Src: 
public List<Tuple<string, double>> CustomerExpensiveOrdersTotalMax() { List<Customer> customers = GetCustomerList(); List<Tuple<string, double>> ordersTotalMax = customers.Select(c => Tuple.Create(c.CustomerId, c.Orders.Where(o => o.Total > 100).Max(o => o.Total))).ToList(); return ordersTotalMax; }
Ref: 
public List<Pair<String, Double>> customerExpensiveOrdersTotalMax() { List<Customer> customers = getCustomerList(); List<Pair<String, Double>> ordersTotalMax = customers.stream().map(c -> Pair.with(c.getCustomerId(), c.getOrders().stream().filter(o -> o.getTotal() > 100) .mapToDouble(o -> o.getTotal()).max().getAsDouble())).toList(); return ordersTotalMax; }
Hyp: 
public List<Pair<String, Double>> customerExpensiveOrdersTotalMax() { List<Customer> customers = getCustomerList(); List<Pair<String, Double>> ordersTotalMax = customers.stream().map(c -> Pair.with(c.getCustomerId(), c.getOrders().stream().filter(o -> o.getTotal() > 100) .mapToDouble(o -> o.getTotal()).max().getAsDouble())).toList(); return ordersTotalMax; }

BLEU: 100.0
Edit Sim: 0


Src: 
public int ProjectedStringElementAt() { string[] strings = { "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine" }; int firstStringLength = strings.Select(s => s.Length) .Where(i => i % 2 == 0).ElementAt(2); return firstStringLength; }
Ref: 
public int projectedStringElementAt() { String[] strings = { "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine" }; int firstStringLength = Arrays.stream(strings).mapToInt(s -> s.length()) .filter(i -> i % 2 == 0).skip(2).findFirst().getAsInt(); return firstStringLength; }
Hyp: 
public int projectedStringElementAt() { String[] strings = {"zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"}; int firstStringLength = Arrays.stream(strings).map(s -> s.length()).filter(i -> i % 2 == 0).skip(2).findFirst().getAsInt(); return firstStringLength; }

BLEU: 62.83
Edit Sim: 8


Src: 
public List<Tuple<string, int>> CustomerEachCountryOrdersMin() { List<Customer> customers = GetCustomerList(); List<Tuple<string, int>> ordersMin = customers.GroupBy(c => c.Country) .Select(g => Tuple.Create(g.Key, g.Min(c => c.Orders.Count))).ToList(); return ordersMin; }
Ref: 
public List<Pair<String, Integer>> customerEachCountryOrdersMin() { List<Customer> customers = getCustomerList(); List<Pair<String, Integer>> ordersMin = customers.stream().collect(groupingBy(c -> c.getCountry())) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().mapToInt(c -> c.getOrders().size()).min().getAsInt())).toList(); return ordersMin; }
Hyp: 
public List<Pair<String, Integer>> customerEachCountryOrdersMin() { List<Customer> customers = getCustomerList(); List<Pair<String, Integer>> ordersMin = customers.stream().collect(groupingBy(c -> c.getCountry())) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().mapToInt(c -> c.getOrders().size()).min().getAsInt())).toList(); return ordersMin; }

BLEU: 100.0
Edit Sim: 0


Src: 
public List<Tuple<string, DateTime>> CustomerOrdersEachNestedSkip() { List<Customer> customers = GetCustomerList(); List<Tuple<string, DateTime>> after3EachOrders = customers .SelectMany(c => c.Orders.Skip(3), (c, o) => Tuple.Create( c.CustomerId, o.OrderDate)).ToList(); return after3EachOrders; }
Ref: 
public List<Pair<String, LocalDate>> customerOrdersEachNestedSkip() { List<Customer> customers = getCustomerList(); List<Pair<String, LocalDate>> after3EachOrders = customers.stream().flatMap(c -> c.getOrders().stream().skip(3) .map(o -> Pair.with(c.getCustomerId(), o.getOrderDate()))).toList(); return after3EachOrders; }
Hyp: 
public List<Pair<String, LocalDate>> customerOrdersEachNestedSkip() { List<Customer> customers = getCustomerList(); List<Pair<String, LocalDate>> after3EachOrders = customers.stream().flatMap(c -> c.getOrders().stream().skip(3) .map(o -> Pair.with(c.getCustomerId(), o.getOrderDate()))).toList(); return after3EachOrders; }

BLEU: 100.0
Edit Sim: 0


Src: 
public int OddNumbersFirstOrDefault() { int[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 }; int firstNum = numbers.FirstOrDefault(n => n % 2 == 1,-2); return firstNum; }
Ref: 
public int oddNumbersFirstOrDefault() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int firstNum = Arrays.stream(numbers).filter(n -> n % 2 == 1).findFirst().orElse(-2); return firstNum; }
Hyp: 
public int oddNumbersFirstOrDefault() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int firstNum = Arrays.stream(numbers).filter(n -> n % 2 == 1).findFirst().orElse(-2); return firstNum; }

BLEU: 100.0
Edit Sim: 0


Src: 
public List<Tuple<string, int>> CustomerExpensiveOrdersCount() { List<Customer> customers = GetCustomerList(); List<Tuple<string, int>> orderCounts = customers.Select(c => Tuple.Create(c.CustomerId, c.Orders.Count(o => o.Total > 100))).ToList(); return orderCounts; }
Ref: 
public List<Pair<String, Integer>> customerExpensiveOrdersCount() { List<Customer> customers = getCustomerList(); List<Pair<String, Integer>> orderCounts = customers.stream().map(c -> Pair.with(c.getCustomerId(), (int) c.getOrders().stream().filter(o -> o.getTotal() > 100).count())).toList(); return orderCounts; }
Hyp: 
public List<Pair<String, Integer>> customerExpensiveOrdersCount() { List<Customer> customers = getCustomerList(); List<Pair<String, Integer>> orderCounts = customers.stream().map(c -> Pair.with(c.getCustomerId(), (int) c.getOrders().stream() .filter(o -> o.getTotal() > 100)).count())).toList(); return orderCounts; }

BLEU: 75.39
Edit Sim: 2


Src: 
public Dictionary<char, List<string>> StringGroupByFirstCharDictOrderbyDescendingCustom() { string[] words = { "aPPLE", "AbAcUs", "bRaNcH", "BlUeBeRrY", "ClOvEr", "cHeRry" }; Dictionary<char, List<string>> wordsGroups = words.GroupBy(w => char.ToLower(w[0])) .ToDictionary(g => g.Key, g => g.OrderByDescending(w=>w,new CaseInsensitiveComparer()).ToList()); return wordsGroups; }
Ref: 
public Map<Character, List<String>> stringGroupByFirstCharDictOrderbyDescendingCustom() { String[] words = {"aPPLE", "AbAcUs", "bRaNcH", "BlUeBeRrY", "ClOvEr", "cHeRry"}; Map<Character, List<String>> wordsGroups = Arrays.stream(words).collect(groupingBy(w -> Character.toLowerCase(w.charAt(0)))) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().sorted(new CaseInsensitiveComparer().reversed()).toList())); return wordsGroups; }
Hyp: 
public Map<Character, List<String>> stringGroupByFirstCharDictOrderbyDescendingCustom() { String[] words = {"aPPLE", "AbAcUs", "bRaNcH", "BlUeBeRrY", "ClOvEr", "cHeRry"}; Map<Character, List<String>> wordsGroups = Arrays.stream(words).collect(groupingBy(w -> Character.toLowerCase(w.charAt(0)))) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().sorted(new CaseInsensitiveComparer().reversed()).toList())); return wordsGroups; }

BLEU: 100.0
Edit Sim: 0


Src: 
public List<int> IntWithSquareIndexedWhere() { int[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 }; List<int> q = numbers.Where((n,i)=>n<i*i).ToList(); return q; }
Ref: 
public List<Integer> intWithSquareIndexedWhere() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; List<Integer> q = IntStream.range(0, numbers.length).filter(i -> numbers[i] < i * i) .map(i -> numbers[i]).boxed().toList(); return q; }
Hyp: 
public List<Integer> intWithSquareIndexedWhere() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; List<Integer> q = IntStream.range(0, numbers.length).filter(i -> numbers[i] < i * numbers[i]).map(i -> numbers[i]).boxed().toList(); return q; }

BLEU: 89.36
Edit Sim: 10


Src: 
public int[] ProjectionIntConcat() { int[] numbersA = { 0, 2, 4, 5, 6, 8, 9 }; int[] numbersB = { 1, 3, 5, 7, 8 }; var first = numbersA.Select(n => n + 1); var second = numbersB.Select(n => n - 1); int[] numbers = first.Concat(second).ToArray(); return numbers; }
Ref: 
public int[] projectionIntConcat() { int[] numbersA = {0, 2, 4, 5, 6, 8, 9}; int[] numbersB = {1, 3, 5, 7, 8}; var first = Arrays.stream(numbersA).map(n -> n + 1); var second = Arrays.stream(numbersB).map(n -> n - 1); int[] allNumbers = IntStream.concat(first, second).toArray(); return allNumbers; }
Hyp: 
public int[] projectionIntConcat() { int[] numbersA = {0, 2, 4, 5, 9}; int[] numbersB = {1, 3, 5, 7, 8}; var first = Arrays.stream(numbersA).map(n -> n + 1); var second = Arrays.stream(numbersB).map(n -> n - 1).toArray(); int[] numbers = IntStream.concat(first, second).toArray(); return numbers; }

BLEU: 78.61
Edit Sim: 24


Src: 
public List<int> RangeOfEvenIntsStartFrom(int start,int count) { List<int> numbers = Enumerable.Range(start, count).Where(n=>n%2==0).ToList(); return numbers; }
Ref: 
public List<Integer> rangeOfEvenIntsStartFrom(int start,int count) { List<Integer> numbers = IntStream.range(start, start+count).filter(n->n%2==0).boxed().toList(); return numbers; }
Hyp: 
public List<Integer> rangeOfEvenIntsStartFrom(int start,int count) { List<Integer> numbers = IntStream.range(start, start+count).filter(n->n% 2 == 0).map(n -> n % 2).boxed().toList(); return numbers; }

BLEU: 52.6
Edit Sim: 19


Src: 
public List<Tuple<string, string>> ProductLeftOuterJoinCategoriesName() { string[] categories = { "Beverages", "Condiments", "Vegetables", "Dairy Products", "Seafood" }; List<Product> products = GetProductList(); List<Tuple<string, string>> q = categories.GroupJoin(products, c => c, p => p.Category, (c, p) => Tuple.Create(c, p)) .SelectMany(t => t.Item2.Select(p=>p.ProductName).DefaultIfEmpty("No Product"), (t, n) => Tuple.Create(t.Item1, n)).ToList(); return q; }
Ref: 
public List<Pair<String, String>> productLeftOuterJoinCategoriesName() { String[] categories = {"Beverages", "Condiments", "Vegetables", "Dairy Products", "Seafood"}; List<Product> products = getProductList(); List<Pair<String, String>> q = Arrays.stream(categories).map( c -> Pair.with(c, products.stream().filter(p -> p.getCategory().equals(c)) .collect(Collectors.toList()))).flatMap(t -> defaultIfEmpty(t.getValue1(), null).stream() .map(p1 -> Pair.with(t.getValue0(), p1!=null?p1.getProductName():"No Product"))).toList(); return q; }
Hyp: 
public List<Pair<String, String>> productLeftOuterJoinCategoriesName() { String[] categories = {"Beverages", "Condiments", "Vegetables", "Dairy Products", "Seafood"}; List<Product> products = getProductList(); List<Pair<String, String>> q = Arrays.stream(categories).map( c -> Pair.with(c, products.stream().filter(p -> p.getCategory().equals(c)) .collect(Collectors.toList()))).flatMap(t -> defaultIfEmpty(t.getValue1(), null).stream() .map(p1 -> Pair.with(t.getValue0(), n))).toList(); return q; }

BLEU: 91.23
Edit Sim: 40


Src: 
public List<Tuple<string,int,double>> CustomerSelectManyCustomerNewOrderIdAndTotals() { List<Customer> customers = GetCustomerList(); List<Tuple<string,int,double>> customerProperties = customers.SelectMany( c=>c.Orders.Where(o=>o.OrderDate>new DateTime(1998, 1, 1)), (c,o)=>Tuple.Create(c.CustomerId, o.OrderId, o.Total)).ToList(); return customerProperties; }
Ref: 
public List<Triplet<String, Integer, Double>> customerSelectManyCustomerNewOrderIdAndTotals() { List<Customer> customers = getCustomerList(); List<Triplet<String, Integer, Double>> customerProperties = customers.stream().flatMap(c -> c.getOrders() .stream().filter(o -> o.getOrderDate().isAfter(LocalDate.of(1998, 1, 1))) .map(o -> Triplet.with(c.getCustomerId(), o.getOrderId(), o.getTotal()))).toList(); return customerProperties; }
Hyp: 
public List<Triplet<String, Integer, Double>> customerSelectManyCustomerNewOrderIdAndTotals() { List<Customer> customers = getCustomerList(); List<Triplet<String, Integer, Double>> customerProperties = customers.stream().flatMap(c -> c.getOrders() .stream().filter(o -> o.getOrderDate().isAfter(LocalDate.of(1998, 1, 1))) .map(o -> Triplet.with(c.getCustomerId(), o.getOrderId(), o.getTotal()))).toList(); return customerProperties; }

BLEU: 100.0
Edit Sim: 0


Src: 
public Dictionary<string, List<Product>> ProductEachCategoryMaxUnitPriceProductsDict() { List<Product> products = GetProductList(); Dictionary<string, List<Product>> categories = products.GroupBy(p => p.Category) .ToDictionary(g => g.Key, g=> g.Where(p => p.UnitPrice == g.Max(p => p.UnitPrice)) .ToList()); return categories; }
Ref: 
public Map<String, List<Product>> productEachCategoryMaxUnitPriceProductsDict() { List<Product> products = getProductList(); Map<String, List<Product>> categories = products.stream().collect(groupingBy(p -> p.getCategory())).entrySet() .stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().collect(groupingBy( p -> p.getUnitPrice())).entrySet().stream().max(Map.Entry.comparingByKey()).get().getValue())); return categories; }
Hyp: 
public Map<String, List<Product>> productEachCategoryMaxUnitPriceProductsDict() { List<Product> products = getProductList(); Map<String, List<Product>> categories = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().collect(groupingBy(p -> p.getUnitPrice())) .entrySet().stream().max(Map.Entry.comparingByKey()).get().getValue())); return categories; }

BLEU: 66.91
Edit Sim: 4


Src: 
public Product ProductFirstOrDefault() { List<Product> products = GetProductList(); Product product12 = products.FirstOrDefault(p => p.ProductId == 12,Product.Default); return product12; }
Ref: 
public Product productFirstOrDefault() { List<Product> products = getProductList(); Product product12 = products.stream().filter(p -> p.getProductId() == 12).findFirst().orElse(Product.DEFAULT); return product12; }
Hyp: 
public Product productFirstOrDefault() { List<Product> products = getProductList(); Product product12 = products.stream().filter(p -> p.getProductId() == 12).findFirst().orElse(Product.DEFAULT); return product12; }

BLEU: 100.0
Edit Sim: 0


Src: 
public int OddFactorOf300Count() { int[] factorsOf300 = { 2, 2, 3, 5, 5 }; int factorsCount = factorsOf300.Count(n => n % 2 == 1); return factorsCount; }
Ref: 
public int oddFactorOf300Count() { int[] factorsOf300 = {2, 2, 3, 5, 5}; int factorsCount = (int) Arrays.stream(factorsOf300).filter(n -> (n % 2 == 1)).count(); return factorsCount; }
Hyp: 
public int oddFactorOf300Count() { int[] factorsOf300 = {2, 2, 3, 5, 5}; int factorsCount = Arrays.stream(factorsOf300).filter(n -> n % 2 == 1).count(); return factorsCount; }

BLEU: 69.78
Edit Sim: 8


Src: 
public List<double> DoubleOrderbyModThenbyDescending() { double[] numbers = { 3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0 }; List<double> sortedNumbers = numbers.OrderBy(n => n % 1.5).ThenByDescending(n => n).ToList(); return sortedNumbers; }
Ref: 
public List<Double> doubleOrderbyModThenbyDescending() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; List<Double> sortedNumbers = Arrays.stream(numbers).boxed().sorted( Comparator.comparing((Double n) -> n % 1.5) .thenComparing(Comparator.reverseOrder())).toList(); return sortedNumbers; }
Hyp: 
public List<Double> doubleOrderbyModThenbyDescending() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; List<Double> sortedNumbers = Arrays.stream(numbers).boxed().sorted( Comparator.comparing((Double n) -> n % 1.5) .thenComparing(Comparator.reverseOrder())).toList(); return sortedNumbers; }

BLEU: 100.0
Edit Sim: 0


Src: 
public double DoubleFirstOrDefault() { double[] numbers = { 3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0 }; double firstNum = numbers.FirstOrDefault(3.14); return firstNum; }
Ref: 
public double doubleFirstOrDefault() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; double firstNum = Arrays.stream(numbers).findFirst().orElse(3.14); return firstNum; }
Hyp: 
public double doubleFirstOrDefault() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; double firstNum = Arrays.stream(numbers).findFirst().orElse(3.14); return firstNum; }

BLEU: 100.0
Edit Sim: 0


Src: 
public List<int> RangeOfEvenIntsStartFrom() { List<int> numbers = Enumerable.Range(100, 100).Where(n=>n%2==0).ToList(); return numbers; }
Ref: 
public List<Integer> rangeOfEvenIntsStartFrom() { List<Integer> numbers = IntStream.range(100, 200).filter(n->n%2==0).boxed().toList(); return numbers; }
Hyp: 
public List<Integer> rangeOfEvenIntsStartFrom() { List<Integer> numbers = IntStream.range(100, 100).filter(n->n% 2 == 0).map(n -> n % 2).boxed().toList(); return numbers; }

BLEU: 47.18
Edit Sim: 20


Src: 
public Dictionary<string, List<Product>> ProductEachCategoryMinUnitPriceProductsDict() { List<Product> products = GetProductList(); Dictionary<string, List<Product>> categories = products.GroupBy(p => p.Category) .ToDictionary(g => g.Key, g=> g.Where(p => p.UnitPrice == g.Min(p => p.UnitPrice)) .ToList()); return categories; }
Ref: 
public Map<String, List<Product>> productEachCategoryMinUnitPriceProductsDict() { List<Product> products = getProductList(); Map<String, List<Product>> categories = products.stream().collect(groupingBy(p -> p.getCategory())).entrySet() .stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().collect(groupingBy( p -> p.getUnitPrice())).entrySet().stream().min(Map.Entry.comparingByKey()).get().getValue())); return categories; }
Hyp: 
public Map<String, List<Product>> productEachCategoryMinUnitPriceProductsDict() { List<Product> products = getProductList(); Map<String, List<Product>> categories = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().collect(groupingBy(p -> p.getUnitPrice())) .entrySet().stream().min(Map.Entry.comparingByKey()).get().getValue())); return categories; }

BLEU: 66.91
Edit Sim: 4


Src: 
public Dictionary<string, double> CustomerOrdersTotalSumDict() { List<Customer> customers = GetCustomerList(); Dictionary<string, double> ordersTotalSum = customers.ToDictionary(c => c.CustomerId, c => c.Orders.Sum(o => o.Total)); return ordersTotalSum; }
Ref: 
public Map<String, Double> customerOrdersTotalSumDict() { List<Customer> customers = getCustomerList(); Map<String, Double> ordersTotalSum = customers.stream().collect(toMap(c -> c.getCustomerId(), c -> c.getOrders().stream().mapToDouble(o -> o.getTotal()).sum())); return ordersTotalSum; }
Hyp: 
public Map<String, Double> customerOrdersTotalSumDict() { List<Customer> customers = getCustomerList(); Map<String, Double> ordersTotalSum = customers.stream().collect(toMap(c -> c.getCustomerId(), c -> c.getOrders().stream().mapToDouble(o -> o.getTotal()).sum())); return ordersTotalSum; }

BLEU: 100.0
Edit Sim: 0


Src: 
public List<Tuple<string,List<Order>>> CustomerIdAndOrders() { List<Customer> customers = GetCustomerList(); List<Tuple<string,List<Order>>> customerProperties = customers.Select(c=> Tuple.Create(c.CustomerId, c.Orders)).ToList(); return customerProperties; }
Ref: 
public List<Pair<String, List<Order>>> customerIdAndOrders() { List<Customer> customers = getCustomerList(); List<Pair<String, List<Order>>> customerProperties = customers.stream().map(c -> Pair.with(c.getCustomerId(), c.getOrders())).toList(); return customerProperties; }
Hyp: 
public List<Pair<String, List<Order>>> customerIdAndOrders() { List<Customer> customers = getCustomerList(); List<Pair<String, List<Order>>> customerProperties = customers.stream().map(c -> Pair.with(c.getCustomerId(), c.getOrders())).toList(); return customerProperties; }

BLEU: 100.0
Edit Sim: 0


Src: 
public List<double> BigDoubleOrderbyModThenby() { double[] numbers = { 3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0 }; List<double> sortedNumbers = numbers.Where(n=>n>3).OrderBy(n => n % 1.5).ThenBy(n => n).ToList(); return sortedNumbers; }
Ref: 
public List<Double> bigDoubleOrderbyModThenby() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; List<Double> sortedNumbers = Arrays.stream(numbers).filter(n->n>3).boxed().sorted( Comparator.comparing((Double n) -> n % 1.5) .thenComparing(Comparator.naturalOrder())).toList(); return sortedNumbers; }
Hyp: 
public List<Double> bigDoubleOrderbyModThenby() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; List<Double> sortedNumbers = Arrays.stream(numbers).filter(n->n>3).boxed().sorted( Comparator.comparing((Double n) -> n % 1.5,Comparator.reverseOrder()) .thenComparing(Comparator.reverseOrder())).toList(); return sortedNumbers; }

BLEU: 88.28
Edit Sim: 32


Src: 
public List<Tuple<string,Order>> CustomerSelectManyCustomerOrders() { List<Customer> customers = GetCustomerList(); List<Tuple<string,Order>> customerProperties = customers.SelectMany(c=>c.Orders, (c,o)=>Tuple.Create(c.CustomerId, o)).ToList(); return customerProperties; }
Ref: 
public List<Pair<String, Order>> customerSelectManyCustomerOrders() { List<Customer> customers = getCustomerList(); List<Pair<String, Order>> customerProperties = customers.stream().flatMap(c -> c.getOrders() .stream().map(o -> Pair.with(c.getCustomerId(), o))).toList(); return customerProperties; }
Hyp: 
public List<Pair<String, Order>> customerSelectManyCustomerOrders() { List<Customer> customers = getCustomerList(); List<Pair<String, Order>> customerProperties = customers.stream().flatMap(c -> c.getOrders() .stream().map(o -> Pair.with(c.getCustomerId(), o))).toList(); return customerProperties; }

BLEU: 100.0
Edit Sim: 0


Src: 
public Dictionary<string, Dictionary<string, Customer>> CustomerNestedGroupByRegionAndName() { List<Customer> customers = GetCustomerList(); Dictionary<string, Dictionary<string, Customer>> customerGroups = customers.GroupBy( c => c.Region).ToDictionary(g => g.Key, g => g.ToDictionary( c => c.CompanyName, c => c)); return customerGroups; }
Ref: 
public Map<String, Map<String, Customer>> customerNestedGroupByRegionAndName() { List<Customer> customers = getCustomerList(); Map<String, Map<String, Customer>> customerGroups = customers.stream().collect(groupingBy(p -> p.getRegion())) .entrySet().stream().collect(toMap( g -> g.getKey(), g -> g.getValue().stream().collect(toMap( c -> c.getCompanyName(), c -> c)))); return customerGroups; }
Hyp: 
public Map<String, Map<String, Customer>> customerNestedGroupByRegionAndName() { List<Customer> customers = getCustomerList(); Map<String, Map<String, Customer>> customerGroups = customers.stream().collect(groupingBy(p -> p.getRegion())) .entrySet().stream().collect(toMap( g -> g.getKey(), g -> g.getValue().stream().collect(groupingBy( c -> c.getCompanyName())))); return customerGroups; }

BLEU: 76.16
Edit Sim: 17


Src: 
public List<Order> CustomerOrdersTakeWhile() { List<Customer> customers = GetCustomerList(); List<Order> firstOrdersWhile = customers.SelectMany(c => c.Orders) .TakeWhile(o => o.OrderDate > new DateTime(2000, 1, 1)).ToList(); return firstOrdersWhile; }
Ref: 
public List<Order> customerOrdersTakeWhile() { List<Customer> customers = getCustomerList(); List<Order> after3Orders = customers.stream().flatMap(c -> c.getOrders().stream()) .takeWhile(o -> o.getOrderDate().isAfter(LocalDate.of(2000, 1, 1))).toList(); return after3Orders; }
Hyp: 
public List<Order> customerOrdersTakeWhile() { List<Customer> customers = getCustomerList(); List<Order> after3Orders = customers.stream().flatMap(c -> c.getOrders().stream()) .takeWhile(o -> o.getOrderDate().isAfter(LocalDate.of(2000, 1, 1))).toList(); return after3Orders; }

BLEU: 100.0
Edit Sim: 0


Src: 
public Dictionary<double, double> ConvertArrayToDictionaryWithDistinctAndPrint() { double[] doubles = { 1.7, 2.3, 1.9, 4.1, 1.7, 2.9 }; Dictionary<double, double> doublesDict = doubles.Distinct().ToDictionary(sr => sr, sr => sr * 2); foreach (var pair in doublesDict) Console.WriteLine(pair.Key + " " + pair.Value); return doublesDict; }
Ref: 
public Map<Double, Double> convertArrayToDictionaryWithDistinctAndPrint() { double[] doubles = {1.7, 2.3, 1.9, 4.1, 1.7, 2.9}; Map<Double, Double> doublesDict = Arrays.stream(doubles).distinct().boxed().collect(toMap( sr -> sr, sr -> sr*2)); for(var pair : doublesDict.entrySet()) System.out.println(pair.getKey() + " " + pair.getValue()); return doublesDict; }
Hyp: 
public Map<Double, Double> convertArrayToDictionaryWithDistinctAndPrint() { double[] doubles = {1.7, 2.3, 1.9, 4.1, 1.7, 2.9}; Map<Double, Double> doublesDict = Arrays.stream(doubles).boxed().collect(groupingBy(sr -> sr * 2)) .entrySet().stream().collect(toMap(pair -> pair.getKey(), pair -> pair.getValue())); return doublesDict; }

BLEU: 51.81
Edit Sim: 89


Src: 
public double[] ProjectionDoubleIntersect() { double[] numbersA = { 0.1, 2.2, 4.3, 5.4, 6.5, 8.6, 9.7 }; double[] numbersB = { 0.1, 3.3, 5.4, 7.7, 8.6 }; var first = numbersA.Select(n => n-(int)n); var second = numbersB.Select(n => n-(int)n); double[] numbers = first.Intersect(second).ToArray(); return numbers; }
Ref: 
public double[] projectionDoubleIntersect() { double[] numbersA = {0.1, 2.2, 4.3, 5.4, 6.5, 8.6, 9.7}; double[] numbersB = {0.1, 3.3, 5.4, 7.7, 8.6}; var first = Arrays.stream(numbersA).map(n -> n - (int) n); var second = Arrays.stream(numbersB).map(n -> n - (int) n); double[] sharedNumbers = first.distinct().filter(a -> second.anyMatch(b -> b == a)).toArray(); return sharedNumbers; }
Hyp: 
public double[] projectionDoubleIntersect() { double[] numbersA = {0.1, 2.2, 4.3, 5.4, 6.5, 8.6, 9.7}; double[] numbersB = {0.1, 3.3, 5.4, 7.7, 8.6}; var first = Arrays.stream(numbersA).map(n -> n - (int) n); var second = Arrays.stream(numbersB).map(n -> n - (int) n); return numbers; }

BLEU: 74.53
Edit Sim: 102


Src: 
public List<Tuple<string, string>> CustomerCrossGroupJoinRegionsPhone() { string[] regions = { "BC", "SP", "OR", "LA" }; List<Customer> customers = GetCustomerList(); List<Tuple<string, string>> q = regions.GroupJoin(customers, r => r, c => c.Region, (r, c) => Tuple.Create(r, c)).SelectMany(t=> t.Item2.Select(c=>c.Phone) ,(t, c) => Tuple.Create(t.Item1, c)).ToList(); return q; }
Ref: 
public List<Pair<String, String>> customerCrossGroupJoinRegionsPhone() { String[] regions = {"BC", "SP", "OR", "LA"}; List<Customer> customers = getCustomerList(); List<Pair<String, String>> q = Arrays.stream(regions).map( r -> Pair.with(r, customers.stream().filter(c -> c.getRegion().equals(r)) .collect(Collectors.toList()))).flatMap(t -> t.getValue1().stream() .map(c1 -> Pair.with(t.getValue0(), c1.getPhone()))).toList(); return q; }
Hyp: 
public List<Pair<String, String>> customerCrossGroupJoinRegionsPhone() { String[] regions = {"BC", "SP", "OR", "LA"}; List<Customer> customers = getCustomerList(); List<Pair<String, String>> q = Arrays.stream(regions).map( r -> Pair.with(r, customers.stream().filter(c -> c.getRegion().equals(r)) .collect(Collectors.toList()))).flatMap(t -> t.getValue1().stream() .map(c1 -> Pair.with(t.getValue0(), c1.getPhone()))).toList(); return q; }

BLEU: 100.0
Edit Sim: 0


Src: 
public List<double> BigDoubleOrderbyDescending() { double[] numbers = { 3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0 }; List<double> sortedNumbers = numbers.Where(n => n > 5).OrderByDescending(n => n).ToList(); return sortedNumbers; }
Ref: 
public List<Double> bigDoubleOrderbyDescending() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; List<Double> sortedNumbers = Arrays.stream(numbers).filter(n -> n > 5).boxed().sorted(Comparator.reverseOrder()).toList(); return sortedNumbers; }
Hyp: 
public List<Double> bigDoubleOrderbyDescending() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; List<Double> sortedNumbers = Arrays.stream(numbers).filter(n -> n > 5).boxed().sorted(Comparator.reverseOrder()).toList(); return sortedNumbers; }

BLEU: 100.0
Edit Sim: 0


Src: 
public List<int> IntTakeWhileIndexed() { int[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 }; List<int> firstNumbers = numbers.TakeWhile((n, i) => n > i).ToList(); return firstNumbers; }
Ref: 
public List<Integer> intTakeWhileIndexed() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; List<Integer> afterNumbers = IntStream.range(0, numbers.length) .takeWhile(i -> numbers[i] > i).map(i -> numbers[i]).boxed().toList(); return afterNumbers; }
Hyp: 
public List<Integer> intTakeWhileIndexed() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; List<Integer> after3Numbers = Arrays.stream(numbers).takeWhile(i -> n > i).boxed().toList(); return after3Numbers; }

BLEU: 58.41
Edit Sim: 56


Src: 
public List<int> IntSkipWhileIndexed() { int[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 }; List<int> afterNumbers = numbers.SkipWhile((n, i) => n > i).ToList(); return afterNumbers; }
Ref: 
public List<Integer> intSkipWhileIndexed() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; List<Integer> afterNumbers = IntStream.range(0, numbers.length) .dropWhile(i -> numbers[i] > i).map(i -> numbers[i]).boxed().toList(); return afterNumbers; }
Hyp: 
public List<Integer> intSkipWhileIndexed() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; List<Integer> afterNumbers = IntStream.range(0, numbers.length) .dropWhile(i -> numbers[i] > i).map(i -> numbers[i]).boxed().toList(); return afterNumbers; }

BLEU: 100.0
Edit Sim: 0


Src: 
public double BigNumbersAverageTwice() { int[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 }; double averageNum = numbers.Where(n => n > 5).Average(n => n * 2); return averageNum; }
Ref: 
public double bigNumbersAverageTwice() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; double averageNum = Arrays.stream(numbers).filter(n -> n >= 5).map(n -> n * 2).average().getAsDouble(); return averageNum; }
Hyp: 
public double bigNumbersAverageTwice() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; double averageNum = Arrays.stream(numbers).filter(n -> n >= 5).map(n -> n * 2).average().getAsDouble(); return averageNum; }

BLEU: 100.0
Edit Sim: 0


Src: 
public Dictionary<string, double> CustomerExpensiveOrdersTotalSumDict() { List<Customer> customers = GetCustomerList(); Dictionary<string, double> ordersTotalSum = customers.ToDictionary(c => c.CustomerId, c => c.Orders.Where(o => o.Total > 100).Sum(o => o.Total)); return ordersTotalSum; }
Ref: 
public Map<String, Double> customerExpensiveOrdersTotalSumDict() { List<Customer> customers = getCustomerList(); Map<String, Double> ordersTotalSum = customers.stream().collect(toMap(c -> c.getCustomerId(), c -> c.getOrders().stream().filter(o -> o.getTotal() > 100) .mapToDouble(o -> o.getTotal()).sum())); return ordersTotalSum; }
Hyp: 
public Map<String, Double> customerExpensiveOrdersTotalSumDict() { List<Customer> customers = getCustomerList(); Map<String, Double> ordersTotalSum = customers.stream().collect(toMap(c -> c.getCustomerId(), c -> c.getOrders().stream().filter(o -> o.getTotal() > 100) .mapToDouble(o -> o.getTotal()).sum())); return ordersTotalSum; }

BLEU: 100.0
Edit Sim: 0


Src: 
public Dictionary<string, List<Product>> ProductEachGroupTake() { List<Product> products = GetProductList(); Dictionary<string, List<Product>> first3EachGroups = products.GroupBy(p => p.Category) .ToDictionary(g => g.Key, g => g.Take(3).ToList()); return first3EachGroups; }
Ref: 
public Map<String, List<Product>> productEachGroupTake() { List<Product> products = getProductList(); Map<String, List<Product>> after3EachGroups = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().limit(3).toList())); return after3EachGroups; }
Hyp: 
public Map<String, List<Product>> productEachGroupTake() { List<Product> products = getProductList(); Map<String, List<Product>> after3EachGroups = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().limit(3).toList())); return after3EachGroups; }

BLEU: 100.0
Edit Sim: 0


Src: 
public double BigDoubleNumbersFirst() { double[] numbers = { 3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0 }; double firstNum = numbers.First(d => d > 5); return firstNum; }
Ref: 
public double bigDoubleNumbersFirst() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; double firstNum = Arrays.stream(numbers).filter(d -> d > 5).findFirst().getAsDouble(); return firstNum; }
Hyp: 
public double bigDoubleNumbersFirst() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; double firstNum = Arrays.stream(numbers).filter(n -> n >= 5).findFirst().getAsDouble(); return firstNum; }

BLEU: 80.44
Edit Sim: 3


Src: 
public double ProductUnitPriceMin() { List<Product> products = GetProductList(); double minUnitPrice = products.Min(p => p.UnitPrice); return minUnitPrice; }
Ref: 
public double productUnitPriceMin() { List<Product> products = getProductList(); double minUnitPrice = products.stream().mapToDouble(p -> p.getUnitPrice()).min().getAsDouble(); return minUnitPrice; }
Hyp: 
public double productUnitPriceMin() { List<Product> products = getProductList(); double minUnitPrice = products.stream().mapToDouble(p -> p.getUnitPrice()).min().getAsDouble(); return minUnitPrice; }

BLEU: 100.0
Edit Sim: 0


Src: 
public List<Tuple<string, string>> CustomerLeftOuterJoinRegionsName() { string[] regions = { "BC", "SP", "OR", "LA" }; List<Customer> customers = GetCustomerList(); List<Tuple<string, string>> q = regions.GroupJoin(customers, r => r, c => c.Region, (r, c) => Tuple.Create(r, c)).SelectMany(t=> t.Item2.Select(c=>c.CompanyName).DefaultIfEmpty("No Customer") ,(t, c) => Tuple.Create(t.Item1, c)).ToList(); return q; }
Ref: 
public List<Pair<String, String>> customerLeftOuterJoinRegionsName() { String[] regions = {"BC", "SP", "OR", "LA"}; List<Customer> customers = getCustomerList(); List<Pair<String, String>> q = Arrays.stream(regions).map( r -> Pair.with(r, customers.stream().filter(c -> c.getRegion().equals(r)) .collect(Collectors.toList()))).flatMap(t -> defaultIfEmpty(t.getValue1(), null).stream() .map(p1 -> Pair.with(t.getValue0(), p1!=null?p1.getCompanyName():"No Customer"))).toList(); return q; }
Hyp: 
public List<Pair<String, String>> customerLeftOuterJoinRegionsName() { String[] regions = {"BC", "SP", "OR", "LA"}; List<Customer> customers = getCustomerList(); List<Pair<String, String>> q = Arrays.stream(regions).map( r -> Pair.with(r, customers.stream().filter(c -> c.getRegion().equals(r)) .collect(Collectors.toList()))).flatMap(t -> defaultIfEmpty(t.getValue1(), null).stream() .map(c1 -> Pair.with(t.getValue0(), c1.getCompanyName()))).toList(); return q; }

BLEU: 84.74
Edit Sim: 25


Src: 
public int ProjectedBigNumbersFirst() { int[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 }; int firstNum = numbers.Select(i => (int)Math.Pow(2, i)).First(n => n > 100); return firstNum; }
Ref: 
public int projectedBigNumbersFirst() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int firstNum = Arrays.stream(numbers).map(i -> (int) Math.pow(2, i)).filter(n -> n > 100).findFirst().getAsInt(); return firstNum; }
Hyp: 
public int projectedBigNumbersFirst() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int firstNum = Arrays.stream(numbers).map(i -> (int) Math.pow(2, i)).filter(n -> n > 100).findFirst().orElse(100); return firstNum; }

BLEU: 91.85
Edit Sim: 9


Src: 
public Dictionary<int, Dictionary<int, List<Order>>> CustomerNestedGroupByOrderYearAndMonth() { List<Customer> customers = GetCustomerList(); Dictionary<int, Dictionary<int, List<Order>>> customerOrderGroups = customers.SelectMany(c => c.Orders) .GroupBy(o => o.OrderDate.Year).ToDictionary( yg => yg.Key, yg => yg.GroupBy(o => o.OrderDate.Month).ToDictionary( mg => mg.Key, mg => mg.ToList()) ); return customerOrderGroups; }
Ref: 
public Map<Integer, Map<Integer, List<Order>>> customerNestedGroupByOrderYearAndMonth() { List<Customer> customers = getCustomerList(); Map<Integer, Map<Integer, List<Order>>> customerOrderGroups = customers.stream().flatMap(c -> c.getOrders().stream()) .collect(groupingBy(o -> o.getOrderDate().getYear())).entrySet().stream().collect(toMap( g -> g.getKey(), g -> g.getValue().stream().collect(groupingBy( o -> o.getOrderDate().getMonthValue() )))); return customerOrderGroups; }
Hyp: 
public Map<Integer, Map<Integer, List<Order>>> customerNestedGroupByOrderYearAndMonth() { List<Customer> customers = getCustomerList(); Map<Integer, Map<Integer, List<Order>>> customerOrderGroups = customers.stream().flatMap(c -> c.getOrders().stream()) .collect(groupingBy(o -> o.getOrderDate().getYear())).entrySet().stream().collect(toMap( g -> g.getKey(), g -> g.getValue().stream().collect(groupingBy(o -> o.getOrderDate().getMonthValue())))); return customerOrderGroups; }

BLEU: 80.96
Edit Sim: 2


Src: 
public List<Tuple<string, List<Product>>> ProductEachCategoryFirstOrDefaultUnitPriceProducts() { List<Product> products = GetProductList(); List<Tuple<string, List<Product>>> categories = products.GroupBy(p => p.Category) .Select(g => Tuple.Create(g.Key, g.Where(p => p.UnitPrice == g.FirstOrDefault(Product.Default).UnitPrice) .ToList())).ToList(); return categories; }
Ref: 
public List<Pair<String, List<Product>>> productEachCategoryFirstOrDefaultUnitPriceProducts() { List<Product> products = getProductList(); List<Pair<String, List<Product>>> categories = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().filter(p -> p.getUnitPrice() == g.getValue().stream().findFirst().orElse(Product.DEFAULT).getUnitPrice()).toList())).toList(); return categories; }
Hyp: 
public List<Pair<String, List<Product>>> productEachCategoryFirstOrDefaultUnitPriceProducts() { List<Product> products = getProductList(); List<Pair<String, List<Product>>> categories = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().filter( p -> p.getUnitPrice() == g.getValue().stream().findFirst().orElse(Product.DEFAULT).getUnitPrice())) .entrySet().stream().findFirst().orElse(Product.DEFAULT).getUnitPrice()))).toList(); return categories; }

BLEU: 74.56
Edit Sim: 68


Src: 
public bool StringAnyMatch(char c) { string[] words = { "cherry", "apple", "blueberry", "banana", "abacus" }; bool anyMatch = words.Any(w => w[0] > c); return anyMatch; }
Ref: 
public boolean stringAnyMatch(char c) { String[] words = {"cherry", "apple", "blueberry", "banana", "abacus"}; boolean anyMatch = Arrays.stream(words).anyMatch(w -> w.charAt(0) > c); return anyMatch; }
Hyp: 
public boolean stringAnyMatch(char c) { String[] words = {"cherry", "apple", "blueberry", "banana", "abacus"}; boolean anyMatch = Arrays.stream(words).anyMatch(w -> w.charAt(0) > c); return anyMatch; }

BLEU: 100.0
Edit Sim: 0


Src: 
public Dictionary<string, double> CustomerEachRegionOrdersTotalMaxDict() { List<Customer> customers = GetCustomerList(); Dictionary<string, double> ordersTotalMax = customers.GroupBy(c => c.Region) .ToDictionary(g => g.Key, g => g.SelectMany(c => c.Orders).Max(o => o.Total)); return ordersTotalMax; }
Ref: 
public Map<String, Double> customerEachRegionOrdersTotalMaxDict() { List<Customer> customers = getCustomerList(); Map<String, Double> ordersTotalMax = customers.stream().collect(groupingBy(c -> c.getRegion())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().flatMap(c -> c.getOrders().stream()).mapToDouble(o -> o.getTotal()).max().getAsDouble())); return ordersTotalMax; }
Hyp: 
public Map<String, Double> customerEachRegionOrdersTotalMaxDict() { List<Customer> customers = getCustomerList(); Map<String, Double> ordersTotalMax = customers.stream().collect(groupingBy(c -> c.getRegion())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().flatMap(c -> c.getOrders().stream()).mapToDouble(o -> o.getTotal()).max().getAsDouble())); return ordersTotalMax; }

BLEU: 100.0
Edit Sim: 0


Src: 
public List<Tuple<double, List<double>>> DoubleGroupByMod() { double[] numbers = { 5.8, 4.3, 1.5, 3.7, 9.3 }; List<Tuple<double, List<double>>> numberGroups = numbers.GroupBy(n => n % 1.5) .Select(g => Tuple.Create(g.Key, g.ToList())).ToList(); return numberGroups; }
Ref: 
public List<Pair<Double, List<Double>>> doubleGroupByMod() { double[] numbers = {5.8, 4.3, 1.5, 3.7, 9.3}; List<Pair<Double, List<Double>>> numberGroups = Arrays.stream(numbers).boxed().collect(groupingBy(n -> n % 1.5)) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue())).toList(); return numberGroups; }
Hyp: 
public List<Pair<Double, List<Double>>> doubleGroupByMod() { double[] numbers = {5.8, 4.3, 1.5, 3.7, 9.3}; List<Pair<Double, List<Double>>> numberGroups = numberGroups = Arrays.stream(numbers).boxed().collect(groupingBy(n -> n % 1.5)); return numberGroups; }

BLEU: 75.73
Edit Sim: 91


Src: 
public Dictionary<string, int> CustomerEachRegionOrdersMinDict() { List<Customer> customers = GetCustomerList(); Dictionary<string, int> ordersMin = customers.GroupBy(c => c.Region) .ToDictionary(g => g.Key, g => g.Min(c => c.Orders.Count)); return ordersMin; }
Ref: 
public Map<String, Integer> customerEachRegionOrdersMinDict() { List<Customer> customers = getCustomerList(); Map<String, Integer> ordersMin = customers.stream().collect(groupingBy(c -> c.getRegion())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().mapToInt(c -> c.getOrders().size()).min().getAsInt())); return ordersMin; }
Hyp: 
public Map<String, Integer> customerEachRegionOrdersMinDict() { List<Customer> customers = getCustomerList(); Map<String, Integer> ordersMin = customers.stream().collect(groupingBy(c -> c.getRegion())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().mapToInt(c -> c.getOrders().size()).min().getAsInt())); return ordersMin; }

BLEU: 100.0
Edit Sim: 0


Src: 
public int BigNumbersSumTwice() { int[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 }; int numbersSum = numbers.Where(n => n > 5).Sum(n => n * 2); return numbersSum; }
Ref: 
public int bigNumbersSumTwice() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int numbersSum = Arrays.stream(numbers).filter(n -> n >= 5).map(n -> n * 2).sum(); return numbersSum; }
Hyp: 
public int bigNumbersSumTwice() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int numbersSum = Arrays.stream(numbers).filter(n -> n >= 5).map(n -> n * 2).sum(); return numbersSum; }

BLEU: 100.0
Edit Sim: 0


Src: 
public List<int> IntSquareSkipWhile() { int[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 }; List<int> afterNumbersWhile = numbers.Select(i => i * i).SkipWhile(i => i > 3).ToList(); return afterNumbersWhile; }
Ref: 
public List<Integer> intSquareSkipWhile() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; List<Integer> after3Numbers = Arrays.stream(numbers).map(i -> i * i).dropWhile(i -> i > 3).boxed().toList(); return after3Numbers; }
Hyp: 
public List<Integer> intSquareSkipWhile() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; List<Integer> after3Numbers = Arrays.stream(numbers).map(i -> i * i).dropWhile(i -> i > 3).boxed().toList(); return after3Numbers; }

BLEU: 100.0
Edit Sim: 0


Src: 
public Dictionary<string, bool> ProductEachGroupAllMatch() { List<Product> products = GetProductList(); Dictionary<string, bool> allMatch = products.GroupBy(p => p.Category) .ToDictionary(g => g.Key, g => g.All(p => p.UnitsInStock > 0)); return allMatch; }
Ref: 
public Map<String, Boolean> productEachGroupAllMatch() { List<Product> products = getProductList(); Map<String, Boolean> allMatch = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().allMatch(p -> p.getUnitsInStock() > 0))); return allMatch; }
Hyp: 
public Map<String, Boolean> productEachGroupAllMatch() { List<Product> products = getProductList(); Map<String, Boolean> allMatch = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().allMatch(p -> p.getUnitsInStock() > 0)); return allMatch; }

BLEU: 90.96
Edit Sim: 1


Src: 
public bool LongStringAnyMatch() { string[] words = { "cherry", "apple", "blueberry", "banana", "abacus" }; bool anyMatch = words.Where(w => w.Length > 5).Any(n => string.CompareOrdinal(n, "b") > 0); return anyMatch; }
Ref: 
public boolean longStringAnyMatch() { String[] words = {"cherry", "apple", "blueberry", "banana", "abacus"}; boolean anyMatch = Arrays.stream(words).filter(w -> w.length() > 5).anyMatch(n -> n.compareTo("b") > 0); return anyMatch; }
Hyp: 
public boolean longStringAnyMatch() { String[] words = {"cherry", "apple", "blueberry", "banana", "abacus"}; boolean anyMatch = Arrays.stream(words).filter(w -> w.length() > 5).anyMatch(n -> n.compareTo("b") > 0); return anyMatch; }

BLEU: 100.0
Edit Sim: 0


Src: 
public List<Product> ProductOrderbyDescendingName() { List<Product> products = GetProductList(); List<Product> sortedProducts = products.OrderByDescending(p => p.ProductName).ToList(); return sortedProducts; }
Ref: 
public List<Product> productOrderbyDescendingName() { List<Product> products = getProductList(); List<Product> sortedProducts = products.stream().sorted( Comparator.comparing(p -> p.getProductName(), Comparator.reverseOrder())).toList(); return sortedProducts; }
Hyp: 
public List<Product> productOrderbyDescendingName() { List<Product> products = getProductList(); List<Product> sortedProducts = products.stream().sorted(Comparator.comparing( p -> p.getProductName(), Comparator.reverseOrder())).toList(); return sortedProducts; }

BLEU: 80.32
Edit Sim: 2


Src: 
public bool[] BigIntWithIndex() { int[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 }; bool[] numSelected = numbers.Where(n => n > 5).Select((n, i) => n == i).ToArray(); return numSelected; }
Ref: 
public Boolean[] bigIntWithIndex() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int[] bigNumbers = Arrays.stream(numbers).filter(n -> n > 5).toArray(); Boolean[] numSelected = (Boolean[]) IntStream.range(0, bigNumbers.length).mapToObj(i -> bigNumbers[i] == i).toArray(); return numSelected; }
Hyp: 
public boolean[] bigIntWithIndex() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; boolean[] bigNumbers = Arrays.stream(numbers).filter(n -> n > 5).toArray(); boolean[] numSelected = IntStream.range(0, bigNumbers.length).filter(i -> bigNumbers[i] == i).map(i -> bigNumbers[i]).toArray(); return numSelected; }

BLEU: 61.13
Edit Sim: 53


Src: 
public double ProductUnitPriceTotalSum() { List<Product> products = GetProductList(); double totalSum = products.Sum(p => p.UnitPrice); return totalSum; }
Ref: 
public double productUnitPriceSum() { List<Product> products = getProductList(); double totalSum = products.stream().mapToDouble(p -> p.getUnitPrice()).sum(); return totalSum; }
Hyp: 
public double productUnitPriceTotalSum() { List<Product> products = getProductList(); double totalSum = products.stream().mapToDouble(p -> p.getUnitPrice()).sum(); return totalSum; }

BLEU: 85.79
Edit Sim: 5


Src: 
public List<Tuple<string, Customer>> CustomerLeftOuterJoinRegions() { string[] regions = { "BC", "SP", "OR", "LA" }; List<Customer> customers = GetCustomerList(); List<Tuple<string, Customer>> q = regions.GroupJoin(customers, r => r, c => c.Region, (r, c) => Tuple.Create(r, c)).SelectMany(t=>t.Item2.DefaultIfEmpty(null) ,(t, c) => Tuple.Create(t.Item1, c)).ToList(); return q; }
Ref: 
public List<Pair<String, Customer>> customerLeftOuterJoinRegions() { String[] regions = {"BC", "SP", "OR", "LA"}; List<Customer> customers = getCustomerList(); List<Pair<String, Customer>> q = Arrays.stream(regions).map( r -> Pair.with(r, customers.stream().filter(c -> c.getRegion().equals(r)) .collect(Collectors.toList()))).flatMap(t -> defaultIfEmpty(t.getValue1(), null).stream() .map(p1 -> Pair.with(t.getValue0(), p1))).toList(); return q; }
Hyp: 
public List<Pair<String, Customer>> customerLeftOuterJoinRegions() { String[] regions = {"BC", "SP", "OR", "LA"}; List<Customer> customers = getCustomerList(); List<Pair<String, Customer>> q = Arrays.stream(regions).map( r -> Pair.with(r, customers.stream().filter(c -> c.getRegion().equals(r)) .collect(Collectors.toList()))).flatMap(t -> defaultIfEmpty(t.getValue1(), null).stream() .map(c1 -> Pair.with(t.getValue0(), c1))).toList(); return q; }

BLEU: 87.0
Edit Sim: 2


Src: 
public Dictionary<string, int> CustomerNewOrdersCountDict() { List<Customer> customers = GetCustomerList(); Dictionary<string, int> orderCounts = customers.ToDictionary( c => c.CustomerId, c => c.Orders.Count( o => o.OrderDate > new DateTime(2000, 1, 1))); return orderCounts; }
Ref: 
public Map<String, Integer> customerNewOrdersCountDict() { List<Customer> customers = getCustomerList(); Map<String, Integer> orderCounts = customers.stream().collect(toMap( c -> c.getCustomerId(), c -> (int) c.getOrders().stream() .filter(o -> o.getOrderDate().isAfter(LocalDate.of(2000, 1, 1))).count())); return orderCounts; }
Hyp: 
public Map<String, Integer> customerNewOrdersCountDict() { List<Customer> customers = getCustomerList(); Map<String, Integer> orderCounts = customers.stream().collect(toMap( c -> c.getCustomerId(), c -> (int) c.getOrders().stream() .filter(o -> o.getOrderDate().isAfter(LocalDate.of(2000, 1, 1))).count())); return orderCounts; }

BLEU: 100.0
Edit Sim: 0


Src: 
public List<string> StringOrderbyLength() { string[] words = { "cherry", "apple", "blueberry" }; List<string> sortedWords = words.OrderBy(w => w.Length).ToList(); return sortedWords; }
Ref: 
public List<String> stringOrderbyLength() { String[] words = {"cherry", "apple", "blueberry"}; List<String> sortedWords = Arrays.stream(words).sorted(Comparator.comparing(w -> w.length())).toList(); return sortedWords; }
Hyp: 
public List<String> stringOrderbyLength() { String[] words = {"cherry", "apple", "blueberry"}; List<String> sortedWords = Arrays.stream(words).sorted(Comparator.comparing(w -> w.length())).toList(); return sortedWords; }

BLEU: 100.0
Edit Sim: 0


Src: 
public string[] SelectByCaseConcat() { string[] words = { "aPPLE", "BlUeBeRrY", "cHeRry" }; string[] upperLowerWords = words.Select(w => w.ToUpper() + w.ToLower()).ToArray(); return upperLowerWords; }
Ref: 
public String[] selectByCaseConcat() { String[] words = {"aPPLE", "BlUeBeRrY", "cHeRry"}; String[] upperLowerWords = (String[]) Arrays.stream(words).map(w -> w.toUpperCase() + w.toLowerCase()).toArray(); return upperLowerWords; }
Hyp: 
public String[] selectByCaseConcat() { String[] words = {"aPPLE", "BlUeBeRrY", "cHeRry"}; String[] upperLowerWords = Arrays.stream(words).map(w -> w.toLowerCase() + w.toLowerCase()).toArray(); return upperLowerWords; }

BLEU: 76.75
Edit Sim: 14


Src: 
public List<Product> ProductOrderbyDescendingId() { List<Product> products = GetProductList(); List<Product> sortedProducts = products.OrderByDescending(p => p.ProductId).ToList(); return sortedProducts; }
Ref: 
public List<Product> productOrderbyDescendingId() { List<Product> products = getProductList(); List<Product> sortedProducts = products.stream().sorted( Comparator.comparing(p -> p.getProductId(), Comparator.reverseOrder())).toList(); return sortedProducts; }
Hyp: 
public List<Product> productOrderbyDescendingId() { List<Product> products = getProductList(); List<Product> sortedProducts = products.stream().sorted(Comparator.comparing( p -> p.getProductId(), Comparator.reverseOrder())).toList(); return sortedProducts; }

BLEU: 80.32
Edit Sim: 2


Src: 
public Dictionary<string, List<Product>> ProductsConvertGroupingToDictionaryAndPrint() { List<Product> products = GetProductList(); Dictionary<string, List<Product>> catagory = products.GroupBy(p => p.Category).ToDictionary( g => g.Key, g => g.ToList()); foreach (var pair in catagory) { Console.WriteLine(pair.Key + ":"); foreach (var product in pair.Value) Console.WriteLine("\t" + product); } return catagory; }
Ref: 
public Map<String, List<Product>> productsConvertGroupingToDictionaryAndPrint() { List<Product> products = getProductList(); Map<String, List<Product>> catagory = products.stream().collect(groupingBy( p ->p.getCategory())); for(var pair : catagory.entrySet()) { System.out.println(pair.getKey() + ":"); for(var product : pair.getValue()) System.out.println("\t" + product); } return catagory; }
Hyp: 
public Map<String, List<Product>> productsConvertGroupingToDictionaryAndPrint() { List<Product> products = getProductList(); Map<String, List<Product>> catagory = products.stream().collect(groupingBy(p -> p.getCategory())); for (var pair : catagory.entrySet()) { System.out.println(pair.getKey() + ":"); for (var product : pair.getValue().stream()) System.out.println("\t" + product); } return catagory; }

BLEU: 65.5
Edit Sim: 13


Src: 
public List<Tuple<string, double>> CustomerOrdersTotalSum() { List<Customer> customers = GetCustomerList(); List<Tuple<string, double>> ordersTotalSum = customers.Select(c => Tuple.Create(c.CustomerId, c.Orders.Sum(o => o.Total))).ToList(); return ordersTotalSum; }
Ref: 
public List<Pair<String, Double>> customerOrdersTotalSum() { List<Customer> customers = getCustomerList(); List<Pair<String, Double>> ordersTotalSum = customers.stream().map(c -> Pair.with(c.getCustomerId(), c.getOrders().stream().mapToDouble(o -> o.getTotal()).sum())).toList(); return ordersTotalSum; }
Hyp: 
public List<Pair<String, Double>> customerOrdersTotalSum() { List<Customer> customers = getCustomerList(); List<Pair<String, Double>> ordersTotalSum = customers.stream().map(c -> Pair.with(c.getCustomerId(), c.getOrders().stream().mapToDouble(o -> o.getTotal()).sum())).toList(); return ordersTotalSum; }

BLEU: 100.0
Edit Sim: 0


Src: 
public List<Tuple<int, string>> CustomerCrossJoinRegionsWithCodeName() { List<Tuple<string, int>> regions = new List<Tuple<string, int>>{ Tuple.Create("BC", 101), Tuple.Create("BC", 105), Tuple.Create("OR", 121), Tuple.Create("LA", 143) }; List<Customer> customers = GetCustomerList(); List<Tuple<int, string>> q = regions.Join(customers, r => r.Item1, c => c.Region, (r, c) => Tuple.Create(r.Item2, c.CompanyName)).ToList(); return q; }
Ref: 
public List<Pair<Integer, String>> customerCrossJoinRegionsWithCodeName() { List<Pair<String, Integer>> regions = Arrays.asList( Pair.with("BC", 101), Pair.with("BC", 105), Pair.with("OR", 121), Pair.with("LA", 143) ); List<Customer> customers = getCustomerList(); List<Pair<Integer, String>> q = regions.stream().flatMap( r -> customers.stream().filter(c -> c.getRegion().equals(r.getValue0())).map( c -> Pair.with(r.getValue1(), c.getCompanyName()))).toList(); return q; }
Hyp: 
public List<Pair<Integer, String>> customerCrossJoinRegionsWithCodeName() { List<Pair<String, Integer>> regions = Arrays.asList( Pair.with("BC", 101), Pair.with("BC", 105), Pair.with("OR", 121), Pair.with("LA", 143) ); List<Customer> customers = getCustomerList(); List<Pair<Integer, String>> q = regions.stream().map( r -> Pair.with(r.getValue1(), customers.stream().filter(c -> c.getRegion().equals(r.getValue0())).toList())).toList(); return q; }

BLEU: 75.06
Edit Sim: 80


Src: 
public double BigNumbersAggregateMultiplyWithSeed() { double[] numbers = { 1.7, 2.3, 1.9, 4.1, 2.9 }; double seed = 1.6; double product = numbers.Where(n => n > 2).Aggregate(seed, (a, b) => a * b); return product; }
Ref: 
public double bigNumbersAggregateMultiplyWithSeed() { double[] numbers = {1.7, 2.3, 1.9, 4.1, 2.9}; double seed = 1.6; double product = Arrays.stream(numbers).filter(n -> n > 2).reduce(seed, (a, b) -> a * b); return product; }
Hyp: 
public double bigNumbersAggregateMultiplyWithSeed() { double[] numbers = {1.7, 2.3, 1.9, 4.1, 2.9}; double seed = 1.6; double product = Arrays.stream(numbers).filter(n -> n >= 2).reduce(seed, b -> a * b).getAsDouble(); return product; }

BLEU: 75.35
Edit Sim: 20


Src: 
public int ProjectedStringFirst() { string[] strings = { "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine" }; int firstStringLength = strings.Select(s => s.Length).First(i => i % 2 == 0); return firstStringLength; }
Ref: 
public int projectedStringFirst() { String[] strings = {"zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"}; int firstStringLength = Arrays.stream(strings).mapToInt(s -> s.length()).filter(i -> i % 2 == 0).findFirst().getAsInt(); return firstStringLength; }
Hyp: 
public int projectedStringFirst() { String[] strings = {"zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"}; int firstStringLength = Arrays.stream(strings).map(s -> s.length()).filter(i -> i % 2 == 0).findFirst().getAsInt(); return firstStringLength; }

BLEU: 91.85
Edit Sim: 5


Src: 
public bool ProductAnyMatch() { List<Product> products = GetProductList(); bool anyMatch = products.Any(p => p.UnitsInStock > 0); return anyMatch; }
Ref: 
public boolean productAnyMatch() { List<Product> products = getProductList(); boolean anyMatch = products.stream().anyMatch(p -> p.getUnitsInStock() > 0); return anyMatch; }
Hyp: 
public boolean productAnyMatch() { List<Product> products = getProductList(); boolean anyMatch = products.stream().anyMatch(p -> p.getUnitsInStock() > 0); return anyMatch; }

BLEU: 100.0
Edit Sim: 0


Src: 
public List<Tuple<string,int,double>> CustomerSelectManyCustomerOrderIdAndTotals() { List<Customer> customers = GetCustomerList(); List<Tuple<string,int,double>> customerProperties = customers.SelectMany(c=>c.Orders, (c,o)=>Tuple.Create(c.CustomerId, o.OrderId, o.Total)).ToList(); return customerProperties; }
Ref: 
public List<Triplet<String, Integer, Double>> customerSelectManyCustomerOrderIdAndTotals() { List<Customer> customers = getCustomerList(); List<Triplet<String, Integer, Double>> customerProperties = customers.stream().flatMap(c -> c.getOrders() .stream().map(o -> Triplet.with(c.getCustomerId(), o.getOrderId(), o.getTotal()))).toList(); return customerProperties; }
Hyp: 
public List<Triplet<String, Integer, Double>> customerSelectManyCustomerOrderIdAndTotals() { List<Customer> customers = getCustomerList(); List<Triplet<String, Integer, Double>> customerProperties = customers.stream().flatMap(c -> c.getOrders() .stream().map(o -> Triplet.with(c.getCustomerId(), o.getOrderId(), o.getTotal()))).toList(); return customerProperties; }

BLEU: 100.0
Edit Sim: 0


Src: 
public int NumbersSum() { int[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 }; int numbersSum = numbers.Sum(); return numbersSum; }
Ref: 
public int numbersSum() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int numbersSum = Arrays.stream(numbers).sum(); return numbersSum; }
Hyp: 
public int numbersSum() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int numbersSum = Arrays.stream(numbers).sum(); return numbersSum; }

BLEU: 100.0
Edit Sim: 0


Src: 
public char[] ShortStringFirstChar() { string[] strings = { "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine" }; char[] selected = strings.Where(w => w.Length < 4).Select(w => w[0]).ToArray(); return selected; }
Ref: 
public Character[] shortStringFirstChar() { String[] strings = {"zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"}; Character[] selected = (Character[]) Arrays.stream(strings).filter(w -> w.length() < 4) .map(w -> w.charAt(0)).toArray(); return selected; }
Hyp: 
public char[] shortStringFirstChar() { String[] strings = {"zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"}; char[] selected = Arrays.stream(strings).filter(w -> w.length() < 4).map(w -> w.charAt(0)).toArray(); return selected; }

BLEU: 66.75
Edit Sim: 27


Src: 
public int[] OddFactorOf300And900Count() { int[][] factorsOf300And900 = { new[] { 2, 2, 3, 5, 5 }, new[] { 2, 2, 3, 3, 5, 5 } }; int[] factorsCount = factorsOf300And900.Select( a => a.Count(n => n % 2 == 1)).ToArray(); return factorsCount; }
Ref: 
public int[] oddFactorOf300And900Count() { int[][] factorsOf300And900 = { {2, 2, 3, 5, 5}, {2, 2, 3, 3, 5, 5} }; int[] factorsCount = Arrays.stream(factorsOf300And900) .mapToInt(a -> (int) Arrays.stream(a).filter(n -> n % 2 == 1).count()).toArray(); return factorsCount; }
Hyp: 
public int[] oddFactorOf300And900Count() { int[] factorsOf300And900 = {new[] {2, 2, 3, 5, 5}; int[] factorsCount = Arrays.stream(factorsOf300And900).map(a -> a.length() % 2 == 1).toArray(); return factorsCount; }

BLEU: 23.57
Edit Sim: 70


Src: 
public List<Tuple<string, double>> CustomerEachRegionOrdersTotalSum() { List<Customer> customers = GetCustomerList(); List<Tuple<string, double>> ordersTotalSum = customers.GroupBy(c => c.Region) .Select(g=>Tuple.Create(g.Key, g.SelectMany(c=>c.Orders).Sum(o => o.Total))).ToList(); return ordersTotalSum; }
Ref: 
public List<Pair<String, Double>> customerEachRegionOrdersTotalSum() { List<Customer> customers = getCustomerList(); List<Pair<String, Double>> ordersTotalSum = customers.stream().collect(groupingBy(c -> c.getRegion())) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().flatMap(c -> c.getOrders().stream()).mapToDouble(o -> o.getTotal()).sum())).toList(); return ordersTotalSum; }
Hyp: 
public List<Pair<String, Double>> customerEachRegionOrdersTotalSum() { List<Customer> customers = getCustomerList(); List<Pair<String, Double>> ordersTotalSum = customers.stream().collect(groupingBy(c -> c.getRegion())) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().flatMap(c -> c.getOrders().stream()).mapToDouble(o -> o.getTotal()).sum())).toList(); return ordersTotalSum; }

BLEU: 100.0
Edit Sim: 0


Src: 
public int[] IntPlusOne() { int[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 }; int[] numSelected = numbers.Select(n => n + 1).ToArray(); return numSelected; }
Ref: 
public int[] intPlusOne() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int[] numSelected = Arrays.stream(numbers).map(n -> n + 1).toArray(); return numSelected; }
Hyp: 
public int[] intPlusOne() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int[] numSelected = IntStream.range(0, numbers.length).map(n -> numbers[n] + 1).toArray(); return numSelected; }

BLEU: 81.14
Edit Sim: 32


Src: 
public List<Tuple<string, Customer>> CustomerCrossGroupJoinRegions() { string[] regions = { "BC", "SP", "OR", "LA" }; List<Customer> customers = GetCustomerList(); List<Tuple<string, Customer>> q = regions.GroupJoin(customers, r => r, c => c.Region, (r, c) => Tuple.Create(r, c)).SelectMany(t=>t.Item2 ,(t, c) => Tuple.Create(t.Item1, c)).ToList(); return q; }
Ref: 
public List<Pair<String, Customer>> customerCrossGroupJoinRegions() { String[] regions = {"BC", "SP", "OR", "LA"}; List<Customer> customers = getCustomerList(); List<Pair<String, Customer>> q = Arrays.stream(regions).map( r -> Pair.with(r, customers.stream().filter(c -> c.getRegion().equals(r)) .collect(Collectors.toList()))).flatMap(t -> t.getValue1().stream() .map(c1 -> Pair.with(t.getValue0(), c1))).toList(); return q; }
Hyp: 
public List<Pair<String, Customer>> customerCrossGroupJoinRegions() { String[] regions = {"BC", "SP", "OR", "LA"}; List<Customer> customers = getCustomerList(); List<Pair<String, Customer>> q = Arrays.stream(regions).map( r -> Pair.with(r, customers.stream().filter(c -> c.getRegion().equals(r)) .collect(Collectors.toList()))).flatMap(t -> t.getValue1().stream() .map(c1 -> Pair.with(t.getValue0(), c1))).toList(); return q; }

BLEU: 100.0
Edit Sim: 0


Src: 
public bool WaCustomerOrdersNestedAnyMatch() { List<Customer> customers = GetCustomerList(); bool anyMatch = customers.Where(c=>c.Region=="WA").SelectMany(c => c.Orders, (c, o) => Tuple.Create( c.CustomerId, o.OrderDate)).Any(t => t.Item2 > new DateTime(2000, 1, 1)); return anyMatch; }
Ref: 
public boolean waCustomerOrdersNestedAnyMatch() { List<Customer> customers = getCustomerList(); boolean anyMatch = customers.stream().filter(c -> c.getRegion() == "WA").flatMap(c -> c.getOrders().stream() .map(o -> Pair.with(c.getCustomerId(), o.getOrderDate()))) .anyMatch(t -> t.getValue1().isAfter(LocalDate.of(2000, 1, 1))); return anyMatch; }
Hyp: 
public boolean waCustomerOrdersNestedAnyMatch() { List<Customer> customers = getCustomerList(); boolean anyMatch = customers.stream().filter(c -> c.getRegion() == "WA").flatMap(c -> c.getOrders().stream() .map(o -> Pair.with(c.getCustomerId(), o.getOrderDate()))) .anyMatch(t -> t.getValue1().isAfter(LocalDate.of(2000, 1, 1))); return anyMatch; }

BLEU: 100.0
Edit Sim: 0


Src: 
public Dictionary<Tuple<string,int>, List<string>> CustomerGroupJoinRegionsWithCodeNameRegion() { List<Tuple<string, int>> regions = new List<Tuple<string, int>>{ Tuple.Create("BC", 101), Tuple.Create("BC", 105), Tuple.Create("OR", 121), Tuple.Create("LA", 143) }; List<Customer> customers = GetCustomerList(); Dictionary<Tuple<string,int>, List<string>> q = regions.GroupJoin(customers, r => r.Item1, c => c.Region, (r, c) => Tuple.Create(r, c.Select(c=>c.CompanyName).ToList())) .ToDictionary(t => t.Item1, t => t.Item2); return q; }
Ref: 
public Map<Pair<String, Integer>, List<String>> customerGroupJoinRegionsWithCodeNameRegion() { List<Pair<String, Integer>> regions = Arrays.asList( Pair.with("BC", 101), Pair.with("BC", 105), Pair.with("OR", 121), Pair.with("LA", 143) ); List<Customer> customers = getCustomerList(); Map<Pair<String, Integer>, List<String>> q = regions.stream().map(r -> Pair.with(r, customers.stream() .filter(c -> c.getRegion().equals(r.getValue0())).map(c->c.getCompanyName()).toList())) .collect(toMap(t->t.getValue0(),t->t.getValue1())); return q; }
Hyp: 
public Map<Pair<String, Integer>, List<String>> customerGroupJoinRegionsWithCodeNameRegion() { List<Pair<String, Integer>> regions = Arrays.asList( Pair.with("BC", 101), Pair.with("BC", 105), Pair.with("OR", 121), Pair.with("LA", 143) ); List<Customer> customers = getCustomerList(); Map<Pair<String, Integer>, List<String>> q = regions.stream().map(r -> Pair.with(r, customers.stream() .filter(c -> c.getRegion().equals(r.getValue0())).toList())) .collect(toMap(t->t.getValue0(),t->t.getValue1())); return q; }

BLEU: 93.54
Edit Sim: 27


Src: 
public List<Tuple<string, DateTime>> CustomerOrdersNestedTakeWhile() { List<Customer> customers = GetCustomerList(); List<Tuple<string, DateTime>> firstOrdersWhile = customers.SelectMany(c => c.Orders, (c, o) => Tuple.Create( c.CustomerId, o.OrderDate)).TakeWhile(t => t.Item2 > new DateTime( 2000, 1, 1)).ToList(); return firstOrdersWhile; }
Ref: 
public List<Pair<String, LocalDate>> customerOrdersNestedTakeWhile() { List<Customer> customers = getCustomerList(); List<Pair<String, LocalDate>> after3Orders = customers.stream().flatMap(c -> c.getOrders().stream() .map(o -> Pair.with(c.getCustomerId(), o.getOrderDate()))) .takeWhile(t -> t.getValue1().isAfter(LocalDate.of(2000, 1, 1))).toList(); return after3Orders; }
Hyp: 
public List<Pair<String, LocalDate>> customerOrdersNestedTakeWhile() { List<Customer> customers = getCustomerList(); List<Pair<String, LocalDate>> after3Orders = customers.stream().flatMap(c -> c.getOrders().stream() .map(o -> Pair.with(c.getCustomerId(), o.getOrderDate()))) .takeWhile(t -> t.getValue1().isAfter(LocalDate.of(2000, 1, 1))).toList(); return after3Orders; }

BLEU: 100.0
Edit Sim: 0


Src: 
public Tuple<int, int>[] SelectManyJoinSumEven() { int[] numbersA = { 0, 2, 4, 5, 6, 8, 9 }; int[] numbersB = { 1, 3, 5, 7, 8 }; Tuple<int, int>[] pairs = numbersA.SelectMany(a => numbersB.Where(b => (a + b) % 2 == 0), (a, b) => Tuple.Create(a, b)).ToArray(); return pairs; }
Ref: 
public Pair<Integer, Integer>[] selectManyJoinSumEven() { int[] numbersA = {0, 2, 4, 5, 6, 8, 9}; int[] numbersB = {1, 3, 5, 7, 8}; Pair<Integer, Integer>[] pairs = (Pair<Integer, Integer>[]) Arrays.stream(numbersA).boxed().flatMap(a -> Arrays.stream(numbersB) .filter(b -> (a + b) % 2 == 0).mapToObj(b -> Pair.with(a, b))).toArray(); return pairs; }
Hyp: 
public Pair<Integer, Integer>[] selectManyJoinSumEven() { int[] numbersA = {0, 2, 4, 5, 9}; int[] numbersB = {1, 3, 5, 7, 8}; int[] pairs = Arrays.stream(numbersA).flatMap(a -> numbersB).filter(b -> (a + b) % 2 == 0).map(b -> Pair.with(a, b)).toArray(); return pairs; }

BLEU: 57.65
Edit Sim: 81


Src: 
public int[] StringLength() { string[] strings = { "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine" }; int[] selected = strings.Select(w => w.Length).ToArray(); return selected; }
Ref: 
public int[] stringLength() { String[] strings = {"zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"}; int[] selected = Arrays.stream(strings).mapToInt(w -> w.length()).toArray(); return selected; }
Hyp: 
public int[] stringLength() { String[] strings = {"zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"}; int[] selected = (int[]) Arrays.stream(strings).mapToInt(w -> w.length()).toArray(); return selected; }

BLEU: 90.25
Edit Sim: 8


Src: 
public int ShortStringMaxLength() { string[] words = { "cherry", "apple", "blueberry" }; int maxLength = words.Where(w => w.Length < 7).Max(w => w.Length); return maxLength; }
Ref: 
public int shortStringMaxLength() { String[] words = {"cherry", "apple", "blueberry"}; int maxLength = Arrays.stream(words).filter(w -> w.length() < 7).mapToInt(w -> w.length()).max().getAsInt(); return maxLength; }
Hyp: 
public int shortStringMaxLength() { String[] words = {"cherry", "apple", "blueberry"}; int maxLength = Arrays.stream(words).filter(w -> w.length() < 7).mapToInt(w -> w.length()).max().getAsInt(); return maxLength; }

BLEU: 100.0
Edit Sim: 0


Src: 
public bool[] IntWithIndex() { int[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 }; bool[] numSelected = numbers.Select((n, i) => n == i).ToArray(); return numSelected; }
Ref: 
public Boolean[] intWithIndex() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; Boolean[] numSelected = (Boolean[]) IntStream.range(0, numbers.length).mapToObj(i -> numbers[i] == i).toArray(); return numSelected; }
Hyp: 
public boolean[] intWithIndex() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; boolean[] numSelected = IntStream.range(0, numbers.length).filter(i -> numbers[i] == i).map(i -> numbers[i] == i).toArray(); return numSelected; }

BLEU: 64.43
Edit Sim: 45


Src: 
public List<int> RangeOfSquareInts() { List<int> numbers = Enumerable.Range(0, 20).Select(n=>n*n).ToList(); return numbers; }
Ref: 
public List<Integer> rangeOfSquareInts() { List<Integer> numbers = IntStream.range(0, 50).map(n->n*n).boxed().toList(); return numbers; }
Hyp: 
public List<Integer> rangeOfSquareInts() { List<Integer> numbers = IntStream.range(0, 20).map(n->n*n).boxed().toList(); return numbers; }

BLEU: 76.12
Edit Sim: 1


Src: 
public Dictionary<bool, List<double>> DoubleGroupByBoolDictOrderbyFraction() { double[] numbers = { 3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0 }; Dictionary<bool, List<double>>  numbersGroups = numbers.GroupBy(n => n>5) .ToDictionary(g => g.Key, g => g.OrderBy(n=>n-(int)n).ToList()); return numbersGroups; }
Ref: 
public Map<Boolean, List<Double>> doubleGroupByBoolDictOrderbyFraction() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; Map<Boolean, List<Double>> numbersGroups = Arrays.stream(numbers).boxed().collect(groupingBy(n -> n > 5)) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().sorted(Comparator.comparing( n -> n - (int) n.doubleValue())).toList())); return numbersGroups; }
Hyp: 
public Map<Boolean, List<Double>> doubleGroupByBoolDictOrderbyFraction() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; Map<Boolean, List<Double>> numbersGroups = Arrays.stream(numbers).boxed().collect(groupingBy(n -> n > 5)) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().sorted(Comparator.comparing( n -> n - (int) n.doubleValue())).toList())); return numbersGroups; }

BLEU: 100.0
Edit Sim: 0


Src: 
public List<string> ShortStringOrderbyDescendingCustom() { string[] words = { "aPPLE", "AbAcUs", "bRaNcH", "BlUeBeRrY", "ClOvEr", "cHeRry" }; List<string> sortedWords = words.Where(w => w.Length < 6).OrderByDescending(w => w, new CaseInsensitiveComparer()).ToList(); return sortedWords; }
Ref: 
public List<String> shortStringOrderbyDescendingCustom() { String[] words = {"aPPLE", "AbAcUs", "bRaNcH", "BlUeBeRrY", "ClOvEr", "cHeRry"}; List<String> sortedWords = Arrays.stream(words).filter(w -> w.length() < 6).sorted(new CaseInsensitiveComparer().reversed()). toList(); return sortedWords; }
Hyp: 
public List<String> shortStringOrderbyDescendingCustom() { String[] words = {"aPPLE", "AbAcUs", "bRaNcH", "BlUeBeRrY", "ClOvEr", "cHeRry"}; List<String> sortedWords = Arrays.stream(words).filter(w -> w.length() < 6).sorted(new CaseInsensitiveComparer().reversed()).toList(); return sortedWords; }

BLEU: 85.92
Edit Sim: 1


Src: 
public Dictionary<string, Order> CustomerEachRegionFirstOrderDict() { List<Customer> customers = GetCustomerList(); Dictionary<string, Order> ordersMax = customers.GroupBy(c => c.Region) .ToDictionary(g => g.Key, g => g.SelectMany(c => c.Orders).First()); return ordersMax; }
Ref: 
public Map<String, Order> customerEachRegionFirstOrderDict() { List<Customer> customers = getCustomerList(); Map<String, Order> ordersFirst = customers.stream().collect(groupingBy(c -> c.getRegion())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().flatMap(c -> c.getOrders().stream()).findFirst().get())); return ordersFirst; }
Hyp: 
public Map<String, Order> customerEachRegionFirstOrderDict() { List<Customer> customers = getCustomerList(); Map<String, Order> ordersMax = customers.stream().collect(groupingBy(c -> c.getRegion())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().flatMap(c -> c.getOrders().stream()).findFirst().get())); return ordersMax; }

BLEU: 83.48
Edit Sim: 10


Src: 
public List<Tuple<bool, List<int>>> ProductGroupByPriceWithId() { List<Product> products = GetProductList(); List<Tuple<bool, List<int>>> productGroup = products.GroupBy(p => p.UnitPrice > 100) .Select(g => Tuple.Create(g.Key, g.Select(p => p.ProductId).ToList())).ToList(); return productGroup; }
Ref: 
public List<Pair<Boolean, List<Integer>>> productGroupByPriceWithId() { List<Product> products = getProductList(); List<Pair<Boolean, List<Integer>>> productGroup = products.stream().collect(groupingBy(p -> p.getUnitPrice() > 100)) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().map(p -> p.getProductId()).toList())).toList(); return productGroup; }
Hyp: 
public List<Pair<Boolean, List<Integer>>> productGroupByPriceWithId() { List<Product> products = getProductList(); List<Pair<Boolean, List<Integer>>> productGroup = products.stream().collect(groupingBy(p -> p.getUnitPrice() > 100)) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().map(p -> p.getProductId()).toList())).toList(); return productGroup; }

BLEU: 100.0
Edit Sim: 0


Src: 
public List<Tuple<string, int>> CustomerDistinctOrdersCount() { List<Customer> customers = GetCustomerList(); List<Tuple<string, int>> orderCounts = customers.Select(c => Tuple.Create(c.CustomerId, c.Orders.Distinct().Count())).ToList(); return orderCounts; }
Ref: 
public List<Pair<String, Integer>> customerDistinctOrdersCount() { List<Customer> customers = getCustomerList(); List<Pair<String, Integer>> orderCounts = customers.stream().map(c -> Pair.with(c.getCustomerId(), (int) c.getOrders().stream().distinct().count())).toList(); return orderCounts; }
Hyp: 
public List<Pair<String, Integer>> customerDistinctOrdersCount() { List<Customer> customers = getCustomerList(); List<Pair<String, Integer>> orderCounts = customers.stream().map(c -> Pair.with(c.getCustomerId(), (int) c.getOrders().stream().distinct().count())).toList(); return orderCounts; }

BLEU: 100.0
Edit Sim: 0


Src: 
public int OddNumbersSum() { int[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 }; int numbersSum = numbers.Where(n => n % 2 == 1).Sum(); return numbersSum; }
Ref: 
public int oddNumbersSum() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int numbersSum = Arrays.stream(numbers).filter(n -> n % 2 == 0).sum(); return numbersSum; }
Hyp: 
public int oddNumbersSum() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int numbersSum = Arrays.stream(numbers).filter(n -> n % 2 == 0).sum(); return numbersSum; }

BLEU: 100.0
Edit Sim: 0


Src: 
public List<int> IntTakeCount(int[] numbers, int n) { List<int> firstNNumbers = numbers.Take(n).ToList(); return firstNNumbers; }
Ref: 
public List<Integer> intTakeCount(int[] numbers, int n) { List<Integer> afterNNumbers = Arrays.stream(numbers).limit(n).boxed().toList(); return afterNNumbers; }
Hyp: 
public List<Integer> intTakeCount(int[] numbers, int n) { List<Integer> afterNNumbers = Arrays.stream(numbers).limit(n).boxed().toList(); return afterNNumbers; }

BLEU: 100.0
Edit Sim: 0


Src: 
public List<Order> WaCustomerSelectManyNewOrders() { List<Customer> customers = GetCustomerList(); List<Order> customerProperties = customers.Where(c => c.Region == "WA").SelectMany(c=> c.Orders.Where(o=>o.OrderDate>new DateTime(1998, 1, 1))).ToList(); return customerProperties; }
Ref: 
public List<Order> waCustomerSelectManyNewOrders() { List<Customer> customers = getCustomerList(); List<parallel.linq101.datasource.Order> customerProperties = customers.stream().filter(c -> c.getRegion().equals("WA")).flatMap(c -> c.getOrders() .stream().filter(o -> o.getOrderDate().isAfter(LocalDate.of(1998, 1, 1)))).toList(); return customerProperties; }
Hyp: 
public List<Order> waCustomerSelectManyNewOrders() { List<Customer> customers = getCustomerList(); List<Order> customerProperties = customers.stream().filter(c -> c.getRegion().equals("WA")).flatMap(c -> c.getOrders() .stream().filter(o -> o.getOrderDate().isAfter(LocalDate.of(1998, 1, 1))).toList(); return customerProperties; }

BLEU: 77.49
Edit Sim: 29


Src: 
public List<double> DoubleFractionOrderbyReverse() { double[] numbers = { 3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0 }; List<double> sortedNumbers = numbers.Select(n => n-(int)n).OrderBy(n=>n).Reverse().ToList(); return sortedNumbers; }
Ref: 
public List<Double> doubleFractionOrderbyReverse() { double[] numbers = { 3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0 }; List<Double> sortedNumbers = Arrays.stream(numbers).map(n -> n-(int)n).boxed().sorted() .collect(collectingAndThen(toList(),l->{Collections.reverse(l);return l;})); return sortedNumbers; }
Hyp: 
public List<Double> doubleFractionOrderbyReverse() { double[] numbers = { 3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0 }; List<Double> sortedNumbers = Arrays.stream(numbers).map(n -> n - (int) n).boxed().sorted().collect( collectingAndThen(toList(),l->{Collections.reverse(l);return l;})); return sortedNumbers; }

BLEU: 79.75
Edit Sim: 5


Src: 
public Dictionary<string, double> CustomerExpensiveOrdersTotalMinDict() { List<Customer> customers = GetCustomerList(); Dictionary<string, double> ordersTotalMin = customers.ToDictionary(c => c.CustomerId, c => c.Orders.Where(o => o.Total > 100).Min(o => o.Total)); return ordersTotalMin; }
Ref: 
public Map<String, Double> customerExpensiveOrdersTotalMinDict() { List<Customer> customers = getCustomerList(); Map<String, Double> ordersTotalMin = customers.stream().collect(toMap(c -> c.getCustomerId(), c -> c.getOrders().stream().filter(o -> o.getTotal() > 100) .mapToDouble(o -> o.getTotal()).min().getAsDouble())); return ordersTotalMin; }
Hyp: 
public Map<String, Double> customerExpensiveOrdersTotalMinDict() { List<Customer> customers = getCustomerList(); Map<String, Double> ordersTotalMin = customers.stream().collect(toMap(c -> c.getCustomerId(), c -> c.getOrders().stream().filter(o -> o.getTotal() > 100) .mapToDouble(o -> o.getTotal()).min().getAsDouble())); return ordersTotalMin; }

BLEU: 100.0
Edit Sim: 0


Src: 
public Dictionary<bool, List<int>> ProductGroupByInStockWithIdDictPrint() { List<Product> products = GetProductList(); Dictionary<bool, List<int>> productGroup = products.GroupBy(p => p.UnitsInStock == 0) .ToDictionary(g => g.Key, g => g.Select(p => p.ProductId).ToList()); productGroup[true].ForEach(p => Console.Write(p)); Console.WriteLine(); productGroup[false].ForEach(p => Console.Write(p)); return productGroup; }
Ref: 
public Map<Boolean, List<Integer>> productGroupByInStockWithIdDictPrint() { List<Product> products = getProductList(); Map<Boolean, List<Integer>> productGroup = products.stream().collect(groupingBy(p -> p.getUnitsInStock() > 0)) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().map(p -> p.getProductId()).toList())); productGroup.get(true).stream().forEach(n -> System.out.print(n)); System.out.println(); productGroup.get(false).stream().forEach(n -> System.out.print(n)); return productGroup; }
Hyp: 
public Map<Boolean, List<Integer>> productGroupByInStockWithIdDictPrint() { List<Product> products = getProductList(); Map<Boolean, List<Integer>> productGroup = products.stream().collect(groupingBy(p -> p.getUnitsInStock() > 0)) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().map(p -> p.getProductId()).toList())); Console.WriteLine(); return productGroup; }

BLEU: 74.73
Edit Sim: 141


Src: 
public List<Tuple<string, double>> ProductCrossJoinCategoriesUnitPrice() { string[] categories = { "Beverages", "Condiments", "Vegetables", "Dairy Products", "Seafood" }; List<Product> products = GetProductList(); List<Tuple<string, double>> q = categories.Join(products, c => c, p => p.Category, (c, p) => Tuple.Create(c, p.UnitPrice)).ToList(); return q; }
Ref: 
public List<Pair<String, Double>> productCrossJoinCategoriesUnitPrice() { String[] categories = {"Beverages", "Condiments", "Vegetables", "Dairy Products", "Seafood"}; List<Product> products = getProductList(); List<Pair<String, Double>> q = Arrays.stream(categories).flatMap( c -> products.stream().filter(p -> p.getCategory().equals(c)).map( p -> Pair.with(c, p.getUnitPrice()))).toList(); return q; }
Hyp: 
public List<Pair<String, Double>> productCrossJoinCategoriesUnitPrice() { String[] categories = {"Beverages", "Condiments", "Vegetables", "Dairy Products", "Seafood"}; List<Product> products = getProductList(); List<Pair<String, Double>> q = Arrays.stream(categories).map( c -> Pair.with(c, products.stream().filter(p -> p.getCategory().equals(c)) .collect(Collectors.toList()))).flatMap(p -> Pair.with(c, p.getUnitPrice()))).toList(); return q; }

BLEU: 76.76
Edit Sim: 56


Src: 
public Dictionary<string, double> CustomerOrdersTotalMaxDict() { List<Customer> customers = GetCustomerList(); Dictionary<string, double> ordersTotalMax = customers.ToDictionary(c => c.CustomerId, c => c.Orders.Max(o => o.Total)); return ordersTotalMax; }
Ref: 
public Map<String, Double> customerOrdersTotalMaxDict() { List<Customer> customers = getCustomerList(); Map<String, Double> ordersTotalMax = customers.stream().collect(toMap(c -> c.getCustomerId(), c -> c.getOrders().stream().mapToDouble(o -> o.getTotal()).max().getAsDouble())); return ordersTotalMax; }
Hyp: 
public Map<String, Double> customerOrdersTotalMaxDict() { List<Customer> customers = getCustomerList(); Map<String, Double> ordersTotalMax = customers.stream().collect(toMap(c -> c.getCustomerId(), c -> c.getOrders().stream().mapToDouble(o -> o.getTotal()).max().getAsDouble())); return ordersTotalMax; }

BLEU: 100.0
Edit Sim: 0


Src: 
public List<string> StringTakeCount(string[] strings, int n) { List<string> firstNWords = strings.Take(n).ToList(); return firstNWords; }
Ref: 
public List<String> stringTakeCount(String[] strings, int n) { List<String> afterNWords = Arrays.stream(strings).limit(3).toList(); return afterNWords; }
Hyp: 
public List<String> stringTakeCount(String[] strings, int n) { List<String> afterNWords = Arrays.stream(strings).limit(3).toList(); return afterNWords; }

BLEU: 100.0
Edit Sim: 0


Src: 
public void NumbersTwiceEager() { int[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 }; int i = 0; var q = numbers.Select(n => n * 2).Select(n => i += n).ToList(); foreach (var v in q) Console.Write(v + " " + i); }
Ref: 
public void numbersTwiceEager() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; AtomicInteger i = new AtomicInteger(0); var q = Arrays.stream(numbers).map(n->n*2).map(n -> i.addAndGet(n)).boxed().toList(); for (var v : q) System.out.println(v + " " + i); }
Hyp: 
public void numbersTwiceEager() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; AtomicInteger i = new AtomicInteger(0); var q = Arrays.stream(numbers).map(n->n*2).map(n -> i.addAndGet(n)).boxed().toList(); for (var v : q) System.out.println(v + " " + i); }

BLEU: 100.0
Edit Sim: 0


Src: 
public double[] DoublesConvertToDescendingArrayAndPrintForeach() { double[] doubles = { 1.7, 2.3, 1.9, 4.1, 2.9 }; double[] doublesArray = doubles.OrderByDescending(d => d).ToArray(); foreach (double d in doublesArray) Console.WriteLine(d); return doublesArray; }
Ref: 
public double[] doublesConvertToDescendingArrayAndPrintForeach() { double[] doubles = {1.7, 2.3, 1.9, 4.1, 2.9}; double[] doublesArray = Arrays.stream(doubles).boxed().sorted(Comparator.reverseOrder()).mapToDouble(d -> d).toArray(); for (double d : doublesArray) System.out.println(d); return doublesArray; }
Hyp: 
public double[] doublesConvertToDescendingArrayAndPrintForeach() { double[] doubles = {1.7, 2.3, 1.9, 4.1, 2.9}; double[] doublesArray = Arrays.stream(doubles).boxed().sorted(Comparator.reverseOrder()).mapToDouble(d -> d).toArray(); for (double d : doublesArray) System.out.println(d); return doublesArray; }

BLEU: 100.0
Edit Sim: 0


Src: 
public double ExpensiveProductUnitPriceTotalSum() { List<Product> products = GetProductList(); double totalSum = products.Where(p => p.UnitPrice > 100).Sum(p => p.UnitPrice); return totalSum; }
Ref: 
public double expensiveProductUnitPriceSum() { List<Product> products = getProductList(); double totalSum = products.stream().filter(p -> p.getUnitPrice() > 100) .mapToDouble(p -> p.getUnitPrice()).sum(); return totalSum; }
Hyp: 
public double expensiveProductUnitPriceTotalSum() { List<Product> products = getProductList(); double totalSum = products.stream().filter(p -> p.getUnitPrice() > 100) .mapToInt(p -> p.getUnitPrice()).sum(); return totalSum; }

BLEU: 76.74
Edit Sim: 11


Src: 
public List<double> BigDoubleOrderby() { double[] numbers = { 3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0 }; List<double> sortedNumbers = numbers.Where(n => n > 5).OrderBy(n => n).ToList(); return sortedNumbers; }
Ref: 
public List<Double> bigDoubleOrderby() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; List<Double> sortedNumbers = Arrays.stream(numbers).filter(n -> n > 5).boxed().sorted().toList(); return sortedNumbers; }
Hyp: 
public List<Double> bigDoubleOrderby() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; List<Double> sortedNumbers = Arrays.stream(numbers).filter(n -> n > 5).boxed().sorted().toList(); return sortedNumbers; }

BLEU: 100.0
Edit Sim: 0


Src: 
public Dictionary<string, int> ConvertTuplesToDictionaryAndPrint() { List<Tuple<string, int>> scoreRecords =new List<Tuple<string, int>> { Tuple.Create("Alice", 50), Tuple.Create("Bob", 40), Tuple.Create("Cathy", 45) }; Dictionary<string, int> scoreRecordsDict = scoreRecords.ToDictionary(sr => sr.Item1, sr => sr.Item2); foreach (var pair in scoreRecordsDict) Console.WriteLine(pair.Key + " " + pair.Value); return scoreRecordsDict; }
Ref: 
public Map<String, Integer> convertTuplesToDictionaryAndPrint() { List<Pair<String,Integer>> scoreRecords = Arrays.asList( Pair.with("Alice", 50), Pair.with("Bob", 40), Pair.with("Cathy", 45)); Map<String, Integer> scoreRecordsDict = scoreRecords.stream().collect(toMap( sr -> sr.getValue0(), sr -> sr.getValue1())); for(var pair : scoreRecordsDict.entrySet()) System.out.println(pair.getKey() + " " + pair.getValue()); return scoreRecordsDict; }
Hyp: 
public Map<String, Integer> convertTuplesToDictionaryAndPrint() { List<Pair<String, Integer>> scoreRecords = Arrays.asList( Pair.with("Alice", 50), Pair.with("Bob", 40), Pair.with("Cathy", 45) ); Map<String, Integer> scoreRecordsDict = scoreRecords.stream().collect(toMap(sr -> sr.getValue0(), sr -> sr.getValue1())); for (var pair : scoreRecordsDict) System.out.println(pair.getKey() + " " + pair.getValue()); return scoreRecordsDict; }

BLEU: 60.34
Edit Sim: 15


Src: 
public List<Product> RepeatedProductsWithCount(int count) { List<Product> products = Enumerable.Repeat(Product.Default, count).ToList(); return products; }
Ref: 
public List<Product> repeatedProductsWithCount(int count) { List<Product> products = Collections.nCopies(count,Product.DEFAULT); return products; }
Hyp: 
public List<Product> repeatedProductsWithCount(int count) { List<Product> products = Collections.nCopies(count, Product.DEFAULT); return products; }

BLEU: 69.98
Edit Sim: 1


Src: 
public List<string> StringSkipWhileCount(string[] strings, char c) { List<string> afterWordsWhile = strings.SkipWhile(w => w[0] > c).ToList(); return afterWordsWhile; }
Ref: 
public List<String> stringSkipWhileCount(String[] strings, char c) { List<String> afterNWords = Arrays.stream(strings).dropWhile(w -> w.charAt(0) > c).toList(); return afterNWords; }
Hyp: 
public List<String> stringSkipWhileCount(String[] strings, char c) { List<String> afterNNumbers = Arrays.stream(strings).dropWhile(w -> w.charAt(0) > c).toList(); return afterNNumbers; }

BLEU: 74.44
Edit Sim: 12


Src: 
public List<int> IntTakeWhileIndexedCount(int n) { int[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 }; List<int> firstNumbers = numbers.TakeWhile((n, i) => n > i).ToList(); return firstNumbers; }
Ref: 
public List<Integer> intTakeWhileIndexedCount(int n) { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; List<Integer> afterNumbers = IntStream.range(0, numbers.length) .takeWhile(i -> n > i).map(i -> numbers[i]).boxed().toList(); return afterNumbers; }
Hyp: 
public List<Integer> intTakeWhileIndexedCount(int n) { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; List<Integer> after3Numbers = IntStream.range(0, numbers.length) .takeWhile(i -> n > i).map(i -> numbers[i]).boxed().toList(); return after3Numbers; }

BLEU: 86.61
Edit Sim: 2


Src: 
public double InputNumbersAggregate(double[] numbers) { double product = numbers.Aggregate((runningProduct, nextFactor) => runningProduct * nextFactor); return product; }
Ref: 
public double inputNumbersAggregate(double[] numbers) { double product = Arrays.stream(numbers).reduce((a, b) -> a * b).getAsDouble(); return product; }
Hyp: 
public double inputNumbersAggregate(double[] numbers) { double product = Arrays.stream(numbers).reduce((runningProduct, nextFactor) -> runningProduct * nextFactor).getAsDouble(); return product; }

BLEU: 55.0
Edit Sim: 48


Src: 
public List<string> StringTakeWhileCount(string[] strings, char c) { List<string> firstWordsWhile = strings.TakeWhile(w => w[0] > c).ToList(); return firstWordsWhile; }
Ref: 
public List<String> stringTakeWhileCount(String[] strings, char c) { List<String> afterNWords = Arrays.stream(strings).takeWhile(w -> w.charAt(0) > c).toList(); return afterNWords; }
Hyp: 
public List<String> stringTakeWhileCount(String[] strings, char c) { List<String> afterNNumbers = Arrays.stream(strings).takeWhile(w -> w.charAt(0) > c).toList(); return afterNNumbers; }

BLEU: 74.44
Edit Sim: 12


Src: 
public List<int> StringLengthTake() { string[] words = { "cherry", "apple", "blueberry", "banana", "abacus" }; List<int> first3Words = words.Select(w => w.Length).Take(3).ToList(); return first3Words; }
Ref: 
public List<Integer> stringLengthTake() { String[] words = {"cherry", "apple", "blueberry", "banana", "abacus"}; List<Integer> after3Words = Arrays.stream(words).map(w -> w.length()).limit(3).toList(); return after3Words; }
Hyp: 
public List<Integer> stringLengthTake() { String[] words = {"cherry", "apple", "blueberry", "banana", "abacus"}; List<Integer> after3Words = Arrays.stream(words).map(w -> w.length()).limit(3).toList(); return after3Words; }

BLEU: 100.0
Edit Sim: 0


Src: 
public void StringLengthEager() { string[] words = { "cherry", "apple", "blueberry" }; int i = 0; var q = words.Select(w => w.Length).Select(n => i += n).ToList(); foreach (var v in q) Console.Write(v + " " + i); }
Ref: 
public void stringLengthEager() { String[] words = {"cherry", "apple", "blueberry"}; AtomicInteger i = new AtomicInteger(0); var q = Arrays.stream(words).map(w -> w.length()).map(n -> i.addAndGet(n)).toList(); for (var v : q) System.out.println(v + " " + i); }
Hyp: 
public void stringLengthEager() { String[] words = {"cherry", "apple", "blueberry"}; AtomicInteger i = new AtomicInteger(0); var q = Arrays.stream(words).map(w -> w.length()).map(n -> i.addAndGet(n)).toList(); for (var v : q) System.out.println(v + " " + i); }

BLEU: 100.0
Edit Sim: 0


Src: 
public int BigNumbersMaxTwice() { int[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 }; int maxNum = numbers.Where(n => n > 5).Max(n => n * 2); return maxNum; }
Ref: 
public int bigNumbersMaxTwice() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int maxNum = Arrays.stream(numbers).filter(n -> n >= 5).map(n -> n * 2).max().getAsInt(); return maxNum; }
Hyp: 
public int bigNumbersMaxTwice() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int maxNum = Arrays.stream(numbers).filter(n -> n >= 5).map(n -> n * 2).max().getAsInt(); return maxNum; }

BLEU: 100.0
Edit Sim: 0


Src: 
public List<Product> ProductIndexedWhere() { List<Product> products = GetProductList(); List<Product> q = products.Where((w,i)=>w.UnitsInStock>0&&i%2==1).ToList(); return q; }
Ref: 
public List<Product> productIndexedWhere() { List<Product> products = getProductList(); List<Product> q = IntStream.range(0, products.size()).filter(i -> products.get(i).getUnitsInStock() > 0 && i % 2 == 1).mapToObj(i -> products.get(i)).toList(); return q; }
Hyp: 
public List<Product> productIndexedWhere() { List<Product> products = getProductList(); List<Product> q = IntStream.range(0, products.size()).filter(i -> products.get(i).getUnitsInStock() > 0 && i % 2 == 1).map(i -> products.get(i).getProduct(); return q; }

BLEU: 84.1
Edit Sim: 13


Src: 
public List<Tuple<string, Product>> ProductCrossJoinCategories() { string[] categories = { "Beverages", "Condiments", "Vegetables", "Dairy Products", "Seafood" }; List<Product> products = GetProductList(); List<Tuple<string, Product>> q = categories.Join(products, c => c, p => p.Category, (c, p) => Tuple.Create(c, p)).ToList(); return q; }
Ref: 
public List<Pair<String, Product>> productCrossJoinCategories() { String[] categories = {"Beverages", "Condiments", "Vegetables", "Dairy Products", "Seafood"}; List<Product> products = getProductList(); List<Pair<String, Product>> q = Arrays.stream(categories).flatMap( c -> products.stream().filter(p -> p.getCategory().equals(c)).map( p -> Pair.with(c, p))).toList(); return q; }
Hyp: 
public List<Pair<String, Product>> productCrossJoinCategories() { String[] categories = {"Beverages", "Condiments", "Vegetables", "Dairy Products", "Seafood"}; List<Product> products = getProductList(); List<Pair<String, Product>> q = Arrays.stream(categories).map( c -> Pair.with(c, products.stream().filter(p -> p.getCategory().equals(c)) .collect(Collectors.toList()))).flatMap(p1 -> Pair.with(c, p1))).toList(); return q; }

BLEU: 69.98
Edit Sim: 58


Src: 
public int[] ShortStringLength() { string[] strings = { "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine" }; int[] selected = strings.Where(w => w.Length < 4).Select(w => w.Length).ToArray(); return selected; }
Ref: 
public int[] shortStringLength() { String[] strings = {"zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"}; int[] selected = Arrays.stream(strings).filter(w -> w.length() < 4).mapToInt(w -> w.length()).toArray(); return selected; }
Hyp: 
public int[] shortStringLength() { String[] strings = {"zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"}; int[] selected = Arrays.stream(strings).filter(w -> w.length() < 4).map(w -> w.length()).toArray(); return selected; }

BLEU: 91.28
Edit Sim: 5


Src: 
public List<Product> InStockProductTakeWhile() { List<Product> products = GetProductList(); List<Product> firstProductsWhile = products.Where(p => p.UnitsInStock > 0).TakeWhile(p => p.ProductId > 100).ToList(); return firstProductsWhile; }
Ref: 
public List<Product> inStockProductTakeWhile() { List<Product> products = getProductList(); List<Product> after3Products = products.stream().filter(p -> p.getUnitsInStock() > 100).takeWhile(p -> p.getProductId() > 100).toList(); return after3Products; }
Hyp: 
public List<Product> inStockProductTakeWhile() { List<Product> products = getProductList(); List<Product> after3Products = products.stream().filter(p -> p.getUnitsInStock() > 100).takeWhile(p -> p.getProductId() > 100).toList(); return after3Products; }

BLEU: 100.0
Edit Sim: 0


Src: 
public List<Tuple<string,int>> ConvertSelectedTupleToListAndPrint() { object[] numbers = { Tuple.Create("Alice", "50"), Tuple.Create("Bob", 40), Tuple.Create("Cathy", 45) }; List<Tuple<string,int>> strings = numbers.OfType<Tuple<string,int>>().ToList(); for (var i = 0; i < strings.Count; i++) Console.WriteLine(strings[i].Item1+":"+strings[i].Item2); return strings; }
Ref: 
public List<Pair<String,Integer>> convertSelectedTupleToListAndPrint() { Object[] numbers = { Pair.with("Alice", "50"), Pair.with("Bob", 40), Pair.with("Cathy", 45) }; List<Pair<String,Integer>> strings = Arrays.stream(numbers).filter(o->o instanceof Pair && ((Pair)o).getValue0() instanceof String &&((Pair)o).getValue1() instanceof Integer) .map(o->(Pair<String,Integer>)o).toList(); for (var i = 0; i < strings.size(); i++) System.out.println(strings.get(i).getValue0()+":"+ strings.get(i).getValue1()); return strings; }
Hyp: 
public List<Pair<String,Integer>> convertSelectedTupleToListAndPrint() { Object[] numbers = { Pair.with("Alice", "50"), Pair.with("Bob", 40), Pair.with("Cathy", 45) }; List<Pair<String,Integer>> strings = Arrays.stream(numbers).filter(o->o instanceof Pair && ((Pair)o).getValue0() instanceof String &&((Pair)o).getValue1() instanceof Integer) .map(o->(Pair<String,Integer>)o).toList(); for (var i = 0; i < strings.size(); i++) System.out.println(strings[i].getValue0()+":"+strings[i].getValue1())); return strings; }

BLEU: 91.65
Edit Sim: 14


Src: 
public int[] TransformIndexHashToInt() { int[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 }; int[] textNums = numbers.Select(n => numbers[n * 97 % 10]).ToArray(); return textNums; }
Ref: 
public int[] transformIndexHashToInt() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int[] textNums = Arrays.stream(numbers).map(n -> numbers[n * 97 % 10]).toArray(); return textNums; }
Hyp: 
public int[] transformIndexHashToInt() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int[] textNums = (int[]) Arrays.stream(numbers).mapToInt(n -> numbers[n * 97 % 10]).toArray(); return textNums; }

BLEU: 88.28
Edit Sim: 13


Src: 
public int ExpensiveOrdersCount(string region) { List<Customer> customers = GetCustomerList(); int count = customers.SelectMany(c => c.Orders).Count(o => o.Total > 100); return count; }
Ref: 
public int expensiveOrdersCount(String region) { List<Customer> customers = getCustomerList(); int count = (int) customers.stream().flatMap(c -> c.getOrders().stream()) .filter(o -> o.getTotal() > 100).count(); return count; }
Hyp: 
public int expensiveOrdersCount(String region) { List<Customer> customers = getCustomerList(); int count = (int) customers.stream().flatMap(c -> c.getOrders().stream()) .filter(o -> o.getTotal() > 100).count(); return count; }

BLEU: 100.0
Edit Sim: 0


Src: 
public Dictionary<string, int> ConvertTuplesToDictionary() { List<Tuple<string, int>> scoreRecords =new List<Tuple<string, int>> { Tuple.Create("Alice", 50), Tuple.Create("Bob", 40), Tuple.Create("Cathy", 45) }; Dictionary<string, int> scoreRecordsDict = scoreRecords.ToDictionary(sr => sr.Item1, sr => sr.Item2); return scoreRecordsDict; }
Ref: 
public Map<String, Integer> convertTuplesToDictionary() { List<Pair<String,Integer>> scoreRecords = Arrays.asList( Pair.with("Alice", 50), Pair.with("Bob", 40), Pair.with("Cathy", 45)); Map<String, Integer> scoreRecordsDict = scoreRecords.stream().collect(toMap( sr -> sr.getValue0(), sr -> sr.getValue1())); return scoreRecordsDict; }
Hyp: 
public Map<String, Integer> convertTuplesToDictionary() { List<Pair<String, Integer>> scoreRecords = Arrays.asList( Pair.with("Alice", 50), Pair.with("Bob", 40), Pair.with("Cathy", 45) ); Map<String, Integer> scoreRecordsDict = scoreRecords.stream().collect(toMap(sr -> sr.getValue0(), sr -> sr.getValue1())); return scoreRecordsDict; }

BLEU: 66.1
Edit Sim: 3


Src: 
public double NumbersDoubledAggregateMultiplyWithSeed() { double[] numbers = { 1.7, 2.3, 1.9, 4.1, 2.9 }; double seed = 1.6; double product = numbers.Select(n => n * 2).Aggregate(seed, (a, b) => a * b); return product; }
Ref: 
public double numbersDoubledAggregateMultiplyWithSeed() { double[] numbers = {1.7, 2.3, 1.9, 4.1, 2.9}; double seed = 1.6; double product = product = Arrays.stream(numbers).map(n -> n * 2).reduce(seed, (a, b) -> a * b); return product; }
Hyp: 
public double numbersDoubledAggregateMultiplyWithSeed() { double[] numbers = {1.7, 2.3, 1.9, 4.1, 2.9}; double seed = 1.6; double product = Arrays.stream(numbers).map(n -> n * 2).reduce(seed, b -> a * b).getAsDouble(); return product; }

BLEU: 75.15
Edit Sim: 29


Src: 
public Dictionary<string, List<double>> ProductGroupUnitPriceDict() { List<Product> products = GetProductList(); Dictionary<string, List<double>> productNames = products.GroupBy(p => p.Category) .ToDictionary(g => g.Key, g => g.Select(p => p.UnitPrice).ToList()); return productNames; }
Ref: 
public Map<String, List<Double>> productGroupUnitPriceDict() { List<Product> products = getProductList(); Map<String, List<Double>> productNames = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().map(p -> p.getUnitPrice()).toList())); return productNames; }
Hyp: 
public Map<String, List<Double>> productGroupUnitPriceDict() { List<Product> products = getProductList(); Map<String, List<Double>> productNames = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().map(p -> p.getUnitPrice()).toList())); return productNames; }

BLEU: 100.0
Edit Sim: 0


Src: 
public int[] IntTwice() { int[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 }; int[] numSelected = numbers.Select(n => n * 2).ToArray(); return numSelected; }
Ref: 
public int[] intTwice() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int[] numSelected = Arrays.stream(numbers).map(n -> n * 2).toArray(); return numSelected; }
Hyp: 
public int[] intTwice() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int[] numSelected = Arrays.stream(numbers).map(n -> n * 2).toArray(); return numSelected; }

BLEU: 100.0
Edit Sim: 0


Src: 
public List<Tuple<string, double>> CustomerInRegionOrdersTotalMin(string region) { List<Customer> customers = GetCustomerList(); List<Tuple<string, double>> ordersTotalMin = customers.Where(c => c.Region.Equals(region)) .Select(c => Tuple.Create(c.CustomerId, c.Orders.Min(o => o.Total))).ToList(); return ordersTotalMin; }
Ref: 
public List<Pair<String, Double>> customerInRegionOrdersTotalMin(String region) { List<Customer> customers = getCustomerList(); List<Pair<String, Double>> ordersTotalMin = customers.stream().filter(c -> c.getRegion().equals(region)) .map(c -> Pair.with(c.getCustomerId(), c.getOrders().stream().mapToDouble(o -> o.getTotal()).min().getAsDouble())).toList(); return ordersTotalMin; }
Hyp: 
public List<Pair<String, Double>> customerInRegionOrdersTotalMin(String region) { List<Customer> customers = getCustomerList(); List<Pair<String, Double>> ordersTotalMin = customers.stream().filter(c -> c.getRegion().equals(region)) .map(c -> Pair.with(c.getCustomerId(), c.getOrders().stream().mapToDouble(o -> o.getTotal()).min().getAsDouble())).toList(); return ordersTotalMin; }

BLEU: 100.0
Edit Sim: 0


Src: 
public List<double> OutOfStockProductUnitPrice() { List<Product> products = GetProductList(); List<double> productNames = products.Where(p => p.UnitsInStock == 0).Select(p => p.UnitPrice).ToList(); return productNames; }
Ref: 
public List<Double> outOfStockProductUnitPrice() { List<Product> products = getProductList(); List<Double> productNames = products.stream().filter(p -> p.getUnitsInStock() == 0).map(p -> p.getUnitPrice()).toList(); return productNames; }
Hyp: 
public List<Double> outOfStockProductUnitPrice() { List<Product> products = getProductList(); List<Double> productNames = products.stream().filter(p -> p.getUnitsInStock() == 0).map(p -> p.getUnitPrice()).toList(); return productNames; }

BLEU: 100.0
Edit Sim: 0


Src: 
public bool EqualInts() { int[] numbersA = { 0, 2, 4, 5, 9 }; int[] numbersB = { 0, 2, 4, 5, 9 }; bool equal = numbersA.SequenceEqual(numbersB); return equal; }
Ref: 
public boolean equalInts() { int[] numbersA = {0, 2, 4, 5, 9}; int[] numbersB = {0, 2, 4, 5, 9}; boolean equal = Arrays.equals(numbersA, numbersB); return equal; }
Hyp: 
public boolean equalInts() { int[] numbersA = {0, 2, 4, 5, 9}; int[] numbersB = {0, 2, 4, 5, 9}; boolean equal = Arrays.equals(numbersA, numbersB); return equal; }

BLEU: 100.0
Edit Sim: 0


Src: 
public Product[] ProductsConvertToDescendingArrayAndPrintForeach() { List<Product> products = GetProductList(); Product[] productsArray = products.OrderByDescending(p => p.UnitPrice).ToArray(); foreach (Product p in productsArray) Console.WriteLine(p); return productsArray; }
Ref: 
public Product[] productsConvertToDescendingArrayAndPrintForeach() { List<Product> products = getProductList(); Product[] productsArray = (Product[]) products.stream().sorted(Comparator.comparing( p -> p.getUnitPrice(), Comparator.reverseOrder())).toArray(); for (Product p : productsArray) System.out.println(p); return productsArray; }
Hyp: 
public Product[] productsConvertToDescendingArrayAndPrintForeach() { List<Product> products = getProductList(); Product[] productsArray = products.stream().sorted(Comparator.comparing( p -> p.getUnitPrice(), Comparator.reverseOrder())).toArray(); for (Product p : productsArray) System.out.println(p); return productsArray; }

BLEU: 89.86
Edit Sim: 12


Src: 
public bool IntAnyMatchInput(int i) { int[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 }; bool anyMatch = numbers.Any(n => n > i); return anyMatch; }
Ref: 
public boolean intAnyMatchInput(int i) { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; boolean anyMatch = Arrays.stream(numbers).anyMatch(n -> n > i); return anyMatch; }
Hyp: 
public boolean intAnyMatchInput(int i) { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; boolean anyMatch = Arrays.stream(numbers).anyMatch(n -> n > i); return anyMatch; }

BLEU: 100.0
Edit Sim: 0


Src: 
public List<string> LongStringIndexedWhere() { string[] words = { "cherry", "apple", "blueberry", "banana", "abacus" }; List<string> q =words.Where(w=>w.Length>5).Where((w,i)=>w.Length<i*3).ToList(); return q; }
Ref: 
public List<String> longStringIndexedWhere() { String[] words = {"cherry", "apple", "blueberry", "banana", "abacus"}; String[] longWords = (String[]) Arrays.stream(words).filter(w -> w.length() > 5).toArray(); List<String> q = IntStream.range(0, longWords.length).filter(i -> longWords[i].length() < i * 3) .mapToObj(i -> longWords[i]).toList(); return q; }
Hyp: 
public List<String> longStringIndexedWhere() { String[] words = {"cherry", "apple", "blueberry", "banana", "abacus"}; List<String> q = IntStream.range(0, words.length).filter(i -> words[i].length() > 5).map(i -> words[i]).toList(); return q; }

BLEU: 38.76
Edit Sim: 119


Src: 
public List<string> StringOrderbyLengthCustomThenby() { string[] words = { "cherry", "apple", "blueberry","banana","abacus" }; List<string> sortedWords = words.OrderBy(w => w.Length, new CustomNumberComparer()).ThenBy(w=>w).ToList(); return sortedWords; }
Ref: 
public List<String> stringOrderbyLengthCustomThenby() { String[] words = {"cherry", "apple", "blueberry", "banana", "abacus"}; List<String> sortedWords =  Arrays.stream(words).sorted(Comparator.comparing((String w) -> w.length(), new CustomNumberComparer()).thenComparing(Comparator.naturalOrder())).toList(); return sortedWords; }
Hyp: 
public List<String> stringOrderbyLengthCustomThenby() { String[] words = {"cherry", "apple", "blueberry","banana","abacus"}; List<String> sortedWords = Arrays.stream(words).sorted(Comparator .comparing((String w) -> w.length(),new CustomNumberComparer()) .thenComparing(new CustomNumberComparer())).toList(); return sortedWords; }

BLEU: 49.1
Edit Sim: 25


Src: 
public List<Tuple<String,int>> CountRegionDistinctCustomer() { List<Customer> customers = GetCustomerList(); List<Tuple<String,int>> regionCounts = customers.GroupBy(c=>c.Region) .Select(g=>Tuple.Create(g.Key, g.Distinct().Count())).ToList(); return regionCounts; }
Ref: 
public List<Pair<String, Integer>> countRegionDistinctCustomer() { List<Customer> customers = getCustomerList(); List<Pair<String, Integer>> regionCounts = customers.stream().collect(groupingBy(c -> c.getRegion())) .entrySet().stream().map(g -> Pair.with(g.getKey(), (int) g.getValue().stream().distinct().count())).toList(); return regionCounts; }
Hyp: 
public List<Pair<String, Integer>> countRegionDistinctCustomer() { List<Customer> customers = getCustomerList(); List<Pair<String, Integer>> regionCounts = customers.stream().collect(groupingBy(c -> c.getRegion())) .entrySet().stream().map(g -> Pair.with(g.getKey(), (int) g.getValue().stream().distinct().count())).toList(); return regionCounts; }

BLEU: 100.0
Edit Sim: 0


Src: 
public int[] TransformIndexToInt() { int[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 }; int[] textNums = numbers.Select(n => numbers[n]).ToArray(); return textNums; }
Ref: 
public int[] transformIndexToInt() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int[] textNums = Arrays.stream(numbers).map(n -> numbers[n]).toArray(); return textNums; }
Hyp: 
public int[] transformIndexToInt() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int[] textNums = (int[]) Arrays.stream(numbers).mapToInt(n -> numbers[n]).toArray(); return textNums; }

BLEU: 86.46
Edit Sim: 13


Src: 
public List<double> DoubleOrderbyModThenby() { double[] numbers = { 3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0 }; List<double> sortedNumbers = numbers.OrderBy(n => n % 1.5).ThenBy(n => n).ToList(); return sortedNumbers; }
Ref: 
public List<Double> doubleOrderbyModThenby() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; List<Double> sortedNumbers = Arrays.stream(numbers).boxed().sorted( Comparator.comparing((Double n) -> n % 1.5) .thenComparing(Comparator.naturalOrder())).toList(); return sortedNumbers; }
Hyp: 
public List<Double> doubleOrderbyModThenby() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; List<Double> sortedNumbers = Arrays.stream(numbers).boxed().sorted( Comparator.comparing((Double n) -> n % 1.5).thenComparing(Comparator.naturalOrder())).toList(); return sortedNumbers; }

BLEU: 88.28
Edit Sim: 1


Src: 
public double ExpensiveProductUnitPriceAggregateAverageWithSeed() { List<Product> products = GetProductList(); double seed = 15.5; double aggregateSum = products.Select(p => p.UnitPrice).Where(d => d > 100) .Aggregate(seed, (a, b) => (a + b) / 2); return aggregateSum; }
Ref: 
public double expensiveProductUnitPriceAggregateAverageWithSeed() { List<Product> products = getProductList(); double seed = 15.5; double aggregateSum = products.stream().map(p -> p.getUnitPrice()).filter(d -> d > 100) .reduce(seed,(a, b) ->(a + b) / 2); return aggregateSum; }
Hyp: 
public double expensiveProductUnitPriceAggregateAverageWithSeed() { List<Product> products = getProductList(); double aggregateSum = products.stream().map(p -> p.getUnitPrice()).filter(d -> d>100) .reduce(seed, (a, b) -> (a + b) / 2).getAsDouble(); return aggregateSum; }

BLEU: 51.7
Edit Sim: 38


Src: 
public List<string> ExpensiveProductNameOrderbyDescending() { List<Product> products = GetProductList(); List<string> sortedProducts = products.Where(p=>p.UnitPrice>100).Select(p => p.ProductName).OrderByDescending(n=>n).ToList(); return sortedProducts; }
Ref: 
public List<String> expensiveProductNameOrderbyDescending() { List<Product> products = getProductList(); List<String> sortedProducts = products.stream().filter(p -> p.getUnitPrice() > 100) .map(p -> p.getProductName()).sorted(Comparator.reverseOrder()).toList(); return sortedProducts; }
Hyp: 
public List<String> expensiveProductNameOrderbyDescending() { List<Product> products = getProductList(); List<String> sortedProducts = products.stream().filter(p -> p.getUnitPrice() > 100).map(p -> p.getProductName()) .sorted(Comparator.reverseOrder()).toList(); return sortedProducts; }

BLEU: 74.74
Edit Sim: 2


Src: 
public char[] ProjectionStringExcept() { string[] wordsA = {"Alice", "Bob", "Foo", "Bar"}; string[] wordsB = {"Cafe", "Bar","Restaurant" }; var first = wordsA.Select(n => n[0]); var second = wordsB.Select(n => n[0]); char[] words = first.Except(second).ToArray(); return words; }
Ref: 
public Character[] projectionStringExcept() { String[] wordsA = {"Alice", "Bob", "Foo", "Bar"}; String[] wordsB = {"Cafe", "Bar", "Restaurant"}; var first = Arrays.stream(wordsA).map(n -> n.charAt(0)); var second = Arrays.stream(wordsB).map(n -> n.charAt(0)); Character[] differemtWords = (Character[]) first.distinct().filter(a -> second.allMatch(b -> b != a)).toArray(); return differemtWords; }
Hyp: 
public char[] projectionStringExcept() { String[] wordsA = {"Alice", "Bob", "Foo", "Bar"}; String[] wordsB = {"Cafe", "Bar","Restaurant"}; var first = Arrays.stream(wordsA).map(n -> n.charAt(0)); var second = Arrays.stream(wordsB).map(n -> n.charAt(0)); char[] words = Stream.concat(first, second).toArray(); return words; }

BLEU: 55.05
Edit Sim: 88


Src: 
public Dictionary<string, List<Product>> ProductEachGroupSkip() { List<Product> products = GetProductList(); Dictionary<string, List<Product>> after3EachGroups = products.GroupBy(p => p.Category) .ToDictionary(g => g.Key, g => g.Skip(3).ToList()); return after3EachGroups; }
Ref: 
public Map<String, List<Product>> productEachGroupSkip() { List<Product> products = getProductList(); Map<String, List<Product>> after3EachGroups = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().skip(3).toList())); return after3EachGroups; }
Hyp: 
public Map<String, List<Product>> productEachGroupSkip() { List<Product> products = getProductList(); Map<String, List<Product>> after3EachGroups = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().skip(3).toList())); return after3EachGroups; }

BLEU: 100.0
Edit Sim: 0


Src: 
public List<Tuple<string, Product>> ProductEachCategoryElementAt() { List<Product> products = GetProductList(); List<Tuple<string, Product>> categories = products.GroupBy(p => p.Category) .Select(g => Tuple.Create(g.Key, g.ElementAt(1))).ToList(); return categories; }
Ref: 
public List<Pair<String, Product>> productEachCategoryElementAt() { List<Product> products = getProductList(); List<Pair<String, Product>> categories = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().skip(1).findFirst().get())).toList(); return categories; }
Hyp: 
public List<Pair<String, Product>> productEachCategoryElementAt() { List<Product> products = getProductList(); List<Pair<String, Product>> categories = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().skip(1)).toList(); return categories; }

BLEU: 88.44
Edit Sim: 19


Src: 
public List<string> StringOrderbyThenbyLengthCustom() { string[] words = { "cherry", "apple", "blueberry","banana","abacus" }; List<string> sortedWords = words.OrderBy(w => w) .ThenBy(w=>w.Length,new CustomNumberComparer()).ToList(); return sortedWords; }
Ref: 
public List<String> stringOrderbyThenbyLengthCustom() { String[] words = {"cherry", "apple", "blueberry", "banana", "abacus"}; List<String> sortedWords = Arrays.stream(words).sorted(Comparator.comparing((String w) -> w) .thenComparing(w -> w.length(),new CustomNumberComparer())).toList(); return sortedWords; }
Hyp: 
public List<String> stringOrderbyThenbyLengthCustom() { String[] words = {"cherry", "apple", "blueberry","banana","abacus"}; List<String> sortedWords = Arrays.stream(words) .sorted(Comparator.comparing((String w) -> w) .thenComparing(w -> w.length(),new CustomNumberComparer())).toList(); return sortedWords; }

BLEU: 71.41
Edit Sim: 3


Src: 
public int DistinctProductCategoryCount() { List<Product> products = GetProductList(); int count = products.Select(p => p.Category).Distinct().Count(); return count; }
Ref: 
public int distinctProductCategoryCount() { List<Product> products = getProductList(); int count = (int) products.stream().map(p -> p.getCategory()).distinct().count(); return count; }
Hyp: 
public int distinctProductCategoryCount() { List<Product> products = getProductList(); int count = (int) products.stream().map(p -> p.getCategory()) .distinct().count(); return count; }

BLEU: 80.32
Edit Sim: 1


Src: 
public Dictionary<string, List<Customer>> CustomerEachCountryOrdersMaxCustomerDict() { List<Customer> customers = GetCustomerList(); Dictionary<string, List<Customer>> customerOrdersMax = customers.GroupBy(c => c.Country) .ToDictionary(g => g.Key, g => g.Where(c => c.Orders.Count ==g.Max(c => c.Orders.Count)).ToList()); return customerOrdersMax; }
Ref: 
public Map<String, List<Customer>> customerEachCountryOrdersMaxCustomerDict() { List<Customer> customers = getCustomerList(); Map<String, List<Customer>> customerOrdersMax = customers.stream().collect(groupingBy(c -> c.getCountry())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream(). collect(groupingBy(c -> c.getOrders().size())).entrySet() .stream().max(Map.Entry.comparingByKey()).get().getValue())); return customerOrdersMax; }
Hyp: 
public Map<String, List<Customer>> customerEachCountryOrdersMaxCustomerDict() { List<Customer> customers = getCustomerList(); Map<String, List<Customer>> customerOrdersMax = customers.stream().collect(groupingBy(c -> c.getCountry())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream(). collect(groupingBy(c -> c.getOrders().size())).entrySet() .stream().max(Map.Entry.comparingByKey()).get().getValue())); return customerOrdersMax; }

BLEU: 100.0
Edit Sim: 0


Src: 
public int BigNumbersMinTwice() { int[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 }; int minNum = numbers.Where(n => n > 5).Min(n => n * 2); return minNum; }
Ref: 
public int bigNumbersMinTwice() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int minNum = Arrays.stream(numbers).filter(n -> n >= 5).map(n -> n * 2).min().getAsInt(); return minNum; }
Hyp: 
public int bigNumbersMinTwice() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int minNum = Arrays.stream(numbers).filter(n -> n >= 5).map(n -> n * 2).min().getAsInt(); return minNum; }

BLEU: 100.0
Edit Sim: 0


Src: 
public List<Tuple<string,string>> CustomerIdAndName() { List<Customer> customers = GetCustomerList(); List<Tuple<string,string>> customerProperties = customers.Select(c=> Tuple.Create(c.CustomerId,c.CompanyName)).ToList(); return customerProperties; }
Ref: 
public List<Pair<String, String>> customerIdAndName() { List<Customer> customers = getCustomerList(); List<Pair<String, String>> customerProperties = customers.stream().map(c -> Pair.with(c.getCustomerId(), c.getCompanyName())).toList(); return customerProperties; }
Hyp: 
public List<Pair<String, String>> customerIdAndName() { List<Customer> customers = getCustomerList(); List<Pair<String, String>> customerProperties = customers.stream().map(c -> Pair.with(c.getCustomerId(), c.getCompanyName())).toList(); return customerProperties; }

BLEU: 100.0
Edit Sim: 0


Src: 
public List<Tuple<bool, List<Product>>> ProductGroupByInStock() { List<Product> products = GetProductList(); List<Tuple<bool, List<Product>>> productGroup = products.GroupBy(p => p.UnitsInStock == 0) .Select(g => Tuple.Create(g.Key, g.ToList())).ToList(); return productGroup; }
Ref: 
public List<Pair<Boolean, List<Product>>> productGroupByInStock() { List<Product> products = getProductList(); List<Pair<Boolean, List<Product>>> productGroup = products.stream().collect(groupingBy(p -> p.getUnitsInStock() > 0)) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue())).toList(); return productGroup; }
Hyp: 
public List<Pair<Boolean, List<Product>>> productGroupByInStock() { List<Product> products = getProductList(); List<Pair<Boolean, List<Product>>> productGroup = products.stream().collect(groupingBy(p -> p.getUnitsInStock() > 0)) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue())).toList(); return productGroup; }

BLEU: 100.0
Edit Sim: 0


Src: 
public double[] ProjectionDoubleConcat() { double[] numbersA = { 0.1, 2.2, 4.3, 5.4, 6.5, 8.6, 9.7 }; double[] numbersB = { 0.1, 3.3, 5.4, 7.7, 8.6 }; var first = numbersA.Select(n => n - (int)n); var second = numbersB.Select(n => n - (int)n); double[] numbers = first.Concat(second).ToArray(); return numbers; }
Ref: 
public double[] projectionDoubleConcat() { double[] numbersA = {0.1, 2.2, 4.3, 5.4, 6.5, 8.6, 9.7}; double[] numbersB = {0.1, 3.3, 5.4, 7.7, 8.6}; var first = Arrays.stream(numbersA).map(n -> n - (int) n); var second = Arrays.stream(numbersB).map(n -> n - (int) n); double[] allNumbers = DoubleStream.concat(first, second).toArray(); return allNumbers; }
Hyp: 
public double[] projectionDoubleConcat() { double[] numbersA = {0.1, 2.2, 4.3, 5.4, 6.5, 8.6, 9.7}; double[] numbersB = {0.1, 3.3, 5.4, 7.7, 8.6}; var first = Arrays.stream(numbersA).map(n -> n - (int) n); var second = Arrays.stream(numbersB).map(n -> n - (int) n); return numbers; }

BLEU: 83.73
Edit Sim: 72


Src: 
public Product[] ProductsConvertToArray() { List<Product> products = GetProductList(); Product[] productsArray = products.OrderBy(p => p.UnitPrice).ToArray(); return productsArray; }
Ref: 
public Product[] productsConvertToArray() { List<Product> products = getProductList(); Product[] productsArray = (Product[]) products.stream().sorted(Comparator.comparing( p -> p.getUnitPrice())).toArray(); return productsArray; }
Hyp: 
public Product[] productsConvertToArray() { List<Product> products = getProductList(); Product[] productsArray = products.stream().sorted(Comparator.comparing( p -> p.getUnitPrice())).toArray(); return productsArray; }

BLEU: 85.81
Edit Sim: 12


Src: 
public List<double> DoubleOrderbyFraction() { double[] numbers = { 3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0 }; List<double> sortedNumbers = numbers.OrderBy(n => n-(int)n).ToList(); return sortedNumbers; }
Ref: 
public List<Double> doubleOrderbyFraction() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; List<Double> sortedNumbers = Arrays.stream(numbers).boxed().sorted(Comparator.comparing(n -> n - (int) n.doubleValue())).toList(); return sortedNumbers; }
Hyp: 
public List<Double> doubleOrderbyFraction() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; List<Double> sortedNumbers = Arrays.stream(numbers).boxed().sorted( Comparator.comparing((Double n) -> n - (int) n.doubleValue()) .toList(); return sortedNumbers; }

BLEU: 73.88
Edit Sim: 11


Src: 
public double ExpensiveProductUnitPriceAverage() { List<Product> products = GetProductList(); double averageUnitPrice = products.Where(p => p.UnitPrice > 100).Average(p => p.UnitPrice); return averageUnitPrice; }
Ref: 
public double expensiveProductUnitPriceAverage() { List<Product> products = getProductList(); double averageUnitPrice = products.stream().filter(p -> p.getUnitPrice() > 100) .mapToDouble(p -> p.getUnitPrice()).average().getAsDouble(); return averageUnitPrice; }
Hyp: 
public double expensiveProductUnitPriceAverage() { List<Product> products = getProductList(); double averageUnitPrice = products.stream().filter(p -> p.getUnitPrice() > 100) .mapToInt(p -> p.getUnitPrice()).average().getAsDouble(); return averageUnitPrice; }

BLEU: 87.87
Edit Sim: 6


Src: 
public List<Product> RepeatedProducts() { List<Product> products = Enumerable.Repeat(Product.Default, 30).ToList(); return products; }
Ref: 
public List<Product> repeatedProducts() { List<Product> products = Collections.nCopies(30,Product.DEFAULT); return products; }
Hyp: 
public List<Product> repeatedProducts() { List<Product> products = Collections.nCopies(30, Product.DEFAULT); return products; }

BLEU: 67.03
Edit Sim: 1


Src: 
public int ProjectedStringFirstOrDefault() { string[] strings = { "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine" }; int firstStringLength = strings.Select(s => s.Length) .FirstOrDefault(i => i % 2 == 0,-1); return firstStringLength; }
Ref: 
public int projectedStringFirstOrDefault() { String[] strings = {"zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"}; int firstStringLength = Arrays.stream(strings).mapToInt(s -> s.length()).filter(i -> i % 2 == 0).findFirst().orElse(-1); return firstStringLength; }
Hyp: 
public int projectedStringFirstOrDefault() { String[] strings = {"zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"}; int firstStringLength = Arrays.stream(strings).map(s -> s.length()).filter(i -> i % 2 == 0).findFirst().orElse(-1); return firstStringLength; }

BLEU: 91.85
Edit Sim: 5


Src: 
public List<Tuple<string,int>> ConvertSelectedTupleToList() { object[] numbers = { Tuple.Create("Alice", "50"), Tuple.Create("Bob", 40), Tuple.Create("Cathy", 45) }; List<Tuple<string,int>> strings = numbers.OfType<Tuple<string,int>>().ToList(); return strings; }
Ref: 
public List<Pair<String,Integer>> convertSelectedTupleToList() { Object[] numbers = { Pair.with("Alice", "50"), Pair.with("Bob", 40), Pair.with("Cathy", 45) }; List<Pair<String,Integer>> strings = Arrays.stream(numbers).filter(o->o instanceof Pair && ((Pair)o).getValue0() instanceof String &&((Pair)o).getValue1() instanceof Integer) .map(o->(Pair<String,Integer>)o).toList(); return strings; }
Hyp: 
public List<Pair<String,Integer>> convertSelectedTupleToList() { Object[] numbers = { Pair.with("Alice", "50"), Pair.with("Bob", 40), Pair.with("Cathy", 45) }; List<Pair<String,Integer>> strings =  Arrays.stream(numbers).filter(o->o instanceof Pair && ((Pair)o).getValue0() instanceof String &&((Pair)o).getValue1() instanceof Integer) .map(o->(Pair<String,Integer>)o).toList(); return strings; }

BLEU: 100.0
Edit Sim: 1


Src: 
public List<int> IntTakeWhile() { int[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 }; List<int> firstNumbersWhile = numbers.TakeWhile(i => i > 3).ToList(); return firstNumbersWhile; }
Ref: 
public List<Integer> intTakeWhile() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; List<Integer> after3Numbers = Arrays.stream(numbers).takeWhile(i -> i > 3).boxed().toList(); return after3Numbers; }
Hyp: 
public List<Integer> intTakeWhile() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; List<Integer> after3Numbers = Arrays.stream(numbers).takeWhile(i -> i > 3).boxed().toList(); return after3Numbers; }

BLEU: 100.0
Edit Sim: 0


Src: 
public List<Tuple<string, int, string>> CustomerCrossJoinRegionsWithCodeNameRegion() { List<Tuple<string, int>> regions = new List<Tuple<string, int>>{ Tuple.Create("BC", 101), Tuple.Create("BC", 105), Tuple.Create("OR", 121), Tuple.Create("LA", 143) }; List<Customer> customers = GetCustomerList(); List<Tuple<string, int, string>> q = regions.Join(customers, r => r.Item1, c => c.Region, (r, c) => Tuple.Create(r.Item1, r.Item2, c.CompanyName)).ToList(); return q; }
Ref: 
public List<Triplet<String, Integer, String>> customerCrossJoinRegionsWithCodeNameRegion() { List<Pair<String, Integer>> regions = Arrays.asList( Pair.with("BC", 101), Pair.with("BC", 105), Pair.with("OR", 121), Pair.with("LA", 143) ); List<Customer> customers = getCustomerList(); List<Triplet<String, Integer, String>> q = regions.stream().flatMap( r -> customers.stream().filter(c -> c.getRegion().equals(r.getValue0())).map( c -> Triplet.with(r.getValue0(), r.getValue1(), c.getCompanyName()))).toList(); return q; }
Hyp: 
public List<Triplet<String, Integer, String>> customerCrossJoinRegionsWithCodeNameRegion() { List<Pair<String, Integer>> regions = Arrays.asList( Pair.with("BC", 101), Pair.with("BC", 105), Pair.with("OR", 121), Pair.with("LA", 143) ); List<Customer> customers = getCustomerList(); List<Triplet<String, Integer, String>> q = regions.stream().map(r -> Triplet.with(r.getValue1(), customers.stream().filter(c -> c.getRegion().equals(r.getValue0())).toList(); return q; }

BLEU: 72.08
Edit Sim: 105


Src: 
public List<Product> ProductsConvertToList() { List<Product> products = GetProductList(); List<Product> productsList = products.OrderBy(p => p.UnitPrice).ToList(); return productsList; }
Ref: 
public List<Product> productsConvertToList() { List<Product> products = getProductList(); List<Product> productsList = products.stream().sorted(Comparator.comparing(p -> p.getUnitPrice())).toList(); return productsList; }
Hyp: 
public List<Product> productsConvertToList() { List<Product> products = getProductList(); List<Product> productsList = products.stream().sorted(Comparator.comparing( p -> p.getUnitPrice())).toList(); return productsList; }

BLEU: 79.13
Edit Sim: 1


Src: 
public List<Product> RepeatedProductsWithBase(Product product) { List<Product> products = Enumerable.Repeat(product, 10).ToList(); return products; }
Ref: 
public List<Product> repeatedProductsWithBase(Product product) { List<Product> products = Collections.nCopies(10,product); return products; }
Hyp: 
public List<Product> repeatedProductsWithBase(Product product) { List<Product> products = Collections.nCopies(10, product); return products; }

BLEU: 69.98
Edit Sim: 1


Src: 
public List<Tuple<string,List<Product>>> ProductGroupByCategoryOrderbyId() { List<Product> products = GetProductList(); List<Tuple<string,List<Product>>> productsGroups = products.GroupBy(p=>p.Category) .Select(g => Tuple.Create(g.Key,g.OrderBy(p=>p.ProductId).ToList())).ToList(); return productsGroups; }
Ref: 
public List<Pair<String, List<Product>>> productGroupByCategoryOrderbyId() { List<Product> products = getProductList(); List<Pair<String, List<Product>>> productsGroups = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream() .sorted(Comparator.comparing(p -> p.getProductId())).toList())).toList(); return productsGroups; }
Hyp: 
public List<Pair<String, List<Product>>> productGroupByCategoryOrderbyId() { List<Product> products = getProductList(); List<Pair<String, List<Product>>> productsGroups = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream(). sorted(Comparator.comparing(p -> p.getProductId())).toList())).toList(); return productsGroups; }

BLEU: 85.91
Edit Sim: 2


Src: 
public Dictionary<string, int> CustomerEachRegionOrdersSumDict() { List<Customer> customers = GetCustomerList(); Dictionary<string, int> ordersTotalSum = customers.GroupBy(c => c.Region) .ToDictionary(g=>g.Key, g=>g.Sum(c=>c.Orders.Count)); return ordersTotalSum; }
Ref: 
public Map<String, Integer> customerEachRegionOrdersSumDict() { List<Customer> customers = getCustomerList(); Map<String, Integer> ordersSum = customers.stream().collect(groupingBy(c -> c.getRegion())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().mapToInt(c -> c.getOrders().size()).sum())); return ordersSum; }
Hyp: 
public Map<String, Integer> customerEachRegionOrdersSumDict() { List<Customer> customers = getCustomerList(); Map<String, Integer> ordersTotalSum = customers.stream().collect(groupingBy(c -> c.getRegion())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().mapToInt(c -> c.getOrders().size()).sum())); return ordersTotalSum; }

BLEU: 83.48
Edit Sim: 10


Src: 
public List<string> StringIndexedWhere() { string[] words = { "cherry", "apple", "blueberry", "banana", "abacus" }; List<string> q = words.Where((w,i)=>w.Length<i).ToList(); return q; }
Ref: 
public List<String> stringIndexedWhere() { String[] words = {"cherry", "apple", "blueberry", "banana", "abacus"}; IntStream.range(0, words.length).filter(i -> words[i].length() < i).mapToObj(i -> words[i]).toList(); List<String> q = IntStream.range(0, words.length).filter(i -> words[i].length() < i).mapToObj(i -> words[i]).toList(); return q; }
Hyp: 
public List<String> stringIndexedWhere() { String[] words = {"cherry", "apple", "blueberry", "banana", "abacus"}; List<String> q = IntStream.range(0, words.length).filter(i -> words[i].length() < i) .mapToObj(i -> words[i]).toList(); return q; }

BLEU: 61.89
Edit Sim: 103


Src: 
public bool CategoryProductAnyMatch() { List<Product> products = GetProductList(); bool anyMatch = products.Where(p => p.Category == "Beverages").Any(p => p.UnitsInStock > 0); return anyMatch; }
Ref: 
public boolean categoryProductAnyMatch() { List<Product> products = getProductList(); boolean anyMatch = products.stream().filter(p -> p.getCategory() == "Beverages").anyMatch(p -> p.getUnitsInStock() > 0); return anyMatch; }
Hyp: 
public boolean categoryProductAnyMatch() { List<Product> products = getProductList(); boolean anyMatch = products.stream().filter(p -> p.getCategory() == "Beverages").anyMatch(p -> p.getUnitsInStock() > 0); return anyMatch; }

BLEU: 100.0
Edit Sim: 0


Src: 
public List<Tuple<string, Product>> ProductEachCategoryFirst() { List<Product> products = GetProductList(); List<Tuple<string, Product>> categories = products.GroupBy(p => p.Category) .Select(g => Tuple.Create(g.Key, g.First())).ToList(); return categories; }
Ref: 
public List<Pair<String, Product>> productEachCategoryFirst() { List<Product> products = getProductList(); List<Pair<String, Product>> categories = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().findFirst().get())).toList(); return categories; }
Hyp: 
public List<Pair<String, Product>> productEachCategoryFirst() { List<Product> products = getProductList(); List<Pair<String, Product>> categories = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().findFirst().get())).toList(); return categories; }

BLEU: 100.0
Edit Sim: 0


Src: 
public double DoubleFirst() { double[] numbers = { 3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0 }; double firstNum = numbers.First(); return firstNum; }
Ref: 
public double doubleFirst() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; double firstNum = Arrays.stream(numbers).findFirst().getAsDouble(); return firstNum; }
Hyp: 
public double doubleFirst() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; double firstNum = Arrays.stream(numbers).findFirst().getAsDouble(); return firstNum; }

BLEU: 100.0
Edit Sim: 0


Src: 
public List<int> ShortStringLengthOrderbyDescending() { string[] words = { "cherry", "apple", "blueberry", "pear", "peach", "melon" }; List<int> sortedWords = words.Where(w => w.Length < 6).Select(w => w.Length).OrderByDescending(w => w).ToList(); return sortedWords; }
Ref: 
public List<Integer> shortStringLengthOrderbyDescending() { String[] words = {"cherry", "apple", "blueberry", "pear", "peach", "melon"}; List<Integer> sortedWords = Arrays.stream(words).filter(w -> w.length() < 6).map(w -> w.length()) .sorted(Comparator.reverseOrder()).toList(); return sortedWords; }
Hyp: 
public List<Integer> shortStringLengthOrderbyDescending() { String[] words = {"cherry", "apple", "blueberry", "pear", "peach", "melon"}; List<Integer> sortedWords = Arrays.stream(words).filter(w -> w.length() < 6).map(w -> w.length()).sorted(Comparator.reverseOrder()).toList(); return sortedWords; }

BLEU: 86.46
Edit Sim: 1


Src: 
public List<double> BigDoubleFractionOrderby() { double[] numbers = { 3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0 }; List<double> sortedNumbers = numbers.Where(n => n > 5).Select(n => n-(int)n).OrderBy(n=>n).ToList(); return sortedNumbers; }
Ref: 
public List<Double> bigDoubleFractionOrderby() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; List<Double> sortedNumbers = Arrays.stream(numbers).filter(n -> n > 5).map(n -> n - (int) n).boxed().sorted().toList(); return sortedNumbers; }
Hyp: 
public List<Double> bigDoubleFractionOrderby() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; List<Double> sortedNumbers = Arrays.stream(numbers).filter(n->n>5).map(n -> n - (int) n).boxed().sorted().toList(); return sortedNumbers; }

BLEU: 79.24
Edit Sim: 4


Src: 
public Dictionary<string,int> ConvertSelectedTupleToDictionaryAndPrint() { object[] numbers = { Tuple.Create("Alice", "50"), Tuple.Create("Bob", 40), Tuple.Create("Cathy", 45) }; Dictionary<string,int> strings = numbers.OfType<Tuple<string,int>>().ToDictionary( t=>t.Item1,t=>t.Item2); foreach (var pair in strings) Console.WriteLine(pair.Key+":"+pair.Value); return strings; }
Ref: 
public Map<String,Integer> convertSelectedTupleToDictionaryAndPrint() { Object[] numbers = { Pair.with("Alice", "50"), Pair.with("Bob", 40), Pair.with("Cathy", 45) }; Map<String,Integer> strings = Arrays.stream(numbers).filter(o->o instanceof Pair && ((Pair)o).getValue0() instanceof String &&((Pair)o).getValue1() instanceof Integer) .map(o->(Pair<String,Integer>)o).collect(toMap(p->p.getValue0(),p->p.getValue1())); for (var pair : strings.entrySet()) System.out.println(pair.getKey()+":"+pair.getValue()); return strings; }
Hyp: 
public Map<String,Integer> convertSelectedTupleToDictionaryAndPrint() { Object[] numbers = { Pair.with("Alice", "50"), Pair.with("Bob", 40), Pair.with("Cathy", 45) }; Map<String,Integer> strings = Arrays.stream(numbers).filter(o->o instanceof Pair && ((Pair)o).getValue0() instanceof String &&((Pair)o).getValue1() instanceof Integer) .map(o->(Pair<String,Integer>)o).collect(toMap(p->p.getKey()+":"+p.getValue())); return strings; }

BLEU: 76.14
Edit Sim: 96


Src: 
public double BigDoubleNumbersSum() { double[] numbers = { 3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0 }; double numbersSum = numbers.Where(d => d > 5).Sum(); return numbersSum; }
Ref: 
public double bigDoubleNumbersSum() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; double numbersSum = Arrays.stream(numbers).filter(n -> n >= 5).sum(); return numbersSum; }
Hyp: 
public double bigDoubleNumbersSum() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; double numbersSum = Arrays.stream(numbers).filter(n -> n >= 5).sum(); return numbersSum; }

BLEU: 100.0
Edit Sim: 0


Src: 
public List<int> IntIndexedWhere() { int[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 }; List<int> q = numbers.Where((n,i)=>n<i).ToList(); return q; }
Ref: 
public List<Integer> intIndexedWhere() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; List<Integer> q = IntStream.range(0, numbers.length).filter(i -> numbers[i] < i).map(i -> numbers[i]).boxed().toList(); return q; }
Hyp: 
public List<Integer> intIndexedWhere() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int[] oddNumbers = Arrays.stream(numbers).filter(i -> n < i) .toArray(); List<Integer> q = IntStream.range(0, oddNumbers.length).filter(i -> oddNumbers[i] < i) .map(i -> oddNumbers[i]).boxed().toList(); return q; }

BLEU: 51.38
Edit Sim: 86


Src: 
public int[] OddIntPlusOne() { int[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 }; int[] numSelected = numbers.Where(n => n % 2 == 1).Select(n => n + 1).ToArray(); return numSelected; }
Ref: 
public int[] oddIntPlusOne() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int[] numSelected = Arrays.stream(numbers).filter(n -> n % 2 == 1).map(n -> n + 1).toArray(); return numSelected; }
Hyp: 
public int[] oddIntPlusOne() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int[] numSelected = Arrays.stream(numbers).filter(n -> n % 2 == 1).map(n -> n + 1).toArray(); return numSelected; }

BLEU: 100.0
Edit Sim: 0


Src: 
public List<Tuple<bool, List<string>>> StringGroupByLengthOrderbyLengthCustom() { string[] words = { "aPPLE", "AbAcUs", "bRaNcH", "BlUeBeRrY", "ClOvEr", "cHeRry" }; List<Tuple<bool, List<string>>> wordsGroups = words.GroupBy(w => w.Length > 8) .Select(g => Tuple.Create(g.Key, g.OrderBy(w=>w.Length,new CustomNumberComparer()).ToList())).ToList(); return wordsGroups; }
Ref: 
public List<Pair<Boolean, List<String>>> stringGroupByLengthOrderbyLengthCustom() { String[] words = {"aPPLE", "AbAcUs", "bRaNcH", "BlUeBeRrY", "ClOvEr", "cHeRry"}; List<Pair<Boolean, List<String>>> wordsGroups = Arrays.stream(words).collect(groupingBy(w -> w.length() > 8)) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().sorted( Comparator.comparing(w -> w.length(), new CustomNumberComparer())).toList())).toList(); return wordsGroups; }
Hyp: 
public List<Pair<Boolean, List<String>>> stringGroupByLengthOrderbyLengthCustom() { String[] words = {"aPPLE", "AbAcUs", "bRaNcH", "BlUeBeRrY", "ClOvEr", "cHeRry"}; List<Pair<Boolean, List<String>>> wordsGroups = Arrays.stream(words).collect(groupingBy(w -> w.length() > 8)) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().sorted( Comparator.comparing(w -> w.length(), new CustomNumberComparer())).toList())).toList(); return wordsGroups; }

BLEU: 100.0
Edit Sim: 0


Src: 
public List<string> ConcatOfRegion() { string[] regions = { "WA", "AF", "RO" }; List<Customer> customers = GetCustomerList(); var customerRegions = customers.Select(c => c.Region); List<string> allRegions = customerRegions.Concat(regions).ToList(); return allRegions; }
Ref: 
public List<String> concatOfRegion() { String[] regions = {"WA", "AF", "RO"}; List<Customer> customers = getCustomerList(); var customerRegions = customers.stream().map(c -> c.getRegion()); List<String> allRegions = Stream.concat(customerRegions, Arrays.stream(regions)).toList(); return allRegions; }
Hyp: 
public List<String> concatOfRegion() { String[] regions = {"WA", "AF", "RO"}; List<Customer> customers = getCustomerList(); var customerRegions = customers.stream().map(c -> c.getRegion()); List<String> allRegions = Stream.concat(customerRegions, Arrays.stream(regions)).toList(); return allRegions; }

BLEU: 100.0
Edit Sim: 0


Src: 
public List<double> DoubleOrderbyFractionThenby() { double[] numbers = { 3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0 }; List<double> sortedNumbers = numbers.OrderBy(n => n-(int)n).ThenBy(n => n).ToList(); return sortedNumbers; }
Ref: 
public List<Double> doubleOrderbyFractionThenby() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; List<Double> sortedNumbers = Arrays.stream(numbers).boxed().sorted( Comparator.comparing((Double n) -> n - (int) n.doubleValue()) .thenComparing(Comparator.naturalOrder())).toList(); return sortedNumbers; }
Hyp: 
public List<Double> doubleOrderbyFractionThenby() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; List<Double> sortedNumbers = Arrays.stream(numbers).boxed().sorted( Comparator.comparing((Double n) -> n - (int) n.doubleValue()) .thenComparing(Comparator.naturalOrder())).toList(); return sortedNumbers; }

BLEU: 100.0
Edit Sim: 0


Src: 
public List<Tuple<string,Order>> WaCustomerSelectManyCustomerNewOrders() { List<Customer> customers = GetCustomerList(); List<Tuple<string,Order>> customerProperties = customers.Where(c => c.Region == "WA").SelectMany( c=>c.Orders.Where(o=>o.OrderDate>new DateTime(1998, 1, 1)), (c,o)=>Tuple.Create(c.CustomerId, o)).ToList(); return customerProperties; }
Ref: 
public List<Pair<String, Order>> waCustomerSelectManyCustomerNewOrders() { List<Customer> customers = getCustomerList(); List<Pair<String, Order>> customerProperties = customers.stream().filter(c -> c.getRegion().equals("WA")).flatMap(c -> c.getOrders() .stream().filter(o -> o.getOrderDate().isAfter(LocalDate.of(1998, 1, 1))) .map(o -> Pair.with(c.getCustomerId(), o))).toList(); return customerProperties; }
Hyp: 
public List<Pair<String, Order>> waCustomerSelectManyCustomerNewOrders() { List<Customer> customers = getCustomerList(); List<Pair<String, Order>> customerProperties = customers.stream().filter(c -> c.getRegion().equals("WA")).flatMap(c -> c.getOrders() .stream().filter(o -> o.getOrderDate().isAfter(LocalDate.of(1998, 1, 1))) .map(o -> Pair.with(c.getCustomerId(), o))).toList(); return customerProperties; }

BLEU: 100.0
Edit Sim: 0


Src: 
public List<Order> CustomerSelectManyNewOrders() { List<Customer> customers = GetCustomerList(); List<Order> customerProperties = customers.SelectMany(c=> c.Orders.Where(o=>o.OrderDate>new DateTime(1998, 1, 1))).ToList(); return customerProperties; }
Ref: 
public List<Order> customerSelectManyNewOrders() { List<Customer> customers = getCustomerList(); List<Order> customerProperties = customers.stream().flatMap(c -> c.getOrders() .stream().filter(o -> o.getOrderDate().isAfter(LocalDate.of(1998, 1, 1)))).toList(); return customerProperties; }
Hyp: 
public List<Order> customerSelectManyNewOrders() { List<Customer> customers = getCustomerList(); List<Order> customerProperties = customers.stream().flatMap(c -> c.getOrders() .stream().filter(o -> o.getOrderDate().isAfter(LocalDate.of(1998, 1, 1))).filter(o -> o.getOrderDate().isAfter(LocalDate.of(1998, 1, 1))).toList(); return customerProperties; }

BLEU: 74.06
Edit Sim: 63


Src: 
public List<double> BigDoubleOrderbyModThenbyDescending() { double[] numbers = { 3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0 }; List<double> sortedNumbers = numbers.Where(n=>n>3).OrderBy(n => n % 1.5).ThenByDescending(n => n).ToList(); return sortedNumbers; }
Ref: 
public List<Double> bigDoubleOrderbyModThenbyDescending() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; List<Double> sortedNumbers = Arrays.stream(numbers).filter(n->n>3).boxed().sorted( Comparator.comparing((Double n) -> n % 1.5) .thenComparing(Comparator.reverseOrder())).toList(); return sortedNumbers; }
Hyp: 
public List<Double> bigDoubleOrderbyModThenbyDescending() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; List<Double> sortedNumbers = Arrays.stream(numbers).filter(n->n>3).boxed().sorted( Comparator.comparing((Double n) -> n % 1.5,Comparator.reverseOrder()) .thenComparing(Comparator.reverseOrder())).toList(); return sortedNumbers; }

BLEU: 91.57
Edit Sim: 26


Src: 
public int[] IntZipAdd() { int[] numbersA = { 0, 2, 4, 5, 6, 8, 9 }; int[] numbersB = { 1, 3, 5, 7, 8, 10, 11 }; int[] addNumbers = numbersA.Zip(numbersB, (a, b) => a + b).ToArray(); return addNumbers; }
Ref: 
public int[] intZipAdd() { int[] numbersA = {0, 2, 4, 5, 6, 8, 9}; int[] numbersB = {1, 3, 5, 7, 8, 10, 11}; int length = numbersA.length; int[] addNumbers = IntStream.range(0, length).map(i -> numbersA[i] + numbersB[i]).toArray(); return addNumbers; }
Hyp: 
public int[] intZipAdd() { int[] numbersA = {0, 2, 4, 5, 6, 8, 9}; int[] numbersB = {1, 3, 5, 7, 8, 10, 11}; int[] addNumbers = IntStream.range(0, numbersA.length).map(i -> numbersA[i] + numbersB[i]).toArray(); return addNumbers; }

BLEU: 78.99
Edit Sim: 39


Src: 
public List<Tuple<bool, List<int>>> IntGroupByBool() { int[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 }; List<Tuple<bool, List<int>>> numberGroups = numbers.GroupBy(n => n > 4) .Select(g => Tuple.Create(g.Key, g.ToList())).ToList(); return numberGroups; }
Ref: 
public List<Pair<Boolean, List<Integer>>> intGroupByBool() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; List<Pair<Boolean, List<Integer>>> numberGroups = Arrays.stream(numbers).boxed().collect(groupingBy(n -> n > 4)) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue())).toList(); return numberGroups; }
Hyp: 
public List<Pair<Boolean, List<Integer>>> intGroupByBool() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; List<Pair<Boolean, List<Integer>>> numberGroups = numberGroups = Arrays.stream(numbers).boxed().collect(groupingBy(n -> n > 4)); return numberGroups; }

BLEU: 79.44
Edit Sim: 91


Src: 
public Dictionary<string, bool> ExpensiveProductEachGroupAllMatch() { List<Product> products = GetProductList(); Dictionary<string, bool> allMatch = products.Where(p => p.UnitPrice > 100).GroupBy(p => p.Category) .ToDictionary(g => g.Key, g => g.All(p => p.UnitsInStock > 0)); return allMatch; }
Ref: 
public Map<String, Boolean> expensiveProductEachGroupAllMatch() { List<Product> products = getProductList(); Map<String, Boolean> allMatch = products.stream().filter(p -> p.getUnitPrice() > 100).collect(groupingBy(p -> p.getCategory())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().allMatch(p -> p.getUnitsInStock() > 0))); return allMatch; }
Hyp: 
public Map<String, Boolean> expensiveProductEachGroupAllMatch() { List<Product> products = getProductList(); Map<String, Boolean> allMatch = products.stream().filter(p -> p.getUnitPrice() > 100).collect( groupingBy(p -> p.getCategory())).entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().allMatch(p -> p.getUnitsInStock() > 0)); return allMatch; }

BLEU: 75.35
Edit Sim: 3


Src: 
public List<string> ShortStringOrderbyDescendingLength() { string[] words = { "cherry", "apple", "blueberry", "pear", "peach", "melon" }; List<string> sortedWords = words.Where(w => w.Length < 6).OrderByDescending(w => w.Length).ToList(); return sortedWords; }
Ref: 
public List<String> shortStringOrderbyDescendingLength() { String[] words = {"cherry", "apple", "blueberry", "pear", "peach", "melon"}; List<String> sortedWords = Arrays.stream(words).filter(w -> w.length() < 6) .sorted(Comparator.comparing(w -> w.length(), Comparator.reverseOrder())).toList(); return sortedWords; }
Hyp: 
public List<String> shortStringOrderbyDescendingLength() { String[] words = {"cherry", "apple", "blueberry", "pear", "peach", "melon"}; List<String> sortedWords = Arrays.stream(words).filter(w -> w.length() < 6).sorted(Comparator.comparing(w -> w.length(), Comparator.reverseOrder())).toList(); return sortedWords; }

BLEU: 86.97
Edit Sim: 1


Src: 
public List<Product> ExpensiveProductTakeWhile() { List<Product> products = GetProductList(); List<Product> firstProductsWhile = products.Where(p => p.UnitPrice > 100).TakeWhile(p => p.ProductId > 100).ToList(); return firstProductsWhile; }
Ref: 
public List<Product> expensiveProductTakeWhile() { List<Product> products = getProductList(); List<Product> after3Products = products.stream().filter(p -> p.getUnitPrice() > 100).takeWhile(p -> p.getProductId() > 100).toList(); return after3Products; }
Hyp: 
public List<Product> expensiveProductTakeWhile() { List<Product> products = getProductList(); List<Product> after3Products = products.stream().filter(p -> p.getUnitPrice() > 100).takeWhile(p -> p.getProductId() > 100).toList(); return after3Products; }

BLEU: 100.0
Edit Sim: 0


Src: 
public List<Tuple<string, double>> CustomerOrdersTotalAverage() { List<Customer> customers = GetCustomerList(); List<Tuple<string, double>> ordersTotalAverage = customers.Select(c => Tuple.Create(c.CustomerId, c.Orders.Average(o => o.Total))).ToList(); return ordersTotalAverage; }
Ref: 
public List<Pair<String, Double>> customerOrdersTotalAverage() { List<Customer> customers = getCustomerList(); List<Pair<String, Double>> ordersTotalAverage = customers.stream().map(c -> Pair.with(c.getCustomerId(), c.getOrders().stream().mapToDouble(o -> o.getTotal()).average().getAsDouble())).toList(); return ordersTotalAverage; }
Hyp: 
public List<Pair<String, Double>> customerOrdersTotalAverage() { List<Customer> customers = getCustomerList(); List<Pair<String, Double>> ordersTotalAverage = customers.stream().map(c -> Pair.with(c.getCustomerId(), c.getOrders().stream().mapToDouble(o -> o.getTotal()).average().getAsDouble())).toList(); return ordersTotalAverage; }

BLEU: 100.0
Edit Sim: 0


Src: 
public Dictionary<String,int> CountDistinctProductByCategoryDict() { List<Product> products = GetProductList(); Dictionary<String,int> categoryCounts = products.GroupBy(p => p.Category) .ToDictionary(g=>g.Key,g => g.Distinct().Count()); return categoryCounts; }
Ref: 
public Map<String, Integer> countDistinctProductByCategoryDict() { List<Product> products = getProductList(); Map<String, Integer> categoryCounts = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> (int) g.getValue().stream().distinct().count())); return categoryCounts; }
Hyp: 
public Map<String, Integer> countDistinctProductByCategoryDict() { List<Product> products = getProductList(); Map<String, Integer> categoryCounts = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> (int) g.getValue().stream().distinct().count())); return categoryCounts; }

BLEU: 100.0
Edit Sim: 0


Src: 
public List<string> StringOrderby() { string[] words = { "cherry", "apple", "blueberry" }; List<string> sortedWords = words.OrderBy(w => w).ToList(); return sortedWords; }
Ref: 
public List<String> stringOrderby() { String[] words = {"cherry", "apple", "blueberry"}; List<String> sortedWords = Arrays.stream(words).sorted().toList(); return sortedWords; }
Hyp: 
public List<String> stringOrderby() { String[] words = {"cherry", "apple", "blueberry"}; List<String> sortedWords = Arrays.stream(words).sorted().collect( collectingAndThen(toList(),l->{Collections.reverse(l);return l;})); return sortedWords; }

BLEU: 74.83
Edit Sim: 67


Src: 
public List<Tuple<string, double>>  ProductCrossGroupJoinCategoriesUnitPrice() { string[] categories = { "Beverages", "Condiments", "Vegetables", "Dairy Products", "Seafood" }; List<Product> products = GetProductList(); List<Tuple<string, double>> q = categories.GroupJoin(products, c => c, p => p.Category, (c, p) => Tuple.Create(c, p)) .SelectMany(t => t.Item2.Select(p=>p.UnitPrice), (t, n) => Tuple.Create(t.Item1, n)).ToList(); return q; }
Ref: 
public List<Pair<String, Double>> productCrossGroupJoinCategoriesUnitPrice() { String[] categories = {"Beverages", "Condiments", "Vegetables", "Dairy Products", "Seafood"}; List<Product> products = getProductList(); List<Pair<String, Double>> q = Arrays.stream(categories).map( c -> Pair.with(c, products.stream().filter(p -> p.getCategory().equals(c)) .collect(Collectors.toList()))).flatMap(t -> t.getValue1().stream() .map(p1 -> Pair.with(t.getValue0(), p1.getUnitPrice()))).toList(); return q; }
Hyp: 
public List<Pair<String, Double>> productCrossGroupJoinCategoriesUnitPrice() { String[] categories = {"Beverages", "Condiments", "Vegetables", "Dairy Products", "Seafood"}; List<Product> products = getProductList(); List<Pair<String, Double>> q = Arrays.stream(categories).map( c -> Pair.with(c, products.stream().filter(p -> p.getCategory().equals(c)) .collect(Collectors.toList()))).flatMap(t -> t.getValue1().stream() .map(n -> Pair.with(t.getValue0(), n))).toList(); return q; }

BLEU: 87.35
Edit Sim: 18


Src: 
public double NumbersAggregateFindMin() { double[] numbers = { 1.7, 2.3, 1.9, 4.1, 2.9 }; double aggregateSum = numbers.Aggregate((a, b) => Math.Min(a,b)); return aggregateSum; }
Ref: 
public double numbersAggregateFindMin() { double[] numbers = {1.7, 2.3, 1.9, 4.1, 2.9}; double aggregateSum = Arrays.stream(numbers).filter(n -> n > 2).reduce((a, b) -> Math.min(a, b)).getAsDouble(); return aggregateSum; }
Hyp: 
public double numbersAggregateFindMin() { double[] numbers = {1.7, 2.3, 1.9, 4.1, 2.9}; double aggregateSum = Arrays.stream(numbers).filter(n -> n > 2).reduce((a, b) -> Math.min(a, b)).getAsDouble(); return aggregateSum; }

BLEU: 100.0
Edit Sim: 0


Src: 
public void OddNumbersEager() { int[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 }; int i = 0; var q = numbers.Where(n => n % 2 == 1).Select(n => i += n).ToList(); foreach (var v in q) Console.Write(v + " " + i); }
Ref: 
public void oddNumbersEager() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; AtomicInteger i = new AtomicInteger(0); var q = Arrays.stream(numbers).filter(n->n%2==1).map(n -> i.addAndGet(n)).boxed().toList(); for (var v : q) System.out.println(v + " " + i); }
Hyp: 
public void oddNumbersEager() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; AtomicInteger i = new AtomicInteger(0); var q = Arrays.stream(numbers).filter(n->n% 2 == 1).map(n -> i.addAndGet(n)).boxed().toList(); for (var v : q) System.out.println(v + " " + i); }

BLEU: 86.93
Edit Sim: 3


Src: 
public Dictionary<string,List<Product>> ProductGroupByCategoryDictOrderbyDescendingId() { List<Product> products = GetProductList(); Dictionary<string,List<Product>>  productsGroups = products.GroupBy(p=>p.Category) .ToDictionary(g => g.Key,g=>g.OrderByDescending(p=>p.ProductId).ToList()); return productsGroups; }
Ref: 
public Map<String, List<Product>> productGroupByCategoryDictOrderbyDescendingId() { List<Product> products = getProductList(); Map<String, List<Product>> productsGroups = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream() .sorted(Comparator.comparing(p -> p.getProductName(),Comparator.reverseOrder())).toList())); return productsGroups; }
Hyp: 
public Map<String, List<Product>> productGroupByCategoryDictOrderbyDescendingId() { List<Product> products = getProductList(); Map<String, List<Product>> productsGroups = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream(). sorted(Comparator.comparing(p -> p.getProductId(), Comparator.reverseOrder())).toList())); return productsGroups; }

BLEU: 77.61
Edit Sim: 7


Src: 
public bool UnequalStrings() { List<string> wordsA = new List<string> { "Alpha", "Beta", "Gamma" }; List<string> wordsB = new List<string> { "aLPhA", "bETa", "gAaMa" }; bool equal = wordsA.SequenceEqual(wordsB); return equal; }
Ref: 
public boolean unequalStrings() { List<String> wordsA = Arrays.asList("Alpha", "Beta", "Gamma"); List<String> wordsB = Arrays.asList("aLPhA", "bETa", "gAaMa"); boolean equal = wordsA.equals(wordsB); return equal; }
Hyp: 
public boolean unequalStrings() { List<String> wordsA = Arrays.asList( "Alpha", "Beta", "Gamma" ); List<String> wordsB = Arrays.asList( "aLPhA", "bETa", "gAaMa" ); boolean equal = Arrays.equals(wordsA, wordsB); return equal; }

BLEU: 37.37
Edit Sim: 17


Src: 
public List<double> DoubleOrderbyDescendingFraction() { double[] numbers = { 3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0 }; List<double> sortedNumbers = numbers.OrderByDescending(n => n-(int)n).ToList(); return sortedNumbers; }
Ref: 
public List<Double> doubleOrderbyDescendingFraction() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; List<Double> sortedNumbers = Arrays.stream(numbers).boxed().sorted( Comparator.comparing(n -> n - (int) n.doubleValue(), Comparator.reverseOrder())).toList(); return sortedNumbers; }
Hyp: 
public List<Double> doubleOrderbyDescendingFraction() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; List<Double> sortedNumbers = Arrays.stream(numbers).boxed().sorted( Comparator.comparing((Double n) -> n - (int) n.doubleValue(), Comparator.reverseOrder()) .thenComparing(Comparator.reverseOrder())).toList(); return sortedNumbers; }

BLEU: 77.82
Edit Sim: 51


Src: 
public List<string> IntersectOfCategory() { string[] categories = {"Furnitures", "Seagoods"}; List<Product> products = GetProductList(); var productCategories = products.Select(p => p.Category); List<string> sharedCategories = productCategories.Intersect(categories).ToList(); return sharedCategories; }
Ref: 
public List<String> intersectOfCategory() { String[] categories = {"Furnitures", "Seagoods"}; List<Product> products = getProductList(); var productCategories = products.stream().map(p -> p.getCategory()); List<String> sharedCategories = productCategories.distinct().filter(a -> Arrays.stream(categories).anyMatch(b -> b.equals(a))).toList(); return sharedCategories; }
Hyp: 
public List<String> intersectOfCategory() { String[] categories = {"Furnitures", "Seagoods"}; List<Product> products = getProductList(); var productCategories = products.stream().map(p -> p.getCategory()); List<String> sharedCategories = productCategories.distinct().filter(a -> customerCategories.anyMatch(b -> b.equals(a))).toList(); return sharedCategories; }

BLEU: 91.28
Edit Sim: 14


Src: 
public Dictionary<string, List<string>>  CustomerGroupJoinRegionsName() { string[] regions = { "BC", "SP", "OR", "LA" }; List<Customer> customers = GetCustomerList(); Dictionary<string, List<string>> q = regions.GroupJoin(customers, r => r, c => c.Region, (r, c) => Tuple.Create(r, c.Select(c1=>c1.CompanyName).ToList())) .ToDictionary(t => t.Item1, t => t.Item2); return q; }
Ref: 
public Map<String, List<String>> customerGroupJoinRegionsName() { String[] regions = {"BC", "SP", "OR", "LA"}; List<Customer> customers = getCustomerList(); Map<String, List<String>> q = Arrays.stream(regions).map(r -> Pair.with(r, customers.stream() .filter(c -> c.getRegion().equals(r)).map(c->c.getCompanyName()).toList())) .collect(toMap(t->t.getValue0(),t->t.getValue1())); return q; }
Hyp: 
public Map<String, List<String>> customerGroupJoinRegionsName() { String[] regions = {"BC", "SP", "OR", "LA"}; List<Customer> customers = getCustomerList(); Map<String, List<String>> q = Arrays.stream(regions).map(r -> Pair.with(r, customers.stream() .filter(c -> c.getRegion().equals(r)).map(c->c.getCompanyName()).toList())) .collect(toMap(t->t.getValue0(),t->t.getValue1())); return q; }

BLEU: 100.0
Edit Sim: 0


Src: 
public List<Product> ProductSkip() { List<Product> products = GetProductList(); List<Product> after3Products = products.Skip(3).ToList(); return after3Products; }
Ref: 
public List<Product> productSkip() { List<Product> products = getProductList(); List<Product> after3Products = products.stream().skip(3).toList(); return after3Products; }
Hyp: 
public List<Product> productSkip() { List<Product> products = getProductList(); List<Product> after3Products = products.stream().skip(3).toList(); return after3Products; }

BLEU: 100.0
Edit Sim: 0


Src: 
public bool StringAnyMatch() { string[] words = { "cherry", "apple", "blueberry", "banana", "abacus" }; bool anyMatch = words.Any(n => string.CompareOrdinal(n, "b") > 0); return anyMatch; }
Ref: 
public boolean stringAnyMatch() { String[] words = {"cherry", "apple", "blueberry", "banana", "abacus"}; boolean anyMatch = Arrays.stream(words).anyMatch(n -> n.compareTo("b") > 0); return anyMatch; }
Hyp: 
public boolean stringAnyMatch() { String[] words = {"cherry", "apple", "blueberry", "banana", "abacus"}; boolean anyMatch = Arrays.stream(words).anyMatch(n -> n.compareTo("b") > 0); return anyMatch; }

BLEU: 100.0
Edit Sim: 0


Src: 
public List<Tuple<string, List<Customer>>> CustomerGroupByRegion() { List<Customer> customers = GetCustomerList(); List<Tuple<string, List<Customer>>> catagory = customers.GroupBy(c => c.Region) .Select(g => Tuple.Create(g.Key, g.ToList())).ToList(); return catagory; }
Ref: 
public List<Pair<String, List<Customer>>> customerGroupByRegion() { List<Customer> customers = getCustomerList(); List<Pair<String, List<Customer>>> catagory = customers.stream().collect(groupingBy(c -> c.getRegion())) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue())).toList(); return catagory; }
Hyp: 
public List<Pair<String, List<Customer>>> customerGroupByRegion() { List<Customer> customers = getCustomerList(); List<Pair<String, List<Customer>>> catagory = customers.stream().collect(groupingBy(c -> c.getRegion())); return catagory; }

BLEU: 69.5
Edit Sim: 76


Src: 
public void OddNumbersTwiceDeferred() { int[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 }; int i = 0; var q = numbers.Where(n => n % 2 == 1).Select(n => n * 2).Select(n => i += n); foreach (var v in q) Console.Write(v + " " + i); }
Ref: 
public void oddNumbersTwiceDeferred() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; AtomicInteger i = new AtomicInteger(0); var q = Arrays.stream(numbers).filter(n->n%2==1).map(n->n*2).map(n -> i.addAndGet(n)); q.forEach(v -> System.out.println(v + " " + i)); }
Hyp: 
public void oddNumbersTwiceDeferred() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; AtomicInteger i = new AtomicInteger(0); var q = Arrays.stream(numbers).filter(n->n% 2 == 1).map(n->n*2).map(n -> i.addAndGet(n)).boxed().toList(); for (var v : q) System.out.println(v + " " + i); }

BLEU: 66.73
Edit Sim: 32


Src: 
public int UniqueFactorsCount(int[] factors) { int factorsCount = factors.Distinct().Count(); return factorsCount; }
Ref: 
public int uniqueFactorsCount(int[] factors) { int factorsCount = (int) Arrays.stream(factors).distinct().count(); return factorsCount; }
Hyp: 
public int uniqueFactorsCount(int[] factors) { int factorsCount = Arrays.stream(factors).distinct().count(); return factorsCount; }

BLEU: 78.32
Edit Sim: 6


Src: 
public List<Tuple<string, DateTime>> CustomerOrdersEachNestedTakeWhile() { List<Customer> customers = GetCustomerList(); List<Tuple<string, DateTime>> firstOrdersEachWhile = customers .SelectMany(c => c.Orders.TakeWhile(o => o.OrderDate > new DateTime( 2000, 1, 1)), (c, o) => Tuple.Create( c.CustomerId, o.OrderDate)).ToList(); return firstOrdersEachWhile; }
Ref: 
public List<Pair<String, LocalDate>> customerOrdersEachNestedTakeWhile() { List<Customer> customers = getCustomerList(); List<Pair<String, LocalDate>> after3EachOrders = customers.stream().flatMap(c -> c.getOrders().stream() .takeWhile(o -> o.getOrderDate().isAfter(LocalDate.of(2000, 1, 1))) .map(o -> Pair.with(c.getCustomerId(), o.getOrderDate()))).toList(); return after3EachOrders; }
Hyp: 
public List<Pair<String, LocalDate>> customerOrdersEachNestedTakeWhile() { List<Customer> customers = getCustomerList(); List<Pair<String, LocalDate>> after3EachWiseOrders = customers.stream().flatMap(c -> c.getOrders().stream().takeWhile(o -> o.getOrderDate() .isAfter(LocalDate.of(2000, 1, 1))) .map(o -> Pair.with(c.getCustomerId(), o.getOrderDate()))).toList(); return after3EachWiseOrders; }

BLEU: 63.87
Edit Sim: 10


Src: 
public string[] StringConcat() { string[] wordsA = { "Alice", "Bob", "Foo", "Bar" }; string[] wordsB = { "Cafe", "Bar", "Restaurant" }; string[] allWords = wordsA.Concat(wordsB).ToArray(); return allWords; }
Ref: 
public String[] stringConcat() { String[] wordsA = {"Alice", "Bob", "Foo", "Bar"}; String[] wordsB = {"Cafe", "Bar", "Restaurant"}; String[] allWords = (String[]) Stream.concat(Arrays.stream(wordsA), Arrays.stream(wordsB)).toArray(); return allWords; }
Hyp: 
public String[] stringConcat() { String[] wordsA = {"Alice", "Bob", "Foo", "Bar"}; String[] wordsB = {"Cafe", "Bar", "Restaurant"}; int length = wordsA.length; String[] allWords = (String[]) Arrays.stream(wordsA).concat(wordsB).toArray(); return allWords; }

BLEU: 71.01
Edit Sim: 56


Src: 
public List<double> DoubleOrderbyFractionDescendingThenbyDescending() { double[] numbers = { 3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0 }; List<double> sortedNumbers = numbers.OrderByDescending(n => n-(int)n).ThenByDescending(n => n).ToList(); return sortedNumbers; }
Ref: 
public List<Double> doubleOrderbyFractionDescendingThenbyDescending() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; List<Double> sortedNumbers = Arrays.stream(numbers).boxed().sorted( Comparator.comparing((Double n) -> n - (int) n.doubleValue(),Comparator.reverseOrder()) .thenComparing(Comparator.reverseOrder())).toList(); return sortedNumbers; }
Hyp: 
public List<Double> doubleOrderbyFractionDescendingThenbyDescending() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; List<Double> sortedNumbers = Arrays.stream(numbers).boxed().sorted( Comparator.comparing((Double n) -> n - (int) n.doubleValue()) .thenComparing(Comparator.reverseOrder())).toList(); return sortedNumbers; }

BLEU: 91.85
Edit Sim: 26


Src: 
public Dictionary<bool, List<int>> IntGroupByBoolDictPrint() { int[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 }; Dictionary<bool, List<int>> numberGroups = numbers.GroupBy(n => n > 4) .ToDictionary(g => g.Key, g => g.ToList()); numberGroups[true].ForEach(n => Console.Write(n)); Console.WriteLine(); numberGroups[false].ForEach(n => Console.Write(n)); return numberGroups; }
Ref: 
public Map<Boolean, List<Integer>> intGroupByBoolDictPrint() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; Map<Boolean, List<Integer>> numberGroups = numberGroups = Arrays.stream(numbers).boxed().collect(groupingBy(n -> n > 4)) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue())); numberGroups.get(true).stream().forEach(n -> System.out.print(n)); System.out.println(); numberGroups.get(false).stream().forEach(n -> System.out.print(n)); return numberGroups; }
Hyp: 
public Map<Boolean, List<Integer>> intGroupByBoolDictPrint() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; Map<Boolean, List<Integer>> numberGroups = Arrays.stream(numbers).boxed().collect(groupingBy(n -> n > 4)); return numberGroups; }

BLEU: 54.78
Edit Sim: 244


Src: 
public List<Tuple<string,DateTime>> CustomerSelectManyCustomerOrderDates() { List<Customer> customers = GetCustomerList(); List<Tuple<string,DateTime>> customerProperties = customers.SelectMany(c=>c.Orders, (c,o)=>Tuple.Create(c.CustomerId, o.OrderDate)).ToList(); return customerProperties; }
Ref: 
public List<Pair<String, LocalDate>> customerSelectManyCustomerOrderDates() { List<Customer> customers = getCustomerList(); List<Pair<String, LocalDate>> customerProperties = customers.stream().flatMap(c -> c.getOrders() .stream().map(o -> Pair.with(c.getCustomerId(), o.getOrderDate()))).toList(); return customerProperties; }
Hyp: 
public List<Pair<String, LocalDate>> customerSelectManyCustomerOrderDates() { List<Customer> customers = getCustomerList(); List<Pair<String, LocalDate>> customerProperties = customers.stream().flatMap(c -> c.getOrders() .stream().map(o -> Pair.with(c.getCustomerId(), o.getOrderDate()))).toList(); return customerProperties; }

BLEU: 100.0
Edit Sim: 0


Src: 
public List<Tuple<string, string>> CustomerCrossJoinRegionsPhone() { string[] regions = { "BC", "SP", "OR", "LA" }; List<Customer> customers = GetCustomerList(); List<Tuple<string, string>> q = regions.Join(customers, r => r, c => c.Region, (r, c) => Tuple.Create(r, c.Phone)).ToList(); return q; }
Ref: 
public List<Pair<String, String>> customerCrossJoinRegionsPhone() { String[] regions = {"BC", "SP", "OR", "LA"}; List<Customer> customers = getCustomerList(); List<Pair<String, String>> q = Arrays.stream(regions).flatMap( r -> customers.stream().filter(c -> c.getRegion().equals(r)).map( c -> Pair.with(r, c.getPhone()))).toList(); return q; }
Hyp: 
public List<Pair<String, String>> customerCrossJoinRegionsPhone() { String[] regions = {"BC", "SP", "OR", "LA"}; List<Customer> customers = getCustomerList(); List<Pair<String, String>> q = Arrays.stream(regions).map(r -> Pair.with(r, customers.stream().filter(c -> c.getRegion().equals(r)).map(c -> Pair.with(r, c.getPhone()))).toList(); return q; }

BLEU: 76.28
Edit Sim: 20


Src: 
public double[] DoubleIntersect() { double[] numbersA = { 0.1, 2.2, 4.3, 5.4, 6.5, 8.6, 9.7 }; double[] numbersB = { 0.1, 3.3, 5.4, 7.7, 8.6 }; double[] sharedNumbers = numbersA.Intersect(numbersB).ToArray(); return sharedNumbers; }
Ref: 
public double[] doubleIntersect() { double[] numbersA = {0.1, 2.2, 4.3, 5.4, 6.5, 8.6, 9.7}; double[] numbersB = {0.1, 3.3, 5.4, 7.7, 8.6}; double[] sharedNumbers = Arrays.stream(numbersA).distinct().filter(a -> Arrays.stream(numbersB).anyMatch(b -> b == a)).toArray(); return sharedNumbers; }
Hyp: 
public double[] doubleIntersect() { double[] numbersA = {0.1, 2.2, 4.3, 5.4, 6.5, 8.6, 9.7}; double[] numbersB = {0.1, 3.3, 5.4, 7.7, 8.6}; double[] sharedNumbers = DoubleStream.concat(Arrays.stream(numbersA), Arrays.stream(numbersB)).distinct().toArray(); return sharedNumbers; }

BLEU: 74.38
Edit Sim: 57


Src: 
public List<char> ConcatOfNameFirstChar() { List<Product> products = GetProductList(); List<Customer> customers = GetCustomerList(); var productFirstChars = products.Select(p => p.ProductName[0]); var customerFirstChars = customers.Select(c => c.CompanyName[0]); List<char> allFirstChars = productFirstChars.Concat(customerFirstChars).ToList(); return allFirstChars; }
Ref: 
public List<Character> concatOfNameFirstChar() { List<Product> products = getProductList(); List<Customer> customers = getCustomerList(); var productFirstChars = products.stream().map(p -> p.getProductName().charAt(0)); var customerFirstChars = customers.stream().map(c -> c.getCompanyName().charAt(0)); List<Character> allFirstChars = Stream.concat(productFirstChars, customerFirstChars).toList(); return allFirstChars; }
Hyp: 
public List<Character> concatOfNameFirstChar() { List<Product> products = getProductList(); List<Customer> customers = getCustomerList(); var productFirstChars = products.stream().map(p -> p.getProductName().charAt(0)); var customerFirstChars = customers.stream().map(c -> c.getCompanyName().charAt(0)); List<Character> allFirstChars = Stream.concat(productFirstChars, customerFirstChars).toList(); return allFirstChars; }

BLEU: 100.0
Edit Sim: 0


Src: 
public List<string> UnionOfCategory() { string[] categories = {"Furnitures", "Seagoods"}; List<Product> products = GetProductList(); var productCategories = products.Select(p => p.Category); List<string> uniqueCategories = productCategories.Union(categories).ToList(); return uniqueCategories; }
Ref: 
public List<String> unionOfCategory() { String[] categories = {"Furnitures", "Seagoods"}; List<Product> products = getProductList(); var productCategories = products.stream().map(p -> p.getCategory()); List<String> uniqueCategories = Stream.concat(productCategories, Arrays.stream(categories)).distinct().toList(); return uniqueCategories; }
Hyp: 
public List<String> unionOfCategory() { String[] categories = {"Furnitures", "Seagoods"}; List<Product> products = getProductList(); var productCategories = products.stream().map(p -> p.getCategory()); List<String> uniqueCategories = Stream.concat(productCategories, Arrays.stream(categories)).distinct().toList(); return uniqueCategories; }

BLEU: 100.0
Edit Sim: 0


Src: 
public double NumbersAggregateSqrtWithSeed() { double[] numbers = { 1.7, 2.3, 1.9, 4.1, 2.9 }; double seed = 1.6; double aggregateSum = numbers.Aggregate(seed, (a, b) => Math.Sqrt(a * b)); return aggregateSum; }
Ref: 
public double numbersAggregateSqrtWithSeed() { double[] numbers = {1.7, 2.3, 1.9, 4.1, 2.9}; double seed = 1.6; double aggregateSum = Arrays.stream(numbers).filter(n -> n > 2).reduce(seed, (a, b) -> Math.sqrt(a * b)); return aggregateSum; }
Hyp: 
public double numbersAggregateSqrtWithSeed() { double[] numbers = {1.7, 2.3, 1.9, 4.1, 2.9}; double seed = 1.6; double aggregateSum = Arrays.stream(numbers).filter(n -> n * n == 2).reduce((a, b) -> Math.sqrt(a * b)).getAsDouble(); return aggregateSum; }

BLEU: 75.5
Edit Sim: 26


Src: 
public List<Product> ProductOrderbyCategoryThenbyDescendingName() { List<Product> products = GetProductList(); List<Product> sortedProducts = products.OrderBy(p => p.Category).ThenByDescending(p=>p.ProductName).ToList(); return sortedProducts; }
Ref: 
public List<Product> productOrderbyCategoryThenbyDescendingName() { List<Product> products = getProductList(); List<Product> sortedProducts =products.stream().sorted(Comparator.comparing((Product p) -> p.getCategory()) .thenComparing(p -> p.getProductName(),Comparator.reverseOrder())).toList(); return sortedProducts; }
Hyp: 
public List<Product> productOrderbyCategoryThenbyDescendingName() { List<Product> products = getProductList(); List<Product> sortedProducts = products.stream().sorted(Comparator.comparing((Product p) -> p.getCategory()) .thenComparing(p -> p.getProductName(),Comparator.reverseOrder())).toList(); return sortedProducts; }

BLEU: 82.32
Edit Sim: 1


Src: 
public List<Product> ExpensiveProductOrderbyDescendingName() { List<Product> products = GetProductList(); List<Product> sortedProducts = products.Where(p=>p.UnitPrice>100).OrderByDescending(p => p.ProductName).ToList(); return sortedProducts; }
Ref: 
public List<Product> expensiveProductOrderbyDescendingName() { List<Product> products = getProductList(); List<Product> sortedProducts = products.stream().filter(p -> p.getUnitPrice() > 100) .sorted(Comparator.comparing(p -> p.getProductName(), Comparator.reverseOrder())).toList(); return sortedProducts; }
Hyp: 
public List<Product> expensiveProductOrderbyDescendingName() { List<Product> products = getProductList(); List<Product> sortedProducts = products.stream().filter(p -> p.getUnitPrice() > 100).sorted(Comparator.comparing(p -> p.getProductName(), Comparator.reverseOrder())).toList(); return sortedProducts; }

BLEU: 83.97
Edit Sim: 1


Src: 
public List<Tuple<Tuple<string, int>, string>> CustomerLeftOuterJoinRegionsWithCodeNameRegion() { List<Tuple<string, int>> regions = new List<Tuple<string, int>>{ Tuple.Create("BC", 101), Tuple.Create("BC", 105), Tuple.Create("OR", 121), Tuple.Create("LA", 143) }; List<Customer> customers = GetCustomerList(); List<Tuple<Tuple<string, int>, string>> q = regions.GroupJoin(customers, r => r.Item1, c => c.Region, (r, c) => Tuple.Create(r, c)).SelectMany(t=> t.Item2.Select(c=>c.CompanyName).DefaultIfEmpty("No Customer"),(t, c) => Tuple.Create(t.Item1, c)).ToList(); return q; }
Ref: 
public List<Pair<Pair<String, Integer>, String>> customerLeftOuterJoinRegionsWithCodeNameRegion() { List<Pair<String, Integer>> regions = Arrays.asList( Pair.with("BC", 101), Pair.with("BC", 105), Pair.with("OR", 121), Pair.with("LA", 143) ); List<Customer> customers = getCustomerList(); List<Pair<Pair<String, Integer>, String>> q = regions.stream().map( r -> Pair.with(r, customers.stream().filter(c -> c.getRegion().equals(r)) .collect(Collectors.toList()))).flatMap(t -> defaultIfEmpty(t.getValue1(), null).stream() .map(p1 -> Pair.with(t.getValue0(), p1!=null?p1.getCompanyName():"No Customer"))).toList(); return q; }
Hyp: 
public List<Pair<String, Integer>, String>> customerLeftOuterJoinRegionsWithCodeNameRegion() { List<Pair<String, Integer>> regions = Arrays.asList( Pair.with("BC", 101), Pair.with("BC", 105), Pair.with("OR", 121), Pair.with("LA", 143) ); List<Customer> customers = getCustomerList(); List<Pair<String, Integer>, String>> q = regions.stream().map( r -> Pair.with(r, customers.stream().filter(c -> c.getRegion().equals(r)) .collect(Collectors.toList()))).flatMap(t -> defaultIfEmpty(t.getValue1(), null).stream() .map(p1 -> Pair.with(t.getValue0(), p1!=null?p1.getCompanyName():"No Customer"))).toList(); return q; }

BLEU: 90.92
Edit Sim: 10


Src: 
public List<int> IntSquareSkip() { int[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 }; List<int> after3Numbers = numbers.Select(i => i * i).Skip(3).ToList(); return after3Numbers; }
Ref: 
public List<Integer> intSquareSkip() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; List<Integer> after3Numbers = Arrays.stream(numbers).map(i -> i * i).skip(3).boxed().toList(); return after3Numbers; }
Hyp: 
public List<Integer> intSquareSkip() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; List<Integer> after3Numbers = Arrays.stream(numbers).map(i -> i * i).skip(3).boxed().toList(); return after3Numbers; }

BLEU: 100.0
Edit Sim: 0


Src: 
public Tuple<string, bool>[] SelectByEvenOdd() { int[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 }; string[] strings = { "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine" }; Tuple<string, bool>[] evenOddWords = numbers.Select(n => Tuple.Create(strings[n], n % 2 == 0)).ToArray(); return evenOddWords; }
Ref: 
public Pair<String, Boolean>[] selectByEvenOdd() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; String[] strings = {"zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"}; Pair<String, Boolean>[] evenOddWords = (Pair<String, Boolean>[]) Arrays.stream(numbers).mapToObj(n -> Pair.with(strings[n], n % 2 == 0)).toArray(); return evenOddWords; }
Hyp: 
public Pair<String, Boolean>[] selectByEvenOdd() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; String[] strings = {"zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"}; Pair<String, Boolean>[] evenOddWords = Arrays.stream(numbers).map(n -> Pair.with(strings[n], false).toArray(); return evenOddWords; }

BLEU: 76.53
Edit Sim: 42


Src: 
public List<Tuple<string, double>> CustomerEachCountryOrdersAverage() { List<Customer> customers = GetCustomerList(); List<Tuple<string, double>> ordersAverage = customers.GroupBy(c => c.Country) .Select(g => Tuple.Create(g.Key, g.Average(c => c.Orders.Count))).ToList(); return ordersAverage; }
Ref: 
public List<Pair<String, Double>> customerEachCountryOrdersAverage() { List<Customer> customers = getCustomerList(); List<Pair<String, Double>> ordersAverage = customers.stream().collect(groupingBy(c -> c.getCountry())) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().mapToInt(c -> c.getOrders().size()).average().getAsDouble())).toList(); return ordersAverage; }
Hyp: 
public List<Pair<String, Double>> customerEachCountryOrdersAverage() { List<Customer> customers = getCustomerList(); List<Pair<String, Double>> ordersAverage = customers.stream().collect(groupingBy(c -> c.getCountry())) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().mapToInt(c -> c.getOrders().size()).average().getAsDouble())).toList(); return ordersAverage; }

BLEU: 100.0
Edit Sim: 0


Src: 
public List<double> DoubleOrderbyDescending() { double[] numbers = { 3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0 }; List<double> sortedNumbers = numbers.OrderByDescending(n => n).ToList(); return sortedNumbers; }
Ref: 
public List<Double> doubleOrderbyDescending() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; List<Double> sortedNumbers = Arrays.stream(numbers).boxed().sorted(Comparator.reverseOrder()).toList(); return sortedNumbers; }
Hyp: 
public List<Double> doubleOrderbyDescending() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; List<Double> sortedNumbers = Arrays.stream(numbers).boxed(). sorted(Comparator.reverseOrder()).toList(); return sortedNumbers; }

BLEU: 85.31
Edit Sim: 1


Src: 
public List<Tuple<Tuple<string, int>, Customer>>  CustomerLeftOuterJoinRegionsWithCodeRegion() { List<Tuple<string, int>> regions = new List<Tuple<string, int>>{ Tuple.Create("BC", 101), Tuple.Create("BC", 105), Tuple.Create("OR", 121), Tuple.Create("LA", 143) }; List<Customer> customers = GetCustomerList(); List<Tuple<Tuple<string, int>, Customer>> q = regions.GroupJoin(customers, r => r.Item1, c => c.Region, (r, c) => Tuple.Create(r, c)).SelectMany(t=> t.Item2.DefaultIfEmpty(null),(t, c) => Tuple.Create(t.Item1, c)).ToList(); return q; }
Ref: 
public List<Pair<Pair<String, Integer>, Customer>> customerLeftOuterJoinRegionsWithCodeRegion() { List<Pair<String, Integer>> regions = Arrays.asList( Pair.with("BC", 101), Pair.with("BC", 105), Pair.with("OR", 121), Pair.with("LA", 143) ); List<Customer> customers = getCustomerList(); List<Pair<Pair<String, Integer>, Customer>> q = regions.stream().map( r -> Pair.with(r, customers.stream().filter(c -> c.getRegion().equals(r)) .collect(Collectors.toList()))).flatMap(t -> defaultIfEmpty(t.getValue1(), null).stream() .map(p1 -> Pair.with(t.getValue0(), p1))).toList(); return q; }
Hyp: 
public List<Pair<String, Integer>, Customer>> customerLeftOuterJoinRegionsWithCodeRegion() { List<Pair<String, Integer>> regions = Arrays.asList( Pair.with("BC", 101), Pair.with("BC", 105), Pair.with("OR", 121), Pair.with("LA", 143) ); List<Customer> customers = getCustomerList(); List<Pair<String, Integer>, Customer>> q = regions.stream().map( r -> Pair.with(r, customers.stream().filter(c -> c.getRegion().equals(r)) .collect(Collectors.toList()))).flatMap(t -> defaultIfEmpty(t.getValue1(), null).stream() .map(p1 -> Pair.with(t.getValue0(), p1!=null?p1.getRegion():"LA", 143)).toList(); return q; }

BLEU: 83.35
Edit Sim: 40


Src: 
public int[] BigIntTwice() { int[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 }; int[] numSelected = numbers.Where(n => n > 5).Select(n => n * 2).ToArray(); return numSelected; }
Ref: 
public int[] bigIntTwice() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int[] numSelected = Arrays.stream(numbers).filter(n -> n > 5).map(n -> n * 2).toArray(); return numSelected; }
Hyp: 
public int[] bigIntTwice() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int[] bigNumbers = Arrays.stream(numbers).filter(n -> n > 5).toArray(); int[] numSelected = IntStream.range(0, bigNumbers.length).map(n -> bigNumbers[n] * 2).toArray(); return numSelected; }

BLEU: 69.64
Edit Sim: 92


Src: 
public List<Tuple<string, double>> ExpensiveProductEachCategoryStock() { List<Product> products = GetProductList(); List<Tuple<string, double>> categories = products.GroupBy(p => p.Category) .Select(g => Tuple.Create(g.Key, g.Where(p => p.UnitPrice > 100) .Average(p => p.UnitsInStock))).ToList(); return categories; }
Ref: 
public List<Pair<String, Double>> expensiveProductEachCategoryStock() { List<Product> products = getProductList(); List<Pair<String, Double>> categories = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().filter( p -> p.getUnitPrice() > 100).mapToInt(p -> p.getUnitsInStock()).average().getAsDouble())).toList(); return categories; }
Hyp: 
public List<Pair<String, Double>> expensiveProductEachCategoryStock() { List<Product> products = getProductList(); List<Pair<String, Double>> categories = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().filter( p -> p.getUnitPrice() > 100).mapToDouble(p -> p.getUnitsInStock()).average().getAsDouble())).toList(); return categories; }

BLEU: 91.28
Edit Sim: 6


Src: 
public List<Tuple<string, int, Customer>> CustomerCrossJoinRegionsWithCodeRegion() { List<Tuple<string, int>> regions = new List<Tuple<string, int>>{ Tuple.Create("BC", 101), Tuple.Create("BC", 105), Tuple.Create("OR", 121), Tuple.Create("LA", 143) }; List<Customer> customers = GetCustomerList(); List<Tuple<string, int, Customer>> q = regions.Join(customers, r => r.Item1, c => c.Region, (r, c) => Tuple.Create(r.Item1, r.Item2, c)).ToList(); return q; }
Ref: 
public List<Triplet<String, Integer, Customer>> customerCrossJoinRegionsWithCodeRegion() { List<Pair<String, Integer>> regions = Arrays.asList( Pair.with("BC", 101), Pair.with("BC", 105), Pair.with("OR", 121), Pair.with("LA", 143) ); List<Customer> customers = getCustomerList(); List<Triplet<String, Integer, Customer>> q = regions.stream().flatMap( r -> customers.stream().filter(c -> c.getRegion().equals(r.getValue0())).map( c -> Triplet.with(r.getValue0(), r.getValue1(), c))).toList(); return q; }
Hyp: 
public List<Pair<String, Integer, Customer>> customerCrossJoinRegionsWithCodeRegion() { List<Pair<String, Integer>> regions = Arrays.asList( Pair.with("BC", 101), Pair.with("BC", 105), Pair.with("OR", 121), Pair.with("LA", 143) ); List<Customer> customers = getCustomerList(); List<Pair<String, Integer, Customer>> q = regions.stream().map(r -> Pair.with(r.getValue1(), customers.stream().filter(c -> c.getRegion().equals(r.getValue0())).toList(); return q; }

BLEU: 61.56
Edit Sim: 100


Src: 
public List<Tuple<string, List<Customer>>> CustomerEachCountryOrdersFirstCustomer() { List<Customer> customers = GetCustomerList(); List<Tuple<string, List<Customer>>> customerOrdersFirst = customers.GroupBy(c => c.Country) .Select(g => Tuple.Create(g.Key, g.Where(c => c.Orders.Count ==g.First().Orders.Count).ToList())).ToList(); return customerOrdersFirst; }
Ref: 
public List<Pair<String, List<Customer>>> customerEachCountryOrdersFirstCustomer() { List<Customer> customers = getCustomerList(); List<Pair<String, List<Customer>>> customerOrdersFirst = customers.stream().collect(groupingBy(c -> c.getRegion())) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().filter( c -> c.getOrders().size() == g.getValue().stream().findFirst().get().getOrders().size()).toList())).toList(); return customerOrdersFirst; }
Hyp: 
public List<Pair<String, List<Customer>>> customerEachCountryOrdersFirstCustomer() { List<Customer> customers = getCustomerList(); List<Pair<String, List<Customer>>> customerOrdersFirst = customers.stream().collect(groupingBy(c -> c.getCountry())) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().filter( c -> c.getOrders().size() == g.getValue().stream().findFirst().getOrders().size()).toList())).toList(); return customerOrdersFirst; }

BLEU: 80.96
Edit Sim: 13


Src: 
public double ProjectedDoubleFirstOrDefault() { double[] numbers = { 3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0 }; double firstNum = numbers.Select(i => Math.Log2(i)) .FirstOrDefault(n => n > 3,3.01); return firstNum; }
Ref: 
public double projectedDoubleFirstOrDefault() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; double firstNum = Arrays.stream(numbers).map(i -> Math.log(i)).filter(n -> n > 3).findFirst().orElse(3.01); return firstNum; }
Hyp: 
public double projectedDoubleFirstOrDefault() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; double firstNum = Arrays.stream(numbers).map(i -> Math.log2(i)).filter(n -> n > 3).findFirst().orElse(3.01); return firstNum; }

BLEU: 91.28
Edit Sim: 1


Src: 
public Dictionary<string, List<string>> ProductGroupNameDict() { List<Product> products = GetProductList(); Dictionary<string, List<string>> productNames = products.GroupBy(p => p.Category) .ToDictionary(g => g.Key, g => g.Select(p => p.ProductName).ToList()); return productNames; }
Ref: 
public Map<String, List<String>> productGroupNameDict() { List<Product> products = getProductList(); Map<String, List<String>> productNames = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().map(p -> p.getProductName()).toList())); return productNames; }
Hyp: 
public Map<String, List<String>> productGroupNameDict() { List<Product> products = getProductList(); Map<String, List<String>> productNames = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().map(p -> p.getProductName()).toList())); return productNames; }

BLEU: 100.0
Edit Sim: 0


Src: 
public List<string> StringSkipCount(string[] strings, int n) { List<string> afterNWords = strings.Skip(n).ToList(); return afterNWords; }
Ref: 
public List<String> stringSkipCount(String[] strings, int n) { List<String> afterNWords = Arrays.stream(strings).skip(3).toList(); return afterNWords; }
Hyp: 
public List<String> stringSkipCount(String[] strings, int n) { List<String> afterNWords = Arrays.stream(strings).skip(3).toList(); return afterNWords; }

BLEU: 100.0
Edit Sim: 0


Src: 
public Dictionary<bool, List<Product>> ProductGroupByInStockDictPrint() { List<Product> products = GetProductList(); Dictionary<bool, List<Product>> productGroup = products.GroupBy(p => p.UnitsInStock == 0) .ToDictionary(g => g.Key, g => g.ToList()); productGroup[true].ForEach(p => Console.Write(p)); Console.WriteLine(); productGroup[false].ForEach(p => Console.Write(p)); return productGroup; }
Ref: 
public Map<Boolean, List<Product>> productGroupByInStockDictPrint() { List<Product> products = getProductList(); Map<Boolean, List<Product>> productGroup = products.stream().collect(groupingBy(p -> p.getUnitsInStock() > 0)); productGroup.get(true).stream().forEach(n -> System.out.print(n)); System.out.println(); productGroup.get(false).stream().forEach(n -> System.out.print(n)); return productGroup; }
Hyp: 
public Map<Boolean, List<Product>> productGroupByInStockDictPrint() { List<Product> products = getProductList(); Map<Boolean, List<Product>> productGroup = products.stream().collect(groupingBy(p -> p.getUnitsInStock() > 0)) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream())); Console.WriteLine(); return productGroup; }

BLEU: 66.49
Edit Sim: 104


Src: 
public Dictionary<string, double> CustomerOrdersTotalMinDict() { List<Customer> customers = GetCustomerList(); Dictionary<string, double> ordersTotalMin = customers.ToDictionary(c => c.CustomerId, c => c.Orders.Min(o => o.Total)); return ordersTotalMin; }
Ref: 
public Map<String, Double> customerOrdersTotalMinDict() { List<Customer> customers = getCustomerList(); Map<String, Double> ordersTotalMin = customers.stream().collect(toMap(c -> c.getCustomerId(), c -> c.getOrders().stream().mapToDouble(o -> o.getTotal()).min().getAsDouble())); return ordersTotalMin; }
Hyp: 
public Map<String, Double> customerOrdersTotalMinDict() { List<Customer> customers = getCustomerList(); Map<String, Double> ordersTotalMin = customers.stream().collect(toMap(c -> c.getCustomerId(), c -> c.getOrders().stream().mapToDouble(o -> o.getTotal()).min().getAsDouble())); return ordersTotalMin; }

BLEU: 100.0
Edit Sim: 0


Src: 
public List<Tuple<string, List<Product>>> ExpensiveProductEachCategoryMinUnitPriceProducts() { List<Product> products = GetProductList(); List<Tuple<string, List<Product>>> categories = products.Where(p=>p.UnitPrice>100).GroupBy(p => p.Category) .Select(g => Tuple.Create(g.Key, g.Where(p => p.UnitPrice == g.Min(p => p.UnitPrice)) .ToList())).ToList(); return categories; }
Ref: 
public List<Pair<String, List<Product>>> expensiveProductEachCategoryMinUnitPriceProducts() { List<Product> products = getProductList(); List<Pair<String, List<Product>>> categories = products.stream().filter(p -> p.getUnitPrice() > 100). collect(groupingBy(p -> p.getCategory())).entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().collect(groupingBy(p -> p.getUnitPrice())) .entrySet().stream().min(Map.Entry.comparingByKey()).get().getValue())).toList(); return categories; }
Hyp: 
public List<Pair<String, List<Product>>> expensiveProductEachCategoryMinUnitPriceProducts() { List<Product> products = getProductList(); List<Pair<String, List<Product>>> categories = products.stream().filter(p -> p.getUnitPrice() > 100). collect(groupingBy(p -> p.getCategory())).entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().collect(groupingBy(p -> p.getUnitPrice())) .entrySet().stream().min(Map.Entry.comparingByKey()).get().getValue())).toList(); return categories; }

BLEU: 100.0
Edit Sim: 0


Src: 
public Dictionary<string, int> CustomerEachCountryOrdersSumDict() { List<Customer> customers = GetCustomerList(); Dictionary<string, int> ordersTotalSum = customers.GroupBy(c => c.Country) .ToDictionary(g=>g.Key, g=>g.Sum(c=>c.Orders.Count)); return ordersTotalSum; }
Ref: 
public Map<String, Integer> customerEachCountryOrdersSumDict() { List<Customer> customers = getCustomerList(); Map<String, Integer> ordersSum = customers.stream().collect(groupingBy(c -> c.getCountry())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().mapToInt(c -> c.getOrders().size()).sum())); return ordersSum; }
Hyp: 
public Map<String, Integer> customerEachCountryOrdersSumDict() { List<Customer> customers = getCustomerList(); Map<String, Integer> ordersTotalSum = customers.stream().collect(groupingBy(c -> c.getCountry())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().mapToInt(c -> c.getOrders().size()).sum())); return ordersTotalSum; }

BLEU: 83.48
Edit Sim: 10


Src: 
public int BigNumbersMin() { int[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 }; int minNum = numbers.Where(n => n > 5).Min(); return minNum; }
Ref: 
public int bigNumbersMin() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int minNum = Arrays.stream(numbers).filter(n -> n >= 5).min().getAsInt(); return minNum; }
Hyp: 
public int bigNumbersMin() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int minNum = Arrays.stream(numbers).filter(n -> n >= 5).min().getAsInt(); return minNum; }

BLEU: 100.0
Edit Sim: 0


Src: 
public Dictionary<char, List<string>> StringGroupByFirstCharDictOrderbyDescending() { string[] words = { "blueberry", "chimpanzee", "abacus", "banana", "apple", "cheese" }; Dictionary<char, List<string>> wordsGroups = words.GroupBy(w => w[0]) .ToDictionary(g => g.Key, g => g.OrderByDescending(w=>w).ToList()); return wordsGroups; }
Ref: 
public Map<Character, List<String>> stringGroupByFirstCharDictOrderbyDescending() { String[] words = {"blueberry", "chimpanzee", "abacus", "banana", "apple", "cheese"}; Map<Character, List<String>> wordsGroups = Arrays.stream(words).collect(groupingBy(w -> w.charAt(0))) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().sorted(Comparator.reverseOrder()).toList())); return wordsGroups; }
Hyp: 
public Map<Character, List<String>> stringGroupByFirstCharDictOrderbyDescending() { String[] words = {"blueberry", "chimpanzee", "abacus", "banana", "apple", "cheese"}; Map<Character, List<String>> wordsGroups = Arrays.stream(words).collect(groupingBy(w -> w.charAt(0))) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream() .sorted(Comparator.reverseOrder()).toList())); return wordsGroups; }

BLEU: 88.28
Edit Sim: 1


Src: 
public double ProductUnitPriceAggregateAverageWithSeed() { List<Product> products = GetProductList(); double seed = 15.5; double aggregateSum = products.Select(p => p.UnitPrice).Aggregate(seed, (a, b) => (a + b) / 2); return aggregateSum; }
Ref: 
public double productUnitPriceAggregateAverageWithSeed() { List<Product> products = getProductList(); double seed = 15.5; double aggregateSum = products.stream().map(p -> p.getUnitPrice()).reduce(seed,(a, b) ->(a + b) / 2); return aggregateSum; }
Hyp: 
public double productUnitPriceAggregateAverageWithSeed() { List<Product> products = getProductList(); double aggregateSum = products.stream().map(p -> p.getUnitPrice()).reduce(seed, (a, b) -> (a + b) / 2).getAsDouble(); return aggregateSum; }

BLEU: 53.92
Edit Sim: 36


Src: 
public char[] ProjectionStringConcat() { string[] wordsA = { "Alice", "Bob", "Foo", "Bar" }; string[] wordsB = { "Cafe", "Bar", "Restaurant" }; var first = wordsA.Select(n => n[0]); var second = wordsB.Select(n => n[0]); char[] words = first.Concat(second).ToArray(); return words; }
Ref: 
public Character[] projectionStringConcat() { String[] wordsA = {"Alice", "Bob", "Foo", "Bar"}; String[] wordsB = {"Cafe", "Bar", "Restaurant"}; var first = Arrays.stream(wordsA).map(n -> n.charAt(0)); var second = Arrays.stream(wordsB).map(n -> n.charAt(0)); Character[] allWords = (Character[]) Stream.concat(first, second).toArray(); return allWords; }
Hyp: 
public char[] projectionStringConcat() { String[] wordsA = {"Alice", "Bob", "Foo", "Bar"}; String[] wordsB = {"Cafe", "Bar", "Restaurant"}; var first = Arrays.stream(wordsA).map(n -> n.charAt(0)); var second = Arrays.stream(wordsB).map(n -> n[0]); char[] words = Stream.concat(first, second).toArray(); return words; }

BLEU: 73.52
Edit Sim: 43


Src: 
public List<Tuple<string,DateTime>> CustomerSelectManyCustomerNewOrderDates() { List<Customer> customers = GetCustomerList(); List<Tuple<string,DateTime>> customerProperties = customers.SelectMany( c=>c.Orders.Where(o=>o.OrderDate>new DateTime(1998, 1, 1)), (c,o)=>Tuple.Create(c.CustomerId, o.OrderDate)).ToList(); return customerProperties; }
Ref: 
public List<Pair<String, LocalDate>> customerSelectManyCustomerNewOrderDates() { List<Customer> customers = getCustomerList(); List<Pair<String, LocalDate>> customerProperties = customers.stream().flatMap(c -> c.getOrders() .stream().filter(o -> o.getOrderDate().isAfter(LocalDate.of(1998, 1, 1))) .map(o -> Pair.with(c.getCustomerId(), o.getOrderDate()))).toList(); return customerProperties; }
Hyp: 
public List<Pair<String, LocalDate>> customerSelectManyCustomerNewOrderDates() { List<Customer> customers = getCustomerList(); List<Pair<String, LocalDate>> customerProperties = customers.stream().flatMap(c -> c.getOrders() .stream().filter(o -> o.getOrderDate().isAfter(LocalDate.of(1998, 1, 1))) .map(o -> Pair.with(c.getCustomerId(), o.getOrderDate()))).toList(); return customerProperties; }

BLEU: 100.0
Edit Sim: 0


Src: 
public double[] DoubleConcat() { double[] numbersA = { 0.1, 2.2, 4.3, 5.4, 6.5, 8.6, 9.7 }; double[] numbersB = { 0.1, 3.3, 5.4, 7.7, 8.6 }; double[] allNumbers = numbersA.Concat(numbersB).ToArray(); return allNumbers; }
Ref: 
public double[] doubleConcat() { double[] numbersA = {0.1, 2.2, 4.3, 5.4, 6.5, 8.6, 9.7}; double[] numbersB = {0.1, 3.3, 5.4, 7.7, 8.6}; double[] allNumbers = DoubleStream.concat(Arrays.stream(numbersA), Arrays.stream(numbersB)).toArray(); return allNumbers; }
Hyp: 
public double[] doubleConcat() { double[] numbersA = {0.1, 2.2, 4.3, 5.4, 6.5, 8.6, 9.7}; double[] numbersB = {0.1, 3.3, 5.4, 7.7, 8.6}; double[] allNumbers = DoubleStream.concat(Arrays.stream(numbersA), Arrays.stream(numbersB)).toArray(); return allNumbers; }

BLEU: 100.0
Edit Sim: 0


Src: 
public List<Tuple<char, List<string>>> StringGroupByFirstCharOrderbyDescending() { string[] words = { "blueberry", "chimpanzee", "abacus", "banana", "apple", "cheese" }; List<Tuple<char, List<string>>> wordsGroups = words.GroupBy(w => w[0]) .Select(g => Tuple.Create(g.Key, g.OrderByDescending(w=>w).ToList())).ToList(); return wordsGroups; }
Ref: 
public List<Pair<Character, List<String>>> stringGroupByFirstCharOrderbyDescending() { String[] words = {"blueberry", "chimpanzee", "abacus", "banana", "apple", "cheese"}; List<Pair<Character, List<String>>> wordsGroups = Arrays.stream(words).collect(groupingBy(w -> w.charAt(0))) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().sorted(Comparator.reverseOrder()).toList())).toList(); return wordsGroups; }
Hyp: 
public List<Pair<Character, List<String>>> stringGroupByFirstCharOrderbyDescending() { String[] words = {"blueberry", "chimpanzee", "abacus", "banana", "apple", "cheese"}; List<Pair<Character, List<String>>> wordsGroups = Arrays.stream(words).collect(groupingBy(w -> w.charAt(0))) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().sorted(Comparator.reverseOrder()).toList())).toList(); return wordsGroups; }

BLEU: 100.0
Edit Sim: 0


Src: 
public List<string> LongStringSkip() { string[] words = { "cherry", "apple", "blueberry", "banana", "abacus" }; List<string> after3Words = words.Where(w => w.Length > 5).Skip(3).ToList(); return after3Words; }
Ref: 
public List<String> longStringSkip() { String[] words = {"cherry", "apple", "blueberry", "banana", "abacus"}; List<String> after3Words = Arrays.stream(words).filter(w -> w.length() > 5).skip(3).toList(); return after3Words; }
Hyp: 
public List<String> longStringSkip() { String[] words = {"cherry", "apple", "blueberry", "banana", "abacus"}; List<String> after3Words = Arrays.stream(words).filter(w -> w.length() > 5).skip(3).toList(); return after3Words; }

BLEU: 100.0
Edit Sim: 0


Src: 
public List<int> IntTakeWhileIndexedCount(int[] numbers, int n) { List<int> firstNumbers = numbers.TakeWhile((n, i) => n > i).ToList(); return firstNumbers; }
Ref: 
public List<Integer> intTakeWhileIndexedCount(int[] numbers, int n) { List<Integer> afterNumbers = IntStream.range(0, numbers.length) .takeWhile(i -> n > i).map(i -> numbers[i]).boxed().toList(); return afterNumbers; }
Hyp: 
public List<Integer> intTakeWhileIndexedCount(int[] numbers, int n) { List<Integer> afterNumbers = IntStream.range(0, numbers.length) .takeWhile(i -> n > i).map(i -> numbers[i]).boxed().toList(); return afterNumbers; }

BLEU: 100.0
Edit Sim: 0


Src: 
public string StringFirstOrDefaultStartWith(char c) { string[] strings = { "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine" }; string startWithChar = strings.FirstOrDefault(s => s[0] == c,"none"); return startWithChar; }
Ref: 
public String stringFirstOrDefaultStartWith(char c) { String[] strings = {"zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"}; String startWithChar = Arrays.stream(strings).filter(s -> s.charAt(0) == c).findFirst().orElse("none"); return startWithChar; }
Hyp: 
public String stringFirstOrDefaultStartWith(char c) { String[] strings = {"zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"}; String startWithChar = Arrays.stream(strings).filter(s -> s.charAt(0) == c).findFirst().orElse(null); return startWithChar; }

BLEU: 90.96
Edit Sim: 5


Src: 
public Dictionary<bool, List<int>> ProductGroupByPriceWithIdDictPrint() { List<Product> products = GetProductList(); Dictionary<bool, List<int>> productGroup = products.GroupBy(p => p.UnitPrice > 100) .ToDictionary(g => g.Key, g => g.Select(p => p.ProductId).ToList()); productGroup[true].ForEach(p => Console.Write(p)); Console.WriteLine(); productGroup[false].ForEach(p => Console.Write(p)); return productGroup; }
Ref: 
public Map<Boolean, List<Integer>> productGroupByPriceWithIdDictPrint() { List<Product> products = getProductList(); Map<Boolean, List<Integer>> productGroup = products.stream().collect(groupingBy(p -> p.getUnitPrice() > 100)) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().map(p -> p.getProductId()).toList())); productGroup.get(true).stream().forEach(n -> System.out.print(n)); System.out.println(); productGroup.get(false).stream().forEach(n -> System.out.print(n)); return productGroup; }
Hyp: 
public Map<Boolean, List<Integer>> productGroupByPriceWithIdDictPrint() { List<Product> products = getProductList(); Map<Boolean, List<Integer>> productGroup = products.stream().collect(groupingBy(p -> p.getUnitPrice() > 100)) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().map(p -> p.getProductId()).toList())); Console.WriteLine(); return productGroup; }

BLEU: 74.73
Edit Sim: 141


Src: 
public List<string> ShortStringOrderby() { string[] words = { "cherry", "apple", "blueberry", "pear", "peach", "melon" }; List<string> sortedWords = words.Where(w => w.Length < 6).OrderBy(w => w).ToList(); return sortedWords; }
Ref: 
public List<String> shortStringOrderby() { String[] words = {"cherry", "apple", "blueberry", "pear", "peach", "melon"}; List<String> sortedWords = Arrays.stream(words).filter(w -> w.length() < 6).sorted().toList(); return sortedWords; }
Hyp: 
public List<String> shortStringOrderby() { String[] words = {"cherry", "apple", "blueberry", "pear", "peach", "melon"}; List<String> sortedWords = Arrays.stream(words).filter(w -> w.length() < 6).sorted().toList(); return sortedWords; }

BLEU: 100.0
Edit Sim: 0


Src: 
public bool[] BigIntWithOriginalIndex() { int[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 }; bool[] numSelected = numbers.Select((n, i) => Tuple.Create(n > 5,n == i)) .Where(t=>t.Item1).Select(t=>t.Item2).ToArray(); return numSelected; }
Ref: 
public Boolean[] bigIntWithOriginalIndex() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; Boolean[] numSelected = (Boolean[]) IntStream.range(0, numbers.length).filter(i -> numbers[i] > 5).filter(i -> numbers[i] % 2 == 1) .mapToObj(i -> numbers[i] == i).toArray(); return numSelected; }
Hyp: 
public boolean[] bigIntWithOriginalIndex() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; boolean[] bigNumbers = Arrays.stream(numbers).map(i -> Pair.with(n > 5, i == i)) .toArray(); boolean[] numSelected = IntStream.range(0, bigNumbers.length).filter(i -> bigNumbers[i] == i).map(i -> bigNumbers[i]).toArray(); return numSelected; }

BLEU: 42.04
Edit Sim: 139


Src: 
public int NumbersFirstOrDefault() { int[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 }; int firstNum = numbers.FirstOrDefault(-1); return firstNum; }
Ref: 
public int numbersFirstOrDefaultOrDefault() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int firstNum = Arrays.stream(numbers).findFirst().orElse(-1); return firstNum; }
Hyp: 
public int numbersFirstOrDefault() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int firstNum = Arrays.stream(numbers).findFirst().orElse(-1); return firstNum; }

BLEU: 90.16
Edit Sim: 9


Src: 
public int ShortStringMinLength() { string[] words = { "cherry", "apple", "blueberry" }; int minLength = words.Where(w => w.Length < 7).Min(w => w.Length); return minLength; }
Ref: 
public int shortStringMinLength() { String[] words = {"cherry", "apple", "blueberry"}; int minLength = Arrays.stream(words).filter(w -> w.length() < 7).mapToInt(w -> w.length()).min().getAsInt(); return minLength; }
Hyp: 
public int shortStringMinLength() { String[] words = {"cherry", "apple", "blueberry"}; int minLength = Arrays.stream(words).filter(w -> w.length() < 7).mapToInt(w -> w.length()).min().getAsInt(); return minLength; }

BLEU: 100.0
Edit Sim: 0


Src: 
public List<double> IntSqrtSkipWhileIndexed() { int[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 }; List<double> afterNumbers = numbers.Select(i => Math.Sqrt(i)).TakeWhile((n, i) => n > i).ToList(); return afterNumbers; }
Ref: 
public List<Double> intSqrtTakeWhileIndexed() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; List<Double> afterNumbers =  IntStream.range(0, numbers.length) .takeWhile(i -> Math.sqrt(numbers[i]) > i).mapToDouble(i -> Math.sqrt(numbers[i]) ).boxed().toList(); return afterNumbers; }
Hyp: 
public List<Double> intSqrtSkipWhileIndexed() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; List<Double> afterNumbers = IntStream.range(0, numbers.length).dropWhile(i -> numbers[i] > i).map(i -> Math.sqrt(i)).boxed().toList(); return afterNumbers; }

BLEU: 61.83
Edit Sim: 39


Src: 
public List<string> LongStringSkipWhile() { string[] words = { "cherry", "apple", "blueberry", "banana", "abacus" }; List<string> afterWordsWhile = words.Where(w => w.Length > 5).SkipWhile(w => w[0] > 'b').ToList(); return afterWordsWhile; }
Ref: 
public List<String> longStringSkipWhile() { String[] words = {"cherry", "apple", "blueberry", "banana", "abacus"}; List<String> after3Words = Arrays.stream(words).filter(w -> w.length() > 5).dropWhile(w -> w.charAt(0) > 'b').toList(); return after3Words; }
Hyp: 
public List<String> longStringSkipWhile() { String[] words = {"cherry", "apple", "blueberry", "banana", "abacus"}; List<String> afterNNumbers = Arrays.stream(words).filter(w -> w.length() > 5).dropWhile(w -> w.charAt(0) > 'b').toList(); return afterNNumbers; }

BLEU: 83.48
Edit Sim: 14


Src: 
public Dictionary<string, List<string>> ProductGroupJoinCategoriesName() { string[] categories = { "Beverages", "Condiments", "Vegetables", "Dairy Products", "Seafood" }; List<Product> products = GetProductList(); Dictionary<string, List<string>> q = categories.GroupJoin(products, c => c, p => p.Category, (c, p) => Tuple.Create(c, p.Select(p1=>p1.ProductName).ToList())) .ToDictionary(t => t.Item1, t => t.Item2); return q; }
Ref: 
public Map<String, List<String>> productGroupJoinCategoriesName() { String[] categories = {"Beverages", "Condiments", "Vegetables", "Dairy Products", "Seafood"}; List<Product> products = getProductList(); Map<String, List<String>> q = Arrays.stream(categories).map(c -> Pair.with(c, products.stream() .filter(p -> p.getCategory().equals(c)).map(p1 -> p1.getProductName()).toList())) .collect(toMap(t -> t.getValue0(), t -> t.getValue1())); return q; }
Hyp: 
public Map<String, List<String>> productGroupJoinCategoriesName() { String[] categories = {"Beverages", "Condiments", "Vegetables", "Dairy Products", "Seafood"}; List<Product> products = getProductList(); Map<String, List<String>> q = Arrays.stream(categories).map(c -> Pair.with(c, products.stream() .filter(p -> p.getCategory().equals(c)) .collect(Collectors.toList()))).collect(toMap(t->t.getValue0(),t->t.getValue1())); return q; }

BLEU: 72.0
Edit Sim: 33


Src: 
public bool IntSquareAllMatch() { int[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 }; bool allMatch = numbers.Select(i => i * i).All(n => n > 3); return allMatch; }
Ref: 
public boolean intSquareAllMatch() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; boolean allMatch = Arrays.stream(numbers).map(i -> i * i).allMatch(n -> n > 3); return allMatch; }
Hyp: 
public boolean intSquareAllMatch() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; boolean allMatch = Arrays.stream(numbers).map(i -> i * i).allMatch(n -> n > 3); return allMatch; }

BLEU: 100.0
Edit Sim: 0


Src: 
public Product[] ProductsConvertToDescendingArrayAndPrint() { List<Product> products = GetProductList(); Product[] productsArray = products.OrderByDescending(p => p.UnitPrice).ToArray(); for (int i = 0; i < productsArray.Length; i++) Console.WriteLine(productsArray[i]); return productsArray; }
Ref: 
public Product[] productsConvertToDescendingArrayAndPrint() { List<Product> products = getProductList(); Product[] productsArray = (Product[]) products.stream().sorted(Comparator.comparing( p -> p.getUnitPrice(), Comparator.reverseOrder())).toArray(); for (int i = 0; i < productsArray.length; i++) System.out.println(productsArray[i]); return productsArray; }
Hyp: 
public Product[] productsConvertToDescendingArrayAndPrint() { List<Product> products = getProductList(); Product[] productsArray = products.stream().sorted(Comparator.comparing( p -> p.getUnitPrice(), Comparator.reverseOrder())).toArray(); for (int i = 0; i < productsArray.length; i++) System.out.println(productsArray[i]); return productsArray; }

BLEU: 91.28
Edit Sim: 12


Src: 
public List<Tuple<string, DateTime>> CustomerOrdersEachNestedSkipWhile() { List<Customer> customers = GetCustomerList(); List<Tuple<string, DateTime>> afterOrdersEachWhile = customers .SelectMany(c => c.Orders.SkipWhile(o => o.OrderDate > new DateTime( 2000, 1, 1)), (c, o) => Tuple.Create( c.CustomerId, o.OrderDate)).ToList(); return afterOrdersEachWhile; }
Ref: 
public List<Pair<String, LocalDate>> customerOrdersEachNestedSkipWhile() { List<Customer> customers = getCustomerList(); List<Pair<String, LocalDate>> after3EachOrders = customers.stream().flatMap(c -> c.getOrders().stream() .dropWhile(o -> o.getOrderDate().isAfter(LocalDate.of(2000, 1, 1))) .map(o -> Pair.with(c.getCustomerId(), o.getOrderDate()))).toList(); return after3EachOrders; }
Hyp: 
public List<Pair<String, LocalDate>> customerOrdersEachNestedSkipWhile() { List<Customer> customers = getCustomerList(); List<Pair<String, LocalDate>> after3EachWiseOrders = customers.stream().flatMap(c -> c.getOrders().stream().dropWhile(o -> o.getOrderDate() .isAfter(LocalDate.of(2000, 1, 1))) .map(o -> Pair.with(c.getCustomerId(), o.getOrderDate()))).toList(); return after3EachWiseOrders; }

BLEU: 63.87
Edit Sim: 10


Src: 
public List<bool> WaCustomerOrdersEachNestedAllMatch() { List<Customer> customers = GetCustomerList(); List<bool> allMatch = customers.Where(c=>c.Region=="WA").Select(c => c.Orders.All(o => o.OrderDate > new DateTime(2000, 1, 1))).ToList(); return allMatch; }
Ref: 
public List<Boolean> waCustomerOrdersEachNestedAllMatch() { List<Customer> customers = getCustomerList(); List<Boolean> allMatch = customers.stream().filter(c -> c.getRegion() == "WA").map(c -> c.getOrders().stream().allMatch(o -> o.getOrderDate().isAfter(LocalDate.of(2000, 1, 1)))).toList(); return allMatch; }
Hyp: 
public List<Boolean> waCustomerOrdersEachNestedAllMatch() { List<Customer> customers = getCustomerList(); List<Boolean> allMatch = customers.stream().filter(c -> c.getRegion() == "WA").map(c -> c.getOrders().stream().allMatch(o -> o.getOrderDate().isAfter(LocalDate.of(2000, 1, 1))).toList(); return allMatch; }

BLEU: 89.42
Edit Sim: 1


Src: 
public Dictionary<string, List<Order>> CustomerEachRegionOrdersTotalMaxCustomerDict() { List<Customer> customers = GetCustomerList(); Dictionary<string, List<Order>> customerOrdersTotalMax = customers.GroupBy(c => c.Region) .ToDictionary(g => g.Key, g=>g.SelectMany(c => c.Orders).Where( o => o.Total == g.SelectMany(c => c.Orders).Max(o => o.Total)).ToList()); return customerOrdersTotalMax; }
Ref: 
public Map<String, List<Order>> customerEachRegionOrdersTotalMaxCustomerDict() { List<Customer> customers = getCustomerList(); Map<String, List<Order>> customerOrdersTotalMax = customers.stream().collect(groupingBy(c -> c.getCountry())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream() .flatMap(c -> c.getOrders().stream()).collect(groupingBy(o -> o.getTotal())) .entrySet().stream().max(Map.Entry.comparingByKey()).get().getValue())); return customerOrdersTotalMax; }
Hyp: 
public Map<String, List<Order>> customerEachRegionOrdersTotalMaxCustomerDict() { List<Customer> customers = getCustomerList(); Map<String, List<Order>> customerOrdersTotalMax = customers.stream().collect(groupingBy(c -> c.getCountry())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream() .flatMap(c -> c.getOrders().stream()).collect(groupingBy(o -> o.getTotal())) .entrySet().stream().max(Map.Entry.comparingByKey()).get().getValue())); return customerOrdersTotalMax; }

BLEU: 100.0
Edit Sim: 0


Src: 
public double DoubleSum() { double[] numbers = { 3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0 }; double numbersSum = numbers.Sum(); return numbersSum; }
Ref: 
public double doubleSum() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; double numbersSum = Arrays.stream(numbers).sum(); return numbersSum; }
Hyp: 
public double doubleSum() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; double numbersSum = Arrays.stream(numbers).sum(); return numbersSum; }

BLEU: 100.0
Edit Sim: 0


Src: 
public string[] StringProjectionZipAdd() { string[] wordsA = { "Alpha", "Beta", "Gamma" }; string[] wordsB = { "red", "green", "blue" }; string[] results = wordsA.Select(w => w[0].ToString()) .Zip(wordsB.Select(w => w[0]), (a, b) => a + b).ToArray(); return results; }
Ref: 
public String[] stringProjectionZipAdd() { String[] wordsA = {"Alpha", "Beta", "Gamma"}; String[] wordsB = {"red", "green", "blue"}; int length = wordsA.length; String[] results = (String[]) IntStream.range(0, length) .mapToObj(i -> String.valueOf(wordsA[i].charAt(0)) + wordsB[i].charAt(0)).toArray(); return results; }
Hyp: 
public String[] stringProjectionZipAdd() { String[] wordsA = {"Alpha", "Beta", "Gamma"}; String[] wordsB = {"red", "green", "blue"}; int length = wordsA.length; String[] results = (String[]) IntStream.range(0, length).mapToObj(i -> wordsA[i] + wordsB[i]).toArray(); return results; }

BLEU: 78.67
Edit Sim: 37


Src: 
public Dictionary<string, List<Product>> ProductGroupSkipWhile() { List<Product> products = GetProductList(); Dictionary<string, List<Product>> afterGroupsWhile = products.GroupBy(p => p.Category) .SkipWhile(g => g.Key.Length > 6).ToDictionary(g => g.Key, g => g.ToList()); return afterGroupsWhile; }
Ref: 
public Map<String, List<Product>> productGroupSkipWhile() { List<Product> products = getProductList(); Map<String, List<Product>> after3Groups = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().dropWhile(g -> g.getKey().length() > 6).collect(toMap(g -> g.getKey(), g -> g.getValue())); return after3Groups; }
Hyp: 
public Map<String, List<Product>> productGroupSkipWhile() { List<Product> products = getProductList(); Map<String, List<Product>> after3Groups = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().dropWhile(g -> g.getKey().length() > 6).collect(toMap(g -> g.getKey(), g -> g.getValue())); return after3Groups; }

BLEU: 100.0
Edit Sim: 0


Src: 
public List<Tuple<string, List<string>>> ProductGroupName() { List<Product> products = GetProductList(); List<Tuple<string, List<string>>> productNames = products.GroupBy(p => p.Category) .Select(g => Tuple.Create(g.Key, g.Select(p => p.ProductName).ToList())) .ToList(); return productNames; }
Ref: 
public List<Pair<String, List<String>>> productGroupName() { List<Product> products = getProductList(); List<Pair<String, List<String>>> productNames = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().map(p -> p.getProductName()).toList())).toList(); return productNames; }
Hyp: 
public List<Pair<String, List<String>>> productGroupName() { List<Product> products = getProductList(); List<Pair<String, List<String>>> productNames = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().map(p -> p.getProductName()).toList())).toList(); return productNames; }

BLEU: 100.0
Edit Sim: 0


Src: 
public List<Tuple<int, string>> CustomerCrossGroupJoinRegionsWithCodeName() { List<Tuple<string, int>> regions = new List<Tuple<string, int>>{ Tuple.Create("BC", 101), Tuple.Create("BC", 105), Tuple.Create("OR", 121), Tuple.Create("LA", 143) }; List<Customer> customers = GetCustomerList(); List<Tuple<int, string>> q = regions.GroupJoin(customers, r => r.Item1, c => c.Region, (r, c) => Tuple.Create(r.Item2, c)).SelectMany(t=> t.Item2.Select(c=>c.CompanyName),(t, c) => Tuple.Create(t.Item1, c)).ToList(); return q; }
Ref: 
public List<Pair<Integer, String>> customerCrossGroupJoinRegionsWithCodeName() { List<Pair<String, Integer>> regions = Arrays.asList( Pair.with("BC", 101), Pair.with("BC", 105), Pair.with("OR", 121), Pair.with("LA", 143) ); List<Customer> customers = getCustomerList(); List<Pair<Integer, String>> q = regions.stream().map( r -> Pair.with(r.getValue1(), customers.stream().filter(c -> c.getRegion().equals(r)) .collect(Collectors.toList()))).flatMap(t -> t.getValue1().stream() .map(c1 -> Pair.with(t.getValue0(), c1.getCompanyName()))).toList(); return q; }
Hyp: 
public List<Pair<Integer, String>> customerCrossGroupJoinRegionsWithCodeName() { List<Pair<String, Integer>> regions = Arrays.asList( Pair.with("BC", 101), Pair.with("BC", 105), Pair.with("OR", 121), Pair.with("LA", 143) ); List<Customer> customers = getCustomerList(); List<Pair<Integer, String>> q = regions.stream().map( r -> Pair.with(r.getValue1(), customers.stream().filter(c -> c.getRegion().equals(r)) .collect(Collectors.toList()))).flatMap(t -> t.getValue1().stream() .map(p1 -> Pair.with(t.getValue0(), p1!=null?p1.getCompanyName():"LA", 143)).toList(); return q; }

BLEU: 86.84
Edit Sim: 21


Src: 
public Dictionary<string, List<Product>> ProductsConvertGroupingToDictionary() { List<Product> products = GetProductList(); Dictionary<string, List<Product>> catagory = products.GroupBy(p => p.Category).ToDictionary( g => g.Key, g => g.ToList()); return catagory; }
Ref: 
public Map<String, List<Product>> productsConvertGroupingToDictionary() { List<Product> products = getProductList(); Map<String, List<Product>> catagory = products.stream().collect(groupingBy( p ->p.getCategory())); return catagory; }
Hyp: 
public Map<String, List<Product>> productsConvertGroupingToDictionary() { List<Product> products = getProductList(); Map<String, List<Product>> catagory = products.stream().collect(groupingBy(p -> p.getCategory())); return catagory; }

BLEU: 74.83
Edit Sim: 2


Src: 
public List<Product> RepeatedProductsWithBaseAndCount(Product product,int count) { List<Product> products = Enumerable.Repeat(product, count).ToList(); return products; }
Ref: 
public List<Product> repeatedProductsWithBaseAndCount(Product product,int count) { List<Product> products = Collections.nCopies(count, product); return products; }
Hyp: 
public List<Product> repeatedProductsWithBaseAndCount(Product product,int count) { List<Product> products = Collections.nCopies(count, product); return products; }

BLEU: 100.0
Edit Sim: 0


Src: 
public List<int> IntsConvertToList() { int[] ints = { 2, 3, 1, 5, 4 }; List<int> intsList = ints.OrderBy(d => d).ToList(); return intsList; }
Ref: 
public List<Integer> intsConvertToList() { int[] ints = {2, 3, 1, 5, 4}; List<Integer> intsList = Arrays.stream(ints).boxed().sorted().toList(); return intsList; }
Hyp: 
public List<Integer> intsConvertToList() { int[] ints = {2, 3, 1, 5, 4}; List<Integer> intsList = Arrays.stream(ints).boxed(). sorted().toList(); return intsList; }

BLEU: 81.37
Edit Sim: 1


Src: 
public List<Tuple<char, List<string>>> StringGroupByFirstCharOrderbyCustom() { string[] words = { "aPPLE", "AbAcUs", "bRaNcH", "BlUeBeRrY", "ClOvEr", "cHeRry" }; List<Tuple<char, List<string>>> wordsGroups = words.GroupBy(w => char.ToLower(w[0])) .Select(g => Tuple.Create(g.Key, g.OrderBy(w=>w,new CaseInsensitiveComparer()).ToList())).ToList(); return wordsGroups; }
Ref: 
public List<Pair<Character, List<String>>> stringGroupByFirstCharOrderbyCustom() { String[] words = {"aPPLE", "AbAcUs", "bRaNcH", "BlUeBeRrY", "ClOvEr", "cHeRry"}; List<Pair<Character, List<String>>> wordsGroups = Arrays.stream(words).collect(groupingBy(w -> Character.toLowerCase(w.charAt(0)))) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().sorted(new CaseInsensitiveComparer()).toList())).toList(); return wordsGroups; }
Hyp: 
public List<Pair<Character, List<String>>> stringGroupByFirstCharOrderbyCustom() { String[] words = {"aPPLE", "AbAcUs", "bRaNcH", "BlUeBeRrY", "ClOvEr", "cHeRry"}; List<Pair<Character, List<String>>> wordsGroups = Arrays.stream(words).collect(groupingBy(w -> Character.toLowerCase(w.charAt(0)))) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().sorted(new CaseInsensitiveComparer().reversed()).toList())).toList(); return wordsGroups; }

BLEU: 90.96
Edit Sim: 11


Src: 
public List<Tuple<string, Customer>> CustomerCrossJoinRegions() { string[] regions = { "BC", "SP", "OR", "LA" }; List<Customer> customers = GetCustomerList(); List<Tuple<string, Customer>> q = regions.Join(customers, r => r, c => c.Region, (r, c) => Tuple.Create(r, c)).ToList(); return q; }
Ref: 
public List<Pair<String, Customer>> customerCrossJoinRegions() { String[] regions = {"BC", "SP", "OR", "LA"}; List<Customer> customers = getCustomerList(); List<Pair<String, Customer>> q = Arrays.stream(regions).flatMap( r -> customers.stream().filter(c -> c.getRegion().equals(r)).map( c -> Pair.with(r, c))).toList(); return q; }
Hyp: 
public List<Pair<String, Customer>> customerCrossJoinRegions() { String[] regions = {"BC", "SP", "OR", "LA"}; List<Customer> customers = getCustomerList(); List<Pair<String, Customer>> q = Arrays.stream(regions).map(r -> Pair.with(r, customers.stream().filter(c -> c.getRegion().equals(r)).map(c -> Pair.with(r, c))).toList(); return q; }

BLEU: 76.28
Edit Sim: 20


Src: 
public double BigNumbersAggregateMultiply() { double[] numbers = { 1.7, 2.3, 1.9, 4.1, 2.9 }; double product = numbers.Where(n => n > 2).Aggregate((a, b) => a * b); return product; }
Ref: 
public double bigNumbersAggregateMultiply() { double[] numbers = {1.7, 2.3, 1.9, 4.1, 2.9}; double product = Arrays.stream(numbers).filter(n -> n > 2).reduce((a, b) -> a * b).getAsDouble(); return product; }
Hyp: 
public double bigNumbersAggregateMultiply() { double[] numbers = {1.7, 2.3, 1.9, 4.1, 2.9}; double product = Arrays.stream(numbers).filter(n -> n >= 2).reduce((a, b) -> a * b).getAsDouble(); return product; }

BLEU: 90.62
Edit Sim: 1


Src: 
public string StringElementAtStartWithO() { string[] strings = { "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine" }; string startWithO = strings.Where(s => s[0] == 'o').ElementAt(0); return startWithO; }
Ref: 
public String stringElementAtStartWithO() { String[] strings = { "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine" }; String startWithO = Arrays.stream(strings).filter(s ->s.charAt(0)=='o').skip(0).findFirst().get(); return startWithO; }
Hyp: 
public String stringElementAtStartWithO() { String[] strings = {"zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"}; String startWithO = Arrays.stream(strings).filter(s -> s.charAt(0) == 'o').skip(1).findFirst().get(); return startWithO; }

BLEU: 59.64
Edit Sim: 6


Src: 
public int AggregateWithdrawMoney() { int[] attemptedWithdrawals = { 100, 20, 10, 40, 50, 10, 70, 30 }; int endBalance = attemptedWithdrawals.Aggregate((balance, nextWithdrawal) => nextWithdrawal <= balance ? balance - nextWithdrawal : balance); return 0; }
Ref: 
public int aggregateWithdrawMoney() { int[] attemptedWithdrawals = {100, 20, 10, 40, 50, 10, 70, 30}; int endBalance = Arrays.stream(attemptedWithdrawals).reduce((balance, nextWithdrawal) -> nextWithdrawal <= balance ? balance - nextWithdrawal : balance).getAsInt(); return 0; }
Hyp: 
public int aggregateWithdrawMoney() { int[] attemptedWithdrawals = {100, 20, 10, 40, 50, 10, 70, 30}; int endBalance = Arrays.stream(attemptedWithdrawals).filter(i -> attemptedWithdrawals[i] < balance) .reduce((balance, nextWithdrawal) -> balance - nextWithdrawal).getAsInt(); return endBalance; }

BLEU: 59.13
Edit Sim: 77


Src: 
public int[] IntZipSub() { int[] numbersA = { 0, 2, 4, 5, 6, 8, 9 }; int[] numbersB = { 1, 3, 5, 7, 8, 10, 11 }; int[] subNumbers = numbersA.Zip(numbersB, (a, b) => a - b).ToArray(); return subNumbers; }
Ref: 
public int[] intZipSub() { int[] numbersA = {0, 2, 4, 5, 6, 8, 9}; int[] numbersB = {1, 3, 5, 7, 8, 10, 11}; int length = numbersA.length; int[] subNumbers = IntStream.range(0, length).map(i -> numbersA[i] - numbersB[i]).toArray(); return subNumbers; }
Hyp: 
public int[] intZipSub() { int[] numbersA = {0, 2, 4, 5, 6, 8, 9}; int[] numbersB = {1, 3, 5, 7, 8, 10, 11}; int[] subNumbers = IntStream.range(0, numbersA.length).map(i -> numbersA[i] - numbersB[i]).toArray(); return subNumbers; }

BLEU: 78.99
Edit Sim: 39


Src: 
public List<int> IntSkipWhileIndexedCount(int n) { int[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 }; List<int> afterNumbers = numbers.SkipWhile((n, i) => n > i).ToList(); return afterNumbers; }
Ref: 
public List<Integer> intSkipWhileIndexedCount(int n) { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; List<Integer> afterNumbers = IntStream.range(0, numbers.length) .dropWhile(i -> n > i).map(i -> numbers[i]).boxed().toList(); return afterNumbers; }
Hyp: 
public List<Integer> intSkipWhileIndexedCount(int n) { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; List<Integer> afterNumbers = IntStream.range(0, numbers.length) .dropWhile(i -> n > i).map(i -> numbers[i]).boxed().toList(); return afterNumbers; }

BLEU: 100.0
Edit Sim: 0


Src: 
public List<string> LongStringTakeWhile() { string[] words = { "cherry", "apple", "blueberry", "banana", "abacus" }; List<string> firstWordsWhile = words.Where(w => w.Length > 5).TakeWhile(w => w[0] > 'b').ToList(); return firstWordsWhile; }
Ref: 
public List<String> longStringTakeWhile() { String[] words = {"cherry", "apple", "blueberry", "banana", "abacus"}; List<String> after3Words = Arrays.stream(words).filter(w -> w.length() > 5).takeWhile(w -> w.charAt(0) > 'b').toList(); return after3Words; }
Hyp: 
public List<String> longStringTakeWhile() { String[] words = {"cherry", "apple", "blueberry", "banana", "abacus"}; List<String> afterNNumbers = Arrays.stream(words).filter(w -> w.length() > 5).takeWhile(w -> w.charAt(0) > 'b').toList(); return afterNNumbers; }

BLEU: 83.48
Edit Sim: 14


Src: 
public string StringElementAtStartWith(char c) { string[] strings = { "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine" }; string startWithChar = strings.Where(s => s[0] == c).ElementAt(2); return startWithChar; }
Ref: 
public String stringElementAtStartWith(char c) { String[] strings = { "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine" }; String startWithO = Arrays.stream(strings).filter(s ->s.charAt(0)==c).skip(2).findFirst().get(); return startWithO; }
Hyp: 
public String stringElementAtStartWith(char c) { String[] strings = {"zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"}; String startWithChar = Arrays.stream(strings).filter(s -> s.charAt(0) == c).skip(2).findFirst().get(); return startWithChar; }

BLEU: 52.6
Edit Sim: 13


Src: 
public Dictionary<string, List<Customer>> CustomerEachRegionOrdersMaxCustomerDict() { List<Customer> customers = GetCustomerList(); Dictionary<string, List<Customer>> customerOrdersMax = customers.GroupBy(c => c.Region) .ToDictionary(g => g.Key, g => g.Where(c => c.Orders.Count ==g.Max(c => c.Orders.Count)).ToList()); return customerOrdersMax; }
Ref: 
public Map<String, List<Customer>> customerEachRegionOrdersMaxCustomerDict() { List<Customer> customers = getCustomerList(); Map<String, List<Customer>> customerOrdersMax = customers.stream().collect(groupingBy(c -> c.getRegion())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream(). collect(groupingBy(c -> c.getOrders().size())).entrySet() .stream().max(Map.Entry.comparingByKey()).get().getValue())); return customerOrdersMax; }
Hyp: 
public Map<String, List<Customer>> customerEachRegionOrdersMaxCustomerDict() { List<Customer> customers = getCustomerList(); Map<String, List<Customer>> customerOrdersMax = customers.stream().collect(groupingBy(c -> c.getCountry())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream(). collect(groupingBy(c -> c.getOrders().size())).entrySet() .stream().max(Map.Entry.comparingByKey()).get().getValue())); return customerOrdersMax; }

BLEU: 90.96
Edit Sim: 7


Src: 
public bool StringLengthAnyMatch() { string[] words = { "cherry", "apple", "blueberry", "banana", "abacus" }; bool anyMatch = words.Select(w => w.Length).Any(n => n > 5); return anyMatch; }
Ref: 
public boolean stringLengthAnyMatch() { String[] words = {"cherry", "apple", "blueberry", "banana", "abacus"}; boolean anyMatch = Arrays.stream(words).map(w -> w.length()).anyMatch(n -> n > 5); return anyMatch; }
Hyp: 
public boolean stringLengthAnyMatch() { String[] words = {"cherry", "apple", "blueberry", "banana", "abacus"}; boolean anyMatch = Arrays.stream(words).map(w -> w.length()).anyMatch(n -> n > 5); return anyMatch; }

BLEU: 100.0
Edit Sim: 0


Src: 
public List<string> StringOrderbyDescendingCustom() { string[] words = { "aPPLE", "AbAcUs", "bRaNcH", "BlUeBeRrY", "ClOvEr", "cHeRry" }; List<string> sortedWords = words.OrderByDescending(w => w, new CaseInsensitiveComparer()).ToList(); return sortedWords; }
Ref: 
public List<String> stringOrderbyDescendingCustom() { String[] words = {"aPPLE", "AbAcUs", "bRaNcH", "BlUeBeRrY", "ClOvEr", "cHeRry"}; List<String> sortedWords = Arrays.stream(words).sorted(new CaseInsensitiveComparer().reversed()).toList(); return sortedWords; }
Hyp: 
public List<String> stringOrderbyDescendingCustom() { String[] words = {"aPPLE", "AbAcUs", "bRaNcH", "BlUeBeRrY", "ClOvEr", "cHeRry"}; List<String> sortedWords = Arrays.stream(words).sorted(new CaseInsensitiveComparer().reversed()).toList(); return sortedWords; }

BLEU: 100.0
Edit Sim: 0


Src: 
public string StringFirstOrDefaultLong() { string[] strings = { "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine" }; string startsWithO = strings.FirstOrDefault(s => s.Length > 4,"empty"); return startsWithO; }
Ref: 
public String stringFirstOrDefaultLong() { String[] strings = {"zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"}; String startsWithO = Arrays.stream(strings).filter(s -> s.length() > 4).findFirst().orElse("empty"); return startsWithO; }
Hyp: 
public String stringFirstOrDefaultLong() { String[] strings = {"zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"}; String startsWithO = Arrays.stream(strings).filter(s -> s.length() > 4).findFirst().orElse(null); return startsWithO; }

BLEU: 90.62
Edit Sim: 7


Src: 
public bool ProjectionEqualInts() { int[] numbersA = { 0, 2, 4, 5, 9 }; int[] numbersB = { 1, 3, 5, 6, 10 }; bool equal = numbersA.Select(n => n + 1).SequenceEqual(numbersB); return equal; }
Ref: 
public boolean projectionEqualInts() { int[] numbersA = {0, 2, 4, 5, 9}; int[] numbersB = {1, 3, 5, 6, 10}; boolean equal = Arrays.equals(Arrays.stream(numbersA).map(n -> n + 1). toArray(), numbersB); return equal; }
Hyp: 
public boolean projectionEqualInts() { int[] numbersA = {0, 2, 4, 5, 9}; int[] numbersB = {1, 3, 5, 6, 10}; boolean equal = Arrays.equals(numbersA, numbersB); return equal; }

BLEU: 75.8
Edit Sim: 42


Src: 
public Dictionary<bool, List<string>> StringGroupByLengthDict() { string[] words = { "blueberry", "chimpanzee", "abacus", "banana", "apple", "cheese" }; Dictionary<bool, List<string>> wordsGroups = words.GroupBy(w => w.Length > 8) .ToDictionary(g => g.Key, g => g.ToList()); return wordsGroups; }
Ref: 
public Map<Boolean, List<String>> stringGroupByLengthDict() { String[] words = {"blueberry", "chimpanzee", "abacus", "banana", "apple", "cheese"}; Map<Boolean, List<String>> wordsGroups = Arrays.stream(words).collect(groupingBy(w -> w.length() > 8)); return wordsGroups; }
Hyp: 
public Map<Boolean, List<String>> stringGroupByLengthDict() { String[] words = {"blueberry", "chimpanzee", "abacus", "banana", "apple", "cheese"}; Map<Boolean, List<String>> wordsGroups = Arrays.stream(words).collect(groupingBy(w -> w.length() > 8)) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue())); return wordsGroups; }

BLEU: 72.71
Edit Sim: 72


Src: 
public List<double> DoubleOrderby() { double[] numbers = { 3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0 }; List<double> sortedNumbers = numbers.OrderBy(n => n).ToList(); return sortedNumbers; }
Ref: 
public List<Double> doubleOrderby() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; List<Double> sortedNumbers = Arrays.stream(numbers).boxed().sorted().toList(); return sortedNumbers; }
Hyp: 
public List<Double> doubleOrderby() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; List<Double> sortedNumbers = Arrays.stream(numbers).boxed().sorted( Comparator.comparing((Double n) -> n).toList(); return sortedNumbers; }

BLEU: 75.99
Edit Sim: 37


Src: 
public string[] SelectByStringAndLengthConcat() { string[] words = { "aPPLE", "BlUeBeRrY", "cHeRry" }; string[] upperLowerWords = words.Select(w => w + w.Length).ToArray(); return upperLowerWords; }
Ref: 
public String[] selectByStringAndLengthConcat() { String[] words = {"aPPLE", "BlUeBeRrY", "cHeRry"}; String[] upperLowerWords = (String[]) Arrays.stream(words).map(w -> w + w.length()).toArray(); return upperLowerWords; }
Hyp: 
public String[] selectByStringAndLengthConcat() { String[] words = {"aPPLE", "BlUeBeRrY", "cHeRry"}; String[] upperLowerWords = Arrays.stream(words).map(w -> w + w.length()).toArray(); return upperLowerWords; }

BLEU: 87.89
Edit Sim: 11


Src: 
public List<Tuple<string, int>> CustomerEachRegionOrdersMin() { List<Customer> customers = GetCustomerList(); List<Tuple<string, int>> ordersMin = customers.GroupBy(c => c.Region) .Select(g => Tuple.Create(g.Key, g.Min(c => c.Orders.Count))).ToList(); return ordersMin; }
Ref: 
public List<Pair<String, Integer>> customerEachRegionOrdersMin() { List<Customer> customers = getCustomerList(); List<Pair<String, Integer>> ordersMin = customers.stream().collect(groupingBy(c -> c.getRegion())) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().mapToInt(c -> c.getOrders().size()).min().getAsInt())).toList(); return ordersMin; }
Hyp: 
public List<Pair<String, Integer>> customerEachRegionOrdersMin() { List<Customer> customers = getCustomerList(); List<Pair<String, Integer>> ordersMin = customers.stream().collect(groupingBy(c -> c.getRegion())) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().mapToInt(c -> c.getOrders().size()).min().getAsInt())).toList(); return ordersMin; }

BLEU: 100.0
Edit Sim: 0


Src: 
public double ProjectedDoubleFirst() { double[] numbers = { 3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0 }; double firstNum = numbers.Select(i => Math.Log(i)).First(n => n > 3); return firstNum; }
Ref: 
public double projectedDoubleFirst() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; double firstNum = Arrays.stream(numbers).map(i -> Math.log(i)).filter(n -> n > 3).findFirst().getAsDouble(); return firstNum; }
Hyp: 
public double projectedDoubleFirst() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; double firstNum = Arrays.stream(numbers).map(i -> Math.log(i)).filter(n -> n > 3).findFirst().orElse(0); return firstNum; }

BLEU: 91.28
Edit Sim: 10


Src: 
public double ExpensiveProductUnitPriceMin() { List<Product> products = GetProductList(); double minUnitPrice = products.Where(p => p.UnitPrice > 100).Min(p => p.UnitPrice); return minUnitPrice; }
Ref: 
public double expensiveProductUnitPriceMin() { List<Product> products = getProductList(); double minUnitPrice = products.stream().filter(p -> p.getUnitPrice() > 100) .mapToDouble(p -> p.getUnitPrice()).min().getAsDouble(); return minUnitPrice; }
Hyp: 
public double expensiveProductUnitPriceMin() { List<Product> products = getProductList(); double minUnitPrice = products.stream().filter(p -> p.getUnitPrice() > 100) .mapToInt(p -> p.getUnitPrice()).min().getAsDouble(); return minUnitPrice; }

BLEU: 87.87
Edit Sim: 6


Src: 
public List<string> StringOrderbyCustomThenbyLengthDescendingCustom() { string[] words = { "aPPLE", "AbAcUs", "bRaNcH", "BlUeBeRrY", "ClOvEr", "cHeRry" }; List<string> sortedWords = words.OrderBy(w => w,new CaseInsensitiveComparer()) .ThenByDescending(w=>w.Length,new CustomNumberComparer()).ToList(); return sortedWords; }
Ref: 
public List<String> stringOrderbyCustomThenbyLengthDescendingCustom() { String[] words = {"aPPLE", "AbAcUs", "bRaNcH", "BlUeBeRrY", "ClOvEr", "cHeRry"}; List<String> sortedWords = Arrays.stream(words).sorted(Comparator.comparing((String w) -> w,new CaseInsensitiveComparer()) .thenComparing(w -> w.length(),new CustomNumberComparer().reversed())).toList(); return sortedWords; }
Hyp: 
public List<String> stringOrderbyCustomThenbyLengthDescendingCustom() { String[] words = {"aPPLE", "AbAcUs", "bRaNcH", "BlUeBeRrY", "ClOvEr", "cHeRry"}; List<String> sortedWords = Arrays.stream(words) .sorted(Comparator.comparing((String w) -> w,new CaseInsensitiveComparer()) .thenComparing(w -> w.length(),new CustomNumberComparer())).toList(); return sortedWords; }

BLEU: 78.12
Edit Sim: 12


Src: 
public int[] ProjectionIntUnion() { int[] numbersA = { 0, 2, 4, 5, 6, 8, 9 }; int[] numbersB = { 1, 3, 5, 7, 8 }; var first = numbersA.Select(n => n+1); var second = numbersB.Select(n => n-1); int[] numbers = first.Union(second).ToArray(); return numbers; }
Ref: 
public int[] projectionIntUnion() { int[] numbersA = {0, 2, 4, 5, 6, 8, 9}; int[] numbersB = {1, 3, 5, 7, 8}; var first = Arrays.stream(numbersA).map(n -> n + 1); var second = Arrays.stream(numbersB).map(n -> n - 1); int[] uniqueNumbers = IntStream.concat(first, second).distinct().toArray(); return uniqueNumbers; }
Hyp: 
public int[] projectionIntUnion() { int[] numbersA = {0, 2, 4, 5, 9}; int[] numbersB = {0, 2, 4, 5, 9}; int[] numbers = {0, 2, 4, 5, 9}; AtomicInteger[] numbers = {0, 2, 4, 5, 9}; var first = Arrays.stream(numbersA).map(n -> n+1); var second = Arrays.stream(numbersB).map(n -> n - 1).toArray(); return numbers; }

BLEU: 42.75
Edit Sim: 136


Src: 
public string[] StringExcept() { string[] wordsA = {"Alice", "Bob", "Foo", "Bar"}; string[] wordsB = {"Cafe", "Bar","Restaurant" }; string[] differentWords = wordsA.Except(wordsB).ToArray(); return differentWords; }
Ref: 
public String[] stringExcept() { String[] wordsA = {"Alice", "Bob", "Foo", "Bar"}; String[] wordsB = {"Cafe", "Bar", "Restaurant"}; String[] differemtWords = (String[]) Arrays.stream(wordsA).distinct().filter(a -> Arrays.stream(wordsB).allMatch(b -> !b.equals(a))).toArray(); return differemtWords; }
Hyp: 
public String[] stringExcept() { String[] wordsA = {"Alice", "Bob", "Foo", "Bar"}; String[] wordsB = {"Cafe", "Bar","Restaurant"}; int length = wordsA.length; String[] differemtWords = Arrays.stream(wordsA).Except(wordsB).toArray(); return differemtWords; }

BLEU: 60.23
Edit Sim: 87


Src: 
public Dictionary<char, List<string>> StringGroupByFirstCharDictOrderbyCustom() { string[] words = { "aPPLE", "AbAcUs", "bRaNcH", "BlUeBeRrY", "ClOvEr", "cHeRry" }; Dictionary<char, List<string>> wordsGroups = words.GroupBy(w => char.ToLower(w[0])) .ToDictionary(g => g.Key, g => g.OrderBy(w=>w,new CaseInsensitiveComparer()).ToList()); return wordsGroups; }
Ref: 
public Map<Character, List<String>> stringGroupByFirstCharDictOrderbyCustom() { String[] words = {"aPPLE", "AbAcUs", "bRaNcH", "BlUeBeRrY", "ClOvEr", "cHeRry"}; Map<Character, List<String>> wordsGroups = Arrays.stream(words).collect(groupingBy(w -> Character.toLowerCase(w.charAt(0)))) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().sorted(new CaseInsensitiveComparer()).toList())); return wordsGroups; }
Hyp: 
public Map<Character, List<String>> stringGroupByFirstCharDictOrderbyCustom() { String[] words = {"aPPLE", "AbAcUs", "bRaNcH", "BlUeBeRrY", "ClOvEr", "cHeRry"}; Map<Character, List<String>> wordsGroups = Arrays.stream(words).collect(groupingBy(w -> Character.toLowerCase(w.charAt(0))) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().sorted(new CaseInsensitiveComparer().reversed()).toList())); return wordsGroups; }

BLEU: 82.93
Edit Sim: 12


Src: 
public Dictionary<string, int> ExpensiveProductEachCategoryStockDict() { List<Product> products = GetProductList(); Dictionary<string, int> categories = products.GroupBy(p => p.Category) .ToDictionary(g => g.Key, g => g.Where(p => p.UnitPrice > 100).Max(p => p.UnitsInStock)); return categories; }
Ref: 
public Map<String, Integer> expensiveProductEachCategoryStockDict() { List<Product> products = getProductList(); Map<String, Integer> categories = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().filter( p -> p.getUnitPrice() > 100).mapToInt(p -> p.getUnitsInStock()).max().getAsInt())); return categories; }
Hyp: 
public Map<String, Integer> expensiveProductEachCategoryStockDict() { List<Product> products = getProductList(); Map<String, Integer> categories = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().filter( p -> p.getUnitPrice() > 100).mapToInt(p -> p.getUnitsInStock()).max().getAsInt())); return categories; }

BLEU: 100.0
Edit Sim: 0


Src: 
public Dictionary<string, List<Product>> ProductEachCategoryFirstUnitPriceProductsDict() { List<Product> products = GetProductList(); Dictionary<string, List<Product>> categories = products.GroupBy(p => p.Category) .ToDictionary(g => g.Key, g=> g.Where(p => p.UnitPrice == g.First().UnitPrice) .ToList()); return categories; }
Ref: 
public Map<String, List<Product>> productEachCategoryFirstUnitPriceProductsDict() { List<Product> products = getProductList(); Map<String, List<Product>> categories = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().filter(p -> p.getUnitPrice() == g.getValue().stream().findFirst().get().getUnitPrice()).toList())); return categories; }
Hyp: 
public Map<String, List<Product>> productEachCategoryFirstUnitPriceProductsDict() { List<Product> products = getProductList(); Map<String, List<Product>> categories = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().filter( p -> p.getUnitPrice() == g.getValue().stream().findFirst().getUnitPrice())) .entrySet().stream().collect(toList())); return categories; }

BLEU: 76.31
Edit Sim: 36


Src: 
public List<string> StringOrderbyLengthReverse() { string[] words = { "cherry", "apple", "blueberry" }; List<string> sortedWords = words.OrderBy(w => w.Length).Reverse().ToList(); return sortedWords; }
Ref: 
public List<String> stringOrderbyLengthReverse() { String[] words = { "cherry", "apple", "blueberry" }; List<String> sortedWords = Arrays.stream(words).sorted(Comparator.comparing(w->w.length())).collect( collectingAndThen(toList(),l->{Collections.reverse(l);return l;})); return sortedWords; }
Hyp: 
public List<String> stringOrderbyLengthReverse() { String[] words = { "cherry", "apple", "blueberry" }; List<String> sortedWords = Arrays.stream(words).sorted().collect( collectingAndThen(toList(),l->{Collections.reverse(l);return l;})); return sortedWords; }

BLEU: 87.25
Edit Sim: 35


Src: 
public int OddNumbersMaxTwice() { int[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 }; int maxNum = numbers.Where(n => n % 2 == 1).Max(n => n * 2); return maxNum; }
Ref: 
public int oddNumbersMaxTwice() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int maxNum = Arrays.stream(numbers).filter(n -> n % 2 == 0).map(n -> n * 2).max().getAsInt(); return maxNum; }
Hyp: 
public int oddNumbersMaxTwice() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int maxNum = Arrays.stream(numbers).filter(n -> n % 2 == 0).map(n -> n * 2).max().getAsInt(); return maxNum; }

BLEU: 100.0
Edit Sim: 0


Src: 
public List<Product> ProductOrderbyId() { List<Product> products = GetProductList(); List<Product> sortedProducts = products.OrderBy(p => p.ProductId).ToList(); return sortedProducts; }
Ref: 
public List<Product> productOrderbyId() { List<Product> products = getProductList(); List<Product> sortedProducts = products.stream().sorted(Comparator.comparing(p -> p.getProductId())).toList(); return sortedProducts; }
Hyp: 
public List<Product> productOrderbyId() { List<Product> products = getProductList(); List<Product> sortedProducts = products.stream().sorted(Comparator.comparing( p -> p.getProductId())).toList(); return sortedProducts; }

BLEU: 79.13
Edit Sim: 1


Src: 
public bool ExpensiveProductAllMatch() { List<Product> products = GetProductList(); bool allMatch = products.Where(p => p.UnitPrice > 100).All(p => p.UnitsInStock > 0); return allMatch; }
Ref: 
public boolean expensiveProductAllMatch() { List<Product> products = getProductList(); boolean allMatch = products.stream().filter(p -> p.getUnitPrice() > 100).allMatch(p -> p.getUnitsInStock() > 0); return allMatch; }
Hyp: 
public boolean expensiveProductAllMatch() { List<Product> products = getProductList(); boolean allMatch = products.stream().filter(p -> p.getUnitPrice() > 100).allMatch(p -> p.getUnitsInStock() > 0); return allMatch; }

BLEU: 100.0
Edit Sim: 0


Src: 
public List<Product> ExpensiveProductOrderbyId() { List<Product> products = GetProductList(); List<Product> sortedProducts = products.Where(p=>p.UnitPrice>100).OrderBy(p => p.ProductId).ToList(); return sortedProducts; }
Ref: 
public List<Product> expensiveProductOrderbyId() { List<Product> products = getProductList(); List<Product> sortedProducts = products.stream().filter(p -> p.getUnitPrice() > 100).sorted(Comparator.comparing(p -> p.getProductId())).toList(); return sortedProducts; }
Hyp: 
public List<Product> expensiveProductOrderbyId() { List<Product> products = getProductList(); List<Product> sortedProducts = products.stream().filter(p -> p.getUnitPrice() > 100).sorted(Comparator.comparing(p -> p.getProductId())).toList(); return sortedProducts; }

BLEU: 100.0
Edit Sim: 0


Src: 
public double ShortStringAverageLength() { string[] words = { "cherry", "apple", "blueberry" }; double averageLength = words.Where(w => w.Length < 7).Average(w => w.Length); return averageLength; }
Ref: 
public double shortStringAverageLength() { String[] words = {"cherry", "apple", "blueberry"}; double averageLength = Arrays.stream(words).filter(w -> w.length() < 7).mapToInt(w -> w.length()).average().getAsDouble(); return averageLength; }
Hyp: 
public double shortStringAverageLength() { String[] words = {"cherry", "apple", "blueberry"}; double averageLength = Arrays.stream(words).filter(w -> w.length() < 7).mapToInt(w -> w.length()).average().getAsDouble(); return averageLength; }

BLEU: 100.0
Edit Sim: 0


Src: 
public int OddNumbersMax() { int[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 }; int maxNum = numbers.Where(n => n % 2 == 1).Max(); return maxNum; }
Ref: 
public int oddNumbersMax() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int maxNum = Arrays.stream(numbers).filter(n -> n % 2 == 0).max().getAsInt(); return maxNum; }
Hyp: 
public int oddNumbersMax() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int maxNum = Arrays.stream(numbers).filter(n -> n % 2 == 0).max().getAsInt(); return maxNum; }

BLEU: 100.0
Edit Sim: 0


Src: 
public List<double> ExpensiveProductUnitPrice() { List<Product> products = GetProductList(); List<double> productNames = products.Where(p => p.UnitPrice > 100).Select(p => p.UnitPrice).ToList(); return productNames; }
Ref: 
public List<Double> expensiveProductUnitPrice() { List<Product> products = getProductList(); List<Double> productNames = products.stream().filter(p -> p.getUnitPrice() > 100).map(p -> p.getUnitPrice()).toList(); return productNames; }
Hyp: 
public List<Double> expensiveProductUnitPrice() { List<Product> products = getProductList(); List<Double> productNames = products.stream().filter(p -> p.getUnitPrice() > 100).mapToDouble(p -> p.getUnitPrice()).toList(); return productNames; }

BLEU: 87.25
Edit Sim: 8


Src: 
public double[] ProjectionDoubleExcept() { double[] numbersA = { 0.1, 2.2, 4.3, 5.4, 6.5, 8.6, 9.7 }; double[] numbersB = { 0.1, 3.3, 5.4, 7.7, 8.6 }; var first = numbersA.Select(n => n-(int)n); var second = numbersB.Select(n => n-(int)n); double[] numbers = first.Except(second).ToArray(); return numbers; }
Ref: 
public double[] projectionDoubleExcept() { double[] numbersA = {0.1, 2.2, 4.3, 5.4, 6.5, 8.6, 9.7}; double[] numbersB = {0.1, 3.3, 5.4, 7.7, 8.6}; var first = Arrays.stream(numbersA).map(n -> n - (int) n); var second = Arrays.stream(numbersB).map(n -> n - (int) n); double[] differemtNumbers = first.distinct().filter(a -> second.allMatch(b -> b != a)).toArray(); return differemtNumbers; }
Hyp: 
public double[] projectionDoubleExcept() { double[] numbersA = {0.1, 2.2, 4.3, 5.4, 6.5, 8.6, 9.7}; double[] numbersB = {0.1, 3.3, 5.4, 7.7, 8.6}; var first = Arrays.stream(numbersA).map(n -> n - (int) n); var second = Arrays.stream(numbersB).map(n -> n - (int) n); return numbers; }

BLEU: 74.53
Edit Sim: 107


Src: 
public List<Tuple<string, string>> ProductCrossGroupJoinCategoriesName() { string[] categories = { "Beverages", "Condiments", "Vegetables", "Dairy Products", "Seafood" }; List<Product> products = GetProductList(); List<Tuple<string, string>> q = categories.GroupJoin(products, c => c, p => p.Category, (c, p) => Tuple.Create(c, p)) .SelectMany(t => t.Item2.Select(p=>p.ProductName), (t, n) => Tuple.Create(t.Item1, n)).ToList(); return q; }
Ref: 
public List<Pair<String, String>> productCrossGroupJoinCategoriesName() { String[] categories = {"Beverages", "Condiments", "Vegetables", "Dairy Products", "Seafood"}; List<Product> products = getProductList(); List<Pair<String, String>> q = Arrays.stream(categories).map( c -> Pair.with(c, products.stream().filter(p -> p.getCategory().equals(c)) .collect(Collectors.toList()))).flatMap(t -> t.getValue1().stream() .map(p1 -> Pair.with(t.getValue0(), p1.getProductName()))).toList(); return q; }
Hyp: 
public List<Pair<String, String>> productCrossGroupJoinCategoriesName() { String[] categories = {"Beverages", "Condiments", "Vegetables", "Dairy Products", "Seafood"}; List<Product> products = getProductList(); List<Pair<String, String>> q = Arrays.stream(categories).map( c -> Pair.with(c, products.stream().filter(p -> p.getCategory().equals(c)) .collect(Collectors.toList()))).flatMap(t -> t.getValue1().stream() .map(n -> Pair.with(t.getValue0(), n))).toList(); return q; }

BLEU: 87.35
Edit Sim: 21


Src: 
public Dictionary<bool, List<Product>> ProductGroupByPriceDictPrint() { List<Product> products = GetProductList(); Dictionary<bool, List<Product>> productGroup = products.GroupBy(p => p.UnitPrice > 100) .ToDictionary(g => g.Key, g => g.ToList()); productGroup[true].ForEach(p => Console.Write(p)); Console.WriteLine(); productGroup[false].ForEach(p => Console.Write(p)); return productGroup; }
Ref: 
public Map<Boolean, List<Product>> productGroupByPriceDictPrint() { List<Product> products = getProductList(); Map<Boolean, List<Product>> productGroup = products.stream().collect(groupingBy(p -> p.getUnitPrice() > 100)); productGroup.get(true).stream().forEach(n -> System.out.print(n)); System.out.println(); productGroup.get(false).stream().forEach(n -> System.out.print(n)); return productGroup; }
Hyp: 
public Map<Boolean, List<Product>> productGroupByPriceDictPrint() { List<Product> products = getProductList(); Map<Boolean, List<Product>> productGroup = products.stream().collect(groupingBy(p -> p.getUnitPrice() > 100)) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue())); Console.WriteLine(); return productGroup; }

BLEU: 66.49
Edit Sim: 111


Src: 
public int[] IntsConvertToArrayAndPrintForeach() { int[] ints = { 2, 3, 1, 5, 4 }; int[] intsArray = ints.OrderBy(d => d).ToArray(); foreach (int i in intsArray) Console.WriteLine(i); return intsArray; }
Ref: 
public int[] intsConvertToArrayAndPrintForeach() { int[] ints = {2, 3, 1, 5, 4}; int[] intsArray = Arrays.stream(ints).sorted().toArray(); for (int i : intsArray) System.out.println(i); return intsArray; }
Hyp: 
public int[] intsConvertToArrayAndPrintForeach() { int[] ints = {2, 3, 1, 5, 4}; int[] intsArray = Arrays.stream(ints).boxed().sorted().toArray(); for (int i : intsArray) System.out.println(i); return intsArray; }

BLEU: 89.42
Edit Sim: 8


Src: 
public List<Product> InStockProductSkipWhile() { List<Product> products = GetProductList(); List<Product> afterProductsWhile = products.Where(p => p.UnitsInStock > 0).SkipWhile(p => p.ProductId > 100).ToList(); return afterProductsWhile; }
Ref: 
public List<Product> inStockProductSkipWhile() { List<Product> products = getProductList(); List<Product> after3Products = products.stream().filter(p -> p.getUnitsInStock() > 100).dropWhile(p -> p.getProductId() > 100).toList(); return after3Products; }
Hyp: 
public List<Product> inStockProductSkipWhile() { List<Product> products = getProductList(); List<Product> after3Products = products.stream().filter(p -> p.getUnitsInStock() > 100).dropWhile(p -> p.getProductId() > 100).toList(); return after3Products; }

BLEU: 100.0
Edit Sim: 0


Src: 
public int OddNumbersFirst() { int[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 }; int firstNum = numbers.First(n => n % 2 == 1); return firstNum; }
Ref: 
public int oddNumbersFirst() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int firstNum = Arrays.stream(numbers).filter(n -> n % 2 == 1).findFirst().getAsInt(); return firstNum; }
Hyp: 
public int oddNumbersFirst() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int firstNum = Arrays.stream(numbers).filter(n -> n % 2 == 0).findFirst().orElse(0); return firstNum; }

BLEU: 91.28
Edit Sim: 9


Src: 
public int TotalOrdersCount(string region) { List<Customer> customers = GetCustomerList(); int count = customers.SelectMany(c => c.Orders).Count(); return count; }
Ref: 
public int totalOrdersCount(String region) { List<Customer> customers = getCustomerList(); int count = (int) customers.stream().flatMap(c -> c.getOrders().stream()).count(); return count; }
Hyp: 
public int totalOrdersCount(String region) { List<Customer> customers = getCustomerList(); int count = (int) customers.stream().flatMap(c -> c.getOrders().stream()).count(); return count; }

BLEU: 100.0
Edit Sim: 0


Src: 
public Dictionary<char, List<string>> StringGroupByFirstCharDict() { string[] words = { "blueberry", "chimpanzee", "abacus", "banana", "apple", "cheese" }; Dictionary<char, List<string>> wordsGroups = words.GroupBy(w => w[0]) .ToDictionary(g => g.Key, g => g.ToList()); return wordsGroups; }
Ref: 
public Map<Character, List<String>> stringGroupByFirstCharDict() { String[] words = {"blueberry", "chimpanzee", "abacus", "banana", "apple", "cheese"}; Map<Character, List<String>> wordsGroups = Arrays.stream(words).collect(groupingBy(w -> w.charAt(0))); return wordsGroups; }
Hyp: 
public Map<Character, List<String>> stringGroupByFirstCharDict() { String[] words = {"blueberry", "chimpanzee", "abacus", "banana", "apple", "cheese"}; Map<Character, List<String>> wordsGroups = Arrays.stream(words).collect(groupingBy(w -> w.charAt(0))) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue())); return wordsGroups; }

BLEU: 70.83
Edit Sim: 72


Src: 
public List<string> StringReverse() { string[] words = { "cherry", "apple", "blueberry" }; List<string> sortedWords = words.Reverse().ToList(); return sortedWords; }
Ref: 
public List<String> stringReverse() { String[] words = { "cherry", "apple", "blueberry" }; List<String> sortedWords = Arrays.stream(words).collect( collectingAndThen(toList(),l->{Collections.reverse(l);return l;})); return sortedWords; }
Hyp: 
public List<String> stringReverse() { String[] words = { "cherry", "apple", "blueberry" }; List<String> sortedWords = Arrays.stream(words).collect( collectingAndThen(toList(),l->{Collections.reverse(l);return l;})); return sortedWords; }

BLEU: 100.0
Edit Sim: 0


Src: 
public Dictionary<string, int> CustomerEachCountryOrdersMaxDict() { List<Customer> customers = GetCustomerList(); Dictionary<string, int> ordersMax = customers.GroupBy(c => c.Country) .ToDictionary(g => g.Key, g => g.Max(c => c.Orders.Count)); return ordersMax; }
Ref: 
public Map<String, Integer> customerEachCountryOrdersMaxDict() { List<Customer> customers = getCustomerList(); Map<String, Integer> ordersMax = customers.stream().collect(groupingBy(c -> c.getCountry())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().mapToInt(c -> c.getOrders().size()).max().getAsInt())); return ordersMax; }
Hyp: 
public Map<String, Integer> customerEachCountryOrdersMaxDict() { List<Customer> customers = getCustomerList(); Map<String, Integer> ordersMax = customers.stream().collect(groupingBy(c -> c.getCountry())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().mapToInt(c -> c.getOrders().size()).max().getAsInt())); return ordersMax; }

BLEU: 100.0
Edit Sim: 0


Src: 
public double BigNumbersAverage() { int[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 }; double averageNum = numbers.Where(n => n > 5).Average(); return averageNum; }
Ref: 
public double bigNumbersAverage() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; double averageNum = Arrays.stream(numbers).filter(n -> n >= 5).average().getAsDouble(); return averageNum; }
Hyp: 
public double bigNumbersAverage() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; double averageNum = Arrays.stream(numbers).filter(n -> n >= 5).average().getAsDouble(); return averageNum; }

BLEU: 100.0
Edit Sim: 0


Src: 
public void OddNumbersTwiceEager() { int[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 }; int i = 0; var q = numbers.Where(n => n % 2 == 1).Select(n => n * 2).Select(n => i += n).ToList(); foreach (var v in q) Console.Write(v + " " + i); }
Ref: 
public void oddNumbersTwiceEager() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; AtomicInteger i = new AtomicInteger(0); var q = Arrays.stream(numbers).filter(n->n%2==1).map(n->n*2).map(n -> i.addAndGet(n)).boxed().toList(); for (var v : q) System.out.println(v + " " + i); }
Hyp: 
public void oddNumbersTwiceEager() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; AtomicInteger i = new AtomicInteger(0); var q = Arrays.stream(numbers).filter(n->n% 2 == 1).map(n->n*2).map(n -> i.addAndGet(n)).boxed().toList(); for (var v : q) System.out.println(v + " " + i); }

BLEU: 86.93
Edit Sim: 3


Src: 
public Dictionary<int,bool> RangeOfIntsToDict() { Dictionary<int, bool> numbers = Enumerable.Range(0, 100).ToDictionary(n => n, n => n % 2 == 0); return numbers; }
Ref: 
public Map<Integer,Boolean> rangeOfIntsToDict() { Map<Integer,Boolean> numbers =IntStream.range(0, 100).boxed().collect(toMap(n->n,n->n%2==0)); return numbers; }
Hyp: 
public Map<Integer, Boolean> rangeOfIntsToDict() { Map<Integer, Boolean> numbers = IntStream.range(0, 100).boxed().collect(toMap(n -> n, n -> n % 2 == 0)); return numbers; }

BLEU: 12.59
Edit Sim: 12


Src: 
public List<int> IntsConvertToDescendingListAndPrint() { int[] ints = { 2, 3, 1, 5, 4 }; List<int> intsList = ints.OrderByDescending(d => d).ToList(); for (int i = 0; i < intsList.Count; i++) Console.WriteLine(intsList[i]); return intsList; }
Ref: 
public List<Integer> intsConvertToDescendingListAndPrint() { int[] ints = {2, 3, 1, 5, 4}; List<Integer> intsList = Arrays.stream(ints).boxed().sorted(Comparator.reverseOrder()).toList(); for (int i = 0; i < intsList.size(); i++) System.out.println(intsList.get(i)); return intsList; }
Hyp: 
public List<Integer> intsConvertToDescendingListAndPrint() { int[] ints = {2, 3, 1, 5, 4}; List<Integer> intsList = Arrays.stream(ints).boxed().sorted(Comparator.reverseOrder()).toList(); for (int i = 0; i < intsList.size(); i++) System.out.println(intsList[i]); return intsList; }

BLEU: 90.96
Edit Sim: 6


Src: 
public Dictionary<string, List<Customer>> CustomerEachCountryOrdersFirstCustomerDict() { List<Customer> customers = GetCustomerList(); Dictionary<string, List<Customer>> customerOrdersFirst = customers.GroupBy(c => c.Country) .ToDictionary(g => g.Key, g => g.Where(c => c.Orders.Count ==g.First().Orders.Count).ToList()); return customerOrdersFirst; }
Ref: 
public Map<String, List<Customer>> customerEachCountryOrdersFirstCustomerDict() { List<Customer> customers = getCustomerList(); Map<String, List<Customer>> customerOrdersFirst = customers.stream().collect(groupingBy(c -> c.getRegion())) .entrySet().stream().collect(toMap(g -> g.getKey(), g->g.getValue().stream().filter( c -> c.getOrders().size() == g.getValue().stream().findFirst().get().getOrders().size()).toList())); return customerOrdersFirst; }
Hyp: 
public Map<String, List<Customer>> customerEachCountryOrdersFirstCustomerDict() { List<Customer> customers = getCustomerList(); Map<String, List<Customer>> customerOrdersFirst = customers.stream().collect(groupingBy(c -> c.getCountry())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().filter( c -> c.getOrders().size() == g.getValue().stream().findFirst().getOrders().size()).toList())); return customerOrdersFirst; }

BLEU: 66.1
Edit Sim: 15


Src: 
public List<Tuple<string, double>> CustomerEachRegionOrdersTotalMax() { List<Customer> customers = GetCustomerList(); List<Tuple<string, double>> ordersTotalMax = customers.GroupBy(c => c.Region) .Select(g => Tuple.Create(g.Key, g.SelectMany(c => c.Orders).Max(o => o.Total))).ToList(); return ordersTotalMax; }
Ref: 
public List<Pair<String, Double>> customerEachRegionOrdersTotalMax() { List<Customer> customers = getCustomerList(); List<Pair<String, Double>> ordersTotalMax = customers.stream().collect(groupingBy(c -> c.getRegion())) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().flatMap(c -> c.getOrders().stream()).mapToDouble(o -> o.getTotal()).max().getAsDouble())).toList(); return ordersTotalMax; }
Hyp: 
public List<Pair<String, Double>> customerEachRegionOrdersTotalMax() { List<Customer> customers = getCustomerList(); List<Pair<String, Double>> ordersTotalMax = customers.stream().collect(groupingBy(c -> c.getRegion())) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().flatMap(c -> c.getOrders().stream()).mapToDouble(o -> o.getTotal()).max().getAsDouble())).toList(); return ordersTotalMax; }

BLEU: 100.0
Edit Sim: 0


Src: 
public List<double> BigDoubleFractionOrderbyDescending() { double[] numbers = { 3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0 }; List<double> sortedNumbers = numbers.Where(n => n > 5).Select(n => n-(int)n).OrderByDescending(n=>n).ToList(); return sortedNumbers; }
Ref: 
public List<Double> bigDoubleFractionOrderbyDescending() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; List<Double> sortedNumbers = Arrays.stream(numbers).filter(n -> n > 5).map(n -> n - (int) n).boxed() .sorted(Comparator.reverseOrder()).toList(); return sortedNumbers; }
Hyp: 
public List<Double> bigDoubleFractionOrderbyDescending() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; List<Double> sortedNumbers = Arrays.stream(numbers).filter(n -> n>5).map(n -> n - (int) n).boxed().sorted(Comparator.reverseOrder()).toList(); return sortedNumbers; }

BLEU: 75.28
Edit Sim: 3


Src: 
public Dictionary<bool, List<Product>> ProductGroupByInStockDict() { List<Product> products = GetProductList(); Dictionary<bool, List<Product>> productGroup = products.GroupBy(p => p.UnitsInStock == 0) .ToDictionary(g => g.Key, g => g.ToList()); return productGroup; }
Ref: 
public Map<Boolean, List<Product>> productGroupByInStockDict() { List<Product> products = getProductList(); Map<Boolean, List<Product>> productGroup = products.stream().collect(groupingBy(p -> p.getUnitsInStock() > 0)); return productGroup; }
Hyp: 
public Map<Boolean, List<Product>> productGroupByInStockDict() { List<Product> products = getProductList(); Map<Boolean, List<Product>> productGroup = products.stream().collect(groupingBy(p -> p.getUnitsInStock() > 0)); return productGroup; }

BLEU: 100.0
Edit Sim: 0


Src: 
public int UniqueFactorOf300Count() { int[] factorsOf300 = { 2, 2, 3, 5, 5 }; int uniqueFactorsCount = factorsOf300.Distinct().Count(); return uniqueFactorsCount; }
Ref: 
public int uniqueFactorOf300Count() { int[] factorsOf300 = {2, 2, 3, 5, 5}; int uniqueFactorsCount = (int) Arrays.stream(factorsOf300).distinct().count(); return uniqueFactorsCount; }
Hyp: 
public int uniqueFactorOf300Count() { int[] factorsOf300 = {2, 2, 3, 5, 5}; int uniqueFactorsCount = Arrays.stream(factorsOf300).distinct().count(); return uniqueFactorsCount; }

BLEU: 86.58
Edit Sim: 6


Src: 
public bool LongStringAllMatch() { string[] words = { "cherry", "apple", "blueberry", "banana", "abacus" }; bool allMatch = words.Where(w => w.Length > 5).All(n => string.CompareOrdinal(n, "b") > 0); return allMatch; }
Ref: 
public boolean longStringAllMatch() { String[] words = {"cherry", "apple", "blueberry", "banana", "abacus"}; boolean allMatch = Arrays.stream(words).filter(w -> w.length() > 5).allMatch(n -> n.compareTo("b") > 0); return allMatch; }
Hyp: 
public boolean longStringAllMatch() { String[] words = {"cherry", "apple", "blueberry", "banana", "abacus"}; boolean allMatch = Arrays.stream(words).filter(w -> w.length() > 5).allMatch(n -> n.compareTo("b") > 0); return allMatch; }

BLEU: 100.0
Edit Sim: 0


Src: 
public List<Product> ProductTakeWhile() { List<Product> products = GetProductList(); List<Product> firstProductsWhile = products.TakeWhile(p => p.ProductId > 100).ToList(); return firstProductsWhile; }
Ref: 
public List<Product> productTakeWhile() { List<Product> products = getProductList(); List<Product> after3Products = products.stream().takeWhile(p -> p.getProductId() > 100).toList(); return after3Products; }
Hyp: 
public List<Product> productTakeWhile() { List<Product> products = getProductList(); List<Product> after3Products = products.stream().takeWhile(p -> p.getProductId() > 100).toList(); return after3Products; }

BLEU: 100.0
Edit Sim: 0


Src: 
public int OddNumbersMinTwice() { int[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 }; int minNum = numbers.Where(n => n % 2 == 1).Min(n => n * 2); return minNum; }
Ref: 
public int oddNumbersMinTwice() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int minNum = Arrays.stream(numbers).filter(n -> n % 2 == 0).map(n -> n * 2).min().getAsInt(); return minNum; }
Hyp: 
public int oddNumbersMinTwice() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int minNum = Arrays.stream(numbers).filter(n -> n % 2 == 0).map(n -> n * 2).min().getAsInt(); return minNum; }

BLEU: 100.0
Edit Sim: 0


Src: 
public void BigDoubleNumbersDeferred() { double[] numbers = { 3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0 }; double d = 0; var q = numbers.Where(d => d > 5).Select(n => d += n); foreach (var v in q) Console.Write(v + " " + d); }
Ref: 
public void bigDoubleNumbersDeferred() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; AtomicReference<Double> d = new AtomicReference<>(0.0); var q = Arrays.stream(numbers).filter(n->n>5).map(n -> d.accumulateAndGet(n, Double::sum)); q.forEach(v -> System.out.println(v + " " + d)); }
Hyp: 
public void bigDoubleNumbersDeferred() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; AtomicReference<Double> d = new AtomicReference<>(0.0); var q = Arrays.stream(numbers).filter(n->n>5).map(n -> d.accumulateAndGet(n, Double::sum)).boxed().toList(); for (var v : q) System.out.println(v + " " + d); }

BLEU: 76.93
Edit Sim: 29


Src: 
public List<Tuple<string, DateTime>> WaCustomerOrdersEachNestedTakeWhile() { List<Customer> customers = GetCustomerList(); List<Tuple<string, DateTime>> firstOrdersEachWhile = customers.Where(c => c.Region == "WA") .SelectMany(c => c.Orders.TakeWhile(o => o.OrderDate > new DateTime( 2000, 1, 1)), (c, o) => Tuple.Create( c.CustomerId, o.OrderDate)).ToList(); return firstOrdersEachWhile; }
Ref: 
public List<Pair<String, LocalDate>> waCustomerOrdersEachNestedTakeWhile() { List<Customer> customers = getCustomerList(); List<Pair<String, LocalDate>> after3EachWAOrders = customers.stream().filter(c -> c.getRegion().equals("WA")) .flatMap(c -> c.getOrders().stream().takeWhile(o -> o.getOrderDate() .isAfter(LocalDate.of(2000, 1, 1))) .map(o -> Pair.with(c.getCustomerId(), o.getOrderDate()))).toList(); return after3EachWAOrders; }
Hyp: 
public List<Pair<String, LocalDate>> waCustomerOrdersEachNestedTakeWhile() { List<Customer> customers = getCustomerList(); List<Pair<String, LocalDate>> after3EachWAOrders = customers.stream().filter(c -> c.getRegion().equals("WA")) .flatMap(c -> c.getOrders().stream().takeWhile(o -> o.getOrderDate() .isAfter(LocalDate.of(2000, 1, 1))) .map(o -> Pair.with(c.getCustomerId(), o.getOrderDate()))).toList(); return after3EachWAOrders; }

BLEU: 100.0
Edit Sim: 0


Src: 
public Dictionary<string, int> ExpensiveProductEachCategoryStockDict() { List<Product> products = GetProductList(); Dictionary<string, int> categories = products.GroupBy(p => p.Category) .ToDictionary(g => g.Key, g => g.Where(p=>p.UnitPrice>100).Sum(p => p.UnitsInStock)); return categories; }
Ref: 
public Map<String, Integer> expensiveProductEachCategoryStockDict() { List<Product> products = getProductList(); Map<String, Integer> categories = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().filter( p -> p.getUnitPrice() > 100).mapToInt(p -> p.getUnitsInStock()).sum())); return categories; }
Hyp: 
public Map<String, Integer> expensiveProductEachCategoryStockDict() { List<Product> products = getProductList(); Map<String, Integer> categories = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().filter( p -> p.getUnitPrice() > 100).mapToInt(p -> p.getUnitsInStock()).sum())); return categories; }

BLEU: 100.0
Edit Sim: 0


Src: 
public List<string> StringOrderbyThenbyLengthDescendingCustom() { string[] words = { "cherry", "apple", "blueberry","banana","abacus" }; List<string> sortedWords = words.OrderBy(w => w) .ThenByDescending(w=>w.Length,new CustomNumberComparer()).ToList(); return sortedWords; }
Ref: 
public List<String> stringOrderbyThenbyLengthDescendingCustom() { String[] words = {"cherry", "apple", "blueberry", "banana", "abacus"}; List<String> sortedWords =Arrays.stream(words).sorted(Comparator.comparing((String w) -> w) .thenComparing(w -> w.length(),new CustomNumberComparer().reversed())).toList(); return sortedWords; }
Hyp: 
public List<String> stringOrderbyThenbyLengthDescendingCustom() { String[] words = {"cherry", "apple", "blueberry","banana","abacus"}; List<String> sortedWords =Arrays.stream(words) .sorted(Comparator.comparing((String w) -> w) .thenComparing(w -> w.length(),new CustomNumberComparer().reversed())).toList(); return sortedWords; }

BLEU: 71.48
Edit Sim: 3


Src: 
public double BigDoubleNumbersFirstOrDefault() { double[] numbers = { 3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0 }; double firstNum = numbers.FirstOrDefault(d => d > 5,-2.3); return firstNum; }
Ref: 
public double bigDoubleNumbersFirstOrDefault() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; double firstNum = Arrays.stream(numbers).filter(d -> d > 5).findFirst().orElse(-2.3); return firstNum; }
Hyp: 
public double bigDoubleNumbersFirstOrDefault() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; double firstNum = Arrays.stream(numbers).filter(n -> n > 5).findFirst().orElse(-2.3); return firstNum; }

BLEU: 84.1
Edit Sim: 2


Src: 
public Dictionary<string, double> CustomerInRegionOrdersTotalSumDict(string region) { List<Customer> customers = GetCustomerList(); Dictionary<string, double> ordersTotalSum = customers.Where(c => c.Region.Equals(region)) .ToDictionary(c => c.CustomerId, c => c.Orders.Sum(o => o.Total)); return ordersTotalSum; }
Ref: 
public Map<String, Double> customerInRegionOrdersTotalSumDict(String region) { List<Customer> customers = getCustomerList(); Map<String, Double> ordersTotalSum = customers.stream().filter(c -> c.getRegion().equals(region)) .collect(toMap(c -> c.getCustomerId(), c -> c.getOrders().stream().mapToDouble(o -> o.getTotal()).sum())); return ordersTotalSum; }
Hyp: 
public Map<String, Double> customerInRegionOrdersTotalSumDict(String region) { List<Customer> customers = getCustomerList(); Map<String, Double> ordersTotalSum = customers.stream().filter(c -> c.getRegion().equals(region)) .collect(toMap(c -> c.getCustomerId(), c -> c.getOrders().stream().mapToDouble(o -> o.getTotal()).sum())); return ordersTotalSum; }

BLEU: 100.0
Edit Sim: 0


Src: 
public List<double> DoubleOrderbyFractionDescendingThenby() { double[] numbers = { 3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0 }; List<double> sortedNumbers = numbers.OrderByDescending(n => n-(int)n).ThenBy(n => n).ToList(); return sortedNumbers; }
Ref: 
public List<Double> doubleOrderbyFractionDescendingThenby() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; List<Double> sortedNumbers = Arrays.stream(numbers).boxed().sorted( Comparator.comparing((Double n) -> n - (int) n.doubleValue(),Comparator.reverseOrder()) .thenComparing(Comparator.naturalOrder())).toList(); return sortedNumbers; }
Hyp: 
public List<Double> doubleOrderbyFractionDescendingThenby() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; List<Double> sortedNumbers = Arrays.stream(numbers).boxed().sorted( Comparator.comparing((Double n) -> n - (int) n.doubleValue()) .thenComparing(Comparator.naturalOrder())).toList(); return sortedNumbers; }

BLEU: 91.85
Edit Sim: 26


Src: 
public Dictionary<string, List<Product>> ProductGroupSkip() { List<Product> products = GetProductList(); Dictionary<string, List<Product>> after3Groups = products.GroupBy(p => p.Category) .Skip(3).ToDictionary(g => g.Key, g => g.ToList()); return after3Groups; }
Ref: 
public Map<String, List<Product>> productGroupSkip() { List<Product> products = getProductList(); Map<String, List<Product>> after3Groups = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().skip(3).collect(toMap(g -> g.getKey(), g -> g.getValue())); return after3Groups; }
Hyp: 
public Map<String, List<Product>> productGroupSkip() { List<Product> products = getProductList(); Map<String, List<Product>> after3Groups = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().skip(3).collect(toMap(g -> g.getKey(), g -> g.getValue())); return after3Groups; }

BLEU: 100.0
Edit Sim: 0


Src: 
public Dictionary<bool, List<Product>> ProductGroupByPriceDict() { List<Product> products = GetProductList(); Dictionary<bool, List<Product>> productGroup = products.GroupBy(p => p.UnitPrice > 100) .ToDictionary(g => g.Key, g => g.ToList()); return productGroup; }
Ref: 
public Map<Boolean, List<Product>> productGroupByPriceDict() { List<Product> products = getProductList(); Map<Boolean, List<Product>> productGroup = products.stream().collect(groupingBy(p -> p.getUnitPrice() > 100)); return productGroup; }
Hyp: 
public Map<Boolean, List<Product>> productGroupByPriceDict() { List<Product> products = getProductList(); Map<Boolean, List<Product>> productGroup = products.stream().collect(groupingBy(p -> p.getUnitPrice() > 100)) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue())); return productGroup; }

BLEU: 67.46
Edit Sim: 72


Src: 
public int NumbersMin() { int[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 }; int minNum = numbers.Min(); return minNum; }
Ref: 
public int numbersMin() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int minNum = Arrays.stream(numbers).min().getAsInt(); return minNum; }
Hyp: 
public int numbersMin() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int minNum = Arrays.stream(numbers).min().getAsInt(); return minNum; }

BLEU: 100.0
Edit Sim: 0


Src: 
public List<string> ExpensiveProductNameOrderby() { List<Product> products = GetProductList(); List<string> sortedProducts = products.Where(p=>p.UnitPrice>100).Select(p => p.ProductName).OrderBy(n=>n).ToList(); return sortedProducts; }
Ref: 
public List<String> expensiveProductNameOrderby() { List<Product> products = getProductList(); List<String> sortedProducts = products.stream().filter(p -> p.getUnitPrice() > 100).map(p -> p.getProductName()).sorted().toList(); return sortedProducts; }
Hyp: 
public List<String> expensiveProductNameOrderby() { List<Product> products = getProductList(); List<String> sortedProducts = products.stream().filter(p -> p.getUnitPrice() > 100).map(p -> p.getProductName()) .sorted(Comparator.comparing(n -> n).toList(); return sortedProducts; }

BLEU: 76.09
Edit Sim: 28


Src: 
public bool ProjectionEqualDoubles() { double[] numbersA = { 0.5, 2.3, 4.7, 5.4, 9.8 }; double[] numbersB = { 6.5, 1.3, 8.7, 2.4, 4.8 }; bool equal = numbersA.Select(n => n - (int)n).SequenceEqual(numbersB.Select(n => n - (int)n)); return equal; }
Ref: 
public boolean projectionEqualDoubles() { double[] numbersA = {0.5, 2.3, 4.7, 5.4, 9.8}; double[] numbersB = {6.5, 1.3, 8.7, 2.4, 4.8}; boolean equal = Arrays.equals(Arrays.stream(numbersA).map(n -> n - (int) n). toArray(), numbersB); return equal; }
Hyp: 
public boolean projectionEqualDoubles() { double[] numbersA = {0.5, 2.3, 4.7, 5.4, 9.8}; double[] numbersB = {6.5, 1.3, 8.7, 2.4, 4.8}; boolean equal = Arrays.equals(numbersA, numbersB); return equal; }

BLEU: 73.14
Edit Sim: 48


Src: 
public List<Product> ProductOrderbyCategoryThenbyDescendingId() { List<Product> products = GetProductList(); List<Product> sortedProducts = products.OrderBy(p => p.Category).ThenByDescending(p=>p.ProductId).ToList(); return sortedProducts; }
Ref: 
public List<Product> productOrderbyCategoryThenbyDescendingId() { List<Product> products = getProductList(); List<Product> sortedProducts = products.stream().sorted(Comparator.comparing((Product p) -> p.getCategory()) .thenComparing(p -> p.getProductId(),Comparator.reverseOrder())).toList(); return sortedProducts; }
Hyp: 
public List<Product> productOrderbyCategoryThenbyDescendingId() { List<Product> products = getProductList(); List<Product> sortedProducts = products.stream().sorted(Comparator.comparing((Product p) -> p.getCategory()) .thenComparing(p -> p.getProductId(),Comparator.reverseOrder())).toList(); return sortedProducts; }

BLEU: 100.0
Edit Sim: 0


Src: 
public List<string> ShortStringOrderbyCustom() { string[] words = { "aPPLE", "AbAcUs", "bRaNcH", "BlUeBeRrY", "ClOvEr", "cHeRry" }; List<string> sortedWords = words.Where(w => w.Length < 6).OrderBy(w => w, new CaseInsensitiveComparer()).ToList(); return sortedWords; }
Ref: 
public List<String> shortStringOrderbyCustom() { String[] words = {"aPPLE", "AbAcUs", "bRaNcH", "BlUeBeRrY", "ClOvEr", "cHeRry"}; List<String> sortedWords = Arrays.stream(words).filter(w -> w.length() < 6).sorted(new CaseInsensitiveComparer()). toList(); return sortedWords; }
Hyp: 
public List<String> shortStringOrderbyCustom() { String[] words = {"aPPLE", "AbAcUs", "bRaNcH", "BlUeBeRrY", "ClOvEr", "cHeRry"}; List<String> sortedWords = Arrays.stream(words).filter(w -> w.length() < 6).sorted(new CaseInsensitiveComparer()).toList(); return sortedWords; }

BLEU: 85.92
Edit Sim: 1


Src: 
public List<Product> ProductOrderbyName() { List<Product> products = GetProductList(); List<Product> sortedProducts = products.OrderBy(p => p.ProductName).ToList(); return sortedProducts; }
Ref: 
public List<Product> productOrderbyName() { List<Product> products = getProductList(); List<Product> sortedProducts = products.stream().sorted(Comparator.comparing(p -> p.getProductName())).toList(); return sortedProducts; }
Hyp: 
public List<Product> productOrderbyName() { List<Product> products = getProductList(); List<Product> sortedProducts = products.stream().sorted(Comparator.comparing( p -> p.getProductName())).toList(); return sortedProducts; }

BLEU: 79.13
Edit Sim: 1


Src: 
public List<Product> ProductOrderbyCategoryThenbyName() { List<Product> products = GetProductList(); List<Product> sortedProducts = products.OrderBy(p => p.Category).ThenBy(p=>p.ProductName).ToList(); return sortedProducts; }
Ref: 
public List<Product> productOrderbyCategoryThenbyName() { List<Product> products = getProductList(); List<Product> sortedProducts = products.stream().sorted(Comparator.comparing((Product p) -> p.getCategory()) .thenComparing(p -> p.getProductName())).toList(); return sortedProducts; }
Hyp: 
public List<Product> productOrderbyCategoryThenbyName() { List<Product> products = getProductList(); List<Product> sortedProducts = products.stream().sorted(Comparator.comparing((Product p) -> p.getCategory()) .thenComparing(p -> p.getProductName())).toList(); return sortedProducts; }

BLEU: 100.0
Edit Sim: 0


Src: 
public bool ProjectionEqualStrings() { List<string> wordsA = new List<string> { "Alpha", "Beta", "Gamma" }; List<string> wordsB = new List<string> { "aLPhA", "bETa", "gAaMa" }; bool equal = wordsA.Select(w => w.ToLower()).SequenceEqual(wordsB.Select(w => w.ToLower())); return equal; }
Ref: 
public boolean projectionEqualStrings() { List<String> wordsA = Arrays.asList("Alpha", "Beta", "Gamma"); List<String> wordsB = Arrays.asList("aLPhA", "bETa", "gAaMa"); boolean equal = wordsA.stream().map(w -> w.toLowerCase()).toList().equals(wordsB); return equal; }
Hyp: 
public boolean projectionEqualStrings() { List<String> wordsA = Arrays.asList( "Alpha", "Beta", "Gamma" ); List<String> wordsB = Arrays.asList( "aLPhA", "bETa", "gAaMa" ); boolean equal = Arrays.equals(wordsA, wordsB); return equal; }

BLEU: 37.37
Edit Sim: 53


Src: 
public List<Order> CustomerSelectManyBigOrders() { List<Customer> customers = GetCustomerList(); List<Order> customerProperties = customers.SelectMany(c=> c.Orders.Where(o=>o.Total>100)).ToList(); return customerProperties; }
Ref: 
public List<Order> customerSelectManyBigOrders() { List<Customer> customers = getCustomerList(); List<Order> customerProperties = customers.stream().flatMap(c -> c.getOrders() .stream().filter(o -> o.getTotal() > 100)).toList(); return customerProperties; }
Hyp: 
public List<Order> customerSelectManyBigOrders() { List<Customer> customers = getCustomerList(); List<Order> customerProperties = customers.stream().flatMap(c -> c.getOrders() .stream().filter(o -> o.getTotal() > 100) .map(o -> o.getOrder())).toList(); return customerProperties; }

BLEU: 77.09
Edit Sim: 24


