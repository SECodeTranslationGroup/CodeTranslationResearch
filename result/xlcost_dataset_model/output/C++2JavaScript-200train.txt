Src: 
bool checkIsAP ( int arr [ ] , int n ) { if ( n == 1 ) return true ; sort ( arr , arr + n ) ; int d = arr [ 1 ] - arr [ 0 ] ; for ( int i = 2 ; i < n ; i ++ ) if ( arr [ i ] - arr [ i - 1 ] != d ) return false ; return true ; }
Ref: 
function checkIsAP ( arr , n ) { if ( n == 1 ) return true ; arr . sort ( ( a , b ) => a - b ) ; let d = arr [ 1 ] - arr [ 0 ] ; for ( let i = 2 ; i < n ; i ++ ) if ( arr [ i ] - arr [ i - 1 ] != d ) return false ; return true ; }
Hyp: 
function checkIsAP ( arr , n ) { if ( n == 1 ) return true ; arr . sort ( function ( a , b ) { return a - b } ) ; let d = arr [ 1 ] - arr [ 0 ] ; for ( let i = 2 ; i < n ; i ++ ) if ( arr [ i ] - arr [ i - 1 ] != d ) return false ; return true ; }

BLEU: 89.79
Edit Sim: 19


Src: 
int longestSubArray ( int arr [ ] , int n ) { bool isZeroPresent = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) { isZeroPresent = true ; break ; } } if ( isZeroPresent ) return n ; return 0 ; }
Ref: 
function longestSubArray ( arr , n ) { var isZeroPresent = false ; for ( var i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) { isZeroPresent = true ; break ; } } if ( isZeroPresent ) return n ; return 0 ; }
Hyp: 
function longestSubArray ( arr , n ) { let isZeroPresent = false ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) { isZeroPresent = true ; break ; } } if ( isZeroPresent ) return n ; return 0 ; }

BLEU: 90.97
Edit Sim: 6


Src: 
ll F ( ll A , ll B ) { if ( A == 1 ) return ( 4 % B ) ; else { ll temp = F ( A - 1 , B ) ; return ( temp * temp ) % B ; } }
Ref: 
function F ( A , B ) { if ( A == 1 ) return ( 4 % B ) ; else { var temp = F ( A - 1 , B ) ; return ( temp * temp ) % B ; } }
Hyp: 
function F ( A , B ) { if ( A == 1 ) return ( 4 % B ) ; else { let temp = F ( A - 1 , B ) ; return ( temp * temp ) % B ; } }

BLEU: 94.41
Edit Sim: 3


Src: 
bool sentencePalindrome ( string str ) { int l = 0 , h = str . length ( ) - 1 ; for ( int i = 0 ; i <= h ; i ++ ) str [ i ] = tolower ( str [ i ] ) ; while ( l <= h ) { if ( ! ( str [ l ] >= ' a ' && str [ l ] <= ' z ' ) ) l ++ ; else if ( ! ( str [ h ] >= ' a ' && str [ h ] <= ' z ' ) ) h -- ; else if ( str [ l ] == str [ h ] ) l ++ , h -- ; else return false ; } return true ; }
Ref: 
function sentencePalindrome ( str ) { let l = 0 ; let h = str . length - 1 ; str = str . toLowerCase ( ) ; while ( l <= h ) { let getAtl = str [ l ] ; let getAth = str [ h ] ; if ( ! ( getAtl >= ' ' && getAtl <= ' ' ) ) l ++ ; else if ( ! ( getAth >= ' ' && getAth <= ' ' ) ) h -- ; else if ( getAtl == getAth ) { l ++ ; h -- ; } else return false ; } return true ; }
Hyp: 
function sentencePalindrome ( str ) { let l = 0 , h = str . length - 1 ; for ( let i = 0 ; i <= h ; i ++ ) str [ i ] = str . toLowerCase ( ) ; while ( l <= h ) { if ( ! ( str [ l ] . charCodeAt ( ) >= ' ' . charCodeAt ( ) && str [ l ] . charCodeAt ( ) <= ' ' . charCodeAt ( ) ) ) l ++ ; else if ( str [ h ] . charCodeAt ( ) == str [ h ] . charCodeAt ( ) ) h -- ; else if ( str [ l ] == str [ h ] ) l ++ , h -- ; else return false ; } return true ; }

BLEU: 43.76
Edit Sim: 184


Src: 
float Calculate_GST ( float org_cost , float N_price ) { return ( ( ( N_price - org_cost ) * 100 ) / org_cost ) ; }
Ref: 
function Calculate_GST ( org_cost , N_price ) { return ( ( ( N_price - org_cost ) * 100 ) / org_cost ) ; }
Hyp: 
function Calculate_GST ( org_cost , N_price ) { return ( ( ( N_price - org_cost ) * 100 ) / org_cost ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
void FindPoints ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 , int x4 , int y4 ) { int x5 = max ( x1 , x3 ) ; int y5 = max ( y1 , y3 ) ; int x6 = min ( x2 , x4 ) ; int y6 = min ( y2 , y4 ) ; if ( x5 > x6 y5 > y6 ) { cout << " No ▁ intersection " ; return ; } cout << " ( " << x5 << " , ▁ " << y5 << " ) ▁ " ; cout << " ( " << x6 << " , ▁ " << y6 << " ) ▁ " ; int x7 = x5 ; int y7 = y6 ; cout << " ( " << x7 << " , ▁ " << y7 << " ) ▁ " ; int x8 = x6 ; int y8 = y5 ; cout << " ( " << x8 << " , ▁ " << y8 << " ) ▁ " ; }
Ref: 
function FindPoints ( x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 ) { var x5 = Math . max ( x1 , x3 ) ; var y5 = Math . max ( y1 , y3 ) ; var x6 = Math . min ( x2 , x4 ) ; var y6 = Math . min ( y2 , y4 ) ; if ( x5 > x6 y5 > y6 ) { document . write ( " " ) ; return ; } document . write ( " " + x5 + " " + y5 + " " ) ; document . write ( " " + x6 + " " + y6 + " " ) ; var x7 = x5 ; var y7 = y6 ; document . write ( " " + x7 + " " + y7 + " " ) ; var x8 = x6 ; var y8 = y5 ; document . write ( " " + x8 + " " + y8 + " " ) ; }
Hyp: 
function FindPoints ( x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 ) { var x5 = Math . max ( x1 , x3 ) ; var y5 = Math . max ( y1 , y3 ) ; var x6 = Math . min ( x2 , x4 ) ; var y6 = Math . min ( y2 , y4 ) ; if ( x5 > x6 y5 > y6 ) { document . write ( " " + x5 + " " + y5 + " " ) ; document . write ( " " + x6 + " " + y6 + " " ) ; } document . write ( " " + x7 + " " + y7 + " " ) ; var x8 = x6 ; var y8 = y5 ; document . write ( " " + x8 + " " + y8 + " " ) ; }

BLEU: 87.97
Edit Sim: 65


Src: 
int maxSum ( int mat [ SIZE ] [ SIZE ] , int n ) { if ( n == 1 ) return mat [ 0 ] [ 0 ] ; int dp [ n ] [ n ] ; int maxSum = INT_MIN , max ; for ( int j = 0 ; j < n ; j ++ ) dp [ n - 1 ] [ j ] = mat [ n - 1 ] [ j ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < n ; j ++ ) { max = INT_MIN ; if ( ( ( j - 1 ) >= 0 ) && ( max < dp [ i + 1 ] [ j - 1 ] ) ) max = dp [ i + 1 ] [ j - 1 ] ; if ( ( ( j + 1 ) < n ) && ( max < dp [ i + 1 ] [ j + 1 ] ) ) max = dp [ i + 1 ] [ j + 1 ] ; dp [ i ] [ j ] = mat [ i ] [ j ] + max ; } } for ( int j = 0 ; j < n ; j ++ ) if ( maxSum < dp [ 0 ] [ j ] ) maxSum = dp [ 0 ] [ j ] ; return maxSum ; }
Ref: 
function maxSum ( mat , n ) { if ( n == 1 ) return mat [ 0 ] [ 0 ] ; let dp = new Array ( n ) ; for ( var i = 0 ; i < dp . length ; i ++ ) { dp [ i ] = new Array ( 2 ) ; } let maxSum = Number . MIN_VALUE , max ; for ( let j = 0 ; j < n ; j ++ ) dp [ n - 1 ] [ j ] = mat [ n - 1 ] [ j ] ; for ( let i = n - 2 ; i >= 0 ; i -- ) { for ( let j = 0 ; j < n ; j ++ ) { max = Number . MIN_VALUE ; if ( ( ( j - 1 ) >= 0 ) && ( max < dp [ i + 1 ] [ j - 1 ] ) ) max = dp [ i + 1 ] [ j - 1 ] ; if ( ( ( j + 1 ) < n ) && ( max < dp [ i + 1 ] [ j + 1 ] ) ) max = dp [ i + 1 ] [ j + 1 ] ; dp [ i ] [ j ] = mat [ i ] [ j ] + max ; } } for ( let j = 0 ; j < n ; j ++ ) if ( maxSum < dp [ 0 ] [ j ] ) maxSum = dp [ 0 ] [ j ] ; return maxSum ; }
Hyp: 
function maxSum ( mat , n ) { if ( n == 1 ) return mat [ 0 ] [ 0 ] ; let dp = new Array ( n ) ; for ( let j = 0 ; j < n ; j ++ ) dp [ n - 1 ] [ j ] = mat [ n - 1 ] [ j ] ; for ( let i = n - 2 ; i >= 0 ; i -- ) { for ( let j = 0 ; j < n ; j ++ ) { max = INT_MIN ; if ( ( ( j - 1 ) >= 0 ) && ( max < dp [ i + 1 ] [ j - 1 ] ) ) max = dp [ i + 1 ] [ j - 1 ] ; if ( ( ( j + 1 ) < n ) && ( max < dp [ i + 1 ] [ j + 1 ] ) ) max = dp [ i + 1 ] [ j + 1 ] ; dp [ i ] [ j ] = mat [ i ] [ j ] + max ; } } for ( let j = 0 ; j < n ; j ++ ) if ( maxSum < dp [ 0 ] [ j ] ) maxSum = dp [ 0 ] [ j ] ; return maxSum ; }

BLEU: 84.12
Edit Sim: 131


Src: 
int pell ( int n ) { if ( n <= 2 ) return n ; return 2 * pell ( n - 1 ) + pell ( n - 2 ) ; }
Ref: 
function pell ( n ) { if ( n <= 2 ) return n ; return 2 * pell ( n - 1 ) + pell ( n - 2 ) ; }
Hyp: 
function pell ( n ) { if ( n <= 2 ) return n ; return 2 * pell ( n - 1 ) + pell ( n - 2 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
void testSomeNumbers ( int limit , int n ) { if ( n < 3 ) return ; for ( int a = 1 ; a <= limit ; a ++ ) for ( int b = a ; b <= limit ; b ++ ) { int pow_sum = pow ( a , n ) + pow ( b , n ) ; double c = pow ( pow_sum , 1.0 / n ) ; int c_pow = pow ( ( int ) c , n ) ; if ( c_pow == pow_sum ) { cout << " Count ▁ example ▁ found " ; return ; } } cout << " No ▁ counter ▁ example ▁ within ▁ given " " ▁ range ▁ and ▁ data " ; }
Ref: 
function testSomeNumbers ( limit , n ) { if ( n < 3 ) return ; for ( let a = 1 ; a <= limit ; a ++ ) for ( let b = a ; b <= limit ; b ++ ) { let pow_sum = ( Math . pow ( a , n ) + Math . pow ( b , n ) ) ; let c = Math . pow ( pow_sum , 1.0 / n ) ; let c_pow = Math . pow ( Math . round ( c ) , n ) ; if ( c_pow == pow_sum ) { document . write ( " " ) ; return ; } } document . write ( " " + " " ) ; }
Hyp: 
function testSomeNumbers ( limit , n ) { if ( n < 3 ) return ; for ( let a = 1 ; a <= limit ; a ++ ) for ( let b = a ; b <= limit ; b ++ ) { let pow_sum = Math . pow ( a , n ) + Math . pow ( b , n ) ; let c = Math . pow ( pow_sum , 1.0 / n ) ; let c_pow = Math . pow ( ( int ) c , n ) ; if ( c_pow == pow_sum ) { document . write ( " " ) ; return ; } } document . write ( " " + limit + " " ) ; }

BLEU: 90.81
Edit Sim: 25


Src: 
bool find3Numbers ( int A [ ] , int arr_size , int sum ) { int l , r ; for ( int i = 0 ; i < arr_size - 2 ; i ++ ) { for ( int j = i + 1 ; j < arr_size - 1 ; j ++ ) { for ( int k = j + 1 ; k < arr_size ; k ++ ) { if ( A [ i ] + A [ j ] + A [ k ] == sum ) { cout << " Triplet ▁ is ▁ " << A [ i ] << " , ▁ " << A [ j ] << " , ▁ " << A [ k ] ; return true ; } } } } return false ; }
Ref: 
function find3Numbers ( A , arr_size , sum ) { let l , r ; for ( let i = 0 ; i < arr_size - 2 ; i ++ ) { for ( let j = i + 1 ; j < arr_size - 1 ; j ++ ) { for ( let k = j + 1 ; k < arr_size ; k ++ ) { if ( A [ i ] + A [ j ] + A [ k ] == sum ) { document . write ( " " + A [ i ] + " " + A [ j ] + " " + A [ k ] ) ; return true ; } } } } return false ; }
Hyp: 
function find3Numbers ( A , arr_size , sum ) { let l , r ; for ( let i = 0 ; i < arr_size - 2 ; i ++ ) { for ( let j = i + 1 ; j < arr_size - 1 ; j ++ ) { for ( let k = j + 1 ; k < arr_size ; k ++ ) { if ( A [ i ] + A [ j ] + A [ k ] == sum ) { document . write ( " " + A [ i ] + " " + A [ j ] + " " + A [ k ] ) ; return true ; } } } } return false ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int ways ( int n ) { int first = 2 ; int second = 3 ; int res = 0 ; for ( int i = 3 ; i <= n ; i ++ ) { res = first + second ; first = second ; second = res ; } return res ; }
Ref: 
function ways ( n ) { var first = 2 ; var second = 3 ; var res = 0 ; for ( i = 3 ; i <= n ; i ++ ) { res = first + second ; first = second ; second = res ; } return res ; }
Hyp: 
function ways ( n ) { let first = 2 ; let second = 3 ; let res = 0 ; for ( let i = 3 ; i <= n ; i ++ ) { res = first + second ; first = second ; second = res ; } return res ; }

BLEU: 81.02
Edit Sim: 13


Src: 
float pentdiagonal ( float a ) { if ( a < 0 ) return -1 ; float d = 1.22 * a ; return d ; }
Ref: 
function pentdiagonal ( a ) { if ( a < 0 ) return - 1 ; let d = 1.22 * a ; return d ; }
Hyp: 
function pentdiagonal ( a ) { if ( a < 0 ) return - 1 ; var d = 1.22 * a ; return d ; }

BLEU: 90.25
Edit Sim: 3


Src: 
int evenNumSubstring ( char str [ ] ) { int len = strlen ( str ) ; int count = 0 ; for ( int i = 0 ; i < len ; i ++ ) { int temp = str [ i ] - '0' ; if ( temp % 2 == 0 ) count += ( i + 1 ) ; } return count ; }
Ref: 
function evenNumSubstring ( str ) { let len = str . length ; let count = 0 ; for ( let i = 0 ; i < len ; i ++ ) { let temp = str [ i ] - ' ' ; if ( temp % 2 == 0 ) count += ( i + 1 ) ; } return count ; }
Hyp: 
function evenNumSubstring ( str ) { let len = str . length ; let count = 0 ; for ( let i = 0 ; i < len ; i ++ ) { let temp = str [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ; if ( temp % 2 == 0 ) count += ( i + 1 ) ; } return count ; }

BLEU: 82.44
Edit Sim: 38


Src: 
int divisorSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; ++ i ) sum += ( n / i ) * i ; return sum ; }
Ref: 
function divisorSum ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; ++ i ) sum += Math . floor ( n / i ) * i ; return sum ; }
Hyp: 
function divisorSum ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; ++ i ) sum += ( n / i ) * i ; return sum ; }

BLEU: 88.86
Edit Sim: 13


Src: 
bool isPerfectSquareString ( string str ) { int sum = 0 ; int len = str . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) sum += ( int ) str [ i ] ; long double squareRoot = sqrt ( sum ) ; return ( ( squareRoot - floor ( squareRoot ) ) == 0 ) ; }
Ref: 
function isPerfectSquareString ( str ) { var sum = 0 ; var len = str . length ; for ( var i = 0 ; i < len ; i ++ ) sum += str . charCodeAt ( i ) ; var squareRoot = Math . sqrt ( sum ) ; return squareRoot - Math . floor ( squareRoot ) == 0 ; }
Hyp: 
function isPerfectSquareString ( str ) { var sum = 0 ; var len = str . length ; for ( var i = 0 ; i < len ; i ++ ) sum += ( int ) str [ i ] . charCodeAt ( 0 ) ; var squareRoot = Math . sqrt ( sum ) ; return ( ( squareRoot - Math . floor ( squareRoot ) ) == 0 ) ; }

BLEU: 74.97
Edit Sim: 23


Src: 
int kthSmallest ( int n , int k ) { return ( 2 * k ) ; }
Ref: 
function kthSmallest ( n , k ) { return ( 2 * k ) ; }
Hyp: 
function kthSmallest ( n , k ) { return ( 2 * k ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int MinOfCubed ( int k ) { if ( k < 8 ) return k ; int res = k ; for ( int i = 1 ; i <= k ; i ++ ) { if ( ( i * i * i ) > k ) return res ; res = min ( res , MinOfCubed ( k - ( i * i * i ) ) + 1 ) ; } return res ; }
Ref: 
function MinOfCubed ( k ) { if ( k < 8 ) return k ; let res = k ; for ( let i = 1 ; i <= k ; i ++ ) { if ( ( i * i * i ) > k ) return res ; res = Math . min ( res , MinOfCubed ( k - ( i * i * i ) ) + 1 ) ; } return res ; }
Hyp: 
function MinOfCubed ( k ) { if ( k < 8 ) return k ; let res = k ; for ( let i = 1 ; i <= k ; i ++ ) { if ( ( i * i * i ) > k ) return res ; res = Math . min ( res , MinOfCubed ( k - ( i * i * i ) ) + 1 ) ; } return res ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int StepstoReachTarget ( int target ) { target = abs ( target ) ; int n = ceil ( ( -1.0 + sqrt ( 1 + 8.0 * target ) ) / 2 ) ; int sum = n * ( n + 1 ) / 2 ; if ( sum == target ) return n ; int d = sum - target ; if ( ( d & 1 ) == 0 ) return n ; else return n + ( ( n & 1 ) ? 2 : 1 ) ; }
Ref: 
function StepstoReachTarget ( target ) { target = Math . abs ( target ) ; let n = Math . ceil ( ( - 1.0 + Math . sqrt ( 1 + 8.0 * target ) ) / 2 ) ; let sum = n * ( n + 1 ) / 2 ; if ( sum == target ) return n ; let d = sum - target ; if ( ( d & 1 ) == 0 ) return n ; else return n + ( ( n & 1 ) != 0 ? 2 : 1 ) ; }
Hyp: 
function StepstoReachTarget ( target ) { target = Math . abs ( target ) ; let n = Math . ceil ( ( - 1.0 + Math . sqrt ( 1 + 8.0 * target ) ) / 2 ) ; let sum = n * ( n + 1 ) / 2 ; if ( sum == target ) return n ; let d = sum - target ; if ( ( d & 1 ) == 0 ) return n ; else return n + ( ( n & 1 ) ? 2 : 1 ) ; }

BLEU: 96.52
Edit Sim: 5


Src: 
float findAreaShaded ( float a ) { float sqArea = a * a ; float semiCircleArea = ( 3.14 * ( a * a ) / 8 ) ; float ShadedArea = 4 * semiCircleArea - sqArea ; return ShadedArea ; }
Ref: 
function findAreaShaded ( a ) { let sqArea = a * a ; let semiCircleArea = ( 3.14 * ( a * a ) / 8 ) ; let ShadedArea = 4 * semiCircleArea - sqArea ; return ShadedArea ; }
Hyp: 
function findAreaShaded ( a ) { var sqArea = a * a ; var semiCircleArea = ( 3.14 * ( a * a ) / 8 ) ; var ShadedArea = 4 * semiCircleArea - sqArea ; return ShadedArea ; }

BLEU: 80.76
Edit Sim: 9


Src: 
int findNth ( int n ) { int count = 0 ; for ( int curr = 19 ; ; curr += 9 ) { int sum = 0 ; for ( int x = curr ; x > 0 ; x = x / 10 ) sum = sum + x % 10 ; if ( sum == 10 ) count ++ ; if ( count == n ) return curr ; } return -1 ; }
Ref: 
function findNth ( n ) { let count = 0 ; for ( let curr = 19 ; ; curr += 9 ) { let sum = 0 ; for ( let x = curr ; x > 0 ; x = parseInt ( x / 10 ) ) sum = sum + x % 10 ; if ( sum == 10 ) count ++ ; if ( count == n ) return curr ; } return - 1 ; }
Hyp: 
function findNth ( n ) { let count = 0 ; for ( let curr = 19 ; ; curr += 9 ) { let sum = 0 ; for ( let x = curr ; x > 0 ; x = Math . floor ( x / 10 ) ) sum = sum + x % 10 ; if ( sum == 10 ) count ++ ; if ( count == n ) return curr ; } return - 1 ; }

BLEU: 94.52
Edit Sim: 11


Src: 
int numberOfPaths ( int m , int n ) { int path = 1 ; for ( int i = n ; i < ( m + n - 1 ) ; i ++ ) { path *= i ; path /= ( i - n + 1 ) ; } return path ; }
Ref: 
function numberOfPaths ( m , n ) { var path = 1 ; for ( i = n ; i < ( m + n - 1 ) ; i ++ ) { path *= i ; path = parseInt ( path / ( i - n + 1 ) ) ; } return path ; }
Hyp: 
function numberOfPaths ( m , n ) { let path = 1 ; for ( let i = n ; i < ( m + n - 1 ) ; i ++ ) { path *= i ; path /= ( i - n + 1 ) ; } return path ; }

BLEU: 77.61
Edit Sim: 28


Src: 
int maxSum ( int arr [ ] , int i , int n ) { if ( i >= n ) return 0 ; if ( v [ i ] ) return dp [ i ] ; v [ i ] = 1 ; dp [ i ] = max ( maxSum ( arr , i + 1 , n ) , arr [ i ] + maxSum ( arr , i + 2 , n ) ) ; return dp [ i ] ; }
Ref: 
function maxSum ( arr , i , n ) { if ( i >= n ) return 0 ; if ( v [ i ] ) return dp [ i ] ; v [ i ] = 1 ; dp [ i ] = Math . max ( maxSum ( arr , i + 1 , n ) , arr [ i ] + maxSum ( arr , i + 2 , n ) ) ; return dp [ i ] ; }
Hyp: 
function maxSum ( arr , i , n ) { if ( i >= n ) return 0 ; if ( v [ i ] ) return dp [ i ] ; v [ i ] = 1 ; dp [ i ] = Math . max ( maxSum ( arr , i + 1 , n ) , arr [ i ] + maxSum ( arr , i + 2 , n ) ) ; return dp [ i ] ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int maxLines ( int n , int x1 [ ] , int y1 [ ] , int x2 [ ] , int y2 [ ] ) { unordered_set < double > s ; double slope ; for ( int i = 0 ; i < n ; ++ i ) { if ( x1 [ i ] == x2 [ i ] ) slope = INT_MAX ; else slope = ( y2 [ i ] - y1 [ i ] ) * 1.0 / ( x2 [ i ] - x1 [ i ] ) * 1.0 ; s . insert ( slope ) ; } return s . size ( ) ; }
Ref: 
function maxLines ( n , x1 , y1 , x2 , y2 ) { var s = [ ] ; var slope = 2147483647 ; for ( let i = 0 ; i < n ; i ++ ) { if ( x1 [ i ] === x2 [ i ] ) slope = 2147483647 ; else slope = ( ( ( y2 [ i ] - y1 [ i ] ) * 1.0 ) / ( x2 [ i ] - x1 [ i ] ) ) * 1.0 ; s . push ( slope ) ; } return s . length ; }
Hyp: 
function maxLines ( n , x1 , y1 , x2 , y2 ) { const s = new Set ( ) for ( let i = 0 ; i < n ; ++ i ) { if ( x1 [ i ] == x2 [ i ] ) slope = Number . MAX_VALUE ; else slope = ( y2 [ i ] - y1 [ i ] ) * 1.0 / ( x2 [ i ] - x1 [ i ] ) * 1.0 ; s . add ( slope ) ; } return s . size ( ) ; }

BLEU: 69.69
Edit Sim: 72


Src: 
int findSum ( int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += i * ( n - i ) ; return 2 * sum ; }
Ref: 
function findSum ( n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum += i * ( n - i ) ; return 2 * sum ; }
Hyp: 
function findSum ( n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum += i * ( n - i ) ; return 2 * sum ; }

BLEU: 100.0
Edit Sim: 0


Src: 
double areaOctagon ( double side ) { return ( float ) ( 2 * ( 1 + sqrt ( 2 ) ) * side * side ) ; }
Ref: 
function areaOctagon ( side ) { return ( 2 * ( 1 + Math . sqrt ( 2 ) ) * side * side ) ; }
Hyp: 
function areaOctagon ( side ) { return ( ( 2 * ( 1 + Math . sqrt ( 2 ) ) * side * side ) ; }

BLEU: 93.45
Edit Sim: 2


Src: 
void pairwiseDifference ( int arr [ ] , int n ) { int diff ; for ( int i = 0 ; i < n - 1 ; i ++ ) { diff = abs ( arr [ i ] - arr [ i + 1 ] ) ; cout << diff << " ▁ " ; } }
Ref: 
function pairwiseDifference ( arr , n ) { var diff ; for ( i = 0 ; i < n - 1 ; i ++ ) { diff = Math . abs ( arr [ i ] - arr [ i + 1 ] ) ; document . write ( diff + " " ) ; } }
Hyp: 
function pairwiseDifference ( arr , n ) { let diff ; for ( let i = 0 ; i < n - 1 ; i ++ ) { diff = Math . abs ( arr [ i ] - arr [ i + 1 ] ) ; document . write ( diff + " " ) ; } }

BLEU: 91.29
Edit Sim: 7


Src: 
int minDiff ( int n , int x , int A [ ] ) { int mn = A [ 0 ] , mx = A [ 0 ] ; for ( int i = 0 ; i < n ; ++ i ) { mn = min ( mn , A [ i ] ) ; mx = max ( mx , A [ i ] ) ; } return max ( 0 , mx - mn - 2 * x ) ; }
Ref: 
function minDiff ( n , x , A ) { var mn = A [ 0 ] , mx = A [ 0 ] ; for ( var i = 0 ; i < n ; ++ i ) { mn = Math . min ( mn , A [ i ] ) ; mx = Math . max ( mx , A [ i ] ) ; } return Math . max ( 0 , mx - mn - 2 * x ) ; }
Hyp: 
function minDiff ( n , x , A ) { let mn = A [ 0 ] ; let mx = A [ 0 ] ; for ( let i = 0 ; i < n ; ++ i ) { mn = Math . min ( mn , A [ i ] ) ; mx = Math . max ( mx , A [ i ] ) ; } return Math . max ( 0 , mx - mn - 2 * x ) ; }

BLEU: 90.03
Edit Sim: 11


Src: 
int findFirstMissing ( int array [ ] , int start , int end ) { if ( start > end ) return end + 1 ; if ( start != array [ start ] ) return start ; int mid = ( start + end ) / 2 ; if ( array [ mid ] == mid ) return findFirstMissing ( array , mid + 1 , end ) ; return findFirstMissing ( array , start , mid ) ; }
Ref: 
function findFirstMissing ( array , start , end ) { if ( start > end ) return end + 1 ; if ( start != array [ start ] ) return start ; let mid = parseInt ( ( start + end ) / 2 , 10 ) ; if ( array [ mid ] == mid ) return findFirstMissing ( array , mid + 1 , end ) ; return findFirstMissing ( array , start , mid ) ; }
Hyp: 
function findFirstMissing ( array , start , end ) { if ( start > end ) return end + 1 ; if ( start != array [ start ] ) return start ; let mid = parseInt ( ( start + end ) / 2 ) ; if ( array [ mid ] == mid ) return findFirstMissing ( array , mid + 1 , end ) ; return findFirstMissing ( array , start , mid ) ; }

BLEU: 95.61
Edit Sim: 5


Src: 
int solve ( int idx , int diff , int N , int M , int K ) { if ( idx > N ) { if ( diff == K ) return 1 ; return 0 ; } if ( dp [ idx ] [ diff ] != -1 ) return dp [ idx ] [ diff ] ; int ans = solve ( idx + 1 , diff , N , M , K ) ; ans += ( M - 1 ) * solve ( idx + 1 , diff + 1 , N , M , K ) ; return dp [ idx ] [ diff ] = ans % MOD ; }
Ref: 
function solve ( idx , diff , N , M , K ) { if ( idx > N ) { if ( diff == K ) return 1 ; return 0 ; } if ( dp [ idx ] [ diff ] != - 1 ) return dp [ idx ] [ diff ] ; let ans = solve ( idx + 1 , diff , N , M , K ) ; ans += ( M - 1 ) * solve ( idx + 1 , diff + 1 , N , M , K ) ; dp [ idx ] [ diff ] = ans % MOD ; return dp [ idx ] [ diff ] ; }
Hyp: 
function solve ( idx , diff , N , M , K ) { if ( idx > N ) { if ( diff == K ) return 1 ; return 0 ; } if ( dp [ idx ] [ diff ] != - 1 ) return dp [ idx ] [ diff ] ; let ans = solve ( idx + 1 , diff , N , M , K ) ; ans += ( M - 1 ) * solve ( idx + 1 , diff + 1 , N , M , K ) ; return dp [ idx ] [ diff ] = ans % MOD ; }

BLEU: 92.11
Edit Sim: 36


Src: 
int minNum ( int arr [ ] , int n ) { int odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 ) odd += 1 ; return ( odd % 2 ) ? 1 : 2 ; }
Ref: 
function minNum ( arr , n ) { let odd = 0 ; for ( let i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 != 0 ) odd += 1 ; return ( ( odd % 2 ) != 0 ) ? 1 : 2 ; }
Hyp: 
function minNum ( arr , n ) { let odd = 0 ; for ( let i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 ) odd += 1 ; return ( odd % 2 ) ? 1 : 2 ; }

BLEU: 83.66
Edit Sim: 14


Src: 
string encryptString ( string str , int n ) { int i = 0 , cnt = 0 ; string encryptedStr = " " ; while ( i < n ) { cnt = i + 1 ; while ( cnt -- ) encryptedStr += str [ i ] ; i ++ ; } return encryptedStr ; }
Ref: 
function encryptString ( str , n ) { let i = 0 , cnt = 0 ; let encryptedStr = " " ; while ( i < n ) { cnt = i + 1 ; while ( cnt -- > 0 ) encryptedStr += str [ i ] ; i ++ ; } return encryptedStr ; }
Hyp: 
function encryptString ( str , n ) { let i = 0 , cnt = 0 ; let encryptedStr = " " ; while ( i < n ) { cnt = i + 1 ; while ( cnt -- ) encryptedStr += str [ i ] ; i ++ ; } return encryptedStr ; }

BLEU: 93.82
Edit Sim: 4


Src: 
int calcFunction ( int n , int r ) { int finalDenominator = 1 ; int mx = max ( r , n - r ) ; for ( int i = mx + 1 ; i <= n ; i ++ ) { int denominator = ( int ) pow ( i , i ) ; int numerator = ( int ) pow ( i - mx , i - mx ) ; finalDenominator = ( finalDenominator * denominator ) / numerator ; } return finalDenominator ; }
Ref: 
function calcFunction ( n , r ) { var finalDenominator = 1 ; var mx = Math . max ( r , n - r ) ; for ( var i = mx + 1 ; i <= n ; i ++ ) { var denominator = Math . pow ( i , i ) ; var numerator = Math . pow ( i - mx , i - mx ) ; finalDenominator = ( finalDenominator * denominator ) / numerator ; } return finalDenominator ; }
Hyp: 
function calcFunction ( n , r ) { let finalDenominator = 1 ; let mx = Math . max ( r , n - r ) ; for ( let i = mx + 1 ; i <= n ; i ++ ) { let denominator = Math . pow ( i , i ) ; let numerator = Math . pow ( i - mx , i - mx ) ; finalDenominator = ( finalDenominator * denominator ) / numerator ; } return finalDenominator ; }

BLEU: 85.2
Edit Sim: 15


Src: 
int maxSum ( int a [ ] , int n ) { int ans = 0 ; int * arr = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) arr [ i ] = a [ i - 1 ] ; int * * dp = new int * [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) dp [ i ] = new int [ 3 ] ; for ( int i = 1 ; i <= n ; ++ i ) { dp [ i ] [ 0 ] = max ( arr [ i ] , dp [ i - 1 ] [ 0 ] + arr [ i ] ) ; dp [ i ] [ 1 ] = max ( 0 , dp [ i - 1 ] [ 0 ] ) - arr [ i ] ; if ( i >= 2 ) dp [ i ] [ 1 ] = max ( dp [ i ] [ 1 ] , dp [ i - 1 ] [ 1 ] + arr [ i ] ) ; if ( i >= 2 ) dp [ i ] [ 2 ] = dp [ i - 1 ] [ 1 ] - arr [ i ] ; if ( i >= 3 ) dp [ i ] [ 2 ] = max ( dp [ i ] [ 2 ] , dp [ i - 1 ] [ 2 ] + arr [ i ] ) ; ans = max ( ans , dp [ i ] [ 0 ] ) ; ans = max ( ans , dp [ i ] [ 1 ] ) ; ans = max ( ans , dp [ i ] [ 2 ] ) ; } return ans ; }
Ref: 
function maxSum ( a , n ) { let ans = 0 ; let arr = new Array ( n + 1 ) ; for ( let i = 1 ; i <= n ; i ++ ) arr [ i ] = a [ i - 1 ] ; let dp = new Array ( n + 1 ) ; for ( let i = 0 ; i <= n ; ++ i ) { dp [ i ] = new Array ( 3 ) ; for ( let j = 0 ; j < 3 ; ++ j ) { dp [ i ] [ j ] = 0 ; } } for ( let i = 1 ; i <= n ; ++ i ) { dp [ i ] [ 0 ] = Math . max ( arr [ i ] , dp [ i - 1 ] [ 0 ] + arr [ i ] ) ; dp [ i ] [ 1 ] = Math . max ( 0 , dp [ i - 1 ] [ 0 ] ) - arr [ i ] ; if ( i >= 2 ) dp [ i ] [ 1 ] = Math . max ( dp [ i ] [ 1 ] , dp [ i - 1 ] [ 1 ] + arr [ i ] ) ; if ( i >= 2 ) dp [ i ] [ 2 ] = dp [ i - 1 ] [ 1 ] - arr [ i ] ; if ( i >= 3 ) dp [ i ] [ 2 ] = Math . max ( dp [ i ] [ 2 ] , dp [ i - 1 ] [ 2 ] + arr [ i ] ) ; ans = Math . max ( ans , dp [ i ] [ 0 ] ) ; ans = Math . max ( ans , dp [ i ] [ 1 ] ) ; ans = Math . max ( ans , dp [ i ] [ 2 ] ) ; } return ans ; }
Hyp: 
function maxSum ( a , n ) { let ans = 0 ; let arr = new Array ( n + 1 ) ; for ( let i = 1 ; i <= n ; i ++ ) arr [ i ] = a [ i - 1 ] ; let dp = new Array ( n + 1 ) ; for ( let i = 0 ; i <= n ; i ++ ) dp [ i ] = new Array ( 3 ) ; for ( let i = 1 ; i <= n ; i ++ ) { dp [ i ] [ 0 ] = Math . max ( arr [ i ] , dp [ i - 1 ] [ 0 ] + arr [ i ] ) ; dp [ i ] [ 1 ] = Math . max ( 0 , dp [ i - 1 ] [ 0 ] ) - arr [ i ] ; if ( i >= 2 ) dp [ i ] [ 2 ] = dp [ i - 1 ] [ 1 ] - arr [ i ] ; if ( i >= 3 ) dp [ i ] [ 2 ] = Math . max ( dp [ i ] [ 2 ] , dp [ i - 1 ] [ 2 ] + arr [ i ] ) ; } return ans ; }

BLEU: 58.88
Edit Sim: 298


Src: 
int findAllSequence ( int N ) { if ( N % 2 == 0 ) { return pow ( 2 , N / 2 + 1 ) + pow ( 2 , N / 2 ) - 2 ; } else { return pow ( 2 , ( N + 1 ) / 2 ) + pow ( 2 , ( N + 1 ) / 2 ) - 2 ; } }
Ref: 
function findAllSequence ( N ) { if ( N % 2 == 0 ) { return ( Math . pow ( 2 , N / 2 + 1 ) + Math . pow ( 2 , N / 2 ) - 2 ) ; } else { return ( Math . pow ( 2 , ( N + 1 ) / 2 ) + Math . pow ( 2 , ( N + 1 ) / 2 ) - 2 ) ; } }
Hyp: 
function findAllSequence ( N ) { if ( N % 2 == 0 ) { return Math . pow ( 2 , N / 2 + 1 ) + Math . pow ( 2 , N / 2 ) - 2 ; } else { return Math . pow ( 2 , ( N + 1 ) / 2 ) + Math . pow ( 2 , ( N + 1 ) / 2 ) - 2 ; } }

BLEU: 87.7
Edit Sim: 8


Src: 
int binarySearch ( int arr [ ] , int left , int right ) { if ( left <= right ) { int mid = ( left + right ) / 2 ; if ( arr [ mid - 1 ] < arr [ mid ] && arr [ mid ] > arr [ mid + 1 ] ) return mid ; if ( arr [ mid ] < arr [ mid + 1 ] ) return binarySearch ( arr , mid + 1 , right ) ; else return binarySearch ( arr , left , mid - 1 ) ; } return -1 ; }
Ref: 
function binarySearch ( arr , left , right ) { if ( left <= right ) { var mid = parseInt ( ( left + right ) / 2 ) ; if ( arr [ mid - 1 ] < arr [ mid ] && arr [ mid ] > arr [ mid + 1 ] ) return mid ; if ( arr [ mid ] < arr [ mid + 1 ] ) return binarySearch ( arr , mid + 1 , right ) ; else return binarySearch ( arr , left , mid - 1 ) ; } return - 1 ; }
Hyp: 
function binarySearch ( arr , left , right ) { if ( left <= right ) { let mid = parseInt ( ( left + right ) / 2 ) ; if ( arr [ mid - 1 ] < arr [ mid ] && arr [ mid ] > arr [ mid + 1 ] ) return mid ; if ( arr [ mid ] < arr [ mid + 1 ] ) return binarySearch ( arr , mid + 1 , right ) ; else return binarySearch ( arr , left , mid - 1 ) ; } return - 1 ; }

BLEU: 97.59
Edit Sim: 3


Src: 
bool isDvisibleBy12 ( string num ) { if ( num . length ( ) >= 3 ) { int d1 = ( int ) num [ num . length ( ) - 1 ] ; if ( d1 % 2 != 0 ) return ( 0 ) ; int d2 = ( int ) num [ num . length ( ) - 2 ] ; int sum = 0 ; for ( int i = 0 ; i < num . length ( ) ; i ++ ) sum += num [ i ] ; return ( sum % 3 == 0 && ( d2 * 10 + d1 ) % 4 == 0 ) ; } else { int number = stoi ( num ) ; return ( number % 12 == 0 ) ; } }
Ref: 
function isDvisibleBy12 ( num ) { if ( num . length >= 3 ) { let d1 = num [ num . length - 1 ] . charCodeAt ( ) ; if ( d1 % 2 != 0 ) return false ; let d2 = num [ num . length - 2 ] . charCodeAt ( ) ; let sum = 0 ; for ( let i = 0 ; i < num . length ; i ++ ) sum += num [ i ] . charCodeAt ( ) ; return ( ( sum % 3 == 0 ) && ( d2 * 10 + d1 ) % 4 == 0 ) ; } else { let number = parseInt ( num , 10 ) ; document . write ( number ) ; return ( number % 12 == 0 ) ; } }
Hyp: 
function isDvisibleBy12 ( num ) { if ( num . length >= 3 ) { let d1 = num [ num . length - 1 ] ; if ( d1 % 2 != 0 ) return ( 0 ) ; let d2 = ( let ) num [ num . length - 2 ] ; let sum = 0 ; for ( let i = 0 ; i < num . length ; i ++ ) sum += num [ i ] ; return ( sum % 3 == 0 && ( d2 * 10 + d1 ) % 4 == 0 ) ; } else { let number = parseInt ( num ) ; return ( number % 12 == 0 ) ; } }

BLEU: 75.59
Edit Sim: 103


Src: 
void printPascal ( int n ) { for ( int line = 1 ; line <= n ; line ++ ) { int C = 1 ; for ( int i = 1 ; i <= line ; i ++ ) { cout << C << " ▁ " ; C = C * ( line - i ) / i ; } cout << " STRNEWLINE " ; } }
Ref: 
function printPascal ( n ) { for ( line = 1 ; line <= n ; line ++ ) { var C = 1 ; for ( i = 1 ; i <= line ; i ++ ) { document . write ( C + " " ) ; C = C * ( line - i ) / i ; } document . write ( " " ) ; } }
Hyp: 
function printPascal ( n ) { for ( let line = 1 ; line <= n ; line ++ ) { let C = 1 ; for ( let i = 1 ; i <= line ; i ++ ) { document . write ( C + " " ) ; C = C * ( line - i ) / i ; } document . write ( " " ) ; } }

BLEU: 89.6
Edit Sim: 11


Src: 
int square ( int n ) { if ( n < 0 ) n = - n ; int res = n ; for ( int i = 1 ; i < n ; i ++ ) res += n ; return res ; }
Ref: 
function square ( n ) { if ( n < 0 ) n = - n ; let res = n ; for ( let i = 1 ; i < n ; i ++ ) res += n ; return res ; }
Hyp: 
function square ( n ) { if ( n < 0 ) n = - n ; let res = n ; for ( let i = 1 ; i < n ; i ++ ) res += n ; return res ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int number_of_tower ( int house [ ] , int range , int n ) { sort ( house , house + n ) ; int numOfTower = 0 ; int i = 0 ; while ( i < n ) { numOfTower ++ ; int loc = house [ i ] + range ; while ( i < n && house [ i ] <= loc ) i ++ ; -- i ; loc = house [ i ] + range ; while ( i < n && house [ i ] <= loc ) i ++ ; } return numOfTower ; }
Ref: 
function number_of_tower ( house , range , n ) { house . sort ( function ( a , b ) { return a - b ; } ) ; let numOfTower = 0 ; let i = 0 ; while ( i < n ) { numOfTower ++ ; let loc = house [ i ] + range ; while ( i < n && house [ i ] <= loc ) i ++ ; -- i ; loc = house [ i ] + range ; while ( i < n && house [ i ] <= loc ) i ++ ; } return numOfTower ; }
Hyp: 
function number_of_tower ( house , range , n ) { house . sort ( function ( a , b ) { return a - b } ) ; let numOfTower = 0 ; let i = 0 ; while ( i < n ) { numOfTower ++ ; let loc = house [ i ] + range ; while ( i < n && house [ i ] <= loc ) i ++ ; -- i ; loc = house [ i ] + range ; while ( i < n && house [ i ] <= loc ) i ++ ; } return numOfTower ; }

BLEU: 97.66
Edit Sim: 2


Src: 
void reArrange ( string words [ ] , int n ) { map < string , int > mp ; for ( int i = 0 ; i < n ; i ++ ) mp [ words [ i ] ] = i + 1 ; sort ( words , words + n ) ; for ( int i = 0 ; i < n ; i ++ ) cout << mp [ words [ i ] ] << " ▁ " ; }
Ref: 
function reArrange ( words , n ) { var mp = new Map ( ) ; for ( var i = 0 ; i < n ; i ++ ) mp . set ( words [ i ] , i + 1 ) ; words . sort ( ) ; for ( var i = 0 ; i < n ; i ++ ) { document . write ( mp . get ( words [ i ] ) + " " ) ; } }
Hyp: 
function reArrange ( words , n ) { var mp = new Map ( ) ; for ( var i = 0 ; i < n ; i ++ ) mp [ words [ i ] ] = i + 1 ; sort ( words , words + n ) ; for ( var i = 0 ; i < n ; i ++ ) document . write ( mp [ words [ i ] ] + " " ) ; }

BLEU: 71.55
Edit Sim: 36


Src: 
void rearrange ( int a [ ] , int size ) { int positive = 0 , negative = 1 ; while ( true ) { while ( positive < size && a [ positive ] >= 0 ) positive += 2 ; while ( negative < size && a [ negative ] <= 0 ) negative += 2 ; if ( positive < size && negative < size ) swap ( a [ positive ] , a [ negative ] ) ; else break ; } }
Ref: 
function rearrange ( a , size ) { let positive = 0 ; let negative = 1 ; let temp ; while ( true ) { while ( positive < size && a [ positive ] >= 0 ) positive += 2 ; while ( negative < size && a [ negative ] <= 0 ) negative += 2 ; if ( positive < size && negative < size ) { temp = a [ positive ] ; a [ positive ] = a [ negative ] ; a [ negative ] = temp ; } else break ; } }
Hyp: 
function rearrange ( a , size ) { let positive = 0 , negative = 1 ; while ( true ) { while ( positive < size && a [ positive ] >= 0 ) positive += 2 ; while ( negative < size && a [ negative ] <= 0 ) negative += 2 ; if ( positive < size && negative < size ) swap ( a [ positive ] , a [ negative ] ) ; else break ; } }

BLEU: 69.15
Edit Sim: 64


Src: 
int countDe ( int arr [ ] , int n ) { vector < int > v ( arr , arr + n ) ; sort ( arr , arr + n ) ; int count1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] != v [ i ] ) count1 ++ ; reverse ( arr , arr + n ) ; int count2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] != v [ i ] ) count2 ++ ; return ( min ( count1 , count2 ) ) ; }
Ref: 
function countDe ( arr , n ) { let v = [ ] ; for ( let i = 0 ; i < n ; i ++ ) v [ i ] = arr [ i ] ; arr . sort ( ) ; let count1 = 0 ; for ( let i = 0 ; i < n ; i ++ ) if ( arr [ i ] != v [ i ] ) count1 ++ ; arr . reverse ( ) ; let count2 = 0 ; for ( let i = 0 ; i < n ; i ++ ) if ( arr [ i ] != v [ i ] ) count2 ++ ; return ( Math . min ( count1 , count2 ) ) ; }
Hyp: 
function countDe ( arr , n ) { let v = arr . slice ( 0 ) ; arr . sort ( function ( a , b ) { return a - b } ) ; let count1 = 0 ; for ( let i = 0 ; i < n ; i ++ ) if ( arr [ i ] != v [ i ] ) count1 ++ ; reverse ( arr , arr + n ) ; let count2 = 0 ; for ( let i = 0 ; i < n ; i ++ ) if ( arr [ i ] != v [ i ] ) count2 ++ ; return ( Math . min ( count1 , count2 ) ) ; }

BLEU: 75.58
Edit Sim: 67


Src: 
void SectorArea ( double radius , double angle ) { if ( angle >= 360 ) cout << " Angle ▁ not ▁ possible " ; else { double sector = ( ( 22 * radius * radius ) / 7 ) * ( angle / 360 ) ; cout << sector ; } }
Ref: 
function SectorArea ( radius , angle ) { if ( angle >= 360 ) document . write ( " " ) ; else { let sector = ( ( 22 * radius * radius ) / 7 ) * ( angle / 360 ) ; document . write ( sector ) ; } }
Hyp: 
function SectorArea ( radius , angle ) { if ( angle >= 360 ) document . write ( " " + " " ) ; else { let sector = ( ( 22 * radius * radius ) / 7 ) * ( angle / 360 ) ; document . write ( sector . toFixed ( 10 ) ) ; } }

BLEU: 84.05
Edit Sim: 23


Src: 
int results ( int n , int k ) { return round ( pow ( n , ( 1.0 / pow ( 2 , k ) ) ) ) ; }
Ref: 
function results ( n , k ) { return parseInt ( Math . round ( Math . pow ( n , ( 1.0 / Math . pow ( 2.0 , k ) ) ) ) ) ; }
Hyp: 
function results ( n , k ) { return Math . round ( Math . pow ( n , ( 1.0 / Math . pow ( 2 , k ) ) ) , 10 ) ; }

BLEU: 76.44
Edit Sim: 17


Src: 
int findRepeatFirstN2 ( char * s ) { int p = -1 , i , j ; for ( i = 0 ; i < strlen ( s ) ; i ++ ) { for ( j = i + 1 ; j < strlen ( s ) ; j ++ ) { if ( s [ i ] == s [ j ] ) { p = i ; break ; } } if ( p != -1 ) break ; } return p ; }
Ref: 
function findRepeatFirstN2 ( s ) { let p = - 1 , i , j ; for ( i = 0 ; i < s . length ; i ++ ) { for ( j = i + 1 ; j < s . length ; j ++ ) { if ( s [ i ] == s [ j ] ) { p = i ; break ; } } if ( p != - 1 ) break ; } return p ; }
Hyp: 
function findRepeatFirstN2 ( s ) { let p = - 1 , i , j ; for ( i = 0 ; i < s . length ; i ++ ) { for ( j = i + 1 ; j < s . length ; j ++ ) { if ( s [ i ] == s [ j ] ) { p = i ; break ; } } if ( p != - 1 ) break ; } return p ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int missingNumber ( int arr1 [ ] , int arr2 [ ] , int n ) { int mnum = 0 ; for ( int i = 0 ; i < n ; i ++ ) mnum = mnum ^ arr1 [ i ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) mnum = mnum ^ arr2 [ i ] ; return mnum ; }
Ref: 
function missingNumber ( arr1 , arr2 , n ) { let mnum = 0 ; for ( let i = 0 ; i < n ; i ++ ) mnum = mnum ^ arr1 [ i ] ; for ( let i = 0 ; i < n - 1 ; i ++ ) mnum = mnum ^ arr2 [ i ] ; return mnum ; }
Hyp: 
function missingNumber ( arr1 , arr2 , n ) { let mnum = 0 ; for ( let i = 0 ; i < n ; i ++ ) mnum = mnum ^ arr1 [ i ] ; for ( let i = 0 ; i < n - 1 ; i ++ ) mnum = mnum ^ arr2 [ i ] ; return mnum ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int countSequences ( int arr [ ] , int n ) { int count = 1 ; sort ( arr , arr + n ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] + 1 != arr [ i + 1 ] ) count ++ ; return count ; }
Ref: 
function countSequences ( arr , n ) { let count = 1 ; arr . sort ( function ( a , b ) { return a - b } ) ; for ( let i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] + 1 != arr [ i + 1 ] ) count ++ ; return count ; }
Hyp: 
function countSequences ( arr , n ) { let count = 1 ; arr . sort ( ( a , b ) => a - b ) ; for ( let i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] + 1 != arr [ i + 1 ] ) count ++ ; return count ; }

BLEU: 87.49
Edit Sim: 19


Src: 
int oddTriangularNumber ( int N ) { return ( N * ( ( 2 * N ) - 1 ) ) ; }
Ref: 
function oddTriangularNumber ( N ) { return ( N * ( ( 2 * N ) - 1 ) ) ; }
Hyp: 
function oddTriangularNumber ( N ) { return ( N * ( ( 2 * N ) - 1 ) ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int numberOfDistinct ( int n ) { int ans = 0 ; for ( int i = 1 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { ans ++ ; if ( ( n / i ) != i ) ans ++ ; } } return ans ; }
Ref: 
function numberOfDistinct ( n ) { var ans = 0 ; for ( i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { ans ++ ; if ( ( n / i ) != i ) ans ++ ; } } return ans ; }
Hyp: 
function numberOfDistinct ( n ) { let ans = 0 ; for ( let i = 1 ; i <= parseInt ( Math . sqrt ( n ) , 10 ) ; i ++ ) { if ( n % i == 0 ) { ans ++ ; if ( ( n / i ) != i ) ans ++ ; } } return ans ; }

BLEU: 81.2
Edit Sim: 25


Src: 
unsigned countBits ( unsigned int number ) { return ( int ) log2 ( number ) + 1 ; }
Ref: 
function countBits ( number ) { return Math . floor ( Math . log2 ( number ) + 1 ) ; }
Hyp: 
function countBits ( number ) { return parseInt ( Math . log2 ( number ) + 1 ) ; }

BLEU: 78.32
Edit Sim: 11


Src: 
int countNumbers ( int n ) { int k = 0 ; while ( n > 0 ) { if ( ( n & 1 ) == 0 ) count += pow ( 2 , k ) ; k += 1 ; n >>= 1 ; } return count ; }
Ref: 
function countNumbers ( n ) { let k = 0 ; let count = 0 ; while ( n > 0 ) { if ( ( n & 1 ) == 0 ) count += ( Math . pow ( 2 , k ) ) ; k += 1 ; n >>= 1 ; } return count ; }
Hyp: 
function countNumbers ( n ) { let k = 0 ; while ( n > 0 ) { if ( ( n & 1 ) == 0 ) count += Math . pow ( 2 , k ) ; k += 1 ; n >>= 1 ; } return count ; }

BLEU: 83.45
Edit Sim: 20


Src: 
char first ( string str ) { for ( int i = 0 ; i < str . length ( ) ; i ++ ) if ( isupper ( str [ i ] ) ) return str [ i ] ; return 0 ; }
Ref: 
function first ( str ) { for ( var i = 0 ; i < str . length ; i ++ ) if ( str [ i ] === str [ i ] . toUpperCase ( ) ) return str [ i ] ; return 0 ; } var str = " " ; var res = first ( str ) ; if ( res == 0 ) document . write ( " " ) ; else { document . write ( res ) ; document . write ( " " ) ; }
Hyp: 
function first ( str ) { for ( i = 0 ; i < str . length ; i ++ ) if ( isupper ( str [ i ] ) ) return str [ i ] ; return 0 ; }

BLEU: 23.54
Edit Sim: 180


Src: 
void center ( int x1 , int x2 , int y1 , int y2 ) { cout << ( float ) ( x1 + x2 ) / 2 << " , ▁ " << ( float ) ( y1 + y2 ) / 2 ; }
Ref: 
function center ( x1 , x2 , y1 , y2 ) { document . write ( ( x1 + x2 ) / 2 + " " + ( y1 + y2 ) / 2 ) ; }
Hyp: 
function center ( x1 , x2 , y1 , y2 ) { document . write ( ( float ) ( x1 + x2 ) / 2 + " " + ( float ) ( y1 + y2 ) / 2 ) ; }

BLEU: 82.12
Edit Sim: 20


Src: 
int evenbinomialCoeffSum ( int n ) { return ( 1 << ( n - 1 ) ) ; }
Ref: 
function evenbinomialCoeffSum ( n ) { return ( 1 << ( n - 1 ) ) ; }
Hyp: 
function evenbinomialCoeffSum ( n ) { return ( 1 << ( n - 1 ) ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
ll multiply ( ll x , ll n ) { return x << n ; }
Ref: 
function multiply ( x , n ) { return x << n ; }
Hyp: 
function multiply ( x , n ) { return ( x << n ) ; }

BLEU: 66.75
Edit Sim: 4


Src: 
int Regions ( int Vertices , int Edges ) { int R = Edges + 2 - Vertices ; return R ; }
Ref: 
function Regions ( Vertices , Edges ) { var R = Edges + 2 - Vertices ; return R ; }
Hyp: 
function Regions ( Vertices , Edges ) { let R = Edges + 2 - Vertices ; return R ; }

BLEU: 87.25
Edit Sim: 3


Src: 
int calculate ( int n , int power ) { int sum = 0 ; int bp = ( int ) pow ( n , power ) ; while ( bp != 0 ) { int d = bp % 10 ; sum += d ; bp /= 10 ; } return sum ; }
Ref: 
function calculate ( n , power ) { sum = 0 ; bp = Math . pow ( n , power ) ; while ( bp != 0 ) { d = bp % 10 ; sum = sum + d ; bp = Math . floor ( bp / 10 ) ; } return sum ; }
Hyp: 
function calculate ( n , power ) { let sum = 0 ; let bp = parseInt ( Math . pow ( n , power ) ) ; while ( bp != 0 ) { let d = bp % 10 ; sum += d ; bp = Math . floor ( bp / 10 ) ; } return sum ; }

BLEU: 74.71
Edit Sim: 32


Src: 
int minimal ( int a [ ] , int n ) { int lo = 0 , hi = n - 1 ; while ( lo < hi ) { int mid = ( lo + hi ) >> 1 ; if ( a [ mid ] < a [ mid + 1 ] ) { hi = mid ; } else { lo = mid + 1 ; } } return lo ; }
Ref: 
function minimal ( a , n ) { let lo = 0 , hi = n - 1 ; while ( lo < hi ) { let mid = ( lo + hi ) >> 1 ; if ( a [ mid ] < a [ mid + 1 ] ) { hi = mid ; } else { lo = mid + 1 ; } } return lo ; }
Hyp: 
function minimal ( a , n ) { let lo = 0 , hi = n - 1 ; while ( lo < hi ) { let mid = ( lo + hi ) >> 1 ; if ( a [ mid ] < a [ mid + 1 ] ) { hi = mid ; } else { lo = mid + 1 ; } } return lo ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int fifthPowerSum ( int n ) { return ( ( 2 * n * n * n * n * n * n ) + ( 6 * n * n * n * n * n ) + ( 5 * n * n * n * n ) - ( n * n ) ) / 12 ; }
Ref: 
function fifthPowerSum ( n ) { return ( ( 2 * n * n * n * n * n * n ) + ( 6 * n * n * n * n * n ) + ( 5 * n * n * n * n ) - ( n * n ) ) / 12 ; }
Hyp: 
function fifthPowerSum ( n ) { return ( ( 2 * n * n * n * n * n ) + ( 6 * n * n * n * n ) + ( 5 * n * n * n * n ) - ( n * n ) ) / 12 ; }

BLEU: 93.11
Edit Sim: 8


Src: 
void printTwoOdd ( int arr [ ] , int size ) { int xor2 = arr [ 0 ] ; int set_bit_no ; int i ; int n = size - 2 ; int x = 0 , y = 0 ; for ( i = 1 ; i < size ; i ++ ) xor2 = xor2 ^ arr [ i ] ; set_bit_no = xor2 & ~ ( xor2 - 1 ) ; for ( i = 0 ; i < size ; i ++ ) { if ( arr [ i ] & set_bit_no ) x = x ^ arr [ i ] ; else y = y ^ arr [ i ] ; } cout << " The ▁ two ▁ ODD ▁ elements ▁ are ▁ " << x << " ▁ & ▁ " << y ; }
Ref: 
function printTwoOdd ( arr , size ) { let xor2 = arr [ 0 ] ; let set_bit_no ; let i ; int n = size - 2 ; let x = 0 , y = 0 ; for ( i = 1 ; i < size ; i ++ ) xor2 = xor2 ^ arr [ i ] ; set_bit_no = xor2 & ~ ( xor2 - 1 ) ; for ( i = 0 ; i < size ; i ++ ) { if ( ( arr [ i ] & set_bit_no ) > 0 ) x = x ^ arr [ i ] ; else y = y ^ arr [ i ] ; } document . write ( " " + x + " " + y + " " ) ; }
Hyp: 
function printTwoOdd ( arr , size ) { let xor2 = arr [ 0 ] ; let set_bit_no ; let i ; let n = size - 2 ; let x = 0 , y = 0 ; for ( i = 1 ; i < size ; i ++ ) xor2 = xor2 ^ arr [ i ] ; set_bit_no = xor2 & ~ ( xor2 - 1 ) ; for ( i = 0 ; i < size ; i ++ ) { if ( ( arr [ i ] & set_bit_no ) > 0 ) x = x ^ arr [ i ] ; else y = y ^ arr [ i ] ; } document . write ( " " + x + " " + y + " " + " " ) ; }

BLEU: 96.05
Edit Sim: 8


Src: 
ll minSum ( int arr [ ] , int n , int x ) { ll sum = 0 ; int largestDivisible = -1 , minimum = arr [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( arr [ i ] % x == 0 && largestDivisible < arr [ i ] ) largestDivisible = arr [ i ] ; if ( arr [ i ] < minimum ) minimum = arr [ i ] ; } if ( largestDivisible == -1 ) return sum ; ll sumAfterOperation = sum - minimum - largestDivisible + ( x * minimum ) + ( largestDivisible / x ) ; return min ( sum , sumAfterOperation ) ; }
Ref: 
function minSum ( arr , n , x ) { var sum = 0 ; var largestDivisible = - 1 , minimum = arr [ 0 ] ; for ( i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( arr [ i ] % x == 0 && largestDivisible < arr [ i ] ) largestDivisible = arr [ i ] ; if ( arr [ i ] < minimum ) minimum = arr [ i ] ; } if ( largestDivisible == - 1 ) return sum ; var sumAfterOperation = sum - minimum - largestDivisible + ( x * minimum ) + ( largestDivisible / x ) ; return Math . min ( sum , sumAfterOperation ) ; }
Hyp: 
function minSum ( arr , n , x ) { let sum = 0 ; let largestDivisible = - 1 , minimum = arr [ 0 ] ; for ( let i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( arr [ i ] % x == 0 && largestDivisible < arr [ i ] ) largestDivisible = arr [ i ] ; if ( arr [ i ] < minimum ) minimum = arr [ i ] ; } if ( largestDivisible == - 1 ) return sum ; let sumAfterOperation = sum - minimum - largestDivisible + ( x * minimum ) + ( largestDivisible / x ) ; return Math . min ( sum , sumAfterOperation ) ; }

BLEU: 92.42
Edit Sim: 13


Src: 
int sum_of_series ( int n ) { int result = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i % 2 == 0 ) result = result - pow ( i , 2 ) ; else result = result + pow ( i , 2 ) ; } return result ; }
Ref: 
function sum_of_series ( n ) { var result = 0 ; for ( i = 1 ; i <= n ; i ++ ) { if ( i % 2 == 0 ) result = result - parseInt ( Math . pow ( i , 2 ) ) ; else result = result + parseInt ( Math . pow ( i , 2 ) ) ; } return result ; }
Hyp: 
function sum_of_series ( n ) { let result = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { if ( i % 2 == 0 ) result = result - Math . pow ( i , 2 ) ; else result = result + Math . pow ( i , 2 ) ; } return result ; }

BLEU: 78.6
Edit Sim: 33


Src: 
int FirstRepeated ( string str ) { int checker = 0 ; for ( int i = 0 ; i < str . length ( ) ; ++ i ) { int val = ( str [ i ] - ' a ' ) ; if ( ( checker & ( 1 << val ) ) > 0 ) return i ; checker |= ( 1 << val ) ; } return -1 ; }
Ref: 
function FirstRepeated ( str ) { let checker = 0 ; for ( let i = 0 ; i < str . length ; ++ i ) { let val = ( str [ i ] - ' ' ) ; if ( ( checker & ( 1 << val ) ) > 0 ) return i ; checker |= ( 1 << val ) ; } return - 1 ; }
Hyp: 
function FirstRepeated ( str ) { var checker = 0 ; for ( var i = 0 ; i < str . length ; ++ i ) { var val = ( str [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ) ; if ( ( checker & ( 1 << val ) ) > 0 ) return i ; checker |= ( 1 << val ) ; } return - 1 ; }

BLEU: 76.27
Edit Sim: 43


Src: 
void findMaxGuests ( int arrl [ ] , int exit [ ] , int n ) { sort ( arrl , arrl + n ) ; sort ( exit , exit + n ) ; int guests_in = 1 , max_guests = 1 , time = arrl [ 0 ] ; int i = 1 , j = 0 ; while ( i < n && j < n ) { if ( arrl [ i ] <= exit [ j ] ) { guests_in ++ ; if ( guests_in > max_guests ) { max_guests = guests_in ; time = arrl [ i ] ; } i ++ ; } else { guests_in -- ; j ++ ; } } cout << " Maximum ▁ Number ▁ of ▁ Guests ▁ = ▁ " << max_guests << " ▁ at ▁ time ▁ " << time ; }
Ref: 
function findMaxGuests ( arrl , exit , n ) { arrl . sort ( function ( a , b ) { return a - b } ) ; exit . sort ( function ( a , b ) { return a - b } ) ; let guests_in = 1 , max_guests = 1 , time = arrl [ 0 ] ; let i = 1 , j = 0 ; while ( i < n && j < n ) { if ( arrl [ i ] <= exit [ j ] ) { guests_in ++ ; if ( guests_in > max_guests ) { max_guests = guests_in ; time = arrl [ i ] ; } i ++ ; } else { guests_in -- ; j ++ ; } } document . write ( " " + max_guests + " " + time ) ; }
Hyp: 
function findMaxGuests ( arrl , exit , n ) { arrl . sort ( function ( a , b ) { return a - b } ) ; let guests_in = 1 , max_guests = 1 , time = arrl [ 0 ] ; let i = 1 , j = 0 ; while ( i < n && j < n ) { if ( arrl [ i ] <= exit [ j ] ) { guests_in ++ ; if ( guests_in > max_guests ) { max_guests = guests_in ; time = arrl [ i ] ; } i ++ ; } else { guests_in -- ; j ++ ; } } document . write ( " " + max_guests + " " + time ) ; }

BLEU: 86.98
Edit Sim: 54


Src: 
int numberofways ( int n , int m ) { int dp [ n + 2 ] [ n + 2 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; dp [ 0 ] [ n + 1 ] = 1 ; for ( int k = n ; k >= m ; k -- ) { for ( int i = 0 ; i <= n ; i ++ ) { dp [ i ] [ k ] = dp [ i ] [ k + 1 ] ; if ( i - k >= 0 ) dp [ i ] [ k ] = ( dp [ i ] [ k ] + dp [ i - k ] [ k ] ) ; } } return dp [ n ] [ m ] ; }
Ref: 
function numberofways ( n , m ) { let dp = new Array ( n + 2 ) ; for ( let i = 0 ; i < dp . length ; i ++ ) { dp [ i ] = new Array ( n + 2 ) ; for ( let j = 0 ; j < dp [ i ] . length ; j ++ ) { dp [ i ] [ j ] = 0 ; } } dp [ 0 ] [ n + 1 ] = 1 ; for ( let k = n ; k >= m ; k -- ) { for ( let i = 0 ; i <= n ; i ++ ) { dp [ i ] [ k ] = dp [ i ] [ k + 1 ] ; if ( i - k >= 0 ) dp [ i ] [ k ] = ( dp [ i ] [ k ] + dp [ i - k ] [ k ] ) ; } } return dp [ n ] [ m ] ; }
Hyp: 
function numberofways ( n , m ) { let dp = new Array ( n + 2 ) ; for ( let i = 0 ; i < n + 2 ; i ++ ) { dp [ i ] = new Array ( n + 2 ) ; for ( let k = n ; k >= m ; k -- ) { for ( let i = 0 ; i <= n ; i ++ ) { dp [ i ] [ k ] = dp [ i ] [ k + 1 ] ; if ( i - k >= 0 ) dp [ i ] [ k ] = ( dp [ i ] [ k ] + dp [ i - k ] [ k ] ) ; } } return dp [ n ] [ m ] ; }

BLEU: 71.9
Edit Sim: 110


Src: 
int series ( int n ) { return ( 8 * n * n ) + 1 ; }
Ref: 
function series ( n ) { return ( 8 * n * n ) + 1 ; }
Hyp: 
function series ( n ) { return ( 8 * n * n ) + 1 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int find ( double p ) { return ceil ( sqrt ( 2 * 365 * log ( 1 / ( 1 - p ) ) ) ) ; }
Ref: 
function find ( p ) { return Math . ceil ( Math . sqrt ( 2 * 365 * Math . log ( 1 / ( 1 - p ) ) ) ) ; }
Hyp: 
function find ( p ) { return Math . ceil ( Math . sqrt ( 2 * 365 * Math . log ( 1 / ( 1 - p ) ) ) ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
ll CalculateMax ( ll arr [ ] , int n ) { sort ( arr , arr + n ) ; int min_sum = arr [ 0 ] + arr [ 1 ] ; int max_sum = arr [ n - 1 ] + arr [ n - 2 ] ; return abs ( max_sum - min_sum ) ; }
Ref: 
function CalculateMax ( arr , n ) { arr . sort ( function ( a , b ) { return a - b } ) ; let min_sum = arr [ 0 ] + arr [ 1 ] ; let max_sum = arr [ n - 1 ] + arr [ n - 2 ] ; return ( Math . abs ( max_sum - min_sum ) ) ; }
Hyp: 
function CalculateMax ( arr , n ) { arr . sort ( ( a , b ) => a - b ) ; let min_sum = arr [ 0 ] + arr [ 1 ] ; let max_sum = arr [ n - 1 ] + arr [ n - 2 ] ; return Math . abs ( max_sum - min_sum ) ; }

BLEU: 80.67
Edit Sim: 23


Src: 
string updateString ( string S , string A , string B ) { int l = A . length ( ) ; for ( int i = 0 ; i + l <= S . length ( ) ; i ++ ) { string curr = S . substr ( i , i + l ) ; if ( curr == A ) { string new_string = " " ; new_string += S . substr ( 0 , i ) + B + S . substr ( i + l , S . length ( ) ) ; S = new_string ; i += l - 1 ; } else { string new_string = " " ; new_string += S . substr ( 0 , i ) + A + S . substr ( i + l , S . length ( ) ) ; S = new_string ; i += l - 1 ; } } return S ; }
Ref: 
function updateString ( S , A , B ) { let l = A . length ; for ( let i = 0 ; i + l <= S . length ; i ++ ) { let curr = S . substring ( i , i + l ) ; if ( curr == A ) { let new_string = S . substring ( 0 , i ) + B + S . substring ( i + l ) ; S = new_string ; i += l - 1 ; } else { let new_string = S . substring ( 0 , i ) + A + S . substring ( i + l ) ; S = new_string ; i += l - 1 ; } } return S ; }
Hyp: 
function updateString ( S , A , B ) { let l = A . length ; let arr = S . split ( " " ) ; for ( let i = 0 ; i + l <= S . length ; i ++ ) { let curr = S . substr ( i , i + l ) ; if ( curr == A ) { let new_string = " " ; new_string += S . substr ( 0 , i ) + B + S . substr ( i + l , S . length ( ) ) ; S = new_string ; i += l - 1 ; } else { let new_string = " " ; new_string += S . substr ( 0 , i ) + A + S . substr ( i + l , S . length ( ) ) ; S = new_string ; i += l - 1 ; } } return S ; }

BLEU: 68.5
Edit Sim: 115


Src: 
int MinimumMail ( int n , int k , int x ) { ll m = ( n - 1 ) + ( ll ) ceil ( ( n - 1 ) * 1.0 / x ) * ( n - 1 ) + ( ll ) ceil ( n * 1.0 / x ) * ( k - n ) ; return m ; }
Ref: 
function MinimumMail ( n , k , x ) { let m = ( n - 1 ) + Math . ceil ( ( n - 1 ) * 1.0 / x ) * ( n - 1 ) + Math . ceil ( n * 1.0 / x ) * ( k - n ) ; return m ; }
Hyp: 
function MinimumMail ( n , k , x ) { let m = ( n - 1 ) + ( ll ) Math . ceil ( ( n - 1 ) * 1.0 / x ) * ( n - 1 ) + ( ll ) Math . ceil ( n * 1.0 / x ) * ( k - n ) ; return m ; }

BLEU: 86.33
Edit Sim: 14


Src: 
int countPairs ( int N ) { int count = 0 ; for ( int i = 1 ; i <= cbrt ( N ) ; i ++ ) { int cb = i * i * i ; int diff = N - cb ; int cbrtDiff = cbrt ( diff ) ; if ( cbrtDiff * cbrtDiff * cbrtDiff == diff ) count ++ ; } return count ; }
Ref: 
function countPairs ( N ) { let count = 0 ; for ( let i = 1 ; i <= parseInt ( Math . pow ( N , ( 1.0 / 3.0 ) ) , 10 ) ; i ++ ) { let cb = i * i * i ; let diff = N - cb ; let cbrtDiff = parseInt ( Math . pow ( diff , ( 1.0 / 3.0 ) ) , 10 ) ; if ( cbrtDiff * cbrtDiff * cbrtDiff == diff ) count ++ ; } return count ; }
Hyp: 
function countPairs ( N ) { let count = 0 ; for ( let i = 1 ; i <= cbrt ( N ) ; i ++ ) { let cb = i * i * i ; let diff = N - cb ; let cbrtDiff = cbrt ( diff ) ; if ( cbrtDiff * cbrtDiff * cbrtDiff == diff ) count ++ ; } return count ; }

BLEU: 61.78
Edit Sim: 84


Src: 
void pendulumArrangement ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int op [ n ] ; int mid = ( n - 1 ) / 2 ; int j = 1 , i = 1 ; op [ mid ] = arr [ 0 ] ; for ( i = 1 ; i <= mid ; i ++ ) { op [ mid + i ] = arr [ j ++ ] ; op [ mid - i ] = arr [ j ++ ] ; } if ( n % 2 == 0 ) op [ mid + i ] = arr [ j ] ; cout << " Pendulum ▁ arrangement : " << endl ; for ( i = 0 ; i < n ; i ++ ) cout << op [ i ] << " ▁ " ; cout << endl ; }
Ref: 
function pendulumArrangement ( arr , n ) { arr . sort ( function ( a , b ) { return a - b ; } ) ; var op = [ ... Array ( n ) ] ; var mid = parseInt ( ( n - 1 ) / 2 ) ; var j = 1 , i = 1 ; op [ mid ] = arr [ 0 ] ; for ( i = 1 ; i <= mid ; i ++ ) { op [ mid + i ] = arr [ j ++ ] ; op [ mid - i ] = arr [ j ++ ] ; } if ( n % 2 == 0 ) op [ mid + i ] = arr [ j ] ; document . write ( " " ) ; for ( i = 0 ; i < n ; i ++ ) document . write ( op [ i ] + " " ) ; document . write ( " " ) ; }
Hyp: 
function pendulumArrangement ( arr , n ) { arr . sort ( function ( a , b ) { return a - b } ) ; let op = new Array ( n ) ; let mid = parseInt ( ( n - 1 ) / 2 ) ; let j = 1 , i = 1 ; op [ mid ] = arr [ 0 ] ; for ( i = 1 ; i <= mid ; i ++ ) { op [ mid + i ] = arr [ j ++ ] ; op [ mid - i ] = arr [ j ++ ] ; } if ( n % 2 == 0 ) op [ mid + i ] = arr [ j ] ; document . write ( " " + op [ i ] + " " ) ; document . write ( " " ) ; }

BLEU: 79.03
Edit Sim: 68


Src: 
int countDigit ( int n ) { int temp = n , count = 0 ; while ( temp != 0 ) { int d = temp % 10 ; temp /= 10 ; if ( d > 0 && n % d == 0 ) count ++ ; } return count ; }
Ref: 
function countDigit ( n ) { var temp = n , count = 0 ; while ( temp != 0 ) { var d = temp % 10 ; temp /= 10 ; if ( d > 0 && n % d == 0 ) count ++ ; } return count ; }
Hyp: 
function countDigit ( n ) { let temp = n ; let count = 0 ; while ( temp != 0 ) { let d = temp % 10 ; temp = parseInt ( temp / 10 ) ; if ( d > 0 && n % d == 0 ) count ++ ; } return count ; }

BLEU: 70.66
Edit Sim: 32


Src: 
int sum ( int n ) { return n * ( n + 1 ) * ( n + 2 ) / 3 ; }
Ref: 
function sum ( n ) { return n * ( n + 1 ) * ( n + 2 ) / 3 ; }
Hyp: 
function sum ( n ) { return n * ( n + 1 ) * ( n + 2 ) / 3 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int maxLength ( char s [ ] , int n ) { int dp [ n ] [ n ] ; memset ( dp , 0 , sizeof ( dp ) ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) if ( s [ i ] == ' ( ' && s [ i + 1 ] == ' ) ' ) dp [ i ] [ i + 1 ] = 2 ; for ( int l = 2 ; l < n ; l ++ ) { for ( int i = 0 , j = l ; j < n ; i ++ , j ++ ) { if ( s [ i ] == ' ( ' && s [ j ] == ' ) ' ) dp [ i ] [ j ] = 2 + dp [ i + 1 ] [ j - 1 ] ; for ( int k = i ; k < j ; k ++ ) dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i ] [ k ] + dp [ k + 1 ] [ j ] ) ; } } return dp [ 0 ] [ n - 1 ] ; }
Ref: 
function maxLength ( s , n ) { let dp = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { dp [ i ] = new Array ( n ) ; for ( let j = 0 ; j < n ; j ++ ) { dp [ i ] [ j ] = 0 ; } } for ( let i = 0 ; i < n - 1 ; i ++ ) if ( s [ i ] == ' ' && s [ i + 1 ] == ' ' ) dp [ i ] [ i + 1 ] = 2 ; for ( let l = 2 ; l < n ; l ++ ) { for ( let i = 0 , j = l ; j < n ; i ++ , j ++ ) { if ( s [ i ] == ' ' && s [ j ] == ' ' ) dp [ i ] [ j ] = 2 + dp [ i + 1 ] [ j - 1 ] ; for ( let k = i ; k < j ; k ++ ) dp [ i ] [ j ] = Math . max ( dp [ i ] [ j ] , dp [ i ] [ k ] + dp [ k + 1 ] [ j ] ) ; } } return dp [ 0 ] [ n - 1 ] ; }
Hyp: 
function maxLength ( s , n ) { let dp = new Array ( n ) ; for ( let i = 0 ; i < n - 1 ; i ++ ) { dp [ i ] = new Array ( n ) ; for ( let j = 0 ; j < n ; j ++ ) { if ( s [ i ] == ' ' && s [ j ] == ' ' ) dp [ i ] [ j ] = 2 + dp [ i + 1 ] [ j - 1 ] ; for ( let k = i ; k < j ; k ++ ) dp [ i ] [ j ] = Math . max ( dp [ i ] [ j ] , dp [ i ] [ k ] + dp [ k + 1 ] [ j ] ) ; } } return dp [ 0 ] [ n - 1 ] ; }

BLEU: 56.62
Edit Sim: 220


Src: 
int countRotations ( int arr [ ] , int low , int high ) { if ( high < low ) return 0 ; if ( high == low ) return low ; int mid = low + ( high - low ) / 2 ; if ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) return ( mid + 1 ) ; if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) return mid ; if ( arr [ high ] > arr [ mid ] ) return countRotations ( arr , low , mid - 1 ) ; return countRotations ( arr , mid + 1 , high ) ; }
Ref: 
function countRotations ( arr , low , high ) { if ( high < low ) return 0 ; if ( high == low ) return low ; let mid = Math . floor ( low + ( high - low ) / 2 ) ; if ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) return ( mid + 1 ) ; if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) return mid ; if ( arr [ high ] > arr [ mid ] ) return countRotations ( arr , low , mid - 1 ) ; return countRotations ( arr , mid + 1 , high ) ; }
Hyp: 
function countRotations ( arr , low , high ) { if ( high < low ) return 0 ; if ( high == low ) return low ; let mid = low + ( high - low ) / 2 ; if ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) return ( mid + 1 ) ; if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) return mid ; if ( arr [ high ] > arr [ mid ] ) return countRotations ( arr , low , mid - 1 ) ; return countRotations ( arr , mid + 1 , high ) ; }

BLEU: 93.68
Edit Sim: 17


Src: 
int findKthGoodNo ( long long int n ) { int lastDig = n % 10 ; if ( lastDig >= 0 && lastDig <= 4 ) return n << 1 ; else return ( n << 1 ) + 1 ; }
Ref: 
function findKthGoodNo ( n ) { let lastDig = n % 10 ; if ( lastDig >= 0 && lastDig <= 4 ) return n << 1 ; else return ( n << 1 ) + 1 ; }
Hyp: 
function findKthGoodNo ( n ) { let lastDig = n % 10 ; if ( lastDig >= 0 && lastDig <= 4 ) return n << 1 ; else return ( n << 1 ) + 1 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int countBT ( int h ) { long long int dp [ h + 1 ] ; dp [ 0 ] = dp [ 1 ] = 1 ; for ( int i = 2 ; i <= h ; i ++ ) { dp [ i ] = ( dp [ i - 1 ] * ( ( 2 * dp [ i - 2 ] ) % mod + dp [ i - 1 ] ) % mod ) % mod ; } return dp [ h ] ; }
Ref: 
function countBT ( h ) { let dp = new Array ( h + 1 ) ; dp . fill ( 0 ) ; dp [ 0 ] = 1 ; dp [ 1 ] = 1 ; for ( let i = 2 ; i <= h ; ++ i ) dp [ i ] = ( dp [ i - 1 ] * ( ( 2 * dp [ i - 2 ] ) % MOD + dp [ i - 1 ] ) % MOD ) % MOD ; return dp [ h ] ; }
Hyp: 
function countBT ( h ) { let dp = new Array ( h + 1 ) ; dp [ 0 ] = dp [ 1 ] = 1 ; for ( let i = 2 ; i <= h ; i ++ ) { dp [ i ] = ( dp [ i - 1 ] * ( ( 2 * dp [ i - 2 ] ) % mod + dp [ i - 1 ] ) % mod ) ; } return dp [ h ] ; }

BLEU: 76.48
Edit Sim: 38


Src: 
bool pythagorean_quadruple ( int a , int b , int c , int d ) { int sum = a * a + b * b + c * c ; if ( d * d == sum ) return true ; else return false ; }
Ref: 
function pythagorean_quadruple ( a , b , c , d ) { let sum = a * a + b * b + c * c ; if ( d * d == sum ) return true ; else return false ; }
Hyp: 
function pythagorean_quadruple ( a , b , c , d ) { let sum = a * a + b * b + c * c ; if ( d * d == sum ) return true ; else return false ; }

BLEU: 100.0
Edit Sim: 0


Src: 
void search ( string pat , string txt ) { int M = pat . size ( ) ; int N = txt . size ( ) ; int i = 0 ; while ( i <= N - M ) { int j ; for ( j = 0 ; j < M ; j ++ ) if ( txt [ i + j ] != pat [ j ] ) break ; { cout << " Pattern ▁ found ▁ at ▁ index ▁ " << i << endl ; i = i + M ; } else if ( j == 0 ) i = i + 1 ; else i = i + j ; } }
Ref: 
function search ( pat , txt ) { let M = pat . length ; let N = txt . length ; let i = 0 ; while ( i <= N - M ) { let j ; for ( j = 0 ; j < M ; j ++ ) if ( txt [ i + j ] != pat [ j ] ) break ; if ( j == M ) { document . write ( " " + i + " " ) ; i = i + M ; } else if ( j == 0 ) i = i + 1 ; else i = i + j ; } }
Hyp: 
function search ( pat , txt ) { let M = pat . length ; let N = txt . length ; let i = 0 ; while ( i <= N - M ) { let j ; for ( j = 0 ; j < M ; j ++ ) if ( txt [ i + j ] != pat [ j ] ) break ; { document . write ( " " + i + " " ) ; i = i + M ; } else if ( j == 0 ) i = i + 1 ; else i = i + j ; } }

BLEU: 93.44
Edit Sim: 14


Src: 
int countChar ( string str ) { int n = str . length ( ) ; if ( n <= 2 ) return n ; int count = 2 ; for ( int i = 1 ; i < n - 1 ; i ++ ) if ( str [ i - 1 ] == str [ i + 1 ] ) count ++ ; return count ; }
Ref: 
function countChar ( str ) { var n = str . length ; if ( n <= 2 ) return n ; var count = 2 ; for ( var i = 1 ; i < n - 1 ; i ++ ) if ( str [ i - 1 ] == str [ i + 1 ] ) count ++ ; return count ; }
Hyp: 
function countChar ( str ) { let n = str . length ; if ( n <= 2 ) return n ; let count = 2 ; for ( let i = 1 ; i < n - 1 ; i ++ ) if ( str [ i - 1 ] == str [ i + 1 ] ) count ++ ; return count ; }

BLEU: 88.3
Edit Sim: 9


Src: 
int calculateLeaps ( int n ) { if ( n == 0 n == 1 ) { return 1 ; } else { int leaps = 0 ; for ( int i = 0 ; i < n ; i ++ ) leaps += calculateLeaps ( i ) ; return leaps ; } }
Ref: 
function calculateLeaps ( n ) { if ( n == 0 n == 1 ) { return 1 ; } else { let leaps = 0 ; for ( let i = 0 ; i < n ; i ++ ) leaps += calculateLeaps ( i ) ; return leaps ; } }
Hyp: 
function calculateLeaps ( n ) { if ( n == 0 n == 1 ) { return 1 ; } else { let leaps = 0 ; for ( let i = 0 ; i < n ; i ++ ) leaps += calculateLeaps ( i ) ; return leaps ; } }

BLEU: 100.0
Edit Sim: 0


Src: 
int minCost ( int A [ ] , int n ) { int cost = 0 ; sort ( A , A + n ) ; int K = A [ n / 2 ] ; for ( int i = 0 ; i < n ; ++ i ) cost += abs ( A [ i ] - K ) ; if ( n % 2 == 0 ) { int tempCost = 0 ; K = A [ ( n / 2 ) - 1 ] ; for ( int i = 0 ; i < n ; ++ i ) tempCost += abs ( A [ i ] - K ) ; cost = min ( cost , tempCost ) ; } return cost ; }
Ref: 
function minCost ( A , n ) { var cost = 0 ; A . sort ( ) ; var K = A [ parseInt ( n / 2 ) ] ; var i ; for ( i = 0 ; i < n ; ++ i ) cost += Math . abs ( A [ i ] - K ) ; if ( n % 2 == 0 ) { var tempCost = 0 ; K = A [ parseInt ( n / 2 ) - 1 ] ; for ( i = 0 ; i < n ; ++ i ) tempCost += Math . abs ( A [ i ] - K ) ; cost = Math . min ( cost , tempCost ) ; } return cost ; }
Hyp: 
function minCost ( A , n ) { let cost = 0 ; A . sort ( ( a , b ) => a - b ) ; let K = A [ parseInt ( n / 2 ) ] ; for ( let i = 0 ; i < n ; ++ i ) cost += Math . abs ( A [ i ] - K ) ; if ( n % 2 == 0 ) { let tempCost = 0 ; K = A [ parseInt ( ( n / 2 ) - 1 ] ; for ( let i = 0 ; i < n ; ++ i ) tempCost += Math . abs ( A [ i ] - K ) ; cost = Math . min ( cost , tempCost ) ; } return cost ; }

BLEU: 81.91
Edit Sim: 44


Src: 
int LongestSubarray ( int arr [ ] , int n , int k ) { int count = 1 ; int max_length = 1 ; int prev_mod = arr [ 0 ] % k ; for ( int i = 1 ; i < n ; i ++ ) { int curr_mod = arr [ i ] % k ; if ( curr_mod == prev_mod ) { count ++ ; } else { max_length = max ( max_length , count ) ; count = 1 ; prev_mod = curr_mod ; } } return max ( max_length , count ) ; }
Ref: 
function LongestSubarray ( arr , n , k ) { let count = 1 ; let max_length = 1 ; let prev_mod = arr [ 0 ] % k ; for ( let i = 1 ; i < n ; i ++ ) { let curr_mod = arr [ i ] % k ; if ( curr_mod == prev_mod ) { count ++ ; } else { max_length = Math . max ( max_length , count ) ; count = 1 ; prev_mod = curr_mod ; } } return Math . max ( max_length , count ) ; }
Hyp: 
function LongestSubarray ( arr , n , k ) { let count = 1 ; let max_length = 1 ; let prev_mod = arr [ 0 ] % k ; for ( let i = 1 ; i < n ; i ++ ) { let curr_mod = arr [ i ] % k ; if ( curr_mod == prev_mod ) { count ++ ; } else { max_length = Math . max ( max_length , count ) ; count = 1 ; prev_mod = curr_mod ; } } return max ( max_length , count ) ; }

BLEU: 96.45
Edit Sim: 7


Src: 
int Race ( int B , int C ) { int result = 0 ; result = ( ( C * 100 ) / B ) ; return 100 - result ; }
Ref: 
function Race ( B , C ) { var result = 0 ; result = ( ( C * 100 ) / B ) ; return 100 - result ; }
Hyp: 
function Race ( B , C ) { let result = 0 ; result = ( ( C * 100 ) / B ) ; return 100 - result ; }

BLEU: 91.57
Edit Sim: 3


Src: 
void nthPalindrome ( int n , int k ) { int temp = ( k & 1 ) ? ( k / 2 ) : ( k / 2 - 1 ) ; int palindrome = ( int ) pow ( 10 , temp ) ; palindrome += n - 1 ; printf ( " % d " , palindrome ) ; if ( k & 1 ) palindrome /= 10 ; while ( palindrome ) { printf ( " % d " , palindrome % 10 ) ; palindrome /= 10 ; } printf ( " STRNEWLINE " ) ; }
Ref: 
function nthPalindrome ( n , k ) { let temp = ( k & 1 ) != 0 ? parseInt ( k / 2 , 10 ) : ( parseInt ( k / 2 , 10 ) - 1 ) ; let palindrome = parseInt ( Math . pow ( 10 , temp ) , 10 ) ; palindrome += n - 1 ; document . write ( palindrome ) ; if ( ( k & 1 ) > 0 ) palindrome = parseInt ( palindrome / 10 , 10 ) ; while ( palindrome > 0 ) { document . write ( palindrome % 10 ) ; palindrome = parseInt ( palindrome / 10 , 10 ) ; } document . write ( " " + " " ) ; }
Hyp: 
function nthPalindrome ( n , k ) { let temp = ( k & 1 ) ? ( k / 2 ) : ( k / 2 - 1 ) ; let palindrome = parseInt ( Math . pow ( 10 , temp ) ; palindrome += n - 1 ; document . write ( palindrome . toFixed ( 10 ) ) ; if ( k & 1 ) palindrome /= 10 ; while ( palindrome ) { document . write ( " " + palindrome % 10 ) ; palindrome /= 10 ; } document . write ( " " ) ; }

BLEU: 57.45
Edit Sim: 130


Src: 
int getMaxNum ( int a , int b , int c ) { if ( b % c == 0 ) return b ; int x = ( ( b / c ) * c ) ; if ( x >= a && x <= b ) return x ; else return -1 ; }
Ref: 
function getMaxNum ( a , b , c ) { if ( b % c == 0 ) return b ; var x = ( parseInt ( b / c ) * c ) ; if ( x >= a && x <= b ) return x ; else return - 1 ; }
Hyp: 
function getMaxNum ( a , b , c ) { if ( b % c == 0 ) return b ; let x = ( ( b / c ) * c ) ; if ( x >= a && x <= b ) return x ; else return - 1 ; }

BLEU: 90.46
Edit Sim: 12


Src: 
int FindMinimumCost ( int ind , int a [ ] , int n , int k , int dp [ ] ) { if ( ind == ( n - 1 ) ) return 0 ; else if ( dp [ ind ] != -1 ) return dp [ ind ] ; else { int ans = INT_MAX ; for ( int i = 1 ; i <= k ; i ++ ) { if ( ind + i < n ) ans = min ( ans , abs ( a [ ind + i ] - a [ ind ] ) + FindMinimumCost ( ind + i , a , n , k , dp ) ) ; else break ; } return dp [ ind ] = ans ; } }
Ref: 
function FindMinimumCost ( ind , a , n , k , dp ) { if ( ind == ( n - 1 ) ) return 0 ; else if ( dp [ ind ] != - 1 ) return dp [ ind ] ; else { var ans = Number . MAX_VALUE ; for ( var i = 1 ; i <= k ; i ++ ) { if ( ind + i < n ) ans = Math . min ( ans , Math . abs ( a [ ind + i ] - a [ ind ] ) + FindMinimumCost ( ind + i , a , n , k , dp ) ) ; else break ; } return dp [ ind ] = ans ; } }
Hyp: 
function FindMinimumCost ( ind , a , n , k , dp ) { if ( ind == ( n - 1 ) ) return 0 ; else if ( dp [ ind ] != - 1 ) return dp [ ind ] ; else { let ans = Number . MAX_VALUE ; for ( let i = 1 ; i <= k ; i ++ ) { if ( ind + i < n ) ans = Math . min ( ans , Math . abs ( a [ ind + i ] - a [ ind ] ) + FindMinimumCost ( ind + i , a , n , k , dp ) ) ; else break ; } return dp [ ind ] = ans ; } }

BLEU: 96.14
Edit Sim: 6


Src: 
void Sum_upto_nth_Term ( int n ) { int r = n * ( n + 1 ) * ( 2 * n + 7 ) / 3 ; cout << r ; }
Ref: 
function Sum_upto_nth_Term ( n ) { let r = n * ( n + 1 ) * ( 2 * n + 7 ) / 3 ; document . write ( r ) ; }
Hyp: 
function Sum_upto_nth_Term ( n ) { let r = n * ( n + 1 ) * ( 2 * n + 7 ) / 3 ; document . write ( r . toFixed ( 10 ) ) ; }

BLEU: 83.39
Edit Sim: 17


Src: 
int minRotation ( int input , int unlock_code ) { int rotation = 0 ; int input_digit , code_digit ; while ( input unlock_code ) { input_digit = input % 10 ; code_digit = unlock_code % 10 ; rotation += min ( abs ( input_digit - code_digit ) , 10 - abs ( input_digit - code_digit ) ) ; input /= 10 ; unlock_code /= 10 ; } return rotation ; }
Ref: 
function minRotation ( input , unlock_code ) { let rotation = 0 ; let input_digit , code_digit ; while ( input > 0 unlock_code > 0 ) { input_digit = input % 10 ; code_digit = unlock_code % 10 ; rotation += Math . min ( Math . abs ( input_digit - code_digit ) , 10 - Math . abs ( input_digit - code_digit ) ) ; input = Math . floor ( input / 10 ) ; unlock_code = Math . floor ( unlock_code / 10 ) ; } return rotation ; }
Hyp: 
function minRotation ( input , unlock_code ) { let rotation = 0 ; let input_digit , code_digit ; while ( input unlock_code ) { input_digit = input % 10 ; code_digit = unlock_code % 10 ; rotation += Math . min ( Math . abs ( input_digit - code_digit ) , 10 - Math . abs ( input_digit - code_digit ) ) ; input /= 10 ; unlock_code /= 10 ; } return rotation ; }

BLEU: 69.83
Edit Sim: 66


Src: 
bool sumSquare ( int n ) { for ( long i = 1 ; i * i <= n ; i ++ ) for ( long j = 1 ; j * j <= n ; j ++ ) if ( i * i + j * j == n ) { cout << i << " ^ 2 ▁ + ▁ " << j << " ^ 2" << endl ; return true ; } return false ; }
Ref: 
function sumSquare ( n ) { for ( i = 1 ; i * i <= n ; i ++ ) for ( j = 1 ; j * j <= n ; j ++ ) if ( i * i + j * j == n ) { document . write ( i + " " + j + " " + " " ) ; return true ; } return false ; }
Hyp: 
function sumSquare ( n ) { for ( let i = 1 ; i * i <= n ; i ++ ) for ( let j = 1 ; j * j <= n ; j ++ ) if ( i * i + j * j == n ) { document . write ( i + " " + j + " " ) ; return true ; } return false ; }

BLEU: 91.85
Edit Sim: 14


Src: 
void solve ( int i , int par , int a [ ] , int n , int k , int current_ans ) { if ( par > k ) return ; if ( par == k && i == n - 1 ) { ans = min ( ans , current_ans ) ; return ; } for ( int j = i + 1 ; j < n ; j ++ ) solve ( j , par + 1 , a , n , k , current_ans + ( a [ j ] - a [ i + 1 ] ) * ( a [ j ] - a [ i + 1 ] ) ) ; }
Ref: 
function solve ( i , par , a , n , k , current_ans ) { if ( par > k ) return ; if ( par == k && i == n - 1 ) { ans = Math . min ( ans , current_ans ) ; return ; } for ( let j = i + 1 ; j < n ; j ++ ) solve ( j , par + 1 , a , n , k , current_ans + ( a [ j ] - a [ i + 1 ] ) * ( a [ j ] - a [ i + 1 ] ) ) ; }
Hyp: 
function solve ( i , par , a , n , k , current_ans ) { if ( par > k ) return ; if ( par == k && i == n - 1 ) { ans = Math . min ( ans , current_ans ) ; return ; } for ( let j = i + 1 ; j < n ; j ++ ) solve ( j , par + 1 , a , n , k , current_ans + ( a [ j ] - a [ i + 1 ] ) * ( a [ j ] - a [ i + 1 ] ) ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int calculate ( string s ) { int ans = 6 ; for ( int i = 0 ; i < 10 ; ++ i ) { for ( int j = 0 ; j < 10 ; ++ j ) { for ( int k = 0 ; k < 10 ; ++ k ) { for ( int l = 0 ; l < 10 ; ++ l ) { for ( int m = 0 ; m < 10 ; ++ m ) { for ( int n = 0 ; n < 10 ; ++ n ) { if ( i + j + k == l + m + n ) { int c = 0 ; if ( i != s [ 0 ] - '0' ) c ++ ; if ( j != s [ 1 ] - '0' ) c ++ ; if ( k != s [ 2 ] - '0' ) c ++ ; if ( l != s [ 3 ] - '0' ) c ++ ; if ( m != s [ 4 ] - '0' ) c ++ ; if ( n != s [ 5 ] - '0' ) c ++ ; if ( c < ans ) ans = c ; } } } } } } } return ans ; }
Ref: 
function calculate ( s ) { let ans = 6 ; for ( let i = 0 ; i < 10 ; ++ i ) { for ( let j = 0 ; j < 10 ; ++ j ) { for ( let k = 0 ; k < 10 ; ++ k ) { for ( let l = 0 ; l < 10 ; ++ l ) { for ( let m = 0 ; m < 10 ; ++ m ) { for ( let n = 0 ; n < 10 ; ++ n ) { if ( i + j + k == l + m + n ) { let c = 0 ; if ( i != s [ 0 ] - ' ' ) c ++ ; if ( j != s [ 1 ] - ' ' ) c ++ ; if ( k != s [ 2 ] - ' ' ) c ++ ; if ( l != s [ 3 ] - ' ' ) c ++ ; if ( m != s [ 4 ] - ' ' ) c ++ ; if ( n != s [ 5 ] - ' ' ) c ++ ; if ( c < ans ) ans = c ; } } } } } } } return ans ; }
Hyp: 
function calculate ( s ) { let ans = 6 ; for ( let i = 0 ; i < 10 ; ++ i ) { for ( let j = 0 ; j < 10 ; ++ j ) { for ( let k = 0 ; k < 10 ; ++ k ) { for ( let l = 0 ; l < 10 ; ++ l ) { for ( let m = 0 ; m < 10 ; ++ m ) { if ( i + j + k == l + m + n ) { let c = 0 ; if ( i != s [ 0 ] - ' ' ) c ++ ; if ( j != s [ 1 ] - ' ' ) c ++ ; if ( k != s [ 2 ] - ' ' ) c ++ ; if ( l != s [ 3 ] - ' ' ) c ++ ; if ( m != s [ 4 ] - ' ' ) c ++ ; if ( n != s [ 5 ] - ' ' ) c ++ ; if ( c < ans ) ans = c ; } } } } } return ans ; }

BLEU: 92.29
Edit Sim: 40


Src: 
int number_of_tower ( int house [ ] , int range , int n ) { sort ( house , house + n ) ; int numOfTower = 0 ; int i = 0 ; while ( i < n ) { numOfTower ++ ; int loc = house [ i ] + range ; while ( i < n && house [ i ] <= loc ) i ++ ; -- i ; loc = house [ i ] + range ; while ( i < n && house [ i ] <= loc ) i ++ ; } return numOfTower ; }
Ref: 
function number_of_tower ( house , range , n ) { house . sort ( function ( a , b ) { return a - b ; } ) ; let numOfTower = 0 ; let i = 0 ; while ( i < n ) { numOfTower ++ ; let loc = house [ i ] + range ; while ( i < n && house [ i ] <= loc ) i ++ ; -- i ; loc = house [ i ] + range ; while ( i < n && house [ i ] <= loc ) i ++ ; } return numOfTower ; }
Hyp: 
function number_of_tower ( house , range , n ) { house . sort ( function ( a , b ) { return a - b } ) ; let numOfTower = 0 ; let i = 0 ; while ( i < n ) { numOfTower ++ ; let loc = house [ i ] + range ; while ( i < n && house [ i ] <= loc ) i ++ ; -- i ; loc = house [ i ] + range ; while ( i < n && house [ i ] <= loc ) i ++ ; } return numOfTower ; }

BLEU: 97.66
Edit Sim: 2


Src: 
int getOddOccurrence ( int arr [ ] , int arr_size ) { for ( int i = 0 ; i < arr_size ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < arr_size ; j ++ ) { if ( arr [ i ] == arr [ j ] ) count ++ ; } if ( count % 2 != 0 ) return arr [ i ] ; } return -1 ; }
Ref: 
function getOddOccurrence ( arr , arr_size ) { for ( let i = 0 ; i < arr_size ; i ++ ) { let count = 0 ; for ( let j = 0 ; j < arr_size ; j ++ ) { if ( arr [ i ] == arr [ j ] ) count ++ ; } if ( count % 2 != 0 ) return arr [ i ] ; } return - 1 ; }
Hyp: 
function getOddOccurrence ( arr , arr_size ) { for ( let i = 0 ; i < arr_size ; i ++ ) { let count = 0 ; for ( let j = 0 ; j < arr_size ; j ++ ) { if ( arr [ i ] == arr [ j ] ) count ++ ; } if ( count % 2 != 0 ) return arr [ i ] ; } return - 1 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int day_of_the_week ( int y , int m , int d ) { int t [ ] = { 0 , 3 , 2 , 5 , 0 , 3 , 5 , 1 , 4 , 6 , 2 , 4 } ; if ( m < 3 ) y -= 1 ; return ( ( y + y / 4 - y / 100 + y / 400 + t [ m - 1 ] + d ) % 7 ) ; }
Ref: 
function day_of_the_week ( y , m , d ) { let t = [ 0 , 3 , 2 , 5 , 0 , 3 , 5 , 1 , 4 , 6 , 2 , 4 ] ; if ( m < 3 ) y -= 1 ; return ( y + y / 4 - y / 100 + y / 400 + t [ m - 1 ] + d ) % 7 ; }
Hyp: 
function day_of_the_week ( y , m , d ) { let t = new Array ( 7 ) ; if ( m < 3 ) y -= 1 ; return ( ( y + y / 4 - y / 100 + y / 400 + t [ m - 1 ] + d ) % 7 ) ; }

BLEU: 60.83
Edit Sim: 49


Src: 
int countDistinct ( int arr [ ] , int n ) { unordered_set < int > s ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . find ( arr [ i ] ) == s . end ( ) ) { s . insert ( arr [ i ] ) ; res ++ ; } } return res ; }
Ref: 
function countDistinct ( arr , n ) { let hs = new Set ( ) ; for ( let i = 0 ; i < n ; i ++ ) { hs . add ( arr [ i ] ) ; } return hs . size ; }
Hyp: 
function countDistinct ( arr , n ) { const s = new Set ( ) ; let res = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( s . has ( arr [ i ] ) ) { s . add ( arr [ i ] ) ; res ++ ; } } return res ; }

BLEU: 52.47
Edit Sim: 68


Src: 
bool isLowerTriangularMatrix ( int mat [ N ] [ N ] ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = i + 1 ; j < N ; j ++ ) if ( mat [ i ] [ j ] != 0 ) return false ; return true ; }
Ref: 
function isLowerTriangularMatrix ( mat ) { for ( let i = 0 ; i < N ; i ++ ) for ( let j = i + 1 ; j < N ; j ++ ) if ( mat [ i ] [ j ] != 0 ) return false ; return true ; }
Hyp: 
function isLowerTriangularMatrix ( mat ) { for ( let i = 0 ; i < N ; i ++ ) for ( let j = i + 1 ; j < N ; j ++ ) if ( mat [ i ] [ j ] != 0 ) return false ; return true ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int summation ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += ( i * i ) ; return sum ; }
Ref: 
function summation ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) sum += ( i * i ) ; return sum ; }
Hyp: 
function summation ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) sum += ( i * i ) ; return sum ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int findNum ( int N , int K ) { int rem = N % K ; if ( rem == 0 ) return N ; else return N - rem ; }
Ref: 
function findNum ( N , K ) { var rem = N % K ; if ( rem == 0 ) return N ; else return N - rem ; }
Hyp: 
function findNum ( N , K ) { let rem = N % K ; if ( rem == 0 ) return N ; else return N - rem ; }

BLEU: 91.57
Edit Sim: 3


Src: 
void maxLitres ( int budget , int plastic , int glass , int refund ) { if ( glass - refund < plastic ) { int ans = max ( ( budget - refund ) / ( glass - refund ) , 0 ) ; budget -= ans * ( glass - refund ) ; ans += budget / plastic ; cout << ans << endl ; } else cout << ( budget / plastic ) << endl ; }
Ref: 
function maxLitres ( budget , plastic , glass , refund ) { if ( glass - refund < plastic ) { let ans = Math . max ( ( budget - refund ) / ( glass - refund ) , 0 ) ; budget -= ans * ( glass - refund ) ; ans += Math . floor ( budget / plastic ) ; document . write ( ans ) ; } else { document . write ( Math . floor ( budget / plastic ) ) ; } }
Hyp: 
function maxLitres ( budget , plastic , glass , refund ) { if ( glass - refund < plastic ) { let ans = Math . max ( ( budget - refund ) / ( glass - refund ) , 0 ) ; budget -= ans * ( glass - refund ) ; ans += budget / plastic ; document . write ( ans + " " ) ; } else document . write ( ( budget / plastic ) + " " ) ; }

BLEU: 78.23
Edit Sim: 45


Src: 
int spiralDiaSum ( int n ) { if ( n == 1 ) return 1 ; return ( 4 * n * n - 6 * n + 6 + spiralDiaSum ( n - 2 ) ) ; }
Ref: 
function spiralDiaSum ( n ) { if ( n == 1 ) return 1 ; return ( 4 * n * n - 6 * n + 6 + spiralDiaSum ( n - 2 ) ) ; }
Hyp: 
function spiralDiaSum ( n ) { if ( n == 1 ) return 1 ; return ( 4 * n * n - 6 * n + 6 + spiralDiaSum ( n - 2 ) ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int lcsOf3 ( string X , string Y , string Z , int m , int n , int o ) { int L [ m + 1 ] [ n + 1 ] [ o + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { for ( int k = 0 ; k <= o ; k ++ ) { if ( i == 0 j == 0 k == 0 ) L [ i ] [ j ] [ k ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] && X [ i - 1 ] == Z [ k - 1 ] ) L [ i ] [ j ] [ k ] = L [ i - 1 ] [ j - 1 ] [ k - 1 ] + 1 ; else L [ i ] [ j ] [ k ] = max ( max ( L [ i - 1 ] [ j ] [ k ] , L [ i ] [ j - 1 ] [ k ] ) , L [ i ] [ j ] [ k - 1 ] ) ; } } } return L [ m ] [ n ] [ o ] ; }
Ref: 
function lcsOf3 ( X , Y , Z , m , n , o ) { let L = new Array ( m + 1 ) ; for ( let i = 0 ; i < m + 1 ; i ++ ) { L [ i ] = new Array ( n + 1 ) ; for ( let j = 0 ; j < n + 1 ; j ++ ) { L [ i ] [ j ] = new Array ( o + 1 ) ; for ( let k = 0 ; k < o + 1 ; k ++ ) { L [ i ] [ j ] [ k ] = 0 ; } } } for ( let i = 0 ; i <= m ; i ++ ) { for ( let j = 0 ; j <= n ; j ++ ) { for ( let k = 0 ; k <= o ; k ++ ) { if ( i == 0 j == 0 k == 0 ) L [ i ] [ j ] [ k ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] && X [ i - 1 ] == Z [ k - 1 ] ) L [ i ] [ j ] [ k ] = L [ i - 1 ] [ j - 1 ] [ k - 1 ] + 1 ; else L [ i ] [ j ] [ k ] = Math . max ( Math . max ( L [ i - 1 ] [ j ] [ k ] , L [ i ] [ j - 1 ] [ k ] ) , L [ i ] [ j ] [ k - 1 ] ) ; } } } return L [ m ] [ n ] [ o ] ; }
Hyp: 
function lcsOf3 ( X , Y , Z , m , n , o ) { var L = Array . from ( Array ( m + 1 ) , ( ) => Array ( n + 1 ) ) ; for ( var i = 0 ; i <= m ; i ++ ) { for ( var j = 0 ; j <= n ; j ++ ) { for ( var k = 0 ; k <= o ; k ++ ) { if ( i == 0 j == 0 k == 0 ) L [ i ] [ j ] [ k ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] && X [ i - 1 ] == Z [ k - 1 ] ) L [ i ] [ j ] [ k ] = L [ i - 1 ] [ j - 1 ] [ k - 1 ] + 1 ; else L [ i ] [ j ] [ k ] = Math . max ( L [ i - 1 ] [ j ] [ k ] , L [ i ] [ j ] [ k - 1 ] ) ; } } } return L [ m ] [ n ] [ o ] ; }

BLEU: 59.02
Edit Sim: 241


Src: 
bool isPossibleToZero ( int a [ ] , int n ) { int num = 0 ; for ( int i = 0 ; i < n ; i ++ ) num = num * 10 + a [ i ] ; return ( num % 11 == 0 ) ; }
Ref: 
function isPossibleToZero ( a , n ) { let num = 0 ; for ( let i = 0 ; i < n ; i ++ ) num = num * 10 + a [ i ] ; return ( num % 11 == 0 ) ; }
Hyp: 
function isPossibleToZero ( a , n ) { let num = 0 ; for ( let i = 0 ; i < n ; i ++ ) num = num * 10 + a [ i ] ; return ( num % 11 == 0 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int findLastIndex ( string & str , char x ) { int index = -1 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) if ( str [ i ] == x ) index = i ; return index ; }
Ref: 
function findLastIndex ( str , x ) { let index = - 1 ; for ( let i = 0 ; i < str . length ; i ++ ) if ( str [ i ] == x ) index = i ; return index ; }
Hyp: 
function findLastIndex ( str , x ) { let index = - 1 ; for ( let i = 0 ; i < str . length ; i ++ ) if ( str [ i ] == x ) index = i ; return index ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int minPerimeter ( int n ) { int l = sqrt ( n ) ; int sq = l * l ; if ( sq == n ) return l * 4 ; else { long long int row = n / l ; long long int perimeter = 2 * ( l + row ) ; if ( n % l != 0 ) perimeter += 2 ; return perimeter ; } }
Ref: 
function minPerimeter ( n ) { let l = Math . sqrt ( n ) ; let sq = l * l ; if ( sq == n ) return l * 4 ; else { let row = n / l ; let perimeter = 2 * ( l + row ) ; if ( n % l != 0 ) perimeter += 2 ; return perimeter ; } }
Hyp: 
function minPerimeter ( n ) { let l = Math . sqrt ( n ) ; let sq = l * l ; if ( sq == n ) return l * 4 ; else { let row = parseInt ( n / l ) ; let perimeter = 2 * ( l + row ) ; if ( n % l != 0 ) perimeter += 2 ; return perimeter ; } }

BLEU: 91.73
Edit Sim: 13


Src: 
int Nonagonal ( int n ) { return n * ( 7 * n - 5 ) / 2 ; }
Ref: 
function Nonagonal ( n ) { return parseInt ( n * ( 7 * n - 5 ) / 2 ) ; }
Hyp: 
function Nonagonal ( n ) { return n * ( 7 * n - 5 ) / 2 ; }

BLEU: 72.85
Edit Sim: 13


Src: 
int totalFlips ( char * A , char * B , char * C , int N ) { int count = 0 ; for ( int i = 0 ; i < N ; ++ i ) { if ( A [ i ] == B [ i ] && C [ i ] == '1' ) ++ count ; else if ( A [ i ] != B [ i ] && C [ i ] == '0' ) ++ count ; } return count ; }
Ref: 
function totalFlips ( A , B , C , N ) { let count = 0 ; for ( let i = 0 ; i < N ; ++ i ) { if ( A [ i ] == B [ i ] && C [ i ] == ' ' ) ++ count ; else if ( A [ i ] != B [ i ] && C [ i ] == ' ' ) ++ count ; } return count ; }
Hyp: 
function totalFlips ( A , B , C , N ) { let count = 0 ; for ( let i = 0 ; i < N ; ++ i ) { if ( A [ i ] == B [ i ] && C [ i ] == ' ' ) ++ count ; else if ( A [ i ] != B [ i ] && C [ i ] == ' ' ) ++ count ; } return count ; }

BLEU: 100.0
Edit Sim: 0


Src: 
float calculateSum ( float n ) { int a = int ( n ) ; return 2 * ( pow ( n , 6 ) + 15 * pow ( n , 4 ) + 15 * pow ( n , 2 ) + 1 ) ; }
Ref: 
function calculateSum ( n ) { return 2 * ( Math . pow ( n , 6 ) + 15 * Math . pow ( n , 4 ) + 15 * Math . pow ( n , 2 ) + 1 ) ; }
Hyp: 
function calculateSum ( n ) { let a = parseInt ( n ) ; return 2 * ( Math . pow ( n , 6 ) + 15 * Math . pow ( n , 4 ) + 15 * Math . pow ( n , 2 ) + 1 ) ; }

BLEU: 81.81
Edit Sim: 25


Src: 
int getOccurence ( int n , int d ) { int itr = d ; while ( itr <= n ) { if ( itr % 10 == d ) result ++ ; if ( itr != 0 && itr / 10 == d ) { result ++ ; itr ++ ; } else if ( itr / 10 == d - 1 ) itr = itr + ( 10 - d ) ; else itr = itr + 10 ; } return result ; }
Ref: 
function getOccurence ( n , d ) { let result = 0 ; let itr = d ; while ( itr <= n ) { if ( itr % 10 == d ) result ++ ; if ( itr != 0 && Math . floor ( itr / 10 ) == d ) { result ++ ; itr ++ ; } else if ( Math . floor ( itr / 10 ) == d - 1 ) itr = itr + ( 10 - d ) ; else itr = itr + 10 ; } return result ; }
Hyp: 
function getOccurence ( n , d ) { let result = 0 ; while ( itr <= n ) { if ( itr % 10 == d ) result ++ ; if ( itr != 0 && itr / 10 == d ) { result ++ ; itr ++ ; } else if ( itr / 10 == d - 1 ) itr = itr + ( 10 - d ) ; else itr = itr + 10 ; } return result ; }

BLEU: 77.4
Edit Sim: 48


Src: 
int circle ( int x1 , int y1 , int x2 , int y2 , int r1 , int r2 ) { int distSq = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ; int radSumSq = ( r1 + r2 ) * ( r1 + r2 ) ; if ( distSq == radSumSq ) return 1 ; else if ( distSq > radSumSq ) return -1 ; else return 0 ; }
Ref: 
function circle ( x1 , y1 , x2 , y2 , r1 , r2 ) { var distSq = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ; var radSumSq = ( r1 + r2 ) * ( r1 + r2 ) ; if ( distSq == radSumSq ) return 1 ; else if ( distSq > radSumSq ) return - 1 ; else return 0 ; }
Hyp: 
function circle ( x1 , y1 , x2 , y2 , r1 , r2 ) { var distSq = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ; var radSumSq = ( r1 + r2 ) * ( r1 + r2 ) ; if ( distSq == radSumSq ) return 1 ; else if ( distSq > radSumSq ) return - 1 ; else return 0 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
long nextGreater ( long long N ) { long long power_of_2 = 1 , shift_count = 0 ; while ( true ) { if ( ( ( N >> shift_count ) & 1 ) % 2 == 0 ) break ; shift_count ++ ; power_of_2 = power_of_2 * 2 ; } return ( N + power_of_2 ) ; }
Ref: 
function nextGreater ( N ) { var power_of_2 = 1 , shift_count = 0 ; while ( true ) { if ( ( ( N >> shift_count ) & 1 ) % 2 == 0 ) break ; shift_count ++ ; power_of_2 = power_of_2 * 2 ; } return ( N + power_of_2 ) ; }
Hyp: 
function nextGreater ( N ) { let power_of_2 = 1 , shift_count = 0 ; while ( true ) { if ( ( ( N >> shift_count ) & 1 ) % 2 == 0 ) break ; shift_count ++ ; power_of_2 = power_of_2 * 2 ; } return ( N + power_of_2 ) ; }

BLEU: 95.43
Edit Sim: 3


Src: 
int countSolutions ( int a ) { int count = 0 ; for ( int i = 0 ; i <= a ; i ++ ) { if ( a == ( i + ( a ^ i ) ) ) count ++ ; } return count ; }
Ref: 
function countSolutions ( a ) { let count = 0 ; for ( let i = 0 ; i <= a ; i ++ ) { if ( a == ( i + ( a ^ i ) ) ) count ++ ; } return count ; }
Hyp: 
function countSolutions ( a ) { let count = 0 ; for ( let i = 0 ; i <= a ; i ++ ) { if ( a == ( i + ( a ^ i ) ) ) count ++ ; } return count ; }

BLEU: 100.0
Edit Sim: 0


Src: 
void twoWaySort ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) arr [ i ] *= -1 ; sort ( arr , arr + n ) ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] & 1 ) arr [ i ] *= -1 ; }
Ref: 
function twoWaySort ( arr , n ) { for ( let i = 0 ; i < n ; i ++ ) arr [ i ] *= - 1 ; arr . sort ( ( a , b ) => a - b ) ; for ( let i = 0 ; i < n ; i ++ ) if ( arr [ i ] & 1 ) arr [ i ] *= - 1 ; }
Hyp: 
function twoWaySort ( arr , n ) { for ( let i = 0 ; i < n ; i ++ ) arr [ i ] *= - 1 ; sort ( arr , arr + n ) ; for ( let i = 0 ; i < n ; i ++ ) if ( arr [ i ] & 1 ) arr [ i ] *= - 1 ; }

BLEU: 82.31
Edit Sim: 19


Src: 
int numBoxes ( int A [ ] , int n , int K ) { sort ( A , A + n ) ; int i = 0 , j = n - 1 ; int ans = 0 ; while ( i <= j ) { ans ++ ; if ( A [ i ] + A [ j ] <= K ) i ++ ; j -- ; } return ans ; }
Ref: 
function numBoxes ( A , n , K ) { A . sort ( function ( a , b ) { return a - b } ) ; let i = 0 , j = ( n - 1 ) ; let ans = 0 ; while ( i <= j ) { ans ++ ; if ( A [ i ] + A [ j ] <= K ) i ++ ; j -- ; } return ans ; }
Hyp: 
function numBoxes ( A , n , K ) { A . sort ( ( a , b ) => a - b ) ; let i = 0 , j = n - 1 ; let ans = 0 ; while ( i <= j ) { ans ++ ; if ( A [ i ] + A [ j ] <= K ) i ++ ; j -- ; } return ans ; }

BLEU: 82.68
Edit Sim: 23


Src: 
void countCountries ( int ans [ ] , int N ) { int total_countries = 0 , i = 0 ; bool invalid = false ; while ( i < N ) { int curr_size = ans [ i ] ; int num = ans [ i ] ; while ( num > 0 ) { if ( ans [ i ] != curr_size ) { cout << " Invalid ▁ Answer STRNEWLINE " ; return ; } else num -- ; i ++ ; } total_countries ++ ; } cout << " There ▁ are ▁ " << total_countries << " ▁ distinct ▁ companies ▁ in ▁ the ▁ group . STRNEWLINE " ; }
Ref: 
function countCountries ( ans , N ) { let total_countries = 0 , i = 0 ; let invalid = false ; while ( i < N ) { let curr_size = ans [ i ] ; let num = ans [ i ] ; while ( num > 0 ) { if ( ans [ i ] != curr_size ) { document . write ( " " ) ; return ; } else num -- ; i ++ ; } total_countries ++ ; } document . write ( " " + total_countries + " " ) ; }
Hyp: 
function countCountries ( ans , N ) { let total_countries = 0 , i = 0 ; let invalid = false ; while ( i < N ) { let curr_size = ans [ i ] ; let num = ans [ i ] ; while ( num > 0 ) { if ( ans [ i ] != curr_size ) { document . write ( " " ) ; return ; } else num -- ; i ++ ; } total_countries ++ ; } document . write ( " " + total_countries + " " ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int countObtuseAngles ( int a , int b , int k ) { int c1 = ( b - a ) - 1 ; int c2 = ( k - b ) + ( a - 1 ) ; if ( c1 == c2 ) return 0 ; return min ( c1 , c2 ) ; }
Ref: 
function countObtuseAngles ( a , b , k ) { var c1 = ( b - a ) - 1 ; var c2 = ( k - b ) + ( a - 1 ) ; if ( c1 == c2 ) return 0 ; return Math . min ( c1 , c2 ) ; }
Hyp: 
function countObtuseAngles ( a , b , k ) { let c1 = ( b - a ) - 1 ; let c2 = ( k - b ) + ( a - 1 ) ; if ( c1 == c2 ) return 0 ; return Math . min ( c1 , c2 ) ; }

BLEU: 90.81
Edit Sim: 6


Src: 
int findSmallestDifference ( int A [ ] , int B [ ] , int m , int n ) { sort ( A , A + m ) ; sort ( B , B + n ) ; int a = 0 , b = 0 ; int result = INT_MAX ; while ( a < m && b < n ) { if ( abs ( A [ a ] - B [ b ] ) < result ) result = abs ( A [ a ] - B [ b ] ) ; if ( A [ a ] < B [ b ] ) a ++ ; else b ++ ; } return result ; }
Ref: 
function findSmallestDifference ( A , B , m , n ) { A . sort ( ( a , b ) => a - b ) ; B . sort ( ( a , b ) => a - b ) ; let a = 0 , b = 0 ; let result = Number . MAX_SAFE_INTEGER ; while ( a < m && b < n ) { if ( Math . abs ( A [ a ] - B [ b ] ) < result ) result = Math . abs ( A [ a ] - B [ b ] ) ; if ( A [ a ] < B [ b ] ) a ++ ; else b ++ ; } return result ; }
Hyp: 
function findSmallestDifference ( A , B , m , n ) { A . sort ( function ( a , b ) { return a - b ; } ) ; B . sort ( function ( a , b ) { return a - b ; } ) ; let result = Number . MAX_VALUE ; while ( a < m && b < n ) { if ( Math . abs ( A [ a ] - B [ b ] ) < result ) result = Math . abs ( A [ a ] - B [ b ] ) ; if ( A [ a ] < B [ b ] ) a ++ ; else b ++ ; } return result ; }

BLEU: 82.15
Edit Sim: 54


Src: 
void subString ( char str [ ] , int n ) { for ( int len = 1 ; len <= n ; len ++ ) { for ( int i = 0 ; i <= n - len ; i ++ ) { int j = i + len - 1 ; for ( int k = i ; k <= j ; k ++ ) cout << str [ k ] ; cout << endl ; } } }
Ref: 
function subString ( str , n ) { for ( let len = 1 ; len <= n ; len ++ ) { for ( let i = 0 ; i <= n - len ; i ++ ) { let j = i + len - 1 ; for ( let k = i ; k <= j ; k ++ ) { document . write ( str [ k ] ) ; } document . write ( " " ) ; } } }
Hyp: 
function subString ( str , n ) { for ( let len = 1 ; len <= n ; len ++ ) { for ( let i = 0 ; i <= n - len ; i ++ ) { let j = i + len - 1 ; for ( let k = i ; k <= j ; k ++ ) document . write ( str [ k ] ) ; document . write ( " " ) ; } } }

BLEU: 94.07
Edit Sim: 4


Src: 
void swap ( int * xp , int * yp ) { * xp = * xp ^ * yp ; * yp = * xp ^ * yp ; * xp = * xp ^ * yp ; }
Ref: 
function swap ( xp , yp ) { xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] ; yp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] ; xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] ; }
Hyp: 
function swap ( xp , yp ) { * xp = * xp ^ * yp ; * yp = * xp ^ * yp ; * xp = * xp ^ * yp ; }

BLEU: 17.34
Edit Sim: 55


Src: 
bool isPerfect ( long long int n ) { long long int sum = 1 ; for ( long long int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( i * i != n ) sum = sum + i + n / i ; else sum = sum + i ; } } if ( sum == n && n != 1 ) return true ; return false ; }
Ref: 
function isPerfect ( n ) { sum = 1 ; for ( let i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( i * i != n ) sum = sum + i + n / i ; else sum = sum + i ; } } if ( sum == n && n != 1 ) return true ; return false ; }
Hyp: 
function isPerfect ( n ) { let sum = 1 ; for ( let i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( i * i != n ) sum = sum + i + n / i ; else sum = sum + i ; } } if ( sum == n && n != 1 ) return true ; return false ; }

BLEU: 96.86
Edit Sim: 4


Src: 
string areAllBitsSet ( int n ) { if ( n == 0 ) return " No " ; if ( ( ( n + 1 ) & n ) == 0 ) return " Yes " ; return " No " ; }
Ref: 
function areAllBitsSet ( n ) { if ( n == 0 ) return " " ; if ( ( ( n + 1 ) & n ) == 0 ) return " " ; return " " ; }
Hyp: 
function areAllBitsSet ( n ) { if ( n == 0 ) return " " ; if ( ( ( n + 1 ) & n ) == 0 ) return " " ; return " " ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int numOfCombinations ( int arr [ ] , int N ) { int C [ 3 ] = { 0 , 0 , 0 } ; for ( int i = 0 ; i < N ; ++ i ) ++ C [ arr [ i ] % 3 ] ; return C [ 1 ] * C [ 2 ] + C [ 0 ] * ( C [ 0 ] - 1 ) / 2 + C [ 0 ] * ( C [ 0 ] - 1 ) * ( C [ 0 ] - 2 ) / 6 + C [ 1 ] * ( C [ 1 ] - 1 ) * ( C [ 1 ] - 2 ) / 6 + C [ 2 ] * ( C [ 2 ] - 1 ) * ( C [ 2 ] - 2 ) / 6 + C [ 0 ] * C [ 1 ] * C [ 2 ] ; }
Ref: 
function numOfCombinations ( arr , N ) { let C = [ 0 , 0 , 0 ] ; for ( let i = 0 ; i < N ; ++ i ) ++ C [ arr [ i ] % 3 ] ; return C [ 1 ] * C [ 2 ] + C [ 0 ] * ( C [ 0 ] - 1 ) / 2 + C [ 0 ] * ( C [ 0 ] - 1 ) * ( C [ 0 ] - 2 ) / 6 + C [ 1 ] * ( C [ 1 ] - 1 ) * ( C [ 1 ] - 2 ) / 6 + C [ 2 ] * ( C [ 2 ] - 1 ) * ( C [ 2 ] - 2 ) / 6 + C [ 0 ] * C [ 1 ] * C [ 2 ] ; }
Hyp: 
function numOfCombinations ( arr , N ) { let C = Array ( 3 ) . fill ( 0 ) ; for ( let i = 0 ; i < N ; ++ i ) ++ C [ arr [ i ] % 3 ] ; return C [ 1 ] * C [ 2 ] + C [ 0 ] * ( C [ 0 ] - 1 ) * ( C [ 0 ] - 2 ) / 6 + C [ 1 ] * ( C [ 1 ] - 1 ) * ( C [ 1 ] - 2 ) / 6 + C [ 2 ] * ( C [ 2 ] - 2 ) / 6 + C [ 0 ] * C [ 1 ] * C [ 2 ] ; }

BLEU: 79.05
Edit Sim: 67


Src: 
void isKthBitSet ( int n , int k ) { if ( n & ( 1 << ( k - 1 ) ) ) cout << " SET " ; else cout << " NOT ▁ SET " ; }
Ref: 
function isKthBitSet ( n , k ) { if ( ( n & ( 1 << ( k - 1 ) ) ) > 0 ) document . write ( " " ) ; else document . write ( " " ) ; }
Hyp: 
function isKthBitSet ( n , k ) { if ( n & ( 1 << ( k - 1 ) ) ) document . write ( " " ) ; else document . write ( " " ) ; }

BLEU: 86.85
Edit Sim: 8


Src: 
int firstDigit ( int x ) { while ( x >= 10 ) x = x / 10 ; return x ; }
Ref: 
function firstDigit ( x ) { while ( x >= 10 ) x = x / 10 ; return Math . floor ( x ) ; }
Hyp: 
function firstDigit ( x ) { while ( x >= 10 ) x = Math . floor ( x / 10 ) ; return x ; }

BLEU: 74.73
Edit Sim: 29


Src: 
int findCountOfPairs ( int a , int b , int n ) { int ans = 0 ; for ( int i = 1 ; i <= a ; i ++ ) { ans += b / n ; ans += ( i % n + b % n ) >= n ? 1 : 0 ; } return ans ; }
Ref: 
function findCountOfPairs ( a , b , n ) { let ans = 0 ; for ( let i = 1 ; i <= a ; i ++ ) { ans += parseInt ( b / n , 10 ) ; ans += ( i % n + b % n ) >= n ? 1 : 0 ; } return ans ; }
Hyp: 
function findCountOfPairs ( a , b , n ) { let ans = 0 ; for ( let i = 1 ; i <= a ; i ++ ) { ans += b / n ; ans += ( i % n + b % n ) >= n ? 1 : 0 ; } return ans ; }

BLEU: 87.02
Edit Sim: 18


Src: 
int sumOfSeries ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= i ; j ++ ) sum += j ; return sum ; }
Ref: 
function sumOfSeries ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) for ( let j = 1 ; j <= i ; j ++ ) sum += j ; return sum ; }
Hyp: 
function sumOfSeries ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) for ( let j = 1 ; j <= i ; j ++ ) sum += j ; return sum ; }

BLEU: 100.0
Edit Sim: 0


Src: 
bool isProductEven ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) if ( ( arr [ i ] & 1 ) == 0 ) return true ; return false ; }
Ref: 
function isProductEven ( arr , n ) { for ( let i = 0 ; i < n ; i ++ ) if ( ( arr [ i ] & 1 ) == 0 ) return true ; return false ; }
Hyp: 
function isProductEven ( arr , n ) { for ( let i = 0 ; i < n ; i ++ ) if ( ( arr [ i ] & 1 ) == 0 ) return true ; return false ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int setleftmostunsetbit ( int n ) { if ( ( n & ( n + 1 ) ) == 0 ) return n ; int pos = 0 ; for ( int temp = n , count = 0 ; temp > 0 ; temp >>= 1 , count ++ ) if ( ( temp & 1 ) == 0 ) pos = count ; return ( n | ( 1 << ( pos ) ) ) ; }
Ref: 
function setleftmostunsetbit ( n ) { if ( ( n & ( n + 1 ) ) == 0 ) return n ; let pos = 0 ; for ( let temp = n , count = 0 ; temp > 0 ; temp >>= 1 , count ++ ) if ( ( temp & 1 ) == 0 ) pos = count ; return ( n | ( 1 << ( pos ) ) ) ; }
Hyp: 
function setleftmostunsetbit ( n ) { if ( ( n & ( n + 1 ) ) == 0 ) return n ; var pos = 0 ; for ( var temp = n ; temp > 0 ; temp >>= 1 , count ++ ) if ( ( temp & 1 ) == 0 ) pos = count ; return ( n | ( 1 << ( pos ) ) ) ; }

BLEU: 86.18
Edit Sim: 18


Src: 
int countsubarray ( int array [ ] , int n , int k ) { int count = 0 ; int i , j , mul ; for ( i = 0 ; i < n ; i ++ ) { if ( array [ i ] < k ) count ++ ; mul = array [ i ] ; for ( j = i + 1 ; j < n ; j ++ ) { mul = mul * array [ j ] ; if ( mul < k ) count ++ ; else break ; } } return count ; }
Ref: 
function countsubarray ( array , n , k ) { var count = 0 ; var i , j , mul ; for ( i = 0 ; i < n ; i ++ ) { if ( array [ i ] < k ) count ++ ; mul = array [ i ] ; for ( j = i + 1 ; j < n ; j ++ ) { mul = mul * array [ j ] ; if ( mul < k ) count ++ ; else break ; } } return count ; }
Hyp: 
function countsubarray ( array , n , k ) { let count = 0 ; let i , j , mul ; for ( i = 0 ; i < n ; i ++ ) { if ( array [ i ] < k ) count ++ ; mul = array [ i ] ; for ( j = i + 1 ; j < n ; j ++ ) { mul = mul * array [ j ] ; if ( mul < k ) count ++ ; else break ; } } return count ; }

BLEU: 94.82
Edit Sim: 6


Src: 
int sumOfSeries ( int n ) { int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) ans += i * i * i * i ; return ans ; }
Ref: 
function sumOfSeries ( n ) { let ans = 0 ; for ( let i = 1 ; i <= n ; i ++ ) ans += i * i * i * i ; return ans ; }
Hyp: 
function sumOfSeries ( n ) { let ans = 0 ; for ( let i = 1 ; i <= n ; i ++ ) ans += i * i * i * i ; return ans ; }

BLEU: 100.0
Edit Sim: 0


Src: 
bool isMagic ( int n ) { int sum = 0 ; while ( n > 0 sum > 9 ) { if ( n == 0 ) { n = sum ; sum = 0 ; } sum += n % 10 ; n /= 10 ; } return ( sum == 1 ) ; }
Ref: 
function isMagic ( n ) { var sum = 0 ; while ( n > 0 sum > 9 ) { if ( n = 0 ) { n = sum ; sum = 0 ; } sum += n % 10 ; n /= 10 ; } return ( sum = 1 ) ; }
Hyp: 
function isMagic ( n ) { let sum = 0 ; while ( n > 0 sum > 9 ) { if ( n == 0 ) { n = sum ; sum = 0 ; } sum = sum + n % 10 ; n = Math . floor ( n / 10 ) ; } return ( sum == 1 ) ; }

BLEU: 65.92
Edit Sim: 34


Src: 
int setBitNumber ( int n ) { if ( n == 0 ) return 0 ; int msb = 0 ; n = n / 2 ; while ( n != 0 ) { n = n / 2 ; msb ++ ; } return ( 1 << msb ) ; }
Ref: 
function setBitNumber ( n ) { if ( n == 0 ) return 0 ; let msb = 0 ; n = n / 2 ; while ( n != 0 ) { n = $n / 2 ; msb ++ ; } return ( 1 << msb ) ; }
Hyp: 
function setBitNumber ( n ) { if ( n == 0 ) return 0 ; let msb = 0 ; n = parseInt ( n / 2 ) ; while ( n != 0 ) { n = parseInt ( n / 2 ) ; msb ++ ; } return ( 1 << msb ) ; }

BLEU: 76.89
Edit Sim: 26


Src: 
int CountPairs ( int n ) { int k = n ; int imin = 1 ; int ans = 0 ; while ( imin <= n ) { int imax = n / k ; ans += k * ( imax - imin + 1 ) ; imin = imax + 1 ; k = n / imin ; } return ans ; }
Ref: 
function CountPairs ( n ) { let k = n ; let imin = 1 ; let ans = 0 ; while ( imin <= n ) { let imax = Math . floor ( n / k ) ; ans += k * ( imax - imin + 1 ) ; imin = imax + 1 ; k = Math . floor ( n / imin ) ; } return ans ; }
Hyp: 
function CountPairs ( n ) { let k = n ; let imin = 1 ; let ans = 0 ; while ( imin <= n ) { let imax = parseInt ( n / k ) ; ans += k * ( imax - imin + 1 ) ; imin = imax + 1 ; k = parseInt ( n / imin ) ; } return ans ; }

BLEU: 87.54
Edit Sim: 22


Src: 
void occurredOnce ( int arr [ ] , int n ) { int i = 1 , len = n ; if ( arr [ 0 ] == arr [ len - 1 ] ) { i = 2 ; len -- ; } for ( ; i < n ; i ++ ) if ( arr [ i ] == arr [ i - 1 ] ) i ++ ; else cout << arr [ i - 1 ] << " ▁ " ; if ( arr [ n - 1 ] != arr [ 0 ] && arr [ n - 1 ] != arr [ n - 2 ] ) cout << arr [ n - 1 ] ; }
Ref: 
function occurredOnce ( arr , n ) { var i = 1 , len = n ; if ( arr [ 0 ] == arr [ len - 1 ] ) { i = 2 ; len -- ; } for ( ; i < n ; i ++ ) if ( arr [ i ] == arr [ i - 1 ] ) i ++ ; else document . write ( arr [ i - 1 ] + " " ) ; if ( arr [ n - 1 ] != arr [ 0 ] && arr [ n - 1 ] != arr [ n - 2 ] ) document . write ( arr [ n - 1 ] ) ; }
Hyp: 
function occurredOnce ( arr , n ) { let i = 1 , len = n ; if ( arr [ 0 ] == arr [ len - 1 ] ) { i = 2 ; len -- ; } for ( ; i < n ; i ++ ) if ( arr [ i ] == arr [ i - 1 ] ) i ++ ; else document . write ( arr [ i - 1 ] + " " ) ; if ( arr [ n - 1 ] != arr [ 0 ] && arr [ n - 1 ] != arr [ n - 2 ] ) document . write ( arr [ n - 1 ] ) ; }

BLEU: 97.96
Edit Sim: 3


Src: 
int squaresum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += ( i * i ) ; return sum ; }
Ref: 
function squaresum ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) sum += ( i * i ) ; return sum ; }
Hyp: 
function squaresum ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) sum += ( i * i ) ; return sum ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int minRevolutions ( double r , int x1 , int y1 , int x2 , int y2 ) { double d = sqrt ( ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ) ; return ceil ( d / ( 2 * r ) ) ; }
Ref: 
function minRevolutions ( r , x1 , y1 , x2 , y2 ) { let d = Math . sqrt ( ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ) ; return Math . ceil ( d / ( 2 * r ) ) ; }
Hyp: 
function minRevolutions ( r , x1 , y1 , x2 , y2 ) { let d = Math . sqrt ( ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ) ; return Math . ceil ( d / ( 2 * r ) ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
void printCoins ( int arr [ ] , int n ) { int oddSum = 0 ; for ( int i = 0 ; i < n ; i += 2 ) oddSum += arr [ i ] ; int evenSum = 0 ; for ( int i = 1 ; i < n ; i += 2 ) evenSum += arr [ i ] ; int start = ( ( oddSum > evenSum ) ? 0 : 1 ) ; for ( int i = start ; i < n ; i += 2 ) cout << arr [ i ] << " ▁ " ; }
Ref: 
function printCoins ( arr , n ) { var oddSum = 0 ; for ( var i = 0 ; i < n ; i += 2 ) oddSum += arr [ i ] ; var evenSum = 0 ; for ( var i = 1 ; i < n ; i += 2 ) evenSum += arr [ i ] ; var start = ( ( oddSum > evenSum ) ? 0 : 1 ) ; for ( var i = start ; i < n ; i += 2 ) document . write ( arr [ i ] + " " ) ; }
Hyp: 
function printCoins ( arr , n ) { let oddSum = 0 ; for ( let i = 0 ; i < n ; i += 2 ) oddSum += arr [ i ] ; let evenSum = 0 ; for ( let i = 1 ; i < n ; i += 2 ) evenSum += arr [ i ] ; let start = ( ( oddSum > evenSum ) ? 0 : 1 ) ; for ( let i = start ; i < n ; i += 2 ) document . write ( arr [ i ] + " " ) ; }

BLEU: 85.46
Edit Sim: 18


Src: 
int printCountRec ( int dist ) { if ( dist < 0 ) return 0 ; if ( dist == 0 ) return 1 ; return printCountRec ( dist - 1 ) + printCountRec ( dist - 2 ) + printCountRec ( dist - 3 ) ; }
Ref: 
function printCountRec ( dist ) { if ( dist < 0 ) return 0 ; if ( dist == 0 ) return 1 ; return printCountRec ( dist - 1 ) + printCountRec ( dist - 2 ) + printCountRec ( dist - 3 ) ; }
Hyp: 
function printCountRec ( dist ) { if ( dist < 0 ) return 0 ; if ( dist == 0 ) return 1 ; return printCountRec ( dist - 1 ) + printCountRec ( dist - 2 ) + printCountRec ( dist - 3 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int getResult ( int n ) { if ( n & 1 ) return 1 ; return -1 ; }
Ref: 
function getResult ( n ) { if ( ( n & 1 ) > 0 ) return 1 ; return - 1 ; }
Hyp: 
function getResult ( n ) { if ( n & 1 ) return 1 ; return - 1 ; }

BLEU: 74.78
Edit Sim: 8


Src: 
void Nthterm ( int n ) { int numerator = pow ( n , 2 ) - 1 ; int denomenator = 2 * n - 3 ; cout << numerator << " / " << denomenator ; }
Ref: 
function Nthterm ( n ) { let numerator = Math . pow ( n , 2 ) - 1 ; let denomenator = 2 * n - 3 ; document . write ( numerator + " " + denomenator ) ; }
Hyp: 
function Nthterm ( n ) { let numerator = Math . pow ( n , 2 ) - 1 ; let denomenator = 2 * n - 3 ; document . write ( numerator + " " + denomenator ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int squares ( int l , int b , int a ) { return ceil ( l / ( double ) a ) * ceil ( b / ( double ) a ) ; }
Ref: 
function squares ( l , b , a ) { return parseInt ( Math . ceil ( l / a ) * Math . ceil ( b / a ) ) ; }
Hyp: 
function squares ( l , b , a ) { return Math . ceil ( l / ( double ) a ) * Math . ceil ( b / ( double ) a ) ; }

BLEU: 68.69
Edit Sim: 32


Src: 
int countMoves ( int n ) { int ct = 0 ; for ( int i = 1 ; i <= n ; i ++ ) ct += i * ( n - i ) ; ct += n ; return ct ; }
Ref: 
function countMoves ( n ) { let ct = 0 ; for ( let i = 1 ; i <= n ; i ++ ) ct += i * ( n - i ) ; ct += n ; return ct ; }
Hyp: 
function countMoves ( n ) { let ct = 0 ; for ( let i = 1 ; i <= n ; i ++ ) ct += i * ( n - i ) ; ct += n ; return ct ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int countPieces ( int N ) { return 2 * N ; }
Ref: 
function countPieces ( N ) { return 2 * N ; }
Hyp: 
function countPieces ( N ) { return 2 * N ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int sumOfSeries ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum = sum + ( 2 * i - 1 ) * ( 2 * i - 1 ) ; return sum ; }
Ref: 
function sumOfSeries ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) sum = sum + ( 2 * i - 1 ) * ( 2 * i - 1 ) ; return sum ; }
Hyp: 
function sumOfSeries ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) sum = sum + ( 2 * i - 1 ) * ( 2 * i - 1 ) ; return sum ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int maxProd ( int N ) { if ( N == 0 ) return 1 ; if ( N < 10 ) return N ; return max ( maxProd ( N / 10 ) * ( N % 10 ) , maxProd ( N / 10 - 1 ) * 9 ) ; }
Ref: 
function maxProd ( N ) { if ( N == 0 ) return 1 ; if ( N < 10 ) return N ; return Math . max ( maxProd ( parseInt ( N / 10 ) ) * ( N % 10 ) , maxProd ( parseInt ( N / 10 ) - 1 ) * 9 ) ; }
Hyp: 
function maxProd ( N ) { if ( N == 0 ) return 1 ; if ( N < 10 ) return N ; return Math . max ( maxProd ( N / 10 ) * ( N % 10 ) , maxProd ( N / 10 - 1 ) * 9 ) ; }

BLEU: 83.15
Edit Sim: 26


Src: 
void diameter ( double r ) { cout << " The ▁ length ▁ of ▁ the ▁ longest ▁ chord " << " ▁ or ▁ diameter ▁ of ▁ the ▁ circle ▁ is ▁ " << 2 * r << endl ; }
Ref: 
function diameter ( r ) { document . write ( " " + " " + 2 * r ) ; }
Hyp: 
function diameter ( r ) { document . write ( " " + " " + 2 * r + " " ) ; }

BLEU: 81.2
Edit Sim: 6


Src: 
int strScore ( string str [ ] , string s , int n ) { int score = 0 , index ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == s ) { for ( int j = 0 ; j < s . length ( ) ; j ++ ) score += s [ j ] - ' a ' + 1 ; index = i + 1 ; break ; } } score = score * index ; return score ; }
Ref: 
function strScore ( str , s , n ) { var score = 0 , index = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( str [ i ] == s ) { for ( j = 0 ; j < s . length ; j ++ ) { score += s . charAt ( j ) . charCodeAt ( 0 ) - ( ' ' ) . charCodeAt ( 0 ) + 1 ; } index = i + 1 ; break ; } } score = score * index ; return score ; }
Hyp: 
function strScore ( str , s , n ) { let score = 0 , index ; for ( let i = 0 ; i < n ; i ++ ) { if ( str [ i ] == s ) { for ( let j = 0 ; j < s . length ; j ++ ) score += s [ j ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) + 1 ; index = i + 1 ; break ; } } score = score * index ; return score ; }

BLEU: 75.46
Edit Sim: 34


Src: 
void printKPFNums ( int A , int B , int K ) { bool prime [ B + 1 ] = { true } ; int p_factors [ B + 1 ] = { 0 } ; for ( int p = 2 ; p <= B ; p ++ ) if ( p_factors [ p ] == 0 ) for ( int i = p ; i <= B ; i += p ) p_factors [ i ] ++ ; for ( int i = A ; i <= B ; i ++ ) if ( p_factors [ i ] == K ) cout << i << " ▁ " ; }
Ref: 
function prletKPFNums ( A , B , K ) { let prime = [ ] ; for ( let i = 0 ; i < B + 1 ; i ++ ) prime [ i ] = true ; let p_factors = [ ] ; for ( let i = 0 ; i < B + 1 ; i ++ ) p_factors [ i ] = 0 ; for ( let p = 2 ; p <= B ; p ++ ) if ( p_factors [ p ] == 0 ) for ( let i = p ; i <= B ; i += p ) p_factors [ i ] ++ ; for ( let i = A ; i <= B ; i ++ ) if ( p_factors [ i ] == K ) document . write ( i + " " ) ; }
Hyp: 
function printKPFNums ( A , B , K ) { let prime = new Array ( B + 1 ) ; let p_factors = new Array ( B + 1 ) ; for ( let p = 2 ; p <= B ; p ++ ) if ( p_factors [ p ] == 0 ) for ( let i = p ; i <= B ; i += p ) p_factors [ i ] ++ ; for ( let i = A ; i <= B ; i ++ ) if ( prime [ i ] == K ) document . write ( i + " " ) ; }

BLEU: 61.14
Edit Sim: 111


Src: 
int getInteger ( int L , int R ) { int number = 0 ; for ( int i = L ; i <= R ; i ++ ) number += pow ( 2 , i ) ; return number ; }
Ref: 
function getInteger ( L , R ) { var number = 0 ; for ( var i = L ; i <= R ; i ++ ) number += Math . pow ( 2 , i ) ; return number ; }
Hyp: 
function getInteger ( L , R ) { let number = 0 ; for ( let i = L ; i <= R ; i ++ ) number += Math . pow ( 2 , i ) ; return number ; }

BLEU: 87.61
Edit Sim: 6


Src: 
int largestKSubmatrix ( int a [ ] [ Col ] ) { int dp [ Row ] [ Col ] ; memset ( dp , sizeof ( dp ) , 0 ) ; int result = 0 ; for ( int i = 0 ; i < Row ; i ++ ) { for ( int j = 0 ; j < Col ; j ++ ) { if ( i == 0 j == 0 ) dp [ i ] [ j ] = 1 ; else { if ( a [ i ] [ j ] == a [ i - 1 ] [ j ] && a [ i ] [ j ] == a [ i ] [ j - 1 ] && a [ i ] [ j ] == a [ i - 1 ] [ j - 1 ] ) dp [ i ] [ j ] = min ( min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) , dp [ i - 1 ] [ j - 1 ] ) + 1 ; else dp [ i ] [ j ] = 1 ; } result = max ( result , dp [ i ] [ j ] ) ; } } return result ; }
Ref: 
function largestKSubmatrix ( a ) { let dp = new Array ( Row ) ; for ( let i = 0 ; i < Row ; i ++ ) { dp [ i ] = new Array ( Col ) ; for ( let j = 0 ; j < Col ; j ++ ) { dp [ i ] [ j ] = 0 ; } } let result = 0 ; for ( let i = 0 ; i < Row ; i ++ ) { for ( let j = 0 ; j < Col ; j ++ ) { if ( i == 0 j == 0 ) dp [ i ] [ j ] = 1 ; else { if ( a [ i ] [ j ] == a [ i - 1 ] [ j ] && a [ i ] [ j ] == a [ i ] [ j - 1 ] && a [ i ] [ j ] == a [ i - 1 ] [ j - 1 ] ) { dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] > dp [ i ] [ j - 1 ] && dp [ i - 1 ] [ j ] > dp [ i - 1 ] [ j - 1 ] + 1 ) ? dp [ i - 1 ] [ j ] : ( dp [ i ] [ j - 1 ] > dp [ i - 1 ] [ j ] && dp [ i ] [ j - 1 ] > dp [ i - 1 ] [ j - 1 ] + 1 ) ? dp [ i ] [ j - 1 ] : dp [ i - 1 ] [ j - 1 ] + 1 ; } else dp [ i ] [ j ] = 1 ; } result = result > dp [ i ] [ j ] ? result : dp [ i ] [ j ] ; } } return result ; }
Hyp: 
function largestKSubmatrix ( a ) { let dp = new Array ( Row ) ; for ( let i = 0 ; i < Row ; i ++ ) { dp [ i ] = new Array ( Col ) ; for ( let j = 0 ; j < Col ; j ++ ) { if ( i == 0 j == 0 ) dp [ i ] [ j ] = 1 ; else { if ( a [ i ] [ j ] == a [ i - 1 ] [ j ] && a [ i ] [ j ] == a [ i - 1 ] [ j ] ) dp [ i ] [ j ] = Math . min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) + 1 ; else dp [ i ] [ j ] = 1 ; } } } return result ; }

BLEU: 29.68
Edit Sim: 435


Src: 
long cal_minimum_time ( long X ) { long t = 0 ; long sum = 0 ; while ( sum < X ) { t ++ ; sum = sum + t ; } return t ; }
Ref: 
function cal_minimum_time ( X ) { let t = 0 ; let sum = 0 ; while ( sum < X ) { t ++ ; sum = sum + t ; } return t ; }
Hyp: 
function cal_minimum_time ( X ) { let t = 0 ; let sum = 0 ; while ( sum < X ) { t ++ ; sum = sum + t ; } return t ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int getAverage ( int x , int y ) { int avg = ( x & y ) + ( ( x ^ y ) >> 1 ) ; return avg ; }
Ref: 
function getAverage ( x , y ) { var avg = ( x & y ) + ( ( x ^ y ) >> 1 ) ; return avg ; }
Hyp: 
function getAverage ( x , y ) { let avg = ( x & y ) + ( ( x ^ y ) >> 1 ) ; return avg ; }

BLEU: 91.57
Edit Sim: 3


Src: 
void findAandB ( double N ) { double val = N * N - 4.0 * N ; if ( val < 0 ) { cout << " NO " ; return ; } double a = ( N + sqrt ( val ) ) / 2.0 ; double b = ( N - sqrt ( val ) ) / 2.0 ; cout << " a ▁ = ▁ " << a << endl ; cout << " b ▁ = ▁ " << b << endl ; }
Ref: 
function findAandB ( N ) { let val = N * N - 4.0 * N ; if ( val < 0 ) { document . write ( " " ) ; return ; } let a = ( N + Math . sqrt ( val ) ) / 2.0 ; let b = ( N - Math . sqrt ( val ) ) / 2.0 ; document . write ( " " + a . toFixed ( 4 ) + " " ) ; document . write ( " " + b . toFixed ( 5 ) ) ; }
Hyp: 
function findAandB ( N ) { let val = N * N - 4.0 * N ; if ( val < 0 ) { document . write ( " " ) ; return ; } let a = ( N + Math . sqrt ( val ) ) / 2.0 ; let b = ( N - Math . sqrt ( val ) ) / 2.0 ; document . write ( " " + a + " " ) ; document . write ( " " + b + " " ) ; }

BLEU: 86.81
Edit Sim: 29


Src: 
int numberOfSticks ( int x ) { return ( 3 * x * ( x + 1 ) ) / 2 ; }
Ref: 
function numberOfSticks ( x ) { return ( 3 * x * ( x + 1 ) ) / 2 ; }
Hyp: 
function numberOfSticks ( x ) { return ( 3 * x * ( x + 1 ) ) / 2 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int calculateEvenSum ( int n ) { if ( n <= 0 ) return 0 ; int fibo [ 2 * n + 1 ] ; fibo [ 0 ] = 0 , fibo [ 1 ] = 1 ; int sum = 0 ; for ( int i = 2 ; i <= 2 * n ; i ++ ) { fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ; if ( i % 2 == 0 ) sum += fibo [ i ] ; } return sum ; }
Ref: 
function calculateEvenSum ( n ) { if ( n <= 0 ) return 0 ; let fibo = Array ( 2 * n + 1 ) ; fibo [ 0 ] = 0 ; fibo [ 1 ] = 1 ; let sum = 0 ; for ( i = 2 ; i <= 2 * n ; i ++ ) { fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ; if ( i % 2 == 0 ) sum += fibo [ i ] ; } return sum ; }
Hyp: 
function calculateEvenSum ( n ) { if ( n <= 0 ) return 0 ; let fibo = new Array ( 2 * n + 1 ) ; fibo [ 0 ] = 0 , fibo [ 1 ] = 1 ; let sum = 0 ; for ( let i = 2 ; i <= 2 * n ; i ++ ) { fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ; if ( i % 2 == 0 ) sum += fibo [ i ] ; } return sum ; }

BLEU: 92.59
Edit Sim: 9


Src: 
int sumOfSeries ( int n ) { return ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; }
Ref: 
function sumOfSeries ( n ) { return ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; }
Hyp: 
function sumOfSeries ( n ) { return ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int nthOdd ( int n ) { return ( 2 * n - 1 ) ; }
Ref: 
function nthOdd ( n ) { return ( 2 * n - 1 ) ; }
Hyp: 
function nthOdd ( n ) { return ( 2 * n - 1 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int countSegments ( int a [ ] , int n , int x ) { bool flag = false ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > x ) { flag = true ; } else { if ( flag ) count += 1 ; flag = false ; } } if ( flag ) count += 1 ; return count ; }
Ref: 
function countSegments ( a , n , x ) { let flag = false ; let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] > x ) { flag = true ; } else { if ( flag ) count += 1 ; flag = false ; } } if ( flag ) count += 1 ; return count ; }
Hyp: 
function countSegments ( a , n , x ) { let flag = false ; let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] > x ) { flag = true ; } else { if ( flag ) count += 1 ; flag = false ; } } if ( flag ) count += 1 ; return count ; }

BLEU: 100.0
Edit Sim: 0


Src: 
void LeadingZeros ( int x , int y ) { if ( ( x ^ y ) <= ( x & y ) ) cout << " Equal " else if ( ( x & ( ~ y ) ) > y ) cout << y ; else cout << x ; }
Ref: 
function LeadingZeros ( x , y ) { if ( ( x ^ y ) <= ( x & y ) ) document . write ( " " ) ; else if ( ( x & ( ~ y ) ) > y ) document . write ( y ) ; else document . write ( x ) ; }
Hyp: 
function LeadingZeros ( x , y ) { if ( ( x ^ y ) <= ( x & y ) ) document . write ( " " ) else if ( ( x & ( ~ y ) ) > y ) document . write ( y ) ; else document . write ( x ) ; }

BLEU: 95.74
Edit Sim: 2


Src: 
int countCon ( int ar [ ] , int n ) { int cnt = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( ar [ i ] == ar [ i + 1 ] ) cnt ++ ; } return cnt ; }
Ref: 
function countCon ( ar , n ) { let cnt = 0 ; for ( let i = 0 ; i < n - 1 ; i ++ ) { if ( ar [ i ] == ar [ i + 1 ] ) cnt ++ ; } return cnt ; }
Hyp: 
function countCon ( ar , n ) { let cnt = 0 ; for ( let i = 0 ; i < n - 1 ; i ++ ) { if ( ar [ i ] == ar [ i + 1 ] ) cnt ++ ; } return cnt ; }

BLEU: 100.0
Edit Sim: 0


Src: 
bool transformString ( string & s ) { char ch = ' a ' ; if ( s . size ( ) < 26 ) return false ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { if ( int ( ch ) > int ( ' z ' ) ) break ; if ( s [ i ] <= ch ) { s [ i ] = ch ; ch = char ( int ( ch ) + 1 ) ; } } if ( ch <= ' z ' ) return false ; return true ; }
Ref: 
function transformString ( ) { var ch = ' ' ; if ( s . length < 26 ) return false ; for ( var i = 0 ; i < s . length ; i ++ ) { if ( ch . charCodeAt ( 0 ) > 122 ) break ; if ( s [ i ] . charCodeAt ( 0 ) <= ch . charCodeAt ( 0 ) ) { s [ i ] = ch ; ch = String . fromCharCode ( ch . charCodeAt ( 0 ) + 1 ) ; } } s = s . join ( ' ' ) if ( ch . charCodeAt ( 0 ) <= ' ' . charCodeAt ( 0 ) ) return false ; return true ; }
Hyp: 
function transformString ( s ) { let ch = ' ' ; if ( s . length < 26 ) return 0 ; for ( let i = 0 ; i < s . length ; i ++ ) { if ( ch > int ( ' ' ) ) break ; if ( s [ i ] <= ch ) { s [ i ] = ch ; ch = char ( parseInt ( ch ) + 1 ) ; } } if ( ch <= ' ' ) return 0 ; return 1 ; }

BLEU: 46.93
Edit Sim: 168


Src: 
int1024_t boost_hyperfactorial ( int num ) { int1024_t val = 1 ; for ( int i = 1 ; i <= num ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) { val *= i ; } } return val ; }
Ref: 
function boost_hyperfactorial ( num ) { var val = 1 ; for ( var i = 1 ; i <= num ; i ++ ) { for ( var j = 1 ; j <= i ; j ++ ) { val *= i ; } } return val ; }
Hyp: 
function boost_hyperfactorial ( num ) { let val = 1 ; for ( let i = 1 ; i <= num ; i ++ ) { for ( let j = 1 ; j <= i ; j ++ ) { val *= i ; } } return val ; }

BLEU: 84.71
Edit Sim: 9


Src: 
bool checkPairs ( int l , int r ) { if ( ( l - r ) % 2 == 0 ) return false ; return true ; }
Ref: 
function checkPairs ( l , r ) { if ( ( l - r ) % 2 == 0 ) return false ; return true ; }
Hyp: 
function checkPairs ( l , r ) { if ( ( l - r ) % 2 == 0 ) return false ; return true ; }

BLEU: 100.0
Edit Sim: 0


Src: 
float ReuleauxArea ( float a ) { if ( a < 0 ) return -1 ; float A = 0.70477 * pow ( a , 2 ) ; return A ; }
Ref: 
function ReuleauxArea ( a ) { if ( a < 0 ) return - 1 ; var A = 0.70477 * Math . pow ( a , 2 ) ; return A ; }
Hyp: 
function ReuleauxArea ( a ) { if ( a < 0 ) return - 1 ; var A = 0.70477 * Math . pow ( a , 2 ) ; return A ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int multiplyBySevenByEight ( int n ) { return ( n - ( n >> 3 ) ) ; }
Ref: 
function multiplyBySevenByEight ( n ) { return ( n - ( n >> 3 ) ) ; }
Hyp: 
function multiplyBySevenByEight ( n ) { return ( n - ( n >> 3 ) ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int findNumber ( int n , int m ) { int num = ( m - 1 ) * 9 + n ; return num ; }
Ref: 
function findNumber ( n , m ) { var num = ( m - 1 ) * 9 + n ; return num ; }
Hyp: 
function findNumber ( n , m ) { let num = ( m - 1 ) * 9 + n ; return num ; }

BLEU: 89.42
Edit Sim: 3


Src: 
int countPairsWithDiffK ( int arr [ ] , int n , int k ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] - arr [ j ] == k arr [ j ] - arr [ i ] == k ) count ++ ; } return count ; }
Ref: 
function countPairsWithDiffK ( arr , n , k ) { count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] - arr [ j ] == k arr [ j ] - arr [ i ] == k ) count ++ ; } return count ; }
Hyp: 
function countPairsWithDiffK ( arr , n , k ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] - arr [ j ] == k arr [ j ] - arr [ i ] == k ) count ++ ; } return count ; }

BLEU: 96.78
Edit Sim: 4


Src: 
int maxvolume ( int s ) { int maxvalue = 0 ; for ( int i = 1 ; i <= s - 2 ; i ++ ) { for ( int j = 1 ; j <= s - 1 ; j ++ ) { int k = s - i - j ; maxvalue = max ( maxvalue , i * j * k ) ; } } return maxvalue ; }
Ref: 
function maxvolume ( s ) { let maxvalue = 0 ; for ( let i = 1 ; i <= s - 2 ; i ++ ) { for ( let j = 1 ; j <= s - 1 ; j ++ ) { let k = s - i - j ; maxvalue = Math . max ( maxvalue , i * j * k ) ; } } return maxvalue ; }
Hyp: 
function maxvolume ( s ) { let maxvalue = 0 ; for ( let i = 1 ; i <= s - 2 ; i ++ ) { for ( let j = 1 ; j <= s - 1 ; j ++ ) { let k = s - i - j ; maxvalue = Math . max ( maxvalue , i * j * k ) ; } } return maxvalue ; }

BLEU: 100.0
Edit Sim: 0


Src: 
Fraction maxFraction ( Fraction first , Fraction sec ) { int a = first . num ; int b = first . den ; int c = sec . num ; int d = sec . den ; int Y = a * d - b * c ; return ( Y > 0 ) ? first : sec ; }
Ref: 
function maxFraction ( first , sec ) { a = first [ 0 ] ; b = first [ 1 ] c = sec [ 0 ] ; d = sec [ 1 ] Y = a * d - b * c return ( Y > 0 ) ? first : sec ; }
Hyp: 
function maxFraction ( first , sec ) { let a = first . num ; let b = first . den ; let c = sec . num ; let d = sec . den ; let Y = a * d - b * c ; return ( Y > 0 ) ? first : sec ; }

BLEU: 52.74
Edit Sim: 40


Src: 
int Identity ( int num ) { int row , col ; for ( row = 0 ; row < num ; row ++ ) { for ( col = 0 ; col < num ; col ++ ) { if ( row == col ) cout << 1 << " ▁ " ; else cout << 0 << " ▁ " ; } cout << endl ; } return 0 ; }
Ref: 
function Identity ( num ) { var row ; var col ; for ( row = 0 ; row < num ; row ++ ) { for ( col = 0 ; col < num ; col ++ ) { if ( row == col ) document . write ( 1 + " " ) ; else document . write ( 0 + " " ) ; } document . write ( " " + " " ) ; } return 0 ; }
Hyp: 
function Identity ( num ) { let row , col ; for ( row = 0 ; row < num ; row ++ ) { for ( col = 0 ; col < num ; col ++ ) { if ( row == col ) document . write ( 1 + " " ) ; else document . write ( 0 + " " ) ; } document . write ( " " ) ; } return 0 ; }

BLEU: 89.68
Edit Sim: 14


Src: 
void print ( int p0 ) { int p1 , i = 0 , x , flag , k ; while ( 1 ) { flag = 1 ; x = ( int ) ( pow ( 2 , i ) ) ; p1 = x * p0 + ( x - 1 ) ; for ( k = 2 ; k < p1 ; k ++ ) { if ( p1 % k == 0 ) { flag = 0 ; break ; } } if ( flag == 0 ) break ; printf ( " % d ▁ " , p1 ) ; i ++ ; } }
Ref: 
function print_C ( p0 ) { let p1 = 0 ; let i = 0 ; let x ; let flag ; let k ; while ( 1 ) { flag = 1 ; x = Math . pow ( 2 , i ) ; p1 = x * p0 + ( x - 1 ) ; for ( let k = 2 ; k < p1 ; k ++ ) { if ( p1 % k == 0 ) { flag = 0 ; break ; } } if ( flag == 0 ) break ; document . write ( p1 + " " ) ; i ++ ; } }
Hyp: 
function print ( p0 ) { let p1 , i = 0 , x , flag , k ; while ( 1 ) { flag = 1 ; x = Math . pow ( 2 , i ) ; p1 = x * p0 + ( x - 1 ) ; for ( k = 2 ; k < p1 ; k ++ ) { if ( p1 % k == 0 ) { flag = 0 ; break ; } } if ( flag == 0 ) break ; document . write ( " " + p1 ) ; i ++ ; } }

BLEU: 78.9
Edit Sim: 36


Src: 
int calculateSum ( int n ) { return pow ( n * ( n + 1 ) / 2 , 2 ) ; }
Ref: 
function calculateSum ( n ) { return parseInt ( Math . pow ( n * ( n + 1 ) / 2 , 2 ) ) ; }
Hyp: 
function calculateSum ( n ) { return Math . pow ( n * ( n + 1 ) / 2 , 2 ) ; }

BLEU: 79.86
Edit Sim: 13


Src: 
int getHermiteNumber ( int n ) { if ( n == 0 ) return 1 ; if ( n == 1 ) return 0 ; else return -2 * ( n - 1 ) * getHermiteNumber ( n - 2 ) ; }
Ref: 
function getHermiteNumber ( n ) { if ( n == 0 ) return 1 ; else if ( n == 1 ) return 1 ; else return - 2 * ( n - 1 ) * getHermiteNumber ( n - 2 ) ; }
Hyp: 
function getHermiteNumber ( n ) { if ( n == 0 ) return 1 ; if ( n == 1 ) return 0 ; else return - 2 * ( n - 1 ) * getHermiteNumber ( n - 2 ) ; }

BLEU: 88.2
Edit Sim: 6


Src: 
float ellipsearea ( float r ) { if ( r < 0 ) return -1 ; float a = ( 3.14 * r * r ) / 4 ; return a ; }
Ref: 
function ellipsearea ( r ) { if ( r < 0 ) return - 1 ; var a = ( ( 3.14 * r * r ) / 4 ) ; return a ; }
Hyp: 
function ellipsearea ( r ) { if ( r < 0 ) return - 1 ; var a = ( 3.14 * r * r ) / 4 ; return a ; }

BLEU: 87.21
Edit Sim: 4


Src: 
int minAbsDiff ( int n ) { int left = 1 << ( ( int ) floor ( log2 ( n ) ) ) ; int right = left * 2 ; return min ( ( n - left ) , ( right - n ) ) ; }
Ref: 
function minAbsDiff ( n ) { let left = 1 << ( Math . floor ( Math . log ( n ) / Math . log ( 2 ) ) ) ; let right = left * 2 ; return Math . min ( ( n - left ) , ( right - n ) ) ; }
Hyp: 
function minAbsDiff ( n ) { let left = 1 << ( Math . floor ( Math . log2 ( n ) ) ) ; let right = left * 2 ; return Math . min ( ( n - left ) , ( right - n ) ) ; }

BLEU: 81.41
Edit Sim: 20


Src: 
bool isPalindrome ( int n ) { if ( n % 11 == 0 ) { return true ; } return false ; }
Ref: 
function isPalindrome ( n ) { if ( n % 11 == 0 ) { return true ; } return false ; }
Hyp: 
function isPalindrome ( n ) { if ( n % 11 == 0 ) { return true ; } return false ; }

BLEU: 100.0
Edit Sim: 0


Src: 
bool findWinner ( int N ) { return N & 1 ; }
Ref: 
function findWinner ( N ) { return N & 1 ; }
Hyp: 
function findWinner ( N ) { return N & 1 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int minInsertion ( string str ) { int n = str . length ( ) ; int res = 0 ; int count [ 26 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) count [ str [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < 26 ; i ++ ) if ( count [ i ] % 2 == 1 ) res ++ ; return ( res == 0 ) ? 0 : res - 1 ; }
Ref: 
function minInsertion ( str ) { let n = str . length ; let res = 0 ; let count = new Array ( 26 ) ; for ( let i = 0 ; i < count . length ; i ++ ) { count [ i ] = 0 ; } for ( let i = 0 ; i < n ; i ++ ) count [ str [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; for ( let i = 0 ; i < 26 ; i ++ ) { if ( count [ i ] % 2 == 1 ) res ++ ; } return ( res == 0 ) ? 0 : res - 1 ; }
Hyp: 
function minInsertion ( str ) { let n = str . length ; let res = 0 ; let count = new Array ( 26 ) . fill ( 0 ) ; for ( let i = 0 ; i < n ; i ++ ) count [ str [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; for ( let i = 0 ; i < 26 ; i ++ ) if ( count [ i ] % 2 == 1 ) res ++ ; return ( res == 0 ) ? 0 : res - 1 ; }

BLEU: 75.97
Edit Sim: 63


Src: 
int getValue ( int n ) { int i = 0 , k = 1 ; while ( i < n ) { i = i + k ; k = k * 2 ; } return k / 2 ; }
Ref: 
function getValue ( n ) { let i = 0 , k = 1 ; while ( i < n ) { i = i + k ; k = k * 2 ; } return parseInt ( k / 2 ) ; }
Hyp: 
function getValue ( n ) { let i = 0 , k = 1 ; while ( i < n ) { i = i + k ; k = k * 2 ; } return k / 2 ; }

BLEU: 86.39
Edit Sim: 13


Src: 
float polyapothem ( float n , float a ) { if ( a < 0 && n < 0 ) return -1 ; return a / ( 2 * tan ( ( 180 / n ) * 3.14159 / 180 ) ) ; }
Ref: 
function polyapothem ( n , a ) { if ( a < 0 && n < 0 ) return - 1 ; return ( a / ( 2 * Math . tan ( ( 180 / n ) * 3.14159 / 180 ) ) ) ; }
Hyp: 
function polyapothem ( n , a ) { if ( a < 0 && n < 0 ) return - 1 ; return a / ( 2 * Math . tan ( ( 180 / n ) * 3.14159 / 180 ) ) ; }

BLEU: 91.75
Edit Sim: 4


Src: 
int findSum ( int n ) { return ( pow ( 10 , n + 1 ) * ( 9 * n - 1 ) + 10 ) / pow ( 9 , 3 ) - n * ( n + 1 ) / 18 ; }
Ref: 
function calculateSum ( n ) { return ( parseInt ( Math . pow ( 10 , n + 1 ) ) * ( 9 * n - 1 ) + 10 ) / parseInt ( Math . pow ( 9 , 3 ) ) - n * ( n + 1 ) / 18 ; }
Hyp: 
function findSum ( n ) { return ( ( Math . pow ( 10 , n + 1 ) * ( 9 * n - 1 ) + 10 ) / Math . pow ( 9 , 3 ) - n * ( n + 1 ) / 18 ; }

BLEU: 78.89
Edit Sim: 33


Src: 
int countOddSquares ( int n , int m ) { return ( int ) pow ( m , 0.5 ) - ( int ) pow ( n - 1 , 0.5 ) ; }
Ref: 
function countOddSquares ( n , m ) { return Math . pow ( m , 0.5 ) - Math . pow ( n - 1 , 0.5 ) ; }
Hyp: 
function countOddSquares ( n , m ) { return ( int ) Math . pow ( m , 0.5 ) - ( int ) Math . pow ( n - 1 , 0.5 ) ; }

BLEU: 74.08
Edit Sim: 16


Src: 
float hexagonside ( float a ) { if ( a < 0 ) return -1 ; float x = 0.5176 * a ; return x ; }
Ref: 
function hexagonside ( a ) { if ( a < 0 ) return - 1 ; let x = 0.5176 * a ; return x ; }
Hyp: 
function hexagonside ( a ) { if ( a < 0 ) return - 1 ; var x = 0.5176 * a ; return x ; }

BLEU: 90.25
Edit Sim: 3


Src: 
int countBits ( int n ) { int count = 0 ; while ( n ) { count ++ ; n >>= 1 ; } return count ; }
Ref: 
function countBits ( n ) { var count = 0 ; while ( n ) { count ++ ; n >>= 1 ; } return count ; }
Hyp: 
function countBits ( n ) { var count = 0 ; while ( n ) { count ++ ; n >>= 1 ; } return count ; }

BLEU: 100.0
Edit Sim: 0


Src: 
void meanVector ( int mat [ rows ] [ cols ] ) { cout << " [ ▁ " ; for ( int i = 0 ; i < rows ; i ++ ) { double mean = 0.00 ; int sum = 0 ; for ( int j = 0 ; j < cols ; j ++ ) sum += mat [ j ] [ i ] ; mean = sum / rows ; cout << mean << " ▁ " ; } cout << " ] " ; }
Ref: 
function meanVector ( mat ) { document . write ( " " ) ; for ( var i = 0 ; i < rows ; i ++ ) { var mean = 0.00 ; var sum = 0 ; for ( var j = 0 ; j < cols ; j ++ ) sum += mat [ j ] [ i ] ; mean = sum / rows ; document . write ( mean + " " ) ; } document . write ( " " ) ; }
Hyp: 
function meanVector ( mat ) { document . write ( " " ) ; for ( var i = 0 ; i < rows ; i ++ ) { var mean = 0.00 ; var sum = 0 ; for ( var j = 0 ; j < cols ; j ++ ) sum += mat [ j ] [ i ] ; mean = sum / rows ; document . write ( mean + " " ) ; } document . write ( " " ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
void translate ( char * str ) { if ( str [ 0 ] == ' ' ) return ; for ( int i = 1 ; str [ i ] != ' ' ; i ++ ) { if ( str [ i - 1 ] == ' A ' && str [ i ] == ' B ' ) { str [ i - 1 ] = ' C ' ; for ( int j = i ; str [ j ] != ' ' ; j ++ ) str [ j ] = str [ j + 1 ] ; } } return ; }
Ref: 
function translate ( str ) { for ( let i = 1 ; i < str . length ; i ++ ) { if ( str [ i - 1 ] == ' ' && str [ i ] == ' ' ) { str [ i - 1 ] = ' ' ; let j ; for ( j = i ; j < str . length - 1 ; j ++ ) str [ j ] = str [ j + 1 ] ; str [ j ] = ' ' ; } } return ; }
Hyp: 
function translate ( str ) { if ( str [ 0 ] == ' ' ) return ; if ( str [ 1 ] == ' ' ) { if ( str [ i - 1 ] == ' ' && str [ i ] == ' ' ) { str [ i - 1 ] = ' ' ; for ( let j = i ; str [ j ] != ' ' ; j ++ ) str [ j ] = str [ j + 1 ] ; } } return ; }

BLEU: 66.48
Edit Sim: 79


Src: 
int CountDigits ( int n ) { if ( n == 1 ) return 1 ; double sum = 0 ; for ( int i = 2 ; i <= n ; ++ i ) { sum += ( double ) log ( i ) / ( double ) log ( 10 ) ; } sum *= ( double ) n ; }
Ref: 
function CountDigits ( n ) { if ( n == 1 ) return 1 ; var sum = 0 ; for ( i = 2 ; i <= n ; ++ i ) { sum += ( Math . log ( i ) / Math . log ( 10 ) ) ; } sum *= n ; return Math . ceil ( sum ) ; }
Hyp: 
function CountDigits ( n ) { if ( n == 1 ) return 1 ; let sum = 0 ; for ( let i = 2 ; i <= n ; ++ i ) { sum += Math . log ( i ) / Math . log ( 10 ) ; } sum *= ( double ) n ; return sum ; }

BLEU: 74.12
Edit Sim: 32


Src: 
string possibleToSort ( int * arr , int n , string str ) { int max_element = -1 ; for ( long i = 0 ; i < str . size ( ) ; i ++ ) { max_element = max ( max_element , arr [ i ] ) ; if ( str [ i ] == '0' ) { if ( max_element > i + 1 ) return " No " ; } } return " Yes " ; }
Ref: 
function possibleToSort ( arr , n , str ) { let max_element = - 1 ; for ( let i = 0 ; i < str . length ; i ++ ) { max_element = Math . max ( max_element , arr [ i ] ) ; if ( str [ i ] == ' ' ) { if ( max_element > i + 1 ) return " " ; } } return " " ; }
Hyp: 
function possibleToSort ( arr , n , str ) { let max_element = - 1 ; for ( let i = 0 ; i < str . length ; i ++ ) { max_element = Math . max ( max_element , arr [ i ] ) ; if ( str [ i ] == ' ' ) { if ( max_element > i + 1 ) return " " ; } } return " " ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int lastFiveDigits ( int n ) { n = ( n / 10000 ) * 10000 + ( ( n / 100 ) % 10 ) * 1000 + ( n % 10 ) * 100 + ( ( n / 10 ) % 10 ) * 10 + ( n / 1000 ) % 10 ; int ans = 1 ; for ( int i = 0 ; i < 5 ; i ++ ) { ans *= n ; ans %= 100000 ; } printf ( " % 05d " , ans ) ; }
Ref: 
function lastFiveDigits ( n ) { n = ( Math . floor ( n / 10000 ) ) * 10000 + ( Math . floor ( n / 100 ) % 10 ) * 1000 + ( n % 10 ) * 100 + ( Math . floor ( n / 10 ) % 10 ) * 10 + Math . floor ( n / 1000 ) % 10 ; let ans = 1 ; for ( let i = 0 ; i < 5 ; i ++ ) { ans *= n ; ans %= 100000 ; } document . write ( ans ) ; }
Hyp: 
function lastFiveDigits ( n ) { n = parseInt ( ( n / 10000 ) * 10000 + ( ( n / 100 ) % 10 ) * 1000 + ( n % 10 ) * 100 + ( ( n / 10 ) % 10 ) * 10 + ( n / 1000 ) % 10 ; let ans = 1 ; for ( let i = 0 ; i < 5 ; i ++ ) { ans *= n ; ans %= 100000 ; } document . write ( " " + ans ) ; }

BLEU: 78.73
Edit Sim: 60


Src: 
int lcs ( string & X , string & Y ) { int m = X . length ( ) , n = Y . length ( ) ; int L [ 2 ] [ n + 1 ] ; bool bi ; for ( int i = 0 ; i <= m ; i ++ ) { bi = i & 1 ; for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) L [ bi ] [ j ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) L [ bi ] [ j ] = L [ 1 - bi ] [ j - 1 ] + 1 ; else L [ bi ] [ j ] = max ( L [ 1 - bi ] [ j ] , L [ bi ] [ j - 1 ] ) ; } } return L [ bi ] [ n ] ; }
Ref: 
function lcs ( X , Y ) { let m = X . length , n = Y . length ; let L = new Array ( 2 ) ; for ( let i = 0 ; i < 2 ; i ++ ) { L [ i ] = new Array ( n + 1 ) ; for ( let j = 0 ; j < n + 1 ; j ++ ) { L [ i ] [ j ] = 0 ; } } let bi = 0 ; for ( let i = 0 ; i <= m ; i ++ ) { bi = i & 1 ; for ( let j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) L [ bi ] [ j ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) L [ bi ] [ j ] = L [ 1 - bi ] [ j - 1 ] + 1 ; else L [ bi ] [ j ] = Math . max ( L [ 1 - bi ] [ j ] , L [ bi ] [ j - 1 ] ) ; } } return L [ bi ] [ n ] ; }
Hyp: 
function lcs ( X , Y ) { var m = X . length , n = Y . length ; var L = new Array ( 2 ) ; for ( var i = 0 ; i <= m ; i ++ ) { bi = i & 1 ; for ( var j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) L [ bi ] [ j ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) L [ bi ] [ j ] = Math . max ( L [ 1 - bi ] [ j ] , L [ bi ] [ j - 1 ] ) ; } } return L [ bi ] [ n ] ; }

BLEU: 52.22
Edit Sim: 204


Src: 
bool checkStar ( int mat [ ] [ size ] ) { int vertexD1 = 0 , vertexDn_1 = 0 ; if ( size == 1 ) return ( mat [ 0 ] [ 0 ] == 0 ) ; if ( size == 2 ) return ( mat [ 0 ] [ 0 ] == 0 && mat [ 0 ] [ 1 ] == 1 && mat [ 1 ] [ 0 ] == 1 && mat [ 1 ] [ 1 ] == 0 ) ; for ( int i = 0 ; i < size ; i ++ ) { int degreeI = 0 ; for ( int j = 0 ; j < size ; j ++ ) if ( mat [ i ] [ j ] ) degreeI ++ ; if ( degreeI == 1 ) vertexD1 ++ ; else if ( degreeI == size - 1 ) vertexDn_1 ++ ; } return ( vertexD1 == ( size - 1 ) && vertexDn_1 == 1 ) ; }
Ref: 
function checkStar ( mat ) { var vertexD1 = 0 , vertexDn_1 = 0 ; if ( size == 1 ) return ( mat [ 0 ] [ 0 ] == 0 ) ; if ( size == 2 ) return ( mat [ 0 ] [ 0 ] == 0 && mat [ 0 ] [ 1 ] == 1 && mat [ 1 ] [ 0 ] == 1 && mat [ 1 ] [ 1 ] == 0 ) ; for ( var i = 0 ; i < size ; i ++ ) { var degreeI = 0 ; for ( var j = 0 ; j < size ; j ++ ) if ( mat [ i ] [ j ] ) degreeI ++ ; if ( degreeI == 1 ) vertexD1 ++ ; else if ( degreeI == size - 1 ) vertexDn_1 ++ ; } return ( vertexD1 == ( size - 1 ) && vertexDn_1 == 1 ) ; }
Hyp: 
function checkStar ( mat ) { var vertexD1 = 0 , vertexDn_1 = 0 ; if ( size == 1 ) return ( mat [ 0 ] [ 0 ] == 0 ) ; if ( size == 2 ) return ( mat [ 0 ] [ 0 ] == 0 && mat [ 0 ] [ 1 ] == 1 && mat [ 1 ] [ 1 ] == 0 ) ; for ( var i = 0 ; i < size ; i ++ ) { var degreeI = 0 ; for ( var j = 0 ; j < size ; j ++ ) if ( mat [ i ] [ j ] ) degreeI ++ ; if ( degreeI == 1 ) vertexD1 ++ ; else if ( degreeI == size - 1 ) vertexDn_1 ++ ; } return ( vertexD1 == ( size - 1 ) && vertexDn_1 == 1 ) ; }

BLEU: 93.87
Edit Sim: 24


Src: 
int findgroups ( int arr [ ] , int n ) { int c [ 3 ] = { 0 } , i ; int res = 0 ; for ( i = 0 ; i < n ; i ++ ) c [ arr [ i ] % 3 ] ++ ; res += ( ( c [ 0 ] * ( c [ 0 ] - 1 ) ) >> 1 ) ; res += c [ 1 ] * c [ 2 ] ; res += ( c [ 0 ] * ( c [ 0 ] - 1 ) * ( c [ 0 ] - 2 ) ) / 6 ; res += ( c [ 1 ] * ( c [ 1 ] - 1 ) * ( c [ 1 ] - 2 ) ) / 6 ; res += ( ( c [ 2 ] * ( c [ 2 ] - 1 ) * ( c [ 2 ] - 2 ) ) / 6 ) ; res += c [ 0 ] * c [ 1 ] * c [ 2 ] ; return res ; }
Ref: 
function findgroups ( arr , n ) { let c = [ 0 , 0 , 0 ] ; let i ; let res = 0 ; for ( i = 0 ; i < n ; i ++ ) c [ arr [ i ] % 3 ] ++ ; res += ( ( c [ 0 ] * ( c [ 0 ] - 1 ) ) >> 1 ) ; res += c [ 1 ] * c [ 2 ] ; res += ( c [ 0 ] * ( c [ 0 ] - 1 ) * Math . floor ( ( c [ 0 ] - 2 ) ) / 6 ) ; res += ( c [ 1 ] * ( c [ 1 ] - 1 ) * Math . floor ( ( c [ 1 ] - 2 ) ) / 6 ) ; res += ( Math . floor ( c [ 2 ] * ( c [ 2 ] - 1 ) * ( c [ 2 ] - 2 ) ) / 6 ) ; res += c [ 0 ] * c [ 1 ] * c [ 2 ] ; return res ; }
Hyp: 
function findgroups ( arr , n ) { let c = Array ( 3 ) . fill ( 0 ) ; let res = 0 ; for ( let i = 0 ; i < n ; i ++ ) c [ arr [ i ] % 3 ] ++ ; res += ( ( c [ 0 ] * ( c [ 0 ] - 1 ) ) >> 1 ) ; res += c [ 1 ] * c [ 2 ] ; res += ( c [ 0 ] * ( c [ 0 ] - 2 ) ) / 6 ; res += ( ( c [ 1 ] * ( c [ 1 ] - 1 ) * ( c [ 1 ] - 2 ) ) / 6 ; res += ( c [ 2 ] * ( c [ 2 ] - 1 ) * ( c [ 2 ] - 2 ) ) / 6 ) ; res += c [ 0 ] * c [ 1 ] * c [ 2 ] ; return res ; }

BLEU: 81.04
Edit Sim: 90


Src: 
int countDigits ( int a , int b ) { if ( a == 0 b == 0 ) return 1 ; return floor ( log10 ( abs ( a ) ) + log10 ( abs ( b ) ) ) + 1 ; }
Ref: 
function countDigits ( a , b ) { if ( a == 0 b == 0 ) return 1 ; return Math . floor ( Math . log10 ( Math . abs ( a ) ) + Math . log10 ( Math . abs ( b ) ) ) + 1 ; }
Hyp: 
function countDigits ( a , b ) { if ( a == 0 b == 0 ) return 1 ; return Math . floor ( Math . log10 ( Math . abs ( a ) ) + Math . log10 ( Math . abs ( b ) ) ) + 1 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int findMinDiff ( int arr [ ] , int n , int m ) { if ( m == 0 n == 0 ) return 0 ; sort ( arr , arr + n ) ; if ( n < m ) return -1 ; int min_diff = INT_MAX ; for ( int i = 0 ; i + m - 1 < n ; i ++ ) { int diff = arr [ i + m - 1 ] - arr [ i ] ; if ( diff < min_diff ) min_diff = diff ; } return min_diff ; }
Ref: 
function findMinDiff ( arr , n , m ) { if ( m == 0 n == 0 ) return 0 ; arr . sort ( function ( a , b ) { return a - b } ) ; if ( n < m ) return - 1 ; let min_diff = Number . MAX_VALUE ; for ( let i = 0 ; i + m - 1 < n ; i ++ ) { let diff = arr [ i + m - 1 ] - arr [ i ] ; if ( diff < min_diff ) min_diff = diff ; } return min_diff ; }
Hyp: 
function findMinDiff ( arr , n , m ) { if ( m == 0 n == 0 ) return 0 ; arr . sort ( ( a , b ) => a - b ) ; if ( n < m ) return - 1 ; let min_diff = Number . MAX_VALUE ; for ( let i = 0 ; i + m - 1 < n ; i ++ ) { let diff = arr [ i + m - 1 ] - arr [ i ] ; if ( diff < min_diff ) min_diff = diff ; } return min_diff ; }

BLEU: 91.98
Edit Sim: 19


Src: 
long countWays ( int n ) { long dp [ 2 ] [ n + 1 ] ; dp [ 0 ] [ 1 ] = 1 ; dp [ 1 ] [ 1 ] = 2 ; for ( int i = 2 ; i <= n ; i ++ ) { dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + dp [ 1 ] [ i - 1 ] ; dp [ 1 ] [ i ] = dp [ 0 ] [ i - 1 ] * 2 + dp [ 1 ] [ i - 1 ] ; } return dp [ 0 ] [ n ] + dp [ 1 ] [ n ] ; }
Ref: 
function countWays ( n ) { let dp = new Array ( 2 ) ; for ( let i = 0 ; i < 2 ; i ++ ) { dp [ i ] = new Array ( n + 1 ) ; } dp [ 0 ] [ 1 ] = 1 ; dp [ 1 ] [ 1 ] = 2 ; for ( let i = 2 ; i <= n ; i ++ ) { dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + dp [ 1 ] [ i - 1 ] ; dp [ 1 ] [ i ] = dp [ 0 ] [ i - 1 ] * 2 + dp [ 1 ] [ i - 1 ] ; } return dp [ 0 ] [ n ] + dp [ 1 ] [ n ] ; }
Hyp: 
function countWays ( n ) { let dp = new Array ( 2 ) ; for ( let i = 2 ; i <= n ; i ++ ) { dp [ 0 ] [ i ] = 1 ; dp [ 1 ] [ 1 ] = 2 ; for ( let i = 2 ; i <= n ; i ++ ) { dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + dp [ 1 ] [ i - 1 ] ; dp [ 1 ] [ i ] = dp [ 0 ] [ i - 1 ] * 2 + dp [ 1 ] [ i - 1 ] ; } return dp [ 0 ] [ n ] + dp [ 1 ] [ n ] ; }

BLEU: 86.71
Edit Sim: 39


Src: 
int findIndex ( int arr [ ] , int len ) { int maxIndex = 0 ; for ( int i = 0 ; i < len ; ++ i ) if ( arr [ i ] > arr [ maxIndex ] ) maxIndex = i ; for ( int i = 0 ; i < len ; ++ i ) if ( maxIndex != i && arr [ maxIndex ] < 2 * arr [ i ] ) return -1 ; return maxIndex ; }
Ref: 
function findIndex ( arr , len ) { let maxIndex = 0 ; for ( let i = 0 ; i < len ; ++ i ) if ( arr [ i ] > arr [ maxIndex ] ) maxIndex = i ; for ( let i = 0 ; i < len ; ++ i ) if ( maxIndex != i && arr [ maxIndex ] < 2 * arr [ i ] ) return - 1 ; return maxIndex ; }
Hyp: 
function findIndex ( arr , len ) { let maxIndex = 0 ; for ( let i = 0 ; i < len ; ++ i ) if ( arr [ i ] > arr [ maxIndex ] ) maxIndex = i ; for ( let i = 0 ; i < len ; ++ i ) if ( maxIndex != i && arr [ maxIndex ] < 2 * arr [ i ] ) return - 1 ; return maxIndex ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int minimumflip ( int mat [ ] [ N ] , int n ) { int flip = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) flip ++ ; return flip ; }
Ref: 
function minimumflip ( mat , n ) { let flip = 0 ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = 0 ; j < i ; j ++ ) if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) flip ++ ; return flip ; }
Hyp: 
function minimumflip ( mat , n ) { let flip = 0 ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = 0 ; j < i ; j ++ ) if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) flip ++ ; return flip ; }

BLEU: 100.0
Edit Sim: 0


Src: 
bool checkIndices ( int Arr [ ] , int N ) { for ( int i = 0 ; i < N - 1 ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( Arr [ i ] != Arr [ j ] ) { if ( Arr [ Arr [ i ] - 1 ] == Arr [ Arr [ j ] - 1 ] ) return true ; } } } return false ; }
Ref: 
function checkIndices ( Arr , N ) { for ( var i = 0 ; i < N - 1 ; i ++ ) { for ( var j = i + 1 ; j < N ; j ++ ) { if ( Arr [ i ] != Arr [ j ] ) { if ( Arr [ Arr [ i ] - 1 ] == Arr [ Arr [ j ] - 1 ] ) return true ; } } } return false ; }
Hyp: 
function checkIndices ( Arr , N ) { for ( let i = 0 ; i < N - 1 ; i ++ ) { for ( let j = i + 1 ; j < N ; j ++ ) { if ( Arr [ i ] != Arr [ j ] ) { if ( Arr [ Arr [ i ] - 1 ] == Arr [ Arr [ j ] - 1 ] ) return true ; } } } return false ; }

BLEU: 94.15
Edit Sim: 6


Src: 
int countOddPair ( int A [ ] , int N ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( ! ( A [ i ] & 1 ) ) count ++ ; int evenPairCount = count * ( count - 1 ) / 2 ; int totPairs = N * ( N - 1 ) / 2 ; return totPairs - evenPairCount ; }
Ref: 
function countOddPair ( A , N ) { let count = 0 ; for ( let i = 0 ; i < N ; i ++ ) if ( ! ( A [ i ] & 1 ) ) count ++ ; let evenPairCount = parseInt ( count * ( count - 1 ) / 2 ) ; let totPairs = parseInt ( N * ( N - 1 ) / 2 ) ; return totPairs - evenPairCount ; }
Hyp: 
function countOddPair ( A , N ) { var count = 0 ; for ( var i = 0 ; i < N ; i ++ ) if ( ( A [ i ] & 1 ) == 0 ) count ++ ; var evenPairCount = count * ( count - 1 ) / 2 ; var totPairs = N * ( N - 1 ) / 2 ; return totPairs - evenPairCount ; }

BLEU: 67.4
Edit Sim: 45


Src: 
float AvgofSquareN ( int n ) { float sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += ( i * i ) ; return sum / n ; }
Ref: 
function AvgofSquareN ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) sum += ( i * i ) ; return sum / n ; }
Hyp: 
function AvgofSquareN ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) sum += ( i * i ) ; return sum / n ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int getHCF ( int x , int y ) { int minimum = min ( x , y ) ; if ( x % minimum == 0 && y % minimum == 0 ) return minimum ; for ( int i = minimum / 2 ; i >= 2 ; i -- ) { if ( x % i == 0 && y % i == 0 ) return i ; } return 1 ; }
Ref: 
function getHCF ( x , y ) { var minimum = Math . min ( x , y ) ; if ( x % minimum == 0 && y % minimum == 0 ) return minimum ; for ( var i = minimum / 2 ; i >= 2 ; i -- ) { if ( x % i == 0 && y % i == 0 ) return i ; } return 1 ; }
Hyp: 
function getHCF ( x , y ) { let minimum = Math . min ( x , y ) ; if ( x % minimum == 0 && y % minimum == 0 ) return minimum ; for ( let i = minimum / 2 ; i >= 2 ; i -- ) { if ( x % i == 0 && y % i == 0 ) return i ; } return 1 ; }

BLEU: 93.28
Edit Sim: 6


Src: 
int search ( int arr [ ] , int n , int x ) { int i ; for ( i = 0 ; i < n ; i ++ ) if ( arr [ i ] == x ) return i ; return -1 ; }
Ref: 
function search ( arr , n , x ) { let i ; for ( i = 0 ; i < n ; i ++ ) if ( arr [ i ] == x ) return i ; return - 1 ; }
Hyp: 
function search ( arr , n , x ) { let i ; for ( i = 0 ; i < n ; i ++ ) if ( arr [ i ] == x ) return i ; return - 1 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
bool checkMarkov ( double m [ ] [ n ] ) { for ( int i = 0 ; i < n ; i ++ ) { double sum = 0 ; for ( int j = 0 ; j < n ; j ++ ) sum = sum + m [ i ] [ j ] ; if ( sum != 1 ) return false ; } return true ; }
Ref: 
function checkMarkov ( m ) { for ( let i = 0 ; i < n ; i ++ ) { let sum = 0 ; for ( let j = 0 ; j < n ; j ++ ) sum = sum + m [ i ] [ j ] ; if ( sum != 1 ) return false ; } return true ; }
Hyp: 
function checkMarkov ( m ) { for ( let i = 0 ; i < n ; i ++ ) { let sum = 0 ; for ( let j = 0 ; j < n ; j ++ ) sum = sum + m [ i ] [ j ] ; if ( sum != 1 ) return false ; } return true ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int findMaximumPieces ( int n ) { return 1 + n * ( n + 1 ) / 2 ; }
Ref: 
function findMaximumPieces ( n ) { return 1 + n * ( n + 1 ) / 2 ; }
Hyp: 
function findMaximumPieces ( n ) { return 1 + n * ( n + 1 ) / 2 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
void printSorted ( int a , int b , int c ) { int get_max = max ( a , max ( b , c ) ) ; int get_min = - max ( - a , max ( - b , - c ) ) ; int get_mid = ( a + b + c ) - ( get_max + get_min ) ; cout << get_min << " ▁ " << get_mid << " ▁ " << get_max ; }
Ref: 
function printSorted ( a , b , c ) { let get_max = Math . max ( a , Math . max ( b , c ) ) ; let get_min = - Math . max ( - a , Math . max ( - b , - c ) ) ; let get_mid = ( a + b + c ) - ( get_max + get_min ) ; document . write ( get_min + " " + get_mid + " " + get_max ) ; }
Hyp: 
function printSorted ( a , b , c ) { let get_max = Math . max ( a , Math . max ( b , c ) ) ; let get_min = Math . max ( - a , Math . max ( - b , - c ) ) ; let get_mid = ( a + b + c ) - ( get_max + get_min ) ; document . write ( get_min + " " + get_mid + " " + get_max ) ; }

BLEU: 97.08
Edit Sim: 2


Src: 
int findMaximumPieces ( int n ) { return 1 + n * ( n + 1 ) / 2 ; }
Ref: 
function findMaximumPieces ( n ) { return 1 + n * ( n + 1 ) / 2 ; }
Hyp: 
function findMaximumPieces ( n ) { return 1 + n * ( n + 1 ) / 2 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
string isAMultipleOf4 ( int n ) { if ( ( n & 3 ) == 0 ) return " Yes " ; return " No " ; }
Ref: 
function isAMultipleOf4 ( n ) { if ( ( n & 3 ) == 0 ) return true ; return false ; }
Hyp: 
function isAMultipleOf4 ( n ) { if ( ( n & 3 ) == 0 ) return " " ; return " " ; }

BLEU: 72.72
Edit Sim: 9


Src: 
int heptagonalNumber ( int n ) { return ( ( 5 * n * n ) - ( 3 * n ) ) / 2 ; }
Ref: 
function heptagonalNumber ( n ) { return parseInt ( ( ( 5 * n * n ) - ( 3 * n ) ) / 2 ) ; }
Hyp: 
function heptagonalNumber ( n ) { return ( ( 5 * n * n ) - ( 3 * n ) ) / 2 ; }

BLEU: 78.87
Edit Sim: 13


Src: 
int MinimumMoves ( int a [ ] , int n , int x ) { int ans = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] <= a [ i - 1 ] ) { int p = ( a [ i - 1 ] - a [ i ] ) / x + 1 ; ans += p ; a [ i ] += p * x ; } } return ans ; }
Ref: 
function MinimumMoves ( a , n , x ) { var ans = 0 ; for ( i = 1 ; i < n ; i ++ ) { if ( a [ i ] <= a [ i - 1 ] ) { var p = parseInt ( ( a [ i - 1 ] - a [ i ] ) / x + 1 ) ; ans += p ; a [ i ] += p * x ; } } return ans ; }
Hyp: 
function MinimumMoves ( a , n , x ) { let ans = 0 ; for ( let i = 1 ; i < n ; i ++ ) { if ( a [ i ] <= a [ i - 1 ] ) { let p = ( a [ i - 1 ] - a [ i ] ) / x + 1 ; ans += p ; a [ i ] += p * x ; } } return ans ; }

BLEU: 85.52
Edit Sim: 23


Src: 
float octadiagonal ( float a ) { if ( a < 0 ) return -1 ; return a * sqrt ( 4 + ( 2 * sqrt ( 2 ) ) ) ; }
Ref: 
function octadiagonal ( a ) { if ( a < 0 ) return - 1 ; return a * Math . sqrt ( 4 + ( 2 * Math . sqrt ( 2 ) ) ) ; }
Hyp: 
function octadiagonal ( a ) { if ( a < 0 ) return - 1 ; return a * Math . sqrt ( 4 + ( 2 * Math . sqrt ( 2 ) ) ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int subsetXOR ( int arr [ ] , int n , int k ) { int max_ele = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] > max_ele ) max_ele = arr [ i ] ; int m = ( 1 << ( int ) ( log2 ( max_ele ) + 1 ) ) - 1 ; if ( k > m ) return 0 ; int dp [ n + 1 ] [ m + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= m ; j ++ ) dp [ i ] [ j ] = 0 ; dp [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 0 ; j <= m ; j ++ ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j ^ arr [ i - 1 ] ] ; return dp [ n ] [ k ] ; }
Ref: 
function subsetXOR ( arr , n , k ) { let max_ele = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) if ( arr [ i ] > max_ele ) max_ele = arr [ i ] ; let m = ( 1 << parseInt ( Math . log ( max_ele ) / Math . log ( 2 ) + 1 , 10 ) ) - 1 ; if ( k > m ) { return 0 ; } let dp = new Array ( n + 1 ) ; for ( let i = 0 ; i <= n ; i ++ ) { dp [ i ] = new Array ( m + 1 ) ; for ( let j = 0 ; j <= m ; j ++ ) { dp [ i ] [ j ] = 0 ; } } dp [ 0 ] [ 0 ] = 1 ; for ( let i = 1 ; i <= n ; i ++ ) for ( let j = 0 ; j <= m ; j ++ ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j ^ arr [ i - 1 ] ] ; return dp [ n ] [ k ] ; }
Hyp: 
function subsetXOR ( arr , n , k ) { let max_ele = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) if ( arr [ i ] > max_ele ) max_ele = arr [ i ] ; let m = ( 1 << ( Math . log2 ( max_ele ) + 1 ) ) - 1 ; if ( k > m ) return 0 ; let dp = new Array ( n + 1 ) ; for ( let i = 0 ; i <= n ; i ++ ) for ( let j = 0 ; j <= m ; j ++ ) dp [ i ] [ j ] = 0 ; dp [ 0 ] [ 0 ] = 1 ; for ( let i = 1 ; i <= n ; i ++ ) for ( let j = 0 ; j <= m ; j ++ ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j ^ arr [ i - 1 ] ] ; return dp [ n ] [ k ] ; }

BLEU: 81.39
Edit Sim: 79


Src: 
void findRightAngle ( int A , int H ) { long D = pow ( H , 4 ) - 16 * A * A ; if ( D >= 0 ) { long root1 = ( H * H + sqrt ( D ) ) / 2 ; long root2 = ( H * H - sqrt ( D ) ) / 2 ; long a = sqrt ( root1 ) ; long b = sqrt ( root2 ) ; if ( b >= a ) cout << a << " ▁ " << b << " ▁ " << H ; else cout << b << " ▁ " << a << " ▁ " << H ; } else cout << " - 1" ; }
Ref: 
function findRightAngle ( A , H ) { let D = Math . pow ( H , 4 ) - 16 * A * A ; if ( D >= 0 ) { let root1 = ( H * H + Math . sqrt ( D ) ) / 2 ; let root2 = ( H * H - Math . sqrt ( D ) ) / 2 ; let a = Math . sqrt ( root1 ) ; let b = Math . sqrt ( root2 ) ; if ( b >= a ) document . write ( a + " " + b + " " + H + " " ) ; else document . write ( b + " " + a + " " + H + " " ) ; } else document . write ( " " ) ; }
Hyp: 
function findRightAngle ( A , H ) { let D = Math . pow ( H , 4 ) - 16 * A * A ; if ( D >= 0 ) { let root1 = ( H * H + Math . sqrt ( D ) ) / 2 ; let root2 = ( H * H - Math . sqrt ( D ) ) / 2 ; let a = Math . sqrt ( root1 ) ; let b = Math . sqrt ( root2 ) ; if ( b >= a ) document . write ( a + " " + b + " " + H ; else document . write ( b + " " + a + " " + H ) ; } else document . write ( " " - 1 ) ; }

BLEU: 92.06
Edit Sim: 18


Src: 
int countWays ( int n ) { for ( int i = 1 ; i < n ; i ++ ) for ( int j = i ; j < n ; j ++ ) for ( int k = j ; k < n ; k ++ ) for ( int l = k ; l < n ; l ++ ) if ( i + j + k + l == n ) counter ++ ; return counter ; }
Ref: 
function countWays ( n ) { for ( let i = 1 ; i < n ; i ++ ) for ( let j = i ; j < n ; j ++ ) for ( let k = j ; k < n ; k ++ ) for ( let l = k ; l < n ; l ++ ) if ( i + j + k + l == n ) counter ++ ; return counter ; }
Hyp: 
function countWays ( n ) { for ( let i = 1 ; i < n ; i ++ ) for ( let j = i ; j < n ; j ++ ) for ( let k = j ; k < n ; k ++ ) for ( let l = k ; l < n ; l ++ ) if ( i + j + k + l == n ) counter ++ ; return counter ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int swapBits ( unsigned int x ) { unsigned int even_bits = x & 0xAAAAAAAA ; unsigned int odd_bits = x & 0x55555555 ; even_bits >>= 1 ; odd_bits <<= 1 ; return ( even_bits odd_bits ) ; }
Ref: 
function swapBits ( x ) { even_bits = x & 0xAAAAAAAA ; odd_bits = x & 0x55555555 ; even_bits >>= 1 ; odd_bits <<= 1 ; return ( even_bits odd_bits ) ; }
Hyp: 
function swapBits ( x ) { var even_bits = x & 0xAAAAAAAA ; var odd_bits = x & 0x55555555 ; even_bits >>= 1 ; odd_bits <<= 1 ; return ( even_bits odd_bits ) ; }

BLEU: 85.0
Edit Sim: 8


Src: 
int findOddPair ( int A [ ] , int N ) { int i , count = 0 ; for ( i = 0 ; i < N ; i ++ ) { if ( A [ i ] % 2 == 0 ) count ++ ; } return count * ( N - count ) ; }
Ref: 
function findOddPair ( A , N ) { let i , count = 0 ; for ( i = 0 ; i < N ; i ++ ) { if ( A [ i ] % 2 == 0 ) count ++ ; } return count * ( N - count ) ; }
Hyp: 
function findOddPair ( A , N ) { let i , count = 0 ; for ( i = 0 ; i < N ; i ++ ) { if ( A [ i ] % 2 == 0 ) count ++ ; } return count * ( N - count ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
float hexagonArea ( float d ) { return ( 3 * sqrt ( 3 ) * pow ( d , 2 ) ) / 8 ; }
Ref: 
function hexagonArea ( d ) { return ( 3 * Math . sqrt ( 3 ) * Math . pow ( d , 2 ) ) / 8 ; }
Hyp: 
function hexagonArea ( d ) { return ( 3 * Math . sqrt ( 3 ) * Math . pow ( d , 2 ) ) / 8 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
bool isValidISBN ( string & isbn ) { int n = isbn . length ( ) ; if ( n != 10 ) return false ; int sum = 0 ; for ( int i = 0 ; i < 9 ; i ++ ) { int digit = isbn [ i ] - '0' ; if ( 0 > digit 9 < digit ) return false ; sum += ( digit * ( 10 - i ) ) ; } char last = isbn [ 9 ] ; if ( last != ' X ' && ( last < '0' last > '9' ) ) return false ; sum += ( ( last == ' X ' ) ? 10 : ( last - '0' ) ) ; return ( sum % 11 == 0 ) ; }
Ref: 
function isValidISBN ( isbn ) { let n = isbn . length ; if ( n != 10 ) return false ; let sum = 0 ; for ( let i = 0 ; i < 9 ; i ++ ) { let digit = isbn [ i ] - ' ' ; if ( 0 > digit 9 < digit ) return false ; sum += ( digit * ( 10 - i ) ) ; } let last = isbn [ 9 ] ; if ( last != ' ' && ( last < ' ' last > ' ' ) ) return false ; sum += ( ( last == ' ' ) ? 10 : ( last - ' ' ) ) ; return ( sum % 11 == 0 ) ; }
Hyp: 
function isValidISBN ( isbn ) { let n = isbn . length ; if ( n != 10 ) return false ; let sum = 0 ; for ( let i = 0 ; i < 9 ; i ++ ) { let digit = isbn [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ; if ( 0 > digit 9 < digit ) return false ; sum += ( digit * ( 10 - i ) ) ; } let last = isbn [ 9 ] ; if ( last != ' ' && ( last < ' ' last > ' ' ) ) return false ; sum += ( ( last == ' ' ) ? 10 : ( last - ' ' ) ) ; return ( sum % 11 == 0 ) ; }

BLEU: 91.1
Edit Sim: 38


Src: 
void Alphabet_N_Pattern ( int N ) { int index , side_index , size ; int Right = 1 , Left = 1 , Diagonal = 2 ; for ( index = 0 ; index < N ; index ++ ) { cout << Left ++ ; for ( side_index = 0 ; side_index < 2 * ( index ) ; side_index ++ ) cout << " ▁ " ; if ( index != 0 && index != N - 1 ) cout << Diagonal ++ ; else cout << " ▁ " ; for ( side_index = 0 ; side_index < 2 * ( N - index - 1 ) ; side_index ++ ) cout << " ▁ " ; cout << Right ++ ; cout << endl ; } }
Ref: 
function Alphabet_N_Pattern ( N ) { var index , side_index , size ; var Right = 1 , Left = 1 , Diagonal = 2 ; for ( index = 0 ; index < N ; index ++ ) { document . write ( Left ++ ) ; for ( side_index = 0 ; side_index < 2 * index ; side_index ++ ) document . write ( " " ) ; if ( index != 0 && index != N - 1 ) document . write ( Diagonal ++ ) ; else document . write ( " " ) ; for ( side_index = 0 ; side_index < 2 * ( N - index - 1 ) ; side_index ++ ) document . write ( " " ) ; document . write ( Right ++ ) ; document . write ( " " ) ; } }
Hyp: 
function Alphabet_N_Pattern ( N ) { let index , side_index , size ; let Right = 1 , Left = 1 , Diagonal = 2 ; for ( index = 0 ; index < N ; index ++ ) { document . write ( Left ++ ) ; for ( side_index = 0 ; side_index < 2 * ( index ) ; side_index ++ ) document . write ( " " ) ; if ( index != 0 && index != N - 1 ) document . write ( Diagonal ++ ; else document . write ( " " ) ; } }

BLEU: 59.55
Edit Sim: 174


Src: 
bool isSuffix ( string s1 , string s2 ) { int n1 = s1 . length ( ) , n2 = s2 . length ( ) ; if ( n1 > n2 ) return false ; for ( int i = 0 ; i < n1 ; i ++ ) if ( s1 [ n1 - i - 1 ] != s2 [ n2 - i - 1 ] ) return false ; return true ; }
Ref: 
function isSuffix ( s1 , s2 ) { let n1 = s1 . length , n2 = s2 . length ; if ( n1 > n2 ) return false ; for ( let i = 0 ; i < n1 ; i ++ ) if ( s1 [ n1 - i - 1 ] != s2 [ n2 - i - 1 ] ) return false ; return true ; }
Hyp: 
function isSuffix ( s1 , s2 ) { var n1 = s1 . length , n2 = s2 . length ; if ( n1 > n2 ) return false ; for ( var i = 0 ; i < n1 ; i ++ ) if ( s1 [ n1 - i - 1 ] != s2 [ n2 - i - 1 ] ) return false ; return true ; }

BLEU: 92.8
Edit Sim: 6


Src: 
int countSubStr ( char str [ ] ) { int res = 0 ; for ( int i = 0 ; str [ i ] != ' \0' ; i ++ ) { if ( str [ i ] == '1' ) { for ( int j = i + 1 ; str [ j ] != ' \0' ; j ++ ) if ( str [ j ] == '1' ) res ++ ; } } return res ; }
Ref: 
function countSubStr ( str , n ) { let res = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( str [ i ] == ' ' ) { for ( let j = i + 1 ; j < n ; j ++ ) { if ( str [ j ] == ' ' ) res ++ ; } } } return res ; }
Hyp: 
function countSubStr ( str ) { let res = 0 ; for ( let i = 0 ; str [ i ] != ' ' ; i ++ ) { if ( str [ i ] == ' ' ) { for ( let j = i + 1 ; str [ j ] != ' ' ; j ++ ) if ( str [ j ] == ' ' ) res ++ ; } } return res ; }

BLEU: 74.7
Edit Sim: 34


Src: 
float trapezoidarea ( float r ) { if ( r < 0 ) return -1 ; float a = ( 3 * sqrt ( 3 ) * pow ( r , 2 ) ) / 4 ; return a ; }
Ref: 
function trapezoidarea ( r ) { if ( r < 0 ) return - 1 ; var a = ( 3 * Math . sqrt ( 3 ) * Math . pow ( r , 2 ) ) / 4 ; return a ; }
Hyp: 
function trapezoidarea ( r ) { if ( r < 0 ) return - 1 ; var a = ( 3 * Math . sqrt ( 3 ) * Math . pow ( r , 2 ) ) / 4 ; return a ; }

BLEU: 100.0
Edit Sim: 0


Src: 
float cone ( float a ) { if ( a < 0 ) return -1 ; float r = ( a * sqrt ( 2 ) ) / 3 ; float h = ( 2 * a ) / 3 ; float V = 3.14 * pow ( r , 2 ) * h ; return V ; }
Ref: 
function cone ( a ) { if ( a < 0 ) return - 1 ; var r = ( a * Math . sqrt ( 2 ) ) / 3 ; var h = ( 2 * a ) / 3 ; var V = ( 3.14 * Math . pow ( r , 2 ) * h ) ; return V ; }
Hyp: 
function cone ( a ) { if ( a < 0 ) return - 1 ; var r = ( a * Math . sqrt ( 2 ) ) / 3 ; var h = ( 2 * a ) / 3 ; var V = 3.14 * Math . pow ( r , 2 ) * h ; return V ; }

BLEU: 92.09
Edit Sim: 4


Src: 
int NumberOfSolutions ( int x , int y , int z , int n ) { int ans = 0 ; for ( int i = 0 ; i <= x ; i ++ ) { for ( int j = 0 ; j <= y ; j ++ ) { int temp = n - i - j ; if ( temp >= 0 ) { temp = min ( temp , z ) ; ans += temp + 1 ; } } } return ans ; }
Ref: 
function NumberOfSolutions ( x , y , z , n ) { var ans = 0 ; for ( var i = 0 ; i <= x ; i ++ ) { for ( var j = 0 ; j <= y ; j ++ ) { var temp = n - i - j ; if ( temp >= 0 ) { temp = Math . min ( temp , z ) ; ans += temp + 1 ; } } } return ans ; }
Hyp: 
function NumberOfSolutions ( x , y , z , n ) { let ans = 0 ; for ( let i = 0 ; i <= x ; i ++ ) { for ( let j = 0 ; j <= y ; j ++ ) { let temp = n - i - j ; if ( temp >= 0 ) { temp = Math . min ( temp , z ) ; ans += temp + 1 ; } } } return ans ; }

BLEU: 88.21
Edit Sim: 12


Src: 
bool isPerfectSquare ( int n ) { for ( int sum = 0 , i = 1 ; sum < n ; i += 2 ) { sum += i ; if ( sum == n ) return true ; } return false ; }
Ref: 
function isPerfectSquare ( n ) { for ( let sum = 0 , i = 1 ; sum < n ; i += 2 ) { sum += i ; if ( sum == n ) return true ; } return false ; }
Hyp: 
function isPerfectSquare ( n ) { for ( let sum = 0 , i = 1 ; sum < n ; i += 2 ) { sum += i ; if ( sum == n ) return true ; } return false ; }

BLEU: 100.0
Edit Sim: 0


Src: 
string findString ( int n , int k ) { string res = " " ; for ( int i = 0 ; i < k ; i ++ ) res = res + ( char ) ( ' a ' + i ) ; int count = 0 ; for ( int i = 0 ; i < n - k ; i ++ ) { res = res + ( char ) ( ' a ' + count ) ; count ++ ; if ( count == k ) count = 0 ; } return res ; }
Ref: 
function findString ( n , k ) { let res = " " ; for ( let i = 0 ; i < k ; i ++ ) res = res + String . fromCharCode ( ' ' . charCodeAt ( 0 ) + i ) ; let count = 0 ; for ( let i = 0 ; i < n - k ; i ++ ) { res = res + String . fromCharCode ( ' ' . charCodeAt ( 0 ) + count ) ; count ++ ; if ( count == k ) count = 0 ; } return res ; }
Hyp: 
function findString ( n , k ) { let res = " " ; for ( let i = 0 ; i < k ; i ++ ) res = res + ( char ) ( ' ' + i ) ; let count = 0 ; for ( let i = 0 ; i < n - k ; i ++ ) { res = res + ( char ) ( ' ' + count ) ; count ++ ; if ( count == k ) count = 0 ; } return res ; }

BLEU: 79.46
Edit Sim: 72


Src: 
void series ( int A , int X , int n ) { int term = pow ( A , n ) ; cout << term << " ▁ " ; for ( int i = 1 ; i <= n ; i ++ ) { term = term * X * ( n - i + 1 ) / ( i * A ) ; cout << term << " ▁ " ; } }
Ref: 
function series ( A , X , n ) { let term = Math . pow ( A , n ) ; document . write ( term + " " ) ; for ( let i = 1 ; i <= n ; i ++ ) { term = term * X * ( n - i + 1 ) / ( i * A ) ; document . write ( term + " " ) ; } }
Hyp: 
function series ( A , X , n ) { let term = Math . pow ( A , n ) ; document . write ( term + " " ) ; for ( let i = 1 ; i <= n ; i ++ ) { term = term * X * ( n - i + 1 ) / ( i * A ) ; document . write ( term + " " ) ; } }

BLEU: 100.0
Edit Sim: 0


Src: 
bool isValid ( string str , int n ) { if ( ! ( ( str [ 0 ] >= ' a ' && str [ 0 ] <= ' z ' ) || ( str [ 0 ] >= ' A ' && str [ 0 ] <= ' Z ' ) str [ 0 ] == ' _ ' ) ) return false ; for ( int i = 1 ; i < str . length ( ) ; i ++ ) { if ( ! ( ( str [ i ] >= ' a ' && str [ i ] <= ' z ' ) || ( str [ i ] >= ' A ' && str [ i ] <= ' Z ' ) || ( str [ i ] >= '0' && str [ i ] <= '9' ) str [ i ] == ' _ ' ) ) return false ; } return true ; }
Ref: 
function isValid ( str , n ) { if ( ! ( ( str [ 0 ] >= ' ' && str [ 0 ] <= ' ' ) || ( str [ 0 ] >= ' ' && str [ 0 ] <= ' ' ) str [ 0 ] == ' ' ) ) return false ; for ( let i = 1 ; i < str . length ; i ++ ) { if ( ! ( ( str [ i ] >= ' ' && str [ i ] <= ' ' ) || ( str [ i ] >= ' ' && str [ i ] <= ' ' ) || ( str [ i ] >= ' ' && str [ i ] <= ' ' ) str [ i ] == ' ' ) ) return false ; } return true ; }
Hyp: 
function isValid ( str , n ) { if ( ! ( str [ 0 ] . charCodeAt ( ) >= ' ' . charCodeAt ( ) && str [ 0 ] . charCodeAt ( ) <= ' ' . charCodeAt ( ) ) || ( str [ 0 ] . charCodeAt ( ) >= ' ' . charCodeAt ( ) && str [ 0 ] . charCodeAt ( ) <= ' ' . charCodeAt ( ) ) || ( str [ i ] . charCodeAt ( ) >= ' ' . charCodeAt ( ) && str [ i ] . charCodeAt ( ) == ' ' . charCodeAt ( ) ) ) return false ; } return true ; }

BLEU: 35.12
Edit Sim: 209


Src: 
float cubeSide ( float h , float r ) { if ( h < 0 && r < 0 ) return -1 ; float a = ( h * r * sqrt ( 2 ) ) / ( h + sqrt ( 2 ) * r ) ; return a ; }
Ref: 
function cube ( h , r ) { if ( h < 0 && r < 0 ) return - 1 ; var a = ( h * r * Math . sqrt ( 2 ) ) / ( h + Math . sqrt ( 2 ) * r ) ; return a ; }
Hyp: 
function cubeSide ( h , r ) { if ( h < 0 && r < 0 ) return - 1 ; var a = ( h * r * Math . sqrt ( 2 ) ) / ( h + Math . sqrt ( 2 ) * r ) ; return a ; }

BLEU: 96.77
Edit Sim: 4


Src: 
void MinimumMaximumPairs ( int n , int m ) { int max_pairs = ( ( n - m + 1 ) * ( n - m ) ) / 2 ; int min_pairs = m * ( ( ( n - m ) / m + 1 ) * ( ( n - m ) / m ) ) / 2 + ceil ( ( n - m ) / double ( m ) ) * ( ( n - m ) % m ) ; cout << " Minimum ▁ no . ▁ of ▁ pairs ▁ = ▁ " << min_pairs << " STRNEWLINE " ; cout << " Maximum ▁ no . ▁ of ▁ pairs ▁ = ▁ " << max_pairs << " STRNEWLINE " ; }
Ref: 
function MinimumMaximumPairs ( n , m ) { var max_pairs = parseInt ( ( ( n - m + 1 ) * ( n - m ) ) / 2 ) ; var min_pairs = m * parseInt ( ( ( ( n - m ) / m + 1 ) * ( ( n - m ) / m ) ) / 2 ) + parseInt ( Math . ceil ( ( ( n - m ) / ( m ) ) ) ) * ( ( n - m ) % m ) ; document . write ( " " + min_pairs + " " ) ; document . write ( " " + max_pairs ) ; }
Hyp: 
function MinimumMaximumPairs ( n , m ) { let max_pairs = ( ( n - m + 1 ) * ( n - m ) ) / 2 ; let min_pairs = m * ( ( ( n - m ) / m + 1 ) * ( ( n - m ) / m ) ) / 2 + Math . ceil ( ( n - m ) / double ( m ) ) * ( ( n - m ) % m ) ; document . write ( " " + min_pairs + " " ) ; document . write ( " " + max_pairs + " " ) ; }

BLEU: 78.31
Edit Sim: 59


Src: 
int sumOfMinAbsDifferences ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int sum = 0 ; sum += abs ( arr [ 0 ] - arr [ 1 ] ) ; sum += abs ( arr [ n - 1 ] - arr [ n - 2 ] ) ; for ( int i = 1 ; i < n - 1 ; i ++ ) sum += min ( abs ( arr [ i ] - arr [ i - 1 ] ) , abs ( arr [ i ] - arr [ i + 1 ] ) ) ; return sum ; }
Ref: 
function sumOfMinAbsDifferences ( arr , n ) { arr . sort ( function ( a , b ) { return a - b } ) ; let sum = 0 ; sum += Math . abs ( arr [ 0 ] - arr [ 1 ] ) ; sum += Math . abs ( arr [ n - 1 ] - arr [ n - 2 ] ) ; for ( let i = 1 ; i < n - 1 ; i ++ ) sum += Math . min ( Math . abs ( arr [ i ] - arr [ i - 1 ] ) , Math . abs ( arr [ i ] - arr [ i + 1 ] ) ) ; return sum ; }
Hyp: 
function sumOfMinAbsDifferences ( arr ) { arr . sort ( ( a , b ) => a - b ) ; let sum = 0 ; sum += Math . abs ( arr [ 0 ] - arr [ 1 ] ) ; sum += Math . abs ( arr [ n - 1 ] - arr [ n - 2 ] ) ; for ( let i = 1 ; i < n - 1 ; i ++ ) sum += Math . min ( abs ( arr [ i ] - arr [ i - 1 ] ) , Math . abs ( arr [ i ] - arr [ i + 1 ] ) ) ; return sum ; }

BLEU: 87.76
Edit Sim: 30


Src: 
int findMinimum ( int x , int y ) { int low = 0 , high = y ; while ( low <= high ) { int mid = ( low + high ) >> 1 ; if ( ( mid * 2 + ( y - mid ) ) >= x ) high = mid - 1 ; else low = mid + 1 ; } return low ; }
Ref: 
function findMinimum ( x , y ) { let low = 0 , high = y ; while ( low <= high ) { let mid = ( low + high ) >> 1 ; if ( ( mid * 2 + ( y - mid ) ) >= x ) high = mid - 1 ; else low = mid + 1 ; } return low ; }
Hyp: 
function findMinimum ( x , y ) { let low = 0 , high = y ; while ( low <= high ) { let mid = ( low + high ) >> 1 ; if ( ( mid * 2 + ( y - mid ) ) >= x ) high = mid - 1 ; else low = mid + 1 ; } return low ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int numberofterm ( int n , int number ) { int firstnum = pow ( 10 , n - 1 ) ; int lastnum = pow ( 10 , n ) ; int count = 0 ; for ( int i = firstnum ; i < lastnum ; i ++ ) if ( i % number == 0 ) count ++ ; return count ; }
Ref: 
function numberofterm ( n , number ) { let firstnum = Math . pow ( 10 , n - 1 ) ; let lastnum = Math . pow ( 10 , n ) ; let count = 0 ; for ( let i = firstnum ; i < lastnum ; i ++ ) if ( i % number == 0 ) count ++ ; return count ; }
Hyp: 
function numberofterm ( n , number ) { let firstnum = Math . pow ( 10 , n - 1 ) ; let lastnum = Math . pow ( 10 , n ) ; let count = 0 ; for ( let i = firstnum ; i < lastnum ; i ++ ) if ( i % number == 0 ) count ++ ; return count ; }

BLEU: 100.0
Edit Sim: 0


Src: 
void printElements ( int arr [ ] , int n ) { for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( arr [ i ] > arr [ i - 1 ] and arr [ i ] > arr [ i + 1 ] ) cout << arr [ i ] << " ▁ " ; } }
Ref: 
function printElements ( arr , n ) { for ( var i = 1 ; i < n - 1 ; i ++ ) { if ( arr [ i ] > arr [ i - 1 ] && arr [ i ] > arr [ i + 1 ] ) document . write ( arr [ i ] + " " ) ; } }
Hyp: 
function printElements ( arr , n ) { for ( let i = 1 ; i < n - 1 ; i ++ ) { if ( arr [ i ] > arr [ i - 1 ] and arr [ i ] > arr [ i + 1 ] ) document . write ( arr [ i ] + " " ) ; } }

BLEU: 92.24
Edit Sim: 6


Src: 
bool Check_is_possible ( int l , int r , int k ) { int count = 0 ; for ( int i = l ; i <= r ; i ++ ) { if ( i % k == 0 ) count ++ ; } return ( count > 1 ) ; }
Ref: 
function Check_is_possible ( l , r , k ) { var count = 0 ; for ( i = l ; i <= r ; i ++ ) { if ( i % k == 0 ) { count ++ ; } } return ( count > 1 ) ; } var l = 4 , r = 12 ; var k = 5 ; if ( Check_is_possible ( l , r , k ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
Hyp: 
function Check_is_possible ( l , r , k ) { var count = 0 ; for ( var i = l ; i <= r ; i ++ ) { if ( i % k == 0 ) count ++ ; } return ( count > 1 ) ; }

BLEU: 35.34
Edit Sim: 147


Src: 
int breakSum ( int n ) { int dp [ n + 1 ] ; dp [ 0 ] = 0 , dp [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) dp [ i ] = max ( dp [ i / 2 ] + dp [ i / 3 ] + dp [ i / 4 ] , i ) ; return dp [ n ] ; }
Ref: 
function breakSum ( n ) { let dp = new Array ( n + 1 ) ; for ( let i = 0 ; i < dp ; i ++ ) { dp [ i ] = 0 ; } dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; for ( let i = 2 ; i <= n ; i ++ ) dp [ i ] = Math . max ( dp [ Math . floor ( i / 2 ) ] + dp [ Math . floor ( i / 3 ) ] + dp [ Math . floor ( i / 4 ) ] , i ) ; return dp [ n ] ; }
Hyp: 
function breakSum ( n ) { let dp = new Array ( n + 1 ) ; dp [ 0 ] = 0 , dp [ 1 ] = 1 ; for ( let i = 2 ; i <= n ; i ++ ) dp [ i ] = Math . max ( dp [ i / 2 ] + dp [ i / 3 ] + dp [ i / 4 ] , i ) ; return dp [ n ] ; }

BLEU: 54.32
Edit Sim: 105


Src: 
int maxPathSum ( int tri [ ] [ N ] ) { int ans = 0 ; for ( int i = N - 2 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < N - i ; j ++ ) { if ( j - 1 >= 0 ) tri [ i ] [ j ] += max ( tri [ i + 1 ] [ j ] , tri [ i + 1 ] [ j - 1 ] ) ; else tri [ i ] [ j ] += tri [ i + 1 ] [ j ] ; ans = max ( ans , tri [ i ] [ j ] ) ; } } return ans ; }
Ref: 
function maxPathSum ( tri ) { var ans = 0 ; for ( var i = N - 2 ; i >= 0 ; i -- ) { for ( var j = 0 ; j < N - i ; j ++ ) { if ( j - 1 >= 0 ) tri [ i ] [ j ] += Math . max ( tri [ i + 1 ] [ j ] , tri [ i + 1 ] [ j - 1 ] ) ; else tri [ i ] [ j ] += tri [ i + 1 ] [ j ] ; ans = Math . max ( ans , tri [ i ] [ j ] ) ; } } return ans ; }
Hyp: 
function maxPathSum ( tri ) { let ans = 0 ; for ( let i = N - 2 ; i >= 0 ; i -- ) { for ( let j = 0 ; j < N - i ; j ++ ) { if ( j - 1 >= 0 ) tri [ i ] [ j ] += Math . max ( tri [ i + 1 ] [ j ] , tri [ i + 1 ] [ j - 1 ] ) ; else tri [ i ] [ j ] += tri [ i + 1 ] [ j ] ; ans = Math . max ( ans , tri [ i ] [ j ] ) ; } } return ans ; }

BLEU: 94.15
Edit Sim: 9


Src: 
int contiguousPerfectSquare ( int arr [ ] , int n ) { int a ; float b ; int current_length = 0 ; int max_length = 0 ; for ( int i = 0 ; i < n ; i ++ ) { b = sqrt ( arr [ i ] ) ; a = b ; if ( a == b ) current_length ++ ; else current_length = 0 ; max_length = max ( max_length , current_length ) ; } return max_length ; }
Ref: 
function contiguousPerfectSquare ( arr , n ) { var a ; var b ; var current_length = 0 ; var max_length = 0 ; for ( var i = 0 ; i < n ; i ++ ) { b = ( Math . sqrt ( arr [ i ] ) ) ; a = parseInt ( b ) ; if ( a == b ) current_length ++ ; else current_length = 0 ; max_length = Math . max ( max_length , current_length ) ; } return max_length ; }
Hyp: 
function contiguousPerfectSquare ( arr , n ) { let a ; let b ; let current_length = 0 ; let max_length = 0 ; for ( let i = 0 ; i < n ; i ++ ) { b = Math . sqrt ( arr [ i ] ) ; a = b ; if ( a == b ) current_length ++ ; else current_length = 0 ; max_length = Math . max ( max_length , current_length ) ; } return max_length ; }

BLEU: 75.16
Edit Sim: 32


Src: 
void octant ( float x , float y , float z ) { if ( x >= 0 && y >= 0 && z >= 0 ) cout << " Point ▁ lies ▁ in ▁ 1st ▁ octant STRNEWLINE " ; else if ( x < 0 && y >= 0 && z >= 0 ) cout << " Point ▁ lies ▁ in ▁ 2nd ▁ octant STRNEWLINE " ; else if ( x < 0 && y < 0 && z >= 0 ) cout << " Point ▁ lies ▁ in ▁ 3rd ▁ octant STRNEWLINE " ; else if ( x >= 0 && y < 0 && z >= 0 ) cout << " Point ▁ lies ▁ in ▁ 4th ▁ octant STRNEWLINE " ; else if ( x >= 0 && y >= 0 && z < 0 ) cout << " Point ▁ lies ▁ in ▁ 5th ▁ octant STRNEWLINE " ; else if ( x < 0 && y >= 0 && z < 0 ) cout << " Point ▁ lies ▁ in ▁ 6th ▁ octant STRNEWLINE " ; else if ( x < 0 && y < 0 && z < 0 ) cout << " Point ▁ lies ▁ in ▁ 7th ▁ octant STRNEWLINE " ; else if ( x >= 0 && y < 0 && z < 0 ) cout << " Point ▁ lies ▁ in ▁ 8th ▁ octant STRNEWLINE " ; }
Ref: 
function octant ( x , y , z ) { if ( x >= 0 && y >= 0 && z >= 0 ) document . write ( " " + " " ) ; else if ( x < 0 && y >= 0 && z >= 0 ) document . write ( " " + " " ) ; else if ( x < 0 && y < 0 && z >= 0 ) document . write ( " " + " " ) ; else if ( x >= 0 && y < 0 && z >= 0 ) document . write ( " " + " " ) ; else if ( x >= 0 && y >= 0 && z < 0 ) document . write ( " " + " " ) ; else if ( x < 0 && y >= 0 && z < 0 ) document . write ( " " + " " ) ; else if ( x < 0 && y < 0 && z < 0 ) document . write ( " " + " " ) ; else if ( x >= 0 && y < 0 && z < 0 ) document . write ( " " + " " ) ; }
Hyp: 
function octant ( x , y , z ) { if ( x >= 0 && y >= 0 && z >= 0 ) document . write ( " " ) ; else if ( x < 0 && y >= 0 && z >= 0 ) document . write ( " " ) ; else if ( x < 0 && y < 0 && z >= 0 ) document . write ( " " ) ; else if ( x >= 0 && y < 0 && z < 0 ) document . write ( " " ) ; else if ( x < 0 && y < 0 && z < 0 ) document . write ( " " ) ; else if ( x >= 0 && y < 0 && z < 0 ) document . write ( " " ) ; else if ( x >= 0 && y < 0 && z < 0 ) document . write ( " " ) ; }

BLEU: 74.37
Edit Sim: 117


Src: 
int countSol ( int coeff [ ] , int n , int rhs ) { int dp [ rhs + 1 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; dp [ 0 ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = coeff [ i ] ; j <= rhs ; j ++ ) dp [ j ] += dp [ j - coeff [ i ] ] ; return dp [ rhs ] ; }
Ref: 
function countSol ( coeff , n , rhs ) { let dp = new Array ( rhs + 1 ) ; dp . fill ( 0 ) ; dp [ 0 ] = 1 ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = coeff [ i ] ; j <= rhs ; j ++ ) dp [ j ] += dp [ j - coeff [ i ] ] ; return dp [ rhs ] ; }
Hyp: 
function countSol ( coeff , n , rhs ) { let dp = new Array ( rhs + 1 ) ; dp . fill ( 0 ) ; for ( let i = 0 ; i < rhs + 1 ; i ++ ) { dp [ i ] = 1 ; for ( let j = coeff [ i ] ; j <= rhs ; j ++ ) dp [ j ] += dp [ j - coeff [ i ] ] ; return dp [ rhs ] ; }

BLEU: 87.94
Edit Sim: 32


Src: 
int winner ( int a [ ] , int n , int k ) { if ( k >= n - 1 ) return n ; int best = 0 , times = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > best ) { best = a [ i ] ; if ( i ) } else if ( times >= k ) return best ; } return best ; }
Ref: 
function winner ( a , n , k ) { if ( k >= n - 1 ) return n ; let best = 0 , times = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] > best ) { best = a [ i ] ; if ( i ) times = 1 ; } else times += 1 ; if ( times >= k ) return best ; } return best ; }
Hyp: 
function winner ( a , n , k ) { if ( k >= n - 1 ) return n ; let best = 0 , times = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] > best ) { best = a [ i ] ; if ( i ) } else if ( times >= k ) return best ; } return best ; }

BLEU: 87.59
Edit Sim: 25


Src: 
int seriesSum ( int n ) { return ( n * ( n + 1 ) * ( n + 2 ) ) / 6 ; }
Ref: 
function seriesSum ( n ) { return ( n * ( n + 1 ) * ( n + 2 ) ) / 6 ; }
Hyp: 
function seriesSum ( n ) { return ( n * ( n + 1 ) * ( n + 2 ) ) / 6 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int Permutations ( int n , int k ) { int ans = 1 ; if ( k >= 2 ) ans += ( n ) * ( n - 1 ) / 2 ; if ( k >= 3 ) ans += ( n ) * ( n - 1 ) * ( n - 2 ) * 2 / 6 ; if ( k >= 4 ) ans += ( n ) * ( n - 1 ) * ( n - 2 ) * ( n - 3 ) * 9 / 24 ; return ans ; }
Ref: 
function Permutations ( n , k ) { var ans = 1 ; if ( k >= 2 ) ans += ( n ) * ( n - 1 ) / 2 ; if ( k >= 3 ) ans += ( n ) * ( n - 1 ) * ( n - 2 ) * 2 / 6 ; if ( k >= 4 ) ans += ( n ) * ( n - 1 ) * ( n - 2 ) * ( n - 3 ) * 9 / 24 ; return ans ; }
Hyp: 
function Permutations ( n , k ) { let ans = 1 ; if ( k >= 2 ) ans += ( n ) * ( n - 1 ) / 2 ; if ( k >= 3 ) ans += ( n ) * ( n - 1 ) * ( n - 2 ) * 2 / 6 ; if ( k >= 4 ) ans += ( n ) * ( n - 1 ) * ( n - 2 ) * ( n - 3 ) * 9 / 24 ; return ans ; }

BLEU: 97.44
Edit Sim: 3


Src: 
string findNumber ( int n , int d ) { string ans = " " ; if ( d != 10 ) { ans += to_string ( d ) ; for ( int i = 1 ; i < n ; i ++ ) ans += '0' ; } else { if ( n == 1 ) ans += " Impossible " ; else { ans += '1' ; for ( int i = 1 ; i < n ; i ++ ) ans += '0' ; } } return ans ; }
Ref: 
function findNumber ( n , d ) { let ans = " " ; if ( d != 10 ) { ans += ( d ) . toString ( ) ; for ( let i = 1 ; i < n ; i ++ ) ans += ' ' ; } else { if ( n == 1 ) ans += " " ; else { ans += ' ' ; for ( let i = 1 ; i < n ; i ++ ) ans += ' ' ; } } return ans ; }
Hyp: 
function findNumber ( n , d ) { let ans = " " ; if ( d != 10 ) { ans += to_string ( d ) ; for ( let i = 1 ; i < n ; i ++ ) ans += ' ' ; } else { if ( n == 1 ) ans += " " ; else { ans += ' ' ; for ( let i = 1 ; i < n ; i ++ ) ans += ' ' ; } } return ans ; }

BLEU: 93.38
Edit Sim: 12


Src: 
int find_sum ( int n , int k ) { int total_sum = ( n * ( n + 1 ) ) / 2 ; int power = k ; while ( power <= n ) { total_sum -= power ; power *= k ; } return total_sum ; }
Ref: 
function find_sum ( n , k ) { let total_sum = ( n * ( n + 1 ) ) / 2 ; let power = k ; while ( power <= n ) { total_sum -= power ; power *= k ; } return total_sum ; }
Hyp: 
function find_sum ( n , k ) { let total_sum = ( n * ( n + 1 ) ) / 2 ; let power = k ; while ( power <= n ) { total_sum -= power ; power *= k ; } return total_sum ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int findPermutation ( int n ) { int len = ceil ( log10 ( n ) ) ; for ( int i = 0 ; i < len ; i ++ ) { if ( n % 2 != 0 ) { return n ; } else { n = ( n / 10 ) + ( n % 10 ) * pow ( 10 , len - i - 1 ) ; continue ; } } return -1 ; }
Ref: 
function findPermutation ( n ) { let len = Math . ceil ( Math . log10 ( n ) ) ; for ( let i = 0 ; i < len ; i ++ ) { if ( n % 2 != 0 ) { return parseInt ( n ) ; } else { n = ( n / 10 ) + ( n % 10 ) * Math . pow ( 10 , len - i - 1 ) ; continue ; } } return - 1 ; }
Hyp: 
function findPermutation ( n ) { let len = Math . ceil ( Math . log10 ( n ) ) ; for ( let i = 0 ; i < len ; i ++ ) { if ( n % 2 != 0 ) { return n ; } else { n = parseInt ( ( n / 10 ) + ( n % 10 ) * Math . pow ( 10 , len - i - 1 ) ; continue ; } } return - 1 ; }

BLEU: 93.17
Edit Sim: 22


Src: 
float sumOfSeries ( int n ) { return 0.0246 * ( pow ( 10 , n ) - 1 - ( 9 * n ) ) ; }
Ref: 
function sumOfSeries ( n ) { return 0.0246 * ( Math . pow ( 10 , n ) - 1 - ( 9 * n ) ) ; }
Hyp: 
function sumOfSeries ( n ) { return 0.0246 * ( Math . pow ( 10 , n ) - 1 - ( 9 * n ) ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int search ( int arr [ ] , int n , int x ) { int i = 0 ; while ( i < n ) { if ( arr [ i ] == x ) return i ; i = i + abs ( arr [ i ] - x ) ; } cout << " number ▁ is ▁ not ▁ present ! " ; return -1 ; }
Ref: 
function search ( arr , n , x ) { let i = 0 ; while ( i < n ) { if ( arr [ i ] == x ) return i ; i = i + Math . abs ( arr [ i ] - x ) ; } document . write ( " " ) ; return - 1 ; }
Hyp: 
function search ( arr , n , x ) { let i = 0 ; while ( i < n ) { if ( arr [ i ] == x ) return i ; i = i + Math . abs ( arr [ i ] - x ) ; } document . write ( " " + x + " " ) ; return - 1 ; }

BLEU: 92.32
Edit Sim: 10


Src: 
void primesInRange ( int n ) { int fact = 1 ; for ( int k = 2 ; k < n ; k ++ ) { fact = fact * ( k - 1 ) ; if ( ( fact + 1 ) % k == 0 ) cout << k << endl ; } }
Ref: 
function primesInRange ( n ) { let fact = 1 ; for ( let k = 2 ; k < n ; k ++ ) { fact = fact * ( k - 1 ) ; if ( ( fact + 1 ) % k == 0 ) document . write ( ( k + " " ) ) ; } }
Hyp: 
function primesInRange ( n ) { var fact = 1 ; for ( var k = 2 ; k < n ; k ++ ) { fact = fact * ( k - 1 ) ; if ( ( fact + 1 ) % k == 0 ) document . write ( k + " " ) ; } }

BLEU: 85.79
Edit Sim: 10


Src: 
float geometricMean ( int arr [ ] , int n ) { float product = 1 ; for ( int i = 0 ; i < n ; i ++ ) product = product * arr [ i ] ; float gm = pow ( product , ( float ) 1 / n ) ; return gm ; }
Ref: 
function geometricMean ( arr , n ) { let product = 1 ; for ( let i = 0 ; i < n ; i ++ ) product = product * arr [ i ] ; let gm = Math . pow ( product , 1 / n ) ; return gm ; }
Hyp: 
function geometricMean ( arr , n ) { var product = 1 ; for ( var i = 0 ; i < n ; i ++ ) product = product * arr [ i ] ; var gm = Math . pow ( product , ( float ) 1 / n ) ; return gm ; }

BLEU: 78.15
Edit Sim: 19


Src: 
void printPermutation ( int n , int k ) { for ( int i = 1 ; i <= n ; i ++ ) { int x = 2 * i - 1 ; int y = 2 * i ; if ( i <= k ) cout << y << " ▁ " << x << " ▁ " ; else cout << x << " ▁ " << y << " ▁ " ; } }
Ref: 
function printPermutation ( n , k ) { for ( var i = 1 ; i <= n ; i ++ ) { var x = 2 * i - 1 ; var y = 2 * i ; if ( i <= k ) document . write ( y + " " + x + " " ) ; else document . write ( x + " " + y + " " ) ; } }
Hyp: 
function printPermutation ( n , k ) { for ( let i = 1 ; i <= n ; i ++ ) { let x = 2 * i - 1 ; let y = 2 * i ; if ( i <= k ) document . write ( y + " " + x + " " ) ; else document . write ( x + " " + y + " " ) ; } }

BLEU: 90.15
Edit Sim: 9


Src: 
int bitPos ( int n1 , int n2 ) { if ( n1 == n2 ) return 0 ; int bitCount1 = floor ( log2 ( n1 ) ) + 1 ; int bitCount2 = floor ( log2 ( n2 ) ) + 1 ; int bitDiff = abs ( bitCount1 - bitCount2 ) ; int maxBitCount = max ( bitCount1 , bitCount2 ) ; if ( bitCount1 > bitCount2 ) { n2 = n2 * pow ( 2 , bitDiff ) ; } else { n1 = n1 * pow ( 2 , bitDiff ) ; } int xorValue = n1 ^ n2 ; int bitCountXorValue = floor ( log2 ( xorValue ) ) + 1 ; int disSimilarBitPosition = maxBitCount - bitCountXorValue + 1 ; return disSimilarBitPosition ; }
Ref: 
function bitPos ( n1 , n2 ) { if ( n1 == n2 ) return 0 ; let bitCount1 = Math . floor ( Math . log2 ( n1 ) ) + 1 ; let bitCount2 = Math . floor ( Math . log2 ( n2 ) ) + 1 ; let bitDiff = Math . abs ( bitCount1 - bitCount2 ) ; let maxBitCount = Math . max ( bitCount1 , bitCount2 ) ; if ( bitCount1 > bitCount2 ) { n2 = n2 * Math . pow ( 2 , bitDiff ) ; } else { n1 = n1 * Math . pow ( 2 , bitDiff ) ; } let xorValue = n1 ^ n2 ; let bitCountXorValue = Math . floor ( Math . log2 ( xorValue ) ) + 1 ; let disSimilarBitPosition = maxBitCount - bitCountXorValue + 1 ; return disSimilarBitPosition ; }
Hyp: 
function bitPos ( n1 , n2 ) { if ( n1 == n2 ) return 0 ; let bitCount1 = Math . floor ( Math . log2 ( n1 ) ) + 1 ; let bitCount2 = Math . floor ( Math . log2 ( n2 ) ) + 1 ; let bitDiff = Math . abs ( bitCount1 - bitCount2 ) ; let maxBitCount = Math . max ( bitCount1 , bitCount2 ) ; if ( bitCount1 > bitCount2 ) { n2 = n2 * Math . pow ( 2 , bitDiff ) ; } else { n1 = n1 * Math . pow ( 2 , bitDiff ) ; } let xorValue = n1 ^ n2 ; let bitCountXorValue = Math . floor ( log2 ( xorValue ) ) + 1 ; let disSimilarBitPosition = maxBitCount - bitCountXorValue + 1 ; return disSimilarBitPosition ; }

BLEU: 97.63
Edit Sim: 7


Src: 
int countDer ( int n ) { int der [ n + 1 ] = { 0 } ; der [ 1 ] = 0 ; der [ 2 ] = 1 ; for ( int i = 3 ; i <= n ; ++ i ) der [ i ] = ( i - 1 ) * ( der [ i - 1 ] + der [ i - 2 ] ) ; return der [ n ] ; }
Ref: 
function countDer ( n ) { let der = new Array ( n + 1 ) ; der [ 1 ] = 0 ; der [ 2 ] = 1 ; for ( let i = 3 ; i <= n ; ++ i ) der [ i ] = ( i - 1 ) * ( der [ i - 1 ] + der [ i - 2 ] ) ; return der [ n ] ; }
Hyp: 
function countDer ( n ) { let der = new Array ( n + 1 ) ; der [ 0 ] = 0 ; der [ 1 ] = 0 ; der [ 2 ] = 1 ; for ( let i = 3 ; i <= n ; ++ i ) der [ i ] = ( i - 1 ) * ( der [ i - 1 ] + der [ i - 2 ] ) ; return der [ n ] ; }

BLEU: 91.81
Edit Sim: 16


Src: 
void equation_ellipse ( float x1 , float y1 , float a , float b , float c , float e ) { float t = a * a + b * b ; float a1 = t - e * ( a * a ) ; float b1 = t - e * ( b * b ) ; float c1 = ( -2 * t * x1 ) - ( 2 * e * c * a ) ; float d1 = ( -2 * t * y1 ) - ( 2 * e * c * b ) ; float e1 = -2 * e * a * b ; float f1 = ( - e * c * c ) + ( t * x1 * x1 ) + ( t * y1 * y1 ) ; cout << fixed ; cout << setprecision ( 2 ) ; cout << " Equation ▁ of ▁ ellipse ▁ is ▁ STRNEWLINE " << a1 << " ▁ x ^ 2 ▁ + ▁ " << b1 << " ▁ y ^ 2 ▁ + ▁ " << c1 << " ▁ x ▁ + ▁ " << d1 << " ▁ y ▁ + ▁ " << e1 << " ▁ xy ▁ + ▁ " << f1 << " ▁ = ▁ 0" ; }
Ref: 
function equation_ellipse ( x1 , y1 , a , b , c , e ) { var t = a * a + b * b ; var a1 = t - e * ( a * a ) ; var b1 = t - e * ( b * b ) ; var c1 = ( - 2 * t * x1 ) - ( 2 * e * c * a ) ; var d1 = ( - 2 * t * y1 ) - ( 2 * e * c * b ) ; var e1 = - 2 * e * a * b ; var f1 = ( - e * c * c ) + ( t * x1 * x1 ) + ( t * y1 * y1 ) ; document . write ( " " + " " ) ; document . write ( a1 + " " + b1 + " " + c1 + " " + d1 + " " + e1 + " " + f1 + " " ) ; }
Hyp: 
function equation_ellipse ( x1 , y1 , a , b , c , e ) { var t = a * a + b * b ; var a1 = t - e * ( a * a ) ; var b1 = t - e * ( b * b ) ; var c1 = ( - 2 * t * x1 ) - ( 2 * e * c * a ) ; var d1 = ( - 2 * t * y1 ) - ( 2 * e * c * b ) ; var e1 = - 2 * e * a * b ; var f1 = ( - e * c * c ) + ( t * x1 * x1 ) + ( t * y1 * y1 ) ; document . write ( " " + a1 + " " + b1 + " " + c1 + " " + d1 + " " + e1 + " " + f1 + " " ) ; }

BLEU: 94.73
Edit Sim: 27


Src: 
int reversDigits ( int num ) { static int rev_num = 0 ; static int base_pos = 1 ; if ( num > 0 ) { reversDigits ( num / 10 ) ; rev_num += ( num % 10 ) * base_pos ; base_pos *= 10 ; } return rev_num ; }
Ref: 
function reversDigits ( num ) { if ( num > 0 ) { reversDigits ( Math . floor ( num / 10 ) ) ; rev_num += ( num % 10 ) * base_pos ; base_pos *= 10 ; } return rev_num ; }
Hyp: 
function reversDigits ( num ) { let rev_num = 0 ; let base_pos = 1 ; if ( num > 0 ) { reversDigits ( num / 10 ) ; rev_num += ( num % 10 ) * base_pos ; base_pos *= 10 ; } return rev_num ; }

BLEU: 72.78
Edit Sim: 50


Src: 
int findMinZero ( int p ) { int first = 1 , second = 1 , number = 2 , next = 1 ; while ( next ) { next = ( first + second ) % p ; first = second ; second = next ; number ++ ; } return number ; }
Ref: 
function findMinZero ( p ) { let first = 1 ; let second = 1 ; let number = 2 ; let next = 1 ; while ( next ) { next = ( first + second ) % p ; first = second ; second = next ; number ++ ; } return number ; }
Hyp: 
function findMinZero ( p ) { let first = 1 , second = 1 , number = 2 , next = 1 ; while ( next ) { next = ( first + second ) % p ; first = second ; second = next ; number ++ ; } return number ; }

BLEU: 80.97
Edit Sim: 15


Src: 
int findMinSum ( long long int a [ ] , long long int b [ ] , int n ) { sort ( a , a + n ) ; sort ( b , b + n ) ; long long int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum + abs ( a [ i ] - b [ i ] ) ; return sum ; }
Ref: 
function findMinSum ( a , b , n ) { a . sort ( ) ; b . sort ( ) ; let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum = sum + Math . abs ( a [ i ] - b [ i ] ) ; return sum ; }
Hyp: 
function findMinSum ( a , b , n ) { a . sort ( function ( a , b ) { return a - b ; } ) ; let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum = sum + Math . abs ( a [ i ] - b [ i ] ) ; return sum ; }

BLEU: 80.69
Edit Sim: 29


Src: 
string areAllBitsSet ( int n ) { if ( n == 0 ) return " No " ; while ( n > 0 ) { if ( ( n & 1 ) == 0 ) return " No " ; n = n >> 1 ; } return " Yes " ; }
Ref: 
function areAllBitsSet ( n ) { if ( n == 0 ) return " " ; while ( n > 0 ) { if ( ( n & 1 ) == 0 ) return " " ; n = n >> 1 ; } return " " ; }
Hyp: 
function areAllBitsSet ( n ) { if ( n == 0 ) return " " ; while ( n > 0 ) { if ( ( n & 1 ) == 0 ) return " " ; n = Math . floor ( n >> 1 ) ; } return " " ; }

BLEU: 84.83
Edit Sim: 17


Src: 
double maxArea ( double a , double b , double c , double d ) { double semiperimeter = ( a + b + c + d ) / 2 ; return sqrt ( ( semiperimeter - a ) * ( semiperimeter - b ) * ( semiperimeter - c ) * ( semiperimeter - d ) ) ; }
Ref: 
function maxArea ( a , b , c , d ) { let semiperimeter = ( a + b + c + d ) / 2 ; return Math . sqrt ( ( semiperimeter - a ) * ( semiperimeter - b ) * ( semiperimeter - c ) * ( semiperimeter - d ) ) ; }
Hyp: 
function maxArea ( a , b , c , d ) { let semiperimeter = ( a + b + c + d ) / 2 ; return Math . sqrt ( ( semiperimeter - a ) * ( semiperimeter - b ) * ( semiperimeter - c ) * ( semiperimeter - d ) ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
bool isCornerPresent ( string str , string corner ) { int n = str . length ( ) ; int cl = corner . length ( ) ; if ( n < cl ) return false ; return ( str . substr ( 0 , cl ) . compare ( corner ) == 0 && str . substr ( n - cl , cl ) . compare ( corner ) == 0 ) ; }
Ref: 
function isCornerPresent ( str , corner ) { var n = str . length ; var cl = corner . length ; if ( n < cl ) return false ; return ( str . substring ( 0 , cl ) . localeCompare ( corner ) === 0 && str . substring ( n - cl , n ) . localeCompare ( corner ) === 0 ) ; }
Hyp: 
function isCornerPresent ( str , corner ) { let n = str . length ; let cl = corner . length ; if ( n < cl ) return false ; return ( str . substr ( 0 , cl ) . compare ( corner ) == 0 && str . substr ( n - cl , cl ) . compare ( corner ) == 0 ) ; }

BLEU: 65.63
Edit Sim: 28


Src: 
int maxXOR ( int n , int k ) { int c = log2 ( n ) + 1 ; return ( ( 1 << c ) - 1 ) ; }
Ref: 
function maxXOR ( n , k ) { let c = ( Math . log ( n ) / Math . log ( 2 ) ) + 1 ; return ( ( 1 << c ) - 1 ) ; }
Hyp: 
function maxXOR ( n , k ) { let c = Math . log2 ( n ) + 1 ; return ( ( 1 << c ) - 1 ) ; }

BLEU: 64.09
Edit Sim: 24


Src: 
float findRadiusOfIncircle ( float a , float b , float c ) { if ( a < 0 b < 0 c < 0 ) return -1 ; float p = ( a + b + c ) / 2 ; float area = sqrt ( p * ( p - a ) * ( p - b ) * ( p - c ) ) ; float radius = area / p ; return radius ; }
Ref: 
function findRadiusOfIncircle ( a , b , c ) { if ( a < 0 b < 0 c < 0 ) return - 1 ; var p = ( a + b + c ) / 2 ; var area = Math . sqrt ( p * ( p - a ) * ( p - b ) * ( p - c ) ) ; var radius = area / p ; return radius ; }
Hyp: 
function findRadiusOfIncircle ( a , b , c ) { if ( a < 0 b < 0 c < 0 ) return - 1 ; var p = ( a + b + c ) / 2 ; var area = Math . sqrt ( p * ( p - a ) * ( p - b ) * ( p - c ) ) ; var radius = area / p ; return radius ; }

BLEU: 100.0
Edit Sim: 0


Src: 
bool FindPoint ( int x1 , int y1 , int x2 , int y2 , int x , int y ) { if ( x > x1 and x < x2 and y > y1 and y < y2 ) return true ; return false ; }
Ref: 
function FindPoint ( x1 , y1 , x2 , y2 , x , y ) { if ( x > x1 && x < x2 && y > y1 && y < y2 ) return true ; return false ; }
Hyp: 
function FindPoint ( x1 , y1 , x2 , y2 , x , y ) { if ( x > x1 and x < x2 and y > y1 and y < y2 ) return true ; return false ; }

BLEU: 80.76
Edit Sim: 9


Src: 
bool isSpiltPossible ( int n , int a [ ] ) { int sum = 0 , c1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; if ( a [ i ] == 1 ) { c1 ++ ; } } if ( sum % 2 ) return false ; if ( ( sum / 2 ) % 2 == 0 ) return true ; if ( c1 > 0 ) return true ; else return false ; }
Ref: 
function isSpiltPossible ( n , a ) { let sum = 0 , c1 = 0 ; for ( let i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; if ( a [ i ] == 1 ) { c1 ++ ; } } if ( sum % 2 != 0 ) return false ; if ( ( sum / 2 ) % 2 == 0 ) return true ; if ( c1 > 0 ) return true ; else return false ; }
Hyp: 
function isSpiltPossible ( n , a ) { let sum = 0 , c1 = 0 ; for ( let i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; if ( a [ i ] == 1 ) { c1 ++ ; } } if ( sum % 2 ) return false ; if ( ( sum / 2 ) % 2 == 0 ) return true ; if ( c1 > 0 ) return true ; else return false ; }

BLEU: 96.22
Edit Sim: 5


Src: 
int countSubStr ( char str [ ] ) { for ( int i = 0 ; str [ i ] != ' \0' ; i ++ ) { if ( str [ i ] == '1' ) m ++ ; } return m * ( m - 1 ) / 2 ; }
Ref: 
function countSubStr ( str , n ) { for ( let i = 0 ; i < n ; i ++ ) { if ( str [ i ] == ' ' ) m ++ ; } return m * Math . floor ( ( m - 1 ) / 2 ) ; }
Hyp: 
function countSubStr ( str ) { for ( let i = 0 ; str [ i ] != ' ' ; i ++ ) { if ( str [ i ] == ' ' ) m ++ ; } return m * ( m - 1 ) / 2 ; }

BLEU: 70.2
Edit Sim: 34


Src: 
int SubArraySum ( int arr [ ] , int n ) { long int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) result += ( arr [ i ] * ( i + 1 ) * ( n - i ) ) ; return result ; }
Ref: 
function SubArraySum ( arr , n ) { let result = 0 ; for ( let i = 0 ; i < n ; i ++ ) result += ( arr [ i ] * ( i + 1 ) * ( n - i ) ) ; return result ; }
Hyp: 
function SubArraySum ( arr , n ) { let result = 0 ; for ( let i = 0 ; i < n ; i ++ ) result += ( arr [ i ] * ( i + 1 ) * ( n - i ) ) ; return result ; }

BLEU: 100.0
Edit Sim: 0


Src: 
float harmonicMean ( float arr [ ] , int n ) { float sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum + ( float ) 1 / arr [ i ] ; return ( float ) n / sum ; }
Ref: 
function harmonicMean ( arr , n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum = sum + ( 1 / arr [ i ] ) ; return n / sum ; }
Hyp: 
function harmonicMean ( arr , n ) { var sum = 0 ; for ( var i = 0 ; i < n ; i ++ ) sum = sum + ( float ) 1 / arr [ i ] ; return ( float ) n / sum ; }

BLEU: 70.45
Edit Sim: 26


Src: 
void find_rectangle ( int area ) { int l , b ; int M = sqrt ( area ) , ans ; for ( int i = M ; i >= 1 ; i -- ) { if ( area % i == 0 ) { l = ( area / i ) ; b = i ; break ; } } cout << " l ▁ = ▁ " << l << " , ▁ b ▁ = ▁ " << b << endl ; }
Ref: 
function find_rectangle ( area ) { let l = 0 , b = 0 ; let M = Math . floor ( Math . sqrt ( area ) ) , ans ; for ( let i = M ; i >= 1 ; i -- ) { if ( area % i == 0 ) { l = Math . floor ( area / i ) ; b = i ; break ; } } document . write ( " " + l + " " + b ) ; }
Hyp: 
function find_rectangle ( area ) { let l , b ; let M = Math . sqrt ( area ) , ans ; for ( let i = M ; i >= 1 ; i -- ) { if ( area % i == 0 ) { l = ( area / i ) ; b = i ; break ; } } document . write ( " " + l + " " + b + " " ) ; }

BLEU: 78.58
Edit Sim: 44


Src: 
int binarySearch ( int arr [ ] , int l , int r , int x ) { if ( r >= l ) { int mid = l + ( r - l ) / 2 ; if ( arr [ mid ] == x ) return mid ; if ( arr [ mid ] > x ) return binarySearch ( arr , l , mid - 1 , x ) ; return binarySearch ( arr , mid + 1 , r , x ) ; } return -1 ; }
Ref: 
function binarySearch ( arr , l , r , x ) { if ( r >= l ) { let mid = l + Math . floor ( ( r - l ) / 2 ) ; if ( arr [ mid ] == x ) return mid ; if ( arr [ mid ] > x ) return binarySearch ( arr , l , mid - 1 , x ) ; return binarySearch ( arr , mid + 1 , r , x ) ; } return - 1 ; }
Hyp: 
function binarySearch ( arr , l , r , x ) { if ( r >= l ) { let mid = l + ( r - l ) / 2 ; if ( arr [ mid ] == x ) return mid ; if ( arr [ mid ] > x ) return binarySearch ( arr , l , mid - 1 , x ) ; return binarySearch ( arr , mid + 1 , r , x ) ; } return - 1 ; }

BLEU: 91.07
Edit Sim: 17


Src: 
int findMinSum ( int num ) { int sum = 0 ; for ( int i = 2 ; i * i <= num ; i ++ ) { while ( num % i == 0 ) { sum += i ; num /= i ; } } sum += num ; return sum ; }
Ref: 
function findMinSum ( num ) { let sum = 0 ; for ( let i = 2 ; i * i <= num ; i ++ ) { while ( num % i == 0 ) { sum += i ; num /= i ; } } sum += num ; return sum ; }
Hyp: 
function findMinSum ( num ) { let sum = 0 ; for ( let i = 2 ; i * i <= num ; i ++ ) { while ( num % i == 0 ) { sum += i ; num = Math . floor ( num / i ) ; } } sum += num ; return sum ; }

BLEU: 83.24
Edit Sim: 24


Src: 
int count ( int n ) { int table [ n + 1 ] , i ; for ( int j = 0 ; j < n + 1 ; j ++ ) table [ j ] = 0 ; table [ 0 ] = 1 ; for ( i = 3 ; i <= n ; i ++ ) table [ i ] += table [ i - 3 ] ; for ( i = 5 ; i <= n ; i ++ ) table [ i ] += table [ i - 5 ] ; for ( i = 10 ; i <= n ; i ++ ) table [ i ] += table [ i - 10 ] ; return table [ n ] ; }
Ref: 
function count ( n ) { let table = new Array ( n + 1 ) , i ; for ( let j = 0 ; j < n + 1 ; j ++ ) table [ j ] = 0 ; table [ 0 ] = 1 ; for ( i = 3 ; i <= n ; i ++ ) table [ i ] += table [ i - 3 ] ; for ( i = 5 ; i <= n ; i ++ ) table [ i ] += table [ i - 5 ] ; for ( i = 10 ; i <= n ; i ++ ) table [ i ] += table [ i - 10 ] ; return table [ n ] ; }
Hyp: 
function count ( n ) { let table = Array ( n + 1 ) . fill ( 0 ) ; for ( let j = 0 ; j < n + 1 ; j ++ ) table [ j ] = 0 ; table [ 0 ] = 1 ; for ( i = 3 ; i <= n ; i ++ ) table [ i ] += table [ i - 3 ] ; for ( i = 5 ; i <= n ; i ++ ) table [ i ] += table [ i - 5 ] ; for ( i = 10 ; i <= n ; i ++ ) table [ i ] += table [ i - 10 ] ; return table [ n ] ; }

BLEU: 93.93
Edit Sim: 14


Src: 
int countDigits ( int a , int b ) { int count = 0 ; int p = abs ( a / b ) ; if ( p == 0 ) return 1 ; while ( p > 0 ) { count ++ ; p = p / 10 ; } return count ; }
Ref: 
function countDigits ( a , b ) { var count = 0 ; var p = Math . abs ( parseInt ( a / b ) ) ; if ( p == 0 ) return 1 ; while ( p > 0 ) { count ++ ; p = parseInt ( p / 10 ) ; } return count ; }
Hyp: 
function countDigits ( a , b ) { let count = 0 ; let p = Math . abs ( a / b ) ; if ( p == 0 ) return 1 ; while ( p > 0 ) { count ++ ; p = Math . floor ( p / 10 ) ; } return count ; }

BLEU: 79.54
Edit Sim: 30


Src: 
void pairs ( int arr [ ] , int n , int k ) { int smallest = INT_MAX ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) { if ( abs ( arr [ i ] + arr [ j ] - k ) < smallest ) { smallest = abs ( arr [ i ] + arr [ j ] - k ) ; count = 1 ; } else if ( abs ( arr [ i ] + arr [ j ] - k ) == smallest ) count ++ ; } cout << " Minimal ▁ Value ▁ = ▁ " << smallest << " STRNEWLINE " ; cout << " Total ▁ Pairs ▁ = ▁ " << count << " STRNEWLINE " ; }
Ref: 
function pairs ( arr , n , k ) { var smallest = 1000000000 ; var count = 0 ; for ( var i = 0 ; i < n ; i ++ ) for ( var j = i + 1 ; j < n ; j ++ ) { if ( Math . abs ( arr [ i ] + arr [ j ] - k ) < smallest ) { smallest = Math . abs ( arr [ i ] + arr [ j ] - k ) ; count = 1 ; } else if ( Math . abs ( arr [ i ] + arr [ j ] - k ) == smallest ) count ++ ; } document . write ( " " + smallest + " " ) ; document . write ( " " + count + " " ) ; }
Hyp: 
function pairs ( arr , n , k ) { let smallest = Number . MAX_VALUE ; let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = i + 1 ; j < n ; j ++ ) { if ( Math . abs ( arr [ i ] + arr [ j ] - k ) < smallest ) { smallest = Math . abs ( arr [ i ] + arr [ j ] - k ) ; count = 1 ; } else if ( Math . abs ( arr [ i ] + arr [ j ] - k ) == smallest ) count ++ ; } document . write ( " " + smallest + " " ) ; }

BLEU: 83.46
Edit Sim: 71


Src: 
double Area ( int b1 , int b2 , int h ) { return ( ( b1 + b2 ) / 2 ) * h ; }
Ref: 
function Area ( b1 , b2 , h ) { return ( ( b1 + b2 ) / 2 ) * h ; }
Hyp: 
function Area ( b1 , b2 , h ) { return ( ( b1 + b2 ) / 2 ) * h ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int maxSum ( int arr [ ] , int n ) { int res = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { int curr_sum = 0 ; for ( int j = 0 ; j < n ; j ++ ) { int index = ( i + j ) % n ; curr_sum += j * arr [ index ] ; } res = max ( res , curr_sum ) ; } return res ; }
Ref: 
function maxSum ( arr , n ) { var res = Number . MIN_VALUE ; for ( i = 0 ; i < n ; i ++ ) { var curr_sum = 0 ; for ( j = 0 ; j < n ; j ++ ) { var index = ( i + j ) % n ; curr_sum += j * arr [ index ] ; } res = Math . max ( res , curr_sum ) ; } return res ; }
Hyp: 
function maxSum ( arr , n ) { let res = Number . MIN_VALUE ; for ( let i = 0 ; i < n ; i ++ ) { let curr_sum = 0 ; for ( let j = 0 ; j < n ; j ++ ) { let index = ( i + j ) % n ; curr_sum += j * arr [ index ] ; } res = Math . max ( res , curr_sum ) ; } return res ; }

BLEU: 85.2
Edit Sim: 17


Src: 
int minSum ( int a [ ] , int n ) { sort ( a , a + n ) ; int num1 = 0 ; int num2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) num1 = num1 * 10 + a [ i ] ; else num2 = num2 * 10 + a [ i ] ; } return num2 + num1 ; }
Ref: 
function minSum ( a , n ) { a . sort ( ) ; let num1 = 0 ; let num2 = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) num1 = num1 * 10 + a [ i ] ; else num2 = num2 * 10 + a [ i ] ; } return num2 + num1 ; }
Hyp: 
function minSum ( a , n ) { a . sort ( ( a , b ) => a - b ) ; let num1 = 0 ; let num2 = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) num1 = num1 * 10 + a [ i ] ; else num2 = num2 * 10 + a [ i ] ; } return num2 + num1 ; }

BLEU: 87.69
Edit Sim: 19


Src: 
int main ( ) { char str [ ] = "11333445538" ; int len = strlen ( str ) ; char * num = tidyNum ( str , len ) ; printf ( " % s STRNEWLINE " , num ) ; return 0 ; }
Ref: 
function tidyNum ( str1 , len ) { var str = str1 . split ( ' ' ) ; for ( i = len - 2 ; i >= 0 ; i -- ) { if ( str [ i ] > str [ i + 1 ] ) { str [ i ] -- ; for ( j = i + 1 ; j < len ; j ++ ) str [ j ] = ' ' ; } } return str . join ( " " ) ; }
Hyp: 
function main ( ) { let str = " " ; let len = str . length ; let num = tidyNum ( str , len ) ; document . write ( " " + num . toFixed ( 10 ) ) ; return 0 ; }

BLEU: 5.19
Edit Sim: 156


Src: 
int minPower ( int n , int x ) { if ( x == 1 ) return n ; int ans = 0 ; while ( n > 0 ) { ans += ( n % x ) ; n /= x ; } return ans ; }
Ref: 
function minPower ( n , x ) { if ( x == 1 ) return n ; let ans = 0 ; while ( n > 0 ) { ans += ( n % x ) ; n = Math . floor ( n / x ) ; } return ans ; }
Hyp: 
function minPower ( n , x ) { if ( x == 1 ) return n ; let ans = 0 ; while ( n > 0 ) { ans += ( n % x ) ; n = Math . floor ( n / x ) ; } return ans ; }

BLEU: 100.0
Edit Sim: 0


Src: 
void splitArr ( int arr [ ] , int n , int k ) { for ( int i = 0 ; i < k ; i ++ ) { int x = arr [ 0 ] ; for ( int j = 0 ; j < n - 1 ; ++ j ) arr [ j ] = arr [ j + 1 ] ; arr [ n - 1 ] = x ; } }
Ref: 
function splitArr ( arr , n , k ) { for ( let i = 0 ; i < k ; i ++ ) { let x = arr [ 0 ] ; for ( let j = 0 ; j < n - 1 ; ++ j ) arr [ j ] = arr [ j + 1 ] ; arr [ n - 1 ] = x ; } }
Hyp: 
function splitArr ( arr , n , k ) { for ( let i = 0 ; i < k ; i ++ ) { let x = arr [ 0 ] ; for ( let j = 0 ; j < n - 1 ; ++ j ) arr [ j ] = arr [ j + 1 ] ; arr [ n - 1 ] = x ; } }

BLEU: 100.0
Edit Sim: 0


Src: 
void areSame ( int a , int b ) { if ( ! ( a - b ) ) cout << " Same " ; else cout << " Not ▁ Same " ; }
Ref: 
function areSame ( a , b ) { if ( ( a - b ) == 0 ) document . write ( " " ) ; else document . write ( " " ) ; }
Hyp: 
function areSame ( a , b ) { if ( ( a - b ) ) document . write ( " " ) ; else document . write ( " " ) ; }

BLEU: 89.9
Edit Sim: 5


Src: 
float area ( float r ) { if ( r < 0 ) return -1 ; float area = 3.14 * pow ( r / ( 2 * sqrt ( 2 ) ) , 2 ) ; return area ; }
Ref: 
function area ( r ) { if ( r < 0 ) return - 1 ; var area = ( 3.14 * Math . pow ( r / ( 2 * Math . sqrt ( 2 ) ) , 2 ) ) ; return area ; }
Hyp: 
function area ( r ) { if ( r < 0 ) return - 1 ; var area = 3.14 * Math . pow ( r / ( 2 * Math . sqrt ( 2 ) ) , 2 ) ; return area ; }

BLEU: 90.61
Edit Sim: 4


Src: 
void print ( int p0 ) { int p1 , i = 0 , x , flag , k ; while ( 1 ) { flag = 1 ; x = ( int ) ( pow ( 2 , i ) ) ; p1 = x * p0 - ( x - 1 ) ; for ( k = 2 ; k < p1 ; k ++ ) { if ( p1 % k == 0 ) { flag = 0 ; break ; } } if ( flag == 0 ) break ; printf ( " % d ▁ " , p1 ) ; i ++ ; } }
Ref: 
function print ( p0 ) { var p1 , i = 0 , x , flag = 1 , k , m = 4 ; while ( flag ) { flag = 1 ; x = Math . pow ( 2 , i ) ; p1 = x * p0 - ( x - 1 ) ; for ( k = 2 ; k < p1 ; k ++ ) { if ( p1 % k == 0 ) { flag = 0 ; break ; } } if ( flag == 0 ) break ; document . write ( p1 + " " ) ; i ++ ; } }
Hyp: 
function print ( p0 ) { let p1 , i = 0 , x , flag , k ; while ( 1 ) { flag = 1 ; x = Math . pow ( 2 , i ) ; p1 = x * p0 - ( x - 1 ) ; for ( k = 2 ; k < p1 ; k ++ ) { if ( p1 % k == 0 ) { flag = 0 ; break ; } } if ( flag == 0 ) break ; document . write ( " " + p1 ) ; i ++ ; } }

BLEU: 83.5
Edit Sim: 25


Src: 
float area_circumscribed ( float c ) { return ( c * c * ( PI / 4 ) ) ; }
Ref: 
function area_cicumscribed ( c ) { return ( c * c * ( PI / 4 ) ) ; }
Hyp: 
function area_circumscribed ( c ) { return ( c * c * ( 3.1415 / 4 ) ) ; }

BLEU: 77.22
Edit Sim: 7


Src: 
void bestApproximate ( int x [ ] , int y [ ] , int n ) { float m , c , sum_x = 0 , sum_y = 0 , sum_xy = 0 , sum_x2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum_x += x [ i ] ; sum_y += y [ i ] ; sum_xy += x [ i ] * y [ i ] ; sum_x2 += pow ( x [ i ] , 2 ) ; } m = ( n * sum_xy - sum_x * sum_y ) / ( n * sum_x2 - pow ( sum_x , 2 ) ) ; c = ( sum_y - m * sum_x ) / n ; cout << " m ▁ = " << m ; cout << " c = " }
Ref: 
function bestApproximate ( x , y , n ) { let m , c , sum_x = 0 , sum_y = 0 , sum_xy = 0 , sum_x2 = 0 ; for ( let i = 0 ; i < n ; i ++ ) { sum_x += x [ i ] ; sum_y += y [ i ] ; sum_xy += x [ i ] * y [ i ] ; sum_x2 += Math . pow ( x [ i ] , 2 ) ; } m = ( n * sum_xy - sum_x * sum_y ) / ( n * sum_x2 - Math . pow ( sum_x , 2 ) ) ; c = ( sum_y - m * sum_x ) / n ; document . write ( " " + m ) ; document . write ( " " + c ) ; }
Hyp: 
function bestApproximate ( x , y , n ) { var m , c , sum_x = 0 , sum_y = 0 , sum_xy = 0 , sum_x2 = 0 ; for ( var i = 0 ; i < n ; i ++ ) { sum_x += x [ i ] ; sum_y += y [ i ] ; sum_xy += x [ i ] * y [ i ] ; sum_x2 += Math . pow ( x [ i ] , 2 ) ; } m = ( n * sum_xy - sum_x * sum_y ) / ( n * sum_x2 - Math . pow ( sum_x , 2 ) ) ; c = ( sum_y - m * sum_x ) / n ; document . write ( " " + m ) ; document . write ( " " + c ) ; }

BLEU: 96.56
Edit Sim: 6


Src: 
int maxProduct ( int arr [ ] , int n ) { if ( n < 4 ) return -1 ; int max_product = INT_MIN ; for ( int i = 0 ; i < n - 3 ; i ++ ) for ( int j = i + 1 ; j < n - 2 ; j ++ ) for ( int k = j + 1 ; k < n - 1 ; k ++ ) for ( int l = k + 1 ; l < n ; l ++ ) max_product = max ( max_product , arr [ i ] * arr [ j ] * arr [ k ] * arr [ l ] ) ; return max_product ; }
Ref: 
function maxProduct ( arr , n ) { if ( n < 4 ) return - 1 ; let max_product = Number . MIN_VALUE ; for ( let i = 0 ; i < n - 3 ; i ++ ) for ( let j = i + 1 ; j < n - 2 ; j ++ ) for ( let k = j + 1 ; k < n - 1 ; k ++ ) for ( let l = k + 1 ; l < n ; l ++ ) max_product = Math . max ( max_product , arr [ i ] * arr [ j ] * arr [ k ] * arr [ l ] ) ; return max_product ; }
Hyp: 
function maxProduct ( arr , n ) { if ( n < 4 ) return - 1 ; let max_product = Number . MAX_VALUE ; for ( let i = 0 ; i < n - 3 ; i ++ ) for ( let j = i + 1 ; j < n - 2 ; j ++ ) for ( let k = j + 1 ; k < n - 1 ; k ++ ) for ( let l = k + 1 ; l < n ; l ++ ) max_product = max ( max_product , arr [ i ] * arr [ j ] * arr [ k ] * arr [ l ] ) ; return max_product ; }

BLEU: 95.18
Edit Sim: 9


Src: 
int findDiff ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int count = 0 , max_count = 0 , min_count = n ; for ( int i = 0 ; i < ( n - 1 ) ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) { count += 1 ; continue ; } else { max_count = max ( max_count , count ) ; min_count = min ( min_count , count ) ; count = 0 ; } } return ( max_count - min_count ) ; }
Ref: 
function findDiff ( arr , n ) { arr . sort ( function ( a , b ) { return a - b } ) ; let count = 0 , max_count = 0 , min_count = n ; for ( let i = 0 ; i < ( n - 1 ) ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) { count += 1 ; continue ; } else { max_count = Math . max ( max_count , count ) ; min_count = Math . min ( min_count , count ) ; count = 0 ; } } return ( max_count - min_count ) ; }
Hyp: 
function findDiff ( arr , n ) { arr . sort ( function ( a , b ) { return a - b ; } ) ; let count = 0 , max_count = 0 , min_count = n ; for ( let i = 0 ; i < ( n - 1 ) ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) { count += 1 ; continue ; } else { max_count = Math . max ( max_count , count ) ; min_count = Math . min ( min_count , count ) ; count = 0 ; } } return ( max_count - min_count ) ; }

BLEU: 97.88
Edit Sim: 2


Src: 
int arraySum ( int arr [ ] , int n ) { int x = ( n + 1 ) / 2 ; return ( arr [ 0 ] - 1 ) * n + x * x ; }
Ref: 
function arraySum ( arr , n ) { let x = ( n + 1 ) / 2 ; return ( arr [ 0 ] - 1 ) * n + x * x ; }
Hyp: 
function arraySum ( arr , n ) { let x = parseInt ( ( n + 1 ) / 2 ) ; return ( arr [ 0 ] - 1 ) * n + x * x ; }

BLEU: 84.0
Edit Sim: 13


Src: 
int countgroup ( int a [ ] , int n ) { int xs = 0 ; for ( int i = 0 ; i < n ; i ++ ) xs = xs ^ a [ i ] ; if ( xs == 0 ) return ( 1 << ( n - 1 ) ) - 1 ; return 0 ; }
Ref: 
function countgroup ( a , n ) { var xs = 0 ; for ( var i = 0 ; i < n ; i ++ ) xs = xs ^ a [ i ] ; if ( xs == 0 ) return ( 1 << ( n - 1 ) ) - 1 ; }
Hyp: 
function countgroup ( a , n ) { let xs = 0 ; for ( let i = 0 ; i < n ; i ++ ) xs = xs ^ a [ i ] ; if ( xs == 0 ) return ( 1 << ( n - 1 ) ) - 1 ; return 0 ; }

BLEU: 85.24
Edit Sim: 17


Src: 
int countSubarrays ( const int * arr , int n , int K ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { ll product = 1 ; for ( int x = i ; x <= j ; x ++ ) product *= arr [ x ] ; if ( product % K == 0 ) count ++ ; } } return count ; }
Ref: 
function countSubarrays ( arr , n , K ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i ; j < n ; j ++ ) { let product = 1 ; for ( let x = i ; x <= j ; x ++ ) product *= arr [ x ] ; if ( product % K == 0 ) count ++ ; } } return count ; }
Hyp: 
function countSubarrays ( arr , n , K ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i ; j < n ; j ++ ) { let product = 1 ; for ( let x = i ; x <= j ; x ++ ) product *= arr [ x ] ; if ( product % K == 0 ) count ++ ; } } return count ; }

BLEU: 100.0
Edit Sim: 0


Src: 
void form_sieve ( ) { sieve_Prime [ 1 ] = 1 ; for ( int i = 2 ; i <= MAX ; i ++ ) { if ( sieve_Prime [ i ] == 0 ) { for ( int j = i * 2 ; j <= MAX ; j += i ) { if ( sieve_Prime [ j ] == 0 ) { sieve_Prime [ j ] = 1 ; sieve_count [ i ] ++ ; } } } } }
Ref: 
function form_sieve ( ) { sieve_Prime [ 1 ] = 1 ; for ( i = 2 ; i <= MAX ; i ++ ) { if ( sieve_Prime [ i ] == 0 ) { for ( j = i * 2 ; j <= MAX ; j += i ) { if ( sieve_Prime [ j ] == 0 ) { sieve_Prime [ j ] = 1 ; sieve_count [ i ] ++ ; } } } } }
Hyp: 
function form_sieve ( ) { sieve_Prime [ 1 ] = 1 ; for ( let i = 2 ; i <= MAX ; i ++ ) { if ( sieve_Prime [ i ] == 0 ) { for ( let j = i * 2 ; j <= MAX ; j += i ) { if ( sieve_Prime [ j ] == 0 ) { sieve_Prime [ j ] = 1 ; sieve_count [ i ] ++ ; } } } } }

BLEU: 93.86
Edit Sim: 8


Src: 
int calculate ( int x , int k , int m ) { int result = x ; k -- ; while ( k -- ) { result = pow ( result , x ) ; if ( result > m ) result %= m ; } return result ; }
Ref: 
function calculate ( x , k , m ) { let result = x ; k = k - 1 ; while ( k -- ) { result = Math . pow ( result , x ) ; if ( result > m ) result %= m ; } return result ; }
Hyp: 
function calculate ( x , k , m ) { let result = x ; k -- ; while ( k -- ) { result = Math . pow ( result , x ) ; if ( result > m ) result %= m ; } return result ; }

BLEU: 89.34
Edit Sim: 6


Src: 
int largestSubset ( int a [ ] , int n ) { int dp [ n ] ; dp [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { int mxm = 0 ; for ( int j = i + 1 ; j < n ; j ++ ) if ( a [ j ] % a [ i ] == 0 a [ i ] % a [ j ] == 0 ) mxm = max ( mxm , dp [ j ] ) ; dp [ i ] = 1 + mxm ; } return * max_element ( dp , dp + n ) ; }
Ref: 
function largestSubset ( a , n ) { let dp = [ ] ; dp [ n - 1 ] = 1 ; for ( let i = n - 2 ; i >= 0 ; i -- ) { let mxm = 0 ; for ( let j = i + 1 ; j < n ; j ++ ) { if ( a [ j ] % a [ i ] == 0 a [ i ] % a [ j ] == 0 ) { mxm = Math . max ( mxm , dp [ j ] ) ; } } dp [ i ] = 1 + mxm ; } return Math . max ( ... dp ) ; }
Hyp: 
function largestSubset ( a , n ) { let dp = new Array ( n ) ; dp [ n - 1 ] = 1 ; for ( let i = n - 2 ; i >= 0 ; i -- ) { let mxm = 0 ; for ( let j = i + 1 ; j < n ; j ++ ) if ( a [ j ] % a [ i ] == 0 a [ i ] % a [ j ] == 0 ) mxm = Math . max ( mxm , dp [ j ] ) ; dp [ i ] = 1 + mxm ; } return dp [ n ] ; }

BLEU: 84.72
Edit Sim: 40


Src: 
void findNumberOfDigits ( long n , int base ) { int dig = ( int ) ( floor ( log ( n ) / log ( base ) ) + 1 ) ; cout << " The ▁ Number ▁ of ▁ digits ▁ of ▁ " << " Number ▁ " << n << " ▁ in ▁ base ▁ " << base << " ▁ is ▁ " << dig ; }
Ref: 
function findNumberOfDigits ( n , base ) { var dig = parseInt ( Math . floor ( Math . log ( n ) / Math . log ( base ) ) + 1 ) ; document . write ( " " + " " + n + " " + base + " " + dig ) ; }
Hyp: 
function findNumberOfDigits ( n , base ) { let dig = parseInt ( Math . floor ( Math . log ( n ) / Math . log ( base ) ) + 1 ) ; document . write ( " " + dig + " " + " " ) ; }

BLEU: 77.72
Edit Sim: 23


Src: 
int decideWinner ( int a [ ] , int n ) { int count0 = 0 ; int count1 = 0 ; int count2 = 0 ; int count3 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 4 == 0 ) count0 ++ ; else if ( a [ i ] % 4 == 1 ) count1 ++ ; else if ( a [ i ] % 4 == 2 ) count2 ++ ; else if ( a [ i ] % 4 == 3 ) count3 ++ ; } if ( count0 % 2 == 0 && count1 % 2 == 0 && count2 % 2 == 0 && count3 == 0 ) return 1 ; else return 2 ; }
Ref: 
function decideWinner ( a , n ) { var count0 = 0 ; var count1 = 0 ; var count2 = 0 ; var count3 = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 4 == 0 ) count0 ++ ; else if ( a [ i ] % 4 == 1 ) count1 ++ ; else if ( a [ i ] % 4 == 2 ) count2 ++ ; else if ( a [ i ] % 4 == 3 ) count3 ++ ; } if ( count0 % 2 == 0 && count1 % 2 == 0 && count2 % 2 == 0 && count3 == 0 ) return 1 ; else return 2 ; }
Hyp: 
function decideWinner ( a , n ) { var count0 = 0 ; var count1 = 0 ; var count2 = 0 ; var count3 = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 4 == 0 ) count0 ++ ; else if ( a [ i ] % 4 == 1 ) count1 ++ ; else if ( a [ i ] % 4 == 2 ) count2 ++ ; else if ( a [ i ] % 4 == 3 ) count3 ++ ; } if ( count0 % 2 == 0 && count1 % 2 == 0 && count2 % 2 == 0 && count3 == 0 ) return 1 ; else return 2 ; }

BLEU: 98.13
Edit Sim: 4


Src: 
int minToggle ( int arr [ ] , int n ) { int zero [ n + 1 ] ; zero [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { if ( arr [ i - 1 ] == 0 ) zero [ i ] = zero [ i - 1 ] + 1 ; else zero [ i ] = zero [ i - 1 ] ; } int ans = n ; for ( int i = 1 ; i <= n ; ++ i ) ans = min ( ans , i - zero [ i ] + zero [ n ] - zero [ i ] ) ; return ans ; }
Ref: 
function minToggle ( arr , n ) { let zero = new Array ( n + 1 ) ; zero [ 0 ] = 0 ; for ( let i = 1 ; i <= n ; ++ i ) { if ( arr [ i - 1 ] == 0 ) zero [ i ] = zero [ i - 1 ] + 1 ; else zero [ i ] = zero [ i - 1 ] ; } let ans = n ; for ( let i = 1 ; i <= n ; ++ i ) ans = Math . min ( ans , i - zero [ i ] + zero [ n ] - zero [ i ] ) ; return ans ; }
Hyp: 
function minToggle ( arr , n ) { let zero = new Array ( n + 1 ) ; zero [ 0 ] = 0 ; let i ; for ( i = 1 ; i <= n ; ++ i ) { if ( arr [ i - 1 ] == 0 ) zero [ i ] = zero [ i - 1 ] + 1 ; else zero [ i ] = zero [ i - 1 ] ; } let ans = n ; for ( i = 1 ; i <= n ; ++ i ) ans = Math . min ( ans , i - zero [ i ] + zero [ n ] - zero [ i ] ) ; return ans ; }

BLEU: 95.11
Edit Sim: 15


Src: 
int calSum ( int n ) { return ( n * ( 2 * n * n * n + 12 * n * n + 25 * n + 21 ) ) / 2 ; }
Ref: 
function calSum ( n ) { return ( n * ( 2 * n * n * n + 12 * n * n + 25 * n + 21 ) ) / 2 ; }
Hyp: 
function calSum ( n ) { return ( n * ( 2 * n * n * n + 12 * n * n + 25 * n + 21 ) ) / 2 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
bool checkConcurrent ( int a1 , int b1 , int c1 , int a2 , int b2 , int c2 , int a3 , int b3 , int c3 ) { return ( a3 * ( b1 * c2 - b2 * c1 ) + b3 * ( c1 * a2 - c2 * a1 ) + c3 * ( a1 * b2 - a2 * b1 ) == 0 ) ; }
Ref: 
function checkConcurrent ( a1 , b1 , c1 , a2 , b2 , c2 , a3 , b3 , c3 ) { return ( a3 * ( b1 * c2 - b2 * c1 ) + b3 * ( c1 * a2 - c2 * a1 ) + c3 * ( a1 * b2 - a2 * b1 ) == 0 ) ; }
Hyp: 
function checkConcurrent ( a1 , b1 , c1 , a2 , b2 , c2 , a3 , b3 , c3 ) { return ( a3 * ( b1 * c2 - b2 * c1 ) + b3 * ( c1 * a2 - c2 * a1 ) + c3 * ( a1 * b2 - a2 * b1 ) == 0 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
float distance ( int x1 , int y1 , int x2 , int y2 ) { return sqrt ( pow ( x2 - x1 , 2 ) + pow ( y2 - y1 , 2 ) * 1.0 ) ; }
Ref: 
function distance ( x1 , y1 , x2 , y2 ) { return Math . sqrt ( Math . pow ( x2 - x1 , 2 ) + Math . pow ( y2 - y1 , 2 ) * 1.0 ) ; }
Hyp: 
function distance ( x1 , y1 , x2 , y2 ) { return Math . pow ( ( Math . pow ( x2 - x1 , 2 ) + Math . pow ( y2 - y1 , 2 ) * 1.0 ) , 0.5 ) ; }

BLEU: 84.18
Edit Sim: 13


Src: 
int findExtra ( int arr1 [ ] , int arr2 [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) if ( arr1 [ i ] != arr2 [ i ] ) return i ; return n ; }
Ref: 
function findExtra ( arr1 , arr2 , n ) { for ( let i = 0 ; i < n ; i ++ ) if ( arr1 [ i ] != arr2 [ i ] ) return i ; return n ; }
Hyp: 
function findExtra ( arr1 , arr2 , n ) { for ( let i = 0 ; i < n ; i ++ ) if ( arr1 [ i ] != arr2 [ i ] ) return i ; return n ; }

BLEU: 100.0
Edit Sim: 0


Src: 
ll count_of_ways ( ll n ) { ll count ; count = ( n + 1 ) * ( n + 2 ) / 2 ; return count ; }
Ref: 
function count_of_ways ( n ) { var count = 0 ; count = ( n + 1 ) * ( n + 2 ) / 2 ; return count ; }
Hyp: 
function count_of_ways ( n ) { let count ; count = ( n + 1 ) * ( n + 2 ) / 2 ; return count ; }

BLEU: 82.33
Edit Sim: 7


Src: 
int maximumDifferenceSum ( int arr [ ] , int N ) { int dp [ N ] [ 2 ] ; for ( int i = 0 ; i < N ; i ++ ) dp [ i ] [ 0 ] = dp [ i ] [ 1 ] = 0 ; for ( int i = 0 ; i < ( N - 1 ) ; i ++ ) { dp [ i + 1 ] [ 0 ] = max ( dp [ i ] [ 0 ] , dp [ i ] [ 1 ] + abs ( 1 - arr [ i ] ) ) ; dp [ i + 1 ] [ 1 ] = max ( dp [ i ] [ 0 ] + abs ( arr [ i + 1 ] - 1 ) , dp [ i ] [ 1 ] + abs ( arr [ i + 1 ] - arr [ i ] ) ) ; } return max ( dp [ N - 1 ] [ 0 ] , dp [ N - 1 ] [ 1 ] ) ; }
Ref: 
function maximumDifferenceSum ( arr , N ) { let dp = new Array ( N ) ; for ( let i = 0 ; i < N ; i ++ ) { dp [ i ] = new Array ( 2 ) ; for ( let j = 0 ; j < 2 ; j ++ ) { dp [ i ] [ j ] = 0 ; } } for ( let i = 0 ; i < N ; i ++ ) dp [ i ] [ 0 ] = dp [ i ] [ 1 ] = 0 ; for ( let i = 0 ; i < ( N - 1 ) ; i ++ ) { dp [ i + 1 ] [ 0 ] = Math . max ( dp [ i ] [ 0 ] , dp [ i ] [ 1 ] + Math . abs ( 1 - arr [ i ] ) ) ; dp [ i + 1 ] [ 1 ] = Math . max ( dp [ i ] [ 0 ] + Math . abs ( arr [ i + 1 ] - 1 ) , dp [ i ] [ 1 ] + Math . abs ( arr [ i + 1 ] - arr [ i ] ) ) ; } return Math . max ( dp [ N - 1 ] [ 0 ] , dp [ N - 1 ] [ 1 ] ) ; }
Hyp: 
function maximumDifferenceSum ( arr , N ) { let dp = new Array ( N ) ; for ( let i = 0 ; i < N ; i ++ ) dp [ i ] [ 0 ] = dp [ i ] [ 1 ] = 0 ; for ( let i = 0 ; i < N ; i ++ ) { dp [ i + 1 ] [ 0 ] = Math . max ( dp [ i ] [ 0 ] , dp [ i ] [ 1 ] + Math . abs ( 1 - arr [ i ] ) ) ; dp [ i + 1 ] [ 1 ] = Math . max ( dp [ i ] [ 0 ] + Math . abs ( arr [ i + 1 ] - 1 ) , dp [ i ] [ 1 ] + Math . abs ( arr [ i + 1 ] - arr [ i ] ) ) ; } return Math . max ( dp [ N - 1 ] [ 0 ] , dp [ N - 1 ] [ 1 ] ) ; }

BLEU: 74.88
Edit Sim: 132


Src: 
int countSetBits ( unsigned int n ) { unsigned int count = 0 ; while ( n ) { count += n & 1 ; n >>= 1 ; } return count ; }
Ref: 
function countSetBits ( n ) { var count = 0 ; while ( n ) { count += n & 1 ; n >>= 1 ; } return count ; }
Hyp: 
function countSetBits ( n ) { var count = 0 ; while ( n ) { count += n & 1 ; n >>= 1 ; } return count ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int next ( int arr [ ] , int target , int end ) { int start = 0 ; int ans = -1 ; while ( start <= end ) { int mid = ( start + end ) / 2 ; if ( arr [ mid ] <= target ) start = mid + 1 ; else { ans = mid ; end = mid - 1 ; } } return ans ; }
Ref: 
function next ( arr , target ) { let start = 0 , end = arr . length - 1 ; let ans = - 1 ; while ( start <= end ) { let mid = parseInt ( ( start + end ) / 2 , 10 ) ; if ( arr [ mid ] <= target ) { start = mid + 1 ; } else { ans = mid ; end = mid - 1 ; } } return ans ; }
Hyp: 
function next ( arr , target , end ) { let start = 0 ; let ans = - 1 ; while ( start <= end ) { let mid = parseInt ( ( start + end ) / 2 ) ; if ( arr [ mid ] <= target ) start = mid + 1 ; else { ans = mid ; end = mid - 1 ; } } return ans ; }

BLEU: 76.74
Edit Sim: 39


Src: 
int countSubstringWithEqualEnds ( string s ) { int result = 0 ; int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i ; j < n ; j ++ ) if ( s [ i ] == s [ j ] ) result ++ ; return result ; }
Ref: 
function countSubstringWithEqualEnds ( s ) { var result = 0 ; var n = s . length ; for ( i = 0 ; i < n ; i ++ ) for ( j = i ; j < n ; j ++ ) if ( s . charAt ( i ) == s . charAt ( j ) ) result ++ ; return result ; }
Hyp: 
function countSubstringWithEqualEnds ( s ) { let result = 0 ; let n = s . length ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = i ; j < n ; j ++ ) if ( s [ i ] == s [ j ] ) result ++ ; return result ; }

BLEU: 68.46
Edit Sim: 36


Src: 
int countDigitOne ( int n ) { int countr = 0 ; for ( int i = 1 ; i <= n ; i *= 10 ) { int divider = i * 10 ; countr += ( n / divider ) * i + min ( max ( n % divider - i + 1 , 0 ) , i ) ; } return countr ; }
Ref: 
function countDigitOne ( n ) { var countr = 0 ; for ( var i = 1 ; i <= n ; i *= 10 ) { var divider = i * 10 ; countr += parseInt ( n / divider ) * i + Math . min ( Math . max ( n % divider - i + 1 , 0 ) , i ) ; } return countr ; }
Hyp: 
function countDigitOne ( n ) { let countr = 0 ; for ( let i = 1 ; i <= n ; i *= 10 ) { let divider = i * 10 ; countr += ( n / divider ) * i + Math . min ( Math . max ( n % divider - i + 1 , 0 ) , i ) ; } return countr ; }

BLEU: 85.67
Edit Sim: 18


Src: 
int multiplyWith3Point5 ( int x ) { return ( x << 1 ) + x + ( x >> 1 ) ; }
Ref: 
function multiplyWith3Point5 ( x ) { return ( x << 1 ) + x + ( x >> 1 ) ; }
Hyp: 
function multiplyWith3Point5 ( x ) { return ( x << 1 ) + x + ( x >> 1 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
void findPoint ( int x1 , int y1 , int x2 , int y2 ) { cout << " ( " << 2 * x2 - x1 << " , ▁ " << 2 * y2 - y1 << " ) " ; }
Ref: 
function findPoint ( x1 , y1 , x2 , y2 ) { document . write ( " " + 2 * ( x2 - x1 ) + " " + 2 * ( y2 - y1 ) + " " ) ; }
Hyp: 
function findPoint ( x1 , y1 , x2 , y2 ) { document . write ( " " + 2 * x2 - x1 + " " + 2 * y2 - y1 + " " ) ; }

BLEU: 75.07
Edit Sim: 8


Src: 
float square ( float a ) { if ( a < 0 ) return -1 ; float x = 0.464 * a ; return x ; }
Ref: 
function square ( a ) { if ( a < 0 ) return - 1 ; var x = 0.464 * a ; return x ; }
Hyp: 
function square ( a ) { if ( a < 0 ) return - 1 ; var x = 0.464 * a ; return x ; }

BLEU: 100.0
Edit Sim: 0


Src: 
string decryptString ( string str , int n ) { int i = 0 , jump = 1 ; string decryptedStr = " " ; while ( i < n ) { decryptedStr += str [ i ] ; i += jump ; jump ++ ; } return decryptedStr ; }
Ref: 
function decryptString ( str , n ) { let i = 0 , jump = 1 ; let decryptedStr = " " ; while ( i < n ) { decryptedStr += str [ i ] ; i += jump ; jump ++ ; } return decryptedStr ; }
Hyp: 
function decryptString ( str , n ) { let i = 0 , jump = 1 ; let decryptedStr = " " ; while ( i < n ) { decryptedStr += str [ i ] ; i += jump ; jump ++ ; } return decryptedStr ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int remainder ( string str ) { int len = str . length ( ) ; int num , rem = 0 ; for ( int i = 0 ; i < len ; i ++ ) { num = rem * 10 + ( str [ i ] - '0' ) ; rem = num % 11 ; } return rem ; }
Ref: 
function remainder ( str ) { let len = str . length ; let num ; let rem = 0 ; for ( let i = 0 ; i < len ; i ++ ) { num = rem * 10 + ( str [ i ] - ' ' ) ; rem = num % 11 ; } return rem ; }
Hyp: 
function remainder ( str ) { let len = str . length ; let num , rem = 0 ; for ( let i = 0 ; i < len ; i ++ ) { num = rem * 10 + ( str [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ) ; rem = num % 11 ; } return rem ; }

BLEU: 80.33
Edit Sim: 39


Src: 
int checkpoint ( int h , int k , int x , int y , int a ) { int p = pow ( ( y - k ) , 2 ) - 4 * a * ( x - h ) ; return p ; }
Ref: 
function checkpoint ( h , k , x , y , a ) { var p = parseInt ( Math . pow ( ( y - k ) , 2 ) - 4 * a * ( x - h ) ) ; return p ; }
Hyp: 
function checkpoint ( h , k , x , y , a ) { let p = Math . pow ( ( y - k ) , 2 ) - 4 * a * ( x - h ) ; return p ; }

BLEU: 83.37
Edit Sim: 16


Src: 
int coutSubSeq ( int A [ ] , int N , int M ) { int sum = 0 ; int ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { for ( int k = j + 1 ; k < N ; k ++ ) { sum = A [ i ] + A [ j ] + A [ k ] ; if ( sum % M == 0 ) ans ++ ; } } } return ans ; }
Ref: 
function coutSubSeq ( A , N , M ) { let sum = 0 ; let ans = 0 ; for ( let i = 0 ; i < N ; i ++ ) { for ( let j = i + 1 ; j < N ; j ++ ) { for ( let k = j + 1 ; k < N ; k ++ ) { sum = A [ i ] + A [ j ] + A [ k ] ; if ( sum % M == 0 ) ans ++ ; } } } return ans ; }
Hyp: 
function coutSubSeq ( A , N , M ) { let sum = 0 ; let ans = 0 ; for ( let i = 0 ; i < N ; i ++ ) { for ( let j = i + 1 ; j < N ; j ++ ) { for ( let k = j + 1 ; k < N ; k ++ ) { sum = A [ i ] + A [ j ] + A [ k ] ; if ( sum % M == 0 ) ans ++ ; } } } return ans ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int countPairs ( int n ) { if ( n == 2 ) return 4 ; int num = ( ( n / 2 ) + 1 ) ; int max = n % num ; int count = n - max ; return count ; }
Ref: 
function countPairs ( n ) { if ( n == 2 ) return 4 ; let num = ( parseInt ( n / 2 , 10 ) + 1 ) ; let max = n % num ; let count = n - max ; return count ; }
Hyp: 
function countPairs ( n ) { if ( n == 2 ) return 4 ; let num = parseInt ( ( n / 2 ) + 1 ) ; let max = n % num ; let count = n - max ; return count ; }

BLEU: 86.68
Edit Sim: 9


Src: 
int longestCommonSum ( bool arr1 [ ] , bool arr2 [ ] , int n ) { int maxLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int sum1 = 0 , sum2 = 0 ; for ( int j = i ; j < n ; j ++ ) { sum1 += arr1 [ j ] ; sum2 += arr2 [ j ] ; if ( sum1 == sum2 ) { int len = j - i + 1 ; if ( len > maxLen ) maxLen = len ; } } } return maxLen ; }
Ref: 
function longestCommonSum ( n ) { let maxLen = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let sum1 = 0 , sum2 = 0 ; for ( let j = i ; j < n ; j ++ ) { sum1 += arr1 [ j ] ; sum2 += arr2 [ j ] ; if ( sum1 == sum2 ) { let len = j - i + 1 ; if ( len > maxLen ) maxLen = len ; } } } return maxLen ; }
Hyp: 
function longestCommonSum ( arr1 , arr2 , n ) { let maxLen = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let sum1 = 0 , sum2 = 0 ; for ( let j = i ; j < n ; j ++ ) { sum1 += arr1 [ j ] ; sum2 += arr2 [ j ] ; if ( sum1 == sum2 ) { let len = j - i + 1 ; if ( len > maxLen ) maxLen = len ; } } } return maxLen ; }

BLEU: 94.51
Edit Sim: 14


Src: 
int maxSubarrayXOR ( int arr [ ] , int n ) { int ans = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { curr_xor = curr_xor ^ arr [ j ] ; ans = max ( ans , curr_xor ) ; } } return ans ; }
Ref: 
function maxSubarrayXOR ( arr , n ) { let ans = Number . MIN_VALUE ; for ( let i = 0 ; i < n ; i ++ ) { let curr_xor = 0 ; for ( let j = i ; j < n ; j ++ ) { curr_xor = curr_xor ^ arr [ j ] ; ans = Math . max ( ans , curr_xor ) ; } } return ans ; }
Hyp: 
function maxSubarrayXOR ( arr , n ) { let ans = INT_MIN ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i ; j < n ; j ++ ) { curr_xor = curr_xor ^ arr [ j ] ; ans = Math . max ( ans , curr_xor ) ; } } return ans ; }

BLEU: 84.97
Edit Sim: 34


Src: 
double hexagonArea ( double s ) { return ( ( 3 * sqrt ( 3 ) * ( s * s ) ) / 2 ) ; }
Ref: 
function hexagonArea ( s ) { return ( ( 3 * Math . sqrt ( 3 ) * ( s * s ) ) / 2 ) ; }
Hyp: 
function hexagonArea ( s ) { return ( ( 3 * Math . sqrt ( 3 ) * ( s * s ) ) / 2 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int solve ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int a = 0 , b = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i & 1 ) a = a * 10 + arr [ i ] ; else b = b * 10 + arr [ i ] ; } return a + b ; }
Ref: 
function solve ( arr , n ) { arr . sort ( ) ; let a = 0 , b = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( i % 2 != 0 ) a = a * 10 + arr [ i ] ; else b = b * 10 + arr [ i ] ; } return a + b ; }
Hyp: 
function solve ( arr , n ) { arr . sort ( ( a , b ) => a - b ) ; let a = 0 , b = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( i & 1 ) a = a * 10 + arr [ i ] ; else b = b * 10 + arr [ i ] ; } return a + b ; }

BLEU: 82.94
Edit Sim: 26


Src: 
int powerOfJump ( string s ) { int count = 1 ; int max_so_far = INT_MIN ; char ch = s [ s . length ( ) - 1 ] ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] == ch ) { if ( count > max_so_far ) { max_so_far = count ; } count = 1 ; } else count ++ ; } return max_so_far ; }
Ref: 
function powerOfJump ( s ) { let count = 1 ; let max_so_far = Number . MIN_VALUE ; let ch = s [ s . length - 1 ] ; for ( let i = 0 ; i < s . length ; i ++ ) { if ( s [ i ] == ch ) { if ( count > max_so_far ) { max_so_far = count ; } count = 1 ; } else count ++ ; } return max_so_far ; }
Hyp: 
function powerOfJump ( s ) { let count = 1 ; let max_so_far = INT_MIN ; let ch = s [ s . length - 1 ] ; for ( let i = 0 ; i < s . length ; i ++ ) { if ( ch == s [ i ] ) { if ( count > max_so_far ) { max_so_far = count ; } count = 1 ; } else count ++ ; } return max_so_far ; }

BLEU: 88.87
Edit Sim: 25


Src: 
void findNumbers ( int n ) { int i = 1 ; while ( i <= n ) { cout << ( ( 2 * i ) - 1 ) << " ▁ " ; i ++ ; } }
Ref: 
function findNumbers ( n ) { var i = 1 ; while ( i <= n ) { document . write ( ( ( 2 * i ) - 1 ) + " " ) ; i ++ ; } }
Hyp: 
function findNumbers ( n ) { let i = 1 ; while ( i <= n ) { document . write ( ( 2 * i ) - 1 ) + " " ) ; i ++ ; } }

BLEU: 90.55
Edit Sim: 5


Src: 
void sumArray ( int arr [ ] , int n ) { int leftSum [ n ] , rightSum [ n ] , Sum [ n ] , i , j ; leftSum [ 0 ] = 0 ; rightSum [ n - 1 ] = 0 ; for ( i = 1 ; i < n ; i ++ ) leftSum [ i ] = arr [ i - 1 ] + leftSum [ i - 1 ] ; for ( j = n - 2 ; j >= 0 ; j -- ) rightSum [ j ] = arr [ j + 1 ] + rightSum [ j + 1 ] ; for ( i = 0 ; i < n ; i ++ ) Sum [ i ] = leftSum [ i ] + rightSum [ i ] ; for ( i = 0 ; i < n ; i ++ ) cout << Sum [ i ] << " ▁ " ; }
Ref: 
function sumArray ( arr , n ) { let leftSum = new Array ( n ) ; let rightSum = new Array ( n ) ; let Sum = new Array ( n ) ; let i = 0 , j = 0 ; leftSum [ 0 ] = 0 ; rightSum [ n - 1 ] = 0 ; for ( i = 1 ; i < n ; i ++ ) leftSum [ i ] = arr [ i - 1 ] + leftSum [ i - 1 ] ; for ( j = n - 2 ; j >= 0 ; j -- ) rightSum [ j ] = arr [ j + 1 ] + rightSum [ j + 1 ] ; for ( i = 0 ; i < n ; i ++ ) Sum [ i ] = leftSum [ i ] + rightSum [ i ] ; for ( i = 0 ; i < n ; i ++ ) document . write ( Sum [ i ] + " " ) ; }
Hyp: 
function sumArray ( arr , n ) { let leftSum = new Array ( n ) , rightSum = new Array ( n ) , Sum = new Array ( n ) ; leftSum [ 0 ] = 0 ; rightSum [ n - 1 ] = 0 ; for ( i = 1 ; i < n ; i ++ ) leftSum [ i ] = arr [ i - 1 ] + leftSum [ i - 1 ] ; for ( j = n - 2 ; j >= 0 ; j -- ) rightSum [ j ] = arr [ j + 1 ] + rightSum [ j + 1 ] ; for ( i = 0 ; i < n ; i ++ ) Sum [ i ] = leftSum [ i ] + rightSum [ i ] ; for ( i = 0 ; i < n ; i ++ ) document . write ( Sum [ i ] + " " ) ; }

BLEU: 90.66
Edit Sim: 30


Src: 
ll boost_hyperfactorial ( ll num ) { ll val = 1 ; for ( int i = 1 ; i <= num ; i ++ ) { val = val * pow ( i , i ) ; } return val ; }
Ref: 
function boost_hyperfactorial ( num ) { let val = 1 ; for ( let i = 1 ; i <= num ; i ++ ) { val = val * Math . pow ( i , i ) ; } return val ; }
Hyp: 
function boost_hyperfactorial ( num ) { let val = 1 ; for ( let i = 1 ; i <= num ; i ++ ) { val = val * Math . pow ( i , i ) ; } return val ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
Ref: 
function gcd ( a , b ) { if ( b == 0 ) { return a ; } return gcd ( b , a % b ) ; } let a = 98 ; let b = 56 ; document . write ( ` ${ a } ${ b } ${ gcd ( a , b ) }
Hyp: 
function gcd ( a , b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }

BLEU: 29.19
Edit Sim: 84


Src: 
void Permutation ( int n , int k ) { int p [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) p [ i ] = i ; for ( int i = 1 ; i < n - k ; i ++ ) p [ i + 1 ] = i ; p [ 1 ] = n - k ; for ( int i = 1 ; i <= n ; i ++ ) cout << p [ i ] << " ▁ " ; }
Ref: 
function Permutation ( n , k ) { let p = new Array ( n + 1 ) ; for ( let i = 1 ; i <= n ; i ++ ) p [ i ] = i ; for ( let i = 1 ; i < n - k ; i ++ ) p [ i + 1 ] = i ; p [ 1 ] = n - k ; for ( let i = 1 ; i <= n ; i ++ ) document . write ( p [ i ] + " " ) ; }
Hyp: 
function Permutation ( n , k ) { let p = Array ( n + 1 ) . fill ( 0 ) ; for ( let i = 1 ; i <= n ; i ++ ) p [ i ] = i ; for ( let i = 1 ; i < n - k ; i ++ ) p [ i + 1 ] = i ; p [ 1 ] = n - k ; for ( let i = 1 ; i < n ; i ++ ) document . write ( p [ i ] + " " ) ; }

BLEU: 90.68
Edit Sim: 18


Src: 
int find ( int index , int openbrk , int n , int adj [ ] [ 2 ] ) { if ( openbrk < 0 ) return MAX_VAL ; if ( index == n ) { if ( openbrk == 0 ) { return 0 ; } return MAX_VAL ; } if ( dp [ index ] [ openbrk ] != -1 ) return dp [ index ] [ openbrk ] ; dp [ index ] [ openbrk ] = min ( adj [ index ] [ 1 ] + find ( index + 1 , openbrk + 1 , n , adj ) , adj [ index ] [ 0 ] + find ( index + 1 , openbrk - 1 , n , adj ) ) ; return dp [ index ] [ openbrk ] ; }
Ref: 
function find ( index , openbrk , n , adj ) { if ( openbrk < 0 ) return MAX_VAL ; if ( index == n ) { if ( openbrk == 0 ) { return 0 ; } return MAX_VAL ; } if ( dp [ index ] [ openbrk ] != - 1 ) return dp [ index ] [ openbrk ] ; dp [ index ] [ openbrk ] = Math . min ( adj [ index ] [ 1 ] + find ( index + 1 , openbrk + 1 , n , adj ) , adj [ index ] [ 0 ] + find ( index + 1 , openbrk - 1 , n , adj ) ) ; return dp [ index ] [ openbrk ] ; }
Hyp: 
function find ( index , openbrk , n , adj ) { if ( openbrk < 0 ) return MAX_VAL ; if ( index == n ) { if ( openbrk == 0 ) { return 0 ; } return MAX_VAL ; } if ( dp [ index ] [ openbrk ] != - 1 ) return dp [ index ] [ openbrk ] ; dp [ index ] [ openbrk ] = Math . min ( adj [ index ] [ 1 ] + find ( index + 1 , openbrk + 1 , n , adj ) ) ; return dp [ index ] [ openbrk ] ; }

BLEU: 81.29
Edit Sim: 67


Src: 
long multiplyFactors ( int n ) { long long prod = 1 ; for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) prod = ( prod * i ) % M ; else { prod = ( prod * i ) % M ; prod = ( prod * n / i ) % M ; } } } return prod ; }
Ref: 
function multiplyFactors ( n ) { let M = 1000000007 ; let i ; prod = 1 ; for ( i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) prod = ( prod * i ) % M ; else { prod = ( prod * i ) % M ; prod = ( prod * n / i ) % M ; } } } return prod ; }
Hyp: 
function multiplyFactors ( n ) { let prod = 1 ; for ( let i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) prod = ( prod * i ) % M ; else { prod = ( prod * i ) % M ; prod = ( prod * n / i ) % M ; } } } return prod ; }

BLEU: 89.35
Edit Sim: 29


Src: 
float polydiagonal ( float n , float a ) { if ( a < 0 && n < 0 ) return -1 ; return 2 * a * sin ( ( ( ( n - 2 ) * 180 ) / ( 2 * n ) ) * 3.14159 / 180 ) ; }
Ref: 
function polydiagonal ( n , a ) { if ( a < 0 && n < 0 ) { return - 1 ; } return ( 2 * a * Math . sin ( ( ( ( n - 2 ) * 180 ) / ( 2 * n ) ) * 3.14159 / 180 ) ) ; }
Hyp: 
function polydiagonal ( n , a ) { if ( a < 0 && n < 0 ) return - 1 ; return 2 * a * Math . sin ( ( ( n - 2 ) * 180 ) / ( 2 * n ) ) * 3.14159 / 180 ) ; }

BLEU: 83.16
Edit Sim: 10


Src: 
int NumberofTimes ( string str ) { int temporary_sum = 0 , count = 0 ; while ( str . length ( ) > 1 ) { temporary_sum = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) temporary_sum += ( str [ i ] - '0' ) ; str = to_string ( temporary_sum ) ; count ++ ; } return count ; }
Ref: 
function NumberofTimes ( str ) { var temporary_sum = 0 , count = 0 ; while ( str . length > 1 ) { temporary_sum = 0 ; for ( i = 0 ; i < str . length ; i ++ ) temporary_sum += ( str . charAt ( i ) - ' ' ) ; str = temporary_sum + " " ; count ++ ; } return count ; }
Hyp: 
function NumberofTimes ( str ) { let temporary_sum = 0 , count = 0 ; while ( str . length > 1 ) { temporary_sum = 0 ; for ( let i = 0 ; i < str . length ; i ++ ) temporary_sum += ( str [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ) ; str = to_string ( temporary_sum ) ; count ++ ; } return count ; }

BLEU: 70.61
Edit Sim: 53


Src: 
string evenlength ( string n ) { string res = n ; for ( int j = n . length ( ) - 1 ; j >= 0 ; -- j ) res += n [ j ] ; return res ; }
Ref: 
function evenlength ( n ) { let res = n ; for ( let j = n . length - 1 ; j >= 0 ; -- j ) res += n [ j ] ; return res ; }
Hyp: 
function evenlength ( n ) { let res = n ; for ( let j = n . length - 1 ; j >= 0 ; -- j ) res += n [ j ] ; return res ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int findMaxSum ( int arr [ ] , int n ) { int preSum [ n ] ; int suffSum [ n ] ; int ans = INT_MIN ; preSum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) preSum [ i ] = preSum [ i - 1 ] + arr [ i ] ; suffSum [ n - 1 ] = arr [ n - 1 ] ; if ( preSum [ n - 1 ] == suffSum [ n - 1 ] ) ans = max ( ans , preSum [ n - 1 ] ) ; for ( int i = n - 2 ; i >= 0 ; i -- ) { suffSum [ i ] = suffSum [ i + 1 ] + arr [ i ] ; if ( suffSum [ i ] == preSum [ i ] ) ans = max ( ans , preSum [ i ] ) ; } return ans ; }
Ref: 
function findMaxSum ( arr , n ) { let preSum = new Array ( n ) ; preSum . fill ( 0 ) ; let suffSum = new Array ( n ) ; suffSum . fill ( 0 ) ; let ans = Number . MIN_VALUE ; preSum [ 0 ] = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) preSum [ i ] = preSum [ i - 1 ] + arr [ i ] ; suffSum [ n - 1 ] = arr [ n - 1 ] ; if ( preSum [ n - 1 ] == suffSum [ n - 1 ] ) ans = Math . max ( ans , preSum [ n - 1 ] ) ; for ( let i = n - 2 ; i >= 0 ; i -- ) { suffSum [ i ] = suffSum [ i + 1 ] + arr [ i ] ; if ( suffSum [ i ] == preSum [ i ] ) ans = Math . max ( ans , preSum [ i ] ) ; } return ans ; }
Hyp: 
function findMaxSum ( arr , n ) { let preSum = new Array ( n ) ; let suffSum = new Array ( n ) ; let ans = 21474836473 ; preSum [ 0 ] = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) preSum [ i ] = preSum [ i - 1 ] + arr [ i ] ; suffSum [ n - 1 ] = arr [ n - 1 ] ; if ( preSum [ n - 1 ] == suffSum [ n - 1 ] ) ans = Math . max ( ans , preSum [ n - 1 ] ) ; for ( let i = n - 2 ; i >= 0 ; i -- ) { suffSum [ i ] = suffSum [ i + 1 ] + arr [ i ] ; if ( suffSum [ i ] == preSum [ i ] ) ans = Math . max ( ans , preSum [ i ] ) ; } return ans ; }

BLEU: 90.11
Edit Sim: 63


Src: 
int minproduct ( int a [ ] , int b [ ] , int n , int k ) { int diff = 0 , res = 0 ; int temp ; for ( int i = 0 ; i < n ; i ++ ) { int pro = a [ i ] * b [ i ] ; res = res + pro ; if ( pro < 0 && b [ i ] < 0 ) temp = ( a [ i ] + 2 * k ) * b [ i ] ; else if ( pro < 0 && a [ i ] < 0 ) temp = ( a [ i ] - 2 * k ) * b [ i ] ; else if ( pro > 0 && a [ i ] < 0 ) temp = ( a [ i ] + 2 * k ) * b [ i ] ; else if ( pro > 0 && a [ i ] > 0 ) temp = ( a [ i ] - 2 * k ) * b [ i ] ; int d = abs ( pro - temp ) ; if ( d > diff ) diff = d ; } return res - diff ; }
Ref: 
function minproduct ( a , b , n , k ) { let diff = 0 , res = 0 ; let temp = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let pro = a [ i ] * b [ i ] ; res = res + pro ; if ( pro < 0 && b [ i ] < 0 ) temp = ( a [ i ] + 2 * k ) * b [ i ] ; else if ( pro < 0 && a [ i ] < 0 ) temp = ( a [ i ] - 2 * k ) * b [ i ] ; else if ( pro > 0 && a [ i ] < 0 ) temp = ( a [ i ] + 2 * k ) * b [ i ] ; else if ( pro > 0 && a [ i ] > 0 ) temp = ( a [ i ] - 2 * k ) * b [ i ] ; let d = Math . abs ( pro - temp ) ; if ( d > diff ) diff = d ; } return res - diff ; }
Hyp: 
function minproduct ( a , b , n , k ) { let diff = 0 , res = 0 ; let temp ; for ( let i = 0 ; i < n ; i ++ ) { let pro = a [ i ] * b [ i ] ; res = res + pro ; if ( pro < 0 && b [ i ] < 0 ) temp = ( a [ i ] + 2 * k ) * b [ i ] ; else if ( pro > 0 && a [ i ] > 0 ) temp = ( a [ i ] - 2 * k ) * b [ i ] ; let d = Math . abs ( pro - temp ) ; if ( d > diff ) diff = d ; } return res - diff ; }

BLEU: 63.75
Edit Sim: 152


Src: 
int getSum ( vector < int > arr , int p ) { return arr . size ( ) ; }
Ref: 
function getSum ( arr , p ) { return arr . length ; }
Hyp: 
function getSum ( arr , p ) { return arr . sum ( p ) ; }

BLEU: 67.36
Edit Sim: 9


Src: 
void printSeries ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) { int num = i * ( i + 1 ) * ( i + 2 ) / 6 ; cout << num << " ▁ " ; } }
Ref: 
function printSeries ( n ) { let i ; for ( i = 1 ; i <= n ; i ++ ) { let num = i * ( i + 1 ) * ( ( i + 2 ) / 6 ) ; document . write ( num + " " ) ; } }
Hyp: 
function printSeries ( n ) { for ( let i = 1 ; i <= n ; i ++ ) { let num = i * ( i + 1 ) * ( i + 2 ) / 6 ; document . write ( num + " " ) ; } }

BLEU: 82.16
Edit Sim: 15


Src: 
void otherEndPoint ( int x1 , int y1 , int m1 , int m2 ) { float x2 = ( float ) ( 2 * m1 - x1 ) ; float y2 = ( float ) ( 2 * m2 - y1 ) ; cout << " x2 ▁ = ▁ " << x2 << " , ▁ " << " y2 ▁ = ▁ " << y2 ; }
Ref: 
function otherEndPoint ( x1 , y1 , m1 , m2 ) { let x2 = 2 * m1 - x1 ; let y2 = 2 * m2 - y1 ; document . write ( " " + x2 + " " + " " + y2 ) ; }
Hyp: 
function otherEndPoint ( x1 , y1 , m1 , m2 ) { var x2 = ( Math . pow ( 2 * m1 - x1 ) ) ; var y2 = ( Math . pow ( 2 * m2 - y1 ) ) ; document . write ( " " + x2 + " " + y2 ) ; }

BLEU: 59.14
Edit Sim: 50


Src: 
int rangeSum ( int l , int r ) { int a = 1 , b = 9 , res = 0 ; for ( int i = 1 ; i <= 10 ; i ++ ) { int L = max ( l , a ) ; int R = min ( r , b ) ; if ( L <= R ) { int sum = ( L + R ) * ( R - L + 1 ) / 2 ; res += ( i * i ) * ( sum % MOD ) ; res %= MOD ; } a = a * 10 ; b = b * 10 + 9 ; } return res ; }
Ref: 
function rangeSum ( l , r ) { var a = 1 , b = 9 , res = 0 ; for ( var i = 1 ; i <= 10 ; i ++ ) { var L = Math . max ( l , a ) ; var R = Math . min ( r , b ) ; if ( L <= R ) { var sum = ( L + R ) * ( R - L + 1 ) / 2 ; res += ( i * i ) * ( sum % MOD ) ; res %= MOD ; } a = a * 10 ; b = b * 10 + 9 ; } return res ; }
Hyp: 
function rangeSum ( l , r ) { let a = 1 , b = 9 , res = 0 ; for ( let i = 1 ; i <= 10 ; i ++ ) { let L = Math . max ( l , a ) ; let R = Math . min ( r , b ) ; if ( L <= R ) { let sum = ( L + R ) * ( R - L + 1 ) / 2 ; res += ( i * i ) * ( sum % MOD ) ; res %= MOD ; } a = a * 10 ; b = b * 10 + 9 ; } return res ; }

BLEU: 89.72
Edit Sim: 15


Src: 
int numberOfPaths ( int m , int n ) { if ( m == 1 n == 1 ) return 1 ; return numberOfPaths ( m - 1 , n ) + numberOfPaths ( m , n - 1 ) ; }
Ref: 
function numberOfPaths ( m , n ) { if ( m == 1 n == 1 ) return 1 ; return numberOfPaths ( m - 1 , n ) + numberOfPaths ( m , n - 1 ) ; }
Hyp: 
function numberOfPaths ( m , n ) { if ( m == 1 n == 1 ) return 1 ; return numberOfPaths ( m - 1 , n ) + numberOfPaths ( m , n - 1 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
void printSorted ( int arr [ ] , int start , int end ) { if ( start > end ) return ; printSorted ( arr , start * 2 + 1 , end ) ; cout << arr [ start ] << " ▁ " ; printSorted ( arr , start * 2 + 2 , end ) ; }
Ref: 
function printSorted ( arr , start , end ) { if ( start > end ) return ; printSorted ( arr , start * 2 + 1 , end ) ; document . write ( arr [ start ] + " " ) ; printSorted ( arr , start * 2 + 2 , end ) ; }
Hyp: 
function printSorted ( arr , start , end ) { if ( start > end ) return ; printSorted ( arr , start * 2 + 1 , end ) ; document . write ( arr [ start ] + " " ) ; printSorted ( arr , start * 2 + 2 , end ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
void printSumSimple ( int mat [ ] [ n ] , int k ) { if ( k > n ) return ; for ( int i = 0 ; i < n - k + 1 ; i ++ ) { for ( int j = 0 ; j < n - k + 1 ; j ++ ) { int sum = 0 ; for ( int p = i ; p < k + i ; p ++ ) for ( int q = j ; q < k + j ; q ++ ) sum += mat [ p ] [ q ] ; cout << sum << " ▁ " ; } cout << endl ; } }
Ref: 
function printSumSimple ( mat , k ) { if ( k > n ) return ; for ( let i = 0 ; i < n - k + 1 ; i ++ ) { for ( let j = 0 ; j < n - k + 1 ; j ++ ) { let sum = 0 ; for ( let p = i ; p < k + i ; p ++ ) for ( let q = j ; q < k + j ; q ++ ) sum += mat [ p ] [ q ] ; document . write ( sum + " " ) ; } document . write ( " " ) ; } }
Hyp: 
function printSumSimple ( mat , k ) { if ( k > n ) return ; if ( k > n ) return ; for ( let i = 0 ; i < n - k + 1 ; i ++ ) { for ( let j = 0 ; j < n - k + 1 ; j ++ ) { let sum = 0 ; for ( let p = i ; p < k + i ; p ++ ) for ( let q = j ; q < k + j ; q ++ ) sum += mat [ p ] [ q ] ; document . write ( sum + " " ) ; } document . write ( " " ) ; } }

BLEU: 93.82
Edit Sim: 22


Src: 
int seiresSum ( int n , int a [ ] ) { return n * ( a [ 0 ] * a [ 0 ] - a [ 2 * n - 1 ] * a [ 2 * n - 1 ] ) / ( 2 * n - 1 ) ; }
Ref: 
function seiresSum ( n , a ) { return n * ( a [ 0 ] * a [ 0 ] - a [ 2 * n - 1 ] * a [ 2 * n - 1 ] ) / ( 2 * n - 1 ) ; }
Hyp: 
function seiresSum ( n , a ) { return n * ( a [ 0 ] * a [ 0 ] - a [ 2 * n - 1 ] * a [ 2 * n - 1 ] ) / ( 2 * n - 1 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int maxSumPair ( int arr [ ] , int N , int k ) { int maxSum = 0 ; sort ( arr , arr + N ) ; for ( int i = N - 1 ; i > 0 ; -- i ) { if ( arr [ i ] - arr [ i - 1 ] < k ) { maxSum += arr [ i ] ; maxSum += arr [ i - 1 ] ; -- i ; } } return maxSum ; }
Ref: 
function maxSumPairWithDifferenceLessThanK ( arr , N , k ) { var maxSum = 0 ; arr . sort ( ( a , b ) => a - b ) ; for ( i = N - 1 ; i > 0 ; -- i ) { if ( arr [ i ] - arr [ i - 1 ] < k ) { maxSum += arr [ i ] ; maxSum += arr [ i - 1 ] ; -- i ; } } return maxSum ; }
Hyp: 
function maxSumPair ( arr , N , k ) { let maxSum = 0 ; arr . sort ( ( a , b ) => a - b ) ; for ( let i = N - 1 ; i > 0 ; -- i ) { if ( arr [ i ] - arr [ i - 1 ] < k ) { maxSum += arr [ i ] ; maxSum += arr [ i - 1 ] ; -- i ; } } return maxSum ; }

BLEU: 92.29
Edit Sim: 30


Src: 
string convert ( string str ) { string w = " " , z = " " ; transform ( str . begin ( ) , str . end ( ) , str . begin ( ) , :: toupper ) ; str += " ▁ " ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char ch = str [ i ] ; if ( ch != ' ▁ ' ) { w = w + ch ; } else { z = z + char ( tolower ( w [ 0 ] ) ) + w . substr ( 1 ) + " ▁ " ; w = " " ; } } return z ; }
Ref: 
function convert ( str ) { var w = " " , z = " " ; str = str . toUpperCase ( ) + " " ; for ( i = 0 ; i < str . length ; i ++ ) { var ch = str [ i ] ; if ( ch != ' ' ) w = w + ch ; else { z = z + ( w [ 0 ] . toLowerCase ( ) ) + w . substring ( 1 ) + " " ; w = " " ; } } return z ; }
Hyp: 
function convert ( str ) { let w = " " , z = " " ; transform ( str . begin ( ) , str . end ( ) , function ( a , b ) { return a + b ; } ) ; str = " " ; for ( let i = 0 ; i < str . length ; i ++ ) { let ch = str [ i ] ; if ( ch != ' ' ) { w = w + ch ; } else { z = z + w . substr ( 1 ) + " " ; w = " " ; } } return z ; }

BLEU: 61.6
Edit Sim: 122


Src: 
void printRepeating ( int arr [ ] , int size ) { int i , j ; printf ( " ▁ Repeating ▁ elements ▁ are ▁ " ) ; for ( i = 0 ; i < size ; i ++ ) for ( j = i + 1 ; j < size ; j ++ ) if ( arr [ i ] == arr [ j ] ) cout << arr [ i ] << " ▁ " ; }
Ref: 
function printRepeating ( arr , size ) { var i , j ; document . write ( " " ) ; for ( i = 0 ; i < size ; i ++ ) { for ( j = i + 1 ; j < size ; j ++ ) { if ( arr [ i ] == arr [ j ] ) document . write ( arr [ i ] + " " ) ; } } }
Hyp: 
function printRepeating ( arr , size ) { let i , j ; document . write ( " " ) ; for ( i = 0 ; i < size ; i ++ ) for ( j = i + 1 ; j < size ; j ++ ) if ( arr [ i ] == arr [ j ] ) document . write ( arr [ i ] + " " ) ; }

BLEU: 87.63
Edit Sim: 11


Src: 
long multiplyByFifteen ( long n ) { long prod = ( n << 4 ) ; prod = prod - n ; return prod ; }
Ref: 
function multiplyByFifteen ( n ) { let prod = ( n << 4 ) ; prod = prod - n ; return prod ; }
Hyp: 
function multiplyByFifteen ( n ) { let prod = ( n << 4 ) ; prod = prod - n ; return prod ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int LCSubStr ( char * X , char * Y , int m , int n ) { int LCSuff [ m + 1 ] [ n + 1 ] ; int result = 0 ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) LCSuff [ i ] [ j ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) { LCSuff [ i ] [ j ] = LCSuff [ i - 1 ] [ j - 1 ] + 1 ; result = max ( result , LCSuff [ i ] [ j ] ) ; } else LCSuff [ i ] [ j ] = 0 ; } } return result ; }
Ref: 
function LCSubStr ( X , Y , m , n ) { var LCStuff = Array ( m + 1 ) . fill ( ) . map ( ( ) => Array ( n + 1 ) . fill ( 0 ) ) ; var result = 0 ; for ( i = 0 ; i <= m ; i ++ ) { for ( j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) LCStuff [ i ] [ j ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) { LCStuff [ i ] [ j ] = LCStuff [ i - 1 ] [ j - 1 ] + 1 ; result = Math . max ( result , LCStuff [ i ] [ j ] ) ; } else LCStuff [ i ] [ j ] = 0 ; } } return result ; }
Hyp: 
function LCSubStr ( X , Y , m , n ) { let LCSuff = new Array ( m + 1 ) [ n + 1 ] ; let result = 0 ; for ( let i = 0 ; i <= m ; i ++ ) { for ( let j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) LCSuff [ i ] [ j ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) { LCSuff [ i ] [ j ] = LCSuff [ i - 1 ] [ j - 1 ] + 1 ; result = Math . max ( result , LCSuff [ i ] [ j ] ) ; } else LCSuff [ i ] [ j ] = 0 ; } } return result ; }

BLEU: 73.84
Edit Sim: 72


Src: 
bool modularSum ( int arr [ ] , int n , int m ) { if ( n > m ) return true ; bool DP [ m ] ; memset ( DP , false , m ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( DP [ 0 ] ) return true ; bool temp [ m ] ; memset ( temp , false , m ) ; for ( int j = 0 ; j < m ; j ++ ) { if ( DP [ j ] == true ) { if ( DP [ ( j + arr [ i ] ) % m ] == false ) temp [ ( j + arr [ i ] ) % m ] = true ; } } for ( int j = 0 ; j < m ; j ++ ) if ( temp [ j ] ) DP [ j ] = true ; DP [ arr [ i ] % m ] = true ; } return DP [ 0 ] ; }
Ref: 
function modularSum ( arr , n , m ) { if ( n > m ) return true ; let DP = new Array ( m ) ; for ( let l = 0 ; l < m ; l ++ ) DP [ l ] = false ; for ( let i = 0 ; i < n ; i ++ ) { if ( DP [ 0 ] ) return true ; let temp = new Array ( m ) ; for ( let l = 0 ; l < m ; l ++ ) temp [ l ] = false ; for ( let j = 0 ; j < m ; j ++ ) { if ( DP [ j ] == true ) { if ( DP [ ( j + arr [ i ] ) % m ] == false ) temp [ ( j + arr [ i ] ) % m ] = true ; } } for ( let j = 0 ; j < m ; j ++ ) if ( temp [ j ] ) DP [ j ] = true ; DP [ arr [ i ] % m ] = true ; } return DP [ 0 ] ; }
Hyp: 
function modularSum ( arr , n , m ) { if ( n > m ) return true ; let DP = new Array ( m ) ; DP . fill ( 0 ) ; for ( let i = 0 ; i < m ; i ++ ) { if ( DP [ 0 ] ) return true ; let temp = new Array ( m ) ; DP . fill ( 0 ) ; for ( let j = 0 ; j < m ; j ++ ) { if ( DP [ j ] == true ) { if ( temp [ ( j + arr [ i ] ) % m ] == 0 ) temp [ ( j + arr [ i ] ) % m ] = 1 ; } } for ( let j = 0 ; j < m ; j ++ ) if ( temp [ j ] ) DP [ j ] = true ; DP [ arr [ i ] % m ] = 1 ; } return DP [ 0 ] ; }

BLEU: 75.04
Edit Sim: 102


Src: 
void maxSum ( int * a , int n ) { vector < int > l ; int s = 0 ; for ( int i = 0 ; i < n ; i ++ ) { s += abs ( a [ i ] ) ; if ( a [ i ] >= 0 ) continue ; if ( i == 0 ) l . push_back ( i + 1 ) ; else { l . push_back ( i + 1 ) ; l . push_back ( i ) ; } } cout << s << endl ; for ( int i = 0 ; i < l . size ( ) ; i ++ ) cout << l [ i ] << " ▁ " ; }
Ref: 
function maxSum ( a , n ) { let l = [ ] ; let s = 0 ; for ( let i = 0 ; i < n ; i ++ ) { s += Math . abs ( a [ i ] ) ; if ( a [ i ] >= 0 ) continue ; if ( i == 0 ) l . push ( i + 1 ) ; else { l . push ( i + 1 ) ; l . push ( i ) ; } } document . write ( s + " " ) ; for ( let i = 0 ; i < l . length ; i ++ ) document . write ( l [ i ] + " " ) ; }
Hyp: 
function maxSum ( a , n ) { let l = [ ] ; let s = 0 ; for ( let i = 0 ; i < n ; i ++ ) { s += Math . abs ( a [ i ] ) ; if ( a [ i ] >= 0 ) continue ; if ( i == 0 ) l . push ( i + 1 ) ; else { l . push ( i + 1 ) ; l . push ( i ) ; } } document . write ( s + " " ) ; }

BLEU: 75.46
Edit Sim: 79


Src: 
int sumOfTheSeries ( int n ) { int sum_n = ( n * ( n + 1 ) / 2 ) ; int sum_sq_n = ( n * ( n + 1 ) / 2 ) * ( 2 * n + 1 ) / 3 ; return ( sum_n + sum_sq_n ) ; }
Ref: 
function sumOfTheSeries ( n ) { let sum_n = ( n * ( n + 1 ) / 2 ) ; let sum_sq_n = ( n * ( n + 1 ) / 2 ) * ( 2 * n + 1 ) / 3 ; return ( sum_n + sum_sq_n ) ; }
Hyp: 
function sumOfTheSeries ( n ) { let sum_n = ( n * ( n + 1 ) / 2 ) ; let sum_sq_n = ( n * ( n + 1 ) / 2 ) * ( 2 * n + 1 ) / 3 ; return ( sum_n + sum_sq_n ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int numOfways ( int n , int k ) { int p = 1 ; if ( k % 2 ) p = -1 ; return ( pow ( n - 1 , k ) + p * ( n - 1 ) ) / n ; }
Ref: 
function numOfways ( n , k ) { let p = 1 ; if ( k % 2 != 0 ) p = - 1 ; return ( Math . pow ( n - 1 , k ) + p * ( n - 1 ) ) / n ; }
Hyp: 
function numOfways ( n , k ) { let p = 1 ; if ( k % 2 ) p = - 1 ; return ( Math . pow ( n - 1 , k ) + p * ( n - 1 ) ) / n ; }

BLEU: 92.95
Edit Sim: 5


Src: 
int possibleways ( int n ) { if ( n % 2 == 1 ) return 0 ; else if ( n % 4 == 0 ) return n / 4 - 1 ; else return n / 4 ; }
Ref: 
function possibleways ( n ) { if ( n % 2 == 1 ) return 0 ; else if ( n % 4 == 0 ) return n / 4 - 1 ; else return n / 4 ; }
Hyp: 
function possibleways ( n ) { if ( n % 2 == 1 ) return 0 ; else if ( n % 4 == 0 ) return n / 4 - 1 ; else return n / 4 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int inversegrayCode ( int n ) { int inv = 0 ; for ( ; n ; n = n >> 1 ) inv ^= n ; return inv ; }
Ref: 
function inversegrayCode ( n ) { let inv = 0 ; for ( ; n ; n = n >> 1 ) inv ^= n ; return inv ; }
Hyp: 
function inversegrayCode ( n ) { let inv = 0 ; for ( ; n ; n = parseInt ( n >> 1 ) ) inv ^= n ; return inv ; }

BLEU: 83.37
Edit Sim: 13


Src: 
int longCommomAnagramSubseq ( char str1 [ ] , char str2 [ ] , int n1 , int n2 ) { int freq1 [ SIZE ] , freq2 [ SIZE ] ; memset ( freq1 , 0 , sizeof ( freq1 ) ) ; memset ( freq2 , 0 , sizeof ( freq2 ) ) ; int len = 0 ; for ( int i = 0 ; i < n1 ; i ++ ) freq1 [ str1 [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < n2 ; i ++ ) freq2 [ str2 [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < SIZE ; i ++ ) len += min ( freq1 [ i ] , freq2 [ i ] ) ; return len ; }
Ref: 
function longCommomAnagramSubseq ( str1 , str2 , n1 , n2 ) { let freq1 = new Array ( SIZE ) ; let freq2 = new Array ( SIZE ) ; for ( let i = 0 ; i < SIZE ; i ++ ) { freq1 [ i ] = 0 ; freq2 [ i ] = 0 ; } let len = 0 ; for ( let i = 0 ; i < n1 ; i ++ ) freq1 [ str1 [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; for ( let i = 0 ; i < n2 ; i ++ ) freq2 [ str2 [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; for ( let i = 0 ; i < SIZE ; i ++ ) len += Math . min ( freq1 [ i ] , freq2 [ i ] ) ; return len ; }
Hyp: 
function longCommomAnagramSubseq ( str1 , str2 , n1 , n2 ) { var freq1 = new Array ( SIZE ) ; var freq2 = new Array ( SIZE ) ; for ( var i = 0 ; i < SIZE ; i ++ ) freq1 [ str1 [ i ] . charCodeAt ( 0 ) - " " . charCodeAt ( 0 ) ] ++ ; for ( var i = 0 ; i < n1 ; i ++ ) freq2 [ str2 [ i ] . charCodeAt ( 0 ) - " " . charCodeAt ( 0 ) ] ++ ; for ( var i = 0 ; i < n2 ; i ++ ) freq2 [ str2 [ i ] . charCodeAt ( 0 ) - " " . charCodeAt ( 0 ) ] ++ ; for ( var i = 0 ; i < SIZE ; i ++ ) len += Math . min ( freq1 [ i ] , freq2 [ i ] ) ; return len ; }

BLEU: 75.5
Edit Sim: 65


Src: 
int countOnes ( bool arr [ ] , int low , int high ) { if ( high >= low ) { int mid = low + ( high - low ) / 2 ; if ( ( mid == high arr [ mid + 1 ] == 0 ) && ( arr [ mid ] == 1 ) ) return mid + 1 ; if ( arr [ mid ] == 1 ) return countOnes ( arr , ( mid + 1 ) , high ) ; return countOnes ( arr , low , ( mid - 1 ) ) ; } return 0 ; }
Ref: 
function countOnes ( arr , low , high ) { if ( high >= low ) { let mid = Math . trunc ( low + ( high - low ) / 2 ) ; if ( ( mid == high arr [ mid + 1 ] == 0 ) && ( arr [ mid ] == 1 ) ) return mid + 1 ; if ( arr [ mid ] == 1 ) return countOnes ( arr , ( mid + 1 ) , high ) ; return countOnes ( arr , low , ( mid - 1 ) ) ; } return 0 ; }
Hyp: 
function countOnes ( arr , low , high ) { if ( high >= low ) { let mid = low + ( high - low ) / 2 ; if ( ( mid == high arr [ mid + 1 ] == 0 ) && ( arr [ mid ] == 1 ) ) return mid + 1 ; if ( arr [ mid ] == 1 ) return countOnes ( arr , ( mid + 1 ) , high ) ; return countOnes ( arr , low , ( mid - 1 ) ) ; } return 0 ; }

BLEU: 92.35
Edit Sim: 17


Src: 
int minIndex ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( 2 * arr [ i ] == sum ) return ( i + 1 ) ; } return -1 ; }
Ref: 
function minIndex ( arr , n ) { var sum = 0 ; for ( i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; for ( i = 0 ; i < n ; i ++ ) { if ( 2 * arr [ i ] == sum ) return ( i + 1 ) ; } return - 1 ; }
Hyp: 
function minIndex ( arr , n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; for ( let i = 0 ; i < n ; i ++ ) { if ( 2 * arr [ i ] == sum ) return ( i + 1 ) ; } return - 1 ; }

BLEU: 89.45
Edit Sim: 11


Src: 
int dodecahedral_num ( int n ) { return n * ( 3 * n - 1 ) * ( 3 * n - 2 ) / 2 ; }
Ref: 
function dodecahedral_num ( n ) { return n * ( 3 * n - 1 ) * ( 3 * n - 2 ) / 2 ; }
Hyp: 
function dodecahedral_num ( n ) { return n * ( 3 * n - 1 ) * ( 3 * n - 2 ) / 2 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int findLCM ( int a , int b ) { int lar = max ( a , b ) ; int small = min ( a , b ) ; for ( int i = lar ; ; i += lar ) { if ( i % small == 0 ) return i ; } }
Ref: 
function findLCM ( a , b ) { var lar = Math . max ( a , b ) ; var small = Math . min ( a , b ) ; for ( i = lar ; ; i += lar ) { if ( i % small == 0 ) return i ; } }
Hyp: 
function findLCM ( a , b ) { let lar = Math . max ( a , b ) ; let small = Math . min ( a , b ) ; for ( let i = lar ; ; i += lar ) { if ( i % small == 0 ) return i ; } }

BLEU: 86.62
Edit Sim: 10


Src: 
int countNumbers ( int l , int r ) { return ( ( r / 6 ) - ( l - 1 ) / 6 ) ; }
Ref: 
function countNumbers ( l , r ) { return ( parseInt ( r / 6 ) - parseInt ( ( l - 1 ) / 6 ) ) ; }
Hyp: 
function countNumbers ( l , r ) { return ( ( r / 6 ) - ( l - 1 ) / 6 ) ; }

BLEU: 72.56
Edit Sim: 22


Src: 
ll findSum ( int n ) { ll sum2 , sum5 , sum10 ; sum2 = ( ( n / 2 ) * ( 4 + ( n / 2 - 1 ) * 2 ) ) / 2 ; sum5 = ( ( n / 5 ) * ( 10 + ( n / 5 - 1 ) * 5 ) ) / 2 ; sum10 = ( ( n / 10 ) * ( 20 + ( n / 10 - 1 ) * 10 ) ) / 2 ; return sum2 + sum5 - sum10 ; }
Ref: 
function findSum ( n ) { var sum2 , sum5 , sum10 ; sum2 = parseInt ( ( parseInt ( n / 2 ) * ( 4 + ( parseInt ( n / 2 ) - 1 ) * 2 ) ) / 2 ) ; sum5 = parseInt ( ( parseInt ( n / 5 ) * ( 10 + ( parseInt ( n / 5 ) - 1 ) * 5 ) ) / 2 ) ; sum10 = parseInt ( ( parseInt ( n / 10 ) * ( 20 + ( parseInt ( n / 10 ) - 1 ) * 10 ) ) / 2 ) ; return sum2 + sum5 - sum10 ; }
Hyp: 
function findSum ( n ) { let sum2 , sum5 , sum10 ; sum2 = ( ( n / 2 ) * ( 4 + ( n / 2 - 1 ) * 2 ) ) / 2 ; sum5 = ( ( n / 5 ) * ( 10 + ( n / 5 - 1 ) * 5 ) ) / 2 ; sum10 = ( ( n / 10 ) * ( 20 + ( n / 10 - 1 ) * 10 ) ) / 2 ; return sum2 + sum5 - sum10 ; }

BLEU: 63.28
Edit Sim: 108


Src: 
bool checkFibinnary ( int n ) { int prev_last = 0 ; while ( n ) { if ( ( n & 1 ) && prev_last ) return false ; prev_last = n & 1 ; n >>= 1 ; } return true ; }
Ref: 
function checkFibinnary ( n ) { var prev_last = 0 ; while ( n != 0 ) { if ( ( n & 1 ) != 0 && prev_last != 0 ) return false ; prev_last = n & 1 ; n >>= 1 ; } return true ; }
Hyp: 
function checkFibinnary ( n ) { let prev_last = 0 ; while ( n ) { if ( ( n & 1 ) && prev_last ) return false ; prev_last = n & 1 ; n >>= 1 ; } return true ; }

BLEU: 72.98
Edit Sim: 18


Src: 
int findMin ( int arr [ ] , int low , int high ) { if ( high < low ) return arr [ 0 ] ; if ( high == low ) return arr [ low ] ; int mid = low + ( high - low ) / 2 ; if ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) return arr [ mid + 1 ] ; if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) return arr [ mid ] ; if ( arr [ high ] > arr [ mid ] ) return findMin ( arr , low , mid - 1 ) ; return findMin ( arr , mid + 1 , high ) ; }
Ref: 
function findMin ( arr , low , high ) { if ( high < low ) return arr [ 0 ] ; if ( high == low ) return arr [ low ] ; let mid = low + Math . floor ( ( high - low ) / 2 ) ; if ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) return arr [ mid + 1 ] ; if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) return arr [ mid ] ; if ( arr [ high ] > arr [ mid ] ) return findMin ( arr , low , mid - 1 ) ; return findMin ( arr , mid + 1 , high ) ; }
Hyp: 
function findMin ( arr , low , high ) { if ( high < low ) return arr [ 0 ] ; if ( high == low ) return arr [ low ] ; let mid = low + ( high - low ) / 2 ; if ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) return arr [ mid + 1 ] ; if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) return arr [ mid ] ; if ( arr [ high ] > arr [ mid ] ) return findMin ( arr , low , mid - 1 ) ; return findMin ( arr , mid + 1 , high ) ; }

BLEU: 94.14
Edit Sim: 17


Src: 
int getMaxGold ( int gold [ ] [ MAX ] , int m , int n ) { int goldTable [ m ] [ n ] ; memset ( goldTable , 0 , sizeof ( goldTable ) ) ; for ( int col = n - 1 ; col >= 0 ; col -- ) { for ( int row = 0 ; row < m ; row ++ ) { int right = ( col == n - 1 ) ? 0 : goldTable [ row ] [ col + 1 ] ; int right_up = ( row == 0 col == n - 1 ) ? 0 : goldTable [ row - 1 ] [ col + 1 ] ; int right_down = ( row == m - 1 col == n - 1 ) ? 0 : goldTable [ row + 1 ] [ col + 1 ] ; goldTable [ row ] [ col ] = gold [ row ] [ col ] + max ( right , max ( right_up , right_down ) ) ; } } int res = goldTable [ 0 ] [ 0 ] ; for ( int i = 1 ; i < m ; i ++ ) res = max ( res , goldTable [ i ] [ 0 ] ) ; return res ; }
Ref: 
function getMaxGold ( gold , m , n ) { let goldTable = new Array ( m ) ; for ( let i = 0 ; i < m ; i ++ ) { goldTable [ i ] = new Array ( n ) ; for ( let j = 0 ; j < n ; j ++ ) { goldTable [ i ] [ j ] = 0 ; } } for ( let col = n - 1 ; col >= 0 ; col -- ) { for ( let row = 0 ; row < m ; row ++ ) { let right = ( col == n - 1 ) ? 0 : goldTable [ row ] [ col + 1 ] ; let right_up = ( row == 0 col == n - 1 ) ? 0 : goldTable [ row - 1 ] [ col + 1 ] ; let right_down = ( row == m - 1 col == n - 1 ) ? 0 : goldTable [ row + 1 ] [ col + 1 ] ; goldTable [ row ] [ col ] = gold [ row ] [ col ] + Math . max ( right , Math . max ( right_up , right_down ) ) ; } } let res = goldTable [ 0 ] [ 0 ] ; for ( let i = 1 ; i < m ; i ++ ) res = Math . max ( res , goldTable [ i ] [ 0 ] ) ; return res ; }
Hyp: 
function getMaxGold ( gold , m , n ) { let goldTable = new Array ( m ) ; for ( let i = 0 ; i < m ; i ++ ) { goldTable [ i ] = new Array ( n ) ; for ( let j = 0 ; j < n - 1 ; j ++ ) { let right = ( col == n - 1 ) ? 0 : goldTable [ row ] [ col + 1 ] ; let right_up = ( row == m - 1 col == n - 1 ) ? 0 : goldTable [ row - 1 ] [ col + 1 ] ; let right_down = ( row == m - 1 col == n - 1 ) ? 0 : goldTable [ row + 1 ] [ col + 1 ] ; goldTable [ row ] [ col ] = gold [ row ] [ col ] + Math . max ( right , Math . max ( right_up , right_down ) ) ; } } let res = goldTable [ 0 ] [ 0 ] ; for ( let i = 1 ; i < m ; i ++ ) res = Math . max ( res , goldTable [ i ] [ 0 ] ) ; return res ; }

BLEU: 81.56
Edit Sim: 121


Src: 
bool areDisjoint ( int set1 [ ] , int set2 [ ] , int m , int n ) { for ( int i = 0 ; i < m ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( set1 [ i ] == set2 [ j ] ) return false ; return true ; }
Ref: 
function aredisjoint ( set1 , set2 ) { for ( let i = 0 ; i < set1 . length ; i ++ ) { for ( let j = 0 ; j < set2 . length ; j ++ ) { if ( set1 [ i ] == set2 [ j ] ) return false ; } } return true ; }
Hyp: 
function areDisjoint ( set1 , set2 , m , n ) { for ( let i = 0 ; i < m ; i ++ ) for ( let j = 0 ; j < n ; j ++ ) if ( set1 [ i ] == set2 [ j ] ) return false ; return true ; }

BLEU: 65.41
Edit Sim: 42


Src: 
int findMinX ( int num [ ] , int rem [ ] , int k ) { while ( true ) { int j ; for ( j = 0 ; j < k ; j ++ ) if ( x % num [ j ] != rem [ j ] ) break ; if ( j == k ) return x ; x ++ ; } return x ; }
Ref: 
function findMinX ( num , rem , k ) { while ( true ) { var j ; for ( j = 0 ; j < k ; j ++ ) if ( x % num [ j ] != rem [ j ] ) break ; if ( j == k ) return x ; x ++ ; } }
Hyp: 
function findMinX ( num , rem , k ) { while ( true ) { let j ; for ( j = 0 ; j < k ; j ++ ) if ( x % num [ j ] != rem [ j ] ) break ; if ( j == k ) return x ; x ++ ; } return x ; }

BLEU: 90.08
Edit Sim: 14


Src: 
float diagonal_length ( float a ) { float L ; L = a * sqrt ( 3 ) ; return L ; }
Ref: 
function diagonal_length ( a ) { let L ; L = a * Math . sqrt ( 3 ) ; return L ; }
Hyp: 
function diagonal_length ( a ) { let L ; L = a * Math . sqrt ( 3 ) ; return L ; }

BLEU: 100.0
Edit Sim: 0


Src: 
void fibonacci ( int n ) { long long int fib ; for ( long long int i = 0 ; i < n ; i ++ ) { fib = ( pow ( ( 1 + sqrt ( 5 ) ) , i ) - pow ( ( 1 - sqrt ( 5 ) ) , i ) ) / ( pow ( 2 , i ) * sqrt ( 5 ) ) ; cout << fib << " ▁ " ; } }
Ref: 
function fibonacci ( n ) { var fib ; for ( i = 0 ; i < n ; i ++ ) { fib = ( Math . pow ( ( 1 + Math . sqrt ( 5 ) ) , i ) - Math . pow ( ( 1 - Math . sqrt ( 5 ) ) , i ) ) / ( Math . pow ( 2 , i ) * Math . sqrt ( 5 ) ) ; document . write ( parseInt ( fib ) + " " ) ; } }
Hyp: 
function fibonacci ( n ) { let fib ; for ( let i = 0 ; i < n ; i ++ ) { fib = ( Math . pow ( ( 1 + Math . sqrt ( 5 ) ) , i ) - Math . pow ( ( 1 - Math . sqrt ( 5 ) ) , i ) ) / ( Math . pow ( 2 , i ) * Math . sqrt ( 5 ) ) ; document . write ( fib + " " ) ; } }

BLEU: 90.43
Edit Sim: 20


Src: 
float polyarea ( float n , float r ) { if ( r < 0 && n < 0 ) return -1 ; float A = ( ( r * r * n ) * sin ( ( 360 / n ) * 3.14159 / 180 ) ) / 2 ; return A ; }
Ref: 
function polyarea ( n , r ) { if ( r < 0 && n < 0 ) return - 1 ; var A = ( ( r * r * n ) * Math . sin ( ( 360 / n ) * 3.14159 / 180 ) ) / 2 ; return A ; }
Hyp: 
function polyarea ( n , r ) { if ( r < 0 && n < 0 ) return - 1 ; var A = ( ( r * r * n ) * Math . sin ( ( 360 / n ) * 3.14159 / 180 ) ) / 2 ; return A ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int countSquares ( int m , int n ) { if ( n < m ) swap ( m , n ) ; return m * ( m + 1 ) * ( 2 * m + 1 ) / 6 + ( n - m ) * m * ( m + 1 ) / 2 ; }
Ref: 
function countSquares ( m , n ) { if ( n < m ) [ m , n ] = [ n , m ] ; return m * ( m + 1 ) * ( 2 * m + 1 ) / 6 + ( n - m ) * m * ( m + 1 ) / 2 ; }
Hyp: 
function countSquares ( m , n ) { if ( n < m ) swap ( m , n ) ; return m * ( m + 1 ) * ( 2 * m + 1 ) / 6 + ( n - m ) * m * ( m + 1 ) / 2 ; }

BLEU: 81.71
Edit Sim: 15


Src: 
int evenbittogglenumber ( int n ) { int res = 0 , count = 0 ; for ( int temp = n ; temp > 0 ; temp >>= 1 ) { if ( count % 2 == 1 ) res |= ( 1 << count ) ; count ++ ; } return n ^ res ; }
Ref: 
function evenbittogglenumber ( n ) { let res = 0 , count = 0 ; for ( let temp = n ; temp > 0 ; temp >>= 1 ) { if ( count % 2 == 1 ) res |= ( 1 << count ) ; count ++ ; } return n ^ res ; }
Hyp: 
function evenbittogglenumber ( n ) { let res = 0 , count = 0 ; for ( let temp = n ; temp > 0 ; temp >>= 1 ) { if ( count % 2 == 1 ) res |= ( 1 << count ) ; count ++ ; } return n ^ res ; }

BLEU: 100.0
Edit Sim: 0


Src: 
void segregate0and1 ( int arr [ ] , int size ) { int left = 0 , right = size - 1 ; while ( left < right ) { while ( arr [ left ] == 0 && left < right ) left ++ ; while ( arr [ right ] == 1 && left < right ) right -- ; if ( left < right ) { arr [ left ] = 0 ; arr [ right ] = 1 ; left ++ ; right -- ; } } }
Ref: 
function segregate0and1 ( arr , size ) { let left = 0 , right = size - 1 ; while ( left < right ) { while ( arr [ left ] == 0 && left < right ) left ++ ; while ( arr [ right ] == 1 && left < right ) right -- ; if ( left < right ) { arr [ left ] = 0 ; arr [ right ] = 1 ; left ++ ; right -- ; } } }
Hyp: 
function segregate0and1 ( arr , size ) { let left = 0 , right = size - 1 ; while ( left < right ) { while ( arr [ left ] == 0 && left < right ) left ++ ; while ( arr [ right ] == 1 && left < right ) right -- ; if ( left < right ) { arr [ left ] = 0 ; arr [ right ] = 1 ; left ++ ; right -- ; } } }

BLEU: 100.0
Edit Sim: 0


Src: 
int search ( int arr [ ] , int l , int h , int key ) { if ( l > h ) return -1 ; int mid = ( l + h ) / 2 ; if ( arr [ mid ] == key ) return mid ; if ( arr [ l ] <= arr [ mid ] ) { if ( key >= arr [ l ] && key <= arr [ mid ] ) return search ( arr , l , mid - 1 , key ) ; return search ( arr , mid + 1 , h , key ) ; } if ( key >= arr [ mid ] && key <= arr [ h ] ) return search ( arr , mid + 1 , h , key ) ; return search ( arr , l , mid - 1 , key ) ; }
Ref: 
function search ( arr , l , h , key ) { if ( l > h ) return - 1 ; let mid = Math . floor ( ( l + h ) / 2 ) ; if ( arr [ mid ] == key ) return mid ; if ( arr [ l ] <= arr [ mid ] ) { if ( key >= arr [ l ] && key <= arr [ mid ] ) return search ( arr , l , mid - 1 , key ) ; return search ( arr , mid + 1 , h , key ) ; } if ( key >= arr [ mid ] && key <= arr [ h ] ) return search ( arr , mid + 1 , h , key ) ; return search ( arr , l , mid - 1 , key ) ; }
Hyp: 
function search ( arr , l , h , key ) { if ( l > h ) return - 1 ; var mid = parseInt ( ( l + h ) / 2 ) ; if ( arr [ mid ] == key ) return mid ; if ( arr [ l ] <= arr [ mid ] ) { if ( key >= arr [ l ] && key <= arr [ mid ] ) return search ( arr , l , mid - 1 , key ) ; return search ( arr , mid + 1 , h , key ) ; } if ( key >= arr [ mid ] && key <= arr [ h ] ) return search ( arr , mid + 1 , h , key ) ; }

BLEU: 85.86
Edit Sim: 58


Src: 
void printOdds ( int arr [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) res = res ^ arr [ i ] ; int set_bit = res & ( ~ ( res - 1 ) ) ; int x = 0 , y = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] & set_bit ) x = x ^ arr [ i ] ; else y = y ^ arr [ i ] ; } cout << x << " ▁ " << y ; }
Ref: 
function printOdds ( arr , n ) { let res = 0 ; for ( let i = 0 ; i < n ; i ++ ) res = res ^ arr [ i ] ; let set_bit = res & ( ~ ( res - 1 ) ) ; let x = 0 , y = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] & set_bit ) x = x ^ arr [ i ] ; else y = y ^ arr [ i ] ; } document . write ( x + " " + y ) ; }
Hyp: 
function printOdds ( arr , n ) { let res = 0 ; for ( let i = 0 ; i < n ; i ++ ) res = res ^ arr [ i ] ; let set_bit = res & ( ~ ( res - 1 ) ) ; let x = 0 , y = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] & set_bit ) > 0 ) x = x ^ arr [ i ] ; else y = y ^ arr [ i ] ; } document . write ( x + " " + y ) ; }

BLEU: 95.37
Edit Sim: 8


Src: 
int oddSum ( int n ) { int sum = 0 , curr = 1 ; for ( int i = 0 ; i < n ; i ++ ) { sum += curr ; curr += 2 ; } return sum ; }
Ref: 
function oddSum ( n ) { let sum = 0 ; curr = 1 ; for ( let i = 0 ; i < n ; i ++ ) { sum += curr ; curr += 2 ; } return sum ; }
Hyp: 
function oddSum ( n ) { let sum = 0 ; let curr = 1 ; for ( let i = 0 ; i < n ; i ++ ) { sum += curr ; curr += 2 ; } return sum ; }

BLEU: 94.14
Edit Sim: 4


Src: 
int sumOfSubstrings ( string num ) { long long int mf = 1 ; for ( int i = num . size ( ) - 1 ; i >= 0 ; i -- ) { sum += ( num [ i ] - '0' ) * ( i + 1 ) * mf ; mf = mf * 10 + 1 ; } return sum ; }
Ref: 
function sumOfSubstrings ( num ) { let sum = 0 ; let mf = 1 ; for ( let i = num . length - 1 ; i >= 0 ; i -- ) { sum += ( num [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ) * ( i + 1 ) * mf ; mf = mf * 10 + 1 ; } return sum ; }
Hyp: 
function sumOfSubstrings ( num ) { let sum = 0 ; for ( let i = num . length - 1 ; i >= 0 ; i -- ) { sum += ( num [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ) * ( i + 1 ) * mf ; mf = mf * 10 + 1 ; } return sum ; }

BLEU: 92.18
Edit Sim: 13


Src: 
void printIntersection ( int A [ ] [ N ] , int B [ ] [ N ] ) { for ( int i = 0 ; i < M ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( A [ i ] [ j ] == B [ i ] [ j ] ) cout << A [ i ] [ j ] << " ▁ " ; else cout << " * ▁ " ; } cout << " STRNEWLINE " ; } }
Ref: 
function printIntersection ( A , B ) { for ( var i = 0 ; i < M ; i ++ ) { for ( var j = 0 ; j < N ; j ++ ) { if ( A [ i ] [ j ] == B [ i ] [ j ] ) document . write ( A [ i ] [ j ] + " " ) ; else document . write ( " " ) ; } document . write ( " " ) ; } }
Hyp: 
function printIntersection ( A , B , M ) { for ( let i = 0 ; i < M ; i ++ ) { for ( let j = 0 ; j < N ; j ++ ) { if ( A [ i ] [ j ] == B [ i ] [ j ] ) document . write ( A [ i ] [ j ] + " " ) ; else document . write ( " " ) ; } }

BLEU: 82.69
Edit Sim: 39


Src: 
void PossibleValues ( int b , int x , int n ) { int leastdivisible = ( b / x + 1 ) * x ; int flag = 1 ; while ( leastdivisible <= n ) { if ( leastdivisible - b >= 1 ) { cout << leastdivisible - b << " ▁ " ; leastdivisible += x ; flag = 0 ; } else break ; } if ( flag ) cout << -1 ; }
Ref: 
function PossibleValues ( b , x , n ) { let leastdivisible = ( Math . floor ( b / x ) + 1 ) * x ; let flag = 1 ; while ( leastdivisible <= n ) { if ( leastdivisible - b >= 1 ) { document . write ( leastdivisible - b + " " ) ; leastdivisible += x ; flag = 0 ; } else break ; } if ( flag > 0 ) document . write ( - 1 + " " ) ; }
Hyp: 
function PossibleValues ( b , x , n ) { let leastdivisible = ( b / x + 1 ) * x ; let flag = 1 ; while ( leastdivisible <= n ) { if ( leastdivisible - b >= 1 ) { document . write ( leastdivisible - b + " " ) ; leastdivisible += x ; flag = 0 ; } else break ; } if ( flag ) document . write ( - 1 ) ; }

BLEU: 82.63
Edit Sim: 27


Src: 
int maxSquare ( int b , int m ) { return ( b / m - 1 ) * ( b / m ) / 2 ; }
Ref: 
function maxSquare ( b , m ) { return ( b / m - 1 ) * ( b / m ) / 2 ; a }
Hyp: 
function maxSquare ( b , m ) { return ( b / m - 1 ) * ( b / m ) / 2 ; }

BLEU: 93.32
Edit Sim: 2


Src: 
void dist ( double x1 , double y1 , double x2 , double y2 , double r ) { cout << " The ▁ shortest ▁ distance ▁ " << " between ▁ a ▁ point ▁ and ▁ a ▁ circle ▁ is ▁ " << sqrt ( ( pow ( ( x2 - x1 ) , 2 ) ) + ( pow ( ( y2 - y1 ) , 2 ) ) ) - r << endl ; }
Ref: 
function dist ( x1 , y1 , x2 , y2 , r ) { document . write ( " " + " " + ( Math . sqrt ( ( Math . pow ( ( x2 - x1 ) , 2 ) ) + ( Math . pow ( ( y2 - y1 ) , 2 ) ) ) - r ) . toFixed ( 5 ) ) ; }
Hyp: 
function dist ( x1 , y1 , x2 , y2 , r ) { document . write ( " " + " " + ( Math . pow ( ( x2 - x1 ) , 2 ) ) + ( Math . pow ( ( y2 - y1 ) , 2 ) ) ) - r ) ; }

BLEU: 81.9
Edit Sim: 34


Src: 
void midpoint ( int x1 , int x2 , int y1 , int y2 ) { cout << ( float ) ( x1 + x2 ) / 2 << " ▁ , ▁ " << ( float ) ( y1 + y2 ) / 2 ; }
Ref: 
function midpoint ( x1 , x2 , y1 , y2 ) { document . write ( ( x1 + x2 ) / 2 + " " + ( y1 + y2 ) / 2 ) ; }
Hyp: 
function midpoint ( x1 , x2 , y1 , y2 ) { document . write ( ( float ) ( x1 + x2 ) / 2 + " " + ( float ) ( y1 + y2 ) / 2 ) ; }

BLEU: 82.12
Edit Sim: 20


Src: 
int oddNumSum ( int n ) { return ( n * ( 2 * n + 1 ) * ( 24 * n * n * n - 12 * n * n - 14 * n + 7 ) ) / 15 ; }
Ref: 
function oddNumSum ( n ) { return ( n * ( 2 * n + 1 ) * ( 24 * n * n * n - 12 * n * n - 14 * n + 7 ) ) / 15 ; }
Hyp: 
function oddNumSum ( n ) { return ( n * ( 2 * n + 1 ) * ( 24 * n * n * n - 12 * n * n - 14 * n + 7 ) ) / 15 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int findMean ( int arr [ ] , int l , int r ) { int sum = 0 , count = 0 ; for ( int i = l ; i <= r ; i ++ ) { sum += arr [ i ] ; count ++ ; } int mean = floor ( sum / count ) ; return mean ; }
Ref: 
function findMean ( arr , l , r ) { let sum = 0 , count = 0 ; for ( let i = l ; i <= r ; i ++ ) { sum += arr [ i ] ; count ++ ; } let mean = Math . floor ( sum / count ) ; return mean ; }
Hyp: 
function findMean ( arr , l , r ) { var sum = 0 , count = 0 ; for ( var i = l ; i <= r ; i ++ ) { sum += arr [ i ] ; count ++ ; } var mean = Math . floor ( sum / count ) ; return mean ; }

BLEU: 87.31
Edit Sim: 9


Src: 
void printDivisors ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) if ( n % i == 0 ) cout << " ▁ " << i ; }
Ref: 
function printDivisors ( n ) { for ( i = 1 ; i <= n ; i ++ ) if ( n % i == 0 ) document . write ( i + " " ) ; }
Hyp: 
function printDivisors ( n ) { for ( let i = 1 ; i <= n ; i ++ ) if ( n % i == 0 ) document . write ( " " + i ) ; }

BLEU: 81.56
Edit Sim: 8


Src: 
int kth ( int arr1 [ ] , int arr2 [ ] , int m , int n , int k ) { int sorted1 [ m + n ] ; int i = 0 , j = 0 , d = 0 ; while ( i < m && j < n ) { if ( arr1 [ i ] < arr2 [ j ] ) sorted1 [ d ++ ] = arr1 [ i ++ ] ; else sorted1 [ d ++ ] = arr2 [ j ++ ] ; } while ( i < m ) sorted1 [ d ++ ] = arr1 [ i ++ ] ; while ( j < n ) sorted1 [ d ++ ] = arr2 [ j ++ ] ; return sorted1 [ k - 1 ] ; }
Ref: 
function kth ( arr1 , arr2 , m , n , k ) { var sorted1 = Array ( m + n ) . fill ( 0 ) ; var i = 0 , j = 0 , d = 0 ; while ( i < m && j < n ) { if ( arr1 [ i ] < arr2 [ j ] ) sorted1 [ d ++ ] = arr1 [ i ++ ] ; else sorted1 [ d ++ ] = arr2 [ j ++ ] ; } while ( i < m ) sorted1 [ d ++ ] = arr1 [ i ++ ] ; while ( j < n ) sorted1 [ d ++ ] = arr2 [ j ++ ] ; return sorted1 [ k - 1 ] ; }
Hyp: 
function kth ( arr1 , arr2 , m , n , k ) { var sorted1 = new Array ( m + n ) ; var i = 0 , j = 0 , d = 0 ; while ( i < m && j < n ) { if ( arr1 [ i ] < arr2 [ j ] ) sorted1 [ d ++ ] = arr1 [ i ++ ] ; else sorted1 [ d ++ ] = arr2 [ j ++ ] ; } while ( i < m ) sorted1 [ d ++ ] = arr1 [ i ++ ] ; while ( j < n ) sorted1 [ d ++ ] = arr2 [ j ++ ] ; return sorted1 [ k - 1 ] ; }

BLEU: 94.59
Edit Sim: 17


Src: 
int MaximumPath ( int Mat [ ] [ N ] ) { int result = 0 ; int dp [ N ] [ N + 2 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; for ( int i = 0 ; i < N ; i ++ ) dp [ 0 ] [ i + 1 ] = Mat [ 0 ] [ i ] ; for ( int i = 1 ; i < N ; i ++ ) for ( int j = 1 ; j <= N ; j ++ ) dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j - 1 ] , max ( dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ j + 1 ] ) ) + Mat [ i ] [ j - 1 ] ; for ( int i = 0 ; i <= N ; i ++ ) result = max ( result , dp [ N - 1 ] [ i ] ) ; return result ; }
Ref: 
function MaximumPath ( Mat ) { let result = 0 ; let dp = new Array ( N ) ; for ( let i = 0 ; i < N ; i ++ ) { dp [ i ] = new Array ( N + 2 ) ; for ( let j = 0 ; j < N + 2 ; j ++ ) { dp [ i ] [ j ] = 0 ; } } for ( let i = 0 ; i < N ; i ++ ) dp [ 0 ] [ i + 1 ] = Mat [ 0 ] [ i ] ; for ( let i = 1 ; i < N ; i ++ ) for ( let j = 1 ; j <= N ; j ++ ) dp [ i ] [ j ] = Math . max ( dp [ i - 1 ] [ j - 1 ] , Math . max ( dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ j + 1 ] ) ) + Mat [ i ] [ j - 1 ] ; for ( let i = 0 ; i <= N ; i ++ ) result = Math . max ( result , dp [ N - 1 ] [ i ] ) ; return result ; }
Hyp: 
function MaximumPath ( Mat ) { let result = 0 ; let dp = new Array ( N ) ; for ( let i = 0 ; i < N ; i ++ ) { dp [ i ] = new Array ( N + 2 ) ; } for ( let i = 0 ; i < N ; i ++ ) { for ( let j = 1 ; j <= N ; j ++ ) dp [ i ] [ j ] = Math . max ( dp [ i - 1 ] [ j - 1 ] , Math . max ( dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ j + 1 ] ) ) + Mat [ i ] [ j - 1 ] ; for ( let i = 0 ; i <= N ; i ++ ) result = Math . max ( result , dp [ N - 1 ] [ i ] ) ; return result ; }

BLEU: 70.42
Edit Sim: 133


Src: 
ll spellsCount ( string num ) { int n = num . length ( ) ; ll result = 1 ; for ( int i = 0 ; i < n ; i ++ ) { int count = 1 ; while ( i < n - 1 && num [ i + 1 ] == num [ i ] ) { count ++ ; i ++ ; } result = result * pow ( 2 , count - 1 ) ; } return result ; }
Ref: 
function spellsCount ( num ) { let n = num . length ; let result = 1 ; for ( let i = 0 ; i < n ; i ++ ) { let count = 1 ; while ( i < n - 1 && num [ i + 1 ] == num [ i ] ) { count ++ ; i ++ ; } result = result * Math . pow ( 2 , count - 1 ) ; } return result ; }
Hyp: 
function spellsCount ( num ) { let n = num . length ; let result = 1 ; for ( let i = 0 ; i < n ; i ++ ) { let count = 1 ; while ( i < n - 1 && num [ i + 1 ] == num [ i ] ) { count ++ ; i ++ ; } result = result * Math . pow ( 2 , count - 1 ) ; } return result ; }

BLEU: 100.0
Edit Sim: 0


Src: 
void countWaysToJump ( int arr [ ] , int n ) { int count_jump [ n ] ; memset ( count_jump , 0 , sizeof ( count_jump ) ) ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] >= n - i - 1 ) count_jump [ i ] ++ ; for ( int j = i + 1 ; j < n - 1 && j <= arr [ i ] + i ; j ++ ) if ( count_jump [ j ] != -1 ) count_jump [ i ] += count_jump [ j ] ; if ( count_jump [ i ] == 0 ) count_jump [ i ] = -1 ; } for ( int i = 0 ; i < n ; i ++ ) cout << count_jump [ i ] << " ▁ " ; }
Ref: 
function countWaysToJump ( arr , n ) { let count_jump = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { count_jump [ i ] = 0 ; } for ( let i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] >= n - i - 1 ) count_jump [ i ] ++ ; for ( let j = i + 1 ; j < n - 1 && j <= arr [ i ] + i ; j ++ ) if ( count_jump [ j ] != - 1 ) count_jump [ i ] += count_jump [ j ] ; if ( count_jump [ i ] == 0 ) count_jump [ i ] = - 1 ; } for ( let i = 0 ; i < n ; i ++ ) document . write ( count_jump [ i ] + " " ) ; }
Hyp: 
function countWaysToJump ( arr , n ) { let count_jump = new Array ( n ) ; count_jump . fill ( 0 ) ; for ( let i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] >= n - i - 1 ) count_jump [ i ] ++ ; for ( let j = i + 1 ; j < n - 1 && j <= arr [ i ] + i ; j ++ ) if ( count_jump [ j ] != - 1 ) count_jump [ i ] += count_jump [ j ] ; if ( count_jump [ i ] == 0 ) count_jump [ i ] = - 1 ; } for ( let i = 0 ; i < n ; i ++ ) document . write ( count_jump [ i ] + " " ) ; }

BLEU: 86.51
Edit Sim: 42


Src: 
int countIslands ( int mat [ ] [ N ] ) { int count = 0 ; for ( int i = 0 ; i < M ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( mat [ i ] [ j ] == ' X ' ) { if ( ( i == 0 mat [ i - 1 ] [ j ] == ' O ' ) && ( j == 0 mat [ i ] [ j - 1 ] == ' O ' ) ) count ++ ; } } } return count ; }
Ref: 
function countIslands ( mat , m , n ) { let count = 0 ; for ( let i = 0 ; i < m ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { if ( mat [ i ] [ j ] == ' ' ) { if ( ( i == 0 mat [ i - 1 ] [ j ] == ' ' ) && ( j == 0 mat [ i ] [ j - 1 ] == ' ' ) ) count ++ ; } } } return count ; }
Hyp: 
function countIslands ( mat ) { let count = 0 ; for ( let i = 0 ; i < M ; i ++ ) { for ( let j = 0 ; j < N ; j ++ ) { if ( mat [ i ] [ j ] == ' ' ) { if ( ( i == 0 mat [ i - 1 ] [ j ] == ' ' ) && ( j == 0 mat [ i ] [ j - 1 ] == ' ' ) ) count ++ ; } } } return count ; }

BLEU: 90.0
Edit Sim: 10


Src: 
int sum ( int a [ ] , int n ) { int maxSum = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) maxSum = max ( maxSum , a [ i ] + a [ j ] ) ; int c = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( a [ i ] + a [ j ] == maxSum ) c ++ ; return c ; }
Ref: 
function sum ( a , n ) { let maxSum = Number . MIN_VALUE ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = i + 1 ; j < n ; j ++ ) maxSum = Math . max ( maxSum , a [ i ] + a [ j ] ) ; let c = 0 ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = i + 1 ; j < n ; j ++ ) if ( a [ i ] + a [ j ] == maxSum ) c ++ ; return c ; }
Hyp: 
function sum ( a , n ) { let maxSum = Number . MAX_VALUE ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = i + 1 ; j < n ; j ++ ) maxSum = Math . max ( maxSum , a [ i ] + a [ j ] ) ; let c = 0 ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = i + 1 ; j < n ; j ++ ) if ( a [ i ] + a [ j ] == maxSum ) c ++ ; return c ; }

BLEU: 97.89
Edit Sim: 2


Src: 
int minimumX ( int n , int k ) { int mini = INT_MAX ; for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { int fir = i ; int sec = n / i ; int num1 = fir * k + sec ; int res = ( num1 / k ) * ( num1 % k ) ; if ( res == n ) mini = min ( num1 , mini ) ; int num2 = sec * k + fir ; res = ( num2 / k ) * ( num2 % k ) ; if ( res == n ) mini = min ( num2 , mini ) ; } } return mini ; }
Ref: 
function minimumX ( n , k ) { let mini = Number . MAX_VALUE ; for ( let i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { let fir = i ; let sec = parseInt ( n / i , 10 ) ; let num1 = fir * k + sec ; let res = parseInt ( ( num1 / k ) , 10 ) * ( num1 % k ) ; if ( res == n ) mini = Math . min ( num1 , mini ) ; let num2 = sec * k + fir ; res = parseInt ( ( num2 / k ) , 10 ) * ( num2 % k ) ; if ( res == n ) mini = Math . min ( num2 , mini ) ; } } return mini ; }
Hyp: 
function minimumX ( n , k ) { let mini = Number . MAX_VALUE ; for ( let i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { let fir = i ; let sec = n / i ; let num1 = fir * k + sec ; let res = ( num1 / k ) * ( num1 % k ) ; if ( res == n ) mini = Math . min ( num1 , mini ) ; let num2 = sec * k + fir ; res = ( num2 / k ) * ( num2 % k ) ; if ( res == n ) mini = Math . min ( num2 , mini ) ; } } } return mini ; }

BLEU: 84.77
Edit Sim: 56


Src: 
void findMinAvgSubarray ( int arr [ ] , int n , int k ) { if ( n < k ) return ; int res_index = 0 ; int curr_sum = 0 ; for ( int i = 0 ; i < k ; i ++ ) curr_sum += arr [ i ] ; int min_sum = curr_sum ; for ( int i = k ; i < n ; i ++ ) { curr_sum += arr [ i ] - arr [ i - k ] ; if ( curr_sum < min_sum ) { min_sum = curr_sum ; res_index = ( i - k + 1 ) ; } } cout << " Subarray ▁ between ▁ [ " << res_index << " , ▁ " << res_index + k - 1 << " ] ▁ has ▁ minimum ▁ average " ; }
Ref: 
function findMinAvgSubarray ( arr , n , k ) { if ( n < k ) return ; let res_index = 0 ; let curr_sum = 0 ; for ( let i = 0 ; i < k ; i ++ ) curr_sum += arr [ i ] ; let min_sum = curr_sum ; for ( let i = k ; i < n ; i ++ ) { curr_sum += arr [ i ] - arr [ i - k ] ; if ( curr_sum < min_sum ) { min_sum = curr_sum ; res_index = ( i - k + 1 ) ; } } document . write ( " " + res_index + " " + ( res_index + k - 1 ) + " " ) ; }
Hyp: 
function findMinAvgSubarray ( arr , n , k ) { if ( n < k ) return ; let res_index = 0 ; let curr_sum = 0 ; for ( let i = 0 ; i < k ; i ++ ) curr_sum += arr [ i ] ; let min_sum = curr_sum ; for ( let i = k ; i < n ; i ++ ) { curr_sum += arr [ i ] - arr [ i - k ] ; if ( curr_sum < min_sum ) { min_sum = curr_sum ; res_index = ( i - k + 1 ) ; } } document . write ( " " + res_index + " " + res_index + k - 1 + " " ) ; }

BLEU: 96.13
Edit Sim: 4


Src: 
int circle ( int x1 , int y1 , int x2 , int y2 , int r1 , int r2 ) { int distSq = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ; int radSumSq = ( r1 + r2 ) * ( r1 + r2 ) ; if ( distSq == radSumSq ) return 1 ; else if ( distSq > radSumSq ) return -1 ; else return 0 ; }
Ref: 
function circle ( x1 , y1 , x2 , y2 , r1 , r2 ) { let distSq = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ; let radSumSq = ( r1 + r2 ) * ( r1 + r2 ) ; if ( distSq == radSumSq ) return 1 ; else if ( distSq > radSumSq ) return - 1 ; else return 0 ; }
Hyp: 
function circle ( x1 , y1 , x2 , y2 , r1 , r2 ) { var distSq = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ; var radSumSq = ( r1 + r2 ) * ( r1 + r2 ) ; if ( distSq == radSumSq ) return 1 ; else if ( distSq > radSumSq ) return - 1 ; else return 0 ; }

BLEU: 93.86
Edit Sim: 6


Src: 
bool isDivisibleBy25 ( string str ) { int n = str . length ( ) ; if ( n == 1 ) return false ; return ( ( str [ n - 1 ] - '0' == 0 && str [ n - 2 ] - '0' == 0 ) || ( ( str [ n - 2 ] - '0' ) * 10 + ( str [ n - 1 ] - '0' ) ) % 25 == 0 ) ; }
Ref: 
function isDivisibleBy25 ( str ) { n = str . length ; if ( n == 1 ) return false ; return ( ( str [ n - 1 ] - ' ' == 0 && str [ n - 2 ] - ' ' == 0 ) || ( ( str [ n - 2 ] - ' ' ) * 10 + ( str [ n - 1 ] - ' ' ) ) % 25 == 0 ) ; }
Hyp: 
function isDivisibleBy25 ( str ) { let n = str . length ; if ( n == 1 ) return false ; return ( ( str [ n - 1 ] - ' ' ) == 0 && str [ n - 2 ] - ' ' == 0 ) || ( ( str [ n - 2 ] - ' ' ) * 10 + ( str [ n - 1 ] - ' ' ) ) % 25 == 0 ) ; }

BLEU: 94.01
Edit Sim: 6


Src: 
int Minsteps ( int n , int m ) { int ans = 0 ; while ( m > n ) { if ( m & 1 ) { m ++ ; ans ++ ; } m /= 2 ; ans ++ ; } return ans + n - m ; }
Ref: 
function Minsteps ( n , m ) { let ans = 0 ; while ( m > n ) { if ( m & 1 ) { m ++ ; ans ++ ; } m = Math . floor ( m / 2 ) ; ans ++ ; } return ans + n - m ; }
Hyp: 
function Minsteps ( n , m ) { let ans = 0 ; while ( m > n ) { if ( m & 1 ) { m ++ ; ans ++ ; } m = Math . floor ( m / 2 ) ; ans ++ ; } return ans + n - m ; }

BLEU: 100.0
Edit Sim: 0


Src: 
bool CheckArray ( int arr [ ] , int n ) { int prod = 1 ; for ( int i = 0 ; i < n ; ++ i ) prod *= arr [ i ] ; for ( int i = 0 ; i < n ; ++ i ) if ( arr [ i ] == prod / arr [ i ] ) return true ; return false ; }
Ref: 
function CheckArray ( arr , n ) { let prod = 1 ; for ( let i = 0 ; i < n ; ++ i ) prod *= arr [ i ] ; for ( let i = 0 ; i < n ; ++ i ) if ( arr [ i ] == prod / arr [ i ] ) return true ; return false ; }
Hyp: 
function CheckArray ( arr , n ) { let prod = 1 ; for ( let i = 0 ; i < n ; ++ i ) prod *= arr [ i ] ; for ( let i = 0 ; i < n ; ++ i ) if ( arr [ i ] == prod / arr [ i ] ) return true ; return false ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int AND ( int a [ ] , int n ) { int ans = a [ 0 ] ; for ( int i = 0 ; i < n ; ++ i ) ans &= a [ i ] ; return ans ; }
Ref: 
function AND ( a , n ) { let ans = a [ 0 ] ; for ( let i = 0 ; i < n ; ++ i ) ans &= a [ i ] ; return ans ; }
Hyp: 
function AND ( a , n ) { let ans = a [ 0 ] ; for ( let i = 0 ; i < n ; ++ i ) ans &= a [ i ] ; return ans ; }

BLEU: 100.0
Edit Sim: 0


Src: 
long nondecdigits ( long long n ) { long long int x = 0 ; for ( x = n ; x >= 1 ; x -- ) { int no = x ; int prev_dig = 11 ; bool flag = true ; while ( no != 0 ) { if ( prev_dig < no % 10 ) { flag = false ; break ; } prev_dig = no % 10 ; no /= 10 ; } if ( flag == true ) break ; } return x ; }
Ref: 
function nondecdigits ( n ) { let x = 0 ; for ( x = n ; x >= 1 ; x -- ) { let no = x ; let prev_dig = 11 ; let flag = true ; while ( no != 0 ) { if ( prev_dig < no % 10 ) { flag = false ; break ; } prev_dig = no % 10 ; no = Math . floor ( no / 10 ) ; } if ( flag == true ) break ; } return x ; }
Hyp: 
function nondecdigits ( n ) { let x = 0 ; for ( x = n ; x >= 1 ; x -- ) { let no = x ; let prev_dig = 11 ; let flag = true ; while ( no != 0 ) { if ( prev_dig < no % 10 ) { flag = false ; break ; } prev_dig = no % 10 ; no = parseInt ( no / 10 ) ; } if ( flag == true ) break ; } return x ; }

BLEU: 95.15
Edit Sim: 11


Src: 
void Loss ( int SP , int P ) { float loss = 0 ; loss = ( 2 * P * P * SP ) / float ( 100 * 100 - P * P ) ; cout << " Loss ▁ = ▁ " << loss ; }
Ref: 
function Loss ( SP , P ) { var loss = 0 ; loss = ( 2 * P * P * SP ) / ( 100 * 100 - P * P ) ; document . write ( " " + loss . toFixed ( 3 ) ) ; }
Hyp: 
function Loss ( SP , P ) { let loss = 0 ; loss = ( 2 * P * P * SP ) / ( 100 * 100 - P * P ) ; document . write ( " " + loss . toFixed ( 10 ) ) ; }

BLEU: 89.88
Edit Sim: 5


Src: 
void segregateElements ( int arr [ ] , int n ) { int temp [ n ] ; int j = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] >= 0 ) temp [ j ++ ] = arr [ i ] ; if ( j == n j == 0 ) return ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] < 0 ) temp [ j ++ ] = arr [ i ] ; memcpy ( arr , temp , sizeof ( temp ) ) ; }
Ref: 
function segregateElements ( arr , n ) { let temp = new Array ( n ) ; let j = 0 ; for ( let i = 0 ; i < n ; i ++ ) if ( arr [ i ] >= 0 ) temp [ j ++ ] = arr [ i ] ; if ( j == n j == 0 ) return ; for ( let i = 0 ; i < n ; i ++ ) if ( arr [ i ] < 0 ) temp [ j ++ ] = arr [ i ] ; for ( let i = 0 ; i < n ; i ++ ) arr [ i ] = temp [ i ] ; }
Hyp: 
function segregateElements ( arr , n ) { let temp = new Array ( n ) ; let j = 0 ; for ( let i = 0 ; i < n ; i ++ ) if ( arr [ i ] >= 0 ) temp [ j ++ ] = arr [ i ] ; if ( j == n j == 0 ) return ; for ( let i = 0 ; i < n ; i ++ ) if ( arr [ i ] < 0 ) temp [ j ++ ] = arr [ i ] ; memcpy ( arr , temp , sizeof ( temp ) ) ; }

BLEU: 81.04
Edit Sim: 40


Src: 
int remainingArea ( int N , int M , int K ) { while ( K -- && N && M ) { if ( N > M ) N = N - M ; else M = M - N ; } if ( N > 0 && M > 0 ) return N * M ; else return 0 ; }
Ref: 
function remainingArea ( N , M , K ) { while ( K -- && N && M ) { if ( N > M ) N = N - M ; else M = M - N ; } if ( N > 0 && M > 0 ) return N * M ; else return 0 ; }
Hyp: 
function remainingArea ( N , M , K ) { while ( K -- && N && M ) { if ( N > M ) N = N - M ; else M = M - N ; } if ( N > 0 && M > 0 ) return N * M ; else return 0 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
ull countCompositions ( ull n ) { return ( 1L ) << ( n - 1 ) ; }
Ref: 
function countCompositions ( n ) { return 1 << ( n - 1 ) ; }
Hyp: 
function countCompositions ( n ) { return ( 1L ) << ( n - 1 ) ; }

BLEU: 73.32
Edit Sim: 5


Src: 
int countConsecutive ( long int N ) { long int count = 0 ; for ( long int L = 1 ; L * ( L + 1 ) < 2 * N ; L ++ ) { double a = ( 1.0 * N - ( L * ( L + 1 ) ) / 2 ) / ( L + 1 ) ; if ( a - ( int ) a == 0.0 ) count ++ ; } return count ; }
Ref: 
function countConsecutive ( N ) { let count = 0 ; for ( let L = 1 ; L * ( L + 1 ) < 2 * N ; L ++ ) { let a = ( ( 1.0 * N - ( L * ( L + 1 ) ) / 2 ) / ( L + 1 ) ) ; if ( a - parseInt ( a , 10 ) == 0.0 ) count ++ ; } return count ; }
Hyp: 
function countConsecutive ( N ) { let count = 0 ; for ( let L = 1 ; L * ( L + 1 ) < 2 * N ; L ++ ) { let a = ( 1.0 * N - ( L * ( L + 1 ) ) / 2 ) / ( L + 1 ) ; if ( a - parseInt ( a ) == 0.0 ) count ++ ; } return count ; }

BLEU: 91.43
Edit Sim: 9


Src: 
bool areVowelsInOrder ( string s ) { int n = s . length ( ) ; char c = ( char ) 64 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ' a ' s [ i ] == ' e ' s [ i ] == ' i ' s [ i ] == ' o ' s [ i ] == ' u ' ) { if ( s [ i ] < c ) return false ; else { c = s [ i ] ; } } } return true ; }
Ref: 
function areVowelsInOrder ( s ) { var n = s . length ; var c = String . fromCharCode ( 64 ) ; for ( var i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ' ' s [ i ] == ' ' s [ i ] == ' ' s [ i ] == ' ' s [ i ] == ' ' ) { if ( s [ i ] < c ) return false ; else { c = s [ i ] ; } } } return true ; }
Hyp: 
function areVowelsInOrder ( s ) { let n = s . length ; let c = ( char ) 64 ; for ( let i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ' ' s [ i ] == ' ' s [ i ] == ' ' ) { if ( s [ i ] < c ) return false ; else { c = s [ i ] ; } } } return true ; }

BLEU: 71.98
Edit Sim: 59


Src: 
int countDer ( int n ) { if ( n == 1 ) return 0 ; if ( n == 2 ) return 1 ; return ( n - 1 ) * ( countDer ( n - 1 ) + countDer ( n - 2 ) ) ; }
Ref: 
function countDer ( n ) { if ( n == 1 ) return 0 ; if ( n == 2 ) return 1 ; return ( n - 1 ) * ( countDer ( n - 1 ) + countDer ( n - 2 ) ) ; }
Hyp: 
function countDer ( n ) { if ( n == 1 ) return 0 ; if ( n == 2 ) return 1 ; return ( n - 1 ) * ( countDer ( n - 1 ) + countDer ( n - 2 ) ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
float rmsValue ( int arr [ ] , int n ) { int square = 0 ; float mean = 0.0 , root = 0.0 ; for ( int i = 0 ; i < n ; i ++ ) { square += pow ( arr [ i ] , 2 ) ; } mean = ( square / ( float ) ( n ) ) ; root = sqrt ( mean ) ; return root ; }
Ref: 
function rmsValue ( arr , n ) { var square = 0 ; var mean = 0 ; var root = 0 ; for ( i = 0 ; i < n ; i ++ ) { square += Math . pow ( arr [ i ] , 2 ) ; } mean = ( square / ( n ) ) ; root = Math . sqrt ( mean ) ; return root ; }
Hyp: 
function rmsValue ( arr , n ) { let square = 0 ; let mean = 0.0 , root = 0.0 ; for ( let i = 0 ; i < n ; i ++ ) { square += Math . pow ( arr [ i ] , 2 ) ; } mean = ( square / ( float ) ( n ) ) ; root = Math . sqrt ( mean ) ; return root ; }

BLEU: 77.9
Edit Sim: 27


Src: 
int solve ( int low , int high , int T ) { while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( ( mid * ( mid + 1 ) ) == T ) return mid ; if ( mid > 0 && ( mid * ( mid + 1 ) ) > T && ( mid * ( mid - 1 ) ) <= T ) return mid - 1 ; if ( ( mid * ( mid + 1 ) ) > T ) high = mid - 1 ; else low = mid + 1 ; } return -1 ; }
Ref: 
function solve ( low , high , T ) { while ( low <= high ) { let mid = Math . floor ( ( low + high ) / 2 ) ; if ( ( mid * ( mid + 1 ) ) == T ) return mid ; if ( mid > 0 && ( mid * ( mid + 1 ) ) > T && ( mid * ( mid - 1 ) ) <= T ) return mid - 1 ; if ( ( mid * ( mid + 1 ) ) > T ) high = mid - 1 ; else low = mid + 1 ; } return - 1 ; }
Hyp: 
function solve ( low , high , T ) { while ( low <= high ) { let mid = ( low + high ) / 2 ; if ( ( mid * ( mid + 1 ) ) == T ) return mid ; if ( mid > 0 && ( mid * ( mid + 1 ) ) > T && ( mid * ( mid - 1 ) ) <= T ) return mid - 1 ; if ( ( mid * ( mid + 1 ) ) > T ) high = mid - 1 ; else low = mid + 1 ; } return - 1 ; }

BLEU: 93.08
Edit Sim: 17


Src: 
int findN ( int k ) { int ans ; if ( k == 0 ) ans = 3 ; if ( k == 1 ) ans = 1 ; else if ( k % 4 == 0 ) ans = k ; else if ( k % 4 == 3 ) ans = k - 1 ; else ans = -1 ; return ans ; }
Ref: 
function findN ( k ) { var ans ; if ( k == 0 ) ans = 3 ; if ( k == 1 ) ans = 1 ; else if ( k % 4 == 0 ) ans = k ; else if ( k % 4 == 3 ) ans = k - 1 ; else ans = - 1 ; return ans ; }
Hyp: 
function findN ( k ) { let ans ; if ( k == 0 ) ans = 3 ; if ( k == 1 ) ans = 1 ; else if ( k % 4 == 0 ) ans = k ; else if ( k % 4 == 3 ) ans = k - 1 ; else ans = - 1 ; return ans ; }

BLEU: 96.2
Edit Sim: 3


Src: 
int MatrixChainOrder ( int p [ ] , int n ) { int dp [ n ] [ n ] ; for ( int i = 1 ; i < n ; i ++ ) dp [ i ] [ i ] = 0 ; for ( int L = 1 ; L < n - 1 ; L ++ ) for ( int i = 1 ; i < n - L ; i ++ ) dp [ i ] [ i + L ] = min ( dp [ i + 1 ] [ i + L ] + p [ i - 1 ] * p [ i ] * p [ i + L ] , dp [ i ] [ i + L - 1 ] + p [ i - 1 ] * p [ i + L - 1 ] * p [ i + L ] ) ; return dp [ 1 ] [ n - 1 ] ; }
Ref: 
function MatrixChainOrder ( p , n ) { var dp = Array . from ( Array ( n ) , ( ) => Array ( n ) ) ; for ( var i = 1 ; i < n ; i ++ ) dp [ i ] [ i ] = 0 ; for ( var L = 1 ; L < n - 1 ; L ++ ) for ( var i = 1 ; i < n - L ; i ++ ) dp [ i ] [ i + L ] = Math . min ( dp [ i + 1 ] [ i + L ] + p [ i - 1 ] * p [ i ] * p [ i + L ] , dp [ i ] [ i + L - 1 ] + p [ i - 1 ] * p [ i + L - 1 ] * p [ i + L ] ) ; return dp [ 1 ] [ n - 1 ] ; }
Hyp: 
function MatrixChainOrder ( p , n ) { let dp = new Array ( n ) ; for ( let i = 1 ; i < n ; i ++ ) dp [ i ] [ i ] = 0 ; for ( let L = 1 ; L < n - 1 ; L ++ ) for ( let i = 1 ; i < n - L ; i ++ ) dp [ i ] [ i + L ] = Math . min ( dp [ i + 1 ] [ i + L ] + p [ i - 1 ] * p [ i ] * p [ i + L ] , dp [ i ] [ i + L - 1 ] + p [ i - 1 ] * p [ i + L ] ) ; return dp [ 1 ] [ n - 1 ] ; }

BLEU: 80.12
Edit Sim: 66


Src: 
int superSeq ( char * X , char * Y , int m , int n ) { int dp [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( ! i ) dp [ i ] [ j ] = j ; else if ( ! j ) dp [ i ] [ j ] = i ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = 1 + min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) ; } } return dp [ m ] [ n ] ; }
Ref: 
function superSeq ( X , Y , m , n ) { var dp = Array ( m + 1 ) . fill ( 0 ) . map ( x => Array ( n + 1 ) . fill ( 0 ) ) ; for ( var i = 0 ; i <= m ; i ++ ) { for ( var j = 0 ; j <= n ; j ++ ) { if ( i == 0 ) dp [ i ] [ j ] = j ; else if ( j == 0 ) dp [ i ] [ j ] = i ; else if ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = 1 + Math . min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) ; } } return dp [ m ] [ n ] ; }
Hyp: 
function superSeq ( X , Y , m , n ) { var dp = Array . from ( Array ( m + 1 ) , ( ) => Array ( n + 1 ) ) ; for ( var i = 0 ; i <= m ; i ++ ) { for ( var j = 0 ; j <= n ; j ++ ) { if ( ! i ) dp [ i ] [ j ] = j ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = 1 + Math . min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) ; } } return dp [ m ] [ n ] ; }

BLEU: 73.86
Edit Sim: 100


Src: 
float sum ( float n ) { if ( n < 2 ) return 1 ; else return 1 / n + ( sum ( n - 1 ) ) ; }
Ref: 
function sum ( n ) { if ( n < 2 ) { return 1 } else { return 1 / n + ( sum ( n - 1 ) ) } }
Hyp: 
function sum ( n ) { if ( n < 2 ) return 1 ; else return 1 / n + ( sum ( n - 1 ) ) ; }

BLEU: 73.72
Edit Sim: 6


Src: 
double arcLength ( double diameter , double angle ) { double pi = 22.0 / 7.0 ; double arc ; if ( angle >= 360 ) { cout << " Angle ▁ cannot " , " ▁ be ▁ formed " ; return 0 ; } else { arc = ( pi * diameter ) * ( angle / 360.0 ) ; return arc ; } }
Ref: 
function arcLength ( diameter , angle ) { let pi = 22.0 / 7.0 ; let arc ; if ( angle >= 360 ) { document . write ( " " + " " ) ; return 0 ; } else { arc = ( pi * diameter ) * ( angle / 360.0 ) ; return arc ; } }
Hyp: 
function arcLength ( diameter , angle ) { var pi = 22.0 / 7.0 ; var arc ; if ( angle >= 360 ) { document . write ( " " + " " ) ; return 0 ; } else { arc = ( pi * diameter ) * ( angle / 360.0 ) ; return arc ; } }

BLEU: 91.58
Edit Sim: 6


Src: 
void printRepeating ( int arr [ ] , int size ) { int i ; cout << " The ▁ repeating ▁ elements ▁ are " ; for ( i = 0 ; i < size ; i ++ ) { if ( arr [ abs ( arr [ i ] ) ] > 0 ) arr [ abs ( arr [ i ] ) ] = - arr [ abs ( arr [ i ] ) ] ; else cout << " ▁ " << abs ( arr [ i ] ) << " ▁ " ; } }
Ref: 
function printRepeating ( arr , size ) { var i ; document . write ( " " ) ; for ( i = 0 ; i < size ; i ++ ) { if ( arr [ Math . abs ( arr [ i ] ) ] > 0 ) arr [ Math . abs ( arr [ i ] ) ] = - arr [ Math . abs ( arr [ i ] ) ] ; else document . write ( Math . abs ( arr [ i ] ) + " " ) ; } }
Hyp: 
function printRepeating ( arr , size ) { let i ; document . write ( " " ) ; for ( i = 0 ; i < size ; i ++ ) { if ( arr [ Math . abs ( arr [ i ] ) ] > 0 ) arr [ Math . abs ( arr [ i ] ) ] = - arr [ Math . abs ( arr [ i ] ) ] ; else document . write ( " " + Math . abs ( arr [ i ] ) + " " ) ; } }

BLEU: 92.98
Edit Sim: 9


Src: 
bool isPerfectSquare ( long double x ) { if ( x >= 0 ) { long long sr = sqrt ( x ) ; return ( sr * sr == x ) ; } return false ; }
Ref: 
function isPerfectSquare ( x ) { if ( x >= 0 ) { let sr = Math . sqrt ( x ) ; return ( ( sr * sr ) == x ) ; } return false ; }
Hyp: 
function isPerfectSquare ( x ) { if ( x >= 0 ) { let sr = Math . sqrt ( x ) ; return ( sr * sr == x ) ; } return false ; }

BLEU: 88.59
Edit Sim: 4


Src: 
int countSeq ( int n ) { int nCr = 1 , res = 1 ; for ( int r = 1 ; r <= n ; r ++ ) { nCr = ( nCr * ( n + 1 - r ) ) / r ; res += nCr * nCr ; } return res ; }
Ref: 
function countSeq ( n ) { let nCr = 1 , res = 1 ; for ( let r = 1 ; r <= n ; r ++ ) { nCr = ( nCr * ( n + 1 - r ) ) / r ; res += nCr * nCr ; } return res ; }
Hyp: 
function countSeq ( n ) { let nCr = 1 , res = 1 ; for ( let r = 1 ; r <= n ; r ++ ) { nCr = ( nCr * ( n + 1 - r ) ) / r ; res += nCr * nCr ; } return res ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int maxArea ( int A [ ] , int len ) { int l = 0 ; int r = len - 1 ; int area = 0 ; while ( l < r ) { area = max ( area , min ( A [ l ] , A [ r ] ) * ( r - l ) ) ; if ( A [ l ] < A [ r ] ) l += 1 ; else r -= 1 ; } return area ; }
Ref: 
function maxArea ( A , len ) { let l = 0 ; let r = len - 1 ; let area = 0 ; while ( l < r ) { area = Math . max ( area , Math . min ( A [ l ] , A [ r ] ) * ( r - l ) ) ; if ( A [ l ] < A [ r ] ) l += 1 ; else r -= 1 ; } return area ; }
Hyp: 
function maxArea ( A , len ) { let l = 0 ; let r = len - 1 ; let area = 0 ; while ( l < r ) { area = Math . max ( area , Math . min ( A [ l ] , A [ r ] ) * ( r - l ) ) ; if ( A [ l ] < A [ r ] ) l += 1 ; else r -= 1 ; } return area ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int findPairCount ( int N , int K ) { int count = 0 ; int rem [ K ] ; rem [ 0 ] = N / K ; for ( int i = 1 ; i < K ; i ++ ) rem [ i ] = ( N - i ) / K + 1 ; if ( K % 2 == 0 ) { count += ( rem [ 0 ] * ( rem [ 0 ] - 1 ) ) / 2 ; for ( int i = 1 ; i < K / 2 ; i ++ ) count += rem [ i ] * rem [ K - i ] ; count += ( rem [ K / 2 ] * ( rem [ K / 2 ] - 1 ) ) / 2 ; } else { count += ( rem [ 0 ] * ( rem [ 0 ] - 1 ) ) / 2 ; for ( int i = 1 ; i <= K / 2 ; i ++ ) count += rem [ i ] * rem [ K - i ] ; } return count ; }
Ref: 
function findPairCount ( N , K ) { var count = 0 ; var rem = Array . from ( { length : K } , ( _ , i ) => 0 ) ; rem [ 0 ] = parseInt ( N / K ) ; for ( i = 1 ; i < K ; i ++ ) rem [ i ] = parseInt ( ( N - i ) / K + 1 ) ; if ( K % 2 == 0 ) { count += parseInt ( ( rem [ 0 ] * ( rem [ 0 ] - 1 ) ) / 2 ) ; for ( i = 1 ; i < K / 2 ; i ++ ) count += rem [ i ] * rem [ K - i ] ; count += ( rem [ K / 2 ] * ( rem [ K / 2 ] - 1 ) ) / 2 ; } else { count += ( rem [ 0 ] * ( rem [ 0 ] - 1 ) ) / 2 ; for ( i = 1 ; i <= K / 2 ; i ++ ) count += rem [ i ] * rem [ K - i ] ; } return count ; }
Hyp: 
function findPairCount ( N , K ) { let count = 0 ; let rem = new Array ( K ) ; rem [ 0 ] = N / K ; for ( let i = 1 ; i < K ; i ++ ) rem [ i ] = ( N - i ) / K + 1 ; if ( K % 2 == 0 ) { count += ( rem [ 0 ] * ( rem [ 0 ] - 1 ) ) / 2 ; for ( let i = 1 ; i < K / 2 ; i ++ ) count += rem [ i ] * rem [ K - i ] ; count += ( rem [ K / 2 ] * ( rem [ K / 2 ] - 1 ) ) / 2 ; } else { count += ( rem [ 0 ] * ( rem [ 0 ] - 1 ) ) / 2 ; for ( let i = 1 ; i <= K / 2 ; i ++ ) count += rem [ i ] * rem [ K - i ] ; } return count ; }

BLEU: 79.11
Edit Sim: 97


Src: 
int getMaxOnes ( int n , int x ) { int zeroes = ( n / x ) ; zeroes = zeroes * zeroes ; int total = n * n ; int ans = total - zeroes ; return ans ; }
Ref: 
function getMaxOnes ( n , x ) { let zeroes = parseInt ( n / x , 10 ) ; zeroes = zeroes * zeroes ; let total = n * n ; let ans = total - zeroes ; return ans ; }
Hyp: 
function getMaxOnes ( n , x ) { let zeroes = ( n / x ) ; zeroes = zeroes * zeroes ; let total = n * n ; let ans = total - zeroes ; return ans ; }

BLEU: 85.75
Edit Sim: 14


Src: 
int SquareCube ( long long int N ) { int cnt = 0 , i = 1 ; while ( int ( pow ( i , 6 ) ) <= N ) { ++ cnt ; ++ i ; } return cnt ; }
Ref: 
function SquareCube ( N ) { let cnt = 0 , i = 1 ; while ( Math . floor ( Math . pow ( i , 6 ) ) <= N ) { ++ cnt ; ++ i ; } return cnt ; }
Hyp: 
function SquareCube ( N ) { let cnt = 0 , i = 1 ; while ( Math . pow ( i , 6 ) ) <= N ) { ++ cnt ; ++ i ; } return cnt ; }

BLEU: 90.7
Edit Sim: 15


Src: 
void subtract ( int A [ ] [ N ] , int B [ ] [ N ] , int C [ ] [ N ] ) { int i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < N ; j ++ ) C [ i ] [ j ] = A [ i ] [ j ] - B [ i ] [ j ] ; }
Ref: 
function subtract ( A , B , C ) { var i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < N ; j ++ ) C [ i ] [ j ] = A [ i ] [ j ] - B [ i ] [ j ] ; } var A = [ [ 1 , 1 , 1 , 1 ] , [ 2 , 2 , 2 , 2 ] , [ 3 , 3 , 3 , 3 ] , [ 4 , 4 , 4 , 4 ] ] ; var B = [ [ 1 , 1 , 1 , 1 ] , [ 2 , 2 , 2 , 2 ] , [ 3 , 3 , 3 , 3 ] , [ 4 , 4 , 4 , 4 ] ] ; var C = Array . from ( Array ( N ) , ( ) => Array ( N ) ) ; var i , j ; subtract ( A , B , C ) ; document . write ( " " + " " ) ; for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < N ; j ++ ) document . write ( C [ i ] [ j ] + " " ) ; document . write ( " " ) ; }
Hyp: 
function subtract ( A , B , C ) { let i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < N ; j ++ ) C [ i ] [ j ] = A [ i ] [ j ] - B [ i ] [ j ] ; }

BLEU: 5.57
Edit Sim: 449


Src: 
int findPieces ( int n ) { return ( n * ( n + 1 ) ) / 2 + 1 ; }
Ref: 
function findPieces ( n ) { return ( n * ( n + 1 ) ) / 2 + 1 ; }
Hyp: 
function findPieces ( n ) { return ( n * ( n + 1 ) ) / 2 + 1 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int countSubStr ( string str , int len , int k ) { int count = 0 ; for ( int i = 0 ; i < len ; i ++ ) { int n = 0 ; for ( int j = i ; j < len ; j ++ ) { n = n * 10 + ( str [ j ] - '0' ) ; if ( n % k == 0 ) count ++ ; } } return count ; }
Ref: 
function countSubStr ( str , len , k ) { let count = 0 ; for ( let i = 0 ; i < len ; i ++ ) { let n = 0 ; for ( let j = i ; j < len ; j ++ ) { n = n * 10 + ( str [ j ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ) ; if ( n % k == 0 ) count ++ ; } } return count ; }
Hyp: 
function countSubStr ( str , len , k ) { let count = 0 ; for ( let i = 0 ; i < len ; i ++ ) { let n = 0 ; for ( let j = i ; j < len ; j ++ ) { n = n * 10 + ( str [ j ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ) ; if ( n % k == 0 ) count ++ ; } } return count ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int centered_cube ( int n ) { return ( 2 * n + 1 ) * ( n * n + n + 1 ) ; }
Ref: 
function centered_cube ( n ) { return ( 2 * n + 1 ) * ( n * n + n + 1 ) ; }
Hyp: 
function centered_cube ( n ) { return ( 2 * n + 1 ) * ( n * n + n + 1 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int squareSum ( int n ) { return 2 * n * ( n + 1 ) * ( 2 * n + 1 ) / 3 ; }
Ref: 
function squareSum ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) sum += ( 2 * i ) * ( 2 * i ) ; return sum ; }
Hyp: 
function squareSum ( n ) { return 2 * n * ( n + 1 ) * ( 2 * n + 1 ) / 3 ; }

BLEU: 22.34
Edit Sim: 60


Src: 
bool validQuadruple ( int arr [ ] , int n ) { if ( n >= MAX ) return true ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) for ( int k = j + 1 ; k < n ; k ++ ) for ( int l = k + 1 ; l < n ; l ++ ) { if ( ( arr [ i ] ^ arr [ j ] ^ arr [ k ] ^ arr [ l ] ) == 0 ) { return true ; } } return false ; }
Ref: 
function validQuadruple ( arr , n ) { if ( n >= MAX ) return true ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = i + 1 ; j < n ; j ++ ) for ( let k = j + 1 ; k < n ; k ++ ) for ( let l = k + 1 ; l < n ; l ++ ) { if ( ( arr [ i ] ^ arr [ j ] ^ arr [ k ] ^ arr [ l ] ) == 0 ) { return true ; } } return false ; }
Hyp: 
function validQuadruple ( arr , n ) { if ( n >= MAX ) return true ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = i + 1 ; j < n ; j ++ ) for ( let k = j + 1 ; k < n ; k ++ ) for ( let l = k + 1 ; l < n ; l ++ ) { if ( ( arr [ i ] ^ arr [ j ] ^ arr [ k ] ^ arr [ l ] ) == 0 ) { return true ; } } return false ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int minSumPath ( vector < vector < int > > & A ) { int memo [ A . size ( ) ] ; int n = A . size ( ) - 1 ; for ( int i = 0 ; i < A [ n ] . size ( ) ; i ++ ) memo [ i ] = A [ n ] [ i ] ; for ( int i = A . size ( ) - 2 ; i >= 0 ; i -- ) for ( int j = 0 ; j < A [ i ] . size ( ) ; j ++ ) memo [ j ] = A [ i ] [ j ] + min ( memo [ j ] , memo [ j + 1 ] ) ; return memo [ 0 ] ; }
Ref: 
function minSumPath ( ) { let memo = [ ] ; let n = A . length - 1 ; for ( let i = 0 ; i < A [ n ] . length ; i ++ ) memo [ i ] = A [ n ] [ i ] ; for ( let i = A . length - 2 ; i >= 0 ; i -- ) for ( let j = 0 ; j < A [ i ] . length ; j ++ ) memo [ j ] = A [ i ] [ j ] + Math . min ( memo [ j ] , memo [ j + 1 ] ) ; return memo [ 0 ] ; }
Hyp: 
function minSumPath ( A ) { let memo = new Array ( A . length ) ; let n = A . length - 1 ; for ( let i = 0 ; i < A [ n ] . size ; i ++ ) memo [ i ] = A [ n ] [ i ] ; for ( let i = A . size ( ) - 2 ; i >= 0 ; i -- ) for ( let j = 0 ; j < A [ i ] . size ; j ++ ) memo [ j ] = A [ i ] [ j ] + Math . min ( memo [ j ] , memo [ j + 1 ] ) ; return memo [ 0 ] ; }

BLEU: 85.23
Edit Sim: 44


Src: 
int countEvenSum ( int arr [ ] , int n ) { int result = 0 ; for ( int i = 0 ; i <= n - 1 ; i ++ ) { int sum = 0 ; for ( int j = i ; j <= n - 1 ; j ++ ) { sum = sum + arr [ j ] ; if ( sum % 2 == 0 ) result ++ ; } } return ( result ) ; }
Ref: 
function countEvenSum ( arr , n ) { let result = 0 ; for ( let i = 0 ; i <= n - 1 ; i ++ ) { let sum = 0 ; for ( let j = i ; j <= n - 1 ; j ++ ) { sum = sum + arr [ j ] ; if ( sum % 2 == 0 ) result ++ ; } } return ( result ) ; }
Hyp: 
function countEvenSum ( arr , n ) { let result = 0 ; for ( let i = 0 ; i <= n - 1 ; i ++ ) { let sum = 0 ; for ( let j = i ; j <= n - 1 ; j ++ ) { sum = sum + arr [ j ] ; if ( sum % 2 == 0 ) result ++ ; } } return ( result ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
bool check ( string s , int m ) { int l = s . length ( ) ; int c1 = 0 ; int c2 = 0 ; for ( int i = 0 ; i < l ; i ++ ) { if ( s [ i ] == '0' ) { c2 = 0 ; c1 ++ ; } else { c1 = 0 ; c2 ++ ; } if ( c1 == m c2 == m ) return true ; } return false ; }
Ref: 
function check ( s , m ) { let l = s . length ; let c1 = 0 ; let c2 = 0 ; for ( let i = 0 ; i < l ; i ++ ) { if ( s [ i ] == ' ' ) { c2 = 0 ; c1 ++ ; } else { c1 = 0 ; c2 ++ ; } if ( c1 == m c2 == m ) return true ; } return false ; }
Hyp: 
function check ( s , m ) { let l = s . length ; let c1 = 0 ; let c2 = 0 ; for ( let i = 0 ; i < l ; i ++ ) { if ( s [ i ] == ' ' ) { c2 = 0 ; c1 ++ ; } else { c1 = 0 ; c2 ++ ; } if ( c1 == m c2 == m ) return true ; } return false ; }

BLEU: 100.0
Edit Sim: 0


Src: 
void alter ( long long int x , long long int y ) { while ( true ) { if ( x == 0 y == 0 ) break ; if ( x >= 2 * y ) x = x % ( 2 * y ) ; else if ( y >= 2 * x ) y = y % ( 2 * x ) ; else break ; } cout << " X = " << x << " , ▁ " << " Y = " << y ; }
Ref: 
function alter ( x , y ) { while ( true ) { if ( x == 0 y == 0 ) break ; if ( x >= 2 * y ) x = x % ( 2 * y ) ; else if ( y >= 2 * x ) y = y % ( 2 * x ) ; else break ; } document . write ( " " + x + " " + " " + y ) ; }
Hyp: 
function alter ( x , y ) { while ( true ) { if ( x == 0 y == 0 ) break ; if ( x >= 2 * y ) x = x % ( 2 * y ) ; else if ( y >= 2 * x ) y = y % ( 2 * x ) ; else break ; } document . write ( " " + x + " " + y + " " ) ; }

BLEU: 96.33
Edit Sim: 4


Src: 
int swapBits ( unsigned int x , unsigned int p1 , unsigned int p2 , unsigned int n ) { unsigned int set1 = ( x >> p1 ) & ( ( 1U << n ) - 1 ) ; unsigned int set2 = ( x >> p2 ) & ( ( 1U << n ) - 1 ) ; unsigned int Xor = ( set1 ^ set2 ) ; Xor = ( Xor << p1 ) | ( Xor << p2 ) ; unsigned int result = x ^ Xor ; return result ; }
Ref: 
function swapBits ( x , p1 , p2 , n ) { let set1 = ( x >> p1 ) & ( ( 1 << n ) - 1 ) ; let set2 = ( x >> p2 ) & ( ( 1 << n ) - 1 ) ; let xor = ( set1 ^ set2 ) ; xor = ( xor << p1 ) | ( xor << p2 ) ; let result = x ^ xor ; return result ; }
Hyp: 
function swapBits ( x , p1 , p2 , n ) { var set1 = ( x >> p1 ) & ( ( 1U << n ) - 1 ) ; var set2 = ( x >> p2 ) & ( ( 1U << n ) - 1 ) ; var Xor = ( set1 ^ set2 ) ; Xor = ( Xor << p1 ) | ( Xor << p2 ) ; unsigned int result = x ^ Xor ; return result ; }

BLEU: 66.86
Edit Sim: 26


Src: 
int findSum ( int n ) { int arr [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) arr [ i ] [ j ] = abs ( i - j ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) sum += arr [ i ] [ j ] ; return sum ; }
Ref: 
function findSum ( n ) { let arr = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { arr [ i ] = new Array ( n ) ; for ( let j = 0 ; j < n ; j ++ ) { arr [ i ] [ j ] = 0 ; } } for ( let i = 0 ; i < n ; i ++ ) for ( let j = 0 ; j < n ; j ++ ) arr [ i ] [ j ] = Math . abs ( i - j ) ; let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = 0 ; j < n ; j ++ ) sum += arr [ i ] [ j ] ; return sum ; }
Hyp: 
function findSum ( n ) { let arr = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = 0 ; j < n ; j ++ ) arr [ i ] [ j ] = Math . abs ( i - j ) ; let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = 0 ; j < n ; j ++ ) sum += arr [ i ] [ j ] ; return sum ; }

BLEU: 60.94
Edit Sim: 126


Src: 
bool findTriplet ( int a1 [ ] , int a2 [ ] , int a3 [ ] , int n1 , int n2 , int n3 , int sum ) { for ( int i = 0 ; i < n1 ; i ++ ) for ( int j = 0 ; j < n2 ; j ++ ) for ( int k = 0 ; k < n3 ; k ++ ) if ( a1 [ i ] + a2 [ j ] + a3 [ k ] == sum ) return true ; return false ; }
Ref: 
function findTriplet ( a1 , a2 , a3 , n1 , n2 , n3 , sum ) { for ( var i = 0 ; i < n1 ; i ++ ) for ( var j = 0 ; j < n2 ; j ++ ) for ( var k = 0 ; k < n3 ; k ++ ) if ( a1 [ i ] + a2 [ j ] + a3 [ k ] == sum ) return true ; return false ; }
Hyp: 
function findTriplet ( a1 , a2 , a3 , n1 , n2 , n3 , sum ) { for ( let i = 0 ; i < n1 ; i ++ ) for ( let j = 0 ; j < n2 ; j ++ ) for ( let k = 0 ; k < n3 ; k ++ ) if ( a1 [ i ] + a2 [ j ] + a3 [ k ] == sum ) return true ; return false ; }

BLEU: 91.09
Edit Sim: 9


Src: 
int findLastIndex ( string & str , char x ) { for ( int i = str . length ( ) - 1 ; i >= 0 ; i -- ) if ( str [ i ] == x ) return i ; return -1 ; }
Ref: 
function findLastIndex ( str , x ) { for ( let i = str . length - 1 ; i >= 0 ; i -- ) if ( str [ i ] == x ) return i ; return - 1 ; }
Hyp: 
function findLastIndex ( str , x ) { for ( let i = str . length - 1 ; i >= 0 ; i -- ) if ( str [ i ] == x ) return i ; return - 1 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int factorial ( unsigned int n ) { if ( n == 0 ) return 1 ; return n * factorial ( n - 1 ) ; }
Ref: 
function factorial ( n ) { if ( n == 0 ) return 1 ; return n * factorial ( n - 1 ) ; }
Hyp: 
function factorial ( n ) { if ( n == 0 ) return 1 ; return n * factorial ( n - 1 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
bool isTriangular ( int num ) { if ( num < 0 ) return false ; int c = ( -2 * num ) ; int b = 1 , a = 1 ; int d = ( b * b ) - ( 4 * a * c ) ; if ( d < 0 ) return false ; float root1 = ( - b + sqrt ( d ) ) / ( 2 * a ) ; float root2 = ( - b - sqrt ( d ) ) / ( 2 * a ) ; if ( root1 > 0 && floor ( root1 ) == root1 ) return true ; if ( root2 > 0 && floor ( root2 ) == root2 ) return true ; return false ; }
Ref: 
function isTriangular ( num ) { if ( num < 0 ) return false ; var c = ( - 2 * num ) ; var b = 1 , a = 1 ; var d = ( b * b ) - ( 4 * a * c ) ; if ( d < 0 ) return false ; var root1 = ( - b + Math . sqrt ( d ) ) / ( 2 * a ) ; var root2 = ( - b - Math . sqrt ( d ) ) / ( 2 * a ) ; if ( root1 > 0 && Math . floor ( root1 ) == root1 ) return true ; if ( root2 > 0 && Math . floor ( root2 ) == root2 ) return true ; return false ; }
Hyp: 
function isTriangular ( num ) { if ( num < 0 ) return false ; let c = ( - 2 * num ) ; let b = 1 , a = 1 ; let d = ( b * b ) - ( 4 * a * c ) ; if ( d < 0 ) return false ; let root1 = ( - b + Math . sqrt ( d ) ) / ( 2 * a ) ; let root2 = ( - b - Math . sqrt ( d ) ) / ( 2 * a ) ; if ( root1 > 0 && Math . floor ( root1 ) == root1 ) return true ; if ( root2 > 0 && Math . floor ( root2 ) == root2 ) return true ; return false ; }

BLEU: 91.05
Edit Sim: 15


Src: 
int numberOfCuts ( int M , int N ) { int result = 0 ; result = ( M - 1 ) * ( N - 1 ) ; return result ; }
Ref: 
function numberOfCuts ( M , N ) { var result = 0 ; result = ( M - 1 ) * ( N - 1 ) ; return result ; }
Hyp: 
function numberOfCuts ( M , N ) { let result = 0 ; result = ( M - 1 ) * ( N - 1 ) ; return result ; }

BLEU: 91.57
Edit Sim: 3


Src: 
void BalanceArray ( vector < int > & A , vector < vector < int > > & Q ) { vector < int > ANS ; int i , sum = 0 ; for ( i = 0 ; i < A . size ( ) ; i ++ ) if ( A [ i ] % 2 == 0 ) sum = sum + A [ i ] ; for ( i = 0 ; i < Q . size ( ) ; i ++ ) { int index = Q [ i ] [ 0 ] ; int value = Q [ i ] [ 1 ] ; if ( A [ index ] % 2 == 0 ) sum = sum - A [ index ] ; A [ index ] = A [ index ] + value ; if ( A [ index ] % 2 == 0 ) sum = sum + A [ index ] ; ANS . push_back ( sum ) ; } for ( i = 0 ; i < ANS . size ( ) ; i ++ ) cout << ANS [ i ] << " ▁ " ; }
Ref: 
function BalanceArray ( A , Q ) { var ANS = [ ] ; var i , sum = 0 ; for ( i = 0 ; i < A . length ; i ++ ) if ( A [ i ] % 2 == 0 ) sum = sum + A [ i ] ; for ( i = 0 ; i < Q . length ; i ++ ) { var index = Q [ i ] [ 0 ] ; var value = Q [ i ] [ 1 ] ; if ( A [ index ] % 2 == 0 ) sum = sum - A [ index ] ; A [ index ] = A [ index ] + value ; if ( A [ index ] % 2 == 0 ) sum = sum + A [ index ] ; ANS . push ( sum ) ; } for ( i = 0 ; i < ANS . length ; i ++ ) document . write ( ANS [ i ] + " " ) ; }
Hyp: 
function BalanceArray ( A , Q ) { let ANS = [ ] ; let i , sum = 0 ; for ( i = 0 ; i < A . length ; i ++ ) if ( A [ i ] % 2 == 0 ) sum = sum + A [ i ] ; for ( i = 0 ; i < Q . length ; i ++ ) { let index = Q [ i ] [ 0 ] ; let value = Q [ i ] [ 1 ] ; if ( A [ index ] % 2 == 0 ) sum = sum - A [ index ] ; A [ index ] = A [ index ] + value ; if ( A [ index ] % 2 == 0 ) sum = sum + A [ index ] ; ANS . push ( sum ) ; } for ( i = 0 ; i < ANS . length ; i ++ ) document . write ( ANS [ i ] + " " ) ; }

BLEU: 94.47
Edit Sim: 12


Src: 
ll countMaxIntersect ( ll n ) { return ( n ) * ( n - 1 ) / 2 ; }
Ref: 
function countMaxIntersect ( n ) { return ( n ) * ( n - 1 ) / 2 ; }
Hyp: 
function countMaxIntersect ( n ) { return ( n ) * ( n - 1 ) / 2 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
long findDigits ( int n ) { if ( n < 0 ) return 0 ; if ( n <= 1 ) return 1 ; double x = ( ( n * log10 ( n / M_E ) + log10 ( 2 * M_PI * n ) / 2.0 ) ) ; return floor ( x ) + 1 ; }
Ref: 
function findDigits ( n ) { if ( n < 0 ) return 0 ; if ( n <= 1 ) return 1 ; let x = ( ( n * Math . log10 ( n / Math . E ) + Math . log10 ( 2 * Math . PI * n ) / 2.0 ) ) ; return Math . floor ( x ) + 1 ; }
Hyp: 
function findDigits ( n ) { if ( n < 0 ) return 0 ; if ( n <= 1 ) return 1 ; let x = ( ( n * Math . log10 ( n / M_E ) + Math . log10 ( 2 * M_PI * n ) / 2.0 ) ) ; return Math . floor ( x ) + 1 ; }

BLEU: 86.81
Edit Sim: 12


Src: 
int nthTerm ( int n ) { return 2 * pow ( n , 2 ) + 3 * n - 5 ; }
Ref: 
function nthTerm ( n ) { return 2 * Math . pow ( n , 2 ) + 3 * n - 5 ; }
Hyp: 
function nthTerm ( n ) { return 2 * Math . pow ( n , 2 ) + 3 * n - 5 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
void findTriplets ( int arr [ ] , int n , int sum ) { for ( int i = 0 ; i < n - 2 ; i ++ ) { for ( int j = i + 1 ; j < n - 1 ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) { if ( arr [ i ] + arr [ j ] + arr [ k ] == sum ) { cout << arr [ i ] << " ▁ " << arr [ j ] << " ▁ " << arr [ k ] << endl ; } } } } }
Ref: 
function findTriplets ( arr , n , sum ) { for ( let i = 0 ; i < n - 2 ; i ++ ) { for ( let j = i + 1 ; j < n - 1 ; j ++ ) { for ( let k = j + 1 ; k < n ; k ++ ) { if ( arr [ i ] + arr [ j ] + arr [ k ] == sum ) { document . write ( arr [ i ] + " " + arr [ j ] + " " + arr [ k ] + " " ) ; } } } } }
Hyp: 
function findTriplets ( arr , n , sum ) { for ( let i = 0 ; i < n - 2 ; i ++ ) { for ( let j = i + 1 ; j < n - 1 ; j ++ ) { for ( let k = j + 1 ; k < n ; k ++ ) { if ( arr [ i ] + arr [ j ] + arr [ k ] == sum ) { document . write ( arr [ i ] + " " + arr [ j ] + " " + arr [ k ] + " " ) ; } } } }

BLEU: 99.14
Edit Sim: 2


Src: 
void equation_plane ( int x1 , int y1 , int z1 , int x2 , int y2 , int z2 , int x3 , int y3 , int z3 , int x , int y , int z ) { int a1 = x2 - x1 ; int b1 = y2 - y1 ; int c1 = z2 - z1 ; int a2 = x3 - x1 ; int b2 = y3 - y1 ; int c2 = z3 - z1 ; int a = b1 * c2 - b2 * c1 ; int b = a2 * c1 - a1 * c2 ; int c = a1 * b2 - b1 * a2 ; int d = ( - a * x1 - b * y1 - c * z1 ) ; if ( a * x + b * y + c * z + d == 0 ) cout << " Coplanar " << endl ; else cout << " Not ▁ Coplanar " << endl ; }
Ref: 
function equation_plane ( x1 , y1 , z1 , x2 , y2 , z2 , x3 , y3 , z3 , x , y , z ) { var a1 = x2 - x1 ; var b1 = y2 - y1 ; var c1 = z2 - z1 ; var a2 = x3 - x1 ; var b2 = y3 - y1 ; var c2 = z3 - z1 ; var a = b1 * c2 - b2 * c1 ; var b = a2 * c1 - a1 * c2 ; var c = a1 * b2 - b1 * a2 ; var d = ( - a * x1 - b * y1 - c * z1 ) ; if ( a * x + b * y + c * z + d == 0 ) document . write ( " " ) ; else document . write ( " " ) ; }
Hyp: 
function equation_plane ( x1 , y1 , z1 , x2 , y2 , z2 , x3 , y3 , z3 , x , y , z ) { var a1 = x2 - x1 ; var b1 = y2 - y1 ; var c1 = z2 - z1 ; var a2 = x3 - x1 ; var b2 = y3 - y1 ; var c2 = z3 - z1 ; var d = ( - a * x1 - b * y1 - c * z1 ) ; if ( a * x + b * y + c * z + d == 0 ) document . write ( " " ) ; else document . write ( " " ) ; }

BLEU: 76.48
Edit Sim: 84


Src: 
void printNSE ( int arr [ ] , int n ) { int next , i , j ; for ( i = 0 ; i < n ; i ++ ) { next = -1 ; for ( j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] > arr [ j ] ) { next = arr [ j ] ; break ; } } cout << arr [ i ] << " ▁ - - ▁ " << next << endl ; } }
Ref: 
function printNSE ( arr , n ) { var next , i , j ; for ( i = 0 ; i < n ; i ++ ) { next = - 1 ; for ( j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] > arr [ j ] ) { next = arr [ j ] ; break ; } } document . write ( arr [ i ] + " " + next + " " ) ; } }
Hyp: 
function printNSE ( arr , n ) { let next , i , j ; for ( i = 0 ; i < n ; i ++ ) { next = - 1 ; for ( j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] > arr [ j ] ) { next = arr [ j ] ; break ; } } document . write ( arr [ i ] + " " + next + " " ) ; } }

BLEU: 97.3
Edit Sim: 3


Src: 
void NicomachuTheorum_sum ( int n ) { int sum = 0 ; for ( int k = 1 ; k <= n ; k ++ ) sum += k * k * k ; int triNo = n * ( n + 1 ) / 2 ; if ( sum == triNo * triNo ) cout << " Yes " ; else cout << " No " ; }
Ref: 
function NicomachuTheorum_sum ( n ) { let sum = 0 ; for ( let k = 1 ; k <= n ; k ++ ) sum += k * k * k ; let triNo = n * ( n + 1 ) / 2 ; if ( sum == triNo * triNo ) document . write ( " " ) ; else document . write ( " " ) ; }
Hyp: 
function NicomachuTheorum_sum ( n ) { let sum = 0 ; for ( let k = 1 ; k <= n ; k ++ ) sum += k * k * k ; let triNo = n * ( n + 1 ) / 2 ; if ( sum == triNo * triNo ) document . write ( " " ) ; else document . write ( " " ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int largestNum ( int a , int b ) { return a * ( bool ) ( a / b ) + b * ( bool ) ( b / a ) ; }
Ref: 
function largestNum ( a , b ) { return a * ( parseInt ( a / b ) > 0 ? 1 : 0 ) + b * ( parseInt ( b / a ) > 0 ? 1 : 0 ) ; }
Hyp: 
function largestNum ( a , b ) { return a * ( bool ) ( a / b ) + b * ( bool ) ( b / a ) ; }

BLEU: 49.8
Edit Sim: 44


Src: 
long answer ( long long n ) { long m = 2 ; long long ans = 1 ; long long r = 1 ; while ( r < n ) { r = ( int ) ( pow ( 2 , m ) - 1 ) * ( pow ( 2 , m - 1 ) ) ; if ( r < n ) ans = r ; m ++ ; } return ans ; }
Ref: 
function answer ( n ) { let m = 2 ; let ans = 1 ; let r = 1 ; while ( r < n ) { r = ( Math . pow ( 2 , m ) - 1 ) * ( Math . pow ( 2 , m - 1 ) ) ; if ( r < n ) ans = r ; m ++ ; } return ans ; }
Hyp: 
function answer ( n ) { let m = 2 ; let ans = 1 ; let r = 1 ; while ( r < n ) { r = ( int ) ( Math . pow ( 2 , m ) - 1 ) * ( Math . pow ( 2 , m - 1 ) ) ; if ( r < n ) ans = r ; m ++ ; } return ans ; }

BLEU: 95.07
Edit Sim: 8


Src: 
int nthTerm ( int n ) { return 3 * pow ( n , 2 ) - 4 * n + 2 ; }
Ref: 
function nthTerm ( n ) { return 3 * Math . pow ( n , 2 ) - 4 * n + 2 ; }
Hyp: 
function nthTerm ( n ) { return 3 * Math . pow ( n , 2 ) - 4 * n + 2 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
float circle_inscribed ( int a ) { return PI * ( a * a ) / 12 ; }
Ref: 
function circle_inscribed ( a ) { return PI * ( a * a ) / 12 ; }
Hyp: 
function circle_inscribed ( a ) { return PI * ( a * a ) / 12 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int maxLevel ( int boxes [ ] , int n ) { sort ( boxes , boxes + n ) ; int prev_width = boxes [ 0 ] ; int prev_count = 1 ; int curr_count = 0 ; int curr_width = 0 ; for ( int i = 1 ; i < n ; i ++ ) { curr_width += boxes [ i ] ; curr_count += 1 ; if ( curr_width > prev_width && curr_count > prev_count ) { prev_width = curr_width ; prev_count = curr_count ; curr_count = 0 ; curr_width = 0 ; ans ++ ; } } return ans ; }
Ref: 
function maxLevel ( boxes , n ) { boxes . sort ( ) ; let prev_width = boxes [ 0 ] ; let prev_count = 1 ; let curr_count = 0 ; let curr_width = 0 ; for ( let i = 1 ; i < n ; i ++ ) { curr_width += boxes [ i ] ; curr_count += 1 ; if ( curr_width > prev_width && curr_count > prev_count ) { prev_width = curr_width ; prev_count = curr_count ; curr_count = 0 ; curr_width = 0 ; ans ++ ; } } return ans ; }
Hyp: 
function maxLevel ( boxes , n ) { boxes . sort ( ( a , b ) => a - b ) ; let prev_width = boxes [ 0 ] ; let prev_count = 1 ; let curr_count = 0 ; let curr_width = 0 ; for ( let i = 1 ; i < n ; i ++ ) { curr_width += boxes [ i ] ; curr_count += 1 ; if ( curr_width > prev_width && curr_count > prev_count ) { prev_width = curr_width ; prev_count = curr_count ; curr_count = 0 ; curr_width = 0 ; ans ++ ; } } return ans ; }

BLEU: 90.21
Edit Sim: 19


Src: 
int cost ( int a [ ] , int n ) { return ( n - 1 ) * ( * min_element ( a , a + n ) ) ; }
Ref: 
function cost ( a , n ) { let min = a [ 0 ] ; for ( let i = 1 ; i < a . length ; i ++ ) { if ( a [ i ] < min ) min = a [ i ] ; } return ( n - 1 ) * min ; }
Hyp: 
function cost ( a , n ) { return ( n - 1 ) * ( * Math . min ( a , a + n ) ) ; }

BLEU: 18.65
Edit Sim: 93


Src: 
int countValues ( int x ) { int count = 0 , n = 1 ; while ( x != 0 ) { if ( x % 2 == 0 ) count += n ; n *= 2 ; x /= 2 ; } return count ; }
Ref: 
function countValues ( x ) { var count = 0 , n = 1 ; while ( x != 0 ) { if ( x % 2 == 0 ) count += n ; n *= 2 ; x = parseInt ( x / 2 ) ; } return count ; }
Hyp: 
function countValues ( x ) { let count = 0 , n = 1 ; while ( x != 0 ) { if ( x % 2 == 0 ) count += n ; n *= 2 ; x = parseInt ( x / 2 ) ; } return count ; }

BLEU: 95.07
Edit Sim: 3


Src: 
int nthTerm ( int n ) { return 2 * pow ( n , 2 ) - n - 1 ; }
Ref: 
function nthTerm ( n ) { return 2 * Math . pow ( n , 2 ) - n - 1 ; }
Hyp: 
function nthTerm ( n ) { return 2 * Math . pow ( n , 2 ) - n - 1 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
char stringPalindrome ( string A , string B ) { int countA [ MAX_CHAR ] = { 0 } ; int countB [ MAX_CHAR ] = { 0 } ; int l1 = A . length ( ) , l2 = B . length ( ) ; for ( int i = 0 ; i < l1 ; i ++ ) countA [ A [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < l2 ; i ++ ) countB [ B [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < 26 ; i ++ ) if ( ( countA [ i ] > 1 && countB [ i ] == 0 ) ) return ' A ' ; return ' B ' ; }
Ref: 
function stringPalindrome ( A , B ) { var countA = Array . from ( { length : MAX_CHAR } , ( _ , i ) => 0 ) ; var countB = Array . from ( { length : MAX_CHAR } , ( _ , i ) => 0 ) ; var l1 = A . length ; var l2 = B . length ; for ( var i = 0 ; i < l1 ; i ++ ) countA [ A . charAt ( i ) . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; for ( var i = 0 ; i < l2 ; i ++ ) countB [ B . charAt ( i ) . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; for ( var i = 0 ; i < 26 ; i ++ ) if ( ( countA [ i ] > 1 && countB [ i ] == 0 ) ) return ' ' ; return ' ' ; }
Hyp: 
function stringPalindrome ( A , B ) { var countA = new Array ( MAX_CHAR ) . fill ( 0 ) ; var countB = new Array ( MAX_CHAR ) . fill ( 0 ) ; for ( var i = 0 ; i < l1 ; i ++ ) countA [ A [ i ] . charCodeAt ( 0 ) - " " . charCodeAt ( 0 ) ] ++ ; for ( var i = 0 ; i < l2 ; i ++ ) countB [ B [ i ] . charCodeAt ( 0 ) - " " . charCodeAt ( 0 ) ] ++ ; for ( var i = 0 ; i < 26 ; i ++ ) if ( ( countA [ i ] > 1 && countB [ i ] == 0 ) ) return ' ' ; return ' ' ; }

BLEU: 62.16
Edit Sim: 136


Src: 
int countOdd ( int L , int R ) { int N = ( R - L ) / 2 ; if ( R % 2 != 0 L % 2 != 0 ) N += 1 ; return N ; }
Ref: 
function countOdd ( L , R ) { let N = Math . floor ( ( R - L ) / 2 ) ; if ( R % 2 != 0 L % 2 != 0 ) N += 1 ; return N ; }
Hyp: 
function countOdd ( L , R ) { let N = ( R - L ) / 2 ; if ( R % 2 != 0 L % 2 != 0 ) N += 1 ; return N ; }

BLEU: 81.23
Edit Sim: 17


Src: 
double findSum ( ll n ) { return sqrt ( 3 ) * ( n * ( n + 1 ) / 2 ) ; }
Ref: 
function findSum ( n ) { return Math . sqrt ( 3 ) * ( n * ( n + 1 ) / 2 ) ; }
Hyp: 
function findSum ( n ) { return Math . sqrt ( 3 ) * ( n * ( n + 1 ) / 2 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int kthdigit ( int a , int b , int k ) { int p = pow ( a , b ) ; int count = 0 ; while ( p > 0 && count < k ) { int rem = p % 10 ; count ++ ; if ( count == k ) return rem ; p = p / 10 ; } return 0 ; }
Ref: 
function kthdigit ( a , b , k ) { let p = Math . pow ( a , b ) ; let count = 0 ; while ( p > 0 && count < k ) { let rem = p % 10 ; count ++ ; if ( count == k ) return rem ; p = p / 10 ; } return 0 ; }
Hyp: 
function kthdigit ( a , b , k ) { let p = Math . pow ( a , b ) ; let count = 0 ; while ( p > 0 && count < k ) { let rem = p % 10 ; count ++ ; if ( count == k ) return rem ; p = Math . floor ( p / 10 ) ; } return 0 ; }

BLEU: 88.86
Edit Sim: 17


Src: 
int centeredNonagonal ( int n ) { return ( 3 * n - 2 ) * ( 3 * n - 1 ) / 2 ; }
Ref: 
function centeredNonagonal ( n ) { return parseInt ( ( 3 * n - 2 ) * ( 3 * n - 1 ) / 2 ) ; }
Hyp: 
function centeredNonagonal ( n ) { return ( 3 * n - 2 ) * ( 3 * n - 1 ) / 2 ; }

BLEU: 78.87
Edit Sim: 13


Src: 
int pentagon_pyramidal ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int p = ( 3 * i * i - i ) / 2 ; sum = sum + p ; } return sum ; }
Ref: 
function pentagon_pyramidal ( n ) { var sum = 0 ; for ( i = 1 ; i <= n ; i ++ ) { var p = ( 3 * i * i - i ) / 2 ; sum = sum + p ; } return sum ; }
Hyp: 
function pentagon_pyramidal ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { let p = ( 3 * i * i - i ) / 2 ; sum = sum + p ; } return sum ; }

BLEU: 85.01
Edit Sim: 10


Src: 
int evenbitsetnumber ( int n ) { int count = 0 , res = 0 ; for ( int temp = n ; temp > 0 ; temp >>= 1 ) { if ( count % 2 == 1 ) res |= ( 1 << count ) ; count ++ ; } return ( n res ) ; }
Ref: 
function evenbitsetnumber ( n ) { let count = 0 , res = 0 ; for ( let temp = n ; temp > 0 ; temp >>= 1 ) { if ( count % 2 == 1 ) res |= ( 1 << count ) ; count ++ ; } return ( n res ) ; }
Hyp: 
function evenbitsetnumber ( n ) { var count = 0 , res = 0 ; for ( var temp = n ; temp > 0 ; temp >>= 1 ) { if ( count % 2 == 1 ) res |= ( 1 << count ) ; count ++ ; } return ( n res ) ; }

BLEU: 91.13
Edit Sim: 6


Src: 
bool isValid ( string str , int len ) { for ( int i = 1 ; i < len ; i ++ ) { if ( str [ i ] == str [ i - 1 ] ) return false ; } return true ; }
Ref: 
function isValid ( str , len ) { for ( let i = 1 ; i < len ; i ++ ) { if ( str [ i ] == str [ i - 1 ] ) return false ; } return true ; }
Hyp: 
function isValid ( str , len ) { for ( let i = 1 ; i < len ; i ++ ) { if ( str [ i ] == str [ i - 1 ] ) return false ; } return true ; }

BLEU: 100.0
Edit Sim: 0


Src: 
bool checkArray ( int arr [ ] , int n ) { return ( arr [ 0 ] % 2 ) && ( arr [ n - 1 ] % 2 ) && ( n % 2 ) ; }
Ref: 
function checkArray ( arr , n ) { return ( ( arr [ 0 ] % 2 ) > 0 && ( arr [ n - 1 ] % 2 ) > 0 && ( n % 2 ) > 0 ) ? 1 : 0 ; }
Hyp: 
function checkArray ( arr , n ) { return ( arr [ 0 ] % 2 ) && ( arr [ n - 1 ] % 2 ) && ( n % 2 ) ; }

BLEU: 60.78
Edit Sim: 24


Src: 
long term ( int n ) { int d = 2 ; int a1 = 0 ; int An = a1 + ( n - 1 ) * d ; An = pow ( An , 3 ) ; return An ; }
Ref: 
function term ( n ) { let d = 2 ; let a1 = 0 ; An = a1 + ( n - 1 ) * d ; return Math . pow ( An , 3 ) ; }
Hyp: 
function term ( n ) { let d = 2 ; let a1 = 0 ; let An = a1 + ( n - 1 ) * d ; An = Math . pow ( An , 3 ) ; return An ; }

BLEU: 79.86
Edit Sim: 22


Src: 
int findTwoThreePrime ( int l , int r ) { if ( l == 1 ) l ++ ; int count = 0 ; for ( int i = l ; i <= r ; i ++ ) { int num = i ; while ( num % 2 == 0 ) num /= 2 ; while ( num % 3 == 0 ) num /= 3 ; if ( num == 1 ) count ++ ; } return count ; }
Ref: 
function findTwoThreePrime ( l , r ) { if ( l == 1 ) l ++ ; let count = 0 ; for ( let i = l ; i <= r ; i ++ ) { let num = i ; while ( num % 2 == 0 ) num = parseInt ( num / 2 , 10 ) ; while ( num % 3 == 0 ) num = parseInt ( num / 3 , 10 ) ; if ( num == 1 ) count ++ ; } return count ; }
Hyp: 
function findTwoThreePrime ( l , r ) { if ( l == 1 ) l ++ ; let count = 0 ; for ( let i = l ; i <= r ; i ++ ) { let num = i ; while ( num % 2 == 0 ) num /= 2 ; while ( num % 3 == 0 ) num /= 3 ; if ( num == 1 ) count ++ ; } return count ; }

BLEU: 76.97
Edit Sim: 50


Src: 
bool checkForSorting ( int arr [ ] , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] > arr [ i + 1 ] ) { if ( arr [ i ] - arr [ i + 1 ] == 1 ) swap ( arr [ i ] , arr [ i + 1 ] ) ; else return false ; } } return true ; }
Ref: 
function checkForSorting ( arr , n ) { let temp = 0 ; for ( let i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] > arr [ i + 1 ] ) { if ( arr [ i ] - arr [ i + 1 ] == 1 ) { temp = arr [ i ] ; arr [ i ] = arr [ i + 1 ] ; arr [ i + 1 ] = temp ; } else return false ; } } return true ; }
Hyp: 
function checkForSorting ( arr , n ) { for ( let i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] > arr [ i + 1 ] ) { if ( arr [ i ] - arr [ i + 1 ] == 1 ) swap ( arr [ i ] , arr [ i + 1 ] ) ; else return false ; } } return true ; }

BLEU: 67.45
Edit Sim: 58


Src: 
int multiplyTen ( int n ) { return ( n << 1 ) + ( n << 3 ) ; }
Ref: 
function multiplyTen ( n ) { return ( n << 1 ) + ( n << 3 ) ; }
Hyp: 
function multiplyTen ( n ) { return ( n << 1 ) + ( n << 3 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int slopeOfNum ( string num , int n ) { int slope = 0 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( num [ i ] > num [ i - 1 ] && num [ i ] > num [ i + 1 ] ) slope ++ ; else if ( num [ i ] < num [ i - 1 ] && num [ i ] < num [ i + 1 ] ) slope ++ ; } return slope ; }
Ref: 
function slopeOfNum ( num , n ) { let slope = 0 ; for ( let i = 1 ; i < n - 1 ; i ++ ) { if ( num [ i ] > num [ i - 1 ] && num [ i ] > num [ i + 1 ] ) slope ++ ; else if ( num [ i ] < num [ i - 1 ] && num [ i ] < num [ i + 1 ] ) slope ++ ; } return slope ; }
Hyp: 
function slopeOfNum ( num , n ) { let slope = 0 ; for ( let i = 1 ; i < n - 1 ; i ++ ) { if ( num [ i ] > num [ i - 1 ] && num [ i ] > num [ i + 1 ] ) slope ++ ; else if ( num [ i ] < num [ i - 1 ] && num [ i ] < num [ i + 1 ] ) slope ++ ; } return slope ; }

BLEU: 100.0
Edit Sim: 0


Src: 
long findAnswer ( int n , vector < int > & arr ) { sort ( arr . begin ( ) , arr . end ( ) ) ; unsigned long long sum = 0 ; for ( int i = 0 ; i < n / 2 ; ++ i ) { sum += ( arr [ i ] + arr [ n - i - 1 ] ) * ( arr [ i ] + arr [ n - i - 1 ] ) ; } return sum ; }
Ref: 
function findAnswer ( n , arr ) { arr . sort ( ( a , b ) => a - b ) ; let sum = 0 ; for ( let i = 0 ; i < Math . floor ( n / 2 ) ; ++ i ) { sum += ( arr [ i ] + arr [ n - i - 1 ] ) * ( arr [ i ] + arr [ n - i - 1 ] ) ; } return sum ; }
Hyp: 
function findAnswer ( n , arr ) { arr . sort ( function ( a , b ) { return a - b ; } ) ; let sum = 0 ; for ( let i = 0 ; i < parseInt ( n / 2 , 10 ) ; ++ i ) { sum += ( arr [ i ] + arr [ n - i - 1 ] ) * ( arr [ i ] + arr [ n - i - 1 ] ) ; } return sum ; }

BLEU: 82.93
Edit Sim: 37


Src: 
int getIndexInSortedArray ( int arr [ ] , int n , int idx ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ idx ] ) result ++ ; if ( arr [ i ] == arr [ idx ] && i < idx ) result ++ ; } return result ; }
Ref: 
function getIndexInSortedArray ( arr , n , idx ) { let result = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ idx ] ) result ++ ; if ( arr [ i ] == arr [ idx ] && i < idx ) result ++ ; } return result ; }
Hyp: 
function getIndexInSortedArray ( arr , n , idx ) { let result = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ idx ] ) result ++ ; if ( arr [ i ] == arr [ idx ] && i < idx ) result ++ ; } return result ; }

BLEU: 100.0
Edit Sim: 0


Src: 
bool isValidNesbitt ( double a , double b , double c ) { double A = a / ( b + c ) ; double B = b / ( a + c ) ; double C = c / ( a + b ) ; double inequality = A + B + C ; return ( inequality >= 1.5 ) ; }
Ref: 
function isValidNesbitt ( a , b , c ) { let A = a / ( b + c ) ; let B = b / ( a + c ) ; let C = c / ( a + b ) ; let inequality = A + B + C ; return ( inequality >= 1.5 ) ; } let a = 1.0 , b = 2.0 , c = 3.0 ; if ( isValidNesbitt ( a , b , c ) == true ) { document . write ( " " + " " ) ; document . write ( " " + a + " " + b + " " + c ) ; }
Hyp: 
function isValidNesbitt ( a , b , c ) { let A = a / ( b + c ) ; let B = b / ( a + c ) ; let C = c / ( a + b ) ; let inequality = A + B + C ; return ( inequality >= 1.5 ) ; }

BLEU: 37.41
Edit Sim: 166


Src: 
void binToDecimal3 ( int n ) { int last_3 = ( ( n & 4 ) + ( n & 2 ) + ( n & 1 ) ) ; n = n >> 3 ; while ( n > 7 ) n = n >> 1 ; int first_3 = ( ( n & 4 ) + ( n & 2 ) + ( n & 1 ) ) ; cout << first_3 << " ▁ " << last_3 ; }
Ref: 
function binToDecimal3 ( n ) { var last_3 = ( ( n & 4 ) + ( n & 2 ) + ( n & 1 ) ) ; n = n >> 3 ; while ( n > 7 ) n = n >> 1 ; var first_3 = ( ( n & 4 ) + ( n & 2 ) + ( n & 1 ) ) ; document . write ( first_3 + " " + last_3 ) ; }
Hyp: 
function binToDecimal3 ( n ) { let last_3 = parseInt ( ( n & 4 ) + ( n & 2 ) + ( n & 1 ) ) ; n = n >> 3 ; while ( n > 7 ) n = n >> 1 ; let first_3 = parseInt ( ( n & 4 ) + ( n & 2 ) + ( n & 1 ) ) ; document . write ( first_3 + " " + last_3 ) ; }

BLEU: 88.57
Edit Sim: 24


Src: 
int KthMinValAfterMconcatenate ( int A [ ] , int N , int M , int K ) { sort ( A , A + N ) ; return ( A [ ( ( K - 1 ) / M ) ] ) ; }
Ref: 
function KthMinValAfterMconcatenate ( A , N , M , K ) { A . sort ( ( a , b ) => a - b ) return ( A [ ( ( K - 1 ) / M ) ] ) ; }
Hyp: 
function KthMinValAfterMconcatenate ( A , N , M , K ) { A . sort ( ( ( K - 1 ) / M ) ) ; return ( A [ parseInt ( ( ( K - 1 ) / M ) ] ) ; }

BLEU: 68.03
Edit Sim: 22


Src: 
bool isPrime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i < n ; i ++ ) if ( n % i == 0 ) return false ; return true ; }
Ref: 
function isPrime ( n ) { if ( n <= 1 ) return false ; for ( let i = 2 ; i < n ; i ++ ) if ( n % i == 0 ) return false ; return true ; }
Hyp: 
function isPrime ( n ) { if ( n <= 1 ) return false ; for ( let i = 2 ; i < n ; i ++ ) if ( n % i == 0 ) return false ; return true ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int minRemove ( int arr [ ] , int n ) { int LIS [ n ] , len = 0 ; for ( int i = 0 ; i < n ; i ++ ) LIS [ i ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ i ] > arr [ j ] && ( i - j ) <= ( arr [ i ] - arr [ j ] ) ) { LIS [ i ] = max ( LIS [ i ] , LIS [ j ] + 1 ) ; } } len = max ( len , LIS [ i ] ) ; } return n - len ; }
Ref: 
function minRemove ( arr , n ) { let LIS = new Array ( n ) . fill ( 0 ) ; let len = 0 ; for ( let i = 0 ; i < n ; i ++ ) LIS [ i ] = 1 ; for ( let i = 1 ; i < n ; i ++ ) { for ( let j = 0 ; j < i ; j ++ ) { if ( arr [ i ] > arr [ j ] && ( i - j ) <= ( arr [ i ] - arr [ j ] ) ) LIS [ i ] = Math . max ( LIS [ i ] , LIS [ j ] + 1 ) ; } len = Math . max ( len , LIS [ i ] ) ; } return n - len ; }
Hyp: 
function minRemove ( arr , n ) { let LIS = new Array ( n ) , len = 0 ; for ( let i = 0 ; i < n ; i ++ ) LIS [ i ] = 1 ; for ( let i = 1 ; i < n ; i ++ ) { for ( let j = 0 ; j < i ; j ++ ) { if ( arr [ i ] > arr [ j ] && ( i - j ) <= ( arr [ i ] - arr [ j ] ) ) { LIS [ i ] = Math . max ( LIS [ i ] , LIS [ j ] + 1 ) ; } } len = Math . max ( len , LIS [ i ] ) ; } return n - len ; }

BLEU: 92.84
Edit Sim: 22


Src: 
int countNumbers ( int N ) { return ( pow ( 10 , N ) - pow ( 8 , N ) ) / 2 ; }
Ref: 
function countNumbers ( N ) { return parseInt ( ( Math . pow ( 10 , N ) - Math . pow ( 8 , N ) ) / 2 , 10 ) ; }
Hyp: 
function countNumbers ( N ) { return ( Math . pow ( 10 , N ) - Math . pow ( 8 , N ) ) / 2 ; }

BLEU: 76.32
Edit Sim: 18


Src: 
long productAscii ( string str ) { long long prod = 1 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { prod *= ( int ) str [ i ] ; } return prod ; }
Ref: 
function productAscii ( str ) { var prod = 1 ; for ( i = 0 ; i < str . length ; i ++ ) { prod *= str . charAt ( i ) . charCodeAt ( 0 ) ; } return prod ; }
Hyp: 
function productAscii ( str ) { let prod = 1 ; for ( let i = 0 ; i < str . length ; i ++ ) { prod *= ( let ) str [ i ] ; } return prod ; }

BLEU: 64.62
Edit Sim: 35


Src: 
double mixtureConcentration ( int n , int p [ ] ) { double res = 0 ; for ( int i = 0 ; i < n ; i ++ ) res += p [ i ] ; res /= n ; return res ; }
Ref: 
function mixtureConcentration ( n , p ) { var res = 0 ; for ( var i = 0 ; i < n ; i ++ ) res += p [ i ] ; res /= n ; return res ; }
Hyp: 
function mixtureConcentration ( n , p ) { let res = 0 ; for ( let i = 0 ; i < n ; i ++ ) res += p [ i ] ; res /= n ; return res ; }

BLEU: 87.61
Edit Sim: 6


Src: 
int findThirdDigit ( int n ) { if ( n < 3 ) return 0 ; return n & 1 ? 1 : 6 ; }
Ref: 
function findThirdDigit ( n ) { if ( n < 3 ) return 0 ; return n & 1 ? 1 : 6 ; }
Hyp: 
function findThirdDigit ( n ) { if ( n < 3 ) return 0 ; return n & 1 ? 1 : 6 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int evenPowerSum ( int n ) { return ( 8 * n * ( n + 1 ) * ( 2 * n + 1 ) * ( 3 * n * n + 3 * n - 1 ) ) / 15 ; }
Ref: 
function evenPowerSum ( n ) { return ( 8 * n * ( n + 1 ) * ( 2 * n + 1 ) * ( 3 * n * n + 3 * n - 1 ) ) / 15 ; }
Hyp: 
function evenPowerSum ( n ) { return ( 8 * n * ( n + 1 ) * ( 2 * n + 1 ) * ( 3 * n * n + 3 * n - 1 ) ) / 15 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int find_distance ( int n ) { return n * ( ( 3 * n ) + 7 ) ; }
Ref: 
function find_distance ( n ) { return n * ( 3 * n + 7 ) ; }
Hyp: 
function find_distance ( n ) { return n * ( ( 3 * n ) + 7 ) ; }

BLEU: 76.71
Edit Sim: 4


Src: 
int LowerInsertionPoint ( int arr [ ] , int n , int X ) { if ( X < arr [ 0 ] ) return 0 ; else if ( X > arr [ n - 1 ] ) return n ; int lowerPnt = 0 ; int i = 1 ; while ( i < n && arr [ i ] < X ) { lowerPnt = i ; i = i * 2 ; } while ( lowerPnt < n && arr [ lowerPnt ] < X ) lowerPnt ++ ; return lowerPnt ; }
Ref: 
function LowerInsertionPoint ( arr , n , X ) { if ( X < arr [ 0 ] ) return 0 ; else if ( X > arr [ n - 1 ] ) return n ; let lowerPnt = 0 ; let i = 1 ; while ( i < n && arr [ i ] < X ) { lowerPnt = i ; i = i * 2 ; } while ( lowerPnt < n && arr [ lowerPnt ] < X ) lowerPnt ++ ; return lowerPnt ; }
Hyp: 
function LowerInsertionPoint ( arr , n , X ) { if ( X < arr [ 0 ] ) return 0 ; else if ( X > arr [ n - 1 ] ) return n ; let lowerPnt = 0 ; let i = 1 ; while ( i < n && arr [ i ] < X ) { lowerPnt = i ; i = i * 2 ; } while ( lowerPnt < n && arr [ lowerPnt ] < X ) lowerPnt ++ ; return lowerPnt ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int maxRepeating ( int * arr , int n , int k ) { for ( int i = 0 ; i < n ; i ++ ) arr [ arr [ i ] % k ] += k ; int max = arr [ 0 ] , result = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > max ) { max = arr [ i ] ; result = i ; } } return result ; }
Ref: 
function maxRepeating ( arr , n , k ) { for ( let i = 0 ; i < n ; i ++ ) arr [ arr [ i ] % k ] += k ; let max = arr [ 0 ] , result = 0 ; for ( let i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > max ) { max = arr [ i ] ; result = i ; } } return result ; }
Hyp: 
function maxRepeating ( arr , n , k ) { for ( let i = 0 ; i < n ; i ++ ) arr [ arr [ i ] % k ] += k ; let max = arr [ 0 ] ; let result = 0 ; for ( let i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > max ) { max = arr [ i ] ; result = i ; } } return result ; }

BLEU: 96.11
Edit Sim: 5


Src: 
int maxResult ( int n , int a , int b , int c ) { int maxVal = 0 ; for ( int i = 0 ; i <= n ; i += a ) { for ( int j = 0 ; j <= n - i ; j += b ) { float z = ( float ) ( n - ( i + j ) ) / ( float ) ( c ) ; if ( floor ( z ) == ceil ( z ) ) { int x = i / a ; int y = j / b ; maxVal = max ( maxVal , x + y + ( int ) z ) ; } } } return maxVal ; }
Ref: 
function maxResult ( n , a , b , c ) { let maxVal = 0 ; for ( let i = 0 ; i <= n ; i += a ) for ( let j = 0 ; j <= n - i ; j += b ) { let z = ( n - ( i + j ) ) / c ; if ( Math . floor ( z ) == Math . ceil ( z ) ) { let x = i / a ; let y = j / b ; maxVal = Math . max ( maxVal , x + y + z ) ; } } return maxVal ; }
Hyp: 
function maxResult ( n , a , b , c ) { let maxVal = 0 ; for ( let i = 0 ; i <= n ; i += a ) { for ( let j = 0 ; j <= n - i ; j += b ) { let z = ( n - ( i + j ) ) / ( float ) ( c ) ; if ( Math . floor ( z ) == Math . ceil ( z ) ) { let x = i / a ; let y = j / b ; maxVal = Math . max ( maxVal , x + y + ( int ) z ) ; } } } return maxVal ; }

BLEU: 87.66
Edit Sim: 26


Src: 
int evenFibSum ( int limit ) { if ( limit < 2 ) return 0 ; long long int ef1 = 0 , ef2 = 2 ; long long int sum = ef1 + ef2 ; while ( ef2 <= limit ) { long long int ef3 = 4 * ef2 + ef1 ; if ( ef3 > limit ) break ; ef1 = ef2 ; ef2 = ef3 ; sum += ef2 ; } return sum ; }
Ref: 
function evenFibSum ( limit ) { if ( limit < 2 ) return 0 ; let ef1 = 0 , ef2 = 2 ; let sum = ef1 + ef2 ; while ( ef2 <= limit ) { let ef3 = 4 * ef2 + ef1 ; if ( ef3 > limit ) break ; ef1 = ef2 ; ef2 = ef3 ; sum += ef2 ; } return sum ; }
Hyp: 
function evenFibSum ( limit ) { if ( limit < 2 ) return 0 ; let ef1 = 0 , ef2 = 2 ; let sum = ef1 + ef2 ; while ( ef2 <= limit ) { let ef3 = 4 * ef2 + ef1 ; if ( ef3 > limit ) break ; ef1 = ef2 ; ef2 = ef3 ; sum += ef2 ; } return sum ; }

BLEU: 100.0
Edit Sim: 0


Src: 
float getMaxMedian ( int arr [ ] , int n , int k ) { int size = n + k ; sort ( arr , arr + n ) ; if ( size % 2 == 0 ) { float median = ( float ) ( arr [ ( size / 2 ) - 1 ] + arr [ size / 2 ] ) / 2 ; return median ; } float median = arr [ size / 2 ] ; return median ; }
Ref: 
function getMaxMedian ( arr , n , k ) { let size = n + k ; arr . sort ( ( a , b ) => a - b ) ; if ( size % 2 == 0 ) { let median = ( arr [ Math . floor ( size / 2 ) - 1 ] + arr [ Math . floor ( size / 2 ) ] ) / 2 ; return median ; } let median = arr [ Math . floor ( size / 2 ) ] ; return median ; }
Hyp: 
function getMaxMedian ( arr , n , k ) { let size = n + k ; arr . sort ( ( a , b ) => a - b ) ; if ( size % 2 == 0 ) { let median = ( arr [ parseInt ( ( size / 2 ) - 1 ] + arr [ parseInt ( size / 2 ) ] ) / 2 ; return median ; } let median = arr [ parseInt ( size / 2 ) ] ; return median ; }

BLEU: 85.79
Edit Sim: 33


Src: 
int icosidigonal_num ( long int n ) { return ( 20 * n * n - 18 * n ) / 2 ; }
Ref: 
function icosidigonal_num ( n ) { return parseInt ( ( 20 * n * n - 18 * n ) / 2 ) ; }
Hyp: 
function icosidigonal_num ( n ) { return ( 20 * n * n - 18 * n ) / 2 ; }

BLEU: 75.21
Edit Sim: 13


Src: 
void timeToMeet ( double s , double v ) { double V = 3 * v / 2 ; double time = s / V ; cout << time ; }
Ref: 
function timeToMeet ( s , v ) { var V = 3 * v / 2 ; var time = s / V ; document . write ( time . toFixed ( 6 ) ) ; }
Hyp: 
function timeToMeet ( s , v ) { let V = 3 * v / 2 ; let time = s / V ; document . write ( time . toFixed ( 10 ) ) ; }

BLEU: 78.53
Edit Sim: 8


Src: 
float Perimeter ( float s , int n ) { float perimeter = 1 ; perimeter = n * s ; return perimeter ; }
Ref: 
function Perimeter ( s , n ) { var perimeter = 1 ; perimeter = n * s ; return perimeter ; }
Hyp: 
function Perimeter ( s , n ) { let perimeter = 1 ; perimeter = n * s ; return perimeter ; }

BLEU: 88.44
Edit Sim: 3


Src: 
int max_min ( int a [ ] , int n ) { sort ( a , a + n ) ; return min ( a [ n - 2 ] - a [ 0 ] , a [ n - 1 ] - a [ 1 ] ) ; }
Ref: 
function max_min ( a , n ) { a . sort ( ) ; return Math . min ( a [ n - 2 ] - a [ 0 ] , a [ n - 1 ] - a [ 1 ] ) ; }
Hyp: 
function max_min ( a , n ) { a . sort ( ( a , b ) => a - b ) ; return Math . min ( a [ n - 2 ] - a [ 0 ] , a [ n - 1 ] - a [ 1 ] ) ; }

BLEU: 80.28
Edit Sim: 19


Src: 
int maxDiff ( int arr [ ] , int n ) { int result = 0 ; sort ( arr , arr + n ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] != arr [ i + 1 ] ) result += abs ( arr [ i ] ) ; else i ++ ; } if ( arr [ n - 2 ] != arr [ n - 1 ] ) result += abs ( arr [ n - 1 ] ) ; return result ; }
Ref: 
function maxDiff ( arr , n ) { var result = 0 ; arr . sort ( ( a , b ) => a - b ) for ( var i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] != arr [ i + 1 ] ) result += Math . abs ( arr [ i ] ) ; else i ++ ; } if ( arr [ n - 2 ] != arr [ n - 1 ] ) result += Math . abs ( arr [ n - 1 ] ) ; return result ; }
Hyp: 
function maxDiff ( arr , n ) { let result = 0 ; arr . sort ( ( a , b ) => a - b ) ; for ( let i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] != arr [ i + 1 ] ) result += Math . abs ( arr [ i ] ) ; else i ++ ; } if ( arr [ n - 2 ] != arr [ n - 1 ] ) result += Math . abs ( arr [ n - 1 ] ) ; return result ; }

BLEU: 93.31
Edit Sim: 8


Src: 
int findFlips ( char str [ ] , int n ) { char last = ' ▁ ' ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( last != str [ i ] ) res ++ ; last = str [ i ] ; } return res / 2 ; }
Ref: 
function findFlips ( str , n ) { var last = ' ' ; var res = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( last != str . charAt ( i ) ) res ++ ; last = str . charAt ( i ) ; } return parseInt ( res / 2 ) ; }
Hyp: 
function findFlips ( str , n ) { let last = ' ' ; let res = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( last != str [ i ] ) res ++ ; last = str [ i ] ; } return res / 2 ; }

BLEU: 60.36
Edit Sim: 45


Src: 
int calculateSum ( int n ) { return n * ( n + 1 ) / 2 + n * ( n + 1 ) * ( 2 * n + 1 ) / 6 ; }
Ref: 
function calculateSum ( n ) { return n * ( n + 1 ) / 2 + n * ( n + 1 ) * ( 2 * n + 1 ) / 6 ; }
Hyp: 
function calculateSum ( n ) { return n * ( n + 1 ) / 2 + n * ( n + 1 ) * ( 2 * n + 1 ) / 6 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int getMinSquares ( int n ) { if ( n <= 3 ) return n ; int * dp = new int [ n + 1 ] ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; dp [ 2 ] = 2 ; dp [ 3 ] = 3 ; for ( int i = 4 ; i <= n ; i ++ ) { dp [ i ] = i ; for ( int x = 1 ; x <= ceil ( sqrt ( i ) ) ; x ++ ) { int temp = x * x ; if ( temp > i ) break ; else dp [ i ] = min ( dp [ i ] , 1 + dp [ i - temp ] ) ; } } int res = dp [ n ] ; delete [ ] dp ; return res ; }
Ref: 
function getMinSquares ( n ) { if ( n <= 3 ) return n ; var dp = new Array ( n + 1 ) ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; dp [ 2 ] = 2 ; dp [ 3 ] = 3 ; for ( var i = 4 ; i <= n ; i ++ ) { dp [ i ] = i ; for ( var x = 1 ; x <= Math . ceil ( Math . sqrt ( i ) ) ; x ++ ) { var temp = x * x ; if ( temp > i ) break ; else dp [ i ] = Math . min ( dp [ i ] , 1 + dp [ i - temp ] ) ; } } var res = dp [ n ] ; return res ; }
Hyp: 
function getMinSquares ( n ) { if ( n <= 3 ) return n ; let dp = new Array ( n + 1 ) ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; dp [ 2 ] = 2 ; dp [ 3 ] = 3 ; for ( let i = 4 ; i <= n ; i ++ ) { dp [ i ] = i ; for ( let x = 1 ; x <= Math . ceil ( Math . sqrt ( i ) ) ; x ++ ) { let temp = x * x ; if ( temp > i ) break ; else dp [ i ] = Math . min ( dp [ i ] , 1 + dp [ i - temp ] ) ; } } let res = dp [ n ] ; delete [ ] dp ; return res ; }

BLEU: 88.43
Edit Sim: 31


Src: 
void subArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { for ( int k = i ; k <= j ; k ++ ) cout << arr [ k ] << " ▁ " ; cout << endl ; } } }
Ref: 
function subArray ( n ) { for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i ; j < n ; j ++ ) { for ( let k = i ; k <= j ; k ++ ) document . write ( arr [ k ] + " " ) ; document . write ( " " ) ; } } }
Hyp: 
function subArray ( arr , n ) { for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i ; j < n ; j ++ ) { for ( let k = i ; k <= j ; k ++ ) document . write ( arr [ k ] + " " ) ; document . write ( " " ) ; } } }

BLEU: 95.33
Edit Sim: 6


Src: 
int minDistance ( int n1 , int n2 ) { int bitCount1 = floor ( log2 ( n1 ) ) + 1 ; int bitCount2 = floor ( log2 ( n2 ) ) + 1 ; int bitDiff = abs ( bitCount1 - bitCount2 ) ; int maxBitCount = max ( bitCount1 , bitCount2 ) ; if ( bitCount1 > bitCount2 ) { n2 = n2 * pow ( 2 , bitDiff ) ; } else { n1 = n1 * pow ( 2 , bitDiff ) ; } int xorValue = n1 ^ n2 ; int bitCountXorValue ; if ( xorValue == 0 ) bitCountXorValue = 1 ; else { bitCountXorValue = floor ( log2 ( xorValue ) ) + 1 ; } int disSimilarBitPosition = maxBitCount - bitCountXorValue ; int result = bitCount1 + bitCount2 - 2 * disSimilarBitPosition ; return result ; }
Ref: 
function minDistance ( n1 , n2 ) { var bitCount1 = Math . floor ( Math . log2 ( n1 ) ) + 1 ; var bitCount2 = Math . floor ( Math . log2 ( n2 ) ) + 1 ; var bitDiff = Math . abs ( bitCount1 - bitCount2 ) ; var maxBitCount = Math . max ( bitCount1 , bitCount2 ) ; if ( bitCount1 > bitCount2 ) { n2 = n2 * Math . pow ( 2 , bitDiff ) ; } else { n1 = n1 * Math . pow ( 2 , bitDiff ) ; } var xorValue = n1 ^ n2 ; var bitCountXorValue ; if ( xorValue == 0 ) bitCountXorValue = 1 ; else { bitCountXorValue = Math . floor ( Math . log2 ( xorValue ) ) + 1 ; } var disSimilarBitPosition = maxBitCount - bitCountXorValue ; var result = bitCount1 + bitCount2 - 2 * disSimilarBitPosition ; return result ; }
Hyp: 
function minDistance ( n1 , n2 ) { let bitCount1 = Math . floor ( Math . log2 ( n1 ) ) + 1 ; let bitCount2 = Math . floor ( Math . log2 ( n2 ) ) + 1 ; let bitDiff = Math . abs ( bitCount1 - bitCount2 ) ; let maxBitCount = Math . max ( bitCount1 , bitCount2 ) ; if ( bitCount1 > bitCount2 ) { n2 = n2 * Math . pow ( 2 , bitDiff ) ; } else { n1 = n1 * Math . pow ( 2 , bitDiff ) ; } let xorValue = n1 ^ n2 ; let bitCountXorValue ; if ( xorValue == 0 ) bitCountXorValue = 1 ; else { bitCountXorValue = Math . floor ( Math . log2 ( xorValue ) ) + 1 ; } let disSimilarBitPosition = maxBitCount - bitCountXorValue ; return result ; }

BLEU: 81.71
Edit Sim: 86


Src: 
int minRadius ( int k , int x [ ] , int y [ ] , int n ) { int dis [ n ] ; for ( int i = 0 ; i < n ; i ++ ) dis [ i ] = x [ i ] * x [ i ] + y [ i ] * y [ i ] ; sort ( dis , dis + n ) ; return dis [ k - 1 ] ; }
Ref: 
function minRadius ( k , x , y , n ) { let dis = Array . from ( { length : n } , ( _ , i ) => 0 ) ; for ( let i = 0 ; i < n ; i ++ ) dis [ i ] = x [ i ] * x [ i ] + y [ i ] * y [ i ] ; dis . sort ( ) ; return dis [ k - 1 ] ; }
Hyp: 
function minRadius ( k , x , y , n ) { let dis = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) dis [ i ] = x [ i ] * x [ i ] + y [ i ] * y [ i ] ; sort ( dis , dis + n ) ; return dis [ k - 1 ] ; }

BLEU: 74.05
Edit Sim: 54


Src: 
int getBoundarySum ( int a [ ] [ MAX ] , int m , int n ) { long long int sum = 0 ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == 0 ) sum += a [ i ] [ j ] ; else if ( i == m - 1 ) sum += a [ i ] [ j ] ; else if ( j == 0 ) sum += a [ i ] [ j ] ; else if ( j == n - 1 ) sum += a [ i ] [ j ] ; } } return sum ; }
Ref: 
function getBoundarySum ( a , m , n ) { let sum = 0 ; for ( let i = 0 ; i < m ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { if ( i == 0 ) sum += a [ i ] [ j ] ; else if ( i == m - 1 ) sum += a [ i ] [ j ] ; else if ( j == 0 ) sum += a [ i ] [ j ] ; else if ( j == n - 1 ) sum += a [ i ] [ j ] ; } } return sum ; }
Hyp: 
function getBoundarySum ( a , m , n ) { let sum = 0 ; for ( let i = 0 ; i < m ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { if ( i == 0 ) sum += a [ i ] [ j ] ; else if ( i == m - 1 ) sum += a [ i ] [ j ] ; else if ( j == 0 ) sum += a [ i ] [ j ] ; else if ( j == n - 1 ) sum += a [ i ] [ j ] ; } } return sum ; }

BLEU: 100.0
Edit Sim: 0


Src: 
float trianglearea ( float r ) { if ( r < 0 ) return -1 ; return r * r ; }
Ref: 
function trianglearea ( r ) { if ( r < 0 ) return - 1 ; return r * r ; }
Hyp: 
function trianglearea ( r ) { if ( r < 0 ) return - 1 ; return r * r ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int pairORSum ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) ans += arr [ i ] | arr [ j ] ; return ans ; }
Ref: 
function pairORSum ( arr , n ) { for ( var i = 0 ; i < n ; i ++ ) for ( var j = i + 1 ; j < n ; j ++ ) ans += arr [ i ] | arr [ j ] ; return ans ; }
Hyp: 
function pairORSum ( arr , n ) { for ( let i = 0 ; i < n ; i ++ ) for ( let j = i + 1 ; j < n ; j ++ ) ans += arr [ i ] | arr [ j ] ; return ans ; }

BLEU: 90.46
Edit Sim: 6


Src: 
int areaSquare ( int side ) { int area = side * side ; return area ; }
Ref: 
function areaSquare ( side ) { let area = side * side ; return area ; }
Hyp: 
function areaSquare ( side ) { let area = side * side ; return area ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int SubseqWidths ( int A [ ] , int n ) { sort ( A , A + n ) ; int pow2 [ n ] ; pow2 [ 0 ] = 1 ; for ( int i = 1 ; i < n ; ++ i ) pow2 [ i ] = ( pow2 [ i - 1 ] * 2 ) % MOD ; int ans = 0 ; for ( int i = 0 ; i < n ; ++ i ) ans = ( ans + ( pow2 [ i ] - pow2 [ n - 1 - i ] ) * A [ i ] ) % MOD ; return ans ; }
Ref: 
function SubseqWidths ( A , n ) { A . sort ( ( a , b ) => a - b ) var pow2 = Array ( n ) . fill ( 0 ) ; pow2 [ 0 ] = 1 ; for ( var i = 1 ; i < n ; ++ i ) pow2 [ i ] = ( pow2 [ i - 1 ] * 2 ) % MOD ; var ans = 0 ; for ( var i = 0 ; i < n ; ++ i ) ans = ( ans + ( pow2 [ i ] - pow2 [ n - 1 - i ] ) * A [ i ] ) % MOD ; return ans ; }
Hyp: 
function SubseqWidths ( A , n ) { A . sort ( ( a , b ) => a - b ) ; let pow2 = new Array ( n ) ; pow2 [ 0 ] = 1 ; for ( let i = 1 ; i < n ; ++ i ) pow2 [ i ] = ( pow2 [ i - 1 ] * 2 ) % MOD ; let ans = 0 ; for ( let i = 0 ; i < n ; ++ i ) ans = ( ans + ( pow2 [ i ] - pow2 [ n - 1 - i ] ) * A [ i ] ) % MOD ; return ans ; }

BLEU: 86.25
Edit Sim: 31


Src: 
int CntDivbyX ( int arr [ ] , int n , int x ) { int number = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { number = ( number * 2 + arr [ i ] ) % x ; if ( number == 0 ) count += 1 ; } return count ; }
Ref: 
function CntDivbyX ( arr , n , x ) { let number = 0 ; let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { number = ( number * 2 + arr [ i ] ) % x ; if ( number == 0 ) count += 1 ; } return count ; }
Hyp: 
function CntDivbyX ( arr , n , x ) { let number = 0 ; let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { number = ( number * 2 + arr [ i ] ) % x ; if ( number == 0 ) count += 1 ; } return count ; }

BLEU: 100.0
Edit Sim: 0


Src: 
float heightCalculate ( int H , int n , int m ) { float N = n * 1.0 ; float M = m * 1.0 ; float h = H * sqrt ( N / ( N + M ) ) ; return h ; }
Ref: 
function heightCalculate ( H , n , m ) { let N = n * 1.0 ; let M = m * 1.0 ; let h = H * Math . sqrt ( N / ( N + M ) ) ; return h ; }
Hyp: 
function heightCalculate ( H , n , m ) { let N = n * 1.0 ; let M = m * 1.0 ; let h = H * Math . sqrt ( N / ( N + M ) ) ; return h ; }

BLEU: 100.0
Edit Sim: 0


Src: 
void printGP ( int a , int r , int n ) { int curr_term ; for ( int i = 0 ; i < n ; i ++ ) { curr_term = a * pow ( r , i ) ; cout << curr_term << " ▁ " ; } }
Ref: 
function printGP ( a , r , n ) { let curr_term ; for ( let i = 0 ; i < n ; i ++ ) { curr_term = a * Math . pow ( r , i ) ; document . write ( curr_term + " " ) ; } }
Hyp: 
function printGP ( a , r , n ) { let curr_term ; for ( let i = 0 ; i < n ; i ++ ) { curr_term = a * Math . pow ( r , i ) ; document . write ( curr_term + " " ) ; } }

BLEU: 100.0
Edit Sim: 0


Src: 
void printClosest ( int ar1 [ ] , int ar2 [ ] , int m , int n , int x ) { int diff = INT_MAX ; int res_l , res_r ; int l = 0 , r = n - 1 ; while ( l < m && r >= 0 ) { if ( abs ( ar1 [ l ] + ar2 [ r ] - x ) < diff ) { res_l = l ; res_r = r ; diff = abs ( ar1 [ l ] + ar2 [ r ] - x ) ; } if ( ar1 [ l ] + ar2 [ r ] > x ) r -- ; else l ++ ; } cout << " The ▁ closest ▁ pair ▁ is ▁ [ " << ar1 [ res_l ] << " , ▁ " << ar2 [ res_r ] << " ] ▁ STRNEWLINE " ; }
Ref: 
function printClosest ( ar1 , ar2 , m , n , x ) { let diff = Number . MAX_VALUE ; let res_l , res_r ; let l = 0 , r = n - 1 ; while ( l < m && r >= 0 ) { if ( Math . abs ( ar1 [ l ] + ar2 [ r ] - x ) < diff ) { res_l = l ; res_r = r ; diff = Math . abs ( ar1 [ l ] + ar2 [ r ] - x ) ; } if ( ar1 [ l ] + ar2 [ r ] > x ) r -- ; else l ++ ; } document . write ( " " + ar1 [ res_l ] + " " + ar2 [ res_r ] + " " ) ; }
Hyp: 
function printClosest ( ar1 , ar2 , m , n , x ) { let diff = Number . MAX_VALUE ; let res_l , res_r ; let l = 0 , r = n - 1 ; while ( l < m && r >= 0 ) { if ( Math . abs ( ar1 [ l ] + ar2 [ r ] - x ) < diff ) { res_l = l ; res_r = r ; diff = Math . abs ( ar1 [ l ] + ar2 [ r ] - x ) ; } if ( ar1 [ l ] + ar2 [ r ] > x ) r -- ; else l ++ ; } document . write ( " " + ar1 [ res_l ] + " " + ar2 [ res_r ] + " " ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
bool isMultipleof5 ( int n ) { while ( n > 0 ) n = n - 5 ; if ( n == 0 ) return true ; return false ; }
Ref: 
function isMultipleof5 ( n ) { while ( n > 0 ) n = n - 5 ; if ( n == 0 ) return true ; return false ; }
Hyp: 
function isMultipleof5 ( n ) { while ( n > 0 ) n = n - 5 ; if ( n == 0 ) return true ; return false ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int minCost ( int N , int P , int Q ) { int cost = 0 ; while ( N > 0 ) { if ( N & 1 ) { cost += P ; N -- ; } else { int temp = N / 2 ; if ( temp * P > Q ) cost += Q ; else cost += P * temp ; N /= 2 ; } } return cost ; }
Ref: 
function minCost ( N , P , Q ) { var cost = 0 ; while ( N > 0 ) { if ( N & 1 ) { cost += P ; N -- ; } else { var temp = parseInt ( N / 2 ) ; if ( temp * P > Q ) cost += Q ; else cost += P * temp ; N = parseInt ( N / 2 ) ; } } return cost ; }
Hyp: 
function minCost ( N , P , Q ) { let cost = 0 ; while ( N > 0 ) { if ( N & 1 ) { cost += P ; N -- ; } else { let temp = N / 2 ; if ( temp * P > Q ) cost += Q ; else cost += P * temp ; N /= 2 ; } } return cost ; }

BLEU: 76.19
Edit Sim: 37


Src: 
int calculateAlternateSum ( int n ) { if ( n <= 0 ) return 0 ; int fibo [ n + 1 ] ; fibo [ 0 ] = 0 , fibo [ 1 ] = 1 ; int sum = pow ( fibo [ 0 ] , 2 ) + pow ( fibo [ 1 ] , 2 ) ; for ( int i = 2 ; i <= n ; i ++ ) { fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ; if ( i % 2 == 0 ) sum -= fibo [ i ] ; else sum += fibo [ i ] ; } return sum ; }
Ref: 
function calculateAlternateSum ( n ) { if ( n <= 0 ) return 0 ; var fibo = Array ( n + 1 ) . fill ( 0 ) ; fibo [ 0 ] = 0 ; fibo [ 1 ] = 1 ; var sum = Math . pow ( fibo [ 0 ] , 2 ) + Math . pow ( fibo [ 1 ] , 2 ) ; for ( i = 2 ; i <= n ; i ++ ) { fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ; if ( i % 2 == 0 ) sum -= fibo [ i ] ; else sum += fibo [ i ] ; } return sum ; }
Hyp: 
function calculateAlternateSum ( n ) { if ( n <= 0 ) return 0 ; let fibo = new Array ( n + 1 ) ; fibo [ 0 ] = 0 , fibo [ 1 ] = 1 ; let sum = 0 ; for ( let i = 2 ; i <= n ; i ++ ) { fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ; if ( i % 2 == 0 ) sum -= fibo [ i ] ; else sum += fibo [ i ] ; } return sum ; }

BLEU: 68.28
Edit Sim: 86


Src: 
int pow ( int a , int b ) { if ( b == 0 ) return 1 ; int answer = a ; int increment = a ; int i , j ; for ( i = 1 ; i < b ; i ++ ) { for ( j = 1 ; j < a ; j ++ ) { answer += increment ; } increment = answer ; } return answer ; }
Ref: 
function pow ( a , b ) { if ( b == 0 ) return 1 ; var answer = a ; var increment = a ; var i , j ; for ( i = 1 ; i < b ; i ++ ) { for ( j = 1 ; j < a ; j ++ ) { answer += increment ; } increment = answer ; } return answer ; }
Hyp: 
function pow ( a , b ) { if ( b == 0 ) return 1 ; let answer = a ; let increment = a ; let i , j ; for ( i = 1 ; i < b ; i ++ ) { for ( j = 1 ; j < a ; j ++ ) { answer += increment ; } increment = answer ; } return answer ; }

BLEU: 89.6
Edit Sim: 9


Src: 
int longestSubstring ( string s ) { int cnt = 1 ; int maxi = 1 ; int n = s . length ( ) ; for ( int i = 1 ; i < n ; i ++ ) { if ( s [ i ] != s [ i - 1 ] ) cnt ++ ; else { maxi = max ( cnt , maxi ) ; cnt = 1 ; } } maxi = max ( cnt , maxi ) ; return maxi ; }
Ref: 
function longestSubstring ( s ) { var cnt = 1 , maxi = 1 ; var n = s . length ; for ( i = 1 ; i < n ; i ++ ) { if ( s . charAt ( i ) != s . charAt ( i - 1 ) ) cnt ++ ; else { maxi = Math . max ( cnt , maxi ) ; cnt = 1 ; } } maxi = Math . max ( cnt , maxi ) ; return maxi ; }
Hyp: 
function longestSubstring ( s ) { var cnt = 1 ; var maxi = 1 ; var n = s . length ; for ( var i = 1 ; i < n ; i ++ ) { if ( s [ i ] != s [ i - 1 ] ) cnt ++ ; else { maxi = Math . max ( cnt , maxi ) ; cnt = 1 ; } } maxi = Math . max ( cnt , maxi ) ; return maxi ; }

BLEU: 80.87
Edit Sim: 31


Src: 
float ellipse ( float l , float b ) { if ( l < 0 b < 0 ) return -1 ; float x = ( 3.14 * l * b ) / 4 ; return x ; }
Ref: 
function ellipse ( l , b ) { if ( l < 0 b < 0 ) return - 1 ; var x = ( 3.14 * l * b ) / 4 ; return x ; }
Hyp: 
function ellipse ( l , b ) { if ( l < 0 b < 0 ) return - 1 ; var x = ( 3.14 * l * b ) / 4 ; return x ; }

BLEU: 100.0
Edit Sim: 0


Src: 
void findGreater ( int a , int b , int n ) { if ( ! ( n & 1 ) ) { a = abs ( a ) ; b = abs ( b ) ; } if ( a == b ) cout << " a ^ n ▁ is ▁ equal ▁ to ▁ b ^ n " ; else if ( a > b ) cout << " a ^ n ▁ is ▁ greater ▁ than ▁ b ^ n " ; else cout << " b ^ n ▁ is ▁ greater ▁ than ▁ a ^ n " ; }
Ref: 
function findGreater ( a , b , n ) { if ( ! ( ( n & 1 ) > 0 ) ) { a = Math . abs ( a ) ; b = Math . abs ( b ) ; } if ( a == b ) document . write ( " " + " " ) ; else if ( a > b ) document . write ( " " + " " ) ; else document . write ( " " + " " ) ; }
Hyp: 
function findGreater ( a , b , n ) { if ( ( n & 1 ) == 0 ) { a = Math . abs ( a ) ; b = Math . abs ( b ) ; } if ( ( a == b ) && ( a > b ) ) document . write ( " " + " " ) ; else document . write ( " " + " " + " " + " " ) ; }

BLEU: 78.83
Edit Sim: 63


Src: 
int minLettersNeeded ( int n ) { if ( n % 26 == 0 ) return ( n / 26 ) ; else return ( ( n / 26 ) + 1 ) ; }
Ref: 
function minLettersNeeded ( n ) { if ( n % 26 == 0 ) return parseInt ( n / 26 ) ; else return ( parseInt ( n / 26 ) + 1 ) ; }
Hyp: 
function minLettersNeeded ( n ) { if ( n % 26 == 0 ) return parseInt ( n / 26 ) ; else return parseInt ( ( n / 26 ) + 1 ) ; }

BLEU: 91.91
Edit Sim: 4


Src: 
string toBinary ( double n ) { if ( n >= 1 n <= 0 ) return " ERROR " ; string answer ; double frac = 0.5 ; answer . append ( " . " ) ; while ( n > 0 ) { if ( answer . length ( ) >= 32 ) return " ERROR " ; if ( n >= frac ) { answer . append ( "1" ) ; n = n - frac ; } else { answer . append ( "0" ) ; } frac /= 2 ; } return answer ; }
Ref: 
function printBinary ( num ) { if ( num >= 1 num <= 0 ) return " " ; let binary = " " ; let frac = 0.5 ; binary += " " ; while ( num > 0 ) { if ( binary . length >= 32 ) return " " ; if ( num >= frac ) { binary += " " ; num -= frac ; } else binary += " " ; frac = frac / 2 ; } return binary ; }
Hyp: 
function toBinary ( n ) { if ( n >= 1 n <= 0 ) return " " ; let answer = " " ; let frac = 0.5 ; answer . append ( " " ) ; while ( n > 0 ) { if ( answer . length >= 32 ) return " " ; if ( n >= frac ) { answer . append ( " " ) ; n = n - frac ; } else { answer . append ( " " ) ; } frac /= 2 ; } return answer ; }

BLEU: 43.6
Edit Sim: 94


Src: 
int binomialCoeff ( int n , int k ) { int C [ k + 1 ] ; memset ( C , 0 , sizeof ( C ) ) ; C [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = min ( i , k ) ; j > 0 ; j -- ) C [ j ] = C [ j ] + C [ j - 1 ] ; } return C [ k ] ; }
Ref: 
function binomialCoeff ( n , k ) { let C = new Array ( k + 1 ) ; C . fill ( 0 ) ; C [ 0 ] = 1 ; for ( let i = 1 ; i <= n ; i ++ ) { for ( let j = Math . min ( i , k ) ; j > 0 ; j -- ) C [ j ] = C [ j ] + C [ j - 1 ] ; } return C [ k ] ; }
Hyp: 
function binomialCoeff ( n , k ) { let C = new Array ( k + 1 ) ; for ( let i = 0 ; i < k + 1 ; i ++ ) { C [ i ] = 1 ; for ( let j = Math . min ( i , k ) ; j > 0 ; j -- ) C [ j ] = C [ j ] + C [ j - 1 ] ; } return C [ k ] ; }

BLEU: 81.41
Edit Sim: 39


Src: 
bool check ( int a [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) if ( a [ i ] ) return true ; return false ; }
Ref: 
function check ( a , n ) { for ( var i = 0 ; i < n ; i ++ ) if ( a [ i ] ) return true ; return false ; }
Hyp: 
function check ( a , n ) { for ( let i = 0 ; i < n ; i ++ ) if ( a [ i ] ) return true ; return false ; }

BLEU: 92.79
Edit Sim: 3


Src: 
int countFriendsPairings ( int n ) { int dp [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { if ( i <= 2 ) dp [ i ] = i ; else dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; } return dp [ n ] ; }
Ref: 
function countFriendsPairings ( n ) { let dp = [ ] ; for ( let i = 0 ; i <= n ; i ++ ) { if ( i <= 2 ) dp [ i ] = i ; else dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; } return dp [ n ] ; }
Hyp: 
function countFriendsPairings ( n ) { let dp = new Array ( n + 1 ) ; for ( let i = 0 ; i <= n ; i ++ ) { if ( i <= 2 ) dp [ i ] = i ; else dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; } return dp [ n ] ; }

BLEU: 89.14
Edit Sim: 18


Src: 
float Area ( float a , float b ) { if ( a < 0 && b < 0 ) return -1 ; float h = sqrt ( ( ( pow ( a , 2 ) + pow ( b , 2 ) ) / ( pow ( a , 2 ) * pow ( b , 2 ) ) ) ) ; float A = 0.70477 * pow ( h , 2 ) ; return A ; }
Ref: 
function Area ( a , b ) { if ( a < 0 && b < 0 ) return - 1 ; let h = Math . sqrt ( ( ( Math . pow ( a , 2 ) + Math . pow ( b , 2 ) ) / ( Math . pow ( a , 2 ) * Math . pow ( b , 2 ) ) ) ) ; let A = 0.70477 * Math . pow ( h , 2 ) ; return A ; }
Hyp: 
function Area ( a , b ) { if ( a < 0 && b < 0 ) return - 1 ; var h = Math . sqrt ( ( ( Math . pow ( a , 2 ) + Math . pow ( b , 2 ) ) / ( Math . pow ( a , 2 ) * Math . pow ( b , 2 ) ) ) ) ; var A = 0.70477 * ( Math . pow ( h , 2 ) ) ; return A ; }

BLEU: 89.71
Edit Sim: 10


Src: 
int findRectNum ( int n ) { return n * ( n + 1 ) ; }
Ref: 
function findRectNum ( n ) { return n * ( n + 1 ) ; }
Hyp: 
function findRectNum ( n ) { return n * ( n + 1 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int getRemainder ( int num , int divisor ) { return ( num - divisor * ( num / divisor ) ) ; }
Ref: 
function getRemainder ( num , divisor ) { let t = ( num - divisor * parseInt ( num / divisor ) ) ; return t ; }
Hyp: 
function getRemainder ( num , divisor ) { return ( num - divisor * ( num / divisor ) ) ; }

BLEU: 59.38
Edit Sim: 25


Src: 
void maxSum ( int a [ ] , int n ) { int maxAnd = 0 ; for ( int i = 0 ; i < n ; i ++ ) maxAnd = max ( maxAnd , a [ i ] ) ; int maxOR = 0 ; for ( int i = 0 ; i < n ; i ++ ) { maxOR = maxOR | a [ i ] ; } cout << maxAnd + maxOR ; }
Ref: 
function maxSum ( a , n ) { var maxAnd = Math . max ( ... a ) ; var maxOR = 0 ; for ( var i = 0 ; i < n ; i ++ ) { maxOR |= a [ i ] ; } document . write ( ( maxAnd + maxOR ) ) ; }
Hyp: 
function maxSum ( a , n ) { let maxAnd = 0 ; for ( let i = 0 ; i < n ; i ++ ) maxAnd = Math . max ( maxAnd , a [ i ] ) ; let maxOR = 0 ; for ( let i = 0 ; i < n ; i ++ ) { maxOR = maxOR | a [ i ] ; } document . write ( maxAnd + maxOR ) ; }

BLEU: 51.62
Edit Sim: 80


Src: 
int countStr ( int n , int bCount , int cCount ) { if ( bCount < 0 cCount < 0 ) return 0 ; if ( n == 0 ) return 1 ; if ( bCount == 0 && cCount == 0 ) return 1 ; int res = countStr ( n - 1 , bCount , cCount ) ; res += countStr ( n - 1 , bCount - 1 , cCount ) ; res += countStr ( n - 1 , bCount , cCount - 1 ) ; return res ; }
Ref: 
function countStr ( n , bCount , cCount ) { if ( bCount < 0 cCount < 0 ) return 0 ; if ( n == 0 ) return 1 ; if ( bCount == 0 && cCount == 0 ) return 1 ; let res = countStr ( n - 1 , bCount , cCount ) ; res += countStr ( n - 1 , bCount - 1 , cCount ) ; res += countStr ( n - 1 , bCount , cCount - 1 ) ; return res ; }
Hyp: 
function countStr ( n , bCount , cCount ) { if ( bCount < 0 cCount < 0 ) return 0 ; if ( n == 0 ) return 1 ; if ( bCount == 0 && cCount == 0 ) return 1 ; let res = countStr ( n - 1 , bCount , cCount ) ; res += countStr ( n - 1 , bCount - 1 , cCount ) ; res += countStr ( n - 1 , bCount , cCount - 1 ) ; return res ; }

BLEU: 100.0
Edit Sim: 0


Src: 
void findPair ( int arr [ ] , int n ) { bool found = false ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { for ( int k = 0 ; k < n ; k ++ ) { if ( arr [ i ] + arr [ j ] == arr [ k ] ) { cout << arr [ i ] << " ▁ " << arr [ j ] << endl ; found = true ; } } } } if ( found == false ) cout << " Not ▁ exist " << endl ; }
Ref: 
function findPair ( arr , n ) { let found = false ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i + 1 ; j < n ; j ++ ) { for ( let k = 0 ; k < n ; k ++ ) { if ( arr [ i ] + arr [ j ] == arr [ k ] ) { document . write ( arr [ i ] + " " + arr [ j ] + " " ) ; found = true ; } } } } if ( found == false ) document . write ( " " ) ; }
Hyp: 
function findPair ( arr , n ) { let found = false ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i + 1 ; j < n ; j ++ ) { for ( let k = 0 ; k < n ; k ++ ) { if ( arr [ i ] + arr [ j ] == arr [ k ] ) { document . write ( arr [ i ] + " " + arr [ j ] + " " ) ; found = true ; } } } } if ( found == false ) document . write ( " " ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
void quadrant ( int x , int y ) { if ( x > 0 and y > 0 ) cout << " lies ▁ in ▁ First ▁ quadrant " ; else if ( x < 0 and y > 0 ) cout << " lies ▁ in ▁ Second ▁ quadrant " ; else if ( x < 0 and y < 0 ) cout << " lies ▁ in ▁ Third ▁ quadrant " ; else if ( x > 0 and y < 0 ) cout << " lies ▁ in ▁ Fourth ▁ quadrant " ; else if ( x == 0 and y > 0 ) cout << " lies ▁ at ▁ positive ▁ y ▁ axis " ; else if ( x == 0 and y < 0 ) cout << " lies ▁ at ▁ negative ▁ y ▁ axis " ; else if ( y == 0 and x < 0 ) cout << " lies ▁ at ▁ negative ▁ x ▁ axis " ; else if ( y == 0 and x > 0 ) cout << " lies ▁ at ▁ positive ▁ x ▁ axis " ; else cout << " lies ▁ at ▁ origin " ; }
Ref: 
function quadrant ( x , y ) { if ( x > 0 && y > 0 ) document . write ( " " ) ; else if ( x < 0 && y > 0 ) document . write ( " " ) ; else if ( x < 0 && y < 0 ) document . write ( " " ) ; else if ( x > 0 && y < 0 ) document . write ( " " ) ; else if ( x == 0 && y > 0 ) document . write ( " " ) ; else if ( x == 0 && y < 0 ) document . write ( " " ) ; else if ( y == 0 && x < 0 ) document . write ( " " ) ; else if ( y == 0 && x > 0 ) document . write ( " " ) ; else document . write ( " " ) ; }
Hyp: 
function quadrant ( x , y ) { if ( x > 0 and y > 0 ) document . write ( " " ) ; else if ( x < 0 and y > 0 ) document . write ( " " ) ; else if ( x > 0 and y < 0 ) document . write ( " " ) ; else if ( x == 0 and y > 0 ) document . write ( " " ) ; else if ( x == 0 and y < 0 ) document . write ( " " ) ; else document . write ( " " ) ; }

BLEU: 53.25
Edit Sim: 176


Src: 
void printDuplicates ( int arr [ ] , int n ) { int i ; int fl = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ arr [ i ] % n ] >= n ) { if ( arr [ arr [ i ] % n ] < 2 * n ) { cout << arr [ i ] % n << " ▁ " ; fl = 1 ; } } arr [ arr [ i ] % n ] += n ; } if ( ! fl ) cout << " - 1" ; }
Ref: 
function printDuplicates ( arr , n ) { let i ; let fl = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ arr [ i ] % n ] >= n ) { if ( arr [ arr [ i ] % n ] < 2 * n ) { document . write ( arr [ i ] % n + " " ) ; fl = 1 ; } } arr [ arr [ i ] % n ] += n ; } if ( ! fl ) document . write ( " " ) ; }
Hyp: 
function printDuplicates ( arr , n ) { let i ; let fl = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ arr [ i ] % n ] >= n ) { if ( arr [ arr [ i ] % n ] < 2 * n ) { document . write ( arr [ i ] % n + " " ) ; fl = 1 ; } } arr [ arr [ i ] % n ] += n ; } if ( ! fl ) document . write ( " " ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int distribution ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int count = 1 ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] > arr [ i - 1 ] ) count ++ ; return min ( count , n / 2 ) ; }
Ref: 
function distribution ( arr , n ) { arr . sort ( ( a , b ) => a - b ) ; var count = 1 ; for ( var i = 1 ; i < n ; i ++ ) if ( arr [ i ] > arr [ i - 1 ] ) count ++ ; return Math . min ( count , parseInt ( n / 2 ) ) ; }
Hyp: 
function distribution ( arr , n ) { arr . sort ( ( a , b ) => a - b ) ; let count = 1 ; for ( let i = 1 ; i < n ; i ++ ) if ( arr [ i ] > arr [ i - 1 ] ) count ++ ; return Math . min ( count , parseInt ( n / 2 ) ) ; }

BLEU: 93.19
Edit Sim: 6


Src: 
int maxSubArraySum ( int a [ ] , int size ) { int max_so_far = a [ 0 ] ; int curr_max = a [ 0 ] ; for ( int i = 1 ; i < size ; i ++ ) { curr_max = max ( a [ i ] , curr_max + a [ i ] ) ; max_so_far = max ( max_so_far , curr_max ) ; } return max_so_far ; }
Ref: 
function maxSubArraySum ( a , size ) { let max_so_far = a [ 0 ] ; let curr_max = a [ 0 ] ; for ( let i = 1 ; i < size ; i ++ ) { curr_max = Math . max ( a [ i ] , curr_max + a [ i ] ) ; max_so_far = Math . max ( max_so_far , curr_max ) ; } return max_so_far ; }
Hyp: 
function maxSubArraySum ( a , size ) { let max_so_far = a [ 0 ] ; let curr_max = a [ 0 ] ; for ( let i = 1 ; i < size ; i ++ ) { curr_max = Math . max ( a [ i ] , curr_max + a [ i ] ) ; max_so_far = Math . max ( max_so_far , curr_max ) ; } return max_so_far ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int Dodecagonal_number ( int n ) { return 5 * n * n - 4 * n ; }
Ref: 
function Dodecagonal_number ( n ) { return 5 * n * n - 4 * n ; }
Hyp: 
function Dodecagonal_number ( n ) { return 5 * n * n - 4 * n ; }

BLEU: 100.0
Edit Sim: 0


Src: 
ll getSum ( ll n , int d ) { if ( n < d ) return 0 ; while ( n % 10 != d ) n -- ; ll k = n / 10 ; return ( k + 1 ) * d + ( k * 10 + 10 * k * k ) / 2 ; }
Ref: 
function getSum ( n , d ) { if ( n < d ) return 0 ; while ( n % 10 != d ) n -- ; k = parseInt ( n / 10 ) ; return ( k + 1 ) * d + ( k * 10 + 10 * k * k ) / 2 ; }
Hyp: 
function getSum ( n , d ) { if ( n < d ) return 0 ; while ( n % 10 != d ) n -- ; let k = parseInt ( n / 10 ) ; return ( k + 1 ) * d + ( k * 10 + 10 * k * k ) / 2 ; }

BLEU: 95.88
Edit Sim: 4


Src: 
int calculateSum ( string arr [ ] , int n ) { if ( n == 0 ) return 0 ; string s = arr [ 0 ] ; int value = stoi ( s ) ; int sum = value ; for ( int i = 2 ; i < n ; i = i + 2 ) { s = arr [ i ] ; int value = stoi ( s ) ; char operation = arr [ i - 1 ] [ 0 ] ; if ( operation == ' + ' ) sum += value ; else sum -= value ; } return sum ; }
Ref: 
function calculateSum ( arr , n ) { if ( n == 0 ) return 0 ; let s = arr [ 0 ] ; let value = parseInt ( s ) ; let sum = value ; for ( let i = 2 ; i < n ; i = i + 2 ) { s = arr [ i ] ; value = parseInt ( s ) ; let operation = arr [ i - 1 ] [ 0 ] ; if ( operation == ' ' ) sum += value ; else sum -= value ; } return sum ; }
Hyp: 
function calculateSum ( arr , n ) { if ( n == 0 ) return 0 ; let s = arr [ 0 ] ; let sum = value ; for ( let i = 2 ; i < n ; i = i + 2 ) { s = arr [ i ] ; let value = stoi ( s ) ; let operation = arr [ i - 1 ] [ 0 ] ; if ( operation == ' ' ) sum += value ; else sum -= value ; } return sum ; }

BLEU: 89.86
Edit Sim: 40


Src: 
int nthSHN ( int n , int dp [ ] ) { if ( n == 1 n == 2 ) return dp [ n ] = 1 ; if ( dp [ n ] != -1 ) return dp [ n ] ; return dp [ n ] = ( ( 6 * n - 9 ) * nthSHN ( n - 1 , dp ) - ( n - 3 ) * nthSHN ( n - 2 , dp ) ) / n ; }
Ref: 
function nthSHN ( n , dp ) { if ( n == 1 n == 2 ) return dp [ n ] = 1 ; if ( dp [ n ] != - 1 ) return dp [ n ] ; return dp [ n ] = ( ( 6 * n - 9 ) * nthSHN ( n - 1 , dp ) - ( n - 3 ) * nthSHN ( n - 2 , dp ) ) / n ; }
Hyp: 
function nthSHN ( n , dp ) { if ( n == 1 n == 2 ) return dp [ n ] = 1 ; if ( dp [ n ] != - 1 ) return dp [ n ] ; return dp [ n ] = ( ( 6 * n - 9 ) * nthSHN ( n - 1 , dp ) - ( n - 3 ) * nthSHN ( n - 2 , dp ) ) / n ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int xorZero ( string str ) { int one_count = 0 , zero_count = 0 ; int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) if ( str [ i ] == '1' ) one_count ++ ; else zero_count ++ ; if ( one_count % 2 == 0 ) return zero_count ; return one_count ; }
Ref: 
function xorZero ( s ) { let one_count = 0 , zero_count = 0 ; let n = s . length ; for ( let i = 0 ; i < n ; i ++ ) if ( s [ i ] == ' ' ) one_count ++ ; else zero_count ++ ; if ( one_count % 2 == 0 ) return zero_count ; return one_count ; }
Hyp: 
function xorZero ( str ) { var one_count = 0 , zero_count = 0 ; var n = str . length ; for ( var i = 0 ; i < n ; i ++ ) if ( str [ i ] == ' ' ) one_count ++ ; else zero_count ++ ; if ( one_count % 2 == 0 ) return zero_count ; return one_count ; }

BLEU: 77.81
Edit Sim: 15


Src: 
void positions ( string str , int n ) { for ( int i = 0 ; i < n ; i ++ ) { cout << ( str [ i ] & NUM ) << " ▁ " ; } }
Ref: 
function positions ( str , n ) { for ( i = 0 ; i < n ; i ++ ) { document . write ( ( str [ i ] . charCodeAt ( 0 ) & NUM ) + " " ) ; } }
Hyp: 
function positions ( str , n ) { for ( let i = 0 ; i < n ; i ++ ) { document . write ( ( str [ i ] & NUM ) + " " ) ; } }

BLEU: 81.85
Edit Sim: 23


Src: 
double polite ( double n ) { n += 1 ; double base = 2 ; return n + ( log ( ( n + ( log ( n ) / log ( base ) ) ) ) ) / log ( base ) ; }
Ref: 
function polite ( n ) { n += 1 ; let base = 2 ; return n + ( Math . log ( ( n + ( Math . log ( n ) / Math . log ( base ) ) ) ) ) / Math . log ( base ) ; }
Hyp: 
function polite ( n ) { n += 1 ; let base = 2 ; return n + ( Math . log ( ( n + ( Math . log ( n ) / Math . log ( base ) ) ) ) / Math . log ( base ) ; }

BLEU: 98.1
Edit Sim: 2


Src: 
bool isRotation ( unsigned int x , unsigned int y ) { unsigned long long int x64 = x | ( ( unsigned long long int ) x << 32 ) ; while ( x64 >= y ) { if ( unsigned ( x64 ) == y ) return true ; x64 >>= 1 ; } return false ; }
Ref: 
function isRotation ( x , y ) { var x64 = x | ( x << 32 ) ; while ( x64 >= y ) { if ( x64 == y ) { return true ; } x64 >>= 1 ; } return false ; } var x = 122 ; var y = 2147483678 ; if ( isRotation ( x , y ) == false ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
Hyp: 
function isRotation ( x , y ) { var x64 = x | ( ( unsigned long long int ) x << 32 ) ; while ( x64 >= y ) { if ( unsigned ( x64 ) == y ) return true ; x64 >>= 1 ; } return false ; }

BLEU: 36.93
Edit Sim: 171


Src: 
int search ( int mat [ 4 ] [ 4 ] , int n , int x ) { if ( n == 0 ) return -1 ; int smallest = mat [ 0 ] [ 0 ] , largest = mat [ n - 1 ] [ n - 1 ] ; if ( x < smallest x > largest ) return -1 ; int i = 0 , j = n - 1 ; while ( i < n && j >= 0 ) { if ( mat [ i ] [ j ] == x ) { cout << " n ▁ Found ▁ at ▁ " << i << " , ▁ " << j ; return 1 ; } if ( mat [ i ] [ j ] > x ) j -- ; else i ++ ; } cout << " n ▁ Element ▁ not ▁ found " ; return 0 ; }
Ref: 
function search ( mat , n , x ) { let i = 0 , j = n - 1 ; while ( i < n && j >= 0 ) { if ( mat [ i ] [ j ] == x ) { document . write ( " " + i + " " + j ) ; return ; } if ( mat [ i ] [ j ] > x ) j -- ; else i ++ ; } document . write ( " " ) ; return ; }
Hyp: 
function search ( mat , n , x ) { if ( n == 0 ) return - 1 ; let smallest = mat [ 0 ] [ 0 ] , largest = mat [ n - 1 ] [ n - 1 ] ; if ( x < smallest x > largest ) return - 1 ; let i = 0 , j = n - 1 ; while ( i < n && j >= 0 ) { if ( mat [ i ] [ j ] == x ) { document . write ( " " + i + " " + j + " " ) ; return 1 ; } if ( mat [ i ] [ j ] > x ) j -- ; else i ++ ; } document . write ( " " + n + " " ) ; return 0 ; }

BLEU: 57.64
Edit Sim: 161


Src: 
int kthgroupsum ( int k ) { return k * k * k ; }
Ref: 
function kthgroupsum ( k ) { return k * k * k ; }
Hyp: 
function kthgroupsum ( k ) { return k * k * k ; }

BLEU: 100.0
Edit Sim: 0


Src: 
void equation_plane ( float x1 , float y1 , float z1 , float x2 , float y2 , float z2 , float x3 , float y3 , float z3 ) { float a1 = x2 - x1 ; float b1 = y2 - y1 ; float c1 = z2 - z1 ; float a2 = x3 - x1 ; float b2 = y3 - y1 ; float c2 = z3 - z1 ; float a = b1 * c2 - b2 * c1 ; float b = a2 * c1 - a1 * c2 ; float c = a1 * b2 - b1 * a2 ; float d = ( - a * x1 - b * y1 - c * z1 ) ; std :: cout << std :: fixed ; std :: cout << std :: setprecision ( 2 ) ; cout << " equation ▁ of ▁ plane ▁ is ▁ " << a << " ▁ x ▁ + ▁ " << b << " ▁ y ▁ + ▁ " << c << " ▁ z ▁ + ▁ " << d << " ▁ = ▁ 0 . " ; }
Ref: 
function equation_plane ( x1 , y1 , z1 , x2 , y2 , z2 , x3 , y3 , z3 ) { var a1 = x2 - x1 ; var b1 = y2 - y1 ; var c1 = z2 - z1 ; var a2 = x3 - x1 ; var b2 = y3 - y1 ; var c2 = z3 - z1 ; var a = b1 * c2 - b2 * c1 ; var b = a2 * c1 - a1 * c2 ; var c = a1 * b2 - b1 * a2 ; var d = ( - a * x1 - b * y1 - c * z1 ) ; document . write ( " " + a + " " + b + " " + c + " " + d + " " ) ; }
Hyp: 
function equation_plane ( x1 , y1 , z1 , x2 , y2 , z2 , x3 , y3 , z3 ) { var a1 = x2 - x1 ; var b1 = y2 - y1 ; var c1 = z2 - z1 ; var a2 = x3 - x1 ; var b2 = y3 - y1 ; var c2 = z3 - z1 ; var a = b1 * c2 - b2 * a2 ; var d = ( - a * x1 - b * y1 - c * z1 ) ; document . write ( " " + a + " " + b + " " + c + " " + d + " " ) ; }

BLEU: 82.98
Edit Sim: 56


Src: 
float area ( float a ) { if ( a < 0 ) return -1 ; float area = sqrt ( a ) / 6 ; return area ; }
Ref: 
function area ( a ) { if ( a < 0 ) return - 1 ; var area = Math . sqrt ( a ) / 6 ; return area ; }
Hyp: 
function area ( a ) { if ( a < 0 ) return - 1 ; var area = ( Math . sqrt ( a ) / 6 ) ; return area ; }

BLEU: 84.53
Edit Sim: 4


Src: 
void printCubes ( int a , int b ) { for ( int i = a ; i <= b ; i ++ ) { for ( int j = 1 ; j * j * j <= i ; j ++ ) { if ( j * j * j == i ) { cout << j * j * j << " ▁ " ; break ; } } } }
Ref: 
function printCubes ( a , b ) { for ( let i = a ; i <= b ; i ++ ) { for ( let j = 1 ; j * j * j <= i ; j ++ ) { if ( j * j * j == i ) { document . write ( j * j * j + " " ) ; break ; } } } }
Hyp: 
function printCubes ( a , b ) { for ( let i = a ; i <= b ; i ++ ) { for ( let j = 1 ; j * j * j <= i ; j ++ ) { if ( j * j * j == i ) { document . write ( j * j * j + " " ) ; break ; } } } }

BLEU: 100.0
Edit Sim: 0


Src: 
int maxSum ( int grid [ 2 ] [ MAX ] , int n ) { int incl = max ( grid [ 0 ] [ 0 ] , grid [ 1 ] [ 0 ] ) ; int excl = 0 , excl_new ; for ( int i = 1 ; i < n ; i ++ ) { excl_new = max ( excl , incl ) ; incl = excl + max ( grid [ 0 ] [ i ] , grid [ 1 ] [ i ] ) ; excl = excl_new ; } return max ( excl , incl ) ; }
Ref: 
function maxSum ( grid , n ) { let incl = Math . max ( grid [ 0 ] [ 0 ] , grid [ 1 ] [ 0 ] ) ; let excl = 0 , excl_new ; for ( let i = 1 ; i < n ; i ++ ) { excl_new = Math . max ( excl , incl ) ; incl = excl + Math . max ( grid [ 0 ] [ i ] , grid [ 1 ] [ i ] ) ; excl = excl_new ; } return Math . max ( excl , incl ) ; }
Hyp: 
function maxSum ( grid , n ) { let incl = Math . max ( grid [ 0 ] [ 0 ] , grid [ 1 ] [ 0 ] ) ; let excl = 0 , excl_new ; for ( let i = 1 ; i < n ; i ++ ) { excl_new = Math . max ( excl , incl ) ; incl = excl + Math . max ( grid [ 0 ] [ i ] , grid [ 1 ] [ i ] ) ; excl = excl_new ; } return max ( excl , incl ) ; }

BLEU: 96.66
Edit Sim: 7


Src: 
void printFactorialNums ( int n ) { int fact = 1 ; int x = 2 ; while ( fact <= n ) { cout << fact << " ▁ " ; fact = fact * x ; x ++ ; } }
Ref: 
function printFactorialNums ( n ) { let fact = 1 ; let x = 2 ; while ( fact <= n ) { document . write ( fact + " " ) ; fact = fact * x ; x ++ ; } }
Hyp: 
function printFactorialNums ( n ) { var fact = 1 ; var x = 2 ; while ( fact <= n ) { document . write ( fact + " " ) ; fact = fact * x ; x ++ ; } }

BLEU: 88.2
Edit Sim: 6


Src: 
void reorder ( int arr [ ] , int index [ ] , int n ) { int temp [ n ] ; for ( int i = 0 ; i < n ; i ++ ) temp [ index [ i ] ] = arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = temp [ i ] ; index [ i ] = i ; } }
Ref: 
function reorder ( arr , index , n ) { var temp = [ ... Array ( n ) ] ; for ( var i = 0 ; i < n ; i ++ ) temp [ index [ i ] ] = arr [ i ] ; for ( var i = 0 ; i < n ; i ++ ) { arr [ i ] = temp [ i ] ; index [ i ] = i ; } }
Hyp: 
function reorder ( arr , index , n ) { let temp = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) temp [ index [ i ] ] = arr [ i ] ; for ( let i = 0 ; i < n ; i ++ ) { arr [ i ] = temp [ i ] ; index [ i ] = i ; } }

BLEU: 83.37
Edit Sim: 16


Src: 
int rectCount ( int n , int m ) { return ( m * n * ( n + 1 ) * ( m + 1 ) ) / 4 ; }
Ref: 
function rectCount ( n , m ) { return parseInt ( ( m * n * ( n + 1 ) * ( m + 1 ) ) / 4 , 10 ) ; }
Hyp: 
function rectCount ( n , m ) { return ( m * n * ( n + 1 ) * ( m + 1 ) ) / 4 ; }

BLEU: 76.32
Edit Sim: 18


Src: 
void printCollatz ( int n ) { while ( n != 1 ) { cout << n << " ▁ " ; if ( n & 1 ) n = 3 * n + 1 ; else n = n / 2 ; } cout << n ; }
Ref: 
function printCollatz ( n ) { while ( n != 1 ) { document . write ( n + " " ) ; if ( ( n & 1 ) != 0 ) n = 3 * n + 1 ; else n = parseInt ( n / 2 , 10 ) ; } document . write ( n ) ; }
Hyp: 
function printCollatz ( n ) { while ( n != 1 ) { document . write ( n + " " ) ; if ( n & 1 ) n = 3 * n + 1 ; else n = parseInt ( n / 2 ) ; } document . write ( n + " " ) ; }

BLEU: 82.47
Edit Sim: 20


Src: 
double Series ( int n ) { int i ; double sums = 0.0 , ser ; for ( i = 1 ; i <= n ; ++ i ) { ser = 1 / pow ( i , i ) ; sums += ser ; } return sums ; }
Ref: 
function Series ( n ) { let sums = 0.0 ; for ( let i = 1 ; i < n + 1 ; i ++ ) { ser = 1 / Math . pow ( i , i ) ; sums += ser ; } return sums ; }
Hyp: 
function Series ( n ) { let i ; let sums = 0.0 , ser ; for ( i = 1 ; i <= n ; ++ i ) { ser = 1 / Math . pow ( i , i ) ; sums += ser ; } return sums ; }

BLEU: 72.04
Edit Sim: 25


Src: 
int term ( int n ) { int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) ans += i ; return ans ; }
Ref: 
function term ( n ) { let ans = 0 ; for ( let i = 1 ; i <= n ; i ++ ) ans += i ; return ans ; }
Hyp: 
function term ( n ) { let ans = 0 ; for ( let i = 1 ; i <= n ; i ++ ) ans += i ; return ans ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int countNonDecreasing ( int n ) { int N = 10 ; long long count = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { count *= ( N + i - 1 ) ; count /= i ; } return count ; }
Ref: 
function countNonDecreasing ( n ) { let N = 10 ; let count = 1 ; for ( let i = 1 ; i <= n ; i ++ ) { count *= ( N + i - 1 ) ; count = Math . floor ( count / i ) ; } return count ; }
Hyp: 
function countNonDecreasing ( n ) { let N = 10 ; let count = 1 ; for ( let i = 1 ; i <= n ; i ++ ) { count *= ( N + i - 1 ) ; count /= i ; } return count ; }

BLEU: 81.12
Edit Sim: 26


Src: 
int maxProduct ( int arr [ ] , int n ) { if ( n < 3 ) return -1 ; int max_product = INT_MIN ; for ( int i = 0 ; i < n - 2 ; i ++ ) for ( int j = i + 1 ; j < n - 1 ; j ++ ) for ( int k = j + 1 ; k < n ; k ++ ) max_product = max ( max_product , arr [ i ] * arr [ j ] * arr [ k ] ) ; return max_product ; }
Ref: 
function maxProduct ( arr , n ) { if ( n < 3 ) return - 1 ; let max_product = Number . MIN_VALUE ; for ( let i = 0 ; i < n - 2 ; i ++ ) for ( let j = i + 1 ; j < n - 1 ; j ++ ) for ( let k = j + 1 ; k < n ; k ++ ) max_product = Math . max ( max_product , arr [ i ] * arr [ j ] * arr [ k ] ) ; return max_product ; }
Hyp: 
function maxProduct ( arr , n ) { if ( n < 3 ) return - 1 ; let max_product = Number . MAX_VALUE ; for ( let i = 0 ; i < n - 2 ; i ++ ) for ( let j = i + 1 ; j < n - 1 ; j ++ ) for ( let k = j + 1 ; k < n ; k ++ ) max_product = Math . max ( max_product , arr [ i ] * arr [ j ] * arr [ k ] ) ; return max_product ; }

BLEU: 97.54
Edit Sim: 2


Src: 
int count ( int S [ ] , int m , int n ) { int table [ n + 1 ] ; memset ( table , 0 , sizeof ( table ) ) ; table [ 0 ] = 1 ; for ( int i = 0 ; i < m ; i ++ ) for ( int j = S [ i ] ; j <= n ; j ++ ) table [ j ] += table [ j - S [ i ] ] ; return table [ n ] ; }
Ref: 
function count ( S , m , n ) { let table = new Array ( n + 1 ) ; table . fill ( 0 ) ; table [ 0 ] = 1 ; for ( let i = 0 ; i < m ; i ++ ) for ( let j = S [ i ] ; j <= n ; j ++ ) table [ j ] += table [ j - S [ i ] ] ; return table [ n ] ; }
Hyp: 
function count ( S , m , n ) { let table = new Array ( n + 1 ) ; for ( let i = 0 ; i < m ; i ++ ) table [ i ] = 0 ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = S [ i ] ; j <= n ; j ++ ) table [ j ] += table [ j - S [ i ] ] ; return table [ n ] ; }

BLEU: 79.94
Edit Sim: 26


Src: 
int countCommon ( int mat [ ] [ MAX ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( mat [ i ] [ i ] == mat [ i ] [ n - i - 1 ] ) res ++ ; return res ; }
Ref: 
function countCommon ( mat , n ) { let res = 0 ; for ( let i = 0 ; i < n ; i ++ ) if ( mat [ i ] [ i ] == mat [ i ] [ n - i - 1 ] ) res ++ ; return res ; }
Hyp: 
function countCommon ( mat , n ) { let res = 0 ; for ( let i = 0 ; i < n ; i ++ ) if ( mat [ i ] [ i ] == mat [ i ] [ n - i - 1 ] ) res ++ ; return res ; }

BLEU: 100.0
Edit Sim: 0


Src: 
bool isOverflow ( long long a , long long b ) { if ( a == 0 b == 0 ) return false ; long long result = a * b ; if ( a == result / b ) return false ; else return true ; }
Ref: 
function isOverflow ( a , b ) { if ( a == 0 b == 0 ) return false ; var result = a * b ; if ( result >= 9223372036854775807 result <= - 9223372036854775808 ) result = 0 if ( a == parseInt ( result / b ) ) return false ; else return true ; }
Hyp: 
function isOverflow ( a , b ) { if ( a == 0 b == 0 ) return false ; let result = a * b ; if ( a == result / b ) return false ; else return true ; }

BLEU: 60.39
Edit Sim: 96


Src: 
int countOccurrences ( int arr [ ] , int n , int x ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( x == arr [ i ] ) res ++ ; return res ; }
Ref: 
function countOccurrences ( arr , n , x ) { let res = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( x == arr [ i ] ) res ++ ; } return res ; }
Hyp: 
function countOccurrences ( arr , n , x ) { let res = 0 ; for ( let i = 0 ; i < n ; i ++ ) if ( x == arr [ i ] ) res ++ ; return res ; }

BLEU: 88.94
Edit Sim: 4


Src: 
int pairsInSortedRotated ( int arr [ ] , int n , int x ) { int i ; for ( i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] > arr [ i + 1 ] ) break ; int l = ( i + 1 ) % n ; int r = i ; int cnt = 0 ; while ( l != r ) { if ( arr [ l ] + arr [ r ] == x ) { cnt ++ ; if ( l == ( r - 1 + n ) % n ) { return cnt ; } l = ( l + 1 ) % n ; r = ( r - 1 + n ) % n ; } else if ( arr [ l ] + arr [ r ] < x ) l = ( l + 1 ) % n ; else r = ( n + r - 1 ) % n ; } return cnt ; }
Ref: 
function pairsInSortedRotated ( arr , n , x ) { let i ; for ( i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] > arr [ i + 1 ] ) break ; let l = ( i + 1 ) % n ; let r = i ; let cnt = 0 ; while ( l != r ) { if ( arr [ l ] + arr [ r ] == x ) { cnt ++ ; if ( l == ( r - 1 + n ) % n ) { return cnt ; } l = ( l + 1 ) % n ; r = ( r - 1 + n ) % n ; } else if ( arr [ l ] + arr [ r ] < x ) l = ( l + 1 ) % n ; else r = ( n + r - 1 ) % n ; } return cnt ; }
Hyp: 
function pairsInSortedRotated ( arr , n , x ) { let i ; for ( i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] > arr [ i + 1 ] ) break ; let l = ( i + 1 ) % n ; let r = i ; let cnt = 0 ; while ( l != r ) { if ( arr [ l ] + arr [ r ] == x ) { cnt ++ ; if ( l == ( r - 1 + n ) % n ) { return cnt ; } l = ( l + 1 ) % n ; r = ( r - 1 + n ) % n ; } else if ( arr [ l ] + arr [ r ] < x ) l = ( l + 1 ) % n ; else r = ( n + r - 1 ) % n ; } return cnt ; }

BLEU: 100.0
Edit Sim: 0


Src: 
void mirror_point ( float a , float b , float c , float d , float x1 , float y1 , float z1 ) { float k = ( - a * x1 - b * y1 - c * z1 - d ) / ( float ) ( a * a + b * b + c * c ) ; float x2 = a * k + x1 ; float y2 = b * k + y1 ; float z2 = c * k + z1 ; float x3 = 2 * x2 - x1 ; float y3 = 2 * y2 - y1 ; float z3 = 2 * z2 - z1 ; std :: cout << std :: fixed ; std :: cout << std :: setprecision ( 1 ) ; cout << " ▁ x3 ▁ = ▁ " << x3 ; cout << " ▁ y3 ▁ = ▁ " << y3 ; cout << " ▁ z3 ▁ = ▁ " << z3 ; }
Ref: 
function mirror_point ( a , b , c , d , x1 , y1 , z1 ) { var k = parseFloat ( ( - a * x1 - b * y1 - c * z1 - d ) / parseFloat ( a * a + b * b + c * c ) ) ; var x2 = parseFloat ( a * k + x1 ) ; var y2 = parseFloat ( b * k + y1 ) ; var z2 = parseFloat ( c * k + z1 ) ; var x3 = parseFloat ( 2 * x2 - x1 ) . toFixed ( 1 ) ; var y3 = parseFloat ( 2 * y2 - y1 ) . toFixed ( 1 ) ; var z3 = parseFloat ( 2 * z2 - z1 ) . toFixed ( 1 ) ; document . write ( " " + x3 ) ; document . write ( " " + y3 ) ; document . write ( " " + z3 ) ; }
Hyp: 
function mirror_point ( a , b , c , d , x1 , y1 , z1 ) { let k = ( - a * x1 - b * y1 - c * z1 - d ) / ( float ) ( a * a + b * b + c * c ) ; let x2 = a * k + x1 ; let y2 = b * k + y1 ; let z2 = c * k + z1 ; let x3 = 2 * x2 - x1 ; document . write ( " " + x3 ) ; document . write ( " " + y3 ) ; document . write ( " " + z3 ) ; }

BLEU: 50.15
Edit Sim: 220


Src: 
float exponential ( int n , float x ) { float sum = 1.0f ; for ( int i = n - 1 ; i > 0 ; -- i ) sum = 1 + x * sum / i ; return sum ; }
Ref: 
function exponential ( n , x ) { var sum = 1 ; for ( i = n - 1 ; i > 0 ; -- i ) sum = 1 + x * sum / i ; return sum ; }
Hyp: 
function exponential ( n , x ) { let sum = 1.0f ; for ( let i = n - 1 ; i > 0 ; -- i ) sum = 1 + x * sum / i ; return sum ; }

BLEU: 82.4
Edit Sim: 10


Src: 
int countSteps ( int n ) { int steps = 0 ; while ( n ) { int largest = sqrt ( n ) ; n -= ( largest * largest ) ; steps ++ ; } return steps ; }
Ref: 
function countSteps ( n ) { let steps = 0 ; while ( n ) { let largest = Math . floor ( Math . sqrt ( n ) ) ; n -= ( largest * largest ) ; steps ++ ; } return steps ; }
Hyp: 
function countSteps ( n ) { let steps = 0 ; while ( n ) { let largest = Math . sqrt ( n ) ; n -= ( largest * largest ) ; steps ++ ; } return steps ; }

BLEU: 86.53
Edit Sim: 17


Src: 
float correlationCoefficient ( int X [ ] , int Y [ ] , int n ) { int sum_X = 0 , sum_Y = 0 , sum_XY = 0 ; int squareSum_X = 0 , squareSum_Y = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum_X = sum_X + X [ i ] ; sum_Y = sum_Y + Y [ i ] ; sum_XY = sum_XY + X [ i ] * Y [ i ] ; squareSum_X = squareSum_X + X [ i ] * X [ i ] ; squareSum_Y = squareSum_Y + Y [ i ] * Y [ i ] ; } float corr = ( float ) ( n * sum_XY - sum_X * sum_Y ) / sqrt ( ( n * squareSum_X - sum_X * sum_X ) * ( n * squareSum_Y - sum_Y * sum_Y ) ) ; return corr ; }
Ref: 
function correlationCoefficient ( X , Y , n ) { let sum_X = 0 , sum_Y = 0 , sum_XY = 0 ; let squareSum_X = 0 , squareSum_Y = 0 ; for ( let i = 0 ; i < n ; i ++ ) { sum_X = sum_X + X [ i ] ; sum_Y = sum_Y + Y [ i ] ; sum_XY = sum_XY + X [ i ] * Y [ i ] ; squareSum_X = squareSum_X + X [ i ] * X [ i ] ; squareSum_Y = squareSum_Y + Y [ i ] * Y [ i ] ; } let corr = ( n * sum_XY - sum_X * sum_Y ) / ( Math . sqrt ( ( n * squareSum_X - sum_X * sum_X ) * ( n * squareSum_Y - sum_Y * sum_Y ) ) ) ; return corr ; }
Hyp: 
function correlationCoefficient ( X , Y , n ) { var sum_X = 0 , sum_Y = 0 , sum_XY = 0 ; var squareSum_X = 0 , squareSum_Y = 0 ; for ( var i = 0 ; i < n ; i ++ ) { sum_X = sum_X + X [ i ] ; sum_Y = sum_Y + Y [ i ] ; sum_XY = sum_XY + X [ i ] * X [ i ] ; squareSum_X = squareSum_X + X [ i ] * Y [ i ] ; squareSum_Y = squareSum_Y + Y [ i ] * Y [ i ] ; } var corr = ( n * sum_XY - sum_X * sum_Y ) / Math . sqrt ( ( n * squareSum_X - sum_X * sum_X ) * ( n * squareSum_Y - sum_Y * sum_Y ) ) ; return corr ; }

BLEU: 90.8
Edit Sim: 18


Src: 
float hexDiagonal ( float a ) { if ( a < 0 ) return -1 ; float d = 1.73 * a ; return d ; }
Ref: 
function hexDiagonal ( a ) { if ( a < 0 ) return - 1 ; var d = 1.73 * a ; return d ; }
Hyp: 
function hexDiagonal ( a ) { if ( a < 0 ) return - 1 ; var d = 1.73 * a ; return d ; }

BLEU: 100.0
Edit Sim: 0


Src: 
string isTriangleExists ( int a , int b , int c ) { if ( a != 0 && b != 0 && c != 0 && ( a + b + c ) == 180 ) if ( ( a + b ) >= c || ( b + c ) >= a || ( a + c ) >= b ) return " YES " ; else return " NO " ; else return " NO " ; }
Ref: 
function isTriangleExists ( a , b , c ) { if ( a != 0 && b != 0 && c != 0 && ( a + b + c ) == 180 ) if ( ( a + b ) >= c || ( b + c ) >= a || ( a + c ) >= b ) return " " ; else return " " ; else return " " ; }
Hyp: 
function isTriangleExists ( a , b , c ) { if ( a != 0 && b != 0 && c != 0 && ( a + b + c ) == 180 ) if ( ( a + b ) >= c || ( b + c ) >= a || ( a + c ) >= b ) return " " ; else return " " ; }

BLEU: 93.11
Edit Sim: 18


Src: 
int countDivisors ( int n ) { int cnt = 0 ; for ( int i = 1 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) cnt ++ ; cnt = cnt + 2 ; } } return cnt ; }
Ref: 
function countDivisors ( n ) { let cnt = 0 ; for ( let i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) cnt ++ ; cnt = cnt + 2 ; } } return cnt ; }
Hyp: 
function countDivisors ( n ) { let cnt = 0 ; for ( let i = 1 ; i <= parseInt ( Math . sqrt ( n ) , 10 ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) cnt ++ ; cnt = cnt + 2 ; } } return cnt ; }

BLEU: 89.16
Edit Sim: 18


Src: 
int minimumCost ( int cost [ ] , int n ) { int dp1 = 0 , dp2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int dp0 = cost [ i ] + min ( dp1 , dp2 ) ; dp2 = dp1 ; dp1 = dp0 ; } return min ( dp1 , dp2 ) ; }
Ref: 
function minimumCost ( cost , n ) { let dp1 = 0 , dp2 = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let dp0 = cost [ i ] + Math . min ( dp1 , dp2 ) ; dp2 = dp1 ; dp1 = dp0 ; } return Math . min ( dp1 , dp2 ) ; }
Hyp: 
function minimumCost ( cost , n ) { let dp1 = 0 , dp2 = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let dp0 = cost [ i ] + Math . min ( dp1 , dp2 ) ; dp2 = dp1 ; dp1 = dp0 ; } return Math . min ( dp1 , dp2 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int findOddPair ( int A [ ] , int N ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( ( A [ i ] % 2 == 1 ) ) count ++ ; return count * ( count - 1 ) / 2 ; }
Ref: 
function findOddPair ( A , N ) { let count = 0 ; for ( let i = 0 ; i < N ; i ++ ) if ( ( A [ i ] % 2 == 1 ) ) count ++ ; return count * ( count - 1 ) / 2 ; }
Hyp: 
function findOddPair ( A , N ) { var count = 0 ; for ( var i = 0 ; i < N ; i ++ ) if ( ( A [ i ] % 2 == 1 ) ) count ++ ; return count * ( count - 1 ) / 2 ; }

BLEU: 90.64
Edit Sim: 6


Src: 
int setRightmostUnsetBit ( int n ) { if ( ( n & ( n + 1 ) ) == 0 ) return n ; return n | ( n + 1 ) ; }
Ref: 
function setRightmostUnsetBit ( n ) { if ( ( n & ( n + 1 ) ) == 0 ) return n ; return n | ( n + 1 ) ; }
Hyp: 
function setRightmostUnsetBit ( n ) { if ( ( n & ( n + 1 ) ) == 0 ) return n ; return n | ( n + 1 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
void distance ( float a1 , float b1 , float c1 , float a2 , float b2 , float c2 ) { float d = ( a1 * a2 + b1 * b2 + c1 * c2 ) ; float e1 = sqrt ( a1 * a1 + b1 * b1 + c1 * c1 ) ; float e2 = sqrt ( a2 * a2 + b2 * b2 + c2 * c2 ) ; d = d / ( e1 * e2 ) ; float pi = 3.14159 ; float A = ( 180 / pi ) * ( acos ( d ) ) ; cout << " Angle ▁ is ▁ " << A << " ▁ degree " ; }
Ref: 
function distance ( a1 , b1 , c1 , a2 , b2 , c2 ) { var d = a1 * a2 + b1 * b2 + c1 * c2 ; var e1 = Math . sqrt ( a1 * a1 + b1 * b1 + c1 * c1 ) ; var e2 = Math . sqrt ( a2 * a2 + b2 * b2 + c2 * c2 ) ; d = parseFloat ( d / ( e1 * e2 ) ) ; var pi = 3.14159 ; var A = ( 180 / pi ) * Math . acos ( d ) ; document . write ( " " + A . toFixed ( 1 ) + " " ) ; }
Hyp: 
function distance ( a1 , b1 , c1 , a2 , b2 , c2 ) { var d = ( a1 * a2 + b1 * b2 + c1 * c2 ) ; var e1 = Math . sqrt ( a1 * a1 + b1 * b1 + c1 * c1 ) ; var e2 = Math . sqrt ( a2 * a2 + b2 * b2 + c2 * c2 ) ; d = d / ( e1 * e2 ) ; var pi = 3.14159 ; var A = ( 180 / pi ) * ( Math . acos ( d ) ) ; document . write ( " " + A + " " ) ; }

BLEU: 87.07
Edit Sim: 39


Src: 
int Circumference ( int a ) { return 4 * a ; }
Ref: 
function Circumference ( a ) { return 4 * a ; }
Hyp: 
function Circumference ( a ) { return 4 * a ; }

BLEU: 100.0
Edit Sim: 0


Src: 
bool isSubsetSum ( int arr [ ] , int n , int sum ) { bool subset [ 2 ] [ sum + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= sum ; j ++ ) { if ( j == 0 ) subset [ i % 2 ] [ j ] = true ; else if ( i == 0 ) subset [ i % 2 ] [ j ] = false ; else if ( arr [ i - 1 ] <= j ) subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j - arr [ i - 1 ] ] || subset [ ( i + 1 ) % 2 ] [ j ] ; else subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j ] ; } } return subset [ n % 2 ] [ sum ] ; }
Ref: 
function isSubsetSum ( arr , n , sum ) { let subset = new Array ( 2 ) ; for ( var i = 0 ; i < subset . length ; i ++ ) { subset [ i ] = new Array ( 2 ) ; } for ( let i = 0 ; i <= n ; i ++ ) { for ( let j = 0 ; j <= sum ; j ++ ) { if ( j == 0 ) subset [ i % 2 ] [ j ] = true ; else if ( i == 0 ) subset [ i % 2 ] [ j ] = false ; else if ( arr [ i - 1 ] <= j ) subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j - arr [ i - 1 ] ] || subset [ ( i + 1 ) % 2 ] [ j ] ; else subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j ] ; } } return subset [ n % 2 ] [ sum ] ; }
Hyp: 
function isSubsetSum ( arr , n , sum ) { let subset = new Array ( 2 ) ; for ( let i = 0 ; i <= n ; i ++ ) { for ( let j = 0 ; j <= sum ; j ++ ) { if ( j == 0 ) subset [ i % 2 ] [ j ] = true ; else if ( i == 0 ) subset [ i % 2 ] [ j ] = false ; else if ( arr [ i - 1 ] <= j ) subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j - arr [ i - 1 ] ] || subset [ ( i + 1 ) % 2 ] [ j ] ; else subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j ] ; } } return subset [ n % 2 ] [ sum ] ; }

BLEU: 85.15
Edit Sim: 84


Src: 
string printSequence ( string arr [ ] , string input ) { string output = " " ; int n = input . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( input [ i ] == ' ▁ ' ) output = output + "0" ; else { int position = input [ i ] - ' A ' ; output = output + arr [ position ] ; } } return output ; }
Ref: 
function printSequence ( arr , input ) { let output = " " ; let n = input . length ; for ( let i = 0 ; i < n ; i ++ ) { if ( input [ i ] == ' ' ) output = output + " " . charCodeAt ( 0 ) ; else { let position = input [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ; output = output + arr [ position ] ; } } return output ; }
Hyp: 
function printSequence ( arr , input ) { let output = " " ; let n = input . length ; let i ; for ( i = 0 ; i < n ; i ++ ) { if ( input [ i ] == ' ' ) output = output + " " ; else { let position = input [ i ] . charCodeAt ( 0 ) - 65 ; output = output + arr [ position ] ; } } return output ; }

BLEU: 80.84
Edit Sim: 52


Src: 
int numofstring ( int n , int m ) { if ( n == 1 ) return m ; if ( n == 2 ) return m * ( m - 1 ) ; return m * ( m - 1 ) * pow ( m - 2 , n - 2 ) ; }
Ref: 
function numofstring ( n , m ) { if ( n == 1 ) return m ; if ( n == 2 ) return m * ( m - 1 ) ; return m * ( m - 1 ) * Math . pow ( m - 2 , n - 2 ) ; }
Hyp: 
function numofstring ( n , m ) { if ( n == 1 ) return m ; if ( n == 2 ) return m * ( m - 1 ) ; return m * ( m - 1 ) * Math . pow ( m - 2 , n - 2 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
float CubeVolume ( float d ) { float Volume ; Volume = ( sqrt ( 3 ) * pow ( d , 3 ) ) / 9 ; return Volume ; }
Ref: 
function CubeVolume ( d ) { let Volume ; Volume = ( Math . sqrt ( 3 ) * Math . pow ( d , 3 ) ) / 9 ; return Volume ; }
Hyp: 
function CubeVolume ( d ) { let Volume ; Volume = ( Math . sqrt ( 3 ) * Math . pow ( d , 3 ) ) / 9 ; return Volume ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int SieveOfSundaram ( int n ) { int nNew = ( n - 1 ) / 2 ; bool marked [ nNew + 1 ] ; memset ( marked , false , sizeof ( marked ) ) ; for ( int i = 1 ; i <= nNew ; i ++ ) for ( int j = i ; ( i + j + 2 * i * j ) <= nNew ; j ++ ) marked [ i + j + 2 * i * j ] = true ; if ( n > 2 ) cout << 2 << " ▁ " ; for ( int i = 1 ; i <= nNew ; i ++ ) if ( marked [ i ] == false ) cout << 2 * i + 1 << " ▁ " ; }
Ref: 
function SieveOfSundaram ( n ) { let nNew = ( n - 1 ) / 2 ; let marked = [ ] ; for ( let i = 0 ; i < nNew + 1 ; i ++ ) marked [ i ] = false ; for ( let i = 1 ; i <= nNew ; i ++ ) for ( let j = i ; ( i + j + 2 * i * j ) <= nNew ; j ++ ) marked [ i + j + 2 * i * j ] = true ; if ( n > 2 ) document . write ( 2 + " " ) ; for ( let i = 1 ; i <= nNew ; i ++ ) if ( marked [ i ] == false ) document . write ( 2 * i + 1 + " " ) ; return - 1 ; }
Hyp: 
function SieveOfSundaram ( n ) { let nNew = parseInt ( ( n - 1 ) / 2 ) ; let marked = new Array ( nNew + 1 ) ; for ( let i = 1 ; i <= nNew ; i ++ ) marked [ i ] = false ; for ( let i = 1 ; i <= nNew ; i ++ ) for ( let j = i ; ( i + j + 2 * i * j ) <= nNew ; j ++ ) marked [ i + j + 2 * i * j ] = true ; if ( n > 2 ) document . write ( 2 + " " ) ; for ( let i = 1 ; i <= nNew ; i ++ ) if ( marked [ i ] == false ) document . write ( 2 * i + 1 + " " ) ; }

BLEU: 88.18
Edit Sim: 53


Src: 
string noAdjacentDup ( string s ) { int n = s . length ( ) ; for ( int i = 1 ; i < n ; i ++ ) { if ( s [ i ] == s [ i - 1 ] ) { s [ i ] = ' a ' ; while ( s [ i ] == s [ i - 1 ] || ( i + 1 < n && s [ i ] == s [ i + 1 ] ) ) s [ i ] ++ ; i ++ ; } } return s ; }
Ref: 
function noAdjacentDup ( s1 ) { let n = s1 . length ; let s = s1 . split ( ' ' ) ; for ( let i = 1 ; i < n ; i ++ ) { if ( s [ i ] == s [ i - 1 ] ) { s [ i ] = ' ' ; while ( s [ i ] == s [ i - 1 ] || ( i + 1 < n && s [ i ] == s [ i + 1 ] ) ) s [ i ] ++ ; i ++ ; } } return ( s ) ; }
Hyp: 
function noAdjacentDup ( s ) { let n = s . length ; let arr = s . split ( " " ) ; for ( let i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == s [ i - 1 ] ) { arr [ i ] = ' ' ; while ( arr [ i ] == s [ i + 1 ] ) arr [ i ] ++ ; i ++ ; } } return arr . join ( " " ) ; }

BLEU: 58.66
Edit Sim: 73


Src: 
int cen_octagonalnum ( long int n ) { return ( 4 * n * n - 4 * n + 1 ) ; }
Ref: 
function centeredoctagonalNumber ( n ) { return 4 * n * ( n - 1 ) + 1 ; }
Hyp: 
function cen_octagonalnum ( n ) { return ( 4 * n * n - 4 * n + 1 ) ; }

BLEU: 40.06
Edit Sim: 18


Src: 
int highestPowerof2 ( int n ) { int p = ( int ) log2 ( n ) ; return ( int ) pow ( 2 , p ) ; }
Ref: 
function highestPowerof2 ( n ) { let p = parseInt ( Math . log ( n ) / Math . log ( 2 ) , 10 ) ; return Math . pow ( 2 , p ) ; }
Hyp: 
function highestPowerof2 ( n ) { let p = Math . log2 ( n ) ; return ( Math . pow ( 2 , p ) ) ; }

BLEU: 48.98
Edit Sim: 42


Src: 
int sum ( int N ) { int S1 , S2 , S3 ; S1 = ( ( N / 2 ) ) * ( 2 * 2 + ( N / 2 - 1 ) * 2 ) / 2 ; S2 = ( ( N / 7 ) ) * ( 2 * 7 + ( N / 7 - 1 ) * 7 ) / 2 ; S3 = ( ( N / 14 ) ) * ( 2 * 14 + ( N / 14 - 1 ) * 14 ) / 2 ; return S1 + S2 - S3 ; }
Ref: 
function sum ( N ) { var S1 , S2 , S3 ; S1 = ( ( ( N / 2 ) ) * parseInt ( 2 * 2 + parseInt ( N / 2 - 1 ) * 2 ) / 2 ) ; S2 = ( parseInt ( parseInt ( N / 7 ) ) * ( 2 * 7 + parseInt ( N / 7 - 1 ) * 7 ) / 2 ) ; S3 = ( parseInt ( parseInt ( N / 14 ) ) * ( 2 * 14 + parseInt ( N / 14 - 1 ) * 14 ) / 2 ) ; return S1 + S2 - S3 ; }
Hyp: 
function sum ( N ) { let S1 , S2 , S3 ; S1 = ( ( N / 2 ) ) * ( 2 * 2 + ( N / 2 - 1 ) * 2 ) / 2 ; S2 = ( ( N / 7 ) ) * ( 2 * 7 + ( N / 7 - 1 ) * 7 ) / 2 ; S3 = ( ( N / 14 ) ) * ( 2 * 14 + ( N / 14 - 1 ) * 14 ) / 2 ; return S1 + S2 - S3 ; }

BLEU: 73.34
Edit Sim: 87


Src: 
void printCharWithFreq ( string str ) { int n = str . size ( ) ; int freq [ SIZE ] ; memset ( freq , 0 , sizeof ( freq ) ) ; for ( int i = 0 ; i < n ; i ++ ) freq [ str [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < n ; i ++ ) { if ( freq [ str [ i ] - ' a ' ] != 0 ) { cout << str [ i ] << freq [ str [ i ] - ' a ' ] << " ▁ " ; freq [ str [ i ] - ' a ' ] = 0 ; } } }
Ref: 
function printCharWithFreq ( str ) { let n = str . length ; let freq = new Array ( SIZE ) ; for ( let i = 0 ; i < freq . length ; i ++ ) { freq [ i ] = 0 ; } for ( let i = 0 ; i < n ; i ++ ) freq [ str [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; for ( let i = 0 ; i < n ; i ++ ) { if ( freq [ str [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] != 0 ) { document . write ( str [ i ] ) ; document . write ( freq [ str [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] + " " ) ; freq [ str [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] = 0 ; } } }
Hyp: 
function printCharWithFreq ( str ) { let n = str . length ; let freq = new Array ( SIZE ) ; for ( let i = 0 ; i < n ; i ++ ) freq [ str [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; for ( let i = 0 ; i < n ; i ++ ) { if ( freq [ str [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] != 0 ) { document . write ( str [ i ] + " " ) ; freq [ str [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] = 0 ; } } }

BLEU: 68.72
Edit Sim: 152


Src: 
void countPermutations ( int N , int B ) { int x = pow ( B , N ) ; int y = pow ( B , N - 1 ) ; cout << x - y << " STRNEWLINE " ; }
Ref: 
function countPermutations ( N , B ) { var x = Math . pow ( B , N ) ; var y = Math . pow ( B , N - 1 ) ; document . write ( x - y ) ; }
Hyp: 
function countPermutations ( N , B ) { let x = Math . pow ( B , N ) ; let y = Math . pow ( B , N - 1 ) ; document . write ( x - y + " " ) ; }

BLEU: 79.01
Edit Sim: 12


Src: 
int numLen ( int K ) { if ( K % 2 == 0 K % 5 == 0 ) return -1 ; int number = 0 ; int len = 1 ; for ( len = 1 ; len <= K ; len ++ ) { number = ( number * 10 + 1 ) % K ; if ( number == 0 ) return len ; } return -1 ; }
Ref: 
function numLen ( K ) { if ( K % 2 == 0 K % 5 == 0 ) return - 1 ; var number = 0 ; var len = 1 ; for ( len = 1 ; len <= K ; len ++ ) { number = ( number * 10 + 1 ) % K ; if ( number == 0 ) return len ; } return - 1 ; }
Hyp: 
function numLen ( K ) { if ( K % 2 == 0 K % 5 == 0 ) return - 1 ; let number = 0 ; let len = 1 ; for ( len = 1 ; len <= K ; len ++ ) { number = ( number * 10 + 1 ) % K ; if ( number == 0 ) return len ; } return - 1 ; }

BLEU: 93.1
Edit Sim: 6


Src: 
void printSubsets ( int n ) { for ( int i = 0 ; i <= n ; i ++ ) if ( ( n & i ) == i ) cout << i << " ▁ " ; }
Ref: 
function printSubsets ( n ) { for ( let i = n ; i > 0 ; i = ( i - 1 ) & n ) document . write ( i + " " ) ; document . write ( " " ) ; }
Hyp: 
function printSubsets ( n ) { for ( let i = 0 ; i <= n ; i ++ ) if ( ( n & i ) == i ) document . write ( i + " " ) ; }

BLEU: 54.32
Edit Sim: 42


Src: 
int sumOfSeries ( int n ) { return 0.6172 * ( pow ( 10 , n ) - 1 ) - 0.55 * n ; }
Ref: 
function sumOfSeries ( n ) { return parseInt ( ( 0.6172 * ( Math . pow ( 10 , n ) - 1 ) - 0.55 * n ) ) ; }
Hyp: 
function sumOfSeries ( n ) { return 0.6172 * ( Math . pow ( 10 , n ) - 1 ) - 0.55 * n ; }

BLEU: 73.94
Edit Sim: 17


Src: 
int maxValue ( int n ) { if ( n == 1 ) return 0 ; return ( ( n * n / 2 ) - 1 ) ; }
Ref: 
function maxValue ( n ) { if ( n == 1 ) return 0 ; return ( parseInt ( n * n / 2 ) - 1 ) ; }
Hyp: 
function maxValue ( n ) { if ( n == 1 ) return 0 ; return ( ( n * n / 2 ) - 1 ) ; }

BLEU: 91.28
Edit Sim: 9


Src: 
int maxRevenue ( int m , int x [ ] , int revenue [ ] , int n , int t ) { int maxRev [ m + 1 ] ; memset ( maxRev , 0 , sizeof ( maxRev ) ) ; int nxtbb = 0 ; for ( int i = 1 ; i <= m ; i ++ ) { if ( nxtbb < n ) { if ( x [ nxtbb ] != i ) maxRev [ i ] = maxRev [ i - 1 ] ; else { if ( i <= t ) maxRev [ i ] = max ( maxRev [ i - 1 ] , revenue [ nxtbb ] ) ; else maxRev [ i ] = max ( maxRev [ i - t - 1 ] + revenue [ nxtbb ] , maxRev [ i - 1 ] ) ; nxtbb ++ ; } } else maxRev [ i ] = maxRev [ i - 1 ] ; } return maxRev [ m ] ; }
Ref: 
function maxRevenue ( m , x , revenue , n , t ) { let maxRev = new Array ( m + 1 ) ; for ( let i = 0 ; i < m + 1 ; i ++ ) maxRev [ i ] = 0 ; let nxtbb = 0 ; for ( let i = 1 ; i <= m ; i ++ ) { if ( nxtbb < n ) { if ( x [ nxtbb ] != i ) maxRev [ i ] = maxRev [ i - 1 ] ; else { if ( i <= t ) maxRev [ i ] = Math . max ( maxRev [ i - 1 ] , revenue [ nxtbb ] ) ; else maxRev [ i ] = Math . max ( maxRev [ i - t - 1 ] + revenue [ nxtbb ] , maxRev [ i - 1 ] ) ; nxtbb ++ ; } } else maxRev [ i ] = maxRev [ i - 1 ] ; } return maxRev [ m ] ; }
Hyp: 
function maxRevenue ( m , x , revenue , n , t ) { let maxRev = new Array ( m + 1 ) ; for ( let i = 0 ; i <= m ; i ++ ) { if ( maxRev [ i ] == maxRev [ i - 1 ] ) { if ( i <= t ) maxRev [ i ] = Math . max ( maxRev [ i - 1 ] , revenue [ nxtbb ] ) ; else maxRev [ i ] = Math . max ( maxRev [ i - t - 1 ] + revenue [ nxtbb ] , maxRev [ i - 1 ] ) ; nxtbb ++ ; } } else maxRev [ i ] = maxRev [ i - 1 ] ; } return maxRev [ m ] ; }

BLEU: 70.66
Edit Sim: 117


Src: 
void sortExceptUandL ( int a [ ] , int l , int u , int n ) { int b [ n - ( u - l + 1 ) ] ; for ( int i = 0 ; i < l ; i ++ ) b [ i ] = a [ i ] ; for ( int i = u + 1 ; i < n ; i ++ ) b [ l + ( i - ( u + 1 ) ) ] = a [ i ] ; sort ( b , b + n - ( u - l + 1 ) ) ; for ( int i = 0 ; i < l ; i ++ ) a [ i ] = b [ i ] ; for ( int i = u + 1 ; i < n ; i ++ ) a [ i ] = b [ l + ( i - ( u + 1 ) ) ] ; }
Ref: 
function sortExceptUandL ( a , l , u , n ) { let b = [ ] ; for ( let i = 0 ; i < l ; i ++ ) b [ i ] = a [ i ] ; for ( let i = u + 1 ; i < n ; i ++ ) b [ l + ( i - ( u + 1 ) ) ] = a [ i ] ; b . sort ( ) ; for ( let i = 0 ; i < l ; i ++ ) a [ i ] = b [ i ] ; for ( let i = u + 1 ; i < n ; i ++ ) a [ i ] = b [ l + ( i - ( u + 1 ) ) ] ; }
Hyp: 
function sortExceptUandL ( a , l , u , n ) { var b = new Array ( n - ( u - l + 1 ) ) ; for ( i = 0 ; i < l ; i ++ ) b [ i ] = a [ i ] ; for ( i = u + 1 ; i < n ; i ++ ) b [ l + ( i - ( u + 1 ) ) ] = a [ i ] ; sort ( b , b + n - ( u - l + 1 ) ) ; for ( i = 0 ; i < l ; i ++ ) a [ i ] = b [ i ] ; for ( i = u + 1 ; i < n ; i ++ ) a [ i ] = b [ l + ( i - ( u + 1 ) ) ] ; }

BLEU: 76.23
Edit Sim: 74


Src: 
int PowerOFPINnfactorial ( int n , int p ) { int ans = 0 ; int temp = p ; while ( temp <= n ) { ans += n / temp ; temp = temp * p ; } return ans ; }
Ref: 
function PowerOFPINnfactorial ( n , p ) { let ans = 0 ; let temp = p ; while ( temp <= n ) { ans += n / temp ; temp = temp * p ; } return ans ; }
Hyp: 
function PowerOFPINnfactorial ( n , p ) { let ans = 0 ; let temp = p ; while ( temp <= n ) { ans += n / temp ; temp = temp * p ; } return ans ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int eulerian ( int n , int m ) { int dp [ n + 1 ] [ m + 1 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= m ; j ++ ) { if ( i > j ) { if ( j == 0 ) dp [ i ] [ j ] = 1 ; else dp [ i ] [ j ] = ( ( i - j ) * dp [ i - 1 ] [ j - 1 ] ) + ( ( j + 1 ) * dp [ i - 1 ] [ j ] ) ; } } } return dp [ n ] [ m ] ; }
Ref: 
function eulerian ( n , m ) { var dp = Array . from ( Array ( n + 1 ) , ( ) => Array ( m + 1 ) . fill ( 0 ) ) ; for ( var i = 1 ; i <= n ; i ++ ) { for ( var j = 0 ; j <= m ; j ++ ) { if ( i > j ) { if ( j == 0 ) dp [ i ] [ j ] = 1 ; else dp [ i ] [ j ] = ( ( i - j ) * dp [ i - 1 ] [ j - 1 ] ) + ( ( j + 1 ) * dp [ i - 1 ] [ j ] ) ; } } } return dp [ n ] [ m ] ; }
Hyp: 
function eulerian ( n , m ) { let dp = new Array ( n + 1 ) ; for ( let i = 0 ; i < n + 1 ; i ++ ) { dp [ i ] = new Array ( m + 1 ) ; for ( let j = 0 ; j <= m ; j ++ ) { if ( i > j ) { if ( j == 0 ) dp [ i ] [ j ] = 1 ; else dp [ i ] [ j ] = ( ( i - j ) * dp [ i - 1 ] [ j - 1 ] ) + ( ( j + 1 ) * dp [ i - 1 ] [ j ] ) ; } } } return dp [ n ] [ m ] ; }

BLEU: 79.41
Edit Sim: 68


Src: 
int nonDecNums ( int n ) { int a [ n + 1 ] [ 10 ] ; for ( int i = 0 ; i <= 9 ; i ++ ) a [ 0 ] [ i ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) a [ i ] [ 9 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 8 ; j >= 0 ; j -- ) a [ i ] [ j ] = a [ i - 1 ] [ j ] + a [ i ] [ j + 1 ] ; return a [ n ] [ 0 ] ; }
Ref: 
function nonDecNums ( n ) { let a = new Array ( n + 1 ) for ( let i = 0 ; i < n + 1 ; i ++ ) { a [ i ] = new Array ( 10 ) ; } for ( let i = 0 ; i <= 9 ; i ++ ) a [ 0 ] [ i ] = 1 ; for ( let i = 1 ; i <= n ; i ++ ) a [ i ] [ 9 ] = 1 ; for ( let i = 1 ; i <= n ; i ++ ) for ( let j = 8 ; j >= 0 ; j -- ) a [ i ] [ j ] = a [ i - 1 ] [ j ] + a [ i ] [ j + 1 ] ; return a [ n ] [ 0 ] ; }
Hyp: 
function nonDecNums ( n ) { var a = Array ( n + 1 ) . fill ( 0 ) ; for ( var i = 0 ; i <= 9 ; i ++ ) a [ 0 ] [ i ] = 1 ; for ( var i = 1 ; i <= n ; i ++ ) a [ i ] [ 9 ] = 1 ; for ( var i = 1 ; i <= n ; i ++ ) for ( var j = 8 ; j >= 0 ; j -- ) a [ i ] [ j ] = a [ i - 1 ] [ j ] + a [ i ] [ j + 1 ] ; return a [ n ] [ 0 ] ; }

BLEU: 71.17
Edit Sim: 78


Src: 
bool isPowerOfTwo ( int n ) { if ( n == 0 ) return 0 ; while ( n != 1 ) { if ( n % 2 != 0 ) return 0 ; n = n / 2 ; } return 1 ; }
Ref: 
function isPowerOfTwo ( n ) { if ( n == 0 ) return 0 ; while ( n != 1 ) { if ( n % 2 != 0 ) return 0 ; n = n / 2 ; } return 1 ; }
Hyp: 
function isPowerOfTwo ( n ) { if ( n == 0 ) return 0 ; while ( n != 1 ) { if ( n % 2 != 0 ) return 0 ; n = Math . floor ( n / 2 ) ; } return 1 ; }

BLEU: 83.24
Edit Sim: 17


Src: 
double Series ( double x , int n ) { double sum = 1 , term = 1 , fct = 1 , p = 1 , multi = 1 ; for ( int i = 1 ; i < n ; i ++ ) { fct = fct * multi * ( multi + 1 ) ; p = p * x * x ; term = ( -1 ) * term ; multi += 2 ; sum = sum + ( term * p ) / fct ; } return sum ; }
Ref: 
function Series ( x , n ) { var sum = 1 , term = 1 , fct = 1 ; var p = 1 , multi = 1 ; for ( let i = 1 ; i < n ; i ++ ) { fct = fct * multi * ( multi + 1 ) ; p = p * x * x ; term = ( - 1 ) * term ; multi += 2 ; sum = sum + ( term * p ) / fct ; } return sum ; }
Hyp: 
function Series ( x , n ) { let sum = 1 , term = 1 , fct = 1 , p = 1 , multi = 1 ; for ( let i = 1 ; i < n ; i ++ ) { fct = fct * multi * ( multi + 1 ) ; p = p * x * x ; term = ( - 1 ) * term ; multi += 2 ; sum = sum + ( term * p ) / fct ; } return sum ; }

BLEU: 93.59
Edit Sim: 8


Src: 
int countSubStr ( string str , int n ) { int len = str . length ( ) ; return ( len - n + 1 ) ; }
Ref: 
function countSubStr ( str , n ) { var len = str . length ; return len - n + 1 ; }
Hyp: 
function countSubStr ( str , n ) { let len = str . length ; return ( len - n + 1 ) ; }

BLEU: 68.43
Edit Sim: 7


Src: 
int findMajority ( int arr [ ] , int n ) { return arr [ n / 2 ] ; }
Ref: 
function findMajority ( arr , n ) { return arr [ Math . floor ( n / 2 ) ] ; }
Hyp: 
function findMajority ( arr , n ) { return arr [ parseInt ( n / 2 ) ] ; }

BLEU: 78.32
Edit Sim: 11


Src: 
int countOrderedPairs ( int N ) { int count_pairs = 0 ; for ( int i = 1 ; i <= sqrt ( N - 1 ) ; ++ i ) { for ( int j = i ; j * i < N ; ++ j ) ++ count_pairs ; } count_pairs *= 2 ; count_pairs -= int ( sqrt ( N - 1 ) ) ; return count_pairs ; }
Ref: 
function countOrderedPairs ( N ) { var count_pairs = 0 ; for ( var i = 1 ; i <= Math . sqrt ( N - 1 ) ; ++ i ) { for ( var j = i ; j * i < N ; ++ j ) ++ count_pairs ; } count_pairs *= 2 ; count_pairs -= parseInt ( Math . sqrt ( N - 1 ) ) ; return count_pairs ; }
Hyp: 
function countOrderedPairs ( N ) { let count_pairs = 0 ; for ( let i = 1 ; i <= parseInt ( Math . sqrt ( N - 1 ) , 10 ) ; ++ i ) { for ( let j = i ; j * i < N ; ++ j ) ++ count_pairs ; } count_pairs *= 2 ; count_pairs -= int ( Math . sqrt ( N - 1 ) ) ; return count_pairs ; }

BLEU: 79.0
Edit Sim: 33


Src: 
int maxvolume ( int s ) { int length = s / 3 ; s -= length ; int breadth = s / 2 ; int height = s - breadth ; return length * breadth * height ; }
Ref: 
function maxvolume ( s ) { let length = parseInt ( s / 3 ) ; s -= length ; let breadth = parseInt ( s / 2 ) ; let height = s - breadth ; return length * breadth * height ; }
Hyp: 
function maxvolume ( s ) { let length = s / 3 ; s -= length ; let breadth = Math . floor ( s / 2 ) ; let height = s - breadth ; return length * breadth * height ; }

BLEU: 80.3
Edit Sim: 24


Src: 
int countWays ( int n ) { int count = 0 ; for ( int i = 1 ; i * i < n ; i ++ ) if ( n % i == 0 ) count ++ ; return count ; }
Ref: 
function countWays ( n ) { let count = 0 ; for ( let i = 1 ; i * i < n ; i ++ ) if ( n % i == 0 ) count ++ ; return count ; }
Hyp: 
function countWays ( n ) { let count = 0 ; for ( let i = 1 ; i * i < n ; i ++ ) if ( n % i == 0 ) count ++ ; return count ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int averageEven ( int n ) { if ( n % 2 != 0 ) { cout << " Invalid ▁ Input " ; return -1 ; } return ( n + 2 ) / 2 ; }
Ref: 
function averageEven ( n ) { if ( n % 2 != 0 ) { document . write ( " " ) ; return - 1 ; } return ( n + 2 ) / 2 ; }
Hyp: 
function averageEven ( n ) { if ( n % 2 != 0 ) { document . write ( " " ) ; return - 1 ; } return ( n + 2 ) / 2 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int evenPowerSum ( int n ) { long long int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int j = 2 * i ; sum = sum + ( j * j * j * j ) ; } return sum ; }
Ref: 
function evenPowerSum ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { let j = 2 * i ; sum = sum + ( j * j * j * j ) ; } return sum ; }
Hyp: 
function evenPowerSum ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { let j = 2 * i ; sum = sum + ( j * j * j * j ) ; } return sum ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int kthgroupsum ( int k ) { int cur = ( k * ( k - 1 ) ) + 1 ; int sum = 0 ; while ( k -- ) { sum += cur ; cur += 2 ; } return sum ; }
Ref: 
function kthgroupsum ( k ) { let cur = ( k * ( k - 1 ) ) + 1 ; let sum = 0 ; while ( k -- ) { sum += cur ; cur += 2 ; } return sum ; }
Hyp: 
function kthgroupsum ( k ) { let cur = ( k * ( k - 1 ) ) + 1 ; let sum = 0 ; while ( k -- ) { sum += cur ; cur += 2 ; } return sum ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int solve ( int A [ ] , int B [ ] , int C [ ] , int i , int j , int k ) { int min_diff , current_diff , max_term ; min_diff = Integer . MAX_VALUE ; while ( i != -1 && j != -1 && k != -1 ) { current_diff = abs ( max ( A [ i ] , max ( B [ j ] , C [ k ] ) ) - min ( A [ i ] , min ( B [ j ] , C [ k ] ) ) ) ; if ( current_diff < min_diff ) min_diff = current_diff ; max_term = max ( A [ i ] , max ( B [ j ] , C [ k ] ) ) ; if ( A [ i ] == max_term ) i -= 1 ; else if ( B [ j ] == max_term ) j -= 1 ; else k -= 1 ; } return min_diff ; }
Ref: 
function solve ( A , B , C ) { let i , j , k ; i = A . length - 1 ; j = B . length - 1 ; k = C . length - 1 ; let min_diff , current_diff , max_term ; min_diff = Math . abs ( Math . max ( A [ i ] , Math . max ( B [ j ] , C [ k ] ) ) - Math . min ( A [ i ] , Math . min ( B [ j ] , C [ k ] ) ) ) ; while ( i != - 1 && j != - 1 && k != - 1 ) { current_diff = Math . abs ( Math . max ( A [ i ] , Math . max ( B [ j ] , C [ k ] ) ) - Math . min ( A [ i ] , Math . min ( B [ j ] , C [ k ] ) ) ) ; if ( current_diff < min_diff ) min_diff = current_diff ; max_term = Math . max ( A [ i ] , Math . max ( B [ j ] , C [ k ] ) ) ; if ( A [ i ] == max_term ) i -= 1 ; else if ( B [ j ] == max_term ) j -= 1 ; else k -= 1 ; } return min_diff ; }
Hyp: 
function solve ( A , B , C , i , j , k ) { let min_diff , current_diff , max_term ; min_diff = Number . MAX_VALUE ; while ( i != - 1 && j != - 1 && k != - 1 ) { current_diff = Math . abs ( Math . max ( A [ i ] , Math . max ( B [ j ] , C [ k ] ) ) - Math . min ( A [ i ] , Math . min ( B [ j ] , C [ k ] ) ) ; if ( current_diff < min_diff ) min_diff = current_diff ; max_term = Math . max ( A [ i ] , Math . max ( B [ j ] , C [ k ] ) ) ; if ( A [ i ] == max_term ) i -= 1 ; else if ( B [ j ] == max_term ) j -= 1 ; else k -= 1 ; } return min_diff ; }

BLEU: 61.38
Edit Sim: 198


Src: 
string removeChars ( string s ) { string modifiedStr = " " ; modifiedStr += s [ 0 ] ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) { if ( isupper ( s [ i ] ) && islower ( s [ i - 1 ] ) || islower ( s [ i ] ) && isupper ( s [ i - 1 ] ) ) modifiedStr += s [ i ] ; } return modifiedStr ; }
Ref: 
function removeChars ( s ) { let modifiedStr = " " ; modifiedStr += s [ 0 ] ; for ( let i = 1 ; i < s . length ; i ++ ) { if ( s [ i ] == ( s [ i ] ) . toUpperCase ( ) && ( s [ i - 1 ] ) == ( s [ i - 1 ] ) . toLowerCase ( ) || s [ i ] == s [ i ] . toLowerCase ( ) && ( s [ i - 1 ] ) == ( s [ i - 1 ] ) . toUpperCase ( ) ) modifiedStr += s [ i ] ; } return modifiedStr ; }
Hyp: 
function removeChars ( s ) { let modifiedStr = " " ; modifiedStr += s [ 0 ] ; for ( let i = 1 ; i < s . length ; i ++ ) { if ( ( s [ i ] ) && islower ( s [ i - 1 ] ) || isupper ( s [ i ] ) && isupper ( s [ i - 1 ] ) ) modifiedStr += s [ i ] ; } return modifiedStr ; }

BLEU: 54.07
Edit Sim: 124


Src: 
int equilibrium ( int arr [ ] , int n ) { int i , j ; int leftsum , rightsum ; for ( i = 0 ; i < n ; ++ i ) { leftsum = 0 ; rightsum = 0 ; for ( j = 0 ; j < i ; j ++ ) leftsum += arr [ j ] ; for ( j = i + 1 ; j < n ; j ++ ) rightsum += arr [ j ] ; if ( leftsum == rightsum ) return i ; } return -1 ; }
Ref: 
function equilibrium ( arr , n ) { var i , j ; var leftsum , rightsum ; for ( i = 0 ; i < n ; ++ i ) { leftsum = 0 ; rightsum = 0 ; for ( let j = 0 ; j < i ; j ++ ) leftsum += arr [ j ] ; for ( let j = i + 1 ; j < n ; j ++ ) rightsum += arr [ j ] ; if ( leftsum == rightsum ) return i ; } return - 1 ; }
Hyp: 
function equilibrium ( arr , n ) { let i , j ; let leftsum , rightsum ; for ( i = 0 ; i < n ; ++ i ) { leftsum = 0 ; rightsum = 0 ; for ( j = 0 ; j < i ; j ++ ) leftsum += arr [ j ] ; for ( j = i + 1 ; j < n ; j ++ ) rightsum += arr [ j ] ; if ( leftsum == rightsum ) return i ; } return - 1 ; }

BLEU: 90.13
Edit Sim: 14


Src: 
int findKCF ( int x , int y , int k ) { int small = min ( x , y ) ; int count = 1 ; for ( int i = 2 ; i <= small ; i ++ ) { if ( x % i == 0 && y % i == 0 ) count ++ ; if ( count == k ) return i ; } return -1 ; }
Ref: 
function findKHCF ( x , y , k ) { let small = Math . min ( x , y ) ; let count = 1 ; for ( let i = 2 ; i <= small ; i ++ ) { if ( x % i == 0 && y % i == 0 ) count ++ ; if ( count == k ) return i ; } return - 1 ; }
Hyp: 
function findKCF ( x , y , k ) { let small = Math . min ( x , y ) ; let count = 1 ; for ( let i = 2 ; i <= small ; i ++ ) { if ( x % i == 0 && y % i == 0 ) count ++ ; if ( count == k ) return i ; } return - 1 ; }

BLEU: 97.61
Edit Sim: 1


Src: 
void printAMeans ( int A , int B , int N ) { float d = ( float ) ( B - A ) / ( N + 1 ) ; for ( int i = 1 ; i <= N ; i ++ ) cout << ( A + i * d ) << " ▁ " ; }
Ref: 
function printAMeans ( A , B , N ) { let d = ( B - A ) / ( N + 1 ) ; for ( let i = 1 ; i <= N ; i ++ ) document . write ( ( A + i * d ) + " " ) ; }
Hyp: 
function printAMeans ( A , B , N ) { let d = ( B - A ) / ( N + 1 ) ; for ( let i = 1 ; i <= N ; i ++ ) document . write ( ( A + i * d ) + " " ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
bool isSymmetric ( int mat [ ] [ MAX ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) return false ; return true ; }
Ref: 
function isSymmetric ( mat , N ) { for ( let i = 0 ; i < N ; i ++ ) for ( let j = 0 ; j < N ; j ++ ) if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) return false ; return true ; }
Hyp: 
function isSymmetric ( mat , N ) { for ( let i = 0 ; i < N ; i ++ ) for ( let j = 0 ; j < N ; j ++ ) if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) return false ; return true ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int breakSum ( int n ) { if ( n == 0 n == 1 ) return n ; return max ( ( breakSum ( n / 2 ) + breakSum ( n / 3 ) + breakSum ( n / 4 ) ) , n ) ; }
Ref: 
function breakSum ( n ) { if ( n == 0 n == 1 ) return n ; return Math . max ( ( breakSum ( Math . floor ( n / 2 ) ) + breakSum ( Math . floor ( n / 3 ) ) + breakSum ( Math . floor ( n / 4 ) ) ) , n ) ; }
Hyp: 
function breakSum ( n ) { if ( n == 0 n == 1 ) return n ; return Math . max ( ( breakSum ( n / 2 ) + breakSum ( n / 3 ) + breakSum ( n / 4 ) ) , n ) ; }

BLEU: 67.57
Edit Sim: 51


Src: 
int sum ( int L , int R ) { int p = R / 6 ; int q = ( L - 1 ) / 6 ; int sumR = 3 * ( p * ( p + 1 ) ) ; int sumL = ( q * ( q + 1 ) ) * 3 ; return sumR - sumL ; }
Ref: 
function sum ( L , R ) { let p = Math . floor ( R / 6 ) ; let q = Math . floor ( ( L - 1 ) / 6 ) ; let sumR = Math . floor ( 3 * ( p * ( p + 1 ) ) ) ; let sumL = Math . floor ( ( q * ( q + 1 ) ) * 3 ) ; return sumR - sumL ; }
Hyp: 
function sum ( L , R ) { let p = R / 6 ; let q = ( L - 1 ) / 6 ; let sumR = 3 * ( p * ( p + 1 ) ) ; let sumL = ( q * ( q + 1 ) ) * 3 ; return sumR - sumL ; }

BLEU: 58.75
Edit Sim: 68


Src: 
void max_area ( int n , int m , int k ) { if ( k > ( n + m - 2 ) ) cout << " Not ▁ possible " << endl ; else { int result ; if ( k < max ( m , n ) - 1 ) { result = max ( m * ( n / ( k + 1 ) ) , n * ( m / ( k + 1 ) ) ) ; } else { result = max ( m / ( k - n + 2 ) , n / ( k - m + 2 ) ) ; } cout << result << endl ; } }
Ref: 
function max_area ( n , m , k ) { if ( k > ( n + m - 2 ) ) document . write ( " " ) ; else { let result ; if ( k < Math . max ( m , n ) - 1 ) { result = Math . max ( m * ( n / ( k + 1 ) ) , n * ( m / ( k + 1 ) ) ) ; } else { result = Math . max ( m / ( k - n + 2 ) , n / ( k - m + 2 ) ) ; } document . write ( result ) ; } }
Hyp: 
function max_area ( n , m , k ) { if ( k > ( n + m - 2 ) ) document . write ( " " ) ; else { let result ; if ( k < Math . max ( m , n ) - 1 ) { result = Math . max ( m * ( n / ( k + 1 ) ) , n * ( m / ( k + 1 ) ) ) ; } else { result = Math . max ( m / ( k - n + 2 ) , n / ( k - m + 2 ) ) ; } document . write ( result ) ; } }

BLEU: 100.0
Edit Sim: 0


Src: 
int countSubArrays ( const int * arr , int n , int K ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { int bitwise_or = 0 ; for ( int k = i ; k <= j ; k ++ ) { bitwise_or = bitwise_or | arr [ k ] ; } if ( bitwise_or >= K ) count ++ ; } } return count ; }
Ref: 
function countSubArrays ( arr , n , K ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i ; j < n ; j ++ ) { let bitwise_or = 0 ; for ( let k = i ; k <= j ; k ++ ) { bitwise_or = bitwise_or | arr [ k ] ; } if ( bitwise_or >= K ) count ++ ; } } return count ; }
Hyp: 
function countSubArrays ( arr , n , K ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i ; j < n ; j ++ ) { let bitwise_or = 0 ; for ( let k = i ; k <= j ; k ++ ) { bitwise_or = bitwise_or | arr [ k ] ; } if ( bitwise_or >= K ) count ++ ; } } return count ; }

BLEU: 100.0
Edit Sim: 0


Src: 
void thirdLargest ( int arr [ ] , int arr_size ) { if ( arr_size < 3 ) { printf ( " ▁ Invalid ▁ Input ▁ " ) ; return ; } int first = arr [ 0 ] ; for ( int i = 1 ; i < arr_size ; i ++ ) if ( arr [ i ] > first ) first = arr [ i ] ; int second = INT_MIN ; for ( int i = 0 ; i < arr_size ; i ++ ) if ( arr [ i ] > second && arr [ i ] < first ) second = arr [ i ] ; int third = INT_MIN ; for ( int i = 0 ; i < arr_size ; i ++ ) if ( arr [ i ] > third && arr [ i ] < second ) third = arr [ i ] ; printf ( " The ▁ third ▁ Largest ▁ element ▁ is ▁ % d STRNEWLINE " , third ) ; }
Ref: 
function thirdLargest ( arr , arr_size ) { if ( arr_size < 3 ) { document . write ( " " ) ; return ; } let first = arr [ 0 ] ; for ( let i = 1 ; i < arr_size ; i ++ ) if ( arr [ i ] > first ) first = arr [ i ] ; let second = Number . MIN_VALUE ; for ( let i = 0 ; i < arr_size ; i ++ ) if ( arr [ i ] > second && arr [ i ] < first ) second = arr [ i ] ; let third = Number . MIN_VALUE ; for ( let i = 0 ; i < arr_size ; i ++ ) if ( arr [ i ] > third && arr [ i ] < second ) third = arr [ i ] ; document . write ( " " + " " , third ) ; }
Hyp: 
function thirdLargest ( arr , arr_size ) { if ( arr_size < 3 ) { document . write ( " " ) ; return ; } let first = arr [ 0 ] ; for ( let i = 1 ; i < arr_size ; i ++ ) if ( arr [ i ] > first ) first = arr [ i ] ; let second = Number . MAX_VALUE ; for ( let i = 0 ; i < arr_size ; i ++ ) if ( arr [ i ] > second && arr [ i ] < first ) second = arr [ i ] ; let third = Number . MAX_VALUE ; for ( let i = 0 ; i < arr_size ; i ++ ) if ( arr [ i ] > third && arr [ i ] < second ) third = arr [ i ] ; document . write ( " " + third ) ; }

BLEU: 94.21
Edit Sim: 10


Src: 
void reverse ( string str , int x ) { int n = ( str . length ( ) - x ) / 2 ; for ( int i = 0 ; i < n ; i ++ ) cout << str [ i ] ; for ( int i = n + x - 1 ; i >= n ; i -- ) cout << str [ i ] ; for ( int i = n + x ; i < str . length ( ) ; i ++ ) cout << str [ i ] ; }
Ref: 
function reverse ( str , x ) { var n = ( str . length - x ) / 2 ; for ( i = 0 ; i < n ; i ++ ) document . write ( str . charAt ( i ) ) ; for ( i = n + x - 1 ; i >= n ; i -- ) document . write ( str . charAt ( i ) ) ; for ( i = n + x ; i < str . length ; i ++ ) document . write ( str . charAt ( i ) ) ; }
Hyp: 
function reverse ( str , x ) { let n = parseInt ( ( str . length - x ) / 2 ) ; for ( let i = 0 ; i < n ; i ++ ) document . write ( str [ i ] ) ; for ( let i = n + x - 1 ; i >= n ; i -- ) document . write ( str [ i ] ) ; for ( let i = n + x ; i < str . length ; i ++ ) document . write ( str [ i ] ) ; }

BLEU: 72.23
Edit Sim: 61


Src: 
int nthTerm ( int N ) { int nth = 0 , i ; for ( i = N ; i > 0 ; i -- ) { nth += pow ( i , i ) ; } return nth ; }
Ref: 
function nthTerm ( N ) { let nth = 0 , i ; for ( i = N ; i > 0 ; i -- ) { nth += Math . pow ( i , i ) ; } return nth ; }
Hyp: 
function nthTerm ( N ) { let nth = 0 , i ; for ( i = N ; i > 0 ; i -- ) { nth += Math . pow ( i , i ) ; } return nth ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int sumNodes ( int l ) { int leafNodeCount = pow ( 2 , l - 1 ) ; int sumLastLevel = 0 ; sumLastLevel = ( leafNodeCount * ( leafNodeCount + 1 ) ) / 2 ; int sum = sumLastLevel * l ; return sum ; }
Ref: 
function sumNodes ( l ) { let leafNodeCount = Math . pow ( 2 , l - 1 ) ; let sumLastLevel = 0 ; sumLastLevel = ( leafNodeCount * ( leafNodeCount + 1 ) ) / 2 ; let sum = sumLastLevel * l ; return sum ; }
Hyp: 
function sumNodes ( l ) { let leafNodeCount = Math . pow ( 2 , l - 1 ) ; let sumLastLevel = 0 ; sumLastLevel = ( leafNodeCount * ( leafNodeCount + 1 ) ) / 2 ; let sum = sumLastLevel * l ; return sum ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int maxAND ( int L , int R ) { int maximum = L & R ; for ( int i = L ; i < R ; i ++ ) for ( int j = i + 1 ; j <= R ; j ++ ) maximum = max ( maximum , ( i & j ) ) ; return maximum ; }
Ref: 
function maxAND ( L , R ) { var maximum = L & R ; for ( var i = L ; i < R ; i ++ ) for ( var j = i + 1 ; j <= R ; j ++ ) maximum = Math . max ( maximum , ( i & j ) ) ; return maximum ; }
Hyp: 
function maxAND ( L , R ) { let maximum = L & R ; for ( let i = L ; i < R ; i ++ ) for ( let j = i + 1 ; j <= R ; j ++ ) maximum = Math . max ( maximum , ( i & j ) ) ; return maximum ; }

BLEU: 87.92
Edit Sim: 9


Src: 
int findSum ( int N , int K ) { int ans = 0 ; for ( int i = 1 ; i <= N ; i ++ ) ans += ( i % K ) ; return ans ; }
Ref: 
function findSum ( N , K ) { let ans = 0 ; for ( let i = 1 ; i <= N ; i ++ ) ans += ( i % K ) ; return ans ; }
Hyp: 
function findSum ( N , K ) { let ans = 0 ; for ( let i = 1 ; i <= N ; i ++ ) ans += ( i % K ) ; return ans ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int maxbalancedprefix ( char str [ ] , int n ) { int sum = 0 ; int maxi = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == ' ( ' ) sum += 1 ; else sum -= 1 ; if ( sum < 0 ) break ; if ( sum == 0 ) maxi = i + 1 ; } return maxi ; }
Ref: 
function maxbalancedprefix ( str , n ) { var sum = 0 ; var maxi = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( str [ i ] == ' ' ) sum += 1 ; else sum -= 1 ; if ( sum < 0 ) break ; if ( sum == 0 ) maxi = i + 1 ; } return maxi ; }
Hyp: 
function maxbalancedprefix ( str , n ) { sum = 0 ; let maxi = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( str [ i ] == ' ' ) sum += 1 ; else sum -= 1 ; if ( sum < 0 ) break ; if ( sum == 0 ) maxi = i + 1 ; } return maxi ; }

BLEU: 90.02
Edit Sim: 10


Src: 
int avg_of_even_num ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += 2 * i ; return sum / n ; }
Ref: 
function avg_of_even_num ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) sum += 2 * i ; return sum / n ; }
Hyp: 
function avg_of_even_num ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) sum += 2 * i ; return sum / n ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int middleOfThree ( int a , int b , int c ) { if ( a > b ) { if ( b > c ) return b ; else if ( a > c ) return c ; else return a ; } else { if ( a > c ) return a ; else if ( b > c ) return c ; else return b ; } }
Ref: 
function middleOfThree ( a , b , c ) { if ( a > b ) { if ( b > c ) return b ; else if ( a > c ) return c ; else return a ; } else { if ( a > c ) return a ; else if ( b > c ) return c ; else return b ; } }
Hyp: 
function middleOfThree ( a , b , c ) { if ( a > b ) { if ( b > c ) return b ; else if ( a > c ) return c ; else return a ; } else { if ( a > c ) return a ; else if ( b > c ) return c ; else return b ; } }

BLEU: 100.0
Edit Sim: 0


Src: 
int seriesSum ( int n ) { return ( n * ( n + 1 ) * ( n + 2 ) ) / 6 ; }
Ref: 
function seriesSum ( n ) { return ( n * ( n + 1 ) * ( n + 2 ) ) / 6 ; }
Hyp: 
function seriesSum ( n ) { return ( n * ( n + 1 ) * ( n + 2 ) ) / 6 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
bool Valid ( int a , int b , int c , int d ) { if ( a + b + c + d == 360 ) return true ; return false ; }
Ref: 
function Valid ( a , b , c , d ) { if ( a + b + c + d == 360 ) return 1 ; return 0 ; }
Hyp: 
function Valid ( a , b , c , d ) { if ( a + b + c + d == 360 ) return true ; return false ; }

BLEU: 84.84
Edit Sim: 9


Src: 
int binarySearch ( int arr [ ] , int low , int high ) { if ( high >= low ) { int mid = ( low + high ) / 2 ; if ( mid == arr [ mid ] ) return mid ; if ( mid > arr [ mid ] ) return binarySearch ( arr , ( mid + 1 ) , high ) ; else return binarySearch ( arr , low , ( mid - 1 ) ) ; } return -1 ; }
Ref: 
function binarySearch ( arr , low , high ) { if ( high >= low ) { let mid = Math . floor ( ( low + high ) / 2 ) ; if ( mid == arr [ mid ] ) return mid ; if ( mid > arr [ mid ] ) return binarySearch ( arr , ( mid + 1 ) , high ) ; else return binarySearch ( arr , low , ( mid - 1 ) ) ; } return - 1 ; }
Hyp: 
function binarySearch ( arr , low , high ) { if ( high >= low ) { let mid = parseInt ( ( low + high ) / 2 ) ; if ( mid == arr [ mid ] ) return mid ; if ( mid > arr [ mid ] ) return binarySearch ( arr , ( mid + 1 ) , high ) ; else return binarySearch ( arr , low , ( mid - 1 ) ) ; } return - 1 ; }

BLEU: 94.88
Edit Sim: 11


Src: 
int solve ( int a [ ] , int n ) { int min1 = a [ 0 ] ; int max1 = a [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > max1 ) max1 = a [ i ] ; if ( a [ i ] < min1 ) min1 = a [ i ] ; } return abs ( min1 - max1 ) ; }
Ref: 
function solve ( a , n ) { let min1 = a [ 0 ] ; let max1 = a [ 0 ] ; for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] > max1 ) max1 = a [ i ] ; if ( a [ i ] < min1 ) min1 = a [ i ] ; } return Math . abs ( min1 - max1 ) ; }
Hyp: 
function solve ( a , n ) { let min1 = a [ 0 ] ; let max1 = a [ 0 ] ; for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] > max1 ) max1 = a [ i ] ; if ( a [ i ] < min1 ) min1 = a [ i ] ; } return Math . abs ( min1 - max1 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int minChanges ( int A [ ] , int n ) { int cnt = 0 ; for ( int i = 0 ; i < n - 2 ; ++ i ) { if ( ( i - 1 >= 0 ) && A [ i - 1 ] == 1 && A [ i + 1 ] == 1 && A [ i ] == 0 ) { A [ i + 1 ] = 0 ; cnt ++ ; } } return cnt ; }
Ref: 
function minChanges ( A , n ) { var cnt = 0 ; for ( var i = 0 ; i < n - 2 ; ++ i ) { if ( ( i - 1 >= 0 ) && A [ i - 1 ] == 1 && A [ i + 1 ] == 1 && A [ i ] == 0 ) { A [ i + 1 ] = 0 ; cnt ++ ; } } return cnt ; }
Hyp: 
function minChanges ( A , n ) { let cnt = 0 ; for ( let i = 0 ; i < n - 2 ; ++ i ) { if ( ( i - 1 >= 0 ) && A [ i - 1 ] == 1 && A [ i + 1 ] == 1 && A [ i ] == 0 ) { A [ i + 1 ] = 0 ; cnt ++ ; } } return cnt ; }

BLEU: 93.93
Edit Sim: 6


Src: 
int evenSum ( int n ) { int C [ n + 1 ] [ n + 1 ] ; int i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= min ( i , n ) ; j ++ ) { if ( j == 0 j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } int sum = 0 ; for ( int i = 0 ; i <= n ; i += 2 ) sum += C [ n ] [ i ] ; return sum ; }
Ref: 
function evenSum ( n ) { var C = Array . from ( Array ( n + 1 ) , ( ) => Array ( n + 1 ) . fill ( 0 ) ) ; var i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= Math . min ( i , n ) ; j ++ ) { if ( j == 0 j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } var sum = 0 ; for ( var i = 0 ; i <= n ; i += 2 ) sum += C [ n ] [ i ] ; return sum ; }
Hyp: 
function evenSum ( n ) { let C = new Array ( n + 1 ) ; for ( let i = 0 ; i <= n ; i ++ ) { for ( let j = 0 ; j <= Math . min ( i , n ) ; j ++ ) { if ( j == 0 j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } let sum = 0 ; for ( let i = 0 ; i <= n ; i += 2 ) sum += C [ n ] [ i ] ; return sum ; }

BLEU: 75.47
Edit Sim: 80


Src: 
int minAdjustmentCost ( int A [ ] , int n , int target ) { int dp [ n ] [ M + 1 ] ; for ( int j = 0 ; j <= M ; j ++ ) dp [ 0 ] [ j ] = abs ( j - A [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j <= M ; j ++ ) { dp [ i ] [ j ] = INT_MAX ; for ( int k = max ( j - target , 0 ) ; k <= min ( M , j + target ) ; k ++ ) dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ i - 1 ] [ k ] + abs ( A [ i ] - j ) ) ; } } int res = INT_MAX ; for ( int j = 0 ; j <= M ; j ++ ) res = min ( res , dp [ n - 1 ] [ j ] ) ; return res ; }
Ref: 
function minAdjustmentCost ( A , n , target ) { let dp = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { dp [ i ] = new Array ( n ) ; for ( let j = 0 ; j <= M ; j ++ ) { dp [ i ] [ j ] = 0 ; } } for ( let j = 0 ; j <= M ; j ++ ) dp [ 0 ] [ j ] = Math . abs ( j - A [ 0 ] ) ; for ( let i = 1 ; i < n ; i ++ ) { for ( let j = 0 ; j <= M ; j ++ ) { dp [ i ] [ j ] = Number . MAX_VALUE ; let k = Math . max ( j - target , 0 ) ; for ( ; k <= Math . min ( M , j + target ) ; k ++ ) dp [ i ] [ j ] = Math . min ( dp [ i ] [ j ] , dp [ i - 1 ] [ k ] + Math . abs ( A [ i ] - j ) ) ; } } let res = Number . MAX_VALUE ; for ( let j = 0 ; j <= M ; j ++ ) res = Math . min ( res , dp [ n - 1 ] [ j ] ) ; return res ; }
Hyp: 
function minAdjustmentCost ( A , n , target ) { let dp = new Array ( n ) ; for ( let j = 0 ; j <= M ; j ++ ) dp [ 0 ] [ j ] = Math . abs ( j - A [ 0 ] ) ; for ( let i = 1 ; i < n ; i ++ ) { for ( let j = 0 ; j <= M ; j ++ ) { dp [ i ] [ j ] = Number . MAX_VALUE ; for ( let k = Math . max ( j - target , 0 ) ; k <= Math . min ( M , j + target ) ; k ++ ) dp [ i ] [ j ] = Math . min ( dp [ i ] [ j ] , dp [ i - 1 ] [ k ] + Math . abs ( A [ i ] - j ) ) ; } } let res = Number . MAX_VALUE ; for ( let j = 0 ; j <= M ; j ++ ) res = Math . min ( res , dp [ n - 1 ] [ j ] ) ; return res ; }

BLEU: 77.06
Edit Sim: 139


Src: 
int unitnumber ( int x , int y ) { x = x % 10 ; if ( y != 0 ) y = y % 4 + 4 ; return ( ( ( int ) ( pow ( x , y ) ) ) % 10 ) ; }
Ref: 
function unitnumber ( x , y ) { x = x % 10 ; if ( y != 0 ) y = y % 4 + 4 ; return ( ( parseInt ( Math . pow ( x , y ) ) ) % 10 ) ; }
Hyp: 
function unitnumber ( x , y ) { x = x % 10 ; if ( y != 0 ) y = y % 4 + 4 ; return ( ( ( Math . pow ( x , y ) ) ) % 10 ) ; }

BLEU: 94.65
Edit Sim: 9


Src: 
void printAllAPTriplets ( int arr [ ] , int n ) { for ( int i = 1 ; i < n - 1 ; i ++ ) { for ( int j = i - 1 , k = i + 1 ; j >= 0 && k < n ; ) { if ( arr [ j ] + arr [ k ] == 2 * arr [ i ] ) { cout << arr [ j ] << " ▁ " << arr [ i ] << " ▁ " << arr [ k ] << endl ; k ++ ; j -- ; } else if ( arr [ j ] + arr [ k ] < 2 * arr [ i ] ) k ++ ; else j -- ; } } }
Ref: 
function printAllAPTriplets ( arr , n ) { for ( let i = 1 ; i < n - 1 ; i ++ ) { for ( let j = i - 1 , k = i + 1 ; j >= 0 && k < n ; ) { if ( arr [ j ] + arr [ k ] == 2 * arr [ i ] ) { document . write ( arr [ j ] + " " + arr [ i ] + " " + arr [ k ] + " " ) ; k ++ ; j -- ; } else if ( arr [ j ] + arr [ k ] < 2 * arr [ i ] ) k ++ ; else j -- ; } } }
Hyp: 
function printAllAPTriplets ( arr , n ) { for ( let i = 1 ; i < n - 1 ; i ++ ) { for ( let j = i - 1 , k = i + 1 ; j >= 0 && k < n ; ) { if ( arr [ j ] + arr [ k ] == 2 * arr [ i ] ) { document . write ( arr [ j ] + " " + arr [ i ] + " " + arr [ k ] + " " ) ; k ++ ; j -- ; } else if ( arr [ j ] + arr [ k ] < 2 * arr [ i ] ) k ++ ; else j -- ; } } }

BLEU: 100.0
Edit Sim: 0


Src: 
int getTotalXorOfSubarrayXors ( int arr [ ] , int N ) { int res = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int freq = ( i + 1 ) * ( N - i ) ; if ( freq % 2 == 1 ) res = res ^ arr [ i ] ; } return res ; }
Ref: 
function getTotalXorOfSubarrayXors ( arr , N ) { let res = 0 ; for ( let i = 0 ; i < N ; i ++ ) { let freq = ( i + 1 ) * ( N - i ) ; if ( freq % 2 == 1 ) res = res ^ arr [ i ] ; } return res ; }
Hyp: 
function getTotalXorOfSubarrayXors ( arr , N ) { let res = 0 ; for ( let i = 0 ; i < N ; i ++ ) { let freq = ( i + 1 ) * ( N - i ) ; if ( freq % 2 == 1 ) res = res ^ arr [ i ] ; } return res ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int find_consecutive_steps ( int arr [ ] , int len ) { int count = 0 ; int maximum = 0 ; for ( int index = 1 ; index < len ; index ++ ) { if ( arr [ index ] > arr [ index - 1 ] ) count ++ ; else { maximum = max ( maximum , count ) ; count = 0 ; } } return max ( maximum , count ) ; }
Ref: 
function find_consecutive_steps ( arr , len ) { let count = 0 ; let maximum = 0 ; for ( let index = 1 ; index < len ; index ++ ) { if ( arr [ index ] > arr [ index - 1 ] ) count ++ ; else { maximum = Math . max ( maximum , count ) ; count = 0 ; } } return Math . max ( maximum , count ) ; }
Hyp: 
function find_consecutive_steps ( arr , len ) { let count = 0 ; let maximum = 0 ; for ( let index = 1 ; index < len ; index ++ ) { if ( arr [ index ] > arr [ index - 1 ] ) count ++ ; else { maximum = Math . max ( maximum , count ) ; count = 0 ; } } return Math . max ( maximum , count ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int findExtra ( int arr1 [ ] , int arr2 [ ] , int n ) { int index = n ; int left = 0 , right = n - 1 ; while ( left <= right ) { int mid = ( left + right ) / 2 ; if ( arr2 [ mid ] == arr1 [ mid ] ) left = mid + 1 ; else { index = mid ; right = mid - 1 ; } } return index ; }
Ref: 
function findExtra ( arr1 , arr2 , n ) { let index = n ; let left = 0 , right = n - 1 ; while ( left <= right ) { let mid = Math . floor ( ( left + right ) / 2 ) ; if ( arr2 [ mid ] == arr1 [ mid ] ) left = mid + 1 ; else { index = mid ; right = mid - 1 ; } } return index ; }
Hyp: 
function findExtra ( arr1 , arr2 , n ) { let index = n ; let left = 0 , right = n - 1 ; while ( left <= right ) { let mid = parseInt ( ( left + right ) / 2 ) ; if ( arr2 [ mid ] == arr1 [ mid ] ) left = mid + 1 ; else { index = mid ; right = mid - 1 ; } } return index ; }

BLEU: 94.63
Edit Sim: 11


Src: 
int sum ( int N ) { int S1 , S2 , S3 ; S1 = ( ( N / 3 ) ) * ( 2 * 3 + ( N / 3 - 1 ) * 3 ) / 2 ; S2 = ( ( N / 4 ) ) * ( 2 * 4 + ( N / 4 - 1 ) * 4 ) / 2 ; S3 = ( ( N / 12 ) ) * ( 2 * 12 + ( N / 12 - 1 ) * 12 ) / 2 ; return S1 + S2 - S3 ; }
Ref: 
function sum ( N ) { var S1 , S2 , S3 ; S1 = ( ( N / 3 ) ) * ( 2 * 3 + ( N / 3 - 1 ) * 3 ) / 2 ; S2 = ( ( N / 4 ) ) * ( 2 * 4 + ( N / 4 - 1 ) * 4 ) / 2 ; S3 = ( ( N / 12 ) ) * ( 2 * 12 + ( N / 12 - 1 ) * 12 ) / 2 ; return S1 + S2 - S3 ; }
Hyp: 
function sum ( N ) { let S1 , S2 , S3 ; S1 = ( ( N / 3 ) ) * ( 2 * 3 + ( N / 3 - 1 ) * 3 ) / 2 ; S2 = ( ( N / 4 ) ) * ( 2 * 4 + ( N / 4 - 1 ) * 4 ) / 2 ; S3 = ( ( N / 12 ) ) * ( 2 * 12 + ( N / 12 - 1 ) * 12 ) / 2 ; return S1 + S2 - S3 ; }

BLEU: 97.59
Edit Sim: 3


Src: 
double haversine ( double lat1 , double lon1 , double lat2 , double lon2 ) { double dLat = ( lat2 - lat1 ) * M_PI / 180.0 ; double dLon = ( lon2 - lon1 ) * M_PI / 180.0 ; lat1 = ( lat1 ) * M_PI / 180.0 ; lat2 = ( lat2 ) * M_PI / 180.0 ; double a = pow ( sin ( dLat / 2 ) , 2 ) + pow ( sin ( dLon / 2 ) , 2 ) * cos ( lat1 ) * cos ( lat2 ) ; double rad = 6371 ; double c = 2 * asin ( sqrt ( a ) ) ; return rad * c ; }
Ref: 
function haversine ( lat1 , lon1 , lat2 , lon2 ) { let dLat = ( lat2 - lat1 ) * Math . PI / 180.0 ; let dLon = ( lon2 - lon1 ) * Math . PI / 180.0 ; lat1 = ( lat1 ) * Math . PI / 180.0 ; lat2 = ( lat2 ) * Math . PI / 180.0 ; let a = Math . pow ( Math . sin ( dLat / 2 ) , 2 ) + Math . pow ( Math . sin ( dLon / 2 ) , 2 ) * Math . cos ( lat1 ) * Math . cos ( lat2 ) ; let rad = 6371 ; let c = 2 * Math . asin ( Math . sqrt ( a ) ) ; return rad * c ; }
Hyp: 
function haversine ( lat1 , lon1 , lat2 , lon2 ) { let dLat = ( lat2 - lat1 ) * M_PI / 180.0 ; let dLon = ( lon2 - lon1 ) * M_PI / 180.0 ; lat1 = ( lat1 ) * M_PI / 180.0 ; lat2 = ( lat2 ) * M_PI / 180.0 ; let rad = 6371 ; let c = 2 * asin ( Math . sqrt ( a ) ) ; return rad * c ; }

BLEU: 42.37
Edit Sim: 173


Src: 
int increment ( unsigned int i ) { i = - ( ~ i ) ; return i ; }
Ref: 
function increment ( i ) { i = - ( ~ i ) ; return i ; }
Hyp: 
function increment ( i ) { i = - ( ~ i ) ; return i ; }

BLEU: 100.0
Edit Sim: 0


Src: 
void printPascal ( int n ) { int arr [ n ] [ n ] ; for ( int line = 0 ; line < n ; line ++ ) { for ( int i = 0 ; i <= line ; i ++ ) { if ( line == i i == 0 ) arr [ line ] [ i ] = 1 ; else arr [ line ] [ i ] = arr [ line - 1 ] [ i - 1 ] + arr [ line - 1 ] [ i ] ; cout << arr [ line ] [ i ] << " ▁ " ; } cout << " STRNEWLINE " ; } }
Ref: 
function printPascal ( n ) { arr = a = Array ( n ) . fill ( 0 ) . map ( x => Array ( n ) . fill ( 0 ) ) ; for ( line = 0 ; line < n ; line ++ ) { for ( i = 0 ; i <= line ; i ++ ) { if ( line == i i == 0 ) arr [ line ] [ i ] = 1 ; else arr [ line ] [ i ] = arr [ line - 1 ] [ i - 1 ] + arr [ line - 1 ] [ i ] ; document . write ( arr [ line ] [ i ] ) ; } document . write ( " " ) ; } }
Hyp: 
function printPascal ( n ) { let arr = Array . from ( { length : n } , ( _ , i ) => 0 ) ; for ( let line = 0 ; line < n ; line ++ ) { for ( let i = 0 ; i <= line ; i ++ ) { if ( line == i i == 0 ) arr [ line ] [ i ] = 1 ; else arr [ line ] [ i ] = arr [ line - 1 ] [ i - 1 ] + arr [ line - 1 ] [ i ] ; document . write ( arr [ line ] [ i ] + " " ) ; } document . write ( " " ) ; }

BLEU: 77.32
Edit Sim: 59


Src: 
int smallestSubWithSum ( int arr [ ] , int n , int x ) { int curr_sum = 0 , min_len = n + 1 ; int start = 0 , end = 0 ; while ( end < n ) { while ( curr_sum <= x && end < n ) curr_sum += arr [ end ++ ] ; while ( curr_sum > x && start < n ) { if ( end - start < min_len ) min_len = end - start ; curr_sum -= arr [ start ++ ] ; } } return min_len ; }
Ref: 
function smallestSubWithSum ( arr , n , x ) { let curr_sum = 0 , min_len = n + 1 ; let start = 0 , end = 0 ; while ( end < n ) { while ( curr_sum <= x && end < n ) curr_sum += arr [ end ++ ] ; while ( curr_sum > x && start < n ) { if ( end - start < min_len ) min_len = end - start ; curr_sum -= arr [ start ++ ] ; } } return min_len ; }
Hyp: 
function smallestSubWithSum ( arr , n , x ) { let curr_sum = 0 , min_len = n + 1 ; let start = 0 , end = 0 ; while ( end < n ) { while ( curr_sum <= x && end < n ) curr_sum += arr [ end ++ ] ; while ( curr_sum > x && start < n ) { if ( end - start < min_len ) min_len = end - start ; curr_sum -= arr [ start ++ ] ; } } return min_len ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int maxXOR ( int mat [ ] [ MAX ] , int N ) { int r_xor , c_xor ; int max_xor = 0 ; for ( int i = 0 ; i < N ; i ++ ) { r_xor = 0 , c_xor = 0 ; for ( int j = 0 ; j < N ; j ++ ) { r_xor = r_xor ^ mat [ i ] [ j ] ; c_xor = c_xor ^ mat [ j ] [ i ] ; } if ( max_xor < max ( r_xor , c_xor ) ) max_xor = max ( r_xor , c_xor ) ; } return max_xor ; }
Ref: 
function maxXOR ( mat , N ) { let r_xor , c_xor ; let max_xor = 0 ; for ( let i = 0 ; i < N ; i ++ ) { r_xor = 0 , c_xor = 0 ; for ( let j = 0 ; j < N ; j ++ ) { r_xor = r_xor ^ mat [ i ] [ j ] ; c_xor = c_xor ^ mat [ j ] [ i ] ; } if ( max_xor < Math . max ( r_xor , c_xor ) ) max_xor = Math . max ( r_xor , c_xor ) ; } return max_xor ; }
Hyp: 
function maxXOR ( mat , N ) { let r_xor , c_xor ; let max_xor = 0 ; for ( let i = 0 ; i < N ; i ++ ) { r_xor = 0 , c_xor = 0 ; for ( let j = 0 ; j < N ; j ++ ) { r_xor = r_xor ^ mat [ i ] [ j ] ; c_xor = c_xor ^ mat [ j ] [ i ] ; } if ( max_xor < max ( r_xor , c_xor ) ) max_xor = Math . max ( r_xor , c_xor ) ; } return max_xor ; }

BLEU: 96.78
Edit Sim: 7


Src: 
int divCount ( int n ) { bool hash [ n + 1 ] ; memset ( hash , true , sizeof ( hash ) ) ; for ( int p = 2 ; p * p < n ; p ++ ) if ( hash [ p ] == true ) for ( int i = p * 2 ; i < n ; i += p ) hash [ i ] = false ; int total = 1 ; for ( int p = 2 ; p <= n ; p ++ ) { if ( hash [ p ] ) { int count = 0 ; if ( n % p == 0 ) { while ( n % p == 0 ) { n = n / p ; count ++ ; } total = total * ( count + 1 ) ; } } } return total ; }
Ref: 
function divCount ( n ) { var hash = Array ( n + 1 ) . fill ( true ) ; for ( var p = 2 ; p * p < n ; p ++ ) if ( hash [ p ] == true ) for ( var i = p * 2 ; i < n ; i += p ) hash [ i ] = false ; var total = 1 ; for ( var p = 2 ; p <= n ; p ++ ) { if ( hash [ p ] ) { var count = 0 ; if ( n % p == 0 ) { while ( n % p == 0 ) { n = parseInt ( n / p ) ; count ++ ; } total = total * ( count + 1 ) ; } } } return total ; }
Hyp: 
function divCount ( n ) { var hash = [ ] ; for ( var p = 2 ; p * p < n ; p ++ ) if ( hash [ p ] == true ) for ( var i = p * 2 ; i < n ; i += p ) hash [ i ] = false ; var total = 1 ; for ( var p = 2 ; p <= n ; p ++ ) { if ( hash [ p ] ) { var count = 0 ; if ( n % p == 0 ) { while ( n % p == 0 ) { n = n / p ; count ++ ; } total = total * ( count + 1 ) ; } } } return total ; }

BLEU: 87.38
Edit Sim: 43


Src: 
float Rate ( int N1 , int N2 ) { float rate = ( N2 - N1 ) * 100 / float ( N1 ) ; return rate ; }
Ref: 
function Rate ( N1 , N2 ) { var rate = ( N2 - N1 ) * 100 / N1 ; return parseInt ( rate ) ; }
Hyp: 
function Rate ( N1 , N2 ) { let rate = ( N2 - N1 ) * 100 / ( N1 ) ; return rate ; }

BLEU: 65.56
Edit Sim: 20


Src: 
int countXorPair ( int arr [ ] , int n ) { int odd = 0 , even = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) even ++ ; else odd ++ ; } return odd * even ; }
Ref: 
function countXorPair ( arr , n ) { let odd = 0 , even = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) even ++ ; else odd ++ ; } return odd * even ; }
Hyp: 
function countXorPair ( arr , n ) { var odd = 0 , even = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) even ++ ; else odd ++ ; } return odd * even ; }

BLEU: 90.97
Edit Sim: 6


Src: 
int countDigits ( int n ) { double ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) ans += log10 ( i ) ; ans = ans * n ; return 1 + floor ( ans ) ; }
Ref: 
function countDigits ( n ) { let ans = 0 ; for ( let i = 1 ; i <= n ; i ++ ) ans += Math . log10 ( i ) ; ans = ans * n ; return 1 + Math . floor ( ans ) ; }
Hyp: 
function countDigits ( n ) { let ans = 0 ; for ( let i = 1 ; i <= n ; i ++ ) ans += Math . log10 ( i ) ; ans = ans * n ; return 1 + Math . floor ( ans ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int complement ( int num ) { int i , len = 0 , temp , comp ; temp = num ; while ( 1 ) { len ++ ; num = num / 10 ; if ( abs ( num ) == 0 ) break ; } num = temp ; comp = pow ( 10 , len ) - num ; return comp ; }
Ref: 
function complement ( num ) { var i , len = 0 , temp , comp ; temp = num ; while ( true ) { len ++ ; num = parseInt ( num / 10 ) ; if ( Math . abs ( num ) == 0 ) break ; } num = temp ; comp = parseInt ( Math . pow ( 10 , len ) - num ) ; return comp ; }
Hyp: 
function complement ( num ) { let i , len = 0 , temp , comp ; temp = num ; while ( 1 ) { len ++ ; num = Math . floor ( num / 10 ) ; if ( Math . abs ( num ) == 0 ) break ; } num = temp ; comp = Math . pow ( 10 , len ) - num ; return comp ; }

BLEU: 81.64
Edit Sim: 31


Src: 
int distancesum ( int x [ ] , int y [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) sum += ( abs ( x [ i ] - x [ j ] ) + abs ( y [ i ] - y [ j ] ) ) ; return sum ; }
Ref: 
function distancesum ( x , y , n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = i + 1 ; j < n ; j ++ ) sum += ( Math . abs ( x [ i ] - x [ j ] ) + Math . abs ( y [ i ] - y [ j ] ) ) ; return sum ; }
Hyp: 
function distancesum ( x , y , n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = i + 1 ; j < n ; j ++ ) sum += ( Math . abs ( x [ i ] - x [ j ] ) + Math . abs ( y [ i ] - y [ j ] ) ) ; return sum ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int closetAND ( int arr [ ] , int n , int k ) { int ans = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { int X = arr [ i ] ; for ( int j = i ; j < n ; j ++ ) { X &= arr [ j ] ; ans = min ( ans , abs ( k - X ) ) ; } } return ans ; }
Ref: 
function closetAND ( arr , n , k ) { let ans = Number . MAX_VALUE ; for ( let i = 0 ; i < n ; i ++ ) { let X = arr [ i ] ; for ( let j = i ; j < n ; j ++ ) { X &= arr [ j ] ; ans = Math . min ( ans , Math . abs ( k - X ) ) ; } } return ans ; }
Hyp: 
function closetAND ( arr , n , k ) { let ans = Number . MAX_VALUE ; for ( let i = 0 ; i < n ; i ++ ) { let X = arr [ i ] ; for ( let j = i ; j < n ; j ++ ) { X &= arr [ j ] ; ans = Math . min ( ans , Math . abs ( k - X ) ) ; } } return ans ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int findSum ( int N ) { return ( 2 * N * ( N + 1 ) * ( 4 * N + 17 ) + 54 * N ) / 6 ; }
Ref: 
function findSum ( N ) { return ( 2 * N * ( N + 1 ) * ( 4 * N + 17 ) + 54 * N ) / 6 ; }
Hyp: 
function findSum ( N ) { return ( 2 * N * ( N + 1 ) * ( 4 * N + 17 ) + 54 * N ) / 6 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
bool isEditDistanceOne ( string s1 , string s2 ) { int m = s1 . length ( ) , n = s2 . length ( ) ; if ( abs ( m - n ) > 1 ) return false ; int i = 0 , j = 0 ; while ( i < m && j < n ) { if ( s1 [ i ] != s2 [ j ] ) { if ( count == 1 ) return false ; if ( m > n ) i ++ ; else if ( m < n ) j ++ ; { i ++ ; j ++ ; } count ++ ; } { i ++ ; j ++ ; } } if ( i < m j < n ) count ++ ; return count == 1 ; }
Ref: 
function isEditDistanceOne ( s1 , s2 ) { let m = s1 . length , n = s2 . length ; if ( Math . abs ( m - n ) > 1 ) return false ; let count = 0 ; let i = 0 , j = 0 ; while ( i < m && j < n ) { if ( s1 [ i ] != s2 [ j ] ) { if ( count == 1 ) return false ; if ( m > n ) i ++ ; else if ( m < n ) j ++ ; else { i ++ ; j ++ ; } count ++ ; } else { i ++ ; j ++ ; } } if ( i < m j < n ) count ++ ; return count == 1 ; }
Hyp: 
function isEditDistanceOne ( s1 , s2 ) { var m = s1 . length , n = s2 . length ; if ( Math . abs ( m - n ) > 1 ) return false ; var i = 0 , j = 0 ; while ( i < m && j < n ) { if ( s1 [ i ] != s2 [ j ] ) { if ( count == 1 ) return false ; if ( m > n ) i ++ ; else if ( m < n ) j ++ ; } count ++ ; } if ( i < m j < n ) count ++ ; } return count == 1 ; }

BLEU: 78.25
Edit Sim: 70


Src: 
float cube ( float h , float r ) { if ( h < 0 && r < 0 ) return -1 ; float a = pow ( h , 3 ) ; return a ; }
Ref: 
function cube ( h , r ) { if ( h < 0 && r < 0 ) return - 1 ; var a = Math . pow ( h , 3 ) ; return a ; }
Hyp: 
function cube ( h , r ) { if ( h < 0 && r < 0 ) return - 1 ; var a = Math . pow ( h , 3 ) ; return a ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int findMaximum ( int arr [ ] , int low , int high ) { int max = arr [ low ] ; int i ; for ( i = low + 1 ; i <= high ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; else break ; } return max ; }
Ref: 
function findMaximum ( arr , low , high ) { var max = arr [ low ] ; var i ; for ( i = low + 1 ; i <= high ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; else break ; } return max ; }
Hyp: 
function findMaximum ( arr , low , high ) { let max = arr [ low ] ; let i ; for ( i = low + 1 ; i <= high ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; else break ; } return max ; }

BLEU: 91.58
Edit Sim: 6


Src: 
int sum ( int N , int X , int Y ) { int S1 , S2 , S3 ; S1 = ( ( N / X ) ) * ( 2 * X + ( N / X - 1 ) * X ) / 2 ; S2 = ( ( N / Y ) ) * ( 2 * Y + ( N / Y - 1 ) * Y ) / 2 ; S3 = ( ( N / ( X * Y ) ) ) * ( 2 * ( X * Y ) + ( N / ( X * Y ) - 1 ) * ( X * Y ) ) / 2 ; return S1 + S2 - S3 ; }
Ref: 
function sum ( N , X , Y ) { var S1 , S2 , S3 ; S1 = ( parseInt ( N / X ) ) * ( 2 * X + parseInt ( N / X - 1 ) * X ) / 2 ; S2 = ( parseInt ( N / Y ) ) * ( 2 * Y + parseInt ( N / Y - 1 ) * Y ) / 2 ; S3 = ( parseInt ( N / ( X * Y ) ) ) * ( 2 * ( X * Y ) + parseInt ( N / ( X * Y ) - 1 ) * ( X * Y ) ) / 2 ; return S1 + S2 - S3 ; }
Hyp: 
function sum ( N , X , Y ) { let S1 , S2 , S3 ; S1 = ( ( N / X ) ) * ( 2 * X + ( N / X - 1 ) * X ) / 2 ; S2 = ( ( N / Y ) ) * ( 2 * Y + ( N / Y - 1 ) * Y ) / 2 ; S3 = ( ( N / ( X * Y ) ) ) * ( 2 * ( X * Y ) + ( N / ( X * Y ) - 1 ) * ( X * Y ) ) / 2 ; return S1 + S2 - S3 ; }

BLEU: 86.24
Edit Sim: 57


Src: 
void generate_derangement ( int N ) { int S [ N + 1 ] ; for ( int i = 1 ; i <= N ; i ++ ) S [ i ] = i ; int D [ N + 1 ] ; for ( int i = 1 ; i <= N ; i += 2 ) { if ( i == N && i % N != 0 ) { int temp = D [ N ] ; D [ N ] = D [ N - 1 ] ; D [ N - 1 ] = temp ; } else { D [ i ] = i + 1 ; D [ i + 1 ] = i ; } } for ( int i = 1 ; i <= N ; i ++ ) printf ( " % d ▁ " , D [ i ] ) ; printf ( " STRNEWLINE " ) ; }
Ref: 
function generate_derangement ( N ) { let S = [ ] ; for ( let i = 1 ; i <= N ; i ++ ) S [ i ] = i ; let D = [ ] ; for ( let i = 1 ; i <= N ; i += 2 ) { if ( i == N ) { D [ N ] = S [ N - 1 ] ; D [ N - 1 ] = S [ N ] ; } else { D [ i ] = i + 1 ; D [ i + 1 ] = i ; } } for ( let i = 1 ; i <= N ; i ++ ) document . write ( D [ i ] + " " ) ; document . write ( " " ) ; }
Hyp: 
function generate_derangement ( N ) { let S = new Array ( N + 1 ) ; for ( let i = 1 ; i <= N ; i ++ ) S [ i ] = i ; let D = new Array ( N + 1 ) ; for ( let i = 1 ; i <= N ; i += 2 ) { if ( i == N && i % N != 0 ) { let temp = D [ N ] ; D [ N ] = D [ N - 1 ] ; D [ N - 1 ] = temp ; } else { D [ i ] = i + 1 ; D [ i + 1 ] = i ; } } for ( let i = 1 ; i <= N ; i ++ ) document . write ( D [ i ] ) ; document . write ( " " ) ; }

BLEU: 76.54
Edit Sim: 85


Src: 
int oddSum ( int n ) { return ( n * n ) ; }
Ref: 
function oddSum ( n ) { return ( n * n ) ; }
Hyp: 
function oddSum ( n ) { return ( n * n ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
float sphere ( float a ) { if ( a < 0 ) return -1 ; float r = a / 2 ; return r ; }
Ref: 
function sphere ( a ) { if ( a < 0 ) return - 1 ; var r = a / 2 ; return r ; }
Hyp: 
function sphere ( a ) { if ( a < 0 ) return - 1 ; var r = a / 2 ; return r ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int computeLastDigit ( long long int A , long long int B ) { int variable = 1 ; return 1 ; else if ( ( B - A ) >= 5 ) return 0 ; else { for ( long long int i = A + 1 ; i <= B ; i ++ ) variable = ( variable * ( i % 10 ) ) ; return variable % 10 ; } }
Ref: 
function computeLastDigit ( A , B ) { let variable = 1 ; return 1 ; else if ( ( B - A ) >= 5 ) return 0 ; else { for ( let i = A + 1 ; i <= B ; i ++ ) variable = ( variable * ( i % 10 ) ) % 10 ; return variable % 10 ; } }
Hyp: 
function computeLastDigit ( A , B ) { let variable = 1 ; return 1 ; else if ( ( B - A ) >= 5 ) return 0 ; else { for ( let i = A + 1 ; i <= B ; i ++ ) variable = ( variable * ( i % 10 ) ) ; return variable % 10 ; } }

BLEU: 94.83
Edit Sim: 5


Src: 
int swapBitsInPair ( unsigned int x ) { return ( ( x & 0b10101010 ) >> 1 ) | ( ( x & 0b01010101 ) << 1 ) ; }
Ref: 
function swapBitsInPair ( x ) { return ( ( x & 0b10101010 ) >> 1 ) | ( ( x & 0b01010101 ) << 1 ) ; }
Hyp: 
function swapBitsInPair ( x ) { return ( ( x & 0b10101010 ) >> 1 ) | ( ( x & 0b01010101 ) << 1 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int count ( int n ) { int cnt = 0 ; int p = 1 ; while ( p <= n ) { cnt ++ ; p *= 2 ; } return cnt ; }
Ref: 
function count ( n ) { var cnt = 0 ; var p = 1 ; while ( p <= n ) { cnt ++ ; p *= 2 ; } return cnt ; }
Hyp: 
function count ( n ) { let cnt = 0 ; let p = 1 ; while ( p <= n ) { cnt ++ ; p *= 2 ; } return cnt ; }

BLEU: 85.0
Edit Sim: 6


Src: 
string maxValue ( string a , string b ) { sort ( b . begin ( ) , b . end ( ) ) ; int n = a . length ( ) ; int m = b . length ( ) ; int j = m - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( j < 0 ) break ; if ( b [ j ] > a [ i ] ) { a [ i ] = b [ j ] ; j -- ; } } return a ; }
Ref: 
function maxValue ( a , b ) { b . sort ( function ( x , y ) { return x - y ; } ) ; let n = a . length ; let m = b . length ; let j = m - 1 ; for ( let i = 0 ; i < n ; i ++ ) { if ( j < 0 ) break ; if ( b [ j ] > a [ i ] ) { a [ i ] = b [ j ] ; j -- ; } } return ( a ) . join ( " " ) ; }
Hyp: 
function maxValue ( a , b ) { b . sort ( ( a , b ) => a - b ) ; let n = a . length ; let m = b . length ; let j = m - 1 ; for ( let i = 0 ; i < n ; i ++ ) { if ( j < 0 ) break ; if ( b [ j ] > a [ i ] ) { a [ i ] = b [ j ] ; j -- ; } } return a ; }

BLEU: 78.35
Edit Sim: 44


Src: 
bool isDivisible ( char str [ ] , int k ) { int n = strlen ( str ) ; int c = 0 ; for ( int i = 0 ; i < k ; i ++ ) if ( str [ n - i - 1 ] == '0' ) c ++ ; return ( c == k ) ; }
Ref: 
function isDivisible ( str , k ) { let n = str . length ; let c = 0 ; for ( let i = 0 ; i < k ; i ++ ) if ( str [ n - i - 1 ] == ' ' ) c ++ ; return ( c == k ) ; }
Hyp: 
function isDivisible ( str , k ) { let n = str . length ; let c = 0 ; for ( let i = 0 ; i < k ; i ++ ) if ( str [ n - i - 1 ] == ' ' ) c ++ ; return ( c == k ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int getNthTerm ( long long int N ) { return 4 * pow ( N , 2 ) - 3 * N + 2 ; }
Ref: 
function getNthTerm ( N ) { return 4 * Math . pow ( N , 2 ) - 3 * N + 2 ; }
Hyp: 
function getNthTerm ( N ) { return 4 * Math . pow ( N , 2 ) - 3 * N + 2 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int minOp ( long long int num ) { int rem ; int count = 0 ; while ( num ) { rem = num % 10 ; if ( ! ( rem == 3 rem == 8 ) ) count ++ ; num /= 10 ; } return count ; }
Ref: 
function minOp ( num ) { var rem ; var count = 0 ; while ( num ) { rem = num % 10 ; if ( ! ( rem == 3 rem == 8 ) ) count ++ ; num = parseInt ( num / 10 ) ; } return count ; }
Hyp: 
function minOp ( num ) { let rem ; let count = 0 ; while ( num ) { rem = num % 10 ; if ( ! ( rem == 3 rem == 8 ) ) count ++ ; num = Math . floor ( num / 10 ) ; } return count ; }

BLEU: 83.02
Edit Sim: 17


Src: 
string isDivisible ( long long int n ) { long long int temp = n ; while ( n ) { int k = n % 10 ; if ( temp % k == 0 ) return " YES " ; n /= 10 ; } return " NO " ; }
Ref: 
function isDivisible ( n ) { temp = n ; while ( n ) { k = n % 10 ; if ( temp % k == 0 ) return " " ; n = Math . floor ( n / 10 ) ; } return " " ; }
Hyp: 
function isDivisible ( n ) { let temp = n ; while ( n ) { let k = n % 10 ; if ( temp % k == 0 ) return " " ; n = Math . floor ( n / 10 ) ; } return " " ; }

BLEU: 90.08
Edit Sim: 8


Src: 
int maxPrimefactorNum ( int N ) { if ( N < 2 ) return 0 ; bool arr [ N + 1 ] ; memset ( arr , true , sizeof ( arr ) ) ; int prod = 1 , res = 0 ; for ( int p = 2 ; p * p <= N ; p ++ ) { if ( arr [ p ] == true ) { for ( int i = p * 2 ; i <= N ; i += p ) arr [ i ] = false ; prod *= p ; if ( prod > N ) return res ; res ++ ; } } return res ; }
Ref: 
function maxPrimefactorNum ( N ) { if ( N < 2 ) return 0 ; arr = Array . from ( { length : N + 1 } , ( _ , i ) => false ) ; var prod = 1 , res = 0 ; for ( var p = 2 ; p * p <= N ; p ++ ) { if ( arr [ p ] == false ) { for ( var i = p * 2 ; i <= N ; i += p ) arr [ i ] = true ; prod *= p ; if ( prod > N ) return res ; res ++ ; } } return res ; }
Hyp: 
function maxPrimefactorNum ( N ) { if ( N < 2 ) return 0 ; let arr = new Array ( N + 1 ) ; arr . fill ( 0 ) ; let prod = 1 , res = 0 ; for ( let p = 2 ; p * p <= N ; p ++ ) { if ( arr [ p ] == true ) { for ( let i = p * 2 ; i <= N ; i += p ) arr [ i ] = false ; prod *= p ; if ( prod > N ) return res ; res ++ ; } } } return res ; }

BLEU: 73.71
Edit Sim: 59


Src: 
void nDigitPerfectSquares ( int n ) { cout << pow ( ceil ( sqrt ( pow ( 10 , n - 1 ) ) ) , 2 ) << " ▁ " ; cout << pow ( ceil ( sqrt ( pow ( 10 , n ) ) ) - 1 , 2 ) ; }
Ref: 
function nDigitPerfectSquares ( n ) { document . write ( Math . pow ( Math . ceil ( Math . sqrt ( Math . pow ( 10 , n - 1 ) ) ) , 2 ) + " " ) ; document . write ( Math . pow ( Math . ceil ( Math . sqrt ( Math . pow ( 10 , n ) ) ) - 1 , 2 ) ) ; }
Hyp: 
function nDigitPerfectSquares ( n ) { document . write ( Math . ceil ( Math . pow ( 10 , n - 1 ) ) ) , 2 ) + " " ) ; document . write ( Math . ceil ( Math . sqrt ( Math . pow ( 10 , n ) ) ) - 1 , 2 ) ; }

BLEU: 80.35
Edit Sim: 42


Src: 
void printTrib ( int n ) { if ( n < 1 ) return ; int first = 0 , second = 0 ; int third = 1 ; cout << first << " ▁ " ; if ( n > 1 ) cout << second << " ▁ " ; if ( n > 2 ) cout << second << " ▁ " ; for ( int i = 3 ; i < n ; i ++ ) { int curr = first + second + third ; first = second ; second = third ; third = curr ; cout << curr << " ▁ " ; } }
Ref: 
function printTrib ( n ) { if ( n < 1 ) return ; let first = 0 , second = 0 ; let third = 1 ; document . write ( first + " " ) ; if ( n > 1 ) document . write ( second + " " ) ; if ( n > 2 ) document . write ( second + " " ) ; for ( let i = 3 ; i < n ; i ++ ) { let curr = first + second + third ; first = second ; second = third ; third = curr ; document . write ( curr + " " ) ; } }
Hyp: 
function printTrib ( n ) { if ( n < 1 ) return ; let first = 0 , second = 0 , third = 1 ; document . write ( first + " " ) ; if ( n > 1 ) document . write ( second + " " ) ; if ( n > 2 ) document . write ( second + " " ) ; }

BLEU: 48.54
Edit Sim: 161


Src: 
void printGMeans ( int A , int B , int N ) { float R = ( float ) pow ( float ( B / A ) , 1.0 / ( float ) ( N + 1 ) ) ; for ( int i = 1 ; i <= N ; i ++ ) cout << A * pow ( R , i ) << " ▁ " ; }
Ref: 
function printGMeans ( A , B , N ) { let R = Math . pow ( ( B / A ) , 1.0 / ( N + 1 ) ) ; for ( let i = 1 ; i <= N ; i ++ ) document . write ( A * Math . pow ( R , i ) + " " ) ; }
Hyp: 
function printGMeans ( A , B , N ) { let R = ( Math . pow ( ( B / A ) , 1.0 / ( Math . pow ( N + 1 ) ) ) ; for ( let i = 1 ; i <= N ; i ++ ) document . write ( A * Math . pow ( R , i ) + " " ) ; }

BLEU: 87.99
Edit Sim: 17


Src: 
int minSum ( int arr [ ] , int n ) { int sum = arr [ 0 ] , prev = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] <= prev ) { prev = prev + 1 ; sum = sum + prev ; } else { sum = sum + arr [ i ] ; prev = arr [ i ] ; } } return sum ; }
Ref: 
function minSum ( arr , n ) { let sum = arr [ 0 ] , prev = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { if ( arr [ i ] <= prev ) { prev = prev + 1 ; sum = sum + prev ; } else { sum = sum + arr [ i ] ; prev = arr [ i ] ; } } return sum ; }
Hyp: 
function minSum ( arr , n ) { let sum = arr [ 0 ] ; let prev = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { if ( arr [ i ] <= prev ) { prev = prev + 1 ; sum = sum + prev ; } else { sum = sum + arr [ i ] ; prev = arr [ i ] ; } } return sum ; }

BLEU: 95.88
Edit Sim: 5


Src: 
void lengtang ( double r1 , double r2 , double d ) { cout << " The ▁ length ▁ of ▁ the ▁ direct " << " ▁ common ▁ tangent ▁ is ▁ " << sqrt ( pow ( d , 2 ) - pow ( ( r1 - r2 ) , 2 ) ) << endl ; }
Ref: 
function lengtang ( r1 , r2 , d ) { document . write ( " " + " " + ( Math . sqrt ( Math . pow ( d , 2 ) - Math . pow ( ( r1 - r2 ) , 2 ) ) ) . toFixed ( 5 ) ) ; }
Hyp: 
function lengtang ( r1 , r2 , d ) { document . write ( " " + " " + Math . pow ( d , 2 ) - Math . pow ( ( r1 - r2 ) , 2 ) ) + " " ) ; }

BLEU: 73.73
Edit Sim: 31


Src: 
int findMinDiff ( int arr [ ] , int n ) { int diff = INT_MAX ; for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( abs ( arr [ i ] - arr [ j ] ) < diff ) diff = abs ( arr [ i ] - arr [ j ] ) ; return diff ; }
Ref: 
function findMinDiff ( arr , n ) { let diff = Number . MAX_VALUE ; for ( let i = 0 ; i < n - 1 ; i ++ ) for ( let j = i + 1 ; j < n ; j ++ ) if ( Math . abs ( ( arr [ i ] - arr [ j ] ) ) < diff ) diff = Math . abs ( ( arr [ i ] - arr [ j ] ) ) ; return diff ; }
Hyp: 
function findMinDiff ( arr , n ) { let diff = Number . MAX_VALUE ; for ( let i = 0 ; i < n - 1 ; i ++ ) for ( let j = i + 1 ; j < n ; j ++ ) if ( Math . abs ( arr [ i ] - arr [ j ] ) < diff ) diff = Math . abs ( arr [ i ] - arr [ j ] ) ; return diff ; }

BLEU: 92.07
Edit Sim: 8


Src: 
int maxLenSub ( int arr [ ] , int n ) { int mls [ n ] , max = 0 ; for ( int i = 0 ; i < n ; i ++ ) mls [ i ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( abs ( arr [ i ] - arr [ j ] ) <= 1 && mls [ i ] < mls [ j ] + 1 ) mls [ i ] = mls [ j ] + 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( max < mls [ i ] ) max = mls [ i ] ; return max ; }
Ref: 
function maxLenSub ( arr , n ) { let mls = new Array ( n ) . fill ( 1 ) , max = 0 ; for ( let i = 0 ; i < n ; i ++ ) mls [ i ] = 1 ; for ( let i = 1 ; i < n ; i ++ ) for ( let j = 0 ; j < i ; j ++ ) if ( Math . abs ( arr [ i ] - arr [ j ] ) <= 1 && mls [ i ] < mls [ j ] + 1 ) mls [ i ] = mls [ j ] + 1 ; for ( let i = 0 ; i < n ; i ++ ) if ( max < mls [ i ] ) max = mls [ i ] ; return max ; }
Hyp: 
function maxLenSub ( arr , n ) { let mls = [ ] , max = 0 ; for ( let i = 0 ; i < n ; i ++ ) mls [ i ] = 1 ; for ( let i = 1 ; i < n ; i ++ ) for ( let j = 0 ; j < i ; j ++ ) if ( Math . abs ( arr [ i ] - arr [ j ] ) <= 1 && mls [ i ] < mls [ j ] + 1 ) mls [ i ] = mls [ j ] + 1 ; for ( let i = 0 ; i < n ; i ++ ) if ( max < mls [ i ] ) max = mls [ i ] ; return max ; }

BLEU: 92.28
Edit Sim: 27


Src: 
int sum_of_series ( int n ) { int result = 0 ; if ( n % 2 == 0 ) { result = - ( n * ( n + 1 ) ) / 2 ; } else { result = ( n * ( n + 1 ) ) / 2 ; } return result ; }
Ref: 
function sum_of_series ( n ) { let result = 0 ; if ( n % 2 == 0 ) { result = - ( n * ( n + 1 ) ) / 2 ; } else { result = ( n * ( n + 1 ) ) / 2 ; } return result ; }
Hyp: 
function sum_of_series ( n ) { let result = 0 ; if ( n % 2 == 0 ) { result = - ( n * ( n + 1 ) ) / 2 ; } else { result = ( n * ( n + 1 ) ) / 2 ; } return result ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int smallestOdd ( int n ) { if ( n == 1 ) return 1 ; return pow ( 10 , n - 1 ) + 1 ; }
Ref: 
function smallestOdd ( n ) { if ( n == 1 ) return 1 ; return Math . pow ( 10 , n - 1 ) + 1 ; }
Hyp: 
function smallestOdd ( n ) { if ( n == 1 ) return 1 ; return Math . pow ( 10 , parseInt ( n - 1 ) + 1 ) ; }

BLEU: 81.83
Edit Sim: 13


Src: 
void printSeries ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) { int num = ( i * ( i + 1 ) * ( i + 2 ) * ( i + 3 ) / 24 ) ; cout << num << " ▁ " ; } }
Ref: 
function printSeries ( n ) { for ( let i = 1 ; i <= n ; i ++ ) { num = ( i * ( i + 1 ) * ( i + 2 ) * ( i + 3 ) / 24 ) ; document . write ( num + " " ) ; } }
Hyp: 
function printSeries ( n ) { for ( let i = 1 ; i <= n ; i ++ ) { let num = ( i * ( i + 1 ) * ( i + 2 ) * ( i + 3 ) / 24 ) ; document . write ( num + " " ) ; } }

BLEU: 95.74
Edit Sim: 4


Src: 
int binomialCoeff ( int n , int k ) { if ( k > n ) return 0 ; if ( k == 0 k == n ) return 1 ; return binomialCoeff ( n - 1 , k - 1 ) + binomialCoeff ( n - 1 , k ) ; }
Ref: 
function binomialCoeff ( n , k ) { if ( k > n ) return 0 ; if ( k == 0 k == n ) return 1 ; return binomialCoeff ( n - 1 , k - 1 ) + binomialCoeff ( n - 1 , k ) ; }
Hyp: 
function binomialCoeff ( n , k ) { if ( k > n ) return 0 ; if ( k == 0 k == n ) return 1 ; return binomialCoeff ( n - 1 , k - 1 ) + binomialCoeff ( n - 1 , k ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
void alternate ( int & a , int & b , int & x ) { x = a ^ b ^ x ; }
Ref: 
function alternate ( a , b , x ) { return x = a ^ b ^ x ; }
Hyp: 
function alternate ( a , b , x ) { x = a ^ b ^ x ; }

BLEU: 86.58
Edit Sim: 7


Src: 
int subtractOne ( int x ) { int m = 1 ; while ( ! ( x & m ) ) { x = x ^ m ; m <<= 1 ; } x = x ^ m ; return x ; }
Ref: 
function subtractOne ( x ) { let m = 1 ; while ( ! ( x & m ) ) { x = x ^ m ; m <<= 1 ; } x = x ^ m ; return x ; }
Hyp: 
function subtractOne ( x ) { let m = 1 ; while ( ! ( x & m ) ) { x = x ^ m ; m <<= 1 ; } x = x ^ m ; return x ; }

BLEU: 100.0
Edit Sim: 0


Src: 
void printRotatedString ( char str [ ] ) { int n = strlen ( str ) ; char temp [ 2 * n + 1 ] ; strcpy ( temp , str ) ; strcat ( temp , str ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j != n ; j ++ ) printf ( " % c " , temp [ i + j ] ) ; printf ( " STRNEWLINE " ) ; } }
Ref: 
function printRotatedString ( str ) { var n = str . length ; var sb = str ; sb += ( str ) ; for ( var i = 0 ; i < n ; i ++ ) { for ( var j = 0 ; j != n ; j ++ ) document . write ( sb . charAt ( i + j ) ) ; document . write ( ' ' ) ; } }
Hyp: 
function printRotatedString ( str ) { let n = str . length ; let temp = new Array ( 2 * n + 1 ) ; strcpy ( temp , str ) ; strcat ( temp , str ) ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j != n ; j ++ ) document . write ( " " + temp [ i + j ] ) ; document . write ( " " ) ; } }

BLEU: 51.65
Edit Sim: 84


Src: 
int countDistinct ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { while ( i < n - 1 && arr [ i ] == arr [ i + 1 ] ) i ++ ; res ++ ; } return res ; }
Ref: 
function countDistinct ( arr , n ) { arr . sort ( function ( a , b ) { return a - b ; } ) ; let res = 0 ; for ( let i = 0 ; i < n ; i ++ ) { while ( i < n - 1 && arr [ i ] == arr [ i + 1 ] ) { i ++ ; } res ++ ; } return res ; }
Hyp: 
function countDistinct ( arr , n ) { arr . sort ( ( a , b ) => a - b ) ; let res = 0 ; for ( let i = 0 ; i < n ; i ++ ) { while ( i < n - 1 && arr [ i ] == arr [ i + 1 ] ) i ++ ; res ++ ; } return res ; }

BLEU: 81.12
Edit Sim: 25


Src: 
int isSubstring ( string s1 , string s2 ) { int M = s1 . length ( ) ; int N = s2 . length ( ) ; for ( int i = 0 ; i <= N - M ; i ++ ) { int j ; for ( j = 0 ; j < M ; j ++ ) if ( s2 [ i + j ] != s1 [ j ] ) break ; if ( j == M ) return i ; } return -1 ; }
Ref: 
function isSubstring ( s1 , s2 ) { var M = s1 . length ; var N = s2 . length ; for ( var i = 0 ; i <= N - M ; i ++ ) { var j ; for ( j = 0 ; j < M ; j ++ ) if ( s2 [ i + j ] != s1 [ j ] ) break ; if ( j == M ) return i ; } return - 1 ; }
Hyp: 
function isSubstring ( s1 , s2 ) { let M = s1 . length ; let N = s2 . length ; for ( let i = 0 ; i <= N - M ; i ++ ) { let j ; for ( j = 0 ; j < M ; j ++ ) if ( s2 [ i + j ] != s1 [ j ] ) break ; if ( j == M ) return i ; } return - 1 ; }

BLEU: 88.07
Edit Sim: 12


Src: 
int PositionRightmostSetbit ( int n ) { int position = 1 ; int m = 1 ; while ( ! ( n & m ) ) { m = m << 1 ; position ++ ; } return position ; }
Ref: 
function PositionRightmostSetbit ( n ) { let position = 1 ; let m = 1 ; while ( ( n & m ) == 0 ) { m = m << 1 ; position ++ ; } return position ; }
Hyp: 
function PositionRightmostSetbit ( n ) { let position = 1 ; let m = 1 ; while ( ( n & m ) ) { m = m << 1 ; position ++ ; } return position ; }

BLEU: 91.17
Edit Sim: 5


Src: 
int calculate ( int a [ ] , int n ) { sort ( a , a + n ) ; int count = 1 ; int answer = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] == a [ i - 1 ] ) { count += 1 ; } else { answer = answer + ( count * ( count - 1 ) ) / 2 ; count = 1 ; } } answer = answer + ( count * ( count - 1 ) ) / 2 ; return answer ; }
Ref: 
function calculate ( a , n ) { a . sort ( ) ; let count = 1 ; let answer = 0 ; for ( let i = 1 ; i < n ; i ++ ) { if ( a [ i ] == a [ i - 1 ] ) { count += 1 ; } else { answer = answer + Math . floor ( ( count * ( count - 1 ) ) / 2 ) ; count = 1 ; } } answer = answer + Math . floor ( ( count * ( count - 1 ) ) / 2 ) ; return answer ; }
Hyp: 
function calculate ( a , n ) { a . sort ( ( a , b ) => a - b ) ; var count = 1 ; var answer = 0 ; for ( var i = 1 ; i < n ; i ++ ) { if ( a [ i ] == a [ i - 1 ] ) { count += 1 ; } else { answer = answer + ( count * ( count - 1 ) ) / 2 ; count = 1 ; } } answer = answer + ( count * ( count - 1 ) ) / 2 ; return answer ; }

BLEU: 78.11
Edit Sim: 62


Src: 
double circumference ( double r ) { double cir = 2 * PI * r ; return cir ; }
Ref: 
function circumference ( r ) { let cir = 2 * 3.1415 * r ; return cir ; }
Hyp: 
function circumference ( r ) { let cir = 2 * PI * r ; return cir ; }

BLEU: 85.79
Edit Sim: 6


Src: 
string allBitsSetInTheGivenRange ( unsigned int n , unsigned int l , unsigned int r ) { int num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ; int new_num = n & num ; if ( num == new_num ) return " Yes " ; return " No " ; }
Ref: 
function allBitsSetInTheGivenRange ( n , l , r ) { var num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ; var new_num = n & num ; if ( num == new_num ) return " " ; return " " ; }
Hyp: 
function allBitsSetInTheGivenRange ( n , l , r ) { var num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ; var new_num = n & num ; if ( num == new_num ) return " " ; return " " ; }

BLEU: 100.0
Edit Sim: 0


Src: 
bool areSumSame ( int a [ ] [ MAX ] , int n , int m ) { int sum1 = 0 , sum2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum1 = 0 , sum2 = 0 ; for ( int j = 0 ; j < m ; j ++ ) { sum1 += a [ i ] [ j ] ; sum2 += a [ j ] [ i ] ; } if ( sum1 == sum2 ) return true ; } return false ; }
Ref: 
function areSumSame ( a , n , m ) { let sum1 = 0 , sum2 = 0 ; for ( let i = 0 ; i < n ; i ++ ) { sum1 = 0 ; sum2 = 0 ; for ( let j = 0 ; j < m ; j ++ ) { sum1 += a [ i ] [ j ] ; sum2 += a [ j ] [ i ] ; } if ( sum1 == sum2 ) return true ; } return false ; }
Hyp: 
function areSumSame ( a , n , m ) { var sum1 = 0 , sum2 = 0 ; for ( var i = 0 ; i < n ; i ++ ) { sum1 = 0 , sum2 = 0 ; for ( var j = 0 ; j < m ; j ++ ) { sum1 += a [ i ] [ j ] ; sum2 += a [ j ] [ i ] ; } if ( sum1 == sum2 ) return true ; } return false ; }

BLEU: 88.87
Edit Sim: 10


Src: 
int check ( string str ) { int n = str . length ( ) ; int digitSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) digitSum += ( str [ i ] - '0' ) ; return ( digitSum % 3 == 0 ) ; }
Ref: 
function check ( str ) { let n = str . length ; let digitSum = 0 ; for ( let i = 0 ; i < n ; i ++ ) digitSum += ( str [ i ] - ' ' ) ; return ( digitSum % 3 == 0 ) ; }
Hyp: 
function check ( str ) { let n = str . length ; let digitSum = 0 ; for ( let i = 0 ; i < n ; i ++ ) digitSum += ( str [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ) ; return ( digitSum % 3 == 0 ) ; }

BLEU: 81.95
Edit Sim: 34


Src: 
int summation ( int n ) { int sum ; sum = ( pow ( 10 , n + 1 ) - 10 - ( 9 * n ) ) / 81 ; return sum ; }
Ref: 
function summation ( n ) { let sum ; sum = ( Math . pow ( 10 , n + 1 ) - 10 - ( 9 * n ) ) / 81 ; return sum ; }
Hyp: 
function summation ( n ) { let sum = 0 ; for ( let i = 0 ; i <= n ; i ++ ) { let p = ( Math . pow ( 10 , n + 1 ) - 10 - ( 9 * n ) ) / 81 ; sum = sum + p ; } return sum ; }

BLEU: 53.59
Edit Sim: 63


Src: 
bool isPossible ( int Sx , int Sy , int Dx , int Dy , int x , int y ) { if ( abs ( Sx - Dx ) % x == 0 and abs ( Sy - Dy ) % y == 0 and ( abs ( Sx - Dx ) / x ) % 2 == ( abs ( Sy - Dy ) / y ) % 2 ) return true ; return false ; }
Ref: 
function isPossible ( Sx , Sy , Dx , Dy , x , y ) { if ( Math . abs ( Sx - Dx ) % x == 0 && Math . abs ( Sy - Dy ) % y == 0 && ( Math . abs ( Sx - Dx ) / x ) % 2 == ( Math . abs ( Sy - Dy ) / y ) % 2 ) return true ; return false ; }
Hyp: 
function isPossible ( Sx , Sy , Dx , Dy , x , y ) { if ( Math . abs ( Sx - Dx ) % x == 0 and Math . abs ( Sy - Dy ) % y == 0 and ( Math . abs ( Sx - Dx ) / x ) % 2 == ( Math . abs ( Sy - Dy ) / y ) % 2 ) return true ; return false ; }

BLEU: 93.71
Edit Sim: 6


Src: 
void productPuzzle ( int a [ ] , int n ) { long double sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += ( long double ) log10 ( a [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) cout << ( int ) ( EPS + pow ( ( long double ) 10.00 , sum - log10 ( a [ i ] ) ) ) << " ▁ " ; }
Ref: 
function productPuzzle ( a , n ) { var sum = 0 ; for ( var i = 0 ; i < n ; i ++ ) sum += Math . log10 ( a [ i ] ) ; for ( var i = 0 ; i < n ; i ++ ) document . write ( parseInt ( ( EPS + Math . pow ( 10.00 , sum - Math . log10 ( a [ i ] ) ) ) ) + " " ) ; }
Hyp: 
function productPuzzle ( a , n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum += Math . log10 ( a [ i ] ) ; for ( let i = 0 ; i < n ; i ++ ) document . write ( ( int ) ( EPS + Math . pow ( ( long double ) 10.00 , sum - Math . log10 ( a [ i ] ) ) ) + " " ) ; }

BLEU: 81.29
Edit Sim: 34


Src: 
int permutationCoeff ( int n , int k ) { int fact [ n + 1 ] ; fact [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) fact [ i ] = i * fact [ i - 1 ] ; return fact [ n ] / fact [ n - k ] ; }
Ref: 
function permutationCoeff ( n , k ) { let fact = new Array ( n + 1 ) ; fact [ 0 ] = 1 ; for ( let i = 1 ; i <= n ; i ++ ) fact [ i ] = i * fact [ i - 1 ] ; return parseInt ( fact [ n ] / fact [ n - k ] , 10 ) ; }
Hyp: 
function permutationCoeff ( n , k ) { var fact = new Array ( n + 1 ) ; fact [ 0 ] = 1 ; for ( var i = 1 ; i <= n ; i ++ ) fact [ i ] = i * fact [ i - 1 ] ; return fact [ n ] / fact [ n - k ] ; }

BLEU: 81.94
Edit Sim: 24


Src: 
float Time ( float arr [ ] , int n , int Emptypipe ) { float fill = 0 ; for ( int i = 0 ; i < n ; i ++ ) fill += 1 / arr [ i ] ; fill = fill - ( 1 / ( float ) Emptypipe ) ; return 1 / fill ; }
Ref: 
function Time ( arr , n , Emptypipe ) { var fill = 0 ; for ( var i = 0 ; i < n ; i ++ ) fill += 1 / arr [ i ] ; fill = fill - ( 1 / Emptypipe ) ; return 1 / fill ; }
Hyp: 
function Time ( arr , n , Emptypipe ) { let fill = 0 ; for ( let i = 0 ; i < n ; i ++ ) fill += 1 / arr [ i ] ; fill = fill - ( 1 / ( float ) Emptypipe ) ; return 1 / fill ; }

BLEU: 82.82
Edit Sim: 16


Src: 
int countRabbits ( int Heads , int Legs ) { int count = 0 ; count = ( Legs ) -2 * ( Heads ) ; count = count / 2 ; return count ; }
Ref: 
function countRabbits ( Heads , Legs ) { var count = 0 ; count = ( Legs ) - 2 * ( Heads ) ; count = count / 2 ; return count ; }
Hyp: 
function countRabbits ( Heads , Legs ) { let count = 0 ; count = ( Legs ) - 2 * ( Heads ) ; count = count / 2 ; return count ; }

BLEU: 92.58
Edit Sim: 3


Src: 
int count ( int S [ ] , int m , int n ) { if ( n == 0 ) return 1 ; if ( n < 0 ) return 0 ; if ( m <= 0 && n >= 1 ) return 0 ; return count ( S , m - 1 , n ) + count ( S , m , n - S [ m - 1 ] ) ; }
Ref: 
function count ( S , m , n ) { if ( n == 0 ) return 1 ; if ( n < 0 ) return 0 ; if ( m <= 0 && n >= 1 ) return 0 ; return count ( S , m - 1 , n ) + count ( S , m , n - S [ m - 1 ] ) ; }
Hyp: 
function count ( S , m , n ) { if ( n == 0 ) return 1 ; if ( n < 0 ) return 0 ; if ( m <= 0 && n >= 1 ) return 0 ; return count ( S , m - 1 , n ) + count ( S , m , n - S [ m - 1 ] ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
long countWays ( int n , int k ) { long total = k ; int mod = 1000000007 ; int same = 0 , diff = k ; for ( int i = 2 ; i <= n ; i ++ ) { same = diff ; diff = total * ( k - 1 ) ; diff = diff % mod ; total = ( same + diff ) % mod ; } return total ; }
Ref: 
function countWays ( n , k ) { let total = k ; let mod = 1000000007 ; let same = 0 , diff = k ; for ( let i = 2 ; i <= n ; i ++ ) { same = diff ; diff = total * ( k - 1 ) ; diff = diff % mod ; total = ( same + diff ) % mod ; } return total ; }
Hyp: 
function countWays ( n , k ) { let total = k ; let mod = 1000000007 ; let same = 0 , diff = k ; for ( let i = 2 ; i <= n ; i ++ ) { same = diff ; diff = total * ( k - 1 ) ; diff = diff % mod ; total = ( same + diff ) % mod ; } return total ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int findStarNum ( int n ) { return ( 6 * n * ( n - 1 ) + 1 ) ; }
Ref: 
function findStarNum ( n ) { return ( 6 * n * ( n - 1 ) + 1 ) ; }
Hyp: 
function findStarNum ( n ) { return ( 6 * n * ( n - 1 ) + 1 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
char findProffesion ( int level , int pos ) { if ( level == 1 ) return ' e ' ; if ( findProffesion ( level - 1 , ( pos + 1 ) / 2 ) == ' d ' ) return ( pos % 2 ) ? ' d ' : ' e ' ; return ( pos % 2 ) ? ' e ' : ' d ' ; }
Ref: 
function findProffesion ( level , pos ) { if ( level == 1 ) return ' ' ; if ( findProffesion ( level - 1 , ( pos + 1 ) / 2 ) == ' ' ) return ( pos % 2 > 0 ) ? ' ' : ' ' ; return ( pos % 2 > 0 ) ? ' ' : ' ' ; }
Hyp: 
function findProffesion ( level , pos ) { if ( level == 1 ) return ' ' ; if ( findProffesion ( level - 1 , parseInt ( pos + 1 ) / 2 ) == ' ' ) return ( pos % 2 ) ? ' ' : ' ' ; return ( pos % 2 ) ? ' ' : ' ' ; }

BLEU: 87.3
Edit Sim: 17


Src: 
int checkpoint ( int h , int k , int x , int y , int a , int b ) { int p = ( pow ( ( x - h ) , 2 ) / pow ( a , 2 ) ) + ( pow ( ( y - k ) , 2 ) / pow ( b , 2 ) ) ; return p ; }
Ref: 
function checkpoint ( h , k , x , y , a , b ) { var p = ( parseInt ( Math . pow ( ( x - h ) , 2 ) ) / parseInt ( Math . pow ( a , 2 ) ) ) + ( parseInt ( Math . pow ( ( y - k ) , 2 ) ) / parseInt ( Math . pow ( b , 2 ) ) ) ; return p ; }
Hyp: 
function checkpoint ( h , k , x , y , a , b ) { let p = ( Math . pow ( ( x - h ) , 2 ) / Math . pow ( a , 2 ) ) + ( Math . pow ( ( y - k ) , 2 ) / Math . pow ( b , 2 ) ) ; return p ; }

BLEU: 73.69
Edit Sim: 55


Src: 
bool isDivisible ( long long int n ) { while ( n / 100 ) { int last_digit = n % 10 ; n /= 10 ; n += last_digit * 3 ; } return ( n % 29 == 0 ) ; }
Ref: 
function isDivisible ( n ) { while ( parseInt ( n / 100 ) ) { let last_digit = n % 10 ; n = parseInt ( n / 10 ) ; n += last_digit * 3 ; } return ( n % 29 == 0 ) ; }
Hyp: 
function isDivisible ( n ) { while ( parseInt ( n / 100 ) > 0 ) { let last_digit = n % 10 ; n = Math . floor ( n / 10 ) ; n += last_digit * 3 ; } return ( n % 29 == 0 ) ; }

BLEU: 84.54
Edit Sim: 15


Src: 
int calculate ( int X ) { int number_of_bits = 8 ; return ( ( 1 << number_of_bits ) - 1 ) ^ X ; }
Ref: 
function calculate ( X ) { let number_of_bits = 8 ; return ( ( 1 << number_of_bits ) - 1 ) ^ X ; }
Hyp: 
function calculate ( X ) { let number_of_bits = 8 ; return ( ( 1 << number_of_bits ) - 1 ) ^ X ; }

BLEU: 100.0
Edit Sim: 0


Src: 
void calculate ( int a [ ] , int b [ ] , int n , int m ) { int mul = 1 ; for ( int i = 0 ; i < m ; i ++ ) if ( b [ i ] != 0 ) mul = mul * b [ i ] ; for ( int i = 0 ; i < n ; i ++ ) { int x = floor ( a [ i ] / mul ) ; cout << x << " ▁ " ; } }
Ref: 
function calculate ( a , b , n , m ) { let mul = 1 ; for ( let i = 0 ; i < m ; i ++ ) if ( b [ i ] != 0 ) mul = mul * b [ i ] ; for ( let i = 0 ; i < n ; i ++ ) { let x = Math . floor ( a [ i ] / mul ) ; document . write ( x + " " ) ; } }
Hyp: 
function calculate ( a , b , n , m ) { let mul = 1 ; for ( let i = 0 ; i < m ; i ++ ) if ( b [ i ] != 0 ) mul = mul * b [ i ] ; for ( let i = 0 ; i < n ; i ++ ) { let x = Math . floor ( a [ i ] / mul ) ; document . write ( x + " " ) ; } }

BLEU: 100.0
Edit Sim: 0


Src: 
int countDigitsToBeRemoved ( int N , int K ) { string s = to_string ( N ) ; int res = 0 ; int f_zero = 0 ; for ( int i = s . size ( ) - 1 ; i >= 0 ; i -- ) { if ( K == 0 ) return res ; if ( s [ i ] == '0' ) { f_zero = 1 ; K -- ; } else res ++ ; } if ( ! K ) return res ; else if ( f_zero ) return s . size ( ) - 1 ; return -1 ; }
Ref: 
function countDigitsToBeRemoved ( N , K ) { var s = N . toString ( ) ; var res = 0 ; var f_zero = 0 ; for ( var i = s . length - 1 ; i >= 0 ; i -- ) { if ( K === 0 ) return res ; if ( s [ i ] === " " ) { f_zero = 1 ; K -- ; } else res ++ ; } if ( K === 0 ) return res ; else if ( f_zero === 1 ) return s . length - 1 ; return - 1 ; }
Hyp: 
function countDigitsToBeRemoved ( N , K ) { let s = " " ; let res = 0 ; let f_zero = 0 ; for ( let i = s . length - 1 ; i >= 0 ; i -- ) { if ( K == 0 ) return res ; if ( s [ i ] == ' ' ) { f_zero = 1 ; K -- ; } else res ++ ; } if ( ! K ) return res ; else if ( f_zero ) return s . size ( ) - 1 ; return - 1 ; }

BLEU: 69.56
Edit Sim: 50


Src: 
int countWays ( int N ) { int E = ( N * ( N - 1 ) ) / 2 ; if ( N == 1 ) return 0 ; return pow ( 2 , E - 1 ) ; }
Ref: 
function countWays ( N ) { let E = parseInt ( ( N * ( N - 1 ) ) / 2 , 10 ) ; if ( N == 1 ) return 0 ; return Math . pow ( 2 , E - 1 ) ; }
Hyp: 
function countWays ( N ) { let E = ( N * ( N - 1 ) ) / 2 ; if ( N == 1 ) return 0 ; return Math . pow ( 2 , E - 1 ) ; }

BLEU: 82.47
Edit Sim: 18


Src: 
int CountCharacters ( string str , int l , int r ) { int cnt = 0 ; unordered_map < char , int > m ; int len = str . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { if ( ! ( l <= str [ i ] and str [ i ] <= r ) ) { cnt ++ ; if ( m [ str [ i ] ] != 1 ) { cout << str [ i ] << " ▁ " ; m [ str [ i ] ] ++ ; } } } return cnt ; }
Ref: 
function CountCharacters ( str , l , r ) { let cnt = 0 ; let m = new Map ( ) ; let len = str . length ; for ( let i = 0 ; i < len ; i ++ ) { if ( ! ( l <= str [ i ] . charCodeAt ( 0 ) && str [ i ] . charCodeAt ( 0 ) <= r ) ) { cnt ++ ; if ( ! m . has ( str [ i ] ) ) { m . set ( str [ i ] , 0 ) ; document . write ( str [ i ] + " " ) ; } m . set ( str [ i ] , m . get ( str [ i ] + 1 ) ) ; } } return cnt ; }
Hyp: 
function CountCharacters ( str , l , r ) { var cnt = 0 ; var m = new Map ( ) ; var len = str . length ; for ( var i = 0 ; i < len ; i ++ ) { if ( ! ( l <= str [ i ] and str [ i ] <= r ) ) { cnt ++ ; if ( m . has ( str [ i ] ) ) { document . write ( str [ i ] + " " ) ; m . set ( str [ i ] , 1 ) ; } } } return cnt ; }

BLEU: 59.74
Edit Sim: 106


Src: 
bool isSubsetSum ( int set [ ] , int n , int sum ) { if ( sum == 0 ) return true ; if ( n == 0 ) return false ; if ( set [ n - 1 ] > sum ) return isSubsetSum ( set , n - 1 , sum ) ; return isSubsetSum ( set , n - 1 , sum ) || isSubsetSum ( set , n - 1 , sum - set [ n - 1 ] ) ; }
Ref: 
function isSubsetSum ( set , n , sum ) { if ( sum == 0 ) return true ; if ( n == 0 ) return false ; if ( set [ n - 1 ] > sum ) return isSubsetSum ( set , n - 1 , sum ) ; return isSubsetSum ( set , n - 1 , sum ) || isSubsetSum ( set , n - 1 , sum - set [ n - 1 ] ) ; }
Hyp: 
function isSubsetSum ( set , n , sum ) { if ( sum == 0 ) return true ; if ( n == 0 ) return false ; if ( set [ n - 1 ] > sum ) return isSubsetSum ( set , n - 1 , sum ) ; return isSubsetSum ( set , n - 1 , sum ) || isSubsetSum ( set , n - 1 , sum - set [ n - 1 ] ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
float squareSide ( float a ) { if ( a < 0 ) return -1 ; float x = 0.423 * a ; return x ; }
Ref: 
function squareSide ( a ) { if ( a < 0 ) return - 1 ; var x = ( 0.423 * a ) ; return x ; }
Hyp: 
function squareSide ( a ) { if ( a < 0 ) return - 1 ; var x = 0.423 * a ; return x ; }

BLEU: 81.57
Edit Sim: 4


Src: 
int countOnes ( int n ) { int count = 1 ; int rem = 1 ; while ( rem != 0 ) { rem = ( rem * 10 + 1 ) % n ; count ++ ; } return count ; }
Ref: 
function countOnes ( n ) { let count = 1 ; let rem = 1 ; while ( rem != 0 ) { rem = ( rem * 10 + 1 ) % n ; count ++ ; } return count ; }
Hyp: 
function countOnes ( n ) { let count = 1 ; let rem = 1 ; while ( rem != 0 ) { rem = ( rem * 10 + 1 ) % n ; count ++ ; } return count ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int maxPrimes ( int n ) { return n / 2 ; }
Ref: 
function maxPrimes ( n ) { return parseInt ( n / 2 ) ; }
Hyp: 
function maxPrimes ( n ) { return parseInt ( n / 2 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
void transpose ( int A [ ] [ N ] ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = i + 1 ; j < N ; j ++ ) swap ( A [ i ] [ j ] , A [ j ] [ i ] ) ; }
Ref: 
function transpose ( A ) { for ( i = 0 ; i < N ; i ++ ) for ( j = i + 1 ; j < N ; j ++ ) { var temp = A [ i ] [ j ] ; A [ i ] [ j ] = A [ j ] [ i ] ; A [ j ] [ i ] = temp ; } } var A = [ [ 1 , 1 , 1 , 1 ] , [ 2 , 2 , 2 , 2 ] , [ 3 , 3 , 3 , 3 ] , [ 4 , 4 , 4 , 4 ] ] ; transpose ( A ) ; document . write ( " " ) ; for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < N ; j ++ ) document . write ( A [ i ] [ j ] + " " ) ; document . write ( " \< " ) ; }
Hyp: 
function transpose ( A ) { for ( let i = 0 ; i < N ; i ++ ) for ( let j = i + 1 ; j < N ; j ++ ) swap ( A [ i ] [ j ] , A [ j ] [ i ] ) ; }

BLEU: 7.91
Edit Sim: 329


Src: 
int MinimumX ( int a , int b , int c , int k ) { int x = INT_MAX ; if ( k <= c ) return 0 ; int h = k - c ; int l = 0 ; while ( l <= h ) { int m = ( l + h ) / 2 ; if ( ( a * m * m ) + ( b * m ) > ( k - c ) ) { x = min ( x , m ) ; h = m - 1 ; } else if ( ( a * m * m ) + ( b * m ) < ( k - c ) ) l = m + 1 ; else return m ; } return x ; }
Ref: 
function MinimumX ( a , b , c , k ) { let x = Number . MAX_VALUE ; if ( k <= c ) return 0 ; let h = k - c ; let l = 0 ; while ( l <= h ) { let m = Math . floor ( ( l + h ) / 2 ) ; if ( ( a * m * m ) + ( b * m ) > ( k - c ) ) { x = Math . min ( x , m ) ; h = m - 1 ; } else if ( ( a * m * m ) + ( b * m ) < ( k - c ) ) l = m + 1 ; else return m ; } return x ; }
Hyp: 
function MinimumX ( a , b , c , k ) { let x = Number . MAX_VALUE ; if ( k <= c ) return 0 ; let h = k - c ; let l = 0 ; while ( l <= h ) { let m = ( l + h ) / 2 ; if ( ( a * m * m ) + ( b * m ) > ( k - c ) ) { x = Math . min ( x , m ) ; h = m - 1 ; } else if ( ( a * m * m ) + ( b * m ) < ( k - c ) ) l = m + 1 ; else return m ; } return x ; }

BLEU: 94.27
Edit Sim: 17


Src: 
int nthTerm ( int n ) { return 5 * pow ( n , 2 ) - 5 * n ; }
Ref: 
function nthTerm ( n ) { return 5 * Math . pow ( n , 2 ) - 5 * n ; }
Hyp: 
function nthTerm ( n ) { return 5 * Math . pow ( n , 2 ) - 5 * n ; }

BLEU: 100.0
Edit Sim: 0


Src: 
char maxRepeating ( string str ) { int n = str . length ( ) ; int count = 0 ; char res = str [ 0 ] ; int cur_count = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i < n - 1 && str [ i ] == str [ i + 1 ] ) cur_count ++ ; else { if ( cur_count > count ) { count = cur_count ; res = str [ i ] ; } cur_count = 1 ; } } return res ; }
Ref: 
function maxRepeating ( str ) { var n = str . length ; var count = 0 ; var res = str [ 0 ] ; var cur_count = 1 ; for ( var i = 0 ; i < n ; i ++ ) { if ( i < n - 1 && str [ i ] == str [ i + 1 ] ) cur_count ++ ; else { if ( cur_count > count ) { count = cur_count ; res = str [ i ] ; } cur_count = 1 ; } } return res ; }
Hyp: 
function maxRepeating ( str ) { let n = str . length ; let count = 0 ; let res = str [ 0 ] ; let cur_count = 1 ; for ( let i = 0 ; i < n ; i ++ ) { if ( i < n - 1 && str [ i ] == str [ i + 1 ] ) cur_count ++ ; else { if ( cur_count > count ) { count = cur_count ; res = str [ i ] ; } cur_count = 1 ; } } return res ; }

BLEU: 87.18
Edit Sim: 15


Src: 
float trianglearea ( float l , float b ) { if ( l < 0 b < 0 ) return -1 ; float area = ( l * b ) / 2 ; return area ; }
Ref: 
function trianglearea ( l , b ) { if ( l < 0 b < 0 ) return - 1 ; let area = ( l * b ) / 2 ; return area ; }
Hyp: 
function trianglearea ( l , b ) { if ( l < 0 b < 0 ) return - 1 ; var area = ( l * b ) / 2 ; return area ; }

BLEU: 92.79
Edit Sim: 3


Src: 
int lbs ( int arr [ ] , int n ) { int i , j ; int * lis = new int [ n ] ; for ( i = 0 ; i < n ; i ++ ) lis [ i ] = 1 ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; int * lds = new int [ n ] ; for ( i = 0 ; i < n ; i ++ ) lds [ i ] = 1 ; for ( i = n - 2 ; i >= 0 ; i -- ) for ( j = n - 1 ; j > i ; j -- ) if ( arr [ i ] > arr [ j ] && lds [ i ] < lds [ j ] + 1 ) lds [ i ] = lds [ j ] + 1 ; int max = lis [ 0 ] + lds [ 0 ] - 1 ; for ( i = 1 ; i < n ; i ++ ) if ( lis [ i ] + lds [ i ] - 1 > max ) max = lis [ i ] + lds [ i ] - 1 ; return max ; }
Ref: 
function lbs ( arr , n ) { let i , j ; let lis = new Array ( n ) for ( i = 0 ; i < n ; i ++ ) lis [ i ] = 1 ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; let lds = new Array ( n ) ; for ( i = 0 ; i < n ; i ++ ) lds [ i ] = 1 ; for ( i = n - 2 ; i >= 0 ; i -- ) for ( j = n - 1 ; j > i ; j -- ) if ( arr [ i ] > arr [ j ] && lds [ i ] < lds [ j ] + 1 ) lds [ i ] = lds [ j ] + 1 ; let max = lis [ 0 ] + lds [ 0 ] - 1 ; for ( i = 1 ; i < n ; i ++ ) if ( lis [ i ] + lds [ i ] - 1 > max ) max = lis [ i ] + lds [ i ] - 1 ; return max ; }
Hyp: 
function lbs ( arr , n ) { let i , j ; let lis = new Array ( n ) for ( i = 0 ; i < n ; i ++ ) lis [ i ] = 1 ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; let lds = new Array ( n ) ; for ( i = 0 ; i < n ; i ++ ) lds [ i ] = 1 ; for ( i = n - 2 ; i >= 0 ; i -- ) for ( j = n - 1 ; j > i ; j -- ) if ( arr [ i ] > arr [ j ] && lds [ i ] < lds [ j ] + 1 ) lds [ i ] = lds [ j ] + 1 ; let max = lis [ 0 ] + lds [ 0 ] - 1 ; for ( i = 1 ; i < n ; i ++ ) if ( lis [ i ] + lds [ i ] - 1 > max ) max = lis [ i ] + lds [ i ] - 1 ; return max ; }

BLEU: 100.0
Edit Sim: 0


Src: 
float hexadiagonal ( float a ) { if ( a < 0 ) return -1 ; return 2 * a ; }
Ref: 
function hexadiagonal ( a ) { if ( a < 0 ) return - 1 ; return 2 * a ; }
Hyp: 
function hexadiagonal ( a ) { if ( a < 0 ) return - 1 ; return 2 * a ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int countSteps ( int x , int y ) { if ( x % y == 0 ) return x / y ; return x / y + countSteps ( y , x % y ) ; }
Ref: 
function countSteps ( x , y ) { if ( x % y == 0 ) return Math . floor ( x / y ) ; return Math . floor ( x / y ) + countSteps ( y , x % y ) ; }
Hyp: 
function countSteps ( x , y ) { if ( x % y == 0 ) return x / y ; return x / y + countSteps ( y , x % y ) ; }

BLEU: 62.51
Edit Sim: 34


Src: 
void segregate0and1 ( int arr [ ] , int n ) { int type0 = 0 ; int type1 = n - 1 ; while ( type0 < type1 ) { if ( arr [ type0 ] == 1 ) { swap ( arr [ type0 ] , arr [ type1 ] ) ; type1 -- ; } else { type0 ++ ; } } }
Ref: 
function segregate0and1 ( arr , n ) { let type0 = 0 ; let type1 = n - 1 ; while ( type0 < type1 ) { if ( arr [ type0 ] == 1 ) { arr [ type0 ] = arr [ type0 ] + arr [ type1 ] ; arr [ type1 ] = arr [ type0 ] - arr [ type1 ] ; arr [ type0 ] = arr [ type0 ] - arr [ type1 ] ; type1 -- ; } else { type0 ++ ; } } }
Hyp: 
function segregate0and1 ( arr , n ) { let type0 = 0 ; let type1 = n - 1 ; while ( type0 < type1 ) { if ( arr [ type0 ] == 1 ) { swap ( arr [ type0 ] , arr [ type1 ] ) ; type1 -- ; } else { type0 ++ ; } } }

BLEU: 51.26
Edit Sim: 108


Src: 
int makeOdd ( int n ) { if ( n % 2 != 0 ) return 1 ; int resul = 1 ; while ( n % 2 == 0 ) { n /= 2 ; resul *= 2 ; } return resul ; }
Ref: 
function makeOdd ( n ) { if ( n % 2 != 0 ) return 1 ; var ans = 1 ; while ( n % 2 == 0 ) { n = parseInt ( n / 2 ) ; ans *= 2 ; } return ans ; }
Hyp: 
function makeOdd ( n ) { if ( n % 2 != 0 ) return 1 ; let resul = 1 ; while ( n % 2 == 0 ) { n = parseInt ( n / 2 ) ; resul *= 2 ; } return resul ; }

BLEU: 82.57
Edit Sim: 15


Src: 
void find_sum_of_two_squares ( int a , int b ) { int ab = a * b ; for ( int i = 0 ; i * i <= ab ; i ++ ) { for ( int j = i ; i * i + j * j <= ab ; j ++ ) { if ( i * i + j * j == ab ) cout << i << " ^ 2 ▁ + ▁ " << j << " ^ 2 ▁ = ▁ " << ab << " STRNEWLINE " ; } } }
Ref: 
function find_sum_of_two_squares ( a , b ) { let ab = a * b ; for ( let i = 0 ; i * i <= ab ; i ++ ) { for ( let j = i ; i * i + j * j <= ab ; j ++ ) { if ( i * i + j * j == ab ) document . write ( i + " " + j + " " + ab + " " ) ; } } }
Hyp: 
function find_sum_of_two_squares ( a , b ) { let ab = a * b ; for ( let i = 0 ; i * i <= ab ; i ++ ) { for ( let j = i ; i * i + j * j <= ab ; j ++ ) { if ( i * i + j * j == ab ) document . write ( i + " " + j + " " + ab + " " ) ; } } }

BLEU: 100.0
Edit Sim: 0


Src: 
int calculateSum ( int n ) { long long int sum = 0 ; for ( int row = 0 ; row < n ; row ++ ) { sum = sum + ( 1 << row ) ; } return sum ; }
Ref: 
function calculateSum ( n ) { let sum = 0 ; for ( let row = 0 ; row < n ; row ++ ) { sum = sum + ( 1 << row ) ; } return sum ; }
Hyp: 
function calculateSum ( n ) { let sum = 0 ; for ( let row = 0 ; row < n ; row ++ ) { sum = sum + ( 1 << row ) ; } return sum ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int calculateSum ( int n ) { long long int sum = 0 ; sum = 1 << n ; return ( sum - 1 ) ; }
Ref: 
function calculateSum ( n ) { sum = 0 ; sum = 1 << n ; return ( sum - 1 ) ; }
Hyp: 
function calculateSum ( n ) { let sum = 0 ; sum = 1 << n ; return ( sum - 1 ) ; }

BLEU: 89.42
Edit Sim: 4


Src: 
bool EqualNumber ( int A , int B ) { return ( A ^ B ) ; }
Ref: 
function EqualNumber ( A , B ) { return ( A ^ B ) ; }
Hyp: 
function EqualNumber ( A , B ) { return ( A ^ B ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int minCost ( int cost [ ] [ N ] ) { int dist [ N ] ; for ( int i = 0 ; i < N ; i ++ ) dist [ i ] = INF ; dist [ 0 ] = 0 ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = i + 1 ; j < N ; j ++ ) if ( dist [ j ] > dist [ i ] + cost [ i ] [ j ] ) dist [ j ] = dist [ i ] + cost [ i ] [ j ] ; return dist [ N - 1 ] ; }
Ref: 
function minCost ( cost ) { let dist = new Array ( N ) ; dist . fill ( 0 ) ; for ( let i = 0 ; i < N ; i ++ ) dist [ i ] = INF ; dist [ 0 ] = 0 ; for ( let i = 0 ; i < N ; i ++ ) for ( let j = i + 1 ; j < N ; j ++ ) if ( dist [ j ] > dist [ i ] + cost [ i ] [ j ] ) dist [ j ] = dist [ i ] + cost [ i ] [ j ] ; return dist [ N - 1 ] ; }
Hyp: 
function minCost ( cost ) { let dist = new Array ( N ) ; for ( let i = 0 ; i < N ; i ++ ) dist [ i ] = INF ; dist [ 0 ] = 0 ; for ( let i = 0 ; i < N ; i ++ ) for ( let j = i + 1 ; j < N ; j ++ ) if ( dist [ j ] > dist [ i ] + cost [ i ] [ j ] ) dist [ j ] = dist [ i ] + cost [ i ] [ j ] ; return dist [ N - 1 ] ; }

BLEU: 94.13
Edit Sim: 20


Src: 
float findRadiusOfcircumcircle ( float l , float b ) { if ( l < 0 b < 0 ) return -1 ; float radius = sqrt ( pow ( l , 2 ) + pow ( b , 2 ) ) / 2 ; return radius ; }
Ref: 
function findRadiusOfcircumcircle ( l , b ) { if ( l < 0 b < 0 ) return - 1 ; var radius = Math . sqrt ( Math . pow ( l , 2 ) + Math . pow ( b , 2 ) ) / 2 ; return radius ; }
Hyp: 
function findRadiusOfcircumcircle ( l , b ) { if ( l < 0 b < 0 ) return - 1 ; var radius = Math . sqrt ( Math . pow ( l , 2 ) + Math . pow ( b , 2 ) ) / 2 ; return radius ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int countWays ( int n ) { int res [ n + 1 ] ; res [ 0 ] = 1 ; res [ 1 ] = 1 ; res [ 2 ] = 2 ; for ( int i = 3 ; i <= n ; i ++ ) res [ i ] = res [ i - 1 ] + res [ i - 2 ] + res [ i - 3 ] ; return res [ n ] ; }
Ref: 
function countWays ( n ) { let res = new Array ( n + 2 ) ; res [ 0 ] = 1 ; res [ 1 ] = 1 ; res [ 2 ] = 2 ; for ( let i = 3 ; i <= n ; i ++ ) res [ i ] = res [ i - 1 ] + res [ i - 2 ] + res [ i - 3 ] ; return res [ n ] ; }
Hyp: 
function countWays ( n ) { let res = new Array ( n + 1 ) ; res [ 0 ] = 1 ; res [ 1 ] = 1 ; res [ 2 ] = 2 ; for ( let i = 3 ; i <= n ; i ++ ) res [ i ] = res [ i - 1 ] + res [ i - 2 ] + res [ i - 3 ] ; return res [ n ] ; }

BLEU: 97.01
Edit Sim: 1


Src: 
int sumofNterm ( int a , int d , int b , int r , int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += ( ( a + ( i - 1 ) * d ) * ( b * pow ( r , i - 1 ) ) ) ; return sum ; }
Ref: 
function sumofNterm ( a , d , b , r , n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) sum += ( ( a + ( i - 1 ) * d ) * ( b * Math . pow ( r , i - 1 ) ) ) ; return sum ; }
Hyp: 
function sumofNterm ( a , d , b , r , n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) sum += ( ( a + ( i - 1 ) * d ) * ( b * Math . pow ( r , i - 1 ) ) ) ; return sum ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int perimeter ( int diameter , int height ) { return 2 * ( diameter + height ) ; }
Ref: 
function perimeter ( diameter , height ) { return 2 * ( diameter + height ) ; }
Hyp: 
function perimeter ( diameter , height ) { return 2 * ( diameter + height ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int smallestEven ( int n ) { if ( n == 1 ) return 0 ; return pow ( 10 , n - 1 ) ; }
Ref: 
function smallestEven ( n ) { if ( n == 1 ) return 0 ; return Math . pow ( 10 , n - 1 ) ; }
Hyp: 
function smallestEven ( n ) { if ( n == 1 ) return 0 ; return Math . pow ( 10 , parseInt ( n - 1 ) ) ; }

BLEU: 82.23
Edit Sim: 13


Src: 
int totalSumDivisibleByNum ( int n , int number ) { int firstnum = pow ( 10 , n - 1 ) ; int lastnum = pow ( 10 , n ) ; int sum = 0 ; for ( int i = firstnum ; i < lastnum ; i ++ ) if ( i % number == 0 ) sum += i ; return sum ; }
Ref: 
function totalSumDivisibleByNum ( n , number ) { let firstnum = Math . pow ( 10 , n - 1 ) ; let lastnum = Math . pow ( 10 , n ) ; let sum = 0 ; for ( let i = firstnum ; i < lastnum ; i ++ ) if ( i % number == 0 ) sum += i ; return sum ; }
Hyp: 
function totalSumDivisibleByNum ( n , number ) { let firstnum = Math . pow ( 10 , n - 1 ) ; let lastnum = Math . pow ( 10 , n ) ; let sum = 0 ; for ( let i = firstnum ; i < lastnum ; i ++ ) if ( i % number == 0 ) sum += i ; return sum ; }

BLEU: 100.0
Edit Sim: 0


Src: 
void printPair ( int g , int l ) { cout << g << " ▁ " << l ; }
Ref: 
function printPair ( g , l ) { document . write ( g + " " + l ) ; }
Hyp: 
function printPair ( g , l ) { document . write ( g + " " + l ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
void leftRotate ( int arr [ ] , int n , int k ) { for ( int i = k ; i < k + n ; i ++ ) cout << arr [ i % n ] << " ▁ " ; }
Ref: 
function leftRotate ( arr , n , k ) { for ( let i = k ; i < k + n ; i ++ ) document . write ( arr [ i % n ] + " " ) ; }
Hyp: 
function leftRotate ( arr , n , k ) { for ( let i = k ; i < k + n ; i ++ ) document . write ( arr [ i % n ] + " " ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
float normal ( float m , float n ) { float N = ( fabsf ( m ) * fabsf ( n ) ) / sqrt ( ( fabsf ( m ) * fabsf ( m ) ) + ( fabsf ( n ) * fabsf ( n ) ) ) ; return N ; }
Ref: 
function normal ( m , n ) { var N = ( ( Math . abs ( m ) * Math . abs ( n ) ) / Math . sqrt ( ( Math . abs ( m ) * Math . abs ( m ) ) + ( Math . abs ( n ) * Math . abs ( n ) ) ) ) ; return N ; }
Hyp: 
function normal ( m , n ) { let N = ( Math . abs ( m ) * Math . abs ( n ) ) / Math . sqrt ( ( Math . abs ( m ) * Math . abs ( m ) ) + ( Math . abs ( n ) * Math . abs ( n ) ) ) ; return N ; }

BLEU: 92.34
Edit Sim: 7


Src: 
int countPaths ( int m , int n ) { if ( m == 1 n == 1 ) return 1 ; return countPaths ( m - 1 , n ) + countPaths ( m , n - 1 ) ; }
Ref: 
function countPaths ( m , n ) { if ( m == 1 n == 1 ) return 1 ; return countPaths ( m - 1 , n ) + countPaths ( m , n - 1 ) ; }
Hyp: 
function countPaths ( m , n ) { if ( m == 1 n == 1 ) return 1 ; return countPaths ( m - 1 , n ) + countPaths ( m , n - 1 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int seriesSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += i * ( i + 1 ) / 2 ; return sum ; }
Ref: 
function seriesSum ( n ) { var sum = 0 ; for ( i = 1 ; i <= n ; i ++ ) sum += i * ( ( i + 1 ) / 2 ) ; return sum ; }
Hyp: 
function seriesSum ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) sum += i * ( i + 1 ) / 2 ; return sum ; }

BLEU: 79.12
Edit Sim: 11


Src: 
int nthMagicNo ( int n ) { int pow = 1 , answer = 0 ; while ( n ) { pow = pow * 5 ; if ( n & 1 ) answer += pow ; } return answer ; }
Ref: 
function nthMagicNo ( n ) { let pow = 1 , answer = 0 ; while ( n != 0 ) { pow = pow * 5 ; if ( ( n & 1 ) == 1 ) answer += pow ; n >>= 1 ; } return answer ; }
Hyp: 
function nthMagicNo ( n ) { let pow = 1 , answer = 0 ; while ( n ) { pow = pow * 5 ; if ( n & 1 ) answer += pow ; } return answer ; }

BLEU: 71.62
Edit Sim: 24


Src: 
long findSumSubsets ( int n ) { return ( n * ( n + 1 ) / 2 ) * ( 1 << ( n - 1 ) ) ; }
Ref: 
function findSumSubsets ( n ) { return ( n * ( n + 1 ) / 2 ) * ( 1 << ( n - 1 ) ) ; }
Hyp: 
function findSumSubsets ( n ) { return ( n * ( n + 1 ) / 2 ) * ( 1 << ( n - 1 ) ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int countPaths ( int n ) { int zB = 1 ; int zADC = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int nzB = zADC * 3 ; int nzADC = ( zADC * 2 + zB ) ; zB = nzB ; zADC = nzADC ; } return zB ; }
Ref: 
function countPaths ( n ) { let zB = 1 ; let zADC = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { let nzB = zADC * 3 ; let nzADC = ( zADC * 2 + zB ) ; zB = nzB ; zADC = nzADC ; } return zB ; }
Hyp: 
function countPaths ( n ) { let zB = 1 ; let zADC = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { let nzB = zADC * 3 ; let nzADC = ( zADC * 2 + zB ) ; zB = nzB ; zADC = nzADC ; } return zB ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int pell ( int n ) { if ( n <= 2 ) return n ; int a = 1 ; int b = 2 ; int c , i ; for ( i = 3 ; i <= n ; i ++ ) { c = 2 * b + a ; a = b ; b = c ; } return b ; }
Ref: 
function pell ( n ) { if ( n <= 2 ) return n ; let a = 1 ; let b = 2 ; let c ; for ( let i = 3 ; i <= n ; i ++ ) { c = 2 * b + a ; a = b ; b = c ; } return b ; }
Hyp: 
function pell ( n ) { if ( n <= 2 ) return n ; let a = 1 ; let b = 2 ; let c , i ; for ( i = 3 ; i <= n ; i ++ ) { c = 2 * b + a ; a = b ; b = c ; } return b ; }

BLEU: 92.12
Edit Sim: 8


Src: 
void shortestLength ( int n , int x [ ] , int y [ ] ) { int answer = 0 ; int i = 0 ; while ( n -- ) { if ( x [ i ] + y [ i ] > answer ) answer = x [ i ] + y [ i ] ; i ++ ; } cout << " Length ▁ - > ▁ " << answer << endl ; cout << " Path ▁ - > ▁ " << " ( ▁ 1 , ▁ " << answer << " ▁ ) " << " and ▁ ( ▁ " << answer << " , ▁ 1 ▁ ) " ; }
Ref: 
function shortestLength ( n , x , y ) { let answer = 0 ; let i = 0 ; while ( n != 0 && i < x . length ) { if ( x [ i ] + y [ i ] > answer ) answer = x [ i ] + y [ i ] ; i ++ ; } document . write ( " " + answer + " " ) ; document . write ( " " + " " + answer + " " + " " + answer + " " ) ; }
Hyp: 
function shortestLength ( n , x , y ) { let answer = 0 ; let i = 0 ; while ( n -- ) { if ( x [ i ] + y [ i ] > answer ) answer = x [ i ] + y [ i ] ; i ++ ; } document . write ( " " + answer + " " ) ; document . write ( " " + x [ i ] + y [ i ] + " " ) ; }

BLEU: 77.35
Edit Sim: 46


Src: 
bool isRatioPossible ( int lowCost , int upCost , int lowQuant , int upQuant , int r ) { for ( int i = lowQuant ; i <= upQuant ; i ++ ) { int ans = i * r ; if ( lowCost <= ans && ans <= upCost ) return true ; } return false ; }
Ref: 
function isRatioPossible ( lowCost , upCost , lowQuant , upQuant , r ) { for ( let i = lowQuant ; i <= upQuant ; i ++ ) { let ans = i * r ; if ( lowCost <= ans && ans <= upCost ) return true ; } return false ; }
Hyp: 
function isRatioPossible ( lowCost , upCost , lowQuant , upQuant , r ) { for ( let i = lowQuant ; i <= upQuant ; i ++ ) { let ans = i * r ; if ( lowCost <= ans && ans <= upCost ) return true ; } return false ; }

BLEU: 100.0
Edit Sim: 0


Src: 
bool isTidy ( int num ) { int prev = 10 ; while ( num ) { int rem = num % 10 ; num /= 10 ; if ( rem > prev ) return false ; prev = rem ; } return true ; }
Ref: 
function isTidy ( num ) { let prev = 10 ; while ( num != 0 ) { let rem = num % 10 ; num /= 10 ; if ( rem > prev ) return false ; prev = rem ; } return true ; }
Hyp: 
function isTidy ( num ) { let prev = 10 ; while ( num ) { let rem = num % 10 ; num = Math . floor ( num / 10 ) ; if ( rem > prev ) return false ; prev = rem ; } return true ; }

BLEU: 76.87
Edit Sim: 29


Src: 
void complement ( string number ) { for ( int i = 0 ; i < number . length ( ) ; i ++ ) if ( number [ i ] != ' . ' ) number [ i ] = '9' - number [ i ] + '0' ; cout << "9 ' s ▁ complement ▁ is ▁ : ▁ " << number ; }
Ref: 
function complement ( number ) { number = number . split ( ' ' ) for ( let i = 0 ; i < number . length ; i ++ ) { if ( number [ i ] != ' ' ) { number [ i ] = String ( 9 - Number ( number [ i ] ) + 0 ) ; } } number = number . join ( " " ) document . write ( " " + number ) ; }
Hyp: 
function complement ( number ) { for ( let i = 0 ; i < number . length ; i ++ ) { if ( number [ i ] != ' ' ) number [ i ] = ' ' - number [ i ] + ' ' ; document . write ( " " + number + " " ) ; } }

BLEU: 54.3
Edit Sim: 99


Src: 
void pendulumArrangement ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int op [ n ] ; int mid = ( n - 1 ) / 2 ; int j = 1 , i = 1 ; op [ mid ] = arr [ 0 ] ; for ( i = 1 ; i <= mid ; i ++ ) { op [ mid + i ] = arr [ j ++ ] ; op [ mid - i ] = arr [ j ++ ] ; } if ( n % 2 == 0 ) op [ mid + i ] = arr [ j ] ; cout << " Pendulum ▁ arrangement : " << endl ; for ( i = 0 ; i < n ; i ++ ) cout << op [ i ] << " ▁ " ; cout << endl ; }
Ref: 
function pendulumArrangement ( arr , n ) { arr . sort ( function ( a , b ) { return a - b ; } ) ; var op = [ ... Array ( n ) ] ; var mid = parseInt ( ( n - 1 ) / 2 ) ; var j = 1 , i = 1 ; op [ mid ] = arr [ 0 ] ; for ( i = 1 ; i <= mid ; i ++ ) { op [ mid + i ] = arr [ j ++ ] ; op [ mid - i ] = arr [ j ++ ] ; } if ( n % 2 == 0 ) op [ mid + i ] = arr [ j ] ; document . write ( " " ) ; for ( i = 0 ; i < n ; i ++ ) document . write ( op [ i ] + " " ) ; document . write ( " " ) ; }
Hyp: 
function pendulumArrangement ( arr , n ) { arr . sort ( function ( a , b ) { return a - b } ) ; let op = new Array ( n ) ; let mid = parseInt ( ( n - 1 ) / 2 ) ; let j = 1 , i = 1 ; op [ mid ] = arr [ 0 ] ; for ( i = 1 ; i <= mid ; i ++ ) { op [ mid + i ] = arr [ j ++ ] ; op [ mid - i ] = arr [ j ++ ] ; } if ( n % 2 == 0 ) op [ mid + i ] = arr [ j ] ; document . write ( " " + op [ i ] + " " ) ; document . write ( " " ) ; }

BLEU: 79.03
Edit Sim: 68


Src: 
int findS ( int s ) { int l = 1 , r = ( s / 2 ) + 1 ; while ( l <= r ) { int mid = ( l + r ) / 2 ; int sum = mid * ( mid + 1 ) / 2 ; if ( sum == s ) return mid ; else if ( sum > s ) r = mid - 1 ; else l = mid + 1 ; } return -1 ; }
Ref: 
function findS ( s ) { var l = 1 , r = parseInt ( ( s / 2 ) + 1 ) ; while ( l <= r ) { var mid = parseInt ( ( l + r ) / 2 ) ; var sum = mid * parseInt ( ( mid + 1 ) / 2 ) ; if ( sum == s ) return mid ; else if ( sum > s ) r = mid - 1 ; else l = mid + 1 ; } return - 1 ; }
Hyp: 
function findS ( s ) { let l = 1 , r = ( s / 2 ) + 1 ; while ( l <= r ) { let mid = parseInt ( ( l + r ) / 2 ) ; let sum = mid * ( mid + 1 ) / 2 ; if ( sum == s ) return mid ; else if ( sum > s ) r = mid - 1 ; else l = mid + 1 ; } return - 1 ; }

BLEU: 78.89
Edit Sim: 35


Src: 
void printNumberWithDR ( int k , int d ) { if ( d == 0 && k != 1 ) cout << " - 1" ; else { cout << d ; k -- ; while ( k -- ) cout << "0" ; } }
Ref: 
function printNumberWithDR ( k , d ) { if ( d == 0 && k != 1 ) document . write ( " " ) ; else { document . write ( d ) ; k -- ; while ( k -- > 0 ) document . write ( " " ) ; } }
Hyp: 
function printNumberWithDR ( k , d ) { if ( d == 0 && k != 1 ) document . write ( " " ) ; else { document . write ( d ) ; k -- ; while ( k -- ) document . write ( " " ) ; } }

BLEU: 93.48
Edit Sim: 4


Src: 
void fib ( int n ) { int a = 0 , b = 1 , c ; if ( n >= 0 ) cout << a << " ▁ " ; if ( n >= 1 ) cout << b << " ▁ " ; for ( int i = 2 ; i <= n ; i ++ ) { c = a + b ; cout << c << " ▁ " ; a = b ; b = c ; } }
Ref: 
function fib ( n ) { let a = 0 , b = 1 , c ; if ( n >= 0 ) document . write ( a + " " ) ; if ( n >= 1 ) document . write ( b + " " ) ; for ( let i = 2 ; i <= n ; i ++ ) { c = a + b ; document . write ( c + " " ) ; a = b ; b = c ; } }
Hyp: 
function fib ( n ) { let a = 0 , b = 1 , c ; if ( n >= 0 ) document . write ( a + " " ) ; if ( n >= 1 ) document . write ( b + " " ) ; for ( let i = 2 ; i <= n ; i ++ ) { c = a + b ; document . write ( c + " " ) ; a = b ; b = c ; } }

BLEU: 100.0
Edit Sim: 0


Src: 
int Next_greater ( int a [ ] , int n , int x ) { sort ( a , a + n ) ; int low = 0 , high = n - 1 , ans = x + 1 ; while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( a [ mid ] <= ans ) { if ( a [ mid ] == ans ) { ans ++ ; high = n - 1 ; } low = mid + 1 ; } else high = mid - 1 ; } return ans ; }
Ref: 
function Next_greater ( a , n , x ) { a . sort ( function ( aa , bb ) { return aa - bb } ) ; let low = 0 , high = n - 1 , ans = x + 1 ; while ( low <= high ) { let mid = Math . floor ( ( low + high ) / 2 ) ; if ( a [ mid ] <= ans ) { if ( a [ mid ] == ans ) { ans ++ ; high = n - 1 ; } low = mid + 1 ; } else high = mid - 1 ; } return ans ; }
Hyp: 
function Next_greater ( a , n , x ) { a . sort ( ( a , b ) => a - b ) ; let low = 0 , high = n - 1 , ans = x + 1 ; while ( low <= high ) { let mid = parseInt ( ( low + high ) / 2 ) ; if ( a [ mid ] <= ans ) { if ( a [ mid ] == ans ) { ans ++ ; high = n - 1 ; } low = mid + 1 ; } else high = mid - 1 ; } return ans ; }

BLEU: 85.25
Edit Sim: 34


Src: 
int minTime ( int arr [ ] , int n ) { if ( n <= 0 ) return 0 ; int incl = arr [ 0 ] ; int excl = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int incl_new = arr [ i ] + min ( excl , incl ) ; int excl_new = incl ; incl = incl_new ; excl = excl_new ; } return min ( incl , excl ) ; }
Ref: 
function minTime ( arr , n ) { if ( n <= 0 ) return 0 ; let incl = arr [ 0 ] ; let excl = 0 ; for ( let i = 1 ; i < n ; i ++ ) { let incl_new = arr [ i ] + Math . min ( excl , incl ) ; let excl_new = incl ; incl = incl_new ; excl = excl_new ; } return Math . min ( incl , excl ) ; }
Hyp: 
function minTime ( arr , n ) { if ( n <= 0 ) return 0 ; let incl = arr [ 0 ] ; let excl = 0 ; for ( let i = 1 ; i < n ; i ++ ) { let incl_new = arr [ i ] + Math . min ( excl , incl ) ; let excl_new = incl ; incl = incl_new ; excl = excl_new ; } return Math . min ( incl , excl ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int countPaths ( int n , int m ) { int dp [ n + 1 ] [ m + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = 1 ; for ( int i = 0 ; i <= m ; i ++ ) dp [ 0 ] [ i ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= m ; j ++ ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] ; return dp [ n ] [ m ] ; }
Ref: 
function countPaths ( n , m ) { var dp = Array ( n + 1 ) . fill ( 0 ) . map ( x => Array ( m + 1 ) . fill ( 0 ) ) ; for ( i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = 1 ; for ( i = 0 ; i <= m ; i ++ ) dp [ 0 ] [ i ] = 1 ; for ( i = 1 ; i <= n ; i ++ ) for ( j = 1 ; j <= m ; j ++ ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] ; return dp [ n ] [ m ] ; }
Hyp: 
function countPaths ( n , m ) { let dp = Array . from ( Array ( n + 1 ) , ( ) => Array ( m + 1 ) ) ; for ( let i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = 1 ; for ( let i = 0 ; i <= m ; i ++ ) dp [ 0 ] [ i ] = 1 ; for ( let i = 1 ; i <= n ; i ++ ) for ( let j = 1 ; j <= m ; j ++ ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] ; return dp [ n ] [ m ] ; }

BLEU: 83.29
Edit Sim: 52


Src: 
int maxSumWO3Consec ( int arr [ ] , int n ) { int sum [ n ] ; if ( n >= 1 ) sum [ 0 ] = arr [ 0 ] ; if ( n >= 2 ) sum [ 1 ] = arr [ 0 ] + arr [ 1 ] ; if ( n > 2 ) sum [ 2 ] = max ( sum [ 1 ] , max ( arr [ 1 ] + arr [ 2 ] , arr [ 0 ] + arr [ 2 ] ) ) ; for ( int i = 3 ; i < n ; i ++ ) sum [ i ] = max ( max ( sum [ i - 1 ] , sum [ i - 2 ] + arr [ i ] ) , arr [ i ] + arr [ i - 1 ] + sum [ i - 3 ] ) ; return sum [ n - 1 ] ; }
Ref: 
function maxSumWO3Consec ( arr , n ) { let sum = [ ] ; if ( n >= 1 ) sum [ 0 ] = arr [ 0 ] ; if ( n >= 2 ) sum [ 1 ] = arr [ 0 ] + arr [ 1 ] ; if ( n > 2 ) sum [ 2 ] = Math . max ( sum [ 1 ] , Math . max ( arr [ 1 ] + arr [ 2 ] , arr [ 0 ] + arr [ 2 ] ) ) ; for ( let i = 3 ; i < n ; i ++ ) sum [ i ] = Math . max ( Math . max ( sum [ i - 1 ] , sum [ i - 2 ] + arr [ i ] ) , arr [ i ] + arr [ i - 1 ] + sum [ i - 3 ] ) ; return sum [ n - 1 ] ; }
Hyp: 
function maxSumWO3Consec ( arr , n ) { let sum = new Array ( n ) ; if ( n >= 1 ) sum [ 0 ] = arr [ 0 ] ; if ( n >= 2 ) sum [ 1 ] = arr [ 0 ] + arr [ 1 ] ; if ( n > 2 ) sum [ 2 ] = Math . max ( sum [ 1 ] , Math . max ( arr [ 1 ] + arr [ 2 ] , arr [ 0 ] + arr [ 2 ] ) ) ; for ( let i = 3 ; i < n ; i ++ ) sum [ i ] = Math . max ( max ( sum [ i - 1 ] , sum [ i - 2 ] + arr [ i ] ) , arr [ i ] + arr [ i - 1 ] + sum [ i - 3 ] ) ; return sum [ n - 1 ] ; }

BLEU: 95.37
Edit Sim: 21


Src: 
int centered_heptagonal_num ( long int n ) { return ( 7 * n * n - 7 * n + 2 ) / 2 ; }
Ref: 
function centered_heptagonal_num ( n ) { return parseInt ( ( 7 * n * n - 7 * n + 2 ) / 2 ) ; }
Hyp: 
function centered_heptagonal_num ( n ) { return ( 7 * n * n - 7 * n + 2 ) / 2 ; }

BLEU: 77.18
Edit Sim: 13


Src: 
bool isSubsetSum ( int set [ ] , int n , int sum ) { if ( sum == 0 ) return true ; if ( n == 0 ) return false ; if ( set [ n - 1 ] > sum ) return isSubsetSum ( set , n - 1 , sum ) ; return isSubsetSum ( set , n - 1 , sum ) || isSubsetSum ( set , n - 1 , sum - set [ n - 1 ] ) ; }
Ref: 
function isSubsetSum ( set , n , sum ) { if ( sum == 0 ) return true ; if ( n == 0 ) return false ; if ( set [ n - 1 ] > sum ) return isSubsetSum ( set , n - 1 , sum ) ; return isSubsetSum ( set , n - 1 , sum ) || isSubsetSum ( set , n - 1 , sum - set [ n - 1 ] ) ; }
Hyp: 
function isSubsetSum ( set , n , sum ) { if ( sum == 0 ) return true ; if ( n == 0 ) return false ; if ( set [ n - 1 ] > sum ) return isSubsetSum ( set , n - 1 , sum ) ; return isSubsetSum ( set , n - 1 , sum ) || isSubsetSum ( set , n - 1 , sum - set [ n - 1 ] ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
void makePolygon ( float a ) { float n = 360 / ( 180 - a ) ; if ( n == ( int ) n ) cout << " YES " ; else cout << " NO " ; }
Ref: 
function makePolygon ( a ) { var n = parseFloat ( 360 / ( 180 - a ) ) ; if ( n === parseInt ( n ) ) document . write ( " " ) ; else document . write ( " " ) ; }
Hyp: 
function makePolygon ( a ) { let n = 360 / ( 180 - a ) ; if ( n == parseInt ( n ) ) document . write ( " " ) ; else document . write ( " " ) ; }

BLEU: 77.68
Edit Sim: 19


Src: 
int binomialCoeff ( int n , int k ) { int res = 1 ; if ( k > n - k ) k = n - k ; for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; }
Ref: 
function binomialCoeff ( n , k ) { let res = 1 ; if ( k > n - k ) k = n - k ; for ( let i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; }
Hyp: 
function binomialCoeff ( n , k ) { let res = 1 ; if ( k > n - k ) k = n - k ; for ( let i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int minimumBox ( int arr [ ] , int n ) { queue < int > q ; queue < int > q ; sort ( arr , arr + n ) ; q . push ( arr [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { int now = q . front ( ) ; if ( arr [ i ] >= 2 * now ) q . pop ( ) ; q . push ( arr [ i ] ) ; } return q . size ( ) ; }
Ref: 
function minimumBox ( arr , n ) { var q = [ ] ; arr . sort ( ( a , b ) => a - b ) q . push ( arr [ 0 ] ) ; for ( var i = 1 ; i < n ; i ++ ) { var now = q [ 0 ] ; if ( arr [ i ] >= 2 * now ) q . pop ( 0 ) ; q . push ( arr [ i ] ) ; } return q . length ; }
Hyp: 
function minimumBox ( arr , n ) { var q = [ ] ; arr . sort ( function ( a , b ) { return a - b ; } ) ; q . push ( arr [ 0 ] ) ; for ( var i = 1 ; i < n ; i ++ ) { var now = q . pop ( ) ; if ( arr [ i ] >= 2 * now ) q . push ( arr [ i ] ) ; } return q . size ( ) ; }

BLEU: 82.28
Edit Sim: 53


Src: 
int countIncreasing ( int arr [ ] , int n ) { int cnt = 0 ; int len = 1 ; for ( int i = 0 ; i < n - 1 ; ++ i ) { if ( arr [ i + 1 ] > arr [ i ] ) len ++ ; else { cnt += ( ( ( len - 1 ) * len ) / 2 ) ; len = 1 ; } } if ( len > 1 ) cnt += ( ( ( len - 1 ) * len ) / 2 ) ; return cnt ; }
Ref: 
function countIncreasing ( n ) { let cnt = 0 ; let len = 1 ; for ( let i = 0 ; i < n - 1 ; ++ i ) { if ( arr [ i + 1 ] > arr [ i ] ) len ++ ; else { cnt += ( ( ( len - 1 ) * len ) / 2 ) ; len = 1 ; } } if ( len > 1 ) cnt += ( ( ( len - 1 ) * len ) / 2 ) ; return cnt ; }
Hyp: 
function countIncreasing ( arr , n ) { let cnt = 0 ; let len = 1 ; for ( let i = 0 ; i < n - 1 ; ++ i ) { if ( arr [ i + 1 ] > arr [ i ] ) len ++ ; else { cnt += parseInt ( ( ( len - 1 ) * len ) / 2 ) ; len = 1 ; } } if ( len > 1 ) cnt += parseInt ( ( ( len - 1 ) * len ) / 2 ) ; return cnt ; }

BLEU: 91.69
Edit Sim: 24


Src: 
int longestSubseqWithDiffOne ( int arr [ ] , int n ) { int dp [ n ] ; for ( int i = 0 ; i < n ; i ++ ) dp [ i ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( ( arr [ i ] == arr [ j ] + 1 ) || ( arr [ i ] == arr [ j ] - 1 ) ) dp [ i ] = max ( dp [ i ] , dp [ j ] + 1 ) ; } } int result = 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( result < dp [ i ] ) result = dp [ i ] ; return result ; }
Ref: 
function longestSubseqWithDiffOne ( arr , n ) { let dp = [ ] ; for ( let i = 0 ; i < n ; i ++ ) dp [ i ] = 1 ; for ( let i = 1 ; i < n ; i ++ ) { for ( let j = 0 ; j < i ; j ++ ) { if ( ( arr [ i ] == arr [ j ] + 1 ) || ( arr [ i ] == arr [ j ] - 1 ) ) dp [ i ] = Math . max ( dp [ i ] , dp [ j ] + 1 ) ; } } let result = 1 ; for ( let i = 0 ; i < n ; i ++ ) if ( result < dp [ i ] ) result = dp [ i ] ; return result ; }
Hyp: 
function longestSubseqWithDiffOne ( arr , n ) { let dp = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) dp [ i ] = 1 ; for ( let i = 1 ; i < n ; i ++ ) { for ( let j = 0 ; j < i ; j ++ ) { if ( ( arr [ i ] == arr [ j ] + 1 ) || ( arr [ i ] == arr [ j ] - 1 ) ) dp [ i ] = Math . max ( dp [ i ] , dp [ j ] + 1 ) ; } } let result = 1 ; for ( let i = 0 ; i < n ; i ++ ) if ( result < dp [ i ] ) result = dp [ i ] ; return result ; }

BLEU: 95.94
Edit Sim: 14


Src: 
int closestNumber ( int n , int m ) { int q = n / m ; int n1 = m * q ; int n2 = ( n * m ) > 0 ? ( m * ( q + 1 ) ) : ( m * ( q - 1 ) ) ; if ( abs ( n - n1 ) < abs ( n - n2 ) ) return n1 ; return n2 ; }
Ref: 
function closestNumber ( n , m ) { let q = parseInt ( n / m ) ; let n1 = m * q ; let n2 = ( n * m ) > 0 ? ( m * ( q + 1 ) ) : ( m * ( q - 1 ) ) ; if ( Math . abs ( n - n1 ) < Math . abs ( n - n2 ) ) return n1 ; return n2 ; }
Hyp: 
function closestNumber ( n , m ) { let q = n / m ; let n1 = m * q ; let n2 = ( n * m ) > 0 ? ( m * ( q + 1 ) ) : ( m * ( q - 1 ) ) ; if ( Math . abs ( n - n1 ) < Math . abs ( n - n2 ) ) return n1 ; return n2 ; }

BLEU: 92.6
Edit Sim: 13


Src: 
int problemsLeft ( int K , int P , int N ) { if ( K <= P ) return 0 ; else return ( K - P ) * N ; }
Ref: 
function problemsLeft ( K , P , N ) { if ( K <= P ) return 0 ; else return ( K - P ) * N ; }
Hyp: 
function problemsLeft ( K , P , N ) { if ( K <= P ) return 0 ; else return ( K - P ) * N ; }

BLEU: 100.0
Edit Sim: 0


Src: 
void section ( double x1 , double x2 , double y1 , double y2 , double z1 , double z2 , double m , double n ) { double x = ( ( m * x2 ) + ( n * x1 ) ) / ( m + n ) ; double y = ( ( m * y2 ) + ( n * y1 ) ) / ( m + n ) ; double z = ( ( m * z2 ) + ( n * z1 ) ) / ( m + n ) ; cout << " ( " << x << " , ▁ " ; cout << y << " , ▁ " ; cout << z << " ) " << endl ; }
Ref: 
function section ( x1 , x2 , y1 , y2 , z1 , z2 , m , n ) { let x = ( ( m * x2 ) + ( n * x1 ) ) / ( m + n ) ; let y = ( ( m * y2 ) + ( n * y1 ) ) / ( m + n ) ; let z = ( ( m * z2 ) + ( n * z1 ) ) / ( m + n ) ; document . write ( " " + x + " " ) ; document . write ( y + " " ) ; document . write ( z + " " ) ; }
Hyp: 
function section ( x1 , x2 , y1 , y2 , z1 , z2 , m , n ) { var x = ( ( m * x2 ) + ( n * x1 ) ) / ( m + n ) ; var y = ( ( m * y2 ) + ( n * y1 ) ) / ( m + n ) ; var z = ( ( m * z2 ) + ( n * z1 ) ) / ( m + n ) ; document . write ( " " + x + " " ) ; document . write ( y + " " ) ; document . write ( z + " " ) ; }

BLEU: 93.81
Edit Sim: 9


Src: 
int findValue ( int X , int Y , int P ) { if ( P % 2 == 0 ) return ( max ( X , Y ) / min ( X , Y ) ) ; else return ( max ( 2 * X , Y ) / min ( 2 * X , Y ) ) ; }
Ref: 
function findValue ( X , Y , P ) { if ( P % 2 == 0 ) return parseInt ( ( Math . max ( X , Y ) / Math . min ( X , Y ) ) , 10 ) ; else return parseInt ( ( Math . max ( 2 * X , Y ) / Math . min ( 2 * X , Y ) ) , 10 ) ; }
Hyp: 
function findValue ( X , Y , P ) { if ( P % 2 == 0 ) return ( Math . max ( X , Y ) / Math . min ( X , Y ) ) ; else return ( Math . max ( 2 * X , Y ) / Math . min ( 2 * X , Y ) ) ; }

BLEU: 79.78
Edit Sim: 36


Src: 
float weightedMean ( int X [ ] , int W [ ] , int n ) { int sum = 0 , numWeight = 0 ; for ( int i = 0 ; i < n ; i ++ ) { numWeight = numWeight + X [ i ] * W [ i ] ; sum = sum + W [ i ] ; } return ( float ) numWeight / sum ; }
Ref: 
function weightedMean ( X , W , n ) { let sum = 0 , numWeight = 0 ; for ( let i = 0 ; i < n ; i ++ ) { numWeight = numWeight + X [ i ] * W [ i ] ; sum = sum + W [ i ] ; } return ( numWeight ) / sum ; }
Hyp: 
function weightedMean ( X , W , n ) { let sum = 0 , numWeight = 0 ; for ( let i = 0 ; i < n ; i ++ ) { numWeight = numWeight + X [ i ] * W [ i ] ; sum = sum + W [ i ] ; } return ( float ) numWeight / sum ; }

BLEU: 93.89
Edit Sim: 10


Src: 
int gcd ( int a , int b ) { if ( a == 0 ) return b ; if ( b == 0 ) return a ; if ( a == b ) return a ; if ( a > b ) return gcd ( a - b , b ) ; return gcd ( a , b - a ) ; }
Ref: 
function gcd ( a , b ) { if ( a == 0 ) return b ; if ( b == 0 ) return a ; if ( a == b ) return a ; if ( a > b ) return gcd ( a - b , b ) ; return gcd ( a , b - a ) ; }
Hyp: 
function gcd ( a , b ) { if ( a == 0 ) return b ; if ( b == 0 ) return a ; if ( a == b ) return a ; if ( a > b ) return gcd ( a - b , b ) ; return gcd ( a , b - a ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int nthTerm ( int n ) { return 4 * pow ( n , 2 ) - 7 * n + 3 ; }
Ref: 
function nthTerm ( n ) { return 4 * Math . pow ( n , 2 ) - 7 * n + 3 ; }
Hyp: 
function nthTerm ( n ) { return 4 * Math . pow ( n , 2 ) - 7 * n + 3 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
void last_digit ( int X , int Y ) { cout << X % Y ; }
Ref: 
function last_digit ( X , Y ) { document . write ( X % Y ) ; }
Hyp: 
function last_digit ( X , Y ) { document . write ( X % Y ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int ceilSearch ( int arr [ ] , int low , int high , int x ) { int i ; if ( x <= arr [ low ] ) return low ; for ( i = low ; i < high ; i ++ ) { if ( arr [ i ] == x ) return i ; if ( arr [ i ] < x && arr [ i + 1 ] >= x ) return i + 1 ; } return -1 ; }
Ref: 
function ceilSearch ( arr , low , high , x ) { let i ; if ( x <= arr [ low ] ) return low ; for ( i = low ; i < high ; i ++ ) { if ( arr [ i ] == x ) return i ; if ( arr [ i ] < x && arr [ i + 1 ] >= x ) return i + 1 ; } return - 1 ; }
Hyp: 
function ceilSearch ( arr , low , high , x ) { let i ; if ( x <= arr [ low ] ) return low ; for ( i = low ; i < high ; i ++ ) { if ( arr [ i ] == x ) return i ; if ( arr [ i ] < x && arr [ i + 1 ] >= x ) return i + 1 ; } return - 1 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int getPeriod ( int n ) { int rem = 1 ; for ( int i = 1 ; i <= n + 1 ; i ++ ) rem = ( 10 * rem ) % n ; int d = rem ; int count = 0 ; do { rem = ( 10 * rem ) % n ; count ++ ; } while ( rem != d ) ; return count ; }
Ref: 
function getPeriod ( n ) { let rem = 1 ; for ( let i = 1 ; i <= n + 1 ; i ++ ) rem = ( 10 * rem ) % n ; let d = rem ; let count = 0 ; do { rem = ( 10 * rem ) % n ; count ++ ; } while ( rem != d ) ; return count ; }
Hyp: 
function getPeriod ( n ) { let rem = 1 ; for ( let i = 1 ; i <= n + 1 ; i ++ ) rem = ( 10 * rem ) % n ; let d = rem ; let count = 0 ; do { rem = ( 10 * rem ) % n ; count ++ ; } while ( rem != d ) ; return count ; }

BLEU: 100.0
Edit Sim: 0


Src: 
float rhombusarea ( float l , float b ) { if ( l < 0 b < 0 ) return -1 ; return ( l * b ) / 2 ; }
Ref: 
function rhombusarea ( l , b ) { if ( l < 0 b < 0 ) return - 1 ; return ( l * b ) / 2 ; }
Hyp: 
function rhombusarea ( l , b ) { if ( l < 0 b < 0 ) return - 1 ; return ( l * b ) / 2 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
string search ( int arr [ ] , int n , int x ) { if ( arr [ n - 1 ] == x ) return " Found " ; int backup = arr [ n - 1 ] ; arr [ n - 1 ] = x ; for ( int i = 0 ; ; i ++ ) { if ( arr [ i ] == x ) { arr [ n - 1 ] = backup ; if ( i < n - 1 ) return " Found " ; return " Not ▁ Found " ; } } }
Ref: 
function search ( arr , n , x ) { if ( arr [ n - 1 ] == x ) return " " ; let backup = arr [ n - 1 ] ; arr [ n - 1 ] = x ; for ( let i = 0 ; ; i ++ ) { if ( arr [ i ] == x ) { arr [ n - 1 ] = backup ; if ( i < n - 1 ) return " " ; return " " ; } } }
Hyp: 
function search ( arr , n , x ) { if ( arr [ n - 1 ] == x ) return " " ; let backup = arr [ n - 1 ] ; arr [ n - 1 ] = x ; for ( let i = 0 ; ; i ++ ) { if ( arr [ i ] == x ) { arr [ n - 1 ] = backup ; if ( i < n - 1 ) return " " ; return " " ; } } }

BLEU: 100.0
Edit Sim: 0


Src: 
void printRepeating ( int arr [ ] , int size ) { int * count = new int [ sizeof ( int ) * ( size - 2 ) ] ; int i ; cout << " ▁ Repeating ▁ elements ▁ are ▁ " ; for ( i = 0 ; i < size ; i ++ ) { if ( count [ arr [ i ] ] == 1 ) cout << arr [ i ] << " ▁ " ; else count [ arr [ i ] ] ++ ; } }
Ref: 
function printRepeating ( arr , size ) { let count = new Array ( size ) ; count . fill ( 0 ) ; let i ; document . write ( " " ) ; for ( i = 0 ; i < size ; i ++ ) { if ( count [ arr [ i ] ] == 1 ) document . write ( arr [ i ] + " " ) ; else count [ arr [ i ] ] ++ ; } }
Hyp: 
function printRepeating ( arr , size ) { let count = new Array ( size ) ; for ( let i = 0 ; i < size ; i ++ ) { if ( count [ arr [ i ] ] == 1 ) document . write ( arr [ i ] + " " ) ; else count [ arr [ i ] ] ++ ; } }

BLEU: 75.53
Edit Sim: 54


Src: 
int find_Area ( int r ) { return ( 2 * r * r ) ; }
Ref: 
function find_Area ( r ) { return ( 2 * r * r ) ; }
Hyp: 
function find_Area ( r ) { return ( 2 * r * r ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int getNthTerm ( long long int N ) { return ( pow ( N , 2 ) + N + 1 ) ; }
Ref: 
function getNthTerm ( N ) { return ( Math . pow ( N , 2 ) + N + 1 ) ; }
Hyp: 
function getNthTerm ( N ) { return ( Math . pow ( N , 2 ) + N + 1 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int countPS ( string str ) { int N = str . length ( ) ; int cps [ N + 1 ] [ N + 1 ] ; memset ( cps , 0 , sizeof ( cps ) ) ; for ( int i = 0 ; i < N ; i ++ ) cps [ i ] [ i ] = 1 ; for ( int L = 2 ; L <= N ; L ++ ) { for ( int i = 0 ; i <= N - L ; i ++ ) { int k = L + i - 1 ; if ( str [ i ] == str [ k ] ) cps [ i ] [ k ] = cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] + 1 ; else cps [ i ] [ k ] = cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] - cps [ i + 1 ] [ k - 1 ] ; } } return cps [ 0 ] [ N - 1 ] ; }
Ref: 
function countPS ( str ) { let N = str . length ; let cps = new Array ( N ) ; for ( let i = 0 ; i < N ; i ++ ) { cps [ i ] = new Array ( N ) ; for ( let j = 0 ; j < N ; j ++ ) { cps [ i ] [ j ] = 0 ; } } for ( let i = 0 ; i < N ; i ++ ) cps [ i ] [ i ] = 1 ; for ( let L = 2 ; L <= N ; L ++ ) { for ( let i = 0 ; i <= N - L ; i ++ ) { let k = L + i - 1 ; if ( str [ i ] == str [ k ] ) { cps [ i ] [ k ] = cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] + 1 ; } else { cps [ i ] [ k ] = cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] - cps [ i + 1 ] [ k - 1 ] ; } } } return cps [ 0 ] [ N - 1 ] ; }
Hyp: 
function countPS ( str ) { let N = str . length ; let cps = new Array ( N + 1 ) ; for ( let i = 0 ; i < N ; i ++ ) cps [ i ] = new Array ( N + 1 ) ; for ( let L = 2 ; L <= N ; L ++ ) { for ( let i = 0 ; i <= N ; i ++ ) { let k = L + i - 1 ; if ( str [ i ] == str [ k ] ) cps [ i ] [ k ] = cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] + 1 ; else cps [ i ] [ k ] = cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k - 1 ] ; } } return cps [ 0 ] [ N - 1 ] ; }

BLEU: 65.34
Edit Sim: 153


Src: 
int magicOfSequence ( int N ) { return ( N * ( N + 1 ) / 2 ) + 2 * N ; }
Ref: 
function magicOfSequence ( N ) { return ( N * ( N + 1 ) / 2 ) + 2 * N ; }
Hyp: 
function magicOfSequence ( N ) { return ( N * ( N + 1 ) / 2 ) + 2 * N ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int mod ( string num , int a ) { int res = 0 ; for ( int i = 0 ; i < num . length ( ) ; i ++ ) res = ( res * 10 + ( int ) num [ i ] - '0' ) % a ; return res ; }
Ref: 
function mod ( num , a ) { let res = 0 ; for ( let i = 0 ; i < num . length ; i ++ ) res = ( res * 10 + num [ i ] - ' ' ) % a ; return res ; }
Hyp: 
function mod ( num , a ) { let res = 0 ; for ( let i = 0 ; i < num . length ; i ++ ) res = ( res * 10 + ( num [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ) % a ; return res ; }

BLEU: 76.96
Edit Sim: 36


Src: 
void ReplaceElements ( int arr [ ] , int n ) { if ( n <= 1 ) return ; int prev = arr [ 0 ] ; arr [ 0 ] = arr [ 0 ] ^ arr [ 1 ] ; for ( int i = 1 ; i < n - 1 ; i ++ ) { int curr = arr [ i ] ; arr [ i ] = prev ^ arr [ i + 1 ] ; prev = curr ; } arr [ n - 1 ] = prev ^ arr [ n - 1 ] ; }
Ref: 
function ReplaceElements ( arr , n ) { if ( n <= 1 ) return ; let prev = arr [ 0 ] ; arr [ 0 ] = arr [ 0 ] ^ arr [ 1 ] ; for ( let i = 1 ; i < n - 1 ; i ++ ) { let curr = arr [ i ] ; arr [ i ] = prev ^ arr [ i + 1 ] ; prev = curr ; } arr [ n - 1 ] = prev ^ arr [ n - 1 ] ; }
Hyp: 
function ReplaceElements ( arr , n ) { if ( n <= 1 ) return ; let prev = arr [ 0 ] ; arr [ 0 ] = arr [ 0 ] ^ arr [ 1 ] ; for ( let i = 1 ; i < n - 1 ; i ++ ) { let curr = arr [ i ] ; arr [ i ] = prev ^ arr [ i + 1 ] ; prev = curr ; } arr [ n - 1 ] = prev ^ arr [ n - 1 ] ; }

BLEU: 100.0
Edit Sim: 0


Src: 
void prevGreater ( int arr [ ] , int n ) { cout << " - 1 , ▁ " ; for ( int i = 1 ; i < n ; i ++ ) { int j ; for ( j = i - 1 ; j >= 0 ; j -- ) { if ( arr [ i ] < arr [ j ] ) { cout << arr [ j ] << " , ▁ " ; break ; } } if ( j == -1 ) cout << " - 1 , ▁ " ; } }
Ref: 
function prevGreater ( arr , n ) { document . write ( " " ) ; for ( let i = 1 ; i < n ; i ++ ) { let j ; for ( j = i - 1 ; j >= 0 ; j -- ) { if ( arr [ i ] < arr [ j ] ) { document . write ( arr [ j ] + " " ) ; break ; } } if ( j == - 1 ) document . write ( " " ) ; } }
Hyp: 
function prevGreater ( arr , n ) { document . write ( " " ) ; for ( let i = 1 ; i < n ; i ++ ) { let j ; for ( j = i - 1 ; j >= 0 ; j -- ) { if ( arr [ i ] < arr [ j ] ) { document . write ( arr [ j ] + " " ) ; break ; } } if ( j == - 1 ) document . write ( " " ) ; } }

BLEU: 100.0
Edit Sim: 0


Src: 
bool isPowerOfTwo ( int x ) { return x && ( ! ( x & ( x - 1 ) ) ) ; }
Ref: 
function isPowerOfTwo ( x ) { return x != 0 && ( ( x & ( x - 1 ) ) == 0 ) ; }
Hyp: 
function isPowerOfTwo ( x ) { return x && ( ! ( x & ( x - 1 ) ) ) ; }

BLEU: 65.41
Edit Sim: 12


Src: 
int rotateRec ( int n , int L [ ] , int B [ ] ) { int m = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { if ( max ( L [ i ] , B [ i ] ) <= m ) m = max ( L [ i ] , B [ i ] ) ; else if ( min ( L [ i ] , B [ i ] ) <= m ) m = min ( L [ i ] , B [ i ] ) ; else { return 0 ; } } return 1 ; }
Ref: 
function rotateRec ( n , L , B ) { var m = Number . MAX_VALUE for ( var i = 0 ; i < n ; i ++ ) { if ( Math . max ( L [ i ] , B [ i ] ) <= m ) m = Math . max ( L [ i ] , B [ i ] ) ; else if ( Math . min ( L [ i ] , B [ i ] ) <= m ) m = Math . min ( L [ i ] , B [ i ] ) ; else { return 0 ; } } return 1 ; }
Hyp: 
function rotateRec ( n , L , B ) { let m = Number . MAX_VALUE ; for ( let i = 0 ; i < n ; i ++ ) { if ( Math . max ( L [ i ] , B [ i ] ) <= m ) m = Math . max ( L [ i ] , B [ i ] ) ; else if ( Math . min ( L [ i ] , B [ i ] ) <= m ) m = Math . min ( L [ i ] , B [ i ] ) ; else { return 0 ; } } return 1 ; }

BLEU: 93.66
Edit Sim: 8


Src: 
void print_result ( int a [ ] , int n , int k , int m ) { vector < int > v [ m ] ; for ( int i = 0 ; i < n ; i ++ ) { int rem = a [ i ] % m ; v [ rem ] . push_back ( a [ i ] ) ; if ( v [ rem ] . size ( ) == k ) { for ( int j = 0 ; j < k ; j ++ ) cout << v [ rem ] [ j ] << " ▁ " ; return ; } } cout << " - 1" ; }
Ref: 
function print_result ( a , n , k , m ) { var v = Array . from ( Array ( m ) , ( ) => Array ( ) ) ; for ( var i = 0 ; i < n ; i ++ ) { var rem = a [ i ] % m ; v [ rem ] . push ( a [ i ] ) ; if ( v [ rem ] . length == k ) { for ( var j = 0 ; j < k ; j ++ ) document . write ( v [ rem ] [ j ] + " " ) ; return ; } } document . write ( " " ) ; }
Hyp: 
function print_result ( a , n , k , m ) { let v = new Array ( m ) ; for ( let i = 0 ; i < m ; i ++ ) { let rem = a [ i ] % m ; v [ rem ] . push ( ( a [ i ] ) % m ) ; if ( v [ rem ] . size ( ) == k ) { for ( let j = 0 ; j < k ; j ++ ) document . write ( v [ rem ] [ j ] + " " ) ; return ; } } document . write ( " " ) ; }

BLEU: 75.8
Edit Sim: 63


Src: 
int sumofproduct ( int n ) { int ans = 0 ; for ( int x = 1 ; x <= n ; x ++ ) { int y = n / x ; ans += ( y * x ) ; } return ans ; }
Ref: 
function sumofproduct ( n ) { var ans = 0 ; for ( x = 1 ; x <= n ; x ++ ) { var y = parseInt ( n / x ) ; ans += ( y * x ) ; } return ans ; }
Hyp: 
function sumofproduct ( n ) { let ans = 0 ; for ( let x = 1 ; x <= n ; x ++ ) { let y = n / x ; ans += ( y * x ) ; } return ans ; }

BLEU: 72.98
Edit Sim: 23


Src: 
void printDivisors ( int n ) { for ( int i = 1 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) cout << " ▁ " << i ; cout << " ▁ " << i << " ▁ " << n / i ; } } }
Ref: 
function printDivisors ( n ) { for ( let i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( parseInt ( n / i , 10 ) == i ) document . write ( i ) ; else document . write ( i + " " + parseInt ( n / i , 10 ) + " " ) ; } } }
Hyp: 
function printDivisors ( n ) { for ( let i = 1 ; i <= parseInt ( Math . sqrt ( n ) ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) document . write ( " " + i ) ; document . write ( " " + n / i ) ; } } }

BLEU: 65.29
Edit Sim: 67


Src: 
int findSubsequenceCount ( string S , string T ) { int m = T . length ( ) , n = S . length ( ) ; if ( m > n ) return 0 ; int mat [ m + 1 ] [ n + 1 ] ; for ( int i = 1 ; i <= m ; i ++ ) mat [ i ] [ 0 ] = 0 ; for ( int j = 0 ; j <= n ; j ++ ) mat [ 0 ] [ j ] = 1 ; for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( T [ i - 1 ] != S [ j - 1 ] ) mat [ i ] [ j ] = mat [ i ] [ j - 1 ] ; else mat [ i ] [ j ] = mat [ i ] [ j - 1 ] + mat [ i - 1 ] [ j - 1 ] ; } } return mat [ m ] [ n ] ; }
Ref: 
function findSubsequenceCount ( S , T ) { let m = T . length ; let n = S . length ; if ( m > n ) return 0 ; let mat = new Array ( m + 1 ) ; for ( let i = 0 ; i <= m ; i ++ ) { mat [ i ] = new Array ( n + 1 ) ; for ( let j = 0 ; j <= n ; j ++ ) { mat [ i ] [ j ] = 0 ; } } for ( let i = 1 ; i <= m ; i ++ ) mat [ i ] [ 0 ] = 0 ; for ( let j = 0 ; j <= n ; j ++ ) mat [ 0 ] [ j ] = 1 ; for ( let i = 1 ; i <= m ; i ++ ) { for ( let j = 1 ; j <= n ; j ++ ) { if ( T [ i - 1 ] != S [ j - 1 ] ) mat [ i ] [ j ] = mat [ i ] [ j - 1 ] ; else mat [ i ] [ j ] = mat [ i ] [ j - 1 ] + mat [ i - 1 ] [ j - 1 ] ; } } return mat [ m ] [ n ] ; }
Hyp: 
function findSubsequenceCount ( S , T ) { let m = T . length , n = S . length ; if ( m > n ) return 0 ; let mat = new Array ( m + 1 ) ; for ( let i = 1 ; i <= m ; i ++ ) mat [ i ] [ 0 ] = 0 ; for ( let j = 0 ; j <= n ; j ++ ) mat [ 0 ] [ j ] = 1 ; for ( let i = 1 ; i <= m ; i ++ ) { for ( let j = 1 ; j <= n ; j ++ ) { if ( T [ i - 1 ] != S [ j - 1 ] ) mat [ i ] [ j ] = mat [ i ] [ j - 1 ] ; else mat [ i ] [ j ] = mat [ i ] [ j - 1 ] + mat [ i - 1 ] [ j - 1 ] ; } } return mat [ m ] [ n ] ; }

BLEU: 74.18
Edit Sim: 137


Src: 
int counLastDigitK ( int low , int high , int k ) { int count = 0 ; for ( int i = low ; i <= high ; i ++ ) if ( i % 10 == k ) count ++ ; return count ; }
Ref: 
function counLastDigitK ( low , high , k ) { let count = 0 ; for ( let i = low ; i <= high ; i ++ ) if ( i % 10 == k ) count ++ ; return count ; }
Hyp: 
function counLastDigitK ( low , high , k ) { let count = 0 ; for ( let i = low ; i <= high ; i ++ ) if ( i % 10 == k ) count ++ ; return count ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int subtract ( int x , int y ) { while ( y != 0 ) { int borrow = ( ~ x ) & y ; x = x ^ y ; y = borrow << 1 ; } return x ; }
Ref: 
function subtract ( x , y ) { while ( y != 0 ) { let borrow = ( ~ x ) & y ; x = x ^ y ; y = borrow << 1 ; } return x ; }
Hyp: 
function subtract ( x , y ) { while ( y != 0 ) { let borrow = ( ~ x ) & y ; x = x ^ y ; y = borrow << 1 ; } return x ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int findOddPair ( int A [ ] , int N ) { int i , j ; int oddPair = 0 ; for ( i = 0 ; i < N ; i ++ ) { for ( j = i + 1 ; j < N ; j ++ ) { if ( ( A [ i ] & A [ j ] ) % 2 != 0 ) oddPair ++ ; } } return oddPair ; }
Ref: 
function findOddPair ( A , N ) { var i , j ; var oddPair = 0 ; for ( i = 0 ; i < N ; i ++ ) { for ( j = i + 1 ; j < N ; j ++ ) { if ( ( A [ i ] & A [ j ] ) % 2 != 0 ) oddPair ++ ; } } return oddPair ; }
Hyp: 
function findOddPair ( A , N ) { let i , j ; let oddPair = 0 ; for ( i = 0 ; i < N ; i ++ ) { for ( j = i + 1 ; j < N ; j ++ ) { if ( ( A [ i ] & A [ j ] ) % 2 != 0 ) oddPair ++ ; } } return oddPair ; }

BLEU: 93.19
Edit Sim: 6


Src: 
void printSubsequences ( int arr [ ] , int n ) { unsigned int opsize = pow ( 2 , n ) ; for ( int counter = 1 ; counter < opsize ; counter ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( counter & ( 1 << j ) ) cout << arr [ j ] << " ▁ " ; } cout << endl ; } }
Ref: 
function printSubsequences ( arr , n ) { let opsize = parseInt ( Math . pow ( 2 , n ) , 10 ) ; for ( let counter = 1 ; counter < opsize ; counter ++ ) { for ( let j = 0 ; j < n ; j ++ ) { if ( ( counter & ( 1 << j ) ) != 0 ) document . write ( arr [ j ] + " " ) ; } document . write ( " " ) ; } }
Hyp: 
function printSubsequences ( arr , n ) { let opsize = Math . pow ( 2 , n ) ; for ( let counter = 1 ; counter < opsize ; counter ++ ) { for ( let j = 0 ; j < n ; j ++ ) { if ( counter & ( 1 << j ) ) document . write ( arr [ j ] + " " ) ; } document . write ( " " ) ; } }

BLEU: 85.66
Edit Sim: 27


Src: 
int getMinSquares ( unsigned int n ) { if ( sqrt ( n ) - floor ( sqrt ( n ) ) == 0 ) return 1 ; if ( n <= 3 ) return n ; int res = n ; for ( int x = 1 ; x <= n ; x ++ ) { int temp = x * x ; if ( temp > n ) break ; else res = min ( res , 1 + getMinSquares ( n - temp ) ) ; } return res ; }
Ref: 
function getMinSquares ( n ) { if ( n <= 3 ) return n ; let res = n ; for ( let x = 1 ; x <= n ; x ++ ) { let temp = x * x ; if ( temp > n ) break ; else res = Math . min ( res , 1 + getMinSquares ( n - temp ) ) ; } return res ; }
Hyp: 
function getMinSquares ( n ) { if ( ( Math . sqrt ( n ) - Math . floor ( Math . sqrt ( n ) ) == 0 ) return 1 ; if ( n <= 3 ) return n ; let res = n ; for ( let x = 1 ; x <= n ; x ++ ) { let temp = x * x ; if ( temp > n ) break ; else res = Math . min ( res , 1 + getMinSquares ( n - temp ) ) ; } return res ; }

BLEU: 72.88
Edit Sim: 80


Src: 
int firstDigit ( int n ) { long long int fact = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { fact = fact * i ; while ( fact % 10 == 0 ) fact = fact / 10 ; } while ( fact >= 10 ) fact = fact / 10 ; return fact ; }
Ref: 
function firstDigit ( n ) { let fact = 1 ; for ( let i = 2 ; i <= n ; i ++ ) { fact = fact * i ; while ( fact % 10 == 0 ) fact = fact / 10 ; } while ( fact >= 10 ) fact = fact / 10 ; return ( Math . round ( fact ) ) ; }
Hyp: 
function firstDigit ( n ) { let fact = 1 ; for ( let i = 2 ; i <= n ; i ++ ) { fact = fact * i ; while ( fact % 10 == 0 ) fact = fact / 10 ; } while ( fact >= 10 ) fact = fact / 10 ; return fact ; }

BLEU: 86.57
Edit Sim: 21


Src: 
int findSum ( int n ) { n -- ; int sum = 0 ; sum += ( n * ( n + 1 ) ) / 2 ; sum += ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; return sum ; }
Ref: 
function findSum ( n ) { n -- ; let sum = 0 ; sum += ( n * ( n + 1 ) ) / 2 ; sum += ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; return sum ; }
Hyp: 
function findSum ( n ) { n -- ; let sum = 0 ; sum += ( n * ( n + 1 ) ) / 2 ; sum += ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; return sum ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int getCount ( int a , int b , int c ) { int count = 0 ; for ( int i = 1 ; i <= 81 ; i ++ ) { int cr = b * pow ( i , a ) + c ; int tmp = cr ; int sm = 0 ; while ( tmp ) { sm += tmp % 10 ; tmp /= 10 ; } if ( sm == i && cr < 1e9 ) count ++ ; } return count ; }
Ref: 
function getCount ( a , b , c ) { let count = 0 ; for ( let i = 1 ; i <= 81 ; i ++ ) { let cr = b * Math . pow ( i , a ) + c ; let tmp = cr ; let sm = 0 ; while ( tmp != 0 ) { sm += tmp % 10 ; tmp = Math . floor ( tmp / 10 ) ; } if ( sm == i && cr < 1e9 ) count ++ ; } return count ; }
Hyp: 
function getCount ( a , b , c ) { let count = 0 ; for ( let i = 1 ; i <= 81 ; i ++ ) { let cr = b * Math . pow ( i , a ) + c ; let tmp = cr ; let sm = 0 ; while ( tmp ) { sm += tmp % 10 ; tmp = Math . floor ( tmp / 10 ) ; } if ( sm == i && cr < 1e9 ) count ++ ; } return count ; }

BLEU: 96.42
Edit Sim: 5


Src: 
int subtract ( int x , int y ) { if ( y == 0 ) return x ; return subtract ( x ^ y , ( ~ x & y ) << 1 ) ; }
Ref: 
function subtract ( x , y ) { if ( y == 0 ) return x ; return subtract ( x ^ y , ( ~ x & y ) << 1 ) ; }
Hyp: 
function subtract ( x , y ) { if ( y == 0 ) return x ; return subtract ( x ^ y , ( ~ x & y ) << 1 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int countNumbers ( int N ) { return int ( sqrt ( N ) ) - 1 ; }
Ref: 
function countNumbers ( N ) { return parseInt ( Math . sqrt ( N ) , 10 ) - 1 ; }
Hyp: 
function countNumbers ( N ) { return parseInt ( Math . sqrt ( N ) ) - 1 ; }

BLEU: 83.01
Edit Sim: 5


Src: 
void ASCIISentence ( std :: string str ) { int l = str . length ( ) ; int convert ; for ( int i = 0 ; i < l ; i ++ ) { convert = str [ i ] - NULL ; cout << convert ; } }
Ref: 
function ASCIISentence ( str ) { let l = str . length ; let convert ; for ( let i = 0 ; i < l ; i ++ ) { convert = str [ i ] . charCodeAt ( 0 ) ; document . write ( convert ) ; } }
Hyp: 
function ASCIISentence ( str ) { let l = str . length ; let convert ; for ( let i = 0 ; i < l ; i ++ ) { convert = str [ i ] . charCodeAt ( 0 ) - 65 ; document . write ( convert . charCodeAt ( 0 ) ) ; } }

BLEU: 82.72
Edit Sim: 24


Src: 
void countToMake0lternate ( const string & s ) { int result = 0 ; for ( int i = 0 ; i < ( s . length ( ) - 1 ) ; i ++ ) if ( s [ i ] == s [ i + 1 ] ) return result ; }
Ref: 
function countToMake0lternate ( s ) { let result = 0 ; for ( let i = 0 ; i < ( s . length - 1 ) ; i ++ ) if ( s [ i ] == s [ i + 1 ] ) return result ; }
Hyp: 
function countToMake0lternate ( s ) { let result = 0 ; for ( let i = 0 ; i < s . length - 1 ; i ++ ) if ( s [ i ] == s [ i + 1 ] ) return result ; }

BLEU: 89.41
Edit Sim: 4


Src: 
void minAdjDifference ( int arr [ ] , int n ) { if ( n < 2 ) return ; int res = abs ( arr [ 1 ] - arr [ 0 ] ) ; for ( int i = 2 ; i < n ; i ++ ) res = min ( res , abs ( arr [ i ] - arr [ i - 1 ] ) ) ; res = min ( res , abs ( arr [ n - 1 ] - arr [ 0 ] ) ) ; cout << " Min ▁ Difference ▁ = ▁ " << res ; }
Ref: 
function minAdjDifference ( arr , n ) { if ( n < 2 ) return ; let res = Math . abs ( arr [ 1 ] - arr [ 0 ] ) ; for ( let i = 2 ; i < n ; i ++ ) res = Math . min ( res , Math . abs ( arr [ i ] - arr [ i - 1 ] ) ) ; res = Math . min ( res , Math . abs ( arr [ n - 1 ] - arr [ 0 ] ) ) ; document . write ( " " + res ) ; }
Hyp: 
function minAdjDifference ( arr , n ) { if ( n < 2 ) return ; let res = Math . abs ( arr [ 1 ] - arr [ 0 ] ) ; for ( let i = 2 ; i < n ; i ++ ) res = Math . min ( res , Math . abs ( arr [ i ] - arr [ i - 1 ] ) ) ; res = Math . min ( res , Math . abs ( arr [ n - 1 ] - arr [ 0 ] ) ) ; document . write ( " " + res ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
void printSubsequences ( string str ) { int n = str . length ( ) ; unsigned int opsize = pow ( 2 , n - 1 ) ; for ( int counter = 0 ; counter < opsize ; counter ++ ) { for ( int j = 0 ; j < n ; j ++ ) { cout << str [ j ] ; if ( counter & ( 1 << j ) ) cout << " ▁ " ; } cout << endl ; } }
Ref: 
function printSubsequences ( s ) { let str = s . split ( ' ' ) ; let n = str . length ; let opsize = Math . pow ( 2 , n - 1 ) ; for ( let counter = 0 ; counter < opsize ; counter ++ ) { for ( let j = 0 ; j < n ; j ++ ) { document . write ( str [ j ] ) ; if ( ( counter & ( 1 << j ) ) > 0 ) document . write ( " " ) ; } document . write ( " " ) ; } }
Hyp: 
function printSubsequences ( str ) { let n = str . length ; let opsize = Math . pow ( 2 , n - 1 ) ; for ( let counter = 0 ; counter < opsize ; counter ++ ) { for ( let j = 0 ; j < n ; j ++ ) { document . write ( str [ j ] ) ; if ( counter & ( 1 << j ) ) document . write ( " " ) ; } document . write ( " " ) ; } }

BLEU: 81.39
Edit Sim: 37


Src: 
double Convert ( double radian ) { double pi = 3.14159 ; return ( radian * ( 180 / pi ) ) ; }
Ref: 
function Convert ( radian ) { let pi = 3.14159 ; return ( radian * ( 180 / pi ) ) ; }
Hyp: 
function Convert ( radian ) { var pi = 3.14159 ; return ( radian * ( 180 / pi ) ) ; }

BLEU: 88.44
Edit Sim: 3


Src: 
int number_of_digits ( int n ) { int i , res , sum = 0 ; for ( i = 4 , res = 1 ; ; i *= 4 , res ++ ) { sum += i ; if ( sum >= n ) break ; } return res ; }
Ref: 
function number_of_digits ( n ) { let i , res , sum = 0 ; for ( i = 4 , res = 1 ; ; i *= 4 , res ++ ) { sum += i ; if ( sum >= n ) break ; } return res ; }
Hyp: 
function number_of_digits ( n ) { let i , res , sum = 0 ; for ( i = 4 , res = 1 ; ; i *= 4 , res ++ ) { sum += i ; if ( sum >= n ) break ; } return res ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int findK ( int n , int k ) { vector < long > a ; for ( int i = 1 ; i < n ; i ++ ) if ( i % 2 == 1 ) a . push_back ( i ) ; for ( int i = 1 ; i < n ; i ++ ) if ( i % 2 == 0 ) a . push_back ( i ) ; return ( a [ k - 1 ] ) ; }
Ref: 
function findK ( n , k ) { let a = [ ] ; for ( let i = 1 ; i < n ; i ++ ) if ( i % 2 == 1 ) a . push ( i ) ; for ( let i = 1 ; i < n ; i ++ ) if ( i % 2 == 0 ) a . push ( i ) ; return ( a [ k - 1 ] ) ; }
Hyp: 
function findK ( n , k ) { let a = [ ] ; for ( let i = 1 ; i < n ; i ++ ) if ( i % 2 == 1 ) a . push ( i ) ; for ( let i = 1 ; i < n ; i ++ ) if ( i % 2 == 0 ) a . push ( i ) ; return ( a [ k - 1 ] ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int findWays ( int m , int n , int x ) { int table [ n + 1 ] [ x + 1 ] ; for ( int j = 1 ; j <= m && j <= x ; j ++ ) table [ 1 ] [ j ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) for ( int j = 1 ; j <= x ; j ++ ) for ( int k = 1 ; k <= m && k < j ; k ++ ) table [ i ] [ j ] += table [ i - 1 ] [ j - k ] ; return table [ n ] [ x ] ; }
Ref: 
function findWays ( m , n , x ) { let table = new Array ( n + 1 ) ; for ( let i = 0 ; i < ( n + 1 ) ; i ++ ) { table [ i ] = new Array ( x + 1 ) ; for ( let j = 0 ; j < ( x + 1 ) ; j ++ ) { table [ i ] [ j ] = 0 ; } } for ( let j = 1 ; j <= m && j <= x ; j ++ ) table [ 1 ] [ j ] = 1 ; for ( let i = 2 ; i <= n ; i ++ ) { for ( let j = 1 ; j <= x ; j ++ ) { for ( let k = 1 ; k < j && k <= m ; k ++ ) table [ i ] [ j ] += table [ i - 1 ] [ j - k ] ; } } return table [ n ] [ x ] ; }
Hyp: 
function findWays ( m , n , x ) { var table = Array ( n + 1 ) . fill ( 0 ) ; for ( var j = 1 ; j <= m && j <= x ; j ++ ) table [ 1 ] [ j ] = 1 ; for ( var i = 2 ; i <= n ; i ++ ) for ( var j = 1 ; j <= x ; j ++ ) for ( var k = 1 ; k <= m && k < j ; k ++ ) table [ i ] [ j ] += table [ i - 1 ] [ j - k ] ; return table [ n ] [ x ] ; }

BLEU: 47.91
Edit Sim: 169


Src: 
bool oppositeSigns ( int x , int y ) { return ( ( x ^ y ) < 0 ) ; }
Ref: 
function oppositeSigns ( x , y ) { return ( ( x ^ y ) < 0 ) ; }
Hyp: 
function oppositeSigns ( x , y ) { return ( ( x ^ y ) < 0 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
bool pointIsOnLine ( int m , int c , int x , int y ) { if ( y == ( ( m * x ) + c ) ) return true ; return false ; }
Ref: 
function pointIsOnLine ( m , c , x , y ) { if ( y == ( ( m * x ) + c ) ) return true ; return false ; }
Hyp: 
function pointIsOnLine ( m , c , x , y ) { if ( y == ( ( m * x ) + c ) ) return true ; return false ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int findMinDiff ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int diff = INT_MAX ; for ( int i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i + 1 ] - arr [ i ] < diff ) diff = arr [ i + 1 ] - arr [ i ] ; return diff ; }
Ref: 
function findMinDiff ( arr , n ) { arr . sort ( function ( a , b ) { return a - b } ) ; let diff = Number . MAX_VALUE ; for ( let i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i + 1 ] - arr [ i ] < diff ) diff = arr [ i + 1 ] - arr [ i ] ; return diff ; }
Hyp: 
function findMinDiff ( arr , n ) { arr . sort ( ( a , b ) => a - b ) ; let diff = Number . MAX_VALUE ; for ( let i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i + 1 ] - arr [ i ] < diff ) diff = arr [ i + 1 ] - arr [ i ] ; return diff ; }

BLEU: 89.5
Edit Sim: 19


Src: 
void swapTwoHalves ( string a , string b ) { int la = a . length ( ) ; int lb = b . length ( ) ; string c = a . substr ( 0 , la / 2 ) + b . substr ( lb / 2 , lb ) ; string d = b . substr ( 0 , lb / 2 ) + a . substr ( la / 2 , la ) ; cout << c << endl << d << endl ; }
Ref: 
function swapTwoHalves ( a , b ) { var la = a . length ; var lb = b . length ; var c = a . substring ( 0 , la / 2 ) + b . substring ( lb / 2 , lb ) ; var d = b . substring ( 0 , lb / 2 ) + a . substring ( la / 2 , la ) ; document . write ( c + " " + " " + d ) ; }
Hyp: 
function swapTwoHalves ( a , b ) { let la = a . length ; let lb = b . length ; let c = a . substr ( 0 , la / 2 ) + b . substr ( lb / 2 , lb ) ; let d = b . substr ( 0 , lb / 2 ) + a . substr ( la / 2 , la ) ; document . write ( c + " " + d + " " ) ; }

BLEU: 72.35
Edit Sim: 28


Src: 
int findNumber ( int n ) { n -- ; int i = 1 ; while ( n >= 0 ) { n -= i ; ++ i ; } return ( n + i ) ; }
Ref: 
function findNumber ( n ) { n -- ; let i = 1 ; while ( n >= 0 ) { n -= i ; ++ i ; } return ( n + i ) ; }
Hyp: 
function findNumber ( n ) { n -- ; let i = 1 ; while ( n >= 0 ) { n -= i ; ++ i ; } return ( n + i ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int minimumIncrease ( int a , int b , int c ) { int arr [ ] = { a , b , c } ; sort ( arr , arr + 3 ) ; if ( arr [ 0 ] + arr [ 1 ] >= arr [ 2 ] ) return 0 ; else return arr [ 2 ] - ( arr [ 0 ] + arr [ 1 ] ) ; }
Ref: 
function minimumIncrease ( a , b , c ) { var arr = [ a , b , c ] ; arr . sort ( ( a , b ) => a - b ) ; if ( arr [ 0 ] + arr [ 1 ] >= arr [ 2 ] ) return 0 ; else return arr [ 2 ] - ( arr [ 0 ] + arr [ 1 ] ) ; }
Hyp: 
function minimumIncrease ( a , b , c ) { let arr = { a , b , c } ; arr . sort ( ( a , b , c ) => a - b ) ; if ( arr . length >= 3 ) return 0 ; else return arr [ 2 ] - ( arr [ 0 ] + arr [ 1 ] ) ; }

BLEU: 68.69
Edit Sim: 34


Src: 
string divisibleBy36 ( string num ) { int l = num . length ( ) ; if ( l == 0 ) return " No " ; if ( l == 1 && num [ 0 ] != '0' ) return " No " ; int two_digit_num = ( num [ l - 2 ] - '0' ) * 10 + ( num [ l - 1 ] - '0' ) ; if ( two_digit_num % 4 != 0 ) return " No " ; int sum = 0 ; for ( int i = 0 ; i < l ; i ++ ) sum += ( num [ i ] - '0' ) ; if ( sum % 9 != 0 ) return " No " ; return " Yes " ; }
Ref: 
function divisibleBy36 ( num ) { let l = num . length ; if ( l == 0 ) return " " ; if ( l == 1 && num [ 0 ] != ' ' ) return " " ; let two_digit_num = ( num [ l - 2 ] - ' ' ) * 10 + ( num [ l - 1 ] - ' ' ) ; if ( two_digit_num % 4 != 0 ) return " " ; let sum = 0 ; for ( let i = 0 ; i < l ; i ++ ) sum += ( num [ i ] - ' ' ) ; if ( sum % 9 != 0 ) return " " ; return " " ; }
Hyp: 
function divisibleBy36 ( num ) { let l = num . length ; if ( l == 0 ) return " " ; if ( l == 1 && num [ 0 ] != ' ' ) return " " ; let two_digit_num = ( num [ l - 2 ] - ' ' ) * 10 + ( num [ l - 1 ] - ' ' ) ; if ( two_digit_num % 4 != 0 ) return " " ; let sum = 0 ; for ( let i = 0 ; i < l ; i ++ ) sum += ( num [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ; if ( sum % 9 != 0 ) return " " ; return " " ; }

BLEU: 91.31
Edit Sim: 36


Src: 
int min_elimination ( int n , int arr [ ] ) { int count = 0 ; int prev_val = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { int curr_val = arr [ i ] ; if ( curr_val % 2 == prev_val % 2 ) count ++ ; prev_val = curr_val ; } return count ; }
Ref: 
function min_elimination ( n , arr ) { let count = 0 ; let prev_val = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { let curr_val = arr [ i ] ; if ( curr_val % 2 == prev_val % 2 ) count ++ ; prev_val = curr_val ; } return count ; }
Hyp: 
function min_elimination ( n , arr ) { let count = 0 ; let prev_val = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { let curr_val = arr [ i ] ; if ( curr_val % 2 == prev_val % 2 ) count ++ ; prev_val = curr_val ; } return count ; }

BLEU: 100.0
Edit Sim: 0


Src: 
void lastDigit ( string a , string b ) { int lastDig = ( a [ a . length ( ) - 1 ] - '0' ) * ( b [ b . length ( ) - 1 ] - '0' ) ; cout << lastDig % 10 ; }
Ref: 
function lastDigit ( a , b ) { var lastDig = ( a [ a . length - 1 ] - ' ' ) * ( b [ b . length - 1 ] - ' ' ) ; document . write ( lastDig % 10 ) ; }
Hyp: 
function lastDigit ( a , b ) { let lastDig = ( a [ a . length - 1 ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ) * ( b [ b . length - 1 ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ) ; document . write ( lastDig / 10 ) ; }

BLEU: 56.85
Edit Sim: 72


Src: 
float sumOfSeries ( int n ) { return ( 0.666 ) * ( 1 - 1 / pow ( 10 , n ) ) ; }
Ref: 
function sumOfSeries ( n ) { return ( 0.666 ) * ( 1 - 1 / Math . pow ( 10 , n ) ) ; }
Hyp: 
function sumOfSeries ( n ) { return ( 0.666 ) * ( 1 - 1 / Math . pow ( 10 , parseInt ( n ) ) ) ; }

BLEU: 83.49
Edit Sim: 13


Src: 
float Area ( float l , float b , float h ) { if ( l < 0 b < 0 h < 0 ) return -1 ; float x = ( l * b ) / ( l + b ) ; float A = 0.70477 * pow ( x , 2 ) ; return A ; }
Ref: 
function Area ( l , b , h ) { if ( l < 0 b < 0 h < 0 ) return - 1 ; let x = ( l * b ) / ( l + b ) ; let A = 0.70477 * Math . pow ( x , 2 ) ; return A ; }
Hyp: 
function Area ( l , b , h ) { if ( l < 0 b < 0 h < 0 ) return - 1 ; var x = ( l * b ) / ( l + b ) ; var A = 0.70477 * ( Math . pow ( x , 2 ) ) ; return A ; }

BLEU: 84.27
Edit Sim: 10


Src: 
int countPairs ( int arr1 [ ] , int arr2 [ ] , int m , int n , int x ) { int count = 0 ; int l = 0 , r = n - 1 ; while ( l < m && r >= 0 ) { if ( ( arr1 [ l ] + arr2 [ r ] ) == x ) { l ++ ; r -- ; count ++ ; } else if ( ( arr1 [ l ] + arr2 [ r ] ) < x ) l ++ ; else r -- ; } return count ; }
Ref: 
function countPairs ( arr1 , arr2 , m , n , x ) { let count = 0 ; let l = 0 , r = n - 1 ; while ( l < m && r >= 0 ) { if ( ( arr1 [ l ] + arr2 [ r ] ) == x ) { l ++ ; r -- ; count ++ ; } else if ( ( arr1 [ l ] + arr2 [ r ] ) < x ) l ++ ; else r -- ; } return count ; }
Hyp: 
function countPairs ( arr1 , arr2 , m , n , x ) { var count = 0 ; var l = 0 , r = n - 1 ; while ( l < m && r >= 0 ) { if ( ( arr1 [ l ] + arr2 [ r ] ) == x ) { l ++ ; r -- ; count ++ ; } else if ( ( arr1 [ l ] + arr2 [ r ] ) < x ) l ++ ; else r -- ; } return count ; }

BLEU: 94.76
Edit Sim: 6


Src: 
int maximum_toys ( int cost [ ] , int N , int K ) { int count = 0 , sum = 0 ; sort ( cost , cost + N ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( sum + cost [ i ] <= K ) { sum = sum + cost [ i ] ; count ++ ; } } return count ; }
Ref: 
function maximum_toys ( cost , N , K ) { let count = 0 , sum = 0 ; cost . sort ( function ( a , b ) { return a - b } ) ; for ( let i = 0 ; i < N ; i ++ ) { if ( sum + cost [ i ] <= K ) { sum = sum + cost [ i ] ; count ++ ; } } return count ; }
Hyp: 
function maximum_toys ( cost , N , K ) { let count = 0 , sum = 0 ; cost . sort ( ( a , b ) => a - b ) ; for ( let i = 0 ; i < N ; i ++ ) { if ( sum + cost [ i ] <= K ) { sum = sum + cost [ i ] ; count ++ ; } } return count ; }

BLEU: 89.37
Edit Sim: 19


Src: 
void printCombination ( int n ) { for ( int i = 1 ; i < n ; i ++ ) { if ( i % 3 != 0 ) { for ( int j = 1 ; j < n ; j ++ ) { if ( j % 3 != 0 ) { for ( int k = 1 ; k < n ; k ++ ) { if ( k % 3 != 0 && ( i + j + k ) == n ) { cout << i << " ▁ " << j << " ▁ " << k ; return ; } } } } } } }
Ref: 
function printCombination ( n ) { for ( let i = 1 ; i < n ; i ++ ) { if ( i % 3 != 0 ) { for ( let j = 1 ; j < n ; j ++ ) { if ( j % 3 != 0 ) { for ( let k = 1 ; k < n ; k ++ ) { if ( k % 3 != 0 && ( i + j + k ) == n ) { document . write ( i + " " + j + " " + k ) ; return ; } } } } } } }
Hyp: 
function printCombination ( n ) { for ( let i = 1 ; i < n ; i ++ ) { if ( i % 3 != 0 ) { for ( let j = 1 ; j < n ; j ++ ) { if ( j % 3 != 0 ) { for ( let k = 1 ; k < n ; k ++ ) { if ( k % 3 != 0 && ( i + j + k ) == n ) { document . write ( i + " " + j + " " + k ) ; return ; } } } } } }

BLEU: 99.12
Edit Sim: 2


Src: 
int printPairs ( int arr [ ] , int n , int sum ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] + arr [ j ] == sum ) cout << " ( " << arr [ i ] << " , ▁ " << arr [ j ] << " ) " << endl ; }
Ref: 
function printPairs ( arr , n , sum ) { for ( let i = 0 ; i < n ; i ++ ) for ( let j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] + arr [ j ] == sum ) document . write ( " " + arr [ i ] + " " + arr [ j ] + " " + " " ) ; }
Hyp: 
function printPairs ( arr , n , sum ) { for ( let i = 0 ; i < n ; i ++ ) for ( let j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] + arr [ j ] == sum ) document . write ( " " + arr [ i ] + " " + arr [ j ] + " " ) ; }

BLEU: 96.27
Edit Sim: 6


Src: 
int bitExtracted ( int number , int k , int p ) { return ( ( ( 1 << k ) - 1 ) & ( number >> ( p - 1 ) ) ) ; }
Ref: 
function bitExtracted ( number , k , p ) { return ( ( ( 1 << k ) - 1 ) & ( number >> ( p - 1 ) ) ) ; }
Hyp: 
function bitExtracted ( number , k , p ) { return ( ( ( 1 << k ) - 1 ) & ( number >> ( p - 1 ) ) ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int setBitNumber ( int n ) { int k = ( int ) ( log2 ( n ) ) ; return 1 << k ; }
Ref: 
function setBitNumber ( n ) { let k = parseInt ( Math . log ( n ) / Math . log ( 2 ) , 10 ) ; return 1 << k ; }
Hyp: 
function setBitNumber ( n ) { let k = parseInt ( Math . log2 ( n ) ) ; return 1 << k ; }

BLEU: 57.64
Edit Sim: 25


Src: 
int countTrailingZero ( int x ) { static const int lookup [ ] = { 32 , 0 , 1 , 26 , 2 , 23 , 27 , 0 , 3 , 16 , 24 , 30 , 28 , 11 , 0 , 13 , 4 , 7 , 17 , 0 , 25 , 22 , 31 , 15 , 29 , 10 , 12 , 6 , 0 , 21 , 14 , 9 , 5 , 20 , 8 , 19 , 18 } ; return lookup [ ( - x & x ) % 37 ] ; }
Ref: 
function countTrailingZero ( x ) { let lookup = [ 32 , 0 , 1 , 26 , 2 , 23 , 27 , 0 , 3 , 16 , 24 , 30 , 28 , 11 , 0 , 13 , 4 , 7 , 17 , 0 , 25 , 22 , 31 , 15 , 29 , 10 , 12 , 6 , 0 , 21 , 14 , 9 , 5 , 20 , 8 , 19 , 18 ] ; return lookup [ ( - x & x ) % 37 ] ; }
Hyp: 
function countTrailingZero ( x ) { let lookup = { 32 , 0 , 1 , 26 , 2 , 23 , 27 , 0 , 3 , 16 , 24 , 28 , 11 , 0 , 13 , 4 , 7 , 17 , 0 , 25 , 22 , 31 , 15 , 29 , 10 , 12 , 6 , 0 , 21 , 14 , 9 , 5 , 20 , 8 , 19 , 18 } ; return lookup [ ( - x & x ) % 37 ] ; }

BLEU: 92.03
Edit Sim: 7


Src: 
int maxOR ( long long arr [ ] , int n , int k , int x ) { long long preSum [ n + 1 ] , suffSum [ n + 1 ] ; long long res , pow = 1 ; for ( int i = 0 ; i < k ; i ++ ) pow *= x ; preSum [ 0 ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) preSum [ i + 1 ] = preSum [ i ] | arr [ i ] ; suffSum [ n ] = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) suffSum [ i ] = suffSum [ i + 1 ] | arr [ i ] ; res = 0 ; for ( int i = 0 ; i < n ; i ++ ) res = max ( res , preSum [ i ] | ( arr [ i ] * pow ) suffSum [ i + 1 ] ) ; return res ; }
Ref: 
function maxOR ( arr , n , k , x ) { let preSum = new Array ( n + 1 ) ; let suffSum = new Array ( n + 1 ) ; let res = 0 , pow = 1 ; for ( let i = 0 ; i < k ; i ++ ) pow *= x ; preSum [ 0 ] = 0 ; for ( let i = 0 ; i < n ; i ++ ) preSum [ i + 1 ] = preSum [ i ] | arr [ i ] ; suffSum [ n ] = 0 ; for ( let i = n - 1 ; i >= 0 ; i -- ) suffSum [ i ] = suffSum [ i + 1 ] | arr [ i ] ; res = 0 ; for ( let i = 0 ; i < n ; i ++ ) res = Math . max ( res , preSum [ i ] | ( arr [ i ] * pow ) suffSum [ i + 1 ] ) ; return res ; }
Hyp: 
function maxOR ( arr , n , k , x ) { let preSum = new Array ( n + 1 ) ; let suffSum = new Array ( n + 1 ) ; let res = 0 ; for ( let i = 0 ; i < k ; i ++ ) pow *= x ; preSum [ 0 ] = 0 ; for ( let i = 0 ; i < n ; i ++ ) preSum [ i + 1 ] = preSum [ i ] | arr [ i ] ; suffSum [ n ] = 0 ; for ( let i = n - 1 ; i >= 0 ; i -- ) suffSum [ i ] = suffSum [ i + 1 ] | arr [ i ] ; res = 0 ; for ( let i = 0 ; i < n ; i ++ ) res = Math . max ( res , preSum [ i ] | ( arr [ i ] * pow ) suffSum [ i + 1 ] ) ; return res ; }

BLEU: 97.08
Edit Sim: 10


Src: 
void findPoints ( int l1 , int r1 , int l2 , int r2 ) { int x = ( l1 != l2 ) ? min ( l1 , l2 ) : -1 ; int y = ( r1 != r2 ) ? max ( r1 , r2 ) : -1 ; cout << x << " ▁ " << y ; }
Ref: 
function findPoints ( l1 , r1 , l2 , r2 ) { var x = ( l1 != l2 ) ? Math . min ( l1 , l2 ) : - 1 ; var y = ( r1 != r2 ) ? Math . max ( r1 , r2 ) : - 1 ; document . write ( x + " " + y ) ; }
Hyp: 
function findPoints ( l1 , r1 , l2 , r2 ) { let x = ( l1 != l2 ) ? Math . min ( l1 , l2 ) : - 1 ; let y = ( r1 != r2 ) ? Math . max ( r1 , r2 ) : - 1 ; document . write ( x + " " + y ) ; }

BLEU: 92.36
Edit Sim: 6


Src: 
int bridge_length ( int trainLength , int Speed , int Time ) { return ( ( Time * Speed ) - trainLength ) ; }
Ref: 
function bridge_length ( trainLength , Speed , Time ) { return ( ( Time * Speed ) - trainLength ) ; }
Hyp: 
function bridge_length ( trainLength , Speed , Time ) { return ( ( Time * Speed ) - trainLength ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int totalDigits ( int n ) { int number_of_digits = 0 ; for ( int i = 1 ; i <= n ; i *= 10 ) number_of_digits += ( n - i + 1 ) ; return number_of_digits ; }
Ref: 
function totalDigits ( n ) { var number_of_digits = 0 ; for ( var i = 1 ; i <= n ; i *= 10 ) number_of_digits += ( n - i + 1 ) ; return number_of_digits ; }
Hyp: 
function totalDigits ( n ) { let number_of_digits = 0 ; for ( let i = 1 ; i <= n ; i *= 10 ) number_of_digits += ( n - i + 1 ) ; return number_of_digits ; }

BLEU: 86.96
Edit Sim: 6


Src: 
int countSquares ( int r , int c , int m ) { int squares = 0 ; for ( int i = 1 ; i <= 8 ; i ++ ) { for ( int j = 1 ; j <= 8 ; j ++ ) { if ( max ( abs ( i - r ) , abs ( j - c ) ) <= m ) squares ++ ; } } return squares ; }
Ref: 
function countSquares ( r , c , m ) { let squares = 0 ; for ( let i = 1 ; i <= 8 ; i ++ ) { for ( let j = 1 ; j <= 8 ; j ++ ) { if ( Math . max ( Math . abs ( i - r ) , Math . abs ( j - c ) ) <= m ) squares ++ ; } } return squares ; }
Hyp: 
function countSquares ( r , c , m ) { let squares = 0 ; for ( let i = 1 ; i <= 8 ; i ++ ) { for ( let j = 1 ; j <= 8 ; j ++ ) { if ( Math . max ( Math . abs ( i - r ) , Math . abs ( j - c ) ) <= m ) squares ++ ; } } return squares ; }

BLEU: 100.0
Edit Sim: 0


Src: 
define show ( x )  cout << #x << " = " << x << " NEW_LINE " void check_euler_four_square_identity ( int a , int b , int ab ) { int s = 0 ; for ( int i = 0 ; i * i <= ab ; i ++ ) { s = i * i ; for ( int j = i ; j * j <= ab ; j ++ ) { s = j * j + i * i ; for ( int k = j ; k * k <= ab ; k ++ ) { s = k * k + j * j + i * i ; for ( int l = k ; l * l <= ab ; l ++ ) { s = l * l + k * k + j * j + i * i ; if ( s == ab ) { show ( i ) ; show ( j ) ; show ( k ) ; show ( l ) ; cout << " " << " Product ▁ of ▁ " << a << " ▁ and ▁ " << b ; cout << " ▁ can ▁ be ▁ written " << " ▁ as ▁ sum ▁ of ▁ squares ▁ of ▁ i , ▁ " << " j , ▁ k , ▁ l STRNEWLINE " ; cout << ab << " ▁ = ▁ " ; cout << i << " * " << i << " ▁ + ▁ " ; cout << j << " * " << j << " ▁ + ▁ " ; cout << k << " * " << k << " ▁ + ▁ " ; cout << l << " * " << l << " STRNEWLINE " ; cout << " STRNEWLINE " ; } } } } } }
Ref: 
function check_euler_four_square_identity ( a , b , ab ) { let s = 0 ; for ( let i = 0 ; i * i <= ab ; i ++ ) { s = i * i ; for ( let j = i ; j * j <= ab ; j ++ ) { s = j * j + i * i ; for ( let k = j ; k * k <= ab ; k ++ ) { s = k * k + j * j + i * i ; for ( let l = k ; l * l <= ab ; l ++ ) { s = l * l + k * k + j * j + i * i ; if ( s == ab ) { document . write ( " " + i + " " ) ; document . write ( " " + j + " " ) ; document . write ( " " + k + " " ) ; document . write ( " " + l + " " ) ; document . write ( " " + a + " " + b ) ; document . write ( " " + " " + " " + " " ) ; document . write ( ab + " " ) ; document . write ( i + " " + i + " " ) ; document . write ( j + " " + j + " " ) ; document . write ( k + " " + k + " " ) ; document . write ( l + " " + l + " " ) ; document . write ( " " ) ; } } } } } }
Hyp: 
function check_euler_four_square_identity ( a , b , ab ) { let s = 0 ; for ( let i = 0 ; i * i <= ab ; i ++ ) { s = i * i ; for ( let j = i ; j * j <= ab ; j ++ ) { s = j * j + i * i ; for ( let k = j ; k * k <= ab ; k ++ ) { s = k * k + j * j + i * i ; for ( let l = l * l + k * k + j * j + i * i ; if ( s == ab ) { show ( i ) ; show ( j ) ; show ( k ) ; show ( l ) ; document . write ( " " + " " + a + " " + b + " " + " " + j + " " + k + " " ) ; document . write ( l ) ; } } } }

BLEU: 48.54
Edit Sim: 349


Src: 
int sumOfSeries ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum = sum + i * ( i + 1 ) * ( i + 2 ) ; return sum ; }
Ref: 
function sumOfSeries ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) sum = sum + i * ( i + 1 ) * ( i + 2 ) ; return sum ; }
Hyp: 
function sumOfSeries ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) sum = sum + i * ( i + 1 ) * ( i + 2 ) ; return sum ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int addOne ( int x ) { int m = 1 ; while ( x & m ) { x = x ^ m ; m <<= 1 ; } x = x ^ m ; return x ; }
Ref: 
function addOne ( x ) { let m = 1 ; while ( x & m ) { x = x ^ m ; m <<= 1 ; } x = x ^ m ; return x ; }
Hyp: 
function addOne ( x ) { let m = 1 ; while ( x & m ) { x = x ^ m ; m <<= 1 ; } x = x ^ m ; return x ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int firstFactorialDivisibleNumber ( int x ) { int fact = 1 ; for ( i = 1 ; i < x ; i ++ ) { fact = fact * i ; if ( fact % x == 0 ) break ; } return i ; }
Ref: 
function firstFactorialDivisibleNumber ( x ) { var fact = 1 ; for ( i = 1 ; i < x ; i ++ ) { fact = fact * i ; if ( fact % x == 0 ) break ; } return i ; }
Hyp: 
function firstFactorialDivisibleNumber ( x ) { var fact = 1 ; for ( var i = 1 ; i < x ; i ++ ) { fact = fact * i ; if ( fact % x == 0 ) break ; } return i ; }

BLEU: 94.53
Edit Sim: 4


Src: 
void check ( unsigned long long m , unsigned long long int n ) { double RHS = m * ( double ) log ( n ) ; double LHS = n * ( double ) log ( m ) ; if ( LHS > RHS ) cout << " m ^ n ▁ > ▁ n ^ m " ; else if ( LHS < RHS ) cout << " m ^ n ▁ < ▁ n ^ m " ; else cout << " m ^ n ▁ = ▁ n ^ m " ; }
Ref: 
function check ( m , n ) { var RHS = m * Math . log ( n ) ; var LHS = n * Math . log ( m ) ; if ( LHS > RHS ) { document . write ( " " ) ; } else if ( LHS < RHS ) { document . write ( " " ) ; } else { document . write ( " " ) ; } }
Hyp: 
function check ( m , n ) { let RHS = m * Math . log ( n ) ; let LHS = n * Math . log ( m ) ; if ( LHS > RHS ) document . write ( " " + n + " " ) ; else if ( LHS < RHS ) document . write ( " " + n + " " ) ; else document . write ( " " + n + " " ) ; }

BLEU: 66.96
Edit Sim: 45


Src: 
bool checkHankelMatrix ( int n , int m [ N ] [ N ] ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i + j < n ) { if ( m [ i ] [ j ] != m [ i + j ] [ 0 ] ) return false ; } else { if ( m [ i ] [ j ] != m [ i + j - n + 1 ] [ n - 1 ] ) return false ; } } } return true ; }
Ref: 
function checkHankelMatrix ( n , m ) { for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { if ( i + j < n ) { if ( m [ i ] [ j ] != m [ i + j ] [ 0 ] ) return false ; } else { if ( m [ i ] [ j ] != m [ i + j - n + 1 ] [ n - 1 ] ) return false ; } } } return true ; }
Hyp: 
function checkHankelMatrix ( n , m ) { for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { if ( i + j < n ) { if ( m [ i ] [ j ] != m [ i + j ] [ 0 ] ) return false ; } else { if ( m [ i ] [ j ] != m [ i + j - n + 1 ] [ n - 1 ] ) return false ; } } } return true ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int minCost ( int coin [ ] , int n , int k ) { sort ( coin , coin + n ) ; int coins_needed = ceil ( 1.0 * n / ( k + 1 ) ) ; int ans = 0 ; for ( int i = 0 ; i <= coins_needed - 1 ; i ++ ) ans += coin [ i ] ; return ans ; }
Ref: 
function minCost ( coin , n , k ) { coin . sort ( function ( a , b ) { return a - b } ) var coins_needed = Math . ceil ( n / ( k + 1 ) ) ; var ans = 0 ; for ( var i = 0 ; i <= coins_needed - 1 ; i ++ ) ans += coin [ i ] ; return ans ; }
Hyp: 
function minCost ( coin , n , k ) { coin . sort ( ( a , b ) => a - b ) ; let coins_needed = Math . ceil ( 1.0 * n / ( k + 1 ) ) ; let ans = 0 ; for ( let i = 0 ; i <= coins_needed - 1 ; i ++ ) ans += coin [ i ] ; return ans ; }

BLEU: 76.75
Edit Sim: 34


Src: 
int toggleKthBit ( int n , int k ) { return ( n ^ ( 1 << ( k - 1 ) ) ) ; }
Ref: 
function toggleKthBit ( n , k ) { return ( n ^ ( 1 << ( k - 1 ) ) ) ; }
Hyp: 
function toggleKthBit ( n , k ) { return ( n ^ ( 1 << ( k - 1 ) ) ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int maxCandies ( int arr [ ] , int n ) { int prevBought = arr [ n - 1 ] ; int candies = prevBought ; for ( int i = n - 2 ; i >= 0 ; i -- ) { int x = min ( prevBought - 1 , arr [ i ] ) ; if ( x >= 0 ) { candies += x ; prevBought = x ; } } return candies ; }
Ref: 
function maxCandies ( arr , n ) { let prevBought = arr [ n - 1 ] ; let candies = prevBought ; for ( let i = n - 2 ; i >= 0 ; i -- ) { let x = Math . min ( prevBought - 1 , arr [ i ] ) ; if ( x >= 0 ) { candies += x ; prevBought = x ; } } return candies ; }
Hyp: 
function maxCandies ( arr , n ) { let prevBought = arr [ n - 1 ] ; let candies = prevBought ; for ( let i = n - 2 ; i >= 0 ; i -- ) { let x = Math . min ( prevBought - 1 , arr [ i ] ) ; if ( x >= 0 ) { candies += x ; prevBought = x ; } } return candies ; }

BLEU: 100.0
Edit Sim: 0


Src: 
bool isPossible ( int n ) { int fac [ 10 ] ; fac [ 0 ] = fac [ 1 ] = 1 ; for ( int i = 2 ; i < 10 ; i ++ ) fac [ i ] = fac [ i - 1 ] * i ; int sum = 0 ; int x = n ; while ( x ) { sum += fac [ x % 10 ] ; x /= 10 ; } if ( sum % n == 0 ) return true ; return false ; }
Ref: 
function isPossible ( n ) { var fac = new Array ( 10 ) ; fac [ 0 ] = fac [ 1 ] = 1 ; for ( var i = 2 ; i < 10 ; i ++ ) fac [ i ] = fac [ i - 1 ] * i ; var sum = 0 ; var x = n ; while ( x != 0 ) { sum += fac [ x % 10 ] ; x = parseInt ( x / 10 ) ; } if ( sum % n == 0 ) return true ; return false ; }
Hyp: 
function isPossible ( n ) { let fac = new Array ( 10 ) ; fac [ 0 ] = fac [ 1 ] = 1 ; for ( let i = 2 ; i < 10 ; i ++ ) fac [ i ] = fac [ i - 1 ] * i ; let sum = 0 ; let x = n ; while ( x ) { sum += fac [ x % 10 ] ; x = Math . floor ( x / 10 ) ; } if ( sum % n == 0 ) return true ; return false ; }

BLEU: 84.51
Edit Sim: 28


Src: 
int divisible ( string num ) { int n = num . length ( ) ; int sum = accumulate ( begin ( num ) , end ( num ) , 0 ) - '0' * 1 ; if ( sum % 3 == 0 ) return 0 ; if ( n == 1 ) return -1 ; for ( int i = 0 ; i < n ; i ++ ) if ( sum % 3 == ( num [ i ] - '0' ) % 3 ) return 1 ; if ( n == 2 ) return -1 ; return 2 ; }
Ref: 
function divisible ( num ) { let n = num . length ; let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum += ( num . charAt ( i ) ) ; if ( sum % 3 == 0 ) return 0 ; if ( n == 1 ) return - 1 ; for ( let i = 0 ; i < n ; i ++ ) if ( sum % 3 == ( num . charAt ( i ) - ' ' ) % 3 ) return 1 ; if ( n == 2 ) return - 1 ; return 2 ; }
Hyp: 
function divisible ( num ) { let n = num . length ; let sum = accumulate ( begin ( num ) , end ( num ) , 0 ) - ' ' * 1 ; if ( sum % 3 == 0 ) return 0 ; if ( n == 1 ) return - 1 ; for ( let i = 0 ; i < n ; i ++ ) if ( sum % 3 == ( num [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) % 3 ) return 1 ; if ( n == 2 ) return - 2 ; }

BLEU: 68.58
Edit Sim: 82


Src: 
int findSum ( int n ) { int sum = 0 ; for ( int i = 1 ; ( 1 << i ) < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { int num = ( 1 << i ) + ( 1 << j ) ; if ( num <= n ) sum += num ; } } return sum ; }
Ref: 
function findSum ( n ) { let sum = 0 ; for ( let i = 1 ; 1 << i < n ; i ++ ) { for ( let j = 0 ; j < i ; j ++ ) { let num = ( 1 << i ) + ( 1 << j ) ; if ( num <= n ) sum += num ; } } return sum ; }
Hyp: 
function findSum ( n ) { let sum = 0 ; for ( let i = 1 ; ( 1 << i ) < n ; i ++ ) { for ( let j = 0 ; j < i ; j ++ ) { let num = ( 1 << i ) + ( 1 << j ) ; if ( num <= n ) sum += num ; } } return sum ; }

BLEU: 93.28
Edit Sim: 4


Src: 
int min_noOf_operation ( int arr [ ] , int n , int k ) { int noOfSubtraction ; int res = 0 ; for ( int i = 1 ; i < n ; i ++ ) { noOfSubtraction = 0 ; if ( arr [ i ] > arr [ i - 1 ] ) { noOfSubtraction = ( arr [ i ] - arr [ i - 1 ] ) / k ; if ( ( arr [ i ] - arr [ i - 1 ] ) % k != 0 ) noOfSubtraction ++ ; arr [ i ] = arr [ i ] - k * noOfSubtraction ; } res = res + noOfSubtraction ; } return res ; }
Ref: 
function min_noOf_operation ( arr , n , k ) { let noOfSubtraction ; let res = 0 ; for ( let i = 1 ; i < n ; i ++ ) { noOfSubtraction = 0 ; if ( arr [ i ] > arr [ i - 1 ] ) { noOfSubtraction = ( arr [ i ] - arr [ i - 1 ] ) / k ; if ( ( arr [ i ] - arr [ i - 1 ] ) % k != 0 ) noOfSubtraction ++ ; arr [ i ] = arr [ i ] - k * noOfSubtraction ; } res = res + noOfSubtraction ; } return res ; }
Hyp: 
function min_noOf_operation ( arr , n , k ) { let noOfSubtraction ; let res = 0 ; for ( let i = 1 ; i < n ; i ++ ) { noOfSubtraction = 0 ; if ( arr [ i ] > arr [ i - 1 ] ) { noOfSubtraction = parseInt ( ( arr [ i ] - arr [ i - 1 ] ) / k ) ; if ( ( arr [ i ] - arr [ i - 1 ] ) % k != 0 ) noOfSubtraction ++ ; arr [ i ] = arr [ i ] - k * noOfSubtraction ; } res = res + noOfSubtraction ; } return res ; }

BLEU: 95.03
Edit Sim: 13


Src: 
void findArea ( float a , float b ) { float Area ; Area = 3.142 * a * b ; cout << " Area : ▁ " << Area ; }
Ref: 
function findArea ( a , b ) { var Area ; Area = 3.142 * a * b ; document . write ( " " + Area . toFixed ( 2 ) ) ; }
Hyp: 
function findArea ( a , b ) { let Area ; Area = 3.142 * a * b ; document . write ( " " + Area . toFixed ( 10 ) ) ; }

BLEU: 85.0
Edit Sim: 5


Src: 
int maxDifference ( int arr [ ] , int N , int k ) { int M , S = 0 , S1 = 0 , max_difference = 0 ; for ( int i = 0 ; i < N ; i ++ ) S += arr [ i ] ; sort ( arr , arr + N , greater < int > ( ) ) ; M = max ( k , N - k ) ; for ( int i = 0 ; i < M ; i ++ ) S1 += arr [ i ] ; max_difference = S1 - ( S - S1 ) ; return max_difference ; }
Ref: 
function maxDifference ( arr , N , k ) { let M , S = 0 , S1 = 0 , max_difference = 0 ; for ( let i = 0 ; i < N ; i ++ ) S += arr [ i ] ; let temp ; for ( let i = 0 ; i < N ; i ++ ) { for ( let j = i + 1 ; j < N ; j ++ ) { if ( arr [ i ] < arr [ j ] ) { temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; } } } M = Math . max ( k , N - k ) ; for ( let i = 0 ; i < M ; i ++ ) S1 += arr [ i ] ; max_difference = S1 - ( S - S1 ) ; return max_difference ; }
Hyp: 
function maxDifference ( arr , N , k ) { let M , S = 0 , S1 = 0 , max_difference = 0 ; for ( let i = 0 ; i < N ; i ++ ) S += arr [ i ] ; sort ( arr , arr + N , greater < int > ( ) ) ; M = Math . max ( k , N - k ) ; for ( let i = 0 ; i < M ; i ++ ) S1 += arr [ i ] ; max_difference = S1 - ( S - S1 ) ; return max_difference ; }

BLEU: 50.51
Edit Sim: 153


Src: 
int minJumps ( int arr [ ] , int n ) { if ( n == 1 ) return 0 ; int res = INT_MAX ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( i + arr [ i ] >= n - 1 ) { int sub_res = minJumps ( arr , i + 1 ) ; if ( sub_res != INT_MAX ) res = min ( res , sub_res + 1 ) ; } } return res ; }
Ref: 
function minJumps ( arr , n ) { if ( n == 1 ) return 0 ; let res = Number . MAX_VALUE ; for ( let i = n - 2 ; i >= 0 ; i -- ) { if ( i + arr [ i ] >= n - 1 ) { let sub_res = minJumps ( arr , i + 1 ) ; if ( sub_res != Number . MAX_VALUE ) res = Math . min ( res , sub_res + 1 ) ; } } return res ; }
Hyp: 
function minJumps ( arr , n ) { if ( n == 1 ) return 0 ; let res = Number . MAX_VALUE ; for ( let i = n - 2 ; i >= 0 ; i -- ) { if ( i + arr [ i ] >= n - 1 ) { let sub_res = minJumps ( arr , i + 1 ) ; if ( sub_res != Number . MAX_VALUE ) res = Math . min ( res , sub_res + 1 ) ; } } return res ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int evenSum ( int n ) { return ( n * ( n + 1 ) ) ; }
Ref: 
function evenSum ( n ) { return ( n * ( n + 1 ) ) ; }
Hyp: 
function evenSum ( n ) { return ( n * ( n + 1 ) ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
void printArray ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int l = 0 , r = n - 1 , flag = 0 , i ; int k = 2 ; while ( l <= r ) { if ( flag == 0 ) { for ( i = l ; i < l + k && i <= r ; i ++ ) cout << arr [ i ] << " ▁ " ; flag = 1 ; l = i ; } { for ( i = r ; i > r - k && i >= l ; i -- ) cout << arr [ i ] << " ▁ " ; flag = 0 ; r = i ; } k ++ ; } }
Ref: 
function printArray ( arr , n ) { arr . sort ( ) ; let l = 0 , r = n - 1 , flag = 0 , i ; let k = 2 ; while ( l <= r ) { if ( flag == 0 ) { for ( i = l ; i < l + k && i <= r ; i ++ ) document . write ( arr [ i ] + " " ) ; flag = 1 ; l = i ; } else { for ( i = r ; i > r - k && i >= l ; i -- ) document . write ( arr [ i ] + " " ) ; flag = 0 ; r = i ; } k ++ ; } }
Hyp: 
function printArray ( arr , n ) { arr . sort ( function ( a , b ) { return a - b } ) ; let l = 0 , r = n - 1 , flag = 0 , i ; let k = 2 ; while ( l <= r ) { if ( flag == 0 ) { for ( i = l ; i < l + k && i <= r ; i ++ ) document . write ( arr [ i ] + " " ) ; flag = 1 ; l = i ; } else { for ( i = r ; i > r - k && i >= l ; i -- ) document . write ( arr [ i ] + " " ) ; flag = 0 ; r = i ; } k ++ ; } }

BLEU: 91.02
Edit Sim: 36


Src: 
int nthEnneadecagonal ( long int n ) { return ( 17 * n * n - 15 * n ) / 2 ; }
Ref: 
function nthEnneadecagonal ( n ) { return ( 17 * n * n - 15 * n ) / 2 ; }
Hyp: 
function nthEnneadecagonal ( n ) { return ( 17 * n * n - 15 * n ) / 2 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int findMaxNum ( int arr [ ] , int n ) { sort ( arr , arr + n , greater < int > ( ) ) ; int num = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { num = num * 10 + arr [ i ] ; } return num ; }
Ref: 
function findMaxNum ( arr , n ) { arr . sort ( function ( a , b ) { return b - a ; } ) ; var num = arr [ 0 ] ; for ( var i = 1 ; i < n ; i ++ ) { num = num * 10 + arr [ i ] ; } return num ; }
Hyp: 
function findMaxNum ( arr , n ) { arr . sort ( ( a , b ) => a - b ) ; let num = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { num = num * 10 + arr [ i ] ; } return num ; }

BLEU: 76.4
Edit Sim: 29


Src: 
void multiple ( int a , int b , int x ) { if ( b < 0 ) { if ( a == 1 && x == 1 ) cout << "1" ; else cout << "0" ; } int mul = pow ( a , b ) ; int ans = mul / x ; int ans1 = x * ans ; int ans2 = x * ( ans + 1 ) ; cout << ( ( ( mul - ans1 ) <= ( ans2 - mul ) ) ? ans1 : ans2 ) ; }
Ref: 
function multiple ( a , b , x ) { if ( b < 0 ) { if ( a == 1 && x == 1 ) document . write ( " " ) ; else document . write ( " " ) ; } var mul = parseInt ( Math . pow ( a , b ) ) ; var ans = mul / x ; var ans1 = x * ans ; var ans2 = x * ( ans + 1 ) ; document . write ( ( ( mul - ans1 ) <= ( ans2 - mul ) ) ? ans1 : ans2 ) ; }
Hyp: 
function multiple ( a , b , x ) { if ( b < 0 ) { if ( a == 1 && x == 1 ) document . write ( " " ) ; else document . write ( " " ) ; } let mul = Math . pow ( a , b ) ; let ans = mul / x ; let ans1 = x * ans ; let ans2 = x * ( ans + 1 ) ; document . write ( ( ( mul - ans1 ) <= ( ans2 - mul ) ) ? ans1 : ans2 ) ; }

BLEU: 86.16
Edit Sim: 25


Src: 
int countKeyPressed ( string str , int len ) { int count = 0 ; for ( int i = 0 ; i < len ; i ++ ) count = count + arr [ str [ i ] - ' a ' ] ; return count ; }
Ref: 
function countKeyPressed ( str , len ) { var count = 0 ; for ( var i = 0 ; i < len ; i ++ ) count = count + arr [ str . charCodeAt ( i ) - 97 ] ; return count ; }
Hyp: 
function countKeyPressed ( str , len ) { var count = 0 ; for ( var i = 0 ; i < len ; i ++ ) count = count + arr [ str [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ; return count ; }

BLEU: 72.54
Edit Sim: 29


Src: 
void merge ( int ar1 [ ] , int ar2 [ ] , int m , int n ) { for ( int i = n - 1 ; i >= 0 ; i -- ) { int j , last = ar1 [ m - 1 ] ; for ( j = m - 2 ; j >= 0 && ar1 [ j ] > ar2 [ i ] ; j -- ) ar1 [ j + 1 ] = ar1 [ j ] ; if ( j != m - 2 last > ar2 [ i ] ) { ar1 [ j + 1 ] = ar2 [ i ] ; ar2 [ i ] = last ; } } }
Ref: 
function merge ( m , n ) { for ( let i = n - 1 ; i >= 0 ; i -- ) { let j , last = arr1 [ m - 1 ] ; for ( j = m - 2 ; j >= 0 && arr1 [ j ] > arr2 [ i ] ; j -- ) arr1 [ j + 1 ] = arr1 [ j ] ; if ( j != m - 2 last > arr2 [ i ] ) { arr1 [ j + 1 ] = arr2 [ i ] ; arr2 [ i ] = last ; } } } merge ( arr1 . length , arr2 . length ) ; document . write ( " " ) ; for ( let i = 0 ; i < arr1 . length ; i ++ ) { document . write ( arr1 [ i ] + " " ) ; } document . write ( " " ) ; for ( let i = 0 ; i < arr2 . length ; i ++ ) { document . write ( arr2 [ i ] + " " ) ; }
Hyp: 
function merge ( ar1 , ar2 , m , n ) { for ( let i = n - 1 ; i >= 0 ; i -- ) { let j , last = ar1 [ m - 1 ] ; for ( j = m - 2 ; j >= 0 && ar1 [ j ] > ar2 [ i ] ; j -- ) ar1 [ j + 1 ] = ar1 [ j ] ; if ( j != m - 2 last > ar2 [ i ] ) { ar1 [ j + 1 ] = ar2 [ i ] ; ar2 [ i ] = last ; } } }

BLEU: 35.79
Edit Sim: 295


Src: 
int evenSum ( int n ) { int curr = 2 , sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { sum += curr ; curr += 2 ; } return sum ; }
Ref: 
function evenSum ( n ) { let curr = 2 , sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { sum += curr ; curr += 2 ; } return sum ; }
Hyp: 
function evenSum ( n ) { let curr = 2 , sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { sum += curr ; curr += 2 ; } return sum ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int lastNon0Digit ( int n ) { if ( n < 10 ) return dig [ n ] ; if ( ( ( n / 10 ) % 10 ) % 2 == 0 ) return ( 6 * lastNon0Digit ( n / 5 ) * dig [ n % 10 ] ) % 10 ; else return ( 4 * lastNon0Digit ( n / 5 ) * dig [ n % 10 ] ) % 10 ; }
Ref: 
function lastNon0Digit ( n ) { if ( n < 10 ) return dig [ n ] ; if ( ( parseInt ( n / 10 , 10 ) % 10 ) % 2 == 0 ) return ( 6 * lastNon0Digit ( parseInt ( n / 5 , 10 ) ) * dig [ n % 10 ] ) % 10 ; else return ( 4 * lastNon0Digit ( parseInt ( n / 5 , 10 ) ) * dig [ n % 10 ] ) % 10 ; }
Hyp: 
function lastNon0Digit ( n ) { if ( n < 10 ) return dig [ n ] ; if ( ( ( n / 10 ) % 10 ) % 2 == 0 ) return ( 6 * lastNon0Digit ( n / 5 ) * dig [ n % 10 ] ) % 10 ; else return ( 4 * lastNon0Digit ( n / 5 ) * dig [ n % 10 ] ) % 10 ; }

BLEU: 76.91
Edit Sim: 50


Src: 
string isDivisible ( long long int n ) { long long int temp = n ; int sum = 0 ; while ( n ) { int k = n % 10 ; sum += k ; n /= 10 ; } if ( temp % sum == 0 ) return " YES " ; return " NO " ; }
Ref: 
function isDivisible ( n ) { temp = n ; sum = 0 ; while ( n ) { k = n % 10 ; sum += k ; n = parseInt ( n / 10 ) ; } if ( temp % sum == 0 ) return " " ; return " " ; }
Hyp: 
function isDivisible ( n ) { let temp = n ; let sum = 0 ; while ( n > 0 ) { let k = n % 10 ; sum += k ; n = Math . floor ( n / 10 ) ; } if ( temp % sum == 0 ) return " " ; return " " ; }

BLEU: 74.92
Edit Sim: 27


Src: 
int isSumDivides ( int N ) { int temp = N ; int sum = 0 ; while ( temp ) { sum += temp % 10 ; temp /= 10 ; } if ( N % sum == 0 ) return 1 ; else return 0 ; }
Ref: 
function isSumDivides ( N ) { var temp = N ; var sum = 0 ; while ( temp > 0 ) { sum += temp % 10 ; temp = parseInt ( temp / 10 ) ; } if ( N % sum == 0 ) return 1 ; else return 0 ; }
Hyp: 
function isSumDivides ( N ) { let temp = N ; let sum = 0 ; while ( temp ) { sum += temp % 10 ; temp = Math . floor ( temp / 10 ) ; } if ( N % sum == 0 ) return 1 ; else return 0 ; }

BLEU: 79.17
Edit Sim: 21


Src: 
int findLength ( string str , int n ) { int current_sum = 0 ; int max_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { current_sum += ( str [ i ] == '0' ? 1 : -1 ) ; if ( current_sum < 0 ) current_sum = 0 ; max_sum = max ( current_sum , max_sum ) ; } return max_sum == 0 ? -1 : max_sum ; }
Ref: 
function findLength ( str , n ) { let current_sum = 0 ; let max_sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { current_sum += ( str [ i ] == ' ' ? 1 : - 1 ) ; if ( current_sum < 0 ) { current_sum = 0 ; } max_sum = Math . max ( current_sum , max_sum ) ; } return max_sum == 0 ? - 1 : max_sum ; }
Hyp: 
function findLength ( str , n ) { var current_sum = 0 ; var max_sum = 0 ; for ( var i = 0 ; i < n ; i ++ ) { current_sum += ( str [ i ] == ' ' ? 1 : - 1 ) ; if ( current_sum < 0 ) current_sum = 0 ; max_sum = Math . max ( current_sum , max_sum ) ; } return max_sum == 0 ? - 1 : max_sum ; }

BLEU: 84.83
Edit Sim: 13


Src: 
int seriesSum ( int calculated , int current , int N ) { int i , cur = 1 ; if ( current == N + 1 ) return 0 ; for ( i = calculated ; i < calculated + current ; i ++ ) cur *= i ; return cur + seriesSum ( i , current + 1 , N ) ; }
Ref: 
function seriesSum ( calculated , current , N ) { let i , cur = 1 ; if ( current == N + 1 ) return 0 ; for ( i = calculated ; i < calculated + current ; i ++ ) cur *= i ; return cur + seriesSum ( i , current + 1 , N ) ; }
Hyp: 
function seriesSum ( calculated , current , N ) { let i , cur = 1 ; if ( current == N + 1 ) return 0 ; for ( i = calculated ; i < calculated + current ; i ++ ) cur *= i ; return cur + seriesSum ( i , current + 1 , N ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int findCount ( int arr [ ] , int n ) { int countOdd = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 == 1 ) countOdd ++ ; if ( countOdd % 2 == 0 ) return 1 ; else return 0 ; }
Ref: 
function findCount ( arr , n ) { var countOdd = 0 ; for ( var i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 == 1 ) countOdd ++ ; if ( countOdd % 2 == 0 ) return 1 ; else return 0 ; }
Hyp: 
function findCount ( arr , n ) { let countOdd = 0 ; for ( let i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 == 1 ) countOdd ++ ; if ( countOdd % 2 == 0 ) return 1 ; else return 0 ; }

BLEU: 90.97
Edit Sim: 6


Src: 
int matrixSum ( int arr [ ] [ n ] ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) { int top_left = ( i + 1 ) * ( j + 1 ) ; int bottom_right = ( n - i ) * ( n - j ) ; sum += ( top_left * bottom_right * arr [ i ] [ j ] ) ; } return sum ; }
Ref: 
function matrixSum ( arr ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = 0 ; j < n ; j ++ ) { let top_left = ( i + 1 ) * ( j + 1 ) ; let bottom_right = ( n - i ) * ( n - j ) ; sum += ( top_left * bottom_right * arr [ i ] [ j ] ) ; } return sum ; }
Hyp: 
function matrixSum ( arr ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = 0 ; j < n ; j ++ ) { let top_left = ( i + 1 ) * ( j + 1 ) ; let bottom_right = ( n - i ) * ( n - j ) ; sum += ( top_left * bottom_right * arr [ i ] [ j ] ) ; } return sum ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int smallestMultiple ( int n ) { if ( n == 1 ) return 5 ; return pow ( 10 , n - 1 ) ; }
Ref: 
function smallestMultiple ( n ) { if ( n == 1 ) return 5 ; return Math . pow ( 10 , n - 1 ) ; }
Hyp: 
function smallestMultiple ( n ) { if ( n == 1 ) return 5 ; return Math . pow ( 10 , parseInt ( n - 1 ) ) ; }

BLEU: 82.23
Edit Sim: 13


Src: 
void segregate0and1 ( int arr [ ] , int size ) { int type0 = 0 ; int type1 = size - 1 ; while ( type0 < type1 ) { if ( arr [ type0 ] == 1 ) { swap ( arr [ type0 ] , arr [ type1 ] ) ; type1 -- ; } else type0 ++ ; } }
Ref: 
function segregate0and1 ( arr , size ) { let type0 = 0 ; let type1 = size - 1 ; while ( type0 < type1 ) { if ( arr [ type0 ] == 1 ) { arr [ type1 ] = arr [ type1 ] + arr [ type0 ] ; arr [ type0 ] = arr [ type1 ] - arr [ type0 ] ; arr [ type1 ] = arr [ type1 ] - arr [ type0 ] ; type1 -- ; } else type0 ++ ; } }
Hyp: 
function segregate0and1 ( arr , size ) { let type0 = 0 ; let type1 = size - 1 ; while ( type0 < type1 ) { if ( arr [ type0 ] == 1 ) { swap ( arr [ type0 ] , arr [ type1 ] ) ; type1 -- ; } else type0 ++ ; } }

BLEU: 50.1
Edit Sim: 108


Src: 
int findIndex ( int n ) { if ( n <= 1 ) return n ; int a = 0 , b = 1 , c = 1 ; int res = 1 ; while ( c < n ) { c = a + b ; res ++ ; a = b ; b = c ; } return res ; }
Ref: 
function findIndex ( n ) { if ( n <= 1 ) return n ; let a = 0 , b = 1 , c = 1 ; let res = 1 ; while ( c < n ) { c = a + b ; res ++ ; a = b ; b = c ; } return res ; }
Hyp: 
function findIndex ( n ) { if ( n <= 1 ) return n ; let a = 0 , b = 1 , c = 1 ; let res = 1 ; while ( c < n ) { c = a + b ; res ++ ; a = b ; b = c ; } return res ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int sum ( long long int n ) { long long int root = sqrt ( n ) ; long long int ans = 0 ; for ( int i = 1 ; i <= root ; i ++ ) ans += n / i ; ans = 2 * ans - ( root * root ) ; return ans ; }
Ref: 
function sum ( n ) { let root = parseInt ( Math . sqrt ( n ) ) ; let ans = 0 ; for ( let i = 1 ; i <= root ; i ++ ) ans += parseInt ( n / i ) ; ans = ( 2 * ans ) - ( root * root ) ; return ans ; }
Hyp: 
function sum ( n ) { let root = Math . sqrt ( n ) ; let ans = 0 ; for ( let i = 1 ; i <= root ; i ++ ) ans += n / i ; ans = 2 * ans - ( root * root ) ; return ans ; }

BLEU: 73.31
Edit Sim: 30


Src: 
int findBucketNo ( int p ) { return ceil ( ( sqrt ( 8 * p + 1 ) - 1 ) / 2 ) ; }
Ref: 
function findBucketNo ( p ) { return Math . ceil ( ( Math . sqrt ( 8 * p + 1 ) - 1 ) / 2 ) ; }
Hyp: 
function findBucketNo ( p ) { return Math . ceil ( ( Math . sqrt ( 8 * p + 1 ) - 1 ) / 2 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int nthTermOfTheSeries ( int n ) { int nthTerm ; if ( n % 2 == 0 ) nthTerm = pow ( n - 1 , 2 ) + n ; else nthTerm = pow ( n + 1 , 2 ) + n ; return nthTerm ; }
Ref: 
function nthTermOfTheSeries ( n ) { let nthTerm ; if ( n % 2 == 0 ) nthTerm = Math . pow ( n - 1 , 2 ) + n ; else nthTerm = Math . pow ( n + 1 , 2 ) + n ; return nthTerm ; }
Hyp: 
function nthTermOfTheSeries ( n ) { let nthTerm ; if ( n % 2 == 0 ) nthTerm = Math . pow ( n - 1 , 2 ) + n ; else nthTerm = Math . pow ( n + 1 , 2 ) + n ; return nthTerm ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int OR ( int a [ ] , int n ) { int ans = a [ 0 ] ; for ( int i = 1 ; i < n ; ++ i ) ans |= a [ i ] ; return ans ; }
Ref: 
function OR ( a , n ) { var ans = a [ 0 ] ; for ( var i = 1 ; i < n ; ++ i ) ans |= a [ i ] ; return ans ; }
Hyp: 
function OR ( a , n ) { let ans = a [ 0 ] ; for ( let i = 1 ; i < n ; ++ i ) ans |= a [ i ] ; return ans ; }

BLEU: 87.29
Edit Sim: 6


Src: 
int countXorPair ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) if ( ( arr [ i ] ^ arr [ j ] ) % 2 == 1 ) count ++ ; } return count ; }
Ref: 
function countXorPair ( arr , n ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i + 1 ; j < n ; j ++ ) if ( ( arr [ i ] ^ arr [ j ] ) % 2 == 1 ) count ++ ; } return count ; }
Hyp: 
function countXorPair ( arr , n ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i + 1 ; j < n ; j ++ ) if ( ( arr [ i ] ^ arr [ j ] ) % 2 == 1 ) count ++ ; } return count ; }

BLEU: 100.0
Edit Sim: 0


Src: 
void printPFsInPairs ( int n ) { for ( int i = 1 ; i * i <= n ; i ++ ) if ( n % i == 0 ) cout << i << " * " << n / i << endl ; }
Ref: 
function printPFsInPairs ( n ) { for ( let i = 1 ; i * i <= n ; i ++ ) if ( n % i == 0 ) document . write ( i + " " + parseInt ( n / i ) + " " ) ; }
Hyp: 
function printPFsInPairs ( n ) { for ( let i = 1 ; i * i <= n ; i ++ ) if ( n % i == 0 ) document . write ( i + " " + n / i + " " ) ; }

BLEU: 87.78
Edit Sim: 13


Src: 
int countSubstringWithEqualEnds ( string s ) { int result = 0 ; int n = s . length ( ) ; int count [ MAX_CHAR ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) count [ s [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) result += ( count [ i ] * ( count [ i ] + 1 ) / 2 ) ; return result ; }
Ref: 
function countSubstringWithEqualEnds ( s ) { var result = 0 ; var n = s . length ; var count = Array . from ( { length : MAX_CHAR } , ( _ , i ) => 0 ) ; for ( var i = 0 ; i < n ; i ++ ) count [ s . charAt ( i ) . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; for ( var i = 0 ; i < MAX_CHAR ; i ++ ) result += ( count [ i ] * ( count [ i ] + 1 ) / 2 ) ; return result ; }
Hyp: 
function countSubstringWithEqualEnds ( s ) { let result = 0 ; let n = s . length ; let count = Array ( MAX_CHAR ) . fill ( 0 ) ; for ( let i = 0 ; i < n ; i ++ ) count [ s [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; for ( let i = 0 ; i < MAX_CHAR ; i ++ ) result += ( count [ i ] * ( count [ i ] + 1 ) / 2 ) ; return result ; }

BLEU: 69.81
Edit Sim: 56


Src: 
double areaCircle ( double b ) { double area = pi * b * b ; return area ; }
Ref: 
function areaCircle ( b ) { let area = 3.1415926 * b * b ; return area ; }
Hyp: 
function areaCircle ( b ) { let area = pi * b * b ; return area ; }

BLEU: 85.79
Edit Sim: 9


Src: 
void printMinDiffPairs ( int arr [ ] , int n ) { if ( n <= 1 ) return ; sort ( arr , arr + n ) ; int minDiff = arr [ 1 ] - arr [ 0 ] ; for ( int i = 2 ; i < n ; i ++ ) minDiff = min ( minDiff , arr [ i ] - arr [ i - 1 ] ) ; for ( int i = 1 ; i < n ; i ++ ) if ( ( arr [ i ] - arr [ i - 1 ] ) == minDiff ) cout << " ( " << arr [ i - 1 ] << " , ▁ " << arr [ i ] << " ) , ▁ " ; }
Ref: 
function printMinDiffPairs ( arr , n ) { if ( n <= 1 ) return ; arr . sort ( ) ; let minDiff = arr [ 1 ] - arr [ 0 ] ; for ( let i = 2 ; i < n ; i ++ ) minDiff = Math . min ( minDiff , arr [ i ] - arr [ i - 1 ] ) ; for ( let i = 1 ; i < n ; i ++ ) { if ( ( arr [ i ] - arr [ i - 1 ] ) == minDiff ) { document . write ( " " + arr [ i - 1 ] + " " + arr [ i ] + " " ) ; } } }
Hyp: 
function printMinDiffPairs ( arr , n ) { if ( n <= 1 ) return ; arr . sort ( ( a , b ) => a - b ) ; let minDiff = arr [ 1 ] - arr [ 0 ] ; for ( let i = 2 ; i < n ; i ++ ) minDiff = Math . min ( minDiff , arr [ i ] - arr [ i - 1 ] ) ; for ( let i = 1 ; i < n ; i ++ ) if ( ( arr [ i ] - arr [ i - 1 ] ) == minDiff ) document . write ( " " + arr [ i - 1 ] + " " + arr [ i ] + " " ) ; }

BLEU: 90.13
Edit Sim: 27


Src: 
bool isMultipleOf10 ( int n ) { return ( n % 15 == 0 ) ; }
Ref: 
function isMultipleOf10 ( n ) { return ( n % 15 == 0 ) ; }
Hyp: 
function isMultipleOf10 ( n ) { return ( n % 15 == 0 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int sumofFactors ( int n ) { if ( n % 2 != 0 ) return 0 ; int res = 1 ; for ( int i = 2 ; i <= sqrt ( n ) ; i ++ ) { int count = 0 , curr_sum = 1 , curr_term = 1 ; while ( n % i == 0 ) { count ++ ; n = n / i ; if ( i == 2 && count == 1 ) curr_sum = 0 ; curr_term *= i ; curr_sum += curr_term ; } res *= curr_sum ; } if ( n >= 2 ) res *= ( 1 + n ) ; return res ; }
Ref: 
function sumofFactors ( n ) { if ( n % 2 != 0 ) return 0 ; let res = 1 ; for ( let i = 2 ; i <= Math . sqrt ( n ) ; i ++ ) { let count = 0 , curr_sum = 1 ; let curr_term = 1 ; while ( n % i == 0 ) { count ++ ; n = n / i ; if ( i == 2 && count == 1 ) curr_sum = 0 ; curr_term *= i ; curr_sum += curr_term ; } res *= curr_sum ; } if ( n >= 2 ) res *= ( 1 + n ) ; return res ; }
Hyp: 
function sumofFactors ( n ) { if ( n % 2 != 0 ) return 0 ; let res = 1 ; for ( let i = 2 ; i <= Math . sqrt ( n ) ; i ++ ) { let count = 0 ; let curr_sum = 1 ; let curr_term = 1 ; while ( n % i == 0 ) { count ++ ; n = n / i ; if ( i == 2 && count == 1 ) curr_sum = 0 ; curr_term *= i ; curr_sum += curr_term ; } res *= curr_sum ; } if ( n >= 2 ) res *= ( 1 + n ) ; return res ; }

BLEU: 97.08
Edit Sim: 5


Src: 
double longestRodInCuboid ( int length , int breadth , int height ) { double result ; int temp ; temp = length * length + breadth * breadth + height * height ; result = sqrt ( temp ) ; return result ; }
Ref: 
function longestRodInCuboid ( length , breadth , height ) { let result ; let temp ; temp = length * length + breadth * breadth + height * height ; result = Math . sqrt ( temp ) ; return result ; }
Hyp: 
function longestRodInCuboid ( length , breadth , height ) { let result ; let temp ; temp = length * length + breadth * breadth + height * height ; result = Math . sqrt ( temp ) ; return result ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int getMinNum ( int a , int b , int c ) { if ( c < a c > b ) return c ; int x = ( ( b / c ) * c ) + c ; return x ; }
Ref: 
function getMinNum ( a , b , c ) { if ( c < a c > b ) return c ; let x = ( parseInt ( b / c ) * c ) + c ; return x ; }
Hyp: 
function getMinNum ( a , b , c ) { if ( c < a c > b ) return c ; let x = ( ( b / c ) * c ) + c ; return x ; }

BLEU: 93.86
Edit Sim: 9


Src: 
float sphereSide ( float h , float r ) { if ( h < 0 && r < 0 ) return -1 ; float R = ( ( h * r * sqrt ( 2 ) ) / ( h + sqrt ( 2 ) * r ) ) / 2 ; return R ; }
Ref: 
function sphereSide ( h , r ) { if ( h < 0 && r < 0 ) return - 1 ; var R = ( ( h * r * Math . sqrt ( 2 ) ) / ( h + Math . sqrt ( 2 ) * r ) ) / 2 ; return R ; }
Hyp: 
function sphereSide ( h , r ) { if ( h < 0 && r < 0 ) return - 1 ; var R = ( ( h * r * Math . sqrt ( 2 ) ) / ( h + Math . sqrt ( 2 ) * r ) ) / 2 ; return R ; }

BLEU: 100.0
Edit Sim: 0


Src: 
char Colour_Combination ( string s ) { char temp = s [ 0 ] ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) { if ( temp != s [ i ] ) { if ( ( temp == ' B ' temp == ' G ' ) && ( s [ i ] == ' G ' s [ i ] == ' B ' ) ) temp = ' Y ' ; else if ( ( temp == ' B ' temp == ' Y ' ) && ( s [ i ] == ' Y ' s [ i ] == ' B ' ) ) temp = ' G ' ; else temp = ' B ' ; } } return temp ; }
Ref: 
function Colour_Combination ( s ) { let temp = s [ 0 ] ; for ( let i = 1 ; i < s . length ; i ++ ) { if ( temp != s [ i ] ) { if ( ( temp == ' ' temp == ' ' ) && ( s [ i ] == ' ' s [ i ] == ' ' ) ) temp = ' ' ; else if ( ( temp == ' ' temp == ' ' ) && ( s [ i ] == ' ' s [ i ] == ' ' ) ) temp = ' ' ; else temp = ' ' ; } } return temp ; }
Hyp: 
function Colour_Combination ( s ) { let temp = s [ 0 ] ; for ( let i = 1 ; i < s . length ; i ++ ) { if ( temp != s [ i ] ) { if ( ( temp == ' ' temp == ' ' ) && ( s [ i ] == ' ' ' s [ i ] == ' ' ) ) temp = ' ' ; else if ( ( temp == ' ' temp == ' ' ) && ( s [ i ] == ' ' ' s [ i ] == ' ' ) ) temp = ' ' ; } } return temp ; }

BLEU: 95.29
Edit Sim: 22


Src: 
void line ( double x0 , double y0 ) { double c = 2 * y0 * x0 ; cout << y0 << " x " << " ▁ + ▁ " << x0 << " y ▁ = ▁ " << c ; }
Ref: 
function line ( x0 , y0 ) { var c = parseInt ( 2 * y0 * x0 ) ; document . write ( y0 + " " + " " + x0 + " " + c ) ; }
Hyp: 
function line ( x0 , y0 ) { let c = 2 * y0 * x0 ; document . write ( y0 + " " + x0 + " " + y0 + " " + c ) ; }

BLEU: 76.85
Edit Sim: 22


Src: 
bool isDefeat ( string s1 , string s2 , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( ( s1 [ i ] == '0' && s2 [ i ] == '1' ) || ( s1 [ i ] == '1' && s2 [ i ] == '0' ) ) continue ; else if ( ( s1 [ i ] == '0' && s2 [ i ] == ' Z ' ) || ( s1 [ i ] == ' Z ' && s2 [ i ] == '0' ) ) continue ; else { return true ; } } return false ; }
Ref: 
function isDefeat ( s1 , s2 , n ) { for ( let i = 0 ; i < n ; i ++ ) { if ( ( s1 [ i ] == ' ' && s2 [ i ] == ' ' ) || ( s1 [ i ] == ' ' && s2 [ i ] == ' ' ) ) continue ; else if ( ( s1 [ i ] == ' ' && s2 [ i ] == ' ' ) || ( s1 [ i ] == ' ' && s2 [ i ] == ' ' ) ) continue ; else { return true ; } } return false ; }
Hyp: 
function isDefeat ( s1 , s2 , n ) { for ( let i = 0 ; i < n ; i ++ ) { if ( ( s1 [ i ] == ' ' && s2 [ i ] == ' ' ) || ( s1 [ i ] == ' ' && s2 [ i ] == ' ' ) ) continue ; else if ( ( s1 [ i ] == ' ' && s2 [ i ] == ' ' ) ) continue ; else { return true ; } } return false ; }

BLEU: 83.38
Edit Sim: 42


Src: 
void smallestGreater ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int diff = INT_MAX , closest = -1 ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ i ] < arr [ j ] && arr [ j ] - arr [ i ] < diff ) { diff = arr [ j ] - arr [ i ] ; closest = j ; } } ( closest == -1 ) ? cout << " _ ▁ " : cout << arr [ closest ] << " ▁ " ; } }
Ref: 
function smallestGreater ( arr , n ) { for ( let i = 0 ; i < n ; i ++ ) { let diff = Number . MAX_VALUE ; let closest = - 1 ; for ( let j = 0 ; j < n ; j ++ ) { if ( arr [ i ] < arr [ j ] && arr [ j ] - arr [ i ] < diff ) { diff = arr [ j ] - arr [ i ] ; closest = j ; } } if ( closest == - 1 ) document . write ( " " ) ; else document . write ( arr [ closest ] + " " ) ; } }
Hyp: 
function smallestGreater ( arr , n ) { for ( let i = 0 ; i < n ; i ++ ) { let diff = Number . MAX_VALUE , closest = - 1 ; for ( let j = 0 ; j < n ; j ++ ) { if ( arr [ i ] < arr [ j ] && arr [ j ] - arr [ i ] < diff ) { diff = arr [ j ] - arr [ i ] ; closest = j ; } } ( closest == - 1 ) ? document . write ( arr [ closest ] + " " ) ; } }

BLEU: 86.4
Edit Sim: 39


Src: 
int countP ( int n , int k ) { int dp [ n + 1 ] [ k + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = 0 ; for ( int i = 0 ; i <= k ; i ++ ) dp [ 0 ] [ k ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= i ; j ++ ) if ( j == 1 i == j ) dp [ i ] [ j ] = 1 ; else dp [ i ] [ j ] = j * dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] ; return dp [ n ] [ k ] ; }
Ref: 
function countP ( n , k ) { let dp = new Array ( n + 1 ) ; for ( let i = 0 ; i < n + 1 ; i ++ ) { dp [ i ] = new Array ( k + 1 ) ; for ( let j = 0 ; j < k + 1 ; j ++ ) { dp [ i ] [ j ] = - 1 ; } } for ( let i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = 0 ; for ( let i = 0 ; i <= k ; i ++ ) dp [ 0 ] [ k ] = 0 ; for ( let i = 1 ; i <= n ; i ++ ) for ( let j = 1 ; j <= k ; j ++ ) if ( j == 1 i == j ) dp [ i ] [ j ] = 1 ; else dp [ i ] [ j ] = j * dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] ; return dp [ n ] [ k ] ; }
Hyp: 
function countP ( n , k ) { let dp = Array . from ( Array ( n + 1 ) , ( ) => Array ( k + 1 ) ) ; for ( let i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = 0 ; for ( let i = 0 ; i <= k ; i ++ ) dp [ 0 ] [ k ] = 0 ; for ( let i = 1 ; i <= n ; i ++ ) for ( let j = 1 ; j <= i ; j ++ ) if ( j == 1 i == j ) dp [ i ] [ j ] = 1 ; else dp [ i ] [ j ] = j * dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] ; return dp [ n ] [ k ] ; }

BLEU: 70.07
Edit Sim: 115


Src: 
void print ( int n , int k ) { int rem = 1 ; for ( int i = 0 ; i < k ; i ++ ) { cout << ( 10 * rem ) / n ; rem = ( 10 * rem ) % n ; } }
Ref: 
function print ( n , k ) { let rem = 1 ; let ans = ' ' ; for ( let i = 0 ; i < k ; i ++ ) { ans += Math . floor ( ( ( 10 * rem ) / n ) ) ; rem = ( 10 * rem ) % n ; } document . write ( ans ) }
Hyp: 
function print ( n , k ) { let rem = 1 ; for ( let i = 0 ; i < k ; i ++ ) { document . write ( ( 10 * rem ) / n ) ; rem = parseInt ( ( 10 * rem ) % n ) ; } }

BLEU: 64.81
Edit Sim: 69


Src: 
int minOperations ( int A [ ] , int n ) { if ( n & 1 ) return -1 ; int zeros = 0 , consZeros = 0 , ones = 0 ; for ( int i = 0 ; i < n ; ++ i ) { A [ i ] == 0 ? zeros ++ : ones ++ ; if ( i + 1 < n ) { if ( A [ i ] == 0 && A [ i + 1 ] == 0 ) consZeros ++ ; } } if ( A [ 0 ] == A [ n - 1 ] && A [ 0 ] == 0 ) consZeros ++ ; if ( zeros == ones ) return consZeros ; else return -1 ; }
Ref: 
function minOperations ( A , n ) { if ( ( n & 1 ) > 0 ) return - 1 ; let zeros = 0 , consZeros = 0 , ones = 0 ; for ( let i = 0 ; i < n ; ++ i ) { if ( A [ i ] == 0 ) zeros ++ ; else ones ++ ; if ( i + 1 < n ) { if ( A [ i ] == 0 && A [ i + 1 ] == 0 ) consZeros ++ ; } } if ( A [ 0 ] == A [ n - 1 ] && A [ 0 ] == 0 ) consZeros ++ ; if ( zeros == ones ) return consZeros ; else return - 1 ; }
Hyp: 
function minOperations ( A , n ) { if ( n & 1 ) return - 1 ; var zeros = 0 , consZeros = 0 , ones = 0 ; for ( var i = 0 ; i < n ; ++ i ) { A [ i ] == 0 ? zeros ++ : ones ++ ; if ( i + 1 < n ) { if ( A [ i ] == 0 && A [ i + 1 ] == 0 ) consZeros ++ ; } } if ( A [ 0 ] == A [ n - 1 ] && A [ 0 ] == 0 ) consZeros ++ ; if ( zeros == ones ) return consZeros ; else return - 1 ; }

BLEU: 85.23
Edit Sim: 26


Src: 
int aliquotSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i < n ; i ++ ) if ( n % i == 0 ) sum += i ; return sum ; }
Ref: 
function aliquotSum ( n ) { let sum = 0 ; for ( let i = 1 ; i < n ; i ++ ) if ( n % i == 0 ) sum += i ; return sum ; }
Hyp: 
function aliquotSum ( n ) { let sum = 0 ; for ( let i = 1 ; i < n ; i ++ ) if ( n % i == 0 ) sum += i ; return sum ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int countRectangles ( int radius ) { int rectangles = 0 ; int diameter = 2 * radius ; int diameterSquare = diameter * diameter ; for ( int a = 1 ; a < 2 * radius ; a ++ ) { for ( int b = 1 ; b < 2 * radius ; b ++ ) { int diagonalLengthSquare = ( a * a + b * b ) ; if ( diagonalLengthSquare <= diameterSquare ) { rectangles ++ ; } } } return rectangles ; }
Ref: 
function countRectangles ( radius ) { let rectangles = 0 ; let diameter = 2 * radius ; let diameterSquare = diameter * diameter ; for ( let a = 1 ; a < 2 * radius ; a ++ ) { for ( let b = 1 ; b < 2 * radius ; b ++ ) { let diagonalLengthSquare = ( a * a + b * b ) ; if ( diagonalLengthSquare <= diameterSquare ) { rectangles ++ ; } } } return rectangles ; }
Hyp: 
function countRectangles ( radius ) { let rectangles = 0 ; let diameter = 2 * radius ; let diameterSquare = diameter * diameter ; for ( let a = 1 ; a < 2 * radius ; a ++ ) { for ( let b = 1 ; b < 2 * radius ; b ++ ) { let diagonalLengthSquare = ( a * a + b * b ) ; if ( diagonalLengthSquare <= diameterSquare ) { rectangles ++ ; } } } return rectangles ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int maxSum ( int arr [ ] , int n , int K ) { int maximum = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { int sumk = 0 ; for ( int j = i ; j < n ; j += K ) sumk = sumk + arr [ j ] ; maximum = max ( maximum , sumk ) ; } return maximum ; }
Ref: 
function maxSum ( arr , n , K ) { var maximum = - 1000000000 ; for ( var i = 0 ; i < n ; i ++ ) { var sumk = 0 ; for ( var j = i ; j < n ; j += K ) sumk = sumk + arr [ j ] ; maximum = Math . max ( maximum , sumk ) ; } return maximum ; }
Hyp: 
function maxSum ( arr , n , K ) { let maximum = Number . MIN_VALUE ; for ( let i = 0 ; i < n ; i ++ ) { let sumk = 0 ; for ( let j = i ; j < n ; j += K ) sumk = sumk + arr [ j ] ; maximum = Math . max ( maximum , sumk ) ; } return maximum ; }

BLEU: 80.95
Edit Sim: 29


Src: 
int LIS ( int a [ ] , int n ) { int dp [ N ] , d [ N ] ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { dp [ a [ i ] ] = 1 ; for ( int j = 2 ; j * j <= a [ i ] ; j ++ ) { if ( a [ i ] % j == 0 ) { dp [ a [ i ] ] = max ( dp [ a [ i ] ] , dp [ d [ j ] ] + 1 ) ; dp [ a [ i ] ] = max ( dp [ a [ i ] ] , dp [ d [ a [ i ] / j ] ] + 1 ) ; d [ j ] = a [ i ] ; d [ a [ i ] / j ] = a [ i ] ; } } ans = max ( ans , dp [ a [ i ] ] ) ; d [ a [ i ] ] = a [ i ] ; } return ans ; }
Ref: 
function LIS ( a , n ) { let dp = new Array ( ) ; let d = new Array ( ) ; let ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) { dp [ a [ i ] ] = 1 ; for ( j = 2 ; j * j <= a [ i ] ; j ++ ) { if ( a [ i ] % j == 0 ) { dp [ a [ i ] ] = Math . max ( dp [ a [ i ] ] , dp [ d [ j ] ] + 1 ) ; dp [ a [ i ] ] = Math . max ( dp [ a [ i ] ] , dp [ d [ a [ i ] / j ] ] + 1 ) ; d [ j ] = a [ i ] ; d [ a [ i ] / j ] = a [ i ] ; } } ans = Math . max ( ans , dp [ a [ i ] ] ) ; d [ a [ i ] ] = a [ i ] ; } return ans ; }
Hyp: 
function LIS ( a , n ) { let dp = new Array ( N ) ; let d = new Array ( N ) ; for ( let i = 0 ; i < n ; i ++ ) { dp [ a [ i ] ] = 1 ; for ( let j = 2 ; j * j <= a [ i ] ; j ++ ) { if ( a [ i ] % j == 0 ) { dp [ a [ i ] ] = Math . max ( dp [ a [ i ] ] , dp [ d [ j ] ] + 1 ) ; dp [ a [ i ] ] = Math . max ( dp [ a [ i ] ] , dp [ d [ j ] ] + 1 ) ; d [ j ] = a [ i ] ; d [ a [ i ] / j ] = a [ i ] ; } } ans = Math . max ( ans , dp [ a [ i ] ] ) ; d [ a [ i ] ] = a [ i ] ; } return ans ; }

BLEU: 92.3
Edit Sim: 30


Src: 
int steps ( int N , int M ) { if ( N == 1 ) return 0 ; return M ; return 2 * M + ( N - 3 ) ; }
Ref: 
function steps ( N , M ) { if ( N == 1 ) return 0 ; return M ; return 2 * M + ( N - 3 ) ; }
Hyp: 
function steps ( N , M ) { if ( N == 1 ) return 0 ; return M ; return 2 * M + ( N - 3 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int findUnique ( unsigned int a [ ] , int n , int k ) { int INT_SIZE = 8 * sizeof ( unsigned int ) ; int count [ INT_SIZE ] ; memset ( count , 0 , sizeof ( count ) ) ; for ( int i = 0 ; i < INT_SIZE ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( ( a [ j ] & ( 1 << i ) ) != 0 ) count [ i ] += 1 ; unsigned res = 0 ; for ( int i = 0 ; i < INT_SIZE ; i ++ ) res += ( count [ i ] % k ) * ( 1 << i ) ; return res ; }
Ref: 
function findUnique ( a , n , k ) { let sizeof_let = 4 ; let LET_SIZE = 8 * sizeof_let ; let count = Array . from ( { length : LET_SIZE } , ( _ , i ) => 0 ) ; for ( let i = 0 ; i < LET_SIZE ; i ++ ) for ( let j = 0 ; j < n ; j ++ ) if ( ( a [ j ] & ( 1 << i ) ) != 0 ) count [ i ] += 1 ; let res = 0 ; for ( let i = 0 ; i < LET_SIZE ; i ++ ) res += ( count [ i ] % k ) * ( 1 << i ) ; return res ; }
Hyp: 
function findUnique ( a , n , k ) { var INT_SIZE = 8 * sizeof ( var ) ; var count = new Array ( INT_SIZE ) ; for ( var i = 0 ; i < INT_SIZE ; i ++ ) count [ i ] = 0 ; for ( var i = 0 ; i < INT_SIZE ; i ++ ) for ( var j = 0 ; j < n ; j ++ ) if ( ( a [ j ] & ( 1 << i ) ) != 0 ) count [ i ] += 1 ; var res = 0 ; for ( var i = 0 ; i < INT_SIZE ; i ++ ) res += ( count [ i ] % k ) * ( 1 << i ) ; return res ; }

BLEU: 63.92
Edit Sim: 104


Src: 
string get_maximum ( string s , int a [ ] ) { int n = s . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] - '0' < a [ s [ i ] - '0' ] ) { int j = i ; while ( j < n && ( s [ j ] - '0' <= a [ s [ j ] - '0' ] ) ) { s [ j ] = '0' + a [ s [ j ] - '0' ] ; j ++ ; } return s ; } } return s ; }
Ref: 
function get_maximum ( s , a ) { let n = s . length ; for ( let i = 0 ; i < n ; i ++ ) { if ( s [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) < a [ s [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ] ) { let j = i ; while ( j < n && ( s [ j ] . charCodeAt ( ) - ' ' . charCodeAt ( ) <= a [ s [ j ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ] ) ) { s [ j ] = String . fromCharCode ( ' ' . charCodeAt ( ) + a [ s [ j ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ] ) ; j ++ ; } return s . join ( " " ) ; } } return s . join ( " " ) ; }
Hyp: 
function get_maximum ( s , a ) { let n = s . length ; let arr = s . split ( " " ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] - ' ' ) < a [ s [ i ] - ' ' ] ) { let j = i ; while ( j < n && ( s [ j ] - ' ' . charCodeAt ( ) <= a [ s [ j ] - ' ' . charCodeAt ( ) ] ) ) { s [ j ] = ' ' + a [ s [ j ] - ' ' . charCodeAt ( ) ] ; j ++ ; } } return s ; }

BLEU: 59.17
Edit Sim: 229


Src: 
float sqroot ( float s ) { int pSq = 0 ; int N = 0 ; for ( int i = static_cast < int > ( s ) ; i > 0 ; i -- ) { for ( int j = 1 ; j < i ; j ++ ) { if ( j * j == i ) { pSq = i ; N = j ; break ; } } if ( pSq > 0 ) break ; } float d = s - pSq ; float P = d / ( 2.0 * N ) ; float A = N + P ; float sqrt_of_s = A - ( ( P * P ) / ( 2.0 * A ) ) ; return sqrt_of_s ; }
Ref: 
function sqroot ( s ) { var pSq = 0 ; var N = 0 ; for ( i = parseInt ( s ) ; i > 0 ; i -- ) { for ( j = 1 ; j < i ; j ++ ) { if ( j * j == i ) { pSq = i ; N = j ; break ; } } if ( pSq > 0 ) break ; } var d = s - pSq ; var P = ( d / ( 2.0 * N ) ) ; var A = N + P ; var sqrt_of_s = A - ( ( P * P ) / ( 2.0 * A ) ) ; return sqrt_of_s ; }
Hyp: 
function sqroot ( s ) { let pSq = 0 ; let N = 0 ; for ( let i = 0 ; i > 0 ; i -- ) { for ( let j = 1 ; j < i ; j ++ ) { if ( j * j == i ) { pSq = i ; N = j ; break ; } } if ( pSq > 0 ) break ; } let d = s - pSq ; let P = d / ( 2.0 * N ) ; let A = N + P ; let sqrt_of_s = A - ( ( P * P ) / ( 2.0 * A ) ) ; return sqrt_of_s ; }

BLEU: 78.06
Edit Sim: 39


Src: 
void idstrt ( double a1 , double b1 , double c1 , double a2 , double b2 , double c2 ) { if ( ( a1 / a2 == b1 / b2 ) && ( a1 / a2 == c1 / c2 ) && ( b1 / b2 == c1 / c2 ) ) cout << " The ▁ given ▁ straight " << " ▁ lines ▁ are ▁ identical " << endl ; else cout << " The ▁ given ▁ straight " << " ▁ lines ▁ are ▁ not ▁ identical " << endl ; }
Ref: 
function idstrt ( a1 , b1 , c1 , a2 , b2 , c2 ) { if ( ( a1 / a2 == b1 / b2 ) && ( a1 / a2 == c1 / c2 ) && ( b1 / b2 == c1 / c2 ) ) document . write ( " " + " " ) ; else document . write ( " " + " " ) ; }
Hyp: 
function idstrt ( a1 , b1 , c1 , a2 , b2 , c2 ) { if ( ( a1 / a2 == b1 / b2 ) && ( a1 / a2 == c1 / c2 ) && ( b1 / b2 == c1 / c2 ) ) document . write ( " " + " " ) ; else document . write ( " " + " " ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
void printAP ( int a , int d , int n ) { int curr_term ; curr_term = a ; for ( int i = 1 ; i <= n ; i ++ ) { cout << curr_term << " ▁ " ; curr_term = curr_term + d ; } }
Ref: 
function printAP ( a , d , n ) { let curr_term ; curr_term = a ; for ( let i = 1 ; i <= n ; i ++ ) { document . write ( curr_term + " " ) ; curr_term = curr_term + d ; } }
Hyp: 
function printAP ( a , d , n ) { let curr_term ; curr_term = a ; for ( let i = 1 ; i <= n ; i ++ ) { document . write ( curr_term + " " ) ; curr_term = curr_term + d ; } }

BLEU: 100.0
Edit Sim: 0


Src: 
void printRoots ( long a , long b , long c ) { cout << 1 << " , ▁ " << c / ( a * 1.0 ) ; }
Ref: 
function printRoots ( a , b , c ) { document . write ( 1 + " " + c / ( a * 1.0 ) ) ; }
Hyp: 
function printRoots ( a , b , c ) { document . write ( " " + c / ( a * 1.0 ) ) ; }

BLEU: 87.33
Edit Sim: 4


Src: 
int countIntervals ( int arr [ ] [ 2 ] , int V , int N ) { int min = INT_MAX ; int max = INT_MIN ; int li , ri ; int freq [ MAX_VAL ] ; for ( int i = 0 ; i < N ; i ++ ) { li = arr [ i ] [ 0 ] ; freq [ li ] = freq [ li ] + 1 ; ri = arr [ i ] [ 1 ] ; freq [ ri + 1 ] = freq [ ri + 1 ] - 1 ; if ( li < min ) min = li ; if ( ri > max ) max = ri ; } for ( int i = min ; i <= max ; i ++ ) freq [ i ] = freq [ i ] + freq [ i - 1 ] ; return freq [ V ] ; }
Ref: 
function countIntervals ( arr , V , N ) { let min = Number . MAX_VALUE , max = Number . MIN_VALUE ; let li , ri ; let freq = new Array ( MAX_VAL ) ; freq . fill ( 0 ) ; for ( let i = 0 ; i < N ; i ++ ) { li = arr [ i ] [ 0 ] ; freq [ li ] = freq [ li ] + 1 ; ri = arr [ i ] [ 1 ] ; freq [ ri + 1 ] = freq [ ri + 1 ] - 1 ; if ( li < min ) min = li ; if ( ri > max ) max = ri ; } for ( let i = min ; i <= max ; i ++ ) freq [ i ] = freq [ i ] + freq [ i - 1 ] ; return freq [ V ] ; }
Hyp: 
function countIntervals ( arr , V , N ) { let min = + 2147483647 ; let max = - 2147483648 ; let li , ri ; let freq = new Array ( MAX_VAL ) ; for ( let i = 0 ; i < N ; i ++ ) { li = arr [ i ] [ 0 ] ; freq [ li ] = freq [ li ] + 1 ; ri = arr [ i ] [ 1 ] ; freq [ ri + 1 ] = freq [ ri + 1 ] - 1 ; if ( li < min ) min = li ; if ( ri > max ) max = ri ; } for ( let i = min ; i <= max ; i ++ ) freq [ i ] = freq [ i ] + freq [ i - 1 ] ; return freq [ V ] ; }

BLEU: 89.76
Edit Sim: 57


Src: 
int subset ( int ar [ ] , int n ) { int res = 0 ; sort ( ar , ar + n ) ; for ( int i = 0 ; i < n ; i ++ ) { int count = 1 ; for ( ; i < n - 1 ; i ++ ) { if ( ar [ i ] == ar [ i + 1 ] ) count ++ ; else break ; } res = max ( res , count ) ; } return res ; }
Ref: 
function subset ( ar , n ) { let res = 0 ; ar . sort ( ) ; for ( let i = 0 ; i < n ; i ++ ) { let count = 1 ; for ( ; i < n - 1 ; i ++ ) { if ( ar [ i ] == ar [ i + 1 ] ) count ++ ; else break ; } res = Math . max ( res , count ) ; } return res ; }
Hyp: 
function subset ( ar , n ) { let res = 0 ; ar . sort ( ( a , b ) => a - b ) ; for ( let i = 0 ; i < n ; i ++ ) { let count = 1 ; for ( let i = n - 1 ; i ++ ) { if ( ar [ i ] == ar [ i + 1 ] ) count ++ ; else break ; } res = Math . max ( res , count ) ; } return res ; }

BLEU: 84.79
Edit Sim: 23


Src: 
int leastValue ( int P , int A , int N , int a [ ] ) { int ans = -1 ; float tmp = ( float ) INFINITY ; for ( int i = 0 ; i < N ; i ++ ) { float t = P - a [ i ] * 0.006 ; if ( abs ( t - A ) < tmp ) { tmp = abs ( t - A ) ; ans = i ; } } return a [ ans ] ; }
Ref: 
function leastValue ( P , A , N , a ) { let ans = - 1 ; let tmp = Number . MAX_VALUE ; for ( let i = 0 ; i < N ; i ++ ) { let t = ( P - a [ i ] * 0.006 ) ; if ( Math . abs ( t - A ) < tmp ) { tmp = Math . abs ( t - A ) ; ans = i ; } } return a [ ans ] ; }
Hyp: 
function leastValue ( P , A , N , a ) { let ans = - 1 ; let tmp = ( float ) INFINITY ; for ( let i = 0 ; i < N ; i ++ ) { let t = P - a [ i ] * 0.006 ; if ( Math . abs ( t - A ) < tmp ) { tmp = Math . abs ( t - A ) ; ans = i ; } } return a [ ans ] ; }

BLEU: 90.26
Edit Sim: 21


Src: 
bool isLucky ( int n ) { bool arr [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) arr [ i ] = false ; while ( n > 0 ) { int digit = n % 10 ; if ( arr [ digit ] ) return false ; arr [ digit ] = true ; n = n / 10 ; } return true ; }
Ref: 
function isLucky ( n ) { var arr = Array ( 10 ) . fill ( 0 ) ; for ( var i = 0 ; i < 10 ; i ++ ) arr [ i ] = false ; while ( n > 0 ) { var digit = n % 10 ; if ( arr [ digit ] ) return false ; arr [ digit ] = true ; n = parseInt ( n / 10 ) ; } return true ; }
Hyp: 
function isLucky ( n ) { let arr = new Array ( 10 ) ; for ( let i = 0 ; i < 10 ; i ++ ) arr [ i ] = false ; while ( n > 0 ) { let digit = n % 10 ; if ( arr [ digit ] ) return false ; arr [ digit ] = true ; n = Math . floor ( n / 10 ) ; } return true ; }

BLEU: 79.68
Edit Sim: 37


Src: 
int countSubsequences ( string s ) { int aCount = 0 ; int bCount = 0 ; int cCount = 0 ; for ( unsigned int i = 0 ; i < s . size ( ) ; i ++ ) { if ( s [ i ] == ' a ' ) aCount = ( 1 + 2 * aCount ) ; else if ( s [ i ] == ' b ' ) bCount = ( aCount + 2 * bCount ) ; else if ( s [ i ] == ' c ' ) cCount = ( bCount + 2 * cCount ) ; } return cCount ; }
Ref: 
function countSubsequences ( s ) { let aCount = 0 ; let bCount = 0 ; let cCount = 0 ; for ( let i = 0 ; i < s . length ; i ++ ) { if ( s [ i ] == ' ' ) aCount = ( 1 + 2 * aCount ) ; else if ( s [ i ] == ' ' ) bCount = ( aCount + 2 * bCount ) ; else if ( s [ i ] == ' ' ) cCount = ( bCount + 2 * cCount ) ; } return cCount ; }
Hyp: 
function countSubsequences ( s ) { var aCount = 0 ; var bCount = 0 ; var cCount = 0 ; for ( var i = 0 ; i < s . length ; i ++ ) { if ( s [ i ] == ' ' ) aCount = ( 1 + 2 * aCount ) ; else if ( s [ i ] == ' ' ) bCount = ( aCount + 2 * bCount ) ; else if ( s [ i ] == ' ' ) cCount = ( bCount + 2 * cCount ) ; } return cCount ; }

BLEU: 90.28
Edit Sim: 12


Src: 
bool isPrime ( int p ) { long long checkNumber = pow ( 2 , p ) - 1 ; long long nextval = 4 % checkNumber ; for ( int i = 1 ; i < p - 1 ; i ++ ) nextval = ( nextval * nextval - 2 ) % checkNumber ; return ( nextval == 0 ) ; }
Ref: 
function isPrime ( p ) { let checkNumber = Math . pow ( 2 , p ) - 1 ; let nextval = 4 % checkNumber ; for ( let i = 1 ; i < p - 1 ; i ++ ) nextval = ( nextval * nextval - 2 ) % checkNumber ; return ( nextval == 0 ) ; }
Hyp: 
function isPrime ( p ) { let checkNumber = Math . pow ( 2 , p ) - 1 ; let nextval = 4 % checkNumber ; for ( let i = 1 ; i < p - 1 ; i ++ ) nextval = ( nextval * nextval - 2 ) % checkNumber ; return ( nextval == 0 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int power ( int x , unsigned int y , int p ) { int res = 1 ; x = x % p ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; }
Ref: 
function power ( x , y , p ) { let res = 1 ; x = x % p ; while ( y > 0 ) { if ( y % 2 == 1 ) { res = ( res * x ) % p ; } x = ( x * x ) % p ; } return res ; }
Hyp: 
function power ( x , y , p ) { let res = 1 ; x = x % p ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; }

BLEU: 84.82
Edit Sim: 10


Src: 
void printClosest ( int arr [ ] , int n , int x ) { int res_l , res_r ; int l = 0 , r = n - 1 , diff = INT_MAX ; while ( r > l ) { if ( abs ( arr [ l ] + arr [ r ] - x ) < diff ) { res_l = l ; res_r = r ; diff = abs ( arr [ l ] + arr [ r ] - x ) ; } if ( arr [ l ] + arr [ r ] > x ) r -- ; else l ++ ; } cout << " ▁ The ▁ closest ▁ pair ▁ is ▁ " << arr [ res_l ] << " ▁ and ▁ " << arr [ res_r ] ; }
Ref: 
function printClosest ( arr , n , x ) { let res_l = 0 , res_r = 0 ; let l = 0 , r = n - 1 , diff = Number . MAX_VALUE ; while ( r > l ) { if ( Math . abs ( arr [ l ] + arr [ r ] - x ) < diff ) { res_l = l ; res_r = r ; diff = Math . abs ( arr [ l ] + arr [ r ] - x ) ; } if ( arr [ l ] + arr [ r ] > x ) r -- ; else l ++ ; } document . write ( " " + arr [ res_l ] + " " + arr [ res_r ] ) ; }
Hyp: 
function printClosest ( arr , n , x ) { let res_l , res_r ; let l = 0 , r = n - 1 , diff = Number . MAX_VALUE ; while ( r > l ) { if ( Math . abs ( arr [ l ] + arr [ r ] - x ) < diff ) { res_l = l ; res_r = r ; diff = Math . abs ( arr [ l ] + arr [ r ] - x ) ; } if ( arr [ l ] + arr [ r ] > x ) r -- ; else l ++ ; } document . write ( " " + arr [ res_l ] + " " + arr [ res_r ] ) ; }

BLEU: 95.0
Edit Sim: 8


Src: 
int CountCharacters ( string str , int k ) { int cnt = 0 ; int len = str . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { if ( str [ i ] < k ) cnt ++ ; } return cnt ; }
Ref: 
function CountCharacters ( str , k ) { let cnt = 0 ; let len = str . length ; for ( let i = 0 ; i < len ; i ++ ) { if ( str [ i ] . charCodeAt ( 0 ) < k ) cnt ++ ; } return cnt ; }
Hyp: 
function CountCharacters ( str , k ) { let cnt = 0 ; let len = str . length ; for ( let i = 0 ; i < len ; i ++ ) { if ( str [ i ] < k ) cnt ++ ; } return cnt ; }

BLEU: 88.12
Edit Sim: 19


Src: 
bool canTakeDown ( int bishopX , int bishopY , int pawnX , int pawnY ) { if ( pawnX - bishopX == pawnY - bishopY ) return true ; else if ( - pawnX + bishopX == pawnY - bishopY ) return true ; else return false ; }
Ref: 
function canTakeDown ( bishopX , bishopY , pawnX , pawnY ) { if ( pawnX - bishopX == pawnY - bishopY ) return true ; else if ( - pawnX + bishopX == pawnY - bishopY ) return true ; else return false ; }
Hyp: 
function canTakeDown ( bishopX , bishopY , pawnX , pawnY ) { if ( pawnX - bishopX == pawnY - bishopY ) return true ; else if ( - pawnX + bishopX == pawnY - bishopY ) return true ; else return false ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int centeredIcosahedralNum ( int n ) { return ( 2 * n + 1 ) * ( 5 * n * n + 5 * n + 3 ) / 3 ; }
Ref: 
function centeredIcosahedralNum ( n ) { return parseInt ( ( 2 * n + 1 ) * ( 5 * n * n + 5 * n + 3 ) / 3 ) ; }
Hyp: 
function centeredIcosahedralNum ( n ) { return ( 2 * n + 1 ) * ( 5 * n * n + 5 * n + 3 ) / 3 ; }

BLEU: 82.7
Edit Sim: 13


Src: 
float findRadiusOfcircumcircle ( float n , float a ) { if ( n < 0 a < 0 ) return -1 ; float radius = a / sqrt ( 2 - ( 2 * cos ( 360 / n ) ) ) ; return radius ; }
Ref: 
function findRadiusOfcircumcircle ( n , a ) { if ( n < 0 a < 0 ) return - 1 ; var radius = ( a / Math . sqrt ( 2 - ( 2 * Math . cos ( 360 / n ) ) ) ) ; return radius ; }
Hyp: 
function findRadiusOfcircumcircle ( n , a ) { if ( n < 0 a < 0 ) return - 1 ; var radius = a / Math . sqrt ( 2 - ( 2 * Math . cos ( 360 / n ) ) ) ; return radius ; }

BLEU: 93.09
Edit Sim: 4


Src: 
void solve ( int A , int B ) { int count = 0 ; for ( int i = 0 ; i < 32 ; i ++ ) { if ( ( ( A >> i ) & 1 ) != ( ( B >> i ) & 1 ) ) { count ++ ; } } cout << " Number ▁ of ▁ different ▁ bits ▁ : ▁ " << count << endl ; }
Ref: 
function solve ( A , B ) { var count = 0 ; for ( i = 0 ; i < 32 ; i ++ ) { if ( ( ( A >> i ) & 1 ) != ( ( B >> i ) & 1 ) ) { count ++ ; } } document . write ( " " + count ) ; }
Hyp: 
function solve ( A , B ) { let count = 0 ; for ( let i = 0 ; i < 32 ; i ++ ) { if ( ( ( A >> i ) & 1 ) != ( ( B >> i ) & 1 ) ) { count ++ ; } } document . write ( " " + count + " " ) ; }

BLEU: 86.1
Edit Sim: 13


Src: 
int centered_pentagonal_Num ( int n ) { return ( 5 * n * n - 5 * n + 2 ) / 2 ; }
Ref: 
function centered_pentagonal_Num ( n ) { return ( 5 * n * n - 5 * n + 2 ) / 2 ; }
Hyp: 
function centered_pentagonal_Num ( n ) { return ( 5 * n * n - 5 * n + 2 ) / 2 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
string check ( long int k , int d0 , int d1 ) { long int s = ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 + ( 8 * ( d0 + d1 ) ) % 10 + ( 6 * ( d0 + d1 ) ) % 10 ; int a = ( k - 3 ) % 4 ; int x ; switch ( a ) { case 0 : x = 0 ; break ; case 1 : x = ( 2 * ( d0 + d1 ) ) % 10 ; break ; case 2 : x = ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 ; break ; case 3 : x = ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 + ( 8 * ( d0 + d1 ) ) % 10 ; break ; } long int sum = d0 + d1 + ( ( k - 3 ) / 4 ) * s + x ; if ( sum % 3 == 0 ) return " YES " ; return " NO " ; }
Ref: 
function check ( k , d0 , d1 ) { let s = ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 + ( 8 * ( d0 + d1 ) ) % 10 + ( 6 * ( d0 + d1 ) ) % 10 ; let a = ( k - 3 ) % 4 ; let x ; switch ( a ) { case 0 : x = 0 ; break ; case 1 : x = ( 2 * ( d0 + d1 ) ) % 10 ; break ; case 2 : x = ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 ; break ; case 3 : x = ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 + ( 8 * ( d0 + d1 ) ) % 10 ; break ; } let sum = d0 + d1 + parseInt ( ( k - 3 ) / 4 ) * s + x ; if ( sum % 3 == 0 ) return " " ; return " " ; }
Hyp: 
function check ( k , d0 , d1 ) { let s = ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 + ( 8 * ( d0 + d1 ) ) % 10 ; let a = parseInt ( k - 3 ) % 4 ; let x ; switch ( a ) { case 0 : x = 0 ; break ; case 1 : x = ( 2 * ( d0 + d1 ) ) % 10 ; break ; case 2 : x = ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 + ( 8 * ( d0 + d1 ) ) % 10 ; break ; } let sum = d0 + d1 + ( ( k - 3 ) / 4 ) * s + x ; if ( sum % 3 == 0 ) return " " ; return " " ; }

BLEU: 77.2
Edit Sim: 115


Src: 
void printGroups ( int n ) { int x = 1 ; int y = n * n ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n / 2 ; j ++ ) { cout << " { ▁ " << x << " , ▁ " << y << " } ▁ " ; x ++ ; y -- ; } cout << endl ; } }
Ref: 
function prletGroups ( n ) { let x = 1 ; let y = n * n ; for ( let i = 1 ; i <= n ; i ++ ) { for ( let j = 1 ; j <= n / 2 ; j ++ ) { document . write ( " " + x + " " + y + " " ) ; x ++ ; y -- ; } document . write ( " " ) ; } }
Hyp: 
function printGroups ( n ) { let x = 1 ; let y = n * n ; for ( let i = 1 ; i <= n ; i ++ ) { for ( let j = 1 ; j <= n / 2 ; j ++ ) { document . write ( " " + x + " " + y + " " ) ; x ++ ; y -- ; } document . write ( " " ) ; } }

BLEU: 97.92
Edit Sim: 2


Src: 
long largestCoprime ( long long N ) { if ( N == 6 ) return 1 ; else if ( N % 4 == 0 ) return ( N / 2 ) - 1 ; else if ( N % 2 == 0 ) return ( N / 2 ) - 2 ; else return ( ( N - 1 ) / 2 ) ; }
Ref: 
function largestCoprime ( N ) { if ( N == 6 ) return 1 ; else if ( N % 4 == 0 ) return ( N / 2 ) - 1 ; else if ( N % 2 == 0 ) return ( N / 2 ) - 2 ; else return ( ( N - 1 ) / 2 ) ; }
Hyp: 
function largestCoprime ( N ) { if ( N == 6 ) return 1 ; else if ( N % 4 == 0 ) return ( N / 2 ) - 1 ; else if ( N % 2 == 0 ) return ( N / 2 ) - 2 ; else return ( ( N - 1 ) / 2 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
bool areChractersUnique ( string str ) { int checker = 0 ; for ( int i = 0 ; i < str . length ( ) ; ++ i ) { int val = ( str [ i ] - ' a ' ) ; if ( ( checker & ( 1 << val ) ) > 0 ) return false ; checker |= ( 1 << val ) ; } return true ; }
Ref: 
function areChractersUnique ( str ) { let checker = 0 ; for ( let i = 0 ; i < str . length ; ++ i ) { let val = ( str [ i ] - ' ' ) ; if ( ( checker & ( 1 << val ) ) > 0 ) return false ; checker |= ( 1 << val ) ; } return true ; }
Hyp: 
function areChractersUnique ( str ) { var checker = 0 ; for ( var i = 0 ; i < str . length ; ++ i ) { var val = ( str [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ) ; if ( ( checker & ( 1 << val ) ) > 0 ) return false ; checker |= ( 1 << val ) ; } return true ; }

BLEU: 75.96
Edit Sim: 43


Src: 
int NumberOfSolutions ( int a , int b , int c , int d ) { int ans = 0 ; for ( int i = a ; i <= b ; i ++ ) if ( d >= max ( c , i + 1 ) ) ans += d - max ( c , i + 1 ) + 1 ; return ans ; }
Ref: 
function NumberOfSolutions ( a , b , c , d ) { let ans = 0 ; for ( let i = a ; i <= b ; i ++ ) if ( d >= Math . max ( c , i + 1 ) ) ans += d - Math . max ( c , i + 1 ) + 1 ; return ans ; }
Hyp: 
function NumberOfSolutions ( a , b , c , d ) { let ans = 0 ; for ( let i = a ; i <= b ; i ++ ) if ( d >= Math . max ( c , i + 1 ) ) ans += d - Math . max ( c , i + 1 ) + 1 ; return ans ; }

BLEU: 100.0
Edit Sim: 0


Src: 
bool allBitsSetInTheGivenRange ( unsigned int n , unsigned int l , unsigned int r ) { int num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ; int new_num = n & num ; if ( new_num == 0 ) return true ; return false ; }
Ref: 
function allBitsSetInTheGivenRange ( n , l , r ) { let num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ; let new_num = n & num ; if ( new_num == 0 ) return true ; return false ; }
Hyp: 
function allBitsSetInTheGivenRange ( n , l , r ) { var num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ; var new_num = n & num ; if ( new_num == 0 ) return true ; return false ; }

BLEU: 90.97
Edit Sim: 6


Src: 
void findNumbers ( int n , int d ) { for ( int i = 0 ; i < n - 2 ; i ++ ) cout << "1" << " ▁ " ; cout << "2" << " ▁ " ; cout << n + d << endl ; }
Ref: 
function findNumbers ( n , d ) { for ( let i = 0 ; i < n - 2 ; i ++ ) document . write ( " " + " " ) ; document . write ( " " + " " ) ; document . write ( n + d ) ; }
Hyp: 
function findNumbers ( n , d ) { for ( let i = 0 ; i < n - 2 ; i ++ ) document . write ( " " + " " ) ; document . write ( n + d + " " ) ; }

BLEU: 81.42
Edit Sim: 31


Src: 
bool getParity ( unsigned int n ) { bool parity = 0 ; while ( n ) { parity = ! parity ; n = n & ( n - 1 ) ; } return parity ; }
Ref: 
function getParity ( n ) { var parity = false ; while ( n != 0 ) { parity = ! parity ; n = n & ( n - 1 ) ; } return parity ; }
Hyp: 
function getParity ( n ) { let parity = 0 ; while ( n ) { parity = ! parity ; n = n & ( n - 1 ) ; } return parity ; }

BLEU: 77.74
Edit Sim: 13


Src: 
int countDigit ( long long n ) { if ( n / 10 == 0 ) return 1 ; return 1 + countDigit ( n / 10 ) ; }
Ref: 
function countDigit ( n ) { if ( n / 10 == 0 ) return 1 ; return 1 + countDigit ( parseInt ( n / 10 ) ) ; }
Hyp: 
function countDigit ( n ) { if ( n / 10 == 0 ) return 1 ; return 1 + countDigit ( parseInt ( n / 10 ) ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int pairAndSum ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) ans += arr [ i ] & arr [ j ] ; return ans ; }
Ref: 
function pairAndSum ( arr , n ) { for ( let i = 0 ; i < n ; i ++ ) for ( let j = i + 1 ; j < n ; j ++ ) ans += arr [ i ] & arr [ j ] ; return ans ; }
Hyp: 
function pairAndSum ( arr , n ) { for ( let i = 0 ; i < n ; i ++ ) for ( let j = i + 1 ; j < n ; j ++ ) ans += arr [ i ] & arr [ j ] ; return ans ; }

BLEU: 100.0
Edit Sim: 0


Src: 
void halfsquare ( int n , int x , int y ) { int half = n / 2 ; if ( ( half == x half == x - 1 ) && ( half == y half == y - 1 ) ) cout << " NO " << endl ; else cout << " YES " << endl ; }
Ref: 
function halfsquare ( n , x , y ) { let half = n / 2 ; if ( ( half == x half == x - 1 ) && ( half == y half == y - 1 ) ) document . write ( " " ) ; else document . write ( " " ) ; }
Hyp: 
function halfsquare ( n , x , y ) { let half = parseInt ( n / 2 ) ; if ( ( half == x half == x - 1 ) && ( half == y half == y - 1 ) ) document . write ( " " ) ; else document . write ( " " ) ; }

BLEU: 90.09
Edit Sim: 13


Src: 
bool canBeSumofConsec ( unsigned int n ) { return ( ( n & ( n - 1 ) ) && n ) ; }
Ref: 
function canBeSumofConsec ( n ) { return ( ( ( n & ( n - 1 ) ) != 0 ) && n != 0 ) ; }
Hyp: 
function canBeSumofConsec ( n ) { return ( ( n & ( n - 1 ) ) && n ) ; }

BLEU: 66.23
Edit Sim: 14


Src: 
int optimalStrategyOfGame ( int * arr , int n ) { int table [ n ] [ n ] ; for ( int gap = 0 ; gap < n ; ++ gap ) { for ( int i = 0 , j = gap ; j < n ; ++ i , ++ j ) { int x = ( ( i + 2 ) <= j ) ? table [ i + 2 ] [ j ] : 0 ; int y = ( ( i + 1 ) <= ( j - 1 ) ) ? table [ i + 1 ] [ j - 1 ] : 0 ; int z = ( i <= ( j - 2 ) ) ? table [ i ] [ j - 2 ] : 0 ; table [ i ] [ j ] = max ( arr [ i ] + min ( x , y ) , arr [ j ] + min ( y , z ) ) ; } } return table [ 0 ] [ n - 1 ] ; }
Ref: 
function optimalStrategyOfGame ( arr , n ) { let table = new Array ( n ) ; let gap , i , j , x , y , z ; for ( let d = 0 ; d < n ; d ++ ) { table [ d ] = new Array ( n ) ; } for ( gap = 0 ; gap < n ; ++ gap ) { for ( i = 0 , j = gap ; j < n ; ++ i , ++ j ) { x = ( ( i + 2 ) <= j ) ? table [ i + 2 ] [ j ] : 0 ; y = ( ( i + 1 ) <= ( j - 1 ) ) ? table [ i + 1 ] [ j - 1 ] : 0 ; z = ( i <= ( j - 2 ) ) ? table [ i ] [ j - 2 ] : 0 ; table [ i ] [ j ] = Math . max ( arr [ i ] + Math . min ( x , y ) , arr [ j ] + Math . min ( y , z ) ) ; } } return table [ 0 ] [ n - 1 ] ; }
Hyp: 
function optimalStrategyOfGame ( arr , n ) { let table = new Array ( n ) ; for ( let gap = 0 ; gap < n ; ++ gap ) { for ( let i = 0 , j = gap ; j < n ; ++ i , ++ j ) { let x = ( ( i + 2 ) <= j ) ? table [ i + 2 ] [ j ] : 0 ; let y = ( ( i + 1 ) <= ( j - 1 ) ) ? table [ i + 1 ] [ j - 1 ] : 0 ; let z = ( i <= ( j - 2 ) ) ? table [ i ] [ j - 2 ] : 0 ; table [ i ] [ j ] = Math . max ( arr [ i ] + min ( x , y ) , arr [ j ] + min ( y , z ) ) ; } } return table [ 0 ] [ n - 1 ] ; }

BLEU: 74.61
Edit Sim: 125


Src: 
int evenDecimalValue ( string str , int n ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { int decimalValue = 0 ; int powerOf2 = 1 ; for ( int k = i ; k <= j ; k ++ ) { decimalValue += ( ( str [ k ] - '0' ) * powerOf2 ) ; powerOf2 *= 2 ; } if ( decimalValue % 2 == 0 ) result ++ ; } } return result ; }
Ref: 
function evenDecimalValue ( str , n ) { var result = 0 ; for ( var i = 0 ; i < n ; i ++ ) { for ( var j = i ; j < n ; j ++ ) { var decimalValue = 0 ; var powerOf2 = 1 ; for ( var k = i ; k <= j ; k ++ ) { decimalValue += ( ( str [ k ] - ' ' ) * powerOf2 ) ; powerOf2 *= 2 ; } if ( decimalValue % 2 == 0 ) result ++ ; } } return result ; }
Hyp: 
function evenDecimalValue ( str , n ) { let result = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i ; j < n ; j ++ ) { let decimalValue = 0 ; let powerOf2 = 1 ; for ( let k = i ; k <= j ; k ++ ) { decimalValue += ( ( str [ k ] . charCodeAt ( ) - ' ' . charCodeAt ( ) * powerOf2 ) ; powerOf2 *= 2 ; } if ( decimalValue % 2 == 0 ) result ++ ; } } return result ; }

BLEU: 77.26
Edit Sim: 50


Src: 
void alternateSubarray ( bool arr [ ] , int n ) { int len [ n ] ; len [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; -- i ) { if ( arr [ i ] ^ arr [ i + 1 ] == 1 ) len [ i ] = len [ i + 1 ] + 1 ; else len [ i ] = 1 ; } for ( int i = 0 ; i < n ; ++ i ) cout << len [ i ] << " ▁ " ; }
Ref: 
function alternateSubarray ( arr , n ) { let len = new Array ( n ) ; len [ n - 1 ] = 1 ; for ( let i = n - 2 ; i >= 0 ; -- i ) { if ( arr [ i ] ^ arr [ i + 1 ] == 1 ) len [ i ] = len [ i + 1 ] + 1 ; else len [ i ] = 1 ; } for ( let i = 0 ; i < n ; ++ i ) document . write ( len [ i ] + " " ) ; }
Hyp: 
function alternateSubarray ( arr , n ) { var len = new Array ( n ) ; len [ n - 1 ] = 1 ; for ( var i = n - 2 ; i >= 0 ; -- i ) { if ( arr [ i ] ^ arr [ i + 1 ] == 1 ) len [ i ] = len [ i + 1 ] + 1 ; else len [ i ] = 1 ; } for ( var i = 0 ; i < n ; ++ i ) document . write ( len [ i ] + " " ) ; }

BLEU: 93.07
Edit Sim: 9


Src: 
double areaSquare ( double side , double fold ) { double area = side * side ; return area * 1.0 / pow ( 2 , fold ) ; }
Ref: 
function areaSquare ( side , fold ) { var area = side * side ; return ( area * 1.0 ) / ( Math . pow ( 2 , fold ) ) ; }
Hyp: 
function areaSquare ( side , fold ) { let area = side * side ; return area * 1.0 / Math . pow ( 2 , fold ) ; }

BLEU: 64.66
Edit Sim: 11


Src: 
int findMin ( int a [ ] , int n ) { double sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) int x = exp ( sum / n ) ; return x + 1 ; }
Ref: 
function findMin ( a , n ) { var sum = 0 ; for ( i = 0 ; i < n ; i ++ ) sum += Math . log ( a [ i ] ) ; var x = parseInt ( Math . exp ( sum / n ) ) ; return x + 1 ; }
Hyp: 
function findMin ( a , n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum = sum + Math . exp ( sum / n ) ; return x + 1 ; }

BLEU: 58.09
Edit Sim: 51


Src: 
int patternCount ( string str ) { char last = str [ 0 ] ; int i = 1 , counter = 0 ; while ( i < str . size ( ) ) { if ( str [ i ] == '0' && last == '1' ) { while ( str [ i ] == '0' ) i ++ ; if ( str [ i ] == '1' ) counter ++ ; } last = str [ i ] ; i ++ ; } return counter ; }
Ref: 
function patternCount ( str ) { var last = str . charAt ( 0 ) ; var i = 1 , counter = 0 ; while ( i < str . length ) { if ( str . charAt ( i ) == ' ' && last == ' ' ) { while ( str . charAt ( i ) == ' ' ) i ++ ; if ( str . charAt ( i ) == ' ' ) counter ++ ; } last = str . charAt ( i ) ; i ++ ; } return counter ; }
Hyp: 
function patternCount ( str ) { let last = str [ 0 ] ; let i = 1 , counter = 0 ; while ( i < str . length ) { if ( last == ' ' ) { while ( str [ i ] == ' ' ) i ++ ; if ( str [ i ] == ' ' ) counter ++ ; } last = str [ i ] ; i ++ ; } return counter ; }

BLEU: 57.13
Edit Sim: 79


Src: 
int get_last_two_digit ( long long int N ) { if ( N <= 10 ) { ll ans = 0 , fac = 1 ; for ( int i = 1 ; i <= N ; i ++ ) { fac = fac * i ; ans += fac ; } return ans % 100 ; } return 13 ; }
Ref: 
function get_last_two_digit ( N ) { if ( N <= 10 ) { let ans = 0 , fac = 1 ; for ( let i = 1 ; i <= N ; i ++ ) { fac = fac * i ; ans += fac ; } return ans % 100 ; } return 13 ; }
Hyp: 
function get_last_two_digit ( N ) { if ( N <= 10 ) { let ans = 0 , fac = 1 ; for ( let i = 1 ; i <= N ; i ++ ) { fac = fac * i ; ans += fac ; } return ans % 100 ; } return 13 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int Substring ( string s ) { int ans = 1 , temp = 1 ; for ( int i = 1 ; i < s . size ( ) ; i ++ ) { if ( s [ i ] == s [ i - 1 ] ) { ++ temp ; } else { ans = max ( ans , temp ) ; temp = 1 ; } } ans = max ( ans , temp ) ; return ans ; }
Ref: 
function Substring ( s ) { var ans = 1 , temp = 1 ; for ( var i = 1 ; i < s . length ; i ++ ) { if ( s [ i ] == s [ i - 1 ] ) { ++ temp ; } else { ans = Math . max ( ans , temp ) ; temp = 1 ; } } ans = Math . max ( ans , temp ) ; return ans ; }
Hyp: 
function Substring ( s ) { let ans = 1 , temp = 1 ; for ( let i = 1 ; i < s . length ; i ++ ) { if ( s [ i ] == s [ i - 1 ] ) { ++ temp ; } else { ans = Math . max ( ans , temp ) ; temp = 1 ; } } return ans ; }

BLEU: 78.4
Edit Sim: 40


Src: 
int countSymmetric ( unsigned int n ) { if ( n == 0 ) return 1 ; return 1 << ( ( n * ( n + 1 ) ) / 2 ) ; }
Ref: 
function countSymmetric ( n ) { if ( n == 0 ) return 1 ; return 1 << ( ( n * ( n + 1 ) ) / 2 ) ; }
Hyp: 
function countSymmetric ( n ) { if ( n == 0 ) return 1 ; return 1 << ( ( n * ( n + 1 ) ) / 2 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int countNonEmptySubstr ( string str ) { int n = str . length ( ) ; return n * ( n + 1 ) / 2 ; }
Ref: 
function countNonEmptySubstr ( str ) { let n = str . length ; return n * ( n + 1 ) / 2 ; }
Hyp: 
function countNonEmptySubstr ( str ) { let n = str . length ; return n * ( n + 1 ) / 2 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int findIndex ( int a [ ] , int n ) { int res ; ll min_diff = INT_MAX ; ll prod [ n ] ; prod [ 0 ] = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) prod [ i ] = prod [ i - 1 ] * a [ i ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) { ll curr_diff = abs ( ( prod [ n - 1 ] / prod [ i ] ) - prod [ i ] ) ; if ( curr_diff < min_diff ) { min_diff = curr_diff ; res = i ; } } return res ; }
Ref: 
function findIndex ( a , n ) { let res = 0 ; let min_diff = Number . MAX_VALUE ; let prod = new Array ( n ) ; prod [ 0 ] = a [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) prod [ i ] = prod [ i - 1 ] * a [ i ] ; for ( let i = 0 ; i < n - 1 ; i ++ ) { let curr_diff = Math . abs ( parseInt ( prod [ n - 1 ] / prod [ i ] , 10 ) - prod [ i ] ) ; if ( curr_diff < min_diff ) { min_diff = curr_diff ; res = i ; } } return res ; }
Hyp: 
function findIndex ( a , n ) { let res = - 1 ; let min_diff = Number . MAX_VALUE ; let prod = new Array ( n ) ; prod [ 0 ] = a [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) prod [ i ] = prod [ i - 1 ] * a [ i ] ; for ( let i = 0 ; i < n - 1 ; i ++ ) { let curr_diff = Math . abs ( ( prod [ n - 1 ] / prod [ i ] ) - prod [ i ] ; if ( curr_diff < min_diff ) { min_diff = curr_diff ; res = i ; } } return res ; }

BLEU: 92.45
Edit Sim: 19


Src: 
int printMinimumProduct ( int arr [ ] , int n ) { int first_min = min ( arr [ 0 ] , arr [ 1 ] ) ; int second_min = max ( arr [ 0 ] , arr [ 1 ] ) ; for ( int i = 2 ; i < n ; i ++ ) { if ( arr [ i ] < first_min ) { second_min = first_min ; first_min = arr [ i ] ; } else if ( arr [ i ] < second_min ) second_min = arr [ i ] ; } return first_min * second_min ; }
Ref: 
function printMinimumProduct ( arr , n ) { let first_min = Math . min ( arr [ 0 ] , arr [ 1 ] ) ; let second_min = Math . max ( arr [ 0 ] , arr [ 1 ] ) ; for ( let i = 2 ; i < n ; i ++ ) { if ( arr [ i ] < first_min ) { second_min = first_min ; first_min = arr [ i ] ; } else if ( arr [ i ] < second_min ) second_min = arr [ i ] ; } return first_min * second_min ; }
Hyp: 
function printMinimumProduct ( arr , n ) { let first_min = Math . min ( arr [ 0 ] , arr [ 1 ] ) ; let second_min = Math . max ( arr [ 0 ] , arr [ 1 ] ) ; for ( let i = 2 ; i < n ; i ++ ) { if ( arr [ i ] < first_min ) { second_min = first_min ; first_min = arr [ i ] ; } else if ( arr [ i ] < second_min ) second_min = arr [ i ] ; } return first_min * second_min ; }

BLEU: 100.0
Edit Sim: 0


Src: 
void findElements ( int arr [ ] , int n ) { int first = INT_MIN , second = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > first ) { second = first ; first = arr [ i ] ; } else if ( arr [ i ] > second ) second = arr [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] < second ) cout << arr [ i ] << " ▁ " ; }
Ref: 
function findElements ( arr , n ) { let first = Number . MIN_VALUE ; let second = Number . MAX_VALUE ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > first ) { second = first ; first = arr [ i ] ; } else if ( arr [ i ] > second ) second = arr [ i ] ; } for ( let i = 0 ; i < n ; i ++ ) if ( arr [ i ] < second ) document . write ( arr [ i ] + " " ) ; }
Hyp: 
function findElements ( arr , n ) { let first = Number . MAX_VALUE , second = Number . MAX_VALUE ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > first ) { second = first ; first = arr [ i ] ; } else if ( arr [ i ] > second ) second = arr [ i ] ; } for ( let i = 0 ; i < n ; i ++ ) if ( arr [ i ] < second ) document . write ( arr [ i ] + " " ) ; }

BLEU: 96.02
Edit Sim: 7


Src: 
int fib ( int n ) { if ( n <= 1 ) return n ; return fib ( n - 1 ) + fib ( n - 2 ) ; }
Ref: 
function fib ( n ) { if ( n <= 1 ) return n ; return fib ( n - 1 ) + fib ( n - 2 ) ; }
Hyp: 
function fib ( n ) { if ( n <= 1 ) return n ; return fib ( n - 1 ) + fib ( n - 2 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int maxHandshake ( int n ) { return ( n * ( n - 1 ) ) / 2 ; }
Ref: 
function maxHandshake ( n ) { return ( n * ( n - 1 ) ) / 2 ; }
Hyp: 
function maxHandshake ( n ) { return ( n * ( n - 1 ) ) / 2 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int countPoints ( int n , int m , vector < int > a , vector < int > b , int x , int y ) { sort ( a . begin ( ) , a . end ( ) ) ; sort ( b . begin ( ) , b . end ( ) ) ; int j = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { while ( j < m ) { if ( a [ i ] + y < b [ j ] ) break ; if ( b [ j ] >= a [ i ] - x && b [ j ] <= a [ i ] + y ) { count ++ ; j ++ ; break ; } else j ++ ; } } return count ; }
Ref: 
function countPoints ( n , m , a , b , x , y ) { a . sort ( function ( a , b ) { return a - b } ) ; b . sort ( function ( a , b ) { return a - b } ) ; let j = 0 ; let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { while ( j < m ) { if ( a [ i ] + y < b [ j ] ) break ; if ( b [ j ] >= a [ i ] - x && b [ j ] <= a [ i ] + y ) { count ++ ; j ++ ; break ; } else j ++ ; } } return count ; }
Hyp: 
function countPoints ( n , m , a , b , x , y ) { a . set ( a . begin ( ) , a . end ( ) ) ; b . set ( b . begin ( ) , b . end ( ) ) ; let j = 0 ; let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { while ( j < m ) { if ( a [ i ] + y < b [ j ] ) break ; if ( b [ j ] >= a [ i ] - x && b [ j ] <= a [ i ] + y ) { count ++ ; j ++ ; break ; } else j ++ ; } } return count ; }

BLEU: 80.92
Edit Sim: 49


Src: 
void pushZerosToEnd ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] != 0 ) arr [ count ++ ] = arr [ i ] ; while ( count < n ) arr [ count ++ ] = 0 ; }
Ref: 
function pushZerosToEnd ( arr , n ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) if ( arr [ i ] != 0 ) arr [ count ++ ] = arr [ i ] ; while ( count < n ) arr [ count ++ ] = 0 ; }
Hyp: 
function pushZerosToEnd ( arr , n ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) if ( arr [ i ] != 0 ) arr [ count ++ ] = arr [ i ] ; while ( count < n ) arr [ count ++ ] = 0 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
void CalculatePairs ( int a [ ] , int n ) { int cnt_zero = 0 ; int cnt_one = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 == 0 ) cnt_zero += 1 ; else cnt_one += 1 ; } long int total_XOR_pairs = cnt_zero * cnt_one ; long int total_AND_pairs = ( cnt_one ) * ( cnt_one - 1 ) / 2 ; long int total_OR_pairs = cnt_zero * cnt_one + ( cnt_one ) * ( cnt_one - 1 ) / 2 ; cout << " cntXOR ▁ = ▁ " << total_XOR_pairs << endl ; cout << " cntAND ▁ = ▁ " << total_AND_pairs << endl ; cout << " cntOR ▁ = ▁ " << total_OR_pairs << endl ; }
Ref: 
function CalculatePairs ( a , n ) { let cnt_zero = 0 ; let cnt_one = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 == 0 ) cnt_zero += 1 ; else cnt_one += 1 ; } let total_XOR_pairs = cnt_zero * cnt_one ; let total_AND_pairs = ( cnt_one ) * ( cnt_one - 1 ) / 2 ; let total_OR_pairs = cnt_zero * cnt_one + ( cnt_one ) * ( cnt_one - 1 ) / 2 ; document . write ( " " + total_XOR_pairs + " " ) ; document . write ( " " + total_AND_pairs + " " ) ; document . write ( " " + total_OR_pairs + " " ) ; }
Hyp: 
function CalculatePairs ( a , n ) { var cnt_zero = 0 ; var cnt_one = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 == 0 ) cnt_zero += 1 ; else cnt_one += 1 ; } var total_XOR_pairs = cnt_zero * cnt_one ; var total_AND_pairs = ( cnt_one ) * ( cnt_one - 1 ) / 2 ; var total_OR_pairs = cnt_zero * cnt_one + ( cnt_one ) * ( cnt_one - 1 ) / 2 ; document . write ( " " + total_XOR_pairs + " " ) ; document . write ( " " + total_AND_pairs + " " ) ; document . write ( " " + total_OR_pairs ) ; }

BLEU: 85.23
Edit Sim: 24


Src: 
int countOnes ( bool arr [ ] , int low , int high ) { if ( high >= low ) { int mid = low + ( high - low ) / 2 ; if ( ( mid == high arr [ mid + 1 ] == 0 ) && ( arr [ mid ] == 1 ) ) return mid + 1 ; if ( arr [ mid ] == 1 ) return countOnes ( arr , ( mid + 1 ) , high ) ; return countOnes ( arr , low , ( mid - 1 ) ) ; } return 0 ; }
Ref: 
function countOnes ( arr , low , high ) { if ( high >= low ) { let mid = Math . trunc ( low + ( high - low ) / 2 ) ; if ( ( mid == high arr [ mid + 1 ] == 0 ) && ( arr [ mid ] == 1 ) ) return mid + 1 ; if ( arr [ mid ] == 1 ) return countOnes ( arr , ( mid + 1 ) , high ) ; return countOnes ( arr , low , ( mid - 1 ) ) ; } return 0 ; }
Hyp: 
function countOnes ( arr , low , high ) { if ( high >= low ) { let mid = low + ( high - low ) / 2 ; if ( ( mid == high arr [ mid + 1 ] == 0 ) && ( arr [ mid ] == 1 ) ) return mid + 1 ; if ( arr [ mid ] == 1 ) return countOnes ( arr , ( mid + 1 ) , high ) ; return countOnes ( arr , low , ( mid - 1 ) ) ; } return 0 ; }

BLEU: 92.35
Edit Sim: 17


Src: 
int maxEdges ( int N ) { int edges = 0 ; edges = floor ( ( N * N ) / 4 ) ; return edges ; }
Ref: 
function maxEdges ( N ) { var edges = 0 ; edges = Math . floor ( ( N * N ) / 4 ) ; return edges ; }
Hyp: 
function maxEdges ( N ) { let edges = 0 ; edges = Math . floor ( ( N * N ) / 4 ) ; return edges ; }

BLEU: 91.28
Edit Sim: 3


Src: 
int eulerian ( int n , int m ) { if ( m >= n n == 0 ) return 0 ; if ( m == 0 ) return 1 ; return ( n - m ) * eulerian ( n - 1 , m - 1 ) + ( m + 1 ) * eulerian ( n - 1 , m ) ; }
Ref: 
function eulerian ( n , m ) { if ( m >= n n == 0 ) return 0 ; if ( m == 0 ) return 1 ; return ( n - m ) * eulerian ( n - 1 , m - 1 ) + ( m + 1 ) * eulerian ( n - 1 , m ) ; }
Hyp: 
function eulerian ( n , m ) { if ( m >= n n == 0 ) return 0 ; if ( m == 0 ) return 1 ; return ( n - m ) * eulerian ( n - 1 , m - 1 ) + ( m + 1 ) * eulerian ( n - 1 , m ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
void SternSequenceFunc ( vector < int > & BrocotSequence , int n ) { for ( int i = 1 ; BrocotSequence . size ( ) < n ; i ++ ) { int considered_element = BrocotSequence [ i ] ; int precedent = BrocotSequence [ i - 1 ] ; BrocotSequence . push_back ( considered_element + precedent ) ; BrocotSequence . push_back ( considered_element ) ; } for ( int i = 0 ; i < 15 ; ++ i ) cout << BrocotSequence [ i ] << " ▁ " ; }
Ref: 
function SternSequenceFunc ( BrocotSequence , n ) { for ( var i = 1 ; BrocotSequence . length < n ; i ++ ) { var considered_element = BrocotSequence [ i ] ; var precedent = BrocotSequence [ i - 1 ] ; BrocotSequence . push ( considered_element + precedent ) ; BrocotSequence . push ( considered_element ) ; } for ( var i = 0 ; i < 15 ; ++ i ) document . write ( BrocotSequence [ i ] + " " ) ; }
Hyp: 
function SternSequenceFunc ( BrocotSequence , n ) { for ( let i = 1 ; BrocotSequence . size ( ) < n ; i ++ ) { let considered_element = BrocotSequence [ i ] ; let precedent = BrocotSequence [ i - 1 ] ; BrocotSequence . push ( considered_element + precedent ) ; BrocotSequence . push ( considered_element ) ; } for ( let i = 0 ; i < 15 ; ++ i ) document . write ( BrocotSequence [ i ] + " " ) ; }

BLEU: 83.47
Edit Sim: 19


Src: 
int calculateSum ( int n ) { return 2 * ( n * ( n + 1 ) * ( 2 * n + 1 ) / 6 ) + n * ( n + 1 ) / 2 + 2 * ( n ) ; }
Ref: 
function calculateSum ( n ) { return 2 * ( n * ( n + 1 ) * ( 2 * n + 1 ) / 6 ) + n * ( n + 1 ) / 2 + 2 * ( n ) ; }
Hyp: 
function calculateSum ( n ) { return 2 * ( n * ( n + 1 ) * ( 2 * n + 1 ) / 6 ) + n * ( n + 1 ) / 2 + 2 * ( n ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
void circle_equation ( double x1 , double y1 , double r ) { double a = -2 * x1 ; double b = -2 * y1 ; double c = ( r * r ) - ( x1 * x1 ) - ( y1 * y1 ) ; cout << " x ^ 2 ▁ + ▁ ( " << a << " ▁ x ) ▁ + ▁ " ; cout << " y ^ 2 ▁ + ▁ ( " << b << " ▁ y ) ▁ = ▁ " ; cout << c << " . " << endl ; }
Ref: 
function circle_equation ( x1 , y1 , r ) { let a = - 2 * x1 ; let b = - 2 * y1 ; let c = ( r * r ) - ( x1 * x1 ) - ( y1 * y1 ) ; document . write ( " " + a + " " ) ; document . write ( " " + b + " " ) ; document . write ( c + " " ) ; }
Hyp: 
function circle_equation ( x1 , y1 , r ) { let a = - 2 * x1 ; let b = - 2 * y1 ; let c = ( r * r ) - ( x1 * x1 ) - ( y1 * y1 ) ; document . write ( " " + ( a + " " ) + " " ) ; document . write ( " " + b + " " ) ; document . write ( c + " " ) ; }

BLEU: 92.63
Edit Sim: 10


Src: 
bool isEven ( int n ) { return ( n % 2 == 0 ) ; }
Ref: 
function isEven ( n ) { return ( n % 2 == 0 ) ; }
Hyp: 
function isEven ( n ) { return ( n % 2 == 0 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
int findSubArray ( int arr [ ] , int n ) { int sum = 0 ; int maxsize = -1 , startindex ; for ( int i = 0 ; i < n - 1 ; i ++ ) { sum = ( arr [ i ] == 0 ) ? -1 : 1 ; for ( int j = i + 1 ; j < n ; j ++ ) { ( arr [ j ] == 0 ) ? ( sum += -1 ) : ( sum += 1 ) ; if ( sum == 0 && maxsize < j - i + 1 ) { maxsize = j - i + 1 ; startindex = i ; } } } if ( maxsize == -1 ) cout << " No ▁ such ▁ subarray " ; else cout << startindex << " ▁ to ▁ " << startindex + maxsize - 1 ; return maxsize ; }
Ref: 
function findSubArray ( arr , n ) { let sum = 0 ; let maxsize = - 1 , startindex = 0 ; let endindex = 0 ; for ( let i = 0 ; i < n - 1 ; i ++ ) { sum = ( arr [ i ] == 0 ) ? - 1 : 1 ; for ( let j = i + 1 ; j < n ; j ++ ) { if ( arr [ j ] == 0 ) sum += - 1 ; else sum += 1 ; if ( sum == 0 && maxsize < j - i + 1 ) { maxsize = j - i + 1 ; startindex = i ; } } } endindex = startindex + maxsize - 1 ; if ( maxsize == - 1 ) document . write ( " " ) ; else document . write ( startindex + " " + endindex ) ; return maxsize ; }
Hyp: 
function findSubArray ( arr , n ) { sum = 0 ; maxsize = - 1 , startindex ; for ( let i = 0 ; i < n - 1 ; i ++ ) { sum = ( arr [ i ] == 0 ) ? - 1 : 1 ; for ( let j = i + 1 ; j < n ; j ++ ) { ( arr [ j ] == 0 ) ? ( sum += - 1 ) : ( sum += 1 ) ; if ( sum == 0 && maxsize < j - i + 1 ) { maxsize = j - i + 1 ; startindex = i ; } } } if ( maxsize == - 1 ) document . write ( startindex + " " + startindex + maxsize - 1 ) ; return maxsize ; }

BLEU: 75.48
Edit Sim: 122


Src: 
float squarearea ( float a , float b ) { if ( a < 0 b < 0 ) return -1 ; float area = 4 * ( ( pow ( a , 2 ) + pow ( b , 2 ) ) / ( pow ( a , 2 ) * pow ( b , 2 ) ) ) ; return area ; }
Ref: 
function squarearea ( a , b ) { if ( a < 0 b < 0 ) return - 1 ; var area = 4 * ( ( Math . pow ( a , 2 ) + Math . pow ( b , 2 ) ) / ( Math . pow ( a , 2 ) * Math . pow ( b , 2 ) ) ) ; return area ; }
Hyp: 
function squarearea ( a , b ) { if ( a < 0 b < 0 ) return - 1 ; var area = 4 * ( ( Math . pow ( a , 2 ) + Math . pow ( b , 2 ) ) / ( Math . pow ( a , 2 ) * Math . pow ( b , 2 ) ) ) ) ; return area ; }

BLEU: 98.62
Edit Sim: 2


Src: 
int cost ( string str ) { int len = str . length ( ) ; int res = 0 ; for ( int i = 0 , j = len - 1 ; i < j ; i ++ , j -- ) if ( str [ i ] != str [ j ] ) res += min ( str [ i ] , str [ j ] ) - ' a ' + 1 ; return res ; }
Ref: 
function cost ( str ) { let len = str . length ; let res = 0 ; for ( let i = 0 , j = len - 1 ; i < j ; i ++ , j -- ) { if ( str [ i ] != str [ j ] ) { res += Math . min ( str [ i ] . charCodeAt ( ) , str [ j ] . charCodeAt ( ) ) - ' ' . charCodeAt ( ) + 1 ; } } return res ; }
Hyp: 
function cost ( str ) { let len = str . length ; let res = 0 ; for ( let i = 0 , j = len - 1 ; i < j ; i ++ , j -- ) if ( str [ i ] != str [ j ] ) res += Math . min ( str [ i ] , str [ j ] ) - ' ' . charCodeAt ( 0 ) + 1 ; return res ; }

BLEU: 76.79
Edit Sim: 44


Src: 
bool isPossibleToZero ( int a [ ] , int n ) { int even = 0 , odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i & 1 ) odd += a [ i ] ; else even += a [ i ] ; } return ( odd == even ) ; }
Ref: 
function isPossibleToZero ( a , n ) { let even = 0 , odd = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( ( i & 1 ) == 0 ) odd += a [ i ] ; else even += a [ i ] ; } return ( odd == even ) ; }
Hyp: 
function isPossibleToZero ( a , n ) { let even = 0 , odd = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( i & 1 ) odd += a [ i ] ; else even += a [ i ] ; } return ( odd == even ) ; }

BLEU: 91.38
Edit Sim: 9


