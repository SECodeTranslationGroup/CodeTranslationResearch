Src: 
function checkIsAP ( arr , n ) { if ( n == 1 ) return true ; arr . sort ( ( a , b ) => a - b ) ; let d = arr [ 1 ] - arr [ 0 ] ; for ( let i = 2 ; i < n ; i ++ ) if ( arr [ i ] - arr [ i - 1 ] != d ) return false ; return true ; }
Ref: 
function checkIsAP ( $ arr , $ n ) { if ( $ n == 1 ) return true ; sort ( $ arr ) ; $ d = $ arr [ 1 ] - $ arr [ 0 ] ; for ( $ i = 2 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] - $ arr [ $ i - 1 ] != $ d ) return false ; return true ; }
Hyp: 
function checkIsAP ( $ arr , $ n ) { if ( $ n == 1 ) return true ; sort ( $ arr ) ; $ d = $ arr [ 1 ] - $ arr [ 0 ] ; for ( $ i = 2 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] - $ arr [ $ i - 1 ] != $ d ) return false ; return true ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function longestSubArray ( arr , n ) { var isZeroPresent = false ; for ( var i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) { isZeroPresent = true ; break ; } } if ( isZeroPresent ) return n ; return 0 ; }
Ref: 
function longestSubArray ( $ arr , $ n ) { $ isZeroPresent = false ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] == 0 ) { $ isZeroPresent = true ; break ; } } if ( $ isZeroPresent ) return $ n ; return 0 ; }
Hyp: 
function longestSubArray ( $ arr , $ n ) { $ isZeroPresent = false ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] == 0 ) { $ isZeroPresent = true ; break ; } } if ( $ isZeroPresent ) return $ n ; return 0 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function F ( A , B ) { if ( A == 1 ) return ( 4 % B ) ; else { var temp = F ( A - 1 , B ) ; return ( temp * temp ) % B ; } }
Ref: 
function F ( $ A , $ B ) { if ( $ A == 1 ) return ( 4 % $ B ) ; else { $ temp = F ( $ A - 1 , $ B ) ; return ( $ temp * $ temp ) % $ B ; } }
Hyp: 
function F ( $ A , $ B ) { if ( $ A == 1 ) return ( 4 % $ B ) ; else { $ temp = F ( $ A - 1 , $ B ) ; return ( $ temp * $ temp ) % $ B ; } }

BLEU: 100.0
Edit Sim: 0


Src: 
function sentencePalindrome ( str ) { let l = 0 ; let h = str . length - 1 ; str = str . toLowerCase ( ) ; while ( l <= h ) { let getAtl = str [ l ] ; let getAth = str [ h ] ; if ( ! ( getAtl >= ' ' && getAtl <= ' ' ) ) l ++ ; else if ( ! ( getAth >= ' ' && getAth <= ' ' ) ) h -- ; else if ( getAtl == getAth ) { l ++ ; h -- ; } else return false ; } return true ; }
Ref: 
function sentencePalindrome ( $ str ) { $ l = 0 ; $ h = strlen ( $ str ) - 1 ; for ( $ i = 0 ; $ i < $ h ; $ i ++ ) $ str [ $ i ] = strtolower ( $ str [ $ i ] ) ; while ( $ l <= $ h ) { if ( ! ( $ str [ $ l ] >= ' a ' && $ str [ $ l ] <= ' z ' ) ) $ l ++ ; else if ( ! ( $ str [ $ h ] >= ' a ' && $ str [ $ h ] <= ' z ' ) ) $ h -- ; else if ( $ str [ $ l ] == $ str [ $ h ] ) { $ l ++ ; $ h -- ; } else return false ; } return true ; }
Hyp: 
function sentencePalindrome ( $ str ) { $ l = 0 ; $ h = strlen ( $ str ) ; while ( $ l <= $ h ) { $ getAtl = $ str [ $ l ] ; $ getAth = $ str [ $ h ] ; if ( ! ( $ getAtl >= '0' && $ getAtl <= '9' ) ) $ l ++ ; else if ( ! ( $ getAth >= '0' && $ getAth <= '9' ) ) $ h -- ; else if ( $ getAtl == $ getAth ) { $ l ++ ; $ h -- ; } else return false ; } return true ; }

BLEU: 46.99
Edit Sim: 138


Src: 
function Calculate_GST ( org_cost , N_price ) { return ( ( ( N_price - org_cost ) * 100 ) / org_cost ) ; }
Ref: 
function Calculate_GST ( $ org_cost , $ N_price ) { return ( ( ( $ N_price - $ org_cost ) * 100 ) / $ org_cost ) ; }
Hyp: 
function Calculate_GST ( $ org_cost , $ N_price ) { return ( ( ( $ N_price - $ org_cost ) * 100 ) / $ org_cost ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function FindPoints ( x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 ) { var x5 = Math . max ( x1 , x3 ) ; var y5 = Math . max ( y1 , y3 ) ; var x6 = Math . min ( x2 , x4 ) ; var y6 = Math . min ( y2 , y4 ) ; if ( x5 > x6 y5 > y6 ) { document . write ( " " ) ; return ; } document . write ( " " + x5 + " " + y5 + " " ) ; document . write ( " " + x6 + " " + y6 + " " ) ; var x7 = x5 ; var y7 = y6 ; document . write ( " " + x7 + " " + y7 + " " ) ; var x8 = x6 ; var y8 = y5 ; document . write ( " " + x8 + " " + y8 + " " ) ; }
Ref: 
function FindPoints ( $ x1 , $ y1 , $ x2 , $ y2 , $ x3 , $ y3 , $ x4 , $ y4 ) { $ x5 = max ( $ x1 , $ x3 ) ; $ y5 = max ( $ y1 , $ y3 ) ; $ x6 = min ( $ x2 , $ x4 ) ; $ y6 = min ( $ y2 , $ y4 ) ; if ( $ x5 > $ x6 $ y5 > $ y6 ) { echo " No ▁ intersection " ; return ; } echo " ( " . $ x5 . " , " ▁ . ▁ $ y5 ▁ . ▁ " ) " ; echo " ( " . $ x6 . " , " ▁ . ▁ $ y6 ▁ . ▁ " ) " ; $ x7 = $ x5 ; $ y7 = $ y6 ; echo " ( " . $ x7 . " , " ▁ . ▁ $ y7 ▁ . ▁ " ) " ; $ x8 = $ x6 ; $ y8 = $ y5 ; echo " ( " . $ x8 . " , " ▁ . ▁ $ y8 ▁ . ▁ " ) " ; }
Hyp: 
function FindPoints ( $ x1 , $ y1 , $ x2 , $ y2 , $ x3 , $ y3 , $ x4 , $ y4 ) { $ x5 = max ( $ x1 , $ x3 ) ; $ y5 = max ( $ y1 , $ y3 ) ; $ x6 = min ( $ x2 , $ x4 ) ; $ y6 = min ( $ y2 , $ y4 ) ; if ( $ x5 > $ x6 $ y5 > $ y6 ) { echo " No " ; return ; } echo " Yes " ; }

BLEU: 32.42
Edit Sim: 262


Src: 
function maxSum ( mat , n ) { if ( n == 1 ) return mat [ 0 ] [ 0 ] ; let dp = new Array ( n ) ; for ( var i = 0 ; i < dp . length ; i ++ ) { dp [ i ] = new Array ( 2 ) ; } let maxSum = Number . MIN_VALUE , max ; for ( let j = 0 ; j < n ; j ++ ) dp [ n - 1 ] [ j ] = mat [ n - 1 ] [ j ] ; for ( let i = n - 2 ; i >= 0 ; i -- ) { for ( let j = 0 ; j < n ; j ++ ) { max = Number . MIN_VALUE ; if ( ( ( j - 1 ) >= 0 ) && ( max < dp [ i + 1 ] [ j - 1 ] ) ) max = dp [ i + 1 ] [ j - 1 ] ; if ( ( ( j + 1 ) < n ) && ( max < dp [ i + 1 ] [ j + 1 ] ) ) max = dp [ i + 1 ] [ j + 1 ] ; dp [ i ] [ j ] = mat [ i ] [ j ] + max ; } } for ( let j = 0 ; j < n ; j ++ ) if ( maxSum < dp [ 0 ] [ j ] ) maxSum = dp [ 0 ] [ j ] ; return maxSum ; }
Ref: 
function maxSum ( $ mat , $ n ) { if ( $ n == 1 ) return $ mat [ 0 ] [ 0 ] ; $ dp = array ( array ( ) ) ; $ maxSum = PHP_INT_MIN ; $ max ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) $ dp [ $ n - 1 ] [ $ j ] = $ mat [ $ n - 1 ] [ $ j ] ; for ( $ i = $ n - 2 ; $ i >= 0 ; $ i -- ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { $ max = PHP_INT_MIN ; if ( ( ( $ j - 1 ) >= 0 ) and ( $ max < $ dp [ $ i + 1 ] [ $ j - 1 ] ) ) $ max = $ dp [ $ i + 1 ] [ $ j - 1 ] ; if ( ( ( $ j + 1 ) < $ n ) and ( $ max < $ dp [ $ i + 1 ] [ $ j + 1 ] ) ) $ max = $ dp [ $ i + 1 ] [ $ j + 1 ] ; $ dp [ $ i ] [ $ j ] = $ mat [ $ i ] [ $ j ] + $ max ; } } for ( $ j = 0 ; $ j < $ n ; $ j ++ ) if ( $ maxSum < $ dp [ 0 ] [ $ j ] ) $ maxSum = $ dp [ 0 ] [ $ j ] ; return $ maxSum ; }
Hyp: 
function maxSum ( $ mat , $ n ) { if ( $ n == 1 ) return $ mat [ 0 ] [ 0 ] ; $ dp = array ( array ( ) ) ; $ maxSum = PHP_INT_MIN ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) $ dp [ $ n - 1 ] [ $ j ] = $ mat [ $ n - 1 ] [ $ j ] ; for ( $ i = $ n - 2 ; $ i >= 0 ; $ i -- ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { $ max = PHP_INT_MIN ; if ( ( ( $ j - 1 ) >= 0 ) && ( $ max < $ dp [ $ i + 1 ] [ $ j - 1 ] ) ) $ max = $ dp [ $ i + 1 ] [ $ j - 1 ] ; if ( ( ( $ j + 1 ) < $ n ) && ( $ max < $ dp [ $ i + 1 ] [ $ j + 1 ] ) ) $ max = $ dp [ $ i + 1 ] [ $ j + 1 ] ; $ dp [ $ i ] [ $ j ] = $ mat [ $ i ] [ $ j ] + $ max ; } } for ( $ j = 0 ; $ j < $ n ; $ j ++ ) if ( $ maxSum < $ dp [ 0 ] [ $ j ] ) $ maxSum = $ dp [ 0 ] [ $ j ] ; return $ maxSum ; }

BLEU: 97.17
Edit Sim: 14


Src: 
function pell ( n ) { if ( n <= 2 ) return n ; return 2 * pell ( n - 1 ) + pell ( n - 2 ) ; }
Ref: 
function pell ( $ n ) { if ( $ n <= 2 ) return $ n ; return 2 * pell ( $ n - 1 ) + pell ( $ n - 2 ) ; }
Hyp: 
function pell ( $ n ) { if ( $ n <= 2 ) return $ n ; return 2 * pell ( $ n - 1 ) + pell ( $ n - 2 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function testSomeNumbers ( limit , n ) { if ( n < 3 ) return ; for ( let a = 1 ; a <= limit ; a ++ ) for ( let b = a ; b <= limit ; b ++ ) { let pow_sum = ( Math . pow ( a , n ) + Math . pow ( b , n ) ) ; let c = Math . pow ( pow_sum , 1.0 / n ) ; let c_pow = Math . pow ( Math . round ( c ) , n ) ; if ( c_pow == pow_sum ) { document . write ( " " ) ; return ; } } document . write ( " " + " " ) ; }
Ref: 
function testSomeNumbers ( $ limit , $ n ) { if ( $ n < 3 ) for ( $ a = 1 ; $ a <= $ limit ; $ a ++ ) for ( $ b = $ a ; $ b <= $ limit ; $ b ++ ) { $ pow_sum = pow ( $ a , $ n ) + pow ( $ b , $ n ) ; $ c = pow ( $ pow_sum , 1.0 / $ n ) ; $ c_pow = pow ( $ c , $ n ) ; if ( $ c_pow != $ pow_sum ) { echo " Count ▁ example ▁ found " ; return ; } } echo " No ▁ counter ▁ example ▁ within ▁ " . " given ▁ range ▁ and ▁ data " ; }
Hyp: 
function testSomeNumbers ( $ limit , $ n ) { if ( $ n < 3 ) return ; for ( $ a = 1 ; $ a <= $ limit ; $ a ++ ) for ( $ b = $ a ; $ b <= $ limit ; $ b ++ ) { $ pow_sum = ( pow ( $ a , $ n ) + pow ( $ b , $ n ) ) ; $ c = pow ( $ pow_sum , 1.0 / $ n ) ; $ c_pow = pow ( round ( $ c ) , $ n ) ; if ( $ c_pow == $ pow_sum ) { echo " Yes " ; return ; } } echo " No " ; }

BLEU: 76.16
Edit Sim: 110


Src: 
function find3Numbers ( A , arr_size , sum ) { let l , r ; for ( let i = 0 ; i < arr_size - 2 ; i ++ ) { for ( let j = i + 1 ; j < arr_size - 1 ; j ++ ) { for ( let k = j + 1 ; k < arr_size ; k ++ ) { if ( A [ i ] + A [ j ] + A [ k ] == sum ) { document . write ( " " + A [ i ] + " " + A [ j ] + " " + A [ k ] ) ; return true ; } } } } return false ; }
Ref: 
function find3Numbers ( $ A , $ arr_size , $ sum ) { $ l ; $ r ; for ( $ i = 0 ; $ i < $ arr_size - 2 ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ arr_size - 1 ; $ j ++ ) { for ( $ k = $ j + 1 ; $ k < $ arr_size ; $ k ++ ) { if ( $ A [ $ i ] + $ A [ $ j ] + $ A [ $ k ] == $ sum ) { echo " Triplet ▁ is " , " ▁ " , $ A [ $ i ] , " , ▁ " , $ A [ $ j ] , " , ▁ " , $ A [ $ k ] ; return true ; } } } } return false ; }
Hyp: 
function find3Numbers ( $ A , $ arr_size , $ sum ) { $ l ; $ r ; for ( $ i = 0 ; $ i < $ arr_size - 2 ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ arr_size - 1 ; $ j ++ ) { for ( $ k = $ j + 1 ; $ k < $ arr_size ; $ k ++ ) { if ( $ A [ $ i ] + $ A [ $ j ] + $ A [ $ k ] == $ sum ) { echo " A [ $ i ] , " , ▁ " , $ A [ $ j ] , " , ▁ " , $ A [ $ k ] ; return true ; } } } } return false ; }

BLEU: 92.74
Edit Sim: 27


Src: 
function ways ( n ) { var first = 2 ; var second = 3 ; var res = 0 ; for ( i = 3 ; i <= n ; i ++ ) { res = first + second ; first = second ; second = res ; } return res ; }
Ref: 
function ways ( $ n ) { $ first = 2 ; $ second = 3 ; $ res = 0 ; for ( $ i = 3 ; $ i <= $ n ; $ i ++ ) { $ res = $ first + $ second ; $ first = $ second ; $ second = $ res ; } return $ res ; }
Hyp: 
function ways ( $ n ) { $ first = 2 ; $ second = 3 ; $ res = 0 ; for ( $ i = 3 ; $ i <= $ n ; $ i ++ ) { $ res = $ first + $ second ; $ first = $ second ; $ second = $ res ; } return $ res ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function pentdiagonal ( a ) { if ( a < 0 ) return - 1 ; let d = 1.22 * a ; return d ; }
Ref: 
function pentdiagonal ( $ a ) { if ( $ a < 0 ) return -1 ; $ d = 1.22 * $ a ; return $ d ; }
Hyp: 
function pentdiagonal ( $ a ) { if ( $ a < 0 ) return -1 ; $ d = 1.22 * $ a ; return $ d ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function evenNumSubstring ( str ) { let len = str . length ; let count = 0 ; for ( let i = 0 ; i < len ; i ++ ) { let temp = str [ i ] - ' ' ; if ( temp % 2 == 0 ) count += ( i + 1 ) ; } return count ; }
Ref: 
function evenNumSubstring ( $ str ) { $ len = strlen ( $ str ) ; $ count = 0 ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { $ temp = $ str [ $ i ] - '0' ; if ( $ temp % 2 == 0 ) $ count += ( $ i + 1 ) ; } return $ count ; }
Hyp: 
function evenNumSubstring ( $ str ) { $ len = strlen ( $ str ) ; $ count = 0 ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { $ temp = ord ( $ str [ $ i ] ) - ord ( '0' ) ; if ( $ temp % 2 == 0 ) $ count += ( $ i + 1 ) ; } return $ count ; }

BLEU: 86.98
Edit Sim: 16


Src: 
function divisorSum ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; ++ i ) sum += Math . floor ( n / i ) * i ; return sum ; }
Ref: 
function divisorSum ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; ++ $ i ) $ sum += floor ( $ n / $ i ) * $ i ; return $ sum ; }
Hyp: 
function divisorSum ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; ++ $ i ) $ sum += ( int ) $ n / $ i * $ i ; return $ sum ; }

BLEU: 88.29
Edit Sim: 8


Src: 
function isPerfectSquareString ( str ) { var sum = 0 ; var len = str . length ; for ( var i = 0 ; i < len ; i ++ ) sum += str . charCodeAt ( i ) ; var squareRoot = Math . sqrt ( sum ) ; return squareRoot - Math . floor ( squareRoot ) == 0 ; }
Ref: 
function isPerfectSquareString ( $ str ) { $ sum = 0 ; $ len = strlen ( $ str ) ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) $ sum += ( int ) $ str [ $ i ] ; $ squareRoot = sqrt ( $ sum ) ; return ( ( $ squareRoot - floor ( $ squareRoot ) ) == 0 ) ; }
Hyp: 
function isPerfectSquareString ( $ str ) { $ sum = 0 ; $ len = strlen ( $ str ) ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) $ sum += ord ( $ str [ $ i ] ) ; $ squareRoot = sqrt ( $ sum ) ; return $ squareRoot - floor ( $ squareRoot ) == 0 ; }

BLEU: 83.08
Edit Sim: 16


Src: 
function kthSmallest ( n , k ) { return ( 2 * k ) ; }
Ref: 
function kthSmallest ( $ n , $ k ) { return ( 2 * $ k ) ; }
Hyp: 
function kthSmallest ( $ n , $ k ) { return ( 2 * $ k ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function MinOfCubed ( k ) { if ( k < 8 ) return k ; let res = k ; for ( let i = 1 ; i <= k ; i ++ ) { if ( ( i * i * i ) > k ) return res ; res = Math . min ( res , MinOfCubed ( k - ( i * i * i ) ) + 1 ) ; } return res ; }
Ref: 
function MinOfCubed ( $ k ) { if ( $ k < 8 ) return $ k ; $ res = $ k ; for ( $ i = 1 ; $ i <= $ k ; $ i ++ ) { if ( ( $ i * $ i * $ i ) > $ k ) return $ res ; $ res = min ( $ res , MinOfCubed ( $ k - ( $ i * $ i * $ i ) ) + 1 ) ; } return $ res ; }
Hyp: 
function MinOfCubed ( $ k ) { if ( $ k < 8 ) return $ k ; $ res = $ k ; for ( $ i = 1 ; $ i <= $ k ; $ i ++ ) { if ( ( $ i * $ i * $ i ) > $ k ) return $ res ; $ res = min ( $ res , MinOfCubed ( $ k - ( $ i * $ i * $ i ) ) + 1 ) ; } return $ res ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function StepstoReachTarget ( target ) { target = Math . abs ( target ) ; let n = Math . ceil ( ( - 1.0 + Math . sqrt ( 1 + 8.0 * target ) ) / 2 ) ; let sum = n * ( n + 1 ) / 2 ; if ( sum == target ) return n ; let d = sum - target ; if ( ( d & 1 ) == 0 ) return n ; else return n + ( ( n & 1 ) != 0 ? 2 : 1 ) ; }
Ref: 
function StepstoReachTarget ( $ target ) { $ target = abs ( $ target ) ; $ n = ceil ( ( -1.0 + sqrt ( 1 + 8.0 * $ target ) ) / 2 ) ; $ sum = $ n * ( $ n + 1 ) / 2 ; if ( $ sum == $ target ) return $ n ; $ d = $ sum - $ target ; if ( ( $ d & 1 ) == 0 ) return n ; else return $ n + ( ( $ n & 1 ) ? 2 : 1 ) ; }
Hyp: 
function StepstoReachTarget ( $ target ) { $ target = abs ( $ target ) ; $ n = ceil ( ( -1.0 + sqrt ( 1 + 8.0 * $ target ) ) / 2 ) ; $ sum = $ n * ( $ n + 1 ) / 2 ; if ( $ sum == $ target ) return $ n ; $ d = $ sum - $ target ; if ( ( $ d & 1 ) == 0 ) return $ n ; else return $ n + ( ( $ n & 1 ) != 0 ? 2 : 1 ) ; }

BLEU: 94.48
Edit Sim: 7


Src: 
function findAreaShaded ( a ) { let sqArea = a * a ; let semiCircleArea = ( 3.14 * ( a * a ) / 8 ) ; let ShadedArea = 4 * semiCircleArea - sqArea ; return ShadedArea ; }
Ref: 
function findAreaShaded ( $ a ) { $ sqArea = $ a * $ a ; $ semiCircleArea = ( 3.14 * ( $ a * $ a ) / 8 ) ; $ ShadedArea = 4 * $ semiCircleArea - $ sqArea ; return $ ShadedArea ; }
Hyp: 
function findAreaShaded ( $ a ) { $ sqArea = $ a * $ a ; $ semiCircleArea = ( 3.14 * ( $ a * $ a ) / 8 ) ; $ ShadedArea = 4 * $ semiCircleArea - $ sqArea ; return $ ShadedArea ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findNth ( n ) { let count = 0 ; for ( let curr = 19 ; ; curr += 9 ) { let sum = 0 ; for ( let x = curr ; x > 0 ; x = parseInt ( x / 10 ) ) sum = sum + x % 10 ; if ( sum == 10 ) count ++ ; if ( count == n ) return curr ; } return - 1 ; }
Ref: 
function findNth ( $ n ) { $ count = 0 ; for ( $ curr = 19 ; ; $ curr += 9 ) { $ sum = 0 ; for ( $ x = $ curr ; $ x > 0 ; $ x = ( int ) $ x / 10 ) $ sum = $ sum + $ x % 10 ; if ( $ sum == 10 ) $ count ++ ; if ( $ count == $ n ) return $ curr ; } return -1 ; }
Hyp: 
function findNth ( $ n ) { $ count = 0 ; for ( $ curr = 19 ; ; $ curr += 9 ) { $ sum = 0 ; for ( $ x = $ curr ; $ x > 0 ; $ x = ( int ) $ x / 10 ) $ sum = $ sum + $ x % 10 ; if ( $ sum == 10 ) $ count ++ ; if ( $ count == $ n ) return $ curr ; } return -1 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function numberOfPaths ( m , n ) { var path = 1 ; for ( i = n ; i < ( m + n - 1 ) ; i ++ ) { path *= i ; path = parseInt ( path / ( i - n + 1 ) ) ; } return path ; }
Ref: 
function numberOfPaths ( $ m , $ n ) { $ path = 1 ; for ( $ i = $ n ; $ i < ( $ m + $ n - 1 ) ; $ i ++ ) { $ path *= $ i ; $ path /= ( $ i - $ n + 1 ) ; } return $ path ; } { echo ( numberOfPaths ( 3 , 3 ) ) ; }
Hyp: 
function numberOfPaths ( $ m , $ n ) { $ path = 1 ; for ( $ i = $ n ; $ i < ( $ m + $ n - 1 ) ; $ i ++ ) { $ path *= $ i ; $ path = ( int ) $ path / ( $ i - $ n + 1 ) ; } return $ path ; }

BLEU: 81.63
Edit Sim: 52


Src: 
function maxSum ( arr , i , n ) { if ( i >= n ) return 0 ; if ( v [ i ] ) return dp [ i ] ; v [ i ] = 1 ; dp [ i ] = Math . max ( maxSum ( arr , i + 1 , n ) , arr [ i ] + maxSum ( arr , i + 2 , n ) ) ; return dp [ i ] ; }
Ref: 
function maxSum ( $ arr , $ i , $ n ) { if ( $ i >= $ n ) return 0 ; if ( $ GLOBALS [ ' v ' ] [ $ i ] ) return $ GLOBALS [ ' dp ' ] [ $ i ] ; $ GLOBALS [ ' v ' ] [ $ i ] = 1 ; $ GLOBALS [ ' dp ' ] [ $ i ] = max ( maxSum ( $ arr , $ i + 1 , $ n ) , $ arr [ $ i ] + maxSum ( $ arr , $ i + 2 , $ n ) ) ; return $ GLOBALS [ ' dp ' ] [ $ i ] ; }
Hyp: 
function maxSum ( $ arr , $ i , $ n ) { if ( $ i >= $ n ) return 0 ; if ( $ v [ $ i ] ) return $ dp [ $ i ] ; $ v [ $ i ] = 1 ; $ dp [ $ i ] = max ( maxSum ( $ arr , $ i + 1 , $ n ) , $ arr [ $ i ] + maxSum ( $ arr , $ i + 2 , $ n ) ) ; return $ dp [ $ i ] ; }

BLEU: 69.8
Edit Sim: 80


Src: 
function maxLines ( n , x1 , y1 , x2 , y2 ) { var s = [ ] ; var slope = 2147483647 ; for ( let i = 0 ; i < n ; i ++ ) { if ( x1 [ i ] === x2 [ i ] ) slope = 2147483647 ; else slope = ( ( ( y2 [ i ] - y1 [ i ] ) * 1.0 ) / ( x2 [ i ] - x1 [ i ] ) ) * 1.0 ; s . push ( slope ) ; } return s . length ; }
Ref: 
function maxLines ( $ n , $ x1 , $ y1 , $ x2 , $ y2 ) { $ s = array ( ) ; $ slope ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { if ( $ x1 [ $ i ] == $ x2 [ $ i ] ) $ slope = PHP_INT_MAX ; else $ slope = ( $ y2 [ $ i ] - $ y1 [ $ i ] ) * 1.0 / ( $ x2 [ $ i ] - $ x1 [ $ i ] ) * 1.0 ; array_push ( $ s , $ slope ) ; } return count ( $ s ) ; }
Hyp: 
function maxLines ( $ n , $ x1 , $ y1 , $ x2 , $ y2 ) { $ s = array ( ) ; $ slope = PHP_INT_MAX ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ x1 [ $ i ] == $ x2 [ $ i ] ) $ slope = PHP_INT_MAX ; else $ slope = ( ( ( $ y2 [ $ i ] - $ y1 [ $ i ] ) * 1.0 ) / ( $ x2 [ $ i ] - $ x1 [ $ i ] ) ) * 1.0 ; array_push ( $ s , $ slope ) ; } return $ s . length ; }

BLEU: 85.91
Edit Sim: 39


Src: 
function findSum ( n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum += i * ( n - i ) ; return 2 * sum ; }
Ref: 
function findSum ( $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum += $ i * ( $ n - $ i ) ; return 2 * $ sum ; }
Hyp: 
function findSum ( $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum += $ i * ( $ n - $ i ) ; return 2 * $ sum ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function areaOctagon ( side ) { return ( 2 * ( 1 + Math . sqrt ( 2 ) ) * side * side ) ; }
Ref: 
function areaOctagon ( $ side ) { return ( 2 * ( 1 + sqrt ( 2 ) ) * $ side * $ side ) ; }
Hyp: 
function areaOctagon ( $ side ) { return ( 2 * ( 1 + sqrt ( 2 ) ) * $ side * $ side ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function pairwiseDifference ( arr , n ) { var diff ; for ( i = 0 ; i < n - 1 ; i ++ ) { diff = Math . abs ( arr [ i ] - arr [ i + 1 ] ) ; document . write ( diff + " " ) ; } }
Ref: 
function pairwiseDifference ( $ arr , $ n ) { $ diff = 0 ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { $ diff = abs ( $ arr [ $ i ] - $ arr [ $ i + 1 ] ) ; echo $ diff . " " ; } }
Hyp: 
function pairwiseDifference ( $ arr , $ n ) { $ diff ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { $ diff = abs ( $ arr [ $ i ] - $ arr [ $ i + 1 ] ) ; echo $ diff . " " ; } }

BLEU: 94.59
Edit Sim: 4


Src: 
function minDiff ( n , x , A ) { var mn = A [ 0 ] , mx = A [ 0 ] ; for ( var i = 0 ; i < n ; ++ i ) { mn = Math . min ( mn , A [ i ] ) ; mx = Math . max ( mx , A [ i ] ) ; } return Math . max ( 0 , mx - mn - 2 * x ) ; }
Ref: 
function minDiff ( $ n , $ x , $ A ) { $ mn = $ A [ 0 ] ; $ mx = $ A [ 0 ] ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { $ mn = min ( $ mn , $ A [ $ i ] ) ; $ mx = max ( $ mx , $ A [ $ i ] ) ; } return max ( 0 , $ mx - $ mn - 2 * $ x ) ; }
Hyp: 
function minDiff ( $ n , $ x , $ A ) { $ mn = $ A [ 0 ] ; $ mx = $ A [ 0 ] ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { $ mn = min ( $ mn , $ A [ $ i ] ) ; $ mx = max ( $ mx , $ A [ $ i ] ) ; } return max ( 0 , $ mx - $ mn - 2 * $ x ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findFirstMissing ( array , start , end ) { if ( start > end ) return end + 1 ; if ( start != array [ start ] ) return start ; let mid = parseInt ( ( start + end ) / 2 , 10 ) ; if ( array [ mid ] == mid ) return findFirstMissing ( array , mid + 1 , end ) ; return findFirstMissing ( array , start , mid ) ; }
Ref: 
function findFirstMissing ( $ array , $ start , $ end ) { if ( $ start > $ end ) return $ end + 1 ; if ( $ start != $ array [ $ start ] ) return $ start ; $ mid = ( $ start + $ end ) / 2 ; if ( $ array [ $ mid ] == $ mid ) return findFirstMissing ( $ array , $ mid + 1 , $ end ) ; return findFirstMissing ( $ array , $ start , $ mid ) ; }
Hyp: 
function findFirstMissing ( $ array , $ start , $ end ) { if ( $ start > $ end ) return $ end + 1 ; if ( $ start != $ array [ $ start ] ) return $ start ; $ mid = ( int ) ( ( $ start + $ end ) / 2 ) ; if ( $ array [ $ mid ] == $ mid ) return findFirstMissing ( $ array , $ mid + 1 , $ end ) ; return findFirstMissing ( $ array , $ start , $ mid ) ; }

BLEU: 92.81
Edit Sim: 12


Src: 
function solve ( idx , diff , N , M , K ) { if ( idx > N ) { if ( diff == K ) return 1 ; return 0 ; } if ( dp [ idx ] [ diff ] != - 1 ) return dp [ idx ] [ diff ] ; let ans = solve ( idx + 1 , diff , N , M , K ) ; ans += ( M - 1 ) * solve ( idx + 1 , diff + 1 , N , M , K ) ; dp [ idx ] [ diff ] = ans % MOD ; return dp [ idx ] [ diff ] ; }
Ref: 
function solve ( $ idx , $ diff , $ N , $ M , $ K ) { global $ dp , $ MOD ; if ( $ idx > $ N ) { if ( $ diff == $ K ) return 1 ; return 0 ; } if ( $ dp [ $ idx ] [ $ diff ] != -1 ) return $ dp [ $ idx ] [ $ diff ] ; $ ans = solve ( $ idx + 1 , $ diff , $ N , $ M , $ K ) ; $ ans += ( $ M - 1 ) * solve ( $ idx + 1 , $ diff + 1 , $ N , $ M , $ K ) ; return $ dp [ $ idx ] [ $ diff ] = $ ans % $ MOD ; }
Hyp: 
function solve ( $ idx , $ diff , $ N , $ M , $ K ) { if ( $ idx > $ N ) { if ( $ diff == $ K ) return 1 ; return 0 ; } if ( $ dp [ $ idx ] [ $ diff ] != -1 ) return $ dp [ $ idx ] [ $ diff ] ; $ ans = solve ( $ idx + 1 , $ diff , $ N , $ M , $ K ) ; $ ans += ( $ M - 1 ) * solve ( $ idx + 1 , $ diff + 1 , $ N , $ M , $ K ) ; $ dp [ $ idx ] [ $ diff ] = $ ans % $ MOD ; return $ dp [ $ idx ] [ $ diff ] ; }

BLEU: 91.86
Edit Sim: 64


Src: 
function minNum ( arr , n ) { let odd = 0 ; for ( let i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 != 0 ) odd += 1 ; return ( ( odd % 2 ) != 0 ) ? 1 : 2 ; }
Ref: 
function minNum ( $ arr , $ n ) { $ odd = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] % 2 ) $ odd += 1 ; return ( $ odd % 2 ) ? 1 : 2 ; }
Hyp: 
function minNum ( $ arr , $ n ) { $ odd = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] % 2 != 0 ) $ odd += 1 ; return ( ( $ odd % 2 ) != 0 ) ? 1 : 2 ; }

BLEU: 86.28
Edit Sim: 14


Src: 
function encryptString ( str , n ) { let i = 0 , cnt = 0 ; let encryptedStr = " " ; while ( i < n ) { cnt = i + 1 ; while ( cnt -- > 0 ) encryptedStr += str [ i ] ; i ++ ; } return encryptedStr ; }
Ref: 
function encryptString ( $ str , $ n ) { $ i = 0 ; $ cnt = 0 ; $ encryptedStr = " " ; while ( $ i < $ n ) { $ cnt = $ i + 1 ; while ( $ cnt -- ) $ encryptedStr . = $ str [ $ i ] ; $ i ++ ; } return $ encryptedStr ; }
Hyp: 
function encryptString ( $ str , $ n ) { $ i = 0 ; $ cnt = 0 ; $ encryptedStr = " " ; while ( $ i < $ n ) { $ cnt = $ i + 1 ; while ( $ cnt -- > 0 ) $ encryptedStr += $ str [ $ i ] ; $ i ++ ; } return $ encryptedStr ; }

BLEU: 91.38
Edit Sim: 6


Src: 
function calcFunction ( n , r ) { var finalDenominator = 1 ; var mx = Math . max ( r , n - r ) ; for ( var i = mx + 1 ; i <= n ; i ++ ) { var denominator = Math . pow ( i , i ) ; var numerator = Math . pow ( i - mx , i - mx ) ; finalDenominator = ( finalDenominator * denominator ) / numerator ; } return finalDenominator ; }
Ref: 
function calcFunction ( $ n , $ r ) { $ finalDenominator = 1 ; $ mx = max ( $ r , $ n - $ r ) ; for ( $ i = $ mx + 1 ; $ i <= $ n ; $ i ++ ) { $ denominator = pow ( $ i , $ i ) ; $ numerator = pow ( $ i - $ mx , $ i - $ mx ) ; $ finalDenominator = ( $ finalDenominator * $ denominator ) / $ numerator ; } return $ finalDenominator ; }
Hyp: 
function calcFunction ( $ n , $ r ) { $ finalDenominator = 1 ; $ mx = max ( $ r , $ n - $ r ) ; for ( $ i = $ mx + 1 ; $ i <= $ n ; $ i ++ ) { $ denominator = pow ( $ i , $ i ) ; $ numerator = pow ( $ i - $ mx , $ i - $ mx ) ; $ finalDenominator = ( $ finalDenominator * $ denominator ) / $ numerator ; } return $ finalDenominator ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function maxSum ( a , n ) { let ans = 0 ; let arr = new Array ( n + 1 ) ; for ( let i = 1 ; i <= n ; i ++ ) arr [ i ] = a [ i - 1 ] ; let dp = new Array ( n + 1 ) ; for ( let i = 0 ; i <= n ; ++ i ) { dp [ i ] = new Array ( 3 ) ; for ( let j = 0 ; j < 3 ; ++ j ) { dp [ i ] [ j ] = 0 ; } } for ( let i = 1 ; i <= n ; ++ i ) { dp [ i ] [ 0 ] = Math . max ( arr [ i ] , dp [ i - 1 ] [ 0 ] + arr [ i ] ) ; dp [ i ] [ 1 ] = Math . max ( 0 , dp [ i - 1 ] [ 0 ] ) - arr [ i ] ; if ( i >= 2 ) dp [ i ] [ 1 ] = Math . max ( dp [ i ] [ 1 ] , dp [ i - 1 ] [ 1 ] + arr [ i ] ) ; if ( i >= 2 ) dp [ i ] [ 2 ] = dp [ i - 1 ] [ 1 ] - arr [ i ] ; if ( i >= 3 ) dp [ i ] [ 2 ] = Math . max ( dp [ i ] [ 2 ] , dp [ i - 1 ] [ 2 ] + arr [ i ] ) ; ans = Math . max ( ans , dp [ i ] [ 0 ] ) ; ans = Math . max ( ans , dp [ i ] [ 1 ] ) ; ans = Math . max ( ans , dp [ i ] [ 2 ] ) ; } return ans ; }
Ref: 
function maxSum ( $ a , $ n ) { $ ans = 0 ; $ arr = array ( ) ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ arr [ $ i ] = $ a [ $ i - 1 ] ; $ dp = array ( array ( ) ) ; for ( $ i = 1 ; $ i <= $ n ; ++ $ i ) { $ dp [ $ i ] [ 0 ] = max ( $ arr [ $ i ] , $ dp [ $ i - 1 ] [ 0 ] + $ arr [ $ i ] ) ; $ dp [ $ i ] [ 1 ] = max ( 0 , $ dp [ $ i - 1 ] [ 0 ] ) - $ arr [ $ i ] ; if ( $ i >= 2 ) $ dp [ $ i ] [ 1 ] = max ( $ dp [ $ i ] [ 1 ] , $ dp [ $ i - 1 ] [ 1 ] + $ arr [ $ i ] ) ; if ( $ i >= 2 ) $ dp [ $ i ] [ 2 ] = $ dp [ $ i - 1 ] [ 1 ] - $ arr [ $ i ] ; if ( $ i >= 3 ) $ dp [ $ i ] [ 2 ] = max ( $ dp [ $ i ] [ 2 ] , $ dp [ $ i - 1 ] [ 2 ] + $ arr [ $ i ] ) ; $ ans = max ( $ ans , $ dp [ $ i ] [ 0 ] ) ; $ ans = max ( $ ans , $ dp [ $ i ] [ 1 ] ) ; $ ans = max ( $ ans , $ dp [ $ i ] [ 2 ] ) ; } return $ ans ; }
Hyp: 
function maxSum ( $ a , $ n ) { $ ans = 0 ; $ arr = array_fill ( 0 , $ n + 1 , NULL ) ; $ dp = array_fill ( 0 , $ n + 1 , NULL ) ; for ( $ i = 0 ; $ i <= $ n ; ++ $ i ) { $ dp [ $ i ] [ 0 ] = max ( $ arr [ $ i ] , $ dp [ $ i - 1 ] [ 0 ] + $ arr [ $ i ] ) ; $ dp [ $ i ] [ 1 ] = max ( 0 , $ dp [ $ i - 1 ] [ 0 ] ) - $ arr [ $ i ] ; if ( $ i >= 2 ) $ dp [ $ i ] [ 2 ] = $ dp [ $ i - 1 ] [ 1 ] - $ arr [ $ i ] ; if ( $ i >= 3 ) $ dp [ $ i ] [ 2 ] = max ( $ dp [ $ i ] [ 2 ] , $ dp [ $ i - 1 ] [ 2 ] + $ arr [ $ i ] ) ; $ ans = max ( $ ans , $ dp [ $ i ] [ 0 ] ) ; $ ans = max ( $ ans , $ dp [ $ i ] [ 1 ] ) ; $ ans = max ( $ ans , $ dp [ $ i ] [ 2 ] ) ; } return $ ans ; }

BLEU: 71.96
Edit Sim: 178


Src: 
function findAllSequence ( N ) { if ( N % 2 == 0 ) { return ( Math . pow ( 2 , N / 2 + 1 ) + Math . pow ( 2 , N / 2 ) - 2 ) ; } else { return ( Math . pow ( 2 , ( N + 1 ) / 2 ) + Math . pow ( 2 , ( N + 1 ) / 2 ) - 2 ) ; } }
Ref: 
function findAllSequence ( $ N ) { if ( $ N % 2 == 0 ) { return pow ( 2 , $ N / 2 + 1 ) + pow ( 2 , $ N / 2 ) - 2 ; } else { return pow ( 2 , ( $ N + 1 ) / 2 ) + pow ( 2 , ( $ N + 1 ) / 2 ) - 2 ; } }
Hyp: 
function findAllSequence ( $ N ) { if ( $ N % 2 == 0 ) { return ( pow ( 2 , $ N / 2 + 1 ) + pow ( 2 , $ N / 2 ) - 2 ) ; } else { return ( pow ( 2 , ( $ N + 1 ) / 2 ) + pow ( 2 , ( $ N + 1 ) / 2 ) - 2 ) ; } }

BLEU: 87.47
Edit Sim: 8


Src: 
function binarySearch ( arr , left , right ) { if ( left <= right ) { var mid = parseInt ( ( left + right ) / 2 ) ; if ( arr [ mid - 1 ] < arr [ mid ] && arr [ mid ] > arr [ mid + 1 ] ) return mid ; if ( arr [ mid ] < arr [ mid + 1 ] ) return binarySearch ( arr , mid + 1 , right ) ; else return binarySearch ( arr , left , mid - 1 ) ; } return - 1 ; }
Ref: 
function binarySearch ( $ arr , $ left , $ right ) { if ( $ left <= $ right ) { $ mid = ( $ left + $ right ) / 2 ; if ( $ arr [ $ mid - 1 ] < $ arr [ $ mid ] && $ arr [ $ mid ] > $ arr [ $ mid + 1 ] ) return $ mid ; if ( $ arr [ $ mid ] < $ arr [ $ mid + 1 ] ) return binarySearch ( $ arr , $ mid + 1 , $ right ) ; else return binarySearch ( $ arr , $ left , $ mid - 1 ) ; } return -1 ; }
Hyp: 
function binarySearch ( $ arr , $ left , $ right ) { if ( $ left <= $ right ) { $ mid = ( $ left + $ right ) / 2 ; if ( $ arr [ $ mid - 1 ] < $ arr [ $ mid ] and $ arr [ $ mid ] > $ arr [ $ mid + 1 ] ) return $ mid ; if ( $ arr [ $ mid ] < $ arr [ $ mid + 1 ] ) return binarySearch ( $ arr , $ mid + 1 , $ right ) ; else return binarySearch ( $ arr , $ left , $ mid - 1 ) ; } return -1 ; }

BLEU: 98.01
Edit Sim: 3


Src: 
function isDvisibleBy12 ( num ) { if ( num . length >= 3 ) { let d1 = num [ num . length - 1 ] . charCodeAt ( ) ; if ( d1 % 2 != 0 ) return false ; let d2 = num [ num . length - 2 ] . charCodeAt ( ) ; let sum = 0 ; for ( let i = 0 ; i < num . length ; i ++ ) sum += num [ i ] . charCodeAt ( ) ; return ( ( sum % 3 == 0 ) && ( d2 * 10 + d1 ) % 4 == 0 ) ; } else { let number = parseInt ( num , 10 ) ; document . write ( number ) ; return ( number % 12 == 0 ) ; } }
Ref: 
function isDvisibleBy12 ( $ num ) { if ( strlen ( $ num ) >= 3 ) { $ d1 = ( int ) $ num [ strlen ( $ num ) - 1 ] ; if ( $ d1 % 2 != 0 ) return ( 0 ) ; $ d2 = ( int ) $ num [ strlen ( $ num ) - 2 ] ; $ sum = 0 ; for ( $ i = 0 ; $ i < strlen ( $ num ) ; $ i ++ ) $ sum += $ num [ $ i ] ; return ( $ sum % 3 == 0 && ( $ d2 * 10 + $ d1 ) % 4 == 0 ) ; } else { $ number = stoi ( $ num ) ; return ( $ number % 12 == 0 ) ; } }
Hyp: 
function isDvisibleBy12 ( $ num ) { if ( strlen ( $ num ) >= 3 ) { $ d1 = ord ( $ num [ strlen ( $ num ) - 1 ] ) ; if ( $ d1 % 2 != 0 ) return false ; $ d2 = ord ( $ num [ strlen ( $ num ) - 2 ] ) ; $ sum = 0 ; for ( $ i = 0 ; $ i < strlen ( $ num ) ; $ i ++ ) $ sum += ord ( $ num [ $ i ] ) ; return ( ( $ sum % 3 == 0 ) && ( $ d2 * 10 + $ d1 ) % 4 == 0 ) ; } else { $ number = ( int ) $ num ; echo ( $ number % 12 == 0 ) ; } }

BLEU: 82.98
Edit Sim: 46


Src: 
function printPascal ( n ) { for ( line = 1 ; line <= n ; line ++ ) { var C = 1 ; for ( i = 1 ; i <= line ; i ++ ) { document . write ( C + " " ) ; C = C * ( line - i ) / i ; } document . write ( " " ) ; } }
Ref: 
function printPascal ( $ n ) { for ( $ line = 1 ; $ line <= $ n ; $ line ++ ) { $ C = 1 ; for ( $ i = 1 ; $ i <= $ line ; $ i ++ ) { print ( $ C . " " ) ; $ C = $ C * ( $ line - $ i ) / $ i ; } print ( " STRNEWLINE " ) ; } }
Hyp: 
function printPascal ( $ n ) { for ( $ line = 1 ; $ line <= $ n ; $ line ++ ) { $ C = 1 ; for ( $ i = 1 ; $ i <= $ line ; $ i ++ ) { echo $ C , " " ; $ C = $ C * ( $ line - $ i ) / $ i ; } echo " STRNEWLINE " ; } }

BLEU: 82.85
Edit Sim: 19


Src: 
function square ( n ) { if ( n < 0 ) n = - n ; let res = n ; for ( let i = 1 ; i < n ; i ++ ) res += n ; return res ; }
Ref: 
function square ( $ n ) { if ( $ n < 0 ) $ n = - $ n ; $ res = $ n ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ res += $ n ; return $ res ; }
Hyp: 
function square ( $ n ) { if ( $ n < 0 ) $ n = - $ n ; $ res = $ n ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ res += $ n ; return $ res ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function number_of_tower ( house , range , n ) { house . sort ( function ( a , b ) { return a - b ; } ) ; let numOfTower = 0 ; let i = 0 ; while ( i < n ) { numOfTower ++ ; let loc = house [ i ] + range ; while ( i < n && house [ i ] <= loc ) i ++ ; -- i ; loc = house [ i ] + range ; while ( i < n && house [ i ] <= loc ) i ++ ; } return numOfTower ; }
Ref: 
function number_of_tower ( $ house , $ range , $ n ) { sort ( $ house ) ; $ numOfTower = 0 ; $ i = 0 ; while ( $ i < $ n ) { $ numOfTower ++ ; $ loc = $ house [ $ i ] + $ range ; while ( $ i < $ n && $ house [ $ i ] <= $ loc ) $ i ++ ; -- $ i ; $ loc = $ house [ $ i ] + $ range ; while ( $ i < $ n && $ house [ $ i ] <= $ loc ) $ i ++ ; } return $ numOfTower ; }
Hyp: 
function number_of_tower ( $ house , $ range , $ n ) { sort ( $ house ) ; $ numOfTower = 0 ; $ i = 0 ; while ( $ i < $ n ) { $ numOfTower ++ ; $ loc = $ house [ $ i ] + $ range ; while ( $ i < $ n and $ house [ $ i ] <= $ loc ) $ i ++ ; -- $ i ; $ loc = $ house [ $ i ] + $ range ; while ( $ i < $ n and $ house [ $ i ] <= $ loc ) $ i ++ ; } return $ numOfTower ; }

BLEU: 95.85
Edit Sim: 6


Src: 
function reArrange ( words , n ) { var mp = new Map ( ) ; for ( var i = 0 ; i < n ; i ++ ) mp . set ( words [ i ] , i + 1 ) ; words . sort ( ) ; for ( var i = 0 ; i < n ; i ++ ) { document . write ( mp . get ( words [ i ] ) + " " ) ; } }
Ref: 
function reArrange ( $ words , $ n ) { $ freq = array ( ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ freq [ $ words [ $ i ] ] = ( $ i + 1 ) ; } sort ( $ words ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ freq [ $ words [ $ i ] ] , " ▁ " ; }
Hyp: 
function reArrange ( $ words , $ n ) { $ mp = array ( ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ mp [ $ words [ $ i ] ] = $ i + 1 ; sort ( $ words ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ mp [ $ words [ $ i ] ] . " ▁ " ; }

BLEU: 79.65
Edit Sim: 21


Src: 
function rearrange ( a , size ) { let positive = 0 ; let negative = 1 ; let temp ; while ( true ) { while ( positive < size && a [ positive ] >= 0 ) positive += 2 ; while ( negative < size && a [ negative ] <= 0 ) negative += 2 ; if ( positive < size && negative < size ) { temp = a [ positive ] ; a [ positive ] = a [ negative ] ; a [ negative ] = temp ; } else break ; } }
Ref: 
function rearrange ( & $ a , $ size ) { $ positive = 0 ; $ negative = 1 ; while ( true ) { while ( $ positive < $ size && $ a [ $ positive ] >= 0 ) $ positive += 2 ; while ( $ negative < $ size && $ a [ $ negative ] <= 0 ) $ negative += 2 ; if ( $ positive < $ size && $ negative < $ size ) { $ temp = $ a [ $ positive ] ; $ a [ $ positive ] = $ a [ $ negative ] ; $ a [ $ negative ] = $ temp ; } else break ; } }
Hyp: 
function rearrange ( & $ a , $ size ) { $ positive = 0 ; $ negative = 1 ; $ temp ; while ( true ) { while ( $ positive < $ size and $ a [ $ positive ] >= 0 ) $ positive += 2 ; while ( $ negative < $ size and $ a [ $ negative ] <= 0 ) $ negative += 2 ; if ( $ positive < $ size and $ negative < $ size ) { $ temp = $ a [ $ positive ] ; $ a [ $ positive ] = $ a [ $ negative ] ; $ a [ $ negative ] = $ temp ; } else break ; } }

BLEU: 91.09
Edit Sim: 18


Src: 
function countDe ( arr , n ) { let v = [ ] ; for ( let i = 0 ; i < n ; i ++ ) v [ i ] = arr [ i ] ; arr . sort ( ) ; let count1 = 0 ; for ( let i = 0 ; i < n ; i ++ ) if ( arr [ i ] != v [ i ] ) count1 ++ ; arr . reverse ( ) ; let count2 = 0 ; for ( let i = 0 ; i < n ; i ++ ) if ( arr [ i ] != v [ i ] ) count2 ++ ; return ( Math . min ( count1 , count2 ) ) ; }
Ref: 
function countDe ( $ arr , $ n ) { $ v = $ arr ; sort ( $ arr ) ; $ count1 = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] != $ v [ $ i ] ) $ count1 ++ ; rsort ( $ arr ) ; $ count2 = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] != $ v [ $ i ] ) $ count2 ++ ; return ( min ( $ count1 , $ count2 ) ) ; }
Hyp: 
function countDe ( $ arr , $ n ) { $ v = array ( ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ v [ $ i ] = $ arr [ $ i ] ; sort ( ) ; $ count1 = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] != $ v [ $ i ] ) $ count1 ++ ; $ arr . reverse ( ) ; $ count2 = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] != $ v [ $ i ] ) $ count2 ++ ; return min ( $ count1 , $ count2 ) ; }

BLEU: 72.06
Edit Sim: 89


Src: 
function SectorArea ( radius , angle ) { if ( angle >= 360 ) document . write ( " " ) ; else { let sector = ( ( 22 * radius * radius ) / 7 ) * ( angle / 360 ) ; document . write ( sector ) ; } }
Ref: 
function SectorArea ( $ radius , $ angle ) { if ( $ angle >= 360 ) echo ( " Angle ▁ not ▁ possible " ) ; else { $ sector = ( ( 22 * $ radius * $ radius ) / 7 ) * ( $ angle / 360 ) ; echo ( $ sector ) ; } }
Hyp: 
function SectorArea ( $ radius , $ angle ) { if ( $ angle >= 360 ) echo " No " ; else { $ sector = ( ( 22 * $ radius * $ radius ) / 7 ) * ( $ angle / 360 ) ; echo $ sector ; } }

BLEU: 74.97
Edit Sim: 29


Src: 
function results ( n , k ) { return parseInt ( Math . round ( Math . pow ( n , ( 1.0 / Math . pow ( 2.0 , k ) ) ) ) ) ; }
Ref: 
function results ( $ n , $ k ) { return round ( pow ( $ n , ( 1.0 / pow ( 2 , $ k ) ) ) ) ; }
Hyp: 
function results ( $ n , $ k ) { return ( int ) round ( pow ( $ n , ( 1.0 / pow ( 2.0 , $ k ) ) ) ; }

BLEU: 79.77
Edit Sim: 12


Src: 
function findRepeatFirstN2 ( s ) { let p = - 1 , i , j ; for ( i = 0 ; i < s . length ; i ++ ) { for ( j = i + 1 ; j < s . length ; j ++ ) { if ( s [ i ] == s [ j ] ) { p = i ; break ; } } if ( p != - 1 ) break ; } return p ; }
Ref: 
function findRepeatFirstN2 ( $ s ) { $ p = -1 ; for ( $ i = 0 ; $ i < strlen ( $ s ) ; $ i ++ ) { for ( $ j = ( $ i + 1 ) ; $ j < strlen ( $ s ) ; $ j ++ ) { if ( $ s [ $ i ] == $ s [ $ j ] ) { $ p = $ i ; break ; } } if ( $ p != -1 ) break ; } return $ p ; }
Hyp: 
function findRepeatFirstN2 ( $ s ) { $ p = -1 ; for ( $ i = 0 ; $ i < strlen ( $ s ) ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < strlen ( $ s ) ; $ j ++ ) { if ( $ s [ $ i ] == $ s [ $ j ] ) { $ p = $ i ; break ; } } if ( $ p != -1 ) break ; } return $ p ; }

BLEU: 94.96
Edit Sim: 4


Src: 
function missingNumber ( arr1 , arr2 , n ) { let mnum = 0 ; for ( let i = 0 ; i < n ; i ++ ) mnum = mnum ^ arr1 [ i ] ; for ( let i = 0 ; i < n - 1 ; i ++ ) mnum = mnum ^ arr2 [ i ] ; return mnum ; }
Ref: 
function missingNumber ( $ arr1 , $ arr2 , $ n ) { $ mnum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ mnum = $ mnum ^ $ arr1 [ $ i ] ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) $ mnum = $ mnum ^ $ arr2 [ $ i ] ; return $ mnum ; }
Hyp: 
function missingNumber ( $ arr1 , $ arr2 , $ n ) { $ mnum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ mnum = $ mnum ^ $ arr1 [ $ i ] ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) $ mnum = $ mnum ^ $ arr2 [ $ i ] ; return $ mnum ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countSequences ( arr , n ) { let count = 1 ; arr . sort ( function ( a , b ) { return a - b } ) ; for ( let i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] + 1 != arr [ i + 1 ] ) count ++ ; return count ; }
Ref: 
function countSequences ( $ arr , $ n ) { $ count = 1 ; sort ( $ arr ) ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) if ( $ arr [ $ i ] + 1 != $ arr [ $ i + 1 ] ) $ count ++ ; return $ count ; }
Hyp: 
function countSequences ( $ arr , $ n ) { $ count = 1 ; sort ( $ arr ) ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) if ( $ arr [ $ i ] + 1 != $ arr [ $ i + 1 ] ) $ count ++ ; return $ count ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function oddTriangularNumber ( N ) { return ( N * ( ( 2 * N ) - 1 ) ) ; }
Ref: 
function oddTriangularNumber ( $ N ) { return ( $ N * ( ( 2 * $ N ) - 1 ) ) ; }
Hyp: 
function oddTriangularNumber ( $ N ) { return ( $ N * ( ( 2 * $ N ) - 1 ) ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function numberOfDistinct ( n ) { var ans = 0 ; for ( i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { ans ++ ; if ( ( n / i ) != i ) ans ++ ; } } return ans ; }
Ref: 
function numberOfDistinct ( $ n ) { $ ans = 0 ; for ( $ i = 1 ; $ i <= sqrt ( $ n ) ; $ i ++ ) { if ( $ n % $ i == 0 ) { $ ans ++ ; if ( ( $ n / $ i ) != $ i ) $ ans ++ ; } } return $ ans ; }
Hyp: 
function numberOfDistinct ( $ n ) { $ ans = 0 ; for ( $ i = 1 ; $ i <= sqrt ( $ n ) ; $ i ++ ) { if ( $ n % $ i == 0 ) { $ ans ++ ; if ( ( $ n / $ i ) != $ i ) $ ans ++ ; } } return $ ans ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countBits ( number ) { return Math . floor ( Math . log2 ( number ) + 1 ) ; }
Ref: 
function countBits ( $ number ) { return ( int ) ( log ( $ number ) / log ( 2 ) ) + 1 ; }
Hyp: 
function countBits ( $ number ) { return floor ( log2 ( $ number ) + 1 ) ; }

BLEU: 42.28
Edit Sim: 22


Src: 
function countNumbers ( n ) { let k = 0 ; let count = 0 ; while ( n > 0 ) { if ( ( n & 1 ) == 0 ) count += ( Math . pow ( 2 , k ) ) ; k += 1 ; n >>= 1 ; } return count ; }
Ref: 
function countNumbers ( $ n ) { $ k = 0 ; $ count = 0 ; while ( $ n > 0 ) { if ( ( $ n & 1 ) == 0 ) $ count += pow ( 2 , $ k ) ; $ k += 1 ; $ n >>= 1 ; } return $ count ; }
Hyp: 
function countNumbers ( $ n ) { $ k = 0 ; $ count = 0 ; while ( $ n > 0 ) { if ( $ n & 1 ) == 0 ) $ count += ( pow ( 2 , $ k ) ) ; $ k += 1 ; $ n >>= 1 ; } return $ count ; }

BLEU: 92.3
Edit Sim: 6


Src: 
function first ( str ) { for ( var i = 0 ; i < str . length ; i ++ ) if ( str [ i ] === str [ i ] . toUpperCase ( ) ) return str [ i ] ; return 0 ; } var str = " " ; var res = first ( str ) ; if ( res == 0 ) document . write ( " " ) ; else { document . write ( res ) ; document . write ( " " ) ; }
Ref: 
function first ( $ str ) { for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) if ( ctype_upper ( $ str [ $ i ] ) ) { return $ str [ $ i ] ; } return 0 ; }
Hyp: 
function first ( $ str ) { for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) if ( $ str [ $ i ] == $ str [ $ i ] ) return $ str [ $ i ] ; return 0 ; } $ str = " geeksforgeeks " ; $ res = first ( $ str ) ; if ( $ res == 0 ) echo " No " ; else { echo $ res ; echo " Yes " ; } echo " No " ; }

BLEU: 44.43
Edit Sim: 156


Src: 
function center ( x1 , x2 , y1 , y2 ) { document . write ( ( x1 + x2 ) / 2 + " " + ( y1 + y2 ) / 2 ) ; }
Ref: 
function center ( $ x1 , $ x2 , $ y1 , $ y2 ) { echo ( ( float ) ( $ x1 + $ x2 ) / 2 . " , ▁ " . ( float ) ( $ y1 + $ y2 ) / 2 ) ; }
Hyp: 
function center ( $ x1 , $ x2 , $ y1 , $ y2 ) { echo ( $ x1 + $ x2 ) / 2 ; echo ( $ y1 + $ y2 ) / 2 ; }

BLEU: 62.62
Edit Sim: 33


Src: 
function evenbinomialCoeffSum ( n ) { return ( 1 << ( n - 1 ) ) ; }
Ref: 
function evenbinomialCoeffSum ( $ n ) { return ( 1 << ( $ n - 1 ) ) ; }
Hyp: 
function evenbinomialCoeffSum ( $ n ) { return ( 1 << ( $ n - 1 ) ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function multiply ( x , n ) { return x << n ; }
Ref: 
function multiply ( $ x , $ n ) { return $ x << $ n ; }
Hyp: 
function multiply ( $ x , $ n ) { return $ x << $ n ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function Regions ( Vertices , Edges ) { var R = Edges + 2 - Vertices ; return R ; }
Ref: 
function Regions ( $ Vertices , $ Edges ) { $ R = $ Edges + 2 - $ Vertices ; return $ R ; }
Hyp: 
function Regions ( $ Vertices , $ Edges ) { $ R = $ Edges + 2 - $ Vertices ; return $ R ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function calculate ( n , power ) { sum = 0 ; bp = Math . pow ( n , power ) ; while ( bp != 0 ) { d = bp % 10 ; sum = sum + d ; bp = Math . floor ( bp / 10 ) ; } return sum ; }
Ref: 
function calculate ( $ n , $ power ) { $ sum = 0 ; $ bp = ( int ) pow ( $ n , $ power ) ; while ( $ bp != 0 ) { $ d = $ bp % 10 ; $ sum += $ d ; $ bp /= 10 ; } return $ sum ; }
Hyp: 
function calculate ( $ n , $ power ) { $ sum = 0 ; $ bp = pow ( $ n , $ power ) ; while ( $ bp != 0 ) { $ d = $ bp % 10 ; $ sum = $ sum + $ d ; $ bp = ( int ) ( $ bp / 10 ) ; } return $ sum ; }

BLEU: 78.08
Edit Sim: 37


Src: 
function minimal ( a , n ) { let lo = 0 , hi = n - 1 ; while ( lo < hi ) { let mid = ( lo + hi ) >> 1 ; if ( a [ mid ] < a [ mid + 1 ] ) { hi = mid ; } else { lo = mid + 1 ; } } return lo ; }
Ref: 
function minimal ( $ a , $ n ) { $ lo = 0 ; $ hi = $ n - 1 ; while ( $ lo < $ hi ) { $ mid = ( $ lo + $ hi ) >> 1 ; if ( $ a [ $ mid ] < $ a [ $ mid + 1 ] ) { $ hi = $ mid ; } else { $ lo = $ mid + 1 ; } } return $ lo ; }
Hyp: 
function minimal ( $ a , $ n ) { $ lo = 0 ; $ hi = $ n - 1 ; while ( $ lo < $ hi ) { $ mid = ( $ lo + $ hi ) >> 1 ; if ( $ a [ $ mid ] < $ a [ $ mid + 1 ] ) { $ hi = $ mid ; } else { $ lo = $ mid + 1 ; } } return $ lo ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function fifthPowerSum ( n ) { return ( ( 2 * n * n * n * n * n * n ) + ( 6 * n * n * n * n * n ) + ( 5 * n * n * n * n ) - ( n * n ) ) / 12 ; }
Ref: 
function fifthPowerSum ( $ n ) { return ( ( 2 * $ n * $ n * $ n * $ n * $ n * $ n ) + ( 6 * $ n * $ n * $ n * $ n * $ n ) + ( 5 * $ n * $ n * $ n * $ n ) - ( $ n * $ n ) ) / 12 ; }
Hyp: 
function fifthPowerSum ( $ n ) { return ( ( 2 * $ n * $ n * $ n * $ n * $ n ) + ( 6 * $ n * $ n * $ n * $ n * $ n ) + ( 5 * $ n * $ n * $ n * $ n ) - ( $ n * $ n ) ) / 12 ; }

BLEU: 96.08
Edit Sim: 6


Src: 
function printTwoOdd ( arr , size ) { let xor2 = arr [ 0 ] ; let set_bit_no ; let i ; int n = size - 2 ; let x = 0 , y = 0 ; for ( i = 1 ; i < size ; i ++ ) xor2 = xor2 ^ arr [ i ] ; set_bit_no = xor2 & ~ ( xor2 - 1 ) ; for ( i = 0 ; i < size ; i ++ ) { if ( ( arr [ i ] & set_bit_no ) > 0 ) x = x ^ arr [ i ] ; else y = y ^ arr [ i ] ; } document . write ( " " + x + " " + y + " " ) ; }
Ref: 
function printTwoOdd ( $ arr , $ size ) { $ xor2 = $ arr [ 0 ] ; $ set_bit_no ; $ i ; $ n = $ size - 2 ; $ x = 0 ; $ y = 0 ; for ( $ i = 1 ; $ i < $ size ; $ i ++ ) $ xor2 = $ xor2 ^ $ arr [ $ i ] ; $ set_bit_no = $ xor2 & ~ ( $ xor2 - 1 ) ; for ( $ i = 0 ; $ i < $ size ; $ i ++ ) { if ( $ arr [ $ i ] & $ set_bit_no ) $ x = $ x ^ $ arr [ $ i ] ; else $ y = $ y ^ $ arr [ $ i ] ; } echo " The ▁ two ▁ ODD ▁ elements ▁ are ▁ " , $ x , " ▁ & ▁ " , $ y ; }
Hyp: 
function printTwoOdd ( $ arr , $ size ) { $ xor2 = $ arr [ 0 ] ; $ set_bit_no ; $ i ; int n = $ size - 2 ; $ x = 0 ; $ y = 0 ; for ( $ i = 1 ; $ i < $ size ; $ i ++ ) $ xor2 = $ xor2 ^ $ arr [ $ i ] ; $ set_bit_no = $ xor2 & ~ ( $ xor2 - 1 ) ; for ( $ i = 0 ; $ i < $ size ; $ i ++ ) { if ( $ arr [ $ i ] & $ set_bit_no ) $ x = $ x ^ $ arr [ $ i ] ; else $ y = $ y ^ $ arr [ $ i ] ; } echo " x = " , ▁ $ x ▁ . ▁ " , " ▁ $ y ▁ . ▁ " " }

BLEU: 87.61
Edit Sim: 38


Src: 
function minSum ( arr , n , x ) { var sum = 0 ; var largestDivisible = - 1 , minimum = arr [ 0 ] ; for ( i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( arr [ i ] % x == 0 && largestDivisible < arr [ i ] ) largestDivisible = arr [ i ] ; if ( arr [ i ] < minimum ) minimum = arr [ i ] ; } if ( largestDivisible == - 1 ) return sum ; var sumAfterOperation = sum - minimum - largestDivisible + ( x * minimum ) + ( largestDivisible / x ) ; return Math . min ( sum , sumAfterOperation ) ; }
Ref: 
function minSum ( $ arr , $ n , $ x ) { $ sum = 0 ; $ largestDivisible = -1 ; $ minimum = $ arr [ 0 ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sum += $ arr [ $ i ] ; if ( $ arr [ $ i ] % $ x == 0 && $ largestDivisible < $ arr [ $ i ] ) $ largestDivisible = $ arr [ $ i ] ; if ( $ arr [ $ i ] < $ minimum ) $ minimum = $ arr [ $ i ] ; } if ( $ largestDivisible == -1 ) return $ sum ; $ sumAfterOperation = $ sum - $ minimum - $ largestDivisible + ( $ x * $ minimum ) + ( $ largestDivisible / $ x ) ; return min ( $ sum , $ sumAfterOperation ) ; }
Hyp: 
function minSum ( $ arr , $ n , $ x ) { $ sum = 0 ; $ largestDivisible = -1 ; $ minimum = $ arr [ 0 ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sum += $ arr [ $ i ] ; if ( $ arr [ $ i ] % $ x == 0 && $ largestDivisible < $ arr [ $ i ] ) $ largestDivisible = $ arr [ $ i ] ; if ( $ arr [ $ i ] < $ minimum ) $ minimum = $ arr [ $ i ] ; } if ( $ largestDivisible == -1 ) return $ sum ; $ sumAfterOperation = $ sum - $ minimum - $ largestDivisible + ( $ x * $ minimum ) + ( $ largestDivisible / $ x ) ; return min ( $ sum , $ sumAfterOperation ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function sum_of_series ( n ) { var result = 0 ; for ( i = 1 ; i <= n ; i ++ ) { if ( i % 2 == 0 ) result = result - parseInt ( Math . pow ( i , 2 ) ) ; else result = result + parseInt ( Math . pow ( i , 2 ) ) ; } return result ; }
Ref: 
function sum_of_series ( $ n ) { $ result = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { if ( $ i % 2 == 0 ) $ result = $ result - pow ( $ i , 2 ) ; else $ result = $ result + pow ( $ i , 2 ) ; } return $ result ; }
Hyp: 
function sum_of_series ( $ n ) { $ result = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { if ( $ i % 2 == 0 ) $ result = $ result - pow ( $ i , 2 ) ; else $ result = $ result + pow ( $ i , 2 ) ; } return $ result ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function FirstRepeated ( str ) { let checker = 0 ; for ( let i = 0 ; i < str . length ; ++ i ) { let val = ( str [ i ] - ' ' ) ; if ( ( checker & ( 1 << val ) ) > 0 ) return i ; checker |= ( 1 << val ) ; } return - 1 ; }
Ref: 
function FirstRepeated ( $ str ) { $ checker = 0 ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; ++ $ i ) { $ val = ( ord ( $ str [ $ i ] ) - ord ( ' a ' ) ) ; if ( ( $ checker & ( 1 << $ val ) ) > 0 ) return $ i ; $ checker |= ( 1 << $ val ) ; } return -1 ; }
Hyp: 
function FirstRepeated ( $ str ) { $ checker = 0 ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; ++ $ i ) { $ val = ( $ str [ $ i ] - '0' ) ; if ( ( $ checker & ( 1 << $ val ) ) > 0 ) return $ i ; $ checker |= ( 1 << $ val ) ; } return -1 ; }

BLEU: 86.18
Edit Sim: 19


Src: 
function findMaxGuests ( arrl , exit , n ) { arrl . sort ( function ( a , b ) { return a - b } ) ; exit . sort ( function ( a , b ) { return a - b } ) ; let guests_in = 1 , max_guests = 1 , time = arrl [ 0 ] ; let i = 1 , j = 0 ; while ( i < n && j < n ) { if ( arrl [ i ] <= exit [ j ] ) { guests_in ++ ; if ( guests_in > max_guests ) { max_guests = guests_in ; time = arrl [ i ] ; } i ++ ; } else { guests_in -- ; j ++ ; } } document . write ( " " + max_guests + " " + time ) ; }
Ref: 
function findMaxGuests ( $ arrl , $ exit , $ n ) { sort ( $ arrl ) ; sort ( $ exit ) ; $ guests_in = 1 ; $ max_guests = 1 ; $ time = $ arrl [ 0 ] ; $ i = 1 ; $ j = 0 ; while ( $ i < $ n and $ j < $ n ) { if ( $ arrl [ $ i ] <= $ exit [ $ j ] ) { $ guests_in ++ ; if ( $ guests_in > $ max_guests ) { $ max_guests = $ guests_in ; $ time = $ arrl [ $ i ] ; } $ i ++ ; } else { $ guests_in -- ; $ j ++ ; } } echo " Maximum ▁ Number ▁ of ▁ Guests ▁ = ▁ " , $ max_guests , " ▁ at ▁ time ▁ " , $ time ; }
Hyp: 
function findMaxGuests ( $ arrl , $ exit , $ n ) { sort ( $ arrl ) ; sort ( $ exit ) ; $ guests_in = 1 ; $ max_guests = 1 ; $ time = $ arrl [ 0 ] ; $ i = 1 ; $ j = 0 ; while ( $ i < $ n && $ j < $ n ) { if ( $ arrl [ $ i ] <= $ exit [ $ j ] ) { $ guests_in ++ ; if ( $ guests_in > $ max_guests ) { $ max_guests = $ guests_in ; $ time = $ arrl [ $ i ] ; } $ i ++ ; } else { $ guests_in -- ; $ j ++ ; } } echo " Maximum ▁ guests : ▁ " , $ max_guests , " STRNEWLINE " ; }

BLEU: 86.71
Edit Sim: 43


Src: 
function numberofways ( n , m ) { let dp = new Array ( n + 2 ) ; for ( let i = 0 ; i < dp . length ; i ++ ) { dp [ i ] = new Array ( n + 2 ) ; for ( let j = 0 ; j < dp [ i ] . length ; j ++ ) { dp [ i ] [ j ] = 0 ; } } dp [ 0 ] [ n + 1 ] = 1 ; for ( let k = n ; k >= m ; k -- ) { for ( let i = 0 ; i <= n ; i ++ ) { dp [ i ] [ k ] = dp [ i ] [ k + 1 ] ; if ( i - k >= 0 ) dp [ i ] [ k ] = ( dp [ i ] [ k ] + dp [ i - k ] [ k ] ) ; } } return dp [ n ] [ m ] ; }
Ref: 
function numberofways ( $ n , $ m ) { global $ MAX ; $ dp = array_fill ( 0 , $ n + 2 , array_fill ( 0 , $ n + 2 , NULL ) ) ; $ dp [ 0 ] [ $ n + 1 ] = 1 ; for ( $ k = $ n ; $ k >= $ m ; $ k -- ) { for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) { $ dp [ $ i ] [ $ k ] = $ dp [ $ i ] [ $ k + 1 ] ; if ( $ i - $ k >= 0 ) $ dp [ $ i ] [ $ k ] = ( $ dp [ $ i ] [ $ k ] + $ dp [ $ i - $ k ] [ $ k ] ) ; } } return $ dp [ $ n ] [ $ m ] ; }
Hyp: 
function numberofways ( $ n , $ m ) { $ dp = array_fill ( 0 , $ n + 2 , array_fill ( 0 , $ m + 1 , NULL ) ) ; $ dp [ 0 ] [ $ n + 1 ] = 1 ; for ( $ k = $ n ; $ k >= $ m ; $ k -- ) { for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) { $ dp [ $ i ] [ $ k ] = $ dp [ $ i ] [ $ k + 1 ] ; if ( $ i - $ k >= 0 ) $ dp [ $ i ] [ $ k ] = ( $ dp [ $ i ] [ $ k ] + $ dp [ $ i - $ k ] [ $ k ] ) ; } } return $ dp [ $ n ] [ $ m ] ; }

BLEU: 94.44
Edit Sim: 17


Src: 
function series ( n ) { return ( 8 * n * n ) + 1 ; }
Ref: 
function series ( $ n ) { return ( 8 * $ n * $ n ) + 1 ; }
Hyp: 
function series ( $ n ) { return ( 8 * $ n * $ n ) + 1 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function find ( p ) { return Math . ceil ( Math . sqrt ( 2 * 365 * Math . log ( 1 / ( 1 - p ) ) ) ) ; }
Ref: 
function find ( $ p ) { return ceil ( sqrt ( 2 * 365 * log ( 1 / ( 1 - $ p ) ) ) ) ; }
Hyp: 
function find ( $ p ) { return ceil ( log ( 1 / ( 1 - $ p ) ) ) ; }

BLEU: 69.65
Edit Sim: 19


Src: 
function CalculateMax ( arr , n ) { arr . sort ( function ( a , b ) { return a - b } ) ; let min_sum = arr [ 0 ] + arr [ 1 ] ; let max_sum = arr [ n - 1 ] + arr [ n - 2 ] ; return ( Math . abs ( max_sum - min_sum ) ) ; }
Ref: 
function CalculateMax ( $ arr , $ n ) { sort ( $ arr ) ; $ min_sum = $ arr [ 0 ] + $ arr [ 1 ] ; $ max_sum = $ arr [ $ n - 1 ] + $ arr [ $ n - 2 ] ; return abs ( $ max_sum - $ min_sum ) ; }
Hyp: 
function CalculateMax ( $ arr , $ n ) { sort ( $ arr ) ; $ min_sum = $ arr [ 0 ] + $ arr [ 1 ] ; $ max_sum = $ arr [ $ n - 1 ] + $ arr [ $ n - 2 ] ; return abs ( $ max_sum - $ min_sum ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function updateString ( S , A , B ) { let l = A . length ; for ( let i = 0 ; i + l <= S . length ; i ++ ) { let curr = S . substring ( i , i + l ) ; if ( curr == A ) { let new_string = S . substring ( 0 , i ) + B + S . substring ( i + l ) ; S = new_string ; i += l - 1 ; } else { let new_string = S . substring ( 0 , i ) + A + S . substring ( i + l ) ; S = new_string ; i += l - 1 ; } } return S ; }
Ref: 
function updateString ( $ S , $ A , $ B ) { $ l = strlen ( $ A ) ; for ( $ i = 0 ; $ i + $ l <= strlen ( $ S ) ; $ i ++ ) { $ curr = substr ( $ S , $ i , $ i + $ l ) ; if ( strcmp ( $ curr , $ A ) == 0 ) { $ new_string = substr ( $ S , 0 , $ i ) . $ B . substr ( $ S , $ i + $ l , strlen ( $ S ) ) ; $ S = $ new_string ; $ i += $ l - 1 ; } else { $ new_string = substr ( $ S , 0 , $ i ) . $ A . substr ( $ S , $ i + $ l , strlen ( $ S ) ) ; $ S = $ new_string ; $ i += $ l - 1 ; } } return $ S ; }
Hyp: 
function updateString ( $ S , $ A , $ B ) { $ l = strlen ( $ A ) ; for ( $ i = 0 ; $ i + $ l <= strlen ( $ S ) ; $ i ++ ) { $ curr = substr ( $ S , $ i , $ i + $ l ) ; if ( $ curr == $ A ) { $ new_string = $ S [ 0 , $ i ] + $ B + $ S [ $ i + $ l ] ; $ S = $ new_string ; $ i += $ l - 1 ; } else { $ new_string = $ S [ 0 , $ i ] + $ A + $ S [ $ i + $ l ] ; $ S = $ new_string ; $ i += $ l - 1 ; } } return $ S ; }

BLEU: 67.91
Edit Sim: 100


Src: 
function MinimumMail ( n , k , x ) { let m = ( n - 1 ) + Math . ceil ( ( n - 1 ) * 1.0 / x ) * ( n - 1 ) + Math . ceil ( n * 1.0 / x ) * ( k - n ) ; return m ; }
Ref: 
function MinimumMail ( $ n , $ k , $ x ) { $ m = ( $ n - 1 ) + ceil ( ( $ n - 1 ) * 1.0 / $ x ) * ( $ n - 1 ) + ceil ( $ n * 1.0 / $ x ) * ( $ k - $ n ) ; return $ m ; }
Hyp: 
function MinimumMail ( $ n , $ k , $ x ) { $ m = ( $ n - 1 ) + ceil ( ( $ n - 1 ) * 1.0 / $ x ) * ( $ n - 1 ) + ceil ( $ n * 1.0 / $ x ) * ( $ k - $ n ) ; return $ m ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countPairs ( N ) { let count = 0 ; for ( let i = 1 ; i <= parseInt ( Math . pow ( N , ( 1.0 / 3.0 ) ) , 10 ) ; i ++ ) { let cb = i * i * i ; let diff = N - cb ; let cbrtDiff = parseInt ( Math . pow ( diff , ( 1.0 / 3.0 ) ) , 10 ) ; if ( cbrtDiff * cbrtDiff * cbrtDiff == diff ) count ++ ; } return count ; }
Ref: 
function countPairs ( $ N ) { $ count = 0 ; for ( $ i = 1 ; $ i <= ( int ) pow ( $ N , 1 / 3 ) ; $ i ++ ) { $ cb = $ i * $ i * $ i ; $ diff = ( $ N - $ cb ) ; $ cbrtDiff = ( int ) pow ( $ diff , 1 / 3 ) ; if ( $ cbrtDiff * $ cbrtDiff * $ cbrtDiff == $ diff ) $ count ++ ; } return $ count ; }
Hyp: 
function countPairs ( $ N ) { $ count = 0 ; for ( $ i = 1 ; $ i <= pow ( $ N , ( 1.0 / 3.0 ) ) ; $ i ++ ) { $ cb = $ i * $ i * $ i ; $ diff = $ N - $ cb ; $ cbrtDiff = pow ( $ diff , ( 1.0 / 3.0 ) ) ; if ( $ cbrtDiff * $ cbrtDiff * $ cbrtDiff == $ diff ) $ count ++ ; } return $ count ; }

BLEU: 78.4
Edit Sim: 36


Src: 
function pendulumArrangement ( arr , n ) { arr . sort ( function ( a , b ) { return a - b ; } ) ; var op = [ ... Array ( n ) ] ; var mid = parseInt ( ( n - 1 ) / 2 ) ; var j = 1 , i = 1 ; op [ mid ] = arr [ 0 ] ; for ( i = 1 ; i <= mid ; i ++ ) { op [ mid + i ] = arr [ j ++ ] ; op [ mid - i ] = arr [ j ++ ] ; } if ( n % 2 == 0 ) op [ mid + i ] = arr [ j ] ; document . write ( " " ) ; for ( i = 0 ; i < n ; i ++ ) document . write ( op [ i ] + " " ) ; document . write ( " " ) ; }
Ref: 
function pendulumArrangement ( $ arr , $ n ) { sort ( $ arr , $ n ) ; sort ( $ arr ) ; $ op [ $ n ] = NULL ; $ mid = floor ( ( $ n - 1 ) / 2 ) ; $ j = 1 ; $ i = 1 ; $ op [ $ mid ] = $ arr [ 0 ] ; for ( $ i = 1 ; $ i <= $ mid ; $ i ++ ) { $ op [ $ mid + $ i ] = $ arr [ $ j ++ ] ; $ op [ $ mid - $ i ] = $ arr [ $ j ++ ] ; } if ( $ n % 2 == 0 ) $ op [ $ mid + $ i ] = $ arr [ $ j ] ; echo " Pendulum ▁ arrangement : " ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ op [ $ i ] , " ▁ " ; echo " STRNEWLINE " ; }
Hyp: 
function pendulumArrangement ( $ arr , $ n ) { sort ( $ arr ) ; $ op = array_fill ( 0 , $ n , 0 ) ; $ mid = ( $ n - 1 ) / 2 ; $ j = 1 ; $ i = 1 ; $ op [ $ mid ] = $ arr [ 0 ] ; for ( $ i = 1 ; $ i <= $ mid ; $ i ++ ) { $ op [ $ mid + $ i ] = $ arr [ $ j ++ ] ; $ op [ $ mid - $ i ] = $ arr [ $ j ++ ] ; } if ( $ n % 2 == 0 ) $ op [ $ mid + $ i ] = $ arr [ $ j ] ; echo " ( " ; }

BLEU: 67.43
Edit Sim: 150


Src: 
function countDigit ( n ) { var temp = n , count = 0 ; while ( temp != 0 ) { var d = temp % 10 ; temp /= 10 ; if ( d > 0 && n % d == 0 ) count ++ ; } return count ; }
Ref: 
function countDigit ( $ n ) { $ temp = $ n ; $ count = 0 ; while ( $ temp != 0 ) { $ d = $ temp % 10 ; $ temp /= 10 ; if ( $ d > 0 && $ n % $ d == 0 ) $ count ++ ; } return $ count ; }
Hyp: 
function countDigit ( $ n ) { $ temp = $ n ; $ count = 0 ; while ( $ temp != 0 ) { $ d = $ temp % 10 ; $ temp /= 10 ; if ( $ d > 0 && $ n % $ d == 0 ) $ count ++ ; } return $ count ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function sum ( n ) { return n * ( n + 1 ) * ( n + 2 ) / 3 ; }
Ref: 
function sum ( $ n ) { return $ n * ( $ n + 1 ) * ( $ n + 2 ) / 3 ; }
Hyp: 
function sum ( $ n ) { return $ n * ( $ n + 1 ) * ( $ n + 2 ) / 3 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function maxLength ( s , n ) { let dp = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { dp [ i ] = new Array ( n ) ; for ( let j = 0 ; j < n ; j ++ ) { dp [ i ] [ j ] = 0 ; } } for ( let i = 0 ; i < n - 1 ; i ++ ) if ( s [ i ] == ' ' && s [ i + 1 ] == ' ' ) dp [ i ] [ i + 1 ] = 2 ; for ( let l = 2 ; l < n ; l ++ ) { for ( let i = 0 , j = l ; j < n ; i ++ , j ++ ) { if ( s [ i ] == ' ' && s [ j ] == ' ' ) dp [ i ] [ j ] = 2 + dp [ i + 1 ] [ j - 1 ] ; for ( let k = i ; k < j ; k ++ ) dp [ i ] [ j ] = Math . max ( dp [ i ] [ j ] , dp [ i ] [ k ] + dp [ k + 1 ] [ j ] ) ; } } return dp [ 0 ] [ n - 1 ] ; }
Ref: 
function maxLength ( $ s , $ n ) { $ dp = array_fill ( 0 , $ n , array_fill ( 0 , $ n , NULL ) ) ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) if ( $ s [ $ i ] == ' ( ' && $ s [ $ i + 1 ] == ' ) ' ) $ dp [ $ i ] [ $ i + 1 ] = 2 ; for ( $ l = 2 ; $ l < $ n ; $ l ++ ) { for ( $ i = 0 , $ j = $ l ; $ j < $ n ; $ i ++ , $ j ++ ) { if ( $ s [ $ i ] == ' ( ' && $ s [ $ j ] == ' ) ' ) $ dp [ $ i ] [ $ j ] = 2 + $ dp [ $ i + 1 ] [ $ j - 1 ] ; for ( $ k = $ i ; $ k < $ j ; $ k ++ ) $ dp [ $ i ] [ $ j ] = max ( $ dp [ $ i ] [ $ j ] , $ dp [ $ i ] [ $ k ] + $ dp [ $ k + 1 ] [ $ j ] ) ; } } return $ dp [ 0 ] [ $ n - 1 ] ; }
Hyp: 
function maxLength ( $ s , $ n ) { $ dp = array ( array ( ) ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ n ; $ j ++ ) $ dp [ $ i ] [ $ j ] = 0 ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) if ( $ s [ $ i ] == '0' && $ s [ $ i + 1 ] == '1' ) $ dp [ $ i ] [ $ i + 1 ] = 2 ; for ( $ l = 2 ; $ l < $ n ; $ l ++ ) { for ( $ i = 0 , $ j = $ l ; $ j < $ n ; $ i ++ , $ j ++ ) { if ( $ s [ $ i ] == '0' && $ s [ $ j ] == '1' ) $ dp [ $ i ] [ $ j ] = 2 + $ dp [ $ i + 1 ] [ $ j - 1 ] ; for ( $ k = $ i ; $ k < $ j ; $ k ++ ) $ dp [ $ i ] [ $ j ] = max ( $ dp [ $ i ] [ $ j ] , $ dp [ $ i ] [ $ k ] + $ dp [ $ k + 1 ] [ $ j ] ) ; } } return $ dp [ 0 ] [ $ n - 1 ] ; }

BLEU: 80.21
Edit Sim: 102


Src: 
function countRotations ( arr , low , high ) { if ( high < low ) return 0 ; if ( high == low ) return low ; let mid = Math . floor ( low + ( high - low ) / 2 ) ; if ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) return ( mid + 1 ) ; if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) return mid ; if ( arr [ high ] > arr [ mid ] ) return countRotations ( arr , low , mid - 1 ) ; return countRotations ( arr , mid + 1 , high ) ; }
Ref: 
function countRotations ( $ arr , $ low , $ high ) { if ( $ high < $ low ) return 0 ; if ( $ high == $ low ) return $ low ; $ mid = $ low + ( $ high - $ low ) / 2 ; if ( $ mid < $ high && $ arr [ $ mid + 1 ] < $ arr [ $ mid ] ) return ( int ) ( $ mid + 1 ) ; if ( $ mid > $ low && $ arr [ $ mid ] < $ arr [ $ mid - 1 ] ) return ( int ) ( $ mid ) ; if ( $ arr [ $ high ] > $ arr [ $ mid ] ) return countRotations ( $ arr , $ low , $ mid - 1 ) ; return countRotations ( $ arr , $ mid + 1 , $ high ) ; }
Hyp: 
function countRotations ( $ arr , $ low , $ high ) { if ( $ high < $ low ) return 0 ; if ( $ high == $ low ) return $ low ; $ mid = floor ( $ low + ( $ high - $ low ) / 2 ) ; if ( $ mid < $ high && $ arr [ $ mid + 1 ] < $ arr [ $ mid ] ) return ( $ mid + 1 ) ; if ( $ mid > $ low && $ arr [ $ mid ] < $ arr [ $ mid - 1 ] ) return $ mid ; if ( $ arr [ $ high ] > $ arr [ $ mid ] ) return countRotations ( $ arr , $ low , $ mid - 1 ) ; return countRotations ( $ arr , $ mid + 1 , $ high ) ; }

BLEU: 92.08
Edit Sim: 30


Src: 
function findKthGoodNo ( n ) { let lastDig = n % 10 ; if ( lastDig >= 0 && lastDig <= 4 ) return n << 1 ; else return ( n << 1 ) + 1 ; }
Ref: 
function findKthGoodNo ( $ n ) { $ lastDig = $ n % 10 ; if ( $ lastDig >= 0 && $ lastDig <= 4 ) return $ n << 1 ; else return ( $ n << 1 ) + 1 ; }
Hyp: 
function findKthGoodNo ( $ n ) { $ lastDig = $ n % 10 ; if ( $ lastDig >= 0 && $ lastDig <= 4 ) return $ n << 1 ; else return ( $ n << 1 ) + 1 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countBT ( h ) { let dp = new Array ( h + 1 ) ; dp . fill ( 0 ) ; dp [ 0 ] = 1 ; dp [ 1 ] = 1 ; for ( let i = 2 ; i <= h ; ++ i ) dp [ i ] = ( dp [ i - 1 ] * ( ( 2 * dp [ i - 2 ] ) % MOD + dp [ i - 1 ] ) % MOD ) % MOD ; return dp [ h ] ; }
Ref: 
function countBT ( $ h ) { global $ mod ; $ dp [ 0 ] = $ dp [ 1 ] = 1 ; for ( $ i = 2 ; $ i <= $ h ; $ i ++ ) { $ dp [ $ i ] = ( $ dp [ $ i - 1 ] * ( ( 2 * $ dp [ $ i - 2 ] ) % $ mod + $ dp [ $ i - 1 ] ) % $ mod ) % $ mod ; } return $ dp [ $ h ] ; }
Hyp: 
function countBT ( $ h ) { $ dp = array_fill ( 0 , $ h + 1 , 0 ) ; $ dp [ 0 ] = 1 ; $ dp [ 1 ] = 1 ; for ( $ i = 2 ; $ i <= $ h ; ++ $ i ) $ dp [ $ i ] = ( $ dp [ $ i - 1 ] * ( ( 2 * $ dp [ $ i - 2 ] ) % $ MOD + $ dp [ $ i - 1 ] ) % $ MOD ) % $ MOD ; return $ dp [ $ h ] ; }

BLEU: 73.32
Edit Sim: 54


Src: 
function pythagorean_quadruple ( a , b , c , d ) { let sum = a * a + b * b + c * c ; if ( d * d == sum ) return true ; else return false ; }
Ref: 
function pythagorean_quadruple ( $ a , $ b , $ c , $ d ) { $ sum = $ a * $ a + $ b * $ b + $ c * $ c ; if ( $ d * $ d == $ sum ) return true ; else return false ; }
Hyp: 
function pythagorean_quadruple ( $ a , $ b , $ c , $ d ) { $ sum = $ a * $ a + $ b * $ b + $ c * $ c ; if ( $ d * $ d == $ sum ) return true ; else return false ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function search ( pat , txt ) { let M = pat . length ; let N = txt . length ; let i = 0 ; while ( i <= N - M ) { let j ; for ( j = 0 ; j < M ; j ++ ) if ( txt [ i + j ] != pat [ j ] ) break ; if ( j == M ) { document . write ( " " + i + " " ) ; i = i + M ; } else if ( j == 0 ) i = i + 1 ; else i = i + j ; } }
Ref: 
function search ( $ pat , $ txt ) { $ M = strlen ( $ pat ) ; $ N = strlen ( $ txt ) ; $ i = 0 ; while ( $ i <= $ N - $ M ) { $ j ; for ( $ j = 0 ; $ j < $ M ; $ j ++ ) if ( $ txt [ $ i + $ j ] != $ pat [ $ j ] ) break ; if ( $ j == $ M ) { echo ( " Pattern ▁ found ▁ at ▁ index ▁ $ i " . " STRNEWLINE " ) ; $ i = $ i + $ M ; } else if ( $ j == 0 ) $ i = $ i + 1 ; else $ i = $ i + $ j ; } }
Hyp: 
function search ( $ pat , $ txt ) { $ M = strlen ( $ pat ) ; $ N = strlen ( $ txt ) ; $ i = 0 ; while ( $ i <= $ N - $ M ) { $ j ; for ( $ j = 0 ; $ j < $ M ; $ j ++ ) if ( $ txt [ $ i + $ j ] != $ pat [ $ j ] ) break ; if ( $ j == $ M ) { echo ( " Pattern ▁ found ▁ at ▁ index ▁ $ i " . " STRNEWLINE " ) ; $ i = $ i + $ M ; } else if ( $ j == 0 ) $ i = $ i + 1 ; else $ i = $ i + $ j ; } }

BLEU: 100.0
Edit Sim: 0


Src: 
function countChar ( str ) { var n = str . length ; if ( n <= 2 ) return n ; var count = 2 ; for ( var i = 1 ; i < n - 1 ; i ++ ) if ( str [ i - 1 ] == str [ i + 1 ] ) count ++ ; return count ; }
Ref: 
function countChar ( $ str ) { $ n = strlen ( $ str ) ; if ( $ n <= 2 ) return $ n ; $ count = 2 ; for ( $ i = 1 ; $ i < $ n - 1 ; $ i ++ ) if ( $ str [ $ i - 1 ] == $ str [ $ i + 1 ] ) $ count ++ ; return $ count ; }
Hyp: 
function countChar ( $ str ) { $ n = strlen ( $ str ) ; if ( $ n <= 2 ) return $ n ; $ count = 2 ; for ( $ i = 1 ; $ i < $ n - 1 ; $ i ++ ) if ( $ str [ $ i - 1 ] == $ str [ $ i + 1 ] ) $ count ++ ; return $ count ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function calculateLeaps ( n ) { if ( n == 0 n == 1 ) { return 1 ; } else { let leaps = 0 ; for ( let i = 0 ; i < n ; i ++ ) leaps += calculateLeaps ( i ) ; return leaps ; } }
Ref: 
function calculateLeaps ( $ n ) { if ( $ n == 0 $ n == 1 ) { return 1 ; } else { $ leaps = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ leaps += calculateLeaps ( $ i ) ; return $ leaps ; } }
Hyp: 
function calculateLeaps ( $ n ) { if ( $ n == 0 $ n == 1 ) return 1 ; else { $ leaps = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ leaps += calculateLeaps ( $ i ) ; return $ leaps ; } }

BLEU: 91.7
Edit Sim: 4


Src: 
function minCost ( A , n ) { var cost = 0 ; A . sort ( ) ; var K = A [ parseInt ( n / 2 ) ] ; var i ; for ( i = 0 ; i < n ; ++ i ) cost += Math . abs ( A [ i ] - K ) ; if ( n % 2 == 0 ) { var tempCost = 0 ; K = A [ parseInt ( n / 2 ) - 1 ] ; for ( i = 0 ; i < n ; ++ i ) tempCost += Math . abs ( A [ i ] - K ) ; cost = Math . min ( cost , tempCost ) ; } return cost ; }
Ref: 
function minCost ( $ A , $ n ) { $ cost = 0 ; sort ( $ A ) ; $ K = $ A [ $ n / 2 ] ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) $ cost += abs ( $ A [ $ i ] - $ K ) ; if ( $ n % 2 == 0 ) { $ tempCost = 0 ; $ K = $ A [ ( $ n / 2 ) - 1 ] ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) $ tempCost += abs ( $ A [ $ i ] - $ K ) ; $ cost = min ( $ cost , $ tempCost ) ; } return $ cost ; }
Hyp: 
function minCost ( $ A , $ n ) { $ cost = 0 ; sort ( $ A ) ; $ K = $ A [ $ n / 2 ] ; $ i ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) $ cost += abs ( $ A [ $ i ] - $ K ) ; if ( $ n % 2 == 0 ) { $ tempCost = 0 ; $ K = $ A [ $ n / 2 - 1 ] ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) $ tempCost += abs ( $ A [ $ i ] - $ K ) ; $ cost = min ( $ cost , $ tempCost ) ; } return $ cost ; }

BLEU: 95.42
Edit Sim: 10


Src: 
function LongestSubarray ( arr , n , k ) { let count = 1 ; let max_length = 1 ; let prev_mod = arr [ 0 ] % k ; for ( let i = 1 ; i < n ; i ++ ) { let curr_mod = arr [ i ] % k ; if ( curr_mod == prev_mod ) { count ++ ; } else { max_length = Math . max ( max_length , count ) ; count = 1 ; prev_mod = curr_mod ; } } return Math . max ( max_length , count ) ; }
Ref: 
function LongestSubarray ( $ arr , $ n , $ k ) { $ cnt = 1 ; $ max_length = 1 ; $ prev_mod = $ arr [ 0 ] % $ k ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ curr_mod = $ arr [ $ i ] % $ k ; if ( $ curr_mod == $ prev_mod ) { $ cnt ++ ; } else { $ max_length = max ( $ max_length , $ cnt ) ; $ cnt = 1 ; $ prev_mod = $ curr_mod ; } } return max ( $ max_length , $ cnt ) ; }
Hyp: 
function LongestSubarray ( $ arr , $ n , $ k ) { $ count = 1 ; $ max_length = 1 ; $ prev_mod = $ arr [ 0 ] % $ k ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ curr_mod = $ arr [ $ i ] % $ k ; if ( $ curr_mod == $ prev_mod ) { $ count ++ ; } else { $ max_length = max ( $ max_length , $ count ) ; $ count = 1 ; $ prev_mod = $ curr_mod ; } } return max ( $ max_length , $ count ) ; }

BLEU: 89.18
Edit Sim: 10


Src: 
function Race ( B , C ) { var result = 0 ; result = ( ( C * 100 ) / B ) ; return 100 - result ; }
Ref: 
function Race ( $ B , $ C ) { $ result = 0 ; $ result = ( ( $ C * 100 ) / $ B ) ; return 100 - $ result ; }
Hyp: 
function Race ( $ B , $ C ) { $ result = 0 ; $ result = ( ( $ C * 100 ) / $ B ) ; return 100 - $ result ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function nthPalindrome ( n , k ) { let temp = ( k & 1 ) != 0 ? parseInt ( k / 2 , 10 ) : ( parseInt ( k / 2 , 10 ) - 1 ) ; let palindrome = parseInt ( Math . pow ( 10 , temp ) , 10 ) ; palindrome += n - 1 ; document . write ( palindrome ) ; if ( ( k & 1 ) > 0 ) palindrome = parseInt ( palindrome / 10 , 10 ) ; while ( palindrome > 0 ) { document . write ( palindrome % 10 ) ; palindrome = parseInt ( palindrome / 10 , 10 ) ; } document . write ( " " + " " ) ; }
Ref: 
function nthPalindrome ( $ n , $ k ) { $ temp = ( $ k & 1 ) ? ( int ) ( $ k / 2 ) : ( int ) ( $ k / 2 - 1 ) ; $ palindrome = ( int ) pow ( 10 , $ temp ) ; $ palindrome += $ n - 1 ; print ( $ palindrome ) ; if ( $ k & 1 ) $ palindrome = ( int ) ( $ palindrome / 10 ) ; while ( $ palindrome > 0 ) { print ( $ palindrome % 10 ) ; $ palindrome = ( int ) ( $ palindrome / 10 ) ; } print ( " STRNEWLINE " ) ; }
Hyp: 
function nthPalindrome ( $ n , $ k ) { $ temp = ( $ k & 1 ) != 0 ? ( int ) ( $ k / 2 ) : ( int ) ( $ k / 2 ) - 1 ; $ palindrome = pow ( 10 , $ temp ) ; $ palindrome += $ n - 1 ; echo $ palindrome ; if ( ( $ k & 1 ) > 0 ) $ palindrome = ( int ) ( $ palindrome / 10 ) ; while ( $ palindrome > 0 ) { echo $ palindrome % 10 ; $ palindrome = ( int ) ( $ palindrome / 10 ) ; } echo " No ▁ such ▁ palindrome " ; }

BLEU: 75.95
Edit Sim: 69


Src: 
function getMaxNum ( a , b , c ) { if ( b % c == 0 ) return b ; var x = ( parseInt ( b / c ) * c ) ; if ( x >= a && x <= b ) return x ; else return - 1 ; }
Ref: 
function getMaxNum ( $ a , $ b , $ c ) { if ( $ b % $ c == 0 ) return $ b ; $ x = ( ( int ) ( $ b / $ c ) * $ c ) ; if ( $ x >= $ a && $ x <= $ b ) return $ x ; else return -1 ; }
Hyp: 
function getMaxNum ( $ a , $ b , $ c ) { if ( $ b % $ c == 0 ) return $ b ; $ x = ( ( int ) ( $ b / $ c ) * $ c ) ; if ( $ x >= $ a && $ x <= $ b ) return $ x ; else return -1 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function FindMinimumCost ( ind , a , n , k , dp ) { if ( ind == ( n - 1 ) ) return 0 ; else if ( dp [ ind ] != - 1 ) return dp [ ind ] ; else { var ans = Number . MAX_VALUE ; for ( var i = 1 ; i <= k ; i ++ ) { if ( ind + i < n ) ans = Math . min ( ans , Math . abs ( a [ ind + i ] - a [ ind ] ) + FindMinimumCost ( ind + i , a , n , k , dp ) ) ; else break ; } return dp [ ind ] = ans ; } }
Ref: 
function FindMinimumCost ( $ ind , $ a , $ n , $ k , $ dp ) { if ( $ ind == ( $ n - 1 ) ) return 0 ; else if ( $ dp [ $ ind ] != -1 ) return $ dp [ $ ind ] ; else { $ ans = PHP_INT_MAX ; for ( $ i = 1 ; $ i <= $ k ; $ i ++ ) { if ( $ ind + $ i < $ n ) $ ans = min ( $ ans , abs ( $ a [ $ ind + $ i ] - $ a [ $ ind ] ) + FindMinimumCost ( $ ind + $ i , $ a , $ n , $ k , $ dp ) ) ; else break ; } return $ dp [ $ ind ] = $ ans ; } }
Hyp: 
function FindMinimumCost ( $ ind , $ a , $ n , $ k , $ dp ) { if ( $ ind == ( $ n - 1 ) ) return 0 ; else if ( $ dp [ $ ind ] != -1 ) return $ dp [ $ ind ] ; else { $ ans = PHP_INT_MAX ; for ( $ i = 1 ; $ i <= $ k ; $ i ++ ) { if ( $ ind + $ i < $ n ) $ ans = min ( $ ans , abs ( $ a [ $ ind + $ i ] - $ a [ $ ind ] ) + FindMinimumCost ( $ ind + $ i , $ a , $ n , $ k , $ dp ) ) ; else break ; } return $ dp [ $ ind ] = $ ans ; }

BLEU: 99.36
Edit Sim: 2


Src: 
function Sum_upto_nth_Term ( n ) { let r = n * ( n + 1 ) * ( 2 * n + 7 ) / 3 ; document . write ( r ) ; }
Ref: 
function Sum_upto_nth_Term ( $ n ) { $ r = $ n * ( $ n + 1 ) * ( 2 * $ n + 7 ) / 3 ; echo $ r ; }
Hyp: 
function Sum_upto_nth_Term ( $ n ) { $ r = $ n * ( $ n + 1 ) * ( 2 * $ n + 7 ) / 3 ; echo $ r ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function minRotation ( input , unlock_code ) { let rotation = 0 ; let input_digit , code_digit ; while ( input > 0 unlock_code > 0 ) { input_digit = input % 10 ; code_digit = unlock_code % 10 ; rotation += Math . min ( Math . abs ( input_digit - code_digit ) , 10 - Math . abs ( input_digit - code_digit ) ) ; input = Math . floor ( input / 10 ) ; unlock_code = Math . floor ( unlock_code / 10 ) ; } return rotation ; }
Ref: 
function minRotation ( $ input , $ unlock_code ) { $ rotation = 0 ; $ input_digit ; $ code_digit ; while ( $ input $ unlock_code ) { $ input_digit = $ input % 10 ; $ code_digit = $ unlock_code % 10 ; $ rotation += min ( abs ( $ input_digit - $ code_digit ) , 10 - abs ( $ input_digit - $ code_digit ) ) ; $ input /= 10 ; $ unlock_code /= 10 ; } return $ rotation ; }
Hyp: 
function minRotation ( $ input , $ unlock_code ) { $ rotation = 0 ; $ input_digit ; $ code_digit ; while ( $ input > 0 $ unlock_code > 0 ) { $ input_digit = $ input % 10 ; $ code_digit = $ unlock_code % 10 ; $ rotation += min ( abs ( $ input_digit - $ code_digit ) , 10 - abs ( $ input_digit - $ code_digit ) ) ; $ input = $ input / 10 ; $ unlock_code = $ unlock_code / 10 ; } return $ rotation ; }

BLEU: 81.43
Edit Sim: 36


Src: 
function sumSquare ( n ) { for ( i = 1 ; i * i <= n ; i ++ ) for ( j = 1 ; j * j <= n ; j ++ ) if ( i * i + j * j == n ) { document . write ( i + " " + j + " " + " " ) ; return true ; } return false ; }
Ref: 
function sumSquare ( int $ n ) { for ( $ i = 1 ; $ i * $ i <= $ n ; $ i ++ ) for ( $ j = 1 ; $ j * $ j <= $ n ; $ j ++ ) if ( $ i * $ i + $ j * $ j == $ n ) { echo $ i , " ^ 2 ▁ + ▁ " , $ j , " ^ 2" ; return true ; } return false ; }
Hyp: 
function sumSquare ( $ n ) { for ( $ i = 1 ; $ i * $ i <= $ n ; $ i ++ ) for ( $ j = 1 ; $ j * $ j <= $ n ; $ j ++ ) if ( $ i * $ i + $ j * $ j == $ n ) { echo $ i . " , ▁ " , $ j , " STRNEWLINE " ; return true ; } } return false ; }

BLEU: 84.87
Edit Sim: 25


Src: 
function solve ( i , par , a , n , k , current_ans ) { if ( par > k ) return ; if ( par == k && i == n - 1 ) { ans = Math . min ( ans , current_ans ) ; return ; } for ( let j = i + 1 ; j < n ; j ++ ) solve ( j , par + 1 , a , n , k , current_ans + ( a [ j ] - a [ i + 1 ] ) * ( a [ j ] - a [ i + 1 ] ) ) ; }
Ref: 
function solve ( $ i , $ par , & $ a , $ n , $ k , $ current_ans ) { global $ inf , $ ans ; if ( $ par > $ k ) return ; if ( $ par == $ k && $ i == $ n - 1 ) { $ ans = min ( $ ans , $ current_ans ) ; return ; } for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) solve ( $ j , $ par + 1 , $ a , $ n , $ k , $ current_ans + ( $ a [ $ j ] - $ a [ $ i + 1 ] ) * ( $ a [ $ j ] - $ a [ $ i + 1 ] ) ) ; }
Hyp: 
function solve ( $ i , $ par , $ a , $ n , $ k , & $ ans ) { if ( $ par > $ k ) return ; if ( $ par == $ k && $ i == $ n - 1 ) { $ ans = min ( $ ans , $ current_ans ) ; return ; } for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) solve ( $ j , $ par + 1 , $ a , $ n , $ k , $ ans + ( $ a [ $ j ] - $ a [ $ i + 1 ] ) * ( $ a [ $ j ] - $ a [ $ i + 1 ] ) ) ; }

BLEU: 90.24
Edit Sim: 42


Src: 
function calculate ( s ) { let ans = 6 ; for ( let i = 0 ; i < 10 ; ++ i ) { for ( let j = 0 ; j < 10 ; ++ j ) { for ( let k = 0 ; k < 10 ; ++ k ) { for ( let l = 0 ; l < 10 ; ++ l ) { for ( let m = 0 ; m < 10 ; ++ m ) { for ( let n = 0 ; n < 10 ; ++ n ) { if ( i + j + k == l + m + n ) { let c = 0 ; if ( i != s [ 0 ] - ' ' ) c ++ ; if ( j != s [ 1 ] - ' ' ) c ++ ; if ( k != s [ 2 ] - ' ' ) c ++ ; if ( l != s [ 3 ] - ' ' ) c ++ ; if ( m != s [ 4 ] - ' ' ) c ++ ; if ( n != s [ 5 ] - ' ' ) c ++ ; if ( c < ans ) ans = c ; } } } } } } } return ans ; }
Ref: 
function calculate ( $ s ) { $ ans = 6 ; for ( $ i = 0 ; $ i < 10 ; ++ $ i ) { for ( $ j = 0 ; $ j < 10 ; ++ $ j ) { for ( $ k = 0 ; $ k < 10 ; ++ $ k ) { for ( $ l = 0 ; $ l < 10 ; ++ $ l ) { for ( $ m = 0 ; $ m < 10 ; ++ $ m ) { for ( $ n = 0 ; $ n < 10 ; ++ $ n ) { if ( $ i + $ j + $ k == $ l + $ m + $ n ) { $ c = 0 ; if ( $ i != $ s [ 0 ] - '0' ) $ c ++ ; if ( $ j != $ s [ 1 ] - '0' ) $ c ++ ; if ( $ k != $ s [ 2 ] - '0' ) $ c ++ ; if ( $ l != $ s [ 3 ] - '0' ) $ c ++ ; if ( $ m != $ s [ 4 ] - '0' ) $ c ++ ; if ( $ n != $ s [ 5 ] - '0' ) $ c ++ ; if ( $ c < $ ans ) $ ans = $ c ; } } } } } } } return $ ans ; }
Hyp: 
function calculate ( $ s ) { $ ans = 6 ; for ( $ i = 0 ; $ i < 10 ; ++ $ i ) { for ( $ j = 0 ; $ j < 10 ; ++ $ j ) { for ( $ k = 0 ; $ k < 10 ; ++ $ k ) { for ( $ l = 0 ; $ l < 10 ; ++ $ l ) { for ( $ m = 0 ; $ m < 10 ; ++ $ m ) { for ( $ n = 0 ; $ n < 10 ; ++ $ n ) { if ( $ i != $ s [ 0 ] - '0' ) $ c ++ ; if ( $ j != $ s [ 1 ] - '0' ) $ c ++ ; if ( $ k != $ s [ 2 ] - '0' ) $ c ++ ; if ( $ l != $ s [ 3 ] - '0' ) $ c ++ ; if ( $ m != $ s [ 4 ] - '0' ) $ c ++ ; if ( $ n != $ s [ 5 ] - '0' ) $ c ++ ; if ( $ c < $ ans ) $ ans = $ c ; } } } } } return $ ans ; }

BLEU: 88.99
Edit Sim: 58


Src: 
function number_of_tower ( house , range , n ) { house . sort ( function ( a , b ) { return a - b ; } ) ; let numOfTower = 0 ; let i = 0 ; while ( i < n ) { numOfTower ++ ; let loc = house [ i ] + range ; while ( i < n && house [ i ] <= loc ) i ++ ; -- i ; loc = house [ i ] + range ; while ( i < n && house [ i ] <= loc ) i ++ ; } return numOfTower ; }
Ref: 
function number_of_tower ( $ house , $ range , $ n ) { sort ( $ house ) ; $ numOfTower = 0 ; $ i = 0 ; while ( $ i < $ n ) { $ numOfTower ++ ; $ loc = $ house [ $ i ] + $ range ; while ( $ i < $ n && $ house [ $ i ] <= $ loc ) $ i ++ ; -- $ i ; $ loc = $ house [ $ i ] + $ range ; while ( $ i < $ n && $ house [ $ i ] <= $ loc ) $ i ++ ; } return $ numOfTower ; }
Hyp: 
function number_of_tower ( $ house , $ range , $ n ) { sort ( $ house ) ; $ numOfTower = 0 ; $ i = 0 ; while ( $ i < $ n ) { $ numOfTower ++ ; $ loc = $ house [ $ i ] + $ range ; while ( $ i < $ n and $ house [ $ i ] <= $ loc ) $ i ++ ; -- $ i ; $ loc = $ house [ $ i ] + $ range ; while ( $ i < $ n and $ house [ $ i ] <= $ loc ) $ i ++ ; } return $ numOfTower ; }

BLEU: 95.85
Edit Sim: 6


Src: 
function getOddOccurrence ( arr , arr_size ) { for ( let i = 0 ; i < arr_size ; i ++ ) { let count = 0 ; for ( let j = 0 ; j < arr_size ; j ++ ) { if ( arr [ i ] == arr [ j ] ) count ++ ; } if ( count % 2 != 0 ) return arr [ i ] ; } return - 1 ; }
Ref: 
function getOddOccurrence ( & $ arr , $ arr_size ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ arr_size ; $ i ++ ) { for ( $ j = 0 ; $ j < $ arr_size ; $ j ++ ) { if ( $ arr [ $ i ] == $ arr [ $ j ] ) $ count ++ ; } if ( $ count % 2 != 0 ) return $ arr [ $ i ] ; } return -1 ; }
Hyp: 
function getOddOccurrence ( & $ arr , $ arr_size ) { for ( $ i = 0 ; $ i < $ arr_size ; $ i ++ ) { $ count = 0 ; for ( $ j = 0 ; $ j < $ arr_size ; $ j ++ ) { if ( $ arr [ $ i ] == $ arr [ $ j ] ) $ count ++ ; } if ( $ count % 2 != 0 ) return $ arr [ $ i ] ; } return -1 ; }

BLEU: 99.46
Edit Sim: 28


Src: 
function day_of_the_week ( y , m , d ) { let t = [ 0 , 3 , 2 , 5 , 0 , 3 , 5 , 1 , 4 , 6 , 2 , 4 ] ; if ( m < 3 ) y -= 1 ; return ( y + y / 4 - y / 100 + y / 400 + t [ m - 1 ] + d ) % 7 ; }
Ref: 
function day_of_the_week ( $ y , $ m , $ d ) { $ t = array ( 0 , 3 , 2 , 5 , 0 , 3 , 5 , 1 , 4 , 6 , 2 , 4 ) ; if ( $ m < 3 ) $ y -= 1 ; return ( ( $ y + $ y / 4 - $ y / 100 + $ y / 400 + $ t [ $ m - 1 ] + $ d ) % 7 ) ; }
Hyp: 
function day_of_the_week ( $ y , $ m , $ d ) { $ t = array ( 0 , 3 , 2 , 5 , 0 , 3 , 5 , 1 , 4 , 6 , 2 , 4 ) ; if ( $ m < 3 ) $ y -= 1 ; return ( $ y + $ y / 4 - $ y / 100 + $ y / 400 + $ t [ $ m - 1 ] + $ d ) % 7 ; }

BLEU: 95.63
Edit Sim: 4


Src: 
function countDistinct ( arr , n ) { let hs = new Set ( ) ; for ( let i = 0 ; i < n ; i ++ ) { hs . add ( arr [ i ] ) ; } return hs . size ; }
Ref: 
function countDistinct ( $ arr , $ n ) { $ s = array ( ) ; $ res = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { array_push ( $ s , $ arr [ $ i ] ) ; } $ s = array_unique ( $ s ) ; return count ( $ s ) ; }
Hyp: 
function countDistinct ( $ arr , $ n ) { $ hs = array ( ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ hs . add ( $ arr [ $ i ] ) ; } return $ hs . size ; }

BLEU: 55.5
Edit Sim: 67


Src: 
function isLowerTriangularMatrix ( mat ) { for ( let i = 0 ; i < N ; i ++ ) for ( let j = i + 1 ; j < N ; j ++ ) if ( mat [ i ] [ j ] != 0 ) return false ; return true ; }
Ref: 
function isLowerTriangularMatrix ( $ mat ) { global $ N ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ N ; $ j ++ ) if ( $ mat [ $ i ] [ $ j ] != 0 ) return false ; return true ; }
Hyp: 
function isLowerTriangularMatrix ( $ mat ) { for ( $ i = 0 ; $ i < $ GLOBALS [ ' N ' ] ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ GLOBALS [ ' N ' ] ; $ j ++ ) if ( $ mat [ $ i ] [ $ j ] != 0 ) return false ; return true ; }

BLEU: 78.52
Edit Sim: 41


Src: 
function summation ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) sum += ( i * i ) ; return sum ; }
Ref: 
function summation ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ sum += ( $ i * $ i ) ; return $ sum ; }
Hyp: 
function summation ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ sum += ( $ i * $ i ) ; return $ sum ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findNum ( N , K ) { var rem = N % K ; if ( rem == 0 ) return N ; else return N - rem ; }
Ref: 
function findNum ( $ N , $ K ) { $ rem = $ N % $ K ; if ( $ rem == 0 ) return $ N ; else return $ N - $ rem ; }
Hyp: 
function findNum ( $ N , $ K ) { $ rem = $ N % $ K ; if ( $ rem == 0 ) return $ N ; else return $ N - $ rem ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function maxLitres ( budget , plastic , glass , refund ) { if ( glass - refund < plastic ) { let ans = Math . max ( ( budget - refund ) / ( glass - refund ) , 0 ) ; budget -= ans * ( glass - refund ) ; ans += Math . floor ( budget / plastic ) ; document . write ( ans ) ; } else { document . write ( Math . floor ( budget / plastic ) ) ; } }
Ref: 
function maxLitres ( $ budget , $ plastic , $ glass , $ refund ) { if ( $ glass - $ refund < $ plastic ) { $ ans = max ( ( int ) ( $ budget - $ refund ) / ( $ glass - $ refund ) , 0 ) ; $ budget -= $ ans * ( $ glass - $ refund ) ; $ ans += ( int ) ( $ budget / $ plastic ) ; echo $ ans . " STRNEWLINE " ; } else echo ( int ) ( $ budget / $ plastic ) . " STRNEWLINE " ; }
Hyp: 
function maxLitres ( $ budget , $ plastic , $ glass , $ refund ) { if ( $ glass - $ refund < $ plastic ) { $ ans = max ( ( $ budget - $ refund ) / ( $ glass - $ refund ) , 0 ) ; $ budget -= $ ans * ( $ glass - $ refund ) ; $ ans += floor ( $ budget / $ plastic ) ; echo $ ans ; } else { echo floor ( $ budget / $ plastic ) ; } }

BLEU: 77.05
Edit Sim: 58


Src: 
function spiralDiaSum ( n ) { if ( n == 1 ) return 1 ; return ( 4 * n * n - 6 * n + 6 + spiralDiaSum ( n - 2 ) ) ; }
Ref: 
function spiralDiaSum ( $ n ) { if ( $ n == 1 ) return 1 ; return ( 4 * $ n * $ n - 6 * $ n + 6 + spiralDiaSum ( $ n - 2 ) ) ; }
Hyp: 
function spiralDiaSum ( $ n ) { if ( $ n == 1 ) return 1 ; return ( 4 * $ n * $ n - 6 * $ n + 6 + spiralDiaSum ( $ n - 2 ) ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function lcsOf3 ( X , Y , Z , m , n , o ) { let L = new Array ( m + 1 ) ; for ( let i = 0 ; i < m + 1 ; i ++ ) { L [ i ] = new Array ( n + 1 ) ; for ( let j = 0 ; j < n + 1 ; j ++ ) { L [ i ] [ j ] = new Array ( o + 1 ) ; for ( let k = 0 ; k < o + 1 ; k ++ ) { L [ i ] [ j ] [ k ] = 0 ; } } } for ( let i = 0 ; i <= m ; i ++ ) { for ( let j = 0 ; j <= n ; j ++ ) { for ( let k = 0 ; k <= o ; k ++ ) { if ( i == 0 j == 0 k == 0 ) L [ i ] [ j ] [ k ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] && X [ i - 1 ] == Z [ k - 1 ] ) L [ i ] [ j ] [ k ] = L [ i - 1 ] [ j - 1 ] [ k - 1 ] + 1 ; else L [ i ] [ j ] [ k ] = Math . max ( Math . max ( L [ i - 1 ] [ j ] [ k ] , L [ i ] [ j - 1 ] [ k ] ) , L [ i ] [ j ] [ k - 1 ] ) ; } } } return L [ m ] [ n ] [ o ] ; }
Ref: 
function lcsOf3 ( $ X , $ Y , $ Z , $ m , $ n , $ o ) { $ L [ $ m + 1 ] [ $ n + 1 ] [ $ o + 1 ] = array ( array ( array ( ) ) ) ; for ( $ i = 0 ; $ i <= $ m ; $ i ++ ) { for ( $ j = 0 ; $ j <= $ n ; $ j ++ ) { for ( $ k = 0 ; $ k <= $ o ; $ k ++ ) { if ( $ i == 0 $ j == 0 $ k == 0 ) $ L [ $ i ] [ $ j ] [ $ k ] = 0 ; else if ( $ X [ $ i - 1 ] == $ Y [ $ j - 1 ] && $ X [ $ i - 1 ] == $ Z [ $ k - 1 ] ) $ L [ $ i ] [ $ j ] [ $ k ] = $ L [ $ i - 1 ] [ $ j - 1 ] [ $ k - 1 ] + 1 ; else $ L [ $ i ] [ $ j ] [ $ k ] = max ( max ( $ L [ $ i - 1 ] [ $ j ] [ $ k ] , $ L [ $ i ] [ $ j - 1 ] [ $ k ] ) , $ L [ $ i ] [ $ j ] [ $ k - 1 ] ) ; } } } return $ L [ $ m ] [ $ n ] [ $ o ] ; }
Hyp: 
function lcsOf3 ( $ X , $ Y , $ Z , $ m , $ n , $ o ) { $ L = array_fill ( 0 , $ m + 1 , array_fill ( 0 , $ n + 1 , array_fill ( 0 , $ o + 1 , NULL ) ) ) ; for ( $ i = 0 ; $ i <= $ m + 1 ; $ i ++ ) for ( $ j = 0 ; $ j < $ n + 1 ; $ j ++ ) { for ( $ k = 0 ; $ k <= $ o ; $ k ++ ) { if ( $ i == 0 $ j == 0 $ k == 0 ) $ L [ $ i ] [ $ j ] [ $ k ] = 0 ; else if ( $ X [ $ i - 1 ] == $ Y [ $ j - 1 ] && $ X [ $ i - 1 ] == $ Z [ $ k - 1 ] ) $ L [ $ i ] [ $ j ] [ $ k ] = $ L [ $ i - 1 ] [ $ j - 1 ] [ $ k - 1 ] + 1 ; else $ L [ $ i ] [ $ j ] [ $ k ] = max ( $ L [ $ i - 1 ] [ $ j ] [ $ k ] , $ L [ $ i ] [ $ j - 1 ] [ $ k - 1 ] ) ; } } return $ L [ $ m ] [ $ n ] [ $ o ] ; }

BLEU: 85.34
Edit Sim: 107


Src: 
function isPossibleToZero ( a , n ) { let num = 0 ; for ( let i = 0 ; i < n ; i ++ ) num = num * 10 + a [ i ] ; return ( num % 11 == 0 ) ; }
Ref: 
function isPossibleToZero ( $ a , $ n ) { $ num = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ num = $ num * 10 + $ a [ $ i ] ; return ( $ num % 11 == 0 ) ; }
Hyp: 
function isPossibleToZero ( $ a , $ n ) { $ num = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ num = $ num * 10 + $ a [ $ i ] ; return ( $ num % 11 == 0 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findLastIndex ( str , x ) { let index = - 1 ; for ( let i = 0 ; i < str . length ; i ++ ) if ( str [ i ] == x ) index = i ; return index ; }
Ref: 
function findLastIndex ( $ str , $ x ) { $ index = -1 ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) if ( $ str [ $ i ] == $ x ) $ index = $ i ; return $ index ; }
Hyp: 
function findLastIndex ( $ str , $ x ) { $ index = -1 ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) if ( $ str [ $ i ] == $ x ) $ index = $ i ; return $ index ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function minPerimeter ( n ) { let l = Math . sqrt ( n ) ; let sq = l * l ; if ( sq == n ) return l * 4 ; else { let row = n / l ; let perimeter = 2 * ( l + row ) ; if ( n % l != 0 ) perimeter += 2 ; return perimeter ; } }
Ref: 
function minPerimeter ( $ n ) { $ l = floor ( sqrt ( $ n ) ) ; $ sq = $ l * $ l ; if ( $ sq == $ n ) return $ l * 4 ; else { $ row = floor ( $ n / $ l ) ; $ perimeter = 2 * ( $ l + $ row ) ; if ( $ n % $ l != 0 ) $ perimeter += 2 ; return $ perimeter ; } }
Hyp: 
function minPerimeter ( $ n ) { $ l = sqrt ( $ n ) ; $ sq = $ l * $ l ; if ( $ sq == $ n ) return $ l * 4 ; else { $ row = $ n / $ l ; $ perimeter = 2 * ( $ l + $ row ) ; if ( $ n % $ l != 0 ) $ perimeter += 2 ; return $ perimeter ; } }

BLEU: 87.06
Edit Sim: 20


Src: 
function Nonagonal ( n ) { return parseInt ( n * ( 7 * n - 5 ) / 2 ) ; }
Ref: 
function Nonagonal ( $ n ) { return $ n * ( 7 * $ n - 5 ) / 2 ; }
Hyp: 
function Nonagonal ( $ n ) { return $ n * ( 7 * $ n - 5 ) / 2 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function totalFlips ( A , B , C , N ) { let count = 0 ; for ( let i = 0 ; i < N ; ++ i ) { if ( A [ i ] == B [ i ] && C [ i ] == ' ' ) ++ count ; else if ( A [ i ] != B [ i ] && C [ i ] == ' ' ) ++ count ; } return count ; }
Ref: 
function totalFlips ( $ A , $ B , $ C , $ N ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ N ; ++ $ i ) { if ( $ A [ $ i ] == $ B [ $ i ] && $ C [ $ i ] == '1' ) ++ $ count ; else if ( $ A [ $ i ] != $ B [ $ i ] && $ C [ $ i ] == '0' ) ++ $ count ; } return $ count ; }
Hyp: 
function totalFlips ( $ A , $ B , $ C , $ N ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ N ; ++ $ i ) { if ( $ A [ $ i ] == $ B [ $ i ] && $ C [ $ i ] == '1' ) ++ $ count ; else if ( $ A [ $ i ] != $ B [ $ i ] && $ C [ $ i ] == '0' ) ++ $ count ; } return $ count ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function calculateSum ( n ) { return 2 * ( Math . pow ( n , 6 ) + 15 * Math . pow ( n , 4 ) + 15 * Math . pow ( n , 2 ) + 1 ) ; }
Ref: 
function calculateSum ( $ n ) { $ a = ( int ) $ n ; return ( 2 * ( pow ( $ n , 6 ) + 15 * pow ( $ n , 4 ) + 15 * pow ( $ n , 2 ) + 1 ) ) ; }
Hyp: 
function calculateSum ( $ n ) { return 2 * ( pow ( $ n , 6 ) + 15 * pow ( $ n , 4 ) + 15 * pow ( $ n , 2 ) + 1 ) ; }

BLEU: 71.73
Edit Sim: 24


Src: 
function getOccurence ( n , d ) { let result = 0 ; let itr = d ; while ( itr <= n ) { if ( itr % 10 == d ) result ++ ; if ( itr != 0 && Math . floor ( itr / 10 ) == d ) { result ++ ; itr ++ ; } else if ( Math . floor ( itr / 10 ) == d - 1 ) itr = itr + ( 10 - d ) ; else itr = itr + 10 ; } return result ; }
Ref: 
function getOccurence ( $ n , $ d ) { $ result = 0 ; $ itr = $ d ; while ( $ itr <= $ n ) { if ( $ itr % 10 == $ d ) $ result ++ ; if ( $ itr != 0 && floor ( $ itr / 10 ) == $ d ) { $ result ++ ; $ itr ++ ; } else if ( floor ( $ itr / 10 ) == $ d - 1 ) $ itr = $ itr + ( 10 - $ d ) ; else $ itr = $ itr + 10 ; } return $ result ; }
Hyp: 
function getOccurence ( $ n , $ d ) { $ result = 0 ; $ itr = $ d ; while ( $ itr <= $ n ) { if ( $ itr % 10 == $ d ) $ result ++ ; if ( $ itr != 0 && $ itr / 10 == $ d ) { $ result ++ ; $ itr ++ ; } else if ( $ itr / 10 == $ d - 1 ) $ itr = $ itr + ( 10 - $ d ) ; else $ itr = $ itr + 10 ; } return $ result ; }

BLEU: 90.04
Edit Sim: 20


Src: 
function circle ( x1 , y1 , x2 , y2 , r1 , r2 ) { var distSq = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ; var radSumSq = ( r1 + r2 ) * ( r1 + r2 ) ; if ( distSq == radSumSq ) return 1 ; else if ( distSq > radSumSq ) return - 1 ; else return 0 ; }
Ref: 
function circle ( $ x1 , $ y1 , $ x2 , $ y2 , $ r1 , $ r2 ) { $ distSq = ( $ x1 - $ x2 ) * ( $ x1 - $ x2 ) + ( $ y1 - $ y2 ) * ( $ y1 - $ y2 ) ; $ radSumSq = ( $ r1 + $ r2 ) * ( $ r1 + $ r2 ) ; if ( $ distSq == $ radSumSq ) return 1 ; else if ( $ distSq > $ radSumSq ) return -1 ; else return 0 ; }
Hyp: 
function circle ( $ x1 , $ y1 , $ x2 , $ y2 , $ r1 , $ r2 ) { $ distSq = ( $ x1 - $ x2 ) * ( $ x1 - $ x2 ) + ( $ y1 - $ y2 ) * ( $ y1 - $ y2 ) ; $ radSumSq = ( $ r1 + $ r2 ) * ( $ r1 + $ r2 ) ; if ( $ distSq == $ radSumSq ) return 1 ; else if ( $ distSq > $ radSumSq ) return -1 ; else return 0 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function nextGreater ( N ) { var power_of_2 = 1 , shift_count = 0 ; while ( true ) { if ( ( ( N >> shift_count ) & 1 ) % 2 == 0 ) break ; shift_count ++ ; power_of_2 = power_of_2 * 2 ; } return ( N + power_of_2 ) ; }
Ref: 
function nextGreater ( $ N ) { $ power_of_2 = 1 ; $ shift_count = 0 ; while ( true ) { if ( ( ( $ N >> $ shift_count ) & 1 ) % 2 == 0 ) break ; $ shift_count ++ ; $ power_of_2 = $ power_of_2 * 2 ; } return ( $ N + $ power_of_2 ) ; }
Hyp: 
function nextGreater ( $ N ) { $ power_of_2 = 1 ; $ shift_count = 0 ; while ( true ) { if ( ( ( $ N >> $ shift_count ) & 1 ) % 2 == 0 ) break ; $ shift_count ++ ; $ power_of_2 = $ power_of_2 * 2 ; } return ( $ N + $ power_of_2 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countSolutions ( a ) { let count = 0 ; for ( let i = 0 ; i <= a ; i ++ ) { if ( a == ( i + ( a ^ i ) ) ) count ++ ; } return count ; }
Ref: 
function countSolutions ( $ a ) { $ count = 0 ; for ( $ i = 0 ; $ i <= $ a ; $ i ++ ) { if ( $ a == ( $ i + ( $ a ^ $ i ) ) ) $ count ++ ; } return $ count ; }
Hyp: 
function countSolutions ( $ a ) { $ count = 0 ; for ( $ i = 0 ; $ i <= $ a ; $ i ++ ) { if ( $ a == ( $ i + ( $ a ^ $ i ) ) ) $ count ++ ; } return $ count ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function twoWaySort ( arr , n ) { for ( let i = 0 ; i < n ; i ++ ) arr [ i ] *= - 1 ; arr . sort ( ( a , b ) => a - b ) ; for ( let i = 0 ; i < n ; i ++ ) if ( arr [ i ] & 1 ) arr [ i ] *= - 1 ; }
Ref: 
function twoWaySort ( & $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ arr [ $ i ] *= -1 ; sort ( $ arr ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] & 1 ) $ arr [ $ i ] *= -1 ; }
Hyp: 
function twoWaySort ( & $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ arr [ $ i ] *= -1 ; sort ( $ arr ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] & 1 ) $ arr [ $ i ] *= -1 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function numBoxes ( A , n , K ) { A . sort ( function ( a , b ) { return a - b } ) ; let i = 0 , j = ( n - 1 ) ; let ans = 0 ; while ( i <= j ) { ans ++ ; if ( A [ i ] + A [ j ] <= K ) i ++ ; j -- ; } return ans ; }
Ref: 
function numBoxes ( $ A , $ n , $ K ) { sort ( $ A ) ; $ i = 0 ; $ j = $ n - 1 ; $ ans = 0 ; while ( $ i <= $ j ) { $ ans ++ ; if ( $ A [ $ i ] + $ A [ $ j ] <= $ K ) $ i ++ ; $ j -- ; } return $ ans ; }
Hyp: 
function numBoxes ( $ A , $ n , $ K ) { sort ( $ A ) ; $ i = 0 ; $ j = ( $ n - 1 ) ; $ ans = 0 ; while ( $ i <= $ j ) { $ ans ++ ; if ( $ A [ $ i ] + $ A [ $ j ] <= $ K ) $ i ++ ; $ j -- ; } return $ ans ; }

BLEU: 94.01
Edit Sim: 4


Src: 
function countCountries ( ans , N ) { let total_countries = 0 , i = 0 ; let invalid = false ; while ( i < N ) { let curr_size = ans [ i ] ; let num = ans [ i ] ; while ( num > 0 ) { if ( ans [ i ] != curr_size ) { document . write ( " " ) ; return ; } else num -- ; i ++ ; } total_countries ++ ; } document . write ( " " + total_countries + " " ) ; }
Ref: 
function countCountries ( $ ans , $ N ) { $ total_countries = 0 ; $ i = 0 ; $ invalid = false ; while ( $ i < $ N ) { $ curr_size = $ ans [ $ i ] ; $ num = $ ans [ $ i ] ; while ( $ num > 0 ) { if ( $ ans [ $ i ] != $ curr_size ) { echo " Invalid ▁ Answer STRNEWLINE " ; return ; } else $ num -- ; $ i ++ ; } $ total_countries ++ ; } echo " There ▁ are ▁ " , $ total_countries , " ▁ distinct ▁ companies ▁ in ▁ the ▁ group . STRNEWLINE " ; }
Hyp: 
function countCountries ( $ ans , $ N ) { $ total_countries = 0 ; $ i = 0 ; $ invalid = false ; while ( $ i < $ N ) { $ curr_size = $ ans [ $ i ] ; $ num = $ ans [ $ i ] ; while ( $ num > 0 ) { if ( $ ans [ $ i ] != $ curr_size ) { echo " Invalid ▁ country " ; return ; } else $ num -- ; $ i ++ ; } $ total_countries ++ ; } echo " Total ▁ of ▁ countries ▁ are ▁ : ▁ " , $ total_countries , " STRNEWLINE " ; }

BLEU: 85.27
Edit Sim: 72


Src: 
function countObtuseAngles ( a , b , k ) { var c1 = ( b - a ) - 1 ; var c2 = ( k - b ) + ( a - 1 ) ; if ( c1 == c2 ) return 0 ; return Math . min ( c1 , c2 ) ; }
Ref: 
function countObtuseAngles ( $ a , $ b , $ k ) { $ c1 = ( $ b - $ a ) - 1 ; $ c2 = ( $ k - $ b ) + ( $ a - 1 ) ; if ( $ c1 == $ c2 ) return 0 ; return min ( $ c1 , $ c2 ) ; }
Hyp: 
function countObtuseAngles ( $ a , $ b , $ k ) { $ c1 = ( $ b - $ a ) - 1 ; $ c2 = ( $ k - $ b ) + ( $ a - 1 ) ; if ( $ c1 == $ c2 ) return 0 ; return min ( $ c1 , $ c2 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findSmallestDifference ( A , B , m , n ) { A . sort ( ( a , b ) => a - b ) ; B . sort ( ( a , b ) => a - b ) ; let a = 0 , b = 0 ; let result = Number . MAX_SAFE_INTEGER ; while ( a < m && b < n ) { if ( Math . abs ( A [ a ] - B [ b ] ) < result ) result = Math . abs ( A [ a ] - B [ b ] ) ; if ( A [ a ] < B [ b ] ) a ++ ; else b ++ ; } return result ; }
Ref: 
function findSmallestDifference ( $ A , $ B , $ m , $ n ) { sort ( $ A ) ; sort ( $ A , $ m ) ; sort ( $ B ) ; sort ( $ B , $ n ) ; $ a = 0 ; $ b = 0 ; $ INT_MAX = 1 ; $ result = $ INT_MAX ; while ( $ a < $ m && $ b < $ n ) { if ( abs ( $ A [ $ a ] - $ B [ $ b ] ) < $ result ) $ result = abs ( $ A [ $ a ] - $ B [ $ b ] ) ; if ( $ A [ $ a ] < $ B [ $ b ] ) $ a ++ ; else $ b ++ ; } return $ result ; } { $ A = array ( 1 , 2 , 11 , 5 ) ; $ B = array ( 4 , 12 , 19 , 23 , 127 , 235 ) ; $ m = sizeof ( $ A ) / sizeof ( $ A [ 0 ] ) ; $ n = sizeof ( $ B ) / sizeof ( $ B [ 0 ] ) ; echo findSmallestDifference ( $ A , $ B , $ m , $ n ) ; return 0 ; }
Hyp: 
function findSmallestDifference ( $ A , $ B , $ m , $ n ) { sort ( $ A ) ; sort ( $ B ) ; $ a = 0 ; $ b = 0 ; $ result = PHP_INT_MAX ; while ( $ a < $ m && $ b < $ n ) { if ( abs ( $ A [ $ a ] - $ B [ $ b ] ) < $ result ) $ result = abs ( $ A [ $ a ] - $ B [ $ b ] ) ; if ( $ A [ $ a ] < $ B [ $ b ] ) $ a ++ ; else $ b ++ ; } return $ result ; }

BLEU: 41.23
Edit Sim: 305


Src: 
function subString ( str , n ) { for ( let len = 1 ; len <= n ; len ++ ) { for ( let i = 0 ; i <= n - len ; i ++ ) { let j = i + len - 1 ; for ( let k = i ; k <= j ; k ++ ) { document . write ( str [ k ] ) ; } document . write ( " " ) ; } } }
Ref: 
function subString ( $ str , $ n ) { for ( $ len = 1 ; $ len <= $ n ; $ len ++ ) { for ( $ i = 0 ; $ i <= $ n - $ len ; $ i ++ ) { $ j = $ i + $ len - 1 ; for ( $ k = $ i ; $ k <= $ j ; $ k ++ ) echo $ str [ $ k ] ; echo " STRNEWLINE " ; } } }
Hyp: 
function subString ( $ str , $ n ) { for ( $ len = 1 ; $ len <= $ n ; $ len ++ ) { for ( $ i = 0 ; $ i <= $ n - $ len ; $ i ++ ) { $ j = $ i + $ len - 1 ; for ( $ k = $ i ; $ k <= $ j ; $ k ++ ) { echo $ str [ $ k ] ; } echo " ▁ " ; } }

BLEU: 92.48
Edit Sim: 16


Src: 
function swap ( xp , yp ) { xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] ; yp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] ; xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] ; }
Ref: 
function swap ( & $ xp , & $ yp ) { $ xp = $ xp ^ $ yp ; $ yp = $ xp ^ $ yp ; $ xp = $ xp ^ $ yp ; }
Hyp: 
function swap ( & $ xp , & $ yp ) { $ xp [ 0 ] = $ xp [ 0 ] ^ $ yp [ 0 ] ; $ yp [ 0 ] = $ xp [ 0 ] ^ $ yp [ 0 ] ; $ xp [ 0 ] = $ xp [ 0 ] ^ $ yp [ 0 ] ; }

BLEU: 35.78
Edit Sim: 54


Src: 
function isPerfect ( n ) { sum = 1 ; for ( let i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( i * i != n ) sum = sum + i + n / i ; else sum = sum + i ; } } if ( sum == n && n != 1 ) return true ; return false ; }
Ref: 
function isPerfect ( $ n ) { $ sum = 1 ; for ( $ i = 2 ; $ i * $ i <= $ n ; $ i ++ ) { if ( $ n % $ i == 0 ) { if ( $ i * $ i != $ n ) $ sum = $ sum + $ i + ( int ) ( $ n / $ i ) ; else $ sum = $ sum + $ i ; } } if ( $ sum == $ n && $ n != 1 ) return true ; return false ; }
Hyp: 
function isPerfect ( $ n ) { $ sum = 1 ; for ( $ i = 2 ; $ i * $ i <= $ n ; $ i ++ ) { if ( $ n % $ i == 0 ) { if ( $ i * $ i != $ n ) $ sum = $ sum + $ i + $ n / $ i ; else $ sum = $ sum + $ i ; } } if ( $ sum == $ n && $ n != 1 ) return true ; return false ; }

BLEU: 92.35
Edit Sim: 12


Src: 
function areAllBitsSet ( n ) { if ( n == 0 ) return " " ; if ( ( ( n + 1 ) & n ) == 0 ) return " " ; return " " ; }
Ref: 
function areAllBitsSet ( $ n ) { if ( $ n == 0 ) return " No " ; if ( ( ( $ n + 1 ) & $ n ) == 0 ) return " Yes " ; return " No " ; }
Hyp: 
function areAllBitsSet ( $ n ) { if ( $ n == 0 ) return "0" ; if ( ( ( $ n + 1 ) & $ n ) == 0 ) return "1" ; return "0" ; }

BLEU: 70.36
Edit Sim: 13


Src: 
function numOfCombinations ( arr , N ) { let C = [ 0 , 0 , 0 ] ; for ( let i = 0 ; i < N ; ++ i ) ++ C [ arr [ i ] % 3 ] ; return C [ 1 ] * C [ 2 ] + C [ 0 ] * ( C [ 0 ] - 1 ) / 2 + C [ 0 ] * ( C [ 0 ] - 1 ) * ( C [ 0 ] - 2 ) / 6 + C [ 1 ] * ( C [ 1 ] - 1 ) * ( C [ 1 ] - 2 ) / 6 + C [ 2 ] * ( C [ 2 ] - 1 ) * ( C [ 2 ] - 2 ) / 6 + C [ 0 ] * C [ 1 ] * C [ 2 ] ; }
Ref: 
function numOfCombinations ( $ arr , $ N ) { $ C = array ( 0 , 0 , 0 ) ; for ( $ i = 0 ; $ i < $ N ; ++ $ i ) ++ $ C [ $ arr [ $ i ] % 3 ] ; return $ C [ 1 ] * $ C [ 2 ] + $ C [ 0 ] * ( $ C [ 0 ] - 1 ) / 2 + $ C [ 0 ] * ( $ C [ 0 ] - 1 ) * ( $ C [ 0 ] - 2 ) / 6 + $ C [ 1 ] * ( $ C [ 1 ] - 1 ) * ( $ C [ 1 ] - 2 ) / 6 + $ C [ 2 ] * ( $ C [ 2 ] - 1 ) * ( $ C [ 2 ] - 2 ) / 6 + $ C [ 0 ] * $ C [ 1 ] * $ C [ 2 ] ; }
Hyp: 
function numOfCombinations ( $ arr , $ N ) { $ C = array ( 0 , 0 , 0 ) ; for ( $ i = 0 ; $ i < $ N ; ++ $ i ) ++ $ C [ $ arr [ $ i ] % 3 ] ; return $ C [ 1 ] * $ C [ 2 ] + $ C [ 0 ] * ( $ C [ 0 ] - 1 ) / 2 + $ C [ 0 ] * ( $ C [ 0 ] - 1 ) * ( $ C [ 0 ] - 2 ) / 6 + $ C [ 1 ] * ( $ C [ 1 ] - 1 ) * ( $ C [ 1 ] - 2 ) / 6 + $ C [ 2 ] * ( $ C [ 2 ] - 1 ) * ( $ C [ 2 ] - 2 ) / 6 + $ C [ 0 ] * $ C [ 1 ] * $ C [ 2 ] ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function isKthBitSet ( n , k ) { if ( ( n & ( 1 << ( k - 1 ) ) ) > 0 ) document . write ( " " ) ; else document . write ( " " ) ; }
Ref: 
function isKthBitSet ( $ n , $ k ) { if ( $ n & ( 1 << ( $ k - 1 ) ) ) echo " SET " ; else echo " NOT ▁ SET " ; }
Hyp: 
function isKthBitSet ( $ n , $ k ) { if ( ( $ n & ( 1 << ( $ k - 1 ) ) ) > 0 ) echo " Yes " ; else echo " No " ; }

BLEU: 73.74
Edit Sim: 19


Src: 
function firstDigit ( x ) { while ( x >= 10 ) x = x / 10 ; return Math . floor ( x ) ; }
Ref: 
function firstDigit ( $ x ) { while ( $ x >= 10 ) $ x = $ x / 10 ; return floor ( $ x ) ; }
Hyp: 
function firstDigit ( $ x ) { while ( $ x >= 10 ) $ x = $ x / 10 ; return floor ( $ x ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findCountOfPairs ( a , b , n ) { let ans = 0 ; for ( let i = 1 ; i <= a ; i ++ ) { ans += parseInt ( b / n , 10 ) ; ans += ( i % n + b % n ) >= n ? 1 : 0 ; } return ans ; }
Ref: 
function findCountOfPairs ( $ a , $ b , $ n ) { $ ans = 0 ; for ( $ i = 1 ; $ i <= $ a ; $ i ++ ) { $ ans += ( int ) ( $ b / $ n ) ; $ ans += ( ( $ i % $ n ) + ( $ b % $ n ) ) >= $ n ? 1 : 0 ; } return $ ans ; }
Hyp: 
function findCountOfPairs ( $ a , $ b , $ n ) { $ ans = 0 ; for ( $ i = 1 ; $ i <= $ a ; $ i ++ ) { $ ans += ( int ) ( $ b / $ n ) ; $ ans += ( $ i % $ n + $ b % $ n ) >= $ n ? 1 : 0 ; } return $ ans ; }

BLEU: 90.51
Edit Sim: 8


Src: 
function sumOfSeries ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) for ( let j = 1 ; j <= i ; j ++ ) sum += j ; return sum ; }
Ref: 
function sumOfSeries ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) for ( $ j = 1 ; $ j <= $ i ; $ j ++ ) $ sum += $ j ; return $ sum ; }
Hyp: 
function sumOfSeries ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) for ( $ j = 1 ; $ j <= $ i ; $ j ++ ) $ sum += $ j ; return $ sum ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function isProductEven ( arr , n ) { for ( let i = 0 ; i < n ; i ++ ) if ( ( arr [ i ] & 1 ) == 0 ) return true ; return false ; }
Ref: 
function isProductEven ( $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( ( $ arr [ $ i ] & 1 ) == 0 ) return true ; return false ; }
Hyp: 
function isProductEven ( $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( ( $ arr [ $ i ] & 1 ) == 0 ) return true ; return false ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function setleftmostunsetbit ( n ) { if ( ( n & ( n + 1 ) ) == 0 ) return n ; let pos = 0 ; for ( let temp = n , count = 0 ; temp > 0 ; temp >>= 1 , count ++ ) if ( ( temp & 1 ) == 0 ) pos = count ; return ( n | ( 1 << ( pos ) ) ) ; }
Ref: 
function setleftmostunsetbit ( $ n ) { if ( ( $ n & ( $ n + 1 ) ) == 0 ) return $ n ; $ pos = 0 ; for ( $ temp = $ n , $ count = 0 ; $ temp > 0 ; $ temp >>= 1 , $ count ++ ) if ( ( $ temp & 1 ) == 0 ) $ pos = $ count ; return ( $ n | ( 1 << ( $ pos ) ) ) ; }
Hyp: 
function setleftmostunsetbit ( $ n ) { if ( ( $ n & ( $ n + 1 ) ) == 0 ) return $ n ; $ pos = 0 ; for ( $ temp = $ n , $ count = 0 ; $ temp > 0 ; $ temp >>= 1 , $ count ++ ) if ( ( $ temp & 1 ) == 0 ) $ pos = $ count ; return ( $ n | ( 1 << ( $ pos ) ) ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countsubarray ( array , n , k ) { var count = 0 ; var i , j , mul ; for ( i = 0 ; i < n ; i ++ ) { if ( array [ i ] < k ) count ++ ; mul = array [ i ] ; for ( j = i + 1 ; j < n ; j ++ ) { mul = mul * array [ j ] ; if ( mul < k ) count ++ ; else break ; } } return count ; }
Ref: 
function countsubarray ( $ array , $ n , $ k ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ array [ $ i ] < $ k ) $ count ++ ; $ mul = $ array [ $ i ] ; for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) { $ mul = $ mul * $ array [ $ j ] ; if ( $ mul < $ k ) $ count ++ ; else break ; } } return $ count ; }
Hyp: 
function countsubarray ( $ array , $ n , $ k ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ array [ $ i ] < $ k ) $ count ++ ; $ mul = $ array [ $ i ] ; for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) { $ mul = $ mul * $ array [ $ j ] ; if ( $ mul < $ k ) $ count ++ ; else break ; } } return $ count ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function sumOfSeries ( n ) { let ans = 0 ; for ( let i = 1 ; i <= n ; i ++ ) ans += i * i * i * i ; return ans ; }
Ref: 
function sumOfSeries ( $ n ) { $ ans = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ ans += $ i * $ i * $ i * $ i ; return $ ans ; }
Hyp: 
function sumOfSeries ( $ n ) { $ ans = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ ans += $ i * $ i * $ i * $ i ; return $ ans ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function isMagic ( n ) { var sum = 0 ; while ( n > 0 sum > 9 ) { if ( n = 0 ) { n = sum ; sum = 0 ; } sum += n % 10 ; n /= 10 ; } return ( sum = 1 ) ; }
Ref: 
function isMagic ( $ n ) { $ sum = 0 ; while ( $ n > 0 $ sum > 9 ) { if ( $ n == 0 ) { $ n = $ sum ; $ sum = 0 ; } $ sum += $ n % 10 ; $ n /= 10 ; } return ( $ sum == 1 ) ; }
Hyp: 
function isMagic ( $ n ) { $ sum = 0 ; while ( $ n > 0 $ sum > 9 ) { if ( $ n = 0 ) { $ n = $ sum ; $ sum = 0 ; } $ sum += $ n % 10 ; $ n /= 10 ; } return ( $ sum = 1 ) ; }

BLEU: 92.36
Edit Sim: 2


Src: 
function setBitNumber ( n ) { if ( n == 0 ) return 0 ; let msb = 0 ; n = n / 2 ; while ( n != 0 ) { n = $n / 2 ; msb ++ ; } return ( 1 << msb ) ; }
Ref: 
function setBitNumber ( $ n ) { if ( $ n == 0 ) return 0 ; $ msb = 0 ; $ n = $ n / 2 ; while ( $ n != 0 ) { $ n = $ n / 2 ; $ msb ++ ; } return ( 1 << $ msb ) ; }
Hyp: 
function setBitNumber ( $ n ) { if ( $ n == 0 ) return 0 ; $ msb = 0 ; $ n = $ n / 2 ; while ( $ n != 0 ) { $ n = $ n / 2 ; $ msb ++ ; } return ( 1 << $ msb ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function CountPairs ( n ) { let k = n ; let imin = 1 ; let ans = 0 ; while ( imin <= n ) { let imax = Math . floor ( n / k ) ; ans += k * ( imax - imin + 1 ) ; imin = imax + 1 ; k = Math . floor ( n / imin ) ; } return ans ; }
Ref: 
function CountPairs ( $ n ) { $ k = $ n ; $ imin = 1 ; $ ans = 0 ; while ( $ imin <= $ n ) { $ imax = $ n / $ k ; $ ans += $ k * ( $ imax - $ imin + 1 ) ; $ imin = $ imax + 1 ; $ k = ( int ) ( $ n / $ imin ) ; } return $ ans ; }
Hyp: 
function CountPairs ( $ n ) { $ k = $ n ; $ imin = 1 ; $ ans = 0 ; while ( $ imin <= $ n ) { $ imax = $ n / $ k ; $ ans += $ k * ( $ imax - $ imin + 1 ) ; $ imin = $ imax + 1 ; $ k = $ n / $ imin ; } return $ ans ; }

BLEU: 90.32
Edit Sim: 12


Src: 
function occurredOnce ( arr , n ) { var i = 1 , len = n ; if ( arr [ 0 ] == arr [ len - 1 ] ) { i = 2 ; len -- ; } for ( ; i < n ; i ++ ) if ( arr [ i ] == arr [ i - 1 ] ) i ++ ; else document . write ( arr [ i - 1 ] + " " ) ; if ( arr [ n - 1 ] != arr [ 0 ] && arr [ n - 1 ] != arr [ n - 2 ] ) document . write ( arr [ n - 1 ] ) ; }
Ref: 
function occurredOnce ( & $ arr , $ n ) { $ i = 1 ; $ len = $ n ; if ( $ arr [ 0 ] == $ arr [ $ len - 1 ] ) { $ i = 2 ; $ len -- ; } for ( ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] == $ arr [ $ i - 1 ] ) $ i ++ ; else echo $ arr [ $ i - 1 ] . " ▁ " ; if ( $ arr [ $ n - 1 ] != $ arr [ 0 ] && $ arr [ $ n - 1 ] != $ arr [ $ n - 2 ] ) echo $ arr [ $ n - 1 ] ; }
Hyp: 
function occurredOnce ( & $ arr , $ n ) { $ i = 1 ; $ len = $ n ; if ( $ arr [ 0 ] == $ arr [ $ len - 1 ] ) { $ i = 2 ; $ len -- ; } for ( ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] == $ arr [ $ i - 1 ] ) $ i ++ ; else echo $ arr [ $ i - 1 ] . " ▁ " ; if ( $ arr [ $ n - 1 ] != $ arr [ 0 ] && $ arr [ $ n - 1 ] != $ arr [ $ n - 2 ] ) echo $ arr [ $ n - 1 ] ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function squaresum ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) sum += ( i * i ) ; return sum ; }
Ref: 
function squaresum ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ sum += ( $ i * $ i ) ; return $ sum ; }
Hyp: 
function squaresum ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ sum += ( $ i * $ i ) ; return $ sum ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function minRevolutions ( r , x1 , y1 , x2 , y2 ) { let d = Math . sqrt ( ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ) ; return Math . ceil ( d / ( 2 * r ) ) ; }
Ref: 
function minRevolutions ( $ r , $ x1 , $ y1 , $ x2 , $ y2 ) { $ d = sqrt ( ( $ x1 - $ x2 ) * ( $ x1 - $ x2 ) + ( $ y1 - $ y2 ) * ( $ y1 - $ y2 ) ) ; return ceil ( $ d / ( 2 * $ r ) ) ; }
Hyp: 
function minRevolutions ( $ r , $ x1 , $ y1 , $ x2 , $ y2 ) { $ d = sqrt ( ( $ x1 - $ x2 ) * ( $ x1 - $ x2 ) + ( $ y1 - $ y2 ) * ( $ y1 - $ y2 ) ) ; return ceil ( $ d / ( 2 * $ r ) ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function printCoins ( arr , n ) { var oddSum = 0 ; for ( var i = 0 ; i < n ; i += 2 ) oddSum += arr [ i ] ; var evenSum = 0 ; for ( var i = 1 ; i < n ; i += 2 ) evenSum += arr [ i ] ; var start = ( ( oddSum > evenSum ) ? 0 : 1 ) ; for ( var i = start ; i < n ; i += 2 ) document . write ( arr [ i ] + " " ) ; }
Ref: 
function printCoins ( & $ arr , $ n ) { $ oddSum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i += 2 ) $ oddSum += $ arr [ $ i ] ; $ evenSum = 0 ; for ( $ i = 1 ; $ i < $ n ; $ i += 2 ) $ evenSum += $ arr [ $ i ] ; $ start = ( ( $ oddSum > $ evenSum ) ? 0 : 1 ) ; for ( $ i = $ start ; $ i < $ n ; $ i += 2 ) echo $ arr [ $ i ] . " ▁ " ; }
Hyp: 
function printCoins ( $ arr , $ n ) { $ oddSum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i += 2 ) $ oddSum += $ arr [ $ i ] ; $ evenSum = 0 ; for ( $ i = 1 ; $ i < $ n ; $ i += 2 ) $ evenSum += $ arr [ $ i ] ; $ start = ( ( $ oddSum > $ evenSum ) ? 0 : 1 ) ; for ( $ i = $ start ; $ i < $ n ; $ i += 2 ) echo $ arr [ $ i ] , " ▁ " ; }

BLEU: 95.98
Edit Sim: 3


Src: 
function printCountRec ( dist ) { if ( dist < 0 ) return 0 ; if ( dist == 0 ) return 1 ; return printCountRec ( dist - 1 ) + printCountRec ( dist - 2 ) + printCountRec ( dist - 3 ) ; }
Ref: 
function printCountRec ( $ dist ) { if ( $ dist < 0 ) return 0 ; if ( $ dist == 0 ) return 1 ; return printCountRec ( $ dist - 1 ) + printCountRec ( $ dist - 2 ) + printCountRec ( $ dist - 3 ) ; }
Hyp: 
function printCountRec ( $ dist ) { if ( $ dist < 0 ) return 0 ; if ( $ dist == 0 ) return 1 ; return printCountRec ( $ dist - 1 ) + printCountRec ( $ dist - 2 ) + printCountRec ( $ dist - 3 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function getResult ( n ) { if ( ( n & 1 ) > 0 ) return 1 ; return - 1 ; }
Ref: 
function getResult ( $ n ) { if ( $ n & 1 ) return 1 ; return -1 ; }
Hyp: 
function getResult ( $ n ) { if ( ( $ n & 1 ) > 0 ) return 1 ; return -1 ; }

BLEU: 76.79
Edit Sim: 8


Src: 
function Nthterm ( n ) { let numerator = Math . pow ( n , 2 ) - 1 ; let denomenator = 2 * n - 3 ; document . write ( numerator + " " + denomenator ) ; }
Ref: 
function Nthterm ( $ n ) { $ numerator = ( pow ( $ n , 2 ) ) -1 ; $ denomenator = 2 * $ n - 3 ; echo $ numerator , " / " , $ denomenator ; return $ Tn ; }
Hyp: 
function Nthterm ( $ n ) { $ numerator = pow ( $ n , 2 ) - 1 ; $ denomenator = 2 * $ n - 3 ; echo $ numerator . " ▁ " . $ denomenator ; }

BLEU: 63.08
Edit Sim: 21


Src: 
function squares ( l , b , a ) { return parseInt ( Math . ceil ( l / a ) * Math . ceil ( b / a ) ) ; }
Ref: 
function squares ( $ l , $ b , $ a ) { return ceil ( $ l / ( double ) $ a ) * ceil ( $ b / ( double ) $ a ) ; }
Hyp: 
function squares ( $ l , $ b , $ a ) { return ceil ( $ l / $ a ) * ceil ( $ b / $ a ) ; }

BLEU: 75.23
Edit Sim: 22


Src: 
function countMoves ( n ) { let ct = 0 ; for ( let i = 1 ; i <= n ; i ++ ) ct += i * ( n - i ) ; ct += n ; return ct ; }
Ref: 
function countMoves ( $ n ) { $ ct = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ ct += $ i * ( $ n - $ i ) ; $ ct += $ n ; return $ ct ; }
Hyp: 
function countMoves ( $ n ) { $ ct = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ ct += $ i * ( $ n - $ i ) ; $ ct += $ n ; return $ ct ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countPieces ( N ) { return 2 * N ; }
Ref: 
function countPieces ( $ N ) { return 2 * $ N ; }
Hyp: 
function countPieces ( $ N ) { return 2 * $ N ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function sumOfSeries ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) sum = sum + ( 2 * i - 1 ) * ( 2 * i - 1 ) ; return sum ; }
Ref: 
function sumOfSeries ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ sum = $ sum + ( 2 * $ i - 1 ) * ( 2 * $ i - 1 ) ; return $ sum ; }
Hyp: 
function sumOfSeries ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ sum = $ sum + ( 2 * $ i - 1 ) * ( 2 * $ i - 1 ) ; return $ sum ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function maxProd ( N ) { if ( N == 0 ) return 1 ; if ( N < 10 ) return N ; return Math . max ( maxProd ( parseInt ( N / 10 ) ) * ( N % 10 ) , maxProd ( parseInt ( N / 10 ) - 1 ) * 9 ) ; }
Ref: 
function maxProd ( $ N ) { if ( $ N == 0 ) return 1 ; if ( $ N < 10 ) return $ N ; return max ( maxProd ( ( int ) ( $ N / 10 ) ) * ( $ N % 10 ) , maxProd ( ( int ) ( $ N / 10 ) - 1 ) * 9 ) ; }
Hyp: 
function maxProd ( $ N ) { if ( $ N == 0 ) return 1 ; if ( $ N < 10 ) return $ N ; return max ( maxProd ( $ N / 10 ) ) * ( $ N % 10 ) , maxProd ( $ N / 10 - 1 ) * 9 ) ; }

BLEU: 81.83
Edit Sim: 22


Src: 
function diameter ( r ) { document . write ( " " + " " + 2 * r ) ; }
Ref: 
function diameter ( $ r ) { echo " The ▁ length ▁ of ▁ the ▁ longest ▁ chord " , " ▁ or ▁ diameter ▁ of ▁ the ▁ circle ▁ is ▁ " , 2 * $ r << " STRNEWLINE " ; }
Hyp: 
function diameter ( $ r ) { echo " The ▁ diameter ▁ of ▁ the ▁ circle ▁ is ▁ " , 2 * $ r ; }

BLEU: 48.08
Edit Sim: 67


Src: 
function strScore ( str , s , n ) { var score = 0 , index = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( str [ i ] == s ) { for ( j = 0 ; j < s . length ; j ++ ) { score += s . charAt ( j ) . charCodeAt ( 0 ) - ( ' ' ) . charCodeAt ( 0 ) + 1 ; } index = i + 1 ; break ; } } score = score * index ; return score ; }
Ref: 
function strScore ( $ str , $ s , $ n ) { $ score = 0 ; $ index ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ str [ $ i ] == $ s ) { for ( $ j = 0 ; $ j < strlen ( $ s ) ; $ j ++ ) $ score += ( ord ( $ s [ $ j ] ) - ord ( ' a ' ) ) + 1 ; $ index = ( $ i + 1 ) ; break ; } } $ score = $ score * $ index ; return $ score ; }
Hyp: 
function strScore ( $ str , $ s , $ n ) { $ score = 0 ; $ index = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ str [ $ i ] == $ s ) { for ( $ j = 0 ; $ j < strlen ( $ s ) ; $ j ++ ) { $ score += ord ( $ s [ $ j ] ) - ord ( '0' ) + 1 ; } $ index = $ i + 1 ; break ; } } $ score = $ score * $ index ; return $ score ; }

BLEU: 85.75
Edit Sim: 19


Src: 
function prletKPFNums ( A , B , K ) { let prime = [ ] ; for ( let i = 0 ; i < B + 1 ; i ++ ) prime [ i ] = true ; let p_factors = [ ] ; for ( let i = 0 ; i < B + 1 ; i ++ ) p_factors [ i ] = 0 ; for ( let p = 2 ; p <= B ; p ++ ) if ( p_factors [ p ] == 0 ) for ( let i = p ; i <= B ; i += p ) p_factors [ i ] ++ ; for ( let i = A ; i <= B ; i ++ ) if ( p_factors [ i ] == K ) document . write ( i + " " ) ; }
Ref: 
function printKPFNums ( $ A , $ B , $ K ) { $ prime = array_fill ( true , $ B + 1 , NULL ) ; $ p_factors = array_fill ( 0 , $ B + 1 , NULL ) ; for ( $ p = 2 ; $ p <= $ B ; $ p ++ ) if ( $ p_factors [ $ p ] == 0 ) for ( $ i = $ p ; $ i <= $ B ; $ i += $ p ) $ p_factors [ $ i ] ++ ; for ( $ i = $ A ; $ i <= $ B ; $ i ++ ) if ( $ p_factors [ $ i ] == $ K ) echo $ i . " " ; }
Hyp: 
function prletKPFNums ( $ A , $ B , $ K ) { $ prime = array ( ) ; for ( $ i = 0 ; $ i < $ B + 1 ; $ i ++ ) $ prime [ $ i ] = true ; $ p_factors = array ( ) ; for ( $ i = 0 ; $ i < $ B + 1 ; $ i ++ ) $ p_factors [ $ i ] = 0 ; for ( $ p = 2 ; $ p <= $ B ; $ p ++ ) if ( $ p_factors [ $ p ] == 0 ) for ( $ i = $ p ; $ i <= $ B ; $ i += $ p ) $ p_factors [ $ i ] ++ ; for ( $ i = $ A ; $ i <= $ B ; $ i ++ ) if ( $ p_factors [ $ i ] == $ K ) echo $ i . " ▁ " ; }

BLEU: 65.02
Edit Sim: 111


Src: 
function getInteger ( L , R ) { var number = 0 ; for ( var i = L ; i <= R ; i ++ ) number += Math . pow ( 2 , i ) ; return number ; }
Ref: 
function getInteger ( $ L , $ R ) { $ number = 0 ; for ( $ i = $ L ; $ i <= $ R ; $ i ++ ) $ number += pow ( 2 , $ i ) ; return $ number ; }
Hyp: 
function getInteger ( $ L , $ R ) { $ number = 0 ; for ( $ i = $ L ; $ i <= $ R ; $ i ++ ) $ number += pow ( 2 , $ i ) ; return $ number ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function largestKSubmatrix ( a ) { let dp = new Array ( Row ) ; for ( let i = 0 ; i < Row ; i ++ ) { dp [ i ] = new Array ( Col ) ; for ( let j = 0 ; j < Col ; j ++ ) { dp [ i ] [ j ] = 0 ; } } let result = 0 ; for ( let i = 0 ; i < Row ; i ++ ) { for ( let j = 0 ; j < Col ; j ++ ) { if ( i == 0 j == 0 ) dp [ i ] [ j ] = 1 ; else { if ( a [ i ] [ j ] == a [ i - 1 ] [ j ] && a [ i ] [ j ] == a [ i ] [ j - 1 ] && a [ i ] [ j ] == a [ i - 1 ] [ j - 1 ] ) { dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] > dp [ i ] [ j - 1 ] && dp [ i - 1 ] [ j ] > dp [ i - 1 ] [ j - 1 ] + 1 ) ? dp [ i - 1 ] [ j ] : ( dp [ i ] [ j - 1 ] > dp [ i - 1 ] [ j ] && dp [ i ] [ j - 1 ] > dp [ i - 1 ] [ j - 1 ] + 1 ) ? dp [ i ] [ j - 1 ] : dp [ i - 1 ] [ j - 1 ] + 1 ; } else dp [ i ] [ j ] = 1 ; } result = result > dp [ i ] [ j ] ? result : dp [ i ] [ j ] ; } } return result ; }
Ref: 
function largestKSubmatrix ( & $ a ) { global $ Row , $ Col ; $ result = 0 ; for ( $ i = 0 ; $ i < $ Row ; $ i ++ ) { for ( $ j = 0 ; $ j < $ Col ; $ j ++ ) { if ( $ i == 0 $ j == 0 ) $ dp [ $ i ] [ $ j ] = 1 ; else { if ( $ a [ $ i ] [ $ j ] == $ a [ $ i - 1 ] [ $ j ] && $ a [ $ i ] [ $ j ] == $ a [ $ i ] [ $ j - 1 ] && $ a [ $ i ] [ $ j ] == $ a [ $ i - 1 ] [ $ j - 1 ] ) $ dp [ $ i ] [ $ j ] = min ( min ( $ dp [ $ i - 1 ] [ $ j ] , $ dp [ $ i ] [ $ j - 1 ] ) , $ dp [ $ i - 1 ] [ $ j - 1 ] ) + 1 ; else $ dp [ $ i ] [ $ j ] = 1 ; } $ result = max ( $ result , $ dp [ $ i ] [ $ j ] ) ; } } return $ result ; }
Hyp: 
function largestKSubmatrix ( $ a ) { $ dp = array ( array ( ) ) ; for ( $ i = 0 ; $ i < $ Row ; $ i ++ ) for ( $ j = 0 ; $ j < $ Col ; $ j ++ ) $ dp [ $ i ] [ $ j ] = 0 ; $ result = 0 ; for ( $ i = 0 ; $ i < $ Row ; $ i ++ ) { for ( $ j = 0 ; $ j < $ Col ; $ j ++ ) { if ( $ a [ $ i ] [ $ j ] == $ a [ $ i - 1 ] [ $ j ] && $ a [ $ i ] [ $ j ] == $ a [ $ i - 1 ] [ $ j - 1 ] && $ a [ $ i ] [ $ j ] == $ a [ $ i - 1 ] [ $ j - 1 ] ) { $ dp [ $ i ] [ $ j ] = ( $ dp [ $ i - 1 ] [ $ j ] > $ dp [ $ i ] [ $ j - 1 ] && $ dp [ $ i - 1 ] [ $ j ] > $ dp [ $ i - 1 ] [ $ j - 1 ] + 1 ) ? $ dp [ $ i ] [ $ j - 1 ] : $ dp [ $ i - 1 ] [ $ j - 1 ] + 1 ; } else $ dp [ $ i ] [ $ j ] = 1 ; } $ result = $ result > $ dp [ $ i ] [ $ j ] ? $ result : $ dp [ $ i ] [ $ j ] ; } return $ result ; }

BLEU: 64.13
Edit Sim: 245


Src: 
function cal_minimum_time ( X ) { let t = 0 ; let sum = 0 ; while ( sum < X ) { t ++ ; sum = sum + t ; } return t ; }
Ref: 
function cal_minimum_time ( $ X ) { $ t = 0 ; $ sum = 0 ; while ( $ sum < $ X ) { $ t ++ ; $ sum = $ sum + $ t ; } return $ t ; }
Hyp: 
function cal_minimum_time ( $ X ) { $ t = 0 ; $ sum = 0 ; while ( $ sum < $ X ) { $ t ++ ; $ sum = $ sum + $ t ; } return $ t ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function getAverage ( x , y ) { var avg = ( x & y ) + ( ( x ^ y ) >> 1 ) ; return avg ; }
Ref: 
function getAverage ( $ x , $ y ) { $ avg = ( $ x & $ y ) + ( ( $ x ^ $ y ) >> 1 ) ; return $ avg ; }
Hyp: 
function getAverage ( $ x , $ y ) { $ avg = ( $ x & $ y ) + ( ( $ x ^ $ y ) >> 1 ) ; return $ avg ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findAandB ( N ) { let val = N * N - 4.0 * N ; if ( val < 0 ) { document . write ( " " ) ; return ; } let a = ( N + Math . sqrt ( val ) ) / 2.0 ; let b = ( N - Math . sqrt ( val ) ) / 2.0 ; document . write ( " " + a . toFixed ( 4 ) + " " ) ; document . write ( " " + b . toFixed ( 5 ) ) ; }
Ref: 
function findAandB ( $ N ) { $ val = $ N * $ N - 4.0 * $ N ; if ( $ val < 0 ) { echo " NO " ; return ; } $ a = ( $ N + sqrt ( $ val ) ) / 2.0 ; $ b = ( $ N - sqrt ( $ val ) ) / 2.0 ; echo " a = " ▁ , ▁ $ a , ▁ " " ; STRNEWLINE TABSYMBOL echo ▁ " b = " ▁ , ▁ $ b , ▁ " " }
Hyp: 
function findAandB ( $ N ) { $ val = $ N * $ N - 4.0 * $ N ; if ( $ val < 0 ) { echo " Invalid ▁ Input " ; return ; } $ a = ( $ N + sqrt ( $ val ) ) / 2.0 ; $ b = ( $ N - sqrt ( $ val ) ) / 2.0 ; echo " A = " , $ a , " STRNEWLINE " ; echo " B = " , $ b , " STRNEWLINE " ; }

BLEU: 73.89
Edit Sim: 54


Src: 
function numberOfSticks ( x ) { return ( 3 * x * ( x + 1 ) ) / 2 ; }
Ref: 
function numberOfSticks ( $ x ) { return ( 3 * $ x * ( $ x + 1 ) ) / 2 ; }
Hyp: 
function numberOfSticks ( $ x ) { return ( 3 * $ x * ( $ x + 1 ) ) / 2 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function calculateEvenSum ( n ) { if ( n <= 0 ) return 0 ; let fibo = Array ( 2 * n + 1 ) ; fibo [ 0 ] = 0 ; fibo [ 1 ] = 1 ; let sum = 0 ; for ( i = 2 ; i <= 2 * n ; i ++ ) { fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ; if ( i % 2 == 0 ) sum += fibo [ i ] ; } return sum ; }
Ref: 
function calculateEvenSum ( $ n ) { if ( $ n <= 0 ) return 0 ; $ fibo [ 2 * $ n + 1 ] = array ( ) ; $ fibo [ 0 ] = 0 ; $ fibo [ 1 ] = 1 ; $ sum = 0 ; for ( $ i = 2 ; $ i <= 2 * $ n ; $ i ++ ) { $ fibo [ $ i ] = $ fibo [ $ i - 1 ] + $ fibo [ $ i - 2 ] ; if ( $ i % 2 == 0 ) $ sum += $ fibo [ $ i ] ; } return $ sum ; }
Hyp: 
function calculateEvenSum ( $ n ) { if ( $ n <= 0 ) return 0 ; $ fibo = array ( ) ; $ fibo [ 0 ] = 0 ; $ fibo [ 1 ] = 1 ; $ sum = 0 ; for ( $ i = 2 ; $ i <= 2 * $ n ; $ i ++ ) { $ fibo [ $ i ] = $ fibo [ $ i - 1 ] + $ fibo [ $ i - 2 ] ; if ( $ i % 2 == 0 ) $ sum += $ fibo [ $ i ] ; } return $ sum ; }

BLEU: 92.04
Edit Sim: 16


Src: 
function sumOfSeries ( n ) { return ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; }
Ref: 
function sumOfSeries ( $ n ) { return ( $ n * ( $ n + 1 ) * ( 2 * $ n + 1 ) ) / 6 ; }
Hyp: 
function sumOfSeries ( $ n ) { return ( $ n * ( $ n + 1 ) * ( 2 * $ n + 1 ) ) / 6 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function nthOdd ( n ) { return ( 2 * n - 1 ) ; }
Ref: 
function nthOdd ( $ n ) { return ( 2 * $ n - 1 ) ; }
Hyp: 
function nthOdd ( $ n ) { return ( 2 * $ n - 1 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countSegments ( a , n , x ) { let flag = false ; let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] > x ) { flag = true ; } else { if ( flag ) count += 1 ; flag = false ; } } if ( flag ) count += 1 ; return count ; }
Ref: 
function countSegments ( $ a , $ n , $ x ) { $ flag = false ; $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] > $ x ) { $ flag = true ; } else { if ( $ flag ) $ count += 1 ; $ flag = false ; } } if ( $ flag ) $ count += 1 ; return $ count ; }
Hyp: 
function countSegments ( $ a , $ n , $ x ) { $ flag = false ; $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] > $ x ) { $ flag = true ; } else { if ( $ flag ) $ count += 1 ; $ flag = false ; } } if ( $ flag ) $ count += 1 ; return $ count ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function LeadingZeros ( x , y ) { if ( ( x ^ y ) <= ( x & y ) ) document . write ( " " ) ; else if ( ( x & ( ~ y ) ) > y ) document . write ( y ) ; else document . write ( x ) ; }
Ref: 
function LeadingZeros ( $ x , $ y ) { if ( ( $ x ^ $ y ) <= ( $ x & $ y ) ) echo " Equal " else if ( ( $ x & ( ~ $ y ) ) > $ y ) echo $ y ; else echo $ x ; }
Hyp: 
function LeadingZeros ( $ x , $ y ) { if ( ( $ x ^ $ y ) <= ( $ x & $ y ) ) echo "0" ; else if ( ( $ x & ( ~ $ y ) ) > $ y ) echo $ y ; else echo $ x ; }

BLEU: 92.25
Edit Sim: 7


Src: 
function countCon ( ar , n ) { let cnt = 0 ; for ( let i = 0 ; i < n - 1 ; i ++ ) { if ( ar [ i ] == ar [ i + 1 ] ) cnt ++ ; } return cnt ; }
Ref: 
function countCon ( $ ar , $ n ) { $ cnt = 0 ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { if ( $ ar [ $ i ] == $ ar [ $ i + 1 ] ) $ cnt ++ ; } return $ cnt ; }
Hyp: 
function countCon ( & $ ar , $ n ) { $ cnt = 0 ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { if ( $ ar [ $ i ] == $ ar [ $ i + 1 ] ) $ cnt ++ ; } return $ cnt ; }

BLEU: 96.01
Edit Sim: 2


Src: 
function transformString ( ) { var ch = ' ' ; if ( s . length < 26 ) return false ; for ( var i = 0 ; i < s . length ; i ++ ) { if ( ch . charCodeAt ( 0 ) > 122 ) break ; if ( s [ i ] . charCodeAt ( 0 ) <= ch . charCodeAt ( 0 ) ) { s [ i ] = ch ; ch = String . fromCharCode ( ch . charCodeAt ( 0 ) + 1 ) ; } } s = s . join ( ' ' ) if ( ch . charCodeAt ( 0 ) <= ' ' . charCodeAt ( 0 ) ) return false ; return true ; }
Ref: 
function transformString ( & $ s ) { $ ch = " a " ; if ( strlen ( $ s ) < 26 ) return false ; for ( $ i = 0 ; $ i < strlen ( $ s ) ; $ i ++ ) { if ( ord ( $ ch ) > ord ( " z " ) ) break ; if ( $ s [ $ i ] <= $ ch ) { $ s [ $ i ] = $ ch ; $ ch = chr ( ord ( $ ch ) + 1 ) ; } } if ( $ ch <= " z " ) return false ; return true ; }
Hyp: 
function transformString ( & $ s ) { $ ch = ' a ' ; if ( strlen ( $ s ) < 26 ) return false ; for ( $ i = 0 ; $ i < strlen ( $ s ) ; $ i ++ ) { if ( ord ( $ s [ $ i ] ) > 122 ) break ; if ( ord ( $ s [ $ i ] ) <= ord ( $ ch ) ) { $ s [ $ i ] = $ ch ; $ ch ++ ; } } $ s = explode ( ' a ' , $ s ) ; if ( ord ( $ ch ) <= ord ( ' z ' ) ) return false ; return true ; }

BLEU: 65.92
Edit Sim: 74


Src: 
function boost_hyperfactorial ( num ) { var val = 1 ; for ( var i = 1 ; i <= num ; i ++ ) { for ( var j = 1 ; j <= i ; j ++ ) { val *= i ; } } return val ; }
Ref: 
function boost_hyperfactorial ( $ num ) { $ val = 1 ; for ( $ i = 1 ; $ i <= $ num ; $ i ++ ) { for ( $ j = 1 ; $ j <= $ i ; $ j ++ ) { $ val *= $ i ; } } return $ val ; }
Hyp: 
function boost_hyperfactorial ( $ num ) { $ val = 1 ; for ( $ i = 1 ; $ i <= $ num ; $ i ++ ) { for ( $ j = 1 ; $ j <= $ i ; $ j ++ ) { $ val *= $ i ; } } return $ val ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function checkPairs ( l , r ) { if ( ( l - r ) % 2 == 0 ) return false ; return true ; }
Ref: 
function checkPairs ( $ l , $ r ) { if ( ( $ l - $ r ) % 2 == 0 ) return false ; return true ; }
Hyp: 
function checkPairs ( $ l , $ r ) { if ( ( $ l - $ r ) % 2 == 0 ) return false ; return true ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function ReuleauxArea ( a ) { if ( a < 0 ) return - 1 ; var A = 0.70477 * Math . pow ( a , 2 ) ; return A ; }
Ref: 
function ReuleauxArea ( $ a ) { if ( $ a < 0 ) return -1 ; $ A = 0.70477 * pow ( $ a , 2 ) ; return $ A ; }
Hyp: 
function ReuleauxArea ( $ a ) { if ( $ a < 0 ) return -1 ; $ A = 0.70477 * pow ( $ a , 2 ) ; return $ A ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function multiplyBySevenByEight ( n ) { return ( n - ( n >> 3 ) ) ; }
Ref: 
function multiplyBySevenByEight ( $ n ) { return ( $ n - ( $ n >> 3 ) ) ; }
Hyp: 
function multiplyBySevenByEight ( $ n ) { return ( $ n - ( $ n >> 3 ) ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findNumber ( n , m ) { var num = ( m - 1 ) * 9 + n ; return num ; }
Ref: 
function findNumber ( $ n , $ m ) { $ num = ( $ m - 1 ) * 9 + $ n ; return $ num ; }
Hyp: 
function findNumber ( $ n , $ m ) { $ num = ( $ m - 1 ) * 9 + $ n ; return $ num ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countPairsWithDiffK ( arr , n , k ) { count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] - arr [ j ] == k arr [ j ] - arr [ i ] == k ) count ++ ; } return count ; }
Ref: 
function countPairsWithDiffK ( $ arr , $ n , $ k ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) if ( $ arr [ $ i ] - $ arr [ $ j ] == $ k or $ arr [ $ j ] - $ arr [ $ i ] == $ k ) $ count ++ ; } return $ count ; }
Hyp: 
function countPairsWithDiffK ( & $ arr , $ n , $ k ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) if ( $ arr [ $ i ] - $ arr [ $ j ] == $ k $ arr [ $ j ] - $ arr [ $ i ] == $ k ) $ count ++ ; } return $ count ; }

BLEU: 96.01
Edit Sim: 5


Src: 
function maxvolume ( s ) { let maxvalue = 0 ; for ( let i = 1 ; i <= s - 2 ; i ++ ) { for ( let j = 1 ; j <= s - 1 ; j ++ ) { let k = s - i - j ; maxvalue = Math . max ( maxvalue , i * j * k ) ; } } return maxvalue ; }
Ref: 
function maxvolume ( $ s ) { $ maxvalue = 0 ; for ( $ i = 1 ; $ i <= $ s - 2 ; $ i ++ ) { for ( $ j = 1 ; $ j <= $ s - 1 ; $ j ++ ) { $ k = $ s - $ i - $ j ; $ maxvalue = max ( $ maxvalue , $ i * $ j * $ k ) ; } } return $ maxvalue ; }
Hyp: 
function maxvolume ( $ s ) { $ maxvalue = 0 ; for ( $ i = 1 ; $ i <= $ s - 2 ; $ i ++ ) { for ( $ j = 1 ; $ j <= $ s - 1 ; $ j ++ ) { $ k = $ s - $ i - $ j ; $ maxvalue = max ( $ maxvalue , $ i * $ j * $ k ) ; } } return $ maxvalue ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function maxFraction ( first , sec ) { a = first [ 0 ] ; b = first [ 1 ] c = sec [ 0 ] ; d = sec [ 1 ] Y = a * d - b * c return ( Y > 0 ) ? first : sec ; }
Ref: 
function maxFraction ( $ first , $ sec ) { $ a = $ first [ 0 ] ; $ b = $ first [ 1 ] ; $ c = $ sec [ 0 ] ; $ d = $ sec [ 1 ] ; $ Y = $ a * $ d - $ b * $ c ; return ( $ Y ) ? $ first : $ sec ; }
Hyp: 
function maxFraction ( $ first , $ sec ) { $ a = $ first [ 0 ] ; $ b = $ first [ 1 ] $ c = $ sec [ 0 ] ; $ d = $ sec [ 1 ] Y = $ a * $ d - $ b * $ c return ( $ Y > 0 ) ? $ first : $ sec ; }

BLEU: 86.05
Edit Sim: 12


Src: 
function Identity ( num ) { var row ; var col ; for ( row = 0 ; row < num ; row ++ ) { for ( col = 0 ; col < num ; col ++ ) { if ( row == col ) document . write ( 1 + " " ) ; else document . write ( 0 + " " ) ; } document . write ( " " + " " ) ; } return 0 ; }
Ref: 
function Identity ( $ num ) { $ row ; $ col ; for ( $ row = 0 ; $ row < $ num ; $ row ++ ) { for ( $ col = 0 ; $ col < $ num ; $ col ++ ) { if ( $ row == $ col ) echo 1 , " ▁ " ; else echo 0 , " ▁ " ; } echo " STRNEWLINE " ; } return 0 ; }
Hyp: 
function Identity ( $ num ) { $ row ; $ col ; for ( $ row = 0 ; $ row < $ num ; $ row ++ ) { for ( $ col = 0 ; $ col < $ num ; $ col ++ ) { if ( $ row == $ col ) echo 1 . " " ; else echo 0 . " " ; } echo " Identity ▁ is ▁ " ; } return 0 ; }

BLEU: 86.88
Edit Sim: 21


Src: 
function print_C ( p0 ) { let p1 = 0 ; let i = 0 ; let x ; let flag ; let k ; while ( 1 ) { flag = 1 ; x = Math . pow ( 2 , i ) ; p1 = x * p0 + ( x - 1 ) ; for ( let k = 2 ; k < p1 ; k ++ ) { if ( p1 % k == 0 ) { flag = 0 ; break ; } } if ( flag == 0 ) break ; document . write ( p1 + " " ) ; i ++ ; } }
Ref: 
function print_C ( $ p0 ) { $ p1 = 0 ; $ i = 0 ; $ x ; $ flag ; $ k ; while ( 1 ) { $ flag = 1 ; $ x = pow ( 2 , $ i ) ; $ p1 = $ x * $ p0 + ( $ x - 1 ) ; for ( $ k = 2 ; $ k < $ p1 ; $ k ++ ) { if ( $ p1 % $ k == 0 ) { $ flag = 0 ; break ; } } if ( $ flag == 0 ) break ; echo $ p1 . " " ; $ i ++ ; } }
Hyp: 
function print_C ( $ p0 ) { $ p1 = 0 ; $ i = 0 ; $ x ; $ flag ; $ k ; while ( 1 ) { $ flag = 1 ; $ x = pow ( 2 , $ i ) ; $ p1 = $ x * $ p0 + ( $ x - 1 ) ; for ( $ k = 2 ; $ k < $ p1 ; $ k ++ ) { if ( $ p1 % $ k == 0 ) { $ flag = 0 ; break ; } } if ( $ flag == 0 ) break ; echo $ p1 , " " ; $ i ++ ; } }

BLEU: 97.95
Edit Sim: 1


Src: 
function calculateSum ( n ) { return parseInt ( Math . pow ( n * ( n + 1 ) / 2 , 2 ) ) ; }
Ref: 
function calculateSum ( $ n ) { return pow ( $ n * ( $ n + 1 ) / 2 , 2 ) ; }
Hyp: 
function findSum ( $ n ) { return ( int ) pow ( $ n * ( $ n + 1 ) / 2 , 2 ) ; }

BLEU: 77.61
Edit Sim: 17


Src: 
function getHermiteNumber ( n ) { if ( n == 0 ) return 1 ; else if ( n == 1 ) return 1 ; else return - 2 * ( n - 1 ) * getHermiteNumber ( n - 2 ) ; }
Ref: 
function getHermiteNumber ( $ n ) { if ( $ n == 0 ) return 1 ; if ( $ n == 1 ) return 0 ; else return -2 * ( $ n - 1 ) * getHermiteNumber ( $ n - 2 ) ; }
Hyp: 
function getHermiteNumber ( $ n ) { if ( $ n == 0 ) return 1 ; else if ( $ n == 1 ) return 1 ; else return - 2 * ( $ n - 1 ) * getHermiteNumber ( $ n - 2 ) ; }

BLEU: 81.98
Edit Sim: 7


Src: 
function ellipsearea ( r ) { if ( r < 0 ) return - 1 ; var a = ( ( 3.14 * r * r ) / 4 ) ; return a ; }
Ref: 
function ellipsearea ( $ r ) { if ( $ r < 0 ) return -1 ; $ a = ( 3.14 * $ r * $ r ) / 4 ; return $ a ; }
Hyp: 
function ellipsearea ( $ r ) { if ( $ r < 0 ) return -1 ; $ a = ( ( 3.14 * $ r * $ r ) / 4 ) ; return $ a ; }

BLEU: 88.64
Edit Sim: 4


Src: 
function minAbsDiff ( n ) { let left = 1 << ( Math . floor ( Math . log ( n ) / Math . log ( 2 ) ) ) ; let right = left * 2 ; return Math . min ( ( n - left ) , ( right - n ) ) ; }
Ref: 
function minAbsDiff ( $ n ) { $ left = 1 << ( ( floor ( log ( $ n ) / log ( 2 ) ) ) ) ; $ right = $ left * 2 ; return min ( ( $ n - $ left ) , ( $ right - $ n ) ) ; }
Hyp: 
function minAbsDiff ( $ n ) { $ left = 1 << ( log ( $ n ) / log ( 2 ) ) ; $ right = $ left * 2 ; return min ( ( $ n - $ left ) , ( $ right - $ n ) ) ; }

BLEU: 89.39
Edit Sim: 14


Src: 
function isPalindrome ( n ) { if ( n % 11 == 0 ) { return true ; } return false ; }
Ref: 
function isPalindrome ( $ n ) { if ( $ n % 11 == 0 ) { return true ; } return false ; }
Hyp: 
function isPalindrome ( $ n ) { if ( $ n % 11 == 0 ) { return true ; } return false ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findWinner ( N ) { return N & 1 ; }
Ref: 
function findWinner ( $ N ) { return $ N & 1 ; }
Hyp: 
function findWinner ( $ N ) { return $ N & 1 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function minInsertion ( str ) { let n = str . length ; let res = 0 ; let count = new Array ( 26 ) ; for ( let i = 0 ; i < count . length ; i ++ ) { count [ i ] = 0 ; } for ( let i = 0 ; i < n ; i ++ ) count [ str [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; for ( let i = 0 ; i < 26 ; i ++ ) { if ( count [ i ] % 2 == 1 ) res ++ ; } return ( res == 0 ) ? 0 : res - 1 ; }
Ref: 
function minInsertion ( $ str ) { $ n = strlen ( $ str ) ; $ res = 0 ; $ count = array ( 26 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ count [ ord ( $ str [ $ i ] ) - ord ( ' a ' ) ] ++ ; for ( $ i = 0 ; $ i < 26 ; $ i ++ ) { if ( $ count [ $ i ] % 2 == 1 ) $ res ++ ; } return ( $ res == 0 ) ? 0 : $ res - 1 ; }
Hyp: 
function minInsertion ( $ str ) { $ n = strlen ( $ str ) ; $ res = 0 ; $ count = array_fill ( 0 , 26 , 0 ) ; for ( $ i = 0 ; $ i < 26 ; $ i ++ ) $ count [ $ i ] = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ count [ ord ( $ str [ $ i ] ) - 97 ] ++ ; for ( $ i = 0 ; $ i < 26 ; $ i ++ ) { if ( $ count [ $ i ] % 2 == 1 ) $ res ++ ; } return ( $ res == 0 ) ? 0 : $ res - 1 ; }

BLEU: 75.37
Edit Sim: 75


Src: 
function getValue ( n ) { let i = 0 , k = 1 ; while ( i < n ) { i = i + k ; k = k * 2 ; } return parseInt ( k / 2 ) ; }
Ref: 
function getValue ( $ n ) { $ i = 0 ; $ k = 1 ; while ( $ i < $ n ) { $ i = $ i + $ k ; $ k = $ k * 2 ; } return ( int ) $ k / 2 ; }
Hyp: 
function getValue ( $ n ) { $ i = 0 ; $ k = 1 ; while ( $ i < $ n ) { $ i = $ i + $ k ; $ k = $ k * 2 ; } return ( int ) $ k / 2 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function polyapothem ( n , a ) { if ( a < 0 && n < 0 ) return - 1 ; return ( a / ( 2 * Math . tan ( ( 180 / n ) * 3.14159 / 180 ) ) ) ; }
Ref: 
function polyapothem ( $ n , $ a ) { if ( $ a < 0 && $ n < 0 ) return -1 ; return $ a / ( 2 * tan ( ( 180 / $ n ) * 3.14159 / 180 ) ) ; }
Hyp: 
function polyapothem ( $ n , $ a ) { if ( $ a < 0 && $ n < 0 ) return -1 ; return ( $ a / ( 2 * tan ( ( 180 / $ n ) * 3.14159 / 180 ) ) ) ; }

BLEU: 92.3
Edit Sim: 4


Src: 
function calculateSum ( n ) { return ( parseInt ( Math . pow ( 10 , n + 1 ) ) * ( 9 * n - 1 ) + 10 ) / parseInt ( Math . pow ( 9 , 3 ) ) - n * ( n + 1 ) / 18 ; }
Ref: 
function findSum ( $ n ) { return ( pow ( 10 , $ n + 1 ) * ( 9 * $ n - 1 ) + 10 ) / pow ( 9 , 3 ) - $ n * ( $ n + 1 ) / 18 ; }
Hyp: 
function findSum ( $ n ) { return ( ( pow ( 10 , $ n + 1 ) ) * ( 9 * $ n - 1 ) + 10 ) / pow ( 9 , 3 ) ) - $ n * ( $ n + 1 ) / 18 ; }

BLEU: 89.96
Edit Sim: 6


Src: 
function countOddSquares ( n , m ) { return Math . pow ( m , 0.5 ) - Math . pow ( n - 1 , 0.5 ) ; }
Ref: 
function countOddSquares ( $ n , $ m ) { return ( int ) pow ( $ m , 0.5 ) - ( int ) pow ( $ n - 1 , 0.5 ) ; }
Hyp: 
function countOddSquares ( $ n , $ m ) { return pow ( $ m , 0.5 ) - pow ( $ n - 1 , 0.5 ) ; }

BLEU: 73.0
Edit Sim: 16


Src: 
function hexagonside ( a ) { if ( a < 0 ) return - 1 ; let x = 0.5176 * a ; return x ; }
Ref: 
function hexagonside ( $ a ) { if ( $ a < 0 ) return -1 ; $ x = 0.5176 * $ a ; return $ x ; }
Hyp: 
function hexagonside ( $ a ) { if ( $ a < 0 ) return -1 ; $ x = 0.5176 * $ a ; return $ x ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countBits ( n ) { var count = 0 ; while ( n ) { count ++ ; n >>= 1 ; } return count ; }
Ref: 
function countBits ( $ n ) { $ count = 0 ; while ( $ n ) { $ count ++ ; $ n >>= 1 ; } return $ count ; }
Hyp: 
function countBits ( $ n ) { $ count = 0 ; while ( $ n ) { $ count ++ ; $ n >>= 1 ; } return $ count ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function meanVector ( mat ) { document . write ( " " ) ; for ( var i = 0 ; i < rows ; i ++ ) { var mean = 0.00 ; var sum = 0 ; for ( var j = 0 ; j < cols ; j ++ ) sum += mat [ j ] [ i ] ; mean = sum / rows ; document . write ( mean + " " ) ; } document . write ( " " ) ; }
Ref: 
function meanVector ( $ mat ) { global $ rows , $ cols ; echo " [ ▁ " ; for ( $ i = 0 ; $ i < $ rows ; $ i ++ ) { $ mean = 0.00 ; $ sum = 0 ; for ( $ j = 0 ; $ j < $ cols ; $ j ++ ) $ sum += $ mat [ $ j ] [ $ i ] ; $ mean = $ sum / $ rows ; echo $ mean , " " ; ▁ } ▁ echo ▁ " ] " }
Hyp: 
function meanVector ( $ mat ) { echo " The ▁ mean ▁ of ▁ the ▁ matrix ▁ is ▁ " , " ( " ; for ( $ i = 0 ; $ i < $ rows ; $ i ++ ) { $ mean = 0.00 ; $ sum = 0 ; for ( $ j = 0 ; $ j < $ cols ; $ j ++ ) $ sum += $ mat [ $ j ] [ $ i ] ; $ mean = $ mean / $ rows ; echo " The ▁ mean ▁ of ▁ the ▁ vector ▁ is ▁ " , $ mean , " STRNEWLINE " ; } echo " STRNEWLINE " ; }

BLEU: 64.77
Edit Sim: 113


Src: 
function translate ( str ) { for ( let i = 1 ; i < str . length ; i ++ ) { if ( str [ i - 1 ] == ' ' && str [ i ] == ' ' ) { str [ i - 1 ] = ' ' ; let j ; for ( j = i ; j < str . length - 1 ; j ++ ) str [ j ] = str [ j + 1 ] ; str [ j ] = ' ' ; } } return ; }
Ref: 
function translate ( & $ str ) { if ( $ str [ 0 ] == ' ' ) return ; for ( $ i = 1 ; $ i < strlen ( $ str ) ; $ i ++ ) { if ( $ str [ $ i - 1 ] == ' A ' && $ str [ $ i ] == ' B ' ) { $ str [ $ i - 1 ] = ' C ' ; for ( $ j = $ i ; $ j < strlen ( $ str ) ; $ j ++ ) $ str [ $ j ] = $ str [ $ j + 1 ] ; } } return ; }
Hyp: 
function translate ( & $ str , $ n ) { for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( $ str [ $ i - 1 ] == '0' && $ str [ $ i ] == '1' ) { $ str [ $ i - 1 ] = '0' ; $ j ; for ( $ j = $ i ; $ j < $ n - 1 ; $ j ++ ) $ str [ $ j ] = $ str [ $ j + 1 ] ; $ str [ $ j ] = '0' ; } } return $ str ; }

BLEU: 65.69
Edit Sim: 96


Src: 
function CountDigits ( n ) { if ( n == 1 ) return 1 ; var sum = 0 ; for ( i = 2 ; i <= n ; ++ i ) { sum += ( Math . log ( i ) / Math . log ( 10 ) ) ; } sum *= n ; return Math . ceil ( sum ) ; }
Ref: 
function CountDigits ( $ n ) { if ( $ n == 1 ) return 1 ; $ sum = 0 ; for ( $ i = 2 ; $ i <= $ n ; ++ $ i ) { $ sum += log ( $ i ) / log ( 10 ) ; } $ sum *= $ n ; }
Hyp: 
function CountDigits ( $ n ) { if ( $ n == 1 ) return 1 ; $ sum = 0 ; for ( $ i = 2 ; $ i <= $ n ; ++ $ i ) { $ sum += ( log10 ( $ i ) ) ; } $ sum *= $ n ; return ceil ( $ sum ) ; }

BLEU: 81.06
Edit Sim: 33


Src: 
function possibleToSort ( arr , n , str ) { let max_element = - 1 ; for ( let i = 0 ; i < str . length ; i ++ ) { max_element = Math . max ( max_element , arr [ i ] ) ; if ( str [ i ] == ' ' ) { if ( max_element > i + 1 ) return " " ; } } return " " ; }
Ref: 
function possibleToSort ( $ arr , $ n , $ str ) { $ max_element = -1 ; for ( $ i = 0 ; $ i < sizeof ( $ str ) ; $ i ++ ) { $ max_element = max ( $ max_element , $ arr [ $ i ] ) ; if ( $ str [ $ i ] == '0' ) { if ( $ max_element > $ i + 1 ) return " No " ; } } return " Yes " ; }
Hyp: 
function possibleToSort ( $ arr , $ n , $ str ) { $ max_element = -1 ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) { $ max_element = max ( $ max_element , $ arr [ $ i ] ) ; if ( $ str [ $ i ] == ' ( ' ) { if ( $ max_element > $ i + 1 ) return " ▁ " ; } } return " No " ; }

BLEU: 89.19
Edit Sim: 13


Src: 
function lastFiveDigits ( n ) { n = ( Math . floor ( n / 10000 ) ) * 10000 + ( Math . floor ( n / 100 ) % 10 ) * 1000 + ( n % 10 ) * 100 + ( Math . floor ( n / 10 ) % 10 ) * 10 + Math . floor ( n / 1000 ) % 10 ; let ans = 1 ; for ( let i = 0 ; i < 5 ; i ++ ) { ans *= n ; ans %= 100000 ; } document . write ( ans ) ; }
Ref: 
function lastFiveDigits ( $ n ) { $ n = ( int ) ( $ n / 10000 ) * 10000 + ( ( int ) ( $ n / 100 ) % 10 ) * 1000 + ( $ n % 10 ) * 100 + ( ( int ) ( $ n / 10 ) % 10 ) * 10 + ( int ) ( $ n / 1000 ) % 10 ; $ ans = 1 ; for ( $ i = 0 ; $ i < 5 ; $ i ++ ) { $ ans *= $ n ; $ ans %= 100000 ; } echo $ ans ; }
Hyp: 
function lastFiveDigits ( $ n ) { $ n = ( int ) ( $ n / 10000 ) ; $ n = ( int ) ( $ n / 100 ) % 10 ) * 1000 + ( $ n % 10 ) * 100 + ( int ) ( $ n / 10 ) % 10 ) * 10 + ( int ) ( $ n / 1000 ) % 10 ; $ ans = 1 ; for ( $ i = 0 ; $ i < 5 ; $ i ++ ) { $ ans *= $ n ; $ ans %= 100000 ; } echo $ ans ; }

BLEU: 93.58
Edit Sim: 10


Src: 
function lcs ( X , Y ) { let m = X . length , n = Y . length ; let L = new Array ( 2 ) ; for ( let i = 0 ; i < 2 ; i ++ ) { L [ i ] = new Array ( n + 1 ) ; for ( let j = 0 ; j < n + 1 ; j ++ ) { L [ i ] [ j ] = 0 ; } } let bi = 0 ; for ( let i = 0 ; i <= m ; i ++ ) { bi = i & 1 ; for ( let j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) L [ bi ] [ j ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) L [ bi ] [ j ] = L [ 1 - bi ] [ j - 1 ] + 1 ; else L [ bi ] [ j ] = Math . max ( L [ 1 - bi ] [ j ] , L [ bi ] [ j - 1 ] ) ; } } return L [ bi ] [ n ] ; }
Ref: 
function lcs ( $ X , $ Y ) { $ m = strlen ( $ X ) ; $ n = strlen ( $ Y ) ; $ L = array ( array ( ) ) ; for ( $ i = 0 ; $ i <= $ m ; $ i ++ ) { $ bi = $ i & 1 ; for ( $ j = 0 ; $ j <= $ n ; $ j ++ ) { if ( $ i == 0 $ j == 0 ) $ L [ $ bi ] [ $ j ] = 0 ; else if ( $ X [ $ i - 1 ] == $ Y [ $ j - 1 ] ) $ L [ $ bi ] [ $ j ] = $ L [ 1 - $ bi ] [ $ j - 1 ] + 1 ; else $ L [ $ bi ] [ $ j ] = max ( $ L [ 1 - $ bi ] [ $ j ] , $ L [ $ bi ] [ $ j - 1 ] ) ; } } return $ L [ $ bi ] [ $ n ] ; }
Hyp: 
function lcs ( $ X , $ Y ) { $ m = strlen ( $ X ) ; $ n = strlen ( $ Y ) ; $ L = array_fill ( 0 , 2 , array_fill ( 0 , $ n + 1 , NULL ) ) ; $ bi = 0 ; for ( $ i = 0 ; $ i <= $ m ; $ i ++ ) { $ bi = $ i & 1 ; for ( $ j = 0 ; $ j <= $ n ; $ j ++ ) { if ( $ i == 0 $ j == 0 ) $ L [ $ bi ] [ $ j ] = 0 ; else if ( $ X [ $ i - 1 ] == $ Y [ $ j - 1 ] ) $ L [ $ bi ] [ $ j ] = $ L [ 1 - $ bi ] [ $ j - 1 ] + 1 ; else $ L [ $ bi ] [ $ j ] = max ( $ L [ 1 - $ bi ] [ $ j ] , $ L [ $ bi ] [ $ j - 1 ] ) ; } } return $ L [ $ bi ] [ $ n ] ; }

BLEU: 89.99
Edit Sim: 48


Src: 
function checkStar ( mat ) { var vertexD1 = 0 , vertexDn_1 = 0 ; if ( size == 1 ) return ( mat [ 0 ] [ 0 ] == 0 ) ; if ( size == 2 ) return ( mat [ 0 ] [ 0 ] == 0 && mat [ 0 ] [ 1 ] == 1 && mat [ 1 ] [ 0 ] == 1 && mat [ 1 ] [ 1 ] == 0 ) ; for ( var i = 0 ; i < size ; i ++ ) { var degreeI = 0 ; for ( var j = 0 ; j < size ; j ++ ) if ( mat [ i ] [ j ] ) degreeI ++ ; if ( degreeI == 1 ) vertexD1 ++ ; else if ( degreeI == size - 1 ) vertexDn_1 ++ ; } return ( vertexD1 == ( size - 1 ) && vertexDn_1 == 1 ) ; }
Ref: 
function checkStar ( $ mat ) { global $ size ; $ vertexD1 = 0 ; $ vertexDn_1 = 0 ; if ( $ size == 1 ) return ( $ mat [ 0 ] [ 0 ] == 0 ) ; if ( $ size == 2 ) return ( $ mat [ 0 ] [ 0 ] == 0 && $ mat [ 0 ] [ 1 ] == 1 && $ mat [ 1 ] [ 0 ] == 1 && $ mat [ 1 ] [ 1 ] == 0 ) ; for ( $ i = 0 ; $ i < $ size ; $ i ++ ) { $ degreeI = 0 ; for ( $ j = 0 ; $ j < $ size ; $ j ++ ) if ( $ mat [ $ i ] [ $ j ] ) $ degreeI ++ ; if ( $ degreeI == 1 ) $ vertexD1 ++ ; else if ( $ degreeI == $ size - 1 ) $ vertexDn_1 ++ ; } return ( $ vertexD1 == ( $ size - 1 ) && $ vertexDn_1 == 1 ) ; }
Hyp: 
function checkStar ( $ mat ) { global $ size ; $ vertexD1 = 0 ; $ vertexDn_1 = 0 ; if ( $ size == 1 ) return ( $ mat [ 0 ] [ 0 ] == 0 ) ; if ( $ size == 2 ) return ( $ mat [ 0 ] [ 0 ] == 0 && $ mat [ 0 ] [ 1 ] == 1 && $ mat [ 1 ] [ 1 ] == 0 ) ; for ( $ i = 0 ; $ i < $ size ; $ i ++ ) { $ degreeI = 0 ; for ( $ j = 0 ; $ j < $ size ; $ j ++ ) if ( $ mat [ $ i ] [ $ j ] ) $ degreeI ++ ; if ( $ degreeI == 1 ) $ vertexD1 ++ ; else if ( $ degreeI == $ size - 1 ) $ vertexDn_1 ++ ; } return ( $ vertexD1 == ( $ size - 1 ) && $ vertexDn_1 == 1 ) ; }

BLEU: 94.32
Edit Sim: 26


Src: 
function findgroups ( arr , n ) { let c = [ 0 , 0 , 0 ] ; let i ; let res = 0 ; for ( i = 0 ; i < n ; i ++ ) c [ arr [ i ] % 3 ] ++ ; res += ( ( c [ 0 ] * ( c [ 0 ] - 1 ) ) >> 1 ) ; res += c [ 1 ] * c [ 2 ] ; res += ( c [ 0 ] * ( c [ 0 ] - 1 ) * Math . floor ( ( c [ 0 ] - 2 ) ) / 6 ) ; res += ( c [ 1 ] * ( c [ 1 ] - 1 ) * Math . floor ( ( c [ 1 ] - 2 ) ) / 6 ) ; res += ( Math . floor ( c [ 2 ] * ( c [ 2 ] - 1 ) * ( c [ 2 ] - 2 ) ) / 6 ) ; res += c [ 0 ] * c [ 1 ] * c [ 2 ] ; return res ; }
Ref: 
function findgroups ( $ arr , $ n ) { $ c = array ( 0 , 0 , 0 ) ; $ res = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ c [ $ arr [ $ i ] % 3 ] += 1 ; $ res += ( ( $ c [ 0 ] * ( $ c [ 0 ] - 1 ) ) >> 1 ) ; $ res += $ c [ 1 ] * $ c [ 2 ] ; $ res += ( $ c [ 0 ] * ( $ c [ 0 ] - 1 ) * ( $ c [ 0 ] - 2 ) ) / 6 ; $ res += ( $ c [ 1 ] * ( $ c [ 1 ] - 1 ) * ( $ c [ 1 ] - 2 ) ) / 6 ; $ res += ( ( $ c [ 2 ] * ( $ c [ 2 ] - 1 ) * ( $ c [ 2 ] - 2 ) ) / 6 ) ; $ res += $ c [ 0 ] * $ c [ 1 ] * $ c [ 2 ] ; return $ res ; }
Hyp: 
function findgroups ( $ arr , $ n ) { $ c = array ( 0 , 0 , 0 ) ; $ i ; $ res = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ c [ $ arr [ $ i ] % 3 ] ++ ; $ res += ( ( $ c [ 0 ] * ( $ c [ 0 ] - 1 ) ) >> 1 ) ; $ res += $ c [ 1 ] * $ c [ 2 ] ; $ res += ( $ c [ 0 ] * ( $ c [ 0 ] - 1 ) * ( int ) ( ( $ c [ 0 ] - 2 ) ) / 6 ) ; $ res += ( $ c [ 1 ] * ( int ) ( $ c [ 1 ] - 1 ) * ( int ) ( $ c [ 1 ] - 2 ) ) / 6 ) ; $ res += ( $ c [ 2 ] * ( int ) ( $ c [ 2 ] - 1 ) * ( int ) ( $ c [ 2 ] - 2 ) ) / 6 ) ; $ res += $ c [ 0 ] * $ c [ 1 ] * $ c [ 2 ] ; return $ res ; }

BLEU: 87.65
Edit Sim: 57


Src: 
function countDigits ( a , b ) { if ( a == 0 b == 0 ) return 1 ; return Math . floor ( Math . log10 ( Math . abs ( a ) ) + Math . log10 ( Math . abs ( b ) ) ) + 1 ; }
Ref: 
function countDigits ( $ a , $ b ) { if ( $ a == 0 or $ b == 0 ) return 1 ; return floor ( log10 ( abs ( $ a ) ) + log10 ( abs ( $ b ) ) ) + 1 ; }
Hyp: 
function countDigits ( $ a , $ b ) { if ( $ a == 0 $ b == 0 ) return 1 ; return floor ( log10 ( abs ( $ a ) ) + log10 ( abs ( $ b ) ) ) + 1 ; }

BLEU: 94.87
Edit Sim: 3


Src: 
function findMinDiff ( arr , n , m ) { if ( m == 0 n == 0 ) return 0 ; arr . sort ( function ( a , b ) { return a - b } ) ; if ( n < m ) return - 1 ; let min_diff = Number . MAX_VALUE ; for ( let i = 0 ; i + m - 1 < n ; i ++ ) { let diff = arr [ i + m - 1 ] - arr [ i ] ; if ( diff < min_diff ) min_diff = diff ; } return min_diff ; }
Ref: 
function findMinDiff ( $ arr , $ n , $ m ) { if ( $ m == 0 $ n == 0 ) return 0 ; sort ( $ arr ) ; if ( $ n < $ m ) return -1 ; $ min_diff = PHP_INT_MAX ; for ( $ i = 0 ; $ i + $ m - 1 < $ n ; $ i ++ ) { $ diff = $ arr [ $ i + $ m - 1 ] - $ arr [ $ i ] ; if ( $ diff < $ min_diff ) $ min_diff = $ diff ; } return $ min_diff ; }
Hyp: 
function findMinDiff ( $ arr , $ n , $ m ) { if ( $ m == 0 $ n == 0 ) return 0 ; sort ( $ arr ) ; if ( $ n < $ m ) return -1 ; $ min_diff = PHP_INT_MAX ; for ( $ i = 0 ; $ i + $ m - 1 < $ n ; $ i ++ ) { $ diff = $ arr [ $ i + $ m - 1 ] - $ arr [ $ i ] ; if ( $ diff < $ min_diff ) $ min_diff = $ diff ; } return $ min_diff ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countWays ( n ) { let dp = new Array ( 2 ) ; for ( let i = 0 ; i < 2 ; i ++ ) { dp [ i ] = new Array ( n + 1 ) ; } dp [ 0 ] [ 1 ] = 1 ; dp [ 1 ] [ 1 ] = 2 ; for ( let i = 2 ; i <= n ; i ++ ) { dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + dp [ 1 ] [ i - 1 ] ; dp [ 1 ] [ i ] = dp [ 0 ] [ i - 1 ] * 2 + dp [ 1 ] [ i - 1 ] ; } return dp [ 0 ] [ n ] + dp [ 1 ] [ n ] ; }
Ref: 
function countWays ( $ n ) { $ dp [ 0 ] [ 1 ] = 1 ; $ dp [ 1 ] [ 1 ] = 2 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { $ dp [ 0 ] [ $ i ] = $ dp [ 0 ] [ $ i - 1 ] + $ dp [ 1 ] [ $ i - 1 ] ; $ dp [ 1 ] [ $ i ] = $ dp [ 0 ] [ $ i - 1 ] * 2 + $ dp [ 1 ] [ $ i - 1 ] ; } return $ dp [ 0 ] [ $ n ] + $ dp [ 1 ] [ $ n ] ; }
Hyp: 
function countWays ( $ n ) { $ dp = array_fill ( 0 , 2 , array_fill ( 0 , $ n + 1 , NULL ) ) ; $ dp [ 0 ] [ 1 ] = 1 ; $ dp [ 1 ] [ 1 ] = 2 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { $ dp [ 0 ] [ $ i ] = $ dp [ 0 ] [ $ i - 1 ] + $ dp [ 1 ] [ $ i - 1 ] ; $ dp [ 1 ] [ $ i ] = $ dp [ 0 ] [ $ i - 1 ] * 2 + $ dp [ 1 ] [ $ i - 1 ] ; } return $ dp [ 0 ] [ $ n ] + $ dp [ 1 ] [ $ n ] ; }

BLEU: 86.22
Edit Sim: 66


Src: 
function findIndex ( arr , len ) { let maxIndex = 0 ; for ( let i = 0 ; i < len ; ++ i ) if ( arr [ i ] > arr [ maxIndex ] ) maxIndex = i ; for ( let i = 0 ; i < len ; ++ i ) if ( maxIndex != i && arr [ maxIndex ] < 2 * arr [ i ] ) return - 1 ; return maxIndex ; }
Ref: 
function findIndex ( $ arr , $ len ) { $ maxIndex = 0 ; for ( $ i = 0 ; $ i < $ len ; ++ $ i ) if ( $ arr [ $ i ] > $ arr [ $ maxIndex ] ) $ maxIndex = $ i ; for ( $ i = 0 ; $ i < $ len ; ++ $ i ) if ( $ maxIndex != $ i and $ arr [ $ maxIndex ] < 2 * $ arr [ $ i ] ) return -1 ; return $ maxIndex ; }
Hyp: 
function findIndex ( $ arr , $ len ) { $ maxIndex = 0 ; for ( $ i = 0 ; $ i < $ len ; ++ $ i ) if ( $ arr [ $ i ] > $ arr [ $ maxIndex ] ) $ maxIndex = $ i ; for ( $ i = 0 ; $ i < $ len ; ++ $ i ) if ( $ maxIndex != $ i && $ arr [ $ maxIndex ] < 2 * $ arr [ $ i ] ) return -1 ; return $ maxIndex ; }

BLEU: 97.54
Edit Sim: 3


Src: 
function minimumflip ( mat , n ) { let flip = 0 ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = 0 ; j < i ; j ++ ) if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) flip ++ ; return flip ; }
Ref: 
function minimumflip ( $ mat , $ n ) { $ flip = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ i ; $ j ++ ) if ( $ mat [ $ i ] [ $ j ] != $ mat [ $ j ] [ $ i ] ) $ flip ++ ; return $ flip ; }
Hyp: 
function minimumflip ( $ mat , $ n ) { $ flip = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ i ; $ j ++ ) if ( $ mat [ $ i ] [ $ j ] != $ mat [ $ j ] [ $ i ] ) $ flip ++ ; return $ flip ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function checkIndices ( Arr , N ) { for ( var i = 0 ; i < N - 1 ; i ++ ) { for ( var j = i + 1 ; j < N ; j ++ ) { if ( Arr [ i ] != Arr [ j ] ) { if ( Arr [ Arr [ i ] - 1 ] == Arr [ Arr [ j ] - 1 ] ) return true ; } } } return false ; }
Ref: 
function checkIndices ( $ Arr , $ N ) { for ( $ i = 0 ; $ i < $ N - 1 ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ N ; $ j ++ ) { if ( $ Arr [ $ i ] != $ Arr [ $ j ] ) { if ( $ Arr [ $ Arr [ $ i ] - 1 ] == $ Arr [ $ Arr [ $ j ] - 1 ] ) return true ; } } } return false ; }
Hyp: 
function checkIndices ( $ Arr , $ N ) { for ( $ i = 0 ; $ i < $ N - 1 ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ N ; $ j ++ ) { if ( $ Arr [ $ i ] != $ Arr [ $ j ] ) { if ( $ Arr [ $ Arr [ $ i ] - 1 ] == $ Arr [ $ Arr [ $ j ] - 1 ] ) return true ; } } } return false ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countOddPair ( A , N ) { let count = 0 ; for ( let i = 0 ; i < N ; i ++ ) if ( ! ( A [ i ] & 1 ) ) count ++ ; let evenPairCount = parseInt ( count * ( count - 1 ) / 2 ) ; let totPairs = parseInt ( N * ( N - 1 ) / 2 ) ; return totPairs - evenPairCount ; }
Ref: 
function countOddPair ( $ A , $ N ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) if ( ! ( $ A [ $ i ] & 1 ) ) $ count ++ ; $ evenPairCount = $ count * ( $ count - 1 ) / 2 ; $ totPairs = $ N * ( $ N - 1 ) / 2 ; return ( $ totPairs - $ evenPairCount ) ; }
Hyp: 
function countOddPair ( & $ A , $ N ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) if ( ! ( $ A [ $ i ] & 1 ) ) $ count ++ ; $ evenPairCount = $ count * ( $ count - 1 ) / 2 ; $ totPairs = $ N * ( $ N - 1 ) / 2 ; return $ totPairs - $ evenPairCount ; }

BLEU: 92.91
Edit Sim: 6


Src: 
function AvgofSquareN ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) sum += ( i * i ) ; return sum / n ; }
Ref: 
function AvgofSquareN ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ sum += ( $ i * $ i ) ; return $ sum / $ n ; }
Hyp: 
function AvgofSquareN ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ sum += ( $ i * $ i ) ; return $ sum / $ n ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function getHCF ( x , y ) { var minimum = Math . min ( x , y ) ; if ( x % minimum == 0 && y % minimum == 0 ) return minimum ; for ( var i = minimum / 2 ; i >= 2 ; i -- ) { if ( x % i == 0 && y % i == 0 ) return i ; } return 1 ; }
Ref: 
function getHCF ( $ x , $ y ) { $ minimum = min ( $ x , $ y ) ; if ( $ x % $ minimum == 0 && $ y % $ minimum == 0 ) return $ minimum ; for ( $ i = $ minimum / 2 ; $ i >= 2 ; $ i -- ) { if ( $ x % $ i == 0 && $ y % $ i == 0 ) return $ i ; } return 1 ; }
Hyp: 
function getHCF ( $ x , $ y ) { $ minimum = min ( $ x , $ y ) ; if ( $ x % $ minimum == 0 && $ y % $ minimum == 0 ) return $ minimum ; for ( $ i = $ minimum / 2 ; $ i >= 2 ; $ i -- ) { if ( $ x % $ i == 0 && $ y % $ i == 0 ) return $ i ; } return 1 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function search ( arr , n , x ) { let i ; for ( i = 0 ; i < n ; i ++ ) if ( arr [ i ] == x ) return i ; return - 1 ; }
Ref: 
function search ( $ arr , $ x ) { $ n = sizeof ( $ arr ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] == $ x ) return $ i ; } return -1 ; }
Hyp: 
function search ( $ arr , $ n , $ x ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] == $ x ) return $ i ; return -1 ; }

BLEU: 72.54
Edit Sim: 26


Src: 
function checkMarkov ( m ) { for ( let i = 0 ; i < n ; i ++ ) { let sum = 0 ; for ( let j = 0 ; j < n ; j ++ ) sum = sum + m [ i ] [ j ] ; if ( sum != 1 ) return false ; } return true ; }
Ref: 
function checkMarkov ( $ m ) { $ n = 3 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sum = 0 ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) $ sum = $ sum + $ m [ $ i ] [ $ j ] ; if ( $ sum != 1 ) return false ; } return true ; }
Hyp: 
function checkMarkov ( $ m ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sum = 0 ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) $ sum = $ sum + $ m [ $ i ] [ $ j ] ; if ( $ sum != 1 ) return false ; } return true ; }

BLEU: 92.04
Edit Sim: 10


Src: 
function findMaximumPieces ( n ) { return 1 + n * ( n + 1 ) / 2 ; }
Ref: 
function findMaximumPieces ( $ n ) { return 1 + $ n * ( $ n + 1 ) / 2 ; }
Hyp: 
function findMaximumPieces ( $ n ) { return 1 + $ n * ( $ n + 1 ) / 2 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function printSorted ( a , b , c ) { let get_max = Math . max ( a , Math . max ( b , c ) ) ; let get_min = - Math . max ( - a , Math . max ( - b , - c ) ) ; let get_mid = ( a + b + c ) - ( get_max + get_min ) ; document . write ( get_min + " " + get_mid + " " + get_max ) ; }
Ref: 
function printSorted ( $ a , $ b , $ c ) { $ get_max = max ( $ a , max ( $ b , $ c ) ) ; $ get_min = - max ( - $ a , max ( - $ b , - $ c ) ) ; $ get_mid = ( $ a + $ b + $ c ) - ( $ get_max + $ get_min ) ; echo $ get_min , " " ▁ , ▁ $ get _ mid , ▁ " " }
Hyp: 
function printSorted ( $ a , $ b , $ c ) { $ get_max = max ( $ a , $ b , $ c ) ; $ get_min = max ( - $ a , max ( - $ b , - $ c ) ) ; $ get_mid = ( $ a + $ b + $ c ) - ( $ get_max + $ get_min ) ; echo $ get_min . " , ▁ " . $ get_mid . " , ▁ " . $ get_max ; }

BLEU: 78.75
Edit Sim: 33


Src: 
function findMaximumPieces ( n ) { return 1 + n * ( n + 1 ) / 2 ; }
Ref: 
function findMaximumPieces ( $ n ) { return 1 + $ n * ( $ n + 1 ) / 2 ; }
Hyp: 
function findMaximumPieces ( $ n ) { return 1 + $ n * ( $ n + 1 ) / 2 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function isAMultipleOf4 ( n ) { if ( ( n & 3 ) == 0 ) return true ; return false ; }
Ref: 
function isAMultipleOf4 ( $ n ) { if ( ( $ n & 3 ) == 0 ) return " Yes " ; return " No " ; }
Hyp: 
function isAMultipleOf4 ( $ n ) { if ( ( $ n & 3 ) == 0 ) return true ; return false ; }

BLEU: 69.0
Edit Sim: 12


Src: 
function heptagonalNumber ( n ) { return parseInt ( ( ( 5 * n * n ) - ( 3 * n ) ) / 2 ) ; }
Ref: 
function heptagonalNumber ( $ n ) { return ( ( 5 * $ n * $ n ) - ( 3 * $ n ) ) / 2 ; }
Hyp: 
function heptagonalNumber ( $ n ) { return ( ( 5 * $ n * $ n ) - ( 3 * $ n ) ) / 2 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function MinimumMoves ( a , n , x ) { var ans = 0 ; for ( i = 1 ; i < n ; i ++ ) { if ( a [ i ] <= a [ i - 1 ] ) { var p = parseInt ( ( a [ i - 1 ] - a [ i ] ) / x + 1 ) ; ans += p ; a [ i ] += p * x ; } } return ans ; }
Ref: 
function MinimumMoves ( & $ a , $ n , $ x ) { $ ans = 0 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] <= $ a [ $ i - 1 ] ) { $ p = ( $ a [ $ i - 1 ] - $ a [ $ i ] ) / $ x + 1 ; $ ans += $ p ; $ a [ $ i ] += $ p * $ x ; } } return $ ans ; }
Hyp: 
function MinimumMoves ( $ a , $ n , $ x ) { $ ans = 0 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] <= $ a [ $ i - 1 ] ) { $ p = ( int ) ( ( $ a [ $ i - 1 ] - $ a [ $ i ] ) / $ x + 1 ) ; $ ans += $ p ; $ a [ $ i ] += $ p * $ x ; } } return $ ans ; }

BLEU: 92.08
Edit Sim: 14


Src: 
function octadiagonal ( a ) { if ( a < 0 ) return - 1 ; return a * Math . sqrt ( 4 + ( 2 * Math . sqrt ( 2 ) ) ) ; }
Ref: 
function octadiagonal ( $ a ) { if ( $ a < 0 ) return -1 ; return $ a * sqrt ( 4 + ( 2 * sqrt ( 2 ) ) ) ; }
Hyp: 
function octadiagonal ( $ a ) { if ( $ a < 0 ) return -1 ; return $ a * sqrt ( 4 + ( 2 * sqrt ( 2 ) ) ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function subsetXOR ( arr , n , k ) { let max_ele = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) if ( arr [ i ] > max_ele ) max_ele = arr [ i ] ; let m = ( 1 << parseInt ( Math . log ( max_ele ) / Math . log ( 2 ) + 1 , 10 ) ) - 1 ; if ( k > m ) { return 0 ; } let dp = new Array ( n + 1 ) ; for ( let i = 0 ; i <= n ; i ++ ) { dp [ i ] = new Array ( m + 1 ) ; for ( let j = 0 ; j <= m ; j ++ ) { dp [ i ] [ j ] = 0 ; } } dp [ 0 ] [ 0 ] = 1 ; for ( let i = 1 ; i <= n ; i ++ ) for ( let j = 0 ; j <= m ; j ++ ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j ^ arr [ i - 1 ] ] ; return dp [ n ] [ k ] ; }
Ref: 
function subsetXOR ( $ arr , $ n , $ k ) { $ max_ele = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] > $ max_ele ) $ max_ele = $ arr [ $ i ] ; $ m = ( 1 << ( int ) ( log ( $ max_ele , 2 ) + 1 ) ) - 1 ; if ( $ k > $ m ) { return 0 ; } for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) for ( $ j = 0 ; $ j <= $ m ; $ j ++ ) $ dp [ $ i ] [ $ j ] = 0 ; $ dp [ 0 ] [ 0 ] = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) for ( $ j = 0 ; $ j <= $ m ; $ j ++ ) $ dp [ $ i ] [ $ j ] = $ dp [ $ i - 1 ] [ $ j ] + $ dp [ $ i - 1 ] [ $ j ^ $ arr [ $ i - 1 ] ] ; return $ dp [ $ n ] [ $ k ] ; }
Hyp: 
function subsetXOR ( $ arr , $ n , $ k ) { $ max_ele = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] > $ max_ele ) $ max_ele = $ arr [ $ i ] ; $ m = ( 1 << ( log2 ( $ max_ele ) + 1 ) ) - 1 ; if ( $ k > $ m ) { return 0 ; } $ dp = array ( $ n + 1 ) ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) { $ dp [ $ i ] = array ( $ m + 1 ) ; for ( $ j = 0 ; $ j <= $ m ; $ j ++ ) $ dp [ $ i ] [ $ j ] = 0 ; $ dp [ $ i ] [ $ j ] = $ dp [ $ i - 1 ] [ $ j ] + $ dp [ $ i - 1 ] [ $ j ^ $ arr [ $ i - 1 ] ] ; return $ dp [ $ n ] [ $ k ] ; }

BLEU: 79.83
Edit Sim: 97


Src: 
function findRightAngle ( A , H ) { let D = Math . pow ( H , 4 ) - 16 * A * A ; if ( D >= 0 ) { let root1 = ( H * H + Math . sqrt ( D ) ) / 2 ; let root2 = ( H * H - Math . sqrt ( D ) ) / 2 ; let a = Math . sqrt ( root1 ) ; let b = Math . sqrt ( root2 ) ; if ( b >= a ) document . write ( a + " " + b + " " + H + " " ) ; else document . write ( b + " " + a + " " + H + " " ) ; } else document . write ( " " ) ; }
Ref: 
function findRightAngle ( $ A , $ H ) { $ D = pow ( $ H , 4 ) - 16 * $ A * $ A ; if ( $ D >= 0 ) { $ root1 = ( $ H * $ H + sqrt ( $ D ) ) / 2 ; $ root2 = ( $ H * $ H - sqrt ( $ D ) ) / 2 ; $ a = sqrt ( $ root1 ) ; $ b = sqrt ( $ root2 ) ; if ( $ b >= $ a ) echo $ a , " ▁ " , $ b , " ▁ " , $ H ; else echo $ b , " ▁ " , $ a , " ▁ " , $ H ; } else echo " - 1" ; }
Hyp: 
function findRightAngle ( $ A , $ H ) { $ D = pow ( $ H , 4 ) - 16 * $ A * $ A ; if ( $ D >= 0 ) { $ root1 = ( $ H * $ H + sqrt ( $ D ) ) / 2 ; $ root2 = ( $ H * $ H - sqrt ( $ D ) ) / 2 ; $ a = sqrt ( $ root1 ) ; $ b = sqrt ( $ root2 ) ; if ( $ b >= $ a ) echo $ a , " , ▁ " , $ b , " , ▁ " , $ H , " " ; else echo $ b , " , ▁ " , $ a , " , ▁ " , $ H , " " ; } else echo " Planes ▁ are ▁ not ▁ parallel " ; }

BLEU: 82.34
Edit Sim: 49


Src: 
function countWays ( n ) { for ( let i = 1 ; i < n ; i ++ ) for ( let j = i ; j < n ; j ++ ) for ( let k = j ; k < n ; k ++ ) for ( let l = k ; l < n ; l ++ ) if ( i + j + k + l == n ) counter ++ ; return counter ; }
Ref: 
function countWays ( $ n ) { $ counter = 0 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) for ( $ j = $ i ; $ j < $ n ; $ j ++ ) for ( $ k = $ j ; $ k < $ n ; $ k ++ ) for ( $ l = $ k ; $ l < $ n ; $ l ++ ) if ( $ i + $ j + $ k + $ l == $ n ) $ counter ++ ; return $ counter ; }
Hyp: 
function countWays ( $ n ) { for ( $ i = 1 ; $ i < $ n ; $ i ++ ) for ( $ j = $ i ; $ j < $ n ; $ j ++ ) for ( $ k = $ j ; $ k < $ n ; $ k ++ ) for ( $ l = $ k ; $ l < $ n ; $ l ++ ) if ( $ i + $ j + $ k + $ l == $ n ) $ counter ++ ; return $ counter ; }

BLEU: 93.91
Edit Sim: 16


Src: 
function swapBits ( x ) { even_bits = x & 0xAAAAAAAA ; odd_bits = x & 0x55555555 ; even_bits >>= 1 ; odd_bits <<= 1 ; return ( even_bits odd_bits ) ; }
Ref: 
function swapBits ( $ x ) { $ even_bits = $ x & 0xAAAAAAAA ; $ odd_bits = $ x & 0x55555555 ; $ even_bits >>= 1 ; $ odd_bits <<= 1 ; return ( $ even_bits $ odd_bits ) ; }
Hyp: 
function swapBits ( $ x ) { $ even_bits = $ x & 0xAAAAAAAA ; $ odd_bits = $ x & 0x55555555 ; $ even_bits >>= 1 ; $ odd_bits <<= 1 ; return ( $ even_bits $ odd_bits ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findOddPair ( A , N ) { let i , count = 0 ; for ( i = 0 ; i < N ; i ++ ) { if ( A [ i ] % 2 == 0 ) count ++ ; } return count * ( N - count ) ; }
Ref: 
function findOddPair ( $ A , $ N ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { if ( $ A [ $ i ] % 2 == 0 ) $ count ++ ; } return $ count * ( $ N - $ count ) ; }
Hyp: 
function findOddPair ( & $ A , $ N ) { $ i ; $ count = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { if ( $ A [ $ i ] % 2 == 0 ) $ count ++ ; } return $ count * ( $ N - $ count ) ; }

BLEU: 90.64
Edit Sim: 8


Src: 
function hexagonArea ( d ) { return ( 3 * Math . sqrt ( 3 ) * Math . pow ( d , 2 ) ) / 8 ; }
Ref: 
function hexagonArea ( $ d ) { return ( 3 * sqrt ( 3 ) * pow ( $ d , 2 ) ) / 8 ; }
Hyp: 
function hexagonArea ( $ d ) { return ( 3 * sqrt ( 3 ) * pow ( $ d , 2 ) ) / 8 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function isValidISBN ( isbn ) { let n = isbn . length ; if ( n != 10 ) return false ; let sum = 0 ; for ( let i = 0 ; i < 9 ; i ++ ) { let digit = isbn [ i ] - ' ' ; if ( 0 > digit 9 < digit ) return false ; sum += ( digit * ( 10 - i ) ) ; } let last = isbn [ 9 ] ; if ( last != ' ' && ( last < ' ' last > ' ' ) ) return false ; sum += ( ( last == ' ' ) ? 10 : ( last - ' ' ) ) ; return ( sum % 11 == 0 ) ; }
Ref: 
function isValidISBN ( $ isbn ) { $ n = strlen ( $ isbn ) ; if ( $ n != 10 ) return -1 ; $ sum = 0 ; for ( $ i = 0 ; $ i < 9 ; $ i ++ ) { $ digit = $ isbn [ $ i ] - '0' ; if ( 0 > $ digit 9 < $ digit ) return -1 ; $ sum += ( $ digit * ( 10 - $ i ) ) ; } $ last = $ isbn [ 9 ] ; if ( $ last != ' X ' && ( $ last < '0' $ last > '9' ) ) return -1 ; $ sum += ( ( $ last == ' X ' ) ? 10 : ( $ last - '0' ) ) ; return ( $ sum % 11 == 0 ) ; }
Hyp: 
function isValidISBN ( $ isbn ) { $ n = strlen ( $ isbn ) ; if ( $ n != 10 ) return false ; $ sum = 0 ; for ( $ i = 0 ; $ i < 9 ; $ i ++ ) { $ digit = $ isbn [ $ i ] - '0' ; if ( 0 > $ digit 9 < $ digit ) return false ; $ sum += ( $ digit * ( 10 - $ i ) ) ; } $ last = $ isbn [ 9 ] ; if ( $ last != '0' && ( $ last < '0' $ last > '0' ) ) return false ; $ sum += ( ( $ last == '0' ) ? 10 : ( $ last - '0' ) ) ; return ( $ sum % 11 == 0 ) ; }

BLEU: 87.62
Edit Sim: 22


Src: 
function Alphabet_N_Pattern ( N ) { var index , side_index , size ; var Right = 1 , Left = 1 , Diagonal = 2 ; for ( index = 0 ; index < N ; index ++ ) { document . write ( Left ++ ) ; for ( side_index = 0 ; side_index < 2 * index ; side_index ++ ) document . write ( " " ) ; if ( index != 0 && index != N - 1 ) document . write ( Diagonal ++ ) ; else document . write ( " " ) ; for ( side_index = 0 ; side_index < 2 * ( N - index - 1 ) ; side_index ++ ) document . write ( " " ) ; document . write ( Right ++ ) ; document . write ( " " ) ; } }
Ref: 
function Alphabet_N_Pattern ( $ N ) { $ index ; $ side_index ; $ size ; $ Right = 1 ; $ Left = 1 ; $ Diagonal = 2 ; for ( $ index = 0 ; $ index < $ N ; $ index ++ ) { echo $ Left ++ ; for ( $ side_index = 0 ; $ side_index < 2 * ( $ index ) ; $ side_index ++ ) echo " ▁ " ; if ( $ index != 0 && $ index != $ N - 1 ) echo $ Diagonal ++ ; else echo " ▁ " ; for ( $ side_index = 0 ; $ side_index < 2 * ( $ N - $ index - 1 ) ; $ side_index ++ ) echo " ▁ " ; echo $ Right ++ ; echo " STRNEWLINE " ; } }
Hyp: 
function Alphabet_N_Pattern ( $ N ) { $ index ; $ side_index ; $ size ; $ Right = 1 ; $ Left = 1 ; $ Diagonal = 2 ; for ( $ index = 0 ; $ index < $ N ; $ index ++ ) { echo $ Left ++ ; for ( $ side_index = 0 ; $ side_index < 2 * $ index ; $ side_index ++ ) echo " ▁ " ; if ( $ index != 0 && $ index != $ N - 1 ) echo $ Diagonal ++ ; else echo " ▁ " ; for ( $ side_index = 0 ; $ side_index < 2 * ( $ N - $ index - 1 ) ; $ side_index ++ ) echo " ▁ " ; echo $ Right ++ ; echo " STRNEWLINE " ; } }

BLEU: 96.78
Edit Sim: 4


Src: 
function isSuffix ( s1 , s2 ) { let n1 = s1 . length , n2 = s2 . length ; if ( n1 > n2 ) return false ; for ( let i = 0 ; i < n1 ; i ++ ) if ( s1 [ n1 - i - 1 ] != s2 [ n2 - i - 1 ] ) return false ; return true ; }
Ref: 
function isSuffix ( $ s1 , $ s2 ) { $ n1 = ( $ s1 ) ; $ n2 = strlen ( $ s2 ) ; if ( $ n1 > $ n2 ) return false ; for ( $ i = 0 ; $ i < $ n1 ; $ i ++ ) if ( $ s1 [ $ n1 - $ i - 1 ] != $ s2 [ $ n2 - $ i - 1 ] ) return false ; return true ; }
Hyp: 
function isSuffix ( $ s1 , $ s2 ) { $ n1 = strlen ( $ s1 ) ; $ n2 = strlen ( $ s2 ) ; if ( $ n1 > $ n2 ) return false ; for ( $ i = 0 ; $ i < $ n1 ; $ i ++ ) if ( $ s1 [ $ n1 - $ i - 1 ] != $ s2 [ $ n2 - $ i - 1 ] ) return false ; return true ; }

BLEU: 97.15
Edit Sim: 7


Src: 
function countSubStr ( str , n ) { let res = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( str [ i ] == ' ' ) { for ( let j = i + 1 ; j < n ; j ++ ) { if ( str [ j ] == ' ' ) res ++ ; } } } return res ; }
Ref: 
function countSubStr ( $ str ) { $ res = 0 ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) { if ( $ str [ $ i ] == '1' ) { for ( $ j = $ i + 1 ; $ j < strlen ( $ str ) ; $ j ++ ) if ( $ str [ $ j ] == '1' ) $ res ++ ; } } return $ res ; }
Hyp: 
function countSubStr ( $ str , $ n ) { $ res = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ str [ $ i ] == '1' ) { for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) { if ( $ str [ $ j ] == '2' ) $ res ++ ; } } } return $ res ; }

BLEU: 79.15
Edit Sim: 39


Src: 
function trapezoidarea ( r ) { if ( r < 0 ) return - 1 ; var a = ( 3 * Math . sqrt ( 3 ) * Math . pow ( r , 2 ) ) / 4 ; return a ; }
Ref: 
function trapezoidarea ( $ r ) { if ( $ r < 0 ) return -1 ; $ a = ( 3 * sqrt ( 3 ) * pow ( $ r , 2 ) ) / 4 ; return $ a ; }
Hyp: 
function trapezoidarea ( $ r ) { if ( $ r < 0 ) return -1 ; $ a = ( 3 * sqrt ( 3 ) * pow ( $ r , 2 ) ) / 4 ; return $ a ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function cone ( a ) { if ( a < 0 ) return - 1 ; var r = ( a * Math . sqrt ( 2 ) ) / 3 ; var h = ( 2 * a ) / 3 ; var V = ( 3.14 * Math . pow ( r , 2 ) * h ) ; return V ; }
Ref: 
function cone ( $ a ) { if ( $ a < 0 ) return -1 ; $ r = ( $ a * sqrt ( 2 ) ) / 3 ; $ h = ( 2 * $ a ) / 3 ; $ V = 3.14 * pow ( $ r , 2 ) * $ h ; return $ V ; }
Hyp: 
function cone ( $ a ) { if ( $ a < 0 ) return -1 ; $ r = ( $ a * sqrt ( 2 ) ) / 3 ; $ h = ( 2 * $ a ) / 3 ; $ V = 3.14 * pow ( $ r , 2 ) * $ h ; return $ V ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function NumberOfSolutions ( x , y , z , n ) { var ans = 0 ; for ( var i = 0 ; i <= x ; i ++ ) { for ( var j = 0 ; j <= y ; j ++ ) { var temp = n - i - j ; if ( temp >= 0 ) { temp = Math . min ( temp , z ) ; ans += temp + 1 ; } } } return ans ; }
Ref: 
function NumberOfSolutions ( $ x , $ y , $ z , $ n ) { $ ans = 0 ; for ( $ i = 0 ; $ i <= $ x ; $ i ++ ) { for ( $ j = 0 ; $ j <= $ y ; $ j ++ ) { $ temp = $ n - $ i - $ j ; if ( $ temp >= 0 ) { $ temp = min ( $ temp , $ z ) ; $ ans += $ temp + 1 ; } } } return $ ans ; }
Hyp: 
function NumberOfSolutions ( $ x , $ y , $ z , $ n ) { $ ans = 0 ; for ( $ i = 0 ; $ i <= $ x ; $ i ++ ) { for ( $ j = 0 ; $ j <= $ y ; $ j ++ ) { $ temp = $ n - $ i - $ j ; if ( $ temp >= 0 ) { $ temp = min ( $ temp , $ z ) ; $ ans += $ temp + 1 ; } } } return $ ans ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function isPerfectSquare ( n ) { for ( let sum = 0 , i = 1 ; sum < n ; i += 2 ) { sum += i ; if ( sum == n ) return true ; } return false ; }
Ref: 
function isPerfectSquare ( $ n ) { for ( $ sum = 0 , $ i = 1 ; $ sum < $ n ; $ i += 2 ) { $ sum += $ i ; if ( $ sum == $ n ) return true ; } return false ; }
Hyp: 
function isPerfectSquare ( $ n ) { for ( $ sum = 0 , $ i = 1 ; $ sum < $ n ; $ i += 2 ) { $ sum += $ i ; if ( $ sum == $ n ) return true ; } return false ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findString ( n , k ) { let res = " " ; for ( let i = 0 ; i < k ; i ++ ) res = res + String . fromCharCode ( ' ' . charCodeAt ( 0 ) + i ) ; let count = 0 ; for ( let i = 0 ; i < n - k ; i ++ ) { res = res + String . fromCharCode ( ' ' . charCodeAt ( 0 ) + count ) ; count ++ ; if ( count == k ) count = 0 ; } return res ; }
Ref: 
function findString ( $ n , $ k ) { $ res = " " ; for ( $ i = 0 ; $ i < $ k ; $ i ++ ) $ res = $ res . chr ( ord ( ' a ' ) + $ i ) ; $ count = 0 ; for ( $ i = 0 ; $ i < $ n - $ k ; $ i ++ ) { $ res = $ res . chr ( ord ( ' a ' ) + $ count ) ; $ count ++ ; if ( $ count == $ k ) $ count = 0 ; } return $ res ; }
Hyp: 
function findString ( $ n , $ k ) { $ res = " GeeksforGeeks " ; for ( $ i = 0 ; $ i < $ k ; $ i ++ ) $ res = $ res + chr ( 0 ) ; $ count = 0 ; for ( $ i = 0 ; $ i < $ n - $ k ; $ i ++ ) { $ res = $ res + chr ( 0 ) + $ i ; $ count ++ ; if ( $ count == $ k ) $ count = 0 ; } return $ res ; }

BLEU: 78.21
Edit Sim: 53


Src: 
function series ( A , X , n ) { let term = Math . pow ( A , n ) ; document . write ( term + " " ) ; for ( let i = 1 ; i <= n ; i ++ ) { term = term * X * ( n - i + 1 ) / ( i * A ) ; document . write ( term + " " ) ; } }
Ref: 
function series ( $ A , $ X , $ n ) { $ term = pow ( $ A , $ n ) ; echo $ term , " " ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ term = $ term * $ X * ( $ n - $ i + 1 ) / ( $ i * $ A ) ; echo $ term , " " ; } }
Hyp: 
function series ( $ A , $ X , $ n ) { $ term = pow ( $ A , $ n ) ; echo $ term . " " ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ term = $ term * $ X * ( $ n - $ i + 1 ) / ( $ i * $ A ) ; echo $ term . " " ; } }

BLEU: 94.08
Edit Sim: 2


Src: 
function isValid ( str , n ) { if ( ! ( ( str [ 0 ] >= ' ' && str [ 0 ] <= ' ' ) || ( str [ 0 ] >= ' ' && str [ 0 ] <= ' ' ) str [ 0 ] == ' ' ) ) return false ; for ( let i = 1 ; i < str . length ; i ++ ) { if ( ! ( ( str [ i ] >= ' ' && str [ i ] <= ' ' ) || ( str [ i ] >= ' ' && str [ i ] <= ' ' ) || ( str [ i ] >= ' ' && str [ i ] <= ' ' ) str [ i ] == ' ' ) ) return false ; } return true ; }
Ref: 
function isValid ( $ str , $ n ) { if ( ! ( ( $ str [ 0 ] >= ' a ' && $ str [ 0 ] <= ' z ' ) || ( $ str [ 0 ] >= ' A ' && $ str [ 0 ] <= ' Z ' ) $ str [ 0 ] == ' _ ' ) ) return false ; for ( $ i = 1 ; $ i < strlen ( $ str ) ; $ i ++ ) { if ( ! ( ( $ str [ $ i ] >= ' a ' && $ str [ $ i ] <= ' z ' ) || ( $ str [ $ i ] >= ' A ' && $ str [ $ i ] <= ' Z ' ) || ( $ str [ $ i ] >= '0' && $ str [ $ i ] <= '9' ) $ str [ $ i ] == ' _ ' ) ) return false ; } return true ; }
Hyp: 
function isValid ( $ str , $ n ) { if ( ! ( ( $ str [ 0 ] >= '0' && $ str [ 0 ] <= '0' ) || ( $ str [ 0 ] >= '0' && $ str [ 0 ] <= '9' ) || ( $ str [ 0 ] >= '0' && $ str [ 0 ] <= '0' ) || ( $ str [ 0 ] >= '0' && $ str [ 0 ] <= '9' ) || ( $ str [ $ i ] >= '0' && $ str [ $ i ] <= '0' ) || ( $ str [ $ i ] >= ' A ' && $ str [ $ i ] <= ' A ' ) || ( $ str [ $ i ] >= ' A ' && $ str [ $ i ] <= ' A ' ) ) return false ; } return true ; }

BLEU: 62.47
Edit Sim: 106


Src: 
function cube ( h , r ) { if ( h < 0 && r < 0 ) return - 1 ; var a = ( h * r * Math . sqrt ( 2 ) ) / ( h + Math . sqrt ( 2 ) * r ) ; return a ; }
Ref: 
function cubeSide ( $ h , $ r ) { if ( $ h < 0 && $ r < 0 ) return -1 ; $ a = ( $ h * $ r * sqrt ( 2 ) ) / ( $ h + sqrt ( 2 ) * $ r ) ; return $ a ; }
Hyp: 
function cube ( $ h , $ r ) { if ( $ h < 0 && $ r < 0 ) return -1 ; $ a = ( $ h * $ r * sqrt ( 2 ) ) / ( $ h + sqrt ( 2 ) * $ r ) ; return $ a ; }

BLEU: 96.99
Edit Sim: 4


Src: 
function MinimumMaximumPairs ( n , m ) { var max_pairs = parseInt ( ( ( n - m + 1 ) * ( n - m ) ) / 2 ) ; var min_pairs = m * parseInt ( ( ( ( n - m ) / m + 1 ) * ( ( n - m ) / m ) ) / 2 ) + parseInt ( Math . ceil ( ( ( n - m ) / ( m ) ) ) ) * ( ( n - m ) % m ) ; document . write ( " " + min_pairs + " " ) ; document . write ( " " + max_pairs ) ; }
Ref: 
function MinimumMaximumPairs ( $ n , $ m ) { $ max_pairs = ( ( $ n - $ m + 1 ) * ( $ n - $ m ) ) / 2 ; $ min_pairs = $ m * ( int ) ( ( ( ( int ) ( $ n - $ m ) / $ m + 1 ) * ( ( int ) ( $ n - $ m ) / $ m ) ) / 2 ) + ( int ) ceil ( ( $ n - $ m ) / $ m ) * ( ( $ n - $ m ) % $ m ) ; echo ( " Minimum ▁ no . ▁ of ▁ pairs ▁ = ▁ " . " $ min _ pairs " . " STRNEWLINE " ) ; echo ( " Maximum ▁ no . ▁ of ▁ pairs ▁ = ▁ " . " $ max _ pairs " ) ; }
Hyp: 
function MinimumMaximumPairs ( $ n , $ m ) { $ max_pairs = ( ( $ n - $ m + 1 ) * ( $ n - $ m ) ) / 2 ; $ min_pairs = $ m * ( ( ( $ n - $ m ) / $ m + 1 ) * ( ( $ n - $ m ) / $ m ) ) / 2 ; $ min_pairs = $ m * ( ( ( $ n - $ m ) / $ m + 1 ) * ( ( $ n - $ m ) / $ m ) ) / 2 ; $ max_pairs = ( ( $ n - $ m ) / ( $ m ) ) * ( ( $ n - $ m ) % $ m ) ; echo " Minimum ▁ Maximum ▁ Pairs ▁ : ▁ " , $ min_pairs , " STRNEWLINE " ; echo " Maximum ▁ of ▁ " , $ max_pairs ; }

BLEU: 61.52
Edit Sim: 142


Src: 
function sumOfMinAbsDifferences ( arr , n ) { arr . sort ( function ( a , b ) { return a - b } ) ; let sum = 0 ; sum += Math . abs ( arr [ 0 ] - arr [ 1 ] ) ; sum += Math . abs ( arr [ n - 1 ] - arr [ n - 2 ] ) ; for ( let i = 1 ; i < n - 1 ; i ++ ) sum += Math . min ( Math . abs ( arr [ i ] - arr [ i - 1 ] ) , Math . abs ( arr [ i ] - arr [ i + 1 ] ) ) ; return sum ; }
Ref: 
function sumOfMinAbsDifferences ( $ arr , $ n ) { sort ( $ arr ) ; sort ( $ arr , $ n ) ; $ sum = 0 ; $ sum += abs ( $ arr [ 0 ] - $ arr [ 1 ] ) ; $ sum += abs ( $ arr [ $ n - 1 ] - $ arr [ $ n - 2 ] ) ; for ( $ i = 1 ; $ i < $ n - 1 ; $ i ++ ) $ sum += min ( abs ( $ arr [ $ i ] - $ arr [ $ i - 1 ] ) , abs ( $ arr [ $ i ] - $ arr [ $ i + 1 ] ) ) ; return $ sum ; }
Hyp: 
function sumOfMinAbsDifferences ( $ arr , $ n ) { sort ( $ arr ) ; $ sum = 0 ; $ sum += abs ( $ arr [ 0 ] - $ arr [ 1 ] ) ; $ sum += abs ( $ arr [ $ n - 1 ] - $ arr [ $ n - 2 ] ) ; for ( $ i = 1 ; $ i < $ n - 1 ; $ i ++ ) $ sum += min ( abs ( $ arr [ $ i ] - $ arr [ $ i - 1 ] ) , abs ( $ arr [ $ i ] - $ arr [ $ i + 1 ] ) ) ; return $ sum ; }

BLEU: 93.18
Edit Sim: 23


Src: 
function findMinimum ( x , y ) { let low = 0 , high = y ; while ( low <= high ) { let mid = ( low + high ) >> 1 ; if ( ( mid * 2 + ( y - mid ) ) >= x ) high = mid - 1 ; else low = mid + 1 ; } return low ; }
Ref: 
function findMinimum ( $ x , $ y ) { $ low = 0 ; $ high = $ y ; while ( $ low <= $ high ) { $ mid = ( $ low + $ high ) >> 1 ; if ( ( $ mid * 2 + ( $ y - $ mid ) ) >= $ x ) $ high = $ mid - 1 ; else $ low = $ mid + 1 ; } return $ low ; }
Hyp: 
function findMinimum ( $ x , $ y ) { $ low = 0 ; $ high = $ y ; while ( $ low <= $ high ) { $ mid = ( $ low + $ high ) >> 1 ; if ( ( $ mid * 2 + ( $ y - $ mid ) ) >= $ x ) $ high = $ mid - 1 ; else $ low = $ mid + 1 ; } return $ low ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function numberofterm ( n , number ) { let firstnum = Math . pow ( 10 , n - 1 ) ; let lastnum = Math . pow ( 10 , n ) ; let count = 0 ; for ( let i = firstnum ; i < lastnum ; i ++ ) if ( i % number == 0 ) count ++ ; return count ; }
Ref: 
function numberofterm ( $ n , $ number ) { $ firstnum = pow ( 10 , $ n - 1 ) ; $ lastnum = pow ( 10 , $ n ) ; $ count = 0 ; for ( $ i = $ firstnum ; $ i < $ lastnum ; $ i ++ ) if ( $ i % $ number == 0 ) $ count ++ ; return $ count ; }
Hyp: 
function numberofterm ( $ n , $ number ) { $ firstnum = pow ( 10 , $ n - 1 ) ; $ lastnum = pow ( 10 , $ n ) ; $ count = 0 ; for ( $ i = $ firstnum ; $ i < $ lastnum ; $ i ++ ) if ( $ i % $ number == 0 ) $ count ++ ; return $ count ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function printElements ( arr , n ) { for ( var i = 1 ; i < n - 1 ; i ++ ) { if ( arr [ i ] > arr [ i - 1 ] && arr [ i ] > arr [ i + 1 ] ) document . write ( arr [ i ] + " " ) ; } }
Ref: 
function printElements ( $ arr , $ n ) { for ( $ i = 1 ; $ i < $ n - 1 ; $ i ++ ) { if ( $ arr [ $ i ] > $ arr [ $ i - 1 ] and $ arr [ $ i ] > $ arr [ $ i + 1 ] ) echo $ arr [ $ i ] . " ▁ " ; } }
Hyp: 
function printElements ( $ arr , $ n ) { for ( $ i = 1 ; $ i < $ n - 1 ; $ i ++ ) { if ( $ arr [ $ i ] > $ arr [ $ i - 1 ] && $ arr [ $ i ] > $ arr [ $ i + 1 ] ) echo $ arr [ $ i ] . " ▁ " ; } }

BLEU: 96.74
Edit Sim: 3


Src: 
function Check_is_possible ( l , r , k ) { var count = 0 ; for ( i = l ; i <= r ; i ++ ) { if ( i % k == 0 ) { count ++ ; } } return ( count > 1 ) ; } var l = 4 , r = 12 ; var k = 5 ; if ( Check_is_possible ( l , r , k ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
Ref: 
function Check_is_possible ( $ l , $ r , $ k ) { $ count = 0 ; for ( $ i = $ l ; $ i <= $ r ; $ i ++ ) { if ( $ i % $ k == 0 ) $ count ++ ; } return ( $ count > 1 ) ; }
Hyp: 
function Check_is_possible ( $ l , $ r , $ k ) { $ count = 0 ; for ( $ i = $ l ; $ i <= $ r ; $ i ++ ) { if ( $ i % $ k == 0 ) { $ count ++ ; } } return ( $ count > 1 ) ; } $ l = 4 ; $ r = 12 ; $ k = 5 ; if ( Check_is_possible ( $ l , $ r , $ k ) ) { echo " Yes " ; } else { echo " No " ; }

BLEU: 54.62
Edit Sim: 122


Src: 
function breakSum ( n ) { let dp = new Array ( n + 1 ) ; for ( let i = 0 ; i < dp ; i ++ ) { dp [ i ] = 0 ; } dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; for ( let i = 2 ; i <= n ; i ++ ) dp [ i ] = Math . max ( dp [ Math . floor ( i / 2 ) ] + dp [ Math . floor ( i / 3 ) ] + dp [ Math . floor ( i / 4 ) ] , i ) ; return dp [ n ] ; }
Ref: 
function breakSum ( $ n ) { $ dp = array_fill ( 0 , $ n + 1 , 0 ) ; $ dp [ 0 ] = 0 ; $ dp [ 1 ] = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) $ dp [ $ i ] = max ( $ dp [ ( int ) ( $ i / 2 ) ] + $ dp [ ( int ) ( $ i / 3 ) ] + $ dp [ ( int ) ( $ i / 4 ) ] , $ i ) ; return $ dp [ $ n ] ; }
Hyp: 
function breakSum ( $ n ) { $ dp = array_fill ( 0 , $ n + 1 , NULL ) ; $ dp [ 0 ] = 0 ; $ dp [ 1 ] = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) $ dp [ $ i ] = max ( $ dp [ $ i / 2 ] + $ dp [ $ i / 3 ] + $ dp [ $ i / 4 ] , $ i ) ; return $ dp [ $ n ] ; }

BLEU: 76.59
Edit Sim: 40


Src: 
function maxPathSum ( tri ) { var ans = 0 ; for ( var i = N - 2 ; i >= 0 ; i -- ) { for ( var j = 0 ; j < N - i ; j ++ ) { if ( j - 1 >= 0 ) tri [ i ] [ j ] += Math . max ( tri [ i + 1 ] [ j ] , tri [ i + 1 ] [ j - 1 ] ) ; else tri [ i ] [ j ] += tri [ i + 1 ] [ j ] ; ans = Math . max ( ans , tri [ i ] [ j ] ) ; } } return ans ; }
Ref: 
function maxPathSum ( $ tri ) { global $ N ; $ ans = 0 ; for ( $ i = $ N - 2 ; $ i >= 0 ; $ i -- ) { for ( $ j = 0 ; $ j < $ N - $ i ; $ j ++ ) { if ( $ j - 1 >= 0 ) $ tri [ $ i ] [ $ j ] += max ( $ tri [ $ i + 1 ] [ $ j ] , $ tri [ $ i + 1 ] [ $ j - 1 ] ) ; else $ tri [ $ i ] [ $ j ] += $ tri [ $ i + 1 ] [ $ j ] ; $ ans = max ( $ ans , $ tri [ $ i ] [ $ j ] ) ; } } return $ ans ; }
Hyp: 
function maxPathSum ( $ tri ) { global $ N ; $ ans = 0 ; for ( $ i = $ N - 2 ; $ i >= 0 ; $ i -- ) { for ( $ j = 0 ; $ j < $ N - $ i ; $ j ++ ) { if ( $ j - 1 >= 0 ) $ tri [ $ i ] [ $ j ] += max ( $ tri [ $ i + 1 ] [ $ j ] , $ tri [ $ i + 1 ] [ $ j - 1 ] ) ; else $ tri [ $ i ] [ $ j ] += $ tri [ $ i + 1 ] [ $ j ] ; $ ans = max ( $ ans , $ tri [ $ i ] [ $ j ] ) ; } } return $ ans ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function contiguousPerfectSquare ( arr , n ) { var a ; var b ; var current_length = 0 ; var max_length = 0 ; for ( var i = 0 ; i < n ; i ++ ) { b = ( Math . sqrt ( arr [ i ] ) ) ; a = parseInt ( b ) ; if ( a == b ) current_length ++ ; else current_length = 0 ; max_length = Math . max ( max_length , current_length ) ; } return max_length ; }
Ref: 
function contiguousPerfectSquare ( $ arr , $ n ) { $ current_length = 0 ; $ max_length = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ b = ( float ) sqrt ( $ arr [ $ i ] ) ; $ a = ( int ) $ b ; if ( $ a == $ b ) $ current_length = $ current_length + 1 ; else $ current_length = 0 ; $ max_length = max ( $ max_length , $ current_length ) ; } return $ max_length ; }
Hyp: 
function contiguousPerfectSquare ( $ arr , $ n ) { $ a ; $ b ; $ current_length = 0 ; $ max_length = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ b = sqrt ( $ arr [ $ i ] ) ; $ a = ( int ) ( $ b ) ; if ( $ a == $ b ) $ current_length ++ ; else $ current_length = 0 ; $ max_length = max ( $ max_length , $ current_length ) ; } return $ max_length ; }

BLEU: 85.97
Edit Sim: 47


Src: 
function octant ( x , y , z ) { if ( x >= 0 && y >= 0 && z >= 0 ) document . write ( " " + " " ) ; else if ( x < 0 && y >= 0 && z >= 0 ) document . write ( " " + " " ) ; else if ( x < 0 && y < 0 && z >= 0 ) document . write ( " " + " " ) ; else if ( x >= 0 && y < 0 && z >= 0 ) document . write ( " " + " " ) ; else if ( x >= 0 && y >= 0 && z < 0 ) document . write ( " " + " " ) ; else if ( x < 0 && y >= 0 && z < 0 ) document . write ( " " + " " ) ; else if ( x < 0 && y < 0 && z < 0 ) document . write ( " " + " " ) ; else if ( x >= 0 && y < 0 && z < 0 ) document . write ( " " + " " ) ; }
Ref: 
function octant ( $ x , $ y , $ z ) { if ( $ x >= 0 && $ y >= 0 && $ z >= 0 ) echo " Point ▁ lies ▁ in ▁ 1st ▁ octant STRNEWLINE " ; else if ( $ x < 0 && $ y >= 0 && $ z >= 0 ) echo " Point ▁ lies ▁ in ▁ 2nd ▁ octant STRNEWLINE " ; else if ( $ x < 0 && $ y < 0 && $ z >= 0 ) echo " Point ▁ lies ▁ in ▁ 3rd ▁ octant STRNEWLINE " ; else if ( $ x >= 0 && $ y < 0 && $ z >= 0 ) echo " Point ▁ lies ▁ in ▁ 4th ▁ octant STRNEWLINE " ; else if ( $ x >= 0 && $ y >= 0 && $ z < 0 ) echo " Point ▁ lies ▁ in ▁ 5th ▁ octant STRNEWLINE " ; else if ( $ x < 0 && $ y >= 0 && $ z < 0 ) echo " Point ▁ lies ▁ in ▁ 6th ▁ octant STRNEWLINE " ; else if ( $ x < 0 && $ y < 0 && $ z < 0 ) echo " Point ▁ lies ▁ in ▁ 7th ▁ octant STRNEWLINE " ; else if ( $ x >= 0 && $ y < 0 && $ z < 0 ) echo " Point ▁ lies ▁ in ▁ 8th ▁ octant STRNEWLINE " ; }
Hyp: 
function octant ( $ x , $ y , $ z ) { if ( $ x >= 0 && $ y >= 0 && $ z >= 0 ) echo "0" ; else if ( $ x < 0 && $ y >= 0 && $ z >= 0 ) echo "0" ; else if ( $ x < 0 && $ y < 0 && $ z >= 0 ) echo "0" ; else if ( $ x >= 0 && $ y < 0 && $ z >= 0 ) echo "0" ; else if ( $ x >= 0 && $ y >= 0 && $ z < 0 ) echo "0" ; else if ( $ x < 0 && $ y >= 0 && $ z < 0 ) echo "0" ; else if ( $ x < 0 && $ y < 0 && $ z < 0 ) echo "0" ; else if ( $ x < 0 && $ y < 0 && $ z < 0 ) echo "0" ; else if ( $ x >= 0 && $ y < 0 && $ z < 0 ) echo "0" ; else if ( $ x >= 0 && $ y < 0 && $ z < 0 ) echo "0" ; }

BLEU: 58.67
Edit Sim: 356


Src: 
function countSol ( coeff , n , rhs ) { let dp = new Array ( rhs + 1 ) ; dp . fill ( 0 ) ; dp [ 0 ] = 1 ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = coeff [ i ] ; j <= rhs ; j ++ ) dp [ j ] += dp [ j - coeff [ i ] ] ; return dp [ rhs ] ; }
Ref: 
function countSol ( $ coeff , $ n , $ rhs ) { $ dp = str_repeat ( " \0" , 256 ) ; $ dp [ 0 ] = 1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = $ coeff [ $ i ] ; $ j <= $ rhs ; $ j ++ ) $ dp [ $ j ] = $ dp [ $ j ] + ( $ dp [ $ j - $ coeff [ $ i ] ] ) ; return $ dp [ $ rhs ] ; }
Hyp: 
function countSol ( $ coeff , $ n , $ rhs ) { $ dp = array_fill ( 0 , $ rhs + 1 , 0 ) ; $ dp [ 0 ] = 1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = $ coeff [ $ i ] ; $ j <= $ rhs ; $ j ++ ) $ dp [ $ j ] += $ dp [ $ j - $ coeff [ $ i ] ] ; return $ dp [ $ rhs ] ; }

BLEU: 81.95
Edit Sim: 42


Src: 
function winner ( a , n , k ) { if ( k >= n - 1 ) return n ; let best = 0 , times = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] > best ) { best = a [ i ] ; if ( i ) times = 1 ; } else times += 1 ; if ( times >= k ) return best ; } return best ; }
Ref: 
function winner ( $ a , $ n , $ k ) { if ( $ k >= $ n - 1 ) return $ n ; $ best = 0 ; $ times = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] > $ best ) { $ best = $ a [ $ i ] ; if ( $ i ) $ times = 1 ; } else $ times += 1 ; if ( $ times >= $ k ) return $ best ; } return $ best ; }
Hyp: 
function winner ( $ a , $ n , $ k ) { if ( $ k >= $ n - 1 ) return $ n ; $ best = 0 ; $ times = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] > $ best ) { $ best = $ a [ $ i ] ; if ( $ i ) $ times = 1 ; } else $ times += 1 ; if ( $ times >= $ k ) return $ best ; } return $ best ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function seriesSum ( n ) { return ( n * ( n + 1 ) * ( n + 2 ) ) / 6 ; }
Ref: 
function seriesSum ( $ n ) { return ( $ n * ( $ n + 1 ) * ( $ n + 2 ) ) / 6 ; }
Hyp: 
function seriesSum ( $ n ) { return ( $ n * ( $ n + 1 ) * ( $ n + 2 ) ) / 6 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function Permutations ( n , k ) { var ans = 1 ; if ( k >= 2 ) ans += ( n ) * ( n - 1 ) / 2 ; if ( k >= 3 ) ans += ( n ) * ( n - 1 ) * ( n - 2 ) * 2 / 6 ; if ( k >= 4 ) ans += ( n ) * ( n - 1 ) * ( n - 2 ) * ( n - 3 ) * 9 / 24 ; return ans ; }
Ref: 
function Permutations ( $ n , $ k ) { $ ans = 1 ; if ( $ k >= 2 ) $ ans += ( $ n ) * ( $ n - 1 ) / 2 ; if ( $ k >= 3 ) $ ans += ( $ n ) * ( $ n - 1 ) * ( $ n - 2 ) * 2 / 6 ; if ( $ k >= 4 ) $ ans += ( $ n ) * ( $ n - 1 ) * ( $ n - 2 ) * ( $ n - 3 ) * 9 / 24 ; return $ ans ; }
Hyp: 
function Permutations ( $ n , $ k ) { $ ans = 1 ; if ( $ k >= 2 ) $ ans += ( $ n ) * ( $ n - 1 ) / 2 ; if ( $ k >= 3 ) $ ans += ( $ n ) * ( $ n - 1 ) * ( $ n - 2 ) * 2 / 6 ; if ( $ k >= 4 ) $ ans += ( $ n ) * ( $ n - 1 ) * ( $ n - 2 ) * ( $ n - 3 ) * 9 / 24 ; return $ ans ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findNumber ( n , d ) { let ans = " " ; if ( d != 10 ) { ans += ( d ) . toString ( ) ; for ( let i = 1 ; i < n ; i ++ ) ans += ' ' ; } else { if ( n == 1 ) ans += " " ; else { ans += ' ' ; for ( let i = 1 ; i < n ; i ++ ) ans += ' ' ; } } return ans ; }
Ref: 
function findNumber ( $ n , $ d ) { $ ans = " " ; if ( $ d != 10 ) { $ ans . = strval ( $ d ) ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ ans . = '0' ; } else { if ( n == 1 ) $ ans . = " Impossible " ; else $ ans . = '1' ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ ans . = '0' ; } return $ ans ; }
Hyp: 
function findNumber ( $ n , $ d ) { $ ans = "9" ; if ( $ d != 10 ) { $ ans += ( $ d ) . toString ( ) ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ ans += '0' ; } else { if ( $ n == 1 ) $ ans . = "0" ; else { $ ans . = '9' ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ ans . = '0' ; } } return $ ans ; }

BLEU: 78.42
Edit Sim: 41


Src: 
function find_sum ( n , k ) { let total_sum = ( n * ( n + 1 ) ) / 2 ; let power = k ; while ( power <= n ) { total_sum -= power ; power *= k ; } return total_sum ; }
Ref: 
function find_sum ( $ n , $ k ) { $ total_sum = ( $ n * ( $ n + 1 ) ) / 2 ; $ power = $ k ; while ( $ power <= $ n ) { $ total_sum -= $ power ; $ power *= $ k ; } return $ total_sum ; }
Hyp: 
function find_sum ( $ n , $ k ) { $ total_sum = ( $ n * ( $ n + 1 ) ) / 2 ; $ power = $ k ; while ( $ power <= $ n ) { $ total_sum -= $ power ; $ power *= $ k ; } return $ total_sum ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findPermutation ( n ) { let len = Math . ceil ( Math . log10 ( n ) ) ; for ( let i = 0 ; i < len ; i ++ ) { if ( n % 2 != 0 ) { return parseInt ( n ) ; } else { n = ( n / 10 ) + ( n % 10 ) * Math . pow ( 10 , len - i - 1 ) ; continue ; } } return - 1 ; }
Ref: 
function findPermutation ( $ n ) { $ len = ceil ( log10 ( $ n ) ) ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { if ( $ n % 2 != 0 ) { return ( int ) $ n ; } else { $ n = ( $ n / 10 ) + ( $ n % 10 ) * pow ( 10 , $ len - $ i - 1 ) ; continue ; } } return -1 ; }
Hyp: 
function findPermutation ( $ n ) { $ len = ( int ) ceil ( log10 ( $ n ) ) ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { if ( $ n % 2 != 0 ) { return ( int ) $ n ; } else { $ n = ( $ n / 10 ) + ( $ n % 10 ) * pow ( 10 , $ len - $ i - 1 ) ; continue ; } } return -1 ; }

BLEU: 95.36
Edit Sim: 8


Src: 
function sumOfSeries ( n ) { return 0.0246 * ( Math . pow ( 10 , n ) - 1 - ( 9 * n ) ) ; }
Ref: 
function sumOfSeries ( $ n ) { return 0.0246 * ( pow ( 10 , $ n ) - 1 - ( 9 * $ n ) ) ; }
Hyp: 
function sumOfSeries ( $ n ) { return 0.0246 * ( pow ( 10 , $ n ) - 1 - ( 9 * $ n ) ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function search ( arr , n , x ) { let i = 0 ; while ( i < n ) { if ( arr [ i ] == x ) return i ; i = i + Math . abs ( arr [ i ] - x ) ; } document . write ( " " ) ; return - 1 ; }
Ref: 
function search ( $ arr , $ n , $ x ) { $ i = 0 ; while ( $ i < $ n ) { if ( $ arr [ $ i ] == $ x ) return $ i ; $ i = $ i + abs ( $ arr [ $ i ] - $ x ) ; } echo " number ▁ is ▁ not ▁ present ! " ; return -1 ; }
Hyp: 
function search ( $ arr , $ n , $ x ) { $ i = 0 ; while ( $ i < $ n ) { if ( $ arr [ $ i ] == $ x ) return $ i ; $ i = $ i + abs ( $ arr [ $ i ] - $ x ) ; } echo " No ▁ such ▁ element " ; return -1 ; }

BLEU: 88.42
Edit Sim: 18


Src: 
function primesInRange ( n ) { let fact = 1 ; for ( let k = 2 ; k < n ; k ++ ) { fact = fact * ( k - 1 ) ; if ( ( fact + 1 ) % k == 0 ) document . write ( ( k + " " ) ) ; } }
Ref: 
function primesInRange ( $ n ) { $ fact = 1 ; for ( $ k = 2 ; $ k < $ n ; $ k ++ ) { $ fact = $ fact * ( $ k - 1 ) ; if ( ( $ fact + 1 ) % $ k == 0 ) print ( $ k . " STRNEWLINE " ) ; } }
Hyp: 
function primesInRange ( $ n ) { $ fact = 1 ; for ( $ k = 2 ; $ k < $ n ; $ k ++ ) { $ fact = $ fact * ( $ k - 1 ) ; if ( ( $ fact + 1 ) % $ k == 0 ) echo ( $ k . " " ) ; } }

BLEU: 92.58
Edit Sim: 16


Src: 
function geometricMean ( arr , n ) { let product = 1 ; for ( let i = 0 ; i < n ; i ++ ) product = product * arr [ i ] ; let gm = Math . pow ( product , 1 / n ) ; return gm ; }
Ref: 
function geometricMean ( $ arr , $ n ) { $ product = 1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ product = $ product * $ arr [ $ i ] ; $ gm = pow ( $ product , ( float ) ( 1 / $ n ) ) ; return $ gm ; }
Hyp: 
function geometricMean ( $ arr , $ n ) { $ product = 1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ product = $ product * $ arr [ $ i ] ; $ gm = pow ( $ product , 1 / $ n ) ; return $ gm ; }

BLEU: 89.11
Edit Sim: 14


Src: 
function printPermutation ( n , k ) { for ( var i = 1 ; i <= n ; i ++ ) { var x = 2 * i - 1 ; var y = 2 * i ; if ( i <= k ) document . write ( y + " " + x + " " ) ; else document . write ( x + " " + y + " " ) ; } }
Ref: 
function printPermutation ( $ n , $ k ) { for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ x = 2 * $ i - 1 ; $ y = 2 * $ i ; if ( $ i <= $ k ) echo $ y . " " ▁ . ▁ $ x ▁ . ▁ " " else echo $ x . " ▁ " . $ y . " ▁ " ; } }
Hyp: 
function printPermutation ( $ n , $ k ) { for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ x = 2 * $ i - 1 ; $ y = 2 * $ i ; if ( $ i <= $ k ) echo $ y . " , ▁ " . $ x . " STRNEWLINE " ; else echo $ x . " , ▁ " . $ y . " STRNEWLINE " ; } }

BLEU: 82.63
Edit Sim: 28


Src: 
function bitPos ( n1 , n2 ) { if ( n1 == n2 ) return 0 ; let bitCount1 = Math . floor ( Math . log2 ( n1 ) ) + 1 ; let bitCount2 = Math . floor ( Math . log2 ( n2 ) ) + 1 ; let bitDiff = Math . abs ( bitCount1 - bitCount2 ) ; let maxBitCount = Math . max ( bitCount1 , bitCount2 ) ; if ( bitCount1 > bitCount2 ) { n2 = n2 * Math . pow ( 2 , bitDiff ) ; } else { n1 = n1 * Math . pow ( 2 , bitDiff ) ; } let xorValue = n1 ^ n2 ; let bitCountXorValue = Math . floor ( Math . log2 ( xorValue ) ) + 1 ; let disSimilarBitPosition = maxBitCount - bitCountXorValue + 1 ; return disSimilarBitPosition ; }
Ref: 
function bitPos ( $ n1 , $ n2 ) { if ( $ n1 == $ n2 ) return 0 ; $ bitCount1 = floor ( log ( $ n1 , 2 ) ) + 1 ; $ bitCount2 = floor ( log ( $ n2 , 2 ) ) + 1 ; $ bitDiff = abs ( $ bitCount1 - $ bitCount2 ) ; $ maxBitCount = max ( $ bitCount1 , $ bitCount2 ) ; if ( $ bitCount1 > $ bitCount2 ) { $ n2 = $ n2 * pow ( 2 , $ bitDiff ) ; } else { $ n1 = $ n1 * pow ( 2 , $ bitDiff ) ; } $ xorValue = $ n1 ^ $ n2 ; $ bitCountXorValue = floor ( log ( $ xorValue , 2 ) ) + 1 ; $ disSimilarBitPosition = $ maxBitCount - $ bitCountXorValue + 1 ; return $ disSimilarBitPosition ; }
Hyp: 
function bitPos ( $ n1 , $ n2 ) { if ( $ n1 == $ n2 ) return 0 ; $ bitCount1 = log2 ( $ n1 ) + 1 ; $ bitCount2 = log2 ( $ n2 ) + 1 ; $ bitDiff = abs ( $ bitCount1 - $ bitCount2 ) ; $ maxBitCount = max ( $ bitCount1 , $ bitCount2 ) ; if ( $ bitCount1 > $ bitCount2 ) { $ n2 = $ n2 * pow ( 2 , $ bitDiff ) ; } else { $ n1 = $ n1 * pow ( 2 , $ bitDiff ) ; } $ xorValue = $ n1 ^ $ n2 ; $ bitCountXorValue = log2 ( $ xorValue ) + 1 ; $ disSimilarBitPosition = $ maxBitCount - $ bitCountXorValue + 1 ; return $ disSimilarBitPosition ; }

BLEU: 82.43
Edit Sim: 45


Src: 
function countDer ( n ) { let der = new Array ( n + 1 ) ; der [ 1 ] = 0 ; der [ 2 ] = 1 ; for ( let i = 3 ; i <= n ; ++ i ) der [ i ] = ( i - 1 ) * ( der [ i - 1 ] + der [ i - 2 ] ) ; return der [ n ] ; }
Ref: 
function countDer ( $ n ) { $ der [ 1 ] = 0 ; $ der [ 2 ] = 1 ; for ( $ i = 3 ; $ i <= $ n ; ++ $ i ) $ der [ $ i ] = ( $ i - 1 ) * ( $ der [ $ i - 1 ] + $ der [ $ i - 2 ] ) ; return $ der [ $ n ] ; }
Hyp: 
function countDer ( $ n ) { $ der = array_fill ( 0 , $ n + 1 , NULL ) ; $ der [ 1 ] = 0 ; $ der [ 2 ] = 1 ; for ( $ i = 3 ; $ i <= $ n ; ++ $ i ) $ der [ $ i ] = ( $ i - 1 ) * ( $ der [ $ i - 1 ] + $ der [ $ i - 2 ] ) ; return $ der [ $ n ] ; }

BLEU: 84.35
Edit Sim: 44


Src: 
function equation_ellipse ( x1 , y1 , a , b , c , e ) { var t = a * a + b * b ; var a1 = t - e * ( a * a ) ; var b1 = t - e * ( b * b ) ; var c1 = ( - 2 * t * x1 ) - ( 2 * e * c * a ) ; var d1 = ( - 2 * t * y1 ) - ( 2 * e * c * b ) ; var e1 = - 2 * e * a * b ; var f1 = ( - e * c * c ) + ( t * x1 * x1 ) + ( t * y1 * y1 ) ; document . write ( " " + " " ) ; document . write ( a1 + " " + b1 + " " + c1 + " " + d1 + " " + e1 + " " + f1 + " " ) ; }
Ref: 
function equation_ellipse ( $ x1 , $ y1 , $ a , $ b , $ c , $ e ) { $ t = ( $ a * $ a ) + ( $ b * $ b ) ; $ a1 = $ t - $ e * ( $ a * $ a ) ; $ b1 = $ t - $ e * ( $ b * $ b ) ; $ c1 = ( -2 * $ t * $ x1 ) - ( 2 * $ e * $ c * $ a ) ; $ d1 = ( -2 * $ t * $ y1 ) - ( 2 * $ e * $ c * $ b ) ; $ e1 = -2 * $ e * $ a * $ b ; $ f1 = ( - $ e * $ c * $ c ) + ( $ t * $ x1 * $ x1 ) + ( $ t * $ y1 * $ y1 ) ; $ fixed ; echo " Equation ▁ of ▁ ellipse ▁ is ▁ STRNEWLINE " , $ a1 , " ▁ x ^ 2 ▁ + ▁ " , $ b1 , " ▁ y ^ 2 ▁ + ▁ " , $ c1 , " ▁ x ▁ + ▁ " , $ d1 , " ▁ y ▁ + ▁ " , $ e1 , " ▁ xy ▁ + ▁ " , $ f1 , " ▁ = ▁ 0" ; }
Hyp: 
function equation_ellipse ( $ x1 , $ y1 , $ a , $ b , $ c , $ e ) { $ t = $ a * $ a + $ b * $ b ; $ a1 = $ t - $ e * ( $ a * $ a ) ; $ b1 = $ t - $ e * ( $ b * $ b ) ; $ c1 = ( - 2 * $ t * $ x1 ) - ( 2 * $ e * $ c * $ a ) ; $ d1 = ( - 2 * $ t * $ y1 ) - ( 2 * $ e * $ c * $ b ) ; $ e1 = - 2 * $ e * $ a * $ b ; $ f1 = ( - $ e * $ c * $ c ) + ( $ t * $ x1 * $ x1 ) + ( $ t * $ y1 * $ y1 ) ; echo " Result ▁ is ▁ " , " STRNEWLINE " ; }

BLEU: 59.91
Edit Sim: 186


Src: 
function reversDigits ( num ) { if ( num > 0 ) { reversDigits ( Math . floor ( num / 10 ) ) ; rev_num += ( num % 10 ) * base_pos ; base_pos *= 10 ; } return rev_num ; }
Ref: 
function reversDigits ( $ num ) { global $ rev_num ; global $ base_pos ; if ( $ num > 0 ) { reversDigits ( ( int ) ( $ num / 10 ) ) ; $ rev_num += ( $ num % 10 ) * $ base_pos ; $ base_pos *= 10 ; } return $ rev_num ; }
Hyp: 
function reversDigits ( $ num ) { if ( $ num > 0 ) { reversDigits ( $ num / 10 ) ; $ rev_num += ( $ num % 10 ) * $ base_pos ; $ base_pos *= 10 ; } return $ rev_num ; }

BLEU: 70.68
Edit Sim: 51


Src: 
function findMinZero ( p ) { let first = 1 ; let second = 1 ; let number = 2 ; let next = 1 ; while ( next ) { next = ( first + second ) % p ; first = second ; second = next ; number ++ ; } return number ; }
Ref: 
function findMinZero ( $ p ) { $ first = 1 ; $ second = 1 ; $ number = 2 ; $ next = 1 ; while ( $ next ) { $ next = ( $ first + $ second ) % $ p ; $ first = $ second ; $ second = $ next ; $ number ++ ; } return $ number ; }
Hyp: 
function findMinZero ( $ p ) { $ first = 1 ; $ second = 1 ; $ number = 2 ; $ next = 1 ; while ( $ next ) { $ next = ( $ first + $ second ) % $ p ; $ first = $ second ; $ second = $ next ; $ number ++ ; } return $ number ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findMinSum ( a , b , n ) { a . sort ( ) ; b . sort ( ) ; let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum = sum + Math . abs ( a [ i ] - b [ i ] ) ; return sum ; }
Ref: 
function findMinSum ( $ a , $ b , $ n ) { sort ( $ a ) ; sort ( $ a , $ n ) ; sort ( $ b ) ; sort ( $ b , $ n ) ; $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum = $ sum + abs ( $ a [ $ i ] - $ b [ $ i ] ) ; return $ sum ; }
Hyp: 
function findMinSum ( $ a , $ b , $ n ) { sort ( $ a ) ; sort ( $ b ) ; $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum = $ sum + abs ( $ a [ $ i ] - $ b [ $ i ] ) ; return $ sum ; }

BLEU: 78.39
Edit Sim: 42


Src: 
function areAllBitsSet ( n ) { if ( n == 0 ) return " " ; while ( n > 0 ) { if ( ( n & 1 ) == 0 ) return " " ; n = n >> 1 ; } return " " ; }
Ref: 
function areAllBitsSet ( $ n ) { if ( $ n == 0 ) return " No " ; while ( $ n > 0 ) { if ( ( $ n & 1 ) == 0 ) return " No " ; $ n = $ n >> 1 ; } return " Yes " ; }
Hyp: 
function areAllBitsSet ( $ n ) { if ( $ n == 0 ) return "0" ; while ( $ n > 0 ) { if ( ( $ n & 1 ) == 0 ) return "1" ; $ n = $ n >> 1 ; } return "0" ; }

BLEU: 76.24
Edit Sim: 13


Src: 
function maxArea ( a , b , c , d ) { let semiperimeter = ( a + b + c + d ) / 2 ; return Math . sqrt ( ( semiperimeter - a ) * ( semiperimeter - b ) * ( semiperimeter - c ) * ( semiperimeter - d ) ) ; }
Ref: 
function maxArea ( $ a , $ b , $ c , $ d ) { $ semiperimeter = ( $ a + $ b + $ c + $ d ) / 2 ; return sqrt ( ( $ semiperimeter - $ a ) * ( $ semiperimeter - $ b ) * ( $ semiperimeter - $ c ) * ( $ semiperimeter - $ d ) ) ; }
Hyp: 
function maxArea ( $ a , $ b , $ c , $ d ) { $ semiperimeter = ( $ a + $ b + $ c + $ d ) / 2 ; return sqrt ( ( $ semiperimeter - $ a ) * ( $ semiperimeter - $ b ) * ( $ semiperimeter - $ c ) * ( $ semiperimeter - $ d ) ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function isCornerPresent ( str , corner ) { var n = str . length ; var cl = corner . length ; if ( n < cl ) return false ; return ( str . substring ( 0 , cl ) . localeCompare ( corner ) === 0 && str . substring ( n - cl , n ) . localeCompare ( corner ) === 0 ) ; }
Ref: 
function isCornerPresent ( $ str , $ corner ) { $ n = strlen ( $ str ) ; $ cl = strlen ( $ corner ) ; if ( $ n < $ cl ) return false ; return ( ! strcmp ( substr ( $ str , 0 , $ cl ) , $ corner ) && ! strcmp ( substr ( $ str , $ n - $ cl , $ cl ) , $ corner ) ) ; }
Hyp: 
function isCornerPresent ( $ str , $ corner ) { $ n = strlen ( $ str ) ; $ cl = strlen ( $ corner ) ; if ( $ n < $ cl ) return false ; return ( $ str [ 0 ] == $ cl && $ str [ ( $ n - $ cl ) ] == $ corner && $ str [ ( $ n - $ cl ) ] == $ corner ) ; }

BLEU: 63.98
Edit Sim: 58


Src: 
function maxXOR ( n , k ) { let c = ( Math . log ( n ) / Math . log ( 2 ) ) + 1 ; return ( ( 1 << c ) - 1 ) ; }
Ref: 
function maxXOR ( $ n , $ k ) { $ c = log ( $ n , 2 ) + 1 ; return ( ( 1 << $ c ) - 1 ) ; }
Hyp: 
function maxXOR ( $ n , $ k ) { $ c = ( log ( $ n ) / log ( 2 ) ) + 1 ; return ( ( 1 << $ c ) - 1 ) ; }

BLEU: 75.99
Edit Sim: 13


Src: 
function findRadiusOfIncircle ( a , b , c ) { if ( a < 0 b < 0 c < 0 ) return - 1 ; var p = ( a + b + c ) / 2 ; var area = Math . sqrt ( p * ( p - a ) * ( p - b ) * ( p - c ) ) ; var radius = area / p ; return radius ; }
Ref: 
function findRadiusOfIncircle ( $ a , $ b , $ c ) { if ( $ a < 0 $ b < 0 $ c < 0 ) return -1 ; $ p = ( $ a + $ b + $ c ) / 2 ; $ area = sqrt ( $ p * ( $ p - $ a ) * ( $ p - $ b ) * ( $ p - $ c ) ) ; $ radius = $ area / $ p ; return $ radius ; }
Hyp: 
function findRadiusOfIncircle ( $ a , $ b , $ c ) { if ( $ a < 0 $ b < 0 $ c < 0 ) return -1 ; $ p = ( $ a + $ b + $ c ) / 2 ; $ area = sqrt ( $ p * ( $ p - $ a ) * ( $ p - $ b ) * ( $ p - $ c ) ) ; $ radius = $ area / $ p ; return $ radius ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function FindPoint ( x1 , y1 , x2 , y2 , x , y ) { if ( x > x1 && x < x2 && y > y1 && y < y2 ) return true ; return false ; }
Ref: 
function FindPoint ( $ x1 , $ y1 , $ x2 , $ y2 , $ x , $ y ) { if ( $ x > $ x1 and $ x < $ x2 and $ y > $ y1 and $ y < $ y2 ) return true ; return false ; }
Hyp: 
function FindPoint ( $ x1 , $ y1 , $ x2 , $ y2 , $ x , $ y ) { if ( $ x > $ x1 && $ x < $ x2 && $ y > $ y1 && $ y < $ y2 ) return true ; return false ; }

BLEU: 85.86
Edit Sim: 9


Src: 
function isSpiltPossible ( n , a ) { let sum = 0 , c1 = 0 ; for ( let i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; if ( a [ i ] == 1 ) { c1 ++ ; } } if ( sum % 2 != 0 ) return false ; if ( ( sum / 2 ) % 2 == 0 ) return true ; if ( c1 > 0 ) return true ; else return false ; }
Ref: 
function isSpiltPossible ( $ n , $ a ) { $ sum = 0 ; $ c1 = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sum += $ a [ $ i ] ; if ( $ a [ $ i ] == 1 ) { $ c1 ++ ; } } if ( $ sum % 2 != 0 ) return false ; if ( ( $ sum / 2 ) % 2 == 0 ) return true ; if ( $ c1 > 0 ) return true ; else return false ; }
Hyp: 
function isSpiltPossible ( $ n , $ a ) { $ sum = 0 ; $ c1 = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sum += $ a [ $ i ] ; if ( $ a [ $ i ] == 1 ) { $ c1 ++ ; } } if ( $ sum % 2 != 0 ) return false ; if ( ( $ sum / 2 ) % 2 == 0 ) return true ; if ( $ c1 > 0 ) return true ; else return false ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countSubStr ( str , n ) { for ( let i = 0 ; i < n ; i ++ ) { if ( str [ i ] == ' ' ) m ++ ; } return m * Math . floor ( ( m - 1 ) / 2 ) ; }
Ref: 
function countSubStr ( $ str ) { for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) { if ( $ str [ $ i ] == '1' ) { $ m ++ ; } } return $ m * ( $ m - 1 ) / 2 ; }
Hyp: 
function countSubStr ( $ str , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ str [ $ i ] == '1' ) $ m ++ ; } return $ m * ( int ) ( ( $ m - 1 ) / 2 ) ; }

BLEU: 72.91
Edit Sim: 36


Src: 
function SubArraySum ( arr , n ) { let result = 0 ; for ( let i = 0 ; i < n ; i ++ ) result += ( arr [ i ] * ( i + 1 ) * ( n - i ) ) ; return result ; }
Ref: 
function SubArraySum ( $ arr , $ n ) { $ result = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ result += ( $ arr [ $ i ] * ( $ i + 1 ) * ( $ n - $ i ) ) ; return $ result ; }
Hyp: 
function SubArraySum ( $ arr , $ n ) { $ result = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ result += ( $ arr [ $ i ] * ( $ i + 1 ) * ( $ n - $ i ) ) ; return $ result ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function harmonicMean ( arr , n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum = sum + ( 1 / arr [ i ] ) ; return n / sum ; }
Ref: 
function harmonicMean ( $ arr , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum = $ sum + ( float ) ( 1 / $ arr [ $ i ] ) ; return ( float ) ( $ n / $ sum ) ; }
Hyp: 
function harmonicMean ( $ arr , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum = $ sum + ( 1 / $ arr [ $ i ] ) ; return $ n / $ sum ; }

BLEU: 81.33
Edit Sim: 24


Src: 
function find_rectangle ( area ) { let l = 0 , b = 0 ; let M = Math . floor ( Math . sqrt ( area ) ) , ans ; for ( let i = M ; i >= 1 ; i -- ) { if ( area % i == 0 ) { l = Math . floor ( area / i ) ; b = i ; break ; } } document . write ( " " + l + " " + b ) ; }
Ref: 
function find_rectangle ( $ area ) { $ M = floor ( sqrt ( $ area ) ) ; for ( $ i = $ M ; $ i >= 1 ; $ i -- ) { if ( $ area % $ i == 0 ) { $ l = floor ( $ area / $ i ) ; $ b = $ i ; break ; } } echo " l = " , ▁ $ l , ▁ " , b = " , ▁ $ b , ▁ " " }
Hyp: 
function find_rectangle ( $ area ) { $ l = 0 ; $ b = 0 ; $ M = ( int ) sqrt ( $ area ) ; $ ans ; for ( $ i = $ M ; $ i >= 1 ; $ i -- ) { if ( $ area % $ i == 0 ) { $ l = ( int ) $ area / $ i ; $ b = $ i ; break ; } } echo " [ " ▁ . $ l ▁ . " ▁ " . $ b ] ; }

BLEU: 62.95
Edit Sim: 62


Src: 
function binarySearch ( arr , l , r , x ) { if ( r >= l ) { let mid = l + Math . floor ( ( r - l ) / 2 ) ; if ( arr [ mid ] == x ) return mid ; if ( arr [ mid ] > x ) return binarySearch ( arr , l , mid - 1 , x ) ; return binarySearch ( arr , mid + 1 , r , x ) ; } return - 1 ; }
Ref: 
function binarySearch ( $ arr , $ l , $ r , $ x ) { if ( $ r >= $ l ) { $ mid = ceil ( $ l + ( $ r - $ l ) / 2 ) ; if ( $ arr [ $ mid ] == $ x ) return floor ( $ mid ) ; if ( $ arr [ $ mid ] > $ x ) return binarySearch ( $ arr , $ l , $ mid - 1 , $ x ) ; return binarySearch ( $ arr , $ mid + 1 , $ r , $ x ) ; } return -1 ; }
Hyp: 
function binarySearch ( $ arr , $ l , $ r , $ x ) { if ( $ r >= $ l ) { $ mid = $ l + ( int ) ( ( $ r - $ l ) / 2 ) ; if ( $ arr [ $ mid ] == $ x ) return $ mid ; if ( $ arr [ $ mid ] > $ x ) return binarySearch ( $ arr , $ l , $ mid - 1 , $ x ) ; return binarySearch ( $ arr , $ mid + 1 , $ r , $ x ) ; } return -1 ; }

BLEU: 91.85
Edit Sim: 20


Src: 
function findMinSum ( num ) { let sum = 0 ; for ( let i = 2 ; i * i <= num ; i ++ ) { while ( num % i == 0 ) { sum += i ; num /= i ; } } sum += num ; return sum ; }
Ref: 
function findMinSum ( $ num ) { $ sum = 0 ; for ( $ i = 2 ; $ i * $ i <= $ num ; $ i ++ ) { while ( $ num % $ i == 0 ) { $ sum += $ i ; $ num /= $ i ; } } $ sum += $ num ; return $ sum ; }
Hyp: 
function findMinSum ( $ num ) { $ sum = 0 ; for ( $ i = 2 ; $ i * $ i <= $ num ; $ i ++ ) { while ( $ num % $ i == 0 ) { $ sum += $ i ; $ num /= $ i ; } } $ sum += $ num ; return $ sum ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function count ( n ) { let table = new Array ( n + 1 ) , i ; for ( let j = 0 ; j < n + 1 ; j ++ ) table [ j ] = 0 ; table [ 0 ] = 1 ; for ( i = 3 ; i <= n ; i ++ ) table [ i ] += table [ i - 3 ] ; for ( i = 5 ; i <= n ; i ++ ) table [ i ] += table [ i - 5 ] ; for ( i = 10 ; i <= n ; i ++ ) table [ i ] += table [ i - 10 ] ; return table [ n ] ; }
Ref: 
function counts ( $ n ) { for ( $ j = 0 ; $ j < $ n + 1 ; $ j ++ ) $ table [ $ j ] = 0 ; $ table [ 0 ] = 1 ; for ( $ i = 3 ; $ i <= $ n ; $ i ++ ) $ table [ $ i ] += $ table [ $ i - 3 ] ; for ( $ i = 5 ; $ i <= $ n ; $ i ++ ) $ table [ $ i ] += $ table [ $ i - 5 ] ; for ( $ i = 10 ; $ i <= $ n ; $ i ++ ) $ table [ $ i ] += $ table [ $ i - 10 ] ; return $ table [ $ n ] ; }
Hyp: 
function countt ( $ n ) { $ table = array_fill ( 0 , $ n + 1 , NULL ) ; $ i ; for ( $ j = 0 ; $ j < $ n + 1 ; $ j ++ ) $ table [ $ j ] = 0 ; $ table [ 0 ] = 1 ; for ( $ i = 3 ; $ i <= $ n ; $ i ++ ) $ table [ $ i ] += $ table [ $ i - 3 ] ; for ( $ i = 5 ; $ i <= $ n ; $ i ++ ) $ table [ $ i ] += $ table [ $ i - 5 ] ; for ( $ i = 10 ; $ i <= $ n ; $ i ++ ) $ table [ $ i ] += $ table [ $ i - 10 ] ; return $ table [ $ n ] ; }

BLEU: 87.38
Edit Sim: 53


Src: 
function countDigits ( a , b ) { var count = 0 ; var p = Math . abs ( parseInt ( a / b ) ) ; if ( p == 0 ) return 1 ; while ( p > 0 ) { count ++ ; p = parseInt ( p / 10 ) ; } return count ; }
Ref: 
function countDigits ( $ a , $ b ) { $ count = 0 ; $ p = abs ( $ a / $ b ) ; if ( $ p == 0 ) return 1 ; while ( $ p > 0 ) { $ count ++ ; $ p = ( int ) ( $ p / 10 ) ; } return $ count ; }
Hyp: 
function countDigits ( $ a , $ b ) { $ count = 0 ; $ p = abs ( $ a / $ b ) ; if ( $ p == 0 ) return 1 ; while ( $ p > 0 ) { $ count ++ ; $ p = ( int ) $ p / 10 ; } return $ count ; }

BLEU: 92.45
Edit Sim: 4


Src: 
function pairs ( arr , n , k ) { var smallest = 1000000000 ; var count = 0 ; for ( var i = 0 ; i < n ; i ++ ) for ( var j = i + 1 ; j < n ; j ++ ) { if ( Math . abs ( arr [ i ] + arr [ j ] - k ) < smallest ) { smallest = Math . abs ( arr [ i ] + arr [ j ] - k ) ; count = 1 ; } else if ( Math . abs ( arr [ i ] + arr [ j ] - k ) == smallest ) count ++ ; } document . write ( " " + smallest + " " ) ; document . write ( " " + count + " " ) ; }
Ref: 
function pairs ( $ arr , $ n , $ k ) { $ smallest = PHP_INT_MAX ; $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) { if ( abs ( $ arr [ $ i ] + $ arr [ $ j ] - $ k ) < $ smallest ) { $ smallest = abs ( $ arr [ $ i ] + $ arr [ $ j ] - $ k ) ; $ count = 1 ; } else if ( abs ( $ arr [ $ i ] + $ arr [ $ j ] - $ k ) == $ smallest ) $ count ++ ; } echo " Minimal Value = " ▁ , ▁ $ smallest ▁ , ▁ " " ; STRNEWLINE TABSYMBOL TABSYMBOL echo ▁ " Total Pairs = " , ▁ $ count ▁ , ▁ " " }
Hyp: 
function pairs ( $ arr , $ n , $ k ) { $ smallest = 1000000000 ; $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) { if ( abs ( $ arr [ $ i ] + $ arr [ $ j ] - $ k ) < $ smallest ) { $ smallest = abs ( $ arr [ $ i ] + $ arr [ $ j ] - $ k ) ; $ count = 1 ; } else if ( abs ( $ arr [ $ i ] + $ arr [ $ j ] - $ k ) == $ smallest ) $ count ++ ; } echo " smallest = " ▁ , ▁ $ smallest ▁ , ▁ " , " count = " }

BLEU: 85.52
Edit Sim: 91


Src: 
function Area ( b1 , b2 , h ) { return ( ( b1 + b2 ) / 2 ) * h ; }
Ref: 
function Area ( $ b1 , $ b2 , $ h ) { return ( ( $ b1 + $ b2 ) / 2 ) * $ h ; }
Hyp: 
function Area ( $ b1 , $ b2 , $ h ) { return ( ( $ b1 + $ b2 ) / 2 ) * $ h ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function maxSum ( arr , n ) { var res = Number . MIN_VALUE ; for ( i = 0 ; i < n ; i ++ ) { var curr_sum = 0 ; for ( j = 0 ; j < n ; j ++ ) { var index = ( i + j ) % n ; curr_sum += j * arr [ index ] ; } res = Math . max ( res , curr_sum ) ; } return res ; }
Ref: 
function maxSum ( $ arr , $ n ) { $ res = PHP_INT_MIN ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ curr_sum = 0 ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { $ index = ( $ i + $ j ) % $ n ; $ curr_sum += $ j * $ arr [ $ index ] ; } $ res = max ( $ res , $ curr_sum ) ; } return $ res ; }
Hyp: 
function maxSum ( $ arr , $ n ) { $ res = PHP_INT_MIN ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ curr_sum = 0 ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { $ index = ( $ i + $ j ) % $ n ; $ curr_sum += $ j * $ arr [ $ index ] ; } $ res = max ( $ res , $ curr_sum ) ; } return $ res ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function minSum ( a , n ) { a . sort ( ) ; let num1 = 0 ; let num2 = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) num1 = num1 * 10 + a [ i ] ; else num2 = num2 * 10 + a [ i ] ; } return num2 + num1 ; }
Ref: 
function minSum ( $ a , $ n ) { sort ( $ a ) ; $ num1 = 0 ; $ num2 = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ i % 2 == 0 ) $ num1 = $ num1 * 10 + $ a [ $ i ] ; else $ num2 = $ num2 * 10 + $ a [ $ i ] ; } return ( $ num2 + $ num1 ) ; }
Hyp: 
function minSum ( $ a , $ n ) { sort ( $ a ) ; $ num1 = 0 ; $ num2 = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ i % 2 == 0 ) $ num1 = $ num1 * 10 + $ a [ $ i ] ; else $ num2 = $ num2 * 10 + $ a [ $ i ] ; } return $ num2 + $ num1 ; }

BLEU: 94.92
Edit Sim: 4


Src: 
function tidyNum ( str1 , len ) { var str = str1 . split ( ' ' ) ; for ( i = len - 2 ; i >= 0 ; i -- ) { if ( str [ i ] > str [ i + 1 ] ) { str [ i ] -- ; for ( j = i + 1 ; j < len ; j ++ ) str [ j ] = ' ' ; } } return str . join ( " " ) ; }
Ref: 
function tidyNum ( $ str , $ len ) { for ( $ i = $ len - 2 ; $ i >= 0 ; $ i -- ) { if ( $ str [ $ i ] > $ str [ $ i + 1 ] ) { $ x = ord ( $ str [ $ i ] ) ; $ x -- ; $ str [ $ i ] = chr ( $ x ) ; for ( $ j = $ i + 1 ; $ j < $ len ; $ j ++ ) $ str [ $ j ] = '9' ; } } return $ str ; }
Hyp: 
function tidyNum ( $ str , $ len ) { $ str = explode ( '0' , $ str ) ; for ( $ i = $ len - 2 ; $ i >= 0 ; $ i -- ) { if ( $ str [ $ i ] > $ str [ $ i + 1 ] ) { $ str [ $ i ] -- ; for ( $ j = $ i + 1 ; $ j < $ len ; $ j ++ ) $ str [ $ j ] = '0' ; } } return $ str ; }

BLEU: 76.63
Edit Sim: 85


Src: 
function minPower ( n , x ) { if ( x == 1 ) return n ; let ans = 0 ; while ( n > 0 ) { ans += ( n % x ) ; n = Math . floor ( n / x ) ; } return ans ; }
Ref: 
function minPower ( $ n , $ x ) { if ( $ x == 1 ) return $ n ; $ ans = 0 ; while ( $ n > 0 ) { $ ans += ( $ n % $ x ) ; $ n /= $ x ; } return $ ans ; }
Hyp: 
function minPower ( $ n , $ x ) { if ( $ x == 1 ) return $ n ; $ ans = 0 ; while ( $ n > 0 ) { $ ans += ( $ n % $ x ) ; $ n = ( int ) $ n / $ x ; } return $ ans ; }

BLEU: 86.34
Edit Sim: 15


Src: 
function splitArr ( arr , n , k ) { for ( let i = 0 ; i < k ; i ++ ) { let x = arr [ 0 ] ; for ( let j = 0 ; j < n - 1 ; ++ j ) arr [ j ] = arr [ j + 1 ] ; arr [ n - 1 ] = x ; } }
Ref: 
function splitArr ( & $ arr , $ n , $ k ) { for ( $ i = 0 ; $ i < $ k ; $ i ++ ) { $ x = $ arr [ 0 ] ; for ( $ j = 0 ; $ j < $ n - 1 ; ++ $ j ) $ arr [ $ j ] = $ arr [ $ j + 1 ] ; $ arr [ $ n - 1 ] = $ x ; } }
Hyp: 
function splitArr ( & $ arr , $ n , $ k ) { for ( $ i = 0 ; $ i < $ k ; $ i ++ ) { $ x = $ arr [ 0 ] ; for ( $ j = 0 ; $ j < $ n - 1 ; ++ $ j ) $ arr [ $ j ] = $ arr [ $ j + 1 ] ; $ arr [ $ n - 1 ] = $ x ; } }

BLEU: 100.0
Edit Sim: 0


Src: 
function areSame ( a , b ) { if ( ( a - b ) == 0 ) document . write ( " " ) ; else document . write ( " " ) ; }
Ref: 
function areSame ( $ a , $ b ) { if ( ! ( $ a - $ b ) ) echo " Same " ; else echo " Not ▁ Same " ; }
Hyp: 
function areSame ( $ a , $ b ) { if ( ( $ a - $ b ) == 0 ) echo " Yes " ; else echo " No " ; }

BLEU: 66.16
Edit Sim: 19


Src: 
function area ( r ) { if ( r < 0 ) return - 1 ; var area = ( 3.14 * Math . pow ( r / ( 2 * Math . sqrt ( 2 ) ) , 2 ) ) ; return area ; }
Ref: 
function area ( $ r ) { if ( $ r < 0 ) return -1 ; $ area = 3.14 * pow ( $ r / ( 2 * sqrt ( 2 ) ) , 2 ) ; return $ area ; }
Hyp: 
function area ( $ r ) { if ( $ r < 0 ) return -1 ; $ area = 3.14 * pow ( $ r / ( 2 * sqrt ( 2 ) ) , 2 ) ; return $ area ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function print ( p0 ) { var p1 , i = 0 , x , flag = 1 , k , m = 4 ; while ( flag ) { flag = 1 ; x = Math . pow ( 2 , i ) ; p1 = x * p0 - ( x - 1 ) ; for ( k = 2 ; k < p1 ; k ++ ) { if ( p1 % k == 0 ) { flag = 0 ; break ; } } if ( flag == 0 ) break ; document . write ( p1 + " " ) ; i ++ ; } }
Ref: 
function print_t ( $ p0 ) { $ p1 ; $ i = 0 ; $ x ; $ flag ; $ k ; while ( 1 ) { $ flag = 1 ; $ x = pow ( 2 , $ i ) ; $ p1 = $ x * $ p0 - ( $ x - 1 ) ; for ( $ k = 2 ; $ k < $ p1 ; $ k ++ ) { if ( $ p1 % $ k == 0 ) { $ flag = 0 ; break ; } } if ( $ flag == 0 ) break ; echo $ p1 . " " ; $ i ++ ; } }
Hyp: 
function print ( $ p0 ) { global $ MAX ; $ i = 0 ; $ flag = 1 ; $ x = pow ( 2 , $ i ) ; $ p1 = $ x * $ p0 - ( $ x - 1 ) ; for ( $ k = 2 ; $ k < $ p1 ; $ k ++ ) { if ( $ p1 % $ k == 0 ) { $ flag = 0 ; break ; } } if ( $ flag == 0 ) break ; echo $ p1 . " ▁ " ; $ i ++ ; } }

BLEU: 82.06
Edit Sim: 43


Src: 
function area_cicumscribed ( c ) { return ( c * c * ( PI / 4 ) ) ; }
Ref: 
function area_circumscribed ( $ c ) { global $ PI ; return ( $ c * $ c * ( $ PI / 4 ) ) ; }
Hyp: 
function area_cicumscribed ( $ c ) { global $ PI ; return ( $ c * $ c * ( $ PI / 4 ) ) ; }

BLEU: 93.56
Edit Sim: 1


Src: 
function bestApproximate ( x , y , n ) { let m , c , sum_x = 0 , sum_y = 0 , sum_xy = 0 , sum_x2 = 0 ; for ( let i = 0 ; i < n ; i ++ ) { sum_x += x [ i ] ; sum_y += y [ i ] ; sum_xy += x [ i ] * y [ i ] ; sum_x2 += Math . pow ( x [ i ] , 2 ) ; } m = ( n * sum_xy - sum_x * sum_y ) / ( n * sum_x2 - Math . pow ( sum_x , 2 ) ) ; c = ( sum_y - m * sum_x ) / n ; document . write ( " " + m ) ; document . write ( " " + c ) ; }
Ref: 
function bestApproximate ( $ x , $ y , $ n ) { $ i ; $ j ; $ m ; $ c ; $ sum_x = 0 ; $ sum_y = 0 ; $ sum_xy = 0 ; $ sum_x2 = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sum_x += $ x [ $ i ] ; $ sum_y += $ y [ $ i ] ; $ sum_xy += $ x [ $ i ] * $ y [ $ i ] ; $ sum_x2 += ( $ x [ $ i ] * $ x [ $ i ] ) ; } $ m = ( $ n * $ sum_xy - $ sum_x * $ sum_y ) / ( $ n * $ sum_x2 - ( $ sum_x * $ sum_x ) ) ; $ c = ( $ sum_y - $ m * $ sum_x ) / $ n ; echo " m = " , ▁ $ m ; STRNEWLINE TABSYMBOL echo ▁ " c = " }
Hyp: 
function bestApproximate ( $ x , $ y , $ n ) { $ sum_x = 0 ; $ sum_y = 0 ; $ sum_xy = 0 ; $ sum_x2 = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sum_x += $ x [ $ i ] ; $ sum_y += $ y [ $ i ] ; $ sum_xy += $ x [ $ i ] * $ y [ $ i ] ; $ sum_x2 += pow ( $ x [ $ i ] , 2 ) ; } $ m = ( $ n * $ sum_xy - $ sum_x * $ sum_y ) / ( $ n * $ sum_x2 - pow ( $ sum_x , 2 ) ) ; $ c = ( $ sum_y - $ m * $ sum_x ) / $ n ; echo " Best Approximate ▁ is ▁ " , $ m ; STRNEWLINE TABSYMBOL echo ▁ " , $ c ; }

BLEU: 80.27
Edit Sim: 79


Src: 
function maxProduct ( arr , n ) { if ( n < 4 ) return - 1 ; let max_product = Number . MIN_VALUE ; for ( let i = 0 ; i < n - 3 ; i ++ ) for ( let j = i + 1 ; j < n - 2 ; j ++ ) for ( let k = j + 1 ; k < n - 1 ; k ++ ) for ( let l = k + 1 ; l < n ; l ++ ) max_product = Math . max ( max_product , arr [ i ] * arr [ j ] * arr [ k ] * arr [ l ] ) ; return max_product ; }
Ref: 
function maxProduct ( $ arr , $ n ) { if ( $ n < 4 ) return -1 ; $ max_product = PHP_INT_MIN ; for ( $ i = 0 ; $ i < $ n - 3 ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n - 2 ; $ j ++ ) for ( $ k = $ j + 1 ; $ k < $ n - 1 ; $ k ++ ) for ( $ l = $ k + 1 ; $ l < $ n ; $ l ++ ) $ max_product = max ( $ max_product , $ arr [ $ i ] * $ arr [ $ j ] * $ arr [ $ k ] * $ arr [ $ l ] ) ; return $ max_product ; }
Hyp: 
function maxProduct ( $ arr , $ n ) { if ( $ n < 4 ) return -1 ; $ max_product = PHP_INT_MIN ; for ( $ i = 0 ; $ i < $ n - 3 ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n - 2 ; $ j ++ ) for ( $ k = $ j + 1 ; $ k < $ n - 1 ; $ k ++ ) for ( $ l = $ k + 1 ; $ l < $ n ; $ l ++ ) $ max_product = max ( $ max_product , $ arr [ $ i ] * $ arr [ $ j ] * $ arr [ $ k ] * $ arr [ $ l ] ) ; return $ max_product ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findDiff ( arr , n ) { arr . sort ( function ( a , b ) { return a - b } ) ; let count = 0 , max_count = 0 , min_count = n ; for ( let i = 0 ; i < ( n - 1 ) ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) { count += 1 ; continue ; } else { max_count = Math . max ( max_count , count ) ; min_count = Math . min ( min_count , count ) ; count = 0 ; } } return ( max_count - min_count ) ; }
Ref: 
function findDiff ( $ arr , $ n ) { sort ( $ arr ) ; $ count = 0 ; $ max_count = 0 ; $ min_count = $ n ; for ( $ i = 0 ; $ i < ( $ n - 1 ) ; $ i ++ ) { if ( $ arr [ $ i ] == $ arr [ $ i + 1 ] ) { $ count += 1 ; continue ; } else { $ max_count = max ( $ max_count , $ count ) ; $ min_count = min ( $ min_count , $ count ) ; $ count = 0 ; } } return ( $ max_count - $ min_count ) ; }
Hyp: 
function findDiff ( $ arr , $ n ) { sort ( $ arr ) ; $ count = 0 ; $ max_count = 0 ; $ min_count = $ n ; for ( $ i = 0 ; $ i < ( $ n - 1 ) ; $ i ++ ) { if ( $ arr [ $ i ] == $ arr [ $ i + 1 ] ) { $ count += 1 ; continue ; } else { $ max_count = max ( $ max_count , $ count ) ; $ min_count = min ( $ min_count , $ count ) ; $ count = 0 ; } } return ( $ max_count - $ min_count ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function arraySum ( arr , n ) { let x = ( n + 1 ) / 2 ; return ( arr [ 0 ] - 1 ) * n + x * x ; }
Ref: 
function arraySum ( $ arr , $ n ) { $ x = ( $ n + 1 ) / 2 ; return ( $ arr [ 0 ] - 1 ) * $ n + $ x * $ x ; }
Hyp: 
function arraySum ( $ arr , $ n ) { $ x = ( $ n + 1 ) / 2 ; return ( $ arr [ 0 ] - 1 ) * $ n + $ x * $ x ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countgroup ( a , n ) { var xs = 0 ; for ( var i = 0 ; i < n ; i ++ ) xs = xs ^ a [ i ] ; if ( xs == 0 ) return ( 1 << ( n - 1 ) ) - 1 ; }
Ref: 
function countgroup ( $ a , $ n ) { $ xs = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ xs = $ xs ^ $ a [ $ i ] ; if ( $ xs == 0 ) return ( 1 << ( $ n - 1 ) ) - 1 ; return 0 ; }
Hyp: 
function countgroup ( $ a , $ n ) { $ xs = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ xs = $ xs ^ $ a [ $ i ] ; if ( $ xs == 0 ) return ( 1 << ( $ n - 1 ) ) - 1 ; return 0 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countSubarrays ( arr , n , K ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i ; j < n ; j ++ ) { let product = 1 ; for ( let x = i ; x <= j ; x ++ ) product *= arr [ x ] ; if ( product % K == 0 ) count ++ ; } } return count ; }
Ref: 
function countSubarrays ( $ arr , $ n , $ K ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = $ i ; $ j < $ n ; $ j ++ ) { $ product = 1 ; for ( $ x = $ i ; $ x <= $ j ; $ x ++ ) $ product *= $ arr [ $ x ] ; if ( $ product % $ K == 0 ) $ count ++ ; } } return $ count ; }
Hyp: 
function countSubarrays ( $ arr , $ n , $ K ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = $ i ; $ j < $ n ; $ j ++ ) { $ product = 1 ; for ( $ x = $ i ; $ x <= $ j ; $ x ++ ) $ product *= $ arr [ $ x ] ; if ( $ product % $ K == 0 ) $ count ++ ; } } return $ count ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function form_sieve ( ) { sieve_Prime [ 1 ] = 1 ; for ( i = 2 ; i <= MAX ; i ++ ) { if ( sieve_Prime [ i ] == 0 ) { for ( j = i * 2 ; j <= MAX ; j += i ) { if ( sieve_Prime [ j ] == 0 ) { sieve_Prime [ j ] = 1 ; sieve_count [ i ] ++ ; } } } } }
Ref: 
function form_sieve ( ) { global $ sieve_Prime , $ sieve_count , $ MAX ; $ sieve_Prime [ 1 ] = 1 ; for ( $ i = 2 ; $ i <= $ MAX ; $ i ++ ) { if ( $ sieve_Prime [ $ i ] == 0 ) { for ( $ j = $ i * 2 ; $ j <= $ MAX ; $ j += $ i ) { if ( $ sieve_Prime [ $ j ] == 0 ) { $ sieve_Prime [ $ j ] = 1 ; $ sieve_count [ $ i ] ++ ; } } } } }
Hyp: 
function form_sieve ( ) { $ sieve_Prime [ 1 ] = 1 ; for ( $ i = 2 ; $ i <= MAX ; $ i ++ ) { if ( $ sieve_Prime [ $ i ] == 0 ) { for ( $ j = $ i * 2 ; $ j <= $ MAX ; $ j += $ i ) { if ( $ sieve_Prime [ $ j ] == 0 ) { $ sieve_Prime [ $ j ] = 1 ; $ sieve_count [ $ i ] ++ ; } } } } }

BLEU: 86.71
Edit Sim: 49


Src: 
function calculate ( x , k , m ) { let result = x ; k = k - 1 ; while ( k -- ) { result = Math . pow ( result , x ) ; if ( result > m ) result %= m ; } return result ; }
Ref: 
function calculate ( $ x , $ k , $ m ) { $ result = $ x ; $ k -- ; while ( $ k -- ) { $ result = pow ( $ result , $ x ) ; if ( $ result > $ m ) $ result %= $ m ; } return $ result ; }
Hyp: 
function calculate ( $ x , $ k , $ m ) { $ result = $ x ; $ k = $ k - 1 ; while ( $ k -- ) { $ result = pow ( $ result , $ x ) ; if ( $ result > $ m ) $ result %= $ m ; } return $ result ; }

BLEU: 90.02
Edit Sim: 8


Src: 
function largestSubset ( a , n ) { let dp = [ ] ; dp [ n - 1 ] = 1 ; for ( let i = n - 2 ; i >= 0 ; i -- ) { let mxm = 0 ; for ( let j = i + 1 ; j < n ; j ++ ) { if ( a [ j ] % a [ i ] == 0 a [ i ] % a [ j ] == 0 ) { mxm = Math . max ( mxm , dp [ j ] ) ; } } dp [ i ] = 1 + mxm ; } return Math . max ( ... dp ) ; }
Ref: 
function largestSubset ( $ a , $ n ) { $ dp = array ( ) ; $ dp [ $ n - 1 ] = 1 ; for ( $ i = $ n - 2 ; $ i >= 0 ; $ i -- ) { $ mxm = 0 ; for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) if ( $ a [ $ j ] % $ a [ $ i ] == 0 or $ a [ $ i ] % $ a [ $ j ] == 0 ) $ mxm = max ( $ mxm , $ dp [ $ j ] ) ; $ dp [ $ i ] = 1 + $ mxm ; } return max ( $ dp ) ; }
Hyp: 
function largestSubset ( $ a , $ n ) { $ dp = array ( ) ; $ dp [ $ n - 1 ] = 1 ; for ( $ i = $ n - 2 ; $ i >= 0 ; $ i -- ) { $ mxm = 0 ; for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) { if ( $ a [ $ j ] % $ a [ $ i ] == 0 $ a [ $ i ] % $ a [ $ j ] == 0 ) { $ mxm = max ( $ mxm , $ dp [ $ j ] ) ; } } $ dp [ $ i ] = 1 + $ mxm ; } return max ( $ dp ) ; }

BLEU: 93.1
Edit Sim: 11


Src: 
function findNumberOfDigits ( n , base ) { var dig = parseInt ( Math . floor ( Math . log ( n ) / Math . log ( base ) ) + 1 ) ; document . write ( " " + " " + n + " " + base + " " + dig ) ; }
Ref: 
function findNumberOfDigits ( $ n , $ b ) { $ dig = ( int ) ( floor ( log ( $ n ) / log ( $ b ) ) + 1 ) ; echo ( " The ▁ Number ▁ of ▁ digits " . " ▁ of ▁ Number ▁ " . $ n . " ▁ in ▁ base ▁ " . $ b . " ▁ is ▁ " . $ dig ) ; }
Hyp: 
function findNumberOfDigits ( $ n , $ base ) { $ dig = ( int ) ( log10 ( $ n ) / log10 ( $ base ) ) + 1 ; echo " The ▁ number ▁ of ▁ " , $ n , " ▁ of ▁ " , $ base , " ▁ is ▁ " , $ dig ; }

BLEU: 38.14
Edit Sim: 67


Src: 
function decideWinner ( a , n ) { var count0 = 0 ; var count1 = 0 ; var count2 = 0 ; var count3 = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 4 == 0 ) count0 ++ ; else if ( a [ i ] % 4 == 1 ) count1 ++ ; else if ( a [ i ] % 4 == 2 ) count2 ++ ; else if ( a [ i ] % 4 == 3 ) count3 ++ ; } if ( count0 % 2 == 0 && count1 % 2 == 0 && count2 % 2 == 0 && count3 == 0 ) return 1 ; else return 2 ; }
Ref: 
function decideWinner ( $ a , $ n ) { $ count0 = 0 ; $ count1 = 0 ; $ count2 = 0 ; $ count3 = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] % 4 == 0 ) $ count0 ++ ; else if ( $ a [ $ i ] % 4 == 1 ) $ count1 ++ ; else if ( $ a [ $ i ] % 4 == 2 ) $ count2 ++ ; else if ( $ a [ $ i ] % 4 == 3 ) $ count3 ++ ; } if ( $ count0 % 2 == 0 && $ count1 % 2 == 0 && $ count2 % 2 == 0 && $ count3 == 0 ) return 1 ; else return 2 ; }
Hyp: 
function decideWinner ( $ a , $ n ) { $ count0 = 0 ; $ count1 = 0 ; $ count2 = 0 ; $ count3 = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] % 4 == 0 ) $ count0 ++ ; else if ( $ a [ $ i ] % 4 == 1 ) $ count1 ++ ; else if ( $ a [ $ i ] % 4 == 2 ) $ count2 ++ ; else if ( $ a [ $ i ] % 4 == 3 ) $ count3 ++ ; } if ( $ count0 % 2 == 0 && $ count1 % 2 == 0 && $ count2 % 2 == 0 && $ count3 == 0 ) return 1 ; else return 2 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function minToggle ( arr , n ) { let zero = new Array ( n + 1 ) ; zero [ 0 ] = 0 ; for ( let i = 1 ; i <= n ; ++ i ) { if ( arr [ i - 1 ] == 0 ) zero [ i ] = zero [ i - 1 ] + 1 ; else zero [ i ] = zero [ i - 1 ] ; } let ans = n ; for ( let i = 1 ; i <= n ; ++ i ) ans = Math . min ( ans , i - zero [ i ] + zero [ n ] - zero [ i ] ) ; return ans ; }
Ref: 
function minToggle ( $ arr , $ n ) { $ zero [ 0 ] = 0 ; $ zero [ $ n + 1 ] = 0 ; for ( $ i = 1 ; $ i <= $ n ; ++ $ i ) { if ( $ arr [ $ i - 1 ] == 0 ) $ zero [ $ i ] = $ zero [ $ i - 1 ] + 1 ; else $ zero [ $ i ] = $ zero [ $ i - 1 ] ; } $ ans = $ n ; for ( $ i = 1 ; $ i <= $ n ; ++ $ i ) $ ans = min ( $ ans , $ i - $ zero [ $ i ] + $ zero [ $ n ] - $ zero [ $ i ] ) ; return $ ans ; }
Hyp: 
function minToggle ( $ arr , $ n ) { $ zero = array_fill ( 0 , $ n + 1 , NULL ) ; $ zero [ 0 ] = 0 ; for ( $ i = 1 ; $ i <= $ n ; ++ $ i ) { if ( $ arr [ $ i - 1 ] == 0 ) $ zero [ $ i ] = $ zero [ $ i - 1 ] + 1 ; else $ zero [ $ i ] = $ zero [ $ i - 1 ] ; } $ ans = $ n ; for ( $ i = 1 ; $ i <= $ n ; ++ $ i ) $ ans = min ( $ ans , $ i - $ zero [ $ i ] + $ zero [ $ n ] - $ zero [ $ i ] ) ; return $ ans ; }

BLEU: 93.43
Edit Sim: 34


Src: 
function calSum ( n ) { return ( n * ( 2 * n * n * n + 12 * n * n + 25 * n + 21 ) ) / 2 ; }
Ref: 
function calculateSum ( $ n ) { return ( $ n * ( 2 * $ n * $ n * $ n + 12 * $ n * $ n + 25 * $ n + 21 ) ) / 2 ; }
Hyp: 
function calSum ( $ n ) { return ( $ n * ( 2 * $ n * $ n * $ n + 12 * $ n * $ n + 25 * $ n + 21 ) ) / 2 ; }

BLEU: 95.95
Edit Sim: 6


Src: 
function checkConcurrent ( a1 , b1 , c1 , a2 , b2 , c2 , a3 , b3 , c3 ) { return ( a3 * ( b1 * c2 - b2 * c1 ) + b3 * ( c1 * a2 - c2 * a1 ) + c3 * ( a1 * b2 - a2 * b1 ) == 0 ) ; }
Ref: 
function checkConcurrent ( $ a1 , $ b1 , $ c1 , $ a2 , $ b2 , $ c2 , $ a3 , $ b3 , $ c3 ) { return ( $ a3 * ( $ b1 * $ c2 - $ b2 * $ c1 ) + $ b3 * ( $ c1 * $ a2 - $ c2 * $ a1 ) + $ c3 * ( $ a1 * $ b2 - $ a2 * $ b1 ) == 0 ) ; }
Hyp: 
function checkConcurrent ( $ a1 , $ b1 , $ c1 , $ a2 , $ b2 , $ c2 , $ a3 , $ b3 , $ c3 ) { return ( $ a3 * ( $ b1 * $ c2 - $ b2 * $ c1 ) + $ b3 * ( $ c1 * $ a2 - $ c2 * $ a1 ) + $ c3 * ( $ a1 * $ b2 - $ a2 * $ b1 ) == 0 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function distance ( x1 , y1 , x2 , y2 ) { return Math . sqrt ( Math . pow ( x2 - x1 , 2 ) + Math . pow ( y2 - y1 , 2 ) * 1.0 ) ; }
Ref: 
function distance ( $ x1 , $ y1 , $ x2 , $ y2 ) { return sqrt ( pow ( $ x2 - $ x1 , 2 ) + pow ( $ y2 - $ y1 , 2 ) * 1.0 ) ; }
Hyp: 
function distance ( $ x1 , $ y1 , $ x2 , $ y2 ) { return sqrt ( pow ( $ x2 - $ x1 , 2 ) + pow ( $ y2 - $ y1 , 2 ) * 1.0 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findExtra ( arr1 , arr2 , n ) { for ( let i = 0 ; i < n ; i ++ ) if ( arr1 [ i ] != arr2 [ i ] ) return i ; return n ; }
Ref: 
function findExtra ( $ arr1 , $ arr2 , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr1 [ $ i ] != $ arr2 [ $ i ] ) return $ i ; return $ n ; }
Hyp: 
function findExtra ( $ arr1 , $ arr2 , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr1 [ $ i ] != $ arr2 [ $ i ] ) return $ i ; return $ n ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function count_of_ways ( n ) { var count = 0 ; count = ( n + 1 ) * ( n + 2 ) / 2 ; return count ; }
Ref: 
function count_of_ways ( $ n ) { $ count ; $ count = ( $ n + 1 ) * ( $ n + 2 ) / 2 ; return $ count ; }
Hyp: 
function count_of_ways ( $ n ) { $ count = 0 ; $ count = ( $ n + 1 ) * ( $ n + 2 ) / 2 ; return $ count ; }

BLEU: 89.96
Edit Sim: 4


Src: 
function maximumDifferenceSum ( arr , N ) { let dp = new Array ( N ) ; for ( let i = 0 ; i < N ; i ++ ) { dp [ i ] = new Array ( 2 ) ; for ( let j = 0 ; j < 2 ; j ++ ) { dp [ i ] [ j ] = 0 ; } } for ( let i = 0 ; i < N ; i ++ ) dp [ i ] [ 0 ] = dp [ i ] [ 1 ] = 0 ; for ( let i = 0 ; i < ( N - 1 ) ; i ++ ) { dp [ i + 1 ] [ 0 ] = Math . max ( dp [ i ] [ 0 ] , dp [ i ] [ 1 ] + Math . abs ( 1 - arr [ i ] ) ) ; dp [ i + 1 ] [ 1 ] = Math . max ( dp [ i ] [ 0 ] + Math . abs ( arr [ i + 1 ] - 1 ) , dp [ i ] [ 1 ] + Math . abs ( arr [ i + 1 ] - arr [ i ] ) ) ; } return Math . max ( dp [ N - 1 ] [ 0 ] , dp [ N - 1 ] [ 1 ] ) ; }
Ref: 
function maximumDifferenceSum ( $ arr , $ N ) { $ dp = array ( array ( ) ) ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) $ dp [ $ i ] [ 0 ] = $ dp [ $ i ] [ 1 ] = 0 ; for ( $ i = 0 ; $ i < ( $ N - 1 ) ; $ i ++ ) { $ dp [ $ i + 1 ] [ 0 ] = max ( $ dp [ $ i ] [ 0 ] , $ dp [ $ i ] [ 1 ] + abs ( 1 - $ arr [ $ i ] ) ) ; $ dp [ $ i + 1 ] [ 1 ] = max ( $ dp [ $ i ] [ 0 ] + abs ( $ arr [ $ i + 1 ] - 1 ) , $ dp [ $ i ] [ 1 ] + abs ( $ arr [ $ i + 1 ] - $ arr [ $ i ] ) ) ; } return max ( $ dp [ $ N - 1 ] [ 0 ] , $ dp [ $ N - 1 ] [ 1 ] ) ; }
Hyp: 
function maximumDifferenceSum ( $ arr , $ N ) { $ dp = array ( array ( ) ) ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) $ dp [ $ i ] [ 0 ] = $ dp [ $ i ] [ 1 ] = 0 ; for ( $ i = 0 ; $ i < ( $ N - 1 ) ; $ i ++ ) { $ dp [ $ i + 1 ] [ 0 ] = max ( $ dp [ $ i ] [ 0 ] , $ dp [ $ i ] [ 1 ] + abs ( 1 - $ arr [ $ i ] ) ) ; $ dp [ $ i + 1 ] [ 1 ] = max ( $ dp [ $ i ] [ 0 ] + abs ( $ arr [ $ i + 1 ] - 1 ) , $ dp [ $ i ] [ 1 ] + abs ( $ arr [ $ i + 1 ] - $ arr [ $ i ] ) ) ; } return max ( $ dp [ $ N - 1 ] [ 0 ] , $ dp [ $ N - 1 ] [ 1 ] ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countSetBits ( n ) { var count = 0 ; while ( n ) { count += n & 1 ; n >>= 1 ; } return count ; }
Ref: 
function countSetBits ( $ n ) { $ count = 0 ; while ( $ n ) { $ count += $ n & 1 ; $ n >>= 1 ; } return $ count ; }
Hyp: 
function countSetBits ( $ n ) { $ count = 0 ; while ( $ n ) { $ count += $ n & 1 ; $ n >>= 1 ; } return $ count ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function next ( arr , target ) { let start = 0 , end = arr . length - 1 ; let ans = - 1 ; while ( start <= end ) { let mid = parseInt ( ( start + end ) / 2 , 10 ) ; if ( arr [ mid ] <= target ) { start = mid + 1 ; } else { ans = mid ; end = mid - 1 ; } } return ans ; }
Ref: 
function next0 ( $ arr , $ target ) { $ start = 0 ; $ end = sizeof ( $ arr ) - 1 ; $ ans = -1 ; while ( $ start <= $ end ) { $ mid = ( int ) ( ( $ start + $ end ) / 2 ) ; if ( $ arr [ $ mid ] <= $ target ) { $ start = $ mid + 1 ; } else { $ ans = $ mid ; $ end = $ mid - 1 ; } } return $ ans ; } { $ arr = array ( 1 , 2 , 3 , 5 , 8 , 12 ) ; echo ( next0 ( $ arr , 8 ) ) ; }
Hyp: 
function next ( $ arr , $ target ) { $ start = 0 ; $ end = count ( $ arr ) ; $ ans = -1 ; while ( $ start <= $ end ) { $ mid = ( $ start + $ end ) / 2 ; if ( $ arr [ $ mid ] <= $ target ) { $ start = $ mid + 1 ; } else { $ ans = $ mid ; $ end = $ mid - 1 ; } } return $ ans ; }

BLEU: 61.72
Edit Sim: 101


Src: 
function countSubstringWithEqualEnds ( s ) { var result = 0 ; var n = s . length ; for ( i = 0 ; i < n ; i ++ ) for ( j = i ; j < n ; j ++ ) if ( s . charAt ( i ) == s . charAt ( j ) ) result ++ ; return result ; }
Ref: 
function countSubstringWithEqualEnds ( $ s ) { $ result = 0 ; $ n = strlen ( $ s ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = $ i ; $ j < $ n ; $ j ++ ) if ( $ s [ $ i ] == $ s [ $ j ] ) $ result ++ ; return $ result ; }
Hyp: 
function countSubstringWithEqualEnds ( $ s ) { $ result = 0 ; $ n = strlen ( $ s ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = $ i ; $ j < $ n ; $ j ++ ) if ( $ s [ $ i ] == $ s [ $ j ] ) $ result ++ ; return $ result ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countDigitOne ( n ) { var countr = 0 ; for ( var i = 1 ; i <= n ; i *= 10 ) { var divider = i * 10 ; countr += parseInt ( n / divider ) * i + Math . min ( Math . max ( n % divider - i + 1 , 0 ) , i ) ; } return countr ; }
Ref: 
function countDigitOne ( $ n ) { $ countr = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i *= 10 ) { $ divider = $ i * 10 ; $ countr += ( int ) ( $ n / $ divider ) * $ i + min ( max ( $ n % $ divider - $ i + 1 , 0 ) , $ i ) ; } return $ countr ; }
Hyp: 
function countDigitOne ( $ n ) { $ countr = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i *= 10 ) { $ divider = $ i * 10 ; $ countr += $ n / $ divider * $ i + min ( max ( $ n % $ divider - $ i + 1 , 0 ) , $ i ) ; } return $ countr ; }

BLEU: 90.2
Edit Sim: 12


Src: 
function multiplyWith3Point5 ( x ) { return ( x << 1 ) + x + ( x >> 1 ) ; }
Ref: 
function multiplyWith3Point5 ( $ x ) { return ( $ x << 1 ) + $ x + ( $ x >> 1 ) ; }
Hyp: 
function multiplyWith3Point5 ( $ x ) { return ( $ x << 1 ) + $ x + ( $ x >> 1 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findPoint ( x1 , y1 , x2 , y2 ) { document . write ( " " + 2 * ( x2 - x1 ) + " " + 2 * ( y2 - y1 ) + " " ) ; }
Ref: 
function findPoint ( $ x1 , $ y1 , $ x2 , $ y2 ) { echo " ( " , 2 * $ x2 - $ x1 , " , ▁ " , 2 * $ y2 - $ y1 , " ) " ; }
Hyp: 
function findPoint ( $ x1 , $ y1 , $ x2 , $ y2 ) { echo " The ▁ point ▁ is ▁ " , 2 * ( $ x2 - $ x1 ) , " ▁ " , 2 * ( $ y2 - $ y1 ) , " STRNEWLINE " ; }

BLEU: 60.23
Edit Sim: 37


Src: 
function square ( a ) { if ( a < 0 ) return - 1 ; var x = 0.464 * a ; return x ; }
Ref: 
function square ( $ a ) { if ( $ a < 0 ) return -1 ; $ x = 0.464 * $ a ; return $ x ; }
Hyp: 
function square ( $ a ) { if ( $ a < 0 ) return -1 ; $ x = 0.464 * $ a ; return $ x ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function decryptString ( str , n ) { let i = 0 , jump = 1 ; let decryptedStr = " " ; while ( i < n ) { decryptedStr += str [ i ] ; i += jump ; jump ++ ; } return decryptedStr ; }
Ref: 
function decryptString ( $ str , $ n ) { $ i = 0 ; $ jump = 1 ; $ decryptedStr = " " ; while ( $ i < $ n ) { $ decryptedStr . = $ str [ $ i ] ; $ i += $ jump ; $ jump ++ ; } return $ decryptedStr ; }
Hyp: 
function decryptString ( $ str , $ n ) { $ i = 0 ; $ jump = 1 ; $ decryptedStr = " " ; while ( $ i < $ n ) { $ decryptedStr += $ str [ $ i ] ; $ i += $ jump ; $ jump ++ ; } return $ decryptedStr ; }

BLEU: 94.25
Edit Sim: 2


Src: 
function remainder ( str ) { let len = str . length ; let num ; let rem = 0 ; for ( let i = 0 ; i < len ; i ++ ) { num = rem * 10 + ( str [ i ] - ' ' ) ; rem = num % 11 ; } return rem ; }
Ref: 
function remainder ( $ str ) { $ len = strlen ( $ str ) ; $ num ; $ rem = 0 ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { $ num = $ rem * 10 + ( $ str [ $ i ] - '0' ) ; $ rem = $ num % 11 ; } return $ rem ; }
Hyp: 
function remainder ( $ str ) { $ len = strlen ( $ str ) ; $ num = 0 ; $ rem = 0 ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { $ num = $ rem * 10 + ( $ str [ $ i ] - '0' ) ; $ rem = $ num % 11 ; } return $ rem ; }

BLEU: 95.39
Edit Sim: 4


Src: 
function checkpoint ( h , k , x , y , a ) { var p = parseInt ( Math . pow ( ( y - k ) , 2 ) - 4 * a * ( x - h ) ) ; return p ; }
Ref: 
function checkpoint ( $ h , $ k , $ x , $ y , $ a ) { $ p = pow ( ( $ y - $ k ) , 2 ) - 4 * $ a * ( $ x - $ h ) ; return $ p ; }
Hyp: 
function checkpoint ( $ h , $ k , $ x , $ y , $ a ) { $ p = pow ( ( $ y - $ k ) , 2 ) - 4 * $ a * ( $ x - $ h ) ; return $ p ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function coutSubSeq ( A , N , M ) { let sum = 0 ; let ans = 0 ; for ( let i = 0 ; i < N ; i ++ ) { for ( let j = i + 1 ; j < N ; j ++ ) { for ( let k = j + 1 ; k < N ; k ++ ) { sum = A [ i ] + A [ j ] + A [ k ] ; if ( sum % M == 0 ) ans ++ ; } } } return ans ; }
Ref: 
function coutSubSeq ( $ A , $ N , $ M ) { $ sum = 0 ; $ ans = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ N ; $ j ++ ) { for ( $ k = $ j + 1 ; $ k < $ N ; $ k ++ ) { $ sum = $ A [ $ i ] + $ A [ $ j ] + $ A [ $ k ] ; if ( $ sum % $ M == 0 ) $ ans ++ ; } } } return $ ans ; }
Hyp: 
function coutSubSeq ( $ A , $ N , $ M ) { $ sum = 0 ; $ ans = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ N ; $ j ++ ) { for ( $ k = $ j + 1 ; $ k < $ N ; $ k ++ ) { $ sum = $ A [ $ i ] + $ A [ $ j ] + $ A [ $ k ] ; if ( $ sum % $ M == 0 ) $ ans ++ ; } } } return $ ans ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countPairs ( n ) { if ( n == 2 ) return 4 ; let num = ( parseInt ( n / 2 , 10 ) + 1 ) ; let max = n % num ; let count = n - max ; return count ; }
Ref: 
function countPairs ( $ n ) { if ( $ n == 2 ) return 4 ; $ num = ( ( int ) ( $ n / 2 ) + 1 ) ; $ max = $ n % $ num ; $ count = ( $ n - $ max ) ; return $ count ; }
Hyp: 
function countPairs ( $ n ) { if ( $ n == 2 ) return 4 ; $ num = ( ( int ) ( $ n / 2 ) + 1 ) ; $ max = $ n % $ num ; $ count = $ n - $ max ; return $ count ; }

BLEU: 91.26
Edit Sim: 4


Src: 
function longestCommonSum ( n ) { let maxLen = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let sum1 = 0 , sum2 = 0 ; for ( let j = i ; j < n ; j ++ ) { sum1 += arr1 [ j ] ; sum2 += arr2 [ j ] ; if ( sum1 == sum2 ) { let len = j - i + 1 ; if ( len > maxLen ) maxLen = len ; } } } return maxLen ; }
Ref: 
function longestCommonSum ( $ arr1 , $ arr2 , $ n ) { $ maxLen = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sum1 = 0 ; $ sum2 = 0 ; for ( $ j = $ i ; $ j < $ n ; $ j ++ ) { $ sum1 += $ arr1 [ $ j ] ; $ sum2 += $ arr2 [ $ j ] ; if ( $ sum1 == $ sum2 ) { $ len = $ j - $ i + 1 ; if ( $ len > $ maxLen ) $ maxLen = $ len ; } } } return $ maxLen ; }
Hyp: 
function longestCommonSum ( $ n ) { $ maxLen = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sum1 = 0 ; $ sum2 = 0 ; for ( $ j = $ i ; $ j < $ n ; $ j ++ ) { $ sum1 += $ arr1 [ $ j ] ; $ sum2 += $ arr2 [ $ j ] ; if ( $ sum1 == $ sum2 ) { $ len = $ j - $ i + 1 ; if ( $ len > $ maxLen ) $ maxLen = $ len ; } } } return $ maxLen ; }

BLEU: 94.56
Edit Sim: 18


Src: 
function maxSubarrayXOR ( arr , n ) { let ans = Number . MIN_VALUE ; for ( let i = 0 ; i < n ; i ++ ) { let curr_xor = 0 ; for ( let j = i ; j < n ; j ++ ) { curr_xor = curr_xor ^ arr [ j ] ; ans = Math . max ( ans , curr_xor ) ; } } return ans ; }
Ref: 
function maxSubarrayXOR ( $ arr , $ n ) { $ ans = PHP_INT_MIN ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ curr_xor = 0 ; for ( $ j = $ i ; $ j < $ n ; $ j ++ ) { $ curr_xor = $ curr_xor ^ $ arr [ $ j ] ; $ ans = max ( $ ans , $ curr_xor ) ; } } return $ ans ; }
Hyp: 
function maxSubarrayXOR ( $ arr , $ n ) { $ ans = PHP_INT_MIN ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ curr_xor = 0 ; for ( $ j = $ i ; $ j < $ n ; $ j ++ ) { $ curr_xor = $ curr_xor ^ $ arr [ $ j ] ; $ ans = max ( $ ans , $ curr_xor ) ; } } return $ ans ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function hexagonArea ( s ) { return ( ( 3 * Math . sqrt ( 3 ) * ( s * s ) ) / 2 ) ; }
Ref: 
function hexagonArea ( $ s ) { return ( ( 3 * sqrt ( 3 ) * ( $ s * $ s ) ) / 2 ) ; }
Hyp: 
function hexagonArea ( $ s ) { return ( ( 3 * sqrt ( 3 ) * ( $ s * $ s ) ) / 2 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function solve ( arr , n ) { arr . sort ( ) ; let a = 0 , b = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( i % 2 != 0 ) a = a * 10 + arr [ i ] ; else b = b * 10 + arr [ i ] ; } return a + b ; }
Ref: 
function solve ( $ arr , $ n ) { sort ( $ arr ) ; sort ( $ arr , $ n ) ; $ a = 0 ; $ b = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ i & 1 ) $ a = $ a * 10 + $ arr [ $ i ] ; else $ b = $ b * 10 + $ arr [ $ i ] ; } return $ a + $ b ; }
Hyp: 
function solve ( $ arr , $ n ) { sort ( $ arr ) ; $ a = 0 ; $ b = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ i % 2 != 0 ) $ a = $ a * 10 + $ arr [ $ i ] ; else $ b = $ b * 10 + $ arr [ $ i ] ; } return $ a + $ b ; }

BLEU: 86.95
Edit Sim: 30


Src: 
function powerOfJump ( s ) { let count = 1 ; let max_so_far = Number . MIN_VALUE ; let ch = s [ s . length - 1 ] ; for ( let i = 0 ; i < s . length ; i ++ ) { if ( s [ i ] == ch ) { if ( count > max_so_far ) { max_so_far = count ; } count = 1 ; } else count ++ ; } return max_so_far ; }
Ref: 
function powerOfJump ( $ s ) { $ count = 1 ; $ max_so_far = PHP_INT_MIN ; $ ch = $ s [ strlen ( $ s ) - 1 ] ; for ( $ i = 0 ; $ i < strlen ( $ s ) ; $ i ++ ) { if ( $ s [ $ i ] == $ ch ) { if ( $ count > $ max_so_far ) { $ max_so_far = $ count ; } $ count = 1 ; } else $ count ++ ; } return $ max_so_far ; }
Hyp: 
function powerOfJump ( $ s ) { $ count = 1 ; $ max_so_far = PHP_INT_MIN ; $ ch = $ s [ strlen ( $ s ) - 1 ] ; for ( $ i = 0 ; $ i < strlen ( $ s ) ; $ i ++ ) { if ( $ s [ $ i ] == $ ch ) { if ( $ count > $ max_so_far ) { $ max_so_far = $ count ; } $ count = 1 ; } else $ count ++ ; } return $ max_so_far ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findNumbers ( n ) { var i = 1 ; while ( i <= n ) { document . write ( ( ( 2 * i ) - 1 ) + " " ) ; i ++ ; } }
Ref: 
function findNumbers ( $ n ) { $ i = 1 ; while ( $ i <= $ n ) { echo ( ( 2 * $ i ) - 1 ) . " ▁ " ; $ i ++ ; } }
Hyp: 
function findNumbers ( $ n ) { $ i = 1 ; while ( $ i <= $ n ) { echo ( ( 2 * $ i ) - 1 ) . " ▁ " ; $ i ++ ; } }

BLEU: 100.0
Edit Sim: 0


Src: 
function sumArray ( arr , n ) { let leftSum = new Array ( n ) ; let rightSum = new Array ( n ) ; let Sum = new Array ( n ) ; let i = 0 , j = 0 ; leftSum [ 0 ] = 0 ; rightSum [ n - 1 ] = 0 ; for ( i = 1 ; i < n ; i ++ ) leftSum [ i ] = arr [ i - 1 ] + leftSum [ i - 1 ] ; for ( j = n - 2 ; j >= 0 ; j -- ) rightSum [ j ] = arr [ j + 1 ] + rightSum [ j + 1 ] ; for ( i = 0 ; i < n ; i ++ ) Sum [ i ] = leftSum [ i ] + rightSum [ i ] ; for ( i = 0 ; i < n ; i ++ ) document . write ( Sum [ i ] + " " ) ; }
Ref: 
function sumArray ( $ arr , $ n ) { $ leftSum = array_fill ( 0 , $ n , 0 ) ; $ rightSum = array_fill ( 0 , $ n , 0 ) ; $ Sum = array_fill ( 0 , $ n , 0 ) ; $ leftSum [ 0 ] = 0 ; $ rightSum [ $ n - 1 ] = 0 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ leftSum [ $ i ] = $ arr [ $ i - 1 ] + $ leftSum [ $ i - 1 ] ; for ( $ j = $ n - 2 ; $ j >= 0 ; $ j -- ) $ rightSum [ $ j ] = $ arr [ $ j + 1 ] + $ rightSum [ $ j + 1 ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ Sum [ $ i ] = $ leftSum [ $ i ] + $ rightSum [ $ i ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ Sum [ $ i ] . " ▁ " ; }
Hyp: 
function sumArray ( $ arr , $ n ) { $ leftSum = array ( ) ; $ rightSum = array ( ) ; $ Sum = array ( ) ; $ i = 0 ; $ j = 0 ; $ leftSum [ 0 ] = 0 ; $ rightSum [ $ n - 1 ] = 0 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ leftSum [ $ i ] = $ arr [ $ i - 1 ] + $ leftSum [ $ i - 1 ] ; for ( $ j = $ n - 2 ; $ j >= 0 ; $ j -- ) $ rightSum [ $ j ] = $ arr [ $ j + 1 ] + $ rightSum [ $ j + 1 ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ Sum [ $ i ] = $ leftSum [ $ i ] + $ rightSum [ $ i ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ Sum [ $ i ] , " ▁ " ; }

BLEU: 86.65
Edit Sim: 51


Src: 
function boost_hyperfactorial ( num ) { let val = 1 ; for ( let i = 1 ; i <= num ; i ++ ) { val = val * Math . pow ( i , i ) ; } return val ; }
Ref: 
function boost_hyperfactorial ( $ num ) { $ val = 1 ; for ( $ i = 1 ; $ i <= $ num ; $ i ++ ) { $ val = $ val * pow ( $ i , $ i ) ; } return $ val ; }
Hyp: 
function boost_hyperfactorial ( $ num ) { $ val = 1 ; for ( $ i = 1 ; $ i <= $ num ; $ i ++ ) { $ val = $ val * pow ( $ i , $ i ) ; } return $ val ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function gcd ( a , b ) { if ( b == 0 ) { return a ; } return gcd ( b , a % b ) ; } let a = 98 ; let b = 56 ; document . write ( ` ${ a } ${ b } ${ gcd ( a , b ) }
Ref: 
function gcd ( $ a , $ b ) { if ( $ b == 0 ) return $ a ; return gcd ( $ b , $ a % $ b ) ; }
Hyp: 
function gcd ( $ a , $ b ) { if ( $ b == 0 ) { return $ a ; } return gcd ( $ b , $ a % $ b ) ; } $ a = 97 ; $ b = 56 ; echo " The ▁ gcd ▁ of ▁ the ▁ direct " , " ▁ common ▁ tangent ▁ is ▁ " , $ a , $ b , " STRNEWLINE " ; }

BLEU: 38.91
Edit Sim: 130


Src: 
function Permutation ( n , k ) { let p = new Array ( n + 1 ) ; for ( let i = 1 ; i <= n ; i ++ ) p [ i ] = i ; for ( let i = 1 ; i < n - k ; i ++ ) p [ i + 1 ] = i ; p [ 1 ] = n - k ; for ( let i = 1 ; i <= n ; i ++ ) document . write ( p [ i ] + " " ) ; }
Ref: 
function Permutation ( $ n , $ k ) { $ p = array ( ) ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ p [ $ i ] = $ i ; for ( $ i = 1 ; $ i < $ n - $ k ; $ i ++ ) $ p [ $ i + 1 ] = $ i ; $ p [ 1 ] = $ n - $ k ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) echo $ p [ $ i ] , " ▁ " ; }
Hyp: 
function Permutation ( $ n , $ k ) { $ p = array ( ) ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ p [ $ i ] = $ i ; for ( $ i = 1 ; $ i < $ n - $ k ; $ i ++ ) $ p [ $ i + 1 ] = $ i ; $ p [ 1 ] = $ n - $ k ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) echo $ p [ $ i ] , " ▁ " ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function find ( index , openbrk , n , adj ) { if ( openbrk < 0 ) return MAX_VAL ; if ( index == n ) { if ( openbrk == 0 ) { return 0 ; } return MAX_VAL ; } if ( dp [ index ] [ openbrk ] != - 1 ) return dp [ index ] [ openbrk ] ; dp [ index ] [ openbrk ] = Math . min ( adj [ index ] [ 1 ] + find ( index + 1 , openbrk + 1 , n , adj ) , adj [ index ] [ 0 ] + find ( index + 1 , openbrk - 1 , n , adj ) ) ; return dp [ index ] [ openbrk ] ; }
Ref: 
function find ( $ index , $ openbrk , $ n , $ adj ) { global $ MAX_VAL ; global $ dp ; if ( $ openbrk < 0 ) return $ MAX_VAL ; if ( $ index == $ n ) { if ( $ openbrk == 0 ) { return 0 ; } return $ MAX_VAL ; } if ( $ dp [ $ index ] [ $ openbrk ] != -1 ) return $ dp [ $ index ] [ $ openbrk ] ; $ dp [ $ index ] [ $ openbrk ] = min ( $ adj [ $ index ] [ 1 ] + find ( $ index + 1 , $ openbrk + 1 , $ n , $ adj ) , $ adj [ $ index ] [ 0 ] + find ( $ index + 1 , $ openbrk - 1 , $ n , $ adj ) ) ; return $ dp [ $ index ] [ $ openbrk ] ; }
Hyp: 
function find ( $ index , $ openbrk , $ n , $ adj ) { global $ MAX_VAL ; if ( $ openbrk < 0 ) return $ MAX_VAL ; if ( $ index == $ n ) { if ( $ openbrk == 0 ) return 0 ; return $ MAX_VAL ; } if ( $ dp [ $ index ] [ $ openbrk ] != -1 ) return $ dp [ $ index ] [ $ openbrk ] ; $ dp [ $ index ] [ $ openbrk ] = min ( $ adj [ $ index ] [ 1 ] + find ( $ index + 1 , $ openbrk + 1 , $ n , $ adj ) , $ adj [ $ index ] [ 0 ] + find ( $ index + 1 , $ openbrk - 1 , $ n , $ adj ) ) ; return $ dp [ $ index ] [ $ openbrk ] ; }

BLEU: 94.27
Edit Sim: 18


Src: 
function multiplyFactors ( n ) { let M = 1000000007 ; let i ; prod = 1 ; for ( i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) prod = ( prod * i ) % M ; else { prod = ( prod * i ) % M ; prod = ( prod * n / i ) % M ; } } } return prod ; }
Ref: 
function multiplyFactors ( $ n ) { global $ M ; $ prod = 1 ; for ( $ i = 1 ; $ i * $ i <= $ n ; $ i ++ ) { if ( $ n % $ i == 0 ) { if ( $ n / $ i == $ i ) $ prod = ( $ prod * $ i ) % $ M ; else { $ prod = ( $ prod * $ i ) % $ M ; $ prod = ( $ prod * $ n / $ i ) % $ M ; } } } return $ prod ; }
Hyp: 
function multiplyFactors ( $ n ) { $ M = 1000000007 ; $ i ; $ prod = 1 ; for ( $ i = 1 ; $ i * $ i <= $ n ; $ i ++ ) { if ( $ n % $ i == 0 ) { if ( $ n / $ i == $ i ) $ prod = ( $ prod * $ i ) % $ M ; else { $ prod = ( $ prod * $ i ) % $ M ; $ prod = ( $ prod * $ n / $ i ) % $ M ; } } } return $ prod ; }

BLEU: 93.37
Edit Sim: 19


Src: 
function polydiagonal ( n , a ) { if ( a < 0 && n < 0 ) { return - 1 ; } return ( 2 * a * Math . sin ( ( ( ( n - 2 ) * 180 ) / ( 2 * n ) ) * 3.14159 / 180 ) ) ; }
Ref: 
function polydiagonal ( $ n , $ a ) { if ( $ a < 0 && $ n < 0 ) return -1 ; return 2 * $ a * sin ( ( ( ( $ n - 2 ) * 180 ) / ( 2 * $ n ) ) * 3.14159 / 180 ) ; }
Hyp: 
function polydiagonal ( $ n , $ a ) { if ( $ a < 0 && $ n < 0 ) { return -1 ; } return ( 2 * $ a * sin ( ( ( $ n - 2 ) * 180 ) / ( 2 * $ n ) ) * 3.14159 / 180 ) ; }

BLEU: 89.02
Edit Sim: 8


Src: 
function NumberofTimes ( str ) { var temporary_sum = 0 , count = 0 ; while ( str . length > 1 ) { temporary_sum = 0 ; for ( i = 0 ; i < str . length ; i ++ ) temporary_sum += ( str . charAt ( i ) - ' ' ) ; str = temporary_sum + " " ; count ++ ; } return count ; }
Ref: 
function NumberofTimes ( $ str ) { $ temporary_sum = 0 ; $ count = 0 ; while ( strlen ( $ str ) > 1 ) { $ temporary_sum = 0 ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) $ temporary_sum += ( $ str [ $ i ] - '0' ) ; $ str = ( string ) ( $ temporary_sum ) ; $ count ++ ; } return $ count ; }
Hyp: 
function NumberofTimes ( $ str ) { $ temporary_sum = 0 ; $ count = 0 ; while ( strlen ( $ str ) > 1 ) { $ temporary_sum = 0 ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) $ temporary_sum += ( ord ( $ str [ $ i ] ) - ord ( '0' ) ) ; $ str = $ temporary_sum . "0" ; $ count ++ ; } return $ count ; }

BLEU: 85.01
Edit Sim: 31


Src: 
function evenlength ( n ) { let res = n ; for ( let j = n . length - 1 ; j >= 0 ; -- j ) res += n [ j ] ; return res ; }
Ref: 
function evenlength ( $ n ) { $ res = $ n ; for ( $ j = strlen ( $ n ) - 1 ; $ j >= 0 ; -- $ j ) $ res = $ res . $ n [ $ j ] ; return $ res ; }
Hyp: 
function evenlength ( $ n ) { $ res = $ n ; for ( $ j = strlen ( $ n ) - 1 ; $ j >= 0 ; -- $ j ) $ res += $ n [ $ j ] ; return $ res ; }

BLEU: 89.34
Edit Sim: 9


Src: 
function findMaxSum ( arr , n ) { let preSum = new Array ( n ) ; preSum . fill ( 0 ) ; let suffSum = new Array ( n ) ; suffSum . fill ( 0 ) ; let ans = Number . MIN_VALUE ; preSum [ 0 ] = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) preSum [ i ] = preSum [ i - 1 ] + arr [ i ] ; suffSum [ n - 1 ] = arr [ n - 1 ] ; if ( preSum [ n - 1 ] == suffSum [ n - 1 ] ) ans = Math . max ( ans , preSum [ n - 1 ] ) ; for ( let i = n - 2 ; i >= 0 ; i -- ) { suffSum [ i ] = suffSum [ i + 1 ] + arr [ i ] ; if ( suffSum [ i ] == preSum [ i ] ) ans = Math . max ( ans , preSum [ i ] ) ; } return ans ; }
Ref: 
function findMaxSum ( $ arr , $ n ) { $ preSum [ $ n ] = array ( ) ; $ suffSum [ $ n ] = array ( ) ; $ ans = PHP_INT_MIN ; $ preSum [ 0 ] = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ preSum [ $ i ] = $ preSum [ $ i - 1 ] + $ arr [ $ i ] ; $ suffSum [ $ n - 1 ] = $ arr [ $ n - 1 ] ; if ( $ preSum [ $ n - 1 ] == $ suffSum [ $ n - 1 ] ) $ ans = max ( $ ans , $ preSum [ $ n - 1 ] ) ; for ( $ i = $ n - 2 ; $ i >= 0 ; $ i -- ) { $ suffSum [ $ i ] = $ suffSum [ $ i + 1 ] + $ arr [ $ i ] ; if ( $ suffSum [ $ i ] == $ preSum [ $ i ] ) $ ans = max ( $ ans , $ preSum [ $ i ] ) ; } return $ ans ; }
Hyp: 
function findMaxSum ( $ arr , $ n ) { $ preSum = array ( ) ; $ suffSum = array ( ) ; $ ans = PHP_INT_MIN ; $ preSum [ 0 ] = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ preSum [ $ i ] = $ preSum [ $ i - 1 ] + $ arr [ $ i ] ; $ suffSum [ $ n - 1 ] = $ arr [ $ n - 1 ] ; if ( $ preSum [ $ n - 1 ] == $ suffSum [ $ n - 1 ] ) $ ans = max ( $ ans , $ preSum [ $ n - 1 ] ) ; for ( $ i = $ n - 2 ; $ i >= 0 ; $ i -- ) { $ suffSum [ $ i ] = $ suffSum [ $ i + 1 ] + $ arr [ $ i ] ; if ( $ suffSum [ $ i ] == $ preSum [ $ i ] ) $ ans = max ( $ ans , $ preSum [ $ i ] ) ; } return $ ans ; }

BLEU: 95.06
Edit Sim: 16


Src: 
function minproduct ( a , b , n , k ) { let diff = 0 , res = 0 ; let temp = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let pro = a [ i ] * b [ i ] ; res = res + pro ; if ( pro < 0 && b [ i ] < 0 ) temp = ( a [ i ] + 2 * k ) * b [ i ] ; else if ( pro < 0 && a [ i ] < 0 ) temp = ( a [ i ] - 2 * k ) * b [ i ] ; else if ( pro > 0 && a [ i ] < 0 ) temp = ( a [ i ] + 2 * k ) * b [ i ] ; else if ( pro > 0 && a [ i ] > 0 ) temp = ( a [ i ] - 2 * k ) * b [ i ] ; let d = Math . abs ( pro - temp ) ; if ( d > diff ) diff = d ; } return res - diff ; }
Ref: 
function minproduct ( $ a , $ b , $ n , $ k ) { $ diff = 0 ; $ res = 0 ; $ temp ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ pro = $ a [ $ i ] * $ b [ $ i ] ; $ res = $ res + $ pro ; if ( $ pro < 0 and $ b [ $ i ] < 0 ) $ temp = ( $ a [ $ i ] + 2 * $ k ) * $ b [ $ i ] ; else if ( $ pro < 0 and $ a [ $ i ] < 0 ) $ temp = ( $ a [ $ i ] - 2 * $ k ) * $ b [ $ i ] ; else if ( $ pro > 0 and $ a [ $ i ] < 0 ) $ temp = ( $ a [ $ i ] + 2 * $ k ) * $ b [ $ i ] ; else if ( $ pro > 0 and $ a [ $ i ] > 0 ) $ temp = ( $ a [ $ i ] - 2 * $ k ) * $ b [ $ i ] ; $ d = abs ( $ pro - $ temp ) ; if ( $ d > $ diff ) $ diff = $ d ; } return $ res - $ diff ; }
Hyp: 
function minproduct ( $ a , $ b , $ n , $ k ) { $ diff = 0 ; $ res = 0 ; $ temp = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ pro = $ a [ $ i ] * $ b [ $ i ] ; $ res = $ res + $ pro ; if ( $ pro < 0 && $ b [ $ i ] < 0 ) $ temp = ( $ a [ $ i ] + 2 * $ k ) * $ b [ $ i ] ; else if ( $ pro < 0 && $ a [ $ i ] < 0 ) $ temp = ( $ a [ $ i ] - 2 * $ k ) * $ b [ $ i ] ; else if ( $ pro > 0 && $ a [ $ i ] > 0 ) $ temp = ( $ a [ $ i ] - 2 * $ k ) * $ b [ $ i ] ; $ d = abs ( $ pro - $ temp ) ; if ( $ d > $ diff ) $ diff = $ d ; } return $ res - $ diff ; }

BLEU: 80.84
Edit Sim: 106


Src: 
function getSum ( arr , p ) { return arr . length ; }
Ref: 
function getSum ( $ arr , $ p ) { return count ( $ arr ) ; }
Hyp: 
function getSum ( $ arr , $ p ) { return sum ( $ arr , $ p ) ; }

BLEU: 63.84
Edit Sim: 10


Src: 
function printSeries ( n ) { let i ; for ( i = 1 ; i <= n ; i ++ ) { let num = i * ( i + 1 ) * ( ( i + 2 ) / 6 ) ; document . write ( num + " " ) ; } }
Ref: 
function printSeries ( $ n ) { for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ num = $ i * ( $ i + 1 ) * ( $ i + 2 ) / 6 ; echo ( $ num . " " ) ; } }
Hyp: 
function printSeries ( $ n ) { for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ num = $ i * ( $ i + 1 ) * ( ( $ i + 2 ) / 6 ) ; echo $ num . " ▁ " ; } }

BLEU: 85.72
Edit Sim: 8


Src: 
function otherEndPoint ( x1 , y1 , m1 , m2 ) { let x2 = 2 * m1 - x1 ; let y2 = 2 * m2 - y1 ; document . write ( " " + x2 + " " + " " + y2 ) ; }
Ref: 
function otherEndPoint ( $ x1 , $ y1 , $ m1 , $ m2 ) { $ x2 = ( 2 * $ m1 - $ x1 ) ; $ y2 = ( 2 * $ m2 - $ y1 ) ; echo " x2 ▁ = ▁ " . $ x2 . " , ▁ y2 ▁ = ▁ " . $ y2 ; }
Hyp: 
function otherEndPoint ( $ x1 , $ y1 , $ m1 , $ m2 ) { $ x2 = 2 * $ m1 - $ x1 ; $ y2 = 2 * $ m2 - $ y1 ; echo " The ▁ other ▁ endpoint ▁ is ▁ " , $ x2 , " ▁ " , $ y2 ; }

BLEU: 58.29
Edit Sim: 33


Src: 
function rangeSum ( l , r ) { var a = 1 , b = 9 , res = 0 ; for ( var i = 1 ; i <= 10 ; i ++ ) { var L = Math . max ( l , a ) ; var R = Math . min ( r , b ) ; if ( L <= R ) { var sum = ( L + R ) * ( R - L + 1 ) / 2 ; res += ( i * i ) * ( sum % MOD ) ; res %= MOD ; } a = a * 10 ; b = b * 10 + 9 ; } return res ; }
Ref: 
function rangeSum ( $ l , $ r ) { global $ MOD ; $ a = 1 ; $ b = 9 ; $ res = 0 ; for ( $ i = 1 ; $ i <= 10 ; $ i ++ ) { $ L = max ( $ l , $ a ) ; $ R = min ( $ r , $ b ) ; if ( $ L <= $ R ) { $ sum = ( $ L + $ R ) * ( $ R - $ L + 1 ) / 2 ; $ res += ( $ i * $ i ) * ( $ sum % $ MOD ) ; $ res %= $ MOD ; } $ a = $ a * 10 ; $ b = $ b * 10 + 9 ; } return $ res ; }
Hyp: 
function rangeSum ( $ l , $ r ) { $ a = 1 ; $ b = 9 ; $ res = 0 ; for ( $ i = 1 ; $ i <= 10 ; $ i ++ ) { $ L = max ( $ l , $ a ) ; $ R = min ( $ r , $ b ) ; if ( $ L <= $ R ) { $ sum = ( $ L + $ R ) * ( $ R - $ L + 1 ) / 2 ; $ res += ( $ i * $ i ) * ( $ sum % $ MOD ) ; $ res %= $ MOD ; } $ a = $ a * 10 ; $ b = $ b * 10 + 9 ; } return $ res ; }

BLEU: 96.34
Edit Sim: 15


Src: 
function numberOfPaths ( m , n ) { if ( m == 1 n == 1 ) return 1 ; return numberOfPaths ( m - 1 , n ) + numberOfPaths ( m , n - 1 ) ; }
Ref: 
function numberOfPaths ( $ m , $ n ) { if ( $ m == 1 $ n == 1 ) return 1 ; return numberOfPaths ( $ m - 1 , $ n ) + numberOfPaths ( $ m , $ n - 1 ) ; }
Hyp: 
function numberOfPaths ( $ m , $ n ) { if ( $ m == 1 $ n == 1 ) return 1 ; return numberOfPaths ( $ m - 1 , $ n ) + numberOfPaths ( $ m , $ n - 1 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function printSorted ( arr , start , end ) { if ( start > end ) return ; printSorted ( arr , start * 2 + 1 , end ) ; document . write ( arr [ start ] + " " ) ; printSorted ( arr , start * 2 + 2 , end ) ; }
Ref: 
function printSorted ( $ arr , $ start , $ end ) { if ( $ start > $ end ) return ; printSorted ( $ arr , $ start * 2 + 1 , $ end ) ; echo ( $ arr [ $ start ] . " " ) ; printSorted ( $ arr , $ start * 2 + 2 , $ end ) ; }
Hyp: 
function printSorted ( $ arr , $ start , $ end ) { if ( $ start > $ end ) return ; printSorted ( $ arr , $ start * 2 + 1 , $ end ) ; echo ( $ arr [ $ start ] ) ; printSorted ( $ arr , $ start * 2 + 2 , $ end ) ; }

BLEU: 93.32
Edit Sim: 6


Src: 
function printSumSimple ( mat , k ) { if ( k > n ) return ; for ( let i = 0 ; i < n - k + 1 ; i ++ ) { for ( let j = 0 ; j < n - k + 1 ; j ++ ) { let sum = 0 ; for ( let p = i ; p < k + i ; p ++ ) for ( let q = j ; q < k + j ; q ++ ) sum += mat [ p ] [ q ] ; document . write ( sum + " " ) ; } document . write ( " " ) ; } }
Ref: 
function printSumSimple ( $ mat , $ k ) { global $ n ; if ( $ k > $ n ) return ; for ( $ i = 0 ; $ i < $ n - $ k + 1 ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n - $ k + 1 ; $ j ++ ) { $ sum = 0 ; for ( $ p = $ i ; $ p < $ k + $ i ; $ p ++ ) for ( $ q = $ j ; $ q < $ k + $ j ; $ q ++ ) $ sum += $ mat [ $ p ] [ $ q ] ; echo $ sum , " " ; } echo " STRNEWLINE " ; } }
Hyp: 
function printSumSimple ( $ mat , $ n , $ k ) { if ( $ k > $ n ) return ; for ( $ i = 0 ; $ i < $ n - $ k + 1 ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n - $ k + 1 ; $ j ++ ) { $ sum = 0 ; for ( $ p = $ i ; $ p < $ k + $ i ; $ p ++ ) for ( $ q = $ j ; $ q < $ k + $ j ; $ q ++ ) $ sum += $ mat [ $ p ] [ $ q ] ; echo $ sum , " ▁ " ; } echo " STRNEWLINE " ; } }

BLEU: 95.49
Edit Sim: 15


Src: 
function seiresSum ( n , a ) { return n * ( a [ 0 ] * a [ 0 ] - a [ 2 * n - 1 ] * a [ 2 * n - 1 ] ) / ( 2 * n - 1 ) ; }
Ref: 
function seiresSum ( $ n , $ a ) { return $ n * ( $ a [ 0 ] * $ a [ 0 ] - $ a [ 2 * $ n - 1 ] * $ a [ 2 * $ n - 1 ] ) / ( 2 * $ n - 1 ) ; }
Hyp: 
function seiresSum ( $ n , $ a ) { return $ n * ( $ a [ 0 ] * $ a [ 0 ] - $ a [ 2 * $ n - 1 ] * $ a [ 2 * $ n - 1 ] ) / ( 2 * $ n - 1 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function maxSumPairWithDifferenceLessThanK ( arr , N , k ) { var maxSum = 0 ; arr . sort ( ( a , b ) => a - b ) ; for ( i = N - 1 ; i > 0 ; -- i ) { if ( arr [ i ] - arr [ i - 1 ] < k ) { maxSum += arr [ i ] ; maxSum += arr [ i - 1 ] ; -- i ; } } return maxSum ; }
Ref: 
function maxSumPairWithDifferenceLessThanK ( $ arr , $ N , $ k ) { $ maxSum = 0 ; sort ( $ arr ) ; for ( $ i = $ N - 1 ; $ i > 0 ; -- $ i ) { if ( $ arr [ $ i ] - $ arr [ $ i - 1 ] < $ k ) { $ maxSum += $ arr [ $ i ] ; $ maxSum += $ arr [ $ i - 1 ] ; -- $ i ; } } return $ maxSum ; }
Hyp: 
function maxSumPairWithDifferenceLessThanK ( $ arr , $ N , $ k ) { $ maxSum = 0 ; sort ( $ arr ) ; for ( $ i = $ N - 1 ; $ i > 0 ; -- $ i ) { if ( $ arr [ $ i ] - $ arr [ $ i - 1 ] < $ k ) { $ maxSum += $ arr [ $ i ] ; $ maxSum += $ arr [ $ i - 1 ] ; -- $ i ; } } return $ maxSum ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function convert ( str ) { var w = " " , z = " " ; str = str . toUpperCase ( ) + " " ; for ( i = 0 ; i < str . length ; i ++ ) { var ch = str [ i ] ; if ( ch != ' ' ) w = w + ch ; else { z = z + ( w [ 0 ] . toLowerCase ( ) ) + w . substring ( 1 ) + " " ; w = " " ; } } return z ; }
Ref: 
function convert ( $ str ) { $ w = " " ; $ z = " " ; $ str = strtoupper ( $ str ) . " ▁ " ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) { $ ch = $ str [ $ i ] ; if ( $ ch != ' ▁ ' ) $ w = $ w . $ ch ; else { $ z = $ z . strtolower ( $ w [ 0 ] ) . substr ( $ w , 1 ) . " ▁ " ; $ w = " " ; } } return $ z ; }
Hyp: 
function convert ( $ str ) { $ w = " " ; $ z = " z ▁ " ; $ str = strtolower ( $ str ) ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) { $ ch = $ str [ $ i ] ; if ( $ ch != ' ▁ ' ) $ w = $ w + $ ch ; else { $ z = $ z + ( strtolower ( $ w [ 0 ] ) ) + $ w [ 1 ] . " " ; $ w = " " ; } } return $ z ; }

BLEU: 80.8
Edit Sim: 32


Src: 
function printRepeating ( arr , size ) { var i , j ; document . write ( " " ) ; for ( i = 0 ; i < size ; i ++ ) { for ( j = i + 1 ; j < size ; j ++ ) { if ( arr [ i ] == arr [ j ] ) document . write ( arr [ i ] + " " ) ; } } }
Ref: 
function printRepeating ( $ arr , $ size ) { $ i ; $ j ; echo " ▁ Repeating ▁ elements ▁ are ▁ " ; for ( $ i = 0 ; $ i < $ size ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ size ; $ j ++ ) if ( $ arr [ $ i ] == $ arr [ $ j ] ) echo $ arr [ $ i ] , " ▁ " ; }
Hyp: 
function printRepeating ( $ arr , $ size ) { echo " Repeating ▁ items ▁ are ▁ selected ▁ " . " STRNEWLINE " ; for ( $ i = 0 ; $ i < $ size ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ size ; $ j ++ ) { if ( $ arr [ $ i ] == $ arr [ $ j ] ) echo $ arr [ $ i ] . " ▁ " ; } } }

BLEU: 76.95
Edit Sim: 54


Src: 
function multiplyByFifteen ( n ) { let prod = ( n << 4 ) ; prod = prod - n ; return prod ; }
Ref: 
function multiplyByFifteen ( $ n ) { $ prod = ( $ n << 4 ) ; $ prod = $ prod - $ n ; return $ prod ; }
Hyp: 
function multiplyByFifteen ( $ n ) { $ prod = ( $ n << 4 ) ; $ prod = $ prod - $ n ; return $ prod ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function LCSubStr ( X , Y , m , n ) { var LCStuff = Array ( m + 1 ) . fill ( ) . map ( ( ) => Array ( n + 1 ) . fill ( 0 ) ) ; var result = 0 ; for ( i = 0 ; i <= m ; i ++ ) { for ( j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) LCStuff [ i ] [ j ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) { LCStuff [ i ] [ j ] = LCStuff [ i - 1 ] [ j - 1 ] + 1 ; result = Math . max ( result , LCStuff [ i ] [ j ] ) ; } else LCStuff [ i ] [ j ] = 0 ; } } return result ; }
Ref: 
function LCSubStr ( $ X , $ Y , $ m , $ n ) { $ LCSuff = array_fill ( 0 , $ m + 1 , array_fill ( 0 , $ n + 1 , NULL ) ) ; $ result = 0 ; for ( $ i = 0 ; $ i <= $ m ; $ i ++ ) { for ( $ j = 0 ; $ j <= $ n ; $ j ++ ) { if ( $ i == 0 $ j == 0 ) $ LCSuff [ $ i ] [ $ j ] = 0 ; else if ( $ X [ $ i - 1 ] == $ Y [ $ j - 1 ] ) { $ LCSuff [ $ i ] [ $ j ] = $ LCSuff [ $ i - 1 ] [ $ j - 1 ] + 1 ; $ result = max ( $ result , $ LCSuff [ $ i ] [ $ j ] ) ; } else $ LCSuff [ $ i ] [ $ j ] = 0 ; } } return $ result ; }
Hyp: 
function LCSubStr ( $ X , $ Y , $ m , $ n ) { $ LCStuff = array_fill ( 0 , $ m + 1 , $ n + 1 , 0 ) ; $ result = 0 ; for ( $ i = 0 ; $ i <= $ m ; $ i ++ ) { for ( $ j = 0 ; $ j <= $ n ; $ j ++ ) { if ( $ i == 0 $ j == 0 ) $ LCStuff [ $ i ] [ $ j ] = 0 ; else if ( $ X [ $ i - 1 ] == $ Y [ $ j - 1 ] ) { $ LCStuff [ $ i ] [ $ j ] = $ LCStuff [ $ i - 1 ] [ $ j - 1 ] + 1 ; $ result = max ( $ result , $ LCStuff [ $ i ] [ $ j ] ) ; } else $ LCStuff [ $ i ] [ $ j ] = 0 ; } } return $ result ; }

BLEU: 88.19
Edit Sim: 29


Src: 
function modularSum ( arr , n , m ) { if ( n > m ) return true ; let DP = new Array ( m ) ; for ( let l = 0 ; l < m ; l ++ ) DP [ l ] = false ; for ( let i = 0 ; i < n ; i ++ ) { if ( DP [ 0 ] ) return true ; let temp = new Array ( m ) ; for ( let l = 0 ; l < m ; l ++ ) temp [ l ] = false ; for ( let j = 0 ; j < m ; j ++ ) { if ( DP [ j ] == true ) { if ( DP [ ( j + arr [ i ] ) % m ] == false ) temp [ ( j + arr [ i ] ) % m ] = true ; } } for ( let j = 0 ; j < m ; j ++ ) if ( temp [ j ] ) DP [ j ] = true ; DP [ arr [ i ] % m ] = true ; } return DP [ 0 ] ; }
Ref: 
function modularSum ( $ arr , $ n , $ m ) { if ( $ n > $ m ) return true ; $ DP = Array_fill ( 0 , $ m , false ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ DP [ 0 ] ) return true ; $ temp = array_fill ( 0 , $ m , false ) ; for ( $ j = 0 ; $ j < $ m ; $ j ++ ) { if ( $ DP [ $ j ] == true ) { if ( $ DP [ ( $ j + $ arr [ $ i ] ) % $ m ] == false ) $ temp [ ( $ j + $ arr [ $ i ] ) % $ m ] = true ; } } for ( $ j = 0 ; $ j < $ m ; $ j ++ ) if ( $ temp [ $ j ] ) $ DP [ $ j ] = true ; $ DP [ $ arr [ $ i ] % $ m ] = true ; } return $ DP [ 0 ] ; }
Hyp: 
function modularSum ( $ arr , $ n , $ m ) { if ( $ n > $ m ) return true ; $ DP = array_fill ( 0 , $ m , false ) ; for ( $ l = 0 ; $ l < $ m ; $ l ++ ) $ DP [ $ l ] = false ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ DP [ 0 ] ) return true ; $ temp = array_fill ( 0 , $ m , false ) ; for ( $ l = 0 ; $ l < $ m ; $ l ++ ) $ temp [ $ l ] = false ; for ( $ j = 0 ; $ j < $ m ; $ j ++ ) if ( $ DP [ $ j ] == true ) { if ( $ DP [ ( $ j + $ arr [ $ i ] ) % $ m ] == false ) $ temp [ ( $ j + $ arr [ $ i ] ) % $ m ] = true ; } } for ( $ j = 0 ; $ j < $ m ; $ j ++ ) if ( $ temp [ $ j ] ) $ DP [ $ j ] = true ; $ DP [ $ arr [ $ i ] % $ m ] = true ; } return $ DP [ 0 ] ; }

BLEU: 78.9
Edit Sim: 125


Src: 
function maxSum ( a , n ) { let l = [ ] ; let s = 0 ; for ( let i = 0 ; i < n ; i ++ ) { s += Math . abs ( a [ i ] ) ; if ( a [ i ] >= 0 ) continue ; if ( i == 0 ) l . push ( i + 1 ) ; else { l . push ( i + 1 ) ; l . push ( i ) ; } } document . write ( s + " " ) ; for ( let i = 0 ; i < l . length ; i ++ ) document . write ( l [ i ] + " " ) ; }
Ref: 
function maxSum ( $ a , $ n ) { $ s = 0 ; $ l = array ( ) ; for ( $ i = 0 ; $ i < count ( $ a ) ; $ i ++ ) { $ s += abs ( $ a [ $ i ] ) ; if ( $ a [ $ i ] >= 0 ) continue ; if ( $ i == 0 ) array_push ( $ l , $ i + 1 ) ; else { array_push ( $ l , $ i + 1 ) ; array_push ( $ l , $ i ) ; } } echo $ s . " STRNEWLINE " ; for ( $ i = 0 ; $ i < count ( $ l ) ; $ i ++ ) echo $ l [ $ i ] . " ▁ " ; }
Hyp: 
function maxSum ( $ a , $ n ) { $ l = array ( ) ; $ s = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ s += abs ( $ a [ $ i ] ) ; if ( $ a [ $ i ] >= 0 ) continue ; if ( $ i == 0 ) $ l . push ( $ i + 1 ) ; else { $ l . push ( $ i + 1 ) ; $ l . push ( $ i ) ; } } echo $ s , " ▁ " ; for ( $ i = 0 ; $ i < sizeof ( $ l ) ; $ i ++ ) echo $ l [ $ i ] . " ▁ " ; }

BLEU: 79.21
Edit Sim: 79


Src: 
function sumOfTheSeries ( n ) { let sum_n = ( n * ( n + 1 ) / 2 ) ; let sum_sq_n = ( n * ( n + 1 ) / 2 ) * ( 2 * n + 1 ) / 3 ; return ( sum_n + sum_sq_n ) ; }
Ref: 
function sumOfTheSeries ( $ n ) { $ sum_n = ( $ n * ( $ n + 1 ) / 2 ) ; $ sum_sq_n = ( $ n * ( $ n + 1 ) / 2 ) * ( 2 * $ n + 1 ) / 3 ; return ( $ sum_n + $ sum_sq_n ) ; }
Hyp: 
function sumOfTheSeries ( $ n ) { $ sum_n = ( $ n * ( $ n + 1 ) / 2 ) ; $ sum_sq_n = ( $ n * ( $ n + 1 ) / 2 ) * ( 2 * $ n + 1 ) / 3 ; return ( $ sum_n + $ sum_sq_n ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function numOfways ( n , k ) { let p = 1 ; if ( k % 2 != 0 ) p = - 1 ; return ( Math . pow ( n - 1 , k ) + p * ( n - 1 ) ) / n ; }
Ref: 
function numOfways ( $ n , $ k ) { $ p = 1 ; if ( $ k % 2 ) $ p = -1 ; return ( pow ( $ n - 1 , $ k ) + $ p * ( $ n - 1 ) ) / $ n ; }
Hyp: 
function numOfways ( $ n , $ k ) { $ p = 1 ; if ( $ k % 2 != 0 ) $ p = -1 ; return ( pow ( $ n - 1 , $ k ) + $ p * ( $ n - 1 ) ) / $ n ; }

BLEU: 93.74
Edit Sim: 5


Src: 
function possibleways ( n ) { if ( n % 2 == 1 ) return 0 ; else if ( n % 4 == 0 ) return n / 4 - 1 ; else return n / 4 ; }
Ref: 
function possibleways ( $ n ) { if ( $ n % 2 == 1 ) return 0 ; else if ( $ n % 4 == 0 ) return $ n / 4 - 1 ; else return $ n / 4 ; }
Hyp: 
function possibleways ( $ n ) { if ( $ n % 2 == 1 ) return 0 ; else if ( $ n % 4 == 0 ) return $ n / 4 - 1 ; else return $ n / 4 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function inversegrayCode ( n ) { let inv = 0 ; for ( ; n ; n = n >> 1 ) inv ^= n ; return inv ; }
Ref: 
function inversegrayCode ( $ n ) { $ inv = 0 ; for ( ; $ n ; $ n = $ n >> 1 ) $ inv ^= $ n ; return $ inv ; }
Hyp: 
function inversegrayCode ( $ n ) { $ inv = 0 ; for ( ; $ n ; $ n = $ n >> 1 ) $ inv ^= $ n ; return $ inv ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function longCommomAnagramSubseq ( str1 , str2 , n1 , n2 ) { let freq1 = new Array ( SIZE ) ; let freq2 = new Array ( SIZE ) ; for ( let i = 0 ; i < SIZE ; i ++ ) { freq1 [ i ] = 0 ; freq2 [ i ] = 0 ; } let len = 0 ; for ( let i = 0 ; i < n1 ; i ++ ) freq1 [ str1 [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; for ( let i = 0 ; i < n2 ; i ++ ) freq2 [ str2 [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; for ( let i = 0 ; i < SIZE ; i ++ ) len += Math . min ( freq1 [ i ] , freq2 [ i ] ) ; return len ; }
Ref: 
function longCommomAnagramSubseq ( $ str1 , $ str2 , $ n1 , $ n2 ) { global $ SIZE ; $ freq1 = array ( ) ; $ freq2 = array ( ) ; for ( $ i = 0 ; $ i < $ SIZE ; $ i ++ ) { $ freq1 [ $ i ] = 0 ; $ freq2 [ $ i ] = 0 ; } $ len = 0 ; for ( $ i = 0 ; $ i < $ n1 ; $ i ++ ) $ freq1 [ ord ( $ str1 [ $ i ] ) - ord ( ' a ' ) ] ++ ; for ( $ i = 0 ; $ i < $ n2 ; $ i ++ ) $ freq2 [ ord ( $ str2 [ $ i ] ) - ord ( ' a ' ) ] ++ ; for ( $ i = 0 ; $ i < $ SIZE ; $ i ++ ) { $ len += min ( $ freq1 [ $ i ] , $ freq2 [ $ i ] ) ; } return $ len ; }
Hyp: 
function longCommomAnagramSubseq ( $ str1 , $ str2 , $ n1 , $ n2 ) { $ freq1 = array ( ) ; $ freq2 = array ( ) ; for ( $ i = 0 ; $ i < $ SIZE ; $ i ++ ) { $ freq1 [ $ i ] = 0 ; $ freq2 [ $ i ] = 0 ; } $ len = 0 ; for ( $ i = 0 ; $ i < $ n1 ; $ i ++ ) $ freq1 [ $ str1 [ $ i ] - ' a ' ] ++ ; for ( $ i = 0 ; $ i < $ n2 ; $ i ++ ) $ freq2 [ $ str2 [ $ i ] - ' a ' ] ++ ; for ( $ i = 0 ; $ i < $ SIZE ; $ i ++ ) $ len += min ( $ freq1 [ $ i ] , $ freq2 [ $ i ] ) ; return $ len ; }

BLEU: 82.96
Edit Sim: 52


Src: 
function countOnes ( arr , low , high ) { if ( high >= low ) { let mid = Math . trunc ( low + ( high - low ) / 2 ) ; if ( ( mid == high arr [ mid + 1 ] == 0 ) && ( arr [ mid ] == 1 ) ) return mid + 1 ; if ( arr [ mid ] == 1 ) return countOnes ( arr , ( mid + 1 ) , high ) ; return countOnes ( arr , low , ( mid - 1 ) ) ; } return 0 ; }
Ref: 
function countOnes ( $ arr , $ low , $ high ) { if ( $ high >= $ low ) { $ mid = $ low + ( $ high - $ low ) / 2 ; if ( ( $ mid == $ high or $ arr [ $ mid + 1 ] == 0 ) and ( $ arr [ $ mid ] == 1 ) ) return $ mid + 1 ; if ( $ arr [ $ mid ] == 1 ) return countOnes ( $ arr , ( $ mid + 1 ) , $ high ) ; return countOnes ( $ arr , $ low , ( $ mid - 1 ) ) ; } return 0 ; }
Hyp: 
function countOnes ( $ arr , $ low , $ high ) { if ( $ high >= $ low ) { $ mid = trunc ( $ low + ( $ high - $ low ) / 2 ) ; if ( ( $ mid == $ high $ arr [ $ mid + 1 ] == 0 ) && ( $ arr [ $ mid ] == 1 ) ) return $ mid + 1 ; if ( $ arr [ $ mid ] == 1 ) return countOnes ( $ arr , ( $ mid + 1 ) , $ high ) ; return countOnes ( $ arr , $ low , ( $ mid - 1 ) ) ; } return 0 ; }

BLEU: 92.06
Edit Sim: 16


Src: 
function minIndex ( arr , n ) { var sum = 0 ; for ( i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; for ( i = 0 ; i < n ; i ++ ) { if ( 2 * arr [ i ] == sum ) return ( i + 1 ) ; } return - 1 ; }
Ref: 
function minIndex ( & $ arr , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum += $ arr [ $ i ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( 2 * $ arr [ $ i ] == $ sum ) return ( $ i + 1 ) ; } return -1 ; }
Hyp: 
function minIndex ( $ arr , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum += $ arr [ $ i ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( 2 * $ arr [ $ i ] == $ sum ) return ( $ i + 1 ) ; } return -1 ; }

BLEU: 97.12
Edit Sim: 2


Src: 
function dodecahedral_num ( n ) { return n * ( 3 * n - 1 ) * ( 3 * n - 2 ) / 2 ; }
Ref: 
function dodecahedral_num ( $ n ) { return $ n * ( 3 * $ n - 1 ) * ( 3 * $ n - 2 ) / 2 ; }
Hyp: 
function dodecahedral_num ( $ n ) { return $ n * ( 3 * $ n - 1 ) * ( 3 * $ n - 2 ) / 2 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findLCM ( a , b ) { var lar = Math . max ( a , b ) ; var small = Math . min ( a , b ) ; for ( i = lar ; ; i += lar ) { if ( i % small == 0 ) return i ; } }
Ref: 
function findLCM ( $ a , $ b ) { $ lar = max ( $ a , $ b ) ; $ small = min ( $ a , $ b ) ; for ( $ i = $ lar ; ; $ i += $ lar ) { if ( $ i % $ small == 0 ) return $ i ; } }
Hyp: 
function findLCM ( $ a , $ b ) { $ lar = max ( $ a , $ b ) ; $ small = min ( $ a , $ b ) ; for ( $ i = $ lar ; ; $ i += $ lar ) { if ( $ i % $ small == 0 ) return $ i ; } }

BLEU: 100.0
Edit Sim: 0


Src: 
function countNumbers ( l , r ) { return ( parseInt ( r / 6 ) - parseInt ( ( l - 1 ) / 6 ) ) ; }
Ref: 
function countNumbers ( $ l , $ r ) { return ( ( int ) ( $ r / 6 ) - ( int ) ( ( $ l - 1 ) / 6 ) ) ; }
Hyp: 
function countNumbers ( $ l , $ r ) { return ( ( int ) ( $ r / 6 ) - ( int ) ( ( $ l - 1 ) / 6 ) ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findSum ( n ) { var sum2 , sum5 , sum10 ; sum2 = parseInt ( ( parseInt ( n / 2 ) * ( 4 + ( parseInt ( n / 2 ) - 1 ) * 2 ) ) / 2 ) ; sum5 = parseInt ( ( parseInt ( n / 5 ) * ( 10 + ( parseInt ( n / 5 ) - 1 ) * 5 ) ) / 2 ) ; sum10 = parseInt ( ( parseInt ( n / 10 ) * ( 20 + ( parseInt ( n / 10 ) - 1 ) * 10 ) ) / 2 ) ; return sum2 + sum5 - sum10 ; }
Ref: 
function findSum ( $ n ) { $ sum2 = ( ( int ) ( $ n / 2 ) * ( 4 + ( ( int ) ( $ n / 2 ) - 1 ) * 2 ) ) / 2 ; $ sum5 = ( ( int ) ( $ n / 5 ) * ( 10 + ( $ n / 5 - 1 ) * 5 ) ) / 2 ; $ sum10 = ( ( int ) ( $ n / 10 ) * ( 20 + ( $ n / 10 - 1 ) * 10 ) ) / 2 ; return $ sum2 + $ sum5 - $ sum10 ; }
Hyp: 
function findSum ( $ n ) { $ sum2 ; $ sum5 ; $ sum10 ; $ sum2 = ( ( $ n / 2 ) * ( 4 + ( $ n / 2 ) - 1 ) * 2 ) ) ; $ sum5 = ( ( $ n / 5 ) * ( 10 + ( $ n / 5 ) - 1 ) * 5 ) ) / 2 ; $ sum10 = ( ( $ n / 10 ) * ( 20 + ( $ n / 10 ) - 1 ) * 10 ) ) / 2 ; return $ sum2 + $ sum5 - $ sum10 ; }

BLEU: 80.86
Edit Sim: 56


Src: 
function checkFibinnary ( n ) { var prev_last = 0 ; while ( n != 0 ) { if ( ( n & 1 ) != 0 && prev_last != 0 ) return false ; prev_last = n & 1 ; n >>= 1 ; } return true ; }
Ref: 
function checkFibinnary ( $ n ) { $ prev_last = 0 ; while ( $ n ) { if ( ( $ n & 1 ) && $ prev_last ) return false ; $ prev_last = $ n & 1 ; $ n >>= 1 ; } return true ; }
Hyp: 
function checkFibinnary ( $ n ) { $ prev_last = 0 ; while ( $ n != 0 ) { if ( ( $ n & 1 ) != 0 && $ prev_last != 0 ) return false ; $ prev_last = $ n & 1 ; $ n >>= 1 ; } return true ; }

BLEU: 81.04
Edit Sim: 15


Src: 
function findMin ( arr , low , high ) { if ( high < low ) return arr [ 0 ] ; if ( high == low ) return arr [ low ] ; let mid = low + Math . floor ( ( high - low ) / 2 ) ; if ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) return arr [ mid + 1 ] ; if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) return arr [ mid ] ; if ( arr [ high ] > arr [ mid ] ) return findMin ( arr , low , mid - 1 ) ; return findMin ( arr , mid + 1 , high ) ; }
Ref: 
function findMin ( $ arr , $ low , $ high ) { if ( $ high < $ low ) return $ arr [ 0 ] ; if ( $ high == $ low ) return $ arr [ $ low ] ; $ mid = $ low + ( $ high - $ low ) / 2 ; if ( $ mid < $ high && $ arr [ $ mid + 1 ] < $ arr [ $ mid ] ) return $ arr [ $ mid + 1 ] ; if ( $ mid > $ low && $ arr [ $ mid ] < $ arr [ $ mid - 1 ] ) return $ arr [ $ mid ] ; if ( $ arr [ $ high ] > $ arr [ $ mid ] ) return findMin ( $ arr , $ low , $ mid - 1 ) ; return findMin ( $ arr , $ mid + 1 , $ high ) ; }
Hyp: 
function findMin ( $ arr , $ low , $ high ) { if ( $ high < $ low ) return $ arr [ 0 ] ; if ( $ high == $ low ) return $ arr [ $ low ] ; $ mid = $ low + ( int ) ( ( $ high - $ low ) / 2 ) ; if ( $ mid < $ high && $ arr [ $ mid + 1 ] < $ arr [ $ mid ] ) return $ arr [ $ mid + 1 ] ; if ( $ mid > $ low && $ arr [ $ mid ] < $ arr [ $ mid - 1 ] ) return $ arr [ $ mid ] ; if ( $ arr [ $ high ] > $ arr [ $ mid ] ) return findMin ( $ arr , $ low , $ mid - 1 ) ; return findMin ( $ arr , $ mid + 1 , $ high ) ; }

BLEU: 95.9
Edit Sim: 12


Src: 
function getMaxGold ( gold , m , n ) { let goldTable = new Array ( m ) ; for ( let i = 0 ; i < m ; i ++ ) { goldTable [ i ] = new Array ( n ) ; for ( let j = 0 ; j < n ; j ++ ) { goldTable [ i ] [ j ] = 0 ; } } for ( let col = n - 1 ; col >= 0 ; col -- ) { for ( let row = 0 ; row < m ; row ++ ) { let right = ( col == n - 1 ) ? 0 : goldTable [ row ] [ col + 1 ] ; let right_up = ( row == 0 col == n - 1 ) ? 0 : goldTable [ row - 1 ] [ col + 1 ] ; let right_down = ( row == m - 1 col == n - 1 ) ? 0 : goldTable [ row + 1 ] [ col + 1 ] ; goldTable [ row ] [ col ] = gold [ row ] [ col ] + Math . max ( right , Math . max ( right_up , right_down ) ) ; } } let res = goldTable [ 0 ] [ 0 ] ; for ( let i = 1 ; i < m ; i ++ ) res = Math . max ( res , goldTable [ i ] [ 0 ] ) ; return res ; }
Ref: 
function getMaxGold ( $ gold , $ m , $ n ) { $ MAX = 100 ; $ goldTable = array ( array ( ) ) ; for ( $ i = 0 ; $ i < $ m ; $ i ++ ) for ( $ j = 0 ; $ j < $ n ; $ j ++ ) $ goldTable [ $ i ] [ $ j ] = 0 ; for ( $ col = $ n - 1 ; $ col >= 0 ; $ col -- ) { for ( $ row = 0 ; $ row < $ m ; $ row ++ ) { if ( $ col == $ n - 1 ) $ right = 0 ; else $ right = $ goldTable [ $ row ] [ $ col + 1 ] ; if ( $ row == 0 or $ col == $ n - 1 ) $ right_up = 0 ; else $ right_up = $ goldTable [ $ row - 1 ] [ $ col + 1 ] ; if ( $ row == $ m - 1 or $ col == $ n - 1 ) $ right_down = 0 ; else $ right_down = $ goldTable [ $ row + 1 ] [ $ col + 1 ] ; $ goldTable [ $ row ] [ $ col ] = $ gold [ $ row ] [ $ col ] + max ( $ right , $ right_up , $ right_down ) ; } } $ res = $ goldTable [ 0 ] [ 0 ] ; for ( $ i = 0 ; $ i < $ m ; $ i ++ ) $ res = max ( $ res , $ goldTable [ $ i ] [ 0 ] ) ; return $ res ; }
Hyp: 
function getMaxGold ( $ gold , $ m , $ n ) { $ goldTable = array_fill ( 0 , $ m , array_fill ( 0 , $ n , NULL ) ) ; for ( $ i = 0 ; $ i < $ m ; $ i ++ ) for ( $ j = 0 ; $ j < $ n ; $ j ++ ) $ goldTable [ $ i ] [ $ j ] = 0 ; for ( $ col = $ n - 1 ; $ col >= 0 ; $ col -- ) { for ( $ row = 0 ; $ row < $ m ; $ row ++ ) { $ right = ( $ col == $ n - 1 ) ? 0 : $ goldTable [ $ row ] [ $ col + 1 ] ; $ right_up = ( $ row == 0 $ col == $ n - 1 ) ? 0 : $ goldTable [ $ row - 1 ] [ $ col + 1 ] ; $ right_down = ( $ row == $ m - 1 $ col == $ n - 1 ) ? 0 : $ goldTable [ $ row + 1 ] [ $ col + 1 ] ; $ goldTable [ $ row ] [ $ col ] = $ gold [ $ row ] [ $ col ] + max ( $ right , max ( $ right_up , $ right_down ) ) ; } } $ res = $ goldTable [ 0 ] [ 0 ] ; for ( $ i = 1 ; $ i < $ m ; $ i ++ ) $ res = max ( $ res , $ goldTable [ $ i ] [ 0 ] ) ; return $ res ; }

BLEU: 82.87
Edit Sim: 185


Src: 
function aredisjoint ( set1 , set2 ) { for ( let i = 0 ; i < set1 . length ; i ++ ) { for ( let j = 0 ; j < set2 . length ; j ++ ) { if ( set1 [ i ] == set2 [ j ] ) return false ; } } return true ; }
Ref: 
function areDisjoint ( $ set1 , $ set2 , $ m , $ n ) { for ( $ i = 0 ; $ i < $ m ; $ i ++ ) for ( $ j = 0 ; $ j < $ n ; $ j ++ ) if ( $ set1 [ $ i ] == $ set2 [ $ j ] ) return false ; return true ; }
Hyp: 
function aredisjoint ( $ set1 , $ set2 ) { for ( $ i = 0 ; $ i < sizeof ( $ set1 ) ; $ i ++ ) { for ( $ j = 0 ; $ j < sizeof ( $ set2 ) ; $ j ++ ) { if ( $ set1 [ $ i ] == $ set2 [ $ j ] ) return false ; } } return true ; }

BLEU: 67.33
Edit Sim: 50


Src: 
function findMinX ( num , rem , k ) { while ( true ) { var j ; for ( j = 0 ; j < k ; j ++ ) if ( x % num [ j ] != rem [ j ] ) break ; if ( j == k ) return x ; x ++ ; } }
Ref: 
function findMinX ( $ num , $ rem , $ k ) { while ( true ) { $ j ; for ( $ j = 0 ; $ j < $ k ; $ j ++ ) if ( $ x % $ num [ $ j ] != $ rem [ $ j ] ) break ; if ( $ j == $ k ) return $ x ; $ x ++ ; } return $ x ; }
Hyp: 
function findMinX ( $ num , $ rem , $ k ) { while ( true ) { $ j ; for ( $ j = 0 ; $ j < $ k ; $ j ++ ) if ( $ x % $ num [ $ j ] != $ rem [ $ j ] ) break ; if ( $ j == $ k ) return $ x ; $ x ++ ; } }

BLEU: 94.0
Edit Sim: 13


Src: 
function diagonal_length ( a ) { let L ; L = a * Math . sqrt ( 3 ) ; return L ; }
Ref: 
function diagonal_length ( $ a ) { $ L ; $ L = $ a * sqrt ( 3 ) ; return $ L ; }
Hyp: 
function diagonal_length ( $ a ) { $ L ; $ L = $ a * sqrt ( 3 ) ; return $ L ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function fibonacci ( n ) { var fib ; for ( i = 0 ; i < n ; i ++ ) { fib = ( Math . pow ( ( 1 + Math . sqrt ( 5 ) ) , i ) - Math . pow ( ( 1 - Math . sqrt ( 5 ) ) , i ) ) / ( Math . pow ( 2 , i ) * Math . sqrt ( 5 ) ) ; document . write ( parseInt ( fib ) + " " ) ; } }
Ref: 
function fibonacci ( $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ fib = ( pow ( ( 1 + sqrt ( 5 ) ) , $ i ) - pow ( ( 1 - sqrt ( 5 ) ) , $ i ) ) / ( pow ( 2 , $ i ) * sqrt ( 5 ) ) ; echo $ fib , " " ; } }
Hyp: 
function fibonacci ( $ n ) { $ fib ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ fib = ( pow ( ( 1 + sqrt ( 5 ) ) , $ i ) - pow ( ( 1 - sqrt ( 5 ) ) , $ i ) ) / ( pow ( 2 , $ i ) * sqrt ( 5 ) ) ; echo ( $ fib ) , " ▁ " ; } }

BLEU: 86.98
Edit Sim: 14


Src: 
function polyarea ( n , r ) { if ( r < 0 && n < 0 ) return - 1 ; var A = ( ( r * r * n ) * Math . sin ( ( 360 / n ) * 3.14159 / 180 ) ) / 2 ; return A ; }
Ref: 
function polyarea ( $ n , $ r ) { if ( $ r < 0 && $ n < 0 ) return -1 ; $ A = ( ( $ r * $ r * $ n ) * sin ( ( 360 / $ n ) * 3.14159 / 180 ) ) / 2 ; return $ A ; }
Hyp: 
function polyarea ( $ n , $ r ) { if ( $ r < 0 && $ n < 0 ) return -1 ; $ A = ( ( $ r * $ r * $ n ) * sin ( ( 360 / $ n ) * 3.14159 / 180 ) ) / 2 ; return $ A ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countSquares ( m , n ) { if ( n < m ) [ m , n ] = [ n , m ] ; return m * ( m + 1 ) * ( 2 * m + 1 ) / 6 + ( n - m ) * m * ( m + 1 ) / 2 ; }
Ref: 
function countSquares ( $ m , $ n ) { if ( $ n < $ m ) list ( $ m , $ n ) = array ( $ n , $ m ) ; return $ m * ( $ m + 1 ) * ( 2 * $ m + 1 ) / 6 + ( $ n - $ m ) * $ m * ( $ m + 1 ) / 2 ; }
Hyp: 
function countSquares ( $ m , $ n ) { if ( $ n < $ m ) [ $ m , $ n ] = [ $ n , $ m ] ; return $ m * ( $ m + 1 ) * ( 2 * $ m + 1 ) / 6 + ( $ n - $ m ) * $ m * ( $ m + 1 ) / 2 ; }

BLEU: 85.44
Edit Sim: 15


Src: 
function evenbittogglenumber ( n ) { let res = 0 , count = 0 ; for ( let temp = n ; temp > 0 ; temp >>= 1 ) { if ( count % 2 == 1 ) res |= ( 1 << count ) ; count ++ ; } return n ^ res ; }
Ref: 
function evenbittogglenumber ( $ n ) { $ res = 0 ; $ count = 0 ; for ( $ temp = $ n ; $ temp > 0 ; $ temp >>= 1 ) { if ( $ count % 2 == 1 ) $ res |= ( 1 << $ count ) ; $ count ++ ; } return $ n ^ $ res ; }
Hyp: 
function evenbittogglenumber ( $ n ) { $ res = 0 ; $ count = 0 ; for ( $ temp = $ n ; $ temp > 0 ; $ temp >>= 1 ) { if ( $ count % 2 == 1 ) $ res |= ( 1 << $ count ) ; $ count ++ ; } return $ n ^ $ res ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function segregate0and1 ( arr , size ) { let left = 0 , right = size - 1 ; while ( left < right ) { while ( arr [ left ] == 0 && left < right ) left ++ ; while ( arr [ right ] == 1 && left < right ) right -- ; if ( left < right ) { arr [ left ] = 0 ; arr [ right ] = 1 ; left ++ ; right -- ; } } }
Ref: 
function segregate0and1 ( & $ arr , $ size ) { $ left = 0 ; $ right = $ size - 1 ; while ( $ left < $ right ) { while ( $ arr [ $ left ] == 0 && $ left < $ right ) $ left ++ ; while ( $ arr [ $ right ] == 1 && $ left < $ right ) $ right -- ; if ( $ left < $ right ) { $ arr [ $ left ] = 0 ; $ arr [ $ right ] = 1 ; $ left ++ ; $ right -- ; } } }
Hyp: 
function segregate0and1 ( & $ arr , $ size ) { $ left = 0 ; $ right = $ size - 1 ; while ( $ left < $ right ) { while ( $ arr [ $ left ] == 0 && $ left < $ right ) $ left ++ ; while ( $ arr [ $ right ] == 1 && $ left < $ right ) $ right -- ; if ( $ left < $ right ) { $ arr [ $ left ] = 0 ; $ arr [ $ right ] = 1 ; $ left ++ ; $ right -- ; } } }

BLEU: 100.0
Edit Sim: 0


Src: 
function search ( arr , l , h , key ) { if ( l > h ) return - 1 ; let mid = Math . floor ( ( l + h ) / 2 ) ; if ( arr [ mid ] == key ) return mid ; if ( arr [ l ] <= arr [ mid ] ) { if ( key >= arr [ l ] && key <= arr [ mid ] ) return search ( arr , l , mid - 1 , key ) ; return search ( arr , mid + 1 , h , key ) ; } if ( key >= arr [ mid ] && key <= arr [ h ] ) return search ( arr , mid + 1 , h , key ) ; return search ( arr , l , mid - 1 , key ) ; }
Ref: 
function search ( $ arr , $ l , $ h , $ key ) { if ( $ l > $ h ) return -1 ; $ mid = ( $ l + $ h ) / 2 ; if ( $ arr [ $ mid ] == $ key ) return $ mid ; if ( $ arr [ $ l ] <= $ arr [ $ mid ] ) { if ( $ key >= $ arr [ $ l ] && $ key <= $ arr [ $ mid ] ) return search ( $ arr , $ l , $ mid - 1 , $ key ) ; return search ( $ arr , $ mid + 1 , $ h , $ key ) ; } if ( $ key >= $ arr [ $ mid ] && $ key <= $ arr [ $ h ] ) return search ( $ arr , $ mid + 1 , $ h , $ key ) ; return search ( $ arr , $ l , $ mid - 1 , $ key ) ; }
Hyp: 
function search ( $ arr , $ l , $ h , $ key ) { if ( $ l > $ h ) return -1 ; $ mid = ( int ) ( ( $ l + $ h ) / 2 ) ; if ( $ arr [ $ mid ] == $ key ) return $ mid ; if ( $ arr [ $ l ] <= $ arr [ $ mid ] ) { if ( $ key >= $ arr [ $ l ] and $ key <= $ arr [ $ mid ] ) return search ( $ arr , $ l , $ mid - 1 , $ key ) ; return search ( $ arr , $ mid + 1 , $ h , $ key ) ; } if ( $ key >= $ arr [ $ mid ] and $ key <= $ arr [ $ h ] ) return search ( $ arr , $ mid + 1 , $ h , $ key ) ; return search ( $ arr , $ l , $ mid - 1 , $ key ) ; }

BLEU: 93.7
Edit Sim: 18


Src: 
function printOdds ( arr , n ) { let res = 0 ; for ( let i = 0 ; i < n ; i ++ ) res = res ^ arr [ i ] ; let set_bit = res & ( ~ ( res - 1 ) ) ; let x = 0 , y = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] & set_bit ) x = x ^ arr [ i ] ; else y = y ^ arr [ i ] ; } document . write ( x + " " + y ) ; }
Ref: 
function printOdds ( $ arr , $ n ) { $ res = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ res = $ res ^ $ arr [ $ i ] ; $ set_bit = $ res & ( ~ ( $ res - 1 ) ) ; $ x = 0 ; $ y = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] & $ set_bit ) $ x = $ x ^ $ arr [ $ i ] ; else $ y = $ y ^ $ arr [ $ i ] ; } echo ( $ x . " ▁ " . $ y ) ; }
Hyp: 
function printOdds ( $ arr , $ n ) { $ res = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ res = $ res ^ $ arr [ $ i ] ; $ set_bit = $ res & ( ~ ( $ res - 1 ) ) ; $ x = 0 ; $ y = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] & $ set_bit ) $ x = $ x ^ $ arr [ $ i ] ; else $ y = $ y ^ $ arr [ $ i ] ; } echo $ x . " ▁ " . $ y ; }

BLEU: 96.64
Edit Sim: 4


Src: 
function oddSum ( n ) { let sum = 0 ; curr = 1 ; for ( let i = 0 ; i < n ; i ++ ) { sum += curr ; curr += 2 ; } return sum ; }
Ref: 
function oddSum ( $ n ) { $ sum = 0 ; $ curr = 1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sum += $ curr ; $ curr += 2 ; } return $ sum ; }
Hyp: 
function oddSum ( $ n ) { $ sum = 0 ; $ curr = 1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sum += $ curr ; $ curr += 2 ; } return $ sum ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function sumOfSubstrings ( num ) { let sum = 0 ; let mf = 1 ; for ( let i = num . length - 1 ; i >= 0 ; i -- ) { sum += ( num [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ) * ( i + 1 ) * mf ; mf = mf * 10 + 1 ; } return sum ; }
Ref: 
function sumOfSubstrings ( $ num ) { $ sum = 0 ; $ mf = 1 ; for ( $ i = strlen ( $ num ) - 1 ; $ i >= 0 ; $ i -- ) { $ sum += ( $ num [ $ i ] - '0' ) * ( $ i + 1 ) * $ mf ; $ mf = $ mf * 10 + 1 ; } return $ sum ; }
Hyp: 
function sumOfSubstrings ( $ num ) { $ sum = 0 ; $ mf = 1 ; for ( $ i = strlen ( $ num ) - 1 ; $ i >= 0 ; $ i -- ) { $ sum += ( ord ( $ num [ $ i ] ) - ord ( '0' ) ) * ( $ i + 1 ) * $ mf ; $ mf = $ mf * 10 + 1 ; } return $ sum ; }

BLEU: 88.78
Edit Sim: 16


Src: 
function printIntersection ( A , B ) { for ( var i = 0 ; i < M ; i ++ ) { for ( var j = 0 ; j < N ; j ++ ) { if ( A [ i ] [ j ] == B [ i ] [ j ] ) document . write ( A [ i ] [ j ] + " " ) ; else document . write ( " " ) ; } document . write ( " " ) ; } }
Ref: 
function printIntersection ( $ A , $ B ) { $ N = 4 ; $ M = 4 ; for ( $ i = 0 ; $ i < $ M ; $ i ++ ) { for ( $ j = 0 ; $ j < $ N ; $ j ++ ) { if ( $ A [ $ i ] [ $ j ] == $ B [ $ i ] [ $ j ] ) echo $ A [ $ i ] [ $ j ] . " ▁ " ; else echo " * ▁ " ; } echo " STRNEWLINE " ; } }
Hyp: 
function printIntersection ( $ A , $ B ) { for ( $ i = 0 ; $ i < $ M ; $ i ++ ) { for ( $ j = 0 ; $ j < $ N ; $ j ++ ) { if ( $ A [ $ i ] [ $ j ] == $ B [ $ i ] [ $ j ] ) echo $ A [ $ i ] [ $ j ] . " ▁ " ; else echo " No " ; } echo " STRNEWLINE " ; } }

BLEU: 85.93
Edit Sim: 23


Src: 
function PossibleValues ( b , x , n ) { let leastdivisible = ( Math . floor ( b / x ) + 1 ) * x ; let flag = 1 ; while ( leastdivisible <= n ) { if ( leastdivisible - b >= 1 ) { document . write ( leastdivisible - b + " " ) ; leastdivisible += x ; flag = 0 ; } else break ; } if ( flag > 0 ) document . write ( - 1 + " " ) ; }
Ref: 
function PossibleValues ( $ b , $ x , $ n ) { $ leastdivisible = ( intval ( $ b / $ x ) + 1 ) * $ x ; $ flag = 1 ; while ( $ leastdivisible <= $ n ) { if ( $ leastdivisible - $ b >= 1 ) { echo $ leastdivisible - $ b . " " ; $ leastdivisible += $ x ; $ flag = 0 ; } else break ; } if ( $ flag ) echo " - 1" ; }
Hyp: 
function PossibleValues ( $ b , $ x , $ n ) { $ leastdivisible = ( int ) ( $ b / $ x ) + 1 ) * $ x ; $ flag = 1 ; while ( $ leastdivisible <= $ n ) { if ( $ leastdivisible - $ b >= 1 ) { echo $ leastdivisible - $ b . " " ; $ leastdivisible += $ x ; $ flag = 0 ; } else break ; } if ( $ flag > 0 ) echo - 1 . " No " ; }

BLEU: 86.32
Edit Sim: 16


Src: 
function maxSquare ( b , m ) { return ( b / m - 1 ) * ( b / m ) / 2 ; a }
Ref: 
function maxSquare ( $ b , $ m ) { return ( $ b / $ m - 1 ) * ( $ b / $ m ) / 2 ; }
Hyp: 
function maxSquare ( $ b , $ m ) { return ( $ b / $ m - 1 ) * ( $ b / $ m ) / 2 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function dist ( x1 , y1 , x2 , y2 , r ) { document . write ( " " + " " + ( Math . sqrt ( ( Math . pow ( ( x2 - x1 ) , 2 ) ) + ( Math . pow ( ( y2 - y1 ) , 2 ) ) ) - r ) . toFixed ( 5 ) ) ; }
Ref: 
function dist ( $ x1 , $ y1 , $ x2 , $ y2 , $ r ) { echo " The ▁ shortest ▁ distance ▁ between ▁ a ▁ point ▁ and ▁ a ▁ circle ▁ is ▁ " , sqrt ( ( pow ( ( $ x2 - $ x1 ) , 2 ) ) + ( pow ( ( $ y2 - $ y1 ) , 2 ) ) ) - $ r ; }
Hyp: 
function dist ( $ x1 , $ y1 , $ x2 , $ y2 , $ r ) { echo " The ▁ distance ▁ " ; echo " from ▁ the ▁ chord ▁ to ▁ centre ▁ " ; echo sqrt ( ( pow ( ( $ x2 - $ x1 ) , 2 ) ) + ( pow ( ( $ y2 - $ y1 ) , 2 ) ) ) ; }

BLEU: 70.92
Edit Sim: 51


Src: 
function midpoint ( x1 , x2 , y1 , y2 ) { document . write ( ( x1 + x2 ) / 2 + " " + ( y1 + y2 ) / 2 ) ; }
Ref: 
function midpoint ( $ x1 , $ x2 , $ y1 , $ y2 ) { echo ( ( float ) ( $ x1 + $ x2 ) / 2 . " ▁ , ▁ " . ( float ) ( $ y1 + $ y2 ) / 2 ) ; }
Hyp: 
function midpoint ( $ x1 , $ x2 , $ y1 , $ y2 ) { echo ( $ x1 + $ x2 ) / 2 ; echo ( $ y1 + $ y2 ) / 2 ; }

BLEU: 61.03
Edit Sim: 35


Src: 
function oddNumSum ( n ) { return ( n * ( 2 * n + 1 ) * ( 24 * n * n * n - 12 * n * n - 14 * n + 7 ) ) / 15 ; }
Ref: 
function oddNumSum ( $ n ) { return ( $ n * ( 2 * $ n + 1 ) * ( 24 * $ n * $ n * $ n - 12 * $ n * $ n - 14 * $ n + 7 ) ) / 15 ; }
Hyp: 
function oddNumSum ( $ n ) { return ( $ n * ( 2 * $ n + 1 ) * ( 24 * $ n * $ n * $ n - 12 * $ n * $ n - 14 * $ n + 7 ) ) / 15 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findMean ( arr , l , r ) { let sum = 0 , count = 0 ; for ( let i = l ; i <= r ; i ++ ) { sum += arr [ i ] ; count ++ ; } let mean = Math . floor ( sum / count ) ; return mean ; }
Ref: 
function findMean ( $ arr , $ l , $ r ) { $ sum = 0 ; $ count = 0 ; for ( $ i = $ l ; $ i <= $ r ; $ i ++ ) { $ sum += $ arr [ $ i ] ; $ count ++ ; } $ mean = floor ( $ sum / $ count ) ; return $ mean ; }
Hyp: 
function findMean ( $ arr , $ l , $ r ) { $ sum = 0 ; $ count = 0 ; for ( $ i = $ l ; $ i <= $ r ; $ i ++ ) { $ sum += $ arr [ $ i ] ; $ count ++ ; } $ mean = floor ( $ sum / $ count ) ; return $ mean ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function printDivisors ( n ) { for ( i = 1 ; i <= n ; i ++ ) if ( n % i == 0 ) document . write ( i + " " ) ; }
Ref: 
function printDivisors ( $ n ) { for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) if ( $ n % $ i == 0 ) echo $ i , " ▁ " ; }
Hyp: 
function printDivisors ( $ n ) { for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) if ( $ n % $ i == 0 ) echo $ i . " " ; }

BLEU: 89.83
Edit Sim: 3


Src: 
function kth ( arr1 , arr2 , m , n , k ) { var sorted1 = Array ( m + n ) . fill ( 0 ) ; var i = 0 , j = 0 , d = 0 ; while ( i < m && j < n ) { if ( arr1 [ i ] < arr2 [ j ] ) sorted1 [ d ++ ] = arr1 [ i ++ ] ; else sorted1 [ d ++ ] = arr2 [ j ++ ] ; } while ( i < m ) sorted1 [ d ++ ] = arr1 [ i ++ ] ; while ( j < n ) sorted1 [ d ++ ] = arr2 [ j ++ ] ; return sorted1 [ k - 1 ] ; }
Ref: 
function kth ( $ arr1 , $ arr2 , $ m , $ n , $ k ) { $ sorted1 [ $ m + $ n ] = 0 ; $ i = 0 ; $ j = 0 ; $ d = 0 ; while ( $ i < $ m && $ j < $ n ) { if ( $ arr1 [ $ i ] < $ arr2 [ $ j ] ) $ sorted1 [ $ d ++ ] = $ arr1 [ $ i ++ ] ; else $ sorted1 [ $ d ++ ] = $ arr2 [ $ j ++ ] ; } while ( $ i < $ m ) $ sorted1 [ $ d ++ ] = $ arr1 [ $ i ++ ] ; while ( $ j < $ n ) $ sorted1 [ $ d ++ ] = $ arr2 [ $ j ++ ] ; return $ sorted1 [ $ k - 1 ] ; }
Hyp: 
function kth ( $ arr1 , $ arr2 , $ m , $ n , $ k ) { $ sorted1 = array ( ) ; $ i = 0 ; $ j = 0 ; $ d = 0 ; while ( $ i < $ m && $ j < $ n ) { if ( $ arr1 [ $ i ] < $ arr2 [ $ j ] ) $ sorted1 [ $ d ++ ] = $ arr1 [ $ i ++ ] ; else $ sorted1 [ $ d ++ ] = $ arr2 [ $ j ++ ] ; } while ( $ i < $ m ) $ sorted1 [ $ d ++ ] = $ arr1 [ $ i ++ ] ; while ( $ j < $ n ) $ sorted1 [ $ d ++ ] = $ arr2 [ $ j ++ ] ; return $ sorted1 [ $ k - 1 ] ; }

BLEU: 93.91
Edit Sim: 14


Src: 
function MaximumPath ( Mat ) { let result = 0 ; let dp = new Array ( N ) ; for ( let i = 0 ; i < N ; i ++ ) { dp [ i ] = new Array ( N + 2 ) ; for ( let j = 0 ; j < N + 2 ; j ++ ) { dp [ i ] [ j ] = 0 ; } } for ( let i = 0 ; i < N ; i ++ ) dp [ 0 ] [ i + 1 ] = Mat [ 0 ] [ i ] ; for ( let i = 1 ; i < N ; i ++ ) for ( let j = 1 ; j <= N ; j ++ ) dp [ i ] [ j ] = Math . max ( dp [ i - 1 ] [ j - 1 ] , Math . max ( dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ j + 1 ] ) ) + Mat [ i ] [ j - 1 ] ; for ( let i = 0 ; i <= N ; i ++ ) result = Math . max ( result , dp [ N - 1 ] [ i ] ) ; return result ; }
Ref: 
function MaximumPath ( & $ Mat ) { global $ N ; $ result = 0 ; $ dp = array_fill ( 0 , $ N , array_fill ( 0 , $ N + 2 , NULL ) ) ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) $ dp [ 0 ] [ $ i + 1 ] = $ Mat [ 0 ] [ $ i ] ; for ( $ i = 1 ; $ i < $ N ; $ i ++ ) for ( $ j = 1 ; $ j <= $ N ; $ j ++ ) $ dp [ $ i ] [ $ j ] = max ( $ dp [ $ i - 1 ] [ $ j - 1 ] , max ( $ dp [ $ i - 1 ] [ $ j ] , $ dp [ $ i - 1 ] [ $ j + 1 ] ) ) + $ Mat [ $ i ] [ $ j - 1 ] ; for ( $ i = 0 ; $ i <= $ N ; $ i ++ ) $ result = max ( $ result , $ dp [ $ N - 1 ] [ $ i ] ) ; return $ result ; }
Hyp: 
function MaximumPath ( $ Mat ) { $ result = 0 ; $ dp = array ( array ( ) ) ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) $ dp [ 0 ] [ $ i + 1 ] = $ Mat [ 0 ] [ $ i ] ; for ( $ i = 1 ; $ i < $ N ; $ i ++ ) for ( $ j = 1 ; $ j <= $ N ; $ j ++ ) $ dp [ $ i ] [ $ j ] = max ( $ dp [ $ i - 1 ] [ $ j - 1 ] , max ( $ dp [ $ i - 1 ] [ $ j ] , $ dp [ $ i - 1 ] [ $ j + 1 ] ) ) + $ Mat [ $ i ] [ $ j - 1 ] ; for ( $ i = 0 ; $ i <= $ N ; $ i ++ ) $ result = max ( $ result , $ dp [ $ N - 1 ] [ $ i ] ) ; return $ result ; }

BLEU: 88.36
Edit Sim: 54


Src: 
function spellsCount ( num ) { let n = num . length ; let result = 1 ; for ( let i = 0 ; i < n ; i ++ ) { let count = 1 ; while ( i < n - 1 && num [ i + 1 ] == num [ i ] ) { count ++ ; i ++ ; } result = result * Math . pow ( 2 , count - 1 ) ; } return result ; }
Ref: 
function spellsCount ( $ num ) { $ n = strlen ( $ num ) ; $ result = 1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ count = 1 ; while ( $ i < $ n - 1 && $ num [ $ i + 1 ] == $ num [ $ i ] ) { $ count ++ ; $ i ++ ; } $ result = $ result * pow ( 2 , $ count - 1 ) ; } return $ result ; }
Hyp: 
function spellsCount ( $ num ) { $ n = strlen ( $ num ) ; $ result = 1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ count = 1 ; while ( $ i < $ n - 1 && $ num [ $ i + 1 ] == $ num [ $ i ] ) { $ count ++ ; $ i ++ ; } $ result = $ result * pow ( 2 , $ count - 1 ) ; } return $ result ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countWaysToJump ( arr , n ) { let count_jump = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { count_jump [ i ] = 0 ; } for ( let i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] >= n - i - 1 ) count_jump [ i ] ++ ; for ( let j = i + 1 ; j < n - 1 && j <= arr [ i ] + i ; j ++ ) if ( count_jump [ j ] != - 1 ) count_jump [ i ] += count_jump [ j ] ; if ( count_jump [ i ] == 0 ) count_jump [ i ] = - 1 ; } for ( let i = 0 ; i < n ; i ++ ) document . write ( count_jump [ i ] + " " ) ; }
Ref: 
function countWaysToJump ( $ arr , $ n ) { $ count_jump ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ count_jump [ $ i ] = 0 ; for ( $ i = $ n - 2 ; $ i >= 0 ; $ i -- ) { if ( $ arr [ $ i ] >= $ n - $ i - 1 ) $ count_jump [ $ i ] ++ ; for ( $ j = $ i + 1 ; $ j < $ n - 1 && $ j <= $ arr [ $ i ] + $ i ; $ j ++ ) if ( $ count_jump [ $ j ] != -1 ) $ count_jump [ $ i ] += $ count_jump [ $ j ] ; if ( $ count_jump [ $ i ] == 0 ) $ count_jump [ $ i ] = -1 ; } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ count_jump [ $ i ] . " ▁ " ; }
Hyp: 
function countWaysToJump ( $ arr , $ n ) { $ count_jump = array_fill ( 0 , $ n , 0 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ count_jump [ $ i ] = 0 ; for ( $ i = $ n - 2 ; $ i >= 0 ; $ i -- ) { if ( $ arr [ $ i ] >= $ n - $ i - 1 ) $ count_jump [ $ i ] ++ ; for ( $ j = $ i + 1 ; $ j < $ n - 1 && $ j <= $ arr [ $ i ] + $ i ; $ j ++ ) if ( $ count_jump [ $ j ] != -1 ) $ count_jump [ $ i ] += $ count_jump [ $ j ] ; if ( $ count_jump [ $ i ] == 0 ) $ count_jump [ $ i ] = -1 ; } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ count_jump [ $ i ] , " ▁ " ; }

BLEU: 93.14
Edit Sim: 30


Src: 
function countIslands ( mat , m , n ) { let count = 0 ; for ( let i = 0 ; i < m ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { if ( mat [ i ] [ j ] == ' ' ) { if ( ( i == 0 mat [ i - 1 ] [ j ] == ' ' ) && ( j == 0 mat [ i ] [ j - 1 ] == ' ' ) ) count ++ ; } } } return count ; }
Ref: 
function countIslands ( $ mat ) { $ M = 6 ; $ N = 3 ; $ count = 0 ; for ( $ i = 0 ; $ i < $ M ; $ i ++ ) { for ( $ j = 0 ; $ j < $ N ; $ j ++ ) { if ( $ mat [ $ i ] [ $ j ] == ' X ' ) { if ( ( $ i == 0 $ mat [ $ i - 1 ] [ $ j ] == ' O ' ) && ( $ j == 0 $ mat [ $ i ] [ $ j - 1 ] == ' O ' ) ) $ count ++ ; } } } return $ count ; }
Hyp: 
function countIslands ( $ mat , $ m , $ n ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ m ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ mat [ $ i ] [ $ j ] == '1' ) { if ( ( $ i == 0 $ mat [ $ i - 1 ] [ $ j ] == '2' ) && ( $ j == 0 $ mat [ $ i ] [ $ j - 1 ] == '1' ) ) $ count ++ ; } } } return $ count ; }

BLEU: 77.17
Edit Sim: 25


Src: 
function sum ( a , n ) { let maxSum = Number . MIN_VALUE ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = i + 1 ; j < n ; j ++ ) maxSum = Math . max ( maxSum , a [ i ] + a [ j ] ) ; let c = 0 ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = i + 1 ; j < n ; j ++ ) if ( a [ i ] + a [ j ] == maxSum ) c ++ ; return c ; }
Ref: 
function sum ( $ a , $ n ) { $ maxSum = PHP_INT_MIN ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) $ maxSum = max ( $ maxSum , $ a [ $ i ] + $ a [ $ j ] ) ; $ c = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) if ( $ a [ $ i ] + $ a [ $ j ] == $ maxSum ) $ c ++ ; return $ c ; }
Hyp: 
function sum ( $ a , $ n ) { $ maxSum = PHP_INT_MIN ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) $ maxSum = max ( $ maxSum , $ a [ $ i ] + $ a [ $ j ] ) ; $ c = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) if ( $ a [ $ i ] + $ a [ $ j ] == $ maxSum ) $ c ++ ; return $ c ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function minimumX ( n , k ) { let mini = Number . MAX_VALUE ; for ( let i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { let fir = i ; let sec = parseInt ( n / i , 10 ) ; let num1 = fir * k + sec ; let res = parseInt ( ( num1 / k ) , 10 ) * ( num1 % k ) ; if ( res == n ) mini = Math . min ( num1 , mini ) ; let num2 = sec * k + fir ; res = parseInt ( ( num2 / k ) , 10 ) * ( num2 % k ) ; if ( res == n ) mini = Math . min ( num2 , mini ) ; } } return mini ; }
Ref: 
function minimumX ( $ n , $ k ) { $ mini = PHP_INT_MAX ; for ( $ i = 1 ; $ i * $ i <= $ n ; $ i ++ ) { if ( $ n % $ i == 0 ) { $ fir = $ i ; $ sec = ( int ) $ n / $ i ; $ num1 = $ fir * $ k + $ sec ; $ res = ( int ) ( $ num1 / $ k ) * ( $ num1 % $ k ) ; if ( $ res == $ n ) $ mini = min ( $ num1 , $ mini ) ; $ num2 = $ sec * $ k + $ fir ; $ res = ( int ) ( $ num2 / $ k ) * ( $ num2 % $ k ) ; if ( $ res == $ n ) $ mini = min ( $ num2 , $ mini ) ; } } return $ mini ; }
Hyp: 
function minimumX ( $ n , $ k ) { $ mini = PHP_INT_MAX ; for ( $ i = 1 ; $ i * $ i <= $ n ; $ i ++ ) { if ( $ n % $ i == 0 ) { $ fir = $ i ; $ sec = ( int ) ( $ n / $ i ) ; $ num1 = $ fir * $ k + $ sec ; $ res = ( int ) ( ( $ num1 / $ k ) , 10 ) * ( $ num1 % $ k ) ; if ( $ res == $ n ) $ mini = min ( $ num1 , $ mini ) ; $ num2 = $ sec * $ k + $ fir ; $ res = ( int ) ( ( $ num2 / $ k ) , 10 ) * ( $ num2 % $ k ) ; if ( $ res == $ n ) $ mini = min ( $ num2 , $ mini ) ; } } return $ mini ; }

BLEU: 91.76
Edit Sim: 22


Src: 
function findMinAvgSubarray ( arr , n , k ) { if ( n < k ) return ; let res_index = 0 ; let curr_sum = 0 ; for ( let i = 0 ; i < k ; i ++ ) curr_sum += arr [ i ] ; let min_sum = curr_sum ; for ( let i = k ; i < n ; i ++ ) { curr_sum += arr [ i ] - arr [ i - k ] ; if ( curr_sum < min_sum ) { min_sum = curr_sum ; res_index = ( i - k + 1 ) ; } } document . write ( " " + res_index + " " + ( res_index + k - 1 ) + " " ) ; }
Ref: 
function findMinAvgSubarray ( $ arr , $ n , $ k ) { if ( $ n < $ k ) return ; $ res_index = 0 ; $ curr_sum = 0 ; for ( $ i = 0 ; $ i < $ k ; $ i ++ ) $ curr_sum += $ arr [ $ i ] ; $ min_sum = $ curr_sum ; for ( $ i = $ k ; $ i < $ n ; $ i ++ ) { $ curr_sum += $ arr [ $ i ] - $ arr [ $ i - $ k ] ; if ( $ curr_sum < $ min_sum ) { $ min_sum = $ curr_sum ; $ res_index = ( $ i - $ k + 1 ) ; } } echo " Subarray between [ " ▁ , $ res _ index ▁ , ▁ " , " ▁ , $ res _ index ▁ + ▁ $ k ▁ - ▁ 1 , ▁ " ] has minimum average " ; }
Hyp: 
function findMinAvgSubarray ( $ arr , $ n , $ k ) { if ( $ n < $ k ) return ; $ res_index = 0 ; $ curr_sum = 0 ; for ( $ i = 0 ; $ i < $ k ; $ i ++ ) $ curr_sum += $ arr [ $ i ] ; $ min_sum = $ curr_sum ; for ( $ i = $ k ; $ i < $ n ; $ i ++ ) { $ curr_sum += $ arr [ $ i ] - $ arr [ $ i - $ k ] ; if ( $ curr_sum < $ min_sum ) { $ min_sum = $ curr_sum ; $ res_index = ( $ i - $ k + 1 ) ; } } echo " Minimum ▁ average ▁ is ▁ " , $ res_index , " STRNEWLINE " ; }

BLEU: 78.74
Edit Sim: 83


Src: 
function circle ( x1 , y1 , x2 , y2 , r1 , r2 ) { let distSq = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ; let radSumSq = ( r1 + r2 ) * ( r1 + r2 ) ; if ( distSq == radSumSq ) return 1 ; else if ( distSq > radSumSq ) return - 1 ; else return 0 ; }
Ref: 
function circle ( $ x1 , $ y1 , $ x2 , $ y2 , $ r1 , $ r2 ) { $ distSq = ( $ x1 - $ x2 ) * ( $ x1 - $ x2 ) + ( $ y1 - $ y2 ) * ( $ y1 - $ y2 ) ; $ radSumSq = ( $ r1 + $ r2 ) * ( $ r1 + $ r2 ) ; if ( $ distSq == $ radSumSq ) return 1 ; else if ( $ distSq > $ radSumSq ) return -1 ; else return 0 ; }
Hyp: 
function circle ( $ x1 , $ y1 , $ x2 , $ y2 , $ r1 , $ r2 ) { $ distSq = ( $ x1 - $ x2 ) * ( $ x1 - $ x2 ) + ( $ y1 - $ y2 ) * ( $ y1 - $ y2 ) ; $ radSumSq = ( $ r1 + $ r2 ) * ( $ r1 + $ r2 ) ; if ( $ distSq == $ radSumSq ) return 1 ; else if ( $ distSq > $ radSumSq ) return -1 ; else return 0 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function isDivisibleBy25 ( str ) { n = str . length ; if ( n == 1 ) return false ; return ( ( str [ n - 1 ] - ' ' == 0 && str [ n - 2 ] - ' ' == 0 ) || ( ( str [ n - 2 ] - ' ' ) * 10 + ( str [ n - 1 ] - ' ' ) ) % 25 == 0 ) ; }
Ref: 
function isDivisibleBy25 ( $ str ) { $ n = strlen ( $ str ) ; if ( $ n == 1 ) return false ; return ( ( $ str [ $ n - 1 ] - '0' == 0 && $ str [ $ n - 2 ] - '0' == 0 ) || ( ( $ str [ $ n - 2 ] - '0' ) * 10 + ( $ str [ $ n - 1 ] - '0' ) ) % 25 == 0 ) ; }
Hyp: 
function isDivisibleBy25 ( $ str ) { $ n = strlen ( $ str ) ; if ( $ n == 1 ) return false ; return ( ( $ str [ $ n - 1 ] - '0' == 0 && $ str [ $ n - 2 ] - '0' == 0 ) || ( ( $ str [ $ n - 2 ] - '0' ) * 10 + ( $ str [ $ n - 1 ] - '0' ) ) % 25 == 0 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function Minsteps ( n , m ) { let ans = 0 ; while ( m > n ) { if ( m & 1 ) { m ++ ; ans ++ ; } m = Math . floor ( m / 2 ) ; ans ++ ; } return ans + n - m ; }
Ref: 
function Minsteps ( $ n , $ m ) { $ ans = 0 ; while ( $ m > $ n ) { if ( $ m % 2 != 0 ) { $ m ++ ; $ ans ++ ; } $ m /= 2 ; $ ans ++ ; } return $ ans + $ n - $ m ; }
Hyp: 
function Minsteps ( $ n , $ m ) { $ ans = 0 ; while ( $ m > $ n ) { if ( $ m & 1 ) { $ m ++ ; $ ans ++ ; } $ m = ( int ) ( $ m / 2 ) ; $ ans ++ ; } return $ ans + $ n - $ m ; }

BLEU: 78.61
Edit Sim: 26


Src: 
function CheckArray ( arr , n ) { let prod = 1 ; for ( let i = 0 ; i < n ; ++ i ) prod *= arr [ i ] ; for ( let i = 0 ; i < n ; ++ i ) if ( arr [ i ] == prod / arr [ i ] ) return true ; return false ; }
Ref: 
function CheckArray ( $ arr , $ n ) { $ prod = 1 ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) $ prod *= $ arr [ $ i ] ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) if ( $ arr [ $ i ] == $ prod / $ arr [ $ i ] ) return true ; return false ; }
Hyp: 
function CheckArray ( $ arr , $ n ) { $ prod = 1 ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) $ prod *= $ arr [ $ i ] ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) if ( $ arr [ $ i ] == $ prod / $ arr [ $ i ] ) return true ; return false ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function AND ( a , n ) { let ans = a [ 0 ] ; for ( let i = 0 ; i < n ; ++ i ) ans &= a [ i ] ; return ans ; }
Ref: 
function ANDS ( & $ a , $ n ) { $ ans = $ a [ 0 ] ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) $ ans &= $ a [ $ i ] ; return $ ans ; }
Hyp: 
function AND ( $ a , $ n ) { $ ans = $ a [ 0 ] ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) $ ans &= $ a [ $ i ] ; return $ ans ; }

BLEU: 93.16
Edit Sim: 3


Src: 
function nondecdigits ( n ) { let x = 0 ; for ( x = n ; x >= 1 ; x -- ) { let no = x ; let prev_dig = 11 ; let flag = true ; while ( no != 0 ) { if ( prev_dig < no % 10 ) { flag = false ; break ; } prev_dig = no % 10 ; no = Math . floor ( no / 10 ) ; } if ( flag == true ) break ; } return x ; }
Ref: 
function nondecdigits ( $ n ) { $ x = 0 ; for ( $ x = $ n ; $ x >= 1 ; $ x -- ) { $ no = $ x ; $ prev_dig = 11 ; $ flag = true ; while ( $ no != 0 ) { if ( $ prev_dig < $ no % 10 ) { $ flag = false ; break ; } $ prev_dig = $ no % 10 ; $ no /= 10 ; } if ( $ flag == true ) break ; } return $ x ; }
Hyp: 
function nondecdigits ( $ n ) { $ x = 0 ; for ( $ x = $ n ; $ x >= 1 ; $ x -- ) { $ no = $ x ; $ prev_dig = 11 ; $ flag = true ; while ( $ no != 0 ) { if ( $ prev_dig < $ no % 10 ) { $ flag = false ; break ; } $ prev_dig = $ no % 10 ; $ no = ( int ) $ no / 10 ; } if ( $ flag == true ) break ; } return $ x ; }

BLEU: 92.07
Edit Sim: 16


Src: 
function Loss ( SP , P ) { var loss = 0 ; loss = ( 2 * P * P * SP ) / ( 100 * 100 - P * P ) ; document . write ( " " + loss . toFixed ( 3 ) ) ; }
Ref: 
function Loss ( $ SP , $ P ) { $ loss = 0 ; $ loss = ( ( 2 * $ P * $ P * $ SP ) / ( 100 * 100 - $ P * $ P ) ) ; print ( " Loss ▁ = ▁ " . round ( $ loss , 3 ) ) ; }
Hyp: 
function Loss ( $ SP , $ P ) { $ loss = 0 ; $ loss = ( 2 * $ P * $ P * $ SP ) / ( 100 * 100 - $ P * $ P ) ; echo " Loss = " . $ loss ; }

BLEU: 68.29
Edit Sim: 31


Src: 
function segregateElements ( arr , n ) { let temp = new Array ( n ) ; let j = 0 ; for ( let i = 0 ; i < n ; i ++ ) if ( arr [ i ] >= 0 ) temp [ j ++ ] = arr [ i ] ; if ( j == n j == 0 ) return ; for ( let i = 0 ; i < n ; i ++ ) if ( arr [ i ] < 0 ) temp [ j ++ ] = arr [ i ] ; for ( let i = 0 ; i < n ; i ++ ) arr [ i ] = temp [ i ] ; }
Ref: 
function segregateElements ( & $ arr , $ n ) { $ temp = array ( 0 , $ n , NULL ) ; $ j = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] >= 0 ) $ temp [ $ j ++ ] = $ arr [ $ i ] ; if ( $ j == $ n $ j == 0 ) return ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] < 0 ) $ temp [ $ j ++ ] = $ arr [ $ i ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ arr [ $ i ] = $ temp [ $ i ] ; }
Hyp: 
function segregateElements ( & $ arr , $ n ) { $ temp = array ( ) ; $ j = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] >= 0 ) $ temp [ $ j ++ ] = $ arr [ $ i ] ; if ( $ j == $ n $ j == 0 ) return ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] < 0 ) $ temp [ $ j ++ ] = $ arr [ $ i ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ arr [ $ i ] = $ temp [ $ i ] ; }

BLEU: 95.26
Edit Sim: 15


Src: 
function remainingArea ( N , M , K ) { while ( K -- && N && M ) { if ( N > M ) N = N - M ; else M = M - N ; } if ( N > 0 && M > 0 ) return N * M ; else return 0 ; }
Ref: 
function remainingArea ( $ N , $ M , $ K ) { while ( $ K -- && $ N && $ M ) { if ( $ N > $ M ) $ N = $ N - $ M ; else $ M = $ M - $ N ; } if ( $ N > 0 && $ M > 0 ) return $ N * $ M ; else return 0 ; }
Hyp: 
function remainingArea ( $ N , $ M , $ K ) { while ( $ K -- && $ N && $ M ) { if ( $ N > $ M ) $ N = $ N - $ M ; else $ M = $ M - $ N ; } if ( $ N > 0 && $ M > 0 ) return $ N * $ M ; else return 0 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countCompositions ( n ) { return 1 << ( n - 1 ) ; }
Ref: 
function countCompositions ( $ n ) { return ( ( 1 ) << ( $ n - 1 ) ) ; }
Hyp: 
function countCompositions ( $ n ) { return 1 << ( $ n - 1 ) ; }

BLEU: 64.65
Edit Sim: 8


Src: 
function countConsecutive ( N ) { let count = 0 ; for ( let L = 1 ; L * ( L + 1 ) < 2 * N ; L ++ ) { let a = ( ( 1.0 * N - ( L * ( L + 1 ) ) / 2 ) / ( L + 1 ) ) ; if ( a - parseInt ( a , 10 ) == 0.0 ) count ++ ; } return count ; }
Ref: 
function countConsecutive ( $ N ) { $ count = 0 ; for ( $ L = 1 ; $ L * ( $ L + 1 ) < 2 * $ N ; $ L ++ ) { $ a = ( int ) ( 1.0 * $ N - ( $ L * ( int ) ( $ L + 1 ) ) / 2 ) / ( $ L + 1 ) ; if ( $ a - ( int ) $ a == 0.0 ) $ count ++ ; } return $ count ; }
Hyp: 
function countConsecutive ( $ N ) { $ count = 0 ; for ( $ L = 1 ; $ L * ( $ L + 1 ) < 2 * $ N ; $ L ++ ) { $ a = ( ( 1.0 * $ N - ( $ L * ( $ L + 1 ) ) / 2 ) / ( $ L + 1 ) ) ; if ( $ a - ( int ) $ a == 0.0 ) $ count ++ ; } return $ count ; }

BLEU: 91.98
Edit Sim: 16


Src: 
function areVowelsInOrder ( s ) { var n = s . length ; var c = String . fromCharCode ( 64 ) ; for ( var i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ' ' s [ i ] == ' ' s [ i ] == ' ' s [ i ] == ' ' s [ i ] == ' ' ) { if ( s [ i ] < c ) return false ; else { c = s [ i ] ; } } } return true ; }
Ref: 
function areVowelsInOrder ( $ s ) { $ n = strlen ( $ s ) ; $ c = chr ( 64 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ s [ $ i ] == ' a ' $ s [ $ i ] == ' e ' $ s [ $ i ] == ' $ i ' $ s [ $ i ] == ' o ' $ s [ $ i ] == ' u ' ) { if ( $ s [ $ i ] < $ c ) return false ; else { $ c = $ s [ $ i ] ; } } } return true ; }
Hyp: 
function areVowelsInOrder ( $ s ) { $ n = strlen ( $ s ) ; $ c = chr ( 64 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ s [ $ i ] == " ▁ " $ s [ $ i ] == " STRNEWLINE " $ s [ $ i ] == " TABSYMBOL " ) { if ( $ s [ $ i ] < $ c ) return false ; else { $ c = $ s [ $ i ] ; } } } return true ; }

BLEU: 72.36
Edit Sim: 53


Src: 
function countDer ( n ) { if ( n == 1 ) return 0 ; if ( n == 2 ) return 1 ; return ( n - 1 ) * ( countDer ( n - 1 ) + countDer ( n - 2 ) ) ; }
Ref: 
function countDer ( $ n ) { if ( $ n == 1 ) return 0 ; if ( $ n == 2 ) return 1 ; return ( $ n - 1 ) * ( countDer ( $ n - 1 ) + countDer ( $ n - 2 ) ) ; }
Hyp: 
function countDer ( $ n ) { if ( $ n == 1 ) return 0 ; if ( $ n == 2 ) return 1 ; return ( $ n - 1 ) * ( countDer ( $ n - 1 ) + countDer ( $ n - 2 ) ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function rmsValue ( arr , n ) { var square = 0 ; var mean = 0 ; var root = 0 ; for ( i = 0 ; i < n ; i ++ ) { square += Math . pow ( arr [ i ] , 2 ) ; } mean = ( square / ( n ) ) ; root = Math . sqrt ( mean ) ; return root ; }
Ref: 
function rmsValue ( $ arr , $ n ) { $ square = 0 ; $ mean = 0.0 ; $ root = 0.0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ square += pow ( $ arr [ $ i ] , 2 ) ; } $ mean = ( $ square / ( float ) ( $ n ) ) ; $ root = sqrt ( $ mean ) ; return $ root ; }
Hyp: 
function rmsValue ( $ arr , $ n ) { $ square = 0 ; $ mean = 0 ; $ root = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ square += pow ( $ arr [ $ i ] , 2 ) ; } $ mean = ( $ square / ( $ n ) ) ; $ root = sqrt ( $ mean ) ; return $ root ; }

BLEU: 89.96
Edit Sim: 14


Src: 
function solve ( low , high , T ) { while ( low <= high ) { let mid = Math . floor ( ( low + high ) / 2 ) ; if ( ( mid * ( mid + 1 ) ) == T ) return mid ; if ( mid > 0 && ( mid * ( mid + 1 ) ) > T && ( mid * ( mid - 1 ) ) <= T ) return mid - 1 ; if ( ( mid * ( mid + 1 ) ) > T ) high = mid - 1 ; else low = mid + 1 ; } return - 1 ; }
Ref: 
function solve ( $ low , $ high , $ T ) { while ( $ low <= $ high ) { $ mid = ( $ low + $ high ) / 2 ; if ( ( $ mid * ( $ mid + 1 ) ) == $ T ) return $ mid ; if ( $ mid > 0 && ( $ mid * ( $ mid + 1 ) ) > $ T && ( $ mid * ( $ mid - 1 ) ) <= $ T ) return $ mid - 1 ; if ( ( $ mid * ( $ mid + 1 ) ) > $ T ) $ high = $ mid - 1 ; else $ low = $ mid + 1 ; } return -1 ; }
Hyp: 
function solve ( $ low , $ high , $ T ) { while ( $ low <= $ high ) { $ mid = ( int ) ( ( $ low + $ high ) / 2 ) ; if ( ( $ mid * ( $ mid + 1 ) ) == $ T ) return $ mid ; if ( $ mid > 0 && ( $ mid * ( $ mid + 1 ) ) > $ T && ( $ mid * ( $ mid - 1 ) ) <= $ T ) return $ mid - 1 ; if ( ( $ mid * ( $ mid + 1 ) ) > $ T ) $ high = $ mid - 1 ; else $ low = $ mid + 1 ; } return -1 ; }

BLEU: 94.89
Edit Sim: 12


Src: 
function findN ( k ) { var ans ; if ( k == 0 ) ans = 3 ; if ( k == 1 ) ans = 1 ; else if ( k % 4 == 0 ) ans = k ; else if ( k % 4 == 3 ) ans = k - 1 ; else ans = - 1 ; return ans ; }
Ref: 
function findN ( $ k ) { $ ans ; if ( $ k == 0 ) $ ans = 3 ; if ( $ k == 1 ) $ ans = 1 ; else if ( $ k % 4 == 0 ) $ ans = $ k ; else if ( $ k % 4 == 3 ) $ ans = $ k - 1 ; else $ ans = -1 ; return $ ans ; }
Hyp: 
function findN ( $ k ) { $ ans ; if ( $ k == 0 ) $ ans = 3 ; if ( $ k == 1 ) $ ans = 1 ; else if ( $ k % 4 == 0 ) $ ans = $ k ; else if ( $ k % 4 == 3 ) $ ans = $ k - 1 ; else $ ans = -1 ; return $ ans ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function MatrixChainOrder ( p , n ) { var dp = Array . from ( Array ( n ) , ( ) => Array ( n ) ) ; for ( var i = 1 ; i < n ; i ++ ) dp [ i ] [ i ] = 0 ; for ( var L = 1 ; L < n - 1 ; L ++ ) for ( var i = 1 ; i < n - L ; i ++ ) dp [ i ] [ i + L ] = Math . min ( dp [ i + 1 ] [ i + L ] + p [ i - 1 ] * p [ i ] * p [ i + L ] , dp [ i ] [ i + L - 1 ] + p [ i - 1 ] * p [ i + L - 1 ] * p [ i + L ] ) ; return dp [ 1 ] [ n - 1 ] ; }
Ref: 
function MatrixChainOrder ( $ p , $ n ) { $ dp = array ( ) ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ dp [ $ i ] [ $ i ] = 0 ; for ( $ L = 1 ; $ L < $ n - 1 ; $ L ++ ) for ( $ i = 1 ; $ i < $ n - $ L ; $ i ++ ) $ dp [ $ i ] [ $ i + $ L ] = min ( $ dp [ $ i + 1 ] [ $ i + $ L ] + $ p [ $ i - 1 ] * $ p [ $ i ] * $ p [ $ i + $ L ] , $ dp [ $ i ] [ $ i + $ L - 1 ] + $ p [ $ i - 1 ] * $ p [ $ i + $ L - 1 ] * $ p [ $ i + $ L ] ) ; return $ dp [ 1 ] [ $ n - 1 ] ; }
Hyp: 
function MatrixChainOrder ( & $ p , $ n ) { $ dp [ 1 ] [ $ n - 1 ] = 0 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ dp [ $ i ] [ $ i ] = 0 ; for ( $ L = 1 ; $ L < $ n - 1 ; $ L ++ ) for ( $ i = 1 ; $ i < $ n - $ L ; $ i ++ ) $ dp [ $ i ] [ $ i + $ L ] = min ( $ dp [ $ i + 1 ] [ $ i + $ L ] + $ p [ $ i - 1 ] * $ p [ $ i ] * $ p [ $ i + $ L ] , $ dp [ $ i ] [ $ i + $ L - 1 ] + $ p [ $ i - 1 ] * $ p [ $ i + $ L - 1 ] * $ p [ $ i + $ L ] ) ; return $ dp [ 1 ] [ $ n - 1 ] ; }

BLEU: 93.08
Edit Sim: 20


Src: 
function superSeq ( X , Y , m , n ) { var dp = Array ( m + 1 ) . fill ( 0 ) . map ( x => Array ( n + 1 ) . fill ( 0 ) ) ; for ( var i = 0 ; i <= m ; i ++ ) { for ( var j = 0 ; j <= n ; j ++ ) { if ( i == 0 ) dp [ i ] [ j ] = j ; else if ( j == 0 ) dp [ i ] [ j ] = i ; else if ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = 1 + Math . min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) ; } } return dp [ m ] [ n ] ; }
Ref: 
function superSeq ( $ X , $ Y , $ m , $ n ) { $ dp = array_fill ( 0 , $ m + 1 , array_fill ( 0 , $ n + 1 , 0 ) ) ; for ( $ i = 0 ; $ i <= $ m ; $ i ++ ) { for ( $ j = 0 ; $ j <= $ n ; $ j ++ ) { if ( ! $ i ) $ dp [ $ i ] [ $ j ] = $ j ; else if ( ! $ j ) $ dp [ $ i ] [ $ j ] = $ i ; else if ( $ X [ $ i - 1 ] == $ Y [ $ j - 1 ] ) $ dp [ $ i ] [ $ j ] = 1 + $ dp [ $ i - 1 ] [ $ j - 1 ] ; else $ dp [ $ i ] [ $ j ] = 1 + min ( $ dp [ $ i - 1 ] [ $ j ] , $ dp [ $ i ] [ $ j - 1 ] ) ; } } return $ dp [ $ m ] [ $ n ] ; }
Hyp: 
function superSeq ( $ X , $ Y , $ m , $ n ) { $ dp [ $ m + 1 ] [ $ n + 1 ] = array ( ) ; for ( $ i = 0 ; $ i <= $ m ; $ i ++ ) { for ( $ j = 0 ; $ j <= $ n ; $ j ++ ) { if ( $ i == 0 ) $ dp [ $ i ] [ $ j ] = $ j ; else if ( $ j == 0 ) $ dp [ $ i ] [ $ j ] = $ i ; else if ( $ X == $ Y [ $ j - 1 ] ) $ dp [ $ i ] [ $ j ] = 1 + $ dp [ $ i - 1 ] [ $ j - 1 ] ; else $ dp [ $ i ] [ $ j ] = min ( $ dp [ $ i - 1 ] [ $ j ] , $ dp [ $ i ] [ $ j - 1 ] ) ; } } return $ dp [ $ m ] [ $ n ] ; }

BLEU: 84.66
Edit Sim: 69


Src: 
function sum ( n ) { if ( n < 2 ) { return 1 } else { return 1 / n + ( sum ( n - 1 ) ) } }
Ref: 
function sum ( $ n ) { if ( $ n < 2 ) return 1 ; else return 1 / $ n + ( sum ( $ n - 1 ) ) ; }
Hyp: 
function sum ( $ n ) { if ( $ n < 2 ) { return 1 } else { return 1 / $ n + ( sum ( $ n - 1 ) ) ; } }

BLEU: 79.53
Edit Sim: 7


Src: 
function arcLength ( diameter , angle ) { let pi = 22.0 / 7.0 ; let arc ; if ( angle >= 360 ) { document . write ( " " + " " ) ; return 0 ; } else { arc = ( pi * diameter ) * ( angle / 360.0 ) ; return arc ; } }
Ref: 
function arcLength ( $ diameter , $ angle ) { $ pi = 22.0 / 7.0 ; $ arc ; if ( $ angle >= 360 ) { echo " Angle ▁ cannot " , " ▁ be ▁ formed " ; return 0 ; } else { $ arc = ( $ pi * $ diameter ) * ( $ angle / 360.0 ) ; return $ arc ; } }
Hyp: 
function arcLength ( $ diameter , $ angle ) { $ pi = 22.0 / 7.0 ; $ arc ; if ( $ angle >= 360 ) { echo " Invalid ▁ angle ▁ " ; return 0 ; } else { $ arc = ( $ pi * $ diameter ) * ( $ angle / 360.0 ) ; return $ arc ; } }

BLEU: 84.25
Edit Sim: 26


Src: 
function printRepeating ( arr , size ) { var i ; document . write ( " " ) ; for ( i = 0 ; i < size ; i ++ ) { if ( arr [ Math . abs ( arr [ i ] ) ] > 0 ) arr [ Math . abs ( arr [ i ] ) ] = - arr [ Math . abs ( arr [ i ] ) ] ; else document . write ( Math . abs ( arr [ i ] ) + " " ) ; } }
Ref: 
function printRepeating ( $ arr , $ size ) { $ i ; echo " The ▁ repeating ▁ elements ▁ are " , " ▁ " ; for ( $ i = 0 ; $ i < $ size ; $ i ++ ) { if ( $ arr [ abs ( $ arr [ $ i ] ) ] > 0 ) $ arr [ abs ( $ arr [ $ i ] ) ] = - $ arr [ abs ( $ arr [ $ i ] ) ] ; else echo abs ( $ arr [ $ i ] ) , " ▁ " ; } }
Hyp: 
function printRepeating ( & $ arr , $ size ) { echo " Repeating ▁ with ▁ diagonals ▁ " ; for ( $ i = 0 ; $ i < $ size ; $ i ++ ) { if ( $ arr [ abs ( $ arr [ $ i ] ) ] > 0 ) $ arr [ abs ( $ arr [ $ i ] ) ] = - $ arr [ abs ( $ arr [ $ i ] ) ] ; else echo abs ( $ arr [ $ i ] ) . " ▁ " ; } }

BLEU: 82.26
Edit Sim: 32


Src: 
function isPerfectSquare ( x ) { if ( x >= 0 ) { let sr = Math . sqrt ( x ) ; return ( ( sr * sr ) == x ) ; } return false ; }
Ref: 
function isPerfectSquare ( $ x ) { $ sr = sqrt ( $ x ) ; return ( ( $ sr - floor ( $ sr ) ) == 0 ) ; }
Hyp: 
function isPerfectSquare ( $ x ) { if ( $ x >= 0 ) { $ sr = sqrt ( $ x ) ; return ( ( $ sr * $ sr ) == $ x ) ; } return false ; }

BLEU: 57.45
Edit Sim: 43


Src: 
function countSeq ( n ) { let nCr = 1 , res = 1 ; for ( let r = 1 ; r <= n ; r ++ ) { nCr = ( nCr * ( n + 1 - r ) ) / r ; res += nCr * nCr ; } return res ; }
Ref: 
function countSeq ( $ n ) { $ nCr = 1 ; $ res = 1 ; for ( $ r = 1 ; $ r <= $ n ; $ r ++ ) { $ nCr = ( $ nCr * ( $ n + 1 - $ r ) ) / $ r ; $ res = $ res + ( $ nCr * $ nCr ) ; } return $ res ; }
Hyp: 
function countSeq ( $ n ) { $ nCr = 1 ; $ res = 1 ; for ( $ r = 1 ; $ r <= $ n ; $ r ++ ) { $ nCr = ( $ nCr * ( $ n + 1 - $ r ) ) / $ r ; $ res += $ nCr * $ nCr ; } return $ res ; }

BLEU: 87.81
Edit Sim: 12


Src: 
function maxArea ( A , len ) { let l = 0 ; let r = len - 1 ; let area = 0 ; while ( l < r ) { area = Math . max ( area , Math . min ( A [ l ] , A [ r ] ) * ( r - l ) ) ; if ( A [ l ] < A [ r ] ) l += 1 ; else r -= 1 ; } return area ; }
Ref: 
function maxArea ( $ A , $ len ) { $ l = 0 ; $ r = $ len - 1 ; $ area = 0 ; while ( $ l < $ r ) { $ area = max ( $ area , min ( $ A [ $ l ] , $ A [ $ r ] ) * ( $ r - $ l ) ) ; if ( $ A [ $ l ] < $ A [ $ r ] ) $ l += 1 ; else $ r -= 1 ; } return $ area ; }
Hyp: 
function maxArea ( $ A , $ len ) { $ l = 0 ; $ r = $ len - 1 ; $ area = 0 ; while ( $ l < $ r ) { $ area = max ( $ area , min ( $ A [ $ l ] , $ A [ $ r ] ) * ( $ r - $ l ) ) ; if ( $ A [ $ l ] < $ A [ $ r ] ) $ l += 1 ; else $ r -= 1 ; } return $ area ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findPairCount ( N , K ) { var count = 0 ; var rem = Array . from ( { length : K } , ( _ , i ) => 0 ) ; rem [ 0 ] = parseInt ( N / K ) ; for ( i = 1 ; i < K ; i ++ ) rem [ i ] = parseInt ( ( N - i ) / K + 1 ) ; if ( K % 2 == 0 ) { count += parseInt ( ( rem [ 0 ] * ( rem [ 0 ] - 1 ) ) / 2 ) ; for ( i = 1 ; i < K / 2 ; i ++ ) count += rem [ i ] * rem [ K - i ] ; count += ( rem [ K / 2 ] * ( rem [ K / 2 ] - 1 ) ) / 2 ; } else { count += ( rem [ 0 ] * ( rem [ 0 ] - 1 ) ) / 2 ; for ( i = 1 ; i <= K / 2 ; i ++ ) count += rem [ i ] * rem [ K - i ] ; } return count ; }
Ref: 
function findPairCount ( $ N , $ K ) { $ count = 0 ; $ rem = array ( 0 , $ K , NULL ) ; $ rem [ 0 ] = intval ( $ N / $ K ) ; for ( $ i = 1 ; $ i < $ K ; $ i ++ ) $ rem [ $ i ] = intval ( ( $ N - $ i ) / $ K ) + 1 ; if ( $ K % 2 == 0 ) { $ count += ( $ rem [ 0 ] * intval ( ( $ rem [ 0 ] - 1 ) ) / 2 ) ; for ( $ i = 1 ; $ i < intval ( $ K / 2 ) ; $ i ++ ) $ count += $ rem [ $ i ] * $ rem [ $ K - $ i ] ; $ count += ( $ rem [ intval ( $ K / 2 ) ] * intval ( ( $ rem [ intval ( $ K / 2 ) ] - 1 ) ) / 2 ) ; } else { $ count += ( $ rem [ 0 ] * intval ( ( $ rem [ 0 ] - 1 ) ) / 2 ) ; for ( $ i = 1 ; $ i <= intval ( $ K / 2 ) ; $ i ++ ) $ count += $ rem [ $ i ] * $ rem [ $ K - $ i ] ; } return $ count ; }
Hyp: 
function findPairCount ( $ N , $ K ) { $ count = 0 ; $ rem = array ( ) ; $ rem [ 0 ] = $ N / $ K ; for ( $ i = 1 ; $ i < $ K ; $ i ++ ) $ rem [ $ i ] = ( $ N - $ i ) / $ K + 1 ; if ( $ K % 2 == 0 ) { $ count += ( $ rem [ 0 ] * ( $ rem [ 0 ] - 1 ) ) / 2 ; for ( $ i = 1 ; $ i < $ K / 2 ; $ i ++ ) $ count += $ rem [ $ i ] * $ rem [ $ K - $ i ] ; $ count += ( $ rem [ $ K / 2 ] * ( $ rem [ $ K / 2 ] - 1 ) ) / 2 ; } else { $ count += ( $ rem [ 0 ] * ( $ rem [ 0 ] - 1 ) ) / 2 ; for ( $ i = 1 ; $ i <= $ K / 2 ; $ i ++ ) $ count += $ rem [ $ i ] * $ rem [ $ K - $ i ] ; } return $ count ; }

BLEU: 76.72
Edit Sim: 114


Src: 
function getMaxOnes ( n , x ) { let zeroes = parseInt ( n / x , 10 ) ; zeroes = zeroes * zeroes ; let total = n * n ; let ans = total - zeroes ; return ans ; }
Ref: 
function getMaxOnes ( $ n , $ x ) { $ zeroes = ( int ) ( $ n / $ x ) ; $ zeroes = $ zeroes * $ zeroes ; $ total = $ n * $ n ; $ ans = $ total - $ zeroes ; return $ ans ; }
Hyp: 
function getMaxOnes ( $ n , $ x ) { $ zeroes = ( int ) ( $ n / $ x ) ; $ zeroes = $ zeroes * $ zeroes ; $ total = $ n * $ n ; $ ans = $ total - $ zeroes ; return $ ans ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function SquareCube ( N ) { let cnt = 0 , i = 1 ; while ( Math . floor ( Math . pow ( i , 6 ) ) <= N ) { ++ cnt ; ++ i ; } return cnt ; }
Ref: 
function SquareCube ( $ N ) { $ cnt = 0 ; $ i = 1 ; while ( ( pow ( $ i , 6 ) ) <= $ N ) { ++ $ cnt ; ++ $ i ; } return $ cnt ; }
Hyp: 
function SquareCube ( $ N ) { $ cnt = 0 ; $ i = 1 ; while ( pow ( $ i , 6 ) ) <= $ N ) { ++ $ cnt ; ++ $ i ; } return $ cnt ; }

BLEU: 96.18
Edit Sim: 2


Src: 
function subtract ( A , B , C ) { var i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < N ; j ++ ) C [ i ] [ j ] = A [ i ] [ j ] - B [ i ] [ j ] ; } var A = [ [ 1 , 1 , 1 , 1 ] , [ 2 , 2 , 2 , 2 ] , [ 3 , 3 , 3 , 3 ] , [ 4 , 4 , 4 , 4 ] ] ; var B = [ [ 1 , 1 , 1 , 1 ] , [ 2 , 2 , 2 , 2 ] , [ 3 , 3 , 3 , 3 ] , [ 4 , 4 , 4 , 4 ] ] ; var C = Array . from ( Array ( N ) , ( ) => Array ( N ) ) ; var i , j ; subtract ( A , B , C ) ; document . write ( " " + " " ) ; for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < N ; j ++ ) document . write ( C [ i ] [ j ] + " " ) ; document . write ( " " ) ; }
Ref: 
function subtract ( & $ A , & $ B , & $ C ) { $ N = 4 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) for ( $ j = 0 ; $ j < $ N ; $ j ++ ) $ C [ $ i ] [ $ j ] = $ A [ $ i ] [ $ j ] - $ B [ $ i ] [ $ j ] ; } $ N = 4 ; $ A = array ( array ( 1 , 1 , 1 , 1 ) , array ( 2 , 2 , 2 , 2 ) , array ( 3 , 3 , 3 , 3 ) , array ( 4 , 4 , 4 , 4 ) ) ; $ B = array ( array ( 1 , 1 , 1 , 1 ) , array ( 2 , 2 , 2 , 2 ) , array ( 3 , 3 , 3 , 3 ) , array ( 4 , 4 , 4 , 4 ) ) ; subtract ( $ A , $ B , $ C ) ; echo " Result ▁ matrix ▁ is ▁ STRNEWLINE " ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { for ( $ j = 0 ; $ j < $ N ; $ j ++ ) { echo $ C [ $ i ] [ $ j ] ; echo " ▁ " ; } echo " STRNEWLINE " ; }
Hyp: 
function subtract ( $ A , $ B , $ C ) { for ( $ i = 0 ; $ i < $ N ; $ i ++ ) for ( $ j = 0 ; $ j < $ N ; $ j ++ ) $ C [ $ i ] [ $ j ] = $ A [ $ i ] [ $ j ] - $ B [ $ i ] [ $ j ] ; } $ A = array ( array ( 1 , 1 , 1 , 1 ) , array ( 2 , 2 , 2 , 2 ) , array ( 3 , 3 , 3 , 3 ) , array ( 4 , 4 , 4 , 4 ) ) ; $ B = array ( array ( 1 , 1 , 1 , 1 ) , array ( 2 , 2 , 2 , 2 ) , array ( 3 , 3 , 3 , 3 ) , array ( 4 , 4 , 4 , 4 ) ) ; $ N = 4 ; subtract ( $ A , $ B , $ C ) ; echo " Result ▁ matrix ▁ is ▁ STRNEWLINE " ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { for ( $ j = 0 ; $ j < $ N ; $ j ++ ) { echo $ C [ $ i ] [ $ j ] ; echo " ▁ " ; } echo " STRNEWLINE " ; }

BLEU: 93.86
Edit Sim: 36


Src: 
function findPieces ( n ) { return ( n * ( n + 1 ) ) / 2 + 1 ; }
Ref: 
function findPieces ( $ n ) { return ( $ n * ( $ n + 1 ) ) / 2 + 1 ; }
Hyp: 
function findPieces ( $ n ) { return ( $ n * ( $ n + 1 ) ) / 2 + 1 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countSubStr ( str , len , k ) { let count = 0 ; for ( let i = 0 ; i < len ; i ++ ) { let n = 0 ; for ( let j = i ; j < len ; j ++ ) { n = n * 10 + ( str [ j ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ) ; if ( n % k == 0 ) count ++ ; } } return count ; }
Ref: 
function countSubStr ( $ str , $ len , $ k ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { $ n = 0 ; for ( $ j = $ i ; $ j < $ len ; $ j ++ ) { $ n = $ n * 10 + ( $ str [ $ j ] - '0' ) ; if ( $ n % $ k == 0 ) $ count ++ ; } } return $ count ; }
Hyp: 
function countSubStr ( $ str , $ len , $ k ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { $ n = 0 ; for ( $ j = $ i ; $ j < $ len ; $ j ++ ) { $ n = $ n * 10 + ( ord ( $ str [ $ j ] ) - ord ( '0' ) ) ; if ( $ n % $ k == 0 ) $ count ++ ; } } return $ count ; }

BLEU: 90.93
Edit Sim: 16


Src: 
function centered_cube ( n ) { return ( 2 * n + 1 ) * ( n * n + n + 1 ) ; }
Ref: 
function centered_cube ( $ n ) { return ( 2 * $ n + 1 ) * ( $ n * $ n + $ n + 1 ) ; }
Hyp: 
function centered_cube ( $ n ) { return ( 2 * $ n + 1 ) * ( $ n * $ n + $ n + 1 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function squareSum ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) sum += ( 2 * i ) * ( 2 * i ) ; return sum ; }
Ref: 
function squareSum ( $ n ) { return 2 * $ n * ( $ n + 1 ) * ( 2 * $ n + 1 ) / 3 ; }
Hyp: 
function squareSum ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ sum += ( 2 * $ i ) * ( 2 * $ i ) ; return $ sum ; }

BLEU: 27.54
Edit Sim: 65


Src: 
function validQuadruple ( arr , n ) { if ( n >= MAX ) return true ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = i + 1 ; j < n ; j ++ ) for ( let k = j + 1 ; k < n ; k ++ ) for ( let l = k + 1 ; l < n ; l ++ ) { if ( ( arr [ i ] ^ arr [ j ] ^ arr [ k ] ^ arr [ l ] ) == 0 ) { return true ; } } return false ; }
Ref: 
function validQuadruple ( $ arr , $ n ) { if ( $ n >= MAX ) return true ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) for ( $ k = $ j + 1 ; $ k < $ n ; $ k ++ ) for ( $ l = $ k + 1 ; $ l < $ n ; $ l ++ ) { if ( ( $ arr [ $ i ] ^ $ arr [ $ j ] ^ $ arr [ $ k ] ^ $ arr [ $ l ] ) == 0 ) { return true ; } } return false ; }
Hyp: 
function validQuadruple ( & $ arr , $ n ) { global $ MAX ; if ( $ n >= $ MAX ) return true ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) for ( $ k = $ j + 1 ; $ k < $ n ; $ k ++ ) for ( $ l = $ k + 1 ; $ l < $ n ; $ l ++ ) { if ( ( $ arr [ $ i ] ^ $ arr [ $ j ] ^ $ arr [ $ k ] ^ $ arr [ $ l ] ) == 0 ) { return true ; } } return false ; }

BLEU: 92.83
Edit Sim: 19


Src: 
function minSumPath ( ) { let memo = [ ] ; let n = A . length - 1 ; for ( let i = 0 ; i < A [ n ] . length ; i ++ ) memo [ i ] = A [ n ] [ i ] ; for ( let i = A . length - 2 ; i >= 0 ; i -- ) for ( let j = 0 ; j < A [ i ] . length ; j ++ ) memo [ j ] = A [ i ] [ j ] + Math . min ( memo [ j ] , memo [ j + 1 ] ) ; return memo [ 0 ] ; }
Ref: 
function minSumPath ( & $ A ) { $ memo = array ( ) ; for ( $ i = 0 ; $ i < count ( $ A ) ; $ i ++ ) $ memo [ $ i ] = 0 ; $ n = count ( $ A ) - 1 ; for ( $ i = 0 ; $ i < count ( $ A [ $ n ] ) ; $ i ++ ) $ memo [ $ i ] = $ A [ $ n ] [ $ i ] ; for ( $ i = count ( $ A ) - 2 ; $ i >= 0 ; $ i -- ) for ( $ j = 0 ; $ j < count ( $ A [ $ i + 1 ] ) - 1 ; $ j ++ ) $ memo [ $ j ] = $ A [ $ i ] [ $ j ] + min ( $ memo [ $ j ] , $ memo [ $ j + 1 ] ) ; return $ memo [ 0 ] ; }
Hyp: 
function minSumPath ( $ A ) { $ memo = array ( ) ; $ n = count ( $ A ) ; for ( $ i = 0 ; $ i < $ A [ $ n ] . length ; $ i ++ ) $ memo [ $ i ] = $ A [ $ n ] [ $ i ] ; for ( $ i = count ( $ A ) - 2 ; $ i >= 0 ; $ i -- ) for ( $ j = 0 ; $ j < $ A [ $ i ] . length ; $ j ++ ) $ memo [ $ j ] = $ A [ $ i ] [ $ j ] + min ( $ memo [ $ j ] , $ memo [ $ j + 1 ] ) ; return $ memo [ 0 ] ; }

BLEU: 72.18
Edit Sim: 106


Src: 
function countEvenSum ( arr , n ) { let result = 0 ; for ( let i = 0 ; i <= n - 1 ; i ++ ) { let sum = 0 ; for ( let j = i ; j <= n - 1 ; j ++ ) { sum = sum + arr [ j ] ; if ( sum % 2 == 0 ) result ++ ; } } return ( result ) ; }
Ref: 
function countEvenSum ( $ arr , $ n ) { $ result = 0 ; for ( $ i = 0 ; $ i <= $ n - 1 ; $ i ++ ) { $ sum = 0 ; for ( $ j = $ i ; $ j <= $ n - 1 ; $ j ++ ) { $ sum = $ sum + $ arr [ $ j ] ; if ( $ sum % 2 == 0 ) $ result ++ ; } } return ( $ result ) ; }
Hyp: 
function countEvenSum ( $ arr , $ n ) { $ result = 0 ; for ( $ i = 0 ; $ i <= $ n - 1 ; $ i ++ ) { $ sum = 0 ; for ( $ j = $ i ; $ j <= $ n - 1 ; $ j ++ ) { $ sum = $ sum + $ arr [ $ j ] ; if ( $ sum % 2 == 0 ) $ result ++ ; } } return ( $ result ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function check ( s , m ) { let l = s . length ; let c1 = 0 ; let c2 = 0 ; for ( let i = 0 ; i < l ; i ++ ) { if ( s [ i ] == ' ' ) { c2 = 0 ; c1 ++ ; } else { c1 = 0 ; c2 ++ ; } if ( c1 == m c2 == m ) return true ; } return false ; }
Ref: 
function check ( $ s , $ m ) { $ l = count ( $ s ) ; $ c1 = 0 ; $ c2 = 0 ; for ( $ i = 0 ; $ i <= $ l ; $ i ++ ) { if ( $ s [ $ i ] == '0' ) { $ c2 = 0 ; $ c1 ++ ; } else { $ c1 = 0 ; $ c2 ++ ; } if ( $ c1 == $ m or $ c2 == $ m ) return true ; } return false ; }
Hyp: 
function check ( $ s , $ m ) { $ l = strlen ( $ s ) ; $ c1 = 0 ; $ c2 = 0 ; for ( $ i = 0 ; $ i < $ l ; $ i ++ ) { if ( $ s [ $ i ] == '0' ) { $ c2 = 0 ; $ c1 ++ ; } else { $ c1 = 0 ; $ c2 ++ ; } if ( $ c1 == $ m $ c2 == $ m ) return true ; } return false ; }

BLEU: 92.59
Edit Sim: 10


Src: 
function alter ( x , y ) { while ( true ) { if ( x == 0 y == 0 ) break ; if ( x >= 2 * y ) x = x % ( 2 * y ) ; else if ( y >= 2 * x ) y = y % ( 2 * x ) ; else break ; } document . write ( " " + x + " " + " " + y ) ; }
Ref: 
function alter ( $ x , $ y ) { while ( true ) { if ( $ x == 0 $ y == 0 ) break ; if ( $ x >= 2 * $ y ) $ x = $ x % ( 2 * $ y ) ; else if ( $ y >= 2 * $ x ) $ y = $ y % ( 2 * $ x ) ; else break ; } echo " X = " , ▁ $ x , ▁ " , " , ▁ " Y = " }
Hyp: 
function alter ( $ x , $ y ) { while ( true ) { if ( $ x == 0 $ y == 0 ) break ; if ( $ x >= 2 * $ y ) $ x = $ x % ( 2 * $ y ) ; else if ( $ y >= 2 * $ x ) $ y = $ y % ( 2 * $ x ) ; else break ; } echo " Alter ▁ Input ▁ is ▁ " , $ x , " STRNEWLINE " ; }

BLEU: 85.25
Edit Sim: 29


Src: 
function swapBits ( x , p1 , p2 , n ) { let set1 = ( x >> p1 ) & ( ( 1 << n ) - 1 ) ; let set2 = ( x >> p2 ) & ( ( 1 << n ) - 1 ) ; let xor = ( set1 ^ set2 ) ; xor = ( xor << p1 ) | ( xor << p2 ) ; let result = x ^ xor ; return result ; }
Ref: 
function swapBits ( $ x , $ p1 , $ p2 , $ n ) { $ set1 = ( $ x >> $ p1 ) & ( ( 1 << $ n ) - 1 ) ; $ set2 = ( $ x >> $ p2 ) & ( ( 1 << $ n ) - 1 ) ; $ xor = ( $ set1 ^ $ set2 ) ; $ xor = ( $ xor << $ p1 ) | ( $ xor << $ p2 ) ; $ result = $ x ^ $ xor ; return $ result ; }
Hyp: 
function swapBits ( $ x , $ p1 , $ p2 , $ n ) { $ set1 = ( $ x >> $ p1 ) & ( ( 1 << $ n ) - 1 ) ; $ set2 = ( $ x >> $ p2 ) & ( ( 1 << $ n ) - 1 ) ; $ xor = ( $ set1 ^ $ set2 ) ; $ xor = ( $ xor << $ p1 ) | ( $ xor << $ p2 ) ; $ result = $ x ^ $ xor ; return $ result ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findSum ( n ) { let arr = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { arr [ i ] = new Array ( n ) ; for ( let j = 0 ; j < n ; j ++ ) { arr [ i ] [ j ] = 0 ; } } for ( let i = 0 ; i < n ; i ++ ) for ( let j = 0 ; j < n ; j ++ ) arr [ i ] [ j ] = Math . abs ( i - j ) ; let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = 0 ; j < n ; j ++ ) sum += arr [ i ] [ j ] ; return sum ; }
Ref: 
function findSum ( $ n ) { $ arr = array ( array ( ) ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ n ; $ j ++ ) $ arr [ $ i ] [ $ j ] = abs ( $ i - $ j ) ; $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ n ; $ j ++ ) $ sum += $ arr [ $ i ] [ $ j ] ; return $ sum ; }
Hyp: 
function findSum ( $ n ) { $ arr = array ( array ( ) ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ n ; $ j ++ ) $ arr [ $ i ] [ $ j ] = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ n ; $ j ++ ) $ arr [ $ i ] [ $ j ] = abs ( $ i - $ j ) ; $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ n ; $ j ++ ) $ sum += $ arr [ $ i ] [ $ j ] ; return $ sum ; }

BLEU: 73.22
Edit Sim: 102


Src: 
function findTriplet ( a1 , a2 , a3 , n1 , n2 , n3 , sum ) { for ( var i = 0 ; i < n1 ; i ++ ) for ( var j = 0 ; j < n2 ; j ++ ) for ( var k = 0 ; k < n3 ; k ++ ) if ( a1 [ i ] + a2 [ j ] + a3 [ k ] == sum ) return true ; return false ; }
Ref: 
function findTriplet ( $ a1 , $ a2 , $ a3 , $ n1 , $ n2 , $ n3 , $ sum ) { for ( $ i = 0 ; $ i < $ n1 ; $ i ++ ) for ( $ j = 0 ; $ j < $ n2 ; $ j ++ ) for ( $ k = 0 ; $ k < $ n3 ; $ k ++ ) if ( $ a1 [ $ i ] + $ a2 [ $ j ] + $ a3 [ $ k ] == $ sum ) return true ; return false ; }
Hyp: 
function findTriplet ( $ a1 , $ a2 , $ a3 , $ n1 , $ n2 , $ n3 , $ sum ) { for ( $ i = 0 ; $ i < $ n1 ; $ i ++ ) for ( $ j = 0 ; $ j < $ n2 ; $ j ++ ) for ( $ k = 0 ; $ k < $ n3 ; $ k ++ ) if ( $ a1 [ $ i ] + $ a2 [ $ j ] + $ a3 [ $ k ] == $ sum ) return true ; return false ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findLastIndex ( str , x ) { for ( let i = str . length - 1 ; i >= 0 ; i -- ) if ( str [ i ] == x ) return i ; return - 1 ; }
Ref: 
function findLastIndex ( $ str , $ x ) { for ( $ i = strlen ( $ str ) - 1 ; $ i >= 0 ; $ i -- ) if ( $ str [ $ i ] == $ x ) return $ i ; return -1 ; }
Hyp: 
function findLastIndex ( $ str , $ x ) { for ( $ i = strlen ( $ str ) - 1 ; $ i >= 0 ; $ i -- ) if ( $ str [ $ i ] == $ x ) return $ i ; return -1 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function factorial ( n ) { if ( n == 0 ) return 1 ; return n * factorial ( n - 1 ) ; }
Ref: 
function factorial ( $ n ) { if ( $ n == 0 ) return 1 ; return $ n * factorial ( $ n - 1 ) ; }
Hyp: 
function factorial ( $ n ) { if ( $ n == 0 ) return 1 ; return $ n * factorial ( $ n - 1 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function isTriangular ( num ) { if ( num < 0 ) return false ; var c = ( - 2 * num ) ; var b = 1 , a = 1 ; var d = ( b * b ) - ( 4 * a * c ) ; if ( d < 0 ) return false ; var root1 = ( - b + Math . sqrt ( d ) ) / ( 2 * a ) ; var root2 = ( - b - Math . sqrt ( d ) ) / ( 2 * a ) ; if ( root1 > 0 && Math . floor ( root1 ) == root1 ) return true ; if ( root2 > 0 && Math . floor ( root2 ) == root2 ) return true ; return false ; }
Ref: 
function isTriangular ( $ num ) { if ( $ num < 0 ) return false ; $ c = ( -2 * $ num ) ; $ b = 1 ; $ a = 1 ; $ d = ( $ b * $ b ) - ( 4 * $ a * $ c ) ; if ( $ d < 0 ) return false ; $ root1 = ( - $ b + ( float ) sqrt ( $ d ) ) / ( 2 * $ a ) ; $ root2 = ( - $ b - ( float ) sqrt ( $ d ) ) / ( 2 * $ a ) ; if ( $ root1 > 0 && floor ( $ root1 ) == $ root1 ) return true ; if ( $ root2 > 0 && floor ( $ root2 ) == $ root2 ) return true ; return false ; }
Hyp: 
function isTriangular ( $ num ) { $ c = ( - 2 * $ num ) ; $ b = 1 ; $ a = 1 ; $ d = ( $ b * $ b ) - ( 4 * $ a * $ c ) ; if ( $ d < 0 ) return false ; $ root1 = ( - $ b + sqrt ( $ d ) ) / ( 2 * $ a ) ; $ root2 = ( - $ b - sqrt ( $ d ) ) / ( 2 * $ a ) ; if ( $ root1 > 0 && floor ( $ root1 ) == $ root1 ) return true ; if ( $ root2 > 0 && floor ( $ root2 ) == $ root2 ) return true ; return false ; }

BLEU: 85.11
Edit Sim: 53


Src: 
function numberOfCuts ( M , N ) { var result = 0 ; result = ( M - 1 ) * ( N - 1 ) ; return result ; }
Ref: 
function numberOfCuts ( $ M , $ N ) { $ result = 0 ; $ result = ( $ M - 1 ) * ( $ N - 1 ) ; return $ result ; }
Hyp: 
function numberOfCuts ( $ M , $ N ) { $ result = 0 ; $ result = ( $ M - 1 ) * ( $ N - 1 ) ; return $ result ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function BalanceArray ( A , Q ) { var ANS = [ ] ; var i , sum = 0 ; for ( i = 0 ; i < A . length ; i ++ ) if ( A [ i ] % 2 == 0 ) sum = sum + A [ i ] ; for ( i = 0 ; i < Q . length ; i ++ ) { var index = Q [ i ] [ 0 ] ; var value = Q [ i ] [ 1 ] ; if ( A [ index ] % 2 == 0 ) sum = sum - A [ index ] ; A [ index ] = A [ index ] + value ; if ( A [ index ] % 2 == 0 ) sum = sum + A [ index ] ; ANS . push ( sum ) ; } for ( i = 0 ; i < ANS . length ; i ++ ) document . write ( ANS [ i ] + " " ) ; }
Ref: 
function BalanceArray ( $ A , & $ Q ) { $ ANS = array ( ) ; $ sum = 0 ; for ( $ i = 0 ; $ i < count ( $ A ) ; $ i ++ ) if ( $ A [ $ i ] % 2 == 0 ) $ sum = $ sum + $ A [ $ i ] ; for ( $ i = 0 ; $ i < count ( $ Q ) ; $ i ++ ) { $ index = $ Q [ $ i ] [ 0 ] ; $ value = $ Q [ $ i ] [ 1 ] ; if ( $ A [ $ index ] % 2 == 0 ) $ sum = $ sum - $ A [ $ index ] ; $ A [ $ index ] = $ A [ $ index ] + $ value ; if ( $ A [ $ index ] % 2 == 0 ) $ sum = $ sum + $ A [ $ index ] ; array_push ( $ ANS , $ sum ) ; } for ( $ i = 0 ; $ i < count ( $ ANS ) ; $ i ++ ) echo $ ANS [ $ i ] . " ▁ " ; }
Hyp: 
function BalanceArray ( $ A , $ Q ) { $ ANS = array ( ) ; $ sum = 0 ; for ( $ i = 0 ; $ i < $ A . length ; $ i ++ ) if ( $ A [ $ i ] % 2 == 0 ) $ sum = $ sum + $ A [ $ i ] ; for ( $ i = 0 ; $ i < strlen ( $ Q ) ; $ i ++ ) { $ index = $ Q [ $ i ] [ 0 ] ; $ value = $ Q [ $ i ] [ 1 ] ; if ( $ A [ $ index ] % 2 == 0 ) $ sum = $ sum - $ A [ $ index ] ; $ A [ $ index ] = $ A [ $ index ] + $ value ; if ( $ A [ $ index ] % 2 == 0 ) $ sum = $ sum + $ A [ $ index ] ; $ ANS . push ( $ sum ) ; } for ( $ i = 0 ; $ i < strlen ( $ ANS ) ; $ i ++ ) echo $ ANS [ $ i ] . " ▁ " ; }

BLEU: 91.89
Edit Sim: 42


Src: 
function countMaxIntersect ( n ) { return ( n ) * ( n - 1 ) / 2 ; }
Ref: 
function countMaxIntersect ( $ n ) { return ( $ n ) * ( $ n - 1 ) / 2 ; }
Hyp: 
function countMaxIntersect ( $ n ) { return ( $ n ) * ( $ n - 1 ) / 2 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findDigits ( n ) { if ( n < 0 ) return 0 ; if ( n <= 1 ) return 1 ; let x = ( ( n * Math . log10 ( n / Math . E ) + Math . log10 ( 2 * Math . PI * n ) / 2.0 ) ) ; return Math . floor ( x ) + 1 ; }
Ref: 
function findDigits ( $ n ) { if ( $ n < 0 ) return 0 ; if ( $ n <= 1 ) return 1 ; $ x = ( ( $ n * log10 ( $ n / M_E ) + log10 ( 2 * M_PI * $ n ) / 2.0 ) ) ; return floor ( $ x ) + 1 ; }
Hyp: 
function findDigits ( $ n ) { if ( $ n < 0 ) return 0 ; if ( $ n <= 1 ) return 1 ; $ x = ( ( $ n * log10 ( $ n / Math . E ) + log10 ( 2 * PI * $ n ) / 2.0 ) ) ; return floor ( $ x ) + 1 ; }

BLEU: 89.66
Edit Sim: 8


Src: 
function nthTerm ( n ) { return 2 * Math . pow ( n , 2 ) + 3 * n - 5 ; }
Ref: 
function nthTerm ( $ n ) { return 2 * pow ( $ n , 2 ) + 3 * $ n - 5 ; }
Hyp: 
function nthTerm ( $ n ) { return 2 * pow ( $ n , 2 ) + 3 * $ n - 5 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findTriplets ( arr , n , sum ) { for ( let i = 0 ; i < n - 2 ; i ++ ) { for ( let j = i + 1 ; j < n - 1 ; j ++ ) { for ( let k = j + 1 ; k < n ; k ++ ) { if ( arr [ i ] + arr [ j ] + arr [ k ] == sum ) { document . write ( arr [ i ] + " " + arr [ j ] + " " + arr [ k ] + " " ) ; } } } } }
Ref: 
function findTriplets ( $ arr , $ n , $ sum ) { for ( $ i = 0 ; $ i < $ n - 2 ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ n - 1 ; $ j ++ ) { for ( $ k = $ j + 1 ; $ k < $ n ; $ k ++ ) { if ( $ arr [ $ i ] + $ arr [ $ j ] + $ arr [ $ k ] == $ sum ) { echo $ arr [ $ i ] , " " , $ arr [ $ j ] , " " , $ arr [ $ k ] , " " ; } } } } }
Hyp: 
function findTriplets ( & $ arr , $ n , $ sum ) { for ( $ i = 0 ; $ i < $ n - 2 ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n - 1 ; $ j ++ ) { for ( $ k = $ j + 1 ; $ k < $ n ; $ k ++ ) { if ( $ arr [ $ i ] + $ arr [ $ j ] + $ arr [ $ k ] == $ sum ) { echo ( $ arr [ $ i ] ) ; echo ( " , ▁ " ) ; echo ( $ arr [ $ j ] ) ; echo ( " , ▁ " ) ; echo ( $ arr [ $ k ] ) ; echo ( " STRNEWLINE " ) ; } } } }

BLEU: 74.78
Edit Sim: 77


Src: 
function equation_plane ( x1 , y1 , z1 , x2 , y2 , z2 , x3 , y3 , z3 , x , y , z ) { var a1 = x2 - x1 ; var b1 = y2 - y1 ; var c1 = z2 - z1 ; var a2 = x3 - x1 ; var b2 = y3 - y1 ; var c2 = z3 - z1 ; var a = b1 * c2 - b2 * c1 ; var b = a2 * c1 - a1 * c2 ; var c = a1 * b2 - b1 * a2 ; var d = ( - a * x1 - b * y1 - c * z1 ) ; if ( a * x + b * y + c * z + d == 0 ) document . write ( " " ) ; else document . write ( " " ) ; }
Ref: 
function equation_plane ( $ x1 , $ y1 , $ z1 , $ x2 , $ y2 , $ z2 , $ x3 , $ y3 , $ z3 , $ x , $ y , $ z ) { $ a1 = $ x2 - $ x1 ; $ b1 = $ y2 - $ y1 ; $ c1 = $ z2 - $ z1 ; $ a2 = $ x3 - $ x1 ; $ b2 = $ y3 - $ y1 ; $ c2 = $ z3 - $ z1 ; $ a = $ b1 * $ c2 - $ b2 * $ c1 ; $ b = $ a2 * $ c1 - $ a1 * $ c2 ; $ c = $ a1 * $ b2 - $ b1 * $ a2 ; $ d = ( - $ a * $ x1 - $ b * $ y1 - $ c * $ z1 ) ; if ( $ a * $ x + $ b * $ y + $ c * $ z + $ d == 0 ) echo ( " Coplanar " ) ; else echo ( " Not ▁ Coplanar " ) ; }
Hyp: 
function equation_plane ( $ x1 , $ y1 , $ z1 , $ x2 , $ y2 , $ z2 , $ x3 , $ y3 , $ z3 , $ x , $ y , $ z ) { $ a1 = $ x2 - $ x1 ; $ b1 = $ y2 - $ y1 ; $ c1 = $ z2 - $ z1 ; $ a2 = $ x3 - $ x1 ; $ b2 = $ y3 - $ y1 ; $ c2 = $ z3 - $ z1 ; $ a = $ b1 * $ c2 - $ b2 * $ c1 ; $ b = $ a2 * $ c1 - $ a1 * $ c2 ; $ c = $ a1 * $ b2 - $ b1 * $ a2 ; $ d = ( - $ a * $ x1 - $ b * $ y1 - $ c * $ z1 ) ; if ( $ a * $ x + $ b * $ y + $ c * $ z + $ d == 0 ) echo " No " ; else echo " Yes " ; }

BLEU: 93.25
Edit Sim: 29


Src: 
function printNSE ( arr , n ) { var next , i , j ; for ( i = 0 ; i < n ; i ++ ) { next = - 1 ; for ( j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] > arr [ j ] ) { next = arr [ j ] ; break ; } } document . write ( arr [ i ] + " " + next + " " ) ; } }
Ref: 
function printNSE ( $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ next = -1 ; for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) { if ( $ arr [ $ i ] > $ arr [ $ j ] ) { $ next = $ arr [ $ j ] ; break ; } } echo $ arr [ $ i ] . " -- " . ▁ $ next . " " } }
Hyp: 
function printNSE ( $ arr , $ n ) { $ next = -1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ next = -1 ; for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) { if ( $ arr [ $ i ] > $ arr [ $ j ] ) { $ next = $ arr [ $ j ] ; break ; } } echo $ arr [ $ i ] . " ▁ " . $ next . " STRNEWLINE " ; } }

BLEU: 87.19
Edit Sim: 31


Src: 
function NicomachuTheorum_sum ( n ) { let sum = 0 ; for ( let k = 1 ; k <= n ; k ++ ) sum += k * k * k ; let triNo = n * ( n + 1 ) / 2 ; if ( sum == triNo * triNo ) document . write ( " " ) ; else document . write ( " " ) ; }
Ref: 
function NicomachuTheorum_sum ( $ n ) { $ sum = 0 ; for ( $ k = 1 ; $ k <= $ n ; $ k ++ ) $ sum += $ k * $ k * $ k ; $ triNo = $ n * ( $ n + 1 ) / 2 ; if ( $ sum == $ triNo * $ triNo ) echo " Yes " ; else echo " No " ; }
Hyp: 
function NicomachuTheorum_sum ( $ n ) { $ sum = 0 ; for ( $ k = 1 ; $ k <= $ n ; $ k ++ ) $ sum += $ k * $ k * $ k ; $ triNo = $ n * ( $ n + 1 ) / 2 ; if ( $ sum == $ triNo * $ triNo ) echo " Yes " ; else echo " No " ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function largestNum ( a , b ) { return a * ( parseInt ( a / b ) > 0 ? 1 : 0 ) + b * ( parseInt ( b / a ) > 0 ? 1 : 0 ) ; }
Ref: 
function largestNum ( $ a , $ b ) { return ( $ a * ( boolean ) floor ( ( $ a / $ b ) ) ) + ( $ b * ( boolean ) floor ( ( $ b / $ a ) ) ) ; }
Hyp: 
function largestNum ( $ a , $ b ) { return $ a * ( int ) ( $ a / $ b ) > 0 ? 1 : 0 ) + $ b * ( int ) ( $ b / $ a ) > 0 ? 1 : 0 ) ; }

BLEU: 52.53
Edit Sim: 48


Src: 
function answer ( n ) { let m = 2 ; let ans = 1 ; let r = 1 ; while ( r < n ) { r = ( Math . pow ( 2 , m ) - 1 ) * ( Math . pow ( 2 , m - 1 ) ) ; if ( r < n ) ans = r ; m ++ ; } return ans ; }
Ref: 
function answer ( $ n ) { $ m = 2 ; $ ans = 1 ; $ r = 1 ; while ( $ r < $ n ) { $ r = ( pow ( 2 , $ m ) - 1 ) * ( pow ( 2 , $ m - 1 ) ) ; if ( $ r < $ n ) $ ans = $ r ; $ m ++ ; } return $ ans ; }
Hyp: 
function answer ( $ n ) { $ m = 2 ; $ ans = 1 ; $ r = 1 ; while ( $ r < $ n ) { $ r = ( pow ( 2 , $ m ) - 1 ) * ( pow ( 2 , $ m - 1 ) ) ; if ( $ r < $ n ) $ ans = $ r ; $ m ++ ; } return $ ans ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function nthTerm ( n ) { return 3 * Math . pow ( n , 2 ) - 4 * n + 2 ; }
Ref: 
function nthTerm ( $ n ) { return 3 * pow ( $ n , 2 ) - 4 * $ n + 2 ; }
Hyp: 
function nthTerm ( $ n ) { return 3 * pow ( $ n , 2 ) - 4 * $ n + 2 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function circle_inscribed ( a ) { return PI * ( a * a ) / 12 ; }
Ref: 
function circle_inscribed ( $ a ) { return 3.14 * ( $ a * $ a ) / 12 ; }
Hyp: 
function circle_inscribed ( $ a ) { return PI * ( $ a * $ a ) / 12 ; }

BLEU: 87.25
Edit Sim: 4


Src: 
function maxLevel ( boxes , n ) { boxes . sort ( ) ; let prev_width = boxes [ 0 ] ; let prev_count = 1 ; let curr_count = 0 ; let curr_width = 0 ; for ( let i = 1 ; i < n ; i ++ ) { curr_width += boxes [ i ] ; curr_count += 1 ; if ( curr_width > prev_width && curr_count > prev_count ) { prev_width = curr_width ; prev_count = curr_count ; curr_count = 0 ; curr_width = 0 ; ans ++ ; } } return ans ; }
Ref: 
function maxLevel ( $ boxes , $ n ) { sort ( $ boxes ) ; $ ans = 1 ; $ prev_width = $ boxes [ 0 ] ; $ prev_count = 1 ; $ curr_count = 0 ; $ curr_width = 0 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ curr_width += $ boxes [ $ i ] ; $ curr_count += 1 ; if ( $ curr_width > $ prev_width and $ curr_count > $ prev_count ) { $ prev_width = $ curr_width ; $ prev_count = $ curr_count ; $ curr_count = 0 ; $ curr_width = 0 ; $ ans ++ ; } } return $ ans ; }
Hyp: 
function maxLevel ( $ boxes , $ n ) { sort ( $ boxes ) ; $ prev_width = $ boxes [ 0 ] ; $ prev_count = 1 ; $ curr_count = 0 ; $ curr_width = 0 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ curr_width += $ boxes [ $ i ] ; $ curr_count += 1 ; if ( $ curr_width > $ prev_width && $ curr_count > $ prev_count ) { $ prev_width = $ curr_width ; $ prev_count = $ curr_count ; $ curr_count = 0 ; $ curr_width = 0 ; } } return $ ans ; }

BLEU: 89.78
Edit Sim: 26


Src: 
function cost ( a , n ) { let min = a [ 0 ] ; for ( let i = 1 ; i < a . length ; i ++ ) { if ( a [ i ] < min ) min = a [ i ] ; } return ( n - 1 ) * min ; }
Ref: 
function cost ( $ a , $ n ) { return ( $ n - 1 ) * ( min ( $ a ) ) ; }
Hyp: 
function cost ( $ a , $ n ) { $ min = $ a [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] < $ min ) $ min = $ a [ $ i ] ; } return ( $ n - 1 ) * $ min ; }

BLEU: 25.84
Edit Sim: 111


Src: 
function countValues ( x ) { var count = 0 , n = 1 ; while ( x != 0 ) { if ( x % 2 == 0 ) count += n ; n *= 2 ; x = parseInt ( x / 2 ) ; } return count ; }
Ref: 
function countValues ( $ x ) { $ count = 0 ; $ n = 1 ; while ( $ x != 0 ) { if ( $ x % 2 == 0 ) $ count += $ n ; $ n *= 2 ; $ x /= 2 ; $ x = ( int ) $ x ; } return $ count ; }
Hyp: 
function countValues ( $ x ) { $ count = 0 ; $ n = 1 ; while ( $ x != 0 ) { if ( $ x % 2 == 0 ) $ count += $ n ; $ n *= 2 ; $ x = ( int ) $ x / 2 ; } return $ count ; }

BLEU: 90.55
Edit Sim: 15


Src: 
function nthTerm ( n ) { return 2 * Math . pow ( n , 2 ) - n - 1 ; }
Ref: 
function nthTerm ( $ n ) { return 2 * pow ( $ n , 2 ) - $ n - 1 ; }
Hyp: 
function nthTerm ( $ n ) { return 2 * pow ( $ n , 2 ) - $ n - 1 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function stringPalindrome ( A , B ) { var countA = Array . from ( { length : MAX_CHAR } , ( _ , i ) => 0 ) ; var countB = Array . from ( { length : MAX_CHAR } , ( _ , i ) => 0 ) ; var l1 = A . length ; var l2 = B . length ; for ( var i = 0 ; i < l1 ; i ++ ) countA [ A . charAt ( i ) . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; for ( var i = 0 ; i < l2 ; i ++ ) countB [ B . charAt ( i ) . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; for ( var i = 0 ; i < 26 ; i ++ ) if ( ( countA [ i ] > 1 && countB [ i ] == 0 ) ) return ' ' ; return ' ' ; }
Ref: 
function stringPalindrome ( $ A , $ B ) { global $ MAX_CHAR ; $ countA = array_fill ( 0 , $ MAX_CHAR , 0 ) ; $ countB = array_fill ( 0 , $ MAX_CHAR , 0 ) ; $ l1 = strlen ( $ A ) ; $ l2 = strlen ( $ B ) ; for ( $ i = 0 ; $ i < $ l1 ; $ i ++ ) $ countA [ ord ( $ A [ $ i ] ) - ord ( ' a ' ) ] ++ ; for ( $ i = 0 ; $ i < $ l2 ; $ i ++ ) $ countB [ ord ( $ B [ $ i ] ) - ord ( ' a ' ) ] ++ ; for ( $ i = 0 ; $ i < 26 ; $ i ++ ) if ( ( $ countA [ $ i ] > 1 && $ countB [ $ i ] == 0 ) ) return ' A ' ; return ' B ' ; }
Hyp: 
function stringPalindrome ( $ A , $ B ) { $ countA = array ( 1024 ) ; $ countB = array ( 1024 ) ; $ l1 = strlen ( $ A ) ; $ l2 = strlen ( $ B ) ; for ( $ i = 0 ; $ i < $ l1 ; $ i ++ ) $ countA [ $ A [ $ i ] - ' a ' ] ++ ; for ( $ i = 0 ; $ i < $ l2 ; $ i ++ ) $ countB [ $ B [ $ i ] - ' a ' ] ++ ; for ( $ i = 0 ; $ i < 26 ; $ i ++ ) if ( ( $ countA [ $ i ] > 1 && $ countB [ $ i ] == 0 ) ) return ' a ' ; return ' b ' ; }

BLEU: 70.82
Edit Sim: 100


Src: 
function countOdd ( L , R ) { let N = Math . floor ( ( R - L ) / 2 ) ; if ( R % 2 != 0 L % 2 != 0 ) N += 1 ; return N ; }
Ref: 
function countOdd ( $ L , $ R ) { $ N = ( $ R - $ L ) / 2 ; if ( $ R % 2 != 0 $ L % 2 != 0 ) $ N ++ ; return $ N ; }
Hyp: 
function countOdd ( $ L , $ R ) { $ N = floor ( ( $ R - $ L ) / 2 ) ; if ( $ R % 2 != 0 $ L % 2 != 0 ) $ N += 1 ; return $ N ; }

BLEU: 80.72
Edit Sim: 13


Src: 
function findSum ( n ) { return Math . sqrt ( 3 ) * ( n * ( n + 1 ) / 2 ) ; }
Ref: 
function findSum ( $ n ) { return sqrt ( 3 ) * ( $ n * ( $ n + 1 ) / 2 ) ; }
Hyp: 
function findSum ( $ n ) { return sqrt ( 3 ) * ( $ n * ( $ n + 1 ) / 2 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function kthdigit ( a , b , k ) { let p = Math . pow ( a , b ) ; let count = 0 ; while ( p > 0 && count < k ) { let rem = p % 10 ; count ++ ; if ( count == k ) return rem ; p = p / 10 ; } return 0 ; }
Ref: 
function kthdigit ( $ a , $ b , $ k ) { $ p = pow ( $ a , $ b ) ; $ count = 0 ; while ( $ p > 0 and $ count < $ k ) { $ rem = $ p % 10 ; $ count ++ ; if ( $ count == $ k ) return $ rem ; $ p = $ p / 10 ; } return 0 ; }
Hyp: 
function kthdigit ( $ a , $ b , $ k ) { $ p = pow ( $ a , $ b ) ; $ count = 0 ; while ( $ p > 0 && $ count < $ k ) { $ rem = $ p % 10 ; $ count ++ ; if ( $ count == $ k ) return $ rem ; $ p = $ p / 10 ; } return 0 ; }

BLEU: 96.86
Edit Sim: 3


Src: 
function centeredNonagonal ( n ) { return parseInt ( ( 3 * n - 2 ) * ( 3 * n - 1 ) / 2 ) ; }
Ref: 
function centeredNonagonal ( $ n ) { return ( 3 * $ n - 2 ) * ( 3 * $ n - 1 ) / 2 ; }
Hyp: 
function centeredNonagonal ( $ n ) { return ( 3 * $ n - 2 ) * ( 3 * $ n - 1 ) / 2 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function pentagon_pyramidal ( n ) { var sum = 0 ; for ( i = 1 ; i <= n ; i ++ ) { var p = ( 3 * i * i - i ) / 2 ; sum = sum + p ; } return sum ; }
Ref: 
function pentagon_pyramidal ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ p = ( 3 * $ i * $ i - $ i ) / 2 ; $ sum = $ sum + $ p ; } return $ sum ; }
Hyp: 
function pentagon_pyramidal ( $ n ) { $ sum = pow ( 3 , $ n * $ n - 1 ) / 2 ; $ sum = $ sum + pow ( 3 , $ n * $ i - 1 ) ; return $ sum ; }

BLEU: 40.6
Edit Sim: 60


Src: 
function evenbitsetnumber ( n ) { let count = 0 , res = 0 ; for ( let temp = n ; temp > 0 ; temp >>= 1 ) { if ( count % 2 == 1 ) res |= ( 1 << count ) ; count ++ ; } return ( n res ) ; }
Ref: 
function evenbitsetnumber ( $ n ) { $ count = 0 ; $ res = 0 ; for ( $ temp = $ n ; $ temp > 0 ; $ temp >>= 1 ) { if ( $ count % 2 == 1 ) $ res |= ( 1 << $ count ) ; $ count ++ ; } return ( $ n $ res ) ; }
Hyp: 
function evenbitsetnumber ( $ n ) { $ count = 0 ; $ res = 0 ; for ( $ temp = $ n ; $ temp > 0 ; $ temp >>= 1 ) { if ( $ count % 2 == 1 ) $ res |= ( 1 << $ count ) ; $ count ++ ; } return ( $ n $ res ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function isValid ( str , len ) { for ( let i = 1 ; i < len ; i ++ ) { if ( str [ i ] == str [ i - 1 ] ) return false ; } return true ; }
Ref: 
function isValid ( $ str , $ len ) { for ( $ i = 1 ; $ i < $ len ; $ i ++ ) { if ( $ str [ $ i ] == $ str [ $ i - 1 ] ) return false ; } return true ; }
Hyp: 
function isValid ( $ str , $ len ) { for ( $ i = 1 ; $ i < $ len ; $ i ++ ) { if ( $ str [ $ i ] == $ str [ $ i - 1 ] ) return false ; } return true ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function checkArray ( arr , n ) { return ( ( arr [ 0 ] % 2 ) > 0 && ( arr [ n - 1 ] % 2 ) > 0 && ( n % 2 ) > 0 ) ? 1 : 0 ; }
Ref: 
function checkArray ( $ arr , $ n ) { return ( $ arr [ 0 ] % 2 ) && ( $ arr [ $ n - 1 ] % 2 ) && ( $ n % 2 ) ; }
Hyp: 
function checkArray ( $ arr , $ n ) { return ( ( $ arr [ 0 ] % 2 ) > 0 && ( $ arr [ $ n - 1 ] % 2 ) > 0 && ( $ n % 2 ) ) ? 1 : 0 ; }

BLEU: 70.24
Edit Sim: 20


Src: 
function term ( n ) { let d = 2 ; let a1 = 0 ; An = a1 + ( n - 1 ) * d ; return Math . pow ( An , 3 ) ; }
Ref: 
function term ( $ n ) { $ d = 2 ; $ a1 = 0 ; $ An = $ a1 + ( $ n - 1 ) * $ d ; return pow ( $ An , 3 ) ; }
Hyp: 
function term ( $ n ) { $ d = 2 ; $ a1 = 0 ; $ An = $ a1 + ( $ n - 1 ) * $ d ; return pow ( $ An , 3 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findTwoThreePrime ( l , r ) { if ( l == 1 ) l ++ ; let count = 0 ; for ( let i = l ; i <= r ; i ++ ) { let num = i ; while ( num % 2 == 0 ) num = parseInt ( num / 2 , 10 ) ; while ( num % 3 == 0 ) num = parseInt ( num / 3 , 10 ) ; if ( num == 1 ) count ++ ; } return count ; }
Ref: 
function findTwoThreePrime ( $ l , $ r ) { if ( $ l == 1 ) $ l ++ ; $ count = 0 ; for ( $ i = $ l ; $ i <= $ r ; $ i ++ ) { $ num = $ i ; while ( $ num % 2 == 0 ) $ num /= 2 ; while ( $ num % 3 == 0 ) $ num /= 3 ; if ( $ num == 1 ) $ count ++ ; } return $ count ; }
Hyp: 
function findTwoThreePrime ( $ l , $ r ) { if ( $ l == 1 ) $ l ++ ; $ count = 0 ; for ( $ i = $ l ; $ i <= $ r ; $ i ++ ) { $ num = $ i ; while ( $ num % 2 == 0 ) $ num = $ num / 2 ; while ( $ num % 3 == 0 ) $ num = $ num / 3 ; if ( $ num == 1 ) $ count ++ ; } return $ count ; }

BLEU: 89.11
Edit Sim: 18


Src: 
function checkForSorting ( arr , n ) { let temp = 0 ; for ( let i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] > arr [ i + 1 ] ) { if ( arr [ i ] - arr [ i + 1 ] == 1 ) { temp = arr [ i ] ; arr [ i ] = arr [ i + 1 ] ; arr [ i + 1 ] = temp ; } else return false ; } } return true ; }
Ref: 
function checkForSorting ( $ arr , $ n ) { $ temp = 0 ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { if ( $ arr [ $ i ] > $ arr [ $ i + 1 ] ) { if ( $ arr [ $ i ] - $ arr [ $ i + 1 ] == 1 ) { $ temp = $ arr [ $ i ] ; $ arr [ $ i ] = $ arr [ $ i + 1 ] ; $ arr [ $ i + 1 ] = $ temp ; } else return false ; } } return true ; }
Hyp: 
function checkForSorting ( & $ arr , $ n ) { $ temp = 0 ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { if ( $ arr [ $ i ] > $ arr [ $ i + 1 ] ) { if ( $ arr [ $ i ] - $ arr [ $ i + 1 ] == 1 ) { $ temp = $ arr [ $ i ] ; $ arr [ $ i ] = $ arr [ $ i + 1 ] ; $ arr [ $ i + 1 ] = $ temp ; } else return false ; } } return true ; }

BLEU: 97.98
Edit Sim: 2


Src: 
function multiplyTen ( n ) { return ( n << 1 ) + ( n << 3 ) ; }
Ref: 
function multiplyTen ( $ n ) { return ( $ n << 1 ) + ( $ n << 3 ) ; }
Hyp: 
function multiplyTen ( $ n ) { return ( $ n << 1 ) + ( $ n << 3 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function slopeOfNum ( num , n ) { let slope = 0 ; for ( let i = 1 ; i < n - 1 ; i ++ ) { if ( num [ i ] > num [ i - 1 ] && num [ i ] > num [ i + 1 ] ) slope ++ ; else if ( num [ i ] < num [ i - 1 ] && num [ i ] < num [ i + 1 ] ) slope ++ ; } return slope ; }
Ref: 
function slopeOfNum ( $ num , $ n ) { $ slope = 0 ; for ( $ i = 1 ; $ i < $ n - 1 ; $ i ++ ) { if ( $ num [ $ i ] > $ num [ $ i - 1 ] && $ num [ $ i ] > $ num [ $ i + 1 ] ) $ slope ++ ; else if ( $ num [ $ i ] < $ num [ $ i - 1 ] && $ num [ $ i ] < $ num [ $ i + 1 ] ) $ slope ++ ; } return $ slope ; }
Hyp: 
function slopeOfNum ( $ num , $ n ) { $ slope = 0 ; for ( $ i = 1 ; $ i < $ n - 1 ; $ i ++ ) { if ( $ num [ $ i ] > $ num [ $ i - 1 ] and $ num [ $ i ] > $ num [ $ i + 1 ] ) $ slope ++ ; else if ( $ num [ $ i ] < $ num [ $ i - 1 ] and $ num [ $ i ] < $ num [ $ i + 1 ] ) $ slope ++ ; } return $ slope ; }

BLEU: 95.71
Edit Sim: 6


Src: 
function findAnswer ( n , arr ) { arr . sort ( ( a , b ) => a - b ) ; let sum = 0 ; for ( let i = 0 ; i < Math . floor ( n / 2 ) ; ++ i ) { sum += ( arr [ i ] + arr [ n - i - 1 ] ) * ( arr [ i ] + arr [ n - i - 1 ] ) ; } return sum ; }
Ref: 
function findAnswer ( $ n , $ arr ) { sort ( $ arr ) ; $ sum = 0 ; for ( $ i = 0 ; $ i < $ n / 2 ; ++ $ i ) { $ sum += ( $ arr [ $ i ] + $ arr [ $ n - $ i - 1 ] ) * ( $ arr [ $ i ] + $ arr [ $ n - $ i - 1 ] ) ; } return $ sum ; }
Hyp: 
function findAnswer ( $ n , $ arr ) { sort ( $ arr ) ; $ sum = 0 ; for ( $ i = 0 ; $ i < $ n / 2 ; ++ $ i ) { $ sum += ( $ arr [ $ i ] + $ arr [ $ n - $ i - 1 ] ) * ( $ arr [ $ i ] + $ arr [ $ n - $ i - 1 ] ) ; } return $ sum ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function getIndexInSortedArray ( arr , n , idx ) { let result = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ idx ] ) result ++ ; if ( arr [ i ] == arr [ idx ] && i < idx ) result ++ ; } return result ; }
Ref: 
function getIndexInSortedArray ( $ arr , $ n , $ idx ) { $ result = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] < $ arr [ $ idx ] ) $ result ++ ; if ( $ arr [ $ i ] == $ arr [ $ idx ] and $ i < $ idx ) $ result ++ ; } return $ result ; }
Hyp: 
function getIndexInSortedArray ( $ arr , $ n , $ idx ) { $ result = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] < $ arr [ $ idx ] ) $ result ++ ; if ( $ arr [ $ i ] == $ arr [ $ idx ] && $ i < $ idx ) $ result ++ ; } return $ result ; }

BLEU: 97.12
Edit Sim: 3


Src: 
function isValidNesbitt ( a , b , c ) { let A = a / ( b + c ) ; let B = b / ( a + c ) ; let C = c / ( a + b ) ; let inequality = A + B + C ; return ( inequality >= 1.5 ) ; } let a = 1.0 , b = 2.0 , c = 3.0 ; if ( isValidNesbitt ( a , b , c ) == true ) { document . write ( " " + " " ) ; document . write ( " " + a + " " + b + " " + c ) ; }
Ref: 
function isValidNesbitt ( $ a , $ b , $ c ) { $ A = $ a / ( $ b + $ c ) ; $ B = $ b / ( $ a + $ c ) ; $ C = $ c / ( $ a + $ b ) ; $ inequality = $ A + $ B + $ C ; return ( $ inequality >= 1.5 ) ; }
Hyp: 
function isValidNesbitt ( $ a , $ b , $ c ) { $ A = $ a / ( $ b + $ c ) ; $ B = $ b / ( $ a + $ c ) ; $ C = $ c / ( $ a + $ b ) ; $ inequality = $ A + $ B + $ C ; return ( $ inequality >= 1.5 ) ; } $ a = 1.0 ; $ b = 2.0 ; $ c = 3.0 ; if ( isValidNesbitt ( $ a , $ b , $ c ) == true ) { echo " Yes " ; echo " No " ; }

BLEU: 63.71
Edit Sim: 119


Src: 
function binToDecimal3 ( n ) { var last_3 = ( ( n & 4 ) + ( n & 2 ) + ( n & 1 ) ) ; n = n >> 3 ; while ( n > 7 ) n = n >> 1 ; var first_3 = ( ( n & 4 ) + ( n & 2 ) + ( n & 1 ) ) ; document . write ( first_3 + " " + last_3 ) ; }
Ref: 
function binToDecimal3 ( $ n ) { $ last_3 = ( ( $ n & 4 ) + ( $ n & 2 ) + ( $ n & 1 ) ) ; $ n = $ n >> 3 ; while ( $ n > 7 ) $ n = $ n >> 1 ; $ first_3 = ( ( $ n & 4 ) + ( $ n & 2 ) + ( $ n & 1 ) ) ; echo ( $ first_3 ) ; echo ( " ▁ " ) ; echo ( $ last_3 ) ; }
Hyp: 
function binToDecimal3 ( $ n ) { $ last_3 = ( ( $ n & 4 ) + ( $ n & 2 ) + ( $ n & 1 ) ) ; $ n = $ n >> 3 ; while ( $ n > 7 ) $ n = $ n >> 1 ; $ first_3 = ( ( $ n & 4 ) + ( $ n & 2 ) + ( $ n & 1 ) ) ; echo $ first_3 . " ▁ " . $ last_3 ; }

BLEU: 84.6
Edit Sim: 24


Src: 
function KthMinValAfterMconcatenate ( A , N , M , K ) { A . sort ( ( a , b ) => a - b ) return ( A [ ( ( K - 1 ) / M ) ] ) ; }
Ref: 
function KthMinValAfterMconcatenate ( $ A , $ N , $ M , $ K ) { sort ( $ A ) ; return ( $ A [ ( ( $ K - 1 ) / $ M ) ] ) ; }
Hyp: 
function KthMinValAfterMconcatenate ( $ A , $ N , $ M , $ K ) { sort ( $ A ) ; return $ A [ ( ( $ K - 1 ) / $ M ) ] ; }

BLEU: 88.24
Edit Sim: 4


Src: 
function isPrime ( n ) { if ( n <= 1 ) return false ; for ( let i = 2 ; i < n ; i ++ ) if ( n % i == 0 ) return false ; return true ; }
Ref: 
function isPrime ( $ n ) { if ( $ n <= 1 ) return false ; for ( $ i = 2 ; $ i < $ n ; $ i ++ ) if ( $ n % $ i == 0 ) return false ; return true ; }
Hyp: 
function isPrime ( $ n ) { if ( $ n <= 1 ) return false ; for ( $ i = 2 ; $ i < $ n ; $ i ++ ) if ( $ n % $ i == 0 ) return false ; return true ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function minRemove ( arr , n ) { let LIS = new Array ( n ) . fill ( 0 ) ; let len = 0 ; for ( let i = 0 ; i < n ; i ++ ) LIS [ i ] = 1 ; for ( let i = 1 ; i < n ; i ++ ) { for ( let j = 0 ; j < i ; j ++ ) { if ( arr [ i ] > arr [ j ] && ( i - j ) <= ( arr [ i ] - arr [ j ] ) ) LIS [ i ] = Math . max ( LIS [ i ] , LIS [ j ] + 1 ) ; } len = Math . max ( len , LIS [ i ] ) ; } return n - len ; }
Ref: 
function minRemove ( $ arr , $ n ) { $ LIS = array ( ) ; $ len = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ LIS [ $ i ] = 1 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ i ; $ j ++ ) { if ( $ arr [ $ i ] > $ arr [ $ j ] ) $ LIS [ $ i ] = max ( $ LIS [ $ i ] , $ LIS [ $ j ] + 1 ) ; } $ len = max ( $ len , $ LIS [ $ i ] ) ; } return $ n - $ len ; }
Hyp: 
function minRemove ( $ arr , $ n ) { $ LIS [ $ n ] = 0 ; $ len = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ LIS [ $ i ] = 1 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ i ; $ j ++ ) if ( $ arr [ $ i ] > $ arr [ $ j ] && ( $ i - $ j ) <= ( $ arr [ $ i ] - $ arr [ $ j ] ) ) $ LIS [ $ i ] = max ( $ LIS [ $ i ] , $ LIS [ $ j ] + 1 ) ; $ len = max ( $ len , $ LIS [ $ i ] ) ; } return $ n - $ len ; }

BLEU: 80.56
Edit Sim: 65


Src: 
function countNumbers ( N ) { return parseInt ( ( Math . pow ( 10 , N ) - Math . pow ( 8 , N ) ) / 2 , 10 ) ; }
Ref: 
function countNumbers ( $ N ) { return ( pow ( 10 , $ N ) - pow ( 8 , $ N ) ) / 2 ; }
Hyp: 
function countNumbers ( $ N ) { return ( pow ( 10 , $ N ) - pow ( 8 , $ N ) ) / 2 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function productAscii ( str ) { var prod = 1 ; for ( i = 0 ; i < str . length ; i ++ ) { prod *= str . charAt ( i ) . charCodeAt ( 0 ) ; } return prod ; }
Ref: 
function productAscii ( $ str ) { $ prod = 1 ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) { $ prod *= ord ( $ str [ $ i ] ) ; } return $ prod ; }
Hyp: 
function productAscii ( $ str ) { $ prod = 1 ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) { $ prod *= ord ( $ str [ $ i ] ) ; } return $ prod ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function mixtureConcentration ( n , p ) { var res = 0 ; for ( var i = 0 ; i < n ; i ++ ) res += p [ i ] ; res /= n ; return res ; }
Ref: 
function mixtureConcentration ( $ n , $ p ) { $ res = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ res += $ p [ $ i ] ; $ res /= $ n ; return $ res ; }
Hyp: 
function mixtureConcentration ( $ n , $ p ) { $ res = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ res += $ p [ $ i ] ; $ res /= $ n ; return $ res ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findThirdDigit ( n ) { if ( n < 3 ) return 0 ; return n & 1 ? 1 : 6 ; }
Ref: 
function findThirdDigit ( $ n ) { if ( $ n < 3 ) return 0 ; return $ n & 1 ? 1 : 6 ; }
Hyp: 
function findThirdDigit ( $ n ) { if ( $ n < 3 ) return 0 ; return $ n & 1 ? 1 : 6 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function evenPowerSum ( n ) { return ( 8 * n * ( n + 1 ) * ( 2 * n + 1 ) * ( 3 * n * n + 3 * n - 1 ) ) / 15 ; }
Ref: 
function evenPowerSum ( $ n ) { return ( 8 * $ n * ( $ n + 1 ) * ( 2 * $ n + 1 ) * ( 3 * $ n * $ n + 3 * $ n - 1 ) ) / 15 ; }
Hyp: 
function evenPowerSum ( $ n ) { return ( 8 * $ n * ( $ n + 1 ) * ( 2 * $ n + 1 ) * ( 3 * $ n * $ n + 3 * $ n - 1 ) ) / 15 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function find_distance ( n ) { return n * ( 3 * n + 7 ) ; }
Ref: 
function find_distance ( $ n ) { return $ n * ( ( 3 * $ n ) + 7 ) ; }
Hyp: 
function find_distance ( $ n ) { return $ n * ( 3 * $ n + 7 ) ; }

BLEU: 79.9
Edit Sim: 4


Src: 
function LowerInsertionPoint ( arr , n , X ) { if ( X < arr [ 0 ] ) return 0 ; else if ( X > arr [ n - 1 ] ) return n ; let lowerPnt = 0 ; let i = 1 ; while ( i < n && arr [ i ] < X ) { lowerPnt = i ; i = i * 2 ; } while ( lowerPnt < n && arr [ lowerPnt ] < X ) lowerPnt ++ ; return lowerPnt ; }
Ref: 
function LowerInsertionPoint ( $ arr , $ n , $ X ) { if ( $ X < $ arr [ 0 ] ) return 0 ; else if ( $ X > $ arr [ $ n - 1 ] ) return $ n ; $ lowerPnt = 0 ; $ i = 1 ; while ( $ i < $ n && $ arr [ $ i ] < $ X ) { $ lowerPnt = $ i ; $ i = $ i * 2 ; } while ( $ lowerPnt < $ n && $ arr [ $ lowerPnt ] < $ X ) $ lowerPnt ++ ; return $ lowerPnt ; }
Hyp: 
function LowerInsertionPoint ( $ arr , $ n , $ X ) { if ( $ X < $ arr [ 0 ] ) return 0 ; else if ( $ X > $ arr [ $ n - 1 ] ) return $ n ; $ lowerPnt = 0 ; $ i = 1 ; while ( $ i < $ n and $ arr [ $ i ] < $ X ) { $ lowerPnt = $ i ; $ i = $ i * 2 ; } while ( $ lowerPnt < $ n and $ arr [ $ lowerPnt ] < $ X ) $ lowerPnt ++ ; return $ lowerPnt ; }

BLEU: 95.67
Edit Sim: 6


Src: 
function maxRepeating ( arr , n , k ) { for ( let i = 0 ; i < n ; i ++ ) arr [ arr [ i ] % k ] += k ; let max = arr [ 0 ] , result = 0 ; for ( let i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > max ) { max = arr [ i ] ; result = i ; } } return result ; }
Ref: 
function maxRepeating ( $ arr , $ n , $ k ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ arr [ $ arr [ $ i ] % $ k ] += $ k ; $ max = $ arr [ 0 ] ; $ result = 0 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] > $ max ) { $ max = $ arr [ $ i ] ; $ result = $ i ; } } return $ result ; }
Hyp: 
function maxRepeating ( $ arr , $ n , $ k ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ arr [ $ arr [ $ i ] % $ k ] += $ k ; $ max = $ arr [ 0 ] ; $ result = 0 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] > $ max ) { $ max = $ arr [ $ i ] ; $ result = $ i ; } } return $ result ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function maxResult ( n , a , b , c ) { let maxVal = 0 ; for ( let i = 0 ; i <= n ; i += a ) for ( let j = 0 ; j <= n - i ; j += b ) { let z = ( n - ( i + j ) ) / c ; if ( Math . floor ( z ) == Math . ceil ( z ) ) { let x = i / a ; let y = j / b ; maxVal = Math . max ( maxVal , x + y + z ) ; } } return maxVal ; }
Ref: 
function maxResult ( $ n , $ a , $ b , $ c ) { $ maxVal = 0 ; for ( $ i = 0 ; $ i <= $ n ; $ i += $ a ) for ( $ j = 0 ; $ j <= $ n - $ i ; $ j += $ b ) { $ z = ( $ n - ( $ i + $ j ) ) / $ c ; if ( floor ( $ z ) == ceil ( $ z ) ) { $ x = ( int ) ( $ i / $ a ) ; $ y = ( int ) ( $ j / $ b ) ; $ maxVal = max ( $ maxVal , $ x + $ y + ( int ) $ z ) ; } } return $ maxVal ; }
Hyp: 
function maxResult ( $ n , $ a , $ b , $ c ) { $ maxVal = 0 ; for ( $ i = 0 ; $ i <= $ n ; $ i += $ a ) for ( $ j = 0 ; $ j <= $ n - $ i ; $ j += $ b ) { $ z = ( $ n - ( $ i + $ j ) ) / $ c ; if ( floor ( $ z ) == ceil ( $ z ) ) { $ x = $ i / $ a ; $ y = $ j / $ b ; $ maxVal = max ( $ maxVal , $ x + $ y + $ z ) ; } } return $ maxVal ; }

BLEU: 86.12
Edit Sim: 32


Src: 
function evenFibSum ( limit ) { if ( limit < 2 ) return 0 ; let ef1 = 0 , ef2 = 2 ; let sum = ef1 + ef2 ; while ( ef2 <= limit ) { let ef3 = 4 * ef2 + ef1 ; if ( ef3 > limit ) break ; ef1 = ef2 ; ef2 = ef3 ; sum += ef2 ; } return sum ; }
Ref: 
function evenFibSum ( $ limit ) { if ( $ limit < 2 ) return 0 ; $ ef1 = 0 ; $ ef2 = 2 ; $ sum = $ ef1 + $ ef2 ; while ( $ ef2 <= $ limit ) { $ ef3 = 4 * $ ef2 + $ ef1 ; if ( $ ef3 > $ limit ) break ; $ ef1 = $ ef2 ; $ ef2 = $ ef3 ; $ sum += $ ef2 ; } return $ sum ; }
Hyp: 
function evenFibSum ( $ limit ) { if ( $ limit < 2 ) return 0 ; $ ef1 = 0 ; $ ef2 = 2 ; $ sum = $ ef1 + $ ef2 ; while ( $ ef2 <= $ limit ) { $ ef3 = 4 * $ ef2 + $ ef1 ; if ( $ ef3 > $ limit ) break ; $ ef1 = $ ef2 ; $ ef2 = $ ef3 ; $ sum += $ ef2 ; } return $ sum ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function getMaxMedian ( arr , n , k ) { let size = n + k ; arr . sort ( ( a , b ) => a - b ) ; if ( size % 2 == 0 ) { let median = ( arr [ Math . floor ( size / 2 ) - 1 ] + arr [ Math . floor ( size / 2 ) ] ) / 2 ; return median ; } let median = arr [ Math . floor ( size / 2 ) ] ; return median ; }
Ref: 
function getMaxMedian ( $ arr , $ n , $ k ) { $ size = $ n + $ k ; sort ( $ arr , $ n ) ; if ( $ size % 2 == 0 ) { $ median = ( float ) ( $ arr [ ( $ size / 2 ) - 1 ] + $ arr [ $ size / 2 ] ) / 2 ; return $ median ; } $ median = $ arr [ $ size / 2 ] ; return $ median ; }
Hyp: 
function getMaxMedian ( $ arr , $ n , $ k ) { $ size = $ n + $ k ; sort ( $ arr ) ; if ( $ size % 2 == 0 ) { $ median = ( $ arr [ $ size / 2 ] - 1 ] + $ arr [ $ size / 2 ] ) / 2 ; return $ median ; } $ median = $ arr [ $ size / 2 ] ; return $ median ; }

BLEU: 85.58
Edit Sim: 19


Src: 
function icosidigonal_num ( n ) { return parseInt ( ( 20 * n * n - 18 * n ) / 2 ) ; }
Ref: 
function icosidigonal_num ( $ n ) { return ( 20 * $ n * $ n - 18 * $ n ) / 2 ; }
Hyp: 
function icosidigonal_num ( $ n ) { return ( 20 * $ n * $ n - 18 * $ n ) / 2 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function timeToMeet ( s , v ) { var V = 3 * v / 2 ; var time = s / V ; document . write ( time . toFixed ( 6 ) ) ; }
Ref: 
function timeToMeet ( $ s , $ v ) { $ V = 3 * $ v / 2 ; $ time = $ s / $ V ; echo $ time ; }
Hyp: 
function timeToMeet ( $ s , $ v ) { $ V = 3 * $ v / 2 ; $ time = $ s / $ V ; echo round ( $ time , 6 ) ; }

BLEU: 80.24
Edit Sim: 14


Src: 
function Perimeter ( s , n ) { var perimeter = 1 ; perimeter = n * s ; return perimeter ; }
Ref: 
function Perimeter ( $ s , $ n ) { $ perimeter = 1 ; $ perimeter = $ n * $ s ; return $ perimeter ; }
Hyp: 
function Perimeter ( $ s , $ n ) { $ perimeter = 1 ; $ perimeter = $ n * $ s ; return $ perimeter ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function max_min ( a , n ) { a . sort ( ) ; return Math . min ( a [ n - 2 ] - a [ 0 ] , a [ n - 1 ] - a [ 1 ] ) ; }
Ref: 
function max_min ( & $ a , $ n ) { sort ( $ a ) ; return min ( $ a [ $ n - 2 ] - $ a [ 0 ] , $ a [ $ n - 1 ] - $ a [ 1 ] ) ; }
Hyp: 
function max_min ( $ a , $ n ) { sort ( $ a ) ; return min ( $ a [ $ n - 2 ] - $ a [ 0 ] , $ a [ $ n - 1 ] - $ a [ 1 ] ) ; }

BLEU: 95.07
Edit Sim: 2


Src: 
function maxDiff ( arr , n ) { var result = 0 ; arr . sort ( ( a , b ) => a - b ) for ( var i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] != arr [ i + 1 ] ) result += Math . abs ( arr [ i ] ) ; else i ++ ; } if ( arr [ n - 2 ] != arr [ n - 1 ] ) result += Math . abs ( arr [ n - 1 ] ) ; return result ; }
Ref: 
function maxDiff ( $ arr , $ n ) { $ result = 0 ; sort ( $ arr ) ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { if ( $ arr [ $ i ] != $ arr [ $ i + 1 ] ) $ result += abs ( $ arr [ $ i ] ) ; else $ i ++ ; } if ( $ arr [ $ n - 2 ] != $ arr [ $ n - 1 ] ) $ result += abs ( $ arr [ $ n - 1 ] ) ; return $ result ; }
Hyp: 
function maxDiff ( $ arr , $ n ) { $ result = 0 ; sort ( $ arr ) ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { if ( $ arr [ $ i ] != $ arr [ $ i + 1 ] ) $ result += abs ( $ arr [ $ i ] ) ; else $ i ++ ; } if ( $ arr [ $ n - 2 ] != $ arr [ $ n - 1 ] ) $ result += abs ( $ arr [ $ n - 1 ] ) ; return $ result ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findFlips ( str , n ) { var last = ' ' ; var res = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( last != str . charAt ( i ) ) res ++ ; last = str . charAt ( i ) ; } return parseInt ( res / 2 ) ; }
Ref: 
function findFlips ( $ str , $ n ) { $ last = ' ▁ ' ; $ res = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ last != $ str [ $ i ] ) $ res ++ ; $ last = $ str [ $ i ] ; } return intval ( $ res / 2 ) ; }
Hyp: 
function findFlips ( $ str , $ n ) { $ last = ' a ' ; $ res = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ last != $ str [ $ i ] ) $ res ++ ; $ last = $ str [ $ i ] ; } return ( int ) $ res / 2 ; }

BLEU: 89.66
Edit Sim: 9


Src: 
function calculateSum ( n ) { return n * ( n + 1 ) / 2 + n * ( n + 1 ) * ( 2 * n + 1 ) / 6 ; }
Ref: 
function calculateSum ( $ n ) { return $ n * ( $ n + 1 ) / 2 + $ n * ( $ n + 1 ) * ( 2 * $ n + 1 ) / 6 ; }
Hyp: 
function calculateSum ( $ n ) { return $ n * ( $ n + 1 ) / 2 + $ n * ( $ n + 1 ) * ( 2 * $ n + 1 ) / 6 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function getMinSquares ( n ) { if ( n <= 3 ) return n ; var dp = new Array ( n + 1 ) ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; dp [ 2 ] = 2 ; dp [ 3 ] = 3 ; for ( var i = 4 ; i <= n ; i ++ ) { dp [ i ] = i ; for ( var x = 1 ; x <= Math . ceil ( Math . sqrt ( i ) ) ; x ++ ) { var temp = x * x ; if ( temp > i ) break ; else dp [ i ] = Math . min ( dp [ i ] , 1 + dp [ i - temp ] ) ; } } var res = dp [ n ] ; return res ; }
Ref: 
function getMinSquares ( $ n ) { $ dp ; $ dp [ 0 ] = 0 ; $ dp [ 1 ] = 1 ; $ dp [ 2 ] = 2 ; $ dp [ 3 ] = 3 ; for ( $ i = 4 ; $ i <= $ n ; $ i ++ ) { $ dp [ $ i ] = $ i ; for ( $ x = 1 ; $ x <= ceil ( sqrt ( $ i ) ) ; $ x ++ ) { $ temp = $ x * $ x ; if ( $ temp > $ i ) break ; else $ dp [ $ i ] = min ( $ dp [ $ i ] , ( 1 + $ dp [ $ i - $ temp ] ) ) ; } } $ res = $ dp [ $ n ] ; return $ res ; }
Hyp: 
function getMinSquares ( $ n ) { if ( $ n <= 3 ) return $ n ; $ dp = array_fill ( 0 , $ n + 1 , NULL ) ; $ dp [ 0 ] = 0 ; $ dp [ 1 ] = 1 ; $ dp [ 2 ] = 2 ; $ dp [ 3 ] = 3 ; for ( $ i = 4 ; $ i <= $ n ; $ i ++ ) { $ dp [ $ i ] = $ i ; for ( $ x = 1 ; $ x <= ceil ( sqrt ( $ i ) ) ; $ x ++ ) { $ temp = $ x * $ x ; if ( $ temp > $ i ) break ; else $ dp [ $ i ] = min ( $ dp [ $ i ] , 1 + $ dp [ $ i - $ temp ] ) ; } } $ res = $ dp [ $ n ] ; return $ res ; }

BLEU: 84.88
Edit Sim: 69


Src: 
function subArray ( n ) { for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i ; j < n ; j ++ ) { for ( let k = i ; k <= j ; k ++ ) document . write ( arr [ k ] + " " ) ; document . write ( " " ) ; } } }
Ref: 
function subArray ( $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = $ i ; $ j < $ n ; $ j ++ ) { for ( $ k = $ i ; $ k <= $ j ; $ k ++ ) echo $ arr [ $ k ] , " ▁ " ; echo " STRNEWLINE " ; } } }
Hyp: 
function subArray ( $ n , $ arr ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = $ i ; $ j < $ n ; $ j ++ ) { for ( $ k = $ i ; $ k <= $ j ; $ k ++ ) echo $ arr [ $ k ] . " ▁ " ; echo " STRNEWLINE " ; } } }

BLEU: 92.42
Edit Sim: 7


Src: 
function minDistance ( n1 , n2 ) { var bitCount1 = Math . floor ( Math . log2 ( n1 ) ) + 1 ; var bitCount2 = Math . floor ( Math . log2 ( n2 ) ) + 1 ; var bitDiff = Math . abs ( bitCount1 - bitCount2 ) ; var maxBitCount = Math . max ( bitCount1 , bitCount2 ) ; if ( bitCount1 > bitCount2 ) { n2 = n2 * Math . pow ( 2 , bitDiff ) ; } else { n1 = n1 * Math . pow ( 2 , bitDiff ) ; } var xorValue = n1 ^ n2 ; var bitCountXorValue ; if ( xorValue == 0 ) bitCountXorValue = 1 ; else { bitCountXorValue = Math . floor ( Math . log2 ( xorValue ) ) + 1 ; } var disSimilarBitPosition = maxBitCount - bitCountXorValue ; var result = bitCount1 + bitCount2 - 2 * disSimilarBitPosition ; return result ; }
Ref: 
function minDistance ( $ n1 , $ n2 ) { $ bitCount1 = floor ( log ( $ n1 , 2 ) ) + 1 ; $ bitCount2 = floor ( log ( $ n2 , 2 ) ) + 1 ; $ bitDiff = abs ( $ bitCount1 - $ bitCount2 ) ; $ maxBitCount = max ( $ bitCount1 , $ bitCount2 ) ; if ( $ bitCount1 > $ bitCount2 ) { $ n2 = $ n2 * pow ( 2 , $ bitDiff ) ; } else { $ n1 = $ n1 * pow ( 2 , $ bitDiff ) ; } $ xorValue = $ n1 ^ $ n2 ; $ bitCountXorValue = floor ( log ( $ xorValue , 2 ) ) + 1 ; $ disSimilarBitPosition = $ maxBitCount - $ bitCountXorValue ; $ result = $ bitCount1 + $ bitCount2 - 2 * $ disSimilarBitPosition ; return $ result ; }
Hyp: 
function minDistance ( $ n1 , $ n2 ) { $ bitCount1 = log2 ( $ n1 ) + 1 ; $ bitCount2 = log2 ( $ n2 ) + 1 ; $ bitDiff = abs ( $ bitCount1 - $ bitCount2 ) ; $ maxBitCount = max ( $ bitCount1 , $ bitCount2 ) ; if ( $ bitCount1 > $ bitCount2 ) { $ n2 = $ n2 * pow ( 2 , $ bitDiff ) ; } else { $ n1 = $ n1 * pow ( 2 , $ bitDiff ) ; } $ xorValue = $ n1 ^ $ n2 ; $ bitCountXorValue ; if ( $ xorValue == 0 ) $ bitCountXorValue = 1 ; else { $ bitCountXorValue = log2 ( $ xorValue ) + 1 ; } $ disSimilarBitPosition = $ maxBitCount - $ bitCountXorValue ; $ result = $ bitCount1 + $ bitCount2 - 2 * $ disSimilarBitPosition ; return $ result ; }

BLEU: 80.54
Edit Sim: 103


Src: 
function minRadius ( k , x , y , n ) { let dis = Array . from ( { length : n } , ( _ , i ) => 0 ) ; for ( let i = 0 ; i < n ; i ++ ) dis [ i ] = x [ i ] * x [ i ] + y [ i ] * y [ i ] ; dis . sort ( ) ; return dis [ k - 1 ] ; }
Ref: 
function minRadius ( $ k , $ x , $ y , $ n ) { $ dis = array ( ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ dis [ $ i ] = $ x [ $ i ] * $ x [ $ i ] + $ y [ $ i ] * $ y [ $ i ] ; sort ( $ dis ) ; return $ dis [ $ k - 1 ] ; }
Hyp: 
function minRadius ( $ k , $ x , $ y , $ n ) { $ dis = array ( ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ dis [ $ i ] = $ x [ $ i ] * $ x [ $ i ] + $ y [ $ i ] * $ y [ $ i ] ; rsort ( $ dis ) ; return $ dis [ $ k - 1 ] ; }

BLEU: 97.24
Edit Sim: 1


Src: 
function getBoundarySum ( a , m , n ) { let sum = 0 ; for ( let i = 0 ; i < m ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { if ( i == 0 ) sum += a [ i ] [ j ] ; else if ( i == m - 1 ) sum += a [ i ] [ j ] ; else if ( j == 0 ) sum += a [ i ] [ j ] ; else if ( j == n - 1 ) sum += a [ i ] [ j ] ; } } return sum ; }
Ref: 
function getBoundarySum ( $ a , $ m , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ m ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ i == 0 ) $ sum += $ a [ $ i ] [ $ j ] ; else if ( $ i == $ m - 1 ) $ sum += $ a [ $ i ] [ $ j ] ; else if ( $ j == 0 ) $ sum += $ a [ $ i ] [ $ j ] ; else if ( $ j == $ n - 1 ) $ sum += $ a [ $ i ] [ $ j ] ; } } return $ sum ; }
Hyp: 
function getBoundarySum ( $ a , $ m , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ m ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ i == 0 ) $ sum += $ a [ $ i ] [ $ j ] ; else if ( $ i == $ m - 1 ) $ sum += $ a [ $ i ] [ $ j ] ; else if ( $ j == $ n - 1 ) $ sum += $ a [ $ i ] [ $ j ] ; } } return $ sum ; }

BLEU: 84.65
Edit Sim: 52


Src: 
function trianglearea ( r ) { if ( r < 0 ) return - 1 ; return r * r ; }
Ref: 
function trianglearea ( $ r ) { if ( $ r < 0 ) return -1 ; return $ r * $ r ; }
Hyp: 
function trianglearea ( $ r ) { if ( $ r < 0 ) return -1 ; return $ r * $ r ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function pairORSum ( arr , n ) { for ( var i = 0 ; i < n ; i ++ ) for ( var j = i + 1 ; j < n ; j ++ ) ans += arr [ i ] | arr [ j ] ; return ans ; }
Ref: 
function pairORSum ( $ arr , $ n ) { $ ans = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) $ ans += $ arr [ $ i ] | $ arr [ $ j ] ; return $ ans ; }
Hyp: 
function pairORSum ( $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) $ ans += $ arr [ $ i ] | $ arr [ $ j ] ; return $ ans ; }

BLEU: 90.93
Edit Sim: 12


Src: 
function areaSquare ( side ) { let area = side * side ; return area ; }
Ref: 
function areaSquare ( $ side ) { $ area = $ side * $ side ; return $ area ; }
Hyp: 
function areaSquare ( $ side ) { $ area = $ side * $ side ; return $ area ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function SubseqWidths ( A , n ) { A . sort ( ( a , b ) => a - b ) var pow2 = Array ( n ) . fill ( 0 ) ; pow2 [ 0 ] = 1 ; for ( var i = 1 ; i < n ; ++ i ) pow2 [ i ] = ( pow2 [ i - 1 ] * 2 ) % MOD ; var ans = 0 ; for ( var i = 0 ; i < n ; ++ i ) ans = ( ans + ( pow2 [ i ] - pow2 [ n - 1 - i ] ) * A [ i ] ) % MOD ; return ans ; }
Ref: 
function SubseqWidths ( & $ A , $ n ) { global $ MOD ; sort ( $ A ) ; $ pow2 = array_fill ( 0 , $ n , NULL ) ; $ pow2 [ 0 ] = 1 ; for ( $ i = 1 ; $ i < $ n ; ++ $ i ) $ pow2 [ $ i ] = ( $ pow2 [ $ i - 1 ] * 2 ) % $ MOD ; $ ans = 0 ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) $ ans = ( $ ans + ( $ pow2 [ $ i ] - $ pow2 [ $ n - 1 - $ i ] ) * $ A [ $ i ] ) % $ MOD ; return $ ans ; }
Hyp: 
function SubseqWidths ( $ A , $ n ) { rsort ( $ A ) ; $ pow2 [ $ n ] = 0 ; $ pow2 [ 0 ] = 1 ; for ( $ i = 1 ; $ i < $ n ; ++ $ i ) $ pow2 [ $ i ] = ( $ pow2 [ $ i - 1 ] * 2 ) % $ MOD ; $ ans = 0 ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) $ ans = ( $ ans + ( $ pow2 [ $ i ] - $ pow2 [ $ n - 1 - $ i ] ) * $ A [ $ i ] ) % $ MOD ; return $ ans ; }

BLEU: 86.7
Edit Sim: 41


Src: 
function CntDivbyX ( arr , n , x ) { let number = 0 ; let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { number = ( number * 2 + arr [ i ] ) % x ; if ( number == 0 ) count += 1 ; } return count ; }
Ref: 
function CntDivbyX ( $ arr , $ n , $ x ) { $ number = 0 ; $ count1 = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ number = ( $ number * 2 + $ arr [ $ i ] ) % $ x ; if ( $ number == 0 ) $ count1 += 1 ; } return $ count1 ; }
Hyp: 
function CntDivbyX ( $ arr , $ n , $ x ) { $ number = 0 ; $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ number = ( $ number * 2 + $ arr [ $ i ] ) % $ x ; if ( $ number == 0 ) $ count += 1 ; } return $ count ; }

BLEU: 90.62
Edit Sim: 3


Src: 
function heightCalculate ( H , n , m ) { let N = n * 1.0 ; let M = m * 1.0 ; let h = H * Math . sqrt ( N / ( N + M ) ) ; return h ; }
Ref: 
function heightCalculate ( $ H , $ n , $ m ) { $ N = $ n * 1.0 ; $ M = $ m * 1.0 ; $ h = $ H * sqrt ( $ N / ( $ N + $ M ) ) ; return $ h ; }
Hyp: 
function heightCalculate ( $ H , $ n , $ m ) { $ N = $ n * 1.0 ; $ M = $ m * 1.0 ; $ h = $ H * sqrt ( $ N / ( $ N + $ M ) ) ; return $ h ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function printGP ( a , r , n ) { let curr_term ; for ( let i = 0 ; i < n ; i ++ ) { curr_term = a * Math . pow ( r , i ) ; document . write ( curr_term + " " ) ; } }
Ref: 
function printGP ( $ a , $ r , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ curr_term = $ a * pow ( $ r , $ i ) ; echo $ curr_term , " " ; } }
Hyp: 
function printGP ( $ a , $ r , $ n ) { $ curr_term ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ curr_term = $ a * pow ( $ r , $ i ) ; echo $ curr_term . " ▁ " ; } }

BLEU: 84.82
Edit Sim: 17


Src: 
function printClosest ( ar1 , ar2 , m , n , x ) { let diff = Number . MAX_VALUE ; let res_l , res_r ; let l = 0 , r = n - 1 ; while ( l < m && r >= 0 ) { if ( Math . abs ( ar1 [ l ] + ar2 [ r ] - x ) < diff ) { res_l = l ; res_r = r ; diff = Math . abs ( ar1 [ l ] + ar2 [ r ] - x ) ; } if ( ar1 [ l ] + ar2 [ r ] > x ) r -- ; else l ++ ; } document . write ( " " + ar1 [ res_l ] + " " + ar2 [ res_r ] + " " ) ; }
Ref: 
function printClosest ( $ ar1 , $ ar2 , $ m , $ n , $ x ) { $ diff = PHP_INT_MAX ; $ res_l ; $ res_r ; $ l = 0 ; $ r = $ n - 1 ; while ( $ l < $ m and $ r >= 0 ) { if ( abs ( $ ar1 [ $ l ] + $ ar2 [ $ r ] - $ x ) < $ diff ) { $ res_l = $ l ; $ res_r = $ r ; $ diff = abs ( $ ar1 [ $ l ] + $ ar2 [ $ r ] - $ x ) ; } if ( $ ar1 [ $ l ] + $ ar2 [ $ r ] > $ x ) $ r -- ; else $ l ++ ; } echo " The ▁ closest ▁ pair ▁ is ▁ [ " , $ ar1 [ $ res_l ] , " , ▁ " , $ ar2 [ $ res_r ] , " ] ▁ STRNEWLINE " ; }
Hyp: 
function printClosest ( $ ar1 , $ ar2 , $ m , $ n , $ x ) { $ diff = PHP_INT_MAX ; $ res_l ; $ res_r ; $ l = 0 ; $ r = $ n - 1 ; while ( $ l < $ m && $ r >= 0 ) { if ( abs ( $ ar1 [ $ l ] + $ ar2 [ $ r ] - $ x ) < $ diff ) { $ res_l = $ l ; $ res_r = $ r ; $ diff = abs ( $ ar1 [ $ l ] + $ ar2 [ $ r ] - $ x ) ; } if ( $ ar1 [ $ l ] + $ ar2 [ $ r ] > $ x ) $ r -- ; else $ l ++ ; } echo " Closest ▁ is ▁ " , $ ar1 [ $ res_l ] , " ▁ is ▁ " , $ ar2 [ $ res_r ] , " STRNEWLINE " ; }

BLEU: 90.63
Edit Sim: 27


Src: 
function isMultipleof5 ( n ) { while ( n > 0 ) n = n - 5 ; if ( n == 0 ) return true ; return false ; }
Ref: 
function isMultipleof5 ( $ n ) { while ( $ n > 0 ) $ n = $ n - 5 ; if ( $ n == 0 ) return true ; return false ; }
Hyp: 
function isMultipleof5 ( $ n ) { while ( $ n > 0 ) $ n = $ n - 5 ; if ( $ n == 0 ) return true ; return false ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function minCost ( N , P , Q ) { var cost = 0 ; while ( N > 0 ) { if ( N & 1 ) { cost += P ; N -- ; } else { var temp = parseInt ( N / 2 ) ; if ( temp * P > Q ) cost += Q ; else cost += P * temp ; N = parseInt ( N / 2 ) ; } } return cost ; }
Ref: 
function minCost ( $ N , $ P , $ Q ) { $ cost = 0 ; while ( $ N > 0 ) { if ( $ N & 1 ) { $ cost += $ P ; $ N -- ; } else { $ temp = $ N / 2 ; if ( $ temp * $ P > $ Q ) $ cost += $ Q ; else $ cost += $ P * $ temp ; $ N /= 2 ; } } return $ cost ; }
Hyp: 
function minCost ( $ N , $ P , $ Q ) { $ cost = 0 ; while ( $ N > 0 ) { if ( $ N & 1 ) { $ cost += $ P ; $ N -- ; } else { $ temp = $ N / 2 ; if ( $ temp * $ P > $ Q ) $ cost += $ Q ; else $ cost += $ P * $ temp ; $ N = ( int ) $ N / 2 ; } } return $ cost ; }

BLEU: 91.44
Edit Sim: 15


Src: 
function calculateAlternateSum ( n ) { if ( n <= 0 ) return 0 ; var fibo = Array ( n + 1 ) . fill ( 0 ) ; fibo [ 0 ] = 0 ; fibo [ 1 ] = 1 ; var sum = Math . pow ( fibo [ 0 ] , 2 ) + Math . pow ( fibo [ 1 ] , 2 ) ; for ( i = 2 ; i <= n ; i ++ ) { fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ; if ( i % 2 == 0 ) sum -= fibo [ i ] ; else sum += fibo [ i ] ; } return sum ; }
Ref: 
function calculateAlternateSum ( $ n ) { if ( $ n <= 0 ) return 0 ; $ fibo = array ( ) ; $ fibo [ 0 ] = 0 ; $ fibo [ 1 ] = 1 ; $ sum = pow ( $ fibo [ 0 ] , 2 ) + pow ( $ fibo [ 1 ] , 2 ) ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { $ fibo [ $ i ] = $ fibo [ $ i - 1 ] + $ fibo [ $ i - 2 ] ; if ( $ i % 2 == 0 ) $ sum -= $ fibo [ $ i ] ; else $ sum += $ fibo [ $ i ] ; } return $ sum ; }
Hyp: 
function calculateAlternateSum ( $ n ) { if ( $ n <= 0 ) return 0 ; $ fibo = array_fill ( 0 , $ n + 1 , 0 ) ; $ fibo [ 0 ] = 0 ; $ fibo [ 1 ] = 1 ; $ sum = pow ( $ fibo [ 0 ] , 2 ) + pow ( $ fibo [ 1 ] , 2 ) ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { $ fibo [ $ i ] = $ fibo [ $ i - 1 ] + $ fibo [ $ i - 2 ] ; if ( $ i % 2 == 0 ) $ sum -= $ fibo [ $ i ] ; else $ sum += $ fibo [ $ i ] ; } return $ sum ; }

BLEU: 92.56
Edit Sim: 21


Src: 
function pow ( a , b ) { if ( b == 0 ) return 1 ; var answer = a ; var increment = a ; var i , j ; for ( i = 1 ; i < b ; i ++ ) { for ( j = 1 ; j < a ; j ++ ) { answer += increment ; } increment = answer ; } return answer ; }
Ref: 
function poww ( $ a , $ b ) { if ( $ b == 0 ) return 1 ; $ answer = $ a ; $ increment = $ a ; $ i ; $ j ; for ( $ i = 1 ; $ i < $ b ; $ i ++ ) { for ( $ j = 1 ; $ j < $ a ; $ j ++ ) { $ answer += $ increment ; } $ increment = $ answer ; } return $ answer ; }
Hyp: 
function pow ( $ a , $ b ) { if ( $ b == 0 ) return 1 ; $ answer = $ a ; $ increment = $ a ; $ i ; $ j ; for ( $ i = 1 ; $ i < $ b ; $ i ++ ) { for ( $ j = 1 ; $ j < $ a ; $ j ++ ) { $ answer += $ increment ; } $ increment = $ answer ; } return $ answer ; }

BLEU: 98.1
Edit Sim: 1


Src: 
function longestSubstring ( s ) { var cnt = 1 , maxi = 1 ; var n = s . length ; for ( i = 1 ; i < n ; i ++ ) { if ( s . charAt ( i ) != s . charAt ( i - 1 ) ) cnt ++ ; else { maxi = Math . max ( cnt , maxi ) ; cnt = 1 ; } } maxi = Math . max ( cnt , maxi ) ; return maxi ; }
Ref: 
function longestSubstring ( $ s ) { $ cnt = 1 ; $ maxi = 1 ; $ n = strlen ( $ s ) ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( $ s [ $ i ] != $ s [ $ i - 1 ] ) $ cnt ++ ; else { $ maxi = max ( $ cnt , $ maxi ) ; $ cnt = 1 ; } } $ maxi = max ( $ cnt , $ maxi ) ; return $ maxi ; }
Hyp: 
function longestSubstring ( $ s ) { $ cnt = 1 ; $ maxi = 1 ; $ n = strlen ( $ s ) ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( $ s [ $ i ] != $ s [ $ i - 1 ] ) $ cnt ++ ; else { $ maxi = max ( $ cnt , $ maxi ) ; $ cnt = 1 ; } } $ maxi = max ( $ cnt , $ maxi ) ; return $ maxi ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function ellipse ( l , b ) { if ( l < 0 b < 0 ) return - 1 ; var x = ( 3.14 * l * b ) / 4 ; return x ; }
Ref: 
function ellipse ( $ l , $ b ) { if ( $ l < 0 $ b < 0 ) return -1 ; $ x = ( 3.14 * $ l * $ b ) / 4 ; return $ x ; }
Hyp: 
function ellipse ( $ l , $ b ) { if ( $ l < 0 $ b < 0 ) return -1 ; $ x = ( 3.14 * $ l * $ b ) / 4 ; return $ x ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findGreater ( a , b , n ) { if ( ! ( ( n & 1 ) > 0 ) ) { a = Math . abs ( a ) ; b = Math . abs ( b ) ; } if ( a == b ) document . write ( " " + " " ) ; else if ( a > b ) document . write ( " " + " " ) ; else document . write ( " " + " " ) ; }
Ref: 
function findGreater ( $ a , $ b , $ n ) { if ( ! ( $ n & 1 ) ) { $ a = abs ( $ a ) ; $ b = abs ( $ b ) ; } if ( $ a == $ b ) echo " a ^ n ▁ is ▁ equal ▁ to ▁ b ^ n " ; else if ( $ a > $ b ) echo " a ^ n ▁ is ▁ greater ▁ than ▁ b ^ n " ; else echo " b ^ n ▁ is ▁ greater ▁ than ▁ a ^ n " ; }
Hyp: 
function findGreater ( $ a , $ b , $ n ) { if ( ! ( $ n & 1 ) ) { $ a = abs ( $ a ) ; $ b = abs ( $ b ) ; } if ( $ a == $ b ) echo " Greater " ; else if ( $ a > $ b ) echo " Greater " ; else echo " Not ▁ " ; }

BLEU: 56.92
Edit Sim: 89


Src: 
function minLettersNeeded ( n ) { if ( n % 26 == 0 ) return parseInt ( n / 26 ) ; else return ( parseInt ( n / 26 ) + 1 ) ; }
Ref: 
function minLettersNeeded ( $ n ) { if ( $ n % 26 == 0 ) return floor ( ( $ n / 26 ) ) ; else return floor ( ( $ n / 26 ) + 1 ) ; }
Hyp: 
function minLettersNeeded ( $ n ) { if ( $ n % 26 == 0 ) return ( int ) ( $ n / 26 ) ; else return ( ( int ) ( $ n / 26 ) + 1 ) ; }

BLEU: 76.67
Edit Sim: 16


Src: 
function printBinary ( num ) { if ( num >= 1 num <= 0 ) return " " ; let binary = " " ; let frac = 0.5 ; binary += " " ; while ( num > 0 ) { if ( binary . length >= 32 ) return " " ; if ( num >= frac ) { binary += " " ; num -= frac ; } else binary += " " ; frac = frac / 2 ; } return binary ; }
Ref: 
function toBinary ( $ n ) { if ( $ n >= 1 $ n <= 0 ) return " ERROR " ; $ frac = 0.5 ; $ answer = " . " ; while ( $ n > 0 ) { if ( strlen ( $ answer ) >= 32 ) return " ERROR " ; if ( $ n >= $ frac ) { $ answer . = "1" ; $ n = $ n - $ frac ; } else { $ answer . = "0" ; } $ frac = ( $ frac / 2 ) ; } return $ answer ; }
Hyp: 
function printBinary ( $ num ) { if ( $ num >= 1 $ num <= 0 ) return "0" ; $ binary = "0" ; $ frac = 0.5 ; $ binary += "0" ; while ( $ num > 0 ) { if ( $ binary . length >= 32 ) return "0" ; if ( $ num >= $ frac ) { $ binary += "0" ; $ num -= $ frac ; } else $ binary += "0" ; $ frac = $ frac / 2 ; } return $ binary ; }

BLEU: 38.3
Edit Sim: 103


Src: 
function binomialCoeff ( n , k ) { let C = new Array ( k + 1 ) ; C . fill ( 0 ) ; C [ 0 ] = 1 ; for ( let i = 1 ; i <= n ; i ++ ) { for ( let j = Math . min ( i , k ) ; j > 0 ; j -- ) C [ j ] = C [ j ] + C [ j - 1 ] ; } return C [ k ] ; }
Ref: 
function binomialCoeff ( $ n , $ k ) { $ C = array_fill ( 0 , $ k + 1 , 0 ) ; $ C [ 0 ] = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { for ( $ j = min ( $ i , $ k ) ; $ j > 0 ; $ j -- ) $ C [ $ j ] = $ C [ $ j ] + $ C [ $ j - 1 ] ; } return $ C [ $ k ] ; }
Hyp: 
function binomialCoeff ( $ n , $ k ) { $ C [ $ k + 1 ] = 0 ; $ C [ 0 ] = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { for ( $ j = min ( $ i , $ k ) ; $ j > 0 ; $ j -- ) $ C [ $ j ] = $ C [ $ j ] + $ C [ $ j - 1 ] ; } return $ C [ $ k ] ; }

BLEU: 90.02
Edit Sim: 21


Src: 
function check ( a , n ) { for ( var i = 0 ; i < n ; i ++ ) if ( a [ i ] ) return true ; return false ; }
Ref: 
function check ( $ a , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ a [ $ i ] ) return true ; return false ; }
Hyp: 
function check ( $ a , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ a [ $ i ] ) return true ; return false ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countFriendsPairings ( n ) { let dp = [ ] ; for ( let i = 0 ; i <= n ; i ++ ) { if ( i <= 2 ) dp [ i ] = i ; else dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; } return dp [ n ] ; }
Ref: 
function countFriendsPairings ( $ n ) { $ dp [ $ n + 1 ] = 0 ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) { if ( $ i <= 2 ) $ dp [ $ i ] = $ i ; else $ dp [ $ i ] = $ dp [ $ i - 1 ] + ( $ i - 1 ) * $ dp [ $ i - 2 ] ; } return $ dp [ $ n ] ; }
Hyp: 
function countFriendsPairings ( $ n ) { $ dp = array ( ) ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) { if ( $ i <= 2 ) $ dp [ $ i ] = $ i ; else $ dp [ $ i ] = $ dp [ $ i - 1 ] + ( $ i - 1 ) * $ dp [ $ i - 2 ] ; } return $ dp [ $ n ] ; }

BLEU: 90.22
Edit Sim: 12


Src: 
function Area ( a , b ) { if ( a < 0 && b < 0 ) return - 1 ; let h = Math . sqrt ( ( ( Math . pow ( a , 2 ) + Math . pow ( b , 2 ) ) / ( Math . pow ( a , 2 ) * Math . pow ( b , 2 ) ) ) ) ; let A = 0.70477 * Math . pow ( h , 2 ) ; return A ; }
Ref: 
function Area ( $ a , $ b ) { if ( $ a < 0 && $ b < 0 ) return -1 ; $ h = sqrt ( ( ( pow ( $ a , 2 ) + pow ( $ b , 2 ) ) / ( pow ( $ a , 2 ) * pow ( $ b , 2 ) ) ) ) ; $ A = 0.70477 * pow ( $ h , 2 ) ; return $ A ; }
Hyp: 
function Area ( $ a , $ b ) { if ( $ a < 0 && $ b < 0 ) return -1 ; $ h = sqrt ( ( ( pow ( $ a , 2 ) + pow ( $ b , 2 ) ) / ( pow ( $ a , 2 ) * pow ( $ b , 2 ) ) ) ; $ A = 0.70477 * pow ( $ h , 2 ) ; return $ A ; }

BLEU: 98.84
Edit Sim: 2


Src: 
function findRectNum ( n ) { return n * ( n + 1 ) ; }
Ref: 
function findRectNum ( $ n ) { return $ n * ( $ n + 1 ) ; }
Hyp: 
function findRectNum ( $ n ) { return $ n * ( $ n + 1 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function getRemainder ( num , divisor ) { let t = ( num - divisor * parseInt ( num / divisor ) ) ; return t ; }
Ref: 
function getRemainder ( $ num , $ divisor ) { $ t = ( $ num - $ divisor * ( int ) ( $ num / $ divisor ) ) ; return $ t ; }
Hyp: 
function getRemainder ( $ num , $ divisor ) { $ t = ( $ num - $ divisor * ( int ) ( $ num / $ divisor ) ) ; return $ t ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function maxSum ( a , n ) { var maxAnd = Math . max ( ... a ) ; var maxOR = 0 ; for ( var i = 0 ; i < n ; i ++ ) { maxOR |= a [ i ] ; } document . write ( ( maxAnd + maxOR ) ) ; }
Ref: 
function maxSum ( $ a , $ n ) { $ maxAnd = max ( $ a ) ; $ maxOR = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ maxOR |= $ a [ $ i ] ; print ( $ maxAnd + $ maxOR ) ; }
Hyp: 
function maxSum ( $ a , $ n ) { $ maxAnd = max ( $ a ) ; $ maxOR = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ maxOR |= $ a [ $ i ] ; } echo ( $ maxAnd + $ maxOR ) ; }

BLEU: 90.25
Edit Sim: 8


Src: 
function countStr ( n , bCount , cCount ) { if ( bCount < 0 cCount < 0 ) return 0 ; if ( n == 0 ) return 1 ; if ( bCount == 0 && cCount == 0 ) return 1 ; let res = countStr ( n - 1 , bCount , cCount ) ; res += countStr ( n - 1 , bCount - 1 , cCount ) ; res += countStr ( n - 1 , bCount , cCount - 1 ) ; return res ; }
Ref: 
function countStr ( $ n , $ bCount , $ cCount ) { if ( $ bCount < 0 $ cCount < 0 ) return 0 ; if ( $ n == 0 ) return 1 ; if ( $ bCount == 0 && $ cCount == 0 ) return 1 ; $ res = countStr ( $ n - 1 , $ bCount , $ cCount ) ; $ res += countStr ( $ n - 1 , $ bCount - 1 , $ cCount ) ; $ res += countStr ( $ n - 1 , $ bCount , $ cCount - 1 ) ; return $ res ; }
Hyp: 
function countStr ( $ n , $ bCount , $ cCount ) { if ( $ bCount < 0 $ cCount < 0 ) return 0 ; if ( $ n == 0 ) return 1 ; if ( $ bCount == 0 && $ cCount == 0 ) return 1 ; $ res = countStr ( $ n - 1 , $ bCount , $ cCount ) ; $ res += countStr ( $ n - 1 , $ bCount - 1 , $ cCount ) ; $ res += countStr ( $ n - 1 , $ bCount , $ cCount - 1 ) ; return $ res ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findPair ( arr , n ) { let found = false ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i + 1 ; j < n ; j ++ ) { for ( let k = 0 ; k < n ; k ++ ) { if ( arr [ i ] + arr [ j ] == arr [ k ] ) { document . write ( arr [ i ] + " " + arr [ j ] + " " ) ; found = true ; } } } } if ( found == false ) document . write ( " " ) ; }
Ref: 
function findPair ( $ arr , $ n ) { $ found = false ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) { for ( $ k = 0 ; $ k < $ n ; $ k ++ ) { if ( $ arr [ $ i ] + $ arr [ $ j ] == $ arr [ $ k ] ) { echo $ arr [ $ i ] , " ▁ " , $ arr [ $ j ] ; $ found = true ; } } } } if ( $ found == false ) echo " Not ▁ exist " ; }
Hyp: 
function findPair ( & $ arr , $ n ) { $ found = false ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) { for ( $ k = 0 ; $ k < $ n ; $ k ++ ) { if ( $ arr [ $ i ] + $ arr [ $ j ] == $ arr [ $ k ] ) { echo ( $ arr [ $ i ] ) ; echo ( " ▁ " ) ; $ found = true ; } } } } if ( $ found == false ) echo " No ▁ such ▁ pair " ; }

BLEU: 86.41
Edit Sim: 31


Src: 
function quadrant ( x , y ) { if ( x > 0 && y > 0 ) document . write ( " " ) ; else if ( x < 0 && y > 0 ) document . write ( " " ) ; else if ( x < 0 && y < 0 ) document . write ( " " ) ; else if ( x > 0 && y < 0 ) document . write ( " " ) ; else if ( x == 0 && y > 0 ) document . write ( " " ) ; else if ( x == 0 && y < 0 ) document . write ( " " ) ; else if ( y == 0 && x < 0 ) document . write ( " " ) ; else if ( y == 0 && x > 0 ) document . write ( " " ) ; else document . write ( " " ) ; }
Ref: 
function quadrant ( $ x , $ y ) { if ( $ x > 0 and $ y > 0 ) echo ( " lies ▁ in ▁ First ▁ quadrant " ) ; else if ( $ x < 0 and $ y > 0 ) echo ( " lies ▁ in ▁ Second ▁ quadrant " ) ; else if ( $ x < 0 and $ y < 0 ) echo ( " lies ▁ in ▁ Third ▁ quadrant " ) ; else if ( $ x > 0 and $ y < 0 ) echo ( " lies ▁ in ▁ Fourth ▁ quadrant " ) ; else if ( $ x == 0 and $ y > 0 ) echo ( " lies ▁ at ▁ positive ▁ y ▁ axis " ) ; else if ( $ x == 0 and $ y < 0 ) echo ( " lies ▁ at ▁ negative ▁ y ▁ axis " ) ; else if ( $ y == 0 and $ x < 0 ) echo ( " lies ▁ at ▁ negative ▁ x ▁ axis " ) ; else if ( $ y == 0 and $ x > 0 ) echo ( " lies ▁ at ▁ positive ▁ x ▁ axis " ) ; else echo ( " lies ▁ at ▁ origin " ) ; }
Hyp: 
function quadrant ( $ x , $ y ) { if ( $ x > 0 && $ y > 0 ) echo " ( ) " ; else if ( $ x < 0 && $ y > 0 ) echo " ( ) " ; else if ( $ x < 0 && $ y < 0 ) echo " ( ) " ; else if ( $ x > 0 && $ y < 0 ) echo " ( ) " ; else if ( $ x == 0 && $ y > 0 ) echo " ( ) " ; else if ( $ x == 0 && $ y < 0 ) echo " ( ) " ; else if ( $ y == 0 && $ x < 0 ) echo " ) " ; else if ( $ y == 0 && $ x > 0 ) echo " ( ) " ; else echo " ( ) " ; }

BLEU: 40.78
Edit Sim: 308


Src: 
function printDuplicates ( arr , n ) { let i ; let fl = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ arr [ i ] % n ] >= n ) { if ( arr [ arr [ i ] % n ] < 2 * n ) { document . write ( arr [ i ] % n + " " ) ; fl = 1 ; } } arr [ arr [ i ] % n ] += n ; } if ( ! fl ) document . write ( " " ) ; }
Ref: 
function printDuplicates ( $ arr , $ n ) { $ i ; $ fl = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ arr [ $ i ] % $ n ] >= $ n ) { if ( $ arr [ $ arr [ $ i ] % $ n ] < 2 * $ n ) { echo $ arr [ $ i ] % $ n . " " ; $ fl = 1 ; } } $ arr [ $ arr [ $ i ] % $ n ] += $ n ; } if ( ! $ fl ) echo " - 1" ; }
Hyp: 
function printDuplicates ( & $ arr , $ n ) { $ i ; $ fl = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ arr [ $ i ] % $ n ] >= $ n ) { if ( $ arr [ $ arr [ $ i ] % $ n ] < 2 * $ n ) { echo $ arr [ $ i ] % $ n . " " ; $ fl = 1 ; } } $ arr [ $ arr [ $ i ] % $ n ] += $ n ; } if ( ! $ fl ) echo " No " ; }

BLEU: 95.53
Edit Sim: 5


Src: 
function distribution ( arr , n ) { arr . sort ( ( a , b ) => a - b ) ; var count = 1 ; for ( var i = 1 ; i < n ; i ++ ) if ( arr [ i ] > arr [ i - 1 ] ) count ++ ; return Math . min ( count , parseInt ( n / 2 ) ) ; }
Ref: 
function distribution ( $ arr , $ n ) { sort ( $ arr ) ; $ count = 1 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] > $ arr [ $ i - 1 ] ) $ count ++ ; return min ( $ count , $ n / 2 ) ; }
Hyp: 
function distribution ( $ arr , $ n ) { sort ( $ arr ) ; $ count = 1 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] > $ arr [ $ i - 1 ] ) $ count ++ ; return min ( $ count , $ n / 2 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function maxSubArraySum ( a , size ) { let max_so_far = a [ 0 ] ; let curr_max = a [ 0 ] ; for ( let i = 1 ; i < size ; i ++ ) { curr_max = Math . max ( a [ i ] , curr_max + a [ i ] ) ; max_so_far = Math . max ( max_so_far , curr_max ) ; } return max_so_far ; }
Ref: 
function maxSubArraySum ( $ a , $ size ) { $ max_so_far = $ a [ 0 ] ; $ curr_max = $ a [ 0 ] ; for ( $ i = 1 ; $ i < $ size ; $ i ++ ) { $ curr_max = max ( $ a [ $ i ] , $ curr_max + $ a [ $ i ] ) ; $ max_so_far = max ( $ max_so_far , $ curr_max ) ; } return $ max_so_far ; }
Hyp: 
function maxSubArraySum ( $ a , $ size ) { $ max_so_far = $ a [ 0 ] ; $ curr_max = $ a [ 0 ] ; for ( $ i = 1 ; $ i < $ size ; $ i ++ ) { $ curr_max = max ( $ a [ $ i ] , $ curr_max + $ a [ $ i ] ) ; $ max_so_far = max ( $ max_so_far , $ curr_max ) ; } return $ max_so_far ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function Dodecagonal_number ( n ) { return 5 * n * n - 4 * n ; }
Ref: 
function Dodecagonal_number ( $ n ) { return 5 * $ n * $ n - 4 * $ n ; }
Hyp: 
function Dodecagonal_number ( $ n ) { return 5 * $ n * $ n - 4 * $ n ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function getSum ( n , d ) { if ( n < d ) return 0 ; while ( n % 10 != d ) n -- ; k = parseInt ( n / 10 ) ; return ( k + 1 ) * d + ( k * 10 + 10 * k * k ) / 2 ; }
Ref: 
function getSum ( $ n , $ d ) { if ( $ n < $ d ) return 0 ; while ( $ n % 10 != $ d ) $ n -- ; $ k = ( int ) ( $ n / 10 ) ; return ( $ k + 1 ) * $ d + ( $ k * 10 + 10 * $ k * $ k ) / 2 ; }
Hyp: 
function digSum ( $ n , $ d ) { if ( $ n < $ d ) return 0 ; while ( $ n % 10 != $ d ) $ n -- ; $ k = ( int ) ( $ n / 10 ) ; return ( $ k + 1 ) * $ d + ( $ k * 10 + 10 * $ k * $ k ) / 2 ; }

BLEU: 97.7
Edit Sim: 3


Src: 
function calculateSum ( arr , n ) { if ( n == 0 ) return 0 ; let s = arr [ 0 ] ; let value = parseInt ( s ) ; let sum = value ; for ( let i = 2 ; i < n ; i = i + 2 ) { s = arr [ i ] ; value = parseInt ( s ) ; let operation = arr [ i - 1 ] [ 0 ] ; if ( operation == ' ' ) sum += value ; else sum -= value ; } return sum ; }
Ref: 
function calculateSum ( $ arr , $ n ) { if ( $ n == 0 ) return 0 ; $ s = $ arr [ 0 ] ; $ value = ( int ) $ s ; $ sum = $ value ; for ( $ i = 2 ; $ i < $ n ; $ i = $ i + 2 ) { $ s = $ arr [ $ i ] ; $ value = ( int ) $ s ; $ operation = $ arr [ $ i - 1 ] ; if ( $ operation == ' + ' ) $ sum += $ value ; else if ( $ operation == ' - ' ) $ sum -= $ value ; } return $ sum ; }
Hyp: 
function calculateSum ( $ arr , $ n ) { if ( $ n == 0 ) return 0 ; $ s = $ arr [ 0 ] ; $ value = ( int ) ( $ s ) ; $ sum = $ value ; for ( $ i = 2 ; $ i < $ n ; $ i = $ i + 2 ) { $ s = $ arr [ $ i ] ; $ value = ( int ) ( $ s ) ; $ operation = $ arr [ $ i - 1 ] [ 0 ] ; if ( $ operation == '1' ) $ sum += $ value ; else $ sum -= $ value ; } return $ sum ; }

BLEU: 84.37
Edit Sim: 45


Src: 
function nthSHN ( n , dp ) { if ( n == 1 n == 2 ) return dp [ n ] = 1 ; if ( dp [ n ] != - 1 ) return dp [ n ] ; return dp [ n ] = ( ( 6 * n - 9 ) * nthSHN ( n - 1 , dp ) - ( n - 3 ) * nthSHN ( n - 2 , dp ) ) / n ; }
Ref: 
function nthSHN ( $ n , $ dp ) { if ( $ n == 1 $ n == 2 ) return $ dp [ $ n ] = 1 ; if ( $ dp [ $ n ] != -1 ) return $ dp [ $ n ] ; return $ dp [ $ n ] = ( ( 6 * $ n - 9 ) * nthSHN ( $ n - 1 , $ dp ) - ( $ n - 3 ) * nthSHN ( $ n - 2 , $ dp ) ) / $ n ; }
Hyp: 
function nthSHN ( $ n , $ dp ) { if ( $ n == 1 $ n == 2 ) return $ dp [ $ n ] = 1 ; if ( $ dp [ $ n ] != -1 ) return $ dp [ $ n ] ; return $ dp [ $ n ] = ( ( 6 * $ n - 9 ) * nthSHN ( $ n - 1 , $ dp ) - ( $ n - 3 ) * nthSHN ( $ n - 2 , $ dp ) ) / $ n ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function xorZero ( s ) { let one_count = 0 , zero_count = 0 ; let n = s . length ; for ( let i = 0 ; i < n ; i ++ ) if ( s [ i ] == ' ' ) one_count ++ ; else zero_count ++ ; if ( one_count % 2 == 0 ) return zero_count ; return one_count ; }
Ref: 
function xorZero ( $ str ) { $ one_count = 0 ; $ zero_count = 0 ; $ n = strlen ( $ str ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ str [ $ i ] == '1' ) $ one_count ++ ; else $ zero_count ++ ; if ( $ one_count % 2 == 0 ) return $ zero_count ; return $ one_count ; }
Hyp: 
function xorZero ( $ s ) { $ one_count = 0 ; $ zero_count = 0 ; $ n = strlen ( $ s ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ s [ $ i ] == '1' ) $ one_count ++ ; else $ zero_count ++ ; if ( $ one_count % 2 == 0 ) return $ zero_count ; return $ one_count ; }

BLEU: 90.52
Edit Sim: 6


Src: 
function positions ( str , n ) { for ( i = 0 ; i < n ; i ++ ) { document . write ( ( str [ i ] . charCodeAt ( 0 ) & NUM ) + " " ) ; } }
Ref: 
function positions ( $ str , $ n ) { $ a = 31 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { print ( ( ord ( $ str [ $ i ] ) & ( $ a ) ) . " " ) ; } }
Hyp: 
function positions ( $ str , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { echo ( ord ( $ str [ $ i ] ) & NUM ) . " ▁ " ; } }

BLEU: 65.73
Edit Sim: 27


Src: 
function polite ( n ) { n += 1 ; let base = 2 ; return n + ( Math . log ( ( n + ( Math . log ( n ) / Math . log ( base ) ) ) ) ) / Math . log ( base ) ; }
Ref: 
function polite ( $ n ) { $ n += 1 ; $ base = 2 ; return $ n + ( log ( ( $ n + ( log ( $ n ) / log ( $ base ) ) ) ) ) / log ( $ base ) ; }
Hyp: 
function polite ( $ n ) { $ n += 1 ; $ base = 2 ; return ( $ n + ( log ( $ n ) / log ( $ base ) ) ) / log ( $ base ) ; }

BLEU: 80.41
Edit Sim: 18


Src: 
function isRotation ( x , y ) { var x64 = x | ( x << 32 ) ; while ( x64 >= y ) { if ( x64 == y ) { return true ; } x64 >>= 1 ; } return false ; } var x = 122 ; var y = 2147483678 ; if ( isRotation ( x , y ) == false ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
Ref: 
function isRotation ( $ x , $ y ) { $ x64 = $ x | ( $ x << 32 ) ; while ( $ x64 >= $ y ) { if ( ( $ x64 ) == $ y ) return 1 ; $ x64 >>= 1 ; } return -1 ; }
Hyp: 
function isRotation ( $ x , $ y ) { $ x64 = $ x | ( $ x << 32 ) ; while ( $ x64 >= $ y ) { if ( $ x64 == $ y ) { return true ; } $ x64 >>= 1 ; } return false ; } $ x = 122 ; $ y = 2147483678 ; if ( isRotation ( $ x , $ y ) == false ) { echo " No " ; } else { echo " Yes " ; }

BLEU: 48.14
Edit Sim: 130


Src: 
function search ( mat , n , x ) { let i = 0 , j = n - 1 ; while ( i < n && j >= 0 ) { if ( mat [ i ] [ j ] == x ) { document . write ( " " + i + " " + j ) ; return ; } if ( mat [ i ] [ j ] > x ) j -- ; else i ++ ; } document . write ( " " ) ; return ; }
Ref: 
function search ( & $ mat , $ n , $ x ) { $ i = 0 ; $ j = $ n - 1 ; while ( $ i < $ n && $ j >= 0 ) { if ( $ mat [ $ i ] [ $ j ] == $ x ) { echo " n ▁ found ▁ at ▁ " . $ i . " , ▁ " . $ j ; return 1 ; } if ( $ mat [ $ i ] [ $ j ] > $ x ) $ j -- ; else $ i ++ ; } echo " n ▁ Element ▁ not ▁ found " ; return 0 ; }
Hyp: 
function search ( $ mat , $ n , $ x ) { $ i = 0 ; $ j = $ n - 1 ; while ( $ i < $ n && $ j >= 0 ) { if ( $ mat [ $ i ] [ $ j ] == $ x ) { echo " Yes STRNEWLINE " ; return ; } if ( $ mat [ $ i ] [ $ j ] > $ x ) $ j -- ; else $ i ++ ; } echo " No " ; }

BLEU: 69.09
Edit Sim: 76


Src: 
function kthgroupsum ( k ) { return k * k * k ; }
Ref: 
function kthgroupsum ( $ k ) { return $ k * $ k * $ k ; }
Hyp: 
function kthgroupsum ( $ k ) { return $ k * $ k * $ k ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function equation_plane ( x1 , y1 , z1 , x2 , y2 , z2 , x3 , y3 , z3 ) { var a1 = x2 - x1 ; var b1 = y2 - y1 ; var c1 = z2 - z1 ; var a2 = x3 - x1 ; var b2 = y3 - y1 ; var c2 = z3 - z1 ; var a = b1 * c2 - b2 * c1 ; var b = a2 * c1 - a1 * c2 ; var c = a1 * b2 - b1 * a2 ; var d = ( - a * x1 - b * y1 - c * z1 ) ; document . write ( " " + a + " " + b + " " + c + " " + d + " " ) ; }
Ref: 
function equation_plane ( $ x1 , $ y1 , $ z1 , $ x2 , $ y2 , $ z2 , $ x3 , $ y3 , $ z3 ) { $ a1 = $ x2 - $ x1 ; $ b1 = $ y2 - $ y1 ; $ c1 = $ z2 - $ z1 ; $ a2 = $ x3 - $ x1 ; $ b2 = $ y3 - $ y1 ; $ c2 = $ z3 - $ z1 ; $ a = $ b1 * $ c2 - $ b2 * $ c1 ; $ b = $ a2 * $ c1 - $ a1 * $ c2 ; $ c = $ a1 * $ b2 - $ b1 * $ a2 ; $ d = ( - $ a * $ x1 - $ b * $ y1 - $ c * $ z1 ) ; echo sprintf ( " equation ▁ of ▁ the ▁ plane ▁ is ▁ % .2fx " . " ▁ + ▁ % .2fy ▁ + ▁ % .2fz ▁ + ▁ % .2f ▁ = ▁ 0" , $ a , $ b , $ c , $ d ) ; }
Hyp: 
function equation_plane ( $ x1 , $ y1 , $ z1 , $ x2 , $ y2 , $ z2 , $ x3 , $ y3 , $ z3 ) { $ a1 = $ x2 - $ x1 ; $ b1 = $ y2 - $ y1 ; $ c1 = $ z2 - $ z1 ; $ a2 = $ x3 - $ x1 ; $ b2 = $ y3 - $ y1 ; $ c2 = $ z3 - $ z1 ; $ a = $ b1 * $ c2 - $ b2 * $ c1 ; $ b = $ a2 * $ c1 - $ a1 * $ c2 ; $ c = $ a1 * $ b2 - $ b1 * $ a2 ; $ d = ( - $ a * $ x1 - $ b * $ y1 - $ c * $ z1 ) ; echo " A = " , ▁ $ a , ▁ " , b , " , ▁ " , $ c , " , ▁ " , $ d , " STRNEWLINE " ; }

BLEU: 78.67
Edit Sim: 90


Src: 
function area ( a ) { if ( a < 0 ) return - 1 ; var area = Math . sqrt ( a ) / 6 ; return area ; }
Ref: 
function area ( $ a ) { if ( $ a < 0 ) return -1 ; $ area = sqrt ( $ a ) / 6 ; return $ area ; }
Hyp: 
function area ( $ a ) { if ( $ a < 0 ) return -1 ; $ area = sqrt ( $ a ) / 6 ; return $ area ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function printCubes ( a , b ) { for ( let i = a ; i <= b ; i ++ ) { for ( let j = 1 ; j * j * j <= i ; j ++ ) { if ( j * j * j == i ) { document . write ( j * j * j + " " ) ; break ; } } } }
Ref: 
function printCubes ( $ a , $ b ) { for ( $ i = $ a ; $ i <= $ b ; $ i ++ ) { for ( $ j = 1 ; $ j * $ j * $ j <= $ i ; $ j ++ ) { if ( $ j * $ j * $ j == $ i ) { echo $ j * $ j * $ j , " " ; break ; } } } }
Hyp: 
function printCubes ( $ a , $ b ) { for ( $ i = $ a ; $ i <= $ b ; $ i ++ ) { for ( $ j = 1 ; $ j * $ j * $ j <= $ i ; $ j ++ ) { if ( $ j * $ j * $ j == $ i ) { echo $ j * $ j * $ j , " " ; break ; } } } }

BLEU: 100.0
Edit Sim: 0


Src: 
function maxSum ( grid , n ) { let incl = Math . max ( grid [ 0 ] [ 0 ] , grid [ 1 ] [ 0 ] ) ; let excl = 0 , excl_new ; for ( let i = 1 ; i < n ; i ++ ) { excl_new = Math . max ( excl , incl ) ; incl = excl + Math . max ( grid [ 0 ] [ i ] , grid [ 1 ] [ i ] ) ; excl = excl_new ; } return Math . max ( excl , incl ) ; }
Ref: 
function maxSum ( $ grid , $ n ) { $ incl = max ( $ grid [ 0 ] [ 0 ] , $ grid [ 1 ] [ 0 ] ) ; $ excl = 0 ; $ excl_new ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ excl_new = max ( $ excl , $ incl ) ; $ incl = $ excl + max ( $ grid [ 0 ] [ $ i ] , $ grid [ 1 ] [ $ i ] ) ; $ excl = $ excl_new ; } return max ( $ excl , $ incl ) ; }
Hyp: 
function maxSum ( $ grid , $ n ) { $ incl = max ( $ grid [ 0 ] [ 0 ] , $ grid [ 1 ] [ 0 ] ) ; $ excl = 0 ; $ excl_new ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ excl_new = max ( $ excl , $ incl ) ; $ incl = $ excl + max ( $ grid [ 0 ] [ $ i ] , $ grid [ 1 ] [ $ i ] ) ; $ excl = $ excl_new ; } return max ( $ excl , $ incl ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function printFactorialNums ( n ) { let fact = 1 ; let x = 2 ; while ( fact <= n ) { document . write ( fact + " " ) ; fact = fact * x ; x ++ ; } }
Ref: 
function printFactorialNums ( $ n ) { $ fact = 1 ; $ x = 2 ; while ( $ fact <= $ n ) { echo $ fact , " " ; $ fact = $ fact * $ x ; $ x ++ ; } }
Hyp: 
function printFactorialNums ( $ n ) { $ fact = 1 ; $ x = 2 ; while ( $ fact <= $ n ) { echo $ fact , " " ; $ fact = $ fact * $ x ; $ x ++ ; } }

BLEU: 100.0
Edit Sim: 0


Src: 
function reorder ( arr , index , n ) { var temp = [ ... Array ( n ) ] ; for ( var i = 0 ; i < n ; i ++ ) temp [ index [ i ] ] = arr [ i ] ; for ( var i = 0 ; i < n ; i ++ ) { arr [ i ] = temp [ i ] ; index [ i ] = i ; } }
Ref: 
function reorder ( $ arr , $ index , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ temp [ $ index [ $ i ] ] = $ arr [ $ i ] ; } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ arr [ $ i ] = $ temp [ $ i ] ; $ index [ $ i ] = $ i ; } echo " Reordered ▁ array ▁ is : ▁ STRNEWLINE " ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { echo $ arr [ $ i ] . " " ; } echo " Modified Index array is : " for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { echo $ index [ $ i ] . " " ; } }
Hyp: 
function reorder ( & $ arr , $ index , $ n ) { $ temp = array ( ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ temp [ $ index [ $ i ] ] = $ arr [ $ i ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ arr [ $ i ] = $ temp [ $ i ] ; $ index [ $ i ] = $ i ; } }

BLEU: 42.3
Edit Sim: 228


Src: 
function rectCount ( n , m ) { return parseInt ( ( m * n * ( n + 1 ) * ( m + 1 ) ) / 4 , 10 ) ; }
Ref: 
function rectCount ( $ n , $ m ) { return ( $ m * $ n * ( $ n + 1 ) * ( $ m + 1 ) ) / 4 ; }
Hyp: 
function rectCount ( $ n , $ m ) { return ( $ m * $ n * ( $ n + 1 ) * ( $ m + 1 ) ) / 4 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function printCollatz ( n ) { while ( n != 1 ) { document . write ( n + " " ) ; if ( ( n & 1 ) != 0 ) n = 3 * n + 1 ; else n = parseInt ( n / 2 , 10 ) ; } document . write ( n ) ; }
Ref: 
function printCollatz ( $ n ) { while ( $ n != 1 ) { echo $ n . " " ; if ( $ n & 1 ) $ n = 3 * $ n + 1 ; else $ n = $ n / 2 ; } echo $ n ; }
Hyp: 
function printCollatz ( $ n ) { while ( $ n != 1 ) { echo $ n . " " ; if ( ( $ n & 1 ) != 0 ) $ n = 3 * $ n + 1 ; else $ n = ( int ) ( $ n / 2 ) ; } echo $ n . " " ; }

BLEU: 72.38
Edit Sim: 27


Src: 
function Series ( n ) { let sums = 0.0 ; for ( let i = 1 ; i < n + 1 ; i ++ ) { ser = 1 / Math . pow ( i , i ) ; sums += ser ; } return sums ; }
Ref: 
function Series ( $ n ) { $ i ; $ sums = 0.0 ; $ ser ; for ( $ i = 1 ; $ i <= $ n ; ++ $ i ) { $ ser = 1 / pow ( $ i , $ i ) ; $ sums += $ ser ; } return $ sums ; }
Hyp: 
function Series ( $ n ) { $ sums = 0.0 ; for ( $ i = 1 ; $ i < $ n + 1 ; $ i ++ ) { $ ser = 1 / pow ( $ i , $ i ) ; $ sums += $ ser ; } return $ sums ; }

BLEU: 76.87
Edit Sim: 22


Src: 
function term ( n ) { let ans = 0 ; for ( let i = 1 ; i <= n ; i ++ ) ans += i ; return ans ; }
Ref: 
function term ( $ n ) { $ ans = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ ans += $ i ; return $ ans ; }
Hyp: 
function term ( $ n ) { $ ans = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ ans += $ i ; return $ ans ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countNonDecreasing ( n ) { let N = 10 ; let count = 1 ; for ( let i = 1 ; i <= n ; i ++ ) { count *= ( N + i - 1 ) ; count = Math . floor ( count / i ) ; } return count ; }
Ref: 
function countNonDecreasing ( $ n ) { $ N = 10 ; $ count = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ count *= ( $ N + $ i - 1 ) ; $ count /= $ i ; } return $ count ; }
Hyp: 
function countNonDecreasing ( $ n ) { $ N = 10 ; $ count = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ count *= ( $ N + $ i - 1 ) ; $ count = ( int ) $ count / $ i ; } return $ count ; }

BLEU: 86.97
Edit Sim: 19


Src: 
function maxProduct ( arr , n ) { if ( n < 3 ) return - 1 ; let max_product = Number . MIN_VALUE ; for ( let i = 0 ; i < n - 2 ; i ++ ) for ( let j = i + 1 ; j < n - 1 ; j ++ ) for ( let k = j + 1 ; k < n ; k ++ ) max_product = Math . max ( max_product , arr [ i ] * arr [ j ] * arr [ k ] ) ; return max_product ; }
Ref: 
function maxProduct ( $ arr , $ n ) { $ INT_MIN = 0 ; if ( $ n < 3 ) return -1 ; $ max_product = $ INT_MIN ; for ( $ i = 0 ; $ i < $ n - 2 ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n - 1 ; $ j ++ ) for ( $ k = $ j + 1 ; $ k < $ n ; $ k ++ ) $ max_product = max ( $ max_product , $ arr [ $ i ] * $ arr [ $ j ] * $ arr [ $ k ] ) ; return $ max_product ; }
Hyp: 
function maxProduct ( $ arr , $ n ) { if ( $ n < 3 ) return -1 ; $ max_product = PHP_INT_MIN ; for ( $ i = 0 ; $ i < $ n - 2 ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n - 1 ; $ j ++ ) for ( $ k = $ j + 1 ; $ k < $ n ; $ k ++ ) $ max_product = max ( $ max_product , $ arr [ $ i ] * $ arr [ $ j ] * $ arr [ $ k ] ) ; return $ max_product ; }

BLEU: 91.97
Edit Sim: 20


Src: 
function count ( S , m , n ) { let table = new Array ( n + 1 ) ; table . fill ( 0 ) ; table [ 0 ] = 1 ; for ( let i = 0 ; i < m ; i ++ ) for ( let j = S [ i ] ; j <= n ; j ++ ) table [ j ] += table [ j - S [ i ] ] ; return table [ n ] ; }
Ref: 
function count_1 ( & $ S , $ m , $ n ) { $ table = array_fill ( 0 , $ n + 1 , NULl ) ; $ table [ 0 ] = 1 ; for ( $ i = 0 ; $ i < $ m ; $ i ++ ) for ( $ j = $ S [ $ i ] ; $ j <= $ n ; $ j ++ ) $ table [ $ j ] += $ table [ $ j - $ S [ $ i ] ] ; return $ table [ $ n ] ; }
Hyp: 
function count ( $ S , $ m , $ n ) { $ table [ $ n + 1 ] = 0 ; $ table [ 0 ] = 1 ; for ( $ i = 0 ; $ i < $ m ; $ i ++ ) for ( $ j = $ S [ $ i ] ; $ j <= $ n ; $ j ++ ) $ table [ $ j ] += $ table [ $ j - $ S [ $ i ] ] ; return $ table [ $ n ] ; }

BLEU: 86.53
Edit Sim: 28


Src: 
function countCommon ( mat , n ) { let res = 0 ; for ( let i = 0 ; i < n ; i ++ ) if ( mat [ i ] [ i ] == mat [ i ] [ n - i - 1 ] ) res ++ ; return res ; }
Ref: 
function countCommon ( $ mat , $ n ) { global $ MAX ; $ res = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ mat [ $ i ] [ $ i ] == $ mat [ $ i ] [ $ n - $ i - 1 ] ) $ res ++ ; return $ res ; }
Hyp: 
function countCommon ( $ mat , $ n ) { $ res = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ mat [ $ i ] [ $ i ] == $ mat [ $ i ] [ $ n - $ i - 1 ] ) $ res ++ ; return $ res ; }

BLEU: 92.37
Edit Sim: 15


Src: 
function isOverflow ( a , b ) { if ( a == 0 b == 0 ) return false ; var result = a * b ; if ( result >= 9223372036854775807 result <= - 9223372036854775808 ) result = 0 if ( a == parseInt ( result / b ) ) return false ; else return true ; }
Ref: 
function isOverflow ( $ a , $ b ) { if ( $ a == 0 $ b == 0 ) return false ; $ result = $ a * $ b ; if ( $ a == ( int ) $ result / $ b ) return false ; else return true ; }
Hyp: 
function isOverflow ( $ a , $ b ) { if ( $ a == 0 $ b == 0 ) return false ; $ result = $ a * $ b ; if ( $ result >= 9223372036854775807 $ result <= - 9223372036854775808 ) $ result = 0 ; if ( $ a == ( int ) $ result / $ b ) ) return false ; else return true ; }

BLEU: 74.1
Edit Sim: 90


Src: 
function countOccurrences ( arr , n , x ) { let res = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( x == arr [ i ] ) res ++ ; } return res ; }
Ref: 
function countOccurrences ( $ arr , $ n , $ x ) { $ res = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ x == $ arr [ $ i ] ) $ res ++ ; return $ res ; }
Hyp: 
function countOccurrences ( $ arr , $ n , $ x ) { $ res = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ x == $ arr [ $ i ] ) $ res ++ ; } return $ res ; }

BLEU: 91.13
Edit Sim: 4


Src: 
function pairsInSortedRotated ( arr , n , x ) { let i ; for ( i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] > arr [ i + 1 ] ) break ; let l = ( i + 1 ) % n ; let r = i ; let cnt = 0 ; while ( l != r ) { if ( arr [ l ] + arr [ r ] == x ) { cnt ++ ; if ( l == ( r - 1 + n ) % n ) { return cnt ; } l = ( l + 1 ) % n ; r = ( r - 1 + n ) % n ; } else if ( arr [ l ] + arr [ r ] < x ) l = ( l + 1 ) % n ; else r = ( n + r - 1 ) % n ; } return cnt ; }
Ref: 
function pairsInSortedRotated ( $ arr , $ n , $ x ) { $ i ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) if ( $ arr [ $ i ] > $ arr [ $ i + 1 ] ) break ; $ l = ( $ i + 1 ) % $ n ; $ r = $ i ; $ cnt = 0 ; while ( $ l != $ r ) { if ( $ arr [ $ l ] + $ arr [ $ r ] == $ x ) { $ cnt ++ ; if ( $ l == ( $ r - 1 + $ n ) % $ n ) { return $ cnt ; } $ l = ( $ l + 1 ) % $ n ; $ r = ( $ r - 1 + $ n ) % $ n ; } else if ( $ arr [ $ l ] + $ arr [ $ r ] < $ x ) $ l = ( $ l + 1 ) % $ n ; else $ r = ( $ n + $ r - 1 ) % $ n ; } return $ cnt ; }
Hyp: 
function pairsInSortedRotated ( $ arr , $ n , $ x ) { for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) if ( $ arr [ $ i ] > $ arr [ $ i + 1 ] ) break ; $ l = ( $ i + 1 ) % $ n ; $ r = $ i ; $ cnt = 0 ; while ( $ l != $ r ) { if ( $ arr [ $ l ] + $ arr [ $ r ] == $ x ) { $ cnt ++ ; if ( $ l == ( $ r - 1 + $ n ) % $ n ) { return $ cnt ; } $ l = ( $ l + 1 ) % $ n ; $ r = ( $ r - 1 + $ n ) % $ n ; } else if ( $ arr [ $ l ] + $ arr [ $ r ] < $ x ) $ l = ( $ l + 1 ) % $ n ; else $ r = ( $ n + $ r - 1 ) % $ n ; } return $ cnt ; }

BLEU: 97.96
Edit Sim: 6


Src: 
function mirror_point ( a , b , c , d , x1 , y1 , z1 ) { var k = parseFloat ( ( - a * x1 - b * y1 - c * z1 - d ) / parseFloat ( a * a + b * b + c * c ) ) ; var x2 = parseFloat ( a * k + x1 ) ; var y2 = parseFloat ( b * k + y1 ) ; var z2 = parseFloat ( c * k + z1 ) ; var x3 = parseFloat ( 2 * x2 - x1 ) . toFixed ( 1 ) ; var y3 = parseFloat ( 2 * y2 - y1 ) . toFixed ( 1 ) ; var z3 = parseFloat ( 2 * z2 - z1 ) . toFixed ( 1 ) ; document . write ( " " + x3 ) ; document . write ( " " + y3 ) ; document . write ( " " + z3 ) ; }
Ref: 
function mirror_point ( $ a , $ b , $ c , $ d , $ x1 , $ y1 , $ z1 ) { $ k = ( - $ a * $ x1 - $ b * $ y1 - $ c * $ z1 - $ d ) / ( $ a * $ a + $ b * $ b + $ c * $ c ) ; $ x2 = $ a * $ k + $ x1 ; $ y2 = $ b * $ k + $ y1 ; $ z2 = $ c * $ k + $ z1 ; $ x3 = 2 * $ x2 - $ x1 ; $ y3 = 2 * $ y2 - $ y1 ; $ z3 = 2 * $ z2 - $ z1 ; echo sprintf ( " x3 ▁ = ▁ % .1f ▁ " , $ x3 ) ; echo sprintf ( " y3 ▁ = ▁ % .1f ▁ " , $ y3 ) ; echo sprintf ( " z3 ▁ = ▁ % .1f ▁ " , $ z3 ) ; }
Hyp: 
function mirror_point ( $ a , $ b , $ c , $ d , $ x1 , $ y1 , $ z1 ) { $ k = ( - $ a * $ x1 - $ b * $ y1 - $ c * $ z1 - $ d ) / ( $ a * $ a + $ b * $ b + $ c * $ c ) ; $ x2 = ( $ a * $ k + $ x1 ) ; $ y2 = ( $ b * $ k + $ y1 ) ; $ z2 = ( $ c * $ k + $ z1 ) ; $ x3 = parseFloat ( 2 * $ x2 - $ x1 ) ; $ y3 = parseFloat ( 2 * $ y2 - $ y1 ) ; $ z3 = parseFloat ( 2 * $ z2 - $ z1 ) ; echo " Mirror ▁ point ▁ is ▁ " , $ x3 ; echo " STRNEWLINE " ; }

BLEU: 67.67
Edit Sim: 140


Src: 
function exponential ( n , x ) { var sum = 1 ; for ( i = n - 1 ; i > 0 ; -- i ) sum = 1 + x * sum / i ; return sum ; }
Ref: 
function exponential ( $ n , $ x ) { $ sum = 1.0 ; for ( $ i = $ n - 1 ; $ i > 0 ; -- $ i ) $ sum = 1 + $ x * $ sum / $ i ; return $ sum ; }
Hyp: 
function exponential ( $ n , $ x ) { $ sum = 1 ; for ( $ i = $ n - 1 ; $ i > 0 ; -- $ i ) $ sum = 1 + $ x * $ sum / $ i ; return $ sum ; }

BLEU: 95.16
Edit Sim: 2


Src: 
function countSteps ( n ) { let steps = 0 ; while ( n ) { let largest = Math . floor ( Math . sqrt ( n ) ) ; n -= ( largest * largest ) ; steps ++ ; } return steps ; }
Ref: 
function countSteps ( $ n ) { $ steps = 0 ; while ( $ n ) { $ largest = ( int ) sqrt ( $ n ) ; $ n -= ( $ largest * $ largest ) ; $ steps ++ ; } return $ steps ; }
Hyp: 
function countSteps ( $ n ) { $ steps = 0 ; while ( $ n ) { $ largest = floor ( sqrt ( $ n ) ) ; $ n -= ( $ largest * $ largest ) ; $ steps ++ ; } return $ steps ; }

BLEU: 90.32
Edit Sim: 8


Src: 
function correlationCoefficient ( X , Y , n ) { let sum_X = 0 , sum_Y = 0 , sum_XY = 0 ; let squareSum_X = 0 , squareSum_Y = 0 ; for ( let i = 0 ; i < n ; i ++ ) { sum_X = sum_X + X [ i ] ; sum_Y = sum_Y + Y [ i ] ; sum_XY = sum_XY + X [ i ] * Y [ i ] ; squareSum_X = squareSum_X + X [ i ] * X [ i ] ; squareSum_Y = squareSum_Y + Y [ i ] * Y [ i ] ; } let corr = ( n * sum_XY - sum_X * sum_Y ) / ( Math . sqrt ( ( n * squareSum_X - sum_X * sum_X ) * ( n * squareSum_Y - sum_Y * sum_Y ) ) ) ; return corr ; }
Ref: 
function correlationCoefficient ( $ X , $ Y , $ n ) { $ sum_X = 0 ; $ sum_Y = 0 ; $ sum_XY = 0 ; $ squareSum_X = 0 ; $ squareSum_Y = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sum_X = $ sum_X + $ X [ $ i ] ; $ sum_Y = $ sum_Y + $ Y [ $ i ] ; $ sum_XY = $ sum_XY + $ X [ $ i ] * $ Y [ $ i ] ; $ squareSum_X = $ squareSum_X + $ X [ $ i ] * $ X [ $ i ] ; $ squareSum_Y = $ squareSum_Y + $ Y [ $ i ] * $ Y [ $ i ] ; } $ corr = ( float ) ( $ n * $ sum_XY - $ sum_X * $ sum_Y ) / sqrt ( ( $ n * $ squareSum_X - $ sum_X * $ sum_X ) * ( $ n * $ squareSum_Y - $ sum_Y * $ sum_Y ) ) ; return $ corr ; }
Hyp: 
function correlationCoefficient ( $ X , $ Y , $ n ) { $ sum_X = 0 ; $ sum_Y = 0 ; $ sum_XY = 0 ; $ squareSum_X = 0 ; $ squareSum_Y = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sum_X = $ sum_X + $ X [ $ i ] ; $ sum_Y = $ sum_Y + $ Y [ $ i ] ; $ sum_XY = $ sum_XY + $ X [ $ i ] * $ Y [ $ i ] ; $ squareSum_X = $ squareSum_X + $ X [ $ i ] * $ X [ $ i ] ; $ squareSum_Y = $ squareSum_Y + $ Y [ $ i ] * $ Y [ $ i ] ; } $ corr = ( $ n * $ sum_XY - $ sum_X * $ sum_Y ) / ( sqrt ( ( $ n * $ squareSum_X - $ sum_X * $ sum_X ) * ( $ n * $ squareSum_Y - $ sum_Y * $ sum_Y ) ) ; return $ corr ; }

BLEU: 97.47
Edit Sim: 12


Src: 
function hexDiagonal ( a ) { if ( a < 0 ) return - 1 ; var d = 1.73 * a ; return d ; }
Ref: 
function hexDiagonal ( $ a ) { if ( $ a < 0 ) return -1 ; $ d = 1.73 * $ a ; return $ d ; }
Hyp: 
function hexDiagonal ( $ a ) { if ( $ a < 0 ) return -1 ; $ d = 1.73 * $ a ; return $ d ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function isTriangleExists ( a , b , c ) { if ( a != 0 && b != 0 && c != 0 && ( a + b + c ) == 180 ) if ( ( a + b ) >= c || ( b + c ) >= a || ( a + c ) >= b ) return " " ; else return " " ; else return " " ; }
Ref: 
function isTriangleExists ( $ a , $ b , $ c ) { if ( $ a != 0 && $ b != 0 && $ c != 0 && ( $ a + $ b + $ c ) == 180 ) if ( ( $ a + $ b ) >= $ c || ( $ b + $ c ) >= $ a || ( $ a + $ c ) >= $ b ) return " YES " ; else return " NO " ; else return " NO " ; }
Hyp: 
function isTriangleExists ( $ a , $ b , $ c ) { if ( $ a != 0 && $ b != 0 && $ c != 0 && ( $ a + $ b + $ c ) == 180 ) if ( ( $ a + $ b ) >= $ c || ( $ b + $ c ) >= $ a || ( $ a + $ c ) >= $ b ) return " Yes " ; else return " No " ; }

BLEU: 88.26
Edit Sim: 22


Src: 
function countDivisors ( n ) { let cnt = 0 ; for ( let i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) cnt ++ ; cnt = cnt + 2 ; } } return cnt ; }
Ref: 
function countDivisors ( $ n ) { $ cnt = 0 ; for ( $ i = 1 ; $ i <= sqrt ( $ n ) ; $ i ++ ) { if ( $ n % $ i == 0 ) { if ( $ n / $ i == $ i ) $ cnt ++ ; else $ cnt = $ cnt + 2 ; } } return $ cnt ; }
Hyp: 
function countDivisors ( $ n ) { $ cnt = 0 ; for ( $ i = 1 ; $ i <= sqrt ( $ n ) ; $ i ++ ) { if ( $ n % $ i == 0 ) { if ( $ n / $ i == $ i ) $ cnt ++ ; $ cnt = $ cnt + 2 ; } } return $ cnt ; }

BLEU: 96.61
Edit Sim: 5


Src: 
function minimumCost ( cost , n ) { let dp1 = 0 , dp2 = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let dp0 = cost [ i ] + Math . min ( dp1 , dp2 ) ; dp2 = dp1 ; dp1 = dp0 ; } return Math . min ( dp1 , dp2 ) ; }
Ref: 
function minimumCost ( & $ cost , $ n ) { $ dp1 = 0 ; $ dp2 = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ dp0 = $ cost [ $ i ] + min ( $ dp1 , $ dp2 ) ; $ dp2 = $ dp1 ; $ dp1 = $ dp0 ; } return min ( $ dp1 , $ dp2 ) ; }
Hyp: 
function minimumCost ( $ cost , $ n ) { $ dp1 = 0 ; $ dp2 = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ dp0 = $ cost [ $ i ] + min ( $ dp1 , $ dp2 ) ; $ dp2 = $ dp1 ; $ dp1 = $ dp0 ; } return min ( $ dp1 , $ dp2 ) ; }

BLEU: 96.9
Edit Sim: 2


Src: 
function findOddPair ( A , N ) { let count = 0 ; for ( let i = 0 ; i < N ; i ++ ) if ( ( A [ i ] % 2 == 1 ) ) count ++ ; return count * ( count - 1 ) / 2 ; }
Ref: 
function findOddPair ( & $ A , $ N ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) if ( ( $ A [ $ i ] % 2 == 1 ) ) $ count ++ ; return $ count * ( $ count - 1 ) / 2 ; }
Hyp: 
function findOddPair ( & $ A , $ N ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) if ( ( $ A [ $ i ] % 2 == 1 ) ) $ count ++ ; return $ count * ( $ count - 1 ) / 2 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function setRightmostUnsetBit ( n ) { if ( ( n & ( n + 1 ) ) == 0 ) return n ; return n | ( n + 1 ) ; }
Ref: 
function setRightmostUnsetBit ( $ n ) { if ( ( $ n & ( $ n + 1 ) ) == 0 ) return $ n ; return $ n | ( $ n + 1 ) ; }
Hyp: 
function setRightmostUnsetBit ( $ n ) { if ( ( $ n & ( $ n + 1 ) ) == 0 ) return $ n ; return $ n | ( $ n + 1 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function distance ( a1 , b1 , c1 , a2 , b2 , c2 ) { var d = a1 * a2 + b1 * b2 + c1 * c2 ; var e1 = Math . sqrt ( a1 * a1 + b1 * b1 + c1 * c1 ) ; var e2 = Math . sqrt ( a2 * a2 + b2 * b2 + c2 * c2 ) ; d = parseFloat ( d / ( e1 * e2 ) ) ; var pi = 3.14159 ; var A = ( 180 / pi ) * Math . acos ( d ) ; document . write ( " " + A . toFixed ( 1 ) + " " ) ; }
Ref: 
function distance ( $ a1 , $ b1 , $ c1 , $ a2 , $ b2 , $ c2 ) { $ d = ( $ a1 * $ a2 + $ b1 * $ b2 + $ c1 * $ c2 ) ; $ e1 = sqrt ( $ a1 * $ a1 + $ b1 * $ b1 + $ c1 * $ c1 ) ; $ e2 = sqrt ( $ a2 * $ a2 + $ b2 * $ b2 + $ c2 * $ c2 ) ; $ d = $ d / ( $ e1 * $ e2 ) ; $ pi = 3.14159 ; $ A = ( 180 / $ pi ) * ( acos ( $ d ) ) ; echo sprintf ( " Angle ▁ is ▁ % .2f ▁ degree " , $ A ) ; }
Hyp: 
function distance ( $ a1 , $ b1 , $ c1 , $ a2 , $ b2 , $ c2 ) { $ d = $ a1 * $ a2 + $ b1 * $ b2 + $ c1 * $ c2 ; $ e1 = sqrt ( $ a1 * $ a1 + $ b1 * $ b1 + $ c1 * $ c1 ) ; $ e2 = sqrt ( $ a2 * $ a2 + $ b2 * $ b2 + $ c2 * $ c2 ) ; $ d = $ d / ( $ e1 * $ e2 ) ; $ pi = 3.14159 ; $ A = ( 180 / $ pi ) * acos ( $ d ) ; echo " Distance ▁ is ▁ " , $ A ; }

BLEU: 84.59
Edit Sim: 38


Src: 
function Circumference ( a ) { return 4 * a ; }
Ref: 
function Circumference ( $ a ) { return 4 * $ a ; }
Hyp: 
function Circumference ( $ a ) { return 4 * $ a ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function isSubsetSum ( arr , n , sum ) { let subset = new Array ( 2 ) ; for ( var i = 0 ; i < subset . length ; i ++ ) { subset [ i ] = new Array ( 2 ) ; } for ( let i = 0 ; i <= n ; i ++ ) { for ( let j = 0 ; j <= sum ; j ++ ) { if ( j == 0 ) subset [ i % 2 ] [ j ] = true ; else if ( i == 0 ) subset [ i % 2 ] [ j ] = false ; else if ( arr [ i - 1 ] <= j ) subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j - arr [ i - 1 ] ] || subset [ ( i + 1 ) % 2 ] [ j ] ; else subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j ] ; } } return subset [ n % 2 ] [ sum ] ; }
Ref: 
function isSubsetSum ( $ arr , $ n , $ sum ) { $ subset [ 2 ] [ $ sum + 1 ] = array ( ) ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 0 ; $ j <= $ sum ; $ j ++ ) { if ( $ j == 0 ) $ subset [ $ i % 2 ] [ $ j ] = true ; else if ( $ i == 0 ) $ subset [ $ i % 2 ] [ $ j ] = false ; else if ( $ arr [ $ i - 1 ] <= $ j ) $ subset [ $ i % 2 ] [ $ j ] = $ subset [ ( $ i + 1 ) % 2 ] [ $ j - $ arr [ $ i - 1 ] ] || $ subset [ ( $ i + 1 ) % 2 ] [ $ j ] ; else $ subset [ $ i % 2 ] [ $ j ] = $ subset [ ( $ i + 1 ) % 2 ] [ $ j ] ; } } return $ subset [ $ n % 2 ] [ $ sum ] ; }
Hyp: 
function isSubsetSum ( $ arr , $ n , $ sum ) { $ subset = array ( array ( ) ) ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 0 ; $ j <= $ sum ; $ j ++ ) { if ( $ j == 0 ) $ subset [ $ i % 2 ] [ $ j ] = true ; else if ( $ i == 0 ) $ subset [ $ i % 2 ] [ $ j ] = false ; else if ( $ arr [ $ i - 1 ] <= $ j ) $ subset [ $ i % 2 ] [ $ j ] = $ subset [ ( $ i + 1 ) % 2 ] [ $ j - $ arr [ $ i - 1 ] ] || $ subset [ ( $ i + 1 ) % 2 ] [ $ j ] ; else $ subset [ $ i % 2 ] [ $ j ] = $ subset [ ( $ i + 1 ) % 2 ] [ $ j ] ; } } return $ subset [ $ n % 2 ] [ $ sum ] ; }

BLEU: 94.93
Edit Sim: 21


Src: 
function printSequence ( arr , input ) { let output = " " ; let n = input . length ; for ( let i = 0 ; i < n ; i ++ ) { if ( input [ i ] == ' ' ) output = output + " " . charCodeAt ( 0 ) ; else { let position = input [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ; output = output + arr [ position ] ; } } return output ; }
Ref: 
function printSequence ( & $ arr , $ input ) { $ output = " " ; $ n = strlen ( $ input ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ input [ $ i ] == ' ▁ ' ) $ output = $ output + "0" ; else { $ position = ord ( $ input [ $ i ] ) - ord ( ' A ' ) ; $ output = $ output . $ arr [ $ position ] ; } } return $ output ; }
Hyp: 
function printSequence ( $ arr , $ input ) { $ output = " " ; $ n = strlen ( $ input ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ input [ $ i ] == ' ( ' ) $ output = $ output + " ) ' ; else { $ position = ord ( $ input [ $ i ] ) - ord ( '0' ) ; $ output = $ output + $ arr [ $ position ] ; } } return $ output ; }

BLEU: 86.6
Edit Sim: 11


Src: 
function numofstring ( n , m ) { if ( n == 1 ) return m ; if ( n == 2 ) return m * ( m - 1 ) ; return m * ( m - 1 ) * Math . pow ( m - 2 , n - 2 ) ; }
Ref: 
function numofstring ( $ n , $ m ) { if ( $ n == 1 ) return $ m ; if ( $ n == 2 ) return $ m * ( $ m - 1 ) ; return $ m * ( $ m - 1 ) * pow ( $ m - 2 , $ n - 2 ) ; } { $ n = 2 ; $ m = 3 ; echo numofstring ( $ n , $ m ) ; return 0 ; }
Hyp: 
function numofstring ( $ n , $ m ) { if ( $ n == 1 ) return $ m ; if ( $ n == 2 ) return $ m * ( $ m - 1 ) ; return $ m * ( $ m - 1 ) * pow ( $ m - 2 , $ n - 2 ) ; }

BLEU: 67.66
Edit Sim: 68


Src: 
function CubeVolume ( d ) { let Volume ; Volume = ( Math . sqrt ( 3 ) * Math . pow ( d , 3 ) ) / 9 ; return Volume ; }
Ref: 
function CubeVolume ( $ d ) { $ Volume ; $ Volume = ( sqrt ( 3 ) * pow ( $ d , 3 ) ) / 9 ; return $ Volume ; }
Hyp: 
function CubeVolume ( $ d ) { $ Volume ; $ Volume = ( sqrt ( 3 ) * pow ( $ d , 3 ) ) / 9 ; return $ Volume ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function SieveOfSundaram ( n ) { let nNew = ( n - 1 ) / 2 ; let marked = [ ] ; for ( let i = 0 ; i < nNew + 1 ; i ++ ) marked [ i ] = false ; for ( let i = 1 ; i <= nNew ; i ++ ) for ( let j = i ; ( i + j + 2 * i * j ) <= nNew ; j ++ ) marked [ i + j + 2 * i * j ] = true ; if ( n > 2 ) document . write ( 2 + " " ) ; for ( let i = 1 ; i <= nNew ; i ++ ) if ( marked [ i ] == false ) document . write ( 2 * i + 1 + " " ) ; return - 1 ; }
Ref: 
function SieveOfSundaram ( $ n ) { $ nNew = ( $ n - 1 ) / 2 ; $ marked = array_fill ( 0 , ( $ nNew + 1 ) , false ) ; for ( $ i = 1 ; $ i <= $ nNew ; $ i ++ ) for ( $ j = $ i ; ( $ i + $ j + 2 * $ i * $ j ) <= $ nNew ; $ j ++ ) $ marked [ $ i + $ j + 2 * $ i * $ j ] = true ; if ( $ n > 2 ) echo "2 ▁ " ; for ( $ i = 1 ; $ i <= $ nNew ; $ i ++ ) if ( $ marked [ $ i ] == false ) echo ( 2 * $ i + 1 ) . " ▁ " ; }
Hyp: 
function SieveOfSundaram ( $ n ) { $ nNew = ( $ n - 1 ) / 2 ; $ marked = array ( ) ; for ( $ i = 0 ; $ i < $ nNew + 1 ; $ i ++ ) $ marked [ $ i ] = false ; for ( $ i = 1 ; $ i <= $ nNew ; $ i ++ ) for ( $ j = $ i ; ( $ i + $ j + 2 * $ i * $ j ) <= $ nNew ; $ j ++ ) $ marked [ $ i + $ j + 2 * $ i * $ j ] = true ; if ( $ n > 2 ) echo 2 , " " ; for ( $ i = 1 ; $ i <= $ nNew ; $ i ++ ) if ( $ marked [ $ i ] == false ) echo 2 * $ i + 1 , " ▁ " ; return -1 ; }

BLEU: 77.97
Edit Sim: 71


Src: 
function noAdjacentDup ( s1 ) { let n = s1 . length ; let s = s1 . split ( ' ' ) ; for ( let i = 1 ; i < n ; i ++ ) { if ( s [ i ] == s [ i - 1 ] ) { s [ i ] = ' ' ; while ( s [ i ] == s [ i - 1 ] || ( i + 1 < n && s [ i ] == s [ i + 1 ] ) ) s [ i ] ++ ; i ++ ; } } return ( s ) ; }
Ref: 
function noAdjacentDup ( $ s ) { $ n = strlen ( $ s ) ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( $ s [ $ i ] == $ s [ $ i - 1 ] ) { $ s [ $ i ] = ' a ' ; while ( $ s [ $ i ] == $ s [ $ i - 1 ] || ( $ i + 1 < $ n && $ s [ $ i ] == $ s [ $ i + 1 ] ) ) $ s [ $ i ] ++ ; $ i ++ ; } } return $ s ; }
Hyp: 
function noAdjacentDup ( $ s1 ) { $ n = strlen ( $ s1 ) ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( $ s [ $ i ] == $ s [ $ i - 1 ] ) { $ s [ $ i ] = ' ▁ ' ; while ( $ s [ $ i ] == $ s [ $ i - 1 ] || ( $ i + 1 < $ n && $ s [ $ i ] == $ s [ $ i + 1 ] ) ) $ s [ $ i ] ++ ; $ i ++ ; } } return ( $ s ) ; }

BLEU: 91.74
Edit Sim: 7


Src: 
function centeredoctagonalNumber ( n ) { return 4 * n * ( n - 1 ) + 1 ; }
Ref: 
function cen_octagonalnum ( $ n ) { return ( 4 * $ n * $ n - 4 * $ n + 1 ) ; }
Hyp: 
function centeredoctagonalNumber ( $ n ) { return 4 * $ n * ( $ n - 1 ) + 1 ; }

BLEU: 45.13
Edit Sim: 21


Src: 
function highestPowerof2 ( n ) { let p = parseInt ( Math . log ( n ) / Math . log ( 2 ) , 10 ) ; return Math . pow ( 2 , p ) ; }
Ref: 
function highestPowerof2 ( $ n ) { $ p = ( int ) log ( $ n , 2 ) ; return ( int ) pow ( 2 , $ p ) ; }
Hyp: 
function highestPowerof2 ( $ n ) { $ p = ( int ) ( log ( $ n ) / log ( 2 ) ) ; return pow ( 2 , $ p ) ; }

BLEU: 68.69
Edit Sim: 20


Src: 
function sum ( N ) { var S1 , S2 , S3 ; S1 = ( ( ( N / 2 ) ) * parseInt ( 2 * 2 + parseInt ( N / 2 - 1 ) * 2 ) / 2 ) ; S2 = ( parseInt ( parseInt ( N / 7 ) ) * ( 2 * 7 + parseInt ( N / 7 - 1 ) * 7 ) / 2 ) ; S3 = ( parseInt ( parseInt ( N / 14 ) ) * ( 2 * 14 + parseInt ( N / 14 - 1 ) * 14 ) / 2 ) ; return S1 + S2 - S3 ; }
Ref: 
function sum ( $ N ) { $ S1 = ( int ) ( ( $ N / 2 ) ) * ( int ) ( 2 * 2 + ( int ) ( $ N / 2 - 1 ) * 2 ) / 2 ; $ S2 = ( int ) ( ( $ N / 7 ) ) * ( int ) ( 2 * 7 + ( int ) ( $ N / 7 - 1 ) * 7 ) / 2 ; $ S3 = ( int ) ( ( $ N / 14 ) ) * ( int ) ( 2 * 14 + ( int ) ( $ N / 14 - 1 ) * 14 ) / 2 ; return ( $ S1 + $ S2 ) - $ S3 ; }
Hyp: 
function sum ( $ N ) { $ S1 ; $ S2 ; $ S3 ; $ S1 = ( ( $ N / 2 ) ) * ( 2 * 2 + ( $ N / 2 - 1 ) * 2 ) / 2 ; $ S2 = ( ( $ N / 7 ) ) * ( 2 * 7 + ( $ N / 7 - 1 ) * 7 ) / 2 ) ; $ S3 = ( ( $ N / 14 ) ) * ( 2 * 14 + ( $ N / 14 - 1 ) * 14 ) / 2 ) ; return $ S1 + $ S2 - $ S3 ; }

BLEU: 69.1
Edit Sim: 87


Src: 
function printCharWithFreq ( str ) { let n = str . length ; let freq = new Array ( SIZE ) ; for ( let i = 0 ; i < freq . length ; i ++ ) { freq [ i ] = 0 ; } for ( let i = 0 ; i < n ; i ++ ) freq [ str [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; for ( let i = 0 ; i < n ; i ++ ) { if ( freq [ str [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] != 0 ) { document . write ( str [ i ] ) ; document . write ( freq [ str [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] + " " ) ; freq [ str [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] = 0 ; } } }
Ref: 
function printCharWithFreq ( $ str ) { global $ SIZE ; $ n = strlen ( $ str ) ; $ freq = array_fill ( 0 , $ SIZE , NULL ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ freq [ ord ( $ str [ $ i ] ) - ord ( ' a ' ) ] ++ ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ freq [ ord ( $ str [ $ i ] ) - ord ( ' a ' ) ] != 0 ) { echo $ str [ $ i ] . $ freq [ ord ( $ str [ $ i ] ) - ord ( ' a ' ) ] . " " ; $ freq [ ord ( $ str [ $ i ] ) - ord ( ' a ' ) ] = 0 ; } } }
Hyp: 
function printCharWithFreq ( $ str ) { $ n = strlen ( $ str ) ; $ freq = array_fill ( 0 , $ SIZE , 0 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ freq [ $ i ] = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ freq [ $ i ] = 0 ; } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ freq [ $ str [ $ i ] - '0' ] != 0 ) { echo $ str [ $ i ] ; echo $ freq [ $ str [ $ i ] - '0' ] . " ▁ " ; $ freq [ $ str [ $ i ] - '0' ] ] = 0 ; } } }

BLEU: 61.57
Edit Sim: 132


Src: 
function countPermutations ( N , B ) { var x = Math . pow ( B , N ) ; var y = Math . pow ( B , N - 1 ) ; document . write ( x - y ) ; }
Ref: 
function countPermutations ( $ N , $ B ) { $ x = pow ( $ B , $ N ) ; $ y = pow ( $ B , $ N - 1 ) ; echo ( $ x - $ y ) , " STRNEWLINE " ; }
Hyp: 
function countPermutations ( $ N , $ B ) { $ x = pow ( $ B , $ N ) ; $ y = pow ( $ B , $ N - 1 ) ; echo $ x - $ y ; }

BLEU: 81.54
Edit Sim: 21


Src: 
function numLen ( K ) { if ( K % 2 == 0 K % 5 == 0 ) return - 1 ; var number = 0 ; var len = 1 ; for ( len = 1 ; len <= K ; len ++ ) { number = ( number * 10 + 1 ) % K ; if ( number == 0 ) return len ; } return - 1 ; }
Ref: 
function numLen ( $ K ) { if ( $ K % 2 == 0 $ K % 5 == 0 ) return -1 ; $ number = 0 ; $ len = 1 ; for ( $ len = 1 ; $ len <= $ K ; $ len ++ ) { $ number = ( $ number * 10 + 1 ) % $ K ; if ( $ number == 0 ) return $ len ; } return -1 ; }
Hyp: 
function numLen ( $ K ) { if ( $ K % 2 == 0 $ K % 5 == 0 ) return -1 ; $ number = 0 ; $ len = 1 ; for ( $ len = 1 ; $ len <= $ K ; $ len ++ ) { $ number = ( $ number * 10 + 1 ) % $ K ; if ( $ number == 0 ) return $ len ; } return -1 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function printSubsets ( n ) { for ( let i = n ; i > 0 ; i = ( i - 1 ) & n ) document . write ( i + " " ) ; document . write ( " " ) ; }
Ref: 
function printSubsets ( $ n ) { for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) if ( ( $ n & $ i ) == $ i ) echo $ i . " " ; }
Hyp: 
function printSubsets ( $ n ) { for ( $ i = $ n ; $ i > 0 ; $ i = ( $ i - 1 ) & $ n ) echo $ i . " " ; echo "0" ; }

BLEU: 58.75
Edit Sim: 33


Src: 
function sumOfSeries ( n ) { return parseInt ( ( 0.6172 * ( Math . pow ( 10 , n ) - 1 ) - 0.55 * n ) ) ; }
Ref: 
function sumOfSeries ( $ n ) { return ( int ) ( 0.6172 * ( pow ( 10 , $ n ) - 1 ) - 0.55 * $ n ) ; }
Hyp: 
function sumOfSeries ( $ n ) { return ( 0.6172 * ( pow ( 10 , $ n ) - 1 ) - 0.55 * $ n ) ; }

BLEU: 88.05
Edit Sim: 8


Src: 
function maxValue ( n ) { if ( n == 1 ) return 0 ; return ( parseInt ( n * n / 2 ) - 1 ) ; }
Ref: 
function maxValue ( $ n ) { if ( $ n == 1 ) return 0 ; return ( ( $ n * $ n / 2 ) - 1 ) ; }
Hyp: 
function maxValue ( $ n ) { if ( $ n == 1 ) return 0 ; return ( $ n * $ n / 2 ) - 1 ; }

BLEU: 87.27
Edit Sim: 4


Src: 
function maxRevenue ( m , x , revenue , n , t ) { let maxRev = new Array ( m + 1 ) ; for ( let i = 0 ; i < m + 1 ; i ++ ) maxRev [ i ] = 0 ; let nxtbb = 0 ; for ( let i = 1 ; i <= m ; i ++ ) { if ( nxtbb < n ) { if ( x [ nxtbb ] != i ) maxRev [ i ] = maxRev [ i - 1 ] ; else { if ( i <= t ) maxRev [ i ] = Math . max ( maxRev [ i - 1 ] , revenue [ nxtbb ] ) ; else maxRev [ i ] = Math . max ( maxRev [ i - t - 1 ] + revenue [ nxtbb ] , maxRev [ i - 1 ] ) ; nxtbb ++ ; } } else maxRev [ i ] = maxRev [ i - 1 ] ; } return maxRev [ m ] ; }
Ref: 
function maxRevenue ( $ m , $ x , $ revenue , $ n , $ t ) { $ maxRev = array_fill ( 0 , $ m + 1 , false ) ; $ nxtbb = 0 ; for ( $ i = 1 ; $ i <= $ m ; $ i ++ ) { if ( $ nxtbb < $ n ) { if ( $ x [ $ nxtbb ] != $ i ) $ maxRev [ $ i ] = $ maxRev [ $ i - 1 ] ; else { if ( $ i <= $ t ) $ maxRev [ $ i ] = max ( $ maxRev [ $ i - 1 ] , $ revenue [ $ nxtbb ] ) ; else $ maxRev [ $ i ] = max ( $ maxRev [ $ i - $ t - 1 ] + $ revenue [ $ nxtbb ] , $ maxRev [ $ i - 1 ] ) ; $ nxtbb ++ ; } } else $ maxRev [ $ i ] = $ maxRev [ $ i - 1 ] ; } return $ maxRev [ $ m ] ; }
Hyp: 
function maxRevenue ( $ m , $ x , $ revenue , $ n , $ t ) { $ maxRev = array ( ) ; for ( $ i = 0 ; $ i < $ m + 1 ; $ i ++ ) $ maxRev [ $ i ] = 0 ; $ nxtbb = 0 ; for ( $ i = 1 ; $ i <= $ m ; $ i ++ ) { if ( $ x [ $ nxtbb ] != $ i ) $ maxRev [ $ i ] = $ maxRev [ $ i - 1 ] ; else { if ( $ i <= $ t ) $ maxRev [ $ i ] = max ( $ maxRev [ $ i - 1 ] , $ revenue [ $ nxtbb ] ) ; else $ maxRev [ $ i ] = max ( $ maxRev [ $ i - $ t - 1 ] + $ revenue [ $ nxtbb ] , $ maxRev [ $ i - 1 ] ) ; $ nxtbb ++ ; } } else $ maxRev [ $ i ] = $ maxRev [ $ i - 1 ] ; } return $ maxRev [ $ m ] ; }

BLEU: 87.12
Edit Sim: 72


Src: 
function sortExceptUandL ( a , l , u , n ) { let b = [ ] ; for ( let i = 0 ; i < l ; i ++ ) b [ i ] = a [ i ] ; for ( let i = u + 1 ; i < n ; i ++ ) b [ l + ( i - ( u + 1 ) ) ] = a [ i ] ; b . sort ( ) ; for ( let i = 0 ; i < l ; i ++ ) a [ i ] = b [ i ] ; for ( let i = u + 1 ; i < n ; i ++ ) a [ i ] = b [ l + ( i - ( u + 1 ) ) ] ; }
Ref: 
function sortExceptUandL ( $ a , $ l , $ u , $ n ) { $ b = array ( ) ; for ( $ i = 0 ; $ i < $ l ; $ i ++ ) $ b [ $ i ] = $ a [ $ i ] ; for ( $ i = $ u + 1 ; $ i < $ n ; $ i ++ ) $ b [ $ l + ( $ i - ( $ u + 1 ) ) ] = $ a [ $ i ] ; sort ( $ b ) ; for ( $ i = 0 ; $ i < $ l ; $ i ++ ) $ a [ $ i ] = $ b [ $ i ] ; for ( $ i = $ u + 1 ; $ i < $ n ; $ i ++ ) $ a [ $ i ] = $ b [ $ l + ( $ i - ( $ u + 1 ) ) ] ; }
Hyp: 
function sortExceptUandL ( & $ a , $ l , $ u , $ n ) { $ b = array ( ) ; for ( $ i = 0 ; $ i < $ l ; $ i ++ ) $ b [ $ i ] = $ a [ $ i ] ; for ( $ i = $ u + 1 ; $ i < $ n ; $ i ++ ) $ b [ $ l + ( $ i - ( $ u + 1 ) ) ] = $ a [ $ i ] ; sort ( $ b ) ; for ( $ i = 0 ; $ i < $ l ; $ i ++ ) $ a [ $ i ] = $ b [ $ i ] ; for ( $ i = $ u + 1 ; $ i < $ n ; $ i ++ ) $ a [ $ i ] = $ b [ $ l + ( $ i - ( $ u + 1 ) ) ] ; $ a = array ( ) ; }

BLEU: 94.77
Edit Sim: 20


Src: 
function PowerOFPINnfactorial ( n , p ) { let ans = 0 ; let temp = p ; while ( temp <= n ) { ans += n / temp ; temp = temp * p ; } return ans ; }
Ref: 
function PowerOFPINnfactorial ( $ n , $ p ) { $ ans = 0 ; $ temp = $ p ; while ( $ temp <= $ n ) { $ ans += $ n / $ temp ; $ temp = $ temp * $ p ; } return $ ans ; }
Hyp: 
function PowerOFPINnfactorial ( $ n , $ p ) { $ ans = 0 ; $ temp = $ p ; while ( $ temp <= $ n ) { $ ans += $ n / $ temp ; $ temp = $ temp * $ p ; } return $ ans ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function eulerian ( n , m ) { var dp = Array . from ( Array ( n + 1 ) , ( ) => Array ( m + 1 ) . fill ( 0 ) ) ; for ( var i = 1 ; i <= n ; i ++ ) { for ( var j = 0 ; j <= m ; j ++ ) { if ( i > j ) { if ( j == 0 ) dp [ i ] [ j ] = 1 ; else dp [ i ] [ j ] = ( ( i - j ) * dp [ i - 1 ] [ j - 1 ] ) + ( ( j + 1 ) * dp [ i - 1 ] [ j ] ) ; } } } return dp [ n ] [ m ] ; }
Ref: 
function eulerian ( $ n , $ m ) { $ dp = array ( array ( ) ) ; for ( $ i = 0 ; $ i < $ n + 1 ; $ i ++ ) for ( $ j = 0 ; $ j < $ m + 1 ; $ j ++ ) $ dp [ $ i ] [ $ j ] = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 0 ; $ j <= $ m ; $ j ++ ) { if ( $ i > $ j ) { if ( $ j == 0 ) $ dp [ $ i ] [ $ j ] = 1 ; else $ dp [ $ i ] [ $ j ] = ( ( $ i - $ j ) * $ dp [ $ i - 1 ] [ $ j - 1 ] ) + ( ( $ j + 1 ) * $ dp [ $ i - 1 ] [ $ j ] ) ; } } } return $ dp [ $ n ] [ $ m ] ; }
Hyp: 
function eulerian ( $ n , $ m ) { $ dp [ $ n + 1 ] [ $ m + 1 ] = array ( ) ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 0 ; $ j <= $ m ; $ j ++ ) { if ( $ i > $ j ) { if ( $ j == 0 ) $ dp [ $ i ] [ $ j ] = 1 ; else $ dp [ $ i ] [ $ j ] = ( ( $ i - $ j ) * $ dp [ $ i - 1 ] [ $ j - 1 ] ) + ( ( $ j + 1 ) * $ dp [ $ i - 1 ] [ $ j ] ) ; } } } return $ dp [ $ n ] [ $ m ] ; }

BLEU: 75.03
Edit Sim: 106


Src: 
function nonDecNums ( n ) { let a = new Array ( n + 1 ) for ( let i = 0 ; i < n + 1 ; i ++ ) { a [ i ] = new Array ( 10 ) ; } for ( let i = 0 ; i <= 9 ; i ++ ) a [ 0 ] [ i ] = 1 ; for ( let i = 1 ; i <= n ; i ++ ) a [ i ] [ 9 ] = 1 ; for ( let i = 1 ; i <= n ; i ++ ) for ( let j = 8 ; j >= 0 ; j -- ) a [ i ] [ j ] = a [ i - 1 ] [ j ] + a [ i ] [ j + 1 ] ; return a [ n ] [ 0 ] ; }
Ref: 
function nonDecNums ( $ n ) { for ( $ i = 0 ; $ i <= 9 ; $ i ++ ) $ a [ 0 ] [ $ i ] = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ a [ $ i ] [ 9 ] = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) for ( $ j = 8 ; $ j >= 0 ; $ j -- ) $ a [ $ i ] [ $ j ] = $ a [ $ i - 1 ] [ $ j ] + $ a [ $ i ] [ $ j + 1 ] ; return $ a [ $ n ] [ 0 ] ; }
Hyp: 
function nonDecNums ( $ n ) { $ a = array_fill ( 0 , $ n + 1 , array_fill ( 0 , 10 , 0 ) ) ; for ( $ i = 0 ; $ i <= 9 ; $ i ++ ) $ a [ 0 ] [ $ i ] = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ a [ $ i ] [ 9 ] = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) for ( $ j = 8 ; $ j >= 0 ; $ j -- ) $ a [ $ i ] [ $ j ] = $ a [ $ i - 1 ] [ $ j ] + $ a [ $ i ] [ $ j + 1 ] ; return $ a [ $ n ] [ 0 ] ; }

BLEU: 85.96
Edit Sim: 63


Src: 
function isPowerOfTwo ( n ) { if ( n == 0 ) return 0 ; while ( n != 1 ) { if ( n % 2 != 0 ) return 0 ; n = n / 2 ; } return 1 ; }
Ref: 
function isPowerOfTwo ( $ n ) { if ( $ n == 0 ) return 0 ; while ( $ n != 1 ) { if ( $ n % 2 != 0 ) return 0 ; $ n = $ n / 2 ; } return 1 ; }
Hyp: 
function isPowerOfTwo ( $ n ) { if ( $ n == 0 ) return 0 ; while ( $ n != 1 ) { if ( $ n % 2 != 0 ) return 0 ; $ n = $ n / 2 ; } return 1 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function Series ( x , n ) { var sum = 1 , term = 1 , fct = 1 ; var p = 1 , multi = 1 ; for ( let i = 1 ; i < n ; i ++ ) { fct = fct * multi * ( multi + 1 ) ; p = p * x * x ; term = ( - 1 ) * term ; multi += 2 ; sum = sum + ( term * p ) / fct ; } return sum ; }
Ref: 
function Series ( $ x , $ n ) { $ sum = 1 ; $ term = 1 ; $ fct = 1 ; $ p = 1 ; $ multi = 1 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ fct = $ fct * $ multi * ( $ multi + 1 ) ; $ p = $ p * $ x * $ x ; $ term = ( -1 ) * $ term ; $ multi += 2 ; $ sum = $ sum + ( $ term * $ p ) / $ fct ; } return $ sum ; }
Hyp: 
function Series ( $ x , $ n ) { $ sum = 1 ; $ term = 1 ; $ fct = 1 ; $ p = 1 ; $ multi = 1 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ fct = $ fct * $ multi * ( $ multi + 1 ) ; $ p = $ p * $ x * $ x ; $ term = ( -1 ) * $ term ; $ multi += 2 ; $ sum = $ sum + ( $ term * $ p ) / $ fct ; } return $ sum ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countSubStr ( str , n ) { var len = str . length ; return len - n + 1 ; }
Ref: 
function countSubStr ( $ str , $ n ) { $ len = strlen ( $ str ) ; return ( $ len - $ n + 1 ) ; }
Hyp: 
function countSubStr ( $ str , $ n ) { $ len = strlen ( $ str ) ; return ( $ len - $ n + 1 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findMajority ( arr , n ) { return arr [ Math . floor ( n / 2 ) ] ; }
Ref: 
function findMajority ( $ arr , $ n ) { return $ arr [ intval ( $ n / 2 ) ] ; }
Hyp: 
function findMajority ( $ arr , $ n ) { return $ arr [ ( int ) ( $ n / 2 ) ] ; }

BLEU: 81.96
Edit Sim: 5


Src: 
function countOrderedPairs ( N ) { var count_pairs = 0 ; for ( var i = 1 ; i <= Math . sqrt ( N - 1 ) ; ++ i ) { for ( var j = i ; j * i < N ; ++ j ) ++ count_pairs ; } count_pairs *= 2 ; count_pairs -= parseInt ( Math . sqrt ( N - 1 ) ) ; return count_pairs ; }
Ref: 
function countOrderedPairs ( $ N ) { $ count_pairs = 0 ; for ( $ i = 1 ; $ i <= sqrt ( $ N - 1 ) ; ++ $ i ) { for ( $ j = $ i ; $ j * $ i < $ N ; ++ $ j ) ++ $ count_pairs ; } $ count_pairs *= 2 ; $ count_pairs -= ( sqrt ( $ N - 1 ) ) ; return $ count_pairs ; }
Hyp: 
function countOrderedPairs ( $ N ) { $ count_pairs = 0 ; for ( $ i = 1 ; $ i <= sqrt ( $ N - 1 ) ; ++ $ i ) { for ( $ j = $ i ; $ j * $ i < $ N ; ++ $ j ) ++ $ count_pairs ; } $ count_pairs *= 2 ; $ count_pairs -= ceil ( sqrt ( $ N - 1 ) ) ; return $ count_pairs ; }

BLEU: 97.01
Edit Sim: 5


Src: 
function maxvolume ( s ) { let length = parseInt ( s / 3 ) ; s -= length ; let breadth = parseInt ( s / 2 ) ; let height = s - breadth ; return length * breadth * height ; }
Ref: 
function maxvolume ( $ s ) { $ length = ( int ) ( $ s / 3 ) ; $ s -= $ length ; $ breadth = ( int ) ( $ s / 2 ) ; $ height = $ s - $ breadth ; return $ length * $ breadth * $ height ; }
Hyp: 
function maxvolume ( $ s ) { $ length = ( int ) ( $ s / 3 ) ; $ s -= $ length ; $ breadth = ( int ) ( $ s / 2 ) ; $ height = $ s - $ breadth ; return ( $ length * $ breadth * $ height ) ; }

BLEU: 92.03
Edit Sim: 4


Src: 
function countWays ( n ) { let count = 0 ; for ( let i = 1 ; i * i < n ; i ++ ) if ( n % i == 0 ) count ++ ; return count ; }
Ref: 
function countWays ( $ n ) { $ count = 0 ; for ( $ i = 1 ; $ i * $ i < $ n ; $ i ++ ) if ( $ n % $ i == 0 ) $ count ++ ; return $ count ; }
Hyp: 
function countWays ( $ n ) { $ count = 0 ; for ( $ i = 1 ; $ i * $ i < $ n ; $ i ++ ) if ( $ n % $ i == 0 ) $ count ++ ; return $ count ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function averageEven ( n ) { if ( n % 2 != 0 ) { document . write ( " " ) ; return - 1 ; } return ( n + 2 ) / 2 ; }
Ref: 
function averageEven ( $ n ) { if ( $ n % 2 != 0 ) { echo ( " Invalid ▁ Input " ) ; return -1 ; } return ( $ n + 2 ) / 2 ; }
Hyp: 
function averageEven ( $ n ) { if ( $ n % 2 != 0 ) { echo " No " ; return -1 ; } return ( $ n + 2 ) / 2 ; }

BLEU: 79.63
Edit Sim: 19


Src: 
function evenPowerSum ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { let j = 2 * i ; sum = sum + ( j * j * j * j ) ; } return sum ; }
Ref: 
function evenPowerSum ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ j = 2 * $ i ; $ sum = $ sum + ( $ j * $ j * $ j * $ j ) ; } return $ sum ; }
Hyp: 
function evenPowerSum ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ j = 2 * $ i ; $ sum = $ sum + ( $ j * $ j * $ j * $ j ) ; } return $ sum ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function kthgroupsum ( k ) { let cur = ( k * ( k - 1 ) ) + 1 ; let sum = 0 ; while ( k -- ) { sum += cur ; cur += 2 ; } return sum ; }
Ref: 
function kthgroupsum ( $ k ) { $ cur = ( $ k * ( $ k - 1 ) ) + 1 ; $ sum = 0 ; while ( $ k -- ) { $ sum += $ cur ; $ cur += 2 ; } return $ sum ; }
Hyp: 
function kthgroupsum ( $ k ) { $ cur = ( $ k * ( $ k - 1 ) ) + 1 ; $ sum = 0 ; while ( $ k -- ) { $ sum += $ cur ; $ cur += 2 ; } return $ sum ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function solve ( A , B , C ) { let i , j , k ; i = A . length - 1 ; j = B . length - 1 ; k = C . length - 1 ; let min_diff , current_diff , max_term ; min_diff = Math . abs ( Math . max ( A [ i ] , Math . max ( B [ j ] , C [ k ] ) ) - Math . min ( A [ i ] , Math . min ( B [ j ] , C [ k ] ) ) ) ; while ( i != - 1 && j != - 1 && k != - 1 ) { current_diff = Math . abs ( Math . max ( A [ i ] , Math . max ( B [ j ] , C [ k ] ) ) - Math . min ( A [ i ] , Math . min ( B [ j ] , C [ k ] ) ) ) ; if ( current_diff < min_diff ) min_diff = current_diff ; max_term = Math . max ( A [ i ] , Math . max ( B [ j ] , C [ k ] ) ) ; if ( A [ i ] == max_term ) i -= 1 ; else if ( B [ j ] == max_term ) j -= 1 ; else k -= 1 ; } return min_diff ; }
Ref: 
function solve ( $ A , $ B , $ C , $ i , $ j , $ k ) { $ min_diff ; $ current_diff ; $ max_term ; $ min_diff = abs ( max ( $ A [ $ i ] , max ( $ B [ $ j ] , $ C [ $ k ] ) ) - min ( $ A [ $ i ] , min ( $ B [ $ j ] , $ C [ $ k ] ) ) ) ; while ( $ i != -1 && $ j != -1 && $ k != -1 ) { $ current_diff = abs ( max ( $ A [ $ i ] , max ( $ B [ $ j ] , $ C [ $ k ] ) ) - min ( $ A [ $ i ] , min ( $ B [ $ j ] , $ C [ $ k ] ) ) ) ; if ( $ current_diff < $ min_diff ) $ min_diff = $ current_diff ; $ max_term = max ( $ A [ $ i ] , max ( $ B [ $ j ] , $ C [ $ k ] ) ) ; if ( $ A [ $ i ] == $ max_term ) $ i -= 1 ; else if ( $ B [ $ j ] == $ max_term ) $ j -= 1 ; else $ k -= 1 ; } return $ min_diff ; }
Hyp: 
function solve ( $ A , $ B , $ C ) { $ i = strlen ( $ A ) - 1 ; $ j = strlen ( $ B ) - 1 ; $ k = strlen ( $ C ) - 1 ; $ min_diff = abs ( max ( $ A [ $ i ] , max ( $ B [ $ j ] , $ C [ $ k ] ) ) - min ( $ A [ $ i ] , min ( $ B [ $ j ] , $ C [ $ k ] ) ) ; if ( $ current_diff < $ min_diff ) $ min_diff = $ current_diff ; $ max_term = max ( $ A [ $ i ] , max ( $ B [ $ j ] , $ C [ $ k ] ) ) ; if ( $ A [ $ i ] == $ max_term ) $ i -= 1 ; else if ( $ B [ $ j ] == $ max_term ) $ j -= 1 ; else $ k -= 1 ; } return $ min_diff ; }

BLEU: 62.58
Edit Sim: 199


Src: 
function removeChars ( s ) { let modifiedStr = " " ; modifiedStr += s [ 0 ] ; for ( let i = 1 ; i < s . length ; i ++ ) { if ( s [ i ] == ( s [ i ] ) . toUpperCase ( ) && ( s [ i - 1 ] ) == ( s [ i - 1 ] ) . toLowerCase ( ) || s [ i ] == s [ i ] . toLowerCase ( ) && ( s [ i - 1 ] ) == ( s [ i - 1 ] ) . toUpperCase ( ) ) modifiedStr += s [ i ] ; } return modifiedStr ; }
Ref: 
function removeChars ( $ s ) { $ modifiedStr = " " ; $ modifiedStr = $ modifiedStr . $ s [ 0 ] ; for ( $ i = 1 ; $ i < strlen ( $ s ) ; $ i ++ ) { if ( ctype_upper ( $ s [ $ i ] ) && ctype_lower ( $ s [ $ i - 1 ] ) || ctype_lower ( $ s [ $ i ] ) && ctype_upper ( $ s [ $ i - 1 ] ) ) $ modifiedStr = $ modifiedStr . $ s [ $ i ] ; } return $ modifiedStr ; }
Hyp: 
function removeChars ( $ s ) { $ modifiedStr = " ▁ " ; $ modifiedStr += $ s [ 0 ] ; for ( $ i = 1 ; $ i < strlen ( $ s ) ; $ i ++ ) { if ( $ s [ $ i ] == ( $ s [ $ i ] ) . toUpperCase ( ) && ( $ s [ $ i - 1 ] ) == ( $ s [ $ i - 1 ] ) . toLowerCase ( ) || $ s [ $ i ] == $ s [ $ i ] ) && ( $ s [ $ i - 1 ] ) . toUpperCase ( ) ) $ modifiedStr += $ s [ $ i ] ; } return $ modifiedStr ; }

BLEU: 62.86
Edit Sim: 121


Src: 
function equilibrium ( arr , n ) { var i , j ; var leftsum , rightsum ; for ( i = 0 ; i < n ; ++ i ) { leftsum = 0 ; rightsum = 0 ; for ( let j = 0 ; j < i ; j ++ ) leftsum += arr [ j ] ; for ( let j = i + 1 ; j < n ; j ++ ) rightsum += arr [ j ] ; if ( leftsum == rightsum ) return i ; } return - 1 ; }
Ref: 
function equilibrium ( $ arr , $ n ) { $ i ; $ j ; $ leftsum ; $ rightsum ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { $ leftsum = 0 ; $ rightsum = 0 ; for ( $ j = 0 ; $ j < $ i ; $ j ++ ) $ leftsum += $ arr [ $ j ] ; for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) $ rightsum += $ arr [ $ j ] ; if ( $ leftsum == $ rightsum ) return $ i ; } return -1 ; }
Hyp: 
function equilibrium ( $ arr , $ n ) { $ i ; $ j ; $ leftsum ; $ rightsum ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { $ leftsum = 0 ; $ rightsum = 0 ; for ( $ j = 0 ; $ j < $ i ; $ j ++ ) $ leftsum += $ arr [ $ j ] ; for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) $ rightsum += $ arr [ $ j ] ; if ( $ leftsum == $ rightsum ) return $ i ; } return -1 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findKHCF ( x , y , k ) { let small = Math . min ( x , y ) ; let count = 1 ; for ( let i = 2 ; i <= small ; i ++ ) { if ( x % i == 0 && y % i == 0 ) count ++ ; if ( count == k ) return i ; } return - 1 ; }
Ref: 
function findKCF ( $ x , $ y , $ k ) { $ small = min ( $ x , $ y ) ; $ count = 1 ; for ( $ i = 2 ; $ i <= $ small ; $ i ++ ) { if ( $ x % $ i == 0 && $ y % $ i == 0 ) $ count ++ ; if ( $ count == $ k ) return $ i ; } return -1 ; }
Hyp: 
function findKHCF ( $ x , $ y , $ k ) { $ small = min ( $ x , $ y ) ; $ count = 1 ; for ( $ i = 2 ; $ i <= $ small ; $ i ++ ) { if ( $ x % $ i == 0 && $ y % $ i == 0 ) $ count ++ ; if ( $ count == $ k ) return $ i ; } return -1 ; }

BLEU: 97.97
Edit Sim: 1


Src: 
function printAMeans ( A , B , N ) { let d = ( B - A ) / ( N + 1 ) ; for ( let i = 1 ; i <= N ; i ++ ) document . write ( ( A + i * d ) + " " ) ; }
Ref: 
function printAMeans ( $ A , $ B , $ N ) { $ d = ( $ B - $ A ) / ( $ N + 1 ) ; for ( $ i = 1 ; $ i <= $ N ; $ i ++ ) echo ( $ A + $ i * $ d ) , " ▁ " ; }
Hyp: 
function printAMeans ( $ A , $ B , $ N ) { $ d = ( $ B - $ A ) / ( $ N + 1 ) ; for ( $ i = 1 ; $ i <= $ N ; $ i ++ ) echo ( $ A + $ i * $ d ) , " ▁ " ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function isSymmetric ( mat , N ) { for ( let i = 0 ; i < N ; i ++ ) for ( let j = 0 ; j < N ; j ++ ) if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) return false ; return true ; }
Ref: 
function isSymmetric ( $ mat , $ N ) { for ( $ i = 0 ; $ i < $ N ; $ i ++ ) for ( $ j = 0 ; $ j < $ N ; $ j ++ ) if ( $ mat [ $ i ] [ $ j ] != $ mat [ $ j ] [ $ i ] ) return false ; return true ; }
Hyp: 
function isSymmetric ( $ mat , $ N ) { for ( $ i = 0 ; $ i < $ N ; $ i ++ ) for ( $ j = 0 ; $ j < $ N ; $ j ++ ) if ( $ mat [ $ i ] [ $ j ] != $ mat [ $ j ] [ $ i ] ) return false ; return true ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function breakSum ( n ) { if ( n == 0 n == 1 ) return n ; return Math . max ( ( breakSum ( Math . floor ( n / 2 ) ) + breakSum ( Math . floor ( n / 3 ) ) + breakSum ( Math . floor ( n / 4 ) ) ) , n ) ; }
Ref: 
function breakSum ( $ n ) { if ( $ n == 0 $ n == 1 ) return $ n ; return max ( ( breakSum ( intval ( $ n / 2 ) ) + breakSum ( intval ( $ n / 3 ) ) + breakSum ( intval ( $ n / 4 ) ) ) , $ n ) ; }
Hyp: 
function breakSum ( $ n ) { if ( $ n == 0 $ n == 1 ) return $ n ; return max ( ( breakSum ( $ n / 2 ) ) + breakSum ( $ n / 3 ) + breakSum ( $ n / 4 ) ) ) ; }

BLEU: 75.44
Edit Sim: 37


Src: 
function sum ( L , R ) { let p = Math . floor ( R / 6 ) ; let q = Math . floor ( ( L - 1 ) / 6 ) ; let sumR = Math . floor ( 3 * ( p * ( p + 1 ) ) ) ; let sumL = Math . floor ( ( q * ( q + 1 ) ) * 3 ) ; return sumR - sumL ; }
Ref: 
function sum ( $ L , $ R ) { $ p = intval ( $ R / 6 ) ; $ q = intval ( ( $ L - 1 ) / 6 ) ; $ sumR = intval ( 3 * ( $ p * ( $ p + 1 ) ) ) ; $ sumL = intval ( ( $ q * ( $ q + 1 ) ) * 3 ) ; return $ sumR - $ sumL ; }
Hyp: 
function sum ( $ L , $ R ) { $ p = intdiv ( $ R , 6 ) ; $ q = intdiv ( $ L - 1 , 6 ) ; $ sumR = 3 * ( $ p * ( $ p + 1 ) ) ; $ sumL = intdiv ( ( $ q * ( $ q + 1 ) ) * 3 ) ; return $ sumR - $ sumL ; }

BLEU: 76.2
Edit Sim: 26


Src: 
function max_area ( n , m , k ) { if ( k > ( n + m - 2 ) ) document . write ( " " ) ; else { let result ; if ( k < Math . max ( m , n ) - 1 ) { result = Math . max ( m * ( n / ( k + 1 ) ) , n * ( m / ( k + 1 ) ) ) ; } else { result = Math . max ( m / ( k - n + 2 ) , n / ( k - m + 2 ) ) ; } document . write ( result ) ; } }
Ref: 
function max_area ( $ n , $ m , $ k ) { if ( $ k > ( $ n + $ m - 2 ) ) echo " Not ▁ possible " , " STRNEWLINE " ; else { $ result ; if ( $ k < max ( $ m , $ n ) - 1 ) { $ result = max ( $ m * ( $ n / ( $ k + 1 ) ) , $ n * ( $ m / ( $ k + 1 ) ) ) ; } else { $ result = max ( $ m / ( $ k - $ n + 2 ) , $ n / ( $ k - $ m + 2 ) ) ; } echo $ result , " STRNEWLINE " ; } }
Hyp: 
function max_area ( $ n , $ m , $ k ) { if ( $ k > ( $ n + $ m - 2 ) ) echo " No " ; else { $ result ; if ( $ k < max ( $ m , $ n ) - 1 ) { $ result = max ( $ m * ( $ n / ( $ k + 1 ) ) , $ n * ( $ m / ( $ k + 1 ) ) ) ; } else { $ result = max ( $ m / ( $ k - $ n + 2 ) , $ n / ( $ k - $ m + 2 ) ) ; } echo $ result ; }

BLEU: 89.36
Edit Sim: 48


Src: 
function countSubArrays ( arr , n , K ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i ; j < n ; j ++ ) { let bitwise_or = 0 ; for ( let k = i ; k <= j ; k ++ ) { bitwise_or = bitwise_or | arr [ k ] ; } if ( bitwise_or >= K ) count ++ ; } } return count ; }
Ref: 
function countSubArrays ( $ arr , $ n , $ K ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { $ bitwise_or = 0 ; for ( $ k = $ i ; $ k < $ j + 1 ; $ k ++ ) $ bitwise_or = $ bitwise_or | $ arr [ $ k ] ; if ( $ bitwise_or >= $ K ) $ count += 1 ; } } return $ count ; }
Hyp: 
function countSubArrays ( $ arr , $ n , $ K ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = $ i ; $ j < $ n ; $ j ++ ) { $ bitwise_or = 0 ; for ( $ k = $ i ; $ k <= $ j ; $ k ++ ) { $ bitwise_or = $ bitwise_or | $ arr [ $ k ] ; } if ( $ bitwise_or >= $ K ) $ count ++ ; } } return $ count ; }

BLEU: 86.52
Edit Sim: 15


Src: 
function thirdLargest ( arr , arr_size ) { if ( arr_size < 3 ) { document . write ( " " ) ; return ; } let first = arr [ 0 ] ; for ( let i = 1 ; i < arr_size ; i ++ ) if ( arr [ i ] > first ) first = arr [ i ] ; let second = Number . MIN_VALUE ; for ( let i = 0 ; i < arr_size ; i ++ ) if ( arr [ i ] > second && arr [ i ] < first ) second = arr [ i ] ; let third = Number . MIN_VALUE ; for ( let i = 0 ; i < arr_size ; i ++ ) if ( arr [ i ] > third && arr [ i ] < second ) third = arr [ i ] ; document . write ( " " + " " , third ) ; }
Ref: 
function thirdLargest ( $ arr , $ arr_size ) { if ( $ arr_size < 3 ) { echo " ▁ Invalid ▁ Input ▁ " ; return ; } $ first = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ arr_size ; $ i ++ ) if ( $ arr [ $ i ] > $ first ) $ first = $ arr [ $ i ] ; $ second = PHP_INT_MIN ; for ( $ i = 0 ; $ i < $ arr_size ; $ i ++ ) if ( $ arr [ $ i ] > $ second && $ arr [ $ i ] < $ first ) $ second = $ arr [ $ i ] ; $ third = PHP_INT_MIN ; for ( $ i = 0 ; $ i < $ arr_size ; $ i ++ ) if ( $ arr [ $ i ] > $ third && $ arr [ $ i ] < $ second ) $ third = $ arr [ $ i ] ; echo " The ▁ third ▁ Largest ▁ element ▁ is ▁ " , $ third , " STRNEWLINE " ; }
Hyp: 
function thirdLargest ( $ arr , $ arr_size ) { if ( $ arr_size < 3 ) { echo " The ▁ largest ▁ element ▁ is ▁ " , " STRNEWLINE " ; return ; } $ first = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ arr_size ; $ i ++ ) if ( $ arr [ $ i ] > $ first ) $ first = $ arr [ $ i ] ; $ second = PHP_INT_MIN ; for ( $ i = 0 ; $ i < $ arr_size ; $ i ++ ) if ( $ arr [ $ i ] > $ second && $ arr [ $ i ] < $ first ) $ second = $ arr [ $ i ] ; $ third = PHP_INT_MIN ; for ( $ i = 0 ; $ i < $ arr_size ; $ i ++ ) if ( $ arr [ $ i ] > $ third && $ arr [ $ i ] < $ second ) $ third = $ arr [ $ i ] ; echo " The ▁ largest ▁ element ▁ is ▁ " , $ third ; }

BLEU: 93.72
Edit Sim: 65


Src: 
function reverse ( str , x ) { var n = ( str . length - x ) / 2 ; for ( i = 0 ; i < n ; i ++ ) document . write ( str . charAt ( i ) ) ; for ( i = n + x - 1 ; i >= n ; i -- ) document . write ( str . charAt ( i ) ) ; for ( i = n + x ; i < str . length ; i ++ ) document . write ( str . charAt ( i ) ) ; }
Ref: 
function reverse ( $ str , $ x ) { $ n = ( strlen ( $ str ) - $ x ) / 2 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo ( $ str [ $ i ] ) ; for ( $ i = $ n + $ x - 1 ; $ i >= $ n ; $ i -- ) echo ( $ str [ $ i ] ) ; for ( $ i = $ n + $ x ; $ i < strlen ( $ str ) ; $ i ++ ) echo $ str [ $ i ] ; }
Hyp: 
function reverse ( $ str , $ x ) { $ n = ( strlen ( $ str ) - $ x ) / 2 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ str [ $ i ] ; for ( $ i = $ n + $ x - 1 ; $ i >= $ n ; $ i -- ) echo $ str [ $ i ] ; for ( $ i = $ n + $ x ; $ i < strlen ( $ str ) ; $ i ++ ) echo $ str [ $ i ] ; }

BLEU: 91.4
Edit Sim: 8


Src: 
function nthTerm ( N ) { let nth = 0 , i ; for ( i = N ; i > 0 ; i -- ) { nth += Math . pow ( i , i ) ; } return nth ; }
Ref: 
function nthTerm ( $ N ) { $ nth = 0 ; $ i ; for ( $ i = $ N ; $ i > 0 ; $ i -- ) { $ nth += pow ( $ i , $ i ) ; } return $ nth ; }
Hyp: 
function nthTerm ( $ N ) { $ nth = 0 ; for ( $ i = $ N ; $ i > 0 ; $ i -- ) { $ nth += pow ( $ i , $ i ) ; } return $ nth ; }

BLEU: 92.4
Edit Sim: 6


Src: 
function sumNodes ( l ) { let leafNodeCount = Math . pow ( 2 , l - 1 ) ; let sumLastLevel = 0 ; sumLastLevel = ( leafNodeCount * ( leafNodeCount + 1 ) ) / 2 ; let sum = sumLastLevel * l ; return sum ; }
Ref: 
function sumNodes ( $ l ) { $ leafNodeCount = ( $ l - 1 ) * ( $ l - 1 ) ; $ sumLastLevel = 0 ; $ sumLastLevel = ( $ leafNodeCount * ( $ leafNodeCount + 1 ) ) / 2 ; $ sum = $ sumLastLevel * $ l ; return $ sum ; }
Hyp: 
function sumNodes ( $ l ) { $ leafNodeCount = pow ( 2 , $ l - 1 ) ; $ sumLastLevel = 0 ; $ sumLastLevel = ( $ leafNodeCount * ( $ leafNodeCount + 1 ) ) / 2 ; $ sum = $ sumLastLevel * $ l ; return $ sum ; }

BLEU: 84.21
Edit Sim: 12


Src: 
function maxAND ( L , R ) { var maximum = L & R ; for ( var i = L ; i < R ; i ++ ) for ( var j = i + 1 ; j <= R ; j ++ ) maximum = Math . max ( maximum , ( i & j ) ) ; return maximum ; }
Ref: 
function maxAND ( $ L , $ R ) { $ maximum = $ L & $ R ; for ( $ i = $ L ; $ i < $ R ; $ i ++ ) for ( $ j = $ i + 1 ; $ j <= $ R ; $ j ++ ) $ maximum = max ( $ maximum , ( $ i & $ j ) ) ; return $ maximum ; }
Hyp: 
function maxAND ( $ L , $ R ) { $ maximum = $ L & $ R ; for ( $ i = $ L ; $ i < $ R ; $ i ++ ) for ( $ j = $ i + 1 ; $ j <= $ R ; $ j ++ ) $ maximum = max ( $ maximum , ( $ i & $ j ) ) ; return $ maximum ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findSum ( N , K ) { let ans = 0 ; for ( let i = 1 ; i <= N ; i ++ ) ans += ( i % K ) ; return ans ; }
Ref: 
function findSum ( $ N , $ K ) { $ ans = 0 ; for ( $ i = 1 ; $ i <= $ N ; $ i ++ ) $ ans += ( $ i % $ K ) ; return $ ans ; }
Hyp: 
function findSum ( $ N , $ K ) { $ ans = 0 ; for ( $ i = 1 ; $ i <= $ N ; $ i ++ ) $ ans += ( $ i % $ K ) ; return $ ans ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function maxbalancedprefix ( str , n ) { var sum = 0 ; var maxi = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( str [ i ] == ' ' ) sum += 1 ; else sum -= 1 ; if ( sum < 0 ) break ; if ( sum == 0 ) maxi = i + 1 ; } return maxi ; }
Ref: 
function maxbalancedprefix ( $ str , $ n ) { $ sum = 0 ; $ maxi = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ str [ $ i ] == ' ( ' ) $ sum += 1 ; else $ sum -= 1 ; if ( $ sum < 0 ) break ; if ( $ sum == 0 ) $ maxi = $ i + 1 ; } return $ maxi ; }
Hyp: 
function maxbalancedprefix ( $ str , $ n ) { $ sum = 0 ; $ maxi = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ str [ $ i ] == '1' ) $ sum += 1 ; else $ sum -= 1 ; if ( $ sum < 0 ) break ; if ( $ sum == 0 ) $ maxi = $ i + 1 ; } return $ maxi ; }

BLEU: 95.05
Edit Sim: 3


Src: 
function avg_of_even_num ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) sum += 2 * i ; return sum / n ; }
Ref: 
function avg_of_even_num ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ sum += 2 * $ i ; return $ sum / $ n ; }
Hyp: 
function avg_of_even_num ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ sum += 2 * $ i ; return $ sum / $ n ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function middleOfThree ( a , b , c ) { if ( a > b ) { if ( b > c ) return b ; else if ( a > c ) return c ; else return a ; } else { if ( a > c ) return a ; else if ( b > c ) return c ; else return b ; } }
Ref: 
function middleOfThree ( $ a , $ b , $ c ) { if ( $ a > $ b ) { if ( $ b > $ c ) return $ b ; else if ( $ a > $ c ) return $ c ; else return $ a ; } else { if ( $ a > $ c ) return $ a ; else if ( $ b > $ c ) return $ c ; else return $ b ; } }
Hyp: 
function middleOfThree ( $ a , $ b , $ c ) { if ( $ a > $ b ) { if ( $ b > $ c ) return $ b ; else if ( $ a > $ c ) return $ c ; else return $ a ; } else { if ( $ a > $ c ) return $ a ; else if ( $ b > $ c ) return $ c ; else return $ b ; } }

BLEU: 100.0
Edit Sim: 0


Src: 
function seriesSum ( n ) { return ( n * ( n + 1 ) * ( n + 2 ) ) / 6 ; }
Ref: 
function seriesSum ( $ n ) { return ( $ n * ( $ n + 1 ) * ( $ n + 2 ) ) / 6 ; }
Hyp: 
function seriesSum ( $ n ) { return ( $ n * ( $ n + 1 ) * ( $ n + 2 ) ) / 6 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function Valid ( a , b , c , d ) { if ( a + b + c + d == 360 ) return 1 ; return 0 ; }
Ref: 
function Valid ( $ a , $ b , $ c , $ d ) { if ( $ a + $ b + $ c + $ d == 360 ) return true ; return false ; }
Hyp: 
function Valid ( $ a , $ b , $ c , $ d ) { if ( $ a + $ b + $ c + $ d == 360 ) return 1 ; return 0 ; }

BLEU: 88.07
Edit Sim: 9


Src: 
function binarySearch ( arr , low , high ) { if ( high >= low ) { let mid = Math . floor ( ( low + high ) / 2 ) ; if ( mid == arr [ mid ] ) return mid ; if ( mid > arr [ mid ] ) return binarySearch ( arr , ( mid + 1 ) , high ) ; else return binarySearch ( arr , low , ( mid - 1 ) ) ; } return - 1 ; }
Ref: 
function binarySearch ( $ arr , $ low , $ high ) { if ( $ high >= $ low ) { $ mid = ( int ) ( ( $ low + $ high ) / 2 ) ; if ( $ mid == $ arr [ $ mid ] ) return $ mid ; if ( $ mid > $ arr [ $ mid ] ) return binarySearch ( $ arr , ( $ mid + 1 ) , $ high ) ; else return binarySearch ( $ arr , $ low , ( $ mid - 1 ) ) ; } return -1 ; }
Hyp: 
function binarySearch ( $ arr , $ low , $ high ) { if ( $ high >= $ low ) { $ mid = ( $ low + $ high ) / 2 ; if ( $ mid == $ arr [ $ mid ] ) return $ mid ; if ( $ mid > $ arr [ $ mid ] ) return binarySearch ( $ arr , ( $ mid + 1 ) , $ high ) ; else return binarySearch ( $ arr , $ low , ( $ mid - 1 ) ) ; } return -1 ; }

BLEU: 93.13
Edit Sim: 12


Src: 
function solve ( a , n ) { let min1 = a [ 0 ] ; let max1 = a [ 0 ] ; for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] > max1 ) max1 = a [ i ] ; if ( a [ i ] < min1 ) min1 = a [ i ] ; } return Math . abs ( min1 - max1 ) ; }
Ref: 
function solve ( $ a , $ n ) { $ min1 = $ a [ 0 ] ; $ max1 = $ a [ 0 ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] > $ max1 ) $ max1 = $ a [ $ i ] ; if ( $ a [ $ i ] < $ min1 ) $ min1 = $ a [ $ i ] ; } return abs ( $ min1 - $ max1 ) ; }
Hyp: 
function solve ( $ a , $ n ) { $ min1 = $ a [ 0 ] ; $ max1 = $ a [ 0 ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] > $ max1 ) $ max1 = $ a [ $ i ] ; if ( $ a [ $ i ] < $ min1 ) $ min1 = $ a [ $ i ] ; } return abs ( $ min1 - $ max1 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function minChanges ( A , n ) { var cnt = 0 ; for ( var i = 0 ; i < n - 2 ; ++ i ) { if ( ( i - 1 >= 0 ) && A [ i - 1 ] == 1 && A [ i + 1 ] == 1 && A [ i ] == 0 ) { A [ i + 1 ] = 0 ; cnt ++ ; } } return cnt ; }
Ref: 
function minChanges ( $ A , $ n ) { $ cnt = 0 ; for ( $ i = 0 ; $ i < $ n - 2 ; ++ $ i ) { if ( ( $ i - 1 >= 0 ) && $ A [ $ i - 1 ] == 1 && $ A [ $ i + 1 ] == 1 && $ A [ $ i ] == 0 ) { $ A [ $ i + 1 ] = 0 ; $ cnt ++ ; } } return $ cnt ; }
Hyp: 
function minChanges ( & $ A , $ n ) { $ cnt = 0 ; for ( $ i = 0 ; $ i < $ n - 2 ; ++ $ i ) { if ( ( $ i - 1 >= 0 ) && $ A [ $ i - 1 ] == 1 && $ A [ $ i + 1 ] == 1 && $ A [ $ i ] == 0 ) { $ A [ $ i + 1 ] = 0 ; $ cnt ++ ; } } return $ cnt ; }

BLEU: 97.49
Edit Sim: 2


Src: 
function evenSum ( n ) { var C = Array . from ( Array ( n + 1 ) , ( ) => Array ( n + 1 ) . fill ( 0 ) ) ; var i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= Math . min ( i , n ) ; j ++ ) { if ( j == 0 j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } var sum = 0 ; for ( var i = 0 ; i <= n ; i += 2 ) sum += C [ n ] [ i ] ; return sum ; }
Ref: 
function evenSum ( $ n ) { $ C = array ( array ( ) ) ; $ i ; $ j ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 0 ; $ j <= min ( $ i , $ n ) ; $ j ++ ) { if ( $ j == 0 or $ j == $ i ) $ C [ $ i ] [ $ j ] = 1 ; else $ C [ $ i ] [ $ j ] = $ C [ $ i - 1 ] [ $ j - 1 ] + $ C [ $ i - 1 ] [ $ j ] ; } } $ sum = 0 ; for ( $ i = 0 ; $ i <= $ n ; $ i += 2 ) $ sum += $ C [ $ n ] [ $ i ] ; return $ sum ; }
Hyp: 
function evenSum ( $ n ) { $ i ; $ j ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 0 ; $ j <= min ( $ i , $ n ) ; $ j ++ ) { if ( $ j == 0 $ j == $ i ) $ C [ $ i ] [ $ j ] = 1 ; else $ C [ $ i ] [ $ j ] = $ C [ $ i - 1 ] [ $ j - 1 ] + $ C [ $ i - 1 ] [ $ j ] ; } } $ sum = 0 ; for ( $ i = 0 ; $ i <= $ n ; $ i += 2 ) $ sum += $ C [ $ n ] [ $ i ] ; return $ sum ; }

BLEU: 92.21
Edit Sim: 31


Src: 
function minAdjustmentCost ( A , n , target ) { let dp = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { dp [ i ] = new Array ( n ) ; for ( let j = 0 ; j <= M ; j ++ ) { dp [ i ] [ j ] = 0 ; } } for ( let j = 0 ; j <= M ; j ++ ) dp [ 0 ] [ j ] = Math . abs ( j - A [ 0 ] ) ; for ( let i = 1 ; i < n ; i ++ ) { for ( let j = 0 ; j <= M ; j ++ ) { dp [ i ] [ j ] = Number . MAX_VALUE ; let k = Math . max ( j - target , 0 ) ; for ( ; k <= Math . min ( M , j + target ) ; k ++ ) dp [ i ] [ j ] = Math . min ( dp [ i ] [ j ] , dp [ i - 1 ] [ k ] + Math . abs ( A [ i ] - j ) ) ; } } let res = Number . MAX_VALUE ; for ( let j = 0 ; j <= M ; j ++ ) res = Math . min ( res , dp [ n - 1 ] [ j ] ) ; return res ; }
Ref: 
function minAdjustmentCost ( $ A , $ n , $ target ) { global $ M ; $ dp = array ( array ( ) ) ; for ( $ j = 0 ; $ j <= $ M ; $ j ++ ) $ dp [ 0 ] [ $ j ] = abs ( $ j - $ A [ 0 ] ) ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j <= $ M ; $ j ++ ) { $ dp [ $ i ] [ $ j ] = PHP_INT_MAX ; for ( $ k = max ( $ j - $ target , 0 ) ; $ k <= min ( $ M , $ j + $ target ) ; $ k ++ ) $ dp [ $ i ] [ $ j ] = min ( $ dp [ $ i ] [ $ j ] , $ dp [ $ i - 1 ] [ $ k ] + abs ( $ A [ $ i ] - $ j ) ) ; } } $ res = PHP_INT_MAX ; for ( $ j = 0 ; $ j <= $ M ; $ j ++ ) $ res = min ( $ res , $ dp [ $ n - 1 ] [ $ j ] ) ; return $ res ; }
Hyp: 
function minAdjustmentCost ( $ A , $ n , $ target ) { $ dp = array ( array ( ) ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j <= $ M ; $ j ++ ) $ dp [ $ i ] [ $ j ] = 0 ; for ( $ j = 0 ; $ j <= $ M ; $ j ++ ) $ dp [ 0 ] [ $ j ] = abs ( $ j - $ A [ 0 ] ) ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j <= $ M ; $ j ++ ) { $ dp [ $ i ] [ $ j ] = PHP_INT_MAX ; for ( $ k = max ( $ j - $ target , 0 ) ; for ( ; $ k <= min ( $ M , $ j + $ target ) ; $ k ++ ) $ dp [ $ i ] [ $ j ] = min ( $ dp [ $ i ] [ $ j ] , $ dp [ $ i - 1 ] [ $ k ] + abs ( $ A [ $ i ] - $ j ) ) ; } } $ res = PHP_INT_MIN ; for ( $ j = 0 ; $ j <= $ M ; $ j ++ ) $ res = min ( $ res , $ dp [ $ n - 1 ] [ $ j ] ) ; return $ res ; }

BLEU: 82.34
Edit Sim: 120


Src: 
function unitnumber ( x , y ) { x = x % 10 ; if ( y != 0 ) y = y % 4 + 4 ; return ( ( parseInt ( Math . pow ( x , y ) ) ) % 10 ) ; }
Ref: 
function unitnumber ( $ x , $ y ) { $ x = $ x % 10 ; if ( $ y != 0 ) $ y = $ y % 4 + 4 ; return ( ( ( int ) ( pow ( $ x , $ y ) ) ) % 10 ) ; }
Hyp: 
function unitnumber ( $ x , $ y ) { $ x = $ x % 10 ; if ( $ y != 0 ) $ y = $ y % 4 + 4 ; return ( ( int ) pow ( $ x , $ y ) ) % 10 ; }

BLEU: 86.76
Edit Sim: 8


Src: 
function printAllAPTriplets ( arr , n ) { for ( let i = 1 ; i < n - 1 ; i ++ ) { for ( let j = i - 1 , k = i + 1 ; j >= 0 && k < n ; ) { if ( arr [ j ] + arr [ k ] == 2 * arr [ i ] ) { document . write ( arr [ j ] + " " + arr [ i ] + " " + arr [ k ] + " " ) ; k ++ ; j -- ; } else if ( arr [ j ] + arr [ k ] < 2 * arr [ i ] ) k ++ ; else j -- ; } } }
Ref: 
function findAllTriplets ( $ arr , $ n ) { for ( $ i = 1 ; $ i < $ n - 1 ; $ i ++ ) { for ( $ j = $ i - 1 , $ k = $ i + 1 ; $ j >= 0 && $ k < $ n { if ( $ arr [ $ j ] + $ arr [ $ k ] == 2 * $ arr [ $ i ] ) { echo $ arr [ $ j ] . " ▁ " . $ arr [ $ i ] . " ▁ " . $ arr [ $ k ] . " STRNEWLINE " ; $ k ++ ; $ j -- ; } else if ( $ arr [ $ j ] + $ arr [ $ k ] < 2 * $ arr [ $ i ] ) $ k ++ ; else $ j -- ; } } }
Hyp: 
function printAllAPTriplets ( $ arr , $ n ) { for ( $ i = 1 ; $ i < $ n - 1 ; $ i ++ ) { for ( $ j = $ i - 1 ; $ k = $ i + 1 ; $ j >= 0 && $ k < $ n ; ) { if ( $ arr [ $ j ] + $ arr [ $ k ] == 2 * $ arr [ $ i ] ) { echo $ arr [ $ j ] , " " ▁ , ▁ $ arr [ $ i ] ▁ , ▁ " " ▁ , ▁ $ arr [ $ k ] ▁ , ▁ " " } else if ( $ arr [ $ j ] + $ arr [ $ k ] < 2 * $ arr [ $ i ] ) $ k ++ ; else $ j -- ; } } }

BLEU: 82.2
Edit Sim: 52


Src: 
function getTotalXorOfSubarrayXors ( arr , N ) { let res = 0 ; for ( let i = 0 ; i < N ; i ++ ) { let freq = ( i + 1 ) * ( N - i ) ; if ( freq % 2 == 1 ) res = res ^ arr [ i ] ; } return res ; }
Ref: 
function getTotalXorOfSubarrayXors ( $ arr , $ N ) { $ res = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { $ freq = ( $ i + 1 ) * ( $ N - $ i ) ; if ( $ freq % 2 == 1 ) $ res = $ res ^ $ arr [ $ i ] ; } return $ res ; }
Hyp: 
function getTotalXorOfSubarrayXors ( $ arr , $ N ) { $ res = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { $ freq = ( $ i + 1 ) * ( $ N - $ i ) ; if ( $ freq % 2 == 1 ) $ res = $ res ^ $ arr [ $ i ] ; } return $ res ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function find_consecutive_steps ( arr , len ) { let count = 0 ; let maximum = 0 ; for ( let index = 1 ; index < len ; index ++ ) { if ( arr [ index ] > arr [ index - 1 ] ) count ++ ; else { maximum = Math . max ( maximum , count ) ; count = 0 ; } } return Math . max ( maximum , count ) ; }
Ref: 
function find_consecutive_steps ( $ arr , $ len ) { $ count = 0 ; $ maximum = 0 ; for ( $ index = 1 ; $ index < $ len ; $ index ++ ) { if ( $ arr [ $ index ] > $ arr [ $ index - 1 ] ) $ count ++ ; else { $ maximum = max ( $ maximum , $ count ) ; $ count = 0 ; } } return max ( $ maximum , $ count ) ; }
Hyp: 
function find_consecutive_steps ( $ arr , $ len ) { $ count = 0 ; $ maximum = 0 ; for ( $ index = 1 ; $ index < $ len ; $ index ++ ) { if ( $ arr [ $ index ] > $ arr [ $ index - 1 ] ) $ count ++ ; else { $ maximum = max ( $ maximum , $ count ) ; $ count = 0 ; } } return max ( $ maximum , $ count ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findExtra ( arr1 , arr2 , n ) { let index = n ; let left = 0 , right = n - 1 ; while ( left <= right ) { let mid = Math . floor ( ( left + right ) / 2 ) ; if ( arr2 [ mid ] == arr1 [ mid ] ) left = mid + 1 ; else { index = mid ; right = mid - 1 ; } } return index ; }
Ref: 
function findExtra ( $ arr1 , $ arr2 , $ n ) { $ index = $ n ; $ left = 0 ; $ right = $ n - 1 ; while ( $ left <= $ right ) { $ mid = ( $ left + $ right ) / 2 ; if ( $ arr2 [ $ mid ] == $ arr1 [ $ mid ] ) $ left = $ mid + 1 ; else { $ index = $ mid ; $ right = $ mid - 1 ; } } return $ index ; } { $ arr1 = array ( 2 , 4 , 6 , 8 , 10 , 12 , 13 ) ; $ arr2 = array ( 2 , 4 , 6 , 8 , 10 , 12 ) ; $ n = sizeof ( $ arr2 ) / sizeof ( $ arr2 [ 0 ] ) ; echo findExtra ( $ arr1 , $ arr2 , $ n ) ; return 0 ; }
Hyp: 
function findExtra ( $ arr1 , $ arr2 , $ n ) { $ index = $ n ; $ left = 0 ; $ right = $ n - 1 ; while ( $ left <= $ right ) { $ mid = ( $ left + $ right ) / 2 ; if ( $ arr2 [ $ mid ] == $ arr1 [ $ mid ] ) $ left = $ mid + 1 ; else { $ index = $ mid ; $ right = $ mid - 1 ; } } return $ index ; }

BLEU: 48.06
Edit Sim: 205


Src: 
function sum ( N ) { var S1 , S2 , S3 ; S1 = ( ( N / 3 ) ) * ( 2 * 3 + ( N / 3 - 1 ) * 3 ) / 2 ; S2 = ( ( N / 4 ) ) * ( 2 * 4 + ( N / 4 - 1 ) * 4 ) / 2 ; S3 = ( ( N / 12 ) ) * ( 2 * 12 + ( N / 12 - 1 ) * 12 ) / 2 ; return S1 + S2 - S3 ; }
Ref: 
function sum ( $ N ) { $ S1 ; $ S2 ; $ S3 ; $ S1 = ( ( $ N / 3 ) ) * ( 2 * 3 + ( $ N / 3 - 1 ) * 3 ) / 2 ; $ S2 = ( ( $ N / 4 ) ) * ( 2 * 4 + ( $ N / 4 - 1 ) * 4 ) / 2 ; $ S3 = ( ( $ N / 12 ) ) * ( 2 * 12 + ( $ N / 12 - 1 ) * 12 ) / 2 ; return $ S1 + $ S2 - $ S3 ; }
Hyp: 
function sum ( $ N ) { $ S1 ; $ S2 ; $ S3 ; $ S1 = ( ( $ N / 3 ) ) * ( 2 * 3 + ( $ N / 3 - 1 ) * 3 ) / 2 ; $ S2 = ( ( $ N / 4 ) ) * ( 2 * 4 + ( $ N / 4 - 1 ) * 4 ) / 2 ; $ S3 = ( ( $ N / 12 ) ) * ( 2 * 12 + ( $ N / 12 - 1 ) * 12 ) / 2 ; return $ S1 + $ S2 - $ S3 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function haversine ( lat1 , lon1 , lat2 , lon2 ) { let dLat = ( lat2 - lat1 ) * Math . PI / 180.0 ; let dLon = ( lon2 - lon1 ) * Math . PI / 180.0 ; lat1 = ( lat1 ) * Math . PI / 180.0 ; lat2 = ( lat2 ) * Math . PI / 180.0 ; let a = Math . pow ( Math . sin ( dLat / 2 ) , 2 ) + Math . pow ( Math . sin ( dLon / 2 ) , 2 ) * Math . cos ( lat1 ) * Math . cos ( lat2 ) ; let rad = 6371 ; let c = 2 * Math . asin ( Math . sqrt ( a ) ) ; return rad * c ; }
Ref: 
function haversine ( $ lat1 , $ lon1 , $ lat2 , $ lon2 ) { $ dLat = ( $ lat2 - $ lat1 ) * M_PI / 180.0 ; $ dLon = ( $ lon2 - $ lon1 ) * M_PI / 180.0 ; $ lat1 = ( $ lat1 ) * M_PI / 180.0 ; $ lat2 = ( $ lat2 ) * M_PI / 180.0 ; $ a = pow ( sin ( $ dLat / 2 ) , 2 ) + pow ( sin ( $ dLon / 2 ) , 2 ) * cos ( $ lat1 ) * cos ( $ lat2 ) ; $ rad = 6371 ; $ c = 2 * asin ( sqrt ( $ a ) ) ; return $ rad * $ c ; }
Hyp: 
function haversine ( $ lat1 , $ lon1 , $ lat2 , $ lon2 ) { $ dLat = ( $ lat2 - $ lat1 ) * PI / 180.0 ; $ dLon = ( $ lon2 - $ lon1 ) * PI / 180.0 ; $ lat1 = ( $ lat1 ) * PI / 180.0 ; $ lat2 = ( $ lat2 ) * PI / 180.0 ; $ a = pow ( sin ( $ dLat / 2 ) , 2 ) + pow ( sin ( $ dLon / 2 ) , 2 ) * cos ( $ lat1 ) * cos ( $ lat2 ) ; $ rad = 6371 ; $ c = 2 * asin ( sqrt ( $ a ) ) ; return $ rad * $ c ; }

BLEU: 92.64
Edit Sim: 8


Src: 
function increment ( i ) { i = - ( ~ i ) ; return i ; }
Ref: 
function increment ( $ i ) { $ i = - ( ~ $ i ) ; return $ i ; }
Hyp: 
function increment ( & $ i ) { $ i = - ( ~ $ i ) ; return $ i ; }

BLEU: 88.44
Edit Sim: 2


Src: 
function printPascal ( n ) { arr = a = Array ( n ) . fill ( 0 ) . map ( x => Array ( n ) . fill ( 0 ) ) ; for ( line = 0 ; line < n ; line ++ ) { for ( i = 0 ; i <= line ; i ++ ) { if ( line == i i == 0 ) arr [ line ] [ i ] = 1 ; else arr [ line ] [ i ] = arr [ line - 1 ] [ i - 1 ] + arr [ line - 1 ] [ i ] ; document . write ( arr [ line ] [ i ] ) ; } document . write ( " " ) ; } }
Ref: 
function printPascal ( $ n ) { $ arr = array ( array ( ) ) ; for ( $ line = 0 ; $ line < $ n ; $ line ++ ) { for ( $ i = 0 ; $ i <= $ line ; $ i ++ ) { if ( $ line == $ i $ i == 0 ) $ arr [ $ line ] [ $ i ] = 1 ; else $ arr [ $ line ] [ $ i ] = $ arr [ $ line - 1 ] [ $ i - 1 ] + $ arr [ $ line - 1 ] [ $ i ] ; echo $ arr [ $ line ] [ $ i ] . " " ; } echo " STRNEWLINE " ; } }
Hyp: 
function printPascal ( $ n ) { $ arr = array_fill ( 0 , $ n , 0 ) ; for ( $ line = 0 ; $ line < $ n ; $ line ++ ) { for ( $ i = 0 ; $ i <= $ line ; $ i ++ ) { if ( $ line == $ i $ i == 0 ) $ arr [ $ line ] [ $ i ] = 1 ; else $ arr [ $ line ] [ $ i ] = $ arr [ $ line - 1 ] [ $ i - 1 ] + $ arr [ $ line - 1 ] [ $ i ] ; echo $ arr [ $ line ] [ $ i ] ; } echo " \r STRNEWLINE " ; } }

BLEU: 90.58
Edit Sim: 23


Src: 
function smallestSubWithSum ( arr , n , x ) { let curr_sum = 0 , min_len = n + 1 ; let start = 0 , end = 0 ; while ( end < n ) { while ( curr_sum <= x && end < n ) curr_sum += arr [ end ++ ] ; while ( curr_sum > x && start < n ) { if ( end - start < min_len ) min_len = end - start ; curr_sum -= arr [ start ++ ] ; } } return min_len ; }
Ref: 
function smallestSubWithSum ( $ arr , $ n , $ x ) { $ curr_sum = 0 ; $ min_len = $ n + 1 ; $ start = 0 ; $ end = 0 ; while ( $ end < $ n ) { while ( $ curr_sum <= $ x && $ end < $ n ) $ curr_sum += $ arr [ $ end ++ ] ; while ( $ curr_sum > $ x && $ start < $ n ) { if ( $ end - $ start < $ min_len ) $ min_len = $ end - $ start ; $ curr_sum -= $ arr [ $ start ++ ] ; } } return $ min_len ; }
Hyp: 
function smallestSubWithSum ( $ arr , $ n , $ x ) { $ curr_sum = 0 ; $ min_len = $ n + 1 ; $ start = 0 ; $ end = 0 ; while ( $ end < $ n ) { while ( $ curr_sum <= $ x && $ end < $ n ) $ curr_sum += $ arr [ $ end ++ ] ; while ( $ curr_sum > $ x and $ start < $ n ) { if ( $ end - $ start < $ min_len ) $ min_len = $ end - $ start ; $ curr_sum -= $ arr [ $ start ++ ] ; } } return $ min_len ; }

BLEU: 97.95
Edit Sim: 3


Src: 
function maxXOR ( mat , N ) { let r_xor , c_xor ; let max_xor = 0 ; for ( let i = 0 ; i < N ; i ++ ) { r_xor = 0 , c_xor = 0 ; for ( let j = 0 ; j < N ; j ++ ) { r_xor = r_xor ^ mat [ i ] [ j ] ; c_xor = c_xor ^ mat [ j ] [ i ] ; } if ( max_xor < Math . max ( r_xor , c_xor ) ) max_xor = Math . max ( r_xor , c_xor ) ; } return max_xor ; }
Ref: 
function maxXOR ( $ mat , $ N ) { $ r_xor ; $ c_xor ; $ max_xor = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { $ r_xor = 0 ; $ c_xor = 0 ; for ( $ j = 0 ; $ j < $ N ; $ j ++ ) { $ r_xor = $ r_xor ^ $ mat [ $ i ] [ $ j ] ; $ c_xor = $ c_xor ^ $ mat [ $ j ] [ $ i ] ; } if ( $ max_xor < max ( $ r_xor , $ c_xor ) ) $ max_xor = max ( $ r_xor , $ c_xor ) ; } return $ max_xor ; }
Hyp: 
function maxXOR ( $ mat , $ N ) { $ r_xor = 0 ; $ c_xor = 0 ; $ max_xor = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { $ r_xor = 0 ; $ c_xor = 0 ; for ( $ j = 0 ; $ j < $ N ; $ j ++ ) { $ r_xor = $ r_xor ^ $ mat [ $ i ] [ $ j ] ; $ c_xor = $ c_xor ^ $ mat [ $ j ] [ $ i ] ; } if ( $ max_xor < max ( $ r_xor , $ c_xor ) ) $ max_xor = max ( $ r_xor , $ c_xor ) ; } return $ max_xor ; }

BLEU: 94.88
Edit Sim: 8


Src: 
function divCount ( n ) { var hash = Array ( n + 1 ) . fill ( true ) ; for ( var p = 2 ; p * p < n ; p ++ ) if ( hash [ p ] == true ) for ( var i = p * 2 ; i < n ; i += p ) hash [ i ] = false ; var total = 1 ; for ( var p = 2 ; p <= n ; p ++ ) { if ( hash [ p ] ) { var count = 0 ; if ( n % p == 0 ) { while ( n % p == 0 ) { n = parseInt ( n / p ) ; count ++ ; } total = total * ( count + 1 ) ; } } } return total ; }
Ref: 
function divCount ( $ n ) { $ hash = array_fill ( 0 , $ n + 1 , 1 ) ; for ( $ p = 2 ; ( $ p * $ p ) < $ n ; $ p ++ ) if ( $ hash [ $ p ] == 1 ) for ( $ i = ( $ p * 2 ) ; $ i < $ n ; $ i = ( $ i + $ p ) ) $ hash [ $ i ] = 0 ; $ total = 1 ; for ( $ p = 2 ; $ p <= $ n ; $ p ++ ) { if ( $ hash [ $ p ] == 1 ) { $ count = 0 ; if ( $ n % $ p == 0 ) { while ( $ n % $ p == 0 ) { $ n = ( $ n / $ p ) ; $ count ++ ; } $ total = $ total * ( $ count + 1 ) ; } } } return $ total ; }
Hyp: 
function divCount ( $ n ) { $ hash = array_fill ( 0 , $ n + 1 , false ) ; for ( $ p = 2 ; $ p * $ p < $ n ; $ p ++ ) if ( $ hash [ $ p ] == true ) for ( $ i = $ p * 2 ; $ i < $ n ; $ i += $ p ) $ hash [ $ i ] = false ; $ total = 1 ; for ( $ p = 2 ; $ p <= $ n ; $ p ++ ) { if ( $ hash [ $ p ] ) { $ count = 0 ; if ( $ n % $ p == 0 ) { while ( $ n % $ p == 0 ) { $ n = ( int ) $ n / $ p ; $ count ++ ; } $ total = $ total * ( $ count + 1 ) ; } } } return $ total ; }

BLEU: 82.31
Edit Sim: 46


Src: 
function Rate ( N1 , N2 ) { var rate = ( N2 - N1 ) * 100 / N1 ; return parseInt ( rate ) ; }
Ref: 
function Rate ( $ N1 , $ N2 ) { $ rate = ( $ N2 - $ N1 ) * 100 / $ N1 ; return $ rate ; }
Hyp: 
function Rate ( $ N1 , $ N2 ) { $ rate = ( $ N2 - $ N1 ) * 100 / $ N1 ; return ( int ) $ rate ; }

BLEU: 86.36
Edit Sim: 8


Src: 
function countXorPair ( arr , n ) { let odd = 0 , even = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) even ++ ; else odd ++ ; } return odd * even ; }
Ref: 
function countXorPair ( $ arr , $ n ) { $ odd = 0 ; $ even = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] % 2 == 0 ) $ even ++ ; else $ odd ++ ; } return $ odd * $ even ; }
Hyp: 
function countXorPair ( $ arr , $ n ) { $ odd = 0 ; $ even = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] % 2 == 0 ) $ even ++ ; else $ odd ++ ; } return $ odd * $ even ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countDigits ( n ) { let ans = 0 ; for ( let i = 1 ; i <= n ; i ++ ) ans += Math . log10 ( i ) ; ans = ans * n ; return 1 + Math . floor ( ans ) ; }
Ref: 
function countDigits ( $ n ) { $ ans = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ ans += log10 ( $ i ) ; $ ans = $ ans * $ n ; return 1 + floor ( $ ans ) ; }
Hyp: 
function countDigits ( $ n ) { $ ans = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ ans += log10 ( $ i ) ; $ ans = $ ans * $ n ; return 1 + floor ( $ ans ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function complement ( num ) { var i , len = 0 , temp , comp ; temp = num ; while ( true ) { len ++ ; num = parseInt ( num / 10 ) ; if ( Math . abs ( num ) == 0 ) break ; } num = temp ; comp = parseInt ( Math . pow ( 10 , len ) - num ) ; return comp ; }
Ref: 
function complement ( $ num ) { $ i ; $ len = 0 ; $ comp ; $ temp = $ num ; while ( 1 ) { $ len ++ ; $ num = ( int ) ( $ num / 10 ) ; if ( abs ( $ num ) == 0 ) break ; } $ num = $ temp ; $ comp = pow ( 10 , $ len ) - $ num ; return $ comp ; }
Hyp: 
function complement ( $ num ) { $ i ; $ len = 0 ; $ temp = $ num ; while ( true ) { $ len ++ ; $ num = ( int ) ( $ num / 10 ) ; if ( abs ( $ num ) == 0 ) break ; } $ num = $ temp ; $ comp = pow ( 10 , $ len ) - $ num ; return $ comp ; }

BLEU: 93.03
Edit Sim: 13


Src: 
function distancesum ( x , y , n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = i + 1 ; j < n ; j ++ ) sum += ( Math . abs ( x [ i ] - x [ j ] ) + Math . abs ( y [ i ] - y [ j ] ) ) ; return sum ; }
Ref: 
function distancesum ( $ x , $ y , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) $ sum += ( abs ( $ x [ $ i ] - $ x [ $ j ] ) + abs ( $ y [ $ i ] - $ y [ $ j ] ) ) ; return $ sum ; }
Hyp: 
function distancesum ( $ x , $ y , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) $ sum += ( abs ( $ x [ $ i ] - $ x [ $ j ] ) + abs ( $ y [ $ i ] - $ y [ $ j ] ) ) ; return $ sum ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function closetAND ( arr , n , k ) { let ans = Number . MAX_VALUE ; for ( let i = 0 ; i < n ; i ++ ) { let X = arr [ i ] ; for ( let j = i ; j < n ; j ++ ) { X &= arr [ j ] ; ans = Math . min ( ans , Math . abs ( k - X ) ) ; } } return ans ; }
Ref: 
function closetAND ( & $ arr , $ n , $ k ) { $ ans = PHP_INT_MAX ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ X = $ arr [ $ i ] ; for ( $ j = $ i ; $ j < $ n ; $ j ++ ) { $ X &= $ arr [ $ j ] ; $ ans = min ( $ ans , abs ( $ k - $ X ) ) ; } } return $ ans ; }
Hyp: 
function closetAND ( $ arr , $ n , $ k ) { $ ans = PHP_INT_MAX ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ X = $ arr [ $ i ] ; for ( $ j = $ i ; $ j < $ n ; $ j ++ ) { $ X &= $ arr [ $ j ] ; $ ans = min ( $ ans , abs ( $ k - $ X ) ) ; } } return $ ans ; }

BLEU: 97.49
Edit Sim: 2


Src: 
function findSum ( N ) { return ( 2 * N * ( N + 1 ) * ( 4 * N + 17 ) + 54 * N ) / 6 ; }
Ref: 
function findSum ( $ N ) { return ( 2 * $ N * ( $ N + 1 ) * ( 4 * $ N + 17 ) + 54 * $ N ) / 6 ; }
Hyp: 
function findSum ( $ N ) { return ( 2 * $ N * ( $ N + 1 ) * ( 4 * $ N + 17 ) + 54 * $ N ) / 6 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function isEditDistanceOne ( s1 , s2 ) { let m = s1 . length , n = s2 . length ; if ( Math . abs ( m - n ) > 1 ) return false ; let count = 0 ; let i = 0 , j = 0 ; while ( i < m && j < n ) { if ( s1 [ i ] != s2 [ j ] ) { if ( count == 1 ) return false ; if ( m > n ) i ++ ; else if ( m < n ) j ++ ; else { i ++ ; j ++ ; } count ++ ; } else { i ++ ; j ++ ; } } if ( i < m j < n ) count ++ ; return count == 1 ; }
Ref: 
function isEditDistanceOne ( $ s1 , $ s2 ) { $ m = strlen ( $ s1 ) ; $ n = strlen ( $ s2 ) ; if ( abs ( $ m - $ n ) > 1 ) return false ; $ count = 0 ; $ i = 0 ; $ j = 0 ; while ( $ i < $ m && $ j < $ n ) { if ( $ s1 [ $ i ] != $ s2 [ $ j ] ) { if ( $ count == 1 ) return false ; if ( $ m > $ n ) $ i ++ ; else if ( $ m < $ n ) $ j ++ ; else { $ i ++ ; $ j ++ ; } $ count ++ ; } else { $ i ++ ; $ j ++ ; } } if ( $ i < $ m $ j < $ n ) $ count ++ ; return $ count == 1 ; }
Hyp: 
function isEditDistanceOne ( $ s1 , $ s2 ) { $ m = strlen ( $ s1 ) ; $ n = strlen ( $ s1 ) ; $ count = 0 ; $ i = 0 ; $ j = 0 ; while ( $ i < $ m && $ j < $ n ) { if ( $ s1 [ $ i ] != $ s2 [ $ j ] ) { if ( $ count == 1 ) return false ; if ( $ m > $ n ) $ i ++ ; else if ( $ m < $ n ) $ j ++ ; else { $ i ++ ; $ j ++ ; } $ count ++ ; } else { $ i ++ ; $ j ++ ; } } if ( $ i < $ m $ j < $ n ) $ count ++ ; return $ count == 1 ; }

BLEU: 88.9
Edit Sim: 44


Src: 
function cube ( h , r ) { if ( h < 0 && r < 0 ) return - 1 ; var a = Math . pow ( h , 3 ) ; return a ; }
Ref: 
function cube ( $ h , $ r ) { if ( $ h < 0 && $ r < 0 ) return -1 ; $ a = pow ( $ h , 3 ) ; return $ a ; }
Hyp: 
function cube ( $ h , $ r ) { if ( $ h < 0 && $ r < 0 ) return -1 ; $ a = pow ( $ h , 3 ) ; return $ a ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findMaximum ( arr , low , high ) { var max = arr [ low ] ; var i ; for ( i = low + 1 ; i <= high ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; else break ; } return max ; }
Ref: 
function findMaximum ( $ arr , $ low , $ high ) { $ max = $ arr [ $ low ] ; $ i ; for ( $ i = $ low ; $ i <= $ high ; $ i ++ ) { if ( $ arr [ $ i ] > $ max ) $ max = $ arr [ $ i ] ; } return $ max ; }
Hyp: 
function findMaximum ( $ arr , $ low , $ high ) { $ max = $ arr [ $ low ] ; $ i ; for ( $ i = $ low + 1 ; $ i <= $ high ; $ i ++ ) { if ( $ arr [ $ i ] > $ max ) $ max = $ arr [ $ i ] ; else break ; } return $ max ; }

BLEU: 90.57
Edit Sim: 17


Src: 
function sum ( N , X , Y ) { var S1 , S2 , S3 ; S1 = ( parseInt ( N / X ) ) * ( 2 * X + parseInt ( N / X - 1 ) * X ) / 2 ; S2 = ( parseInt ( N / Y ) ) * ( 2 * Y + parseInt ( N / Y - 1 ) * Y ) / 2 ; S3 = ( parseInt ( N / ( X * Y ) ) ) * ( 2 * ( X * Y ) + parseInt ( N / ( X * Y ) - 1 ) * ( X * Y ) ) / 2 ; return S1 + S2 - S3 ; }
Ref: 
function sum ( $ N , $ X , $ Y ) { $ S1 ; $ S2 ; $ S3 ; $ S1 = floor ( ( ( int ) $ N / $ X ) ) * ( 2 * $ X + ( int ) ( ( int ) $ N / $ X - 1 ) * $ X ) / 2 ; $ S2 = floor ( ( ( int ) $ N / $ Y ) ) * ( 2 * $ Y + ( int ) ( ( int ) $ N / $ Y - 1 ) * $ Y ) / 2 ; $ S3 = floor ( ( ( int ) $ N / ( $ X * $ Y ) ) ) * ( 2 * ( $ X * $ Y ) + ( ( int ) $ N / ( $ X * $ Y ) - 1 ) * ( int ) ( $ X * $ Y ) ) / 2 ; return ceil ( $ S1 + ( $ S2 - $ S3 ) ) ; }
Hyp: 
function sum ( $ N , $ X , $ Y ) { $ S1 = ( int ) ( 2 * $ X + ( int ) ( $ N / $ X - 1 ) * $ X ) / 2 ; $ S2 = ( int ) ( $ N / $ Y ) ) * ( 2 * $ Y + ( int ) ( $ N / $ Y - 1 ) * $ Y ) / 2 ; $ S3 = ( $ N / ( $ X * $ Y ) ) * ( 2 * ( $ X * $ Y ) + ( int ) ( $ N / ( $ X * $ Y ) - 1 ) * ( $ X * $ Y ) ) / 2 ; return $ S1 + $ S2 - $ S3 ; }

BLEU: 66.05
Edit Sim: 118


Src: 
function generate_derangement ( N ) { let S = [ ] ; for ( let i = 1 ; i <= N ; i ++ ) S [ i ] = i ; let D = [ ] ; for ( let i = 1 ; i <= N ; i += 2 ) { if ( i == N ) { D [ N ] = S [ N - 1 ] ; D [ N - 1 ] = S [ N ] ; } else { D [ i ] = i + 1 ; D [ i + 1 ] = i ; } } for ( let i = 1 ; i <= N ; i ++ ) document . write ( D [ i ] + " " ) ; document . write ( " " ) ; }
Ref: 
function generate_derangement ( $ N ) { $ S = array ( ) ; for ( $ i = 1 ; $ i <= $ N ; $ i ++ ) $ S [ $ i ] = $ i ; $ D = array ( ) ; for ( $ i = 1 ; $ i <= $ N ; $ i += 2 ) { if ( $ i == $ N ) { $ D [ $ N ] = $ S [ $ N - 1 ] ; $ D [ $ N - 1 ] = $ S [ $ N ] ; } else { $ D [ $ i ] = $ i + 1 ; $ D [ $ i + 1 ] = $ i ; } } for ( $ i = 1 ; $ i <= $ N ; $ i ++ ) echo $ D [ $ i ] . " ▁ " ; echo " STRNEWLINE " ; }
Hyp: 
function generate_derangement ( $ N ) { $ S = array ( ) ; for ( $ i = 1 ; $ i <= $ N ; $ i ++ ) $ S [ $ i ] = $ i ; $ D = array ( ) ; for ( $ i = 1 ; $ i <= $ N ; $ i += 2 ) { if ( $ i == $ N ) { $ D [ $ N ] = $ S [ $ N - 1 ] ; $ D [ $ N - 1 ] = $ S [ $ N ] ; } else { $ D [ $ i ] = $ i + 1 ; $ D [ $ i + 1 ] = $ i ; } } for ( $ i = 1 ; $ i <= $ N ; $ i ++ ) echo $ D [ $ i ] , " ▁ " ; echo " STRNEWLINE " ; }

BLEU: 98.54
Edit Sim: 1


Src: 
function oddSum ( n ) { return ( n * n ) ; }
Ref: 
function oddSum ( $ n ) { return ( $ n * $ n ) ; }
Hyp: 
function oddSum ( $ n ) { return ( $ n * $ n ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function sphere ( a ) { if ( a < 0 ) return - 1 ; var r = a / 2 ; return r ; }
Ref: 
function sphere ( $ a ) { if ( $ a < 0 ) return -1 ; $ r = ( $ a / 2 ) ; return $ r ; }
Hyp: 
function sphere ( $ a ) { if ( $ a < 0 ) return -1 ; $ r = $ a / 2 ; return $ r ; }

BLEU: 83.42
Edit Sim: 4


Src: 
function computeLastDigit ( A , B ) { let variable = 1 ; return 1 ; else if ( ( B - A ) >= 5 ) return 0 ; else { for ( let i = A + 1 ; i <= B ; i ++ ) variable = ( variable * ( i % 10 ) ) % 10 ; return variable % 10 ; } }
Ref: 
function computeLastDigit ( $ A , $ B ) { $ variable = 1 ; if ( $ A == $ B ) return 1 ; else if ( ( $ B - $ A ) >= 5 ) return 0 ; else { for ( $ i = $ A + 1 ; $ i <= $ B ; $ i ++ ) $ variable = ( $ variable * ( $ i % 10 ) ) % 10 ; return $ variable % 10 ; } }
Hyp: 
function computeLastDigit ( $ A , $ B ) { $ variable = 1 ; return 1 ; else if ( ( $ B - $ A ) >= 5 ) return 0 ; else { for ( $ i = $ A + 1 ; $ i <= $ B ; $ i ++ ) $ variable = ( $ variable * ( $ i % 10 ) ) % 10 ; return $ variable % 10 ; } }

BLEU: 88.88
Edit Sim: 18


Src: 
function swapBitsInPair ( x ) { return ( ( x & 0b10101010 ) >> 1 ) | ( ( x & 0b01010101 ) << 1 ) ; }
Ref: 
function swapBitsInPair ( $ x ) { return ( ( $ x & 0b10101010 ) >> 1 ) | ( ( $ x & 0b01010101 ) << 1 ) ; }
Hyp: 
function swapBitsInPair ( $ x ) { return ( ( $ x & 0b10101010 ) >> 1 ) | ( ( $ x & 0b01010101 ) << 1 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function count ( n ) { var cnt = 0 ; var p = 1 ; while ( p <= n ) { cnt ++ ; p *= 2 ; } return cnt ; }
Ref: 
function count_t ( $ n ) { $ cnt = 0 ; $ p = 1 ; while ( $ p <= $ n ) { $ cnt ++ ; $ p *= 2 ; } return $ cnt ; }
Hyp: 
function count ( $ n ) { $ cnt = 0 ; $ p = 1 ; while ( $ p <= $ n ) { $ cnt ++ ; $ p *= 2 ; } return $ cnt ; }

BLEU: 95.65
Edit Sim: 2


Src: 
function maxValue ( a , b ) { b . sort ( function ( x , y ) { return x - y ; } ) ; let n = a . length ; let m = b . length ; let j = m - 1 ; for ( let i = 0 ; i < n ; i ++ ) { if ( j < 0 ) break ; if ( b [ j ] > a [ i ] ) { a [ i ] = b [ j ] ; j -- ; } } return ( a ) . join ( " " ) ; }
Ref: 
function maxValue ( $ a , $ b ) { sort ( $ b ) ; $ n = sizeof ( $ a ) ; $ m = sizeof ( $ b ) ; $ j = $ m - 1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ j < 0 ) break ; if ( $ b [ $ j ] > $ a [ $ i ] ) { $ a [ $ i ] = $ b [ $ j ] ; $ j -- ; } } $ a = implode ( " " , $ a ) ; return $ a ; }
Hyp: 
function maxValue ( $ a , $ b ) { sort ( $ b ) ; $ n = count ( $ a ) ; $ m = count ( $ b ) ; $ j = $ m - 1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ j < 0 ) break ; if ( $ b [ $ j ] > $ a [ $ i ] ) { $ a [ $ i ] = $ b [ $ j ] ; $ j -- ; } } return ( $ a ) ; }

BLEU: 84.5
Edit Sim: 44


Src: 
function isDivisible ( str , k ) { let n = str . length ; let c = 0 ; for ( let i = 0 ; i < k ; i ++ ) if ( str [ n - i - 1 ] == ' ' ) c ++ ; return ( c == k ) ; }
Ref: 
function isDivisible ( $ str , $ k ) { $ n = strlen ( $ str ) ; $ c = 0 ; for ( $ i = 0 ; $ i < $ k ; $ i ++ ) if ( $ str [ $ n - $ i - 1 ] == '0' ) $ c ++ ; return ( $ c == $ k ) ; }
Hyp: 
function isDivisible ( $ str , $ k ) { $ n = strlen ( $ str ) ; $ c = 0 ; for ( $ i = 0 ; $ i < $ k ; $ i ++ ) if ( $ str [ $ n - $ i - 1 ] == '0' ) $ c ++ ; return ( $ c == $ k ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function getNthTerm ( N ) { return 4 * Math . pow ( N , 2 ) - 3 * N + 2 ; }
Ref: 
function getNthTerm ( $ N ) { return 4 * pow ( $ N , 2 ) - 3 * $ N + 2 ; }
Hyp: 
function getNthTerm ( $ N ) { return 4 * pow ( $ N , 2 ) - 3 * $ N + 2 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function minOp ( num ) { var rem ; var count = 0 ; while ( num ) { rem = num % 10 ; if ( ! ( rem == 3 rem == 8 ) ) count ++ ; num = parseInt ( num / 10 ) ; } return count ; }
Ref: 
function minOp ( $ num ) { $ count = 0 ; while ( $ num ) { $ rem = intval ( $ num % 10 ) ; if ( ! ( $ rem == 3 $ rem == 8 ) ) $ count ++ ; $ num = intval ( $ num / 10 ) ; } return $ count ; }
Hyp: 
function minOp ( $ num ) { $ rem ; $ count = 0 ; while ( $ num ) { $ rem = $ num % 10 ; if ( ! ( $ rem == 3 $ rem == 8 ) ) $ count ++ ; $ num = ( int ) $ num / 10 ; } return $ count ; }

BLEU: 79.96
Edit Sim: 27


Src: 
function isDivisible ( n ) { temp = n ; while ( n ) { k = n % 10 ; if ( temp % k == 0 ) return " " ; n = Math . floor ( n / 10 ) ; } return " " ; }
Ref: 
function isDivisible ( $ n ) { $ temp = $ n ; while ( $ n ) { $ k = $ n % 10 ; if ( $ temp % $ k == 0 ) return " YES " ; $ n = floor ( $ n / 10 ) ; } return " NO " ; }
Hyp: 
function isDivisible ( $ n ) { $ temp = $ n ; while ( $ n ) { $ k = $ n % 10 ; if ( $ temp % $ k == 0 ) return " A " ; $ n = ( int ) $ n / 10 ; } return " B " ; }

BLEU: 81.69
Edit Sim: 13


Src: 
function maxPrimefactorNum ( N ) { if ( N < 2 ) return 0 ; arr = Array . from ( { length : N + 1 } , ( _ , i ) => false ) ; var prod = 1 , res = 0 ; for ( var p = 2 ; p * p <= N ; p ++ ) { if ( arr [ p ] == false ) { for ( var i = p * 2 ; i <= N ; i += p ) arr [ i ] = true ; prod *= p ; if ( prod > N ) return res ; res ++ ; } } return res ; }
Ref: 
function maxPrimefactorNum ( $ N ) { if ( $ N < 2 ) return 0 ; $ arr = array_fill ( 0 , ( $ N + 1 ) , true ) ; $ prod = 1 ; $ res = 0 ; for ( $ p = 2 ; $ p * $ p <= $ N ; $ p ++ ) { if ( $ arr [ $ p ] == true ) { for ( $ i = $ p * 2 ; $ i <= $ N ; $ i += $ p ) $ arr [ $ i ] = false ; $ prod *= $ p ; if ( $ prod > $ N ) return $ res ; $ res ++ ; } } return $ res ; }
Hyp: 
function maxPrimefactorNum ( $ N ) { if ( $ N < 2 ) return 0 ; $ arr = array ( ) ; $ prod = 1 ; $ res = 0 ; for ( $ p = 2 ; $ p * $ p <= $ N ; $ p ++ ) { if ( $ arr [ $ p ] == 0 ) { for ( $ i = $ p * 2 ; $ i <= $ N ; $ i += $ p ) $ arr [ $ i ] = true ; $ prod *= $ p ; if ( $ prod > $ N ) return $ res ; $ res ++ ; } } return $ res ; }

BLEU: 86.68
Edit Sim: 36


Src: 
function nDigitPerfectSquares ( n ) { document . write ( Math . pow ( Math . ceil ( Math . sqrt ( Math . pow ( 10 , n - 1 ) ) ) , 2 ) + " " ) ; document . write ( Math . pow ( Math . ceil ( Math . sqrt ( Math . pow ( 10 , n ) ) ) - 1 , 2 ) ) ; }
Ref: 
function nDigitPerfectSquares ( $ n ) { echo pow ( ceil ( sqrt ( pow ( 10 , $ n - 1 ) ) ) , 2 ) , " " ; echo pow ( ceil ( sqrt ( pow ( 10 , $ n ) ) ) - 1 , 2 ) ; }
Hyp: 
function nDigitPerfectSquares ( $ n ) { echo pow ( ceil ( sqrt ( pow ( 10 , $ n - 1 ) ) ) , 2 ) ; echo pow ( ceil ( sqrt ( pow ( 10 , $ n ) ) ) - 1 , 2 ) ; }

BLEU: 91.57
Edit Sim: 6


Src: 
function printTrib ( n ) { if ( n < 1 ) return ; let first = 0 , second = 0 ; let third = 1 ; document . write ( first + " " ) ; if ( n > 1 ) document . write ( second + " " ) ; if ( n > 2 ) document . write ( second + " " ) ; for ( let i = 3 ; i < n ; i ++ ) { let curr = first + second + third ; first = second ; second = third ; third = curr ; document . write ( curr + " " ) ; } }
Ref: 
function printTrib ( $ n ) { if ( $ n < 1 ) return ; $ first = 0 ; $ second = 0 ; $ third = 1 ; echo $ first , " " ; if ( $ n > 1 ) echo $ second , " ▁ " ; if ( $ n > 2 ) echo $ second , " ▁ " ; for ( $ i = 3 ; $ i < $ n ; $ i ++ ) { $ curr = $ first + $ second + $ third ; $ first = $ second ; $ second = $ third ; $ third = $ curr ; echo $ curr , " " ; } }
Hyp: 
function printTrib ( $ n ) { if ( $ n < 1 ) return ; $ first = 0 ; $ second = 0 ; $ third = 1 ; echo $ first , " " ; if ( $ n > 1 ) echo $ second , " " ; if ( $ n > 2 ) echo $ second , " " ; for ( $ i = 3 ; $ i < $ n ; $ i ++ ) { $ curr = $ first + $ second + $ third ; $ first = $ second ; $ second = $ third ; $ third = $ curr ; echo $ curr , " " ; } }

BLEU: 95.94
Edit Sim: 4


Src: 
function printGMeans ( A , B , N ) { let R = Math . pow ( ( B / A ) , 1.0 / ( N + 1 ) ) ; for ( let i = 1 ; i <= N ; i ++ ) document . write ( A * Math . pow ( R , i ) + " " ) ; }
Ref: 
function printGMeans ( $ A , $ B , $ N ) { $ R = pow ( ( $ B / $ A ) , 1.0 / ( $ N + 1 ) ) ; for ( $ i = 1 ; $ i <= $ N ; $ i ++ ) echo $ A * pow ( $ R , $ i ) , " ▁ " ; }
Hyp: 
function printGMeans ( $ A , $ B , $ N ) { $ R = pow ( ( $ B / $ A ) , 1.0 / ( $ N + 1 ) ) ; for ( $ i = 1 ; $ i <= $ N ; $ i ++ ) echo $ A * pow ( $ R , $ i ) . " ▁ " ; }

BLEU: 96.41
Edit Sim: 1


Src: 
function minSum ( arr , n ) { let sum = arr [ 0 ] , prev = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { if ( arr [ i ] <= prev ) { prev = prev + 1 ; sum = sum + prev ; } else { sum = sum + arr [ i ] ; prev = arr [ i ] ; } } return sum ; }
Ref: 
function minSum ( $ arr , $ n ) { $ sum = $ arr [ 0 ] ; $ prev = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] <= $ prev ) { $ prev = $ prev + 1 ; $ sum = $ sum + $ prev ; } else { $ sum = $ sum + $ arr [ $ i ] ; $ prev = $ arr [ $ i ] ; } } return $ sum ; }
Hyp: 
function minSum ( $ arr , $ n ) { $ sum = $ arr [ 0 ] ; $ prev = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] <= $ prev ) { $ prev = $ prev + 1 ; $ sum = $ sum + $ prev ; } else { $ sum = $ sum + $ arr [ $ i ] ; $ prev = $ arr [ $ i ] ; } } return $ sum ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function lengtang ( r1 , r2 , d ) { document . write ( " " + " " + ( Math . sqrt ( Math . pow ( d , 2 ) - Math . pow ( ( r1 - r2 ) , 2 ) ) ) . toFixed ( 5 ) ) ; }
Ref: 
function lengtang ( $ r1 , $ r2 , $ d ) { echo " The ▁ length ▁ of ▁ the ▁ direct ▁ common ▁ tangent ▁ is ▁ " , sqrt ( pow ( $ d , 2 ) - pow ( ( $ r1 - $ r2 ) , 2 ) ) ; }
Hyp: 
function lengtang ( $ r1 , $ r2 , $ d ) { echo " The ▁ length ▁ of ▁ the ▁ direct " , " ▁ common ▁ tangent ▁ is ▁ " , sqrt ( pow ( $ d , 2 ) - pow ( ( $ r1 - $ r2 ) , 2 ) ) , " STRNEWLINE " ; }

BLEU: 84.77
Edit Sim: 23


Src: 
function findMinDiff ( arr , n ) { let diff = Number . MAX_VALUE ; for ( let i = 0 ; i < n - 1 ; i ++ ) for ( let j = i + 1 ; j < n ; j ++ ) if ( Math . abs ( ( arr [ i ] - arr [ j ] ) ) < diff ) diff = Math . abs ( ( arr [ i ] - arr [ j ] ) ) ; return diff ; }
Ref: 
function findMinDiff ( $ arr , $ n ) { $ diff = PHP_INT_MAX ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) if ( abs ( $ arr [ $ i ] - $ arr [ $ j ] ) < $ diff ) $ diff = abs ( $ arr [ $ i ] - $ arr [ $ j ] ) ; return $ diff ; }
Hyp: 
function findMinDiff ( $ arr , $ n ) { $ diff = PHP_INT_MAX ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) if ( abs ( ( $ arr [ $ i ] - $ arr [ $ j ] ) ) < $ diff ) $ diff = abs ( ( $ arr [ $ i ] - $ arr [ $ j ] ) ) ; return $ diff ; }

BLEU: 93.21
Edit Sim: 8


Src: 
function maxLenSub ( arr , n ) { let mls = new Array ( n ) . fill ( 1 ) , max = 0 ; for ( let i = 0 ; i < n ; i ++ ) mls [ i ] = 1 ; for ( let i = 1 ; i < n ; i ++ ) for ( let j = 0 ; j < i ; j ++ ) if ( Math . abs ( arr [ i ] - arr [ j ] ) <= 1 && mls [ i ] < mls [ j ] + 1 ) mls [ i ] = mls [ j ] + 1 ; for ( let i = 0 ; i < n ; i ++ ) if ( max < mls [ i ] ) max = mls [ i ] ; return max ; }
Ref: 
function maxLenSub ( $ arr , $ n ) { $ mls = array ( ) ; $ max = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ mls [ $ i ] = 1 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ i ; $ j ++ ) if ( abs ( $ arr [ $ i ] - $ arr [ $ j ] ) <= 1 and $ mls [ $ i ] < $ mls [ $ j ] + 1 ) $ mls [ $ i ] = $ mls [ $ j ] + 1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ max < $ mls [ $ i ] ) $ max = $ mls [ $ i ] ; return $ max ; }
Hyp: 
function maxLenSub ( $ arr , $ n ) { $ mls = array_fill ( 0 , $ n , 1 ) ; $ max = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ mls [ $ i ] = 1 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ i ; $ j ++ ) if ( abs ( $ arr [ $ i ] - $ arr [ $ j ] ) <= 1 && $ mls [ $ i ] < $ mls [ $ j ] + 1 ) $ mls [ $ i ] = $ mls [ $ j ] + 1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ max < $ mls [ $ i ] ) $ max = $ mls [ $ i ] ; return $ max ; }

BLEU: 93.61
Edit Sim: 20


Src: 
function sum_of_series ( n ) { let result = 0 ; if ( n % 2 == 0 ) { result = - ( n * ( n + 1 ) ) / 2 ; } else { result = ( n * ( n + 1 ) ) / 2 ; } return result ; }
Ref: 
function sum_of_series ( $ n ) { $ result = 0 ; if ( $ n % 2 == 0 ) { $ result = - ( $ n * ( $ n + 1 ) ) / 2 ; } else { $ result = ( $ n * ( $ n + 1 ) ) / 2 ; } return $ result ; }
Hyp: 
function sum_of_series ( $ n ) { $ result = 0 ; if ( $ n % 2 == 0 ) { $ result = - ( $ n * ( $ n + 1 ) ) / 2 ; } else { $ result = ( $ n * ( $ n + 1 ) ) / 2 ; } return $ result ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function smallestOdd ( n ) { if ( n == 1 ) return 1 ; return Math . pow ( 10 , n - 1 ) + 1 ; }
Ref: 
function smallestOdd ( $ n ) { if ( $ n == 1 ) return 1 ; return pow ( 10 , $ n - 1 ) + 1 ; }
Hyp: 
function smallestOdd ( $ n ) { if ( $ n == 1 ) return 1 ; return pow ( 10 , $ n - 1 ) + 1 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function printSeries ( n ) { for ( let i = 1 ; i <= n ; i ++ ) { num = ( i * ( i + 1 ) * ( i + 2 ) * ( i + 3 ) / 24 ) ; document . write ( num + " " ) ; } }
Ref: 
function printSeries ( $ n ) { for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ num = ( $ i * ( $ i + 1 ) * ( $ i + 2 ) * ( $ i + 3 ) / 24 ) ; echo ( $ num . " " ) ; } }
Hyp: 
function printSeries ( $ n ) { for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ num = ( $ i * ( $ i + 1 ) * ( $ i + 2 ) * ( $ i + 3 ) / 24 ) ; echo $ num . " ▁ " ; } }

BLEU: 91.2
Edit Sim: 4


Src: 
function binomialCoeff ( n , k ) { if ( k > n ) return 0 ; if ( k == 0 k == n ) return 1 ; return binomialCoeff ( n - 1 , k - 1 ) + binomialCoeff ( n - 1 , k ) ; }
Ref: 
function binomialCoeff ( $ n , $ k ) { if ( $ k > $ n ) return 0 ; if ( $ k == 0 $ k == $ n ) return 1 ; return binomialCoeff ( $ n - 1 , $ k - 1 ) + binomialCoeff ( $ n - 1 , $ k ) ; }
Hyp: 
function binomialCoeff ( $ n , $ k ) { if ( $ k > $ n ) return 0 ; if ( $ k == 0 $ k == $ n ) return 1 ; return binomialCoeff ( $ n - 1 , $ k - 1 ) + binomialCoeff ( $ n - 1 , $ k ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function alternate ( a , b , x ) { return x = a ^ b ^ x ; }
Ref: 
function alternate ( & $ a , & $ b , & $ x ) { $ x = $ a ^ $ b ^ $ x ; }
Hyp: 
function alternate ( $ a , $ b , $ x ) { return $ x = $ a ^ $ b ^ $ x ; }

BLEU: 65.44
Edit Sim: 13


Src: 
function subtractOne ( x ) { let m = 1 ; while ( ! ( x & m ) ) { x = x ^ m ; m <<= 1 ; } x = x ^ m ; return x ; }
Ref: 
function subtractOne ( $ x ) { $ m = 1 ; while ( ! ( $ x & $ m ) ) { $ x = $ x ^ $ m ; $ m <<= 1 ; } $ x = $ x ^ $ m ; return $ x ; }
Hyp: 
function subtractOne ( & $ x ) { $ m = 1 ; while ( ! ( $ x & $ m ) ) { $ x = $ x ^ $ m ; $ m <<= 1 ; } $ x = $ x ^ $ m ; return $ x ; }

BLEU: 95.26
Edit Sim: 2


Src: 
function printRotatedString ( str ) { var n = str . length ; var sb = str ; sb += ( str ) ; for ( var i = 0 ; i < n ; i ++ ) { for ( var j = 0 ; j != n ; j ++ ) document . write ( sb . charAt ( i + j ) ) ; document . write ( ' ' ) ; } }
Ref: 
function printRotatedString ( $ str ) { $ n = strlen ( $ str ) ; $ temp = $ str . $ str ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j != $ n ; $ j ++ ) print ( $ temp [ $ i + $ j ] ) ; print ( " STRNEWLINE " ) ; } }
Hyp: 
function printRotatedString ( $ str ) { $ n = strlen ( $ str ) ; $ sb = $ str ; $ sb += ( $ str ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j != $ n ; $ j ++ ) echo $ sb [ $ i + $ j ] ; echo ' ▁ ' ; } }

BLEU: 74.84
Edit Sim: 51


Src: 
function countDistinct ( arr , n ) { arr . sort ( function ( a , b ) { return a - b ; } ) ; let res = 0 ; for ( let i = 0 ; i < n ; i ++ ) { while ( i < n - 1 && arr [ i ] == arr [ i + 1 ] ) { i ++ ; } res ++ ; } return res ; }
Ref: 
function countDistinct ( $ arr , $ n ) { sort ( $ arr , 0 ) ; $ res = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { while ( $ i < $ n - 1 && $ arr [ $ i ] == $ arr [ $ i + 1 ] ) $ i ++ ; $ res ++ ; } return $ res ; }
Hyp: 
function countDistinct ( $ arr , $ n ) { sort ( $ arr ) ; $ res = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { while ( $ i < $ n - 1 && $ arr [ $ i ] == $ arr [ $ i + 1 ] ) { $ i ++ ; } $ res ++ ; } return $ res ; }

BLEU: 91.77
Edit Sim: 8


Src: 
function isSubstring ( s1 , s2 ) { var M = s1 . length ; var N = s2 . length ; for ( var i = 0 ; i <= N - M ; i ++ ) { var j ; for ( j = 0 ; j < M ; j ++ ) if ( s2 [ i + j ] != s1 [ j ] ) break ; if ( j == M ) return i ; } return - 1 ; }
Ref: 
function isSubstring ( $ s1 , $ s2 ) { $ M = strlen ( $ s1 ) ; $ N = strlen ( $ s2 ) ; for ( $ i = 0 ; $ i <= $ N - $ M ; $ i ++ ) { $ j = 0 ; for ( ; $ j < $ M ; $ j ++ ) if ( $ s2 [ $ i + $ j ] != $ s1 [ $ j ] ) break ; if ( $ j == $ M ) return $ i ; } return -1 ; }
Hyp: 
function isSubstring ( $ s1 , $ s2 ) { $ M = strlen ( $ s1 ) ; $ N = strlen ( $ s2 ) ; for ( $ i = 0 ; $ i <= $ N - $ M ; $ i ++ ) { for ( $ j = 0 ; $ j < $ M ; $ j ++ ) if ( $ s2 [ $ i + $ j ] != $ s1 [ $ j ] ) break ; if ( $ j == $ M ) return $ i ; } return -1 ; }

BLEU: 95.63
Edit Sim: 10


Src: 
function PositionRightmostSetbit ( n ) { let position = 1 ; let m = 1 ; while ( ( n & m ) == 0 ) { m = m << 1 ; position ++ ; } return position ; }
Ref: 
function PositionRightmostSetbit ( $ n ) { $ position = 1 ; $ m = 1 ; while ( ! ( $ n & $ m ) ) { $ m = $ m << 1 ; $ position ++ ; } return $ position ; }
Hyp: 
function PositionRightmostSetbit ( $ n ) { $ position = 1 ; $ m = 1 ; while ( ( $ n & $ m ) == 0 ) { $ m = $ m << 1 ; $ position ++ ; } return $ position ; }

BLEU: 89.22
Edit Sim: 7


Src: 
function calculate ( a , n ) { a . sort ( ) ; let count = 1 ; let answer = 0 ; for ( let i = 1 ; i < n ; i ++ ) { if ( a [ i ] == a [ i - 1 ] ) { count += 1 ; } else { answer = answer + Math . floor ( ( count * ( count - 1 ) ) / 2 ) ; count = 1 ; } } answer = answer + Math . floor ( ( count * ( count - 1 ) ) / 2 ) ; return answer ; }
Ref: 
function calculate ( $ a , $ n ) { sort ( $ a ) ; $ count = 1 ; $ answer = 0 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] == $ a [ $ i - 1 ] ) { $ count += 1 ; } else { $ answer = $ answer + ( $ count * ( $ count - 1 ) ) / 2 ; $ count = 1 ; } } $ answer = $ answer + ( $ count * ( $ count - 1 ) ) / 2 ; return $ answer ; }
Hyp: 
function calculate ( $ a , $ n ) { sort ( $ a ) ; $ count = 1 ; $ answer = 0 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] == $ a [ $ i - 1 ] ) { $ count += 1 ; } else { $ answer = $ answer + ( ( $ count * ( $ count - 1 ) ) / 2 ) ; $ count = 1 ; } } $ answer = $ answer + ( ( $ count * ( $ count - 1 ) ) / 2 ) ; return $ answer ; }

BLEU: 93.2
Edit Sim: 8


Src: 
function circumference ( r ) { let cir = 2 * 3.1415 * r ; return cir ; }
Ref: 
function circumference ( $ r ) { global $ PI ; $ cir = 2 * $ PI * $ r ; return $ cir ; }
Hyp: 
function circumference ( $ r ) { $ cir = 2 * 3.1415 * $ r ; return $ cir ; }

BLEU: 63.72
Edit Sim: 20


Src: 
function allBitsSetInTheGivenRange ( n , l , r ) { var num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ; var new_num = n & num ; if ( num == new_num ) return " " ; return " " ; }
Ref: 
function allBitsSetInTheGivenRange ( $ n , $ l , $ r ) { $ num = ( ( 1 << $ r ) - 1 ) ^ ( ( 1 << ( $ l - 1 ) ) - 1 ) ; $ new_num = $ n & $ num ; if ( $ num == $ new_num ) return " Yes " ; return " No " ; }
Hyp: 
function allBitsSetInTheGivenRange ( $ n , $ l , $ r ) { $ num = ( ( 1 << $ r ) - 1 ) ^ ( ( 1 << ( $ l - 1 ) ) - 1 ) ; $ new_num = $ n & $ num ; if ( $ num == $ new_num ) return " Yes " ; return " No " ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function areSumSame ( a , n , m ) { let sum1 = 0 , sum2 = 0 ; for ( let i = 0 ; i < n ; i ++ ) { sum1 = 0 ; sum2 = 0 ; for ( let j = 0 ; j < m ; j ++ ) { sum1 += a [ i ] [ j ] ; sum2 += a [ j ] [ i ] ; } if ( sum1 == sum2 ) return true ; } return false ; }
Ref: 
function areSumSame ( $ a , $ n , $ m ) { $ sum1 = 0 ; $ sum2 = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sum1 = 0 ; $ sum2 = 0 ; for ( $ j = 0 ; $ j < $ m ; $ j ++ ) { $ sum1 += $ a [ $ i ] [ $ j ] ; $ sum2 += $ a [ $ j ] [ $ i ] ; } if ( $ sum1 == $ sum2 ) return true ; } return false ; }
Hyp: 
function areSumSame ( $ a , $ n , $ m ) { $ sum1 = 0 ; $ sum2 = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sum1 = 0 ; $ sum2 = 0 ; for ( $ j = 0 ; $ j < $ m ; $ j ++ ) { $ sum1 += $ a [ $ i ] [ $ j ] ; $ sum2 += $ a [ $ j ] [ $ i ] ; } if ( $ sum1 == $ sum2 ) return true ; } return false ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function check ( str ) { let n = str . length ; let digitSum = 0 ; for ( let i = 0 ; i < n ; i ++ ) digitSum += ( str [ i ] - ' ' ) ; return ( digitSum % 3 == 0 ) ; }
Ref: 
function check ( $ str ) { $ n = strlen ( $ str ) ; $ digitSum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ digitSum += ( $ str [ $ i ] - '0' ) ; return ( $ digitSum % 3 == 0 ) ; }
Hyp: 
function check ( $ str ) { $ n = strlen ( $ str ) ; $ digitSum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ digitSum += ( $ str [ $ i ] - '0' ) ; return ( $ digitSum % 3 == 0 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function summation ( n ) { let sum ; sum = ( Math . pow ( 10 , n + 1 ) - 10 - ( 9 * n ) ) / 81 ; return sum ; }
Ref: 
function summation ( $ n ) { $ sum ; $ sum = ( pow ( 10 , $ n + 1 ) - 10 - ( 9 * $ n ) ) / 81 ; return $ sum ; }
Hyp: 
function summation ( $ n ) { $ sum ; $ sum = ( pow ( 10 , $ n + 1 ) - 10 - ( 9 * $ n ) ) / 81 ; return $ sum ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function isPossible ( Sx , Sy , Dx , Dy , x , y ) { if ( Math . abs ( Sx - Dx ) % x == 0 && Math . abs ( Sy - Dy ) % y == 0 && ( Math . abs ( Sx - Dx ) / x ) % 2 == ( Math . abs ( Sy - Dy ) / y ) % 2 ) return true ; return false ; }
Ref: 
function isPossible ( $ Sx , $ Sy , $ Dx , $ Dy , $ x , $ y ) { if ( abs ( $ Sx - $ Dx ) % $ x == 0 && abs ( $ Sy - $ Dy ) % $ y == 0 && ( abs ( $ Sx - $ Dx ) / $ x ) % 2 == ( abs ( $ Sy - $ Dy ) / $ y ) % 2 ) return true ; return false ; }
Hyp: 
function isPossible ( $ Sx , $ Sy , $ Dx , $ Dy , $ x , $ y ) { if ( abs ( $ Sx - $ Dx ) % $ x == 0 && abs ( $ Sy - $ Dy ) % $ y == 0 && ( abs ( $ Sx - $ Dx ) / $ x ) % 2 == ( abs ( $ Sy - $ Dy ) / $ y ) % 2 ) return true ; return false ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function productPuzzle ( a , n ) { var sum = 0 ; for ( var i = 0 ; i < n ; i ++ ) sum += Math . log10 ( a [ i ] ) ; for ( var i = 0 ; i < n ; i ++ ) document . write ( parseInt ( ( EPS + Math . pow ( 10.00 , sum - Math . log10 ( a [ i ] ) ) ) ) + " " ) ; }
Ref: 
function productPuzzle ( $ a , $ n ) { global $ EPS ; $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum += ( double ) log10 ( $ a [ $ i ] ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo ( int ) ( $ EPS + pow ( ( double ) 10.00 , $ sum - log10 ( $ a [ $ i ] ) ) ) . " ▁ " ; }
Hyp: 
function productPuzzle ( $ a , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum += log10 ( $ a [ $ i ] ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo ( $ EPS + pow ( 10.00 , $ sum - log10 ( $ a [ $ i ] ) ) ) ; }

BLEU: 75.86
Edit Sim: 53


Src: 
function permutationCoeff ( n , k ) { let fact = new Array ( n + 1 ) ; fact [ 0 ] = 1 ; for ( let i = 1 ; i <= n ; i ++ ) fact [ i ] = i * fact [ i - 1 ] ; return parseInt ( fact [ n ] / fact [ n - k ] , 10 ) ; }
Ref: 
function permutationCoeff ( $ n , $ k ) { $ fact = array ( ) ; $ fact [ 0 ] = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ fact [ $ i ] = $ i * $ fact [ $ i - 1 ] ; return $ fact [ $ n ] / $ fact [ $ n - $ k ] ; }
Hyp: 
function permutationCoeff ( $ n , $ k ) { $ fact [ 0 ] = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ fact [ $ i ] = $ i * $ fact [ $ i - 1 ] ; return floor ( $ fact [ $ n ] / $ fact [ $ n - $ k ] ) ; }

BLEU: 88.13
Edit Sim: 31


Src: 
function Time ( arr , n , Emptypipe ) { var fill = 0 ; for ( var i = 0 ; i < n ; i ++ ) fill += 1 / arr [ i ] ; fill = fill - ( 1 / Emptypipe ) ; return 1 / fill ; }
Ref: 
function T_ime ( $ arr , $ n , $ Emptypipe ) { $ fill = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ fill += 1 / $ arr [ $ i ] ; $ fill = $ fill - ( 1 / $ Emptypipe ) ; return 1 / $ fill ; }
Hyp: 
function Time ( $ arr , $ n , $ Emptypipe ) { $ fill = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ fill += 1 / $ arr [ $ i ] ; $ fill = $ fill - ( 1 / $ Emptypipe ) ; return 1 / $ fill ; }

BLEU: 97.36
Edit Sim: 1


Src: 
function countRabbits ( Heads , Legs ) { var count = 0 ; count = ( Legs ) - 2 * ( Heads ) ; count = count / 2 ; return count ; }
Ref: 
function countRabbits ( $ Heads , $ Legs ) { $ count = 0 ; $ count = ( $ Legs ) - 2 * ( $ Heads ) ; $ count = ( int ) $ count / 2 ; return $ count ; }
Hyp: 
function countRabbits ( $ Heads , $ Legs ) { $ count = 0 ; $ count = ( $ Legs ) - 2 * ( $ Heads ) ; $ count = $ count / 2 ; return $ count ; }

BLEU: 89.87
Edit Sim: 8


Src: 
function count ( S , m , n ) { if ( n == 0 ) return 1 ; if ( n < 0 ) return 0 ; if ( m <= 0 && n >= 1 ) return 0 ; return count ( S , m - 1 , n ) + count ( S , m , n - S [ m - 1 ] ) ; }
Ref: 
function coun ( $ S , $ m , $ n ) { if ( $ n == 0 ) return 1 ; if ( $ n < 0 ) return 0 ; if ( $ m <= 0 && $ n >= 1 ) return 0 ; return coun ( $ S , $ m - 1 , $ n ) + coun ( $ S , $ m , $ n - $ S [ $ m - 1 ] ) ; }
Hyp: 
function count1 ( $ S , $ m , $ n ) { if ( $ n == 0 ) return 1 ; if ( $ n < 0 ) return 0 ; if ( $ m <= 0 && $ n >= 1 ) return 0 ; return count1 ( $ S , $ m - 1 , $ n ) + count1 ( $ S , $ m , $ n - $ S [ $ m - 1 ] ) ; }

BLEU: 91.92
Edit Sim: 6


Src: 
function countWays ( n , k ) { let total = k ; let mod = 1000000007 ; let same = 0 , diff = k ; for ( let i = 2 ; i <= n ; i ++ ) { same = diff ; diff = total * ( k - 1 ) ; diff = diff % mod ; total = ( same + diff ) % mod ; } return total ; }
Ref: 
function countWays ( $ n , $ k ) { $ total = $ k ; $ mod = 1000000007 ; $ same = 0 ; $ diff = $ k ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { $ same = $ diff ; $ diff = $ total * ( $ k - 1 ) ; $ diff = $ diff % $ mod ; $ total = ( $ same + $ diff ) % $ mod ; } return $ total ; }
Hyp: 
function countWays ( $ n , $ k ) { $ total = $ k ; $ mod = 1000000007 ; $ same = 0 ; $ diff = $ k ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { $ same = $ diff ; $ diff = $ total * ( $ k - 1 ) ; $ diff = $ diff % $ mod ; $ total = ( $ same + $ diff ) % $ mod ; } return $ total ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findStarNum ( n ) { return ( 6 * n * ( n - 1 ) + 1 ) ; }
Ref: 
function findStarNum ( $ n ) { return ( 6 * $ n * ( $ n - 1 ) + 1 ) ; }
Hyp: 
function findStarNum ( $ n ) { return ( 6 * $ n * ( $ n - 1 ) + 1 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findProffesion ( level , pos ) { if ( level == 1 ) return ' ' ; if ( findProffesion ( level - 1 , ( pos + 1 ) / 2 ) == ' ' ) return ( pos % 2 > 0 ) ? ' ' : ' ' ; return ( pos % 2 > 0 ) ? ' ' : ' ' ; }
Ref: 
function findProffesion ( $ level , $ pos ) { if ( $ level == 1 ) return ' e ' ; if ( findProffesion ( $ level - 1 , ( $ pos + 1 ) / 2 ) == ' d ' ) return ( $ pos % 2 ) ? ' d ' : ' e ' ; return ( $ pos % 2 ) ? ' e ' : ' d ' ; }
Hyp: 
function findProffesion ( $ level , $ pos ) { if ( $ level == 1 ) return '9' ; if ( findProffesion ( $ level - 1 , ( $ pos + 1 ) / 2 ) == '0' ) return ( $ pos % 2 > 0 ) ? '0' : '1' ; return ( $ pos % 2 > 0 ) ? '0' : '1' ; }

BLEU: 63.13
Edit Sim: 24


Src: 
function checkpoint ( h , k , x , y , a , b ) { var p = ( parseInt ( Math . pow ( ( x - h ) , 2 ) ) / parseInt ( Math . pow ( a , 2 ) ) ) + ( parseInt ( Math . pow ( ( y - k ) , 2 ) ) / parseInt ( Math . pow ( b , 2 ) ) ) ; return p ; }
Ref: 
function checkpoint ( $ h , $ k , $ x , $ y , $ a , $ b ) { $ p = ( pow ( ( $ x - $ h ) , 2 ) / pow ( $ a , 2 ) ) + ( pow ( ( $ y - $ k ) , 2 ) / pow ( $ b , 2 ) ) ; return $ p ; }
Hyp: 
function checkpoint ( $ h , $ k , $ x , $ y , $ a , $ b ) { $ p = ( pow ( ( $ x - $ h ) , 2 ) ) / ( pow ( $ a , 2 ) ) ) + ( pow ( ( $ y - $ k ) , 2 ) ) / ( pow ( $ b , 2 ) ) ) ; return $ p ; }

BLEU: 86.91
Edit Sim: 12


Src: 
function isDivisible ( n ) { while ( parseInt ( n / 100 ) ) { let last_digit = n % 10 ; n = parseInt ( n / 10 ) ; n += last_digit * 3 ; } return ( n % 29 == 0 ) ; }
Ref: 
function isDivisible ( $ n ) { while ( intval ( $ n / 100 ) ) { $ last_digit = $ n % 10 ; $ n = intval ( $ n / 10 ) ; $ n += $ last_digit * 3 ; } return ( $ n % 29 == 0 ) ; }
Hyp: 
function isDivisible ( $ n ) { while ( ( int ) ( $ n / 100 ) ) { $ last_digit = $ n % 10 ; $ n = ( int ) ( $ n / 10 ) ; $ n += $ last_digit * 3 ; } return ( $ n % 29 == 0 ) ; }

BLEU: 84.96
Edit Sim: 10


Src: 
function calculate ( X ) { let number_of_bits = 8 ; return ( ( 1 << number_of_bits ) - 1 ) ^ X ; }
Ref: 
function calculate ( $ X ) { $ number_of_bits = 8 ; return ( ( 1 << $ number_of_bits ) - 1 ) ^ $ X ; }
Hyp: 
function calculate ( $ X ) { $ number_of_bits = 8 ; return ( ( 1 << $ number_of_bits ) - 1 ) ^ $ X ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function calculate ( a , b , n , m ) { let mul = 1 ; for ( let i = 0 ; i < m ; i ++ ) if ( b [ i ] != 0 ) mul = mul * b [ i ] ; for ( let i = 0 ; i < n ; i ++ ) { let x = Math . floor ( a [ i ] / mul ) ; document . write ( x + " " ) ; } }
Ref: 
function calculate ( $ a , $ b , $ n , $ m ) { $ mul = 1 ; for ( $ i = 0 ; $ i < $ m ; $ i ++ ) if ( $ b [ $ i ] != 0 ) $ mul = $ mul * $ b [ $ i ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ x = floor ( $ a [ $ i ] / $ mul ) ; echo $ x , " " ; } }
Hyp: 
function calculate ( $ a , $ b , $ n , $ m ) { $ mul = 1 ; for ( $ i = 0 ; $ i < $ m ; $ i ++ ) if ( $ b [ $ i ] != 0 ) $ mul = $ mul * $ b [ $ i ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ x = ( int ) $ a [ $ i ] / $ mul ; echo $ x . " ▁ " ; } }

BLEU: 90.61
Edit Sim: 11


Src: 
function countDigitsToBeRemoved ( N , K ) { var s = N . toString ( ) ; var res = 0 ; var f_zero = 0 ; for ( var i = s . length - 1 ; i >= 0 ; i -- ) { if ( K === 0 ) return res ; if ( s [ i ] === " " ) { f_zero = 1 ; K -- ; } else res ++ ; } if ( K === 0 ) return res ; else if ( f_zero === 1 ) return s . length - 1 ; return - 1 ; }
Ref: 
function countDigitsToBeRemoved ( $ N , $ K ) { $ s = strval ( $ N ) ; $ res = 0 ; $ f_zero = 0 ; for ( $ i = strlen ( $ s ) - 1 ; $ i >= 0 ; $ i -- ) { if ( $ K == 0 ) return $ res ; if ( $ s [ $ i ] == '0' ) { $ f_zero = 1 ; $ K -- ; } else $ res ++ ; } if ( ! $ K ) return $ res ; else if ( $ f_zero ) return strlen ( $ s ) - 1 ; return -1 ; }
Hyp: 
function countDigitsToBeRemoved ( $ N , $ K ) { $ s = $ N . toString ( ) ; $ res = 0 ; $ f_zero = 0 ; for ( $ i = strlen ( $ s ) - 1 ; $ i >= 0 ; $ i -- ) { if ( $ K == 0 ) return $ res ; if ( $ s [ $ i ] == '0' ) { $ f_zero = 1 ; $ K -- ; } else $ res ++ ; } if ( $ K == 0 ) return $ res ; else if ( $ f_zero == 1 ) return $ s . length - 1 ; return -1 ; }

BLEU: 85.05
Edit Sim: 39


Src: 
function countWays ( N ) { let E = parseInt ( ( N * ( N - 1 ) ) / 2 , 10 ) ; if ( N == 1 ) return 0 ; return Math . pow ( 2 , E - 1 ) ; }
Ref: 
function countWays ( $ N ) { $ E = ( $ N * ( $ N - 1 ) ) / 2 ; if ( $ N == 1 ) return 0 ; return ( int ) pow ( 2 , $ E - 1 ) ; }
Hyp: 
function countWays ( $ N ) { $ E = ( $ N * ( $ N - 1 ) ) / 2 ; if ( $ N == 1 ) return 0 ; return pow ( 2 , $ E - 1 ) ; }

BLEU: 90.51
Edit Sim: 8


Src: 
function CountCharacters ( str , l , r ) { let cnt = 0 ; let m = new Map ( ) ; let len = str . length ; for ( let i = 0 ; i < len ; i ++ ) { if ( ! ( l <= str [ i ] . charCodeAt ( 0 ) && str [ i ] . charCodeAt ( 0 ) <= r ) ) { cnt ++ ; if ( ! m . has ( str [ i ] ) ) { m . set ( str [ i ] , 0 ) ; document . write ( str [ i ] + " " ) ; } m . set ( str [ i ] , m . get ( str [ i ] + 1 ) ) ; } } return cnt ; }
Ref: 
function CountCharacters ( $ str , $ l , $ r ) { $ cnt = 0 ; $ m = array_fill ( 0 , 256 , NULL ) ; $ len = strlen ( $ str ) ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { if ( ! ( $ l <= ord ( $ str [ $ i ] ) and ord ( $ str [ $ i ] ) <= $ r ) ) { $ cnt ++ ; if ( isset ( $ m [ ord ( $ str [ $ i ] ) ] ) != 1 ) { echo $ str [ $ i ] . " " ; $ m [ ord ( $ str [ $ i ] ) ] ++ ; } } } return $ cnt ; }
Hyp: 
function CountCharacters ( $ str , $ l , $ r ) { $ cnt = 0 ; $ m = array ( ) ; $ len = strlen ( $ str ) ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { if ( ! ( $ l <= ord ( $ str [ $ i ] ) && ord ( $ str [ $ i ] ) <= $ r ) ) { $ cnt ++ ; if ( ! $ m [ $ str [ $ i ] ] ) { $ m [ $ str [ $ i ] ] = 0 ; echo $ str [ $ i ] . " " ; } $ m [ $ str [ $ i ] + 1 ] = 1 ; } } return $ cnt ; }

BLEU: 75.57
Edit Sim: 71


Src: 
function isSubsetSum ( set , n , sum ) { if ( sum == 0 ) return true ; if ( n == 0 ) return false ; if ( set [ n - 1 ] > sum ) return isSubsetSum ( set , n - 1 , sum ) ; return isSubsetSum ( set , n - 1 , sum ) || isSubsetSum ( set , n - 1 , sum - set [ n - 1 ] ) ; }
Ref: 
function isSubsetSum ( $ set , $ n , $ sum ) { if ( $ sum == 0 ) return true ; if ( $ n == 0 ) return false ; if ( $ set [ $ n - 1 ] > $ sum ) return isSubsetSum ( $ set , $ n - 1 , $ sum ) ; return isSubsetSum ( $ set , $ n - 1 , $ sum ) || isSubsetSum ( $ set , $ n - 1 , $ sum - $ set [ $ n - 1 ] ) ; }
Hyp: 
function isSubsetSum ( $ set , $ n , $ sum ) { if ( $ sum == 0 ) return true ; if ( $ n == 0 ) return false ; if ( $ set [ $ n - 1 ] > $ sum ) return isSubsetSum ( $ set , $ n - 1 , $ sum ) ; return isSubsetSum ( $ set , $ n - 1 , $ sum ) || isSubsetSum ( $ set , $ n - 1 , $ sum - $ set [ $ n - 1 ] ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function squareSide ( a ) { if ( a < 0 ) return - 1 ; var x = ( 0.423 * a ) ; return x ; }
Ref: 
function squareSide ( $ a ) { if ( $ a < 0 ) return -1 ; $ x = 0.423 * $ a ; return $ x ; }
Hyp: 
function squareSide ( $ a ) { if ( $ a < 0 ) return -1 ; $ x = ( 0.423 * $ a ) ; return $ x ; }

BLEU: 83.5
Edit Sim: 4


Src: 
function countOnes ( n ) { let count = 1 ; let rem = 1 ; while ( rem != 0 ) { rem = ( rem * 10 + 1 ) % n ; count ++ ; } return count ; }
Ref: 
function countOnes ( $ n ) { $ count = 1 ; $ rem = 1 ; while ( $ rem != 0 ) { $ rem = ( $ rem * 10 + 1 ) % $ n ; $ count ++ ; } return $ count ; }
Hyp: 
function countOnes ( $ n ) { $ count = 1 ; $ rem = 1 ; while ( $ rem != 0 ) { $ rem = ( $ rem * 10 + 1 ) % $ n ; $ count ++ ; } return $ count ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function maxPrimes ( n ) { return parseInt ( n / 2 ) ; }
Ref: 
function maxPrimes ( $ n ) { return ( int ) ( $ n / 2 ) ; }
Hyp: 
function maxPrimes ( $ n ) { return ( int ) ( $ n / 2 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function transpose ( A ) { for ( i = 0 ; i < N ; i ++ ) for ( j = i + 1 ; j < N ; j ++ ) { var temp = A [ i ] [ j ] ; A [ i ] [ j ] = A [ j ] [ i ] ; A [ j ] [ i ] = temp ; } } var A = [ [ 1 , 1 , 1 , 1 ] , [ 2 , 2 , 2 , 2 ] , [ 3 , 3 , 3 , 3 ] , [ 4 , 4 , 4 , 4 ] ] ; transpose ( A ) ; document . write ( " " ) ; for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < N ; j ++ ) document . write ( A [ i ] [ j ] + " " ) ; document . write ( " \< " ) ; }
Ref: 
function transpose ( & $ A ) { for ( $ i = 0 ; $ i < $ N ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ N ; $ j ++ ) { $ temp = $ A [ $ i ] [ $ j ] ; $ A [ $ i ] [ $ j ] = $ A [ $ j ] [ $ i ] ; $ A [ $ j ] [ $ i ] = $ temp ; } } $ N = 4 ; $ A = array ( array ( 1 , 1 , 1 , 1 ) , array ( 2 , 2 , 2 , 2 ) , array ( 3 , 3 , 3 , 3 ) , array ( 4 , 4 , 4 , 4 ) ) ; transpose ( $ A ) ; echo " Modified ▁ matrix ▁ is ▁ " . " STRNEWLINE " ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { for ( $ j = 0 ; $ j < $ N ; $ j ++ ) echo $ A [ $ i ] [ $ j ] . " ▁ " ; echo " STRNEWLINE " ; }
Hyp: 
function transpose ( & $ A ) { for ( $ i = 0 ; $ i < $ N ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ N ; $ j ++ ) { $ t = $ A [ $ i ] [ $ j ] ; $ A [ $ i ] [ $ j ] = $ A [ $ j ] [ $ i ] ; $ A [ $ j ] [ $ i ] = $ t ; } } $ A = array ( array ( 1 , 1 , 1 , 1 ) , array ( 2 , 2 , 2 , 2 ) , array ( 3 , 3 , 3 , 3 ) , array ( 4 , 4 , 4 , 4 ) ) ; transpose ( $ A ) ; echo " Result ▁ matrix ▁ is ▁ STRNEWLINE " ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { for ( $ j = 0 ; $ j < $ N ; $ j ++ ) { echo $ A [ $ i ] [ $ j ] ; echo " ▁ " ; } echo " STRNEWLINE " ; }

BLEU: 90.07
Edit Sim: 40


Src: 
function MinimumX ( a , b , c , k ) { let x = Number . MAX_VALUE ; if ( k <= c ) return 0 ; let h = k - c ; let l = 0 ; while ( l <= h ) { let m = Math . floor ( ( l + h ) / 2 ) ; if ( ( a * m * m ) + ( b * m ) > ( k - c ) ) { x = Math . min ( x , m ) ; h = m - 1 ; } else if ( ( a * m * m ) + ( b * m ) < ( k - c ) ) l = m + 1 ; else return m ; } return x ; }
Ref: 
function MinimumX ( $ a , $ b , $ c , $ k ) { $ x = PHP_INT_MAX ; if ( $ k <= $ c ) return 0 ; $ h = $ k - $ c ; $ l = 0 ; while ( $ l <= $ h ) { $ m = floor ( ( $ l + $ h ) / 2 ) ; if ( ( $ a * $ m * $ m ) + ( $ b * $ m ) > ( $ k - $ c ) ) { $ x = min ( $ x , $ m ) ; $ h = $ m - 1 ; } else if ( ( $ a * $ m * $ m ) + ( $ b * $ m ) < ( $ k - $ c ) ) $ l = $ m + 1 ; else return $ m ; } return $ x ; }
Hyp: 
function MinimumX ( $ a , $ b , $ c , $ k ) { $ x = PHP_INT_MAX ; if ( $ k <= $ c ) return 0 ; $ h = $ k - $ c ; $ l = 0 ; while ( $ l <= $ h ) { $ m = ( int ) ( ( $ l + $ h ) / 2 ) ; if ( ( $ a * $ m * $ m ) + ( $ b * $ m ) > ( $ k - $ c ) ) { $ x = min ( $ x , $ m ) ; $ h = $ m - 1 ; } else if ( ( $ a * $ m * $ m ) + ( $ b * $ m ) < ( $ k - $ c ) ) $ l = $ m + 1 ; else return $ m ; } return $ x ; }

BLEU: 97.38
Edit Sim: 7


Src: 
function nthTerm ( n ) { return 5 * Math . pow ( n , 2 ) - 5 * n ; }
Ref: 
function nthTerm ( $ n ) { return 5 * pow ( $ n , 2 ) - 5 * $ n ; }
Hyp: 
function nthTerm ( $ n ) { return 5 * pow ( $ n , 2 ) - 5 * $ n ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function maxRepeating ( str ) { var n = str . length ; var count = 0 ; var res = str [ 0 ] ; var cur_count = 1 ; for ( var i = 0 ; i < n ; i ++ ) { if ( i < n - 1 && str [ i ] == str [ i + 1 ] ) cur_count ++ ; else { if ( cur_count > count ) { count = cur_count ; res = str [ i ] ; } cur_count = 1 ; } } return res ; }
Ref: 
function maxRepeating ( $ str ) { $ n = strlen ( $ str ) ; $ count = 0 ; $ res = $ str [ 0 ] ; $ cur_count = 1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ i < $ n - 1 && $ str [ $ i ] == $ str [ $ i + 1 ] ) $ cur_count ++ ; else { if ( $ cur_count > $ count ) { $ count = $ cur_count ; $ res = $ str [ $ i ] ; } $ cur_count = 1 ; } } return $ res ; }
Hyp: 
function maxRepeating ( $ str ) { $ n = strlen ( $ str ) ; $ count = 0 ; $ res = $ str [ 0 ] ; $ cur_count = 1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ i < $ n - 1 && $ str [ $ i ] == $ str [ $ i + 1 ] ) $ cur_count ++ ; else { if ( $ cur_count > $ count ) { $ count = $ cur_count ; $ res = $ str [ $ i ] ; } $ cur_count = 1 ; } } return $ res ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function trianglearea ( l , b ) { if ( l < 0 b < 0 ) return - 1 ; let area = ( l * b ) / 2 ; return area ; }
Ref: 
function trianglearea ( $ l , $ b ) { if ( $ l < 0 or $ b < 0 ) return -1 ; $ area = ( $ l * $ b ) / 2 ; return $ area ; }
Hyp: 
function trianglearea ( $ l , $ b ) { if ( $ l < 0 $ b < 0 ) return -1 ; $ area = ( $ l * $ b ) / 2 ; return $ area ; }

BLEU: 94.0
Edit Sim: 3


Src: 
function lbs ( arr , n ) { let i , j ; let lis = new Array ( n ) for ( i = 0 ; i < n ; i ++ ) lis [ i ] = 1 ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; let lds = new Array ( n ) ; for ( i = 0 ; i < n ; i ++ ) lds [ i ] = 1 ; for ( i = n - 2 ; i >= 0 ; i -- ) for ( j = n - 1 ; j > i ; j -- ) if ( arr [ i ] > arr [ j ] && lds [ i ] < lds [ j ] + 1 ) lds [ i ] = lds [ j ] + 1 ; let max = lis [ 0 ] + lds [ 0 ] - 1 ; for ( i = 1 ; i < n ; i ++ ) if ( lis [ i ] + lds [ i ] - 1 > max ) max = lis [ i ] + lds [ i ] - 1 ; return max ; }
Ref: 
function lbs ( & $ arr , $ n ) { $ lis = array_fill ( 0 , $ n , NULL ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ lis [ $ i ] = 1 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ i ; $ j ++ ) if ( $ arr [ $ i ] > $ arr [ $ j ] && $ lis [ $ i ] < $ lis [ $ j ] + 1 ) $ lis [ $ i ] = $ lis [ $ j ] + 1 ; $ lds = array_fill ( 0 , $ n , NULL ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ lds [ $ i ] = 1 ; for ( $ i = $ n - 2 ; $ i >= 0 ; $ i -- ) for ( $ j = $ n - 1 ; $ j > $ i ; $ j -- ) if ( $ arr [ $ i ] > $ arr [ $ j ] && $ lds [ $ i ] < $ lds [ $ j ] + 1 ) $ lds [ $ i ] = $ lds [ $ j ] + 1 ; $ max = $ lis [ 0 ] + $ lds [ 0 ] - 1 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) if ( $ lis [ $ i ] + $ lds [ $ i ] - 1 > $ max ) $ max = $ lis [ $ i ] + $ lds [ $ i ] - 1 ; return $ max ; }
Hyp: 
function lbs ( & $ arr , $ n ) { $ lis = array_fill ( 0 , $ n , NULL ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ lis [ $ i ] = 1 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ i ; $ j ++ ) if ( $ arr [ $ i ] > $ arr [ $ j ] && $ lis [ $ i ] < $ lis [ $ j ] + 1 ) $ lis [ $ i ] = $ lis [ $ j ] + 1 ; $ lds = array_fill ( 0 , $ n , NULL ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ lds [ $ i ] = 1 ; for ( $ i = $ n - 2 ; $ i >= 0 ; $ i -- ) for ( $ j = $ n - 1 ; $ j > $ i ; $ j -- ) if ( $ arr [ $ i ] > $ arr [ $ j ] && $ lds [ $ i ] < $ lds [ $ j ] + 1 ) $ lds [ $ i ] = $ lds [ $ j ] + 1 ; $ max = $ lis [ 0 ] + $ lds [ 0 ] - 1 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) if ( $ lis [ $ i ] + $ lds [ $ i ] - 1 > $ max ) $ max = $ lis [ $ i ] + $ lds [ $ i ] - 1 ; return $ max ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function hexadiagonal ( a ) { if ( a < 0 ) return - 1 ; return 2 * a ; }
Ref: 
function hexadiagonal ( $ a ) { if ( $ a < 0 ) return -1 ; return 2 * $ a ; }
Hyp: 
function hexadiagonal ( $ a ) { if ( $ a < 0 ) return -1 ; return 2 * $ a ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countSteps ( x , y ) { if ( x % y == 0 ) return Math . floor ( x / y ) ; return Math . floor ( x / y ) + countSteps ( y , x % y ) ; }
Ref: 
function countSteps ( $ x , $ y ) { if ( $ x % $ y == 0 ) return floor ( ( ( int ) $ x / $ y ) ) ; return floor ( ( ( int ) $ x / $ y ) + countSteps ( $ y , $ x % $ y ) ) ; }
Hyp: 
function countSteps ( $ x , $ y ) { if ( $ x % $ y == 0 ) return ( int ) floor ( $ x / $ y ) ; return ( int ) floor ( $ x / $ y ) + countSteps ( $ y , $ x % $ y ) ; }

BLEU: 76.21
Edit Sim: 32


Src: 
function segregate0and1 ( arr , n ) { let type0 = 0 ; let type1 = n - 1 ; while ( type0 < type1 ) { if ( arr [ type0 ] == 1 ) { arr [ type0 ] = arr [ type0 ] + arr [ type1 ] ; arr [ type1 ] = arr [ type0 ] - arr [ type1 ] ; arr [ type0 ] = arr [ type0 ] - arr [ type1 ] ; type1 -- ; } else { type0 ++ ; } } }
Ref: 
function segregate0and1 ( $ arr , $ n ) { $ type0 = 0 ; $ type1 = $ n - 1 ; while ( $ type0 < $ type1 ) { if ( $ arr [ $ type0 ] == 1 ) { $ temp = $ arr [ $ type0 ] ; $ arr [ $ type0 ] = $ arr [ $ type1 ] ; $ arr [ $ type1 ] = $ temp ; $ type1 -- ; } else { $ type0 ++ ; } } return $ arr ; }
Hyp: 
function segregate0and1 ( & $ arr , $ n ) { $ type0 = 0 ; $ type1 = $ n - 1 ; while ( $ type0 < $ type1 ) { if ( $ arr [ $ type0 ] == 1 ) { $ arr [ $ type0 ] = $ arr [ $ type0 ] + $ arr [ $ type1 ] ; $ arr [ $ type1 ] = $ arr [ $ type0 ] - $ arr [ $ type1 ] ; $ arr [ $ type0 ] = $ arr [ $ type0 ] - $ arr [ $ type1 ] ; $ type1 -- ; } else { $ type0 ++ ; } } }

BLEU: 69.15
Edit Sim: 100


Src: 
function makeOdd ( n ) { if ( n % 2 != 0 ) return 1 ; var ans = 1 ; while ( n % 2 == 0 ) { n = parseInt ( n / 2 ) ; ans *= 2 ; } return ans ; }
Ref: 
function makeOdd ( $ n ) { if ( $ n % 2 != 0 ) return 1 ; $ resul = 1 ; while ( $ n % 2 == 0 ) { $ n /= 2 ; $ resul *= 2 ; } return $ resul ; }
Hyp: 
function makeOdd ( $ n ) { if ( $ n % 2 != 0 ) return 1 ; $ ans = 1 ; while ( $ n % 2 == 0 ) { $ n = ( int ) $ n / 2 ; $ ans *= 2 ; } return $ ans ; }

BLEU: 71.01
Edit Sim: 27


Src: 
function find_sum_of_two_squares ( a , b ) { let ab = a * b ; for ( let i = 0 ; i * i <= ab ; i ++ ) { for ( let j = i ; i * i + j * j <= ab ; j ++ ) { if ( i * i + j * j == ab ) document . write ( i + " " + j + " " + ab + " " ) ; } } }
Ref: 
function find_sum_of_two_squares ( $ a , $ b ) { $ ab = $ a * $ b ; for ( $ i = 0 ; $ i * $ i <= $ ab ; $ i ++ ) { for ( $ j = $ i ; $ i * $ i + $ j * $ j <= $ ab ; $ j ++ ) { if ( $ i * $ i + $ j * $ j == $ ab ) echo $ i , " ^ 2 ▁ + ▁ " , $ j , " ^ 2 ▁ = ▁ " , $ ab , " STRNEWLINE " ; } } }
Hyp: 
function find_sum_of_two_squares ( $ a , $ b ) { $ ab = $ a * $ b ; for ( $ i = 0 ; $ i * $ i <= $ ab ; $ i ++ ) { for ( $ j = $ i ; $ i * $ i + $ j * $ j <= $ ab ; $ j ++ ) { if ( $ i * $ i + $ j * $ j == $ ab ) echo $ i . " " , $ j , " " , $ ab , " " ; } } }

BLEU: 84.84
Edit Sim: 32


Src: 
function calculateSum ( n ) { let sum = 0 ; for ( let row = 0 ; row < n ; row ++ ) { sum = sum + ( 1 << row ) ; } return sum ; }
Ref: 
function calculateSum ( $ n ) { $ sum = 0 ; for ( $ row = 0 ; $ row < $ n ; $ row ++ ) { $ sum = $ sum + ( 1 << $ row ) ; } return $ sum ; }
Hyp: 
function calculateSum ( $ n ) { $ sum = 0 ; for ( $ row = 0 ; $ row < $ n ; $ row ++ ) { $ sum = $ sum + ( 1 << $ row ) ; } return $ sum ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function calculateSum ( n ) { sum = 0 ; sum = 1 << n ; return ( sum - 1 ) ; }
Ref: 
function calculateSum ( $ n ) { $ sum = 0 ; $ sum = 1 << $ n ; return ( $ sum - 1 ) ; }
Hyp: 
function calculateSum ( $ n ) { $ sum = 0 ; $ sum = 1 << $ n ; return ( $ sum - 1 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function EqualNumber ( A , B ) { return ( A ^ B ) ; }
Ref: 
function EqualNumber ( $ A , $ B ) { return ( $ A ^ $ B ) ; }
Hyp: 
function EqualNumber ( $ A , $ B ) { return ( $ A ^ $ B ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function minCost ( cost ) { let dist = new Array ( N ) ; dist . fill ( 0 ) ; for ( let i = 0 ; i < N ; i ++ ) dist [ i ] = INF ; dist [ 0 ] = 0 ; for ( let i = 0 ; i < N ; i ++ ) for ( let j = i + 1 ; j < N ; j ++ ) if ( dist [ j ] > dist [ i ] + cost [ i ] [ j ] ) dist [ j ] = dist [ i ] + cost [ i ] [ j ] ; return dist [ N - 1 ] ; }
Ref: 
function minCost ( $ cost ) { global $ INF ; global $ N ; $ dist [ $ N ] = array ( ) ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) $ dist [ $ i ] = $ INF ; $ dist [ 0 ] = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ N ; $ j ++ ) if ( $ dist [ $ j ] > $ dist [ $ i ] + $ cost [ $ i ] [ $ j ] ) $ dist [ $ j ] = $ dist [ $ i ] + $ cost [ $ i ] [ $ j ] ; return $ dist [ $ N - 1 ] ; }
Hyp: 
function minCost ( & $ cost ) { global $ N ; $ dist = array ( ) ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) $ dist [ $ i ] = INF ; $ dist [ 0 ] = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ N ; $ j ++ ) if ( $ dist [ $ j ] > $ dist [ $ i ] + $ cost [ $ i ] [ $ j ] ) $ dist [ $ j ] = $ dist [ $ i ] + $ cost [ $ i ] [ $ j ] ; return $ dist [ $ N - 1 ] ; }

BLEU: 91.28
Edit Sim: 27


Src: 
function findRadiusOfcircumcircle ( l , b ) { if ( l < 0 b < 0 ) return - 1 ; var radius = Math . sqrt ( Math . pow ( l , 2 ) + Math . pow ( b , 2 ) ) / 2 ; return radius ; }
Ref: 
function findRadiusOfcircumcircle ( $ l , $ b ) { if ( $ l < 0 $ b < 0 ) return -1 ; $ radius = sqrt ( pow ( $ l , 2 ) + pow ( $ b , 2 ) ) / 2 ; return $ radius ; }
Hyp: 
function findRadiusOfcircumcircle ( $ l , $ b ) { if ( $ l < 0 $ b < 0 ) return -1 ; $ radius = sqrt ( pow ( $ l , 2 ) + pow ( $ b , 2 ) ) / 2 ; return $ radius ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countWays ( n ) { let res = new Array ( n + 2 ) ; res [ 0 ] = 1 ; res [ 1 ] = 1 ; res [ 2 ] = 2 ; for ( let i = 3 ; i <= n ; i ++ ) res [ i ] = res [ i - 1 ] + res [ i - 2 ] + res [ i - 3 ] ; return res [ n ] ; }
Ref: 
function countWays ( $ n ) { $ res [ 0 ] = 1 ; $ res [ 1 ] = 1 ; $ res [ 2 ] = 2 ; for ( $ i = 3 ; $ i <= $ n ; $ i ++ ) $ res [ $ i ] = $ res [ $ i - 1 ] + $ res [ $ i - 2 ] + $ res [ $ i - 3 ] ; return $ res [ $ n ] ; }
Hyp: 
function countWays ( $ n ) { $ res [ 0 ] = 1 ; $ res [ 1 ] = 1 ; $ res [ 2 ] = 2 ; for ( $ i = 3 ; $ i <= $ n ; $ i ++ ) $ res [ $ i ] = $ res [ $ i - 1 ] + $ res [ $ i - 2 ] + $ res [ $ i - 3 ] ; return $ res [ $ n ] ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function sumofNterm ( a , d , b , r , n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) sum += ( ( a + ( i - 1 ) * d ) * ( b * Math . pow ( r , i - 1 ) ) ) ; return sum ; }
Ref: 
function sumofNterm ( $ a , $ d , $ b , $ r , $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ sum += ( ( $ a + ( $ i - 1 ) * $ d ) * ( $ b * pow ( $ r , $ i - 1 ) ) ) ; return $ sum ; }
Hyp: 
function sumofNterm ( $ a , $ d , $ b , $ r , $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ sum += ( ( $ a + ( $ i - 1 ) * $ d ) * ( $ b * pow ( $ r , $ i - 1 ) ) ) ; return $ sum ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function perimeter ( diameter , height ) { return 2 * ( diameter + height ) ; }
Ref: 
function perimeter ( $ diameter , $ height ) { return 2 * ( $ diameter + $ height ) ; }
Hyp: 
function perimeter ( $ diameter , $ height ) { return 2 * ( $ diameter + $ height ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function smallestEven ( n ) { if ( n == 1 ) return 0 ; return Math . pow ( 10 , n - 1 ) ; }
Ref: 
function smallestEven ( $ n ) { if ( $ n == 1 ) return 0 ; return pow ( 10 , $ n - 1 ) ; }
Hyp: 
function smallestEven ( $ n ) { if ( $ n == 1 ) return 0 ; return pow ( 10 , $ n - 1 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function totalSumDivisibleByNum ( n , number ) { let firstnum = Math . pow ( 10 , n - 1 ) ; let lastnum = Math . pow ( 10 , n ) ; let sum = 0 ; for ( let i = firstnum ; i < lastnum ; i ++ ) if ( i % number == 0 ) sum += i ; return sum ; }
Ref: 
function totalSumDivisibleByNum ( $ n , $ number ) { $ firstnum = pow ( 10 , $ n - 1 ) ; $ lastnum = pow ( 10 , $ n ) ; $ sum = 0 ; for ( $ i = $ firstnum ; $ i < $ lastnum ; $ i ++ ) if ( $ i % $ number == 0 ) $ sum += $ i ; return $ sum ; }
Hyp: 
function totalSumDivisibleByNum ( $ n , $ number ) { $ firstnum = pow ( 10 , $ n - 1 ) ; $ lastnum = pow ( 10 , $ n ) ; $ sum = 0 ; for ( $ i = $ firstnum ; $ i < $ lastnum ; $ i ++ ) if ( $ i % $ number == 0 ) $ sum += $ i ; return $ sum ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function printPair ( g , l ) { document . write ( g + " " + l ) ; }
Ref: 
function printPair ( $ g , $ l ) { echo $ g ; echo ( " ▁ " ) ; echo $ l ; }
Hyp: 
function printPair ( $ g , $ l ) { echo ( $ g . " , ▁ " . $ l . " ) " ; }

BLEU: 49.85
Edit Sim: 18


Src: 
function leftRotate ( arr , n , k ) { for ( let i = k ; i < k + n ; i ++ ) document . write ( arr [ i % n ] + " " ) ; }
Ref: 
function leftRotate ( $ arr , $ n , $ k ) { for ( $ i = $ k ; $ i < $ k + $ n ; $ i ++ ) echo $ arr [ $ i % $ n ] , " ▁ " ; }
Hyp: 
function leftRotate ( $ arr , $ n , $ k ) { for ( $ i = $ k ; $ i < $ k + $ n ; $ i ++ ) echo $ arr [ $ i % $ n ] . " ▁ " ; }

BLEU: 94.87
Edit Sim: 1


Src: 
function normal ( m , n ) { var N = ( ( Math . abs ( m ) * Math . abs ( n ) ) / Math . sqrt ( ( Math . abs ( m ) * Math . abs ( m ) ) + ( Math . abs ( n ) * Math . abs ( n ) ) ) ) ; return N ; }
Ref: 
function normal ( $ m , $ n ) { $ N = ( abs ( $ m ) * abs ( $ n ) ) / sqrt ( ( abs ( $ m ) * abs ( $ m ) ) + ( abs ( $ n ) * abs ( $ n ) ) ) ; return $ N ; }
Hyp: 
function normal ( $ m , $ n ) { $ N = ( ( abs ( $ m ) * abs ( $ n ) ) / sqrt ( ( abs ( $ m ) * abs ( $ m ) ) + ( abs ( $ n ) * abs ( $ n ) ) ) ; return $ N ; }

BLEU: 97.21
Edit Sim: 2


Src: 
function countPaths ( m , n ) { if ( m == 1 n == 1 ) return 1 ; return countPaths ( m - 1 , n ) + countPaths ( m , n - 1 ) ; }
Ref: 
function countPaths ( $ m , $ n ) { if ( $ m == 1 $ n == 1 ) return 1 ; return countPaths ( $ m - 1 , $ n ) + countPaths ( $ m , $ n - 1 ) ; }
Hyp: 
function countPaths ( $ m , $ n ) { if ( $ m == 1 $ n == 1 ) return 1 ; return countPaths ( $ m - 1 , $ n ) + countPaths ( $ m , $ n - 1 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function seriesSum ( n ) { var sum = 0 ; for ( i = 1 ; i <= n ; i ++ ) sum += i * ( ( i + 1 ) / 2 ) ; return sum ; }
Ref: 
function seriesSum ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ sum += $ i * ( $ i + 1 ) / 2 ; return $ sum ; }
Hyp: 
function seriesSum ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ sum += $ i * ( ( $ i + 1 ) / 2 ) ; return $ sum ; }

BLEU: 91.41
Edit Sim: 4


Src: 
function nthMagicNo ( n ) { let pow = 1 , answer = 0 ; while ( n != 0 ) { pow = pow * 5 ; if ( ( n & 1 ) == 1 ) answer += pow ; n >>= 1 ; } return answer ; }
Ref: 
function nthMagicNo ( $ n ) { $ pow = 1 ; $ answer = 0 ; while ( $ n ) { $ pow = $ pow * 5 ; if ( $ n & 1 ) $ answer += $ pow ; } return $ answer ; }
Hyp: 
function nthMagicNo ( $ n ) { $ pow = 1 ; $ answer = 0 ; while ( $ n != 0 ) { $ pow = $ pow * 5 ; if ( ( $ n & 1 ) == 1 ) $ answer += $ pow ; $ n >>= 1 ; } return $ answer ; }

BLEU: 76.13
Edit Sim: 26


Src: 
function findSumSubsets ( n ) { return ( n * ( n + 1 ) / 2 ) * ( 1 << ( n - 1 ) ) ; }
Ref: 
function findSumSubsets ( $ n ) { return ( $ n * ( $ n + 1 ) / 2 ) * ( 1 << ( $ n - 1 ) ) ; }
Hyp: 
function findSumSubsets ( $ n ) { return ( $ n * ( $ n + 1 ) / 2 ) * ( 1 << ( $ n - 1 ) ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countPaths ( n ) { let zB = 1 ; let zADC = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { let nzB = zADC * 3 ; let nzADC = ( zADC * 2 + zB ) ; zB = nzB ; zADC = nzADC ; } return zB ; }
Ref: 
function countPaths ( $ n ) { $ zB = 1 ; $ zADC = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ nzB = $ zADC * 3 ; $ nzADC = ( $ zADC * 2 + $ zB ) ; $ zB = $ nzB ; $ zADC = $ nzADC ; } return $ zB ; }
Hyp: 
function countPaths ( $ n ) { $ zB = 1 ; $ zADC = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ nzB = $ zADC * 3 ; $ nzADC = ( $ zADC * 2 + $ zB ) ; $ zB = $ nzB ; $ zADC = $ nzADC ; } return $ zB ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function pell ( n ) { if ( n <= 2 ) return n ; let a = 1 ; let b = 2 ; let c ; for ( let i = 3 ; i <= n ; i ++ ) { c = 2 * b + a ; a = b ; b = c ; } return b ; }
Ref: 
function pell ( $ n ) { if ( $ n <= 2 ) return $ n ; $ a = 1 ; $ b = 2 ; $ c ; $ i ; for ( $ i = 3 ; $ i <= $ n ; $ i ++ ) { $ c = 2 * $ b + $ a ; $ a = $ b ; $ b = $ c ; } return $ b ; }
Hyp: 
function pell ( $ n ) { if ( $ n <= 2 ) return $ n ; $ a = 1 ; $ b = 2 ; $ c ; for ( $ i = 3 ; $ i <= $ n ; $ i ++ ) { $ c = 2 * $ b + $ a ; $ a = $ b ; $ b = $ c ; } return $ b ; }

BLEU: 95.28
Edit Sim: 6


Src: 
function shortestLength ( n , x , y ) { let answer = 0 ; let i = 0 ; while ( n != 0 && i < x . length ) { if ( x [ i ] + y [ i ] > answer ) answer = x [ i ] + y [ i ] ; i ++ ; } document . write ( " " + answer + " " ) ; document . write ( " " + " " + answer + " " + " " + answer + " " ) ; }
Ref: 
function shortestLength ( $ n , & $ x , & $ y ) { $ answer = 0 ; $ i = 0 ; while ( $ n -- ) { if ( $ x [ $ i ] + $ y [ $ i ] > $ answer ) $ answer = $ x [ $ i ] + $ y [ $ i ] ; $ i ++ ; } echo " Length ▁ - > ▁ " . $ answer . " STRNEWLINE " ; echo " Path ▁ - > ▁ " . " ( 1 , " ▁ . $ answer ▁ . " ) " . STRNEWLINE TABSYMBOL TABSYMBOL " and ( " ▁ . $ answer ▁ . ▁ " , 1 ) " ; }
Hyp: 
function shortestLength ( $ n , $ x , $ y ) { $ answer = 0 ; $ i = 0 ; while ( $ n != 0 && $ i < strlen ( $ x ) ) { if ( $ x [ $ i ] + $ y [ $ i ] > $ answer ) $ answer = $ x [ $ i ] + $ y [ $ i ] ; $ i ++ ; } echo " Yes ▁ " , $ answer , " STRNEWLINE " ; echo " No ▁ " , $ answer , " STRNEWLINE " ; }

BLEU: 56.7
Edit Sim: 135


Src: 
function isRatioPossible ( lowCost , upCost , lowQuant , upQuant , r ) { for ( let i = lowQuant ; i <= upQuant ; i ++ ) { let ans = i * r ; if ( lowCost <= ans && ans <= upCost ) return true ; } return false ; }
Ref: 
function isRatioPossible ( $ lowCost , $ upCost , $ lowQuant , $ upQuant , $ r ) { for ( $ i = $ lowQuant ; $ i <= $ upQuant ; $ i ++ ) { $ ans = $ i * $ r ; if ( $ lowCost <= $ ans && $ ans <= $ upCost ) return true ; } return false ; }
Hyp: 
function isRatioPossible ( $ lowCost , $ upCost , $ lowQuant , $ upQuant , $ r ) { for ( $ i = $ lowQuant ; $ i <= $ upQuant ; $ i ++ ) { $ ans = $ i * $ r ; if ( $ lowCost <= $ ans && $ ans <= $ upCost ) return true ; } return false ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function isTidy ( num ) { let prev = 10 ; while ( num != 0 ) { let rem = num % 10 ; num /= 10 ; if ( rem > prev ) return false ; prev = rem ; } return true ; }
Ref: 
function isTidy ( $ num ) { $ prev = 10 ; while ( $ num ) { $ rem = $ num % 10 ; $ num = ( int ) $ num / 10 ; if ( $ rem > $ prev ) return false ; $ prev = $ rem ; } return true ; }
Hyp: 
function isTidy ( $ num ) { $ prev = 10 ; while ( $ num != 0 ) { $ rem = $ num % 10 ; $ num /= 10 ; if ( $ rem > $ prev ) return false ; $ prev = $ rem ; } return true ; }

BLEU: 82.57
Edit Sim: 22


Src: 
function complement ( number ) { number = number . split ( ' ' ) for ( let i = 0 ; i < number . length ; i ++ ) { if ( number [ i ] != ' ' ) { number [ i ] = String ( 9 - Number ( number [ i ] ) + 0 ) ; } } number = number . join ( " " ) document . write ( " " + number ) ; }
Ref: 
function complement ( $ number ) { for ( $ i = 0 ; $ i < strlen ( $ number ) ; $ i ++ ) if ( $ number [ $ i ] != ' . ' ) $ number [ $ i ] = '9' - $ number [ $ i ] + '0' ; echo "9 ' s ▁ complement ▁ is ▁ : ▁ " , $ number ; }
Hyp: 
function complement ( $ number ) { for ( $ i = 0 ; $ i < strlen ( $ number ) ; $ i ++ ) { if ( $ number [ $ i ] != '0' ) { $ number [ $ i ] = String ( 9 - Number ( $ number [ $ i ] ) + 0 ) ; } } $ number = $ number . join ( "0" ) echo " The ▁ complement ▁ of ▁ the ▁ number ▁ is ▁ " , $ number , " STRNEWLINE " ; }

BLEU: 51.95
Edit Sim: 109


Src: 
function pendulumArrangement ( arr , n ) { arr . sort ( function ( a , b ) { return a - b ; } ) ; var op = [ ... Array ( n ) ] ; var mid = parseInt ( ( n - 1 ) / 2 ) ; var j = 1 , i = 1 ; op [ mid ] = arr [ 0 ] ; for ( i = 1 ; i <= mid ; i ++ ) { op [ mid + i ] = arr [ j ++ ] ; op [ mid - i ] = arr [ j ++ ] ; } if ( n % 2 == 0 ) op [ mid + i ] = arr [ j ] ; document . write ( " " ) ; for ( i = 0 ; i < n ; i ++ ) document . write ( op [ i ] + " " ) ; document . write ( " " ) ; }
Ref: 
function pendulumArrangement ( $ arr , $ n ) { sort ( $ arr , $ n ) ; sort ( $ arr ) ; $ op [ $ n ] = NULL ; $ mid = floor ( ( $ n - 1 ) / 2 ) ; $ j = 1 ; $ i = 1 ; $ op [ $ mid ] = $ arr [ 0 ] ; for ( $ i = 1 ; $ i <= $ mid ; $ i ++ ) { $ op [ $ mid + $ i ] = $ arr [ $ j ++ ] ; $ op [ $ mid - $ i ] = $ arr [ $ j ++ ] ; } if ( $ n % 2 == 0 ) $ op [ $ mid + $ i ] = $ arr [ $ j ] ; echo " Pendulum ▁ arrangement : " ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ op [ $ i ] , " ▁ " ; echo " STRNEWLINE " ; }
Hyp: 
function pendulumArrangement ( $ arr , $ n ) { sort ( $ arr ) ; $ op = array_fill ( 0 , $ n , 0 ) ; $ mid = ( $ n - 1 ) / 2 ; $ j = 1 ; $ i = 1 ; $ op [ $ mid ] = $ arr [ 0 ] ; for ( $ i = 1 ; $ i <= $ mid ; $ i ++ ) { $ op [ $ mid + $ i ] = $ arr [ $ j ++ ] ; $ op [ $ mid - $ i ] = $ arr [ $ j ++ ] ; } if ( $ n % 2 == 0 ) $ op [ $ mid + $ i ] = $ arr [ $ j ] ; echo " ( " ; }

BLEU: 67.43
Edit Sim: 150


Src: 
function findS ( s ) { var l = 1 , r = parseInt ( ( s / 2 ) + 1 ) ; while ( l <= r ) { var mid = parseInt ( ( l + r ) / 2 ) ; var sum = mid * parseInt ( ( mid + 1 ) / 2 ) ; if ( sum == s ) return mid ; else if ( sum > s ) r = mid - 1 ; else l = mid + 1 ; } return - 1 ; }
Ref: 
function findS ( $ s ) { $ l = 1 ; $ r = 1 + ( int ) $ s / 2 ; while ( $ l <= $ r ) { $ mid = ( int ) ( ( $ l + $ r ) / 2 ) ; $ sum = ( int ) ( $ mid * ( $ mid + 1 ) / 2 ) ; if ( $ sum == $ s ) return $ mid ; else if ( $ sum > $ s ) $ r = $ mid - 1 ; else $ l = $ mid + 1 ; } return -1 ; }
Hyp: 
function findS ( $ s ) { $ l = 1 ; $ r = ( int ) ( ( $ s / 2 ) + 1 ) ; while ( $ l <= $ r ) { $ mid = ( int ) ( ( $ l + $ r ) / 2 ) ; $ sum = $ mid * ( int ) ( ( $ mid + 1 ) / 2 ) ; if ( $ sum == $ s ) return $ mid ; else if ( $ sum > $ s ) $ r = $ mid - 1 ; else $ l = $ mid + 1 ; } return -1 ; }

BLEU: 88.99
Edit Sim: 27


Src: 
function printNumberWithDR ( k , d ) { if ( d == 0 && k != 1 ) document . write ( " " ) ; else { document . write ( d ) ; k -- ; while ( k -- > 0 ) document . write ( " " ) ; } }
Ref: 
function printNumberWithDR ( $ k , $ d ) { if ( $ d == 0 && $ k != 1 ) echo " - 1" ; else { echo $ d ; $ k -- ; while ( $ k -- ) echo "0" ; } }
Hyp: 
function printNumberWithDR ( $ k , $ d ) { if ( $ d == 0 && $ k != 1 ) echo "0" ; else { echo $ d ; $ k -- ; while ( $ k -- > 0 ) echo "1" ; } }

BLEU: 85.36
Edit Sim: 9


Src: 
function fib ( n ) { let a = 0 , b = 1 , c ; if ( n >= 0 ) document . write ( a + " " ) ; if ( n >= 1 ) document . write ( b + " " ) ; for ( let i = 2 ; i <= n ; i ++ ) { c = a + b ; document . write ( c + " " ) ; a = b ; b = c ; } }
Ref: 
function fib ( $ n ) { $ a = 0 ; $ b = 1 ; $ c ; if ( $ n >= 0 ) echo $ a , " ▁ " ; if ( $ n >= 1 ) echo $ b , " ▁ " ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { $ c = $ a + $ b ; echo $ c , " " ; $ a = $ b ; $ b = $ c ; } }
Hyp: 
function fib ( $ n ) { $ a = 0 ; $ b = 1 ; $ c ; if ( $ n >= 0 ) echo $ a . " ▁ " ; if ( $ n >= 1 ) echo $ b . " ▁ " ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { $ c = $ a + $ b ; echo $ c . " ▁ " ; $ a = $ b ; $ b = $ c ; } }

BLEU: 90.48
Edit Sim: 5


Src: 
function Next_greater ( a , n , x ) { a . sort ( function ( aa , bb ) { return aa - bb } ) ; let low = 0 , high = n - 1 , ans = x + 1 ; while ( low <= high ) { let mid = Math . floor ( ( low + high ) / 2 ) ; if ( a [ mid ] <= ans ) { if ( a [ mid ] == ans ) { ans ++ ; high = n - 1 ; } low = mid + 1 ; } else high = mid - 1 ; } return ans ; }
Ref: 
function Next_greater ( $ a , $ n , $ x ) { sort ( $ a ) ; $ low = 0 ; $ high = $ n - 1 ; $ ans = $ x + 1 ; while ( $ low <= $ high ) { $ mid = ( $ low + $ high ) / 2 ; if ( $ a [ $ mid ] <= $ ans ) { if ( $ a [ $ mid ] == $ ans ) { $ ans ++ ; $ high = $ n - 1 ; } $ low = $ mid + 1 ; } else $ high = $ mid - 1 ; } return $ ans ; }
Hyp: 
function Next_greater ( $ a , $ n , $ x ) { sort ( $ a ) ; $ low = 0 ; $ high = $ n - 1 ; $ ans = $ x + 1 ; while ( $ low <= $ high ) { $ mid = ( $ low + $ high ) / 2 ; if ( $ a [ $ mid ] <= $ ans ) { if ( $ a [ $ mid ] == $ ans ) { $ ans ++ ; $ high = $ n - 1 ; } $ low = $ mid + 1 ; } else $ high = $ mid - 1 ; } return $ ans ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function minTime ( arr , n ) { if ( n <= 0 ) return 0 ; let incl = arr [ 0 ] ; let excl = 0 ; for ( let i = 1 ; i < n ; i ++ ) { let incl_new = arr [ i ] + Math . min ( excl , incl ) ; let excl_new = incl ; incl = incl_new ; excl = excl_new ; } return Math . min ( incl , excl ) ; }
Ref: 
function minTime ( $ arr , $ n ) { if ( $ n <= 0 ) return 0 ; $ excl = 0 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ incl_new = $ arr [ $ i ] + min ( $ excl , $ incl ) ; $ excl_new = $ incl ; $ incl = $ incl_new ; $ excl = $ excl_new ; } return min ( $ incl , $ excl ) ; }
Hyp: 
function minTime ( $ arr , $ n ) { if ( $ n <= 0 ) return 0 ; $ incl = $ arr [ 0 ] ; $ excl = 0 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ incl_new = $ arr [ $ i ] + min ( $ excl , $ incl ) ; $ excl_new = $ incl ; $ incl = $ incl_new ; $ excl = $ excl_new ; } return min ( $ incl , $ excl ) ; }

BLEU: 90.79
Edit Sim: 23


Src: 
function countPaths ( n , m ) { var dp = Array ( n + 1 ) . fill ( 0 ) . map ( x => Array ( m + 1 ) . fill ( 0 ) ) ; for ( i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = 1 ; for ( i = 0 ; i <= m ; i ++ ) dp [ 0 ] [ i ] = 1 ; for ( i = 1 ; i <= n ; i ++ ) for ( j = 1 ; j <= m ; j ++ ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] ; return dp [ n ] [ m ] ; }
Ref: 
function countPaths ( $ n , $ m ) { for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) $ dp [ $ i ] [ 0 ] = 1 ; for ( $ i = 0 ; $ i <= $ m ; $ i ++ ) $ dp [ 0 ] [ $ i ] = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) for ( $ j = 1 ; $ j <= $ m ; $ j ++ ) $ dp [ $ i ] [ $ j ] = $ dp [ $ i - 1 ] [ $ j ] + $ dp [ $ i ] [ $ j - 1 ] ; return $ dp [ $ n ] [ $ m ] ; }
Hyp: 
function countPaths ( $ n , $ m ) { $ dp [ $ n + 1 ] [ $ m + 1 ] = array ( ) ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) $ dp [ $ i ] [ 0 ] = 1 ; for ( $ i = 0 ; $ i <= $ m ; $ i ++ ) $ dp [ 0 ] [ $ i ] = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) for ( $ j = 1 ; $ j <= $ m ; $ j ++ ) $ dp [ $ i ] [ $ j ] = $ dp [ $ i - 1 ] [ $ j ] + $ dp [ $ i ] [ $ j - 1 ] ; return $ dp [ $ n ] [ $ m ] ; }

BLEU: 87.97
Edit Sim: 43


Src: 
function maxSumWO3Consec ( arr , n ) { let sum = [ ] ; if ( n >= 1 ) sum [ 0 ] = arr [ 0 ] ; if ( n >= 2 ) sum [ 1 ] = arr [ 0 ] + arr [ 1 ] ; if ( n > 2 ) sum [ 2 ] = Math . max ( sum [ 1 ] , Math . max ( arr [ 1 ] + arr [ 2 ] , arr [ 0 ] + arr [ 2 ] ) ) ; for ( let i = 3 ; i < n ; i ++ ) sum [ i ] = Math . max ( Math . max ( sum [ i - 1 ] , sum [ i - 2 ] + arr [ i ] ) , arr [ i ] + arr [ i - 1 ] + sum [ i - 3 ] ) ; return sum [ n - 1 ] ; }
Ref: 
function maxSumWO3Consec ( $ arr , $ n ) { $ sum = array ( ) ; if ( $ n >= 1 ) $ sum [ 0 ] = $ arr [ 0 ] ; if ( $ n >= 2 ) $ sum [ 1 ] = $ arr [ 0 ] + $ arr [ 1 ] ; if ( $ n > 2 ) $ sum [ 2 ] = max ( $ sum [ 1 ] , max ( $ arr [ 1 ] + $ arr [ 2 ] , $ arr [ 0 ] + $ arr [ 2 ] ) ) ; for ( $ i = 3 ; $ i < $ n ; $ i ++ ) $ sum [ $ i ] = max ( max ( $ sum [ $ i - 1 ] , $ sum [ $ i - 2 ] + $ arr [ $ i ] ) , $ arr [ $ i ] + $ arr [ $ i - 1 ] + $ sum [ $ i - 3 ] ) ; return $ sum [ $ n - 1 ] ; }
Hyp: 
function maxSumWO3Consec ( $ arr , $ n ) { $ sum = array ( ) ; if ( $ n >= 1 ) $ sum [ 0 ] = $ arr [ 0 ] ; if ( $ n >= 2 ) $ sum [ 1 ] = $ arr [ 0 ] + $ arr [ 1 ] ; if ( $ n > 2 ) $ sum [ 2 ] = max ( $ sum [ 1 ] , max ( $ arr [ 1 ] + $ arr [ 2 ] , $ arr [ 0 ] + $ arr [ 2 ] ) ) ; for ( $ i = 3 ; $ i < $ n ; $ i ++ ) $ sum [ $ i ] = max ( $ sum [ $ i - 1 ] , $ sum [ $ i - 2 ] + $ arr [ $ i ] ) , $ arr [ $ i ] + $ arr [ $ i - 1 ] + $ sum [ $ i - 3 ] ) ; return $ sum [ $ n - 1 ] ; }

BLEU: 98.87
Edit Sim: 6


Src: 
function centered_heptagonal_num ( n ) { return parseInt ( ( 7 * n * n - 7 * n + 2 ) / 2 ) ; }
Ref: 
function centered_heptagonal_num ( $ n ) { return ( 7 * $ n * $ n - 7 * $ n + 2 ) / 2 ; }
Hyp: 
function centered_heptagonal_num ( $ n ) { return ( 7 * $ n * $ n - 7 * $ n + 2 ) / 2 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function isSubsetSum ( set , n , sum ) { if ( sum == 0 ) return true ; if ( n == 0 ) return false ; if ( set [ n - 1 ] > sum ) return isSubsetSum ( set , n - 1 , sum ) ; return isSubsetSum ( set , n - 1 , sum ) || isSubsetSum ( set , n - 1 , sum - set [ n - 1 ] ) ; }
Ref: 
function isSubsetSum ( $ set , $ n , $ sum ) { if ( $ sum == 0 ) return true ; if ( $ n == 0 ) return false ; if ( $ set [ $ n - 1 ] > $ sum ) return isSubsetSum ( $ set , $ n - 1 , $ sum ) ; return isSubsetSum ( $ set , $ n - 1 , $ sum ) || isSubsetSum ( $ set , $ n - 1 , $ sum - $ set [ $ n - 1 ] ) ; }
Hyp: 
function isSubsetSum ( $ set , $ n , $ sum ) { if ( $ sum == 0 ) return true ; if ( $ n == 0 ) return false ; if ( $ set [ $ n - 1 ] > $ sum ) return isSubsetSum ( $ set , $ n - 1 , $ sum ) ; return isSubsetSum ( $ set , $ n - 1 , $ sum ) || isSubsetSum ( $ set , $ n - 1 , $ sum - $ set [ $ n - 1 ] ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function makePolygon ( a ) { var n = parseFloat ( 360 / ( 180 - a ) ) ; if ( n === parseInt ( n ) ) document . write ( " " ) ; else document . write ( " " ) ; }
Ref: 
function makePolygon ( $ a ) { $ n = 360 / ( 180 - $ a ) ; if ( $ n == ( int ) $ n ) echo " YES " ; else echo " NO " ; }
Hyp: 
function makePolygon ( $ a ) { $ n = ( float ) ( 360 / ( 180 - $ a ) ) ; if ( $ n == ( int ) $ n ) echo " Polygon ▁ is ▁ " ; else echo " Polygon ▁ is ▁ " ; }

BLEU: 64.46
Edit Sim: 42


Src: 
function binomialCoeff ( n , k ) { let res = 1 ; if ( k > n - k ) k = n - k ; for ( let i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; }
Ref: 
function binomialCoeff ( $ n , $ k ) { $ res = 1 ; if ( $ k > $ n - $ k ) $ k = $ n - $ k ; for ( $ i = 0 ; $ i < $ k ; ++ $ i ) { $ res *= ( $ n - $ i ) ; $ res /= ( $ i + 1 ) ; } return $ res ; }
Hyp: 
function binomialCoeff ( $ n , $ k ) { $ res = 1 ; if ( $ k > $ n - $ k ) $ k = $ n - $ k ; for ( $ i = 0 ; $ i < $ k ; ++ $ i ) { $ res *= ( $ n - $ i ) ; $ res /= ( $ i + 1 ) ; } return $ res ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function minimumBox ( arr , n ) { var q = [ ] ; arr . sort ( ( a , b ) => a - b ) q . push ( arr [ 0 ] ) ; for ( var i = 1 ; i < n ; i ++ ) { var now = q [ 0 ] ; if ( arr [ i ] >= 2 * now ) q . pop ( 0 ) ; q . push ( arr [ i ] ) ; } return q . length ; }
Ref: 
function minimumBox ( $ arr , $ n ) { $ q = array ( ) ; sort ( $ arr ) ; array_push ( $ q , $ arr [ 0 ] ) ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ now = $ q [ 0 ] ; if ( $ arr [ $ i ] >= 2 * $ now ) array_pop ( $ q ) ; array_push ( $ q , $ arr [ $ i ] ) ; } return count ( $ q ) ; }
Hyp: 
function minimumBox ( $ arr , $ n ) { $ q = array ( ) ; sort ( $ arr ) ; array_push ( $ q , $ arr [ 0 ] ) ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ now = $ q [ 0 ] ; if ( $ arr [ $ i ] >= 2 * $ now ) $ q . pop ( 0 ) ; array_push ( $ q , $ arr [ $ i ] ) ; } return $ q . length ; }

BLEU: 89.35
Edit Sim: 21


Src: 
function countIncreasing ( n ) { let cnt = 0 ; let len = 1 ; for ( let i = 0 ; i < n - 1 ; ++ i ) { if ( arr [ i + 1 ] > arr [ i ] ) len ++ ; else { cnt += ( ( ( len - 1 ) * len ) / 2 ) ; len = 1 ; } } if ( len > 1 ) cnt += ( ( ( len - 1 ) * len ) / 2 ) ; return cnt ; }
Ref: 
function countIncreasing ( $ arr , $ n ) { $ cnt = 0 ; $ len = 1 ; for ( $ i = 0 ; $ i < $ n - 1 ; ++ $ i ) { if ( $ arr [ $ i + 1 ] > $ arr [ $ i ] ) $ len ++ ; else { $ cnt += ( ( ( $ len - 1 ) * $ len ) / 2 ) ; $ len = 1 ; } } if ( $ len > 1 ) $ cnt += ( ( ( $ len - 1 ) * $ len ) / 2 ) ; return $ cnt ; }
Hyp: 
function countIncreasing ( $ n ) { $ cnt = 0 ; $ len = 1 ; for ( $ i = 0 ; $ i < $ n - 1 ; ++ $ i ) { if ( $ arr [ $ i + 1 ] > $ arr [ $ i ] ) $ len ++ ; else { $ cnt += ( ( ( $ len - 1 ) * $ len ) / 2 ) ; $ len = 1 ; } } if ( $ len > 1 ) $ cnt += ( ( ( $ len - 1 ) * $ len ) / 2 ) ; return $ cnt ; }

BLEU: 96.86
Edit Sim: 8


Src: 
function longestSubseqWithDiffOne ( arr , n ) { let dp = [ ] ; for ( let i = 0 ; i < n ; i ++ ) dp [ i ] = 1 ; for ( let i = 1 ; i < n ; i ++ ) { for ( let j = 0 ; j < i ; j ++ ) { if ( ( arr [ i ] == arr [ j ] + 1 ) || ( arr [ i ] == arr [ j ] - 1 ) ) dp [ i ] = Math . max ( dp [ i ] , dp [ j ] + 1 ) ; } } let result = 1 ; for ( let i = 0 ; i < n ; i ++ ) if ( result < dp [ i ] ) result = dp [ i ] ; return result ; }
Ref: 
function longestSubseqWithDiffOne ( $ arr , $ n ) { $ dp [ $ n ] = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ dp [ $ i ] = 1 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ i ; $ j ++ ) { if ( ( $ arr [ $ i ] == $ arr [ $ j ] + 1 ) || ( $ arr [ $ i ] == $ arr [ $ j ] - 1 ) ) $ dp [ $ i ] = max ( $ dp [ $ i ] , $ dp [ $ j ] + 1 ) ; } } $ result = 1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ result < $ dp [ $ i ] ) $ result = $ dp [ $ i ] ; return $ result ; }
Hyp: 
function longestSubseqWithDiffOne ( $ arr , $ n ) { $ dp = array ( ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ dp [ $ i ] = 1 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ i ; $ j ++ ) if ( ( $ arr [ $ i ] == $ arr [ $ j ] + 1 ) || ( $ arr [ $ i ] == $ arr [ $ j ] - 1 ) ) $ dp [ $ i ] = max ( $ dp [ $ i ] , $ dp [ $ j ] + 1 ) ; $ result = 1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ result < $ dp [ $ i ] ) $ result = $ dp [ $ i ] ; return $ result ; }

BLEU: 91.86
Edit Sim: 16


Src: 
function closestNumber ( n , m ) { let q = parseInt ( n / m ) ; let n1 = m * q ; let n2 = ( n * m ) > 0 ? ( m * ( q + 1 ) ) : ( m * ( q - 1 ) ) ; if ( Math . abs ( n - n1 ) < Math . abs ( n - n2 ) ) return n1 ; return n2 ; }
Ref: 
function closestNumber ( $ n , $ m ) { $ q = ( int ) ( $ n / $ m ) ; $ n1 = $ m * $ q ; $ n2 = ( $ n * $ m ) > 0 ? ( $ m * ( $ q + 1 ) ) : ( $ m * ( $ q - 1 ) ) ; if ( abs ( $ n - $ n1 ) < abs ( $ n - $ n2 ) ) return $ n1 ; return $ n2 ; }
Hyp: 
function closestNumber ( $ n , $ m ) { $ q = ( int ) ( $ n / $ m ) ; $ n1 = $ m * $ q ; $ n2 = ( $ n * $ m ) > 0 ? ( $ m * ( $ q + 1 ) ) : ( $ m * ( $ q - 1 ) ) ; if ( abs ( $ n - $ n1 ) < abs ( $ n - $ n2 ) ) return $ n1 ; return $ n2 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function problemsLeft ( K , P , N ) { if ( K <= P ) return 0 ; else return ( K - P ) * N ; }
Ref: 
function problemsLeft ( $ K , $ P , $ N ) { if ( $ K <= $ P ) return 0 ; else return ( $ K - $ P ) * $ N ; }
Hyp: 
function problemsLeft ( $ K , $ P , $ N ) { if ( $ K <= $ P ) return 0 ; else return ( $ K - $ P ) * $ N ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function section ( x1 , x2 , y1 , y2 , z1 , z2 , m , n ) { let x = ( ( m * x2 ) + ( n * x1 ) ) / ( m + n ) ; let y = ( ( m * y2 ) + ( n * y1 ) ) / ( m + n ) ; let z = ( ( m * z2 ) + ( n * z1 ) ) / ( m + n ) ; document . write ( " " + x + " " ) ; document . write ( y + " " ) ; document . write ( z + " " ) ; }
Ref: 
function section ( $ x1 , $ x2 , $ y1 , $ y2 , $ z1 , $ z2 , $ m , $ n ) { $ x = ( ( $ m * $ x2 ) + ( $ n * $ x1 ) ) / ( $ m + $ n ) ; $ y = ( ( $ m * $ y2 ) + ( $ n * $ y1 ) ) / ( $ m + $ n ) ; $ z = ( ( $ m * $ z2 ) + ( $ n * $ z1 ) ) / ( $ m + $ n ) ; echo " ( " . $ x . " , " ; ▁ echo ▁ $ y ▁ . ▁ " , " ; ▁ echo ▁ $ z ▁ . ▁ " ) " ▁ . " " }
Hyp: 
function section ( $ x1 , $ x2 , $ y1 , $ y2 , $ z1 , $ z2 , $ m , $ n ) { $ x = ( ( $ m * $ x2 ) + ( $ n * $ x1 ) ) / ( $ m + $ n ) ; $ y = ( ( $ m * $ y2 ) + ( $ n * $ y1 ) ) / ( $ m + $ n ) ; $ z = ( ( $ m * $ z2 ) + ( $ n * $ z1 ) ) / ( $ m + $ n ) ; echo " x = " ▁ , ▁ $ x ▁ , ▁ " ; echo $ y . " , ▁ " ; echo $ z . " STRNEWLINE " ; }

BLEU: 81.31
Edit Sim: 38


Src: 
function findValue ( X , Y , P ) { if ( P % 2 == 0 ) return parseInt ( ( Math . max ( X , Y ) / Math . min ( X , Y ) ) , 10 ) ; else return parseInt ( ( Math . max ( 2 * X , Y ) / Math . min ( 2 * X , Y ) ) , 10 ) ; }
Ref: 
function findValue ( $ X , $ Y , $ P ) { if ( $ P % 2 == 0 ) return ( int ) ( max ( $ X , $ Y ) / min ( $ X , $ Y ) ) ; else return ( int ) ( max ( 2 * $ X , $ Y ) / min ( 2 * $ X , $ Y ) ) ; }
Hyp: 
function findValue ( $ X , $ Y , $ P ) { if ( $ P % 2 == 0 ) return ( int ) ( max ( $ X , $ Y ) / min ( $ X , $ Y ) ) ; else return ( int ) ( max ( 2 * $ X , $ Y ) / min ( 2 * $ X , $ Y ) ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function weightedMean ( X , W , n ) { let sum = 0 , numWeight = 0 ; for ( let i = 0 ; i < n ; i ++ ) { numWeight = numWeight + X [ i ] * W [ i ] ; sum = sum + W [ i ] ; } return ( numWeight ) / sum ; }
Ref: 
function weightedMean ( $ X , $ W , $ n ) { $ sum = 0 ; $ numWeight = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ numWeight = $ numWeight + $ X [ $ i ] * $ W [ $ i ] ; $ sum = $ sum + $ W [ $ i ] ; } return ( float ) ( $ numWeight / $ sum ) ; }
Hyp: 
function weightedMean ( $ X , $ W , $ n ) { $ sum = 0 ; $ numWeight = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ numWeight = $ numWeight + $ X [ $ i ] * $ W [ $ i ] ; $ sum = $ sum + $ W [ $ i ] ; } return ( $ numWeight ) / $ sum ; }

BLEU: 91.56
Edit Sim: 14


Src: 
function gcd ( a , b ) { if ( a == 0 ) return b ; if ( b == 0 ) return a ; if ( a == b ) return a ; if ( a > b ) return gcd ( a - b , b ) ; return gcd ( a , b - a ) ; }
Ref: 
function gcd ( $ a , $ b ) { if ( $ a == 0 ) return $ b ; if ( $ b == 0 ) return $ a ; if ( $ a == $ b ) return $ a ; if ( $ a > $ b ) return gcd ( $ a - $ b , $ b ) ; return gcd ( $ a , $ b - $ a ) ; }
Hyp: 
function gcd ( $ a , $ b ) { if ( $ a == 0 ) return $ b ; if ( $ b == 0 ) return $ a ; if ( $ a == $ b ) return $ a ; if ( $ a > $ b ) return gcd ( $ a - $ b , $ b ) ; return gcd ( $ a , $ b - $ a ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function nthTerm ( n ) { return 4 * Math . pow ( n , 2 ) - 7 * n + 3 ; }
Ref: 
function nthTerm ( $ n ) { return 4 * pow ( $ n , 2 ) - 7 * $ n + 3 ; }
Hyp: 
function nthTerm ( $ n ) { return 4 * pow ( $ n , 2 ) - 7 * $ n + 3 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function last_digit ( X , Y ) { document . write ( X % Y ) ; }
Ref: 
function last_digit ( $ X , $ Y ) { echo ( $ X % $ Y ) ; }
Hyp: 
function last_digit ( $ X , $ Y ) { echo $ X % $ Y ; }

BLEU: 73.99
Edit Sim: 4


Src: 
function ceilSearch ( arr , low , high , x ) { let i ; if ( x <= arr [ low ] ) return low ; for ( i = low ; i < high ; i ++ ) { if ( arr [ i ] == x ) return i ; if ( arr [ i ] < x && arr [ i + 1 ] >= x ) return i + 1 ; } return - 1 ; }
Ref: 
function ceilSearch ( $ arr , $ low , $ high , $ x ) { if ( $ x <= $ arr [ $ low ] ) return $ low ; for ( $ i = $ low ; $ i < $ high ; $ i ++ ) { if ( $ arr [ $ i ] == $ x ) return $ i ; if ( $ arr [ $ i ] < $ x && $ arr [ $ i + 1 ] >= $ x ) return $ i + 1 ; } return -1 ; }
Hyp: 
function ceilSearch ( $ arr , $ low , $ high , $ x ) { if ( $ x <= $ arr [ $ low ] ) return $ low ; for ( $ i = $ low ; $ i < $ high ; $ i ++ ) { if ( $ arr [ $ i ] == $ x ) return $ i ; if ( $ arr [ $ i ] < $ x && $ arr [ $ i + 1 ] >= $ x ) return $ i + 1 ; } return -1 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function getPeriod ( n ) { let rem = 1 ; for ( let i = 1 ; i <= n + 1 ; i ++ ) rem = ( 10 * rem ) % n ; let d = rem ; let count = 0 ; do { rem = ( 10 * rem ) % n ; count ++ ; } while ( rem != d ) ; return count ; }
Ref: 
function getPeriod ( $ n ) { $ rem = 1 ; for ( $ i = 1 ; $ i <= $ n + 1 ; $ i ++ ) $ rem = ( 10 * $ rem ) % $ n ; $ d = $ rem ; $ count = 0 ; do { $ rem = ( 10 * $ rem ) % $ n ; $ count ++ ; } while ( $ rem != $ d ) ; return $ count ; }
Hyp: 
function getPeriod ( $ n ) { $ rem = 1 ; for ( $ i = 1 ; $ i <= $ n + 1 ; $ i ++ ) $ rem = ( 10 * $ rem ) % $ n ; $ d = $ rem ; $ count = 0 ; do { $ rem = ( 10 * $ rem ) % $ n ; $ count ++ ; } while ( $ rem != $ d ) ; return $ count ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function rhombusarea ( l , b ) { if ( l < 0 b < 0 ) return - 1 ; return ( l * b ) / 2 ; }
Ref: 
function rhombusarea ( $ l , $ b ) { if ( $ l < 0 $ b < 0 ) return -1 ; return ( $ l * $ b ) / 2 ; }
Hyp: 
function rhombusarea ( $ l , $ b ) { if ( $ l < 0 $ b < 0 ) return -1 ; return ( $ l * $ b ) / 2 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function search ( arr , n , x ) { if ( arr [ n - 1 ] == x ) return " " ; let backup = arr [ n - 1 ] ; arr [ n - 1 ] = x ; for ( let i = 0 ; ; i ++ ) { if ( arr [ i ] == x ) { arr [ n - 1 ] = backup ; if ( i < n - 1 ) return " " ; return " " ; } } }
Ref: 
function search ( $ arr , $ n , $ x ) { if ( $ arr [ $ n - 1 ] == $ x ) return " Found " ; $ backup = $ arr [ $ n - 1 ] ; $ arr [ $ n - 1 ] = $ x ; for ( $ i = 0 ; ; $ i ++ ) { if ( $ arr [ $ i ] == $ x ) { $ arr [ $ n - 1 ] = $ backup ; if ( $ i < $ n - 1 ) return " Found " ; return " Not ▁ Found " ; } } }
Hyp: 
function search ( & $ arr , $ n , $ x ) { if ( $ arr [ $ n - 1 ] == $ x ) return " Yes " ; $ backup = $ arr [ $ n - 1 ] ; $ arr [ $ n - 1 ] = $ x ; for ( $ i = 0 ; ; $ i ++ ) { if ( $ arr [ $ i ] == $ x ) { $ arr [ $ n - 1 ] = $ backup ; if ( $ i < $ n - 1 ) return " No " ; return " " ; } } }

BLEU: 90.59
Edit Sim: 23


Src: 
function printRepeating ( arr , size ) { let count = new Array ( size ) ; count . fill ( 0 ) ; let i ; document . write ( " " ) ; for ( i = 0 ; i < size ; i ++ ) { if ( count [ arr [ i ] ] == 1 ) document . write ( arr [ i ] + " " ) ; else count [ arr [ i ] ] ++ ; } }
Ref: 
function printRepeating ( $ arr , $ size ) { $ count = array_fill ( 0 , $ size , 0 ) ; echo " Repeated ▁ elements ▁ are ▁ " ; for ( $ i = 0 ; $ i < $ size ; $ i ++ ) { if ( $ count [ $ arr [ $ i ] ] == 1 ) echo $ arr [ $ i ] . " ▁ " ; else $ count [ $ arr [ $ i ] ] ++ ; } }
Hyp: 
function printRepeating ( $ arr , $ size ) { $ count = array_fill ( 0 , $ size , 0 ) ; for ( $ i = 0 ; $ i < $ size ; $ i ++ ) { if ( $ count [ $ arr [ $ i ] ] == 1 ) echo $ arr [ $ i ] . " ▁ " ; else $ count [ $ arr [ $ i ] ] ++ ; } }

BLEU: 87.83
Edit Sim: 39


Src: 
function find_Area ( r ) { return ( 2 * r * r ) ; }
Ref: 
function find_Area ( $ r ) { return ( 2 * $ r * $ r ) ; }
Hyp: 
function find_Area ( $ r ) { return ( 2 * $ r * $ r ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function getNthTerm ( N ) { return ( Math . pow ( N , 2 ) + N + 1 ) ; }
Ref: 
function getNthTerm ( $ N ) { return ( pow ( $ N , 2 ) + $ N + 1 ) ; }
Hyp: 
function getNthTerm ( $ N ) { return ( pow ( $ N , 2 ) + $ N + 1 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countPS ( str ) { let N = str . length ; let cps = new Array ( N ) ; for ( let i = 0 ; i < N ; i ++ ) { cps [ i ] = new Array ( N ) ; for ( let j = 0 ; j < N ; j ++ ) { cps [ i ] [ j ] = 0 ; } } for ( let i = 0 ; i < N ; i ++ ) cps [ i ] [ i ] = 1 ; for ( let L = 2 ; L <= N ; L ++ ) { for ( let i = 0 ; i <= N - L ; i ++ ) { let k = L + i - 1 ; if ( str [ i ] == str [ k ] ) { cps [ i ] [ k ] = cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] + 1 ; } else { cps [ i ] [ k ] = cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] - cps [ i + 1 ] [ k - 1 ] ; } } } return cps [ 0 ] [ N - 1 ] ; }
Ref: 
function countPS ( $ str ) { $ N = strlen ( $ str ) ; $ cps = array_fill ( 0 , $ N + 1 , array_fill ( 0 , $ N + 1 , NULL ) ) ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) $ cps [ $ i ] [ $ i ] = 1 ; for ( $ L = 2 ; $ L <= $ N ; $ L ++ ) { for ( $ i = 0 ; $ i <= $ N - $ L ; $ i ++ ) { $ k = $ L + $ i - 1 ; if ( $ str [ $ i ] == $ str [ $ k ] ) $ cps [ $ i ] [ $ k ] = $ cps [ $ i ] [ $ k - 1 ] + $ cps [ $ i + 1 ] [ $ k ] + 1 ; else $ cps [ $ i ] [ $ k ] = $ cps [ $ i ] [ $ k - 1 ] + $ cps [ $ i + 1 ] [ $ k ] - $ cps [ $ i + 1 ] [ $ k - 1 ] ; } } return $ cps [ 0 ] [ $ N - 1 ] ; }
Hyp: 
function countPS ( $ str ) { $ N = strlen ( $ str ) ; $ cps = array_fill ( 0 , $ N , NULL ) ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) $ cps [ $ i ] [ $ i ] = 1 ; for ( $ L = 2 ; $ L <= $ N ; $ L ++ ) { for ( $ i = 0 ; $ i <= $ N - $ L ; $ i ++ ) { $ k = $ L + $ i - 1 ; if ( $ str [ $ i ] == $ str [ $ k ] ) { $ cps [ $ i ] [ $ k ] = $ cps [ $ i ] [ $ k - 1 ] + $ cps [ $ i + 1 ] [ $ k ] + 1 ; } else { $ cps [ $ i ] [ $ k ] = $ cps [ $ i ] [ $ k - 1 ] + $ cps [ $ i + 1 ] [ $ k ] - $ cps [ $ i + 1 ] [ $ k - 1 ] ; } } } return $ cps [ 0 ] [ $ N - 1 ] ; }

BLEU: 92.46
Edit Sim: 41


Src: 
function magicOfSequence ( N ) { return ( N * ( N + 1 ) / 2 ) + 2 * N ; }
Ref: 
function magicOfSequence ( $ N ) { return ( $ N * ( $ N + 1 ) / 2 ) + 2 * $ N ; }
Hyp: 
function magicOfSequence ( $ N ) { return ( $ N * ( $ N + 1 ) / 2 ) + 2 * $ N ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function mod ( num , a ) { let res = 0 ; for ( let i = 0 ; i < num . length ; i ++ ) res = ( res * 10 + num [ i ] - ' ' ) % a ; return res ; }
Ref: 
function mod ( $ num , $ a ) { $ res = 0 ; for ( $ i = 0 ; $ i < $ r = strlen ( $ num ) ; $ i ++ ) $ res = ( $ res * 10 + $ num [ $ i ] - '0' ) % $ a ; return $ res ; }
Hyp: 
function mod ( $ num , $ a ) { $ res = 0 ; for ( $ i = 0 ; $ i < strlen ( $ num ) ; $ i ++ ) $ res = ( $ res * 10 + $ num [ $ i ] - '0' ) % $ a ; return $ res ; }

BLEU: 92.9
Edit Sim: 6


Src: 
function ReplaceElements ( arr , n ) { if ( n <= 1 ) return ; let prev = arr [ 0 ] ; arr [ 0 ] = arr [ 0 ] ^ arr [ 1 ] ; for ( let i = 1 ; i < n - 1 ; i ++ ) { let curr = arr [ i ] ; arr [ i ] = prev ^ arr [ i + 1 ] ; prev = curr ; } arr [ n - 1 ] = prev ^ arr [ n - 1 ] ; }
Ref: 
function ReplaceElements ( & $ arr , $ n ) { if ( $ n <= 1 ) return ; $ prev = $ arr [ 0 ] ; $ arr [ 0 ] = $ arr [ 0 ] ^ $ arr [ 1 ] ; for ( $ i = 1 ; $ i < $ n - 1 ; $ i ++ ) { $ curr = $ arr [ $ i ] ; $ arr [ $ i ] = $ prev ^ $ arr [ $ i + 1 ] ; $ prev = $ curr ; } $ arr [ $ n - 1 ] = $ prev ^ $ arr [ $ n - 1 ] ; }
Hyp: 
function ReplaceElements ( & $ arr , $ n ) { if ( $ n <= 1 ) return ; $ prev = $ arr [ 0 ] ; $ arr [ 0 ] = $ arr [ 0 ] ^ $ arr [ 1 ] ; for ( $ i = 1 ; $ i < $ n - 1 ; $ i ++ ) { $ curr = $ arr [ $ i ] ; $ arr [ $ i ] = $ prev ^ $ arr [ $ i + 1 ] ; $ prev = $ curr ; } $ arr [ $ n - 1 ] = $ prev ^ $ arr [ $ n - 1 ] ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function prevGreater ( arr , n ) { document . write ( " " ) ; for ( let i = 1 ; i < n ; i ++ ) { let j ; for ( j = i - 1 ; j >= 0 ; j -- ) { if ( arr [ i ] < arr [ j ] ) { document . write ( arr [ j ] + " " ) ; break ; } } if ( j == - 1 ) document . write ( " " ) ; } }
Ref: 
function prevGreater ( & $ arr , $ n ) { echo ( " - 1 , ▁ " ) ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { for ( $ j = $ i - 1 ; $ j >= 0 ; $ j -- ) { if ( $ arr [ $ i ] < $ arr [ $ j ] ) { echo ( $ arr [ $ j ] ) ; echo ( " , ▁ " ) ; break ; } } if ( $ j == -1 ) echo ( " - 1 , ▁ " ) ; } }
Hyp: 
function prevGreater ( & $ arr , $ n ) { echo " Following ▁ ranges ▁ are ▁ selected ▁ " . " STRNEWLINE " ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { for ( $ j = $ i - 1 ; $ j >= 0 ; $ j -- ) { if ( $ arr [ $ i ] < $ arr [ $ j ] ) { echo ( $ arr [ $ j ] . " ▁ " ) ; break ; } } if ( $ j == -1 ) echo " No " ; } }

BLEU: 78.73
Edit Sim: 72


Src: 
function isPowerOfTwo ( x ) { return x != 0 && ( ( x & ( x - 1 ) ) == 0 ) ; }
Ref: 
function isPowerOfTwo ( $ x ) { return $ x && ( ! ( $ x & ( $ x - 1 ) ) ) ; }
Hyp: 
function isPowerOfTwo ( $ x ) { return $ x != 0 && ( ( $ x & ( $ x - 1 ) ) == 0 ) ; }

BLEU: 70.71
Edit Sim: 12


Src: 
function rotateRec ( n , L , B ) { var m = Number . MAX_VALUE for ( var i = 0 ; i < n ; i ++ ) { if ( Math . max ( L [ i ] , B [ i ] ) <= m ) m = Math . max ( L [ i ] , B [ i ] ) ; else if ( Math . min ( L [ i ] , B [ i ] ) <= m ) m = Math . min ( L [ i ] , B [ i ] ) ; else { return 0 ; } } return 1 ; }
Ref: 
function rotateRec ( $ n , $ L , $ B ) { $ m = PHP_INT_MAX ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( max ( $ L [ $ i ] , $ B [ $ i ] ) <= $ m ) $ m = max ( $ L [ $ i ] , $ B [ $ i ] ) ; else if ( min ( $ L [ $ i ] , $ B [ $ i ] ) <= $ m ) $ m = min ( $ L [ $ i ] , $ B [ $ i ] ) ; else { return 0 ; } } return 1 ; }
Hyp: 
function rotateRec ( $ n , $ L , $ B ) { $ m = PHP_INT_MAX ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( max ( $ L [ $ i ] , $ B [ $ i ] ) <= $ m ) $ m = max ( $ L [ $ i ] , $ B [ $ i ] ) ; else if ( min ( $ L [ $ i ] , $ B [ $ i ] ) <= $ m ) $ m = min ( $ L [ $ i ] , $ B [ $ i ] ) ; else { return 0 ; } } return 1 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function print_result ( a , n , k , m ) { var v = Array . from ( Array ( m ) , ( ) => Array ( ) ) ; for ( var i = 0 ; i < n ; i ++ ) { var rem = a [ i ] % m ; v [ rem ] . push ( a [ i ] ) ; if ( v [ rem ] . length == k ) { for ( var j = 0 ; j < k ; j ++ ) document . write ( v [ rem ] [ j ] + " " ) ; return ; } } document . write ( " " ) ; }
Ref: 
function print_result ( $ a , $ n , $ k , $ m ) { $ v = array_fill ( 0 , $ m + 1 , array ( ) ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ rem = $ a [ $ i ] % $ m ; array_push ( $ v [ $ rem ] , $ a [ $ i ] ) ; if ( count ( $ v [ $ rem ] ) == $ k ) { for ( $ j = 0 ; $ j < $ k ; $ j ++ ) echo $ v [ $ rem ] [ $ j ] . " ▁ " ; return ; } } echo " - 1" ; }
Hyp: 
function print_result ( $ a , $ n , $ k , $ m ) { $ v ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ rem = $ a [ $ i ] % $ m ; $ v [ $ rem ] . push ( $ a [ $ i ] ) ; if ( $ v [ $ rem ] . length == $ k ) { for ( $ j = 0 ; $ j < $ k ; $ j ++ ) echo $ v [ $ rem ] [ $ j ] . " ▁ " ; return ; } } echo " No " ; }

BLEU: 78.18
Edit Sim: 81


Src: 
function sumofproduct ( n ) { var ans = 0 ; for ( x = 1 ; x <= n ; x ++ ) { var y = parseInt ( n / x ) ; ans += ( y * x ) ; } return ans ; }
Ref: 
function sumofproduct ( $ n ) { $ ans = 0 ; for ( $ x = 1 ; $ x <= $ n ; $ x ++ ) { $ y = ( int ) ( $ n / $ x ) ; $ ans += ( $ y * $ x ) ; } return $ ans ; }
Hyp: 
function sumofproduct ( $ n ) { $ ans = 0 ; for ( $ x = 1 ; $ x <= $ n ; $ x ++ ) { $ y = ( int ) ( $ n / $ x ) ; $ ans += ( $ y * $ x ) ; } return $ ans ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function printDivisors ( n ) { for ( let i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( parseInt ( n / i , 10 ) == i ) document . write ( i ) ; else document . write ( i + " " + parseInt ( n / i , 10 ) + " " ) ; } } }
Ref: 
function printDivisors ( $ n ) { for ( $ i = 1 ; $ i <= sqrt ( $ n ) ; $ i ++ ) { if ( $ n % $ i == 0 ) { if ( $ n / $ i == $ i ) echo $ i , " ▁ " ; else echo $ i , " ▁ " , $ n / $ i , " ▁ " ; } } }
Hyp: 
function printDivisors ( $ n ) { for ( $ i = 1 ; $ i <= sqrt ( $ n ) ; $ i ++ ) { if ( $ n % $ i == 0 ) { if ( ( int ) $ n / $ i == $ i ) echo $ i ; else echo $ i . " , ▁ " . $ n / $ i . " STRNEWLINE " ; } } }

BLEU: 79.01
Edit Sim: 31


Src: 
function findSubsequenceCount ( S , T ) { let m = T . length ; let n = S . length ; if ( m > n ) return 0 ; let mat = new Array ( m + 1 ) ; for ( let i = 0 ; i <= m ; i ++ ) { mat [ i ] = new Array ( n + 1 ) ; for ( let j = 0 ; j <= n ; j ++ ) { mat [ i ] [ j ] = 0 ; } } for ( let i = 1 ; i <= m ; i ++ ) mat [ i ] [ 0 ] = 0 ; for ( let j = 0 ; j <= n ; j ++ ) mat [ 0 ] [ j ] = 1 ; for ( let i = 1 ; i <= m ; i ++ ) { for ( let j = 1 ; j <= n ; j ++ ) { if ( T [ i - 1 ] != S [ j - 1 ] ) mat [ i ] [ j ] = mat [ i ] [ j - 1 ] ; else mat [ i ] [ j ] = mat [ i ] [ j - 1 ] + mat [ i - 1 ] [ j - 1 ] ; } } return mat [ m ] [ n ] ; }
Ref: 
function findSubsequenceCount ( $ S , $ T ) { $ m = strlen ( $ T ) ; $ n = strlen ( $ S ) ; if ( $ m > $ n ) return 0 ; $ mat = array ( array ( ) ) ; for ( $ i = 1 ; $ i <= $ m ; $ i ++ ) $ mat [ $ i ] [ 0 ] = 0 ; for ( $ j = 0 ; $ j <= $ n ; $ j ++ ) $ mat [ 0 ] [ $ j ] = 1 ; for ( $ i = 1 ; $ i <= $ m ; $ i ++ ) { for ( $ j = 1 ; $ j <= $ n ; $ j ++ ) { if ( $ T [ $ i - 1 ] != $ S [ $ j - 1 ] ) $ mat [ $ i ] [ $ j ] = $ mat [ $ i ] [ $ j - 1 ] ; else $ mat [ $ i ] [ $ j ] = $ mat [ $ i ] [ $ j - 1 ] + $ mat [ $ i - 1 ] [ $ j - 1 ] ; } } return $ mat [ $ m ] [ $ n ] ; }
Hyp: 
function findSubsequenceCount ( $ S , $ T ) { $ m = strlen ( $ T ) ; $ n = strlen ( $ S ) ; if ( $ m > $ n ) return 0 ; $ mat = array_fill ( 0 , $ m + 1 , array_fill ( 0 , $ n + 1 , NULL ) ) ; for ( $ i = 0 ; $ i <= $ m ; $ i ++ ) $ mat [ $ i ] [ 0 ] = 0 ; for ( $ j = 0 ; $ j <= $ n ; $ j ++ ) $ mat [ 0 ] [ $ j ] = 1 ; for ( $ i = 1 ; $ i <= $ m ; $ i ++ ) { for ( $ j = 1 ; $ j <= $ n ; $ j ++ ) { if ( $ T [ $ i - 1 ] != $ S [ $ j - 1 ] ) $ mat [ $ i ] [ $ j ] = $ mat [ $ i ] [ $ j - 1 ] ; else $ mat [ $ i ] [ $ j ] = $ mat [ $ i ] [ $ j - 1 ] + $ mat [ $ i - 1 ] [ $ j - 1 ] ; } } return $ mat [ $ m ] [ $ n ] ; }

BLEU: 91.31
Edit Sim: 44


Src: 
function counLastDigitK ( low , high , k ) { let count = 0 ; for ( let i = low ; i <= high ; i ++ ) if ( i % 10 == k ) count ++ ; return count ; }
Ref: 
function counLastDigitK ( $ low , $ high , $ k ) { $ count = 0 ; for ( $ i = $ low ; $ i <= $ high ; $ i ++ ) if ( $ i % 10 == $ k ) $ count ++ ; return $ count ; }
Hyp: 
function counLastDigitK ( $ low , $ high , $ k ) { $ count = 0 ; for ( $ i = $ low ; $ i <= $ high ; $ i ++ ) if ( $ i % 10 == $ k ) $ count ++ ; return $ count ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function subtract ( x , y ) { while ( y != 0 ) { let borrow = ( ~ x ) & y ; x = x ^ y ; y = borrow << 1 ; } return x ; }
Ref: 
function subtract ( $ x , $ y ) { while ( $ y != 0 ) { $ borrow = ( ~ $ x ) & $ y ; $ x = $ x ^ $ y ; $ y = $ borrow << 1 ; } return $ x ; }
Hyp: 
function subtract ( $ x , $ y ) { while ( $ y != 0 ) { $ borrow = ( ~ $ x ) & $ y ; $ x = $ x ^ $ y ; $ y = $ borrow << 1 ; } return $ x ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findOddPair ( A , N ) { var i , j ; var oddPair = 0 ; for ( i = 0 ; i < N ; i ++ ) { for ( j = i + 1 ; j < N ; j ++ ) { if ( ( A [ i ] & A [ j ] ) % 2 != 0 ) oddPair ++ ; } } return oddPair ; }
Ref: 
function findOddPair ( & $ A , $ N ) { $ oddPair = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ N ; $ j ++ ) { if ( ( $ A [ $ i ] & $ A [ $ j ] ) % 2 != 0 ) $ oddPair = $ oddPair + 1 ; } } return $ oddPair ; }
Hyp: 
function findOddPair ( $ A , $ N ) { $ oddPair = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ N ; $ j ++ ) { if ( ( $ A [ $ i ] & $ A [ $ j ] ) % 2 != 0 ) $ oddPair ++ ; } } return $ oddPair ; }

BLEU: 89.98
Edit Sim: 16


Src: 
function printSubsequences ( arr , n ) { let opsize = parseInt ( Math . pow ( 2 , n ) , 10 ) ; for ( let counter = 1 ; counter < opsize ; counter ++ ) { for ( let j = 0 ; j < n ; j ++ ) { if ( ( counter & ( 1 << j ) ) != 0 ) document . write ( arr [ j ] + " " ) ; } document . write ( " " ) ; } }
Ref: 
function printSubsequences ( $ arr , $ n ) { $ opsize = pow ( 2 , $ n ) ; for ( $ counter = 1 ; $ counter < $ opsize ; $ counter ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ counter & ( 1 << $ j ) ) echo $ arr [ $ j ] , " ▁ " ; } echo " STRNEWLINE " ; } }
Hyp: 
function printSubsequences ( $ arr , $ n ) { $ opsize = pow ( 2 , $ n ) ; for ( $ counter = 1 ; $ counter < $ opsize ; $ counter ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( ( $ counter & ( 1 << $ j ) ) != 0 ) echo $ arr [ $ j ] . " ▁ " ; } echo " STRNEWLINE " ; } }

BLEU: 91.26
Edit Sim: 10


Src: 
function getMinSquares ( n ) { if ( n <= 3 ) return n ; let res = n ; for ( let x = 1 ; x <= n ; x ++ ) { let temp = x * x ; if ( temp > n ) break ; else res = Math . min ( res , 1 + getMinSquares ( n - temp ) ) ; } return res ; }
Ref: 
function getMinSquares ( $ n ) { if ( $ n <= 3 ) return $ n ; $ res = $ n ; for ( $ x = 1 ; $ x <= $ n ; $ x ++ ) { $ temp = $ x * $ x ; if ( $ temp > $ n ) break ; else $ res = min ( $ res , 1 + getMinSquares ( $ n - $ temp ) ) ; } return $ res ; }
Hyp: 
function getMinSquares ( $ n ) { if ( $ n <= 3 ) return $ n ; $ res = $ n ; for ( $ x = 1 ; $ x <= $ n ; $ x ++ ) { $ temp = $ x * $ x ; if ( $ temp > $ n ) break ; else $ res = min ( $ res , 1 + getMinSquares ( $ n - $ temp ) ) ; } return $ res ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function firstDigit ( n ) { let fact = 1 ; for ( let i = 2 ; i <= n ; i ++ ) { fact = fact * i ; while ( fact % 10 == 0 ) fact = fact / 10 ; } while ( fact >= 10 ) fact = fact / 10 ; return ( Math . round ( fact ) ) ; }
Ref: 
function firstDigit ( $ n ) { $ fact = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { $ fact = $ fact * $ i ; while ( $ fact % 10 == 0 ) $ fact = $ fact / 10 ; } while ( $ fact >= 10 ) $ fact = $ fact / 10 ; return floor ( $ fact ) ; }
Hyp: 
function firstDigit ( $ n ) { $ fact = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { $ fact = $ fact * $ i ; while ( $ fact % 10 == 0 ) $ fact = $ fact / 10 ; } while ( $ fact >= 10 ) $ fact = $ fact / 10 ; return ( floor ( $ fact ) ) ; }

BLEU: 94.72
Edit Sim: 4


Src: 
function findSum ( n ) { n -- ; let sum = 0 ; sum += ( n * ( n + 1 ) ) / 2 ; sum += ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; return sum ; }
Ref: 
function findSum ( $ n ) { $ n -- ; $ sum = 0 ; $ sum += ( $ n * ( $ n + 1 ) ) / 2 ; $ sum += ( $ n * ( $ n + 1 ) * ( 2 * $ n + 1 ) ) / 6 ; return $ sum ; }
Hyp: 
function findSum ( $ n ) { $ n -- ; $ sum = 0 ; $ sum += ( $ n * ( $ n + 1 ) ) / 2 ; $ sum += ( $ n * ( $ n + 1 ) * ( 2 * $ n + 1 ) ) / 6 ; return $ sum ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function getCount ( a , b , c ) { let count = 0 ; for ( let i = 1 ; i <= 81 ; i ++ ) { let cr = b * Math . pow ( i , a ) + c ; let tmp = cr ; let sm = 0 ; while ( tmp != 0 ) { sm += tmp % 10 ; tmp = Math . floor ( tmp / 10 ) ; } if ( sm == i && cr < 1e9 ) count ++ ; } return count ; }
Ref: 
function getCount ( $ a , $ b , $ c ) { $ count = 0 ; for ( $ i = 1 ; $ i <= 81 ; $ i ++ ) { $ cr = $ b * ( int ) pow ( $ i , $ a ) + $ c ; $ tmp = $ cr ; $ sm = 0 ; while ( $ tmp != 0 ) { $ sm += $ tmp % 10 ; $ tmp /= 10 ; } if ( $ sm == $ i && $ cr < 1e9 ) $ count ++ ; } return $ count ; } { $ a = 3 ; $ b = 2 ; $ c = 8 ; echo ( getCount ( $ a , $ b , $ c ) ) ; }
Hyp: 
function getCount ( $ a , $ b , $ c ) { $ count = 0 ; for ( $ i = 1 ; $ i <= 81 ; $ i ++ ) { $ cr = $ b * pow ( $ i , $ a ) + $ c ; $ tmp = $ cr ; $ sm = 0 ; while ( $ tmp != 0 ) { $ sm += $ tmp % 10 ; $ tmp = $ tmp / 10 ; } if ( $ sm == $ i && $ cr < 1e9 ) $ count ++ ; } return $ count ; }

BLEU: 70.72
Edit Sim: 91


Src: 
function subtract ( x , y ) { if ( y == 0 ) return x ; return subtract ( x ^ y , ( ~ x & y ) << 1 ) ; }
Ref: 
function subtract ( $ x , $ y ) { if ( $ y == 0 ) return $ x ; return subtract ( $ x ^ $ y , ( ~ $ x & $ y ) << 1 ) ; }
Hyp: 
function subtract ( $ x , $ y ) { if ( $ y == 0 ) return $ x ; return subtract ( $ x ^ $ y , ( ~ $ x & $ y ) << 1 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countNumbers ( N ) { return parseInt ( Math . sqrt ( N ) , 10 ) - 1 ; }
Ref: 
function countNumbers ( $ N ) { return ( int ) ( sqrt ( $ N ) ) - 1 ; }
Hyp: 
function countNumbers ( $ N ) { return ( int ) sqrt ( $ N ) - 1 ; }

BLEU: 78.89
Edit Sim: 4


Src: 
function ASCIISentence ( str ) { let l = str . length ; let convert ; for ( let i = 0 ; i < l ; i ++ ) { convert = str [ i ] . charCodeAt ( 0 ) ; document . write ( convert ) ; } }
Ref: 
function ASCIISentence ( $ str ) { for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) echo ord ( $ str [ $ i ] ) ; }
Hyp: 
function ASCIISentence ( $ str ) { $ l = strlen ( $ str ) ; for ( $ i = 0 ; $ i < $ l ; $ i ++ ) { $ convert = ord ( $ str [ $ i ] ) ; print ( $ convert ) ; } }

BLEU: 57.78
Edit Sim: 69


Src: 
function countToMake0lternate ( s ) { let result = 0 ; for ( let i = 0 ; i < ( s . length - 1 ) ; i ++ ) if ( s [ i ] == s [ i + 1 ] ) return result ; }
Ref: 
function countToMake0lternate ( $ s ) { $ result = 0 ; for ( $ i = 0 ; $ i < ( strlen ( $ s ) - 1 ) ; $ i ++ ) if ( $ s [ $ i ] == $ s [ $ i + 1 ] ) $ result ++ ; return $ result ; }
Hyp: 
function countToMake0lternate ( $ s ) { $ result = 0 ; for ( $ i = 0 ; $ i < ( strlen ( $ s ) - 1 ) ; $ i ++ ) if ( $ s [ $ i ] == $ s [ $ i + 1 ] ) $ result ++ ; return $ result ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function minAdjDifference ( arr , n ) { if ( n < 2 ) return ; let res = Math . abs ( arr [ 1 ] - arr [ 0 ] ) ; for ( let i = 2 ; i < n ; i ++ ) res = Math . min ( res , Math . abs ( arr [ i ] - arr [ i - 1 ] ) ) ; res = Math . min ( res , Math . abs ( arr [ n - 1 ] - arr [ 0 ] ) ) ; document . write ( " " + res ) ; }
Ref: 
function minAdjDifference ( $ arr , $ n ) { if ( $ n < 2 ) return ; $ res = abs ( $ arr [ 1 ] - $ arr [ 0 ] ) ; for ( $ i = 2 ; $ i < $ n ; $ i ++ ) $ res = min ( $ res , abs ( $ arr [ $ i ] - $ arr [ $ i - 1 ] ) ) ; $ res = min ( $ res , abs ( $ arr [ $ n - 1 ] - $ arr [ 0 ] ) ) ; echo " Min ▁ Difference ▁ = ▁ " , $ res ; }
Hyp: 
function minAdjDifference ( $ arr , $ n ) { if ( $ n < 2 ) return ; $ res = abs ( $ arr [ 1 ] - $ arr [ 0 ] ) ; for ( $ i = 2 ; $ i < $ n ; $ i ++ ) $ res = min ( $ res , abs ( $ arr [ $ i ] - $ arr [ $ i - 1 ] ) ) ; $ res = min ( $ res , abs ( $ arr [ $ n - 1 ] - $ arr [ 0 ] ) ) ; echo " Minimum ▁ adjDifference ▁ is ▁ " , $ res ; }

BLEU: 95.08
Edit Sim: 9


Src: 
function printSubsequences ( s ) { let str = s . split ( ' ' ) ; let n = str . length ; let opsize = Math . pow ( 2 , n - 1 ) ; for ( let counter = 0 ; counter < opsize ; counter ++ ) { for ( let j = 0 ; j < n ; j ++ ) { document . write ( str [ j ] ) ; if ( ( counter & ( 1 << j ) ) > 0 ) document . write ( " " ) ; } document . write ( " " ) ; } }
Ref: 
function printSubsequences ( $ str ) { $ n = strlen ( $ str ) ; $ opsize = pow ( 2 , $ n - 1 ) ; for ( $ counter = 0 ; $ counter < $ opsize ; $ counter ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { echo $ str [ $ j ] ; if ( $ counter & ( 1 << $ j ) ) echo " ▁ " ; } echo " STRNEWLINE " ; } }
Hyp: 
function printSubsequences ( $ s ) { $ n = strlen ( $ s ) ; $ opsize = pow ( 2 , $ n - 1 ) ; for ( $ counter = 0 ; $ counter < $ opsize ; $ counter ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { echo $ str [ $ j ] ; if ( ( $ counter & ( 1 << $ j ) ) > 0 ) echo "0" ; } echo "0" ; } }

BLEU: 84.07
Edit Sim: 27


Src: 
function Convert ( radian ) { let pi = 3.14159 ; return ( radian * ( 180 / pi ) ) ; }
Ref: 
function Convert ( $ radian ) { $ pi = 3.14159 ; return ( $ radian * ( 180 / $ pi ) ) ; }
Hyp: 
function Convert ( $ radian ) { $ pi = 3.14159 ; return ( $ radian * ( 180 / $ pi ) ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function number_of_digits ( n ) { let i , res , sum = 0 ; for ( i = 4 , res = 1 ; ; i *= 4 , res ++ ) { sum += i ; if ( sum >= n ) break ; } return res ; }
Ref: 
function number_of_digits ( $ n ) { $ i ; $ res ; $ sum = 0 ; for ( $ i = 4 , $ res = 1 ; ; $ i *= 4 , $ res ++ ) { $ sum += $ i ; if ( $ sum >= $ n ) break ; } return $ res ; }
Hyp: 
function number_of_digits ( $ n ) { $ i ; $ res ; $ sum = 0 ; for ( $ i = 4 , $ res = 1 ; ; $ i *= 4 , $ res ++ ) { $ sum += $ i ; if ( $ sum >= $ n ) break ; } return $ res ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findK ( n , k ) { let a = [ ] ; for ( let i = 1 ; i < n ; i ++ ) if ( i % 2 == 1 ) a . push ( i ) ; for ( let i = 1 ; i < n ; i ++ ) if ( i % 2 == 0 ) a . push ( i ) ; return ( a [ k - 1 ] ) ; }
Ref: 
function findK ( $ n , $ k ) { $ a ; $ index = 0 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) if ( $ i % 2 == 1 ) $ a [ $ index ++ ] = $ i ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) if ( $ i % 2 == 0 ) $ a [ $ index ++ ] = $ i ; return ( $ a [ $ k - 1 ] ) ; }
Hyp: 
function findK ( $ n , $ k ) { $ a = array ( ) ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) if ( $ i % 2 == 1 ) $ a . push ( $ i ) ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) if ( $ i % 2 == 0 ) array_push ( $ a , $ i ) ; return ( $ a [ $ k - 1 ] ) ; }

BLEU: 75.7
Edit Sim: 44


Src: 
function findWays ( m , n , x ) { let table = new Array ( n + 1 ) ; for ( let i = 0 ; i < ( n + 1 ) ; i ++ ) { table [ i ] = new Array ( x + 1 ) ; for ( let j = 0 ; j < ( x + 1 ) ; j ++ ) { table [ i ] [ j ] = 0 ; } } for ( let j = 1 ; j <= m && j <= x ; j ++ ) table [ 1 ] [ j ] = 1 ; for ( let i = 2 ; i <= n ; i ++ ) { for ( let j = 1 ; j <= x ; j ++ ) { for ( let k = 1 ; k < j && k <= m ; k ++ ) table [ i ] [ j ] += table [ i - 1 ] [ j - k ] ; } } return table [ n ] [ x ] ; }
Ref: 
function findWays ( $ m , $ n , $ x ) { $ table ; for ( $ i = 1 ; $ i < $ n + 1 ; $ i ++ ) for ( $ j = 1 ; $ j < $ x + 1 ; $ j ++ ) $ table [ $ i ] [ $ j ] = 0 ; for ( $ j = 1 ; $ j <= $ m && $ j <= $ x ; $ j ++ ) $ table [ 1 ] [ $ j ] = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) for ( $ j = 1 ; $ j <= $ x ; $ j ++ ) for ( $ k = 1 ; $ k <= $ m && $ k < $ j ; $ k ++ ) $ table [ $ i ] [ $ j ] += $ table [ $ i - 1 ] [ $ j - $ k ] ; return $ table [ $ n ] [ $ x ] ; }
Hyp: 
function findWays ( $ m , $ n , $ x ) { $ table = array_fill ( 0 , $ n + 1 , array_fill ( 0 , $ x + 1 , NULL ) ) ; for ( $ j = 0 ; $ j < ( $ x + 1 ) ; $ j ++ ) $ table [ $ i ] [ $ j ] = 0 ; for ( $ j = 1 ; $ j <= $ m && $ j <= $ x ; $ j ++ ) $ table [ 1 ] [ $ j ] = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 1 ; $ j <= $ x ; $ j ++ ) { for ( $ k = 1 ; $ k < $ j && $ k <= $ m ; $ k ++ ) $ table [ $ i ] [ $ j ] += $ table [ $ i - 1 ] [ $ j - $ k ] ; } } return $ table [ $ n ] [ $ x ] ; }

BLEU: 80.89
Edit Sim: 58


Src: 
function oppositeSigns ( x , y ) { return ( ( x ^ y ) < 0 ) ; }
Ref: 
function oppositeSigns ( $ x , $ y ) { return ( ( $ x ^ $ y ) < 0 ) ; }
Hyp: 
function oppositeSigns ( $ x , $ y ) { return ( ( $ x ^ $ y ) < 0 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function pointIsOnLine ( m , c , x , y ) { if ( y == ( ( m * x ) + c ) ) return true ; return false ; }
Ref: 
function pointIsOnLine ( $ m , $ c , $ x , $ y ) { if ( $ y == ( ( $ m * $ x ) + $ c ) ) return true ; return false ; }
Hyp: 
function pointIsOnLine ( $ m , $ c , $ x , $ y ) { if ( $ y == ( ( $ m * $ x ) + $ c ) ) return true ; return false ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findMinDiff ( arr , n ) { arr . sort ( function ( a , b ) { return a - b } ) ; let diff = Number . MAX_VALUE ; for ( let i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i + 1 ] - arr [ i ] < diff ) diff = arr [ i + 1 ] - arr [ i ] ; return diff ; }
Ref: 
function findMinDiff ( $ arr , $ n ) { sort ( $ arr ) ; $ diff = PHP_INT_MAX ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) if ( $ arr [ $ i + 1 ] - $ arr [ $ i ] < $ diff ) $ diff = $ arr [ $ i + 1 ] - $ arr [ $ i ] ; return $ diff ; }
Hyp: 
function findMinDiff ( $ arr , $ n ) { sort ( $ arr ) ; $ diff = PHP_INT_MAX ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) if ( $ arr [ $ i + 1 ] - $ arr [ $ i ] < $ diff ) $ diff = $ arr [ $ i + 1 ] - $ arr [ $ i ] ; return $ diff ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function swapTwoHalves ( a , b ) { var la = a . length ; var lb = b . length ; var c = a . substring ( 0 , la / 2 ) + b . substring ( lb / 2 , lb ) ; var d = b . substring ( 0 , lb / 2 ) + a . substring ( la / 2 , la ) ; document . write ( c + " " + " " + d ) ; }
Ref: 
function swapTwoHalves ( $ a , $ b ) { $ la = strlen ( $ a ) ; $ lb = strlen ( $ b ) ; $ c = substr ( $ a , 0 , intval ( $ la / 2 ) ) . substr ( $ b , intval ( $ lb / 2 ) , $ lb ) ; $ d = substr ( $ b , 0 , intval ( $ lb / 2 ) ) . substr ( $ a , intval ( $ la / 2 ) , $ la ) ; echo ( $ c . " " ▁ . ▁ $ d ▁ . ▁ " " }
Hyp: 
function swapTwoHalves ( $ a , $ b ) { $ la = strlen ( $ a ) ; $ lb = strlen ( $ b ) ; $ c = $ a [ 0 ] ; $ la / 2 = $ b [ $ lb / 2 ] ; $ d = $ b [ 0 ] ; $ lb / 2 = $ a [ $ la / 2 ] ; echo $ c , " , ▁ " , " ▁ " , $ d ; }

BLEU: 40.68
Edit Sim: 119


Src: 
function findNumber ( n ) { n -- ; let i = 1 ; while ( n >= 0 ) { n -= i ; ++ i ; } return ( n + i ) ; }
Ref: 
function findNumber ( $ n ) { $ n -- ; $ i = 1 ; while ( $ n >= 0 ) { $ n -= $ i ; ++ $ i ; } return ( $ n + $ i ) ; }
Hyp: 
function findNumber ( $ n ) { $ n -- ; $ i = 1 ; while ( $ n >= 0 ) { $ n -= $ i ; ++ $ i ; } return ( $ n + $ i ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function minimumIncrease ( a , b , c ) { var arr = [ a , b , c ] ; arr . sort ( ( a , b ) => a - b ) ; if ( arr [ 0 ] + arr [ 1 ] >= arr [ 2 ] ) return 0 ; else return arr [ 2 ] - ( arr [ 0 ] + arr [ 1 ] ) ; }
Ref: 
function minimumIncrease ( $ a , $ b , $ c ) { $ arr = array ( $ a , $ b , $ c ) ; sort ( $ arr ) ; if ( $ arr [ 0 ] + $ arr [ 1 ] >= $ arr [ 2 ] ) return 0 ; else return $ arr [ 2 ] - ( $ arr [ 0 ] + $ arr [ 1 ] ) ; }
Hyp: 
function minimumIncrease ( $ a , $ b , $ c ) { $ arr = array_merge ( $ arr , $ a ) ; sort ( $ arr ) ; if ( $ arr [ 0 ] + $ arr [ 1 ] >= $ arr [ 2 ] ) return 0 ; else return $ arr [ 2 ] - ( $ arr [ 0 ] + $ arr [ 1 ] ) ; }

BLEU: 87.85
Edit Sim: 11


Src: 
function divisibleBy36 ( num ) { let l = num . length ; if ( l == 0 ) return " " ; if ( l == 1 && num [ 0 ] != ' ' ) return " " ; let two_digit_num = ( num [ l - 2 ] - ' ' ) * 10 + ( num [ l - 1 ] - ' ' ) ; if ( two_digit_num % 4 != 0 ) return " " ; let sum = 0 ; for ( let i = 0 ; i < l ; i ++ ) sum += ( num [ i ] - ' ' ) ; if ( sum % 9 != 0 ) return " " ; return " " ; }
Ref: 
function divisibleBy36 ( $ num ) { $ l = strlen ( $ num ) ; if ( $ l == 0 ) return " No " ; if ( $ l == 1 && $ num [ 0 ] != '0' ) return " No " ; $ two_digit_num = ( $ num [ $ l - 2 ] - '0' ) * 10 + ( $ num [ $ l - 1 ] - '0' ) ; if ( $ two_digit_num % 4 != 0 ) return " No " ; $ sum = 0 ; for ( $ i = 0 ; $ i < $ l ; $ i ++ ) $ sum += ( $ num [ $ i ] - '0' ) ; if ( $ sum % 9 != 0 ) return " No " ; return " Yes " ; }
Hyp: 
function divisibleBy36 ( $ num ) { $ l = strlen ( $ num ) ; if ( $ l == 0 ) return "0" ; if ( $ l == 1 && $ num [ 0 ] != '0' ) return "1" ; $ two_digit_num = ( $ num [ $ l - 2 ] - '0' ) * 10 + ( $ num [ $ l - 1 ] - '0' ) ; if ( $ two_digit_num % 4 != 0 ) return "1" ; $ sum = 0 ; for ( $ i = 0 ; $ i < $ l ; $ i ++ ) $ sum += ( $ num [ $ i ] - '0' ) ; if ( $ sum % 9 != 0 ) return "1" ; return "0" ; }

BLEU: 84.9
Edit Sim: 21


Src: 
function min_elimination ( n , arr ) { let count = 0 ; let prev_val = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { let curr_val = arr [ i ] ; if ( curr_val % 2 == prev_val % 2 ) count ++ ; prev_val = curr_val ; } return count ; }
Ref: 
function min_elimination ( $ n , $ arr ) { $ count = 0 ; $ prev_val = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ curr_val = $ arr [ $ i ] ; if ( $ curr_val % 2 == $ prev_val % 2 ) $ count ++ ; $ prev_val = $ curr_val ; } return $ count ; }
Hyp: 
function min_elimination ( $ n , $ arr ) { $ count = 0 ; $ prev_val = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ curr_val = $ arr [ $ i ] ; if ( $ curr_val % 2 == $ prev_val % 2 ) $ count ++ ; $ prev_val = $ curr_val ; } return $ count ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function lastDigit ( a , b ) { var lastDig = ( a [ a . length - 1 ] - ' ' ) * ( b [ b . length - 1 ] - ' ' ) ; document . write ( lastDig % 10 ) ; }
Ref: 
function lastDigit ( $ a , $ b ) { $ lastDig = ( ord ( $ a [ strlen ( $ a ) - 1 ] ) - 48 ) * ( ord ( $ b [ strlen ( $ b ) - 1 ] ) - 48 ) ; echo $ lastDig % 10 ; }
Hyp: 
function lastDigit ( $ a , $ b ) { $ lastDig = ( $ a [ $ a . length - 1 ] - '0' ) * ( $ b [ $ b . length - 1 ] - '0' ) ; echo $ lastDig / 10 ; }

BLEU: 47.41
Edit Sim: 43


Src: 
function sumOfSeries ( n ) { return ( 0.666 ) * ( 1 - 1 / Math . pow ( 10 , n ) ) ; }
Ref: 
function sumOfSeries ( $ n ) { return ( 0.666 ) * ( 1 - 1 / pow ( 10 , $ n ) ) ; }
Hyp: 
function sumOfSeries ( $ n ) { return ( 0.666 ) * ( 1 - 1 / pow ( 10 , $ n ) ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function Area ( l , b , h ) { if ( l < 0 b < 0 h < 0 ) return - 1 ; let x = ( l * b ) / ( l + b ) ; let A = 0.70477 * Math . pow ( x , 2 ) ; return A ; }
Ref: 
function Area ( $ l , $ b , $ h ) { if ( $ l < 0 or $ b < 0 or $ h < 0 ) return -1 ; $ x = ( $ l * $ b ) / ( $ l + $ b ) ; $ A = 0.70477 * pow ( $ x , 2 ) ; return $ A ; }
Hyp: 
function Area ( $ l , $ b , $ h ) { if ( $ l < 0 $ b < 0 $ h < 0 ) return -1 ; $ x = ( $ l * $ b ) / ( $ l + $ b ) ; $ A = 0.70477 * pow ( $ x , 2 ) ; return $ A ; }

BLEU: 92.67
Edit Sim: 6


Src: 
function countPairs ( arr1 , arr2 , m , n , x ) { let count = 0 ; let l = 0 , r = n - 1 ; while ( l < m && r >= 0 ) { if ( ( arr1 [ l ] + arr2 [ r ] ) == x ) { l ++ ; r -- ; count ++ ; } else if ( ( arr1 [ l ] + arr2 [ r ] ) < x ) l ++ ; else r -- ; } return count ; }
Ref: 
function countPairs ( $ arr1 , $ arr2 , $ m , $ n , $ x ) { $ count = 0 ; $ l = 0 ; $ r = $ n - 1 ; while ( $ l < $ m and $ r >= 0 ) { if ( ( $ arr1 [ $ l ] + $ arr2 [ $ r ] ) == $ x ) { $ l ++ ; $ r -- ; $ count ++ ; } else if ( ( $ arr1 [ $ l ] + $ arr2 [ $ r ] ) < $ x ) $ l ++ ; else $ r -- ; } return $ count ; }
Hyp: 
function countPairs ( $ arr1 , $ arr2 , $ m , $ n , $ x ) { $ count = 0 ; $ l = 0 ; $ r = $ n - 1 ; while ( $ l < $ m && $ r >= 0 ) { if ( ( $ arr1 [ $ l ] + $ arr2 [ $ r ] ) == $ x ) { $ l ++ ; $ r -- ; $ count ++ ; } else if ( ( $ arr1 [ $ l ] + $ arr2 [ $ r ] ) < $ x ) $ l ++ ; else $ r -- ; } return $ count ; }

BLEU: 97.95
Edit Sim: 3


Src: 
function maximum_toys ( cost , N , K ) { let count = 0 , sum = 0 ; cost . sort ( function ( a , b ) { return a - b } ) ; for ( let i = 0 ; i < N ; i ++ ) { if ( sum + cost [ i ] <= K ) { sum = sum + cost [ i ] ; count ++ ; } } return count ; }
Ref: 
function maximum_toys ( $ cost , $ N , $ K ) { $ count = 0 ; $ sum = 0 ; sort ( $ cost ) ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { if ( $ sum + $ cost [ $ i ] <= $ K ) { $ sum = $ sum + $ cost [ $ i ] ; $ count ++ ; } } return $ count ; }
Hyp: 
function maximum_toys ( $ cost , $ N , $ K ) { $ count = 0 ; $ sum = 0 ; sort ( $ cost ) ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { if ( $ sum + $ cost [ $ i ] <= $ K ) { $ sum = $ sum + $ cost [ $ i ] ; $ count ++ ; } } return $ count ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function printCombination ( n ) { for ( let i = 1 ; i < n ; i ++ ) { if ( i % 3 != 0 ) { for ( let j = 1 ; j < n ; j ++ ) { if ( j % 3 != 0 ) { for ( let k = 1 ; k < n ; k ++ ) { if ( k % 3 != 0 && ( i + j + k ) == n ) { document . write ( i + " " + j + " " + k ) ; return ; } } } } } } }
Ref: 
function printCombination ( $ n ) { for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( $ i % 3 != 0 ) { for ( $ j = 1 ; $ j < $ n ; $ j ++ ) { if ( $ j % 3 != 0 ) { for ( $ k = 1 ; $ k < $ n ; $ k ++ ) { if ( $ k % 3 != 0 && ( $ i + $ j + $ k ) == $ n ) { echo $ i , " " ▁ , ▁ $ j ▁ , ▁ " " return ; } } } } } } }
Hyp: 
function printCombination ( $ n ) { for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( $ i % 3 != 0 ) { for ( $ j = 1 ; $ j < $ n ; $ j ++ ) { if ( $ j % 3 != 0 ) { for ( $ k = 1 ; $ k < $ n ; $ k ++ ) { if ( $ k % 3 != 0 && ( $ i + $ j + $ k ) == $ n ) { echo $ i . " , ▁ " . $ j , " , ▁ " . $ k ; return ; } } } } } }

BLEU: 89.12
Edit Sim: 16


Src: 
function printPairs ( arr , n , sum ) { for ( let i = 0 ; i < n ; i ++ ) for ( let j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] + arr [ j ] == sum ) document . write ( " " + arr [ i ] + " " + arr [ j ] + " " + " " ) ; }
Ref: 
function printPairs ( $ arr , $ n , $ sum ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) if ( $ arr [ $ i ] + $ arr [ $ j ] == $ sum ) echo " ( " , $ arr [ $ i ] , " , ▁ " , $ arr [ $ j ] , " ) " , " STRNEWLINE " ; }
Hyp: 
function printPairs ( & $ arr , $ n , $ sum ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) if ( $ arr [ $ i ] + $ arr [ $ j ] == $ sum ) echo " ( " . $ arr [ $ i ] . " , ▁ " . $ arr [ $ j ] . " ) " ; }

BLEU: 78.01
Edit Sim: 37


Src: 
function bitExtracted ( number , k , p ) { return ( ( ( 1 << k ) - 1 ) & ( number >> ( p - 1 ) ) ) ; }
Ref: 
function bitExtracted ( $ number , $ k , $ p ) { return ( ( ( 1 << $ k ) - 1 ) & ( $ number >> ( $ p - 1 ) ) ) ; }
Hyp: 
function bitExtracted ( $ number , $ k , $ p ) { return ( ( ( 1 << $ k ) - 1 ) & ( $ number >> ( $ p - 1 ) ) ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function setBitNumber ( n ) { let k = parseInt ( Math . log ( n ) / Math . log ( 2 ) , 10 ) ; return 1 << k ; }
Ref: 
function setBitNumber ( $ n ) { $ k = ( int ) ( log ( $ n , 2 ) ) ; return 1 << $ k ; }
Hyp: 
function setBitNumber ( $ n ) { $ k = ( int ) log ( $ n ) / log ( 2 ) ; return 1 << $ k ; }

BLEU: 75.71
Edit Sim: 11


Src: 
function countTrailingZero ( x ) { let lookup = [ 32 , 0 , 1 , 26 , 2 , 23 , 27 , 0 , 3 , 16 , 24 , 30 , 28 , 11 , 0 , 13 , 4 , 7 , 17 , 0 , 25 , 22 , 31 , 15 , 29 , 10 , 12 , 6 , 0 , 21 , 14 , 9 , 5 , 20 , 8 , 19 , 18 ] ; return lookup [ ( - x & x ) % 37 ] ; }
Ref: 
function countTrailingZero ( $ x ) { $ lookup = array ( 32 , 0 , 1 , 26 , 2 , 23 , 27 , 0 , 3 , 16 , 24 , 30 , 28 , 11 , 0 , 13 , 4 , 7 , 17 , 0 , 25 , 22 , 31 , 15 , 29 , 10 , 12 , 6 , 0 , 21 , 14 , 9 , 5 , 20 , 8 , 19 , 18 ) ; return $ lookup [ ( - $ x & $ x ) % 37 ] ; }
Hyp: 
function countTrailingZero ( $ x ) { $ lookup = array ( 32 , 0 , 1 , 26 , 2 , 23 , 27 , 0 , 3 , 16 , 24 , 30 , 28 , 11 , 0 , 13 , 4 , 7 , 17 , 0 , 25 , 22 , 31 , 15 , 29 , 10 , 12 , 6 , 0 , 21 , 14 , 9 , 5 , 20 , 8 , 19 , 18 ] ; return $ lookup [ ( - $ x & $ x ) % 37 ] ; }

BLEU: 97.57
Edit Sim: 1


Src: 
function maxOR ( arr , n , k , x ) { let preSum = new Array ( n + 1 ) ; let suffSum = new Array ( n + 1 ) ; let res = 0 , pow = 1 ; for ( let i = 0 ; i < k ; i ++ ) pow *= x ; preSum [ 0 ] = 0 ; for ( let i = 0 ; i < n ; i ++ ) preSum [ i + 1 ] = preSum [ i ] | arr [ i ] ; suffSum [ n ] = 0 ; for ( let i = n - 1 ; i >= 0 ; i -- ) suffSum [ i ] = suffSum [ i + 1 ] | arr [ i ] ; res = 0 ; for ( let i = 0 ; i < n ; i ++ ) res = Math . max ( res , preSum [ i ] | ( arr [ i ] * pow ) suffSum [ i + 1 ] ) ; return res ; }
Ref: 
function maxOR ( $ arr , $ n , $ k , $ x ) { $ res ; $ pow = 1 ; for ( $ i = 0 ; $ i < $ k ; $ i ++ ) $ pow *= $ x ; $ preSum [ 0 ] = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ preSum [ $ i + 1 ] = $ preSum [ $ i ] | $ arr [ $ i ] ; $ suffSum [ $ n ] = 0 ; for ( $ i = $ n - 1 ; $ i >= 0 ; $ i -- ) $ suffSum [ $ i ] = $ suffSum [ $ i + 1 ] | $ arr [ $ i ] ; $ res = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ res = max ( $ res , $ preSum [ $ i ] | ( $ arr [ $ i ] * $ pow ) $ suffSum [ $ i + 1 ] ) ; return $ res ; }
Hyp: 
function maxOR ( $ arr , $ n , $ k , $ x ) { $ preSum = array ( ) ; $ suffSum = array ( ) ; $ res = 0 ; $ pow = 1 ; for ( $ i = 0 ; $ i < $ k ; $ i ++ ) $ pow *= $ x ; $ preSum [ 0 ] = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ preSum [ $ i + 1 ] = $ preSum [ $ i ] | $ arr [ $ i ] ; $ suffSum [ $ n ] = 0 ; for ( $ i = $ n - 1 ; $ i >= 0 ; $ i -- ) $ suffSum [ $ i ] = $ suffSum [ $ i + 1 ] | $ arr [ $ i ] ; $ res = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ res = max ( $ res , $ preSum [ $ i ] | ( $ arr [ $ i ] * $ pow ) $ suffSum [ $ i + 1 ] ) ; return $ res ; }

BLEU: 91.98
Edit Sim: 51


Src: 
function findPoints ( l1 , r1 , l2 , r2 ) { var x = ( l1 != l2 ) ? Math . min ( l1 , l2 ) : - 1 ; var y = ( r1 != r2 ) ? Math . max ( r1 , r2 ) : - 1 ; document . write ( x + " " + y ) ; }
Ref: 
function findPoints ( $ l1 , $ r1 , $ l2 , $ r2 ) { $ x = ( $ l1 != $ l2 ) ? min ( $ l1 , $ l2 ) : -1 ; $ y = ( $ r1 != $ r2 ) ? max ( $ r1 , $ r2 ) : -1 ; echo $ x , " " , $ y ; }
Hyp: 
function findPoints ( $ l1 , $ r1 , $ l2 , $ r2 ) { $ x = ( $ l1 != $ l2 ) ? min ( $ l1 , $ l2 ) : -1 ; $ y = ( $ r1 != $ r2 ) ? max ( $ r1 , $ r2 ) : -1 ; echo $ x . " , ▁ " . $ y ; }

BLEU: 90.93
Edit Sim: 6


Src: 
function bridge_length ( trainLength , Speed , Time ) { return ( ( Time * Speed ) - trainLength ) ; }
Ref: 
function bridge_length ( $ trainLength , $ Speed , $ Time ) { return ( ( $ Time * $ Speed ) - $ trainLength ) ; }
Hyp: 
function bridge_length ( $ trainLength , $ Speed , $ Time ) { return ( ( $ Time * $ Speed ) - $ trainLength ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function totalDigits ( n ) { var number_of_digits = 0 ; for ( var i = 1 ; i <= n ; i *= 10 ) number_of_digits += ( n - i + 1 ) ; return number_of_digits ; }
Ref: 
function totalDigits ( $ n ) { $ number_of_digits = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i *= 10 ) $ number_of_digits += ( $ n - $ i + 1 ) ; return $ number_of_digits ; }
Hyp: 
function totalDigits ( $ n ) { $ number_of_digits = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i *= 10 ) $ number_of_digits += ( $ n - $ i + 1 ) ; return $ number_of_digits ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countSquares ( r , c , m ) { let squares = 0 ; for ( let i = 1 ; i <= 8 ; i ++ ) { for ( let j = 1 ; j <= 8 ; j ++ ) { if ( Math . max ( Math . abs ( i - r ) , Math . abs ( j - c ) ) <= m ) squares ++ ; } } return squares ; }
Ref: 
function countSquares ( $ r , $ c , $ m ) { $ squares = 0 ; for ( $ i = 1 ; $ i <= 8 ; $ i ++ ) { for ( $ j = 1 ; $ j <= 8 ; $ j ++ ) { if ( max ( abs ( $ i - $ r ) , abs ( $ j - $ c ) ) <= $ m ) $ squares ++ ; } } return $ squares ; }
Hyp: 
function countSquares ( $ r , $ c , $ m ) { $ squares = 0 ; for ( $ i = 1 ; $ i <= 8 ; $ i ++ ) { for ( $ j = 1 ; $ j <= 8 ; $ j ++ ) { if ( max ( abs ( $ i - $ r ) , abs ( $ j - $ c ) ) <= $ m ) $ squares ++ ; } } return $ squares ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function check_euler_four_square_identity ( a , b , ab ) { let s = 0 ; for ( let i = 0 ; i * i <= ab ; i ++ ) { s = i * i ; for ( let j = i ; j * j <= ab ; j ++ ) { s = j * j + i * i ; for ( let k = j ; k * k <= ab ; k ++ ) { s = k * k + j * j + i * i ; for ( let l = k ; l * l <= ab ; l ++ ) { s = l * l + k * k + j * j + i * i ; if ( s == ab ) { document . write ( " " + i + " " ) ; document . write ( " " + j + " " ) ; document . write ( " " + k + " " ) ; document . write ( " " + l + " " ) ; document . write ( " " + a + " " + b ) ; document . write ( " " + " " + " " + " " ) ; document . write ( ab + " " ) ; document . write ( i + " " + i + " " ) ; document . write ( j + " " + j + " " ) ; document . write ( k + " " + k + " " ) ; document . write ( l + " " + l + " " ) ; document . write ( " " ) ; } } } } } }
Ref: 
function check_euler_four_square_identity ( $ a , $ b , $ ab ) { $ s = 0 ; for ( $ i = 0 ; $ i * $ i <= $ ab ; $ i ++ ) { $ s = $ i * $ i ; for ( $ j = $ i ; $ j * $ j <= $ ab ; $ j ++ ) { $ s = $ j * $ j + $ i * $ i ; for ( $ k = $ j ; $ k * $ k <= $ ab ; $ k ++ ) { $ s = $ k * $ k + $ j * $ j + $ i * $ i ; for ( $ l = $ k ; $ l * $ l <= $ ab ; $ l ++ ) { $ s = $ l * $ l + $ k * $ k + $ j * $ j + $ i * $ i ; if ( $ s == $ ab ) { echo ( " i ▁ = ▁ " . $ i . " STRNEWLINE " ) ; echo ( " j ▁ = ▁ " . $ j . " STRNEWLINE " ) ; echo ( " k ▁ = ▁ " . $ k . " STRNEWLINE " ) ; echo ( " l ▁ = ▁ " . $ l . " STRNEWLINE " ) ; echo " " . " Product ▁ of ▁ " . $ a . " ▁ and ▁ " . $ b ; echo " ▁ can ▁ be ▁ written " . " ▁ as ▁ sum ▁ of ▁ squares ▁ of ▁ i , ▁ " . " j , ▁ k , ▁ l STRNEWLINE " ; echo $ ab . " ▁ = ▁ " ; echo $ i . " * " ▁ . ▁ $ i . ▁ " + " echo $ j . " * " . $ j . " ▁ + ▁ " ; echo $ k . " * " ▁ . ▁ $ k ▁ . ▁ " + " echo $ l . " * " . $ l . " STRNEWLINE " ; echo " STRNEWLINE " ; } } } } } }
Hyp: 
function check_euler_four_square_identity ( $ a , $ b , $ ab ) { $ s = 0 ; for ( $ i = 0 ; $ i * $ i <= $ ab ; $ i ++ ) { $ s = $ i * $ i ; for ( $ j = $ i ; $ j * $ j <= $ ab ; $ j ++ ) { $ s = $ j * $ j + $ i * $ i ; for ( $ k = $ j ; $ k * $ k <= $ ab ; $ k ++ ) { $ s = $ k * $ k + $ j * $ j + $ i * $ i ; for ( $ l = $ k ; $ l * $ l <= $ ab ; $ l ++ ) { $ s = $ l * $ l + $ k * $ k + $ j * $ j + $ i * $ i ; if ( $ s == $ ab ) { echo " Yes " ; echo " No " ; echo " STRNEWLINE " ; } } } } }

BLEU: 37.35
Edit Sim: 504


Src: 
function sumOfSeries ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) sum = sum + i * ( i + 1 ) * ( i + 2 ) ; return sum ; }
Ref: 
function sumOfSeries ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ sum = $ sum + $ i * ( $ i + 1 ) * ( $ i + 2 ) ; return $ sum ; }
Hyp: 
function sumOfSeries ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ sum = $ sum + $ i * ( $ i + 1 ) * ( $ i + 2 ) ; return $ sum ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function addOne ( x ) { let m = 1 ; while ( x & m ) { x = x ^ m ; m <<= 1 ; } x = x ^ m ; return x ; }
Ref: 
function addOne ( $ x ) { $ m = 1 ; while ( $ x & $ m ) { $ x = $ x ^ $ m ; $ m <<= 1 ; } $ x = $ x ^ $ m ; return $ x ; }
Hyp: 
function addOne ( & $ x ) { $ m = 1 ; while ( $ x & $ m ) { $ x = $ x ^ $ m ; $ m <<= 1 ; } $ x = $ x ^ $ m ; return $ x ; }

BLEU: 94.97
Edit Sim: 2


Src: 
function firstFactorialDivisibleNumber ( x ) { var fact = 1 ; for ( i = 1 ; i < x ; i ++ ) { fact = fact * i ; if ( fact % x == 0 ) break ; } return i ; }
Ref: 
function firstFactorialDivisibleNumber ( $ x ) { $ i = 1 ; $ fact = 1 ; for ( $ i = 1 ; $ i < $ x ; $ i ++ ) { $ fact = $ fact * $ i ; if ( $ fact % $ x == 0 ) break ; } return $ i ; }
Hyp: 
function firstFactorialDivisibleNumber ( $ x ) { $ fact = 1 ; for ( $ i = 1 ; $ i < $ x ; $ i ++ ) { $ fact = $ fact * $ i ; if ( $ fact % $ x == 0 ) break ; } return $ i ; }

BLEU: 90.35
Edit Sim: 10


Src: 
function check ( m , n ) { var RHS = m * Math . log ( n ) ; var LHS = n * Math . log ( m ) ; if ( LHS > RHS ) { document . write ( " " ) ; } else if ( LHS < RHS ) { document . write ( " " ) ; } else { document . write ( " " ) ; } }
Ref: 
function check ( $ m , $ n ) { $ RHS = $ m * log ( $ n ) ; $ LHS = $ n * log ( $ m ) ; if ( $ LHS > $ RHS ) echo " m ^ n ▁ > ▁ n ^ m " ; else if ( $ LHS < $ RHS ) echo " m ^ n ▁ < ▁ n ^ m " ; else echo " m ^ n ▁ = ▁ n ^ m " ; }
Hyp: 
function check ( $ m , $ n ) { $ RHS = $ m * log ( $ n ) ; $ LHS = $ n * log ( $ m ) ; if ( $ LHS > $ RHS ) { echo "2 ▁ " ; } else if ( $ LHS < $ RHS ) { echo "1 ▁ " ; } else { echo " No ▁ " ; } }

BLEU: 57.45
Edit Sim: 56


Src: 
function checkHankelMatrix ( n , m ) { for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { if ( i + j < n ) { if ( m [ i ] [ j ] != m [ i + j ] [ 0 ] ) return false ; } else { if ( m [ i ] [ j ] != m [ i + j - n + 1 ] [ n - 1 ] ) return false ; } } } return true ; }
Ref: 
function checkHankelMatrix ( $ n , $ m ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ i + $ j < $ n ) { if ( $ m [ $ i ] [ $ j ] != $ m [ $ i + $ j ] [ 0 ] ) return false ; } else { if ( $ m [ $ i ] [ $ j ] != $ m [ $ i + $ j - $ n + 1 ] [ $ n - 1 ] ) return false ; } } } return true ; }
Hyp: 
function checkHankelMatrix ( $ n , $ m ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ i + $ j < $ n ) { if ( $ m [ $ i ] [ $ j ] != $ m [ $ i + $ j ] [ 0 ] ) return false ; } else { if ( $ m [ $ i ] [ $ j ] != $ m [ $ i + $ j - $ n + 1 ] [ $ n - 1 ] ) return false ; } } } return true ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function minCost ( coin , n , k ) { coin . sort ( function ( a , b ) { return a - b } ) var coins_needed = Math . ceil ( n / ( k + 1 ) ) ; var ans = 0 ; for ( var i = 0 ; i <= coins_needed - 1 ; i ++ ) ans += coin [ i ] ; return ans ; }
Ref: 
function minCost ( $ coin , $ n , $ k ) { sort ( $ coin ) ; sort ( $ coin , $ n ) ; $ coins_needed = ceil ( 1.0 * $ n / ( $ k + 1 ) ) ; $ ans = 0 ; for ( $ i = 0 ; $ i <= $ coins_needed - 1 ; $ i ++ ) $ ans += $ coin [ $ i ] ; return $ ans ; } { $ coin = array ( 8 , 5 , 3 , 10 , 2 , 1 , 15 , 25 ) ; $ n = sizeof ( $ coin ) / sizeof ( $ coin [ 0 ] ) ; $ k = 3 ; echo minCost ( $ coin , $ n , $ k ) ; return 0 ; }
Hyp: 
function minCost ( $ coin , $ n , $ k ) { sort ( $ coin ) ; $ coins_needed = ceil ( $ n / ( $ k + 1 ) ) ; $ ans = 0 ; for ( $ i = 0 ; $ i <= $ coins_needed - 1 ; $ i ++ ) $ ans += $ coin [ $ i ] ; return $ ans ; }

BLEU: 36.02
Edit Sim: 199


Src: 
function toggleKthBit ( n , k ) { return ( n ^ ( 1 << ( k - 1 ) ) ) ; }
Ref: 
function toggleKthBit ( $ n , $ k ) { return ( $ n ^ ( 1 << ( $ k - 1 ) ) ) ; }
Hyp: 
function toggleKthBit ( $ n , $ k ) { return $ n ^ ( 1 << ( $ k - 1 ) ) ; }

BLEU: 85.8
Edit Sim: 4


Src: 
function maxCandies ( arr , n ) { let prevBought = arr [ n - 1 ] ; let candies = prevBought ; for ( let i = n - 2 ; i >= 0 ; i -- ) { let x = Math . min ( prevBought - 1 , arr [ i ] ) ; if ( x >= 0 ) { candies += x ; prevBought = x ; } } return candies ; }
Ref: 
function maxCandies ( $ arr , $ n ) { $ prevBought = $ arr [ $ n - 1 ] ; $ candies = $ prevBought ; for ( $ i = $ n - 2 ; $ i >= 0 ; $ i -- ) { $ x = min ( $ prevBought - 1 , $ arr [ $ i ] ) ; if ( $ x >= 0 ) { $ candies += $ x ; $ prevBought = $ x ; } } return $ candies ; }
Hyp: 
function maxCandies ( $ arr , $ n ) { $ prevBought = $ arr [ $ n - 1 ] ; $ candies = $ prevBought ; for ( $ i = $ n - 2 ; $ i >= 0 ; $ i -- ) { $ x = min ( $ prevBought - 1 , $ arr [ $ i ] ) ; if ( $ x >= 0 ) { $ candies += $ x ; $ prevBought = $ x ; } } return $ candies ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function isPossible ( n ) { var fac = new Array ( 10 ) ; fac [ 0 ] = fac [ 1 ] = 1 ; for ( var i = 2 ; i < 10 ; i ++ ) fac [ i ] = fac [ i - 1 ] * i ; var sum = 0 ; var x = n ; while ( x != 0 ) { sum += fac [ x % 10 ] ; x = parseInt ( x / 10 ) ; } if ( sum % n == 0 ) return true ; return false ; }
Ref: 
function isPossible ( $ n ) { $ fac = array ( ) ; $ fac [ 0 ] = $ fac [ 1 ] = 1 ; for ( $ i = 2 ; $ i < 10 ; $ i ++ ) $ fac [ $ i ] = $ fac [ $ i - 1 ] * $ i ; $ sum = 0 ; $ x = $ n ; while ( $ x ) { $ sum += $ fac [ $ x % 10 ] ; $ x /= 10 ; } if ( $ sum % $ n == 0 ) return true ; return false ; }
Hyp: 
function isPossible ( $ n ) { $ fac = array_fill ( 0 , 10 , 0 ) ; $ fac [ 0 ] = $ fac [ 1 ] = 1 ; for ( $ i = 2 ; $ i < 10 ; $ i ++ ) $ fac [ $ i ] = $ fac [ $ i - 1 ] * $ i ; $ sum = 0 ; $ x = $ n ; while ( $ x != 0 ) { $ sum += $ fac [ $ x % 10 ] ; $ x = ( int ) ( $ x / 10 ) ; } if ( $ sum % $ n == 0 ) return true ; return false ; }

BLEU: 82.15
Edit Sim: 40


Src: 
function divisible ( num ) { let n = num . length ; let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum += ( num . charAt ( i ) ) ; if ( sum % 3 == 0 ) return 0 ; if ( n == 1 ) return - 1 ; for ( let i = 0 ; i < n ; i ++ ) if ( sum % 3 == ( num . charAt ( i ) - ' ' ) % 3 ) return 1 ; if ( n == 2 ) return - 1 ; return 2 ; }
Ref: 
function divisible ( $ num ) { $ n = strlen ( $ num ) ; $ sum = ( $ num ) ; ( $ num ) ; 0 - '0' ; if ( $ sum % 3 == 0 ) return 0 ; if ( $ n == 1 ) return -1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ sum % 3 == ( $ num [ $ i ] - '0' ) % 3 ) return 1 ; if ( $ n == 2 ) return -1 ; return 2 ; }
Hyp: 
function divisible ( $ num ) { $ n = strlen ( $ num ) ; $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum += ( $ num [ $ i ] ) ; if ( $ sum % 3 == 0 ) return 0 ; if ( $ n == 1 ) return -1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ sum % 3 == ( $ num [ $ i ] - '0' ) % 3 ) return 1 ; if ( $ n == 2 ) return -1 ; return 2 ; }

BLEU: 77.74
Edit Sim: 48


Src: 
function findSum ( n ) { let sum = 0 ; for ( let i = 1 ; 1 << i < n ; i ++ ) { for ( let j = 0 ; j < i ; j ++ ) { let num = ( 1 << i ) + ( 1 << j ) ; if ( num <= n ) sum += num ; } } return sum ; }
Ref: 
function findSum ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; ( 1 << $ i ) < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ i ; $ j ++ ) { $ num = ( 1 << $ i ) + ( 1 << $ j ) ; if ( $ num <= $ n ) $ sum += $ num ; } } return $ sum ; }
Hyp: 
function findSum ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; 1 << $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ i ; $ j ++ ) { $ num = ( 1 << $ i ) + ( 1 << $ j ) ; if ( $ num <= $ n ) $ sum += $ num ; } } return $ sum ; }

BLEU: 91.46
Edit Sim: 6


Src: 
function min_noOf_operation ( arr , n , k ) { let noOfSubtraction ; let res = 0 ; for ( let i = 1 ; i < n ; i ++ ) { noOfSubtraction = 0 ; if ( arr [ i ] > arr [ i - 1 ] ) { noOfSubtraction = ( arr [ i ] - arr [ i - 1 ] ) / k ; if ( ( arr [ i ] - arr [ i - 1 ] ) % k != 0 ) noOfSubtraction ++ ; arr [ i ] = arr [ i ] - k * noOfSubtraction ; } res = res + noOfSubtraction ; } return res ; }
Ref: 
function min_noOf_operation ( $ arr , $ n , $ k ) { $ noOfSubtraction ; $ res = 0 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ noOfSubtraction = 0 ; if ( $ arr [ $ i ] > $ arr [ $ i - 1 ] ) { $ noOfSubtraction = ( $ arr [ $ i ] - $ arr [ $ i - 1 ] ) / $ k ; if ( ( $ arr [ $ i ] - $ arr [ $ i - 1 ] ) % $ k != 0 ) $ noOfSubtraction ++ ; $ arr [ $ i ] = $ arr [ $ i ] - $ k * $ noOfSubtraction ; } $ res = $ res + $ noOfSubtraction ; } return floor ( $ res ) ; }
Hyp: 
function min_noOf_operation ( & $ arr , $ n , $ k ) { $ noOfSubtraction ; $ res = 0 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ noOfSubtraction = 0 ; if ( $ arr [ $ i ] > $ arr [ $ i - 1 ] ) { $ noOfSubtraction = ( int ) ( $ arr [ $ i ] - $ arr [ $ i - 1 ] ) / $ k ; if ( ( $ arr [ $ i ] - $ arr [ $ i - 1 ] ) % $ k != 0 ) $ noOfSubtraction ++ ; $ arr [ $ i ] = $ arr [ $ i ] - $ k * $ noOfSubtraction ; } $ res = $ res + $ noOfSubtraction ; } return $ res ; }

BLEU: 94.64
Edit Sim: 20


Src: 
function findArea ( a , b ) { var Area ; Area = 3.142 * a * b ; document . write ( " " + Area . toFixed ( 2 ) ) ; }
Ref: 
function findArea ( $ a , $ b ) { $ Area ; $ Area = 3.142 * $ a * $ b ; echo " Area : ▁ " . $ Area ; }
Hyp: 
function findArea ( $ a , $ b ) { $ Area ; $ Area = 3.142 * $ a * $ b ; echo " The ▁ area ▁ of ▁ the ▁ chord " , $ Area ; }

BLEU: 70.03
Edit Sim: 24


Src: 
function maxDifference ( arr , N , k ) { let M , S = 0 , S1 = 0 , max_difference = 0 ; for ( let i = 0 ; i < N ; i ++ ) S += arr [ i ] ; let temp ; for ( let i = 0 ; i < N ; i ++ ) { for ( let j = i + 1 ; j < N ; j ++ ) { if ( arr [ i ] < arr [ j ] ) { temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; } } } M = Math . max ( k , N - k ) ; for ( let i = 0 ; i < M ; i ++ ) S1 += arr [ i ] ; max_difference = S1 - ( S - S1 ) ; return max_difference ; }
Ref: 
function maxDifference ( $ arr , $ N , $ k ) { $ M ; $ S = 0 ; $ S1 = 0 ; $ max_difference = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) $ S += $ arr [ $ i ] ; rsort ( $ arr ) ; $ M = max ( $ k , $ N - $ k ) ; for ( $ i = 0 ; $ i < $ M ; $ i ++ ) $ S1 += $ arr [ $ i ] ; $ max_difference = $ S1 - ( $ S - $ S1 ) ; return $ max_difference ; }
Hyp: 
function maxDifference ( $ arr , $ N , $ k ) { $ M = 0 ; $ S = 0 ; $ S1 = 0 ; $ max_difference = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) $ S += $ arr [ $ i ] ; $ temp ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ N ; $ j ++ ) { if ( $ arr [ $ i ] < $ arr [ $ j ] ) { $ temp = $ arr [ $ i ] ; $ arr [ $ i ] = $ arr [ $ j ] ; $ arr [ $ j ] = $ temp ; } } } $ M = max ( $ k , $ N - $ k ) ; for ( $ i = 0 ; $ i < $ M ; $ i ++ ) $ S1 += $ arr [ $ i ] ; $ max_difference = $ S1 - ( $ S - $ S1 ) ; return $ max_difference ; }

BLEU: 54.33
Edit Sim: 208


Src: 
function minJumps ( arr , n ) { if ( n == 1 ) return 0 ; let res = Number . MAX_VALUE ; for ( let i = n - 2 ; i >= 0 ; i -- ) { if ( i + arr [ i ] >= n - 1 ) { let sub_res = minJumps ( arr , i + 1 ) ; if ( sub_res != Number . MAX_VALUE ) res = Math . min ( res , sub_res + 1 ) ; } } return res ; }
Ref: 
function minJumps ( $ arr , $ l , $ h ) { if ( $ h == $ l ) return 0 ; if ( $ arr [ $ l ] == 0 ) return INT_MAX ; $ min = 999999 ; for ( $ i = $ l + 1 ; $ i <= $ h && $ i <= $ l + $ arr [ $ l ] ; $ i ++ ) { $ jumps = minJumps ( $ arr , $ i , $ h ) ; if ( $ jumps != 999999 && $ jumps + 1 < $ min ) $ min = $ jumps + 1 ; } return $ min ; }
Hyp: 
function minJumps ( $ arr , $ n ) { if ( $ n == 1 ) return 0 ; $ res = PHP_INT_MAX ; for ( $ i = $ n - 2 ; $ i >= 0 ; $ i -- ) { if ( $ i + $ arr [ $ i ] >= $ n - 1 ) { $ sub_res = minJumps ( $ arr , $ i + 1 ) ; if ( $ sub_res != PHP_INT_MAX ) $ res = min ( $ res , $ sub_res + 1 ) ; } } return $ res ; }

BLEU: 34.13
Edit Sim: 132


Src: 
function evenSum ( n ) { return ( n * ( n + 1 ) ) ; }
Ref: 
function evenSum ( $ n ) { return ( $ n * ( $ n + 1 ) ) ; }
Hyp: 
function evenSum ( $ n ) { return ( $ n * ( $ n + 1 ) ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function printArray ( arr , n ) { arr . sort ( ) ; let l = 0 , r = n - 1 , flag = 0 , i ; let k = 2 ; while ( l <= r ) { if ( flag == 0 ) { for ( i = l ; i < l + k && i <= r ; i ++ ) document . write ( arr [ i ] + " " ) ; flag = 1 ; l = i ; } else { for ( i = r ; i > r - k && i >= l ; i -- ) document . write ( arr [ i ] + " " ) ; flag = 0 ; r = i ; } k ++ ; } }
Ref: 
function printArray ( $ arr , $ n ) { sort ( $ arr ) ; $ l = 0 ; $ r = $ n - 1 ; $ flag = 0 ; $ k = 2 ; while ( $ l <= $ r ) { if ( $ flag == 0 ) { for ( $ i = $ l ; $ i < $ l + $ k && $ i <= $ r ; $ i ++ ) echo $ arr [ $ i ] , " ▁ " ; $ flag = 1 ; $ l = $ i ; } { for ( $ i = $ r ; $ i > $ r - $ k && $ i >= $ l ; $ i -- ) echo $ arr [ $ i ] , " ▁ " ; $ flag = 0 ; $ r = $ i ; } $ k ++ ; } }
Hyp: 
function printArray ( $ arr , $ n ) { sort ( $ arr ) ; $ l = 0 ; $ r = $ n - 1 ; $ flag = 0 ; $ i ; $ k = 2 ; while ( $ l <= $ r ) { if ( $ flag == 0 ) { for ( $ i = $ l ; $ i < $ l + $ k && $ i <= $ r ; $ i ++ ) echo $ arr [ $ i ] . " ▁ " ; $ flag = 1 ; $ l = $ i ; } else { for ( $ i = $ r ; $ i > $ r - $ k && $ i >= $ l ; $ i -- ) echo $ arr [ $ i ] . " ▁ " ; $ flag = 0 ; $ r = $ i ; } $ k ++ ; } }

BLEU: 93.58
Edit Sim: 13


Src: 
function nthEnneadecagonal ( n ) { return ( 17 * n * n - 15 * n ) / 2 ; }
Ref: 
function nthEnneadecagonal ( $ n ) { return ( 17 * $ n * $ n - 15 * $ n ) / 2 ; }
Hyp: 
function nthEnneadecagonal ( $ n ) { return ( 17 * $ n * $ n - 15 * $ n ) / 2 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findMaxNum ( arr , n ) { arr . sort ( function ( a , b ) { return b - a ; } ) ; var num = arr [ 0 ] ; for ( var i = 1 ; i < n ; i ++ ) { num = num * 10 + arr [ i ] ; } return num ; }
Ref: 
function findMaxNum ( & $ arr , $ n ) { rsort ( $ arr ) ; $ num = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ num = $ num * 10 + $ arr [ $ i ] ; } return $ num ; }
Hyp: 
function findMaxNum ( $ arr , $ n ) { sort ( $ arr ) ; $ num = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ num = $ num * 10 + $ arr [ $ i ] ; } return $ num ; }

BLEU: 92.12
Edit Sim: 3


Src: 
function multiple ( a , b , x ) { if ( b < 0 ) { if ( a == 1 && x == 1 ) document . write ( " " ) ; else document . write ( " " ) ; } var mul = parseInt ( Math . pow ( a , b ) ) ; var ans = mul / x ; var ans1 = x * ans ; var ans2 = x * ( ans + 1 ) ; document . write ( ( ( mul - ans1 ) <= ( ans2 - mul ) ) ? ans1 : ans2 ) ; }
Ref: 
function multiple ( $ a , $ b , $ x ) { if ( $ b < 0 ) { if ( $ a == 1 && $ x == 1 ) echo "1" ; else echo "0" ; } $ mul = pow ( $ a , $ b ) ; $ ans = $ mul / $ x ; $ ans1 = $ x * $ ans ; $ ans2 = $ x * ( $ ans + 1 ) ; $ k = ( ( ( $ mul - $ ans1 ) <= ( $ ans2 - $ mul ) ) ? $ ans1 : $ ans2 ) ; echo ( $ k ) ; }
Hyp: 
function multiple ( $ a , $ b , $ x ) { if ( $ b < 0 ) { if ( $ a == 1 && $ x == 1 ) echo " Yes " ; else echo " No " ; } $ ans = $ mul / $ x ; $ ans1 = $ x * $ ans ; $ ans2 = $ x * ( $ ans + 1 ) ; echo ( ( $ mul - $ ans1 ) <= ( $ ans2 - $ mul ) ) ? $ ans1 : $ ans2 ) ; }

BLEU: 75.54
Edit Sim: 56


Src: 
function countKeyPressed ( str , len ) { var count = 0 ; for ( var i = 0 ; i < len ; i ++ ) count = count + arr [ str . charCodeAt ( i ) - 97 ] ; return count ; }
Ref: 
function countKeyPressed ( $ str , $ len ) { global $ arr ; $ count = 0 ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) $ count = $ count + $ arr [ ord ( $ str [ $ i ] ) - ord ( ' a ' ) ] ; return $ count ; }
Hyp: 
function countKeyPressed ( $ str , $ len ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) $ count = $ count + $ arr [ ord ( $ str [ $ i ] ) - 97 ] ; return $ count ; }

BLEU: 79.84
Edit Sim: 28


Src: 
function merge ( m , n ) { for ( let i = n - 1 ; i >= 0 ; i -- ) { let j , last = arr1 [ m - 1 ] ; for ( j = m - 2 ; j >= 0 && arr1 [ j ] > arr2 [ i ] ; j -- ) arr1 [ j + 1 ] = arr1 [ j ] ; if ( j != m - 2 last > arr2 [ i ] ) { arr1 [ j + 1 ] = arr2 [ i ] ; arr2 [ i ] = last ; } } } merge ( arr1 . length , arr2 . length ) ; document . write ( " " ) ; for ( let i = 0 ; i < arr1 . length ; i ++ ) { document . write ( arr1 [ i ] + " " ) ; } document . write ( " " ) ; for ( let i = 0 ; i < arr2 . length ; i ++ ) { document . write ( arr2 [ i ] + " " ) ; }
Ref: 
function merge ( & $ ar1 , & $ ar2 , $ m , $ n ) { for ( $ i = $ n - 1 ; $ i >= 0 ; $ i -- ) { $ last = $ ar1 [ $ m - 1 ] ; for ( $ j = $ m - 2 ; $ j >= 0 && $ ar1 [ $ j ] > $ ar2 [ $ i ] ; $ j -- ) $ ar1 [ $ j + 1 ] = $ ar1 [ $ j ] ; if ( $ j != $ m - 2 $ last > $ ar2 [ $ i ] ) { $ ar1 [ $ j + 1 ] = $ ar2 [ $ i ] ; $ ar2 [ $ i ] = $ last ; } } }
Hyp: 
function merge ( $ m , $ n ) { for ( $ i = $ n - 1 ; $ i >= 0 ; $ i -- ) { for ( $ j = $ m - 1 ; $ j >= 0 && $ arr1 [ $ j ] > $ arr2 [ $ i ] ; $ j -- ) $ arr1 [ $ j + 1 ] = $ arr1 [ $ j ] ; if ( $ j != $ m - 2 $ last > $ arr2 [ $ i ] ) { $ arr1 [ $ j + 1 ] = $ arr2 [ $ i ] ; $ arr2 [ $ i ] = $ last ; } } } merge ( $ arr1 . length , $ arr2 . length ) ; echo " Result ▁ is ▁ STRNEWLINE " ; for ( $ i = 0 ; $ i < strlen ( $ arr1 ) ; $ i ++ ) { echo $ arr1 [ $ i ] . " ▁ " ; } echo " STRNEWLINE " ; }

BLEU: 55.65
Edit Sim: 249


Src: 
function evenSum ( n ) { let curr = 2 , sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { sum += curr ; curr += 2 ; } return sum ; }
Ref: 
function evenSum ( $ n ) { $ curr = 2 ; $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ sum += $ curr ; $ curr += 2 ; } return $ sum ; }
Hyp: 
function evenSum ( $ n ) { $ curr = 2 ; $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ sum += $ curr ; $ curr += 2 ; } return $ sum ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function lastNon0Digit ( n ) { if ( n < 10 ) return dig [ n ] ; if ( ( parseInt ( n / 10 , 10 ) % 10 ) % 2 == 0 ) return ( 6 * lastNon0Digit ( parseInt ( n / 5 , 10 ) ) * dig [ n % 10 ] ) % 10 ; else return ( 4 * lastNon0Digit ( parseInt ( n / 5 , 10 ) ) * dig [ n % 10 ] ) % 10 ; }
Ref: 
function lastNon0Digit ( $ n ) { global $ dig ; if ( $ n < 10 ) return $ dig [ $ n ] ; if ( ( ( $ n / 10 ) % 10 ) % 2 == 0 ) return ( 6 * lastNon0Digit ( $ n / 5 ) * $ dig [ $ n % 10 ] ) % 10 ; else return ( 4 * lastNon0Digit ( $ n / 5 ) * $ dig [ $ n % 10 ] ) % 10 ; }
Hyp: 
function lastNon0Digit ( $ n ) { if ( $ n < 10 ) return $ dig [ $ n ] ; if ( ( ( int ) ( $ n / 10 ) % 10 ) % 2 == 0 ) return ( 6 * lastNon0Digit ( $ n / 5 ) ) * $ dig [ $ n % 10 ] ) % 10 ; else return ( 4 * lastNon0Digit ( $ n / 5 ) ) * $ dig [ $ n % 10 ] ) % 10 ; }

BLEU: 90.51
Edit Sim: 27


Src: 
function isDivisible ( n ) { temp = n ; sum = 0 ; while ( n ) { k = n % 10 ; sum += k ; n = parseInt ( n / 10 ) ; } if ( temp % sum == 0 ) return " " ; return " " ; }
Ref: 
function isDivisible ( $ n ) { $ temp = $ n ; $ sum = 0 ; while ( $ n ) { $ k = $ n % 10 ; $ sum += $ k ; $ n = ( int ) ( $ n / 10 ) ; } if ( $ temp % $ sum == 0 ) return " YES " ; return " NO " ; }
Hyp: 
function isDivisible ( $ n ) { $ temp = $ n ; $ sum = 0 ; while ( $ n ) { $ k = $ n % 10 ; $ sum += $ k ; $ n = ( int ) ( $ n / 10 ) ; } if ( $ temp % $ sum == 0 ) return " Alice " ; return " Bob " ; }

BLEU: 93.0
Edit Sim: 8


Src: 
function isSumDivides ( N ) { var temp = N ; var sum = 0 ; while ( temp > 0 ) { sum += temp % 10 ; temp = parseInt ( temp / 10 ) ; } if ( N % sum == 0 ) return 1 ; else return 0 ; }
Ref: 
function isSumDivides ( $ N ) { $ temp = $ N ; $ sum = 0 ; while ( $ temp ) { $ sum += $ temp % 10 ; $ temp = ( int ) $ temp / 10 ; } if ( $ N % $ sum == 0 ) return 1 ; else return 0 ; }
Hyp: 
function isSumDivides ( $ N ) { $ temp = $ N ; $ sum = 0 ; while ( $ temp > 0 ) { $ sum += $ temp % 10 ; $ temp = ( int ) ( $ temp / 10 ) ; } if ( $ N % $ sum == 0 ) return 1 ; else return 0 ; }

BLEU: 86.77
Edit Sim: 8


Src: 
function findLength ( str , n ) { let current_sum = 0 ; let max_sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { current_sum += ( str [ i ] == ' ' ? 1 : - 1 ) ; if ( current_sum < 0 ) { current_sum = 0 ; } max_sum = Math . max ( current_sum , max_sum ) ; } return max_sum == 0 ? - 1 : max_sum ; }
Ref: 
function findLength ( $ str , $ n ) { $ current_sum = 0 ; $ max_sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ current_sum += ( $ str [ $ i ] == '0' ? 1 : -1 ) ; if ( $ current_sum < 0 ) $ current_sum = 0 ; $ max_sum = max ( $ current_sum , $ max_sum ) ; } return $ max_sum == 0 ? -1 : $ max_sum ; }
Hyp: 
function findLength ( $ str , $ n ) { $ current_sum = 0 ; $ max_sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ current_sum += ( $ str [ $ i ] == '1' ? 1 : -1 ) ; if ( $ current_sum < 0 ) { $ current_sum = 0 ; } $ max_sum = max ( $ current_sum , $ max_sum ) ; } return $ max_sum == 0 ? -1 : $ max_sum ; }

BLEU: 91.95
Edit Sim: 5


Src: 
function seriesSum ( calculated , current , N ) { let i , cur = 1 ; if ( current == N + 1 ) return 0 ; for ( i = calculated ; i < calculated + current ; i ++ ) cur *= i ; return cur + seriesSum ( i , current + 1 , N ) ; }
Ref: 
function seriesSum ( $ calculated , $ current , $ N ) { $ i ; $ cur = 1 ; if ( $ current == $ N + 1 ) return 0 ; for ( $ i = $ calculated ; $ i < $ calculated + $ current ; $ i ++ ) $ cur *= $ i ; return $ cur + seriesSum ( $ i , $ current + 1 , $ N ) ; }
Hyp: 
function seriesSum ( $ calculated , $ current , $ N ) { $ cur = 1 ; if ( $ current == $ N + 1 ) return 0 ; for ( $ i = $ calculated ; $ i < $ calculated + $ current ; $ i ++ ) $ cur *= $ i ; return $ cur + seriesSum ( $ i , $ current + 1 , $ N ) ; }

BLEU: 95.22
Edit Sim: 6


Src: 
function findCount ( arr , n ) { var countOdd = 0 ; for ( var i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 == 1 ) countOdd ++ ; if ( countOdd % 2 == 0 ) return 1 ; else return 0 ; }
Ref: 
function findCount ( $ arr , $ n ) { $ countOdd = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] % 2 == 1 ) $ countOdd ++ ; if ( $ countOdd % 2 == 0 ) return 1 ; else return 0 ; }
Hyp: 
function findCount ( $ arr , $ n ) { $ countOdd = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] % 2 == 1 ) $ countOdd ++ ; if ( $ countOdd % 2 == 0 ) return 1 ; else return 0 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function matrixSum ( arr ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = 0 ; j < n ; j ++ ) { let top_left = ( i + 1 ) * ( j + 1 ) ; let bottom_right = ( n - i ) * ( n - j ) ; sum += ( top_left * bottom_right * arr [ i ] [ j ] ) ; } return sum ; }
Ref: 
function matrixSum ( $ arr ) { $ n = 3 ; $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { $ top_left = ( $ i + 1 ) * ( $ j + 1 ) ; $ bottom_right = ( $ n - $ i ) * ( $ n - $ j ) ; $ sum += ( $ top_left * $ bottom_right * $ arr [ $ i ] [ $ j ] ) ; } return $ sum ; }
Hyp: 
function matrixSum ( $ arr ) { $ sum = 0 ; $ n = 3 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { $ top_left = ( $ i + 1 ) * ( $ j + 1 ) ; $ bottom_right = ( $ n - $ i ) * ( $ n - $ j ) ; $ sum += ( $ top_left * $ bottom_right * $ arr [ $ i ] [ $ j ] ) ; } return $ sum ; }

BLEU: 97.56
Edit Sim: 8


Src: 
function smallestMultiple ( n ) { if ( n == 1 ) return 5 ; return Math . pow ( 10 , n - 1 ) ; }
Ref: 
function smallestMultiple ( $ n ) { if ( $ n == 1 ) return 5 ; return pow ( 10 , $ n - 1 ) ; }
Hyp: 
function smallestMultiple ( $ n ) { if ( $ n == 1 ) return 5 ; return pow ( 10 , $ n - 1 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function segregate0and1 ( arr , size ) { let type0 = 0 ; let type1 = size - 1 ; while ( type0 < type1 ) { if ( arr [ type0 ] == 1 ) { arr [ type1 ] = arr [ type1 ] + arr [ type0 ] ; arr [ type0 ] = arr [ type1 ] - arr [ type0 ] ; arr [ type1 ] = arr [ type1 ] - arr [ type0 ] ; type1 -- ; } else type0 ++ ; } }
Ref: 
function segregate0and1 ( & $ arr , $ size ) { $ type0 = 0 ; $ type1 = $ size - 1 ; while ( $ type0 < $ type1 ) { if ( $ arr [ $ type0 ] == 1 ) { $ temp = $ arr [ $ type0 ] ; $ arr [ $ type0 ] = $ arr [ $ type1 ] ; $ arr [ $ type1 ] = $ temp ; $ type1 -- ; } else $ type0 ++ ; } }
Hyp: 
function segregate0and1 ( & $ arr , $ size ) { $ type0 = 0 ; $ type1 = $ size - 1 ; while ( $ type0 < $ type1 ) { if ( $ arr [ $ type0 ] == 1 ) { $ arr [ $ type1 ] = $ arr [ $ type1 ] + $ arr [ $ type0 ] ; $ arr [ $ type0 ] = $ arr [ $ type1 ] - $ arr [ $ type0 ] ; $ arr [ $ type1 ] = $ arr [ $ type1 ] - $ arr [ $ type0 ] ; $ type1 -- ; } else $ type0 ++ ; } }

BLEU: 70.84
Edit Sim: 85


Src: 
function findIndex ( n ) { if ( n <= 1 ) return n ; let a = 0 , b = 1 , c = 1 ; let res = 1 ; while ( c < n ) { c = a + b ; res ++ ; a = b ; b = c ; } return res ; }
Ref: 
function findIndex ( $ n ) { if ( $ n <= 1 ) return $ n ; $ a = 0 ; $ b = 1 ; $ c = 1 ; $ res = 1 ; while ( $ c < $ n ) { $ c = $ a + $ b ; $ res ++ ; $ a = $ b ; $ b = $ c ; } return $ res ; }
Hyp: 
function findIndex ( $ n ) { if ( $ n <= 1 ) return $ n ; $ a = 0 ; $ b = 1 ; $ c = 1 ; $ res = 1 ; while ( $ c < $ n ) { $ c = $ a + $ b ; $ res ++ ; $ a = $ b ; $ b = $ c ; } return $ res ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function sum ( n ) { let root = parseInt ( Math . sqrt ( n ) ) ; let ans = 0 ; for ( let i = 1 ; i <= root ; i ++ ) ans += parseInt ( n / i ) ; ans = ( 2 * ans ) - ( root * root ) ; return ans ; }
Ref: 
function sum ( $ n ) { $ root = intval ( sqrt ( $ n ) ) ; $ ans = 0 ; for ( $ i = 1 ; $ i <= $ root ; $ i ++ ) $ ans += intval ( $ n / $ i ) ; $ ans = ( 2 * $ ans ) - ( $ root * $ root ) ; return $ ans ; }
Hyp: 
function sum ( $ n ) { $ root = ( int ) sqrt ( $ n ) ; $ ans = 0 ; for ( $ i = 1 ; $ i <= $ root ; $ i ++ ) $ ans += ( int ) $ n / $ i ; $ ans = ( 2 * $ ans ) - ( $ root * $ root ) ; return $ ans ; }

BLEU: 85.99
Edit Sim: 16


Src: 
function findBucketNo ( p ) { return Math . ceil ( ( Math . sqrt ( 8 * p + 1 ) - 1 ) / 2 ) ; }
Ref: 
function findBucketNo ( $ p ) { return ceil ( ( sqrt ( 8 * $ p + 1 ) - 1 ) / 2 ) ; }
Hyp: 
function findBucketNo ( $ p ) { return ceil ( ( sqrt ( 8 * $ p + 1 ) - 1 ) / 2 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function nthTermOfTheSeries ( n ) { let nthTerm ; if ( n % 2 == 0 ) nthTerm = Math . pow ( n - 1 , 2 ) + n ; else nthTerm = Math . pow ( n + 1 , 2 ) + n ; return nthTerm ; }
Ref: 
function nthTermOfTheSeries ( $ n ) { if ( $ n % 2 == 0 ) $ nthTerm = pow ( $ n - 1 , 2 ) + $ n ; else $ nthTerm = pow ( $ n + 1 , 2 ) + $ n ; return $ nthTerm ; }
Hyp: 
function nthTermOfTheSeries ( $ n ) { if ( $ n % 2 == 0 ) $ nthTerm = pow ( $ n - 1 , 2 ) + $ n ; else $ nthTerm = pow ( $ n + 1 , 2 ) + $ n ; return $ nthTerm ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function OR ( a , n ) { var ans = a [ 0 ] ; for ( var i = 1 ; i < n ; ++ i ) ans |= a [ i ] ; return ans ; }
Ref: 
function O_R ( $ a , $ n ) { $ ans = $ a [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; ++ $ i ) $ ans |= $ a [ $ i ] ; return $ ans ; }
Hyp: 
function OR ( $ a , $ n ) { $ ans = $ a [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; ++ $ i ) $ ans |= $ a [ $ i ] ; return $ ans ; }

BLEU: 96.51
Edit Sim: 1


Src: 
function countXorPair ( arr , n ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i + 1 ; j < n ; j ++ ) if ( ( arr [ i ] ^ arr [ j ] ) % 2 == 1 ) count ++ ; } return count ; }
Ref: 
function countXorPair ( $ arr , $ n ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) if ( ( $ arr [ $ i ] ^ $ arr [ $ j ] ) % 2 == 1 ) $ count ++ ; } return $ count ; }
Hyp: 
function countXorPair ( & $ arr , $ n ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) if ( ( $ arr [ $ i ] ^ $ arr [ $ j ] ) % 2 == 1 ) $ count ++ ; } return $ count ; }

BLEU: 97.05
Edit Sim: 2


Src: 
function printPFsInPairs ( n ) { for ( let i = 1 ; i * i <= n ; i ++ ) if ( n % i == 0 ) document . write ( i + " " + parseInt ( n / i ) + " " ) ; }
Ref: 
function printPFsInPairs ( $ n ) { for ( $ i = 1 ; $ i * $ i <= $ n ; $ i ++ ) if ( $ n % $ i == 0 ) echo $ i . " * " . ▁ $ n ▁ / ▁ $ i ▁ . " " }
Hyp: 
function printPFsInPairs ( $ n ) { for ( $ i = 1 ; $ i * $ i <= $ n ; $ i ++ ) if ( $ n % $ i == 0 ) echo $ i . " , ▁ " . floor ( $ n / $ i ) . " STRNEWLINE " ; }

BLEU: 75.87
Edit Sim: 26


Src: 
function countSubstringWithEqualEnds ( s ) { var result = 0 ; var n = s . length ; var count = Array . from ( { length : MAX_CHAR } , ( _ , i ) => 0 ) ; for ( var i = 0 ; i < n ; i ++ ) count [ s . charAt ( i ) . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; for ( var i = 0 ; i < MAX_CHAR ; i ++ ) result += ( count [ i ] * ( count [ i ] + 1 ) / 2 ) ; return result ; }
Ref: 
function countSubstringWithEqualEnds ( $ s ) { global $ MAX_CHAR ; $ result = 0 ; $ n = strlen ( $ s ) ; $ count = array_fill ( 0 , $ MAX_CHAR , 0 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ count [ ord ( $ s [ $ i ] ) - ord ( ' a ' ) ] ++ ; for ( $ i = 0 ; $ i < $ MAX_CHAR ; $ i ++ ) $ result += ( $ count [ $ i ] * ( $ count [ $ i ] + 1 ) / 2 ) ; return $ result ; }
Hyp: 
function countSubstringWithEqualEnds ( $ s ) { $ result = 0 ; $ n = strlen ( $ s ) ; $ count = array_fill ( 0 , $ n , 0 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ count [ ord ( $ s [ $ i ] ) - 97 ] ++ ; for ( $ i = 0 ; $ i < $ MAX_CHAR ; $ i ++ ) $ result += ( $ count [ $ i ] * ( $ count [ $ i ] + 1 ) / 2 ) ; return $ result ; }

BLEU: 87.15
Edit Sim: 41


Src: 
function areaCircle ( b ) { let area = 3.1415926 * b * b ; return area ; }
Ref: 
function areaCircle ( $ b ) { $ area = $ GLOBALS [ ' pi ' ] * $ b * $ b ; return $ area ; }
Hyp: 
function areaCircle ( $ b ) { $ area = 3.1415926 * $ b * $ b ; return $ area ; }

BLEU: 68.13
Edit Sim: 20


Src: 
function printMinDiffPairs ( arr , n ) { if ( n <= 1 ) return ; arr . sort ( ) ; let minDiff = arr [ 1 ] - arr [ 0 ] ; for ( let i = 2 ; i < n ; i ++ ) minDiff = Math . min ( minDiff , arr [ i ] - arr [ i - 1 ] ) ; for ( let i = 1 ; i < n ; i ++ ) { if ( ( arr [ i ] - arr [ i - 1 ] ) == minDiff ) { document . write ( " " + arr [ i - 1 ] + " " + arr [ i ] + " " ) ; } } }
Ref: 
function printMinDiffPairs ( $ arr , $ n ) { if ( $ n <= 1 ) return ; sort ( $ arr ) ; $ minDiff = $ arr [ 1 ] - $ arr [ 0 ] ; for ( $ i = 2 ; $ i < $ n ; $ i ++ ) $ minDiff = min ( $ minDiff , $ arr [ $ i ] - $ arr [ $ i - 1 ] ) ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) if ( ( $ arr [ $ i ] - $ arr [ $ i - 1 ] ) == $ minDiff ) echo " ( " , $ arr [ $ i - 1 ] , " , ▁ " , $ arr [ $ i ] , " ) , ▁ " ; }
Hyp: 
function printMinDiffPairs ( $ arr , $ n ) { if ( $ n <= 1 ) return ; sort ( $ arr ) ; $ minDiff = $ arr [ 1 ] - $ arr [ 0 ] ; for ( $ i = 2 ; $ i < $ n ; $ i ++ ) $ minDiff = min ( $ minDiff , $ arr [ $ i ] - $ arr [ $ i - 1 ] ) ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( ( $ arr [ $ i ] - $ arr [ $ i - 1 ] ) == $ minDiff ) { echo " ( " , $ arr [ $ i - 1 ] , " , ▁ " , $ arr [ $ i ] , " ) " ; } } }

BLEU: 94.53
Edit Sim: 8


Src: 
function isMultipleOf10 ( n ) { return ( n % 15 == 0 ) ; }
Ref: 
function isMultipleOf10 ( $ n ) { return ( $ n % 15 == 0 ) ; }
Hyp: 
function isMultipleOf10 ( $ n ) { return ( $ n % 15 == 0 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function sumofFactors ( n ) { if ( n % 2 != 0 ) return 0 ; let res = 1 ; for ( let i = 2 ; i <= Math . sqrt ( n ) ; i ++ ) { let count = 0 , curr_sum = 1 ; let curr_term = 1 ; while ( n % i == 0 ) { count ++ ; n = n / i ; if ( i == 2 && count == 1 ) curr_sum = 0 ; curr_term *= i ; curr_sum += curr_term ; } res *= curr_sum ; } if ( n >= 2 ) res *= ( 1 + n ) ; return res ; }
Ref: 
function sumofFactors ( $ n ) { if ( $ n % 2 != 0 ) return 0 ; $ res = 1 ; for ( $ i = 2 ; $ i <= sqrt ( $ n ) ; $ i ++ ) { $ count = 0 ; $ curr_sum = 1 ; $ curr_term = 1 ; while ( $ n % $ i == 0 ) { $ count ++ ; $ n = floor ( $ n / $ i ) ; if ( $ i == 2 && $ count == 1 ) $ curr_sum = 0 ; $ curr_term *= $ i ; $ curr_sum += $ curr_term ; } $ res *= $ curr_sum ; } if ( $ n >= 2 ) $ res *= ( 1 + $ n ) ; return $ res ; }
Hyp: 
function sumofFactors ( $ n ) { if ( $ n % 2 != 0 ) return 0 ; $ res = 1 ; for ( $ i = 2 ; $ i <= sqrt ( $ n ) ; $ i ++ ) { $ count = 0 ; $ curr_sum = 1 ; $ curr_term = 1 ; while ( $ n % $ i == 0 ) { $ count ++ ; $ n = $ n / $ i ; if ( $ i == 2 && $ count == 1 ) $ curr_sum = 0 ; $ curr_term *= $ i ; $ curr_sum += $ curr_term ; } $ res *= $ curr_sum ; } if ( $ n >= 2 ) $ res *= ( 1 + $ n ) ; return $ res ; }

BLEU: 95.84
Edit Sim: 10


Src: 
function longestRodInCuboid ( length , breadth , height ) { let result ; let temp ; temp = length * length + breadth * breadth + height * height ; result = Math . sqrt ( temp ) ; return result ; }
Ref: 
function longestRodInCuboid ( $ length , $ breadth , $ height ) { $ result ; $ temp ; $ temp = $ length * $ length + $ breadth * $ breadth + $ height * $ height ; $ result = sqrt ( $ temp ) ; return $ result ; }
Hyp: 
function longestRodInCuboid ( $ length , $ breadth , $ height ) { $ result ; $ temp ; $ temp = $ length * $ length + $ breadth * $ breadth + $ height * $ height ; $ result = sqrt ( $ temp ) ; return $ result ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function getMinNum ( a , b , c ) { if ( c < a c > b ) return c ; let x = ( parseInt ( b / c ) * c ) + c ; return x ; }
Ref: 
function getMinNum ( $ a , $ b , $ c ) { if ( $ c < $ a $ c > $ b ) return $ c ; $ x = ( floor ( ( $ b / $ c ) ) * $ c ) + $ c ; return $ x ; }
Hyp: 
function getMinNum ( $ a , $ b , $ c ) { if ( $ c < $ a $ c > $ b ) return $ c ; $ x = ( ( $ b / $ c ) * $ c ) + $ c ; return $ x ; }

BLEU: 91.83
Edit Sim: 10


Src: 
function sphereSide ( h , r ) { if ( h < 0 && r < 0 ) return - 1 ; var R = ( ( h * r * Math . sqrt ( 2 ) ) / ( h + Math . sqrt ( 2 ) * r ) ) / 2 ; return R ; }
Ref: 
function sphereSide ( $ h , $ r ) { if ( $ h < 0 && $ r < 0 ) return -1 ; $ R = ( ( $ h * $ r * sqrt ( 2 ) ) / ( $ h + sqrt ( 2 ) * $ r ) ) / 2 ; return $ R ; }
Hyp: 
function sphereSide ( $ h , $ r ) { if ( $ h < 0 && $ r < 0 ) return -1 ; $ R = ( ( $ h * $ r * sqrt ( 2 ) ) / ( $ h + sqrt ( 2 ) * $ r ) ) / 2 ; return $ R ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function Colour_Combination ( s ) { let temp = s [ 0 ] ; for ( let i = 1 ; i < s . length ; i ++ ) { if ( temp != s [ i ] ) { if ( ( temp == ' ' temp == ' ' ) && ( s [ i ] == ' ' s [ i ] == ' ' ) ) temp = ' ' ; else if ( ( temp == ' ' temp == ' ' ) && ( s [ i ] == ' ' s [ i ] == ' ' ) ) temp = ' ' ; else temp = ' ' ; } } return temp ; }
Ref: 
function Colour_Combination ( $ s ) { $ temp = $ s [ 0 ] ; for ( $ i = 1 ; $ i < strlen ( $ s ) ; $ i ++ ) { if ( $ temp != $ s [ $ i ] ) { if ( ( $ temp == ' B ' $ temp == ' G ' ) && ( $ s [ $ i ] == ' G ' $ s [ $ i ] == ' B ' ) ) $ temp = ' Y ' ; else if ( ( $ temp == ' B ' $ temp == ' Y ' ) && ( $ s [ $ i ] == ' Y ' $ s [ $ i ] == ' B ' ) ) $ temp = ' G ' ; else $ temp = ' B ' ; } } return $ temp ; }
Hyp: 
function Colour_Combination ( $ s ) { $ temp = $ s [ 0 ] ; for ( $ i = 1 ; $ i < strlen ( $ s ) ; $ i ++ ) { if ( $ temp != $ s [ $ i ] ) { if ( ( $ temp == '0' $ temp == '1' ) && ( $ s [ $ i ] == '2' $ s [ $ i ] == '3' ) ) $ temp = '1' ; else if ( ( $ temp == '0' $ temp == '1' ) && ( $ s [ $ i ] == '5' $ s [ $ i ] == '7' ) ) $ temp = '0' ; else $ temp = '1' ; } } return $ temp ; }

BLEU: 67.7
Edit Sim: 33


Src: 
function line ( x0 , y0 ) { var c = parseInt ( 2 * y0 * x0 ) ; document . write ( y0 + " " + " " + x0 + " " + c ) ; }
Ref: 
function line ( $ x0 , $ y0 ) { $ c = 2 * $ y0 * $ x0 ; echo $ y0 , " x " , " ▁ + ▁ " , $ x0 , " y ▁ = ▁ " , $ c ; }
Hyp: 
function line ( $ x0 , $ y0 ) { $ c = ( int ) ( 2 * $ y0 * $ x0 ) ; echo ( $ y0 . " , ▁ " . $ x0 . " , ▁ " . $ c ) ; }

BLEU: 47.38
Edit Sim: 35


Src: 
function isDefeat ( s1 , s2 , n ) { for ( let i = 0 ; i < n ; i ++ ) { if ( ( s1 [ i ] == ' ' && s2 [ i ] == ' ' ) || ( s1 [ i ] == ' ' && s2 [ i ] == ' ' ) ) continue ; else if ( ( s1 [ i ] == ' ' && s2 [ i ] == ' ' ) || ( s1 [ i ] == ' ' && s2 [ i ] == ' ' ) ) continue ; else { return true ; } } return false ; }
Ref: 
function isDefeat ( $ s1 , $ s2 , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( ( $ s1 [ $ i ] == '0' && $ s2 [ $ i ] == '1' ) || ( $ s1 [ $ i ] == '1' && $ s2 [ $ i ] == '0' ) ) continue ; else if ( ( $ s1 [ $ i ] == '0' && $ s2 [ $ i ] == ' Z ' ) || ( $ s1 [ $ i ] == ' Z ' && $ s2 [ $ i ] == '0' ) ) continue ; else { return true ; } } return false ; }
Hyp: 
function isDefeat ( $ s1 , $ s2 , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( ( $ s1 [ $ i ] == '0' && $ s2 [ $ i ] == '1' ) or ( $ s1 [ $ i ] == '2' && $ s2 [ $ i ] == '0' ) ) continue ; else if ( ( $ s1 [ $ i ] == '0' && $ s2 [ $ i ] == '1' ) or ( $ s1 [ $ i ] == '3' && $ s2 [ $ i ] == '5' ) ) continue ; else { return true ; } } return false ; }

BLEU: 86.99
Edit Sim: 12


Src: 
function smallestGreater ( arr , n ) { for ( let i = 0 ; i < n ; i ++ ) { let diff = Number . MAX_VALUE ; let closest = - 1 ; for ( let j = 0 ; j < n ; j ++ ) { if ( arr [ i ] < arr [ j ] && arr [ j ] - arr [ i ] < diff ) { diff = arr [ j ] - arr [ i ] ; closest = j ; } } if ( closest == - 1 ) document . write ( " " ) ; else document . write ( arr [ closest ] + " " ) ; } }
Ref: 
function smallestGreater ( $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ diff = PHP_INT_MAX ; $ closest = -1 ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ arr [ $ i ] < $ arr [ $ j ] && $ arr [ $ j ] - $ arr [ $ i ] < $ diff ) { $ diff = $ arr [ $ j ] - $ arr [ $ i ] ; $ closest = $ j ; } } if ( $ closest == -1 ) echo " _ ▁ " ; else echo $ arr [ $ closest ] , " ▁ " ; } }
Hyp: 
function smallestGreater ( $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ diff = PHP_INT_MAX ; $ closest = -1 ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ arr [ $ i ] < $ arr [ $ j ] && $ arr [ $ j ] - $ arr [ $ i ] < $ diff ) { $ diff = $ arr [ $ j ] - $ arr [ $ i ] ; $ closest = $ j ; } } if ( $ closest == -1 ) echo $ arr [ $ closest ] . " ▁ " ; else echo $ arr [ $ closest ] . " ▁ " ; } }

BLEU: 92.06
Edit Sim: 23


Src: 
function countP ( n , k ) { let dp = new Array ( n + 1 ) ; for ( let i = 0 ; i < n + 1 ; i ++ ) { dp [ i ] = new Array ( k + 1 ) ; for ( let j = 0 ; j < k + 1 ; j ++ ) { dp [ i ] [ j ] = - 1 ; } } for ( let i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = 0 ; for ( let i = 0 ; i <= k ; i ++ ) dp [ 0 ] [ k ] = 0 ; for ( let i = 1 ; i <= n ; i ++ ) for ( let j = 1 ; j <= k ; j ++ ) if ( j == 1 i == j ) dp [ i ] [ j ] = 1 ; else dp [ i ] [ j ] = j * dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] ; return dp [ n ] [ k ] ; }
Ref: 
function countP ( $ n , $ k ) { $ dp [ $ n + 1 ] [ $ k + 1 ] = array ( array ( ) ) ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) $ dp [ $ i ] [ 0 ] = 0 ; for ( $ i = 0 ; $ i <= $ k ; $ i ++ ) $ dp [ 0 ] [ $ k ] = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) for ( $ j = 1 ; $ j <= $ i ; $ j ++ ) if ( $ j == 1 $ i == $ j ) $ dp [ $ i ] [ $ j ] = 1 ; else $ dp [ $ i ] [ $ j ] = $ j * $ dp [ $ i - 1 ] [ $ j ] + $ dp [ $ i - 1 ] [ $ j - 1 ] ; return $ dp [ $ n ] [ $ k ] ; }
Hyp: 
function countP ( $ n , $ k ) { $ dp = array_fill ( 0 , $ n + 1 , array_fill ( 0 , $ k + 1 , NULL ) ) ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) $ dp [ $ i ] [ 0 ] = 0 ; for ( $ i = 0 ; $ i <= $ k ; $ i ++ ) $ dp [ 0 ] [ $ k ] = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) for ( $ j = 1 ; $ j <= $ k ; $ j ++ ) if ( $ j == 1 $ i == $ j ) $ dp [ $ i ] [ $ j ] = 1 ; else $ dp [ $ i ] [ $ j ] = $ j * $ dp [ $ i - 1 ] [ $ j ] + $ dp [ $ i - 1 ] [ $ j - 1 ] ; return $ dp [ $ n ] [ $ k ] ; }

BLEU: 91.15
Edit Sim: 41


Src: 
function print ( n , k ) { let rem = 1 ; let ans = ' ' ; for ( let i = 0 ; i < k ; i ++ ) { ans += Math . floor ( ( ( 10 * rem ) / n ) ) ; rem = ( 10 * rem ) % n ; } document . write ( ans ) }
Ref: 
function println ( $ n , $ k ) { $ rem = 1 ; for ( $ i = 0 ; $ i < $ k ; $ i ++ ) { echo floor ( ( 10 * $ rem ) / $ n ) ; $ rem = ( 10 * $ rem ) % $ n ; } }
Hyp: 
function print ( $ n , $ k ) { $ rem = 1 ; $ ans = '9' ; for ( $ i = 0 ; $ i < $ k ; $ i ++ ) { $ ans += ( int ) ( ( ( 10 * $ rem ) / $ n ) ) ; $ rem = ( 10 * $ rem ) % $ n ; } echo $ ans ; }

BLEU: 70.64
Edit Sim: 48


Src: 
function minOperations ( A , n ) { if ( ( n & 1 ) > 0 ) return - 1 ; let zeros = 0 , consZeros = 0 , ones = 0 ; for ( let i = 0 ; i < n ; ++ i ) { if ( A [ i ] == 0 ) zeros ++ ; else ones ++ ; if ( i + 1 < n ) { if ( A [ i ] == 0 && A [ i + 1 ] == 0 ) consZeros ++ ; } } if ( A [ 0 ] == A [ n - 1 ] && A [ 0 ] == 0 ) consZeros ++ ; if ( zeros == ones ) return consZeros ; else return - 1 ; }
Ref: 
function minOperations ( $ A , $ n ) { if ( $ n & 1 ) return -1 ; $ zeros = 0 ; $ consZeros = 0 ; $ ones = 0 ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { $ A [ $ i ] == 0 ? $ zeros ++ : $ ones ++ ; if ( ( $ i + 1 ) < $ n ) { if ( $ A [ $ i ] == 0 && $ A [ $ i + 1 ] == 0 ) $ consZeros ++ ; } } if ( $ A [ 0 ] == $ A [ $ n - 1 ] && $ A [ 0 ] == 0 ) $ consZeros ++ ; if ( $ zeros == $ ones ) return $ consZeros ; else return -1 ; }
Hyp: 
function minOperations ( $ A , $ n ) { if ( ( $ n & 1 ) ) return -1 ; $ zeros = 0 ; $ consZeros = 0 ; $ ones = 0 ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { if ( $ A [ $ i ] == 0 ) $ zeros ++ ; else $ ones ++ ; if ( $ i + 1 < $ n ) { if ( $ A [ $ i ] == 0 and $ A [ $ i + 1 ] == 0 ) $ consZeros ++ ; } } if ( $ A [ 0 ] == $ A [ $ n - 1 ] and $ A [ 0 ] == 0 ) $ consZeros ++ ; if ( $ zeros == $ ones ) return $ consZeros ; else return -1 ; }

BLEU: 88.34
Edit Sim: 26


Src: 
function aliquotSum ( n ) { let sum = 0 ; for ( let i = 1 ; i < n ; i ++ ) if ( n % i == 0 ) sum += i ; return sum ; }
Ref: 
function aliquotSum ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) if ( $ n % $ i == 0 ) $ sum += $ i ; return $ sum ; }
Hyp: 
function aliquotSum ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) if ( $ n % $ i == 0 ) $ sum += $ i ; return $ sum ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countRectangles ( radius ) { let rectangles = 0 ; let diameter = 2 * radius ; let diameterSquare = diameter * diameter ; for ( let a = 1 ; a < 2 * radius ; a ++ ) { for ( let b = 1 ; b < 2 * radius ; b ++ ) { let diagonalLengthSquare = ( a * a + b * b ) ; if ( diagonalLengthSquare <= diameterSquare ) { rectangles ++ ; } } } return rectangles ; }
Ref: 
function countRectangles ( $ radius ) { $ rectangles = 0 ; $ diameter = 2 * $ radius ; $ diameterSquare = $ diameter * $ diameter ; for ( $ a = 1 ; $ a < 2 * $ radius ; $ a ++ ) { for ( $ b = 1 ; $ b < 2 * $ radius ; $ b ++ ) { $ diagonalLengthSquare = ( $ a * $ a + $ b * $ b ) ; if ( $ diagonalLengthSquare <= $ diameterSquare ) { $ rectangles ++ ; } } } return $ rectangles ; }
Hyp: 
function countRectangles ( $ radius ) { $ rectangles = 0 ; $ diameter = 2 * $ radius ; $ diameterSquare = $ diameter * $ diameter ; for ( $ a = 1 ; $ a < 2 * $ radius ; $ a ++ ) { for ( $ b = 1 ; $ b < 2 * $ radius ; $ b ++ ) { $ diagonalLengthSquare = ( $ a * $ a + $ b * $ b ) ; if ( $ diagonalLengthSquare <= $ diameterSquare ) { $ rectangles ++ ; } } } return $ rectangles ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function maxSum ( arr , n , K ) { var maximum = - 1000000000 ; for ( var i = 0 ; i < n ; i ++ ) { var sumk = 0 ; for ( var j = i ; j < n ; j += K ) sumk = sumk + arr [ j ] ; maximum = Math . max ( maximum , sumk ) ; } return maximum ; }
Ref: 
function maxSum ( $ arr , $ n , $ K ) { $ maximum = PHP_INT_MIN ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sumk = 0 ; for ( $ j = $ i ; $ j < $ n ; $ j += $ K ) $ sumk = $ sumk + $ arr [ $ j ] ; $ maximum = max ( $ maximum , $ sumk ) ; } return $ maximum ; }
Hyp: 
function maxSum ( $ arr , $ n , $ K ) { $ maximum = PHP_INT_MIN ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sumk = 0 ; for ( $ j = $ i ; $ j < $ n ; $ j += $ K ) $ sumk = $ sumk + $ arr [ $ j ] ; $ maximum = max ( $ maximum , $ sumk ) ; } return $ maximum ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function LIS ( a , n ) { let dp = new Array ( ) ; let d = new Array ( ) ; let ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) { dp [ a [ i ] ] = 1 ; for ( j = 2 ; j * j <= a [ i ] ; j ++ ) { if ( a [ i ] % j == 0 ) { dp [ a [ i ] ] = Math . max ( dp [ a [ i ] ] , dp [ d [ j ] ] + 1 ) ; dp [ a [ i ] ] = Math . max ( dp [ a [ i ] ] , dp [ d [ a [ i ] / j ] ] + 1 ) ; d [ j ] = a [ i ] ; d [ a [ i ] / j ] = a [ i ] ; } } ans = Math . max ( ans , dp [ a [ i ] ] ) ; d [ a [ i ] ] = a [ i ] ; } return ans ; }
Ref: 
function LIS ( $ a , $ n ) { $ dp = array ( ) ; $ d = array ( ) ; $ ans = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ dp [ $ a [ $ i ] ] = 1 ; for ( $ j = 2 ; $ j * $ j <= $ a [ $ i ] ; $ j ++ ) { if ( $ a [ $ i ] % $ j == 0 ) { $ dp [ $ a [ $ i ] ] = max ( $ dp [ $ a [ $ i ] ] , $ dp [ $ d [ $ j ] ] + 1 ) ; $ dp [ $ a [ $ i ] ] = max ( $ dp [ $ a [ $ i ] ] , $ dp [ $ d [ $ a [ $ i ] / $ j ] ] + 1 ) ; $ d [ $ j ] = $ a [ $ i ] ; $ d [ $ a [ $ i ] / $ j ] = $ a [ $ i ] ; } } $ ans = max ( $ ans , $ dp [ $ a [ $ i ] ] ) ; $ d [ $ a [ $ i ] ] = $ a [ $ i ] ; } return $ ans ; }
Hyp: 
function LIS ( $ a , $ n ) { $ dp = array ( ) ; $ d = array ( ) ; $ ans = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ dp [ $ a [ $ i ] ] = 1 ; for ( $ j = 2 ; $ j * $ j <= $ a [ $ i ] ; $ j ++ ) { if ( $ a [ $ i ] % $ j == 0 ) { $ dp [ $ a [ $ i ] ] = max ( $ dp [ $ a [ $ i ] ] , $ dp [ $ d [ $ j ] ] + 1 ) ; $ dp [ $ a [ $ i ] ] = max ( $ dp [ $ a [ $ i ] ] , $ dp [ $ d [ $ j ] ] + 1 ) ; $ d [ $ j ] = $ a [ $ i ] ; $ d [ $ a [ $ i ] / $ j ] = $ a [ $ i ] ; } } $ ans = max ( $ ans , $ dp [ $ a [ $ i ] ] ) ; $ d [ $ a [ $ i ] ] = $ a [ $ i ] ; } return $ ans ; }

BLEU: 97.03
Edit Sim: 14


Src: 
function steps ( N , M ) { if ( N == 1 ) return 0 ; return M ; return 2 * M + ( N - 3 ) ; }
Ref: 
function steps ( $ N , $ M ) { if ( $ N == 1 ) return 0 ; return $ M ; return 2 * $ M + ( $ N - 3 ) ; }
Hyp: 
function steps ( $ N , $ M ) { if ( $ N == 1 ) return 0 ; return $ M ; return 2 * $ M + ( $ N - 3 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findUnique ( a , n , k ) { let sizeof_let = 4 ; let LET_SIZE = 8 * sizeof_let ; let count = Array . from ( { length : LET_SIZE } , ( _ , i ) => 0 ) ; for ( let i = 0 ; i < LET_SIZE ; i ++ ) for ( let j = 0 ; j < n ; j ++ ) if ( ( a [ j ] & ( 1 << i ) ) != 0 ) count [ i ] += 1 ; let res = 0 ; for ( let i = 0 ; i < LET_SIZE ; i ++ ) res += ( count [ i ] % k ) * ( 1 << i ) ; return res ; }
Ref: 
function findUnique ( $ a , $ n , $ k ) { $ INT_SIZE = 8 * PHP_INT_SIZE ; $ count = array ( ) ; for ( $ i = 0 ; $ i < $ INT_SIZE ; $ i ++ ) $ count [ $ i ] = 0 ; for ( $ i = 0 ; $ i < $ INT_SIZE ; $ i ++ ) for ( $ j = 0 ; $ j < $ n ; $ j ++ ) if ( ( $ a [ $ j ] & ( 1 << $ i ) ) != 0 ) $ count [ $ i ] += 1 ; $ res = 0 ; for ( $ i = 0 ; $ i < $ INT_SIZE ; $ i ++ ) $ res += ( $ count [ $ i ] % $ k ) * ( 1 << $ i ) ; return $ res ; }
Hyp: 
function findUnique ( $ a , $ n , $ k ) { $ sizeof_let = 4 ; $ LET_SIZE = 8 * $ sizeof_let ; $ count = array_fill ( 0 , $ LET_SIZE , 0 ) ; for ( $ i = 0 ; $ i < $ LET_SIZE ; $ i ++ ) for ( $ j = 0 ; $ j < $ n ; $ j ++ ) if ( ( $ a [ $ j ] & ( 1 << $ i ) ) != 0 ) $ count [ $ i ] += 1 ; $ res = 0 ; for ( $ i = 0 ; $ i < $ LET_SIZE ; $ i ++ ) $ res += ( $ count [ $ i ] % $ k ) * ( 1 << $ i ) ; return $ res ; }

BLEU: 76.85
Edit Sim: 88


Src: 
function get_maximum ( s , a ) { let n = s . length ; for ( let i = 0 ; i < n ; i ++ ) { if ( s [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) < a [ s [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ] ) { let j = i ; while ( j < n && ( s [ j ] . charCodeAt ( ) - ' ' . charCodeAt ( ) <= a [ s [ j ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ] ) ) { s [ j ] = String . fromCharCode ( ' ' . charCodeAt ( ) + a [ s [ j ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ] ) ; j ++ ; } return s . join ( " " ) ; } } return s . join ( " " ) ; }
Ref: 
function get_maximum ( $ s , $ a ) { $ n = strlen ( $ s ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ s [ $ i ] - '0' < $ a [ $ s [ $ i ] - '0' ] ) { $ j = $ i ; while ( $ j < $ n && ( $ s [ $ j ] - '0' <= $ a [ $ s [ $ j ] - '0' ] ) ) { $ s [ $ j ] = '0' + $ a [ $ s [ $ j ] - '0' ] ; $ j ++ ; } return $ s ; } } return $ s ; }
Hyp: 
function get_maximum ( $ s , $ a ) { $ n = strlen ( $ s ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( ord ( $ s [ $ i ] ) - ord ( '0' ) < $ a [ ord ( $ s [ $ i ] ) - ord ( '0' ) ] ) { $ j = $ i ; while ( $ j < $ n && ( $ s [ $ j ] ) - ord ( '0' ) <= $ a [ ord ( $ s [ $ j ] ) - ord ( ' A ' ) ] ) ) { $ s [ $ j ] = chr ( 97 + $ a [ ord ( $ s [ $ j ] ) - ord ( ' A ' ) ] ) ; $ j ++ ; } return $ s [ " " ] ; } } return " No " ; }

BLEU: 60.89
Edit Sim: 103


Src: 
function sqroot ( s ) { var pSq = 0 ; var N = 0 ; for ( i = parseInt ( s ) ; i > 0 ; i -- ) { for ( j = 1 ; j < i ; j ++ ) { if ( j * j == i ) { pSq = i ; N = j ; break ; } } if ( pSq > 0 ) break ; } var d = s - pSq ; var P = ( d / ( 2.0 * N ) ) ; var A = N + P ; var sqrt_of_s = A - ( ( P * P ) / ( 2.0 * A ) ) ; return sqrt_of_s ; }
Ref: 
function sqroot ( $ s ) { $ pSq = 0 ; $ N = 0 ; for ( $ i = intval ( $ s ) ; $ i > 0 ; $ i -- ) { for ( $ j = 1 ; $ j < $ i ; $ j ++ ) { if ( $ j * $ j == $ i ) { $ pSq = $ i ; $ N = $ j ; break ; } } if ( $ pSq > 0 ) break ; } $ d = $ s - $ pSq ; $ P = $ d / ( 2.0 * $ N ) ; $ A = $ N + $ P ; $ sqrt_of_s = $ A - ( ( $ P * $ P ) / ( 2.0 * $ A ) ) ; return $ sqrt_of_s ; }
Hyp: 
function sqroot ( $ s ) { $ pSq = 0 ; $ N = 0 ; for ( $ i = intval ( $ s ) ; $ i > 0 ; $ i -- ) { for ( $ j = 1 ; $ j < $ i ; $ j ++ ) { if ( $ j * $ j == $ i ) { $ pSq = $ i ; $ N = $ j ; break ; } } if ( $ pSq > 0 ) break ; } $ d = $ s - $ pSq ; $ P = ( $ d / ( 2.0 * $ N ) ) ; $ A = $ N + $ P ; $ sqrt_of_s = $ A - ( ( $ P * $ P ) / ( 2.0 * $ A ) ) ; return $ sqrt_of_s ; }

BLEU: 97.23
Edit Sim: 4


Src: 
function idstrt ( a1 , b1 , c1 , a2 , b2 , c2 ) { if ( ( a1 / a2 == b1 / b2 ) && ( a1 / a2 == c1 / c2 ) && ( b1 / b2 == c1 / c2 ) ) document . write ( " " + " " ) ; else document . write ( " " + " " ) ; }
Ref: 
function idstrt ( $ a1 , $ b1 , $ c1 , $ a2 , $ b2 , $ c2 ) { if ( ( $ a1 / $ a2 == $ b1 / $ b2 ) && ( $ a1 / $ a2 == $ c1 / $ c2 ) && ( $ b1 / $ b2 == $ c1 / $ c2 ) ) echo " The ▁ given ▁ straight ▁ lines ▁ are ▁ identical " , " STRNEWLINE " ; else echo " The ▁ given ▁ straight ▁ lines ▁ are ▁ not ▁ identical " , " STRNEWLINE " ; }
Hyp: 
function idstrt ( $ a1 , $ b1 , $ c1 , $ a2 , $ b2 , $ c2 ) { if ( ( $ a1 / $ a2 == $ b1 / $ b2 ) && ( $ a1 / $ a2 == $ c1 / $ c2 ) && ( $ b1 / $ b2 == $ c1 / $ c2 ) ) echo " Yes STRNEWLINE " ; else echo " No " ; }

BLEU: 64.8
Edit Sim: 122


Src: 
function printAP ( a , d , n ) { let curr_term ; curr_term = a ; for ( let i = 1 ; i <= n ; i ++ ) { document . write ( curr_term + " " ) ; curr_term = curr_term + d ; } }
Ref: 
function printAP ( $ a , $ d , $ n ) { $ curr_term ; $ curr_term = a ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { echo ( $ curr_term . " " ) ; $ curr_term += $ d ; } }
Hyp: 
function printAP ( $ a , $ d , $ n ) { $ curr_term ; $ curr_term = $ a ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { echo $ curr_term , " " ; $ curr_term = $ curr_term + $ d ; } }

BLEU: 76.69
Edit Sim: 20


Src: 
function printRoots ( a , b , c ) { document . write ( 1 + " " + c / ( a * 1.0 ) ) ; }
Ref: 
function printRoots ( $ a , $ b , $ c ) { echo "1" ; echo " , ▁ " ; echo $ c / ( $ a * 1.0 ) ; }
Hyp: 
function printRoots ( $ a , $ b , $ c ) { echo " A = " , ▁ $ a , ▁ " , B = " , ▁ $ b , ▁ " , C = " , ▁ $ c / ( $ a * 1.0 ) ; }

BLEU: 48.01
Edit Sim: 41


Src: 
function countIntervals ( arr , V , N ) { let min = Number . MAX_VALUE , max = Number . MIN_VALUE ; let li , ri ; let freq = new Array ( MAX_VAL ) ; freq . fill ( 0 ) ; for ( let i = 0 ; i < N ; i ++ ) { li = arr [ i ] [ 0 ] ; freq [ li ] = freq [ li ] + 1 ; ri = arr [ i ] [ 1 ] ; freq [ ri + 1 ] = freq [ ri + 1 ] - 1 ; if ( li < min ) min = li ; if ( ri > max ) max = ri ; } for ( let i = min ; i <= max ; i ++ ) freq [ i ] = freq [ i ] + freq [ i - 1 ] ; return freq [ V ] ; }
Ref: 
function countIntervals ( $ arr , $ V , $ N ) { global $ MAX_VAL ; $ min = PHP_INT_MAX ; $ max = 0 ; $ li = 0 ; $ ri = 0 ; $ freq = array_fill ( 0 , $ MAX_VAL , 0 ) ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { $ li = $ arr [ $ i ] [ 0 ] ; $ freq [ $ li ] = $ freq [ $ li ] + 1 ; $ ri = $ arr [ $ i ] [ 1 ] ; $ freq [ $ ri + 1 ] = $ freq [ $ ri + 1 ] - 1 ; if ( $ li < $ min ) $ min = $ li ; if ( $ ri > $ max ) $ max = $ ri ; } for ( $ i = $ min ; $ i <= $ max ; $ i ++ ) $ freq [ $ i ] = $ freq [ $ i ] + $ freq [ $ i - 1 ] ; return $ freq [ $ V ] ; }
Hyp: 
function countIntervals ( $ arr , $ V , $ N ) { $ min = PHP_INT_MAX ; $ max = PHP_INT_MIN ; $ freq = array_fill ( 0 , $ MAX_VAL , 0 ) ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { $ li = $ arr [ $ i ] [ 0 ] ; $ freq [ $ li ] = $ freq [ $ li ] + 1 ; $ ri = $ arr [ $ i ] [ 1 ] ; $ freq [ $ ri + 1 ] = $ freq [ $ ri + 1 ] - 1 ; if ( $ li < $ min ) $ min = $ li ; if ( $ ri > $ max ) $ max = $ ri ; } for ( $ i = $ min ; $ i <= $ max ; $ i ++ ) $ freq [ $ i ] = $ freq [ $ i ] + $ freq [ $ i - 1 ] ; return $ freq [ $ V ] ; }

BLEU: 91.15
Edit Sim: 42


Src: 
function subset ( ar , n ) { let res = 0 ; ar . sort ( ) ; for ( let i = 0 ; i < n ; i ++ ) { let count = 1 ; for ( ; i < n - 1 ; i ++ ) { if ( ar [ i ] == ar [ i + 1 ] ) count ++ ; else break ; } res = Math . max ( res , count ) ; } return res ; }
Ref: 
function subset ( $ ar , $ n ) { $ res = 0 ; sort ( $ ar ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ count = 1 ; for ( ; $ i < $ n - 1 ; $ i ++ ) { if ( $ ar [ $ i ] == $ ar [ $ i + 1 ] ) $ count ++ ; else break ; } $ res = max ( $ res , $ count ) ; } return $ res ; }
Hyp: 
function subset ( $ ar , $ n ) { $ res = 0 ; sort ( $ ar ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ count = 1 ; for ( ; $ i < $ n - 1 ; $ i ++ ) { if ( $ ar [ $ i ] == $ ar [ $ i + 1 ] ) $ count ++ ; else break ; } $ res = max ( $ res , $ count ) ; } return $ res ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function leastValue ( P , A , N , a ) { let ans = - 1 ; let tmp = Number . MAX_VALUE ; for ( let i = 0 ; i < N ; i ++ ) { let t = ( P - a [ i ] * 0.006 ) ; if ( Math . abs ( t - A ) < tmp ) { tmp = Math . abs ( t - A ) ; ans = i ; } } return a [ ans ] ; }
Ref: 
function leastValue ( $ P , $ A , $ N , $ a ) { $ ans = -1 ; $ tmp = PHP_INT_MAX ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { $ t = $ P - $ a [ $ i ] * 0.006 ; if ( abs ( $ t - $ A ) < $ tmp ) { $ tmp = abs ( $ t - $ A ) ; $ ans = $ i ; } } return $ a [ $ ans ] ; }
Hyp: 
function leastValue ( $ P , $ A , $ N , $ a ) { $ ans = -1 ; $ tmp = PHP_INT_MAX ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { $ t = ( $ P - $ a [ $ i ] * 0.006 ) ; if ( abs ( $ t - $ A ) < $ tmp ) { $ tmp = abs ( $ t - $ A ) ; $ ans = $ i ; } } return $ a [ $ ans ] ; }

BLEU: 95.17
Edit Sim: 4


Src: 
function isLucky ( n ) { var arr = Array ( 10 ) . fill ( 0 ) ; for ( var i = 0 ; i < 10 ; i ++ ) arr [ i ] = false ; while ( n > 0 ) { var digit = n % 10 ; if ( arr [ digit ] ) return false ; arr [ digit ] = true ; n = parseInt ( n / 10 ) ; } return true ; }
Ref: 
function isLucky ( $ n ) { $ arr = array ( ) ; for ( $ i = 0 ; $ i < 10 ; $ i ++ ) $ arr [ $ i ] = false ; while ( $ n > 0 ) { $ digit = $ n % 10 ; if ( $ arr [ $ digit ] ) return false ; $ arr [ $ digit ] = true ; $ n = ( int ) ( $ n / 10 ) ; } return true ; }
Hyp: 
function isLucky ( $ n ) { $ arr = array_fill ( 0 , 10 , false ) ; for ( $ i = 0 ; $ i < 10 ; $ i ++ ) $ arr [ $ i ] = false ; while ( $ n > 0 ) { $ digit = $ n % 10 ; if ( $ arr [ $ digit ] ) return false ; $ arr [ $ digit ] = true ; $ n = ( int ) $ n / 10 ; } return true ; }

BLEU: 88.21
Edit Sim: 24


Src: 
function countSubsequences ( s ) { let aCount = 0 ; let bCount = 0 ; let cCount = 0 ; for ( let i = 0 ; i < s . length ; i ++ ) { if ( s [ i ] == ' ' ) aCount = ( 1 + 2 * aCount ) ; else if ( s [ i ] == ' ' ) bCount = ( aCount + 2 * bCount ) ; else if ( s [ i ] == ' ' ) cCount = ( bCount + 2 * cCount ) ; } return cCount ; }
Ref: 
function countSubsequences ( $ s ) { $ aCount = 0 ; $ bCount = 0 ; $ cCount = 0 ; for ( $ i = 0 ; $ i < strlen ( $ s ) ; $ i ++ ) { if ( $ s [ $ i ] == ' a ' ) $ aCount = ( 1 + 2 * $ aCount ) ; else if ( $ s [ $ i ] == ' b ' ) $ bCount = ( $ aCount + 2 * $ bCount ) ; else if ( $ s [ $ i ] == ' c ' ) $ cCount = ( $ bCount + 2 * $ cCount ) ; } return $ cCount ; }
Hyp: 
function countSubsequences ( $ s ) { $ aCount = 0 ; $ bCount = 0 ; $ cCount = 0 ; for ( $ i = 0 ; $ i < strlen ( $ s ) ; $ i ++ ) { if ( $ s [ $ i ] == ' ( ' ) $ aCount = ( 1 + 2 * $ aCount ) ; else if ( $ s [ $ i ] == ' ) ' ) $ bCount = ( $ aCount + 2 * $ bCount ) ; else if ( $ s [ $ i ] == ' ) ' ) $ cCount = ( $ bCount + 2 * $ cCount ) ; } return $ cCount ; }

BLEU: 94.06
Edit Sim: 3


Src: 
function isPrime ( p ) { let checkNumber = Math . pow ( 2 , p ) - 1 ; let nextval = 4 % checkNumber ; for ( let i = 1 ; i < p - 1 ; i ++ ) nextval = ( nextval * nextval - 2 ) % checkNumber ; return ( nextval == 0 ) ; }
Ref: 
function isPrime ( $ p ) { $ checkNumber = pow ( 2 , $ p ) - 1 ; $ nextval = 4 % $ checkNumber ; for ( $ i = 1 ; $ i < $ p - 1 ; $ i ++ ) $ nextval = ( $ nextval * $ nextval - 2 ) % $ checkNumber ; return ( $ nextval == 0 ) ; }
Hyp: 
function isPrime ( $ p ) { $ checkNumber = pow ( 2 , $ p ) - 1 ; $ nextval = 4 % $ checkNumber ; for ( $ i = 1 ; $ i < $ p - 1 ; $ i ++ ) $ nextval = ( $ nextval * $ nextval - 2 ) % $ checkNumber ; return ( $ nextval == 0 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function power ( x , y , p ) { let res = 1 ; x = x % p ; while ( y > 0 ) { if ( y % 2 == 1 ) { res = ( res * x ) % p ; } x = ( x * x ) % p ; } return res ; }
Ref: 
function power ( $ x , $ y , $ p ) { $ res = 1 ; $ x = $ x % $ p ; while ( $ y > 0 ) { if ( $ y & 1 ) $ res = ( $ res * $ x ) % $ p ; $ x = ( $ x * $ x ) % $ p ; } return $ res ; }
Hyp: 
function power ( $ x , $ y , $ p ) { $ res = 1 ; $ x = $ x % $ p ; while ( $ y > 0 ) { if ( $ y % 2 == 1 ) { $ res = ( $ res * $ x ) % $ p ; } $ x = ( $ x * $ x ) % $ p ; } return $ res ; }

BLEU: 88.22
Edit Sim: 10


Src: 
function printClosest ( arr , n , x ) { let res_l = 0 , res_r = 0 ; let l = 0 , r = n - 1 , diff = Number . MAX_VALUE ; while ( r > l ) { if ( Math . abs ( arr [ l ] + arr [ r ] - x ) < diff ) { res_l = l ; res_r = r ; diff = Math . abs ( arr [ l ] + arr [ r ] - x ) ; } if ( arr [ l ] + arr [ r ] > x ) r -- ; else l ++ ; } document . write ( " " + arr [ res_l ] + " " + arr [ res_r ] ) ; }
Ref: 
function printClosest ( $ arr , $ n , $ x ) { $ res_l ; $ res_r ; $ l = 0 ; $ r = $ n - 1 ; $ diff = PHP_INT_MAX ; while ( $ r > $ l ) { if ( abs ( $ arr [ $ l ] + $ arr [ $ r ] - $ x ) < $ diff ) { $ res_l = $ l ; $ res_r = $ r ; $ diff = abs ( $ arr [ $ l ] + $ arr [ $ r ] - $ x ) ; } if ( $ arr [ $ l ] + $ arr [ $ r ] > $ x ) $ r -- ; else $ l ++ ; } echo " ▁ The ▁ closest ▁ pair ▁ is ▁ " , $ arr [ $ res_l ] , " ▁ and ▁ " , $ arr [ $ res_r ] ; }
Hyp: 
function printClosest ( $ arr , $ n , $ x ) { $ res_l = 0 ; $ res_r = 0 ; $ l = 0 ; $ r = $ n - 1 ; $ diff = PHP_INT_MAX ; while ( $ r > $ l ) { if ( abs ( $ arr [ $ l ] + $ arr [ $ r ] - $ x ) < $ diff ) { $ res_l = $ l ; $ res_r = $ r ; $ diff = abs ( $ arr [ $ l ] + $ arr [ $ r ] - $ x ) ; } if ( $ arr [ $ l ] + $ arr [ $ r ] > $ x ) $ r -- ; else $ l ++ ; } echo " Closest ▁ is ▁ " , $ arr [ $ res_l ] , " ▁ is ▁ " , $ arr [ $ res_r ] ; }

BLEU: 92.32
Edit Sim: 27


Src: 
function CountCharacters ( str , k ) { let cnt = 0 ; let len = str . length ; for ( let i = 0 ; i < len ; i ++ ) { if ( str [ i ] . charCodeAt ( 0 ) < k ) cnt ++ ; } return cnt ; }
Ref: 
function CountCharacters ( $ str , $ k ) { $ cnt = 0 ; $ len = strlen ( $ str ) ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { if ( $ str [ $ i ] < chr ( $ k ) ) $ cnt += 1 ; } return $ cnt ; }
Hyp: 
function CountCharacters ( $ str , $ k ) { $ cnt = 0 ; $ len = strlen ( $ str ) ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { if ( ord ( $ str [ $ i ] ) < $ k ) $ cnt ++ ; } return $ cnt ; }

BLEU: 85.12
Edit Sim: 17


Src: 
function canTakeDown ( bishopX , bishopY , pawnX , pawnY ) { if ( pawnX - bishopX == pawnY - bishopY ) return true ; else if ( - pawnX + bishopX == pawnY - bishopY ) return true ; else return false ; }
Ref: 
function canTakeDown ( $ bishopX , $ bishopY , $ pawnX , $ pawnY ) { if ( $ pawnX - $ bishopX == $ pawnY - $ bishopY ) return true ; else if ( - $ pawnX + $ bishopX == $ pawnY - $ bishopY ) return true ; else return false ; }
Hyp: 
function canTakeDown ( $ bishopX , $ bishopY , $ pawnX , $ pawnY ) { if ( $ pawnX - $ bishopX == $ pawnY - $ bishopY ) return true ; else if ( - $ pawnX + $ bishopX == $ pawnY - $ bishopY ) return true ; else return false ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function centeredIcosahedralNum ( n ) { return parseInt ( ( 2 * n + 1 ) * ( 5 * n * n + 5 * n + 3 ) / 3 ) ; }
Ref: 
function centeredIcosahedralNum ( $ n ) { return ( 2 * $ n + 1 ) * ( 5 * $ n * $ n + 5 * $ n + 3 ) / 3 ; }
Hyp: 
function centeredIcosahedralNum ( $ n ) { return ( 2 * $ n + 1 ) * ( 5 * $ n * $ n + 5 * $ n + 3 ) / 3 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findRadiusOfcircumcircle ( n , a ) { if ( n < 0 a < 0 ) return - 1 ; var radius = ( a / Math . sqrt ( 2 - ( 2 * Math . cos ( 360 / n ) ) ) ) ; return radius ; }
Ref: 
function findRadiusOfcircumcircle ( $ n , $ a ) { if ( $ n < 0 $ a < 0 ) return -1 ; $ radius = $ a / sqrt ( 2 - ( 2 * cos ( 360 / $ n ) ) ) ; return $ radius ; }
Hyp: 
function findRadiusOfcircumcircle ( $ n , $ a ) { if ( $ n < 0 $ a < 0 ) return -1 ; $ radius = ( $ a / sqrt ( 2 - ( 2 * cos ( 360 / $ n ) ) ) ; return $ radius ; }

BLEU: 95.16
Edit Sim: 2


Src: 
function solve ( A , B ) { var count = 0 ; for ( i = 0 ; i < 32 ; i ++ ) { if ( ( ( A >> i ) & 1 ) != ( ( B >> i ) & 1 ) ) { count ++ ; } } document . write ( " " + count ) ; }
Ref: 
function solve ( $ A , $ B ) { $ count = 0 ; for ( $ i = 0 ; $ i < 32 ; $ i ++ ) { if ( ( ( $ A >> $ i ) & 1 ) != ( ( $ B >> $ i ) & 1 ) ) { $ count ++ ; } } echo " Number ▁ of ▁ different ▁ bits ▁ : ▁ $ count " ; }
Hyp: 
function solve ( $ A , $ B ) { $ count = 0 ; for ( $ i = 0 ; $ i < 32 ; $ i ++ ) { if ( ( ( $ A >> $ i ) & 1 ) != ( ( $ B >> $ i ) & 1 ) ) { $ count ++ ; } } echo " Yes STRNEWLINE " ; }

BLEU: 82.74
Edit Sim: 41


Src: 
function centered_pentagonal_Num ( n ) { return ( 5 * n * n - 5 * n + 2 ) / 2 ; }
Ref: 
function centered_pentagonal_Num ( $ n ) { return ( 5 * $ n * $ n - 5 * $ n + 2 ) / 2 ; }
Hyp: 
function centered_pentagonal_Num ( $ n ) { return ( 5 * $ n * $ n - 5 * $ n + 2 ) / 2 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function check ( k , d0 , d1 ) { let s = ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 + ( 8 * ( d0 + d1 ) ) % 10 + ( 6 * ( d0 + d1 ) ) % 10 ; let a = ( k - 3 ) % 4 ; let x ; switch ( a ) { case 0 : x = 0 ; break ; case 1 : x = ( 2 * ( d0 + d1 ) ) % 10 ; break ; case 2 : x = ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 ; break ; case 3 : x = ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 + ( 8 * ( d0 + d1 ) ) % 10 ; break ; } let sum = d0 + d1 + parseInt ( ( k - 3 ) / 4 ) * s + x ; if ( sum % 3 == 0 ) return " " ; return " " ; }
Ref: 
function check ( $ k , $ d0 , $ d1 ) { $ s = ( 2 * ( $ d0 + $ d1 ) ) % 10 + ( 4 * ( $ d0 + $ d1 ) ) % 10 + ( 8 * ( $ d0 + $ d1 ) ) % 10 + ( 6 * ( $ d0 + $ d1 ) ) % 10 ; $ a = ( $ k - 3 ) % 4 ; $ x ; switch ( $ a ) { case 0 : $ x = 0 ; break ; case 1 : $ x = ( 2 * ( $ d0 + $ d1 ) ) % 10 ; break ; case 2 : $ x = ( 2 * ( $ d0 + $ d1 ) ) % 10 + ( 4 * ( $ d0 + $ d1 ) ) % 10 ; break ; case 3 : $ x = ( 2 * ( $ d0 + $ d1 ) ) % 10 + ( 4 * ( $ d0 + $ d1 ) ) % 10 + ( 8 * ( $ d0 + $ d1 ) ) % 10 ; break ; } $ sum = $ d0 + $ d1 + ( int ) ( ( $ k - 3 ) / 4 ) * $ s + $ x ; if ( $ sum % 3 == 0 ) return " YES " ; return " NO " ; }
Hyp: 
function check ( $ k , $ d0 , $ d1 ) { $ s = ( 2 * ( $ d0 + $ d1 ) ) % 10 + ( 4 * ( $ d0 + $ d1 ) ) % 10 + ( 8 * ( $ d0 + $ d1 ) ) % 10 + ( 6 * ( $ d0 + $ d1 ) ) % 10 ; $ a = ( $ k - 3 ) % 4 ; $ x = 0 ; break ; case 1 : $ x = ( 2 * ( $ d0 + $ d1 ) ) % 10 ; break ; case 2 : $ x = ( 2 * ( $ d0 + $ d1 ) ) % 10 + ( 4 * ( $ d0 + $ d1 ) ) % 10 + ( 8 * ( $ d0 + $ d1 ) ) % 10 ; break ; } $ sum = $ d0 + $ d1 + ( ( $ k - 3 ) / 4 ) * $ s + $ x ; if ( $ sum % 3 == 0 ) return " Yes " ; return " No " ; }

BLEU: 76.17
Edit Sim: 128


Src: 
function prletGroups ( n ) { let x = 1 ; let y = n * n ; for ( let i = 1 ; i <= n ; i ++ ) { for ( let j = 1 ; j <= n / 2 ; j ++ ) { document . write ( " " + x + " " + y + " " ) ; x ++ ; y -- ; } document . write ( " " ) ; } }
Ref: 
function printGroups ( $ n ) { $ x = 1 ; $ y = $ n * $ n ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 1 ; $ j <= $ n / 2 ; $ j ++ ) { echo " { " ▁ , ▁ $ x ▁ , ▁ " , " ▁ , ▁ $ y ▁ , ▁ " } " $ x ++ ; $ y -- ; } echo " STRNEWLINE " ; } }
Hyp: 
function prletGroups ( $ n ) { $ x = 1 ; $ y = $ n * $ n ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 1 ; $ j <= $ n / 2 ; $ j ++ ) { echo " x ▁ = ▁ 1 , ▁ $ x ▁ , ▁ " , $ y ▁ = ▁ 1 , ▁ " " } echo " STRNEWLINE " ; } }

BLEU: 76.25
Edit Sim: 35


Src: 
function largestCoprime ( N ) { if ( N == 6 ) return 1 ; else if ( N % 4 == 0 ) return ( N / 2 ) - 1 ; else if ( N % 2 == 0 ) return ( N / 2 ) - 2 ; else return ( ( N - 1 ) / 2 ) ; }
Ref: 
function largestCoprime ( $ N ) { if ( $ N == 6 ) return 1 ; else if ( $ N % 4 == 0 ) return ( $ N / 2 ) - 1 ; else if ( $ N % 2 == 0 ) return ( $ N / 2 ) - 2 ; else return ( ( $ N - 1 ) / 2 ) ; }
Hyp: 
function largestCoprime ( $ N ) { if ( $ N == 6 ) return 1 ; else if ( $ N % 4 == 0 ) return ( $ N / 2 ) - 1 ; else if ( $ N % 2 == 0 ) return ( $ N / 2 ) - 2 ; else return ( ( $ N - 1 ) / 2 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function areChractersUnique ( str ) { let checker = 0 ; for ( let i = 0 ; i < str . length ; ++ i ) { let val = ( str [ i ] - ' ' ) ; if ( ( checker & ( 1 << val ) ) > 0 ) return false ; checker |= ( 1 << val ) ; } return true ; }
Ref: 
function areChractersUnique ( $ str ) { $ checker = 0 ; for ( $ i = 0 ; $ i < $ len = strlen ( $ str ) ; ++ $ i ) { $ val = ( $ str [ $ i ] - ' a ' ) ; if ( ( $ checker & ( 1 << $ val ) ) > 0 ) return false ; $ checker |= ( 1 << $ val ) ; } return true ; }
Hyp: 
function areChractersUnique ( $ str ) { $ checker = 0 ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; ++ $ i ) { $ val = ( $ str [ $ i ] - ' a ' ) ; if ( ( $ checker & ( 1 << $ val ) ) > 0 ) return false ; $ checker |= ( 1 << $ val ) ; } return true ; }

BLEU: 94.67
Edit Sim: 8


Src: 
function NumberOfSolutions ( a , b , c , d ) { let ans = 0 ; for ( let i = a ; i <= b ; i ++ ) if ( d >= Math . max ( c , i + 1 ) ) ans += d - Math . max ( c , i + 1 ) + 1 ; return ans ; }
Ref: 
function NumberOfSolutions ( $ a , $ b , $ c , $ d ) { $ ans = 0 ; for ( $ i = $ a ; $ i <= $ b ; $ i ++ ) if ( $ d >= max ( $ c , $ i + 1 ) ) $ ans += $ d - max ( $ c , $ i + 1 ) + 1 ; return $ ans ; }
Hyp: 
function NumberOfSolutions ( $ a , $ b , $ c , $ d ) { $ ans = 0 ; for ( $ i = $ a ; $ i <= $ b ; $ i ++ ) if ( $ d >= max ( $ c , $ i + 1 ) ) $ ans += $ d - max ( $ c , $ i + 1 ) + 1 ; return $ ans ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function allBitsSetInTheGivenRange ( n , l , r ) { let num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ; let new_num = n & num ; if ( new_num == 0 ) return true ; return false ; }
Ref: 
function allBitsSetInTheGivenRange ( $ n , $ l , $ r ) { $ num = ( ( 1 << $ r ) - 1 ) ^ ( ( 1 << ( $ l - 1 ) ) - 1 ) ; $ new_num = $ n & $ num ; if ( $ new_num == 0 ) return true ; return false ; }
Hyp: 
function allBitsSetInTheGivenRange ( $ n , $ l , $ r ) { $ num = ( ( 1 << $ r ) - 1 ) ^ ( ( 1 << ( $ l - 1 ) ) - 1 ) ; $ new_num = $ n & $ num ; if ( $ new_num == 0 ) return true ; return false ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findNumbers ( n , d ) { for ( let i = 0 ; i < n - 2 ; i ++ ) document . write ( " " + " " ) ; document . write ( " " + " " ) ; document . write ( n + d ) ; }
Ref: 
function findNumbers ( $ n , $ d ) { for ( $ i = 0 ; $ i < $ n - 2 ; $ i ++ ) echo "1" , " ▁ " ; echo "2" , " ▁ " ; echo $ n + $ d , " STRNEWLINE " ; }
Hyp: 
function findNumbers ( $ n , $ d ) { for ( $ i = 0 ; $ i < $ n - 2 ; $ i ++ ) echo "0" ; echo "1" ; echo $ n + $ d ; }

BLEU: 65.44
Edit Sim: 35


Src: 
function getParity ( n ) { var parity = false ; while ( n != 0 ) { parity = ! parity ; n = n & ( n - 1 ) ; } return parity ; }
Ref: 
function getParity ( $ n ) { $ parity = 0 ; while ( $ n ) { $ parity = ! $ parity ; $ n = $ n & ( $ n - 1 ) ; } return $ parity ; }
Hyp: 
function getParity ( $ n ) { $ parity = false ; while ( $ n != 0 ) { $ parity = ! $ parity ; $ n = $ n & ( $ n - 1 ) ; } return $ parity ; }

BLEU: 87.01
Edit Sim: 10


Src: 
function countDigit ( n ) { if ( n / 10 == 0 ) return 1 ; return 1 + countDigit ( parseInt ( n / 10 ) ) ; }
Ref: 
function countDigit ( $ n ) { if ( $ n / 10 == 0 ) return 1 ; return 1 + countDigit ( ( int ) ( $ n / 10 ) ) ; }
Hyp: 
function countDigit ( $ n ) { if ( $ n / 10 == 0 ) return 1 ; return 1 + countDigit ( $ n / 10 ) ; }

BLEU: 80.6
Edit Sim: 12


Src: 
function pairAndSum ( arr , n ) { for ( let i = 0 ; i < n ; i ++ ) for ( let j = i + 1 ; j < n ; j ++ ) ans += arr [ i ] & arr [ j ] ; return ans ; }
Ref: 
function pairAndSum ( $ arr , $ n ) { $ ans = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) $ ans += $ arr [ $ i ] & $ arr [ $ j ] ; return $ ans ; }
Hyp: 
function pairAndSum ( $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) $ ans += $ arr [ $ i ] & $ arr [ $ j ] ; return $ ans ; }

BLEU: 90.93
Edit Sim: 12


Src: 
function halfsquare ( n , x , y ) { let half = n / 2 ; if ( ( half == x half == x - 1 ) && ( half == y half == y - 1 ) ) document . write ( " " ) ; else document . write ( " " ) ; }
Ref: 
function halfsquare ( $ n , $ x , $ y ) { $ half = $ n / 2 ; if ( ( $ half == $ x $ half == $ x - 1 ) && ( $ half == $ y $ half == $ y - 1 ) ) echo " NO " ; else echo " YES " ; }
Hyp: 
function halfsquare ( $ n , $ x , $ y ) { $ half = $ n / 2 ; if ( ( $ half == $ x $ half == $ x - 1 ) && ( $ half == $ y $ half == $ y - 1 ) ) echo " Half " ; else echo " Outside " ; }

BLEU: 92.12
Edit Sim: 11


Src: 
function canBeSumofConsec ( n ) { return ( ( ( n & ( n - 1 ) ) != 0 ) && n != 0 ) ; }
Ref: 
function canBeSumofConsec ( $ n ) { return ( ( $ n & ( $ n - 1 ) ) && $ n ) ; }
Hyp: 
function canBeSumofConsec ( $ n ) { return ( ( ( $ n & ( $ n - 1 ) ) != 0 ) && $ n != 0 ) ; }

BLEU: 72.23
Edit Sim: 14


Src: 
function optimalStrategyOfGame ( arr , n ) { let table = new Array ( n ) ; let gap , i , j , x , y , z ; for ( let d = 0 ; d < n ; d ++ ) { table [ d ] = new Array ( n ) ; } for ( gap = 0 ; gap < n ; ++ gap ) { for ( i = 0 , j = gap ; j < n ; ++ i , ++ j ) { x = ( ( i + 2 ) <= j ) ? table [ i + 2 ] [ j ] : 0 ; y = ( ( i + 1 ) <= ( j - 1 ) ) ? table [ i + 1 ] [ j - 1 ] : 0 ; z = ( i <= ( j - 2 ) ) ? table [ i ] [ j - 2 ] : 0 ; table [ i ] [ j ] = Math . max ( arr [ i ] + Math . min ( x , y ) , arr [ j ] + Math . min ( y , z ) ) ; } } return table [ 0 ] [ n - 1 ] ; }
Ref: 
function optimalStrategyOfGame ( $ arr , $ n ) { $ table = array_fill ( 0 , $ n , array_fill ( 0 , $ n , 0 ) ) ; for ( $ gap = 0 ; $ gap < $ n ; ++ $ gap ) { for ( $ i = 0 , $ j = $ gap ; $ j < $ n ; ++ $ i , ++ $ j ) { $ x = ( ( $ i + 2 ) <= $ j ) ? $ table [ $ i + 2 ] [ $ j ] : 0 ; $ y = ( ( $ i + 1 ) <= ( $ j - 1 ) ) ? $ table [ $ i + 1 ] [ $ j - 1 ] : 0 ; $ z = ( $ i <= ( $ j - 2 ) ) ? $ table [ $ i ] [ $ j - 2 ] : 0 ; $ table [ $ i ] [ $ j ] = max ( $ arr [ $ i ] + min ( $ x , $ y ) , $ arr [ $ j ] + min ( $ y , $ z ) ) ; } } return $ table [ 0 ] [ $ n - 1 ] ; }
Hyp: 
function optimalStrategyOfGame ( $ arr , $ n ) { $ table = array ( array ( ) ) ; $ gap ; $ i ; $ j ; $ x ; $ y ; $ z ; for ( $ d = 0 ; $ d < $ n ; $ d ++ ) $ table [ $ d ] = array ( ) ; for ( $ gap = 0 ; $ gap < $ n ; ++ $ gap ) { for ( $ i = 0 , $ j = $ gap ; $ j < $ n ; ++ $ i , ++ $ j ) { $ x = ( $ i + 2 ) <= $ j ) ? $ table [ $ i + 2 ] [ $ j ] : 0 ; $ y = ( $ i + 1 ) <= ( $ j - 1 ) ) ? $ table [ $ i + 1 ] [ $ j - 1 ] : 0 ; $ z = $ i <= ( $ j - 2 ) ) ? $ table [ $ i ] [ $ j - 2 ] : 0 ; $ table [ $ i ] [ $ j ] = max ( $ arr [ $ i ] + min ( $ x , $ y ) , $ arr [ $ j ] + min ( $ y , $ z ) ; } } return $ table [ 0 ] [ $ n - 1 ] ; }

BLEU: 80.25
Edit Sim: 102


Src: 
function evenDecimalValue ( str , n ) { var result = 0 ; for ( var i = 0 ; i < n ; i ++ ) { for ( var j = i ; j < n ; j ++ ) { var decimalValue = 0 ; var powerOf2 = 1 ; for ( var k = i ; k <= j ; k ++ ) { decimalValue += ( ( str [ k ] - ' ' ) * powerOf2 ) ; powerOf2 *= 2 ; } if ( decimalValue % 2 == 0 ) result ++ ; } } return result ; }
Ref: 
function evenDecimalValue ( $ str , $ n ) { $ result = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = $ i ; $ j < $ n ; $ j ++ ) { $ decimalValue = 0 ; $ powerOf2 = 1 ; for ( $ k = $ i ; $ k <= $ j ; $ k ++ ) { $ decimalValue += ( ( $ str [ $ k ] - '0' ) * $ powerOf2 ) ; $ powerOf2 *= 2 ; } if ( $ decimalValue % 2 == 0 ) $ result ++ ; } } return $ result ; }
Hyp: 
function evenDecimalValue ( $ str , $ n ) { $ result = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = $ i ; $ j < $ n ; $ j ++ ) { $ decimalValue = 0 ; $ powerOf2 = 1 ; for ( $ k = $ i ; $ k <= $ j ; $ k ++ ) { $ decimalValue += ( ( $ str [ $ k ] - '0' ) * $ powerOf2 ) ; $ powerOf2 *= 2 ; } if ( $ decimalValue % 2 == 0 ) $ result ++ ; } } return $ result ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function alternateSubarray ( arr , n ) { let len = new Array ( n ) ; len [ n - 1 ] = 1 ; for ( let i = n - 2 ; i >= 0 ; -- i ) { if ( arr [ i ] ^ arr [ i + 1 ] == 1 ) len [ i ] = len [ i + 1 ] + 1 ; else len [ i ] = 1 ; } for ( let i = 0 ; i < n ; ++ i ) document . write ( len [ i ] + " " ) ; }
Ref: 
function alternateSubarray ( & $ arr , $ n ) { $ len = array_fill ( 0 , $ n , NULL ) ; $ len [ $ n - 1 ] = 1 ; for ( $ i = $ n - 2 ; $ i >= 0 ; -- $ i ) { if ( $ arr [ $ i ] ^ $ arr [ $ i + 1 ] == 1 ) $ len [ $ i ] = $ len [ $ i + 1 ] + 1 ; else $ len [ $ i ] = 1 ; } for ( $ i = 0 ; $ i < $ n ; ++ $ i ) echo $ len [ $ i ] . " ▁ " ; }
Hyp: 
function alternateSubarray ( $ arr , $ n ) { $ len [ $ n - 1 ] = 1 ; for ( $ i = $ n - 2 ; $ i >= 0 ; -- $ i ) { if ( $ arr [ $ i ] ^ $ arr [ $ i + 1 ] == 1 ) $ len [ $ i ] = $ len [ $ i + 1 ] + 1 ; else $ len [ $ i ] = 1 ; } for ( $ i = 0 ; $ i < $ n ; ++ $ i ) echo $ len [ $ i ] , " ▁ " ; }

BLEU: 85.96
Edit Sim: 43


Src: 
function areaSquare ( side , fold ) { var area = side * side ; return ( area * 1.0 ) / ( Math . pow ( 2 , fold ) ) ; }
Ref: 
function areaSquare ( $ side , $ fold ) { $ area = $ side * $ side ; return $ area * 1.0 / pow ( 2 , $ fold ) ; }
Hyp: 
function areaSquare ( $ side , $ fold ) { $ area = $ side * $ side ; return ( $ area * 1.0 ) / ( pow ( 2 , $ fold ) ) ; }

BLEU: 76.43
Edit Sim: 8


Src: 
function findMin ( a , n ) { var sum = 0 ; for ( i = 0 ; i < n ; i ++ ) sum += Math . log ( a [ i ] ) ; var x = parseInt ( Math . exp ( sum / n ) ) ; return x + 1 ; }
Ref: 
function findMin ( $ a , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum += log ( $ a [ $ i ] ) ; $ x = exp ( $ sum / $ n ) ; return ( int ) ( $ x + 1 ) ; }
Hyp: 
function findMin ( $ a , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum += log ( $ a [ $ i ] ) ; $ x = ( int ) exp ( $ sum / $ n ) ; return $ x + 1 ; }

BLEU: 88.35
Edit Sim: 20


Src: 
function patternCount ( str ) { var last = str . charAt ( 0 ) ; var i = 1 , counter = 0 ; while ( i < str . length ) { if ( str . charAt ( i ) == ' ' && last == ' ' ) { while ( str . charAt ( i ) == ' ' ) i ++ ; if ( str . charAt ( i ) == ' ' ) counter ++ ; } last = str . charAt ( i ) ; i ++ ; } return counter ; }
Ref: 
function patternCount ( $ str ) { $ last = $ str [ 0 ] ; $ i = 1 ; $ counter = 0 ; while ( $ i < strlen ( $ str ) ) { if ( $ str [ $ i ] == '0' && $ last == '1' ) { while ( $ str [ $ i ] == '0' ) $ i ++ ; if ( $ str [ $ i ] == '1' ) $ counter ++ ; } $ last = $ str [ $ i ] ; $ i ++ ; } return $ counter ; }
Hyp: 
function patternCount ( $ str ) { $ last = $ str [ 0 ] ; $ i = 1 ; $ counter = 0 ; while ( $ i < strlen ( $ str ) ) { if ( $ str [ $ i ] == ' ( ' && $ last == ' ) ' ) { while ( $ str [ $ i ] == ' ) ' ) $ i ++ ; if ( $ str [ $ i ] == ' ) ' ) $ counter ++ ; } $ last = $ str [ $ i ] ; $ i ++ ; } return $ counter ; }

BLEU: 84.0
Edit Sim: 12


Src: 
function get_last_two_digit ( N ) { if ( N <= 10 ) { let ans = 0 , fac = 1 ; for ( let i = 1 ; i <= N ; i ++ ) { fac = fac * i ; ans += fac ; } return ans % 100 ; } return 13 ; }
Ref: 
function get_last_two_digit ( $ N ) { if ( $ N <= 10 ) { $ ans = 0 ; $ fac = 1 ; for ( $ i = 1 ; $ i <= $ N ; $ i ++ ) { $ fac = $ fac * $ i ; $ ans += $ fac ; } return $ ans % 100 ; } return 13 ; }
Hyp: 
function get_last_two_digit ( $ N ) { if ( $ N <= 10 ) { $ ans = 0 ; $ fac = 1 ; for ( $ i = 1 ; $ i <= $ N ; $ i ++ ) { $ fac = $ fac * $ i ; $ ans += $ fac ; } return $ ans % 100 ; } return 13 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function Substring ( s ) { var ans = 1 , temp = 1 ; for ( var i = 1 ; i < s . length ; i ++ ) { if ( s [ i ] == s [ i - 1 ] ) { ++ temp ; } else { ans = Math . max ( ans , temp ) ; temp = 1 ; } } ans = Math . max ( ans , temp ) ; return ans ; }
Ref: 
function Substring ( $ s ) { $ ans = 1 ; $ temp = 1 ; for ( $ i = 1 ; $ i < strlen ( $ s ) ; $ i ++ ) { if ( $ s [ $ i ] == $ s [ $ i - 1 ] ) { ++ $ temp ; } else { $ ans = max ( $ ans , $ temp ) ; $ temp = 1 ; } } $ ans = max ( $ ans , $ temp ) ; return $ ans ; }
Hyp: 
function Substring ( $ s ) { $ ans = 1 ; $ temp = 1 ; for ( $ i = 1 ; $ i < strlen ( $ s ) ; $ i ++ ) { if ( $ s [ $ i ] == $ s [ $ i - 1 ] ) { ++ $ temp ; } else { $ ans = max ( $ ans , $ temp ) ; $ temp = 1 ; } } $ ans = max ( $ ans , $ temp ) ; return $ ans ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countSymmetric ( n ) { if ( n == 0 ) return 1 ; return 1 << ( ( n * ( n + 1 ) ) / 2 ) ; }
Ref: 
function countSymmetric ( $ n ) { if ( $ n == 0 ) return 1 ; return 1 << ( ( $ n * ( $ n + 1 ) ) / 2 ) ; }
Hyp: 
function countSymmetric ( $ n ) { if ( $ n == 0 ) return 1 ; return 1 << ( ( $ n * ( $ n + 1 ) ) / 2 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countNonEmptySubstr ( str ) { let n = str . length ; return n * ( n + 1 ) / 2 ; }
Ref: 
function countNonEmptySubstr ( $ str ) { $ n = strlen ( $ str ) ; return $ n * ( $ n + 1 ) / 2 ; }
Hyp: 
function countNonEmptySubstr ( $ str ) { $ n = strlen ( $ str ) ; return $ n * ( $ n + 1 ) / 2 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findIndex ( a , n ) { let res = 0 ; let min_diff = Number . MAX_VALUE ; let prod = new Array ( n ) ; prod [ 0 ] = a [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) prod [ i ] = prod [ i - 1 ] * a [ i ] ; for ( let i = 0 ; i < n - 1 ; i ++ ) { let curr_diff = Math . abs ( parseInt ( prod [ n - 1 ] / prod [ i ] , 10 ) - prod [ i ] ) ; if ( curr_diff < min_diff ) { min_diff = curr_diff ; res = i ; } } return res ; }
Ref: 
function findIndex ( $ a , $ n ) { $ min_diff = PHP_INT_MAX ; $ prod = array ( ) ; $ prod [ 0 ] = $ a [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ prod [ $ i ] = $ prod [ $ i - 1 ] * $ a [ $ i ] ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { $ curr_diff = abs ( ( $ prod [ $ n - 1 ] / $ prod [ $ i ] ) - $ prod [ $ i ] ) ; if ( $ curr_diff < $ min_diff ) { $ min_diff = $ curr_diff ; $ res = $ i ; } } return $ res ; }
Hyp: 
function findIndex ( $ a , $ n ) { $ res = 0 ; $ min_diff = PHP_INT_MAX ; $ prod = array ( ) ; $ prod [ 0 ] = $ a [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ prod [ $ i ] = $ prod [ $ i - 1 ] * $ a [ $ i ] ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { $ curr_diff = abs ( $ prod [ $ n - 1 ] / $ prod [ $ i ] - $ prod [ $ i ] ) ; if ( $ curr_diff < $ min_diff ) { $ min_diff = $ curr_diff ; $ res = $ i ; } } return $ res ; }

BLEU: 94.83
Edit Sim: 16


Src: 
function printMinimumProduct ( arr , n ) { let first_min = Math . min ( arr [ 0 ] , arr [ 1 ] ) ; let second_min = Math . max ( arr [ 0 ] , arr [ 1 ] ) ; for ( let i = 2 ; i < n ; i ++ ) { if ( arr [ i ] < first_min ) { second_min = first_min ; first_min = arr [ i ] ; } else if ( arr [ i ] < second_min ) second_min = arr [ i ] ; } return first_min * second_min ; }
Ref: 
function printMinimumProduct ( $ arr , $ n ) { $ first_min = min ( $ arr [ 0 ] , $ arr [ 1 ] ) ; $ second_min = max ( $ arr [ 0 ] , $ arr [ 1 ] ) ; for ( $ i = 2 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] < $ first_min ) { $ second_min = $ first_min ; $ first_min = $ arr [ $ i ] ; } else if ( $ arr [ $ i ] < $ second_min ) $ second_min = $ arr [ $ i ] ; } return $ first_min * $ second_min ; }
Hyp: 
function printMinimumProduct ( $ arr , $ n ) { $ first_min = min ( $ arr [ 0 ] , $ arr [ 1 ] ) ; $ second_min = max ( $ arr [ 0 ] , $ arr [ 1 ] ) ; for ( $ i = 2 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] < $ first_min ) { $ second_min = $ first_min ; $ first_min = $ arr [ $ i ] ; } else if ( $ arr [ $ i ] < $ second_min ) $ second_min = $ arr [ $ i ] ; } return $ first_min * $ second_min ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findElements ( arr , n ) { let first = Number . MIN_VALUE ; let second = Number . MAX_VALUE ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > first ) { second = first ; first = arr [ i ] ; } else if ( arr [ i ] > second ) second = arr [ i ] ; } for ( let i = 0 ; i < n ; i ++ ) if ( arr [ i ] < second ) document . write ( arr [ i ] + " " ) ; }
Ref: 
function findElements ( $ arr , $ n ) { $ first = PHP_INT_MIN ; $ second = PHP_INT_MIN ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] > $ first ) { $ second = $ first ; $ first = $ arr [ $ i ] ; } else if ( $ arr [ $ i ] > $ second ) $ second = $ arr [ $ i ] ; } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] < $ second ) echo $ arr [ $ i ] , " ▁ " ; }
Hyp: 
function findElements ( $ arr , $ n ) { $ first = PHP_INT_MIN ; $ second = PHP_INT_MAX ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] > $ first ) { $ second = $ first ; $ first = $ arr [ $ i ] ; } else if ( $ arr [ $ i ] > $ second ) $ second = $ arr [ $ i ] ; } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] < $ second ) echo $ arr [ $ i ] . " ▁ " ; }

BLEU: 96.23
Edit Sim: 3


Src: 
function fib ( n ) { if ( n <= 1 ) return n ; return fib ( n - 1 ) + fib ( n - 2 ) ; }
Ref: 
function fib ( $ n ) { if ( $ n <= 1 ) return $ n ; return fib ( $ n - 1 ) + fib ( $ n - 2 ) ; }
Hyp: 
function fib ( $ n ) { if ( $ n <= 1 ) return $ n ; return fib ( $ n - 1 ) + fib ( $ n - 2 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function maxHandshake ( n ) { return ( n * ( n - 1 ) ) / 2 ; }
Ref: 
function maxHandshake ( $ n ) { return ( $ n * ( $ n - 1 ) ) / 2 ; }
Hyp: 
function maxHandshake ( $ n ) { return ( $ n * ( $ n - 1 ) ) / 2 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countPoints ( n , m , a , b , x , y ) { a . sort ( function ( a , b ) { return a - b } ) ; b . sort ( function ( a , b ) { return a - b } ) ; let j = 0 ; let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { while ( j < m ) { if ( a [ i ] + y < b [ j ] ) break ; if ( b [ j ] >= a [ i ] - x && b [ j ] <= a [ i ] + y ) { count ++ ; j ++ ; break ; } else j ++ ; } } return count ; }
Ref: 
function countPoints ( $ n , $ m , $ a , $ b , $ x , $ y ) { sort ( $ a ) ; sort ( $ b ) ; $ j = 0 ; $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { while ( $ j < $ m ) { if ( $ a [ $ i ] + $ y < $ b [ $ j ] ) break ; if ( $ b [ $ j ] >= $ a [ $ i ] - $ x && $ b [ $ j ] <= $ a [ $ i ] + $ y ) { $ count ++ ; $ j ++ ; break ; } else $ j ++ ; } } return $ count ; }
Hyp: 
function countPoints ( $ n , $ m , $ a , $ b , $ x , $ y ) { sort ( $ a ) ; sort ( $ b ) ; $ j = 0 ; $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { while ( $ j < $ m ) { if ( $ a [ $ i ] + $ y < $ b [ $ j ] ) break ; if ( $ b [ $ j ] >= $ a [ $ i ] - $ x && $ b [ $ j ] <= $ a [ $ i ] + $ y ) { $ count ++ ; $ j ++ ; break ; } else $ j ++ ; } } return $ count ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function pushZerosToEnd ( arr , n ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) if ( arr [ i ] != 0 ) arr [ count ++ ] = arr [ i ] ; while ( count < n ) arr [ count ++ ] = 0 ; }
Ref: 
function pushZerosToEnd ( & $ arr , $ n ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] != 0 ) $ arr [ $ count ++ ] = $ arr [ $ i ] ; while ( $ count < $ n ) $ arr [ $ count ++ ] = 0 ; }
Hyp: 
function pushZerosToEnd ( & $ arr , $ n ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] != 0 ) $ arr [ $ count ++ ] = $ arr [ $ i ] ; while ( $ count < $ n ) $ arr [ $ count ++ ] = 0 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function CalculatePairs ( a , n ) { let cnt_zero = 0 ; let cnt_one = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 == 0 ) cnt_zero += 1 ; else cnt_one += 1 ; } let total_XOR_pairs = cnt_zero * cnt_one ; let total_AND_pairs = ( cnt_one ) * ( cnt_one - 1 ) / 2 ; let total_OR_pairs = cnt_zero * cnt_one + ( cnt_one ) * ( cnt_one - 1 ) / 2 ; document . write ( " " + total_XOR_pairs + " " ) ; document . write ( " " + total_AND_pairs + " " ) ; document . write ( " " + total_OR_pairs + " " ) ; }
Ref: 
function CalculatePairs ( $ a , $ n ) { $ cnt_zero = 0 ; $ cnt_one = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] % 2 == 0 ) $ cnt_zero += 1 ; else $ cnt_one += 1 ; } $ total_XOR_pairs = $ cnt_zero * $ cnt_one ; $ total_AND_pairs = ( $ cnt_one ) * ( $ cnt_one - 1 ) / 2 ; $ total_OR_pairs = $ cnt_zero * $ cnt_one + ( $ cnt_one ) * ( $ cnt_one - 1 ) / 2 ; echo ( " cntXOR ▁ = ▁ $ total _ XOR _ pairs STRNEWLINE " ) ; echo ( " cntAND ▁ = ▁ $ total _ AND _ pairs STRNEWLINE " ) ; echo ( " cntOR ▁ = ▁ $ total _ OR _ pairs STRNEWLINE " ) ; }
Hyp: 
function CalculatePairs ( $ a , $ n ) { $ cnt_zero = 0 ; $ cnt_one = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] % 2 == 0 ) $ cnt_zero += 1 ; else $ cnt_one += 1 ; } $ total_XOR_pairs = $ cnt_zero * $ cnt_one ; $ total_AND_pairs = ( $ cnt_one ) * ( $ cnt_one - 1 ) / 2 ; $ total_OR_pairs = $ cnt_zero * $ cnt_one + ( $ cnt_one ) * ( $ cnt_one - 1 ) / 2 ; echo " Total = " ▁ , ▁ $ total_AND_pairs , ▁ " " ; STRNEWLINE TABSYMBOL echo ▁ " Total = " ▁ , ▁ $ total_OR_pairs , ▁ " " }

BLEU: 71.42
Edit Sim: 109


Src: 
function countOnes ( arr , low , high ) { if ( high >= low ) { let mid = Math . trunc ( low + ( high - low ) / 2 ) ; if ( ( mid == high arr [ mid + 1 ] == 0 ) && ( arr [ mid ] == 1 ) ) return mid + 1 ; if ( arr [ mid ] == 1 ) return countOnes ( arr , ( mid + 1 ) , high ) ; return countOnes ( arr , low , ( mid - 1 ) ) ; } return 0 ; }
Ref: 
function countOnes ( $ arr , $ low , $ high ) { if ( $ high >= $ low ) { $ mid = $ low + ( $ high - $ low ) / 2 ; if ( ( $ mid == $ high or $ arr [ $ mid + 1 ] == 0 ) and ( $ arr [ $ mid ] == 1 ) ) return $ mid + 1 ; if ( $ arr [ $ mid ] == 1 ) return countOnes ( $ arr , ( $ mid + 1 ) , $ high ) ; return countOnes ( $ arr , $ low , ( $ mid - 1 ) ) ; } return 0 ; }
Hyp: 
function countOnes ( $ arr , $ low , $ high ) { if ( $ high >= $ low ) { $ mid = trunc ( $ low + ( $ high - $ low ) / 2 ) ; if ( ( $ mid == $ high $ arr [ $ mid + 1 ] == 0 ) && ( $ arr [ $ mid ] == 1 ) ) return $ mid + 1 ; if ( $ arr [ $ mid ] == 1 ) return countOnes ( $ arr , ( $ mid + 1 ) , $ high ) ; return countOnes ( $ arr , $ low , ( $ mid - 1 ) ) ; } return 0 ; }

BLEU: 92.06
Edit Sim: 16


Src: 
function maxEdges ( N ) { var edges = 0 ; edges = Math . floor ( ( N * N ) / 4 ) ; return edges ; }
Ref: 
function maxEdges ( $ N ) { $ edges = 0 ; $ edges = floor ( ( $ N * $ N ) / 4 ) ; return $ edges ; }
Hyp: 
function maxEdges ( $ N ) { $ edges = 0 ; $ edges = ( $ N * $ N ) / 4 ; return $ edges ; }

BLEU: 80.68
Edit Sim: 10


Src: 
function eulerian ( n , m ) { if ( m >= n n == 0 ) return 0 ; if ( m == 0 ) return 1 ; return ( n - m ) * eulerian ( n - 1 , m - 1 ) + ( m + 1 ) * eulerian ( n - 1 , m ) ; }
Ref: 
function eulerian ( $ n , $ m ) { if ( $ m >= $ n $ n == 0 ) return 0 ; if ( $ m == 0 ) return 1 ; return ( $ n - $ m ) * eulerian ( $ n - 1 , $ m - 1 ) + ( $ m + 1 ) * eulerian ( $ n - 1 , $ m ) ; }
Hyp: 
function eulerian ( $ n , $ m ) { if ( $ m >= $ n $ n == 0 ) return 0 ; if ( $ m == 0 ) return 1 ; return ( $ n - $ m ) * eulerian ( $ n - 1 , $ m - 1 ) + ( $ m + 1 ) * eulerian ( $ n - 1 , $ m ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function SternSequenceFunc ( BrocotSequence , n ) { for ( var i = 1 ; BrocotSequence . length < n ; i ++ ) { var considered_element = BrocotSequence [ i ] ; var precedent = BrocotSequence [ i - 1 ] ; BrocotSequence . push ( considered_element + precedent ) ; BrocotSequence . push ( considered_element ) ; } for ( var i = 0 ; i < 15 ; ++ i ) document . write ( BrocotSequence [ i ] + " " ) ; }
Ref: 
function SternSequenceFunc ( & $ BrocotSequence , $ n ) { for ( $ i = 1 ; count ( $ BrocotSequence ) < $ n ; $ i ++ ) { $ considered_element = $ BrocotSequence [ $ i ] ; $ precedent = $ BrocotSequence [ $ i - 1 ] ; array_push ( $ BrocotSequence , $ considered_element + $ precedent ) ; array_push ( $ BrocotSequence , $ considered_element ) ; } for ( $ i = 0 ; $ i < 15 ; ++ $ i ) echo ( $ BrocotSequence [ $ i ] . " ▁ " ) ; }
Hyp: 
function SternSequenceFunc ( $ BrocotSequence , $ n ) { for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ considered_element = $ BrocotSequence [ $ i ] ; $ precedent = $ BrocotSequence [ $ i - 1 ] ; array_push ( $ BrocotSequence , $ considered_element + $ precedent ) ; array_push ( $ BrocotSequence , $ considered_element ) ; } for ( $ i = 0 ; $ i < 15 ; ++ $ i ) echo $ BrocotSequence [ $ i ] . " ▁ " ; }

BLEU: 87.52
Edit Sim: 30


Src: 
function calculateSum ( n ) { return 2 * ( n * ( n + 1 ) * ( 2 * n + 1 ) / 6 ) + n * ( n + 1 ) / 2 + 2 * ( n ) ; }
Ref: 
function calculateSum ( $ n ) { return 2 * ( $ n * ( $ n + 1 ) * ( 2 * $ n + 1 ) / 6 ) + $ n * ( $ n + 1 ) / 2 + 2 * ( $ n ) ; }
Hyp: 
function calculateSum ( $ n ) { return 2 * ( $ n * ( $ n + 1 ) * ( 2 * $ n + 1 ) / 6 ) + $ n * ( $ n + 1 ) / 2 + 2 * ( $ n ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function circle_equation ( x1 , y1 , r ) { let a = - 2 * x1 ; let b = - 2 * y1 ; let c = ( r * r ) - ( x1 * x1 ) - ( y1 * y1 ) ; document . write ( " " + a + " " ) ; document . write ( " " + b + " " ) ; document . write ( c + " " ) ; }
Ref: 
function circle_equation ( $ x1 , $ y1 , $ r ) { $ a = -2 * $ x1 ; $ b = -2 * $ y1 ; $ c = ( $ r * $ r ) - ( $ x1 * $ x1 ) - ( $ y1 * $ y1 ) ; echo " x ^ 2 + ( " ▁ . ▁ $ a ▁ . ▁ " x ) + " echo " y ^ 2 ▁ + ▁ ( " . $ b . " ▁ y ) ▁ = ▁ " ; echo $ c . " . " . " STRNEWLINE " ; }
Hyp: 
function circle_equation ( $ x1 , $ y1 , $ r ) { $ a = - 2 * $ x1 ; $ b = - 2 * $ y1 ; $ c = ( $ r * $ r ) - ( $ x1 * $ x1 ) - ( $ y1 * $ y1 ) ; echo " A = " , ▁ $ a , ▁ " , B = " , ▁ $ b , ▁ " " ; echo " C = " , $ c , " STRNEWLINE " ; }

BLEU: 55.37
Edit Sim: 61


Src: 
function isEven ( n ) { return ( n % 2 == 0 ) ; }
Ref: 
function isEven ( $ n ) { return ( $ n % 2 == 0 ) ; }
Hyp: 
function isEven ( $ n ) { return ( $ n % 2 == 0 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findSubArray ( arr , n ) { let sum = 0 ; let maxsize = - 1 , startindex = 0 ; let endindex = 0 ; for ( let i = 0 ; i < n - 1 ; i ++ ) { sum = ( arr [ i ] == 0 ) ? - 1 : 1 ; for ( let j = i + 1 ; j < n ; j ++ ) { if ( arr [ j ] == 0 ) sum += - 1 ; else sum += 1 ; if ( sum == 0 && maxsize < j - i + 1 ) { maxsize = j - i + 1 ; startindex = i ; } } } endindex = startindex + maxsize - 1 ; if ( maxsize == - 1 ) document . write ( " " ) ; else document . write ( startindex + " " + endindex ) ; return maxsize ; }
Ref: 
function findSubArray ( & $ arr , $ n ) { $ sum = 0 ; $ maxsize = -1 ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { $ sum = ( $ arr [ $ i ] == 0 ) ? -1 : 1 ; for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) { ( $ arr [ $ j ] == 0 ) ? ( $ sum += -1 ) : ( $ sum += 1 ) ; if ( $ sum == 0 && $ maxsize < $ j - $ i + 1 ) { $ maxsize = $ j - $ i + 1 ; $ startindex = $ i ; } } } if ( $ maxsize == -1 ) echo " No ▁ such ▁ subarray " ; else echo $ startindex . " ▁ to ▁ " . ( $ startindex + $ maxsize - 1 ) ; return $ maxsize ; }
Hyp: 
function findSubArray ( $ arr , $ n ) { $ sum = 0 ; $ maxsize = -1 ; $ startindex = 0 ; $ endindex = 0 ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { $ sum = ( $ arr [ $ i ] == 0 ) ? -1 : 1 ; for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) { if ( $ arr [ $ j ] == 0 ) $ sum += -1 ; else $ sum += 1 ; if ( $ sum == 0 && $ maxsize < $ j - $ i + 1 ) { $ maxsize = $ j - $ i + 1 ; $ startindex = $ i ; } } } $ endindex = $ startindex + $ maxsize - 1 ; if ( $ maxsize == -1 ) echo " No " ; else echo $ startindex . " No " . $ endindex ; }

BLEU: 81.09
Edit Sim: 154


Src: 
function squarearea ( a , b ) { if ( a < 0 b < 0 ) return - 1 ; var area = 4 * ( ( Math . pow ( a , 2 ) + Math . pow ( b , 2 ) ) / ( Math . pow ( a , 2 ) * Math . pow ( b , 2 ) ) ) ; return area ; }
Ref: 
function squarearea ( $ a , $ b ) { if ( $ a < 0 or $ b < 0 ) return -1 ; $ area = 4 * ( ( ( pow ( $ a , 2 ) + pow ( $ b , 2 ) ) / ( pow ( $ a , 2 ) * pow ( $ b , 2 ) ) ) ) ; return $ area ; }
Hyp: 
function squarearea ( $ a , $ b ) { if ( $ a < 0 $ b < 0 ) return -1 ; $ area = 4 * ( ( pow ( $ a , 2 ) + pow ( $ b , 2 ) ) / ( pow ( $ a , 2 ) * pow ( $ b , 2 ) ) ) ; return $ area ; }

BLEU: 93.52
Edit Sim: 7


Src: 
function cost ( str ) { let len = str . length ; let res = 0 ; for ( let i = 0 , j = len - 1 ; i < j ; i ++ , j -- ) { if ( str [ i ] != str [ j ] ) { res += Math . min ( str [ i ] . charCodeAt ( ) , str [ j ] . charCodeAt ( ) ) - ' ' . charCodeAt ( ) + 1 ; } } return res ; }
Ref: 
function cost ( $ str ) { $ len = strlen ( $ str ) ; $ res = 0 ; for ( $ i = 0 , $ j = $ len - 1 ; $ i < $ j ; $ i ++ , $ j -- ) if ( $ str [ $ i ] != $ str [ $ j ] ) $ res += ( min ( ord ( $ str [ $ i ] ) , ord ( $ str [ $ j ] ) ) - ord ( ' a ' ) + 1 ) ; return $ res ; }
Hyp: 
function cost ( $ str ) { $ len = strlen ( $ str ) ; $ res = 0 ; for ( $ i = 0 , $ j = $ len - 1 ; $ i < $ j ; $ i ++ , $ j -- ) { if ( $ str [ $ i ] != $ str [ $ j ] ) { $ res += min ( ord ( $ str [ $ i ] ) , ord ( $ str [ $ j ] ) ) - ord ( '0' ) + 1 ; } } return $ res ; }

BLEU: 87.43
Edit Sim: 13


Src: 
function isPossibleToZero ( a , n ) { let even = 0 , odd = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( ( i & 1 ) == 0 ) odd += a [ i ] ; else even += a [ i ] ; } return ( odd == even ) ; }
Ref: 
function isPossibleToZero ( $ a , $ n ) { $ even = 0 ; $ odd = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ i & 1 ) $ odd += $ a [ $ i ] ; else $ even += $ a [ $ i ] ; } return ( $ odd == $ even ) ; }
Hyp: 
function isPossibleToZero ( $ a , $ n ) { $ even = 0 ; $ odd = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( ( $ i & 1 ) == 0 ) $ odd += $ a [ $ i ] ; else $ even += $ a [ $ i ] ; } return ( $ odd == $ even ) ; }

BLEU: 93.11
Edit Sim: 9


