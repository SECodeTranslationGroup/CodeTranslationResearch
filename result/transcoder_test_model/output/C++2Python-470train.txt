Src: 
void printPairs ( int arr [ ] , int n ) { vector < int > v ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( abs ( arr [ i ] ) == abs ( arr [ j ] ) ) v . push_back ( abs ( arr [ i ] ) ) ; if ( v . size ( ) == 0 ) return ; sort ( v . begin ( ) , v . end ( ) ) ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) cout << - v [ i ] << " ▁ " << v [ i ] ; }
Ref: 
def printPairs ( arr , n ) : NEW_LINE INDENT v = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( abs ( arr [ i ] ) == abs ( arr [ j ] ) ) : NEW_LINE INDENT v . append ( abs ( arr [ i ] ) ) NEW_LINE DEDENT DEDENT DEDENT if ( len ( v ) == 0 ) : NEW_LINE INDENT return ; NEW_LINE DEDENT v . sort ( ) NEW_LINE for i in range ( len ( v ) ) : NEW_LINE INDENT print ( - v [ i ] , " " , v [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
Hyp: 
def printPairs ( arr , n ) : NEW_LINE INDENT v = [ ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( abs ( arr [ i ] ) == abs ( arr [ j ] ) ) : NEW_LINE INDENT v . append ( abs ( arr [ i ] ) ) NEW_LINE DEDENT DEDENT DEDENT if ( len ( v ) == 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT sort ( v ) NEW_LINE for i in range ( len ( v ) ) : NEW_LINE INDENT print ( - v [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT

BLEU: 87.95
Edit Sim: 28


Src: 
float findArea ( float a , float b , float c ) { if ( a < 0 || b < 0 || c < 0 || ( a + b <= c ) || a + c <= b || b + c <= a ) { cout << " Not ▁ a ▁ valid ▁ trianglen " ; exit ( 0 ) ; } float s = ( a + b + c ) / 2 ; return sqrt ( s * ( s - a ) * ( s - b ) * ( s - c ) ) ; }
Ref: 
def findArea ( a , b , c ) : NEW_LINE INDENT if ( a < 0 or b < 0 or c < 0 or ( a + b <= c ) or ( a + c <= b ) or ( b + c <= a ) ) : NEW_LINE INDENT print ( ' Not ▁ a ▁ valid ▁ trianglen ' ) NEW_LINE return NEW_LINE DEDENT s = ( a + b + c ) / 2 NEW_LINE area = ( s * ( s - a ) * ( s - b ) * ( s - c ) ) ** 0.5 NEW_LINE print ( ' Area ▁ of ▁ a ▁ traingle ▁ is ▁ % f ' % area ) NEW_LINE DEDENT
Hyp: 
def findArea ( a , b , c ) : NEW_LINE INDENT if ( a < 0 or b < 0 or c < 0 or ( a + b <= c ) or a + c <= b or b + c <= a ) : NEW_LINE INDENT print ( " Not ▁ a ▁ valid ▁ trianglen " ) NEW_LINE exit ( 0 ) NEW_LINE DEDENT s = ( a + b + c ) / 2 NEW_LINE return math . sqrt ( s * ( s - a ) * ( s - b ) * ( s - c ) ) NEW_LINE DEDENT

BLEU: 66.26
Edit Sim: 101


Src: 
bool isMajority ( int a [ ] , int n ) { unordered_map < int , int > mp ; for ( int i = 0 ; i < n ; i ++ ) mp [ a [ i ] ] ++ ; for ( auto x : mp ) if ( x . second >= n / 2 ) return true ; return false ; }
Ref: 
def isMajority ( a ) : NEW_LINE INDENT mp = { } NEW_LINE for i in a : NEW_LINE INDENT if i in mp : mp [ i ] += 1 NEW_LINE else : mp [ i ] = 1 NEW_LINE DEDENT for x in mp : NEW_LINE INDENT if mp [ x ] >= len ( a ) // 2 : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
Hyp: 
def isMajority ( a , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ a [ i ] ] = mp . get ( a [ i ] , 0 ) + 1 NEW_LINE DEDENT for x in mp : NEW_LINE INDENT if ( mp [ x ] >= n // 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT

BLEU: 50.34
Edit Sim: 67


Src: 
int nonDecNums ( int n ) { int a [ n + 1 ] [ 10 ] ; for ( int i = 0 ; i <= 9 ; i ++ ) a [ 0 ] [ i ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) a [ i ] [ 9 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 8 ; j >= 0 ; j -- ) a [ i ] [ j ] = a [ i - 1 ] [ j ] + a [ i ] [ j + 1 ] ; return a [ n ] [ 0 ] ; }
Ref: 
def nonDecNums ( n ) : NEW_LINE INDENT a = np . zeros ( ( n + 1 , 10 ) ) NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT a [ 0 ] [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT a [ i ] [ 9 ] = 1 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 8 , - 1 , - 1 ) : NEW_LINE INDENT a [ i ] [ j ] = a [ i - 1 ] [ j ] + a [ i ] [ j + 1 ] NEW_LINE DEDENT DEDENT return int ( a [ n ] [ 0 ] ) NEW_LINE DEDENT
Hyp: 
def nonDecNums ( n ) : NEW_LINE INDENT a = [ [ 0 for i in range ( 10 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( 9 ) : NEW_LINE INDENT a [ 0 ] [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT a [ i ] [ 9 ] = 1 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 8 , - 1 , - 1 ) : NEW_LINE INDENT a [ i ] [ j ] = a [ i - 1 ] [ j ] + a [ i ] [ j + 1 ] NEW_LINE DEDENT DEDENT return a [ n ] [ 0 ] NEW_LINE DEDENT

BLEU: 84.44
Edit Sim: 51


Src: 
void firstFit ( int blockSize [ ] , int m , int processSize [ ] , int n ) { int allocation [ n ] ; memset ( allocation , - 1 , sizeof ( allocation ) ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( blockSize [ j ] >= processSize [ i ] ) { allocation [ i ] = j ; blockSize [ j ] -= processSize [ i ] ; break ; } } } cout << " \n Process ▁ No . \tProcess ▁ Size\tBlock ▁ no . \n " ; for ( int i = 0 ; i < n ; i ++ ) { cout << " ▁ " << i + 1 << " \t\t " << processSize [ i ] << " \t\t " ; if ( allocation [ i ] != - 1 ) cout << allocation [ i ] + 1 ; else cout << " Not ▁ Allocated " ; cout << endl ; } }
Ref: 
def firstFit ( blockSize , m , processSize , n ) : NEW_LINE INDENT allocation = [ - 1 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if blockSize [ j ] >= processSize [ i ] : NEW_LINE INDENT allocation [ i ] = j NEW_LINE blockSize [ j ] -= processSize [ i ] NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT print ( " ▁ Process ▁ No . ▁ Process ▁ Size ▁ ▁ ▁ ▁ ▁ ▁ Block ▁ no . " ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( " ▁ " , i + 1 , " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " , processSize [ i ] , " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " , end = " ▁ " ) NEW_LINE if allocation [ i ] != - 1 : NEW_LINE INDENT print ( allocation [ i ] + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ Allocated " ) NEW_LINE DEDENT DEDENT DEDENT
Hyp: 
def firstfit ( blockSize , m , processSize , n ) : NEW_LINE INDENT allocation = [ - 1 ] * n NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , m ) : NEW_LINE INDENT if ( blockSize [ j ] >= processSize [ i ] ) : NEW_LINE INDENT allocation [ i ] = j NEW_LINE blockSize [ j ] -= processSize [ i ] NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT print ( " Process ▁ No . \tProcess ▁ Size\tBlock ▁ no . " ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( " ▁ " , i + 1 , " \t\t " , processSize [ i ] , " \t\t " , if ( allocation [ i ] != - 1 ) : NEW_LINE INDENT print ( allocation [ i ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ Allocated " ) NEW_LINE DEDENT DEDENT

BLEU: 69.3
Edit Sim: 103


Src: 
int firstNonRepeating ( int arr [ ] , int n ) { unordered_map < int , int > mp ; for ( int i = 0 ; i < n ; i ++ ) mp [ arr [ i ] ] ++ ; for ( int i = 0 ; i < n ; i ++ ) if ( mp [ arr [ i ] ] == 1 ) return arr [ i ] ; return - 1 ; }
Ref: 
def firstNonRepeating ( arr , n ) : NEW_LINE INDENT mp = defaultdict ( lambda : 0 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if mp [ arr [ i ] ] == 1 : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
Hyp: 
def firstNonRepeating ( arr , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] = mp . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( mp [ arr [ i ] ] == 1 ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT

BLEU: 73.92
Edit Sim: 52


Src: 
bool distributingBalls ( int k , int n , string str ) { int a [ MAX_CHAR ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { a [ str [ i ] - ' a ' ] ++ ; } for ( int i = 0 ; i < MAX_CHAR ; i ++ ) if ( a [ i ] > k ) return false ; return true ; }
Ref: 
def distributingBalls ( k , n , string ) : NEW_LINE INDENT a = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( n ) : NEW_LINE INDENT a [ ord ( string [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( MAX_CHAR ) : NEW_LINE INDENT if ( a [ i ] > k ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
Hyp: 
def distributingBalls ( k , n , str ) : NEW_LINE INDENT a = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( n ) : NEW_LINE INDENT a [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( MAX_CHAR ) : NEW_LINE INDENT if ( a [ i ] > k ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT

BLEU: 93.78
Edit Sim: 6


Src: 
ll count_of_ways ( ll n ) { ll count ; count = ( n + 1 ) * ( n + 2 ) / 2 ; return count ; }
Ref: 
def count_of_ways ( n ) : NEW_LINE INDENT count = 0 NEW_LINE count = ( n + 1 ) * ( n + 2 ) // 2 NEW_LINE return count NEW_LINE DEDENT
Hyp: 
def count_of_ways ( n ) : NEW_LINE INDENT count = ( n + 1 ) * ( n + 2 ) / 2 NEW_LINE return int ( count ) NEW_LINE DEDENT

BLEU: 71.32
Edit Sim: 28


Src: 
int maxSum ( int arr [ ] , int n ) { int cum_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) cum_sum += arr [ i ] ; int curr_val = 0 ; for ( int i = 0 ; i < n ; i ++ ) curr_val += i * arr [ i ] ; int res = curr_val ; for ( int i = 1 ; i < n ; i ++ ) { int next_val = curr_val - ( cum_sum - arr [ i - 1 ] ) + arr [ i - 1 ] * ( n - 1 ) ; curr_val = next_val ; res = max ( res , next_val ) ; } return res ; }
Ref: 
def maxSum ( arr , n ) : NEW_LINE INDENT cum_sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT cum_sum += arr [ i ] NEW_LINE DEDENT curr_val = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT curr_val += i * arr [ i ] NEW_LINE DEDENT res = curr_val NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT next_val = ( curr_val - ( cum_sum - arr [ i - 1 ] ) + arr [ i - 1 ] * ( n - 1 ) ) NEW_LINE curr_val = next_val NEW_LINE res = max ( res , next_val ) NEW_LINE DEDENT return res NEW_LINE DEDENT
Hyp: 
def maxSum ( arr , n ) : NEW_LINE INDENT cum_sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT cum_sum += arr [ i ] NEW_LINE DEDENT curr_val = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT curr_val += i * arr [ i ] NEW_LINE DEDENT res = curr_val NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT next_val = curr_val - ( cum_sum - arr [ i - 1 ] ) + arr [ i - 1 ] * ( n - 1 ) NEW_LINE curr_val = next_val NEW_LINE res = max ( res , next_val ) NEW_LINE DEDENT return res NEW_LINE DEDENT

BLEU: 90.7
Edit Sim: 12


Src: 
int calcAngle ( double h , double m ) { if ( h < 0 || m < 0 || h > 12 || m > 60 ) printf ( " Wrong ▁ input " ) ; if ( h == 12 ) h = 0 ; if ( m == 60 ) m = 0 ; int hour_angle = 0.5 * ( h * 60 + m ) ; int minute_angle = 6 * m ; int angle = abs ( hour_angle - minute_angle ) ; angle = min ( 360 - angle , angle ) ; return angle ; }
Ref: 
def calcAngle ( h , m ) : NEW_LINE INDENT if ( h < 0 or m < 0 or h > 12 or m > 60 ) : NEW_LINE INDENT print ( ' Wrong ▁ input ' ) NEW_LINE DEDENT if ( h == 12 ) : NEW_LINE INDENT h = 0 NEW_LINE DEDENT if ( m == 60 ) : NEW_LINE INDENT m = 0 NEW_LINE DEDENT hour_angle = 0.5 * ( h * 60 + m ) NEW_LINE minute_angle = 6 * m NEW_LINE angle = abs ( hour_angle - minute_angle ) NEW_LINE angle = min ( 360 - angle , angle ) NEW_LINE return angle NEW_LINE DEDENT
Hyp: 
def calcAngle ( h , m ) : NEW_LINE INDENT if ( h < 0 or m < 0 or h > 12 or m > 60 ) : NEW_LINE INDENT print ( " Wrong ▁ input " ) NEW_LINE DEDENT if ( h == 12 ) : NEW_LINE INDENT h = 0 NEW_LINE DEDENT if ( m == 60 ) : NEW_LINE INDENT m = 0 NEW_LINE DEDENT hour_angle = 0.5 * ( h * 60 + m ) NEW_LINE minute_angle = 6 * m NEW_LINE angle = abs ( hour_angle - minute_angle ) NEW_LINE angle = min ( 360 - angle , angle ) NEW_LINE return angle NEW_LINE DEDENT

BLEU: 95.43
Edit Sim: 2


Src: 
int smallest ( int x , int y , int z ) { if ( ! ( y / x ) ) return ( ! ( y / z ) ) ? y : z ; return ( ! ( x / z ) ) ? x : z ; }
Ref: 
def smallest ( x , y , z ) : NEW_LINE INDENT if ( not ( y / x ) ) : NEW_LINE INDENT return y if ( not ( y / z ) ) else z NEW_LINE DEDENT return x if ( not ( x / z ) ) else z NEW_LINE DEDENT
Hyp: 
def smallest ( x , y , z ) : NEW_LINE INDENT if ( not ( y / x ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT

BLEU: 42.46
Edit Sim: 54


Src: 
char findExtraCharcter ( string strA , string strB ) { int res = 0 , i ; for ( i = 0 ; i < strA . length ( ) ; i ++ ) { res ^= strA [ i ] ; } for ( i = 0 ; i < strB . length ( ) ; i ++ ) { res ^= strB [ i ] ; } return ( ( char ) ( res ) ) ; }
Ref: 
def findExtraCharcter ( strA , strB ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 0 , len ( strA ) ) : NEW_LINE INDENT res = res ^ ( ord ) ( strA [ i ] ) NEW_LINE DEDENT for i in range ( 0 , len ( strB ) ) : NEW_LINE INDENT res = res ^ ( ord ) ( strB [ i ] ) NEW_LINE DEDENT return ( ( chr ) ( res ) ) ; NEW_LINE DEDENT
Hyp: 
def findExtraCharcter ( strA , strB ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( len ( strA ) ) : NEW_LINE INDENT res ^= strA [ i ] NEW_LINE DEDENT for i in range ( len ( strB ) ) : NEW_LINE INDENT res ^= strB [ i ] NEW_LINE DEDENT return ( ( char ) ( res ) ) NEW_LINE DEDENT

BLEU: 58.12
Edit Sim: 47


Src: 
void recaman ( int n ) { if ( n <= 0 ) return ; printf ( " % d , ▁ " , 0 ) ; unordered_set < int > s ; s . insert ( 0 ) ; int prev = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int curr = prev - i ; if ( curr < 0 || s . find ( curr ) != s . end ( ) ) curr = prev + i ; s . insert ( curr ) ; printf ( " % d , ▁ " , curr ) ; prev = curr ; } }
Ref: 
def recaman ( n ) : NEW_LINE INDENT if ( n <= 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT print ( 0 , " , " , end = ' ' ) NEW_LINE s = set ( [ ] ) NEW_LINE s . add ( 0 ) NEW_LINE prev = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT curr = prev - i NEW_LINE if ( curr < 0 or curr in s ) : NEW_LINE INDENT curr = prev + i NEW_LINE DEDENT s . add ( curr ) NEW_LINE print ( curr , " , " , end = ' ' ) NEW_LINE prev = curr NEW_LINE DEDENT DEDENT
Hyp: 
def recaman ( n ) : NEW_LINE INDENT if ( n <= 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT s = set ( ) NEW_LINE prev = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT curr = prev - i NEW_LINE if curr < 0 or curr in s : NEW_LINE INDENT curr = prev + i NEW_LINE DEDENT s . add ( curr ) NEW_LINE print ( " % d , ▁ " , curr ) NEW_LINE prev = curr NEW_LINE DEDENT DEDENT

BLEU: 62.45
Edit Sim: 88


Src: 
int findMinimumAngle ( int arr [ ] , int n ) { int l = 0 , sum = 0 , ans = 360 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; while ( sum >= 180 ) { ans = min ( ans , 2 * abs ( 180 - sum ) ) ; sum -= arr [ l ] ; l ++ ; } ans = min ( ans , 2 * abs ( 180 - sum ) ) ; } return ans ; }
Ref: 
def findMinimumAngle ( arr , n ) : NEW_LINE INDENT l = 0 NEW_LINE _sum = 0 NEW_LINE ans = 360 NEW_LINE for i in range ( n ) : NEW_LINE INDENT _sum += arr [ i ] NEW_LINE while _sum >= 180 : NEW_LINE INDENT ans = min ( ans , 2 * abs ( 180 - _sum ) ) NEW_LINE _sum -= arr [ l ] NEW_LINE l += 1 NEW_LINE DEDENT ans = min ( ans , 2 * abs ( 180 - _sum ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
Hyp: 
def findMinimumAngle ( arr , n ) : NEW_LINE INDENT l = 0 NEW_LINE sum = 0 NEW_LINE ans = 360 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE while ( sum >= 180 ) : NEW_LINE INDENT ans = min ( ans , 2 * abs ( 180 - sum ) ) NEW_LINE sum -= arr [ l ] NEW_LINE l += 1 NEW_LINE DEDENT ans = min ( ans , 2 * abs ( 180 - sum ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT

BLEU: 77.3
Edit Sim: 13


Src: 
void countSubsequence ( char s [ ] , int n ) { int cntG = 0 , cntF = 0 , result = 0 , C = 0 ; for ( int i = 0 ; i < n ; i ++ ) { switch ( s [ i ] ) { case ' G ' : cntG ++ ; result += C ; break ; case ' F ' : cntF ++ ; C += cntG ; break ; default : continue ; } } cout << result << endl ; }
Ref: 
def countSubsequence ( s , n ) : NEW_LINE INDENT cntG = 0 NEW_LINE cntF = 0 NEW_LINE result = 0 NEW_LINE C = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == ' G ' ) : NEW_LINE INDENT cntG += 1 NEW_LINE result += C NEW_LINE continue NEW_LINE DEDENT if ( s [ i ] == ' F ' ) : NEW_LINE INDENT cntF += 1 NEW_LINE C += cntG NEW_LINE continue NEW_LINE DEDENT else : NEW_LINE INDENT continue NEW_LINE DEDENT DEDENT print ( result ) NEW_LINE DEDENT
Hyp: 
def countSubsequence ( s , n ) : NEW_LINE INDENT cntG = 0 NEW_LINE cntF = 0 NEW_LINE result = 0 NEW_LINE C = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT switch ( s [ i ] ) : NEW_LINE INDENT case ' G ' : NEW_LINE INDENT cntG += 1 NEW_LINE result += C NEW_LINE break NEW_LINE DEDENT case ' F ' : NEW_LINE INDENT cntF += 1 NEW_LINE C += cntG NEW_LINE break NEW_LINE DEDENT default : NEW_LINE INDENT continue NEW_LINE DEDENT DEDENT print ( result ) NEW_LINE DEDENT

BLEU: 74.74
Edit Sim: 68


Src: 
int maxdiff ( int arr [ ] , int n ) { unordered_map < int , int > freq ; for ( int i = 0 ; i < n ; i ++ ) freq [ arr [ i ] ] ++ ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( freq [ arr [ i ] ] > freq [ arr [ j ] ] && arr [ i ] > arr [ j ] ) ans = max ( ans , freq [ arr [ i ] ] - freq [ arr [ j ] ] ) ; else if ( freq [ arr [ i ] ] < freq [ arr [ j ] ] && arr [ i ] < arr [ j ] ) ans = max ( ans , freq [ arr [ j ] ] - freq [ arr [ i ] ] ) ; } } return ans ; }
Ref: 
def maxdiff ( arr , n ) : NEW_LINE INDENT freq = defaultdict ( lambda : 0 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ arr [ i ] ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if freq [ arr [ i ] ] > freq [ arr [ j ] ] and arr [ i ] > arr [ j ] : NEW_LINE INDENT ans = max ( ans , freq [ arr [ i ] ] - freq [ arr [ j ] ] ) NEW_LINE DEDENT elif freq [ arr [ i ] ] < freq [ arr [ j ] ] and arr [ i ] < arr [ j ] : NEW_LINE INDENT ans = max ( ans , freq [ arr [ j ] ] - freq [ arr [ i ] ] ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
Hyp: 
def maxdiff ( arr , n ) : NEW_LINE INDENT freq = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ arr [ i ] ] = freq . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( freq [ arr [ i ] ] > freq [ arr [ j ] ] and arr [ i ] > arr [ j ] ) : NEW_LINE INDENT ans = max ( ans , freq [ arr [ i ] ] - freq [ arr [ j ] ] ) NEW_LINE DEDENT elif ( freq [ arr [ i ] ] < freq [ arr [ j ] ] and arr [ i ] < arr [ j ] ) : NEW_LINE INDENT ans = max ( ans , freq [ arr [ j ] ] - freq [ arr [ i ] ] ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT

BLEU: 85.42
Edit Sim: 58


Src: 
bool areEqual ( int arr1 [ ] , int arr2 [ ] , int n , int m ) { if ( n != m ) return false ; sort ( arr1 , arr1 + n ) ; sort ( arr2 , arr2 + m ) ; for ( int i = 0 ; i < n ; i ++ ) if ( arr1 [ i ] != arr2 [ i ] ) return false ; return true ; }
Ref: 
def areEqual ( arr1 , arr2 , n , m ) : NEW_LINE INDENT if ( n != m ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT arr1 . sort ( ) ; NEW_LINE arr2 . sort ( ) ; NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( arr1 [ i ] != arr2 [ i ] ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT return True ; NEW_LINE DEDENT
Hyp: 
def areEqual ( arr1 , arr2 , n , m ) : NEW_LINE INDENT if n != m : NEW_LINE INDENT return 0 NEW_LINE DEDENT arr1 . sort ( ) NEW_LINE arr2 . sort ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if arr1 [ i ] != arr2 [ i ] : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT

BLEU: 62.63
Edit Sim: 36


Src: 
int countFriendsPairings ( int n ) { int a = 1 , b = 2 , c = 0 ; if ( n <= 2 ) { return n ; } for ( int i = 3 ; i <= n ; i ++ ) { c = b + ( i - 1 ) * a ; a = b ; b = c ; } return c ; }
Ref: 
def countFriendsPairings ( n ) : NEW_LINE INDENT a , b , c = 1 , 2 , 0 NEW_LINE if ( n <= 2 ) : NEW_LINE INDENT return n NEW_LINE DEDENT for i in range ( 3 , n + 1 ) : NEW_LINE INDENT c = b + ( i - 1 ) * a NEW_LINE a = b NEW_LINE b = c NEW_LINE DEDENT return c NEW_LINE DEDENT
Hyp: 
def countFriendsPairings ( n ) : NEW_LINE INDENT a = 1 NEW_LINE b = 2 NEW_LINE c = 0 NEW_LINE if n <= 2 : NEW_LINE INDENT return n NEW_LINE DEDENT for i in range ( 3 , n + 1 ) : NEW_LINE INDENT c = b + ( i - 1 ) * a NEW_LINE a = b NEW_LINE b = c NEW_LINE DEDENT return c NEW_LINE DEDENT

BLEU: 80.27
Edit Sim: 26


Src: 
int PowerOFPINnfactorial ( int n , int p ) { int ans = 0 ; int temp = p ; while ( temp <= n ) { ans += n / temp ; temp = temp * p ; } return ans ; }
Ref: 
def PowerOFPINnfactorial ( n , p ) : NEW_LINE INDENT ans = 0 NEW_LINE temp = p NEW_LINE while ( temp <= n ) : NEW_LINE INDENT ans += n / temp NEW_LINE temp = temp * p NEW_LINE DEDENT return ans NEW_LINE DEDENT
Hyp: 
def PowerOFPINnfactorial ( n , p ) : NEW_LINE INDENT ans = 0 NEW_LINE temp = p NEW_LINE while ( temp <= n ) : NEW_LINE INDENT ans += n / temp NEW_LINE temp = temp * p NEW_LINE DEDENT return ans NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int findLength ( char * str ) { int n = strlen ( str ) ; int maxlen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j += 2 ) { int length = j - i + 1 ; int leftsum = 0 , rightsum = 0 ; for ( int k = 0 ; k < length / 2 ; k ++ ) { leftsum += ( str [ i + k ] - '0' ) ; rightsum += ( str [ i + k + length / 2 ] - '0' ) ; } if ( leftsum == rightsum && maxlen < length ) maxlen = length ; } } return maxlen ; }
Ref: 
def findLength ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE maxlen = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n , 2 ) : NEW_LINE INDENT length = j - i + 1 NEW_LINE leftsum = 0 NEW_LINE rightsum = 0 NEW_LINE for k in range ( 0 , int ( length / 2 ) ) : NEW_LINE INDENT leftsum += ( int ( str [ i + k ] ) - int ( '0' ) ) NEW_LINE rightsum += ( int ( str [ i + k + int ( length / 2 ) ] ) - int ( '0' ) ) NEW_LINE DEDENT if ( leftsum == rightsum and maxlen < length ) : NEW_LINE INDENT maxlen = length NEW_LINE DEDENT DEDENT DEDENT return maxlen NEW_LINE DEDENT
Hyp: 
def findLength ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE maxlen = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n , 2 ) : NEW_LINE INDENT length = j - i + 1 NEW_LINE leftsum = 0 NEW_LINE rightsum = 0 NEW_LINE for k in range ( 0 , int ( length / 2 ) ) : NEW_LINE INDENT leftsum += ( ord ( str [ i + k ] ) - ord ( '0' ) ) NEW_LINE rightsum += ( ord ( str [ i + k + length // 2 ] ) - ord ( '0' ) ) NEW_LINE DEDENT if ( leftsum == rightsum and maxlen < length ) : NEW_LINE INDENT maxlen = length NEW_LINE DEDENT DEDENT DEDENT return maxlen NEW_LINE DEDENT

BLEU: 88.48
Edit Sim: 21


Src: 
int search ( int arr [ ] , int n , int x ) { int i ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == x ) return i ; } return - 1 ; }
Ref: 
def search ( arr , n , x ) : NEW_LINE INDENT i = 0 NEW_LINE for i in range ( i , n ) : NEW_LINE INDENT if ( arr [ i ] == x ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
Hyp: 
def search ( arr , n , x ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == x ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT

BLEU: 80.98
Edit Sim: 19


Src: 
void subArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { for ( int k = i ; k <= j ; k ++ ) cout << arr [ k ] << " ▁ " ; cout << endl ; } } }
Ref: 
def subArray ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT for k in range ( i , j + 1 ) : NEW_LINE INDENT print ( arr [ k ] , end = " ▁ " ) NEW_LINE DEDENT print ( " \n " , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
Hyp: 
def subArray ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT for k in range ( i , j + 1 ) : NEW_LINE INDENT print ( arr [ k ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT DEDENT

BLEU: 87.24
Edit Sim: 19


Src: 
bool isSubSeqDivisible ( string str ) { int n = str . length ( ) ; int dp [ n + 1 ] [ 10 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; int arr [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) arr [ i ] = str [ i - 1 ] - '0' ; for ( int i = 1 ; i <= n ; i ++ ) { dp [ i ] [ arr [ i ] % 8 ] = 1 ; for ( int j = 0 ; j < 8 ; j ++ ) { if ( dp [ i - 1 ] [ j ] > dp [ i ] [ ( j * 10 + arr [ i ] ) % 8 ] ) dp [ i ] [ ( j * 10 + arr [ i ] ) % 8 ] = dp [ i - 1 ] [ j ] ; if ( dp [ i - 1 ] [ j ] > dp [ i ] [ j ] ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; } } for ( int i = 1 ; i <= n ; i ++ ) { if ( dp [ i ] [ 0 ] == 1 ) return true ; } return false ; }
Ref: 
def isSubSeqDivisible ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE dp = [ [ 0 for i in range ( 10 ) ] for i in range ( n + 1 ) ] NEW_LINE arr = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT arr [ i ] = int ( str [ i - 1 ] ) NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT dp [ i ] [ arr [ i ] % 8 ] = 1 NEW_LINE for j in range ( 8 ) : NEW_LINE INDENT if ( dp [ i - 1 ] [ j ] > dp [ i ] [ ( j * 10 + arr [ i ] ) % 8 ] ) : NEW_LINE INDENT dp [ i ] [ ( j * 10 + arr [ i ] ) % 8 ] = dp [ i - 1 ] [ j ] NEW_LINE DEDENT if ( dp [ i - 1 ] [ j ] > dp [ i ] [ j ] ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( dp [ i ] [ 0 ] == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
Hyp: 
def isSubSeqDivisible ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE dp = [ [ 0 for j in range ( 10 ) ] for i in range ( n + 1 ) ] NEW_LINE arr = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT arr [ i ] = ord ( str [ i - 1 ] ) - ord ( '0' ) NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT dp [ i ] [ arr [ i ] % 8 ] = 1 NEW_LINE for j in range ( 8 ) : NEW_LINE INDENT if ( dp [ i - 1 ] [ j ] > dp [ i ] [ ( j * 10 + arr [ i ] ) % 8 ] ) : NEW_LINE INDENT dp [ i ] [ ( j * 10 + arr [ i ] ) % 8 ] = dp [ i - 1 ] [ j ] NEW_LINE DEDENT if ( dp [ i - 1 ] [ j ] > dp [ i ] [ j ] ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( dp [ i ] [ 0 ] == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT

BLEU: 96.06
Edit Sim: 18


Src: 
void solve ( int i , int par , int a [ ] , int n , int k , int current_ans ) { if ( par > k ) return ; if ( par == k && i == n - 1 ) { ans = min ( ans , current_ans ) ; return ; } for ( int j = i + 1 ; j < n ; j ++ ) solve ( j , par + 1 , a , n , k , current_ans + ( a [ j ] - a [ i + 1 ] ) * ( a [ j ] - a [ i + 1 ] ) ) ; }
Ref: 
def solve ( i , par , a , n , k , current_ans ) : NEW_LINE INDENT if ( par > k ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT global ans NEW_LINE if ( par == k and i == n - 1 ) : NEW_LINE INDENT ans = min ( ans , current_ans ) NEW_LINE return 0 NEW_LINE DEDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT solve ( j , par + 1 , a , n , k , current_ans + ( a [ j ] - a [ i + 1 ] ) * ( a [ j ] - a [ i + 1 ] ) ) NEW_LINE DEDENT DEDENT
Hyp: 
def solve ( i , par , a , n , k , current_ans ) : NEW_LINE INDENT if ( par > k ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( par == k and i == n - 1 ) : NEW_LINE INDENT ans = min ( ans , current_ans ) NEW_LINE return NEW_LINE DEDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT solve ( j , par + 1 , a , n , k , current_ans + ( a [ j ] - a [ i + 1 ] ) * ( a [ j ] - a [ i + 1 ] ) ) NEW_LINE DEDENT DEDENT

BLEU: 92.33
Edit Sim: 24


Src: 
public : float squareRoot ( float n ) { float x = n ; float y = 1 ; float e = 0.000001 ; while ( x - y > e ) { x = ( x + y ) / 2 ; y = n / x ; } return x ; }
Ref: 
def squareRoot ( n ) : NEW_LINE INDENT x = n NEW_LINE y = 1 NEW_LINE e = 0.000001 NEW_LINE while ( x - y > e ) : NEW_LINE INDENT x = ( x + y ) / 2 NEW_LINE y = n / x NEW_LINE DEDENT return x NEW_LINE DEDENT
Hyp: 
def squareRoot ( n ) : NEW_LINE INDENT x = n NEW_LINE y = 1 NEW_LINE while ( x > y ) : NEW_LINE INDENT x = ( x + y ) / 2 NEW_LINE y = n / x NEW_LINE DEDENT return x NEW_LINE DEDENT

BLEU: 80.25
Edit Sim: 27


Src: 
int CountPairs ( int n ) { int k = n ; int imin = 1 ; int ans = 0 ; while ( imin <= n ) { int imax = n / k ; ans += k * ( imax - imin + 1 ) ; imin = imax + 1 ; k = n / imin ; } return ans ; }
Ref: 
def CountPairs ( n ) : NEW_LINE INDENT k = n NEW_LINE imin = 1 NEW_LINE ans = 0 NEW_LINE while ( imin <= n ) : NEW_LINE INDENT imax = n / k NEW_LINE ans += k * ( imax - imin + 1 ) NEW_LINE imin = imax + 1 NEW_LINE k = n / imin NEW_LINE DEDENT return ans NEW_LINE DEDENT
Hyp: 
def CountPairs ( n ) : NEW_LINE INDENT k = n NEW_LINE imin = 1 NEW_LINE ans = 0 NEW_LINE while ( imin <= n ) : NEW_LINE INDENT imax = n // k NEW_LINE ans += k * ( imax - imin + 1 ) NEW_LINE imin = imax + 1 NEW_LINE k = n / imin NEW_LINE DEDENT return ans NEW_LINE DEDENT

BLEU: 96.01
Edit Sim: 1


Src: 
int multiplyWith3Point5 ( int x ) { return ( x << 1 ) + x + ( x >> 1 ) ; }
Ref: 
def multiplyWith3Point5 ( x ) : NEW_LINE INDENT return ( x << 1 ) + x + ( x >> 1 ) NEW_LINE DEDENT
Hyp: 
def multiplyWith3Point5 ( x ) : NEW_LINE INDENT return ( x << 1 ) + x + ( x >> 1 ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
bool prevPermutation ( string & str ) { int n = str . length ( ) - 1 ; int i = n ; while ( i > 0 && str [ i - 1 ] <= str [ i ] ) i -- ; if ( i <= 0 ) return false ; int j = i - 1 ; while ( j + 1 <= n && str [ j + 1 ] <= str [ i - 1 ] ) j ++ ; swap ( str [ i - 1 ] , str [ j ] ) ; reverse ( str . begin ( ) + i , str . end ( ) ) ; return true ; }
Ref: 
def prevPermutation ( str ) : NEW_LINE INDENT n = len ( str ) - 1 NEW_LINE i = n NEW_LINE while ( i > 0 and str [ i - 1 ] <= str [ i ] ) : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT if ( i <= 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT j = i - 1 NEW_LINE while ( j + 1 <= n and str [ j + 1 ] <= str [ i - 1 ] ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT str = list ( str ) NEW_LINE temp = str [ i - 1 ] NEW_LINE str [ i - 1 ] = str [ j ] NEW_LINE str [ j ] = temp NEW_LINE str = ' ' . join ( str ) NEW_LINE str [ : : - 1 ] NEW_LINE return True , str NEW_LINE DEDENT
Hyp: 
def prevPermutation ( str ) : NEW_LINE INDENT n = len ( str ) - 1 NEW_LINE i = n NEW_LINE while ( i > 0 and str [ i - 1 ] <= str [ i ] ) : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT if ( i <= 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT j = i - 1 NEW_LINE while ( j + 1 <= n and str [ j + 1 ] <= str [ i - 1 ] ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT str [ i - 1 ] , str [ j ] = str [ j ] , str [ i - 1 ] NEW_LINE str [ i - 1 ] = str [ i - 1 ] , str [ j ] NEW_LINE return True NEW_LINE DEDENT

BLEU: 79.73
Edit Sim: 95


Src: 
double polygonArea ( double X [ ] , double Y [ ] , int n ) { double area = 0.0 ; int j = n - 1 ; for ( int i = 0 ; i < n ; i ++ ) { area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) ; j = i ; } return abs ( area / 2.0 ) ; }
Ref: 
def polygonArea ( X , Y , n ) : NEW_LINE INDENT area = 0.0 NEW_LINE j = n - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) NEW_LINE j = i NEW_LINE DEDENT return int ( abs ( area / 2.0 ) ) NEW_LINE DEDENT
Hyp: 
def polygonArea ( X , Y , n ) : NEW_LINE INDENT area = 0.0 NEW_LINE j = n - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT area = area + ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) NEW_LINE j = i NEW_LINE DEDENT return abs ( area // 2.0 ) NEW_LINE DEDENT

BLEU: 86.7
Edit Sim: 17


Src: 
int equilibrium ( int arr [ ] , int n ) { int i , j ; int leftsum , rightsum ; for ( i = 0 ; i < n ; ++ i ) { leftsum = 0 ; for ( j = 0 ; j < i ; j ++ ) leftsum += arr [ j ] ; rightsum = 0 ; for ( j = i + 1 ; j < n ; j ++ ) rightsum += arr [ j ] ; if ( leftsum == rightsum ) return i ; } return - 1 ; }
Ref: 
def equilibrium ( arr ) : NEW_LINE INDENT leftsum = 0 NEW_LINE rightsum = 0 NEW_LINE n = len ( arr ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT leftsum = 0 NEW_LINE rightsum = 0 NEW_LINE for j in range ( i ) : NEW_LINE INDENT leftsum += arr [ j ] NEW_LINE DEDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT rightsum += arr [ j ] NEW_LINE DEDENT if leftsum == rightsum : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
Hyp: 
def equilibrium ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT leftsum = 0 NEW_LINE for j in range ( i ) : NEW_LINE INDENT leftsum += arr [ j ] NEW_LINE DEDENT rightsum = 0 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT rightsum += arr [ j ] NEW_LINE DEDENT if ( leftsum == rightsum ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT

BLEU: 75.36
Edit Sim: 118


Src: 
int chordCnt ( int A ) { int n = 2 * A ; int dpArray [ n + 1 ] = { 0 } ; dpArray [ 0 ] = 1 ; dpArray [ 2 ] = 1 ; for ( int i = 4 ; i <= n ; i += 2 ) { for ( int j = 0 ; j < i - 1 ; j += 2 ) { dpArray [ i ] += ( dpArray [ j ] * dpArray [ i - 2 - j ] ) ; } } return dpArray [ n ] ; }
Ref: 
def chordCnt ( A ) : NEW_LINE INDENT n = 2 * A NEW_LINE dpArray = [ 0 ] * ( n + 1 ) NEW_LINE dpArray [ 0 ] = 1 NEW_LINE dpArray [ 2 ] = 1 NEW_LINE for i in range ( 4 , n + 1 , 2 ) : NEW_LINE INDENT for j in range ( 0 , i - 1 , 2 ) : NEW_LINE INDENT dpArray [ i ] += ( dpArray [ j ] * dpArray [ i - 2 - j ] ) NEW_LINE DEDENT DEDENT return int ( dpArray [ n ] ) NEW_LINE DEDENT
Hyp: 
def chordCnt ( A ) : NEW_LINE INDENT n = 2 * A NEW_LINE dpArray = [ 0 for i in range ( n + 1 ) ] NEW_LINE dpArray [ 0 ] = 1 NEW_LINE dpArray [ 2 ] = 1 NEW_LINE for i in range ( 4 , n + 2 ) : NEW_LINE INDENT for j in range ( i - 1 , 2 ) : NEW_LINE INDENT dpArray [ i ] += ( dpArray [ j ] * dpArray [ i - 2 - j ] ) NEW_LINE DEDENT DEDENT return dpArray [ n ] NEW_LINE DEDENT

BLEU: 82.87
Edit Sim: 31


Src: 
double compute ( int a , int b ) { double AM , GM , HM ; AM = ( a + b ) / 2 ; GM = sqrt ( a * b ) ; HM = ( GM * GM ) / AM ; return HM ; }
Ref: 
def compute ( a , b ) : NEW_LINE INDENT AM = ( a + b ) / 2 NEW_LINE GM = math . sqrt ( a * b ) NEW_LINE HM = ( GM * GM ) / AM NEW_LINE return HM NEW_LINE DEDENT
Hyp: 
def compute ( a , b ) : NEW_LINE INDENT AM = ( a + b ) / 2 NEW_LINE GM = math . sqrt ( a * b ) NEW_LINE HM = ( GM * GM ) / AM NEW_LINE return HM NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
void findMajority ( int arr [ ] , int n ) { int maxCount = 0 ; int index = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ i ] == arr [ j ] ) count ++ ; } if ( count > maxCount ) { maxCount = count ; index = i ; } } if ( maxCount > n / 2 ) cout << arr [ index ] << endl ; else cout << " No ▁ Majority ▁ Element " << endl ; }
Ref: 
def findMajority ( arr , n ) : NEW_LINE INDENT maxCount = 0 ; NEW_LINE index = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == arr [ j ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( count > maxCount ) : NEW_LINE INDENT maxCount = count NEW_LINE index = i NEW_LINE DEDENT DEDENT if ( maxCount > n // 2 ) : NEW_LINE INDENT print ( arr [ index ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No ▁ Majority ▁ Element " ) NEW_LINE DEDENT DEDENT
Hyp: 
def findMajority ( arr , n ) : NEW_LINE INDENT maxCount = 0 NEW_LINE index = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == arr [ j ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( count > maxCount ) : NEW_LINE INDENT maxCount = count NEW_LINE index = i NEW_LINE DEDENT DEDENT if ( maxCount > n // 2 ) : NEW_LINE INDENT print ( arr [ index ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No ▁ Majority ▁ Element " ) NEW_LINE DEDENT DEDENT

BLEU: 97.91
Edit Sim: 2


Src: 
bool isPerfectSquare ( int n ) { for ( int sum = 0 , i = 1 ; sum < n ; i += 2 ) { sum += i ; if ( sum == n ) return true ; } return false ; }
Ref: 
def isPerfectSquare ( n ) : NEW_LINE INDENT i = 1 NEW_LINE the_sum = 0 NEW_LINE while the_sum < n : NEW_LINE INDENT the_sum += i NEW_LINE if the_sum == n : NEW_LINE INDENT return True NEW_LINE DEDENT i += 2 NEW_LINE DEDENT return False NEW_LINE DEDENT
Hyp: 
def isPerfectSquare ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE i = 1 NEW_LINE while ( sum < n ) : NEW_LINE INDENT sum += i NEW_LINE if ( sum == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT i += 2 NEW_LINE DEDENT return False NEW_LINE DEDENT

BLEU: 60.97
Edit Sim: 28


Src: 
string findSubString ( string str , string pat ) { int len1 = str . length ( ) ; int len2 = pat . length ( ) ; if ( len1 < len2 ) { cout << " No ▁ such ▁ window ▁ exists " ; return " " ; } int hash_pat [ no_of_chars ] = { 0 } ; int hash_str [ no_of_chars ] = { 0 } ; for ( int i = 0 ; i < len2 ; i ++ ) hash_pat [ pat [ i ] ] ++ ; int start = 0 , start_index = - 1 , min_len = INT_MAX ; int count = 0 ; for ( int j = 0 ; j < len1 ; j ++ ) { hash_str [ str [ j ] ] ++ ; if ( hash_pat [ str [ j ] ] != 0 && hash_str [ str [ j ] ] <= hash_pat [ str [ j ] ] ) count ++ ; if ( count == len2 ) { while ( hash_str [ str [ start ] ] > hash_pat [ str [ start ] ] || hash_pat [ str [ start ] ] == 0 ) { if ( hash_str [ str [ start ] ] > hash_pat [ str [ start ] ] ) hash_str [ str [ start ] ] -- ; start ++ ; } int len_window = j - start + 1 ; if ( min_len > len_window ) { min_len = len_window ; start_index = start ; } } } if ( start_index == - 1 ) { cout << " No ▁ such ▁ window ▁ exists " ; return " " ; } return str . substr ( start_index , min_len ) ; }
Ref: 
def findSubString ( string , pat ) : NEW_LINE INDENT len1 = len ( string ) NEW_LINE len2 = len ( pat ) NEW_LINE if len1 < len2 : NEW_LINE INDENT print ( " No ▁ such ▁ window ▁ exists " ) NEW_LINE return " " NEW_LINE DEDENT hash_pat = [ 0 ] * no_of_chars NEW_LINE hash_str = [ 0 ] * no_of_chars NEW_LINE for i in range ( 0 , len2 ) : NEW_LINE INDENT hash_pat [ ord ( pat [ i ] ) ] += 1 NEW_LINE DEDENT start , start_index , min_len = 0 , - 1 , float ( ' inf ' ) NEW_LINE count = 0 NEW_LINE for j in range ( 0 , len1 ) : NEW_LINE INDENT hash_str [ ord ( string [ j ] ) ] += 1 NEW_LINE if ( hash_pat [ ord ( string [ j ] ) ] != 0 and hash_str [ ord ( string [ j ] ) ] <= hash_pat [ ord ( string [ j ] ) ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if count == len2 : NEW_LINE INDENT while ( hash_str [ ord ( string [ start ] ) ] > hash_pat [ ord ( string [ start ] ) ] or hash_pat [ ord ( string [ start ] ) ] == 0 ) : NEW_LINE INDENT if ( hash_str [ ord ( string [ start ] ) ] > hash_pat [ ord ( string [ start ] ) ] ) : NEW_LINE INDENT hash_str [ ord ( string [ start ] ) ] -= 1 NEW_LINE DEDENT start += 1 NEW_LINE DEDENT len_window = j - start + 1 NEW_LINE if min_len > len_window : NEW_LINE INDENT min_len = len_window NEW_LINE start_index = start NEW_LINE DEDENT DEDENT DEDENT if start_index == - 1 : NEW_LINE INDENT print ( " No ▁ such ▁ window ▁ exists " ) NEW_LINE return " " NEW_LINE DEDENT return string [ start_index : start_index + min_len ] NEW_LINE DEDENT
Hyp: 
def findSubString ( str , pat ) : NEW_LINE INDENT len1 = len ( str ) NEW_LINE len2 = len ( pat ) NEW_LINE if len1 < len2 : NEW_LINE INDENT print ( " No ▁ such ▁ window ▁ exists " ) NEW_LINE return " " NEW_LINE DEDENT hash_pat = [ 0 ] * ( len2 - 1 ) NEW_LINE hash_str = [ 0 ] * ( len1 ) NEW_LINE start_index = - 1 NEW_LINE min_len = sys . maxsize NEW_LINE count = 0 NEW_LINE for j in range ( len1 ) : NEW_LINE INDENT hash_str [ ord ( str [ j ] ) ] += 1 NEW_LINE DEDENT if ( hash_pat [ ord ( str [ j ] ) ] != 0 and hash_str [ ord ( str [ j ] ) ] <= hash_pat [ ord ( str [ j ] ) ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( count == len2 ) : NEW_LINE INDENT while ( hash_str [ ord ( str [ start ] ) ] > hash_pat [ ord ( str [ start ] ) ] or hash_pat [ ord ( str [ start ] ) ] == 0 ) : NEW_LINE INDENT if ( hash_str [ ord ( str [ start ] ) ] > hash_pat [ ord ( str [ start ] ) ] ) : NEW_LINE INDENT hash_str [ ord ( str [ start ] ) ] -= 1 NEW_LINE DEDENT start += 1 NEW_LINE DEDENT len_window = j - start + 1 NEW_LINE if ( min_len > len_window ) : NEW_LINE INDENT min_len = len_window NEW_LINE start_index = start NEW_LINE DEDENT DEDENT DEDENT if ( start_index == - 1 ) : NEW_LINE INDENT print ( " No ▁ such ▁ window ▁ exists " ) NEW_LINE return " " NEW_LINE DEDENT

BLEU: 70.64
Edit Sim: 269


Src: 
int countDivisibleSubseq ( string str , int n ) { int len = str . length ( ) ; int dp [ len ] [ n ] ; memset ( dp , 0 , sizeof ( dp ) ) ; dp [ 0 ] [ ( str [ 0 ] - '0' ) % n ] ++ ; for ( int i = 1 ; i < len ; i ++ ) { dp [ i ] [ ( str [ i ] - '0' ) % n ] ++ ; for ( int j = 0 ; j < n ; j ++ ) { dp [ i ] [ j ] += dp [ i - 1 ] [ j ] ; dp [ i ] [ ( j * 10 + ( str [ i ] - '0' ) ) % n ] += dp [ i - 1 ] [ j ] ; } } return dp [ len - 1 ] [ 0 ] ; }
Ref: 
def countDivisibleSubseq ( str , n ) : NEW_LINE INDENT l = len ( str ) NEW_LINE dp = [ [ 0 for x in range ( l ) ] for y in range ( n ) ] NEW_LINE dp [ 0 ] [ ( ord ( str [ 0 ] ) - ord ( '0' ) ) % n ] += 1 NEW_LINE for i in range ( 1 , l ) : NEW_LINE INDENT dp [ i ] [ ( ord ( str [ i ] ) - ord ( '0' ) ) % n ] += 1 NEW_LINE for j in range ( n ) : NEW_LINE INDENT dp [ i ] [ j ] += dp [ i - 1 ] [ j ] NEW_LINE dp [ i ] [ ( j * 10 + ( ord ( str [ i ] ) - ord ( '0' ) ) ) % n ] += dp [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT return dp [ l - 1 ] [ 0 ] NEW_LINE DEDENT
Hyp: 
def countDivisibleSubseq ( str , n ) : NEW_LINE INDENT l = len ( str ) NEW_LINE dp = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] NEW_LINE dp [ 0 ] [ ( ord ( str [ 0 ] ) - ord ( '0' ) ) % n ] += 1 NEW_LINE for i in range ( 1 , l ) : NEW_LINE INDENT dp [ i ] [ ( ord ( str [ i ] ) - ord ( '0' ) ) % n ] += 1 NEW_LINE for j in range ( n ) : NEW_LINE INDENT dp [ i ] [ j ] += dp [ i - 1 ] [ j ] NEW_LINE dp [ i ] [ ( j * 10 + ( ord ( str [ i ] ) - ord ( '0' ) ) % n ] += dp [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT return dp [ l - 1 ] [ 0 ] NEW_LINE DEDENT

BLEU: 95.14
Edit Sim: 5


Src: 
void pairs ( int arr [ ] , int n , int k ) { int smallest = INT_MAX ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) { if ( abs ( arr [ i ] + arr [ j ] - k ) < smallest ) { smallest = abs ( arr [ i ] + arr [ j ] - k ) ; count = 1 ; } else if ( abs ( arr [ i ] + arr [ j ] - k ) == smallest ) count ++ ; } cout << " Minimal ▁ Value ▁ = ▁ " << smallest << " \n " ; cout << " Total ▁ Pairs ▁ = ▁ " << count << " \n " ; }
Ref: 
def pairs ( arr , n , k ) : NEW_LINE INDENT smallest = 999999999999 NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if abs ( arr [ i ] + arr [ j ] - k ) < smallest : NEW_LINE INDENT smallest = abs ( arr [ i ] + arr [ j ] - k ) NEW_LINE count = 1 NEW_LINE DEDENT elif abs ( arr [ i ] + arr [ j ] - k ) == smallest : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT print ( " Minimal ▁ Value ▁ = ▁ " , smallest ) NEW_LINE print ( " Total ▁ Pairs ▁ = ▁ " , count ) NEW_LINE DEDENT
Hyp: 
def pairs ( arr , n , k ) : NEW_LINE INDENT smallest = sys . maxsize NEW_LINE count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( abs ( arr [ i ] + arr [ j ] - k ) < smallest ) : NEW_LINE INDENT smallest = abs ( arr [ i ] + arr [ j ] - k ) NEW_LINE count = 1 NEW_LINE DEDENT elif ( abs ( arr [ i ] + arr [ j ] - k ) == smallest ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT print ( " Minimal ▁ Value ▁ = ▁ " , smallest ) NEW_LINE print ( " Total ▁ Pairs ▁ = ▁ " , count ) NEW_LINE DEDENT

BLEU: 87.81
Edit Sim: 25


Src: 
int nearestSmallerEqFib ( int n ) { if ( n == 0 || n == 1 ) return n ; int f1 = 0 , f2 = 1 , f3 = 1 ; while ( f3 <= n ) { f1 = f2 ; f2 = f3 ; f3 = f1 + f2 ; } return f2 ; }
Ref: 
def nearestSmallerEqFib ( n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT f1 , f2 , f3 = 0 , 1 , 1 NEW_LINE while ( f3 <= n ) : NEW_LINE INDENT f1 = f2 ; NEW_LINE f2 = f3 ; NEW_LINE f3 = f1 + f2 ; NEW_LINE DEDENT return f2 ; NEW_LINE DEDENT
Hyp: 
def nearestSmallerEqFib ( n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT f1 , f2 , f3 = 0 , 1 , 1 NEW_LINE while ( f3 <= n ) : NEW_LINE INDENT f1 = f2 NEW_LINE f2 = f3 NEW_LINE f3 = f1 + f2 NEW_LINE DEDENT return f2 NEW_LINE DEDENT

BLEU: 85.32
Edit Sim: 8


Src: 
void shuffle ( int card [ ] , int n ) { srand ( time ( 0 ) ) ; for ( int i = 0 ; i < n ; i ++ ) { int r = i + ( rand ( ) % ( 52 - i ) ) ; swap ( card [ i ] , card [ r ] ) ; } }
Ref: 
def shuffle ( card , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT r = i + ( random . randint ( 0 , 55 ) % ( 52 - i ) ) NEW_LINE tmp = card [ i ] NEW_LINE card [ i ] = card [ r ] NEW_LINE card [ r ] = tmp NEW_LINE DEDENT DEDENT
Hyp: 
def shuffle ( card , n ) : NEW_LINE INDENT srand ( time ( 0 ) ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT r = i + ( rand ( ) % ( 52 - i ) ) NEW_LINE card [ i ] , card [ r ] = card [ r ] , card [ i ] NEW_LINE DEDENT DEDENT

BLEU: 66.44
Edit Sim: 83


Src: 
int maxLen ( int arr [ ] , int n ) { unordered_map < int , int > presum ; int sum = 0 ; int max_len = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( arr [ i ] == 0 && max_len == 0 ) max_len = 1 ; if ( sum == 0 ) max_len = i + 1 ; if ( presum . find ( sum ) != presum . end ( ) ) { max_len = max ( max_len , i - presum [ sum ] ) ; } else { presum [ sum ] = i ; } } return max_len ; }
Ref: 
def maxLen ( arr ) : NEW_LINE INDENT hash_map = { } NEW_LINE max_len = 0 NEW_LINE curr_sum = 0 NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT curr_sum += arr [ i ] NEW_LINE if arr [ i ] is 0 and max_len is 0 : NEW_LINE INDENT max_len = 1 NEW_LINE DEDENT if curr_sum is 0 : NEW_LINE INDENT max_len = i + 1 NEW_LINE DEDENT if curr_sum in hash_map : NEW_LINE INDENT max_len = max ( max_len , i - hash_map [ curr_sum ] ) NEW_LINE DEDENT else : NEW_LINE INDENT hash_map [ curr_sum ] = i NEW_LINE DEDENT DEDENT return max_len NEW_LINE DEDENT
Hyp: 
def maxLen ( arr , n ) : NEW_LINE INDENT presum = dict ( ) NEW_LINE Sum = 0 NEW_LINE max_len = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT Sum += arr [ i ] NEW_LINE if ( arr [ i ] == 0 and max_len == 0 ) : NEW_LINE INDENT max_len = 1 NEW_LINE DEDENT if ( Sum == 0 ) : NEW_LINE INDENT max_len = i + 1 NEW_LINE DEDENT if ( Sum in presum ) : NEW_LINE INDENT max_len = max ( max_len , i - presum [ Sum ] ) NEW_LINE DEDENT else : NEW_LINE INDENT presum [ Sum ] = i NEW_LINE DEDENT DEDENT return max_len NEW_LINE DEDENT

BLEU: 58.78
Edit Sim: 104


Src: 
int maxLength ( char s [ ] , int n ) { int dp [ n ] [ n ] ; memset ( dp , 0 , sizeof ( dp ) ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) if ( s [ i ] == ' ( ' && s [ i + 1 ] == ' ) ' ) dp [ i ] [ i + 1 ] = 2 ; for ( int l = 2 ; l < n ; l ++ ) { for ( int i = 0 , j = l ; j < n ; i ++ , j ++ ) { if ( s [ i ] == ' ( ' && s [ j ] == ' ) ' ) dp [ i ] [ j ] = 2 + dp [ i + 1 ] [ j - 1 ] ; for ( int k = i ; k < j ; k ++ ) dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i ] [ k ] + dp [ k + 1 ] [ j ] ) ; } } return dp [ 0 ] [ n - 1 ] ; }
Ref: 
def maxLength ( s , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( s [ i ] == ' ( ' and s [ i + 1 ] == ' ) ' ) : NEW_LINE INDENT dp [ i ] [ i + 1 ] = 2 NEW_LINE DEDENT DEDENT for l in range ( 2 , n ) : NEW_LINE INDENT i = - 1 NEW_LINE for j in range ( l , n ) : NEW_LINE INDENT i += 1 NEW_LINE if ( s [ i ] == ' ( ' and s [ j ] == ' ) ' ) : NEW_LINE INDENT dp [ i ] [ j ] = 2 + dp [ i + 1 ] [ j - 1 ] NEW_LINE DEDENT for k in range ( i , j ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i ] [ k ] + dp [ k + 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ 0 ] [ n - 1 ] NEW_LINE DEDENT
Hyp: 
def maxLength ( s , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( s [ i ] == ' ( ' and s [ i + 1 ] == ' ) ' ) : NEW_LINE INDENT dp [ i ] [ i + 1 ] = 2 NEW_LINE DEDENT DEDENT for l in range ( 2 , n ) : NEW_LINE INDENT i = 0 NEW_LINE j = l NEW_LINE while ( j < n ) : NEW_LINE INDENT if ( s [ i ] == ' ( ' and s [ j ] == ' ) ' ) : NEW_LINE INDENT dp [ i ] [ j ] = 2 + dp [ i + 1 ] [ j - 1 ] NEW_LINE DEDENT for k in range ( i , j ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i ] [ k ] + dp [ k + 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ 0 ] [ n - 1 ] NEW_LINE DEDENT

BLEU: 92.53
Edit Sim: 38


Src: 
int summingSeries ( long n ) { return pow ( n , 2 ) ; }
Ref: 
def summingSeries ( n ) : NEW_LINE INDENT return math . pow ( n , 2 ) NEW_LINE DEDENT
Hyp: 
def summingSeries ( n ) : NEW_LINE INDENT return int ( math . pow ( n , 2 ) ) NEW_LINE DEDENT

BLEU: 74.31
Edit Sim: 8


Src: 
bool isSubsetSum ( int arr [ ] , int n , int sum ) { bool subset [ 2 ] [ sum + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= sum ; j ++ ) { if ( j == 0 ) subset [ i % 2 ] [ j ] = true ; else if ( i == 0 ) subset [ i % 2 ] [ j ] = false ; else if ( arr [ i - 1 ] <= j ) subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j - arr [ i - 1 ] ] || subset [ ( i + 1 ) % 2 ] [ j ] ; else subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j ] ; } } return subset [ n % 2 ] [ sum ] ; }
Ref: 
def isSubsetSum ( arr , n , sum ) : NEW_LINE INDENT subset = [ [ False for j in range ( sum + 1 ) ] for i in range ( 3 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( sum + 1 ) : NEW_LINE INDENT if ( j == 0 ) : NEW_LINE INDENT subset [ i % 2 ] [ j ] = True NEW_LINE DEDENT elif ( i == 0 ) : NEW_LINE INDENT subset [ i % 2 ] [ j ] = False NEW_LINE DEDENT elif ( arr [ i - 1 ] <= j ) : NEW_LINE INDENT subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j - arr [ i - 1 ] ] or subset [ ( i + 1 ) % 2 ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return subset [ n % 2 ] [ sum ] NEW_LINE DEDENT
Hyp: 
def isSubsetSum ( arr , n , Sum ) : NEW_LINE INDENT subset = [ [ False for i in range ( Sum + 1 ) ] for j in range ( 2 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( Sum + 1 ) : NEW_LINE INDENT if j == 0 : NEW_LINE INDENT subset [ i % 2 ] [ j ] = True NEW_LINE DEDENT elif i == 0 : NEW_LINE INDENT subset [ i % 2 ] [ j ] = False NEW_LINE DEDENT elif arr [ i - 1 ] <= j : NEW_LINE INDENT subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j - arr [ i - 1 ] ] or subset [ ( i + 1 ) % 2 ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return subset [ n % 2 ] [ Sum ] NEW_LINE DEDENT

BLEU: 85.62
Edit Sim: 19


Src: 
int findExtra ( int arr1 [ ] , int arr2 [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) if ( arr1 [ i ] != arr2 [ i ] ) return i ; return n ; }
Ref: 
def findExtra ( arr1 , arr2 , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr1 [ i ] != arr2 [ i ] ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return n NEW_LINE DEDENT
Hyp: 
def findExtra ( arr1 , arr2 , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( arr1 [ i ] != arr2 [ i ] ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return n NEW_LINE DEDENT

BLEU: 92.5
Edit Sim: 4


Src: 
int numberOfPermWithKInversion ( int N , int K ) { if ( N == 0 ) return 0 ; if ( K == 0 ) return 1 ; if ( memo [ N ] [ K ] != 0 ) return memo [ N ] [ K ] ; int sum = 0 ; for ( int i = 0 ; i <= K ; i ++ ) { if ( i <= N - 1 ) sum += numberOfPermWithKInversion ( N - 1 , K - i ) ; } memo [ N ] [ K ] = sum ; return sum ; }
Ref: 
def numberOfPermWithKInversion ( N , K ) : NEW_LINE INDENT if ( N == 0 ) : return 0 NEW_LINE if ( K == 0 ) : return 1 NEW_LINE if ( memo [ N ] [ K ] != 0 ) : NEW_LINE INDENT return memo [ N ] [ K ] NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( K + 1 ) : NEW_LINE INDENT if ( i <= N - 1 ) : NEW_LINE INDENT sum += numberOfPermWithKInversion ( N - 1 , K - i ) NEW_LINE DEDENT DEDENT memo [ N ] [ K ] = sum NEW_LINE return sum NEW_LINE DEDENT
Hyp: 
def numberOfPermWithKInversion ( N , K ) : NEW_LINE INDENT if ( N == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( K == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT memo [ N ] [ K ] = 0 NEW_LINE return memo [ N ] [ K ] NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( K + 1 ) : NEW_LINE INDENT if ( i <= N - 1 ) : NEW_LINE INDENT sum += numberOfPermWithKInversion ( N - 1 , K - i ) NEW_LINE DEDENT DEDENT memo [ N ] [ K ] = sum NEW_LINE return sum NEW_LINE DEDENT

BLEU: 87.69
Edit Sim: 57


Src: 
int removeConsecutiveSame ( vector < string > v ) { stack < string > st ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) { if ( st . empty ( ) ) st . push ( v [ i ] ) ; else { string str = st . top ( ) ; if ( str . compare ( v [ i ] ) == 0 ) st . pop ( ) ; else st . push ( v [ i ] ) ; } } return st . size ( ) ; }
Ref: 
def removeConsecutiveSame ( v ) : NEW_LINE INDENT st = [ ] NEW_LINE for i in range ( len ( v ) ) : NEW_LINE INDENT if ( len ( st ) == 0 ) : NEW_LINE INDENT st . append ( v [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT Str = st [ - 1 ] NEW_LINE if ( Str == v [ i ] ) : NEW_LINE INDENT st . pop ( ) NEW_LINE DEDENT else : NEW_LINE INDENT st . append ( v [ i ] ) NEW_LINE DEDENT DEDENT DEDENT return len ( st ) NEW_LINE DEDENT
Hyp: 
def removeConsecutiveSame ( v ) : NEW_LINE INDENT st = [ ] NEW_LINE for i in range ( len ( v ) ) : NEW_LINE INDENT if ( len ( st ) == 0 ) : NEW_LINE INDENT st . append ( v [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT st . pop ( ) NEW_LINE DEDENT else : NEW_LINE INDENT st . append ( v [ i ] ) NEW_LINE DEDENT DEDENT return len ( st ) NEW_LINE DEDENT

BLEU: 77.41
Edit Sim: 73


Src: 
void find ( vector < string > list1 , vector < string > list2 ) { vector < string > res ; int max_possible_sum = list1 . size ( ) + list2 . size ( ) - 2 ; for ( int sum = 0 ; sum <= max_possible_sum ; sum ++ ) { for ( int i = 0 ; i <= sum ; i ++ ) if ( i < list1 . size ( ) && ( sum - i ) < list2 . size ( ) && list1 [ i ] == list2 [ sum - i ] ) res . push_back ( list1 [ i ] ) ; if ( res . size ( ) > 0 ) break ; } for ( int i = 0 ; i < res . size ( ) ; i ++ ) cout << res [ i ] << " ▁ " ; }
Ref: 
def find ( list1 , list2 ) : NEW_LINE INDENT res = [ ] NEW_LINE max_possible_sum = len ( list1 ) + len ( list2 ) - 2 NEW_LINE for sum in range ( max_possible_sum + 1 ) : NEW_LINE INDENT for i in range ( sum + 1 ) : NEW_LINE INDENT if ( i < len ( list1 ) and ( sum - i ) < len ( list2 ) and list1 [ i ] == list2 [ sum - i ] ) : NEW_LINE INDENT res . append ( list1 [ i ] ) NEW_LINE DEDENT DEDENT if ( len ( res ) > 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT for i in range ( len ( res ) ) : NEW_LINE INDENT print ( res [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
Hyp: 
def find ( list1 , list2 ) : NEW_LINE INDENT res = [ ] NEW_LINE max_possible_sum = len ( list1 ) + len ( list2 ) - 2 NEW_LINE for sum in range ( max_possible_sum + 1 ) : NEW_LINE INDENT for i in range ( sum + 1 ) : NEW_LINE INDENT if ( i < len ( list1 ) and ( sum - i ) < len ( list2 ) and list1 [ i ] == list2 [ sum - i ] ) : NEW_LINE INDENT res . append ( list1 [ i ] ) NEW_LINE DEDENT DEDENT if ( len ( res ) > 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT for i in range ( 0 , len ( res ) ) : NEW_LINE INDENT print ( res [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT

BLEU: 94.68
Edit Sim: 6


Src: 
int firstNonRepeating ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < n ; j ++ ) if ( i != j && arr [ i ] == arr [ j ] ) break ; if ( j == n ) return arr [ i ] ; } return - 1 ; }
Ref: 
def firstNonRepeating ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT j = 0 NEW_LINE while ( j < n ) : NEW_LINE INDENT if ( i != j and arr [ i ] == arr [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if ( j == n ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
Hyp: 
def firstNonRepeating ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( i != j and arr [ i ] == arr [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( j == n ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT

BLEU: 81.78
Edit Sim: 36


Src: 
int search ( int arr [ ] , int n , int x ) { for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == x ) return i ; } return - 1 ; }
Ref: 
def search ( arr , x ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT if ( x == arr [ j ] ) : NEW_LINE INDENT return j NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
Hyp: 
def search ( arr , n , x ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == x ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT

BLEU: 52.81
Edit Sim: 46


Src: 
void middlesum ( int mat [ ] [ MAX ] , int n ) { int row_sum = 0 , col_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) row_sum += mat [ n / 2 ] [ i ] ; cout << " Sum ▁ of ▁ middle ▁ row ▁ = ▁ " << row_sum << endl ; for ( int i = 0 ; i < n ; i ++ ) col_sum += mat [ i ] [ n / 2 ] ; cout << " Sum ▁ of ▁ middle ▁ column ▁ = ▁ " << col_sum ; }
Ref: 
def middlesum ( mat , n ) : NEW_LINE INDENT row_sum = 0 NEW_LINE col_sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT row_sum += mat [ n // 2 ] [ i ] NEW_LINE DEDENT print ( " Sum ▁ of ▁ middle ▁ row ▁ = ▁ " , row_sum ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT col_sum += mat [ i ] [ n // 2 ] NEW_LINE DEDENT print ( " Sum ▁ of ▁ middle ▁ column ▁ = ▁ " , col_sum ) NEW_LINE DEDENT
Hyp: 
def middlesum ( mat , n ) : NEW_LINE INDENT row_sum = 0 NEW_LINE col_sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT row_sum += mat [ n // 2 ] [ i ] NEW_LINE DEDENT print ( " Sum ▁ of ▁ middle ▁ row ▁ = ▁ " , row_sum ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT col_sum += mat [ i ] [ n // 2 ] NEW_LINE DEDENT print ( " Sum ▁ of ▁ middle ▁ column ▁ = ▁ " , col_sum ) NEW_LINE DEDENT

BLEU: 93.25
Edit Sim: 8


Src: 
long long moduloMultiplication ( long long a , long long b , long long mod ) { long long res = 0 ; a %= mod ; while ( b ) { if ( b & 1 ) res = ( res + a ) % mod ; a = ( 2 * a ) % mod ; b >>= 1 ; } return res ; }
Ref: 
def moduloMultiplication ( a , b , mod ) : NEW_LINE INDENT res = 0 ; NEW_LINE a = a % mod ; NEW_LINE while ( b ) : NEW_LINE INDENT if ( b & 1 ) : NEW_LINE INDENT res = ( res + a ) % mod ; NEW_LINE DEDENT a = ( 2 * a ) % mod ; NEW_LINE b >>= 1 ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT
Hyp: 
def moduloMultiplication ( a , b , mod ) : NEW_LINE INDENT res = 0 NEW_LINE a %= mod NEW_LINE while ( b ) : NEW_LINE INDENT if ( b & 1 ) : NEW_LINE INDENT res = ( res + a ) % mod NEW_LINE DEDENT a = ( 2 * a ) % mod NEW_LINE b >>= 1 NEW_LINE DEDENT return res NEW_LINE DEDENT

BLEU: 74.05
Edit Sim: 17


Src: 
void pythagoreanTriplets ( int limit ) { int a , b , c = 0 ; int m = 2 ; while ( c < limit ) { for ( int n = 1 ; n < m ; ++ n ) { a = m * m - n * n ; b = 2 * m * n ; c = m * m + n * n ; if ( c > limit ) break ; printf ( " % d ▁ % d ▁ % d \n " , a , b , c ) ; } m ++ ; } }
Ref: 
def pythagoreanTriplets ( limits ) : NEW_LINE INDENT c , m = 0 , 2 NEW_LINE while c < limits : NEW_LINE INDENT for n in range ( 1 , m ) : NEW_LINE INDENT a = m * m - n * n NEW_LINE b = 2 * m * n NEW_LINE c = m * m + n * n NEW_LINE if c > limits : NEW_LINE INDENT break NEW_LINE DEDENT print ( a , b , c ) NEW_LINE DEDENT m = m + 1 NEW_LINE DEDENT DEDENT
Hyp: 
def pythagoreanTriplets ( limit ) : NEW_LINE INDENT c = 0 NEW_LINE m = 2 NEW_LINE while ( c < limit ) : NEW_LINE INDENT for n in range ( 1 , m ) : NEW_LINE INDENT a = m * m - n * n NEW_LINE b = 2 * m * n NEW_LINE c = m * m + n * n NEW_LINE if ( c > limit ) : NEW_LINE INDENT break NEW_LINE DEDENT print ( a , b , c ) NEW_LINE DEDENT m += 1 NEW_LINE DEDENT DEDENT

BLEU: 76.02
Edit Sim: 26


Src: 
long long int findSum ( int n ) { return n * ( n + 1 ) * ( n + 2 ) * ( 3 * n + 1 ) / 24 ; }
Ref: 
def findSum ( n ) : NEW_LINE INDENT return n * ( n + 1 ) * ( n + 2 ) * ( 3 * n + 1 ) / 24 NEW_LINE DEDENT
Hyp: 
def findSum ( n ) : NEW_LINE INDENT return ( n * ( n + 1 ) * ( n + 2 ) * ( 3 * n + 1 ) / 24 ) NEW_LINE DEDENT

BLEU: 86.24
Edit Sim: 4


Src: 
int fib ( int n ) { if ( n == 0 ) return 0 ; if ( n == 1 || n == 2 ) return ( f [ n ] = 1 ) ; if ( f [ n ] ) return f [ n ] ; int k = ( n & 1 ) ? ( n + 1 ) / 2 : n / 2 ; f [ n ] = ( n & 1 ) ? ( fib ( k ) * fib ( k ) + fib ( k - 1 ) * fib ( k - 1 ) ) : ( 2 * fib ( k - 1 ) + fib ( k ) ) * fib ( k ) ; return f [ n ] ; }
Ref: 
def fib ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n == 1 or n == 2 ) : NEW_LINE INDENT f [ n ] = 1 NEW_LINE return ( f [ n ] ) NEW_LINE DEDENT if ( f [ n ] ) : NEW_LINE INDENT return f [ n ] NEW_LINE DEDENT if ( n & 1 ) : NEW_LINE INDENT k = ( n + 1 ) // 2 NEW_LINE DEDENT else : NEW_LINE INDENT k = n // 2 NEW_LINE DEDENT if ( ( n & 1 ) ) : NEW_LINE INDENT f [ n ] = ( fib ( k ) * fib ( k ) + fib ( k - 1 ) * fib ( k - 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT f [ n ] = ( 2 * fib ( k - 1 ) + fib ( k ) ) * fib ( k ) NEW_LINE DEDENT return f [ n ] NEW_LINE DEDENT
Hyp: 
def fib ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n == 1 or n == 2 ) : NEW_LINE INDENT return ( f [ n ] = 1 ) NEW_LINE DEDENT if ( f [ n ] ) : NEW_LINE INDENT return f [ n ] NEW_LINE DEDENT k = ( n & 1 ) ? ( n + 1 ) // 2 : n // 2 NEW_LINE f [ n ] = ( n & 1 ) ? ( n + 1 ) // 2 : n // 2 NEW_LINE f [ n ] = ( fib ( k ) * fib ( k ) + fib ( k - 1 ) * fib ( k - 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT f [ n ] = ( 2 * fib ( k - 1 ) + fib ( k ) ) * fib ( k ) ) NEW_LINE return f [ n ] NEW_LINE DEDENT DEDENT

BLEU: 81.38
Edit Sim: 128


Src: 
int largestPower ( int n , int p ) { int x = 0 ; while ( n ) { n /= p ; x += n ; } return x ; }
Ref: 
def largestPower ( n , p ) : NEW_LINE INDENT x = 0 NEW_LINE while n : NEW_LINE INDENT n /= p NEW_LINE x += n NEW_LINE DEDENT return x NEW_LINE DEDENT
Hyp: 
def largestPower ( n , p ) : NEW_LINE INDENT x = 0 NEW_LINE while ( n ) : NEW_LINE INDENT n = n // p NEW_LINE x += n NEW_LINE DEDENT return x NEW_LINE DEDENT

BLEU: 74.67
Edit Sim: 9


Src: 
bool isIdentity ( int mat [ ] [ MAX ] , int N ) { for ( int row = 0 ; row < N ; row ++ ) { for ( int col = 0 ; col < N ; col ++ ) { if ( row == col && mat [ row ] [ col ] != 1 ) return false ; else if ( row != col && mat [ row ] [ col ] != 0 ) return false ; } } return true ; }
Ref: 
def isIdentity ( mat , N ) : NEW_LINE INDENT for row in range ( N ) : NEW_LINE INDENT for col in range ( N ) : NEW_LINE INDENT if ( row == col and mat [ row ] [ col ] != 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT elif ( row != col and mat [ row ] [ col ] != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT
Hyp: 
def isIdentity ( mat , N ) : NEW_LINE INDENT for row in range ( N ) : NEW_LINE INDENT for col in range ( N ) : NEW_LINE INDENT if ( row == col and mat [ row ] [ col ] != 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT elif ( row != col and mat [ row ] [ col ] != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int minCells ( int mat [ SIZE ] [ SIZE ] , int m , int n ) { int dp [ m ] [ n ] ; for ( int i = 0 ; i < m ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) dp [ i ] [ j ] = INT_MAX ; dp [ 0 ] [ 0 ] = 1 ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( dp [ i ] [ j ] != INT_MAX && ( j + mat [ i ] [ j ] ) < n && ( dp [ i ] [ j ] + 1 ) < dp [ i ] [ j + mat [ i ] [ j ] ] ) dp [ i ] [ j + mat [ i ] [ j ] ] = dp [ i ] [ j ] + 1 ; if ( dp [ i ] [ j ] != INT_MAX && ( i + mat [ i ] [ j ] ) < m && ( dp [ i ] [ j ] + 1 ) < dp [ i + mat [ i ] [ j ] ] [ j ] ) dp [ i + mat [ i ] [ j ] ] [ j ] = dp [ i ] [ j ] + 1 ; } } if ( dp [ m - 1 ] [ n - 1 ] != INT_MAX ) return dp [ m - 1 ] [ n - 1 ] ; return - 1 ; }
Ref: 
def minCells ( mat , m , n ) : NEW_LINE INDENT dp = [ [ MAX for i in range ( n ) ] for i in range ( m ) ] NEW_LINE dp [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( dp [ i ] [ j ] != MAX and ( j + mat [ i ] [ j ] ) < n and ( dp [ i ] [ j ] + 1 ) < dp [ i ] [ j + mat [ i ] [ j ] ] ) : NEW_LINE INDENT dp [ i ] [ j + mat [ i ] [ j ] ] = dp [ i ] [ j ] + 1 NEW_LINE DEDENT if ( dp [ i ] [ j ] != MAX and ( i + mat [ i ] [ j ] ) < m and ( dp [ i ] [ j ] + 1 ) < dp [ i + mat [ i ] [ j ] ] [ j ] ) : NEW_LINE INDENT dp [ i + mat [ i ] [ j ] ] [ j ] = dp [ i ] [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT if ( dp [ m - 1 ] [ n - 1 ] != MAX ) : NEW_LINE INDENT return dp [ m - 1 ] [ n - 1 ] NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
Hyp: 
def minCells ( mat , m , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT dp [ i ] [ j ] = sys . maxsize NEW_LINE DEDENT DEDENT dp [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( dp [ i ] [ j ] != INT_MAX and ( j + mat [ i ] [ j ] ) < n and ( dp [ i ] [ j ] + 1 ) < dp [ i ] [ j + mat [ i ] [ j ] ] ) : NEW_LINE INDENT dp [ i ] [ j + mat [ i ] [ j ] ] = dp [ i ] [ j ] + 1 NEW_LINE DEDENT if ( dp [ i ] [ j ] != INT_MAX and ( i + mat [ i ] [ j ] ) < m and ( dp [ i ] [ j ] + 1 ) < dp [ i + mat [ i ] [ j ] ] [ j ] ) : NEW_LINE INDENT dp [ i + mat [ i ] [ j ] ] [ j ] = dp [ i ] [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT if ( dp [ m - 1 ] [ n - 1 ] != INT_MAX ) : NEW_LINE INDENT return dp [ m - 1 ] [ n - 1 ] NEW_LINE DEDENT return - 1 NEW_LINE DEDENT

BLEU: 84.57
Edit Sim: 146


Src: 
void arrangeString ( string str , int x , int y ) { int count_0 = 0 ; int count_1 = 0 ; int len = str . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { if ( str [ i ] == '0' ) count_0 ++ ; else count_1 ++ ; } while ( count_0 > 0 || count_1 > 0 ) { for ( int j = 0 ; j < x && count_0 > 0 ; j ++ ) { if ( count_0 > 0 ) { cout << "0" ; count_0 -- ; } } for ( int j = 0 ; j < y && count_1 > 0 ; j ++ ) { if ( count_1 > 0 ) { cout << "1" ; count_1 -- ; } } } }
Ref: 
def arrangeString ( str1 , x , y ) : NEW_LINE INDENT count_0 = 0 NEW_LINE count_1 = 0 NEW_LINE n = len ( str1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if str1 [ i ] == '0' : NEW_LINE INDENT count_0 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_1 += 1 NEW_LINE DEDENT DEDENT while count_0 > 0 or count_1 > 0 : NEW_LINE INDENT for i in range ( 0 , x ) : NEW_LINE INDENT if count_0 > 0 : NEW_LINE INDENT print ( "0" , end = " " ) NEW_LINE count_0 -= 1 NEW_LINE DEDENT DEDENT for j in range ( 0 , y ) : NEW_LINE INDENT if count_1 > 0 : NEW_LINE INDENT print ( "1" , end = " " ) NEW_LINE count_1 -= 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT
Hyp: 
def arrangeString ( str , x , y ) : NEW_LINE INDENT count_0 = 0 NEW_LINE count_1 = 0 NEW_LINE len = len ( str ) NEW_LINE for i in range ( len ) : NEW_LINE INDENT if ( str [ i ] == '0' ) : NEW_LINE INDENT count_0 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_1 += 1 NEW_LINE DEDENT DEDENT while ( count_0 > 0 or count_1 > 0 ) : NEW_LINE INDENT for j in range ( x and count_0 > 0 ) : NEW_LINE INDENT if ( count_0 > 0 ) : NEW_LINE INDENT print ( "0" , end = " " ) NEW_LINE count_0 -= 1 NEW_LINE DEDENT DEDENT for j in range ( y and count_1 > 0 ) : NEW_LINE INDENT if ( count_1 > 0 ) : NEW_LINE INDENT print ( "1" , end = " " ) NEW_LINE count_1 -= 1 NEW_LINE DEDENT DEDENT DEDENT

BLEU: 69.65
Edit Sim: 60


Src: 
int getLevenstein ( string const & input ) { string revInput ( input . rbegin ( ) , input . rend ( ) ) ; int n = input . size ( ) ; vector < vector < int > > dp ( n + 1 , vector < int > ( n + 1 , - 1 ) ) ; for ( int i = 0 ; i <= n ; ++ i ) { dp [ 0 ] [ i ] = i ; dp [ i ] [ 0 ] = i ; } for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j <= n ; ++ j ) { if ( input [ i - 1 ] == revInput [ j - 1 ] ) dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = 1 + min ( { dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] } ) ; } } int res = numeric_limits < int > :: max ( ) ; for ( int i = n , j = 0 ; i >= 0 ; -- i , ++ j ) { res = min ( res , dp [ i ] [ j ] ) ; if ( i < n ) res = min ( res , dp [ i + 1 ] [ j ] ) ; if ( i > 0 ) res = min ( res , dp [ i - 1 ] [ j ] ) ; } return res ; }
Ref: 
def getLevenstein ( inpt ) : NEW_LINE INDENT revInput = inpt [ : : - 1 ] NEW_LINE n = len ( inpt ) NEW_LINE dp = [ [ - 1 for _ in range ( n + 1 ) ] for __ in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT dp [ 0 ] [ i ] = i NEW_LINE dp [ i ] [ 0 ] = i NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if inpt [ i - 1 ] == revInput [ j - 1 ] : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = 1 + min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT res = INT_MAX NEW_LINE i , j = n , 0 NEW_LINE while i >= 0 : NEW_LINE INDENT res = min ( res , dp [ i ] [ j ] ) NEW_LINE if i < n : NEW_LINE INDENT res = min ( res , dp [ i + 1 ] [ j ] ) NEW_LINE DEDENT if i > 0 : NEW_LINE INDENT res = min ( res , dp [ i - 1 ] [ j ] ) NEW_LINE DEDENT i -= 1 NEW_LINE j += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT
Hyp: 
def getLevenstein ( inp ) : NEW_LINE INDENT revInput = inp . read ( ) NEW_LINE n = len ( inp ) NEW_LINE dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT dp [ 0 ] [ i ] = i NEW_LINE dp [ i ] [ 0 ] = i NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( inp [ i - 1 ] == revInput [ j - 1 ] ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = 1 + min ( { dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] } ) NEW_LINE DEDENT DEDENT DEDENT res = float ( ' inf ' ) NEW_LINE for i in range ( n , - 1 , - 1 ) : NEW_LINE INDENT res = min ( res , dp [ i ] [ j ] ) NEW_LINE if ( i < n ) : NEW_LINE INDENT res = min ( res , dp [ i + 1 ] [ j ] ) NEW_LINE DEDENT if ( i > 0 ) : NEW_LINE INDENT res = min ( res , dp [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT

BLEU: 79.75
Edit Sim: 110


Src: 
int carAssembly ( int a [ ] [ NUM_STATION ] , int t [ ] [ NUM_STATION ] , int * e , int * x ) { int T1 [ NUM_STATION ] , T2 [ NUM_STATION ] , i ; T1 [ 0 ] = e [ 0 ] + a [ 0 ] [ 0 ] ; T2 [ 0 ] = e [ 1 ] + a [ 1 ] [ 0 ] ; for ( i = 1 ; i < NUM_STATION ; ++ i ) { T1 [ i ] = min ( T1 [ i - 1 ] + a [ 0 ] [ i ] , T2 [ i - 1 ] + t [ 1 ] [ i ] + a [ 0 ] [ i ] ) ; T2 [ i ] = min ( T2 [ i - 1 ] + a [ 1 ] [ i ] , T1 [ i - 1 ] + t [ 0 ] [ i ] + a [ 1 ] [ i ] ) ; } return min ( T1 [ NUM_STATION - 1 ] + x [ 0 ] , T2 [ NUM_STATION - 1 ] + x [ 1 ] ) ; }
Ref: 
def carAssembly ( a , t , e , x ) : NEW_LINE INDENT NUM_STATION = len ( a [ 0 ] ) NEW_LINE T1 = [ 0 for i in range ( NUM_STATION ) ] NEW_LINE T2 = [ 0 for i in range ( NUM_STATION ) ] NEW_LINE T1 [ 0 ] = e [ 0 ] + a [ 0 ] [ 0 ] NEW_LINE T2 [ 0 ] = e [ 1 ] + a [ 1 ] [ 0 ] NEW_LINE for i in range ( 1 , NUM_STATION ) : NEW_LINE INDENT T1 [ i ] = min ( T1 [ i - 1 ] + a [ 0 ] [ i ] , T2 [ i - 1 ] + t [ 1 ] [ i ] + a [ 0 ] [ i ] ) NEW_LINE T2 [ i ] = min ( T2 [ i - 1 ] + a [ 1 ] [ i ] , T1 [ i - 1 ] + t [ 0 ] [ i ] + a [ 1 ] [ i ] ) NEW_LINE DEDENT return min ( T1 [ NUM_STATION - 1 ] + x [ 0 ] , T2 [ NUM_STATION - 1 ] + x [ 1 ] ) NEW_LINE DEDENT
Hyp: 
def carAssembly ( a , t , e , x ) : NEW_LINE INDENT T1 = [ 0 for i in range ( NUM_STATION ) ] NEW_LINE T2 = [ 0 for i in range ( NUM_STATION ) ] NEW_LINE for i in range ( 1 , NUM_STATION ) : NEW_LINE INDENT T1 [ 0 ] = e [ 0 ] + a [ 0 ] [ 0 ] NEW_LINE T2 [ 0 ] = e [ 1 ] + a [ 1 ] [ 0 ] NEW_LINE for i in range ( 1 , NUM_STATION ) : NEW_LINE INDENT T1 [ i ] = min ( T1 [ i - 1 ] + a [ 0 ] [ i ] , T2 [ i - 1 ] + t [ 1 ] [ i ] + a [ 0 ] [ i ] ) NEW_LINE T2 [ i ] = min ( T2 [ i - 1 ] + a [ 1 ] [ i ] , T1 [ i - 1 ] + t [ 0 ] [ i ] + a [ 1 ] [ i ] ) NEW_LINE DEDENT return min ( T1 [ NUM_STATION - 1 ] + x [ 0 ] , T2 [ NUM_STATION - 1 ] + x [ 1 ] ) NEW_LINE DEDENT

BLEU: 93.66
Edit Sim: 55


Src: 
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
Ref: 
def gcd ( a , b ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT
Hyp: 
def gcd ( a , b ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
void findTriplets ( int arr [ ] , int n ) { bool found = false ; sort ( arr , arr + n ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int l = i + 1 ; int r = n - 1 ; int x = arr [ i ] ; while ( l < r ) { if ( x + arr [ l ] + arr [ r ] == 0 ) { printf ( " % d ▁ % d ▁ % d \n " , x , arr [ l ] , arr [ r ] ) ; l ++ ; r -- ; found = true ; } else if ( x + arr [ l ] + arr [ r ] < 0 ) l ++ ; else r -- ; } } if ( found == false ) cout << " ▁ No ▁ Triplet ▁ Found " << endl ; }
Ref: 
def findTriplets ( arr , n ) : NEW_LINE INDENT found = False NEW_LINE arr . sort ( ) NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT l = i + 1 NEW_LINE r = n - 1 NEW_LINE x = arr [ i ] NEW_LINE while ( l < r ) : NEW_LINE INDENT if ( x + arr [ l ] + arr [ r ] == 0 ) : NEW_LINE INDENT print ( x , arr [ l ] , arr [ r ] ) NEW_LINE l += 1 NEW_LINE r -= 1 NEW_LINE found = True NEW_LINE DEDENT elif ( x + arr [ l ] + arr [ r ] < 0 ) : NEW_LINE INDENT l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT DEDENT DEDENT if ( found == False ) : NEW_LINE INDENT print ( " ▁ No ▁ Triplet ▁ Found " ) NEW_LINE DEDENT DEDENT
Hyp: 
def findTriplets ( arr , n ) : NEW_LINE INDENT found = False NEW_LINE arr . sort ( ) NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT l = i + 1 NEW_LINE r = n - 1 NEW_LINE x = arr [ i ] NEW_LINE while ( l < r ) : NEW_LINE INDENT if ( x + arr [ l ] + arr [ r ] == 0 ) : NEW_LINE INDENT print ( " % d ▁ " , x , arr [ l ] , arr [ r ] ) NEW_LINE l += 1 NEW_LINE r -= 1 NEW_LINE found = True NEW_LINE DEDENT elif ( x + arr [ l ] + arr [ r ] < 0 ) : NEW_LINE INDENT l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT DEDENT DEDENT if ( found == False ) : NEW_LINE INDENT print ( " ▁ No ▁ Triplet ▁ Found " ) NEW_LINE DEDENT DEDENT

BLEU: 95.65
Edit Sim: 12


Src: 
int getOddOccurrence ( int ar [ ] , int ar_size ) { int res = 0 ; for ( int i = 0 ; i < ar_size ; i ++ ) res = res ^ ar [ i ] ; return res ; }
Ref: 
def getOddOccurrence ( arr ) : NEW_LINE INDENT res = 0 NEW_LINE for element in arr : NEW_LINE INDENT res = res ^ element NEW_LINE DEDENT return res NEW_LINE DEDENT
Hyp: 
def getOddOccurrence ( ar , ar_size ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( ar_size ) : NEW_LINE INDENT res = res ^ ar [ i ] NEW_LINE DEDENT return res NEW_LINE DEDENT

BLEU: 52.48
Edit Sim: 35


Src: 
int maxTasks ( int high [ ] , int low [ ] , int n ) { if ( n <= 0 ) return 0 ; return max ( high [ n - 1 ] + maxTasks ( high , low , ( n - 2 ) ) , low [ n - 1 ] + maxTasks ( high , low , ( n - 1 ) ) ) ; }
Ref: 
def maxTasks ( high , low , n ) : NEW_LINE INDENT if ( n <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return max ( high [ n - 1 ] + maxTasks ( high , low , ( n - 2 ) ) , low [ n - 1 ] + maxTasks ( high , low , ( n - 1 ) ) ) NEW_LINE DEDENT
Hyp: 
def maxTasks ( high , low , n ) : NEW_LINE INDENT if ( n <= 0 ) : return 0 NEW_LINE return max ( high [ n - 1 ] + maxTasks ( high , low , ( n - 2 ) ) , low [ n - 1 ] + maxTasks ( high , low , ( n - 1 ) ) ) NEW_LINE DEDENT

BLEU: 91.19
Edit Sim: 23


Src: 
void printOtherSides ( int n ) { if ( n & 1 ) { if ( n == 1 ) cout << - 1 << endl ; else { int b = ( n * n - 1 ) / 2 ; int c = ( n * n + 1 ) / 2 ; cout << " b ▁ = ▁ " << b << " , ▁ c ▁ = ▁ " << c << endl ; } } else { if ( n == 2 ) cout << - 1 << endl ; else { int b = n * n / 4 - 1 ; int c = n * n / 4 + 1 ; cout << " b ▁ = ▁ " << b << " , ▁ c ▁ = ▁ " << c << endl ; } } }
Ref: 
def printOtherSides ( n ) : NEW_LINE INDENT if ( n & 1 ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT b = ( n * n - 1 ) // 2 NEW_LINE c = ( n * n + 1 ) // 2 NEW_LINE print ( " b ▁ = " , b , " , ▁ c ▁ = " , c ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( n == 2 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT b = n * n // 4 - 1 NEW_LINE c = n * n // 4 + 1 NEW_LINE print ( " b ▁ = " , b " , ▁ c ▁ = " , c ) NEW_LINE DEDENT DEDENT DEDENT
Hyp: 
def printOtherSides ( n ) : NEW_LINE INDENT if ( n & 1 ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT b = ( n * n - 1 ) // 2 NEW_LINE c = ( n * n + 1 ) // 2 NEW_LINE print ( " b ▁ = ▁ " , b , " , ▁ c ▁ = ▁ " , c ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( n == 2 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT b = ( n * n // 4 - 1 ) NEW_LINE c = n * n // 4 + 1 NEW_LINE print ( " b ▁ = ▁ " , b , " , ▁ c ▁ = ▁ " , c ) NEW_LINE DEDENT DEDENT DEDENT

BLEU: 88.71
Edit Sim: 14


Src: 
void printUnsorted ( int arr [ ] , int n ) { int s = 0 , e = n - 1 , i , max , min ; for ( s = 0 ; s < n - 1 ; s ++ ) { if ( arr [ s ] > arr [ s + 1 ] ) break ; } if ( s == n - 1 ) { cout << " The ▁ complete ▁ array ▁ is ▁ sorted " ; return ; } for ( e = n - 1 ; e > 0 ; e -- ) { if ( arr [ e ] < arr [ e - 1 ] ) break ; } max = arr [ s ] ; min = arr [ s ] ; for ( i = s + 1 ; i <= e ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; if ( arr [ i ] < min ) min = arr [ i ] ; } for ( i = 0 ; i < s ; i ++ ) { if ( arr [ i ] > min ) { s = i ; break ; } } for ( i = n - 1 ; i >= e + 1 ; i -- ) { if ( arr [ i ] < max ) { e = i ; break ; } } cout << " The ▁ unsorted ▁ subarray ▁ which " << " ▁ makes ▁ the ▁ given ▁ array " << endl << " sorted ▁ lies ▁ between ▁ the ▁ indees ▁ " << s << " ▁ and ▁ " << e ; return ; }
Ref: 
def printUnsorted ( arr , n ) : NEW_LINE INDENT e = n - 1 NEW_LINE for s in range ( 0 , n - 1 ) : NEW_LINE INDENT if arr [ s ] > arr [ s + 1 ] : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if s == n - 1 : NEW_LINE INDENT print ( " The ▁ complete ▁ array ▁ is ▁ sorted " ) NEW_LINE exit ( ) NEW_LINE DEDENT e = n - 1 NEW_LINE while e > 0 : NEW_LINE INDENT if arr [ e ] < arr [ e - 1 ] : NEW_LINE INDENT break NEW_LINE DEDENT e -= 1 NEW_LINE DEDENT max = arr [ s ] NEW_LINE min = arr [ s ] NEW_LINE for i in range ( s + 1 , e + 1 ) : NEW_LINE INDENT if arr [ i ] > max : NEW_LINE INDENT max = arr [ i ] NEW_LINE DEDENT if arr [ i ] < min : NEW_LINE INDENT min = arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( s ) : NEW_LINE INDENT if arr [ i ] > min : NEW_LINE INDENT s = i NEW_LINE break NEW_LINE DEDENT DEDENT i = n - 1 NEW_LINE while i >= e + 1 : NEW_LINE INDENT if arr [ i ] < max : NEW_LINE INDENT e = i NEW_LINE break NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT print ( " The ▁ unsorted ▁ subarray ▁ which ▁ makes ▁ the ▁ given ▁ array " ) NEW_LINE print ( " sorted ▁ lies ▁ between ▁ the ▁ indexes ▁ % d ▁ and ▁ % d " % ( s , e ) ) NEW_LINE DEDENT
Hyp: 
def printUnsorted ( arr , n ) : NEW_LINE INDENT s = 0 NEW_LINE e = n - 1 NEW_LINE for s in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( arr [ s ] > arr [ s + 1 ] ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( s == n - 1 ) : NEW_LINE INDENT print ( " The ▁ complete ▁ array ▁ is ▁ sorted " ) NEW_LINE return NEW_LINE DEDENT for e in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT if ( arr [ e ] < arr [ e - 1 ] ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT max = arr [ s ] NEW_LINE min = arr [ s ] NEW_LINE for i in range ( s + 1 , e + 1 ) : NEW_LINE INDENT if ( arr [ i ] > min ) : NEW_LINE INDENT s = i NEW_LINE break NEW_LINE DEDENT DEDENT for i in range ( n - 1 , e + 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] < max ) : NEW_LINE INDENT e = i NEW_LINE break NEW_LINE DEDENT DEDENT print ( " The ▁ unsorted ▁ subarray ▁ which " , " ▁ makes ▁ the ▁ given ▁ array " , sep = " " ) NEW_LINE print ( " The ▁ unsorted ▁ subarray ▁ which " , " sorted ▁ lies ▁ between ▁ the ▁ indees " , s , " and ▁ " , e ) NEW_LINE return NEW_LINE DEDENT

BLEU: 62.86
Edit Sim: 354


Src: 
int circle ( int x1 , int y1 , int x2 , int y2 , int r1 , int r2 ) { int distSq = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ; int radSumSq = ( r1 + r2 ) * ( r1 + r2 ) ; if ( distSq == radSumSq ) return 1 ; else if ( distSq > radSumSq ) return - 1 ; else return 0 ; }
Ref: 
def circle ( x1 , y1 , x2 , y2 , r1 , r2 ) : NEW_LINE INDENT distSq = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) NEW_LINE radSumSq = ( r1 + r2 ) * ( r1 + r2 ) NEW_LINE if ( distSq == radSumSq ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( distSq > radSumSq ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT
Hyp: 
def circle ( x1 , y1 , x2 , y2 , r1 , r2 ) : NEW_LINE INDENT distSq = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) NEW_LINE radSumSq = ( r1 + r2 ) * ( r1 + r2 ) NEW_LINE if ( distSq == radSumSq ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( distSq > radSumSq ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
void countDistinct ( int arr [ ] , int k , int n ) { map < int , int > hm ; int dist_count = 0 ; for ( int i = 0 ; i < k ; i ++ ) { if ( hm [ arr [ i ] ] == 0 ) { dist_count ++ ; } hm [ arr [ i ] ] += 1 ; } cout << dist_count << endl ; for ( int i = k ; i < n ; i ++ ) { if ( hm [ arr [ i - k ] ] == 1 ) { dist_count -- ; } hm [ arr [ i - k ] ] -= 1 ; if ( hm [ arr [ i ] ] == 0 ) { dist_count ++ ; } hm [ arr [ i ] ] += 1 ; cout << dist_count << endl ; } }
Ref: 
def countDistinct ( arr , k , n ) : NEW_LINE INDENT mp = defaultdict ( lambda : 0 ) NEW_LINE dist_count = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT if mp [ arr [ i ] ] == 0 : NEW_LINE INDENT dist_count += 1 NEW_LINE DEDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT print ( dist_count ) NEW_LINE for i in range ( k , n ) : NEW_LINE INDENT if mp [ arr [ i - k ] ] == 1 : NEW_LINE INDENT dist_count -= 1 NEW_LINE DEDENT mp [ arr [ i - k ] ] -= 1 NEW_LINE if mp [ arr [ i ] ] == 0 : NEW_LINE INDENT dist_count += 1 NEW_LINE DEDENT mp [ arr [ i ] ] += 1 NEW_LINE print ( dist_count ) NEW_LINE DEDENT DEDENT
Hyp: 
def countDistinct ( arr , k , n ) : NEW_LINE INDENT hm = dict ( ) NEW_LINE dist_count = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT if ( hm [ arr [ i ] ] == 0 ) : NEW_LINE INDENT dist_count += 1 NEW_LINE DEDENT hm [ arr [ i ] ] += 1 NEW_LINE DEDENT print ( dist_count ) NEW_LINE for i in range ( k , n ) : NEW_LINE INDENT if ( hm [ arr [ i - k ] ] == 1 ) : NEW_LINE INDENT dist_count -= 1 NEW_LINE DEDENT hm [ arr [ i - k ] ] -= 1 NEW_LINE if ( hm [ arr [ i ] ] == 0 ) : NEW_LINE INDENT dist_count += 1 NEW_LINE DEDENT hm [ arr [ i ] ] += 1 NEW_LINE print ( dist_count ) NEW_LINE DEDENT DEDENT

BLEU: 79.43
Edit Sim: 44


Src: 
float findArea ( float a ) { float area ; area = ( sqrt ( 5 * ( 5 + 2 * ( sqrt ( 5 ) ) ) ) * a * a ) / 4 ; return area ; }
Ref: 
def findArea ( a ) : NEW_LINE INDENT area = ( sqrt ( 5 * ( 5 + 2 * ( sqrt ( 5 ) ) ) ) * a * a ) / 4 NEW_LINE return area NEW_LINE DEDENT
Hyp: 
def findArea ( a ) : NEW_LINE INDENT area = ( math . sqrt ( 5 * ( 5 + 2 * ( math . sqrt ( 5 ) ) ) ) * a * a ) / 4 NEW_LINE return math . floor ( area ) NEW_LINE DEDENT

BLEU: 70.56
Edit Sim: 31


Src: 
int countRotationsDivBy8 ( string n ) { int len = n . length ( ) ; int count = 0 ; if ( len == 1 ) { int oneDigit = n [ 0 ] - '0' ; if ( oneDigit % 8 == 0 ) return 1 ; return 0 ; } if ( len == 2 ) { int first = ( n [ 0 ] - '0' ) * 10 + ( n [ 1 ] - '0' ) ; int second = ( n [ 1 ] - '0' ) * 10 + ( n [ 0 ] - '0' ) ; if ( first % 8 == 0 ) count ++ ; if ( second % 8 == 0 ) count ++ ; return count ; } int threeDigit ; for ( int i = 0 ; i < ( len - 2 ) ; i ++ ) { threeDigit = ( n [ i ] - '0' ) * 100 + ( n [ i + 1 ] - '0' ) * 10 + ( n [ i + 2 ] - '0' ) ; if ( threeDigit % 8 == 0 ) count ++ ; } threeDigit = ( n [ len - 1 ] - '0' ) * 100 + ( n [ 0 ] - '0' ) * 10 + ( n [ 1 ] - '0' ) ; if ( threeDigit % 8 == 0 ) count ++ ; threeDigit = ( n [ len - 2 ] - '0' ) * 100 + ( n [ len - 1 ] - '0' ) * 10 + ( n [ 0 ] - '0' ) ; if ( threeDigit % 8 == 0 ) count ++ ; return count ; }
Ref: 
def countRotationsDivBy8 ( n ) : NEW_LINE INDENT l = len ( n ) NEW_LINE count = 0 NEW_LINE if ( l == 1 ) : NEW_LINE INDENT oneDigit = int ( n [ 0 ] ) NEW_LINE if ( oneDigit % 8 == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT if ( l == 2 ) : NEW_LINE INDENT first = int ( n [ 0 ] ) * 10 + int ( n [ 1 ] ) NEW_LINE second = int ( n [ 1 ] ) * 10 + int ( n [ 0 ] ) NEW_LINE if ( first % 8 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( second % 8 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT threeDigit = 0 NEW_LINE for i in range ( 0 , ( l - 2 ) ) : NEW_LINE INDENT threeDigit = ( int ( n [ i ] ) * 100 + int ( n [ i + 1 ] ) * 10 + int ( n [ i + 2 ] ) ) NEW_LINE if ( threeDigit % 8 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT threeDigit = ( int ( n [ l - 1 ] ) * 100 + int ( n [ 0 ] ) * 10 + int ( n [ 1 ] ) ) NEW_LINE if ( threeDigit % 8 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT threeDigit = ( int ( n [ l - 2 ] ) * 100 + int ( n [ l - 1 ] ) * 10 + int ( n [ 0 ] ) ) NEW_LINE if ( threeDigit % 8 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
Hyp: 
def countRotationsDivBy8 ( n ) : NEW_LINE INDENT l = len ( n ) NEW_LINE count = 0 NEW_LINE if ( l == 1 ) : NEW_LINE INDENT oneDigit = ord ( n [ 0 ] ) - ord ( '0' ) NEW_LINE if ( oneDigit % 8 == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT if ( l == 2 ) : NEW_LINE INDENT first = ( ord ( n [ 0 ] ) - ord ( '0' ) ) * 10 + ( n [ 1 ] - ord ( '0' ) ) NEW_LINE second = ( ord ( n [ 1 ] ) - ord ( '0' ) ) * 10 + ( n [ 0 ] ) - ord ( '0' ) ) NEW_LINE if ( first % 8 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( second % 8 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT threeDigit = 0 NEW_LINE for i in range ( 0 , ( l - 2 ) ) : NEW_LINE INDENT threeDigit = ( ord ( n [ i ] ) - ord ( '0' ) ) * 100 + ( n [ i + 1 ] - ord ( '0' ) ) * 10 + ( n [ i + 2 ] - ord ( '0' ) ) NEW_LINE if ( threeDigit % 8 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT threeDigit = ( ord ( n [ l - 1 ] ) - ord ( '0' ) ) * 100 + ( n [ 0 ] - ord ( '0' ) ) * 10 + ( n [ 1 ] - ord ( '0' ) ) NEW_LINE if ( threeDigit % 8 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT threeDigit = ( ord ( n [ l - 2 ] - ord ( '0' ) ) * 100 + ( n [ len - 1 ] - ord ( '0' ) ) * 10 + ( n [ 0 ] - ord ( '0' ) ) NEW_LINE if ( threeDigit % 8 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT

BLEU: 68.15
Edit Sim: 253


Src: 
int lcs ( int dp [ MAX ] [ MAX ] [ MAX ] , int arr1 [ ] , int n , int arr2 [ ] , int m , int k ) { if ( k < 0 ) return - 1e7 ; if ( n < 0 || m < 0 ) return 0 ; int & ans = dp [ n ] [ m ] [ k ] ; if ( ans != - 1 ) return ans ; ans = max ( lcs ( dp , arr1 , n - 1 , arr2 , m , k ) , lcs ( dp , arr1 , n , arr2 , m - 1 , k ) ) ; if ( arr1 [ n - 1 ] == arr2 [ m - 1 ] ) ans = max ( ans , 1 + lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k ) ) ; ans = max ( ans , 1 + lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k - 1 ) ) ; return ans ; }
Ref: 
def lcs ( dp , arr1 , n , arr2 , m , k ) : NEW_LINE INDENT if k < 0 : NEW_LINE INDENT return - ( 10 ** 7 ) NEW_LINE DEDENT if n < 0 or m < 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = dp [ n ] [ m ] [ k ] NEW_LINE if ans != - 1 : NEW_LINE INDENT return ans NEW_LINE DEDENT ans = max ( lcs ( dp , arr1 , n - 1 , arr2 , m , k ) , lcs ( dp , arr1 , n , arr2 , m - 1 , k ) ) NEW_LINE if arr1 [ n - 1 ] == arr2 [ m - 1 ] : NEW_LINE INDENT ans = max ( ans , 1 + lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k ) ) NEW_LINE DEDENT ans = max ( ans , lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k - 1 ) ) NEW_LINE return ans NEW_LINE DEDENT
Hyp: 
def lcs ( dp , arr1 , n , arr2 , m , k ) : NEW_LINE INDENT if ( k < 0 ) : NEW_LINE INDENT return - 1e7 NEW_LINE DEDENT if ( n < 0 or m < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = dp [ n ] [ m ] [ k ] NEW_LINE if ( ans != - 1 ) : NEW_LINE INDENT return ans NEW_LINE DEDENT ans = max ( lcs ( dp , arr1 , n - 1 , arr2 , m , k ) , lcs ( dp , arr1 , n , arr2 , m - 1 , k ) ) NEW_LINE if ( arr1 [ n - 1 ] == arr2 [ m - 1 ] ) : NEW_LINE INDENT ans = max ( ans , 1 + lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k ) ) NEW_LINE DEDENT ans = max ( ans , 1 + lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k - 1 ) ) NEW_LINE return ans NEW_LINE DEDENT

BLEU: 86.77
Edit Sim: 29


Src: 
int editDistDP ( string str1 , string str2 , int m , int n ) { int dp [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 ) dp [ i ] [ j ] = j ; else if ( j == 0 ) dp [ i ] [ j ] = i ; else if ( str1 [ i - 1 ] == str2 [ j - 1 ] ) dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = 1 + min ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ j - 1 ] ) ; } } return dp [ m ] [ n ] ; }
Ref: 
def editDistDP ( str1 , str2 , m , n ) : NEW_LINE INDENT dp = [ [ 0 for x in range ( n + 1 ) ] for x in range ( m + 1 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT dp [ i ] [ j ] = j NEW_LINE DEDENT elif j == 0 : NEW_LINE INDENT dp [ i ] [ j ] = i NEW_LINE DEDENT elif str1 [ i - 1 ] == str2 [ j - 1 ] : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = 1 + min ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ m ] [ n ] NEW_LINE DEDENT
Hyp: 
def editDistDP ( str1 , str2 , m , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( m + 1 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT dp [ i ] [ j ] = j NEW_LINE DEDENT elif j == 0 : NEW_LINE INDENT dp [ i ] [ j ] = i NEW_LINE DEDENT elif str1 [ i - 1 ] == str2 [ j - 1 ] : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = 1 + min ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ m ] [ n ] NEW_LINE DEDENT

BLEU: 97.48
Edit Sim: 2


Src: 
int countOps ( int A [ ] [ MAX ] , int B [ ] [ MAX ] , int m , int n ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) A [ i ] [ j ] -= B [ i ] [ j ] ; for ( int i = 1 ; i < n ; i ++ ) for ( int j = 1 ; j < m ; j ++ ) if ( A [ i ] [ j ] - A [ i ] [ 0 ] - A [ 0 ] [ j ] + A [ 0 ] [ 0 ] != 0 ) return - 1 ; int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) result += abs ( A [ i ] [ 0 ] ) ; for ( int j = 0 ; j < m ; j ++ ) result += abs ( A [ 0 ] [ j ] - A [ 0 ] [ 0 ] ) ; return ( result ) ; }
Ref: 
def countOps ( A , B , m , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT A [ i ] [ j ] -= B [ i ] [ j ] NEW_LINE DEDENT DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT if ( A [ i ] [ j ] - A [ i ] [ 0 ] - A [ 0 ] [ j ] + A [ 0 ] [ 0 ] != 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT DEDENT result = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT result += abs ( A [ i ] [ 0 ] ) NEW_LINE DEDENT for j in range ( m ) : NEW_LINE INDENT result += abs ( A [ 0 ] [ j ] - A [ 0 ] [ 0 ] ) NEW_LINE DEDENT return ( result ) NEW_LINE DEDENT
Hyp: 
def countOps ( A , B , m , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , m ) : NEW_LINE INDENT A [ i ] [ j ] -= B [ i ] [ j ] NEW_LINE DEDENT DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( 1 , m ) : NEW_LINE INDENT if ( A [ i ] [ j ] - A [ i ] [ 0 ] - A [ 0 ] [ j ] + A [ 0 ] [ 0 ] != 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT DEDENT result = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT result += abs ( A [ i ] [ 0 ] ) NEW_LINE DEDENT for j in range ( 0 , m ) : NEW_LINE INDENT result += abs ( A [ 0 ] [ j ] - A [ 0 ] [ 0 ] ) NEW_LINE DEDENT return ( result ) NEW_LINE DEDENT

BLEU: 91.89
Edit Sim: 17


Src: 
void longestAlternating ( int arr [ ] , int n ) { int count [ n ] ; count [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] * arr [ i + 1 ] < 0 ) count [ i ] = count [ i + 1 ] + 1 ; else count [ i ] = 1 ; } for ( int i = 0 ; i < n ; i ++ ) cout << count [ i ] << " ▁ " ; }
Ref: 
def longestAlternating ( arr , n ) : NEW_LINE INDENT count = [ None ] * n NEW_LINE count [ n - 1 ] = 1 NEW_LINE i = n - 2 NEW_LINE while i >= 0 : NEW_LINE INDENT if ( arr [ i ] * arr [ i + 1 ] < 0 ) : NEW_LINE INDENT count [ i ] = count [ i + 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT count [ i ] = 1 NEW_LINE DEDENT i = i - 1 NEW_LINE DEDENT i = 0 NEW_LINE while i < n : NEW_LINE INDENT print ( count [ i ] , end = " ▁ " ) NEW_LINE i = i + 1 NEW_LINE DEDENT DEDENT
Hyp: 
def longestAlternating ( arr , n ) : NEW_LINE INDENT count = [ 0 ] * n NEW_LINE count [ n - 1 ] = 1 NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] * arr [ i + 1 ] < 0 ) : NEW_LINE INDENT count [ i ] = count [ i + 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT count [ i ] = 1 NEW_LINE DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( count [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT

BLEU: 69.96
Edit Sim: 92


Src: 
void printDivisors ( int n ) { vector < int > v ; for ( int i = 1 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) printf ( " % d ▁ " , i ) ; else { printf ( " % d ▁ " , i ) ; v . push_back ( n / i ) ; } } } for ( int i = v . size ( ) - 1 ; i >= 0 ; i -- ) printf ( " % d ▁ " , v [ i ] ) ; }
Ref: 
def printDivisors ( n ) : NEW_LINE INDENT list = [ ] NEW_LINE for i in range ( 1 , int ( math . sqrt ( n ) + 1 ) ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( n / i == i ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE list . append ( int ( n / i ) ) NEW_LINE DEDENT DEDENT DEDENT for i in list [ : : - 1 ] : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT
Hyp: 
def printDivisors ( n ) : NEW_LINE INDENT v = [ ] NEW_LINE for i in range ( 1 , int ( m . sqrt ( n ) + 1 ) ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT if n / i == i : NEW_LINE INDENT print ( " % d ▁ " , i ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " % d ▁ " , i ) NEW_LINE v . append ( n / i ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( len ( v ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( v [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT

BLEU: 61.1
Edit Sim: 73


Src: 
bool isPower ( int x , long int y ) { if ( x == 1 ) return ( y == 1 ) ; long int pow = 1 ; while ( pow < y ) pow *= x ; return ( pow == y ) ; }
Ref: 
def isPower ( x , y ) : NEW_LINE INDENT if ( x == 1 ) : NEW_LINE INDENT return ( y == 1 ) NEW_LINE DEDENT pow = 1 NEW_LINE while ( pow < y ) : NEW_LINE INDENT pow = pow * x NEW_LINE DEDENT return ( pow == y ) NEW_LINE DEDENT
Hyp: 
def isPower ( x , y ) : NEW_LINE INDENT if ( x == 1 ) : NEW_LINE INDENT return ( y == 1 ) NEW_LINE DEDENT pow = 1 NEW_LINE while ( pow < y ) : NEW_LINE INDENT pow *= x NEW_LINE DEDENT return ( pow == y ) NEW_LINE DEDENT

BLEU: 91.64
Edit Sim: 7


Src: 
int maxSum ( int arr [ ] , int N , int k ) { int MS [ N ] ; MS [ N - 1 ] = arr [ N - 1 ] ; for ( int i = N - 2 ; i >= 0 ; i -- ) { if ( i + k + 1 >= N ) MS [ i ] = max ( arr [ i ] , MS [ i + 1 ] ) ; else MS [ i ] = max ( arr [ i ] + MS [ i + k + 1 ] , MS [ i + 1 ] ) ; } return MS [ 0 ] ; }
Ref: 
def maxSum ( arr , N , k ) : NEW_LINE INDENT MS = [ 0 for i in range ( N ) ] NEW_LINE MS [ N - 1 ] = arr [ N - 1 ] NEW_LINE for i in range ( N - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( i + k + 1 >= N ) : NEW_LINE INDENT MS [ i ] = max ( arr [ i ] , MS [ i + 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT MS [ i ] = max ( arr [ i ] + MS [ i + k + 1 ] , MS [ i + 1 ] ) NEW_LINE DEDENT DEDENT return MS [ 0 ] NEW_LINE DEDENT
Hyp: 
def maxSum ( arr , N , k ) : NEW_LINE INDENT MS = [ 0 ] * N NEW_LINE MS [ N - 1 ] = arr [ N - 1 ] NEW_LINE for i in range ( N - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( i + k + 1 >= N ) : NEW_LINE INDENT MS [ i ] = max ( arr [ i ] , MS [ i + 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT MS [ i ] = max ( arr [ i ] + MS [ i + k + 1 ] , MS [ i + 1 ] ) NEW_LINE DEDENT DEDENT return MS [ 0 ] NEW_LINE DEDENT

BLEU: 93.13
Edit Sim: 19


Src: 
void printGrouped ( string str ) { int n = str . length ( ) ; int count [ MAX_CHAR ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) count [ str [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < n ; i ++ ) { while ( count [ str [ i ] - ' a ' ] -- ) cout << str [ i ] ; count [ str [ i ] - ' a ' ] = 0 ; } }
Ref: 
def printGrouped ( string ) : NEW_LINE INDENT n = len ( string ) NEW_LINE count = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( n ) : NEW_LINE INDENT count [ ord ( string [ i ] ) - ord ( " a " ) ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT while count [ ord ( string [ i ] ) - ord ( " a " ) ] : NEW_LINE INDENT print ( string [ i ] , end = " " ) NEW_LINE count [ ord ( string [ i ] ) - ord ( " a " ) ] -= 1 NEW_LINE DEDENT count [ ord ( string [ i ] ) - ord ( " a " ) ] = 0 NEW_LINE DEDENT DEDENT
Hyp: 
def printGrouped ( Str ) : NEW_LINE INDENT n = len ( Str ) NEW_LINE count = [ 0 for i in range ( MAX_CHAR ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT count [ ord ( Str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT while ( count [ ord ( Str [ i ] ) - ord ( ' a ' ) ] > 0 ) : NEW_LINE INDENT print ( Str [ i ] , end = " " ) NEW_LINE DEDENT count [ ord ( Str [ i ] ) - ord ( ' a ' ) ] = 0 NEW_LINE DEDENT DEDENT

BLEU: 60.16
Edit Sim: 118


Src: 
int sortedCount ( int mat [ ] [ MAX ] , int r , int c ) { int result = 0 ; for ( int i = 0 ; i < r ; i ++ ) { int j ; for ( j = 0 ; j < c - 1 ; j ++ ) if ( mat [ i ] [ j + 1 ] <= mat [ i ] [ j ] ) break ; if ( j == c - 1 ) result ++ ; } for ( int i = 0 ; i < r ; i ++ ) { int j ; for ( j = c - 1 ; j > 0 ; j -- ) if ( mat [ i ] [ j - 1 ] <= mat [ i ] [ j ] ) break ; if ( c > 1 && j == 0 ) result ++ ; } return result ; }
Ref: 
def sortedCount ( mat , r , c ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( r ) : NEW_LINE INDENT j = 0 NEW_LINE for j in range ( c - 1 ) : NEW_LINE INDENT if mat [ i ] [ j + 1 ] <= mat [ i ] [ j ] : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if j == c - 2 : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT for i in range ( 0 , r ) : NEW_LINE INDENT j = 0 NEW_LINE for j in range ( c - 1 , 0 , - 1 ) : NEW_LINE INDENT if mat [ i ] [ j - 1 ] <= mat [ i ] [ j ] : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if c > 1 and j == 1 : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
Hyp: 
def sortedCount ( mat , r , c ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( r ) : NEW_LINE INDENT j = 0 NEW_LINE while ( j < c - 1 ) : NEW_LINE INDENT if ( mat [ i ] [ j + 1 ] <= mat [ i ] [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if ( j == c - 1 ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT for i in range ( r ) : NEW_LINE INDENT j = c - 1 NEW_LINE while ( j > 0 ) : NEW_LINE INDENT if ( mat [ i ] [ j - 1 ] <= mat [ i ] [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT j -= 1 NEW_LINE DEDENT if ( c > 1 and j == 0 ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT

BLEU: 72.6
Edit Sim: 96


Src: 
int countSub ( string str ) { vector < int > last ( MAX_CHAR , - 1 ) ; int n = str . length ( ) ; int dp [ n + 1 ] ; dp [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { dp [ i ] = 2 * dp [ i - 1 ] ; if ( last [ str [ i - 1 ] ] != - 1 ) dp [ i ] = dp [ i ] - dp [ last [ str [ i - 1 ] ] ] ; last [ str [ i - 1 ] ] = ( i - 1 ) ; } return dp [ n ] ; }
Ref: 
def countSub ( ss ) : NEW_LINE INDENT last = [ - 1 for i in range ( MAX_CHAR + 1 ) ] NEW_LINE n = len ( ss ) NEW_LINE dp = [ - 2 for i in range ( n + 1 ) ] NEW_LINE dp [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT dp [ i ] = 2 * dp [ i - 1 ] NEW_LINE if last [ ord ( ss [ i - 1 ] ) ] != - 1 : NEW_LINE INDENT dp [ i ] = dp [ i ] - dp [ last [ ord ( ss [ i - 1 ] ) ] ] NEW_LINE DEDENT last [ ord ( ss [ i - 1 ] ) ] = i - 1 NEW_LINE DEDENT return dp [ n ] NEW_LINE DEDENT
Hyp: 
def countSub ( str ) : NEW_LINE INDENT last = [ - 1 for i in range ( MAX_CHAR ) ] NEW_LINE n = len ( str ) NEW_LINE dp = [ 0 for _ in range ( n + 1 ) ] NEW_LINE dp [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT dp [ i ] = 2 * dp [ i - 1 ] NEW_LINE if ( last [ str [ i - 1 ] ] != - 1 ) : NEW_LINE INDENT dp [ i ] = dp [ i ] - dp [ last [ str [ i - 1 ] ] ] NEW_LINE DEDENT last [ str [ i - 1 ] ] = ( i - 1 ) NEW_LINE DEDENT return dp [ n ] NEW_LINE DEDENT

BLEU: 73.41
Edit Sim: 49


Src: 
int findLIS ( int A [ ] , int n ) { unordered_map < int , int > hash ; int LIS_size = 1 ; int LIS_index = 0 ; hash [ A [ 0 ] ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { hash [ A [ i ] ] = hash [ A [ i ] - 1 ] + 1 ; if ( LIS_size < hash [ A [ i ] ] ) { LIS_size = hash [ A [ i ] ] ; LIS_index = A [ i ] ; } } cout << " LIS _ size ▁ = ▁ " << LIS_size << " \n " ; cout << " LIS ▁ : ▁ " ; int start = LIS_index - LIS_size + 1 ; while ( start <= LIS_index ) { cout << start << " ▁ " ; start ++ ; } }
Ref: 
def findLIS ( A , n ) : NEW_LINE INDENT hash = dict ( ) NEW_LINE LIS_size , LIS_index = 1 , 0 NEW_LINE hash [ A [ 0 ] ] = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if A [ i ] - 1 not in hash : NEW_LINE INDENT hash [ A [ i ] - 1 ] = 0 NEW_LINE DEDENT hash [ A [ i ] ] = hash [ A [ i ] - 1 ] + 1 NEW_LINE if LIS_size < hash [ A [ i ] ] : NEW_LINE INDENT LIS_size = hash [ A [ i ] ] NEW_LINE LIS_index = A [ i ] NEW_LINE DEDENT DEDENT print ( " LIS _ size ▁ = " , LIS_size ) NEW_LINE print ( " LIS ▁ : ▁ " , end = " " ) NEW_LINE start = LIS_index - LIS_size + 1 NEW_LINE while start <= LIS_index : NEW_LINE INDENT print ( start , end = " ▁ " ) NEW_LINE start += 1 NEW_LINE DEDENT DEDENT
Hyp: 
def findLIS ( A , n ) : NEW_LINE INDENT Hash = dict ( ) NEW_LINE LIS_size = 1 NEW_LINE LIS_index = 0 NEW_LINE hash [ A [ 0 ] ] = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT Hash [ A [ i ] ] = Hash [ A [ i ] - 1 ] + 1 NEW_LINE if ( LIS_size < Hash [ A [ i ] ] ) : NEW_LINE INDENT LIS_size = Hash [ A [ i ] ] NEW_LINE LIS_index = A [ i ] NEW_LINE DEDENT DEDENT print ( " LIS _ size ▁ = ▁ " , LIS_size , " \n " ) NEW_LINE print ( " LIS ▁ : ▁ " , LIS_index ) NEW_LINE start = LIS_index - LIS_size + 1 NEW_LINE while ( start <= LIS_index ) : NEW_LINE INDENT print ( start , end = " ▁ " ) NEW_LINE start += 1 NEW_LINE DEDENT DEDENT

BLEU: 68.71
Edit Sim: 135


Src: 
void printMaxOfMin ( int arr [ ] , int n ) { for ( int k = 1 ; k <= n ; k ++ ) { int maxOfMin = INT_MIN ; for ( int i = 0 ; i <= n - k ; i ++ ) { int min = arr [ i ] ; for ( int j = 1 ; j < k ; j ++ ) { if ( arr [ i + j ] < min ) min = arr [ i + j ] ; } if ( min > maxOfMin ) maxOfMin = min ; } cout << maxOfMin << " ▁ " ; } }
Ref: 
def printMaxOfMin ( arr , n ) : NEW_LINE INDENT for k in range ( 1 , n + 1 ) : NEW_LINE INDENT maxOfMin = INT_MIN NEW_LINE for i in range ( n - k + 1 ) : NEW_LINE INDENT min = arr [ i ] NEW_LINE for j in range ( k ) : NEW_LINE INDENT if ( arr [ i + j ] < min ) : NEW_LINE INDENT min = arr [ i + j ] NEW_LINE DEDENT DEDENT if ( min > maxOfMin ) : NEW_LINE INDENT maxOfMin = min NEW_LINE DEDENT DEDENT print ( maxOfMin , end = " ▁ " ) NEW_LINE DEDENT DEDENT
Hyp: 
def printMaxOfMin ( arr , n ) : NEW_LINE INDENT for k in range ( 1 , n + 1 ) : NEW_LINE INDENT maxOfMin = - sys . maxsize - 1 NEW_LINE for i in range ( 0 , n - k + 1 ) : NEW_LINE INDENT min = arr [ i ] NEW_LINE for j in range ( 1 , k + 1 ) : NEW_LINE INDENT if ( arr [ i + j ] < min ) : NEW_LINE INDENT min = arr [ i + j ] NEW_LINE DEDENT DEDENT if ( min > maxOfMin ) : NEW_LINE INDENT maxOfMin = min NEW_LINE DEDENT DEDENT print ( maxOfMin , end = " ▁ " ) NEW_LINE DEDENT DEDENT

BLEU: 85.83
Edit Sim: 31


Src: 
int maximumZeros ( int * arr , int n , int k ) { int subset [ k + 1 ] [ MAX5 + 5 ] ; memset ( subset , - 1 , sizeof ( subset ) ) ; subset [ 0 ] [ 0 ] = 0 ; for ( int p = 0 ; p < n ; p ++ ) { int pw2 = 0 , pw5 = 0 ; while ( arr [ p ] % 2 == 0 ) { pw2 ++ ; arr [ p ] /= 2 ; } while ( arr [ p ] % 5 == 0 ) { pw5 ++ ; arr [ p ] /= 5 ; } for ( int i = k - 1 ; i >= 0 ; i -- ) for ( int j = 0 ; j < MAX5 ; j ++ ) if ( subset [ i ] [ j ] != - 1 ) subset [ i + 1 ] [ j + pw5 ] = max ( subset [ i + 1 ] [ j + pw5 ] , subset [ i ] [ j ] + pw2 ) ; } int ans = 0 ; for ( int i = 0 ; i < MAX5 ; i ++ ) ans = max ( ans , min ( i , subset [ k ] [ i ] ) ) ; return ans ; }
Ref: 
def maximumZeros ( arr , n , k ) : NEW_LINE INDENT global MAX5 NEW_LINE subset = [ [ - 1 ] * ( MAX5 + 5 ) for _ in range ( k + 1 ) ] NEW_LINE subset [ 0 ] [ 0 ] = 0 NEW_LINE for p in arr : NEW_LINE INDENT pw2 , pw5 = 0 , 0 NEW_LINE while not p % 2 : NEW_LINE INDENT pw2 += 1 NEW_LINE p //= 2 NEW_LINE DEDENT while not p % 5 : NEW_LINE INDENT pw5 += 1 NEW_LINE p //= 5 NEW_LINE DEDENT for i in range ( k - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( MAX5 ) : NEW_LINE INDENT if subset [ i ] [ j ] != - 1 : NEW_LINE INDENT subset [ i + 1 ] [ j + pw5 ] = ( max ( subset [ i + 1 ] [ j + pw5 ] , ( subset [ i ] [ j ] + pw2 ) ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( MAX5 ) : NEW_LINE INDENT ans = max ( ans , min ( i , subset [ k ] [ i ] ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
Hyp: 
def maximumZeros ( arr , n , k ) : NEW_LINE INDENT subset = [ [ 0 for i in range ( MAX5 + 5 ) ] for j in range ( k + 1 ) ] NEW_LINE for p in range ( n ) : NEW_LINE INDENT pw2 = 0 NEW_LINE pw5 = 0 NEW_LINE while ( arr [ p ] % 2 == 0 ) : NEW_LINE INDENT pw2 += 1 NEW_LINE arr [ p ] /= 2 NEW_LINE DEDENT while ( arr [ p ] % 5 == 0 ) : NEW_LINE INDENT pw5 += 1 NEW_LINE arr [ p ] /= 5 NEW_LINE DEDENT for i in range ( k - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( MAX5 ) : NEW_LINE INDENT if ( subset [ i ] [ j ] != - 1 ) : NEW_LINE INDENT subset [ i + 1 ] [ j + pw5 ] = max ( subset [ i + 1 ] [ j + pw5 ] , subset [ i ] [ j ] + pw2 ) NEW_LINE DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( MAX5 ) : NEW_LINE INDENT ans = max ( ans , min ( i , subset [ k ] [ i ] ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT

BLEU: 72.97
Edit Sim: 151


Src: 
int largestSubset ( int a [ ] , int n ) { sort ( a , a + n ) ; int dp [ n ] ; dp [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { int mxm = 0 ; for ( int j = i + 1 ; j < n ; j ++ ) if ( a [ j ] % a [ i ] == 0 ) mxm = max ( mxm , dp [ j ] ) ; dp [ i ] = 1 + mxm ; } return * max_element ( dp , dp + n ) ; }
Ref: 
def largestSubset ( a , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE dp = [ 0 for i in range ( n ) ] NEW_LINE dp [ n - 1 ] = 1 NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT mxm = 0 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if a [ j ] % a [ i ] == 0 : NEW_LINE INDENT mxm = max ( mxm , dp [ j ] ) NEW_LINE DEDENT DEDENT dp [ i ] = 1 + mxm NEW_LINE DEDENT return max ( dp ) NEW_LINE DEDENT
Hyp: 
def largestSubset ( a , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE dp = [ 0 ] * ( n + 1 ) NEW_LINE dp [ n - 1 ] = 1 NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT mxm = 0 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( a [ j ] % a [ i ] == 0 ) : NEW_LINE INDENT mxm = max ( mxm , dp [ j ] ) NEW_LINE DEDENT DEDENT dp [ i ] = 1 + mxm NEW_LINE DEDENT return max ( dp , dp + n ) NEW_LINE DEDENT

BLEU: 85.75
Edit Sim: 27


Src: 
char encodedChar ( string str , int k ) { string expand = " " ; string temp ; int freq = 0 ; for ( int i = 0 ; str [ i ] != ' \0' ; ) { temp = " " ; freq = 0 ; while ( str [ i ] >= ' a ' && str [ i ] <= ' z ' ) { temp . push_back ( str [ i ] ) ; i ++ ; } while ( str [ i ] >= '1' && str [ i ] <= '9' ) { freq = freq * 10 + str [ i ] - '0' ; i ++ ; } for ( int j = 1 ; j <= freq ; j ++ ) expand . append ( temp ) ; } if ( freq == 0 ) expand . append ( temp ) ; return expand [ k - 1 ] ; }
Ref: 
def encodedChar ( str , k ) : NEW_LINE INDENT expand = " " NEW_LINE freq = 0 NEW_LINE i = 0 NEW_LINE while ( i < len ( str ) ) : NEW_LINE INDENT temp = " " NEW_LINE freq = 0 NEW_LINE while ( i < len ( str ) and ord ( str [ i ] ) >= ord ( ' a ' ) and ord ( str [ i ] ) <= ord ( ' z ' ) ) : NEW_LINE INDENT temp += str [ i ] NEW_LINE i += 1 NEW_LINE DEDENT while ( i < len ( str ) and ord ( str [ i ] ) >= ord ( '1' ) and ord ( str [ i ] ) <= ord ( '9' ) ) : NEW_LINE INDENT freq = freq * 10 + ord ( str [ i ] ) - ord ( '0' ) NEW_LINE i += 1 NEW_LINE DEDENT for j in range ( 1 , freq + 1 , 1 ) : NEW_LINE INDENT expand += temp NEW_LINE DEDENT DEDENT if ( freq == 0 ) : NEW_LINE INDENT expand += temp NEW_LINE DEDENT return expand [ k - 1 ] NEW_LINE DEDENT
Hyp: 
def encodedChar ( str , k ) : NEW_LINE INDENT expand = " " NEW_LINE temp = " " NEW_LINE freq = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT temp = " " NEW_LINE freq = 0 NEW_LINE while ( i < len ( str ) and str [ i ] != ' \0' ) : NEW_LINE INDENT temp . append ( chr ( ord ( str [ i ] ) ) NEW_LINE i += 1 NEW_LINE DEDENT while ( str [ i ] >= '1' and str [ i ] <= '9' ) : NEW_LINE INDENT freq = freq * 10 + ord ( str [ i ] ) - ord ( '0' ) NEW_LINE i += 1 NEW_LINE DEDENT for j in range ( 1 , freq + 1 ) : NEW_LINE INDENT expand . append ( temp ) NEW_LINE DEDENT DEDENT if ( freq == 0 ) : NEW_LINE INDENT expand . append ( temp ) NEW_LINE DEDENT return expand [ k - 1 ] NEW_LINE DEDENT

BLEU: 64.07
Edit Sim: 181


Src: 
int countNum ( int arr [ ] , int n ) { unordered_set < int > s ; int count = 0 , maxm = INT_MIN , minm = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { s . insert ( arr [ i ] ) ; if ( arr [ i ] < minm ) minm = arr [ i ] ; if ( arr [ i ] > maxm ) maxm = arr [ i ] ; } for ( int i = minm ; i <= maxm ; i ++ ) if ( s . find ( arr [ i ] ) == s . end ( ) ) count ++ ; return count ; }
Ref: 
def countNum ( arr , n ) : NEW_LINE INDENT s = dict ( ) NEW_LINE count , maxm , minm = 0 , - 10 ** 9 , 10 ** 9 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s [ arr [ i ] ] = 1 NEW_LINE if ( arr [ i ] < minm ) : NEW_LINE INDENT minm = arr [ i ] NEW_LINE DEDENT if ( arr [ i ] > maxm ) : NEW_LINE INDENT maxm = arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( minm , maxm + 1 ) : NEW_LINE INDENT if i not in s . keys ( ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
Hyp: 
def countNum ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE count = 0 NEW_LINE maxm = INT_MIN NEW_LINE minm = INT_MAX NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . add ( arr [ i ] ) NEW_LINE if ( arr [ i ] < minm ) : NEW_LINE INDENT minm = arr [ i ] NEW_LINE DEDENT if ( arr [ i ] > maxm ) : NEW_LINE INDENT maxm = arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( minm , maxm + 1 ) : NEW_LINE INDENT if arr [ i ] not in s : NEW_LINE INDENT s . add ( arr [ i ] ) NEW_LINE DEDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT

BLEU: 71.14
Edit Sim: 104


Src: 
int countPairs ( int arr [ ] , int n ) { unordered_map < int , int > mp ; for ( int i = 0 ; i < n ; i ++ ) mp [ arr [ i ] ] ++ ; int ans = 0 ; for ( auto it = mp . begin ( ) ; it != mp . end ( ) ; it ++ ) { int count = it -> second ; ans += ( count * ( count - 1 ) ) / 2 ; } return ans ; }
Ref: 
def countPairs ( arr , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] in mp . keys ( ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for it in mp : NEW_LINE INDENT count = mp [ it ] NEW_LINE ans += ( count * ( count - 1 ) ) // 2 NEW_LINE DEDENT return ans NEW_LINE DEDENT
Hyp: 
def countPairs ( arr , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] = mp . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT ans = 0 NEW_LINE for key , values in mp . items ( ) : NEW_LINE INDENT count = values NEW_LINE ans += ( count * ( count - 1 ) ) / 2 NEW_LINE DEDENT return int ( ans ) NEW_LINE DEDENT

BLEU: 59.88
Edit Sim: 132


Src: 
int maxDiff ( int arr [ ] , int n ) { int result = 0 ; sort ( arr , arr + n ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] != arr [ i + 1 ] ) result += abs ( arr [ i ] ) ; else i ++ ; } if ( arr [ n - 2 ] != arr [ n - 1 ] ) result += abs ( arr [ n - 1 ] ) ; return result ; }
Ref: 
def maxDiff ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE arr . sort ( ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( abs ( arr [ i ] ) != abs ( arr [ i + 1 ] ) ) : NEW_LINE INDENT result += abs ( arr [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT if ( arr [ n - 2 ] != arr [ n - 1 ] ) : NEW_LINE INDENT result += abs ( arr [ n - 1 ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT
Hyp: 
def maxDiff ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE arr . sort ( ) NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( arr [ i ] != arr [ i + 1 ] ) : NEW_LINE INDENT result += abs ( arr [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT if ( arr [ n - 2 ] != arr [ n - 1 ] ) : NEW_LINE INDENT result += abs ( arr [ n - 1 ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT

BLEU: 87.24
Edit Sim: 26


Src: 
int middleOfThree ( int a , int b , int c ) { if ( ( a < b && b < c ) || ( c < b && b < a ) ) return b ; else if ( ( b < a && a < c ) || ( c < a && a < b ) ) return a ; else return c ; }
Ref: 
def middleOfThree ( a , b , c ) : NEW_LINE INDENT if ( ( a < b and b < c ) or ( c < b and b < a ) ) : NEW_LINE INDENT return b NEW_LINE DEDENT if ( ( b < a and a < c ) or ( c < a and a < b ) ) : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return c NEW_LINE DEDENT DEDENT
Hyp: 
def middleOfThree ( a , b , c ) : NEW_LINE INDENT if ( ( a < b and b < c ) or ( c < b and b < a ) ) : NEW_LINE INDENT return b NEW_LINE DEDENT elif ( ( b < a and a < c ) or ( c < a and a < b ) ) : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return c NEW_LINE DEDENT DEDENT

BLEU: 96.78
Edit Sim: 2


Src: 
int countarray ( int n , int k , int x ) { int dp [ MAXN ] = { 0 } ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; for ( int i = 2 ; i < n ; i ++ ) dp [ i ] = ( k - 2 ) * dp [ i - 1 ] + ( k - 1 ) * dp [ i - 2 ] ; return ( x == 1 ? ( k - 1 ) * dp [ n - 2 ] : dp [ n - 1 ] ) ; }
Ref: 
def countarray ( n , k , x ) : NEW_LINE INDENT dp = list ( ) NEW_LINE dp . append ( 0 ) NEW_LINE dp . append ( 1 ) NEW_LINE i = 2 NEW_LINE while i < n : NEW_LINE INDENT dp . append ( ( k - 2 ) * dp [ i - 1 ] + ( k - 1 ) * dp [ i - 2 ] ) NEW_LINE i = i + 1 NEW_LINE DEDENT return ( ( k - 1 ) * dp [ n - 2 ] if x == 1 else dp [ n - 1 ] ) NEW_LINE DEDENT
Hyp: 
def countarray ( n , k , x ) : NEW_LINE INDENT dp = [ 0 for i in range ( MAXN ) ] NEW_LINE dp [ 0 ] = 0 NEW_LINE dp [ 1 ] = 1 NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT dp [ i ] = ( k - 2 ) * dp [ i - 1 ] + ( k - 1 ) * dp [ i - 2 ] ) NEW_LINE DEDENT return ( x == 1 ? ( k - 1 ) * dp [ n - 2 ] : dp [ n - 1 ] ) NEW_LINE DEDENT

BLEU: 60.34
Edit Sim: 114


Src: 
int nswp ( int n ) { if ( n == 0 || n == 1 ) return 1 ; return 2 * nswp ( n - 1 ) + nswp ( n - 2 ) ; }
Ref: 
def nswp ( n ) : NEW_LINE INDENT if n == 0 or n == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 2 * nswp ( n - 1 ) + nswp ( n - 2 ) NEW_LINE DEDENT
Hyp: 
def nswp ( n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 2 * nswp ( n - 1 ) + nswp ( n - 2 ) NEW_LINE DEDENT

BLEU: 87.91
Edit Sim: 4


Src: 
int fib ( int n ) { if ( lookup [ n ] == NIL ) { if ( n <= 1 ) lookup [ n ] = n ; else lookup [ n ] = fib ( n - 1 ) + fib ( n - 2 ) ; } return lookup [ n ] ; }
Ref: 
def fib ( n , lookup ) : NEW_LINE INDENT if n == 0 or n == 1 : NEW_LINE INDENT lookup [ n ] = n NEW_LINE DEDENT if lookup [ n ] is None : NEW_LINE INDENT lookup [ n ] = fib ( n - 1 , lookup ) + fib ( n - 2 , lookup ) NEW_LINE DEDENT return lookup [ n ] NEW_LINE DEDENT
Hyp: 
def fib ( n ) : NEW_LINE INDENT if ( lookup [ n ] == NIL ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT lookup [ n ] = n NEW_LINE DEDENT else : NEW_LINE INDENT lookup [ n ] = fib ( n - 1 ) + fib ( n - 2 ) NEW_LINE DEDENT DEDENT return lookup [ n ] NEW_LINE DEDENT

BLEU: 62.79
Edit Sim: 87


Src: 
int countNums ( int n , int x , int y ) { vector < bool > arr ( n + 1 , false ) ; if ( x <= n ) arr [ x ] = true ; if ( y <= n ) arr [ y ] = true ; int result = 0 ; for ( int i = min ( x , y ) ; i <= n ; i ++ ) { if ( arr [ i ] ) { if ( i + x <= n ) arr [ i + x ] = true ; if ( i + y <= n ) arr [ i + y ] = true ; result ++ ; } } return result ; }
Ref: 
def countNums ( n , x , y ) : NEW_LINE INDENT arr = [ False for i in range ( n + 2 ) ] NEW_LINE if ( x <= n ) : NEW_LINE INDENT arr [ x ] = True NEW_LINE DEDENT if ( y <= n ) : NEW_LINE INDENT arr [ y ] = True NEW_LINE DEDENT result = 0 NEW_LINE for i in range ( min ( x , y ) , n + 1 ) : NEW_LINE INDENT if ( arr [ i ] ) : NEW_LINE INDENT if ( i + x <= n ) : NEW_LINE INDENT arr [ i + x ] = True NEW_LINE DEDENT if ( i + y <= n ) : NEW_LINE INDENT arr [ i + y ] = True NEW_LINE DEDENT result = result + 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
Hyp: 
def countNums ( n , x , y ) : NEW_LINE INDENT arr = [ False ] * ( n + 1 ) NEW_LINE if x <= n : NEW_LINE INDENT arr [ x ] = True NEW_LINE DEDENT if y <= n : NEW_LINE INDENT arr [ y ] = True NEW_LINE DEDENT result = 0 NEW_LINE for i in range ( min ( x , y ) + 1 , n + 1 ) : NEW_LINE INDENT if arr [ i ] == True : NEW_LINE INDENT if i + x <= n : NEW_LINE INDENT arr [ i + x ] = True NEW_LINE DEDENT if i + y <= n : NEW_LINE INDENT arr [ i + y ] = True NEW_LINE DEDENT result += 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT

BLEU: 71.88
Edit Sim: 55


Src: 
int countPS ( string str ) { int N = str . length ( ) ; int cps [ N + 1 ] [ N + 1 ] ; memset ( cps , 0 , sizeof ( cps ) ) ; for ( int i = 0 ; i < N ; i ++ ) cps [ i ] [ i ] = 1 ; for ( int L = 2 ; L <= N ; L ++ ) { for ( int i = 0 ; i < N ; i ++ ) { int k = L + i - 1 ; if ( str [ i ] == str [ k ] ) cps [ i ] [ k ] = cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] + 1 ; else cps [ i ] [ k ] = cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] - cps [ i + 1 ] [ k - 1 ] ; } } return cps [ 0 ] [ N - 1 ] ; }
Ref: 
def countPS ( str ) : NEW_LINE INDENT N = len ( str ) NEW_LINE cps = [ [ 0 for i in range ( N + 2 ) ] for j in range ( N + 2 ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT cps [ i ] [ i ] = 1 NEW_LINE DEDENT for L in range ( 2 , N + 1 ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT k = L + i - 1 NEW_LINE if ( k < N ) : NEW_LINE INDENT if ( str [ i ] == str [ k ] ) : NEW_LINE INDENT cps [ i ] [ k ] = ( cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT cps [ i ] [ k ] = ( cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] - cps [ i + 1 ] [ k - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return cps [ 0 ] [ N - 1 ] NEW_LINE DEDENT
Hyp: 
def countPS ( str ) : NEW_LINE INDENT N = len ( str ) NEW_LINE cps = [ [ 0 for x in range ( N + 1 ) ] for y in range ( N + 1 ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT cps [ i ] [ i ] = 1 NEW_LINE DEDENT for L in range ( 2 , N + 1 ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT k = L + i - 1 NEW_LINE if ( str [ i ] == str [ k ] ) : NEW_LINE INDENT cps [ i ] [ k ] = cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT cps [ i ] [ k ] = cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] - cps [ i + 1 ] [ k - 1 ] NEW_LINE DEDENT DEDENT DEDENT return cps [ 0 ] [ N - 1 ] NEW_LINE DEDENT

BLEU: 85.67
Edit Sim: 50


Src: 
string decimalToBinary ( double num , int k_prec ) { string binary = " " ; int Integral = num ; double fractional = num - Integral ; while ( Integral ) { int rem = Integral % 2 ; binary . push_back ( rem + '0' ) ; Integral /= 2 ; } reverse ( binary . begin ( ) , binary . end ( ) ) ; binary . push_back ( ' . ' ) ; while ( k_prec -- ) { fractional *= 2 ; int fract_bit = fractional ; if ( fract_bit == 1 ) { fractional -= fract_bit ; binary . push_back ( 1 + '0' ) ; } else binary . push_back ( 0 + '0' ) ; } return binary ; }
Ref: 
def decimalToBinary ( num , k_prec ) : NEW_LINE INDENT binary = " " NEW_LINE Integral = int ( num ) NEW_LINE fractional = num - Integral NEW_LINE while ( Integral ) : NEW_LINE INDENT rem = Integral % 2 NEW_LINE binary += str ( rem ) NEW_LINE Integral //= 2 NEW_LINE DEDENT binary = binary [ : : - 1 ] NEW_LINE binary += ' . ' NEW_LINE while ( k_prec ) : NEW_LINE INDENT fractional *= 2 NEW_LINE fract_bit = int ( fractional ) NEW_LINE if ( fract_bit == 1 ) : NEW_LINE INDENT fractional -= fract_bit NEW_LINE binary += '1' NEW_LINE DEDENT else : NEW_LINE INDENT binary += '0' NEW_LINE DEDENT k_prec -= 1 NEW_LINE DEDENT return binary NEW_LINE DEDENT
Hyp: 
def decimalToBinary ( num , k_prec ) : NEW_LINE INDENT binary = " " NEW_LINE Integral = num NEW_LINE fractional = num - Integral NEW_LINE while ( Integral ) : NEW_LINE INDENT rem = Integral % 2 NEW_LINE binary . append ( rem + '0' ) NEW_LINE Integral /= 2 NEW_LINE DEDENT binary . reverse ( ) NEW_LINE binary . append ( ' . ' ) NEW_LINE while ( k_prec -= 1 ) : NEW_LINE INDENT fractional *= 2 NEW_LINE fract_bit = fractional NEW_LINE if ( fract_bit == 1 ) : NEW_LINE INDENT fractional -= fract_bit NEW_LINE binary . append ( 1 + '0' ) NEW_LINE DEDENT else : NEW_LINE INDENT binary . append ( 0 + '0' ) NEW_LINE DEDENT DEDENT return binary NEW_LINE DEDENT

BLEU: 63.09
Edit Sim: 118


Src: 
int countParenth ( char symb [ ] , char oper [ ] , int n ) { int F [ n ] [ n ] , T [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { F [ i ] [ i ] = ( symb [ i ] == ' F ' ) ? 1 : 0 ; T [ i ] [ i ] = ( symb [ i ] == ' T ' ) ? 1 : 0 ; } for ( int gap = 1 ; gap < n ; ++ gap ) { for ( int i = 0 , j = gap ; j < n ; ++ i , ++ j ) { T [ i ] [ j ] = F [ i ] [ j ] = 0 ; for ( int g = 0 ; g < gap ; g ++ ) { int k = i + g ; int tik = T [ i ] [ k ] + F [ i ] [ k ] ; int tkj = T [ k + 1 ] [ j ] + F [ k + 1 ] [ j ] ; if ( oper [ k ] == ' & ' ) { T [ i ] [ j ] += T [ i ] [ k ] * T [ k + 1 ] [ j ] ; F [ i ] [ j ] += ( tik * tkj - T [ i ] [ k ] * T [ k + 1 ] [ j ] ) ; } if ( oper [ k ] == ' | ' ) { F [ i ] [ j ] += F [ i ] [ k ] * F [ k + 1 ] [ j ] ; T [ i ] [ j ] += ( tik * tkj - F [ i ] [ k ] * F [ k + 1 ] [ j ] ) ; } if ( oper [ k ] == ' ^ ' ) { T [ i ] [ j ] += F [ i ] [ k ] * T [ k + 1 ] [ j ] + T [ i ] [ k ] * F [ k + 1 ] [ j ] ; F [ i ] [ j ] += T [ i ] [ k ] * T [ k + 1 ] [ j ] + F [ i ] [ k ] * F [ k + 1 ] [ j ] ; } } } } return T [ 0 ] [ n - 1 ] ; }
Ref: 
def countParenth ( symb , oper , n ) : NEW_LINE INDENT F = [ [ 0 for i in range ( n + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE T = [ [ 0 for i in range ( n + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if symb [ i ] == ' F ' : NEW_LINE INDENT F [ i ] [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT F [ i ] [ i ] = 0 NEW_LINE DEDENT if symb [ i ] == ' T ' : NEW_LINE INDENT T [ i ] [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT T [ i ] [ i ] = 0 NEW_LINE DEDENT DEDENT for gap in range ( 1 , n ) : NEW_LINE INDENT i = 0 NEW_LINE for j in range ( gap , n ) : NEW_LINE INDENT T [ i ] [ j ] = F [ i ] [ j ] = 0 NEW_LINE for g in range ( gap ) : NEW_LINE INDENT k = i + g NEW_LINE tik = T [ i ] [ k ] + F [ i ] [ k ] NEW_LINE tkj = T [ k + 1 ] [ j ] + F [ k + 1 ] [ j ] NEW_LINE if oper [ k ] == ' & ' : NEW_LINE INDENT T [ i ] [ j ] += T [ i ] [ k ] * T [ k + 1 ] [ j ] NEW_LINE F [ i ] [ j ] += ( tik * tkj - T [ i ] [ k ] * T [ k + 1 ] [ j ] ) NEW_LINE DEDENT if oper [ k ] == ' | ' : NEW_LINE INDENT F [ i ] [ j ] += F [ i ] [ k ] * F [ k + 1 ] [ j ] NEW_LINE T [ i ] [ j ] += ( tik * tkj - F [ i ] [ k ] * F [ k + 1 ] [ j ] ) NEW_LINE DEDENT if oper [ k ] == ' ^ ' : NEW_LINE INDENT T [ i ] [ j ] += ( F [ i ] [ k ] * T [ k + 1 ] [ j ] + T [ i ] [ k ] * F [ k + 1 ] [ j ] ) NEW_LINE F [ i ] [ j ] += ( T [ i ] [ k ] * T [ k + 1 ] [ j ] + F [ i ] [ k ] * F [ k + 1 ] [ j ] ) NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT DEDENT return T [ 0 ] [ n - 1 ] NEW_LINE DEDENT
Hyp: 
def countParenth ( symb , oper , n ) : NEW_LINE INDENT F = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] NEW_LINE T = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT F [ i ] [ i ] = 1 NEW_LINE if ( symb [ i ] == ' F ' ) : NEW_LINE INDENT T [ i ] [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT T [ i ] [ i ] = 0 NEW_LINE DEDENT for gap in range ( 1 , n ) : NEW_LINE INDENT for i in range ( gap , n ) : NEW_LINE INDENT T [ i ] [ j ] = F [ i ] [ j ] = 0 NEW_LINE for g in range ( gap , n ) : NEW_LINE INDENT k = i + g NEW_LINE tik = T [ i ] [ k ] + F [ i ] [ k ] NEW_LINE tkj = T [ k + 1 ] [ j ] + F [ k + 1 ] [ j ] NEW_LINE if ( oper [ k ] == ' & ' ) : NEW_LINE INDENT T [ i ] [ j ] += T [ i ] [ k ] * T [ k + 1 ] [ j ] NEW_LINE F [ i ] [ j ] += ( tik * tkj - T [ i ] [ k ] * T [ k + 1 ] [ j ] ) NEW_LINE DEDENT if ( oper [ k ] == ' | ' ) : NEW_LINE INDENT F [ i ] [ j ] += F [ i ] [ k ] * F [ k + 1 ] [ j ] NEW_LINE T [ i ] [ j ] += ( tik * tkj - F [ i ] [ k ] * F [ k + 1 ] [ j ] ) NEW_LINE DEDENT DEDENT if ( oper [ k ] == ' ^ ' ) : NEW_LINE INDENT T [ i ] [ j ] += F [ i ] [ k ] * T [ k + 1 ] [ j ] + T [ i ] [ k ] * F [ k + 1 ] [ j ] NEW_LINE F [ i ] [ j ] += T [ i ] [ k ] * F [ k + 1 ] [ j ] )

BLEU: 77.94
Edit Sim: 307


Src: 
int countSetBits ( int n ) { if ( n == 0 ) return 0 ; else return ( n & 1 ) + countSetBits ( n >> 1 ) ; }
Ref: 
def countSetBits ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return ( n & 1 ) + countSetBits ( n >> 1 ) NEW_LINE DEDENT DEDENT
Hyp: 
def countSetBits ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return ( n & 1 ) + countSetBits ( n >> 1 ) NEW_LINE DEDENT DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int longestCommonSum ( bool arr1 [ ] , bool arr2 [ ] , int n ) { int maxLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int sum1 = 0 , sum2 = 0 ; for ( int j = i ; j < n ; j ++ ) { sum1 += arr1 [ j ] ; sum2 += arr2 [ j ] ; if ( sum1 == sum2 ) { int len = j - i + 1 ; if ( len > maxLen ) maxLen = len ; } } } return maxLen ; }
Ref: 
def longestCommonSum ( arr1 , arr2 , n ) : NEW_LINE INDENT maxLen = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum1 = 0 NEW_LINE sum2 = 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT sum1 += arr1 [ j ] NEW_LINE sum2 += arr2 [ j ] NEW_LINE if ( sum1 == sum2 ) : NEW_LINE INDENT len = j - i + 1 NEW_LINE if ( len > maxLen ) : NEW_LINE INDENT maxLen = len NEW_LINE DEDENT DEDENT DEDENT DEDENT return maxLen NEW_LINE DEDENT
Hyp: 
def longestCommonSum ( arr1 , arr2 , n ) : NEW_LINE INDENT maxLen = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum1 = 0 NEW_LINE sum2 = 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT sum1 += arr1 [ j ] NEW_LINE sum2 += arr2 [ j ] NEW_LINE if ( sum1 == sum2 ) : NEW_LINE INDENT length = j - i + 1 NEW_LINE if ( length > maxLen ) : NEW_LINE INDENT maxLen = length NEW_LINE DEDENT DEDENT DEDENT DEDENT return maxLen NEW_LINE DEDENT

BLEU: 92.36
Edit Sim: 9


Src: 
int maxTripletSum ( int arr [ ] , int n ) { int sum = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) for ( int k = j + 1 ; k < n ; k ++ ) if ( sum < arr [ i ] + arr [ j ] + arr [ k ] ) sum = arr [ i ] + arr [ j ] + arr [ k ] ; return sum ; }
Ref: 
def maxTripletSum ( arr , n ) : NEW_LINE INDENT sm = - 1000000 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT if ( sm < ( arr [ i ] + arr [ j ] + arr [ k ] ) ) : NEW_LINE INDENT sm = arr [ i ] + arr [ j ] + arr [ k ] NEW_LINE DEDENT DEDENT DEDENT DEDENT return sm NEW_LINE DEDENT
Hyp: 
def maxTripletSum ( arr , n ) : NEW_LINE INDENT sum = - sys . maxsize - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT if ( sum < arr [ i ] + arr [ j ] + arr [ k ] ) : NEW_LINE INDENT sum = arr [ i ] + arr [ j ] + arr [ k ] NEW_LINE DEDENT DEDENT DEDENT return sum NEW_LINE DEDENT

BLEU: 82.98
Edit Sim: 32


Src: 
int evaluateBoolExpr ( string s ) { int n = s . length ( ) ; for ( int i = 0 ; i < n ; i += 2 ) { if ( s [ i + 1 ] == ' A ' ) { if ( s [ i + 2 ] == '0' || s [ i ] == '0' ) s [ i + 2 ] = '0' ; else s [ i + 2 ] = '1' ; } else if ( s [ i + 1 ] == ' B ' ) { if ( s [ i + 2 ] == '1' || s [ i ] == '1' ) s [ i + 2 ] = '1' ; else s [ i + 2 ] = '0' ; } else { if ( s [ i + 2 ] == s [ i ] ) s [ i + 2 ] = '0' ; else s [ i + 2 ] = '1' ; } } return s [ n - 1 ] - '0' ; }
Ref: 
def evaluateBoolExpr ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE for i in range ( 0 , n - 2 , 2 ) : NEW_LINE INDENT if ( s [ i + 1 ] == " A " ) : NEW_LINE INDENT if ( s [ i + 2 ] == "0" or s [ i ] == "0" ) : NEW_LINE INDENT s [ i + 2 ] = "0" NEW_LINE DEDENT else : NEW_LINE INDENT s [ i + 2 ] = "1" NEW_LINE DEDENT DEDENT elif ( s [ i + 1 ] == " B " ) : NEW_LINE INDENT if ( s [ i + 2 ] == "1" or s [ i ] == "1" ) : NEW_LINE INDENT s [ i + 2 ] = "1" NEW_LINE DEDENT else : NEW_LINE INDENT s [ i + 2 ] = "0" NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( s [ i + 2 ] == s [ i ] ) : NEW_LINE INDENT s [ i + 2 ] = "0" NEW_LINE DEDENT else : NEW_LINE INDENT s [ i + 2 ] = "1" NEW_LINE DEDENT DEDENT DEDENT return ord ( s [ n - 1 ] ) - ord ( "0" ) NEW_LINE DEDENT
Hyp: 
def evaluateBoolExpr ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE for i in range ( 0 , n , 2 ) : NEW_LINE INDENT if ( s [ i + 1 ] == ' A ' ) : NEW_LINE INDENT if ( s [ i + 2 ] == '0' or s [ i ] == '0' ) : NEW_LINE INDENT s [ i + 2 ] = '0' NEW_LINE DEDENT else : NEW_LINE INDENT s [ i + 2 ] = '1' NEW_LINE DEDENT DEDENT elif ( s [ i + 1 ] == ' B ' ) : NEW_LINE INDENT if ( s [ i + 2 ] == '1' or s [ i ] == '1' ) : NEW_LINE INDENT s [ i + 2 ] = '1' NEW_LINE DEDENT else : NEW_LINE INDENT s [ i + 2 ] = '0' NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( s [ i + 2 ] == s [ i ] ) : NEW_LINE INDENT s [ i + 2 ] = '0' NEW_LINE DEDENT else : NEW_LINE INDENT s [ i + 2 ] = '1' NEW_LINE DEDENT DEDENT DEDENT return s [ n - 1 ] - '0' NEW_LINE DEDENT

BLEU: 77.75
Edit Sim: 46


Src: 
int findNth ( int n ) { int nthElement = 19 + ( n - 1 ) * 9 ; int outliersCount = ( int ) log10 ( nthElement ) - 1 ; nthElement += 9 * outliersCount ; return nthElement ; }
Ref: 
def findNth ( n ) : NEW_LINE INDENT nthElement = 19 + ( n - 1 ) * 9 NEW_LINE outliersCount = int ( math . log10 ( nthElement ) ) - 1 NEW_LINE nthElement += 9 * outliersCount NEW_LINE return nthElement NEW_LINE DEDENT
Hyp: 
def findNth ( n ) : NEW_LINE INDENT nthElement = 19 + ( n - 1 ) * 9 NEW_LINE outliersCount = ( int ) ( math . log10 ( nthElement ) - 1 ) NEW_LINE nthElement += 9 * outliersCount NEW_LINE return nthElement NEW_LINE DEDENT

BLEU: 83.43
Edit Sim: 7


Src: 
int numofAP ( int a [ ] , int n ) { int minarr = INT_MAX , maxarr = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { minarr = min ( minarr , a [ i ] ) ; maxarr = max ( maxarr , a [ i ] ) ; } int dp [ n ] , sum [ MAX ] ; int ans = n + 1 ; for ( int d = ( minarr - maxarr ) ; d <= ( maxarr - minarr ) ; d ++ ) { memset ( sum , 0 , sizeof sum ) ; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] = 1 ; if ( a [ i ] - d >= 1 && a [ i ] - d <= 1000000 ) dp [ i ] += sum [ a [ i ] - d ] ; ans += dp [ i ] - 1 ; sum [ a [ i ] ] += dp [ i ] ; } } return ans ; }
Ref: 
def numofAP ( a , n ) : NEW_LINE INDENT minarr = + 2147483647 NEW_LINE maxarr = - 2147483648 NEW_LINE for i in range ( n ) : NEW_LINE INDENT minarr = min ( minarr , a [ i ] ) NEW_LINE maxarr = max ( maxarr , a [ i ] ) NEW_LINE DEDENT dp = [ 0 for i in range ( n + 1 ) ] NEW_LINE ans = n + 1 NEW_LINE for d in range ( ( minarr - maxarr ) , ( maxarr - minarr ) + 1 ) : NEW_LINE INDENT sum = [ 0 for i in range ( MAX + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp [ i ] = 1 NEW_LINE if ( a [ i ] - d >= 1 and a [ i ] - d <= 1000000 ) : NEW_LINE INDENT dp [ i ] += sum [ a [ i ] - d ] NEW_LINE DEDENT ans += dp [ i ] - 1 NEW_LINE sum [ a [ i ] ] += dp [ i ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
Hyp: 
def numofAP ( a , n ) : NEW_LINE INDENT minarr = 2147483647 NEW_LINE maxarr = 2147483647 NEW_LINE for i in range ( n ) : NEW_LINE INDENT minarr = min ( minarr , a [ i ] ) NEW_LINE maxarr = max ( maxarr , a [ i ] ) NEW_LINE DEDENT dp = [ 0 for i in range ( n ) ] NEW_LINE sum = [ 0 for i in range ( maxarr - minarr ) ] NEW_LINE ans = n + 1 NEW_LINE for d in range ( ( minarr - maxarr ) , ( maxarr - minarr ) + 1 ) : NEW_LINE INDENT sum [ i ] = a [ i ] - d NEW_LINE if ( a [ i ] - d >= 1 and a [ i ] - d <= 1000000 ) : NEW_LINE INDENT dp [ i ] += sum [ a [ i ] - d ] NEW_LINE DEDENT ans += dp [ i ] - 1 NEW_LINE sum [ a [ i ] ] += dp [ i ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT

BLEU: 85.29
Edit Sim: 120


Src: 
int countSol ( int coeff [ ] , int start , int end , int rhs ) { if ( rhs == 0 ) return 1 ; int result = 0 ; for ( int i = start ; i <= end ; i ++ ) if ( coeff [ i ] <= rhs ) result += countSol ( coeff , i , end , rhs - coeff [ i ] ) ; return result ; }
Ref: 
def countSol ( coeff , start , end , rhs ) : NEW_LINE INDENT if ( rhs == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT result = 0 NEW_LINE for i in range ( start , end + 1 ) : NEW_LINE INDENT if ( coeff [ i ] <= rhs ) : NEW_LINE INDENT result += countSol ( coeff , i , end , rhs - coeff [ i ] ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
Hyp: 
def countSol ( coeff , start , end , rhs ) : NEW_LINE INDENT if ( rhs == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT result = 0 NEW_LINE for i in range ( start , end + 1 ) : NEW_LINE INDENT if ( coeff [ i ] <= rhs ) : NEW_LINE INDENT result += countSol ( coeff , i , end , rhs - coeff [ i ] ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int minSwaps ( int arr [ ] , int n ) { pair < int , int > arrPos [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arrPos [ i ] . first = arr [ i ] ; arrPos [ i ] . second = i ; } sort ( arrPos , arrPos + n ) ; vector < bool > vis ( n , false ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( vis [ i ] || arrPos [ i ] . second == i ) continue ; int cycle_size = 0 ; int j = i ; while ( ! vis [ j ] ) { vis [ j ] = 1 ; j = arrPos [ j ] . second ; cycle_size ++ ; } if ( cycle_size > 0 ) { ans += ( cycle_size - 1 ) ; } } return ans ; }
Ref: 
def minSwaps ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE arrpos = [ * enumerate ( arr ) ] NEW_LINE arrpos . sort ( key = lambda it : it [ 1 ] ) NEW_LINE vis = { k : False for k in range ( n ) } NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if vis [ i ] or arrpos [ i ] [ 0 ] == i : NEW_LINE INDENT continue NEW_LINE DEDENT cycle_size = 0 NEW_LINE j = i NEW_LINE while not vis [ j ] : NEW_LINE INDENT vis [ j ] = True NEW_LINE j = arrpos [ j ] [ 0 ] NEW_LINE cycle_size += 1 NEW_LINE DEDENT if cycle_size > 0 : NEW_LINE INDENT ans += ( cycle_size - 1 ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
Hyp: 
def minSwaps ( arr , n ) : NEW_LINE INDENT arrPos = [ None ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT arrPos [ i ] . first = arr [ i ] NEW_LINE arrPos [ i ] . second = i NEW_LINE DEDENT arrPos . sort ( ) NEW_LINE vis = [ False ] * ( n + 1 ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( vis [ i ] or arrPos [ i ] . second == i ) : NEW_LINE INDENT continue NEW_LINE DEDENT cycle_size = 0 NEW_LINE j = i NEW_LINE while ( vis [ j ] == 0 ) : NEW_LINE INDENT vis [ j ] = 1 NEW_LINE j = arrPos [ j ] . second NEW_LINE cycle_size += 1 NEW_LINE DEDENT if ( cycle_size > 0 ) : NEW_LINE INDENT ans += ( cycle_size - 1 ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT

BLEU: 50.61
Edit Sim: 165


Src: 
void spiralFill ( int m , int n , int a [ ] [ MAX ] ) { int val = 1 ; int k = 0 , l = 0 ; while ( k < m && l < n ) { for ( int i = l ; i < n ; ++ i ) a [ k ] [ i ] = val ++ ; k ++ ; for ( int i = k ; i < m ; ++ i ) a [ i ] [ n - 1 ] = val ++ ; n -- ; if ( k < m ) { for ( int i = n - 1 ; i >= l ; -- i ) a [ m - 1 ] [ i ] = val ++ ; m -- ; } if ( l < n ) { for ( int i = m - 1 ; i >= k ; -- i ) a [ i ] [ l ] = val ++ ; l ++ ; } } }
Ref: 
def spiralFill ( m , n , a ) : NEW_LINE INDENT val = 1 NEW_LINE k , l = 0 , 0 NEW_LINE while ( k < m and l < n ) : NEW_LINE INDENT for i in range ( l , n ) : NEW_LINE INDENT a [ k ] [ i ] = val NEW_LINE val += 1 NEW_LINE DEDENT k += 1 NEW_LINE for i in range ( k , m ) : NEW_LINE INDENT a [ i ] [ n - 1 ] = val NEW_LINE val += 1 NEW_LINE DEDENT n -= 1 NEW_LINE if ( k < m ) : NEW_LINE INDENT for i in range ( n - 1 , l - 1 , - 1 ) : NEW_LINE INDENT a [ m - 1 ] [ i ] = val NEW_LINE val += 1 NEW_LINE DEDENT m -= 1 NEW_LINE DEDENT if ( l < n ) : NEW_LINE INDENT for i in range ( m - 1 , k - 1 , - 1 ) : NEW_LINE INDENT a [ i ] [ l ] = val NEW_LINE val += 1 NEW_LINE DEDENT l += 1 NEW_LINE DEDENT DEDENT DEDENT
Hyp: 
def spiralFill ( m , n , a ) : NEW_LINE INDENT val = 1 NEW_LINE k = 0 l = 0 NEW_LINE while ( k < m and l < n ) : NEW_LINE INDENT for i in range ( l , n ) : NEW_LINE INDENT a [ k ] [ i ] = val += 1 NEW_LINE DEDENT k += 1 NEW_LINE for i in range ( k , m ) : NEW_LINE INDENT a [ i ] [ n - 1 ] = val += 1 NEW_LINE DEDENT n -= 1 NEW_LINE if ( k < m ) : NEW_LINE INDENT for i in range ( n - 1 , l - 1 , - 1 ) : NEW_LINE INDENT a [ m - 1 ] [ i ] = val += 1 NEW_LINE DEDENT m -= 1 NEW_LINE DEDENT if ( l < n ) : NEW_LINE INDENT for i in range ( m - 1 , k - 1 , - 1 ) : NEW_LINE INDENT a [ i ] [ l ] = val += 1 NEW_LINE DEDENT l += 1 NEW_LINE DEDENT DEDENT DEDENT

BLEU: 91.88
Edit Sim: 58


Src: 
void printClosest ( int ar1 [ ] , int ar2 [ ] , int m , int n , int x ) { int diff = INT_MAX ; int res_l , res_r ; int l = 0 , r = n - 1 ; while ( l < m && r >= 0 ) { if ( abs ( ar1 [ l ] + ar2 [ r ] - x ) < diff ) { res_l = l ; res_r = r ; diff = abs ( ar1 [ l ] + ar2 [ r ] - x ) ; } if ( ar1 [ l ] + ar2 [ r ] > x ) r -- ; else l ++ ; } cout << " The ▁ closest ▁ pair ▁ is ▁ [ " << ar1 [ res_l ] << " , ▁ " << ar2 [ res_r ] << " ] ▁ \n " ; }
Ref: 
def printClosest ( ar1 , ar2 , m , n , x ) : NEW_LINE INDENT diff = sys . maxsize NEW_LINE l = 0 NEW_LINE r = n - 1 NEW_LINE while ( l < m and r >= 0 ) : NEW_LINE INDENT if abs ( ar1 [ l ] + ar2 [ r ] - x ) < diff : NEW_LINE INDENT res_l = l NEW_LINE res_r = r NEW_LINE diff = abs ( ar1 [ l ] + ar2 [ r ] - x ) NEW_LINE DEDENT if ar1 [ l ] + ar2 [ r ] > x : NEW_LINE INDENT r = r - 1 NEW_LINE DEDENT else : NEW_LINE INDENT l = l + 1 NEW_LINE DEDENT DEDENT print ( " The ▁ closest ▁ pair ▁ is ▁ [ " , ar1 [ res_l ] , " , " , ar2 [ res_r ] , " ] " ) NEW_LINE DEDENT
Hyp: 
def printClosest ( ar1 , ar2 , m , n , x ) : NEW_LINE INDENT diff = sys . maxsize NEW_LINE res_l = res_r = 0 NEW_LINE l = 0 NEW_LINE r = n - 1 NEW_LINE while ( l < m and r >= 0 ) : NEW_LINE INDENT if ( abs ( ar1 [ l ] + ar2 [ r ] - x ) < diff ) : NEW_LINE INDENT res_l = l NEW_LINE res_r = r NEW_LINE diff = abs ( ar1 [ l ] + ar2 [ r ] - x ) NEW_LINE DEDENT if ( ar1 [ l ] + ar2 [ r ] > x ) : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT l += 1 NEW_LINE DEDENT DEDENT print ( " The ▁ closest ▁ pair ▁ is ▁ [ " , ar1 [ res_l ] , " , ▁ " , ar2 [ res_r ] , " ] " , sep = " " ) NEW_LINE DEDENT

BLEU: 82.44
Edit Sim: 59


Src: 
int minimumBox ( int arr [ ] , int n ) { queue < int > q ; sort ( arr , arr + n ) ; q . push ( arr [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { int now = q . front ( ) ; if ( arr [ i ] >= 2 * now ) q . pop ( ) ; q . push ( arr [ i ] ) ; } return q . size ( ) ; }
Ref: 
def minimumBox ( arr , n ) : NEW_LINE INDENT q = collections . deque ( [ ] ) NEW_LINE arr . sort ( ) NEW_LINE q . append ( arr [ 0 ] ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT now = q [ 0 ] NEW_LINE if ( arr [ i ] >= 2 * now ) : NEW_LINE INDENT q . popleft ( ) NEW_LINE DEDENT q . append ( arr [ i ] ) NEW_LINE DEDENT return len ( q ) NEW_LINE DEDENT
Hyp: 
def minimumBox ( arr , n ) : NEW_LINE INDENT q = Queue ( ) NEW_LINE arr . sort ( ) NEW_LINE q . put ( arr [ 0 ] ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT now = q . get ( ) NEW_LINE if arr [ i ] >= 2 * now : NEW_LINE INDENT q . get ( ) NEW_LINE DEDENT q . put ( arr [ i ] ) NEW_LINE DEDENT return len ( q ) NEW_LINE DEDENT

BLEU: 74.3
Edit Sim: 46


Src: 
int findInteger ( int arr [ ] , int n ) { unordered_map < int , int > hash ; int maximum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < 0 ) hash [ abs ( arr [ i ] ) ] -= 1 ; else hash [ arr [ i ] ] += 1 ; } for ( int i = 0 ; i < n ; i ++ ) if ( hash [ arr [ i ] ] != 0 ) return arr [ i ] ; return - 1 ; }
Ref: 
def findInteger ( arr , n ) : NEW_LINE INDENT hash = dict ( ) NEW_LINE maximum = 0 NEW_LINE for i in arr : NEW_LINE INDENT if ( i < 0 ) : NEW_LINE INDENT if abs ( i ) not in hash . keys ( ) : NEW_LINE INDENT hash [ abs ( i ) ] = - 1 NEW_LINE DEDENT else : NEW_LINE INDENT hash [ abs ( i ) ] -= 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT hash [ i ] = hash . get ( i , 0 ) + 1 NEW_LINE DEDENT DEDENT for i in arr : NEW_LINE INDENT if i in hash . keys ( ) and hash [ i ] > 0 : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
Hyp: 
def findInteger ( arr , n ) : NEW_LINE INDENT Hash = dict ( ) NEW_LINE maximum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] < 0 ) : NEW_LINE INDENT hash [ abs ( arr [ i ] ) ] -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT hash [ arr [ i ] ] += 1 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( Hash [ arr [ i ] ] != 0 ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT

BLEU: 46.67
Edit Sim: 183


Src: 
void convertOpposite ( string & str ) { int ln = str . length ( ) ; for ( int i = 0 ; i < ln ; i ++ ) { if ( str [ i ] >= ' a ' && str [ i ] <= ' z ' ) str [ i ] = str [ i ] - 32 ; else if ( str [ i ] >= ' A ' && str [ i ] <= ' Z ' ) str [ i ] = str [ i ] + 32 ; } }
Ref: 
def convertOpposite ( str ) : NEW_LINE INDENT ln = len ( str ) NEW_LINE for i in range ( ln ) : NEW_LINE INDENT if str [ i ] >= ' a ' and str [ i ] <= ' z ' : NEW_LINE INDENT str [ i ] = chr ( ord ( str [ i ] ) - 32 ) NEW_LINE DEDENT elif str [ i ] >= ' A ' and str [ i ] <= ' Z ' : NEW_LINE INDENT str [ i ] = chr ( ord ( str [ i ] ) + 32 ) NEW_LINE DEDENT DEDENT DEDENT
Hyp: 
def convertOpposite ( str ) : NEW_LINE INDENT ln = len ( str ) NEW_LINE for i in range ( ln ) : NEW_LINE INDENT if ( str [ i ] >= ' a ' and str [ i ] <= ' z ' ) : NEW_LINE INDENT str [ i ] = str [ i ] - 32 NEW_LINE DEDENT elif ( str [ i ] >= ' A ' and str [ i ] <= ' Z ' ) : NEW_LINE INDENT str [ i ] = str [ i ] + 32 NEW_LINE DEDENT DEDENT DEDENT

BLEU: 76.4
Edit Sim: 40


Src: 
unsigned long long int int decimalToBinary ( int N ) { ull B_Number = 0 ; int cnt = 0 ; while ( N != 0 ) { int rem = N % 2 ; ull c = pow ( 10 , cnt ) ; B_Number += rem * c ; N /= 2 ; cnt ++ ; } return B_Number ; }
Ref: 
def decimalToBinary ( N ) : NEW_LINE INDENT B_Number = 0 NEW_LINE cnt = 0 NEW_LINE while ( N != 0 ) : NEW_LINE INDENT rem = N % 2 NEW_LINE c = pow ( 10 , cnt ) NEW_LINE B_Number += rem * c NEW_LINE N //= 2 NEW_LINE cnt += 1 NEW_LINE DEDENT return B_Number NEW_LINE DEDENT
Hyp: 
def decimalToBinary ( N ) : NEW_LINE INDENT B_Number = 0 NEW_LINE cnt = 0 NEW_LINE while ( N != 0 ) : NEW_LINE INDENT rem = N % 2 NEW_LINE c = pow ( 10 , cnt ) NEW_LINE B_Number += rem * c NEW_LINE N /= 2 NEW_LINE cnt += 1 NEW_LINE DEDENT return B_Number NEW_LINE DEDENT

BLEU: 95.67
Edit Sim: 1


Src: 
int findRepeating ( int arr [ ] , int n ) { unordered_set < int > s ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . find ( arr [ i ] ) != s . end ( ) ) return arr [ i ] ; s . insert ( arr [ i ] ) ; } return - 1 ; }
Ref: 
def findRepeating ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] in s : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT s . add ( arr [ i ] ) NEW_LINE DEDENT rteurn - 1 NEW_LINE DEDENT
Hyp: 
def findRepeating ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] not in s : NEW_LINE INDENT s . add ( arr [ i ] ) NEW_LINE DEDENT DEDENT for i in s : NEW_LINE INDENT if arr [ i ] not in s : NEW_LINE INDENT s . add ( arr [ i ] ) NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT

BLEU: 58.74
Edit Sim: 99


Src: 
void transpose ( int A [ ] [ N ] ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = i + 1 ; j < N ; j ++ ) swap ( A [ i ] [ j ] , A [ j ] [ i ] ) ; }
Ref: 
def transpose ( A ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT A [ i ] [ j ] , A [ j ] [ i ] = A [ j ] [ i ] , A [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT
Hyp: 
def transpose ( A ) : NEW_LINE INDENT for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT t = A [ i ] [ j ] NEW_LINE A [ i ] [ j ] = t [ j ] [ i ] NEW_LINE DEDENT DEDENT DEDENT

BLEU: 75.15
Edit Sim: 28


Src: 
void findConsecutive ( int N ) { int start = 1 , end = ( N + 1 ) / 2 ; while ( start < end ) { int sum = 0 ; for ( int i = start ; i <= end ; i ++ ) { sum = sum + i ; if ( sum == N ) { for ( int j = start ; j <= i ; j ++ ) printf ( " % d ▁ " , j ) ; printf ( " \n " ) ; break ; } if ( sum > N ) break ; } sum = 0 ; start ++ ; } }
Ref: 
def findConsecutive ( N ) : NEW_LINE INDENT start = 1 NEW_LINE end = ( N + 1 ) // 2 NEW_LINE while ( start < end ) : NEW_LINE INDENT Sum = 0 NEW_LINE for i in range ( start , end + 1 ) : NEW_LINE INDENT Sum = Sum + i NEW_LINE if ( Sum == N ) : NEW_LINE INDENT for j in range ( start , i + 1 ) : NEW_LINE INDENT print ( j , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE break NEW_LINE DEDENT if ( Sum > N ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT Sum = 0 NEW_LINE start += 1 NEW_LINE DEDENT DEDENT
Hyp: 
def findConsecutive ( N ) : NEW_LINE INDENT start = 1 NEW_LINE end = int ( ( N + 1 ) / 2 ) NEW_LINE while ( start < end ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( start , end + 1 ) : NEW_LINE INDENT sum = sum + i NEW_LINE if ( sum == N ) : NEW_LINE INDENT for j in range ( start , i + 1 ) : NEW_LINE INDENT print ( ' % d ▁ ' , j ) NEW_LINE DEDENT print ( " " ) NEW_LINE break NEW_LINE DEDENT if ( sum > N ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT sum = 0 NEW_LINE start += 1 NEW_LINE DEDENT DEDENT

BLEU: 73.3
Edit Sim: 27


Src: 
void printSubsequences ( string str ) { int n = str . length ( ) ; unsigned int opsize = pow ( 2 , n - 1 ) ; for ( int counter = 0 ; counter < opsize ; counter ++ ) { for ( int j = 0 ; j < n ; j ++ ) { cout << str [ j ] ; if ( counter & ( 1 << j ) ) cout << " ▁ " ; } cout << endl ; } }
Ref: 
def printSubsequences ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE opsize = int ( pow ( 2 , n - 1 ) ) NEW_LINE for counter in range ( opsize ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT print ( str [ j ] , end = " " ) NEW_LINE if ( counter & ( 1 << j ) ) : NEW_LINE INDENT print ( " ▁ " , end = " " ) NEW_LINE DEDENT DEDENT print ( " \n " , end = " " ) NEW_LINE DEDENT DEDENT
Hyp: 
def printSubsequences ( Str ) : NEW_LINE INDENT n = len ( Str ) NEW_LINE opsize = ( int ) ( math . pow ( 2 , n - 1 ) ) NEW_LINE for counter in range ( 0 , opsize ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT print ( Str [ j ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT

BLEU: 50.36
Edit Sim: 122


Src: 
double maxArea ( double a , double b , double c , double d ) { double semiperimeter = ( a + b + c + d ) / 2 ; return sqrt ( ( semiperimeter - a ) * ( semiperimeter - b ) * ( semiperimeter - c ) * ( semiperimeter - d ) ) ; }
Ref: 
def maxArea ( a , b , c , d ) : NEW_LINE INDENT semiperimeter = ( a + b + c + d ) / 2 NEW_LINE return math . sqrt ( ( semiperimeter - a ) * ( semiperimeter - b ) * ( semiperimeter - c ) * ( semiperimeter - d ) ) NEW_LINE DEDENT
Hyp: 
def maxArea ( a , b , c , d ) : NEW_LINE INDENT semiperimeter = ( a + b + c + d ) / 2 NEW_LINE return math . sqrt ( ( semiperimeter - a ) * ( semiperimeter - b ) * ( semiperimeter - c ) * ( semiperimeter - d ) ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int Right_most_setbit ( int num ) { int pos = 1 ; for ( int i = 0 ; i < INT_SIZE ; i ++ ) { if ( ! ( num & ( 1 << i ) ) ) pos ++ ; else break ; } return pos ; }
Ref: 
def Right_most_setbit ( num ) : NEW_LINE INDENT pos = 1 NEW_LINE for i in range ( INT_SIZE ) : NEW_LINE INDENT if not ( num & ( 1 << i ) ) : NEW_LINE INDENT pos += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return pos NEW_LINE DEDENT
Hyp: 
def Right_most_setbit ( num ) : NEW_LINE INDENT pos = 1 NEW_LINE for i in range ( 0 , INT_SIZE ) : NEW_LINE INDENT if ( not ( num & ( 1 << i ) ) ) : NEW_LINE INDENT pos += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return pos NEW_LINE DEDENT

BLEU: 86.94
Edit Sim: 8


Src: 
int printRoman ( int number ) { int num [ ] = { 1 , 4 , 5 , 9 , 10 , 40 , 50 , 90 , 100 , 400 , 500 , 900 , 1000 } ; string sym [ ] = { " I " , " IV " , " V " , " IX " , " X " , " XL " , " L " , " XC " , " C " , " CD " , " D " , " CM " , " M " } ; int i = 12 ; while ( number > 0 ) { int div = number / num [ i ] ; number = number % num [ i ] ; while ( div -- ) { cout << sym [ i ] ; } i -- ; } }
Ref: 
def printRoman ( number ) : NEW_LINE INDENT num = [ 1 , 4 , 5 , 9 , 10 , 40 , 50 , 90 , 100 , 400 , 500 , 900 , 1000 ] NEW_LINE sym = [ " I " , " IV " , " V " , " IX " , " X " , " XL " , " L " , " XC " , " C " , " CD " , " D " , " CM " , " M " ] NEW_LINE i = 12 NEW_LINE while number : NEW_LINE INDENT div = number // num [ i ] NEW_LINE number %= num [ i ] NEW_LINE while div : NEW_LINE INDENT print ( sym [ i ] , end = " " ) NEW_LINE div -= 1 NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT DEDENT
Hyp: 
def printRoman ( number ) : NEW_LINE INDENT num = [ 1 , 4 , 5 , 9 , 10 , 40 , 50 , 90 , 100 , 400 , 500 , 900 , 1000 ] NEW_LINE sym = [ " I " , " IV " , " V " , " IX " , " X " , " XL " , " L " , " XC " , " C " , " CD " , " D " , " CM " , " M " ] NEW_LINE i = 12 NEW_LINE while ( number > 0 ) : NEW_LINE INDENT div = number // num [ i ] NEW_LINE number = number % num [ i ] NEW_LINE while ( div > 0 ) : NEW_LINE INDENT print ( sym [ i ] , end = " " ) NEW_LINE i -= 1 NEW_LINE DEDENT DEDENT

BLEU: 87.78
Edit Sim: 51


Src: 
bool isSubsetSum ( int set [ ] , int n , int sum ) { if ( sum == 0 ) return true ; if ( n == 0 && sum != 0 ) return false ; if ( set [ n - 1 ] > sum ) return isSubsetSum ( set , n - 1 , sum ) ; return isSubsetSum ( set , n - 1 , sum ) || isSubsetSum ( set , n - 1 , sum - set [ n - 1 ] ) ; }
Ref: 
def isSubsetSum ( set , n , sum ) : NEW_LINE INDENT if ( sum == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n == 0 and sum != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( set [ n - 1 ] > sum ) : NEW_LINE INDENT return isSubsetSum ( set , n - 1 , sum ) NEW_LINE DEDENT return isSubsetSum ( set , n - 1 , sum ) or isSubsetSum ( set , n - 1 , sum - set [ n - 1 ] ) NEW_LINE DEDENT
Hyp: 
def isSubsetSum ( set , n , sum ) : NEW_LINE INDENT if ( sum == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n == 0 and sum != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( set [ n - 1 ] > sum ) : NEW_LINE INDENT return isSubsetSum ( set , n - 1 , sum ) NEW_LINE DEDENT return isSubsetSum ( set , n - 1 , sum ) or isSubsetSum ( set , n - 1 , sum - set [ n - 1 ] ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int countDigits ( int a , int b ) { if ( a == 0 || b == 0 ) return 1 ; return floor ( log10 ( abs ( a ) ) + log10 ( abs ( b ) ) ) + 1 ; }
Ref: 
def countDigits ( a , b ) : NEW_LINE INDENT if ( a == 0 or b == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return math . floor ( math . log10 ( abs ( a ) ) + math . log10 ( abs ( b ) ) ) + 1 NEW_LINE DEDENT
Hyp: 
def countDigits ( a , b ) : NEW_LINE INDENT if a == 0 or b == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT return math . floor ( math . log10 ( abs ( a ) ) + math . log10 ( abs ( b ) ) ) + 1 NEW_LINE DEDENT

BLEU: 90.78
Edit Sim: 4


Src: 
int countWays ( int n ) { int table [ n + 1 ] ; memset ( table , 0 , sizeof ( table ) ) ; table [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) for ( int j = i ; j <= n ; j ++ ) table [ j ] += table [ j - i ] ; return table [ n ] ; }
Ref: 
def CountWays ( n ) : NEW_LINE INDENT table = [ 0 ] * ( n + 1 ) NEW_LINE table [ 0 ] = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i , n + 1 ) : NEW_LINE INDENT table [ j ] += table [ j - i ] NEW_LINE DEDENT DEDENT return table [ n ] NEW_LINE DEDENT
Hyp: 
def countWays ( n ) : NEW_LINE INDENT table = [ 0 for i in range ( n + 1 ) ] NEW_LINE table [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( i , n + 1 ) : NEW_LINE INDENT table [ j ] += table [ j - i ] NEW_LINE DEDENT DEDENT return table [ n ] NEW_LINE DEDENT

BLEU: 83.19
Edit Sim: 20


Src: 
void twoWaySort ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] & 1 ) arr [ i ] *= - 1 ; sort ( arr , arr + n ) ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] & 1 ) arr [ i ] *= - 1 ; }
Ref: 
def twoWaySort ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] & 1 ) : NEW_LINE INDENT arr [ i ] *= - 1 NEW_LINE DEDENT DEDENT arr . sort ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] & 1 ) : NEW_LINE INDENT arr [ i ] *= - 1 NEW_LINE DEDENT DEDENT DEDENT
Hyp: 
def twoWaySort ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] & 1 ) : NEW_LINE INDENT arr [ i ] *= - 1 NEW_LINE DEDENT DEDENT arr . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] & 1 ) : NEW_LINE INDENT arr [ i ] *= - 1 NEW_LINE DEDENT DEDENT

BLEU: 90.32
Edit Sim: 15


Src: 
int PowerOFPINnfactorial ( int n , int p ) { int ans = 0 ; int temp = p ; while ( temp <= n ) { ans += n / temp ; temp = temp * p ; } return ans ; }
Ref: 
def PowerOFPINnfactorial ( n , p ) : NEW_LINE INDENT ans = 0 NEW_LINE temp = p NEW_LINE while ( temp <= n ) : NEW_LINE INDENT ans += n / temp NEW_LINE temp = temp * p NEW_LINE DEDENT return int ( ans ) NEW_LINE DEDENT
Hyp: 
def PowerOFPINnfactorial ( n , p ) : NEW_LINE INDENT ans = 0 NEW_LINE temp = p NEW_LINE while ( temp <= n ) : NEW_LINE INDENT ans += n / temp NEW_LINE temp = temp * p NEW_LINE DEDENT return ans NEW_LINE DEDENT

BLEU: 89.01
Edit Sim: 8


Src: 
int findMaxValue ( int mat [ ] [ N ] ) { int maxValue = INT_MIN ; for ( int a = 0 ; a < N - 1 ; a ++ ) for ( int b = 0 ; b < N - 1 ; b ++ ) for ( int d = a + 1 ; d < N ; d ++ ) for ( int e = b + 1 ; e < N ; e ++ ) if ( maxValue < ( mat [ d ] [ e ] - mat [ a ] [ b ] ) ) maxValue = mat [ d ] [ e ] - mat [ a ] [ b ] ; return maxValue ; }
Ref: 
def findMaxValue ( mat ) : NEW_LINE INDENT maxValue = 0 NEW_LINE for a in range ( N - 1 ) : NEW_LINE INDENT for b in range ( N - 1 ) : NEW_LINE INDENT for d in range ( a + 1 , N ) : NEW_LINE INDENT for e in range ( b + 1 , N ) : NEW_LINE INDENT if maxValue < int ( mat [ d ] [ e ] - mat [ a ] [ b ] ) : NEW_LINE INDENT maxValue = int ( mat [ d ] [ e ] - mat [ a ] [ b ] ) ; NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return maxValue ; NEW_LINE DEDENT
Hyp: 
def findMaxValue ( mat ) : NEW_LINE INDENT maxValue = - sys . maxsize - 1 NEW_LINE for a in range ( N - 1 ) : NEW_LINE INDENT for b in range ( N - 1 ) : NEW_LINE INDENT for d in range ( a + 1 , N ) : NEW_LINE INDENT for e in range ( b + 1 , N ) : NEW_LINE INDENT if ( maxValue < ( mat [ d ] [ e ] - mat [ a ] [ b ] ) ) : NEW_LINE INDENT maxValue = mat [ d ] [ e ] - mat [ a ] [ b ] NEW_LINE DEDENT DEDENT DEDENT DEDENT return maxValue NEW_LINE DEDENT

BLEU: 85.69
Edit Sim: 46


Src: 
bool findTriplet ( int a1 [ ] , int a2 [ ] , int a3 [ ] , int n1 , int n2 , int n3 , int sum ) { unordered_set < int > s ; for ( int i = 0 ; i < n1 ; i ++ ) s . insert ( a1 [ i ] ) ; for ( int i = 0 ; i < n2 ; i ++ ) { for ( int j = 0 ; j < n3 ; j ++ ) { if ( s . find ( sum - a2 [ i ] - a3 [ j ] ) != s . end ( ) ) return true ; } } return false ; }
Ref: 
def findTriplet ( a1 , a2 , a3 , n1 , n2 , n3 , sum ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( n1 ) : NEW_LINE INDENT s . add ( a1 [ i ] ) NEW_LINE DEDENT for i in range ( n2 ) : NEW_LINE INDENT for j in range ( n3 ) : NEW_LINE INDENT if sum - a2 [ i ] - a3 [ j ] in s : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT
Hyp: 
def findTriplet ( a1 , a2 , a3 , n1 , n2 , n3 , sum ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( 0 , n1 ) : NEW_LINE INDENT s . add ( a1 [ i ] ) NEW_LINE DEDENT for i in range ( 0 , n2 ) : NEW_LINE INDENT for j in range ( 0 , n3 ) : NEW_LINE INDENT if ( sum - a2 [ i ] - a3 [ j ] ) in s : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT

BLEU: 84.48
Edit Sim: 16


Src: 
int getOddOccurrence ( int arr [ ] , int arr_size ) { for ( int i = 0 ; i < arr_size ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < arr_size ; j ++ ) { if ( arr [ i ] == arr [ j ] ) count ++ ; } if ( count % 2 != 0 ) return arr [ i ] ; } return - 1 ; }
Ref: 
def getOddOccurrence ( arr , arr_size ) : NEW_LINE INDENT for i in range ( 0 , arr_size ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( 0 , arr_size ) : NEW_LINE INDENT if arr [ i ] == arr [ j ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( count % 2 != 0 ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
Hyp: 
def getOddOccurrence ( arr , arr_size ) : NEW_LINE INDENT for i in range ( 0 , arr_size ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( 0 , arr_size ) : NEW_LINE INDENT if ( arr [ i ] == arr [ j ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( count % 2 != 0 ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT

BLEU: 93.86
Edit Sim: 4


Src: 
void factorize ( long long n ) { int count = 0 ; while ( ! ( n % 2 ) ) { n >>= 1 ; count ++ ; } if ( count ) cout << 2 << " ▁ ▁ " << count << endl ; for ( long long i = 3 ; i <= sqrt ( n ) ; i += 2 ) { count = 0 ; while ( n % i == 0 ) { count ++ ; n = n / i ; } if ( count ) cout << i << " ▁ ▁ " << count << endl ; } if ( n > 2 ) cout << n << " ▁ ▁ " << 1 << endl ; }
Ref: 
def factorize ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( ( n % 2 > 0 ) == False ) : NEW_LINE INDENT n >>= 1 NEW_LINE count += 1 NEW_LINE DEDENT if ( count > 0 ) : NEW_LINE INDENT print ( 2 , count ) NEW_LINE DEDENT for i in range ( 3 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n % i == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE n = int ( n / i ) NEW_LINE DEDENT if ( count > 0 ) : NEW_LINE INDENT print ( i , count ) NEW_LINE DEDENT i += 2 NEW_LINE DEDENT if ( n > 2 ) : NEW_LINE INDENT print ( n , 1 ) NEW_LINE DEDENT DEDENT
Hyp: 
def factorize ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( not ( n % 2 ) ) : NEW_LINE INDENT n >>= 1 NEW_LINE count += 1 NEW_LINE DEDENT if ( count ) : NEW_LINE INDENT print ( 2 , end = " ▁ " ) NEW_LINE count += 1 NEW_LINE DEDENT for i in range ( 3 , int ( math . sqrt ( n ) + 2 ) ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n % i == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE n = n / i NEW_LINE DEDENT if ( count ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE count += 1 NEW_LINE DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT print ( n , end = " ▁ " ) NEW_LINE 1 NEW_LINE DEDENT DEDENT

BLEU: 69.77
Edit Sim: 111


Src: 
int findSmallestDifference ( int A [ ] , int B [ ] , int m , int n ) { sort ( A , A + m ) ; sort ( B , B + n ) ; int a = 0 , b = 0 ; int result = INT_MAX ; while ( a < m && b < n ) { if ( abs ( A [ a ] - B [ b ] ) < result ) result = abs ( A [ a ] - B [ b ] ) ; if ( A [ a ] < B [ b ] ) a ++ ; else b ++ ; } return result ; }
Ref: 
def findSmallestDifference ( A , B , m , n ) : NEW_LINE INDENT A . sort ( ) NEW_LINE B . sort ( ) NEW_LINE a = 0 NEW_LINE b = 0 NEW_LINE result = sys . maxsize NEW_LINE while ( a < m and b < n ) : NEW_LINE INDENT if ( abs ( A [ a ] - B [ b ] ) < result ) : NEW_LINE INDENT result = abs ( A [ a ] - B [ b ] ) NEW_LINE DEDENT if ( A [ a ] < B [ b ] ) : NEW_LINE INDENT a += 1 NEW_LINE DEDENT else : NEW_LINE INDENT b += 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
Hyp: 
def findSmallestDifference ( A , B , m , n ) : NEW_LINE INDENT A . sort ( ) NEW_LINE B . sort ( ) NEW_LINE a = 0 b = 0 NEW_LINE result = sys . maxsize NEW_LINE while ( a < m and b < n ) : NEW_LINE INDENT if ( abs ( A [ a ] - B [ b ] ) < result ) : NEW_LINE INDENT result = abs ( A [ a ] - B [ b ] ) NEW_LINE DEDENT if ( A [ a ] < B [ b ] ) : NEW_LINE INDENT a += 1 NEW_LINE DEDENT else : NEW_LINE INDENT b += 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT

BLEU: 97.95
Edit Sim: 9


Src: 
bool check ( string s ) { if ( s . size ( ) >= 10 ) return true ; for ( int i = 1 ; i < s . size ( ) ; i ++ ) { for ( int j = i + 1 ; j < s . size ( ) ; j ++ ) { for ( int k = j + 1 ; k < s . size ( ) ; k ++ ) { string s1 = s . substr ( 0 , i ) ; string s2 = s . substr ( i , j - i ) ; string s3 = s . substr ( j , k - j ) ; string s4 = s . substr ( k , s . size ( ) - k ) ; if ( s1 != s2 && s1 != s3 && s1 != s4 && s2 != s3 && s2 != s4 && s3 != s4 ) return true ; } } } return false ; }
Ref: 
def check ( s ) : NEW_LINE INDENT if ( len ( s ) >= 10 ) : NEW_LINE INDENT return True NEW_LINE DEDENT for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT for j in range ( i + 1 , len ( s ) ) : NEW_LINE INDENT for k in range ( j + 1 , len ( s ) ) : NEW_LINE INDENT s1 = s [ 0 : i ] NEW_LINE s2 = s [ i : j - i ] NEW_LINE s3 = s [ j : k - j ] NEW_LINE s4 = s [ k : len ( s ) - k ] NEW_LINE if ( s1 != s2 and s1 != s3 and s1 != s4 and s2 != s3 and s2 != s4 and s3 != s4 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT DEDENT return False NEW_LINE DEDENT
Hyp: 
def check ( s ) : NEW_LINE INDENT if ( len ( s ) >= 10 ) : NEW_LINE INDENT return True NEW_LINE DEDENT for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT for j in range ( i + 1 , len ( s ) ) : NEW_LINE INDENT for k in range ( j + 1 , len ( s ) ) : NEW_LINE INDENT s1 = s [ 0 ] NEW_LINE s2 = s [ i , j - i ] NEW_LINE s3 = s [ j , k - j ] NEW_LINE s4 = s [ k , len ( s ) - k ] NEW_LINE if ( s1 != s2 and s1 != s3 and s1 != s4 and s2 != s3 and s2 != s4 and s3 != s4 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT DEDENT return False NEW_LINE DEDENT

BLEU: 92.95
Edit Sim: 7


Src: 
bool isPath ( int arr [ row ] [ col ] ) { arr [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i < row ; i ++ ) if ( arr [ i ] [ 0 ] != - 1 ) arr [ i ] [ 0 ] = arr [ i - 1 ] [ 0 ] ; for ( int j = 1 ; j < col ; j ++ ) if ( arr [ 0 ] [ j ] != - 1 ) arr [ 0 ] [ j ] = arr [ 0 ] [ j - 1 ] ; for ( int i = 1 ; i < row ; i ++ ) for ( int j = 1 ; j < col ; j ++ ) if ( arr [ i ] [ j ] != - 1 ) arr [ i ] [ j ] = max ( arr [ i ] [ j - 1 ] , arr [ i - 1 ] [ j ] ) ; return ( arr [ row - 1 ] [ col - 1 ] == 1 ) ; }
Ref: 
def isPath ( arr ) : NEW_LINE INDENT arr [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , row ) : NEW_LINE INDENT if ( arr [ i ] [ 0 ] != - 1 ) : NEW_LINE INDENT arr [ i ] [ 0 ] = arr [ i - 1 ] [ 0 ] NEW_LINE DEDENT DEDENT for j in range ( 1 , col ) : NEW_LINE INDENT if ( arr [ 0 ] [ j ] != - 1 ) : NEW_LINE INDENT arr [ 0 ] [ j ] = arr [ 0 ] [ j - 1 ] NEW_LINE DEDENT DEDENT for i in range ( 1 , row ) : NEW_LINE INDENT for j in range ( 1 , col ) : NEW_LINE INDENT if ( arr [ i ] [ j ] != - 1 ) : NEW_LINE INDENT arr [ i ] [ j ] = max ( arr [ i ] [ j - 1 ] , arr [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return ( arr [ row - 1 ] [ col - 1 ] == 1 ) NEW_LINE DEDENT
Hyp: 
def isPath ( arr ) : NEW_LINE INDENT arr [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , row ) : NEW_LINE INDENT if ( arr [ i ] [ 0 ] != - 1 ) : NEW_LINE INDENT arr [ i ] [ 0 ] = arr [ i - 1 ] [ 0 ] NEW_LINE DEDENT DEDENT for j in range ( 1 , col ) : NEW_LINE INDENT if ( arr [ 0 ] [ j ] != - 1 ) : NEW_LINE INDENT arr [ 0 ] [ j ] = arr [ 0 ] [ j - 1 ] NEW_LINE DEDENT DEDENT for i in range ( 1 , row ) : NEW_LINE INDENT for j in range ( 1 , col ) : NEW_LINE INDENT if ( arr [ i ] [ j ] != - 1 ) : NEW_LINE INDENT arr [ i ] [ j ] = max ( arr [ i ] [ j - 1 ] , arr [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return ( arr [ row - 1 ] [ col - 1 ] == 1 ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
void bitonicGenerator ( int arr [ ] , int n ) { int i = 1 ; int j = n - 1 ; if ( j % 2 != 0 ) j -- ; while ( i < j ) { swap ( arr [ i ] , arr [ j ] ) ; i += 2 ; j -= 2 ; } sort ( arr , arr + ( n + 1 ) / 2 ) ; sort ( arr + ( n + 1 ) / 2 , arr + n , greater < int > ( ) ) ; }
Ref: 
def bitonicGenerator ( arr , n ) : NEW_LINE INDENT i = 1 NEW_LINE j = n - 1 NEW_LINE if ( j % 2 != 0 ) : NEW_LINE INDENT j = j - 1 NEW_LINE DEDENT while ( i < j ) : NEW_LINE INDENT arr [ j ] , arr [ i ] = arr [ i ] , arr [ j ] NEW_LINE i = i + 2 NEW_LINE j = j - 2 NEW_LINE DEDENT arr_f = [ ] NEW_LINE arr_s = [ ] NEW_LINE for i in range ( int ( ( n + 1 ) / 2 ) ) : NEW_LINE INDENT arr_f . append ( arr [ i ] ) NEW_LINE DEDENT i = int ( ( n + 1 ) / 2 ) NEW_LINE while ( i < n ) : NEW_LINE INDENT arr_s . append ( arr [ i ] ) NEW_LINE i = i + 1 NEW_LINE DEDENT arr_f . sort ( ) NEW_LINE arr_s . sort ( reverse = True ) NEW_LINE for i in arr_s : NEW_LINE INDENT arr_f . append ( i ) NEW_LINE DEDENT return arr_f NEW_LINE DEDENT
Hyp: 
def bitonicGenerator ( arr , n ) : NEW_LINE INDENT i = 1 NEW_LINE j = n - 1 NEW_LINE if ( j % 2 != 0 ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT while ( i < j ) : NEW_LINE INDENT arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ] NEW_LINE i += 2 NEW_LINE j -= 2 NEW_LINE DEDENT arr . sort ( ) NEW_LINE DEDENT

BLEU: 21.18
Edit Sim: 431


Src: 
int solve ( int dp [ ] [ MAX ] , int a [ ] , int low , int high , int turn ) { if ( low == high ) return a [ low ] * turn ; if ( dp [ low ] [ high ] != 0 ) return dp [ low ] [ high ] ; dp [ low ] [ high ] = max ( a [ low ] * turn + solve ( dp , a , low + 1 , high , turn + 1 ) , a [ high ] * turn + solve ( dp , a , low , high - 1 , turn + 1 ) ) ; return dp [ low ] [ high ] ; }
Ref: 
def solve ( dp , a , low , high , turn ) : NEW_LINE INDENT if ( low == high ) : NEW_LINE INDENT return a [ low ] * turn NEW_LINE DEDENT if ( dp [ low ] [ high ] != 0 ) : NEW_LINE INDENT return dp [ low ] [ high ] NEW_LINE DEDENT dp [ low ] [ high ] = max ( a [ low ] * turn + solve ( dp , a , low + 1 , high , turn + 1 ) , a [ high ] * turn + solve ( dp , a , low , high - 1 , turn + 1 ) ) ; NEW_LINE return dp [ low ] [ high ] NEW_LINE DEDENT
Hyp: 
def solve ( dp , a , low , high , turn ) : NEW_LINE INDENT if low == high : NEW_LINE INDENT return a [ low ] * turn NEW_LINE DEDENT if dp [ low ] [ high ] != 0 : NEW_LINE INDENT return dp [ low ] [ high ] NEW_LINE DEDENT dp [ low ] [ high ] = max ( a [ low ] * turn + solve ( dp , a , low + 1 , high , turn + 1 ) , a [ high ] * turn + solve ( dp , a , low , high - 1 , turn + 1 ) ) NEW_LINE return dp [ low ] [ high ] NEW_LINE DEDENT

BLEU: 90.07
Edit Sim: 10


Src: 
void direction ( ll R , ll C ) { if ( R != C && R % 2 == 0 && C % 2 != 0 && R < C ) { cout << " Left " << endl ; return ; } if ( R != C && R % 2 != 0 && C % 2 == 0 && R > C ) { cout << " Up " << endl ; return ; } if ( R == C && R % 2 != 0 && C % 2 != 0 ) { cout << " Right " << endl ; return ; } if ( R == C && R % 2 == 0 && C % 2 == 0 ) { cout << " Left " << endl ; return ; } if ( R != C && R % 2 != 0 && C % 2 != 0 && R < C ) { cout << " Right " << endl ; return ; } if ( R != C && R % 2 != 0 && C % 2 != 0 && R > C ) { cout << " Down " << endl ; return ; } if ( R != C && R % 2 == 0 && C % 2 == 0 && R < C ) { cout << " Left " << endl ; return ; } if ( R != C && R % 2 == 0 && C % 2 == 0 && R > C ) { cout << " Up " << endl ; return ; } if ( R != C && R % 2 == 0 && C % 2 != 0 && R > C ) { cout << " Down " << endl ; return ; } if ( R != C && R % 2 != 0 && C % 2 == 0 && R < C ) { cout << " Right " << endl ; return ; } }
Ref: 
def direction ( R , C ) : NEW_LINE INDENT if ( R != C and R % 2 == 0 and C % 2 != 0 and R < C ) : NEW_LINE INDENT print ( " Left " ) NEW_LINE return NEW_LINE DEDENT if ( R != C and R % 2 == 0 and C % 2 == 0 and R > C ) : NEW_LINE INDENT print ( " Up " ) NEW_LINE return NEW_LINE DEDENT if R == C and R % 2 != 0 and C % 2 != 0 : NEW_LINE INDENT print ( " Right " ) NEW_LINE return NEW_LINE DEDENT if R == C and R % 2 == 0 and C % 2 == 0 : NEW_LINE INDENT print ( " Left " ) NEW_LINE return NEW_LINE DEDENT if ( R != C and R % 2 != 0 and C % 2 != 0 and R < C ) : NEW_LINE INDENT print ( " Right " ) NEW_LINE return NEW_LINE DEDENT if ( R != C and R % 2 != 0 and C % 2 != 0 and R > C ) : NEW_LINE INDENT print ( " Down " ) NEW_LINE return NEW_LINE DEDENT if ( R != C and R % 2 == 0 and C % 2 != 0 and R < C ) : NEW_LINE INDENT print ( " Left " ) NEW_LINE return NEW_LINE DEDENT if ( R != C and R % 2 == 0 and C % 2 == 0 and R > C ) : NEW_LINE INDENT print ( " Up " ) NEW_LINE return NEW_LINE DEDENT if ( R != C and R % 2 != 0 and C % 2 != 0 and R > C ) : NEW_LINE INDENT print ( " Down " ) NEW_LINE return NEW_LINE DEDENT if ( R != C and R % 2 != 0 and C % 2 != 0 and R < C ) : NEW_LINE INDENT print ( " Right " ) NEW_LINE return NEW_LINE DEDENT DEDENT
Hyp: 
def direction ( R , C ) : NEW_LINE INDENT if ( R != C and R % 2 == 0 and C % 2 != 0 and R < C ) : NEW_LINE INDENT print ( " Left " ) NEW_LINE return NEW_LINE DEDENT if ( R != C and R % 2 != 0 and C % 2 == 0 and R > C ) : NEW_LINE INDENT print ( " Up " ) NEW_LINE return NEW_LINE DEDENT if ( R == C and R % 2 != 0 and C % 2 != 0 ) : NEW_LINE INDENT print ( " Right " ) NEW_LINE return NEW_LINE DEDENT if ( R == C and R % 2 == 0 and C % 2 != 0 ) : NEW_LINE INDENT print ( " Left " ) NEW_LINE return NEW_LINE DEDENT if ( R != C and R % 2 != 0 and C % 2 != 0 and R < C ) : NEW_LINE INDENT print ( " Down " ) NEW_LINE return NEW_LINE DEDENT if ( R != C and R % 2 == 0 and C % 2 != 0 and R < C ) : NEW_LINE INDENT print ( " Left " ) NEW_LINE return NEW_LINE DEDENT if ( R != C and R % 2 == 0 and C % 2 == 0 and R < C ) : NEW_LINE INDENT print ( " Down " ) NEW_LINE return NEW_LINE DEDENT if ( R != C and R % 2 == 0 and C % 2 == 0 and R > C ) : NEW_LINE INDENT print ( " Up " ) NEW_LINE return NEW_LINE DEDENT if ( R != C and R % 2 == 0 and C % 2 != 0 and R > C ) : NEW_LINE INDENT print ( " Down " ) NEW_LINE return NEW_LINE DEDENT if ( R != C and R % 2 != 0 and C % 2 == 0 and R > C ) : NEW_LINE INDENT print ( " Right " ) NEW_LINE return NEW_LINE DEDENT DEDENT

BLEU: 94.78
Edit Sim: 29


Src: 
void splitString ( string str ) { string alpha , num , special ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( isdigit ( str [ i ] ) ) num . push_back ( str [ i ] ) ; else if ( ( str [ i ] >= ' A ' && str [ i ] <= ' Z ' ) || ( str [ i ] >= ' a ' && str [ i ] <= ' z ' ) ) alpha . push_back ( str [ i ] ) ; else special . push_back ( str [ i ] ) ; } cout << alpha << endl ; cout << num << endl ; cout << special << endl ; }
Ref: 
def splitString ( str ) : NEW_LINE INDENT alpha = " " NEW_LINE num = " " NEW_LINE special = " " NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] . isdigit ( ) ) : NEW_LINE INDENT num = num + str [ i ] NEW_LINE DEDENT elif ( ( str [ i ] >= ' A ' and str [ i ] <= ' Z ' ) or ( str [ i ] >= ' a ' and str [ i ] <= ' z ' ) ) : NEW_LINE INDENT alpha += str [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT special += str [ i ] NEW_LINE DEDENT DEDENT print ( alpha ) NEW_LINE print ( num ) NEW_LINE print ( special ) NEW_LINE DEDENT
Hyp: 
def splitString ( str ) : NEW_LINE INDENT alpha = " " NEW_LINE num = [ ] NEW_LINE special = [ ] NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( num . endswith ( str [ i ] ) ) : NEW_LINE INDENT num . append ( str [ i ] ) NEW_LINE DEDENT elif ( ( str [ i ] >= ' A ' and str [ i ] <= ' Z ' ) or ( str [ i ] >= ' a ' and str [ i ] <= ' z ' ) ) : NEW_LINE INDENT alpha . append ( str [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT special . append ( str [ i ] ) NEW_LINE DEDENT DEDENT print ( alpha ) NEW_LINE print ( num ) NEW_LINE print ( special ) NEW_LINE DEDENT

BLEU: 77.42
Edit Sim: 58


Src: 
int binaryMedian ( int m [ ] [ MAX ] , int r , int c ) { int min = INT_MAX , max = INT_MIN ; for ( int i = 0 ; i < r ; i ++ ) { if ( m [ i ] [ 0 ] < min ) min = m [ i ] [ 0 ] ; if ( m [ i ] [ c - 1 ] > max ) max = m [ i ] [ c - 1 ] ; } int desired = ( r * c + 1 ) / 2 ; while ( min < max ) { int mid = min + ( max - min ) / 2 ; int place = 0 ; for ( int i = 0 ; i < r ; ++ i ) place += upper_bound ( m [ i ] , m [ i ] + c , mid ) - m [ i ] ; if ( place < desired ) min = mid + 1 ; else max = mid ; } return min ; }
Ref: 
def binaryMedian ( m , r , d ) : NEW_LINE INDENT mi = m [ 0 ] [ 0 ] NEW_LINE mx = 0 NEW_LINE for i in range ( r ) : NEW_LINE INDENT if m [ i ] [ 0 ] < mi : NEW_LINE INDENT mi = m [ i ] [ 0 ] NEW_LINE DEDENT if m [ i ] [ d - 1 ] > mx : NEW_LINE INDENT mx = m [ i ] [ d - 1 ] NEW_LINE DEDENT DEDENT desired = ( r * d + 1 ) // 2 NEW_LINE while ( mi < mx ) : NEW_LINE INDENT mid = mi + ( mx - mi ) // 2 NEW_LINE place = [ 0 ] NEW_LINE for i in range ( r ) : NEW_LINE INDENT j = upper_bound ( m [ i ] , mid ) NEW_LINE place [ 0 ] = place [ 0 ] + j NEW_LINE DEDENT if place [ 0 ] < desired : NEW_LINE INDENT mi = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT mx = mid NEW_LINE DEDENT DEDENT print ( " Median ▁ is " , mi ) NEW_LINE return NEW_LINE DEDENT
Hyp: 
def binaryMedian ( m , r , c ) : NEW_LINE INDENT min = 2147483647 NEW_LINE max = 2147483647 NEW_LINE for i in range ( r ) : NEW_LINE INDENT if ( m [ i ] [ 0 ] < min ) : NEW_LINE INDENT min = m [ i ] [ 0 ] NEW_LINE DEDENT if ( m [ i ] [ c - 1 ] > max ) : NEW_LINE INDENT max = m [ i ] [ c - 1 ] NEW_LINE DEDENT desired = ( r * c + 1 ) / 2 NEW_LINE while ( min < max ) : NEW_LINE INDENT mid = min + ( max - min ) // 2 NEW_LINE place = 0 NEW_LINE for i in range ( r ) : NEW_LINE INDENT place += upper_bound ( m [ i ] , m [ i ] + c , mid ) - m [ i ] NEW_LINE DEDENT if ( place < desired ) : NEW_LINE INDENT min = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT max = mid NEW_LINE DEDENT DEDENT return min NEW_LINE DEDENT

BLEU: 51.41
Edit Sim: 145


Src: 
void printDuplicates ( int arr [ ] , int n ) { unordered_map < int , int > freq ; for ( int i = 0 ; i < n ; i ++ ) freq [ arr [ i ] ] ++ ; bool dup = false ; unordered_map < int , int > :: iterator itr ; for ( itr = freq . begin ( ) ; itr != freq . end ( ) ; itr ++ ) { if ( itr -> second > 1 ) { cout << itr -> first << " ▁ " ; dup = true ; } } if ( dup == false ) cout << " - 1" ; }
Ref: 
def printDuplicates ( arr ) : NEW_LINE INDENT dict = { } NEW_LINE for ele in arr : NEW_LINE INDENT try : NEW_LINE INDENT dict [ ele ] += 1 NEW_LINE DEDENT except : NEW_LINE INDENT dict [ ele ] = 1 NEW_LINE DEDENT DEDENT for item in dict : NEW_LINE INDENT if ( dict [ item ] > 1 ) : NEW_LINE INDENT print ( item , end = " ▁ " ) NEW_LINE DEDENT DEDENT print ( " \n " ) NEW_LINE DEDENT
Hyp: 
def printDuplicates ( arr , n ) : NEW_LINE INDENT freq = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ arr [ i ] ] = freq . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT dup = False NEW_LINE for key , values in freq . items ( ) : NEW_LINE INDENT if values > 1 : NEW_LINE INDENT print ( key , end = " ▁ " ) NEW_LINE dup = True NEW_LINE DEDENT DEDENT if dup == False : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT DEDENT

BLEU: 28.09
Edit Sim: 207


Src: 
void fib ( int n ) { int a = 0 , b = 1 , c ; if ( n >= 0 ) cout << a << " ▁ " ; if ( n >= 1 ) cout << b << " ▁ " ; for ( int i = 2 ; i <= n ; i ++ ) { c = a + b ; cout << c << " ▁ " ; a = b ; b = c ; } }
Ref: 
def fib ( n ) : NEW_LINE INDENT a = 0 NEW_LINE b = 1 NEW_LINE if ( n >= 0 ) : NEW_LINE INDENT print ( a , end = ' ▁ ' ) NEW_LINE DEDENT if ( n >= 1 ) : NEW_LINE INDENT print ( b , end = ' ▁ ' ) NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT c = a + b NEW_LINE print ( c , end = ' ▁ ' ) NEW_LINE a = b NEW_LINE b = c NEW_LINE DEDENT DEDENT
Hyp: 
def fib ( n ) : NEW_LINE INDENT a = 0 NEW_LINE b = 1 NEW_LINE if n >= 0 : NEW_LINE INDENT print ( a , end = " ▁ " ) NEW_LINE DEDENT if n >= 1 : NEW_LINE INDENT print ( b , end = " ▁ " ) NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT c = a + b NEW_LINE print ( c , end = " ▁ " ) NEW_LINE a = b NEW_LINE b = c NEW_LINE DEDENT DEDENT

BLEU: 76.2
Edit Sim: 14


Src: 
int swapNibbles ( int x ) { return ( ( x & 0x0F ) << 4 | ( x & 0xF0 ) >> 4 ) ; }
Ref: 
def swapNibbles ( x ) : NEW_LINE INDENT return ( ( x & 0x0F ) << 4 | ( x & 0xF0 ) >> 4 ) NEW_LINE DEDENT
Hyp: 
def swapNibbles ( x ) : NEW_LINE INDENT return ( ( x & 0x0F ) << 4 | ( x & 0xF0 ) >> 4 ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int countPS ( int i , int j ) { if ( i >= n || j < 0 ) return 0 ; if ( dp [ i ] [ j ] != - 1 ) return dp [ i ] [ j ] ; if ( abs ( i - j ) == 1 ) { if ( str [ i ] == str [ j ] ) return dp [ i ] [ j ] = 3 ; else return dp [ i ] [ j ] = 2 ; } if ( i == j ) return dp [ 1 ] [ j ] = 1 ; else if ( str [ i ] == str [ j ] ) return dp [ i ] [ j ] = countPS ( i + 1 , j ) + countPS ( i , j - 1 ) + 1 ; else return dp [ i ] [ j ] = countPS ( i + 1 , j ) + countPS ( i , j - 1 ) - countPS ( i + 1 , j - 1 ) ; }
Ref: 
def countPS ( i , j ) : NEW_LINE INDENT if ( i >= n or j < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ i ] [ j ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ j ] NEW_LINE DEDENT if ( abs ( i - j ) == 1 ) : NEW_LINE INDENT if ( str [ i ] == str [ j ] ) : NEW_LINE INDENT dp [ i ] [ j ] = 3 NEW_LINE return dp [ i ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = 2 NEW_LINE return dp [ i ] [ j ] NEW_LINE DEDENT DEDENT if ( i == j ) : NEW_LINE INDENT dp [ 1 ] [ j ] = 1 NEW_LINE return dp [ 1 ] [ j ] NEW_LINE DEDENT elif ( str [ i ] == str [ j ] ) : NEW_LINE INDENT dp [ i ] [ j ] = ( countPS ( i + 1 , j ) + countPS ( i , j - 1 ) + 1 ) NEW_LINE return dp [ i ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = ( countPS ( i + 1 , j ) + countPS ( i , j - 1 ) - countPS ( i + 1 , j - 1 ) ) NEW_LINE return dp [ i ] [ j ] NEW_LINE DEDENT DEDENT
Hyp: 
def countPS ( i , j ) : NEW_LINE INDENT if ( i >= n or j < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ i ] [ j ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ j ] NEW_LINE DEDENT if ( abs ( i - j ) == 1 ) : NEW_LINE INDENT if ( str [ i ] == str [ j ] ) : NEW_LINE INDENT dp [ i ] [ j ] = 3 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = 2 NEW_LINE DEDENT DEDENT if ( i == j ) : NEW_LINE INDENT return dp [ 1 ] [ j ] = 1 NEW_LINE DEDENT elif ( str [ i ] == str [ j ] ) : NEW_LINE INDENT return dp [ i ] [ j ] = countPS ( i + 1 , j ) + countPS ( i , j - 1 ) + 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = countPS ( i + 1 , j ) + countPS ( i , j - 1 ) - countPS ( i + 1 , j - 1 ) NEW_LINE DEDENT DEDENT

BLEU: 76.53
Edit Sim: 171


Src: 
int divisorSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; ++ i ) sum += ( n / i ) * i ; return sum ; }
Ref: 
def divisorSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += int ( n / i ) * i NEW_LINE DEDENT return int ( sum ) NEW_LINE DEDENT
Hyp: 
def divisorSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += ( n // i ) * i NEW_LINE DEDENT return sum NEW_LINE DEDENT

BLEU: 77.3
Edit Sim: 13


Src: 
int addOne ( int x ) { int m = 1 ; while ( x & m ) { x = x ^ m ; m <<= 1 ; } x = x ^ m ; return x ; }
Ref: 
def addOne ( x ) : NEW_LINE INDENT m = 1 NEW_LINE while ( x & m ) : NEW_LINE INDENT x = x ^ m NEW_LINE m <<= 1 NEW_LINE DEDENT x = x ^ m NEW_LINE return x NEW_LINE DEDENT
Hyp: 
def addOne ( x ) : NEW_LINE INDENT m = 1 NEW_LINE while ( x & m ) : NEW_LINE INDENT x = x ^ m NEW_LINE m <<= 1 NEW_LINE DEDENT x = x ^ m NEW_LINE return x NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int check ( string str ) { int n = str . length ( ) ; int digitSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) digitSum += ( str [ i ] - '0' ) ; return ( digitSum % 9 == 0 ) ; }
Ref: 
def check ( st ) : NEW_LINE INDENT n = len ( st ) NEW_LINE digitSum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT digitSum = digitSum + ( int ) ( st [ i ] ) NEW_LINE DEDENT return ( digitSum % 9 == 0 ) NEW_LINE DEDENT
Hyp: 
def check ( num ) : NEW_LINE INDENT digitSum = 0 NEW_LINE while num > 0 : NEW_LINE INDENT rem = num % 10 NEW_LINE digitSum = digitSum + rem NEW_LINE num = num // 10 NEW_LINE DEDENT return ( digitSum % 9 == 0 ) NEW_LINE DEDENT

BLEU: 41.82
Edit Sim: 73


Src: 
int findMaxGCD ( int arr [ ] , int n ) { int high = 0 ; for ( int i = 0 ; i < n ; i ++ ) high = max ( high , arr [ i ] ) ; int divisors [ high + 1 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 1 ; j <= sqrt ( arr [ i ] ) ; j ++ ) { if ( arr [ i ] % j == 0 ) { divisors [ j ] ++ ; if ( j != arr [ i ] / j ) divisors [ arr [ i ] / j ] ++ ; } } } for ( int i = high ; i >= 1 ; i -- ) if ( divisors [ i ] > 1 ) return i ; }
Ref: 
def findMaxGCD ( arr , n ) : NEW_LINE INDENT high = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT high = max ( high , arr [ i ] ) NEW_LINE i = i + 1 NEW_LINE DEDENT divisors = [ 0 ] * ( high + 1 ) NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT j = 1 NEW_LINE while j <= math . sqrt ( arr [ i ] ) : NEW_LINE INDENT if ( arr [ i ] % j == 0 ) : NEW_LINE INDENT divisors [ j ] = divisors [ j ] + 1 NEW_LINE if ( j != arr [ i ] / j ) : NEW_LINE INDENT divisors [ arr [ i ] / j ] = divisors [ arr [ i ] / j ] NEW_LINE INDENT + 1 NEW_LINE DEDENT DEDENT DEDENT j = j + 1 NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT i = high NEW_LINE while i >= 1 : NEW_LINE INDENT if ( divisors [ i ] > 1 ) : NEW_LINE INDENT return i NEW_LINE DEDENT i = i - 1 NEW_LINE DEDENT return 1 NEW_LINE DEDENT
Hyp: 
def findMaxGCD ( arr , n ) : NEW_LINE INDENT high = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT high = max ( high , arr [ i ] ) NEW_LINE DEDENT divisors = [ 0 for i in range ( high + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( 1 , int ( math . sqrt ( arr [ i ] ) + 1 ) ) : NEW_LINE INDENT if arr [ i ] % j == 0 : NEW_LINE INDENT divisors [ j ] = divisors [ j ] + 1 NEW_LINE if j != arr [ i ] / j : NEW_LINE INDENT divisors [ arr [ i ] / j ] = divisors [ arr [ i ] / j ] + 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( high , 0 , - 1 ) : NEW_LINE INDENT if divisors [ i ] > 1 : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT DEDENT

BLEU: 58.32
Edit Sim: 233


Src: 
int minRemove ( int arr [ ] , int n ) { int LIS [ n ] , len = 0 ; for ( int i = 0 ; i < n ; i ++ ) LIS [ i ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ i ] > arr [ j ] && ( i - j ) <= ( arr [ i ] - arr [ j ] ) ) { LIS [ i ] = max ( LIS [ i ] , LIS [ j ] + 1 ) ; } } len = max ( len , LIS [ i ] ) ; } return n - len ; }
Ref: 
def minRemove ( arr , n ) : NEW_LINE INDENT LIS = [ 0 for i in range ( n ) ] NEW_LINE len = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT LIS [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and ( i - j ) <= ( arr [ i ] - arr [ j ] ) ) : NEW_LINE INDENT LIS [ i ] = max ( LIS [ i ] , LIS [ j ] + 1 ) NEW_LINE DEDENT DEDENT len = max ( len , LIS [ i ] ) NEW_LINE DEDENT return ( n - len ) NEW_LINE DEDENT
Hyp: 
def minRemove ( arr , n ) : NEW_LINE INDENT LIS = [ 0 ] * n NEW_LINE len = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT LIS [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( 0 , i ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and ( i - j ) <= ( arr [ i ] - arr [ j ] ) ) : NEW_LINE INDENT LIS [ i ] = max ( LIS [ i ] , LIS [ j ] + 1 ) NEW_LINE DEDENT DEDENT len = max ( len , LIS [ i ] ) NEW_LINE DEDENT return n - len NEW_LINE DEDENT

BLEU: 88.1
Edit Sim: 31


Src: 
void computeLPSArray ( char * pat , int M , int * lps ) { int len = 0 ; lps [ 0 ] = 0 ; int i = 1 ; while ( i < M ) { if ( pat [ i ] == pat [ len ] ) { len ++ ; lps [ i ] = len ; i ++ ; } else { if ( len != 0 ) { len = lps [ len - 1 ] ; } else { lps [ i ] = 0 ; i ++ ; } } } }
Ref: 
def computeLPSArray ( pat , M , lps ) : NEW_LINE INDENT len = 0 NEW_LINE lps [ 0 ] NEW_LINE i = 1 NEW_LINE while i < M : NEW_LINE INDENT if pat [ i ] == pat [ len ] : NEW_LINE INDENT len += 1 NEW_LINE lps [ i ] = len NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if len != 0 : NEW_LINE INDENT len = lps [ len - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT lps [ i ] = 0 NEW_LINE i += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT
Hyp: 
def computeLPSArray ( pat , M , lps ) : NEW_LINE INDENT len = 0 NEW_LINE lps [ 0 ] = 0 NEW_LINE i = 1 NEW_LINE while ( i < M ) : NEW_LINE INDENT if ( pat [ i ] == pat [ len ] ) : NEW_LINE INDENT len += 1 NEW_LINE lps [ i ] = len NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( len != 0 ) : NEW_LINE INDENT len = lps [ len - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT lps [ i ] = 0 NEW_LINE i += 1 NEW_LINE DEDENT DEDENT DEDENT

BLEU: 82.37
Edit Sim: 23


Src: 
int numofsubset ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int count = 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] + 1 != arr [ i + 1 ] ) count ++ ; } return count ; }
Ref: 
def numofsubset ( arr , n ) : NEW_LINE INDENT x = sorted ( arr ) NEW_LINE count = 1 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( x [ i ] + 1 != x [ i + 1 ] ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
Hyp: 
def numofsubset ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE count = 1 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if arr [ i ] + 1 != arr [ i + 1 ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT

BLEU: 69.93
Edit Sim: 27


Src: 
void stoogesort ( int arr [ ] , int l , int h ) { if ( l >= h ) return ; if ( arr [ l ] > arr [ h ] ) swap ( arr [ l ] , arr [ h ] ) ; if ( h - l + 1 > 2 ) { int t = ( h - l + 1 ) / 3 ; stoogesort ( arr , l , h - t ) ; stoogesort ( arr , l + t , h ) ; stoogesort ( arr , l , h - t ) ; } }
Ref: 
def stoogesort ( arr , l , h ) : NEW_LINE INDENT if l >= h : NEW_LINE INDENT return NEW_LINE DEDENT if arr [ l ] > arr [ h ] : NEW_LINE INDENT t = arr [ l ] NEW_LINE arr [ l ] = arr [ h ] NEW_LINE arr [ h ] = t NEW_LINE DEDENT if h - l + 1 > 2 : NEW_LINE INDENT t = ( int ) ( ( h - l + 1 ) / 3 ) NEW_LINE stoogesort ( arr , l , ( h - t ) ) NEW_LINE stoogesort ( arr , l + t , ( h ) ) NEW_LINE stoogesort ( arr , l , ( h - t ) ) NEW_LINE DEDENT DEDENT
Hyp: 
def stoogesort ( arr , l , h ) : NEW_LINE INDENT if l >= h : NEW_LINE INDENT return NEW_LINE DEDENT if arr [ l ] > arr [ h ] : NEW_LINE INDENT arr [ l ] , arr [ h ] = arr [ h ] , arr [ l ] NEW_LINE DEDENT if h - l + 1 > 2 : NEW_LINE INDENT t = ( h - l + 1 ) // 3 NEW_LINE stoogesort ( arr , l , h - t ) NEW_LINE stoogesort ( arr , l + t , h ) NEW_LINE stoogesort ( arr , l , h - t ) NEW_LINE DEDENT DEDENT

BLEU: 73.04
Edit Sim: 51


Src: 
void solve ( int n , int t , string s ) { for ( int i = 0 ; i < t ; i ++ ) for ( int j = 0 ; j < n - 1 ; j ++ ) if ( s [ j ] == ' B ' && s [ j + 1 ] == ' G ' ) { char temp = s [ j ] ; s [ j ] = s [ j + 1 ] ; s [ j + 1 ] = temp ; j ++ ; } cout << s ; }
Ref: 
def solve ( n , t , p ) : NEW_LINE INDENT s = list ( p ) NEW_LINE for i in range ( 0 , t ) : NEW_LINE INDENT for j in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( s [ j ] == ' B ' and s [ j + 1 ] == ' G ' ) : NEW_LINE INDENT temp = s [ j ] NEW_LINE s [ j ] = s [ j + 1 ] NEW_LINE s [ j + 1 ] = temp NEW_LINE j = j + 1 NEW_LINE DEDENT DEDENT DEDENT print ( ' ' . join ( s ) ) NEW_LINE DEDENT
Hyp: 
def solve ( n , t , s ) : NEW_LINE INDENT for i in range ( t ) : NEW_LINE INDENT for j in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( s [ j ] == ' B ' and s [ j + 1 ] == ' G ' ) : NEW_LINE INDENT temp = s [ j ] NEW_LINE s [ j ] = s [ j + 1 ] NEW_LINE s [ j + 1 ] = temp NEW_LINE j += 1 NEW_LINE DEDENT DEDENT DEDENT print ( s ) NEW_LINE DEDENT

BLEU: 76.68
Edit Sim: 49


Src: 
int turnOffK ( int n , int k ) { if ( k <= 0 ) return n ; return ( n & ~ ( 1 << ( k - 1 ) ) ) ; }
Ref: 
def turnOffK ( n , k ) : NEW_LINE INDENT if ( k <= 0 ) : NEW_LINE INDENT return n NEW_LINE DEDENT return ( n & ~ ( 1 << ( k - 1 ) ) ) NEW_LINE DEDENT
Hyp: 
def turnOffK ( n , k ) : NEW_LINE INDENT if ( k <= 0 ) : return n NEW_LINE DEDENT return ( n & ~ ( 1 << ( k - 1 ) ) ) NEW_LINE DEDENT

BLEU: 90.94
Edit Sim: 16


Src: 
void printEqualModNumbers ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int d = arr [ n - 1 ] - arr [ 0 ] ; vector < int > v ; for ( int i = 1 ; i * i <= d ; i ++ ) { if ( d % i == 0 ) { v . push_back ( i ) ; if ( i != d / i ) v . push_back ( d / i ) ; } } for ( int i = 0 ; i < v . size ( ) ; i ++ ) { int temp = arr [ 0 ] % v [ i ] ; int j ; for ( j = 1 ; j < n ; j ++ ) if ( arr [ j ] % v [ i ] != temp ) break ; if ( j == n ) cout << v [ i ] << " ▁ " ; } }
Ref: 
def printEqualModNumbers ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE d = arr [ n - 1 ] - arr [ 0 ] NEW_LINE v = [ ] NEW_LINE i = 1 NEW_LINE while ( i * i <= d ) : NEW_LINE INDENT if ( d % i == 0 ) : NEW_LINE INDENT v . append ( i ) NEW_LINE if ( i != d / i ) : NEW_LINE INDENT v . append ( d / i ) NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT for i in range ( len ( v ) ) : NEW_LINE INDENT temp = arr [ 0 ] % v [ i ] NEW_LINE j = 1 NEW_LINE while ( j < n ) : NEW_LINE INDENT if ( arr [ j ] % v [ i ] != temp ) : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if ( j == n ) : NEW_LINE INDENT print ( v [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
Hyp: 
def printEqualModNumbers ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE d = arr [ n - 1 ] - arr [ 0 ] NEW_LINE v = [ ] NEW_LINE for i in range ( 1 , d - 1 ) : NEW_LINE INDENT if ( d % i == 0 ) : NEW_LINE INDENT v . append ( i ) NEW_LINE if ( i != d // i ) : NEW_LINE INDENT v . append ( d // i ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( 0 , len ( v ) ) : NEW_LINE INDENT temp = arr [ 0 ] % v [ i ] NEW_LINE j = 1 NEW_LINE while ( j < n ) : NEW_LINE INDENT if ( arr [ j ] % v [ i ] != temp ) : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if ( j == n ) : NEW_LINE INDENT print ( v [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT

BLEU: 87.2
Edit Sim: 44


Src: 
int findMaximum ( int arr [ ] , int low , int high ) { if ( low == high ) return arr [ low ] ; if ( ( high == low + 1 ) && arr [ low ] >= arr [ high ] ) return arr [ low ] ; if ( ( high == low + 1 ) && arr [ low ] < arr [ high ] ) return arr [ high ] ; int mid = ( low + high ) / 2 ; if ( arr [ mid ] > arr [ mid + 1 ] && arr [ mid ] > arr [ mid - 1 ] ) return arr [ mid ] ; if ( arr [ mid ] > arr [ mid + 1 ] && arr [ mid ] < arr [ mid - 1 ] ) return findMaximum ( arr , low , mid - 1 ) ; else return findMaximum ( arr , mid + 1 , high ) ; }
Ref: 
def findMaximum ( arr , low , high ) : NEW_LINE INDENT if low == high : NEW_LINE INDENT return arr [ low ] NEW_LINE DEDENT if high == low + 1 and arr [ low ] >= arr [ high ] : NEW_LINE INDENT return arr [ low ] NEW_LINE DEDENT if high == low + 1 and arr [ low ] < arr [ high ] : NEW_LINE INDENT return arr [ high ] NEW_LINE DEDENT mid = ( low + high ) // 2 NEW_LINE if arr [ mid ] > arr [ mid + 1 ] and arr [ mid ] > arr [ mid - 1 ] : NEW_LINE INDENT return arr [ mid ] NEW_LINE DEDENT if arr [ mid ] > arr [ mid + 1 ] and arr [ mid ] < arr [ mid - 1 ] : NEW_LINE INDENT return findMaximum ( arr , low , mid - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return findMaximum ( arr , mid + 1 , high ) NEW_LINE DEDENT DEDENT
Hyp: 
def findMaximum ( arr , low , high ) : NEW_LINE INDENT if low == high : NEW_LINE INDENT return arr [ low ] NEW_LINE DEDENT if ( high == low + 1 ) and arr [ low ] >= arr [ high ] ) : NEW_LINE INDENT return arr [ low ] NEW_LINE DEDENT if ( high == low + 1 ) and arr [ low ] < arr [ high ] ) : NEW_LINE INDENT return arr [ high ] NEW_LINE DEDENT mid = int ( ( low + high ) / 2 ) NEW_LINE if ( arr [ mid ] > arr [ mid + 1 ] and arr [ mid ] > arr [ mid - 1 ] ) : NEW_LINE INDENT return arr [ mid ] NEW_LINE DEDENT if ( arr [ mid ] > arr [ mid + 1 ] and arr [ mid ] < arr [ mid - 1 ] ) : NEW_LINE INDENT return findMaximum ( arr , low , mid - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return findMaximum ( arr , mid + 1 , high ) NEW_LINE DEDENT DEDENT

BLEU: 82.78
Edit Sim: 29


Src: 
int stringReduction ( string str ) { int n = str . length ( ) ; int count [ 3 ] = { 0 } ; for ( int i = 0 ; i < n ; ++ i ) count [ str [ i ] - ' a ' ] ++ ; if ( count [ 0 ] == n || count [ 1 ] == n || count [ 2 ] == n ) return n ; if ( ( count [ 0 ] % 2 ) == ( count [ 1 ] % 2 ) && ( count [ 1 ] % 2 ) == ( count [ 2 ] % 2 ) ) return 2 ; return 1 ; }
Ref: 
def stringReduction ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE count = [ 0 ] * 3 NEW_LINE for i in range ( n ) : NEW_LINE INDENT count [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT if ( count [ 0 ] == n or count [ 1 ] == n or count [ 2 ] == n ) : NEW_LINE INDENT return n NEW_LINE DEDENT if ( ( count [ 0 ] % 2 ) == ( count [ 1 ] % 2 ) and ( count [ 1 ] % 2 ) == ( count [ 2 ] % 2 ) ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT return 1 NEW_LINE DEDENT
Hyp: 
def stringReduction ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE count = [ 0 for i in range ( 3 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT count [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT if ( count [ 0 ] == n or count [ 1 ] == n or count [ 2 ] == n ) : NEW_LINE INDENT return n NEW_LINE DEDENT if ( ( count [ 0 ] % 2 ) == ( count [ 1 ] % 2 ) and ( count [ 1 ] % 2 ) == ( count [ 2 ] % 2 ) ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT return 1 NEW_LINE DEDENT

BLEU: 93.43
Edit Sim: 19


Src: 
int KnapSack ( int val [ ] , int wt [ ] , int n , int W ) { int dp [ W + 1 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = W ; j >= wt [ i ] ; j -- ) dp [ j ] = max ( dp [ j ] , val [ i ] + dp [ j - wt [ i ] ] ) ; return dp [ W ] ; }
Ref: 
def KnapSack ( val , wt , n , W ) : NEW_LINE INDENT dp = [ 0 ] * ( W + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( W , wt [ i ] , - 1 ) : NEW_LINE INDENT dp [ j ] = max ( dp [ j ] , val [ i ] + dp [ j - wt [ i ] ] ) NEW_LINE DEDENT DEDENT return dp [ W ] NEW_LINE DEDENT
Hyp: 
def KnapSack ( val , wt , n , W ) : NEW_LINE INDENT dp = [ 0 for i in range ( W + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( W , wt [ i ] + 1 ) : NEW_LINE INDENT dp [ j ] = max ( dp [ j ] , val [ i ] + dp [ j - wt [ i ] ] ) NEW_LINE DEDENT DEDENT return dp [ W ] NEW_LINE DEDENT

BLEU: 88.77
Edit Sim: 18


Src: 
long long int findSum ( int n ) { long long int multiTerms = n * ( n + 1 ) / 2 ; long long int sum = multiTerms ; for ( int i = 2 ; i <= n ; i ++ ) { multiTerms = multiTerms - ( i - 1 ) ; sum = sum + multiTerms * i ; } return sum ; }
Ref: 
def findSum ( n ) : NEW_LINE INDENT multiTerms = n * ( n + 1 ) // 2 NEW_LINE sm = multiTerms NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT multiTerms = multiTerms - ( i - 1 ) NEW_LINE sm = sm + multiTerms * i NEW_LINE DEDENT return sm NEW_LINE DEDENT
Hyp: 
def findSum ( n ) : NEW_LINE INDENT multiTerms = n * ( n + 1 ) / 2 NEW_LINE sum = multiTerms NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT multiTerms = multiTerms - ( i - 1 ) NEW_LINE sum = sum + multiTerms * i NEW_LINE DEDENT return sum NEW_LINE DEDENT

BLEU: 80.95
Edit Sim: 5


Src: 
void recursiveReverse ( string & str ) { stack < char > st ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) st . push ( str [ i ] ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { str [ i ] = st . top ( ) ; st . pop ( ) ; } }
Ref: 
def recursiveReverse ( str ) : NEW_LINE INDENT stack = [ ] NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT stack . append ( str [ i ] ) NEW_LINE DEDENT for i in range ( len ( str ) ) : NEW_LINE INDENT str [ i ] = stack . pop ( ) NEW_LINE DEDENT DEDENT
Hyp: 
def recursiveReverse ( str ) : NEW_LINE INDENT st = [ ] NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT st . append ( str [ i ] ) NEW_LINE DEDENT for i in range ( len ( str ) ) : NEW_LINE INDENT str [ i ] = st [ - 1 ] NEW_LINE st . pop ( ) NEW_LINE DEDENT DEDENT

BLEU: 80.04
Edit Sim: 26


Src: 
int subArraySum ( int arr [ ] , int n , int sum ) { int curr_sum , i , j ; for ( i = 0 ; i < n ; i ++ ) { curr_sum = arr [ i ] ; for ( j = i + 1 ; j <= n ; j ++ ) { if ( curr_sum == sum ) { cout << " Sum ▁ found ▁ between ▁ indexes ▁ " << i << " ▁ and ▁ " << j - 1 ; return 1 ; } if ( curr_sum > sum || j == n ) break ; curr_sum = curr_sum + arr [ j ] ; } } cout << " No ▁ subarray ▁ found " ; return 0 ; }
Ref: 
def subArraySum ( arr , n , sum ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT curr_sum = arr [ i ] NEW_LINE j = i + 1 NEW_LINE while j <= n : NEW_LINE INDENT if curr_sum == sum : NEW_LINE INDENT print ( " Sum ▁ found ▁ between " ) NEW_LINE print ( " indexes ▁ % d ▁ and ▁ % d " % ( i , j - 1 ) ) NEW_LINE return 1 NEW_LINE DEDENT if curr_sum > sum or j == n : NEW_LINE INDENT break NEW_LINE DEDENT curr_sum = curr_sum + arr [ j ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT print ( " No ▁ subarray ▁ found " ) NEW_LINE return 0 NEW_LINE DEDENT
Hyp: 
def subArraySum ( arr , n , Sum ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT curr_sum = arr [ i ] NEW_LINE for j in range ( i + 1 , n + 1 ) : NEW_LINE INDENT if curr_sum == Sum : NEW_LINE INDENT print ( " Sum ▁ found ▁ between ▁ indexes ▁ " , i , " and ▁ " , j - 1 ) NEW_LINE return 1 NEW_LINE DEDENT if curr_sum > Sum or j == n : NEW_LINE INDENT break NEW_LINE DEDENT curr_sum = curr_sum + arr [ j ] NEW_LINE DEDENT DEDENT print ( " No ▁ subarray ▁ found " ) NEW_LINE return 0 NEW_LINE DEDENT

BLEU: 67.03
Edit Sim: 88


Src: 
int getSingle ( int arr [ ] , int n ) { int result = 0 ; int x , sum ; for ( int i = 0 ; i < INT_SIZE ; i ++ ) { sum = 0 ; x = ( 1 << i ) ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] & x ) sum ++ ; } if ( sum % 3 ) result |= x ; } return result ; }
Ref: 
def getSingle ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 0 , INT_SIZE ) : NEW_LINE INDENT sm = 0 NEW_LINE x = ( 1 << i ) NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ j ] & x ) : NEW_LINE INDENT sm = sm + 1 NEW_LINE DEDENT DEDENT if ( sm % 3 ) : NEW_LINE INDENT result = result | x NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
Hyp: 
def getSingle ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 0 , INT_SIZE ) : NEW_LINE INDENT sum = 0 NEW_LINE x = ( 1 << i ) NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ j ] & x ) : NEW_LINE INDENT sum += 1 NEW_LINE DEDENT DEDENT if ( sum % 3 ) : NEW_LINE INDENT result |= x NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT

BLEU: 83.14
Edit Sim: 18


Src: 
unsigned int getModulo ( unsigned int n , unsigned int d ) { return ( n & ( d - 1 ) ) ; }
Ref: 
def getModulo ( n , d ) : NEW_LINE INDENT return ( n & ( d - 1 ) ) NEW_LINE DEDENT
Hyp: 
def getModulo ( n , d ) : NEW_LINE INDENT return ( n & ( d - 1 ) ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
bool allCharactersSame ( string s ) { int n = s . length ( ) ; for ( int i = 1 ; i < n ; i ++ ) if ( s [ i ] != s [ 0 ] ) return false ; return true ; }
Ref: 
def allCharactersSame ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if s [ i ] != s [ 0 ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
Hyp: 
def allCharactersSame ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( s [ i ] != s [ 0 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT

BLEU: 89.88
Edit Sim: 4


Src: 
long long int maxDecimalValue ( int mat [ ] [ N ] , int i , int j , int p ) { if ( i >= N || j >= N ) return 0 ; int result = max ( maxDecimalValue ( mat , i , j + 1 , p + 1 ) , maxDecimalValue ( mat , i + 1 , j , p + 1 ) ) ; if ( mat [ i ] [ j ] == 1 ) return pow ( 2 , p ) + result ; else return result ; }
Ref: 
def maxDecimalValue ( mat , i , j , p ) : NEW_LINE INDENT if i >= N or j >= N : NEW_LINE INDENT return 0 NEW_LINE DEDENT result = max ( maxDecimalValue ( mat , i , j + 1 , p + 1 ) , maxDecimalValue ( mat , i + 1 , j , p + 1 ) ) NEW_LINE if mat [ i ] [ j ] == 1 : NEW_LINE INDENT return pow ( 2 , p ) + result NEW_LINE DEDENT else : NEW_LINE INDENT return result NEW_LINE DEDENT DEDENT
Hyp: 
def maxDecimalValue ( mat , i , j , p ) : NEW_LINE INDENT if i >= N or j >= N : NEW_LINE INDENT return 0 NEW_LINE DEDENT result = max ( maxDecimalValue ( mat , i , j + 1 , p + 1 ) , maxDecimalValue ( mat , i + 1 , j , p + 1 ) ) NEW_LINE if mat [ i ] [ j ] == 1 : NEW_LINE INDENT return pow ( 2 , p ) + result NEW_LINE DEDENT else : NEW_LINE INDENT return result NEW_LINE DEDENT DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
long long int countBT ( int h ) { long long int dp [ h + 1 ] ; dp [ 0 ] = dp [ 1 ] = 1 ; for ( int i = 2 ; i <= h ; i ++ ) { dp [ i ] = ( dp [ i - 1 ] * ( ( 2 * dp [ i - 2 ] ) % mod + dp [ i - 1 ] ) % mod ) % mod ; } return dp [ h ] ; }
Ref: 
def countBT ( h ) : NEW_LINE INDENT MOD = 1000000007 NEW_LINE dp = [ 0 for i in range ( h + 1 ) ] NEW_LINE dp [ 0 ] = 1 NEW_LINE dp [ 1 ] = 1 NEW_LINE for i in range ( 2 , h + 1 ) : NEW_LINE INDENT dp [ i ] = ( dp [ i - 1 ] * ( ( 2 * dp [ i - 2 ] ) % MOD + dp [ i - 1 ] ) % MOD ) % MOD NEW_LINE DEDENT return dp [ h ] NEW_LINE DEDENT
Hyp: 
def countBT ( h ) : NEW_LINE INDENT dp = [ 0 for i in range ( h + 1 ) ] NEW_LINE dp [ 0 ] = dp [ 1 ] = 1 NEW_LINE for i in range ( 2 , h + 1 ) : NEW_LINE INDENT dp [ i ] = ( dp [ i - 1 ] * ( ( 2 * dp [ i - 2 ] ) % mod + dp [ i - 1 ] ) % mod ) % mod NEW_LINE DEDENT return dp [ h ] NEW_LINE DEDENT

BLEU: 83.79
Edit Sim: 46


Src: 
int getInvCount ( int arr [ ] , int n ) { int inv_count = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] > arr [ j ] ) inv_count ++ ; return inv_count ; }
Ref: 
def getInvCount ( arr , n ) : NEW_LINE INDENT inv_count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] ) : NEW_LINE INDENT inv_count += 1 NEW_LINE DEDENT DEDENT DEDENT return inv_count NEW_LINE DEDENT
Hyp: 
def getInvCount ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE inv_count = 0 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if arr [ i ] > arr [ j ] : NEW_LINE INDENT inv_count += 1 NEW_LINE DEDENT DEDENT DEDENT return inv_count NEW_LINE DEDENT

BLEU: 73.84
Edit Sim: 41


Src: 
void printRect ( int X [ ] , int Y [ ] , int n ) { int Xmax = * max_element ( X , X + n ) ; int Xmin = * min_element ( X , X + n ) ; int Ymax = * max_element ( Y , Y + n ) ; int Ymin = * min_element ( Y , Y + n ) ; cout << " { " << Xmin << " , ▁ " << Ymin << " } " << endl ; cout << " { " << Xmin << " , ▁ " << Ymax << " } " << endl ; cout << " { " << Xmax << " , ▁ " << Ymax << " } " << endl ; cout << " { " << Xmax << " , ▁ " << Ymin << " } " << endl ; }
Ref: 
def printRect ( X , Y , n ) : NEW_LINE INDENT Xmax = max ( X ) NEW_LINE Xmin = min ( X ) NEW_LINE Ymax = max ( Y ) NEW_LINE Ymin = min ( Y ) NEW_LINE print ( " { " , Xmin , " , ▁ " , Ymin , " } " , sep = " " ) NEW_LINE print ( " { " , Xmin , " , ▁ " , Ymax , " } " , sep = " " ) NEW_LINE print ( " { " , Xmax , " , ▁ " , Ymax , " } " , sep = " " ) NEW_LINE print ( " { " , Xmax , " , ▁ " , Ymin , " } " , sep = " " ) NEW_LINE DEDENT
Hyp: 
def printRect ( X , Y , n ) : NEW_LINE INDENT Xmax = max ( X , X + n ) NEW_LINE Xmin = min ( X , X + n ) NEW_LINE Ymax = max ( Y , Y + n ) NEW_LINE Ymin = min ( Y , Y + n ) NEW_LINE print ( " { " , Xmin , " , ▁ " , Ymin , " } " , endl ) NEW_LINE print ( " { " , Xmin , " , ▁ " , Ymax , " } " , endl ) NEW_LINE print ( " { " , Xmax , " , ▁ " , Ymax , " } " , endl ) NEW_LINE print ( " { " , Xmax , " , ▁ " , Ymin , " } " , endl ) NEW_LINE DEDENT

BLEU: 77.54
Edit Sim: 64


Src: 
int dealnnoy ( int n , int m ) { int dp [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) dp [ i ] [ 0 ] = 1 ; for ( int i = 0 ; i <= m ; i ++ ) dp [ 0 ] [ i ] = 1 ; for ( int i = 1 ; i <= m ; i ++ ) for ( int j = 1 ; j <= n ; j ++ ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] + dp [ i ] [ j - 1 ] ; return dp [ m ] [ n ] ; }
Ref: 
def dealnnoy ( n , m ) : NEW_LINE INDENT dp = [ [ 0 for x in range ( n + 1 ) ] for x in range ( m + 1 ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT dp [ 0 ] [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , m + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] + dp [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT return dp [ m ] [ n ] NEW_LINE DEDENT
Hyp: 
def dealnnoy ( n , m ) : NEW_LINE INDENT if ( n == 0 or m == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return ( dp [ m + 1 ] [ n + 1 ] ) NEW_LINE DEDENT

BLEU: 2.99
Edit Sim: 365


Src: 
int power ( int x , unsigned int y , int p ) { int res = 1 ; x = x % p ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % p ; y = y >> 1 ; x = ( x * x ) % p ; } return res ; }
Ref: 
def power ( x , y , p ) : NEW_LINE INDENT res = 1 NEW_LINE x = x % p NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( ( y & 1 ) == 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT y = y >> 1 NEW_LINE x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT
Hyp: 
def power ( x , y , p ) : NEW_LINE INDENT res = 1 NEW_LINE x = x % p NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT y = y >> 1 NEW_LINE x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT

BLEU: 93.23
Edit Sim: 9


Src: 
bool isValidISBN ( string & isbn ) { int n = isbn . length ( ) ; if ( n != 10 ) return false ; int sum = 0 ; for ( int i = 0 ; i < 9 ; i ++ ) { int digit = isbn [ i ] - '0' ; if ( 0 > digit || 9 < digit ) return false ; sum += ( digit * ( 10 - i ) ) ; } char last = isbn [ 9 ] ; if ( last != ' X ' && ( last < '0' || last > '9' ) ) return false ; sum += ( ( last == ' X ' ) ? 10 : ( last - '0' ) ) ; return ( sum % 11 == 0 ) ; }
Ref: 
def isValidISBN ( isbn ) : NEW_LINE INDENT if len ( isbn ) != 10 : NEW_LINE INDENT return False NEW_LINE DEDENT _sum = 0 NEW_LINE for i in range ( 9 ) : NEW_LINE INDENT if 0 <= int ( isbn [ i ] ) <= 9 : NEW_LINE INDENT _sum += int ( isbn [ i ] ) * ( 10 - i ) NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if ( isbn [ 9 ] != ' X ' and 0 <= int ( isbn [ 9 ] ) <= 9 ) : NEW_LINE INDENT return False NEW_LINE DEDENT _sum += 10 if isbn [ 9 ] == ' X ' else int ( isbn [ 9 ] ) NEW_LINE return ( _sum % 11 == 0 ) NEW_LINE DEDENT
Hyp: 
def isValidISBN ( isbn ) : NEW_LINE INDENT n = len ( isbn ) NEW_LINE if n != 10 : NEW_LINE INDENT return False NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( 9 ) : NEW_LINE INDENT digit = isbn [ i ] - ord ( '0' ) ; NEW_LINE if ( 0 > digit or 9 < digit ) : NEW_LINE INDENT return False NEW_LINE DEDENT sum += ( digit * ( 10 - i ) ) NEW_LINE DEDENT last = isbn [ 9 ] NEW_LINE if ( last != ' X ' and ( last < '0' or last > '9' ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT sum += ( ( last == ' X ' ) ? 10 : ( last - ord ( '0' ) ) ) NEW_LINE return ( sum % 11 == 0 ) NEW_LINE DEDENT

BLEU: 45.58
Edit Sim: 205


Src: 
void NFG ( int a [ ] , int n , int freq [ ] ) { stack < int > s ; s . push ( 0 ) ; int res [ n ] = { 0 } ; for ( int i = 1 ; i < n ; i ++ ) { if ( freq [ a [ s . top ( ) ] ] > freq [ a [ i ] ] ) s . push ( i ) ; else { while ( freq [ a [ s . top ( ) ] ] < freq [ a [ i ] ] && ! s . empty ( ) ) { res [ s . top ( ) ] = a [ i ] ; s . pop ( ) ; } s . push ( i ) ; } } while ( ! s . empty ( ) ) { res [ s . top ( ) ] = - 1 ; s . pop ( ) ; } for ( int i = 0 ; i < n ; i ++ ) { cout << res [ i ] << " ▁ " ; } }
Ref: 
def NFG ( a , n ) : NEW_LINE INDENT if ( n <= 0 ) : NEW_LINE INDENT print ( " List ▁ empty " ) NEW_LINE return [ ] NEW_LINE DEDENT stack = [ 0 ] * n NEW_LINE freq = { } NEW_LINE for i in a : NEW_LINE INDENT freq [ a [ i ] ] = 0 NEW_LINE DEDENT for i in a : NEW_LINE INDENT freq [ a [ i ] ] += 1 NEW_LINE DEDENT res = [ 0 ] * n NEW_LINE top = - 1 NEW_LINE top += 1 NEW_LINE stack [ top ] = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( freq [ a [ stack [ top ] ] ] > freq [ a [ i ] ] ) : NEW_LINE INDENT top += 1 NEW_LINE stack [ top ] = i NEW_LINE DEDENT else : NEW_LINE INDENT while ( top > - 1 and freq [ a [ stack [ top ] ] ] < freq [ a [ i ] ] ) : NEW_LINE INDENT res [ stack [ top ] ] = a [ i ] NEW_LINE top -= 1 NEW_LINE DEDENT top += 1 NEW_LINE stack [ top ] = i NEW_LINE DEDENT DEDENT while ( top > - 1 ) : NEW_LINE INDENT res [ stack [ top ] ] = - 1 NEW_LINE top -= 1 NEW_LINE DEDENT return res NEW_LINE DEDENT
Hyp: 
def NFG ( a , n , freq ) : NEW_LINE INDENT s = [ ] NEW_LINE res = [ 0 ] * n NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if freq [ a [ s [ - 1 ] ] > freq [ a [ i ] ] : NEW_LINE INDENT s . append ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT while freq [ a [ s [ - 1 ] ] < freq [ a [ i ] ] and len ( s ) != 0 : NEW_LINE INDENT res [ s [ - 1 ] ] = a [ i ] NEW_LINE s . pop ( ) NEW_LINE DEDENT s . append ( i ) NEW_LINE DEDENT DEDENT while len ( s ) != 0 : NEW_LINE INDENT res [ s [ - 1 ] ] = - 1 NEW_LINE s . pop ( ) NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( res [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT

BLEU: 36.61
Edit Sim: 492


Src: 
int swapBits ( unsigned int x , unsigned int p1 , unsigned int p2 , unsigned int n ) { unsigned int set1 = ( x >> p1 ) & ( ( 1U << n ) - 1 ) ; unsigned int set2 = ( x >> p2 ) & ( ( 1U << n ) - 1 ) ; unsigned int Xor = ( set1 ^ set2 ) ; Xor = ( Xor << p1 ) | ( Xor << p2 ) ; unsigned int result = x ^ Xor ; return result ; }
Ref: 
def swapBits ( x , p1 , p2 , n ) : NEW_LINE INDENT set1 = ( x >> p1 ) & ( ( 1 << n ) - 1 ) NEW_LINE set2 = ( x >> p2 ) & ( ( 1 << n ) - 1 ) NEW_LINE xor = ( set1 ^ set2 ) NEW_LINE xor = ( xor << p1 ) | ( xor << p2 ) NEW_LINE result = x ^ xor NEW_LINE return result NEW_LINE DEDENT
Hyp: 
def swapBits ( x , p1 , p2 , n ) : NEW_LINE INDENT set1 = ( x >> p1 ) & ( ( 1U << n ) - 1 ) NEW_LINE set2 = ( x >> p2 ) & ( ( 1U << n ) - 1 ) NEW_LINE Xor = ( set1 ^ set2 ) NEW_LINE Xor = ( Xor << p1 ) | ( Xor << p2 ) NEW_LINE result = x ^ Xor NEW_LINE return result NEW_LINE DEDENT

BLEU: 78.13
Edit Sim: 7


Src: 
void printEqualSumSets ( int arr [ ] , int n ) { int i , currSum ; int sum = accumulate ( arr , arr + n , 0 ) ; if ( sum & 1 ) { cout << " - 1" ; return ; } int k = sum >> 1 ; bool dp [ n + 1 ] [ k + 1 ] ; for ( i = 1 ; i <= k ; i ++ ) dp [ 0 ] [ i ] = false ; for ( i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = true ; for ( i = 1 ; i <= n ; i ++ ) { for ( currSum = 1 ; currSum <= k ; currSum ++ ) { dp [ i ] [ currSum ] = dp [ i - 1 ] [ currSum ] ; if ( arr [ i - 1 ] <= currSum ) dp [ i ] [ currSum ] = dp [ i ] [ currSum ] | dp [ i - 1 ] [ currSum - arr [ i - 1 ] ] ; } } vector < int > set1 , set2 ; if ( ! dp [ n ] [ k ] ) { cout << " - 1 \n " ; return ; } i = n ; currSum = k ; while ( i > 0 && currSum >= 0 ) { if ( dp [ i - 1 ] [ currSum ] ) { i -- ; set2 . push_back ( arr [ i ] ) ; } else if ( dp [ i - 1 ] [ currSum - arr [ i - 1 ] ] ) { i -- ; currSum -= arr [ i ] ; set1 . push_back ( arr [ i ] ) ; } } cout << " Set ▁ 1 ▁ elements : ▁ " ; for ( i = 0 ; i < set1 . size ( ) ; i ++ ) cout << set1 [ i ] << " ▁ " ; cout << " \n Set ▁ 2 ▁ elements : ▁ " ; for ( i = 0 ; i < set2 . size ( ) ; i ++ ) cout << set2 [ i ] << " ▁ " ; }
Ref: 
def printEqualSumSets ( arr , n ) : NEW_LINE INDENT sum_array = sum ( arr ) NEW_LINE if ( sum_array & 1 ) : NEW_LINE INDENT print ( " - 1" ) NEW_LINE return NEW_LINE DEDENT k = sum_array >> 1 NEW_LINE dp = np . zeros ( ( n + 1 , k + 1 ) ) NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT dp [ 0 ] [ i ] = False NEW_LINE DEDENT for i in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = True NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for currSum in range ( 1 , k + 1 ) : NEW_LINE INDENT dp [ i ] [ currSum ] = dp [ i - 1 ] [ currSum ] NEW_LINE if ( arr [ i - 1 ] <= currSum ) : NEW_LINE INDENT dp [ i ] [ currSum ] = ( dp [ i ] [ currSum ] or dp [ i - 1 ] [ currSum - arr [ i - 1 ] ] ) NEW_LINE DEDENT DEDENT DEDENT set1 , set2 = [ ] , [ ] NEW_LINE if ( not dp [ n ] [ k ] ) : NEW_LINE INDENT print ( " - 1" ) NEW_LINE return NEW_LINE DEDENT i = n NEW_LINE currSum = k NEW_LINE while ( i > 0 and currSum >= 0 ) : NEW_LINE INDENT if ( dp [ i - 1 ] [ currSum ] ) : NEW_LINE INDENT i -= 1 NEW_LINE set2 . append ( arr [ i ] ) NEW_LINE DEDENT elif ( dp [ i - 1 ] [ currSum - arr [ i - 1 ] ] ) : NEW_LINE INDENT i -= 1 NEW_LINE currSum -= arr [ i ] NEW_LINE set1 . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT print ( " Set ▁ 1 ▁ elements : " , end = " ▁ " ) NEW_LINE for i in range ( len ( set1 ) ) : NEW_LINE INDENT print ( set1 [ i ] , end = " ▁ " ) NEW_LINE DEDENT print ( " \n Set ▁ 2 ▁ elements : " , end = " ▁ " ) NEW_LINE for i in range ( len ( set2 ) ) : NEW_LINE INDENT print ( set2 [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
Hyp: 
def printEqualSumSets ( arr , n ) : NEW_LINE INDENT Sum = sum ( arr ) NEW_LINE if Sum & 1 : NEW_LINE INDENT print ( " - 1" ) NEW_LINE return NEW_LINE DEDENT k = Sum >> 1 NEW_LINE dp = [ [ False for i in range ( k + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT dp [ 0 ] [ i ] = False NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for currSum in range ( 1 , k + 1 ) : NEW_LINE INDENT dp [ i ] [ currSum ] = dp [ i - 1 ] [ currSum ] NEW_LINE if arr [ i - 1 ] <= currSum : NEW_LINE INDENT dp [ i ] [ currSum ] = dp [ i ] [ currSum ] | dp [ i - 1 ] [ currSum - arr [ i - 1 ] ] NEW_LINE DEDENT DEDENT DEDENT i = n NEW_LINE currSum = k NEW_LINE while i > 0 and currSum >= 0 : NEW_LINE INDENT if dp [ i - 1 ] [ currSum ] : NEW_LINE INDENT i -= 1 NEW_LINE set2 . append ( arr [ i ] ) NEW_LINE DEDENT elif dp [ i - 1 ] [ currSum - arr [ i - 1 ] ] : NEW_LINE INDENT i -= 1 NEW_LINE currSum -= arr [ i ] NEW_LINE DEDENT set1 = list ( set1 ) NEW_LINE for i in range ( len ( set1 ) ) : NEW_LINE INDENT print ( set1 [ i ] , end = " ▁ " ) NEW_LINE DEDENT print ( " Set ▁ 2 ▁ elements : ▁ " ) NEW_LINE for i in range ( len ( set2 ) ) : NEW_LINE INDENT print ( set2 [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT

BLEU: 66.28
Edit Sim: 359


Src: 
int power ( int n ) { if ( n == 1 ) return 2 ; return 2 * power ( n - 1 ) ; }
Ref: 
def power ( n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return 2 NEW_LINE DEDENT return 2 * power ( n - 1 ) NEW_LINE DEDENT
Hyp: 
def power ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT return 2 * power ( n - 1 , 2 ) NEW_LINE DEDENT

BLEU: 74.12
Edit Sim: 8


Src: 
void findElements ( int arr [ ] , int n ) { int first = INT_MIN , second = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > first ) { second = first ; first = arr [ i ] ; } else if ( arr [ i ] > second ) second = arr [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] < second ) cout << arr [ i ] << " ▁ " ; }
Ref: 
def findElements ( arr , n ) : NEW_LINE INDENT first = - sys . maxsize NEW_LINE second = - sys . maxsize NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] > first ) : NEW_LINE INDENT second = first NEW_LINE first = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > second ) : NEW_LINE INDENT second = arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] < second ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
Hyp: 
def findElements ( arr , n ) : NEW_LINE INDENT first = - 100000000 NEW_LINE second = - 100000000 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] > first ) : NEW_LINE INDENT second = first NEW_LINE first = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > second ) : NEW_LINE INDENT second = arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] < second ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT

BLEU: 92.52
Edit Sim: 26


Src: 
int lastPosition ( int n , int m , int k ) { if ( m <= n - k + 1 ) return m + k - 1 ; m = m - ( n - k + 1 ) ; return ( m % n == 0 ) ? n : ( m % n ) ; }
Ref: 
def lastPosition ( n , m , k ) : NEW_LINE INDENT if ( m <= n - k + 1 ) : NEW_LINE INDENT return m + k - 1 NEW_LINE DEDENT m = m - ( n - k + 1 ) NEW_LINE if ( m % n == 0 ) : NEW_LINE INDENT return n NEW_LINE DEDENT else : NEW_LINE INDENT return m % n NEW_LINE DEDENT DEDENT
Hyp: 
def lastPosition ( n , m , k ) : NEW_LINE INDENT if ( m <= n - k + 1 ) : NEW_LINE INDENT return m + k - 1 NEW_LINE DEDENT m = m - ( n - k + 1 ) NEW_LINE return ( n % n ) NEW_LINE DEDENT

BLEU: 63.5
Edit Sim: 91


Src: 
void reverseStr ( string & str ) { int n = str . length ( ) ; for ( int i = 0 , j = n - 1 ; i < j ; i ++ , j -- ) swap ( str [ i ] , str [ j ] ) ; }
Ref: 
def reverseStr ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE i , j = 0 , n - 1 NEW_LINE while i < j : NEW_LINE INDENT str [ i ] , str [ j ] = str [ j ] , str [ i ] NEW_LINE i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT DEDENT
Hyp: 
def reverseStr ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE i = 0 NEW_LINE j = n - 1 NEW_LINE while ( i < j ) : NEW_LINE INDENT str [ i ] , str [ j ] = str [ j ] , str [ i ] NEW_LINE i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT DEDENT

BLEU: 83.39
Edit Sim: 16


Src: 
int findMaximum ( int arr [ ] , int low , int high ) { int max = arr [ low ] ; int i ; for ( i = low + 1 ; i <= high ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; else break ; } return max ; }
Ref: 
def findMaximum ( arr , low , high ) : NEW_LINE INDENT max = arr [ low ] NEW_LINE i = low NEW_LINE for i in range ( high + 1 ) : NEW_LINE INDENT if arr [ i ] > max : NEW_LINE INDENT max = arr [ i ] NEW_LINE DEDENT DEDENT return max NEW_LINE DEDENT
Hyp: 
def findMaximum ( arr , low , high ) : NEW_LINE INDENT max = arr [ low ] NEW_LINE i = low + 1 NEW_LINE while i <= high : NEW_LINE INDENT if ( arr [ i ] > max ) : NEW_LINE INDENT max = arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return max NEW_LINE DEDENT

BLEU: 70.83
Edit Sim: 72


Src: 
int longestPrefixSuffix ( string s ) { int n = s . length ( ) ; int lps [ n ] ; lps [ 0 ] = 0 ; int len = 0 ; int i = 1 ; while ( i < n ) { if ( s [ i ] == s [ len ] ) { len ++ ; lps [ i ] = len ; i ++ ; } else { if ( len != 0 ) { len = lps [ len - 1 ] ; } else { lps [ i ] = 0 ; i ++ ; } } } int res = lps [ n - 1 ] ; return ( res > n / 2 ) ? n / 2 : res ; }
Ref: 
def longestPrefixSuffix ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE lps = [ 0 ] * n NEW_LINE l = 0 NEW_LINE i = 1 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( s [ i ] == s [ l ] ) : NEW_LINE INDENT l = l + 1 NEW_LINE lps [ i ] = l NEW_LINE i = i + 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( l != 0 ) : NEW_LINE INDENT l = lps [ l - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT lps [ i ] = 0 NEW_LINE i = i + 1 NEW_LINE DEDENT DEDENT DEDENT res = lps [ n - 1 ] NEW_LINE if ( res > n / 2 ) : NEW_LINE INDENT return n // 2 NEW_LINE DEDENT else : NEW_LINE INDENT return res NEW_LINE DEDENT DEDENT
Hyp: 
def longestPrefixSuffix ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE lps = [ 0 for x in range ( n ) ] NEW_LINE lps [ 0 ] = 0 NEW_LINE len = 0 NEW_LINE i = 1 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( s [ i ] == s [ len ] ) : NEW_LINE INDENT len += 1 NEW_LINE lps [ i ] = len NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( len != 0 ) : NEW_LINE INDENT len = lps [ len - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT lps [ i ] = 0 NEW_LINE i += 1 NEW_LINE DEDENT DEDENT DEDENT res = lps [ n - 1 ] NEW_LINE return ( res > n // 2 ) ? n // 2 : res NEW_LINE DEDENT

BLEU: 65.74
Edit Sim: 151


Src: 
int MaxTotalRectangleArea ( int a [ ] , int n ) { sort ( a , a + n , greater < int > ( ) ) ; int sum = 0 ; bool flag = false ; int len ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( a [ i ] == a [ i + 1 ] || a [ i ] - a [ i + 1 ] == 1 ) && ( ! flag ) ) { flag = true ; len = a [ i + 1 ] ; i ++ ; } else if ( ( a [ i ] == a [ i + 1 ] || a [ i ] - a [ i + 1 ] == 1 ) && ( flag ) ) { sum = sum + a [ i + 1 ] * len ; flag = false ; i ++ ; } } return sum ; }
Ref: 
def MaxTotalRectangleArea ( a , n ) : NEW_LINE INDENT a . sort ( reverse = True ) NEW_LINE sum = 0 NEW_LINE flag = False NEW_LINE len = 0 NEW_LINE i = 0 NEW_LINE while ( i < n - 1 ) : NEW_LINE INDENT if ( i != 0 ) : NEW_LINE INDENT i = i + 1 NEW_LINE DEDENT if ( ( a [ i ] == a [ i + 1 ] or a [ i ] - a [ i + 1 ] == 1 ) and flag == False ) : NEW_LINE INDENT flag = True NEW_LINE len = a [ i + 1 ] NEW_LINE i = i + 1 NEW_LINE DEDENT elif ( ( a [ i ] == a [ i + 1 ] or a [ i ] - a [ i + 1 ] == 1 ) and flag == True ) : NEW_LINE INDENT sum = sum + a [ i + 1 ] * len NEW_LINE flag = False NEW_LINE i = i + 1 NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
Hyp: 
def MaxTotalRectangleArea ( a , n ) : NEW_LINE INDENT a . sort ( reverse = True ) NEW_LINE sum = 0 NEW_LINE flag = False NEW_LINE len = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( a [ i ] == a [ i + 1 ] or a [ i ] - a [ i + 1 ] == 1 ) and ( not flag ) ) : NEW_LINE INDENT flag = True NEW_LINE len = a [ i + 1 ] NEW_LINE i += 1 NEW_LINE DEDENT elif ( ( a [ i ] == a [ i + 1 ] or a [ i ] - a [ i + 1 ] == 1 ) and ( flag ) ) : NEW_LINE INDENT sum = sum + a [ i + 1 ] * len NEW_LINE flag = False NEW_LINE i += 1 NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT

BLEU: 74.71
Edit Sim: 112


Src: 
void printFibonacciNumbers ( int n ) { int f1 = 0 , f2 = 1 , i ; if ( n < 1 ) return ; for ( i = 1 ; i <= n ; i ++ ) { cout << f2 << " ▁ " ; int next = f1 + f2 ; f1 = f2 ; f2 = next ; } }
Ref: 
def printFibonacciNumbers ( n ) : NEW_LINE INDENT f1 = 0 NEW_LINE f2 = 1 NEW_LINE if ( n < 1 ) : NEW_LINE INDENT return NEW_LINE DEDENT for x in range ( 0 , n ) : NEW_LINE INDENT print ( f2 , end = " ▁ " ) NEW_LINE next = f1 + f2 NEW_LINE f1 = f2 NEW_LINE f2 = next NEW_LINE DEDENT DEDENT
Hyp: 
def printFibonacciNumbers ( n ) : NEW_LINE INDENT f1 = 0 NEW_LINE f2 = 1 NEW_LINE if ( n < 1 ) : NEW_LINE INDENT return NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( f2 , end = " ▁ " ) NEW_LINE next = f1 + f2 NEW_LINE f1 = f2 NEW_LINE f2 = next NEW_LINE DEDENT DEDENT

BLEU: 87.76
Edit Sim: 6


Src: 
void minimizeWithKSwaps ( int arr [ ] , int n , int k ) { for ( int i = 0 ; i < n - 1 && k > 0 ; ++ i ) { int pos = i ; for ( int j = i + 1 ; j < n ; ++ j ) { if ( j - i > k ) break ; if ( arr [ j ] < arr [ pos ] ) pos = j ; } for ( int j = pos ; j > i ; -- j ) swap ( arr [ j ] , arr [ j - 1 ] ) ; k -= pos - i ; } }
Ref: 
def minimizeWithKSwaps ( arr , n , k ) : NEW_LINE INDENT for i in range ( n - 1 ) : NEW_LINE INDENT pos = i NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( j - i > k ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( arr [ j ] < arr [ pos ] ) : NEW_LINE INDENT pos = j NEW_LINE DEDENT DEDENT for j in range ( pos , i , - 1 ) : NEW_LINE INDENT arr [ j ] , arr [ j - 1 ] = arr [ j - 1 ] , arr [ j ] NEW_LINE DEDENT k -= pos - i NEW_LINE DEDENT DEDENT
Hyp: 
def minimizeWithKSwaps ( arr , n , k ) : NEW_LINE INDENT for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( k > 0 ) : NEW_LINE INDENT pos = i NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( j - i > k ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( arr [ j ] < arr [ pos ] ) : NEW_LINE INDENT pos = j NEW_LINE DEDENT DEDENT for j in range ( pos , i , - 1 ) : NEW_LINE INDENT t = arr [ j ] NEW_LINE arr [ j ] = arr [ j - 1 ] NEW_LINE arr [ j - 1 ] = t NEW_LINE DEDENT k = k - pos - i NEW_LINE DEDENT DEDENT DEDENT

BLEU: 79.27
Edit Sim: 79


Src: 
bool isHeap ( int arr [ ] , int i , int n ) { if ( i > ( n - 2 ) / 2 ) return true ; if ( arr [ i ] >= arr [ 2 * i + 1 ] && arr [ i ] >= arr [ 2 * i + 2 ] && isHeap ( arr , 2 * i + 1 , n ) && isHeap ( arr , 2 * i + 2 , n ) ) return true ; return false ; }
Ref: 
def isHeap ( arr , i , n ) : NEW_LINE INDENT if i > int ( ( n - 2 ) / 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( arr [ i ] >= arr [ 2 * i + 1 ] and arr [ i ] >= arr [ 2 * i + 2 ] and isHeap ( arr , 2 * i + 1 , n ) and isHeap ( arr , 2 * i + 2 , n ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
Hyp: 
def isHeap ( arr , i , n ) : NEW_LINE INDENT if i > ( n - 2 ) // 2 : NEW_LINE INDENT return True NEW_LINE DEDENT if ( arr [ i ] >= arr [ 2 * i + 1 ] and arr [ i ] >= arr [ 2 * i + 2 ] and isHeap ( arr , 2 * i + 1 , n ) and isHeap ( arr , 2 * i + 2 , n ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT

BLEU: 92.03
Edit Sim: 9


Src: 
int findLength ( string str , int n ) { int ans = 0 ; for ( int i = 0 ; i <= n - 2 ; i ++ ) { int l = i , r = i + 1 ; int lsum = 0 , rsum = 0 ; while ( r < n && l >= 0 ) { lsum += str [ l ] - '0' ; rsum += str [ r ] - '0' ; if ( lsum == rsum ) ans = max ( ans , r - l + 1 ) ; l -- ; r ++ ; } } return ans ; }
Ref: 
def findLength ( st , n ) : NEW_LINE INDENT total = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT total [ i ] = ( total [ i - 1 ] + int ( st [ i - 1 ] ) - int ( '0' ) ) NEW_LINE DEDENT ans = 0 NEW_LINE l = 2 NEW_LINE while ( l <= n ) : NEW_LINE INDENT for i in range ( n - l + 1 ) : NEW_LINE INDENT j = i + l - 1 NEW_LINE if ( total [ i + int ( l / 2 ) ] - total [ i ] == total [ i + l ] - total [ i + int ( l / 2 ) ] ) : NEW_LINE INDENT ans = max ( ans , l ) NEW_LINE DEDENT DEDENT l = l + 2 NEW_LINE DEDENT return ans NEW_LINE DEDENT
Hyp: 
def findLength ( str , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT l = i NEW_LINE r = i + 1 NEW_LINE lsum = 0 NEW_LINE rsum = 0 NEW_LINE while ( r < n and l >= 0 ) : NEW_LINE INDENT lsum += ord ( str [ l ] ) - ord ( '0' ) NEW_LINE rsum += ord ( str [ r ] ) - ord ( '0' ) NEW_LINE if ( lsum == rsum ) : NEW_LINE INDENT ans = max ( ans , r - l + 1 ) NEW_LINE DEDENT l -= 1 NEW_LINE r += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT

BLEU: 27.77
Edit Sim: 256


Src: 
int countSubarrays ( int arr [ ] , int n ) { int difference = 0 ; int ans = 0 ; int hash_positive [ n + 1 ] , hash_negative [ n + 1 ] ; fill_n ( hash_positive , n + 1 , 0 ) ; fill_n ( hash_negative , n + 1 , 0 ) ; hash_positive [ 0 ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] & 1 == 1 ) difference ++ ; else difference -- ; if ( difference < 0 ) { ans += hash_negative [ - difference ] ; hash_negative [ - difference ] ++ ; } else { ans += hash_positive [ difference ] ; hash_positive [ difference ] ++ ; } } return ans ; }
Ref: 
def countSubarrays ( arr , n ) : NEW_LINE INDENT difference = 0 NEW_LINE ans = 0 NEW_LINE hash_positive = [ 0 ] * ( n + 1 ) NEW_LINE hash_negative = [ 0 ] * ( n + 1 ) NEW_LINE hash_positive [ 0 ] = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] & 1 == 1 ) : NEW_LINE INDENT difference = difference + 1 NEW_LINE DEDENT else : NEW_LINE INDENT difference = difference - 1 NEW_LINE DEDENT if ( difference < 0 ) : NEW_LINE INDENT ans += hash_negative [ - difference ] NEW_LINE hash_negative [ - difference ] = hash_negative [ - difference ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += hash_positive [ difference ] NEW_LINE hash_positive [ difference ] = hash_positive [ difference ] + 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
Hyp: 
def countSubarrays ( arr , n ) : NEW_LINE INDENT difference = 0 NEW_LINE ans = 0 NEW_LINE hash_positive = [ 0 ] * ( n + 1 ) NEW_LINE hash_negative = [ 0 ] * ( n + 1 ) NEW_LINE fill_n ( hash_positive , n + 1 , 0 ) NEW_LINE fill_n ( hash_negative , n + 1 , 0 ) NEW_LINE hash_positive [ 0 ] = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] & 1 == 1 ) : NEW_LINE INDENT difference += 1 NEW_LINE DEDENT else : NEW_LINE INDENT difference -= 1 NEW_LINE DEDENT if ( difference < 0 ) : NEW_LINE INDENT ans += hash_negative [ - difference ] NEW_LINE hash_negative [ - difference ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += hash_positive [ difference ] NEW_LINE hash_positive [ difference ] += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT

BLEU: 80.46
Edit Sim: 186


Src: 
int knapSack ( int W , int wt [ ] , int val [ ] , int n ) { int i , w ; int K [ n + 1 ] [ W + 1 ] ; for ( i = 0 ; i <= n ; i ++ ) { for ( w = 0 ; w <= W ; w ++ ) { if ( i == 0 || w == 0 ) K [ i ] [ w ] = 0 ; else if ( wt [ i - 1 ] <= w ) K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) ; else K [ i ] [ w ] = K [ i - 1 ] [ w ] ; } } return K [ n ] [ W ] ; }
Ref: 
def knapSack ( W , wt , val , n ) : NEW_LINE INDENT K = [ [ 0 for x in range ( W + 1 ) ] for x in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for w in range ( W + 1 ) : NEW_LINE INDENT if i == 0 or w == 0 : NEW_LINE INDENT K [ i ] [ w ] = 0 NEW_LINE DEDENT elif wt [ i - 1 ] <= w : NEW_LINE INDENT K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) NEW_LINE DEDENT else : NEW_LINE INDENT K [ i ] [ w ] = K [ i - 1 ] [ w ] NEW_LINE DEDENT DEDENT DEDENT return K [ n ] [ W ] NEW_LINE DEDENT
Hyp: 
def knapSack ( W , wt , val , n ) : NEW_LINE INDENT K = [ [ 0 for x in range ( W + 1 ) ] for x in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for w in range ( W + 1 ) : NEW_LINE INDENT if i == 0 or w == 0 : NEW_LINE INDENT K [ i ] [ w ] = 0 NEW_LINE DEDENT elif wt [ i - 1 ] <= w : NEW_LINE INDENT K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) NEW_LINE DEDENT else : NEW_LINE INDENT K [ i ] [ w ] = K [ i - 1 ] [ w ] NEW_LINE DEDENT DEDENT DEDENT return K [ n ] [ W ] NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
void multiply ( int A [ ] [ N ] , int B [ ] [ N ] , int C [ ] [ N ] ) { int i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < N ; j ++ ) C [ i ] [ j ] = A [ i ] [ j ] - B [ i ] [ j ] ; }
Ref: 
def multiply ( A , B , C ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT C [ i ] [ j ] = A [ i ] [ j ] - B [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT
Hyp: 
def multiply ( A , B , C ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT C [ i ] [ j ] = A [ i ] [ j ] - B [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int maxDP ( int n ) { int res [ n + 1 ] ; res [ 0 ] = 0 ; res [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res [ i ] = max ( i , ( res [ i / 2 ] + res [ i / 3 ] + res [ i / 4 ] + res [ i / 5 ] ) ) ; return res [ n ] ; }
Ref: 
def maxDP ( n ) : NEW_LINE INDENT res = list ( ) NEW_LINE res . append ( 0 ) NEW_LINE res . append ( 1 ) NEW_LINE i = 2 NEW_LINE while i < n + 1 : NEW_LINE INDENT res . append ( max ( i , ( res [ int ( i / 2 ) ] + res [ int ( i / 3 ) ] + res [ int ( i / 4 ) ] + res [ int ( i / 5 ) ] ) ) ) NEW_LINE i = i + 1 NEW_LINE DEDENT return res [ n ] NEW_LINE DEDENT
Hyp: 
def maxDP ( n ) : NEW_LINE INDENT res = [ 0 for i in range ( n + 1 ) ] NEW_LINE res [ 0 ] = 0 NEW_LINE res [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT res [ i ] = max ( i , ( res [ i // 2 ] + res [ i // 3 ] + res [ i // 4 ] + res [ i // 5 ] ) ) NEW_LINE DEDENT return res [ n ] NEW_LINE DEDENT

BLEU: 37.29
Edit Sim: 127


Src: 
int findDiff ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int count = 0 , max_count = 0 , min_count = n ; for ( int i = 0 ; i < ( n - 1 ) ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) { count += 1 ; continue ; } else { max_count = max ( max_count , count ) ; min_count = min ( min_count , count ) ; count = 0 ; } } return ( max_count - min_count ) ; }
Ref: 
def findDiff ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE count = 0 max_count = 0 min_count = n NEW_LINE for i in range ( 0 , ( n - 1 ) ) : NEW_LINE INDENT if arr [ i ] == arr [ i + 1 ] : NEW_LINE INDENT count += 1 NEW_LINE continue NEW_LINE DEDENT else : NEW_LINE INDENT max_count = max ( max_count , count ) NEW_LINE min_count = min ( min_count , count ) NEW_LINE count = 0 NEW_LINE DEDENT DEDENT return max_count - min_count NEW_LINE DEDENT
Hyp: 
def findDiff ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE count = 0 NEW_LINE max_count = 0 NEW_LINE min_count = n NEW_LINE for i in range ( 0 , ( n - 1 ) ) : NEW_LINE INDENT if ( arr [ i ] == arr [ i + 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE continue NEW_LINE DEDENT else : NEW_LINE INDENT max_count = max ( max_count , count ) NEW_LINE min_count = min ( min_count , count ) NEW_LINE count = 0 NEW_LINE DEDENT DEDENT return ( max_count - min_count ) NEW_LINE DEDENT

BLEU: 85.45
Edit Sim: 26


Src: 
int countSink ( int n , int m , int edgeFrom [ ] , int edgeTo [ ] ) { int mark [ n ] ; memset ( mark , 0 , sizeof mark ) ; for ( int i = 0 ; i < m ; i ++ ) mark [ edgeFrom [ i ] ] = 1 ; int count = 0 ; for ( int i = 1 ; i <= n ; i ++ ) if ( ! mark [ i ] ) count ++ ; return count ; }
Ref: 
def countSink ( n , m , edgeFrom , edgeTo ) : NEW_LINE INDENT mark = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT mark [ edgeFrom [ i ] ] = 1 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( not mark [ i ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
Hyp: 
def countSink ( n , m , edgeFrom , edgeTo ) : NEW_LINE INDENT mark = [ 0 ] * n NEW_LINE for i in range ( 0 , m ) : NEW_LINE INDENT mark [ edgeFrom [ i ] ] = 1 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( mark [ i ] == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT

BLEU: 85.99
Edit Sim: 21


Src: 
int countNegative ( int M [ ] [ 4 ] , int n , int m ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( M [ i ] [ j ] < 0 ) count += 1 ; else break ; } } return count ; }
Ref: 
def countNegative ( M , n , m ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if M [ i ] [ j ] < 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
Hyp: 
def countNegative ( M , n , m ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( M [ i ] [ j ] < 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT

BLEU: 92.58
Edit Sim: 4


Src: 
int middleOfThree ( int a , int b , int c ) { if ( a > b ) { if ( b > c ) return b ; else if ( a > c ) return c ; else return a ; } else { if ( a > c ) return a ; else if ( b > c ) return c ; else return b ; } }
Ref: 
def middleOfThree ( a , b , c ) : NEW_LINE INDENT if a > b : NEW_LINE INDENT if ( b > c ) : NEW_LINE INDENT return b NEW_LINE DEDENT elif ( a > c ) : NEW_LINE INDENT return c NEW_LINE DEDENT else : NEW_LINE INDENT return a NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( a > c ) : NEW_LINE INDENT return a NEW_LINE DEDENT elif ( b > c ) : NEW_LINE INDENT return c NEW_LINE DEDENT else : NEW_LINE INDENT return b NEW_LINE DEDENT DEDENT DEDENT
Hyp: 
def middleOfThree ( a , b , c ) : NEW_LINE INDENT if a > b : NEW_LINE INDENT if b > c : NEW_LINE INDENT return b NEW_LINE DEDENT elif a > c : NEW_LINE INDENT return c NEW_LINE DEDENT else : NEW_LINE INDENT if a > c : NEW_LINE INDENT return a NEW_LINE DEDENT elif b > c : NEW_LINE INDENT return c NEW_LINE DEDENT else : NEW_LINE INDENT return b NEW_LINE DEDENT DEDENT

BLEU: 65.53
Edit Sim: 78


Src: 
int countOfSubstringWithKOnes ( string s , int K ) { int N = s . length ( ) ; int res = 0 ; int countOfOne = 0 ; int freq [ N + 1 ] = { 0 } ; freq [ 0 ] = 1 ; for ( int i = 0 ; i < N ; i ++ ) { countOfOne += ( s [ i ] - '0' ) ; if ( countOfOne >= K ) { res += freq [ countOfOne - K ] ; } freq [ countOfOne ] ++ ; } return res ; }
Ref: 
def countOfSubstringWithKOnes ( s , K ) : NEW_LINE INDENT N = len ( s ) NEW_LINE res = 0 NEW_LINE countOfOne = 0 NEW_LINE freq = [ 0 for i in range ( N + 1 ) ] NEW_LINE freq [ 0 ] = 1 NEW_LINE for i in range ( 0 , N , 1 ) : NEW_LINE INDENT countOfOne += ord ( s [ i ] ) - ord ( '0' ) NEW_LINE if ( countOfOne >= K ) : NEW_LINE INDENT res += freq [ countOfOne - K ] NEW_LINE DEDENT freq [ countOfOne ] += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT
Hyp: 
def countOfSubstringWithKOnes ( s , K ) : NEW_LINE INDENT N = len ( s ) NEW_LINE res = 0 NEW_LINE countOfOne = 0 NEW_LINE freq = [ 0 for i in range ( N + 1 ) ] NEW_LINE freq [ 0 ] = 1 NEW_LINE for i in range ( N ) : NEW_LINE INDENT countOfOne += ( ord ( s [ i ] ) - ord ( '0' ) ) NEW_LINE if ( countOfOne >= K ) : NEW_LINE INDENT res += freq [ countOfOne - K ] NEW_LINE DEDENT freq [ countOfOne ] += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT

BLEU: 91.92
Edit Sim: 12


Src: 
bool findPairs ( int arr [ ] , int n ) { map < int , pair < int , int > > Hash ; for ( int i = 0 ; i < n ; ++ i ) { for ( int j = i + 1 ; j < n ; ++ j ) { int sum = arr [ i ] + arr [ j ] ; if ( Hash . find ( sum ) == Hash . end ( ) ) Hash [ sum ] = make_pair ( i , j ) ; else { pair < int , int > pp = Hash [ sum ] ; cout << " ( " << arr [ pp . first ] << " , ▁ " << arr [ pp . second ] << " ) ▁ and ▁ ( " << arr [ i ] << " , ▁ " << arr [ j ] << " ) n " ; return true ; } } } cout << " No ▁ pairs ▁ found " ; return false ; }
Ref: 
def findPairs ( arr , n ) : NEW_LINE Hash = { } NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE sum = arr [ i ] + arr [ j ] NEW_LINE if sum in Hash . keys ( ) : NEW_LINE INDENT prev = Hash . get ( sum ) NEW_LINE print ( str ( prev ) + " ▁ and ▁ ( % d , ▁ % d ) " % ( arr [ i ] , arr [ j ] ) ) NEW_LINE return True NEW_LINE DEDENT else : NEW_LINE INDENT Hash [ sum ] = ( arr [ i ] , arr [ j ] ) NEW_LINE DEDENT DEDENT
Hyp: 
def findPairs ( arr , n ) : NEW_LINE INDENT Hash = dict ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT Sum = arr [ i ] + arr [ j ] NEW_LINE if ( Sum in Hash ) : NEW_LINE INDENT Hash [ Sum ] = make_pair ( i , j ) NEW_LINE DEDENT else : NEW_LINE INDENT pp = Hash [ Sum ] NEW_LINE print ( " ( " , arr [ pp [ 0 ] , " , ▁ " , arr [ pp [ 1 ] , " ) and ▁ ( " , arr [ i ] , " , ▁ " , arr [ j ] , " ) n " ) NEW_LINE return True NEW_LINE DEDENT DEDENT DEDENT print ( " No ▁ pairs ▁ found " ) NEW_LINE return False NEW_LINE DEDENT

BLEU: 44.17
Edit Sim: 229


Src: 
int search ( int arr [ ] , int n , int x ) { int i ; for ( i = 0 ; i < n ; i ++ ) if ( arr [ i ] == x ) return i ; return - 1 ; }
Ref: 
def search ( arr , n , x ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] == x ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
Hyp: 
def search ( arr , n , x ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == x ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT

BLEU: 92.16
Edit Sim: 4


Src: 
bool check ( string s1 , string s2 ) { int n = s1 . length ( ) ; int m = s2 . length ( ) ; bool dp [ n + 1 ] [ m + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= m ; j ++ ) { dp [ i ] [ j ] = false ; } } dp [ 0 ] [ 0 ] = true ; for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) { for ( int j = 0 ; j <= s2 . length ( ) ; j ++ ) { if ( dp [ i ] [ j ] ) { if ( j < s2 . length ( ) && ( toupper ( s1 [ i ] ) == s2 [ j ] ) ) dp [ i + 1 ] [ j + 1 ] = true ; if ( ! isupper ( s1 [ i ] ) ) dp [ i + 1 ] [ j ] = true ; } } } return ( dp [ n ] [ m ] ) ; }
Ref: 
def check ( s1 , s2 ) : NEW_LINE INDENT n = len ( s1 ) NEW_LINE m = len ( s2 ) NEW_LINE dp = ( [ [ False for i in range ( m + 1 ) ] for i in range ( n + 1 ) ] ) NEW_LINE dp [ 0 ] [ 0 ] = True NEW_LINE for i in range ( len ( s1 ) ) : NEW_LINE INDENT for j in range ( len ( s2 ) + 1 ) : NEW_LINE INDENT if ( dp [ i ] [ j ] ) : NEW_LINE INDENT if ( ( j < len ( s2 ) and ( s1 [ i ] . upper ( ) == s2 [ j ] ) ) ) : NEW_LINE INDENT dp [ i + 1 ] [ j + 1 ] = True NEW_LINE DEDENT if ( s1 [ i ] . isupper ( ) == False ) : NEW_LINE INDENT dp [ i + 1 ] [ j ] = True NEW_LINE DEDENT DEDENT DEDENT DEDENT return ( dp [ n ] [ m ] ) NEW_LINE DEDENT
Hyp: 
def check ( s1 , s2 ) : NEW_LINE INDENT n = len ( s1 ) NEW_LINE m = len ( s2 ) NEW_LINE dp = [ [ False for i in range ( m + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( m + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = False NEW_LINE DEDENT DEDENT dp [ 0 ] [ 0 ] = True NEW_LINE for i in range ( len ( s1 ) ) : NEW_LINE INDENT for j in range ( len ( s2 ) ) : NEW_LINE INDENT if ( dp [ i ] [ j ] ) : NEW_LINE INDENT if ( j < len ( s2 ) and ( toupper ( s1 [ i ] ) == s2 [ j ] ) ) : NEW_LINE INDENT dp [ i + 1 ] [ j + 1 ] = True NEW_LINE DEDENT if ( not isupper ( s1 [ i ] ) ) : NEW_LINE INDENT dp [ i + 1 ] [ j ] = True NEW_LINE DEDENT DEDENT DEDENT DEDENT return ( dp [ n ] [ m ] ) NEW_LINE DEDENT

BLEU: 77.55
Edit Sim: 176


Src: 
int binaryToDecimal ( string n ) { string num = n ; int dec_value = 0 ; int base = 1 ; int len = num . length ( ) ; for ( int i = len - 1 ; i >= 0 ; i -- ) { if ( num [ i ] == '1' ) dec_value += base ; base = base * 2 ; } return dec_value ; }
Ref: 
def binaryToDecimal ( n ) : NEW_LINE INDENT num = n NEW_LINE dec_value = 0 NEW_LINE base1 = 1 NEW_LINE len1 = len ( num ) NEW_LINE for i in range ( len1 - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( num [ i ] == '1' ) : NEW_LINE INDENT dec_value += base1 NEW_LINE DEDENT base1 = base1 * 2 NEW_LINE DEDENT return dec_value NEW_LINE DEDENT
Hyp: 
def binaryToDecimal ( n ) : NEW_LINE INDENT num = n NEW_LINE dec_value = 0 NEW_LINE base = 1 NEW_LINE len = len ( num ) NEW_LINE for i in range ( len - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( num [ i ] == '1' ) : NEW_LINE INDENT dec_value += base NEW_LINE DEDENT base = base * 2 NEW_LINE DEDENT return dec_value NEW_LINE DEDENT

BLEU: 80.17
Edit Sim: 6


Src: 
long countWays ( int n ) { long dp [ 2 ] [ n + 1 ] ; dp [ 0 ] [ 1 ] = 1 ; dp [ 1 ] [ 1 ] = 2 ; for ( int i = 2 ; i <= n ; i ++ ) { dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + dp [ 1 ] [ i - 1 ] ; dp [ 1 ] [ i ] = dp [ 0 ] [ i - 1 ] * 2 + dp [ 1 ] [ i - 1 ] ; } return dp [ 0 ] [ n ] + dp [ 1 ] [ n ] ; }
Ref: 
def countWays ( n ) : NEW_LINE INDENT dp = [ [ 0 ] * ( n + 1 ) for i in range ( 2 ) ] NEW_LINE dp [ 0 ] [ 1 ] = 1 NEW_LINE dp [ 1 ] [ 1 ] = 2 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + dp [ 1 ] [ i - 1 ] NEW_LINE dp [ 1 ] [ i ] = ( dp [ 0 ] [ i - 1 ] * 2 + dp [ 1 ] [ i - 1 ] ) NEW_LINE DEDENT return dp [ 0 ] [ n ] + dp [ 1 ] [ n ] NEW_LINE DEDENT
Hyp: 
def countWays ( n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n + 1 ) ] for i in range ( 2 , n + 1 ) ] NEW_LINE dp [ 0 ] [ 1 ] = 1 NEW_LINE dp [ 1 ] [ 1 ] = 2 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + dp [ 1 ] [ i - 1 ] NEW_LINE dp [ 1 ] [ i ] = dp [ 0 ] [ i - 1 ] * 2 + dp [ 1 ] [ i - 1 ] NEW_LINE DEDENT return dp [ 0 ] [ n ] + dp [ 1 ] [ n ] NEW_LINE DEDENT

BLEU: 88.78
Edit Sim: 27


Src: 
string compute ( string str , int n ) { string reverseAlphabet = " zyxwvutsrqponmlkjihgfedcba " ; int l = str . length ( ) ; for ( int i = n ; i < l ; i ++ ) str [ i ] = reverseAlphabet [ str [ i ] - ' a ' ] ; return str ; }
Ref: 
def compute ( st , n ) : NEW_LINE INDENT reverseAlphabet = " zyxwvutsrqponmlkjihgfedcba " NEW_LINE l = len ( st ) NEW_LINE answer = " " NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT answer = answer + st [ i ] NEW_LINE DEDENT for i in range ( n , l ) : NEW_LINE INDENT answer = ( answer + reverseAlphabet [ ord ( st [ i ] ) - ord ( ' a ' ) ] ) NEW_LINE DEDENT return answer NEW_LINE DEDENT
Hyp: 
def compute ( str , n ) : NEW_LINE INDENT reverseAlphabet = " zyxwvutsrqponmlkjihgfedcba " NEW_LINE l = len ( str ) NEW_LINE for i in range ( n , l ) : NEW_LINE INDENT str [ i ] = reverseAlphabet [ ord ( str [ i ] ) - ord ( ' a ' ) ] NEW_LINE DEDENT return str NEW_LINE DEDENT

BLEU: 46.72
Edit Sim: 127


Src: 
int maxLenSub ( int arr [ ] , int n ) { int mls [ n ] , max = 0 ; for ( int i = 0 ; i < n ; i ++ ) mls [ i ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( abs ( arr [ i ] - arr [ j ] ) <= 1 && mls [ i ] < mls [ j ] + 1 ) mls [ i ] = mls [ j ] + 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( max < mls [ i ] ) max = mls [ i ] ; return max ; }
Ref: 
def maxLenSub ( arr , n ) : NEW_LINE INDENT mls = [ ] NEW_LINE max = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT mls . append ( 1 ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( abs ( arr [ i ] - arr [ j ] ) <= 1 and mls [ i ] < mls [ j ] + 1 ) : NEW_LINE INDENT mls [ i ] = mls [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( max < mls [ i ] ) : NEW_LINE INDENT max = mls [ i ] NEW_LINE DEDENT DEDENT return max NEW_LINE DEDENT
Hyp: 
def maxLenSub ( arr , n ) : NEW_LINE INDENT mls = [ 0 ] * n NEW_LINE max = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT mls [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( 0 , i ) : NEW_LINE INDENT if ( abs ( arr [ i ] - arr [ j ] ) <= 1 and mls [ i ] < mls [ j ] + 1 ) : NEW_LINE INDENT mls [ i ] = mls [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( max < mls [ i ] ) : NEW_LINE INDENT max = mls [ i ] NEW_LINE DEDENT DEDENT return max NEW_LINE DEDENT

BLEU: 82.91
Edit Sim: 32


Src: 
long exponentiation ( long base , long exp ) { long t = 1L ; while ( exp > 0 ) { if ( exp % 2 != 0 ) t = ( t * base ) % N ; base = ( base * base ) % N ; exp /= 2 ; } return t % N ; }
Ref: 
def exponentiation ( bas , exp ) : NEW_LINE INDENT t = 1 NEW_LINE while ( exp > 0 ) : NEW_LINE INDENT if ( exp % 2 != 0 ) : NEW_LINE INDENT t = ( t * bas ) % N NEW_LINE DEDENT bas = ( bas * bas ) % N NEW_LINE exp = int ( exp / 2 ) NEW_LINE DEDENT return t % N NEW_LINE DEDENT
Hyp: 
def exponentiation ( base , exp ) : NEW_LINE INDENT t = 1L NEW_LINE while ( exp > 0 ) : NEW_LINE INDENT if ( exp % 2 != 0 ) : NEW_LINE INDENT t = ( t * base ) % N NEW_LINE DEDENT base = ( base * base ) % N NEW_LINE exp = exp // 2 NEW_LINE DEDENT return t % N NEW_LINE DEDENT

BLEU: 69.15
Edit Sim: 15


Src: 
int sequence ( int n ) { int f [ n + 1 ] ; int i ; f [ 0 ] = 0 ; f [ 1 ] = 1 ; f [ 2 ] = 1 ; for ( i = 3 ; i <= n ; i ++ ) f [ i ] = f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ] ; return f [ n ] ; }
Ref: 
def sequence ( n ) : NEW_LINE INDENT f = array . array ( ' i ' , [ 0 , 1 , 1 ] ) NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT r = f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ] NEW_LINE f . append ( r ) ; NEW_LINE DEDENT return r NEW_LINE DEDENT
Hyp: 
def sequence ( n ) : NEW_LINE INDENT f = [ 0 ] * ( n + 1 ) NEW_LINE f [ 0 ] = 0 NEW_LINE f [ 1 ] = 1 NEW_LINE f [ 2 ] = 1 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT f [ i ] = f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ] NEW_LINE DEDENT return f [ n ] NEW_LINE DEDENT

BLEU: 55.02
Edit Sim: 103


Src: 
int lbs ( int arr [ ] , int n ) { int i , j ; int * lis = new int [ n ] ; for ( i = 0 ; i < n ; i ++ ) lis [ i ] = 1 ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; int * lds = new int [ n ] ; for ( i = 0 ; i < n ; i ++ ) lds [ i ] = 1 ; for ( i = n - 2 ; i >= 0 ; i -- ) for ( j = n - 1 ; j > i ; j -- ) if ( arr [ i ] > arr [ j ] && lds [ i ] < lds [ j ] + 1 ) lds [ i ] = lds [ j ] + 1 ; int max = lis [ 0 ] + lds [ 0 ] - 1 ; for ( i = 1 ; i < n ; i ++ ) if ( lis [ i ] + lds [ i ] - 1 > max ) max = lis [ i ] + lds [ i ] - 1 ; return max ; }
Ref: 
def lbs ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE lis = [ 1 for i in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( 0 , i ) : NEW_LINE INDENT if ( ( arr [ i ] > arr [ j ] ) and ( lis [ i ] < lis [ j ] + 1 ) ) : NEW_LINE INDENT lis [ i ] = lis [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT lds = [ 1 for i in range ( n + 1 ) ] NEW_LINE for i in reversed ( range ( n - 1 ) ) : NEW_LINE INDENT for j in reversed ( range ( i - 1 , n ) ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and lds [ i ] < lds [ j ] + 1 ) : NEW_LINE INDENT lds [ i ] = lds [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT maximum = lis [ 0 ] + lds [ 0 ] - 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT maximum = max ( ( lis [ i ] + lds [ i ] - 1 ) , maximum ) NEW_LINE DEDENT return maximum NEW_LINE DEDENT
Hyp: 
def lbs ( arr , n ) : NEW_LINE INDENT lis = [ 0 ] * n NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT lis [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( 0 , i ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and lis [ i ] < lis [ j ] + 1 ) : NEW_LINE INDENT lis [ i ] = lis [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT lds = [ 0 ] * n NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT lds [ i ] = 1 NEW_LINE DEDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( n - 1 , i , - 1 ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and lds [ i ] < lds [ j ] + 1 ) : NEW_LINE INDENT lds [ i ] = lds [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT max = lis [ 0 ] + lds [ 0 ] - 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( lis [ i ] + lds [ i ] - 1 > max ) : NEW_LINE INDENT max = lis [ i ] + lds [ i ] - 1 NEW_LINE DEDENT DEDENT return max NEW_LINE DEDENT

BLEU: 65.56
Edit Sim: 237


Src: 
int maximumSum ( int a [ ] [ M ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) sort ( a [ i ] , a [ i ] + M ) ; int sum = a [ n - 1 ] [ M - 1 ] ; int prev = a [ n - 1 ] [ M - 1 ] ; int i , j ; for ( i = n - 2 ; i >= 0 ; i -- ) { for ( j = M - 1 ; j >= 0 ; j -- ) { if ( a [ i ] [ j ] < prev ) { prev = a [ i ] [ j ] ; sum += prev ; break ; } } if ( j == - 1 ) return 0 ; } return sum ; }
Ref: 
def maximumSum ( a , n ) : NEW_LINE INDENT global M NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT a [ i ] . sort ( ) NEW_LINE DEDENT sum = a [ n - 1 ] [ M - 1 ] NEW_LINE prev = a [ n - 1 ] [ M - 1 ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( M - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( a [ i ] [ j ] < prev ) : NEW_LINE INDENT prev = a [ i ] [ j ] NEW_LINE sum += prev NEW_LINE break NEW_LINE DEDENT DEDENT if ( j == - 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
Hyp: 
def maximumSum ( a , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT a [ i ] . sort ( ) NEW_LINE DEDENT sum = a [ n - 1 ] [ M - 1 ] NEW_LINE prev = a [ n - 1 ] [ M - 1 ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( M - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( a [ i ] [ j ] < prev ) : NEW_LINE INDENT prev = a [ i ] [ j ] NEW_LINE sum += prev NEW_LINE break NEW_LINE DEDENT DEDENT if ( j == - 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT

BLEU: 94.62
Edit Sim: 22


Src: 
int fib ( int n ) { if ( n <= 1 ) return n ; return fib ( n - 1 ) + fib ( n - 2 ) ; }
Ref: 
def fib ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT return fib ( n - 1 ) + fib ( n - 2 ) NEW_LINE DEDENT
Hyp: 
def fib ( n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return n NEW_LINE DEDENT return fib ( n - 1 ) + fib ( n - 2 ) NEW_LINE DEDENT

BLEU: 85.79
Edit Sim: 4


Src: 
int countPairs ( string str ) { int result = 0 ; int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( abs ( str [ i ] - str [ j ] ) == abs ( i - j ) ) result ++ ; return result ; }
Ref: 
def countPairs ( str1 ) : NEW_LINE INDENT result = 0 ; NEW_LINE n = len ( str1 ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( abs ( ord ( str1 [ i ] ) - ord ( str1 [ j ] ) ) == abs ( i - j ) ) : NEW_LINE INDENT result += 1 ; NEW_LINE DEDENT DEDENT DEDENT return result ; NEW_LINE DEDENT
Hyp: 
def countPairs ( str ) : NEW_LINE INDENT result = 0 NEW_LINE n = len ( str ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( abs ( str [ i ] - str [ j ] ) == abs ( i - j ) ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT

BLEU: 71.16
Edit Sim: 26


Src: 
bool flipsPossible ( int a [ ] , int n ) { int count_odd = 0 , count_even = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] & 1 ) count_odd ++ ; else count_even ++ ; } if ( count_odd % 2 && count_even % 2 ) return false ; else return true ; }
Ref: 
def flipsPossible ( a , n ) : NEW_LINE INDENT count_odd = 0 count_even = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] & 1 ) : NEW_LINE INDENT count_odd += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_even += 1 NEW_LINE DEDENT DEDENT if ( count_odd % 2 and count_even % 2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT
Hyp: 
def flipsPossible ( a , n ) : NEW_LINE INDENT count_odd = 0 NEW_LINE count_even = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] & 1 ) : NEW_LINE INDENT count_odd += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_even += 1 NEW_LINE DEDENT DEDENT if ( count_odd % 2 and count_even % 2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT

BLEU: 96.86
Edit Sim: 9


Src: 
bool checkDuplicatesWithinK ( int arr [ ] , int n , int k ) { unordered_set < int > myset ; for ( int i = 0 ; i < n ; i ++ ) { if ( myset . find ( arr [ i ] ) != myset . end ( ) ) return true ; myset . insert ( arr [ i ] ) ; if ( i >= k ) myset . erase ( arr [ i - k ] ) ; } return false ; }
Ref: 
def checkDuplicatesWithinK ( arr , n , k ) : NEW_LINE INDENT myset = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] in myset : NEW_LINE INDENT return True NEW_LINE DEDENT myset . append ( arr [ i ] ) NEW_LINE if ( i >= k ) : NEW_LINE INDENT myset . remove ( arr [ i - k ] ) NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
Hyp: 
def checkDuplicatesWithinK ( arr , n , k ) : NEW_LINE INDENT myset = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] in myset : NEW_LINE INDENT return True NEW_LINE DEDENT myset . add ( arr [ i ] ) NEW_LINE if i >= k : NEW_LINE INDENT myset . remove ( arr [ i - k ] ) NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT

BLEU: 86.08
Edit Sim: 14


Src: 
void diagonalsquare ( int mat [ ] [ MAX ] , int row , int column ) { cout << " ▁ \n Diagonal ▁ one ▁ : ▁ " ; for ( int i = 0 ; i < row ; i ++ ) { cout << mat [ i ] [ i ] * mat [ i ] [ i ] << " ▁ " ; } cout << " ▁ \n \n Diagonal ▁ two ▁ : ▁ " ; for ( int i = 0 ; i < row ; i ++ ) { cout << mat [ i ] [ row - i - 1 ] * mat [ i ] [ row - i - 1 ] << " ▁ " ; } }
Ref: 
def diagonalsquare ( mat , row , column ) : NEW_LINE INDENT print ( " Diagonal ▁ one ▁ : ▁ " , end = " " ) NEW_LINE for i in range ( 0 , row ) : NEW_LINE INDENT print ( mat [ i ] [ i ] * mat [ i ] [ i ] , end = " ▁ " ) NEW_LINE DEDENT print ( " \n \n Diagonal ▁ two ▁ : ▁ " , end = " " ) NEW_LINE for i in range ( 0 , row ) : NEW_LINE INDENT print ( mat [ i ] [ row - i - 1 ] * mat [ i ] [ row - i - 1 ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
Hyp: 
def diagonalsquare ( mat , row , column ) : NEW_LINE INDENT print ( " ▁ \n Diagonal ▁ one ▁ : ▁ " , end = " ▁ " ) NEW_LINE for i in range ( row ) : NEW_LINE INDENT print ( mat [ i ] [ i ] * mat [ i ] [ i ] , end = " ▁ " ) NEW_LINE DEDENT print ( " ▁ \n " , end = " ▁ " ) NEW_LINE for i in range ( row ) : NEW_LINE INDENT print ( mat [ i ] [ row - i - 1 ] * mat [ i ] [ row - i - 1 ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT

BLEU: 85.28
Edit Sim: 40


Src: 
int maxArea ( bool mat [ R ] [ C ] ) { int hist [ R + 1 ] [ C + 1 ] ; for ( int i = 0 ; i < C ; i ++ ) { hist [ 0 ] [ i ] = mat [ 0 ] [ i ] ; for ( int j = 1 ; j < R ; j ++ ) hist [ j ] [ i ] = ( mat [ j ] [ i ] == 0 ) ? 0 : hist [ j - 1 ] [ i ] + 1 ; } for ( int i = 0 ; i < R ; i ++ ) { int count [ R + 1 ] = { 0 } ; for ( int j = 0 ; j < C ; j ++ ) count [ hist [ i ] [ j ] ] ++ ; int col_no = 0 ; for ( int j = R ; j >= 0 ; j -- ) { if ( count [ j ] > 0 ) { for ( int k = 0 ; k < count [ j ] ; k ++ ) { hist [ i ] [ col_no ] = j ; col_no ++ ; } } } } int curr_area , max_area = 0 ; for ( int i = 0 ; i < R ; i ++ ) { for ( int j = 0 ; j < C ; j ++ ) { curr_area = ( j + 1 ) * hist [ i ] [ j ] ; if ( curr_area > max_area ) max_area = curr_area ; } } return max_area ; }
Ref: 
def maxArea ( mat ) : NEW_LINE INDENT hist = [ [ 0 for i in range ( C + 1 ) ] for i in range ( R + 1 ) ] NEW_LINE for i in range ( 0 , C , 1 ) : NEW_LINE INDENT hist [ 0 ] [ i ] = mat [ 0 ] [ i ] NEW_LINE for j in range ( 1 , R , 1 ) : NEW_LINE INDENT if ( ( mat [ j ] [ i ] == 0 ) ) : NEW_LINE INDENT hist [ j ] [ i ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT hist [ j ] [ i ] = hist [ j - 1 ] [ i ] + 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( 0 , R , 1 ) : NEW_LINE INDENT count = [ 0 for i in range ( R + 1 ) ] NEW_LINE for j in range ( 0 , C , 1 ) : NEW_LINE INDENT count [ hist [ i ] [ j ] ] += 1 NEW_LINE DEDENT col_no = 0 NEW_LINE j = R NEW_LINE while ( j >= 0 ) : NEW_LINE INDENT if ( count [ j ] > 0 ) : NEW_LINE INDENT for k in range ( 0 , count [ j ] , 1 ) : NEW_LINE INDENT hist [ i ] [ col_no ] = j NEW_LINE col_no += 1 NEW_LINE DEDENT DEDENT j -= 1 NEW_LINE DEDENT DEDENT max_area = 0 NEW_LINE for i in range ( 0 , R , 1 ) : NEW_LINE INDENT for j in range ( 0 , C , 1 ) : NEW_LINE INDENT curr_area = ( j + 1 ) * hist [ i ] [ j ] NEW_LINE if ( curr_area > max_area ) : NEW_LINE INDENT max_area = curr_area NEW_LINE DEDENT DEDENT DEDENT return max_area NEW_LINE DEDENT
Hyp: 
def maxArea ( mat ) : NEW_LINE INDENT hist = [ [ 0 for i in range ( C + 1 ) ] for j in range ( R + 1 ) ] NEW_LINE for i in range ( R + 1 ) : NEW_LINE INDENT hist [ 0 ] [ i ] = mat [ 0 ] [ i ] NEW_LINE for j in range ( 1 , R ) : NEW_LINE INDENT hist [ j ] [ i ] = ( mat [ j ] [ i ] == 0 ) ? 0 : hist [ j - 1 ] [ i ] + 1 NEW_LINE DEDENT DEDENT for i in range ( R ) : NEW_LINE INDENT count [ hist [ i ] [ j ] ] += 1 NEW_LINE DEDENT col_no = 0 NEW_LINE for j in range ( R , - 1 , - 1 ) : NEW_LINE INDENT if ( count [ j ] > 0 ) : NEW_LINE INDENT for k in range ( count [ j ] , 1 ) : NEW_LINE INDENT hist [ i ] [ col_no ] = j NEW_LINE col_no += 1 NEW_LINE DEDENT DEDENT DEDENT curr_area = 0 NEW_LINE for i in range ( R ) : NEW_LINE INDENT for j in range ( C ) : NEW_LINE INDENT curr_area = ( j + 1 ) * hist [ i ] [ j ] NEW_LINE if ( curr_area > max_area ) : NEW_LINE INDENT max_area = curr_area NEW_LINE DEDENT DEDENT DEDENT return max_area NEW_LINE DEDENT

BLEU: 68.43
Edit Sim: 280


Src: 
int longestSubseqWithDiffOne ( int arr [ ] , int n ) { int dp [ n ] ; for ( int i = 0 ; i < n ; i ++ ) dp [ i ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( ( arr [ i ] == arr [ j ] + 1 ) || ( arr [ i ] == arr [ j ] - 1 ) ) dp [ i ] = max ( dp [ i ] , dp [ j ] + 1 ) ; } } int result = 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( result < dp [ i ] ) result = dp [ i ] ; return result ; }
Ref: 
def longestSubseqWithDiffOne ( arr , n ) : NEW_LINE INDENT dp = [ 1 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( ( arr [ i ] == arr [ j ] + 1 ) or ( arr [ i ] == arr [ j ] - 1 ) ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i ] , dp [ j ] + 1 ) NEW_LINE DEDENT DEDENT DEDENT result = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( result < dp [ i ] ) : NEW_LINE INDENT result = dp [ i ] NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
Hyp: 
def longestSubseqWithDiffOne ( arr , n ) : NEW_LINE INDENT dp = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( ( arr [ i ] == arr [ j ] + 1 ) or ( arr [ i ] == arr [ j ] - 1 ) ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i ] , dp [ j ] + 1 ) NEW_LINE DEDENT DEDENT DEDENT result = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( result < dp [ i ] ) : NEW_LINE INDENT result = dp [ i ] NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT

BLEU: 86.34
Edit Sim: 56


Src: 
int maxSquare ( int b , int m ) { return ( b / m - 1 ) * ( b / m ) / 2 ; }
Ref: 
def maxSquare ( b , m ) : NEW_LINE INDENT return ( b / m - 1 ) * ( b / m ) / 2 NEW_LINE DEDENT
Hyp: 
def maxSquare ( b , m ) : NEW_LINE INDENT return ( ( b // m - 1 ) * ( b / m ) / 2 ) NEW_LINE DEDENT

BLEU: 77.98
Edit Sim: 5


Src: 
int maxSumPairWithDifferenceLessThanK ( int arr [ ] , int N , int K ) { sort ( arr , arr + N ) ; int dp [ N ] ; dp [ 0 ] = 0 ; for ( int i = 1 ; i < N ; i ++ ) { dp [ i ] = dp [ i - 1 ] ; if ( arr [ i ] - arr [ i - 1 ] < K ) { if ( i >= 2 ) dp [ i ] = max ( dp [ i ] , dp [ i - 2 ] + arr [ i ] + arr [ i - 1 ] ) ; else dp [ i ] = max ( dp [ i ] , arr [ i ] + arr [ i - 1 ] ) ; } } return dp [ N - 1 ] ; }
Ref: 
def maxSumPairWithDifferenceLessThanK ( arr , N , K ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE dp = [ 0 ] * N NEW_LINE dp [ 0 ] = 0 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] NEW_LINE if ( arr [ i ] - arr [ i - 1 ] < K ) : NEW_LINE INDENT if ( i >= 2 ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i ] , dp [ i - 2 ] + arr [ i ] + arr [ i - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] = max ( dp [ i ] , arr [ i ] + arr [ i - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ N - 1 ] NEW_LINE DEDENT
Hyp: 
def maxSumPairWithDifferenceLessThanK ( arr , N , K ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE dp = [ 0 for _ in range ( N ) ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] NEW_LINE if ( arr [ i ] - arr [ i - 1 ] < K ) : NEW_LINE INDENT if ( i >= 2 ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i ] , dp [ i - 2 ] + arr [ i ] + arr [ i - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] = max ( dp [ i ] , arr [ i ] + arr [ i - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ N - 1 ] NEW_LINE DEDENT

BLEU: 93.04
Edit Sim: 20


Src: 
int minOperation ( int arr [ ] , int n ) { unordered_map < int , int > hash ; for ( int i = 0 ; i < n ; i ++ ) hash [ arr [ i ] ] ++ ; int max_count = 0 ; for ( auto i : hash ) if ( max_count < i . second ) max_count = i . second ; return ( n - max_count ) ; }
Ref: 
def minOperation ( arr , n ) : NEW_LINE INDENT Hash = defaultdict ( lambda : 0 ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT Hash [ arr [ i ] ] += 1 NEW_LINE DEDENT max_count = 0 NEW_LINE for i in Hash : NEW_LINE INDENT if max_count < Hash [ i ] : NEW_LINE INDENT max_count = Hash [ i ] NEW_LINE DEDENT DEDENT return n - max_count NEW_LINE DEDENT
Hyp: 
def minOperation ( arr , n ) : NEW_LINE INDENT Hash = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT Hash [ arr [ i ] ] = Hash . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT max_count = 0 NEW_LINE for i in Hash : NEW_LINE INDENT if ( max_count < i ) : NEW_LINE INDENT max_count = i NEW_LINE DEDENT DEDENT return ( n - max_count ) NEW_LINE DEDENT

BLEU: 62.79
Edit Sim: 77


Src: 
void kSmallestPair ( int arr1 [ ] , int n1 , int arr2 [ ] , int n2 , int k ) { if ( k > n1 * n2 ) { cout << " k ▁ pairs ▁ don ' t ▁ exist " ; return ; } int index2 [ n1 ] ; memset ( index2 , 0 , sizeof ( index2 ) ) ; while ( k > 0 ) { int min_sum = INT_MAX ; int min_index = 0 ; for ( int i1 = 0 ; i1 < n1 ; i1 ++ ) { if ( index2 [ i1 ] < n2 && arr1 [ i1 ] + arr2 [ index2 [ i1 ] ] < min_sum ) { min_index = i1 ; min_sum = arr1 [ i1 ] + arr2 [ index2 [ i1 ] ] ; } } cout << " ( " << arr1 [ min_index ] << " , ▁ " << arr2 [ index2 [ min_index ] ] << " ) ▁ " ; index2 [ min_index ] ++ ; k -- ; } }
Ref: 
def kSmallestPair ( arr1 , n1 , arr2 , n2 , k ) : NEW_LINE INDENT if ( k > n1 * n2 ) : NEW_LINE INDENT print ( " k ▁ pairs ▁ don ' t ▁ exist " ) NEW_LINE return NEW_LINE DEDENT index2 = [ 0 for i in range ( n1 ) ] NEW_LINE while ( k > 0 ) : NEW_LINE INDENT min_sum = sys . maxsize NEW_LINE min_index = 0 NEW_LINE for i1 in range ( 0 , n1 , 1 ) : NEW_LINE INDENT if ( index2 [ i1 ] < n2 and arr1 [ i1 ] + arr2 [ index2 [ i1 ] ] < min_sum ) : NEW_LINE INDENT min_index = i1 NEW_LINE min_sum = arr1 [ i1 ] + arr2 [ index2 [ i1 ] ] NEW_LINE DEDENT DEDENT print ( " ( " , arr1 [ min_index ] , " , " , arr2 [ index2 [ min_index ] ] , " ) " , end = " ▁ " ) NEW_LINE index2 [ min_index ] += 1 NEW_LINE k -= 1 NEW_LINE DEDENT DEDENT
Hyp: 
def kSmallestPair ( arr1 , n1 , arr2 , n2 , k ) : NEW_LINE INDENT if ( k > n1 * n2 ) : NEW_LINE INDENT print ( " k ▁ pairs ▁ don ' t ▁ exist " ) NEW_LINE return NEW_LINE DEDENT index2 = [ 0 ] * n1 NEW_LINE while ( k > 0 ) : NEW_LINE INDENT min_sum = sys . maxsize NEW_LINE min_index = 0 NEW_LINE for i1 in range ( n1 ) : NEW_LINE INDENT if ( index2 [ i1 ] < n2 and arr1 [ i1 ] + arr2 [ index2 [ i1 ] ] < min_sum ) : NEW_LINE INDENT min_index = i1 NEW_LINE min_sum = arr1 [ i1 ] + arr2 [ index2 [ i1 ] ] NEW_LINE DEDENT DEDENT print ( " ( " , arr1 [ min_index ] , " , ▁ " , arr2 [ index2 [ min_index ] ] , " ) ▁ " , index2 [ min_index ] ] ) NEW_LINE k -= 1 NEW_LINE DEDENT DEDENT

BLEU: 84.8
Edit Sim: 54


Src: 
void spiralPrint ( int m , int n , int a [ R ] [ C ] ) { int i , k = 0 , l = 0 ; while ( k < m && l < n ) { for ( i = l ; i < n ; ++ i ) { cout << a [ k ] [ i ] << " ▁ " ; } k ++ ; for ( i = k ; i < m ; ++ i ) { cout << a [ i ] [ n - 1 ] << " ▁ " ; } n -- ; if ( k < m ) { for ( i = n - 1 ; i >= l ; -- i ) { cout << a [ m - 1 ] [ i ] << " ▁ " ; } m -- ; } if ( l < n ) { for ( i = m - 1 ; i >= k ; -- i ) { cout << a [ i ] [ l ] << " ▁ " ; } l ++ ; } } }
Ref: 
def spiralPrint ( m , n , a ) : NEW_LINE INDENT k = 0 l = 0 NEW_LINE while ( k < m and l < n ) : NEW_LINE INDENT for i in range ( l , n ) : NEW_LINE INDENT print ( a [ k ] [ i ] , end = " ▁ " ) NEW_LINE DEDENT k += 1 NEW_LINE for i in range ( k , m ) : NEW_LINE INDENT print ( a [ i ] [ n - 1 ] , end = " ▁ " ) NEW_LINE DEDENT n -= 1 NEW_LINE if ( k < m ) : NEW_LINE INDENT for i in range ( n - 1 , ( l - 1 ) , - 1 ) : NEW_LINE INDENT print ( a [ m - 1 ] [ i ] , end = " ▁ " ) NEW_LINE DEDENT m -= 1 NEW_LINE DEDENT if ( l < n ) : NEW_LINE INDENT for i in range ( m - 1 , k - 1 , - 1 ) : NEW_LINE INDENT print ( a [ i ] [ l ] , end = " ▁ " ) NEW_LINE DEDENT l += 1 NEW_LINE DEDENT DEDENT DEDENT
Hyp: 
def spiralPrint ( m , n , a ) : NEW_LINE INDENT k = 0 l = 0 NEW_LINE while ( k < m and l < n ) : NEW_LINE INDENT for i in range ( l , n ) : NEW_LINE INDENT print ( a [ k ] [ i ] , end = " ▁ " ) NEW_LINE DEDENT k += 1 NEW_LINE for i in range ( k , m ) : NEW_LINE INDENT print ( a [ i ] [ n - 1 ] , end = " ▁ " ) NEW_LINE DEDENT n -= 1 NEW_LINE if ( k < m ) : NEW_LINE INDENT for i in range ( n - 1 , l - 1 , - 1 ) : NEW_LINE INDENT print ( a [ m - 1 ] [ i ] , end = " ▁ " ) NEW_LINE DEDENT m -= 1 NEW_LINE if ( l < n ) : NEW_LINE INDENT for i in range ( m - 1 , k - 1 , - 1 ) : NEW_LINE INDENT print ( a [ i ] [ l ] , end = " ▁ " ) NEW_LINE DEDENT l += 1 NEW_LINE DEDENT DEDENT DEDENT

BLEU: 96.39
Edit Sim: 11


Src: 
int findSum ( string str ) { string temp = " " ; int sum = 0 ; for ( char ch : str ) { if ( isdigit ( ch ) ) temp += ch ; else { sum += atoi ( temp . c_str ( ) ) ; temp = " " ; } } return sum + atoi ( temp . c_str ( ) ) ; }
Ref: 
def findSum ( str1 ) : NEW_LINE INDENT temp = " " NEW_LINE Sum = 0 NEW_LINE for ch in str1 : NEW_LINE INDENT if ( ch . isdigit ( ) ) : NEW_LINE INDENT temp += ch NEW_LINE DEDENT else : NEW_LINE INDENT Sum += int ( temp ) NEW_LINE temp = "0" NEW_LINE DEDENT DEDENT return Sum + int ( temp ) NEW_LINE DEDENT
Hyp: 
def findSum ( str ) : NEW_LINE INDENT temp = " " NEW_LINE sum = 0 NEW_LINE for ch in str : NEW_LINE INDENT if ( isdigit ( ch ) ) : NEW_LINE INDENT temp += ch NEW_LINE DEDENT else : NEW_LINE INDENT sum += int ( temp ) NEW_LINE temp = " " NEW_LINE DEDENT DEDENT return sum + int ( temp ) NEW_LINE DEDENT

BLEU: 68.88
Edit Sim: 14


Src: 
int pentagonalNum ( int n ) { return ( 3 * n * n - n ) / 2 ; }
Ref: 
def pentagonalNum ( n ) : NEW_LINE INDENT return ( 3 * n * n - n ) / 2 NEW_LINE DEDENT
Hyp: 
def pentagonalNum ( n ) : NEW_LINE INDENT return ( 3 * n * n - n ) / 2 NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
long long int countNonDecreasing ( int n ) { int N = 10 ; long long count = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { count *= ( N + i - 1 ) ; count /= i ; } return count ; }
Ref: 
def countNonDecreasing ( n ) : NEW_LINE INDENT N = 10 NEW_LINE count = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT count = int ( count * ( N + i - 1 ) ) NEW_LINE count = int ( count / i ) NEW_LINE DEDENT return count NEW_LINE DEDENT
Hyp: 
def countNonDecreasing ( n ) : NEW_LINE INDENT N = 10 NEW_LINE count = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT count *= ( N + i - 1 ) NEW_LINE count /= i NEW_LINE DEDENT return count NEW_LINE DEDENT

BLEU: 70.23
Edit Sim: 34


Src: 
int mostFrequent ( int arr [ ] , int n ) { unordered_map < int , int > hash ; for ( int i = 0 ; i < n ; i ++ ) hash [ arr [ i ] ] ++ ; int max_count = 0 , res = - 1 ; for ( auto i : hash ) { if ( max_count < i . second ) { res = i . first ; max_count = i . second ; } } return res ; }
Ref: 
def mostFrequent ( arr , n ) : NEW_LINE INDENT Hash = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] in Hash . keys ( ) : NEW_LINE INDENT Hash [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT Hash [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT max_count = 0 NEW_LINE res = - 1 NEW_LINE for i in Hash : NEW_LINE INDENT if ( max_count < Hash [ i ] ) : NEW_LINE INDENT res = i NEW_LINE max_count = Hash [ i ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
Hyp: 
def mostFrequent ( arr , n ) : NEW_LINE INDENT Hash = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT Hash [ arr [ i ] ] = Hash . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT max_count = 0 NEW_LINE res = - 1 NEW_LINE for i in Hash : NEW_LINE INDENT if ( max_count < i ) : NEW_LINE INDENT res = i NEW_LINE max_count = i NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT

BLEU: 62.86
Edit Sim: 123


Src: 
int kth ( int arr1 [ ] , int arr2 [ ] , int m , int n , int k ) { int sorted1 [ m + n ] ; int i = 0 , j = 0 , d = 0 ; while ( i < m && j < n ) { if ( arr1 [ i ] < arr2 [ j ] ) sorted1 [ d ++ ] = arr1 [ i ++ ] ; else sorted1 [ d ++ ] = arr2 [ j ++ ] ; } while ( i < m ) sorted1 [ d ++ ] = arr1 [ i ++ ] ; while ( j < n ) sorted1 [ d ++ ] = arr2 [ j ++ ] ; return sorted1 [ k - 1 ] ; }
Ref: 
def kth ( arr1 , arr2 , m , n , k ) : NEW_LINE INDENT sorted1 = [ 0 ] * ( m + n ) NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE d = 0 NEW_LINE while ( i < m and j < n ) : NEW_LINE INDENT if ( arr1 [ i ] < arr2 [ j ] ) : NEW_LINE INDENT sorted1 [ d ] = arr1 [ i ] NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT sorted1 [ d ] = arr2 [ j ] NEW_LINE j += 1 NEW_LINE DEDENT d += 1 NEW_LINE DEDENT while ( i < m ) : NEW_LINE INDENT sorted1 [ d ] = arr1 [ i ] NEW_LINE d += 1 NEW_LINE i += 1 NEW_LINE DEDENT while ( j < n ) : NEW_LINE INDENT sorted1 [ d ] = arr2 [ j ] NEW_LINE d += 1 NEW_LINE j += 1 NEW_LINE DEDENT return sorted1 [ k - 1 ] NEW_LINE DEDENT
Hyp: 
def kth ( arr1 , arr2 , m , n , k ) : NEW_LINE INDENT sorted1 = [ 0 ] * ( m + n ) NEW_LINE i , j , d = 0 , 0 NEW_LINE while ( i < m and j < n ) : NEW_LINE INDENT if ( arr1 [ i ] < arr2 [ j ] ) : NEW_LINE INDENT sorted1 [ d ] = arr1 [ i ] NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT sorted1 [ d ] = arr2 [ j ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT while ( i < m ) : NEW_LINE INDENT sorted1 [ d ] = arr1 [ i ] NEW_LINE i += 1 NEW_LINE DEDENT while ( j < n ) : NEW_LINE INDENT sorted1 [ d ] = arr2 [ j ] NEW_LINE j += 1 NEW_LINE DEDENT return sorted1 [ k - 1 ] NEW_LINE DEDENT

BLEU: 85.78
Edit Sim: 71


Src: 
int binomialCoeff ( int n , int k ) { if ( k == 0 || k == n ) return 1 ; return binomialCoeff ( n - 1 , k - 1 ) + binomialCoeff ( n - 1 , k ) ; }
Ref: 
def binomialCoeff ( n , k ) : NEW_LINE INDENT if k == 0 or k == n : NEW_LINE INDENT return 1 NEW_LINE DEDENT return binomialCoeff ( n - 1 , k - 1 ) + binomialCoeff ( n - 1 , k ) NEW_LINE DEDENT
Hyp: 
def binomialCoeff ( n , k ) : NEW_LINE INDENT if ( k == 0 or k == n ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return binomialCoeff ( n - 1 , k - 1 ) + binomialCoeff ( n - 1 , k ) NEW_LINE DEDENT

BLEU: 89.45
Edit Sim: 4


Src: 
string firstLetterWord ( string str ) { string result = " " ; bool v = true ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] == ' ▁ ' ) v = true ; else if ( str [ i ] != ' ▁ ' && v == true ) { result . push_back ( str [ i ] ) ; v = false ; } } return result ; }
Ref: 
def firstLetterWord ( str ) : NEW_LINE INDENT result = " " NEW_LINE v = True NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] == ' ▁ ' ) : NEW_LINE INDENT v = True NEW_LINE DEDENT elif ( str [ i ] != ' ▁ ' and v == True ) : NEW_LINE INDENT result += ( str [ i ] ) NEW_LINE v = False NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
Hyp: 
def firstLetterWord ( str ) : NEW_LINE INDENT result = " " NEW_LINE v = True NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] == ' ▁ ' ) : NEW_LINE INDENT v = True NEW_LINE DEDENT elif ( str [ i ] != ' ▁ ' and v == True ) : NEW_LINE INDENT result = result + list ( str [ i ] ) NEW_LINE v = False NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT

BLEU: 93.76
Edit Sim: 14


Src: 
void assign ( int a [ ] , int n ) { sort ( a , a + n ) ; int ans [ n ] ; int p = 0 , q = n - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( i + 1 ) % 2 == 0 ) ans [ i ] = a [ q -- ] ; else ans [ i ] = a [ p ++ ] ; } for ( int i = 0 ; i < n ; i ++ ) cout << ans [ i ] << " ▁ " ; }
Ref: 
def assign ( a , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE ans = [ 0 ] * n NEW_LINE p = 0 NEW_LINE q = n - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i + 1 ) % 2 == 0 : NEW_LINE INDENT ans [ i ] = a [ q ] NEW_LINE q = q - 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans [ i ] = a [ p ] NEW_LINE p = p + 1 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( ans [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
Hyp: 
def assign ( a , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE ans = [ 0 ] * ( n + 1 ) NEW_LINE p = 0 NEW_LINE q = n - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( ( i + 1 ) % 2 == 0 ) : NEW_LINE INDENT ans [ i ] = a [ q ] NEW_LINE DEDENT else : NEW_LINE INDENT ans [ i ] = a [ p ] NEW_LINE DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( ans [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT

BLEU: 79.56
Edit Sim: 60


Src: 
void printDistinct ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] == arr [ j ] ) break ; if ( i == j ) cout << arr [ i ] << " ▁ " ; } }
Ref: 
def printDistinct ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT d = 0 NEW_LINE for j in range ( 0 , i ) : NEW_LINE INDENT if ( arr [ i ] == arr [ j ] ) : NEW_LINE INDENT d = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( d == 0 ) : NEW_LINE INDENT print ( arr [ i ] ) NEW_LINE DEDENT DEDENT DEDENT
Hyp: 
def printDistinct ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ i ] == arr [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( i == j ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT

BLEU: 70.1
Edit Sim: 54


Src: 
int countSolutions ( int n ) { int res = 0 ; for ( int x = 0 ; x * x < n ; x ++ ) for ( int y = 0 ; x * x + y * y < n ; y ++ ) res ++ ; return res ; }
Ref: 
def countSolutions ( n ) : NEW_LINE INDENT res = 0 NEW_LINE x = 0 NEW_LINE while ( x * x < n ) : NEW_LINE INDENT y = 0 NEW_LINE while ( x * x + y * y < n ) : NEW_LINE INDENT res = res + 1 NEW_LINE y = y + 1 NEW_LINE DEDENT x = x + 1 NEW_LINE DEDENT return res NEW_LINE DEDENT
Hyp: 
def countSolutions ( n ) : NEW_LINE INDENT res = 0 NEW_LINE for x in range ( 0 , n ) : NEW_LINE INDENT for y in range ( 0 , n ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT

BLEU: 32.47
Edit Sim: 95


Src: 
void relativeComplement ( int arr1 [ ] , int arr2 [ ] , int n , int m ) { int i = 0 , j = 0 ; while ( i < n && j < m ) { if ( arr1 [ i ] < arr2 [ j ] ) { cout << arr1 [ i ] << " ▁ " ; i ++ ; } else if ( arr1 [ i ] > arr2 [ j ] ) { j ++ ; } else if ( arr1 [ i ] == arr2 [ j ] ) { i ++ ; j ++ ; } } while ( i < n ) cout << arr1 [ i ] << " ▁ " ; }
Ref: 
def relativeComplement ( arr1 , arr2 , n , m ) : NEW_LINE INDENT i = 0 NEW_LINE j = 0 NEW_LINE while ( i < n and j < m ) : NEW_LINE INDENT if ( arr1 [ i ] < arr2 [ j ] ) : NEW_LINE INDENT print ( arr1 [ i ] , " ▁ " , end = " " ) NEW_LINE i += 1 NEW_LINE DEDENT elif ( arr1 [ i ] > arr2 [ j ] ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT elif ( arr1 [ i ] == arr2 [ j ] ) : NEW_LINE INDENT i += 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT while ( i < n ) : NEW_LINE INDENT print ( arr1 [ i ] , " ▁ " , end = " " ) NEW_LINE DEDENT DEDENT
Hyp: 
def relativeComplement ( arr1 , arr2 , n , m ) : NEW_LINE INDENT i , j = 0 , 0 NEW_LINE while i < n and j < m : NEW_LINE INDENT if arr1 [ i ] < arr2 [ j ] : NEW_LINE INDENT print ( arr1 [ i ] , end = " ▁ " ) NEW_LINE i += 1 NEW_LINE DEDENT elif arr1 [ i ] > arr2 [ j ] : NEW_LINE INDENT j += 1 NEW_LINE DEDENT elif arr1 [ i ] == arr2 [ j ] : NEW_LINE INDENT i += 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT while i < n : NEW_LINE INDENT print ( arr1 [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT

BLEU: 66.73
Edit Sim: 59


Src: 
int findFourElements ( int arr [ ] , int n ) { unordered_map < int , pair < int , int > > mp ; for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) mp [ arr [ i ] + arr [ j ] ] = { i , j } ; int d = INT_MIN ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int abs_diff = abs ( arr [ i ] - arr [ j ] ) ; if ( mp . find ( abs_diff ) != mp . end ( ) ) { pair < int , int > p = mp [ abs_diff ] ; if ( p . first != i && p . first != j && p . second != i && p . second != j ) d = max ( d , max ( arr [ i ] , arr [ j ] ) ) ; } } } return d ; }
Ref: 
def findFourElements ( arr , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT mp [ arr [ i ] + arr [ j ] ] = ( i , j ) NEW_LINE DEDENT DEDENT d = - 10 ** 9 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT abs_diff = abs ( arr [ i ] - arr [ j ] ) NEW_LINE if abs_diff in mp . keys ( ) : NEW_LINE INDENT p = mp [ abs_diff ] NEW_LINE if ( p [ 0 ] != i and p [ 0 ] != j and p [ 1 ] != i and p [ 1 ] != j ) : NEW_LINE INDENT d = max ( d , max ( arr [ i ] , arr [ j ] ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return d NEW_LINE DEDENT
Hyp: 
def findFourElements ( arr , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT mp [ arr [ i ] + arr [ j ] ] = { i , j } NEW_LINE DEDENT DEDENT d = - sys . maxsize - 1 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT abs_diff = abs ( arr [ i ] - arr [ j ] ) NEW_LINE if ( abs_diff in mp ) : NEW_LINE INDENT p = mp [ abs_diff ] NEW_LINE if ( p [ 0 ] != i and p [ 0 ] != j ) : NEW_LINE INDENT d = max ( d , max ( arr [ i ] , arr [ j ] ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return d NEW_LINE DEDENT

BLEU: 82.97
Edit Sim: 70


Src: 
int findTrailingZeros ( int n ) { int count = 0 ; for ( int i = 5 ; n / i >= 1 ; i *= 5 ) count += n / i ; return count ; }
Ref: 
def findTrailingZeros ( n ) : NEW_LINE INDENT count = 0 NEW_LINE i = 5 NEW_LINE while ( n / i >= 1 ) : NEW_LINE INDENT count += int ( n / i ) NEW_LINE i *= 5 NEW_LINE DEDENT return int ( count ) NEW_LINE DEDENT
Hyp: 
def findTrailingZeros ( n ) : NEW_LINE INDENT count = 0 NEW_LINE i = 5 NEW_LINE while ( n // i >= 1 ) : NEW_LINE INDENT count += n // i NEW_LINE i = 5 NEW_LINE DEDENT return count NEW_LINE DEDENT

BLEU: 63.06
Edit Sim: 18


Src: 
bool isPrime ( int p ) { long long checkNumber = pow ( 2 , p ) - 1 ; long long nextval = 4 % checkNumber ; for ( int i = 1 ; i < p - 1 ; i ++ ) nextval = ( nextval * nextval - 2 ) % checkNumber ; return ( nextval == 0 ) ; }
Ref: 
def isPrime ( p ) : NEW_LINE INDENT checkNumber = 2 ** p - 1 NEW_LINE nextval = 4 % checkNumber NEW_LINE for i in range ( 1 , p - 1 ) : NEW_LINE INDENT nextval = ( nextval * nextval - 2 ) % checkNumber NEW_LINE DEDENT if ( nextval == 0 ) : return True NEW_LINE else : return False NEW_LINE DEDENT
Hyp: 
def isPrime ( p ) : NEW_LINE INDENT checkNumber = ( long ) ( math . pow ( 2 , p ) - 1 ) NEW_LINE nextval = 4 % checkNumber NEW_LINE for i in range ( 1 , p - 1 ) : NEW_LINE INDENT nextval = ( nextval * nextval - 2 ) % checkNumber NEW_LINE DEDENT return ( nextval == 0 ) NEW_LINE DEDENT

BLEU: 71.26
Edit Sim: 79


Src: 
int CountSubstring ( char str [ ] , int n ) { int ans = ( n * ( n + 1 ) ) / 2 ; int a_index = 0 ; int b_index = 0 ; int c_index = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == ' a ' ) { a_index = i + 1 ; ans -= min ( b_index , c_index ) ; } else if ( str [ i ] == ' b ' ) { b_index = i + 1 ; ans -= min ( a_index , c_index ) ; } else { c_index = i + 1 ; ans -= min ( a_index , b_index ) ; } } return ans ; }
Ref: 
def CountSubString ( Str , n ) : NEW_LINE INDENT ans = ( n * ( n + 1 ) ) // 2 NEW_LINE a_index = 0 NEW_LINE b_index = 0 NEW_LINE c_index = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( Str [ i ] == ' a ' ) : NEW_LINE INDENT a_index = i + 1 NEW_LINE ans -= min ( b_index , c_index ) NEW_LINE DEDENT elif ( Str [ i ] == ' b ' ) : NEW_LINE INDENT b_index = i + 1 NEW_LINE ans -= min ( a_index , c_index ) NEW_LINE DEDENT else : NEW_LINE INDENT c_index = i + 1 NEW_LINE ans -= min ( a_index , b_index ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
Hyp: 
def CountSubstring ( str , n ) : NEW_LINE INDENT ans = ( n * ( n + 1 ) ) / 2 NEW_LINE a_index = 0 NEW_LINE b_index = 0 NEW_LINE c_index = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( str [ i ] == ' a ' ) : NEW_LINE INDENT a_index = i + 1 NEW_LINE ans -= min ( b_index , c_index ) NEW_LINE DEDENT elif ( str [ i ] == ' b ' ) : NEW_LINE INDENT b_index = i + 1 NEW_LINE ans -= min ( a_index , c_index ) NEW_LINE DEDENT else : NEW_LINE INDENT c_index = i + 1 NEW_LINE ans -= min ( a_index , b_index ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT

BLEU: 88.93
Edit Sim: 9


Src: 
bool isPalindrome ( string str ) { int l = 0 ; int h = str . length ( ) - 1 ; while ( h > l ) if ( str [ l ++ ] != str [ h -- ] ) return false ; return true ; }
Ref: 
def isPalindrome ( string ) : NEW_LINE INDENT l = 0 NEW_LINE h = len ( string ) - 1 NEW_LINE while h > l : NEW_LINE INDENT l += 1 NEW_LINE h -= 1 NEW_LINE if string [ l - 1 ] != string [ h + 1 ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
Hyp: 
def isPalindrome ( str ) : NEW_LINE INDENT l = 0 NEW_LINE h = len ( str ) - 1 NEW_LINE while ( h > l ) : NEW_LINE INDENT if ( str [ l ] != str [ h ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT l += 1 NEW_LINE h -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT

BLEU: 58.26
Edit Sim: 89


Src: 
int maxNumOfChocolates ( int arr [ ] , int n , int k ) { unordered_map < int , int > um ; int sum [ n ] , curr_rem ; int maxSum = 0 ; sum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) sum [ i ] = sum [ i - 1 ] + arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) { curr_rem = sum [ i ] % k ; if ( curr_rem == 0 ) { if ( maxSum < sum [ i ] ) maxSum = sum [ i ] ; } else if ( um . find ( curr_rem ) == um . end ( ) ) um [ curr_rem ] = i ; else if ( maxSum < ( sum [ i ] - sum [ um [ curr_rem ] ] ) ) maxSum = sum [ i ] - sum [ um [ curr_rem ] ] ; } return ( maxSum / k ) ; }
Ref: 
def maxNumOfChocolates ( arr , n , k ) : NEW_LINE INDENT um , curr_rem , maxSum = { } , 0 , 0 NEW_LINE sm = [ 0 ] * n NEW_LINE sm [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT sm [ i ] = sm [ i - 1 ] + arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT curr_rem = sm [ i ] % k NEW_LINE if ( not curr_rem and maxSum < sm [ i ] ) : NEW_LINE INDENT maxSum = sm [ i ] NEW_LINE DEDENT elif ( not curr_rem in um ) : NEW_LINE INDENT um [ curr_rem ] = i NEW_LINE DEDENT elif ( maxSum < ( sm [ i ] - sm [ um [ curr_rem ] ] ) ) : NEW_LINE INDENT maxSum = sm [ i ] - sm [ um [ curr_rem ] ] NEW_LINE DEDENT DEDENT return maxSum // k NEW_LINE DEDENT
Hyp: 
def maxNumOfChocolates ( arr , n , k ) : NEW_LINE INDENT um = dict ( ) NEW_LINE Sum = [ 0 ] * n NEW_LINE maxSum = 0 NEW_LINE Sum [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT Sum [ i ] = Sum [ i - 1 ] + arr [ i ] NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT curr_rem = Sum [ i ] % k NEW_LINE if curr_rem == 0 : NEW_LINE INDENT if ( maxSum < Sum [ i ] ) : NEW_LINE INDENT maxSum = Sum [ i ] NEW_LINE DEDENT DEDENT elif ( curr_rem in um ) : NEW_LINE INDENT um [ curr_rem ] = i NEW_LINE DEDENT elif ( maxSum < ( Sum [ i ] - Sum [ um [ curr_rem ] ] ) ) : NEW_LINE INDENT maxSum = Sum [ i ] - Sum [ um [ curr_rem ] ] NEW_LINE DEDENT DEDENT return ( maxSum / k ) NEW_LINE DEDENT

BLEU: 68.7
Edit Sim: 108


Src: 
string decode ( string str ) { stack < int > integerstack ; stack < char > stringstack ; string temp = " " , result = " " ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { int count = 0 ; if ( str [ i ] >= '0' && str [ i ] <= '9' ) { while ( str [ i ] >= '0' && str [ i ] <= '9' ) { count = count * 10 + str [ i ] - '0' ; i ++ ; } i -- ; integerstack . push ( count ) ; } else if ( str [ i ] == ' ] ' ) { temp = " " ; count = 0 ; if ( ! integerstack . empty ( ) ) { count = integerstack . top ( ) ; integerstack . pop ( ) ; } while ( ! stringstack . empty ( ) && stringstack . top ( ) != ' [ ' ) { temp = stringstack . top ( ) + temp ; stringstack . pop ( ) ; } if ( ! stringstack . empty ( ) && stringstack . top ( ) == ' [ ' ) stringstack . pop ( ) ; for ( int j = 0 ; j < count ; j ++ ) result = result + temp ; for ( int j = 0 ; j < result . length ( ) ; j ++ ) stringstack . push ( result [ j ] ) ; result = " " ; } else if ( str [ i ] == ' [ ' ) { if ( str [ i - 1 ] >= '0' && str [ i - 1 ] <= '9' ) stringstack . push ( str [ i ] ) ; else { stringstack . push ( str [ i ] ) ; integerstack . push ( 1 ) ; } } else stringstack . push ( str [ i ] ) ; } while ( ! stringstack . empty ( ) ) { result = stringstack . top ( ) + result ; stringstack . pop ( ) ; } return result ; }
Ref: 
def decode ( Str ) : NEW_LINE INDENT integerstack = [ ] NEW_LINE stringstack = [ ] NEW_LINE temp = " " NEW_LINE result = " " NEW_LINE for i in range ( len ( Str ) ) : NEW_LINE INDENT count = 0 NEW_LINE if ( Str [ i ] >= '0' and Str [ i ] <= '9' ) : NEW_LINE INDENT while ( Str [ i ] >= '0' and Str [ i ] <= '9' ) : NEW_LINE INDENT count = count * 10 + ord ( Str [ i ] ) - ord ( '0' ) NEW_LINE i += 1 NEW_LINE DEDENT i -= 1 NEW_LINE integerstack . append ( count ) NEW_LINE DEDENT elif ( Str [ i ] == ' ] ' ) : NEW_LINE INDENT temp = " " NEW_LINE count = 0 NEW_LINE if ( len ( integerstack ) != 0 ) : NEW_LINE INDENT count = integerstack [ - 1 ] NEW_LINE integerstack . pop ( ) NEW_LINE DEDENT while ( len ( stringstack ) != 0 and stringstack [ - 1 ] != ' [ ' ) : NEW_LINE INDENT temp = stringstack [ - 1 ] + temp NEW_LINE stringstack . pop ( ) NEW_LINE DEDENT if ( len ( stringstack ) != 0 and stringstack [ - 1 ] == ' [ ' ) : NEW_LINE INDENT stringstack . pop ( ) NEW_LINE DEDENT for j in range ( count ) : NEW_LINE INDENT result = result + temp NEW_LINE DEDENT for j in range ( len ( result ) ) : NEW_LINE INDENT stringstack . append ( result [ j ] ) NEW_LINE DEDENT result = " " NEW_LINE DEDENT elif ( Str [ i ] == ' [ ' ) : NEW_LINE INDENT if ( Str [ i - 1 ] >= '0' and Str [ i - 1 ] <= '9' ) : NEW_LINE INDENT stringstack . append ( Str [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT stringstack . append ( Str [ i ] ) NEW_LINE integerstack . append ( 1 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT stringstack . append ( Str [ i ] ) NEW_LINE DEDENT DEDENT while len ( stringstack ) != 0 : NEW_LINE INDENT result = stringstack [ - 1 ] + result NEW_LINE stringstack . pop ( ) NEW_LINE DEDENT return result NEW_LINE DEDENT
Hyp: 
def decode ( str ) : NEW_LINE INDENT integerstack = [ ] NEW_LINE stringstack = [ ] NEW_LINE temp = " " NEW_LINE result = " " NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT count = 0 NEW_LINE if ( str [ i ] >= '0' and str [ i ] <= '9' ) : NEW_LINE INDENT while ( str [ i ] >= '0' and str [ i ] <= '9' ) : NEW_LINE INDENT count = count * 10 + ord ( str [ i ] ) - ord ( '0' ) NEW_LINE i += 1 NEW_LINE DEDENT integerstack . append ( count ) NEW_LINE DEDENT elif ( str [ i ] == ' [ ' ) : NEW_LINE INDENT temp = " " NEW_LINE count = 0 NEW_LINE if ( len ( stringstack ) != 0 and stringstack [ - 1 ] != ' [ ' ) : NEW_LINE INDENT temp = stringstack [ - 1 ] + temp NEW_LINE stringstack . pop ( ) NEW_LINE DEDENT for j in range ( count ) : NEW_LINE INDENT result = result + temp NEW_LINE DEDENT for j in range ( len ( result ) ) : NEW_LINE INDENT stringstack . append ( result [ j ] ) NEW_LINE DEDENT result = " " NEW_LINE DEDENT elif ( str [ i ] == ' [ ' ) : NEW_LINE INDENT if ( str [ i - 1 ] >= '0' and str [ i - 1 ] <= '9' ) : NEW_LINE INDENT stringstack . append ( str [ i ] ) NEW_LINE integerstack . append ( 1 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT stringstack . append ( str [ i ] ) NEW_LINE DEDENT DEDENT while ( len ( stringstack ) != 0 ) : NEW_LINE INDENT result = stringstack [ - 1 ] + result NEW_LINE stringstack . pop ( ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT

BLEU: 71.54
Edit Sim: 366


Src: 
int minSum ( int A [ ] , int n ) { int min_val = * min_element ( A , A + n ) ; return ( min_val * ( n - 1 ) ) ; }
Ref: 
def minSum ( A ) : NEW_LINE INDENT min_val = min ( A ) ; NEW_LINE return min_val * ( len ( A ) - 1 ) NEW_LINE DEDENT
Hyp: 
def minSum ( A , n ) : NEW_LINE INDENT min_val = min ( A ) NEW_LINE return ( min_val * ( n - 1 ) ) NEW_LINE DEDENT

BLEU: 56.71
Edit Sim: 16


Src: 
bool isPower ( int x , int y ) { int res1 = log ( y ) / log ( x ) ; double res2 = log ( y ) / log ( x ) ; return ( res1 == res2 ) ; }
Ref: 
def isPower ( x , y ) : NEW_LINE INDENT res1 = math . log ( y ) / math . log ( x ) NEW_LINE res2 = math . log ( y ) / math . log ( x ) NEW_LINE return 1 if ( res1 == res2 ) else 0 NEW_LINE DEDENT
Hyp: 
def isPower ( x , y ) : NEW_LINE INDENT res1 = math . log ( y ) / math . log ( x ) NEW_LINE res2 = math . log ( y ) / math . log ( x ) NEW_LINE return ( res1 == res2 ) NEW_LINE DEDENT

BLEU: 87.02
Edit Sim: 12


Src: 
int countWords ( string str [ ] , int n ) { unordered_map < string , int > m ; for ( int i = 0 ; i < n ; i ++ ) m [ str [ i ] ] += 1 ; int res = 0 ; for ( auto it = m . begin ( ) ; it != m . end ( ) ; it ++ ) if ( ( it -> second == 2 ) ) res ++ ; return res ; }
Ref: 
def countWords ( stri , n ) : NEW_LINE INDENT m = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT m [ stri [ i ] ] = m . get ( stri [ i ] , 0 ) + 1 NEW_LINE DEDENT res = 0 NEW_LINE for i in m . values ( ) : NEW_LINE INDENT if i == 2 : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
Hyp: 
def countWords ( str , n ) : NEW_LINE INDENT mp = defaultdict ( lambda : 0 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ str [ i ] ] += 1 NEW_LINE DEDENT res = 0 NEW_LINE for key , values in mp . items ( ) : NEW_LINE INDENT if values == 2 : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT

BLEU: 56.38
Edit Sim: 76


Src: 
int findLargestd ( int S [ ] , int n ) { bool found = false ; sort ( S , S + n ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == j ) continue ; for ( int k = j + 1 ; k < n ; k ++ ) { if ( i == k ) continue ; for ( int l = k + 1 ; l < n ; l ++ ) { if ( i == l ) continue ; if ( S [ i ] == S [ j ] + S [ k ] + S [ l ] ) { found = true ; return S [ i ] ; } } } } } if ( found == false ) return INT_MIN ; }
Ref: 
def findLargestd ( S , n ) : NEW_LINE INDENT found = False NEW_LINE S . sort ( ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT continue NEW_LINE DEDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT if ( i == k ) : NEW_LINE INDENT continue NEW_LINE DEDENT for l in range ( k + 1 , n ) : NEW_LINE INDENT if ( i == l ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( S [ i ] == S [ j ] + S [ k ] + S [ l ] ) : NEW_LINE INDENT found = True NEW_LINE return S [ i ] NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT if ( found == False ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT
Hyp: 
def findLargestd ( S , n ) : NEW_LINE INDENT found = False NEW_LINE S . sort ( ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT continue NEW_LINE DEDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT if ( i == k ) : NEW_LINE INDENT continue NEW_LINE DEDENT for l in range ( k + 1 , n ) : NEW_LINE INDENT if ( i == l ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( S [ i ] == S [ j ] + S [ k ] + S [ l ] ) : NEW_LINE INDENT found = True NEW_LINE return S [ i ] NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT if ( found == False ) : NEW_LINE INDENT return INT_MIN NEW_LINE DEDENT

BLEU: 97.47
Edit Sim: 14


Src: 
e9 int minMaxValues ( int arr [ ] , int n , int m ) { int sum = 0 ; for ( int i = 0 ; i < ( n + m ) ; i ++ ) { sum += arr [ i ] ; arr [ i ] += 50 ; } bool dp [ MAX + 1 ] [ MAX * MAX + 1 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; dp [ 0 ] [ 0 ] = 1 ; for ( int i = 0 ; i < ( n + m ) ; i ++ ) { for ( int k = min ( n , i + 1 ) ; k >= 1 ; k -- ) { for ( int j = 0 ; j < MAX * MAX + 1 ; j ++ ) { if ( dp [ k - 1 ] [ j ] ) dp [ k ] [ j + arr [ i ] ] = 1 ; } } } int max_value = - INF , min_value = INF ; for ( int i = 0 ; i < MAX * MAX + 1 ; i ++ ) { if ( dp [ n ] [ i ] ) { int temp = i - 50 * n ; max_value = max ( max_value , temp * ( sum - temp ) ) ; min_value = min ( min_value , temp * ( sum - temp ) ) ; } } cout << " Maximum ▁ Value : ▁ " << max_value << " \n " << " Minimum ▁ Value : ▁ " << min_value << endl ; }
Ref: 
def minMaxValues ( arr , n , m ) : NEW_LINE INDENT sum = 0 NEW_LINE INF = 1000000000 NEW_LINE MAX = 50 NEW_LINE for i in range ( 0 , ( n + m ) ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE arr [ i ] += 50 NEW_LINE DEDENT dp = [ [ 0 for x in range ( MAX * MAX + 1 ) ] for y in range ( MAX + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 0 , ( n + m ) ) : NEW_LINE INDENT for k in range ( min ( n , i + 1 ) , 0 , - 1 ) : NEW_LINE INDENT for j in range ( 0 , MAX * MAX + 1 ) : NEW_LINE INDENT if ( dp [ k - 1 ] [ j ] ) : NEW_LINE INDENT dp [ k ] [ j + arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT max_value = - 1 * INF NEW_LINE min_value = INF NEW_LINE for i in range ( 0 , MAX * MAX + 1 ) : NEW_LINE INDENT if ( dp [ n ] [ i ] ) : NEW_LINE INDENT temp = i - 50 * n NEW_LINE max_value = max ( max_value , temp * ( sum - temp ) ) NEW_LINE min_value = min ( min_value , temp * ( sum - temp ) ) NEW_LINE DEDENT DEDENT print ( " Maximum ▁ Value : ▁ { } \n Minimum ▁ Value : ▁ { } " . format ( max_value , min_value ) ) NEW_LINE DEDENT
Hyp: 
def minMaxValues ( arr , n , m ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n + m ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE arr [ i ] += 50 NEW_LINE DEDENT dp = [ [ False for i in range ( MAX + 1 ) ] for i in range ( MAX + 1 ) ] NEW_LINE for i in range ( n + m ) : NEW_LINE INDENT for k in range ( min ( n , i + 1 ) , MAX * MAX + 1 ) : NEW_LINE INDENT for j in range ( MAX * MAX + 1 ) : NEW_LINE INDENT if ( dp [ k - 1 ] [ j ] ) : NEW_LINE INDENT dp [ k ] [ j + arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT DEDENT max_value = - INF NEW_LINE min_value = INF NEW_LINE for i in range ( MAX * MAX + 1 ) : NEW_LINE INDENT if ( dp [ n ] [ i ] ) : NEW_LINE INDENT temp = i - 50 * n NEW_LINE max_value = max ( max_value , temp * ( sum - temp ) ) NEW_LINE min_value = min ( min_value , temp * ( sum - temp ) ) NEW_LINE DEDENT DEDENT print ( " Maximum ▁ Value : ▁ " , max_value ) NEW_LINE print ( " Minimum ▁ Value : ▁ " , min_value ) NEW_LINE DEDENT

BLEU: 76.44
Edit Sim: 175


Src: 
void constructTree ( int n , int d , int h ) { if ( d == 1 ) { if ( n == 2 && h == 1 ) { cout << "1 ▁ 2" << endl ; return ; } cout << " - 1" << endl ; return ; } if ( d > 2 * h ) { cout << " - 1" << endl ; return ; } for ( int i = 1 ; i <= h ; i ++ ) cout << i << " ▁ " << i + 1 << endl ; if ( d > h ) { cout << "1" << " ▁ " << h + 2 << endl ; for ( int i = h + 2 ; i <= d ; i ++ ) { cout << i << " ▁ " << i + 1 << endl ; } } for ( int i = d + 1 ; i < n ; i ++ ) { int k = 1 ; if ( d == h ) k = 2 ; cout << k << " ▁ " << i + 1 << endl ; } }
Ref: 
def constructTree ( n , d , h ) : NEW_LINE INDENT if d == 1 : NEW_LINE INDENT if n == 2 and h == 1 : NEW_LINE INDENT print ( "1 ▁ 2" ) NEW_LINE return 0 NEW_LINE DEDENT print ( " - 1" ) NEW_LINE return 0 NEW_LINE DEDENT if d > 2 * h : NEW_LINE INDENT print ( " - 1" ) NEW_LINE return 0 NEW_LINE DEDENT for i in range ( 1 , h + 1 ) : NEW_LINE INDENT print ( i , " ▁ " , i + 1 ) NEW_LINE DEDENT if d > h : NEW_LINE INDENT print ( 1 , " ▁ ▁ " , h + 2 ) NEW_LINE for i in range ( h + 2 , d + 1 ) : NEW_LINE INDENT print ( i , " ▁ " , i + 1 ) NEW_LINE DEDENT DEDENT for i in range ( d + 1 , n ) : NEW_LINE INDENT k = 1 NEW_LINE if d == h : NEW_LINE INDENT k = 2 NEW_LINE DEDENT print ( k , " ▁ " , i + 1 ) NEW_LINE DEDENT DEDENT
Hyp: 
def constructTree ( n , d , h ) : NEW_LINE INDENT if ( d == 1 ) : NEW_LINE INDENT if ( n == 2 and h == 1 ) : NEW_LINE INDENT print ( "1 ▁ 2" , endl ) NEW_LINE return NEW_LINE DEDENT print ( " - 1" , endl ) NEW_LINE return NEW_LINE DEDENT if ( d > 2 * h ) : NEW_LINE INDENT print ( " - 1" , endl ) NEW_LINE return NEW_LINE DEDENT for i in range ( 1 , h + 1 ) : NEW_LINE INDENT print ( i , " ▁ " , i + 1 ) NEW_LINE DEDENT if ( d > h ) : NEW_LINE INDENT print ( "1" , " ▁ " , h + 2 ) NEW_LINE for i in range ( h + 2 , d + 1 ) : NEW_LINE INDENT print ( i , " ▁ " , i + 1 ) NEW_LINE DEDENT DEDENT for i in range ( d + 1 , n ) : NEW_LINE INDENT k = 1 NEW_LINE if ( d == h ) : NEW_LINE INDENT k = 2 NEW_LINE DEDENT print ( k , " ▁ " , i + 1 ) NEW_LINE DEDENT DEDENT

BLEU: 78.62
Edit Sim: 51


Src: 
int rectCount ( int n , int m ) { return ( m * n * ( n + 1 ) * ( m + 1 ) ) / 4 ; }
Ref: 
def rectCount ( n , m ) : NEW_LINE INDENT return ( m * n * ( n + 1 ) * ( m + 1 ) ) // 4 NEW_LINE DEDENT
Hyp: 
def rectCount ( n , m ) : NEW_LINE INDENT return ( m * n * ( n + 1 ) * ( m + 1 ) ) // 4 NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
void sortUsingHash ( int a [ ] , int n ) { int max = * std :: max_element ( a , a + n ) ; int hash [ max + 1 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) hash [ a [ i ] ] += 1 ; for ( int i = 0 ; i <= max ; i ++ ) { if ( hash [ i ] ) { for ( int j = 0 ; j < hash [ i ] ; j ++ ) { cout << i << " ▁ " ; } } } }
Ref: 
def sortUsingHash ( a , n ) : NEW_LINE INDENT Max = max ( a ) NEW_LINE Hash = [ 0 ] * ( Max + 1 ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT Hash [ a [ i ] ] += 1 NEW_LINE DEDENT for i in range ( 0 , Max + 1 ) : NEW_LINE INDENT if Hash [ i ] != 0 : NEW_LINE INDENT for j in range ( 0 , Hash [ i ] ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
Hyp: 
def sortUsingHash ( a , n ) : NEW_LINE INDENT max1 = max ( a ) NEW_LINE hash = [ 0 for i in range ( max1 + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT hash [ a [ i ] ] = hash [ a [ i ] ] + 1 NEW_LINE DEDENT for i in range ( max1 + 1 ) : NEW_LINE INDENT if ( hash [ i ] ) : NEW_LINE INDENT for j in range ( hash [ i ] ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT DEDENT

BLEU: 62.51
Edit Sim: 63


Src: 
void subarrayDivisibleByK ( int arr [ ] , int n , int k ) { map < int , int > mp ; int s = 0 , e = 0 , maxs = 0 , maxe = 0 ; mp [ arr [ 0 ] % k ] ++ ; for ( int i = 1 ; i < n ; i ++ ) { int mod = arr [ i ] % k ; while ( mp [ k - mod ] != 0 || ( mod == 0 && mp [ mod ] != 0 ) ) { mp [ arr [ s ] % k ] -- ; s ++ ; } mp [ mod ] ++ ; e ++ ; if ( ( e - s ) > ( maxe - maxs ) ) { maxe = e ; maxs = s ; } } cout << " The ▁ maximum ▁ size ▁ is ▁ " << maxe - maxs + 1 << " ▁ and ▁ " " the ▁ subarray ▁ is ▁ as ▁ follows \n " ; for ( int i = maxs ; i <= maxe ; i ++ ) cout << arr [ i ] << " ▁ " ; }
Ref: 
def subarrayDivisibleByK ( arr , n , k ) : NEW_LINE INDENT mp = [ 0 ] * 1000 NEW_LINE s = 0 e = 0 maxs = 0 maxe = 0 NEW_LINE mp [ arr [ 0 ] % k ] = mp [ arr [ 0 ] % k ] + 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT mod = arr [ i ] % k NEW_LINE while ( mp [ k - mod ] != 0 or ( mod == 0 and mp [ mod ] != 0 ) ) : NEW_LINE INDENT mp [ arr [ s ] % k ] = mp [ arr [ s ] % k ] - 1 NEW_LINE s = s + 1 NEW_LINE DEDENT mp [ mod ] = mp [ mod ] + 1 NEW_LINE e = e + 1 NEW_LINE if ( ( e - s ) > ( maxe - maxs ) ) : NEW_LINE INDENT maxe = e NEW_LINE maxs = s NEW_LINE DEDENT DEDENT print ( " The ▁ maximum ▁ size ▁ is ▁ { } ▁ and ▁ the ▁ " . format ( ( maxe - maxs + 1 ) ) ) for i in range ( maxs , maxe + 1 ) : NEW_LINE INDENT print ( " { } ▁ " . format ( arr [ i ] ) , end = " " ) NEW_LINE DEDENT DEDENT
Hyp: 
def subarrayDivisibleByK ( arr , n , k ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE s = 0 NEW_LINE e = 0 NEW_LINE maxs = 0 NEW_LINE maxe = 0 NEW_LINE mp [ arr [ 0 ] % k ] = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT mod = arr [ i ] % k NEW_LINE while ( mp [ k - mod ] != 0 or ( mod == 0 and mp [ mod ] != 0 ) ) : NEW_LINE INDENT mp [ arr [ s ] % k ] -= 1 NEW_LINE s += 1 NEW_LINE DEDENT mp [ mod ] += 1 NEW_LINE e += 1 NEW_LINE if ( ( e - s ) > ( maxe - maxs ) ) : NEW_LINE INDENT maxe = e NEW_LINE maxs = s NEW_LINE DEDENT DEDENT print ( " The ▁ maximum ▁ size ▁ is " , maxe - maxs + 1 , " and ▁ " , arr [ i ] , end = " ▁ " ) NEW_LINE for i in range ( maxs , maxe + 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT

BLEU: 66.48
Edit Sim: 166


Src: 
bool isDivisible ( char str [ ] , int k ) { int n = strlen ( str ) ; int c = 0 ; for ( int i = 0 ; i < k ; i ++ ) if ( str [ n - i - 1 ] == '0' ) c ++ ; return ( c == k ) ; }
Ref: 
def isDivisible ( str , k ) : NEW_LINE INDENT n = len ( str ) NEW_LINE c = 0 NEW_LINE for i in range ( 0 , k ) : NEW_LINE INDENT if ( str [ n - i - 1 ] == '0' ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT return ( c == k ) NEW_LINE DEDENT
Hyp: 
def isDivisible ( str , k ) : NEW_LINE INDENT n = len ( str ) NEW_LINE c = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT if ( str [ n - i - 1 ] == '0' ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT return ( c == k ) NEW_LINE DEDENT

BLEU: 94.32
Edit Sim: 4


Src: 
int divisible ( string num ) { int n = num . length ( ) ; int sum = accumulate ( begin ( num ) , end ( num ) , 0 ) - '0' * 1 ; if ( sum % 3 == 0 ) return 0 ; if ( n == 1 ) return - 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( sum % 3 == ( num [ i ] - '0' ) % 3 ) return 1 ; if ( n == 2 ) return - 1 ; return 2 ; }
Ref: 
def divisible ( num ) : NEW_LINE INDENT n = len ( num ) NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += int ( num [ i ] ) NEW_LINE DEDENT if ( sum % 3 == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( sum % 3 == int ( num [ i ] ) % 3 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT if ( n == 2 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return 2 NEW_LINE DEDENT
Hyp: 
def divisible ( num ) : NEW_LINE INDENT n = len ( num ) NEW_LINE sum = int ( accumulate ( num ) , end ( num ) , 0 ) - '0' * 1 NEW_LINE if ( sum % 3 == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( sum % 3 == ( num [ i ] - '0' ) % 3 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT if ( n == 2 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return 2 NEW_LINE DEDENT

BLEU: 76.86
Edit Sim: 75


Src: 
int superSeq ( char * X , char * Y , int m , int n ) { if ( ! m ) return n ; if ( ! n ) return m ; if ( X [ m - 1 ] == Y [ n - 1 ] ) return 1 + superSeq ( X , Y , m - 1 , n - 1 ) ; return 1 + min ( superSeq ( X , Y , m - 1 , n ) , superSeq ( X , Y , m , n - 1 ) ) ; }
Ref: 
def superSeq ( X , Y , m , n ) : NEW_LINE INDENT if ( not m ) : return n NEW_LINE if ( not n ) : return m NEW_LINE if ( X [ m - 1 ] == Y [ n - 1 ] ) : NEW_LINE INDENT return 1 + superSeq ( X , Y , m - 1 , n - 1 ) NEW_LINE DEDENT return 1 + min ( superSeq ( X , Y , m - 1 , n ) , superSeq ( X , Y , m , n - 1 ) ) NEW_LINE DEDENT
Hyp: 
def superSeq ( X , Y , m , n ) : NEW_LINE INDENT if ( ! m ) : NEW_LINE INDENT return n NEW_LINE DEDENT if ( not n ) : NEW_LINE INDENT return m NEW_LINE DEDENT if ( X [ m - 1 ] == Y [ n - 1 ] ) : NEW_LINE INDENT return 1 + superSeq ( X , Y , m - 1 , n - 1 ) NEW_LINE DEDENT return 1 + min ( superSeq ( X , Y , m - 1 , n ) , superSeq ( X , Y , m , n - 1 ) ) NEW_LINE DEDENT

BLEU: 86.42
Edit Sim: 49


Src: 
void swapUpperToLower ( int arr [ n ] [ n ] ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int temp = arr [ i ] [ j ] ; arr [ i ] [ j ] = arr [ j ] [ i ] ; arr [ j ] [ i ] = temp ; } } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) cout << arr [ i ] [ j ] << " ▁ " ; cout << endl ; } }
Ref: 
def swapUpperToLower ( arr ) : NEW_LINE INDENT n = 4 ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT temp = arr [ i ] [ j ] ; NEW_LINE arr [ i ] [ j ] = arr [ j ] [ i ] ; NEW_LINE arr [ j ] [ i ] = temp ; NEW_LINE DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] [ j ] , end = " ▁ " ) ; NEW_LINE DEDENT print ( " ▁ " ) ; NEW_LINE DEDENT DEDENT
Hyp: 
def swapUpperToLower ( arr ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT temp = arr [ i ] [ j ] NEW_LINE arr [ i ] [ j ] = arr [ j ] [ i ] NEW_LINE arr [ j ] [ i ] = temp NEW_LINE DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] [ j ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT

BLEU: 82.19
Edit Sim: 33


Src: 
int kthgroupsum ( int k ) { int cur = ( k * ( k - 1 ) ) + 1 ; int sum = 0 ; while ( k -- ) { sum += cur ; cur += 2 ; } return sum ; }
Ref: 
def kthgroupsum ( k ) : NEW_LINE INDENT cur = int ( ( k * ( k - 1 ) ) + 1 ) NEW_LINE sum = 0 NEW_LINE while k : NEW_LINE INDENT sum += cur NEW_LINE cur += 2 NEW_LINE k = k - 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT
Hyp: 
def kthgroupsum ( k ) : NEW_LINE INDENT cur = ( k * ( k - 1 ) ) + 1 NEW_LINE sum = 0 NEW_LINE while ( k > 0 ) : NEW_LINE INDENT sum += cur NEW_LINE cur += 2 NEW_LINE DEDENT return sum NEW_LINE DEDENT

BLEU: 71.57
Edit Sim: 35


Src: 
bool isMagicSquare ( int mat [ ] [ N ] ) { int sum = 0 , sum2 = 0 ; for ( int i = 0 ; i < N ; i ++ ) sum = sum + mat [ i ] [ i ] ; for ( int i = 0 ; i < N ; i ++ ) sum2 = sum2 + mat [ i ] [ N - 1 - i ] ; if ( sum != sum2 ) return false ; for ( int i = 0 ; i < N ; i ++ ) { int rowSum = 0 ; for ( int j = 0 ; j < N ; j ++ ) rowSum += mat [ i ] [ j ] ; if ( rowSum != sum ) return false ; } for ( int i = 0 ; i < N ; i ++ ) { int colSum = 0 ; for ( int j = 0 ; j < N ; j ++ ) colSum += mat [ j ] [ i ] ; if ( sum != colSum ) return false ; } return true ; }
Ref: 
def isMagicSquare ( mat ) : NEW_LINE INDENT s = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT s = s + mat [ i ] [ i ] NEW_LINE DEDENT s2 = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT s2 = s2 + mat [ i ] [ N - i - 1 ] NEW_LINE DEDENT if ( s != s2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 0 , N ) : NEW_LINE INDENT rowSum = 0 NEW_LINE for j in range ( 0 , N ) : NEW_LINE INDENT rowSum += mat [ i ] [ j ] NEW_LINE DEDENT if ( rowSum != s ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT for i in range ( 0 , N ) : NEW_LINE INDENT colSum = 0 NEW_LINE for j in range ( 0 , N ) : NEW_LINE INDENT colSum += mat [ j ] [ i ] NEW_LINE DEDENT if ( s != colSum ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
Hyp: 
def isMagicSquare ( mat ) : NEW_LINE INDENT sum = 0 NEW_LINE sum2 = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum = sum + mat [ i ] [ i ] NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT sum2 = sum2 + mat [ i ] [ N - 1 - i ] NEW_LINE DEDENT if ( sum != sum2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT rowSum = 0 NEW_LINE for j in range ( N ) : NEW_LINE INDENT rowSum += mat [ i ] [ j ] NEW_LINE DEDENT if ( rowSum != sum ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT colSum = 0 NEW_LINE for j in range ( N ) : NEW_LINE INDENT colSum += mat [ j ] [ i ] NEW_LINE DEDENT if ( sum != colSum ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT

BLEU: 70.03
Edit Sim: 93


Src: 
bool isScalarMatrix ( int mat [ N ] [ N ] ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) if ( ( i != j ) && ( mat [ i ] [ j ] != 0 ) ) return false ; for ( int i = 0 ; i < N - 1 ; i ++ ) if ( mat [ i ] [ i ] != mat [ i + 1 ] [ i + 1 ] ) return false ; return true ; }
Ref: 
def isScalarMatrix ( mat ) : NEW_LINE INDENT for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( 0 , N ) : NEW_LINE INDENT if ( ( i != j ) and ( mat [ i ] [ j ] != 0 ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT for i in range ( 0 , N - 1 ) : NEW_LINE INDENT if ( mat [ i ] [ i ] != mat [ i + 1 ] [ i + 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
Hyp: 
def isScalarMatrix ( mat ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if ( ( i != j ) and ( mat [ i ] [ j ] != 0 ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT for i in range ( N - 1 ) : NEW_LINE INDENT if ( mat [ i ] [ i ] != mat [ i + 1 ] [ i + 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT

BLEU: 90.11
Edit Sim: 12


Src: 
int longSubarrWthSumDivByK ( int arr [ ] , int n , int k ) { unordered_map < int , int > um ; int mod_arr [ n ] , max = 0 ; int curr_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { curr_sum += arr [ i ] ; mod_arr [ i ] = ( ( curr_sum % k ) + k ) % k ; } for ( int i = 0 ; i < n ; i ++ ) { if ( mod_arr [ i ] == 0 ) max = i + 1 ; else if ( um . find ( mod_arr [ i ] ) == um . end ( ) ) um [ mod_arr [ i ] ] = i ; else if ( max < ( i - um [ mod_arr [ i ] ] ) ) max = i - um [ mod_arr [ i ] ] ; } return max ; }
Ref: 
def longSubarrWthSumDivByK ( arr , n , k ) : NEW_LINE INDENT um = { i : 0 for i in range ( 8 ) } NEW_LINE mod_arr = [ 0 for i in range ( n ) ] NEW_LINE max = 0 NEW_LINE curr_sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT curr_sum += arr [ i ] NEW_LINE mod_arr [ i ] = ( ( curr_sum % k ) + k ) % k NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( mod_arr [ i ] == 0 ) : NEW_LINE INDENT max = i + 1 NEW_LINE DEDENT elif ( mod_arr [ i ] in um ) : NEW_LINE INDENT um [ mod_arr [ i ] ] = i NEW_LINE DEDENT else : NEW_LINE INDENT if ( max < ( i - um [ mod_arr [ i ] ] ) ) : NEW_LINE INDENT max = i - um [ mod_arr [ i ] ] NEW_LINE DEDENT DEDENT DEDENT return max NEW_LINE DEDENT
Hyp: 
def longSubarrWthSumDivByK ( arr , n , k ) : NEW_LINE INDENT um = dict ( ) NEW_LINE mod_arr = [ 0 ] * n NEW_LINE max = 0 NEW_LINE curr_sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT curr_sum += arr [ i ] NEW_LINE mod_arr [ i ] = ( ( curr_sum % k ) + k ) % k NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( mod_arr [ i ] == 0 ) : NEW_LINE INDENT max = i + 1 NEW_LINE DEDENT elif ( mod_arr [ i ] not in um ) : NEW_LINE INDENT um [ mod_arr [ i ] ] = i NEW_LINE DEDENT elif ( max < ( i - um [ mod_arr [ i ] ] ) ) : NEW_LINE INDENT max = i - um [ mod_arr [ i ] ] NEW_LINE DEDENT DEDENT return max NEW_LINE DEDENT

BLEU: 80.28
Edit Sim: 84


Src: 
void reverse ( string str ) { if ( str . size ( ) == 0 ) { return ; } reverse ( str . substr ( 1 ) ) ; cout << str [ 0 ] ; }
Ref: 
def reverse ( string ) : NEW_LINE INDENT if len ( string ) == 0 : NEW_LINE INDENT return NEW_LINE DEDENT temp = string [ 0 ] NEW_LINE reverse ( string [ 1 : ] ) NEW_LINE print ( temp , end = ' ' ) NEW_LINE DEDENT
Hyp: 
def reverse ( str ) : NEW_LINE INDENT if ( len ( str ) == 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT str = list ( str ) NEW_LINE print ( str [ 0 ] , end = " " ) NEW_LINE DEDENT

BLEU: 36.19
Edit Sim: 61


Src: 
long long arrangeBraces ( int n , int pos [ ] , int k ) { bool h [ N ] ; int dp [ N ] [ N ] ; memset ( h , 0 , sizeof h ) ; memset ( dp , 0 , sizeof dp ) ; for ( int i = 0 ; i < k ; i ++ ) h [ pos [ i ] ] = 1 ; dp [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= 2 * n ; i ++ ) { for ( int j = 0 ; j <= 2 * n ; j ++ ) { if ( h [ i ] ) { if ( j != 0 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = 0 ; } else { if ( j != 0 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] ; else dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] ; } } } return dp [ 2 * n ] [ 0 ] ; }
Ref: 
def arrangeBraces ( n , pos , k ) : NEW_LINE INDENT h = [ False for i in range ( N ) ] NEW_LINE dp = [ [ 0 for i in range ( N ) ] for i in range ( N ) ] NEW_LINE for i in range ( k ) : NEW_LINE INDENT h [ pos [ i ] ] = 1 NEW_LINE DEDENT dp [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , 2 * n + 1 ) : NEW_LINE INDENT for j in range ( 2 * n + 1 ) : NEW_LINE INDENT if ( h [ i ] ) : NEW_LINE INDENT if ( j != 0 ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( j != 0 ) : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] NEW_LINE DEDENT DEDENT DEDENT DEDENT return dp [ 2 * n ] [ 0 ] NEW_LINE DEDENT
Hyp: 
def arrangeBraces ( n , pos , k ) : NEW_LINE INDENT h = [ False for i in range ( k ) ] NEW_LINE dp = [ [ 0 for i in range ( k ) ] for j in range ( N ) ] NEW_LINE for i in range ( k ) : NEW_LINE INDENT h [ pos [ i ] ] = 1 NEW_LINE DEDENT dp [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , 2 * n + 1 ) : NEW_LINE INDENT for j in range ( 0 , 2 * n + 1 ) : NEW_LINE INDENT if ( h [ i ] ) : NEW_LINE INDENT if ( j != 0 ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( j != 0 ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] NEW_LINE DEDENT DEDENT DEDENT return dp [ 2 * n ] [ 0 ] NEW_LINE DEDENT

BLEU: 93.99
Edit Sim: 18


Src: 
bool isDvisibleBy12 ( string num ) { if ( num . length ( ) >= 3 ) { int d1 = ( int ) num [ num . length ( ) - 1 ] ; if ( d1 % 2 != 0 ) return ( 0 ) ; int d2 = ( int ) num [ num . length ( ) - 2 ] ; int sum = 0 ; for ( int i = 0 ; i < num . length ( ) ; i ++ ) sum += num [ i ] ; return ( sum % 3 == 0 && ( d2 * 10 + d1 ) % 4 == 0 ) ; } else { int number = stoi ( num ) ; return ( number % 12 == 0 ) ; } }
Ref: 
def isDvisibleBy12 ( num ) : NEW_LINE INDENT if ( len ( num ) >= 3 ) : NEW_LINE INDENT d1 = int ( num [ len ( num ) - 1 ] ) NEW_LINE if ( d1 % 2 != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT d2 = int ( num [ len ( num ) - 2 ] ) NEW_LINE sum = 0 NEW_LINE for i in range ( 0 , len ( num ) ) : NEW_LINE INDENT sum += int ( num [ i ] ) NEW_LINE DEDENT return ( sum % 3 == 0 and ( d2 * 10 + d1 ) % 4 == 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT number = int ( num ) NEW_LINE return ( number % 12 == 0 ) NEW_LINE DEDENT DEDENT
Hyp: 
def isDvisibleBy12 ( num ) : NEW_LINE INDENT if ( len ( num ) >= 3 ) : NEW_LINE INDENT d1 = ord ( num [ len ( num ) - 1 ] ) NEW_LINE if ( d1 % 2 != 0 ) : NEW_LINE INDENT return ( 0 ) NEW_LINE DEDENT d2 = ord ( num [ len ( num ) - 2 ] ) NEW_LINE sum = 0 NEW_LINE for i in range ( len ( num ) ) : NEW_LINE INDENT sum += num [ i ] NEW_LINE DEDENT return ( sum % 3 == 0 and ( d2 * 10 + d1 ) % 4 == 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT number = ord ( num ) NEW_LINE return ( number % 12 == 0 ) NEW_LINE DEDENT DEDENT

BLEU: 86.69
Edit Sim: 26


Src: 
int maxDiff ( int arr [ ] , int n ) { int SubsetSum_1 = 0 , SubsetSum_2 = 0 ; for ( int i = 0 ; i <= n - 1 ; i ++ ) { bool isSingleOccurance = true ; for ( int j = i + 1 ; j <= n - 1 ; j ++ ) { if ( arr [ i ] == arr [ j ] ) { isSingleOccurance = false ; arr [ i ] = arr [ j ] = 0 ; break ; } } if ( isSingleOccurance ) { if ( arr [ i ] > 0 ) SubsetSum_1 += arr [ i ] ; else SubsetSum_2 += arr [ i ] ; } } return abs ( SubsetSum_1 - SubsetSum_2 ) ; }
Ref: 
def maxDiff ( arr , n ) : NEW_LINE INDENT SubsetSum_1 = 0 NEW_LINE SubsetSum_2 = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT isSingleOccurance = True NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] == arr [ j ] ) : NEW_LINE INDENT isSingleOccurance = False NEW_LINE arr [ i ] = arr [ j ] = 0 NEW_LINE break NEW_LINE DEDENT DEDENT if ( isSingleOccurance == True ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT SubsetSum_1 += arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT SubsetSum_2 += arr [ i ] NEW_LINE DEDENT DEDENT DEDENT return abs ( SubsetSum_1 - SubsetSum_2 ) NEW_LINE DEDENT
Hyp: 
def maxDiff ( arr , n ) : NEW_LINE INDENT SubsetSum_1 = 0 NEW_LINE SubsetSum_2 = 0 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT isSingleOccurance = True NEW_LINE for j in range ( i + 1 , n - 1 ) : NEW_LINE INDENT if arr [ i ] == arr [ j ] : NEW_LINE INDENT isSingleOccurance = False NEW_LINE arr [ i ] = arr [ j ] = 0 NEW_LINE break NEW_LINE DEDENT DEDENT if isSingleOccurance : NEW_LINE INDENT if arr [ i ] > 0 : NEW_LINE INDENT SubsetSum_1 += arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT SubsetSum_2 += arr [ i ] NEW_LINE DEDENT DEDENT DEDENT return abs ( SubsetSum_1 - SubsetSum_2 ) NEW_LINE DEDENT

BLEU: 85.38
Edit Sim: 28


Src: 
string lexSmallest ( string a [ ] , int n ) { sort ( a , a + n , compare ) ; string answer = " " ; for ( int i = 0 ; i < n ; i ++ ) answer += a [ i ] ; return answer ; }
Ref: 
def lexSmallest ( a , n ) : NEW_LINE INDENT a . sort ( reverse = True ) NEW_LINE answer = " " NEW_LINE for i in range ( n ) : NEW_LINE INDENT answer += a [ i ] NEW_LINE DEDENT return answer NEW_LINE DEDENT
Hyp: 
def lexSmallest ( a , n ) : NEW_LINE INDENT a . sort ( reverse = True ) NEW_LINE answer = " " NEW_LINE for i in range ( n ) : NEW_LINE INDENT answer += a [ i ] NEW_LINE DEDENT return answer NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int maxCost ( int mat [ ] [ MAX ] , int N ) { int dp [ N ] [ N ] ; memset ( dp , 0 , sizeof ( dp ) ) ; dp [ 0 ] [ 0 ] = mat [ 0 ] [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) dp [ i ] [ 0 ] = mat [ i ] [ 0 ] + dp [ i - 1 ] [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) for ( int j = 1 ; j < i + 1 && j < N ; j ++ ) dp [ i ] [ j ] = mat [ i ] [ j ] + max ( dp [ i - 1 ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ; int result = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( result < dp [ N - 1 ] [ i ] ) result = dp [ N - 1 ] [ i ] ; return result ; }
Ref: 
def maxCost ( mat , N ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( N ) ] for j in range ( N ) ] NEW_LINE dp [ 0 ] [ 0 ] = mat [ 0 ] [ 0 ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT dp [ i ] [ 0 ] = mat [ i ] [ 0 ] + dp [ i - 1 ] [ 0 ] NEW_LINE DEDENT for i in range ( 1 , N ) : NEW_LINE INDENT for j in range ( 1 , min ( i + 1 , N ) ) : NEW_LINE INDENT dp [ i ] [ j ] = mat [ i ] [ j ] + \ NEW_LINE INDENT max ( dp [ i - 1 ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT result = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( result < dp [ N - 1 ] [ i ] ) : NEW_LINE INDENT result = dp [ N - 1 ] [ i ] NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
Hyp: 
def maxCost ( mat , N ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( N ) ] for j in range ( N ) ] NEW_LINE dp [ 0 ] [ 0 ] = mat [ 0 ] [ 0 ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT for j in range ( 1 , i + 1 and N ) : NEW_LINE INDENT dp [ i ] [ 0 ] = mat [ i ] [ 0 ] + dp [ i - 1 ] [ 0 ] NEW_LINE DEDENT DEDENT result = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( result < dp [ N - 1 ] [ i ] ) : NEW_LINE INDENT result = dp [ N - 1 ] [ i ] NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT

BLEU: 65.12
Edit Sim: 184


Src: 
int xorZero ( string str ) { int one_count = 0 , zero_count = 0 ; int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) if ( str [ i ] == '1' ) one_count ++ ; else zero_count ++ ; if ( one_count % 2 == 0 ) return zero_count ; return one_count ; }
Ref: 
def xorZero ( str ) : NEW_LINE INDENT one_count = 0 NEW_LINE zero_count = 0 NEW_LINE n = len ( str ) NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( str [ i ] == '1' ) : NEW_LINE INDENT one_count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT zero_count += 1 NEW_LINE DEDENT DEDENT if ( one_count % 2 == 0 ) : NEW_LINE INDENT return zero_count NEW_LINE DEDENT return one_count NEW_LINE DEDENT
Hyp: 
def xorZero ( str ) : NEW_LINE INDENT one_count = 0 NEW_LINE zero_count = 0 NEW_LINE n = len ( str ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( str [ i ] == '1' ) : NEW_LINE INDENT one_count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT zero_count += 1 NEW_LINE DEDENT DEDENT if ( one_count % 2 == 0 ) : NEW_LINE INDENT return zero_count NEW_LINE DEDENT return one_count NEW_LINE DEDENT

BLEU: 95.71
Edit Sim: 4


Src: 
double nthRoot ( int A , int N ) { double xPre = rand ( ) % 10 ; double eps = 1e - 3 ; double delX = INT_MAX ; double xK ; while ( delX > eps ) { xK = ( ( N - 1.0 ) * xPre + ( double ) A / pow ( xPre , N - 1 ) ) / ( double ) N ; delX = abs ( xK - xPre ) ; xPre = xK ; } return xK ; }
Ref: 
def nthRoot ( A , N ) : NEW_LINE INDENT xPre = random . randint ( 1 , 101 ) % 10 NEW_LINE eps = 0.001 NEW_LINE delX = 2147483647 NEW_LINE xK = 0.0 NEW_LINE while ( delX > eps ) : NEW_LINE INDENT xK = ( ( N - 1.0 ) * xPre + A / pow ( xPre , N - 1 ) ) / N NEW_LINE delX = abs ( xK - xPre ) NEW_LINE xPre = xK NEW_LINE DEDENT return xK NEW_LINE DEDENT
Hyp: 
def nthRoot ( A , N ) : NEW_LINE INDENT xPre = rand ( ) % 10 NEW_LINE eps = 1e - 3 NEW_LINE delX = sys . maxsize NEW_LINE xK = ( ( N - 1.0 ) * xPre + ( double ) A / pow ( xPre , N - 1 ) ) / ( double ) N NEW_LINE delX = abs ( xK - xPre ) NEW_LINE xPre = xK NEW_LINE DEDENT return xK NEW_LINE DEDENT

BLEU: 65.79
Edit Sim: 110


Src: 
string findLeft ( string str ) { int n = str . length ( ) ; while ( n -- ) { if ( str [ n ] == ' d ' ) { str [ n ] = ' c ' ; break ; } if ( str [ n ] == ' b ' ) { str [ n ] = ' a ' ; break ; } if ( str [ n ] == ' a ' ) str [ n ] = ' b ' ; else if ( str [ n ] == ' c ' ) str [ n ] = ' d ' ; } return str ; }
Ref: 
def findLeft ( str ) : NEW_LINE INDENT n = len ( str ) - 1 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT if ( str [ n ] == ' d ' ) : NEW_LINE INDENT str = str [ 0 : n ] + ' c ' + str [ n + 1 : ] NEW_LINE break NEW_LINE DEDENT if ( str [ n ] == ' b ' ) : NEW_LINE INDENT str = str [ 0 : n ] + ' a ' + str [ n + 1 : ] NEW_LINE break NEW_LINE DEDENT if ( str [ n ] == ' a ' ) : NEW_LINE INDENT str = str [ 0 : n ] + ' b ' + str [ n + 1 : ] NEW_LINE DEDENT elif ( str [ n ] == ' c ' ) : NEW_LINE INDENT str = str [ 0 : n ] + ' d ' + str [ n + 1 : ] NEW_LINE DEDENT n -= 1 NEW_LINE DEDENT return str NEW_LINE DEDENT
Hyp: 
def findLeft ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE while ( n > 0 ) : NEW_LINE INDENT if ( str [ n ] == ' d ' ) : NEW_LINE INDENT str = list ( str ) NEW_LINE break NEW_LINE DEDENT if ( str [ n ] == ' b ' ) : NEW_LINE INDENT str = list ( str ) NEW_LINE break NEW_LINE DEDENT if ( str [ n ] == ' a ' ) : NEW_LINE INDENT str = list ( str ) NEW_LINE break NEW_LINE DEDENT if ( str [ n ] == ' b ' ) : NEW_LINE INDENT str = ' b ' NEW_LINE DEDENT elif ( str [ n ] == ' c ' ) : NEW_LINE INDENT str = ' d ' NEW_LINE DEDENT DEDENT return str NEW_LINE DEDENT

BLEU: 54.13
Edit Sim: 158


Src: 
int subset ( int ar [ ] , int n ) { int res = 0 ; sort ( ar , ar + n ) ; for ( int i = 0 ; i < n ; i ++ ) { int count = 1 ; for ( ; i < n - 1 ; i ++ ) { if ( ar [ i ] == ar [ i + 1 ] ) count ++ ; else break ; } res = max ( res , count ) ; } return res ; }
Ref: 
def subset ( ar , n ) : NEW_LINE INDENT res = 0 NEW_LINE ar . sort ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT count = 1 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ar [ i ] == ar [ i + 1 ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT res = max ( res , count ) NEW_LINE DEDENT return res NEW_LINE DEDENT
Hyp: 
def subset ( ar , n ) : NEW_LINE INDENT res = 0 NEW_LINE ar . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT count = 1 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( ar [ i ] == ar [ i + 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT res = max ( res , count ) NEW_LINE DEDENT return res NEW_LINE DEDENT

BLEU: 92.61
Edit Sim: 8


Src: 
void minRange ( int arr [ ] , int n , int k ) { int l = 0 , r = n ; for ( int i = 0 ; i < n ; i ++ ) { unordered_set < int > s ; int j ; for ( j = i ; j < n ; j ++ ) { s . insert ( arr [ j ] ) ; if ( s . size ( ) == k ) { if ( ( j - i ) < ( r - l ) ) { r = j ; l = i ; } break ; } } if ( j == n ) break ; } if ( l == 0 && r == n ) cout << " Invalid ▁ k " ; else cout << l << " ▁ " << r ; }
Ref: 
def minRange ( arr , n , k ) : NEW_LINE INDENT l = 0 NEW_LINE r = n NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = [ ] NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT s . append ( arr [ j ] ) NEW_LINE if ( len ( s ) == k ) : NEW_LINE INDENT if ( ( j - i ) < ( r - l ) ) : NEW_LINE INDENT r = j NEW_LINE l = i NEW_LINE DEDENT break NEW_LINE DEDENT DEDENT if ( j == n ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( l == 0 and r == n ) : NEW_LINE INDENT print ( " Invalid ▁ k " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( l , r ) NEW_LINE DEDENT DEDENT
Hyp: 
def minRange ( arr , n , k ) : NEW_LINE INDENT l = 0 NEW_LINE r = n NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = set ( ) NEW_LINE j = i NEW_LINE for j in range ( n ) : NEW_LINE INDENT s . add ( arr [ j ] ) NEW_LINE if ( len ( s ) == k ) : NEW_LINE INDENT if ( ( j - i ) < ( r - l ) ) : NEW_LINE INDENT r = j NEW_LINE l = i NEW_LINE DEDENT break NEW_LINE DEDENT DEDENT if ( j == n ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( l == 0 and r == n ) : NEW_LINE INDENT print ( " Invalid ▁ k " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( l , " ▁ " , r ) NEW_LINE DEDENT DEDENT

BLEU: 89.08
Edit Sim: 37


Src: 
int findSum ( int A [ ] , int B [ ] , int n ) { unordered_map < int , int > hash ; for ( int i = 0 ; i < n ; i ++ ) { hash [ A [ i ] ] ++ ; hash [ B [ i ] ] ++ ; } int sum = 0 ; for ( auto x : hash ) if ( x . second == 1 ) sum += x . first ; return sum ; }
Ref: 
def findSum ( A , B , n ) : NEW_LINE INDENT Hash = defaultdict ( lambda : 0 ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT Hash [ A [ i ] ] += 1 NEW_LINE Hash [ B [ i ] ] += 1 NEW_LINE DEDENT Sum = 0 NEW_LINE for x in Hash : NEW_LINE INDENT if Hash [ x ] == 1 : NEW_LINE INDENT Sum += x NEW_LINE DEDENT DEDENT return Sum NEW_LINE DEDENT
Hyp: 
def findSum ( A , B , n ) : NEW_LINE INDENT Hash = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT Hash [ A [ i ] ] = Hash . get ( A [ i ] , 0 ) + 1 NEW_LINE Hash [ B [ i ] ] = Hash . get ( B [ i ] , 0 ) + 1 NEW_LINE DEDENT sum = 0 NEW_LINE for x in Hash : NEW_LINE INDENT if ( Hash [ x ] == 1 ) : NEW_LINE INDENT sum += x NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT

BLEU: 56.16
Edit Sim: 89


Src: 
void printSubStr ( string str , int low , int high ) { for ( int i = low ; i <= high ; ++ i ) cout << str [ i ] ; }
Ref: 
def printSubStr ( st , low , high ) : NEW_LINE INDENT sys . stdout . write ( st [ low : high + 1 ] ) NEW_LINE sys . stdout . flush ( ) NEW_LINE return ' ' NEW_LINE DEDENT
Hyp: 
def printSubStr ( str , low , high ) : NEW_LINE INDENT for i in range ( low , high + 1 ) : NEW_LINE INDENT print ( str [ i ] , end = " " ) NEW_LINE DEDENT DEDENT

BLEU: 29.25
Edit Sim: 67


Src: 
int evenSum ( int n ) { int C [ n + 1 ] [ n + 1 ] ; int i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= min ( i , n ) ; j ++ ) { if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } int sum = 0 ; for ( int i = 0 ; i <= n ; i += 2 ) sum += C [ n ] [ i ] ; return sum ; }
Ref: 
def evenSum ( n ) : NEW_LINE INDENT C = [ [ 0 for x in range ( n + 1 ) ] for y in range ( n + 1 ) ] NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT for j in range ( 0 , min ( i , n + 1 ) ) : NEW_LINE INDENT if j == 0 or j == i : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT sum = 0 ; NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT if n % 2 == 0 : NEW_LINE INDENT sum = sum + C [ n ] [ i ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
Hyp: 
def evenSum ( n ) : NEW_LINE INDENT C = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( min ( i , n ) + 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT sum = 0 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT sum += C [ n ] [ i ] NEW_LINE DEDENT return sum NEW_LINE DEDENT

BLEU: 76.26
Edit Sim: 69


Src: 
int getMinSquares ( int n ) { int * dp = new int [ n + 1 ] ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; dp [ 2 ] = 2 ; dp [ 3 ] = 3 ; for ( int i = 4 ; i <= n ; i ++ ) { dp [ i ] = i ; for ( int x = 1 ; x <= ceil ( sqrt ( i ) ) ; x ++ ) { int temp = x * x ; if ( temp > i ) break ; else dp [ i ] = min ( dp [ i ] , 1 + dp [ i - temp ] ) ; } } int res = dp [ n ] ; delete [ ] dp ; return res ; }
Ref: 
def getMinSquares ( n ) : NEW_LINE INDENT dp = [ 0 , 1 , 2 , 3 ] NEW_LINE for i in range ( 4 , n + 1 ) : NEW_LINE INDENT dp . append ( i ) NEW_LINE for x in range ( 1 , int ( ceil ( sqrt ( i ) ) ) + 1 ) : NEW_LINE INDENT temp = x * x ; NEW_LINE if temp > i : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] = min ( dp [ i ] , 1 + dp [ i - temp ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ n ] NEW_LINE DEDENT
Hyp: 
def getMinSquares ( n ) : NEW_LINE INDENT dp = [ 0 for i in range ( n + 1 ) ] NEW_LINE dp [ 0 ] = 0 NEW_LINE dp [ 1 ] = 1 NEW_LINE dp [ 2 ] = 2 NEW_LINE dp [ 3 ] = 3 NEW_LINE for i in range ( 4 , n + 1 ) : NEW_LINE INDENT dp [ i ] = i NEW_LINE for x in range ( 1 , math . ceil ( math . sqrt ( i ) ) + 1 ) : NEW_LINE INDENT temp = x * x NEW_LINE if ( temp > i ) : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] = min ( dp [ i ] , 1 + dp [ i - temp ] ) NEW_LINE DEDENT DEDENT DEDENT res = dp [ n ] NEW_LINE delete [ dp ] NEW_LINE return res NEW_LINE DEDENT

BLEU: 56.56
Edit Sim: 180


Src: 
void arrayEvenAndOdd ( int arr [ ] , int n ) { int i = - 1 , j = 0 ; int t ; while ( j != n ) { if ( arr [ j ] % 2 == 0 ) { i ++ ; swap ( arr [ i ] , arr [ j ] ) ; } j ++ ; } for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; }
Ref: 
def arrayEvenAndOdd ( arr , n ) : NEW_LINE INDENT i = - 1 NEW_LINE j = 0 NEW_LINE while ( j != n ) : NEW_LINE INDENT if ( arr [ j ] % 2 == 0 ) : NEW_LINE INDENT i = i + 1 NEW_LINE arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ] NEW_LINE DEDENT j = j + 1 NEW_LINE DEDENT for i in arr : NEW_LINE INDENT print ( str ( i ) + " ▁ " , end = ' ' ) NEW_LINE DEDENT DEDENT
Hyp: 
def arrayEvenAndOdd ( arr , n ) : NEW_LINE INDENT i = - 1 NEW_LINE j = 0 NEW_LINE while ( j != n ) : NEW_LINE INDENT if ( arr [ j ] % 2 == 0 ) : NEW_LINE INDENT i += 1 NEW_LINE arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ] NEW_LINE DEDENT j += 1 NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT

BLEU: 77.8
Edit Sim: 40


Src: 
void diagonalsquare ( int mat [ ] [ MAX ] , int row , int column ) { cout << " Diagonal ▁ one ▁ : ▁ " ; for ( int i = 0 ; i < row ; i ++ ) { for ( int j = 0 ; j < column ; j ++ ) if ( i == j ) cout << mat [ i ] [ j ] * mat [ i ] [ j ] << " ▁ " ; } cout << " ▁ \n \n Diagonal ▁ two ▁ : ▁ " ; for ( int i = 0 ; i < row ; i ++ ) { for ( int j = 0 ; j < column ; j ++ ) if ( i + j == column - 1 ) cout << mat [ i ] [ j ] * mat [ i ] [ j ] << " ▁ ▁ " ; } }
Ref: 
def diagonalsquare ( mat , row , column ) : NEW_LINE INDENT print ( " Diagonal ▁ one ▁ : ▁ " , end = " " ) NEW_LINE for i in range ( 0 , row ) : NEW_LINE INDENT for j in range ( 0 , column ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT print ( " { } ▁ " . format ( mat [ i ] [ j ] * mat [ i ] [ j ] ) , end = " " ) NEW_LINE DEDENT DEDENT DEDENT print ( " ▁ \n \n Diagonal ▁ two ▁ : ▁ " , end = " " ) NEW_LINE for i in range ( 0 , row ) : NEW_LINE INDENT for j in range ( 0 , column ) : NEW_LINE INDENT if ( i + j == column - 1 ) : NEW_LINE INDENT print ( " { } ▁ " . format ( mat [ i ] [ j ] * mat [ i ] [ j ] ) , end = " " ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
Hyp: 
def diagonalsquare ( mat , row , column ) : NEW_LINE INDENT print ( " Diagonal ▁ one ▁ : ▁ " , end = " ▁ " ) NEW_LINE for i in range ( row ) : NEW_LINE INDENT for j in range ( column ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT print ( mat [ i ] [ j ] * mat [ i ] [ j ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT print ( " ▁ \n Diagonal ▁ two ▁ : ▁ " ) NEW_LINE for i in range ( row ) : NEW_LINE INDENT for j in range ( column ) : NEW_LINE INDENT if ( i + j == column - 1 ) : NEW_LINE INDENT print ( mat [ i ] [ j ] * mat [ i ] [ j ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT

BLEU: 72.4
Edit Sim: 97


Src: 
bool areSumSame ( int a [ ] [ MAX ] , int n , int m ) { int sum1 = 0 , sum2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum1 = 0 , sum2 = 0 ; for ( int j = 0 ; j < m ; j ++ ) { sum1 += a [ i ] [ j ] ; sum2 += a [ j ] [ i ] ; } if ( sum1 == sum2 ) return true ; } return false ; }
Ref: 
def areSumSame ( a , n , m ) : NEW_LINE INDENT sum1 = 0 NEW_LINE sum2 = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum1 = 0 NEW_LINE sum2 = 0 NEW_LINE for j in range ( 0 , m ) : NEW_LINE INDENT sum1 += a [ i ] [ j ] NEW_LINE sum2 += a [ j ] [ i ] NEW_LINE DEDENT if ( sum1 == sum2 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT
Hyp: 
def areSumSame ( a , n , m ) : NEW_LINE INDENT sum1 = 0 NEW_LINE sum2 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum1 = 0 NEW_LINE sum2 = 0 NEW_LINE for j in range ( m ) : NEW_LINE INDENT sum1 += a [ i ] [ j ] NEW_LINE sum2 += a [ j ] [ i ] NEW_LINE DEDENT if ( sum1 == sum2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT

BLEU: 86.76
Edit Sim: 17


Src: 
void printClosest ( int arr [ ] , int n , int x ) { int res_l , res_r ; int l = 0 , r = n - 1 , diff = INT_MAX ; while ( r > l ) { if ( abs ( arr [ l ] + arr [ r ] - x ) < diff ) { res_l = l ; res_r = r ; diff = abs ( arr [ l ] + arr [ r ] - x ) ; } if ( arr [ l ] + arr [ r ] > x ) r -- ; else l ++ ; } cout << " ▁ The ▁ closest ▁ pair ▁ is ▁ " << arr [ res_l ] << " ▁ and ▁ " << arr [ res_r ] ; }
Ref: 
def printClosest ( arr , n , x ) : NEW_LINE INDENT res_l , res_r = 0 , 0 NEW_LINE l , r , diff = 0 , n - 1 , MAX_VAL NEW_LINE while r > l : NEW_LINE INDENT if abs ( arr [ l ] + arr [ r ] - x ) < diff : NEW_LINE INDENT res_l = l NEW_LINE res_r = r NEW_LINE diff = abs ( arr [ l ] + arr [ r ] - x ) NEW_LINE DEDENT if arr [ l ] + arr [ r ] > x : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT l += 1 NEW_LINE DEDENT DEDENT print ( ' The ▁ closest ▁ pair ▁ is ▁ { } ▁ and ▁ { } ' . format ( arr [ res_l ] , arr [ res_r ] ) ) NEW_LINE DEDENT
Hyp: 
def printClosest ( arr , n , x ) : NEW_LINE INDENT res_l = 0 NEW_LINE res_r = 0 NEW_LINE l = 0 NEW_LINE r = n - 1 NEW_LINE diff = sys . maxsize NEW_LINE while ( r > l ) : NEW_LINE INDENT if ( abs ( arr [ l ] + arr [ r ] - x ) < diff ) : NEW_LINE INDENT res_l = l NEW_LINE res_r = r NEW_LINE diff = abs ( arr [ l ] + arr [ r ] - x ) NEW_LINE DEDENT if ( arr [ l ] + arr [ r ] > x ) : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT l += 1 NEW_LINE DEDENT DEDENT print ( " The ▁ closest ▁ pair ▁ is " , arr [ res_l ] , " and ▁ " , arr [ res_r ] ) NEW_LINE DEDENT

BLEU: 71.33
Edit Sim: 101


Src: 
int countSubStr ( char str [ ] ) { int m = 0 ; for ( int i = 0 ; str [ i ] != ' \0' ; i ++ ) { if ( str [ i ] == '1' ) m ++ ; } return m * ( m - 1 ) / 2 ; }
Ref: 
def countSubStr ( st , n ) : NEW_LINE INDENT m = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( st [ i ] == '1' ) : NEW_LINE INDENT m = m + 1 NEW_LINE DEDENT DEDENT return m * ( m - 1 ) // 2 NEW_LINE DEDENT
Hyp: 
def countSubStr ( st , n ) : NEW_LINE INDENT m = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( st [ i ] == '1' ) : NEW_LINE INDENT m = m + 1 NEW_LINE DEDENT DEDENT return m * ( m - 1 ) / 2 NEW_LINE DEDENT

BLEU: 95.59
Edit Sim: 1


Src: 
int countSubstringWithEqualEnds ( string s ) { int result = 0 ; int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i ; j < n ; j ++ ) if ( s [ i ] == s [ j ] ) result ++ ; return result ; }
Ref: 
def countSubstringWithEqualEnds ( s ) : NEW_LINE INDENT result = 0 NEW_LINE n = len ( s ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT if ( s [ i ] == s [ j ] ) : NEW_LINE INDENT result = result + 1 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
Hyp: 
def countSubstringWithEqualEnds ( s ) : NEW_LINE INDENT result = 0 NEW_LINE n = len ( s ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT if ( s [ i ] == s [ j ] ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT

BLEU: 91.12
Edit Sim: 14


Src: 
int calcMaxValue ( string str ) { int res = str [ 0 ] - '0' ; for ( int i = 1 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] == '0' || str [ i ] == '1' || res < 2 ) res += ( str [ i ] - '0' ) ; else res *= ( str [ i ] - '0' ) ; } return res ; }
Ref: 
def calcMaxValue ( str ) : NEW_LINE INDENT res = ord ( str [ 0 ] ) - 48 NEW_LINE for i in range ( 1 , len ( str ) ) : NEW_LINE INDENT if ( str [ i ] == '0' or str [ i ] == '1' or res < 2 ) : NEW_LINE INDENT res += ord ( str [ i ] ) - 48 NEW_LINE DEDENT else : NEW_LINE INDENT res *= ord ( str [ i ] ) - 48 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
Hyp: 
def calcMaxValue ( str ) : NEW_LINE INDENT res = int ( str [ 0 ] ) - '0' NEW_LINE for i in range ( 1 , len ( str ) ) : NEW_LINE INDENT if ( str [ i ] == '0' or str [ i ] == '1' or res < 2 ) : NEW_LINE INDENT res += ( ord ( str [ i ] ) - ord ( '0' ) ) NEW_LINE DEDENT else : NEW_LINE INDENT res = res * ( ord ( str [ i ] ) - ord ( '0' ) ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT

BLEU: 75.19
Edit Sim: 42


Src: 
void bestFit ( int blockSize [ ] , int m , int processSize [ ] , int n ) { int allocation [ n ] ; memset ( allocation , - 1 , sizeof ( allocation ) ) ; for ( int i = 0 ; i < n ; i ++ ) { int bestIdx = - 1 ; for ( int j = 0 ; j < m ; j ++ ) { if ( blockSize [ j ] >= processSize [ i ] ) { if ( bestIdx == - 1 ) bestIdx = j ; else if ( blockSize [ bestIdx ] > blockSize [ j ] ) bestIdx = j ; } } if ( bestIdx != - 1 ) { allocation [ i ] = bestIdx ; blockSize [ bestIdx ] -= processSize [ i ] ; } } cout << " \n Process ▁ No . \tProcess ▁ Size\tBlock ▁ no . \n " ; for ( int i = 0 ; i < n ; i ++ ) { cout << " ▁ ▁ ▁ " << i + 1 << " \t\t " << processSize [ i ] << " \t\t " ; if ( allocation [ i ] != - 1 ) cout << allocation [ i ] + 1 ; else cout << " Not ▁ Allocated " ; cout << endl ; } }
Ref: 
def bestFit ( blockSize , m , processSize , n ) : NEW_LINE INDENT allocation = [ - 1 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT bestIdx = - 1 NEW_LINE for j in range ( m ) : NEW_LINE INDENT if blockSize [ j ] >= processSize [ i ] : NEW_LINE INDENT if bestIdx == - 1 : NEW_LINE INDENT bestIdx = j NEW_LINE DEDENT elif blockSize [ bestIdx ] > blockSize [ j ] : NEW_LINE INDENT bestIdx = j NEW_LINE DEDENT DEDENT DEDENT if bestIdx != - 1 : NEW_LINE INDENT allocation [ i ] = bestIdx NEW_LINE blockSize [ bestIdx ] -= processSize [ i ] NEW_LINE DEDENT DEDENT print ( " Process ▁ No . ▁ Process ▁ Size ▁ ▁ ▁ ▁ ▁ Block ▁ no . " ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( i + 1 , " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " , processSize [ i ] , end = " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " ) NEW_LINE if allocation [ i ] != - 1 : NEW_LINE INDENT print ( allocation [ i ] + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ Allocated " ) NEW_LINE DEDENT DEDENT DEDENT
Hyp: 
def bestfit ( blockSize , m , processSize , n ) : NEW_LINE INDENT allocation = [ - 1 ] * n NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT bestIdx = - 1 NEW_LINE for j in range ( 0 , m ) : NEW_LINE INDENT if ( blockSize [ j ] >= processSize [ i ] ) : NEW_LINE INDENT if ( bestIdx == - 1 ) : NEW_LINE INDENT bestIdx = j NEW_LINE DEDENT elif ( blockSize [ bestIdx ] > blockSize [ j ] ) : NEW_LINE INDENT bestIdx = j NEW_LINE DEDENT DEDENT DEDENT if ( bestIdx != - 1 ) : NEW_LINE INDENT allocation [ i ] = bestIdx NEW_LINE blockSize [ bestIdx ] -= processSize [ i ] NEW_LINE DEDENT DEDENT print ( " Process ▁ No . \tProcess ▁ Size\tBlock ▁ no . " ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( " ▁ " , i + 1 , " \t\t " , processSize [ i ] , " \t\t " , allocation [ i ] + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ Allocated " ) NEW_LINE DEDENT DEDENT

BLEU: 68.59
Edit Sim: 152


Src: 
void countFreq ( int a [ ] , int n ) { unordered_map < int , int > hm ; for ( int i = 0 ; i < n ; i ++ ) hm [ a [ i ] ] ++ ; int cumul = 0 ; for ( int i = 0 ; i < n ; i ++ ) { cumul += hm [ a [ i ] ] ; if ( hm [ a [ i ] ] ) { cout << a [ i ] << " - > " << cumul << endl ; } hm [ a [ i ] ] = 0 ; } }
Ref: 
def countFreq ( a , n ) : NEW_LINE INDENT hm = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT hm [ a [ i ] ] = hm . get ( a [ i ] , 0 ) + 1 NEW_LINE DEDENT cumul = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT cumul += hm [ a [ i ] ] NEW_LINE if ( hm [ a [ i ] ] > 0 ) : NEW_LINE INDENT print ( a [ i ] , " - > " , cumul ) NEW_LINE DEDENT hm [ a [ i ] ] = 0 NEW_LINE DEDENT DEDENT
Hyp: 
def countFreq ( a , n ) : NEW_LINE INDENT hm = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT hm [ a [ i ] ] = hm . get ( a [ i ] , 0 ) + 1 NEW_LINE DEDENT cumul = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT cumul += hm [ a [ i ] ] NEW_LINE if ( hm [ a [ i ] ] ) : NEW_LINE INDENT print ( a [ i ] , end = " - > " , cumul ) NEW_LINE DEDENT hm [ a [ i ] ] = 0 NEW_LINE DEDENT DEDENT

BLEU: 95.63
Edit Sim: 10


Src: 
bool isSubSeqDivisible ( string str ) { for ( int i = 0 ; i < l ; i ++ ) { for ( int j = i ; j < l ; j ++ ) { for ( int k = j ; k < l ; k ++ ) { if ( arr [ i ] % 8 == 0 ) return true ; else if ( ( arr [ i ] * 10 + arr [ j ] ) % 8 == 0 && i != j ) return true ; else if ( ( arr [ i ] * 100 + arr [ j ] * 10 + arr [ k ] ) % 8 == 0 && i != j && j != k && i != k ) return true ; } } } return false ; }
Ref: 
def isSubSeqDivisible ( st ) : NEW_LINE INDENT l = len ( st ) NEW_LINE arr = [ 0 ] * l NEW_LINE for i in range ( 0 , l ) : NEW_LINE INDENT for j in range ( i , l ) : NEW_LINE INDENT for k in range ( j , l ) : NEW_LINE INDENT if ( arr [ i ] % 8 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT elif ( ( arr [ i ] * 10 + arr [ j ] ) % 8 == 0 and i != j ) : NEW_LINE INDENT return True NEW_LINE DEDENT elif ( ( arr [ i ] * 100 + arr [ j ] * 10 + arr [ k ] ) % 8 == 0 and i != j and j != k and i != k ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT DEDENT return False NEW_LINE DEDENT
Hyp: 
def isSubSeqDivisible ( arr ) : NEW_LINE INDENT for i in range ( 0 , l ) : NEW_LINE INDENT for j in range ( i , l ) : NEW_LINE INDENT for k in range ( j , l ) : NEW_LINE INDENT if ( arr [ i ] % 8 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT elif ( ( arr [ i ] * 10 + arr [ j ] ) % 8 == 0 and i != j ) : NEW_LINE INDENT return True NEW_LINE DEDENT elif ( ( arr [ i ] * 100 + arr [ j ] * 10 + arr [ k ] ) % 8 == 0 and i != j and j != k and i != k ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT DEDENT return False NEW_LINE DEDENT

BLEU: 87.88
Edit Sim: 52


Src: 
unsigned int getAbs ( int n ) { int const mask = n >> ( sizeof ( int ) * CHARBIT - 1 ) ; return ( ( n + mask ) ^ mask ) ; }
Ref: 
def getAbs ( n ) : NEW_LINE INDENT mask = n >> ( SIZE_INT * CHARBIT - 1 ) NEW_LINE return ( ( n + mask ) ^ mask ) NEW_LINE DEDENT
Hyp: 
def getAbs ( n ) : NEW_LINE INDENT mask = n >> ( sizeof ( int ) * CHARBIT - 1 ) NEW_LINE return ( ( n + mask ) ^ mask ) NEW_LINE DEDENT

BLEU: 83.85
Edit Sim: 14


Src: 
int countPairs ( int arr [ ] , int n ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int product = arr [ i ] * arr [ j ] ; for ( int k = 0 ; k < n ; k ++ ) { if ( arr [ k ] == product ) { result ++ ; break ; } } } } return result ; }
Ref: 
def countPairs ( arr , n ) : NEW_LINE INDENT result = 0 ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT product = arr [ i ] * arr [ j ] ; NEW_LINE for k in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ k ] == product ) : NEW_LINE INDENT result = result + 1 ; NEW_LINE break ; NEW_LINE DEDENT DEDENT DEDENT DEDENT return result ; NEW_LINE DEDENT
Hyp: 
def countPairs ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT product = arr [ i ] * arr [ j ] NEW_LINE for k in range ( 0 , n ) : NEW_LINE INDENT if arr [ k ] == product : NEW_LINE INDENT result += 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT

BLEU: 76.53
Edit Sim: 31


Src: 
int minCost ( int a [ ] , int n , int k ) { int dp [ n + 1 ] [ k + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= k ; j ++ ) dp [ i ] [ j ] = inf ; dp [ 0 ] [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= k ; j ++ ) for ( int m = i - 1 ; m >= 0 ; m -- ) dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ m ] [ j - 1 ] + ( a [ i - 1 ] - a [ m ] ) * ( a [ i - 1 ] - a [ m ] ) ) ; return dp [ n ] [ k ] ; }
Ref: 
def minCost ( a , n , k ) : NEW_LINE INDENT dp = [ [ inf for i in range ( k + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , k + 1 ) : NEW_LINE INDENT for m in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ m ] [ j - 1 ] + ( a [ i - 1 ] - a [ m ] ) * ( a [ i - 1 ] - a [ m ] ) ) NEW_LINE DEDENT DEDENT DEDENT return dp [ n ] [ k ] NEW_LINE DEDENT
Hyp: 
def minCost ( a , n , k ) : NEW_LINE INDENT if ( k == 0 ) : NEW_LINE INDENT return inf NEW_LINE DEDENT dp = [ [ 0 for i in range ( k + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( k + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = inf NEW_LINE DEDENT DEDENT dp [ 0 ] [ 0 ] = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , k + 1 ) : NEW_LINE INDENT for m in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ m ] [ j - 1 ] + ( a [ i - 1 ] - a [ m ] ) * ( a [ i - 1 ] - a [ m ] ) ) NEW_LINE DEDENT DEDENT return dp [ n ] [ k ] NEW_LINE DEDENT

BLEU: 74.78
Edit Sim: 197


Src: 
bool containsOdd ( int G [ ] [ V ] , int src ) { int colorArr [ V ] ; for ( int i = 0 ; i < V ; ++ i ) colorArr [ i ] = - 1 ; colorArr [ src ] = 1 ; queue < int > q ; q . push ( src ) ; while ( ! q . empty ( ) ) { int u = q . front ( ) ; q . pop ( ) ; if ( G [ u ] [ u ] == 1 ) return true ; for ( int v = 0 ; v < V ; ++ v ) { if ( G [ u ] [ v ] && colorArr [ v ] == - 1 ) { colorArr [ v ] = 1 - colorArr [ u ] ; q . push ( v ) ; } else if ( G [ u ] [ v ] && colorArr [ v ] == colorArr [ u ] ) return true ; } } return false ; }
Ref: 
def containsOdd ( G , src ) : NEW_LINE INDENT global V NEW_LINE colorArr = [ - 1 ] * V NEW_LINE colorArr [ src ] = 1 NEW_LINE q = queue . Queue ( ) NEW_LINE q . put ( src ) NEW_LINE while ( not q . empty ( ) ) : NEW_LINE INDENT u = q . get ( ) NEW_LINE if ( G [ u ] [ u ] == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT for v in range ( V ) : NEW_LINE INDENT if ( G [ u ] [ v ] and colorArr [ v ] == - 1 ) : NEW_LINE INDENT colorArr [ v ] = 1 - colorArr [ u ] NEW_LINE q . put ( v ) NEW_LINE DEDENT elif ( G [ u ] [ v ] and colorArr [ v ] == colorArr [ u ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT
Hyp: 
def containsOdd ( G , src ) : NEW_LINE INDENT colorArr = [ 0 ] * V NEW_LINE for i in range ( V ) : NEW_LINE INDENT colorArr [ i ] = - 1 NEW_LINE DEDENT colorArr [ src ] = 1 NEW_LINE q = queue . Queue ( ) NEW_LINE q . put ( src ) NEW_LINE while ( not q . empty ( ) ) : NEW_LINE INDENT u = q . get ( ) NEW_LINE if ( G [ u ] [ u ] == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT for v in range ( V ) : NEW_LINE INDENT if ( G [ u ] [ v ] and colorArr [ v ] == - 1 ) : NEW_LINE INDENT colorArr [ v ] = 1 - colorArr [ u ] NEW_LINE q . put ( v ) NEW_LINE DEDENT elif ( G [ u ] [ v ] and colorArr [ v ] == colorArr [ u ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT

BLEU: 87.13
Edit Sim: 68


Src: 
int countSetBits ( int n ) { if ( n == 0 ) return 0 ; else return 1 + countSetBits ( n & ( n - 1 ) ) ; }
Ref: 
def countSetBits ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return 1 + countSetBits ( n & ( n - 1 ) ) NEW_LINE DEDENT DEDENT
Hyp: 
def countSetBits ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return 1 + countSetBits ( n & ( n - 1 ) ) NEW_LINE DEDENT DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
bool isAnBn ( string str ) { int n = str . length ( ) ; int i ; for ( i = 0 ; i < n ; i ++ ) if ( str [ i ] != ' a ' ) break ; if ( i * 2 != n ) return false ; int j ; for ( j = i ; j < n ; j ++ ) if ( str [ j ] != ' b ' ) return false ; return true ; }
Ref: 
def isAnBn ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( str [ i ] != ' a ' ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( i * 2 != n ) : NEW_LINE INDENT return False NEW_LINE DEDENT for j in range ( i , n ) : NEW_LINE INDENT if ( str [ j ] != ' b ' ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
Hyp: 
def isAnBn ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT if ( str [ i ] != ' a ' ) : NEW_LINE INDENT break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if ( i * 2 != n ) : NEW_LINE INDENT return False NEW_LINE DEDENT j = i NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT if ( str [ j ] != ' b ' ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT

BLEU: 80.38
Edit Sim: 50


Src: 
int getMinSquares ( unsigned int n ) { if ( sqrt ( n ) - floor ( sqrt ( n ) ) == 0 ) return 1 ; if ( n <= 3 ) return n ; int res = n ; for ( int x = 1 ; x <= n ; x ++ ) { int temp = x * x ; if ( temp > n ) break ; else res = min ( res , 1 + getMinSquares ( n - temp ) ) ; } return res ; }
Ref: 
def getMinSquares ( n ) : NEW_LINE INDENT if n <= 3 : NEW_LINE INDENT return n ; NEW_LINE DEDENT res = n NEW_LINE for x in range ( 1 , n + 1 ) : NEW_LINE INDENT temp = x * x ; NEW_LINE if temp > n : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT res = min ( res , 1 + getMinSquares ( n - temp ) ) NEW_LINE DEDENT DEDENT return res ; NEW_LINE DEDENT
Hyp: 
def getMinSquares ( n ) : NEW_LINE INDENT if ( ( math . sqrt ( n ) - floor ( math . sqrt ( n ) ) == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return n NEW_LINE DEDENT res = n NEW_LINE for x in range ( 1 , n + 1 ) : NEW_LINE INDENT temp = x * x NEW_LINE if ( temp > n ) : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT res = min ( res , 1 + getMinSquares ( n - temp ) ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT

BLEU: 60.99
Edit Sim: 118


Src: 
int maxDistance ( int arr [ ] , int n ) { unordered_map < int , int > mp ; int max_dist = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . find ( arr [ i ] ) == mp . end ( ) ) mp [ arr [ i ] ] = i ; else max_dist = max ( max_dist , i - mp [ arr [ i ] ] ) ; } return max_dist ; }
Ref: 
def maxDistance ( arr , n ) : NEW_LINE INDENT mp = { } NEW_LINE maxDict = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] not in mp . keys ( ) : NEW_LINE INDENT mp [ arr [ i ] ] = i NEW_LINE DEDENT else : NEW_LINE INDENT maxDict = max ( maxDict , i - mp [ arr [ i ] ] ) NEW_LINE DEDENT DEDENT return maxDict NEW_LINE DEDENT
Hyp: 
def maxDistance ( arr , n ) : NEW_LINE INDENT mp = { i : 0 for i in range ( 13 ) } NEW_LINE max_dist = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] not in mp : NEW_LINE INDENT mp [ arr [ i ] ] = i NEW_LINE DEDENT else : NEW_LINE INDENT max_dist = max ( max_dist , i - mp [ arr [ i ] ] ) NEW_LINE DEDENT DEDENT return max_dist NEW_LINE DEDENT

BLEU: 74.33
Edit Sim: 51


Src: 
int maxSumWO3Consec ( int arr [ ] , int n ) { int sum [ n ] ; if ( n >= 1 ) sum [ 0 ] = arr [ 0 ] ; if ( n >= 2 ) sum [ 1 ] = arr [ 0 ] + arr [ 1 ] ; if ( n > 2 ) sum [ 2 ] = max ( sum [ 1 ] , max ( arr [ 1 ] + arr [ 2 ] , arr [ 0 ] + arr [ 2 ] ) ) ; for ( int i = 3 ; i < n ; i ++ ) sum [ i ] = max ( max ( sum [ i - 1 ] , sum [ i - 2 ] + arr [ i ] ) , arr [ i ] + arr [ i - 1 ] + sum [ i - 3 ] ) ; return sum [ n - 1 ] ; }
Ref: 
def maxSumWO3Consec ( arr , n ) : NEW_LINE INDENT sum = [ 0 for k in range ( n ) ] NEW_LINE if n >= 1 : NEW_LINE INDENT sum [ 0 ] = arr [ 0 ] NEW_LINE DEDENT if n >= 2 : NEW_LINE INDENT sum [ 1 ] = arr [ 0 ] + arr [ 1 ] NEW_LINE DEDENT if n > 2 : NEW_LINE INDENT sum [ 2 ] = max ( sum [ 1 ] , max ( arr [ 1 ] + arr [ 2 ] , arr [ 0 ] + arr [ 2 ] ) ) NEW_LINE DEDENT for i in range ( 3 , n ) : NEW_LINE INDENT sum [ i ] = max ( max ( sum [ i - 1 ] , sum [ i - 2 ] + arr [ i ] ) , arr [ i ] + arr [ i - 1 ] + sum [ i - 3 ] ) NEW_LINE DEDENT return sum [ n - 1 ] NEW_LINE DEDENT
Hyp: 
def maxSumWO3Consec ( arr , n ) : NEW_LINE INDENT sum = [ 0 for i in range ( n ) ] NEW_LINE if n >= 1 : NEW_LINE INDENT sum [ 0 ] = arr [ 0 ] NEW_LINE DEDENT if n >= 2 : NEW_LINE INDENT sum [ 1 ] = arr [ 0 ] + arr [ 1 ] NEW_LINE DEDENT if n > 2 : NEW_LINE INDENT sum [ 2 ] = max ( sum [ 1 ] , max ( arr [ 1 ] + arr [ 2 ] , arr [ 0 ] + arr [ 2 ] ) ) NEW_LINE DEDENT for i in range ( 3 , n ) : NEW_LINE INDENT sum [ i ] = max ( max ( sum [ i - 1 ] , sum [ i - 2 ] + arr [ i ] ) , arr [ i ] + arr [ i - 1 ] + sum [ i - 3 ] ) NEW_LINE DEDENT return sum [ n - 1 ] NEW_LINE DEDENT

BLEU: 98.59
Edit Sim: 1


Src: 
void checkEulerFourSquareIdentity ( int a , int b ) { int ab = a * b ; bool flag = false ; int i = 0 ; while ( i * i <= ab ) { int j = i ; while ( i * i + j * j <= ab ) { int k = j ; while ( i * i + j * j + k * k <= ab ) { double l = sqrt ( ab - ( i * i + j * j + k * k ) ) ; if ( floor ( l ) == ceil ( l ) && l >= k ) { flag = true ; cout << " i ▁ = ▁ " << i << " \n " ; cout << " j ▁ = ▁ " << j << " \n " ; cout << " k ▁ = ▁ " << k << " \n " ; cout << " l ▁ = ▁ " << ( int ) l << " \n " ; cout << " Product ▁ of ▁ " << a << " ▁ and ▁ " << b << " ▁ can ▁ be ▁ written ▁ as ▁ sum ▁ of ▁ squares " << " ▁ of ▁ i , ▁ j , ▁ k , ▁ l ▁ \n " ; cout << ab + " ▁ = ▁ " << i << " * " << i << " ▁ + ▁ " << j << " * " << j << " ▁ + ▁ " << k << " * " << k << " ▁ + ▁ " << ( int ) l << " * " << ( int ) l << " \n " ; } k += 1 ; } j += 1 ; } i += 1 ; } if ( flag == false ) { cout << " Solution ▁ doesn ' t ▁ exist ! \n " ; return ; } }
Ref: 
def checkEulerFourSquareIdentity ( a , b ) : NEW_LINE INDENT ab = a * b NEW_LINE flag = False NEW_LINE i = 0 NEW_LINE while i * i <= ab : NEW_LINE INDENT j = i NEW_LINE while i * i + j * j <= ab : NEW_LINE INDENT k = j NEW_LINE while i * i + j * j + k * k <= ab : NEW_LINE INDENT l = ( ab - ( i * i + j * j + k * k ) ) ** ( 0.5 ) NEW_LINE if l == int ( l ) and l >= k : NEW_LINE INDENT flag = True NEW_LINE print ( " i ▁ = ▁ " , i ) NEW_LINE print ( " j ▁ = ▁ " , j ) NEW_LINE print ( " k ▁ = ▁ " , k ) NEW_LINE print ( " l ▁ = ▁ " , l ) NEW_LINE print ( " Product ▁ of " , a , " and " , b , " can ▁ be ▁ written ▁ as ▁ sum ▁ of ▁ squares ▁ of ▁ i , ▁ j , ▁ k , ▁ l " ) NEW_LINE print ( ab , " ▁ = ▁ " , i , " * " , i , " + " , j , " * " , j , " + " , k , " * " , k , " + " , l , " * " , l ) NEW_LINE DEDENT k += 1 NEW_LINE DEDENT j += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if flag == False : NEW_LINE INDENT print ( " Solution ▁ doesn ' t ▁ exist ! " ) NEW_LINE return NEW_LINE DEDENT DEDENT
Hyp: 
def checkEulerFourSquareIdentity ( a , b ) : NEW_LINE INDENT ab = a * b NEW_LINE flag = False NEW_LINE i = 0 NEW_LINE while ( i * i <= ab ) : NEW_LINE INDENT j = i NEW_LINE while ( i * i + j * j <= ab ) : NEW_LINE INDENT k = j NEW_LINE while ( i * i + j * j + k * k <= ab ) : NEW_LINE INDENT l = math . sqrt ( ab - ( i * i + j * j + k * k ) ) NEW_LINE if ( floor ( l ) == ceil ( l ) and l >= k ) : NEW_LINE INDENT flag = True NEW_LINE print ( " i ▁ = ▁ " , i , " \n " ) NEW_LINE print ( " j ▁ = ▁ " , j , " \n " ) NEW_LINE print ( " k ▁ = ▁ " , k , " \n " , " l ▁ = ▁ " , ( int ) l , " \n " ) NEW_LINE print ( ab + " ▁ = ▁ " , i , " ▁ + ▁ " , j , " * " , k , " * " , l , " * " , ( int ) l , " \n " ) NEW_LINE DEDENT k += 1 NEW_LINE DEDENT j += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if ( flag == False ) : NEW_LINE INDENT print ( " Solution ▁ doesn't ▁ exist ! " ) NEW_LINE return NEW_LINE DEDENT DEDENT

BLEU: 67.03
Edit Sim: 220


Src: 
int nobleInteger ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) continue ; if ( arr [ i ] == n - i - 1 ) return arr [ i ] ; } if ( arr [ n - 1 ] == 0 ) return arr [ n - 1 ] ; return - 1 ; }
Ref: 
def nobleInteger ( arr ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE n = len ( arr ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if arr [ i ] == arr [ i + 1 ] : NEW_LINE INDENT continue NEW_LINE DEDENT if arr [ i ] == n - i - 1 : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT if arr [ n - 1 ] == 0 : NEW_LINE INDENT return arr [ n - 1 ] NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
Hyp: 
def nobleInteger ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if arr [ i ] == arr [ i + 1 ] : NEW_LINE INDENT continue NEW_LINE DEDENT if arr [ i ] == n - i - 1 : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT if arr [ n - 1 ] == 0 : NEW_LINE INDENT return arr [ n - 1 ] NEW_LINE DEDENT return - 1 NEW_LINE DEDENT

BLEU: 89.73
Edit Sim: 33


Src: 
int countIslands ( int mat [ ] [ N ] ) { int count = 0 ; for ( int i = 0 ; i < M ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( mat [ i ] [ j ] == ' X ' ) { if ( ( i == 0 || mat [ i - 1 ] [ j ] == ' O ' ) && ( j == 0 || mat [ i ] [ j - 1 ] == ' O ' ) ) count ++ ; } } } return count ; }
Ref: 
def countIslands ( mat ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , M ) : NEW_LINE INDENT for j in range ( 0 , N ) : NEW_LINE INDENT if ( mat [ i ] [ j ] == ' X ' ) : NEW_LINE INDENT if ( ( i == 0 or mat [ i - 1 ] [ j ] == ' O ' ) and ( j == 0 or mat [ i ] [ j - 1 ] == ' O ' ) ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
Hyp: 
def countIslands ( mat ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( M ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if ( mat [ i ] [ j ] == ' X ' ) : NEW_LINE INDENT if ( ( i == 0 or mat [ i - 1 ] [ j ] == ' O ' ) and ( j == 0 or mat [ i ] [ j - 1 ] == ' O ' ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return count NEW_LINE DEDENT

BLEU: 89.49
Edit Sim: 17


Src: 
int selectRandom ( int x ) { static int res ; static int count = 0 ; count ++ ; if ( count == 1 ) res = x ; else { int i = rand ( ) % count ; if ( i == count - 1 ) res = x ; } return res ; }
Ref: 
def selectRandom ( x ) : NEW_LINE INDENT res = 0 NEW_LINE count = 0 NEW_LINE count += 1 NEW_LINE if ( count == 1 ) : NEW_LINE INDENT res = x NEW_LINE DEDENT else : NEW_LINE INDENT i = random . randrange ( count ) NEW_LINE if ( i == count - 1 ) : NEW_LINE INDENT res = x NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
Hyp: 
def selectRandom ( x ) : NEW_LINE INDENT res = x NEW_LINE count = 0 NEW_LINE if ( count == 1 ) : NEW_LINE INDENT res = x NEW_LINE DEDENT else : NEW_LINE INDENT i = rand ( ) % count NEW_LINE if ( i == count - 1 ) : NEW_LINE INDENT res = x NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT

BLEU: 78.72
Edit Sim: 36


Src: 
void productArray ( int arr [ ] , int n ) { if ( n == 1 ) { cout << 0 ; return ; } int i , temp = 1 ; int * prod = new int [ ( sizeof ( int ) * n ) ] ; memset ( prod , 1 , n ) ; for ( i = 0 ; i < n ; i ++ ) { prod [ i ] = temp ; temp *= arr [ i ] ; } temp = 1 ; for ( i = n - 1 ; i >= 0 ; i -- ) { prod [ i ] *= temp ; temp *= arr [ i ] ; } for ( i = 0 ; i < n ; i ++ ) cout << prod [ i ] << " ▁ " ; return ; }
Ref: 
def productArray ( arr , n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT print ( 0 ) NEW_LINE return NEW_LINE DEDENT i , temp = 1 , 1 NEW_LINE prod = [ 1 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT prod [ i ] = temp NEW_LINE temp *= arr [ i ] NEW_LINE DEDENT temp = 1 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT prod [ i ] *= temp NEW_LINE temp *= arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( prod [ i ] , end = " ▁ " ) NEW_LINE DEDENT return NEW_LINE DEDENT
Hyp: 
def productArray ( arr , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT print ( 0 ) NEW_LINE return NEW_LINE DEDENT temp = 1 NEW_LINE prod = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT prod [ i ] = temp NEW_LINE temp *= arr [ i ] NEW_LINE DEDENT temp = 1 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT prod [ i ] *= temp NEW_LINE temp *= arr [ i ] NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( prod [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT

BLEU: 79.13
Edit Sim: 53


Src: 
bool sortedAfterSwap ( int A [ ] , bool B [ ] , int n ) { int i , j ; for ( i = 0 ; i < n - 1 ; i ++ ) { if ( B [ i ] ) { j = i ; while ( B [ j ] ) j ++ ; sort ( A + i , A + 1 + j ) ; i = j ; } } for ( i = 0 ; i < n ; i ++ ) { if ( A [ i ] != i + 1 ) return false ; } return true ; }
Ref: 
def sortedAfterSwap ( A , B , n ) : NEW_LINE INDENT for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( B [ i ] == 1 ) : NEW_LINE INDENT j = i NEW_LINE while ( B [ j ] == 1 ) : NEW_LINE INDENT j = j + 1 NEW_LINE DEDENT A = A [ 0 : i ] + sorted ( A [ i : j + 1 ] ) + A [ j + 1 : ] NEW_LINE i = j NEW_LINE DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( A [ i ] != i + 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
Hyp: 
def sortedAfterSwap ( A , B , n ) : NEW_LINE INDENT for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( B [ i ] ) : NEW_LINE INDENT j = i NEW_LINE while ( B [ j ] ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT A [ i ] = i + 1 NEW_LINE DEDENT return True NEW_LINE DEDENT

BLEU: 34.6
Edit Sim: 201


Src: 
int maxSubarrayXOR ( int arr [ ] , int n ) { int ans = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { int curr_xor = 0 ; for ( int j = i ; j < n ; j ++ ) { curr_xor = curr_xor ^ arr [ j ] ; ans = max ( ans , curr_xor ) ; } } return ans ; }
Ref: 
def maxSubarrayXOR ( arr , n ) : NEW_LINE INDENT ans = - 2147483648 NEW_LINE for i in range ( n ) : NEW_LINE INDENT curr_xor = 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT curr_xor = curr_xor ^ arr [ j ] NEW_LINE ans = max ( ans , curr_xor ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
Hyp: 
def maxSubarrayXOR ( arr , n ) : NEW_LINE INDENT ans = - sys . maxsize - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT curr_xor = 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT curr_xor = curr_xor ^ arr [ j ] NEW_LINE ans = max ( ans , curr_xor ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT

BLEU: 85.69
Edit Sim: 21


Src: 
int cost ( int a [ ] , int n ) { return ( n - 1 ) * ( * min_element ( a , a + n ) ) ; }
Ref: 
def cost ( a , n ) : NEW_LINE INDENT return ( ( n - 1 ) * min ( a ) ) NEW_LINE DEDENT
Hyp: 
def cost ( a , n ) : NEW_LINE INDENT return ( n - 1 ) * ( min_element ( a , a + n ) ) NEW_LINE DEDENT

BLEU: 66.02
Edit Sim: 20


Src: 
int minRemovalsDP ( int arr [ ] , int n ) { int longest_start = - 1 , longest_end = 0 ; for ( int start = 0 ; start < n ; start ++ ) { int min = INT_MAX , max = INT_MIN ; for ( int end = start ; end < n ; end ++ ) { int val = arr [ end ] ; if ( val < min ) min = val ; if ( val > max ) max = val ; if ( 2 * min <= max ) break ; if ( end - start > longest_end - longest_start || longest_start == - 1 ) { longest_start = start ; longest_end = end ; } } } if ( longest_start == - 1 ) return n ; return ( n - ( longest_end - longest_start + 1 ) ) ; }
Ref: 
def minRemovalsDP ( arr , n ) : NEW_LINE INDENT longest_start = - 1 NEW_LINE longest_end = 0 NEW_LINE for start in range ( n ) : NEW_LINE INDENT min = sys . maxsize NEW_LINE max = - sys . maxsize NEW_LINE for end in range ( start , n ) : NEW_LINE INDENT val = arr [ end ] NEW_LINE if ( val < min ) : NEW_LINE INDENT min = val NEW_LINE DEDENT if ( val > max ) : NEW_LINE INDENT max = val NEW_LINE DEDENT if ( 2 * min <= max ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( end - start > longest_end - longest_start or longest_start == - 1 ) : NEW_LINE INDENT longest_start = start NEW_LINE longest_end = end NEW_LINE DEDENT DEDENT DEDENT if ( longest_start == - 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT return ( n - ( longest_end - longest_start + 1 ) ) NEW_LINE DEDENT
Hyp: 
def minRemovalsDP ( arr , n ) : NEW_LINE INDENT longest_start = - 1 NEW_LINE longest_end = 0 NEW_LINE for start in range ( n ) : NEW_LINE INDENT min = sys . maxsize NEW_LINE max = sys . maxsize NEW_LINE for end in range ( start , n ) : NEW_LINE INDENT val = arr [ end ] NEW_LINE if val < min : NEW_LINE INDENT min = val NEW_LINE DEDENT if val > max : NEW_LINE INDENT max = val NEW_LINE DEDENT if 2 * min <= max : NEW_LINE INDENT break NEW_LINE DEDENT if end - start > longest_end - longest_start or longest_start == - 1 : NEW_LINE INDENT longest_start = start NEW_LINE longest_end = end NEW_LINE DEDENT DEDENT DEDENT if longest_start == - 1 : NEW_LINE INDENT return n NEW_LINE DEDENT return ( n - ( longest_end - longest_start + 1 ) ) NEW_LINE DEDENT

BLEU: 82.14
Edit Sim: 22


Src: 
int getInvCount ( int arr [ ] , int n ) { int invcount = 0 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { int small = 0 ; for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] > arr [ j ] ) small ++ ; int great = 0 ; for ( int j = i - 1 ; j >= 0 ; j -- ) if ( arr [ i ] < arr [ j ] ) great ++ ; invcount += great * small ; } return invcount ; }
Ref: 
def getInvCount ( arr , n ) : NEW_LINE INDENT invcount = 0 NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT small = 0 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] ) : NEW_LINE INDENT small += 1 NEW_LINE DEDENT DEDENT great = 0 NEW_LINE for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] < arr [ j ] ) : NEW_LINE INDENT great += 1 NEW_LINE DEDENT DEDENT invcount += great * small NEW_LINE DEDENT return invcount NEW_LINE DEDENT
Hyp: 
def getInvCount ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE invcount = 0 NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT small = 0 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if arr [ i ] > arr [ j ] : NEW_LINE INDENT small += 1 NEW_LINE DEDENT DEDENT great = 0 NEW_LINE for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT if arr [ i ] < arr [ j ] : NEW_LINE INDENT great += 1 NEW_LINE DEDENT DEDENT invcount += great * small NEW_LINE DEDENT return invcount NEW_LINE DEDENT

BLEU: 87.35
Edit Sim: 37


Src: 
double surface_area_octahedron ( double side ) { return ( 2 * ( sqrt ( 3 ) ) * ( side * side ) ) ; }
Ref: 
def surface_area_octahedron ( side ) : NEW_LINE INDENT return ( 2 * ( math . sqrt ( 3 ) ) * ( side * side ) ) NEW_LINE DEDENT
Hyp: 
def surface_area_octahedron ( side ) : NEW_LINE INDENT return ( 2 * ( math . sqrt ( 3 ) ) * ( side * side ) ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
void gnomeSort ( int arr [ ] , int n ) { int index = 0 ; while ( index < n ) { if ( index == 0 ) index ++ ; if ( arr [ index ] >= arr [ index - 1 ] ) index ++ ; else { swap ( arr [ index ] , arr [ index - 1 ] ) ; index -- ; } } return ; }
Ref: 
def gnomeSort ( arr , n ) : NEW_LINE INDENT index = 0 NEW_LINE while index < n : NEW_LINE INDENT if index == 0 : NEW_LINE INDENT index = index + 1 NEW_LINE DEDENT if arr [ index ] >= arr [ index - 1 ] : NEW_LINE INDENT index = index + 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ index ] , arr [ index - 1 ] = arr [ index - 1 ] , arr [ index ] NEW_LINE index = index - 1 NEW_LINE DEDENT DEDENT return arr NEW_LINE DEDENT
Hyp: 
def gnomeSort ( arr , n ) : NEW_LINE INDENT index = 0 NEW_LINE while ( index < n ) : NEW_LINE INDENT if ( index == 0 ) : NEW_LINE INDENT index += 1 NEW_LINE DEDENT if ( arr [ index ] >= arr [ index - 1 ] ) : NEW_LINE INDENT index += 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ index ] , arr [ index - 1 ] = arr [ index - 1 ] , arr [ index ] NEW_LINE index -= 1 NEW_LINE DEDENT DEDENT return NEW_LINE DEDENT

BLEU: 73.31
Edit Sim: 43


Src: 
int find ( int n , int k ) { if ( n + 1 >= k ) return ( k - 1 ) ; else return ( 2 * n + 1 - k ) ; }
Ref: 
def find ( n , k ) : NEW_LINE INDENT if ( n + 1 >= k ) : NEW_LINE INDENT return ( k - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( 2 * n + 1 - k ) NEW_LINE DEDENT DEDENT
Hyp: 
def find ( n , k ) : NEW_LINE INDENT if ( n + 1 >= k ) : NEW_LINE INDENT return ( k - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( 2 * n + 1 - k ) NEW_LINE DEDENT DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int countUnique ( int mat [ ] [ MAX ] , int n , int m ) { int rowsum [ n ] , colsum [ m ] ; memset ( colsum , 0 , sizeof ( colsum ) ) ; memset ( rowsum , 0 , sizeof ( rowsum ) ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( mat [ i ] [ j ] ) { rowsum [ i ] ++ ; colsum [ j ] ++ ; } int uniquecount = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( mat [ i ] [ j ] && rowsum [ i ] == 1 && colsum [ j ] == 1 ) uniquecount ++ ; return uniquecount ; }
Ref: 
def countUnique ( mat , n , m ) : NEW_LINE INDENT rowsum = [ 0 ] * n NEW_LINE colsum = [ 0 ] * m NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( mat [ i ] [ j ] != 0 ) : NEW_LINE INDENT rowsum [ i ] += 1 NEW_LINE colsum [ j ] += 1 NEW_LINE DEDENT DEDENT DEDENT uniquecount = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( mat [ i ] [ j ] != 0 and rowsum [ i ] == 1 and colsum [ j ] == 1 ) : NEW_LINE INDENT uniquecount += 1 NEW_LINE DEDENT DEDENT DEDENT return uniquecount NEW_LINE DEDENT
Hyp: 
def countUnique ( mat , n , m ) : NEW_LINE INDENT colsum = [ 0 ] * m NEW_LINE rowsum = [ 0 ] * n NEW_LINE colsum = [ 0 ] * m NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , m ) : NEW_LINE INDENT if ( mat [ i ] [ j ] ) : NEW_LINE INDENT rowsum [ i ] += 1 NEW_LINE colsum [ j ] += 1 NEW_LINE DEDENT DEDENT DEDENT uniquecount = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , m ) : NEW_LINE INDENT if ( mat [ i ] [ j ] and rowsum [ i ] == 1 and colsum [ j ] == 1 ) : NEW_LINE INDENT uniquecount += 1 NEW_LINE DEDENT DEDENT DEDENT return uniquecount NEW_LINE DEDENT

BLEU: 83.05
Edit Sim: 54


Src: 
void generate ( int ones , int zeroes , string str , int len ) { if ( len == str . length ( ) ) { cout << str << " ▁ ▁ " ; return ; } generate ( ones + 1 , zeroes , str + "1" , len ) ; if ( ones > zeroes ) generate ( ones , zeroes + 1 , str + "0" , len ) ; }
Ref: 
def generate ( ones , zeroes , str , len1 ) : NEW_LINE INDENT if ( len1 == len ( str ) ) : NEW_LINE INDENT print ( str , end = " ▁ " ) NEW_LINE return NEW_LINE DEDENT generate ( ones + 1 , zeroes , str + "1" , len1 ) NEW_LINE if ( ones > zeroes ) : NEW_LINE INDENT generate ( ones , zeroes + 1 , str + "0" , len1 ) NEW_LINE DEDENT DEDENT
Hyp: 
def generate ( ones , zeroes , str , len ) : NEW_LINE INDENT if ( len == len ( str ) ) : NEW_LINE INDENT print ( str , end = " ▁ " ) NEW_LINE return NEW_LINE DEDENT generate ( ones + 1 , zeroes , str + "1" , len ) NEW_LINE if ( ones > zeroes ) : NEW_LINE INDENT generate ( ones , zeroes + 1 , str + "0" , len ) NEW_LINE DEDENT DEDENT

BLEU: 87.31
Edit Sim: 4


Src: 
void midPointCircleDraw ( int x_centre , int y_centre , int r ) { int x = r , y = 0 ; cout << " ( " << x + x_centre << " , ▁ " << y + y_centre << " ) ▁ " ; if ( r > 0 ) { cout << " ( " << x + x_centre << " , ▁ " << - y + y_centre << " ) ▁ " ; cout << " ( " << y + x_centre << " , ▁ " << x + y_centre << " ) ▁ " ; cout << " ( " << - y + x_centre << " , ▁ " << x + y_centre << " ) \n " ; } int P = 1 - r ; while ( x > y ) { y ++ ; if ( P <= 0 ) P = P + 2 * y + 1 ; else { x -- ; P = P + 2 * y - 2 * x + 1 ; } if ( x < y ) break ; cout << " ( " << x + x_centre << " , ▁ " << y + y_centre << " ) ▁ " ; cout << " ( " << - x + x_centre << " , ▁ " << y + y_centre << " ) ▁ " ; cout << " ( " << x + x_centre << " , ▁ " << - y + y_centre << " ) ▁ " ; cout << " ( " << - x + x_centre << " , ▁ " << - y + y_centre << " ) \n " ; if ( x != y ) { cout << " ( " << y + x_centre << " , ▁ " << x + y_centre << " ) ▁ " ; cout << " ( " << - y + x_centre << " , ▁ " << x + y_centre << " ) ▁ " ; cout << " ( " << y + x_centre << " , ▁ " << - x + y_centre << " ) ▁ " ; cout << " ( " << - y + x_centre << " , ▁ " << - x + y_centre << " ) \n " ; } } }
Ref: 
def midPointCircleDraw ( x_centre , y_centre , r ) : NEW_LINE INDENT x = r NEW_LINE y = 0 NEW_LINE print ( " ( " , x + x_centre , " , ▁ " , y + y_centre , " ) " , sep = " " , end = " " ) NEW_LINE if ( r > 0 ) : NEW_LINE INDENT print ( " ( " , x + x_centre , " , ▁ " , - y + y_centre , " ) " , sep = " " , end = " " ) NEW_LINE print ( " ( " , y + x_centre , " , ▁ " , x + y_centre , " ) " , sep = " " , end = " " ) NEW_LINE print ( " ( " , - y + x_centre , " , ▁ " , x + y_centre , " ) " , sep = " " ) NEW_LINE DEDENT P = 1 - r NEW_LINE while ( x > y ) : NEW_LINE INDENT y += 1 NEW_LINE if ( P <= 0 ) : NEW_LINE INDENT P = P + 2 * y + 1 NEW_LINE DEDENT else : NEW_LINE INDENT x -= 1 NEW_LINE P = P + 2 * y - 2 * x + 1 NEW_LINE DEDENT if ( x < y ) : NEW_LINE INDENT break NEW_LINE DEDENT print ( " ( " , x + x_centre , " , ▁ " , y + y_centre , " ) " , sep = " " , end = " " ) NEW_LINE print ( " ( " , - x + x_centre , " , ▁ " , y + y_centre , " ) " , sep = " " , end = " " ) NEW_LINE print ( " ( " , x + x_centre , " , ▁ " , - y + y_centre , " ) " , sep = " " , end = " " ) NEW_LINE print ( " ( " , - x + x_centre , " , ▁ " , - y + y_centre , " ) " , sep = " " ) NEW_LINE if ( x != y ) : NEW_LINE INDENT print ( " ( " , y + x_centre , " , ▁ " , x + y_centre , " ) " , sep = " " , end = " " ) NEW_LINE print ( " ( " , - y + x_centre , " , ▁ " , x + y_centre , " ) " , sep = " " , end = " " ) NEW_LINE print ( " ( " , y + x_centre , " , ▁ " , - x + y_centre , " ) " , sep = " " , end = " " ) NEW_LINE print ( " ( " , - y + x_centre , " , ▁ " , - x + y_centre , " ) " , sep = " " ) NEW_LINE DEDENT DEDENT DEDENT
Hyp: 
def midPointCircleDraw ( x_centre , y_centre , r ) : NEW_LINE INDENT x = r NEW_LINE y = 0 NEW_LINE print ( " ( " , x + x_centre , " , ▁ " , y + y_centre , " ) ▁ " ) NEW_LINE if ( r > 0 ) : NEW_LINE INDENT print ( " ( " , x + x_centre , " , ▁ " , - y + y_centre , " ) ▁ " ) NEW_LINE print ( " ( " , y + x_centre , " , ▁ " , x + y_centre , " ) ▁ " ) NEW_LINE print ( " ( " , y + x_centre , " , ▁ " , y + y_centre , " ) ▁ " , x + y_centre , " ) ▁ " ) NEW_LINE DEDENT P = 1 - r NEW_LINE while ( x > y ) : NEW_LINE INDENT y += 1 NEW_LINE if ( P <= 0 ) : NEW_LINE INDENT P = P + 2 * y + 1 NEW_LINE DEDENT else : NEW_LINE INDENT x -= 1 NEW_LINE P = P + 2 * y - 2 * x + 1 NEW_LINE DEDENT if ( x < y ) : NEW_LINE INDENT break NEW_LINE DEDENT print ( " ( " , x + x_centre , " , ▁ " , y + y_centre , " ) ▁ " ) NEW_LINE print ( " ( " , - x + x_centre , " , ▁ " , - y + y_centre , " ) ▁ " ) NEW_LINE print ( " ( " , y + x_centre , " , ▁ " , x + y_centre , " , - y + y_centre , " ) ▁ " , - y + y_centre , " ) ▁ " ) NEW_LINE print ( " , - y + x_centre , " , - x + y_centre , " ) ▁ " ) NEW_LINE DEDENT if ( x != y ) : NEW_LINE INDENT print (

BLEU: 55.2
Edit Sim: 547


Src: 
void printFactorialNums ( int n ) { int fact = 1 ; int x = 2 ; while ( fact <= n ) { cout << fact << " ▁ " ; fact = fact * x ; x ++ ; } }
Ref: 
def printFactorialNums ( n ) : NEW_LINE INDENT fact = 1 NEW_LINE x = 2 NEW_LINE while fact <= n : NEW_LINE INDENT print ( fact , end = " ▁ " ) NEW_LINE fact = fact * x NEW_LINE x += 1 NEW_LINE DEDENT DEDENT
Hyp: 
def printFactorialNums ( n ) : NEW_LINE INDENT fact = 1 NEW_LINE x = 2 NEW_LINE while ( fact <= n ) : NEW_LINE INDENT print ( fact , end = " ▁ " ) NEW_LINE fact = fact * x NEW_LINE x += 1 NEW_LINE DEDENT DEDENT

BLEU: 89.22
Edit Sim: 4


Src: 
int countFriendsPairings ( int n ) { int dp [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { if ( i <= 2 ) dp [ i ] = i ; else dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; } return dp [ n ] ; }
Ref: 
def countFriendsPairings ( n ) : NEW_LINE INDENT dp = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT if ( i <= 2 ) : NEW_LINE INDENT dp [ i ] = i NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] NEW_LINE DEDENT DEDENT return dp [ n ] NEW_LINE DEDENT
Hyp: 
def countFriendsPairings ( n ) : NEW_LINE INDENT dp = [ 0 for _ in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT if i <= 2 : NEW_LINE INDENT dp [ i ] = i NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] NEW_LINE DEDENT DEDENT return dp [ n ] NEW_LINE DEDENT

BLEU: 91.48
Edit Sim: 5


Src: 
int remainder ( string str ) { int len = str . length ( ) ; int num , rem = 0 ; for ( int i = 0 ; i < len ; i ++ ) { num = rem * 10 + ( str [ i ] - '0' ) ; rem = num % 11 ; } return rem ; }
Ref: 
def remainder ( st ) : NEW_LINE INDENT ln = len ( st ) NEW_LINE rem = 0 NEW_LINE for i in range ( 0 , ln ) : NEW_LINE INDENT num = rem * 10 + ( int ) ( st [ i ] ) NEW_LINE rem = num % 11 NEW_LINE DEDENT return rem NEW_LINE DEDENT
Hyp: 
def remainder ( str ) : NEW_LINE INDENT l = len ( str ) NEW_LINE rem = 0 NEW_LINE for i in range ( l ) : NEW_LINE INDENT num = rem * 10 + int ( str [ i ] ) NEW_LINE rem = num % 11 NEW_LINE DEDENT return rem NEW_LINE DEDENT

BLEU: 67.37
Edit Sim: 13


Src: 
int findNth ( int n ) { int count = 0 ; for ( int curr = 1 ; ; curr ++ ) { int sum = 0 ; for ( int x = curr ; x > 0 ; x = x / 10 ) sum = sum + x % 10 ; if ( sum == 10 ) count ++ ; if ( count == n ) return curr ; } return - 1 ; }
Ref: 
def findNth ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for curr in itertools . count ( ) : NEW_LINE INDENT sum = 0 NEW_LINE x = curr NEW_LINE while ( x ) : NEW_LINE INDENT sum = sum + x % 10 NEW_LINE x = x // 10 NEW_LINE DEDENT if ( sum == 10 ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT if ( count == n ) : NEW_LINE INDENT return curr NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
Hyp: 
def findNth ( n ) : NEW_LINE INDENT count = 0 NEW_LINE curr = 1 NEW_LINE while ( True ) : NEW_LINE INDENT sum = 0 NEW_LINE x = curr NEW_LINE while ( x > 0 ) : NEW_LINE INDENT sum = sum + x % 10 NEW_LINE x = int ( x / 10 ) NEW_LINE DEDENT if ( sum == 10 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( count == n ) : NEW_LINE INDENT return curr NEW_LINE DEDENT curr += 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT

BLEU: 71.68
Edit Sim: 68


Src: 
bool sortedAfterSwap ( int A [ ] , bool B [ ] , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( B [ i ] ) { if ( A [ i ] != i + 1 ) swap ( A [ i ] , A [ i + 1 ] ) ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( A [ i ] != i + 1 ) return false ; } return true ; }
Ref: 
def sortedAfterSwap ( A , B , n ) : NEW_LINE INDENT for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if B [ i ] : NEW_LINE INDENT if A [ i ] != i + 1 : NEW_LINE INDENT A [ i ] , A [ i + 1 ] = A [ i + 1 ] , A [ i ] NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if A [ i ] != i + 1 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
Hyp: 
def sortedAfterSwap ( A , B , n ) : NEW_LINE INDENT for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( B [ i ] ) : NEW_LINE INDENT if ( A [ i ] != i + 1 ) : NEW_LINE INDENT t = A [ i ] NEW_LINE A [ i ] = t NEW_LINE DEDENT DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( A [ i ] != i + 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT

BLEU: 72.18
Edit Sim: 45


Src: 
int maximumSum ( int arr [ ] , int n , int k ) { for ( int i = 1 ; i <= k ; i ++ ) { int min = INT_MAX ; int index = - 1 ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] < min ) { min = arr [ j ] ; index = j ; } } if ( min == 0 ) break ; arr [ index ] = - arr [ index ] ; } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; return sum ; }
Ref: 
def maximumSum ( arr , n , k ) : NEW_LINE INDENT for i in range ( 1 , k + 1 ) : NEW_LINE INDENT min = + 2147483647 NEW_LINE index = - 1 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( arr [ j ] < min ) : NEW_LINE INDENT min = arr [ j ] NEW_LINE index = j NEW_LINE DEDENT DEDENT if ( min == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT arr [ index ] = - arr [ index ] NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT return sum NEW_LINE DEDENT
Hyp: 
def maximumSum ( arr , n , k ) : NEW_LINE INDENT for i in range ( 1 , k + 1 ) : NEW_LINE INDENT min = sys . maxsize NEW_LINE index = - 1 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( arr [ j ] < min ) : NEW_LINE INDENT min = arr [ j ] NEW_LINE index = j NEW_LINE DEDENT DEDENT if ( min == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT arr [ index ] = - arr [ index ] NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT return sum NEW_LINE DEDENT

BLEU: 96.28
Edit Sim: 13


Src: 
void printSquares ( int n ) { int square = 0 , odd = 1 ; for ( int x = 0 ; x < n ; x ++ ) { cout << square << " ▁ " ; square = square + odd ; odd = odd + 2 ; } }
Ref: 
def printSquares ( n ) : NEW_LINE INDENT square = 0 NEW_LINE odd = 1 NEW_LINE for x in range ( 0 , n ) : NEW_LINE INDENT print ( square , end = " ▁ " ) NEW_LINE square = square + odd NEW_LINE odd = odd + 2 NEW_LINE DEDENT DEDENT
Hyp: 
def printSquares ( n ) : NEW_LINE INDENT square = 0 NEW_LINE odd = 1 NEW_LINE for x in range ( 0 , n ) : NEW_LINE INDENT print ( square , end = " ▁ " ) NEW_LINE square = square + odd NEW_LINE odd = odd + 2 NEW_LINE DEDENT DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
bool checkReverse ( int arr [ ] , int n ) { if ( n == 1 ) return true ; int i ; for ( i = 1 ; i < n && arr [ i - 1 ] < arr [ i ] ; i ++ ) ; if ( i == n ) return true ; int j = i ; while ( arr [ j ] < arr [ j - 1 ] ) { if ( i > 1 && arr [ j ] < arr [ i - 2 ] ) return false ; j ++ ; } if ( j == n ) return true ; int k = j ; if ( arr [ k ] < arr [ i - 1 ] ) return false ; while ( k > 1 && k < n ) { if ( arr [ k ] < arr [ k - 1 ] ) return false ; k ++ ; } return true ; }
Ref: 
def checkReverse ( arr , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT i = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if arr [ i - 1 ] < arr [ i ] : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT j = i NEW_LINE while ( arr [ j ] < arr [ j - 1 ] ) : NEW_LINE INDENT if ( i > 1 and arr [ j ] < arr [ i - 2 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if ( j == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT k = j NEW_LINE if ( arr [ k ] < arr [ i - 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT while ( k > 1 and k < n ) : NEW_LINE INDENT if ( arr [ k ] < arr [ k - 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT k += 1 NEW_LINE DEDENT return True NEW_LINE DEDENT
Hyp: 
def checkReverse ( arr , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT i = 1 NEW_LINE while ( i < n and arr [ i - 1 ] < arr [ i ] ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT if ( i == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT j = i NEW_LINE while ( arr [ j ] < arr [ j - 1 ] ) : NEW_LINE INDENT if ( i > 1 and arr [ j ] < arr [ i - 2 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if ( j == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT k = j NEW_LINE if ( arr [ k ] < arr [ i - 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT while ( k > 1 and k < n ) : NEW_LINE INDENT if ( arr [ k ] < arr [ k - 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT k += 1 NEW_LINE DEDENT return True NEW_LINE DEDENT

BLEU: 91.07
Edit Sim: 69


Src: 
double vol_of_octahedron ( double side ) { return ( ( side * side * side ) * ( sqrt ( 2 ) / 3 ) ) ; }
Ref: 
def vol_of_octahedron ( side ) : NEW_LINE INDENT return ( ( side * side * side ) * ( math . sqrt ( 2 ) / 3 ) ) NEW_LINE DEDENT
Hyp: 
def vol_of_octahedron ( side ) : NEW_LINE INDENT return ( side * side * side ) * ( math . sqrt ( 2 ) / 3 ) ) NEW_LINE DEDENT

BLEU: 94.12
Edit Sim: 2


Src: 
int numberOfPaths ( int m , int n ) { if ( m == 1 || n == 1 ) return 1 ; return numberOfPaths ( m - 1 , n ) + numberOfPaths ( m , n - 1 ) ; }
Ref: 
def numberOfPaths ( m , n ) : NEW_LINE INDENT if ( m == 1 or n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return numberOfPaths ( m - 1 , n ) + numberOfPaths ( m , n - 1 ) NEW_LINE DEDENT
Hyp: 
def numberOfPaths ( m , n ) : NEW_LINE INDENT if ( m == 1 or n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return ( numberOfPaths ( m - 1 , n ) + numberOfPaths ( m , n - 1 ) ) NEW_LINE DEDENT

BLEU: 91.04
Edit Sim: 4


Src: 
int binarySearch ( int arr [ ] , int l , int r , int x ) { if ( r >= l ) { int mid = l + ( r - l ) / 2 ; if ( arr [ mid ] == x ) return mid ; if ( arr [ mid ] > x ) return binarySearch ( arr , l , mid - 1 , x ) ; return binarySearch ( arr , mid + 1 , r , x ) ; } return - 1 ; }
Ref: 
def binarySearch ( arr , l , r , x ) : NEW_LINE INDENT if r >= l : NEW_LINE INDENT mid = l + ( r - l ) // 2 NEW_LINE if arr [ mid ] == x : NEW_LINE INDENT return mid NEW_LINE DEDENT elif arr [ mid ] > x : NEW_LINE INDENT return binarySearch ( arr , l , mid - 1 , x ) NEW_LINE DEDENT else : NEW_LINE INDENT return binarySearch ( arr , mid + 1 , r , x ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT
Hyp: 
def binarySearch ( arr , l , r , x ) : NEW_LINE INDENT if ( r >= l ) : NEW_LINE INDENT mid = l + ( r - l ) // 2 NEW_LINE DEDENT if ( arr [ mid ] == x ) : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( arr [ mid ] > x ) : NEW_LINE INDENT return binarySearch ( arr , l , mid - 1 , x ) NEW_LINE DEDENT return binarySearch ( arr , mid + 1 , r , x ) NEW_LINE DEDENT

BLEU: 72.8
Edit Sim: 108


Src: 
int numberOfPaths ( int m , int n ) { int count [ m ] [ n ] ; for ( int i = 0 ; i < m ; i ++ ) count [ i ] [ 0 ] = 1 ; for ( int j = 0 ; j < n ; j ++ ) count [ 0 ] [ j ] = 1 ; for ( int i = 1 ; i < m ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) count [ i ] [ j ] = count [ i - 1 ] [ j ] + count [ i ] [ j - 1 ] ; } return count [ m - 1 ] [ n - 1 ] ; }
Ref: 
def numberOfPaths ( m , n ) : NEW_LINE INDENT count = [ [ 0 for x in range ( m ) ] for y in range ( n ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT count [ i ] [ 0 ] = 1 ; NEW_LINE DEDENT for j in range ( n ) : NEW_LINE INDENT count [ 0 ] [ j ] = 1 ; NEW_LINE DEDENT for i in range ( 1 , m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT count [ i ] [ j ] = count [ i - 1 ] [ j ] + count [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT return count [ m - 1 ] [ n - 1 ] NEW_LINE DEDENT
Hyp: 
def numberOfPaths ( m , n ) : NEW_LINE INDENT count = [ [ 0 for i in range ( n ) ] for j in range ( m ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT count [ i ] [ 0 ] = 1 NEW_LINE DEDENT for j in range ( n ) : NEW_LINE INDENT count [ 0 ] [ j ] = 1 NEW_LINE DEDENT for i in range ( 1 , m ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT count [ i ] [ j ] = count [ i - 1 ] [ j ] + count [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT return count [ m - 1 ] [ n - 1 ] NEW_LINE DEDENT

BLEU: 91.37
Edit Sim: 12


Src: 
long long answer ( int n ) { int dp [ n + 1 ] [ 10 ] ; if ( n == 1 ) return 10 ; for ( int j = 0 ; j <= 9 ; j ++ ) dp [ 1 ] [ j ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= 9 ; j ++ ) { if ( j == 0 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] ; else if ( j == 9 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] ; } } long long sum = 0 ; for ( int j = 1 ; j <= 9 ; j ++ ) sum += dp [ n ] [ j ] ; return sum ; }
Ref: 
def answer ( n ) : NEW_LINE INDENT dp = [ [ 0 for x in range ( 10 ) ] for y in range ( n + 1 ) ] NEW_LINE if ( n == 1 ) : NEW_LINE INDENT return 10 NEW_LINE DEDENT for j in range ( 10 ) : NEW_LINE INDENT dp [ 1 ] [ j ] = 1 NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT for j in range ( 10 ) : NEW_LINE INDENT if ( j == 0 ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] NEW_LINE DEDENT elif ( j == 9 ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] ) NEW_LINE DEDENT DEDENT DEDENT sum = 0 NEW_LINE for j in range ( 1 , 10 ) : NEW_LINE INDENT sum = sum + dp [ n ] [ j ] NEW_LINE DEDENT return sum NEW_LINE DEDENT
Hyp: 
def answer ( n ) : NEW_LINE INDENT dp = [ [ 0 for j in range ( 10 ) ] for i in range ( n + 1 ) ] NEW_LINE if n == 1 : NEW_LINE INDENT return 10 NEW_LINE DEDENT for j in range ( 9 ) : NEW_LINE INDENT dp [ 1 ] [ j ] = 1 NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT for j in range ( 0 , 9 ) : NEW_LINE INDENT if j == 0 : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] NEW_LINE DEDENT elif j == 9 : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] NEW_LINE DEDENT DEDENT DEDENT sum = 0 NEW_LINE for j in range ( 1 , 9 ) : NEW_LINE INDENT sum += dp [ n ] [ j ] NEW_LINE DEDENT return sum NEW_LINE DEDENT

BLEU: 83.41
Edit Sim: 34


Src: 
int maxDifference ( int arr [ ] , int N , int k ) { int M , S = 0 , S1 = 0 , max_difference = 0 ; for ( int i = 0 ; i < N ; i ++ ) S += arr [ i ] ; sort ( arr , arr + N , greater < int > ( ) ) ; M = max ( k , N - k ) ; for ( int i = 0 ; i < M ; i ++ ) S1 += arr [ i ] ; max_difference = S1 - ( S - S1 ) ; return max_difference ; }
Ref: 
def maxDifference ( arr , N , k ) : NEW_LINE INDENT S = 0 NEW_LINE S1 = 0 NEW_LINE max_difference = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT S += arr [ i ] NEW_LINE DEDENT arr . sort ( reverse = True ) NEW_LINE M = max ( k , N - k ) NEW_LINE for i in range ( M ) : NEW_LINE INDENT S1 += arr [ i ] NEW_LINE DEDENT max_difference = S1 - ( S - S1 ) NEW_LINE return max_difference NEW_LINE DEDENT
Hyp: 
def maxDifference ( arr , N , k ) : NEW_LINE INDENT S = 0 NEW_LINE S1 = 0 NEW_LINE max_difference = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT S += arr [ i ] NEW_LINE DEDENT arr . sort ( reverse = True ) NEW_LINE M = max ( k , N - k ) NEW_LINE for i in range ( 0 , M ) : NEW_LINE INDENT S1 += arr [ i ] NEW_LINE DEDENT max_difference = S1 - ( S - S1 ) NEW_LINE return max_difference NEW_LINE DEDENT

BLEU: 92.76
Edit Sim: 8


Src: 
int maxSumSubarrayRemovingOneEle ( int arr [ ] , int n ) { int fw [ n ] , bw [ n ] ; int cur_max = arr [ 0 ] , max_so_far = arr [ 0 ] ; fw [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { cur_max = max ( arr [ i ] , cur_max + arr [ i ] ) ; max_so_far = max ( max_so_far , cur_max ) ; fw [ i ] = cur_max ; } cur_max = max_so_far = bw [ n - 1 ] = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) { cur_max = max ( arr [ i ] , cur_max + arr [ i ] ) ; max_so_far = max ( max_so_far , cur_max ) ; bw [ i ] = cur_max ; } int fans = max_so_far ; for ( int i = 1 ; i < n - 1 ; i ++ ) fans = max ( fans , fw [ i - 1 ] + bw [ i + 1 ] ) ; return fans ; }
Ref: 
def maxSumSubarrayRemovingOneEle ( arr , n ) : NEW_LINE INDENT fw = [ 0 for k in range ( n ) ] NEW_LINE bw = [ 0 for k in range ( n ) ] NEW_LINE cur_max , max_so_far = arr [ 0 ] , arr [ 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT cur_max = max ( arr [ i ] , cur_max + arr [ i ] ) NEW_LINE max_so_far = max ( max_so_far , cur_max ) NEW_LINE fw [ i ] = cur_max NEW_LINE DEDENT cur_max = max_so_far = bw [ n - 1 ] = arr [ n - 1 ] NEW_LINE i = n - 2 NEW_LINE while i >= 0 : NEW_LINE INDENT cur_max = max ( arr [ i ] , cur_max + arr [ i ] ) NEW_LINE max_so_far = max ( max_so_far , cur_max ) NEW_LINE bw [ i ] = cur_max NEW_LINE i -= 1 NEW_LINE DEDENT fans = max_so_far NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT fans = max ( fans , fw [ i - 1 ] + bw [ i + 1 ] ) NEW_LINE DEDENT return fans NEW_LINE DEDENT
Hyp: 
def maxSumSubarrayRemovingOneEle ( arr , n ) : NEW_LINE INDENT fw = [ 0 for i in range ( n ) ] NEW_LINE bw = [ 0 for i in range ( n ) ] NEW_LINE cur_max = max_so_far = arr [ 0 ] NEW_LINE fw [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT cur_max = max ( arr [ i ] , cur_max + arr [ i ] ) NEW_LINE max_so_far = max ( max_so_far , cur_max ) NEW_LINE fw [ i ] = cur_max NEW_LINE DEDENT cur_max = max_so_far = bw [ n - 1 ] = arr [ n - 1 ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT cur_max = max ( arr [ i ] , cur_max + arr [ i ] ) NEW_LINE max_so_far = max ( max_so_far , cur_max ) NEW_LINE bw [ i ] = cur_max NEW_LINE DEDENT fans = max_so_far NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT fans = max ( fans , fw [ i - 1 ] + bw [ i + 1 ] ) NEW_LINE DEDENT return fans NEW_LINE DEDENT

BLEU: 85.23
Edit Sim: 70


Src: 
void moveSpaceInFront ( char str [ ] ) { int i = strlen ( str ) ; for ( int j = i ; j >= 0 ; j -- ) if ( str [ j ] != ' ▁ ' ) str [ i -- ] = str [ j ] ; while ( i >= 0 ) str [ i -- ] = ' ▁ ' ; }
Ref: 
def moveSpaceInFront ( s ) : NEW_LINE INDENT i = len ( s ) - 1 NEW_LINE for j in range ( i , - 1 , - 1 ) : NEW_LINE INDENT if ( s [ j ] != ' ▁ ' ) : NEW_LINE INDENT s = s [ : i ] + s [ j ] + s [ i + 1 : ] NEW_LINE i -= 1 NEW_LINE DEDENT DEDENT while ( i >= 0 ) : NEW_LINE INDENT s = s [ : i ] + ' ▁ ' + s [ i + 1 : ] NEW_LINE i -= 1 NEW_LINE DEDENT return s NEW_LINE DEDENT
Hyp: 
def moveSpaceInFront ( str ) : NEW_LINE INDENT i = len ( str ) NEW_LINE for j in range ( i , len ( str ) - 1 ) : NEW_LINE INDENT if ( str [ j ] != ' ▁ ' ) : NEW_LINE INDENT str [ i ] = str [ j ] NEW_LINE i -= 1 NEW_LINE DEDENT DEDENT while ( i >= 0 ) : NEW_LINE INDENT str [ i ] = ' ▁ ' NEW_LINE DEDENT DEDENT

BLEU: 45.01
Edit Sim: 99


Src: 
int recaman ( int n ) { int arr [ n ] ; arr [ 0 ] = 0 ; printf ( " % d , ▁ " , arr [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { int curr = arr [ i - 1 ] - i ; int j ; for ( j = 0 ; j < i ; j ++ ) { if ( ( arr [ j ] == curr ) || curr < 0 ) { curr = arr [ i - 1 ] + i ; break ; } } arr [ i ] = curr ; printf ( " % d , ▁ " , arr [ i ] ) ; } }
Ref: 
def recaman ( n ) : NEW_LINE INDENT arr = [ 0 ] * n NEW_LINE arr [ 0 ] = 0 NEW_LINE print ( arr [ 0 ] , end = " , ▁ " ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT curr = arr [ i - 1 ] - i NEW_LINE for j in range ( 0 , i ) : NEW_LINE INDENT if ( ( arr [ j ] == curr ) or curr < 0 ) : NEW_LINE INDENT curr = arr [ i - 1 ] + i NEW_LINE break NEW_LINE DEDENT DEDENT arr [ i ] = curr NEW_LINE print ( arr [ i ] , end = " , ▁ " ) NEW_LINE DEDENT DEDENT
Hyp: 
def recaman ( n ) : NEW_LINE INDENT arr = [ 0 for i in range ( n ) ] NEW_LINE arr [ 0 ] = 0 NEW_LINE print ( arr [ 0 ] , end = " " ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT curr = arr [ i - 1 ] - i NEW_LINE for j in range ( i ) : NEW_LINE INDENT if ( ( arr [ j ] == curr ) or curr < 0 ) : NEW_LINE INDENT curr = arr [ i - 1 ] + i NEW_LINE break NEW_LINE DEDENT DEDENT arr [ i ] = curr NEW_LINE print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT

BLEU: 88.67
Edit Sim: 31


Src: 
int findMaxPoints ( int A [ ] [ M ] ) { int P1S [ M + 1 ] [ N + 1 ] , P1E [ M + 1 ] [ N + 1 ] ; memset ( P1S , 0 , sizeof ( P1S ) ) ; memset ( P1E , 0 , sizeof ( P1E ) ) ; int P2S [ M + 1 ] [ N + 1 ] , P2E [ M + 1 ] [ N + 1 ] ; memset ( P2S , 0 , sizeof ( P2S ) ) ; memset ( P2E , 0 , sizeof ( P2E ) ) ; for ( int i = 1 ; i <= N ; i ++ ) for ( int j = 1 ; j <= M ; j ++ ) P1S [ i ] [ j ] = max ( P1S [ i - 1 ] [ j ] , P1S [ i ] [ j - 1 ] ) + A [ i - 1 ] [ j - 1 ] ; for ( int i = N ; i >= 1 ; i -- ) for ( int j = M ; j >= 1 ; j -- ) P1E [ i ] [ j ] = max ( P1E [ i + 1 ] [ j ] , P1E [ i ] [ j + 1 ] ) + A [ i - 1 ] [ j - 1 ] ; for ( int i = N ; i >= 1 ; i -- ) for ( int j = 1 ; j <= M ; j ++ ) P2S [ i ] [ j ] = max ( P2S [ i + 1 ] [ j ] , P2S [ i ] [ j - 1 ] ) + A [ i - 1 ] [ j - 1 ] ; for ( int i = 1 ; i <= N ; i ++ ) for ( int j = M ; j >= 1 ; j -- ) P2E [ i ] [ j ] = max ( P2E [ i - 1 ] [ j ] , P2E [ i ] [ j + 1 ] ) + A [ i - 1 ] [ j - 1 ] ; int ans = 0 ; for ( int i = 2 ; i < N ; i ++ ) { for ( int j = 2 ; j < M ; j ++ ) { int op1 = P1S [ i ] [ j - 1 ] + P1E [ i ] [ j + 1 ] + P2S [ i + 1 ] [ j ] + P2E [ i - 1 ] [ j ] ; int op2 = P1S [ i - 1 ] [ j ] + P1E [ i + 1 ] [ j ] + P2S [ i ] [ j - 1 ] + P2E [ i ] [ j + 1 ] ; ans = max ( ans , max ( op1 , op2 ) ) ; } } return ans ; }
Ref: 
def findMaxPoints ( A ) : NEW_LINE INDENT P1S = [ [ 0 for i in range ( N + 2 ) ] for j in range ( M + 2 ) ] NEW_LINE P1E = [ [ 0 for i in range ( N + 2 ) ] for j in range ( M + 2 ) ] NEW_LINE P2S = [ [ 0 for i in range ( N + 2 ) ] for j in range ( M + 2 ) ] NEW_LINE P2E = [ [ 0 for i in range ( N + 2 ) ] for j in range ( M + 2 ) ] NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( 1 , M + 1 ) : NEW_LINE INDENT P1S [ i ] [ j ] = max ( P1S [ i - 1 ] [ j ] , P1S [ i ] [ j - 1 ] ) + A [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT DEDENT for i in range ( N , 0 , - 1 ) : NEW_LINE INDENT for j in range ( M , 0 , - 1 ) : NEW_LINE INDENT P1E [ i ] [ j ] = max ( P1E [ i + 1 ] [ j ] , P1E [ i ] [ j + 1 ] ) + A [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT DEDENT for i in range ( N , 0 , - 1 ) : NEW_LINE INDENT for j in range ( 1 , M + 1 ) : NEW_LINE INDENT P2S [ i ] [ j ] = max ( P2S [ i + 1 ] [ j ] , P2S [ i ] [ j - 1 ] ) + A [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT DEDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( M , 0 , - 1 ) : NEW_LINE INDENT P2E [ i ] [ j ] = max ( P2E [ i - 1 ] [ j ] , P2E [ i ] [ j + 1 ] ) + A [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 2 , N ) : NEW_LINE INDENT for j in range ( 2 , M ) : NEW_LINE INDENT op1 = P1S [ i ] [ j - 1 ] + P1E [ i ] [ j + 1 ] + \ NEW_LINE INDENT P2S [ i + 1 ] [ j ] + P2E [ i - 1 ] [ j ] NEW_LINE DEDENT op2 = P1S [ i - 1 ] [ j ] + P1E [ i + 1 ] [ j ] + \ NEW_LINE INDENT P2S [ i ] [ j - 1 ] + P2E [ i ] [ j + 1 ] NEW_LINE DEDENT ans = max ( ans , max ( op1 , op2 ) ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
Hyp: 
def findMaxPoints ( A ) : NEW_LINE INDENT P1S = [ [ 0 for i in range ( N + 1 ) ] for j in range ( M + 1 ) ] NEW_LINE P1E = [ [ 0 for i in range ( N + 1 ) ] for j in range ( M + 1 ) ] NEW_LINE DEDENT P2S = [ [ 0 for i in range ( M + 1 ) ] for j in range ( N + 1 ) ] NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( 1 , M + 1 ) : NEW_LINE INDENT P1S [ i ] [ j ] = max ( P1S [ i - 1 ] [ j ] , P1S [ i ] [ j - 1 ] ) + A [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT DEDENT for i in range ( N , 1 , - 1 ) : NEW_LINE INDENT for j in range ( 1 , M + 1 ) : NEW_LINE INDENT P2S [ i ] [ j ] = max ( P2S [ i + 1 ] [ j ] , P2S [ i ] [ j + 1 ] ) + A [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT DEDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( M + 1 ) : NEW_LINE INDENT P2E [ i ] [ j ] = max ( P2E [ i - 1 ] [ j ] , P2E [ i ] [ j + 1 ] ) + A [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT for j in range ( 2 , M + 1 ) : NEW_LINE INDENT op1 = P1S [ i ] [ j - 1 ] + P1E [ i ] [ j + 1 ] NEW_LINE DEDENT DEDENT

BLEU: 55.82
Edit Sim: 575


Src: 
int KnapSack ( int val [ ] , int wt [ ] , int n , int W ) { int mat [ 2 ] [ W + 1 ] ; memset ( mat , 0 , sizeof ( mat ) ) ; int i = 0 ; while ( i < n ) { int j = 0 ; if ( i % 2 != 0 ) { while ( ++ j <= W ) { if ( wt [ i ] <= j ) mat [ 1 ] [ j ] = max ( val [ i ] + mat [ 0 ] [ j - wt [ i ] ] , mat [ 0 ] [ j ] ) ; else mat [ 1 ] [ j ] = mat [ 0 ] [ j ] ; } } else { while ( ++ j <= W ) { if ( wt [ i ] <= j ) mat [ 0 ] [ j ] = max ( val [ i ] + mat [ 1 ] [ j - wt [ i ] ] , mat [ 1 ] [ j ] ) ; else mat [ 0 ] [ j ] = mat [ 1 ] [ j ] ; } } i ++ ; } return ( n % 2 != 0 ) ? mat [ 0 ] [ W ] : mat [ 1 ] [ W ] ; }
Ref: 
def KnapSack ( val , wt , n , W ) : NEW_LINE INDENT mat = [ [ 0 for i in range ( W + 1 ) ] for i in range ( 2 ) ] NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT j = 0 NEW_LINE if i % 2 == 0 : NEW_LINE INDENT while j < W : NEW_LINE INDENT j += 1 NEW_LINE if wt [ i ] <= j : NEW_LINE INDENT mat [ 1 ] [ j ] = max ( val [ i ] + mat [ 0 ] [ j - wt [ i ] ] , mat [ 0 ] [ j ] ) NEW_LINE DEDENT else : NEW_LINE INDENT mat [ 1 ] [ j ] = mat [ 0 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT while j < W : NEW_LINE INDENT j += 1 NEW_LINE if wt [ i ] <= j : NEW_LINE INDENT mat [ 0 ] [ j ] = max ( val [ i ] + mat [ 1 ] [ j - wt [ i ] ] , mat [ 1 ] [ j ] ) NEW_LINE DEDENT else : NEW_LINE INDENT mat [ 0 ] [ j ] = mat [ 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT i += 1 NEW_LINE DEDENT if n % 2 == 0 : NEW_LINE INDENT return mat [ 0 ] [ W ] NEW_LINE DEDENT else : NEW_LINE INDENT return mat [ 1 ] [ W ] NEW_LINE DEDENT DEDENT
Hyp: 
def KnapSack ( val , wt , n , W ) : NEW_LINE INDENT mat = [ [ 0 for i in range ( W + 1 ) ] for j in range ( 2 ) ] NEW_LINE i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT j = 0 NEW_LINE if ( i % 2 != 0 ) : NEW_LINE INDENT while ( j <= W ) : NEW_LINE INDENT if ( wt [ i ] <= j ) : NEW_LINE INDENT mat [ 1 ] [ j ] = max ( val [ i ] + mat [ 0 ] [ j - wt [ i ] ] , mat [ 0 ] [ j ] ) NEW_LINE DEDENT else : NEW_LINE INDENT mat [ 1 ] [ j ] = mat [ 0 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT while ( j <= W ) : NEW_LINE INDENT if ( wt [ i ] <= j ) : NEW_LINE INDENT mat [ 0 ] [ j ] = max ( val [ i ] + mat [ 1 ] [ j - wt [ i ] ] , mat [ 1 ] [ j ] ) NEW_LINE DEDENT else : NEW_LINE INDENT mat [ 0 ] [ j ] = mat [ 1 ] [ j ] NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT return mat [ 0 ] [ W ] NEW_LINE DEDENT

BLEU: 77.04
Edit Sim: 166


Src: 
int modInverse ( int a , int m ) { a = a % m ; for ( int x = 1 ; x < m ; x ++ ) if ( ( a * x ) % m == 1 ) return x ; }
Ref: 
def modInverse ( a , m ) : NEW_LINE INDENT a = a % m NEW_LINE for x in range ( 1 , m ) : NEW_LINE INDENT if ( ( a * x ) % m == 1 ) : NEW_LINE INDENT return x NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT
Hyp: 
def modInverse ( a , m ) : NEW_LINE INDENT a = a % m NEW_LINE for x in range ( 1 , m ) : NEW_LINE INDENT if ( ( a * x ) % m == 1 ) : NEW_LINE INDENT return x NEW_LINE DEDENT DEDENT DEDENT

BLEU: 92.59
Edit Sim: 18


Src: 
int lenghtOfLongestAP ( int set [ ] , int n ) { if ( n <= 2 ) return n ; int L [ n ] [ n ] ; int llap = 2 ; for ( int i = 0 ; i < n ; i ++ ) L [ i ] [ n - 1 ] = 2 ; for ( int j = n - 2 ; j >= 1 ; j -- ) { int i = j - 1 , k = j + 1 ; while ( i >= 0 && k <= n - 1 ) { if ( set [ i ] + set [ k ] < 2 * set [ j ] ) k ++ ; else if ( set [ i ] + set [ k ] > 2 * set [ j ] ) { L [ i ] [ j ] = 2 , i -- ; } else { L [ i ] [ j ] = L [ j ] [ k ] + 1 ; llap = max ( llap , L [ i ] [ j ] ) ; i -- ; k ++ ; } } while ( i >= 0 ) { L [ i ] [ j ] = 2 ; i -- ; } } return llap ; }
Ref: 
def lenghtOfLongestAP ( set , n ) : NEW_LINE INDENT if ( n <= 2 ) : NEW_LINE INDENT return n NEW_LINE DEDENT L = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] NEW_LINE llap = 2 NEW_LINE for i in range ( n ) : NEW_LINE INDENT L [ i ] [ n - 1 ] = 2 NEW_LINE DEDENT for j in range ( n - 2 , 0 , - 1 ) : NEW_LINE INDENT i = j - 1 NEW_LINE k = j + 1 NEW_LINE while ( i >= 0 and k <= n - 1 ) : NEW_LINE INDENT if ( set [ i ] + set [ k ] < 2 * set [ j ] ) : NEW_LINE INDENT k += 1 NEW_LINE DEDENT elif ( set [ i ] + set [ k ] > 2 * set [ j ] ) : NEW_LINE INDENT L [ i ] [ j ] = 2 NEW_LINE i -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] = L [ j ] [ k ] + 1 NEW_LINE llap = max ( llap , L [ i ] [ j ] ) NEW_LINE i -= 1 NEW_LINE k += 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT L [ i ] [ j ] = 2 NEW_LINE i -= 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return llap NEW_LINE DEDENT
Hyp: 
def lenghtOfLongestAP ( set , n ) : NEW_LINE INDENT if ( n <= 2 ) : NEW_LINE INDENT return n NEW_LINE DEDENT L = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] NEW_LINE llap = 2 NEW_LINE for i in range ( n ) : NEW_LINE INDENT L [ i ] [ n - 1 ] = 2 NEW_LINE DEDENT for j in range ( n - 2 , 0 , - 1 ) : NEW_LINE INDENT i = j - 1 NEW_LINE k = j + 1 NEW_LINE while ( i >= 0 and k <= n - 1 ) : NEW_LINE INDENT if ( set [ i ] + set [ k ] < 2 * set [ j ] ) : NEW_LINE INDENT k += 1 NEW_LINE DEDENT elif ( set [ i ] + set [ k ] > 2 * set [ j ] ) : NEW_LINE INDENT L [ i ] [ j ] = 2 , i -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] = L [ j ] [ k ] + 1 NEW_LINE llap = max ( llap , L [ i ] [ j ] ) NEW_LINE i -= 1 NEW_LINE k += 1 NEW_LINE DEDENT DEDENT while ( i >= 0 ) : NEW_LINE INDENT L [ i ] [ j ] = 2 NEW_LINE i -= 1 NEW_LINE DEDENT DEDENT return llap NEW_LINE DEDENT

BLEU: 95.86
Edit Sim: 38


Src: 
int countOfBinaryNumberLessThanN ( int N ) { queue < int > q ; q . push ( 1 ) ; int cnt = 0 ; int t ; while ( ! q . empty ( ) ) { t = q . front ( ) ; q . pop ( ) ; if ( t <= N ) { cnt ++ ; q . push ( t * 10 ) ; q . push ( t * 10 + 1 ) ; } } return cnt ; }
Ref: 
def countOfBinaryNumberLessThanN ( N ) : NEW_LINE INDENT q = deque ( ) NEW_LINE q . append ( 1 ) NEW_LINE cnt = 0 NEW_LINE while ( q ) : NEW_LINE INDENT t = q . popleft ( ) NEW_LINE if ( t <= N ) : NEW_LINE INDENT cnt = cnt + 1 NEW_LINE q . append ( t * 10 ) NEW_LINE q . append ( t * 10 + 1 ) NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT
Hyp: 
def countOfBinaryNumberLessThanN ( N ) : NEW_LINE INDENT q = queue . Queue ( ) NEW_LINE q . put ( 1 ) NEW_LINE cnt = 0 NEW_LINE t = 0 NEW_LINE while ( not q . empty ( ) ) : NEW_LINE INDENT t = q . get ( ) NEW_LINE if ( t <= N ) : NEW_LINE INDENT cnt += 1 NEW_LINE q . put ( t * 10 ) NEW_LINE q . put ( t * 10 + 1 ) NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT

BLEU: 67.88
Edit Sim: 68


Src: 
int findIndex ( int n ) { if ( n <= 1 ) return n ; int a = 0 , b = 1 , c = 1 ; int res = 1 ; while ( c < n ) { c = a + b ; res ++ ; a = b ; b = c ; } return res ; }
Ref: 
def findIndex ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT a = 0 NEW_LINE b = 1 NEW_LINE c = 1 NEW_LINE res = 1 NEW_LINE while ( c < n ) : NEW_LINE INDENT c = a + b NEW_LINE res = res + 1 NEW_LINE a = b NEW_LINE b = c NEW_LINE DEDENT return res NEW_LINE DEDENT
Hyp: 
def findIndex ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT a = 0 b = 1 NEW_LINE c = 1 NEW_LINE res = 1 NEW_LINE while ( c < n ) : NEW_LINE INDENT c = a + b NEW_LINE res += 1 NEW_LINE a = b NEW_LINE b = c NEW_LINE DEDENT return res NEW_LINE DEDENT

BLEU: 89.9
Edit Sim: 16


Src: 
int substringConversions ( string str , int k , int b ) { int i = 0 , sum = 0 , counter = k - 1 ; for ( i ; i < k ; i ++ ) { sum = sum + ( ( str . at ( i ) - '0' ) * pow ( b , counter ) ) ; counter -- ; } cout << sum << " ▁ " ; int prev = sum ; sum = 0 , counter = 0 ; for ( i ; i < str . size ( ) ; i ++ ) { sum = prev - ( ( str . at ( i - k ) - '0' ) * pow ( b , k - 1 ) ) ; sum = sum * b ; sum = sum + ( str . at ( i ) - '0' ) ; cout << sum << " ▁ " ; prev = sum ; counter ++ ; } }
Ref: 
def substringConversions ( str1 , k , b ) : NEW_LINE INDENT for i in range ( 0 , len ( str1 ) - k + 1 ) : NEW_LINE INDENT sub = str1 [ i : k + i ] NEW_LINE Sum = 0 NEW_LINE counter = 0 NEW_LINE for i in range ( len ( sub ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT Sum = ( Sum + ( ( ord ( sub [ i ] ) - ord ( '0' ) ) * pow ( b , counter ) ) ) NEW_LINE counter += 1 NEW_LINE DEDENT print ( Sum , end = " ▁ " ) NEW_LINE DEDENT DEDENT
Hyp: 
def substringConversions ( str , k , b ) : NEW_LINE INDENT i = 0 NEW_LINE sum = 0 NEW_LINE counter = k - 1 NEW_LINE for i in range ( k ) : NEW_LINE INDENT sum = sum + ( ( ord ( str [ i ] ) - ord ( '0' ) ) * pow ( b , counter ) ) NEW_LINE counter -= 1 NEW_LINE DEDENT print ( sum , end = " ▁ " ) NEW_LINE prev = sum NEW_LINE sum = 0 NEW_LINE counter = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT sum = prev - ( ( ord ( str [ i - k ] ) - ord ( '0' ) ) * pow ( b , k - 1 ) ) NEW_LINE sum = sum * b NEW_LINE sum = sum + ( ord ( str [ i ] ) - ord ( '0' ) ) NEW_LINE print ( sum , end = " ▁ " ) NEW_LINE prev = sum NEW_LINE counter += 1 NEW_LINE DEDENT DEDENT

BLEU: 38.95
Edit Sim: 342


Src: 
int maxSumPairWithDifferenceLessThanK ( int arr [ ] , int N , int k ) { int maxSum = 0 ; sort ( arr , arr + N ) ; for ( int i = N - 1 ; i > 0 ; -- i ) { if ( arr [ i ] - arr [ i - 1 ] < k ) { maxSum += arr [ i ] ; maxSum += arr [ i - 1 ] ; -- i ; } } return maxSum ; }
Ref: 
def maxSumPairWithDifferenceLessThanK ( arr , N , k ) : NEW_LINE INDENT maxSum = 0 NEW_LINE arr . sort ( ) NEW_LINE i = N - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT if ( arr [ i ] - arr [ i - 1 ] < k ) : NEW_LINE INDENT maxSum += arr [ i ] NEW_LINE maxSum += arr [ i - 1 ] NEW_LINE i -= 1 NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT return maxSum NEW_LINE DEDENT
Hyp: 
def maxSumPairWithDifferenceLessThanK ( arr , N , k ) : NEW_LINE INDENT maxSum = 0 NEW_LINE arr . sort ( ) NEW_LINE i = N - 1 NEW_LINE while ( i > 0 ) : NEW_LINE INDENT if ( arr [ i ] - arr [ i - 1 ] < k ) : NEW_LINE INDENT maxSum += arr [ i ] NEW_LINE maxSum += arr [ i - 1 ] NEW_LINE i -= 1 NEW_LINE DEDENT DEDENT return maxSum NEW_LINE DEDENT

BLEU: 90.49
Edit Sim: 17


Src: 
string longestRepeatedSubSeq ( string str ) { int n = str . length ( ) ; int dp [ n + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= n ; j ++ ) dp [ i ] [ j ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= n ; j ++ ) if ( str [ i - 1 ] == str [ j - 1 ] && i != j ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ; string res = " " ; int i = n , j = n ; while ( i > 0 && j > 0 ) { if ( dp [ i ] [ j ] == dp [ i - 1 ] [ j - 1 ] + 1 ) { res = res + str [ i - 1 ] ; i -- ; j -- ; } else if ( dp [ i ] [ j ] == dp [ i - 1 ] [ j ] ) i -- ; else j -- ; } reverse ( res . begin ( ) , res . end ( ) ) ; return res ; }
Ref: 
def longestRepeatedSubSeq ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( str [ i - 1 ] == str [ j - 1 ] and i != j ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT res = ' ' NEW_LINE i = n NEW_LINE j = n NEW_LINE while ( i > 0 and j > 0 ) : NEW_LINE INDENT if ( dp [ i ] [ j ] == dp [ i - 1 ] [ j - 1 ] + 1 ) : NEW_LINE INDENT res += str [ i - 1 ] NEW_LINE i -= 1 NEW_LINE j -= 1 NEW_LINE DEDENT elif ( dp [ i ] [ j ] == dp [ i - 1 ] [ j ] ) : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT DEDENT res = ' ' . join ( reversed ( res ) ) NEW_LINE return res NEW_LINE DEDENT
Hyp: 
def longestRepeatedSubSeq ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE dp = [ [ 0 for x in range ( n + 1 ) ] for y in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( str [ i - 1 ] == str [ j - 1 ] and i != j ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT res = " " NEW_LINE i = n NEW_LINE j = n NEW_LINE while ( i > 0 and j > 0 ) : NEW_LINE INDENT if ( dp [ i ] [ j ] == dp [ i - 1 ] [ j - 1 ] + 1 ) : NEW_LINE INDENT res = res + str [ i - 1 ] NEW_LINE i -= 1 NEW_LINE j -= 1 NEW_LINE DEDENT elif ( dp [ i ] [ j ] == dp [ i - 1 ] [ j ] ) : NEW_LINE INDENT i -= 1 NEW_LINE j -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT

BLEU: 84.13
Edit Sim: 207


Src: 
bool isHeap ( int arr [ ] , int n ) { for ( int i = 0 ; i <= ( n - 2 ) / 2 ; i ++ ) { if ( arr [ 2 * i + 1 ] > arr [ i ] ) return false ; if ( 2 * i + 2 < n && arr [ 2 * i + 2 ] > arr [ i ] ) return false ; } return true ; }
Ref: 
def isHeap ( arr , n ) : NEW_LINE INDENT for i in range ( int ( ( n - 2 ) / 2 ) + 1 ) : NEW_LINE INDENT if arr [ 2 * i + 1 ] > arr [ i ] : NEW_LINE INDENT return False NEW_LINE DEDENT if ( 2 * i + 2 < n and arr [ 2 * i + 2 ] > arr [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
Hyp: 
def isHeap ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , int ( ( n - 2 ) / 2 ) ) : NEW_LINE INDENT if ( arr [ 2 * i + 1 ] > arr [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( 2 * i + 2 < n and arr [ 2 * i + 2 ] > arr [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT

BLEU: 88.61
Edit Sim: 12


Src: 
int calculateEnergy ( int mat [ SIZE ] [ SIZE ] , int n ) { int i_des , j_des , q ; int tot_energy = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { q = mat [ i ] [ j ] / n ; i_des = q ; j_des = mat [ i ] [ j ] - ( n * q ) ; tot_energy += abs ( i_des - i ) + abs ( j_des - j ) ; } } return tot_energy ; }
Ref: 
def calculateEnergy ( mat , n ) : NEW_LINE INDENT tot_energy = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT q = mat [ i ] [ j ] // n NEW_LINE i_des = q NEW_LINE j_des = mat [ i ] [ j ] - ( n * q ) NEW_LINE tot_energy += ( abs ( i_des - i ) + abs ( j_des - j ) ) NEW_LINE DEDENT DEDENT return tot_energy NEW_LINE DEDENT
Hyp: 
def calculateEnergy ( mat , n ) : NEW_LINE INDENT tot_energy = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT q = mat [ i ] [ j ] / n NEW_LINE i_des = q NEW_LINE j_des = mat [ i ] [ j ] - ( n * q ) NEW_LINE tot_energy += abs ( i_des - i ) + abs ( j_des - j ) NEW_LINE DEDENT DEDENT return tot_energy NEW_LINE DEDENT

BLEU: 86.88
Edit Sim: 13


Src: 
void rearrange ( int a [ ] , int size ) { int positive = 0 , negative = 1 ; while ( true ) { while ( positive < size && a [ positive ] >= 0 ) positive += 2 ; while ( negative < size && a [ negative ] <= 0 ) negative += 2 ; if ( positive < size && negative < size ) swap ( a [ positive ] , a [ negative ] ) ; else break ; } }
Ref: 
def rearrange ( a , size ) : NEW_LINE INDENT positive = 0 NEW_LINE negative = 1 NEW_LINE while ( True ) : NEW_LINE INDENT while ( positive < size and a [ positive ] >= 0 ) : NEW_LINE INDENT positive = positive + 2 NEW_LINE DEDENT while ( negative < size and a [ negative ] <= 0 ) : NEW_LINE INDENT negative = negative + 2 NEW_LINE DEDENT if ( positive < size and negative < size ) : NEW_LINE INDENT temp = a [ positive ] NEW_LINE a [ positive ] = a [ negative ] NEW_LINE a [ negative ] = temp NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT
Hyp: 
def rearrange ( a , size ) : NEW_LINE INDENT positive = 0 NEW_LINE negative = 1 NEW_LINE while ( positive < size and a [ positive ] >= 0 ) : NEW_LINE INDENT positive += 2 NEW_LINE DEDENT while ( negative < size and a [ negative ] <= 0 ) : NEW_LINE INDENT negative += 2 NEW_LINE DEDENT if ( positive < size and negative < size ) : NEW_LINE INDENT a [ positive ] , a [ negative ] = a [ negative ] , a [ positive ] NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT

BLEU: 75.38
Edit Sim: 95


Src: 
void antiSpiralTraversal ( int m , int n , int a [ R ] [ C ] ) { int i , k = 0 , l = 0 ; stack < int > stk ; while ( k <= m && l <= n ) { for ( i = l ; i <= n ; ++ i ) stk . push ( a [ k ] [ i ] ) ; k ++ ; for ( i = k ; i <= m ; ++ i ) stk . push ( a [ i ] [ n ] ) ; n -- ; if ( k <= m ) { for ( i = n ; i >= l ; -- i ) stk . push ( a [ m ] [ i ] ) ; m -- ; } if ( l <= n ) { for ( i = m ; i >= k ; -- i ) stk . push ( a [ i ] [ l ] ) ; l ++ ; } } while ( ! stk . empty ( ) ) { cout << stk . top ( ) << " ▁ " ; stk . pop ( ) ; } }
Ref: 
def antiSpiralTraversal ( m , n , a ) : NEW_LINE INDENT k = 0 NEW_LINE l = 0 NEW_LINE stk = [ ] NEW_LINE while ( k <= m and l <= n ) : NEW_LINE INDENT for i in range ( l , n + 1 ) : NEW_LINE INDENT stk . append ( a [ k ] [ i ] ) NEW_LINE DEDENT k += 1 NEW_LINE for i in range ( k , m + 1 ) : NEW_LINE INDENT stk . append ( a [ i ] [ n ] ) NEW_LINE DEDENT n -= 1 NEW_LINE if ( k <= m ) : NEW_LINE INDENT for i in range ( n , l - 1 , - 1 ) : NEW_LINE INDENT stk . append ( a [ m ] [ i ] ) NEW_LINE DEDENT m -= 1 NEW_LINE DEDENT if ( l <= n ) : NEW_LINE INDENT for i in range ( m , k - 1 , - 1 ) : NEW_LINE INDENT stk . append ( a [ i ] [ l ] ) NEW_LINE DEDENT l += 1 NEW_LINE DEDENT DEDENT while len ( stk ) != 0 : NEW_LINE INDENT print ( str ( stk [ - 1 ] ) , end = " ▁ " ) NEW_LINE stk . pop ( ) NEW_LINE DEDENT DEDENT
Hyp: 
def antiSpiralTraversal ( m , n , a ) : NEW_LINE INDENT k = 0 l = 0 NEW_LINE stk = [ ] NEW_LINE while ( k <= m and l <= n ) : NEW_LINE INDENT for i in range ( l , n + 1 ) : NEW_LINE INDENT stk . append ( a [ k ] [ i ] ) NEW_LINE DEDENT k += 1 NEW_LINE for i in range ( k , m + 1 ) : NEW_LINE INDENT stk . append ( a [ i ] [ n ] ) NEW_LINE DEDENT n -= 1 NEW_LINE if ( k <= m ) : NEW_LINE INDENT for i in range ( n , l - 1 , - 1 ) : NEW_LINE INDENT stk . append ( a [ m ] [ i ] ) NEW_LINE DEDENT m -= 1 NEW_LINE DEDENT if ( l <= n ) : NEW_LINE INDENT for i in range ( m , k - 1 , - 1 ) : NEW_LINE INDENT stk . append ( a [ i ] [ l ] ) NEW_LINE l += 1 NEW_LINE DEDENT DEDENT DEDENT while ( len ( stk ) != 0 ) : NEW_LINE INDENT print ( * stk ) NEW_LINE DEDENT DEDENT

BLEU: 87.2
Edit Sim: 79


Src: 
void maxProduct ( int arr [ ] , int n ) { if ( n < 2 ) { cout << " No ▁ pairs ▁ exists \n " ; return ; } if ( n == 2 ) { cout << arr [ 0 ] << " ▁ " << arr [ 1 ] << endl ; return ; } int posa = INT_MIN , posb = INT_MIN ; int nega = INT_MIN , negb = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > posa ) { posb = posa ; posa = arr [ i ] ; } else if ( arr [ i ] > posb ) posb = arr [ i ] ; if ( arr [ i ] < 0 && abs ( arr [ i ] ) > abs ( nega ) ) { negb = nega ; nega = arr [ i ] ; } else if ( arr [ i ] < 0 && abs ( arr [ i ] ) > abs ( negb ) ) negb = arr [ i ] ; } if ( nega * negb > posa * posb ) cout << " Max ▁ product ▁ pair ▁ is ▁ { " << nega << " , ▁ " << negb << " } " ; else cout << " Max ▁ product ▁ pair ▁ is ▁ { " << posa << " , ▁ " << posb << " } " ; }
Ref: 
def maxProduct ( arr , n ) : NEW_LINE INDENT if ( n < 2 ) : NEW_LINE INDENT print ( " No ▁ pairs ▁ exists " ) NEW_LINE return NEW_LINE DEDENT if ( n == 2 ) : NEW_LINE INDENT print ( arr [ 0 ] , " ▁ " , arr [ 1 ] ) NEW_LINE return NEW_LINE DEDENT posa = 0 NEW_LINE posb = 0 NEW_LINE nega = 0 NEW_LINE negb = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] > posa ) : NEW_LINE INDENT posb = posa NEW_LINE posa = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > posb ) : NEW_LINE INDENT posb = arr [ i ] NEW_LINE DEDENT if ( arr [ i ] < 0 and abs ( arr [ i ] ) > abs ( nega ) ) : NEW_LINE INDENT negb = nega NEW_LINE nega = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] < 0 and abs ( arr [ i ] ) > abs ( negb ) ) : NEW_LINE INDENT negb = arr [ i ] NEW_LINE DEDENT DEDENT if ( nega * negb > posa * posb ) : NEW_LINE INDENT print ( " Max ▁ product ▁ pair ▁ is ▁ { " , nega , " , ▁ " , negb , " } " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Max ▁ product ▁ pair ▁ is ▁ { " , posa , " , ▁ " , posb , " } " ) NEW_LINE DEDENT DEDENT
Hyp: 
def maxProduct ( arr , n ) : NEW_LINE INDENT if ( n < 2 ) : NEW_LINE INDENT print ( " No ▁ pairs ▁ exists " ) NEW_LINE return NEW_LINE DEDENT if ( n == 2 ) : NEW_LINE INDENT print ( arr [ 0 ] , end = " ▁ " ) NEW_LINE return NEW_LINE DEDENT posa = - 100000000 NEW_LINE posb = - 100000000 NEW_LINE nega = - 100000000 NEW_LINE negb = - 100000000 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] > posa ) : NEW_LINE INDENT posb = posa NEW_LINE posa = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > posb ) : NEW_LINE INDENT posb = arr [ i ] NEW_LINE DEDENT if ( arr [ i ] < 0 and abs ( arr [ i ] ) > abs ( nega ) ) : NEW_LINE INDENT negb = nega NEW_LINE nega = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] < 0 and abs ( arr [ i ] ) > abs ( negb ) ) : NEW_LINE INDENT negb = arr [ i ] NEW_LINE DEDENT DEDENT if ( nega * negb > posa * posb ) : NEW_LINE INDENT print ( " Max ▁ product ▁ pair ▁ is ▁ { " , nega , " , " , negb , " } " , sep = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Max ▁ product ▁ pair ▁ is ▁ { " , posa , " , " , posb , " } " , sep = " " ) NEW_LINE DEDENT DEDENT

BLEU: 87.44
Edit Sim: 85


Src: 
int findMaxVal ( int arr [ ] , int n , int num , int maxLimit ) { int ind ; int val ; int dp [ n ] [ maxLimit + 1 ] ; for ( ind = 0 ; ind < n ; ind ++ ) { for ( val = 0 ; val <= maxLimit ; val ++ ) { if ( ind == 0 ) { if ( num - arr [ ind ] == val || num + arr [ ind ] == val ) { dp [ ind ] [ val ] = 1 ; } else { dp [ ind ] [ val ] = 0 ; } } else { if ( val - arr [ ind ] >= 0 && val + arr [ ind ] <= maxLimit ) { dp [ ind ] [ val ] = dp [ ind - 1 ] [ val - arr [ ind ] ] || dp [ ind - 1 ] [ val + arr [ ind ] ] ; } else if ( val - arr [ ind ] >= 0 ) { dp [ ind ] [ val ] = dp [ ind - 1 ] [ val - arr [ ind ] ] ; } else if ( val + arr [ ind ] <= maxLimit ) { dp [ ind ] [ val ] = dp [ ind - 1 ] [ val + arr [ ind ] ] ; } else { dp [ ind ] [ val ] = 0 ; } } } } for ( val = maxLimit ; val >= 0 ; val -- ) { if ( dp [ n - 1 ] [ val ] ) { return val ; } } return - 1 ; }
Ref: 
def findMaxVal ( arr , n , num , maxLimit ) : NEW_LINE INDENT ind = - 1 NEW_LINE val = - 1 NEW_LINE dp = [ [ 0 for i in range ( maxLimit + 1 ) ] for j in range ( n ) ] NEW_LINE for ind in range ( n ) : NEW_LINE INDENT for val in range ( maxLimit + 1 ) : NEW_LINE INDENT if ( ind == 0 ) : NEW_LINE INDENT if ( num - arr [ ind ] == val or num + arr [ ind ] == val ) : NEW_LINE INDENT dp [ ind ] [ val ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ ind ] [ val ] = 0 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( val - arr [ ind ] >= 0 and val + arr [ ind ] <= maxLimit ) : NEW_LINE INDENT if ( dp [ ind - 1 ] [ val - arr [ ind ] ] == 1 or dp [ ind - 1 ] [ val + arr [ ind ] ] == 1 ) : NEW_LINE INDENT dp [ ind ] [ val ] = 1 NEW_LINE DEDENT DEDENT elif ( val - arr [ ind ] >= 0 ) : NEW_LINE INDENT dp [ ind ] [ val ] = dp [ ind - 1 ] [ val - arr [ ind ] ] NEW_LINE DEDENT elif ( val + arr [ ind ] <= maxLimit ) : NEW_LINE INDENT dp [ ind ] [ val ] = dp [ ind - 1 ] [ val + arr [ ind ] ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ ind ] [ val ] = 0 NEW_LINE DEDENT DEDENT DEDENT DEDENT for val in range ( maxLimit , - 1 , - 1 ) : NEW_LINE INDENT if ( dp [ n - 1 ] [ val ] == 1 ) : NEW_LINE INDENT return val NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
Hyp: 
def findMaxVal ( arr , n , num , maxLimit ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( maxLimit + 1 ) ] for j in range ( n ) ] NEW_LINE for ind in range ( n ) : NEW_LINE INDENT for val in range ( maxLimit + 1 ) : NEW_LINE INDENT if ( ind == 0 ) : NEW_LINE INDENT if ( num - arr [ ind ] == val or num + arr [ ind ] == val ) : NEW_LINE INDENT dp [ ind ] [ val ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ ind ] [ val ] = 0 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( val - arr [ ind ] >= 0 and val + arr [ ind ] <= maxLimit ) : NEW_LINE INDENT dp [ ind ] [ val ] = dp [ ind - 1 ] [ val - arr [ ind ] ] or dp [ ind - 1 ] [ val + arr [ ind ] ] NEW_LINE DEDENT elif ( val - arr [ ind ] >= 0 ) : NEW_LINE INDENT dp [ ind ] [ val ] = dp [ ind - 1 ] [ val - arr [ ind ] ] NEW_LINE DEDENT elif ( val + arr [ ind ] <= maxLimit ) : NEW_LINE INDENT dp [ ind ] [ val ] = dp [ ind - 1 ] [ val + arr [ ind ] ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ ind ] [ val ] = 0 NEW_LINE DEDENT DEDENT DEDENT for val in range ( maxLimit , - 1 , - 1 ) : NEW_LINE INDENT if ( dp [ n - 1 ] [ val ] ) : NEW_LINE INDENT return val NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT

BLEU: 90.12
Edit Sim: 122


Src: 
int Resources ( int process , int need ) { int minResources = 0 ; minResources = process * ( need - 1 ) + 1 ; return minResources ; }
Ref: 
def Resources ( process , need ) : NEW_LINE INDENT minResources = 0 NEW_LINE minResources = process * ( need - 1 ) + 1 NEW_LINE return minResources NEW_LINE DEDENT
Hyp: 
def Resources ( process , need ) : NEW_LINE INDENT minResources = 0 NEW_LINE minResources = process * ( need - 1 ) + 1 NEW_LINE return minResources NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
void bubbleSort ( int arr [ ] , int n ) { int i , j ; for ( i = 0 ; i < n - 1 ; i ++ ) for ( j = 0 ; j < n - i - 1 ; j ++ ) if ( arr [ j ] > arr [ j + 1 ] ) swap ( & arr [ j ] , & arr [ j + 1 ] ) ; }
Ref: 
def bubbleSort ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( 0 , n - i - 1 ) : NEW_LINE INDENT if arr [ j ] > arr [ j + 1 ] : NEW_LINE INDENT arr [ j ] , arr [ j + 1 ] = arr [ j + 1 ] , arr [ j ] NEW_LINE DEDENT DEDENT DEDENT DEDENT
Hyp: 
def bubbleSort ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( 0 , n - i - 1 ) : NEW_LINE INDENT if arr [ j ] > arr [ j + 1 ] : NEW_LINE INDENT arr [ j ] , arr [ j + 1 ] = arr [ j + 1 ] , arr [ j ] NEW_LINE DEDENT DEDENT DEDENT

BLEU: 98.8
Edit Sim: 7


Src: 
int superSeq ( char * X , char * Y , int m , int n ) { int dp [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( ! i ) dp [ i ] [ j ] = j ; else if ( ! j ) dp [ i ] [ j ] = i ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = 1 + min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) ; } } return dp [ m ] [ n ] ; }
Ref: 
def superSeq ( X , Y , m , n ) : NEW_LINE INDENT dp = [ [ 0 ] * ( n + 2 ) for i in range ( m + 2 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if ( not i ) : dp [ i ] [ j ] = j NEW_LINE elif ( not j ) : dp [ i ] [ j ] = i NEW_LINE elif ( X [ i - 1 ] == Y [ j - 1 ] ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : dp [ i ] [ j ] = 1 + min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT return dp [ m ] [ n ] NEW_LINE DEDENT
Hyp: 
def superSeq ( X , Y , m , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( m + 1 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if ( not i ) : NEW_LINE INDENT dp [ i ] [ j ] = j NEW_LINE DEDENT elif ( not j ) : NEW_LINE INDENT dp [ i ] [ j ] = i NEW_LINE DEDENT elif ( X [ i - 1 ] == Y [ j - 1 ] ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = 1 + min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ m ] [ n ] NEW_LINE DEDENT

BLEU: 84.95
Edit Sim: 87


Src: 
int countIntegralSolutions ( int n ) { int result = 0 ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= n - i ; j ++ ) for ( int k = 0 ; k <= ( n - i - j ) ; k ++ ) if ( i + j + k == n ) result ++ ; return result ; }
Ref: 
def countIntegralSolutions ( n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT for k in range ( n + 1 ) : NEW_LINE INDENT if i + j + k == n : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
Hyp: 
def countIntegralSolutions ( n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n - i ) : NEW_LINE INDENT for k in range ( ( n - i - j ) + 1 ) : NEW_LINE INDENT if ( i + j + k == n ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT

BLEU: 75.57
Edit Sim: 29


Src: 
int minJumps ( int arr [ ] , int n ) { int * jumps = new int [ n ] ; int min ; jumps [ n - 1 ] = 0 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] == 0 ) jumps [ i ] = INT_MAX ; else if ( arr [ i ] >= n - i - 1 ) jumps [ i ] = 1 ; else { min = INT_MAX ; for ( int j = i + 1 ; j < n && j <= arr [ i ] + i ; j ++ ) { if ( min > jumps [ j ] ) min = jumps [ j ] ; } if ( min != INT_MAX ) jumps [ i ] = min + 1 ; else jumps [ i ] = min ; } } return jumps [ 0 ] ; }
Ref: 
def minJumps ( arr , n ) : NEW_LINE INDENT jumps = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] == 0 ) : NEW_LINE INDENT jumps [ i ] = float ( ' inf ' ) NEW_LINE DEDENT elif ( arr [ i ] >= n - i - 1 ) : NEW_LINE INDENT jumps [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT min = float ( ' inf ' ) NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( j <= arr [ i ] + i ) : NEW_LINE INDENT if ( min > jumps [ j ] ) : NEW_LINE INDENT min = jumps [ j ] NEW_LINE DEDENT DEDENT DEDENT if ( min != float ( ' inf ' ) ) : NEW_LINE INDENT jumps [ i ] = min + 1 NEW_LINE DEDENT else : NEW_LINE INDENT jumps [ i ] = min NEW_LINE DEDENT DEDENT DEDENT return jumps [ 0 ] NEW_LINE DEDENT
Hyp: 
def minJumps ( arr , n ) : NEW_LINE INDENT jumps = [ 0 ] * n NEW_LINE jumps [ n - 1 ] = 0 NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if arr [ i ] == 0 : NEW_LINE INDENT jumps [ i ] = sys . maxsize NEW_LINE DEDENT elif arr [ i ] >= n - i - 1 : NEW_LINE INDENT jumps [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT min = sys . maxsize NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if min > jumps [ j ] : NEW_LINE INDENT min = jumps [ j ] NEW_LINE DEDENT DEDENT if min != sys . maxsize : NEW_LINE INDENT jumps [ i ] = min + 1 NEW_LINE DEDENT else : NEW_LINE INDENT jumps [ i ] = min NEW_LINE DEDENT DEDENT return jumps [ 0 ] NEW_LINE DEDENT

BLEU: 65.54
Edit Sim: 144


Src: 
int minAdjustmentCost ( int A [ ] , int n , int target ) { int dp [ n ] [ M + 1 ] ; for ( int j = 0 ; j <= M ; j ++ ) dp [ 0 ] [ j ] = abs ( j - A [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j <= M ; j ++ ) { dp [ i ] [ j ] = INT_MAX ; for ( int k = max ( j - target , 0 ) ; k <= min ( M , j + target ) ; k ++ ) dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ i - 1 ] [ k ] + abs ( A [ i ] - j ) ) ; } } int res = INT_MAX ; for ( int j = 0 ; j <= M ; j ++ ) res = min ( res , dp [ n - 1 ] [ j ] ) ; return res ; }
Ref: 
def minAdjustmentCost ( A , n , target ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( M + 1 ) ] for i in range ( n ) ] NEW_LINE for j in range ( M + 1 ) : NEW_LINE INDENT dp [ 0 ] [ j ] = abs ( j - A [ 0 ] ) NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( M + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = 100000000 NEW_LINE for k in range ( max ( j - target , 0 ) , min ( M , j + target ) + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ i - 1 ] [ k ] + abs ( A [ i ] - j ) ) NEW_LINE DEDENT DEDENT DEDENT res = 10000000 NEW_LINE for j in range ( M + 1 ) : NEW_LINE INDENT res = min ( res , dp [ n - 1 ] [ j ] ) NEW_LINE DEDENT return res NEW_LINE DEDENT
Hyp: 
def minAdjustmentCost ( A , n , target ) : NEW_LINE INDENT dp = [ [ 0 for j in range ( M + 1 ) ] for i in range ( n ) ] NEW_LINE for j in range ( M + 1 ) : NEW_LINE INDENT dp [ 0 ] [ j ] = abs ( j - A [ 0 ] ) NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( M + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = sys . maxint NEW_LINE for k in range ( max ( j - target , 0 ) , min ( M , j + target ) + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ i - 1 ] [ k ] + abs ( A [ i ] - j ) ) NEW_LINE DEDENT DEDENT DEDENT res = sys . maxsize NEW_LINE for j in range ( M + 1 ) : NEW_LINE INDENT res = min ( res , dp [ n - 1 ] [ j ] ) NEW_LINE DEDENT return res NEW_LINE DEDENT

BLEU: 94.57
Edit Sim: 26


Src: 
int kthSmallest ( int arr [ ] , int n , int k ) { sort ( arr , arr + n ) ; return arr [ k - 1 ] ; }
Ref: 
def kthSmallest ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE return arr [ k - 1 ] NEW_LINE DEDENT
Hyp: 
def kthSmallest ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE return arr [ k - 1 ] NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
INT_MAX int minCost ( int cost [ ] [ N ] ) { int dist [ N ] ; for ( int i = 0 ; i < N ; i ++ ) dist [ i ] = INF ; dist [ 0 ] = 0 ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = i + 1 ; j < N ; j ++ ) if ( dist [ j ] > dist [ i ] + cost [ i ] [ j ] ) dist [ j ] = dist [ i ] + cost [ i ] [ j ] ; return dist [ N - 1 ] ; }
Ref: 
def minCost ( cost ) : NEW_LINE INDENT dist = [ 0 for i in range ( N ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT dist [ i ] = INF NEW_LINE DEDENT dist [ 0 ] = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT if ( dist [ j ] > dist [ i ] + cost [ i ] [ j ] ) : NEW_LINE INDENT dist [ j ] = dist [ i ] + cost [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return dist [ N - 1 ] NEW_LINE DEDENT
Hyp: 
def minCost ( cost ) : NEW_LINE INDENT dist = [ INF ] * N NEW_LINE for i in range ( N ) : NEW_LINE INDENT dist [ i ] = INF NEW_LINE DEDENT dist [ 0 ] = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT if ( dist [ j ] > dist [ i ] + cost [ i ] [ j ] ) : NEW_LINE INDENT dist [ j ] = dist [ i ] + cost [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return dist [ N - 1 ] NEW_LINE DEDENT

BLEU: 91.75
Edit Sim: 20


Src: 
string reversingString ( string str , int start , int end ) { while ( start < end ) { str [ start ] ^= str [ end ] ; str [ end ] ^= str [ start ] ; str [ start ] ^= str [ end ] ; ++ start ; -- end ; } return str ; }
Ref: 
def reversingString ( str , start , end ) : NEW_LINE INDENT while ( start < end ) : NEW_LINE INDENT str = ( str [ : start ] + chr ( ord ( str [ start ] ) ^ ord ( str [ end ] ) ) + str [ start + 1 : ] ) NEW_LINE str = ( str [ : end ] + chr ( ord ( str [ start ] ) ^ ord ( str [ end ] ) ) + str [ end + 1 : ] ) NEW_LINE str = ( str [ : start ] + chr ( ord ( str [ start ] ) ^ ord ( str [ end ] ) ) + str [ start + 1 : ] ) NEW_LINE start += 1 NEW_LINE end -= 1 NEW_LINE DEDENT return str NEW_LINE DEDENT
Hyp: 
def reversingString ( str , start , end ) : NEW_LINE INDENT while ( start < end ) : NEW_LINE INDENT str [ start ] ^= str [ end ] NEW_LINE str [ end ] ^= str [ start ] NEW_LINE str [ start ] ^= str [ end ] NEW_LINE start += 1 NEW_LINE end -= 1 NEW_LINE DEDENT return str NEW_LINE DEDENT

BLEU: 21.69
Edit Sim: 219


Src: 
int minimalSteps ( string s , int n ) { int dp [ n ] ; for ( int i = 0 ; i < n ; i ++ ) dp [ i ] = INT_MAX ; string s1 = " " , s2 = " " ; dp [ 0 ] = 1 ; s1 += s [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { s1 += s [ i ] ; s2 = s . substr ( i + 1 , i + 1 ) ; dp [ i ] = min ( dp [ i ] , dp [ i - 1 ] + 1 ) ; if ( s1 == s2 ) dp [ i * 2 + 1 ] = min ( dp [ i ] + 1 , dp [ i * 2 + 1 ] ) ; } return dp [ n - 1 ] ; }
Ref: 
def minimalSteps ( s , n ) : NEW_LINE INDENT dp = [ INT_MAX for i in range ( n ) ] NEW_LINE s1 = " " NEW_LINE s2 = " " NEW_LINE dp [ 0 ] = 1 NEW_LINE s1 += s [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT s1 += s [ i ] NEW_LINE s2 = s [ i + 1 : i + 1 + i + 1 ] NEW_LINE dp [ i ] = min ( dp [ i ] , dp [ i - 1 ] + 1 ) NEW_LINE if ( s1 == s2 ) : NEW_LINE INDENT dp [ i * 2 + 1 ] = min ( dp [ i ] + 1 , dp [ i * 2 + 1 ] ) NEW_LINE DEDENT DEDENT return dp [ n - 1 ] NEW_LINE DEDENT
Hyp: 
def minimalSteps ( s , n ) : NEW_LINE INDENT dp = [ None ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp [ i ] = sys . maxsize NEW_LINE DEDENT s1 = " " NEW_LINE s2 = " " NEW_LINE dp [ 0 ] = 1 NEW_LINE s1 += s [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT s1 += s [ i ] NEW_LINE s2 = s . substr ( i + 1 , i + 1 ) NEW_LINE dp [ i ] = min ( dp [ i ] , dp [ i - 1 ] + 1 ) NEW_LINE if ( s1 == s2 ) : NEW_LINE INDENT dp [ i * 2 + 1 ] = min ( dp [ i ] + 1 , dp [ i * 2 + 1 ] ) NEW_LINE DEDENT DEDENT return dp [ n - 1 ] NEW_LINE DEDENT

BLEU: 82.46
Edit Sim: 75


Src: 
int MinimumCost ( int cost [ ] , int n , int W ) { vector < int > val , wt ; int size = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( cost [ i ] != - 1 ) { val . push_back ( cost [ i ] ) ; wt . push_back ( i + 1 ) ; size ++ ; } } n = size ; int min_cost [ n + 1 ] [ W + 1 ] ; for ( int i = 0 ; i <= W ; i ++ ) min_cost [ 0 ] [ i ] = INF ; for ( int i = 1 ; i <= n ; i ++ ) min_cost [ i ] [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= W ; j ++ ) { if ( wt [ i - 1 ] > j ) min_cost [ i ] [ j ] = min_cost [ i - 1 ] [ j ] ; else min_cost [ i ] [ j ] = min ( min_cost [ i - 1 ] [ j ] , min_cost [ i ] [ j - wt [ i - 1 ] ] + val [ i - 1 ] ) ; } } return ( min_cost [ n ] [ W ] == INF ) ? - 1 : min_cost [ n ] [ W ] ; }
Ref: 
def MinimumCost ( cost , n , W ) : NEW_LINE INDENT val = list ( ) NEW_LINE wt = list ( ) NEW_LINE size = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( cost [ i ] != - 1 ) : NEW_LINE INDENT val . append ( cost [ i ] ) NEW_LINE wt . append ( i + 1 ) NEW_LINE size += 1 NEW_LINE DEDENT DEDENT n = size NEW_LINE min_cost = [ [ 0 for i in range ( W + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( W + 1 ) : NEW_LINE INDENT min_cost [ 0 ] [ i ] = INF NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT min_cost [ i ] [ 0 ] = 0 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , W + 1 ) : NEW_LINE INDENT if ( wt [ i - 1 ] > j ) : NEW_LINE INDENT min_cost [ i ] [ j ] = min_cost [ i - 1 ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT min_cost [ i ] [ j ] = min ( min_cost [ i - 1 ] [ j ] , min_cost [ i ] [ j - wt [ i - 1 ] ] + val [ i - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT if ( min_cost [ n ] [ W ] == INF ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return min_cost [ n ] [ W ] NEW_LINE DEDENT DEDENT
Hyp: 
def MinimumCost ( cost , n , W ) : NEW_LINE INDENT val = [ ] NEW_LINE wt = [ ] NEW_LINE size = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( cost [ i ] != - 1 ) : NEW_LINE INDENT val . append ( cost [ i ] ) NEW_LINE wt . append ( i + 1 ) NEW_LINE size += 1 NEW_LINE DEDENT DEDENT n = size NEW_LINE min_cost = [ [ INF for i in range ( W + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT min_cost [ 0 ] [ i ] = INF NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , W + 1 ) : NEW_LINE INDENT if ( wt [ i - 1 ] > j ) : NEW_LINE INDENT min_cost [ i ] [ j ] = min_cost [ i - 1 ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT min_cost [ i ] [ j ] = min ( min_cost [ i - 1 ] [ j ] , min_cost [ i ] [ j - wt [ i - 1 ] ] + val [ i - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return - 1 if ( min_cost [ n ] [ W ] == INF ) else min_cost [ n ] [ W ] NEW_LINE DEDENT

BLEU: 79.23
Edit Sim: 219


Src: 
void bitonicGenerator ( int arr [ ] , int n ) { vector < int > evenArr ; vector < int > oddArr ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! ( i % 2 ) ) evenArr . push_back ( arr [ i ] ) ; else oddArr . push_back ( arr [ i ] ) ; } sort ( evenArr . begin ( ) , evenArr . end ( ) ) ; sort ( oddArr . begin ( ) , oddArr . end ( ) , greater < int > ( ) ) ; int i = 0 ; for ( int j = 0 ; j < evenArr . size ( ) ; j ++ ) arr [ i ++ ] = evenArr [ j ] ; for ( int j = 0 ; j < oddArr . size ( ) ; j ++ ) arr [ i ++ ] = oddArr [ j ] ; }
Ref: 
def bitonicGenerator ( arr , n ) : NEW_LINE INDENT evenArr = [ ] NEW_LINE oddArr = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( i % 2 ) == 0 ) : NEW_LINE INDENT evenArr . append ( arr [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT oddArr . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT evenArr = sorted ( evenArr ) NEW_LINE oddArr = sorted ( oddArr ) NEW_LINE oddArr = oddArr [ : : - 1 ] NEW_LINE i = 0 NEW_LINE for j in range ( len ( evenArr ) ) : NEW_LINE INDENT arr [ i ] = evenArr [ j ] NEW_LINE i += 1 NEW_LINE DEDENT for j in range ( len ( oddArr ) ) : NEW_LINE INDENT arr [ i ] = oddArr [ j ] NEW_LINE i += 1 NEW_LINE DEDENT DEDENT
Hyp: 
def bitonicGenerator ( arr , n ) : NEW_LINE INDENT evenArr = [ 0 ] * n NEW_LINE oddArr = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( not ( i % 2 ) ) : NEW_LINE INDENT evenArr . append ( arr [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT oddArr . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT evenArr . sort ( reverse = True ) NEW_LINE for j in range ( len ( evenArr ) ) : NEW_LINE INDENT arr [ i ] = evenArr [ j ] NEW_LINE DEDENT for j in range ( len ( oddArr ) ) : NEW_LINE INDENT arr [ i ] = oddArr [ j ] NEW_LINE DEDENT DEDENT

BLEU: 69.71
Edit Sim: 143


Src: 
int countDivisibles ( int arr [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] % arr [ j ] == 0 || arr [ j ] % arr [ i ] == 0 ) res ++ ; return res ; }
Ref: 
def countDivisibles ( arr , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] % arr [ j ] == 0 or arr [ j ] % arr [ i ] == 0 ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT
Hyp: 
def countDivisibles ( arr , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if arr [ i ] % arr [ j ] == 0 or arr [ j ] % arr [ i ] == 0 : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT

BLEU: 93.61
Edit Sim: 4


Src: 
int lis ( int arr [ ] , int n ) { int max = 1 ; _lis ( arr , n , & max ) ; return max ; }
Ref: 
def lis ( arr ) : NEW_LINE INDENT global maximum NEW_LINE n = len ( arr ) NEW_LINE maximum = 1 NEW_LINE _lis ( arr , n ) NEW_LINE return maximum NEW_LINE DEDENT
Hyp: 
def lis ( arr , n ) : NEW_LINE INDENT max = 1 NEW_LINE arr [ n ] = max NEW_LINE return max NEW_LINE DEDENT

BLEU: 31.82
Edit Sim: 71


Src: 
void printFirstRepeating ( int arr [ ] , int n ) { int min = - 1 ; set < int > myset ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( myset . find ( arr [ i ] ) != myset . end ( ) ) min = i ; else myset . insert ( arr [ i ] ) ; } if ( min != - 1 ) cout << " The ▁ first ▁ repeating ▁ element ▁ is ▁ " << arr [ min ] ; else cout << " There ▁ are ▁ no ▁ repeating ▁ elements " ; }
Ref: 
def printFirstRepeating ( arr , n ) : NEW_LINE INDENT Min = - 1 NEW_LINE myset = dict ( ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if arr [ i ] in myset . keys ( ) : NEW_LINE INDENT Min = i NEW_LINE DEDENT else : NEW_LINE INDENT myset [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT if ( Min != - 1 ) : NEW_LINE INDENT print ( " The ▁ first ▁ repeating ▁ element ▁ is " , arr [ Min ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " There ▁ are ▁ no ▁ repeating ▁ elements " ) NEW_LINE DEDENT DEDENT
Hyp: 
def printFirstRepeating ( arr , n ) : NEW_LINE INDENT min = - 1 NEW_LINE myset = set ( ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if arr [ i ] in myset : NEW_LINE INDENT min = i NEW_LINE DEDENT else : NEW_LINE INDENT myset . add ( arr [ i ] ) NEW_LINE DEDENT DEDENT if ( min != - 1 ) : NEW_LINE INDENT print ( " The ▁ first ▁ repeating ▁ element ▁ is " , arr [ min ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " There ▁ are ▁ no ▁ repeating ▁ elements " ) NEW_LINE DEDENT DEDENT

BLEU: 80.36
Edit Sim: 29


Src: 
int minCoins ( int coins [ ] , int m , int V ) { if ( V == 0 ) return 0 ; int res = INT_MAX ; for ( int i = 0 ; i < m ; i ++ ) { if ( coins [ i ] <= V ) { int sub_res = minCoins ( coins , m , V - coins [ i ] ) ; if ( sub_res != INT_MAX && sub_res + 1 < res ) res = sub_res + 1 ; } } return res ; }
Ref: 
def minCoins ( coins , m , V ) : NEW_LINE INDENT if ( V == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT res = sys . maxsize NEW_LINE for i in range ( 0 , m ) : NEW_LINE INDENT if ( coins [ i ] <= V ) : NEW_LINE INDENT sub_res = minCoins ( coins , m , V - coins [ i ] ) NEW_LINE if ( sub_res != sys . maxsize and sub_res + 1 < res ) : NEW_LINE INDENT res = sub_res + 1 NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT
Hyp: 
def minCoins ( coins , m , V ) : NEW_LINE INDENT if ( V == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT res = sys . maxsize NEW_LINE for i in range ( m ) : NEW_LINE INDENT if ( coins [ i ] <= V ) : NEW_LINE INDENT sub_res = minCoins ( coins , m , V - coins [ i ] ) NEW_LINE if ( sub_res != sys . maxsize and sub_res + 1 < res ) : NEW_LINE INDENT res = sub_res + 1 NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT

BLEU: 96.49
Edit Sim: 4


Src: 
void pairSum ( int mat [ ] [ MAX ] , int n , int sum ) { for ( int i = 0 ; i < n ; i ++ ) sort ( mat [ i ] , mat [ i ] + n ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int left = 0 , right = n - 1 ; while ( left < n && right >= 0 ) { if ( ( mat [ i ] [ left ] + mat [ j ] [ right ] ) == sum ) { cout << " ( " << mat [ i ] [ left ] << " , ▁ " << mat [ j ] [ right ] << " ) , ▁ " ; left ++ ; right -- ; } else { if ( ( mat [ i ] [ left ] + mat [ j ] [ right ] ) < sum ) left ++ ; else right -- ; } } } } }
Ref: 
def pairSum ( mat , n , sum ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT mat [ i ] . sort ( ) NEW_LINE DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT left = 0 NEW_LINE right = n - 1 NEW_LINE while ( left < n and right >= 0 ) : NEW_LINE INDENT if ( ( mat [ i ] [ left ] + mat [ j ] [ right ] ) == sum ) : NEW_LINE INDENT print ( " ( " , mat [ i ] [ left ] , " , ▁ " , mat [ j ] [ right ] , " ) , ▁ " , end = " ▁ " ) NEW_LINE left += 1 NEW_LINE right -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( ( mat [ i ] [ left ] + mat [ j ] [ right ] ) < sum ) : NEW_LINE INDENT left += 1 NEW_LINE DEDENT else : NEW_LINE INDENT right -= 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT
Hyp: 
def pairSum ( mat , n , sum ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT mat . sort ( ) NEW_LINE DEDENT for i in range ( 0 , n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT left = 0 NEW_LINE right = n - 1 NEW_LINE while ( left < n and right >= 0 ) : NEW_LINE INDENT if ( ( mat [ i ] [ left ] + mat [ j ] [ right ] ) == sum ) : NEW_LINE INDENT print ( " ( " , mat [ i ] [ left ] , " , ▁ " , mat [ j ] [ right ] , " ) , ▁ " ) NEW_LINE left += 1 NEW_LINE right -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( ( mat [ i ] [ left ] + mat [ j ] [ right ] ) < sum ) : NEW_LINE INDENT left += 1 NEW_LINE DEDENT else : NEW_LINE INDENT right -= 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT

BLEU: 92.26
Edit Sim: 42


Src: 
int minimum_cost ( int a [ ] , int n ) { int mn = INT_MAX ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { mn = min ( a [ i ] , mn ) ; sum += a [ i ] ; } return mn * ( sum - mn ) ; }
Ref: 
def minimum_cost ( a , n ) : NEW_LINE INDENT mn = sys . maxsize NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT mn = min ( a [ i ] , mn ) NEW_LINE sum += a [ i ] NEW_LINE DEDENT return mn * ( sum - mn ) NEW_LINE DEDENT
Hyp: 
def minimum_cost ( a , n ) : NEW_LINE INDENT mn = sys . maxsize NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT mn = min ( a [ i ] , mn ) NEW_LINE sum += a [ i ] NEW_LINE DEDENT return mn * ( sum - mn ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int lps ( char * str ) { int n = strlen ( str ) ; int i , j , cl ; int L [ n ] [ n ] ; for ( i = 0 ; i < n ; i ++ ) L [ i ] [ i ] = 1 ; for ( cl = 2 ; cl <= n ; cl ++ ) { for ( i = 0 ; i < n - cl + 1 ; i ++ ) { j = i + cl - 1 ; if ( str [ i ] == str [ j ] && cl == 2 ) L [ i ] [ j ] = 2 ; else if ( str [ i ] == str [ j ] ) L [ i ] [ j ] = L [ i + 1 ] [ j - 1 ] + 2 ; else L [ i ] [ j ] = max ( L [ i ] [ j - 1 ] , L [ i + 1 ] [ j ] ) ; } } return L [ 0 ] [ n - 1 ] ; }
Ref: 
def lps ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE L = [ [ 0 for x in range ( n ) ] for x in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT L [ i ] [ i ] = 1 NEW_LINE DEDENT for cl in range ( 2 , n + 1 ) : NEW_LINE INDENT for i in range ( n - cl + 1 ) : NEW_LINE INDENT j = i + cl - 1 NEW_LINE if str [ i ] == str [ j ] and cl == 2 : NEW_LINE INDENT L [ i ] [ j ] = 2 NEW_LINE DEDENT elif str [ i ] == str [ j ] : NEW_LINE INDENT L [ i ] [ j ] = L [ i + 1 ] [ j - 1 ] + 2 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] = max ( L [ i ] [ j - 1 ] , L [ i + 1 ] [ j ] ) ; NEW_LINE DEDENT DEDENT DEDENT return L [ 0 ] [ n - 1 ] NEW_LINE DEDENT
Hyp: 
def lps ( str1 ) : NEW_LINE INDENT n = len ( str1 ) NEW_LINE L = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT L [ i ] [ i ] = 1 NEW_LINE DEDENT for cl in range ( 2 , n + 1 ) : NEW_LINE INDENT for i in range ( n - cl + 1 ) : NEW_LINE INDENT j = i + cl - 1 NEW_LINE if ( str1 [ i ] == str1 [ j ] and cl == 2 ) : NEW_LINE INDENT L [ i ] [ j ] = 2 NEW_LINE DEDENT elif ( str1 [ i ] == str1 [ j ] ) : NEW_LINE INDENT L [ i ] [ j ] = L [ i + 1 ] [ j - 1 ] + 2 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] = max ( L [ i ] [ j - 1 ] , L [ i + 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return L [ 0 ] [ n - 1 ] NEW_LINE DEDENT

BLEU: 86.29
Edit Sim: 18


Src: 
string censor ( string text , string word ) { vector < string > word_list ; boost :: split ( word_list , text , boost :: is_any_of ( " \\ ▁ + " ) ) ; string result = " " ; string stars = " " ; for ( int i = 0 ; i < word . size ( ) ; i ++ ) stars += ' * ' ; int index = 0 ; for ( string i : word_list ) { if ( i . compare ( word ) == 0 ) { word_list [ index ] = stars ; } index ++ ; } for ( string i : word_list ) { result += i + ' ▁ ' ; } return result ; }
Ref: 
def censor ( text , word ) : NEW_LINE INDENT word_list = text . split ( ) NEW_LINE result = ' ' NEW_LINE stars = ' * ' * len ( word ) NEW_LINE count = 0 NEW_LINE index = 0 NEW_LINE for i in word_list : NEW_LINE INDENT if i == word : NEW_LINE INDENT word_list [ index ] = stars NEW_LINE DEDENT index += 1 NEW_LINE DEDENT result = ' ▁ ' . join ( word_list ) NEW_LINE return result NEW_LINE DEDENT
Hyp: 
def censor ( text , word ) : NEW_LINE INDENT word_list = [ ] NEW_LINE text = list ( text ) NEW_LINE result = " " NEW_LINE stars = " " NEW_LINE for i in range ( len ( word ) ) : NEW_LINE INDENT stars += ' * ' NEW_LINE DEDENT index = 0 NEW_LINE for i in range ( len ( word_list ) ) : NEW_LINE INDENT if ( i == word [ 0 ] ) : NEW_LINE INDENT word_list [ index ] = stars NEW_LINE DEDENT index += 1 NEW_LINE DEDENT for i in word_list : NEW_LINE INDENT if ( i == word ) : NEW_LINE INDENT word_list [ index ] = stars NEW_LINE DEDENT index += 1 NEW_LINE DEDENT for i in word_list : NEW_LINE INDENT result += i + ' ▁ ' NEW_LINE DEDENT return result NEW_LINE DEDENT

BLEU: 36.34
Edit Sim: 287


Src: 
public : bool isPowerOfFour ( int n ) { if ( n == 0 ) return 0 ; while ( n != 1 ) { if ( n % 4 != 0 ) return 0 ; n = n / 4 ; } return 1 ; }
Ref: 
def isPowerOfFour ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT while ( n != 1 ) : NEW_LINE INDENT if ( n % 4 != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT n = n // 4 NEW_LINE DEDENT return True NEW_LINE DEDENT
Hyp: 
def isPowerOfFour ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT while ( n != 1 ) : NEW_LINE INDENT if ( n % 4 != 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT n = int ( n / 4 ) NEW_LINE DEDENT return 1 NEW_LINE DEDENT

BLEU: 74.98
Edit Sim: 22


Src: 
float getArea ( int a ) { float area = ( M_PI * a * a ) / 4.0 ; return area ; }
Ref: 
def getArea ( a ) : NEW_LINE INDENT area = ( math . pi * a * a ) / 4 NEW_LINE return area NEW_LINE DEDENT
Hyp: 
def getArea ( a ) : NEW_LINE INDENT area = ( M_PI * a * a ) / 4.0 NEW_LINE return area NEW_LINE DEDENT

BLEU: 71.3
Edit Sim: 11


Src: 
int distancesum ( int x [ ] , int y [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) sum += ( abs ( x [ i ] - x [ j ] ) + abs ( y [ i ] - y [ j ] ) ) ; return sum ; }
Ref: 
def distancesum ( x , y , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT sum += ( abs ( x [ i ] - x [ j ] ) + abs ( y [ i ] - y [ j ] ) ) NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
Hyp: 
def distancesum ( x , y , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT sum += ( abs ( x [ i ] - x [ j ] ) + abs ( y [ i ] - y [ j ] ) ) NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT

BLEU: 95.45
Edit Sim: 4


Src: 
void findMax ( int arr [ ] [ N ] ) { int row = 0 , i , j ; for ( i = 0 , j = N - 1 ; i < N ; i ++ ) { while ( arr [ i ] [ j ] == 1 && j >= 0 ) { row = i ; j -- ; } } cout << " Row ▁ number ▁ = ▁ " << row + 1 ; cout << " , ▁ MaxCount ▁ = ▁ " << N - 1 - j ; }
Ref: 
def findMax ( arr ) : NEW_LINE INDENT row = 0 NEW_LINE j = N - 1 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT while ( arr [ i ] [ j ] == 1 and j >= 0 ) : NEW_LINE INDENT row = i NEW_LINE j -= 1 NEW_LINE DEDENT DEDENT print ( " Row ▁ number ▁ = ▁ " , row + 1 , " , ▁ MaxCount ▁ = ▁ " , N - 1 - j ) NEW_LINE DEDENT
Hyp: 
def findMax ( arr ) : NEW_LINE INDENT row = 0 NEW_LINE j = N - 1 NEW_LINE for i in range ( N ) : NEW_LINE INDENT while ( arr [ i ] [ j ] == 1 and j >= 0 ) : NEW_LINE INDENT row = i NEW_LINE j -= 1 NEW_LINE DEDENT DEDENT print ( " Row ▁ number ▁ = ▁ " , row + 1 ) NEW_LINE print ( " , ▁ MaxCount ▁ = ▁ " , N - 1 - j ) NEW_LINE DEDENT

BLEU: 92.28
Edit Sim: 22


Src: 
int lastNon0Digit ( int n ) { if ( n < 10 ) return dig [ n ] ; if ( ( ( n / 10 ) % 10 ) % 2 == 0 ) return ( 6 * lastNon0Digit ( n / 5 ) * dig [ n % 10 ] ) % 10 ; else return ( 4 * lastNon0Digit ( n / 5 ) * dig [ n % 10 ] ) % 10 ; }
Ref: 
def lastNon0Digit ( n ) : NEW_LINE INDENT if ( n < 10 ) : NEW_LINE INDENT return dig [ n ] NEW_LINE DEDENT if ( ( ( n // 10 ) % 10 ) % 2 == 0 ) : NEW_LINE INDENT return ( 6 * lastNon0Digit ( n // 5 ) * dig [ n % 10 ] ) % 10 NEW_LINE DEDENT else : NEW_LINE INDENT return ( 4 * lastNon0Digit ( n // 5 ) * dig [ n % 10 ] ) % 10 NEW_LINE DEDENT return 0 NEW_LINE DEDENT
Hyp: 
def lastNon0Digit ( n ) : NEW_LINE INDENT if ( n < 10 ) : NEW_LINE INDENT return dig [ n ] NEW_LINE DEDENT if ( ( ( n // 10 ) % 10 ) % 2 == 0 ) : NEW_LINE INDENT return ( 6 * lastNon0Digit ( n // 5 ) * dig [ n % 10 ] ) % 10 NEW_LINE DEDENT else : NEW_LINE INDENT return ( 4 * lastNon0Digit ( n // 5 ) * dig [ n % 10 ] ) % 10 NEW_LINE DEDENT DEDENT

BLEU: 95.99
Edit Sim: 18


Src: 
int evenFibSum ( int limit ) { if ( limit < 2 ) return 0 ; long long int ef1 = 0 , ef2 = 2 ; long long int sum = ef1 + ef2 ; while ( ef2 <= limit ) { long long int ef3 = 4 * ef2 + ef1 ; if ( ef3 > limit ) break ; ef1 = ef2 ; ef2 = ef3 ; sum += ef2 ; } return sum ; }
Ref: 
def evenFibSum ( limit ) : NEW_LINE INDENT if ( limit < 2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ef1 = 0 NEW_LINE ef2 = 2 NEW_LINE sm = ef1 + ef2 NEW_LINE while ( ef2 <= limit ) : NEW_LINE INDENT ef3 = 4 * ef2 + ef1 NEW_LINE if ( ef3 > limit ) : NEW_LINE INDENT break NEW_LINE DEDENT ef1 = ef2 NEW_LINE ef2 = ef3 NEW_LINE sm = sm + ef2 NEW_LINE DEDENT return sm NEW_LINE DEDENT
Hyp: 
def evenFibSum ( limit ) : NEW_LINE INDENT if ( limit < 2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ef1 = 0 NEW_LINE ef2 = 2 NEW_LINE sum = ef1 + ef2 NEW_LINE while ( ef2 <= limit ) : NEW_LINE INDENT ef3 = 4 * ef2 + ef1 NEW_LINE if ( ef3 > limit ) : NEW_LINE INDENT break NEW_LINE DEDENT ef1 = ef2 NEW_LINE ef2 = ef3 NEW_LINE sum += ef2 NEW_LINE DEDENT return sum NEW_LINE DEDENT

BLEU: 87.43
Edit Sim: 8


Src: 
int search ( int arr [ ] , int n , int x ) { int i = 0 ; while ( i < n ) { if ( arr [ i ] == x ) return i ; i = i + abs ( arr [ i ] - x ) ; } cout << " number ▁ is ▁ not ▁ present ! " ; return - 1 ; }
Ref: 
def search ( arr , n , x ) : NEW_LINE INDENT i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( arr [ i ] == x ) : NEW_LINE INDENT return i NEW_LINE DEDENT i = i + abs ( arr [ i ] - x ) NEW_LINE DEDENT print ( " number ▁ is ▁ not ▁ present ! " ) NEW_LINE return - 1 NEW_LINE DEDENT
Hyp: 
def search ( arr , n , x ) : NEW_LINE INDENT i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( arr [ i ] == x ) : NEW_LINE INDENT return i NEW_LINE DEDENT i = i + abs ( arr [ i ] - x ) NEW_LINE DEDENT print ( " number ▁ is ▁ not ▁ present " ) NEW_LINE return - 1 NEW_LINE DEDENT

BLEU: 96.61
Edit Sim: 2


Src: 
bool isRotated ( string str1 , string str2 ) { if ( str1 . length ( ) != str2 . length ( ) ) return false ; string clock_rot = " " ; string anticlock_rot = " " ; int len = str2 . length ( ) ; anticlock_rot = anticlock_rot + str2 . substr ( len - 2 , 2 ) + str2 . substr ( 0 , len - 2 ) ; clock_rot = clock_rot + str2 . substr ( 2 ) + str2 . substr ( 0 , 2 ) ; return ( str1 . compare ( clock_rot ) == 0 || str1 . compare ( anticlock_rot ) == 0 ) ; }
Ref: 
def isRotated ( str1 , str2 ) : NEW_LINE INDENT if ( len ( str1 ) != len ( str2 ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT clock_rot = " " NEW_LINE anticlock_rot = " " NEW_LINE l = len ( str2 ) NEW_LINE anticlock_rot = ( anticlock_rot + str2 [ l - 2 : ] + str2 [ 0 : l - 2 ] ) NEW_LINE clock_rot = clock_rot + str2 [ 2 : ] + str2 [ 0 : 2 ] NEW_LINE return ( str1 == clock_rot or str1 == anticlock_rot ) NEW_LINE DEDENT
Hyp: 
def isRotated ( str1 , str2 ) : NEW_LINE INDENT if ( len ( str1 ) != len ( str2 ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT clock_rot = " " NEW_LINE anticlock_rot = " " NEW_LINE l = len ( str2 ) NEW_LINE anticlock_rot = anticlock_rot + str2 [ l - 2 , 2 ] + str2 [ 0 , l - 2 ] NEW_LINE clock_rot = clock_rot + str2 [ 2 ] + str2 [ 0 , 2 ] NEW_LINE return ( str1 == str2 [ 0 ] or str1 == str2 [ 1 ] ) NEW_LINE DEDENT

BLEU: 76.2
Edit Sim: 33


Src: 
void printHosoya ( int n ) { int dp [ N ] [ N ] ; memset ( dp , 0 , sizeof ( dp ) ) ; dp [ 0 ] [ 0 ] = dp [ 1 ] [ 0 ] = dp [ 1 ] [ 1 ] = 1 ; for ( int i = 2 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i > j ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 2 ] [ j ] ; else dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 2 ] [ j - 2 ] ; } } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j <= i ; j ++ ) cout << dp [ i ] [ j ] << " ▁ " ; cout << endl ; } }
Ref: 
def printHosoya ( n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( N ) ] for i in range ( N ) ] NEW_LINE dp [ 0 ] [ 0 ] = dp [ 1 ] [ 0 ] = dp [ 1 ] [ 1 ] = 1 NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( i > j ) : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] + dp [ i - 2 ] [ j ] ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i - 1 ] [ j - 1 ] + dp [ i - 2 ] [ j - 2 ] ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 ) : NEW_LINE INDENT print ( dp [ i ] [ j ] , end = ' ▁ ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT
Hyp: 
def printHosoya ( n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( N ) ] for j in range ( N ) ] NEW_LINE dp [ 0 ] [ 0 ] = dp [ 1 ] [ 0 ] = dp [ 1 ] [ 1 ] = 1 NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT if ( i > j ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 2 ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 2 ] [ j - 2 ] NEW_LINE DEDENT DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 ) : NEW_LINE INDENT print ( dp [ i ] [ j ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT

BLEU: 90.2
Edit Sim: 19


Src: 
int findSubArray ( int arr [ ] , int n ) { int sum = 0 ; int maxsize = - 1 , startindex ; for ( int i = 0 ; i < n - 1 ; i ++ ) { sum = ( arr [ i ] == 0 ) ? - 1 : 1 ; for ( int j = i + 1 ; j < n ; j ++ ) { ( arr [ j ] == 0 ) ? ( sum += - 1 ) : ( sum += 1 ) ; if ( sum == 0 && maxsize < j - i + 1 ) { maxsize = j - i + 1 ; startindex = i ; } } } if ( maxsize == - 1 ) cout << " No ▁ such ▁ subarray " ; else cout << startindex << " ▁ to ▁ " << startindex + maxsize - 1 ; return maxsize ; }
Ref: 
def findSubArray ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE maxsize = - 1 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT sum = - 1 if ( arr [ i ] == 0 ) else 1 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT sum = sum + ( - 1 ) if ( arr [ j ] == 0 ) else sum + 1 NEW_LINE if ( sum == 0 and maxsize < j - i + 1 ) : NEW_LINE INDENT maxsize = j - i + 1 NEW_LINE startindex = i NEW_LINE DEDENT DEDENT DEDENT if ( maxsize == - 1 ) : NEW_LINE INDENT print ( " No ▁ such ▁ subarray " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( startindex , " to " , startindex + maxsize - 1 ) NEW_LINE DEDENT return maxsize NEW_LINE DEDENT
Hyp: 
def findSubArray ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE maxsize = - 1 NEW_LINE startindex = 0 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT sum = 0 NEW_LINE if ( arr [ i ] == 0 ) : NEW_LINE INDENT sum = - 1 NEW_LINE DEDENT else : NEW_LINE INDENT sum = 1 NEW_LINE DEDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ j ] == 0 ) : NEW_LINE INDENT sum += - 1 NEW_LINE DEDENT else : NEW_LINE INDENT sum += 1 NEW_LINE DEDENT if ( sum == 0 and maxsize < j - i + 1 ) : NEW_LINE INDENT maxsize = j - i + 1 NEW_LINE startindex = i NEW_LINE DEDENT DEDENT DEDENT if ( maxsize == - 1 ) : NEW_LINE INDENT print ( " No ▁ such ▁ subarray " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( startindex , " to ▁ " , startindex + maxsize - 1 ) NEW_LINE DEDENT return maxsize NEW_LINE DEDENT

BLEU: 76.57
Edit Sim: 187


Src: 
void insertionSortRecursive ( int arr [ ] , int n ) { if ( n <= 1 ) return ; insertionSortRecursive ( arr , n - 1 ) ; int last = arr [ n - 1 ] ; int j = n - 2 ; while ( j >= 0 && arr [ j ] > last ) { arr [ j + 1 ] = arr [ j ] ; j -- ; } arr [ j + 1 ] = last ; }
Ref: 
def insertionSortRecursive ( arr , n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return NEW_LINE DEDENT insertionSortRecursive ( arr , n - 1 ) NEW_LINE last = arr [ n - 1 ] NEW_LINE j = n - 2 NEW_LINE while ( j >= 0 and arr [ j ] > last ) : NEW_LINE INDENT arr [ j + 1 ] = arr [ j ] NEW_LINE j = j - 1 NEW_LINE DEDENT arr [ j + 1 ] = last NEW_LINE DEDENT
Hyp: 
def insertionSortRecursive ( arr , n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return NEW_LINE DEDENT arr . sort ( ) NEW_LINE last = arr [ n - 1 ] NEW_LINE j = n - 2 NEW_LINE while ( j >= 0 and arr [ j ] > last ) : NEW_LINE INDENT arr [ j + 1 ] = arr [ j ] NEW_LINE j -= 1 NEW_LINE DEDENT arr [ j + 1 ] = last NEW_LINE DEDENT

BLEU: 85.64
Edit Sim: 35


Src: 
int findDiff ( int arr [ ] , int n ) { unordered_map < int , int > hm ; for ( int i = 0 ; i < n ; i ++ ) hm [ arr [ i ] ] ++ ; int max_count = 0 , min_count = n ; for ( auto x : hm ) { max_count = max ( max_count , x . second ) ; min_count = min ( min_count , x . second ) ; } return ( max_count - min_count ) ; }
Ref: 
def findDiff ( arr , n ) : NEW_LINE INDENT mp = defaultdict ( lambda : 0 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT max_count = 0 min_count = n NEW_LINE for key , values in mp . items ( ) : NEW_LINE INDENT max_count = max ( max_count , values ) NEW_LINE min_count = min ( min_count , values ) NEW_LINE DEDENT return max_count - min_count NEW_LINE DEDENT
Hyp: 
def findDiff ( arr , n ) : NEW_LINE INDENT hm = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT hm [ arr [ i ] ] = hm . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT max_count = 0 NEW_LINE min_count = n NEW_LINE for x in hm : NEW_LINE INDENT max_count = max ( max_count , x ) NEW_LINE min_count = min ( min_count , x ) NEW_LINE DEDENT return ( max_count - min_count ) NEW_LINE DEDENT

BLEU: 57.45
Edit Sim: 102


Src: 
int playGame ( int arr [ ] , int n ) { unordered_set < int > hash ; for ( int i = 0 ; i < n ; i ++ ) hash . insert ( arr [ i ] ) ; return ( hash . size ( ) % 2 == 0 ? 1 : 2 ) ; }
Ref: 
def playGame ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . add ( arr [ i ] ) NEW_LINE DEDENT return 1 if len ( s ) % 2 == 0 else 2 NEW_LINE DEDENT
Hyp: 
def playGame ( arr , n ) : NEW_LINE INDENT Hash = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT Hash . add ( arr [ i ] ) NEW_LINE DEDENT return ( len ( Hash ) % 2 == 0 ? 1 : 2 ) NEW_LINE DEDENT

BLEU: 69.94
Edit Sim: 20


Src: 
int subset ( int arr [ ] , int n ) { unordered_map < int , int > mp ; for ( int i = 0 ; i < n ; i ++ ) mp [ arr [ i ] ] ++ ; int res = 0 ; for ( auto x : mp ) res = max ( res , x . second ) ; return res ; }
Ref: 
def subset ( arr , n ) : NEW_LINE INDENT mp = { i : 0 for i in range ( 10 ) } NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT res = 0 NEW_LINE for key , value in mp . items ( ) : NEW_LINE INDENT res = max ( res , value ) NEW_LINE DEDENT return res NEW_LINE DEDENT
Hyp: 
def subset ( arr , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] = mp . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT res = 0 NEW_LINE for x in mp : NEW_LINE INDENT res = max ( res , x ) NEW_LINE DEDENT return res NEW_LINE DEDENT

BLEU: 65.2
Edit Sim: 84


Src: 
bool isProduct ( int arr [ ] , int n , int x ) { if ( n < 2 ) return false ; unordered_set < int > s ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) { if ( x == 0 ) return true ; else continue ; } if ( x % arr [ i ] == 0 ) { if ( s . find ( x / arr [ i ] ) != s . end ( ) ) return true ; s . insert ( arr [ i ] ) ; } } return false ; }
Ref: 
def isProduct ( arr , n , x ) : NEW_LINE INDENT if n < 2 : NEW_LINE INDENT return False NEW_LINE DEDENT s = set ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if arr [ i ] == 0 : NEW_LINE INDENT if x == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT continue NEW_LINE DEDENT DEDENT if x % arr [ i ] == 0 : NEW_LINE INDENT if x // arr [ i ] in s : NEW_LINE INDENT return True NEW_LINE DEDENT s . add ( arr [ i ] ) NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
Hyp: 
def isProduct ( arr , n , x ) : NEW_LINE INDENT if ( n < 2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT s = set ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] == 0 ) : NEW_LINE INDENT if ( x == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT continue NEW_LINE DEDENT DEDENT if ( x % arr [ i ] == 0 ) : NEW_LINE INDENT if ( x // arr [ i ] ) in s : NEW_LINE INDENT return True NEW_LINE DEDENT s . add ( arr [ i ] ) NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT

BLEU: 79.13
Edit Sim: 20


Src: 
double largestSumOfAverages ( vector < int > & A , int K ) { int n = A . size ( ) ; double pre_sum [ n + 1 ] ; pre_sum [ 0 ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) pre_sum [ i + 1 ] = pre_sum [ i ] + A [ i ] ; double dp [ n ] = { 0 } ; double sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) dp [ i ] = ( pre_sum [ n ] - pre_sum [ i ] ) / ( n - i ) ; for ( int k = 0 ; k < K - 1 ; k ++ ) for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) dp [ i ] = max ( dp [ i ] , ( pre_sum [ j ] - pre_sum [ i ] ) / ( j - i ) + dp [ j ] ) ; return dp [ 0 ] ; }
Ref: 
def largestSumOfAverages ( A , K ) : NEW_LINE INDENT n = len ( A ) NEW_LINE pre_sum = [ 0 ] * ( n + 1 ) NEW_LINE pre_sum [ 0 ] = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT pre_sum [ i + 1 ] = pre_sum [ i ] + A [ i ] NEW_LINE DEDENT dp = [ 0 ] * n NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp [ i ] = ( pre_sum [ n ] - pre_sum [ i ] ) / ( n - i ) NEW_LINE DEDENT for k in range ( K - 1 ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i ] , ( pre_sum [ j ] - pre_sum [ i ] ) / ( j - i ) + dp [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return int ( dp [ 0 ] ) NEW_LINE DEDENT
Hyp: 
def largestSumOfAverages ( A , K ) : NEW_LINE INDENT n = len ( A ) NEW_LINE pre_sum = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT pre_sum [ i + 1 ] = pre_sum [ i ] + A [ i ] NEW_LINE DEDENT dp = [ 0 for i in range ( n ) ] NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp [ i ] = ( pre_sum [ n ] - pre_sum [ i ] ) / ( n - i ) NEW_LINE DEDENT for k in range ( K - 1 ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i ] , ( pre_sum [ j ] - pre_sum [ i ] ) / ( j - i ) + dp [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ 0 ] NEW_LINE DEDENT

BLEU: 89.1
Edit Sim: 58


Src: 
int getMinSteps ( int n ) { int table [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) table [ i ] = n - i ; for ( int i = n ; i >= 1 ; i -- ) { if ( ! ( i % 2 ) ) table [ i / 2 ] = min ( table [ i ] + 1 , table [ i / 2 ] ) ; if ( ! ( i % 3 ) ) table [ i / 3 ] = min ( table [ i ] + 1 , table [ i / 3 ] ) ; } return table [ 1 ] ;
Ref: 
def getMinSteps ( n ) : NEW_LINE INDENT table = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT table [ i ] = n - i NEW_LINE DEDENT for i in range ( n , 0 , - 1 ) : NEW_LINE INDENT if ( not ( i % 2 ) ) : NEW_LINE INDENT table [ i // 2 ] = min ( table [ i ] + 1 , table [ i // 2 ] ) NEW_LINE DEDENT if ( not ( i % 3 ) ) : NEW_LINE INDENT table [ i // 3 ] = min ( table [ i ] + 1 , table [ i // 3 ] ) NEW_LINE DEDENT DEDENT return table [ 1 ] NEW_LINE
Hyp: 
def getMinSteps ( n ) : NEW_LINE INDENT table = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT table [ i ] = n - i NEW_LINE DEDENT for i in range ( n + 1 ) : NEW_LINE INDENT if ( not ( i % 2 ) ) : NEW_LINE INDENT table [ i // 2 ] = min ( table [ i ] + 1 , table [ i // 2 ] ) NEW_LINE DEDENT if ( not ( i % 3 ) ) : NEW_LINE INDENT table [ i // 3 ] = min ( table [ i ] + 1 , table [ i // 3 ] ) NEW_LINE DEDENT DEDENT return table [ 1 ] NEW_LINE DEDENT

BLEU: 95.98
Edit Sim: 14


Src: 
int nthTerm ( int n ) { return ( n * n ) + ( n * n * n ) ; }
Ref: 
def nthTerm ( n ) : NEW_LINE INDENT return ( n * n ) + ( n * n * n ) NEW_LINE DEDENT
Hyp: 
def nthTerm ( n ) : NEW_LINE INDENT return ( n * n ) + ( n * n * n ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int findMaxAverage ( int arr [ ] , int n , int k ) { if ( k > n ) return - 1 ; int sum = arr [ 0 ] ; for ( int i = 1 ; i < k ; i ++ ) sum += arr [ i ] ; int max_sum = sum , max_end = k - 1 ; for ( int i = k ; i < n ; i ++ ) { int sum = sum + arr [ i ] - arr [ i - k ] ; if ( sum > max_sum ) { max_sum = sum ; max_end = i ; } } return max_end - k + 1 ; }
Ref: 
def findMaxAverage ( arr , n , k ) : NEW_LINE INDENT if ( k > n ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT sum = arr [ 0 ] NEW_LINE for i in range ( 1 , k ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT max_sum = sum NEW_LINE max_end = k - 1 NEW_LINE for i in range ( k , n ) : NEW_LINE INDENT sum = sum + arr [ i ] - arr [ i - k ] NEW_LINE if ( sum > max_sum ) : NEW_LINE INDENT max_sum = sum NEW_LINE max_end = i NEW_LINE DEDENT DEDENT return max_end - k + 1 NEW_LINE DEDENT
Hyp: 
def findMaxAverage ( arr , n , k ) : NEW_LINE INDENT if ( k > n ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT sum = arr [ 0 ] NEW_LINE for i in range ( 1 , k ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT max_sum = sum NEW_LINE max_end = k - 1 NEW_LINE for i in range ( k , n ) : NEW_LINE INDENT sum = sum + arr [ i ] - arr [ i - k ] NEW_LINE if ( sum > max_sum ) : NEW_LINE INDENT max_sum = sum NEW_LINE max_end = i NEW_LINE DEDENT DEDENT return max_end - k + 1 NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int eggDrop ( int n , int k ) { if ( k == 1 || k == 0 ) return k ; if ( n == 1 ) return k ; int min = INT_MAX , x , res ; for ( x = 1 ; x <= k ; x ++ ) { res = max ( eggDrop ( n - 1 , x - 1 ) , eggDrop ( n , k - x ) ) ; if ( res < min ) min = res ; } return min + 1 ; }
Ref: 
def eggDrop ( n , k ) : NEW_LINE INDENT if ( k == 1 or k == 0 ) : NEW_LINE INDENT return k NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return k NEW_LINE DEDENT min = sys . maxsize NEW_LINE for x in range ( 1 , k + 1 ) : NEW_LINE INDENT res = max ( eggDrop ( n - 1 , x - 1 ) , eggDrop ( n , k - x ) ) NEW_LINE if ( res < min ) : NEW_LINE INDENT min = res NEW_LINE DEDENT DEDENT return min + 1 NEW_LINE DEDENT
Hyp: 
def eggDrop ( n , k ) : NEW_LINE INDENT if ( k == 1 or k == 0 ) : NEW_LINE INDENT return k NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return k NEW_LINE DEDENT min = sys . maxsize NEW_LINE for x in range ( 1 , k + 1 ) : NEW_LINE INDENT res = max ( eggDrop ( n - 1 , x - 1 ) , eggDrop ( n , k - x ) ) NEW_LINE if ( res < min ) : NEW_LINE INDENT min = res NEW_LINE DEDENT DEDENT return min + 1 NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int count ( string s , char c ) { int res = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) if ( s [ i ] == c ) res ++ ; return res ; }
Ref: 
def count ( s , c ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == c ) : NEW_LINE INDENT res = res + 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
Hyp: 
def count ( s , c ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == c ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT

BLEU: 90.97
Edit Sim: 7


Src: 
int findRotations ( string str ) { string tmp = str + str ; int n = str . length ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { string substring = tmp . substr ( i , str . size ( ) ) ; if ( str == substring ) return i ; } return n ; }
Ref: 
def findRotations ( str ) : NEW_LINE INDENT tmp = str + str NEW_LINE n = len ( str ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT substring = tmp [ i : n ] NEW_LINE if ( str == substring ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return n NEW_LINE DEDENT
Hyp: 
def findRotations ( str ) : NEW_LINE INDENT tmp = str + str NEW_LINE n = len ( str ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT substring = tmp [ i : i + len ( str ) ] NEW_LINE if ( str == substring ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return n NEW_LINE DEDENT

BLEU: 88.67
Edit Sim: 14


Src: 
void randomize ( int arr [ ] , int n ) { srand ( time ( NULL ) ) ; for ( int i = n - 1 ; i > 0 ; i -- ) { int j = rand ( ) % ( i + 1 ) ; swap ( & arr [ i ] , & arr [ j ] ) ; } }
Ref: 
def randomize ( arr , n ) : NEW_LINE INDENT for i in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT j = random . randint ( 0 , i + 1 ) NEW_LINE arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ] NEW_LINE DEDENT return arr NEW_LINE DEDENT
Hyp: 
def randomize ( arr , n ) : NEW_LINE INDENT srand ( time ( NULL ) ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT j = rand ( ) % ( i + 1 ) NEW_LINE arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ] NEW_LINE DEDENT DEDENT

BLEU: 71.16
Edit Sim: 70


Src: 
int findLength ( string str , int n ) { int sum [ n + 1 ] ; sum [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum [ i ] = ( sum [ i - 1 ] + str [ i - 1 ] - '0' ) ; int ans = 0 ; for ( int len = 2 ; len <= n ; len += 2 ) { for ( int i = 0 ; i <= n - len ; i ++ ) { int j = i + len - 1 ; if ( sum [ i + len / 2 ] - sum [ i ] == sum [ i + len ] - sum [ i + len / 2 ] ) ans = max ( ans , len ) ; } } return ans ; }
Ref: 
def findLength ( string , n ) : NEW_LINE INDENT Sum = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT Sum [ i ] = ( Sum [ i - 1 ] + int ( string [ i - 1 ] ) ) NEW_LINE DEDENT ans = 0 NEW_LINE for length in range ( 2 , n + 1 , 2 ) : NEW_LINE INDENT for i in range ( 0 , n - length + 1 ) : NEW_LINE INDENT j = i + length - 1 NEW_LINE if ( Sum [ i + length // 2 ] - Sum [ i ] == Sum [ i + length ] - Sum [ i + length // 2 ] ) : NEW_LINE INDENT ans = max ( ans , length ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
Hyp: 
def findLength ( str , n ) : NEW_LINE INDENT sum = [ 0 for i in range ( n + 1 ) ] NEW_LINE sum [ 0 ] = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum [ i ] = ( sum [ i - 1 ] + str [ i - 1 ] - '0' ) NEW_LINE DEDENT ans = 0 NEW_LINE for l in range ( 2 , n + 2 ) : NEW_LINE INDENT for i in range ( 0 , n - l + 1 ) : NEW_LINE INDENT j = i + len - 1 NEW_LINE if ( sum [ i + len // 2 ] - sum [ i ] == sum [ i + len ] - sum [ i + len // 2 ] ) : NEW_LINE INDENT ans = max ( ans , l ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT

BLEU: 62.0
Edit Sim: 93


Src: 
void translate ( char * str ) { int len = strlen ( str ) ; if ( len < 2 ) return ; int i = 0 ; int j = 0 ; while ( j < len - 1 ) { if ( str [ j ] == ' A ' && str [ j + 1 ] == ' B ' ) { j = j + 2 ; str [ i ++ ] = ' C ' ; continue ; } str [ i ++ ] = str [ j ++ ] ; } if ( j == len - 1 ) str [ i ++ ] = str [ j ] ; str [ i ] = '' ; }
Ref: 
def translate ( st ) : NEW_LINE INDENT l = len ( st ) NEW_LINE if ( l < 2 ) : NEW_LINE INDENT return NEW_LINE DEDENT i = 0 NEW_LINE j = 0 NEW_LINE while ( j < l - 1 ) : NEW_LINE INDENT if ( st [ j ] == ' A ' and st [ j + 1 ] == ' B ' ) : NEW_LINE INDENT j += 2 NEW_LINE st [ i ] = ' C ' NEW_LINE i += 1 NEW_LINE continue NEW_LINE DEDENT st [ i ] = st [ j ] NEW_LINE i += 1 NEW_LINE j += 1 NEW_LINE DEDENT if ( j == l - 1 ) : NEW_LINE INDENT st [ i ] = st [ j ] NEW_LINE i += 1 NEW_LINE DEDENT st [ i ] = ' ▁ ' NEW_LINE st [ l - 1 ] = ' ▁ ' NEW_LINE DEDENT
Hyp: 
def translate ( st ) : NEW_LINE INDENT l = len ( st ) NEW_LINE if ( l < 2 ) : NEW_LINE INDENT return NEW_LINE DEDENT i = 0 NEW_LINE j = 0 NEW_LINE while ( j < l - 1 ) : NEW_LINE INDENT if ( st [ j ] == ' A ' and st [ j + 1 ] == ' B ' ) : NEW_LINE INDENT j = j + 2 NEW_LINE str [ i ] = ' C ' NEW_LINE continue NEW_LINE DEDENT str [ i ] = st [ j ] NEW_LINE j += 1 NEW_LINE DEDENT if ( j == l - 1 ) : NEW_LINE INDENT st [ i ] = st [ j ] NEW_LINE DEDENT st [ i ] = ' ' NEW_LINE DEDENT

BLEU: 76.75
Edit Sim: 87


Src: 
int maximumNumberDistinctPrimeRange ( int m , int n ) { long long factorCount [ n + 1 ] ; bool prime [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { factorCount [ i ] = 0 ; prime [ i ] = true ; } for ( int i = 2 ; i <= n ; i ++ ) { if ( prime [ i ] == true ) { factorCount [ i ] = 1 ; for ( int j = i * 2 ; j <= n ; j += i ) { factorCount [ j ] ++ ; prime [ j ] = false ; } } } int max = factorCount [ m ] ; int num = m ; for ( int i = m ; i <= n ; i ++ ) { if ( factorCount [ i ] > max ) { max = factorCount [ i ] ; num = i ; } } return num ; }
Ref: 
def maximumNumberDistinctPrimeRange ( m , n ) : NEW_LINE INDENT factorCount = [ 0 ] * ( n + 1 ) NEW_LINE prime = [ False ] * ( n + 1 ) NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT factorCount [ i ] = 0 NEW_LINE prime [ i ] = True NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ i ] == True ) : NEW_LINE INDENT factorCount [ i ] = 1 NEW_LINE for j in range ( i * 2 , n + 1 , i ) : NEW_LINE INDENT factorCount [ j ] += 1 NEW_LINE prime [ j ] = False NEW_LINE DEDENT DEDENT DEDENT max = factorCount [ m ] NEW_LINE num = m NEW_LINE for i in range ( m , n + 1 ) : NEW_LINE INDENT if ( factorCount [ i ] > max ) : NEW_LINE INDENT max = factorCount [ i ] NEW_LINE num = i NEW_LINE DEDENT DEDENT return num NEW_LINE DEDENT
Hyp: 
def maximumNumberDistinctPrimeRange ( m , n ) : NEW_LINE INDENT factorCount = [ 0 ] * ( n + 1 ) NEW_LINE prime = [ False ] * ( n + 1 ) NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT factorCount [ i ] = 0 NEW_LINE prime [ i ] = True NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if prime [ i ] == True : NEW_LINE INDENT factorCount [ i ] = 1 NEW_LINE for j in range ( i * 2 , n + 1 , i ) : NEW_LINE INDENT factorCount [ j ] += 1 NEW_LINE prime [ j ] = False NEW_LINE DEDENT DEDENT DEDENT max = factorCount [ m ] NEW_LINE num = m NEW_LINE for i in range ( m , n + 1 ) : NEW_LINE INDENT if factorCount [ i ] > max : NEW_LINE INDENT max = factorCount [ i ] NEW_LINE num = i NEW_LINE DEDENT DEDENT return num NEW_LINE DEDENT

BLEU: 94.46
Edit Sim: 8


Src: 
unsigned long int catalan ( unsigned int n ) { if ( n <= 1 ) return 1 ; unsigned long int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) res += catalan ( i ) * catalan ( n - i - 1 ) ; return res ; }
Ref: 
def catalan ( n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT res += catalan ( i ) * catalan ( n - i - 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT
Hyp: 
def catalan ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT res = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT res += catalan ( i ) * catalan ( n - i - 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT

BLEU: 85.29
Edit Sim: 8


Src: 
int sumOfSeries ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum = sum + ( 2 * i - 1 ) * ( 2 * i - 1 ) ; return sum ; }
Ref: 
def sumOfSeries ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum = sum + ( 2 * i - 1 ) * ( 2 * i - 1 ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
Hyp: 
def sumOfSeries ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum = sum + ( 2 * i - 1 ) * ( 2 * i - 1 ) NEW_LINE DEDENT return sum NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int minRevolutions ( double r , int x1 , int y1 , int x2 , int y2 ) { double d = sqrt ( ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ) ; return ceil ( d / ( 2 * r ) ) ; }
Ref: 
def minRevolutions ( r , x1 , y1 , x2 , y2 ) : NEW_LINE INDENT d = math . sqrt ( ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ) NEW_LINE return math . ceil ( d // ( 2 * r ) ) NEW_LINE DEDENT
Hyp: 
def minRevolutions ( r , x1 , y1 , x2 , y2 ) : NEW_LINE INDENT d = ( math . sqrt ( ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ) NEW_LINE return math . ceil ( d / ( 2 * r ) ) NEW_LINE DEDENT

BLEU: 91.86
Edit Sim: 3


Src: 
void printString ( string str , char ch , int count ) { int occ = 0 , i ; if ( count == 0 ) { cout << str ; return ; } for ( i = 0 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] == ch ) occ ++ ; if ( occ == count ) break ; } if ( i < str . length ( ) - 1 ) cout << str . substr ( i + 1 , str . length ( ) - ( i + 1 ) ) ; else cout << " Empty ▁ string " ; }
Ref: 
def printString ( str , ch , count ) : NEW_LINE INDENT occ , i = 0 , 0 NEW_LINE if ( count == 0 ) : NEW_LINE INDENT print ( str ) NEW_LINE DEDENT for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] == ch ) : NEW_LINE INDENT occ += 1 NEW_LINE DEDENT if ( occ == count ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( i < len ( str ) - 1 ) : NEW_LINE INDENT print ( str [ i + 1 : len ( str ) - i + 2 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Empty ▁ string " ) NEW_LINE DEDENT DEDENT
Hyp: 
def printString ( str , ch , count ) : NEW_LINE INDENT occ = 0 NEW_LINE i = 0 NEW_LINE while i < ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] == ch ) : NEW_LINE INDENT occ = occ + 1 NEW_LINE DEDENT if ( occ == count ) : NEW_LINE INDENT break NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT if ( i < len ( str ) - 1 ) : NEW_LINE INDENT print ( str [ i + 1 : ] , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Empty ▁ string " ) NEW_LINE DEDENT DEDENT

BLEU: 69.64
Edit Sim: 111


Src: 
int largestKSubmatrix ( int a [ ] [ Col ] ) { int dp [ Row ] [ Col ] ; memset ( dp , sizeof ( dp ) , 0 ) ; int result = 0 ; for ( int i = 0 ; i < Row ; i ++ ) { for ( int j = 0 ; j < Col ; j ++ ) { if ( i == 0 || j == 0 ) dp [ i ] [ j ] = 1 ; else { if ( a [ i ] [ j ] == a [ i - 1 ] [ j ] && a [ i ] [ j ] == a [ i ] [ j - 1 ] && a [ i ] [ j ] == a [ i - 1 ] [ j - 1 ] ) dp [ i ] [ j ] = min ( min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) , dp [ i - 1 ] [ j - 1 ] ) + 1 ; else dp [ i ] [ j ] = 1 ; } result = max ( result , dp [ i ] [ j ] ) ; } } return result ; }
Ref: 
def largestKSubmatrix ( a ) : NEW_LINE INDENT dp = [ [ 0 for x in range ( Row ) ] for y in range ( Col ) ] NEW_LINE result = 0 NEW_LINE for i in range ( Row ) : NEW_LINE INDENT for j in range ( Col ) : NEW_LINE INDENT if ( i == 0 or j == 0 ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( a [ i ] [ j ] == a [ i - 1 ] [ j ] and a [ i ] [ j ] == a [ i ] [ j - 1 ] and a [ i ] [ j ] == a [ i - 1 ] [ j - 1 ] ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) , dp [ i - 1 ] [ j - 1 ] ) + 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = 1 NEW_LINE DEDENT DEDENT result = max ( result , dp [ i ] [ j ] ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
Hyp: 
def largestKSubmatrix ( a ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( Col ) ] for j in range ( Row ) ] NEW_LINE result = 0 NEW_LINE for i in range ( Row ) : NEW_LINE INDENT for j in range ( Col ) : NEW_LINE INDENT if ( i == 0 | j == 0 ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( a [ i ] [ j ] == a [ i - 1 ] [ j ] and a [ i ] [ j ] == a [ i ] [ j - 1 ] and a [ i ] [ j ] == a [ i - 1 ] [ j - 1 ] ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) , dp [ i - 1 ] [ j - 1 ] ) + 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = 1 NEW_LINE DEDENT DEDENT result = max ( result , dp [ i ] [ j ] ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT

BLEU: 96.47
Edit Sim: 8


Src: 
void printPascal ( int n ) { int arr [ n ] [ n ] ; for ( int line = 0 ; line < n ; line ++ ) { for ( int i = 0 ; i <= line ; i ++ ) { if ( line == i || i == 0 ) arr [ line ] [ i ] = 1 ; else arr [ line ] [ i ] = arr [ line - 1 ] [ i - 1 ] + arr [ line - 1 ] [ i ] ; cout << arr [ line ] [ i ] << " ▁ " ; } cout << " \n " ; } }
Ref: 
def printPascal ( n : int ) : NEW_LINE INDENT arr = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] NEW_LINE for line in range ( 0 , n ) : NEW_LINE INDENT for i in range ( 0 , line + 1 ) : NEW_LINE INDENT if ( i is 0 or i is line ) : NEW_LINE INDENT arr [ line ] [ i ] = 1 NEW_LINE print ( arr [ line ] [ i ] , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT arr [ line ] [ i ] = ( arr [ line - 1 ] [ i - 1 ] + arr [ line - 1 ] [ i ] ) NEW_LINE print ( arr [ line ] [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT print ( " \n " , end = " " ) NEW_LINE DEDENT DEDENT
Hyp: 
def printPascal ( n ) : NEW_LINE INDENT arr = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] NEW_LINE for line in range ( n ) : NEW_LINE INDENT for i in range ( line + 1 ) : NEW_LINE INDENT if ( line == i or i == 0 ) : NEW_LINE INDENT arr [ line ] [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ line ] [ i ] = arr [ line - 1 ] [ i - 1 ] + arr [ line - 1 ] [ i ] NEW_LINE DEDENT print ( arr [ line ] [ i ] , end = " ▁ " ) NEW_LINE DEDENT print ( " " ) NEW_LINE DEDENT DEDENT

BLEU: 65.72
Edit Sim: 113


Src: 
int answer_query ( int a [ ] , int n , int l , int r ) { int count = 0 ; for ( int i = l ; i < r ; i ++ ) if ( a [ i ] == a [ i + 1 ] ) count += 1 ; return count ; }
Ref: 
def answer_query ( a , n , l , r ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( l , r ) : NEW_LINE INDENT if ( a [ i ] == a [ i + 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
Hyp: 
def answer_query ( a , n , l , r ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( l , r , 1 ) : NEW_LINE INDENT if ( a [ i ] == a [ i + 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT

BLEU: 93.96
Edit Sim: 4


Src: 
int cassini ( int n ) { return ( n & 1 ) ? - 1 : 1 ; }
Ref: 
def cassini ( n ) : NEW_LINE INDENT return - 1 if ( n & 1 ) else 1 NEW_LINE DEDENT
Hyp: 
def cassini ( n ) : NEW_LINE INDENT return - 1 if ( n & 1 ) else 1 NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int compute_average ( int a , int b ) { return ( a + b ) / 2 ; }
Ref: 
def compute_average ( a , b ) : NEW_LINE INDENT return floor ( ( a + b ) / 2 ) NEW_LINE DEDENT
Hyp: 
def compute_average ( a , b ) : NEW_LINE INDENT return ( a + b ) / 2 NEW_LINE DEDENT

BLEU: 72.85
Edit Sim: 10


Src: 
int waysToArrange ( int N , int K , int k [ ] ) { int C [ N + 1 ] [ N + 1 ] ; int i , j ; for ( i = 0 ; i <= N ; i ++ ) { for ( j = 0 ; j <= i ; j ++ ) { if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) ; } } int dp [ K ] ; int count = 0 ; dp [ 0 ] = 1 ; for ( int i = 0 ; i < K ; i ++ ) { dp [ i + 1 ] = ( dp [ i ] * C [ count + k [ i ] - 1 ] [ k [ i ] - 1 ] ) ; count += k [ i ] ; } return dp [ K ] ; }
Ref: 
def waysToArrange ( N , K , k ) : NEW_LINE INDENT C = np . zeros ( ( N + 1 , N + 1 ) ) NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT for j in range ( i + 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT dp = np . zeros ( ( K + 1 ) ) NEW_LINE count = 0 NEW_LINE dp [ 0 ] = 1 NEW_LINE for i in range ( K ) : NEW_LINE INDENT dp [ i + 1 ] = ( dp [ i ] * C [ count + k [ i ] - 1 ] [ k [ i ] - 1 ] ) NEW_LINE count += k [ i ] NEW_LINE DEDENT return dp [ K ] NEW_LINE DEDENT
Hyp: 
def waysToArrange ( N , K , k ) : NEW_LINE INDENT C = [ [ 0 for i in range ( N + 1 ) ] for j in range ( N + 1 ) ] NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT for j in range ( i + 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT dp = [ 0 for i in range ( K ) ] NEW_LINE count = 0 NEW_LINE for i in range ( K ) : NEW_LINE INDENT dp [ i + 1 ] = ( dp [ i ] * C [ count + k [ i ] - 1 ] [ k [ i ] - 1 ] ) NEW_LINE count += k [ i ] NEW_LINE DEDENT return dp [ K ] NEW_LINE DEDENT

BLEU: 85.54
Edit Sim: 76


Src: 
void findDimen ( int H , int A ) { if ( H * H < 4 * A ) { cout << " Not ▁ Possible \n " ; return ; } double apb = sqrt ( H * H + 4 * A ) ; double asb = sqrt ( H * H - 4 * A ) ; cout . precision ( 2 ) ; cout << " P ▁ = ▁ " << fixed << ( apb - asb ) / 2.0 << " \n " ; cout << " B ▁ = ▁ " << ( apb + asb ) / 2.0 ; }
Ref: 
def findDimen ( H , A ) : NEW_LINE INDENT if H * H < 4 * A : NEW_LINE INDENT print ( " Not ▁ Possible " ) NEW_LINE return NEW_LINE DEDENT apb = sqrt ( H * H + 4 * A ) NEW_LINE asb = sqrt ( H * H - 4 * A ) NEW_LINE print ( " P ▁ = ▁ " , " % .2f " % ( ( apb - asb ) / 2.0 ) ) NEW_LINE print ( " B ▁ = ▁ " , " % .2f " % ( ( apb + asb ) / 2.0 ) ) NEW_LINE DEDENT
Hyp: 
def findDimen ( H , A ) : NEW_LINE INDENT if ( H * H < 4 * A ) : NEW_LINE INDENT print ( " Not ▁ Possible " ) NEW_LINE return NEW_LINE DEDENT apb = math . sqrt ( H * H + 4 * A ) NEW_LINE asb = math . sqrt ( H * H - 4 * A ) NEW_LINE print ( " P ▁ = ▁ " , fixed , ( apb - asb ) / 2.0 , " \n " ) NEW_LINE print ( " B ▁ = ▁ " , ( apb + asb ) / 2.0 ) NEW_LINE DEDENT

BLEU: 77.41
Edit Sim: 53


Src: 
int maxTripletSum ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; return arr [ n - 1 ] + arr [ n - 2 ] + arr [ n - 3 ] ; }
Ref: 
def maxTripletSum ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE return ( arr [ n - 1 ] + arr [ n - 2 ] + arr [ n - 3 ] ) NEW_LINE DEDENT
Hyp: 
def maxTripletSum ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE return arr [ n - 1 ] + arr [ n - 2 ] + arr [ n - 3 ] NEW_LINE DEDENT

BLEU: 87.94
Edit Sim: 4


Src: 
long long int MaxDotProduct ( int A [ ] , int B [ ] , int m , int n ) { long long int dp [ n + 1 ] [ m + 1 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = i ; j <= m ; j ++ ) dp [ i ] [ j ] = max ( ( dp [ i - 1 ] [ j - 1 ] + ( A [ j - 1 ] * B [ i - 1 ] ) ) , dp [ i ] [ j - 1 ] ) ; return dp [ n ] [ m ] ; }
Ref: 
def MaxDotProduct ( A , B , m , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( m + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 , 1 ) : NEW_LINE INDENT for j in range ( i , m + 1 , 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( ( dp [ i - 1 ] [ j - 1 ] + ( A [ j - 1 ] * B [ i - 1 ] ) ) , dp [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT return dp [ n ] [ m ] NEW_LINE DEDENT
Hyp: 
def MaxDotProduct ( A , B , m , n ) : NEW_LINE INDENT dp = [ [ 0 for x in range ( m + 1 ) ] for y in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( i , m + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( ( dp [ i - 1 ] [ j - 1 ] + ( A [ j - 1 ] * B [ i - 1 ] ) ) , dp [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT return dp [ n ] [ m ] NEW_LINE DEDENT

BLEU: 92.09
Edit Sim: 10


Src: 
int findMinDiff ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int diff = INT_MAX ; for ( int i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i + 1 ] - arr [ i ] < diff ) diff = arr [ i + 1 ] - arr [ i ] ; return diff ; }
Ref: 
def findMinDiff ( arr , n ) : NEW_LINE INDENT arr = sorted ( arr ) NEW_LINE diff = 10 ** 20 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if arr [ i + 1 ] - arr [ i ] < diff : NEW_LINE INDENT diff = arr [ i + 1 ] - arr [ i ] NEW_LINE DEDENT DEDENT return diff NEW_LINE DEDENT
Hyp: 
def findMinDiff ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE diff = sys . maxsize NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( arr [ i + 1 ] - arr [ i ] < diff ) : NEW_LINE INDENT diff = arr [ i + 1 ] - arr [ i ] NEW_LINE DEDENT DEDENT return diff NEW_LINE DEDENT

BLEU: 80.96
Edit Sim: 23


Src: 
int findLastIndex ( string & str , char x ) { for ( int i = str . length ( ) - 1 ; i >= 0 ; i -- ) if ( str [ i ] == x ) return i ; return - 1 ; }
Ref: 
def findLastIndex ( str , x ) : NEW_LINE INDENT for i in range ( len ( str ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( str [ i ] == x ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
Hyp: 
def findLastIndex ( str , x ) : NEW_LINE INDENT for i in range ( len ( str ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( str [ i ] == x ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int maxLower ( string str ) { int n = str . length ( ) ; int i = 0 ; for ( ; i < n ; i ++ ) { if ( str [ i ] >= ' A ' && str [ i ] <= ' Z ' ) { i ++ ; break ; } } int maxCount = 0 ; int count [ MAX_CHAR ] = { 0 } ; for ( ; i < n ; i ++ ) { if ( str [ i ] >= ' A ' && str [ i ] <= ' Z ' ) { int currCount = 0 ; for ( int j = 0 ; j < MAX_CHAR ; j ++ ) if ( count [ j ] > 0 ) currCount ++ ; maxCount = max ( maxCount , currCount ) ; memset ( count , 0 , sizeof ( count ) ) ; } if ( str [ i ] >= ' a ' && str [ i ] <= ' z ' ) count [ str [ i ] - ' a ' ] ++ ; } return maxCount ; }
Ref: 
def maxLower ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE i = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if str [ i ] >= ' A ' and str [ i ] <= ' Z ' : NEW_LINE INDENT i += 1 NEW_LINE break NEW_LINE DEDENT DEDENT maxCount = 0 NEW_LINE count = [ ] NEW_LINE for j in range ( MAX_CHAR ) : NEW_LINE INDENT count . append ( 0 ) NEW_LINE DEDENT for j in range ( i , n ) : NEW_LINE INDENT if str [ j ] >= ' A ' and str [ j ] <= ' Z ' : NEW_LINE INDENT currCount = 0 NEW_LINE for k in range ( MAX_CHAR ) : NEW_LINE INDENT if count [ k ] > 0 : NEW_LINE INDENT currCount += 1 NEW_LINE DEDENT DEDENT maxCount = max ( maxCount , currCount ) NEW_LINE for y in count : NEW_LINE INDENT y = 0 NEW_LINE DEDENT DEDENT if str [ j ] >= ' a ' and str [ j ] <= ' z ' : NEW_LINE INDENT count [ ord ( str [ j ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT DEDENT return maxCount NEW_LINE DEDENT
Hyp: 
def maxLower ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT if ( str [ i ] >= ' A ' and str [ i ] <= ' Z ' ) : NEW_LINE INDENT i += 1 NEW_LINE break NEW_LINE DEDENT DEDENT maxCount = 0 NEW_LINE count = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( str [ i ] >= ' A ' and str [ i ] <= ' Z ' ) : NEW_LINE INDENT currCount = 0 NEW_LINE for j in range ( MAX_CHAR ) : NEW_LINE INDENT if ( count [ j ] > 0 ) : NEW_LINE INDENT currCount += 1 NEW_LINE DEDENT DEDENT maxCount = max ( maxCount , currCount ) NEW_LINE memset ( count , 0 , sizeof ( count ) ) NEW_LINE DEDENT if ( str [ i ] >= ' a ' and str [ i ] <= ' z ' ) : NEW_LINE INDENT count [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT DEDENT return maxCount NEW_LINE DEDENT

BLEU: 69.78
Edit Sim: 151


Src: 
void findElements ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) if ( arr [ j ] > arr [ i ] ) count ++ ; if ( count >= 2 ) cout << arr [ i ] << " ▁ " ; } }
Ref: 
def findElements ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT if arr [ j ] > arr [ i ] : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT if count >= 2 : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
Hyp: 
def findElements ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( arr [ j ] > arr [ i ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( count >= 2 ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT

BLEU: 82.04
Edit Sim: 21


Src: 
string evenlength ( string n ) { string res = n ; for ( int j = n . length ( ) - 1 ; j >= 0 ; -- j ) res += n [ j ] ; return res ; }
Ref: 
def evenlength ( n ) : NEW_LINE INDENT res = n NEW_LINE for j in range ( len ( n ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT res += n [ j ] NEW_LINE DEDENT return res NEW_LINE DEDENT
Hyp: 
def evenlength ( n ) : NEW_LINE INDENT res = n NEW_LINE j = len ( n ) - 1 NEW_LINE while ( j >= 0 ) : NEW_LINE INDENT res += n [ j ] NEW_LINE j -= 1 NEW_LINE DEDENT return res NEW_LINE DEDENT

BLEU: 66.1
Edit Sim: 48


Src: 
int maxLen ( int arr [ ] , int n ) { unordered_map < int , int > hM ; int sum = 0 ; int max_len = 0 ; int ending_index = - 1 ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = ( arr [ i ] == 0 ) ? - 1 : 1 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( sum == 0 ) { max_len = i + 1 ; ending_index = i ; } if ( hM . find ( sum + n ) != hM . end ( ) ) { if ( max_len < i - hM [ sum + n ] ) { max_len = i - hM [ sum + n ] ; ending_index = i ; } } else hM [ sum + n ] = i ; } for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = ( arr [ i ] == - 1 ) ? 0 : 1 ; printf ( " % d ▁ to ▁ % d \n " , ending_index - max_len + 1 , ending_index ) ; return max_len ; }
Ref: 
def maxLen ( arr , n ) : NEW_LINE INDENT hash_map = { } NEW_LINE curr_sum = 0 NEW_LINE max_len = 0 NEW_LINE ending_index = - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] == 0 ) : NEW_LINE INDENT arr [ i ] = - 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = 1 NEW_LINE DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT curr_sum = curr_sum + arr [ i ] NEW_LINE if ( curr_sum == 0 ) : NEW_LINE INDENT max_len = i + 1 NEW_LINE ending_index = i NEW_LINE DEDENT if ( curr_sum + n ) in hash_map : NEW_LINE INDENT max_len = max ( max_len , i - hash_map [ curr_sum + n ] ) NEW_LINE DEDENT else : NEW_LINE INDENT hash_map [ curr_sum ] = i NEW_LINE DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] == - 1 ) : NEW_LINE INDENT arr [ i ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = 1 NEW_LINE DEDENT DEDENT print ( ending_index - max_len + 1 , end = " ▁ " ) NEW_LINE print ( " to " , end = " ▁ " ) NEW_LINE print ( ending_index ) NEW_LINE return max_len NEW_LINE DEDENT
Hyp: 
def maxLen ( arr , n ) : NEW_LINE INDENT hM = dict ( ) NEW_LINE Sum = 0 NEW_LINE max_len = 0 NEW_LINE ending_index = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT Sum += arr [ i ] NEW_LINE if Sum == 0 : NEW_LINE INDENT max_len = i + 1 NEW_LINE ending_index = i NEW_LINE DEDENT if Sum in hM . keys ( ) : NEW_LINE INDENT if max_len < i - hM [ Sum + n ] : NEW_LINE INDENT max_len = i - hM [ Sum + n ] NEW_LINE ending_index = i NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT hM [ Sum + n ] = i NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = - 1 NEW_LINE if arr [ i ] == - 1 : NEW_LINE INDENT arr [ i ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT hM [ Sum + n ] = i NEW_LINE DEDENT DEDENT print ( " % d ▁ to ▁ % d " , ending_index - max_len + 1 , ending_index ) NEW_LINE return max_len NEW_LINE DEDENT

BLEU: 49.37
Edit Sim: 406


Src: 
int possibleStrings ( int n , int r , int b , int g ) { int fact [ n + 1 ] ; fact [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) fact [ i ] = fact [ i - 1 ] * i ; int left = n - ( r + g + b ) ; int sum = 0 ; for ( int i = 0 ; i <= left ; i ++ ) { for ( int j = 0 ; j <= left - i ; j ++ ) { int k = left - ( i + j ) ; sum = sum + fact [ n ] / ( fact [ i + r ] * fact [ j + b ] * fact [ k + g ] ) ; } } return sum ; }
Ref: 
def possibleStrings ( n , r , b , g ) : NEW_LINE INDENT fact = [ 0 for i in range ( n + 1 ) ] NEW_LINE fact [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 , 1 ) : NEW_LINE INDENT fact [ i ] = fact [ i - 1 ] * i NEW_LINE DEDENT left = n - ( r + g + b ) NEW_LINE sum = 0 NEW_LINE for i in range ( 0 , left + 1 , 1 ) : NEW_LINE INDENT for j in range ( 0 , left - i + 1 , 1 ) : NEW_LINE INDENT k = left - ( i + j ) NEW_LINE sum = ( sum + fact [ n ] / ( fact [ i + r ] * fact [ j + b ] * fact [ k + g ] ) ) NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
Hyp: 
def possibleStrings ( n , r , b , g ) : NEW_LINE INDENT fact = [ 0 for i in range ( n + 1 ) ] NEW_LINE fact [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT fact [ i ] = fact [ i - 1 ] * i NEW_LINE DEDENT left = n - ( r + g + b ) NEW_LINE sum = 0 NEW_LINE for i in range ( left + 1 ) : NEW_LINE INDENT for j in range ( left - i + 1 ) : NEW_LINE INDENT k = left - ( i + j ) NEW_LINE sum = sum + fact [ n ] / ( fact [ i + r ] * fact [ j + b ] * fact [ k + g ] ) NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT

BLEU: 87.94
Edit Sim: 24


Src: 
int numberofways ( string A , string B , int N , int M ) { vector < int > pos [ MAX ] ; for ( int i = 0 ; i < M ; i ++ ) pos [ B [ i ] ] . push_back ( i + 1 ) ; int dpl [ N + 2 ] [ M + 2 ] ; memset ( dpl , 0 , sizeof ( dpl ) ) ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 1 ; j <= M ; j ++ ) { if ( A [ i - 1 ] == B [ j - 1 ] ) dpl [ i ] [ j ] = dpl [ i - 1 ] [ j - 1 ] + 1 ; else dpl [ i ] [ j ] = max ( dpl [ i - 1 ] [ j ] , dpl [ i ] [ j - 1 ] ) ; } } int LCS = dpl [ N ] [ M ] ; int dpr [ N + 2 ] [ M + 2 ] ; memset ( dpr , 0 , sizeof ( dpr ) ) ; for ( int i = N ; i >= 1 ; i -- ) { for ( int j = M ; j >= 1 ; j -- ) { if ( A [ i - 1 ] == B [ j - 1 ] ) dpr [ i ] [ j ] = dpr [ i + 1 ] [ j + 1 ] + 1 ; else dpr [ i ] [ j ] = max ( dpr [ i + 1 ] [ j ] , dpr [ i ] [ j + 1 ] ) ; } } int ans = 0 ; for ( int i = 0 ; i <= N ; i ++ ) { for ( int j = 0 ; j < MAX ; j ++ ) { for ( auto x : pos [ j ] ) { if ( dpl [ i ] [ x - 1 ] + dpr [ i + 1 ] [ x + 1 ] == LCS ) { ans ++ ; break ; } } } } return ans ; }
Ref: 
def numberofways ( A , B , N , M ) : NEW_LINE INDENT pos = [ [ ] for _ in range ( MAX ) ] NEW_LINE for i in range ( M ) : NEW_LINE INDENT pos [ ord ( B [ i ] ) ] . append ( i + 1 ) NEW_LINE DEDENT dpl = [ [ 0 ] * ( M + 2 ) for _ in range ( N + 2 ) ] NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( 1 , M + 1 ) : NEW_LINE INDENT if A [ i - 1 ] == B [ j - 1 ] : NEW_LINE INDENT dpl [ i ] [ j ] = dpl [ i - 1 ] [ j - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT dpl [ i ] [ j ] = max ( dpl [ i - 1 ] [ j ] , dpl [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT LCS = dpl [ N ] [ M ] NEW_LINE dpr = [ [ 0 ] * ( M + 2 ) for _ in range ( N + 2 ) ] NEW_LINE for i in range ( N , 0 , - 1 ) : NEW_LINE INDENT for j in range ( M , 0 , - 1 ) : NEW_LINE INDENT if A [ i - 1 ] == B [ j - 1 ] : NEW_LINE INDENT dpr [ i ] [ j ] = dpr [ i + 1 ] [ j + 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT dpr [ i ] [ j ] = max ( dpr [ i + 1 ] [ j ] , dpr [ i ] [ j + 1 ] ) NEW_LINE DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT for j in range ( MAX ) : NEW_LINE INDENT for x in pos [ j ] : NEW_LINE INDENT if dpl [ i ] [ x - 1 ] + dpr [ i + 1 ] [ x + 1 ] == LCS : NEW_LINE INDENT ans += 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
Hyp: 
def numberofways ( A , B , N , M ) : NEW_LINE INDENT pos = [ ] NEW_LINE for i in range ( M ) : NEW_LINE INDENT pos [ B [ i ] ] . append ( i + 1 ) NEW_LINE DEDENT dpl = [ [ 0 for i in range ( M + 2 ) ] for j in range ( N + 2 ) ] NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( 1 , M + 1 ) : NEW_LINE INDENT if ( A [ i - 1 ] == B [ j - 1 ] ) : NEW_LINE INDENT dpl [ i ] [ j ] = dpl [ i - 1 ] [ j - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT dpl [ i ] [ j ] = max ( dpl [ i - 1 ] [ j ] , dpl [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT LCS = dpl [ N ] [ M ] NEW_LINE dpr = [ dpr [ N + 2 ] [ M + 2 ] NEW_LINE for i in range ( N , 1 , - 1 ) : NEW_LINE INDENT for j in range ( M , 1 , - 1 ) : NEW_LINE INDENT if ( A [ i - 1 ] == B [ j - 1 ] ) : NEW_LINE INDENT dpr [ i ] [ j ] = dpr [ i + 1 ] [ j + 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT dpr [ i ] [ j ] = max ( dpr [ i + 1 ] [ j ] , dpr [ i ] [ j + 1 ] ) NEW_LINE DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT for j in range ( MAX ) : NEW_LINE INDENT for x in pos : NEW_LINE INDENT for l in range ( MAX ) : NEW_LINE INDENT if ( dpl [ i ] [ x - 1 ] + dpr [ i + 1 ] [ x + 1 ] == LCS ) : NEW_LINE INDENT ans += 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT

BLEU: 87.67
Edit Sim: 132


Src: 
double circumference ( double r ) { double cir = 2 * PI * r ; return cir ; }
Ref: 
def circumference ( r ) : NEW_LINE INDENT return ( 2 * PI * r ) NEW_LINE DEDENT
Hyp: 
def circumference ( r ) : NEW_LINE INDENT cir = 2 * PI * r NEW_LINE return cir NEW_LINE DEDENT

BLEU: 59.23
Edit Sim: 25


Src: 
int substringConversions ( string str , int k , int b ) { for ( int i = 0 ; i + k <= str . size ( ) ; i ++ ) { string sub = str . substr ( i , k ) ; int sum = 0 , counter = 0 ; for ( int i = sub . size ( ) - 1 ; i >= 0 ; i -- ) { sum = sum + ( ( sub . at ( i ) - '0' ) * pow ( b , counter ) ) ; counter ++ ; } cout << sum << " ▁ " ; } }
Ref: 
def substringConversions ( s , k , b ) : NEW_LINE INDENT l = len ( s ) NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( ( i + k ) < l + 1 ) : NEW_LINE INDENT sub = s [ i : i + k ] NEW_LINE sum , counter = 0 , 0 NEW_LINE for i in range ( len ( sub ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT sum = sum + ( ( ord ( sub [ i ] ) - ord ( '0' ) ) * pow ( b , counter ) ) NEW_LINE counter += 1 NEW_LINE DEDENT print ( sum , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
Hyp: 
def substringConversions ( str , k , b ) : NEW_LINE INDENT for i in range ( 0 , len ( str ) , k ) : NEW_LINE INDENT sub = str [ i : i + k ] NEW_LINE sum = 0 NEW_LINE counter = 0 NEW_LINE for i in range ( len ( sub ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT sum = sum + ( int ) ( ( sub [ i ] ) - ord ( '0' ) ) * pow ( b , counter ) ) NEW_LINE counter = counter + 1 NEW_LINE DEDENT print ( sum , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT

BLEU: 65.43
Edit Sim: 104


Src: 
int maxPathSum ( int tri [ ] [ N ] , int m , int n ) { for ( int i = m - 1 ; i >= 0 ; i -- ) { for ( int j = 0 ; j <= i ; j ++ ) { if ( tri [ i + 1 ] [ j ] > tri [ i + 1 ] [ j + 1 ] ) tri [ i ] [ j ] += tri [ i + 1 ] [ j ] ; else tri [ i ] [ j ] += tri [ i + 1 ] [ j + 1 ] ; } } return tri [ 0 ] [ 0 ] ; }
Ref: 
def maxPathSum ( tri , m , n ) : NEW_LINE INDENT for i in range ( m - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( i + 1 ) : NEW_LINE INDENT if ( tri [ i + 1 ] [ j ] > tri [ i + 1 ] [ j + 1 ] ) : NEW_LINE INDENT tri [ i ] [ j ] += tri [ i + 1 ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT tri [ i ] [ j ] += tri [ i + 1 ] [ j + 1 ] NEW_LINE DEDENT DEDENT DEDENT return tri [ 0 ] [ 0 ] NEW_LINE DEDENT
Hyp: 
def maxPathSum ( tri , m , n ) : NEW_LINE INDENT for i in range ( m - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( i + 1 ) : NEW_LINE INDENT if ( tri [ i + 1 ] [ j ] > tri [ i + 1 ] [ j + 1 ] ) : NEW_LINE INDENT tri [ i ] [ j ] += tri [ i + 1 ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT tri [ i ] [ j ] += tri [ i + 1 ] [ j + 1 ] NEW_LINE DEDENT DEDENT DEDENT return tri [ 0 ] [ 0 ] NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int SumOfKsubArray ( int arr [ ] , int n , int k ) { int sum = 0 ; deque < int > S ( k ) , G ( k ) ; int i = 0 ; for ( i = 0 ; i < k ; i ++ ) { while ( ( ! S . empty ( ) ) && arr [ S . back ( ) ] >= arr [ i ] ) S . pop_back ( ) ; while ( ( ! G . empty ( ) ) && arr [ G . back ( ) ] <= arr [ i ] ) G . pop_back ( ) ; G . push_back ( i ) ; S . push_back ( i ) ; } for ( ; i < n ; i ++ ) { sum += arr [ S . front ( ) ] + arr [ G . front ( ) ] ; while ( ! S . empty ( ) && S . front ( ) <= i - k ) S . pop_front ( ) ; while ( ! G . empty ( ) && G . front ( ) <= i - k ) G . pop_front ( ) ; while ( ( ! S . empty ( ) ) && arr [ S . back ( ) ] >= arr [ i ] ) S . pop_back ( ) ; while ( ( ! G . empty ( ) ) && arr [ G . back ( ) ] <= arr [ i ] ) G . pop_back ( ) ; G . push_back ( i ) ; S . push_back ( i ) ; } sum += arr [ S . front ( ) ] + arr [ G . front ( ) ] ; return sum ; }
Ref: 
def SumOfKsubArray ( arr , n , k ) : NEW_LINE INDENT Sum = 0 NEW_LINE S = deque ( ) NEW_LINE G = deque ( ) NEW_LINE for i in range ( k ) : NEW_LINE INDENT while ( len ( S ) > 0 and arr [ S [ - 1 ] ] >= arr [ i ] ) : NEW_LINE INDENT S . pop ( ) NEW_LINE DEDENT while ( len ( G ) > 0 and arr [ G [ - 1 ] ] <= arr [ i ] ) : NEW_LINE INDENT G . pop ( ) NEW_LINE DEDENT G . append ( i ) NEW_LINE S . append ( i ) NEW_LINE DEDENT for i in range ( k , n ) : NEW_LINE INDENT Sum += arr [ S [ 0 ] ] + arr [ G [ 0 ] ] NEW_LINE while ( len ( S ) > 0 and S [ 0 ] <= i - k ) : NEW_LINE INDENT S . popleft ( ) NEW_LINE DEDENT while ( len ( G ) > 0 and G [ 0 ] <= i - k ) : NEW_LINE INDENT G . popleft ( ) NEW_LINE DEDENT while ( len ( S ) > 0 and arr [ S [ - 1 ] ] >= arr [ i ] ) : NEW_LINE INDENT S . pop ( ) NEW_LINE DEDENT while ( len ( G ) > 0 and arr [ G [ - 1 ] ] <= arr [ i ] ) : NEW_LINE INDENT G . pop ( ) NEW_LINE DEDENT G . append ( i ) NEW_LINE S . append ( i ) NEW_LINE DEDENT Sum += arr [ S [ 0 ] ] + arr [ G [ 0 ] ] NEW_LINE return Sum NEW_LINE DEDENT
Hyp: 
def SumOfKsubArray ( arr , n , k ) : NEW_LINE INDENT sum = 0 NEW_LINE s = deque ( k ) NEW_LINE G = deque ( k ) NEW_LINE i = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT while ( len ( S ) != 0 and arr [ S [ - 1 ] ] >= arr [ i ] ) : NEW_LINE INDENT S . popleft ( ) NEW_LINE DEDENT while ( len ( G ) != 0 and arr [ G [ - 1 ] ] <= arr [ i ] ) : NEW_LINE INDENT G . popleft ( ) NEW_LINE DEDENT G . append ( i ) NEW_LINE S . append ( i ) NEW_LINE DEDENT for i in range ( k , n ) : NEW_LINE INDENT sum += arr [ S [ - 1 ] ] + arr [ G [ - 1 ] ] NEW_LINE while ( len ( S ) != 0 and S [ - 1 ] <= i - k ) : NEW_LINE INDENT S . popleft ( ) NEW_LINE DEDENT while ( len ( G ) != 0 and arr [ G [ - 1 ] ] >= arr [ i ] ) : NEW_LINE INDENT G . popleft ( ) NEW_LINE DEDENT while ( len ( S ) != 0 and arr [ S [ - 1 ] ] <= arr [ i ] ) : NEW_LINE INDENT S . popleft ( ) NEW_LINE DEDENT while ( len ( G ) != 0 and arr [ G [ - 1 ] ] <= arr [ i ] ) : NEW_LINE INDENT G . popleft ( ) NEW_LINE DEDENT G . append ( i ) NEW_LINE S . append ( i ) NEW_LINE S . append ( i ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT sum += arr [ S [ - 1 ] + arr [ G [ - 1 ] NEW_LINE return sum NEW_LINE DEDENT

BLEU: 73.48
Edit Sim: 134


Src: 
int fun ( unsigned int n ) { return n & ( n - 1 ) ; }
Ref: 
def fun ( n ) : NEW_LINE INDENT return n & ( n - 1 ) NEW_LINE DEDENT
Hyp: 
def fun ( n ) : NEW_LINE INDENT return n & ( n - 1 ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
pair < double , double > mirrorImage ( double a , double b , double c , double x1 , double y1 ) { double temp = - 2 * ( a * x1 + b * y1 + c ) / ( a * a + b * b ) ; double x = temp * a + x1 ; double y = temp * b + y1 ; return make_pair ( x , y ) ; }
Ref: 
def mirrorImage ( a , b , c , x1 , y1 ) : NEW_LINE INDENT temp = - 2 * ( a * x1 + b * y1 + c ) / ( a * a + b * b ) NEW_LINE x = temp * a + x1 NEW_LINE y = temp * b + y1 NEW_LINE return ( x , y ) NEW_LINE DEDENT
Hyp: 
def mirrorImage ( a , b , c , x1 , y1 ) : NEW_LINE INDENT temp = - 2 * ( a * x1 + b * y1 + c ) / ( a * a + b * b ) NEW_LINE x = temp * a + x1 NEW_LINE y = temp * b + y1 NEW_LINE return make_pair ( x , y ) NEW_LINE DEDENT

BLEU: 96.25
Edit Sim: 10


Src: 
void printDistinct ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; for ( int i = 0 ; i < n ; i ++ ) { while ( i < n - 1 && arr [ i ] == arr [ i + 1 ] ) i ++ ; cout << arr [ i ] << " ▁ " ; } }
Ref: 
def printDistinct ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i < n - 1 and arr [ i ] == arr [ i + 1 ] ) : NEW_LINE INDENT while ( i < n - 1 and ( arr [ i ] == arr [ i + 1 ] ) ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
Hyp: 
def printDistinct ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT while ( i < n - 1 and arr [ i ] == arr [ i + 1 ] ) : NEW_LINE INDENT i = i + 1 NEW_LINE DEDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT

BLEU: 61.44
Edit Sim: 107


Src: 
int printIntersection ( int arr1 [ ] , int arr2 [ ] , int m , int n ) { int i = 0 , j = 0 ; while ( i < m && j < n ) { if ( arr1 [ i ] < arr2 [ j ] ) i ++ ; else if ( arr2 [ j ] < arr1 [ i ] ) j ++ ; else { cout << arr2 [ j ] << " ▁ " ; i ++ ; j ++ ; } } }
Ref: 
def printIntersection ( arr1 , arr2 , m , n ) : NEW_LINE INDENT i , j = 0 , 0 NEW_LINE while i < m and j < n : NEW_LINE INDENT if arr1 [ i ] < arr2 [ j ] : NEW_LINE INDENT i += 1 NEW_LINE DEDENT elif arr2 [ j ] < arr1 [ i ] : NEW_LINE INDENT j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( arr2 [ j ] ) NEW_LINE j += 1 NEW_LINE i += 1 NEW_LINE DEDENT DEDENT DEDENT
Hyp: 
def printIntersection ( arr1 , arr2 , m , n ) : NEW_LINE INDENT i , j = 0 , 0 NEW_LINE while i < m and j < n : NEW_LINE INDENT if arr1 [ i ] < arr2 [ j ] : NEW_LINE INDENT i += 1 NEW_LINE DEDENT elif arr2 [ j ] < arr1 [ i ] : NEW_LINE INDENT j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( arr2 [ j ] , arr1 [ i ] ) NEW_LINE i += 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT DEDENT

BLEU: 92.42
Edit Sim: 15


Src: 
int search ( int arr [ ] , int n , int x , int k ) { int i = 0 ; while ( i < n ) { if ( arr [ i ] == x ) return i ; i = i + max ( 1 , abs ( arr [ i ] - x ) / k ) ; } cout << " number ▁ is ▁ not ▁ present ! " ; return - 1 ; }
Ref: 
def search ( arr , n , x , k ) : NEW_LINE INDENT i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( arr [ i ] == x ) : NEW_LINE INDENT return i NEW_LINE DEDENT i = i + max ( 1 , int ( abs ( arr [ i ] - x ) / k ) ) NEW_LINE DEDENT print ( " number ▁ is ▁ not ▁ present ! " ) NEW_LINE return - 1 NEW_LINE DEDENT
Hyp: 
def search ( arr , n , x , k ) : NEW_LINE INDENT i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( arr [ i ] == x ) : NEW_LINE INDENT return i NEW_LINE DEDENT i = i + max ( 1 , abs ( arr [ i ] - x ) / k ) NEW_LINE DEDENT print ( " number ▁ is ▁ not ▁ present " ) NEW_LINE return - 1 NEW_LINE DEDENT

BLEU: 90.84
Edit Sim: 10


Src: 
string arrangeString ( string str ) { int char_count [ MAX_CHAR ] = { 0 } ; int sum = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] >= ' A ' && str [ i ] <= ' Z ' ) char_count [ str [ i ] - ' A ' ] ++ ; else sum = sum + ( str [ i ] - '0' ) ; } string res = " " ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { char ch = ( char ) ( ' A ' + i ) ; while ( char_count [ i ] -- ) res = res + ch ; } if ( sum > 0 ) res = res + to_string ( sum ) ; return res ; }
Ref: 
def arrangeString ( string ) : NEW_LINE INDENT char_count = [ 0 ] * MAX_CHAR NEW_LINE s = 0 NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT if string [ i ] >= " A " and string [ i ] <= " Z " : NEW_LINE INDENT char_count [ ord ( string [ i ] ) - ord ( " A " ) ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT s += ord ( string [ i ] ) - ord ( "0" ) NEW_LINE DEDENT DEDENT res = " " NEW_LINE for i in range ( MAX_CHAR ) : NEW_LINE INDENT ch = chr ( ord ( " A " ) + i ) NEW_LINE while char_count [ i ] : NEW_LINE INDENT res += ch NEW_LINE char_count [ i ] -= 1 NEW_LINE DEDENT DEDENT if s > 0 : NEW_LINE INDENT res += str ( s ) NEW_LINE DEDENT return res NEW_LINE DEDENT
Hyp: 
def arrangeString ( str ) : NEW_LINE INDENT char_count = [ 0 for i in range ( MAX_CHAR ) ] NEW_LINE sum = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] >= ' A ' and str [ i ] <= ' Z ' ) : NEW_LINE INDENT char_count [ ord ( str [ i ] ) - ord ( ' A ' ) ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT sum = sum + ( ord ( str [ i ] ) - ord ( '0' ) ) NEW_LINE DEDENT DEDENT res = " " NEW_LINE for i in range ( MAX_CHAR ) : NEW_LINE INDENT ch = chr ( ord ( ' A ' ) + i ) NEW_LINE while ( char_count [ i ] > 0 ) : NEW_LINE INDENT res = res + chr ( ord ( ' A ' ) + i ) NEW_LINE DEDENT if ( sum > 0 ) : NEW_LINE INDENT res = res + str ( sum ) NEW_LINE DEDENT return res NEW_LINE DEDENT

BLEU: 51.05
Edit Sim: 122


Src: 
int countStrings ( int n ) { int a [ n ] , b [ n ] ; a [ 0 ] = b [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { a [ i ] = a [ i - 1 ] + b [ i - 1 ] ; b [ i ] = a [ i - 1 ] ; } return a [ n - 1 ] + b [ n - 1 ] ; }
Ref: 
def countStrings ( n ) : NEW_LINE INDENT a = [ 0 for i in range ( n ) ] NEW_LINE b = [ 0 for i in range ( n ) ] NEW_LINE a [ 0 ] = b [ 0 ] = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT a [ i ] = a [ i - 1 ] + b [ i - 1 ] NEW_LINE b [ i ] = a [ i - 1 ] NEW_LINE DEDENT return a [ n - 1 ] + b [ n - 1 ] NEW_LINE DEDENT
Hyp: 
def countStrings ( n ) : NEW_LINE INDENT a = [ 0 ] * n NEW_LINE b = [ 0 ] * n NEW_LINE a [ 0 ] = b [ 0 ] = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT a [ i ] = a [ i - 1 ] + b [ i - 1 ] NEW_LINE b [ i ] = a [ i - 1 ] NEW_LINE DEDENT return a [ n - 1 ] + b [ n - 1 ] NEW_LINE DEDENT

BLEU: 82.44
Edit Sim: 38


Src: 
int minSum ( int arr [ ] , int n ) { int dp [ n ] ; if ( n == 1 ) return arr [ 0 ] ; if ( n == 2 ) return min ( arr [ 0 ] , arr [ 1 ] ) ; if ( n == 3 ) return min ( arr [ 0 ] , min ( arr [ 1 ] , arr [ 2 ] ) ) ; if ( n == 4 ) return min ( min ( arr [ 0 ] , arr [ 1 ] ) , min ( arr [ 2 ] , arr [ 3 ] ) ) ; dp [ 0 ] = arr [ 0 ] ; dp [ 1 ] = arr [ 1 ] ; dp [ 2 ] = arr [ 2 ] ; dp [ 3 ] = arr [ 3 ] ; for ( int i = 4 ; i < n ; i ++ ) dp [ i ] = arr [ i ] + min ( min ( dp [ i - 1 ] , dp [ i - 2 ] ) , min ( dp [ i - 3 ] , dp [ i - 4 ] ) ) ; return min ( min ( dp [ n - 1 ] , dp [ n - 2 ] ) , min ( dp [ n - 4 ] , dp [ n - 3 ] ) ) ; }
Ref: 
def minSum ( arr , n ) : NEW_LINE INDENT dp = [ 0 ] * n NEW_LINE if ( n == 1 ) : NEW_LINE INDENT return arr [ 0 ] NEW_LINE DEDENT if ( n == 2 ) : NEW_LINE INDENT return min ( arr [ 0 ] , arr [ 1 ] ) NEW_LINE DEDENT if ( n == 3 ) : NEW_LINE INDENT return min ( arr [ 0 ] , min ( arr [ 1 ] , arr [ 2 ] ) ) NEW_LINE DEDENT if ( n == 4 ) : NEW_LINE INDENT return min ( min ( arr [ 0 ] , arr [ 1 ] ) , min ( arr [ 2 ] , arr [ 3 ] ) ) NEW_LINE DEDENT dp [ 0 ] = arr [ 0 ] NEW_LINE dp [ 1 ] = arr [ 1 ] NEW_LINE dp [ 2 ] = arr [ 2 ] NEW_LINE dp [ 3 ] = arr [ 3 ] NEW_LINE for i in range ( 4 , n ) : NEW_LINE INDENT dp [ i ] = arr [ i ] + min ( min ( dp [ i - 1 ] , dp [ i - 2 ] ) , min ( dp [ i - 3 ] , dp [ i - 4 ] ) ) NEW_LINE DEDENT return min ( min ( dp [ n - 1 ] , dp [ n - 2 ] ) , min ( dp [ n - 4 ] , dp [ n - 3 ] ) ) NEW_LINE DEDENT
Hyp: 
def minSum ( arr , n ) : NEW_LINE INDENT if ( n == 1 ) : return arr [ 0 ] NEW_LINE if ( n == 2 ) : return min ( arr [ 0 ] , arr [ 1 ] ) NEW_LINE if ( n == 3 ) : return min ( arr [ 0 ] , arr [ 1 ] , arr [ 2 ] ) NEW_LINE if ( n == 4 ) : return min ( min ( arr [ 0 ] , arr [ 1 ] , arr [ 2 ] , arr [ 3 ] ) NEW_LINE dp [ 0 ] = arr [ 0 ] NEW_LINE dp [ 1 ] = arr [ 1 ] NEW_LINE dp [ 2 ] = arr [ 2 ] NEW_LINE dp [ 3 ] = arr [ 3 ] NEW_LINE for i in range ( 4 , n ) : NEW_LINE INDENT dp [ i ] = arr [ i ] + min ( min ( dp [ i - 1 ] , dp [ i - 2 ] ) , min ( dp [ i - 3 ] , dp [ i - 4 ] ) ) NEW_LINE DEDENT return min ( min ( dp [ n - 1 ] , dp [ n - 2 ] ) , min ( dp [ n - 4 ] , dp [ n - 3 ] ) ) NEW_LINE DEDENT

BLEU: 82.79
Edit Sim: 134


Src: 
string printSequence ( string arr [ ] , string input ) { string output = " " ; int n = input . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( input [ i ] == ' ▁ ' ) output = output + "0" ; else { int position = input [ i ] - ' A ' ; output = output + arr [ position ] ; } } return output ; }
Ref: 
def printSequence ( arr , input ) : NEW_LINE INDENT n = len ( input ) NEW_LINE output = " " NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( input [ i ] == ' ▁ ' ) : NEW_LINE INDENT output = output + "0" NEW_LINE DEDENT else : NEW_LINE INDENT position = ord ( input [ i ] ) - ord ( ' A ' ) NEW_LINE output = output + arr [ position ] NEW_LINE DEDENT DEDENT return output NEW_LINE DEDENT
Hyp: 
def printSequence ( arr , Input ) : NEW_LINE INDENT output = " " NEW_LINE n = len ( Input ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( Input [ i ] == ' ▁ ' ) : NEW_LINE INDENT output = output + "0" NEW_LINE DEDENT else : NEW_LINE INDENT position = ord ( Input [ i ] ) - ord ( ' A ' ) ; NEW_LINE output = output + arr [ position ] NEW_LINE DEDENT DEDENT return output NEW_LINE DEDENT

BLEU: 77.85
Edit Sim: 37


Src: 
void rotatematrix ( int m , int n , int mat [ R ] [ C ] ) { int row = 0 , col = 0 ; int prev , curr ; while ( row < m && col < n ) { if ( row + 1 == m || col + 1 == n ) break ; prev = mat [ row + 1 ] [ col ] ; for ( int i = col ; i < n ; i ++ ) { curr = mat [ row ] [ i ] ; mat [ row ] [ i ] = prev ; prev = curr ; } row ++ ; for ( int i = row ; i < m ; i ++ ) { curr = mat [ i ] [ n - 1 ] ; mat [ i ] [ n - 1 ] = prev ; prev = curr ; } n -- ; if ( row < m ) { for ( int i = n - 1 ; i >= col ; i -- ) { curr = mat [ m - 1 ] [ i ] ; mat [ m - 1 ] [ i ] = prev ; prev = curr ; } } m -- ; if ( col < n ) { for ( int i = m - 1 ; i >= row ; i -- ) { curr = mat [ i ] [ col ] ; mat [ i ] [ col ] = prev ; prev = curr ; } } col ++ ; } for ( int i = 0 ; i < R ; i ++ ) { for ( int j = 0 ; j < C ; j ++ ) cout << mat [ i ] [ j ] << " ▁ " ; cout << endl ; } }
Ref: 
def rotateMatrix ( mat ) : NEW_LINE INDENT if not len ( mat ) : NEW_LINE INDENT return NEW_LINE DEDENT top = 0 NEW_LINE bottom = len ( mat ) - 1 NEW_LINE left = 0 NEW_LINE right = len ( mat [ 0 ] ) - 1 NEW_LINE while left < right and top < bottom : NEW_LINE INDENT prev = mat [ top + 1 ] [ left ] NEW_LINE for i in range ( left , right + 1 ) : NEW_LINE INDENT curr = mat [ top ] [ i ] NEW_LINE mat [ top ] [ i ] = prev NEW_LINE prev = curr NEW_LINE DEDENT top += 1 NEW_LINE for i in range ( top , bottom + 1 ) : NEW_LINE INDENT curr = mat [ i ] [ right ] NEW_LINE mat [ i ] [ right ] = prev NEW_LINE prev = curr NEW_LINE DEDENT right -= 1 NEW_LINE for i in range ( right , left - 1 , - 1 ) : NEW_LINE INDENT curr = mat [ bottom ] [ i ] NEW_LINE mat [ bottom ] [ i ] = prev NEW_LINE prev = curr NEW_LINE DEDENT bottom -= 1 NEW_LINE for i in range ( bottom , top - 1 , - 1 ) : NEW_LINE INDENT curr = mat [ i ] [ left ] NEW_LINE mat [ i ] [ left ] = prev NEW_LINE prev = curr NEW_LINE DEDENT left += 1 NEW_LINE DEDENT return mat NEW_LINE DEDENT
Hyp: 
def rotatematrix ( m , n , mat ) : NEW_LINE INDENT row = 0 NEW_LINE col = 0 NEW_LINE while ( row < m and col < n ) : NEW_LINE INDENT if ( row + 1 == m or col + 1 == n ) : NEW_LINE INDENT break NEW_LINE DEDENT prev = mat [ row + 1 ] [ col ] NEW_LINE for i in range ( col , n ) : NEW_LINE INDENT curr = mat [ row ] [ i ] NEW_LINE mat [ row ] [ i ] = prev NEW_LINE prev = curr NEW_LINE DEDENT row += 1 NEW_LINE for i in range ( row , m ) : NEW_LINE INDENT curr = mat [ i ] [ n - 1 ] NEW_LINE mat [ i ] [ n - 1 ] = prev NEW_LINE prev = curr NEW_LINE DEDENT n -= 1 NEW_LINE if ( row < m ) : NEW_LINE INDENT for i in range ( n - 1 , col - 1 , - 1 ) : NEW_LINE INDENT curr = mat [ m - 1 ] [ i ] NEW_LINE mat [ m - 1 ] [ i ] = prev NEW_LINE prev = curr NEW_LINE DEDENT DEDENT m -= 1 NEW_LINE if ( col < n ) : NEW_LINE INDENT for i in range ( m - 1 , row - 1 , - 1 ) : NEW_LINE INDENT curr = mat [ i ] [ col ] NEW_LINE mat [ i ] [ col ] = prev NEW_LINE prev = curr NEW_LINE DEDENT DEDENT col += 1 NEW_LINE DEDENT for i in range ( R ) : NEW_LINE INDENT for j in range ( C ) : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT

BLEU: 46.67
Edit Sim: 452


Src: 
int maxcoefficientvalue ( int n ) { int C [ n + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= min ( i , n ) ; j ++ ) { if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } int maxvalue = 0 ; for ( int i = 0 ; i <= n ; i ++ ) maxvalue = max ( maxvalue , C [ n ] [ i ] ) ; return maxvalue ; }
Ref: 
def maxcoefficientvalue ( n ) : NEW_LINE INDENT C = [ [ 0 for x in range ( n + 1 ) ] for y in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( min ( i , n ) + 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT maxvalue = 0 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT maxvalue = max ( maxvalue , C [ n ] [ i ] ) NEW_LINE DEDENT return maxvalue NEW_LINE DEDENT
Hyp: 
def maxcoefficientvalue ( n ) : NEW_LINE INDENT C = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( min ( i , n + 1 ) ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT maxvalue = 0 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT maxvalue = max ( maxvalue , C [ n ] [ i ] ) NEW_LINE DEDENT return maxvalue NEW_LINE DEDENT

BLEU: 91.82
Edit Sim: 9


Src: 
double gcd ( double a , double b ) { if ( a < b ) return gcd ( b , a ) ; if ( fabs ( b ) < 0.001 ) return a ; else return ( gcd ( b , a - floor ( a / b ) * b ) ) ; }
Ref: 
def gcd ( a , b ) : NEW_LINE INDENT if ( a < b ) : NEW_LINE INDENT return gcd ( b , a ) NEW_LINE DEDENT if ( abs ( b ) < 0.001 ) : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return ( gcd ( b , a - math . floor ( a / b ) * b ) ) NEW_LINE DEDENT DEDENT
Hyp: 
def gcd ( a , b ) : NEW_LINE INDENT if a < b : NEW_LINE INDENT return gcd ( b , a ) NEW_LINE DEDENT if fabs ( b ) < 0.001 : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return ( gcd ( b , a - math . floor ( a / b ) * b ) ) NEW_LINE DEDENT DEDENT

BLEU: 83.93
Edit Sim: 8


Src: 
void sortByPattern ( string & str , string pat ) { int count [ MAX_CHAR ] = { 0 } ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) count [ str [ i ] - ' a ' ] ++ ; int index = 0 ; for ( int i = 0 ; i < pat . length ( ) ; i ++ ) for ( int j = 0 ; j < count [ pat [ i ] - ' a ' ] ; j ++ ) str [ index ++ ] = pat [ i ] ; }
Ref: 
def sortByPattern ( str , pat ) : NEW_LINE INDENT global MAX_CHAR NEW_LINE count = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( 0 , len ( str ) ) : NEW_LINE INDENT count [ ord ( str [ i ] ) - 97 ] += 1 NEW_LINE DEDENT index = 0 NEW_LINE str = " " NEW_LINE for i in range ( 0 , len ( pat ) ) : NEW_LINE INDENT j = 0 NEW_LINE while ( j < count [ ord ( pat [ i ] ) - ord ( ' a ' ) ] ) : NEW_LINE INDENT str += pat [ i ] NEW_LINE j = j + 1 NEW_LINE index += 1 NEW_LINE DEDENT DEDENT return str NEW_LINE DEDENT
Hyp: 
def sortByPattern ( str , pat ) : NEW_LINE INDENT count = [ 0 for i in range ( MAX_CHAR ) ] NEW_LINE for i in range ( 0 , len ( str ) , 1 ) : NEW_LINE INDENT count [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT index = 0 NEW_LINE for i in range ( 0 , len ( pat ) , 1 ) : NEW_LINE INDENT for j in range ( 0 , count [ pat [ i ] - ord ( ' a ' ) ] , 1 ) : NEW_LINE INDENT str [ index ] = pat [ i ] NEW_LINE DEDENT DEDENT DEDENT

BLEU: 59.23
Edit Sim: 167


Src: 
void rearrange ( int arr [ ] , int n ) { int max_idx = n - 1 , min_idx = 0 ; int max_elem = arr [ n - 1 ] + 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { arr [ i ] += ( arr [ max_idx ] % max_elem ) * max_elem ; max_idx -- ; } else { arr [ i ] += ( arr [ min_idx ] % max_elem ) * max_elem ; min_idx ++ ; } } for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = arr [ i ] / max_elem ; }
Ref: 
def rearrange ( arr , n ) : NEW_LINE INDENT max_idx = n - 1 NEW_LINE min_idx = 0 NEW_LINE max_elem = arr [ n - 1 ] + 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT arr [ i ] += ( arr [ max_idx ] % max_elem ) * max_elem NEW_LINE max_idx -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] += ( arr [ min_idx ] % max_elem ) * max_elem NEW_LINE min_idx += 1 NEW_LINE DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT arr [ i ] = arr [ i ] / max_elem NEW_LINE DEDENT DEDENT
Hyp: 
def rearrange ( arr , n ) : NEW_LINE INDENT max_idx = n - 1 NEW_LINE min_idx = 0 NEW_LINE max_elem = arr [ n - 1 ] + 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT arr [ i ] += ( arr [ max_idx ] % max_elem ) * max_elem NEW_LINE max_idx -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] += ( arr [ min_idx ] % max_elem ) * max_elem NEW_LINE min_idx += 1 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = arr [ i ] // max_elem NEW_LINE DEDENT DEDENT

BLEU: 92.27
Edit Sim: 9


Src: 
int minJumps ( int arr [ ] , int n ) { int * jumps = new int [ n ] ; int i , j ; if ( n == 0 || arr [ 0 ] == 0 ) return INT_MAX ; jumps [ 0 ] = 0 ; for ( i = 1 ; i < n ; i ++ ) { jumps [ i ] = INT_MAX ; for ( j = 0 ; j < i ; j ++ ) { if ( i <= j + arr [ j ] && jumps [ j ] != INT_MAX ) { jumps [ i ] = min ( jumps [ i ] , jumps [ j ] + 1 ) ; break ; } } } return jumps [ n - 1 ] ; }
Ref: 
def minJumps ( arr , n ) : NEW_LINE INDENT jumps = [ 0 for i in range ( n ) ] NEW_LINE if ( n == 0 ) or ( arr [ 0 ] == 0 ) : NEW_LINE INDENT return float ( ' inf ' ) NEW_LINE DEDENT jumps [ 0 ] = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT jumps [ i ] = float ( ' inf ' ) NEW_LINE for j in range ( i ) : NEW_LINE INDENT if ( i <= j + arr [ j ] ) and ( jumps [ j ] != float ( ' inf ' ) ) : NEW_LINE INDENT jumps [ i ] = min ( jumps [ i ] , jumps [ j ] + 1 ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT return jumps [ n - 1 ] NEW_LINE DEDENT
Hyp: 
def minJumps ( arr , n ) : NEW_LINE INDENT jumps = [ None ] * n NEW_LINE if n == 0 or arr [ 0 ] == 0 : NEW_LINE INDENT return sys . maxsize NEW_LINE DEDENT jumps [ 0 ] = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT jumps [ i ] = sys . maxsize NEW_LINE for j in range ( i ) : NEW_LINE INDENT if ( i <= j + arr [ j ] and jumps [ j ] != INT_MAX ) : NEW_LINE INDENT jumps [ i ] = min ( jumps [ i ] , jumps [ j ] + 1 ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT return jumps [ n - 1 ] NEW_LINE DEDENT

BLEU: 68.79
Edit Sim: 77


Src: 
float find_prob ( int N , float P ) { double dp [ N + 1 ] ; dp [ 0 ] = 1 ; dp [ 1 ] = 0 ; dp [ 2 ] = P ; dp [ 3 ] = 1 - P ; for ( int i = 4 ; i <= N ; ++ i ) dp [ i ] = ( P ) * dp [ i - 2 ] + ( 1 - P ) * dp [ i - 3 ] ; return dp [ N ] ; }
Ref: 
def find_prob ( N , P ) : NEW_LINE INDENT dp = [ 0 ] * ( n + 1 ) NEW_LINE dp [ 0 ] = 1 NEW_LINE dp [ 1 ] = 0 NEW_LINE dp [ 2 ] = P NEW_LINE dp [ 3 ] = 1 - P NEW_LINE for i in range ( 4 , N + 1 ) : NEW_LINE INDENT dp [ i ] = ( P ) * dp [ i - 2 ] + ( 1 - P ) * dp [ i - 3 ] NEW_LINE DEDENT return dp [ N ] NEW_LINE DEDENT
Hyp: 
def find_prob ( N , P ) : NEW_LINE INDENT dp = [ 0 for i in range ( N + 1 ) ] NEW_LINE dp [ 0 ] = 1 NEW_LINE dp [ 1 ] = 0 NEW_LINE dp [ 2 ] = P NEW_LINE dp [ 3 ] = 1 - P NEW_LINE for i in range ( 4 , N + 1 ) : NEW_LINE INDENT dp [ i ] = ( P ) * dp [ i - 2 ] + ( 1 - P ) * dp [ i - 3 ] NEW_LINE DEDENT return dp [ N ] NEW_LINE DEDENT

BLEU: 90.92
Edit Sim: 16


Src: 
int waysToIncreaseLCSBy1 ( string str1 , string str2 ) { int m = str1 . length ( ) , n = str2 . length ( ) ; vector < int > position [ M ] ; for ( int i = 1 ; i <= n ; i ++ ) position [ toInt ( str2 [ i - 1 ] ) ] . push_back ( i ) ; int lcsl [ m + 2 ] [ n + 2 ] ; int lcsr [ m + 2 ] [ n + 2 ] ; for ( int i = 0 ; i <= m + 1 ; i ++ ) for ( int j = 0 ; j <= n + 1 ; j ++ ) lcsl [ i ] [ j ] = lcsr [ i ] [ j ] = 0 ; for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( str1 [ i - 1 ] == str2 [ j - 1 ] ) lcsl [ i ] [ j ] = 1 + lcsl [ i - 1 ] [ j - 1 ] ; else lcsl [ i ] [ j ] = max ( lcsl [ i - 1 ] [ j ] , lcsl [ i ] [ j - 1 ] ) ; } } for ( int i = m ; i >= 1 ; i -- ) { for ( int j = n ; j >= 1 ; j -- ) { if ( str1 [ i - 1 ] == str2 [ j - 1 ] ) lcsr [ i ] [ j ] = 1 + lcsr [ i + 1 ] [ j + 1 ] ; else lcsr [ i ] [ j ] = max ( lcsr [ i + 1 ] [ j ] , lcsr [ i ] [ j + 1 ] ) ; } } int ways = 0 ; for ( int i = 0 ; i <= m ; i ++ ) { for ( char c = ' a ' ; c <= ' z ' ; c ++ ) { for ( int j = 0 ; j < position [ toInt ( c ) ] . size ( ) ; j ++ ) { int p = position [ toInt ( c ) ] [ j ] ; if ( lcsl [ i ] [ p - 1 ] + lcsr [ i + 1 ] [ p + 1 ] == lcsl [ m ] [ n ] ) ways ++ ; } } } return ways ; }
Ref: 
def waysToIncreaseLCSBy1 ( str1 , str2 ) : NEW_LINE INDENT m = len ( str1 ) NEW_LINE n = len ( str2 ) NEW_LINE position = [ [ ] for i in range ( M ) ] NEW_LINE for i in range ( 1 , n + 1 , 1 ) : NEW_LINE INDENT position [ ord ( str2 [ i - 1 ] ) - 97 ] . append ( i ) NEW_LINE DEDENT lcsl = [ [ 0 for i in range ( n + 2 ) ] for j in range ( m + 2 ) ] NEW_LINE lcsr = [ [ 0 for i in range ( n + 2 ) ] for j in range ( m + 2 ) ] NEW_LINE for i in range ( 1 , m + 1 , 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 , 1 ) : NEW_LINE INDENT if ( str1 [ i - 1 ] == str2 [ j - 1 ] ) : NEW_LINE INDENT lcsl [ i ] [ j ] = 1 + lcsl [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT lcsl [ i ] [ j ] = max ( lcsl [ i - 1 ] [ j ] , lcsl [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( m , 0 , - 1 ) : NEW_LINE INDENT for j in range ( n , 0 , - 1 ) : NEW_LINE INDENT if ( str1 [ i - 1 ] == str2 [ j - 1 ] ) : NEW_LINE INDENT lcsr [ i ] [ j ] = 1 + lcsr [ i + 1 ] [ j + 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT lcsr [ i ] [ j ] = max ( lcsr [ i + 1 ] [ j ] , lcsr [ i ] [ j + 1 ] ) NEW_LINE DEDENT DEDENT DEDENT ways = 0 NEW_LINE for i in range ( 0 , m + 1 , 1 ) : NEW_LINE INDENT for C in range ( 0 , 26 , 1 ) : NEW_LINE INDENT for j in range ( 0 , len ( position [ C ] ) , 1 ) : NEW_LINE INDENT p = position [ C ] [ j ] NEW_LINE if ( lcsl [ i ] [ p - 1 ] + lcsr [ i + 1 ] [ p + 1 ] == lcsl [ m ] [ n ] ) : NEW_LINE INDENT ways += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return ways NEW_LINE DEDENT
Hyp: 
def waysToIncreaseLCSBy1 ( str1 , str2 ) : NEW_LINE INDENT m = len ( str1 ) NEW_LINE n = len ( str2 ) NEW_LINE position = [ ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT position [ toInt ( str2 [ i - 1 ] ) ] . append ( i ) NEW_LINE DEDENT lcsl = [ [ 0 for i in range ( n + 2 ) ] for j in range ( m + 2 ) ] NEW_LINE lcsr = [ [ 0 for j in range ( n + 2 ) ] NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( str1 [ i - 1 ] == str2 [ j - 1 ] ) : NEW_LINE INDENT lcsl [ i ] [ j ] = 1 + lcsl [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT lcsl [ i ] [ j ] = max ( lcsl [ i - 1 ] [ j ] , lcsl [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( m , 1 , - 1 ) : NEW_LINE INDENT for j in range ( n , 1 , - 1 ) : NEW_LINE INDENT if ( str1 [ i - 1 ] == str2 [ j - 1 ] ) : NEW_LINE INDENT lcsr [ i ] [ j ] = 1 + lcsr [ i + 1 ] [ j + 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT lcsr [ i ] [ j ] = max ( lcsr [ i + 1 ] [ j ] , lcsr [ i ] [ j + 1 ] ) NEW_LINE DEDENT DEDENT DEDENT ways = 0 NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for c in range ( ' a ' , ' z ' ) : NEW_LINE INDENT for j in range ( len ( position ) ) : NEW_LINE INDENT p = position [ toInt ( c ) ] [ j ] NEW_LINE if ( lcsl [ i ] [ p - 1 ] + lcsr [ i + 1 ] [ p + 1 ] == lcsl [ m ] [ n ] ) : NEW_LINE INDENT ways += 1

BLEU: 83.46
Edit Sim: 184


Src: 
int lis ( int arr [ ] , int n ) { int lis [ n ] ; lis [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { lis [ i ] = 1 ; for ( int j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; } return * max_element ( lis , lis + n ) ; }
Ref: 
def lis ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE lis = [ 1 ] * n NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( 0 , i ) : NEW_LINE INDENT if arr [ i ] > arr [ j ] and lis [ i ] < lis [ j ] + 1 : NEW_LINE INDENT lis [ i ] = lis [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT maximum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT maximum = max ( maximum , lis [ i ] ) NEW_LINE DEDENT return maximum NEW_LINE DEDENT
Hyp: 
def lis ( arr , n ) : NEW_LINE INDENT lis = [ 0 for i in range ( n ) ] NEW_LINE lis [ 0 ] = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT lis [ i ] = 1 NEW_LINE for j in range ( i ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and lis [ i ] < lis [ j ] + 1 ) : NEW_LINE INDENT lis [ i ] = lis [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT return max ( lis , lis + n ) NEW_LINE DEDENT

BLEU: 65.88
Edit Sim: 171


Src: 
void SternSequenceFunc ( vector < int > & BrocotSequence , int n ) { for ( int i = 1 ; BrocotSequence . size ( ) < n ; i ++ ) { int considered_element = BrocotSequence [ i ] ; int precedent = BrocotSequence [ i - 1 ] ; BrocotSequence . push_back ( considered_element + precedent ) ; BrocotSequence . push_back ( considered_element ) ; } for ( int i = 0 ; i < 15 ; ++ i ) cout << BrocotSequence [ i ] << " ▁ " ; }
Ref: 
def SternSequenceFunc ( BrocotSequence , n ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT considered_element = BrocotSequence [ i ] NEW_LINE precedent = BrocotSequence [ i - 1 ] NEW_LINE BrocotSequence . append ( considered_element + precedent ) NEW_LINE BrocotSequence . append ( considered_element ) NEW_LINE DEDENT for i in range ( 0 , 15 ) : NEW_LINE INDENT print ( BrocotSequence [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
Hyp: 
def SternSequenceFunc ( BrocotSequence , n ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT considered_element = BrocotSequence [ i ] NEW_LINE precedent = BrocotSequence [ i - 1 ] NEW_LINE BrocotSequence . append ( considered_element + precedent ) NEW_LINE BrocotSequence . append ( considered_element ) NEW_LINE DEDENT for i in range ( 0 , 15 ) : NEW_LINE INDENT print ( BrocotSequence [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
void printTreeEdges ( int prufer [ ] , int m ) { int vertices = m + 2 ; int vertex_set [ vertices ] ; for ( int i = 0 ; i < vertices ; i ++ ) vertex_set [ i ] = 0 ; for ( int i = 0 ; i < vertices - 2 ; i ++ ) vertex_set [ prufer [ i ] - 1 ] += 1 ; cout << " \n The ▁ edge ▁ set ▁ E ( G ) ▁ is ▁ : \n " ; int j = 0 ; for ( int i = 0 ; i < vertices - 2 ; i ++ ) { for ( j = 0 ; j < vertices ; j ++ ) { if ( vertex_set [ j ] == 0 ) { vertex_set [ j ] = - 1 ; cout << " ( " << ( j + 1 ) << " , ▁ " << prufer [ i ] << " ) ▁ ▁ " ; vertex_set [ prufer [ i ] - 1 ] -- ; break ; } } } j = 0 ; for ( int i = 0 ; i < vertices ; i ++ ) { if ( vertex_set [ i ] == 0 && j == 0 ) { cout << " ( " << ( i + 1 ) << " , ▁ " ; j ++ ; } else if ( vertex_set [ i ] == 0 && j == 1 ) cout << ( i + 1 ) << " ) \n " ; } }
Ref: 
def printTreeEdges ( prufer , m ) : NEW_LINE INDENT vertices = m + 2 NEW_LINE vertex_set = [ 0 ] * vertices NEW_LINE for i in range ( vertices - 2 ) : NEW_LINE INDENT vertex_set [ prufer [ i ] - 1 ] += 1 NEW_LINE DEDENT print ( " The ▁ edge ▁ set ▁ E ( G ) ▁ is ▁ : " ) NEW_LINE j = 0 NEW_LINE for i in range ( vertices - 2 ) : NEW_LINE INDENT for j in range ( vertices ) : NEW_LINE INDENT if ( vertex_set [ j ] == 0 ) : NEW_LINE INDENT vertex_set [ j ] = - 1 NEW_LINE print ( " ( " , ( j + 1 ) , " , ▁ " , prufer [ i ] , " ) ▁ " , sep = " " , end = " " ) NEW_LINE vertex_set [ prufer [ i ] - 1 ] -= 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT j = 0 NEW_LINE for i in range ( vertices ) : NEW_LINE INDENT if ( vertex_set [ i ] == 0 and j == 0 ) : NEW_LINE INDENT print ( " ( " , ( i + 1 ) , " , ▁ " , sep = " " , end = " " ) NEW_LINE j += 1 NEW_LINE DEDENT elif ( vertex_set [ i ] == 0 and j == 1 ) : NEW_LINE INDENT print ( ( i + 1 ) , " ) " ) NEW_LINE DEDENT DEDENT DEDENT
Hyp: 
def printTreeEdges ( prufer , m ) : NEW_LINE INDENT vertices = len ( prufer ) NEW_LINE vertex_set = [ 0 ] * vertices NEW_LINE for i in range ( 0 , vertices ) : NEW_LINE INDENT vertex_set [ i ] = 0 NEW_LINE DEDENT for i in range ( 0 , vertices - 2 ) : NEW_LINE INDENT vertex_set [ prufer [ i ] - 1 ] += 1 NEW_LINE DEDENT print ( " The ▁ edge ▁ set ▁ E ( G ) ▁ is ▁ : " ) NEW_LINE j = 0 NEW_LINE for i in range ( 0 , vertices - 2 ) : NEW_LINE INDENT for j in range ( 0 , vertices ) : NEW_LINE INDENT if ( vertex_set [ j ] == 0 ) : NEW_LINE INDENT vertex_set [ j ] = - 1 NEW_LINE print ( " ( " , ( j + 1 ) , " , ▁ " , prufer [ i ] , " ) ▁ " , vertex_set [ prufer [ i ] - 1 ] -= 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT j = 0 NEW_LINE for i in range ( 0 , vertices ) : NEW_LINE INDENT if ( vertex_set [ i ] == 0 and j == 0 ) : NEW_LINE INDENT print ( " ( " , ( i + 1 ) , " , ▁ " , j + 1 ) NEW_LINE DEDENT elif ( vertex_set [ i ] == 0 and j == 1 ) : NEW_LINE INDENT print ( ( i + 1 ) , " ) NEW_LINE j += 1 NEW_LINE DEDENT DEDENT DEDENT

BLEU: 83.85
Edit Sim: 197


Src: 
int countDecodingDP ( char * digits , int n ) { int count [ n + 1 ] ; count [ 0 ] = 1 ; count [ 1 ] = 1 ; if ( digits [ 0 ] == '0' ) return 0 ; for ( int i = 2 ; i <= n ; i ++ ) { count [ i ] = 0 ; if ( digits [ i - 1 ] > '0' ) count [ i ] = count [ i - 1 ] ; if ( digits [ i - 2 ] == '1' || ( digits [ i - 2 ] == '2' && digits [ i - 1 ] < '7' ) ) count [ i ] += count [ i - 2 ] ; } return count [ n ] ; }
Ref: 
def countDecodingDP ( digits , n ) : NEW_LINE INDENT count = [ 0 ] * ( n + 1 ) NEW_LINE count [ 0 ] = 1 NEW_LINE count [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT count [ i ] = 0 NEW_LINE if ( digits [ i - 1 ] > '0' ) : NEW_LINE INDENT count [ i ] = count [ i - 1 ] NEW_LINE DEDENT if ( digits [ i - 2 ] == '1' or ( digits [ i - 2 ] == '2' and digits [ i - 1 ] < '7' ) ) : NEW_LINE INDENT count [ i ] += count [ i - 2 ] NEW_LINE DEDENT DEDENT return count [ n ] NEW_LINE DEDENT
Hyp: 
def countDecodingDP ( digits , n ) : NEW_LINE INDENT count = [ 0 ] * ( n + 1 ) NEW_LINE count [ 0 ] = 1 NEW_LINE count [ 1 ] = 1 NEW_LINE if ( digits [ 0 ] == '0' ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT count [ i ] = 0 NEW_LINE if ( digits [ i - 1 ] > '0' ) : NEW_LINE INDENT count [ i ] = count [ i - 1 ] NEW_LINE DEDENT if ( digits [ i - 2 ] == '1' or ( digits [ i - 2 ] == '2' and digits [ i - 1 ] < '7' ) ) : NEW_LINE INDENT count [ i ] += count [ i - 2 ] NEW_LINE DEDENT DEDENT return count [ n ] NEW_LINE DEDENT

BLEU: 88.66
Edit Sim: 70


Src: 
int countStrings ( int n ) { int a [ n ] , b [ n ] ; a [ 0 ] = b [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { a [ i ] = a [ i - 1 ] + b [ i - 1 ] ; b [ i ] = a [ i - 1 ] ; } return ( 1 << n ) - a [ n - 1 ] - b [ n - 1 ] ; }
Ref: 
def countStrings ( n ) : NEW_LINE INDENT a = [ 0 ] * n NEW_LINE b = [ 0 ] * n NEW_LINE a [ 0 ] = b [ 0 ] = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT a [ i ] = a [ i - 1 ] + b [ i - 1 ] NEW_LINE b [ i ] = a [ i - 1 ] NEW_LINE DEDENT return ( 1 << n ) - a [ n - 1 ] - b [ n - 1 ] NEW_LINE DEDENT
Hyp: 
def countStrings ( n ) : NEW_LINE INDENT a = [ 0 ] * n NEW_LINE b = [ 0 ] * n NEW_LINE a [ 0 ] = b [ 0 ] = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT a [ i ] = a [ i - 1 ] + b [ i - 1 ] NEW_LINE b [ i ] = a [ i - 1 ] NEW_LINE DEDENT return ( 1 << n ) - a [ n - 1 ] - b [ n - 1 ] NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int maximumSegments ( int n , int a , int b , int c ) { int dp [ n + 1 ] ; memset ( dp , - 1 , sizeof ( dp ) ) ; dp [ 0 ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( dp [ i ] != - 1 ) { if ( i + a <= n ) dp [ i + a ] = max ( dp [ i ] + 1 , dp [ i + a ] ) ; if ( i + b <= n ) dp [ i + b ] = max ( dp [ i ] + 1 , dp [ i + b ] ) ; if ( i + c <= n ) dp [ i + c ] = max ( dp [ i ] + 1 , dp [ i + c ] ) ; } } return dp [ n ] ; }
Ref: 
def maximumSegments ( n , a , b , c ) : NEW_LINE INDENT dp = [ - 1 ] * ( n + 10 ) NEW_LINE dp [ 0 ] = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( dp [ i ] != - 1 ) : NEW_LINE INDENT if ( i + a <= n ) : NEW_LINE INDENT dp [ i + a ] = max ( dp [ i ] + 1 , dp [ i + a ] ) NEW_LINE DEDENT if ( i + b <= n ) : NEW_LINE INDENT dp [ i + b ] = max ( dp [ i ] + 1 , dp [ i + b ] ) NEW_LINE DEDENT if ( i + c <= n ) : NEW_LINE INDENT dp [ i + c ] = max ( dp [ i ] + 1 , dp [ i + c ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ n ] NEW_LINE DEDENT
Hyp: 
def maximumSegments ( n , a , b , c ) : NEW_LINE INDENT dp = [ 0 for _ in range ( n + 1 ) ] NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT if ( dp [ i ] != - 1 ) : NEW_LINE INDENT if ( i + a <= n ) : NEW_LINE INDENT dp [ i + a ] = max ( dp [ i ] + 1 , dp [ i + a ] ) NEW_LINE DEDENT if ( i + b <= n ) : NEW_LINE INDENT dp [ i + b ] = max ( dp [ i ] + 1 , dp [ i + b ] ) NEW_LINE DEDENT if ( i + c <= n ) : NEW_LINE INDENT dp [ i + c ] = max ( dp [ i ] + 1 , dp [ i + c ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ n ] NEW_LINE DEDENT

BLEU: 90.67
Edit Sim: 33


Src: 
void printBracketNumber ( string exp , int n ) { int left_bnum = 1 ; stack < int > right_bnum ; for ( int i = 0 ; i < n ; i ++ ) { if ( exp [ i ] == ' ( ' ) { cout << left_bnum << " ▁ " ; right_bnum . push ( left_bnum ) ; left_bnum ++ ; } else if ( exp [ i ] == ' ) ' ) { cout << right_bnum . top ( ) << " ▁ " ; right_bnum . pop ( ) ; } } }
Ref: 
def printBracketNumber ( exp , n ) : NEW_LINE INDENT left_bnum = 1 NEW_LINE right_bnum = list ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if exp [ i ] == ' ( ' : NEW_LINE INDENT print ( left_bnum , end = " ▁ " ) NEW_LINE right_bnum . append ( left_bnum ) NEW_LINE left_bnum += 1 NEW_LINE DEDENT elif exp [ i ] == ' ) ' : NEW_LINE INDENT print ( right_bnum [ - 1 ] , end = " ▁ " ) NEW_LINE right_bnum . pop ( ) NEW_LINE DEDENT DEDENT DEDENT
Hyp: 
def printBracketNumber ( exp , n ) : NEW_LINE INDENT left_bnum = 1 NEW_LINE right_bnum = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( exp [ i ] == ' ( ' ) : NEW_LINE INDENT print ( left_bnum , end = " ▁ " ) NEW_LINE right_bnum . append ( left_bnum ) NEW_LINE left_bnum += 1 NEW_LINE DEDENT elif ( exp [ i ] == ' ) ' ) : NEW_LINE INDENT print ( right_bnum [ - 1 ] , end = " ▁ " ) NEW_LINE right_bnum . pop ( ) NEW_LINE DEDENT DEDENT DEDENT

BLEU: 87.15
Edit Sim: 15


Src: 
int countWords ( char str [ ] , int len ) { int count = 1 ; if ( len == 1 ) return count ; if ( str [ 0 ] == str [ 1 ] ) count *= 1 ; else count *= 2 ; for ( int j = 1 ; j < len - 1 ; j ++ ) { if ( str [ j ] == str [ j - 1 ] && str [ j ] == str [ j + 1 ] ) count *= 1 ; else if ( str [ j ] == str [ j - 1 ] || str [ j ] == str [ j + 1 ] || str [ j - 1 ] == str [ j + 1 ] ) count *= 2 ; else count *= 3 ; } if ( str [ len - 1 ] == str [ len - 2 ] ) count *= 1 ; else count *= 2 ; return count ; }
Ref: 
def countWords ( str , l ) : NEW_LINE INDENT count = 1 ; NEW_LINE if ( l == 1 ) : NEW_LINE INDENT return count NEW_LINE DEDENT if ( str [ 0 ] == str [ 1 ] ) : NEW_LINE INDENT count *= 1 NEW_LINE DEDENT else : NEW_LINE INDENT count *= 2 NEW_LINE DEDENT for j in range ( 1 , l - 1 ) : NEW_LINE INDENT if ( str [ j ] == str [ j - 1 ] and str [ j ] == str [ j + 1 ] ) : NEW_LINE INDENT count *= 1 NEW_LINE DEDENT elif ( str [ j ] == str [ j - 1 ] or str [ j ] == str [ j + 1 ] or str [ j - 1 ] == str [ j + 1 ] ) : NEW_LINE INDENT count *= 2 NEW_LINE DEDENT else : NEW_LINE INDENT count *= 3 NEW_LINE DEDENT DEDENT if ( str [ l - 1 ] == str [ l - 2 ] ) : NEW_LINE INDENT count *= 1 NEW_LINE DEDENT else : NEW_LINE INDENT count *= 2 NEW_LINE DEDENT return count NEW_LINE DEDENT
Hyp: 
def countWords ( str , len ) : NEW_LINE INDENT count = 1 NEW_LINE if ( len == 1 ) : NEW_LINE INDENT return count NEW_LINE DEDENT if ( str [ 0 ] == str [ 1 ] ) : NEW_LINE INDENT count *= 1 NEW_LINE DEDENT else : NEW_LINE INDENT count *= 2 NEW_LINE DEDENT for j in range ( 1 , len - 1 ) : NEW_LINE INDENT if ( str [ j ] == str [ j - 1 ] and str [ j ] == str [ j + 1 ] ) : NEW_LINE INDENT count *= 1 NEW_LINE DEDENT elif ( str [ j ] == str [ j - 1 ] or str [ j ] == str [ j + 1 ] or str [ j - 1 ] == str [ j + 1 ] ) : NEW_LINE INDENT count *= 2 NEW_LINE DEDENT else : NEW_LINE INDENT count *= 3 NEW_LINE DEDENT DEDENT if ( str [ l - 1 ] == str [ l - 2 ] ) : NEW_LINE INDENT count *= 1 NEW_LINE DEDENT else : NEW_LINE INDENT count *= 2 NEW_LINE DEDENT return count NEW_LINE DEDENT

BLEU: 94.95
Edit Sim: 8


Src: 
int largest ( int arr [ ] , int n ) { int i ; int max = arr [ 0 ] ; for ( i = 1 ; i < n ; i ++ ) if ( arr [ i ] > max ) max = arr [ i ] ; return max ; }
Ref: 
def largest ( arr , n ) : NEW_LINE INDENT max = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if arr [ i ] > max : NEW_LINE INDENT max = arr [ i ] NEW_LINE DEDENT DEDENT return max NEW_LINE DEDENT
Hyp: 
def largest ( arr , n ) : NEW_LINE INDENT max = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] > max ) : NEW_LINE INDENT max = arr [ i ] NEW_LINE DEDENT DEDENT return max NEW_LINE DEDENT

BLEU: 90.46
Edit Sim: 4


Src: 
int findMinDiff ( int arr [ ] , int n ) { int diff = INT_MAX ; for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( abs ( arr [ i ] - arr [ j ] ) < diff ) diff = abs ( arr [ i ] - arr [ j ] ) ; return diff ; }
Ref: 
def findMinDiff ( arr , n ) : NEW_LINE INDENT diff = 10 ** 20 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if abs ( arr [ i ] - arr [ j ] ) < diff : NEW_LINE INDENT diff = abs ( arr [ i ] - arr [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return diff NEW_LINE DEDENT
Hyp: 
def findMinDiff ( arr , n ) : NEW_LINE INDENT diff = sys . maxsize NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( abs ( arr [ i ] - arr [ j ] ) < diff ) : NEW_LINE INDENT diff = abs ( arr [ i ] - arr [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return diff NEW_LINE DEDENT

BLEU: 84.55
Edit Sim: 20


Src: 
int maxSum ( int arr [ ] , int n ) { int res = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { int curr_sum = 0 ; for ( int j = 0 ; j < n ; j ++ ) { int index = ( i + j ) % n ; curr_sum += j * arr [ index ] ; } res = max ( res , curr_sum ) ; } return res ; }
Ref: 
def maxSum ( arr , n ) : NEW_LINE INDENT res = - sys . maxsize NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT curr_sum = 0 NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT index = int ( ( i + j ) % n ) NEW_LINE curr_sum += j * arr [ index ] NEW_LINE DEDENT res = max ( res , curr_sum ) NEW_LINE DEDENT return res NEW_LINE DEDENT
Hyp: 
def maxSum ( arr , n ) : NEW_LINE INDENT res = - sys . maxsize - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT curr_sum = 0 NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT index = ( i + j ) % n NEW_LINE curr_sum += j * arr [ index ] NEW_LINE DEDENT res = max ( res , curr_sum ) NEW_LINE DEDENT return res NEW_LINE DEDENT

BLEU: 90.64
Edit Sim: 12


Src: 
float volumeOfEllipsoid ( float r1 , float r2 , float r3 ) { float pi = 3.14 ; return 1.33 * pi * r1 * r2 * r3 ; }
Ref: 
def volumeOfEllipsoid ( r1 , r2 , r3 ) : NEW_LINE INDENT return 1.33 * math . pi * r1 * r2 * r3 NEW_LINE DEDENT
Hyp: 
def volumeOfEllipsoid ( r1 , r2 , r3 ) : NEW_LINE INDENT pi = 3.14 NEW_LINE return 1.33 * pi * r1 * r2 * r3 NEW_LINE DEDENT

BLEU: 73.59
Edit Sim: 26


Src: 
int lcsOf3 ( string X , string Y , string Z , int m , int n , int o ) { int L [ m + 1 ] [ n + 1 ] [ o + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { for ( int k = 0 ; k <= o ; k ++ ) { if ( i == 0 || j == 0 || k == 0 ) L [ i ] [ j ] [ k ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] && X [ i - 1 ] == Z [ k - 1 ] ) L [ i ] [ j ] [ k ] = L [ i - 1 ] [ j - 1 ] [ k - 1 ] + 1 ; else L [ i ] [ j ] [ k ] = max ( max ( L [ i - 1 ] [ j ] [ k ] , L [ i ] [ j - 1 ] [ k ] ) , L [ i ] [ j ] [ k - 1 ] ) ; } } } return L [ m ] [ n ] [ o ] ; }
Ref: 
def lcsOf3 ( X , Y , Z , m , n , o ) : NEW_LINE INDENT L = [ [ [ 0 for i in range ( o + 1 ) ] for j in range ( n + 1 ) ] for k in range ( m + 1 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT for k in range ( o + 1 ) : NEW_LINE INDENT if ( i == 0 or j == 0 or k == 0 ) : NEW_LINE INDENT L [ i ] [ j ] [ k ] = 0 NEW_LINE DEDENT elif ( X [ i - 1 ] == Y [ j - 1 ] and X [ i - 1 ] == Z [ k - 1 ] ) : NEW_LINE INDENT L [ i ] [ j ] [ k ] = L [ i - 1 ] [ j - 1 ] [ k - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] [ k ] = max ( max ( L [ i - 1 ] [ j ] [ k ] , L [ i ] [ j - 1 ] [ k ] ) , L [ i ] [ j ] [ k - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return L [ m ] [ n ] [ o ] NEW_LINE DEDENT
Hyp: 
def lcsOf3 ( X , Y , Z , m , n , o ) : NEW_LINE INDENT L = [ [ 0 for i in range ( o + 1 ) ] for j in range ( m + 1 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT for k in range ( o + 1 ) : NEW_LINE INDENT if ( i == 0 or j == 0 or k == 0 ) : NEW_LINE INDENT L [ i ] [ j ] [ k ] = 0 NEW_LINE DEDENT elif ( X [ i - 1 ] == Y [ j - 1 ] and X [ i - 1 ] == Z [ k - 1 ] ) : NEW_LINE INDENT L [ i ] [ j ] [ k ] = L [ i - 1 ] [ j - 1 ] [ k - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] [ k ] = max ( max ( L [ i - 1 ] [ j ] [ k ] , L [ i ] [ j - 1 ] [ k ] ) , L [ i ] [ j ] [ k - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return L [ m ] [ n ] [ o ] NEW_LINE DEDENT

BLEU: 95.24
Edit Sim: 36


Src: 
int countEndless ( bool input [ ] [ MAX ] , int n ) { bool row [ n ] [ n ] , col [ n ] [ n ] ; for ( int j = 0 ; j < n ; j ++ ) { bool isEndless = 1 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( input [ i ] [ j ] == 0 ) isEndless = 0 ; col [ i ] [ j ] = isEndless ; } } for ( int i = 0 ; i < n ; i ++ ) { bool isEndless = 1 ; for ( int j = n - 1 ; j >= 0 ; j -- ) { if ( input [ i ] [ j ] == 0 ) isEndless = 0 ; row [ i ] [ j ] = isEndless ; } } int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 1 ; j < n ; j ++ ) if ( row [ i ] [ j ] && col [ i ] [ j ] ) ans ++ ; return ans ; }
Ref: 
def countEndless ( input_mat , n ) : NEW_LINE INDENT row = np . zeros ( ( n , n ) ) NEW_LINE col = np . zeros ( ( n , n ) ) NEW_LINE for j in range ( n ) : NEW_LINE INDENT isEndless = 1 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( input_mat [ i ] [ j ] == 0 ) : NEW_LINE INDENT isEndless = 0 NEW_LINE DEDENT col [ i ] [ j ] = isEndless NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT isEndless = 1 NEW_LINE for j in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( input_mat [ i ] [ j ] == 0 ) : NEW_LINE INDENT isEndless = 0 NEW_LINE DEDENT row [ i ] [ j ] = isEndless NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT if ( row [ i ] [ j ] and col [ i ] [ j ] ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
Hyp: 
def countEndless ( inp ) : NEW_LINE INDENT row = [ [ False for i in range ( n ) ] for j in range ( n ) ] NEW_LINE col = [ [ False for i in range ( n ) ] for j in range ( n ) ] NEW_LINE for j in range ( n ) : NEW_LINE INDENT isEndless = 1 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( inp [ i ] [ j ] == 0 ) : NEW_LINE INDENT isEndless = 0 NEW_LINE DEDENT col [ i ] [ j ] = isEndless NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT isEndless = 1 NEW_LINE for j in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( inp [ i ] [ j ] == 0 ) : NEW_LINE INDENT isEndless = 0 NEW_LINE DEDENT row [ i ] [ j ] = isEndless NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT if ( row [ i ] [ j ] and col [ i ] [ j ] ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT

BLEU: 81.23
Edit Sim: 104


Src: 
void NextFit ( int blockSize [ ] , int m , int processSize [ ] , int n ) { int allocation [ n ] , j = 0 ; memset ( allocation , - 1 , sizeof ( allocation ) ) ; for ( int i = 0 ; i < n ; i ++ ) { while ( j < m ) { if ( blockSize [ j ] >= processSize [ i ] ) { allocation [ i ] = j ; blockSize [ j ] -= processSize [ i ] ; break ; } j = ( j + 1 ) % m ; } } cout << " \n Process ▁ No . \tProcess ▁ Size\tBlock ▁ no . \n " ; for ( int i = 0 ; i < n ; i ++ ) { cout << " ▁ " << i + 1 << " \t\t " << processSize [ i ] << " \t\t " ; if ( allocation [ i ] != - 1 ) cout << allocation [ i ] + 1 ; else cout << " Not ▁ Allocated " ; cout << endl ; } }
Ref: 
def NextFit ( blockSize , m , processSize , n ) : NEW_LINE INDENT allocation = [ - 1 ] * n NEW_LINE j = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT while j < m : NEW_LINE INDENT if blockSize [ j ] >= processSize [ i ] : NEW_LINE INDENT allocation [ i ] = j NEW_LINE blockSize [ j ] -= processSize [ i ] NEW_LINE break NEW_LINE DEDENT j = ( j + 1 ) % m NEW_LINE DEDENT DEDENT print ( " Process ▁ No . ▁ Process ▁ Size ▁ Block ▁ no . " ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( i + 1 , " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " , processSize [ i ] , end = " ▁ ▁ ▁ ▁ ▁ " ) NEW_LINE if allocation [ i ] != - 1 : NEW_LINE INDENT print ( allocation [ i ] + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ Allocated " ) NEW_LINE DEDENT DEDENT DEDENT
Hyp: 
def Nextfit ( blockSize , m , processSize , n ) : NEW_LINE INDENT allocation = [ - 1 ] * n NEW_LINE j = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT while ( j < m ) : NEW_LINE INDENT if ( blockSize [ j ] >= processSize [ i ] ) : NEW_LINE INDENT allocation [ i ] = j NEW_LINE blockSize [ j ] -= processSize [ i ] NEW_LINE break NEW_LINE DEDENT j = ( j + 1 ) % m NEW_LINE DEDENT DEDENT print ( " Process ▁ No . \tProcess ▁ Size\tBlock ▁ no . " ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( " ▁ " , i + 1 , " \t\t " , processSize [ i ] , " \t\t " , if ( allocation [ i ] != - 1 ) : NEW_LINE INDENT print ( allocation [ i ] + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ Allocated " ) NEW_LINE DEDENT DEDENT

BLEU: 76.3
Edit Sim: 74


Src: 
int lenOfLongestGP ( int set [ ] , int n ) { if ( n < 2 ) return n ; if ( n == 2 ) return ( set [ 1 ] % set [ 0 ] == 0 ) ; sort ( set , set + n ) ; int L [ n ] [ n ] ; int llgp = 1 ; for ( int i = 0 ; i < n ; ++ i ) if ( set [ n - 1 ] % set [ i ] == 0 ) L [ i ] [ n - 1 ] = 2 ; else L [ i ] [ n - 1 ] = 1 ; for ( int j = n - 2 ; j >= 1 ; -- j ) { int i = j - 1 , k = j + 1 ; while ( i >= 0 && k <= n - 1 ) { if ( set [ i ] * set [ k ] < set [ j ] * set [ j ] ) ++ k ; else if ( set [ i ] * set [ k ] > set [ j ] * set [ j ] ) { if ( set [ j ] % set [ i ] == 0 ) L [ i ] [ j ] = 2 ; else L [ i ] [ j ] = 1 ; -- i ; } else { L [ i ] [ j ] = L [ j ] [ k ] + 1 ; if ( L [ i ] [ j ] > llgp ) llgp = L [ i ] [ j ] ; -- i ; ++ k ; } } while ( i >= 0 ) { if ( set [ j ] % set [ i ] == 0 ) L [ i ] [ j ] = 2 ; else L [ i ] [ j ] = 1 ; -- i ; } } return llgp ; }
Ref: 
def lenOfLongestGP ( sett , n ) : NEW_LINE INDENT if n < 2 : NEW_LINE INDENT return n NEW_LINE DEDENT if n == 2 : NEW_LINE INDENT return ( sett [ 1 ] % sett [ 0 ] == 0 ) NEW_LINE DEDENT sett . sort ( ) NEW_LINE L = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] NEW_LINE llgp = 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if sett [ n - 1 ] % sett [ i ] == 0 : NEW_LINE INDENT L [ i ] [ n - 1 ] = 2 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ n - 1 ] = 1 NEW_LINE DEDENT DEDENT for j in range ( n - 2 , 0 , - 1 ) : NEW_LINE INDENT i = j - 1 NEW_LINE k = j + 1 NEW_LINE while i >= 0 and k <= n - 1 : NEW_LINE INDENT if sett [ i ] * sett [ k ] < sett [ j ] * sett [ j ] : NEW_LINE INDENT k += 1 NEW_LINE DEDENT elif sett [ i ] * sett [ k ] > sett [ j ] * sett [ j ] : NEW_LINE INDENT if sett [ j ] % sett [ i ] == 0 : NEW_LINE INDENT L [ i ] [ j ] = 2 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] = 1 NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] = L [ j ] [ k ] + 1 NEW_LINE if L [ i ] [ j ] > llgp : NEW_LINE INDENT llgp = L [ i ] [ j ] NEW_LINE DEDENT i -= 1 NEW_LINE k + 1 NEW_LINE DEDENT DEDENT while i >= 0 : NEW_LINE INDENT if sett [ j ] % sett [ i ] == 0 : NEW_LINE INDENT L [ i ] [ j ] = 2 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] = 1 NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT DEDENT return llgp NEW_LINE DEDENT
Hyp: 
def lenOfLongestGP ( set , n ) : NEW_LINE INDENT if ( n < 2 ) : NEW_LINE INDENT return n NEW_LINE DEDENT if ( n == 2 ) : NEW_LINE INDENT return ( set [ 1 ] % set [ 0 ] == 0 ) NEW_LINE DEDENT set . sort ( ) NEW_LINE L = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] NEW_LINE llgp = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( set [ n - 1 ] % set [ i ] == 0 ) : NEW_LINE INDENT L [ i ] [ n - 1 ] = 2 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ n - 1 ] = 1 NEW_LINE DEDENT for j in range ( n - 2 , 0 , - 1 ) : NEW_LINE INDENT i = j - 1 NEW_LINE k = j + 1 NEW_LINE while ( i >= 0 and k <= n - 1 ) : NEW_LINE INDENT if ( set [ i ] * set [ k ] < set [ j ] * set [ j ] ) : NEW_LINE INDENT k += 1 NEW_LINE DEDENT elif ( set [ i ] * set [ k ] > set [ j ] * set [ j ] ) : NEW_LINE INDENT if ( set [ j ] % set [ i ] == 0 ) : NEW_LINE INDENT L [ i ] [ j ] = 2 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] = 1 NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT DEDENT return llgp NEW_LINE DEDENT

BLEU: 52.69
Edit Sim: 435


Src: 
bool checkValidity ( int a , int b , int c ) { if ( a + b <= c || a + c <= b || b + c <= a ) return false ; else return true ; }
Ref: 
def checkValidity ( a , b , c ) : NEW_LINE INDENT if ( a + b <= c ) or ( a + c <= b ) or ( b + c <= a ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT
Hyp: 
def checkValidity ( a , b , c ) : NEW_LINE INDENT if ( a + b <= c or a + c <= b or b + c <= a ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT

BLEU: 82.94
Edit Sim: 8


Src: 
bool isDDM ( int m [ N ] [ N ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int sum = 0 ; for ( int j = 0 ; j < n ; j ++ ) sum += abs ( m [ i ] [ j ] ) ; sum -= abs ( m [ i ] [ i ] ) ; if ( abs ( m [ i ] [ i ] ) < sum ) return false ; } return true ; }
Ref: 
def isDDM ( m , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT sum = sum + abs ( m [ i ] [ j ] ) NEW_LINE DEDENT sum = sum - abs ( m [ i ] [ i ] ) NEW_LINE if ( abs ( m [ i ] [ i ] ) < sum ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
Hyp: 
def isDDM ( m , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT sum += abs ( m [ i ] [ j ] ) NEW_LINE DEDENT sum -= abs ( m [ i ] [ i ] ) NEW_LINE if ( abs ( m [ i ] [ i ] ) < sum ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT

BLEU: 82.76
Edit Sim: 22


Src: 
void transpose ( int A [ ] [ N ] , int B [ ] [ N ] ) { int i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < N ; j ++ ) B [ i ] [ j ] = A [ j ] [ i ] ; }
Ref: 
def transpose ( A , B ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT B [ i ] [ j ] = A [ j ] [ i ] NEW_LINE DEDENT DEDENT DEDENT
Hyp: 
def transpose ( A , B ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT B [ i ] [ j ] = A [ j ] [ i ] NEW_LINE DEDENT DEDENT DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int returnMaxSum ( int A [ ] , int B [ ] , int n ) { unordered_set < int > mp ; int result = 0 ; int curr_sum = 0 , curr_begin = 0 ; for ( int i = 0 ; i < n ; ++ i ) { while ( mp . find ( A [ i ] ) != mp . end ( ) ) { mp . erase ( A [ curr_begin ] ) ; curr_sum -= B [ curr_begin ] ; curr_begin ++ ; } mp . insert ( A [ i ] ) ; curr_sum += B [ i ] ; result = max ( result , curr_sum ) ; } return result ; }
Ref: 
def returnMaxSum ( A , B , n ) : NEW_LINE INDENT mp = set ( ) NEW_LINE result = 0 NEW_LINE curr_sum = curr_begin = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT while A [ i ] in mp : NEW_LINE INDENT mp . remove ( A [ curr_begin ] ) NEW_LINE curr_sum -= B [ curr_begin ] NEW_LINE curr_begin += 1 NEW_LINE DEDENT mp . add ( A [ i ] ) NEW_LINE curr_sum += B [ i ] NEW_LINE result = max ( result , curr_sum ) NEW_LINE DEDENT return result NEW_LINE DEDENT
Hyp: 
def returnMaxSum ( A , B , n ) : NEW_LINE INDENT mp = set ( ) NEW_LINE result = 0 NEW_LINE curr_sum = 0 NEW_LINE curr_begin = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT while ( A [ curr_begin ] in mp ) : NEW_LINE INDENT mp . remove ( A [ curr_begin ] ) NEW_LINE curr_sum -= B [ curr_begin ] NEW_LINE curr_begin += 1 NEW_LINE DEDENT mp . add ( A [ i ] ) NEW_LINE curr_sum += B [ i ] NEW_LINE result = max ( result , curr_sum ) NEW_LINE DEDENT return result NEW_LINE DEDENT

BLEU: 88.29
Edit Sim: 28


Src: 
int sumEqualProduct ( int a [ ] , int n ) { int zero = 0 , two = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) { zero ++ ; } if ( a [ i ] == 2 ) { two ++ ; } } int cnt = ( zero * ( zero - 1 ) ) / 2 + ( two * ( two - 1 ) ) / 2 ; return cnt ; }
Ref: 
def sumEqualProduct ( a , n ) : NEW_LINE INDENT zero = 0 NEW_LINE two = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] == 0 : NEW_LINE INDENT zero += 1 NEW_LINE DEDENT if a [ i ] == 2 : NEW_LINE INDENT two += 1 NEW_LINE DEDENT DEDENT cnt = ( zero * ( zero - 1 ) ) // 2 + \ NEW_LINE INDENT ( two * ( two - 1 ) ) // 2 NEW_LINE DEDENT return cnt NEW_LINE DEDENT
Hyp: 
def sumEqualProduct ( a , n ) : NEW_LINE INDENT zero = 0 NEW_LINE two = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == 0 ) : NEW_LINE INDENT zero += 1 NEW_LINE DEDENT if ( a [ i ] == 2 ) : NEW_LINE INDENT two += 1 NEW_LINE DEDENT DEDENT cnt = ( zero * ( zero - 1 ) ) / 2 + ( two * ( two - 1 ) ) / 2 NEW_LINE return int ( cnt ) NEW_LINE DEDENT

BLEU: 76.56
Edit Sim: 41


Src: 
INT_MAX int shortestDist ( int graph [ N ] [ N ] ) { int dist [ N ] ; dist [ N - 1 ] = 0 ; for ( int i = N - 2 ; i >= 0 ; i -- ) { dist [ i ] = INF ; for ( int j = i ; j < N ; j ++ ) { if ( graph [ i ] [ j ] == INF ) continue ; dist [ i ] = min ( dist [ i ] , graph [ i ] [ j ] + dist [ j ] ) ; } } return dist [ 0 ] ; }
Ref: 
def shortestDist ( graph ) : NEW_LINE INDENT global INF NEW_LINE dist = [ 0 ] * N NEW_LINE dist [ N - 1 ] = 0 NEW_LINE for i in range ( N - 2 , - 1 , - 1 ) : NEW_LINE INDENT dist [ i ] = INF NEW_LINE for j in range ( N ) : NEW_LINE INDENT if graph [ i ] [ j ] == INF : NEW_LINE INDENT continue NEW_LINE DEDENT dist [ i ] = min ( dist [ i ] , graph [ i ] [ j ] + dist [ j ] ) NEW_LINE DEDENT DEDENT return dist [ 0 ] NEW_LINE DEDENT
Hyp: 
def shortestDist ( graph ) : NEW_LINE INDENT dist = [ None ] * N NEW_LINE dist [ N - 1 ] = 0 NEW_LINE for i in range ( N - 2 , - 1 , - 1 ) : NEW_LINE INDENT dist [ i ] = INF NEW_LINE for j in range ( i , N ) : NEW_LINE INDENT if ( graph [ i ] [ j ] == INF ) : NEW_LINE INDENT continue NEW_LINE DEDENT dist [ i ] = min ( dist [ i ] , graph [ i ] [ j ] + dist [ j ] ) NEW_LINE DEDENT DEDENT return dist [ 0 ] NEW_LINE DEDENT

BLEU: 88.89
Edit Sim: 32


Src: 
long long int calculateSum ( int n ) { long long int sum = 0 ; sum = 1 << n ; return ( sum - 1 ) ; }
Ref: 
def calculateSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE sum = 1 << n NEW_LINE return ( sum - 1 ) NEW_LINE DEDENT
Hyp: 
def calculateSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE sum = 1 << n NEW_LINE return ( sum - 1 ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 || n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
Ref: 
def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return True NEW_LINE DEDENT
Hyp: 
def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return True NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
void fib ( int n ) { int a = 0 , b = 1 ; if ( n >= 0 ) cout << a << " ▁ " ; if ( n >= 1 ) cout << b << " ▁ " ; for ( int i = 2 ; i <= n ; i ++ ) { cout << a + b << " ▁ " ; b = a + b ; a = b - a ; } }
Ref: 
def fib ( n ) : NEW_LINE INDENT a = 0 NEW_LINE b = 1 NEW_LINE if ( n >= 0 ) : NEW_LINE INDENT print ( a , end = ' ▁ ' ) NEW_LINE DEDENT if ( n >= 1 ) : NEW_LINE INDENT print ( b , end = ' ▁ ' ) NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT print ( a + b , end = ' ▁ ' ) NEW_LINE b = a + b NEW_LINE a = b - a NEW_LINE DEDENT DEDENT
Hyp: 
def fib ( n ) : NEW_LINE INDENT a = 0 NEW_LINE b = 1 NEW_LINE if n >= 0 : NEW_LINE INDENT print ( a , end = " ▁ " ) NEW_LINE DEDENT if n >= 1 : NEW_LINE INDENT print ( b , end = " ▁ " ) NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT print ( a + b , end = " ▁ " ) NEW_LINE b = a + b NEW_LINE a = b - a NEW_LINE DEDENT DEDENT

BLEU: 76.2
Edit Sim: 14


Src: 
int kthdigit ( int a , int b , int k ) { int p = pow ( a , b ) ; int count = 0 ; while ( p > 0 && count < k ) { int rem = p % 10 ; count ++ ; if ( count == k ) return rem ; p = p / 10 ; } return 0 ; }
Ref: 
def kthdigit ( a , b , k ) : NEW_LINE INDENT p = a ** b NEW_LINE count = 0 NEW_LINE while ( p > 0 and count < k ) : NEW_LINE INDENT rem = p % 10 NEW_LINE count = count + 1 NEW_LINE if ( count == k ) : NEW_LINE INDENT return rem NEW_LINE DEDENT p = p / 10 NEW_LINE DEDENT DEDENT
Hyp: 
def kthdigit ( a , b , k ) : NEW_LINE INDENT p = pow ( a , b ) NEW_LINE count = 0 NEW_LINE while ( p > 0 and count < k ) : NEW_LINE INDENT rem = p % 10 NEW_LINE count += 1 NEW_LINE if ( count == k ) : NEW_LINE INDENT return rem NEW_LINE DEDENT p = p // 10 NEW_LINE DEDENT return 0 NEW_LINE DEDENT

BLEU: 77.6
Edit Sim: 38


Src: 
bool isEven ( int n ) { return ( ! ( n & 1 ) ) ; }
Ref: 
def isEven ( n ) : NEW_LINE INDENT return ( not ( n & 1 ) ) NEW_LINE DEDENT
Hyp: 
def isEven ( n ) : NEW_LINE INDENT return ( not ( n & 1 ) ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
void printPath ( string str ) { int i = 0 ; int curX = 0 , curY = 0 ; while ( i < str . length ( ) ) { int nextX = ( str [ i ] - ' A ' ) / 5 ; int nextY = ( str [ i ] - ' B ' + 1 ) % 5 ; while ( curX > nextX ) { cout << " Move ▁ Up " << endl ; curX -- ; } while ( curY > nextY ) { cout << " Move ▁ Left " << endl ; curY -- ; } while ( curX < nextX ) { cout << " Move ▁ Down " << endl ; curX ++ ; } while ( curY < nextY ) { cout << " Move ▁ Right " << endl ; curY ++ ; } cout << " Press ▁ OK " << endl ; i ++ ; } }
Ref: 
def printPath ( str ) : NEW_LINE INDENT i = 0 NEW_LINE curX = 0 NEW_LINE curY = 0 NEW_LINE while ( i < len ( str ) ) : NEW_LINE INDENT nextX = int ( ( ord ( str [ i ] ) - ord ( ' A ' ) ) / 5 ) NEW_LINE nextY = ( ord ( str [ i ] ) - ord ( ' B ' ) + 1 ) % 5 NEW_LINE while ( curX > nextX ) : NEW_LINE INDENT print ( " Move ▁ Up " ) NEW_LINE curX -= 1 NEW_LINE DEDENT while ( curY > nextY ) : NEW_LINE INDENT print ( " Move ▁ Left " ) NEW_LINE curY -= 1 NEW_LINE DEDENT while ( curX < nextX ) : NEW_LINE INDENT print ( " Move ▁ Down " ) NEW_LINE curX += 1 NEW_LINE DEDENT while ( curY < nextY ) : NEW_LINE INDENT print ( " Move ▁ Right " ) NEW_LINE curY += 1 NEW_LINE DEDENT print ( " Press ▁ OK " ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT
Hyp: 
def printPath ( str ) : NEW_LINE INDENT i = 0 NEW_LINE curX = 0 NEW_LINE curY = 0 NEW_LINE while i < len ( str ) : NEW_LINE INDENT nextX = int ( ( str [ i ] - ord ( ' A ' ) ) / 5 ) NEW_LINE nextY = int ( ( str [ i ] - ord ( ' B ' ) + 1 ) % 5 ) NEW_LINE while ( curX > nextX ) : NEW_LINE INDENT print ( " Move ▁ Up " , endl ) NEW_LINE curX -= 1 NEW_LINE DEDENT while ( curY > nextY ) : NEW_LINE INDENT print ( " Move ▁ Left " , endl , curY -= 1 NEW_LINE DEDENT while ( curX < nextX ) : NEW_LINE INDENT print ( " Move ▁ Down " , endl ) NEW_LINE curX += 1 NEW_LINE DEDENT while ( curY < nextY ) : NEW_LINE INDENT print ( " Move ▁ Right " , endl ) NEW_LINE curY += 1 NEW_LINE DEDENT print ( " Press ▁ OK " ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT

BLEU: 85.7
Edit Sim: 51


Src: 
bool checkcircle ( int r , int R , int r1 , int x1 , int y1 ) { int dis = sqrt ( x1 * x1 + y1 * y1 ) ; return ( dis - r1 >= R && dis + r1 <= r ) ; }
Ref: 
def checkcircle ( r , R , r1 , x1 , y1 ) : NEW_LINE INDENT dis = int ( math . sqrt ( x1 * x1 + y1 * y1 ) ) NEW_LINE return ( dis - r1 >= R and dis + r1 <= r ) NEW_LINE DEDENT
Hyp: 
def checkcircle ( R , r1 , x1 , y1 ) : NEW_LINE INDENT dis = ( math . sqrt ( x1 * x1 + y1 * y1 ) ) NEW_LINE return ( dis - r1 >= R and dis + r1 <= r ) NEW_LINE DEDENT

BLEU: 87.53
Edit Sim: 8


Src: 
bool isMinHeap ( int level [ ] , int n ) { for ( int i = ( n / 2 - 1 ) ; i >= 0 ; i -- ) { if ( level [ i ] > level [ 2 * i + 1 ] ) return false ; if ( 2 * i + 2 < n ) { if ( level [ i ] > level [ 2 * i + 2 ] ) return false ; } } return true ; }
Ref: 
def isMinHeap ( level , n ) : NEW_LINE INDENT for i in range ( int ( n / 2 ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if level [ i ] > level [ 2 * i + 1 ] : NEW_LINE INDENT return False NEW_LINE DEDENT if 2 * i + 2 < n : NEW_LINE INDENT if level [ i ] > level [ 2 * i + 2 ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT
Hyp: 
def isMinHeap ( level , n ) : NEW_LINE INDENT for i in range ( ( n // 2 - 1 ) , - 1 , - 1 ) : NEW_LINE INDENT if ( level [ i ] > level [ 2 * i + 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( 2 * i + 2 < n ) : NEW_LINE INDENT if ( level [ i ] > level [ 2 * i + 2 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT

BLEU: 76.86
Edit Sim: 20


Src: 
void thirdLargest ( int arr [ ] , int arr_size ) { if ( arr_size < 3 ) { printf ( " ▁ Invalid ▁ Input ▁ " ) ; return ; } int first = arr [ 0 ] ; for ( int i = 1 ; i < arr_size ; i ++ ) if ( arr [ i ] > first ) first = arr [ i ] ; int second = INT_MIN ; for ( int i = 0 ; i < arr_size ; i ++ ) if ( arr [ i ] > second && arr [ i ] < first ) second = arr [ i ] ; int third = INT_MIN ; for ( int i = 0 ; i < arr_size ; i ++ ) if ( arr [ i ] > third && arr [ i ] < second ) third = arr [ i ] ; printf ( " The ▁ third ▁ Largest ▁ element ▁ is ▁ % d \n " , third ) ; }
Ref: 
def thirdLargest ( arr , arr_size ) : NEW_LINE INDENT if ( arr_size < 3 ) : NEW_LINE INDENT print ( " ▁ Invalid ▁ Input ▁ " ) NEW_LINE return NEW_LINE DEDENT first = arr [ 0 ] NEW_LINE for i in range ( 1 , arr_size ) : NEW_LINE INDENT if ( arr [ i ] > first ) : NEW_LINE INDENT first = arr [ i ] NEW_LINE DEDENT DEDENT second = - sys . maxsize NEW_LINE for i in range ( 0 , arr_size ) : NEW_LINE INDENT if ( arr [ i ] > second and arr [ i ] < first ) : NEW_LINE INDENT second = arr [ i ] NEW_LINE DEDENT DEDENT third = - sys . maxsize NEW_LINE for i in range ( 0 , arr_size ) : NEW_LINE INDENT if ( arr [ i ] > third and arr [ i ] < second ) : NEW_LINE INDENT third = arr [ i ] NEW_LINE DEDENT DEDENT print ( " The ▁ Third ▁ Largest " , " element ▁ is " , third ) NEW_LINE DEDENT
Hyp: 
def thirdLargest ( arr , arr_size ) : NEW_LINE INDENT if arr_size < 3 : NEW_LINE INDENT print ( " ▁ Invalid ▁ Input ▁ " ) NEW_LINE return NEW_LINE DEDENT first = arr [ 0 ] NEW_LINE for i in range ( 1 , arr_size ) : NEW_LINE INDENT if arr [ i ] > first : NEW_LINE INDENT first = arr [ i ] NEW_LINE DEDENT DEDENT second = INT_MIN NEW_LINE for i in range ( 0 , arr_size ) : NEW_LINE INDENT if arr [ i ] > second and arr [ i ] < first : NEW_LINE INDENT second = arr [ i ] NEW_LINE DEDENT DEDENT third = INT_MIN NEW_LINE for i in range ( 0 , arr_size ) : NEW_LINE INDENT if arr [ i ] > third and arr [ i ] < second : NEW_LINE INDENT third = arr [ i ] NEW_LINE DEDENT DEDENT print ( " The ▁ third ▁ Largest ▁ element ▁ is " , third ) NEW_LINE DEDENT

BLEU: 79.09
Edit Sim: 52


Src: 
int maxHamming ( int arr [ ] , int n ) { int brr [ 2 * n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) brr [ i ] = arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) brr [ n + i ] = arr [ i ] ; int maxHam = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int currHam = 0 ; for ( int j = i , k = 0 ; j < ( i + n ) ; j ++ , k ++ ) if ( brr [ j ] != arr [ k ] ) currHam ++ ; if ( currHam == n ) return n ; maxHam = max ( maxHam , currHam ) ; } return maxHam ; }
Ref: 
def maxHamming ( arr , n ) : NEW_LINE INDENT brr = [ 0 ] * ( 2 * n + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT brr [ i ] = arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT brr [ n + i ] = arr [ i ] NEW_LINE DEDENT maxHam = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT currHam = 0 NEW_LINE k = 0 NEW_LINE for j in range ( i , i + n ) : NEW_LINE INDENT if brr [ j ] != arr [ k ] : NEW_LINE INDENT currHam += 1 NEW_LINE k = k + 1 NEW_LINE DEDENT DEDENT if currHam == n : NEW_LINE INDENT return n NEW_LINE DEDENT maxHam = max ( maxHam , currHam ) NEW_LINE DEDENT return maxHam NEW_LINE DEDENT
Hyp: 
def maxHamming ( arr , n ) : NEW_LINE INDENT brr = [ 0 ] * ( 2 * n + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT brr [ i ] = arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT brr [ n + i ] = arr [ i ] NEW_LINE DEDENT maxHam = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT currHam = 0 NEW_LINE for j in range ( i , ( i + n ) ) : NEW_LINE INDENT if ( brr [ j ] != arr [ k ] ) : NEW_LINE INDENT currHam += 1 NEW_LINE DEDENT DEDENT if ( currHam == n ) : NEW_LINE INDENT return n NEW_LINE DEDENT maxHam = max ( maxHam , currHam ) NEW_LINE DEDENT return maxHam NEW_LINE DEDENT

BLEU: 88.28
Edit Sim: 46


Src: 
int findSum ( int N , int K ) { int ans = 0 ; for ( int i = 1 ; i <= N ; i ++ ) ans += ( i % K ) ; return ans ; }
Ref: 
def findSum ( N , K ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT ans += ( i % K ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
Hyp: 
def findSum ( N , K ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT ans += ( i % K ) NEW_LINE DEDENT return ans NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
double seriesSum ( int n ) { int i = 1 ; double res = 0.0 ; bool sign = true ; while ( n > 0 ) { n -- ; if ( sign ) { sign = ! sign ; res = res + ( double ) ++ i / ++ i ; } else { sign = ! sign ; res = res - ( double ) ++ i / ++ i ; } } return res ; }
Ref: 
def seriesSum ( n ) : NEW_LINE INDENT i = 1 NEW_LINE res = 0.0 NEW_LINE sign = True NEW_LINE while ( n > 0 ) : NEW_LINE INDENT n = n - 1 NEW_LINE if ( sign ) : NEW_LINE INDENT sign = False NEW_LINE res = res + ( i + 1 ) / ( i + 2 ) NEW_LINE i = i + 2 NEW_LINE DEDENT else : NEW_LINE INDENT sign = True NEW_LINE res = res - ( i + 1 ) / ( i + 2 ) NEW_LINE i = i + 2 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
Hyp: 
def seriesSum ( n ) : NEW_LINE INDENT i = 1 NEW_LINE res = 0.0 NEW_LINE sign = True NEW_LINE while ( n > 0 ) : NEW_LINE INDENT n -= 1 NEW_LINE if ( sign ) : NEW_LINE INDENT sign = not sign NEW_LINE res = res + ( double ) ++ i / i NEW_LINE DEDENT else : NEW_LINE INDENT sign = not sign NEW_LINE res = res - ( double ) ++ i / i NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT

BLEU: 57.32
Edit Sim: 80


Src: 
int countSetBits ( int n ) { int i = 0 ; int ans = 0 ; while ( ( 1 << i ) <= n ) { bool k = 0 ; int change = 1 << i ; for ( int j = 0 ; j <= n ; j ++ ) { ans += k ; if ( change == 1 ) { k = ! k ; change = 1 << i ; } else { change -- ; } } i ++ ; } return ans ; }
Ref: 
def countSetBits ( n ) : NEW_LINE INDENT i = 0 NEW_LINE ans = 0 NEW_LINE while ( ( 1 << i ) <= n ) : NEW_LINE INDENT k = 0 NEW_LINE change = 1 << i NEW_LINE for j in range ( 0 , n + 1 ) : NEW_LINE INDENT ans += k NEW_LINE if change == 1 : NEW_LINE INDENT k = not k NEW_LINE change = 1 << i NEW_LINE DEDENT else : NEW_LINE INDENT change -= 1 NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
Hyp: 
def countSetBits ( n ) : NEW_LINE INDENT i = 0 NEW_LINE ans = 0 NEW_LINE while ( ( 1 << i ) <= n ) : NEW_LINE INDENT k = 0 NEW_LINE change = 1 << i NEW_LINE for j in range ( 0 , n + 1 ) : NEW_LINE INDENT ans += k NEW_LINE if ( change == 1 ) : NEW_LINE INDENT k = not k NEW_LINE change = 1 << i NEW_LINE DEDENT else : NEW_LINE INDENT change -= 1 NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT

BLEU: 94.76
Edit Sim: 4


Src: 
int getPairsCount ( int arr [ ] , int n , int sum ) { unordered_map < int , int > m ; for ( int i = 0 ; i < n ; i ++ ) m [ arr [ i ] ] ++ ; int twice_count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { twice_count += m [ sum - arr [ i ] ] ; if ( sum - arr [ i ] == arr [ i ] ) twice_count -- ; } return twice_count / 2 ; }
Ref: 
def getPairsCount ( arr , n , sum ) : NEW_LINE INDENT m = [ 0 ] * 1000 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT m [ arr [ i ] ] NEW_LINE m [ arr [ i ] ] += 1 NEW_LINE DEDENT twice_count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT twice_count += m [ sum - arr [ i ] ] NEW_LINE if ( sum - arr [ i ] == arr [ i ] ) : NEW_LINE INDENT twice_count -= 1 NEW_LINE DEDENT DEDENT return int ( twice_count / 2 ) NEW_LINE DEDENT
Hyp: 
def getPairsCount ( arr , n , sum ) : NEW_LINE INDENT mp = defaultdict ( lambda : 0 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT twice_count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT twice_count += mp [ sum - arr [ i ] ] NEW_LINE if ( sum - arr [ i ] == arr [ i ] ) : NEW_LINE INDENT twice_count -= 1 NEW_LINE DEDENT DEDENT return int ( twice_count / 2 ) NEW_LINE DEDENT

BLEU: 73.99
Edit Sim: 57


Src: 
bool isDiagonalMatrix ( int mat [ N ] [ N ] ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) if ( ( i != j ) && ( mat [ i ] [ j ] != 0 ) ) return false ; return true ; }
Ref: 
def isDiagonalMatrix ( mat ) : NEW_LINE INDENT for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( 0 , N ) : NEW_LINE INDENT if ( ( i != j ) and ( mat [ i ] [ j ] != 0 ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT
Hyp: 
def isDiagonalMatrix ( mat ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if ( ( i != j ) and ( mat [ i ] [ j ] != 0 ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT

BLEU: 88.87
Edit Sim: 8


Src: 
void printSorted ( int a , int b , int c ) { int get_max = max ( a , max ( b , c ) ) ; int get_min = - max ( - a , max ( - b , - c ) ) ; int get_mid = ( a + b + c ) - ( get_max + get_min ) ; cout << get_min << " ▁ " << get_mid << " ▁ " << get_max ; }
Ref: 
def printSorted ( a , b , c ) : NEW_LINE INDENT get_max = max ( a , max ( b , c ) ) NEW_LINE get_min = - max ( - a , max ( - b , - c ) ) NEW_LINE get_mid = ( a + b + c ) - ( get_max + get_min ) NEW_LINE print ( get_min , " ▁ " , get_mid , " ▁ " , get_max ) NEW_LINE DEDENT
Hyp: 
def printSorted ( a , b , c ) : NEW_LINE INDENT get_max = max ( a , b , c ) NEW_LINE get_min = - max ( - a , max ( - b , - c ) ) NEW_LINE get_mid = ( a + b + c ) - ( get_max + get_min ) NEW_LINE print ( get_min , " ▁ " , get_mid , " ▁ " , get_max ) NEW_LINE DEDENT

BLEU: 93.11
Edit Sim: 8


Src: 
bool isDivisible ( long long int n ) { while ( n / 100 ) { int last_digit = n % 10 ; n /= 10 ; n += last_digit * 3 ; } return ( n % 29 == 0 ) ; }
Ref: 
def isDivisible ( n ) : NEW_LINE INDENT while ( int ( n / 100 ) ) : NEW_LINE INDENT last_digit = int ( n % 10 ) NEW_LINE n = int ( n / 10 ) NEW_LINE n += last_digit * 3 NEW_LINE DEDENT return ( n % 29 == 0 ) NEW_LINE DEDENT
Hyp: 
def isDivisible ( n ) : NEW_LINE INDENT while ( n // 100 ) : NEW_LINE INDENT last_digit = n % 10 NEW_LINE n = n // 10 NEW_LINE n += last_digit * 3 NEW_LINE DEDENT return ( n % 29 == 0 ) NEW_LINE DEDENT

BLEU: 61.94
Edit Sim: 24


Src: 
int getSingle ( int arr [ ] , int n ) { int ones = 0 , twos = 0 ; int common_bit_mask ; for ( int i = 0 ; i < n ; i ++ ) { twos = twos | ( ones & arr [ i ] ) ; ones = ones ^ arr [ i ] ; common_bit_mask = ~ ( ones & twos ) ; ones &= common_bit_mask ; twos &= common_bit_mask ; } return ones ; }
Ref: 
def getSingle ( arr , n ) : NEW_LINE INDENT ones = 0 NEW_LINE twos = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT twos = twos | ( ones & arr [ i ] ) NEW_LINE ones = ones ^ arr [ i ] NEW_LINE common_bit_mask = ~ ( ones & twos ) NEW_LINE ones &= common_bit_mask NEW_LINE twos &= common_bit_mask NEW_LINE DEDENT return ones NEW_LINE DEDENT
Hyp: 
def getSingle ( arr , n ) : NEW_LINE INDENT ones = 0 NEW_LINE twos = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT twos = twos | ( ones & arr [ i ] ) NEW_LINE ones = ones ^ arr [ i ] NEW_LINE common_bit_mask = ~ ( ones & twos ) NEW_LINE ones &= common_bit_mask NEW_LINE twos &= common_bit_mask NEW_LINE DEDENT return ones NEW_LINE DEDENT

BLEU: 95.2
Edit Sim: 4


Src: 
int minSumPath ( vector < vector < int > > & A ) { int memo [ A . size ( ) ] ; int n = A . size ( ) - 1 ; for ( int i = 0 ; i < A [ n ] . size ( ) ; i ++ ) memo [ i ] = A [ n ] [ i ] ; for ( int i = A . size ( ) - 2 ; i >= 0 ; i -- ) for ( int j = 0 ; j < A [ i ] . size ( ) ; j ++ ) memo [ j ] = A [ i ] [ j ] + min ( memo [ j ] , memo [ j + 1 ] ) ; return memo [ 0 ] ; }
Ref: 
def minSumPath ( A ) : NEW_LINE INDENT memo = [ None ] * len ( A ) NEW_LINE n = len ( A ) - 1 NEW_LINE for i in range ( len ( A [ n ] ) ) : NEW_LINE INDENT memo [ i ] = A [ n ] [ i ] NEW_LINE DEDENT for i in range ( len ( A ) - 2 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( len ( A [ i ] ) ) : NEW_LINE INDENT memo [ j ] = A [ i ] [ j ] + min ( memo [ j ] , memo [ j + 1 ] ) ; NEW_LINE DEDENT DEDENT return memo [ 0 ] NEW_LINE DEDENT
Hyp: 
def minSumPath ( A ) : NEW_LINE INDENT memo = [ 0 ] * ( len ( A ) ) NEW_LINE n = len ( A ) - 1 NEW_LINE for i in range ( len ( A [ n ] ) ) : NEW_LINE INDENT memo [ i ] = A [ n ] [ i ] NEW_LINE DEDENT for i in range ( len ( A ) - 2 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( len ( A [ i ] ) ) : NEW_LINE INDENT memo [ j ] = A [ i ] [ j ] + min ( memo [ j ] , memo [ j + 1 ] ) NEW_LINE DEDENT DEDENT return memo [ 0 ] NEW_LINE DEDENT

BLEU: 93.94
Edit Sim: 10


Src: 
void GFG :: rearrange ( int arr [ ] , int n ) { int i = - 1 ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] < 0 ) { i ++ ; swap ( & arr [ i ] , & arr [ j ] ) ; } } int pos = i + 1 , neg = 0 ; while ( pos < n && neg < pos && arr [ neg ] < 0 ) { swap ( & arr [ neg ] , & arr [ pos ] ) ; pos ++ ; neg += 2 ; } }
Ref: 
def rearrange ( arr , n ) : NEW_LINE INDENT i = - 1 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( arr [ j ] < 0 ) : NEW_LINE INDENT i += 1 NEW_LINE arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ] NEW_LINE DEDENT DEDENT pos , neg = i + 1 , 0 NEW_LINE while ( pos < n and neg < pos and arr [ neg ] < 0 ) : NEW_LINE INDENT arr [ neg ] , arr [ pos ] = arr [ pos ] , arr [ neg ] NEW_LINE pos += 1 NEW_LINE neg += 2 NEW_LINE DEDENT DEDENT
Hyp: 
def rearrange ( arr , n ) : NEW_LINE INDENT i = - 1 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if arr [ j ] < 0 : NEW_LINE INDENT i += 1 NEW_LINE arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ] NEW_LINE DEDENT DEDENT pos = i + 1 NEW_LINE neg = 0 NEW_LINE while pos < n and neg < pos and arr [ neg ] < 0 : NEW_LINE INDENT arr [ neg ] , arr [ pos ] = arr [ pos ] , arr [ neg ] NEW_LINE pos += 1 NEW_LINE neg += 2 NEW_LINE DEDENT DEDENT

BLEU: 87.05
Edit Sim: 25


Src: 
int countNum ( int arr [ ] , int n ) { int count = 0 ; sort ( arr , arr + n ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] != arr [ i + 1 ] && arr [ i ] != arr [ i + 1 ] - 1 ) count += arr [ i + 1 ] - arr [ i ] - 1 ; return count ; }
Ref: 
def countNum ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE arr . sort ( ) NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( arr [ i ] != arr [ i + 1 ] and arr [ i ] != arr [ i + 1 ] - 1 ) : NEW_LINE INDENT count += arr [ i + 1 ] - arr [ i ] - 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
Hyp: 
def countNum ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE arr . sort ( ) NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( arr [ i ] != arr [ i + 1 ] and arr [ i ] != arr [ i + 1 ] - 1 ) : NEW_LINE INDENT count += arr [ i + 1 ] - arr [ i ] - 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int largestGCDSubsequence ( int arr [ ] , int n ) { int ans = 0 ; int maxele = * max_element ( arr , arr + n ) ; for ( int i = 2 ; i <= maxele ; ++ i ) { int count = 0 ; for ( int j = 0 ; j < n ; ++ j ) { if ( arr [ j ] % i == 0 ) ++ count ; } ans = max ( ans , count ) ; } return ans ; }
Ref: 
def largestGCDSubsequence ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE maxele = max ( arr ) NEW_LINE for i in range ( 2 , maxele + 1 ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( arr [ j ] % i == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT ans = max ( ans , count ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
Hyp: 
def largestGCDSubsequence ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE maxele = max ( arr ) NEW_LINE for i in range ( 2 , maxele + 1 ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if arr [ j ] % i == 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT ans = max ( ans , count ) NEW_LINE DEDENT return ans NEW_LINE DEDENT

BLEU: 93.85
Edit Sim: 4


Src: 
bool isNumber ( string s ) { for ( int i = 0 ; i < s . length ( ) ; i ++ ) if ( isdigit ( s [ i ] ) == false ) return false ; return true ; }
Ref: 
def isNumber ( s ) : NEW_LINE INDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] . isdigit ( ) != True : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
Hyp: 
def isNumber ( s ) : NEW_LINE INDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] . isdigit ( ) == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT

BLEU: 84.32
Edit Sim: 9


Src: 
int countPairs ( int arr1 [ ] , int arr2 [ ] , int m , int n , int x ) { int count = 0 ; unordered_set < int > us ; for ( int i = 0 ; i < m ; i ++ ) us . insert ( arr1 [ i ] ) ; for ( int j = 0 ; j < n ; j ++ ) if ( us . find ( x - arr2 [ j ] ) != us . end ( ) ) count ++ ; return count ; }
Ref: 
def countPairs ( arr1 , arr2 , m , n , x ) : NEW_LINE INDENT count = 0 NEW_LINE us = set ( ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT us . add ( arr1 [ i ] ) NEW_LINE DEDENT for j in range ( n ) : NEW_LINE INDENT if x - arr2 [ j ] in us : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
Hyp: 
def countPairs ( arr1 , arr2 , m , n , x ) : NEW_LINE INDENT count = 0 NEW_LINE us = set ( ) NEW_LINE for i in range ( 0 , m ) : NEW_LINE INDENT us . add ( arr1 [ i ] ) NEW_LINE DEDENT for j in range ( 0 , n ) : NEW_LINE INDENT if ( ( x - arr2 [ j ] ) in us ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT

BLEU: 82.05
Edit Sim: 16


Src: 
int countSquares ( int a , int b ) { int cnt = 0 ; for ( int i = a ; i <= b ; i ++ ) for ( int j = 1 ; j * j <= i ; j ++ ) if ( j * j == i ) cnt ++ ; return cnt ; }
Ref: 
def CountSquares ( a , b ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( a , b + 1 ) : NEW_LINE INDENT j = 1 ; NEW_LINE while j * j <= i : NEW_LINE INDENT if j * j == i : NEW_LINE INDENT cnt = cnt + 1 NEW_LINE DEDENT j = j + 1 NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT return cnt NEW_LINE DEDENT
Hyp: 
def countSquares ( a , b ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( a , b + 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT if ( j * j == i ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT

BLEU: 52.86
Edit Sim: 75


Src: 
int minSum ( int n ) { int sum = 0 ; while ( n > 0 ) { sum += ( n % 10 ) ; n /= 10 ; } if ( sum == 1 ) return 10 ; return sum ; }
Ref: 
def minSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT sum += ( n % 10 ) NEW_LINE n //= 10 NEW_LINE DEDENT if ( sum == 1 ) : NEW_LINE INDENT return 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT
Hyp: 
def minSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT sum += ( n % 10 ) NEW_LINE n = int ( n / 10 ) NEW_LINE DEDENT if ( sum == 1 ) : NEW_LINE INDENT return 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT

BLEU: 85.03
Edit Sim: 13


Src: 
int nonFibonacci ( int n ) { int prevPrev = 1 , prev = 2 , curr = 3 ; while ( n > 0 ) { prevPrev = prev ; prev = curr ; curr = prevPrev + prev ; n = n - ( curr - prev - 1 ) ; } n = n + ( curr - prev - 1 ) ; return prev + n ; }
Ref: 
def nonFibonacci ( n ) : NEW_LINE INDENT prevPrev = 1 NEW_LINE prev = 2 NEW_LINE curr = 3 NEW_LINE while n > 0 : NEW_LINE INDENT prevPrev = prev NEW_LINE prev = curr NEW_LINE curr = prevPrev + prev NEW_LINE n = n - ( curr - prev - 1 ) NEW_LINE DEDENT n = n + ( curr - prev - 1 ) NEW_LINE return prev + n NEW_LINE DEDENT
Hyp: 
def nonFibonacci ( n ) : NEW_LINE INDENT prevPrev , prev , curr = 1 , 2 , 3 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT prevPrev = prev NEW_LINE prev = curr NEW_LINE curr = prevPrev + prev NEW_LINE n = n - ( curr - prev - 1 ) NEW_LINE DEDENT n = n + ( curr - prev - 1 ) NEW_LINE return prev + n NEW_LINE DEDENT

BLEU: 80.84
Edit Sim: 32


Src: 
int lis ( int arr [ ] , int n ) { int lis [ n ] ; lis [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { lis [ i ] = 1 ; for ( int j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; } return * max_element ( lis , lis + n ) ; }
Ref: 
def lis ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE lis = [ 1 ] * n NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( 0 , i ) : NEW_LINE INDENT if arr [ i ] > arr [ j ] and lis [ i ] < lis [ j ] + 1 : NEW_LINE INDENT lis [ i ] = lis [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT maximum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT maximum = max ( maximum , lis [ i ] ) NEW_LINE DEDENT return maximum NEW_LINE DEDENT
Hyp: 
def lis ( arr , n ) : NEW_LINE INDENT lis = [ 0 for i in range ( n ) ] NEW_LINE lis [ 0 ] = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT lis [ i ] = 1 NEW_LINE for j in range ( i ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and lis [ i ] < lis [ j ] + 1 ) : NEW_LINE INDENT lis [ i ] = lis [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT return max ( lis , lis + n ) NEW_LINE DEDENT

BLEU: 65.88
Edit Sim: 171


Src: 
void leftRotate ( int arr [ ] , int n , int k ) { for ( int i = k ; i < k + n ; i ++ ) cout << arr [ i % n ] << " ▁ " ; }
Ref: 
def leftRotate ( arr , n , k ) : NEW_LINE INDENT for i in range ( k , k + n ) : NEW_LINE INDENT print ( str ( arr [ i % n ] ) , end = " ▁ " ) NEW_LINE DEDENT DEDENT
Hyp: 
def leftRotate ( arr , n , k ) : NEW_LINE INDENT for i in range ( k , k + n ) : NEW_LINE INDENT print ( arr [ i % n ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT

BLEU: 88.36
Edit Sim: 8


Src: 
string repeat ( string s , int n ) { string s1 = s ; for ( int i = 1 ; i < n ; i ++ ) s += s1 ; return s ; }
Ref: 
def repeat ( s , n ) : NEW_LINE INDENT s1 = s NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT s += s1 NEW_LINE DEDENT return s NEW_LINE DEDENT
Hyp: 
def repeat ( s , n ) : NEW_LINE INDENT s1 = s NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT s = s1 + s ; NEW_LINE DEDENT return s1 NEW_LINE DEDENT

BLEU: 78.76
Edit Sim: 8


Src: 
string findSubString ( string str ) { int n = str . length ( ) ; int dist_count = 0 ; bool visited [ MAX_CHARS ] = { false } ; for ( int i = 0 ; i < n ; i ++ ) { if ( visited [ str [ i ] ] == false ) { visited [ str [ i ] ] = true ; dist_count ++ ; } } int start = 0 , start_index = - 1 , min_len = INT_MAX ; int count = 0 ; int curr_count [ MAX_CHARS ] = { 0 } ; for ( int j = 0 ; j < n ; j ++ ) { curr_count [ str [ j ] ] ++ ; if ( curr_count [ str [ j ] ] == 1 ) count ++ ; if ( count == dist_count ) { while ( curr_count [ str [ start ] ] > 1 ) { if ( curr_count [ str [ start ] ] > 1 ) curr_count [ str [ start ] ] -- ; start ++ ; } int len_window = j - start + 1 ; if ( min_len > len_window ) { min_len = len_window ; start_index = start ; } } } return str . substr ( start_index , min_len ) ; }
Ref: 
def findSubString ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE dist_count = len ( set ( [ x for x in str ] ) ) NEW_LINE count , start , start_index , min_len = 0 , 0 , - 1 , 9999999999 NEW_LINE curr_count = defaultdict ( lambda : 0 ) NEW_LINE for j in range ( n ) : NEW_LINE INDENT curr_count [ str [ j ] ] += 1 NEW_LINE if curr_count [ str [ j ] ] == 1 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if count == dist_count : NEW_LINE INDENT while curr_count [ str [ start ] ] > 1 : NEW_LINE INDENT if curr_count [ str [ start ] ] > 1 : NEW_LINE INDENT curr_count [ str [ start ] ] -= 1 NEW_LINE DEDENT start += 1 NEW_LINE DEDENT len_window = j - start + 1 NEW_LINE if min_len > len_window : NEW_LINE INDENT min_len = len_window NEW_LINE start_index = start NEW_LINE DEDENT DEDENT DEDENT return str [ start_index : start_index + min_len ] NEW_LINE DEDENT
Hyp: 
def findSubString ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE dist_count = 0 NEW_LINE visited = [ False ] * MAX_CHARS NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( visited [ ord ( str [ i ] ) ] == False ) : NEW_LINE INDENT visited [ ord ( str [ i ] ) ] = True NEW_LINE dist_count += 1 NEW_LINE DEDENT DEDENT start = 0 NEW_LINE start_index = - 1 NEW_LINE min_len = sys . maxsize NEW_LINE count = 0 NEW_LINE curr_count = [ 0 ] * MAX_CHARS NEW_LINE for j in range ( n ) : NEW_LINE INDENT curr_count [ ord ( str [ j ] ) ] += 1 NEW_LINE if ( curr_count [ ord ( str [ j ] ) ] == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( count == dist_count ) : NEW_LINE INDENT while ( curr_count [ ord ( str [ start ] ) ] > 1 ) : NEW_LINE INDENT if ( curr_count [ ord ( str [ start ] ) ] > 1 ) : NEW_LINE INDENT curr_count [ ord ( str [ start ] ) ] -= 1 NEW_LINE start += 1 NEW_LINE DEDENT DEDENT len_window = j - start + 1 NEW_LINE if ( min_len > len_window ) : NEW_LINE INDENT min_len = len_window NEW_LINE start_index = start NEW_LINE DEDENT DEDENT DEDENT return str [ start_index : start_index + min_len ) NEW_LINE DEDENT

BLEU: 43.4
Edit Sim: 358


Src: 
public : int findStep ( int n ) { if ( n == 1 || n == 0 ) return 1 ; else if ( n == 2 ) return 2 ; else return findStep ( n - 3 ) + findStep ( n - 2 ) + findStep ( n - 1 ) ; }
Ref: 
def findStep ( n ) : NEW_LINE INDENT if ( n == 1 or n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( n == 2 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT else : NEW_LINE INDENT return findStep ( n - 3 ) + findStep ( n - 2 ) + findStep ( n - 1 ) NEW_LINE DEDENT DEDENT
Hyp: 
def findStep ( n ) : NEW_LINE INDENT if ( n == 1 or n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( n == 2 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT else : NEW_LINE INDENT return findStep ( n - 3 ) + findStep ( n - 2 ) + findStep ( n - 1 ) NEW_LINE DEDENT DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
void printSubsequences ( int arr [ ] , int n ) { unsigned int opsize = pow ( 2 , n ) ; for ( int counter = 1 ; counter < opsize ; counter ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( counter & ( 1 << j ) ) cout << arr [ j ] << " ▁ " ; } cout << endl ; } }
Ref: 
def printSubsequences ( arr , n ) : NEW_LINE INDENT opsize = math . pow ( 2 , n ) NEW_LINE for counter in range ( 1 , ( int ) ( opsize ) ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT if ( counter & ( 1 << j ) ) : NEW_LINE INDENT print ( arr [ j ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT
Hyp: 
def printSubsequences ( arr , n ) : NEW_LINE INDENT opsize = ( int ) ( math . pow ( 2 , n ) ) NEW_LINE for counter in range ( 1 , opsize ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT if ( ( counter & ( 1 << j ) ) > 0 ) : NEW_LINE INDENT print ( arr [ j ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT

BLEU: 86.28
Edit Sim: 32


Src: 
int minXOR ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int minXor = INT_MAX ; int val = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { val = arr [ i ] ^ arr [ i + 1 ] ; minXor = min ( minXor , val ) ; } return minXor ; }
Ref: 
def minXOR ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE minXor = int ( sys . float_info . max ) NEW_LINE val = 0 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT val = arr [ i ] ^ arr [ i + 1 ] NEW_LINE minXor = min ( minXor , val ) NEW_LINE DEDENT return minXor NEW_LINE DEDENT
Hyp: 
def minXOR ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE minXor = 2147483647 NEW_LINE val = 0 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT val = arr [ i ] ^ arr [ i + 1 ] NEW_LINE minXor = min ( minXor , val ) NEW_LINE DEDENT return minXor NEW_LINE DEDENT

BLEU: 86.46
Edit Sim: 30


Src: 
void luDecomposition ( int mat [ ] [ MAX ] , int n ) { int lower [ n ] [ n ] , upper [ n ] [ n ] ; memset ( lower , 0 , sizeof ( lower ) ) ; memset ( upper , 0 , sizeof ( upper ) ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int k = i ; k < n ; k ++ ) { int sum = 0 ; for ( int j = 0 ; j < i ; j ++ ) sum += ( lower [ i ] [ j ] * upper [ j ] [ k ] ) ; upper [ i ] [ k ] = mat [ i ] [ k ] - sum ; } for ( int k = i ; k < n ; k ++ ) { if ( i == k ) lower [ i ] [ i ] = 1 ; else { int sum = 0 ; for ( int j = 0 ; j < i ; j ++ ) sum += ( lower [ k ] [ j ] * upper [ j ] [ i ] ) ; lower [ k ] [ i ] = ( mat [ k ] [ i ] - sum ) / upper [ i ] [ i ] ; } } } cout << setw ( 6 ) << " ▁ ▁ ▁ ▁ ▁ ▁ Lower ▁ Triangular " << setw ( 32 ) << " Upper ▁ Triangular " << endl ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) cout << setw ( 6 ) << lower [ i ] [ j ] << " \t " ; cout << " \t " ; for ( int j = 0 ; j < n ; j ++ ) cout << setw ( 6 ) << upper [ i ] [ j ] << " \t " ; cout << endl ; } }
Ref: 
def luDecomposition ( mat , n ) : NEW_LINE INDENT lower = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] NEW_LINE upper = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for k in range ( i , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for j in range ( i ) : NEW_LINE INDENT sum += ( lower [ i ] [ j ] * upper [ j ] [ k ] ) NEW_LINE DEDENT upper [ i ] [ k ] = mat [ i ] [ k ] - sum NEW_LINE DEDENT for k in range ( i , n ) : NEW_LINE INDENT if ( i == k ) : NEW_LINE INDENT lower [ i ] [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT sum = 0 NEW_LINE for j in range ( i ) : NEW_LINE INDENT sum += ( lower [ k ] [ j ] * upper [ j ] [ i ] ) NEW_LINE DEDENT lower [ k ] [ i ] = int ( ( mat [ k ] [ i ] - sum ) / upper [ i ] [ i ] ) NEW_LINE DEDENT DEDENT DEDENT print ( " Lower ▁ Triangular\t\tUpper ▁ Triangular " ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT print ( lower [ i ] [ j ] , end = " \t " ) NEW_LINE DEDENT print ( " " , end = " \t " ) NEW_LINE for j in range ( n ) : NEW_LINE INDENT print ( upper [ i ] [ j ] , end = " \t " ) NEW_LINE DEDENT print ( " " ) NEW_LINE DEDENT DEDENT
Hyp: 
def luDecomposition ( mat , n ) : NEW_LINE INDENT lower = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] NEW_LINE upper = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for k in range ( i , n ) : NEW_LINE INDENT Sum = 0 NEW_LINE for j in range ( i ) : NEW_LINE INDENT Sum += ( lower [ i ] [ j ] * upper [ j ] [ k ] ) NEW_LINE DEDENT upper [ i ] [ k ] = mat [ i ] [ k ] - Sum NEW_LINE DEDENT DEDENT for k in range ( i , n ) : NEW_LINE INDENT if ( i == k ) : NEW_LINE INDENT lower [ i ] [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT Sum = 0 NEW_LINE for j in range ( i ) : NEW_LINE INDENT Sum += ( lower [ k ] [ j ] * upper [ j ] [ i ] ) NEW_LINE DEDENT lower [ k ] [ i ] = ( mat [ k ] [ i ] - Sum ) / upper [ i ] [ i ] NEW_LINE DEDENT DEDENT print ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT print ( 6 , lower [ i ] [ j ] , end = " \t " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT

BLEU: 73.63
Edit Sim: 216


Src: 
void bin ( unsigned n ) { if ( n > 1 ) bin ( n >> 1 ) ; printf ( " % d " , n & 1 ) ; }
Ref: 
def bin ( n ) : NEW_LINE INDENT if ( n > 1 ) : NEW_LINE INDENT bin ( n >> 1 ) NEW_LINE DEDENT print ( n & 1 , end = " " ) NEW_LINE DEDENT
Hyp: 
def bin ( n ) : NEW_LINE INDENT if n > 1 : NEW_LINE INDENT bin ( n >> 1 ) NEW_LINE DEDENT print ( n & 1 , end = " " ) NEW_LINE DEDENT

BLEU: 86.18
Edit Sim: 4


Src: 
int CountPS ( char str [ ] , int n ) { int dp [ n ] [ n ] ; memset ( dp , 0 , sizeof ( dp ) ) ; bool P [ n ] [ n ] ; memset ( P , false , sizeof ( P ) ) ; for ( int i = 0 ; i < n ; i ++ ) P [ i ] [ i ] = true ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( str [ i ] == str [ i + 1 ] ) { P [ i ] [ i + 1 ] = true ; dp [ i ] [ i + 1 ] = 1 ; } } for ( int gap = 2 ; gap < n ; gap ++ ) { for ( int i = 0 ; i < n - gap ; i ++ ) { int j = gap + i ; if ( str [ i ] == str [ j ] && P [ i + 1 ] [ j - 1 ] ) P [ i ] [ j ] = true ; if ( P [ i ] [ j ] == true ) dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] + 1 - dp [ i + 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] - dp [ i + 1 ] [ j - 1 ] ; } } return dp [ 0 ] [ n - 1 ] ; }
Ref: 
def CountPS ( str , n ) : NEW_LINE INDENT dp = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] NEW_LINE P = [ [ False for x in range ( n ) ] for y in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT P [ i ] [ i ] = True NEW_LINE DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT if ( str [ i ] == str [ i + 1 ] ) : NEW_LINE INDENT P [ i ] [ i + 1 ] = True NEW_LINE dp [ i ] [ i + 1 ] = 1 NEW_LINE DEDENT DEDENT for gap in range ( 2 , n ) : NEW_LINE INDENT for i in range ( n - gap ) : NEW_LINE INDENT j = gap + i ; NEW_LINE if ( str [ i ] == str [ j ] and P [ i + 1 ] [ j - 1 ] ) : NEW_LINE INDENT P [ i ] [ j ] = True NEW_LINE DEDENT if ( P [ i ] [ j ] == True ) : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] + 1 - dp [ i + 1 ] [ j - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] - dp [ i + 1 ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ 0 ] [ n - 1 ] NEW_LINE DEDENT
Hyp: 
def CountPS ( Str , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] NEW_LINE P = [ [ False for i in range ( n ) ] for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT P [ i ] [ i ] = True NEW_LINE DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT if ( Str [ i ] == Str [ i + 1 ] ) : NEW_LINE INDENT P [ i ] [ i + 1 ] = True NEW_LINE dp [ i ] [ i + 1 ] = 1 NEW_LINE DEDENT DEDENT for gap in range ( 2 , n ) : NEW_LINE INDENT for i in range ( n - gap ) : NEW_LINE INDENT j = gap + i NEW_LINE if ( Str [ i ] == Str [ j ] and P [ i + 1 ] [ j - 1 ] ) : NEW_LINE INDENT P [ i ] [ j ] = True NEW_LINE DEDENT if ( P [ i ] [ j ] == True ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] + 1 - dp [ i + 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] - dp [ i + 1 ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT return dp [ 0 ] [ n - 1 ] NEW_LINE DEDENT

BLEU: 88.88
Edit Sim: 19


Src: 
void modularEquation ( int a , int b ) { if ( a < b ) { cout << " No ▁ solution ▁ possible ▁ " << endl ; return ; } if ( a == b ) { cout << " Infinite ▁ Solution ▁ possible ▁ " << endl ; return ; } int count = 0 ; int n = a - b ; int y = sqrt ( a - b ) ; for ( int i = 1 ; i <= y ; ++ i ) { if ( n % i == 0 ) { if ( n / i > b ) count ++ ; if ( i > b ) count ++ ; } } if ( y * y == n && y > b ) count -- ; cout << count << endl ; }
Ref: 
def modularEquation ( a , b ) : NEW_LINE INDENT if ( a < b ) : NEW_LINE INDENT print ( " No ▁ solution ▁ possible ▁ " ) NEW_LINE return NEW_LINE DEDENT if ( a == b ) : NEW_LINE INDENT print ( " Infinite ▁ Solution ▁ possible ▁ " ) NEW_LINE return NEW_LINE DEDENT count = 0 NEW_LINE n = a - b NEW_LINE y = ( int ) ( math . sqrt ( a - b ) ) NEW_LINE for i in range ( 1 , y + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( n / i > b ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT if ( i > b ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT DEDENT if ( y * y == n and y > b ) : NEW_LINE INDENT count = count - 1 NEW_LINE DEDENT print ( count ) NEW_LINE DEDENT
Hyp: 
def modularEquation ( a , b ) : NEW_LINE INDENT if a < b : NEW_LINE INDENT print ( " No ▁ solution ▁ possible ▁ " ) NEW_LINE return NEW_LINE DEDENT if a == b : NEW_LINE INDENT print ( " Infinite ▁ Solution ▁ possible ▁ " ) NEW_LINE return NEW_LINE DEDENT count = 0 NEW_LINE n = a - b NEW_LINE y = math . sqrt ( a - b ) NEW_LINE for i in range ( 1 , y + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT if n // i > b : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if i > b : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT if ( y * y == n and y > b ) : NEW_LINE INDENT count -= 1 NEW_LINE DEDENT print ( count ) NEW_LINE DEDENT

BLEU: 71.12
Edit Sim: 60


Src: 
int minimumSquare ( int a , int b ) { long long result = 0 , rem = 0 ; if ( a < b ) swap ( a , b ) ; while ( b > 0 ) { result += a / b ; long long rem = a % b ; a = b ; b = rem ; } return result ; }
Ref: 
def minimumSquare ( a , b ) : NEW_LINE INDENT result = 0 NEW_LINE rem = 0 NEW_LINE if ( a < b ) : NEW_LINE INDENT a , b = b , a NEW_LINE DEDENT while ( b > 0 ) : NEW_LINE INDENT result += int ( a / b ) NEW_LINE rem = int ( a % b ) NEW_LINE a = b NEW_LINE b = rem NEW_LINE DEDENT return result NEW_LINE DEDENT
Hyp: 
def minimumSquare ( a , b ) : NEW_LINE INDENT result = 0 NEW_LINE rem = 0 NEW_LINE if a < b : NEW_LINE INDENT a , b = a , b NEW_LINE DEDENT while b > 0 : NEW_LINE INDENT result += a // b NEW_LINE rem = a % b NEW_LINE a = b NEW_LINE b = rem NEW_LINE DEDENT return result NEW_LINE DEDENT

BLEU: 62.11
Edit Sim: 27


Src: 
int maxSum ( int mat [ SIZE ] [ SIZE ] , int n ) { if ( n == 1 ) return mat [ 0 ] [ 0 ] ; int dp [ n ] [ n ] ; int maxSum = INT_MIN , max ; for ( int j = 0 ; j < n ; j ++ ) dp [ n - 1 ] [ j ] = mat [ n - 1 ] [ j ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < n ; j ++ ) { max = INT_MIN ; if ( ( ( j - 1 ) >= 0 ) && ( max < dp [ i + 1 ] [ j - 1 ] ) ) max = dp [ i + 1 ] [ j - 1 ] ; if ( ( ( j + 1 ) < n ) && ( max < dp [ i + 1 ] [ j + 1 ] ) ) max = dp [ i + 1 ] [ j + 1 ] ; dp [ i ] [ j ] = mat [ i ] [ j ] + max ; } } for ( int j = 0 ; j < n ; j ++ ) if ( maxSum < dp [ 0 ] [ j ] ) maxSum = dp [ 0 ] [ j ] ; return maxSum ; }
Ref: 
def maxSum ( mat , n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return mat [ 0 ] [ 0 ] NEW_LINE DEDENT dp = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] NEW_LINE maxSum = INT_MIN NEW_LINE for j in range ( n ) : NEW_LINE INDENT dp [ n - 1 ] [ j ] = mat [ n - 1 ] [ j ] NEW_LINE DEDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT maxi = INT_MIN NEW_LINE if ( ( ( ( j - 1 ) >= 0 ) and ( maxi < dp [ i + 1 ] [ j - 1 ] ) ) ) : NEW_LINE INDENT maxi = dp [ i + 1 ] [ j - 1 ] NEW_LINE DEDENT if ( ( ( ( j + 1 ) < n ) and ( maxi < dp [ i + 1 ] [ j + 1 ] ) ) ) : NEW_LINE INDENT maxi = dp [ i + 1 ] [ j + 1 ] NEW_LINE DEDENT dp [ i ] [ j ] = mat [ i ] [ j ] + maxi NEW_LINE DEDENT DEDENT for j in range ( n ) : NEW_LINE INDENT if ( maxSum < dp [ 0 ] [ j ] ) : NEW_LINE INDENT maxSum = dp [ 0 ] [ j ] NEW_LINE DEDENT DEDENT return maxSum NEW_LINE DEDENT
Hyp: 
def maxSum ( mat , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return mat [ 0 ] [ 0 ] NEW_LINE DEDENT dp = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] NEW_LINE maxSum = - sys . maxsize - 1 NEW_LINE for j in range ( n ) : NEW_LINE INDENT max = INT_MIN NEW_LINE if ( ( j - 1 ) >= 0 ) and ( max < dp [ i + 1 ] [ j - 1 ] ) : NEW_LINE INDENT max = dp [ i + 1 ] [ j - 1 ] NEW_LINE DEDENT if ( ( j + 1 ) < n ) and ( max < dp [ i + 1 ] [ j + 1 ] ) ) : NEW_LINE INDENT max = dp [ i + 1 ] [ j + 1 ] NEW_LINE DEDENT dp [ i ] [ j ] = mat [ i ] [ j ] + max NEW_LINE DEDENT DEDENT for j in range ( n ) : NEW_LINE INDENT if ( maxSum < dp [ 0 ] [ j ] ) : NEW_LINE INDENT maxSum = dp [ 0 ] [ j ] NEW_LINE DEDENT DEDENT return maxSum NEW_LINE DEDENT

BLEU: 70.62
Edit Sim: 171


Src: 
long long int findMinSum ( int a [ ] , int b [ ] , int n ) { sort ( a , a + n ) ; sort ( b , b + n ) ; long long int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum + abs ( a [ i ] - b [ i ] ) ; return sum ; }
Ref: 
def findMinSum ( a , b , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE b . sort ( ) NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = sum + abs ( a [ i ] - b [ i ] ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
Hyp: 
def findMinSum ( a , b , n ) : NEW_LINE INDENT a . sort ( reverse = False ) NEW_LINE b . sort ( reverse = False ) NEW_LINE sum = 0 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT sum = sum + abs ( a [ i ] - b [ i ] ) NEW_LINE DEDENT return sum NEW_LINE DEDENT

BLEU: 77.76
Edit Sim: 40


Src: 
void deleteElements ( int arr [ ] , int n , int k ) { stack < int > s ; s . push ( arr [ 0 ] ) ; int count = 0 ; for ( int i = 1 ; i < n ; i ++ ) { while ( ! s . empty ( ) && s . top ( ) < arr [ i ] && count < k ) { s . pop ( ) ; count ++ ; } s . push ( arr [ i ] ) ; } int m = s . size ( ) ; vector < int > v ( m ) ; while ( ! s . empty ( ) ) { v [ -- m ] = s . top ( ) ; s . pop ( ) ; } for ( auto x : v ) cout << x << " ▁ " ; cout << endl ; }
Ref: 
def deleteElements ( arr , n , k ) : NEW_LINE INDENT st = [ ] NEW_LINE st . append ( arr [ 0 ] ) NEW_LINE top = 0 NEW_LINE count = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT while ( len ( st ) != 0 and count < k and st [ top ] < arr [ i ] ) : NEW_LINE INDENT st . pop ( ) NEW_LINE count += 1 NEW_LINE top -= 1 NEW_LINE DEDENT st . append ( arr [ i ] ) NEW_LINE top += 1 NEW_LINE DEDENT for i in range ( 0 , len ( st ) ) : NEW_LINE INDENT print ( st [ i ] , " ▁ " , end = " " ) NEW_LINE DEDENT DEDENT
Hyp: 
def deleteElements ( arr , n , k ) : NEW_LINE INDENT s = [ ] NEW_LINE s . append ( arr [ 0 ] ) NEW_LINE count = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT while ( len ( s ) > 0 and s [ - 1 ] < arr [ i ] and count < k ) : NEW_LINE INDENT s . pop ( ) NEW_LINE count += 1 NEW_LINE DEDENT s . append ( arr [ i ] ) NEW_LINE DEDENT m = len ( s ) NEW_LINE v = [ 0 ] * m NEW_LINE while ( len ( s ) != 0 ) : NEW_LINE INDENT v [ m ] = s [ - 1 ] NEW_LINE s . pop ( ) NEW_LINE DEDENT for x in v : NEW_LINE INDENT print ( x , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT

BLEU: 50.91
Edit Sim: 210


Src: 
char first ( string str ) { for ( int i = 0 ; i < str . length ( ) ; i ++ ) if ( isupper ( str [ i ] ) ) return str [ i ] ; return 0 ; }
Ref: 
def first ( str ) : NEW_LINE INDENT for i in range ( 0 , len ( str ) ) : NEW_LINE INDENT if ( str [ i ] . istitle ( ) ) : NEW_LINE INDENT return str [ i ] NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT
Hyp: 
def first ( str ) : NEW_LINE INDENT for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] . isupper ( ) ) : NEW_LINE INDENT return str [ i ] NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT

BLEU: 87.34
Edit Sim: 9


Src: 
int minDist ( int arr [ ] , int n , int x , int y ) { int i , j ; int min_dist = INT_MAX ; for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { if ( ( x == arr [ i ] && y == arr [ j ] || y == arr [ i ] && x == arr [ j ] ) && min_dist > abs ( i - j ) ) { min_dist = abs ( i - j ) ; } } } return min_dist ; }
Ref: 
def minDist ( arr , n , x , y ) : NEW_LINE INDENT min_dist = 99999999 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( x == arr [ i ] and y == arr [ j ] or y == arr [ i ] and x == arr [ j ] ) and min_dist > abs ( i - j ) : NEW_LINE INDENT min_dist = abs ( i - j ) NEW_LINE DEDENT DEDENT return min_dist NEW_LINE DEDENT DEDENT
Hyp: 
def minDist ( arr , n , x , y ) : NEW_LINE INDENT min_dist = sys . maxsize NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( ( x == arr [ i ] and y == arr [ j ] or y == arr [ i ] and x == arr [ j ] ) and min_dist > abs ( i - j ) ) : NEW_LINE INDENT min_dist = abs ( i - j ) NEW_LINE DEDENT DEDENT DEDENT return min_dist NEW_LINE DEDENT

BLEU: 88.22
Edit Sim: 35


Src: 
double arcLength ( double diameter , double angle ) { double pi = 22.0 / 7.0 ; double arc ; if ( angle >= 360 ) { cout << " Angle ▁ cannot " , " ▁ be ▁ formed " ; return 0 ; } else { arc = ( pi * diameter ) * ( angle / 360.0 ) ; return arc ; } }
Ref: 
def arcLength ( diameter , angle ) : NEW_LINE INDENT if angle >= 360 : NEW_LINE INDENT print ( " Angle ▁ cannot ▁ be ▁ formed " ) NEW_LINE return 0 NEW_LINE DEDENT else : NEW_LINE INDENT arc = ( 3.142857142857143 * diameter ) * ( angle / 360.0 ) NEW_LINE return arc NEW_LINE DEDENT DEDENT
Hyp: 
def arcLength ( diameter , angle ) : NEW_LINE INDENT pi = 22.0 / 7.0 NEW_LINE arc = 0 NEW_LINE if angle >= 360 : NEW_LINE INDENT print ( " Angle ▁ cannot " , " ▁ be ▁ formed " ) NEW_LINE return 0 NEW_LINE DEDENT else : NEW_LINE INDENT arc = ( pi * diameter ) * ( angle / 360.0 ) NEW_LINE return arc NEW_LINE DEDENT DEDENT

BLEU: 73.11
Edit Sim: 65


Src: 
void findSymPairs ( int arr [ ] [ 2 ] , int row ) { unordered_map < int , int > hM ; for ( int i = 0 ; i < row ; i ++ ) { int first = arr [ i ] [ 0 ] ; int sec = arr [ i ] [ 1 ] ; if ( hM . find ( sec ) != hM . end ( ) && hM [ sec ] == first ) cout << " ( " << sec << " , ▁ " << first << " ) " << endl ; else hM [ first ] = sec ; } }
Ref: 
def findSymPairs ( arr , row ) : NEW_LINE INDENT hM = dict ( ) NEW_LINE for i in range ( row ) : NEW_LINE INDENT first = arr [ i ] [ 0 ] NEW_LINE sec = arr [ i ] [ 1 ] NEW_LINE if ( sec in hM . keys ( ) and hM [ sec ] == first ) : NEW_LINE INDENT print ( " ( " , sec , " , " , first , " ) " ) NEW_LINE DEDENT else : NEW_LINE INDENT hM [ first ] = sec NEW_LINE DEDENT DEDENT DEDENT
Hyp: 
def findSymPairs ( arr , row ) : NEW_LINE INDENT hM = dict ( ) NEW_LINE for i in range ( row ) : NEW_LINE INDENT first = arr [ i ] [ 0 ] NEW_LINE sec = arr [ i ] [ 1 ] NEW_LINE if ( sec in hM ) : NEW_LINE INDENT print ( " ( " , sec , " , ▁ " , first , " ) " ) NEW_LINE DEDENT else : NEW_LINE INDENT hM [ first ] = sec NEW_LINE DEDENT DEDENT DEDENT

BLEU: 85.43
Edit Sim: 37


Src: 
bool isValidString ( string str ) { int freq [ CHARS ] = { 0 } ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) freq [ str [ i ] - ' a ' ] ++ ; int i , freq1 = 0 , count_freq1 = 0 ; for ( i = 0 ; i < CHARS ; i ++ ) { if ( freq [ i ] != 0 ) { freq1 = freq [ i ] ; count_freq1 = 1 ; break ; } } int j , freq2 = 0 , count_freq2 = 0 ; for ( j = i + 1 ; j < CHARS ; j ++ ) { if ( freq [ j ] != 0 ) { if ( freq [ j ] == freq1 ) count_freq1 ++ ; else { count_freq2 = 1 ; freq2 = freq [ j ] ; break ; } } } for ( int k = j + 1 ; k < CHARS ; k ++ ) { if ( freq [ k ] != 0 ) { if ( freq [ k ] == freq1 ) count_freq1 ++ ; if ( freq [ k ] == freq2 ) count_freq2 ++ ; else return false ; } if ( count_freq1 > 1 && count_freq2 > 1 ) return false ; } return true ; }
Ref: 
def isValidString ( str ) : NEW_LINE INDENT freq = [ 0 ] * CHARS NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT freq1 = 0 NEW_LINE count_freq1 = 0 NEW_LINE for i in range ( CHARS ) : NEW_LINE INDENT if ( freq [ i ] != 0 ) : NEW_LINE INDENT freq1 = freq [ i ] NEW_LINE count_freq1 = 1 NEW_LINE break NEW_LINE DEDENT DEDENT freq2 = 0 NEW_LINE count_freq2 = 0 NEW_LINE for j in range ( i + 1 , CHARS ) : NEW_LINE INDENT if ( freq [ j ] != 0 ) : NEW_LINE INDENT if ( freq [ j ] == freq1 ) : NEW_LINE INDENT count_freq1 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_freq2 = 1 NEW_LINE freq2 = freq [ j ] NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT for k in range ( j + 1 , CHARS ) : NEW_LINE INDENT if ( freq [ k ] != 0 ) : NEW_LINE INDENT if ( freq [ k ] == freq1 ) : NEW_LINE INDENT count_freq1 += 1 NEW_LINE DEDENT if ( freq [ k ] == freq2 ) : NEW_LINE INDENT count_freq2 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if ( count_freq1 > 1 and count_freq2 > 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
Hyp: 
def isValidString ( str ) : NEW_LINE INDENT freq = [ 0 ] * CHARS NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT i = 0 NEW_LINE count_freq1 = 0 NEW_LINE for i in range ( CHARS ) : NEW_LINE INDENT if freq [ i ] != 0 : NEW_LINE INDENT freq1 = freq [ i ] NEW_LINE count_freq1 = 1 NEW_LINE break NEW_LINE DEDENT DEDENT j = 0 NEW_LINE count_freq2 = 0 NEW_LINE for j in range ( i + 1 , CHARS ) : NEW_LINE INDENT if freq [ j ] != 0 : NEW_LINE INDENT if freq [ j ] == freq1 : NEW_LINE INDENT count_freq1 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_freq2 = 1 NEW_LINE freq2 = freq [ j ] NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT for k in range ( j + 1 , CHARS ) : NEW_LINE INDENT if freq [ k ] != 0 : NEW_LINE INDENT if freq [ k ] == freq1 : NEW_LINE INDENT count_freq1 += 1 NEW_LINE DEDENT if freq [ k ] == freq2 : NEW_LINE INDENT count_freq2 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if count_freq1 > 1 and count_freq2 > 1 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT

BLEU: 83.95
Edit Sim: 38


Src: 
bool isPrime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i < n ; i ++ ) if ( n % i == 0 ) return false ; return true ; }
Ref: 
def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
Hyp: 
def isPrime ( n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT

BLEU: 80.08
Edit Sim: 8


Src: 
int findMaxAverage ( int arr [ ] , int n , int k ) { if ( k > n ) return - 1 ; int * csum = new int [ n ] ; csum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) csum [ i ] = csum [ i - 1 ] + arr [ i ] ; int max_sum = csum [ k - 1 ] , max_end = k - 1 ; for ( int i = k ; i < n ; i ++ ) { int curr_sum = csum [ i ] - csum [ i - k ] ; if ( curr_sum > max_sum ) { max_sum = curr_sum ; max_end = i ; } } delete [ ] csum ; return max_end - k + 1 ; }
Ref: 
def findMaxAverage ( arr , n , k ) : NEW_LINE INDENT if k > n : NEW_LINE INDENT return - 1 NEW_LINE DEDENT csum = [ 0 ] * n NEW_LINE csum [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT csum [ i ] = csum [ i - 1 ] + arr [ i ] NEW_LINE DEDENT max_sum = csum [ k - 1 ] NEW_LINE max_end = k - 1 NEW_LINE for i in range ( k , n ) : NEW_LINE INDENT curr_sum = csum [ i ] - csum [ i - k ] NEW_LINE if curr_sum > max_sum : NEW_LINE INDENT max_sum = curr_sum NEW_LINE max_end = i NEW_LINE DEDENT DEDENT return max_end - k + 1 NEW_LINE DEDENT
Hyp: 
def findMaxAverage ( arr , n , k ) : NEW_LINE INDENT if ( k > n ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT csum = [ 0 ] * n NEW_LINE csum [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT csum [ i ] = csum [ i - 1 ] + arr [ i ] NEW_LINE DEDENT max_sum = csum [ k - 1 ] NEW_LINE max_end = k - 1 NEW_LINE for i in range ( k , n ) : NEW_LINE INDENT curr_sum = csum [ i ] - csum [ i - k ] NEW_LINE if curr_sum > max_sum : NEW_LINE INDENT max_sum = curr_sum NEW_LINE max_end = i NEW_LINE DEDENT DEDENT return max_end - k + 1 NEW_LINE DEDENT

BLEU: 96.39
Edit Sim: 4


Src: 
void maximizecube ( int l , int b , int h ) { int side = __gcd ( l , __gcd ( b , h ) ) ; int num = l / side ; num = ( num * b / side ) ; num = ( num * h / side ) ; cout << side << " ▁ " << num << endl ; }
Ref: 
def maximizecube ( l , b , h ) : NEW_LINE INDENT side = gcd ( l , gcd ( b , h ) ) NEW_LINE num = int ( l / side ) NEW_LINE num = int ( num * b / side ) NEW_LINE num = int ( num * h / side ) NEW_LINE print ( side , num ) NEW_LINE DEDENT
Hyp: 
def maximizecube ( l , b , h ) : NEW_LINE INDENT side = __gcd ( l , __gcd ( b , h ) ) NEW_LINE num = l / side NEW_LINE num = ( num * b / side ) NEW_LINE num = ( num * h / side ) NEW_LINE print ( side , " ▁ " , num ) NEW_LINE DEDENT

BLEU: 72.8
Edit Sim: 28


Src: 
int horner ( int poly [ ] , int n , int x ) { int result = poly [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) result = result * x + poly [ i ] ; return result ; }
Ref: 
def horner ( poly , n , x ) : NEW_LINE INDENT result = poly [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT result = result * x + poly [ i ] NEW_LINE DEDENT return result NEW_LINE DEDENT
Hyp: 
def horner ( poly , n , x ) : NEW_LINE INDENT result = poly [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT result = result * x + poly [ i ] NEW_LINE DEDENT return result NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
void rotate ( int arr [ ] , int n ) { int x = arr [ n - 1 ] , i ; for ( i = n - 1 ; i > 0 ; i -- ) arr [ i ] = arr [ i - 1 ] ; arr [ 0 ] = x ; }
Ref: 
def rotate ( arr , n ) : NEW_LINE INDENT x = arr [ n - 1 ] NEW_LINE for i in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT arr [ i ] = arr [ i - 1 ] NEW_LINE DEDENT arr [ 0 ] = x NEW_LINE DEDENT
Hyp: 
def rotate ( arr , n ) : NEW_LINE INDENT x = arr [ n - 1 ] NEW_LINE i = n - 1 NEW_LINE while ( i > 0 ) : NEW_LINE INDENT arr [ i ] = arr [ i - 1 ] NEW_LINE i -= 1 NEW_LINE DEDENT arr [ 0 ] = x NEW_LINE DEDENT

BLEU: 74.21
Edit Sim: 41


Src: 
void bonacciseries ( long n , int m ) { int a [ m ] = { 0 } ; a [ n - 1 ] = 1 ; a [ n ] = 1 ; for ( int i = n + 1 ; i < m ; i ++ ) a [ i ] = 2 * a [ i - 1 ] - a [ i - n - 1 ] ; for ( int i = 0 ; i < m ; i ++ ) cout << a [ i ] << " ▁ " ; }
Ref: 
def bonacciseries ( n , m ) : NEW_LINE INDENT a = [ 0 for i in range ( m ) ] NEW_LINE a [ n - 1 ] = 1 NEW_LINE a [ n ] = 1 NEW_LINE for i in range ( n + 1 , m ) : NEW_LINE INDENT a [ i ] = 2 * a [ i - 1 ] - a [ i - n - 1 ] NEW_LINE DEDENT for i in range ( 0 , m ) : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
Hyp: 
def bonacciseries ( n , m ) : NEW_LINE INDENT a = [ 0 ] * m NEW_LINE a [ n - 1 ] = 1 NEW_LINE a [ n ] = 1 NEW_LINE for i in range ( n + 1 , m ) : NEW_LINE INDENT a [ i ] = 2 * a [ i - 1 ] - a [ i - n - 1 ] NEW_LINE DEDENT for i in range ( 0 , m ) : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT

BLEU: 91.26
Edit Sim: 19


Src: 
int numberOfWays ( int x ) { int dp [ x + 1 ] ; dp [ 0 ] = dp [ 1 ] = 1 ; for ( int i = 2 ; i <= x ; i ++ ) dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; return dp [ x ] ; }
Ref: 
def numberOfWays ( x ) : NEW_LINE INDENT if x == 0 or x == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return ( numberOfWays ( x - 1 ) + ( x - 1 ) * numberOfWays ( x - 2 ) ) NEW_LINE DEDENT DEDENT
Hyp: 
def numberOfWays ( x ) : NEW_LINE INDENT dp = [ 0 for i in range ( x + 1 ) ] NEW_LINE dp [ 0 ] = dp [ 1 ] = 1 NEW_LINE for i in range ( 2 , x + 1 ) : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] NEW_LINE DEDENT return dp [ x ] NEW_LINE DEDENT

BLEU: 18.87
Edit Sim: 135


Src: 
int findoptimal ( int N ) { if ( N <= 6 ) return N ; int screen [ N ] ; int b ; int n ; for ( n = 1 ; n <= 6 ; n ++ ) screen [ n - 1 ] = n ; for ( n = 7 ; n <= N ; n ++ ) { screen [ n - 1 ] = max ( 2 * screen [ n - 4 ] , max ( 3 * screen [ n - 5 ] , 4 * screen [ n - 6 ] ) ) ; } return screen [ N - 1 ] ; }
Ref: 
def findoptimal ( N ) : NEW_LINE INDENT if ( N <= 6 ) : NEW_LINE INDENT return N NEW_LINE DEDENT screen = [ 0 ] * N NEW_LINE for n in range ( 1 , 7 ) : NEW_LINE INDENT screen [ n - 1 ] = n NEW_LINE DEDENT for n in range ( 7 , N + 1 ) : NEW_LINE INDENT screen [ n - 1 ] = max ( 2 * screen [ n - 4 ] , max ( 3 * screen [ n - 5 ] , 4 * screen [ n - 6 ] ) ) NEW_LINE DEDENT return screen [ N - 1 ] NEW_LINE DEDENT
Hyp: 
def findoptimal ( N ) : NEW_LINE INDENT if ( N <= 6 ) : NEW_LINE INDENT return N NEW_LINE DEDENT screen = [ 0 ] * N NEW_LINE b = 0 NEW_LINE n = 1 NEW_LINE while ( n <= 6 ) : NEW_LINE INDENT screen [ n - 1 ] = n NEW_LINE DEDENT for n in range ( 7 , N + 1 ) : NEW_LINE INDENT screen [ n - 1 ] = max ( 2 * screen [ n - 4 ] , max ( 3 * screen [ n - 5 ] , 4 * screen [ n - 6 ] ) ) NEW_LINE DEDENT return screen [ N - 1 ] NEW_LINE DEDENT

BLEU: 88.45
Edit Sim: 34


Src: 
int maxRowDiff ( int mat [ ] [ MAX ] , int m , int n ) { int rowSum [ m ] ; for ( int i = 0 ; i < m ; i ++ ) { int sum = 0 ; for ( int j = 0 ; j < n ; j ++ ) sum += mat [ i ] [ j ] ; rowSum [ i ] = sum ; } int max_diff = rowSum [ 1 ] - rowSum [ 0 ] ; int min_element = rowSum [ 0 ] ; for ( int i = 1 ; i < m ; i ++ ) { if ( rowSum [ i ] - min_element > max_diff ) max_diff = rowSum [ i ] - min_element ; if ( rowSum [ i ] < min_element ) min_element = rowSum [ i ] ; } return max_diff ; }
Ref: 
def maxRowDiff ( mat , m , n ) : NEW_LINE INDENT rowSum = [ 0 ] * m NEW_LINE for i in range ( 0 , m ) : NEW_LINE INDENT sum = 0 NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT sum += mat [ i ] [ j ] NEW_LINE DEDENT rowSum [ i ] = sum NEW_LINE DEDENT max_diff = rowSum [ 1 ] - rowSum [ 0 ] NEW_LINE min_element = rowSum [ 0 ] NEW_LINE for i in range ( 1 , m ) : NEW_LINE INDENT if ( rowSum [ i ] - min_element > max_diff ) : NEW_LINE INDENT max_diff = rowSum [ i ] - min_element NEW_LINE DEDENT if ( rowSum [ i ] < min_element ) : NEW_LINE INDENT min_element = rowSum [ i ] NEW_LINE DEDENT DEDENT return max_diff NEW_LINE DEDENT
Hyp: 
def maxRowDiff ( mat , m , n ) : NEW_LINE INDENT rowSum = [ 0 ] * m NEW_LINE for i in range ( m ) : NEW_LINE INDENT sum = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT sum += mat [ i ] [ j ] NEW_LINE DEDENT rowSum [ i ] = sum NEW_LINE DEDENT max_diff = rowSum [ 1 ] - rowSum [ 0 ] NEW_LINE min_element = rowSum [ 0 ] NEW_LINE for i in range ( 1 , m ) : NEW_LINE INDENT if ( rowSum [ i ] - min_element > max_diff ) : NEW_LINE INDENT max_diff = rowSum [ i ] - min_element NEW_LINE DEDENT if ( rowSum [ i ] < min_element ) : NEW_LINE INDENT min_element = rowSum [ i ] NEW_LINE DEDENT DEDENT return max_diff NEW_LINE DEDENT

BLEU: 95.17
Edit Sim: 8


Src: 
int isPossible ( int n , int index , int modulo , int M , int arr [ ] , int dp [ ] [ MAX ] ) { modulo = ( ( modulo % M ) + M ) % M ; if ( index == n ) { if ( modulo == 0 ) return 1 ; return 0 ; } if ( dp [ index ] [ modulo ] != - 1 ) return dp [ index ] [ modulo ] ; int placeAdd = isPossible ( n , index + 1 , modulo + arr [ index ] , M , arr , dp ) ; int placeMinus = isPossible ( n , index + 1 , modulo - arr [ index ] , M , arr , dp ) ; bool res = ( placeAdd || placeMinus ) ; dp [ index ] [ modulo ] = res ; return res ; }
Ref: 
def isPossible ( n , index , modulo , M , arr , dp ) : NEW_LINE INDENT modulo = ( ( modulo % M ) + M ) % M NEW_LINE if ( index == n ) : NEW_LINE INDENT if ( modulo == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT if ( dp [ index ] [ modulo ] != - 1 ) : NEW_LINE INDENT return dp [ index ] [ modulo ] NEW_LINE DEDENT placeAdd = isPossible ( n , index + 1 , modulo + arr [ index ] , M , arr , dp ) NEW_LINE placeMinus = isPossible ( n , index + 1 , modulo - arr [ index ] , M , arr , dp ) NEW_LINE res = bool ( placeAdd or placeMinus ) NEW_LINE dp [ index ] [ modulo ] = res NEW_LINE return res NEW_LINE DEDENT
Hyp: 
def isPossible ( n , index , modulo , M , arr , dp ) : NEW_LINE INDENT modulo = ( ( modulo % M ) + M ) % M NEW_LINE if index == n : NEW_LINE INDENT if ( modulo == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT if dp [ index ] [ modulo ] != - 1 : NEW_LINE INDENT return dp [ index ] [ modulo ] NEW_LINE DEDENT placeAdd = isPossible ( n , index + 1 , modulo + arr [ index ] , M , arr , dp ) NEW_LINE placeMinus = isPossible ( n , index + 1 , modulo - arr [ index ] , M , arr , dp ) NEW_LINE res = placeAdd or placeMinus NEW_LINE dp [ index ] [ modulo ] = res NEW_LINE return res NEW_LINE DEDENT

BLEU: 89.42
Edit Sim: 17


Src: 
int fib ( int n ) { if ( n < 6 ) return f [ n ] ; int t = 5 , fn = 5 ; while ( t < n ) { fn = round ( fn * PHI ) ; t ++ ; } return fn ; }
Ref: 
def fib ( n ) : NEW_LINE INDENT if n < 6 : NEW_LINE INDENT return f [ n ] NEW_LINE DEDENT t = 5 NEW_LINE fn = 5 NEW_LINE while t < n : NEW_LINE INDENT fn = round ( fn * PHI ) NEW_LINE t += 1 NEW_LINE DEDENT return fn NEW_LINE DEDENT
Hyp: 
def fib ( n ) : NEW_LINE INDENT if ( n < 6 ) : NEW_LINE INDENT return f [ n ] NEW_LINE DEDENT t = 5 NEW_LINE fn = 5 NEW_LINE while ( t < n ) : NEW_LINE INDENT fn = round ( fn * PHI ) NEW_LINE t += 1 NEW_LINE DEDENT return fn NEW_LINE DEDENT

BLEU: 82.37
Edit Sim: 8


Src: 
int minCost ( int cost [ R ] [ C ] , int m , int n ) { int i , j ; int tc [ R ] [ C ] ; tc [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] ; for ( i = 1 ; i <= m ; i ++ ) tc [ i ] [ 0 ] = tc [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ] ; for ( j = 1 ; j <= n ; j ++ ) tc [ 0 ] [ j ] = tc [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ] ; for ( i = 1 ; i <= m ; i ++ ) for ( j = 1 ; j <= n ; j ++ ) tc [ i ] [ j ] = min ( tc [ i - 1 ] [ j - 1 ] , tc [ i - 1 ] [ j ] , tc [ i ] [ j - 1 ] ) + cost [ i ] [ j ] ; return tc [ m ] [ n ] ; }
Ref: 
def minCost ( cost , m , n ) : NEW_LINE INDENT tc = [ [ 0 for x in range ( C ) ] for x in range ( R ) ] NEW_LINE tc [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT tc [ i ] [ 0 ] = tc [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ] NEW_LINE DEDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT tc [ 0 ] [ j ] = tc [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ] NEW_LINE DEDENT for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT tc [ i ] [ j ] = min ( tc [ i - 1 ] [ j - 1 ] , tc [ i - 1 ] [ j ] , tc [ i ] [ j - 1 ] ) + cost [ i ] [ j ] NEW_LINE DEDENT DEDENT return tc [ m ] [ n ] NEW_LINE DEDENT
Hyp: 
def minCost ( cost , m , n ) : NEW_LINE INDENT tc = [ [ 0 for i in range ( 10 ) ] for j in range ( 10 ) ] NEW_LINE tc [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT tc [ i ] [ 0 ] = tc [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ] NEW_LINE DEDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT tc [ 0 ] [ j ] = tc [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ] NEW_LINE DEDENT for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT tc [ i ] [ j ] = min ( tc [ i - 1 ] [ j - 1 ] , tc [ i - 1 ] [ j ] , tc [ i ] [ j - 1 ] ) + cost [ i ] [ j ] NEW_LINE DEDENT DEDENT return tc [ m ] [ n ] NEW_LINE DEDENT

BLEU: 95.47
Edit Sim: 6


Src: 
void amendSentence ( string str ) { for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] >= ' A ' && str [ i ] <= ' Z ' ) { str [ i ] = str [ i ] + 32 ; if ( i != 0 ) cout << " ▁ " ; cout << str [ i ] ; } else cout << str [ i ] ; } }
Ref: 
def amendSentence ( string ) : NEW_LINE INDENT string = list ( string ) NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT if string [ i ] >= ' A ' and string [ i ] <= ' Z ' : NEW_LINE INDENT string [ i ] = chr ( ord ( string [ i ] ) + 32 ) NEW_LINE if i != 0 : NEW_LINE INDENT print ( " ▁ " , end = " " ) NEW_LINE DEDENT print ( string [ i ] , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( string [ i ] , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
Hyp: 
def amendSentence ( string ) : NEW_LINE INDENT for i in range ( 0 , len ( string ) ) : NEW_LINE INDENT if string [ i ] >= ' A ' and string [ i ] <= ' Z ' : NEW_LINE INDENT string [ i ] = string [ i ] + 32 NEW_LINE if i != 0 : NEW_LINE INDENT print ( " ▁ " , end = " " ) NEW_LINE DEDENT print ( string [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( string [ i ] ) NEW_LINE DEDENT DEDENT DEDENT

BLEU: 71.56
Edit Sim: 78


Src: 
int countWays ( int arr [ ] , int m , int N ) { int count [ N + 1 ] ; memset ( count , 0 , sizeof ( count ) ) ; count [ 0 ] = 1 ; for ( int i = 1 ; i <= N ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( i >= arr [ j ] ) count [ i ] += count [ i - arr [ j ] ] ; return count [ N ] ; }
Ref: 
def countWays ( arr , m , N ) : NEW_LINE INDENT count = [ 0 for i in range ( N + 1 ) ] NEW_LINE count [ 0 ] = 1 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( i >= arr [ j ] ) : NEW_LINE INDENT count [ i ] += count [ i - arr [ j ] ] NEW_LINE DEDENT DEDENT DEDENT return count [ N ] NEW_LINE DEDENT
Hyp: 
def countWays ( arr , m , N ) : NEW_LINE INDENT count = [ 0 for _ in range ( N + 1 ) ] NEW_LINE count [ 0 ] = 1 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( i >= arr [ j ] ) : NEW_LINE INDENT count [ i ] += count [ i - arr [ j ] ] NEW_LINE DEDENT DEDENT DEDENT return count [ N ] NEW_LINE DEDENT

BLEU: 97.33
Edit Sim: 1


Src: 
ll count_of_ways ( ll n ) { ll count = 0 ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= n ; j ++ ) for ( int k = 0 ; k <= n ; k ++ ) if ( i + j + k == n ) count ++ ; return count ; }
Ref: 
def count_of_ways ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT for j in range ( 0 , n + 1 ) : NEW_LINE INDENT for k in range ( 0 , n + 1 ) : NEW_LINE INDENT if ( i + j + k == n ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
Hyp: 
def count_of_ways ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT for k in range ( n + 1 ) : NEW_LINE INDENT if ( i + j + k == n ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT

BLEU: 79.32
Edit Sim: 28


Src: 
float sumOfSeries ( int n ) { return ( 0.666 ) * ( 1 - 1 / pow ( 10 , n ) ) ; }
Ref: 
def sumOfSeries ( n ) : NEW_LINE INDENT return ( ( 0.666 ) * ( 1 - 1 / pow ( 10 , n ) ) ) NEW_LINE DEDENT
Hyp: 
def sumOfSeries ( n ) : NEW_LINE INDENT return ( 0.666 ) * ( 1 - 1 / pow ( 10 , n ) ) NEW_LINE DEDENT

BLEU: 89.06
Edit Sim: 4


Src: 
void findDivision ( string & str , int a , int b ) { int len = str . length ( ) ; vector < int > lr ( len + 1 , 0 ) ; lr [ 0 ] = ( str [ 0 ] - '0' ) % a ; for ( int i = 1 ; i < len ; i ++ ) lr [ i ] = ( ( lr [ i - 1 ] * 10 ) % a + ( str [ i ] - '0' ) ) % a ; vector < int > rl ( len + 1 , 0 ) ; rl [ len - 1 ] = ( str [ len - 1 ] - '0' ) % b ; int power10 = 10 ; for ( int i = len - 2 ; i >= 0 ; i -- ) { rl [ i ] = ( rl [ i + 1 ] + ( str [ i ] - '0' ) * power10 ) % b ; power10 = ( power10 * 10 ) % b ; } for ( int i = 0 ; i < len - 1 ; i ++ ) { if ( lr [ i ] != 0 ) continue ; if ( rl [ i + 1 ] == 0 ) { cout << " YES \n " ; for ( int k = 0 ; k <= i ; k ++ ) cout << str [ k ] ; cout << " , ▁ " ; for ( int k = i + 1 ; k < len ; k ++ ) cout << str [ k ] ; return ; } } cout << " NO \n " ; }
Ref: 
def findDivision ( str , a , b ) : NEW_LINE INDENT lenn = len ( str ) NEW_LINE lr = [ 0 ] * ( lenn + 1 ) NEW_LINE lr [ 0 ] = ( int ( str [ 0 ] ) ) % a NEW_LINE for i in range ( 1 , lenn ) : NEW_LINE INDENT lr [ i ] = ( ( lr [ i - 1 ] * 10 ) % a + \ int ( str [ i ] ) ) % a NEW_LINE DEDENT rl = [ 0 ] * ( lenn + 1 ) NEW_LINE rl [ lenn - 1 ] = int ( str [ lenn - 1 ] ) % b NEW_LINE power10 = 10 NEW_LINE for i in range ( lenn - 2 , - 1 , - 1 ) : NEW_LINE INDENT rl [ i ] = ( rl [ i + 1 ] + int ( str [ i ] ) * power10 ) % b NEW_LINE power10 = ( power10 * 10 ) % b NEW_LINE DEDENT for i in range ( 0 , lenn - 1 ) : NEW_LINE INDENT if ( lr [ i ] != 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( rl [ i + 1 ] == 0 ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE for k in range ( 0 , i + 1 ) : NEW_LINE INDENT print ( str [ k ] , end = " " ) NEW_LINE DEDENT print ( " , " , end = " ▁ " ) NEW_LINE for i in range ( i + 1 , lenn ) : NEW_LINE INDENT print ( str [ k ] , end = " " ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT print ( " NO " ) NEW_LINE DEDENT
Hyp: 
def findDivision ( str , a , b ) : NEW_LINE INDENT l = len ( str ) NEW_LINE lr = [ 0 for i in range ( l ) ] NEW_LINE lr [ 0 ] = ( ord ( str [ 0 ] ) - ord ( '0' ) ) % a NEW_LINE for i in range ( 1 , l ) : NEW_LINE INDENT lr [ i ] = ( ( lr [ i - 1 ] * 10 ) % a + ( ord ( str [ i ] ) - ord ( '0' ) ) ) % a NEW_LINE DEDENT rl [ l - 1 ] = ( ord ( str [ l - 1 ] ) - ord ( '0' ) ) % b NEW_LINE power10 = 10 NEW_LINE for i in range ( l - 2 , - 1 , - 1 ) : NEW_LINE INDENT rl [ i ] = ( rl [ i + 1 ] + ( ord ( str [ i ] ) - ord ( '0' ) ) * power10 ) % b NEW_LINE power10 = ( power10 * 10 ) % b NEW_LINE DEDENT for i in range ( l - 1 ) : NEW_LINE INDENT if ( lr [ i ] != 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( rl [ i + 1 ] == 0 ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE for k in range ( i + 1 , l ) : NEW_LINE INDENT print ( str [ k ] , end = " , ▁ " ) NEW_LINE for k in range ( i + 1 , l ) : NEW_LINE INDENT print ( str [ k ] , end = " " ) NEW_LINE DEDENT DEDENT print ( " NO " ) NEW_LINE DEDENT

BLEU: 75.3
Edit Sim: 207


Src: 
int countCommon ( int mat [ ] [ MAX ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( mat [ i ] [ i ] == mat [ i ] [ n - i - 1 ] ) res ++ ; return res ; }
Ref: 
def countCommon ( mat , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if mat [ i ] [ i ] == mat [ i ] [ n - i - 1 ] : NEW_LINE INDENT res = res + 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
Hyp: 
def countCommon ( mat , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( mat [ i ] [ i ] == mat [ i ] [ n - i - 1 ] ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT

BLEU: 81.31
Edit Sim: 15


Src: 
int hexagonalNum ( int n ) { return n * ( 2 * n - 1 ) ; }
Ref: 
def hexagonalNum ( n ) : NEW_LINE INDENT return n * ( 2 * n - 1 ) NEW_LINE DEDENT
Hyp: 
def hexagonalNum ( n ) : NEW_LINE INDENT return n * ( 2 * n - 1 ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int findGreatest ( int arr [ ] , int n ) { int result = - 1 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n - 1 ; j ++ ) for ( int k = j + 1 ; k < n ; k ++ ) if ( arr [ j ] * arr [ k ] == arr [ i ] ) result = max ( result , arr [ i ] ) ; return result ; }
Ref: 
def findGreatest ( arr , n ) : NEW_LINE INDENT result = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n - 1 ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT if ( arr [ j ] * arr [ k ] == arr [ i ] ) : NEW_LINE INDENT result = max ( result , arr [ i ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
Hyp: 
def findGreatest ( arr , n ) : NEW_LINE INDENT result = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( 0 , n - 1 ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT if arr [ j ] * arr [ k ] == arr [ i ] : NEW_LINE INDENT result = max ( result , arr [ i ] ) NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT

BLEU: 91.59
Edit Sim: 15


Src: 
void squareRoot ( int n , int p ) { n = n % p ; for ( int x = 2 ; x < p ; x ++ ) { if ( ( x * x ) % p == n ) { cout << " Square ▁ root ▁ is ▁ " << x ; return ; } } cout << " Square ▁ root ▁ doesn ' t ▁ exist " ; }
Ref: 
def squareRoot ( n , p ) : NEW_LINE INDENT n = n % p NEW_LINE for x in range ( 2 , p ) : NEW_LINE INDENT if ( ( x * x ) % p == n ) : NEW_LINE INDENT print ( " Square ▁ root ▁ is ▁ " , x ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( " Square ▁ root ▁ doesn ' t ▁ exist " ) NEW_LINE DEDENT
Hyp: 
def squareRoot ( n , p ) : NEW_LINE INDENT n = n % p NEW_LINE for x in range ( 2 , p ) : NEW_LINE INDENT if ( ( x * x ) % p == n ) : NEW_LINE INDENT print ( " Square ▁ root ▁ is ▁ " , x ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( " Square ▁ root ▁ doesn ' t ▁ exist " ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int count ( string a , string b ) { int m = a . length ( ) ; int n = b . length ( ) ; int lookup [ m + 1 ] [ n + 1 ] = { { 0 } } ; for ( int i = 0 ; i <= n ; ++ i ) lookup [ 0 ] [ i ] = 0 ; for ( int i = 0 ; i <= m ; ++ i ) lookup [ i ] [ 0 ] = 1 ; for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( a [ i - 1 ] == b [ j - 1 ] ) lookup [ i ] [ j ] = lookup [ i - 1 ] [ j - 1 ] + lookup [ i - 1 ] [ j ] ; else lookup [ i ] [ j ] = lookup [ i - 1 ] [ j ] ; } } return lookup [ m ] [ n ] ; }
Ref: 
def count ( a , b ) : NEW_LINE INDENT m = len ( a ) NEW_LINE n = len ( b ) NEW_LINE lookup = [ [ 0 ] * ( n + 1 ) for i in range ( m + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT lookup [ 0 ] [ i ] = 0 NEW_LINE DEDENT for i in range ( m + 1 ) : NEW_LINE INDENT lookup [ i ] [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if a [ i - 1 ] == b [ j - 1 ] : NEW_LINE INDENT lookup [ i ] [ j ] = lookup [ i - 1 ] [ j - 1 ] + lookup [ i - 1 ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT lookup [ i ] [ j ] = lookup [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return lookup [ m ] [ n ] NEW_LINE DEDENT
Hyp: 
def count ( a , b ) : NEW_LINE INDENT m = len ( a ) NEW_LINE n = len ( b ) NEW_LINE lookup = [ [ 0 for i in range ( n + 1 ) ] for j in range ( m + 1 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT lookup [ 0 ] [ i ] = 0 NEW_LINE DEDENT for i in range ( n + 1 ) : NEW_LINE INDENT lookup [ i ] [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( a [ i - 1 ] == b [ j - 1 ] ) : NEW_LINE INDENT lookup [ i ] [ j ] = lookup [ i - 1 ] [ j - 1 ] + lookup [ i - 1 ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT lookup [ i ] [ j ] = lookup [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return lookup [ m ] [ n ] NEW_LINE DEDENT

BLEU: 93.84
Edit Sim: 22


Src: 
int find_extra_element_index ( int arrA [ ] , int arrB [ ] , int n , int m ) { int extra_element = sum ( arrA , n ) - sum ( arrB , m ) ; return indexOf ( arrA , extra_element , n ) ; }
Ref: 
def find_extra_element_index ( arrA , arrB ) : NEW_LINE INDENT extra_element = sum ( arrA ) - sum ( arrB ) NEW_LINE return arrA . index ( extra_element ) NEW_LINE DEDENT
Hyp: 
def find_extra_element_index ( arrA , arrB , n , m ) : NEW_LINE INDENT extra_element = sum ( arrA , n ) - sum ( arrB , m ) NEW_LINE return indexOf ( arrA , extra_element , n ) NEW_LINE DEDENT

BLEU: 47.32
Edit Sim: 34


Src: 
int find ( int a [ ] , int b [ ] , int k , int n1 , int n2 ) { unordered_set < int > s ; for ( int i = 0 ; i < n2 ; i ++ ) s . insert ( b [ i ] ) ; int missing = 0 ; for ( int i = 0 ; i < n1 ; i ++ ) { if ( s . find ( a [ i ] ) == s . end ( ) ) missing ++ ; if ( missing == k ) return a [ i ] ; } return - 1 ; }
Ref: 
def find ( a , b , k , n1 , n2 ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( n2 ) : NEW_LINE INDENT s . add ( b [ i ] ) NEW_LINE DEDENT missing = 0 NEW_LINE for i in range ( n1 ) : NEW_LINE INDENT if a [ i ] not in s : NEW_LINE INDENT missing += 1 NEW_LINE DEDENT if missing == k : NEW_LINE INDENT return a [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
Hyp: 
def find ( a , b , k , n1 , n2 ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( n2 ) : NEW_LINE INDENT s . add ( b [ i ] ) NEW_LINE DEDENT missing = 0 NEW_LINE for i in range ( n1 ) : NEW_LINE INDENT if ( a [ i ] not in s ) : NEW_LINE INDENT missing += 1 NEW_LINE DEDENT if ( missing == k ) : NEW_LINE INDENT return a [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT

BLEU: 89.46
Edit Sim: 8


Src: 
int sumNodes ( int l ) { int leafNodeCount = pow ( 2 , l - 1 ) ; int sumLastLevel = 0 ; sumLastLevel = ( leafNodeCount * ( leafNodeCount + 1 ) ) / 2 ; int sum = sumLastLevel * l ; return sum ; }
Ref: 
def sumNodes ( l ) : NEW_LINE INDENT leafNodeCount = math . pow ( 2 , l - 1 ) NEW_LINE sumLastLevel = 0 NEW_LINE sumLastLevel = ( ( leafNodeCount * ( leafNodeCount + 1 ) ) / 2 ) NEW_LINE sum = sumLastLevel * l NEW_LINE return int ( sum ) NEW_LINE DEDENT
Hyp: 
def sumNodes ( l ) : NEW_LINE INDENT leafNodeCount = int ( math . pow ( 2 , l - 1 ) ) NEW_LINE sumLastLevel = 0 NEW_LINE sumLastLevel = ( leafNodeCount * ( leafNodeCount + 1 ) ) / 2 NEW_LINE sum = sumLastLevel * l NEW_LINE return sum NEW_LINE DEDENT

BLEU: 79.25
Edit Sim: 20


Src: 
int leonardo ( int n ) { int dp [ n + 1 ] ; dp [ 0 ] = dp [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] + 1 ; return dp [ n ] ; }
Ref: 
def leonardo ( n ) : NEW_LINE INDENT dp = [ ] NEW_LINE dp . append ( 1 ) NEW_LINE dp . append ( 1 ) NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT dp . append ( dp [ i - 1 ] + dp [ i - 2 ] + 1 ) NEW_LINE DEDENT return dp [ n ] NEW_LINE DEDENT
Hyp: 
def leonardo ( n ) : NEW_LINE INDENT dp = [ 0 for i in range ( n + 1 ) ] NEW_LINE dp [ 0 ] = dp [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] + 1 NEW_LINE DEDENT return dp [ n ] NEW_LINE DEDENT

BLEU: 62.86
Edit Sim: 46


Src: 
int countNumber ( int n ) { int result = 0 ; for ( int i = 1 ; i <= 9 ; i ++ ) { stack < int > s ; if ( i <= n ) { s . push ( i ) ; result ++ ; } while ( ! s . empty ( ) ) { int tp = s . top ( ) ; s . pop ( ) ; for ( int j = tp % 10 ; j <= 9 ; j ++ ) { int x = tp * 10 + j ; if ( x <= n ) { s . push ( x ) ; result ++ ; } } } } return result ; }
Ref: 
def countNumber ( n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 1 , 10 ) : NEW_LINE INDENT s = [ ] NEW_LINE if ( i <= n ) : NEW_LINE INDENT s . append ( i ) NEW_LINE result += 1 NEW_LINE DEDENT while len ( s ) != 0 : NEW_LINE INDENT tp = s [ - 1 ] NEW_LINE s . pop ( ) NEW_LINE for j in range ( tp % 10 , 10 ) : NEW_LINE INDENT x = tp * 10 + j NEW_LINE if ( x <= n ) : NEW_LINE INDENT s . append ( x ) NEW_LINE result += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
Hyp: 
def countNumber ( n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 1 , 9 + 1 ) : NEW_LINE INDENT s = [ ] NEW_LINE if ( i <= n ) : NEW_LINE INDENT s . append ( i ) NEW_LINE result += 1 NEW_LINE DEDENT while ( len ( s ) != 0 ) : NEW_LINE INDENT tp = s [ - 1 ] NEW_LINE s . pop ( ) NEW_LINE for j in range ( tp % 10 , 9 + 1 ) : NEW_LINE INDENT x = tp * 10 + j NEW_LINE if ( x <= n ) : NEW_LINE INDENT s . append ( x ) NEW_LINE result += 1 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT

BLEU: 89.0
Edit Sim: 21


Src: 
bool check ( int degree [ ] , int n ) { int deg_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) deg_sum += degree [ i ] ; return ( 2 * ( n - 1 ) == deg_sum ) ; }
Ref: 
def check ( degree , n ) : NEW_LINE INDENT deg_sum = sum ( degree ) NEW_LINE if ( 2 * ( n - 1 ) == deg_sum ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
Hyp: 
def check ( degree , n ) : NEW_LINE INDENT deg_sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT deg_sum += degree [ i ] NEW_LINE DEDENT return ( 2 * ( n - 1 ) == deg_sum ) NEW_LINE DEDENT

BLEU: 53.65
Edit Sim: 92


Src: 
int evenbinomialCoeffSum ( int n ) { return ( 1 << ( n - 1 ) ) ; }
Ref: 
def evenbinomialCoeffSum ( n ) : NEW_LINE INDENT return ( 1 << ( n - 1 ) ) NEW_LINE DEDENT
Hyp: 
def evenbinomialCoeffSum ( n ) : NEW_LINE INDENT return ( 1 << ( n - 1 ) ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int findMin ( int arr [ ] , int low , int high ) { if ( high < low ) return arr [ 0 ] ; if ( high == low ) return arr [ low ] ; int mid = low + ( high - low ) / 2 ; if ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) return arr [ mid + 1 ] ; if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) return arr [ mid ] ; if ( arr [ high ] > arr [ mid ] ) return findMin ( arr , low , mid - 1 ) ; return findMin ( arr , mid + 1 , high ) ; }
Ref: 
def findMin ( arr , low , high ) : NEW_LINE INDENT if high < low : NEW_LINE INDENT return arr [ 0 ] NEW_LINE DEDENT if high == low : NEW_LINE INDENT return arr [ low ] NEW_LINE DEDENT mid = int ( ( low + high ) / 2 ) NEW_LINE if mid < high and arr [ mid + 1 ] < arr [ mid ] : NEW_LINE INDENT return arr [ mid + 1 ] NEW_LINE DEDENT if mid > low and arr [ mid ] < arr [ mid - 1 ] : NEW_LINE INDENT return arr [ mid ] NEW_LINE DEDENT if arr [ high ] > arr [ mid ] : NEW_LINE INDENT return findMin ( arr , low , mid - 1 ) NEW_LINE DEDENT return findMin ( arr , mid + 1 , high ) NEW_LINE DEDENT
Hyp: 
def findMin ( arr , low , high ) : NEW_LINE INDENT if high < low : NEW_LINE INDENT return arr [ 0 ] NEW_LINE DEDENT if high == low : NEW_LINE INDENT return arr [ low ] NEW_LINE DEDENT mid = low + ( high - low ) / 2 ; NEW_LINE if mid < high and arr [ mid + 1 ] < arr [ mid ] : NEW_LINE INDENT return arr [ mid + 1 ] NEW_LINE DEDENT if mid > low and arr [ mid ] < arr [ mid - 1 ] : NEW_LINE INDENT return arr [ mid ] NEW_LINE DEDENT if arr [ high ] > arr [ mid ] : NEW_LINE INDENT return findMin ( arr , low , mid - 1 ) NEW_LINE DEDENT return findMin ( arr , mid + 1 , high ) NEW_LINE DEDENT

BLEU: 93.93
Edit Sim: 14


Src: 
int findS ( int s ) { int sum = 0 ; for ( int n = 1 ; sum < s ; n ++ ) { sum += n * n ; if ( sum == s ) return n ; } return - 1 ; }
Ref: 
def findS ( s ) : NEW_LINE INDENT _sum = 0 NEW_LINE n = 1 NEW_LINE while ( _sum < s ) : NEW_LINE INDENT _sum += n * n NEW_LINE n += 1 NEW_LINE DEDENT n -= 1 NEW_LINE if _sum == s : NEW_LINE INDENT return n NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
Hyp: 
def findS ( s ) : NEW_LINE INDENT sum = 0 NEW_LINE for n in range ( 1 , s ) : NEW_LINE INDENT sum += n * n NEW_LINE if ( sum == s ) : NEW_LINE INDENT return n NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT

BLEU: 47.47
Edit Sim: 73


Src: 
char getMaxOccuringChar ( char * str ) { int count [ ASCII_SIZE ] = { 0 } ; int len = strlen ( str ) ; int max = 0 ; char result ; for ( int i = 0 ; i < len ; i ++ ) { count [ str [ i ] ] ++ ; if ( max < count [ str [ i ] ] ) { max = count [ str [ i ] ] ; result = str [ i ] ; } } return result ; }
Ref: 
def getMaxOccuringChar ( str ) : NEW_LINE INDENT count = [ 0 ] * ASCII_SIZE NEW_LINE max = - 1 NEW_LINE c = ' ' NEW_LINE for i in str : NEW_LINE INDENT count [ ord ( i ) ] += 1 ; NEW_LINE DEDENT for i in str : NEW_LINE INDENT if max < count [ ord ( i ) ] : NEW_LINE INDENT max = count [ ord ( i ) ] NEW_LINE c = i NEW_LINE DEDENT DEDENT return c NEW_LINE DEDENT
Hyp: 
def getMaxOccuringChar ( str ) : NEW_LINE INDENT count = [ 0 ] * ASCII_SIZE NEW_LINE l = len ( str ) NEW_LINE max = 0 NEW_LINE result = ' ' NEW_LINE for i in range ( l ) : NEW_LINE INDENT count [ ord ( str [ i ] ) ] = count [ ord ( str [ i ] ) ] + 1 NEW_LINE if ( max < count [ ord ( str [ i ] ) ] ) : NEW_LINE INDENT max = count [ ord ( str [ i ] ) ] NEW_LINE result = str [ i ] NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT

BLEU: 43.02
Edit Sim: 126


Src: 
int countStr ( int n ) { return 1 + ( n * 2 ) + ( n * ( ( n * n ) - 1 ) / 2 ) ; }
Ref: 
def countStr ( n ) : NEW_LINE INDENT return ( 1 + ( n * 2 ) + ( n * ( ( n * n ) - 1 ) // 2 ) ) NEW_LINE DEDENT
Hyp: 
def countStr ( n ) : NEW_LINE INDENT return 1 + ( n * 2 ) + ( n * ( ( n * n ) - 1 ) / 2 ) NEW_LINE DEDENT

BLEU: 80.96
Edit Sim: 5


Src: 
void printSumSimple ( int mat [ ] [ n ] , int k ) { if ( k > n ) return ; for ( int i = 0 ; i < n - k + 1 ; i ++ ) { for ( int j = 0 ; j < n - k + 1 ; j ++ ) { int sum = 0 ; for ( int p = i ; p < k + i ; p ++ ) for ( int q = j ; q < k + j ; q ++ ) sum += mat [ p ] [ q ] ; cout << sum << " ▁ ▁ " ; } cout << endl ; } }
Ref: 
def printSumSimple ( mat , k ) : NEW_LINE INDENT if ( k > n ) : NEW_LINE INDENT return NEW_LINE DEDENT for i in range ( n - k + 1 ) : NEW_LINE INDENT for j in range ( n - k + 1 ) : NEW_LINE INDENT sum = 0 NEW_LINE for p in range ( i , k + i ) : NEW_LINE INDENT for q in range ( j , k + j ) : NEW_LINE INDENT sum += mat [ p ] [ q ] NEW_LINE DEDENT DEDENT print ( sum , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT
Hyp: 
def printSumSimple ( mat , k ) : NEW_LINE INDENT global n NEW_LINE if k > n : NEW_LINE INDENT return NEW_LINE DEDENT for i in range ( 0 , n - k + 1 ) : NEW_LINE INDENT for j in range ( 0 , n - k + 1 ) : NEW_LINE INDENT sum = 0 NEW_LINE for p in range ( i , k + i ) : NEW_LINE INDENT for q in range ( j , k + j ) : NEW_LINE INDENT sum += mat [ p ] [ q ] NEW_LINE DEDENT DEDENT print ( sum , end = " ▁ " ) NEW_LINE DEDENT DEDENT

BLEU: 87.72
Edit Sim: 55


Src: 
void findCount ( int n , int sum ) { int start = pow ( 10 , n - 1 ) ; int end = pow ( 10 , n ) - 1 ; int count = 0 ; int i = start ; while ( i <= end ) { int cur = 0 ; int temp = i ; while ( temp != 0 ) { cur += temp % 10 ; temp = temp / 10 ; } if ( cur == sum ) { count ++ ; i += 9 ; } else i ++ ; } cout << count ; }
Ref: 
def findCount ( n , sum ) : NEW_LINE INDENT start = math . pow ( 10 , n - 1 ) NEW_LINE end = math . pow ( 10 , n ) - 1 NEW_LINE count = 0 NEW_LINE i = start NEW_LINE while ( i <= end ) : NEW_LINE INDENT cur = 0 NEW_LINE temp = i NEW_LINE while ( temp != 0 ) : NEW_LINE INDENT cur += temp % 10 NEW_LINE temp = temp // 10 NEW_LINE DEDENT if ( cur == sum ) : NEW_LINE INDENT count = count + 1 NEW_LINE i += 9 NEW_LINE DEDENT else : NEW_LINE INDENT i = i + 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT
Hyp: 
def findCount ( n , sum ) : NEW_LINE INDENT start = pow ( 10 , n - 1 ) NEW_LINE end = pow ( 10 , n ) - 1 NEW_LINE count = 0 NEW_LINE i = start NEW_LINE while ( i <= end ) : NEW_LINE INDENT cur = 0 NEW_LINE temp = i NEW_LINE while ( temp != 0 ) : NEW_LINE INDENT cur += temp % 10 NEW_LINE temp = int ( temp / 10 ) NEW_LINE DEDENT if ( cur == sum ) : NEW_LINE INDENT count += 1 NEW_LINE i += 9 NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT

BLEU: 83.12
Edit Sim: 37


Src: 
int countGroups ( int position , int previous_sum , int length , char * num ) { if ( position == length ) return 1 ; if ( dp [ position ] [ previous_sum ] != - 1 ) return dp [ position ] [ previous_sum ] ; dp [ position ] [ previous_sum ] = 0 ; int res = 0 ; int sum = 0 ; for ( int i = position ; i < length ; i ++ ) { sum += ( num [ i ] - '0' ) ; if ( sum >= previous_sum ) res += countGroups ( i + 1 , sum , length , num ) ; } dp [ position ] [ previous_sum ] = res ; return res ; }
Ref: 
def countGroups ( position , previous_sum , length , num ) : NEW_LINE INDENT if ( position == length ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( dp [ position ] [ previous_sum ] != - 1 ) : NEW_LINE INDENT return dp [ position ] [ previous_sum ] NEW_LINE DEDENT dp [ position ] [ previous_sum ] = 0 NEW_LINE res = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( position , length ) : NEW_LINE INDENT sum += ( ord ( num [ i ] ) - ord ( '0' ) ) NEW_LINE if ( sum >= previous_sum ) : NEW_LINE INDENT res += countGroups ( i + 1 , sum , length , num ) NEW_LINE DEDENT DEDENT dp [ position ] [ previous_sum ] = res NEW_LINE return res NEW_LINE DEDENT
Hyp: 
def countGroups ( position , previous_sum , length , num ) : NEW_LINE INDENT if ( position == length ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( dp [ position ] [ previous_sum ] != - 1 ) : NEW_LINE INDENT return dp [ position ] [ previous_sum ] NEW_LINE DEDENT dp [ position ] [ previous_sum ] = 0 NEW_LINE res = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( position , length ) : NEW_LINE INDENT sum = sum + int ( num [ i ] ) NEW_LINE if ( sum >= previous_sum ) : NEW_LINE INDENT res = res + countGroups ( i + 1 , sum , length , num ) NEW_LINE DEDENT DEDENT dp [ position ] [ previous_sum ] = res NEW_LINE return res NEW_LINE DEDENT

BLEU: 90.08
Edit Sim: 31


Src: 
int intersection ( int n ) { return n * ( n - 1 ) ; }
Ref: 
def intersection ( n ) : NEW_LINE INDENT return n * ( n - 1 ) NEW_LINE DEDENT
Hyp: 
def intersection ( n ) : NEW_LINE INDENT return n * ( n - 1 ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int findSum ( int n ) { n -- ; int sum = 0 ; sum += ( n * ( n + 1 ) ) / 2 ; sum += ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; return sum ; }
Ref: 
def findSum ( n ) : NEW_LINE INDENT n -= 1 NEW_LINE sum = 0 NEW_LINE sum += ( n * ( n + 1 ) ) / 2 NEW_LINE sum += ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 NEW_LINE return int ( sum ) NEW_LINE DEDENT
Hyp: 
def findSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE sum += ( n * ( n + 1 ) ) / 2 NEW_LINE sum += ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 NEW_LINE return int ( sum ) NEW_LINE DEDENT

BLEU: 90.36
Edit Sim: 16


Src: 
int findRepeatingElement ( int arr [ ] , int low , int high ) { if ( low > high ) return - 1 ; int mid = ( low + high ) / 2 ; if ( arr [ mid ] != mid + 1 ) { if ( mid > 0 && arr [ mid ] == arr [ mid - 1 ] ) return mid ; return findRepeatingElement ( arr , low , mid - 1 ) ; } return findRepeatingElement ( arr , mid + 1 , high ) ; }
Ref: 
def findRepeatingElement ( arr , low , high ) : NEW_LINE INDENT if low > high : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = ( low + high ) / 2 NEW_LINE if ( arr [ mid ] != mid + 1 ) : NEW_LINE INDENT if ( mid > 0 and arr [ mid ] == arr [ mid - 1 ] ) : NEW_LINE INDENT return mid NEW_LINE DEDENT return findRepeatingElement ( arr , low , mid - 1 ) NEW_LINE DEDENT return findRepeatingElement ( arr , mid + 1 , high ) NEW_LINE DEDENT
Hyp: 
def findRepeatingElement ( arr , low , high ) : NEW_LINE INDENT if ( low > high ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = int ( ( low + high ) / 2 ) NEW_LINE if ( arr [ mid ] != mid + 1 ) : NEW_LINE INDENT if ( mid > 0 and arr [ mid ] == arr [ mid - 1 ] ) : NEW_LINE INDENT return mid NEW_LINE DEDENT return findRepeatingElement ( arr , low , mid - 1 ) NEW_LINE DEDENT

BLEU: 81.2
Edit Sim: 81


Src: 
int smallest ( int x , int y , int z ) { int c = 0 ; while ( x && y && z ) { x -- ; y -- ; z -- ; c ++ ; } return c ; }
Ref: 
def smallest ( x , y , z ) : NEW_LINE INDENT c = 0 NEW_LINE while ( x and y and z ) : NEW_LINE INDENT x = x - 1 NEW_LINE y = y - 1 NEW_LINE z = z - 1 NEW_LINE c = c + 1 NEW_LINE DEDENT return c NEW_LINE DEDENT
Hyp: 
def smallest ( x , y , z ) : NEW_LINE INDENT c = 0 NEW_LINE while ( x and y and z ) : NEW_LINE INDENT x -= 1 NEW_LINE y -= 1 NEW_LINE z -= 1 NEW_LINE c += 1 NEW_LINE DEDENT return c NEW_LINE DEDENT

BLEU: 66.09
Edit Sim: 20


Src: 
double maxAverageOfPath ( int cost [ M ] [ M ] , int N ) { int dp [ N + 1 ] [ N + 1 ] ; dp [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ] ; for ( int j = 1 ; j < N ; j ++ ) dp [ 0 ] [ j ] = dp [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ] ; for ( int i = 1 ; i < N ; i ++ ) for ( int j = 1 ; j <= N ; j ++ ) dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) + cost [ i ] [ j ] ; return ( double ) dp [ N - 1 ] [ N - 1 ] / ( 2 * N - 1 ) ; }
Ref: 
def maxAverageOfPath ( cost , N ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( N + 1 ) ] for j in range ( N + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ] NEW_LINE DEDENT for j in range ( 1 , N ) : NEW_LINE INDENT dp [ 0 ] [ j ] = dp [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ] NEW_LINE DEDENT for i in range ( 1 , N ) : NEW_LINE INDENT for j in range ( 1 , N ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) + cost [ i ] [ j ] NEW_LINE DEDENT DEDENT return dp [ N - 1 ] [ N - 1 ] / ( 2 * N - 1 ) NEW_LINE DEDENT
Hyp: 
def maxAverageOfPath ( cost , N ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( N + 1 ) ] for j in range ( N + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ] NEW_LINE DEDENT for j in range ( 1 , N + 1 ) : NEW_LINE INDENT dp [ 0 ] [ j ] = dp [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ] NEW_LINE DEDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( 1 , N + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) + cost [ i ] [ j ] NEW_LINE DEDENT DEDENT return ( double ) dp [ N - 1 ] [ N - 1 ] / ( 2 * N - 1 ) NEW_LINE DEDENT

BLEU: 93.32
Edit Sim: 23


Src: 
int countPairsWithDiffK ( int arr [ ] , int n , int k ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] - arr [ j ] == k || arr [ j ] - arr [ i ] == k ) count ++ ; } return count ; }
Ref: 
def countPairsWithDiffK ( arr , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if arr [ i ] - arr [ j ] == k or arr [ j ] - arr [ i ] == k : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
Hyp: 
def countPairsWithDiffK ( arr , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] - arr [ j ] == k or arr [ j ] - arr [ i ] == k ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT

BLEU: 93.78
Edit Sim: 4


Src: 
int longLenSub ( int arr [ ] , int n ) { unordered_map < int , int > um ; int longLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int len = 0 ; if ( um . find ( arr [ i ] - 1 ) != um . end ( ) && len < um [ arr [ i ] - 1 ] ) len = um [ arr [ i ] - 1 ] ; if ( um . find ( arr [ i ] + 1 ) != um . end ( ) && len < um [ arr [ i ] + 1 ] ) len = um [ arr [ i ] + 1 ] ; um [ arr [ i ] ] = len + 1 ; if ( longLen < um [ arr [ i ] ] ) longLen = um [ arr [ i ] ] ; } return longLen ; }
Ref: 
def longLenSub ( arr , n ) : NEW_LINE INDENT um = defaultdict ( lambda : 0 ) NEW_LINE longLen = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT len1 = 0 NEW_LINE if ( arr [ i - 1 ] in um and len1 < um [ arr [ i ] - 1 ] ) : NEW_LINE INDENT len1 = um [ arr [ i ] - 1 ] NEW_LINE DEDENT if ( arr [ i ] + 1 in um and len1 < um [ arr [ i ] + 1 ] ) : NEW_LINE INDENT len1 = um [ arr [ i ] + 1 ] NEW_LINE DEDENT um [ arr [ i ] ] = len1 + 1 NEW_LINE if longLen < um [ arr [ i ] ] : NEW_LINE INDENT longLen = um [ arr [ i ] ] NEW_LINE DEDENT DEDENT return longLen NEW_LINE DEDENT
Hyp: 
def longLenSub ( arr , n ) : NEW_LINE INDENT um = dict ( ) NEW_LINE longLen = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT len = 0 NEW_LINE if ( arr [ i ] - 1 ) in um : NEW_LINE INDENT len = um [ arr [ i ] - 1 ] NEW_LINE DEDENT if ( um [ arr [ i ] + 1 ) in um : NEW_LINE INDENT len = um [ arr [ i ] + 1 ] NEW_LINE DEDENT um [ arr [ i ] ] = len + 1 NEW_LINE if ( longLen < um [ arr [ i ] ] ) : NEW_LINE INDENT longLen = um [ arr [ i ] ] NEW_LINE DEDENT DEDENT return longLen NEW_LINE DEDENT

BLEU: 67.49
Edit Sim: 99


Src: 
bool isPrime ( int n , int i = 2 ) { if ( n <= 2 ) return ( n == 2 ) ? true : false ; if ( n % i == 0 ) return false ; if ( i * i > n ) return true ; return isPrime ( n , i + 1 ) ; }
Ref: 
def isPrime ( n , i = 2 ) : NEW_LINE INDENT if ( n <= 2 ) : NEW_LINE INDENT return True if ( n == 2 ) else False NEW_LINE DEDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( i * i > n ) : NEW_LINE INDENT return true NEW_LINE DEDENT return isPrime ( n , i + 1 ) NEW_LINE DEDENT
Hyp: 
def isPrime ( n , i ) : NEW_LINE INDENT if ( n <= 2 ) : NEW_LINE INDENT return ( n == 2 ) NEW_LINE DEDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( i * i > n ) : NEW_LINE INDENT return True NEW_LINE DEDENT return isPrime ( n , i + 1 ) NEW_LINE DEDENT

BLEU: 83.08
Edit Sim: 24


Src: 
int computeLastDigit ( long long int A , long long int B ) { int variable = 1 ; if ( A == B ) return 1 ; else if ( ( B - A ) >= 5 ) return 0 ; else { for ( long long int i = A + 1 ; i <= B ; i ++ ) variable = ( variable * ( i % 10 ) ) % 10 ; return variable % 10 ; } }
Ref: 
def computeLastDigit ( A , B ) : NEW_LINE INDENT variable = 1 NEW_LINE if ( A == B ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( ( B - A ) >= 5 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( A + 1 , B + 1 ) : NEW_LINE INDENT variable = ( variable * ( i % 10 ) ) % 10 NEW_LINE DEDENT return variable % 10 NEW_LINE DEDENT DEDENT
Hyp: 
def computeLastDigit ( A , B ) : NEW_LINE INDENT variable = 1 NEW_LINE if A == B : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( B - A ) >= 5 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( A + 1 , B + 1 ) : NEW_LINE INDENT variable = ( variable * ( i % 10 ) ) % 10 NEW_LINE DEDENT return variable % 10 NEW_LINE DEDENT

BLEU: 90.74
Edit Sim: 13


Src: 
int minOperation ( bool arr [ N ] [ M ] ) { int ans = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { for ( int j = M - 1 ; j >= 0 ; j -- ) { if ( arr [ i ] [ j ] == 0 ) { ans ++ ; for ( int k = 0 ; k <= i ; k ++ ) { for ( int h = 0 ; h <= j ; h ++ ) { if ( arr [ k ] [ h ] == 1 ) arr [ k ] [ h ] = 0 ; else arr [ k ] [ h ] = 1 ; } } } } } return ans ; }
Ref: 
def minOperation ( arr ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( M - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] [ j ] == 0 ) : NEW_LINE INDENT ans += 1 NEW_LINE for k in range ( i + 1 ) : NEW_LINE INDENT for h in range ( j + 1 ) : NEW_LINE INDENT if ( arr [ k ] [ h ] == 1 ) : NEW_LINE INDENT arr [ k ] [ h ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ k ] [ h ] = 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
Hyp: 
def minOperation ( arr ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( M - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] [ j ] == 0 ) : NEW_LINE INDENT ans += 1 NEW_LINE for k in range ( i + 1 , M + 1 ) : NEW_LINE INDENT for h in range ( j + 1 ) : NEW_LINE INDENT if ( arr [ k ] [ h ] == 1 ) : NEW_LINE INDENT arr [ k ] [ h ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ k ] [ h ] = 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT

BLEU: 97.04
Edit Sim: 15


Src: 
unsigned int nextPowerOf2 ( unsigned int n ) { unsigned int p = 1 ; if ( n && ! ( n & ( n - 1 ) ) ) return n ; while ( p < n ) p <<= 1 ; return p ; }
Ref: 
def nextPowerOf2 ( n ) : NEW_LINE INDENT p = 1 NEW_LINE if ( n and not ( n & ( n - 1 ) ) ) : NEW_LINE INDENT return n NEW_LINE DEDENT while ( p < n ) : NEW_LINE INDENT p <<= 1 NEW_LINE DEDENT return p NEW_LINE DEDENT
Hyp: 
def nextPowerOf2 ( n ) : NEW_LINE INDENT p = 1 NEW_LINE if ( n and not ( n & ( n - 1 ) ) ) : NEW_LINE INDENT return n NEW_LINE DEDENT while ( p < n ) : NEW_LINE INDENT p <<= 1 NEW_LINE DEDENT return p NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int getMinDiff ( int arr [ ] , int n , int k ) { if ( n == 1 ) return 0 ; sort ( arr , arr + n ) ; int ans = arr [ n - 1 ] - arr [ 0 ] ; int small = arr [ 0 ] + k ; int big = arr [ n - 1 ] - k ; if ( small > big ) swap ( small , big ) ; for ( int i = 1 ; i < n - 1 ; i ++ ) { int subtract = arr [ i ] - k ; int add = arr [ i ] + k ; if ( subtract >= small || add <= big ) continue ; if ( big - subtract <= add - small ) small = subtract ; else big = add ; } return min ( ans , big - small ) ; }
Ref: 
def getMinDiff ( arr , n , k ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT arr . sort ( ) NEW_LINE ans = arr [ n - 1 ] - arr [ 0 ] NEW_LINE small = arr [ 0 ] + k NEW_LINE big = arr [ n - 1 ] - k NEW_LINE if ( small > big ) : NEW_LINE INDENT small , big = big , small NEW_LINE DEDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT subtract = arr [ i ] - k NEW_LINE add = arr [ i ] + k NEW_LINE if ( subtract >= small or add <= big ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( big - subtract <= add - small ) : NEW_LINE INDENT small = subtract NEW_LINE DEDENT else : NEW_LINE INDENT big = add NEW_LINE DEDENT DEDENT return min ( ans , big - small ) NEW_LINE DEDENT
Hyp: 
def getMinDiff ( arr , n , k ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT arr . sort ( ) NEW_LINE ans = arr [ n - 1 ] - arr [ 0 ] NEW_LINE small = arr [ 0 ] + k NEW_LINE big = arr [ n - 1 ] - k NEW_LINE if ( small > big ) : NEW_LINE INDENT small = big NEW_LINE DEDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT subtract = arr [ i ] - k NEW_LINE add = arr [ i ] + k NEW_LINE if ( subtract >= small or add <= big ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( big - subtract <= add - small ) : NEW_LINE INDENT small = subtract NEW_LINE DEDENT else : NEW_LINE INDENT big = add NEW_LINE DEDENT DEDENT return min ( ans , big - small ) NEW_LINE DEDENT

BLEU: 95.98
Edit Sim: 14


Src: 
int numberofways ( int n , int m ) { int dp [ n + 2 ] [ n + 2 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; dp [ 0 ] [ n + 1 ] = 1 ; for ( int k = n ; k >= m ; k -- ) { for ( int i = 0 ; i <= n ; i ++ ) { dp [ i ] [ k ] = dp [ i ] [ k + 1 ] ; if ( i - k >= 0 ) dp [ i ] [ k ] = ( dp [ i ] [ k ] + dp [ i - k ] [ k ] ) ; } } return dp [ n ] [ m ] ; }
Ref: 
def numberofways ( n , m ) : NEW_LINE INDENT dp = np . zeros ( ( n + 2 , n + 2 ) ) NEW_LINE dp [ 0 ] [ n + 1 ] = 1 NEW_LINE for k in range ( n , m - 1 , - 1 ) : NEW_LINE INDENT for i in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ k ] = dp [ i ] [ k + 1 ] NEW_LINE if ( i - k >= 0 ) : NEW_LINE INDENT dp [ i ] [ k ] = ( dp [ i ] [ k ] + dp [ i - k ] [ k ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ n ] [ m ] NEW_LINE DEDENT
Hyp: 
def numberofways ( n , m ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n + 2 ) ] for j in range ( n + 2 ) ] NEW_LINE dp [ 0 ] [ n + 1 ] = 1 NEW_LINE for k in range ( n , m + 1 ) : NEW_LINE INDENT for i in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ k ] = dp [ i ] [ k + 1 ] NEW_LINE if i - k >= 0 : NEW_LINE INDENT dp [ i ] [ k ] = ( dp [ i ] [ k ] + dp [ i - k ] [ k ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ n ] [ m ] NEW_LINE DEDENT

BLEU: 82.47
Edit Sim: 48


Src: 
bool check ( int n ) { return 1162261467 % n == 0 ; }
Ref: 
def check ( n ) : NEW_LINE INDENT return 1162261467 % n == 0 NEW_LINE DEDENT
Hyp: 
def check ( n ) : NEW_LINE INDENT return 1162261467 % n == 0 NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int sequence ( int n ) { if ( n == 1 || n == 2 ) return 1 ; else return sequence ( sequence ( n - 1 ) ) + sequence ( n - sequence ( n - 1 ) ) ; }
Ref: 
def sequence ( n ) : NEW_LINE INDENT if n == 1 or n == 2 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return sequence ( sequence ( n - 1 ) ) + sequence ( n - sequence ( n - 1 ) ) ; NEW_LINE DEDENT DEDENT
Hyp: 
def sequence ( n ) : NEW_LINE INDENT if n == 1 or n == 2 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return sequence ( sequence ( n - 1 ) ) + sequence ( n - sequence ( n - 1 ) ) NEW_LINE DEDENT DEDENT

BLEU: 95.17
Edit Sim: 2


Src: 
void generate_derangement ( int N ) { int S [ N + 1 ] ; for ( int i = 1 ; i <= N ; i ++ ) S [ i ] = i ; int D [ N + 1 ] ; for ( int i = 1 ; i <= N ; i += 2 ) { if ( i == N && i % N != 0 ) { int temp = D [ N ] D [ N ] = D [ N - 1 ] ; D [ N - 1 ] = temp ; } else { D [ i ] = i + 1 ; D [ i + 1 ] = i ; } } for ( int i = 1 ; i <= N ; i ++ ) printf ( " % d ▁ " , D [ i ] ) ; printf ( " \n " ) ; }
Ref: 
def generate_derangement ( N ) : NEW_LINE INDENT S = [ 0 ] * ( N + 1 ) NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT S [ i ] = i NEW_LINE DEDENT D = [ 0 ] * ( N + 1 ) NEW_LINE for i in range ( 1 , N + 1 , 2 ) : NEW_LINE INDENT if i == N : NEW_LINE INDENT D [ N ] = S [ N - 1 ] NEW_LINE D [ N - 1 ] = S [ N ] NEW_LINE DEDENT else : NEW_LINE INDENT D [ i ] = i + 1 NEW_LINE D [ i + 1 ] = i NEW_LINE DEDENT DEDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT print ( D [ i ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT
Hyp: 
def generate_derangement ( N ) : NEW_LINE INDENT S = [ 0 ] * ( N + 1 ) NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT S [ i ] = i NEW_LINE DEDENT D = [ 0 ] * ( N + 1 ) NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if i == N and i % N != 0 : NEW_LINE INDENT temp = D [ N ] D [ N ] = D [ N - 1 ] NEW_LINE D [ N - 1 ] = temp NEW_LINE DEDENT else : NEW_LINE INDENT D [ i ] = i + 1 NEW_LINE D [ i + 1 ] = i NEW_LINE DEDENT DEDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT print ( D [ i ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT

BLEU: 87.86
Edit Sim: 42


Src: 
int countTriangle ( int graph [ V ] [ V ] , bool isDirected ) { int count_Triangle = 0 ; for ( int i = 0 ; i < V ; i ++ ) { for ( int j = 0 ; j < V ; j ++ ) { for ( int k = 0 ; k < V ; k ++ ) { if ( graph [ i ] [ j ] && graph [ j ] [ k ] && graph [ k ] [ i ] ) count_Triangle ++ ; } } } isDirected ? count_Triangle /= 3 : count_Triangle /= 6 ; return count_Triangle ; }
Ref: 
def countTriangle ( g , isDirected ) : NEW_LINE INDENT nodes = len ( g ) NEW_LINE count_Triangle = 0 NEW_LINE for i in range ( nodes ) : NEW_LINE INDENT for j in range ( nodes ) : NEW_LINE INDENT for k in range ( nodes ) : NEW_LINE INDENT if ( i != j and i != k and j != k and g [ i ] [ j ] and g [ j ] [ k ] and g [ k ] [ i ] ) : NEW_LINE INDENT count_Triangle += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return count_Triangle / 3 if isDirected else count_Triangle / 6 NEW_LINE DEDENT
Hyp: 
def countTriangle ( graph , isDirected ) : NEW_LINE INDENT count_Triangle = 0 NEW_LINE for i in range ( V ) : NEW_LINE INDENT for j in range ( V ) : NEW_LINE INDENT for k in range ( V ) : NEW_LINE INDENT if ( graph [ i ] [ j ] and graph [ j ] [ k ] and graph [ k ] [ i ] ) : NEW_LINE INDENT count_Triangle += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT isDirected ? count_Triangle // 3 : NEW_LINE INDENT count_Triangle // 6 NEW_LINE return count_Triangle NEW_LINE DEDENT

BLEU: 56.03
Edit Sim: 146


Src: 
int findHeight ( int * parent , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int p = i , current = 1 ; while ( parent [ p ] != - 1 ) { current ++ ; p = parent [ p ] ; } res = max ( res , current ) ; } return res ; }
Ref: 
def findHeight ( parent , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT p = i NEW_LINE current = 1 NEW_LINE while ( parent [ p ] != - 1 ) : NEW_LINE INDENT current += 1 NEW_LINE p = parent [ p ] NEW_LINE DEDENT res = max ( res , current ) NEW_LINE DEDENT return res NEW_LINE DEDENT
Hyp: 
def findHeight ( parent , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT p = i NEW_LINE current = 1 NEW_LINE while ( parent [ p ] != - 1 ) : NEW_LINE INDENT current += 1 NEW_LINE p = parent [ p ] NEW_LINE DEDENT res = max ( res , current ) NEW_LINE DEDENT return res NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int leonardo ( int n ) { if ( n == 0 || n == 1 ) return 1 ; return leonardo ( n - 1 ) + leonardo ( n - 2 ) + 1 ; }
Ref: 
def leonardo ( n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return ( leonardo ( n - 1 ) + leonardo ( n - 2 ) + 1 ) NEW_LINE DEDENT
Hyp: 
def leonardo ( n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return leonardo ( n - 1 ) + leonardo ( n - 2 ) + 1 NEW_LINE DEDENT

BLEU: 89.05
Edit Sim: 4


Src: 
int findLargestPlus ( int mat [ N ] [ N ] ) { int left [ N ] [ N ] , right [ N ] [ N ] , top [ N ] [ N ] , bottom [ N ] [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { top [ 0 ] [ i ] = mat [ 0 ] [ i ] ; bottom [ N - 1 ] [ i ] = mat [ N - 1 ] [ i ] ; left [ i ] [ 0 ] = mat [ i ] [ 0 ] ; right [ i ] [ N - 1 ] = mat [ i ] [ N - 1 ] ; } for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 1 ; j < N ; j ++ ) { if ( mat [ i ] [ j ] == 1 ) left [ i ] [ j ] = left [ i ] [ j - 1 ] + 1 ; else left [ i ] [ j ] = 0 ; if ( mat [ j ] [ i ] == 1 ) top [ j ] [ i ] = top [ j - 1 ] [ i ] + 1 ; else top [ j ] [ i ] = 0 ; j = N - 1 - j ; if ( mat [ j ] [ i ] == 1 ) bottom [ j ] [ i ] = bottom [ j + 1 ] [ i ] + 1 ; else bottom [ j ] [ i ] = 0 ; if ( mat [ i ] [ j ] == 1 ) right [ i ] [ j ] = right [ i ] [ j + 1 ] + 1 ; else right [ i ] [ j ] = 0 ; j = N - 1 - j ; } } int n = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { int len = min ( min ( top [ i ] [ j ] , bottom [ i ] [ j ] ) , min ( left [ i ] [ j ] , right [ i ] [ j ] ) ) ; if ( len > n ) n = len ; } } if ( n ) return 4 * ( n - 1 ) + 1 ; return 0 ; }
Ref: 
def findLargestPlus ( mat ) : NEW_LINE INDENT left = [ [ 0 for x in range ( N ) ] for y in range ( N ) ] NEW_LINE right = [ [ 0 for x in range ( N ) ] for y in range ( N ) ] NEW_LINE top = [ [ 0 for x in range ( N ) ] for y in range ( N ) ] NEW_LINE bottom = [ [ 0 for x in range ( N ) ] for y in range ( N ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT top [ 0 ] [ i ] = mat [ 0 ] [ i ] NEW_LINE bottom [ N - 1 ] [ i ] = mat [ N - 1 ] [ i ] NEW_LINE left [ i ] [ 0 ] = mat [ i ] [ 0 ] NEW_LINE right [ i ] [ N - 1 ] = mat [ i ] [ N - 1 ] NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( 1 , N ) : NEW_LINE INDENT if ( mat [ i ] [ j ] == 1 ) : NEW_LINE INDENT left [ i ] [ j ] = left [ i ] [ j - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT left [ i ] [ j ] = 0 NEW_LINE DEDENT if ( mat [ j ] [ i ] == 1 ) : NEW_LINE INDENT top [ j ] [ i ] = top [ j - 1 ] [ i ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT top [ j ] [ i ] = 0 NEW_LINE DEDENT j = N - 1 - j NEW_LINE if ( mat [ j ] [ i ] == 1 ) : NEW_LINE INDENT bottom [ j ] [ i ] = bottom [ j + 1 ] [ i ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT bottom [ j ] [ i ] = 0 NEW_LINE DEDENT if ( mat [ i ] [ j ] == 1 ) : NEW_LINE INDENT right [ i ] [ j ] = right [ i ] [ j + 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT right [ i ] [ j ] = 0 NEW_LINE DEDENT j = N - 1 - j NEW_LINE DEDENT DEDENT n = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT l = min ( min ( top [ i ] [ j ] , bottom [ i ] [ j ] ) , min ( left [ i ] [ j ] , right [ i ] [ j ] ) ) NEW_LINE if ( l > n ) : NEW_LINE INDENT n = l NEW_LINE DEDENT DEDENT DEDENT if ( n ) : NEW_LINE INDENT return 4 * ( n - 1 ) + 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT
Hyp: 
def findLargestPlus ( mat ) : NEW_LINE INDENT global N NEW_LINE left = [ [ 0 for i in range ( N ) ] for j in range ( N ) ] NEW_LINE right = [ [ 0 for i in range ( N ) ] for j in range ( N ) ] NEW_LINE top [ 0 ] [ i ] = mat [ 0 ] [ i ] NEW_LINE bottom [ N - 1 ] [ i ] = mat [ N - 1 ] [ i ] NEW_LINE left [ i ] [ 0 ] = mat [ i ] [ 0 ] NEW_LINE right [ i ] [ N - 1 ] = mat [ i ] [ N - 1 ] NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( 1 , N ) : NEW_LINE INDENT if ( mat [ i ] [ j ] == 1 ) : NEW_LINE INDENT left [ i ] [ j ] = left [ i ] [ j - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT top [ j ] [ i ] = 0 NEW_LINE DEDENT j = N - 1 - j NEW_LINE if ( mat [ j ] [ i ] == 1 ) : NEW_LINE INDENT bottom [ j ] [ i ] = bottom [ j + 1 ] [ i ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT bottom [ j ] [ i ] = 0 NEW_LINE DEDENT if ( mat [ i ] [ j ] == 1 ) : NEW_LINE INDENT right [ i ] [ j ] = right [ i ] [ j + 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT right [ i ] [ j ] = 0 NEW_LINE DEDENT j = N - 1 - j NEW_LINE DEDENT DEDENT n = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if ( n ) : NEW_LINE INDENT return 4 * ( n - 1 ) + 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT

BLEU: 62.12
Edit Sim: 513


Src: 
bool HalfDiagonalSums ( int mat [ ] [ MAX ] , int n ) { int diag1_left = 0 , diag1_right = 0 ; int diag2_left = 0 , diag2_right = 0 ; for ( int i = 0 , j = n - 1 ; i < n ; i ++ , j -- ) { if ( i < n / 2 ) { diag1_left += mat [ i ] [ i ] ; diag2_left += mat [ j ] [ i ] ; } else if ( i > n / 2 ) { diag1_right += mat [ i ] [ i ] ; diag2_right += mat [ j ] [ i ] ; } } return ( diag1_left == diag2_right && diag2_right == diag2_left && diag1_right == diag2_left && diag2_right == mat [ n / 2 ] [ n / 2 ] ) ; }
Ref: 
def HalfDiagonalSums ( mat , n ) : NEW_LINE INDENT diag1_left = 0 NEW_LINE diag1_right = 0 NEW_LINE diag2_left = 0 NEW_LINE diag2_right = 0 NEW_LINE i = 0 NEW_LINE j = n - 1 NEW_LINE while i < n : NEW_LINE INDENT if ( i < n // 2 ) : NEW_LINE INDENT diag1_left += mat [ i ] [ i ] NEW_LINE diag2_left += mat [ j ] [ i ] NEW_LINE DEDENT elif ( i > n // 2 ) : NEW_LINE INDENT diag1_right += mat [ i ] [ i ] NEW_LINE diag2_right += mat [ j ] [ i ] NEW_LINE DEDENT i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT return ( diag1_left == diag2_right and diag2_right == diag2_left and diag1_right == diag2_left and diag2_right == mat [ n // 2 ] [ n // 2 ] ) NEW_LINE DEDENT
Hyp: 
def HalfDiagonalSums ( mat , n ) : NEW_LINE INDENT diag1_left = 0 NEW_LINE diag1_right = 0 NEW_LINE diag2_left = 0 NEW_LINE diag2_right = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( i < n // 2 ) : NEW_LINE INDENT diag1_left += mat [ i ] [ i ] NEW_LINE diag2_left += mat [ j ] [ i ] NEW_LINE DEDENT elif ( i > n // 2 ) : NEW_LINE INDENT diag1_right += mat [ i ] [ i ] NEW_LINE diag2_right += mat [ j ] [ i ] NEW_LINE DEDENT DEDENT return ( diag1_left == diag2_right and diag2_right == diag2_left and diag1_right == diag2_left and diag2_right == mat [ n // 2 ] [ n // 2 ] ) NEW_LINE DEDENT

BLEU: 82.94
Edit Sim: 68


Src: 
int sumAtKthLevel ( string tree , int k ) { int level = - 1 ; int sum = 0 ; int n = tree . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( tree [ i ] == ' ( ' ) level ++ ; else if ( tree [ i ] == ' ) ' ) level -- ; else { if ( level == k ) sum += ( tree [ i ] - '0' ) ; } } return sum ; }
Ref: 
def sumAtKthLevel ( tree , k ) : NEW_LINE INDENT level = - 1 NEW_LINE sum = 0 NEW_LINE n = len ( tree ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( tree [ i ] == ' ( ' ) : NEW_LINE INDENT level += 1 NEW_LINE DEDENT elif ( tree [ i ] == ' ) ' ) : NEW_LINE INDENT level -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( level == k ) : NEW_LINE INDENT sum += ( ord ( tree [ i ] ) - ord ( '0' ) ) NEW_LINE DEDENT DEDENT DEDENT return sum NEW_LINE DEDENT
Hyp: 
def sumAtKthLevel ( tree , k ) : NEW_LINE INDENT level = - 1 NEW_LINE sum = 0 NEW_LINE n = len ( tree ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( tree [ i ] == ' ( ' ) : NEW_LINE INDENT level += 1 NEW_LINE DEDENT elif ( tree [ i ] == ' ) ' ) : NEW_LINE INDENT level -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( level == k ) : NEW_LINE INDENT sum += ( int ( tree [ i ] ) - int ( '0' ) ) NEW_LINE DEDENT DEDENT DEDENT return sum NEW_LINE DEDENT

BLEU: 92.36
Edit Sim: 10


Src: 
void LeibnizHarmonicTriangle ( int n ) { int C [ n + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= min ( i , n ) ; j ++ ) { if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) cout << "1 / " << i * C [ i - 1 ] [ j - 1 ] << " ▁ " ; cout << endl ; } }
Ref: 
def LeibnizHarmonicTriangle ( n ) : NEW_LINE INDENT C = [ [ 0 for x in range ( n + 1 ) ] for y in range ( n + 1 ) ] NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT for j in range ( 0 , min ( i , n ) + 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT print ( "1 / " , end = " " ) NEW_LINE print ( i * C [ i - 1 ] [ j - 1 ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT
Hyp: 
def LeibnizHarmonicTriangle ( n ) : NEW_LINE INDENT C = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT print ( "1 / " , i * C [ i - 1 ] [ j - 1 ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT

BLEU: 86.06
Edit Sim: 51


Src: 
int countWays ( string s ) { int count [ 26 ] = { 0 } ; for ( char x : s ) count [ x - ' a ' ] ++ ; count [ s [ 0 ] - ' a ' ] = 1 ; int ans = 1 ; for ( int i = 0 ; i < 26 ; ++ i ) if ( count [ i ] != 0 ) ans *= count [ i ] ; return ans ; }
Ref: 
def countWays ( s ) : NEW_LINE INDENT count = [ 0 ] * 26 NEW_LINE for x in s : NEW_LINE INDENT count [ ord ( x ) - ord ( ' a ' ) ] = ( count [ ord ( x ) - ord ( ' a ' ) ] ) + 1 NEW_LINE DEDENT count [ ord ( s [ 0 ] ) - ord ( ' a ' ) ] = 1 NEW_LINE ans = 1 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if ( count [ i ] != 0 ) : NEW_LINE INDENT ans *= count [ i ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
Hyp: 
def countWays ( s ) : NEW_LINE INDENT count = [ 0 for x in range ( 26 ) ] NEW_LINE for x in s : NEW_LINE INDENT count [ ord ( x ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT count [ ord ( s [ 0 ] ) - ord ( ' a ' ) ] = 1 NEW_LINE ans = 1 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if ( count [ i ] != 0 ) : NEW_LINE INDENT ans *= count [ i ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT

BLEU: 80.12
Edit Sim: 62


Src: 
int countWays ( int n , int m ) { int count [ n + 1 ] ; count [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i > m ) count [ i ] = count [ i - 1 ] + count [ i - m ] ; else if ( i < m ) count [ i ] = 1 ; else count [ i ] = 2 ; } return count [ n ] ; }
Ref: 
def countWays ( n , m ) : NEW_LINE INDENT count = [ ] NEW_LINE for i in range ( n + 2 ) : NEW_LINE INDENT count . append ( 0 ) NEW_LINE DEDENT count [ 0 ] = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( i > m ) : NEW_LINE INDENT count [ i ] = count [ i - 1 ] + count [ i - m ] NEW_LINE DEDENT elif ( i < m ) : NEW_LINE INDENT count [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT count [ i ] = 2 NEW_LINE DEDENT DEDENT return count [ n ] NEW_LINE DEDENT
Hyp: 
def countWays ( n , m ) : NEW_LINE INDENT count = [ 0 for _ in range ( n + 1 ) ] NEW_LINE count [ 0 ] = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if i > m : NEW_LINE INDENT count [ i ] = count [ i - 1 ] + count [ i - m ] NEW_LINE DEDENT elif i < m : NEW_LINE INDENT count [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT count [ i ] = 2 NEW_LINE DEDENT DEDENT return count [ n ] NEW_LINE DEDENT

BLEU: 75.59
Edit Sim: 65


Src: 
void printCommonElements ( int mat [ M ] [ N ] ) { unordered_map < int , int > mp ; for ( int j = 0 ; j < N ; j ++ ) mp [ mat [ 0 ] [ j ] ] = 1 ; for ( int i = 1 ; i < M ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( mp [ mat [ i ] [ j ] ] == i ) { mp [ mat [ i ] [ j ] ] = i + 1 ; if ( i == M - 1 ) cout << mat [ i ] [ j ] << " ▁ " ; } } } }
Ref: 
def printCommonElements ( mat ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for j in range ( N ) : NEW_LINE INDENT mp [ mat [ 0 ] [ j ] ] = 1 NEW_LINE DEDENT for i in range ( 1 , M ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if ( mat [ i ] [ j ] in mp . keys ( ) and mp [ mat [ i ] [ j ] ] == i ) : NEW_LINE INDENT mp [ mat [ i ] [ j ] ] = i + 1 NEW_LINE if i == M - 1 : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT
Hyp: 
def printCommonElements ( mat ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for j in range ( N ) : NEW_LINE INDENT mp [ mat [ 0 ] [ j ] ] = 1 NEW_LINE DEDENT for i in range ( 1 , M ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if ( mp [ mat [ i ] [ j ] ] == i ) : NEW_LINE INDENT mp [ mat [ i ] [ j ] ] = i + 1 NEW_LINE if ( i == M - 1 ) : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT DEDENT

BLEU: 85.7
Edit Sim: 48


Src: 
int floorSearch ( int arr [ ] , int n , int x ) { if ( x >= arr [ n - 1 ] ) return n - 1 ; if ( x < arr [ 0 ] ) return - 1 ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] > x ) return ( i - 1 ) ; return - 1 ; }
Ref: 
def floorSearch ( arr , low , high , x ) : NEW_LINE INDENT if ( low > high ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( x >= arr [ high ] ) : NEW_LINE INDENT return high NEW_LINE DEDENT mid = int ( ( low + high ) / 2 ) NEW_LINE if ( arr [ mid ] == x ) : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( mid > 0 and arr [ mid - 1 ] <= x and x < arr [ mid ] ) : NEW_LINE INDENT return mid - 1 NEW_LINE DEDENT if ( x < arr [ mid ] ) : NEW_LINE INDENT return floorSearch ( arr , low , mid - 1 , x ) NEW_LINE DEDENT return floorSearch ( arr , mid + 1 , high , x ) NEW_LINE DEDENT
Hyp: 
def floorSearch ( arr , n , x ) : NEW_LINE INDENT if ( x >= arr [ n - 1 ] ) : NEW_LINE INDENT return n - 1 NEW_LINE DEDENT if ( x < arr [ 0 ] ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] > x ) : NEW_LINE INDENT return ( i - 1 ) NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT

BLEU: 29.52
Edit Sim: 290


Src: 
unsigned int nextPowerOf2 ( unsigned int n ) { unsigned int p = 1 ; if ( n && ! ( n & ( n - 1 ) ) ) return n ; while ( p < n ) p <<= 1 ; return p ; }
Ref: 
def nextPowerOf2 ( n ) : NEW_LINE INDENT p = 1 NEW_LINE if ( n and not ( n & ( n - 1 ) ) ) : NEW_LINE INDENT return n NEW_LINE DEDENT while ( p < n ) : NEW_LINE INDENT p <<= 1 NEW_LINE DEDENT return p NEW_LINE DEDENT
Hyp: 
def nextPowerOf2 ( n ) : NEW_LINE INDENT p = 1 NEW_LINE if ( n and not ( n & ( n - 1 ) ) ) : NEW_LINE INDENT return n NEW_LINE DEDENT while ( p < n ) : NEW_LINE INDENT p <<= 1 NEW_LINE DEDENT return p NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
void printkthnode ( vector < pair < int , int > > adj [ ] , int wt [ ] , int n , int k ) { for ( int i = 0 ; i < n ; i ++ ) sort ( adj [ i ] . begin ( ) , adj [ i ] . end ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( adj [ i ] . size ( ) >= k ) cout << adj [ i ] [ adj [ i ] . size ( ) - k ] . second ; else cout << " - 1" ; } }
Ref: 
def printkthnode ( adj , wt , n , k ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT adj [ i ] . sort ( ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( len ( adj [ i ] ) >= k ) : NEW_LINE INDENT print ( adj [ i ] [ len ( adj [ i ] ) - k ] [ 1 ] , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " - 1" , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
Hyp: 
def printkthnode ( adj , wt , n , k ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( len ( adj ) >= k ) : NEW_LINE INDENT print ( adj [ i ] [ len ( adj ) - k ] , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " - 1" , end = " " ) NEW_LINE DEDENT DEDENT DEDENT

BLEU: 59.87
Edit Sim: 96


Src: 
void longest ( int a [ ] , int n , int k ) { unordered_map < int , int > freq ; int start = 0 , end = 0 , now = 0 , l = 0 ; for ( int i = 0 ; i < n ; i ++ ) { freq [ a [ i ] ] ++ ; if ( freq [ a [ i ] ] == 1 ) now ++ ; while ( now > k ) { freq [ a [ l ] ] -- ; if ( freq [ a [ l ] ] == 0 ) now -- ; l ++ ; } if ( i - l + 1 >= end - start + 1 ) end = i , start = l ; } for ( int i = start ; i <= end ; i ++ ) cout << a [ i ] << " ▁ " ; }
Ref: 
def longest ( a , n , k ) : NEW_LINE INDENT freq = [ 0 ] * n NEW_LINE start = 0 NEW_LINE end = 0 NEW_LINE now = 0 NEW_LINE l = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ a [ i ] ] += 1 NEW_LINE if ( freq [ a [ i ] ] == 1 ) : NEW_LINE INDENT now += 1 NEW_LINE DEDENT while ( now > k ) : NEW_LINE INDENT freq [ a [ l ] ] -= 1 NEW_LINE if ( freq [ a [ l ] ] == 0 ) : NEW_LINE INDENT now -= 1 NEW_LINE DEDENT l += 1 NEW_LINE DEDENT if ( i - l + 1 >= end - start + 1 ) : NEW_LINE INDENT end = i NEW_LINE start = l NEW_LINE DEDENT DEDENT for i in range ( start , end + 1 ) : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
Hyp: 
def longest ( a , n , k ) : NEW_LINE INDENT freq = dict ( ) NEW_LINE start = 0 NEW_LINE end = 0 NEW_LINE now = 0 NEW_LINE l = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ a [ i ] ] = freq . get ( a [ i ] , 0 ) + 1 NEW_LINE if freq [ a [ i ] ] == 1 : NEW_LINE INDENT now += 1 NEW_LINE DEDENT while now > k : NEW_LINE INDENT freq [ a [ l ] ] -= 1 NEW_LINE if freq [ a [ l ] ] == 0 : NEW_LINE INDENT now -= 1 NEW_LINE DEDENT l += 1 NEW_LINE DEDENT if i - l + 1 >= end - start + 1 : NEW_LINE INDENT end = i , start = l NEW_LINE DEDENT DEDENT for i in range ( start , end + 1 ) : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT

BLEU: 81.87
Edit Sim: 61


Src: 
int minimumflip ( int mat [ ] [ N ] , int n ) { int flip = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) flip ++ ; return flip ; }
Ref: 
def minimumflip ( mat , n ) : NEW_LINE INDENT flip = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if mat [ i ] [ j ] != mat [ j ] [ i ] : NEW_LINE INDENT flip += 1 NEW_LINE DEDENT DEDENT DEDENT return flip NEW_LINE DEDENT
Hyp: 
def minimumflip ( mat , n ) : NEW_LINE INDENT flip = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) : NEW_LINE INDENT flip += 1 NEW_LINE DEDENT DEDENT DEDENT return flip NEW_LINE DEDENT

BLEU: 92.24
Edit Sim: 4


Src: 
int breakSum ( int n ) { if ( n == 0 || n == 1 ) return n ; return max ( ( breakSum ( n / 2 ) + breakSum ( n / 3 ) + breakSum ( n / 4 ) ) , n ) ; }
Ref: 
def breakSum ( n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT return max ( ( breakSum ( n // 2 ) + breakSum ( n // 3 ) + breakSum ( n // 4 ) ) , n ) NEW_LINE DEDENT
Hyp: 
def breakSum ( n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT return max ( ( breakSum ( n // 2 ) + breakSum ( n // 3 ) + breakSum ( n // 4 ) ) , n ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int countPairs ( int arr1 [ ] , int arr2 [ ] , int m , int n , int x ) { int count = 0 ; for ( int i = 0 ; i < m ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( ( arr1 [ i ] + arr2 [ j ] ) == x ) count ++ ; return count ; }
Ref: 
def countPairs ( arr1 , arr2 , m , n , x ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if arr1 [ i ] + arr2 [ j ] == x : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
Hyp: 
def countPairs ( arr1 , arr2 , m , n , x ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , m ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT if ( ( arr1 [ i ] + arr2 [ j ] ) == x ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT

BLEU: 75.17
Edit Sim: 25


Src: 
void alternateSubarray ( bool arr [ ] , int n ) { int len [ n ] ; len [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; -- i ) { if ( arr [ i ] ^ arr [ i + 1 ] == 1 ) len [ i ] = len [ i + 1 ] + 1 ; else len [ i ] = 1 ; } for ( int i = 0 ; i < n ; ++ i ) cout << len [ i ] << " ▁ " ; }
Ref: 
def alternateSubarray ( arr , n ) : NEW_LINE INDENT len = [ ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT len . append ( 0 ) NEW_LINE DEDENT len [ n - 1 ] = 1 NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] ^ arr [ i + 1 ] == True ) : NEW_LINE INDENT len [ i ] = len [ i + 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT len [ i ] = 1 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( len [ i ] , " ▁ " , end = " " ) NEW_LINE DEDENT DEDENT
Hyp: 
def alternateSubarray ( arr , n ) : NEW_LINE INDENT len = [ 0 ] * n NEW_LINE len [ n - 1 ] = 1 NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] ^ arr [ i + 1 ] == 1 ) : NEW_LINE INDENT len [ i ] = len [ i + 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT len [ i ] = 1 NEW_LINE DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( len [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT

BLEU: 75.02
Edit Sim: 95


Src: 
void subsequence ( char s [ ] , char t [ ] , int n , int k ) { int last = 0 , cnt = 0 , new_last = 0 , size = 0 ; for ( char ch = ' z ' ; ch >= ' a ' ; ch -- ) { cnt = 0 ; for ( int i = last ; i < n ; i ++ ) { if ( s [ i ] == ch ) cnt ++ ; } if ( cnt >= k ) { for ( int i = last ; i < n ; i ++ ) { if ( s [ i ] == ch ) { t [ size ++ ] = ch ; new_last = i ; } } last = new_last ; } } t [ size ] = ' \0' ; }
Ref: 
def subsequence ( s , t , n , k ) : NEW_LINE INDENT last = 0 NEW_LINE cnt = 0 NEW_LINE new_last = 0 NEW_LINE size = 0 NEW_LINE string = ' zyxwvutsrqponmlkjihgfedcba ' NEW_LINE for ch in string : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( last , n ) : NEW_LINE INDENT if s [ i ] == ch : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT if cnt >= k : NEW_LINE INDENT for i in range ( last , n ) : NEW_LINE INDENT if s [ i ] == ch : NEW_LINE INDENT t [ size ] = ch NEW_LINE new_last = i NEW_LINE size += 1 NEW_LINE DEDENT DEDENT last = new_last NEW_LINE DEDENT DEDENT DEDENT
Hyp: 
def subsequence ( s , t , n , k ) : NEW_LINE INDENT last = 0 NEW_LINE cnt = 0 NEW_LINE new_last = 0 NEW_LINE size = 0 NEW_LINE for ch in range ( ord ( ' z ' ) , ord ( ' a ' ) , - 1 ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( last , n ) : NEW_LINE INDENT if ( s [ i ] == ch ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT if ( cnt >= k ) : NEW_LINE INDENT for i in range ( last , n ) : NEW_LINE INDENT if ( s [ i ] == ch ) : NEW_LINE INDENT t [ size ] = ch NEW_LINE new_last = i NEW_LINE DEDENT DEDENT last = new_last NEW_LINE DEDENT DEDENT t [ size ] = ' ' NEW_LINE DEDENT

BLEU: 70.2
Edit Sim: 112


Src: 
int maxLen ( int arr [ ] , int n ) { int max_len = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int curr_sum = 0 ; for ( int j = i ; j < n ; j ++ ) { curr_sum += arr [ j ] ; if ( curr_sum == 0 ) max_len = max ( max_len , j - i + 1 ) ; } } return max_len ; }
Ref: 
def maxLen ( arr ) : NEW_LINE INDENT max_len = 0 NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT curr_sum = 0 NEW_LINE for j in range ( i , len ( arr ) ) : NEW_LINE INDENT curr_sum += arr [ j ] NEW_LINE if curr_sum == 0 : NEW_LINE INDENT max_len = max ( max_len , j - i + 1 ) NEW_LINE DEDENT DEDENT DEDENT return max_len NEW_LINE DEDENT
Hyp: 
def maxLen ( arr , n ) : NEW_LINE INDENT max_len = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT curr_sum = 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT curr_sum += arr [ j ] NEW_LINE if curr_sum == 0 : NEW_LINE INDENT max_len = max ( max_len , j - i + 1 ) NEW_LINE DEDENT DEDENT DEDENT return max_len NEW_LINE DEDENT

BLEU: 83.59
Edit Sim: 24


Src: 
int findWays ( int m , int n , int x ) { int table [ n + 1 ] [ x + 1 ] ; memset ( table , 0 , sizeof ( table ) ) ; for ( int j = 1 ; j <= m && j <= x ; j ++ ) table [ 1 ] [ j ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) for ( int j = 1 ; j <= x ; j ++ ) for ( int k = 1 ; k <= m && k < j ; k ++ ) table [ i ] [ j ] += table [ i - 1 ] [ j - k ] ; return table [ n ] [ x ] ; }
Ref: 
def findWays ( m , n , x ) : NEW_LINE INDENT table = [ [ 0 ] * ( x + 1 ) for i in range ( n + 1 ) ] NEW_LINE for j in range ( 1 , min ( m + 1 , x + 1 ) ) : NEW_LINE INDENT table [ 1 ] [ j ] = 1 NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , x + 1 ) : NEW_LINE INDENT for k in range ( 1 , min ( m + 1 , j ) ) : NEW_LINE INDENT table [ i ] [ j ] += table [ i - 1 ] [ j - k ] NEW_LINE DEDENT DEDENT DEDENT return table [ - 1 ] [ - 1 ] NEW_LINE DEDENT
Hyp: 
def findWays ( m , n , x ) : NEW_LINE INDENT table = [ [ 0 for i in range ( x + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for j in range ( 1 , m + 1 ) : NEW_LINE INDENT table [ 1 ] [ j ] = 1 NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , x + 1 ) : NEW_LINE INDENT for k in range ( 1 , m + 1 ) : NEW_LINE INDENT table [ i ] [ j ] += table [ i - 1 ] [ j - k ] NEW_LINE DEDENT DEDENT DEDENT return table [ n ] [ x ] NEW_LINE DEDENT

BLEU: 80.27
Edit Sim: 50


Src: 
bool checkCorrectOrNot ( string s ) { int count [ MAX_CHAR ] = { 0 } ; int n = s . length ( ) ; if ( n == 1 ) return true ; for ( int i = 0 , j = n - 1 ; i < j ; i ++ , j -- ) { count [ s [ i ] - ' a ' ] ++ ; count [ s [ j ] - ' a ' ] -- ; } for ( int i = 0 ; i < MAX_CHAR ; i ++ ) if ( count [ i ] != 0 ) return false ; return true ; }
Ref: 
def checkCorrectOrNot ( s ) : NEW_LINE INDENT global MAX_CHAR NEW_LINE count = [ 0 ] * MAX_CHAR NEW_LINE n = len ( s ) NEW_LINE if n == 1 : NEW_LINE INDENT return true NEW_LINE DEDENT i = 0 j = n - 1 NEW_LINE while i < j : NEW_LINE INDENT count [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE count [ ord ( s [ j ] ) - ord ( ' a ' ) ] -= 1 NEW_LINE i += 1 j -= 1 NEW_LINE DEDENT for i in range ( MAX_CHAR ) : NEW_LINE INDENT if count [ i ] != 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
Hyp: 
def checkCorrectOrNot ( s ) : NEW_LINE INDENT count = [ 0 ] * MAX_CHAR NEW_LINE n = len ( s ) NEW_LINE if ( n == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT for i in range ( 0 , n , 1 ) : NEW_LINE INDENT count [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE count [ ord ( s [ j ] ) - ord ( ' a ' ) ] -= 1 NEW_LINE DEDENT for i in range ( 0 , MAX_CHAR ) : NEW_LINE INDENT if ( count [ i ] != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT

BLEU: 72.6
Edit Sim: 88


Src: 
int findNumberOfTriangles ( int arr [ ] , int n ) { qsort ( arr , n , sizeof ( arr [ 0 ] ) , comp ) ; int count = 0 ; for ( int i = 0 ; i < n - 2 ; ++ i ) { int k = i + 2 ; for ( int j = i + 1 ; j < n ; ++ j ) { while ( k < n && arr [ i ] + arr [ j ] > arr [ k ] ) ++ k ; if ( k > j ) count += k - j - 1 ; } } return count ; }
Ref: 
def findnumberofTriangles ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE arr . sort ( ) NEW_LINE count = 0 NEW_LINE for i in range ( 0 , n - 2 ) : NEW_LINE INDENT k = i + 2 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT while ( k < n and arr [ i ] + arr [ j ] > arr [ k ] ) : NEW_LINE INDENT k += 1 NEW_LINE DEDENT if ( k > j ) : NEW_LINE INDENT count += k - j - 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
Hyp: 
def findNumberOfTriangles ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE count = 0 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT k = i + 2 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT while ( k < n and arr [ i ] + arr [ j ] > arr [ k ] ) : NEW_LINE INDENT k = k + 1 NEW_LINE DEDENT if ( k > j ) : NEW_LINE INDENT count += k - j - 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT

BLEU: 85.45
Edit Sim: 37


Src: 
int countWays ( int n ) { int A [ n + 1 ] , B [ n + 1 ] ; A [ 0 ] = 1 , A [ 1 ] = 0 , B [ 0 ] = 0 , B [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { A [ i ] = A [ i - 2 ] + 2 * B [ i - 1 ] ; B [ i ] = A [ i - 1 ] + B [ i - 2 ] ; } return A [ n ] ; }
Ref: 
def countWays ( n ) : NEW_LINE INDENT A = [ 0 ] * ( n + 1 ) NEW_LINE B = [ 0 ] * ( n + 1 ) NEW_LINE A [ 0 ] = 1 NEW_LINE A [ 1 ] = 0 NEW_LINE B [ 0 ] = 0 NEW_LINE B [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT A [ i ] = A [ i - 2 ] + 2 * B [ i - 1 ] NEW_LINE B [ i ] = A [ i - 1 ] + B [ i - 2 ] NEW_LINE DEDENT return A [ n ] NEW_LINE DEDENT
Hyp: 
def countWays ( n ) : NEW_LINE INDENT A = [ 0 ] * ( n + 1 ) NEW_LINE B = [ 0 ] * ( n + 1 ) NEW_LINE A [ 0 ] = 1 NEW_LINE A [ 1 ] = 0 NEW_LINE B [ 0 ] = 0 NEW_LINE B [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT A [ i ] = A [ i - 2 ] + 2 * B [ i - 1 ] NEW_LINE B [ i ] = A [ i - 1 ] + B [ i - 2 ] NEW_LINE DEDENT return A [ n ] NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int lcs ( char * X , char * Y , int m , int n ) { if ( m == 0 || n == 0 ) return 0 ; if ( X [ m - 1 ] == Y [ n - 1 ] ) return 1 + lcs ( X , Y , m - 1 , n - 1 ) ; else return max ( lcs ( X , Y , m , n - 1 ) , lcs ( X , Y , m - 1 , n ) ) ; }
Ref: 
def lcs ( X , Y , m , n ) : NEW_LINE INDENT if m == 0 or n == 0 : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT elif X [ m - 1 ] == Y [ n - 1 ] : NEW_LINE INDENT return 1 + lcs ( X , Y , m - 1 , n - 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT return max ( lcs ( X , Y , m , n - 1 ) , lcs ( X , Y , m - 1 , n ) ) ; NEW_LINE DEDENT DEDENT
Hyp: 
def lcs ( X , Y , m , n ) : NEW_LINE INDENT if ( m == 0 or n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( X [ m - 1 ] == Y [ n - 1 ] ) : NEW_LINE INDENT return 1 + lcs ( X , Y , m - 1 , n - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return max ( lcs ( X , Y , m , n - 1 ) , lcs ( X , Y , m - 1 , n ) ) NEW_LINE DEDENT DEDENT

BLEU: 85.01
Edit Sim: 16


Src: 
int minValue ( int A [ ] , int B [ ] , int n ) { sort ( A , A + n ) ; sort ( B , B + n ) ; int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) result += ( A [ i ] * B [ n - i - 1 ] ) ; return result ; }
Ref: 
def minValue ( A , B , n ) : NEW_LINE INDENT sorted ( A ) NEW_LINE sorted ( B ) NEW_LINE result = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT result += ( A [ i ] * B [ n - i - 1 ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT
Hyp: 
def minValue ( A , B , n ) : NEW_LINE INDENT A . sort ( reverse = False ) NEW_LINE B . sort ( reverse = False ) NEW_LINE result = 0 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT result += ( A [ i ] * B [ n - i - 1 ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT

BLEU: 68.29
Edit Sim: 46


Src: 
bool isOneFlip ( string str ) { int sum = 0 ; int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) sum += str [ i ] - '0' ; return ( sum == n - 1 || sum == 1 ) ; }
Ref: 
def isOneFlip ( str ) : NEW_LINE INDENT sum = 0 NEW_LINE n = len ( str ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum += int ( str [ i ] ) - int ( '0' ) NEW_LINE DEDENT return ( sum == n - 1 or sum == 1 ) NEW_LINE DEDENT
Hyp: 
def isOneFlip ( str ) : NEW_LINE INDENT sum = 0 NEW_LINE n = len ( str ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum = sum + int ( str [ i ] ) NEW_LINE DEDENT return ( sum == n - 1 or sum == 1 ) NEW_LINE DEDENT

BLEU: 86.16
Edit Sim: 21


Src: 
int MatrixChainOrder ( int p [ ] , int i , int j ) { if ( i == j ) return 0 ; int k ; int min = INT_MAX ; int count ; for ( k = i ; k < j ; k ++ ) { count = MatrixChainOrder ( p , i , k ) + MatrixChainOrder ( p , k + 1 , j ) + p [ i - 1 ] * p [ k ] * p [ j ] ; if ( count < min ) min = count ; } return min ; }
Ref: 
def MatrixChainOrder ( p , i , j ) : NEW_LINE INDENT if i == j : NEW_LINE INDENT return 0 NEW_LINE DEDENT _min = sys . maxsize NEW_LINE for k in range ( i , j ) : NEW_LINE INDENT count = ( MatrixChainOrder ( p , i , k ) + MatrixChainOrder ( p , k + 1 , j ) + p [ i - 1 ] * p [ k ] * p [ j ] ) NEW_LINE if count < _min : NEW_LINE INDENT _min = count NEW_LINE DEDENT DEDENT return _min NEW_LINE DEDENT
Hyp: 
def MatrixChainOrder ( p , i , j ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT min = sys . maxsize NEW_LINE for k in range ( i , j ) : NEW_LINE INDENT count = ( MatrixChainOrder ( p , i , k ) + MatrixChainOrder ( p , k + 1 , j ) + p [ i - 1 ] * p [ k ] * p [ j ] ) NEW_LINE if ( count < min ) : NEW_LINE INDENT min = count NEW_LINE DEDENT DEDENT return min NEW_LINE DEDENT

BLEU: 82.05
Edit Sim: 12


Src: 
public : int multiply ( int x , int y ) { if ( y == 0 ) return 0 ; if ( y > 0 ) return ( x + multiply ( x , y - 1 ) ) ; if ( y < 0 ) return - multiply ( x , - y ) ; }
Ref: 
def multiply ( x , y ) : NEW_LINE INDENT if ( y == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( y > 0 ) : NEW_LINE INDENT return ( x + multiply ( x , y - 1 ) ) NEW_LINE DEDENT if ( y < 0 ) : NEW_LINE INDENT return - multiply ( x , - y ) NEW_LINE DEDENT DEDENT
Hyp: 
def multiply ( x , y ) : NEW_LINE INDENT if ( y == 0 ) : return 0 NEW_LINE if ( y > 0 ) : NEW_LINE INDENT return ( x + multiply ( x , y - 1 ) ) NEW_LINE DEDENT if ( y < 0 ) : NEW_LINE INDENT return - multiply ( x , - y ) NEW_LINE DEDENT DEDENT

BLEU: 90.93
Edit Sim: 23


Src: 
int countP ( int n , int k ) { int dp [ n + 1 ] [ k + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = 0 ; for ( int i = 0 ; i <= k ; i ++ ) dp [ 0 ] [ k ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= i ; j ++ ) if ( j == 1 || i == j ) dp [ i ] [ j ] = 1 ; else dp [ i ] [ j ] = j * dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] ; return dp [ n ] [ k ] ; }
Ref: 
def countP ( n , k ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( k + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = 0 NEW_LINE DEDENT for i in range ( k + 1 ) : NEW_LINE INDENT dp [ 0 ] [ k ] = 0 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , k + 1 ) : NEW_LINE INDENT if ( j == 1 or i == j ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = ( j * dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ n ] [ k ] NEW_LINE DEDENT
Hyp: 
def countP ( n , k ) : NEW_LINE INDENT if ( k == 0 or n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( countP ( n - 1 , k ) + countP ( n , k - 1 ) ) NEW_LINE DEDENT

BLEU: 2.82
Edit Sim: 453


Src: 
void worstFit ( int blockSize [ ] , int m , int processSize [ ] , int n ) { int allocation [ n ] ; memset ( allocation , - 1 , sizeof ( allocation ) ) ; for ( int i = 0 ; i < n ; i ++ ) { int wstIdx = - 1 ; for ( int j = 0 ; j < m ; j ++ ) { if ( blockSize [ j ] >= processSize [ i ] ) { if ( wstIdx == - 1 ) wstIdx = j ; else if ( blockSize [ wstIdx ] < blockSize [ j ] ) wstIdx = j ; } } if ( wstIdx != - 1 ) { allocation [ i ] = wstIdx ; blockSize [ wstIdx ] -= processSize [ i ] ; } } cout << " \n Process ▁ No . \tProcess ▁ Size\tBlock ▁ no . \n " ; for ( int i = 0 ; i < n ; i ++ ) { cout << " ▁ ▁ ▁ " << i + 1 << " \t\t " << processSize [ i ] << " \t\t " ; if ( allocation [ i ] != - 1 ) cout << allocation [ i ] + 1 ; else cout << " Not ▁ Allocated " ; cout << endl ; } }
Ref: 
def worstFit ( blockSize , m , processSize , n ) : NEW_LINE INDENT allocation = [ - 1 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT wstIdx = - 1 NEW_LINE for j in range ( m ) : NEW_LINE INDENT if blockSize [ j ] >= processSize [ i ] : NEW_LINE INDENT if wstIdx == - 1 : NEW_LINE INDENT wstIdx = j NEW_LINE DEDENT elif blockSize [ wstIdx ] < blockSize [ j ] : NEW_LINE INDENT wstIdx = j NEW_LINE DEDENT DEDENT DEDENT if wstIdx != - 1 : NEW_LINE INDENT allocation [ i ] = wstIdx NEW_LINE blockSize [ wstIdx ] -= processSize [ i ] NEW_LINE DEDENT DEDENT print ( " Process ▁ No . ▁ Process ▁ Size ▁ Block ▁ no . " ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( i + 1 , " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " , processSize [ i ] , end = " ▁ ▁ ▁ ▁ ▁ " ) NEW_LINE if allocation [ i ] != - 1 : NEW_LINE INDENT print ( allocation [ i ] + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ Allocated " ) NEW_LINE DEDENT DEDENT DEDENT
Hyp: 
def worstfit ( blockSize , m , processSize , n ) : NEW_LINE INDENT allocation = [ - 1 ] * n NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT wstIdx = - 1 NEW_LINE for j in range ( 0 , m ) : NEW_LINE INDENT if ( blockSize [ j ] >= processSize [ i ] ) : NEW_LINE INDENT if ( wstIdx == - 1 ) : NEW_LINE INDENT wstIdx = j NEW_LINE DEDENT elif ( blockSize [ wstIdx ] < blockSize [ j ] ) : NEW_LINE INDENT wstIdx = j NEW_LINE DEDENT DEDENT DEDENT if ( wstIdx != - 1 ) : NEW_LINE INDENT allocation [ i ] = wstIdx NEW_LINE blockSize [ wstIdx ] -= processSize [ i ] NEW_LINE DEDENT DEDENT print ( " Process ▁ No . \tProcess ▁ Size\tBlock ▁ no . " ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( " ▁ " , i + 1 , " \t\t " , processSize [ i ] , " \t\t " , allocation [ i ] + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ Allocated " ) NEW_LINE DEDENT DEDENT

BLEU: 71.28
Edit Sim: 136


Src: 
int maxvolume ( int s ) { int length = s / 3 ; s -= length ; int breadth = s / 2 ; int height = s - breadth ; return length * breadth * height ; }
Ref: 
def maxvolume ( s ) : NEW_LINE INDENT length = int ( s / 3 ) NEW_LINE s -= length NEW_LINE breadth = s / 2 NEW_LINE height = s - breadth NEW_LINE return int ( length * breadth * height ) NEW_LINE DEDENT
Hyp: 
def maxvolume ( s ) : NEW_LINE INDENT length = int ( s / 3 ) NEW_LINE s -= length NEW_LINE breadth = int ( s / 2 ) NEW_LINE height = s - breadth NEW_LINE return length * breadth * height NEW_LINE DEDENT

BLEU: 81.43
Edit Sim: 16


Src: 
int findLength ( char * str ) { int n = strlen ( str ) ; int maxlen = 0 ; int sum [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) sum [ i ] [ i ] = str [ i ] - '0' ; for ( int len = 2 ; len <= n ; len ++ ) { for ( int i = 0 ; i < n - len + 1 ; i ++ ) { int j = i + len - 1 ; int k = len / 2 ; sum [ i ] [ j ] = sum [ i ] [ j - k ] + sum [ j - k + 1 ] [ j ] ; if ( len % 2 == 0 && sum [ i ] [ j - k ] == sum [ ( j - k + 1 ) ] [ j ] && len > maxlen ) maxlen = len ; } } return maxlen ; }
Ref: 
def findLength ( string ) : NEW_LINE INDENT n = len ( string ) NEW_LINE maxlen = 0 NEW_LINE Sum = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT Sum [ i ] [ i ] = int ( string [ i ] ) NEW_LINE DEDENT for length in range ( 2 , n + 1 ) : NEW_LINE INDENT for i in range ( 0 , n - length + 1 ) : NEW_LINE INDENT j = i + length - 1 NEW_LINE k = length // 2 NEW_LINE Sum [ i ] [ j ] = ( Sum [ i ] [ j - k ] + Sum [ j - k + 1 ] [ j ] ) NEW_LINE if ( length % 2 == 0 and Sum [ i ] [ j - k ] == Sum [ ( j - k + 1 ) ] [ j ] and length > maxlen ) : NEW_LINE INDENT maxlen = length NEW_LINE DEDENT DEDENT DEDENT return maxlen NEW_LINE DEDENT
Hyp: 
def findLength ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE maxlen = 0 NEW_LINE sum = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum [ i ] [ i ] = ord ( str [ i ] ) - ord ( '0' ) NEW_LINE DEDENT for l in range ( 2 , n + 1 ) : NEW_LINE INDENT for i in range ( n - len + 1 ) : NEW_LINE INDENT j = i + len - 1 NEW_LINE k = len // 2 NEW_LINE sum [ i ] [ j ] = sum [ i ] [ j - k ] + sum [ j - k + 1 ] [ j ] NEW_LINE if ( len % 2 == 0 and sum [ i ] [ j - k ] == sum [ ( j - k + 1 ) ] [ j ] and len > maxlen ) : NEW_LINE INDENT maxlen = len NEW_LINE DEDENT DEDENT DEDENT return maxlen NEW_LINE DEDENT

BLEU: 68.03
Edit Sim: 69


Src: 
int subArraySum ( int arr [ ] , int n , int sum ) { int curr_sum = arr [ 0 ] , start = 0 , i ; for ( i = 1 ; i <= n ; i ++ ) { while ( curr_sum > sum && start < i - 1 ) { curr_sum = curr_sum - arr [ start ] ; start ++ ; } if ( curr_sum == sum ) { cout << " Sum ▁ found ▁ between ▁ indexes ▁ " << start << " ▁ and ▁ " << i - 1 ; return 1 ; } if ( i < n ) curr_sum = curr_sum + arr [ i ] ; } cout << " No ▁ subarray ▁ found " ; return 0 ; }
Ref: 
def subArraySum ( arr , n , sum ) : NEW_LINE INDENT curr_sum = arr [ 0 ] NEW_LINE start = 0 NEW_LINE i = 1 NEW_LINE while i <= n : NEW_LINE INDENT while curr_sum > sum and start < i - 1 : NEW_LINE INDENT curr_sum = curr_sum - arr [ start ] NEW_LINE start += 1 NEW_LINE DEDENT if curr_sum == sum : NEW_LINE INDENT print ( " Sum ▁ found ▁ between ▁ indexes " ) NEW_LINE print ( " % d ▁ and ▁ % d " % ( start , i - 1 ) ) NEW_LINE return 1 NEW_LINE DEDENT if i < n : NEW_LINE INDENT curr_sum = curr_sum + arr [ i ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print ( " No ▁ subarray ▁ found " ) NEW_LINE return 0 NEW_LINE DEDENT
Hyp: 
def subArraySum ( arr , n , Sum ) : NEW_LINE INDENT curr_sum = arr [ 0 ] NEW_LINE start = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT while ( curr_sum > Sum and start < i - 1 ) : NEW_LINE INDENT curr_sum = curr_sum - arr [ start ] NEW_LINE start += 1 NEW_LINE DEDENT if ( curr_sum == Sum ) : NEW_LINE INDENT print ( " Sum ▁ found ▁ between ▁ indexes ▁ " , start , " and ▁ " , i - 1 ) NEW_LINE return 1 NEW_LINE DEDENT if ( i < n ) : NEW_LINE INDENT curr_sum = curr_sum + arr [ i ] NEW_LINE DEDENT DEDENT print ( " No ▁ subarray ▁ found " ) NEW_LINE return 0 NEW_LINE DEDENT

BLEU: 66.78
Edit Sim: 90


Src: 
void commonCharacters ( string str [ ] , int n ) { bool prim [ MAX_CHAR ] ; memset ( prim , true , sizeof ( prim ) ) ; for ( int i = 0 ; i < n ; i ++ ) { bool sec [ MAX_CHAR ] = { false } ; for ( int j = 0 ; str [ i ] [ j ] ; j ++ ) { if ( prim [ str [ i ] [ j ] - ' a ' ] ) sec [ str [ i ] [ j ] - ' a ' ] = true ; } memcpy ( prim , sec , MAX_CHAR ) ; } for ( int i = 0 ; i < 26 ; i ++ ) if ( prim [ i ] ) printf ( " % c ▁ " , i + ' a ' ) ; }
Ref: 
def commonCharacters ( strings , n ) : NEW_LINE INDENT prim = [ True ] * MAX_CHAR NEW_LINE for i in range ( n ) : NEW_LINE INDENT sec = [ False ] * MAX_CHAR NEW_LINE for j in range ( len ( strings [ i ] ) ) : NEW_LINE INDENT if ( prim [ ord ( strings [ i ] [ j ] ) - ord ( ' a ' ) ] ) : NEW_LINE INDENT sec [ ord ( strings [ i ] [ j ] ) - ord ( ' a ' ) ] = True NEW_LINE DEDENT DEDENT for i in range ( MAX_CHAR ) : NEW_LINE INDENT prim [ i ] = sec [ i ] NEW_LINE DEDENT DEDENT for i in range ( 26 ) : NEW_LINE INDENT if ( prim [ i ] ) : NEW_LINE INDENT print ( " % c ▁ " % ( i + ord ( ' a ' ) ) , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
Hyp: 
def commonCharacters ( Str , n ) : NEW_LINE INDENT prim = [ False for i in range ( MAX_CHAR ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT sec = [ False for i in range ( MAX_CHAR ) ] NEW_LINE for j in range ( len ( Str [ i ] ) ) : NEW_LINE INDENT if ( prim [ ord ( Str [ i ] [ j ] ) - ord ( ' a ' ) ] == 0 ) : NEW_LINE INDENT sec [ ord ( Str [ i ] [ j ] ) - ord ( ' a ' ) ] = True NEW_LINE DEDENT DEDENT DEDENT for i in range ( 26 ) : NEW_LINE INDENT if ( prim [ i ] ) : NEW_LINE INDENT print ( " % c ▁ " , i + ord ( ' a ' ) ) NEW_LINE DEDENT DEDENT DEDENT

BLEU: 72.47
Edit Sim: 169


Src: 
bool canMakeStr2 ( string str1 , string str2 ) { int count [ MAX ] = { 0 } ; for ( int i = 0 ; i < str1 . length ( ) ; i ++ ) count [ str1 [ i ] ] ++ ; for ( int i = 0 ; i < str2 . length ( ) ; i ++ ) { if ( count [ str2 [ i ] ] == 0 ) return false ; count [ str2 [ i ] ] -- ; } return true ; }
Ref: 
def canMakeStr2 ( s1 , s2 ) : NEW_LINE INDENT count = { s1 [ i ] : 0 for i in range ( len ( s1 ) ) } NEW_LINE for i in range ( len ( s1 ) ) : NEW_LINE INDENT count [ s1 [ i ] ] += 1 NEW_LINE DEDENT for i in range ( len ( s2 ) ) : NEW_LINE INDENT if count [ s2 [ i ] ] == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT count [ s2 [ i ] ] -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT
Hyp: 
def canMakeStr2 ( str1 , str2 ) : NEW_LINE INDENT count = [ 0 for i in range ( 0 , MAX ) ] NEW_LINE for i in range ( len ( str1 ) ) : NEW_LINE INDENT count [ ord ( str1 [ i ] ) ] = count [ ord ( str1 [ i ] ) ] + 1 NEW_LINE DEDENT for i in range ( len ( str2 ) ) : NEW_LINE INDENT if ( count [ ord ( str2 [ i ] ) ] == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT count [ ord ( str2 [ i ] ) ] -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT

BLEU: 50.44
Edit Sim: 94


Src: 
void generateSquare ( int n ) { int magicSquare [ n ] [ n ] ; memset ( magicSquare , 0 , sizeof ( magicSquare ) ) ; int i = n / 2 ; int j = n - 1 ; for ( int num = 1 ; num <= n * n ; ) { if ( i == - 1 && j == n ) { j = n - 2 ; i = 0 ; } else { if ( j == n ) j = 0 ; if ( i < 0 ) i = n - 1 ; } if ( magicSquare [ i ] [ j ] ) { j -= 2 ; i ++ ; continue ; } else magicSquare [ i ] [ j ] = num ++ ; j ++ ; i -- ; } cout << " The ▁ Magic ▁ Square ▁ for ▁ n = " << n << " : \n Sum ▁ of ▁ " " each ▁ row ▁ or ▁ column ▁ " << n * ( n * n + 1 ) / 2 << " : \n \n " ; for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < n ; j ++ ) cout << magicSquare [ i ] [ j ] << " ▁ " ; cout << endl ; } }
Ref: 
def generateSquare ( n ) : NEW_LINE INDENT magicSquare = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] NEW_LINE i = n / 2 NEW_LINE j = n - 1 NEW_LINE num = 1 NEW_LINE while num <= ( n * n ) : NEW_LINE INDENT if i == - 1 and j == n : NEW_LINE INDENT j = n - 2 NEW_LINE i = 0 NEW_LINE DEDENT else : NEW_LINE INDENT if j == n : NEW_LINE INDENT j = 0 NEW_LINE DEDENT if i < 0 : NEW_LINE INDENT i = n - 1 NEW_LINE DEDENT DEDENT if magicSquare [ int ( i ) ] [ int ( j ) ] : NEW_LINE INDENT j = j - 2 NEW_LINE i = i + 1 NEW_LINE continue NEW_LINE DEDENT else : NEW_LINE INDENT magicSquare [ int ( i ) ] [ int ( j ) ] = num NEW_LINE num = num + 1 NEW_LINE DEDENT j = j + 1 NEW_LINE i = i - 1 NEW_LINE DEDENT print ( " Magic ▁ Squre ▁ for ▁ n ▁ = " , n ) NEW_LINE print ( " Sum ▁ of ▁ each ▁ row ▁ or ▁ column " , n * ( n * n + 1 ) / 2 , " \n " ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT print ( ' % 2d ▁ ' % ( magicSquare [ i ] [ j ] ) , end = ' ' ) NEW_LINE if j == n - 1 : NEW_LINE INDENT print ( ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
Hyp: 
def generateSquare ( n ) : NEW_LINE INDENT magicSquare = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] NEW_LINE i = int ( n / 2 ) NEW_LINE j = n - 1 NEW_LINE num = 1 NEW_LINE while ( num <= n * n ) : NEW_LINE INDENT if ( i == - 1 and j == n ) : NEW_LINE INDENT j = n - 2 NEW_LINE i = 0 NEW_LINE DEDENT else : NEW_LINE INDENT if ( j == n ) : NEW_LINE INDENT j = 0 NEW_LINE DEDENT if ( i < 0 ) : NEW_LINE INDENT i = n - 1 NEW_LINE DEDENT DEDENT if ( magicSquare [ i ] [ j ] ) : NEW_LINE INDENT j -= 2 NEW_LINE i += 1 NEW_LINE continue NEW_LINE DEDENT else : NEW_LINE INDENT magicSquare [ i ] [ j ] = num += 1 NEW_LINE j += 1 NEW_LINE i -= 1 NEW_LINE DEDENT DEDENT print ( " The ▁ Magic ▁ Square ▁ for ▁ n = " , n , " : \n " ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT print ( magicSquare [ i ] [ j ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT

BLEU: 56.53
Edit Sim: 259


Src: 
int count ( string a , string b , int m , int n ) { if ( ( m == 0 && n == 0 ) || n == 0 ) return 1 ; if ( m == 0 ) return 0 ; if ( a [ m - 1 ] == b [ n - 1 ] ) return count ( a , b , m - 1 , n - 1 ) + count ( a , b , m - 1 , n ) ; else return count ( a , b , m - 1 , n ) ; }
Ref: 
def count ( a , b , m , n ) : NEW_LINE INDENT if ( ( m == 0 and n == 0 ) or n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( m == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( a [ m - 1 ] == b [ n - 1 ] ) : NEW_LINE INDENT return ( count ( a , b , m - 1 , n - 1 ) + count ( a , b , m - 1 , n ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return count ( a , b , m - 1 , n ) NEW_LINE DEDENT DEDENT
Hyp: 
def count ( a , b , m , n ) : NEW_LINE INDENT if ( ( m == 0 and n == 0 ) or n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( m == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( a [ m - 1 ] == b [ n - 1 ] ) : NEW_LINE INDENT return count ( a , b , m - 1 , n - 1 ) + count ( a , b , m - 1 , n ) NEW_LINE DEDENT else : NEW_LINE INDENT return count ( a , b , m - 1 , n ) NEW_LINE DEDENT DEDENT

BLEU: 96.44
Edit Sim: 4


Src: 
int numofArray ( int n , int m ) { int dp [ MAX ] [ MAX ] ; vector < int > di [ MAX ] ; vector < int > mu [ MAX ] ; memset ( dp , 0 , sizeof dp ) ; memset ( di , 0 , sizeof di ) ; memset ( mu , 0 , sizeof mu ) ; for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 2 * i ; j <= m ; j += i ) { di [ j ] . push_back ( i ) ; mu [ i ] . push_back ( j ) ; } di [ i ] . push_back ( i ) ; } for ( int i = 1 ; i <= m ; i ++ ) dp [ 1 ] [ i ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { dp [ i ] [ j ] = 0 ; for ( auto x : di [ j ] ) dp [ i ] [ j ] += dp [ i - 1 ] [ x ] ; for ( auto x : mu [ j ] ) dp [ i ] [ j ] += dp [ i - 1 ] [ x ] ; } } int ans = 0 ; for ( int i = 1 ; i <= m ; i ++ ) { ans += dp [ n ] [ i ] ; di [ i ] . clear ( ) ; mu [ i ] . clear ( ) ; } return ans ; }
Ref: 
def numofArray ( n , m ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( MAX ) ] for j in range ( MAX ) ] NEW_LINE di = [ [ ] for i in range ( MAX ) ] NEW_LINE mu = [ [ ] for i in range ( MAX ) ] NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 2 * i , m + 1 , i ) : NEW_LINE INDENT di [ j ] . append ( i ) NEW_LINE mu [ i ] . append ( j ) NEW_LINE DEDENT di [ i ] . append ( i ) NEW_LINE DEDENT for i in range ( 1 , m + 1 ) : NEW_LINE INDENT dp [ 1 ] [ i ] = 1 NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , m + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = 0 NEW_LINE for x in di [ j ] : NEW_LINE INDENT dp [ i ] [ j ] += dp [ i - 1 ] [ x ] NEW_LINE DEDENT for x in mu [ j ] : NEW_LINE INDENT dp [ i ] [ j ] += dp [ i - 1 ] [ x ] NEW_LINE DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT ans += dp [ n ] [ i ] NEW_LINE di [ i ] . clear ( ) NEW_LINE mu [ i ] . clear ( ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
Hyp: 
def numofArray ( n , m ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( MAX ) ] for j in range ( MAX ) ] NEW_LINE mu = [ 0 for i in range ( MAX ) ] NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 2 * i , m + 1 ) : NEW_LINE INDENT di [ j ] . append ( i ) NEW_LINE mu [ i ] . append ( j ) NEW_LINE DEDENT di [ i ] . append ( i ) NEW_LINE DEDENT for i in range ( 1 , m + 1 ) : NEW_LINE INDENT dp [ 1 ] [ i ] = 1 NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , m + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = 0 NEW_LINE for x in di : NEW_LINE INDENT dp [ i ] [ j ] += dp [ i - 1 ] [ x ] NEW_LINE DEDENT for x in mu [ j ] : NEW_LINE INDENT dp [ i ] [ j ] += dp [ i - 1 ] [ x ] NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT ans += dp [ n ] [ i ] NEW_LINE di [ i ] . clear ( ) NEW_LINE mu [ i ] . clear ( ) NEW_LINE DEDENT return ans NEW_LINE DEDENT

BLEU: 90.76
Edit Sim: 65


Src: 
int countOnes ( bool arr [ ] , int low , int high ) { if ( high >= low ) { int mid = low + ( high - low ) / 2 ; if ( ( mid == high || arr [ mid + 1 ] == 0 ) && ( arr [ mid ] == 1 ) ) return mid + 1 ; if ( arr [ mid ] == 1 ) return countOnes ( arr , ( mid + 1 ) , high ) ; return countOnes ( arr , low , ( mid - 1 ) ) ; } return 0 ; }
Ref: 
def countOnes ( arr , low , high ) : NEW_LINE INDENT if high >= low : NEW_LINE INDENT mid = low + ( high - low ) / 2 NEW_LINE if ( ( mid == high or arr [ mid + 1 ] == 0 ) and ( arr [ mid ] == 1 ) ) : NEW_LINE INDENT return mid + 1 NEW_LINE DEDENT if arr [ mid ] == 1 : NEW_LINE INDENT return countOnes ( arr , ( mid + 1 ) , high ) NEW_LINE DEDENT return countOnes ( arr , low , mid - 1 ) NEW_LINE DEDENT return 0 NEW_LINE DEDENT
Hyp: 
def countOnes ( arr , low , high ) : NEW_LINE INDENT if high >= low : NEW_LINE INDENT mid = low + ( high - low ) // 2 NEW_LINE DEDENT if ( mid == high or arr [ mid + 1 ] == 0 and arr [ mid ] == 1 ) : NEW_LINE INDENT return mid + 1 NEW_LINE DEDENT if ( arr [ mid ] == 1 ) : NEW_LINE INDENT return countOnes ( arr , ( mid + 1 ) , high ) NEW_LINE DEDENT return countOnes ( arr , low , ( mid - 1 ) ) NEW_LINE DEDENT

BLEU: 82.81
Edit Sim: 45


Src: 
int ceilSearch ( int arr [ ] , int low , int high , int x ) { int mid ; if ( x <= arr [ low ] ) return low ; if ( x > arr [ high ] ) return - 1 ; mid = ( low + high ) / 2 ; if ( arr [ mid ] == x ) return mid ; else if ( arr [ mid ] < x ) { if ( mid + 1 <= high && x <= arr [ mid + 1 ] ) return mid + 1 ; else return ceilSearch ( arr , mid + 1 , high , x ) ; } else { if ( mid - 1 >= low && x > arr [ mid - 1 ] ) return mid ; else return ceilSearch ( arr , low , mid - 1 , x ) ; } }
Ref: 
def ceilSearch ( arr , low , high , x ) : NEW_LINE INDENT if x <= arr [ low ] : NEW_LINE INDENT return low NEW_LINE DEDENT if x > arr [ high ] : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = ( low + high ) / 2 NEW_LINE if arr [ mid ] == x : NEW_LINE INDENT return mid NEW_LINE DEDENT elif arr [ mid ] < x : NEW_LINE INDENT if mid + 1 <= high and x <= arr [ mid + 1 ] : NEW_LINE INDENT return mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT return ceilSearch ( arr , mid + 1 , high , x ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if mid - 1 >= low and x > arr [ mid - 1 ] : NEW_LINE INDENT return mid NEW_LINE DEDENT else : NEW_LINE INDENT return ceilSearch ( arr , low , mid - 1 , x ) NEW_LINE DEDENT DEDENT DEDENT
Hyp: 
def ceilSearch ( arr , low , high , x ) : NEW_LINE INDENT if x <= arr [ low ] : NEW_LINE INDENT return low NEW_LINE DEDENT if x > arr [ high ] : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = int ( ( low + high ) / 2 ) NEW_LINE if arr [ mid ] == x : NEW_LINE INDENT return mid NEW_LINE DEDENT elif arr [ mid ] < x : NEW_LINE INDENT if mid + 1 <= high and x <= arr [ mid + 1 ] : NEW_LINE INDENT return mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT return ceilSearch ( arr , mid + 1 , high , x ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if mid - 1 >= low and x > arr [ mid - 1 ] : NEW_LINE INDENT return mid NEW_LINE DEDENT else : NEW_LINE INDENT return ceilSearch ( arr , low , mid - 1 , x ) NEW_LINE DEDENT DEDENT DEDENT

BLEU: 96.46
Edit Sim: 8


Src: 
string decToBin ( int n ) { if ( n == 0 ) return "0" ; string bin = " " ; while ( n > 0 ) { bin = ( ( n & 1 ) == 0 ? '0' : '1' ) + bin ; n >>= 1 ; } return bin ; }
Ref: 
def decToBin ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return "0" NEW_LINE DEDENT bin = " " NEW_LINE while ( n > 0 ) : NEW_LINE INDENT if ( n & 1 == 0 ) : NEW_LINE INDENT bin = '0' + bin NEW_LINE DEDENT else : NEW_LINE INDENT bin = '1' + bin NEW_LINE DEDENT n = n >> 1 NEW_LINE DEDENT return bin NEW_LINE DEDENT
Hyp: 
def decToBin ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return "0" NEW_LINE DEDENT bin = " " NEW_LINE while ( n > 0 ) : NEW_LINE INDENT bin = ( ( n & 1 ) == 0 ? '0' : '1' ) + bin NEW_LINE n >>= 1 NEW_LINE DEDENT return bin NEW_LINE DEDENT

BLEU: 62.63
Edit Sim: 93


Src: 
public : void printNos ( unsigned int n ) { if ( n > 0 ) { printNos ( n - 1 ) ; cout << n << " ▁ " ; } return ; }
Ref: 
def printNos ( n ) : NEW_LINE INDENT if n > 0 : NEW_LINE INDENT printNos ( n - 1 ) NEW_LINE print ( n , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT
Hyp: 
def printNos ( n ) : NEW_LINE INDENT if n > 0 : NEW_LINE INDENT printNos ( n - 1 ) NEW_LINE print ( n , end = " ▁ " ) NEW_LINE DEDENT return NEW_LINE DEDENT

BLEU: 80.46
Edit Sim: 18


Src: 
void prefixSum2D ( int a [ ] [ C ] ) { int psa [ R ] [ C ] ; psa [ 0 ] [ 0 ] = a [ 0 ] [ 0 ] ; for ( int i = 1 ; i < C ; i ++ ) psa [ 0 ] [ i ] = psa [ 0 ] [ i - 1 ] + a [ 0 ] [ i ] ; for ( int i = 0 ; i < R ; i ++ ) psa [ i ] [ 0 ] = psa [ i - 1 ] [ 0 ] + a [ i ] [ 0 ] ; for ( int i = 1 ; i < R ; i ++ ) { for ( int j = 1 ; j < C ; j ++ ) psa [ i ] [ j ] = psa [ i - 1 ] [ j ] + psa [ i ] [ j - 1 ] - psa [ i - 1 ] [ j - 1 ] + a [ i ] [ j ] ; } for ( int i = 0 ; i < R ; i ++ ) { for ( int j = 0 ; j < C ; j ++ ) cout << psa [ i ] [ j ] << " ▁ " ; cout << " \n " ; } }
Ref: 
def prefixSum2D ( a ) : NEW_LINE INDENT global C , R NEW_LINE psa = [ [ 0 for x in range ( C ) ] for y in range ( R ) ] NEW_LINE psa [ 0 ] [ 0 ] = a [ 0 ] [ 0 ] NEW_LINE for i in range ( 1 , C ) : NEW_LINE INDENT psa [ 0 ] [ i ] = ( psa [ 0 ] [ i - 1 ] + a [ 0 ] [ i ] ) NEW_LINE DEDENT for i in range ( 0 , R ) : NEW_LINE INDENT psa [ i ] [ 0 ] = ( psa [ i - 1 ] [ 0 ] + a [ i ] [ 0 ] ) NEW_LINE DEDENT for i in range ( 1 , R ) : NEW_LINE INDENT for j in range ( 1 , C ) : NEW_LINE INDENT psa [ i ] [ j ] = ( psa [ i - 1 ] [ j ] + psa [ i ] [ j - 1 ] - psa [ i - 1 ] [ j - 1 ] + a [ i ] [ j ] ) NEW_LINE DEDENT DEDENT for i in range ( 0 , R ) : NEW_LINE INDENT for j in range ( 0 , C ) : NEW_LINE INDENT print ( psa [ i ] [ j ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT
Hyp: 
def prefixSum2D ( a ) : NEW_LINE INDENT psa = [ [ 0 for i in range ( C ) ] for j in range ( R ) ] NEW_LINE psa [ 0 ] [ 0 ] = a [ 0 ] [ 0 ] NEW_LINE for i in range ( 1 , C ) : NEW_LINE INDENT psa [ 0 ] [ i ] = psa [ 0 ] [ i - 1 ] + a [ 0 ] [ i ] NEW_LINE DEDENT for i in range ( R ) : NEW_LINE INDENT for j in range ( 1 , C ) : NEW_LINE INDENT psa [ i ] [ j ] = psa [ i - 1 ] [ j ] + psa [ i ] [ j - 1 ] - psa [ i - 1 ] [ j - 1 ] + a [ i ] [ j ] NEW_LINE DEDENT DEDENT for i in range ( 1 , R ) : NEW_LINE INDENT for j in range ( 1 , C ) : NEW_LINE INDENT psa [ i ] [ j ] = psa [ i - 1 ] [ j ] + psa [ i ] [ j - 1 ] - psa [ i - 1 ] [ j - 1 ] + a [ i ] [ j ] NEW_LINE DEDENT DEDENT for i in range ( R ) : NEW_LINE INDENT for j in range ( C ) : NEW_LINE INDENT print ( psa [ i ] [ j ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT

BLEU: 77.85
Edit Sim: 139


Src: 
int eulerian ( int n , int m ) { if ( m >= n || n == 0 ) return 0 ; if ( m == 0 ) return 1 ; return ( n - m ) * eulerian ( n - 1 , m - 1 ) + ( m + 1 ) * eulerian ( n - 1 , m ) ; }
Ref: 
def eulerian ( n , m ) : NEW_LINE INDENT if ( m >= n or n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( m == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return ( ( n - m ) * eulerian ( n - 1 , m - 1 ) + ( m + 1 ) * eulerian ( n - 1 , m ) ) NEW_LINE DEDENT
Hyp: 
def eulerian ( n , m ) : NEW_LINE INDENT if ( m >= n or n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( m == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return ( n - m ) * eulerian ( n - 1 , m - 1 ) + ( m + 1 ) * eulerian ( n - 1 , m ) ) NEW_LINE DEDENT

BLEU: 97.66
Edit Sim: 2


Src: 
long long int findSubarraySum ( int arr [ ] , int n ) { int res = 0 ; unordered_map < int , int > m ; for ( int i = 0 ; i < n ; i ++ ) { int sum = 0 ; for ( int j = i ; j < n ; j ++ ) { sum += arr [ j ] ; m [ sum ] ++ ; } } for ( auto x : m ) if ( x . second == 1 ) res += x . first ; return res ; }
Ref: 
def findSubarraySum ( arr , n ) : NEW_LINE INDENT res = 0 NEW_LINE m = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT Sum = 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT Sum += arr [ j ] NEW_LINE m [ Sum ] = m . get ( Sum , 0 ) + 1 NEW_LINE DEDENT DEDENT for x in m : NEW_LINE INDENT if m [ x ] == 1 : NEW_LINE INDENT res += x NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
Hyp: 
def findSubarraySum ( arr , n ) : NEW_LINE INDENT res = 0 NEW_LINE mp = defaultdict ( lambda : 0 ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT Sum = 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT Sum += arr [ j ] NEW_LINE mp [ Sum ] += 1 NEW_LINE DEDENT DEDENT for x in mp : NEW_LINE INDENT if ( mp [ second ] == 1 ) : NEW_LINE INDENT res += x NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT

BLEU: 70.84
Edit Sim: 59


Src: 
int isMultipleOf3 ( int n ) { int odd_count = 0 ; int even_count = 0 ; if ( n < 0 ) n = - n ; if ( n == 0 ) return 1 ; if ( n == 1 ) return 0 ; while ( n ) { if ( n & 1 ) odd_count ++ ; if ( n & 2 ) even_count ++ ; n = n >> 2 ; } return isMultipleOf3 ( abs ( odd_count - even_count ) ) ; }
Ref: 
def isMultipleOf3 ( n ) : NEW_LINE INDENT odd_count = 0 NEW_LINE even_count = 0 NEW_LINE if ( n < 0 ) : NEW_LINE INDENT n = - n NEW_LINE DEDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT while ( n ) : NEW_LINE INDENT if ( n & 1 ) : NEW_LINE INDENT odd_count += 1 NEW_LINE DEDENT if ( n & 2 ) : NEW_LINE INDENT even_count += 1 NEW_LINE DEDENT n = n >> 2 NEW_LINE DEDENT return isMultipleOf3 ( abs ( odd_count - even_count ) ) NEW_LINE DEDENT
Hyp: 
def isMultipleOf3 ( n ) : NEW_LINE INDENT odd_count = 0 NEW_LINE even_count = 0 NEW_LINE if ( n < 0 ) : NEW_LINE INDENT n = - n NEW_LINE DEDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT while ( n ) : NEW_LINE INDENT if ( n & 1 ) : NEW_LINE INDENT odd_count += 1 NEW_LINE DEDENT if ( n & 2 ) : NEW_LINE INDENT even_count += 1 NEW_LINE DEDENT n = n >> 2 NEW_LINE DEDENT return isMultipleOf3 ( abs ( odd_count - even_count ) ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int longestSubsequenceCommonSegment ( int k , string s1 , string s2 ) { int n = s1 . length ( ) ; int m = s2 . length ( ) ; int lcs [ n + 1 ] [ m + 1 ] ; int cnt [ n + 1 ] [ m + 1 ] ; memset ( lcs , 0 , sizeof ( lcs ) ) ; memset ( cnt , 0 , sizeof ( cnt ) ) ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { lcs [ i ] [ j ] = max ( lcs [ i - 1 ] [ j ] , lcs [ i ] [ j - 1 ] ) ; if ( s1 [ i - 1 ] == s2 [ j - 1 ] ) cnt [ i ] [ j ] = cnt [ i - 1 ] [ j - 1 ] + 1 ; if ( cnt [ i ] [ j ] >= k ) { for ( int a = k ; a <= cnt [ i ] [ j ] ; a ++ ) lcs [ i ] [ j ] = max ( lcs [ i ] [ j ] , lcs [ i - a ] [ j - a ] + a ) ; } } } return lcs [ n ] [ m ] ; }
Ref: 
def longestSubsequenceCommonSegment ( k , s1 , s2 ) : NEW_LINE INDENT n = len ( s1 ) NEW_LINE m = len ( s2 ) NEW_LINE lcs = [ [ 0 for x in range ( m + 1 ) ] for y in range ( n + 1 ) ] NEW_LINE cnt = [ [ 0 for x in range ( m + 1 ) ] for y in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , m + 1 ) : NEW_LINE INDENT lcs [ i ] [ j ] = max ( lcs [ i - 1 ] [ j ] , lcs [ i ] [ j - 1 ] ) NEW_LINE if ( s1 [ i - 1 ] == s2 [ j - 1 ] ) : NEW_LINE INDENT cnt [ i ] [ j ] = cnt [ i - 1 ] [ j - 1 ] + 1 NEW_LINE DEDENT if ( cnt [ i ] [ j ] >= k ) : NEW_LINE INDENT for a in range ( k , cnt [ i ] [ j ] + 1 ) : NEW_LINE INDENT lcs [ i ] [ j ] = max ( lcs [ i ] [ j ] , lcs [ i - a ] [ j - a ] + a ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return lcs [ n ] [ m ] NEW_LINE DEDENT
Hyp: 
def longestSubsequenceCommonSegment ( k , s1 , s2 ) : NEW_LINE INDENT n = len ( s1 ) NEW_LINE m = len ( s2 ) NEW_LINE lcs = [ [ 0 for i in range ( m + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE cnt = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , m + 1 ) : NEW_LINE INDENT lcs [ i ] [ j ] = max ( lcs [ i - 1 ] [ j ] , lcs [ i ] [ j - 1 ] ) NEW_LINE if ( s1 [ i - 1 ] == s2 [ j - 1 ] ) : NEW_LINE INDENT cnt [ i ] [ j ] = cnt [ i - 1 ] [ j - 1 ] + 1 NEW_LINE DEDENT if ( cnt [ i ] [ j ] >= k ) : NEW_LINE INDENT for a in range ( k , cnt [ i ] [ j ] + 1 ) : NEW_LINE INDENT lcs [ i ] [ j ] = max ( lcs [ i ] [ j ] , lcs [ i - a ] [ j - a ] + a ) NEW_LINE DEDENT DEDENT DEDENT return lcs [ n ] [ m ] NEW_LINE DEDENT

BLEU: 94.78
Edit Sim: 12


Src: 
int areaSquare ( int side ) { int area = side * side ; return area ; }
Ref: 
def areaSquare ( side ) : NEW_LINE INDENT area = side * side NEW_LINE return area NEW_LINE DEDENT
Hyp: 
def areaSquare ( side ) : NEW_LINE INDENT area = side * side NEW_LINE return area NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
void findpath ( int graph [ ] [ 5 ] , int n ) { vector < int > numofadj ; for ( int i = 0 ; i < n ; i ++ ) numofadj . push_back ( accumulate ( graph [ i ] , graph [ i ] + 5 , 0 ) ) ; int startpoint = 0 , numofodd = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( numofadj [ i ] % 2 == 1 ) { numofodd ++ ; startpoint = i ; } } if ( numofodd > 2 ) { cout << " No ▁ Solution " << endl ; return ; } stack < int > stack ; vector < int > path ; int cur = startpoint ; while ( ! stack . empty ( ) or accumulate ( graph [ cur ] , graph [ cur ] + 5 , 0 ) != 0 ) { if ( accumulate ( graph [ cur ] , graph [ cur ] + 5 , 0 ) == 0 ) { path . push_back ( cur ) ; cur = stack . top ( ) ; stack . pop ( ) ; } else { for ( int i = 0 ; i < n ; i ++ ) { if ( graph [ cur ] [ i ] == 1 ) { stack . push ( cur ) ; graph [ cur ] [ i ] = 0 ; graph [ i ] [ cur ] = 0 ; cur = i ; break ; } } } } for ( auto ele : path ) cout << ele << " ▁ - > ▁ " ; cout << cur << endl ; }
Ref: 
def findpath ( graph ) : NEW_LINE INDENT n = len ( graph ) NEW_LINE numofadj = list ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT numofadj . append ( sum ( graph [ i ] ) ) NEW_LINE DEDENT startpoint = 0 NEW_LINE numofodd = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( numofadj [ i ] % 2 == 1 ) : NEW_LINE INDENT numofodd += 1 NEW_LINE startpoint = i NEW_LINE DEDENT DEDENT if ( numofodd > 2 ) : NEW_LINE INDENT print ( " No ▁ Solution " ) NEW_LINE return NEW_LINE DEDENT stack = list ( ) NEW_LINE path = list ( ) NEW_LINE cur = startpoint NEW_LINE while ( stack != [ ] or sum ( graph [ cur ] ) != 0 ) : NEW_LINE INDENT if ( sum ( graph [ cur ] ) == 0 ) : NEW_LINE INDENT path . append ( cur + 1 ) NEW_LINE cur = stack . pop ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if graph [ cur ] [ i ] == 1 : NEW_LINE INDENT stack . append ( cur ) NEW_LINE graph [ cur ] [ i ] = 0 NEW_LINE graph [ i ] [ cur ] = 0 NEW_LINE cur = i NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT for ele in path : NEW_LINE INDENT print ( ele , " - > ▁ " , end = ' ' ) NEW_LINE DEDENT print ( cur + 1 ) NEW_LINE DEDENT
Hyp: 
def findpath ( graph , n ) : NEW_LINE INDENT numofadj = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT numofadj . append ( accumulate ( graph [ i ] , graph [ i ] + 5 , 0 ) ) NEW_LINE DEDENT startpoint = 0 NEW_LINE numofodd = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if numofadj [ i ] % 2 == 1 : NEW_LINE INDENT numofodd += 1 NEW_LINE startpoint = i NEW_LINE DEDENT DEDENT if numofodd > 2 : NEW_LINE INDENT print ( " No ▁ Solution " ) NEW_LINE return NEW_LINE DEDENT stack = [ ] NEW_LINE path = [ ] NEW_LINE cur = startpoint NEW_LINE while ( len ( stack ) != 0 ) : NEW_LINE INDENT if ( accumulate ( graph [ cur ] , graph [ cur ] + 5 , 0 ) == 0 ) : NEW_LINE INDENT path . append ( cur ) NEW_LINE cur = stack [ - 1 ] NEW_LINE stack . pop ( ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( graph [ cur ] [ i ] == 1 ) : NEW_LINE INDENT stack . append ( cur ) NEW_LINE graph [ cur ] [ i ] = 0 NEW_LINE graph [ i ] [ cur ] = 0 NEW_LINE cur = i NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT for ele in path : NEW_LINE INDENT print ( ele , end = " ▁ - > ▁ " ) NEW_LINE DEDENT print ( cur ) NEW_LINE DEDENT

BLEU: 76.96
Edit Sim: 203


Src: 
int lcsOf3 ( int i , int j , int k ) { if ( i == - 1 || j == - 1 || k == - 1 ) return 0 ; if ( dp [ i ] [ j ] [ k ] != - 1 ) return dp [ i ] [ j ] [ k ] ; if ( X [ i ] == Y [ j ] && Y [ j ] == Z [ k ] ) return dp [ i ] [ j ] [ k ] = 1 + lcsOf3 ( i - 1 , j - 1 , k - 1 ) ; else return dp [ i ] [ j ] [ k ] = max ( max ( lcsOf3 ( i - 1 , j , k ) , lcsOf3 ( i , j - 1 , k ) ) , lcsOf3 ( i , j , k - 1 ) ) ; }
Ref: 
def lcsOf3 ( i , j , k ) : NEW_LINE INDENT if ( i == - 1 or j == - 1 or k == - 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ i ] [ j ] [ k ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ j ] [ k ] NEW_LINE DEDENT if ( X [ i ] == Y [ j ] and Y [ j ] == Z [ k ] ) : NEW_LINE INDENT dp [ i ] [ j ] [ k ] = 1 + lcsOf3 ( i - 1 , j - 1 , k - 1 ) NEW_LINE return dp [ i ] [ j ] [ k ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] [ k ] = max ( max ( lcsOf3 ( i - 1 , j , k ) , lcsOf3 ( i , j - 1 , k ) ) , lcsOf3 ( i , j , k - 1 ) ) NEW_LINE return dp [ i ] [ j ] [ k ] NEW_LINE DEDENT DEDENT
Hyp: 
def lcsOf3 ( i , j , k ) : NEW_LINE INDENT if ( i == - 1 or j == - 1 or k == - 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ i ] [ j ] [ k ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ j ] [ k ] NEW_LINE DEDENT if ( X [ i ] == Y [ j ] and Y [ j ] == Z [ k ] ) : NEW_LINE INDENT dp [ i ] [ j ] [ k ] = 1 + lcsOf3 ( i - 1 , j - 1 , k - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] [ k ] = max ( max ( lcsOf3 ( i - 1 , j , k ) , lcsOf3 ( i , j - 1 , k ) ) , lcsOf3 ( i , j , k - 1 ) ) NEW_LINE DEDENT DEDENT

BLEU: 86.64
Edit Sim: 74


Src: 
void findLarger ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; for ( int i = n - 1 ; i >= n / 2 ; i -- ) cout << arr [ i ] << " ▁ " ; }
Ref: 
def findLarger ( arr , n ) : NEW_LINE INDENT x = sorted ( arr ) NEW_LINE for i in range ( n / 2 , n ) : NEW_LINE INDENT print ( x [ i ] ) , NEW_LINE DEDENT DEDENT
Hyp: 
def findLarger ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE for i in range ( n - 1 , int ( n / 2 ) + 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT

BLEU: 49.44
Edit Sim: 45


Src: 
int spiralDiaSum ( int n ) { if ( n == 1 ) return 1 ; return ( 4 * n * n - 6 * n + 6 + spiralDiaSum ( n - 2 ) ) ; }
Ref: 
def spiralDiaSum ( n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT return ( 4 * n * n - 6 * n + 6 + spiralDiaSum ( n - 2 ) ) NEW_LINE DEDENT
Hyp: 
def spiralDiaSum ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return ( 4 * n * n - 6 * n + 6 + spiralDiaSum ( n - 2 ) ) NEW_LINE DEDENT

BLEU: 88.2
Edit Sim: 4


Src: 
int countOccurrences ( int arr [ ] , int n , int x ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( x == arr [ i ] ) res ++ ; return res ; }
Ref: 
def countOccurrences ( arr , n , x ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if x == arr [ i ] : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
Hyp: 
def countOccurrences ( arr , n , x ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( x == arr [ i ] ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT

BLEU: 89.22
Edit Sim: 4


Src: 
int sumBetweenTwoKth ( int arr [ ] , int n , int k1 , int k2 ) { sort ( arr , arr + n ) ; return accumulate ( arr + k1 , arr + k2 - 1 , 0 ) ; }
Ref: 
def sumBetweenTwoKth ( arr , n , k1 , k2 ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE result = 0 NEW_LINE for i in range ( k1 , k2 - 1 ) : NEW_LINE INDENT result += arr [ i ] NEW_LINE DEDENT return result NEW_LINE DEDENT
Hyp: 
def sumBetweenTwoKth ( arr , n , k1 , k2 ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE return accumulate ( arr + k1 , arr + k2 - 1 , 0 ) NEW_LINE DEDENT

BLEU: 44.57
Edit Sim: 95


Src: 
int calculate ( int a [ ] , int n ) { int * maximum = max_element ( a , a + 5 ) ; int frequency [ * maximum + 1 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { frequency [ a [ i ] ] += 1 ; } int answer = 0 ; for ( int i = 0 ; i < ( * maximum ) + 1 ; i ++ ) { answer = answer + frequency [ i ] * ( frequency [ i ] - 1 ) ; } return answer / 2 ; }
Ref: 
def calculate ( a ) : NEW_LINE INDENT maximum = max ( a ) NEW_LINE frequency = [ 0 for x in range ( maximum + 1 ) ] NEW_LINE for i in a : NEW_LINE INDENT frequency [ i ] += 1 NEW_LINE DEDENT answer = 0 NEW_LINE for i in frequency : NEW_LINE INDENT answer = answer + i * ( i - 1 ) // 2 NEW_LINE DEDENT return answer NEW_LINE DEDENT
Hyp: 
def calculate ( a , n ) : NEW_LINE INDENT maximum = max ( a , a + 5 ) NEW_LINE frequency = [ 0 ] * ( maximum + 1 ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT frequency [ a [ i ] ] = frequency [ a [ i ] ] + 1 NEW_LINE DEDENT answer = 0 NEW_LINE for i in range ( 0 , ( * maximum ) + 1 ) : NEW_LINE INDENT answer = answer + frequency [ i ] * ( frequency [ i ] - 1 ) NEW_LINE DEDENT return answer // 2 NEW_LINE DEDENT

BLEU: 43.62
Edit Sim: 135


Src: 
unsigned int doublefactorial ( unsigned int n ) { int res = 1 ; for ( int i = n ; i >= 0 ; i = i - 2 ) { if ( i == 0 || i == 1 ) return res ; else res *= i ; } }
Ref: 
def doublefactorial ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( n , - 1 , - 2 ) : NEW_LINE INDENT if ( i == 0 or i == 1 ) : NEW_LINE INDENT return res NEW_LINE DEDENT else : NEW_LINE INDENT res *= i NEW_LINE DEDENT DEDENT DEDENT
Hyp: 
def doublefactorial ( n ) : NEW_LINE INDENT return 1 if ( n == 0 or n == 1 ) else n * factorial ( n - 1 ) NEW_LINE DEDENT

BLEU: 19.61
Edit Sim: 143


Src: 
int lcs ( char * X , char * Y , int m , int n ) { if ( m == 0 || n == 0 ) return 0 ; if ( X [ m - 1 ] == Y [ n - 1 ] ) return 1 + lcs ( X , Y , m - 1 , n - 1 ) ; else return max ( lcs ( X , Y , m , n - 1 ) , lcs ( X , Y , m - 1 , n ) ) ; }
Ref: 
def lcs ( X , Y , m , n ) : NEW_LINE INDENT if m == 0 or n == 0 : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT elif X [ m - 1 ] == Y [ n - 1 ] : NEW_LINE INDENT return 1 + lcs ( X , Y , m - 1 , n - 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT return max ( lcs ( X , Y , m , n - 1 ) , lcs ( X , Y , m - 1 , n ) ) ; NEW_LINE DEDENT DEDENT
Hyp: 
def lcs ( X , Y , m , n ) : NEW_LINE INDENT if ( m == 0 or n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( X [ m - 1 ] == Y [ n - 1 ] ) : NEW_LINE INDENT return 1 + lcs ( X , Y , m - 1 , n - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return max ( lcs ( X , Y , m , n - 1 ) , lcs ( X , Y , m - 1 , n ) ) NEW_LINE DEDENT DEDENT

BLEU: 85.01
Edit Sim: 16


Src: 
int maxProductSubset ( int a [ ] , int n ) { if ( n == 1 ) return a [ 0 ] ; int max_neg = INT_MIN ; int count_neg = 0 , count_zero = 0 ; int prod = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) { count_zero ++ ; continue ; } if ( a [ i ] < 0 ) { count_neg ++ ; max_neg = max ( max_neg , a [ i ] ) ; } prod = prod * a [ i ] ; } if ( count_zero == n ) return 0 ; if ( count_neg & 1 ) { if ( count_neg == 1 && count_zero > 0 && count_zero + count_neg == n ) return 0 ; prod = prod / max_neg ; } return prod ; }
Ref: 
def maxProductSubset ( a , n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return a [ 0 ] NEW_LINE DEDENT max_neg = - 999999999999 NEW_LINE count_neg = 0 NEW_LINE count_zero = 0 NEW_LINE prod = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] == 0 : NEW_LINE INDENT count_zero += 1 NEW_LINE continue NEW_LINE DEDENT if a [ i ] < 0 : NEW_LINE INDENT count_neg += 1 NEW_LINE max_neg = max ( max_neg , a [ i ] ) NEW_LINE DEDENT prod = prod * a [ i ] NEW_LINE DEDENT if count_zero == n : NEW_LINE INDENT return 0 NEW_LINE DEDENT if count_neg & 1 : NEW_LINE INDENT if ( count_neg == 1 and count_zero > 0 and count_zero + count_neg == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT prod = int ( prod / max_neg ) NEW_LINE DEDENT return prod NEW_LINE DEDENT
Hyp: 
def maxProductSubset ( a , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return a [ 0 ] NEW_LINE DEDENT max_neg = - maxsize - 1 NEW_LINE count_neg = 0 NEW_LINE count_zero = 0 NEW_LINE prod = 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( a [ i ] == 0 ) : NEW_LINE INDENT count_zero += 1 NEW_LINE continue NEW_LINE DEDENT if ( a [ i ] < 0 ) : NEW_LINE INDENT count_neg += 1 NEW_LINE max_neg = max ( max_neg , a [ i ] ) NEW_LINE DEDENT prod = prod * a [ i ] NEW_LINE DEDENT if ( count_zero == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( count_neg & 1 ) : NEW_LINE INDENT if ( count_neg == 1 and count_zero > 0 and count_zero + count_neg == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT prod = prod / max_neg NEW_LINE DEDENT return prod NEW_LINE DEDENT

BLEU: 78.65
Edit Sim: 44


Src: 
int offeringNumber ( int n , int templeHeight [ ] ) { int sum = 0 ; for ( int i = 0 ; i < n ; ++ i ) { int left = 0 , right = 0 ; for ( int j = i - 1 ; j >= 0 ; -- j ) { if ( templeHeight [ j ] < templeHeight [ j + 1 ] ) ++ left ; else break ; } for ( int j = i + 1 ; j < n ; ++ j ) { if ( templeHeight [ j ] < templeHeight [ j - 1 ] ) ++ right ; else break ; } sum += max ( right , left ) + 1 ; } return sum ; }
Ref: 
def offeringNumber ( n , templeHeight ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT left = 0 NEW_LINE right = 0 NEW_LINE for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( templeHeight [ j ] < templeHeight [ j + 1 ] ) : NEW_LINE INDENT left += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( templeHeight [ j ] < templeHeight [ j - 1 ] ) : NEW_LINE INDENT right += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT sum += max ( right , left ) + 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT
Hyp: 
def offeringNumber ( n , templeHeight ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT left = 0 NEW_LINE right = 0 NEW_LINE for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( templeHeight [ j ] < templeHeight [ j + 1 ] ) : NEW_LINE INDENT left += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( templeHeight [ j ] < templeHeight [ j - 1 ] ) : NEW_LINE INDENT right += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT sum += max ( right , left ) + 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT

BLEU: 97.52
Edit Sim: 4


Src: 
int sumNodes ( int l ) { int leafNodeCount = pow ( 2 , l - 1 ) ; vector < int > vec [ l ] ; for ( int i = 1 ; i <= leafNodeCount ; i ++ ) vec [ l - 1 ] . push_back ( i ) ; for ( int i = l - 2 ; i >= 0 ; i -- ) { int k = 0 ; while ( k < vec [ i + 1 ] . size ( ) - 1 ) { vec [ i ] . push_back ( vec [ i + 1 ] [ k ] + vec [ i + 1 ] [ k + 1 ] ) ; k += 2 ; } } int sum = 0 ; for ( int i = 0 ; i < l ; i ++ ) { for ( int j = 0 ; j < vec [ i ] . size ( ) ; j ++ ) sum += vec [ i ] [ j ] ; } return sum ; }
Ref: 
def SumNodes ( l ) : NEW_LINE INDENT leafNodeCount = pow ( 2 , l - 1 ) NEW_LINE vec = [ [ ] for i in range ( l ) ] NEW_LINE for i in range ( 1 , leafNodeCount + 1 ) : NEW_LINE INDENT vec [ l - 1 ] . append ( i ) NEW_LINE DEDENT for i in range ( l - 2 , - 1 , - 1 ) : NEW_LINE INDENT k = 0 NEW_LINE while ( k < len ( vec [ i + 1 ] ) - 1 ) : NEW_LINE INDENT vec [ i ] . append ( vec [ i + 1 ] [ k ] + vec [ i + 1 ] [ k + 1 ] ) NEW_LINE k += 2 NEW_LINE DEDENT DEDENT Sum = 0 NEW_LINE for i in range ( l ) : NEW_LINE INDENT for j in range ( len ( vec [ i ] ) ) : NEW_LINE INDENT Sum += vec [ i ] [ j ] NEW_LINE DEDENT DEDENT return Sum NEW_LINE DEDENT
Hyp: 
def sumNodes ( l ) : NEW_LINE INDENT leafNodeCount = int ( math . pow ( 2 , l - 1 ) ) NEW_LINE vec = [ [ 0 for i in range ( leafNodeCount ) ] for j in range ( l ) ] NEW_LINE for i in range ( 1 , leafNodeCount + 1 ) : NEW_LINE INDENT vec [ l - 1 ] . append ( i ) NEW_LINE DEDENT for i in range ( l - 2 , - 1 , - 1 ) : NEW_LINE INDENT k = 0 NEW_LINE while ( k < len ( vec [ i + 1 ] ) - 1 ) : NEW_LINE INDENT vec [ i ] . append ( vec [ i + 1 ] [ k ] + vec [ i + 1 ] [ k + 1 ] ) NEW_LINE k += 2 NEW_LINE DEDENT DEDENT sum = 0 NEW_LINE for i in range ( l ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT sum += vec [ i ] [ j ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT

BLEU: 85.19
Edit Sim: 71


Src: 
string constructPalin ( string str , int len ) { int i = 0 , j = len - 1 ; for ( ; i < j ; i ++ , j -- ) { if ( str [ i ] == str [ j ] && str [ i ] != ' * ' ) continue ; else if ( str [ i ] == str [ j ] && str [ i ] == ' * ' ) { str [ i ] = ' a ' ; str [ j ] = ' a ' ; continue ; } else if ( str [ i ] == ' * ' ) { str [ i ] = str [ j ] ; continue ; } else if ( str [ j ] == ' * ' ) { str [ j ] = str [ i ] ; continue ; } cout << " Not ▁ Possible " ; return " " ; } return str ; }
Ref: 
def constructPalin ( string , l ) : NEW_LINE INDENT string = list ( string ) NEW_LINE i = - 1 NEW_LINE j = l NEW_LINE while i < j : NEW_LINE INDENT i += 1 NEW_LINE j -= 1 NEW_LINE if ( string [ i ] == string [ j ] and string [ i ] != ' * ' ) : NEW_LINE INDENT continue NEW_LINE DEDENT elif ( string [ i ] == string [ j ] and string [ i ] == ' * ' ) : NEW_LINE INDENT string [ i ] = ' a ' NEW_LINE string [ j ] = ' a ' NEW_LINE continue NEW_LINE DEDENT elif string [ i ] == ' * ' : NEW_LINE INDENT string [ i ] = string [ j ] NEW_LINE continue NEW_LINE DEDENT elif string [ j ] == ' * ' : NEW_LINE INDENT string [ j ] = string [ i ] NEW_LINE continue NEW_LINE DEDENT print ( " Not ▁ Possible " ) NEW_LINE return " " NEW_LINE DEDENT return ' ' . join ( string ) NEW_LINE DEDENT
Hyp: 
def constructPalin ( str , len ) : NEW_LINE INDENT i = 0 NEW_LINE j = len - 1 NEW_LINE for i in range ( 0 , j ) : NEW_LINE INDENT if ( str [ i ] == str [ j ] and str [ i ] != ' * ' ) : NEW_LINE INDENT continue NEW_LINE DEDENT elif ( str [ i ] == str [ j ] and str [ i ] == ' * ' ) : NEW_LINE INDENT str [ i ] = ' a ' NEW_LINE str [ j ] = ' a ' NEW_LINE continue NEW_LINE DEDENT elif ( str [ i ] == ' * ' ) : NEW_LINE INDENT str [ i ] = str [ j ] NEW_LINE continue NEW_LINE DEDENT elif ( str [ j ] == ' * ' ) : NEW_LINE INDENT str [ j ] = str [ i ] NEW_LINE continue NEW_LINE DEDENT DEDENT print ( " Not ▁ Possible " ) NEW_LINE return " " NEW_LINE DEDENT

BLEU: 56.3
Edit Sim: 184


Src: 
int countPairs ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] == arr [ j ] ) ans ++ ; return ans ; }
Ref: 
def countPairs ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] == arr [ j ] ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
Hyp: 
def countPairs ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if arr [ i ] == arr [ j ] : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT

BLEU: 92.22
Edit Sim: 4


Src: 
unsigned int russianPeasant ( unsigned int a , unsigned int b ) { int res = 0 ; while ( b > 0 ) { if ( b & 1 ) res = res + a ; a = a << 1 ; b = b >> 1 ; } return res ; }
Ref: 
def russianPeasant ( a , b ) : NEW_LINE INDENT res = 0 NEW_LINE while ( b > 0 ) : NEW_LINE INDENT if ( b & 1 ) : NEW_LINE INDENT res = res + a NEW_LINE DEDENT a = a << 1 NEW_LINE b = b >> 1 NEW_LINE DEDENT return res NEW_LINE DEDENT
Hyp: 
def russianPeasant ( a , b ) : NEW_LINE INDENT res = 0 NEW_LINE while ( b > 0 ) : NEW_LINE INDENT if ( b & 1 ) : NEW_LINE INDENT res = res + a NEW_LINE DEDENT a = a << 1 NEW_LINE b = b >> 1 NEW_LINE DEDENT return res NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
string encrypt ( string text , int s ) { string result = " " ; for ( int i = 0 ; i < text . length ( ) ; i ++ ) { if ( isupper ( text [ i ] ) ) result += char ( int ( text [ i ] + s - 65 ) % 26 + 65 ) ; else result += char ( int ( text [ i ] + s - 97 ) % 26 + 97 ) ; } return result ; }
Ref: 
def encrypt ( text , s ) : NEW_LINE INDENT result = " " NEW_LINE for i in range ( len ( text ) ) : NEW_LINE INDENT char = text [ i ] NEW_LINE if ( char . isupper ( ) ) : NEW_LINE INDENT result += chr ( ( ord ( char ) + s - 65 ) % 26 + 65 ) NEW_LINE DEDENT else : NEW_LINE INDENT result += chr ( ( ord ( char ) + s - 97 ) % 26 + 97 ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
Hyp: 
def encrypt ( text , s ) : NEW_LINE INDENT result = " " NEW_LINE for i in range ( 0 , len ( text ) ) : NEW_LINE INDENT if ( isupper ( text [ i ] ) ) : NEW_LINE INDENT result += chr ( int ( text [ i ] + s - 65 ) % 26 + 65 ) NEW_LINE DEDENT else : NEW_LINE INDENT result += chr ( int ( text [ i ] + s - 97 ) % 26 + 97 ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT

BLEU: 74.04
Edit Sim: 70


Src: 
long double distance ( long double lat1 , long double long1 , long double lat2 , long double long2 ) { lat1 = toRadians ( lat1 ) ; long1 = toRadians ( long1 ) ; lat2 = toRadians ( lat2 ) ; long2 = toRadians ( long2 ) ; long double dlong = long2 - long1 ; long double dlat = lat2 - lat1 ; long double ans = pow ( sin ( dlat / 2 ) , 2 ) + cos ( lat1 ) * cos ( lat2 ) * pow ( sin ( dlong / 2 ) , 2 ) ; ans = 2 * asin ( sqrt ( ans ) ) ; long double R = 6371 ; ans = ans * R ; return ans ; }
Ref: 
def distance ( lat1 , lat2 , lon1 , lon2 ) : NEW_LINE INDENT lon1 = radians ( lon1 ) NEW_LINE lon2 = radians ( lon2 ) NEW_LINE lat1 = radians ( lat1 ) NEW_LINE lat2 = radians ( lat2 ) NEW_LINE dlon = lon2 - lon1 NEW_LINE dlat = lat2 - lat1 NEW_LINE a = sin ( dlat / 2 ) ** 2 + cos ( lat1 ) * cos ( lat2 ) * sin ( dlon / 2 ) ** 2 NEW_LINE c = 2 * asin ( sqrt ( a ) ) NEW_LINE r = 6371 NEW_LINE return ( c * r ) NEW_LINE DEDENT
Hyp: 
def distance ( lat1 , long1 , lat2 , long2 ) : NEW_LINE INDENT lat1 = toRadians ( lat1 ) NEW_LINE long1 = toRadians ( long1 ) NEW_LINE lat2 = toRadians ( lat2 ) NEW_LINE long2 = toRadians ( long2 ) NEW_LINE dlong = long2 - long1 NEW_LINE dlat = lat2 - lat1 NEW_LINE ans = ( pow ( sin ( dlat / 2 ) , 2 ) + cos ( lat1 ) * cos ( lat2 ) * pow ( sin ( dlong / 2 ) , 2 ) ) NEW_LINE ans = 2 * asin ( math . sqrt ( ans ) ) NEW_LINE R = 6371 NEW_LINE ans = ans * R NEW_LINE return ans NEW_LINE DEDENT

BLEU: 38.34
Edit Sim: 105


Src: 
long int evenFib ( int n ) { if ( n < 1 ) return n ; if ( n == 1 ) return 2 ; return ( ( 4 * evenFib ( n - 1 ) ) + evenFib ( n - 2 ) ) ; }
Ref: 
def evenFib ( n ) : NEW_LINE INDENT if ( n < 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT return ( ( 4 * evenFib ( n - 1 ) ) + evenFib ( n - 2 ) ) NEW_LINE DEDENT
Hyp: 
def evenFib ( n ) : NEW_LINE INDENT if n < 1 : NEW_LINE INDENT return n NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT return 2 NEW_LINE DEDENT return ( ( 4 * evenFib ( n - 1 ) ) + evenFib ( n - 2 ) ) NEW_LINE DEDENT

BLEU: 81.2
Edit Sim: 8


Src: 
int gcd ( int a , int b ) { if ( a == 0 ) return b ; if ( b == 0 ) return a ; int k ; for ( k = 0 ; ( ( a | b ) && 1 ) == 0 ; ++ k ) { a >>= 1 ; b >>= 1 ; } while ( ( a > 1 ) == 0 ) a >>= 1 ; do { while ( ( b > 1 ) == 0 ) b >>= 1 ; if ( a > b ) swap ( a , b ) ; b = ( b - a ) ; } while ( b != 0 ) ; return a << k ; }
Ref: 
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT k = 0 NEW_LINE while ( ( ( a | b ) & 1 ) == 0 ) : NEW_LINE INDENT a = a >> 1 NEW_LINE b = b >> 1 NEW_LINE k = k + 1 NEW_LINE DEDENT while ( ( a & 1 ) == 0 ) : NEW_LINE INDENT a = a >> 1 NEW_LINE DEDENT while ( b != 0 ) : NEW_LINE INDENT while ( ( b & 1 ) == 0 ) : NEW_LINE INDENT b = b >> 1 NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT temp = a NEW_LINE a = b NEW_LINE b = temp NEW_LINE DEDENT b = ( b - a ) NEW_LINE DEDENT return ( a << k ) NEW_LINE DEDENT
Hyp: 
def gcd ( a , b ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT return b NEW_LINE DEDENT if b == 0 : NEW_LINE INDENT return a NEW_LINE DEDENT k = 0 NEW_LINE while ( ( a | b ) and 1 ) == 0 : NEW_LINE INDENT k = k + 1 NEW_LINE DEDENT while ( ( a > 1 ) == 0 ) : NEW_LINE INDENT a >>= 1 NEW_LINE b >>= 1 NEW_LINE DEDENT while ( ( a > 1 ) == 0 ) : NEW_LINE INDENT a >>= 1 NEW_LINE DEDENT while ( b > 1 ) == 0 ) : NEW_LINE INDENT b >>= 1 NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT a = a >> 1 NEW_LINE DEDENT b = ( b - a ) NEW_LINE DEDENT while ( b != 0 ) : NEW_LINE INDENT return a << k NEW_LINE DEDENT

BLEU: 66.99
Edit Sim: 155


Src: 
bool isPowerOfTwo ( int n ) { if ( n == 0 ) return 0 ; while ( n != 1 ) { if ( n % 2 != 0 ) return 0 ; n = n / 2 ; } return 1 ; }
Ref: 
def isPowerOfTwo ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT while ( n != 1 ) : NEW_LINE INDENT if ( n % 2 != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT n = n // 2 NEW_LINE DEDENT return True NEW_LINE DEDENT
Hyp: 
def isPowerOfTwo ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT while ( n != 1 ) : NEW_LINE INDENT if ( n % 2 != 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT n = int ( n / 2 ) NEW_LINE DEDENT return 1 NEW_LINE DEDENT

BLEU: 74.98
Edit Sim: 22


Src: 
long long int findSum ( int n ) { long long int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = i ; j <= n ; j ++ ) sum = sum + i * j ; return sum ; }
Ref: 
def findSum ( n ) : NEW_LINE INDENT sm = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( i , n + 1 ) : NEW_LINE INDENT sm = sm + i * j NEW_LINE DEDENT DEDENT return sm NEW_LINE DEDENT
Hyp: 
def findSum ( N ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( i , N + 1 ) : NEW_LINE INDENT sum = sum + i * j NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT

BLEU: 67.61
Edit Sim: 7


Src: 
int binomialCoeffSum ( int n ) { return ( 1 << n ) ; }
Ref: 
def binomialCoeffSum ( n ) : NEW_LINE INDENT return ( 1 << n ) NEW_LINE DEDENT
Hyp: 
def binomialCoeffSum ( n ) : NEW_LINE INDENT return math . log ( 1 << n ) NEW_LINE DEDENT

BLEU: 74.83
Edit Sim: 11


Src: 
int calculateSum ( string arr [ ] , int n ) { if ( n == 0 ) return 0 ; string s = arr [ 0 ] ; int value = stoi ( s ) ; int sum = value ; for ( int i = 2 ; i < n ; i = i + 2 ) { s = arr [ i ] ; int value = stoi ( s ) ; char operation = arr [ i - 1 ] [ 0 ] ; if ( operation == ' + ' ) sum += value ; else sum -= value ; } return sum ; }
Ref: 
def calculateSum ( arr , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT s = arr [ 0 ] NEW_LINE value = int ( s ) NEW_LINE sum = value NEW_LINE for i in range ( 2 , n , 2 ) : NEW_LINE INDENT s = arr [ i ] NEW_LINE value = int ( s ) NEW_LINE operation = arr [ i - 1 ] [ 0 ] NEW_LINE if ( operation == ' + ' ) : NEW_LINE INDENT sum += value NEW_LINE DEDENT else : NEW_LINE INDENT sum -= value NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
Hyp: 
def calculateSum ( arr , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT s = arr [ 0 ] NEW_LINE value = int ( s ) NEW_LINE sum = value NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT s = arr [ i ] NEW_LINE value = int ( s ) NEW_LINE operation = arr [ i - 1 ] [ 0 ] NEW_LINE if ( operation == ' + ' ) : NEW_LINE INDENT sum += value NEW_LINE DEDENT else : NEW_LINE INDENT sum -= value NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT

BLEU: 96.81
Edit Sim: 4


Src: 
void checkPoint ( int radius , int x , int y , float percent , float startAngle ) { float endAngle = 360 / percent + startAngle ; float polarradius = sqrt ( x * x + y * y ) ; float Angle = atan ( y / x ) ; if ( Angle >= startAngle && Angle <= endAngle && polarradius < radius ) printf ( " Point ▁ ( % d , ▁ % d ) ▁ exist ▁ in ▁ the ▁ circle ▁ sector \n " , x , y ) ; else printf ( " Point ▁ ( % d , ▁ % d ) ▁ does ▁ not ▁ exist ▁ in ▁ the ▁ circle ▁ sector \n " , x , y ) ; }
Ref: 
def checkPoint ( radius , x , y , percent , startAngle ) : NEW_LINE INDENT endAngle = 360 / percent + startAngle NEW_LINE polarradius = math . sqrt ( x * x + y * y ) NEW_LINE Angle = math . atan ( y / x ) NEW_LINE if ( Angle >= startAngle and Angle <= endAngle and polarradius < radius ) : NEW_LINE INDENT print ( " Point ▁ ( " , x , " , " , y , " ) ▁ " " exist ▁ in ▁ the ▁ circle ▁ sector " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Point ▁ ( " , x , " , " , y , " ) ▁ " " does ▁ not ▁ exist ▁ in ▁ the ▁ circle ▁ sector " ) NEW_LINE DEDENT DEDENT
Hyp: 
def checkPoint ( radius , x , y , percent , startAngle ) : NEW_LINE INDENT endAngle = 360 / percent + startAngle NEW_LINE polarradius = math . sqrt ( x * x + y * y ) NEW_LINE Angle = math . atan ( y / x ) NEW_LINE if ( Angle >= startAngle and Angle <= endAngle and polarradius < radius ) : NEW_LINE INDENT print ( " Point ▁ ( % d , ▁ % d ) ▁ exist ▁ in ▁ the ▁ circle ▁ sector " , x , y ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Point ▁ ( % d , ▁ % d ) ▁ does ▁ not ▁ exist " , x , y ) NEW_LINE DEDENT DEDENT

BLEU: 73.99
Edit Sim: 72


Src: 
void printknapSack ( int W , int wt [ ] , int val [ ] , int n ) { int i , w ; int K [ n + 1 ] [ W + 1 ] ; for ( i = 0 ; i <= n ; i ++ ) { for ( w = 0 ; w <= W ; w ++ ) { if ( i == 0 || w == 0 ) K [ i ] [ w ] = 0 ; else if ( wt [ i - 1 ] <= w ) K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) ; else K [ i ] [ w ] = K [ i - 1 ] [ w ] ; } } int res = K [ n ] [ W ] ; printf ( " % d \n " , res ) ; w = W ; for ( i = n ; i > 0 && res > 0 ; i -- ) { if ( res == K [ i - 1 ] [ w ] ) continue ; else { printf ( " % d ▁ " , wt [ i - 1 ] ) ; res = res - val [ i - 1 ] ; w = w - wt [ i - 1 ] ; } } }
Ref: 
def printknapSack ( W , wt , val , n ) : NEW_LINE INDENT K = [ [ 0 for w in range ( W + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for w in range ( W + 1 ) : NEW_LINE INDENT if i == 0 or w == 0 : NEW_LINE INDENT K [ i ] [ w ] = 0 NEW_LINE DEDENT elif wt [ i - 1 ] <= w : NEW_LINE INDENT K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) NEW_LINE DEDENT else : NEW_LINE INDENT K [ i ] [ w ] = K [ i - 1 ] [ w ] NEW_LINE DEDENT DEDENT DEDENT res = K [ n ] [ W ] NEW_LINE print ( res ) NEW_LINE w = W NEW_LINE for i in range ( n , 0 , - 1 ) : NEW_LINE INDENT if res <= 0 : NEW_LINE INDENT break NEW_LINE DEDENT if res == K [ i - 1 ] [ w ] : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT print ( wt [ i - 1 ] ) NEW_LINE res = res - val [ i - 1 ] NEW_LINE w = w - wt [ i - 1 ] NEW_LINE DEDENT DEDENT DEDENT
Hyp: 
def printknapSack ( W , wt , val , n ) : NEW_LINE INDENT K = [ [ 0 for x in range ( W + 1 ) ] for x in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for w in range ( W + 1 ) : NEW_LINE INDENT if i == 0 or w == 0 : NEW_LINE INDENT K [ i ] [ w ] = 0 NEW_LINE DEDENT elif wt [ i - 1 ] <= w : NEW_LINE INDENT K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) NEW_LINE DEDENT else : NEW_LINE INDENT K [ i ] [ w ] = K [ i - 1 ] [ w ] NEW_LINE DEDENT DEDENT DEDENT res = K [ n ] [ W ] NEW_LINE print ( res ) NEW_LINE w = W NEW_LINE for i in range ( n , res > 0 ) : NEW_LINE INDENT if res == K [ i - 1 ] [ w ] : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT print ( wt [ i - 1 ] , end = " ▁ " ) NEW_LINE res = res - val [ i - 1 ] NEW_LINE w = w - wt [ i - 1 ] NEW_LINE DEDENT DEDENT DEDENT

BLEU: 91.97
Edit Sim: 73


Src: 
int getTotalNumberOfSequences ( int m , int n ) { int T [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i < m + 1 ; i ++ ) { for ( int j = 0 ; j < n + 1 ; j ++ ) { if ( i == 0 || j == 0 ) T [ i ] [ j ] = 0 ; else if ( i < j ) T [ i ] [ j ] = 0 ; else if ( j == 1 ) T [ i ] [ j ] = i ; else T [ i ] [ j ] = T [ i - 1 ] [ j ] + T [ i / 2 ] [ j - 1 ] ; } } return T [ m ] [ n ] ; }
Ref: 
def getTotalNumberOfSequences ( m , n ) : NEW_LINE INDENT T = [ [ 0 for i in range ( n + 1 ) ] for i in range ( m + 1 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if i == 0 or j == 0 : NEW_LINE INDENT T [ i ] [ j ] = 0 NEW_LINE DEDENT elif i < j : NEW_LINE INDENT T [ i ] [ j ] = 0 NEW_LINE DEDENT elif j == 1 : NEW_LINE INDENT T [ i ] [ j ] = i NEW_LINE DEDENT else : NEW_LINE INDENT T [ i ] [ j ] = T [ i - 1 ] [ j ] + T [ i // 2 ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT return T [ m ] [ n ] NEW_LINE DEDENT
Hyp: 
def getTotalNumberOfSequences ( m , n ) : NEW_LINE INDENT T = [ [ 0 for i in range ( n + 1 ) ] for j in range ( m + 1 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if ( i == 0 | j == 0 ) : NEW_LINE INDENT T [ i ] [ j ] = 0 NEW_LINE DEDENT elif ( i < j ) : NEW_LINE INDENT T [ i ] [ j ] = 0 NEW_LINE DEDENT elif ( j == 1 ) : NEW_LINE INDENT T [ i ] [ j ] = i NEW_LINE DEDENT else : NEW_LINE INDENT T [ i ] [ j ] = T [ i - 1 ] [ j ] + T [ i // 2 ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT return T [ m ] [ n ] NEW_LINE DEDENT

BLEU: 88.07
Edit Sim: 15


Src: 
int findSum ( int n ) { int arr [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) arr [ i ] [ j ] = abs ( i - j ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) sum += arr [ i ] [ j ] ; return sum ; }
Ref: 
def findSum ( n ) : NEW_LINE INDENT arr = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT arr [ i ] [ j ] = abs ( i - j ) NEW_LINE DEDENT DEDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT sum += arr [ i ] [ j ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
Hyp: 
def findSum ( n ) : NEW_LINE INDENT arr = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT arr [ i ] [ j ] = abs ( i - j ) NEW_LINE DEDENT DEDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT sum += arr [ i ] [ j ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT

BLEU: 95.26
Edit Sim: 2


Src: 
string replace ( string s , char c1 , char c2 ) { int l = s . length ( ) ; for ( int i = 0 ; i < l ; i ++ ) { if ( s [ i ] == c1 ) s [ i ] = c2 ; else if ( s [ i ] == c2 ) s [ i ] = c1 ; } return s ; }
Ref: 
def replace ( s , c1 , c2 ) : NEW_LINE INDENT l = len ( s ) NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( s [ i ] == c1 ) : NEW_LINE INDENT s = s [ 0 : i ] + c2 + s [ i + 1 : ] NEW_LINE DEDENT elif ( s [ i ] == c2 ) : NEW_LINE INDENT s = s [ 0 : i ] + c1 + s [ i + 1 : ] NEW_LINE DEDENT DEDENT return s NEW_LINE DEDENT
Hyp: 
def replace ( s , c1 , c2 ) : NEW_LINE INDENT l = len ( s ) NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( s [ i ] == c1 ) : NEW_LINE INDENT s [ i ] = c2 NEW_LINE DEDENT elif ( s [ i ] == c2 ) : NEW_LINE INDENT s [ i ] = c1 NEW_LINE DEDENT DEDENT return s NEW_LINE DEDENT

BLEU: 63.56
Edit Sim: 50


Src: 
int discreteLogarithm ( int a , int b , int m ) { int n = ( int ) sqrt ( m ) + 1 ; int an = 1 ; for ( int i = 0 ; i < n ; ++ i ) an = ( an * a ) % m ; unordered_map < int , int > value ; for ( int i = 1 , cur = an ; i <= n ; ++ i ) { if ( ! value [ cur ] ) value [ cur ] = i ; cur = ( cur * an ) % m ; } for ( int i = 0 , cur = b ; i <= n ; ++ i ) { if ( value [ cur ] ) { int ans = value [ cur ] * n - i ; if ( ans < m ) return ans ; } cur = ( cur * a ) % m ; } return - 1 ; }
Ref: 
def discreteLogarithm ( a , b , m ) : NEW_LINE INDENT n = int ( math . sqrt ( m ) + 1 ) NEW_LINE an = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT an = ( an * a ) % m NEW_LINE DEDENT value = [ 0 ] * m NEW_LINE cur = an NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( value [ cur ] == 0 ) : NEW_LINE INDENT value [ cur ] = i NEW_LINE DEDENT cur = ( cur * an ) % m NEW_LINE DEDENT cur = b NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT if ( value [ cur ] > 0 ) : NEW_LINE INDENT ans = value [ cur ] * n - i NEW_LINE if ( ans < m ) : NEW_LINE INDENT return ans NEW_LINE DEDENT DEDENT cur = ( cur * a ) % m NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
Hyp: 
def discreteLogarithm ( a , b , m ) : NEW_LINE INDENT n = ( int ) ( math . sqrt ( m ) + 1 ) NEW_LINE an = 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT an = ( an * a ) % m NEW_LINE DEDENT value = dict ( ) NEW_LINE for i in range ( 1 , an + 1 ) : NEW_LINE INDENT if ( value [ cur ] == 0 ) : NEW_LINE INDENT value [ cur ] = i NEW_LINE DEDENT cur = ( cur * an ) % m NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( value [ cur ] != 0 ) : NEW_LINE INDENT ans = value [ cur ] * n - i NEW_LINE if ( ans < m ) : NEW_LINE INDENT return ans NEW_LINE DEDENT DEDENT cur = ( cur * a ) % m NEW_LINE DEDENT return - 1 NEW_LINE DEDENT

BLEU: 86.1
Edit Sim: 56


Src: 
long long maxPrimeFactors ( long long n ) { long long maxPrime = - 1 ; while ( n % 2 == 0 ) { maxPrime = 2 ; n >>= 1 ; } for ( int i = 3 ; i <= sqrt ( n ) ; i += 2 ) { while ( n % i == 0 ) { maxPrime = i ; n = n / i ; } } if ( n > 2 ) maxPrime = n ; return maxPrime ; }
Ref: 
def maxPrimeFactors ( n ) : NEW_LINE INDENT maxPrime = - 1 NEW_LINE while n % 2 == 0 : NEW_LINE INDENT maxPrime = 2 NEW_LINE n >>= 1 NEW_LINE DEDENT for i in range ( 3 , int ( math . sqrt ( n ) ) + 1 , 2 ) : NEW_LINE INDENT while n % i == 0 : NEW_LINE INDENT maxPrime = i NEW_LINE n = n / i NEW_LINE DEDENT DEDENT if n > 2 : NEW_LINE INDENT maxPrime = n NEW_LINE DEDENT return int ( maxPrime ) NEW_LINE DEDENT
Hyp: 
def maxPrimeFactors ( n ) : NEW_LINE INDENT maxPrime = - 1 NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT maxPrime = 2 NEW_LINE n >>= 1 NEW_LINE DEDENT for i in range ( 3 , int ( math . sqrt ( n ) + 2 ) ) : NEW_LINE INDENT while ( n % i == 0 ) : NEW_LINE INDENT maxPrime = i NEW_LINE n = n / i NEW_LINE DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT maxPrime = n NEW_LINE DEDENT return maxPrime NEW_LINE DEDENT

BLEU: 79.18
Edit Sim: 26


Src: 
bool isPossibleTriangle ( int arr [ ] , int N ) { if ( N < 3 ) return false ; sort ( arr , arr + N ) ; for ( int i = 0 ; i < N - 2 ; i ++ ) if ( arr [ i ] + arr [ i + 1 ] > arr [ i + 2 ] ) return true ; }
Ref: 
def isPossibleTriangle ( arr , N ) : NEW_LINE INDENT if N < 3 : NEW_LINE INDENT return False NEW_LINE DEDENT arr . sort ( ) NEW_LINE for i in range ( N - 2 ) : NEW_LINE INDENT if arr [ i ] + arr [ i + 1 ] > arr [ i + 2 ] : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT
Hyp: 
def isPossibleTriangle ( arr , N ) : NEW_LINE INDENT if ( N < 3 ) : NEW_LINE INDENT return False NEW_LINE DEDENT arr . sort ( ) NEW_LINE for i in range ( 0 , N - 2 ) : NEW_LINE INDENT if ( arr [ i ] + arr [ i + 1 ] > arr [ i + 2 ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT

BLEU: 81.18
Edit Sim: 12


Src: 
int numOfIncSubseqOfSizeK ( int arr [ ] , int n , int k ) { int dp [ k ] [ n ] , sum = 0 ; memset ( dp , 0 , sizeof ( dp ) ) ; for ( int i = 0 ; i < n ; i ++ ) dp [ 0 ] [ i ] = 1 ; for ( int l = 1 ; l < k ; l ++ ) { for ( int i = l ; i < n ; i ++ ) { dp [ l ] [ i ] = 0 ; for ( int j = l - 1 ; j < i ; j ++ ) { if ( arr [ j ] < arr [ i ] ) dp [ l ] [ i ] += dp [ l - 1 ] [ j ] ; } } } for ( int i = k - 1 ; i < n ; i ++ ) sum += dp [ k - 1 ] [ i ] ; return sum ; }
Ref: 
def numOfIncSubseqOfSizeK ( arr , n , k ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n ) ] for i in range ( k ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp [ 0 ] [ i ] = 1 NEW_LINE DEDENT for l in range ( 1 , k ) : NEW_LINE INDENT for i in range ( l , n ) : NEW_LINE INDENT dp [ l ] [ i ] = 0 NEW_LINE for j in range ( l - 1 , i ) : NEW_LINE INDENT if ( arr [ j ] < arr [ i ] ) : NEW_LINE INDENT dp [ l ] [ i ] += dp [ l - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT DEDENT Sum = 0 NEW_LINE for i in range ( k - 1 , n ) : NEW_LINE INDENT Sum += dp [ k - 1 ] [ i ] NEW_LINE DEDENT return Sum NEW_LINE DEDENT
Hyp: 
def numOfIncSubseqOfSizeK ( arr , n , k ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( k ) ] for j in range ( k ) ] NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp [ 0 ] [ i ] = 1 NEW_LINE DEDENT for l in range ( 1 , k ) : NEW_LINE INDENT for i in range ( l , n ) : NEW_LINE INDENT dp [ l ] [ i ] = 0 NEW_LINE for j in range ( l - 1 , i ) : NEW_LINE INDENT if arr [ j ] < arr [ i ] : NEW_LINE INDENT dp [ l ] [ i ] += dp [ l - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT DEDENT for i in range ( k - 1 , n ) : NEW_LINE INDENT sum += dp [ k - 1 ] [ i ] NEW_LINE DEDENT return sum NEW_LINE DEDENT

BLEU: 89.08
Edit Sim: 42


Src: 
int solve ( char X [ ] , char Y [ ] , int l , int r , int k , int dp [ ] [ N ] [ N ] ) { if ( ! k ) return 0 ; if ( l < 0 | r < 0 ) return 1e9 ; if ( dp [ l ] [ r ] [ k ] != - 1 ) return dp [ l ] [ r ] [ k ] ; int cost = ( X [ l ] - ' a ' ) ^ ( Y [ r ] - ' a ' ) ; return dp [ l ] [ r ] [ k ] = min ( { cost + solve ( X , Y , l - 1 , r - 1 , k - 1 , dp ) , solve ( X , Y , l - 1 , r , k , dp ) , solve ( X , Y , l , r - 1 , k , dp ) } ) ; }
Ref: 
def solve ( X , Y , l , r , k , dp ) : NEW_LINE INDENT if k == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if l < 0 or r < 0 : NEW_LINE INDENT return 1000000000 NEW_LINE DEDENT if dp [ l ] [ r ] [ k ] != - 1 : NEW_LINE INDENT return dp [ l ] [ r ] [ k ] NEW_LINE DEDENT cost = ( ( ord ( X [ l ] ) - ord ( ' a ' ) ) ^ ( ord ( Y [ r ] ) - ord ( ' a ' ) ) ) NEW_LINE dp [ l ] [ r ] [ k ] = min ( [ cost + solve ( X , Y , l - 1 , r - 1 , k - 1 , dp ) , solve ( X , Y , l - 1 , r , k , dp ) , solve ( X , Y , l , r - 1 , k , dp ) ] ) NEW_LINE return dp [ l ] [ r ] [ k ] NEW_LINE DEDENT
Hyp: 
def solve ( X , Y , l , r , k , dp ) : NEW_LINE INDENT if ( k == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( l < 0 | r < 0 ) : NEW_LINE INDENT return 1e9 NEW_LINE DEDENT if ( dp [ l ] [ r ] [ k ] != - 1 ) : NEW_LINE INDENT return dp [ l ] [ r ] [ k ] NEW_LINE DEDENT cost = ( X [ l ] - ord ( ' a ' ) ) ^ ( Y [ r ] - ord ( ' a ' ) ) NEW_LINE return dp [ l ] [ r ] [ k ] NEW_LINE DEDENT dp [ l ] [ r ] [ k ] = min ( { cost + solve ( X , Y , l - 1 , r - 1 , k - 1 , dp ) , solve ( X , Y , l - 1 , r , k , dp ) , solve ( X , Y , l , r - 1 , k , dp ) } ) NEW_LINE return dp [ l ] [ r ] [ k ] NEW_LINE DEDENT

BLEU: 79.15
Edit Sim: 82


Src: 
int remainderWith7 ( string num ) { int series [ ] = { 1 , 3 , 2 , - 1 , - 3 , - 2 } ; int series_index = 0 ; int result = 0 ; for ( int i = num . size ( ) - 1 ; i >= 0 ; i -- ) { int digit = num [ i ] - '0' ; result += digit * series [ series_index ] ; series_index = ( series_index + 1 ) % 6 ; result %= 7 ; } if ( result < 0 ) result = ( result + 7 ) % 7 ; return result ; }
Ref: 
def remainderWith7 ( num ) : NEW_LINE INDENT series = [ 1 , 3 , 2 , - 1 , - 3 , - 2 ] NEW_LINE series_index = 0 NEW_LINE result = 0 NEW_LINE for i in range ( ( len ( num ) - 1 ) , - 1 , - 1 ) : NEW_LINE INDENT digit = ord ( num [ i ] ) - 48 NEW_LINE result += digit * series [ series_index ] NEW_LINE series_index = ( series_index + 1 ) % 6 NEW_LINE result %= 7 NEW_LINE DEDENT if ( result < 0 ) : NEW_LINE INDENT result = ( result + 7 ) % 7 NEW_LINE DEDENT return result NEW_LINE DEDENT
Hyp: 
def remainderWith7 ( num ) : NEW_LINE INDENT series = [ 1 , 3 , 2 , - 1 , - 3 , - 2 ] NEW_LINE series_index = 0 NEW_LINE result = 0 NEW_LINE i = len ( num ) - 1 NEW_LINE while i >= 0 : NEW_LINE INDENT digit = ord ( num [ i ] ) - ord ( '0' ) NEW_LINE result += digit * series [ series_index ] NEW_LINE series_index = ( series_index + 1 ) % 6 NEW_LINE result %= 7 NEW_LINE DEDENT if ( result < 0 ) : NEW_LINE INDENT result = ( result + 7 ) % 7 NEW_LINE DEDENT return result NEW_LINE DEDENT

BLEU: 83.88
Edit Sim: 44


Src: 
bool isSubSequence ( char str1 [ ] , char str2 [ ] , int m , int n ) { if ( m == 0 ) return true ; if ( n == 0 ) return false ; if ( str1 [ m - 1 ] == str2 [ n - 1 ] ) return isSubSequence ( str1 , str2 , m - 1 , n - 1 ) ; return isSubSequence ( str1 , str2 , m , n - 1 ) ; }
Ref: 
def isSubSequence ( string1 , string2 , m , n ) : NEW_LINE INDENT if m == 0 : return True NEW_LINE if n == 0 : return False NEW_LINE if string1 [ m - 1 ] == string2 [ n - 1 ] : NEW_LINE INDENT return isSubSequence ( string1 , string2 , m - 1 , n - 1 ) NEW_LINE DEDENT return isSubSequence ( string1 , string2 , m , n - 1 ) NEW_LINE DEDENT
Hyp: 
def isSubSequence ( str1 , str2 , m , n ) : NEW_LINE INDENT if ( m == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( str1 [ m - 1 ] == str2 [ n - 1 ] ) : NEW_LINE INDENT return isSubSequence ( str1 , str2 , m - 1 , n - 1 ) NEW_LINE DEDENT return isSubSequence ( str1 , str2 , m , n - 1 ) NEW_LINE DEDENT

BLEU: 53.15
Edit Sim: 82


Src: 
int getRemainder ( int num , int divisor ) { return ( num - divisor * ( num / divisor ) ) ; }
Ref: 
def getRemainder ( num , divisor ) : NEW_LINE INDENT return ( num - divisor * ( num // divisor ) ) NEW_LINE DEDENT
Hyp: 
def getRemainder ( num , divisor ) : NEW_LINE INDENT return ( num - divisor * ( num / divisor ) ) NEW_LINE DEDENT

BLEU: 88.95
Edit Sim: 1


Src: 
int minProductSubset ( int a [ ] , int n ) { if ( n == 1 ) return a [ 0 ] ; int max_neg = INT_MIN ; int min_pos = INT_MAX ; int count_neg = 0 , count_zero = 0 ; int prod = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) { count_zero ++ ; continue ; } if ( a [ i ] < 0 ) { count_neg ++ ; max_neg = max ( max_neg , a [ i ] ) ; } if ( a [ i ] > 0 ) min_pos = min ( min_pos , a [ i ] ) ; prod = prod * a [ i ] ; } if ( count_zero == n || ( count_neg == 0 && count_zero > 0 ) ) return 0 ; if ( count_neg == 0 ) return min_pos ; if ( ! ( count_neg & 1 ) && count_neg != 0 ) { prod = prod / max_neg ; } return prod ; }
Ref: 
def minProductSubset ( a , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return a [ 0 ] NEW_LINE DEDENT max_neg = float ( ' - inf ' ) NEW_LINE min_pos = float ( ' inf ' ) NEW_LINE count_neg = 0 NEW_LINE count_zero = 0 NEW_LINE prod = 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( a [ i ] == 0 ) : NEW_LINE INDENT count_zero = count_zero + 1 NEW_LINE continue NEW_LINE DEDENT if ( a [ i ] < 0 ) : NEW_LINE INDENT count_neg = count_neg + 1 NEW_LINE max_neg = max ( max_neg , a [ i ] ) NEW_LINE DEDENT if ( a [ i ] > 0 ) : NEW_LINE INDENT min_pos = min ( min_pos , a [ i ] ) NEW_LINE DEDENT prod = prod * a [ i ] NEW_LINE DEDENT if ( count_zero == n or ( count_neg == 0 and count_zero > 0 ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( count_neg == 0 ) : NEW_LINE INDENT return min_pos NEW_LINE DEDENT if ( ( count_neg & 1 ) == 0 and count_neg != 0 ) : NEW_LINE INDENT prod = int ( prod / max_neg ) NEW_LINE DEDENT return prod NEW_LINE DEDENT
Hyp: 
def minProductSubset ( a , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return a [ 0 ] NEW_LINE DEDENT max_neg = - 2147483647 NEW_LINE min_pos = 2147483647 NEW_LINE count_neg = 0 NEW_LINE count_zero = 0 NEW_LINE prod = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == 0 ) : NEW_LINE INDENT count_zero += 1 NEW_LINE continue NEW_LINE DEDENT if ( a [ i ] < 0 ) : NEW_LINE INDENT count_neg += 1 NEW_LINE max_neg = max ( max_neg , a [ i ] ) NEW_LINE DEDENT if ( a [ i ] > 0 ) : NEW_LINE INDENT min_pos = min ( min_pos , a [ i ] ) NEW_LINE DEDENT prod = prod * a [ i ] NEW_LINE DEDENT if ( count_zero == n or ( count_neg == 0 and count_zero > 0 ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( count_neg == 0 ) : NEW_LINE INDENT return min_pos NEW_LINE DEDENT if ( not ( count_neg & 1 ) and count_neg != 0 ) : NEW_LINE INDENT prod = prod / max_neg NEW_LINE DEDENT return prod NEW_LINE DEDENT

BLEU: 81.84
Edit Sim: 83


Src: 
public : int getSum ( int n ) { int sum = 0 ; while ( n != 0 ) { sum = sum + n % 10 ; n = n / 10 ; } return sum ; }
Ref: 
def getSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT sum = sum + int ( n % 10 ) NEW_LINE n = int ( n / 10 ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
Hyp: 
def getSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT sum = sum + int ( n % 10 ) NEW_LINE n = int ( n / 10 ) NEW_LINE DEDENT return sum NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int findDigits ( int n ) { if ( n < 0 ) return 0 ; if ( n <= 1 ) return 1 ; double digits = 0 ; for ( int i = 2 ; i <= n ; i ++ ) digits += log10 ( i ) ; return floor ( digits ) + 1 ; }
Ref: 
def findDigits ( n ) : NEW_LINE INDENT if ( n < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n <= 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT digits = 0 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT digits += math . log10 ( i ) NEW_LINE DEDENT return math . floor ( digits ) + 1 NEW_LINE DEDENT
Hyp: 
def findDigits ( n ) : NEW_LINE INDENT if ( n < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n <= 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT digits = 0 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT digits += math . log10 ( i ) NEW_LINE DEDENT return math . floor ( digits ) + 1 NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
void mergeTwoHalf ( int A [ ] , int n ) { sort ( A , A + n ) ; }
Ref: 
def mergeTwoHalf ( A , n ) : NEW_LINE INDENT A . sort ( ) NEW_LINE DEDENT
Hyp: 
def mergeTwoHalf ( A , n ) : NEW_LINE INDENT A . sort ( ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
void fill0X ( int m , int n ) { int i , k = 0 , l = 0 ; int r = m , c = n ; char a [ m ] [ n ] ; char x = ' X ' ; while ( k < m && l < n ) { for ( i = l ; i < n ; ++ i ) a [ k ] [ i ] = x ; k ++ ; for ( i = k ; i < m ; ++ i ) a [ i ] [ n - 1 ] = x ; n -- ; if ( k < m ) { for ( i = n - 1 ; i >= l ; -- i ) a [ m - 1 ] [ i ] = x ; m -- ; } if ( l < n ) { for ( i = m - 1 ; i >= k ; -- i ) a [ i ] [ l ] = x ; l ++ ; } x = ( x == '0' ) ? ' X ' : '0' ; } for ( i = 0 ; i < r ; i ++ ) { for ( int j = 0 ; j < c ; j ++ ) printf ( " % c ▁ " , a [ i ] [ j ] ) ; printf ( " \n " ) ; } }
Ref: 
def fill0X ( m , n ) : NEW_LINE INDENT i , k , l = 0 , 0 , 0 NEW_LINE r = m NEW_LINE c = n NEW_LINE a = [ [ None ] * n for i in range ( m ) ] NEW_LINE x = ' X ' NEW_LINE while k < m and l < n : NEW_LINE INDENT for i in range ( l , n ) : NEW_LINE INDENT a [ k ] [ i ] = x NEW_LINE DEDENT k += 1 NEW_LINE for i in range ( k , m ) : NEW_LINE INDENT a [ i ] [ n - 1 ] = x NEW_LINE DEDENT n -= 1 NEW_LINE if k < m : NEW_LINE INDENT for i in range ( n - 1 , l - 1 , - 1 ) : NEW_LINE INDENT a [ m - 1 ] [ i ] = x NEW_LINE DEDENT m -= 1 NEW_LINE DEDENT if l < n : NEW_LINE INDENT for i in range ( m - 1 , k - 1 , - 1 ) : NEW_LINE INDENT a [ i ] [ l ] = x NEW_LINE DEDENT l += 1 NEW_LINE DEDENT x = ' X ' if x == '0' else '0' NEW_LINE DEDENT for i in range ( r ) : NEW_LINE INDENT for j in range ( c ) : NEW_LINE INDENT print ( a [ i ] [ j ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT
Hyp: 
def fill0X ( m , n ) : NEW_LINE INDENT k = 0 l = 0 NEW_LINE r = m NEW_LINE c = n NEW_LINE a = [ [ 0 for i in range ( n ) ] for j in range ( m ) ] NEW_LINE x = ' X ' NEW_LINE while ( k < m and l < n ) : NEW_LINE INDENT for i in range ( l , n ) : NEW_LINE INDENT a [ k ] [ i ] = x NEW_LINE DEDENT k += 1 NEW_LINE for i in range ( k , m ) : NEW_LINE INDENT a [ i ] [ n - 1 ] = x NEW_LINE DEDENT n -= 1 NEW_LINE if ( k < m ) : NEW_LINE INDENT for i in range ( n - 1 , l - 1 , - 1 ) : NEW_LINE INDENT a [ m - 1 ] [ i ] = x NEW_LINE DEDENT m -= 1 NEW_LINE DEDENT if ( l < n ) : NEW_LINE INDENT for i in range ( m - 1 , k - 1 , - 1 ) : NEW_LINE INDENT a [ i ] [ l ] = x NEW_LINE DEDENT l += 1 NEW_LINE DEDENT x = ( x == '0' ) ? ' X ' : '0' ) NEW_LINE DEDENT for i in range ( r ) : NEW_LINE INDENT for j in range ( c ) : NEW_LINE INDENT print ( a [ i ] [ j ] , end = " " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT

BLEU: 84.51
Edit Sim: 63


Src: 
int minPerimeter ( int n ) { int l = sqrt ( n ) ; int sq = l * l ; if ( sq == n ) return l * 4 ; else { long long int row = n / l ; long long int perimeter = 2 * ( l + row ) ; if ( n % l != 0 ) perimeter += 2 ; return perimeter ; } }
Ref: 
def minPerimeter ( n ) : NEW_LINE INDENT l = math . sqrt ( n ) NEW_LINE sq = l * l NEW_LINE if ( sq == n ) : NEW_LINE INDENT return l * 4 NEW_LINE DEDENT else : NEW_LINE INDENT row = n / l NEW_LINE perimeter = 2 * ( l + row ) NEW_LINE if ( n % l != 0 ) : NEW_LINE INDENT perimeter += 2 NEW_LINE DEDENT return perimeter NEW_LINE DEDENT DEDENT
Hyp: 
def minPerimeter ( n ) : NEW_LINE INDENT l = int ( math . sqrt ( n ) ) NEW_LINE sq = l * l NEW_LINE if ( sq == n ) : NEW_LINE INDENT return l * 4 NEW_LINE DEDENT else : NEW_LINE INDENT row = n / l NEW_LINE perimeter = 2 * ( l + row ) NEW_LINE if ( n % l != 0 ) : NEW_LINE INDENT perimeter += 2 NEW_LINE DEDENT return perimeter NEW_LINE DEDENT

BLEU: 93.41
Edit Sim: 15


Src: 
void possibleOrNot ( long long a1 , long long a2 , long long b1 , long long b2 , long long c1 , long long c2 ) { long long dis1 = pow ( b1 - a1 , 2 ) + pow ( b2 - a2 , 2 ) ; long long dis2 = pow ( c1 - b1 , 2 ) + pow ( c2 - b2 , 2 ) ; if ( dis1 != dis2 ) cout << " No " ; else if ( b1 == ( ( a1 + c1 ) / 2.0 ) && b2 == ( ( a2 + c2 ) / 2.0 ) ) cout << " No " ; else cout << " Yes " ; }
Ref: 
def possibleOrNot ( a1 , a2 , b1 , b2 , c1 , c2 ) : NEW_LINE INDENT dis1 = ( pow ( b1 - a1 , 2 ) + pow ( b2 - a2 , 2 ) ) NEW_LINE dis2 = ( pow ( c1 - b1 , 2 ) + pow ( c2 - b2 , 2 ) ) NEW_LINE if ( dis1 != dis2 ) : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT elif ( b1 == ( ( a1 + c1 ) // 2.0 ) and b2 == ( ( a2 + c2 ) // 2.0 ) ) : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT DEDENT
Hyp: 
def possibleOrNot ( a1 , a2 , b1 , b2 , c1 , c2 ) : NEW_LINE INDENT dis1 = pow ( b1 - a1 , 2 ) + pow ( b2 - a2 , 2 ) NEW_LINE dis2 = pow ( c1 - b1 , 2 ) + pow ( c2 - b2 , 2 ) NEW_LINE if ( dis1 != dis2 ) : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT elif ( b1 == ( ( a1 + c1 ) // 2.0 ) and b2 == ( ( a2 + c2 ) // 2.0 ) ) : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT DEDENT

BLEU: 93.27
Edit Sim: 8


Src: 
float slope ( float x1 , float y1 , float x2 , float y2 ) { return ( y2 - y1 ) / ( x2 - x1 ) ; }
Ref: 
def slope ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT return ( float ) ( y2 - y1 ) / ( x2 - x1 ) NEW_LINE DEDENT
Hyp: 
def slope ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT return ( y2 - y1 ) / ( x2 - x1 ) NEW_LINE DEDENT

BLEU: 87.23
Edit Sim: 10


Src: 
int countSquares ( int a , int b ) { return ( floor ( sqrt ( b ) ) - ceil ( sqrt ( a ) ) + 1 ) ; }
Ref: 
def CountSquares ( a , b ) : NEW_LINE INDENT return ( math . floor ( math . sqrt ( b ) ) - math . ceil ( math . sqrt ( a ) ) + 1 ) NEW_LINE DEDENT
Hyp: 
def countSquares ( a , b ) : NEW_LINE INDENT return ( math . floor ( math . sqrt ( b ) ) - math . ceil ( math . sqrt ( a ) ) + 1 ) NEW_LINE DEDENT

BLEU: 95.54
Edit Sim: 1


Src: 
int countStrings ( int n , int k ) { int dp [ n + 1 ] [ k + 1 ] [ 2 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; dp [ 1 ] [ 0 ] [ 0 ] = 1 ; dp [ 1 ] [ 0 ] [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { dp [ i ] [ j ] [ 0 ] = dp [ i - 1 ] [ j ] [ 0 ] + dp [ i - 1 ] [ j ] [ 1 ] ; dp [ i ] [ j ] [ 1 ] = dp [ i - 1 ] [ j ] [ 0 ] ; if ( j - 1 >= 0 ) dp [ i ] [ j ] [ 1 ] += dp [ i - 1 ] [ j - 1 ] [ 1 ] ; } } return dp [ n ] [ k ] [ 0 ] + dp [ n ] [ k ] [ 1 ] ; }
Ref: 
def countStrings ( n , k ) : NEW_LINE INDENT dp = [ [ [ 0 , 0 ] for __ in range ( k + 1 ) ] for _ in range ( n + 1 ) ] NEW_LINE dp [ 1 ] [ 0 ] [ 0 ] = 1 NEW_LINE dp [ 1 ] [ 0 ] [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT for j in range ( k + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] [ 0 ] = ( dp [ i - 1 ] [ j ] [ 0 ] + dp [ i - 1 ] [ j ] [ 1 ] ) NEW_LINE dp [ i ] [ j ] [ 1 ] = dp [ i - 1 ] [ j ] [ 0 ] NEW_LINE if j >= 1 : NEW_LINE INDENT dp [ i ] [ j ] [ 1 ] += dp [ i - 1 ] [ j - 1 ] [ 1 ] NEW_LINE DEDENT DEDENT DEDENT return dp [ n ] [ k ] [ 0 ] + dp [ n ] [ k ] [ 1 ] NEW_LINE DEDENT
Hyp: 
def countStrings ( n , k ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( k + 1 ) ] for j in range ( 2 ) ] NEW_LINE dp [ 1 ] [ 0 ] [ 0 ] = 1 NEW_LINE dp [ 1 ] [ 0 ] [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT dp [ i ] [ j ] [ 0 ] = dp [ i - 1 ] [ j ] [ 0 ] + dp [ i - 1 ] [ j ] [ 1 ] NEW_LINE dp [ i ] [ j ] [ 1 ] = dp [ i - 1 ] [ j ] [ 0 ] NEW_LINE if j - 1 >= 0 : NEW_LINE INDENT dp [ i ] [ j ] [ 1 ] += dp [ i - 1 ] [ j - 1 ] [ 1 ] NEW_LINE DEDENT DEDENT DEDENT return dp [ n ] [ k ] [ 0 ] + dp [ n ] [ k ] [ 1 ] NEW_LINE DEDENT

BLEU: 87.33
Edit Sim: 30


Src: 
void findSmallestRange ( int arr [ ] [ N ] , int n , int k ) { int i , minval , maxval , minrange , minel , maxel , flag , minind ; for ( i = 0 ; i <= k ; i ++ ) ptr [ i ] = 0 ; minrange = INT_MAX ; while ( 1 ) { minind = - 1 ; minval = INT_MAX ; maxval = INT_MIN ; flag = 0 ; for ( i = 0 ; i < k ; i ++ ) { if ( ptr [ i ] == n ) { flag = 1 ; break ; } if ( ptr [ i ] < n && arr [ i ] [ ptr [ i ] ] < minval ) { minind = i ; minval = arr [ i ] [ ptr [ i ] ] ; } if ( ptr [ i ] < n && arr [ i ] [ ptr [ i ] ] > maxval ) { maxval = arr [ i ] [ ptr [ i ] ] ; } } if ( flag ) break ; ptr [ minind ] ++ ; if ( ( maxval - minval ) < minrange ) { minel = minval ; maxel = maxval ; minrange = maxel - minel ; } } printf ( " The ▁ smallest ▁ range ▁ is ▁ [ % d ▁ , ▁ % d ] \n " , minel , maxel ) ; }
Ref: 
def findSmallestRange ( arr , n , k ) : NEW_LINE INDENT i , minval , maxval , minrange , minel , maxel , flag , minind = 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 NEW_LINE for i in range ( k + 1 ) : NEW_LINE INDENT ptr [ i ] = 0 NEW_LINE DEDENT minrange = 10 ** 9 NEW_LINE while ( 1 ) : NEW_LINE INDENT minind = - 1 NEW_LINE minval = 10 ** 9 NEW_LINE maxval = - 10 ** 9 NEW_LINE flag = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT if ( ptr [ i ] == n ) : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT if ( ptr [ i ] < n and arr [ i ] [ ptr [ i ] ] < minval ) : NEW_LINE INDENT minind = i NEW_LINE minval = arr [ i ] [ ptr [ i ] ] NEW_LINE DEDENT if ( ptr [ i ] < n and arr [ i ] [ ptr [ i ] ] > maxval ) : NEW_LINE INDENT maxval = arr [ i ] [ ptr [ i ] ] NEW_LINE DEDENT DEDENT if ( flag ) : NEW_LINE INDENT break NEW_LINE DEDENT ptr [ minind ] += 1 NEW_LINE if ( ( maxval - minval ) < minrange ) : NEW_LINE INDENT minel = minval NEW_LINE maxel = maxval NEW_LINE minrange = maxel - minel NEW_LINE DEDENT DEDENT print ( " The ▁ smallest ▁ range ▁ is ▁ [ " , minel , maxel , " ] " ) NEW_LINE DEDENT
Hyp: 
def findSmallestRange ( arr , n , k ) : NEW_LINE INDENT ptr = [ 0 ] * k NEW_LINE minrange = sys . maxsize NEW_LINE while ( 1 ) : NEW_LINE INDENT minind = - 1 NEW_LINE minval = sys . maxsize NEW_LINE maxval = sys . maxsize NEW_LINE flag = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT if ( ptr [ i ] == n ) : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT if ( ptr [ i ] < n and arr [ i ] [ ptr [ i ] ] < minval ) : NEW_LINE INDENT minind = i NEW_LINE minval = arr [ i ] [ ptr [ i ] ] NEW_LINE DEDENT if ( ptr [ i ] < n and arr [ i ] [ ptr [ i ] ] > maxval ) : NEW_LINE INDENT maxval = arr [ i ] [ ptr [ i ] ] NEW_LINE DEDENT DEDENT if ( flag ) : NEW_LINE INDENT break NEW_LINE DEDENT ptr [ minind ] += 1 NEW_LINE if ( ( maxval - minval ) < minrange ) : NEW_LINE INDENT minel = minval NEW_LINE maxel = maxval NEW_LINE minrange = maxel - minel NEW_LINE DEDENT DEDENT print ( " The ▁ smallest ▁ range ▁ is ▁ [ % d ▁ , % d ] " , minel , maxel ) NEW_LINE DEDENT

BLEU: 73.42
Edit Sim: 205


Src: 
string lexicographicSubConcat ( string s ) { int n = s . length ( ) ; int sub_count = n * ( n + 1 ) / 2 ; string arr [ sub_count ] ; int index = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int len = 1 ; len <= n - i ; len ++ ) arr [ index ++ ] = s . substr ( i , len ) ; sort ( arr , arr + sub_count ) ; string res = " " ; for ( int i = 0 ; i < sub_count ; i ++ ) res += arr [ i ] ; return res ; }
Ref: 
def lexicographicSubConcat ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE sub_count = ( n * ( n + 1 ) ) // 2 NEW_LINE arr = [ 0 ] * sub_count NEW_LINE index = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( 1 , n - i + 1 ) : NEW_LINE INDENT arr [ index ] = s [ i : i + j ] NEW_LINE index += 1 NEW_LINE DEDENT DEDENT arr . sort ( ) NEW_LINE res = " " NEW_LINE for i in range ( sub_count ) : NEW_LINE INDENT res += arr [ i ] NEW_LINE DEDENT return res NEW_LINE DEDENT
Hyp: 
def lexicographicSubConcat ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE sub_count = int ( ( n + 1 ) / 2 ) NEW_LINE arr = [ None ] * ( sub_count + 1 ) NEW_LINE index = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for len in range ( 1 , n - i + 1 ) : NEW_LINE INDENT arr [ index ] = s [ i , len ] NEW_LINE index += 1 NEW_LINE DEDENT DEDENT arr . sort ( ) NEW_LINE res = " " NEW_LINE for i in range ( 0 , sub_count ) : NEW_LINE INDENT res += arr [ i ] NEW_LINE DEDENT return res NEW_LINE DEDENT

BLEU: 77.12
Edit Sim: 37


Src: 
void maxelement ( int no_of_rows , int arr [ ] [ N ] ) { int i = 0 ; int max = 0 ; int result [ no_of_rows ] ; while ( i < no_of_rows ) { for ( int j = 0 ; j < N ; j ++ ) { if ( arr [ i ] [ j ] > max ) { max = arr [ i ] [ j ] ; } } result [ i ] = max ; max = 0 ; i ++ ; } printArray ( result , no_of_rows ) ; }
Ref: 
def maxelement ( arr ) : NEW_LINE INDENT no_of_rows = len ( arr ) NEW_LINE no_of_column = len ( arr [ 0 ] ) NEW_LINE for i in range ( no_of_rows ) : NEW_LINE INDENT max1 = 0 NEW_LINE for j in range ( no_of_column ) : NEW_LINE INDENT if arr [ i ] [ j ] > max1 : NEW_LINE INDENT max1 = arr [ i ] [ j ] NEW_LINE DEDENT DEDENT print ( max1 ) NEW_LINE DEDENT DEDENT
Hyp: 
def maxelement ( no_of_rows , arr ) : NEW_LINE INDENT i = 0 NEW_LINE max = 0 NEW_LINE result = [ 0 ] * ( no_of_rows ) NEW_LINE while ( i < no_of_rows ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if ( arr [ i ] [ j ] > max ) : NEW_LINE INDENT max = arr [ i ] [ j ] NEW_LINE DEDENT DEDENT result [ i ] = max NEW_LINE max = 0 NEW_LINE i += 1 NEW_LINE DEDENT printArray ( result , no_of_rows ) NEW_LINE DEDENT

BLEU: 40.63
Edit Sim: 197


Src: 
int countNegative ( int M [ ] [ 4 ] , int n , int m ) { int count = 0 ; int i = 0 ; int j = m - 1 ; while ( j >= 0 && i < n ) { if ( M [ i ] [ j ] < 0 ) { count += j + 1 ; i += 1 ; } else j -= 1 ; } return count ; }
Ref: 
def countNegative ( M , n , m ) : NEW_LINE INDENT count = 0 NEW_LINE i = 0 NEW_LINE j = m - 1 NEW_LINE while j >= 0 and i < n : NEW_LINE INDENT if M [ i ] [ j ] < 0 : NEW_LINE INDENT count += ( j + 1 ) NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
Hyp: 
def countNegative ( M , n , m ) : NEW_LINE INDENT count = 0 NEW_LINE i = 0 NEW_LINE j = m - 1 NEW_LINE while ( j >= 0 and i < n ) : NEW_LINE INDENT if ( M [ i ] [ j ] < 0 ) : NEW_LINE INDENT count += j + 1 NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT

BLEU: 83.69
Edit Sim: 12


Src: 
int findpos ( string n ) { int i = 0 , pos = 0 ; while ( n [ i ] != ' \0' ) { switch ( n [ i ] ) { case '4' : pos = pos * 2 + 1 ; break ; case '7' : pos = pos * 2 + 2 ; break ; } i ++ ; } return pos ; }
Ref: 
def findpos ( n ) : NEW_LINE INDENT i = 0 NEW_LINE j = len ( n ) NEW_LINE pos = 0 NEW_LINE while ( i < j ) : NEW_LINE INDENT if ( n [ i ] == '4' ) : NEW_LINE INDENT pos = pos * 2 + 1 NEW_LINE DEDENT if ( n [ i ] == '7' ) : NEW_LINE INDENT pos = pos * 2 + 2 NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT return pos NEW_LINE DEDENT
Hyp: 
def findpos ( n ) : NEW_LINE INDENT i = 0 NEW_LINE pos = 0 NEW_LINE while i < len ( n ) : NEW_LINE INDENT switch n [ i ] : NEW_LINE INDENT case '4' : NEW_LINE INDENT pos = pos * 2 + 1 NEW_LINE break NEW_LINE DEDENT case '7' : NEW_LINE INDENT pos = pos * 2 + 2 NEW_LINE break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return pos NEW_LINE DEDENT

BLEU: 58.12
Edit Sim: 104


Src: 
long long int yMod ( long long int y , long long int x ) { if ( log2 ( y ) < x ) return y ; if ( x > 63 ) return y ; return ( y % ( 1 << x ) ) ; }
Ref: 
def yMod ( y , x ) : NEW_LINE INDENT return ( y % pow ( 2 , x ) ) NEW_LINE DEDENT
Hyp: 
def yMod ( y , x ) : NEW_LINE INDENT if ( math . log2 ( y ) < x ) : NEW_LINE INDENT return y NEW_LINE DEDENT if ( x > 63 ) : NEW_LINE INDENT return y NEW_LINE DEDENT return ( y % ( 1 << x ) ) NEW_LINE DEDENT

BLEU: 30.77
Edit Sim: 132


Src: 
int maxSumIS ( int arr [ ] , int n ) { int i , j , max = 0 ; int msis [ n ] ; for ( i = 0 ; i < n ; i ++ ) msis [ i ] = arr [ i ] ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && msis [ i ] < msis [ j ] + arr [ i ] ) msis [ i ] = msis [ j ] + arr [ i ] ; for ( i = 0 ; i < n ; i ++ ) if ( max < msis [ i ] ) max = msis [ i ] ; return max ; }
Ref: 
def maxSumIS ( arr , n ) : NEW_LINE INDENT max = 0 NEW_LINE msis = [ 0 for x in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT msis [ i ] = arr [ i ] NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and msis [ i ] < msis [ j ] + arr [ i ] ) : NEW_LINE INDENT msis [ i ] = msis [ j ] + arr [ i ] NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if max < msis [ i ] : NEW_LINE INDENT max = msis [ i ] NEW_LINE DEDENT DEDENT return max NEW_LINE DEDENT
Hyp: 
def maxSumIS ( arr , n ) : NEW_LINE INDENT max = 0 NEW_LINE msis = [ 0 ] * n NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT msis [ i ] = arr [ i ] NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( 0 , i ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and msis [ i ] < msis [ j ] + arr [ i ] ) : NEW_LINE INDENT msis [ i ] = msis [ j ] + arr [ i ] NEW_LINE DEDENT DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( max < msis [ i ] ) : NEW_LINE INDENT max = msis [ i ] NEW_LINE DEDENT DEDENT return max NEW_LINE DEDENT

BLEU: 87.42
Edit Sim: 35


Src: 
int maxLength ( char s [ ] , int n ) { int invalidOpenBraces = 0 ; int invalidCloseBraces = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ' ( ' ) { invalidOpenBraces ++ ; } else { if ( invalidOpenBraces == 0 ) { invalidCloseBraces ++ ; } else { invalidOpenBraces -- ; } } } return ( n - ( invalidOpenBraces + invalidCloseBraces ) ) ; }
Ref: 
def maxLength ( s , n ) : NEW_LINE INDENT invalidOpenBraces = 0 NEW_LINE invalidCloseBraces = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == ' ( ' ) : NEW_LINE INDENT invalidOpenBraces += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( invalidOpenBraces == 0 ) : NEW_LINE INDENT invalidCloseBraces += 1 NEW_LINE DEDENT else : NEW_LINE INDENT invalidOpenBraces -= 1 NEW_LINE DEDENT DEDENT DEDENT return ( n - ( invalidOpenBraces + invalidCloseBraces ) ) NEW_LINE DEDENT
Hyp: 
def maxLength ( s , n ) : NEW_LINE INDENT invalidOpenBraces = 0 NEW_LINE invalidCloseBraces = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == ' ( ' : NEW_LINE INDENT invalidOpenBraces += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if invalidOpenBraces == 0 : NEW_LINE INDENT invalidCloseBraces += 1 NEW_LINE DEDENT else : NEW_LINE INDENT invalidOpenBraces -= 1 NEW_LINE DEDENT DEDENT DEDENT return ( n - ( invalidOpenBraces + invalidCloseBraces ) ) NEW_LINE DEDENT

BLEU: 88.28
Edit Sim: 8


Src: 
ll lis ( ll arr [ ] , ll n ) { ll mpis [ n ] ; for ( int i = 0 ; i < n ; i ++ ) mpis [ i ] = arr [ i ] ; for ( int i = 1 ; i < n ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && mpis [ i ] < ( mpis [ j ] * arr [ i ] ) ) mpis [ i ] = mpis [ j ] * arr [ i ] ; return * max_element ( mpis , mpis + n ) ; }
Ref: 
def lis ( arr , n ) : NEW_LINE INDENT mpis = [ 0 ] * ( n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mpis [ i ] = arr [ i ] NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and mpis [ i ] < ( mpis [ j ] * arr [ i ] ) ) : NEW_LINE INDENT mpis [ i ] = mpis [ j ] * arr [ i ] NEW_LINE DEDENT DEDENT DEDENT return max ( mpis ) NEW_LINE DEDENT
Hyp: 
def lis ( arr , n ) : NEW_LINE INDENT mpis = [ 0 ] * n NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT mpis [ i ] = arr [ i ] NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( 0 , i ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and mpis [ i ] < ( mpis [ j ] * arr [ i ] ) ) : NEW_LINE INDENT mpis [ i ] = mpis [ j ] * arr [ i ] NEW_LINE DEDENT DEDENT DEDENT return max_element ( mpis , mpis + n ) NEW_LINE DEDENT

BLEU: 86.69
Edit Sim: 31


Src: 
bool findthepath ( char * S , int v ) { result [ 0 ] = v + '0' ; for ( int i = 1 ; S [ i ] ; i ++ ) { if ( adj [ v ] [ S [ i ] - ' A ' ] || adj [ S [ i ] - ' A ' ] [ v ] ) { v = S [ i ] - ' A ' ; } else if ( adj [ v ] [ S [ i ] - ' A ' + 5 ] || adj [ S [ i ] - ' A ' + 5 ] [ v ] ) { v = S [ i ] - ' A ' + 5 ; } else return false ; result [ i ] = v + '0' ; } return true ; }
Ref: 
def findthepath ( S , v ) : NEW_LINE INDENT result [ 0 ] = v NEW_LINE for i in range ( 1 , len ( S ) ) : NEW_LINE INDENT if ( adj [ v ] [ ord ( S [ i ] ) - ord ( ' A ' ) ] or adj [ ord ( S [ i ] ) - ord ( ' A ' ) ] [ v ] ) : NEW_LINE INDENT v = ord ( S [ i ] ) - ord ( ' A ' ) NEW_LINE DEDENT elif ( adj [ v ] [ ord ( S [ i ] ) - ord ( ' A ' ) + 5 ] or adj [ ord ( S [ i ] ) - ord ( ' A ' ) + 5 ] [ v ] ) : NEW_LINE INDENT v = ord ( S [ i ] ) - ord ( ' A ' ) + 5 NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT result . append ( v ) NEW_LINE DEDENT return True NEW_LINE DEDENT
Hyp: 
def findthepath ( S , v ) : NEW_LINE INDENT result [ 0 ] = v + '0' NEW_LINE for i in range ( 1 , len ( S ) ) : NEW_LINE INDENT if ( adj [ v ] [ S [ i ] - ' A ' ] or adj [ S [ i ] - ' A ' ] [ v ] ) : NEW_LINE INDENT v = S [ i ] - ' A ' NEW_LINE DEDENT elif ( adj [ v ] [ S [ i ] - ' A ' + 5 ] or adj [ S [ i ] - ' A ' + 5 ] [ v ] ) : NEW_LINE INDENT v = S [ i ] - ' A ' + 5 NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT result [ i ] = v + '0' NEW_LINE DEDENT return True NEW_LINE DEDENT

BLEU: 57.23
Edit Sim: 114


Src: 
bool checkSorted ( int n , queue < int > & q ) { stack < int > st ; int expected = 1 ; int fnt ; while ( ! q . empty ( ) ) { fnt = q . front ( ) ; q . pop ( ) ; if ( fnt == expected ) expected ++ ; else { if ( st . empty ( ) ) { st . push ( fnt ) ; } else if ( ! st . empty ( ) && st . top ( ) < fnt ) { return false ; } else st . push ( fnt ) ; } while ( ! st . empty ( ) && st . top ( ) == expected ) { st . pop ( ) ; expected ++ ; } } if ( expected - 1 == n && st . empty ( ) ) return true ; return false ; }
Ref: 
def checkSorted ( n , q ) : NEW_LINE INDENT st = [ ] NEW_LINE expected = 1 NEW_LINE fnt = None NEW_LINE while ( not q . empty ( ) ) : NEW_LINE INDENT fnt = q . queue [ 0 ] NEW_LINE q . get ( ) NEW_LINE if ( fnt == expected ) : NEW_LINE INDENT expected += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( len ( st ) == 0 ) : NEW_LINE INDENT st . append ( fnt ) NEW_LINE DEDENT elif ( len ( st ) != 0 and st [ - 1 ] < fnt ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT st . append ( fnt ) NEW_LINE DEDENT DEDENT while ( len ( st ) != 0 and st [ - 1 ] == expected ) : NEW_LINE INDENT st . pop ( ) NEW_LINE expected += 1 NEW_LINE DEDENT DEDENT if ( expected - 1 == n and len ( st ) == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
Hyp: 
def checkSorted ( n , q ) : NEW_LINE INDENT st = [ ] NEW_LINE expected = 1 NEW_LINE while ( not q . empty ( ) ) : NEW_LINE INDENT fnt = q . get ( ) NEW_LINE if ( fnt == expected ) : NEW_LINE INDENT expected += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( len ( st ) == 0 ) : NEW_LINE INDENT st . append ( fnt ) NEW_LINE DEDENT elif ( len ( st ) != 0 and st [ - 1 ] < fnt ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT st . append ( fnt ) NEW_LINE DEDENT DEDENT while ( len ( st ) and st [ - 1 ] == expected ) : NEW_LINE INDENT st . pop ( ) NEW_LINE expected += 1 NEW_LINE DEDENT DEDENT if ( expected - 1 == n and len ( st ) == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT

BLEU: 91.25
Edit Sim: 50


Src: 
void generate ( set < string > & st , string s ) { if ( s . size ( ) == 0 ) return ; if ( st . find ( s ) == st . end ( ) ) { st . insert ( s ) ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { string t = s ; t . erase ( i , 1 ) ; generate ( st , t ) ; } } return ; }
Ref: 
def generate ( st , s ) : NEW_LINE INDENT if len ( s ) == 0 : NEW_LINE INDENT return NEW_LINE DEDENT if s not in st : NEW_LINE INDENT st . add ( s ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT t = list ( s ) . copy ( ) NEW_LINE t . remove ( s [ i ] ) NEW_LINE t = ' ' . join ( t ) NEW_LINE generate ( st , t ) NEW_LINE DEDENT DEDENT return NEW_LINE DEDENT
Hyp: 
def generate ( st , s ) : NEW_LINE INDENT if ( len ( s ) == 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( st . get ( s ) == None ) : NEW_LINE INDENT return NEW_LINE DEDENT st . add ( s ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT t = s NEW_LINE t . remove ( i , 1 ) NEW_LINE generate ( st , t ) NEW_LINE DEDENT DEDENT return NEW_LINE DEDENT

BLEU: 65.18
Edit Sim: 102


Src: 
void tower ( int n , char sourcePole , char destinationPole , char auxiliaryPole ) { if ( 0 == n ) return ; tower ( n - 1 , sourcePole , auxiliaryPole , destinationPole ) ; cout << " Move ▁ the ▁ disk ▁ " << n << " ▁ from ▁ " << sourcePole << " ▁ to ▁ " << destinationPole << endl ; tower ( n - 1 , auxiliaryPole , destinationPole , sourcePole ) ; }
Ref: 
def tower ( n , sourcePole , destinationPole , auxiliaryPole ) : NEW_LINE INDENT if ( 0 == n ) : NEW_LINE INDENT return NEW_LINE DEDENT tower ( n - 1 , sourcePole , auxiliaryPole , destinationPole ) NEW_LINE print ( " Move ▁ the ▁ disk " , sourcePole , " from " , sourcePole , " to " , destinationPole ) NEW_LINE tower ( n - 1 , auxiliaryPole , destinationPole , sourcePole ) NEW_LINE DEDENT
Hyp: 
def tower ( n , sourcePole , destinationPole , auxiliaryPole ) : NEW_LINE INDENT if ( 0 == n ) : NEW_LINE INDENT return NEW_LINE DEDENT tower ( n - 1 , sourcePole , auxiliaryPole , destinationPole ) NEW_LINE print ( " Move ▁ the ▁ disk ▁ " , n , " ▁ from ▁ " , sourcePole , " ▁ to " , destinationPole ) NEW_LINE DEDENT

BLEU: 72.97
Edit Sim: 88


Src: 
int findMaximumPieces ( int n ) { return 1 + n * ( n + 1 ) / 2 ; }
Ref: 
def findMaximumPieces ( n ) : NEW_LINE INDENT return int ( 1 + n * ( n + 1 ) / 2 ) NEW_LINE DEDENT
Hyp: 
def findMaximumPieces ( n ) : NEW_LINE INDENT return 1 + n * ( n + 1 ) / 2 NEW_LINE DEDENT

BLEU: 75.21
Edit Sim: 8


Src: 
string minLexRotation ( string str ) { int n = str . length ( ) ; string arr [ n ] ; string concat = str + str ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = concat . substr ( i , n ) ; sort ( arr , arr + n ) ; return arr [ 0 ] ; }
Ref: 
def minLexRotation ( str_ ) : NEW_LINE INDENT n = len ( str_ ) NEW_LINE arr = [ 0 ] * n NEW_LINE concat = str_ + str_ NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr [ i ] = concat [ i : n + i ] NEW_LINE DEDENT arr . sort ( ) NEW_LINE return arr [ 0 ] NEW_LINE DEDENT
Hyp: 
def minLexRotation ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE arr = [ None ] * n NEW_LINE concat = str + str NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT arr [ i ] = concat [ i : n ] NEW_LINE DEDENT arr . sort ( ) NEW_LINE return arr [ 0 ] NEW_LINE DEDENT

BLEU: 74.11
Edit Sim: 16


Src: 
int findMinInsertions ( char str [ ] , int l , int h ) { if ( l > h ) return INT_MAX ; if ( l == h ) return 0 ; if ( l == h - 1 ) return ( str [ l ] == str [ h ] ) ? 0 : 1 ; return ( str [ l ] == str [ h ] ) ? findMinInsertions ( str , l + 1 , h - 1 ) : ( min ( findMinInsertions ( str , l , h - 1 ) , findMinInsertions ( str , l + 1 , h ) ) + 1 ) ; }
Ref: 
def findMinInsertions ( str , l , h ) : NEW_LINE INDENT if ( l > h ) : NEW_LINE INDENT return sys . maxsize NEW_LINE DEDENT if ( l == h ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( l == h - 1 ) : NEW_LINE INDENT return 0 if ( str [ l ] == str [ h ] ) else 1 NEW_LINE DEDENT if ( str [ l ] == str [ h ] ) : NEW_LINE INDENT return findMinInsertions ( str , l + 1 , h - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( min ( findMinInsertions ( str , l , h - 1 ) , findMinInsertions ( str , l + 1 , h ) ) + 1 ) NEW_LINE DEDENT DEDENT
Hyp: 
def findMinInsertions ( str , l , h ) : NEW_LINE INDENT if ( l > h ) : NEW_LINE INDENT return sys . maxsize NEW_LINE DEDENT if ( l == h ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( l == h - 1 ) : NEW_LINE INDENT return ( str [ l ] == str [ h ] ) ? 0 : 1 NEW_LINE DEDENT return ( ( str [ l ] == str [ h ] ) ? findMinInsertions ( str , l + 1 , h - 1 ) : ( min ( findMinInsertions ( str , l , h - 1 ) , findMinInsertions ( str , l + 1 , h ) ) + 1 ) NEW_LINE DEDENT

BLEU: 83.64
Edit Sim: 93


Src: 
int octalToDecimal ( int n ) { int num = n ; int dec_value = 0 ; int base = 1 ; int temp = num ; while ( temp ) { int last_digit = temp % 10 ; temp = temp / 10 ; dec_value += last_digit * base ; base = base * 8 ; } return dec_value ; }
Ref: 
def octalToDecimal ( n ) : NEW_LINE INDENT num = n NEW_LINE dec_value = 0 NEW_LINE base = 1 NEW_LINE temp = num NEW_LINE while ( temp ) : NEW_LINE INDENT last_digit = temp % 10 NEW_LINE temp = int ( temp / 10 ) NEW_LINE dec_value += last_digit * base NEW_LINE base = base * 8 NEW_LINE DEDENT return dec_value NEW_LINE DEDENT
Hyp: 
def octalToDecimal ( n ) : NEW_LINE INDENT num = n NEW_LINE dec_value = 0 NEW_LINE base = 1 NEW_LINE temp = num NEW_LINE while ( temp ) : NEW_LINE INDENT last_digit = temp % 10 NEW_LINE temp = int ( temp / 10 ) NEW_LINE dec_value += last_digit * base NEW_LINE base = base * 8 NEW_LINE DEDENT return dec_value NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int getMissingNo ( int a [ ] , int n ) { int total = ( n + 1 ) * ( n + 2 ) / 2 ; for ( int i = 0 ; i < n ; i ++ ) total -= a [ i ] ; return total ; }
Ref: 
def getMissingNo ( A ) : NEW_LINE INDENT n = len ( A ) NEW_LINE total = ( n + 1 ) * ( n + 2 ) / 2 NEW_LINE sum_of_A = sum ( A ) NEW_LINE return total - sum_of_A NEW_LINE DEDENT
Hyp: 
def getMissingNo ( a , n ) : NEW_LINE INDENT total = ( n + 1 ) * ( n + 2 ) // 2 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT total -= a [ i ] NEW_LINE DEDENT return total NEW_LINE DEDENT

BLEU: 37.68
Edit Sim: 86


Src: 
void printSquares ( int n ) { int square = 0 , prev_x = 0 ; for ( int x = 0 ; x < n ; x ++ ) { square = ( square + x + prev_x ) ; cout << square << " ▁ " ; prev_x = x ; } }
Ref: 
def printSquares ( n ) : NEW_LINE INDENT square = 0 ; prev_x = 0 ; NEW_LINE for x in range ( 0 , n ) : NEW_LINE INDENT square = ( square + x + prev_x ) NEW_LINE print ( square , end = " ▁ " ) NEW_LINE prev_x = x NEW_LINE DEDENT DEDENT
Hyp: 
def printSquares ( n ) : NEW_LINE INDENT square = 0 NEW_LINE prev_x = 0 NEW_LINE for x in range ( 0 , n ) : NEW_LINE INDENT square = ( square + x + prev_x ) NEW_LINE print ( square , end = " ▁ " ) NEW_LINE prev_x = x NEW_LINE DEDENT DEDENT

BLEU: 90.81
Edit Sim: 10


Src: 
bool isPossible ( int a [ ] , int b [ ] , int n , int k ) { sort ( a , a + n ) ; sort ( b , b + n , greater < int > ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) if ( a [ i ] + b [ i ] < k ) return false ; return true ; }
Ref: 
def isPossible ( a , b , n , k ) : NEW_LINE INDENT a . sort ( reverse = True ) NEW_LINE b . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] + b [ i ] < k ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
Hyp: 
def isPossible ( a , b , n , k ) : NEW_LINE INDENT a . sort ( reverse = True ) NEW_LINE b . sort ( reverse = True ) NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if a [ i ] + b [ i ] < k : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT

BLEU: 79.77
Edit Sim: 27


Src: 
void fitOrNotFit ( int R , int r , int x , int y , int rad ) { double val = sqrt ( pow ( x , 2 ) + pow ( y , 2 ) ) ; if ( val + rad <= R && val - rad >= R - r ) cout << " Fits \n " ; else cout << " Doesn ' t ▁ Fit \n " ; }
Ref: 
def fitOrNotFit ( R , r , x , y , rad ) : NEW_LINE INDENT val = math . sqrt ( math . pow ( x , 2 ) + math . pow ( y , 2 ) ) NEW_LINE if ( val + rad <= R and val - rad >= R - r ) : NEW_LINE INDENT print ( " Fits \n " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Doesn ' t ▁ Fit " ) NEW_LINE DEDENT DEDENT
Hyp: 
def fitOrNotfit ( R , r , x , y , rad ) : NEW_LINE INDENT val = ( math . sqrt ( pow ( x , 2 ) + math . pow ( y , 2 ) ) ) NEW_LINE if ( val + rad <= R and val - rad >= R - r ) : NEW_LINE INDENT print ( " Fits " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Doesn ' t ▁ Fit " ) NEW_LINE DEDENT DEDENT

BLEU: 89.27
Edit Sim: 15


Src: 
int findPosition ( int k , int n ) { unsigned long long int f1 = 0 , f2 = 1 , f3 ; for ( int i = 2 ; i <= MAX ; i ++ ) { f3 = f1 + f2 ; f1 = f2 ; f2 = f3 ; if ( f2 % k == 0 ) return n * i ; } }
Ref: 
def findPosition ( k , n ) : NEW_LINE INDENT f1 = 0 NEW_LINE f2 = 1 NEW_LINE i = 2 NEW_LINE while i != 0 : NEW_LINE INDENT f3 = f1 + f2 NEW_LINE f1 = f2 NEW_LINE f2 = f3 NEW_LINE if f2 % k == 0 : NEW_LINE INDENT return n * i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return NEW_LINE DEDENT
Hyp: 
def findPosition ( k , n ) : NEW_LINE INDENT f1 , f2 = 0 , 1 , 1 NEW_LINE for i in range ( 2 , MAX + 1 ) : NEW_LINE INDENT f3 = f1 + f2 NEW_LINE f1 = f2 NEW_LINE f2 = f3 NEW_LINE if ( f2 % k == 0 ) : NEW_LINE INDENT return n * i NEW_LINE DEDENT DEDENT DEDENT

BLEU: 60.82
Edit Sim: 74


Src: 
void sequence ( int n ) { int f [ n + 1 ] ; f [ 0 ] = 0 ; f [ 1 ] = 1 ; f [ 2 ] = 1 ; cout << f [ 1 ] << " ▁ " << f [ 2 ] << " ▁ " ; for ( int i = 3 ; i <= n ; i ++ ) { f [ i ] = f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ] ; cout << f [ i ] << " ▁ " ; } }
Ref: 
def sequence ( n ) : NEW_LINE INDENT f = [ 0 , 1 , 1 ] NEW_LINE print ( f [ 1 ] , end = " ▁ " ) , NEW_LINE print ( f [ 2 ] , end = " ▁ " ) , NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT f . append ( f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ] ) NEW_LINE print ( f [ i ] , end = " ▁ " ) , NEW_LINE DEDENT DEDENT
Hyp: 
def sequence ( n ) : NEW_LINE INDENT f = [ 0 ] * ( n + 1 ) NEW_LINE f [ 0 ] = 0 NEW_LINE f [ 1 ] = 1 NEW_LINE f [ 2 ] = 1 NEW_LINE print ( f [ 1 ] , " ▁ " , f [ 2 ] , " ▁ " ) NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT f [ i ] = f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ] NEW_LINE print ( f [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT

BLEU: 64.06
Edit Sim: 75


Src: 
int countManipulations ( string s1 , string s2 ) { int count = 0 ; int char_count [ 26 ] ; for ( int i = 0 ; i < 26 ; i ++ ) { char_count [ i ] = 0 ; } for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) char_count [ s1 [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < s2 . length ( ) ; i ++ ) { char_count [ s2 [ i ] - ' a ' ] -- ; if ( char_count [ s2 [ i ] - ' a ' ] < 0 ) count ++ ; } return count ; }
Ref: 
def countManipulations ( s1 , s2 ) : NEW_LINE INDENT count = 0 NEW_LINE char_count = [ 0 ] * 26 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT char_count [ i ] = 0 NEW_LINE DEDENT for i in range ( len ( s1 ) ) : NEW_LINE INDENT char_count [ ord ( s1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( len ( s2 ) ) : NEW_LINE INDENT char_count [ ord ( s2 [ i ] ) - ord ( ' a ' ) ] -= 1 NEW_LINE if ( char_count [ ord ( s2 [ i ] ) - ord ( ' a ' ) ] < 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
Hyp: 
def countManipulations ( s1 , s2 ) : NEW_LINE INDENT count = 0 NEW_LINE char_count = [ 0 ] * 26 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT char_count [ i ] = 0 NEW_LINE DEDENT for i in range ( len ( s1 ) ) : NEW_LINE INDENT char_count [ ord ( s1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( len ( s2 ) ) : NEW_LINE INDENT char_count [ ord ( s2 [ i ] ) - ord ( ' a ' ) ] -= 1 NEW_LINE if ( char_count [ ord ( s2 [ i ] ) - ord ( ' a ' ) ] < 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int count ( int n ) { int table [ n + 1 ] , i ; for ( int j = 0 ; j < n + 1 ; j ++ ) table [ j ] = 0 ; table [ 0 ] = 1 ; for ( i = 3 ; i <= n ; i ++ ) table [ i ] += table [ i - 3 ] ; for ( i = 5 ; i <= n ; i ++ ) table [ i ] += table [ i - 5 ] ; for ( i = 10 ; i <= n ; i ++ ) table [ i ] += table [ i - 10 ] ; return table [ n ] ; }
Ref: 
def count ( n ) : NEW_LINE INDENT table = [ 0 for i in range ( n + 1 ) ] NEW_LINE table [ 0 ] = 1 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT table [ i ] += table [ i - 3 ] NEW_LINE DEDENT for i in range ( 5 , n + 1 ) : NEW_LINE INDENT table [ i ] += table [ i - 5 ] NEW_LINE DEDENT for i in range ( 10 , n + 1 ) : NEW_LINE INDENT table [ i ] += table [ i - 10 ] NEW_LINE DEDENT return table [ n ] NEW_LINE DEDENT
Hyp: 
def count ( n ) : NEW_LINE INDENT table = [ 0 for _ in range ( n + 1 ) ] NEW_LINE for j in range ( n ) : NEW_LINE INDENT table [ j ] = 0 NEW_LINE DEDENT table [ 0 ] = 1 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT table [ i ] += table [ i - 3 ] NEW_LINE DEDENT for i in range ( 5 , n + 1 ) : NEW_LINE INDENT table [ i ] += table [ i - 5 ] NEW_LINE DEDENT for i in range ( 10 , n + 1 ) : NEW_LINE INDENT table [ i ] += table [ i - 10 ] NEW_LINE DEDENT return table [ n ] NEW_LINE DEDENT

BLEU: 83.73
Edit Sim: 72


Src: 
int maxSubsequenceSubstring ( char x [ ] , char y [ ] , int n , int m ) { int dp [ MAX ] [ MAX ] ; for ( int i = 0 ; i <= m ; i ++ ) for ( int j = 0 ; j <= n ; j ++ ) dp [ i ] [ j ] = 0 ; for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( x [ j - 1 ] == y [ i - 1 ] ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = dp [ i ] [ j - 1 ] ; } } int ans = 0 ; for ( int i = 1 ; i <= m ; i ++ ) ans = max ( ans , dp [ i ] [ n ] ) ; return ans ; }
Ref: 
def maxSubsequenceSubstring ( x , y , n , m ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( MAX ) ] for i in range ( MAX ) ] NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( x [ j - 1 ] == y [ i - 1 ] ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT ans = max ( ans , dp [ i ] [ n ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
Hyp: 
def maxSubsequenceSubstring ( x , y , n , m ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( MAX ) ] for j in range ( MAX ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT dp [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( x [ j - 1 ] == y [ i - 1 ] ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT ans = max ( ans , dp [ i ] [ n ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT

BLEU: 82.84
Edit Sim: 125


Src: 
int findLongestRepeatingSubSeq ( string str ) { int n = str . length ( ) ; int dp [ n + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= n ; j ++ ) dp [ i ] [ j ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( str [ i - 1 ] == str [ j - 1 ] && i != j ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ; } } return dp [ n ] [ n ] ; }
Ref: 
def findLongestRepeatingSubSeq ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE dp = [ [ 0 ] * ( n + 1 ) ] * ( n + 1 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( str [ i - 1 ] == str [ j - 1 ] and i != j ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ n ] [ n ] NEW_LINE DEDENT
Hyp: 
def findLongestRepeatingSubSeq ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE dp = [ [ 0 for x in range ( n + 1 ) ] for y in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( str [ i - 1 ] == str [ j - 1 ] and i != j ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ n ] [ n ] NEW_LINE DEDENT

BLEU: 75.15
Edit Sim: 156


Src: 
bool isCornerPresent ( string str , string corner ) { int n = str . length ( ) ; int cl = corner . length ( ) ; if ( n < cl ) return false ; return ( str . substr ( 0 , cl ) . compare ( corner ) == 0 && str . substr ( n - cl , cl ) . compare ( corner ) == 0 ) ; }
Ref: 
def isCornerPresent ( str , corner ) : NEW_LINE INDENT n = len ( str ) NEW_LINE cl = len ( corner ) NEW_LINE if ( n < cl ) : NEW_LINE INDENT return False NEW_LINE DEDENT return ( ( str [ : cl ] == corner ) and ( str [ n - cl : ] == corner ) ) NEW_LINE DEDENT
Hyp: 
def isCornerPresent ( str , corner ) : NEW_LINE INDENT n = len ( str ) NEW_LINE cl = len ( corner ) NEW_LINE if n < cl : NEW_LINE INDENT return False NEW_LINE DEDENT return ( str [ 0 : cl ] == corner and str [ n - cl : cl ] == corner ) NEW_LINE DEDENT

BLEU: 73.39
Edit Sim: 17


Src: 
int getMedian ( int ar1 [ ] , int ar2 [ ] , int n ) { int i = 0 ; int j = 0 ; int count ; int m1 = - 1 , m2 = - 1 ; for ( count = 0 ; count <= n ; count ++ ) { if ( i == n ) { m1 = m2 ; m2 = ar2 [ 0 ] ; break ; } else if ( j == n ) { m1 = m2 ; m2 = ar1 [ 0 ] ; break ; } if ( ar1 [ i ] < ar2 [ j ] ) { m1 = m2 ; m2 = ar1 [ i ] ; i ++ ; } else { m1 = m2 ; m2 = ar2 [ j ] ; j ++ ; } } return ( m1 + m2 ) / 2 ; }
Ref: 
def getMedian ( ar1 , ar2 , n ) : NEW_LINE INDENT i = 0 NEW_LINE j = 0 NEW_LINE m1 = - 1 NEW_LINE m2 = - 1 NEW_LINE count = 0 NEW_LINE while count < n + 1 : NEW_LINE INDENT count += 1 NEW_LINE if i == n : NEW_LINE INDENT m1 = m2 NEW_LINE m2 = ar2 [ 0 ] NEW_LINE break NEW_LINE DEDENT elif j == n : NEW_LINE INDENT m1 = m2 NEW_LINE m2 = ar1 [ 0 ] NEW_LINE break NEW_LINE DEDENT if ar1 [ i ] < ar2 [ j ] : NEW_LINE INDENT m1 = m2 NEW_LINE m2 = ar1 [ i ] NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT m1 = m2 NEW_LINE m2 = ar2 [ j ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT return ( m1 + m2 ) / 2 NEW_LINE DEDENT
Hyp: 
def getMedian ( ar1 , ar2 , n ) : NEW_LINE INDENT i = 0 NEW_LINE j = 0 NEW_LINE count = 0 NEW_LINE m1 = - 1 NEW_LINE m2 = - 1 NEW_LINE for count in range ( n + 1 ) : NEW_LINE INDENT if i == n : NEW_LINE INDENT m1 = m2 NEW_LINE m2 = ar2 [ 0 ] NEW_LINE break NEW_LINE DEDENT elif j == n : NEW_LINE INDENT m1 = m2 NEW_LINE m2 = ar1 [ 0 ] NEW_LINE break NEW_LINE DEDENT if ar1 [ i ] < ar2 [ j ] : NEW_LINE INDENT m1 = m2 NEW_LINE m2 = ar1 [ i ] NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT m1 = m2 NEW_LINE m2 = ar2 [ j ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT return ( m1 + m2 ) // 2 NEW_LINE DEDENT

BLEU: 90.13
Edit Sim: 53


Src: 
int countZeroes ( int mat [ N ] [ N ] ) { int row = N - 1 , col = 0 ; int count = 0 ; while ( col < N ) { while ( mat [ row ] [ col ] ) if ( -- row < 0 ) return count ; count += ( row + 1 ) ; col ++ ; } return count ; }
Ref: 
def countZeroes ( mat ) : NEW_LINE INDENT N = 5 ; NEW_LINE row = N - 1 ; NEW_LINE col = 0 ; NEW_LINE count = 0 ; NEW_LINE while ( col < N ) : NEW_LINE INDENT while ( mat [ row ] [ col ] ) : NEW_LINE INDENT if ( row < 0 ) : NEW_LINE INDENT return count ; NEW_LINE DEDENT row = row - 1 ; NEW_LINE DEDENT count = count + ( row + 1 ) ; NEW_LINE col = col + 1 ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT
Hyp: 
def countZeroes ( mat ) : NEW_LINE INDENT row = N - 1 NEW_LINE col = 0 NEW_LINE count = 0 NEW_LINE while ( col < N ) : NEW_LINE INDENT while ( mat [ row ] [ col ] ) : NEW_LINE INDENT if ( -- row < 0 ) : NEW_LINE INDENT return count NEW_LINE DEDENT count += ( row + 1 ) NEW_LINE col += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT

BLEU: 54.3
Edit Sim: 82


Src: 
int jumpSearch ( int arr [ ] , int x , int n ) { int step = sqrt ( n ) ; int prev = 0 ; while ( arr [ min ( step , n ) - 1 ] < x ) { prev = step ; step += sqrt ( n ) ; if ( prev >= n ) return - 1 ; } while ( arr [ prev ] < x ) { prev ++ ; if ( prev == min ( step , n ) ) return - 1 ; } if ( arr [ prev ] == x ) return prev ; return - 1 ; }
Ref: 
def jumpSearch ( arr , x , n ) : NEW_LINE INDENT step = math . sqrt ( n ) NEW_LINE prev = 0 NEW_LINE while arr [ int ( min ( step , n ) - 1 ) ] < x : NEW_LINE INDENT prev = step NEW_LINE step += math . sqrt ( n ) NEW_LINE if prev >= n : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT while arr [ int ( prev ) ] < x : NEW_LINE INDENT prev += 1 NEW_LINE if prev == min ( step , n ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT if arr [ int ( prev ) ] == x : NEW_LINE INDENT return prev NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
Hyp: 
def jumpSearch ( arr , x , n ) : NEW_LINE INDENT step = math . sqrt ( n ) NEW_LINE prev = 0 NEW_LINE while ( arr [ min ( step , n ) - 1 ] < x ) : NEW_LINE INDENT prev = step NEW_LINE step += math . sqrt ( n ) NEW_LINE if ( prev >= n ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT while ( arr [ prev ] < x ) : NEW_LINE INDENT prev += 1 NEW_LINE if ( prev == min ( step , n ) ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT if ( arr [ prev ] == x ) : NEW_LINE INDENT return prev NEW_LINE DEDENT return - 1 NEW_LINE DEDENT

BLEU: 76.58
Edit Sim: 44


Src: 
void solution ( int a , int b , int n ) { for ( int i = 0 ; i * a <= n ; i ++ ) { if ( ( n - ( i * a ) ) % b == 0 ) { cout << " x ▁ = ▁ " << i << " , ▁ y ▁ = ▁ " << ( n - ( i * a ) ) / b ; return ; } } cout << " No ▁ solution " ; }
Ref: 
def solution ( a , b , n ) : NEW_LINE INDENT i = 0 NEW_LINE while i * a <= n : NEW_LINE INDENT if ( n - ( i * a ) ) % b == 0 : NEW_LINE INDENT print ( " x ▁ = ▁ " , i , " , ▁ y ▁ = ▁ " , int ( ( n - ( i * a ) ) / b ) ) NEW_LINE return 0 NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT print ( " No ▁ solution " ) NEW_LINE DEDENT
Hyp: 
def solution ( a , b , n ) : NEW_LINE INDENT for i in range ( 0 , a + 1 ) : NEW_LINE INDENT if ( ( n - ( i * a ) ) % b == 0 ) : NEW_LINE INDENT print ( " x ▁ = ▁ " , i , " , ▁ y ▁ = ▁ " , ( n - ( i * a ) ) / b ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( " No ▁ solution " ) NEW_LINE DEDENT

BLEU: 72.73
Edit Sim: 56


Src: 
string longDivision ( string number , int divisor ) { string ans ; int idx = 0 ; int temp = number [ idx ] - '0' ; while ( temp < divisor ) temp = temp * 10 + ( number [ ++ idx ] - '0' ) ; while ( number . size ( ) > idx ) { ans += ( temp / divisor ) + '0' ; temp = ( temp % divisor ) * 10 + number [ ++ idx ] - '0' ; } if ( ans . length ( ) == 0 ) return "0" ; return ans ; }
Ref: 
def longDivision ( number , divisor ) : NEW_LINE INDENT ans = " " NEW_LINE idx = 0 NEW_LINE temp = ord ( number [ idx ] ) - ord ( '0' ) NEW_LINE while ( temp < divisor ) : NEW_LINE INDENT temp = ( temp * 10 + ord ( number [ idx + 1 ] ) - ord ( '0' ) ) NEW_LINE idx += 1 NEW_LINE DEDENT idx += 1 NEW_LINE while ( ( len ( number ) ) > idx ) : NEW_LINE INDENT ans += chr ( math . floor ( temp // divisor ) + ord ( '0' ) ) NEW_LINE temp = ( ( temp % divisor ) * 10 + ord ( number [ idx ] ) - ord ( '0' ) ) NEW_LINE idx += 1 NEW_LINE DEDENT ans += chr ( math . floor ( temp // divisor ) + ord ( '0' ) ) NEW_LINE if ( len ( ans ) == 0 ) : NEW_LINE INDENT return "0" NEW_LINE DEDENT return ans NEW_LINE DEDENT
Hyp: 
def longDivision ( number , divisor ) : NEW_LINE INDENT ans = " " NEW_LINE idx = 0 NEW_LINE temp = number [ idx ] - '0' NEW_LINE while ( temp < divisor ) : NEW_LINE INDENT temp = ( temp * 10 + ( number [ idx ] - '0' ) ) NEW_LINE DEDENT while ( len ( number ) > idx ) : NEW_LINE INDENT ans += ( temp // divisor ) + '0' NEW_LINE temp = ( temp % divisor ) * 10 + number [ idx ] - '0' NEW_LINE DEDENT if ( len ( ans ) == 0 ) : NEW_LINE INDENT return "0" NEW_LINE DEDENT return ans NEW_LINE DEDENT

BLEU: 46.09
Edit Sim: 210


Src: 
void sort012 ( int a [ ] , int arr_size ) { int lo = 0 ; int hi = arr_size - 1 ; int mid = 0 ; while ( mid <= hi ) { switch ( a [ mid ] ) { case 0 : swap ( a [ lo ++ ] , a [ mid ++ ] ) ; break ; case 1 : mid ++ ; break ; case 2 : swap ( a [ mid ] , a [ hi -- ] ) ; break ; } } }
Ref: 
def sort012 ( a , arr_size ) : NEW_LINE INDENT lo = 0 NEW_LINE hi = arr_size - 1 NEW_LINE mid = 0 NEW_LINE while mid <= hi : NEW_LINE INDENT if a [ mid ] == 0 : NEW_LINE INDENT a [ lo ] , a [ mid ] = a [ mid ] , a [ lo ] NEW_LINE lo = lo + 1 NEW_LINE mid = mid + 1 NEW_LINE DEDENT elif a [ mid ] == 1 : NEW_LINE INDENT mid = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT a [ mid ] , a [ hi ] = a [ hi ] , a [ mid ] NEW_LINE hi = hi - 1 NEW_LINE DEDENT DEDENT DEDENT
Hyp: 
def sort012 ( a , arr_size ) : NEW_LINE INDENT lo = 0 NEW_LINE hi = arr_size - 1 NEW_LINE mid = 0 NEW_LINE while ( mid <= hi ) : NEW_LINE INDENT switch a [ mid ] : NEW_LINE INDENT case 0 : NEW_LINE INDENT a [ lo ] , a [ mid ] = a [ mid ] , a [ hi ] NEW_LINE break NEW_LINE DEDENT case 1 : NEW_LINE INDENT mid += 1 NEW_LINE break NEW_LINE DEDENT case 2 : NEW_LINE INDENT a [ mid ] , a [ hi -= 1 ] = a [ hi ] , a [ mid ] NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT

BLEU: 63.39
Edit Sim: 112


Src: 
bool canRepresentBST ( int pre [ ] , int n ) { stack < int > s ; int root = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { if ( pre [ i ] < root ) return false ; while ( ! s . empty ( ) && s . top ( ) < pre [ i ] ) { root = s . top ( ) ; s . pop ( ) ; } s . push ( pre [ i ] ) ; } return true ; }
Ref: 
def canRepresentBST ( pre ) : NEW_LINE INDENT s = [ ] NEW_LINE root = INT_MIN NEW_LINE for value in pre : NEW_LINE INDENT if value < root : NEW_LINE INDENT return False NEW_LINE DEDENT while ( len ( s ) > 0 and s [ - 1 ] < value ) : NEW_LINE INDENT root = s . pop ( ) NEW_LINE DEDENT s . append ( value ) NEW_LINE DEDENT return True NEW_LINE DEDENT
Hyp: 
def canRepresentBST ( pre , n ) : NEW_LINE INDENT s = [ ] NEW_LINE root = - sys . maxsize - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( pre [ i ] < root ) : NEW_LINE INDENT return False NEW_LINE DEDENT while ( len ( s ) > 0 and s [ - 1 ] < pre [ i ] ) : NEW_LINE INDENT root = s [ - 1 ] NEW_LINE s . pop ( ) NEW_LINE DEDENT s . append ( pre [ i ] ) NEW_LINE DEDENT return True NEW_LINE DEDENT

BLEU: 56.04
Edit Sim: 85


Src: 
int find ( bool arr [ n ] [ n ] ) { int i = 0 , j = n - 1 ; int res = - 1 ; while ( i < n && j >= 0 ) { if ( arr [ i ] [ j ] == 0 ) { while ( j >= 0 && ( arr [ i ] [ j ] == 0 || i == j ) ) j -- ; if ( j == - 1 ) { res = i ; break ; } else i ++ ; } else { while ( i < n && ( arr [ i ] [ j ] == 1 || i == j ) ) i ++ ; if ( i == n ) { res = j ; break ; } else j -- ; } } if ( res == - 1 ) return res ; for ( int i = 0 ; i < n ; i ++ ) if ( res != i && arr [ i ] [ res ] != 1 ) return - 1 ; for ( int j = 0 ; j < n ; j ++ ) if ( res != j && arr [ res ] [ j ] != 0 ) return - 1 ; return res ; }
Ref: 
def find ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE i = 0 NEW_LINE j = n - 1 NEW_LINE res = - 1 NEW_LINE while i < n and j >= 0 : NEW_LINE INDENT if arr [ i ] [ j ] == 0 : NEW_LINE INDENT while j >= 0 and ( arr [ i ] [ j ] == 0 or i == j ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT if j == - 1 : NEW_LINE INDENT res = i NEW_LINE break NEW_LINE DEDENT else : i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT while i < n and ( arr [ i ] [ j ] == 1 or i == j ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT if i == n : NEW_LINE INDENT res = j NEW_LINE break NEW_LINE DEDENT else : j -= 1 NEW_LINE DEDENT DEDENT if res == - 1 : NEW_LINE INDENT return res NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if res != i and arr [ i ] [ res ] != 1 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT for j in range ( 0 , j ) : NEW_LINE INDENT if res != j and arr [ res ] [ j ] != 0 : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT DEDENT return res ; NEW_LINE DEDENT
Hyp: 
def find ( arr ) : NEW_LINE INDENT i = 0 NEW_LINE j = n - 1 NEW_LINE res = - 1 NEW_LINE while ( i < n and j >= 0 ) : NEW_LINE INDENT if ( arr [ i ] [ j ] == 0 ) : NEW_LINE INDENT while ( j >= 0 and ( arr [ i ] [ j ] == 0 or i == j ) ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT if ( j == - 1 ) : NEW_LINE INDENT res = i NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT while ( i < n and ( arr [ i ] [ j ] == 1 or i == j ) ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT if ( i == n ) : NEW_LINE INDENT res = j NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT DEDENT DEDENT if ( res == - 1 ) : NEW_LINE INDENT return res NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( res != i and arr [ i ] [ res ] != 1 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT for j in range ( 0 , n ) : NEW_LINE INDENT if ( res != j and arr [ res ] [ j ] != 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT

BLEU: 76.51
Edit Sim: 112


Src: 
void printArray ( int * a , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << a [ i ] << " ▁ " ; cout << endl ; return ; }
Ref: 
def printArray ( a , n ) : NEW_LINE INDENT for i in a : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT
Hyp: 
def printArray ( a , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE return NEW_LINE DEDENT

BLEU: 67.86
Edit Sim: 32


Src: 
void sortSquares ( int arr [ ] , int n ) { int K = 0 ; for ( K = 0 ; K < n ; K ++ ) if ( arr [ K ] >= 0 ) break ; int i = K - 1 ; int j = K ; int ind = 0 ; int temp [ n ] ; while ( i >= 0 && j < n ) { if ( arr [ i ] * arr [ i ] < arr [ j ] * arr [ j ] ) { temp [ ind ] = arr [ i ] * arr [ i ] ; i -- ; } else { temp [ ind ] = arr [ j ] * arr [ j ] ; j ++ ; } ind ++ ; } while ( i >= 0 ) { temp [ ind ] = arr [ i ] * arr [ i ] ; i -- ; ind ++ ; } while ( j < n ) { temp [ ind ] = arr [ j ] * arr [ j ] ; j ++ ; ind ++ ; } for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = temp [ i ] ; }
Ref: 
def sortSquares ( arr , n ) : NEW_LINE INDENT K = 0 NEW_LINE for K in range ( n ) : NEW_LINE INDENT if ( arr [ K ] >= 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT i = K - 1 NEW_LINE j = K NEW_LINE ind = 0 NEW_LINE temp = [ 0 ] * n NEW_LINE while ( i >= 0 and j < n ) : NEW_LINE INDENT if ( arr [ i ] * arr [ i ] < arr [ j ] * arr [ j ] ) : NEW_LINE INDENT temp [ ind ] = arr [ i ] * arr [ i ] NEW_LINE i -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT temp [ ind ] = arr [ j ] * arr [ j ] NEW_LINE j += 1 NEW_LINE DEDENT ind += 1 NEW_LINE DEDENT while ( i >= 0 ) : NEW_LINE INDENT temp [ ind ] = arr [ i ] * arr [ i ] NEW_LINE i -= 1 NEW_LINE ind += 1 NEW_LINE DEDENT while ( j < n ) : NEW_LINE INDENT temp [ ind ] = arr [ j ] * arr [ j ] NEW_LINE j += 1 NEW_LINE ind += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = temp [ i ] NEW_LINE DEDENT DEDENT
Hyp: 
def sortSquares ( arr , n ) : NEW_LINE INDENT K = 0 NEW_LINE for K in range ( 0 , n ) : NEW_LINE INDENT if arr [ K ] >= 0 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT i = K - 1 NEW_LINE j = K NEW_LINE ind = 0 NEW_LINE temp = [ 0 ] * n NEW_LINE while i >= 0 and j < n : NEW_LINE INDENT if arr [ i ] * arr [ i ] < arr [ j ] * arr [ j ] : NEW_LINE INDENT temp [ ind ] = arr [ i ] * arr [ i ] NEW_LINE i -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT temp [ ind ] = arr [ j ] * arr [ j ] NEW_LINE j += 1 NEW_LINE DEDENT ind += 1 NEW_LINE DEDENT while i >= 0 : NEW_LINE INDENT temp [ ind ] = arr [ i ] * arr [ i ] NEW_LINE i -= 1 NEW_LINE ind += 1 NEW_LINE DEDENT while j < n : NEW_LINE INDENT temp [ ind ] = arr [ j ] * arr [ j ] NEW_LINE j += 1 NEW_LINE ind += 1 NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT arr [ i ] = temp [ i ] NEW_LINE DEDENT DEDENT

BLEU: 87.92
Edit Sim: 28


Src: 
int find_maximum ( int a [ ] , int n , int k ) { unordered_map < int , int > b ; for ( int i = 0 ; i < n ; i ++ ) { int x = a [ i ] ; int d = min ( 1 + i , n - i ) ; if ( b . find ( x ) == b . end ( ) ) b [ x ] = d ; else b [ x ] = min ( d , b [ x ] ) ; } int ans = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { int x = a [ i ] ; if ( x != k - x && b . find ( k - x ) != b . end ( ) ) ans = min ( max ( b [ x ] , b [ k - x ] ) , ans ) ; } return ans ; }
Ref: 
def find_maximum ( a , n , k ) : NEW_LINE INDENT b = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = a [ i ] NEW_LINE d = min ( 1 + i , n - i ) NEW_LINE if x not in b . keys ( ) : NEW_LINE INDENT b [ x ] = d NEW_LINE DEDENT else : NEW_LINE INDENT b [ x ] = min ( d , b [ x ] ) NEW_LINE DEDENT DEDENT ans = 10 ** 9 NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = a [ i ] NEW_LINE if ( x != ( k - x ) and ( k - x ) in b . keys ( ) ) : NEW_LINE INDENT ans = min ( max ( b [ x ] , b [ k - x ] ) , ans ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
Hyp: 
def find_maximum ( a , n , k ) : NEW_LINE INDENT b = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = a [ i ] NEW_LINE d = min ( 1 + i , n - i ) NEW_LINE if ( b . get ( x ) ) : NEW_LINE INDENT b [ x ] = d NEW_LINE DEDENT else : NEW_LINE INDENT b [ x ] = min ( d , b [ x ] ) NEW_LINE DEDENT DEDENT ans = sys . maxsize NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = a [ i ] NEW_LINE if ( x != k - x and b . get ( k - x ) ) : NEW_LINE INDENT ans = min ( max ( b [ x ] , b [ k - x ] ) , ans ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT

BLEU: 85.94
Edit Sim: 47


Src: 
char maxRepeating ( string str ) { int n = str . length ( ) ; int count = 0 ; char res = str [ 0 ] ; int cur_count = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i < n - 1 && str [ i ] == str [ i + 1 ] ) cur_count ++ ; else { if ( cur_count > count ) { count = cur_count ; res = str [ i ] ; } cur_count = 1 ; } } return res ; }
Ref: 
def maxRepeating ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE count = 0 NEW_LINE res = str [ 0 ] NEW_LINE cur_count = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i < n - 1 and str [ i ] == str [ i + 1 ] ) : NEW_LINE INDENT cur_count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if cur_count > count : NEW_LINE INDENT count = cur_count NEW_LINE res = str [ i ] NEW_LINE DEDENT cur_count = 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
Hyp: 
def maxRepeating ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE count = 0 NEW_LINE res = str [ 0 ] NEW_LINE cur_count = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i < n - 1 and str [ i ] == str [ i + 1 ] ) : NEW_LINE INDENT cur_count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if cur_count > count : NEW_LINE INDENT count = cur_count NEW_LINE res = str [ i ] NEW_LINE DEDENT cur_count = 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int solveQuery ( int start , int end , int arr [ ] ) { unordered_map < int , int > frequency ; for ( int i = start ; i <= end ; i ++ ) frequency [ arr [ i ] ] ++ ; int count = 0 ; for ( auto x : frequency ) if ( x . first == x . second ) count ++ ; return count ; }
Ref: 
def solveQuery ( start , end , arr ) : NEW_LINE INDENT frequency = dict ( ) NEW_LINE for i in range ( start , end + 1 ) : NEW_LINE INDENT if arr [ i ] in frequency . keys ( ) : NEW_LINE INDENT frequency [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT frequency [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT count = 0 NEW_LINE for x in frequency : NEW_LINE INDENT if x == frequency [ x ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
Hyp: 
def solveQuery ( start , end , arr ) : NEW_LINE INDENT frequency = dict ( ) NEW_LINE for i in range ( start , end + 1 ) : NEW_LINE INDENT frequency [ arr [ i ] ] = frequency . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT count = 0 NEW_LINE for x in frequency : NEW_LINE INDENT if ( frequency [ x ] == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT

BLEU: 67.45
Edit Sim: 126


Src: 
int Circumference ( int a ) { return 4 * a ; }
Ref: 
def Circumference ( a ) : NEW_LINE INDENT return ( 4 * a ) NEW_LINE DEDENT
Hyp: 
def Circumference ( a ) : NEW_LINE INDENT return 4 * a NEW_LINE DEDENT

BLEU: 66.49
Edit Sim: 4


Src: 
int numberOfPaths ( int m , int n ) { int path = 1 ; for ( int i = n ; i < ( m + n - 1 ) ; i ++ ) { path *= i ; path /= ( i - n + 1 ) ; } return path ; }
Ref: 
def numberOfPaths ( m , n ) : NEW_LINE INDENT for i in range ( n , ( m + n - 1 ) ) : NEW_LINE INDENT path *= i NEW_LINE path //= ( i - n + 1 ) NEW_LINE DEDENT return path NEW_LINE DEDENT
Hyp: 
def numberOfPaths ( m , n ) : NEW_LINE INDENT path = 1 NEW_LINE for i in range ( n , ( m + n - 1 ) ) : NEW_LINE INDENT path *= i NEW_LINE path /= ( i - n + 1 ) NEW_LINE DEDENT return path NEW_LINE DEDENT

BLEU: 83.92
Edit Sim: 19


Src: 
void pointClip ( int XY [ ] [ 2 ] , int n , int Xmin , int Ymin , int Xmax , int Ymax ) { cout << " Point ▁ inside ▁ the ▁ viewing ▁ pane : " << endl ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( XY [ i ] [ 0 ] >= Xmin ) && ( XY [ i ] [ 0 ] <= Xmax ) ) { if ( ( XY [ i ] [ 1 ] >= Ymin ) && ( XY [ i ] [ 1 ] <= Ymax ) ) cout << " [ " << XY [ i ] [ 0 ] << " , " << XY [ i ] [ 1 ] << " ] ▁ " ; } } cout << " \n " << endl ; cout << " Point ▁ outside ▁ the ▁ viewing ▁ pane : " << endl ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( XY [ i ] [ 0 ] < Xmin ) || ( XY [ i ] [ 0 ] > Xmax ) ) cout << " [ " << XY [ i ] [ 0 ] << " , " << XY [ i ] [ 1 ] << " ] ▁ " ; if ( ( XY [ i ] [ 1 ] < Ymin ) || ( XY [ i ] [ 1 ] > Ymax ) ) cout << " [ " << XY [ i ] [ 0 ] << " , " << XY [ i ] [ 1 ] << " ] ▁ " ; } }
Ref: 
def pointClip ( XY , n , Xmin , Ymin , Xmax , Ymax ) : NEW_LINE INDENT print ( " Point ▁ inside ▁ the ▁ viewing ▁ pane : " ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( XY [ i ] [ 0 ] >= Xmin ) and ( XY [ i ] [ 0 ] <= Xmax ) ) : NEW_LINE INDENT if ( ( XY [ i ] [ 1 ] >= Ymin ) and ( XY [ i ] [ 1 ] <= Ymax ) ) : NEW_LINE INDENT print ( " [ " , XY [ i ] [ 0 ] , " , ▁ " , XY [ i ] [ 1 ] , " ] " , sep = " " , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT print ( " \n \n Point ▁ outside ▁ the ▁ viewing ▁ pane : " ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( XY [ i ] [ 0 ] < Xmin ) or ( XY [ i ] [ 0 ] > Xmax ) ) : NEW_LINE INDENT print ( " [ " , XY [ i ] [ 0 ] , " , ▁ " , XY [ i ] [ 1 ] , " ] " , sep = " " , end = " ▁ " ) NEW_LINE DEDENT if ( ( XY [ i ] [ 1 ] < Ymin ) or ( XY [ i ] [ 1 ] > Ymax ) ) : NEW_LINE INDENT print ( " [ " , XY [ i ] [ 0 ] , " , ▁ " , XY [ i ] [ 1 ] , " ] " , sep = " " , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
Hyp: 
def pointClip ( XY , n , Xmin , Ymin , Xmax , Ymax ) : NEW_LINE INDENT print ( " Point ▁ inside ▁ the ▁ viewing ▁ pane : " ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( ( XY [ i ] [ 0 ] >= Xmin ) and ( XY [ i ] [ 0 ] <= Xmax ) ) : NEW_LINE INDENT if ( ( XY [ i ] [ 1 ] >= Ymin ) and ( XY [ i ] [ 1 ] <= Ymax ) ) : NEW_LINE INDENT print ( " [ " , XY [ i ] [ 0 ] , " , " , XY [ i ] [ 1 ] , " ] ▁ " ) NEW_LINE DEDENT DEDENT DEDENT print ( " \n " ) NEW_LINE DEDENT

BLEU: 28.54
Edit Sim: 500


Src: 
ll pre_compute ( ll a [ ] , ll n , ll index , ll k ) { ll dp [ n ] [ n ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > a [ 0 ] ) dp [ 0 ] [ i ] = a [ i ] + a [ 0 ] ; else dp [ 0 ] [ i ] = a [ i ] ; } for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( a [ j ] > a [ i ] && j > i ) { if ( dp [ i - 1 ] [ i ] + a [ j ] > dp [ i - 1 ] [ j ] ) dp [ i ] [ j ] = dp [ i - 1 ] [ i ] + a [ j ] ; else dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; } else dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; } } return dp [ index ] [ k ] ; }
Ref: 
def pre_compute ( a , n , index , k ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] > a [ 0 ] : NEW_LINE INDENT dp [ 0 ] [ i ] = a [ i ] + a [ 0 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ 0 ] [ i ] = a [ i ] NEW_LINE DEDENT DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if a [ j ] > a [ i ] and j > i : NEW_LINE INDENT if dp [ i - 1 ] [ i ] + a [ j ] > dp [ i - 1 ] [ j ] : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ i ] + a [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return dp [ index ] [ k ] NEW_LINE DEDENT
Hyp: 
def pre_compute ( a , n , index , k ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] > a [ 0 ] ) : NEW_LINE INDENT dp [ 0 ] [ i ] = a [ i ] + a [ 0 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ 0 ] [ i ] = a [ i ] NEW_LINE DEDENT DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( a [ j ] > a [ i ] and j > i ) : NEW_LINE INDENT if ( dp [ i - 1 ] [ i ] + a [ j ] > dp [ i - 1 ] [ j ] ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ i ] + a [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return dp [ index ] [ k ] NEW_LINE DEDENT

BLEU: 85.38
Edit Sim: 95


Src: 
void splitArr ( int arr [ ] , int n , int k ) { for ( int i = 0 ; i < k ; i ++ ) { int x = arr [ 0 ] ; for ( int j = 0 ; j < n - 1 ; ++ j ) arr [ j ] = arr [ j + 1 ] ; arr [ n - 1 ] = x ; } }
Ref: 
def splitArr ( arr , n , k ) : NEW_LINE INDENT for i in range ( 0 , k ) : NEW_LINE INDENT x = arr [ 0 ] NEW_LINE for j in range ( 0 , n - 1 ) : NEW_LINE INDENT arr [ j ] = arr [ j + 1 ] NEW_LINE DEDENT arr [ n - 1 ] = x NEW_LINE DEDENT DEDENT
Hyp: 
def splitArr ( arr , n , k ) : NEW_LINE INDENT for i in range ( k ) : NEW_LINE INDENT x = arr [ 0 ] NEW_LINE for j in range ( 0 , n - 1 ) : NEW_LINE INDENT arr [ j ] = arr [ j + 1 ] NEW_LINE DEDENT arr [ n - 1 ] = x NEW_LINE DEDENT DEDENT

BLEU: 94.83
Edit Sim: 4


Src: 
int smallestSubWithSum ( int arr [ ] , int n , int x ) { int curr_sum = 0 , min_len = n + 1 ; int start = 0 , end = 0 ; while ( end < n ) { while ( curr_sum <= x && end < n ) { if ( curr_sum <= 0 && x > 0 ) { start = end ; curr_sum = 0 ; } curr_sum += arr [ end ++ ] ; } while ( curr_sum > x && start < n ) { if ( end - start < min_len ) min_len = end - start ; curr_sum -= arr [ start ++ ] ; } } return min_len ; }
Ref: 
def smallestSubWithSum ( arr , n , x ) : NEW_LINE INDENT curr_sum = 0 NEW_LINE min_len = n + 1 NEW_LINE start = 0 NEW_LINE end = 0 NEW_LINE while ( end < n ) : NEW_LINE INDENT while ( curr_sum <= x and end < n ) : NEW_LINE INDENT if ( curr_sum <= 0 and x > 0 ) : NEW_LINE INDENT start = end NEW_LINE curr_sum = 0 NEW_LINE DEDENT curr_sum += arr [ end ] NEW_LINE end += 1 NEW_LINE DEDENT while ( curr_sum > x and start < n ) : NEW_LINE INDENT if ( end - start < min_len ) : NEW_LINE INDENT min_len = end - start NEW_LINE DEDENT curr_sum -= arr [ start ] NEW_LINE start += 1 NEW_LINE DEDENT DEDENT return min_len NEW_LINE DEDENT
Hyp: 
def smallestSubWithSum ( arr , n , x ) : NEW_LINE INDENT curr_sum = 0 NEW_LINE min_len = n + 1 NEW_LINE start = 0 NEW_LINE end = 0 NEW_LINE while ( end < n ) : NEW_LINE INDENT while ( curr_sum <= x and end < n ) : NEW_LINE INDENT if ( curr_sum <= 0 and x > 0 ) : NEW_LINE INDENT start = end NEW_LINE curr_sum = 0 NEW_LINE DEDENT curr_sum += arr [ end ] NEW_LINE end += 1 NEW_LINE DEDENT while ( curr_sum > x and start < n ) : NEW_LINE INDENT if ( end - start < min_len ) : NEW_LINE INDENT min_len = end - start NEW_LINE DEDENT curr_sum -= arr [ start ] NEW_LINE start += 1 NEW_LINE DEDENT DEDENT return min_len NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int winner ( int a [ ] , int n , int k ) { if ( k >= n - 1 ) return n ; int best = 0 , times = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > best ) { best = a [ i ] ; if ( i ) times = 1 ; } else times += 1 ; if ( times >= k ) return best ; } return best ; }
Ref: 
def winner ( a , n , k ) : NEW_LINE INDENT if k >= n - 1 : NEW_LINE INDENT return n NEW_LINE DEDENT best = 0 NEW_LINE times = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] > best : NEW_LINE INDENT best = a [ i ] NEW_LINE if i == True : NEW_LINE INDENT times = 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT times += 1 NEW_LINE DEDENT if times >= k : NEW_LINE INDENT return best NEW_LINE DEDENT DEDENT return best NEW_LINE DEDENT
Hyp: 
def winner ( a , n , k ) : NEW_LINE INDENT if ( k >= n - 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT best = 0 NEW_LINE times = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( a [ i ] > best ) : NEW_LINE INDENT best = a [ i ] NEW_LINE if ( i ) : NEW_LINE INDENT times = 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT times += 1 NEW_LINE DEDENT if ( times >= k ) : NEW_LINE INDENT return best NEW_LINE DEDENT DEDENT return best NEW_LINE DEDENT

BLEU: 77.82
Edit Sim: 23


Src: 
bool divisibleBy20 ( string num ) { int lastTwoDigits = stoi ( num . substr ( num . length ( ) - 2 , num . length ( ) - 1 ) ) ; return ( ( lastTwoDigits % 5 == 0 ) && ( lastTwoDigits % 4 == 0 ) ) ; }
Ref: 
def divisibleBy20 ( num ) : NEW_LINE INDENT lastTwoDigits = int ( num [ - 2 : ] ) NEW_LINE return ( ( lastTwoDigits % 5 == 0 and lastTwoDigits % 4 == 0 ) ) NEW_LINE DEDENT
Hyp: 
def divisibleBy20 ( num ) : NEW_LINE INDENT lastTwoDigits = int ( num [ : - 2 ] ) NEW_LINE lastTwoDigits = int ( num [ : - 1 ] ) NEW_LINE return ( ( lastTwoDigits % 5 == 0 ) and ( lastTwoDigits % 4 == 0 ) ) NEW_LINE DEDENT

BLEU: 60.96
Edit Sim: 51


Src: 
int countSolutions ( int n ) { int x = 0 , yCount , res = 0 ; for ( yCount = 0 ; yCount * yCount < n ; yCount ++ ) ; while ( yCount != 0 ) { res += yCount ; x ++ ; while ( yCount != 0 && ( x * x + ( yCount - 1 ) * ( yCount - 1 ) >= n ) ) yCount -- ; } return res ; }
Ref: 
def countSolutions ( n ) : NEW_LINE INDENT x = 0 NEW_LINE res = 0 NEW_LINE yCount = 0 NEW_LINE while ( yCount * yCount < n ) : NEW_LINE INDENT yCount = yCount + 1 NEW_LINE DEDENT while ( yCount != 0 ) : NEW_LINE INDENT res = res + yCount NEW_LINE x = x + 1 NEW_LINE while ( yCount != 0 and ( x * x + ( yCount - 1 ) * ( yCount - 1 ) >= n ) ) : NEW_LINE INDENT yCount = yCount - 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
Hyp: 
def countSolutions ( n ) : NEW_LINE INDENT x = 0 NEW_LINE yCount = 0 NEW_LINE res = 0 NEW_LINE for yCount in range ( 0 , n ) : NEW_LINE INDENT while ( yCount * yCount < n ) : NEW_LINE INDENT yCount += 1 NEW_LINE DEDENT while ( yCount != 0 ) : NEW_LINE INDENT res += yCount NEW_LINE x += 1 NEW_LINE while ( yCount != 0 and ( x * x + ( yCount - 1 ) * ( yCount - 1 ) >= n ) : NEW_LINE INDENT yCount -= 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT

BLEU: 76.42
Edit Sim: 83


Src: 
void CountTriangles ( vector < int > A ) { int n = A . size ( ) ; sort ( A . begin ( ) , A . end ( ) ) ; int count = 0 ; for ( int i = n - 1 ; i >= 1 ; i -- ) { int l = 0 , r = i - 1 ; while ( l < r ) { if ( A [ l ] + A [ r ] > A [ i ] ) { count += r - l ; r -- ; } else l ++ ; } } cout << " No ▁ of ▁ possible ▁ solutions : ▁ " << count ; }
Ref: 
def CountTriangles ( A ) : NEW_LINE INDENT n = len ( A ) NEW_LINE A . sort ( ) NEW_LINE count = 0 NEW_LINE for i in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT l = 0 NEW_LINE r = i - 1 NEW_LINE while ( l < r ) : NEW_LINE INDENT if ( A [ l ] + A [ r ] > A [ i ] ) : NEW_LINE INDENT count += r - l NEW_LINE r -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT l += 1 NEW_LINE DEDENT DEDENT DEDENT print ( " No ▁ of ▁ possible ▁ solutions : ▁ " , count ) NEW_LINE DEDENT
Hyp: 
def CountTriangles ( A ) : NEW_LINE INDENT n = len ( A ) NEW_LINE A . sort ( ) NEW_LINE count = 0 NEW_LINE for i in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT l = 0 NEW_LINE r = i - 1 NEW_LINE while ( l < r ) : NEW_LINE INDENT if ( A [ l ] + A [ r ] > A [ i ] ) : NEW_LINE INDENT count += r - l NEW_LINE r -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT l += 1 NEW_LINE DEDENT DEDENT print ( " No ▁ of ▁ possible ▁ solutions : ▁ " , count ) NEW_LINE DEDENT

BLEU: 98.96
Edit Sim: 7


Src: 
uint_t snoob ( uint_t x ) { uint_t rightOne ; uint_t nextHigherOneBit ; uint_t rightOnesPattern ; uint_t next = 0 ; if ( x ) { rightOne = x & - ( signed ) x ; nextHigherOneBit = x + rightOne ; rightOnesPattern = x ^ nextHigherOneBit ; rightOnesPattern = ( rightOnesPattern ) / rightOne ; rightOnesPattern >>= 2 ; next = nextHigherOneBit | rightOnesPattern ; } return next ; }
Ref: 
def snoob ( x ) : NEW_LINE INDENT next = 0 NEW_LINE if ( x ) : NEW_LINE INDENT rightOne = x & - ( x ) NEW_LINE nextHigherOneBit = x + int ( rightOne ) NEW_LINE rightOnesPattern = x ^ int ( nextHigherOneBit ) NEW_LINE rightOnesPattern = ( int ( rightOnesPattern ) / int ( rightOne ) ) NEW_LINE rightOnesPattern = int ( rightOnesPattern ) >> 2 NEW_LINE next = nextHigherOneBit | rightOnesPattern NEW_LINE DEDENT return next NEW_LINE DEDENT
Hyp: 
def snoob ( x ) : NEW_LINE INDENT rightOne = 0 NEW_LINE nextHigherOneBit = 0 NEW_LINE rightOnesPattern = 0 NEW_LINE if x : NEW_LINE INDENT rightOne = x & - ( signed ) x NEW_LINE nextHigherOneBit = x + rightOne NEW_LINE rightOnesPattern = x ^ nextHigherOneBit NEW_LINE rightOnesPattern = ( rightOnesPattern ) / rightOne NEW_LINE rightOnesPattern >>= 2 NEW_LINE next = nextHigherOneBit | rightOnesPattern NEW_LINE DEDENT return next NEW_LINE DEDENT

BLEU: 52.81
Edit Sim: 132


Src: 
bool isInorder ( int arr [ ] , int n ) { if ( n == 0 || n == 1 ) return true ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i - 1 ] > arr [ i ] ) return false ; return true ; }
Ref: 
def isInorder ( arr , n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT for i in range ( 1 , n , 1 ) : NEW_LINE INDENT if ( arr [ i - 1 ] > arr [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
Hyp: 
def isInorder ( arr , n ) : NEW_LINE INDENT if n == 0 or n == 1 : NEW_LINE INDENT return True NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if arr [ i - 1 ] > arr [ i ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT

BLEU: 78.77
Edit Sim: 12


Src: 
int lis ( int arr [ ] , int n ) { int max = 1 ; _lis ( arr , n , & max ) ; return max ; }
Ref: 
def lis ( arr ) : NEW_LINE INDENT global maximum NEW_LINE n = len ( arr ) NEW_LINE maximum = 1 NEW_LINE _lis ( arr , n ) NEW_LINE return maximum NEW_LINE DEDENT
Hyp: 
def lis ( arr , n ) : NEW_LINE INDENT max = 1 NEW_LINE arr [ n ] = max NEW_LINE return max NEW_LINE DEDENT

BLEU: 31.82
Edit Sim: 71


Src: 
int maxProduct ( int arr [ ] , int n ) { if ( n < 3 ) return - 1 ; int max_product = INT_MIN ; for ( int i = 0 ; i < n - 2 ; i ++ ) for ( int j = i + 1 ; j < n - 1 ; j ++ ) for ( int k = j + 1 ; k < n ; k ++ ) max_product = max ( max_product , arr [ i ] * arr [ j ] * arr [ k ] ) ; return max_product ; }
Ref: 
def maxProduct ( arr , n ) : NEW_LINE INDENT if n < 3 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT max_product = - ( sys . maxsize - 1 ) NEW_LINE for i in range ( 0 , n - 2 ) : NEW_LINE INDENT for j in range ( i + 1 , n - 1 ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT max_product = max ( max_product , arr [ i ] * arr [ j ] * arr [ k ] ) NEW_LINE DEDENT DEDENT DEDENT return max_product NEW_LINE DEDENT
Hyp: 
def maxProduct ( arr , n ) : NEW_LINE INDENT if ( n < 3 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT max_product = - sys . maxsize - 1 NEW_LINE for i in range ( 0 , n - 2 ) : NEW_LINE INDENT for j in range ( i + 1 , n - 1 ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT max_product = max ( max_product , arr [ i ] * arr [ j ] * arr [ k ] ) NEW_LINE DEDENT DEDENT DEDENT return max_product NEW_LINE DEDENT

BLEU: 92.71
Edit Sim: 8


Src: 
void countFreq ( int a [ ] , int n ) { unordered_map < int , int > hm ; for ( int i = 0 ; i < n ; i ++ ) hm [ a [ i ] ] ++ ; set < pair < int , int > > st ; for ( auto x : hm ) { st . insert ( { x . first , x . second } ) ; } int cumul = 0 ; for ( auto x : st ) { cumul += x . second ; cout << x . first << " ▁ " << cumul << endl ; } }
Ref: 
def countFreq ( a , n ) : NEW_LINE INDENT hm = { } NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT hm [ a [ i ] ] = hm . get ( a [ i ] , 0 ) + 1 NEW_LINE DEDENT st = set ( ) NEW_LINE for x in hm : NEW_LINE INDENT st . add ( ( x , hm [ x ] ) ) NEW_LINE DEDENT cumul = 0 NEW_LINE for x in sorted ( st ) : NEW_LINE INDENT cumul += x [ 1 ] NEW_LINE print ( x [ 0 ] , cumul ) NEW_LINE DEDENT DEDENT
Hyp: 
def countFreq ( arr , n ) : NEW_LINE INDENT hm = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT hm [ arr [ i ] ] = hm . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT st = set ( ) NEW_LINE for x in hm : NEW_LINE INDENT st . add ( { x . first , x . second } ) NEW_LINE DEDENT cumul = 0 NEW_LINE for x in st : NEW_LINE INDENT cumul += x . second NEW_LINE print ( x . first , end = " ▁ " ) NEW_LINE print ( cumul ) NEW_LINE DEDENT DEDENT

BLEU: 63.1
Edit Sim: 89


Src: 
int nCrModp ( int n , int r , int p ) { int C [ r + 1 ] ; memset ( C , 0 , sizeof ( C ) ) ; C [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = min ( i , r ) ; j > 0 ; j -- ) C [ j ] = ( C [ j ] + C [ j - 1 ] ) % p ; } return C [ r ] ; }
Ref: 
def nCrModp ( n , r , p ) : NEW_LINE INDENT C = [ 0 for i in range ( r + 1 ) ] NEW_LINE C [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( min ( i , r ) , 0 , - 1 ) : NEW_LINE INDENT C [ j ] = ( C [ j ] + C [ j - 1 ] ) % p NEW_LINE DEDENT DEDENT return C [ r ] NEW_LINE DEDENT
Hyp: 
def nCrModp ( n , r , p ) : NEW_LINE INDENT C = [ 0 for i in range ( r + 1 ) ] NEW_LINE C [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( min ( i , r ) , - 1 , - 1 ) : NEW_LINE INDENT C [ j ] = ( C [ j ] + C [ j - 1 ] ) % p NEW_LINE DEDENT DEDENT return C [ r ] NEW_LINE DEDENT

BLEU: 96.43
Edit Sim: 3


Src: 
void CocktailSort ( int a [ ] , int n ) { bool swapped = true ; int start = 0 ; int end = n - 1 ; while ( swapped ) { swapped = false ; for ( int i = start ; i < end ; ++ i ) { if ( a [ i ] > a [ i + 1 ] ) { swap ( a [ i ] , a [ i + 1 ] ) ; swapped = true ; } } if ( ! swapped ) break ; swapped = false ; -- end ; for ( int i = end - 1 ; i >= start ; -- i ) { if ( a [ i ] > a [ i + 1 ] ) { swap ( a [ i ] , a [ i + 1 ] ) ; swapped = true ; } } ++ start ; } }
Ref: 
def cocktailSort ( a ) : NEW_LINE INDENT n = len ( a ) NEW_LINE swapped = True NEW_LINE start = 0 NEW_LINE end = n - 1 NEW_LINE while ( swapped == True ) : NEW_LINE INDENT swapped = False NEW_LINE for i in range ( start , end ) : NEW_LINE INDENT if ( a [ i ] > a [ i + 1 ] ) : NEW_LINE INDENT a [ i ] , a [ i + 1 ] = a [ i + 1 ] , a [ i ] NEW_LINE swapped = True NEW_LINE DEDENT DEDENT if ( swapped == False ) : NEW_LINE INDENT break NEW_LINE DEDENT swapped = False NEW_LINE end = end - 1 NEW_LINE for i in range ( end - 1 , start - 1 , - 1 ) : NEW_LINE INDENT if ( a [ i ] > a [ i + 1 ] ) : NEW_LINE INDENT a [ i ] , a [ i + 1 ] = a [ i + 1 ] , a [ i ] NEW_LINE swapped = True NEW_LINE DEDENT DEDENT start = start + 1 NEW_LINE DEDENT DEDENT
Hyp: 
def CocktailSort ( a ) : NEW_LINE INDENT swapped = True NEW_LINE start = 0 NEW_LINE end = n - 1 NEW_LINE while ( swapped ) : NEW_LINE INDENT swapped = False NEW_LINE for i in range ( start , end ) : NEW_LINE INDENT if ( a [ i ] > a [ i + 1 ] ) : NEW_LINE INDENT a [ i ] , a [ i + 1 ] = a [ i + 1 ] , a [ i ] NEW_LINE swapped = True NEW_LINE DEDENT DEDENT if ( not swapped ) : NEW_LINE INDENT break NEW_LINE DEDENT swapped = False NEW_LINE end = end - 1 NEW_LINE for i in range ( end - 1 , start , - 1 ) : NEW_LINE INDENT if ( a [ i ] > a [ i + 1 ] ) : NEW_LINE INDENT a [ i ] , a [ i + 1 ] = a [ i + 1 ] , a [ i ] NEW_LINE swapped = True NEW_LINE DEDENT DEDENT start += 1 NEW_LINE DEDENT DEDENT

BLEU: 86.46
Edit Sim: 58


Src: 
void solveWordWrap ( int arr [ ] , int n , int k ) { int i , j ; int currlen ; int cost ; int dp [ n ] ; int ans [ n ] ; dp [ n - 1 ] = 0 ; ans [ n - 1 ] = n - 1 ; for ( i = n - 2 ; i >= 0 ; i -- ) { currlen = - 1 ; dp [ i ] = INT_MAX ; for ( j = i ; j < n ; j ++ ) { currlen += ( arr [ j ] + 1 ) ; if ( currlen > k ) break ; if ( j == n - 1 ) cost = 0 ; else cost = ( k - currlen ) * ( k - currlen ) + dp [ j + 1 ] ; if ( cost < dp [ i ] ) { dp [ i ] = cost ; ans [ i ] = j ; } } } i = 0 ; while ( i < n ) { cout << i + 1 << " ▁ " << ans [ i ] + 1 << " ▁ " ; i = ans [ i ] + 1 ; } }
Ref: 
def solveWordWrap ( arr , n , k ) : NEW_LINE INDENT dp = [ 0 ] * n NEW_LINE ans = [ 0 ] * n NEW_LINE dp [ n - 1 ] = 0 NEW_LINE ans [ n - 1 ] = n - 1 NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT currlen = - 1 NEW_LINE dp [ i ] = sys . maxsize NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT currlen += ( arr [ j ] + 1 ) NEW_LINE if ( currlen > k ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( j == n - 1 ) : NEW_LINE INDENT cost = 0 NEW_LINE DEDENT else : NEW_LINE INDENT cost = ( ( k - currlen ) * ( k - currlen ) + dp [ j + 1 ] ) NEW_LINE DEDENT if ( cost < dp [ i ] ) : NEW_LINE INDENT dp [ i ] = cost NEW_LINE ans [ i ] = j NEW_LINE DEDENT DEDENT DEDENT i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT print ( i + 1 , ans [ i ] + 1 , end = " ▁ " ) NEW_LINE i = ans [ i ] + 1 NEW_LINE DEDENT DEDENT
Hyp: 
def solveWordWrap ( arr , n , k ) : NEW_LINE INDENT dp = [ 0 ] * ( n + 1 ) NEW_LINE ans = [ 0 ] * ( n + 1 ) NEW_LINE dp [ n - 1 ] = 0 NEW_LINE ans [ n - 1 ] = n - 1 NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT currlen = - 1 NEW_LINE dp [ i ] = sys . maxsize NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT currlen += ( arr [ j ] + 1 ) NEW_LINE if currlen > k : NEW_LINE INDENT break NEW_LINE DEDENT if j == n - 1 : NEW_LINE INDENT cost = 0 NEW_LINE DEDENT else : NEW_LINE INDENT cost = ( k - currlen ) * ( k - currlen ) + dp [ j + 1 ] NEW_LINE DEDENT if cost < dp [ i ] : NEW_LINE INDENT dp [ i ] = cost NEW_LINE ans [ i ] = j NEW_LINE DEDENT DEDENT DEDENT i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT print ( i + 1 , end = " ▁ " ) NEW_LINE i = ans [ i ] + 1 NEW_LINE DEDENT DEDENT

BLEU: 87.42
Edit Sim: 48


Src: 
int binarySearch ( int arr [ ] , int l , int r , int x ) { while ( l <= r ) { int m = l + ( r - l ) / 2 ; if ( arr [ m ] == x ) return m ; if ( arr [ m ] < x ) l = m + 1 ; else r = m - 1 ; } return - 1 ; }
Ref: 
def binarySearch ( arr , l , r , x ) : NEW_LINE INDENT while l <= r : NEW_LINE INDENT mid = l + ( r - l ) // 2 NEW_LINE if arr [ mid ] == x : NEW_LINE INDENT return mid NEW_LINE DEDENT elif arr [ mid ] < x : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT r = mid - 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
Hyp: 
def binarySearch ( arr , l , r , x ) : NEW_LINE INDENT while ( l <= r ) : NEW_LINE INDENT m = l + ( r - l ) // 2 NEW_LINE if ( arr [ m ] == x ) : NEW_LINE INDENT return m NEW_LINE DEDENT if ( arr [ m ] < x ) : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT else : NEW_LINE INDENT r = m - 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT

BLEU: 63.12
Edit Sim: 26


Src: 
int minXOR ( int arr [ ] , int n ) { int min_xor = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) min_xor = min ( min_xor , arr [ i ] ^ arr [ j ] ) ; return min_xor ; }
Ref: 
def minXOR ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE min_xor = 999999 NEW_LINE val = 0 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n - 1 ) : NEW_LINE INDENT val = arr [ i ] ^ arr [ j ] NEW_LINE min_xor = min ( min_xor , val ) NEW_LINE DEDENT DEDENT return min_xor NEW_LINE DEDENT
Hyp: 
def minXOR ( arr , n ) : NEW_LINE INDENT min_xor = sys . maxsize NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT min_xor = min ( min_xor , arr [ i ] ^ arr [ j ] ) NEW_LINE DEDENT DEDENT return min_xor NEW_LINE DEDENT

BLEU: 61.49
Edit Sim: 100


Src: 
int sumofFactors ( int n ) { if ( n % 2 != 0 ) return 0 ; int res = 1 ; for ( int i = 2 ; i <= sqrt ( n ) ; i ++ ) { int count = 0 , curr_sum = 1 , curr_term = 1 ; while ( n % i == 0 ) { count ++ ; n = n / i ; if ( i == 2 && count == 1 ) curr_sum = 0 ; curr_term *= i ; curr_sum += curr_term ; } res *= curr_sum ; } if ( n >= 2 ) res *= ( 1 + n ) ; return res ; }
Ref: 
def sumofFactors ( n ) : NEW_LINE INDENT if ( n % 2 != 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT res = 1 NEW_LINE for i in range ( 2 , ( int ) ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT count = 0 NEW_LINE curr_sum = 1 NEW_LINE curr_term = 1 NEW_LINE while ( n % i == 0 ) : NEW_LINE INDENT count = count + 1 NEW_LINE n = n // i NEW_LINE if ( i == 2 and count == 1 ) : NEW_LINE INDENT curr_sum = 0 NEW_LINE DEDENT curr_term = curr_term * i NEW_LINE curr_sum = curr_sum + curr_term NEW_LINE DEDENT res = res * curr_sum NEW_LINE DEDENT if ( n >= 2 ) : NEW_LINE INDENT res = res * ( 1 + n ) NEW_LINE DEDENT return res NEW_LINE DEDENT
Hyp: 
def sumofFactors ( n ) : NEW_LINE INDENT if ( n % 2 != 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT res = 1 NEW_LINE for i in range ( 2 , int ( m . sqrt ( n ) + 1 ) ) : NEW_LINE INDENT count = 0 NEW_LINE curr_sum = 1 NEW_LINE curr_term = 1 NEW_LINE while ( n % i == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE n = n / i NEW_LINE if ( i == 2 and count == 1 ) : NEW_LINE INDENT curr_sum = 0 NEW_LINE DEDENT curr_term = curr_term * i NEW_LINE curr_sum += curr_term NEW_LINE DEDENT res = res * curr_sum NEW_LINE DEDENT if ( n > 2 ) : NEW_LINE INDENT res = res * ( 1 + n ) NEW_LINE DEDENT return res NEW_LINE DEDENT

BLEU: 84.79
Edit Sim: 33


Src: 
char first ( string str , int i = 0 ) { if ( str [ i ] == ' \0' ) return 0 ; if ( isupper ( str [ i ] ) ) return str [ i ] ; return first ( str , i + 1 ) ; }
Ref: 
def first ( str , i ) : NEW_LINE INDENT if ( str [ i ] == ' \0' ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( str [ i ] . isupper ( ) ) : NEW_LINE INDENT return str [ i ] NEW_LINE DEDENT return first ( str , i + 1 ) NEW_LINE DEDENT
Hyp: 
def first ( str , i ) : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( str [ i ] . isupper ( ) ) : NEW_LINE INDENT return str [ i ] NEW_LINE DEDENT return first ( str , i + 1 ) ; NEW_LINE DEDENT

BLEU: 83.89
Edit Sim: 14


Src: 
int maxGameByWinner ( int N ) { int dp [ N ] ; dp [ 0 ] = 1 ; dp [ 1 ] = 2 ; int i = 2 ; do { dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] ; } while ( dp [ i ++ ] <= N ) ; return ( i - 2 ) ; }
Ref: 
def maxGameByWinner ( N ) : NEW_LINE INDENT dp = [ 0 for i in range ( N ) ] NEW_LINE dp [ 0 ] = 1 NEW_LINE dp [ 1 ] = 2 NEW_LINE i = 1 NEW_LINE while dp [ i ] <= N : NEW_LINE INDENT i = i + 1 NEW_LINE dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] NEW_LINE DEDENT return ( i - 1 ) NEW_LINE DEDENT
Hyp: 
def maxGameByWinner ( N ) : NEW_LINE INDENT dp = [ 0 for i in range ( N ) ] NEW_LINE dp [ 0 ] = 1 NEW_LINE dp [ 1 ] = 2 NEW_LINE i = 2 NEW_LINE do : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] NEW_LINE i += 1 NEW_LINE DEDENT return ( i - 2 ) NEW_LINE DEDENT

BLEU: 74.98
Edit Sim: 51


Src: 
int equilibrium ( int arr [ ] , int n ) { int sum = 0 ; int leftsum = 0 ; for ( int i = 0 ; i < n ; ++ i ) sum += arr [ i ] ; for ( int i = 0 ; i < n ; ++ i ) { sum -= arr [ i ] ; if ( leftsum == sum ) return i ; leftsum += arr [ i ] ; } return - 1 ; }
Ref: 
def equilibrium ( arr ) : NEW_LINE INDENT total_sum = sum ( arr ) NEW_LINE leftsum = 0 NEW_LINE for i , num in enumerate ( arr ) : NEW_LINE INDENT total_sum -= num NEW_LINE if leftsum == total_sum : NEW_LINE INDENT return i NEW_LINE DEDENT leftsum += num NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
Hyp: 
def equilibrium ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE leftsum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT sum -= arr [ i ] NEW_LINE if ( leftsum == sum ) : NEW_LINE INDENT return i NEW_LINE DEDENT leftsum += arr [ i ] NEW_LINE DEDENT return - 1 NEW_LINE DEDENT

BLEU: 36.73
Edit Sim: 123


Src: 
double procal ( int n ) { return ( 3.0 * n ) / ( 4.0 * ( n * n ) - 1 ) ; }
Ref: 
def procal ( n ) : NEW_LINE INDENT return ( 3.0 * n ) / ( 4.0 * ( n * n ) - 1 ) NEW_LINE DEDENT
Hyp: 
def procal ( n ) : NEW_LINE INDENT return ( 3.0 * n ) / ( 4.0 * ( n * n ) - 1 ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
void rearrange ( int arr [ ] , int n ) { int temp [ n ] ; int small = 0 , large = n - 1 ; int flag = true ; for ( int i = 0 ; i < n ; i ++ ) { if ( flag ) temp [ i ] = arr [ large -- ] ; else temp [ i ] = arr [ small ++ ] ; flag = ! flag ; } for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = temp [ i ] ; }
Ref: 
def rearrange ( arr , n ) : NEW_LINE INDENT temp = n * [ None ] NEW_LINE small , large = 0 , n - 1 NEW_LINE flag = True NEW_LINE for i in range ( n ) : NEW_LINE INDENT if flag is True : NEW_LINE INDENT temp [ i ] = arr [ large ] NEW_LINE large -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT temp [ i ] = arr [ small ] NEW_LINE small += 1 NEW_LINE DEDENT flag = bool ( 1 - flag ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = temp [ i ] NEW_LINE DEDENT return arr NEW_LINE DEDENT
Hyp: 
def rearrange ( arr , n ) : NEW_LINE INDENT temp = [ 0 ] * n NEW_LINE small = 0 NEW_LINE large = n - 1 NEW_LINE flag = True NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( flag ) : NEW_LINE INDENT temp [ i ] = arr [ large -= 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT temp [ i ] = arr [ small ] NEW_LINE DEDENT flag = not flag NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT arr [ i ] = temp [ i ] NEW_LINE DEDENT DEDENT

BLEU: 68.2
Edit Sim: 111


Src: 
void greatest ( string s ) { int n = s . length ( ) ; int a [ n ] ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = s [ i ] - '0' ; sum += a [ i ] ; } if ( a [ n - 1 ] % 2 ) { if ( a [ n - 2 ] % 2 != 0 or ( sum - a [ n - 1 ] ) % 3 != 0 ) { cout << " - 1" << endl ; } else { cout << n << endl ; } } else { int re = sum % 3 ; int del = - 1 ; int flag = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( ( a [ i ] ) % 3 == re ) { if ( a [ i + 1 ] > a [ i ] ) { del = i ; flag = 1 ; break ; } else { del = i ; } } } if ( flag == 0 ) { if ( a [ n - 2 ] % 2 == 0 and re == a [ n - 1 ] % 3 ) del = n - 1 ; } if ( del == - 1 ) cout << - 1 << endl ; else { cout << del + 1 << endl ; } } }
Ref: 
def greatest ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE a = [ 0 for i in range ( n ) ] NEW_LINE Sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT a [ i ] = ord ( s [ i ] ) - ord ( '0' ) NEW_LINE Sum += a [ i ] NEW_LINE DEDENT if ( a [ n - 1 ] % 2 ) : NEW_LINE INDENT if ( a [ n - 2 ] % 2 != 0 or ( Sum - a [ n - 1 ] ) % 3 != 0 ) : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT re = Sum % 3 NEW_LINE dell = - 1 NEW_LINE flag = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( ( a [ i ] ) % 3 == re ) : NEW_LINE INDENT if ( a [ i + 1 ] > a [ i ] ) : NEW_LINE INDENT dell = i NEW_LINE flag = 1 NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT dell = i NEW_LINE DEDENT DEDENT DEDENT if ( flag == 0 ) : NEW_LINE INDENT if ( a [ n - 2 ] % 2 == 0 and re == a [ n - 1 ] % 3 ) : NEW_LINE INDENT dell = n - 1 NEW_LINE DEDENT DEDENT if ( dell == - 1 ) : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( dell + 1 ) NEW_LINE DEDENT DEDENT DEDENT
Hyp: 
def greatest ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE a = [ 0 ] * n NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT a [ i ] = ord ( s [ i ] ) - ord ( '0' ) NEW_LINE sum += a [ i ] NEW_LINE DEDENT if a [ n - 1 ] % 2 : NEW_LINE INDENT if a [ n - 2 ] % 2 != 0 or sum - a [ n - 1 ] % 3 != 0 : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT re = sum % 3 NEW_LINE del = - 1 NEW_LINE flag = 0 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( a [ i ] ) % 3 == re ) : NEW_LINE INDENT if ( a [ i + 1 ] > a [ i ] ) : NEW_LINE INDENT del = i NEW_LINE flag = 1 NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT del = i NEW_LINE DEDENT DEDENT DEDENT if ( flag == 0 ) : NEW_LINE INDENT if ( a [ n - 2 ] % 2 == 0 and re == a [ n - 1 ] % 3 ) : NEW_LINE INDENT del = n - 1 NEW_LINE DEDENT DEDENT if ( del == - 1 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( del + 1 ) NEW_LINE DEDENT DEDENT DEDENT

BLEU: 81.39
Edit Sim: 50


Src: 
int isChangeable ( int notes [ ] , int n ) { int fiveCount = 0 ; int tenCount = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( notes [ i ] == 5 ) fiveCount ++ ; else if ( notes [ i ] == 10 ) { if ( fiveCount > 0 ) { fiveCount -- ; tenCount ++ ; } else return 0 ; } else { if ( fiveCount > 0 && tenCount > 0 ) { fiveCount -- ; tenCount -- ; } else if ( fiveCount >= 3 ) { fiveCount -= 3 ; } else return 0 ; } } return 1 ; }
Ref: 
def isChangeable ( notes , n ) : NEW_LINE INDENT fiveCount = 0 NEW_LINE tenCount = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( notes [ i ] == 5 ) : NEW_LINE INDENT fiveCount += 1 NEW_LINE DEDENT elif ( notes [ i ] == 10 ) : NEW_LINE INDENT if ( fiveCount > 0 ) : NEW_LINE INDENT fiveCount -= 1 NEW_LINE tenCount += 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( fiveCount > 0 and tenCount > 0 ) : NEW_LINE INDENT fiveCount -= 1 NEW_LINE tenCount -= 1 NEW_LINE DEDENT elif ( fiveCount >= 3 ) : NEW_LINE INDENT fiveCount -= 3 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT DEDENT return 1 NEW_LINE DEDENT
Hyp: 
def isChangeable ( notes ) : NEW_LINE INDENT fiveCount = 0 NEW_LINE tenCount = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( notes [ i ] == 5 ) : NEW_LINE INDENT fiveCount += 1 NEW_LINE DEDENT elif ( notes [ i ] == 10 ) : NEW_LINE INDENT if ( fiveCount > 0 ) : NEW_LINE INDENT fiveCount -= 1 NEW_LINE tenCount += 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( fiveCount > 0 and tenCount > 0 ) : NEW_LINE INDENT fiveCount -= 1 NEW_LINE tenCount -= 1 NEW_LINE DEDENT elif ( fiveCount >= 3 ) : NEW_LINE INDENT fiveCount -= 3 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT DEDENT return 1 NEW_LINE DEDENT

BLEU: 97.44
Edit Sim: 4


Src: 
int LCSubStr ( char * X , char * Y , int m , int n ) { int LCSuff [ m + 1 ] [ n + 1 ] ; int result = 0 ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 || j == 0 ) LCSuff [ i ] [ j ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) { LCSuff [ i ] [ j ] = LCSuff [ i - 1 ] [ j - 1 ] + 1 ; result = max ( result , LCSuff [ i ] [ j ] ) ; } else LCSuff [ i ] [ j ] = 0 ; } } return result ; }
Ref: 
def LCSubStr ( X , Y , m , n ) : NEW_LINE INDENT LCSuff = [ [ 0 for k in range ( n + 1 ) ] for l in range ( m + 1 ) ] NEW_LINE result = 0 NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if ( i == 0 or j == 0 ) : NEW_LINE INDENT LCSuff [ i ] [ j ] = 0 NEW_LINE DEDENT elif ( X [ i - 1 ] == Y [ j - 1 ] ) : NEW_LINE INDENT LCSuff [ i ] [ j ] = LCSuff [ i - 1 ] [ j - 1 ] + 1 NEW_LINE result = max ( result , LCSuff [ i ] [ j ] ) NEW_LINE DEDENT else : NEW_LINE INDENT LCSuff [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
Hyp: 
def LCSubStr ( X , Y , m , n ) : NEW_LINE INDENT LCSuff = [ [ 0 for x in range ( n + 1 ) ] for y in range ( m + 1 ) ] NEW_LINE result = 0 NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if ( i == 0 | j == 0 ) : NEW_LINE INDENT LCSuff [ i ] [ j ] = 0 NEW_LINE DEDENT elif ( X [ i - 1 ] == Y [ j - 1 ] ) : NEW_LINE INDENT LCSuff [ i ] [ j ] = LCSuff [ i - 1 ] [ j - 1 ] + 1 NEW_LINE result = max ( result , LCSuff [ i ] [ j ] ) NEW_LINE DEDENT else : NEW_LINE INDENT LCSuff [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT

BLEU: 95.54
Edit Sim: 4


Src: 
int maxSumWO3Consec ( int n ) { if ( sum [ n ] != - 1 ) return sum [ n ] ; if ( n == 0 ) return sum [ n ] = 0 ; if ( n == 1 ) return sum [ n ] = arr [ 0 ] ; if ( n == 2 ) return sum [ n ] = arr [ 1 ] + arr [ 0 ] ; return sum [ n ] = max ( max ( maxSumWO3Consec ( n - 1 ) , maxSumWO3Consec ( n - 2 ) + arr [ n - 1 ] ) , arr [ n - 2 ] + arr [ n - 1 ] + maxSumWO3Consec ( n - 3 ) ) ; }
Ref: 
def maxSumWO3Consec ( n ) : NEW_LINE INDENT if ( sum [ n ] != - 1 ) : NEW_LINE INDENT return sum [ n ] NEW_LINE DEDENT if ( n == 0 ) : NEW_LINE INDENT sum [ n ] = 0 NEW_LINE return sum [ n ] NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT sum [ n ] = arr [ 0 ] NEW_LINE return sum [ n ] NEW_LINE DEDENT if ( n == 2 ) : NEW_LINE INDENT sum [ n ] = arr [ 1 ] + arr [ 0 ] NEW_LINE return sum [ n ] NEW_LINE DEDENT sum [ n ] = max ( max ( maxSumWO3Consec ( n - 1 ) , maxSumWO3Consec ( n - 2 ) + arr [ n - 1 ] ) , arr [ n - 2 ] + arr [ n - 1 ] + maxSumWO3Consec ( n - 3 ) ) NEW_LINE return sum [ n ] NEW_LINE DEDENT
Hyp: 
def maxSumWO3Consec ( n ) : NEW_LINE INDENT if ( sum [ n ] != - 1 ) : NEW_LINE INDENT return sum [ n ] NEW_LINE DEDENT if ( n == 0 ) : NEW_LINE INDENT sum [ n ] = 0 NEW_LINE if ( n == 1 ) : NEW_LINE INDENT sum [ n ] = arr [ 0 ] NEW_LINE if ( n == 2 ) : NEW_LINE INDENT sum [ n ] = arr [ 1 ] + arr [ 0 ] NEW_LINE DEDENT return sum [ n ] NEW_LINE DEDENT

BLEU: 43.98
Edit Sim: 259


Src: 
int findMinZero ( int p ) { int first = 1 , second = 1 , number = 2 , next = 1 ; while ( next ) { next = ( first + second ) % p ; first = second ; second = next ; number ++ ; } return number ; }
Ref: 
def findMinZero ( p ) : NEW_LINE INDENT first = 1 NEW_LINE second = 1 NEW_LINE number = 2 NEW_LINE next = 1 NEW_LINE while ( next ) : NEW_LINE INDENT next = ( first + second ) % p NEW_LINE first = second NEW_LINE second = next NEW_LINE number = number + 1 NEW_LINE DEDENT return number NEW_LINE DEDENT
Hyp: 
def findMinZero ( p ) : NEW_LINE INDENT first = 1 NEW_LINE second = 1 NEW_LINE number = 2 NEW_LINE next = 1 NEW_LINE while ( next ) : NEW_LINE INDENT next = ( first + second ) % p NEW_LINE first = second NEW_LINE second = next NEW_LINE number += 1 NEW_LINE DEDENT return number NEW_LINE DEDENT

BLEU: 92.35
Edit Sim: 10


Src: 
void reorder ( int arr [ ] , int index [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { while ( index [ i ] != i ) { int oldTargetI = index [ index [ i ] ] ; char oldTargetE = arr [ index [ i ] ] ; arr [ index [ i ] ] = arr [ i ] ; index [ index [ i ] ] = index [ i ] ; index [ i ] = oldTargetI ; arr [ i ] = oldTargetE ; } } }
Ref: 
def reorder ( arr , index , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT while ( index [ i ] != i ) : NEW_LINE INDENT oldTargetI = index [ index [ i ] ] NEW_LINE oldTargetE = arr [ index [ i ] ] NEW_LINE arr [ index [ i ] ] = arr [ i ] NEW_LINE index [ index [ i ] ] = index [ i ] NEW_LINE index [ i ] = oldTargetI NEW_LINE arr [ i ] = oldTargetE NEW_LINE DEDENT DEDENT DEDENT
Hyp: 
def reorder ( arr , index , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT while ( index [ i ] != i ) : NEW_LINE INDENT oldTargetI = index [ index [ i ] ] NEW_LINE oldTargetE = arr [ index [ i ] ] NEW_LINE arr [ index [ i ] ] = arr [ i ] NEW_LINE index [ i ] ] = index [ i ] NEW_LINE arr [ index [ i ] ] = oldTargetE NEW_LINE DEDENT DEDENT DEDENT

BLEU: 86.89
Edit Sim: 44


Src: 
int longestNull ( string str ) { vector < pair < char , int > > arr ; arr . push_back ( { ' @ ' , - 1 } ) ; int maxlen = 0 ; for ( int i = 0 ; i < str . length ( ) ; ++ i ) { arr . push_back ( { str [ i ] , i } ) ; while ( arr . size ( ) >= 3 && arr [ arr . size ( ) - 3 ] . first == '1' && arr [ arr . size ( ) - 2 ] . first == '0' && arr [ arr . size ( ) - 1 ] . first == '0' ) { arr . pop_back ( ) ; arr . pop_back ( ) ; arr . pop_back ( ) ; } int tmp = arr . back ( ) . second ; maxlen = max ( maxlen , i - tmp ) ; } return maxlen ; }
Ref: 
def longestNull ( S ) : NEW_LINE INDENT arr = [ ] NEW_LINE arr . append ( [ ' @ ' , - 1 ] ) NEW_LINE maxlen = 0 NEW_LINE for i in range ( len ( S ) ) : NEW_LINE INDENT arr . append ( [ S [ i ] , i ] ) NEW_LINE while ( len ( arr ) >= 3 and arr [ len ( arr ) - 3 ] [ 0 ] == '1' and arr [ len ( arr ) - 2 ] [ 0 ] == '0' and arr [ len ( arr ) - 1 ] [ 0 ] == '0' ) : NEW_LINE INDENT arr . pop ( ) NEW_LINE arr . pop ( ) NEW_LINE arr . pop ( ) NEW_LINE DEDENT tmp = arr [ - 1 ] NEW_LINE maxlen = max ( maxlen , i - tmp [ 1 ] ) NEW_LINE DEDENT return maxlen NEW_LINE DEDENT
Hyp: 
def longestNull ( str ) : NEW_LINE INDENT arr = [ ] NEW_LINE maxlen = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT arr . append ( ( ' @ ' , - 1 ) ) NEW_LINE maxlen = max ( maxlen , i ) NEW_LINE DEDENT for i in range ( len ( str ) ) : NEW_LINE INDENT arr . append ( ( str [ i ] , i ) ) NEW_LINE while ( len ( arr ) >= 3 and arr [ len ( arr ) - 3 ] . first == '1' and arr [ len ( arr ) - 2 ] . first == '0' and arr [ len ( arr ) - 1 ] . first == '0' ) ) : NEW_LINE INDENT arr . pop ( ) NEW_LINE arr . pop ( ) NEW_LINE DEDENT tmp = arr [ - 1 ] NEW_LINE maxlen = max ( maxlen , i - tmp ) NEW_LINE DEDENT return maxlen NEW_LINE DEDENT

BLEU: 68.68
Edit Sim: 156


Src: 
int calculateSum ( int n ) { if ( n <= 0 ) return 0 ; int fibo [ n + 1 ] ; fibo [ 0 ] = 0 , fibo [ 1 ] = 1 ; int sum = fibo [ 0 ] + fibo [ 1 ] ; for ( int i = 2 ; i <= n ; i ++ ) { fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ; sum += fibo [ i ] ; } return sum ; }
Ref: 
def calculateSum ( n ) : NEW_LINE INDENT if ( n <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT fibo = [ 0 ] * ( n + 1 ) NEW_LINE fibo [ 1 ] = 1 NEW_LINE sm = fibo [ 0 ] + fibo [ 1 ] NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] NEW_LINE sm = sm + fibo [ i ] NEW_LINE DEDENT return sm NEW_LINE DEDENT
Hyp: 
def calculateSum ( n ) : NEW_LINE INDENT if ( n <= 0 ) : return 0 NEW_LINE DEDENT fibo = [ 0 ] * ( n + 1 ) NEW_LINE fibo [ 0 ] = 0 NEW_LINE fibo [ 1 ] = 1 NEW_LINE sum = fibo [ 0 ] + fibo [ 1 ] NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] NEW_LINE sum += fibo [ i ] NEW_LINE DEDENT return sum NEW_LINE DEDENT

BLEU: 83.79
Edit Sim: 48


Src: 
INT_MAX int shortestPath ( int graph [ ] [ V ] , int u , int v , int k ) { if ( k == 0 && u == v ) return 0 ; if ( k == 1 && graph [ u ] [ v ] != INF ) return graph [ u ] [ v ] ; if ( k <= 0 ) return INF ; int res = INF ; for ( int i = 0 ; i < V ; i ++ ) { if ( graph [ u ] [ i ] != INF && u != i && v != i ) { int rec_res = shortestPath ( graph , i , v , k - 1 ) ; if ( rec_res != INF ) res = min ( res , graph [ u ] [ i ] + rec_res ) ; } } return res ; }
Ref: 
def shortestPath ( graph , u , v , k ) : NEW_LINE INDENT V = 4 NEW_LINE INF = 999999999999 NEW_LINE if k == 0 and u == v : NEW_LINE INDENT return 0 NEW_LINE DEDENT if k == 1 and graph [ u ] [ v ] != INF : NEW_LINE INDENT return graph [ u ] [ v ] NEW_LINE DEDENT if k <= 0 : NEW_LINE INDENT return INF NEW_LINE DEDENT res = INF NEW_LINE for i in range ( V ) : NEW_LINE INDENT if graph [ u ] [ i ] != INF and u != i and v != i : NEW_LINE INDENT rec_res = shortestPath ( graph , i , v , k - 1 ) NEW_LINE if rec_res != INF : NEW_LINE INDENT res = min ( res , graph [ u ] [ i ] + rec_res ) NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT
Hyp: 
def shortestPath ( graph , u , v , k ) : NEW_LINE INDENT if ( k == 0 and u == v ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( k == 1 and graph [ u ] [ v ] != INF ) : NEW_LINE INDENT return graph [ u ] [ v ] NEW_LINE DEDENT if ( k <= 0 ) : NEW_LINE INDENT return INF NEW_LINE DEDENT res = INF NEW_LINE for i in range ( V ) : NEW_LINE INDENT if ( graph [ u ] [ i ] != INF and u != i and v != i ) : NEW_LINE INDENT rec_res = shortestPath ( graph , i , v , k - 1 ) NEW_LINE if ( rec_res != INF ) : NEW_LINE INDENT res = min ( res , graph [ u ] [ i ] + rec_res ) NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT

BLEU: 83.27
Edit Sim: 62


Src: 
int sumofsquare ( int n ) { int C [ n + 1 ] [ n + 1 ] ; int i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= min ( i , n ) ; j ++ ) { if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } int sum = 0 ; for ( int i = 0 ; i <= n ; i ++ ) sum += ( C [ n ] [ i ] * C [ n ] [ i ] ) ; return sum ; }
Ref: 
def sumofsquare ( n ) : NEW_LINE INDENT C = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT for j in range ( 0 , min ( i , n ) + 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT sum = 0 NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT sum = sum + ( C [ n ] [ i ] * C [ n ] [ i ] ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
Hyp: 
def sumofsquare ( n ) : NEW_LINE INDENT C = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( min ( i , n ) + 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT sum = 0 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT sum += ( C [ n ] [ i ] * C [ n ] [ i ] ) NEW_LINE DEDENT return sum NEW_LINE DEDENT

BLEU: 88.29
Edit Sim: 23


Src: 
void constructArr ( int arr [ ] , int pair [ ] , int n ) { arr [ 0 ] = ( pair [ 0 ] + pair [ 1 ] - pair [ n - 1 ] ) / 2 ; for ( int i = 1 ; i < n ; i ++ ) arr [ i ] = pair [ i - 1 ] - arr [ 0 ] ; }
Ref: 
def constructArr ( arr , pair , n ) : NEW_LINE INDENT arr [ 0 ] = ( pair [ 0 ] + pair [ 1 ] - pair [ n - 1 ] ) // 2 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT arr [ i ] = pair [ i - 1 ] - arr [ 0 ] NEW_LINE DEDENT DEDENT
Hyp: 
def constructArr ( arr , pair , n ) : NEW_LINE INDENT arr [ 0 ] = ( pair [ 0 ] + pair [ 1 ] - pair [ n - 1 ] ) / 2 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT arr [ i ] = ( pair [ i - 1 ] - arr [ 0 ] ) NEW_LINE DEDENT DEDENT

BLEU: 89.15
Edit Sim: 5


Src: 
int patternCount ( string str ) { char last = str [ 0 ] ; int i = 1 , counter = 0 ; while ( i < str . size ( ) ) { if ( str [ i ] == '0' && last == '1' ) { while ( str [ i ] == '0' ) i ++ ; if ( str [ i ] == '1' ) counter ++ ; } last = str [ i ] ; i ++ ; } return counter ; }
Ref: 
def patternCount ( str ) : NEW_LINE INDENT last = str [ 0 ] NEW_LINE i = 1 counter = 0 NEW_LINE while ( i < len ( str ) ) : NEW_LINE INDENT if ( str [ i ] == '0' and last == '1' ) : NEW_LINE INDENT while ( str [ i ] == '0' ) : NEW_LINE INDENT i += 1 NEW_LINE if ( str [ i ] == '1' ) : NEW_LINE INDENT counter += 1 NEW_LINE DEDENT DEDENT DEDENT last = str [ i ] NEW_LINE i += 1 NEW_LINE DEDENT return counter NEW_LINE DEDENT
Hyp: 
def patternCount ( s ) : NEW_LINE INDENT last = s [ 0 ] NEW_LINE i = 1 NEW_LINE counter = 0 NEW_LINE while ( i < len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == '0' and last == '1' ) : NEW_LINE INDENT while ( s [ i ] == '0' ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT counter += 1 NEW_LINE DEDENT DEDENT last = s [ i ] NEW_LINE i += 1 NEW_LINE DEDENT return counter NEW_LINE DEDENT

BLEU: 77.25
Edit Sim: 37


Src: 
int findFrequency ( int arr [ ] , int n , int left , int right , int element ) { int count = 0 ; for ( int i = left - 1 ; i <= right ; ++ i ) if ( arr [ i ] == element ) ++ count ; return count ; }
Ref: 
def findFrequency ( arr , n , left , right , element ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( left - 1 , right ) : NEW_LINE INDENT if ( arr [ i ] == element ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
Hyp: 
def findFrequency ( arr , n , left , right , element ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( left - 1 , right + 1 ) : NEW_LINE INDENT if ( arr [ i ] == element ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT

BLEU: 86.39
Edit Sim: 13


Src: 
void parabola ( float a , float b , float c ) { cout << " Vertex : ▁ ( " << ( - b / ( 2 * a ) ) << " , ▁ " << ( ( ( 4 * a * c ) - ( b * b ) ) / ( 4 * a ) ) << " ) " << endl ; cout << " Focus : ▁ ( " << ( - b / ( 2 * a ) ) << " , ▁ " << ( ( ( 4 * a * c ) - ( b * b ) + 1 ) / ( 4 * a ) ) << " ) " << endl ; cout << " Directrix : ▁ y = " << c - ( ( b * b ) + 1 ) * 4 * a << endl ; }
Ref: 
def parabola ( a , b , c ) : NEW_LINE INDENT print ( " Vertex : ▁ ( " , ( - b / ( 2 * a ) ) , " , ▁ " , ( ( ( 4 * a * c ) - ( b * b ) ) / ( 4 * a ) ) , " ) " , sep = " " ) NEW_LINE print ( " Focus : ▁ ( " , ( - b / ( 2 * a ) ) , " , ▁ " , ( ( ( 4 * a * c ) - ( b * b ) + 1 ) / ( 4 * a ) ) , " ) " , sep = " " ) NEW_LINE print ( " Directrix : ▁ y = " , c - ( ( b * b ) + 1 ) * 4 * a , sep = " " ) NEW_LINE DEDENT
Hyp: 
def parabola ( a , b , c ) : NEW_LINE INDENT print ( " Vertex : ▁ ( " , ( - b / ( 2 * a ) ) , " , ▁ " , ( ( 4 * a * c ) - ( b * b ) ) / ( 4 * a ) ) , " ) " , endl ) NEW_LINE print ( " Focus : ▁ ( " , ( - b / ( 2 * a ) ) , " , ▁ " , ( ( 4 * a * c ) - ( b * b ) + 1 ) / ( 4 * a ) ) , " ) " , endl ) NEW_LINE print ( " Directrix : ▁ y = " , c - ( ( b * b ) + 1 ) * 4 * a ) NEW_LINE print ( " Directrix : ▁ y = " , c - ( ( b * b ) + 1 ) * 4 * a ) NEW_LINE DEDENT

BLEU: 81.97
Edit Sim: 85


Src: 
int minproduct ( int a [ ] , int b [ ] , int n , int k ) { int diff = 0 , res = 0 ; int temp ; for ( int i = 0 ; i < n ; i ++ ) { int pro = a [ i ] * b [ i ] ; res = res + pro ; if ( pro < 0 && b [ i ] < 0 ) temp = ( a [ i ] + 2 * k ) * b [ i ] ; else if ( pro < 0 && a [ i ] < 0 ) temp = ( a [ i ] - 2 * k ) * b [ i ] ; else if ( pro > 0 && a [ i ] < 0 ) temp = ( a [ i ] + 2 * k ) * b [ i ] ; else if ( pro > 0 && a [ i ] > 0 ) temp = ( a [ i ] - 2 * k ) * b [ i ] ; int d = abs ( pro - temp ) ; if ( d > diff ) diff = d ; } return res - diff ; }
Ref: 
def minproduct ( a , b , n , k ) : NEW_LINE INDENT diff = 0 NEW_LINE res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT pro = a [ i ] * b [ i ] NEW_LINE res = res + pro NEW_LINE if ( pro < 0 and b [ i ] < 0 ) : NEW_LINE INDENT temp = ( a [ i ] + 2 * k ) * b [ i ] NEW_LINE DEDENT elif ( pro < 0 and a [ i ] < 0 ) : NEW_LINE INDENT temp = ( a [ i ] - 2 * k ) * b [ i ] NEW_LINE DEDENT elif ( pro > 0 and a [ i ] < 0 ) : NEW_LINE INDENT temp = ( a [ i ] + 2 * k ) * b [ i ] NEW_LINE DEDENT elif ( pro > 0 and a [ i ] > 0 ) : NEW_LINE INDENT temp = ( a [ i ] - 2 * k ) * b [ i ] NEW_LINE DEDENT d = abs ( pro - temp ) NEW_LINE if ( d > diff ) : NEW_LINE INDENT diff = d NEW_LINE DEDENT DEDENT return res - diff NEW_LINE DEDENT
Hyp: 
def minproduct ( a , b , n , k ) : NEW_LINE INDENT diff = 0 NEW_LINE res = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT pro = a [ i ] * b [ i ] NEW_LINE res = res + pro NEW_LINE if ( pro < 0 and b [ i ] < 0 ) : NEW_LINE INDENT temp = ( a [ i ] + 2 * k ) * b [ i ] NEW_LINE DEDENT elif ( pro < 0 and a [ i ] < 0 ) : NEW_LINE INDENT temp = ( a [ i ] - 2 * k ) * b [ i ] NEW_LINE DEDENT elif ( pro > 0 and a [ i ] < 0 ) : NEW_LINE INDENT temp = ( a [ i ] + 2 * k ) * b [ i ] NEW_LINE DEDENT elif ( pro > 0 and a [ i ] > 0 ) : NEW_LINE INDENT temp = ( a [ i ] - 2 * k ) * b [ i ] NEW_LINE DEDENT DEDENT return res - diff NEW_LINE DEDENT

BLEU: 88.28
Edit Sim: 95


Src: 
void longestSubseqWithK ( string str , int k ) { int n = str . size ( ) ; int freq [ MAX_CHARS ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) freq [ str [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < n ; i ++ ) if ( freq [ str [ i ] - ' a ' ] >= k ) cout << str [ i ] ; }
Ref: 
def longestSubseqWithK ( str , k ) : NEW_LINE INDENT n = len ( str ) NEW_LINE freq = [ 0 ] * MAX_CHARS NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] >= k ) : NEW_LINE INDENT print ( str [ i ] , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
Hyp: 
def longestSubseqWithK ( str , k ) : NEW_LINE INDENT n = len ( str ) NEW_LINE freq = [ 0 for i in range ( MAX_CHARS ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] >= k ) : NEW_LINE INDENT print ( str [ i ] , end = " " ) NEW_LINE DEDENT DEDENT DEDENT

BLEU: 91.89
Edit Sim: 19


Src: 
int pairsInSortedRotated ( int arr [ ] , int n , int x ) { int i ; for ( i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] > arr [ i + 1 ] ) break ; int l = ( i + 1 ) % n ; int r = i ; int cnt = 0 ; while ( l != r ) { if ( arr [ l ] + arr [ r ] == x ) { cnt ++ ; if ( l == ( r - 1 + n ) % n ) { return cnt ; } l = ( l + 1 ) % n ; r = ( r - 1 + n ) % n ; } else if ( arr [ l ] + arr [ r ] < x ) l = ( l + 1 ) % n ; else r = ( n + r - 1 ) % n ; } return cnt ; }
Ref: 
def pairsInSortedRotated ( arr , n , x ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if arr [ i ] > arr [ i + 1 ] : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT l = ( i + 1 ) % n NEW_LINE r = i NEW_LINE cnt = 0 NEW_LINE while ( l != r ) : NEW_LINE INDENT if arr [ l ] + arr [ r ] == x : NEW_LINE INDENT cnt += 1 NEW_LINE if l == ( r - 1 + n ) % n : NEW_LINE INDENT return cnt NEW_LINE DEDENT l = ( l + 1 ) % n NEW_LINE r = ( r - 1 + n ) % n NEW_LINE DEDENT elif arr [ l ] + arr [ r ] < x : NEW_LINE INDENT l = ( l + 1 ) % n NEW_LINE DEDENT else : NEW_LINE INDENT r = ( n + r - 1 ) % n NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT
Hyp: 
def pairsInSortedRotated ( arr , n , x ) : NEW_LINE INDENT for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i + 1 ] ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT l = ( i + 1 ) % n NEW_LINE r = i NEW_LINE cnt = 0 NEW_LINE while ( l != r ) : NEW_LINE INDENT if ( arr [ l ] + arr [ r ] == x ) : NEW_LINE INDENT cnt += 1 NEW_LINE if ( l == ( r - 1 + n ) % n ) : NEW_LINE INDENT return cnt NEW_LINE DEDENT l = ( l + 1 ) % n NEW_LINE r = ( r - 1 + n ) % n NEW_LINE DEDENT elif ( arr [ l ] + arr [ r ] < x ) : NEW_LINE INDENT l = ( l + 1 ) % n NEW_LINE DEDENT else : NEW_LINE INDENT r = ( n + r - 1 ) % n NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT

BLEU: 86.27
Edit Sim: 24


Src: 
int middleOfThree ( int a , int b , int c ) { int x = a - b ; int y = b - c ; int z = a - c ; if ( x * y > 0 ) return b ; else if ( x * z > 0 ) return c ; else return a ; }
Ref: 
def middleOfThree ( a , b , c ) : NEW_LINE INDENT x = a - b NEW_LINE y = b - c NEW_LINE z = a - c NEW_LINE if x * y > 0 : NEW_LINE INDENT return b NEW_LINE DEDENT elif ( x * z > 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT else : NEW_LINE INDENT return a NEW_LINE DEDENT DEDENT
Hyp: 
def middleOfThree ( a , b , c ) : NEW_LINE INDENT x = a - b NEW_LINE y = b - c NEW_LINE z = a - c NEW_LINE if ( x * y > 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT elif ( x * z > 0 ) : NEW_LINE INDENT return c NEW_LINE DEDENT else : NEW_LINE INDENT return a NEW_LINE DEDENT DEDENT

BLEU: 88.82
Edit Sim: 6


Src: 
unsigned int nextPowerOf2 ( unsigned int n ) { unsigned count = 0 ; if ( n && ! ( n & ( n - 1 ) ) ) return n ; while ( n != 0 ) { n >>= 1 ; count += 1 ; } return 1 << count ; }
Ref: 
def nextPowerOf2 ( n ) : NEW_LINE INDENT count = 0 NEW_LINE if ( n and not ( n & ( n - 1 ) ) ) : NEW_LINE INDENT return n NEW_LINE DEDENT while ( n != 0 ) : NEW_LINE INDENT n >>= 1 NEW_LINE count += 1 NEW_LINE DEDENT return 1 << count NEW_LINE DEDENT
Hyp: 
def nextPowerOf2 ( n ) : NEW_LINE INDENT count = 0 NEW_LINE if ( n and not ( n & ( n - 1 ) ) ) : NEW_LINE INDENT return n NEW_LINE DEDENT while ( n != 0 ) : NEW_LINE INDENT n >>= 1 NEW_LINE count += 1 NEW_LINE DEDENT return 1 << count NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int maxSubArraySumRepeated ( int a [ ] , int n , int k ) { int max_so_far = INT_MIN , max_ending_here = 0 ; for ( int i = 0 ; i < n * k ; i ++ ) { max_ending_here = max_ending_here + a [ i % n ] ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; if ( max_ending_here < 0 ) max_ending_here = 0 ; } return max_so_far ; }
Ref: 
def maxSubArraySumRepeated ( a , n , k ) : NEW_LINE INDENT max_so_far = - 2147483648 NEW_LINE max_ending_here = 0 NEW_LINE for i in range ( n * k ) : NEW_LINE INDENT max_ending_here = max_ending_here + a [ i % n ] NEW_LINE if ( max_so_far < max_ending_here ) : NEW_LINE INDENT max_so_far = max_ending_here NEW_LINE DEDENT if ( max_ending_here < 0 ) : NEW_LINE INDENT max_ending_here = 0 NEW_LINE DEDENT DEDENT return max_so_far NEW_LINE DEDENT
Hyp: 
def maxSubArraySumRepeated ( a , n , k ) : NEW_LINE INDENT max_so_far = - maxint - 1 NEW_LINE max_ending_here = 0 NEW_LINE for i in range ( 0 , n * k ) : NEW_LINE INDENT max_ending_here = max_ending_here + a [ i % n ] NEW_LINE if ( max_so_far < max_ending_here ) : NEW_LINE INDENT max_so_far = max_ending_here NEW_LINE DEDENT if ( max_ending_here < 0 ) : NEW_LINE INDENT max_ending_here = 0 NEW_LINE DEDENT DEDENT return max_so_far NEW_LINE DEDENT

BLEU: 89.97
Edit Sim: 14


Src: 
void reverse ( char str [ ] ) { int n = strlen ( str ) , i ; for ( i = 0 ; i < n / 2 ; i ++ ) swap ( & str [ i ] , & str [ n - i - 1 ] ) ; }
Ref: 
def reverse ( string ) : NEW_LINE INDENT string = string [ : : - 1 ] NEW_LINE return string NEW_LINE DEDENT
Hyp: 
def reverse ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE for i in range ( 0 , int ( n / 2 ) ) : NEW_LINE INDENT str [ i ] , str [ n - i - 1 ] = str [ n - i - 1 ] , str [ i ] NEW_LINE DEDENT DEDENT

BLEU: 10.44
Edit Sim: 116


Src: 
string nextWord ( string s ) { if ( s == " " ) return " a " ; int i = s . length ( ) - 1 ; while ( s [ i ] == ' z ' && i >= 0 ) i -- ; if ( i == - 1 ) s = s + ' a ' ; else s [ i ] ++ ; return s ; }
Ref: 
def nextWord ( s ) : NEW_LINE INDENT if ( s == " ▁ " ) : NEW_LINE INDENT return " a " NEW_LINE DEDENT i = len ( s ) - 1 NEW_LINE while ( s [ i ] == ' z ' and i >= 0 ) : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT if ( i == - 1 ) : NEW_LINE INDENT s = s + ' a ' NEW_LINE DEDENT else : NEW_LINE INDENT s = s . replace ( s [ i ] , chr ( ord ( s [ i ] ) + 1 ) , 1 ) NEW_LINE DEDENT return s NEW_LINE DEDENT
Hyp: 
def nextWord ( s ) : NEW_LINE INDENT if ( s == " " ) : NEW_LINE INDENT return " a " NEW_LINE DEDENT i = len ( s ) - 1 NEW_LINE while ( s [ i ] == ' z ' and i >= 0 ) : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT if ( i == - 1 ) : NEW_LINE INDENT s = s + ' a ' NEW_LINE DEDENT else : NEW_LINE INDENT s [ i ] = s [ i ] + 1 NEW_LINE DEDENT return s NEW_LINE DEDENT

BLEU: 78.24
Edit Sim: 43


Src: 
int binomialCoeffSum ( int n ) { int C [ n + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= min ( i , n ) ; j ++ ) { if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } int sum = 0 ; for ( int i = 0 ; i <= n ; i ++ ) sum += C [ n ] [ i ] ; return sum ; }
Ref: 
def binomialCoeffSum ( n ) : NEW_LINE INDENT C = [ [ 0 ] * ( n + 2 ) for i in range ( 0 , n + 2 ) ] NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT for j in range ( 0 , min ( i , n ) + 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT sum = 0 NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT sum += C [ n ] [ i ] NEW_LINE DEDENT return sum NEW_LINE DEDENT
Hyp: 
def binomialCoeffSum ( n ) : NEW_LINE INDENT C = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( min ( i , n ) + 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT sum = 0 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT sum += C [ n ] [ i ] NEW_LINE DEDENT return sum NEW_LINE DEDENT

BLEU: 85.51
Edit Sim: 34


Src: 
bool isEven ( int n ) { return ( n % 2 == 0 ) ; }
Ref: 
def isEven ( n ) : NEW_LINE INDENT return ( n % 2 == 0 ) NEW_LINE DEDENT
Hyp: 
def isEven ( n ) : NEW_LINE INDENT return ( n % 2 == 0 ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int binarySearch ( int arr [ ] , int low , int high , int key ) { if ( high < low ) return - 1 ; int mid = ( low + high ) / 2 ; if ( key == arr [ mid ] ) return mid ; if ( key > arr [ mid ] ) return binarySearch ( arr , ( mid + 1 ) , high , key ) ; return binarySearch ( arr , low , ( mid - 1 ) , key ) ; }
Ref: 
def binarySearch ( arr , low , high , key ) : NEW_LINE INDENT if ( high < low ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = ( low + high ) / 2 NEW_LINE if ( key == arr [ int ( mid ) ] ) : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( key > arr [ int ( mid ) ] ) : NEW_LINE INDENT return binarySearch ( arr , ( mid + 1 ) , high , key ) NEW_LINE DEDENT return ( binarySearch ( arr , low , ( mid - 1 ) , key ) ) NEW_LINE DEDENT
Hyp: 
def binarySearch ( arr , low , high , key ) : NEW_LINE INDENT if high < low : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = int ( ( low + high ) / 2 ) NEW_LINE if key == arr [ mid ] : NEW_LINE INDENT return mid NEW_LINE DEDENT if key > arr [ mid ] : NEW_LINE INDENT return binarySearch ( arr , ( mid + 1 ) , high , key ) NEW_LINE DEDENT return binarySearch ( arr , low , ( mid - 1 ) , key ) NEW_LINE DEDENT

BLEU: 70.52
Edit Sim: 40


Src: 
void maxMin ( int arr [ ] [ MAX ] , int n ) { int min = INT_MAX ; int max = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j <= n / 2 ; j ++ ) { if ( arr [ i ] [ j ] > arr [ i ] [ n - j - 1 ] ) { if ( min > arr [ i ] [ n - j - 1 ] ) min = arr [ i ] [ n - j - 1 ] ; if ( max < arr [ i ] [ j ] ) max = arr [ i ] [ j ] ; } else { if ( min > arr [ i ] [ j ] ) min = arr [ i ] [ j ] ; if ( max < arr [ i ] [ n - j - 1 ] ) max = arr [ i ] [ n - j - 1 ] ; } } } cout << " Maximum ▁ = ▁ " << max ; << " , ▁ Minimum ▁ = ▁ " << min ; }
Ref: 
def MAXMIN ( arr , n ) : NEW_LINE INDENT MIN = 10 ** 9 NEW_LINE MAX = - 10 ** 9 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n // 2 + 1 ) : NEW_LINE INDENT if ( arr [ i ] [ j ] > arr [ i ] [ n - j - 1 ] ) : NEW_LINE INDENT if ( MIN > arr [ i ] [ n - j - 1 ] ) : NEW_LINE INDENT MIN = arr [ i ] [ n - j - 1 ] NEW_LINE DEDENT if ( MAX < arr [ i ] [ j ] ) : NEW_LINE INDENT MAX = arr [ i ] [ j ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( MIN > arr [ i ] [ j ] ) : NEW_LINE INDENT MIN = arr [ i ] [ j ] NEW_LINE DEDENT if ( MAX < arr [ i ] [ n - j - 1 ] ) : NEW_LINE INDENT MAX = arr [ i ] [ n - j - 1 ] NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( " MAXimum ▁ = " , MAX , " , ▁ MINimum ▁ = " , MIN ) NEW_LINE DEDENT
Hyp: 
def maxMin ( arr , n ) : NEW_LINE INDENT min = 10000000000 NEW_LINE max = 10000000000 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n // 2 ) : NEW_LINE INDENT if ( arr [ i ] [ j ] > arr [ i ] [ n - j - 1 ] ) : NEW_LINE INDENT if ( min > arr [ i ] [ n - j - 1 ] ) : NEW_LINE INDENT min = arr [ i ] [ n - j - 1 ] NEW_LINE DEDENT if ( max < arr [ i ] [ j ] ) : NEW_LINE INDENT max = arr [ i ] [ j ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( min > arr [ i ] [ j ] ) : NEW_LINE INDENT min = arr [ i ] [ j ] NEW_LINE DEDENT if ( max < arr [ i ] [ n - j - 1 ] ) : NEW_LINE INDENT max = arr [ i ] [ n - j - 1 ] NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( " Maximum ▁ = ▁ " , max ) NEW_LINE print ( " , ▁ Minimum ▁ = ▁ " , min ) NEW_LINE DEDENT

BLEU: 76.5
Edit Sim: 90


Src: 
int bool isPowerOfTwo ( int x ) { return x && ( ! ( x & ( x - 1 ) ) ) ; }
Ref: 
def isPowerOfTwo ( x ) : NEW_LINE INDENT return ( x and ( not ( x & ( x - 1 ) ) ) ) NEW_LINE DEDENT
Hyp: 
def isPowerOfTwo ( x ) : NEW_LINE INDENT return x and ( not ( x & ( x - 1 ) ) ) NEW_LINE DEDENT

BLEU: 86.34
Edit Sim: 4


Src: 
int countPaths ( int n , int m ) { if ( n == 0 || m == 0 ) return 1 ; return ( countPaths ( n - 1 , m ) + countPaths ( n , m - 1 ) ) ; }
Ref: 
def countPaths ( n , m ) : NEW_LINE INDENT if ( n == 0 or m == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return ( countPaths ( n - 1 , m ) + countPaths ( n , m - 1 ) ) NEW_LINE DEDENT
Hyp: 
def countPaths ( n , m ) : NEW_LINE INDENT if ( n == 0 or m == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return ( countPaths ( n - 1 , m ) + countPaths ( n , m - 1 ) ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
bool isRectangle ( const vector < vector < int > > & matrix ) { int rows = matrix . size ( ) ; if ( rows == 0 ) return false ; int columns = matrix [ 0 ] . size ( ) ; unordered_map < int , unordered_set < int > > table ; for ( int i = 0 ; i < rows ; ++ i ) { for ( int j = 0 ; j < columns - 1 ; ++ j ) { for ( int k = j + 1 ; k < columns ; ++ k ) { if ( matrix [ i ] [ j ] == 1 && matrix [ i ] [ k ] == 1 ) { if ( table . find ( j ) != table . end ( ) && table [ j ] . find ( k ) != table [ j ] . end ( ) ) return true ; table [ j ] . insert ( k ) ; } } } } return false ; }
Ref: 
def isRectangle ( matrix ) : NEW_LINE INDENT rows = len ( matrix ) NEW_LINE if ( rows == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT columns = len ( matrix [ 0 ] ) NEW_LINE table = { } NEW_LINE for i in range ( rows ) : NEW_LINE INDENT for j in range ( columns - 1 ) : NEW_LINE INDENT for k in range ( j + 1 , columns ) : NEW_LINE INDENT if ( matrix [ i ] [ j ] == 1 and matrix [ i ] [ k ] == 1 ) : NEW_LINE INDENT if ( j in table and k in table [ j ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( k in table and j in table [ k ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT if j not in table : NEW_LINE INDENT table [ j ] = set ( ) NEW_LINE DEDENT if k not in table : NEW_LINE INDENT table [ k ] = set ( ) NEW_LINE DEDENT table [ j ] . add ( k ) NEW_LINE table [ k ] . add ( j ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return False NEW_LINE DEDENT
Hyp: 
def isRectangle ( matrix ) : NEW_LINE INDENT rows = len ( matrix ) NEW_LINE if ( rows == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT columns = len ( matrix [ 0 ] ) NEW_LINE table = dict ( ) NEW_LINE for i in range ( rows ) : NEW_LINE INDENT for j in range ( columns - 1 ) : NEW_LINE INDENT for k in range ( j + 1 , columns ) : NEW_LINE INDENT if ( matrix [ i ] [ j ] == 1 and matrix [ i ] [ k ] == 1 ) : NEW_LINE INDENT if ( table [ j ] . get ( k ) in table ) : NEW_LINE INDENT return True NEW_LINE DEDENT table [ j ] [ k ] = 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return False NEW_LINE DEDENT

BLEU: 57.59
Edit Sim: 278


Src: 
void decToBinary ( int n ) { int binaryNum [ 32 ] ; int i = 0 ; while ( n > 0 ) { binaryNum [ i ] = n % 2 ; n = n / 2 ; i ++ ; } for ( int j = i - 1 ; j >= 0 ; j -- ) cout << binaryNum [ j ] ; }
Ref: 
def decToBinary ( n ) : NEW_LINE INDENT binaryNum = [ 0 ] * n NEW_LINE i = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT binaryNum [ i ] = n % 2 NEW_LINE n = int ( n / 2 ) NEW_LINE i += 1 NEW_LINE DEDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( binaryNum [ j ] , end = " " ) NEW_LINE DEDENT DEDENT
Hyp: 
def decToBinary ( n ) : NEW_LINE INDENT binaryNum = [ 0 ] * 32 NEW_LINE i = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT binaryNum [ i ] = n % 2 NEW_LINE n = int ( n / 2 ) NEW_LINE i += 1 NEW_LINE DEDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( binaryNum [ j ] , end = " " ) NEW_LINE DEDENT DEDENT

BLEU: 97.01
Edit Sim: 2


Src: 
int countFriendsPairings ( int n ) { if ( dp [ n ] != - 1 ) return dp [ n ] ; if ( n > 2 ) return dp [ n ] = countFriendsPairings ( n - 1 ) + ( n - 1 ) * countFriendsPairings ( n - 2 ) ; else return dp [ n ] = n ; }
Ref: 
def countFriendsPairings ( n ) : NEW_LINE INDENT dp = [ - 1 ] * 100 NEW_LINE if ( dp [ n ] != - 1 ) : NEW_LINE INDENT return dp [ n ] NEW_LINE DEDENT if ( n > 2 ) : NEW_LINE INDENT dp [ n ] = ( countFriendsPairings ( n - 1 ) + ( n - 1 ) * countFriendsPairings ( n - 2 ) ) NEW_LINE return dp [ n ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ n ] = n NEW_LINE return dp [ n ] NEW_LINE DEDENT DEDENT
Hyp: 
def countFriendsPairings ( n ) : NEW_LINE INDENT if ( dp [ n ] != - 1 ) : NEW_LINE INDENT return dp [ n ] NEW_LINE DEDENT if ( n > 2 ) : NEW_LINE INDENT dp [ n ] = countFriendsPairings ( n - 1 ) + ( n - 1 ) * countFriendsPairings ( n - 2 ) NEW_LINE return dp [ n ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ n ] = n NEW_LINE DEDENT DEDENT

BLEU: 76.64
Edit Sim: 57


Src: 
int maximumSumSubarray ( int arr [ ] , int n ) { int min_prefix_sum = 0 ; int res = numeric_limits < int > :: min ( ) ; int prefix_sum [ n ] ; prefix_sum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) prefix_sum [ i ] = prefix_sum [ i - 1 ] + arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) { res = max ( res , prefix_sum [ i ] - min_prefix_sum ) ; min_prefix_sum = min ( min_prefix_sum , prefix_sum [ i ] ) ; } return res ; }
Ref: 
def maximumSumSubarray ( arr , n ) : NEW_LINE INDENT min_prefix_sum = 0 NEW_LINE res = - math . inf NEW_LINE prefix_sum = [ ] NEW_LINE prefix_sum . append ( arr [ 0 ] ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT prefix_sum . append ( prefix_sum [ i - 1 ] + arr [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT res = max ( res , prefix_sum [ i ] - min_prefix_sum ) NEW_LINE min_prefix_sum = min ( min_prefix_sum , prefix_sum [ i ] ) NEW_LINE DEDENT return res NEW_LINE DEDENT
Hyp: 
def maximumSumSubarray ( arr , n ) : NEW_LINE INDENT min_prefix_sum = 0 NEW_LINE res = - float ( ' inf ' ) NEW_LINE prefix_sum = [ 0 for i in range ( n ) ] NEW_LINE prefix_sum [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT prefix_sum [ i ] = prefix_sum [ i - 1 ] + arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT res = max ( res , prefix_sum [ i ] - min_prefix_sum ) NEW_LINE min_prefix_sum = min ( min_prefix_sum , prefix_sum [ i ] ) NEW_LINE DEDENT return res NEW_LINE DEDENT

BLEU: 74.45
Edit Sim: 53


Src: 
int countOccurrences ( string s , int K ) { int n = s . length ( ) ; int C , c1 = 0 , c2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ' a ' ) c1 ++ ; if ( s [ i ] == ' b ' ) { c2 ++ ; C += c1 ; } } return C * K + ( K * ( K - 1 ) / 2 ) * c1 * c2 ; }
Ref: 
def countOccurrences ( s , K ) : NEW_LINE INDENT n = len ( s ) NEW_LINE c1 = 0 NEW_LINE c2 = 0 NEW_LINE C = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == ' a ' : NEW_LINE INDENT c1 += 1 NEW_LINE DEDENT if s [ i ] == ' b ' : NEW_LINE INDENT c2 += 1 NEW_LINE C += c1 NEW_LINE DEDENT DEDENT return C * K + ( K * ( K - 1 ) / 2 ) * c1 * c2 NEW_LINE DEDENT
Hyp: 
def countOccurrences ( s , K ) : NEW_LINE INDENT n = len ( s ) NEW_LINE C = 0 NEW_LINE c1 = 0 NEW_LINE c2 = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( s [ i ] == ' a ' ) : NEW_LINE INDENT c1 += 1 NEW_LINE DEDENT if ( s [ i ] == ' b ' ) : NEW_LINE INDENT c2 += 1 NEW_LINE DEDENT C += c1 NEW_LINE DEDENT DEDENT return ( C * K + ( K * ( K - 1 ) // 2 ) * c1 * c2 ) NEW_LINE DEDENT

BLEU: 76.33
Edit Sim: 29


Src: 
bool checkDivisibility ( string num ) { int length = num . size ( ) ; if ( length == 1 && num [ 0 ] == '0' ) return true ; if ( length % 3 == 1 ) { num += "00" ; length += 2 ; } else if ( length % 3 == 2 ) { num += "0" ; length += 1 ; } int sum = 0 , p = 1 ; for ( int i = length - 1 ; i >= 0 ; i -- ) { int group = 0 ; group += num [ i -- ] - '0' ; group += ( num [ i -- ] - '0' ) * 10 ; group += ( num [ i ] - '0' ) * 100 ; sum = sum + group * p ; p *= ( - 1 ) ; } sum = abs ( sum ) ; return ( sum % 13 == 0 ) ; }
Ref: 
def checkDivisibility ( num ) : NEW_LINE INDENT length = len ( num ) NEW_LINE if ( length == 1 and num [ 0 ] == '0' ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( length % 3 == 1 ) : NEW_LINE INDENT num = str ( num ) + "00" NEW_LINE length += 2 NEW_LINE DEDENT elif ( length % 3 == 2 ) : NEW_LINE INDENT num = str ( num ) + "0" NEW_LINE length += 1 NEW_LINE DEDENT sum = 0 NEW_LINE p = 1 NEW_LINE for i in range ( length - 1 , - 1 , - 1 ) : NEW_LINE INDENT group = 0 NEW_LINE group += ord ( num [ i ] ) - ord ( '0' ) NEW_LINE i -= 1 NEW_LINE group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 10 NEW_LINE i -= 1 NEW_LINE group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 100 NEW_LINE sum = sum + group * p NEW_LINE p *= ( - 1 ) NEW_LINE DEDENT sum = abs ( sum ) NEW_LINE return ( sum % 13 == 0 ) NEW_LINE DEDENT
Hyp: 
def checkDivisibility ( num ) : NEW_LINE INDENT length = len ( num ) NEW_LINE if ( length == 1 and num [ 0 ] == '0' ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( length % 3 == 1 ) : NEW_LINE INDENT num += "00" NEW_LINE length += 2 NEW_LINE DEDENT elif ( length % 3 == 2 ) : NEW_LINE INDENT num += "0" NEW_LINE length += 1 NEW_LINE DEDENT sum = 0 NEW_LINE p = 1 NEW_LINE for i in range ( length - 1 , - 1 , - 1 ) : NEW_LINE INDENT group = 0 NEW_LINE group += ord ( num [ i ] ) - ord ( '0' ) NEW_LINE group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 10 NEW_LINE group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 100 NEW_LINE sum = sum + group * p NEW_LINE p = ( - 1 ) NEW_LINE DEDENT sum = abs ( sum ) NEW_LINE return ( sum % 13 == 0 ) NEW_LINE DEDENT

BLEU: 86.77
Edit Sim: 63


Src: 
int countRect ( int n ) { int ans = 0 ; for ( int length = 1 ; length <= sqrt ( n ) ; ++ length ) for ( int height = length ; height * length <= n ; ++ height ) ans ++ ; return ans ; }
Ref: 
def countRect ( n ) : NEW_LINE INDENT ans = 0 NEW_LINE for length in range ( 1 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT height = length NEW_LINE while ( height * length <= n ) : NEW_LINE INDENT ans += 1 NEW_LINE height += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
Hyp: 
def countRect ( n ) : NEW_LINE INDENT ans = 0 NEW_LINE length = 1 NEW_LINE while ( length <= math . sqrt ( n ) ) : NEW_LINE INDENT for height in range ( length , int ( n / 2 ) + 1 ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT

BLEU: 64.91
Edit Sim: 92


Src: 
public : unsigned int countSetBits ( int n ) { unsigned int count = 0 ; while ( n ) { n &= ( n - 1 ) ; count ++ ; } return count ; }
Ref: 
def countSetBits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT n &= ( n - 1 ) NEW_LINE count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
Hyp: 
def countSetBits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT n &= ( n - 1 ) NEW_LINE count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int lenOfLongSubarr ( int arr [ ] , int n ) { unordered_map < int , int > um ; int sum = 0 , maxLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] == 0 ? - 1 : 1 ; if ( sum == 1 ) maxLen = i + 1 ; else if ( um . find ( sum ) == um . end ( ) ) um [ sum ] = i ; if ( um . find ( sum - 1 ) != um . end ( ) ) { if ( maxLen < ( i - um [ sum - 1 ] ) ) maxLen = i - um [ sum - 1 ] ; } } return maxLen ; }
Ref: 
def lenOfLongSubarr ( arr , n ) : NEW_LINE INDENT um = { i : 0 for i in range ( 10 ) } NEW_LINE sum = 0 NEW_LINE maxLen = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] == 0 : NEW_LINE INDENT sum += - 1 NEW_LINE DEDENT else : NEW_LINE INDENT sum += 1 NEW_LINE DEDENT if ( sum == 1 ) : NEW_LINE INDENT maxLen = i + 1 NEW_LINE DEDENT elif ( sum not in um ) : NEW_LINE INDENT um [ sum ] = i NEW_LINE DEDENT if ( ( sum - 1 ) in um ) : NEW_LINE INDENT if ( maxLen < ( i - um [ sum - 1 ] ) ) : NEW_LINE INDENT maxLen = i - um [ sum - 1 ] NEW_LINE DEDENT DEDENT DEDENT return maxLen NEW_LINE DEDENT
Hyp: 
def lenOfLongSubarr ( arr , n ) : NEW_LINE INDENT um = dict ( ) NEW_LINE Sum = 0 NEW_LINE maxLen = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT Sum += arr [ i ] == 0 ? - 1 : 1 NEW_LINE if Sum == 1 : NEW_LINE INDENT maxLen = i + 1 NEW_LINE DEDENT elif um . get ( Sum ) : NEW_LINE INDENT um [ Sum ] = i NEW_LINE DEDENT if um . get ( Sum - 1 ) : NEW_LINE INDENT if maxLen < ( i - um [ Sum - 1 ] ) : NEW_LINE INDENT maxLen = i - um [ Sum - 1 ] NEW_LINE DEDENT DEDENT DEDENT return maxLen NEW_LINE DEDENT

BLEU: 54.8
Edit Sim: 144


Src: 
unsigned int factorial ( unsigned int n ) { int res = 1 , i ; for ( i = 2 ; i <= n ; i ++ ) res *= i ; return res ; }
Ref: 
def factorial ( n ) : NEW_LINE INDENT return 1 if ( n == 1 or n == 0 ) else n * factorial ( n - 1 ) NEW_LINE DEDENT
Hyp: 
def factorial ( n ) : NEW_LINE INDENT return 1 if ( n == 1 or n == 0 ) else n * factorial ( n - 1 ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int minJumps ( int arr [ ] , int n ) { if ( n == 1 ) return 0 ; int res = INT_MAX ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( i + arr [ i ] >= n - 1 ) { int sub_res = minJumps ( arr , i + 1 ) ; if ( sub_res != INT_MAX ) res = min ( res , sub_res + 1 ) ; } } return res ; }
Ref: 
def minJumps ( arr , l , h ) : NEW_LINE INDENT if ( h == l ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( arr [ l ] == 0 ) : NEW_LINE INDENT return float ( ' inf ' ) NEW_LINE DEDENT min = float ( ' inf ' ) NEW_LINE for i in range ( l + 1 , h + 1 ) : NEW_LINE INDENT if ( i < l + arr [ l ] + 1 ) : NEW_LINE INDENT jumps = minJumps ( arr , i , h ) NEW_LINE if ( jumps != float ( ' inf ' ) and jumps + 1 < min ) : NEW_LINE INDENT min = jumps + 1 NEW_LINE DEDENT DEDENT DEDENT return min NEW_LINE DEDENT
Hyp: 
def minJumps ( arr , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT res = sys . maxsize NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( i + arr [ i ] >= n - 1 ) : NEW_LINE INDENT sub_res = minJumps ( arr , i + 1 ) NEW_LINE if ( sub_res != sys . maxsize ) : NEW_LINE INDENT res = min ( res , sub_res + 1 ) NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT

BLEU: 35.35
Edit Sim: 190


Src: 
int minTimeForWritingChars ( int N , int insert , int remove , int copy ) { if ( N == 0 ) return 0 ; if ( N == 1 ) return insert ; int dp [ N + 1 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; for ( int i = 1 ; i <= N ; i ++ ) { if ( i % 2 == 0 ) dp [ i ] = min ( dp [ i - 1 ] + insert , dp [ i / 2 ] + copy ) ; else dp [ i ] = min ( dp [ i - 1 ] + insert , dp [ ( i + 1 ) / 2 ] + copy + remove ) ; } return dp [ N ] ; }
Ref: 
def minTimeForWritingChars ( N , insrt , remov , cpy ) : NEW_LINE INDENT if N == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if N == 1 : NEW_LINE INDENT return insrt NEW_LINE DEDENT dp = [ 0 ] * ( N + 1 ) NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT dp [ i ] = min ( dp [ i - 1 ] + insrt , dp [ i // 2 ] + cpy ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] = min ( dp [ i - 1 ] + insrt , dp [ ( i + 1 ) // 2 ] + cpy + remov ) NEW_LINE DEDENT DEDENT return dp [ N ] NEW_LINE DEDENT
Hyp: 
def minTimeForWritingChars ( N , insert , remove , copy ) : NEW_LINE INDENT if ( N == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( N == 1 ) : NEW_LINE INDENT return insert NEW_LINE DEDENT dp = [ 0 for i in range ( N + 1 ) ] NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT dp [ i ] = min ( dp [ i - 1 ] + insert , dp [ i // 2 ] + copy ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] = min ( dp [ i - 1 ] + insert , dp [ ( i + 1 ) // 2 ] + copy + remove ) NEW_LINE DEDENT DEDENT return dp [ N ] NEW_LINE DEDENT

BLEU: 70.62
Edit Sim: 36


Src: 
void carveCross ( string str ) { int n = str . length ( ) ; if ( n % 2 == 0 ) { cout << " Not ▁ possible . ▁ Please ▁ enter ▁ " << " odd ▁ length ▁ string . \n " ; } else { char arr [ max ] [ max ] ; int m = n / 2 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { arr [ i ] [ j ] = ' X ' ; } } for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] [ m ] = str [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { arr [ m ] [ i ] = str [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { cout << arr [ i ] [ j ] << " ▁ " ; } cout << " \n " ; } } }
Ref: 
def carveCross ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT print ( " Not ▁ possible . ▁ Please ▁ enter ▁ " , " odd ▁ length ▁ string . \n " ) NEW_LINE DEDENT else : NEW_LINE INDENT arr = [ [ False for x in range ( max ) ] for y in range ( max ) ] NEW_LINE m = n // 2 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT arr [ i ] [ j ] = ' X ' NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] [ m ] = str [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ m ] [ i ] = str [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT print ( arr [ i ] [ j ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT DEDENT
Hyp: 
def carveCross ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE if n % 2 == 0 : NEW_LINE INDENT print ( " Not ▁ possible . ▁ Please ▁ enter ▁ " , " odd ▁ length ▁ string . " ) NEW_LINE DEDENT else : NEW_LINE INDENT arr = [ [ 0 for i in range ( max ) ] for j in range ( n ) ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] [ j ] = ' X ' NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] [ m ] = str [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ m ] [ i ] = str [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT print ( arr [ i ] [ j ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT

BLEU: 84.56
Edit Sim: 78


Src: 
int sumoflength ( int arr [ ] , int n ) { unordered_set < int > s ; int j = 0 , ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { while ( j < n && s . find ( arr [ j ] ) == s . end ( ) ) { s . insert ( arr [ j ] ) ; j ++ ; } ans += ( ( j - i ) * ( j - i + 1 ) ) / 2 ; s . erase ( arr [ i ] ) ; } return ans ; }
Ref: 
def sumoflength ( arr , n ) : NEW_LINE INDENT s = [ ] NEW_LINE j = 0 NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT while ( j < n and ( arr [ j ] not in s ) ) : NEW_LINE INDENT s . append ( arr [ j ] ) NEW_LINE j += 1 NEW_LINE DEDENT ans += ( ( j - i ) * ( j - i + 1 ) ) // 2 NEW_LINE s . remove ( arr [ i ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
Hyp: 
def sumoflength ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE j = 0 NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT while ( j < n and arr [ i ] not in s ) : NEW_LINE INDENT s . add ( arr [ i ] ) NEW_LINE j += 1 NEW_LINE DEDENT ans += ( ( j - i ) * ( j - i + 1 ) ) / 2 NEW_LINE DEDENT s . remove ( arr [ i ] ) NEW_LINE DEDENT return int ( ans ) NEW_LINE DEDENT

BLEU: 77.06
Edit Sim: 32


Src: 
void findTriplets ( int arr [ ] , int n ) { bool found = false ; for ( int i = 0 ; i < n - 1 ; i ++ ) { unordered_set < int > s ; for ( int j = i + 1 ; j < n ; j ++ ) { int x = - ( arr [ i ] + arr [ j ] ) ; if ( s . find ( x ) != s . end ( ) ) { printf ( " % d ▁ % d ▁ % d \n " , x , arr [ i ] , arr [ j ] ) ; found = true ; } else s . insert ( arr [ j ] ) ; } } if ( found == false ) cout << " ▁ No ▁ Triplet ▁ Found " << endl ; }
Ref: 
def findTriplets ( arr , n ) : NEW_LINE INDENT found = False NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT s = set ( ) NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT x = - ( arr [ i ] + arr [ j ] ) NEW_LINE if x in s : NEW_LINE INDENT print ( x , arr [ i ] , arr [ j ] ) NEW_LINE found = True NEW_LINE DEDENT else : NEW_LINE INDENT s . add ( arr [ j ] ) NEW_LINE DEDENT DEDENT DEDENT if found == False : NEW_LINE INDENT print ( " No ▁ Triplet ▁ Found " ) NEW_LINE DEDENT DEDENT
Hyp: 
def findTriplets ( arr , n ) : NEW_LINE INDENT found = False NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT s = set ( ) NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT x = - ( arr [ i ] + arr [ j ] ) NEW_LINE if ( x in s ) : NEW_LINE INDENT print ( " % d ▁ % d " , x , arr [ i ] , arr [ j ] ) NEW_LINE found = True NEW_LINE DEDENT else : NEW_LINE INDENT s . add ( arr [ j ] ) NEW_LINE DEDENT DEDENT DEDENT if ( found == False ) : NEW_LINE INDENT print ( " ▁ No ▁ Triplet ▁ Found " ) NEW_LINE DEDENT DEDENT

BLEU: 81.64
Edit Sim: 30


Src: 
int maxPrefix ( char s [ ] , char t [ ] ) { int count = 0 ; for ( int i = 0 ; i < strlen ( t ) ; i ++ ) { if ( count == strlen ( s ) ) break ; if ( t [ i ] == s [ count ] ) count ++ ; } return count ; }
Ref: 
def maxPrefix ( s , t ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , len ( t ) ) : NEW_LINE INDENT if ( count == len ( s ) ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( t [ i ] == s [ count ] ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
Hyp: 
def maxPrefix ( s , t ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( t ) ) : NEW_LINE INDENT if ( count == len ( s ) ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( t [ i ] == s [ count ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT

BLEU: 88.42
Edit Sim: 13


Src: 
void segregateElements ( int arr [ ] , int n ) { int temp [ n ] ; int j = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] >= 0 ) temp [ j ++ ] = arr [ i ] ; if ( j == n || j == 0 ) return ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] < 0 ) temp [ j ++ ] = arr [ i ] ; memcpy ( arr , temp , sizeof ( temp ) ) ; }
Ref: 
def segregateElements ( arr , n ) : NEW_LINE INDENT temp = [ 0 for k in range ( n ) ] NEW_LINE j = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] >= 0 ) : NEW_LINE INDENT temp [ j ] = arr [ i ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT if ( j == n or j == 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] < 0 ) : NEW_LINE INDENT temp [ j ] = arr [ i ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT for k in range ( n ) : NEW_LINE INDENT arr [ k ] = temp [ k ] NEW_LINE DEDENT DEDENT
Hyp: 
def segregateElements ( arr , n ) : NEW_LINE INDENT temp = [ 0 ] * n NEW_LINE j = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if arr [ i ] >= 0 : NEW_LINE INDENT temp [ j ] = arr [ i ] NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if j == n or j == 0 : NEW_LINE INDENT return NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if arr [ i ] < 0 : NEW_LINE INDENT temp [ j ] = arr [ i ] NEW_LINE DEDENT j += 1 NEW_LINE DEDENT DEDENT arr = sorted ( temp ) NEW_LINE DEDENT

BLEU: 61.93
Edit Sim: 116


Src: 
void mergeIntervals ( Interval arr [ ] , int n ) { sort ( arr , arr + n , mycomp ) ; int index = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ index ] . e >= arr [ i ] . s ) { arr [ index ] . e = max ( arr [ index ] . e , arr [ i ] . e ) ; arr [ index ] . s = min ( arr [ index ] . s , arr [ i ] . s ) ; } else { arr [ index ] = arr [ i ] ; index ++ ; } } cout << " \n ▁ The ▁ Merged ▁ Intervals ▁ are : ▁ " ; for ( int i = 0 ; i <= index ; i ++ ) cout << " [ " << arr [ i ] . s << " , ▁ " << arr [ i ] . e << " ] ▁ " ; }
Ref: 
def mergeIntervals ( arr ) : NEW_LINE INDENT arr . sort ( key = lambda x : x [ 0 ] ) NEW_LINE m = [ ] NEW_LINE s = - 10000 NEW_LINE max = - 100000 NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT a = arr [ i ] NEW_LINE if a [ 0 ] > max : NEW_LINE INDENT if i != 0 : NEW_LINE INDENT m . append ( [ s , max ] ) NEW_LINE DEDENT max = a [ 1 ] NEW_LINE s = a [ 0 ] NEW_LINE DEDENT else : NEW_LINE INDENT if a [ 1 ] >= max : NEW_LINE INDENT max = a [ 1 ] NEW_LINE DEDENT DEDENT DEDENT if max != - 100000 and [ s , max ] not in m : NEW_LINE INDENT m . append ( [ s , max ] ) NEW_LINE DEDENT print ( " The ▁ Merged ▁ Intervals ▁ are ▁ : " , end = " ▁ " ) NEW_LINE for i in range ( len ( m ) ) : NEW_LINE INDENT print ( m [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
Hyp: 
def mergeIntervals ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE index = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if arr [ index ] . e >= arr [ i ] . s : NEW_LINE INDENT arr [ index ] . e = max ( arr [ index ] . e , arr [ i ] . e ) NEW_LINE arr [ index ] . s = min ( arr [ index ] . s , arr [ i ] . s ) NEW_LINE DEDENT else : NEW_LINE INDENT arr [ index ] = arr [ i ] NEW_LINE index += 1 NEW_LINE DEDENT DEDENT print ( " The ▁ Merged ▁ Intervals ▁ are : ▁ " ) NEW_LINE for i in range ( index + 1 ) : NEW_LINE INDENT print ( " [ " , arr [ i ] . s , " , ▁ " , arr [ i ] . e , " ] " ) NEW_LINE DEDENT DEDENT

BLEU: 31.36
Edit Sim: 381


Src: 
float correlationCoefficient ( int X [ ] , int Y [ ] , int n ) { int sum_X = 0 , sum_Y = 0 , sum_XY = 0 ; int squareSum_X = 0 , squareSum_Y = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum_X = sum_X + X [ i ] ; sum_Y = sum_Y + Y [ i ] ; sum_XY = sum_XY + X [ i ] * Y [ i ] ; squareSum_X = squareSum_X + X [ i ] * X [ i ] ; squareSum_Y = squareSum_Y + Y [ i ] * Y [ i ] ; } float corr = ( float ) ( n * sum_XY - sum_X * sum_Y ) / sqrt ( ( n * squareSum_X - sum_X * sum_X ) * ( n * squareSum_Y - sum_Y * sum_Y ) ) ; return corr ; }
Ref: 
def correlationCoefficient ( X , Y , n ) : NEW_LINE INDENT sum_X = 0 NEW_LINE sum_Y = 0 NEW_LINE sum_XY = 0 NEW_LINE squareSum_X = 0 NEW_LINE squareSum_Y = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT sum_X = sum_X + X [ i ] NEW_LINE sum_Y = sum_Y + Y [ i ] NEW_LINE sum_XY = sum_XY + X [ i ] * Y [ i ] NEW_LINE squareSum_X = squareSum_X + X [ i ] * X [ i ] NEW_LINE squareSum_Y = squareSum_Y + Y [ i ] * Y [ i ] NEW_LINE i = i + 1 NEW_LINE DEDENT corr = ( float ) ( n * sum_XY - sum_X * sum_Y ) / NEW_LINE INDENT ( float ) ( math . sqrt ( ( n * squareSum_X - sum_X * sum_X ) * ( n * squareSum_Y - sum_Y * sum_Y ) ) ) NEW_LINE DEDENT return corr NEW_LINE DEDENT
Hyp: 
def correlationCoefficient ( X , Y , n ) : NEW_LINE INDENT sum_X = 0 NEW_LINE sum_Y = 0 NEW_LINE sum_XY = 0 NEW_LINE squareSum_X = 0 NEW_LINE squareSum_Y = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum_X = sum_X + X [ i ] NEW_LINE sum_Y = sum_Y + Y [ i ] NEW_LINE sum_XY = sum_XY + X [ i ] * Y [ i ] NEW_LINE squareSum_X = squareSum_X + X [ i ] * X [ i ] NEW_LINE squareSum_Y = squareSum_Y + Y [ i ] * Y [ i ] NEW_LINE DEDENT corr = ( float ) ( ( n * sum_XY - sum_X * sum_Y ) / math . sqrt ( ( n * squareSum_X - sum_X * sum_X ) * ( n * squareSum_Y - sum_Y * sum_Y ) ) ) NEW_LINE return corr NEW_LINE DEDENT

BLEU: 83.87
Edit Sim: 76


Src: 
int findArea ( int arr [ ] , int n ) { sort ( arr , arr + n , greater < int > ( ) ) ; int dimension [ 2 ] = { 0 , 0 } ; for ( int i = 0 , j = 0 ; i < n - 1 && j < 2 ; i ++ ) if ( arr [ i ] == arr [ i + 1 ] ) dimension [ j ++ ] = arr [ i ++ ] ; return ( dimension [ 0 ] * dimension [ 1 ] ) ; }
Ref: 
def findArea ( arr , n ) : NEW_LINE INDENT arr . sort ( reverse = True ) NEW_LINE dimension = [ 0 , 0 ] NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE while ( i < n - 1 and j < 2 ) : NEW_LINE INDENT if ( arr [ i ] == arr [ i + 1 ] ) : NEW_LINE INDENT dimension [ j ] = arr [ i ] NEW_LINE j += 1 NEW_LINE i += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return ( dimension [ 0 ] * dimension [ 1 ] ) NEW_LINE DEDENT
Hyp: 
def findArea ( arr , n ) : NEW_LINE INDENT arr . sort ( reverse = True ) NEW_LINE dimension = [ 0 , 0 ] * 2 NEW_LINE j = 0 NEW_LINE i = 0 NEW_LINE while ( i < n - 1 and j < 2 ) : NEW_LINE INDENT if ( arr [ i ] == arr [ i + 1 ] ) : NEW_LINE INDENT dimension [ j ] = arr [ i ] NEW_LINE i += 1 NEW_LINE DEDENT DEDENT return ( dimension [ 0 ] * dimension [ 1 ] ) NEW_LINE DEDENT

BLEU: 88.03
Edit Sim: 38


Src: 
int minOps ( int arr [ ] , int n , int k ) { int max = * max_element ( arr , arr + n ) ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( max - arr [ i ] ) % k != 0 ) return - 1 ; else res += ( max - arr [ i ] ) / k ; } return res ; }
Ref: 
def minOps ( arr , n , k ) : NEW_LINE INDENT max1 = max ( arr ) NEW_LINE res = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( ( max1 - arr [ i ] ) % k != 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT res += ( max1 - arr [ i ] ) / k NEW_LINE DEDENT DEDENT return int ( res ) NEW_LINE DEDENT
Hyp: 
def minOps ( arr , n , k ) : NEW_LINE INDENT max1 = max ( arr ) NEW_LINE res = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( ( max - arr [ i ] ) % k != 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT res += ( max - arr [ i ] ) / k NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT

BLEU: 87.83
Edit Sim: 10


Src: 
int floorSqrt ( int x ) { if ( x == 0 || x == 1 ) return x ; int i = 1 , result = 1 ; while ( result <= x ) { i ++ ; result = i * i ; } return i - 1 ; }
Ref: 
def floorSqrt ( x ) : NEW_LINE INDENT if ( x == 0 or x == 1 ) : NEW_LINE INDENT return x NEW_LINE DEDENT i = 1 result = 1 NEW_LINE while ( result <= x ) : NEW_LINE INDENT i += 1 NEW_LINE result = i * i NEW_LINE DEDENT return i - 1 NEW_LINE DEDENT
Hyp: 
def floorSqrt ( x ) : NEW_LINE INDENT if ( x == 0 or x == 1 ) : NEW_LINE INDENT return x NEW_LINE DEDENT i = 1 NEW_LINE result = 1 NEW_LINE while ( result <= x ) : NEW_LINE INDENT i += 1 NEW_LINE result = i * i NEW_LINE DEDENT return i - 1 NEW_LINE DEDENT

BLEU: 95.67
Edit Sim: 9


Src: 
int isdivisible7 ( char num [ ] ) { int n = strlen ( num ) , gSum ; if ( n == 0 && num [ 0 ] == ' \n ' ) return 1 ; if ( n % 3 == 1 ) { strcat ( num , "00" ) ; n += 2 ; } else if ( n % 3 == 2 ) { strcat ( num , "0" ) ; n ++ ; } int i , GSum = 0 , p = 1 ; for ( i = n - 1 ; i >= 0 ; i -- ) { int group = 0 ; group += num [ i -- ] - '0' ; group += ( num [ i -- ] - '0' ) * 10 ; group += ( num [ i ] - '0' ) * 100 ; gSum = gSum + group * p ; p *= ( - 1 ) ; } return ( gSum % 7 == 0 ) ; }
Ref: 
def isdivisible7 ( num ) : NEW_LINE INDENT n = len ( num ) NEW_LINE if ( n == 0 and num [ 0 ] == ' \n ' ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n % 3 == 1 ) : NEW_LINE INDENT num = str ( num ) + "00" NEW_LINE n += 2 NEW_LINE DEDENT elif ( n % 3 == 2 ) : NEW_LINE INDENT num = str ( num ) + "0" NEW_LINE n += 1 NEW_LINE DEDENT GSum = 0 NEW_LINE p = 1 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT group = 0 NEW_LINE group += ord ( num [ i ] ) - ord ( '0' ) NEW_LINE i -= 1 NEW_LINE group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 10 NEW_LINE i -= 1 NEW_LINE group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 100 NEW_LINE GSum = GSum + group * p NEW_LINE p *= ( - 1 ) NEW_LINE DEDENT return ( GSum % 7 == 0 ) NEW_LINE DEDENT
Hyp: 
def isdivisible7 ( num ) : NEW_LINE INDENT n = len ( num ) NEW_LINE gSum = 0 NEW_LINE if n == 0 and num [ 0 ] == ' \n ' : NEW_LINE INDENT return 1 NEW_LINE DEDENT if n % 3 == 1 : NEW_LINE INDENT num = list ( num ) NEW_LINE n += 2 NEW_LINE DEDENT elif n % 3 == 2 : NEW_LINE INDENT num = list ( num ) NEW_LINE n += 1 NEW_LINE DEDENT i = n - 1 NEW_LINE while i >= 0 : NEW_LINE INDENT group = 0 NEW_LINE group += ord ( num [ i ] ) - ord ( '0' ) NEW_LINE group += ord ( num [ i ] ) - ord ( '0' ) NEW_LINE group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 10 NEW_LINE group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 100 NEW_LINE gSum = gSum + group * p NEW_LINE p = ( - 1 ) NEW_LINE DEDENT return ( gSum % 7 == 0 ) NEW_LINE DEDENT

BLEU: 67.19
Edit Sim: 152


Src: 
void printMat ( int degseq [ ] , int n ) { int mat [ n ] [ n ] ; memset ( mat , 0 , sizeof ( mat ) ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( degseq [ i ] > 0 && degseq [ j ] > 0 ) { degseq [ i ] -- ; degseq [ j ] -- ; mat [ i ] [ j ] = 1 ; mat [ j ] [ i ] = 1 ; } } } cout << " \n " << setw ( 3 ) << " ▁ ▁ ▁ ▁ ▁ " ; for ( int i = 0 ; i < n ; i ++ ) cout << setw ( 3 ) << " ( " << i << " ) " ; cout << " \n \n " ; for ( int i = 0 ; i < n ; i ++ ) { cout << setw ( 4 ) << " ( " << i << " ) " ; for ( int j = 0 ; j < n ; j ++ ) cout << setw ( 5 ) << mat [ i ] [ j ] ; cout << " \n " ; } }
Ref: 
def printMat ( degseq , n ) : NEW_LINE INDENT mat = [ [ 0 ] * n for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( degseq [ i ] > 0 and degseq [ j ] > 0 ) : NEW_LINE INDENT degseq [ i ] -= 1 NEW_LINE degseq [ j ] -= 1 NEW_LINE mat [ i ] [ j ] = 1 NEW_LINE mat [ j ] [ i ] = 1 NEW_LINE DEDENT DEDENT DEDENT print ( " ▁ ▁ ▁ ▁ ▁ ▁ " , end = " ▁ " ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( " ▁ " , " ( " , i , " ) " , end = " " ) NEW_LINE DEDENT print ( ) NEW_LINE print ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( " ▁ " , " ( " , i , " ) " , end = " " ) NEW_LINE for j in range ( n ) : NEW_LINE INDENT print ( " ▁ ▁ ▁ ▁ ▁ " , mat [ i ] [ j ] , end = " " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT
Hyp: 
def printMat ( degseq , n ) : NEW_LINE INDENT mat = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( degseq [ i ] > 0 and degseq [ j ] > 0 ) : NEW_LINE INDENT degseq [ i ] -= 1 NEW_LINE degseq [ j ] -= 1 NEW_LINE mat [ i ] [ j ] = 1 NEW_LINE mat [ j ] [ i ] = 1 NEW_LINE DEDENT DEDENT DEDENT print ( " \n " , setw ( 3 ) , " ▁ " ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( 3 , " ( " , i , " ) " ) NEW_LINE DEDENT print ( " \n " , 4 , end = " " ) NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT print ( setw ( 4 ) , mat [ i ] [ j ] ) NEW_LINE DEDENT print ( " \n " ) NEW_LINE DEDENT DEDENT

BLEU: 69.78
Edit Sim: 188


Src: 
int minTime ( int arr [ ] , int n , int m ) { int t = 0 ; while ( 1 ) { int items = 0 ; for ( int i = 0 ; i < n ; i ++ ) items += ( t / arr [ i ] ) ; if ( items >= m ) return t ; t ++ ; } }
Ref: 
def minTime ( arr , n , m ) : NEW_LINE INDENT t = 0 NEW_LINE while ( 1 ) : NEW_LINE INDENT items = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT items += ( t // arr [ i ] ) NEW_LINE DEDENT if ( items >= m ) : NEW_LINE INDENT return t NEW_LINE DEDENT t += 1 NEW_LINE DEDENT DEDENT
Hyp: 
def minTime ( arr , n , m ) : NEW_LINE INDENT t = 0 NEW_LINE while ( 1 ) : NEW_LINE INDENT items = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT items += ( t // arr [ i ] ) NEW_LINE DEDENT if ( items >= m ) : NEW_LINE INDENT return t NEW_LINE DEDENT t += 1 NEW_LINE DEDENT DEDENT

BLEU: 94.92
Edit Sim: 4


Src: 
long long int MaximumDecimalValue ( int mat [ ] [ N ] , int n ) { int dp [ n ] [ n ] ; memset ( dp , 0 , sizeof ( dp ) ) ; if ( mat [ 0 ] [ 0 ] == 1 ) dp [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( mat [ 0 ] [ i ] == 1 ) dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + pow ( 2 , i ) ; else dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] ; } for ( int i = 1 ; i < n ; i ++ ) { if ( mat [ i ] [ 0 ] == 1 ) dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + pow ( 2 , i ) ; else dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] ; } for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) { if ( mat [ i ] [ j ] == 1 ) dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) + pow ( 2 , i + j ) ; else dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ; } } return dp [ n - 1 ] [ n - 1 ] ; }
Ref: 
def MaximumDecimalValue ( mat , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] NEW_LINE if ( mat [ 0 ] [ 0 ] == 1 ) : NEW_LINE INDENT dp [ 0 ] [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( mat [ 0 ] [ i ] == 1 ) : NEW_LINE INDENT dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + 2 ** i NEW_LINE DEDENT else : NEW_LINE INDENT dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] NEW_LINE DEDENT DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( mat [ i ] [ 0 ] == 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + 2 ** i NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT if ( mat [ i ] [ j ] == 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) + ( 2 ** ( i + j ) ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ n - 1 ] [ n - 1 ] NEW_LINE DEDENT
Hyp: 
def MaximumDecimalValue ( mat , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] NEW_LINE if ( mat [ 0 ] [ 0 ] == 1 ) : NEW_LINE INDENT dp [ 0 ] [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( mat [ 0 ] [ i ] == 1 ) : NEW_LINE INDENT dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + pow ( 2 , i ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] NEW_LINE DEDENT DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( mat [ i ] [ 0 ] == 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + pow ( 2 , i ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] NEW_LINE DEDENT DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT if ( mat [ i ] [ j ] == 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) + pow ( 2 , i + j ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ n - 1 ] [ n - 1 ] NEW_LINE DEDENT

BLEU: 93.25
Edit Sim: 44


Src: 
bool isDivisible999 ( string num ) { int n = num . length ( ) ; if ( n == 0 && num [ 0 ] == '0' ) return true ; if ( n % 3 == 1 ) num = "00" + num ; if ( n % 3 == 2 ) num = "0" + num ; int gSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int group = 0 ; group += ( num [ i ++ ] - '0' ) * 100 ; group += ( num [ i ++ ] - '0' ) * 10 ; group += num [ i ] - '0' ; gSum += group ; } if ( gSum > 1000 ) { num = to_string ( gSum ) ; n = num . length ( ) ; gSum = isDivisible999 ( num ) ; } return ( gSum == 999 ) ; }
Ref: 
def isDivisible999 ( num ) : NEW_LINE INDENT n = len ( num ) ; NEW_LINE if ( n == 0 or num [ 0 ] == '0' ) : NEW_LINE INDENT return true NEW_LINE DEDENT if ( ( n % 3 ) == 1 ) : NEW_LINE INDENT num = "00" + num NEW_LINE DEDENT if ( ( n % 3 ) == 2 ) : NEW_LINE INDENT num = "0" + num NEW_LINE DEDENT gSum = 0 NEW_LINE for i in range ( 0 , n , 3 ) : NEW_LINE INDENT group = 0 NEW_LINE group += ( ord ( num [ i ] ) - 48 ) * 100 NEW_LINE group += ( ord ( num [ i + 1 ] ) - 48 ) * 10 NEW_LINE group += ( ord ( num [ i + 2 ] ) - 48 ) NEW_LINE gSum += group NEW_LINE DEDENT if ( gSum > 1000 ) : NEW_LINE INDENT num = str ( gSum ) NEW_LINE n = len ( num ) NEW_LINE gSum = isDivisible999 ( num ) NEW_LINE DEDENT return ( gSum == 999 ) NEW_LINE DEDENT
Hyp: 
def isDivisible999 ( num ) : NEW_LINE INDENT n = len ( num ) NEW_LINE if ( n == 0 and num [ 0 ] == '0' ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 3 == 1 ) : NEW_LINE INDENT num = "00" + num NEW_LINE DEDENT if ( n % 3 == 2 ) : NEW_LINE INDENT num = "0" + num NEW_LINE DEDENT gSum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT group = 0 NEW_LINE group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 100 NEW_LINE group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 10 NEW_LINE group += ord ( num [ i ] ) - ord ( '0' ) ) NEW_LINE gSum += group NEW_LINE DEDENT if ( gSum > 1000 ) : NEW_LINE INDENT num = str ( gSum ) NEW_LINE n = len ( num ) NEW_LINE gSum = isDivisible999 ( num ) NEW_LINE DEDENT return ( gSum == 999 ) NEW_LINE DEDENT

BLEU: 81.06
Edit Sim: 55


Src: 
int maxSumBitonicSubArr ( int arr [ ] , int n ) { int msis [ n ] , msds [ n ] ; int max_sum = INT_MIN ; msis [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] > arr [ i - 1 ] ) msis [ i ] = msis [ i - 1 ] + arr [ i ] ; else msis [ i ] = arr [ i ] ; msds [ n - 1 ] = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) if ( arr [ i ] > arr [ i + 1 ] ) msds [ i ] = msds [ i + 1 ] + arr [ i ] ; else msds [ i ] = arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) if ( max_sum < ( msis [ i ] + msds [ i ] - arr [ i ] ) ) max_sum = msis [ i ] + msds [ i ] - arr [ i ] ; return max_sum ; }
Ref: 
def maxSumBitonicSubArr ( arr , n ) : NEW_LINE INDENT msis = [ None ] * n NEW_LINE msds = [ None ] * n NEW_LINE max_sum = 0 NEW_LINE msis [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i - 1 ] ) : NEW_LINE INDENT msis [ i ] = msis [ i - 1 ] + arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT msis [ i ] = arr [ i ] NEW_LINE DEDENT DEDENT msds [ n - 1 ] = arr [ n - 1 ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i + 1 ] ) : NEW_LINE INDENT msds [ i ] = msds [ i + 1 ] + arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT msds [ i ] = arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( max_sum < ( msis [ i ] + msds [ i ] - arr [ i ] ) ) : NEW_LINE INDENT max_sum = ( msis [ i ] + msds [ i ] - arr [ i ] ) NEW_LINE DEDENT DEDENT return max_sum NEW_LINE DEDENT
Hyp: 
def maxSumBitonicSubArr ( arr , n ) : NEW_LINE INDENT msis = [ 0 ] * n NEW_LINE msds = [ 0 ] * n NEW_LINE max_sum = - sys . maxsize - 1 NEW_LINE msis [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i - 1 ] ) : NEW_LINE INDENT msis [ i ] = msis [ i - 1 ] + arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT msis [ i ] = arr [ i ] NEW_LINE DEDENT DEDENT msds [ n - 1 ] = arr [ n - 1 ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i + 1 ] ) : NEW_LINE INDENT msds [ i ] = msds [ i + 1 ] + arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT msds [ i ] = arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( max_sum < ( msis [ i ] + msds [ i ] - arr [ i ] ) ) : NEW_LINE INDENT max_sum = msis [ i ] + msds [ i ] - arr [ i ] NEW_LINE DEDENT DEDENT return max_sum NEW_LINE DEDENT

BLEU: 93.8
Edit Sim: 31


Src: 
int findMinNumber ( int n ) { int count = 0 , ans = 1 ; while ( n % 2 == 0 ) { count ++ ; n /= 2 ; } if ( count % 2 ) ans *= 2 ; for ( int i = 3 ; i <= sqrt ( n ) ; i += 2 ) { count = 0 ; while ( n % i == 0 ) { count ++ ; n /= i ; } if ( count % 2 ) ans *= i ; } if ( n > 2 ) ans *= n ; return ans ; }
Ref: 
def findMinNumber ( n ) : NEW_LINE INDENT count = 0 NEW_LINE ans = 1 NEW_LINE while n % 2 == 0 : NEW_LINE INDENT count += 1 NEW_LINE n //= 2 NEW_LINE DEDENT if count % 2 is not 0 : NEW_LINE INDENT ans *= 2 NEW_LINE DEDENT for i in range ( 3 , ( int ) ( math . sqrt ( n ) ) + 1 , 2 ) : NEW_LINE INDENT count = 0 NEW_LINE while n % i == 0 : NEW_LINE INDENT count += 1 NEW_LINE n //= i NEW_LINE DEDENT if count % 2 is not 0 : NEW_LINE INDENT ans *= i NEW_LINE DEDENT DEDENT if n > 2 : NEW_LINE INDENT ans *= n NEW_LINE DEDENT return ans NEW_LINE DEDENT
Hyp: 
def findMinNumber ( n ) : NEW_LINE INDENT count = 0 NEW_LINE ans = 1 NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE n /= 2 NEW_LINE DEDENT if ( count % 2 ) : NEW_LINE INDENT ans *= 2 NEW_LINE DEDENT for i in range ( 3 , int ( m . sqrt ( n ) + 2 ) ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n % i == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE n /= i NEW_LINE DEDENT if ( count % 2 ) : NEW_LINE INDENT ans *= i NEW_LINE DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT ans = ans * n NEW_LINE DEDENT return ans NEW_LINE DEDENT

BLEU: 67.22
Edit Sim: 54


Src: 
int rangeGCD ( int n , int m ) { return ( n == m ) ? n : 1 ; }
Ref: 
def rangeGCD ( n , m ) : NEW_LINE INDENT return n if ( n == m ) else 1 NEW_LINE DEDENT
Hyp: 
def rangeGCD ( n , m ) : NEW_LINE INDENT return ( n == m ) ? n : 1 NEW_LINE DEDENT

BLEU: 71.32
Edit Sim: 10


Src: 
int assignValue ( int a , int b , bool x ) { int arr [ ] = { a , b } ; return ( arr [ x ] ) ; }
Ref: 
def assignValue ( a , b , x ) : NEW_LINE INDENT arr = [ a , b ] NEW_LINE return ( arr [ x ] ) NEW_LINE DEDENT
Hyp: 
def assignValue ( a , b , x ) : NEW_LINE INDENT arr = [ a , b ] NEW_LINE return arr [ x ] NEW_LINE DEDENT

BLEU: 82.62
Edit Sim: 4


Src: 
bool isTriangular ( int num ) { if ( num < 0 ) return false ; int sum = 0 ; for ( int n = 1 ; sum <= num ; n ++ ) { sum = sum + n ; if ( sum == num ) return true ; } return false ; }
Ref: 
def isTriangular ( num ) : NEW_LINE INDENT if ( num < 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT sum , n = 0 , 1 NEW_LINE while ( sum <= num ) : NEW_LINE INDENT sum = sum + n NEW_LINE if ( sum == num ) : NEW_LINE INDENT return True NEW_LINE DEDENT n += 1 NEW_LINE DEDENT return False NEW_LINE DEDENT
Hyp: 
def isTriangular ( num ) : NEW_LINE INDENT if ( num < 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT sum = 0 NEW_LINE for n in range ( 1 , num + 1 ) : NEW_LINE INDENT sum = sum + n NEW_LINE if ( sum == num ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT

BLEU: 74.08
Edit Sim: 45


Src: 
bool checkPangram ( string & str ) { vector < bool > mark ( 26 , false ) ; int index ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( ' A ' <= str [ i ] && str [ i ] <= ' Z ' ) index = str [ i ] - ' A ' ; else if ( ' a ' <= str [ i ] && str [ i ] <= ' z ' ) index = str [ i ] - ' a ' ; mark [ index ] = true ; } for ( int i = 0 ; i <= 25 ; i ++ ) if ( mark [ i ] == false ) return ( false ) ; return ( true ) ; }
Ref: 
def checkPangram ( s ) : NEW_LINE INDENT List = [ ] NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT List . append ( False ) NEW_LINE DEDENT for c in s . lower ( ) : NEW_LINE INDENT if not c == " ▁ " : NEW_LINE INDENT List [ ord ( c ) - ord ( ' a ' ) ] = True NEW_LINE DEDENT DEDENT for ch in List : NEW_LINE INDENT if ch == False : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
Hyp: 
def checkPangram ( st ) : NEW_LINE INDENT mark = [ False for i in range ( 26 ) ] NEW_LINE index = 0 NEW_LINE for i in range ( len ( st ) ) : NEW_LINE INDENT if ( ' A ' <= st [ i ] and st [ i ] <= ' Z ' ) : NEW_LINE INDENT index = ord ( st [ i ] ) - ord ( ' A ' ) NEW_LINE DEDENT elif ( ' a ' <= st [ i ] and st [ i ] <= ' z ' ) : NEW_LINE INDENT index = ord ( st [ i ] ) - ord ( ' a ' ) NEW_LINE DEDENT mark [ index ] = True NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT if ( mark [ i ] == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT

BLEU: 29.64
Edit Sim: 245


Src: 
int interpolationSearch ( int arr [ ] , int n , int x ) { int lo = 0 , hi = ( n - 1 ) ; while ( lo <= hi && x >= arr [ lo ] && x <= arr [ hi ] ) { if ( lo == hi ) { if ( arr [ lo ] == x ) return lo ; return - 1 ; } int pos = lo + ( ( ( double ) ( hi - lo ) / ( arr [ hi ] - arr [ lo ] ) ) * ( x - arr [ lo ] ) ) ; if ( arr [ pos ] == x ) return pos ; if ( arr [ pos ] < x ) lo = pos + 1 ; else hi = pos - 1 ; } return - 1 ; }
Ref: 
def interpolationSearch ( arr , n , x ) : NEW_LINE INDENT lo = 0 NEW_LINE hi = ( n - 1 ) NEW_LINE while lo <= hi and x >= arr [ lo ] and x <= arr [ hi ] : NEW_LINE INDENT if lo == hi : NEW_LINE INDENT if arr [ lo ] == x : NEW_LINE INDENT return lo ; NEW_LINE DEDENT return - 1 ; NEW_LINE DEDENT pos = lo + int ( ( ( float ( hi - lo ) / ( arr [ hi ] - arr [ lo ] ) ) * ( x - arr [ lo ] ) ) ) NEW_LINE if arr [ pos ] == x : NEW_LINE INDENT return pos NEW_LINE DEDENT if arr [ pos ] < x : NEW_LINE INDENT lo = pos + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT hi = pos - 1 ; NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
Hyp: 
def interpolationSearch ( arr , n , x ) : NEW_LINE INDENT lo = 0 NEW_LINE hi = ( n - 1 ) NEW_LINE while ( lo <= hi and x >= arr [ lo ] and x <= arr [ hi ] ) : NEW_LINE INDENT if ( lo == hi ) : NEW_LINE INDENT if ( arr [ lo ] == x ) : NEW_LINE INDENT return lo NEW_LINE DEDENT return - 1 NEW_LINE DEDENT pos = lo + ( ( ( hi - lo ) / ( arr [ hi ] - arr [ lo ] ) ) * ( x - arr [ lo ] ) ) NEW_LINE if ( arr [ pos ] == x ) : NEW_LINE INDENT return pos NEW_LINE DEDENT if ( arr [ pos ] < x ) : NEW_LINE INDENT lo = pos + 1 NEW_LINE DEDENT else : NEW_LINE INDENT hi = pos - 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT

BLEU: 78.9
Edit Sim: 42


Src: 
void minSpacePreferLarge ( int wall , int m , int n ) { int num_m = 0 , num_n = 0 , min_empty = wall ; int p = 0 , q = 0 , rem ; while ( wall >= n ) { p = wall / m ; rem = wall % m ; if ( rem <= min_empty ) { num_m = p ; num_n = q ; min_empty = rem ; } q += 1 ; wall = wall - n ; } cout << num_m << " ▁ " << num_n << " ▁ " << min_empty << endl ; }
Ref: 
def minSpacePreferLarge ( w , m , n ) : NEW_LINE INDENT num_m = 0 NEW_LINE num_n = 0 NEW_LINE rem = w NEW_LINE p = 0 NEW_LINE q = 0 NEW_LINE r = 0 NEW_LINE while ( w >= n ) : NEW_LINE INDENT p = w / m NEW_LINE r = w % m NEW_LINE if ( r <= rem ) : NEW_LINE INDENT num_m = p NEW_LINE num_n = q NEW_LINE rem = r NEW_LINE DEDENT q += 1 NEW_LINE w -= n NEW_LINE DEDENT print ( str ( int ( num_m ) ) + " ▁ " + str ( num_n ) + " ▁ " + str ( rem ) ) NEW_LINE DEDENT
Hyp: 
def minSpacePreferLarge ( wall , m , n ) : NEW_LINE INDENT num_m = 0 NEW_LINE num_n = 0 NEW_LINE min_empty = wall NEW_LINE p = 0 NEW_LINE q = 0 NEW_LINE rem = 0 NEW_LINE while ( wall >= n ) : NEW_LINE INDENT p = wall // m NEW_LINE rem = wall % m NEW_LINE if ( rem <= min_empty ) : NEW_LINE INDENT num_m = p NEW_LINE num_n = q NEW_LINE min_empty = rem NEW_LINE DEDENT q += 1 NEW_LINE wall = wall - n NEW_LINE DEDENT print ( num_m , " ▁ " , num_n , " ▁ " , min_empty ) NEW_LINE DEDENT

BLEU: 54.91
Edit Sim: 94


Src: 
int findRepeating ( int arr [ ] , int n ) { int missingElement = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int element = arr [ abs ( arr [ i ] ) ] ; if ( element < 0 ) { missingElement = arr [ i ] ; break ; } arr [ abs ( arr [ i ] ) ] = - arr [ abs ( arr [ i ] ) ] ; } return abs ( missingElement ) ; }
Ref: 
def findRepeating ( arr , n ) : NEW_LINE INDENT missingElement = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT element = arr [ abs ( arr [ i ] ) ] NEW_LINE if ( element < 0 ) : NEW_LINE INDENT missingElement = arr [ i ] NEW_LINE break NEW_LINE DEDENT arr [ abs ( arr [ i ] ) ] = - arr [ abs ( arr [ i ] ) ] NEW_LINE DEDENT return abs ( missingElement ) NEW_LINE DEDENT
Hyp: 
def findRepeating ( arr , n ) : NEW_LINE INDENT missingElement = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT element = arr [ abs ( arr [ i ] ) ] NEW_LINE if ( element < 0 ) : NEW_LINE INDENT missingElement = arr [ i ] NEW_LINE break NEW_LINE DEDENT arr [ abs ( arr [ i ] ) ] = - arr [ abs ( arr [ i ] ) ] NEW_LINE DEDENT return abs ( missingElement ) NEW_LINE DEDENT

BLEU: 96.01
Edit Sim: 4


Src: 
void kLargest ( int arr [ ] , int n , int k ) { sort ( arr , arr + n , greater < int > ( ) ) ; for ( int i = 0 ; i < k ; i ++ ) cout << arr [ i ] << " ▁ " ; }
Ref: 
def kLargest ( arr , k ) : NEW_LINE INDENT arr . sort ( reverse = True ) NEW_LINE for i in range ( k ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
Hyp: 
def kLargest ( arr , n , k ) : NEW_LINE INDENT arr . sort ( reverse = True ) NEW_LINE for i in range ( k ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT

BLEU: 94.02
Edit Sim: 4


Src: 
int knapSack ( int W , int wt [ ] , int val [ ] , int n ) { int i , w ; int K [ n + 1 ] [ W + 1 ] ; for ( i = 0 ; i <= n ; i ++ ) { for ( w = 0 ; w <= W ; w ++ ) { if ( i == 0 || w == 0 ) K [ i ] [ w ] = 0 ; else if ( wt [ i - 1 ] <= w ) K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) ; else K [ i ] [ w ] = K [ i - 1 ] [ w ] ; } } return K [ n ] [ W ] ; }
Ref: 
def knapSack ( W , wt , val , n ) : NEW_LINE INDENT K = [ [ 0 for x in range ( W + 1 ) ] for x in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for w in range ( W + 1 ) : NEW_LINE INDENT if i == 0 or w == 0 : NEW_LINE INDENT K [ i ] [ w ] = 0 NEW_LINE DEDENT elif wt [ i - 1 ] <= w : NEW_LINE INDENT K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) NEW_LINE DEDENT else : NEW_LINE INDENT K [ i ] [ w ] = K [ i - 1 ] [ w ] NEW_LINE DEDENT DEDENT DEDENT return K [ n ] [ W ] NEW_LINE DEDENT
Hyp: 
def knapSack ( W , wt , val , n ) : NEW_LINE INDENT K = [ [ 0 for x in range ( W + 1 ) ] for x in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for w in range ( W + 1 ) : NEW_LINE INDENT if i == 0 or w == 0 : NEW_LINE INDENT K [ i ] [ w ] = 0 NEW_LINE DEDENT elif wt [ i - 1 ] <= w : NEW_LINE INDENT K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) NEW_LINE DEDENT else : NEW_LINE INDENT K [ i ] [ w ] = K [ i - 1 ] [ w ] NEW_LINE DEDENT DEDENT DEDENT return K [ n ] [ W ] NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
bool isPowerOfFour ( unsigned int n ) { return n != 0 && ( ( n & ( n - 1 ) ) == 0 ) && ! ( n & 0xAAAAAAAA ) ; }
Ref: 
def isPowerOfFour ( n ) : NEW_LINE INDENT return ( n != 0 and ( ( n & ( n - 1 ) ) == 0 ) and not ( n & 0xAAAAAAAA ) ) NEW_LINE DEDENT
Hyp: 
def isPowerOfFour ( n ) : NEW_LINE INDENT return n != 0 and ( ( n & ( n - 1 ) ) == 0 ) and not ( n & 0xAAAAAAAA ) NEW_LINE DEDENT

BLEU: 87.94
Edit Sim: 4


Src: 
unsigned int factorial ( unsigned int n ) { if ( n == 0 ) return 1 ; return n * factorial ( n - 1 ) ; }
Ref: 
def factorial ( n ) : NEW_LINE INDENT return 1 if ( n == 1 or n == 0 ) else n * factorial ( n - 1 ) NEW_LINE DEDENT
Hyp: 
def factorial ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return n * factorial ( n - 1 ) NEW_LINE DEDENT

BLEU: 69.67
Edit Sim: 50


Src: 
int findgroups ( int arr [ ] , int n ) { int c [ 3 ] = { 0 } , i ; int res = 0 ; for ( i = 0 ; i < n ; i ++ ) c [ arr [ i ] % 3 ] ++ ; res += ( ( c [ 0 ] * ( c [ 0 ] - 1 ) ) >> 1 ) ; res += c [ 1 ] * c [ 2 ] ; res += ( c [ 0 ] * ( c [ 0 ] - 1 ) * ( c [ 0 ] - 2 ) ) / 6 ; res += ( c [ 1 ] * ( c [ 1 ] - 1 ) * ( c [ 1 ] - 2 ) ) / 6 ; res += ( ( c [ 2 ] * ( c [ 2 ] - 1 ) * ( c [ 2 ] - 2 ) ) / 6 ) ; res += c [ 0 ] * c [ 1 ] * c [ 2 ] ; return res ; }
Ref: 
def findgroups ( arr , n ) : NEW_LINE INDENT c = [ 0 , 0 , 0 ] NEW_LINE res = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT c [ arr [ i ] % 3 ] += 1 NEW_LINE DEDENT res += ( ( c [ 0 ] * ( c [ 0 ] - 1 ) ) >> 1 ) NEW_LINE res += c [ 1 ] * c [ 2 ] NEW_LINE res += ( c [ 0 ] * ( c [ 0 ] - 1 ) * ( c [ 0 ] - 2 ) ) / 6 NEW_LINE res += ( c [ 1 ] * ( c [ 1 ] - 1 ) * ( c [ 1 ] - 2 ) ) / 6 NEW_LINE res += ( ( c [ 2 ] * ( c [ 2 ] - 1 ) * ( c [ 2 ] - 2 ) ) / 6 ) NEW_LINE res += c [ 0 ] * c [ 1 ] * c [ 2 ] NEW_LINE return res NEW_LINE DEDENT
Hyp: 
def findgroups ( arr , n ) : NEW_LINE INDENT c = [ 0 for i in range ( 3 ) ] NEW_LINE res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT c [ arr [ i ] % 3 ] = c [ i ] + 1 NEW_LINE DEDENT res += ( ( c [ 0 ] * ( c [ 0 ] - 1 ) ) >> 1 ) NEW_LINE res += c [ 1 ] * c [ 2 ] NEW_LINE res += ( ( c [ 0 ] * ( c [ 0 ] - 1 ) ) >> 1 ) NEW_LINE res += c [ 0 ] * c [ 2 ] NEW_LINE res += ( ( c [ 0 ] * ( c [ 0 ] - 1 ) * ( c [ 0 ] - 2 ) ) / 6 ) NEW_LINE res += ( ( c [ 1 ] * ( c [ 1 ] - 1 ) * ( c [ 1 ] - 2 ) ) / 6 ) NEW_LINE res += ( ( c [ 2 ] * ( c [ 2 ] - 1 ) * ( c [ 2 ] - 2 ) ) / 6 ) NEW_LINE res += ( ( c [ 0 ] * c [ 1 ] * c [ 2 ] - 1 ) * ( c [ 2 ] - 2 ) ) / 6 ) NEW_LINE res += ( ( c [ 0 ] * c [ 1 ] * c [ 2 ] - 1 ) * ( c [ 0 ] - 2 ) ) / 6 ) NEW_LINE return res NEW_LINE DEDENT

BLEU: 61.03
Edit Sim: 245


Src: 
int kthLargestSum ( int arr [ ] , int n , int k ) { int sum [ n + 1 ] ; sum [ 0 ] = 0 ; sum [ 1 ] = arr [ 0 ] ; for ( int i = 2 ; i <= n ; i ++ ) sum [ i ] = sum [ i - 1 ] + arr [ i - 1 ] ; priority_queue < int , vector < int > , greater < int > > Q ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = i ; j <= n ; j ++ ) { int x = sum [ j ] - sum [ i - 1 ] ; if ( Q . size ( ) < k ) Q . push ( x ) ; else { if ( Q . top ( ) < x ) { Q . pop ( ) ; Q . push ( x ) ; } } } } return Q . top ( ) ; }
Ref: 
def kthLargestSum ( arr , n , k ) : NEW_LINE INDENT sum = [ ] NEW_LINE sum . append ( 0 ) NEW_LINE sum . append ( arr [ 0 ] ) NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT sum . append ( sum [ i - 1 ] + arr [ i - 1 ] ) NEW_LINE DEDENT Q = [ ] NEW_LINE heapq . heapify ( Q ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( i , n + 1 ) : NEW_LINE INDENT x = sum [ j ] - sum [ i - 1 ] NEW_LINE if len ( Q ) < k : NEW_LINE INDENT heapq . heappush ( Q , x ) NEW_LINE DEDENT else : NEW_LINE INDENT if Q [ 0 ] < x : NEW_LINE INDENT heapq . heappop ( Q ) NEW_LINE heapq . heappush ( Q , x ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return Q [ 0 ] NEW_LINE DEDENT
Hyp: 
def kthLargestSum ( arr , n , k ) : NEW_LINE INDENT sum = [ 0 ] * ( n + 1 ) NEW_LINE sum [ 0 ] = 0 NEW_LINE sum [ 1 ] = arr [ 0 ] NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT sum [ i ] = sum [ i - 1 ] + arr [ i - 1 ] NEW_LINE DEDENT Q = PriorityQueue ( ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( i , n + 1 ) : NEW_LINE INDENT x = sum [ j ] - sum [ i - 1 ] NEW_LINE if ( len ( Q ) < k ) : NEW_LINE INDENT Q . put ( x ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( Q [ - 1 ] < x ) : NEW_LINE INDENT Q . pop ( ) NEW_LINE Q . put ( x ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return Q . get ( ) NEW_LINE DEDENT

BLEU: 67.43
Edit Sim: 131


Src: 
int findMaxValue ( int mat [ ] [ N ] ) { int maxValue = INT_MIN ; int maxArr [ N ] [ N ] ; maxArr [ N - 1 ] [ N - 1 ] = mat [ N - 1 ] [ N - 1 ] ; int maxv = mat [ N - 1 ] [ N - 1 ] ; for ( int j = N - 2 ; j >= 0 ; j -- ) { if ( mat [ N - 1 ] [ j ] > maxv ) maxv = mat [ N - 1 ] [ j ] ; maxArr [ N - 1 ] [ j ] = maxv ; } maxv = mat [ N - 1 ] [ N - 1 ] ; for ( int i = N - 2 ; i >= 0 ; i -- ) { if ( mat [ i ] [ N - 1 ] > maxv ) maxv = mat [ i ] [ N - 1 ] ; maxArr [ i ] [ N - 1 ] = maxv ; } for ( int i = N - 2 ; i >= 0 ; i -- ) { for ( int j = N - 2 ; j >= 0 ; j -- ) { if ( maxArr [ i + 1 ] [ j + 1 ] - mat [ i ] [ j ] > maxValue ) maxValue = maxArr [ i + 1 ] [ j + 1 ] - mat [ i ] [ j ] ; maxArr [ i ] [ j ] = max ( mat [ i ] [ j ] , max ( maxArr [ i ] [ j + 1 ] , maxArr [ i + 1 ] [ j ] ) ) ; } } return maxValue ; }
Ref: 
def findMaxValue ( mat ) : NEW_LINE INDENT maxValue = - sys . maxsize - 1 NEW_LINE maxArr = [ [ 0 for x in range ( N ) ] for y in range ( N ) ] NEW_LINE maxArr [ N - 1 ] [ N - 1 ] = mat [ N - 1 ] [ N - 1 ] NEW_LINE maxv = mat [ N - 1 ] [ N - 1 ] NEW_LINE for j in range ( N - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( mat [ N - 1 ] [ j ] > maxv ) : NEW_LINE INDENT maxv = mat [ N - 1 ] [ j ] NEW_LINE DEDENT maxArr [ N - 1 ] [ j ] = maxv NEW_LINE DEDENT maxv = mat [ N - 1 ] [ N - 1 ] NEW_LINE for i in range ( N - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( mat [ i ] [ N - 1 ] > maxv ) : NEW_LINE INDENT maxv = mat [ i ] [ N - 1 ] NEW_LINE DEDENT maxArr [ i ] [ N - 1 ] = maxv NEW_LINE DEDENT for i in range ( N - 2 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( N - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( maxArr [ i + 1 ] [ j + 1 ] - mat [ i ] [ j ] > maxValue ) : NEW_LINE INDENT maxValue = ( maxArr [ i + 1 ] [ j + 1 ] - mat [ i ] [ j ] ) NEW_LINE DEDENT maxArr [ i ] [ j ] = max ( mat [ i ] [ j ] , max ( maxArr [ i ] [ j + 1 ] , maxArr [ i + 1 ] [ j ] ) ) NEW_LINE DEDENT DEDENT return maxValue NEW_LINE DEDENT
Hyp: 
def findMaxValue ( mat ) : NEW_LINE INDENT maxValue = - sys . maxsize - 1 NEW_LINE maxArr = [ [ 0 for i in range ( N ) ] for j in range ( N ) ] NEW_LINE maxArr [ N - 1 ] [ N - 1 ] = mat [ N - 1 ] [ N - 1 ] NEW_LINE maxv = mat [ N - 1 ] [ N - 1 ] NEW_LINE for j in range ( N - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( mat [ N - 1 ] [ j ] > maxv ) : NEW_LINE INDENT maxv = mat [ N - 1 ] [ j ] NEW_LINE DEDENT maxArr [ N - 1 ] [ j ] = maxv NEW_LINE DEDENT maxv = mat [ N - 1 ] [ N - 1 ] NEW_LINE for i in range ( N - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( mat [ i ] [ N - 1 ] > maxv ) : NEW_LINE INDENT maxv = mat [ i ] [ N - 1 ] NEW_LINE DEDENT maxArr [ i ] [ N - 1 ] = maxv NEW_LINE DEDENT for i in range ( N - 2 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( N - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( maxArr [ i + 1 ] [ j + 1 ] - mat [ i ] [ j ] > maxValue ) : NEW_LINE INDENT maxValue = maxArr [ i + 1 ] [ j + 1 ] - mat [ i ] [ j ] NEW_LINE DEDENT maxArr [ i ] [ j ] = max ( mat [ i ] [ j ] , max ( maxArr [ i + 1 ] [ j + 1 ] , maxArr [ i + 1 ] [ j ] ) ) NEW_LINE DEDENT DEDENT return maxValue NEW_LINE DEDENT

BLEU: 96.68
Edit Sim: 10


Src: 
int kPrimeFactor ( int n , int k ) { while ( n % 2 == 0 ) { k -- ; n = n / 2 ; if ( k == 0 ) return 2 ; } for ( int i = 3 ; i <= sqrt ( n ) ; i = i + 2 ) { while ( n % i == 0 ) { if ( k == 1 ) return i ; k -- ; n = n / i ; } } if ( n > 2 && k == 1 ) return n ; return - 1 ; }
Ref: 
def kPrimeFactor ( n , k ) : NEW_LINE INDENT while ( n % 2 == 0 ) : NEW_LINE INDENT k = k - 1 NEW_LINE n = n / 2 NEW_LINE if ( k == 0 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT DEDENT i = 3 NEW_LINE while i <= math . sqrt ( n ) : NEW_LINE INDENT while ( n % i == 0 ) : NEW_LINE INDENT if ( k == 1 ) : NEW_LINE INDENT return i NEW_LINE DEDENT k = k - 1 NEW_LINE n = n / i NEW_LINE DEDENT i = i + 2 NEW_LINE DEDENT if ( n > 2 and k == 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
Hyp: 
def kPrimeFactor ( n , k ) : NEW_LINE INDENT while ( n % 2 == 0 ) : NEW_LINE INDENT k -= 1 NEW_LINE n = n / 2 NEW_LINE if ( k == 0 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT i = 3 NEW_LINE while ( i <= ( math . sqrt ( n ) ) : NEW_LINE INDENT while ( n % i == 0 ) : NEW_LINE INDENT if ( k == 1 ) : NEW_LINE INDENT return i NEW_LINE DEDENT k -= 1 NEW_LINE n = n / i NEW_LINE DEDENT DEDENT if ( n > 2 and k == 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT return - 1 NEW_LINE DEDENT

BLEU: 83.49
Edit Sim: 42


Src: 
void printDistinct ( int arr [ ] , int n ) { unordered_set < int > s ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . find ( arr [ i ] ) == s . end ( ) ) { s . insert ( arr [ i ] ) ; cout << arr [ i ] << " ▁ " ; } } }
Ref: 
def printDistinct ( arr , n ) : NEW_LINE INDENT s = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] not in s . keys ( ) ) : NEW_LINE INDENT s [ arr [ i ] ] = arr [ i ] NEW_LINE print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
Hyp: 
def printDistinct ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] not in s : NEW_LINE INDENT s . add ( arr [ i ] ) NEW_LINE print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT

BLEU: 71.45
Edit Sim: 32


Src: 
int decToBinary ( int n ) { for ( int i = 31 ; i >= 0 ; i -- ) { int k = n >> i ; if ( k & 1 ) cout << "1" ; else cout << "0" ; } }
Ref: 
def decToBinary ( n ) : NEW_LINE INDENT for i in range ( 31 , - 1 , - 1 ) : NEW_LINE INDENT k = n >> i NEW_LINE if ( k & 1 ) : NEW_LINE INDENT print ( "1" , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "0" , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
Hyp: 
def decToBinary ( n ) : NEW_LINE INDENT for i in range ( 31 ) : NEW_LINE INDENT k = n >> i NEW_LINE if ( k & 1 ) : NEW_LINE INDENT print ( "1" , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "0" , end = " " ) NEW_LINE DEDENT DEDENT DEDENT

BLEU: 88.34
Edit Sim: 12


Src: 
bool SieveOfEratosthenes ( int n , bool isPrime [ ] ) { isPrime [ 0 ] = isPrime [ 1 ] = false ; for ( int i = 2 ; i <= n ; i ++ ) isPrime [ i ] = true ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( isPrime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) isPrime [ i ] = false ; } } }
Ref: 
def SieveOfEratosthenes ( n , isPrime ) : NEW_LINE INDENT isPrime [ 0 ] = isPrime [ 1 ] = False NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT isPrime [ i ] = True NEW_LINE DEDENT for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( p * p <= n and isPrime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT isPrime [ i ] = False NEW_LINE p += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT
Hyp: 
def SieveOfEratosthenes ( n , isPrime ) : NEW_LINE INDENT isPrime [ 0 ] = isPrime [ 1 ] = False NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT isPrime [ i ] = True NEW_LINE DEDENT for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( isPrime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT isPrime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT

BLEU: 88.29
Edit Sim: 31


Src: 
int abFree ( string s ) { int n = s . length ( ) ; char char_array [ n + 1 ] ; strcpy ( char_array , s . c_str ( ) ) ; int b_count = 0 ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( char_array [ n - i - 1 ] == ' a ' ) { res = ( res + b_count ) ; b_count = ( b_count * 2 ) ; } else { b_count += 1 ; } } return res ; }
Ref: 
def abFree ( s ) : NEW_LINE INDENT b_count = 0 NEW_LINE res = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ ~ i ] == ' a ' : NEW_LINE INDENT res = ( res + b_count ) NEW_LINE b_count = ( b_count * 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT b_count += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
Hyp: 
def abFree ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE char_array = list ( s ) NEW_LINE b_count = 0 NEW_LINE res = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( char_array [ n - i - 1 ] == ' a ' ) : NEW_LINE INDENT res = ( res + b_count ) NEW_LINE b_count = ( b_count * 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT b_count += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT

BLEU: 67.7
Edit Sim: 84


Src: 
int countSubstrs ( string str , int i , int j , int n ) { if ( n == 1 ) return 1 ; if ( n <= 0 ) return 0 ; int res = countSubstrs ( str , i + 1 , j , n - 1 ) + countSubstrs ( str , i , j - 1 , n - 1 ) - countSubstrs ( str , i + 1 , j - 1 , n - 2 ) ; if ( str [ i ] == str [ j ] ) res ++ ; return res ; }
Ref: 
def countSubstrs ( str , i , j , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT res = ( countSubstrs ( str , i + 1 , j , n - 1 ) + countSubstrs ( str , i , j - 1 , n - 1 ) - countSubstrs ( str , i + 1 , j - 1 , n - 2 ) ) NEW_LINE if ( str [ i ] == str [ j ] ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT
Hyp: 
def countSubstrs ( str , i , j , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT res = ( countSubstrs ( str , i + 1 , j , n - 1 ) + countSubstrs ( str , i , j - 1 , n - 1 ) - countSubstrs ( str , i + 1 , j - 1 , n - 2 ) ) NEW_LINE if ( str [ i ] == str [ j ] ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT

BLEU: 98.48
Edit Sim: 7


Src: 
int findFirstMissing ( int array [ ] , int start , int end ) { if ( start > end ) return end + 1 ; if ( start != array [ start ] ) return start ; int mid = ( start + end ) / 2 ; if ( array [ mid ] == mid ) return findFirstMissing ( array , mid + 1 , end ) ; return findFirstMissing ( array , start , mid ) ; }
Ref: 
def findFirstMissing ( array , start , end ) : NEW_LINE INDENT if ( start > end ) : NEW_LINE INDENT return end + 1 NEW_LINE DEDENT if ( start != array [ start ] ) : NEW_LINE INDENT return start NEW_LINE DEDENT mid = int ( ( start + end ) / 2 ) NEW_LINE if ( array [ mid ] == mid ) : NEW_LINE INDENT return findFirstMissing ( array , mid + 1 , end ) NEW_LINE DEDENT return findFirstMissing ( array , start , mid ) NEW_LINE DEDENT
Hyp: 
def findFirstMissing ( array , start , end ) : NEW_LINE INDENT if start > end : NEW_LINE INDENT return end + 1 NEW_LINE DEDENT if start != array [ start ] : NEW_LINE INDENT return start NEW_LINE DEDENT mid = int ( ( start + end ) / 2 ) NEW_LINE if array [ mid ] == mid : NEW_LINE INDENT return findFirstMissing ( array , mid + 1 , end ) NEW_LINE DEDENT return findFirstMissing ( array , start , mid ) NEW_LINE DEDENT

BLEU: 83.01
Edit Sim: 12


Src: 
unsigned int factorial ( unsigned int n ) { if ( n == 0 ) return 1 ; return n * factorial ( n - 1 ) ; }
Ref: 
def factorial ( n ) : NEW_LINE INDENT return 1 if ( n == 1 or n == 0 ) else n * factorial ( n - 1 ) NEW_LINE DEDENT
Hyp: 
def factorial ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return n * factorial ( n - 1 ) NEW_LINE DEDENT

BLEU: 69.67
Edit Sim: 50


Src: 
int minRotation ( int input , int unlock_code ) { int rotation = 0 ; int input_digit , code_digit ; while ( input || unlock_code ) { input_digit = input % 10 ; code_digit = unlock_code % 10 ; rotation += min ( abs ( input_digit - code_digit ) , 10 - abs ( input_digit - code_digit ) ) ; input /= 10 ; unlock_code /= 10 ; } return rotation ; }
Ref: 
def minRotation ( input , unlock_code ) : NEW_LINE INDENT rotation = 0 NEW_LINE while ( input > 0 or unlock_code > 0 ) : NEW_LINE INDENT input_digit = input % 10 NEW_LINE code_digit = unlock_code % 10 NEW_LINE rotation += min ( abs ( input_digit - code_digit ) , 10 - abs ( input_digit - code_digit ) ) NEW_LINE input = int ( input / 10 ) NEW_LINE unlock_code = int ( unlock_code / 10 ) NEW_LINE DEDENT return rotation NEW_LINE DEDENT
Hyp: 
def minRotation ( input , unlock_code ) : NEW_LINE INDENT rotation = 0 NEW_LINE while ( input or unlock_code ) : NEW_LINE INDENT input_digit = input % 10 NEW_LINE code_digit = unlock_code % 10 NEW_LINE rotation += min ( abs ( input_digit - code_digit ) , 10 - abs ( input_digit - code_digit ) ) NEW_LINE input //= 10 NEW_LINE unlock_code //= 10 NEW_LINE DEDENT return rotation NEW_LINE DEDENT

BLEU: 70.6
Edit Sim: 48


Src: 
void findFibSubset ( int arr [ ] , int n ) { int max = * std :: max_element ( arr , arr + n ) ; int a = 0 , b = 1 ; unordered_set < int > hash ; hash . insert ( a ) ; hash . insert ( b ) ; while ( b < max ) { int c = a + b ; a = b ; b = c ; hash . insert ( b ) ; } for ( int i = 0 ; i < n ; i ++ ) if ( hash . find ( arr [ i ] ) != hash . end ( ) ) printf ( " % d ▁ " , arr [ i ] ) ; }
Ref: 
def findFibSubset ( arr , n ) : NEW_LINE INDENT m = max ( arr ) NEW_LINE a = 0 NEW_LINE b = 1 NEW_LINE hash = [ ] NEW_LINE hash . append ( a ) NEW_LINE hash . append ( b ) NEW_LINE while ( b < m ) : NEW_LINE INDENT c = a + b NEW_LINE a = b NEW_LINE b = c NEW_LINE hash . append ( b ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if arr [ i ] in hash : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
Hyp: 
def findFibSubset ( arr , n ) : NEW_LINE INDENT max1 = max ( arr ) NEW_LINE a = 0 NEW_LINE b = 1 NEW_LINE hash = set ( ) NEW_LINE hash . add ( a ) NEW_LINE hash . add ( b ) NEW_LINE while ( b < max1 ) : NEW_LINE INDENT c = a + b NEW_LINE a = b NEW_LINE b = c NEW_LINE hash . add ( b ) NEW_LINE DEDENT while ( b < max1 ) : NEW_LINE INDENT c = a + b NEW_LINE a = b NEW_LINE b = c NEW_LINE hash . add ( b ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if arr [ i ] not in hash : NEW_LINE INDENT hash . add ( arr [ i ] ) NEW_LINE DEDENT DEDENT DEDENT

BLEU: 59.4
Edit Sim: 166


Src: 
bool checkMarkov ( double m [ ] [ n ] ) { for ( int i = 0 ; i < n ; i ++ ) { double sum = 0 ; for ( int j = 0 ; j < n ; j ++ ) sum = sum + m [ i ] [ j ] ; if ( sum != 1 ) return false ; } return true ; }
Ref: 
def checkMarkov ( m ) : NEW_LINE INDENT for i in range ( 0 , len ( m ) ) : NEW_LINE INDENT sm = 0 NEW_LINE for j in range ( 0 , len ( m [ i ] ) ) : NEW_LINE INDENT sm = sm + m [ i ] [ j ] NEW_LINE DEDENT if ( sm != 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
Hyp: 
def checkMarkov ( mat ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT sum = sum + mat [ i ] [ j ] NEW_LINE DEDENT if ( sum != 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT

BLEU: 56.21
Edit Sim: 38


Src: 
int insertSorted ( int arr [ ] , int n , int key , int capacity ) { if ( n >= capacity ) return n ; int i ; for ( i = n - 1 ; ( i >= 0 && arr [ i ] > key ) ; i -- ) arr [ i + 1 ] = arr [ i ] ; arr [ i + 1 ] = key ; return ( n + 1 ) ; }
Ref: 
def insertSorted ( arr , n , key , capacity ) : NEW_LINE INDENT if ( n >= capacity ) : NEW_LINE INDENT return n NEW_LINE DEDENT i = n - 1 NEW_LINE while i >= 0 and arr [ i ] > key : NEW_LINE INDENT arr [ i + 1 ] = arr [ i ] NEW_LINE i -= 1 NEW_LINE DEDENT arr [ i + 1 ] = key NEW_LINE return ( n + 1 ) NEW_LINE DEDENT
Hyp: 
def insertSorted ( arr , n , key , capacity ) : NEW_LINE INDENT if n >= capacity : NEW_LINE INDENT return n NEW_LINE DEDENT i = n - 1 NEW_LINE while ( i >= 0 and arr [ i ] > key ) : NEW_LINE INDENT arr [ i + 1 ] = arr [ i ] NEW_LINE i -= 1 NEW_LINE DEDENT arr [ i + 1 ] = key NEW_LINE return ( n + 1 ) NEW_LINE DEDENT

BLEU: 91.33
Edit Sim: 8


Src: 
void recursiveReverse ( string & str , int i = 0 ) { int n = str . length ( ) ; if ( i == n / 2 ) return ; swap ( str [ i ] , str [ n - i - 1 ] ) ; recursiveReverse ( str , i + 1 ) ; }
Ref: 
def recursiveReverse ( str , i = 0 ) : NEW_LINE INDENT n = len ( str ) NEW_LINE if i == n // 2 : NEW_LINE INDENT return NEW_LINE DEDENT str [ i ] , str [ n - i - 1 ] = str [ n - i - 1 ] , str [ i ] NEW_LINE recursiveReverse ( str , i + 1 ) NEW_LINE DEDENT
Hyp: 
def recursiveReverse ( str , i ) : NEW_LINE INDENT n = len ( str ) NEW_LINE if i == n // 2 : NEW_LINE INDENT return NEW_LINE DEDENT str [ i ] , str [ n - i - 1 ] = str [ n - i - 1 ] , str [ i ] NEW_LINE recursiveReverse ( str , i + 1 ) NEW_LINE DEDENT

BLEU: 94.83
Edit Sim: 4


Src: 
bool areConsecutive ( int arr [ ] , int n ) { if ( n < 1 ) return false ; int min = getMin ( arr , n ) ; int max = getMax ( arr , n ) ; if ( max - min + 1 == n ) { bool * visited = ( bool * ) calloc ( n , sizeof ( bool ) ) ; int i ; for ( i = 0 ; i < n ; i ++ ) { if ( visited [ arr [ i ] - min ] != false ) return false ; visited [ arr [ i ] - min ] = true ; } return true ; } return false ; }
Ref: 
def areConsecutive ( arr , n ) : NEW_LINE INDENT if ( n < 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT Min = min ( arr ) NEW_LINE Max = max ( arr ) NEW_LINE if ( Max - Min + 1 == n ) : NEW_LINE INDENT visited = [ False for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( visited [ arr [ i ] - Min ] != False ) : NEW_LINE INDENT return False NEW_LINE DEDENT visited [ arr [ i ] - Min ] = True NEW_LINE DEDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
Hyp: 
def areConsecutive ( arr , n ) : NEW_LINE INDENT if ( n < 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT min = getMin ( arr , n ) NEW_LINE max = getMax ( arr , n ) NEW_LINE if ( max - min + 1 == n ) : NEW_LINE INDENT visited = [ False ] * n NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( visited [ arr [ i ] - min ] != False ) : NEW_LINE INDENT return False NEW_LINE DEDENT visited [ arr [ i ] - min ] = True NEW_LINE DEDENT return True NEW_LINE DEDENT

BLEU: 69.65
Edit Sim: 74


Src: 
double findMod ( double a , double b ) { double mod ; if ( a < 0 ) mod = - a ; else mod = a ; if ( b < 0 ) b = - b ; while ( mod >= b ) mod = mod - b ; if ( a < 0 ) return - mod ; return mod ; }
Ref: 
def findMod ( a , b ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT a = - a NEW_LINE DEDENT if ( b < 0 ) : NEW_LINE INDENT b = - b NEW_LINE DEDENT mod = a NEW_LINE while ( mod >= b ) : NEW_LINE INDENT mod = mod - b NEW_LINE DEDENT if ( a < 0 ) : NEW_LINE INDENT return - mod NEW_LINE DEDENT return mod NEW_LINE DEDENT
Hyp: 
def findMod ( a , b ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT mod = - a NEW_LINE DEDENT else : NEW_LINE INDENT mod = a NEW_LINE DEDENT if ( b < 0 ) : NEW_LINE INDENT b = - b NEW_LINE DEDENT while ( mod >= b ) : NEW_LINE INDENT mod = mod - b NEW_LINE DEDENT if ( a < 0 ) : NEW_LINE INDENT return - mod NEW_LINE DEDENT return mod NEW_LINE DEDENT

BLEU: 87.11
Edit Sim: 53


Src: 
int sumOfSubstrings ( string num ) { int n = num . length ( ) ; int sumofdigit [ n ] ; sumofdigit [ 0 ] = toDigit ( num [ 0 ] ) ; int res = sumofdigit [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { int numi = toDigit ( num [ i ] ) ; sumofdigit [ i ] = ( i + 1 ) * numi + 10 * sumofdigit [ i - 1 ] ; res += sumofdigit [ i ] ; } return res ; }
Ref: 
def sumOfSubstrings ( num ) : NEW_LINE INDENT n = len ( num ) NEW_LINE sumofdigit = [ ] NEW_LINE sumofdigit . append ( int ( num [ 0 ] ) ) NEW_LINE res = sumofdigit [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT numi = int ( num [ i ] ) NEW_LINE sumofdigit . append ( ( i + 1 ) * numi + 10 * sumofdigit [ i - 1 ] ) NEW_LINE res += sumofdigit [ i ] NEW_LINE DEDENT return res NEW_LINE DEDENT
Hyp: 
def sumOfSubstrings ( num ) : NEW_LINE INDENT n = len ( num ) NEW_LINE sumofdigit = [ 0 for i in range ( n ) ] NEW_LINE sumofdigit [ 0 ] = int ( num [ 0 ] ) NEW_LINE res = sumofdigit [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT numi = int ( num [ i ] ) NEW_LINE sumofdigit [ i ] = ( i + 1 ) * numi + 10 * sumofdigit [ i - 1 ] NEW_LINE res += sumofdigit [ i ] NEW_LINE DEDENT return res NEW_LINE DEDENT

BLEU: 78.73
Edit Sim: 43


Src: 
int findGreatest ( int arr [ ] , int n ) { unordered_map < int , int > m ; for ( int i = 0 ; i < n ; i ++ ) m [ arr [ i ] ] ++ ; sort ( arr , arr + n ) ; for ( int i = n - 1 ; i > 1 ; i -- ) { for ( int j = 0 ; j < i && arr [ j ] <= sqrt ( arr [ i ] ) ; j ++ ) { if ( arr [ i ] % arr [ j ] == 0 ) { int result = arr [ i ] / arr [ j ] ; if ( result != arr [ j ] && m [ result ] > 0 ) return arr [ i ] ; else if ( result == arr [ j ] && m [ result ] > 1 ) return arr [ i ] ; } } } return - 1 ; }
Ref: 
def findGreatest ( arr , n ) : NEW_LINE INDENT m = dict ( ) NEW_LINE for i in arr : NEW_LINE INDENT m [ i ] = m . get ( i , 0 ) + 1 NEW_LINE DEDENT arr = sorted ( arr ) NEW_LINE for i in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT j = 0 NEW_LINE while ( j < i and arr [ j ] <= sqrt ( arr [ i ] ) ) : NEW_LINE INDENT if ( arr [ i ] % arr [ j ] == 0 ) : NEW_LINE INDENT result = arr [ i ] // arr [ j ] NEW_LINE if ( result != arr [ j ] and ( result in m . keys ( ) ) and m [ result ] > 0 ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT elif ( result == arr [ j ] and ( result in m . keys ( ) ) and m [ result ] > 1 ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT j += 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
Hyp: 
def findGreatest ( arr , n ) : NEW_LINE INDENT mp = defaultdict ( lambda : 0 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT arr . sort ( ) NEW_LINE for i in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT for j in range ( 0 , i , 1 ) : NEW_LINE INDENT if ( arr [ i ] % arr [ j ] == 0 ) : NEW_LINE INDENT result = arr [ i ] // arr [ j ] NEW_LINE if ( result != arr [ j ] and m [ result ] > 0 ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT elif ( result == arr [ j ] and m [ result ] > 1 ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT DEDENT DEDENT return - 1 NEW_LINE DEDENT

BLEU: 63.24
Edit Sim: 183


Src: 
int getMissingNo ( int a [ ] , int n ) { int i , total = 1 ; for ( i = 2 ; i <= ( n + 1 ) ; i ++ ) { total += i ; total -= a [ i - 2 ] ; } return total ; }
Ref: 
def getMissingNo ( a , n ) : NEW_LINE INDENT i , total = 0 , 1 NEW_LINE for i in range ( 2 , n + 2 ) : NEW_LINE INDENT total += i NEW_LINE total -= a [ i - 2 ] NEW_LINE DEDENT return total NEW_LINE DEDENT
Hyp: 
def getMissingNo ( a , n ) : NEW_LINE INDENT total = 1 NEW_LINE for i in range ( 2 , ( n + 1 ) ) : NEW_LINE INDENT total += i NEW_LINE total -= a [ i - 2 ] NEW_LINE DEDENT return total NEW_LINE DEDENT

BLEU: 78.15
Edit Sim: 13


Src: 
unsigned int nextPowerOf2 ( unsigned int n ) { n -- ; n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; n ++ ; return n ; }
Ref: 
def nextPowerOf2 ( n ) : NEW_LINE INDENT n -= 1 NEW_LINE n |= n >> 1 NEW_LINE n |= n >> 2 NEW_LINE n |= n >> 4 NEW_LINE n |= n >> 8 NEW_LINE n |= n >> 16 NEW_LINE n += 1 NEW_LINE return n NEW_LINE DEDENT
Hyp: 
def nextPowerOf2 ( n ) : NEW_LINE INDENT n -= 1 NEW_LINE n |= n >> 1 NEW_LINE n |= n >> 2 NEW_LINE n |= n >> 4 NEW_LINE n |= n >> 8 NEW_LINE n |= n >> 16 NEW_LINE n += 1 NEW_LINE return n NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
void add ( int A [ ] [ N ] , int B [ ] [ N ] , int C [ ] [ N ] ) { int i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < N ; j ++ ) C [ i ] [ j ] = A [ i ] [ j ] + B [ i ] [ j ] ; }
Ref: 
def add ( A , B , C ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT C [ i ] [ j ] = A [ i ] [ j ] + B [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT
Hyp: 
def add ( A , B , C ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT C [ i ] [ j ] = A [ i ] [ j ] + B [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int zigzag ( int n , int k ) { int dp [ n + 1 ] [ k + 1 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; dp [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ i - j ] ; return dp [ n ] [ k ] ; } int main ( ) { int n = 4 , k = 3 ; cout << zigzag ( n , k ) << endl ; return 0 ; }
Ref: 
def zigzag ( n , k ) : NEW_LINE INDENT dp = [ [ 0 for x in range ( k + 1 ) ] for y in range ( n + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = 0 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , k + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ i - j ] ) NEW_LINE DEDENT DEDENT return dp [ n ] [ k ] NEW_LINE DEDENT
Hyp: 
def zigzag ( n , k ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( k + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = 0 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ i - j ] NEW_LINE DEDENT DEDENT return dp [ n ] [ k ] NEW_LINE DEDENT

BLEU: 91.1
Edit Sim: 7


Src: 
int eggDrop ( int n , int k ) { int eggFloor [ n + 1 ] [ k + 1 ] ; int res ; int i , j , x ; for ( i = 1 ; i <= n ; i ++ ) { eggFloor [ i ] [ 1 ] = 1 ; eggFloor [ i ] [ 0 ] = 0 ; } for ( j = 1 ; j <= k ; j ++ ) eggFloor [ 1 ] [ j ] = j ; for ( i = 2 ; i <= n ; i ++ ) { for ( j = 2 ; j <= k ; j ++ ) { eggFloor [ i ] [ j ] = INT_MAX ; for ( x = 1 ; x <= j ; x ++ ) { res = 1 + max ( eggFloor [ i - 1 ] [ x - 1 ] , eggFloor [ i ] [ j - x ] ) ; if ( res < eggFloor [ i ] [ j ] ) eggFloor [ i ] [ j ] = res ; } } } return eggFloor [ n ] [ k ] ; }
Ref: 
def eggDrop ( n , k ) : NEW_LINE INDENT eggFloor = [ [ 0 for x in range ( k + 1 ) ] for x in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT eggFloor [ i ] [ 1 ] = 1 NEW_LINE eggFloor [ i ] [ 0 ] = 0 NEW_LINE DEDENT for j in range ( 1 , k + 1 ) : NEW_LINE INDENT eggFloor [ 1 ] [ j ] = j NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT for j in range ( 2 , k + 1 ) : NEW_LINE INDENT eggFloor [ i ] [ j ] = INT_MAX NEW_LINE for x in range ( 1 , j + 1 ) : NEW_LINE INDENT res = 1 + max ( eggFloor [ i - 1 ] [ x - 1 ] , eggFloor [ i ] [ j - x ] ) NEW_LINE if res < eggFloor [ i ] [ j ] : NEW_LINE INDENT eggFloor [ i ] [ j ] = res NEW_LINE DEDENT DEDENT DEDENT DEDENT return eggFloor [ n ] [ k ] NEW_LINE DEDENT
Hyp: 
def eggDrop ( n , k ) : NEW_LINE INDENT eggFloor = [ [ 0 for x in range ( k + 1 ) ] for y in range ( n + 1 ) ] NEW_LINE res = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT eggFloor [ i ] [ 1 ] = 1 NEW_LINE eggFloor [ i ] [ 0 ] = 0 NEW_LINE DEDENT for j in range ( 1 , k + 1 ) : NEW_LINE INDENT eggFloor [ 1 ] [ j ] = j NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT for j in range ( 2 , k + 1 ) : NEW_LINE INDENT eggFloor [ i ] [ j ] = sys . maxint NEW_LINE for x in range ( 1 , j + 1 ) : NEW_LINE INDENT res = 1 + max ( eggFloor [ i - 1 ] [ x - 1 ] , eggFloor [ i ] [ j - x ] ) NEW_LINE if res < eggFloor [ i ] [ j ] : NEW_LINE INDENT eggFloor [ i ] [ j ] = res NEW_LINE DEDENT DEDENT DEDENT DEDENT return eggFloor [ n ] [ k ] NEW_LINE DEDENT

BLEU: 94.63
Edit Sim: 30


Src: 
string noAdjacentDup ( string s ) { int n = s . length ( ) ; for ( int i = 1 ; i < n ; i ++ ) { if ( s [ i ] == s [ i - 1 ] ) { s [ i ] = ' a ' ; while ( s [ i ] == s [ i - 1 ] || ( i + 1 < n && s [ i ] == s [ i + 1 ] ) ) s [ i ] ++ ; i ++ ; } } return s ; }
Ref: 
def noAdjacentDup ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( s [ i ] == s [ i - 1 ] ) : NEW_LINE INDENT s [ i ] = " a " NEW_LINE while ( s [ i ] == s [ i - 1 ] or ( i + 1 < n and s [ i ] == s [ i + 1 ] ) ) : NEW_LINE INDENT s [ i ] += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT return s NEW_LINE DEDENT
Hyp: 
def noAdjacentDup ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( s [ i ] == s [ i - 1 ] ) : NEW_LINE INDENT s [ i ] = ' a ' NEW_LINE while ( s [ i ] == s [ i - 1 ] or ( i + 1 < n and s [ i ] == s [ i + 1 ] ) ) : NEW_LINE INDENT s [ i ] = ' ' NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT return s NEW_LINE DEDENT

BLEU: 91.88
Edit Sim: 6


Src: 
int maximumDifferenceSum ( int arr [ ] , int N ) { int dp [ N ] [ 2 ] ; for ( int i = 0 ; i < N ; i ++ ) dp [ i ] [ 0 ] = dp [ i ] [ 1 ] = 0 ; for ( int i = 0 ; i < ( N - 1 ) ; i ++ ) { dp [ i + 1 ] [ 0 ] = max ( dp [ i ] [ 0 ] , dp [ i ] [ 1 ] + abs ( 1 - arr [ i ] ) ) ; dp [ i + 1 ] [ 1 ] = max ( dp [ i ] [ 0 ] + abs ( arr [ i + 1 ] - 1 ) , dp [ i ] [ 1 ] + abs ( arr [ i + 1 ] - arr [ i ] ) ) ; } return max ( dp [ N - 1 ] [ 0 ] , dp [ N - 1 ] [ 1 ] ) ; }
Ref: 
def maximumDifferenceSum ( arr , N ) : NEW_LINE INDENT dp = [ [ 0 , 0 ] for i in range ( N ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i ] [ 1 ] = 0 NEW_LINE DEDENT for i in range ( N - 1 ) : NEW_LINE INDENT dp [ i + 1 ] [ 0 ] = max ( dp [ i ] [ 0 ] , dp [ i ] [ 1 ] + abs ( 1 - arr [ i ] ) ) NEW_LINE dp [ i + 1 ] [ 1 ] = max ( dp [ i ] [ 0 ] + abs ( arr [ i + 1 ] - 1 ) , dp [ i ] [ 1 ] + abs ( arr [ i + 1 ] - arr [ i ] ) ) NEW_LINE DEDENT return max ( dp [ N - 1 ] [ 0 ] , dp [ N - 1 ] [ 1 ] ) NEW_LINE DEDENT
Hyp: 
def maximumDifferenceSum ( arr , N ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( N ) ] for j in range ( 2 ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i ] [ 1 ] = 0 NEW_LINE DEDENT for i in range ( ( N - 1 ) ) : NEW_LINE INDENT dp [ i + 1 ] [ 0 ] = max ( dp [ i ] [ 0 ] , dp [ i ] [ 1 ] + abs ( 1 - arr [ i ] ) ) NEW_LINE dp [ i + 1 ] [ 1 ] = max ( dp [ i + 1 ] [ 1 ] , max ( dp [ i ] [ 0 ] + abs ( arr [ i + 1 ] - 1 ) , dp [ i ] [ 1 ] + abs ( arr [ i + 1 ] - arr [ i ] ) ) NEW_LINE DEDENT DEDENT return max ( dp [ N - 1 ] [ 0 ] , dp [ N - 1 ] [ 1 ] ) NEW_LINE DEDENT

BLEU: 87.37
Edit Sim: 59


Src: 
int minInsertionStepToSortArray ( int arr [ ] , int N ) { int lis [ N ] ; for ( int i = 0 ; i < N ; i ++ ) lis [ i ] = 1 ; for ( int i = 1 ; i < N ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( arr [ i ] >= arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; int max = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( max < lis [ i ] ) max = lis [ i ] ; return ( N - max ) ; }
Ref: 
def minInsertionStepToSortArray ( arr , N ) : NEW_LINE INDENT lis = [ 0 ] * N NEW_LINE for i in range ( N ) : NEW_LINE INDENT lis [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , N ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ i ] >= arr [ j ] and lis [ i ] < lis [ j ] + 1 ) : NEW_LINE INDENT lis [ i ] = lis [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT max = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( max < lis [ i ] ) : NEW_LINE INDENT max = lis [ i ] NEW_LINE DEDENT DEDENT return ( N - max ) NEW_LINE DEDENT
Hyp: 
def minInsertionStepToSortArray ( arr , N ) : NEW_LINE INDENT lis = [ 0 ] * N NEW_LINE for i in range ( N ) : NEW_LINE INDENT lis [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , N ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ i ] >= arr [ j ] and lis [ i ] < lis [ j ] + 1 ) : NEW_LINE INDENT lis [ i ] = lis [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT max = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( max < lis [ i ] ) : NEW_LINE INDENT max = lis [ i ] NEW_LINE DEDENT DEDENT return ( N - max ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
bool isMultipleOf10 ( int n ) { return ( n % 15 == 0 ) ; }
Ref: 
def isMultipleOf10 ( n ) : NEW_LINE INDENT return ( n % 15 == 0 ) NEW_LINE DEDENT
Hyp: 
def isMultipleOf10 ( n ) : NEW_LINE INDENT return ( n % 15 == 0 ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int exactPrimeFactorCount ( int n ) { int count = 0 ; if ( n % 2 == 0 ) { count ++ ; while ( n % 2 == 0 ) n = n / 2 ; } for ( int i = 3 ; i <= sqrt ( n ) ; i = i + 2 ) { if ( n % i == 0 ) { count ++ ; while ( n % i == 0 ) n = n / i ; } } if ( n > 2 ) count ++ ; return count ; }
Ref: 
def exactPrimeFactorCount ( n ) : NEW_LINE INDENT count = 0 NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT count = count + 1 NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT n = int ( n / 2 ) NEW_LINE DEDENT DEDENT i = 3 NEW_LINE while ( i <= int ( math . sqrt ( n ) ) ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT count = count + 1 NEW_LINE while ( n % i == 0 ) : NEW_LINE INDENT n = int ( n / i ) NEW_LINE DEDENT DEDENT i = i + 2 NEW_LINE DEDENT if ( n > 2 ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
Hyp: 
def exactPrimeFactorCount ( n ) : NEW_LINE INDENT count = 0 NEW_LINE if n % 2 == 0 : NEW_LINE INDENT count += 1 NEW_LINE while n % 2 == 0 : NEW_LINE INDENT n = n / 2 NEW_LINE DEDENT DEDENT for i in range ( 3 , int ( m . sqrt ( n ) + 2 ) ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT count += 1 NEW_LINE while n % i == 0 : NEW_LINE INDENT n = n / i NEW_LINE DEDENT DEDENT DEDENT if n > 2 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT

BLEU: 45.09
Edit Sim: 108


Src: 
void query ( char s [ ] , int i , int j ) { int n = strlen ( s ) ; i %= n ; j %= n ; ( s [ i ] == s [ j ] ) ? ( cout << " Yes " << endl ) : ( cout << " No " << endl ) ; }
Ref: 
def query ( s , i , j ) : NEW_LINE INDENT n = len ( s ) NEW_LINE i %= n NEW_LINE j %= n NEW_LINE print ( " Yes " ) if s [ i ] == s [ j ] else print ( " No " ) NEW_LINE DEDENT
Hyp: 
def query ( s , i , j ) : NEW_LINE INDENT n = len ( s ) NEW_LINE i %= n NEW_LINE j %= n NEW_LINE if ( s [ i ] == s [ j ] ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT

BLEU: 72.35
Edit Sim: 83


Src: 
int maxProduct ( int arr [ ] , int n ) { if ( n < 3 ) return - 1 ; sort ( arr , arr + n ) ; return max ( arr [ 0 ] * arr [ 1 ] * arr [ n - 1 ] , arr [ n - 1 ] * arr [ n - 2 ] * arr [ n - 3 ] ) ; }
Ref: 
def maxProduct ( arr , n ) : NEW_LINE INDENT if n < 3 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT arr . sort ( ) NEW_LINE return max ( arr [ 0 ] * arr [ 1 ] * arr [ n - 1 ] , arr [ n - 1 ] * arr [ n - 2 ] * arr [ n - 3 ] ) NEW_LINE DEDENT
Hyp: 
def maxProduct ( arr , n ) : NEW_LINE INDENT if ( n < 3 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT arr . sort ( ) NEW_LINE return max ( arr [ 0 ] * arr [ 1 ] * arr [ n - 1 ] , arr [ n - 1 ] * arr [ n - 2 ] * arr [ n - 3 ] ) NEW_LINE DEDENT

BLEU: 93.0
Edit Sim: 4


Src: 
void findMinAvgSubarray ( int arr [ ] , int n , int k ) { if ( n < k ) return ; int res_index = 0 ; int curr_sum = 0 ; for ( int i = 0 ; i < k ; i ++ ) curr_sum += arr [ i ] ; int min_sum = curr_sum ; for ( int i = k ; i < n ; i ++ ) { curr_sum += arr [ i ] - arr [ i - k ] ; if ( curr_sum < min_sum ) { min_sum = curr_sum ; res_index = ( i - k + 1 ) ; } } cout << " Subarray ▁ between ▁ [ " << res_index << " , ▁ " << res_index + k - 1 << " ] ▁ has ▁ minimum ▁ average " ; }
Ref: 
def findMinAvgSubarray ( arr , n , k ) : NEW_LINE INDENT if ( n < k ) : return 0 NEW_LINE res_index = 0 NEW_LINE curr_sum = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT curr_sum += arr [ i ] NEW_LINE DEDENT min_sum = curr_sum NEW_LINE for i in range ( k , n ) : NEW_LINE INDENT curr_sum += arr [ i ] - arr [ i - k ] NEW_LINE if ( curr_sum < min_sum ) : NEW_LINE INDENT min_sum = curr_sum NEW_LINE res_index = ( i - k + 1 ) NEW_LINE DEDENT DEDENT print ( " Subarray ▁ between ▁ [ " , res_index , " , ▁ " , ( res_index + k - 1 ) , " ] ▁ has ▁ minimum ▁ average " ) NEW_LINE DEDENT
Hyp: 
def findMinAvgSubarray ( arr , n , k ) : NEW_LINE INDENT if ( n < k ) : NEW_LINE INDENT return NEW_LINE DEDENT res_index = 0 NEW_LINE curr_sum = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT curr_sum += arr [ i ] NEW_LINE DEDENT min_sum = curr_sum NEW_LINE for i in range ( k , n ) : NEW_LINE INDENT curr_sum += arr [ i ] - arr [ i - k ] NEW_LINE if ( curr_sum < min_sum ) : NEW_LINE INDENT min_sum = curr_sum NEW_LINE res_index = ( i - k + 1 ) NEW_LINE DEDENT DEDENT print ( " Subarray ▁ between ▁ [ " , res_index , " , ▁ " , res_index + k - 1 , " ] ▁ has ▁ minimum ▁ average " ) NEW_LINE DEDENT

BLEU: 93.48
Edit Sim: 29


Src: 
int countwalks ( int graph [ ] [ V ] , int u , int v , int k ) { if ( k == 0 && u == v ) return 1 ; if ( k == 1 && graph [ u ] [ v ] ) return 1 ; if ( k <= 0 ) return 0 ; int count = 0 ; for ( int i = 0 ; i < V ; i ++ ) if ( graph [ u ] [ i ] == 1 ) count += countwalks ( graph , i , v , k - 1 ) ; return count ; }
Ref: 
def countwalks ( graph , u , v , k ) : NEW_LINE INDENT if ( k == 0 and u == v ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( k == 1 and graph [ u ] [ v ] ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( k <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( 0 , V ) : NEW_LINE INDENT if ( graph [ u ] [ i ] == 1 ) : NEW_LINE INDENT count += countwalks ( graph , i , v , k - 1 ) NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
Hyp: 
def countwalks ( graph , u , v , k ) : NEW_LINE INDENT if ( k == 0 and u == v ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( k == 1 and graph [ u ] [ v ] ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( k <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( V ) : NEW_LINE INDENT if ( graph [ u ] [ i ] == 1 ) : NEW_LINE INDENT count += countwalks ( graph , i , v , k - 1 ) NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT

BLEU: 96.97
Edit Sim: 4


Src: 
int countPairs ( int arr [ ] , int n ) { int result = 0 ; set < int > Hash ; for ( int i = 0 ; i < n ; i ++ ) Hash . insert ( arr [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int product = arr [ i ] * arr [ j ] ; if ( Hash . find ( product ) != Hash . end ( ) ) result ++ ; } } return result ; }
Ref: 
def countPairs ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE Hash = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT Hash . add ( arr [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT product = arr [ i ] * arr [ j ] NEW_LINE if product in ( Hash ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
Hyp: 
def countPairs ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE Hash = set ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT Hash . add ( arr [ i ] ) NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT product = arr [ i ] * arr [ j ] NEW_LINE if ( Hash . get ( product ) ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT

BLEU: 85.83
Edit Sim: 28


Src: 
void print_sequence ( int n , int k ) { int b = n / ( k * ( k + 1 ) / 2 ) ; if ( b == 0 ) { cout << - 1 << endl ; } else { int r = 1 ; for ( int x = 1 ; x * x <= n ; x ++ ) { if ( n % x != 0 ) continue ; if ( x <= b && x > r ) r = x ; if ( n / x <= b && n / x > r ) r = n / x ; } for ( int i = 1 ; i < k ; i ++ ) cout << r * i << " ▁ " ; int res = n - ( r * ( k * ( k - 1 ) / 2 ) ) ; cout << res << endl ; } }
Ref: 
def print_sequence ( n , k ) : NEW_LINE INDENT b = int ( n / ( k * ( k + 1 ) / 2 ) ) NEW_LINE if b == 0 : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT else : NEW_LINE INDENT r = 1 NEW_LINE x = 1 NEW_LINE while x ** 2 <= n : NEW_LINE INDENT if n % x != 0 : NEW_LINE INDENT continue NEW_LINE DEDENT elif x <= b and x > r : NEW_LINE INDENT r = x NEW_LINE DEDENT elif n / x <= b and n / x > r : NEW_LINE INDENT r = n / x NEW_LINE DEDENT x = x + 1 NEW_LINE DEDENT i = 1 NEW_LINE while i < k : NEW_LINE INDENT print ( r * i , end = " ▁ " ) NEW_LINE i = i + 1 NEW_LINE DEDENT last_term = n - ( r * ( k * ( k - 1 ) / 2 ) ) NEW_LINE print ( last_term ) NEW_LINE DEDENT DEDENT
Hyp: 
def print_sequence ( n , k ) : NEW_LINE INDENT b = n // ( k * ( k + 1 ) / 2 ) NEW_LINE if ( b == 0 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT r = 1 NEW_LINE for x in range ( 1 , int ( n / x ) + 1 ) : NEW_LINE INDENT if ( n % x != 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( x <= b and x > r ) : NEW_LINE INDENT r = x NEW_LINE DEDENT if ( n / x <= b and n / x > r ) : NEW_LINE INDENT r = n / x NEW_LINE DEDENT DEDENT for i in range ( 1 , k ) : NEW_LINE INDENT print ( r * i , end = " ▁ " ) NEW_LINE DEDENT res = n - ( r * ( k * ( k - 1 ) // 2 ) ) NEW_LINE print ( res ) NEW_LINE DEDENT DEDENT

BLEU: 64.15
Edit Sim: 136


Src: 
unsigned int nextPowerOf2 ( unsigned int n ) { n -- ; n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; n ++ ; return n ; }
Ref: 
def nextPowerOf2 ( n ) : NEW_LINE INDENT n -= 1 NEW_LINE n |= n >> 1 NEW_LINE n |= n >> 2 NEW_LINE n |= n >> 4 NEW_LINE n |= n >> 8 NEW_LINE n |= n >> 16 NEW_LINE n += 1 NEW_LINE return n NEW_LINE DEDENT
Hyp: 
def nextPowerOf2 ( n ) : NEW_LINE INDENT n -= 1 NEW_LINE n |= n >> 1 NEW_LINE n |= n >> 2 NEW_LINE n |= n >> 4 NEW_LINE n |= n >> 8 NEW_LINE n |= n >> 16 NEW_LINE n += 1 NEW_LINE return n NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
- 100000000 int findMaxValue ( int arr [ ] , int n ) { if ( n < 4 ) { printf ( " The ▁ array ▁ should ▁ have ▁ atlest ▁ 4 ▁ elements \n " ) ; return MIN ; } int table1 [ n + 1 ] , table2 [ n ] , table3 [ n - 1 ] , table4 [ n - 2 ] ; for ( int i = 0 ; i <= n ; i ++ ) table1 [ i ] = table2 [ i ] = table3 [ i ] = table4 [ i ] = MIN ; for ( int i = n - 1 ; i >= 0 ; i -- ) table1 [ i ] = max ( table1 [ i + 1 ] , arr [ i ] ) ; for ( int i = n - 2 ; i >= 0 ; i -- ) table2 [ i ] = max ( table2 [ i + 1 ] , table1 [ i + 1 ] - arr [ i ] ) ; for ( int i = n - 3 ; i >= 0 ; i -- ) table3 [ i ] = max ( table3 [ i + 1 ] , table2 [ i + 1 ] + arr [ i ] ) ; for ( int i = n - 4 ; i >= 0 ; i -- ) table4 [ i ] = max ( table4 [ i + 1 ] , table3 [ i + 1 ] - arr [ i ] ) ; return table4 [ 0 ] ; }
Ref: 
def findMaxValue ( arr , n ) : NEW_LINE INDENT if n < 4 : NEW_LINE INDENT print ( " The ▁ array ▁ should ▁ have ▁ atlest ▁ 4 ▁ elements " ) NEW_LINE return MIN NEW_LINE DEDENT table1 , table2 = [ MIN ] * ( n + 1 ) , [ MIN ] * n NEW_LINE table3 , table4 = [ MIN ] * ( n - 1 ) , [ MIN ] * ( n - 2 ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT table1 [ i ] = max ( table1 [ i + 1 ] , arr [ i ] ) NEW_LINE DEDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT table2 [ i ] = max ( table2 [ i + 1 ] , table1 [ i + 1 ] - arr [ i ] ) NEW_LINE DEDENT for i in range ( n - 3 , - 1 , - 1 ) : NEW_LINE INDENT table3 [ i ] = max ( table3 [ i + 1 ] , table2 [ i + 1 ] + arr [ i ] ) NEW_LINE DEDENT for i in range ( n - 4 , - 1 , - 1 ) : NEW_LINE INDENT table4 [ i ] = max ( table4 [ i + 1 ] , table3 [ i + 1 ] - arr [ i ] ) NEW_LINE DEDENT return table4 [ 0 ] NEW_LINE DEDENT
Hyp: 
def findMaxValue ( arr , n ) : NEW_LINE INDENT if ( n < 4 ) : NEW_LINE INDENT print ( " The ▁ array ▁ should ▁ have ▁ atlest ▁ 4 ▁ elements " ) NEW_LINE return MIN NEW_LINE DEDENT table1 = [ 0 ] * ( n + 1 ) NEW_LINE table2 = [ 0 ] * ( n + 1 ) NEW_LINE table3 = [ 0 ] * ( n - 1 ) NEW_LINE table4 = [ MIN ] * ( n - 2 ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT table1 [ i ] = max ( table1 [ i + 1 ] , arr [ i ] ) NEW_LINE DEDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT table2 [ i ] = max ( table2 [ i + 1 ] , table1 [ i + 1 ] - arr [ i ] ) NEW_LINE DEDENT for i in range ( n - 3 , - 1 , - 1 ) : NEW_LINE INDENT table3 [ i ] = max ( table3 [ i + 1 ] , table2 [ i + 1 ] + arr [ i ] ) NEW_LINE DEDENT for i in range ( n - 4 , - 1 , - 1 ) : NEW_LINE INDENT table4 [ i ] = max ( table4 [ i + 1 ] , table3 [ i + 1 ] - arr [ i ] ) NEW_LINE DEDENT return table4 [ 0 ] NEW_LINE DEDENT

BLEU: 90.14
Edit Sim: 72


Src: 
void printInSortedOrder ( string arr [ ] , int n ) { int index [ n ] ; int i , j , min ; for ( i = 0 ; i < n ; i ++ ) index [ i ] = i ; for ( i = 0 ; i < n - 1 ; i ++ ) { min = i ; for ( j = i + 1 ; j < n ; j ++ ) { if ( arr [ index [ min ] ] . compare ( arr [ index [ j ] ] ) > 0 ) min = j ; } if ( min != i ) { int temp = index [ min ] ; index [ min ] = index [ i ] ; index [ i ] = temp ; } } for ( i = 0 ; i < n ; i ++ ) cout << arr [ index [ i ] ] << " ▁ " ; }
Ref: 
def printInSortedOrder ( arr , n ) : NEW_LINE INDENT index = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT index [ i ] = i NEW_LINE DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT min = i NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ index [ min ] ] > arr [ index [ j ] ] ) : NEW_LINE INDENT min = j NEW_LINE DEDENT DEDENT if ( min != i ) : NEW_LINE INDENT index [ min ] , index [ i ] = index [ i ] , index [ min ] NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ index [ i ] ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
Hyp: 
def printInSortedOrder ( arr , n ) : NEW_LINE INDENT index = [ 0 ] * n NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT index [ i ] = i NEW_LINE DEDENT for i in range ( 0 , n - 1 ) : NEW_LINE INDENT min = i NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ index [ min ] ] == arr [ index [ j ] ] ) > 0 : NEW_LINE INDENT min = j NEW_LINE DEDENT DEDENT if ( min != i ) : NEW_LINE INDENT temp = index [ min ] NEW_LINE index [ min ] = index [ i ] NEW_LINE index [ i ] = temp NEW_LINE DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ index [ i ] ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT

BLEU: 83.11
Edit Sim: 52


Src: 
int findS ( int s ) { int sum = 0 ; for ( int n = 1 ; sum < s ; n ++ ) { sum += n * n * n ; if ( sum == s ) return n ; } return - 1 ; }
Ref: 
def findS ( s ) : NEW_LINE INDENT _sum = 0 NEW_LINE n = 1 NEW_LINE while ( _sum < s ) : NEW_LINE INDENT _sum += n * n * n NEW_LINE n += 1 NEW_LINE DEDENT n -= 1 NEW_LINE if _sum == s : NEW_LINE INDENT return n NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
Hyp: 
def findS ( s ) : NEW_LINE INDENT sum = 0 NEW_LINE for n in range ( 1 , s ) : NEW_LINE INDENT sum += n * n * n NEW_LINE if ( sum == s ) : NEW_LINE INDENT return n NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT

BLEU: 49.47
Edit Sim: 73


Src: 
void printFun ( int test ) { if ( test < 1 ) return ; else { cout << test << " ▁ " ; printFun ( test - 1 ) ; cout << test << " ▁ " ; return ; } }
Ref: 
def printFun ( test ) : NEW_LINE INDENT if ( test < 1 ) : NEW_LINE INDENT return NEW_LINE DEDENT else : NEW_LINE INDENT print ( test , end = " ▁ " ) NEW_LINE printFun ( test - 1 ) NEW_LINE print ( test , end = " ▁ " ) NEW_LINE return NEW_LINE DEDENT DEDENT
Hyp: 
def printFun ( test ) : NEW_LINE INDENT if ( test < 1 ) : NEW_LINE INDENT return NEW_LINE DEDENT else : NEW_LINE INDENT print ( test , end = " ▁ " ) NEW_LINE printFun ( test - 1 ) NEW_LINE print ( test , end = " ▁ " ) NEW_LINE return NEW_LINE DEDENT DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
void shiftMatrixByK ( int mat [ N ] [ N ] , int k ) { if ( k > N ) { cout << " shifting ▁ is ▁ not ▁ possible " << endl ; return ; } int j = 0 ; while ( j < N ) { for ( int i = k ; i < N ; i ++ ) cout << mat [ j ] [ i ] << " ▁ " ; for ( int i = 0 ; i < k ; i ++ ) cout << mat [ j ] [ i ] << " ▁ " ; cout << endl ; j ++ ; } }
Ref: 
def shiftMatrixByK ( mat , k ) : NEW_LINE INDENT if ( k > N ) : NEW_LINE INDENT print ( " shifting ▁ is " " ▁ not ▁ possible " ) NEW_LINE return NEW_LINE DEDENT j = 0 NEW_LINE while ( j < N ) : NEW_LINE INDENT for i in range ( k , N ) : NEW_LINE INDENT print ( " { } ▁ " . format ( mat [ j ] [ i ] ) , end = " " ) NEW_LINE DEDENT for i in range ( 0 , k ) : NEW_LINE INDENT print ( " { } ▁ " . format ( mat [ j ] [ i ] ) , end = " " ) NEW_LINE DEDENT print ( " " ) NEW_LINE j = j + 1 NEW_LINE DEDENT DEDENT
Hyp: 
def shiftMatrixByK ( mat , k ) : NEW_LINE INDENT global N NEW_LINE if k > N : NEW_LINE INDENT print ( " shifting ▁ is ▁ not ▁ possible " ) NEW_LINE return NEW_LINE DEDENT j = 0 NEW_LINE while ( j < N ) : NEW_LINE INDENT for i in range ( k , N ) : NEW_LINE INDENT print ( mat [ j ] [ i ] , end = " ▁ " ) NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT print ( mat [ j ] [ i ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE j += 1 NEW_LINE DEDENT DEDENT

BLEU: 65.92
Edit Sim: 88


Src: 
void sortUsingHash ( int a [ ] , int n ) { int max = * std :: max_element ( a , a + n ) ; int min = abs ( * std :: min_element ( a , a + n ) ) ; int hashpos [ max + 1 ] = { 0 } ; int hashneg [ min + 1 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] >= 0 ) hashpos [ a [ i ] ] += 1 ; else hashneg [ abs ( a [ i ] ) ] += 1 ; } for ( int i = min ; i > 0 ; i -- ) { if ( hashneg [ i ] ) { for ( int j = 0 ; j < hashneg [ i ] ; j ++ ) { cout << ( - 1 ) * i << " ▁ " ; } } } for ( int i = 0 ; i <= max ; i ++ ) { if ( hashpos [ i ] ) { for ( int j = 0 ; j < hashpos [ i ] ; j ++ ) { cout << i << " ▁ " ; } } } }
Ref: 
def sortUsingHash ( a , n ) : NEW_LINE INDENT Max = max ( a ) NEW_LINE Min = abs ( min ( a ) ) NEW_LINE hashpos = [ 0 ] * ( Max + 1 ) NEW_LINE hashneg = [ 0 ] * ( Min + 1 ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if a [ i ] >= 0 : NEW_LINE INDENT hashpos [ a [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT hashneg [ abs ( a [ i ] ) ] += 1 NEW_LINE DEDENT DEDENT for i in range ( Min , 0 , - 1 ) : NEW_LINE INDENT if hashneg [ i ] != 0 : NEW_LINE INDENT for j in range ( 0 , hashneg [ i ] ) : NEW_LINE INDENT print ( ( - 1 ) * i , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( 0 , Max + 1 ) : NEW_LINE INDENT if hashpos [ i ] != 0 : NEW_LINE INDENT for j in range ( 0 , hashpos [ i ] ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
Hyp: 
def sortUsingHash ( a , n ) : NEW_LINE INDENT max1 = max ( a ) NEW_LINE min1 = abs ( a [ n ] ) NEW_LINE hashpos = [ 0 ] * ( max1 + 1 ) NEW_LINE hashneg = [ 0 ] * ( min1 + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] >= 0 ) : NEW_LINE INDENT hashpos [ a [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT hashneg [ abs ( a [ i ] ) ] += 1 NEW_LINE DEDENT DEDENT for i in range ( min , max1 + 1 ) : NEW_LINE INDENT if ( hashneg [ i ] ) : NEW_LINE INDENT for j in range ( - 1 , hashneg [ i ] , 1 ) : NEW_LINE INDENT print ( ( - 1 ) * i , " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( max1 + 1 ) : NEW_LINE INDENT if ( hashpos [ i ] ) : NEW_LINE INDENT for j in range ( hashpos [ i ] ) : NEW_LINE INDENT print ( i , " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT

BLEU: 73.85
Edit Sim: 76


Src: 
void findPair ( int arr [ ] , int n ) { bool found = false ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { for ( int k = 0 ; k < n ; k ++ ) { if ( arr [ i ] + arr [ j ] == arr [ k ] ) { cout << arr [ i ] << " ▁ " << arr [ j ] << endl ; found = true ; } } } } if ( found == false ) cout << " Not ▁ exist " << endl ; }
Ref: 
def findPair ( arr , n ) : NEW_LINE INDENT found = False NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT for k in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] + arr [ j ] == arr [ k ] ) : NEW_LINE INDENT print ( arr [ i ] , arr [ j ] ) NEW_LINE found = True NEW_LINE DEDENT DEDENT DEDENT DEDENT if ( found == False ) : NEW_LINE INDENT print ( " Not ▁ exist " ) NEW_LINE DEDENT DEDENT
Hyp: 
def findPair ( arr , n ) : NEW_LINE INDENT found = False NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT for k in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] + arr [ j ] == arr [ k ] ) : NEW_LINE INDENT print ( arr [ i ] , arr [ j ] ) NEW_LINE found = True NEW_LINE DEDENT DEDENT DEDENT DEDENT if ( found == False ) : NEW_LINE INDENT print ( " Not ▁ exist " ) NEW_LINE DEDENT DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int findMaxGCD ( int arr [ ] , int n ) { int high = 0 ; for ( int i = 0 ; i < n ; i ++ ) high = max ( high , arr [ i ] ) ; int count [ high + 1 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) count [ arr [ i ] ] ++ ; int counter = 0 ; for ( int i = high ; i >= 1 ; i -- ) { int j = i ; counter = 0 ; while ( j <= high ) { if ( count [ j ] >= 2 ) return j ; else if ( count [ j ] == 1 ) counter ++ ; j += i ; if ( counter == 2 ) return i ; } } }
Ref: 
def findMaxGCD ( arr , n ) : NEW_LINE INDENT high = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT high = max ( high , arr [ i ] ) NEW_LINE DEDENT count = [ 0 ] * ( high + 1 ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT count [ arr [ i ] ] += 1 NEW_LINE DEDENT counter = 0 NEW_LINE for i in range ( high , 0 , - 1 ) : NEW_LINE INDENT j = i NEW_LINE while ( j <= high ) : NEW_LINE INDENT if ( count [ j ] > 0 ) : NEW_LINE INDENT counter += count [ j ] NEW_LINE DEDENT j += i NEW_LINE if ( counter == 2 ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT counter = 0 NEW_LINE DEDENT DEDENT
Hyp: 
def findMaxGCD ( arr , n ) : NEW_LINE INDENT high = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT high = max ( high , arr [ i ] ) NEW_LINE DEDENT count = [ 0 for i in range ( high + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT count [ arr [ i ] ] = count [ arr [ i ] ] + 1 NEW_LINE DEDENT counter = 0 NEW_LINE for i in range ( high , 1 ) : NEW_LINE INDENT j = i NEW_LINE counter = 0 NEW_LINE while ( j <= high ) : NEW_LINE INDENT if ( count [ j ] >= 2 ) : NEW_LINE INDENT return j NEW_LINE DEDENT elif ( count [ j ] == 1 ) : NEW_LINE INDENT counter += 1 NEW_LINE DEDENT j += i NEW_LINE if ( counter == 2 ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT DEDENT

BLEU: 73.22
Edit Sim: 169


Src: 
bool squareRootExists ( int n , int p ) { n = n % p ; for ( int x = 2 ; x < p ; x ++ ) if ( ( x * x ) % p == n ) return true ; return false ; }
Ref: 
def squareRootExists ( n , p ) : NEW_LINE INDENT n = n % p NEW_LINE for x in range ( 2 , p , 1 ) : NEW_LINE INDENT if ( ( x * x ) % p == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
Hyp: 
def squareRootExists ( n , p ) : NEW_LINE INDENT n = n % p NEW_LINE for x in range ( 2 , p ) : NEW_LINE INDENT if ( ( x * x ) % p == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT

BLEU: 93.35
Edit Sim: 4


Src: 
int count ( int n , int x ) { int count == 0 ; for ( int i = 1 ; i <= n && i <= x ; i ++ ) { if ( x / i <= n && x % i == 0 ) count ++ ; } return count ; }
Ref: 
def count ( n , x ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if i <= x : NEW_LINE INDENT if x // i <= n and x % i == 0 : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT
Hyp: 
def count ( n , x ) : NEW_LINE INDENT count = 0 NEW_LINE i = 1 NEW_LINE while i <= n and i <= x : NEW_LINE INDENT if ( x // i <= n and x % i == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT

BLEU: 53.65
Edit Sim: 64


Src: 
int maxSubArraySum ( int a [ ] , int size ) { int max_so_far = INT_MIN , max_ending_here = 0 , start = 0 , end = 0 , s = 0 ; for ( int i = 0 ; i < size ; i ++ ) { max_ending_here += a [ i ] ; if ( max_so_far < max_ending_here ) { max_so_far = max_ending_here ; start = s ; end = i ; } if ( max_ending_here < 0 ) { max_ending_here = 0 ; s = i + 1 ; } } return ( end - start + 1 ) ; }
Ref: 
def maxSubArraySum ( a , size ) : NEW_LINE INDENT max_so_far = - maxsize - 1 NEW_LINE max_ending_here = 0 NEW_LINE start = 0 NEW_LINE end = 0 NEW_LINE s = 0 NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT max_ending_here += a [ i ] NEW_LINE if max_so_far < max_ending_here : NEW_LINE INDENT max_so_far = max_ending_here NEW_LINE start = s NEW_LINE end = i NEW_LINE DEDENT if max_ending_here < 0 : NEW_LINE INDENT max_ending_here = 0 NEW_LINE s = i + 1 NEW_LINE DEDENT DEDENT return ( end - start + 1 ) NEW_LINE DEDENT
Hyp: 
def maxSubArraySum ( a , size ) : NEW_LINE INDENT max_so_far = - maxsize - 1 NEW_LINE max_ending_here = 0 NEW_LINE start = 0 NEW_LINE end = 0 NEW_LINE s = 0 NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT max_ending_here += a [ i ] NEW_LINE if max_so_far < max_ending_here : NEW_LINE INDENT max_so_far = max_ending_here NEW_LINE start = s NEW_LINE end = i NEW_LINE DEDENT if max_ending_here < 0 : NEW_LINE INDENT max_ending_here = 0 NEW_LINE s = i + 1 NEW_LINE DEDENT DEDENT return ( end - start + 1 ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
void smallestSubsegment ( int a [ ] , int n ) { unordered_map < int , int > left ; unordered_map < int , int > count ; int mx = 0 ; int mn , strindex ; for ( int i = 0 ; i < n ; i ++ ) { int x = a [ i ] ; if ( count [ x ] == 0 ) { left [ x ] = i ; count [ x ] = 1 ; } else count [ x ] ++ ; if ( count [ x ] > mx ) { mx = count [ x ] ; mn = i - left [ x ] + 1 ; strindex = left [ x ] ; } else if ( count [ x ] == mx && i - left [ x ] + 1 < mn ) { mn = i - left [ x ] + 1 ; strindex = left [ x ] ; } } for ( int i = strindex ; i < strindex + mn ; i ++ ) cout << a [ i ] << " ▁ " ; }
Ref: 
def smallestSubsegment ( a , n ) : NEW_LINE INDENT left = dict ( ) NEW_LINE count = dict ( ) NEW_LINE mx = 0 NEW_LINE mn , strindex = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = a [ i ] NEW_LINE if ( x not in count . keys ( ) ) : NEW_LINE INDENT left [ x ] = i NEW_LINE count [ x ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT count [ x ] += 1 NEW_LINE DEDENT if ( count [ x ] > mx ) : NEW_LINE INDENT mx = count [ x ] NEW_LINE mn = i - left [ x ] + 1 NEW_LINE strindex = left [ x ] NEW_LINE DEDENT elif ( count [ x ] == mx and i - left [ x ] + 1 < mn ) : NEW_LINE INDENT mn = i - left [ x ] + 1 NEW_LINE strindex = left [ x ] NEW_LINE DEDENT DEDENT for i in range ( strindex , strindex + mn ) : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
Hyp: 
def smallestSubsegment ( a , n ) : NEW_LINE INDENT left = dict ( ) NEW_LINE count = dict ( ) NEW_LINE mx = 0 NEW_LINE mn = 0 NEW_LINE strindex = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = a [ i ] NEW_LINE if count [ x ] == 0 : NEW_LINE INDENT left [ x ] = i NEW_LINE count [ x ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT count [ x ] += 1 NEW_LINE DEDENT if count [ x ] > mx : NEW_LINE INDENT mx = count [ x ] NEW_LINE mn = i - left [ x ] + 1 NEW_LINE strindex = left [ x ] NEW_LINE DEDENT elif count [ x ] == mx and i - left [ x ] + 1 < mn : NEW_LINE INDENT mn = i - left [ x ] + 1 NEW_LINE strindex = left [ x ] NEW_LINE DEDENT DEDENT for i in range ( strindex , strindex + mn ) : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT

BLEU: 86.97
Edit Sim: 44


Src: 
void findRandomIndexOfMax ( int arr [ ] , int n ) { unordered_map < int , int > freq ; for ( int i = 0 ; i < n ; i ++ ) freq [ arr [ i ] ] += 1 ; int max_element ; int max_so_far = INT_MIN ; for ( pair < int , int > p : freq ) { if ( p . second > max_so_far ) { max_so_far = p . second ; max_element = p . first ; } } int r = ( rand ( ) % max_so_far ) + 1 ; for ( int i = 0 , count = 0 ; i < n ; i ++ ) { if ( arr [ i ] == max_element ) count ++ ; if ( count == r ) { cout << " Element ▁ with ▁ maximum ▁ frequency ▁ present ▁ " " at ▁ index ▁ " << i << endl ; break ; } } }
Ref: 
def findRandomIndexOfMax ( arr , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] in mp ) : NEW_LINE INDENT mp [ arr [ i ] ] = mp [ arr [ i ] ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT max_element = - 323567 NEW_LINE max_so_far = - 323567 NEW_LINE for p in mp : NEW_LINE INDENT if ( mp [ p ] > max_so_far ) : NEW_LINE INDENT max_so_far = mp [ p ] NEW_LINE max_element = p NEW_LINE DEDENT DEDENT r = int ( ( ( random . randrange ( 1 , max_so_far , 2 ) % max_so_far ) + 1 ) ) NEW_LINE i = 0 NEW_LINE count = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( arr [ i ] == max_element ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT if ( count == r ) : NEW_LINE INDENT print ( " Element ▁ with ▁ maximum ▁ frequency ▁ present ▁ at ▁ index ▁ " , i ) NEW_LINE break NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT DEDENT
Hyp: 
def findRandomIndexOfMax ( arr , n ) : NEW_LINE INDENT freq = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ arr [ i ] ] = freq . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT max_element = - 1 NEW_LINE max_so_far = - 1 NEW_LINE for p in freq : NEW_LINE INDENT if ( p . second > max_so_far ) : NEW_LINE INDENT max_so_far = p . second NEW_LINE max_element = p . first NEW_LINE DEDENT DEDENT r = ( rand ( ) % max_so_far ) + 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == max_element ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( count == r ) : NEW_LINE INDENT print ( " Element ▁ with ▁ maximum ▁ frequency ▁ present ▁ " , i ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT

BLEU: 49.71
Edit Sim: 280


Src: 
int minRadius ( int k , int x [ ] , int y [ ] , int n ) { int dis [ n ] ; for ( int i = 0 ; i < n ; i ++ ) dis [ i ] = x [ i ] * x [ i ] + y [ i ] * y [ i ] ; sort ( dis , dis + n ) ; return dis [ k - 1 ] ; }
Ref: 
def minRadius ( k , x , y , n ) : NEW_LINE INDENT dis = [ 0 ] * n NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT dis [ i ] = x [ i ] * x [ i ] + y [ i ] * y [ i ] NEW_LINE DEDENT dis . sort ( ) NEW_LINE return dis [ k - 1 ] NEW_LINE DEDENT
Hyp: 
def minRadius ( k , x , y , n ) : NEW_LINE INDENT dis = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT dis [ i ] = x [ i ] * x [ i ] + y [ i ] * y [ i ] NEW_LINE DEDENT sort ( dis ) NEW_LINE return dis [ k - 1 ] NEW_LINE DEDENT

BLEU: 87.21
Edit Sim: 18


Src: 
int singleNumber ( int a [ ] , int n ) { unordered_set < int > s ( a , a + n ) ; int arr_sum = accumulate ( a , a + n , 0 ) ; int set_sum = accumulate ( s . begin ( ) , s . end ( ) , 0 ) ; return ( 3 * set_sum - arr_sum ) / 2 ; }
Ref: 
def singleNumber ( nums ) : NEW_LINE INDENT return ( 3 * sum ( set ( nums ) ) - sum ( nums ) ) / 2 NEW_LINE DEDENT
Hyp: 
def singleNumber ( a , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE arr_sum = accumulate ( a , a + n , 0 ) NEW_LINE set_sum = accumulate ( s , s , 0 ) NEW_LINE return ( 3 * set_sum - arr_sum ) / 2 NEW_LINE DEDENT

BLEU: 21.76
Edit Sim: 117


Src: 
int countInRange ( int arr [ ] , int n , int x , int y ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] >= x && arr [ i ] <= y ) count ++ ; } return count ; }
Ref: 
def countInRange ( arr , n , x , y ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] >= x and arr [ i ] <= y ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
Hyp: 
def countInRange ( arr , n , x , y ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] >= x and arr [ i ] <= y : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT

BLEU: 86.54
Edit Sim: 6


Src: 
void findSmallest ( int m , int s ) { if ( s == 0 ) { ( m == 1 ) ? cout << " Smallest ▁ number ▁ is ▁ " << 0 : cout << " Not ▁ possible " ; return ; } if ( s > 9 * m ) { cout << " Not ▁ possible " ; return ; } int res [ m ] ; s -= 1 ; for ( int i = m - 1 ; i > 0 ; i -- ) { if ( s > 9 ) { res [ i ] = 9 ; s -= 9 ; } else { res [ i ] = s ; s = 0 ; } } res [ 0 ] = s + 1 ; cout << " Smallest ▁ number ▁ is ▁ " ; for ( int i = 0 ; i < m ; i ++ ) cout << res [ i ] ; }
Ref: 
def findSmallest ( m , s ) : NEW_LINE INDENT if ( s == 0 ) : NEW_LINE INDENT if ( m == 1 ) : NEW_LINE INDENT print ( " Smallest ▁ number ▁ is ▁ 0" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ possible " ) NEW_LINE DEDENT return NEW_LINE DEDENT if ( s > 9 * m ) : NEW_LINE INDENT print ( " Not ▁ possible " ) NEW_LINE return NEW_LINE DEDENT res = [ 0 for i in range ( m + 1 ) ] NEW_LINE s -= 1 NEW_LINE for i in range ( m - 1 , 0 , - 1 ) : NEW_LINE INDENT if ( s > 9 ) : NEW_LINE INDENT res [ i ] = 9 NEW_LINE s -= 9 NEW_LINE DEDENT else : NEW_LINE INDENT res [ i ] = s NEW_LINE s = 0 NEW_LINE DEDENT DEDENT res [ 0 ] = s + 1 NEW_LINE print ( " Smallest ▁ number ▁ is ▁ " , end = " " ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT print ( res [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
Hyp: 
def findSmallest ( m , s ) : NEW_LINE INDENT if ( s == 0 ) : NEW_LINE INDENT ( m == 1 ) : NEW_LINE INDENT print ( " Smallest ▁ number ▁ is ▁ " , 0 ) NEW_LINE DEDENT if ( s > 9 * m ) : NEW_LINE INDENT print ( " Not ▁ possible " ) NEW_LINE return NEW_LINE DEDENT res = [ 0 ] * m NEW_LINE s -= 1 NEW_LINE for i in range ( m - 1 , 0 , - 1 ) : NEW_LINE INDENT if ( s > 9 ) : NEW_LINE INDENT res [ i ] = 9 NEW_LINE s -= 9 NEW_LINE DEDENT else : NEW_LINE INDENT res [ i ] = s NEW_LINE s = 0 NEW_LINE DEDENT DEDENT res [ 0 ] = s + 1 NEW_LINE print ( " Smallest ▁ number ▁ is ▁ " ) NEW_LINE for i in range ( 0 , m ) : NEW_LINE INDENT print ( res [ i ] ) NEW_LINE DEDENT DEDENT

BLEU: 76.68
Edit Sim: 144


Src: 
bool isPresent ( string s , string q ) { int freq [ MAX_CHAR ] = { 0 } ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) freq [ s [ i ] ] ++ ; for ( int i = 0 ; i < q . length ( ) ; i ++ ) { freq [ q [ i ] ] -- ; if ( freq [ q [ i ] ] < 0 ) return false ; } return true ; }
Ref: 
def isPresent ( s , q ) : NEW_LINE INDENT freq = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT freq [ ord ( s [ i ] ) ] += 1 NEW_LINE DEDENT for i in range ( 0 , len ( q ) ) : NEW_LINE INDENT freq [ ord ( q [ i ] ) ] -= 1 NEW_LINE if ( freq [ ord ( q [ i ] ) ] < 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
Hyp: 
def isPresent ( s , q ) : NEW_LINE INDENT freq = [ 0 for i in range ( MAX_CHAR ) ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT freq [ ord ( s [ i ] ) ] += 1 NEW_LINE DEDENT for i in range ( len ( q ) ) : NEW_LINE INDENT freq [ ord ( q [ i ] ) ] -= 1 NEW_LINE if ( freq [ ord ( q [ i ] ) ] < 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT

BLEU: 88.15
Edit Sim: 27


Src: 
void sortArray ( int arr [ ] , int n , int A , int B , int C ) { for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = A * arr [ i ] * arr [ i ] + B * arr [ i ] + C ; int index , maximum = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { if ( maximum < arr [ i ] ) { index = i ; maximum = arr [ i ] ; } } int i = 0 , j = n - 1 ; int new_arr [ n ] , k = 0 ; while ( i < index && j > index ) { if ( arr [ i ] < arr [ j ] ) new_arr [ k ++ ] = arr [ i ++ ] ; else new_arr [ k ++ ] = arr [ j -- ] ; } while ( i < index ) new_arr [ k ++ ] = arr [ i ++ ] ; while ( j > index ) new_arr [ k ++ ] = arr [ j -- ] ; new_arr [ n - 1 ] = maximum ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = new_arr [ i ] ; }
Ref: 
def sortArray ( arr , n , A , B , C ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = ( A * arr [ i ] * arr [ i ] + B * arr [ i ] + C ) NEW_LINE DEDENT index = - ( sys . maxsize - 1 ) NEW_LINE maximum = - ( sys . maxsize - 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if maximum < arr [ i ] : NEW_LINE INDENT index = i NEW_LINE maximum = arr [ i ] NEW_LINE DEDENT DEDENT i = 0 j = n - 1 NEW_LINE new_arr = [ 0 ] * n NEW_LINE k = 0 NEW_LINE while i < index and j > index : NEW_LINE INDENT if arr [ i ] < arr [ j ] : NEW_LINE INDENT new_arr [ k ] = arr [ i ] NEW_LINE k += 1 NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT new_arr [ k ] = arr [ j ] NEW_LINE k += 1 NEW_LINE j -= 1 NEW_LINE DEDENT DEDENT while i < index : NEW_LINE INDENT new_arr [ k ] = arr [ i ] NEW_LINE k += 1 NEW_LINE i += 1 NEW_LINE DEDENT while j > index : NEW_LINE INDENT new_arr [ k ] = arr [ j ] NEW_LINE k += 1 NEW_LINE j -= 1 NEW_LINE new_arr [ n - 1 ] = maximum NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = new_arr [ i ] NEW_LINE DEDENT DEDENT
Hyp: 
def sortArray ( arr , n , A , B , C ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = A * arr [ i ] * arr [ i ] + B * arr [ i ] + C NEW_LINE DEDENT index = - sys . maxsize - 1 NEW_LINE maximum = - sys . maxsize - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( maximum < arr [ i ] ) : NEW_LINE INDENT index = i NEW_LINE maximum = arr [ i ] NEW_LINE DEDENT DEDENT i = 0 NEW_LINE j = n - 1 NEW_LINE new_arr = [ 0 ] * n NEW_LINE k = 0 NEW_LINE while ( i < index and j > index ) : NEW_LINE INDENT if ( arr [ i ] < arr [ j ] ) : NEW_LINE INDENT new_arr [ k ] = arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT new_arr [ k ] = arr [ j ] NEW_LINE j -= 1 NEW_LINE DEDENT DEDENT while ( i < index ) : NEW_LINE INDENT new_arr [ k ] = arr [ i ] NEW_LINE i += 1 NEW_LINE DEDENT while ( j > index ) : NEW_LINE INDENT new_arr [ k ] = arr [ j ] NEW_LINE j -= 1 NEW_LINE DEDENT new_arr [ n - 1 ] = maximum NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr [ i ] = new_arr [ i ] NEW_LINE DEDENT DEDENT

BLEU: 79.46
Edit Sim: 127


Src: 
void printDistance ( int mat [ N ] [ M ] ) { int ans [ N ] [ M ] ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < M ; j ++ ) ans [ i ] [ j ] = INT_MAX ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < M ; j ++ ) { for ( int k = 0 ; k < N ; k ++ ) for ( int l = 0 ; l < M ; l ++ ) { if ( mat [ k ] [ l ] == 1 ) ans [ i ] [ j ] = min ( ans [ i ] [ j ] , abs ( i - k ) + abs ( j - l ) ) ; } } for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) cout << ans [ i ] [ j ] << " ▁ " ; cout << endl ; } }
Ref: 
def printDistance ( mat ) : NEW_LINE INDENT global N , M NEW_LINE ans = [ [ None ] * M for i in range ( N ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT ans [ i ] [ j ] = 999999999999 NEW_LINE DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT for k in range ( N ) : NEW_LINE INDENT for l in range ( M ) : NEW_LINE INDENT if ( mat [ k ] [ l ] == 1 ) : NEW_LINE INDENT ans [ i ] [ j ] = min ( ans [ i ] [ j ] , abs ( i - k ) + abs ( j - l ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT print ( ans [ i ] [ j ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT
Hyp: 
def printDistance ( mat ) : NEW_LINE INDENT ans = [ [ 0 for i in range ( M ) ] for j in range ( N ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT ans [ i ] [ j ] = sys . maxsize NEW_LINE DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT for k in range ( N ) : NEW_LINE INDENT for l in range ( M ) : NEW_LINE INDENT if ( mat [ k ] [ l ] == 1 ) : NEW_LINE INDENT ans [ i ] [ j ] = min ( ans [ i ] [ j ] , abs ( i - k ) + abs ( j - l ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT print ( ans [ i ] [ j ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT

BLEU: 91.95
Edit Sim: 52


Src: 
int findLastIndex ( string & str , char x ) { int index = - 1 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) if ( str [ i ] == x ) index = i ; return index ; }
Ref: 
def findLastIndex ( str , x ) : NEW_LINE INDENT index = - 1 NEW_LINE for i in range ( 0 , len ( str ) ) : NEW_LINE INDENT if str [ i ] == x : NEW_LINE INDENT index = i NEW_LINE DEDENT DEDENT return index NEW_LINE DEDENT
Hyp: 
def findLastIndex ( str , x ) : NEW_LINE INDENT index = - 1 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] == x ) : NEW_LINE INDENT index = i NEW_LINE DEDENT DEDENT return index NEW_LINE DEDENT

BLEU: 86.42
Edit Sim: 8


Src: 
void printAllAPTriplets ( int arr [ ] , int n ) { unordered_set < int > s ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int diff = arr [ j ] - arr [ i ] ; if ( s . find ( arr [ i ] - diff ) != s . end ( ) ) cout << arr [ i ] - diff << " ▁ " << arr [ i ] << " ▁ " << arr [ j ] << endl ; } s . insert ( arr [ i ] ) ; } }
Ref: 
def printAllAPTriplets ( arr , n ) : NEW_LINE INDENT s = [ ] NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT diff = arr [ j ] - arr [ i ] NEW_LINE if ( ( arr [ i ] - diff ) in arr ) : NEW_LINE INDENT print ( " { } ▁ { } ▁ { } " . format ( ( arr [ i ] - diff ) , arr [ i ] , arr [ j ] ) , end = " \n " ) NEW_LINE DEDENT DEDENT DEDENT s . append ( arr [ i ] ) NEW_LINE DEDENT
Hyp: 
def printAllAPTriplets ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT diff = arr [ j ] - arr [ i ] NEW_LINE if ( arr [ i ] - diff ) in s : NEW_LINE INDENT print ( arr [ i ] - diff , end = " ▁ " , arr [ j ] ) NEW_LINE DEDENT DEDENT DEDENT s . add ( arr [ i ] ) NEW_LINE DEDENT DEDENT

BLEU: 68.53
Edit Sim: 83


Src: 
char * simplify ( string str ) { int len = str . length ( ) ; char * res = new char ( len ) ; int index = 0 , i = 0 ; stack < int > s ; s . push ( 0 ) ; while ( i < len ) { if ( str [ i ] == ' + ' ) { if ( s . top ( ) == 1 ) res [ index ++ ] = ' - ' ; if ( s . top ( ) == 0 ) res [ index ++ ] = ' + ' ; } else if ( str [ i ] == ' - ' ) { if ( s . top ( ) == 1 ) res [ index ++ ] = ' + ' ; else if ( s . top ( ) == 0 ) res [ index ++ ] = ' - ' ; } else if ( str [ i ] == ' ( ' && i > 0 ) { if ( str [ i - 1 ] == ' - ' ) { int x = ( s . top ( ) == 1 ) ? 0 : 1 ; s . push ( x ) ; } else if ( str [ i - 1 ] == ' + ' ) s . push ( s . top ( ) ) ; } else if ( str [ i ] == ' ) ' ) s . pop ( ) ; else res [ index ++ ] = str [ i ] ; i ++ ; } return res ; }
Ref: 
def simplify ( Str ) : NEW_LINE INDENT Len = len ( Str ) NEW_LINE res = [ None ] * Len NEW_LINE index = 0 NEW_LINE i = 0 NEW_LINE s = [ ] NEW_LINE s . append ( 0 ) NEW_LINE while ( i < Len ) : NEW_LINE INDENT if ( Str [ i ] == ' + ' ) : NEW_LINE INDENT if ( s [ - 1 ] == 1 ) : NEW_LINE INDENT res [ index ] = ' - ' NEW_LINE index += 1 NEW_LINE DEDENT if ( s [ - 1 ] == 0 ) : NEW_LINE INDENT res [ index ] = ' + ' NEW_LINE index += 1 NEW_LINE DEDENT DEDENT elif ( Str [ i ] == ' - ' ) : NEW_LINE INDENT if ( s [ - 1 ] == 1 ) : NEW_LINE INDENT res [ index ] = ' + ' NEW_LINE index += 1 NEW_LINE DEDENT elif ( s [ - 1 ] == 0 ) : NEW_LINE INDENT res [ index ] = ' - ' NEW_LINE index += 1 NEW_LINE DEDENT DEDENT elif ( Str [ i ] == ' ( ' and i > 0 ) : NEW_LINE INDENT if ( Str [ i - 1 ] == ' - ' ) : NEW_LINE INDENT x = 0 if ( s [ - 1 ] == 1 ) else 1 NEW_LINE s . append ( x ) NEW_LINE DEDENT elif ( Str [ i - 1 ] == ' + ' ) : NEW_LINE INDENT s . append ( s [ - 1 ] ) NEW_LINE DEDENT DEDENT elif ( Str [ i ] == ' ) ' ) : NEW_LINE INDENT s . pop ( ) NEW_LINE DEDENT else : NEW_LINE INDENT res [ index ] = Str [ i ] NEW_LINE index += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT
Hyp: 
def simplify ( str ) : NEW_LINE INDENT l = len ( str ) NEW_LINE res = [ 0 ] * ( l ) NEW_LINE index = 0 NEW_LINE i = 0 NEW_LINE s = [ ] NEW_LINE while i < l : NEW_LINE INDENT if ( str [ i ] == ' + ' ) : NEW_LINE INDENT if ( s [ 0 ] == 1 ) : NEW_LINE INDENT res [ index ] = ' - ' NEW_LINE DEDENT if ( s [ 0 ] == 0 ) : NEW_LINE INDENT res [ index ] = ' + ' NEW_LINE DEDENT DEDENT elif ( str [ i ] == ' - ' ) : NEW_LINE INDENT if ( s [ 0 ] == 1 ) : NEW_LINE INDENT res [ index ] = ' - ' NEW_LINE DEDENT elif ( s [ 0 ] == 0 ) : NEW_LINE INDENT res [ index ] = ' - ' NEW_LINE DEDENT DEDENT elif ( str [ i ] == ' ( ' and i > 0 ) : NEW_LINE INDENT if ( str [ i - 1 ] == ' - ' ) : NEW_LINE INDENT x = 0 NEW_LINE DEDENT s . append ( x ) NEW_LINE DEDENT elif ( str [ i - 1 ] == ' + ' ) : NEW_LINE INDENT s . append ( s [ - 1 ] ) NEW_LINE DEDENT DEDENT elif ( str [ i ] == ' ) ' ) : NEW_LINE INDENT s . pop ( ) NEW_LINE DEDENT else : NEW_LINE INDENT res [ index ] = str [ i ] NEW_LINE i += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT

BLEU: 68.69
Edit Sim: 201


Src: 
double vol_of_dodecahedron ( int side ) { return ( ( ( 15 + ( 7 * ( sqrt ( 5 ) ) ) ) / 4 ) * ( pow ( side , 3 ) ) ) ; }
Ref: 
def vol_of_dodecahedron ( side ) : NEW_LINE INDENT return ( ( ( 15 + ( 7 * ( math . sqrt ( 5 ) ) ) ) / 4 ) * ( math . pow ( side , 3 ) ) ) NEW_LINE DEDENT
Hyp: 
def vol_of_dodecahedron ( side ) : NEW_LINE INDENT return ( ( ( 15 + ( 7 * ( math . sqrt ( 5 ) ) ) ) / 4 ) * ( math . pow ( side , 3 ) ) ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int countTransformation ( string a , string b ) { int n = a . size ( ) , m = b . size ( ) ; if ( m == 0 ) return 1 ; int dp [ m + 1 ] [ n + 1 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { if ( i == 0 ) { if ( j == 0 ) dp [ i ] [ j ] = ( a [ j ] == b [ i ] ) ? 1 : 0 ; else if ( a [ j ] == b [ i ] ) dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + 1 ; else dp [ i ] [ j ] = dp [ i ] [ j - 1 ] ; } else { if ( a [ j ] == b [ i ] ) dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = dp [ i ] [ j - 1 ] ; } } } return dp [ m - 1 ] [ n - 1 ] ; }
Ref: 
def countTransformation ( a , b ) : NEW_LINE INDENT n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE if m == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT dp = [ [ 0 ] * ( n + 1 ) for _ in range ( m + 1 ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT if j == 0 : NEW_LINE INDENT if a [ j ] == b [ i ] : NEW_LINE INDENT dp [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT elif a [ j ] == b [ i ] : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if a [ j ] == b [ i ] : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ j - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT DEDENT return dp [ m - 1 ] [ n - 1 ] NEW_LINE DEDENT
Hyp: 
def countTransformation ( a , b ) : NEW_LINE INDENT n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE if ( m == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( m + 1 ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT if ( j == 0 ) : NEW_LINE INDENT dp [ i ] [ j ] = ( a [ j ] == b [ i ] ) ? 1 : 0 NEW_LINE DEDENT elif ( a [ j ] == b [ i ] ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( a [ j ] == b [ i ] ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT return dp [ m - 1 ] [ n - 1 ] NEW_LINE DEDENT

BLEU: 80.95
Edit Sim: 153


Src: 
int sumAtKthLevel ( string tree , int k , int & i , int level ) { if ( tree [ i ++ ] == ' ( ' ) { if ( tree [ i ] == ' ) ' ) return 0 ; int sum = 0 ; if ( level == k ) sum = tree [ i ] - '0' ; int leftsum = sumAtKthLevel ( tree , k , ++ i , level + 1 ) ; int rightsum = sumAtKthLevel ( tree , k , ++ i , level + 1 ) ; ++ i ; return sum + leftsum + rightsum ; } }
Ref: 
def sumAtKthLevel ( tree , k , i , level ) : NEW_LINE INDENT if ( tree [ i [ 0 ] ] == ' ( ' ) : NEW_LINE INDENT i [ 0 ] += 1 NEW_LINE if ( tree [ i [ 0 ] ] == ' ) ' ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT sum = 0 NEW_LINE if ( level == k ) : NEW_LINE INDENT sum = int ( tree [ i [ 0 ] ] ) NEW_LINE DEDENT i [ 0 ] += 1 NEW_LINE leftsum = sumAtKthLevel ( tree , k , i , level + 1 ) NEW_LINE i [ 0 ] += 1 NEW_LINE rightsum = sumAtKthLevel ( tree , k , i , level + 1 ) NEW_LINE i [ 0 ] += 1 NEW_LINE return sum + leftsum + rightsum NEW_LINE DEDENT DEDENT
Hyp: 
def sumAtKthLevel ( tree , k , i , level ) : NEW_LINE INDENT if ( tree [ i ] == ' ( ' ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT sum = 0 NEW_LINE if ( level == k ) : NEW_LINE INDENT sum = int ( tree [ i ] ) - int ( '0' ) NEW_LINE DEDENT leftsum = sumAtKthLevel ( tree , k , i , level + 1 ) NEW_LINE rightsum = sumAtKthLevel ( tree , k , i , level + 1 ) NEW_LINE i += 1 NEW_LINE return sum + leftsum + rightsum NEW_LINE DEDENT

BLEU: 58.12
Edit Sim: 148


Src: 
void printRepeating ( int arr [ ] , int size ) { int * count = new int [ sizeof ( int ) * ( size - 2 ) ] ; int i ; cout << " ▁ Repeating ▁ elements ▁ are ▁ " ; for ( i = 0 ; i < size ; i ++ ) { if ( count [ arr [ i ] ] == 1 ) cout << arr [ i ] << " ▁ " ; else count [ arr [ i ] ] ++ ; } }
Ref: 
def printRepeating ( arr , size ) : NEW_LINE INDENT count = [ 0 ] * size NEW_LINE print ( " ▁ Repeating ▁ elements ▁ are ▁ " , end = " " ) NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT if ( count [ arr [ i ] ] == 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT count [ arr [ i ] ] = count [ arr [ i ] ] + 1 NEW_LINE DEDENT DEDENT DEDENT
Hyp: 
def printRepeating ( arr , size ) : NEW_LINE INDENT count = [ 0 ] * ( size - 2 ) NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT if ( count [ arr [ i ] ] == 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT count [ arr [ i ] ] += 1 NEW_LINE DEDENT DEDENT DEDENT

BLEU: 69.02
Edit Sim: 85


Src: 
int countPairsWithDiffK ( int arr [ ] , int n , int k ) { int count = 0 ; sort ( arr , arr + n ) ; int l = 0 ; int r = 0 ; while ( r < n ) { if ( arr [ r ] - arr [ l ] == k ) { count ++ ; l ++ ; r ++ ; } else if ( arr [ r ] - arr [ l ] > k ) l ++ ; else r ++ ; } return count ; }
Ref: 
def countPairsWithDiffK ( arr , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE arr . sort ( ) NEW_LINE l = 0 NEW_LINE r = 0 NEW_LINE while r < n : NEW_LINE INDENT if arr [ r ] - arr [ l ] == k : NEW_LINE INDENT count += 1 NEW_LINE l += 1 NEW_LINE r += 1 NEW_LINE DEDENT elif arr [ r ] - arr [ l ] > k : NEW_LINE INDENT l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT r += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
Hyp: 
def countPairsWithDiffK ( arr , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE arr . sort ( ) NEW_LINE l = 0 NEW_LINE r = 0 NEW_LINE while ( r < n ) : NEW_LINE INDENT if ( arr [ r ] - arr [ l ] == k ) : NEW_LINE INDENT count += 1 NEW_LINE l += 1 NEW_LINE r += 1 NEW_LINE DEDENT elif ( arr [ r ] - arr [ l ] > k ) : NEW_LINE INDENT l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT r += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT

BLEU: 85.32
Edit Sim: 12


Src: 
bool isSubsetSum ( int set [ ] , int n , int sum ) { bool subset [ n + 1 ] [ sum + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) subset [ i ] [ 0 ] = true ; for ( int i = 1 ; i <= sum ; i ++ ) subset [ 0 ] [ i ] = false ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= sum ; j ++ ) { if ( j < set [ i - 1 ] ) subset [ i ] [ j ] = subset [ i - 1 ] [ j ] ; if ( j >= set [ i - 1 ] ) subset [ i ] [ j ] = subset [ i - 1 ] [ j ] || subset [ i - 1 ] [ j - set [ i - 1 ] ] ; } } return subset [ n ] [ sum ] ; }
Ref: 
def isSubsetSum ( set , n , sum ) : NEW_LINE INDENT subset = ( [ [ False for i in range ( sum + 1 ) ] for i in range ( n + 1 ) ] ) NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT subset [ i ] [ 0 ] = True NEW_LINE for i in range ( 1 , sum + 1 ) : NEW_LINE INDENT subset [ 0 ] [ i ] = False NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , sum + 1 ) : NEW_LINE INDENT if j < set [ i - 1 ] : NEW_LINE INDENT subset [ i ] [ j ] = subset [ i - 1 ] [ j ] NEW_LINE DEDENT if j >= set [ i - 1 ] : NEW_LINE INDENT subset [ i ] [ j ] = ( subset [ i - 1 ] [ j ] or subset [ i - 1 ] [ j - set [ i - 1 ] ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return subset [ n ] [ sum ] NEW_LINE DEDENT
Hyp: 
def isSubsetSum ( set , n , Sum ) : NEW_LINE INDENT subset = [ [ False for i in range ( Sum + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT subset [ i ] [ 0 ] = True NEW_LINE DEDENT for i in range ( 1 , Sum + 1 ) : NEW_LINE INDENT subset [ 0 ] [ i ] = False NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , Sum + 1 ) : NEW_LINE INDENT if ( j < Set [ i - 1 ] ) : NEW_LINE INDENT subset [ i ] [ j ] = subset [ i - 1 ] [ j ] NEW_LINE DEDENT if ( j >= Set [ i - 1 ] ) : NEW_LINE INDENT subset [ i ] [ j ] = subset [ i - 1 ] [ j ] or subset [ i - 1 ] [ j - set [ i - 1 ] ] NEW_LINE DEDENT DEDENT DEDENT return subset [ n ] [ Sum ] NEW_LINE DEDENT

BLEU: 83.25
Edit Sim: 37


Src: 
void findMajority ( int arr [ ] , int size ) { unordered_map < int , int > m ; for ( int i = 0 ; i < size ; i ++ ) m [ arr [ i ] ] ++ ; int count = 0 ; for ( auto i : m ) { if ( i . second > size / 2 ) { count = 1 ; cout << " Majority ▁ found ▁ : - ▁ " << i . first << endl ; break ; } } if ( count == 0 ) cout << " No ▁ Majority ▁ element " << endl ; }
Ref: 
def findMajority ( arr , size ) : NEW_LINE INDENT m = { } NEW_LINE for i in range ( size ) : NEW_LINE INDENT if arr [ i ] in m : NEW_LINE INDENT m [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT m [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT count = 0 NEW_LINE for key in m : NEW_LINE INDENT if m [ key ] > size / 2 : NEW_LINE INDENT count = 1 NEW_LINE print ( " Majority ▁ found ▁ : - " , key ) NEW_LINE break NEW_LINE DEDENT DEDENT if ( count == 0 ) : NEW_LINE INDENT print ( " No ▁ Majority ▁ element " ) NEW_LINE DEDENT DEDENT
Hyp: 
def findMajority ( arr , size ) : NEW_LINE INDENT mp = defaultdict ( lambda : 0 ) NEW_LINE for i in range ( size ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT count = 0 NEW_LINE for i in mp : NEW_LINE INDENT if ( mp [ i ] > size // 2 ) : NEW_LINE INDENT count = 1 NEW_LINE print ( " Majority ▁ found ▁ : - ▁ " , i ) NEW_LINE break NEW_LINE DEDENT DEDENT if ( count == 0 ) : NEW_LINE INDENT print ( " No ▁ Majority ▁ element " ) NEW_LINE DEDENT DEDENT

BLEU: 60.8
Edit Sim: 131


Src: 
int knapSack ( int W , int wt [ ] , int val [ ] , int n ) { if ( n == 0 || W == 0 ) return 0 ; if ( wt [ n - 1 ] > W ) return knapSack ( W , wt , val , n - 1 ) ; else return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 ] , wt , val , n - 1 ) , knapSack ( W , wt , val , n - 1 ) ) ; }
Ref: 
def knapSack ( W , wt , val , n ) : NEW_LINE INDENT if n == 0 or W == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( wt [ n - 1 ] > W ) : NEW_LINE INDENT return knapSack ( W , wt , val , n - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 ] , wt , val , n - 1 ) , knapSack ( W , wt , val , n - 1 ) ) NEW_LINE DEDENT DEDENT
Hyp: 
def knapSack ( W , wt , val , n ) : NEW_LINE INDENT if n == 0 or W == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( wt [ n - 1 ] > W ) : NEW_LINE INDENT return knapSack ( W , wt , val , n - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 ] , wt , val , n - 1 ) , knapSack ( W , wt , val , n - 1 ) ) NEW_LINE DEDENT DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
void replaceOriginal ( string s , int n ) { string r ( n , ' ▁ ' ) ; for ( int i = 0 ; i < n ; i ++ ) { r [ i ] = s [ n - 1 - i ] ; if ( s [ i ] != ' a ' && s [ i ] != ' e ' && s [ i ] != ' i ' && s [ i ] != ' o ' && s [ i ] != ' u ' ) { cout << r [ i ] ; } } cout << endl ; }
Ref: 
def replaceOriginal ( s , n ) : NEW_LINE INDENT r = [ ' ▁ ' ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT r [ i ] = s [ n - 1 - i ] NEW_LINE if ( s [ i ] != ' a ' and s [ i ] != ' e ' and s [ i ] != ' i ' and s [ i ] != ' o ' and s [ i ] != ' u ' ) : NEW_LINE INDENT print ( r [ i ] , end = " " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT
Hyp: 
def replaceOriginal ( s , n ) : NEW_LINE INDENT r = string ( n , ' ▁ ' ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT r [ i ] = s [ n - 1 - i ] NEW_LINE if ( s [ i ] != ' a ' and s [ i ] != ' e ' and s [ i ] != ' i ' and s [ i ] != ' o ' and s [ i ] != ' u ' ) : NEW_LINE INDENT print ( r [ i ] , end = " " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT

BLEU: 90.46
Edit Sim: 17


Src: 
void findPair ( int arr [ ] , int n ) { unordered_set < int > s ; for ( int i = 0 ; i < n ; i ++ ) s . insert ( arr [ i ] ) ; bool found = false ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( s . find ( arr [ i ] + arr [ j ] ) != s . end ( ) ) { cout << arr [ i ] << " ▁ " << arr [ j ] << endl ; found = true ; } } } if ( found == false ) cout << " Not ▁ exist " << endl ; }
Ref: 
def findPair ( arr , n ) : NEW_LINE INDENT s = { i : 1 for i in arr } NEW_LINE found = False NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if arr [ i ] + arr [ j ] in s . keys ( ) : NEW_LINE INDENT print ( arr [ i ] , arr [ j ] ) NEW_LINE found = True NEW_LINE DEDENT DEDENT DEDENT if found == False : NEW_LINE INDENT print ( " Not ▁ exist " ) NEW_LINE DEDENT DEDENT
Hyp: 
def findPair ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . add ( arr [ i ] ) NEW_LINE DEDENT found = False NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if arr [ i ] + arr [ j ] in s : NEW_LINE INDENT print ( arr [ i ] , arr [ j ] ) NEW_LINE found = True NEW_LINE DEDENT DEDENT DEDENT if found == False : NEW_LINE INDENT print ( " Not ▁ exist " ) NEW_LINE DEDENT DEDENT

BLEU: 78.46
Edit Sim: 82


Src: 
int countNonEmptySubstr ( string str ) { int n = str . length ( ) ; return n * ( n + 1 ) / 2 ; }
Ref: 
def countNonEmptySubstr ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE return int ( n * ( n + 1 ) / 2 ) NEW_LINE DEDENT
Hyp: 
def countNonEmptySubstr ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE return ( n * ( n + 1 ) / 2 ) NEW_LINE DEDENT

BLEU: 91.28
Edit Sim: 4


Src: 
int countDigits ( int a , int b ) { int count = 0 ; int p = abs ( a * b ) ; if ( p == 0 ) return 1 ; while ( p > 0 ) { count ++ ; p = p / 10 ; } return count ; }
Ref: 
def countDigits ( a , b ) : NEW_LINE INDENT count = 0 NEW_LINE p = abs ( a * b ) NEW_LINE if ( p == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT while ( p > 0 ) : NEW_LINE INDENT count = count + 1 NEW_LINE p = p // 10 NEW_LINE DEDENT return count NEW_LINE DEDENT
Hyp: 
def countDigits ( a , b ) : NEW_LINE INDENT count = 0 NEW_LINE p = abs ( a * b ) NEW_LINE if ( p == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT while ( p > 0 ) : NEW_LINE INDENT count += 1 NEW_LINE p = p // 10 NEW_LINE DEDENT return count NEW_LINE DEDENT

BLEU: 92.6
Edit Sim: 9


Src: 
int maxProfit ( int price [ ] , int n ) { int * profit = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) profit [ i ] = 0 ; int max_price = price [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( price [ i ] > max_price ) max_price = price [ i ] ; profit [ i ] = max ( profit [ i + 1 ] , max_price - price [ i ] ) ; } int min_price = price [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( price [ i ] < min_price ) min_price = price [ i ] ; profit [ i ] = max ( profit [ i - 1 ] , profit [ i ] + ( price [ i ] - min_price ) ) ; } int result = profit [ n - 1 ] ; delete [ ] profit ; return result ; }
Ref: 
def maxProfit ( price , n ) : NEW_LINE INDENT profit = [ 0 ] * n NEW_LINE max_price = price [ n - 1 ] NEW_LINE for i in range ( n - 2 , 0 , - 1 ) : NEW_LINE INDENT if price [ i ] > max_price : NEW_LINE INDENT max_price = price [ i ] NEW_LINE DEDENT profit [ i ] = max ( profit [ i + 1 ] , max_price - price [ i ] ) NEW_LINE DEDENT min_price = price [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if price [ i ] < min_price : NEW_LINE INDENT min_price = price [ i ] NEW_LINE DEDENT profit [ i ] = max ( profit [ i - 1 ] , profit [ i ] + ( price [ i ] - min_price ) ) NEW_LINE DEDENT result = profit [ n - 1 ] NEW_LINE return result NEW_LINE DEDENT
Hyp: 
def maxProfit ( price , n ) : NEW_LINE INDENT profit = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT profit [ i ] = 0 NEW_LINE DEDENT max_price = price [ n - 1 ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( price [ i ] > max_price ) : NEW_LINE INDENT max_price = price [ i ] NEW_LINE DEDENT profit [ i ] = max ( profit [ i + 1 ] , max_price - price [ i ] ) NEW_LINE DEDENT min_price = price [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( price [ i ] < min_price ) : NEW_LINE INDENT min_price = price [ i ] NEW_LINE DEDENT profit [ i ] = max ( profit [ i - 1 ] , profit [ i ] + ( price [ i ] - min_price ) ) NEW_LINE DEDENT result = profit [ n - 1 ] NEW_LINE delete [ profit ] NEW_LINE return result NEW_LINE DEDENT

BLEU: 80.14
Edit Sim: 110


Src: 
int countDer ( int n ) { int der [ n + 1 ] ; der [ 0 ] = 1 ; der [ 1 ] = 0 ; der [ 2 ] = 1 ; for ( int i = 3 ; i <= n ; ++ i ) der [ i ] = ( i - 1 ) * ( der [ i - 1 ] + der [ i - 2 ] ) ; return der [ n ] ; }
Ref: 
def countDer ( n ) : NEW_LINE INDENT der = [ 0 for i in range ( n + 1 ) ] NEW_LINE der [ 0 ] = 1 NEW_LINE der [ 1 ] = 0 NEW_LINE der [ 2 ] = 1 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT der [ i ] = ( i - 1 ) * ( der [ i - 1 ] + der [ i - 2 ] ) NEW_LINE DEDENT return der [ n ] NEW_LINE DEDENT
Hyp: 
def countDer ( n ) : NEW_LINE INDENT der = [ 0 ] * ( n + 1 ) NEW_LINE der [ 0 ] = 1 NEW_LINE der [ 1 ] = 0 NEW_LINE der [ 2 ] = 1 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT der [ i ] = ( i - 1 ) * ( der [ i - 1 ] + der [ i - 2 ] ) NEW_LINE DEDENT return der [ n ] NEW_LINE DEDENT

BLEU: 91.51
Edit Sim: 15


Src: 
int findMaxPath ( int mat [ ] [ M ] ) { for ( int i = 1 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { if ( j > 0 && j < M - 1 ) mat [ i ] [ j ] += max ( mat [ i - 1 ] [ j ] , max ( mat [ i - 1 ] [ j - 1 ] , mat [ i - 1 ] [ j + 1 ] ) ) ; else if ( j > 0 ) mat [ i ] [ j ] += max ( mat [ i - 1 ] [ j ] , mat [ i - 1 ] [ j - 1 ] ) ; else if ( j < M - 1 ) mat [ i ] [ j ] += max ( mat [ i - 1 ] [ j ] , mat [ i - 1 ] [ j + 1 ] ) ; } } int res = 0 ; for ( int j = 0 ; j < M ; j ++ ) res = max ( mat [ N - 1 ] [ j ] , res ) ; return res ; }
Ref: 
def findMaxPath ( mat ) : NEW_LINE INDENT res = - 1 NEW_LINE for i in range ( M ) : NEW_LINE INDENT res = max ( res , mat [ 0 ] [ i ] ) NEW_LINE DEDENT for i in range ( 1 , N ) : NEW_LINE INDENT res = - 1 NEW_LINE for j in range ( M ) : NEW_LINE INDENT if ( j > 0 and j < M - 1 ) : NEW_LINE INDENT mat [ i ] [ j ] += max ( mat [ i - 1 ] [ j ] , max ( mat [ i - 1 ] [ j - 1 ] , mat [ i - 1 ] [ j + 1 ] ) ) NEW_LINE DEDENT elif ( j > 0 ) : NEW_LINE INDENT mat [ i ] [ j ] += max ( mat [ i - 1 ] [ j ] , mat [ i - 1 ] [ j - 1 ] ) NEW_LINE DEDENT elif ( j < M - 1 ) : NEW_LINE INDENT mat [ i ] [ j ] += max ( mat [ i - 1 ] [ j ] , mat [ i - 1 ] [ j + 1 ] ) NEW_LINE DEDENT res = max ( mat [ i ] [ j ] , res ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
Hyp: 
def findMaxPath ( mat ) : NEW_LINE INDENT for i in range ( 1 , N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT if ( j > 0 and j < M - 1 ) : NEW_LINE INDENT mat [ i ] [ j ] += max ( mat [ i - 1 ] [ j ] , max ( mat [ i - 1 ] [ j - 1 ] , mat [ i - 1 ] [ j + 1 ] ) ) NEW_LINE DEDENT elif ( j > 0 ) : NEW_LINE INDENT mat [ i ] [ j ] += max ( mat [ i - 1 ] [ j ] , mat [ i - 1 ] [ j - 1 ] ) NEW_LINE DEDENT elif ( j < M - 1 ) : NEW_LINE INDENT mat [ i ] [ j ] += max ( mat [ i - 1 ] [ j ] , mat [ i - 1 ] [ j + 1 ] ) NEW_LINE DEDENT DEDENT DEDENT res = 0 NEW_LINE for j in range ( M ) : NEW_LINE INDENT res = max ( mat [ N - 1 ] [ j ] , res ) NEW_LINE DEDENT return res NEW_LINE DEDENT

BLEU: 86.21
Edit Sim: 211


Src: 
bool checkIsAP ( int arr [ ] , int n ) { if ( n == 1 ) return true ; sort ( arr , arr + n ) ; int d = arr [ 1 ] - arr [ 0 ] ; for ( int i = 2 ; i < n ; i ++ ) if ( arr [ i ] - arr [ i - 1 ] != d ) return false ; return true ; }
Ref: 
def checkIsAP ( arr , n ) : NEW_LINE INDENT if ( n == 1 ) : return True NEW_LINE arr . sort ( ) NEW_LINE d = arr [ 1 ] - arr [ 0 ] NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT if ( arr [ i ] - arr [ i - 1 ] != d ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
Hyp: 
def checkIsAP ( arr , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT arr . sort ( ) NEW_LINE d = arr [ 1 ] - arr [ 0 ] NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT if ( arr [ i ] - arr [ i - 1 ] != d ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT

BLEU: 92.46
Edit Sim: 23


Src: 
int check ( string str ) { int n = str . length ( ) ; int oddDigSum = 0 , evenDigSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) oddDigSum += ( str [ i ] - '0' ) ; else evenDigSum += ( str [ i ] - '0' ) ; } return ( ( oddDigSum - evenDigSum ) % 11 == 0 ) ; }
Ref: 
def check ( st ) : NEW_LINE INDENT n = len ( st ) NEW_LINE oddDigSum = 0 NEW_LINE evenDigSum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT oddDigSum = oddDigSum + ( ( int ) ( st [ i ] ) ) NEW_LINE DEDENT else : NEW_LINE INDENT evenDigSum = evenDigSum + ( ( int ) ( st [ i ] ) ) NEW_LINE DEDENT DEDENT return ( ( oddDigSum - evenDigSum ) % 11 == 0 ) NEW_LINE DEDENT
Hyp: 
def check ( st ) : NEW_LINE INDENT n = len ( st ) NEW_LINE oddDigSum = 0 NEW_LINE evenDigSum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT oddDigSum = oddDigSum + ( ord ( st [ i ] ) - ord ( '0' ) ) NEW_LINE DEDENT else : NEW_LINE INDENT evenDigSum = evenDigSum + ( ord ( st [ i ] ) - ord ( '0' ) ) NEW_LINE DEDENT DEDENT return ( ( oddDigSum - evenDigSum ) % 11 == 0 ) NEW_LINE DEDENT

BLEU: 81.54
Edit Sim: 42


Src: 
void swap ( int * xp , int * yp ) { * xp = * xp ^ * yp ; * yp = * xp ^ * yp ; * xp = * xp ^ * yp ; }
Ref: 
def swap ( xp , yp ) : NEW_LINE INDENT xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] NEW_LINE yp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] NEW_LINE xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] NEW_LINE DEDENT
Hyp: 
def swap ( xp , yp ) : NEW_LINE INDENT xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] NEW_LINE yp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] NEW_LINE xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int find_Area ( int r ) { return ( 2 * r * r ) ; }
Ref: 
def find_Area ( r ) : NEW_LINE INDENT return ( 2 * r * r ) NEW_LINE DEDENT
Hyp: 
def find_Area ( r ) : NEW_LINE INDENT return ( 2 * r * r ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
bool isLucky ( int n ) { bool arr [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) arr [ i ] = false ; while ( n > 0 ) { int digit = n % 10 ; if ( arr [ digit ] ) return false ; arr [ digit ] = true ; n = n / 10 ; } return true ; }
Ref: 
def isLucky ( n ) : NEW_LINE INDENT ar = [ 0 ] * 10 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT digit = math . floor ( n % 10 ) NEW_LINE if ( ar [ digit ] ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ar [ digit ] = 1 NEW_LINE n = n / 10 NEW_LINE DEDENT return 1 NEW_LINE DEDENT
Hyp: 
def isLucky ( n ) : NEW_LINE INDENT arr = [ False ] * 10 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT arr [ i ] = False NEW_LINE DEDENT while ( n > 0 ) : NEW_LINE INDENT digit = n % 10 NEW_LINE if ( arr [ digit ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT arr [ digit ] = True NEW_LINE n = int ( n / 10 ) NEW_LINE DEDENT return True NEW_LINE DEDENT

BLEU: 44.72
Edit Sim: 109


Src: 
void countWaysToJump ( int arr [ ] , int n ) { int count_jump [ n ] ; memset ( count_jump , 0 , sizeof ( count_jump ) ) ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] >= n - i - 1 ) count_jump [ i ] ++ ; for ( int j = i + 1 ; j < n - 1 && j <= arr [ i ] + i ; j ++ ) if ( count_jump [ j ] != - 1 ) count_jump [ i ] += count_jump [ j ] ; if ( count_jump [ i ] == 0 ) count_jump [ i ] = - 1 ; } for ( int i = 0 ; i < n ; i ++ ) cout << count_jump [ i ] << " ▁ " ; }
Ref: 
def countWaysToJump ( arr , n ) : NEW_LINE INDENT count_jump = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] >= n - i - 1 ) : NEW_LINE INDENT count_jump [ i ] += 1 NEW_LINE DEDENT j = i + 1 NEW_LINE while ( j < n - 1 and j <= arr [ i ] + i ) : NEW_LINE INDENT if ( count_jump [ j ] != - 1 ) : NEW_LINE INDENT count_jump [ i ] += count_jump [ j ] NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if ( count_jump [ i ] == 0 ) : NEW_LINE INDENT count_jump [ i ] = - 1 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( count_jump [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
Hyp: 
def countWaysToJump ( arr , n ) : NEW_LINE INDENT count_jump = [ 0 ] * n NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] >= n - i - 1 ) : NEW_LINE INDENT count_jump [ i ] += 1 NEW_LINE DEDENT for j in range ( i + 1 , n - 1 , + 1 ) : NEW_LINE INDENT if ( count_jump [ j ] != - 1 ) : NEW_LINE INDENT count_jump [ i ] += count_jump [ j ] NEW_LINE DEDENT DEDENT if ( count_jump [ i ] == 0 ) : NEW_LINE INDENT count_jump [ i ] = - 1 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( count_jump [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT

BLEU: 77.39
Edit Sim: 78


Src: 
void zodiac_sign ( int day , string month ) { string astro_sign = " " ; if ( month == " december " ) { if ( day < 22 ) astro_sign = " Sagittarius " ; else astro_sign = " capricorn " ; } else if ( month == " january " ) { if ( day < 20 ) astro_sign = " Capricorn " ; else astro_sign = " aquarius " ; } else if ( month == " february " ) { if ( day < 19 ) astro_sign = " Aquarius " ; else astro_sign = " pisces " ; } else if ( month == " march " ) { if ( day < 21 ) astro_sign = " Pisces " ; else astro_sign = " aries " ; } else if ( month == " april " ) { if ( day < 20 ) astro_sign = " Aries " ; else astro_sign = " taurus " ; } else if ( month == " may " ) { if ( day < 21 ) astro_sign = " Taurus " ; else astro_sign = " gemini " ; } else if ( month == " june " ) { if ( day < 21 ) astro_sign = " Gemini " ; else astro_sign = " cancer " ; } else if ( month == " july " ) { if ( day < 23 ) astro_sign = " Cancer " ; else astro_sign = " leo " ; } else if ( month == " august " ) { if ( day < 23 ) astro_sign = " Leo " ; else astro_sign = " virgo " ; } else if ( month == " september " ) { if ( day < 23 ) astro_sign = " Virgo " ; else astro_sign = " libra " ; } else if ( month == " october " ) { if ( day < 23 ) astro_sign = " Libra " ; else astro_sign = " scorpio " ; } else if ( month == " november " ) { if ( day < 22 ) astro_sign = " scorpio " ; else astro_sign = " sagittarius " ; } cout << astro_sign ; }
Ref: 
def zodiac_sign ( day , month ) : NEW_LINE INDENT if month == ' december ' : NEW_LINE INDENT astro_sign = ' Sagittarius ' if ( day < 22 ) else ' capricorn ' NEW_LINE DEDENT elif month == ' january ' : NEW_LINE INDENT astro_sign = ' Capricorn ' if ( day < 20 ) else ' aquarius ' NEW_LINE DEDENT elif month == ' february ' : NEW_LINE INDENT astro_sign = ' Aquarius ' if ( day < 19 ) else ' pisces ' NEW_LINE DEDENT elif month == ' march ' : NEW_LINE INDENT astro_sign = ' Pisces ' if ( day < 21 ) else ' aries ' NEW_LINE DEDENT elif month == ' april ' : NEW_LINE INDENT astro_sign = ' Aries ' if ( day < 20 ) else ' taurus ' NEW_LINE DEDENT elif month == ' may ' : NEW_LINE INDENT astro_sign = ' Taurus ' if ( day < 21 ) else ' gemini ' NEW_LINE DEDENT elif month == ' june ' : NEW_LINE INDENT astro_sign = ' Gemini ' if ( day < 21 ) else ' cancer ' NEW_LINE DEDENT elif month == ' july ' : NEW_LINE INDENT astro_sign = ' Cancer ' if ( day < 23 ) else ' leo ' NEW_LINE DEDENT elif month == ' august ' : NEW_LINE INDENT astro_sign = ' Leo ' if ( day < 23 ) else ' virgo ' NEW_LINE DEDENT elif month == ' september ' : NEW_LINE INDENT astro_sign = ' Virgo ' if ( day < 23 ) else ' libra ' NEW_LINE DEDENT elif month == ' october ' : NEW_LINE INDENT astro_sign = ' Libra ' if ( day < 23 ) else ' scorpio ' NEW_LINE DEDENT elif month == ' november ' : NEW_LINE INDENT astro_sign = ' scorpio ' if ( day < 22 ) else ' sagittarius ' NEW_LINE DEDENT print ( astro_sign ) NEW_LINE DEDENT
Hyp: 
def zodiac_sign ( day , month ) : NEW_LINE INDENT astro_sign = " " NEW_LINE if ( month == " december " ) : NEW_LINE INDENT if ( day < 22 ) : NEW_LINE INDENT astro_sign = " Sagittarius " NEW_LINE DEDENT else : NEW_LINE INDENT astro_sign = " capricorn " NEW_LINE DEDENT elif ( month == " january " ) : NEW_LINE INDENT if ( day < 20 ) : NEW_LINE INDENT astro_sign = " Capricorn " NEW_LINE DEDENT else : NEW_LINE INDENT astro_sign = " aquarius " NEW_LINE DEDENT elif ( month == " february " ) : NEW_LINE INDENT if ( day < 19 ) : NEW_LINE INDENT astro_sign = " Aquarius " NEW_LINE DEDENT else : NEW_LINE INDENT astro_sign = " Pisces " NEW_LINE DEDENT elif ( month == " march " ) : NEW_LINE INDENT if ( day < 21 ) : NEW_LINE INDENT astro_sign = " Aries " NEW_LINE DEDENT else : NEW_LINE INDENT astro_sign = " aries " NEW_LINE DEDENT elif ( month == " may " ) : NEW_LINE INDENT if ( day < 21 ) : NEW_LINE INDENT astro_sign = " Taurus " NEW_LINE DEDENT else : NEW_LINE INDENT astro_sign = " Gemini " NEW_LINE DEDENT elif ( month == " june " ) : NEW_LINE INDENT if ( day < 23 ) : NEW_LINE INDENT astro_sign = " Cancer " NEW_LINE DEDENT else : NEW_LINE INDENT astro_sign = " Leo " NEW_LINE DEDENT elif ( month == " august " ) : NEW_LINE INDENT if ( day < 23 ) : NEW_LINE INDENT astro_sign = " Virgo " NEW_LINE DEDENT else : NEW_LINE INDENT astro_sign = " Virgo " NEW_LINE DEDENT elif ( month == " september " ) : NEW_LINE INDENT if ( day < 23 ) : NEW_LINE INDENT astro_sign = " Libra " NEW_LINE DEDENT else : NEW_LINE INDENT astro_sign = "

BLEU: 32.59
Edit Sim: 808


Src: 
int countSol ( int coeff [ ] , int n , int rhs ) { int dp [ rhs + 1 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; dp [ 0 ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = coeff [ i ] ; j <= rhs ; j ++ ) dp [ j ] += dp [ j - coeff [ i ] ] ; return dp [ rhs ] ; }
Ref: 
def countSol ( coeff , n , rhs ) : NEW_LINE INDENT dp = [ 0 for i in range ( rhs + 1 ) ] NEW_LINE dp [ 0 ] = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( coeff [ i ] , rhs + 1 ) : NEW_LINE INDENT dp [ j ] += dp [ j - coeff [ i ] ] NEW_LINE DEDENT DEDENT return dp [ rhs ] NEW_LINE DEDENT
Hyp: 
def countSol ( coeff , n , rhs ) : NEW_LINE INDENT dp = [ 0 for i in range ( rhs + 1 ) ] NEW_LINE dp [ 0 ] = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( coeff [ i ] , rhs + 1 ) : NEW_LINE INDENT dp [ j ] += dp [ j - coeff [ i ] ] NEW_LINE DEDENT DEDENT return dp [ rhs ] NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
bool isSymmetric ( int mat [ ] [ MAX ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) return false ; return true ; }
Ref: 
def isSymmetric ( mat , N ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT
Hyp: 
def isSymmetric ( mat , N ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
bool isRectangle ( const vector < vector < int > > & m ) { int rows = m . size ( ) ; if ( rows == 0 ) return false ; int columns = m [ 0 ] . size ( ) ; for ( int y1 = 0 ; y1 < rows ; y1 ++ ) for ( int x1 = 0 ; x1 < columns ; x1 ++ ) if ( m [ y1 ] [ x1 ] == 1 ) for ( int y2 = y1 + 1 ; y2 < rows ; y2 ++ ) for ( int x2 = x1 + 1 ; x2 < columns ; x2 ++ ) if ( m [ y1 ] [ x2 ] == 1 && m [ y2 ] [ x1 ] == 1 && m [ y2 ] [ x2 ] == 1 ) return true ; return false ; }
Ref: 
def isRectangle ( m ) : NEW_LINE INDENT rows = len ( m ) NEW_LINE if ( rows == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT columns = len ( m [ 0 ] ) NEW_LINE for y1 in range ( rows ) : NEW_LINE INDENT for x1 in range ( columns ) : NEW_LINE INDENT if ( m [ y1 ] [ x1 ] == 1 ) : NEW_LINE INDENT for y2 in range ( y1 + 1 , rows ) : NEW_LINE INDENT for x2 in range ( x1 + 1 , columns ) : NEW_LINE INDENT if ( m [ y1 ] [ x2 ] == 1 and m [ y2 ] [ x1 ] == 1 and m [ y2 ] [ x2 ] == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT return False NEW_LINE DEDENT
Hyp: 
def isRectangle ( mat ) : NEW_LINE INDENT rows = len ( mat ) NEW_LINE if ( rows == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT columns = len ( mat [ 0 ] ) NEW_LINE for y1 in range ( rows ) : NEW_LINE INDENT for x1 in range ( columns ) : NEW_LINE INDENT if ( mat [ y1 ] [ x1 ] == 1 ) : NEW_LINE INDENT for y2 in range ( y1 + 1 , rows ) : NEW_LINE INDENT for x2 in range ( x1 + 1 , columns ) : NEW_LINE INDENT if ( mat [ y1 ] [ x2 ] == 1 and mat [ y2 ] [ x1 ] == 1 and mat [ y2 ] [ x2 ] == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT

BLEU: 85.97
Edit Sim: 35


Src: 
bool isDivBy9 ( int n ) { if ( n == 0 || n == 9 ) return true ; if ( n < 9 ) return false ; return isDivBy9 ( ( int ) ( n >> 3 ) - ( int ) ( n & 7 ) ) ; }
Ref: 
def isDivBy9 ( n ) : NEW_LINE INDENT if ( n == 0 or n == 9 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n < 9 ) : NEW_LINE INDENT return False NEW_LINE DEDENT return isDivBy9 ( ( int ) ( n >> 3 ) - ( int ) ( n & 7 ) ) NEW_LINE DEDENT
Hyp: 
def isDivBy9 ( n ) : NEW_LINE INDENT if ( n == 0 or n == 9 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n < 9 ) : NEW_LINE INDENT return False NEW_LINE DEDENT return isDivBy9 ( ( int ) ( n >> 3 ) - ( int ) ( n & 7 ) ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int knapSack ( int W , int wt [ ] , int val [ ] , int n ) { if ( n == 0 || W == 0 ) return 0 ; if ( wt [ n - 1 ] > W ) return knapSack ( W , wt , val , n - 1 ) ; else return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 ] , wt , val , n - 1 ) , knapSack ( W , wt , val , n - 1 ) ) ; }
Ref: 
def knapSack ( W , wt , val , n ) : NEW_LINE INDENT if n == 0 or W == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( wt [ n - 1 ] > W ) : NEW_LINE INDENT return knapSack ( W , wt , val , n - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 ] , wt , val , n - 1 ) , knapSack ( W , wt , val , n - 1 ) ) NEW_LINE DEDENT DEDENT
Hyp: 
def knapSack ( W , wt , val , n ) : NEW_LINE INDENT if n == 0 or W == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( wt [ n - 1 ] > W ) : NEW_LINE INDENT return knapSack ( W , wt , val , n - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 ] , wt , val , n - 1 ) , knapSack ( W , wt , val , n - 1 ) ) NEW_LINE DEDENT DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
void printRepeating ( int arr [ ] , int size ) { int Xor = arr [ 0 ] ; int set_bit_no ; int i ; int n = size - 2 ; int x = 0 , y = 0 ; for ( i = 1 ; i < size ; i ++ ) Xor ^= arr [ i ] ; for ( i = 1 ; i <= n ; i ++ ) Xor ^= i ; set_bit_no = Xor & ~ ( Xor - 1 ) ; for ( i = 0 ; i < size ; i ++ ) { if ( arr [ i ] & set_bit_no ) x = x ^ arr [ i ] ; else y = y ^ arr [ i ] ; } for ( i = 1 ; i <= n ; i ++ ) { if ( i & set_bit_no ) x = x ^ i ; else y = y ^ i ; } cout << " The ▁ two ▁ repeating ▁ elements ▁ are ▁ " << y << " ▁ " << x ; }
Ref: 
def printRepeating ( arr , size ) : NEW_LINE INDENT xor = arr [ 0 ] NEW_LINE n = size - 2 NEW_LINE x = 0 NEW_LINE y = 0 NEW_LINE for i in range ( 1 , size ) : NEW_LINE INDENT xor ^= arr [ i ] NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT xor ^= i NEW_LINE DEDENT set_bit_no = xor & ~ ( xor - 1 ) NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT if ( arr [ i ] & set_bit_no ) : NEW_LINE INDENT x = x ^ arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT y = y ^ arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( i & set_bit_no ) : NEW_LINE INDENT x = x ^ i NEW_LINE DEDENT else : NEW_LINE INDENT y = y ^ i NEW_LINE DEDENT DEDENT print ( " The ▁ two ▁ repeating " , " elements ▁ are " , y , x ) NEW_LINE DEDENT
Hyp: 
def printRepeating ( arr , size ) : NEW_LINE INDENT Xor = arr [ 0 ] NEW_LINE set_bit_no = 0 NEW_LINE x = 0 NEW_LINE y = 0 NEW_LINE for i in range ( 1 , size ) : NEW_LINE INDENT Xor ^= arr [ i ] NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT Xor ^= i NEW_LINE DEDENT set_bit_no = Xor & ~ ( Xor - 1 ) NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT if ( arr [ i ] & set_bit_no ) : NEW_LINE INDENT x = x ^ arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT y = y ^ arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( i & set_bit_no ) : NEW_LINE INDENT x = x ^ i NEW_LINE DEDENT else : NEW_LINE INDENT y = y ^ i NEW_LINE DEDENT DEDENT print ( " The ▁ two ▁ repeating ▁ elements ▁ are " , y , " ▁ " , x ) NEW_LINE DEDENT

BLEU: 88.05
Edit Sim: 29


Src: 
int findSubsequenceCount ( string S , string T ) { int m = T . length ( ) , n = S . length ( ) ; if ( m > n ) return 0 ; int mat [ m + 1 ] [ n + 1 ] ; for ( int i = 1 ; i <= m ; i ++ ) mat [ i ] [ 0 ] = 0 ; for ( int j = 0 ; j <= n ; j ++ ) mat [ 0 ] [ j ] = 1 ; for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( T [ i - 1 ] != S [ j - 1 ] ) mat [ i ] [ j ] = mat [ i ] [ j - 1 ] ; else mat [ i ] [ j ] = mat [ i ] [ j - 1 ] + mat [ i - 1 ] [ j - 1 ] ; } } return mat [ m ] [ n ] ; }
Ref: 
def findSubsequenceCount ( S , T ) : NEW_LINE INDENT m = len ( T ) NEW_LINE n = len ( S ) NEW_LINE if m > n : NEW_LINE INDENT return 0 NEW_LINE DEDENT mat = [ [ 0 for _ in range ( n + 1 ) ] for __ in range ( m + 1 ) ] NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT mat [ i ] [ 0 ] = 0 NEW_LINE DEDENT for j in range ( n + 1 ) : NEW_LINE INDENT mat [ 0 ] [ j ] = 1 NEW_LINE DEDENT for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if T [ i - 1 ] != S [ j - 1 ] : NEW_LINE INDENT mat [ i ] [ j ] = mat [ i ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT mat [ i ] [ j ] = ( mat [ i ] [ j - 1 ] + mat [ i - 1 ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return mat [ m ] [ n ] NEW_LINE DEDENT
Hyp: 
def findSubsequenceCount ( S , T ) : NEW_LINE INDENT m = len ( T ) NEW_LINE n = len ( S ) NEW_LINE if m > n : NEW_LINE INDENT return 0 NEW_LINE DEDENT mat = [ [ 0 for i in range ( n + 1 ) ] for j in range ( m + 1 ) ] NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT mat [ i ] [ 0 ] = 0 NEW_LINE DEDENT for j in range ( n + 1 ) : NEW_LINE INDENT mat [ 0 ] [ j ] = 1 NEW_LINE DEDENT for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if T [ i - 1 ] != S [ j - 1 ] : NEW_LINE INDENT mat [ i ] [ j ] = mat [ i ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT mat [ i ] [ j ] = mat [ i ] [ j - 1 ] + mat [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT return mat [ m ] [ n ] NEW_LINE DEDENT

BLEU: 95.45
Edit Sim: 7


Src: 
int breakSum ( int n ) { int dp [ n + 1 ] ; dp [ 0 ] = 0 , dp [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) dp [ i ] = max ( dp [ i / 2 ] + dp [ i / 3 ] + dp [ i / 4 ] , i ) ; return dp [ n ] ; }
Ref: 
def breakSum ( n ) : NEW_LINE INDENT dp = [ 0 ] * ( n + 1 ) NEW_LINE dp [ 0 ] = 0 NEW_LINE dp [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT dp [ i ] = max ( dp [ int ( i / 2 ) ] + dp [ int ( i / 3 ) ] + dp [ int ( i / 4 ) ] , i ) NEW_LINE DEDENT return dp [ n ] NEW_LINE DEDENT
Hyp: 
def breakSum ( n ) : NEW_LINE INDENT dp = [ 0 for _ in range ( n + 1 ) ] NEW_LINE dp [ 0 ] = 0 NEW_LINE dp [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i // 2 ] + dp [ i // 3 ] + dp [ i // 4 ] , i ) NEW_LINE DEDENT return dp [ n ] NEW_LINE DEDENT

BLEU: 72.54
Edit Sim: 39


Src: 
void decToHexa ( int n ) { char hexaDeciNum [ 100 ] ; int i = 0 ; while ( n != 0 ) { int temp = 0 ; temp = n % 16 ; if ( temp < 10 ) { hexaDeciNum [ i ] = temp + 48 ; i ++ ; } else { hexaDeciNum [ i ] = temp + 55 ; i ++ ; } n = n / 16 ; } for ( int j = i - 1 ; j >= 0 ; j -- ) cout << hexaDeciNum [ j ] ; }
Ref: 
def decToHexa ( n ) : NEW_LINE INDENT hexaDeciNum = [ '0' ] * 100 NEW_LINE i = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT temp = 0 NEW_LINE temp = n % 16 NEW_LINE if ( temp < 10 ) : NEW_LINE INDENT hexaDeciNum [ i ] = chr ( temp + 48 ) NEW_LINE i = i + 1 NEW_LINE DEDENT else : NEW_LINE INDENT hexaDeciNum [ i ] = chr ( temp + 55 ) NEW_LINE i = i + 1 NEW_LINE DEDENT n = int ( n / 16 ) NEW_LINE DEDENT j = i - 1 NEW_LINE while ( j >= 0 ) : NEW_LINE INDENT print ( ( hexaDeciNum [ j ] ) , end = " " ) NEW_LINE j = j - 1 NEW_LINE DEDENT DEDENT
Hyp: 
def decToHexa ( n ) : NEW_LINE INDENT hexaDeciNum = [ 0 ] * 100 NEW_LINE i = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT temp = 0 NEW_LINE temp = n % 16 NEW_LINE if ( temp < 10 ) : NEW_LINE INDENT hexaDeciNum [ i ] = temp + 48 NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT hexaDeciNum [ i ] = temp + 55 NEW_LINE i += 1 NEW_LINE DEDENT n = int ( n / 16 ) NEW_LINE DEDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( hexaDeciNum [ j ] , end = " " ) NEW_LINE DEDENT DEDENT

BLEU: 67.06
Edit Sim: 78


Src: 
int gcd ( int a , int b ) { if ( a == b ) return a ; if ( a == 0 ) return b ; if ( b == 0 ) return a ; if ( ~ a & 1 ) { if ( b & 1 ) return gcd ( a >> 1 , b ) ; else return gcd ( a >> 1 , b >> 1 ) << 1 ; } if ( ~ b & 1 ) return gcd ( a , b >> 1 ) ; if ( a > b ) return gcd ( ( a - b ) >> 1 , b ) ; return gcd ( ( b - a ) >> 1 , a ) ; }
Ref: 
def gcd ( a , b ) : NEW_LINE INDENT if ( a == b ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( ( ~ a & 1 ) == 1 ) : NEW_LINE INDENT if ( ( b & 1 ) == 1 ) : NEW_LINE INDENT return gcd ( a >> 1 , b ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( gcd ( a >> 1 , b >> 1 ) << 1 ) NEW_LINE DEDENT DEDENT if ( ( ~ b & 1 ) == 1 ) : NEW_LINE INDENT return gcd ( a , b >> 1 ) NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT return gcd ( ( a - b ) >> 1 , b ) NEW_LINE DEDENT return gcd ( ( b - a ) >> 1 , a ) NEW_LINE DEDENT
Hyp: 
def gcd ( a , b ) : NEW_LINE INDENT if a == b : NEW_LINE INDENT return a NEW_LINE DEDENT if b == 0 : NEW_LINE INDENT return b NEW_LINE DEDENT if ~ a & 1 : NEW_LINE INDENT if ( b & 1 ) : NEW_LINE INDENT return gcd ( a >> 1 , b ) NEW_LINE DEDENT else : NEW_LINE INDENT return gcd ( a >> 1 , b >> 1 ) << 1 NEW_LINE DEDENT DEDENT if ( ~ b & 1 ) : NEW_LINE INDENT return gcd ( a , b >> 1 ) NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT return gcd ( ( a - b ) >> 1 , b ) NEW_LINE DEDENT return gcd ( ( b - a ) >> 1 , a ) NEW_LINE DEDENT

BLEU: 70.87
Edit Sim: 101


Src: 
bool oppositeSigns ( int x , int y ) { return ( ( x ^ y ) < 0 ) ; }
Ref: 
def oppositeSigns ( x , y ) : NEW_LINE INDENT return ( ( x ^ y ) < 0 ) NEW_LINE DEDENT
Hyp: 
def oppositeSigns ( x , y ) : NEW_LINE INDENT return ( ( x ^ y ) < 0 ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
bool arraySortedOrNot ( int arr [ ] , int n ) { if ( n == 0 || n == 1 ) return true ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i - 1 ] > arr [ i ] ) return false ; return true ; }
Ref: 
def arraySortedOrNot ( arr , n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i - 1 ] > arr [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
Hyp: 
def arraySortedOrNot ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE if n == 0 or n == 1 : NEW_LINE INDENT return True NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if arr [ i - 1 ] > arr [ i ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT

BLEU: 77.26
Edit Sim: 35


Src: 
void strToBinary ( string s ) { int n = s . length ( ) ; for ( int i = 0 ; i <= n ; i ++ ) { int val = int ( s [ i ] ) ; string bin = " " ; while ( val > 0 ) { ( val % 2 ) ? bin . push_back ( '1' ) : bin . push_back ( '0' ) ; val /= 2 ; } reverse ( bin . begin ( ) , bin . end ( ) ) ; cout << bin << " ▁ " ; } }
Ref: 
def strToBinary ( s ) : NEW_LINE INDENT bin_conv = [ ] NEW_LINE for c in s : NEW_LINE INDENT ascii_val = ord ( c ) NEW_LINE binary_val = bin ( ascii_val ) NEW_LINE bin_conv . append ( binary_val [ 2 : ] ) NEW_LINE DEDENT return ( ' ▁ ' . join ( bin_conv ) ) NEW_LINE DEDENT
Hyp: 
def strToBinary ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT val = int ( s [ i ] ) NEW_LINE bin = " " NEW_LINE while ( val > 0 ) : NEW_LINE INDENT ( val % 2 ) : NEW_LINE INDENT bin . append ( '1' ) NEW_LINE DEDENT else : NEW_LINE INDENT bin . append ( '0' ) NEW_LINE val //= 2 NEW_LINE DEDENT DEDENT bin = ' ' . join ( bin ) NEW_LINE DEDENT

BLEU: 18.99
Edit Sim: 196


Src: 
void evaluate ( long long int n ) { if ( n == 1 || n == 2 ) printf ( " No ▁ Pythagoras ▁ Triplet ▁ exists " ) ; else if ( n % 2 == 0 ) { long long int var = 1LL * n * n / 4 ; printf ( " Pythagoras ▁ Triplets ▁ exist ▁ i . e . ▁ " ) ; printf ( " % lld ▁ % lld ▁ % lld " , n , var - 1 , var + 1 ) ; } else if ( n % 2 != 0 ) { long long int var = 1LL * n * n + 1 ; printf ( " Pythagoras ▁ Triplets ▁ exist ▁ i . e . ▁ " ) ; printf ( " % lld ▁ % lld ▁ % lld " , n , var / 2 - 1 , var / 2 ) ; } }
Ref: 
def evaluate ( n ) : NEW_LINE INDENT if ( n == 1 or n == 2 ) : NEW_LINE INDENT print ( " No ▁ Pythagoras " + " ▁ Triplet ▁ exists " ) NEW_LINE DEDENT elif ( n % 2 == 0 ) : NEW_LINE INDENT var = n * n / 4 NEW_LINE print ( " Pythagoras ▁ Triplets " + " ▁ exist ▁ i . e . ▁ " , end = " " ) NEW_LINE print ( int ( n ) , " ▁ " , int ( var - 1 ) , " ▁ " , int ( var + 1 ) ) NEW_LINE DEDENT elif ( n % 2 != 0 ) : NEW_LINE INDENT var = n * n + 1 NEW_LINE print ( " Pythagoras ▁ Triplets ▁ " + " exist ▁ i . e . ▁ " , end = " " ) NEW_LINE print ( int ( n ) , " ▁ " , int ( var / 2 - 1 ) , " ▁ " , int ( var / 2 ) ) NEW_LINE DEDENT DEDENT
Hyp: 
def evaluate ( n ) : NEW_LINE INDENT if ( n == 1 or n == 2 ) : NEW_LINE INDENT print ( " No ▁ Pythagoras ▁ Triplet ▁ exists " ) NEW_LINE DEDENT elif ( n % 2 == 0 ) : NEW_LINE INDENT var = 1LL * n * n // 4 NEW_LINE print ( " Pythagoras ▁ Triplets ▁ exist ▁ i . e . ▁ " ) NEW_LINE print ( " % lld ▁ % lld " , n , var - 1 , var + 1 ) NEW_LINE DEDENT elif ( n % 2 != 0 ) : NEW_LINE INDENT var = 1LL * n * n + 1 NEW_LINE print ( " Pythagoras ▁ Triplets ▁ exist ▁ i . e . ▁ " ) NEW_LINE print ( " % lld ▁ % lld " , n , var // 2 - 1 , var // 2 ) NEW_LINE DEDENT DEDENT

BLEU: 57.38
Edit Sim: 121


Src: 
bool isOverflow ( long long a , long long b ) { if ( a == 0 || b == 0 ) return false ; long long result = a * b ; if ( a == result / b ) return false ; else return true ; }
Ref: 
def isOverflow ( a , b ) : NEW_LINE INDENT if ( a == 0 or b == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT result = a * b NEW_LINE if ( result >= 9223372036854775807 or result <= - 9223372036854775808 ) : NEW_LINE INDENT result = 0 NEW_LINE DEDENT if ( a == ( result // b ) ) : NEW_LINE INDENT print ( result // b ) NEW_LINE return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT
Hyp: 
def isOverflow ( a , b ) : NEW_LINE INDENT if ( a == 0 or b == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT result = a * b NEW_LINE if ( a == result / b ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT

BLEU: 55.03
Edit Sim: 153


Src: 
bool findDuplicateparenthesis ( string str ) { stack < char > Stack ; for ( char ch : str ) { if ( ch == ' ) ' ) { char top = Stack . top ( ) ; Stack . pop ( ) ; int elementsInside = 0 ; while ( top != ' ( ' ) { elementsInside ++ ; top = Stack . top ( ) ; Stack . pop ( ) ; } if ( elementsInside < 1 ) { return 1 ; } } else Stack . push ( ch ) ; } return false ; }
Ref: 
def findDuplicateparenthesis ( string ) : NEW_LINE INDENT Stack = [ ] NEW_LINE for ch in string : NEW_LINE INDENT if ch == ' ) ' : NEW_LINE INDENT top = Stack . pop ( ) NEW_LINE elementsInside = 0 NEW_LINE while top != ' ( ' : NEW_LINE INDENT elementsInside += 1 NEW_LINE top = Stack . pop ( ) NEW_LINE DEDENT if elementsInside < 1 : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT Stack . append ( ch ) NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
Hyp: 
def findDuplicateparenthesis ( str ) : NEW_LINE INDENT Stack = [ ] NEW_LINE for ch in str : NEW_LINE INDENT if ( ch == ' ) ' ) : NEW_LINE INDENT top = Stack [ - 1 ] NEW_LINE Stack . pop ( ) NEW_LINE elementsInside = 0 NEW_LINE while ( top != ' ( ' ) : NEW_LINE INDENT elementsInside += 1 NEW_LINE top = Stack [ - 1 ] NEW_LINE Stack . pop ( ) NEW_LINE DEDENT if ( elementsInside < 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT Stack . append ( ch ) NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT

BLEU: 66.09
Edit Sim: 68


Src: 
int countRotations ( string n ) { int len = n . length ( ) ; if ( len == 1 ) { int oneDigit = n . at ( 0 ) - '0' ; if ( oneDigit % 4 == 0 ) return 1 ; return 0 ; } int twoDigit , count = 0 ; for ( int i = 0 ; i < ( len - 1 ) ; i ++ ) { twoDigit = ( n . at ( i ) - '0' ) * 10 + ( n . at ( i + 1 ) - '0' ) ; if ( twoDigit % 4 == 0 ) count ++ ; } twoDigit = ( n . at ( len - 1 ) - '0' ) * 10 + ( n . at ( 0 ) - '0' ) ; if ( twoDigit % 4 == 0 ) count ++ ; return count ; }
Ref: 
def countRotations ( n ) : NEW_LINE INDENT l = len ( n ) NEW_LINE if ( l == 1 ) : NEW_LINE INDENT oneDigit = ( int ) ( n [ 0 ] ) NEW_LINE if ( oneDigit % 4 == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( 0 , l - 1 ) : NEW_LINE INDENT twoDigit = ( int ) ( n [ i ] ) * 10 + ( int ) ( n [ i + 1 ] ) NEW_LINE if ( twoDigit % 4 == 0 ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT twoDigit = ( int ) ( n [ l - 1 ] ) * 10 + ( int ) ( n [ 0 ] ) NEW_LINE if ( twoDigit % 4 == 0 ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
Hyp: 
def countRotations ( n ) : NEW_LINE INDENT l = len ( n ) NEW_LINE if ( l == 1 ) : NEW_LINE INDENT oneDigit = ord ( n [ 0 ] ) - ord ( '0' ) NEW_LINE if ( oneDigit % 4 == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT twoDigit = 0 NEW_LINE count = 0 NEW_LINE for i in range ( 0 , ( l - 1 ) ) : NEW_LINE INDENT twoDigit = ( ord ( n [ i ] ) - ord ( '0' ) ) * 10 + ( ord ( n [ i + 1 ] ) - ord ( '0' ) ) NEW_LINE if ( twoDigit % 4 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT twoDigit = ( ord ( n [ l - 1 ] ) - ord ( '0' ) ) * 10 + ( ord ( n [ 0 ] ) - ord ( '0' ) ) NEW_LINE if ( twoDigit % 4 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT

BLEU: 67.94
Edit Sim: 153


Src: 
void findTriplets ( int x ) { vector < int > fact ; unordered_set < int > factors ; for ( int i = 2 ; i <= sqrt ( x ) ; i ++ ) { if ( x % i == 0 ) { fact . push_back ( i ) ; if ( x / i != i ) fact . push_back ( x / i ) ; factors . insert ( i ) ; factors . insert ( x / i ) ; } } bool found = false ; int k = fact . size ( ) ; for ( int i = 0 ; i < k ; i ++ ) { int a = fact [ i ] ; for ( int j = 0 ; j < k ; j ++ ) { int b = fact [ j ] ; if ( ( a != b ) && ( x % ( a * b ) == 0 ) && ( x / ( a * b ) != a ) && ( x / ( a * b ) != b ) && ( x / ( a * b ) != 1 ) ) { cout << a << " ▁ " << b << " ▁ " << ( x / ( a * b ) ) ; found = true ; break ; } } if ( found ) break ; } if ( ! found ) cout << " - 1" ; }
Ref: 
def findTriplets ( x ) : NEW_LINE INDENT fact = [ ] NEW_LINE factors = set ( ) NEW_LINE for i in range ( 2 , int ( sqrt ( x ) ) ) : NEW_LINE INDENT if ( x % i == 0 ) : NEW_LINE INDENT fact . append ( i ) NEW_LINE if ( x / i != i ) : NEW_LINE INDENT fact . append ( x // i ) NEW_LINE DEDENT factors . add ( i ) NEW_LINE factors . add ( x // i ) NEW_LINE DEDENT DEDENT found = False NEW_LINE k = len ( fact ) NEW_LINE for i in range ( k ) : NEW_LINE INDENT a = fact [ i ] NEW_LINE for j in range ( k ) : NEW_LINE INDENT b = fact [ j ] NEW_LINE if ( ( a != b ) and ( x % ( a * b ) == 0 ) and ( x / ( a * b ) != a ) and ( x / ( a * b ) != b ) and ( x / ( a * b ) != 1 ) ) : NEW_LINE INDENT print ( a , b , x // ( a * b ) ) NEW_LINE found = True NEW_LINE break NEW_LINE DEDENT DEDENT if ( found ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( not found ) : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT DEDENT
Hyp: 
def findTriplets ( x ) : NEW_LINE INDENT fact = [ ] NEW_LINE factors = [ ] NEW_LINE for i in range ( 2 , int ( m . sqrt ( x ) + 1 ) ) : NEW_LINE INDENT if ( x % i == 0 ) : NEW_LINE INDENT fact . append ( i ) NEW_LINE if ( x / i != i ) : NEW_LINE INDENT fact . append ( x / i ) NEW_LINE DEDENT factors . append ( i ) NEW_LINE DEDENT factors . append ( x / i ) NEW_LINE DEDENT found = False NEW_LINE k = len ( fact ) NEW_LINE for i in range ( 0 , k ) : NEW_LINE INDENT a = fact [ i ] NEW_LINE for j in range ( 0 , k ) : NEW_LINE INDENT b = fact [ j ] NEW_LINE if ( ( a != b ) and ( x % ( a * b ) == 0 ) and ( x / ( a * b ) != a ) and ( x / ( a * b ) != b ) and ( x / ( a * b ) != 1 ) ) : NEW_LINE INDENT print ( a , " ▁ " , b , " ▁ " , ( x / ( a * b ) ) , found = True NEW_LINE break NEW_LINE DEDENT DEDENT if ( found ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( not found ) : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT DEDENT

BLEU: 82.66
Edit Sim: 73


Src: 
void findCombinations ( string str , int index , string out ) { if ( index == str . length ( ) ) cout << out << endl ; for ( int i = index ; i < str . length ( ) ; i ++ ) findCombinations ( str , i + 1 , out + " ( " + str . substr ( index , i + 1 - index ) + " ) " ) ; }
Ref: 
def findCombinations ( string , index , out ) : NEW_LINE INDENT if index == len ( string ) : NEW_LINE INDENT print ( out ) NEW_LINE DEDENT for i in range ( index , len ( string ) , 1 ) : NEW_LINE INDENT findCombinations ( string , i + 1 , out + " ( " + string [ index : i + 1 ] + " ) " ) NEW_LINE DEDENT DEDENT
Hyp: 
def findCombinations ( str , index , out ) : NEW_LINE INDENT if ( index == len ( str ) ) : NEW_LINE INDENT print ( out ) NEW_LINE DEDENT for i in range ( index , len ( str ) ) : NEW_LINE INDENT findCombinations ( str , i + 1 , out + " ( " + str [ index : i + 1 - index ] + " ) " ) NEW_LINE DEDENT DEDENT

BLEU: 72.53
Edit Sim: 29


Src: 
int search ( int arr [ ] , int n , int x ) { int i = 0 ; while ( i <= n - 1 ) { if ( arr [ i ] == x ) return i ; i += abs ( arr [ i ] - x ) ; } return - 1 ; }
Ref: 
def search ( arr , n , x ) : NEW_LINE INDENT i = 0 NEW_LINE while ( i <= n - 1 ) : NEW_LINE INDENT if ( arr [ i ] == x ) : NEW_LINE INDENT return i NEW_LINE DEDENT i += abs ( arr [ i ] - x ) NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
Hyp: 
def search ( arr , n , x ) : NEW_LINE INDENT i = 0 NEW_LINE while ( i <= n ) : NEW_LINE INDENT if ( arr [ i ] == x ) : NEW_LINE INDENT return i NEW_LINE DEDENT i += abs ( arr [ i ] - x ) NEW_LINE DEDENT return - 1 NEW_LINE DEDENT

BLEU: 94.13
Edit Sim: 4


Src: 
void findMissing ( int a [ ] , int b [ ] , int n , int m ) { unordered_set < int > s ; for ( int i = 0 ; i < m ; i ++ ) s . insert ( b [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) if ( s . find ( a [ i ] ) == s . end ( ) ) cout << a [ i ] << " ▁ " ; }
Ref: 
def findMissing ( a , b , n , m ) : NEW_LINE INDENT s = dict ( ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT s [ b [ i ] ] = 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if a [ i ] not in s . keys ( ) : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
Hyp: 
def findMissing ( a , b , n , m ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT s . add ( b [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] not in s ) : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT

BLEU: 81.61
Edit Sim: 24


Src: 
int countPairs ( string str ) { int result = 0 ; int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 1 ; ( i + j ) < n && j <= MAX_CHAR ; j ++ ) if ( ( abs ( str [ i + j ] - str [ i ] ) == j ) ) result ++ ; return result ; }
Ref: 
def countPairs ( str1 ) : NEW_LINE INDENT result = 0 ; NEW_LINE n = len ( str1 ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 1 , MAX_CHAR + 1 ) : NEW_LINE INDENT if ( ( i + j ) < n ) : NEW_LINE INDENT if ( ( abs ( ord ( str1 [ i + j ] ) - ord ( str1 [ i ] ) ) == j ) ) : NEW_LINE INDENT result += 1 ; NEW_LINE DEDENT DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
Hyp: 
def countPairs ( str ) : NEW_LINE INDENT result = 0 NEW_LINE n = len ( str ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 1 , MAX_CHAR + 1 ) : NEW_LINE INDENT if ( ( abs ( str [ i + j ] - str [ i ] ) == j ) ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT

BLEU: 61.52
Edit Sim: 70


Src: 
int maxSum ( int stack1 [ ] , int stack2 [ ] , int stack3 [ ] , int n1 , int n2 , int n3 ) { int sum1 = 0 , sum2 = 0 , sum3 = 0 ; for ( int i = 0 ; i < n1 ; i ++ ) sum1 += stack1 [ i ] ; for ( int i = 0 ; i < n2 ; i ++ ) sum2 += stack2 [ i ] ; for ( int i = 0 ; i < n3 ; i ++ ) sum3 += stack3 [ i ] ; int top1 = 0 , top2 = 0 , top3 = 0 ; int ans = 0 ; while ( 1 ) { if ( top1 == n1 || top2 == n2 || top3 == n3 ) return 0 ; if ( sum1 == sum2 && sum2 == sum3 ) return sum1 ; if ( sum1 >= sum2 && sum1 >= sum3 ) sum1 -= stack1 [ top1 ++ ] ; else if ( sum2 >= sum3 && sum2 >= sum3 ) sum2 -= stack2 [ top2 ++ ] ; else if ( sum3 >= sum2 && sum3 >= sum1 ) sum3 -= stack3 [ top3 ++ ] ; } }
Ref: 
def maxSum ( stack1 , stack2 , stack3 , n1 , n2 , n3 ) : NEW_LINE INDENT sum1 , sum2 , sum3 = 0 , 0 , 0 NEW_LINE for i in range ( n1 ) : NEW_LINE INDENT sum1 += stack1 [ i ] NEW_LINE DEDENT for i in range ( n2 ) : NEW_LINE INDENT sum2 += stack2 [ i ] NEW_LINE DEDENT for i in range ( n3 ) : NEW_LINE INDENT sum3 += stack3 [ i ] NEW_LINE DEDENT top1 , top2 , top3 = 0 , 0 , 0 NEW_LINE ans = 0 NEW_LINE while ( 1 ) : NEW_LINE INDENT if ( top1 == n1 or top2 == n2 or top3 == n3 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( sum1 == sum2 and sum2 == sum3 ) : NEW_LINE INDENT return sum1 NEW_LINE DEDENT if ( sum1 >= sum2 and sum1 >= sum3 ) : NEW_LINE INDENT sum1 -= stack1 [ top1 ] NEW_LINE top1 = top1 + 1 NEW_LINE DEDENT elif ( sum2 >= sum3 and sum2 >= sum3 ) : NEW_LINE INDENT sum2 -= stack2 [ top2 ] NEW_LINE top2 = top2 + 1 NEW_LINE DEDENT elif ( sum3 >= sum2 and sum3 >= sum1 ) : NEW_LINE INDENT sum3 -= stack3 [ top3 ] NEW_LINE top3 = top3 + 1 NEW_LINE DEDENT DEDENT DEDENT
Hyp: 
def maxSum ( stack1 , stack2 , stack3 , n1 , n2 , n3 ) : NEW_LINE INDENT sum1 = 0 NEW_LINE sum2 = 0 NEW_LINE sum3 = 0 NEW_LINE for i in range ( n1 ) : NEW_LINE INDENT sum1 += stack1 [ i ] NEW_LINE DEDENT for i in range ( n2 ) : NEW_LINE INDENT sum2 += stack2 [ i ] NEW_LINE DEDENT for i in range ( n3 ) : NEW_LINE INDENT sum3 += stack3 [ i ] NEW_LINE DEDENT top1 = 0 NEW_LINE top2 = 0 NEW_LINE top3 = 0 NEW_LINE ans = 0 NEW_LINE while ( 1 ) : NEW_LINE INDENT if ( top1 == n1 or top2 == n2 or top3 == n3 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( sum1 == sum2 and sum2 == sum3 ) : NEW_LINE INDENT return sum1 NEW_LINE DEDENT if ( sum1 >= sum2 and sum1 >= sum3 ) : NEW_LINE INDENT sum1 -= stack1 [ top1 ] NEW_LINE DEDENT elif ( sum2 >= sum3 and sum2 >= sum3 ) : NEW_LINE INDENT sum2 -= stack2 [ top2 ] NEW_LINE DEDENT elif ( sum3 >= sum2 and sum3 >= sum1 ) : NEW_LINE INDENT sum3 -= stack3 [ top3 ] NEW_LINE DEDENT DEDENT

BLEU: 84.04
Edit Sim: 132


Src: 
int solve ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int a = 0 , b = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i & 1 ) a = a * 10 + arr [ i ] ; else b = b * 10 + arr [ i ] ; } return a + b ; }
Ref: 
def solve ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE a = 0 b = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i % 2 != 0 ) : NEW_LINE INDENT a = a * 10 + arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT b = b * 10 + arr [ i ] NEW_LINE DEDENT DEDENT return a + b NEW_LINE DEDENT
Hyp: 
def solve ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE a = 0 NEW_LINE b = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if i & 1 : NEW_LINE INDENT a = a * 10 + arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT b = b * 10 + arr [ i ] NEW_LINE DEDENT DEDENT return a + b NEW_LINE DEDENT

BLEU: 85.75
Edit Sim: 24


Src: 
int firstFactorialDivisibleNumber ( int x ) { int i = 1 ; int fact = 1 ; for ( i = 1 ; i < x ; i ++ ) { fact = fact * i ; if ( fact % x == 0 ) break ; } return i ; }
Ref: 
def firstFactorialDivisibleNumber ( x ) : NEW_LINE INDENT i = 1 NEW_LINE fact = 1 NEW_LINE for i in range ( 1 , x ) : NEW_LINE INDENT fact = fact * i NEW_LINE if ( fact % x == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return i NEW_LINE DEDENT
Hyp: 
def firstFactorialDivisibleNumber ( x ) : NEW_LINE INDENT i = 1 NEW_LINE fact = 1 NEW_LINE for i in range ( 1 , x ) : NEW_LINE INDENT fact = fact * i NEW_LINE if ( fact % x == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return i NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int countMinOperations ( unsigned int target [ ] , int n ) { int result = 0 ; while ( 1 ) { int zero_count = 0 ; int i ; for ( i = 0 ; i < n ; i ++ ) { if ( target [ i ] & 1 ) break ; else if ( target [ i ] == 0 ) zero_count ++ ; } if ( zero_count == n ) return result ; if ( i == n ) { for ( int j = 0 ; j < n ; j ++ ) target [ j ] = target [ j ] / 2 ; result ++ ; } for ( int j = i ; j < n ; j ++ ) { if ( target [ j ] & 1 ) { target [ j ] -- ; result ++ ; } } } }
Ref: 
def countMinOperations ( target , n ) : NEW_LINE INDENT result = 0 NEW_LINE while ( True ) : NEW_LINE INDENT zero_count = 0 NEW_LINE i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( ( target [ i ] & 1 ) > 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT elif ( target [ i ] == 0 ) : NEW_LINE INDENT zero_count += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if ( zero_count == n ) : NEW_LINE INDENT return result NEW_LINE DEDENT if ( i == n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT target [ j ] = target [ j ] // 2 NEW_LINE DEDENT result += 1 NEW_LINE DEDENT for j in range ( i , n ) : NEW_LINE INDENT if ( target [ j ] & 1 ) : NEW_LINE INDENT target [ j ] -= 1 NEW_LINE result += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT
Hyp: 
def countMinOperations ( target , n ) : NEW_LINE INDENT result = 0 NEW_LINE while ( True ) : NEW_LINE INDENT zero_count = 0 NEW_LINE i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( target [ i ] & 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT elif ( target [ i ] == 0 ) : NEW_LINE INDENT zero_count += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if ( zero_count == n ) : NEW_LINE INDENT return result NEW_LINE DEDENT if ( i == n ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT target [ j ] = target [ j ] // 2 NEW_LINE result += 1 NEW_LINE DEDENT for j in range ( i , n ) : NEW_LINE INDENT if ( target [ j ] & 1 ) : NEW_LINE INDENT target [ j ] -= 1 NEW_LINE result += 1 NEW_LINE DEDENT DEDENT DEDENT

BLEU: 93.81
Edit Sim: 26


Src: 
void sortit ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = i + 1 ; } }
Ref: 
def sortit ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = i + 1 NEW_LINE DEDENT DEDENT
Hyp: 
def sortit ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = i + 1 NEW_LINE DEDENT DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
bool canMakeAllSame ( string str ) { int zeros = 0 , ones = 0 ; for ( char ch : str ) ( ch == '0' ) ? ++ zeros : ++ ones ; return ( zeros == 1 || ones == 1 ) ; }
Ref: 
def canMakeAllSame ( str ) : NEW_LINE INDENT zeros = 0 NEW_LINE ones = 0 NEW_LINE for i in range ( 0 , len ( str ) ) : NEW_LINE INDENT ch = str [ i ] NEW_LINE if ( ch == '0' ) : NEW_LINE INDENT zeros = zeros + 1 NEW_LINE DEDENT else : NEW_LINE INDENT ones = ones + 1 NEW_LINE DEDENT DEDENT return ( zeros == 1 or ones == 1 ) NEW_LINE DEDENT
Hyp: 
def canMakeAllSame ( st ) : NEW_LINE INDENT zeros = 0 NEW_LINE ones = 0 NEW_LINE for ch in st : NEW_LINE INDENT if ( ch == '0' ) : NEW_LINE INDENT zeros = zeros + 1 NEW_LINE DEDENT else : NEW_LINE INDENT ones = ones + 1 NEW_LINE DEDENT DEDENT return ( zeros == 1 or ones == 1 ) NEW_LINE DEDENT

BLEU: 68.43
Edit Sim: 50


Src: 
void minheapify ( int a [ ] , int index ) { int small = index ; int l = 2 * index + 1 ; int r = 2 * index + 2 ; if ( l < n && a [ l ] < a [ small ] ) small = l ; if ( r < n && a [ r ] < a [ small ] ) small = r ; if ( small != index ) { swap ( a [ small ] , a [ index ] ) ; minheapify ( a , small ) ; } }
Ref: 
def minheapify ( a , index ) : NEW_LINE INDENT small = index NEW_LINE l = 2 * index + 1 NEW_LINE r = 2 * index + 2 NEW_LINE if ( l < n and a [ l ] < a [ small ] ) : NEW_LINE INDENT small = l NEW_LINE DEDENT if ( r < n and a [ r ] < a [ small ] ) : NEW_LINE INDENT small = r NEW_LINE DEDENT if ( small != index ) : NEW_LINE INDENT ( a [ small ] , a [ index ] ) = ( a [ index ] , a [ small ] ) NEW_LINE minheapify ( a , small ) NEW_LINE DEDENT DEDENT
Hyp: 
def minheapify ( a , index ) : NEW_LINE INDENT small = index NEW_LINE l = 2 * index + 1 NEW_LINE r = 2 * index + 2 NEW_LINE if ( l < n and a [ l ] < a [ small ] ) : NEW_LINE INDENT small = l NEW_LINE DEDENT if ( r < n and a [ r ] < a [ small ] ) : NEW_LINE INDENT small = r NEW_LINE DEDENT if ( small != index ) : NEW_LINE INDENT a [ small ] , a [ index ] = a [ index ] , a [ small ] NEW_LINE minheapify ( a , small ) NEW_LINE DEDENT DEDENT

BLEU: 92.14
Edit Sim: 8


Src: 
void KMP ( int m , int n , string str2 , string str1 ) { int pos = 0 , len = 0 ; int p [ m + 1 ] ; int k = 0 ; p [ 1 ] = 0 ; for ( int i = 2 ; i <= n ; i ++ ) { while ( k > 0 && str1 [ k ] != str1 [ i - 1 ] ) k = p [ k ] ; if ( str1 [ k ] == str1 [ i - 1 ] ) ++ k ; p [ i ] = k ; } for ( int j = 0 , i = 0 ; i < m ; i ++ ) { while ( j > 0 && str1 [ j ] != str2 [ i ] ) j = p [ j ] ; if ( str1 [ j ] == str2 [ i ] ) j ++ ; if ( j > len ) { len = j ; pos = i - j + 1 ; } } cout << " Shift ▁ = ▁ " << pos << endl ; cout << " Prefix ▁ = ▁ " << str1 . substr ( 0 , len ) ; }
Ref: 
def KMP ( m , n , str2 , str1 ) : NEW_LINE INDENT pos = 0 NEW_LINE Len = 0 NEW_LINE p = [ 0 for i in range ( m + 1 ) ] NEW_LINE k = 0 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT while ( k > 0 and str1 [ k ] != str1 [ i - 1 ] ) : NEW_LINE INDENT k = p [ k ] NEW_LINE DEDENT if ( str1 [ k ] == str1 [ i - 1 ] ) : NEW_LINE INDENT k += 1 NEW_LINE DEDENT p [ i ] = k NEW_LINE DEDENT j = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT while ( j > 0 and j < n and str1 [ j ] != str2 [ i ] ) : NEW_LINE INDENT j = p [ j ] NEW_LINE DEDENT if ( j < n and str1 [ j ] == str2 [ i ] ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT if ( j > Len ) : NEW_LINE INDENT Len = j NEW_LINE pos = i - j + 1 NEW_LINE DEDENT DEDENT print ( " Shift ▁ = ▁ " , pos ) NEW_LINE print ( " Prefix ▁ = ▁ " , str1 [ : Len ] ) NEW_LINE DEDENT
Hyp: 
def KMP ( m , n , str2 , str1 ) : NEW_LINE INDENT pos = 0 NEW_LINE len = 0 NEW_LINE p = [ 0 ] * ( m + 1 ) NEW_LINE k = 0 NEW_LINE p [ 1 ] = 0 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT while ( k > 0 and str1 [ k ] != str1 [ i - 1 ] ) : NEW_LINE INDENT k = p [ k ] NEW_LINE DEDENT if ( str1 [ k ] == str1 [ i - 1 ] ) : NEW_LINE INDENT k = k + 1 NEW_LINE DEDENT p [ i ] = k NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT while ( j > 0 and str1 [ j ] != str2 [ i ] ) : NEW_LINE INDENT j = p [ j ] NEW_LINE DEDENT if ( str1 [ j ] == str2 [ i ] ) : NEW_LINE INDENT j = j + 1 NEW_LINE DEDENT if ( j > len ) : NEW_LINE INDENT len = j NEW_LINE pos = i - j + 1 NEW_LINE DEDENT DEDENT print ( " Shift ▁ = ▁ " , pos ) NEW_LINE print ( " Prefix ▁ = ▁ " , str1 ) NEW_LINE DEDENT

BLEU: 83.06
Edit Sim: 87


Src: 
void swapDiagonal ( int matrix [ ] [ N ] ) { for ( int i = 0 ; i < N ; i ++ ) swap ( matrix [ i ] [ i ] , matrix [ i ] [ N - i - 1 ] ) ; }
Ref: 
def swapDiagonal ( matrix ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT matrix [ i ] [ i ] , matrix [ i ] [ N - i - 1 ] = \ NEW_LINE INDENT matrix [ i ] [ N - i - 1 ] , matrix [ i ] [ i ] NEW_LINE DEDENT DEDENT DEDENT
Hyp: 
def swapDiagonal ( matrix ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT matrix [ i ] [ i ] , matrix [ i ] [ N - i - 1 ] = matrix [ i ] [ N - i - 1 ] , matrix [ i ] [ i ] NEW_LINE DEDENT DEDENT

BLEU: 91.14
Edit Sim: 25


Src: 
void psuedoBinary ( int n ) { while ( n > 0 ) { int temp = n , m = 0 , p = 1 ; while ( temp ) { int rem = temp % 10 ; temp = temp / 10 ; if ( rem != 0 ) m += p ; p *= 10 ; } cout << m << " ▁ " ; n = n - m ; } }
Ref: 
def psuedoBinary ( n ) : NEW_LINE INDENT while ( n > 0 ) : NEW_LINE INDENT temp = n NEW_LINE m = 0 NEW_LINE p = 1 NEW_LINE while ( temp ) : NEW_LINE INDENT rem = temp % 10 NEW_LINE temp = int ( temp / 10 ) NEW_LINE if ( rem != 0 ) : NEW_LINE INDENT m += p NEW_LINE DEDENT p *= 10 NEW_LINE DEDENT print ( m , end = " ▁ " ) NEW_LINE n = n - m NEW_LINE DEDENT DEDENT
Hyp: 
def psuedoBinary ( n ) : NEW_LINE INDENT while ( n > 0 ) : NEW_LINE INDENT temp = n NEW_LINE m = 0 NEW_LINE p = 1 NEW_LINE while ( temp ) : NEW_LINE INDENT rem = temp % 10 NEW_LINE temp = int ( temp / 10 ) NEW_LINE if ( rem != 0 ) : NEW_LINE INDENT m += p NEW_LINE DEDENT p = 10 NEW_LINE DEDENT print ( m , end = " ▁ " ) NEW_LINE n = n - m NEW_LINE DEDENT DEDENT

BLEU: 97.15
Edit Sim: 1


Src: 
int findmin ( Point p [ ] , int n ) { int a = 0 , b = 0 , c = 0 , d = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( p [ i ] . x <= 0 ) a ++ ; else if ( p [ i ] . x >= 0 ) b ++ ; if ( p [ i ] . y >= 0 ) c ++ ; else if ( p [ i ] . y <= 0 ) d ++ ; } return min ( { a , b , c , d } ) ; }
Ref: 
def findmin ( p , n ) : NEW_LINE INDENT a , b , c , d = 0 , 0 , 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( p [ i ] [ 0 ] <= 0 ) : NEW_LINE INDENT a += 1 NEW_LINE DEDENT elif ( p [ i ] [ 0 ] >= 0 ) : NEW_LINE INDENT b += 1 NEW_LINE DEDENT if ( p [ i ] [ 1 ] >= 0 ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT elif ( p [ i ] [ 1 ] <= 0 ) : NEW_LINE INDENT d += 1 NEW_LINE DEDENT DEDENT return min ( [ a , b , c , d ] ) NEW_LINE DEDENT
Hyp: 
def findmin ( p , n ) : NEW_LINE INDENT a = 0 NEW_LINE b = 0 NEW_LINE c = 0 NEW_LINE d = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( p [ i ] . x <= 0 ) : NEW_LINE INDENT a += 1 NEW_LINE DEDENT elif ( p [ i ] . x >= 0 ) : NEW_LINE INDENT b += 1 NEW_LINE DEDENT if ( p [ i ] . y >= 0 ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT elif ( p [ i ] . y <= 0 ) : NEW_LINE INDENT d += 1 NEW_LINE DEDENT DEDENT return min ( { a , b , c , d } ) NEW_LINE DEDENT

BLEU: 72.85
Edit Sim: 51


Src: 
int minCoins ( int coins [ ] , int m , int V ) { int table [ V + 1 ] ; table [ 0 ] = 0 ; for ( int i = 1 ; i <= V ; i ++ ) table [ i ] = INT_MAX ; for ( int i = 1 ; i <= V ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) if ( coins [ j ] <= i ) { int sub_res = table [ i - coins [ j ] ] ; if ( sub_res != INT_MAX && sub_res + 1 < table [ i ] ) table [ i ] = sub_res + 1 ; } } return table [ V ] ; }
Ref: 
def minCoins ( coins , m , V ) : NEW_LINE INDENT table = [ 0 for i in range ( V + 1 ) ] NEW_LINE table [ 0 ] = 0 NEW_LINE for i in range ( 1 , V + 1 ) : NEW_LINE INDENT table [ i ] = sys . maxsize NEW_LINE DEDENT for i in range ( 1 , V + 1 ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( coins [ j ] <= i ) : NEW_LINE INDENT sub_res = table [ i - coins [ j ] ] NEW_LINE if ( sub_res != sys . maxsize and sub_res + 1 < table [ i ] ) : NEW_LINE INDENT table [ i ] = sub_res + 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return table [ V ] NEW_LINE DEDENT
Hyp: 
def minCoins ( coins , m , V ) : NEW_LINE INDENT table = [ 0 for _ in range ( V + 1 ) ] NEW_LINE table [ 0 ] = 0 NEW_LINE for i in range ( 1 , V + 1 ) : NEW_LINE INDENT table [ i ] = sys . maxsize NEW_LINE DEDENT for i in range ( 1 , V + 1 ) : NEW_LINE INDENT for j in range ( 0 , m ) : NEW_LINE INDENT if ( coins [ j ] <= i ) : NEW_LINE INDENT sub_res = table [ i - coins [ j ] ] NEW_LINE if ( sub_res != INT_MAX and sub_res + 1 < table [ i ] ) : NEW_LINE INDENT table [ i ] = sub_res + 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return table [ V ] NEW_LINE DEDENT

BLEU: 94.11
Edit Sim: 18


Src: 
string maximumPalinUsingKChanges ( string str , int k ) { string palin = str ; int l = 0 ; int r = str . length ( ) - 1 ; while ( l < r ) { if ( str [ l ] != str [ r ] ) { palin [ l ] = palin [ r ] = max ( str [ l ] , str [ r ] ) ; k -- ; } l ++ ; r -- ; } if ( k < 0 ) return " Not ▁ possible " ; l = 0 ; r = str . length ( ) - 1 ; while ( l <= r ) { if ( l == r ) { if ( k > 0 ) palin [ l ] = '9' ; } if ( palin [ l ] < '9' ) { if ( k >= 2 && palin [ l ] == str [ l ] && palin [ r ] == str [ r ] ) { k -= 2 ; palin [ l ] = palin [ r ] = '9' ; } else if ( k >= 1 && ( palin [ l ] != str [ l ] || palin [ r ] != str [ r ] ) ) { k -- ; palin [ l ] = palin [ r ] = '9' ; } } l ++ ; r -- ; } return palin ; }
Ref: 
def maximumPalinUsingKChanges ( strr , k ) : NEW_LINE INDENT palin = strr NEW_LINE l = 0 NEW_LINE r = len ( strr ) - 1 NEW_LINE while ( l <= r ) : NEW_LINE INDENT if ( strr [ l ] != strr [ r ] ) : NEW_LINE INDENT palin [ l ] = palin [ r ] = max ( strr [ l ] , strr [ r ] ) NEW_LINE k -= 1 NEW_LINE DEDENT l += 1 NEW_LINE r -= 1 NEW_LINE DEDENT if ( k < 0 ) : NEW_LINE INDENT return " Not ▁ possible " NEW_LINE DEDENT l = 0 NEW_LINE r = len ( strr ) - 1 NEW_LINE while ( l <= r ) : NEW_LINE INDENT if ( l == r ) : NEW_LINE INDENT if ( k > 0 ) : NEW_LINE INDENT palin [ l ] = '9' NEW_LINE DEDENT DEDENT if ( palin [ l ] < '9' ) : NEW_LINE INDENT if ( k >= 2 and palin [ l ] == strr [ l ] and palin [ r ] == strr [ r ] ) : NEW_LINE INDENT k -= 1 NEW_LINE palin [ l ] = palin [ r ] = '9' NEW_LINE DEDENT elif ( k >= 1 and ( palin [ l ] != strr [ l ] or palin [ r ] != strr [ r ] ) ) : NEW_LINE INDENT k -= 1 NEW_LINE palin [ l ] = palin [ r ] = '9' NEW_LINE DEDENT DEDENT l += 1 NEW_LINE r -= 1 NEW_LINE DEDENT return palin NEW_LINE DEDENT
Hyp: 
def maximumPalinUsingKChanges ( str , k ) : NEW_LINE INDENT palin = str NEW_LINE l = 0 NEW_LINE r = len ( str ) - 1 NEW_LINE while ( l < r ) : NEW_LINE INDENT if ( str [ l ] != str [ r ] ) : NEW_LINE INDENT palin [ l ] = palin [ r ] = max ( str [ l ] , str [ r ] ) NEW_LINE k -= 1 NEW_LINE DEDENT l += 1 NEW_LINE r -= 1 NEW_LINE DEDENT if ( k < 0 ) : NEW_LINE INDENT return " Not ▁ possible " NEW_LINE DEDENT l = 0 NEW_LINE r = len ( str ) - 1 NEW_LINE while ( l <= r ) : NEW_LINE INDENT if ( k > 0 ) : NEW_LINE INDENT palin [ l ] = '9' NEW_LINE DEDENT DEDENT if ( palin [ l ] < '9' ) : NEW_LINE INDENT if ( k >= 2 and palin [ l ] == str [ l ] and palin [ r ] == str [ r ] ) : NEW_LINE INDENT k -= 2 NEW_LINE palin [ l ] = palin [ r ] = '9' NEW_LINE DEDENT elif ( k >= 1 and ( palin [ l ] != str [ l ] or palin [ r ] != str [ r ] ) : NEW_LINE INDENT k -= 1 NEW_LINE palin [ l ] = palin [ r ] = '9' NEW_LINE DEDENT DEDENT l += 1 NEW_LINE r -= 1 NEW_LINE DEDENT return palin NEW_LINE DEDENT

BLEU: 82.97
Edit Sim: 48


Src: 
int findMinRooms ( string slots [ ] , int n , int m ) { int counts [ m ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( slots [ i ] [ j ] == '1' ) counts [ j ] ++ ; return * max_element ( counts , counts + m ) ; }
Ref: 
def findMinRooms ( slots , n , m ) : NEW_LINE INDENT counts = [ 0 ] * m NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( slots [ i ] [ j ] == '1' ) : NEW_LINE INDENT counts [ j ] += 1 NEW_LINE DEDENT DEDENT DEDENT return max ( counts ) NEW_LINE DEDENT
Hyp: 
def findMinRooms ( slots , n , m ) : NEW_LINE INDENT counts = [ 0 for i in range ( m ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( slots [ i ] [ j ] == '1' ) : NEW_LINE INDENT counts [ j ] += 1 NEW_LINE DEDENT DEDENT DEDENT return max ( counts , counts + m ) NEW_LINE DEDENT

BLEU: 81.84
Edit Sim: 32


Src: 
void printMaxSum ( int arr [ ] , int n ) { int dp [ n ] ; memset ( dp , 0 , sizeof dp ) ; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] = arr [ i ] ; int maxi = 0 ; for ( int j = 1 ; j <= sqrt ( i + 1 ) ; j ++ ) { if ( ( ( i + 1 ) % j == 0 ) && ( i + 1 ) != j ) { if ( dp [ j - 1 ] > maxi ) maxi = dp [ j - 1 ] ; if ( dp [ ( i + 1 ) / j - 1 ] > maxi && j != 1 ) maxi = dp [ ( i + 1 ) / j - 1 ] ; } } dp [ i ] += maxi ; } for ( int i = 0 ; i < n ; i ++ ) cout << dp [ i ] << " ▁ " ; }
Ref: 
def printMaxSum ( arr , n ) : NEW_LINE INDENT dp = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp [ i ] = arr [ i ] NEW_LINE maxi = 0 NEW_LINE for j in range ( 1 , int ( ( i + 1 ) ** 0.5 ) + 1 ) : NEW_LINE INDENT if ( ( i + 1 ) % j == 0 and ( i + 1 ) != j ) : NEW_LINE INDENT if ( dp [ j - 1 ] > maxi ) : NEW_LINE INDENT maxi = dp [ j - 1 ] NEW_LINE DEDENT if ( dp [ ( i + 1 ) // j - 1 ] > maxi and j != 1 ) : NEW_LINE INDENT maxi = dp [ ( i + 1 ) // j - 1 ] NEW_LINE DEDENT DEDENT DEDENT dp [ i ] += maxi NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( dp [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT
Hyp: 
def printMaxSum ( arr , n ) : NEW_LINE INDENT dp = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp [ i ] = arr [ i ] NEW_LINE maxi = 0 NEW_LINE for j in range ( 1 , int ( m . sqrt ( i + 1 ) + 1 ) ) : NEW_LINE INDENT if ( ( ( i + 1 ) % j == 0 ) and ( i + 1 ) != j ) : NEW_LINE INDENT if ( dp [ j - 1 ] > maxi ) : NEW_LINE INDENT maxi = dp [ j - 1 ] NEW_LINE DEDENT if ( dp [ ( i + 1 ) / j - 1 ] > maxi and j != 1 ) : NEW_LINE INDENT maxi = dp [ ( i + 1 ) / j - 1 ] NEW_LINE DEDENT DEDENT DEDENT dp [ i ] += maxi NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( dp [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT

BLEU: 89.9
Edit Sim: 22


Src: 
int maxAlternateSum ( int arr [ ] , int n ) { if ( n == 1 ) return arr [ 0 ] ; int dec [ n ] ; memset ( dec , 0 , sizeof ( dec ) ) ; int inc [ n ] ; memset ( inc , 0 , sizeof ( inc ) ) ; dec [ 0 ] = inc [ 0 ] = arr [ 0 ] ; int flag = 0 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ j ] > arr [ i ] ) { dec [ i ] = max ( dec [ i ] , inc [ j ] + arr [ i ] ) ; flag = 1 ; } else if ( arr [ j ] < arr [ i ] && flag == 1 ) inc [ i ] = max ( inc [ i ] , dec [ j ] + arr [ i ] ) ; } } int result = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { if ( result < inc [ i ] ) result = inc [ i ] ; if ( result < dec [ i ] ) result = dec [ i ] ; } return result ; }
Ref: 
def maxAlternateSum ( arr , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return arr [ 0 ] NEW_LINE DEDENT dec = [ 0 for i in range ( n + 1 ) ] NEW_LINE inc = [ 0 for i in range ( n + 1 ) ] NEW_LINE dec [ 0 ] = inc [ 0 ] = arr [ 0 ] NEW_LINE flag = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ j ] > arr [ i ] ) : NEW_LINE INDENT dec [ i ] = max ( dec [ i ] , inc [ j ] + arr [ i ] ) NEW_LINE flag = 1 NEW_LINE DEDENT elif ( arr [ j ] < arr [ i ] and flag == 1 ) : NEW_LINE INDENT inc [ i ] = max ( inc [ i ] , dec [ j ] + arr [ i ] ) NEW_LINE DEDENT DEDENT DEDENT result = - 2147483648 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( result < inc [ i ] ) : NEW_LINE INDENT result = inc [ i ] NEW_LINE DEDENT if ( result < dec [ i ] ) : NEW_LINE INDENT result = dec [ i ] NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
Hyp: 
def maxAlternateSum ( arr , n ) : NEW_LINE INDENT if ( n == 1 ) : return arr [ 0 ] NEW_LINE DEDENT dec = [ 0 for i in range ( n ) ] NEW_LINE inc = [ 0 for i in range ( n ) ] NEW_LINE dec [ 0 ] = inc [ 0 ] = arr [ 0 ] NEW_LINE flag = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ j ] > arr [ i ] ) : NEW_LINE INDENT dec [ i ] = max ( dec [ i ] , inc [ j ] + arr [ i ] ) NEW_LINE flag = 1 NEW_LINE DEDENT elif ( arr [ j ] < arr [ i ] and flag == 1 ) : NEW_LINE INDENT inc [ i ] = max ( inc [ i ] , dec [ j ] + arr [ i ] ) NEW_LINE DEDENT DEDENT DEDENT result = - sys . maxsize - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( result < inc [ i ] ) : NEW_LINE INDENT result = inc [ i ] NEW_LINE DEDENT if ( result < dec [ i ] ) : NEW_LINE INDENT result = dec [ i ] NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT

BLEU: 94.75
Edit Sim: 41


Src: 
void printRepeating ( int arr [ ] , int size ) { int i , j ; printf ( " ▁ Repeating ▁ elements ▁ are ▁ " ) ; for ( i = 0 ; i < size ; i ++ ) for ( j = i + 1 ; j < size ; j ++ ) if ( arr [ i ] == arr [ j ] ) cout << arr [ i ] << " ▁ " ; }
Ref: 
def printRepeating ( arr , size ) : NEW_LINE INDENT print ( " Repeating ▁ elements ▁ are ▁ " , end = ' ' ) NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT for j in range ( i + 1 , size ) : NEW_LINE INDENT if arr [ i ] == arr [ j ] : NEW_LINE INDENT print ( arr [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
Hyp: 
def printRepeating ( arr , size ) : NEW_LINE INDENT for i in range ( 0 , size ) : NEW_LINE INDENT for j in range ( i + 1 , size ) : NEW_LINE INDENT if arr [ i ] == arr [ j ] : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT DEDENT

BLEU: 71.58
Edit Sim: 66


Src: 
int minProduct ( int arr [ ] , int n , int k ) { priority_queue < int , vector < int > , greater < int > > pq ; for ( int i = 0 ; i < n ; i ++ ) pq . push ( arr [ i ] ) ; int count = 0 , ans = 1 ; while ( pq . empty ( ) == false && count < k ) { ans = ans * pq . top ( ) ; pq . pop ( ) ; count ++ ; } return ans ; }
Ref: 
def minProduct ( arr , n , k ) : NEW_LINE INDENT heapq . heapify ( arr ) NEW_LINE count = 0 NEW_LINE ans = 1 NEW_LINE while ( arr ) and count < k : NEW_LINE INDENT x = heapq . heappop ( arr ) NEW_LINE ans = ans * x NEW_LINE count = count + 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
Hyp: 
def minProduct ( arr , n , k ) : NEW_LINE INDENT pq = PriorityQueue ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT pq . put ( arr [ i ] ) NEW_LINE DEDENT count = 0 NEW_LINE ans = 1 NEW_LINE while ( len ( pq ) == 0 and count < k ) : NEW_LINE INDENT ans = ans * pq . get ( ) NEW_LINE count += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT

BLEU: 42.6
Edit Sim: 146


Src: 
int largest ( int arr [ ] , int n ) { return * max_element ( arr , arr + n ) ; }
Ref: 
def largest ( arr , n ) : NEW_LINE INDENT return max ( arr ) NEW_LINE DEDENT
Hyp: 
def largest ( arr , n ) : NEW_LINE INDENT return arr [ n ] NEW_LINE DEDENT

BLEU: 68.53
Edit Sim: 8


Src: 
float exponential ( int n , float x ) { float sum = 1.0f ; for ( int i = n - 1 ; i > 0 ; -- i ) sum = 1 + x * sum / i ; return sum ; }
Ref: 
def exponential ( n , x ) : NEW_LINE INDENT sum = 1.0 NEW_LINE for i in range ( n , 0 , - 1 ) : NEW_LINE INDENT sum = 1 + x * sum / i NEW_LINE DEDENT print ( " e ^ x ▁ = " , sum ) NEW_LINE DEDENT
Hyp: 
def exponential ( n , x ) : NEW_LINE INDENT sum = 1.0f NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT sum = 1 + x * sum / i NEW_LINE DEDENT return float ( sum ) NEW_LINE DEDENT

BLEU: 67.41
Edit Sim: 27


Src: 
int firstElement ( int arr [ ] , int n , int k ) { unordered_map < int , int > count_map ; for ( int i = 0 ; i < n ; i ++ ) count_map [ arr [ i ] ] ++ ; for ( int i = 0 ; i < n ; i ++ ) if ( count_map [ arr [ i ] ] == k ) return arr [ i ] ; return - 1 ; }
Ref: 
def firstElement ( arr , n , k ) : NEW_LINE INDENT count_map = { } NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] in count_map . keys ( ) ) : NEW_LINE INDENT count_map [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_map [ arr [ i ] ] = 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( count_map [ arr [ i ] ] == k ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
Hyp: 
def firstElement ( arr , n , k ) : NEW_LINE INDENT count_map = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if count_map . get ( arr [ i ] ) : NEW_LINE INDENT count_map [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_map [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if count_map [ arr [ i ] ] == k : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT

BLEU: 70.04
Edit Sim: 78


Src: 
int maxProd ( int n ) { if ( n == 2 || n == 3 ) return ( n - 1 ) ; int res = 1 ; while ( n > 4 ) { n -= 3 ; res *= 3 ; } return ( n * res ) ; }
Ref: 
def maxProd ( n ) : NEW_LINE INDENT if ( n == 2 or n == 3 ) : NEW_LINE INDENT return ( n - 1 ) NEW_LINE DEDENT res = 1 NEW_LINE while ( n > 4 ) : NEW_LINE INDENT n -= 3 NEW_LINE res *= 3 NEW_LINE DEDENT return ( n * res ) NEW_LINE DEDENT
Hyp: 
def maxProd ( n ) : NEW_LINE INDENT if ( n == 2 or n == 3 ) : NEW_LINE INDENT return ( n - 1 ) NEW_LINE DEDENT res = 1 NEW_LINE while ( n > 4 ) : NEW_LINE INDENT n -= 3 NEW_LINE res *= 3 NEW_LINE DEDENT return ( n * res ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int maxSum ( int grid [ 2 ] [ MAX ] , int n ) { int incl = max ( grid [ 0 ] [ 0 ] , grid [ 1 ] [ 0 ] ) ; int excl = 0 , excl_new ; for ( int i = 1 ; i < n ; i ++ ) { excl_new = max ( excl , incl ) ; incl = excl + max ( grid [ 0 ] [ i ] , grid [ 1 ] [ i ] ) ; excl = excl_new ; } return max ( excl , incl ) ; }
Ref: 
def maxSum ( grid , n ) : NEW_LINE INDENT incl = max ( grid [ 0 ] [ 0 ] , grid [ 1 ] [ 0 ] ) NEW_LINE excl = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT excl_new = max ( excl , incl ) NEW_LINE incl = excl + max ( grid [ 0 ] [ i ] , grid [ 1 ] [ i ] ) NEW_LINE excl = excl_new NEW_LINE DEDENT return max ( excl , incl ) NEW_LINE DEDENT
Hyp: 
def maxSum ( grid , n ) : NEW_LINE INDENT incl = max ( grid [ 0 ] [ 0 ] , grid [ 1 ] [ 0 ] ) NEW_LINE excl = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT excl_new = max ( excl , incl ) NEW_LINE incl = excl + max ( grid [ 0 ] [ i ] , grid [ 1 ] [ i ] ) NEW_LINE excl = excl_new NEW_LINE DEDENT return max ( excl , incl ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int countRotations ( int arr [ ] , int low , int high ) { if ( high < low ) return 0 ; if ( high == low ) return low ; int mid = low + ( high - low ) / 2 ; if ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) return ( mid + 1 ) ; if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) return mid ; if ( arr [ high ] > arr [ mid ] ) return countRotations ( arr , low , mid - 1 ) ; return countRotations ( arr , mid + 1 , high ) ; }
Ref: 
def countRotations ( arr , low , high ) : NEW_LINE INDENT if ( high < low ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( high == low ) : NEW_LINE INDENT return low NEW_LINE DEDENT mid = low + ( high - low ) / 2 NEW_LINE mid = int ( mid ) NEW_LINE if ( mid < high and arr [ mid + 1 ] < arr [ mid ] ) : NEW_LINE INDENT return ( mid + 1 ) NEW_LINE DEDENT if ( mid > low and arr [ mid ] < arr [ mid - 1 ] ) : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( arr [ high ] > arr [ mid ] ) : NEW_LINE INDENT return countRotations ( arr , low , mid - 1 ) NEW_LINE DEDENT return countRotations ( arr , mid + 1 , high ) NEW_LINE DEDENT
Hyp: 
def countRotations ( arr , low , high ) : NEW_LINE INDENT if high < low : NEW_LINE INDENT return 0 NEW_LINE DEDENT if high == low : NEW_LINE INDENT return low NEW_LINE DEDENT mid = low + ( high - low ) / 2 NEW_LINE if mid < high and arr [ mid + 1 ] < arr [ mid ] : NEW_LINE INDENT return ( mid + 1 ) NEW_LINE DEDENT if mid > low and arr [ mid ] < arr [ mid - 1 ] : NEW_LINE INDENT return mid NEW_LINE DEDENT if arr [ high ] > arr [ mid ] : NEW_LINE INDENT return countRotations ( arr , low , mid - 1 ) NEW_LINE DEDENT return countRotations ( arr , mid + 1 , high ) NEW_LINE DEDENT

BLEU: 77.56
Edit Sim: 47


Src: 
int findSum ( int n ) { int ans = 0 , temp = 0 , num ; for ( int i = 1 ; i <= n && temp < n ; i ++ ) { temp = i - 1 ; num = 1 ; while ( temp < n ) { if ( temp + i <= n ) ans += ( i * num ) ; else ans += ( ( n - temp ) * num ) ; temp += i ; num ++ ; } } return ans ; }
Ref: 
def findSum ( n ) : NEW_LINE INDENT ans = 0 temp = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if temp < n : NEW_LINE INDENT temp = i - 1 NEW_LINE num = 1 NEW_LINE while temp < n : NEW_LINE INDENT if temp + i <= n : NEW_LINE INDENT ans += i * num NEW_LINE DEDENT else : NEW_LINE INDENT ans += ( n - temp ) * num NEW_LINE DEDENT temp += i NEW_LINE num += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
Hyp: 
def findSum ( n ) : NEW_LINE INDENT ans = 0 NEW_LINE temp = 0 NEW_LINE num = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT temp = i - 1 NEW_LINE num = 1 NEW_LINE while ( temp < n ) : NEW_LINE INDENT if ( temp + i <= n ) : NEW_LINE INDENT ans += ( i * num ) NEW_LINE DEDENT else : NEW_LINE INDENT ans += ( ( n - temp ) * num ) NEW_LINE temp += i NEW_LINE num += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT

BLEU: 70.97
Edit Sim: 81


Src: 
bool checkCorrectOrNot ( string s ) { int count1 [ MAX_CHAR ] = { 0 } ; int count2 [ MAX_CHAR ] = { 0 } ; int n = s . length ( ) ; if ( n == 1 ) return true ; for ( int i = 0 , j = n - 1 ; i < j ; i ++ , j -- ) { count1 [ s [ i ] - ' a ' ] ++ ; count2 [ s [ j ] - ' a ' ] ++ ; } for ( int i = 0 ; i < MAX_CHAR ; i ++ ) if ( count1 [ i ] != count2 [ i ] ) return false ; return true ; }
Ref: 
def checkCorrectOrNot ( s ) : NEW_LINE INDENT global MAX_CHAR NEW_LINE count1 = [ 0 ] * MAX_CHAR NEW_LINE count2 = [ 0 ] * MAX_CHAR NEW_LINE n = len ( s ) NEW_LINE if n == 1 : NEW_LINE INDENT return true NEW_LINE DEDENT i = 0 j = n - 1 NEW_LINE while ( i < j ) : NEW_LINE INDENT count1 [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE count2 [ ord ( s [ j ] ) - ord ( ' a ' ) ] += 1 NEW_LINE i += 1 j -= 1 NEW_LINE DEDENT for i in range ( MAX_CHAR ) : NEW_LINE INDENT if count1 [ i ] != count2 [ i ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
Hyp: 
def checkCorrectOrNot ( s ) : NEW_LINE INDENT count1 = [ 0 ] * MAX_CHAR NEW_LINE count2 = [ 0 ] * MAX_CHAR NEW_LINE n = len ( s ) NEW_LINE if ( n == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT for i in range ( 0 , n , 1 ) : NEW_LINE INDENT count1 [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE count2 [ ord ( s [ j ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( 0 , MAX_CHAR ) : NEW_LINE INDENT if ( count1 [ i ] != count2 [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT

BLEU: 74.35
Edit Sim: 90


Src: 
int divSum ( int n ) { int result = 0 ; for ( int i = 2 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( i == ( n / i ) ) result += i ; else result += ( i + n / i ) ; } } return ( result + n + 1 ) ; }
Ref: 
def divSum ( n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 2 , ( int ) ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( i == ( n / i ) ) : NEW_LINE INDENT result = result + i NEW_LINE DEDENT else : NEW_LINE INDENT result = result + ( i + n // i ) NEW_LINE DEDENT DEDENT DEDENT return ( result + n + 1 ) NEW_LINE DEDENT
Hyp: 
def divSum ( n ) : NEW_LINE INDENT result = 0 NEW_LINE i = 2 NEW_LINE while i <= ( math . sqrt ( n ) ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( i == ( n / i ) ) : NEW_LINE INDENT result = result + i ; NEW_LINE DEDENT else : NEW_LINE INDENT result = result + ( i + n / i ) ; NEW_LINE DEDENT DEDENT i = i + 1 NEW_LINE DEDENT return ( result + n + 1 ) ; NEW_LINE DEDENT

BLEU: 74.01
Edit Sim: 55


Src: 
void rotateMatrix ( int mat [ ] [ N ] ) { for ( int i = N - 1 ; i >= 0 ; i -- ) { for ( int j = N - 1 ; j >= 0 ; j -- ) printf ( " % d ▁ " , mat [ i ] [ j ] ) ; printf ( " \n " ) ; } }
Ref: 
def rotateMatrix ( mat ) : NEW_LINE INDENT i = N - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT j = N - 1 NEW_LINE while ( j >= 0 ) : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = " ▁ " ) NEW_LINE j = j - 1 NEW_LINE DEDENT print ( ) NEW_LINE i = i - 1 NEW_LINE DEDENT DEDENT
Hyp: 
def rotateMatrix ( mat ) : NEW_LINE INDENT for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT

BLEU: 53.23
Edit Sim: 90


Src: 
void printSpiral ( int mat [ ] [ MAX ] , int r , int c ) { int i , a = 0 , b = 2 ; int low_row = ( 0 > a ) ? 0 : a ; int low_column = ( 0 > b ) ? 0 : b - 1 ; int high_row = ( ( a + 1 ) >= r ) ? r - 1 : a + 1 ; int high_column = ( ( b + 1 ) >= c ) ? c - 1 : b + 1 ; while ( ( low_row > 0 - r && low_column > 0 - c ) ) { for ( i = low_column + 1 ; i <= high_column && i < c && low_row >= 0 ; ++ i ) cout << mat [ low_row ] [ i ] << " ▁ " ; low_row -= 1 ; for ( i = low_row + 2 ; i <= high_row && i < r && high_column < c ; ++ i ) cout << mat [ i ] [ high_column ] << " ▁ " ; high_column += 1 ; for ( i = high_column - 2 ; i >= low_column && i >= 0 && high_row < r ; -- i ) cout << mat [ high_row ] [ i ] << " ▁ " ; high_row += 1 ; for ( i = high_row - 2 ; i > low_row && i >= 0 && low_column >= 0 ; -- i ) cout << mat [ i ] [ low_column ] << " ▁ " ; low_column -= 1 ; } cout << endl ; }
Ref: 
def printSpiral ( mat , r , c ) : NEW_LINE INDENT a = 0 NEW_LINE b = 2 NEW_LINE low_row = 0 if ( 0 > a ) else a NEW_LINE low_column = 0 if ( 0 > b ) else b - 1 NEW_LINE high_row = r - 1 if ( ( a + 1 ) >= r ) else a + 1 NEW_LINE high_column = c - 1 if ( ( b + 1 ) >= c ) else b + 1 NEW_LINE while ( ( low_row > 0 - r and low_column > 0 - c ) ) : NEW_LINE INDENT i = low_column + 1 NEW_LINE while ( i <= high_column and i < c and low_row >= 0 ) : NEW_LINE INDENT print ( mat [ low_row ] [ i ] , end = " ▁ " ) NEW_LINE i += 1 NEW_LINE DEDENT low_row -= 1 NEW_LINE i = low_row + 2 NEW_LINE while ( i <= high_row and i < r and high_column < c ) : NEW_LINE INDENT print ( mat [ i ] [ high_column ] , end = " ▁ " ) NEW_LINE i += 1 NEW_LINE DEDENT high_column += 1 NEW_LINE i = high_column - 2 NEW_LINE while ( i >= low_column and i >= 0 and high_row < r ) : NEW_LINE INDENT print ( mat [ high_row ] [ i ] , end = " ▁ " ) NEW_LINE i -= 1 NEW_LINE DEDENT high_row += 1 NEW_LINE i = high_row - 2 NEW_LINE while ( i > low_row and i >= 0 and low_column >= 0 ) : NEW_LINE INDENT print ( mat [ i ] [ low_column ] , end = " ▁ " ) NEW_LINE i -= 1 NEW_LINE DEDENT low_column -= 1 NEW_LINE DEDENT print ( ) NEW_LINE DEDENT
Hyp: 
def printSpiral ( mat , r , c ) : NEW_LINE INDENT a = 0 NEW_LINE b = 2 NEW_LINE low_row = 0 NEW_LINE low_column = 0 NEW_LINE if ( 0 > a ) : NEW_LINE INDENT a = 0 NEW_LINE DEDENT b = 2 NEW_LINE high_row = 0 NEW_LINE low_column = 0 NEW_LINE if ( 0 > b ) : NEW_LINE INDENT b = b - 1 NEW_LINE DEDENT low_column = 0 NEW_LINE while ( low_row > 0 - r and low_column > 0 - c ) : NEW_LINE INDENT for i in range ( low_column + 1 , high_column < c and low_row >= 0 ) : NEW_LINE INDENT print ( mat [ low_row ] [ i ] , end = " ▁ " ) NEW_LINE low_row -= 1 NEW_LINE DEDENT for i in range ( low_row + 2 , high_row and i < r and high_column < c ) : NEW_LINE INDENT print ( mat [ i ] [ high_column ] , end = " ▁ " ) NEW_LINE high_column += 1 NEW_LINE DEDENT for i in range ( high_column - 2 , low_row and i >= 0 and high_row < r , - 1 ) : NEW_LINE INDENT print ( mat [ high_row ] [ i ] , end = " ▁ " ) NEW_LINE high_row += 1 NEW_LINE DEDENT for i in range ( high_row - 2 , low_row and i >= 0 and low_column >= 0 , - 1 ) : NEW_LINE INDENT print ( mat [ i ] [ low_column ] , end = " ▁ " ) NEW_LINE low_column -= 1 NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT

BLEU: 61.97
Edit Sim: 388


Src: 
int countSeq ( int n ) { int nCr = 1 , res = 1 ; for ( int r = 1 ; r <= n ; r ++ ) { nCr = ( nCr * ( n + 1 - r ) ) / r ; res += nCr * nCr ; } return res ; }
Ref: 
def countSeq ( n ) : NEW_LINE INDENT nCr = 1 NEW_LINE res = 1 NEW_LINE for r in range ( 1 , n + 1 ) : NEW_LINE INDENT nCr = ( nCr * ( n + 1 - r ) ) / r ; NEW_LINE res += nCr * nCr ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT
Hyp: 
def countSeq ( n ) : NEW_LINE INDENT nCr = 1 NEW_LINE res = 1 NEW_LINE for r in range ( 1 , n + 1 ) : NEW_LINE INDENT nCr = ( nCr * ( n + 1 - r ) ) / r NEW_LINE res += nCr * nCr NEW_LINE DEDENT return res NEW_LINE DEDENT

BLEU: 87.48
Edit Sim: 6


Src: 
double areaOctagon ( double side ) { return ( float ) ( 2 * ( 1 + sqrt ( 2 ) ) * side * side ) ; }
Ref: 
def areaOctagon ( side ) : NEW_LINE INDENT return ( 2 * ( 1 + ( math . sqrt ( 2 ) ) ) * side * side ) NEW_LINE DEDENT
Hyp: 
def areaOctagon ( side ) : NEW_LINE INDENT return ( float ) ( 2 * ( 1 + math . sqrt ( 2 ) ) * side * side ) NEW_LINE DEDENT

BLEU: 83.19
Edit Sim: 14


Src: 
int findLongestConseqSubseq ( int arr [ ] , int n ) { unordered_set < int > S ; for ( int i = 0 ; i < n ; i ++ ) S . insert ( arr [ i ] ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( S . find ( arr [ i ] - 1 ) == S . end ( ) ) { int j = arr [ i ] ; while ( S . find ( j ) != S . end ( ) ) j ++ ; ans = max ( ans , j - arr [ i ] ) ; } } return ans ; }
Ref: 
def findLongestConseqSubseq ( arr , n ) : NEW_LINE INDENT S = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT S . add ( arr [ i ] ) NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if S . __contains__ ( arr [ i ] ) : NEW_LINE INDENT j = arr [ i ] NEW_LINE while ( S . __contains__ ( j ) ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT ans = max ( ans , j - arr [ i ] ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
Hyp: 
def findLongestConseqSubseq ( arr , n ) : NEW_LINE INDENT s = Set ( ) NEW_LINE for ele in arr : NEW_LINE INDENT s . add ( ele ) NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] - 1 ) not in s : NEW_LINE INDENT j = arr [ i ] NEW_LINE while ( j in s ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT ans = max ( ans , j - arr [ i ] ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT

BLEU: 68.45
Edit Sim: 66


Src: 
void printSuperSeq ( string & a , string & b ) { int m = a . length ( ) , n = b . length ( ) ; int dp [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( ! i ) dp [ i ] [ j ] = j ; else if ( ! j ) dp [ i ] [ j ] = i ; else if ( a [ i - 1 ] == b [ j - 1 ] ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = 1 + min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) ; } } int index = dp [ m ] [ n ] ; string res ( index + 1 , ' \0' ) ; int i = m , j = n ; while ( i > 0 && j > 0 ) { if ( a [ i - 1 ] == b [ j - 1 ] ) { res [ index - 1 ] = a [ i - 1 ] ; i -- ; j -- ; index -- ; } else if ( dp [ i - 1 ] [ j ] < dp [ i ] [ j - 1 ] ) { res [ index - 1 ] = a [ i - 1 ] ; i -- ; index -- ; } else { res [ index - 1 ] = b [ j - 1 ] ; j -- ; index -- ; } } while ( i > 0 ) { res [ index - 1 ] = a [ i - 1 ] ; i -- ; index -- ; } while ( j > 0 ) { res [ index - 1 ] = b [ j - 1 ] ; j -- ; index -- ; } cout << res ; }
Ref: 
def printSuperSeq ( a , b ) : NEW_LINE INDENT m = len ( a ) NEW_LINE n = len ( b ) NEW_LINE dp = [ [ 0 ] * ( n + 1 ) for i in range ( m + 1 ) ] NEW_LINE for i in range ( 0 , m + 1 ) : NEW_LINE INDENT for j in range ( 0 , n + 1 ) : NEW_LINE INDENT if not i : NEW_LINE INDENT dp [ i ] [ j ] = j NEW_LINE DEDENT elif not j : NEW_LINE INDENT dp [ i ] [ j ] = i NEW_LINE DEDENT elif ( a [ i - 1 ] == b [ j - 1 ] ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = 1 + min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT index = dp [ m ] [ n ] NEW_LINE res = [ " " ] * ( index ) NEW_LINE i = m NEW_LINE j = n NEW_LINE while ( i > 0 and j > 0 ) : NEW_LINE INDENT if ( a [ i - 1 ] == b [ j - 1 ] ) : NEW_LINE INDENT res [ index - 1 ] = a [ i - 1 ] NEW_LINE i -= 1 NEW_LINE j -= 1 NEW_LINE index -= 1 NEW_LINE DEDENT elif ( dp [ i - 1 ] [ j ] < dp [ i ] [ j - 1 ] ) : NEW_LINE INDENT res [ index - 1 ] = a [ i - 1 ] NEW_LINE i -= 1 NEW_LINE index -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT res [ index - 1 ] = b [ j - 1 ] NEW_LINE j -= 1 NEW_LINE index -= 1 NEW_LINE DEDENT DEDENT while ( i > 0 ) : NEW_LINE INDENT res [ index - 1 ] = a [ i - 1 ] NEW_LINE i -= 1 NEW_LINE index -= 1 NEW_LINE DEDENT while ( j > 0 ) : NEW_LINE INDENT res [ index - 1 ] = b [ j - 1 ] NEW_LINE j -= 1 NEW_LINE index -= 1 NEW_LINE DEDENT print ( " " . join ( res ) ) NEW_LINE DEDENT
Hyp: 
def printSuperSeq ( a , b ) : NEW_LINE INDENT m = len ( a ) NEW_LINE n = len ( b ) NEW_LINE dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT dp [ i ] [ j ] = i NEW_LINE DEDENT elif ( a [ i - 1 ] == b [ j - 1 ] ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = 1 + min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT index = dp [ m ] [ n ] NEW_LINE res = " " NEW_LINE i = m NEW_LINE j = n NEW_LINE while ( i > 0 and j > 0 ) : NEW_LINE INDENT if ( a [ i - 1 ] == b [ j - 1 ] ) : NEW_LINE INDENT res [ index - 1 ] = a [ i - 1 ] NEW_LINE i -= 1 NEW_LINE j -= 1 NEW_LINE index -= 1 NEW_LINE DEDENT elif ( dp [ i - 1 ] [ j ] < dp [ i ] [ j - 1 ] ) : NEW_LINE INDENT res [ index - 1 ] = a [ i - 1 ] NEW_LINE i -= 1 NEW_LINE index -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT res [ index - 1 ] = b [ j - 1 ] NEW_LINE j -= 1 NEW_LINE index -= 1 NEW_LINE DEDENT DEDENT while ( i > 0 ) : NEW_LINE INDENT res [ index - 1 ] = a [ i - 1 ] NEW_LINE i -= 1 NEW_LINE index -= 1 NEW_LINE DEDENT while ( j > 0 ) : NEW_LINE INDENT res [ index - 1 ] = b [ j - 1 ] NEW_LINE j -= 1 NEW_LINE index -= 1 NEW_LINE DEDENT DEDENT while ( j > 0 ) : NEW_LINE INDENT res [ index - 1 ] = b [ j

BLEU: 88.73
Edit Sim: 151


Src: 
int numberOfPaths ( int m , int n ) { int dp [ n ] = { 1 } ; dp [ 0 ] = 1 ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) { dp [ j ] += dp [ j - 1 ] ; } } return dp [ n - 1 ] ; }
Ref: 
def numberOfPaths ( p , q ) : NEW_LINE INDENT dp = [ 1 for i in range ( q ) ] NEW_LINE for i in range ( p - 1 ) : NEW_LINE INDENT for j in range ( 1 , q ) : NEW_LINE INDENT dp [ j ] += dp [ j - 1 ] NEW_LINE DEDENT DEDENT return dp [ q - 1 ] NEW_LINE DEDENT
Hyp: 
def numberOfPaths ( m , n ) : NEW_LINE INDENT dp = [ 0 for _ in range ( n ) ] NEW_LINE dp [ 0 ] = 1 NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT dp [ j ] += dp [ j - 1 ] NEW_LINE DEDENT DEDENT return dp [ n - 1 ] NEW_LINE DEDENT

BLEU: 63.82
Edit Sim: 34


Src: 
bool isPowerOfFour ( unsigned int n ) { int count = 0 ; if ( n && ! ( n & ( n - 1 ) ) ) { while ( n > 1 ) { n >>= 1 ; count += 1 ; } return ( count % 2 == 0 ) ? 1 : 0 ; } return 0 ; }
Ref: 
def isPowerOfFour ( n ) : NEW_LINE INDENT count = 0 NEW_LINE if ( n and ( not ( n & ( n - 1 ) ) ) ) : NEW_LINE INDENT while ( n > 1 ) : NEW_LINE INDENT n >>= 1 NEW_LINE count += 1 NEW_LINE DEDENT if ( count % 2 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT
Hyp: 
def isPowerOfFour ( n ) : NEW_LINE INDENT count = 0 NEW_LINE if ( n and not ( n & ( n - 1 ) ) ) : NEW_LINE INDENT while ( n > 1 ) : NEW_LINE INDENT n >>= 1 NEW_LINE count += 1 NEW_LINE DEDENT return ( count % 2 == 0 ) ? 1 : 0 NEW_LINE DEDENT

BLEU: 69.27
Edit Sim: 101


Src: 
int sumofoddFactors ( int n ) { int res = 1 ; while ( n % 2 == 0 ) n = n / 2 ; for ( int i = 3 ; i <= sqrt ( n ) ; i ++ ) { int count = 0 , curr_sum = 1 ; int curr_term = 1 ; while ( n % i == 0 ) { count ++ ; n = n / i ; curr_term *= i ; curr_sum += curr_term ; } res *= curr_sum ; } if ( n >= 2 ) res *= ( 1 + n ) ; return res ; }
Ref: 
def sumofoddFactors ( n ) : NEW_LINE INDENT res = 1 NEW_LINE while n % 2 == 0 : NEW_LINE INDENT n = n // 2 NEW_LINE DEDENT for i in range ( 3 , int ( math . sqrt ( n ) + 1 ) ) : NEW_LINE INDENT count = 0 NEW_LINE curr_sum = 1 NEW_LINE curr_term = 1 NEW_LINE while n % i == 0 : NEW_LINE INDENT count += 1 NEW_LINE n = n // i NEW_LINE curr_term *= i NEW_LINE curr_sum += curr_term NEW_LINE DEDENT res *= curr_sum NEW_LINE DEDENT if n >= 2 : NEW_LINE INDENT res *= ( 1 + n ) NEW_LINE DEDENT return res NEW_LINE DEDENT
Hyp: 
def sumofoddFactors ( n ) : NEW_LINE INDENT res = 1 NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT n = n / 2 NEW_LINE DEDENT for i in range ( 3 , int ( m . sqrt ( n ) + 1 ) ) : NEW_LINE INDENT count = 0 NEW_LINE curr_sum = 1 NEW_LINE curr_term = 1 NEW_LINE while ( n % i == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE n = n / i NEW_LINE curr_term = curr_term * i NEW_LINE curr_sum += curr_term NEW_LINE DEDENT res = res * curr_sum NEW_LINE DEDENT if ( n > 2 ) : NEW_LINE INDENT res = res * ( 1 + n ) NEW_LINE DEDENT return res NEW_LINE DEDENT

BLEU: 69.87
Edit Sim: 45


Src: 
int findElement ( int arr [ ] , int n ) { int leftMax [ n ] ; leftMax [ 0 ] = INT_MIN ; for ( int i = 1 ; i < n ; i ++ ) leftMax [ i ] = max ( leftMax [ i - 1 ] , arr [ i - 1 ] ) ; int rightMin = INT_MAX ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( leftMax [ i ] < arr [ i ] && rightMin > arr [ i ] ) return i ; rightMin = min ( rightMin , arr [ i ] ) ; } return - 1 ; }
Ref: 
def findElement ( arr , n ) : NEW_LINE INDENT leftMax = [ None ] * n NEW_LINE leftMax [ 0 ] = float ( ' - inf ' ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT leftMax [ i ] = max ( leftMax [ i - 1 ] , arr [ i - 1 ] ) NEW_LINE DEDENT rightMin = float ( ' inf ' ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if leftMax [ i ] < arr [ i ] and rightMin > arr [ i ] : NEW_LINE INDENT return i NEW_LINE DEDENT rightMin = min ( rightMin , arr [ i ] ) NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
Hyp: 
def findElement ( arr , n ) : NEW_LINE INDENT leftMax = [ 0 ] * n NEW_LINE leftMax [ 0 ] = - sys . maxsize - 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT leftMax [ i ] = max ( leftMax [ i - 1 ] , arr [ i - 1 ] ) NEW_LINE DEDENT rightMin = sys . maxsize NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( leftMax [ i ] < arr [ i ] and rightMin > arr [ i ] ) : NEW_LINE INDENT return i NEW_LINE DEDENT rightMin = min ( rightMin , arr [ i ] ) NEW_LINE DEDENT return - 1 NEW_LINE DEDENT

BLEU: 84.38
Edit Sim: 37


Src: 
int search ( int arr [ ] , int l , int h , int key ) { if ( l > h ) return - 1 ; int mid = ( l + h ) / 2 ; if ( arr [ mid ] == key ) return mid ; if ( arr [ l ] <= arr [ mid ] ) { if ( key >= arr [ l ] && key <= arr [ mid ] ) return search ( arr , l , mid - 1 , key ) ; return search ( arr , mid + 1 , h , key ) ; } if ( key >= arr [ mid ] && key <= arr [ h ] ) return search ( arr , mid + 1 , h , key ) ; return search ( arr , l , mid - 1 , key ) ; }
Ref: 
def search ( arr , l , h , key ) : NEW_LINE INDENT if l > h : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = ( l + h ) // 2 NEW_LINE if arr [ mid ] == key : NEW_LINE INDENT return mid NEW_LINE DEDENT if arr [ l ] <= arr [ mid ] : NEW_LINE INDENT if key >= arr [ l ] and key <= arr [ mid ] : NEW_LINE INDENT return search ( arr , l , mid - 1 , key ) NEW_LINE DEDENT return search ( arr , mid + 1 , h , key ) NEW_LINE DEDENT if key >= arr [ mid ] and key <= arr [ h ] : NEW_LINE INDENT return search ( a , mid + 1 , h , key ) NEW_LINE DEDENT return search ( arr , l , mid - 1 , key ) NEW_LINE DEDENT
Hyp: 
def search ( arr , l , h , key ) : NEW_LINE INDENT if ( l > h ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = int ( ( l + h ) / 2 ) NEW_LINE if ( arr [ mid ] == key ) : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( arr [ l ] <= arr [ mid ] ) : NEW_LINE INDENT if ( key >= arr [ l ] and key <= arr [ mid ] ) : NEW_LINE INDENT return search ( arr , l , mid - 1 , key ) NEW_LINE DEDENT return search ( arr , mid + 1 , h , key ) NEW_LINE DEDENT if ( key >= arr [ mid ] and key <= arr [ h ] ) : NEW_LINE INDENT return search ( arr , mid + 1 , h , key ) NEW_LINE DEDENT return search ( arr , l , mid - 1 , key ) NEW_LINE DEDENT

BLEU: 78.81
Edit Sim: 31


Src: 
long int exponentiation ( long int base , long int exp ) { if ( exp == 0 ) return 1 ; if ( exp == 1 ) return base % N ; long int t = exponentiation ( base , exp / 2 ) ; t = ( t * t ) % N ; if ( exp % 2 == 0 ) return t ; else return ( ( base % N ) * t ) % N ; }
Ref: 
def exponentiation ( bas , exp ) : NEW_LINE INDENT if ( exp == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( exp == 1 ) : NEW_LINE INDENT return bas % N NEW_LINE DEDENT t = exponentiation ( bas , int ( exp / 2 ) ) NEW_LINE t = ( t * t ) % N NEW_LINE if ( exp % 2 == 0 ) : NEW_LINE INDENT return t NEW_LINE DEDENT else : NEW_LINE INDENT return ( ( bas % N ) * t ) % N NEW_LINE DEDENT DEDENT
Hyp: 
def exponentiation ( base , exp ) : NEW_LINE INDENT if ( exp == 0 ) : return 1 NEW_LINE if ( exp == 1 ) : return base % N NEW_LINE DEDENT t = exponentiation ( base , int ( exp / 2 ) ) NEW_LINE t = ( t * t ) % N NEW_LINE if ( exp % 2 == 0 ) : NEW_LINE INDENT return t NEW_LINE DEDENT else : NEW_LINE INDENT return ( ( base % N ) * t ) % N NEW_LINE DEDENT DEDENT

BLEU: 79.82
Edit Sim: 43


Src: 
void divisibilityCheck ( int arr [ ] , int n ) { unordered_set < int > s ; int max_ele = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { s . insert ( arr [ i ] ) ; max_ele = max ( max_ele , arr [ i ] ) ; } unordered_set < int > res ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != 0 ) { for ( int j = arr [ i ] * 2 ; j <= max_ele ; j += arr [ i ] ) { if ( s . find ( j ) != s . end ( ) ) res . insert ( j ) ; } } } unordered_map < int , int > mp ; for ( int i = 0 ; i < n ; i ++ ) mp [ arr [ i ] ] ++ ; unordered_map < int , int > :: iterator it ; vector < int > ans ; for ( it = mp . begin ( ) ; it != mp . end ( ) ; it ++ ) { if ( it -> second >= 2 ) { if ( res . find ( it -> first ) == res . end ( ) ) { int val = it -> second ; while ( val -- ) ans . push_back ( it -> first ) ; } } if ( res . find ( it -> first ) != res . end ( ) ) { int val = it -> second ; while ( val -- ) ans . push_back ( it -> first ) ; } } for ( auto x : ans ) cout << x << " ▁ " ; }
Ref: 
def divisibilityCheck ( arr , n ) : NEW_LINE INDENT s = dict ( ) NEW_LINE max_ele = - 10 ** 9 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s [ arr [ i ] ] = 1 NEW_LINE max_ele = max ( max_ele , arr [ i ] ) NEW_LINE DEDENT res = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] != 0 ) : NEW_LINE INDENT for j in range ( arr [ i ] * 2 , max_ele + 1 , arr [ i ] ) : NEW_LINE INDENT if ( j in s . keys ( ) ) : NEW_LINE INDENT res [ j ] = 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT for x in res : NEW_LINE INDENT print ( x , end = " ▁ " ) NEW_LINE DEDENT DEDENT
Hyp: 
def divisibilityCheck ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE max_ele = - sys . maxsize - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . add ( arr [ i ] ) NEW_LINE max_ele = max ( max_ele , arr [ i ] ) NEW_LINE DEDENT res = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] != 0 : NEW_LINE INDENT for j in range ( arr [ i ] * 2 , max_ele + arr [ i ] ) : NEW_LINE INDENT if ( s . get ( j ) in s ) : NEW_LINE INDENT res . add ( j ) NEW_LINE DEDENT DEDENT DEDENT DEDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT ans = [ ] NEW_LINE for key , values in mp . items ( ) : NEW_LINE INDENT if values >= 2 : NEW_LINE INDENT if values in res : NEW_LINE INDENT val = res . get ( key ) NEW_LINE while val in s : NEW_LINE INDENT ans . append ( key ) NEW_LINE DEDENT DEDENT if values in res : NEW_LINE INDENT val = res . get ( key ) NEW_LINE while val > 0 : NEW_LINE INDENT ans . append ( key ) NEW_LINE DEDENT DEDENT for key in ans : NEW_LINE INDENT print ( key , end = " ▁ " ) NEW_LINE DEDENT DEDENT

BLEU: 43.37
Edit Sim: 550


Src: 
void printRepeating ( int arr [ ] , int size ) { int i ; cout << " The ▁ repeating ▁ elements ▁ are " ; for ( i = 0 ; i < size ; i ++ ) { if ( arr [ abs ( arr [ i ] ) ] > 0 ) arr [ abs ( arr [ i ] ) ] = - arr [ abs ( arr [ i ] ) ] ; else cout << " ▁ " << abs ( arr [ i ] ) << " ▁ " ; } }
Ref: 
def printRepeating ( arr , size ) : NEW_LINE INDENT print ( " ▁ The ▁ repeating ▁ elements ▁ are " , end = " ▁ " ) NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT if ( arr [ abs ( arr [ i ] ) ] > 0 ) : NEW_LINE INDENT arr [ abs ( arr [ i ] ) ] = ( - 1 ) * arr [ abs ( arr [ i ] ) ] NEW_LINE DEDENT else : NEW_LINE INDENT print ( abs ( arr [ i ] ) , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
Hyp: 
def printRepeating ( arr , size ) : NEW_LINE INDENT for i in range ( size ) : NEW_LINE INDENT if arr [ abs ( arr [ i ] ) ] > 0 : NEW_LINE INDENT arr [ abs ( arr [ i ] ) ] = - arr [ abs ( arr [ i ] ) ] NEW_LINE DEDENT else : NEW_LINE INDENT print ( " ▁ " , abs ( arr [ i ] ) , " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT

BLEU: 62.94
Edit Sim: 102


Src: 
int minPalPartion ( char * str ) { int n = strlen ( str ) ; int C [ n ] [ n ] ; bool P [ n ] [ n ] ; int i , j , k , L ; for ( i = 0 ; i < n ; i ++ ) { P [ i ] [ i ] = true ; C [ i ] [ i ] = 0 ; } for ( L = 2 ; L <= n ; L ++ ) { for ( i = 0 ; i < n - L + 1 ; i ++ ) { j = i + L - 1 ; if ( L == 2 ) P [ i ] [ j ] = ( str [ i ] == str [ j ] ) ; else P [ i ] [ j ] = ( str [ i ] == str [ j ] ) && P [ i + 1 ] [ j - 1 ] ; if ( P [ i ] [ j ] == true ) C [ i ] [ j ] = 0 ; else { C [ i ] [ j ] = INT_MAX ; for ( k = i ; k <= j - 1 ; k ++ ) C [ i ] [ j ] = min ( C [ i ] [ j ] , C [ i ] [ k ] + C [ k + 1 ] [ j ] + 1 ) ; } } } return C [ 0 ] [ n - 1 ] ; }
Ref: 
def minPalPartion ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE C = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] NEW_LINE P = [ [ False for i in range ( n ) ] for i in range ( n ) ] NEW_LINE j = 0 NEW_LINE k = 0 NEW_LINE L = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT P [ i ] [ i ] = True NEW_LINE C [ i ] [ i ] = 0 NEW_LINE DEDENT for L in range ( 2 , n + 1 ) : NEW_LINE INDENT for i in range ( n - L + 1 ) : NEW_LINE INDENT j = i + L - 1 NEW_LINE if L == 2 : NEW_LINE INDENT P [ i ] [ j ] = ( str [ i ] == str [ j ] ) NEW_LINE DEDENT else : NEW_LINE INDENT P [ i ] [ j ] = ( ( str [ i ] == str [ j ] ) and P [ i + 1 ] [ j - 1 ] ) NEW_LINE DEDENT if P [ i ] [ j ] == True : NEW_LINE INDENT C [ i ] [ j ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = 100000000 NEW_LINE for k in range ( i , j ) : NEW_LINE INDENT C [ i ] [ j ] = min ( C [ i ] [ j ] , C [ i ] [ k ] + C [ k + 1 ] [ j ] + 1 ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return C [ 0 ] [ n - 1 ] NEW_LINE DEDENT
Hyp: 
def minPalPartion ( str1 ) : NEW_LINE INDENT n = len ( str1 ) NEW_LINE C = [ [ 0 for x in range ( n + 1 ) ] for y in range ( n + 1 ) ] NEW_LINE P = [ [ False for x in range ( n + 1 ) ] for y in range ( n + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT P [ i ] [ i ] = True NEW_LINE C [ i ] [ i ] = 0 NEW_LINE DEDENT for L in range ( 2 , n + 1 ) : NEW_LINE INDENT for i in range ( n - L + 1 ) : NEW_LINE INDENT j = i + L - 1 NEW_LINE if ( L == 2 ) : NEW_LINE INDENT P [ i ] [ j ] = ( str1 [ i ] == str1 [ j ] ) NEW_LINE DEDENT else : NEW_LINE INDENT P [ i ] [ j ] = ( ( str1 [ i ] == str1 [ j ] ) and P [ i + 1 ] [ j - 1 ] ) NEW_LINE DEDENT if ( P [ i ] [ j ] == True ) : NEW_LINE INDENT C [ i ] [ j ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = sys . maxsize NEW_LINE for k in range ( i , j - 1 ) : NEW_LINE INDENT C [ i ] [ j ] = min ( C [ i ] [ j ] , C [ i ] [ k ] + C [ k + 1 ] [ j ] + 1 ) NEW_LINE DEDENT DEDENT DEDENT return C [ 0 ] [ n - 1 ] NEW_LINE DEDENT

BLEU: 81.15
Edit Sim: 99


Src: 
int height ( int N ) { return ceil ( log2 ( N + 1 ) ) - 1 ; }
Ref: 
def height ( N ) : NEW_LINE INDENT return math . ceil ( math . log2 ( N + 1 ) ) - 1 NEW_LINE DEDENT
Hyp: 
def height ( N ) : NEW_LINE INDENT return math . ceil ( math . log2 ( N + 1 ) ) - 1 NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
bool checkCount ( int arr [ ] , int n , int k ) { unordered_map < int , int > hash ; for ( int i = 0 ; i < n ; i ++ ) hash [ arr [ i ] ] ++ ; for ( auto x : hash ) if ( x . second > 2 * k ) return false ; return true ; }
Ref: 
def checkCount ( arr , n , k ) : NEW_LINE INDENT mp = defaultdict ( lambda : 0 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT for key , values in mp . items ( ) : NEW_LINE INDENT if values > 2 * k : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
Hyp: 
def checkCount ( arr , n , k ) : NEW_LINE INDENT Hash = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT Hash [ arr [ i ] ] = Hash . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT for x in Hash : NEW_LINE INDENT if ( Hash [ x ] > 2 * k ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT

BLEU: 57.92
Edit Sim: 93


Src: 
void removeDuplicates ( char S [ ] ) { int n = strlen ( S ) ; if ( n < 2 ) return ; int j = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( S [ j ] != S [ i ] ) { j ++ ; S [ j ] = S [ i ] ; } } j ++ ; S [ j ] = ' \0' ; }
Ref: 
def removeDuplicates ( S ) : NEW_LINE INDENT n = len ( S ) NEW_LINE if ( n < 2 ) : NEW_LINE INDENT return NEW_LINE DEDENT j = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( S [ j ] != S [ i ] ) : NEW_LINE INDENT j += 1 NEW_LINE S [ j ] = S [ i ] NEW_LINE DEDENT DEDENT j += 1 NEW_LINE S = S [ : j ] NEW_LINE return S NEW_LINE DEDENT
Hyp: 
def removeDuplicates ( S ) : NEW_LINE INDENT n = len ( S ) NEW_LINE if ( n < 2 ) : NEW_LINE INDENT return NEW_LINE DEDENT j = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( S [ j ] != S [ i ] ) : NEW_LINE INDENT j += 1 NEW_LINE S [ j ] = S [ i ] NEW_LINE DEDENT DEDENT j += 1 NEW_LINE S [ j ] = ' \0' NEW_LINE DEDENT DEDENT

BLEU: 88.13
Edit Sim: 27


Src: 
void thirdLargest ( int arr [ ] , int arr_size ) { if ( arr_size < 3 ) { printf ( " ▁ Invalid ▁ Input ▁ " ) ; return ; } int first = arr [ 0 ] , second = INT_MIN , third = INT_MIN ; for ( int i = 1 ; i < arr_size ; i ++ ) { if ( arr [ i ] > first ) { third = second ; second = first ; first = arr [ i ] ; } else if ( arr [ i ] > second ) { third = second ; second = arr [ i ] ; } else if ( arr [ i ] > third ) third = arr [ i ] ; } printf ( " The ▁ third ▁ Largest ▁ element ▁ is ▁ % d \n " , third ) ; }
Ref: 
def thirdLargest ( arr , arr_size ) : NEW_LINE INDENT if ( arr_size < 3 ) : NEW_LINE INDENT print ( " ▁ Invalid ▁ Input ▁ " ) NEW_LINE return NEW_LINE DEDENT first = arr [ 0 ] NEW_LINE second = - sys . maxsize NEW_LINE third = - sys . maxsize NEW_LINE for i in range ( 1 , arr_size ) : NEW_LINE INDENT if ( arr [ i ] > first ) : NEW_LINE INDENT third = second NEW_LINE second = first NEW_LINE first = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > second ) : NEW_LINE INDENT third = second NEW_LINE second = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > third ) : NEW_LINE INDENT third = arr [ i ] NEW_LINE DEDENT DEDENT print ( " The ▁ third ▁ Largest " , " element ▁ is " , third ) NEW_LINE DEDENT
Hyp: 
def thirdLargest ( arr , arr_size ) : NEW_LINE INDENT if arr_size < 3 : NEW_LINE INDENT print ( " ▁ Invalid ▁ Input ▁ " ) NEW_LINE return NEW_LINE DEDENT first = arr [ 0 ] NEW_LINE second = INT_MIN NEW_LINE third = INT_MIN NEW_LINE for i in range ( 1 , arr_size ) : NEW_LINE INDENT if arr [ i ] > first : NEW_LINE INDENT third = second NEW_LINE second = first NEW_LINE first = arr [ i ] NEW_LINE DEDENT elif arr [ i ] > second : NEW_LINE INDENT third = second NEW_LINE second = arr [ i ] NEW_LINE DEDENT elif arr [ i ] > third : NEW_LINE INDENT third = arr [ i ] NEW_LINE DEDENT DEDENT print ( " The ▁ third ▁ Largest ▁ element ▁ is " , third ) NEW_LINE DEDENT

BLEU: 76.72
Edit Sim: 51


Src: 
int longOddEvenIncSeq ( int arr [ ] , int n ) { int lioes [ n ] ; int maxLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) lioes [ i ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && ( arr [ i ] + arr [ j ] ) % 2 != 0 && lioes [ i ] < lioes [ j ] + 1 ) lioes [ i ] = lioes [ j ] + 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( maxLen < lioes [ i ] ) maxLen = lioes [ i ] ; return maxLen ; }
Ref: 
def longOddEvenIncSeq ( arr , n ) : NEW_LINE INDENT lioes = list ( ) NEW_LINE maxLen = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT lioes . append ( 1 ) NEW_LINE DEDENT i = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and ( arr [ i ] + arr [ j ] ) % 2 != 0 and lioes [ i ] < lioes [ j ] + 1 ) : NEW_LINE INDENT lioes [ i ] = lioes [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if maxLen < lioes [ i ] : NEW_LINE INDENT maxLen = lioes [ i ] NEW_LINE DEDENT DEDENT return maxLen NEW_LINE DEDENT
Hyp: 
def longOddEvenIncSeq ( arr , n ) : NEW_LINE INDENT lioes = [ 0 ] * n NEW_LINE maxLen = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT lioes [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( 0 , i ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and ( arr [ i ] + arr [ j ] ) % 2 != 0 and lioes [ i ] < lioes [ j ] + 1 ) : NEW_LINE INDENT lioes [ i ] = lioes [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( maxLen < lioes [ i ] ) : NEW_LINE INDENT maxLen = lioes [ i ] NEW_LINE DEDENT DEDENT return maxLen NEW_LINE DEDENT

BLEU: 80.43
Edit Sim: 52


Src: 
int addOne ( int x ) { return ( - ( ~ x ) ) ; }
Ref: 
def addOne ( x ) : NEW_LINE INDENT return ( - ( ~ x ) ) NEW_LINE DEDENT
Hyp: 
def addOne ( x ) : NEW_LINE INDENT return ( - ( ~ x ) ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int getNumStrictMonotone ( int len ) { int DP [ len ] [ DP_s ] ; memset ( DP , 0 , sizeof ( DP ) ) ; for ( int i = 0 ; i < DP_s ; ++ i ) DP [ 0 ] [ i ] = i + 1 ; for ( int i = 1 ; i < len ; ++ i ) for ( int j = 1 ; j < DP_s ; ++ j ) DP [ i ] [ j ] = DP [ i - 1 ] [ j - 1 ] + DP [ i ] [ j - 1 ] ; return DP [ len - 1 ] [ DP_s - 1 ] ; }
Ref: 
def getNumStrictMonotone ( ln ) : NEW_LINE INDENT DP = [ [ 0 ] * DP_s for _ in range ( ln ) ] NEW_LINE for i in range ( DP_s ) : NEW_LINE INDENT DP [ 0 ] [ i ] = i + 1 NEW_LINE DEDENT for i in range ( 1 , ln ) : NEW_LINE INDENT for j in range ( 1 , DP_s ) : NEW_LINE INDENT DP [ i ] [ j ] = DP [ i - 1 ] [ j - 1 ] + DP [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT return DP [ ln - 1 ] [ DP_s - 1 ] NEW_LINE DEDENT
Hyp: 
def getNumStrictMonotone ( len ) : NEW_LINE INDENT DP = [ [ 0 for i in range ( DP_s ) ] for j in range ( DP_s ) ] NEW_LINE for i in range ( 0 , DP_s ) : NEW_LINE INDENT DP [ 0 ] [ i ] = i + 1 NEW_LINE DEDENT for i in range ( 1 , len ) : NEW_LINE INDENT for j in range ( 1 , DP_s ) : NEW_LINE INDENT DP [ i ] [ j ] = DP [ i - 1 ] [ j - 1 ] + DP [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT return DP [ len - 1 ] [ DP_s - 1 ] NEW_LINE DEDENT

BLEU: 81.27
Edit Sim: 31


Src: 
int binarySearch ( int arr [ ] , int l , int r , int x ) { if ( r >= l ) { int mid = l + ( r - l ) / 2 ; if ( arr [ mid ] == x ) return mid ; if ( mid > l && arr [ mid - 1 ] == x ) return ( mid - 1 ) ; if ( mid < r && arr [ mid + 1 ] == x ) return ( mid + 1 ) ; if ( arr [ mid ] > x ) return binarySearch ( arr , l , mid - 2 , x ) ; return binarySearch ( arr , mid + 2 , r , x ) ; } return - 1 ; }
Ref: 
def binarySearch ( arr , l , r , x ) : NEW_LINE INDENT if ( r >= l ) : NEW_LINE INDENT mid = int ( l + ( r - l ) / 2 ) NEW_LINE if ( arr [ mid ] == x ) : return mid NEW_LINE if ( mid > l and arr [ mid - 1 ] == x ) : NEW_LINE INDENT return ( mid - 1 ) NEW_LINE DEDENT if ( mid < r and arr [ mid + 1 ] == x ) : NEW_LINE INDENT return ( mid + 1 ) NEW_LINE DEDENT if ( arr [ mid ] > x ) : NEW_LINE INDENT return binarySearch ( arr , l , mid - 2 , x ) NEW_LINE DEDENT return binarySearch ( arr , mid + 2 , r , x ) NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
Hyp: 
def binarySearch ( arr , l , r , x ) : NEW_LINE INDENT if ( r >= l ) : NEW_LINE INDENT mid = l + ( r - l ) // 2 NEW_LINE if ( arr [ mid ] == x ) : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( mid > l and arr [ mid - 1 ] == x ) : NEW_LINE INDENT return ( mid - 1 ) NEW_LINE DEDENT if ( mid < r and arr [ mid + 1 ] == x ) : NEW_LINE INDENT return ( mid + 1 ) NEW_LINE DEDENT if ( arr [ mid ] > x ) : NEW_LINE INDENT return binarySearch ( arr , l , mid - 2 , x ) NEW_LINE DEDENT return binarySearch ( arr , mid + 2 , r , x ) NEW_LINE DEDENT

BLEU: 89.82
Edit Sim: 59


Src: 
void bresenham ( int x1 , int y1 , int x2 , int y2 ) { int m_new = 2 * ( y2 - y1 ) ; int slope_error_new = m_new - ( x2 - x1 ) ; for ( int x = x1 , y = y1 ; x <= x2 ; x ++ ) { cout << " ( " << x << " , " << y << " ) \n " ; slope_error_new += m_new ; if ( slope_error_new >= 0 ) { y ++ ; slope_error_new -= 2 * ( x2 - x1 ) ; } } }
Ref: 
def bresenham ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT m_new = 2 * ( y2 - y1 ) NEW_LINE slope_error_new = m_new - ( x2 - x1 ) NEW_LINE y = y1 NEW_LINE for x in range ( x1 , x2 + 1 ) : NEW_LINE INDENT print ( " ( " , x , " , " , y , " ) \n " ) NEW_LINE slope_error_new = slope_error_new + m_new NEW_LINE if ( slope_error_new >= 0 ) : NEW_LINE INDENT y = y + 1 NEW_LINE slope_error_new = slope_error_new - 2 * ( x2 - x1 ) NEW_LINE DEDENT DEDENT DEDENT
Hyp: 
def bresenham ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT m_new = 2 * ( y2 - y1 ) NEW_LINE slope_error_new = m_new - ( x2 - x1 ) NEW_LINE for x in range ( x1 , y1 , x2 + 1 ) : NEW_LINE INDENT print ( " ( " , x , " , " , y , " ) " , slope_error_new ) NEW_LINE if ( slope_error_new >= 0 ) : NEW_LINE INDENT y += 1 NEW_LINE slope_error_new -= 2 * ( x2 - x1 ) NEW_LINE DEDENT DEDENT DEDENT

BLEU: 77.18
Edit Sim: 83


Src: 
int maxRevenue ( int m , int x [ ] , int revenue [ ] , int n , int t ) { int maxRev [ m + 1 ] ; memset ( maxRev , 0 , sizeof ( maxRev ) ) ; int nxtbb = 0 ; for ( int i = 1 ; i <= m ; i ++ ) { if ( nxtbb < n ) { if ( x [ nxtbb ] != i ) maxRev [ i ] = maxRev [ i - 1 ] ; else { if ( i <= t ) maxRev [ i ] = max ( maxRev [ i - 1 ] , revenue [ nxtbb ] ) ; else maxRev [ i ] = max ( maxRev [ i - t - 1 ] + revenue [ nxtbb ] , maxRev [ i - 1 ] ) ; nxtbb ++ ; } } else maxRev [ i ] = maxRev [ i - 1 ] ; } return maxRev [ m ] ; }
Ref: 
def maxRevenue ( m , x , revenue , n , t ) : NEW_LINE INDENT maxRev = [ 0 ] * ( m + 1 ) NEW_LINE nxtbb = 0 NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT if ( nxtbb < n ) : NEW_LINE INDENT if ( x [ nxtbb ] != i ) : NEW_LINE INDENT maxRev [ i ] = maxRev [ i - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT if ( i <= t ) : NEW_LINE INDENT maxRev [ i ] = max ( maxRev [ i - 1 ] , revenue [ nxtbb ] ) NEW_LINE DEDENT else : NEW_LINE INDENT maxRev [ i ] = max ( maxRev [ i - t - 1 ] + revenue [ nxtbb ] , maxRev [ i - 1 ] ) NEW_LINE DEDENT nxtbb += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT maxRev [ i ] = maxRev [ i - 1 ] NEW_LINE DEDENT DEDENT return maxRev [ m ] NEW_LINE DEDENT
Hyp: 
def maxRevenue ( m , x , revenue , n , t ) : NEW_LINE INDENT maxRev = [ 0 for i in range ( m + 1 ) ] NEW_LINE nxtbb = 0 NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT if ( nxtbb < n ) : NEW_LINE INDENT if ( x [ nxtbb ] != i ) : NEW_LINE INDENT maxRev [ i ] = maxRev [ i - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT if ( i <= t ) : NEW_LINE INDENT maxRev [ i ] = max ( maxRev [ i - 1 ] , revenue [ nxtbb ] ) NEW_LINE DEDENT else : NEW_LINE INDENT maxRev [ i ] = max ( maxRev [ i - t - 1 ] + revenue [ nxtbb ] , maxRev [ i - 1 ] ) NEW_LINE nxtbb += 1 NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT maxRev [ i ] = maxRev [ i - 1 ] NEW_LINE DEDENT DEDENT return maxRev [ m ] NEW_LINE DEDENT

BLEU: 94.45
Edit Sim: 29


Src: 
pair < double , double > void lineFromPoints ( pdd P , pdd Q ) { double a = Q . second - P . second ; double b = P . first - Q . first ; double c = a * ( P . first ) + b * ( P . second ) ; if ( b < 0 ) { cout << " The ▁ line ▁ passing ▁ through ▁ points ▁ P ▁ and ▁ Q ▁ is : ▁ " << a << " x ▁ " << b << " y ▁ = ▁ " << c << endl ; } else { cout << " The ▁ line ▁ passing ▁ through ▁ points ▁ P ▁ and ▁ Q ▁ is : ▁ " << a << " x ▁ + ▁ " << b << " y ▁ = ▁ " << c << endl ; } }
Ref: 
def lineFromPoints ( P , Q ) : NEW_LINE INDENT a = Q [ 1 ] - P [ 1 ] NEW_LINE b = P [ 0 ] - Q [ 0 ] NEW_LINE c = a * ( P [ 0 ] ) + b * ( P [ 1 ] ) NEW_LINE if ( b < 0 ) : NEW_LINE INDENT print ( " The ▁ line ▁ passing ▁ through ▁ points ▁ P ▁ and ▁ Q ▁ is : " , a , " x ▁ " , b , " y ▁ = ▁ " , c , " \n " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " The ▁ line ▁ passing ▁ through ▁ points ▁ P ▁ and ▁ Q ▁ is : ▁ " , a , " x ▁ + ▁ " , b , " y ▁ = ▁ " , c , " \n " ) NEW_LINE DEDENT DEDENT
Hyp: 
def lineFromPoints ( P , Q ) : NEW_LINE INDENT a = Q . second - P . second NEW_LINE b = P . first - Q . first NEW_LINE c = a * ( P . first ) + b * ( P . second ) NEW_LINE if ( b < 0 ) : NEW_LINE INDENT print ( " The ▁ line ▁ passing ▁ through ▁ points ▁ P ▁ and ▁ Q ▁ is : ▁ " , a , " x ▁ " , b , " y ▁ = ▁ " , c ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " The ▁ line ▁ passing ▁ through ▁ points ▁ P ▁ and ▁ Q ▁ is : ▁ " , a , " x ▁ + ▁ " , b , " y ▁ = ▁ " , c ) NEW_LINE DEDENT DEDENT

BLEU: 75.78
Edit Sim: 59


Src: 
int findMinX ( int num [ ] , int rem [ ] , int k ) { int x = 1 ; while ( true ) { int j ; for ( j = 0 ; j < k ; j ++ ) if ( x % num [ j ] != rem [ j ] ) break ; if ( j == k ) return x ; x ++ ; } return x ; }
Ref: 
def findMinX ( num , rem , k ) : NEW_LINE INDENT x = 1 NEW_LINE while ( True ) : NEW_LINE INDENT j = 0 NEW_LINE while ( j < k ) : NEW_LINE INDENT if ( x % num [ j ] != rem [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if ( j == k ) : NEW_LINE INDENT return x NEW_LINE DEDENT x += 1 NEW_LINE DEDENT DEDENT
Hyp: 
def findMinX ( num , rem , k ) : NEW_LINE INDENT x = 1 NEW_LINE while ( True ) : NEW_LINE INDENT j = 0 NEW_LINE while ( j < k ) : NEW_LINE INDENT if ( x % num [ j ] != rem [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if ( j == k ) : NEW_LINE INDENT return x NEW_LINE DEDENT x += 1 NEW_LINE DEDENT return x NEW_LINE DEDENT

BLEU: 95.45
Edit Sim: 18


Src: 
bool find3Numbers ( int A [ ] , int arr_size , int sum ) { int l , r ; for ( int i = 0 ; i < arr_size - 2 ; i ++ ) { for ( int j = i + 1 ; j < arr_size - 1 ; j ++ ) { for ( int k = j + 1 ; k < arr_size ; k ++ ) { if ( A [ i ] + A [ j ] + A [ k ] == sum ) { cout << " Triplet ▁ is ▁ " << A [ i ] << " , ▁ " << A [ j ] << " , ▁ " << A [ k ] ; return true ; } } } } return false ; }
Ref: 
def find3Numbers ( A , arr_size , sum ) : NEW_LINE INDENT for i in range ( 0 , arr_size - 2 ) : NEW_LINE INDENT for j in range ( i + 1 , arr_size - 1 ) : NEW_LINE INDENT for k in range ( j + 1 , arr_size ) : NEW_LINE INDENT if A [ i ] + A [ j ] + A [ k ] == sum : NEW_LINE INDENT print ( " Triplet ▁ is " , A [ i ] , " , ▁ " , A [ j ] , " , ▁ " , A [ k ] ) NEW_LINE return True NEW_LINE DEDENT DEDENT DEDENT DEDENT return False NEW_LINE DEDENT
Hyp: 
def find3Numbers ( A , arr_size , sum ) : NEW_LINE INDENT for i in range ( 0 , arr_size - 2 ) : NEW_LINE INDENT for j in range ( i + 1 , arr_size - 1 ) : NEW_LINE INDENT for k in range ( j + 1 , arr_size ) : NEW_LINE INDENT if ( A [ i ] + A [ j ] + A [ k ] == sum ) : NEW_LINE INDENT print ( " Triplet ▁ is " , A [ i ] , " , ▁ " , A [ j ] , " , ▁ " , A [ k ] ) NEW_LINE return True NEW_LINE DEDENT DEDENT DEDENT DEDENT return False NEW_LINE DEDENT

BLEU: 95.88
Edit Sim: 4


Src: 
void KMaxCombinations ( int A [ ] , int B [ ] , int N , int K ) { priority_queue < int > pq ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) pq . push ( A [ i ] + B [ j ] ) ; int count = 0 ; while ( count < K ) { cout << pq . top ( ) << endl ; pq . pop ( ) ; count ++ ; } }
Ref: 
def KMaxCombinations ( A , B , N , K ) : NEW_LINE INDENT pq = PriorityQueue ( ) NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( 0 , N ) : NEW_LINE INDENT a = A [ i ] + B [ j ] NEW_LINE pq . put ( ( - a , a ) ) NEW_LINE DEDENT DEDENT count = 0 NEW_LINE while ( count < K ) : NEW_LINE INDENT print ( pq . get ( ) [ 1 ] ) NEW_LINE count = count + 1 NEW_LINE DEDENT DEDENT
Hyp: 
def KMaxCombinations ( A , B , N , K ) : NEW_LINE INDENT pq = PriorityQueue ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT pq . put ( A [ i ] + B [ j ] ) NEW_LINE DEDENT DEDENT count = 0 NEW_LINE while ( count < K ) : NEW_LINE INDENT print ( pq . get ( ) , end = " " ) NEW_LINE pq . get ( ) NEW_LINE count += 1 NEW_LINE DEDENT DEDENT

BLEU: 72.52
Edit Sim: 76


Src: 
int numberOfSticks ( int x ) { return ( 3 * x * ( x + 1 ) ) / 2 ; }
Ref: 
def numberOfSticks ( x ) : NEW_LINE INDENT return ( 3 * x * ( x + 1 ) ) / 2 NEW_LINE DEDENT
Hyp: 
def numberOfSticks ( x ) : NEW_LINE INDENT return int ( ( 3 * x * ( x + 1 ) ) / 2 ) NEW_LINE DEDENT

BLEU: 77.54
Edit Sim: 8


Src: 
int countSubstringWithEqualEnds ( string s ) { int result = 0 ; int n = s . length ( ) ; int count [ MAX_CHAR ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) count [ s [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) result += ( count [ i ] * ( count [ i ] + 1 ) / 2 ) ; return result ; }
Ref: 
def countSubstringWithEqualEnds ( s ) : NEW_LINE INDENT result = 0 NEW_LINE n = len ( s ) NEW_LINE count = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( n ) : NEW_LINE INDENT count [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( MAX_CHAR ) : NEW_LINE INDENT result += ( count [ i ] * ( count [ i ] + 1 ) / 2 ) NEW_LINE DEDENT return result NEW_LINE DEDENT
Hyp: 
def countSubstringWithEqualEnds ( s ) : NEW_LINE INDENT result = 0 NEW_LINE n = len ( s ) NEW_LINE count = [ 0 for i in range ( MAX_CHAR ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT count [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( MAX_CHAR ) : NEW_LINE INDENT result += count [ i ] * ( count [ i ] + 1 ) // 2 NEW_LINE DEDENT return int ( result ) NEW_LINE DEDENT

BLEU: 81.65
Edit Sim: 32


Src: 
int isDivisibleBy7 ( int num ) { if ( num < 0 ) return isDivisibleBy7 ( - num ) ; if ( num == 0 || num == 7 ) return 1 ; if ( num < 10 ) return 0 ; return isDivisibleBy7 ( num / 10 - 2 * ( num - num / 10 * 10 ) ) ; }
Ref: 
def isDivisibleBy7 ( num ) : NEW_LINE INDENT if num < 0 : NEW_LINE INDENT return isDivisibleBy7 ( - num ) NEW_LINE DEDENT if ( num == 0 or num == 7 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( num < 10 ) : NEW_LINE INDENT return False NEW_LINE DEDENT return isDivisibleBy7 ( num // 10 - 2 * ( num - num // 10 * 10 ) ) NEW_LINE DEDENT
Hyp: 
def isDivisibleBy7 ( num ) : NEW_LINE INDENT if ( num < 0 ) : NEW_LINE INDENT return isDivisibleBy7 ( - num ) NEW_LINE DEDENT if ( num == 0 or num == 7 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( num < 10 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return isDivisibleBy7 ( num // 10 - 2 * ( num - num // 10 * 10 ) ) NEW_LINE DEDENT

BLEU: 86.45
Edit Sim: 13


Src: 
int findRepeatingNumber ( const int arr [ ] , int n ) { int sq = sqrt ( n ) ; int range = ( n / sq ) + 1 ; int count [ range ] = { 0 } ; for ( int i = 0 ; i <= n ; i ++ ) { count [ ( arr [ i ] - 1 ) / sq ] ++ ; } int selected_block = range - 1 ; for ( int i = 0 ; i < range - 1 ; i ++ ) { if ( count [ i ] > sq ) { selected_block = i ; break ; } } unordered_map < int , int > m ; for ( int i = 0 ; i <= n ; i ++ ) { if ( ( ( selected_block * sq ) < arr [ i ] ) && ( arr [ i ] <= ( ( selected_block + 1 ) * sq ) ) ) { m [ arr [ i ] ] ++ ; if ( m [ arr [ i ] ] > 1 ) return arr [ i ] ; } } return - 1 ; }
Ref: 
def findRepeatingNumber ( arr , n ) : NEW_LINE INDENT sq = sqrt ( n ) NEW_LINE range__ = int ( ( n / sq ) + 1 ) NEW_LINE count = [ 0 for i in range ( range__ ) ] NEW_LINE for i in range ( 0 , n + 1 , 1 ) : NEW_LINE INDENT count [ int ( ( arr [ i ] - 1 ) / sq ) ] += 1 NEW_LINE DEDENT selected_block = range__ - 1 NEW_LINE for i in range ( 0 , range__ - 1 , 1 ) : NEW_LINE INDENT if ( count [ i ] > sq ) : NEW_LINE INDENT selected_block = i NEW_LINE break NEW_LINE DEDENT DEDENT m = { i : 0 for i in range ( n ) } NEW_LINE for i in range ( 0 , n + 1 , 1 ) : NEW_LINE INDENT if ( ( ( selected_block * sq ) < arr [ i ] ) and ( arr [ i ] <= ( ( selected_block + 1 ) * sq ) ) ) : NEW_LINE INDENT m [ arr [ i ] ] += 1 NEW_LINE if ( m [ arr [ i ] ] > 1 ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT DEDENT return - 1 NEW_LINE DEDENT
Hyp: 
def findRepeatingNumber ( arr , n ) : NEW_LINE INDENT sq = int ( math . sqrt ( n ) ) NEW_LINE range = ( n / sq ) + 1 NEW_LINE count = [ 0 ] * ( range + 1 ) NEW_LINE for i in range ( range + 1 ) : NEW_LINE INDENT count [ ( arr [ i ] - 1 ) / sq ] += 1 NEW_LINE DEDENT selected_block = range - 1 NEW_LINE for i in range ( range - 1 ) : NEW_LINE INDENT if ( count [ i ] > sq ) : NEW_LINE INDENT selected_block = i NEW_LINE break NEW_LINE DEDENT DEDENT m = { } NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT if ( ( selected_block * sq ) < arr [ i ] ) and ( arr [ i ] <= ( ( selected_block + 1 ) * sq ) ) : NEW_LINE INDENT m [ arr [ i ] ] += 1 NEW_LINE if ( m [ arr [ i ] ] > 1 ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT DEDENT return - 1 NEW_LINE DEDENT

BLEU: 73.79
Edit Sim: 109


Src: 
int findSDSFunc ( int n ) { int DP [ n + 1 ] ; DP [ 0 ] = 0 ; DP [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { if ( i % 2 == 0 ) DP [ i ] = DP [ i / 2 ] ; else DP [ i ] = DP [ ( i - 1 ) / 2 ] + DP [ ( i + 1 ) / 2 ] ; } return DP [ n ] ; }
Ref: 
def findSDSFunc ( n ) : NEW_LINE INDENT DP = [ 0 ] * ( n + 1 ) NEW_LINE DP [ 0 ] = 0 NEW_LINE DP [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( int ( i % 2 ) == 0 ) : NEW_LINE INDENT DP [ i ] = DP [ int ( i / 2 ) ] NEW_LINE DEDENT else : NEW_LINE INDENT DP [ i ] = ( DP [ int ( ( i - 1 ) / 2 ) ] + DP [ int ( ( i + 1 ) / 2 ) ] ) NEW_LINE DEDENT DEDENT return DP [ n ] NEW_LINE DEDENT
Hyp: 
def findSDSFunc ( n ) : NEW_LINE INDENT DP = [ 0 for i in range ( 0 , n + 1 ) ] NEW_LINE DP [ 0 ] = 0 NEW_LINE DP [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT DP [ i ] = DP [ i // 2 ] NEW_LINE DEDENT else : NEW_LINE INDENT DP [ i ] = DP [ ( i - 1 ) // 2 ] + DP [ ( i + 1 ) // 2 ] NEW_LINE DEDENT DEDENT return DP [ n ] NEW_LINE DEDENT

BLEU: 66.2
Edit Sim: 61


Src: 
int recSearch ( int arr [ ] , int l , int r , int x ) { if ( r < l ) return - 1 ; if ( arr [ l ] == x ) return l ; if ( arr [ r ] == x ) return r ; return recSearch ( arr , l + 1 , r - 1 , x ) ; }
Ref: 
def recSearch ( arr , l , r , x ) : NEW_LINE INDENT if r < l : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if arr [ l ] == x : NEW_LINE INDENT return l NEW_LINE DEDENT if arr [ r ] == x : NEW_LINE INDENT return r NEW_LINE DEDENT return recSearch ( arr , l + 1 , r - 1 , x ) NEW_LINE DEDENT
Hyp: 
def recSearch ( arr , l , r , x ) : NEW_LINE INDENT if ( r < l ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( arr [ l ] == x ) : NEW_LINE INDENT return l NEW_LINE DEDENT if ( arr [ r ] == x ) : NEW_LINE INDENT return r NEW_LINE DEDENT return recSearch ( arr , l + 1 , r - 1 , x ) NEW_LINE DEDENT

BLEU: 79.74
Edit Sim: 12


Src: 
bool check ( string str ) { int n = str . length ( ) ; if ( n == 0 ) return false ; if ( n == 1 ) return ( ( str [ 0 ] - '0' ) % 4 == 0 ) ; int last = str [ n - 1 ] - '0' ; int second_last = str [ n - 2 ] - '0' ; return ( ( second_last * 10 + last ) % 4 == 0 ) ; }
Ref: 
def check ( st ) : NEW_LINE INDENT n = len ( st ) NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return ( ( st [ 0 ] - '0' ) % 4 == 0 ) NEW_LINE DEDENT last = ( int ) ( st [ n - 1 ] ) NEW_LINE second_last = ( int ) ( st [ n - 2 ] ) NEW_LINE return ( ( second_last * 10 + last ) % 4 == 0 ) NEW_LINE DEDENT
Hyp: 
def check ( st ) : NEW_LINE INDENT n = len ( st ) NEW_LINE if n == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT return ( ( ord ( st [ 0 ] ) - ord ( '0' ) ) % 4 == 0 ) NEW_LINE DEDENT last = ord ( st [ n - 1 ] ) - ord ( '0' ) NEW_LINE second_last = ord ( st [ n - 2 ] ) - ord ( '0' ) NEW_LINE return ( ( second_last * 10 + last ) % 4 == 0 ) NEW_LINE DEDENT

BLEU: 70.2
Edit Sim: 66


Src: 
string to_upper ( string & in ) { for ( int i = 0 ; i < in . length ( ) ; i ++ ) if ( ' a ' <= in [ i ] <= ' z ' ) in [ i ] = in [ i ] - ' a ' + ' A ' ; return in ; }
Ref: 
def to_upper ( string ) : NEW_LINE INDENT for i in range ( len ( string ) ) : NEW_LINE INDENT if ( ' a ' <= string [ i ] <= ' z ' ) : NEW_LINE INDENT string = ( string [ 0 : i ] + chr ( ord ( string [ i ] ) - ord ( ' a ' ) + ord ( ' A ' ) ) + string [ i + 1 : ] ) NEW_LINE DEDENT DEDENT return string NEW_LINE DEDENT
Hyp: 
def to_upper ( in ) : NEW_LINE INDENT for i in range ( len ( in ) ) : NEW_LINE INDENT if ( ord ( in [ i ] ) <= ord ( ' a ' ) and ord ( in [ i ] ) <= ord ( ' z ' ) ) : NEW_LINE INDENT in [ i ] = ord ( in [ i ] ) - ord ( ' a ' ) + ord ( ' A ' ) NEW_LINE DEDENT DEDENT return in NEW_LINE DEDENT

BLEU: 56.46
Edit Sim: 108


Src: 
int remAnagram ( string str1 , string str2 ) { int count1 [ CHARS ] = { 0 } , count2 [ CHARS ] = { 0 } ; for ( int i = 0 ; str1 [ i ] != ' \0' ; i ++ ) count1 [ str1 [ i ] - ' a ' ] ++ ; for ( int i = 0 ; str2 [ i ] != ' \0' ; i ++ ) count2 [ str2 [ i ] - ' a ' ] ++ ; int result = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) result += abs ( count1 [ i ] - count2 [ i ] ) ; return result ; }
Ref: 
def remAnagram ( str1 , str2 ) : NEW_LINE INDENT count1 = [ 0 ] * CHARS NEW_LINE count2 = [ 0 ] * CHARS NEW_LINE i = 0 NEW_LINE while i < len ( str1 ) : NEW_LINE INDENT count1 [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE i += 1 NEW_LINE DEDENT i = 0 NEW_LINE while i < len ( str2 ) : NEW_LINE INDENT count2 [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE i += 1 NEW_LINE DEDENT result = 0 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT result += abs ( count1 [ i ] - count2 [ i ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT
Hyp: 
def remAnagram ( str1 , str2 ) : NEW_LINE INDENT count1 = [ 0 ] * CHARS NEW_LINE count2 = [ 0 ] * CHARS NEW_LINE for i in range ( len ( str1 ) ) : NEW_LINE INDENT count1 [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( len ( str2 ) ) : NEW_LINE INDENT count2 [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT result = 0 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT result += abs ( count1 [ i ] - count2 [ i ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT

BLEU: 80.78
Edit Sim: 74


Src: 
void sortInWave ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i += 2 ) { if ( i > 0 && arr [ i - 1 ] > arr [ i ] ) swap ( & arr [ i ] , & arr [ i - 1 ] ) ; if ( i < n - 1 && arr [ i ] < arr [ i + 1 ] ) swap ( & arr [ i ] , & arr [ i + 1 ] ) ; } }
Ref: 
def sortInWave ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n , 2 ) : NEW_LINE INDENT if ( i > 0 and arr [ i ] < arr [ i - 1 ] ) : NEW_LINE INDENT arr [ i ] , arr [ i - 1 ] = arr [ i - 1 ] , arr [ i ] NEW_LINE DEDENT if ( i < n - 1 and arr [ i ] < arr [ i + 1 ] ) : NEW_LINE INDENT arr [ i ] , arr [ i + 1 ] = arr [ i + 1 ] , arr [ i ] NEW_LINE DEDENT DEDENT DEDENT
Hyp: 
def sortInWave ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n , 2 ) : NEW_LINE INDENT if i > 0 and arr [ i - 1 ] > arr [ i ] : NEW_LINE INDENT arr [ i ] , arr [ i - 1 ] = arr [ i ] , arr [ i - 1 ] NEW_LINE DEDENT if i < n - 1 and arr [ i ] < arr [ i + 1 ] : NEW_LINE INDENT arr [ i ] , arr [ i + 1 ] = arr [ i + 1 ] , arr [ i ] NEW_LINE DEDENT DEDENT DEDENT

BLEU: 87.97
Edit Sim: 25


Src: 
string getMinNumberForPattern ( string seq ) { int n = seq . length ( ) ; if ( n >= 9 ) return " - 1" ; string result ( n + 1 , ' ▁ ' ) ; int count = 1 ; for ( int i = 0 ; i <= n ; i ++ ) { if ( i == n || seq [ i ] == ' I ' ) { for ( int j = i - 1 ; j >= - 1 ; j -- ) { result [ j + 1 ] = '0' + count ++ ; if ( j >= 0 && seq [ j ] == ' I ' ) break ; } } } return result ; }
Ref: 
def getMinNumberForPattern ( seq ) : NEW_LINE INDENT n = len ( seq ) NEW_LINE if ( n >= 9 ) : NEW_LINE INDENT return " - 1" NEW_LINE DEDENT result = [ None ] * ( n + 1 ) NEW_LINE count = 1 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT if ( i == n or seq [ i ] == ' I ' ) : NEW_LINE INDENT for j in range ( i - 1 , - 2 , - 1 ) : NEW_LINE INDENT result [ j + 1 ] = int ( '0' + str ( count ) ) NEW_LINE count += 1 NEW_LINE if ( j >= 0 and seq [ j ] == ' I ' ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
Hyp: 
def getMinNumberForPattern ( seq ) : NEW_LINE INDENT n = len ( seq ) NEW_LINE if n >= 9 : NEW_LINE INDENT return " - 1" NEW_LINE DEDENT result = " " NEW_LINE count = 1 NEW_LINE for i in range ( n + 1 , ' ▁ ' ) : NEW_LINE INDENT if i == n or seq [ i ] == ' I ' : NEW_LINE INDENT j = i - 1 NEW_LINE while j >= - 1 : NEW_LINE INDENT result [ j + 1 ] = '0' + count NEW_LINE if j >= 0 and seq [ j ] == ' I ' : NEW_LINE INDENT break NEW_LINE DEDENT j -= 1 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT

BLEU: 60.89
Edit Sim: 118


Src: 
bool isPossible ( string str , int n ) { int len = str . length ( ) ; if ( len >= n ) return true ; return false ; }
Ref: 
def isPossible ( str , n ) : NEW_LINE INDENT l = len ( str ) NEW_LINE if ( l >= n ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
Hyp: 
def isPossible ( str , n ) : NEW_LINE INDENT lenn = len ( str ) NEW_LINE if ( lenn >= n ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT

BLEU: 84.53
Edit Sim: 6


Src: 
void center ( int x1 , int x2 , int y1 , int y2 ) { cout << ( float ) ( x1 + x2 ) / 2 << " , ▁ " << ( float ) ( y1 + y2 ) / 2 ; }
Ref: 
def center ( x1 , x2 , y1 , y2 ) : NEW_LINE INDENT print ( int ( ( x1 + x2 ) / 2 ) , end = " " ) NEW_LINE print ( " , " , int ( ( y1 + y2 ) / 2 ) ) NEW_LINE DEDENT
Hyp: 
def center ( x1 , x2 , y1 , y2 ) : NEW_LINE INDENT print ( ( x1 + x2 ) // 2 , " , ▁ " , ( y1 + y2 ) // 2 ) NEW_LINE DEDENT

BLEU: 50.07
Edit Sim: 47


Src: 
void findMin ( int V ) { vector < int > ans ; for ( int i = n - 1 ; i >= 0 ; i -- ) { while ( V >= deno [ i ] ) { V -= deno [ i ] ; ans . push_back ( deno [ i ] ) ; } } for ( int i = 0 ; i < ans . size ( ) ; i ++ ) cout << ans [ i ] << " ▁ ▁ " ; }
Ref: 
def findMin ( V ) : NEW_LINE INDENT deno = [ 1 , 2 , 5 , 10 , 20 , 50 , 100 , 500 , 1000 ] NEW_LINE n = len ( deno ) NEW_LINE ans = [ ] NEW_LINE i = n - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT while ( V >= deno [ i ] ) : NEW_LINE INDENT V -= deno [ i ] NEW_LINE ans . append ( deno [ i ] ) NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT for i in range ( len ( ans ) ) : NEW_LINE INDENT print ( ans [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
Hyp: 
def findMin ( V ) : NEW_LINE INDENT ans = [ ] NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT while ( V >= deno [ i ] ) : NEW_LINE INDENT V -= deno [ i ] NEW_LINE ans . append ( deno [ i ] ) NEW_LINE DEDENT DEDENT for i in range ( len ( ans ) ) : NEW_LINE INDENT print ( ans [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT

BLEU: 59.49
Edit Sim: 122


Src: 
ll mulmod ( ll a , ll b , ll mod ) { ll res = 0 ; a = a % mod ; while ( b > 0 ) { if ( b % 2 == 1 ) res = ( res + a ) % mod ; a = ( a * 2 ) % mod ; b /= 2 ; } return res % mod ; }
Ref: 
def mulmod ( a , b , mod ) : NEW_LINE INDENT res = 0 NEW_LINE a = a % mod NEW_LINE while ( b > 0 ) : NEW_LINE INDENT if ( b % 2 == 1 ) : NEW_LINE INDENT res = ( res + a ) % mod NEW_LINE DEDENT a = ( a * 2 ) % mod NEW_LINE b //= 2 NEW_LINE DEDENT return res % mod NEW_LINE DEDENT
Hyp: 
def mulmod ( a , b , mod ) : NEW_LINE INDENT res = 0 NEW_LINE a = a % mod NEW_LINE while ( b > 0 ) : NEW_LINE INDENT if ( b % 2 == 1 ) : NEW_LINE INDENT res = ( res + a ) % mod NEW_LINE DEDENT a = ( a * 2 ) % mod NEW_LINE b = b // 2 NEW_LINE DEDENT return res % mod NEW_LINE DEDENT

BLEU: 94.0
Edit Sim: 5


Src: 
string Dragon_Curve_Sequence ( int n ) { string s = "1" ; for ( int i = 2 ; i <= n ; i ++ ) { string temp = "1" ; char prev = '1' , zero = '0' , one = '1' ; for ( int j = 0 ; j < s . length ( ) ; j ++ ) { temp += s [ j ] ; if ( prev == '0' ) { temp += one ; prev = one ; } else { temp += zero ; prev = zero ; } } s = temp ; } return s ; }
Ref: 
def Dragon_Curve_Sequence ( n ) : NEW_LINE INDENT s = "1" NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT temp = "1" NEW_LINE prev = '1' NEW_LINE zero = '0' NEW_LINE one = '1' NEW_LINE for j in range ( len ( s ) ) : NEW_LINE INDENT temp += s [ j ] NEW_LINE if ( prev == '0' ) : NEW_LINE INDENT temp += one NEW_LINE prev = one NEW_LINE DEDENT else : NEW_LINE INDENT temp += zero NEW_LINE prev = zero NEW_LINE DEDENT DEDENT s = temp NEW_LINE DEDENT return s NEW_LINE DEDENT
Hyp: 
def Dragon_Curve_Sequence ( n ) : NEW_LINE INDENT s = "1" NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT temp = "1" NEW_LINE prev = '1' NEW_LINE zero = '0' NEW_LINE one = '1' NEW_LINE for j in range ( len ( s ) ) : NEW_LINE INDENT temp += s [ j ] NEW_LINE if ( prev == '0' ) : NEW_LINE INDENT temp += one NEW_LINE prev = one NEW_LINE DEDENT else : NEW_LINE INDENT temp += zero NEW_LINE prev = zero NEW_LINE DEDENT DEDENT s = temp NEW_LINE DEDENT return s NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int minInitialPoints ( int points [ ] [ C ] ) { int dp [ R ] [ C ] ; int m = R , n = C ; dp [ m - 1 ] [ n - 1 ] = points [ m - 1 ] [ n - 1 ] > 0 ? 1 : abs ( points [ m - 1 ] [ n - 1 ] ) + 1 ; for ( int i = m - 2 ; i >= 0 ; i -- ) dp [ i ] [ n - 1 ] = max ( dp [ i + 1 ] [ n - 1 ] - points [ i ] [ n - 1 ] , 1 ) ; for ( int j = n - 2 ; j >= 0 ; j -- ) dp [ m - 1 ] [ j ] = max ( dp [ m - 1 ] [ j + 1 ] - points [ m - 1 ] [ j ] , 1 ) ; for ( int i = m - 2 ; i >= 0 ; i -- ) { for ( int j = n - 2 ; j >= 0 ; j -- ) { int min_points_on_exit = min ( dp [ i + 1 ] [ j ] , dp [ i ] [ j + 1 ] ) ; dp [ i ] [ j ] = max ( min_points_on_exit - points [ i ] [ j ] , 1 ) ; } } return dp [ 0 ] [ 0 ] ; }
Ref: 
def minInitialPoints ( points ) : NEW_LINE INDENT dp = [ [ 0 for x in range ( C + 1 ) ] for y in range ( R + 1 ) ] NEW_LINE m , n = R , C NEW_LINE if points [ m - 1 ] [ n - 1 ] > 0 : NEW_LINE INDENT dp [ m - 1 ] [ n - 1 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ m - 1 ] [ n - 1 ] = abs ( points [ m - 1 ] [ n - 1 ] ) + 1 NEW_LINE DEDENT for i in range ( m - 2 , - 1 , - 1 ) : NEW_LINE INDENT dp [ i ] [ n - 1 ] = max ( dp [ i + 1 ] [ n - 1 ] - points [ i ] [ n - 1 ] , 1 ) NEW_LINE DEDENT for i in range ( 2 , - 1 , - 1 ) : NEW_LINE INDENT dp [ m - 1 ] [ i ] = max ( dp [ m - 1 ] [ i + 1 ] - points [ m - 1 ] [ i ] , 1 ) NEW_LINE DEDENT for i in range ( m - 2 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT min_points_on_exit = min ( dp [ i + 1 ] [ j ] , dp [ i ] [ j + 1 ] ) NEW_LINE dp [ i ] [ j ] = max ( min_points_on_exit - points [ i ] [ j ] , 1 ) NEW_LINE DEDENT DEDENT return dp [ 0 ] [ 0 ] NEW_LINE DEDENT
Hyp: 
def minInitialPoints ( points ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( C ) ] for j in range ( R ) ] NEW_LINE m = R NEW_LINE n = C NEW_LINE if ( points [ m - 1 ] [ n - 1 ] > 0 ) : NEW_LINE INDENT dp [ m - 1 ] [ n - 1 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ m - 1 ] [ n - 1 ] = abs ( points [ m - 1 ] [ n - 1 ] ) + 1 NEW_LINE DEDENT for i in range ( m - 2 , - 1 , - 1 ) : NEW_LINE INDENT dp [ i ] [ n - 1 ] = max ( dp [ i + 1 ] [ n - 1 ] - points [ i ] [ n - 1 ] , 1 ) NEW_LINE DEDENT for j in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT dp [ m - 1 ] [ j ] = max ( dp [ m - 1 ] [ j + 1 ] - points [ m - 1 ] [ j ] , 1 ) NEW_LINE DEDENT for i in range ( m - 2 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT min_points_on_exit = min ( dp [ i + 1 ] [ j ] , dp [ i ] [ j + 1 ] ) NEW_LINE dp [ i ] [ j ] = max ( min_points_on_exit - points [ i ] [ j ] , 1 ) NEW_LINE DEDENT DEDENT return dp [ 0 ] [ 0 ] NEW_LINE DEDENT

BLEU: 90.3
Edit Sim: 34


Src: 
int findRepeating ( int arr [ ] , int n ) { return accumulate ( arr , arr + n , 0 ) - ( ( n - 1 ) * n / 2 ) ; }
Ref: 
def findRepeating ( arr , n ) : NEW_LINE INDENT return sum ( arr ) - ( ( ( n - 1 ) * n ) // 2 ) NEW_LINE DEDENT
Hyp: 
def findRepeating ( arr , n ) : NEW_LINE INDENT return accumulate ( arr , arr + n , 0 ) - ( ( n - 1 ) * n // 2 ) NEW_LINE DEDENT

BLEU: 65.41
Edit Sim: 25


Src: 
char getSecondMostFreq ( string str ) { int count [ NO_OF_CHARS ] = { 0 } , i ; for ( i = 0 ; str [ i ] ; i ++ ) ( count [ str [ i ] ] ) ++ ; int first = 0 , second = 0 ; for ( i = 0 ; i < NO_OF_CHARS ; i ++ ) { if ( count [ i ] > count [ first ] ) { second = first ; first = i ; } else if ( count [ i ] > count [ second ] && count [ i ] != count [ first ] ) second = i ; } return second ; }
Ref: 
def getSecondMostFreq ( str ) : NEW_LINE INDENT NO_OF_CHARS = 256 NEW_LINE count = [ 0 ] * NO_OF_CHARS NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT count [ ord ( str [ i ] ) ] += 1 NEW_LINE DEDENT first , second = 0 , 0 NEW_LINE for i in range ( NO_OF_CHARS ) : NEW_LINE INDENT if count [ i ] > count [ first ] : NEW_LINE INDENT second = first NEW_LINE first = i NEW_LINE DEDENT elif ( count [ i ] > count [ second ] and count [ i ] != count [ first ] ) : NEW_LINE INDENT second = i NEW_LINE DEDENT DEDENT return chr ( second ) NEW_LINE DEDENT
Hyp: 
def getSecondMostFreq ( Str ) : NEW_LINE INDENT count = [ 0 ] * ( NO_OF_CHARS ) NEW_LINE for i in range ( 0 , len ( Str ) ) : NEW_LINE INDENT count [ ord ( Str [ i ] ) ] = count [ ord ( Str [ i ] ) ] + 1 NEW_LINE DEDENT first = 0 NEW_LINE second = 0 NEW_LINE for i in range ( 0 , NO_OF_CHARS ) : NEW_LINE INDENT if ( count [ i ] > count [ first ] ) : NEW_LINE INDENT second = first NEW_LINE first = i NEW_LINE DEDENT elif ( count [ i ] > count [ second ] and count [ i ] != count [ first ] ) : NEW_LINE INDENT second = i NEW_LINE DEDENT DEDENT return second NEW_LINE DEDENT

BLEU: 67.24
Edit Sim: 101


Src: 
string findSum ( string str1 , string str2 ) { if ( str1 . length ( ) > str2 . length ( ) ) swap ( str1 , str2 ) ; string str = " " ; int n1 = str1 . length ( ) , n2 = str2 . length ( ) ; reverse ( str1 . begin ( ) , str1 . end ( ) ) ; reverse ( str2 . begin ( ) , str2 . end ( ) ) ; int carry = 0 ; for ( int i = 0 ; i < n1 ; i ++ ) { int sum = ( ( str1 [ i ] - '0' ) + ( str2 [ i ] - '0' ) + carry ) ; str . push_back ( sum % 10 + '0' ) ; carry = sum / 10 ; } for ( int i = n1 ; i < n2 ; i ++ ) { int sum = ( ( str2 [ i ] - '0' ) + carry ) ; str . push_back ( sum % 10 + '0' ) ; carry = sum / 10 ; } if ( carry ) str . push_back ( carry + '0' ) ; reverse ( str . begin ( ) , str . end ( ) ) ; return str ; }
Ref: 
def findSum ( str1 , str2 ) : NEW_LINE INDENT if ( len ( str1 ) > len ( str2 ) ) : NEW_LINE INDENT t = str1 NEW_LINE str1 = str2 NEW_LINE str2 = t NEW_LINE DEDENT str = " " NEW_LINE n1 = len ( str1 ) NEW_LINE n2 = len ( str2 ) NEW_LINE str1 = str1 [ : : - 1 ] NEW_LINE str2 = str2 [ : : - 1 ] NEW_LINE carry = 0 NEW_LINE for i in range ( n1 ) : NEW_LINE INDENT sum = ( ( ord ( str1 [ i ] ) - 48 ) + ( ( ord ( str2 [ i ] ) - 48 ) + carry ) ) NEW_LINE str += chr ( sum % 10 + 48 ) NEW_LINE carry = int ( sum / 10 ) NEW_LINE DEDENT for i in range ( n1 , n2 ) : NEW_LINE INDENT sum = ( ( ord ( str2 [ i ] ) - 48 ) + carry ) NEW_LINE str += chr ( sum % 10 + 48 ) NEW_LINE carry = ( int ) ( sum / 10 ) NEW_LINE DEDENT if ( carry ) : NEW_LINE INDENT str += chr ( carry + 48 ) NEW_LINE DEDENT str = str [ : : - 1 ] NEW_LINE return str NEW_LINE DEDENT
Hyp: 
def findSum ( str1 , str2 ) : NEW_LINE INDENT if len ( str1 ) > len ( str2 ) : NEW_LINE INDENT temp = str1 NEW_LINE str1 = str2 NEW_LINE str2 = temp NEW_LINE DEDENT str3 = " " NEW_LINE n1 = len ( str1 ) NEW_LINE n2 = len ( str2 ) NEW_LINE reverse ( str1 ) NEW_LINE str3 = str3 . reverse ( ) NEW_LINE carry = 0 NEW_LINE for i in range ( 0 , n1 ) : NEW_LINE INDENT sum = ( ( ord ( str1 [ i ] ) - ord ( '0' ) ) + int ( ( ord ( str2 [ i ] ) - ord ( '0' ) ) ) + carry ) NEW_LINE str3 = str3 + str ( sum % 10 ) NEW_LINE carry = sum // 10 NEW_LINE DEDENT for i in range ( n1 , n2 ) : NEW_LINE INDENT sum = ( ( ord ( str2 [ i ] ) - ord ( '0' ) ) + carry ) NEW_LINE str3 = str3 + str ( sum % 10 ) NEW_LINE carry = sum // 10 NEW_LINE DEDENT if ( carry ) : NEW_LINE INDENT str3 + str ( carry + '0' ) NEW_LINE DEDENT str3 = str3 [ : : - 1 ] NEW_LINE return str3 NEW_LINE DEDENT

BLEU: 62.26
Edit Sim: 147


Src: 
void printNGE ( int arr [ ] , int n ) { int next , i , j ; for ( i = 0 ; i < n ; i ++ ) { next = - 1 ; for ( j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] < arr [ j ] ) { next = arr [ j ] ; break ; } } cout << arr [ i ] << " ▁ - - ▁ " << next << endl ; } }
Ref: 
def printNGE ( arr ) : NEW_LINE INDENT for i in range ( 0 , len ( arr ) , 1 ) : NEW_LINE INDENT next = - 1 NEW_LINE for j in range ( i + 1 , len ( arr ) , 1 ) : NEW_LINE INDENT if arr [ i ] < arr [ j ] : NEW_LINE INDENT next = arr [ j ] NEW_LINE break NEW_LINE DEDENT DEDENT print ( str ( arr [ i ] ) + " ▁ - - ▁ " + str ( next ) ) NEW_LINE DEDENT DEDENT
Hyp: 
def printNGE ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT next = - 1 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] < arr [ j ] ) : NEW_LINE INDENT next = arr [ j ] NEW_LINE break NEW_LINE DEDENT DEDENT print ( arr [ i ] , " ▁ - - ▁ " , next ) NEW_LINE DEDENT DEDENT

BLEU: 67.36
Edit Sim: 54


