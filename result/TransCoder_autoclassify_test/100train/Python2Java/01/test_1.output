static int nonDecNums ( int n ) { int [ ] [ ] a = new int [ n + 1 ] [ 10 ] ; for ( int i = 0 ; i <= 9 ; i ++ ) a [ 0 ] [ i ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) a [ i ] [ 9 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) a [ i ] [ 8 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 8 ; j >= 0 ; j -- ) a [ i ] [ j ] = a [ i - 1 ] [ j ] + a [ i ] [ j + 1 ] ; } } return a [ n ] [ 0 ] ; }
static int maxSum ( int arr [ ] , int n ) { int cum_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) cum_sum += arr [ i ] ; int curr_val = 0 ; for ( int i = 0 ; i < n ; i ++ ) { curr_val += i * arr [ i ] ; } int res = curr_val ; for ( int i = 1 ; i < n ; i ++ ) { next_val = ( curr_val - ( cum_sum - arr [ i - 1 ] ) + arr [ i - 1 ] * ( n - 1 ) ) ; curr_val = next_val ; res = Math . max ( res , next_val ) ; } return res ; }
static int countSubsequence ( String s , int n ) { int cntG = 0 ; int cntF = 0 ; int result = 0 ; int C = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == ' G ' ) cntG ++ ; result += C ; continue ; if ( s . charAt ( i ) == ' F ' ) cntF ++ ; C ++ ; } else { result ++ ; } } System . out . println ( result ) ; }
static int countFriendsPairings ( int n ) { int a = 1 , b = 2 , c = 1 ; if ( n <= 2 ) return n ; for ( int i = 3 ; i <= n ; i ++ ) { c = b + ( i - 1 ) * a ; a = b ; b = c ; } return c ; }
static void subArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { for ( int k = i ; k < j ; k ++ ) { System . out . print ( arr [ k ] + " ▁ " ) ; System . out . println ( ) ; } } }
static int solve ( int i , int par , int a [ ] , int n , int k , int current_ans ) { if ( par > k ) return 0 ; if ( i == n - 1 ) ans = Math . min ( ans , current_ans ) ; for ( int j = i + 1 ; j < n ; j ++ ) { solve ( j , par + 1 , a , n , k , current_ans + ( a [ j ] - a [ i + 1 ] ) * ( a [ j ] - a [ i + 1 ] ) ) ; } return 0 ; }
static int squareRoot ( int n ) { int x = n ; int y = 1 ; double e = 0.000001 ; while ( x - y > e ) x = ( x + y ) / 2 ; y = n / x ; return x ; }
static int CountPairs ( int n ) { int k = n ; int imin = 1 ; int ans = 0 ; while ( imin <= n ) { int imax = n / k ; ans += k * ( imax - imin + 1 ) ; imin = imax + 1 ; k = n / imin ; } return ans ; }
static int polygonArea ( double X [ ] , double Y [ ] , int n ) { double area = 0.0 ; int j = n - 1 ; for ( int i = 0 ; i < n ; i ++ ) { area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) ; j = i ; } return ( int ) ( Math . abs ( area / 2.0 ) ) ; }
static int equilibrium ( int arr [ ] ) { int leftsum = 0 , rightsum = 0 ; int n = arr . length ; for ( int i = 0 ; i < n ; i ++ ) { leftsum = 0 ; rightsum = 0 ; for ( int j = i ; j < n ; j ++ ) { leftsum += arr [ j ] ; } for ( int j = i + 1 ; j < n ; j ++ ) { rightsum += arr [ j ] ; } if ( leftsum == rightsum ) return i ; } return - 1 ; }
static int chordCnt ( int A ) { int n = 2 * A ; int dpArray [ ] = new int [ n + 1 ] ; dpArray [ 0 ] = 1 ; dpArray [ 2 ] = 1 ; for ( int i = 4 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= i - 1 ; j ++ ) dpArray [ i ] += ( dpArray [ j ] * dpArray [ i - 2 - j ] ) ; } return int ( dpArray [ n ] ) ; }
static int compute ( int a , int b ) { double AM = ( a + b ) / 2 ; double GM = Math . sqrt ( a * b ) ; double HM = ( GM * GM ) / AM ; return HM ; }
static int findMajority ( int arr [ ] , int n ) { int maxCount = 0 ; int index = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ i ] == arr [ j ] ) count ++ ; if ( count > maxCount ) { maxCount = count ; index = i ; } } if ( maxCount > n / 2 ) System . out . print ( arr [ index ] ) ; else System . out . println ( " No ▁ Majority ▁ Element " ) ; } return maxCount ; }
static boolean isPerfectSquare ( int n ) { int i = 1 ; int the_sum = 0 ; while ( the_sum < n ) the_sum += i ; if ( the_sum == n ) return true ; return false ; }
static int nearestSmallerEqFib ( int n ) { if ( n == 0 || n == 1 ) return n ; int f1 , f2 , f3 ; for ( f1 = f2 ; f2 <= f3 ; f3 = f1 + f2 ; return f2 ; }
static boolean isSubsetSum ( int arr [ ] , int n , int sum ) { boolean [ ] [ ] subset = new boolean [ 3 ] [ n + 1 ] ; for ( int i = 0 ; i < 3 ; i ++ ) subset [ i ] [ 0 ] = true ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < sum ; j ++ ) { if ( j == 0 ) subset [ i % 2 ] [ j ] = false ; } else if ( arr [ i - 1 ] <= j ) subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j - arr [ i - 1 ] ] || subset [ ( i + 1 ) % 2 ] [ j ] ; else subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j ] ; } } return subset [ n % 2 ] [ sum ] ; }
static int findExtra ( int arr1 [ ] , int arr2 [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( arr1 [ i ] != arr2 [ i ] ) { return i ; } } return n ; }
static int numberOfPermWithKInversion ( int N , int K ) { if ( N == 0 ) return 0 ; if ( K == 0 ) return 1 ; int sum = 0 ; for ( int i = 0 ; i <= K ; i ++ ) { if ( i <= N - 1 ) sum += numberOfPermWithKInversion ( N - 1 , K - i ) ; } memo [ N ] [ K ] = sum ; return sum ; }
static int firstNonRepeating ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < n ; j ++ ) if ( i != j && arr [ i ] == arr [ j ] ) break ; if ( j == n ) return arr [ i ] ; } return - 1 ; }
static int search ( int arr [ ] , int x ) { int n = arr . length ; for ( int j = 0 ; j < n ; j ++ ) if ( arr [ j ] == x ) return j ; return - 1 ; }
static void middlesum ( int mat [ ] [ ] , int n ) { int row_sum = 0 , col_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) row_sum += mat [ n / 2 ] [ i ] ; for ( int i = 0 ; i < n ; i ++ ) { col_sum += mat [ i ] [ n / 2 ] ; } System . out . println ( " Sum ▁ of ▁ middle ▁ row ▁ = ▁ " + row_sum ) ; for ( int i = 0 ; i < n ; i ++ ) { col_sum += mat [ i ] [ n / 2 ] ; } System . out . println ( " Sum ▁ of ▁ middle ▁ column ▁ = ▁ " + col_sum ) ; }
static void pythagoreanTriplets ( int limits ) { int c , m = 0 ; while ( c < limits ) { c = 0 ; m = 2 ; for ( int n = 1 ; n <= m ; n ++ ) { int a = m * m - n * n ; int b = 2 * m * n ; c = m * m + n * n ; if ( c > limits ) break ; System . out . println ( a , b , c ) ; } }
static int findSum ( int n ) { return n * ( n + 1 ) * ( n + 2 ) * ( 3 * n + 1 ) / 24 ; }
static int fib ( int n ) { if ( n == 0 ) return 0 ; if ( n == 1 || n == 2 ) return 1 ; if ( f [ n ] == null ) return f [ n ] ; if ( n & 1 ) { int k ; if ( n & 2 ) { k = ( n + 1 ) / 2 ; } else { k = ( n + 1 ) / 2 ; } if ( n & 1 ) { f [ n ] = ( fib ( k ) * fib ( k ) + fib ( k - 1 ) * fib ( k - 1 ) ) ; } else { f [ n ] = ( 2 * fib ( k - 1 ) + fib ( k ) ) * fib ( k - 1 ) ; } } return f [ n ] ; }
static boolean isIdentity ( int mat [ ] [ ] ) { int row , col ; for ( row = 0 ; row < N ; row ++ ) { for ( col = 0 ; col < N ; col ++ ) { if ( row == col && mat [ row ] [ col ] != 1 ) return false ; else if ( row != col && mat [ row ] [ col ] != 0 ) return false ; } } return true ; }
static int minCells ( int mat [ ] [ ] , int m , int n ) { int dp [ ] [ ] = new int [ m ] [ n ] ; dp [ 0 ] [ 0 ] = 1 ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( dp [ i ] [ j ] != MAX && ( j + mat [ i ] [ j ] ) < n && ( dp [ i ] [ j + mat [ i ] [ j ] + 1 ) < dp [ i ] [ j + mat [ i ] [ j ] ] ) ) dp [ i ] [ j + mat [ i ] [ j ] ] = dp [ i ] [ j ] + 1 ; } } if ( dp [ m ] [ n - 1 ] != MAX ) return dp [ m - 1 ] [ n - 1 ] ; } return - 1 ; }
static void arrangeString ( String str , int x , int y ) { int count_0 = 0 , count_1 = 0 ; int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( str . charAt ( i ) == '0' ) count_0 ++ ; else count_1 ++ ; } while ( count_0 > 0 || count_1 > 0 ) { for ( int i = 0 ; i < x ; i ++ ) { if ( count_0 > 0 ) System . out . print ( " 0 " ) ; count_0 -- ; } for ( int j = 0 ; j < y ; j ++ ) { if ( count_1 > 0 ) System . out . print ( 1 + " " ) ; count_1 -- ; } } }
static int carAssembly ( int a [ ] [ ] , int t [ ] [ ] , int e , int x [ ] ) { int NUM_STATION = a . length ; int T1 [ ] = new int [ NUM_STATION ] ; int [ ] T2 = new int [ NUM_STATION ] ; for ( int i = 0 ; i < NUM_STATION ; i ++ ) T1 [ i ] = e [ 0 ] + a [ 0 ] [ 0 ] ; for ( int i = 1 ; i < NUM_STATION ; i ++ ) { T2 [ i ] = e [ 1 ] + a [ 1 ] [ 0 ] ; for ( int i = 1 ; i < NUM_STATION ; i ++ ) { T1 [ i ] = T1 [ i - 1 ] + a [ 0 ] [ i ] ; T2 [ i ] = Math . min ( T2 [ i - 1 ] + t [ 1 ] [ i ] , T1 [ i - 1 ] + t [ 0 ] [ i ] + a [ 1 ] [ i ] ) ; } } return Math . min ( T1 [ NUM_STATION - 1 ] + x [ 0 ] , T2 [ NUM_STATION - 1 ] + x [ 1 ] ) ; }
static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
boolean findTriplets ( int arr [ ] , int n ) { boolean found = false ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int l = i + 1 ; int r = n - 1 ; int x = arr [ i ] ; while ( l < r ) { if ( x + arr [ l ] + arr [ r ] == 0 ) System . out . print ( x + arr [ l ] + arr [ r ] ) ; l ++ ; r -- ; found = true ; } else if ( x + arr [ l ] + arr [ r ] < 0 ) l ++ ; else r -- ; } if ( found == false ) System . out . println ( " ▁ No ▁ Triplet ▁ Found " ) ; } return found ; }
static int maxTasks ( int high [ ] , int low [ ] , int n ) { if ( n <= 0 ) return 0 ; return Math . max ( high [ n - 1 ] + maxTasks ( high , low , ( n - 2 ) ) , low [ n - 1 ] + maxTasks ( high , low , ( n - 1 ) ) ) ; }
static void printOtherSides ( int n ) { if ( n & 1 ) { if ( n == 1 ) System . out . println ( - 1 ) ; else { int b = ( n * n - 1 ) / 2 ; int c = ( n * n + 1 ) / 2 ; System . out . println ( " b ▁ = " + b + " , ▁ c ▁ = " + c ) ; } } else { if ( n == 2 ) System . out . println ( " b ▁ = " + n * n / 4 - 1 ; c = n * n / 4 + 1 ; System . out . println ( " b ▁ = " + b + " , ▁ c ▁ = " + c ) ; } } }
static void printUnsorted ( int arr [ ] , int n ) { int s , e ; for ( s = 0 ; s < n - 1 ; s ++ ) { if ( arr [ s ] > arr [ s + 1 ] ) break ; if ( s == n - 1 ) System . out . println ( " The ▁ complete ▁ array ▁ is ▁ sorted " ) ; exit ( ) ; } e = n - 1 ; for ( i = s + 1 ; i <= e ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; if ( arr [ i ] < min ) min = arr [ i ] ; } for ( i = 0 ; i < s ; i ++ ) { if ( arr [ i ] > min ) { s = i ; break ; } } for ( i = n - 1 ; i >= e + 1 ; i -- ) { if ( arr [ i ] < max ) { e = i ; break ; } } System . out . println ( " The ▁ unsorted ▁ subarray ▁ which ▁ makes ▁ the ▁ given ▁ array " ) ; System . out . println ( " sorted ▁ lies ▁ between ▁ the ▁ indexes ▁ and ▁ " + s + " " ) ; }
public static int circle ( int x1 , int y1 , int x2 , int y2 , int r1 , int r2 ) { int distSq = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ; int radSumSq = ( r1 + r2 ) * ( r1 + r2 ) ; if ( distSq == radSumSq ) return 1 ; else return 0 ; }
static int countOps ( int A [ ] [ ] , int B [ ] [ ] , int m , int n ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) A [ i ] [ j ] -= B [ i ] [ j ] ; } for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) { if ( A [ i ] [ j ] - A [ i ] [ 0 ] - A [ 0 ] [ j ] + A [ 0 ] [ 0 ] != 0 ) return - 1 ; } } return result ; }
static void longestAlternating ( int arr [ ] , int n ) { int [ ] count = new int [ n ] ; count [ n - 1 ] = 1 ; int i ; for ( i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] * arr [ i + 1 ] < 0 ) count [ i ] = count [ i + 1 ] + 1 ; else count [ i ] = 1 ; } i = 0 ; while ( i < n ) { System . out . print ( count [ i ] + " ▁ " ) ; i ++ ; } System . out . println ( ) ; }
static int sortedCount ( int mat [ ] [ ] , int r , int c ) { int result = 0 ; for ( int i = 0 ; i < r ; i ++ ) { int j ; for ( j = 0 ; j < c - 1 ; j ++ ) { if ( mat [ i ] [ j + 1 ] <= mat [ i ] [ j ] ) break ; } if ( j == c - 2 ) result ++ ; } for ( int i = 0 ; i < r ; i ++ ) { j = 0 ; for ( j = 0 ; j < c - 1 ; j ++ ) { if ( mat [ i ] [ j - 1 ] <= mat [ i ] [ j ] ) break ; } if ( c > 1 && j == 1 ) result ++ ; } } return result ; }
static void printMaxOfMin ( int arr [ ] , int n ) { for ( int k = 1 ; k <= n ; k ++ ) { int maxOfMin = Integer . MIN_VALUE ; for ( int i = 0 ; i <= n - k ; i ++ ) { int min = arr [ i ] ; for ( int j = 0 ; j < k ; j ++ ) { if ( arr [ i + j ] < min ) { min = arr [ i + j ] ; } } if ( min > maxOfMin ) { maxOfMin = min ; } } System . out . println ( maxOfMin + " ▁ " ) ; }
static int middleOfThree ( int a , int b , int c ) { if ( ( a < b && b < c ) || ( c < b && b < a ) ) return b ; if ( ( b < a && a < c ) || ( c < a && a < b ) ) return a ; else return c ; }
static int countarray ( int n , int k , int x ) { int dp [ ] = new int [ n ] ; dp . add ( 0 ) ; dp . add ( 1 ) ; for ( int i = 2 ; i < n ; i ++ ) { dp . add ( k - 2 ) * dp [ i - 1 ] + ( k - 1 ) * dp [ i - 2 ] ) ; i ++ ; } return ( k - 1 ) * dp [ n - 2 ] if ( x == 1 ) dp [ n - 1 ] ; }
static int nswp ( int n ) { if ( n == 0 || n == 1 ) return 1 ; return 2 * nswp ( n - 1 ) + nswp ( n - 2 ) ; }
static int fib ( int n , int [ ] lookup ) { if ( n == 0 || n == 1 ) lookup [ n ] = n ; if ( lookup [ n ] is None ) { lookup [ n ] = fib ( n - 1 , lookup ) + fib ( n - 2 , lookup ) ; } return lookup [ n ] ; }
static int countParenth ( char symb [ ] [ ] , char oper [ ] , int n ) { int F [ ] [ ] = new int [ n + 1 ] [ n + 1 ] ; int [ ] T [ ] [ ] = new int [ n ] [ n ] ; int gap , i , j , k , tik , tkj ; for ( i = 0 ; i < n ; i ++ ) { F [ i ] [ i ] = 1 ; } else { T [ i ] [ i ] = 0 ; } } for ( gap = 1 ; gap < n ; ++ gap ) { for ( i = 0 ; j < n ; ++ i ) { j = gap ; for ( g = 0 ; g < gap ; ++ g ) { k = i + g ; tik = T [ i ] [ k ] + F [ i ] [ k ] ; tkj = T [ k + 1 ] [ j ] + F [ k + 1 ] [ j ] ; if ( oper [ k ] == ' & ' ) { T [ i ] [ j ] += T [ i ] [ k ] * T [ k + 1 ] [ j ] ; F [ i ] [ j ] += ( tik * tkj - T [ i ] [ k ] * F [ k + 1 ] [ j ] ) ; } if ( oper [ k ] == ' ^ ' ) { T [ i ] [ j ] += ( F [ i ] [ k ] * T [ k + 1 ] [ j ] + T [ i ] [ k + 1 ] [ j ] ) ; } } } return 0 ; }
static int longestCommonSum ( int arr1 [ ] , int arr2 [ ] , int n ) { int maxLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int sum1 = 0 , sum2 = 0 ; for ( int j = 0 ; j < n ; j ++ ) { sum1 += arr1 [ j ] ; sum2 += arr2 [ j ] ; if ( sum1 == sum2 ) { len = j - i + 1 ; if ( len > maxLen ) { maxLen = len ; } } } return maxLen ; }
static int maxTripletSum ( int arr [ ] , int n ) { int sm = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) { if ( sm < ( arr [ i ] + arr [ j ] + arr [ k ] ) ) { sm = arr [ i ] + arr [ j ] + arr [ k ] ; } } } return sm ; }
static int findNth ( int n ) { int nthElement = 19 + ( n - 1 ) * 9 ; int outliersCount = Math . log10 ( nthElement ) ; nthElement += 9 * outliersCount ; return nthElement ; }
static int countSol ( int coeff [ ] , int start , int end , int rhs ) { if ( rhs == 0 ) return 1 ; int result = 0 ; for ( int i = start ; i <= end ; i ++ ) { if ( coeff [ i ] <= rhs ) result += countSol ( coeff , i , end , rhs - coeff [ i ] ) ; } return result ; }
static void findConsecutive ( int N ) { int start = 1 , end = ( N + 1 ) / 2 ; while ( start < end ) { int sum = 0 ; for ( int i = start ; i <= end ; i ++ ) { sum = sum + i ; if ( sum == N ) { for ( int j = start ; j <= end ; j ++ ) { System . out . print ( j + " ▁ " ) ; } System . out . println ( ) ; break ; } } sum = 0 ; start ++ ; } }
static double maxArea ( int a , int b , int c , int d ) { double semiperimeter = ( a + b + c + d ) / 2 ; return Math . sqrt ( ( semiperimeter - a ) * ( semiperimeter - b ) * ( semiperimeter - c ) * ( semiperimeter - d ) ) ; }
static boolean isSubsetSum ( int [ ] set , int n , int sum ) { if ( sum == 0 ) return true ; if ( n == 0 && sum != 0 ) return false ; if ( set [ n - 1 ] > sum ) return isSubsetSum ( set , n - 1 , sum ) ; if ( set [ n - 1 ] > sum ) return isSubsetSum ( set , n - 1 , sum ) ; if ( set [ n - 1 ] > sum ) return isSubsetSum ( set , n - 1 , sum ) ; return isSubsetSum ( set , n - 1 , sum - set [ n - 1 ] ) ; }
static int PowerOFPINnfactorial ( int n , int p ) { int ans = 0 ; int temp = p ; while ( temp <= n ) ans += n / temp ; return ans ; }
static int findMaxValue ( int mat [ ] [ ] ) { int maxValue = 0 ; for ( int a = 0 ; a <= N - 2 ; a ++ ) { for ( int b = 0 ; b <= N - 1 ; b ++ ) { for ( int d = a + 1 ; d < N ; d ++ ) { for ( int e = b + 1 ; e < N ; e ++ ) { if ( maxValue < Math . abs ( mat [ d ] [ e ] - mat [ a ] [ b ] ) ) { maxValue = Math . abs ( mat [ d ] [ e ] - mat [ a ] [ b ] ) ; } } } return maxValue ; }
static int getOddOccurrence ( int arr [ ] , int arr_size ) { int count = 0 ; for ( int i = 0 ; i < arr_size ; i ++ ) { count = 0 ; for ( int j = 0 ; j < arr_size ; j ++ ) if ( arr [ i ] == arr [ j ] ) count ++ ; if ( count % 2 != 0 ) return arr [ i ] ; } return - 1 ; }
static void direction ( int R , int C ) { if ( R != C && R % 2 == 0 && C % 2 != 0 && R < C ) System . out . println ( " Left " ) ; if ( R == C && R % 2 == 0 && C % 2 != 0 && R < C ) System . out . println ( " Up " ) ; if ( R == C && R % 2 == 0 && C % 2 != 0 && R < C ) System . out . println ( " Right " ) ; if ( R != C && R % 2 != 0 && C % 2 != 0 && R < C ) System . out . println ( " Left " ) ; if ( R != C && R % 2 == 0 && C % 2 != 0 && R < C ) System . out . println ( " Down " ) ; if ( R != C && R % 2 == 0 && C % 2 != 0 && R < C ) System . out . println ( " Left " ) ; if ( R != C && R % 2 == 0 && C % 2 != 0 && R < C ) System . out . println ( " Left " ) ; if ( R != C && R % 2 == 0 && C % 2 != 0 && R < C ) System . out . println ( " Right " ) ; if ( R != C && R % 2 != 0 && C % 2 != 0 && R < C ) System . out . println ( " Up " ) ; return ; }
static void fib ( int n ) { int a = 0 , b = 1 ; if ( n >= 0 ) System . out . print ( a + ' ▁ ' ) ; if ( n >= 1 ) System . out . print ( b + ' ▁ ' ) ; for ( int i = 2 ; i <= n ; i ++ ) { int c = a + b ; System . out . print ( c + ' ▁ ' ) ; } }
static int divisorSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += ( n / i ) * i ; return sum ; }
static void solve ( int n , int t , char [ ] p ) { char [ ] s = new char [ n - 1 ] ; for ( int i = 0 ; i < t ; i ++ ) { for ( int j = 0 ; j < n - 1 ; j ++ ) { if ( s [ j ] == ' B ' && s [ j + 1 ] == ' G ' ) { s [ j ] = s [ j + 1 ] ; s [ j + 1 ] = temp ; j = j + 1 ; } } } System . out . println ( ' ' ) ; }
static int turnOffK ( int n , int k ) { if ( k <= 0 ) return n ; return ( n & ~ ( 1 << ( k - 1 ) ) ) ; }
public static int findMaximum ( int [ ] arr , int low , int high ) { if ( low == high ) { System . out . println ( " The ▁ required ▁ element ▁ is ▁ " + arr [ low ] ) ; return arr [ low ] ; } if ( high == low + 1 && arr [ low ] >= arr [ high ] ) return arr [ low ] ; if ( high == low + 1 && arr [ low ] < arr [ high ] ) return arr [ high ] ; int mid = ( low + high ) / 2 ; if ( arr [ mid ] > arr [ mid + 1 ] && arr [ mid ] > arr [ mid - 1 ] ) return findMaximum ( arr , low , mid - 1 ) ; else if ( arr [ mid ] > arr [ mid + 1 ] && arr [ mid ] < arr [ mid - 1 ] ) return findMaximum ( arr , mid + 1 , high ) ; }
static int subArraySum ( int arr [ ] , int n , int sum ) { int curr_sum = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { int j ; for ( j = i + 1 ; j <= n ; j ++ ) { if ( curr_sum == sum ) { System . out . println ( " Sum ▁ found ▁ between ▁ % d ▁ " + ( i , j - 1 ) ) ; return 1 ; } if ( curr_sum > sum || j == n ) break ; curr_sum = curr_sum + arr [ j ] ; j ++ ; } } System . out . println ( " No ▁ subarray ▁ found " ) ; return 0 ; }
static int getModulo ( int n , int d ) { return ( n & ( d - 1 ) ) ; }
int getInvCount ( int arr [ ] , int n ) { int inv_count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] > arr [ j ] ) inv_count ++ ; } return inv_count ; }
static int dealnnoy ( int n , int m ) { int dp [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { dp [ 0 ] [ i ] = 1 ; } for ( int i = 1 ; i <= m ; i ++ ) { dp [ i ] [ 0 ] = 1 ; } for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] + dp [ i ] [ j - 1 ] ; } } return dp [ m ] [ n ] ; }
static boolean isValidISBN ( String isbn ) { if ( isbn . length ( ) != 10 ) return false ; int _sum = 0 ; for ( int i = 0 ; i < 9 ; i ++ ) { if ( 0 <= int ( isbn . charAt ( i ) ) <= 9 ) _sum += int ( isbn . charAt ( i ) ) * ( 10 - i ) ; else if ( isbn . charAt ( 9 ) != ' X ' && 0 <= int ( isbn . charAt ( 9 ) ) <= 9 ) return false ; } _sum += 10 if ( isbn . charAt ( 9 ) == ' X ' ) int . valueOf ( isbn . charAt ( 9 ) ) ; return ( _sum % 11 == 0 ) ; }
static int power ( int n ) { if ( n == 1 ) return 2 ; return 2 * power ( n - 1 ) ; }
static int lastPosition ( int n , int m , int k ) { if ( m <= n - k + 1 ) return m + k - 1 ; m = m - ( n - k + 1 ) ; if ( m % n == 0 ) return n ; else return m % n ; }
static void printFibonacciNumbers ( int n ) { int f1 = 0 , f2 = 1 ; if ( n < 1 ) return ; for ( int x = 0 ; x < n ; x ++ ) { System . out . print ( f2 + " ▁ " ) ; f2 = next ; } }
static int knapSack ( int W , int wt , int val [ ] , int n ) { int K [ ] [ ] = new int [ W + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= W ; i ++ ) { for ( int w = 0 ; w < n ; w ++ ) { if ( i == 0 || w == 0 ) K [ i ] [ w ] = 0 ; else if ( wt [ i - 1 ] <= w ) K [ i ] [ w ] = Math . max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) ; else K [ i ] [ w ] = K [ i - 1 ] [ w ] ; } } return K [ n ] [ W ] ; }
static void multiply ( int A [ ] [ ] , int B [ ] [ ] , int C [ ] [ ] ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { C [ i ] [ j ] = A [ i ] [ j ] - B [ i ] [ j ] ; } } }
static int countNegative ( int M [ ] [ ] , int n , int m ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( M [ i ] [ j ] < 0 ) count ++ ; else break ; } } return count ; }
static int middleOfThree ( int a , int b , int c ) { if ( a > b ) { if ( b > c ) return b ; else if ( a > c ) return c ; else return a ; } else if ( b > c ) return b ; else if ( a > c ) return c ; else return b ; }
static int countWays ( int n ) { int dp [ ] [ ] = new int [ n + 1 ] [ n + 1 ] ; dp [ 0 ] [ 1 ] = 1 ; dp [ 1 ] [ 1 ] = 2 ; for ( int i = 2 ; i <= n ; i ++ ) { dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + dp [ 1 ] [ i - 1 ] ; dp [ 1 ] [ i ] = ( dp [ 0 ] [ i - 1 ] * 2 + dp [ 1 ] [ i - 1 ] ) ; } return dp [ 0 ] [ n ] + dp [ 1 ] [ n ] ; }
static int maxLenSub ( int arr [ ] , int n ) { int mls [ ] = new int [ n ] ; int max = 0 ; for ( int i = 0 ; i < n ; i ++ ) mls . add ( 1 ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( Math . abs ( arr [ i ] - arr [ j ] ) <= 1 && mls [ i ] < mls [ j ] + 1 ) mls [ i ] = mls [ j ] + 1 ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( max < mls [ i ] ) max = mls [ i ] ; } return max ; }
static int exponentiation ( int bas , int exp ) { int t = 1 ; while ( exp > 0 ) { if ( exp % 2 != 0 ) t = ( t * bas ) % N ; bas = ( bas * bas ) % N ; exp = exp / 2 ; } return t % N ; }
static int sequence ( int n ) { int [ ] f = new int [ n + 1 ] ; f [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { int r = f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ] ; f . append ( r ) ; } return 0 ; }
static int lbs ( int arr [ ] ) { int n = arr . length ; int lis [ ] = new int [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( ( arr [ i ] > arr [ j ] ) && ( lis [ i ] < lis [ j ] + 1 ) ) lis [ i ] = lis [ j ] + 1 ; } } int lds [ ] = new int [ n - 1 ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i - 1 ; j <= n ; j ++ ) { if ( arr [ i ] > arr [ j ] && lds [ i ] < lds [ j ] + 1 ) ) lds [ i ] = lds [ j ] + 1 ; } } int maximum = lis [ 0 ] + lds [ 0 ] - 1 ; for ( int i = 1 ; i <= n ; i ++ ) maximum = Math . max ( ( lis [ i ] + lds [ i ] - 1 ) , maximum ) ; } return maximum ; }
static int maximumSum ( int a [ ] [ ] , int n ) { int i , j ; quickSort ( a , 0 , n ) ; for ( i = 0 ; i < n ; i ++ ) { Arrays . sort ( a [ i ] ) ; } int sum = a [ n - 1 ] [ M - 1 ] ; int prev = a [ n - 1 ] [ M - 1 ] ; for ( i = n - 2 ; i >= 0 ; i -- ) { for ( j = M - 1 ; j >= 0 ; j -- ) { if ( a [ i ] [ j ] < prev ) { prev = a [ i ] [ j ] ; sum += prev ; break ; } } if ( j == - 1 ) return 0 ; } return sum ; }
static int fib ( int n ) { if ( n <= 1 ) return n ; return fib ( n - 1 ) + fib ( n - 2 ) ; }
static void diagonalsquare ( int mat [ ] [ ] , int row , int column ) { System . out . print ( " Diagonal ▁ one ▁ : ▁ " ) ; for ( int i = 0 ; i < row ; i ++ ) System . out . print ( mat [ i ] [ i ] * mat [ i ] [ i ] + " ▁ " ) ; for ( int i = 0 ; i < row ; i ++ ) System . out . print ( mat [ i ] [ row - i - 1 ] * mat [ i ] [ row - i - 1 ] + " ▁ " ) ; for ( int i = 0 ; i < row ; i ++ ) System . out . print ( mat [ i ] [ row - i - 1 ] * mat [ i ] [ row - i - 1 ] + " ▁ " ) ; }
static int maxArea ( int mat [ ] [ ] ) { int hist [ ] [ ] = new int [ R + 1 ] [ C ] ; for ( int i = 0 ; i <= R ; i ++ ) { hist [ 0 ] [ i ] = mat [ 0 ] [ i ] ; for ( int j = 1 ; j <= R ; j ++ ) { if ( mat [ j ] [ i ] == 0 ) hist [ j ] [ i ] = 0 ; else hist [ j ] [ i ] = hist [ j - 1 ] [ i ] + 1 ; } } int count [ ] = new int [ R ] [ C ] ; for ( int i = 0 ; i <= R ; i ++ ) { count [ i ] [ j ] = mat [ i ] [ i ] ; for ( int j = 0 ; j <= C ; j ++ ) { if ( count [ j ] > 0 ) { for ( int k = 0 ; k < count [ j ] ; k ++ ) { hist [ i ] [ col_no ] = j ; col_no ++ ; } } } int max_area = 0 ; for ( int i = 0 ; i <= R ; i ++ ) { for ( int j = 0 ; j < C ; j ++ ) { int curr_area = ( j + 1 ) * hist [ i ] [ j ] ; if ( curr_area > max_area ) { max_area = curr_area ; } } } return max_area ; }
static int longestSubseqWithDiffOne ( int arr [ ] , int n ) { int dp [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) dp [ i ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( ( arr [ i ] == arr [ j ] + 1 ) || ( arr [ i ] == arr [ j ] - 1 ) ) { dp [ i ] = Math . max ( dp [ i ] , dp [ j ] + 1 ) ; } } int result = 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( result < dp [ i ] ) result = dp [ i ] ; } return result ; }
static int maxSquare ( int b , int m ) { return ( b / m - 1 ) * ( b / m ) / 2 ; }
static void spiralPrint ( int m , int n , int a [ ] [ ] ) { int i , k = 0 , l = 0 ; while ( k < m && l < n ) { for ( i = l ; i < n ; ++ i ) { System . out . print ( a [ k ] [ i ] + " ▁ " ) ; } k ++ ; for ( i = k ; i < m ; ++ i ) { System . out . print ( a [ i ] [ n - 1 ] + " ▁ " ) ; } n -- ; if ( k < m ) { for ( i = n - 1 ; i >= ( l - 1 ) ; -- i ) { System . out . print ( a [ m - 1 ] [ i ] + " ▁ " ) ; } m -- ; } if ( l < n ) { for ( i = m - 1 ; i >= k ; -- i ) { System . out . print ( a [ i ] [ l ] + " ▁ " ) ; } l ++ ; } }
static int pentagonalNum ( int n ) { return ( 3 * n * n - n ) / 2 ; }
static int countNonDecreasing ( int n ) { int N = 10 ; int count = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { count = count * ( N + i - 1 ) ) ; count = count / i ; } return count ; }
public static int kth ( int arr1 [ ] , int arr2 [ ] , int m , int n , int k ) { int sorted1 [ ] = new int [ m + n ] ; int i = 0 , j = 0 , d = 0 ; while ( i < m && j < n ) { if ( arr1 [ i ] < arr2 [ j ] ) sorted1 [ d ] = arr1 [ i ] ; i ++ ; else { sorted1 [ d ] = arr2 [ j ] ; j ++ ; } d ++ ; } while ( i < m ) { sorted1 [ d ] = arr1 [ i ++ ] ; d ++ ; i ++ ; } while ( j < n ) { sorted1 [ d ] = arr2 [ j ++ ] ; d ++ ; j ++ ; } return sorted1 [ k - 1 ] ; }
static int binomialCoeff ( int n , int k ) { if ( k == 0 || k == n ) return 1 ; return binomialCoeff ( n - 1 , k - 1 ) + binomialCoeff ( n - 1 , k ) ; }
static void printDistinct ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int d = 0 ; for ( int j = 0 ; j < i ; j ++ ) if ( arr [ i ] == arr [ j ] ) d = 1 ; break ; if ( d == 0 ) System . out . print ( arr [ i ] ) ; } }
static int countSolutions ( int n ) { int res = 0 ; int x = 0 ; while ( x * x < n ) { int y = 0 ; while ( x * x + y * y < n ) { res ++ ; y = y + 1 ; } x = x + 1 ; } return res ; }
static void relativeComplement ( int arr1 [ ] , int arr2 [ ] , int n , int m ) { int i = 0 , j = 0 ; while ( i < n && j < m ) { if ( arr1 [ i ] < arr2 [ j ] ) System . out . print ( arr1 [ i ] + " ▁ " ) ; i ++ ; } else if ( arr1 [ i ] > arr2 [ j ] ) { j ++ ; } else if ( arr1 [ i ] == arr2 [ j ] ) { i ++ ; j ++ ; } } while ( i < n ) System . out . print ( arr1 [ i ++ ] + " ▁ " ) ; }
static int findTrailingZeros ( int n ) { int count = 0 ; for ( int i = 5 ; n / i >= 1 ; count += n / i ) ; i *= 5 ; return count ; }
static int CountSubString ( String str , int n ) { int ans = ( n * ( n + 1 ) ) / 2 ; int a_index = 0 , b_index = 0 , c_index = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str . charAt ( i ) == ' a ' ) a_index = i + 1 ; ans -= Math . min ( b_index , c_index ) ; else if ( str . charAt ( i ) == ' b ' ) b_index = i + 1 ; ans -= Math . min ( a_index , c_index ) ; else c_index = i + 1 ; } } return ans ; }
static int findLargestd ( int S [ ] , int n ) { boolean found = false ; Arrays . sort ( S ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == j ) continue ; for ( int k = j + 1 ; k < n ; k ++ ) { if ( i == k ) continue ; for ( int l = k + 1 ; l < n ; l ++ ) { if ( i == l ) continue ; if ( S [ i ] == S [ j ] + S [ k ] + S [ l ] ) { found = true ; return S [ i ] ; } } } if ( found == false ) return - 1 ; } return - 1 ; }
static int constructTree ( int n , int d , int h ) { if ( d == 1 ) System . out . println ( " 1 ▁ 2 " ) ; return 0 ; if ( n == 2 && h == 1 ) System . out . println ( " 1 ▁ 2 " ) ; return 0 ; } if ( d > 2 * h ) System . out . println ( " - 1" ) ; return 0 ; }
static int rectCount ( int n , int m ) { return ( m * n * ( n + 1 ) * ( m + 1 ) ) / 4 ; }
static void subarrayDivisibleByK ( int arr [ ] , int n , int k ) { int [ ] mp = new int [ 1000 ] ; int s = 0 , e = 0 , maxs = 0 , maxe = 0 ; for ( int i = 0 ; i < n ; i ++ ) { mp [ arr [ 0 ] % k ] = mp [ arr [ 0 ] % k ] + 1 ; s = s + 1 ; e = e + 1 ; if ( ( mod == 0 && mp [ mod ] != 0 ) ) { mp [ arr [ s ] % k ] = mp [ arr [ s ] % k ] - 1 ; s = s + 1 ; } mp [ mod ] = mp [ mod ] + 1 ; e = e + 1 ; if ( ( e - s ) > ( maxe - maxs ) ) { maxe = e ; maxs = s ; } } System . out . println ( " The ▁ maximum ▁ size ▁ is ▁ " + ( maxe - maxs + 1 ) ) ; for ( int i = maxs ; i <= maxe ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; }
static void swapUpperToLower ( int arr [ ] [ ] ) { int n = arr . length ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int temp = arr [ i ] [ j ] ; arr [ i ] [ j ] = arr [ j ] [ i ] ; arr [ j ] [ i ] = temp ; } } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { System . out . print ( arr [ i ] [ j ] + " ▁ " ) ; } System . out . println ( ) ; } }
static int kthgroupsum ( int k ) { int cur = ( k * ( k - 1 ) ) + 1 ; int sum = 0 ; for ( int k = k - 1 ; k > 0 ; k -- ) sum += cur ; return sum ; }
static boolean isMagicSquare ( int mat [ ] [ ] ) { int s = 0 ; for ( int i = 0 ; i < N ; i ++ ) { s = s + mat [ i ] [ i ] ; } int s2 = 0 ; for ( int i = 0 ; i < N ; i ++ ) { s2 = s2 + mat [ i ] [ N - i - 1 ] ; if ( s != s2 ) { return false ; } } for ( int i = 0 ; i < N ; i ++ ) { int rowSum = 0 ; for ( int j = 0 ; j < N ; j ++ ) { rowSum += mat [ i ] [ j ] ; } if ( s != rowSum ) { return false ; } } return true ; }
static boolean isScalarMatrix ( int mat [ ] [ ] ) { int i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < N ; j ++ ) if ( ( i != j ) && ( mat [ i ] [ j ] != 0 ) ) return false ; for ( i = 0 ; i < N - 1 ; i ++ ) if ( mat [ i ] [ i ] != mat [ i + 1 ] [ i + 1 ] ) return false ; for ( i = 0 ; i < N - 2 ; i ++ ) { if ( mat [ i ] [ i ] != mat [ i + 1 ] [ i + 1 ] ) return false ; } } return true ; }
public static int maxDiff ( int arr [ ] , int n ) { int SubsetSum_1 = 0 , SubsetSum_2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { boolean isSingleOccurance = true ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] == arr [ j ] ) { isSingleOccurance = false ; arr [ i ] = arr [ j ] = 0 ; break ; } } if ( isSingleOccurance == true ) { if ( arr [ i ] > 0 ) SubsetSum_1 += arr [ i ] ; else SubsetSum_2 += arr [ i ] ; } } return Math . abs ( SubsetSum_1 - SubsetSum_2 ) ; }
static int maxCost ( int mat [ ] [ ] , int N ) { int dp [ ] [ ] = new int [ N ] [ N ] ; dp [ 0 ] [ 0 ] = mat [ 0 ] [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) { dp [ i ] [ 0 ] = mat [ i ] [ 0 ] + dp [ i - 1 ] [ 0 ] ; } for ( int i = 1 ; i < N ; i ++ ) { for ( int j = 1 ; j <= Math . min ( i + 1 , N ) ; j ++ ) { dp [ i ] [ j ] = mat [ i ] [ j ] + dp [ i - 1 ] [ j - 1 ] ; Math . max ( dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ j ] ) ; } } int result = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( result < dp [ N - 1 ] [ i ] ) result = dp [ N - 1 ] [ i ] ; return result ; }
static int evenSum ( int n ) { int C [ ] [ ] = new int [ n + 1 ] [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( n % 2 == 0 ) sum += C [ n ] [ i ] ; } } return sum ; }
static void diagonalsquare ( int mat [ ] [ ] , int row , int column ) { System . out . println ( " Diagonal ▁ one ▁ : ▁ " ) ; for ( int i = 0 ; i < row ; i ++ ) { for ( int j = 0 ; j < column ; j ++ ) { if ( i == j ) System . out . print ( " { } ▁ " . format ( mat [ i ] [ j ] * mat [ i ] [ j ] ) ) ; end = " " ) ; } System . out . println ( " ▁ \n \n " ) ; for ( int i = 0 ; i < row ; i ++ ) { for ( int j = 0 ; j < column ; j ++ ) { if ( i + j == column - 1 ) System . out . print ( " { } ▁ " . format ( mat [ i ] [ j ] * mat [ i ] [ j ] ) ) ; end = " " ) ; } } System . out . println ( ) ; }
static int areSumSame ( int a [ ] [ ] , int n , int m ) { int sum1 = 0 , sum2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum1 = 0 ; sum2 = 0 ; for ( int j = 0 ; j < m ; j ++ ) { sum1 += a [ i ] [ j ] ; sum2 += a [ j ] [ i ] ; } if ( sum1 == sum2 ) return 1 ; } return 0 ; }
static int countPairs ( int arr [ ] , int n ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int product = arr [ i ] * arr [ j ] ; for ( int k = 0 ; k < n ; k ++ ) { if ( arr [ k ] == product ) result ++ ; break ; } } } return result ; }
static int minCost ( int a [ ] , int n , int k ) { int dp [ ] [ ] = new int [ k + 1 ] [ n + 1 ] ; dp [ 0 ] [ 0 ] = 0 ; for ( int i = 1 ; i <= k ; i ++ ) { for ( int j = i ; j <= n ; j ++ ) { for ( int m = i - 1 ; m >= 0 ; m -- ) { dp [ i ] [ j ] = Math . min ( dp [ m ] [ j - 1 ] + ( a [ i - 1 ] - a [ m ] ) * ( a [ i - 1 ] - a [ m ] ) ) ; } } return dp [ n ] [ k ] ; }
static int countSetBits ( int n ) { if ( n == 0 ) return 0 ; else return 1 + countSetBits ( n & ( n - 1 ) ) ; }
static boolean checkEulerFourSquareIdentity ( int a , int b ) { int ab = a * b ; boolean flag = false ; for ( int i = 0 ; i * i <= ab ; i ++ ) { int j = i ; while ( i * i + j * j <= ab ) { int k = j ; while ( i * i + j * j + k * k <= ab ) { int l = ( ab - ( i * i + j * j + k * k ) ) ** ( 0.5 ) ; if ( l == int . MIN_VALUE ) && l >= k ) { flag = true ; System . out . println ( " i ▁ = ▁ " + i ) ; System . out . println ( " j ▁ = ▁ " + j ) ; System . out . println ( " k ▁ = ▁ " + k ) ; System . out . println ( " l ▁ = ▁ " + l ) ; if ( l == int . MIN_VALUE ) { flag = true ; System . out . println ( " Product ▁ of ▁ squares ▁ of ▁ i , ▁ j , ▁ k , ▁ l " ) ; } k ++ ; } j ++ ; } if ( flag == false ) System . out . println ( " Solution ▁ doesn't ▁ exist ! " ) ; return false ; }
static int countIslands ( int mat [ ] [ ] ) { int count = 0 ; for ( int i = 0 ; i < M ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( mat [ i ] [ j ] == ' X ' ) { if ( i == 0 || mat [ i - 1 ] [ j ] == ' O ' ) count ++ ; } } } return count ; }
static int getInvCount ( int arr [ ] , int n ) { int invcount = 0 ; for ( int i = 1 ; i <= n - 2 ; i ++ ) { int small = 0 ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] > arr [ j ] ) small ++ ; } int great = 0 ; for ( int j = i - 1 ; j >= 0 ; j -- ) { if ( arr [ i ] < arr [ j ] ) great ++ ; } invcount += great * small ; } return invcount ; }
static int find ( int n , int k ) { if ( n + 1 >= k ) return ( k - 1 ) ; else return ( 2 * n + 1 - k ) ; }
static void generate ( int ones , int zeroes , String str , int len1 ) { if ( len1 == str . length ( ) ) System . out . print ( str + " ▁ " ) ; return ; }
static void midPointCircleDraw ( int x_centre , int y_centre , int r ) { int x = r ; int y = 0 ; System . out . println ( " ( " + x + x_centre + " , ▁ " + y + y_centre + " ) " ) ; int P = 1 - r ; while ( x > y ) { y ++ ; if ( P <= 0 ) P = P + 2 * y + 1 ; else { x -- ; } } if ( x < y ) { break ; } if ( x < y ) { break ; } System . out . println ( " ( " + x + x_centre + " , ▁ " + y + " ) " ) ; if ( P <= 0 ) P = P + 2 * y + 1 ; else { P = P + 2 * y - 2 * x + 1 ; } } System . out . println ( " ( " + x + x_centre + " , ▁ " + y + y_centre + " ) " ) ; if ( x != y ) { break ; } System . out . println ( " ( " + x + x_centre + " , ▁ " + y + y_centre + " ) " ) ; } System . out . println ( ) ; }
static void printFactorialNums ( int n ) { int fact = 1 ; int x = 2 ; while ( fact <= n ) { System . out . print ( fact ) ; fact = fact * x ; x ++ ; } }
static int countFriendsPairings ( int n ) { int dp [ ] = new int [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { if ( i <= 2 ) dp [ i ] = i ; else dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; } return dp [ n ] ; }
static int findNth ( int n ) { int count = 0 ; for ( int curr = 0 ; curr < n ; ++ curr ) { int sum = 0 ; for ( int x = curr ; x < 10 ; ++ x ) sum = sum + x % 10 ; if ( sum == 10 ) count ++ ; if ( count == n ) return curr ; } return - 1 ; }
static int maximumSum ( int arr [ ] , int n , int k ) { int min = Integer . MAX_VALUE ; int index = - 1 ; for ( int i = 1 ; i <= k ; i ++ ) { min = Integer . MAX_VALUE ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] < min ) { min = arr [ j ] ; index = j ; } } if ( min == 0 ) break ; arr [ index ] = - arr [ index ] ; } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; return sum ; }
static void printSquares ( int n ) { int square = 0 ; int odd = 1 ; for ( int x = 0 ; x < n ; x ++ ) { System . out . print ( square + " ▁ " ) ; square = square + odd ; odd = odd + 2 ; } }
public static int numberOfPaths ( int m , int n ) { if ( m == 1 || n == 1 ) return 1 ; return numberOfPaths ( m - 1 , n ) + numberOfPaths ( m , n - 1 ) ; }
static int binarySearch ( int [ ] arr , int l , int r , int x ) { if ( r >= l ) { int mid = l + ( r - l ) / 2 ; if ( arr [ mid ] == x ) return mid ; else if ( arr [ mid ] > x ) return binarySearch ( arr , l , mid - 1 , x ) ; else if ( arr [ mid ] > x ) return binarySearch ( arr , mid + 1 , r , x ) ; } else return - 1 ; }
static int numberOfPaths ( int m , int n ) { int [ ] [ ] count = new int [ m ] [ n ] ; for ( int i = 0 ; i < m ; i ++ ) { count [ i ] [ 0 ] = 1 ; } for ( int j = 0 ; j < n ; j ++ ) { count [ 0 ] [ j ] = 1 ; } for ( int i = 1 ; i < m ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) { count [ i ] [ j ] = count [ i - 1 ] [ j ] + count [ i ] [ j - 1 ] ; } } return count [ m - 1 ] [ n - 1 ] ; }
static int answer ( int n ) { int dp [ ] [ ] = new int [ n + 1 ] [ n + 1 ] ; if ( n == 1 ) return 10 ; for ( int [ ] rows : dp ) Arrays . fill ( rows , 0 ) ; for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 0 ; j < 10 ; j ++ ) { dp [ 0 ] [ j ] = dp [ i - 1 ] [ j + 1 ] ; } else if ( j == 9 ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] ; } else { dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] ; } } } int sum = 0 ; for ( int j = 1 ; j <= 10 ; j ++ ) sum += dp [ n ] [ j ] ; return sum ; }
static void recaman ( int n ) { int [ ] arr = new int [ n ] ; arr [ 0 ] = 0 ; System . out . println ( arr [ 0 ] + " , ▁ " ) ; for ( int i = 1 ; i <= n ; i ++ ) { int curr = arr [ i - 1 ] - i ; for ( int j = 0 ; j < i ; j ++ ) if ( ( arr [ j ] == curr ) || curr < 0 ) { curr = arr [ i - 1 ] + i ; break ; } } arr [ i ] = curr ; System . out . println ( arr [ i ] + " , ▁ " ) ; }
static int modInverse ( int a , int m ) { a = a % m ; for ( int x = 1 ; x < m ; x ++ ) if ( ( a * x ) % m == 1 ) return x ; return 1 ; }
static int lenghtOfLongestAP ( int [ ] set , int n ) { if ( n <= 2 ) return n ; int llap = 2 ; for ( int i = 0 ; i < n ; i ++ ) { L [ i ] [ n - 1 ] = 2 ; } for ( int j = n - 2 ; j >= 0 ; j -- ) { int k ; for ( k = j + 1 ; k <= n - 1 ; k ++ ) { if ( set [ i ] + set [ k ] < 2 * set [ j ] ) L [ i ] [ j ] = 2 ; i -- ; } else { L [ i ] [ j ] = L [ j ] [ k ] + 1 ; llap = Math . max ( llap , L [ i ] [ j ] ) ; i -- ; k ++ ; } } } return llap ; }
static int findIndex ( int n ) { if ( n <= 1 ) return n ; int a = 0 , b = 1 , c = 1 ; int res = 1 ; while ( c < n ) { c = a + b ; res ++ ; a = b ; b = c ; } return res ; }
static int maxSumPairWithDifferenceLessThanK ( int arr [ ] , int N , int k ) { int maxSum = 0 ; Arrays . sort ( arr ) ; for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( arr [ i ] - arr [ i - 1 ] < k ) maxSum += arr [ i ] ; maxSum += arr [ i - 1 ] ; } return maxSum ; }
static int calculateEnergy ( int mat [ ] [ ] , int n ) { int tot_energy = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { int q = mat [ i ] [ j ] / n ; int i_des = q ; int j_des = mat [ i ] [ j ] - ( n * q ) ; tot_energy += ( Math . abs ( i_des - i ) + Math . abs ( j_des - j ) ) ; } } return tot_energy ; }
static void antiSpiralTraversal ( int m , int n , int a [ ] [ ] ) { int i , k = 0 , l = 0 ; Stack < Integer > stk = new Stack < > ( ) ; while ( k <= m && l <= n ) { for ( i = l ; i <= n ; i ++ ) { stk . push ( a [ k ] [ i ] ) ; } k ++ ; for ( i = k ; i <= m ; i ++ ) { stk . push ( a [ i ] [ n ] ) ; } n -- ; if ( k <= m ) { for ( i = n ; i <= l ; i -- ) { stk . push ( a [ m ] [ i ] ) ; } m -- ; } if ( l <= n ) { for ( i = m ; i >= k ; i -- ) { stk . push ( a [ i ] [ l ] ) ; } l ++ ; } } while ( ! stk . empty ( ) ) System . out . print ( " ▁ " ) ; stk . pop ( ) ; }
static int findMaxVal ( int arr [ ] , int n , int maxLimit ) { int ind = - 1 , val = - 1 ; int dp [ ] [ ] = new int [ maxLimit + 1 ] [ n ] ; for ( ind = 0 ; ind < n ; ind ++ ) { for ( val = 0 ; val < maxLimit ; val ++ ) { if ( ind == 0 ) { if ( num - arr [ ind ] == val || num + arr [ ind ] == val ) { dp [ ind ] [ val ] = 1 ; } else { dp [ ind ] [ val ] = 0 ; } } } for ( val = 0 ; val < maxLimit ; val ++ ) { if ( val - arr [ ind ] >= 0 && val + arr [ ind ] <= maxLimit ) { if ( dp [ ind - 1 ] [ val - arr [ ind ] ] == 1 || dp [ ind - 1 ] [ val + arr [ ind ] ] == 1 ) { dp [ ind ] [ val ] = 1 ; } else { dp [ ind ] [ val ] = 0 ; } } } for ( val = maxLimit ; val >= 0 ; val -- ) { if ( dp [ n - 1 ] [ val ] == 1 ) return val ; } return - 1 ; }
static int Resources ( int process , int need ) { int minResources = 0 ; minResources = process * ( need - 1 ) + 1 ; return minResources ; }
static int countIntegralSolutions ( int n ) { int result = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { for ( int k = 0 ; k <= n ; k ++ ) { if ( i + j + k == n ) result ++ ; } } } return result ; }
static int minCost ( int cost [ ] [ ] ) { int dist [ ] = new int [ N ] [ N ] ; for ( int i = 0 ; i < N ; i ++ ) dist [ i ] = INF ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = i + 1 ; j < N ; j ++ ) if ( dist [ j ] > dist [ i ] + cost [ i ] [ j ] ) dist [ j ] = dist [ i ] + cost [ i ] [ j ] ; } return dist [ N - 1 ] ; }
int countDivisibles ( int arr [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] % arr [ j ] == 0 || arr [ j ] % arr [ i ] == 0 ) res ++ ; } return res ; }
static void pairSum ( int mat [ ] [ ] , int n , int sum ) { int i , j , left , right ; quickSort ( mat , 0 , n - 1 ) ; for ( i = 0 ; i < n - 2 ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { left = 0 ; right = n - 1 ; while ( left < n && right >= 0 ) { if ( ( mat [ i ] [ left ] + mat [ j ] [ right ] ) == sum ) { System . out . print ( " ( " + mat [ i ] [ left ] + " , ▁ " + mat [ j ] [ right ] + " ) , ▁ " ) ; left ++ ; right -- ; } else { if ( ( mat [ i ] [ left ] + mat [ j ] [ right ] ) < sum ) left ++ ; else right -- ; } } }
static boolean isPowerOfFour ( int n ) { if ( n == 0 ) return false ; while ( n != 1 ) { if ( n % 4 != 0 ) return false ; n = n / 4 ; } return true ; }
static int distancesum ( int x [ ] , int y [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) sum += ( Math . abs ( x [ i ] - x [ j ] ) + Math . abs ( y [ i ] - y [ j ] ) ) ; } return sum ; }
static void findMax ( int arr [ ] [ ] ) { int row = 0 , j = N - 1 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] [ j ] == 1 && j >= 0 ) { row = i ; j -- ; } } System . out . println ( " Row ▁ number ▁ = ▁ " + row + " , ▁ MaxCount ▁ = ▁ " + N - 1 - j ) ; }
static int lastNon0Digit ( int n ) { if ( n < 10 ) return dig [ n ] ; if ( ( ( n / 10 ) % 10 ) % 2 == 0 ) return ( 6 * lastNon0Digit ( n / 5 ) * dig [ n % 10 ] ) % 10 ; else return ( 4 * lastNon0Digit ( n / 5 ) * dig [ n % 10 ] ) % 10 ; }
static int search ( int arr [ ] , int n , int x ) { int i ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == x ) return i ; } System . out . println ( " number ▁ is ▁ not ▁ present ! " ) ; return - 1 ; }
static void printHosoya ( int n ) { int dp [ ] [ ] = new int [ N ] [ n ] ; dp [ 0 ] [ 0 ] = dp [ 1 ] [ 0 ] = 1 ; for ( int i = 2 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i > j ) dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] + dp [ i - 2 ] [ j - 2 ] ) ; else dp [ i ] [ j ] = ( dp [ i - 1 ] [ j - 1 ] + dp [ i - 2 ] [ j - 2 ] ) ; } } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { System . out . print ( dp [ i ] [ j ] + ' ▁ ' ) ; } System . out . println ( ) ; } }
static void insertionSortRecursive ( int arr [ ] , int n ) { if ( n <= 1 ) return ; insertionSortRecursive ( arr , n - 1 ) ; int j , last = arr [ n - 1 ] ; for ( j = n - 2 ; j >= 0 && arr [ j ] > last ; j -- ) arr [ j + 1 ] = arr [ j ] ; arr [ j + 1 ] = last ; }
static int nthTerm ( int n ) { return ( n * n ) + ( n * n * n ) ; }
static int findMaxAverage ( int arr [ ] , int n , int k ) { if ( k > n ) return - 1 ; int sum = arr [ 0 ] ; for ( int i = 1 ; i < k ; i ++ ) sum += arr [ i ] ; int max_sum = sum ; int max_end = k - 1 ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + arr [ i ] - arr [ i - k ] ; if ( sum > max_sum ) { max_sum = sum ; max_end = i ; } } return max_end - k + 1 ; }
static int sumOfSeries ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += ( 2 * i - 1 ) * ( 2 * i - 1 ) ; return sum ; }
static void printString ( String str , char ch , int count ) { int occ , i = 0 ; if ( count == 0 ) System . out . println ( str ) ; for ( i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) == ch ) occ ++ ; if ( occ == count ) break ; if ( i < str . length ( ) - 1 ) System . out . print ( str . charAt ( i + 1 ) ) ; else System . out . println ( " Empty ▁ string " ) ; } else { System . out . println ( " Empty ▁ string " ) ; } }
static void printPascal ( int n ) { int arr [ ] [ ] = new int [ n ] [ n ] ; for ( int line = 0 ; line < n ; line ++ ) { arr [ line ] [ 0 ] = 1 ; for ( int i = 0 ; i < line ; i ++ ) { if ( i is 0 || i is line ) arr [ line ] [ i ] = 1 ; else arr [ line ] [ i ] = ( arr [ line - 1 ] [ i - 1 ] + arr [ line - 1 ] [ i ] ) ; System . out . print ( arr [ line ] [ i ] + " ▁ " ) ; } System . out . print ( " \n " ) ; } }
static int answer_query ( char a [ ] , int n , int l , int r ) { int count = 0 ; for ( int i = 0 ; i < l ; i += 2 ) if ( a [ i ] == a [ i + 1 ] ) count ++ ; return count ; }
static int compute_average ( int a , int b ) { return ( a + b ) / 2 ; }
static void findElements ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) if ( arr [ j ] > arr [ i ] ) count ++ ; if ( count >= 2 ) System . out . print ( arr [ i ] + " ▁ " ) ; } }
static int possibleStrings ( int n , int r , int b , int g ) { int fact [ ] = new int [ n + 1 ] ; fact [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) fact [ i ] = fact [ i - 1 ] * i ; int left = n - ( r + g + b ) ; int sum = 0 ; for ( int i = 0 ; i <= left ; i ++ ) { for ( int j = 0 ; j <= left - i ; j ++ ) { int k = left - ( i + j ) ; sum = sum + fact [ n ] / ( fact [ i + r ] * fact [ j + b ] * fact [ k + g ] ) ; } } return sum ; }
static int maxPathSum ( int tri [ ] [ ] , int m , int n ) { for ( int i = m - 1 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < n - 1 ; j ++ ) { if ( tri [ i + 1 ] [ j ] > tri [ i + 1 ] [ j + 1 ] ) tri [ i ] [ j ] += tri [ i + 1 ] [ j ] ; else tri [ i ] [ j ] += tri [ i + 1 ] [ j + 1 ] ; } } return tri [ 0 ] [ 0 ] ; }
static int fun ( int n ) { return n & ( n - 1 ) ; }
static int mirrorImage ( int a , int b , int c , int x1 , int y1 ) { double temp = - 2 * ( a * x1 + b * y1 + c ) / ( a * a + b * b ) ; int x = temp * a + x1 ; int y = temp * b + y1 ; return ( x , y ) ; }
static int printIntersection ( int arr1 [ ] , int arr2 [ ] , int m , int n ) { int i = 0 , j = 0 ; while ( i < m && j < n ) { if ( arr1 [ i ] < arr2 [ j ] ) i ++ ; else if ( arr2 [ j ] < arr1 [ i ] ) j ++ ; else System . out . print ( arr2 [ j ] ) ; } return 0 ; }
static int rotateMatrix ( int mat [ ] [ ] ) { if ( mat == null ) return new int [ ] [ ] ; int top = 0 , bottom = mat . length - 1 ; int left = 0 , right = mat . length - 1 ; while ( left < right && top < bottom ) { int prev = mat [ top + 1 ] [ left ] ; for ( int i = left ; i <= right ; i ++ ) { curr = mat [ top ] [ i ] ; mat [ top ] [ i ] = prev ; prev = curr ; } top ++ ; for ( int i = top ; i <= bottom ; i ++ ) { curr = mat [ i ] [ right ] ; mat [ i ] [ right ] = prev ; prev = curr ; } right -- ; for ( int i = right ; i >= left ; i -- ) { curr = mat [ bottom ] [ i ] ; mat [ bottom ] [ i ] = prev ; prev = curr ; } bottom -- ; } for ( int i = bottom ; i >= top ; i -- ) { curr = mat [ i ] [ left ] ; mat [ i ] [ left ] = prev ; prev = curr ; } left ++ ; } } return mat ; }
static void rearrange ( int arr [ ] , int n ) { int max_idx = n - 1 ; int min_idx = 0 ; int max_elem = arr [ n - 1 ] + 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) arr [ i ] += ( arr [ max_idx ] % max_elem ) * max_elem ; max_idx -- ; else arr [ i ] += ( arr [ min_idx ] % max_elem ) * max_elem ; min_idx ++ ; } } for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = arr [ i ] / max_elem ; } }
static void printTreeEdges ( int prufer [ ] , int m ) { int vertices = m + 2 ; int [ ] vertex_set = new int [ vertices ] ; for ( int i = 0 ; i < vertices - 2 ; i ++ ) { vertex_set [ prufer [ i ] - 1 ] ++ ; } System . out . println ( " The ▁ edge ▁ set ▁ E ( G ) ▁ is ▁ : " ) ; for ( int i = 0 ; i < vertices - 2 ; i ++ ) { for ( int j = 0 ; j < vertices ; j ++ ) { if ( vertex_set [ j ] == 0 ) vertex_set [ j ] = - 1 ; System . out . print ( " ( " + ( j + 1 ) + " , ▁ " + prufer [ i ] + " ) ▁ " ) ; } } int j = 0 ; for ( int i = 0 ; i < vertices ; i ++ ) { if ( vertex_set [ i ] == 0 && j == 0 ) System . out . print ( ( i + 1 ) + " , ▁ " ) ; j ++ ; } else if ( vertex_set [ i ] == 0 && j == 1 ) System . out . print ( ( i + 1 ) + " , ▁ " ) ; } }
static int countDecodingDP ( char digits [ ] , int n ) { int [ ] count = new int [ n + 1 ] ; count [ 0 ] = 1 ; count [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { count [ i ] = 0 ; if ( digits [ i - 1 ] > '0' ) count [ i ] = count [ i - 1 ] ; if ( digits [ i - 2 ] == '1' || ( digits [ i - 2 ] == '2' && digits [ i - 1 ] < '7' ) ) count [ i ] += count [ i - 2 ] ; } return count [ n ] ; }
static int largest ( int arr [ ] , int n ) { int max = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; } return max ; }
static void transpose ( int A [ ] [ ] , int B [ ] [ ] ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) B [ i ] [ j ] = A [ j ] [ i ] ; } }
static int sumEqualProduct ( int a [ ] , int n ) { int zero = 0 , two = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) zero ++ ; if ( a [ i ] == 2 ) two ++ ; } int cnt = ( zero * ( zero - 1 ) ) / 2 + ( two * ( two - 1 ) ) / 2 ; return cnt ; }
static boolean isPrime ( int n ) { if ( n <= 1 ) System . out . println ( " False " ) ; if ( n <= 3 ) System . out . println ( " True " ) ; if ( n % 2 == 0 || n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
static void fib ( int n ) { int a = 0 , b = 1 ; if ( n >= 0 ) System . out . print ( a + ' ▁ ' ) ; if ( n >= 1 ) System . out . print ( b + ' ▁ ' ) ; for ( int i = 2 ; i <= n ; i ++ ) System . out . print ( a + b + ' ▁ ' ) ; for ( int i = 2 ; i <= n ; i ++ ) System . out . print ( a + b + ' ▁ ' ) ; b = a + b ; a = b - a ; } }
static void thirdLargest ( int arr [ ] , int arr_size ) { if ( arr_size < 3 ) System . out . println ( " ▁ Invalid ▁ Input ▁ " ) ; return ; } int first = arr [ 0 ] ; for ( int i = 1 ; i < arr_size ; i ++ ) { if ( arr [ i ] > first ) first = arr [ i ] ; } int second = Integer . MAX_VALUE ; for ( int i = 0 ; i < arr_size ; i ++ ) { if ( arr [ i ] > second && arr [ i ] < first ) second = arr [ i ] ; } int third = Integer . MAX_VALUE ; for ( int i = 0 ; i < arr_size ; i ++ ) { if ( arr [ i ] > third && arr [ i ] < second ) third = arr [ i ] ; } System . out . println ( " The ▁ Third ▁ Largest " + " element ▁ is ▁ " + third ) ; }
static int maxHamming ( int arr [ ] , int n ) { int brr [ ] = new int [ 2 * n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { brr [ i ] = arr [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { brr [ n + i ] = arr [ i ] ; } int maxHam = 0 ; for ( int i = 1 ; i < n ; i ++ ) { currHam = 0 ; int k = 0 ; for ( int j = i ; j < i + n ; j ++ ) { if ( brr [ j ] != arr [ k ] ) { currHam ++ ; k ++ ; } } if ( maxHam == n ) return n ; } return maxHam ; }
static int findSum ( int n , int K ) { int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) ans += ( i % K ) ; return ans ; }
static double seriesSum ( int n ) { int i = 1 ; double res = 0.0 ; boolean sign = true ; while ( n > 0 ) { n = n - 1 ; if ( sign ) { sign = false ; res = res + ( i + 1 ) / ( i + 2 ) ; i = i + 2 ; } else { sign = true ; res = res - ( i + 1 ) / ( i + 2 ) ; i = i + 2 ; } } return res ; }
static boolean isDiagonalMatrix ( int mat [ ] [ ] ) { int i , j ; for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < N ; j ++ ) { if ( ( i != j ) && ( mat [ i ] [ j ] != 0 ) ) return false ; } } return true ; }
static int getSingle ( int arr [ ] , int n ) { int ones = 0 ; int twos = 0 ; for ( int i = 0 ; i < n ; i ++ ) { twos = twos | ( ones & arr [ i ] ) ; ones = ones ^ arr [ i ] ; common_bit_mask = ~ ( ones & twos ) ; ones &= common_bit_mask ; twos &= common_bit_mask ; } return ones ; }
static int countNum ( int arr [ ] , int n ) { int count = 0 ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] != arr [ i + 1 ] && arr [ i ] != arr [ i + 1 ] - 1 ) count += arr [ i + 1 ] - arr [ i ] - 1 ; } return count ; }
static int CountSquares ( int a , int b ) { int cnt = 0 ; for ( int i = a ; i <= b ; i ++ ) { int j ; for ( j = 1 ; j * j <= i ; j ++ ) if ( j * j == i ) cnt ++ ; } return cnt ; }
static int minSum ( int n ) { int sum = 0 ; while ( n > 0 ) { sum += ( n % 10 ) ; n /= 10 ; if ( sum == 1 ) return 10 ; } return sum ; }
static int nonFibonacci ( int n ) { int prevPrev = 1 ; int prev = 2 ; int curr = 3 ; while ( n > 0 ) { prevPrev = prev ; prev = curr ; curr = prevPrev + prev ; n = n - ( curr - prev - 1 ) ; } return prev + n ; }
static void leftRotate ( int arr [ ] , int n , int k ) { for ( int i = k ; i < k + n ; i ++ ) System . out . print ( arr [ i % n ] + " ▁ " ) ; }
static String repeat ( String s , int n ) { String s1 = s ; for ( int i = 1 ; i <= n ; i ++ ) s1 = s + s1 ; return s ; }
static int findStep ( int n ) { if ( n == 1 || n == 0 ) return 1 ; else if ( n == 2 ) return 2 ; else return findStep ( n - 3 ) + findStep ( n - 2 ) + findStep ( n - 1 ) ; }
static int CountPS ( String str , int n ) { int dp [ ] [ ] = new int [ n ] [ n ] ; boolean [ ] [ ] P = new boolean [ n ] [ n ] ; int gap , i , j , k , L ; for ( i = 0 ; i < n ; i ++ ) { P [ i ] [ i ] = true ; dp [ i ] [ i + 1 ] = 1 ; } for ( gap = 2 ; gap < n - gap ; gap ++ ) { for ( i = 0 ; i < n - 1 ; i ++ ) { if ( str [ i ] == str . charAt ( i + 1 ) ) P [ i ] [ i + 1 ] = true ; if ( P [ i ] [ j ] == true ) P [ i ] [ j ] = true ; else { dp [ i ] [ j ] = ( dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] - dp [ i + 1 ] [ j - 1 ] ) ; } } } return dp [ 0 ] [ n - 1 ] ; }
static void modularEquation ( int a , int b ) { if ( a < b ) System . out . println ( " No ▁ solution ▁ possible ▁ " ) ; if ( a == b ) System . out . println ( " Infinite ▁ Solution ▁ possible ▁ " ) ; return ; } int count = 0 ; int n = a - b ; int y = ( int ) ( Math . sqrt ( a - b ) ) ; for ( int i = 1 ; i <= y ; i ++ ) { if ( n % i == 0 ) if ( n / i > b ) count ++ ; if ( i > b ) count ++ ; } } if ( y * y == n && y > b ) count = count - 1 ; System . out . println ( count ) ; }
static int maxSum ( int mat [ ] [ ] , int n ) { if ( n == 1 ) return mat [ 0 ] [ 0 ] ; int dp [ ] [ ] = new int [ n ] [ n ] ; int maxSum = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] [ 0 ] = mat [ i ] [ 0 ] ; } for ( int i = n - 2 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < n ; j ++ ) { int maxi = Integer . MIN_VALUE ; if ( ( ( j - 1 ) >= 0 ) && ( maxi < dp [ i + 1 ] [ j - 1 ] ) ) maxi = dp [ i + 1 ] [ j - 1 ] ; if ( ( ( j + 1 ) < n ) && ( maxi < dp [ i + 1 ] [ j + 1 ] ) ) maxi = dp [ i + 1 ] [ j + 1 ] ; dp [ i ] [ j ] = mat [ i ] [ j ] + maxi ; } } for ( int j = 0 ; j < n ; j ++ ) { if ( maxSum < dp [ 0 ] [ j ] ) maxSum = dp [ 0 ] [ j ] ; } } return maxSum ; }
static double arcLength ( double diameter , double angle ) { if ( angle >= 360 ) System . out . println ( " Angle ▁ cannot ▁ be ▁ formed " ) ; return 0 ; }
static boolean isPrime ( int n ) { if ( n <= 1 ) System . out . println ( " False " ) ; for ( int i = 2 ; i <= n ; i ++ ) if ( n % i == 0 ) return false ; return true ; }
static int findMaxAverage ( int arr [ ] , int n , int k ) { if ( k > n ) return - 1 ; int [ ] csum = new int [ n ] ; csum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) csum [ i ] = arr [ i ] ; int max_sum = csum [ k - 1 ] ; int max_end = k - 1 ; for ( int i = 0 ; i < k ; i ++ ) { int curr_sum = csum [ i ] - csum [ i - k ] ; if ( curr_sum > max_sum ) { max_sum = curr_sum ; max_end = i ; } } return max_end - k + 1 ; }
static int horner ( int poly [ ] , int n , int x ) { int result = poly [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) result = result * x + poly [ i ] ; return result ; }
public static int numberOfWays ( int x ) { if ( x == 0 || x == 1 ) return 1 ; else return numberOfWays ( x - 1 ) + ( x - 1 ) * numberOfWays ( x - 2 ) ; }
static int maxRowDiff ( int mat [ ] [ ] , int m , int n ) { int [ ] rowSum = new int [ m ] ; for ( int i = 0 ; i < m ; i ++ ) { int sum = 0 ; for ( int j = 0 ; j < n ; j ++ ) sum += mat [ i ] [ j ] ; rowSum [ i ] = sum ; } int max_diff = rowSum [ 1 ] - rowSum [ 0 ] ; int min_element = rowSum [ 0 ] ; for ( int i = 1 ; i < m ; i ++ ) { if ( rowSum [ i ] - min_element > max_diff ) { max_diff = rowSum [ i ] - min_element ; } if ( rowSum [ i ] < min_element ) { min_element = rowSum [ i ] ; } } return max_diff ; }
static int minCost ( int cost [ ] [ ] , int m , int n ) { int tc [ ] [ ] = new int [ C ] [ R ] ; tc [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] ; for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { tc [ i ] [ 0 ] = tc [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ] ; } for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { tc [ 0 ] [ j ] = tc [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ] ; } } return tc [ m ] [ n ] ; }
static int count_of_ways ( int n ) { int count = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { for ( int k = 0 ; k <= n ; k ++ ) { if ( i + j + k == n ) count ++ ; } } } return count ; }
static int countCommon ( int mat [ ] [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( mat [ i ] [ i ] == mat [ i ] [ n - i - 1 ] ) res ++ ; return res ; }
static int hexagonalNum ( int n ) { return n * ( 2 * n - 1 ) ; }
static int findGreatest ( int arr [ ] , int n ) { int result = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n - 1 ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) { if ( arr [ j ] * arr [ k ] == arr [ i ] ) result = Math . max ( result , arr [ i ] ) ; } } } return result ; }
static void squareRoot ( int n , int p ) { int x ; n = n % p ; for ( x = 2 ; x < p ; x ++ ) { if ( ( x * x ) % p == n ) System . out . println ( " Square ▁ root ▁ is ▁ " + x ) ; return ; } System . out . println ( " Square ▁ root ▁ doesn't ' t ▁ exist " ) ; }
static int leonardo ( int n ) { int dp [ ] = new int [ n + 1 ] ; dp . add ( 1 ) ; dp . add ( 1 ) ; for ( int i = 2 ; i <= n ; i ++ ) dp . add ( dp [ i - 1 ] + dp [ i - 2 ] + 1 ) ; return dp [ n ] ; }
static long evenbinomialCoeffSum ( int n ) { return ( 1 << ( n - 1 ) ) ; }
static int findMin ( int [ ] arr , int low , int high ) { if ( high < low ) return arr [ 0 ] ; if ( high == low ) { System . out . println ( " The ▁ required ▁ element ▁ is ▁ " + arr [ low ] ) ; return arr [ low ] ; } int mid = ( low + high ) / 2 ; if ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) return arr [ mid + 1 ] ; if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) return arr [ mid ] ; if ( arr [ high ] > arr [ mid ] ) return findMin ( arr , low , mid - 1 ) ; return findMin ( arr , mid + 1 , high ) ; }
static int findS ( int s ) { int _sum = 0 ; int n = 1 ; while ( _sum < s ) { _sum += n * n ; n ++ ; } if ( _sum == s ) return n ; return - 1 ; }
static int countStr ( int n ) { return 1 + ( n * 2 ) + ( n * ( ( n * n ) - 1 ) / 2 ) ; }
static void printSumSimple ( int mat [ ] [ ] , int k , int n ) { if ( k > n ) return ; for ( int i = 0 ; i <= k ; i ++ ) { for ( int j = 0 ; j <= n - k ; j ++ ) { int sum = 0 ; for ( int p = i ; p <= k + i ; p ++ ) { for ( int q = j ; q <= k + j ; q ++ ) { sum += mat [ p ] [ q ] ; } } System . out . print ( sum + " ▁ " ) ; } System . out . println ( ) ; }
static int countGroups ( int position , int previous_sum , int length , int num [ ] ) { if ( position == length ) return 1 ; if ( dp [ position ] [ previous_sum ] != - 1 ) return dp [ position ] [ previous_sum ] ; dp [ position ] [ previous_sum ] = 0 ; int res = 0 ; for ( int i = 0 ; i < position ; i ++ ) { sum += ( num [ i ] - '0' ) ; if ( sum >= previous_sum ) res += countGroups ( i + 1 , sum , length , num ) ; } if ( res >= previous_sum ) res += countGroups ( position + 1 , sum , length , num ) ; } return res ; }
static int intersection ( int n ) { return n * ( n - 1 ) ; }
static int findSum ( int n ) { n -- ; int sum = 0 ; sum += ( n * ( n + 1 ) ) / 2 ; sum += ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; return sum ; }
static int findRepeatingElement ( int [ ] arr , int low , int high ) { if ( low > high ) return - 1 ; int mid = ( low + high ) / 2 ; if ( arr [ mid ] != mid + 1 ) { if ( mid > 0 && arr [ mid ] == arr [ mid - 1 ] ) return mid ; return findRepeatingElement ( arr , low , mid - 1 ) ; } return findRepeatingElement ( arr , mid + 1 , high ) ; }
static int maxAverageOfPath ( int cost [ ] [ ] , int N ) { int dp [ ] [ ] = new int [ N ] [ N + 1 ] ; dp [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] ; for ( int i = 1 ; i <= N ; i ++ ) { dp [ i ] [ 0 ] = cost [ i ] [ 0 ] ; } for ( int j = 1 ; j <= N ; j ++ ) { dp [ 0 ] [ j ] = dp [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ] ; } for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 1 ; j <= N ; j ++ ) { dp [ i ] [ j ] = Math . max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) + cost [ i ] [ j ] ; } } return dp [ N - 1 ] [ N - 1 ] / ( 2 * N - 1 ) ; }
static int countPairsWithDiffK ( int arr [ ] , int n , int k ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] - arr [ j ] == k || arr [ j ] - arr [ i ] == k ) count ++ ; } return count ; }
static boolean isPrime ( int n , int i ) { if ( n <= 2 ) return true if ( n == 2 ) else false ; if ( n % i == 0 ) return false ; if ( i * i > n ) return true ; return isPrime ( n , i + 1 ) ; }
static int computeLastDigit ( int A , int B ) { int variable = 1 ; if ( A == B ) return 1 ; else if ( ( B - A ) >= 5 ) return 0 ; else { for ( int i = A + 1 ; i <= B ; i ++ ) variable = ( variable * ( i % 10 ) ) % 10 ; return variable % 10 ; } }
static boolean check ( int n ) { return 1162261467 % n == 0 ; }
static int sequence ( int n ) { if ( n == 1 || n == 2 ) return 1 ; else return sequence ( n - 1 ) + sequence ( n - sequence ( n - 1 ) ) ; }
static int findHeight ( int parent [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int p = i ; int current = 1 ; while ( parent [ p ] != - 1 ) current ++ ; p = parent [ p ] ; } res = Math . max ( res , current ) ; } return res ; }
static int HalfDiagonalSums ( int mat [ ] [ ] , int n ) { int diag1_left = 0 , diag1_right = 0 , diag2_left = 0 , diag2_right = 0 ; int i = 0 , j = n - 1 ; while ( i < n ) { if ( i < n / 2 ) { diag1_left += mat [ i ] [ i ] ; diag2_left += mat [ j ] [ i ] ; } else if ( i > n / 2 ) { diag1_right += mat [ i ] [ i ] ; diag2_right += mat [ j ] [ i ] ; } i ++ ; j -- ; } return ( diag1_left == diag2_right && diag2_left == diag2_left && diag1_right == diag2_left && diag2_right == mat [ n / 2 ] [ n / 2 ] ) ; }
static void LeibnizHarmonicTriangle ( int n ) { int [ ] [ ] C = new int [ n ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= i ; j ++ ) { if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) ; } } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) { if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ; } } } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) System . out . print ( i * C [ i - 1 ] [ j - 1 ] + " ▁ " ) ; } System . out . println ( ) ; }
static int floorSearch ( int [ ] arr , int low , int high , int x ) { if ( low > high ) return - 1 ; if ( x >= arr [ high ] ) return high ; int mid = ( low + high ) / 2 ; if ( arr [ mid ] == x ) return mid ; if ( mid > 0 && arr [ mid - 1 ] <= x && x < arr [ mid ] ) return mid - 1 ; if ( x < arr [ mid ] ) return mid + 1 ; return floorSearch ( arr , low , mid - 1 , x ) ; if ( x < arr [ mid ] ) return floorSearch ( arr , low , mid + 1 , x ) ; }
static int minimumflip ( int mat [ ] [ ] , int n ) { int flip = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) flip ++ ; } } return flip ; }
static int breakSum ( int n ) { if ( n == 0 || n == 1 ) return n ; return Math . max ( ( breakSum ( n / 2 ) + breakSum ( n / 3 ) + breakSum ( n / 4 ) ) ; }
int countPairs ( int arr1 [ ] , int arr2 [ ] , int m , int n , int x ) { int count = 0 ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) if ( arr1 [ i ] + arr2 [ j ] == x ) count ++ ; } return count ; }
static void alternateSubarray ( int arr [ ] , int n ) { int [ ] len = new int [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) len . add ( 0 ) ; len [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] ^ arr [ i + 1 ] == true ) len [ i ] = len [ i + 1 ] + 1 ; else len [ i ] = 1 ; } } for ( int i = 0 ; i < n ; i ++ ) System . out . print ( len [ i ] + " ▁ " ) ; }
static void subsequence ( char s [ ] , char t [ ] , int n , int k ) { int i , cnt = 0 ; int new_last = 0 , size = 0 ; String str = ' zyxwvutsrqponmlkjihgfedcba ' ; for ( ch = ' zyxwvutsrqponmlkjihgfedcba ' ; ch < str . length ( ) ; ch ++ ) { cnt ++ ; } if ( cnt >= k ) { for ( i = last ; i < n ; i ++ ) { if ( s [ i ] == ch ) { t [ size ] = ch ; new_last = i ; size ++ ; } } last = new_last ; } }
static int maxLen ( int arr [ ] ) { int max_len = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { int curr_sum = 0 ; for ( int j = i ; j < arr . length ; j ++ ) { curr_sum += arr [ j ] ; if ( curr_sum == 0 ) { max_len = j - i + 1 ; } } } return max_len ; }
public static int lcs ( int X [ ] , int Y [ ] , int m , int n ) { if ( m == 0 || n == 0 ) return 0 ; else if ( X [ m - 1 ] == Y [ n - 1 ] ) return 1 + lcs ( X , Y , m - 1 , n - 1 ) ; else return Math . max ( lcs ( X , Y , m , n - 1 ) , lcs ( X , Y , m - 1 , n ) ) ; }
static int multiply ( int x , int y ) { if ( y == 0 ) return 0 ; if ( y > 0 ) return ( x + multiply ( x , y - 1 ) ) ; if ( y < 0 ) return ( - multiply ( x , - y ) ) ; return ( x + multiply ( x , y - 1 ) ) ; }
static int countP ( int n , int k ) { int dp [ ] [ ] = new int [ k + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= k ; i ++ ) { dp [ i ] [ 0 ] = 0 ; } for ( int i = 0 ; i <= n ; i ++ ) { dp [ 0 ] [ i ] = 0 ; } for ( int i = 1 ; i <= k ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( j == 1 || i == j ) dp [ i ] [ j ] = 1 ; else dp [ i ] [ j ] = ( j * dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] ) ; } } return dp [ n ] [ k ] ; }
static int maxvolume ( int s ) { int length = ( s / 3 ) ; s -= length ; int breadth = s / 2 ; int height = s - breadth ; return length * breadth * height ; }
static int findLength ( String str ) { int n = str . length ( ) ; int maxlen = 0 ; int [ ] [ ] sum = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { sum [ i ] [ i ] = str . charAt ( i ) ; } for ( int length = 2 ; length <= n ; length ++ ) { for ( int i = 0 ; i < n ; i ++ ) { int j = i + length - 1 ; int k = length / 2 ; sum [ i ] [ j ] = sum [ i ] [ j - k ] + sum [ j - k + 1 ] [ j ] ; if ( length % 2 == 0 && sum [ i ] [ j - k ] == sum [ ( j - k + 1 ) ] [ j ] && length > maxlen ) { maxlen = length ; } } } return maxlen ; }
static int subArraySum ( int arr [ ] , int n , int sum ) { int curr_sum = arr [ 0 ] ; int start = 0 ; int i ; for ( i = 1 ; i <= n ; i ++ ) { while ( curr_sum > sum && start < i - 1 ) { curr_sum = curr_sum - arr [ start ] ; start ++ ; } if ( curr_sum == sum ) { System . out . println ( " Sum ▁ found ▁ between ▁ indexes ▁ " + ( start + i - 1 ) ) ; return 1 ; } if ( i < n ) { curr_sum = curr_sum + arr [ i ] ; } System . out . println ( " No ▁ subarray ▁ found " ) ; return 0 ; }
static void generateSquare ( int n ) { int magicSquare [ ] [ ] = new int [ n ] [ n ] ; int i , j , num ; for ( i = 0 , j = n - 1 ; num <= ( n * n ) ; i = n / 2 ; while ( num <= ( n * n ) ) { if ( i == - 1 && j == n ) { j = n - 2 ; i = 0 ; } else { if ( j == n ) { i = n - 1 ; continue ; } else { magicSquare [ int ( i ) ] [ int ( j ) ] = num ; num = num + 1 ; } j = j + 1 ; i = i - 1 ; } } System . out . println ( " Magic ▁ Squre ▁ for ▁ n ▁ = " + n ) ; for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < n ; j ++ ) { System . out . print ( ' % 2d ▁ ' + ( magicSquare [ i ] [ j ] ) ; if ( j == n - 1 ) System . out . print ( ) ; } }
static int countOnes ( int [ ] arr , int low , int high ) { if ( high >= low ) return 0 ; if ( low >= high ) { int mid = ( low + high ) / 2 ; if ( ( mid == high || arr [ mid + 1 ] == 0 ) && ( arr [ mid ] == 1 ) ) return mid + 1 ; if ( arr [ mid ] == 1 ) return countOnes ( arr , ( mid + 1 ) , high ) ; return countOnes ( arr , low , mid - 1 ) ; } return 0 ; }
static int ceilSearch ( int [ ] arr , int low , int high , int x ) { if ( x <= arr [ low ] ) return low ; if ( x > arr [ high ] ) return high ; int mid = ( low + high ) / 2 ; if ( arr [ mid ] == x ) return mid ; else if ( arr [ mid ] < x ) { if ( mid + 1 <= high && x <= arr [ mid + 1 ] ) return mid + 1 ; else return ceilSearch ( arr , mid + 1 , high , x ) ; } else if ( mid ] < x ) { if ( mid + 1 <= high && x <= arr [ mid + 1 ] ) return mid + 1 ; else return ceilSearch ( arr , mid + 1 , high , x ) ; } }
static String decToBin ( int n ) { if ( n == 0 ) return "0" ; String bin = " " ; while ( n > 0 ) { if ( n & 1 == 0 ) bin = '0' + bin ; else bin = '1' + bin ; n = n >> 1 ; } return bin ; }
static void printNos ( int n ) { if ( n > 0 ) System . out . print ( n - 1 ) ; System . out . println ( n + ' ▁ ' ) ; }
static int eulerian ( int n , int m ) { if ( m >= n || n == 0 ) return 0 ; if ( m == 0 ) return 1 ; return ( n - m ) * eulerian ( n - 1 , m - 1 ) + ( m + 1 ) * eulerian ( n - 1 , m ) ) ; }
static int areaSquare ( int side ) { int area = side * side ; return area ; }
static int spiralDiaSum ( int n ) { if ( n == 1 ) return 1 ; return 4 * n * n - 6 * n + 6 + spiralDiaSum ( n - 2 ) ; }
int countOccurrences ( int arr [ ] , int n , int x ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == x ) res ++ ; return res ; }
static int doublefactorial ( int n ) { int res = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( i == 0 || i == 1 ) return res ; else res *= i ; } return res ; }
public static int lcs ( int X [ ] , int Y [ ] , int m , int n ) { if ( m == 0 || n == 0 ) return 0 ; else if ( X [ m - 1 ] == Y [ n - 1 ] ) return 1 + lcs ( X , Y , m - 1 , n - 1 ) ; else return Math . max ( lcs ( X , Y , m , n - 1 ) , lcs ( X , Y , m - 1 , n ) ) ; }
static int offeringNumber ( int n , int templeHeight [ ] ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int left = 0 , right = 0 ; for ( int j = i - 1 ; j >= 0 ; j -- ) { if ( templeHeight [ j ] < templeHeight [ j + 1 ] ) { left ++ ; } else { break ; } } for ( int j = i + 1 ; j < n ; j ++ ) { if ( templeHeight [ j ] < templeHeight [ j - 1 ] ) { right ++ ; } else { break ; } } sum += Math . max ( right , left ) + 1 ; } return sum ; }
static String constructPalin ( String str , int l ) { char [ ] string = str . toCharArray ( ) ; int i = - 1 , j = l ; while ( i < j ) { if ( string [ i ] == string [ j ] && string [ i ] != ' * ' ) continue ; else if ( string [ i ] == string [ j ] && string [ i ] == ' * ' ) { string [ i ] = ' a ' ; string [ j ] = ' a ' ; continue ; } else if ( string [ i ] == string [ j ] && string [ i ] == ' * ' ) { string [ i ] = ' a ' ; string [ j ] = ' a ' ; continue ; } else if ( string [ i ] == ' * ' ) { string [ i ] = string [ j ] ; continue ; } } return " " ; }
static int countPairs ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] == arr [ j ] ) ans ++ ; } return ans ; }
static int evenFib ( int n ) { if ( n < 1 ) return n ; if ( n == 1 ) return 2 ; return ( 4 * evenFib ( n - 1 ) ) + evenFib ( n - 2 ) ; }
static int findSum ( int n ) { int sm = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = i ; j <= n ; j ++ ) sm = sm + i * j ; return sm ; }
static long binomialCoeffSum ( int n ) { return 1 << n ; }
static void printknapSack ( int W , int wt , int val [ ] , int n ) { int K [ ] [ ] = new int [ W + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { K [ i ] [ 0 ] = 0 ; } for ( int i = 0 ; i <= W ; i ++ ) { for ( int w = 0 ; w < n ; w ++ ) { if ( i == 0 || w == 0 ) K [ i ] [ w ] = 0 ; else K [ i ] [ w ] = Math . max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) ; else K [ i ] [ w ] = K [ i - 1 ] [ w ] ; } } int res = K [ n ] [ W ] ; for ( int i = 0 ; i >= n ; i -- ) { if ( res <= 0 ) break ; if ( res == K [ i - 1 ] [ w ] ) { continue ; } else { System . out . print ( wt [ i - 1 ] + " ▁ " ) ; res = res - val [ i - 1 ] ; w = w - wt [ i - 1 ] ; } } }
static int getTotalNumberOfSequences ( int m , int n ) { int T [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 || j == 0 ) T [ i ] [ j ] = 0 ; else if ( i < j ) T [ i ] [ j ] = 0 ; else if ( i < j ) { T [ i ] [ j ] = i ; } else if ( j == 1 ) T [ i ] [ j ] = i ; } } return T [ m ] [ n ] ; }
static int maxPrimeFactors ( int n ) { int maxPrime = - 1 ; while ( n % 2 == 0 ) maxPrime = 2 ; n >>= 1 ; for ( int i = 3 ; i <= Math . sqrt ( n ) ; i ++ ) { while ( n % i == 0 ) maxPrime = i ; n = n / i ; } if ( n > 2 ) maxPrime = n ; } return maxPrime ; }
static int remainderWith7 ( String num ) { int series [ ] = new int [ 6 ] ; int series_index = 0 ; int result = 0 ; for ( int i = ( num . length ( ) - 1 ) ; i >= 0 ; i -- ) { digit = num . charAt ( i ) - 48 ; result += digit * series [ series_index ] ; series_index = ( series_index + 1 ) % 6 ; result %= 7 ; } if ( result < 0 ) { result = ( result + 7 ) % 7 ; } return result ; }
static int getRemainder ( int num , int divisor ) { return num - divisor * ( num / divisor ) ; }
static int getSum ( int n ) { int sum = 0 ; while ( n != 0 ) sum = sum + n % 10 ; n = n / 10 ; return sum ; }
static void fill0X ( int m , int n ) { int i , k , l ; int r = m , c = n ; int a [ ] [ ] = new int [ m ] [ n ] ; int x = ' X ' ; for ( i = 0 ; i < m ; ++ i ) { a [ i ] [ l ] = x ; } k ++ ; for ( i = l ; i < n ; ++ i ) { a [ k ] [ i ] = x ; } n -- ; if ( k < m ) { for ( i = n - 1 ; i >= l ; -- i ) { a [ m - 1 ] [ i ] = x ; } m -- ; } if ( l < n ) { for ( i = m - 1 ; i >= k ; -- i ) { a [ i ] [ l ] = x ; } l ++ ; } x = ' X ' ; for ( i = 0 ; i < r ; ++ i ) { for ( j = 0 ; j < c ; ++ j ) System . out . print ( a [ i ] [ j ] + " ▁ " ) ; } System . out . println ( ) ; }
static double slope ( double x1 , double y1 , double x2 , double y2 ) { return ( float ) ( y2 - y1 ) / ( x2 - x1 ) ; }
static int countNegative ( int M [ ] [ ] , int n , int m ) { int count = 0 ; for ( int i = 0 , j = m - 1 ; j >= 0 && i < n ; i ++ ) { if ( M [ i ] [ j ] < 0 ) count += ( j + 1 ) ; else j -- ; } return count ; }
static int maxSumIS ( int arr [ ] , int n ) { int max = 0 ; int [ ] msis = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) msis [ i ] = arr [ i ] ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ i ] > arr [ j ] && msis [ i ] < msis [ j ] + arr [ i ] ) msis [ i ] = msis [ j ] + arr [ i ] ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( max < msis [ i ] ) max = msis [ i ] ; } return max ; }
static int maxLength ( String s , int n ) { int invalidOpenBraces = 0 , invalidCloseBraces = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == ' ( ' ) ) invalidOpenBraces ++ ; else if ( invalidOpenBraces == 0 ) invalidCloseBraces -- ; } return ( n - ( invalidOpenBraces + invalidCloseBraces ) ) ; }
public static void tower ( int n , int sourcePole , int destinationPole , int auxiliaryPole ) { if ( 0 == n ) return ; tower ( n - 1 , sourcePole , auxiliaryPole , destinationPole ) ; if ( n - 1 == destinationPole ) { return ; } tower ( n - 1 , auxiliaryPole , destinationPole , sourcePole ) ; System . out . println ( " Move ▁ the ▁ disk " + sourcePole + " to ▁ " + destinationPole ) ; }
static int findMaximumPieces ( int n ) { return 1 + n * ( n + 1 ) / 2 ; }
static int findMinInsertions ( String str , int l , int h ) { if ( l > h ) return Integer . MAX_VALUE ; if ( l == h ) return 0 ; if ( l == h - 1 ) return 1 ; if ( str . charAt ( l ) == str . charAt ( h ) ) else 1 ; if ( str . charAt ( l ) == str . charAt ( h ) ) return findMinInsertions ( str , l + 1 , h - 1 ) ; else return findMinInsertions ( str , l , h - 1 ) ; }
static int octalToDecimal ( int n ) { int num = n ; int dec_value = 0 ; int base = 1 ; int temp = num ; while ( temp > 0 ) { dec_value += ( char ) temp % 10 ; temp = temp / 10 ; base = base * 8 ; } return dec_value ; }
static void printSquares ( int n ) { int square = 0 ; int prev_x = 0 ; for ( int x = 0 ; x < n ; x ++ ) { square = ( square + x + prev_x ) ; System . out . print ( square + " ▁ " ) ; prev_x = x ; } }
static void sequence ( int n ) { int [ ] f = new int [ n + 1 ] ; System . out . print ( f [ 0 ] + " ▁ " ) ; System . out . print ( f [ 2 ] + " ▁ " ) ; for ( int i = 3 ; i <= n ; i ++ ) { f . push ( f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ] ) ; System . out . print ( f [ i ] + " ▁ " ) ; } }
static int maxSubsequenceSubstring ( char x [ ] , char y [ ] , int n , int m ) { int dp [ ] [ ] = new int [ MAX ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { dp [ i ] [ 0 ] = i ; } for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( x [ j - 1 ] == y [ i - 1 ] ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = dp [ i ] [ j - 1 ] ; } } int ans = 0 ; for ( int i = 1 ; i <= m ; i ++ ) ans = Math . max ( ans , dp [ i ] [ n ] ) ; return ans ; }
static int getMedian ( int arr1 [ ] , int arr2 [ ] , int n ) { int i = 0 , j = 0 ; int m1 = - 1 , m2 = - 1 ; int count = 0 ; while ( count < n + 1 ) { if ( i == n ) { m1 = m2 ; m2 = arr2 [ 0 ] ; break ; } else if ( j == n ) { m1 = m2 ; m2 = arr1 [ 0 ] ; break ; } else { m1 = m2 ; m2 = arr2 [ j ] ; j ++ ; } } return ( m1 + m2 ) / 2 ; }
static int countZeroes ( int mat [ ] [ ] ) { int N = mat . length ; int row = N - 1 ; int col = 0 ; int count = 0 ; while ( col < N ) { while ( mat [ row ] [ col ] ) { if ( row < 0 ) return count ; row -- ; } count = count + ( row + 1 ) ; col ++ ; } return count ; }
static int solution ( int a , int b , int n ) { int i ; for ( i = 0 ; i * a <= n ; i ++ ) { if ( ( n - ( i * a ) ) % b == 0 ) System . out . println ( " x ▁ = ▁ " + i + " , ▁ y ▁ = ▁ " + ( n - ( i * a ) ) / b ) ; return 0 ; }
static int Circumference ( int a ) { return 4 * a ; }
static int numberOfPaths ( int m , int n ) { int path = 1 ; for ( int i = n ; i <= ( m + n - 1 ) ; i ++ ) path *= i ; path /= ( i - n + 1 ) ; return path ; }
static void pointClip ( int XY [ ] [ ] , int n , int Xmin , int Ymin , int Xmax , int Ymax ) { System . out . println ( " Point ▁ inside ▁ the ▁ viewing ▁ pane : " ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( XY [ i ] [ 0 ] >= Xmin ) && ( XY [ i ] [ 0 ] <= Xmax ) ) System . out . print ( " [ " + XY [ i ] [ 0 ] + " , ▁ " + XY [ i ] [ 1 ] + " ] " ) ; } System . out . println ( " \n \n " ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( XY [ i ] [ 0 ] < Xmin ) || ( XY [ i ] [ 0 ] > Xmax ) ) System . out . print ( " [ " + XY [ i ] [ 0 ] + " , ▁ " + XY [ i ] [ 1 ] + " ] " ) ; if ( ( XY [ i ] [ 1 ] < Ymin ) || ( XY [ i ] [ 1 ] > Ymax ) ) System . out . print ( " [ " + XY [ i ] [ 0 ] + " , ▁ " + XY [ i ] [ 1 ] + " ] " ) ; } System . out . println ( " \n " ) ; }
static int pre_compute ( int a [ ] , int n , int index , int k ) { int dp [ ] [ ] = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > a [ 0 ] ) { dp [ 0 ] [ i ] = a [ i ] + a [ 0 ] ; } else { dp [ 0 ] [ i ] = a [ i ] ; } } for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( a [ j ] > a [ i ] && j > i ) { if ( dp [ i - 1 ] [ i ] + a [ j ] > dp [ i - 1 ] [ j ] ) { dp [ i ] [ j ] = dp [ i - 1 ] [ i ] + a [ j ] ; } else { dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; } } } return dp [ index ] [ k ] ; }
static void splitArr ( int arr [ ] , int n , int k ) { for ( int i = 0 ; i < k ; i ++ ) { int x = arr [ 0 ] ; for ( int j = 0 ; j < n - 1 ; j ++ ) arr [ j ] = arr [ j + 1 ] ; arr [ n - 1 ] = x ; } }
static int smallestSubWithSum ( int arr [ ] , int n , int x ) { int curr_sum = 0 ; int min_len = n + 1 ; int start = 0 , end = 0 ; while ( end < n ) { while ( curr_sum <= x && end < n ) { if ( curr_sum <= 0 && x > 0 ) { start = end ; curr_sum = 0 ; } curr_sum += arr [ end ] ; end ++ ; } while ( curr_sum > x && start < n ) { if ( end - start < min_len ) min_len = end - start ; curr_sum -= arr [ start ] ; start ++ ; } } return min_len ; }
static int winner ( int a [ ] , int n , int k ) { if ( k >= n - 1 ) return n ; int best = 0 ; int times = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > best ) { best = a [ i ] ; if ( i == true ) times ++ ; else times ++ ; if ( times >= k ) return best ; } return best ; }
static int countSolutions ( int n ) { int x = 0 , res = 0 ; int yCount = 0 ; while ( yCount * yCount < n ) yCount ++ ; while ( res != 0 ) res = res + yCount ; x = x + 1 ; while ( yCount != 0 && ( x * x + ( yCount - 1 ) * ( yCount - 1 ) >= n ) ) yCount -- ; return res ; }
static int maxProduct ( int arr [ ] , int n ) { if ( n < 3 ) return - 1 ; int max_product = Integer . MIN_VALUE ; for ( int i = 0 ; i <= n - 2 ; i ++ ) { for ( int j = i + 1 ; j <= n - 1 ; j ++ ) { for ( int k = j + 1 ; k <= n ; k ++ ) { max_product = Math . max ( max_product , arr [ i ] * arr [ j ] * arr [ k ] ) ; } } } return max_product ; }
static void solveWordWrap ( int arr [ ] , int n , int k ) { int dp [ ] = new int [ n ] ; int [ ] ans = new int [ n ] ; dp [ n - 1 ] = 0 ; ans [ n - 1 ] = n - 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { int currlen = - 1 ; for ( int j = i ; j < n ; j ++ ) { currlen += ( arr [ j ] + 1 ) ; if ( currlen > k ) break ; int cost = ( k - currlen ) * ( k - currlen ) + dp [ j + 1 ] ; if ( cost < dp [ i ] ) { dp [ i ] = cost ; ans [ i ] = j ; } } }
static int sumofFactors ( int n ) { if ( n % 2 != 0 ) return 0 ; int res = 1 ; for ( int i = 2 ; i <= Math . sqrt ( n ) ; i ++ ) { int count = 0 ; int curr_sum = 1 ; int curr_term = 1 ; for ( int k = 2 ; k <= Math . sqrt ( n ) ; k ++ ) { count ++ ; n = n / i ; if ( i == 2 && count == 1 ) { curr_sum = 0 ; curr_term = curr_term * i ; curr_sum = curr_sum + curr_term ; } res = res * curr_sum ; } if ( n >= 2 ) res = res * ( 1 + n ) ; } return res ; }
static int maxGameByWinner ( int N ) { int dp [ ] = new int [ N ] ; dp [ 0 ] = 1 ; dp [ 1 ] = 2 ; for ( int i = 1 ; i <= N ; i ++ ) { dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] ; } return ( i - 1 ) ; }
static int equilibrium ( int arr [ ] ) { int total_sum = arr . length ; int leftsum = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { total_sum -= num ; if ( leftsum == total_sum ) return i ; leftsum += num ; } return - 1 ; }
static double procal ( int n ) { return ( 3.0 * n ) / ( 4.0 * ( n * n ) - 1 ) ; }
static int greatest ( String s ) { int n = s . length ( ) ; int [ ] a = new int [ n ] ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) a [ i ] = s . charAt ( i ) - '0' ; sum += a [ i ] ; if ( a [ n - 1 ] % 2 ) { if ( a [ n - 2 ] % 2 != 0 || sum - a [ n - 1 ] % 3 != 0 ) System . out . println ( " - 1 " ) ; else { System . out . println ( n ) ; } } int re = sum % 3 ; int dell = - 1 ; int flag = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( ( a [ i ] ) % 3 == re ) { if ( a [ i + 1 ] > a [ i ] ) { dell = i ; flag = 1 ; break ; } else { dell = i ; } } if ( flag == 0 ) { if ( a [ n - 2 ] % 2 == 0 && re == a [ n - 1 ] % 3 ) dell = n - 1 ; } else { dell = n - 1 ; } } } return dell ; }
static boolean isChangeable ( int notes [ ] , int n ) { int fiveCount = 0 , tenCount = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( notes [ i ] == 5 ) fiveCount ++ ; else if ( notes [ i ] == 10 ) { if ( fiveCount > 0 && tenCount > 0 ) { fiveCount -- ; tenCount ++ ; } else { if ( fiveCount > 0 && tenCount > 0 ) { fiveCount -- ; tenCount -- ; } else { return 0 ; } } } return 1 ; }
static int maxSumWO3Consec ( int n ) { if ( sum [ n ] != - 1 ) return sum [ n ] ; if ( n == 0 ) sum [ n ] = 0 ; return sum [ n ] ; } if ( n == 1 ) sum [ n ] = arr [ 0 ] ; return sum [ n ] ; if ( n == 2 ) sum [ n ] = arr [ 1 ] + arr [ 0 ] ; if ( n == 3 ) sum [ n ] = arr [ 2 ] + arr [ n - 1 ] + maxSumWO3Consec ( n - 3 ) ; return sum [ n ] ; }
static int findMinZero ( int p ) { int first = 1 , second = 1 , number = 2 ; int next = 1 ; while ( next ) { next = ( first + second ) % p ; first = second ; second = next ; number = number + 1 ; } return number ; }
static void reorder ( ) { int oldTargetI , oldTargetE ; for ( int i = 0 ; i < n ; i ++ ) { while ( index [ i ] != i ) { oldTargetI = index [ index [ i ] ] ; oldTargetE = arr [ index [ i ] ] ; arr [ index [ i ] ] = arr [ i ] ; index [ i ] = oldTargetI ; arr [ i ] = oldTargetE ; } }
static int calculateSum ( int n ) { if ( n <= 0 ) return 0 ; int [ ] fibo = new int [ n + 1 ] ; fibo [ 1 ] = 1 ; int sm = fibo [ 0 ] + fibo [ 1 ] ; for ( int i = 2 ; i <= n ; i ++ ) fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ; sm = sm + fibo [ i ] ; return sm ; }
static int shortestPath ( int graph [ ] [ ] , int u , int v , int k ) { int V = 4 ; int INF = 999999999999 ; if ( k == 0 && u == v ) return 0 ; if ( k == 1 && graph [ u ] [ v ] != INF ) return graph [ u ] [ v ] ; if ( k <= 0 ) return INF ; int res = INF ; for ( int i = 0 ; i < V ; i ++ ) { if ( graph [ u ] [ i ] != INF && u != i && v != i ) { int rec_res = shortestPath ( graph , i , v , k - 1 ) ; if ( rec_res != INF ) res = Math . min ( res , graph [ u ] [ i ] + rec_res ) ; } } return res ; }
static int sumofsquare ( int n ) { int [ ] [ ] C = new int [ n + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) C [ i ] [ 0 ] = 1 ; for ( int j = 0 ; j <= n ; j ++ ) C [ 0 ] [ j ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= i ; j ++ ) { if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) ; } } int sum = 0 ; for ( int i = 0 ; i <= n ; i ++ ) sum += ( C [ n ] [ i ] * C [ n ] [ i ] ) ; return sum ; }
static void constructArr ( int arr [ ] , int pair [ ] , int n ) { arr [ 0 ] = ( pair [ 0 ] + pair [ 1 ] - pair [ n - 1 ] ) / 2 ; for ( int i = 1 ; i < n ; i ++ ) arr [ i ] = pair [ i - 1 ] - arr [ 0 ] ; }
static int findFrequency ( int arr [ ] , int n , int left , int right , int element ) { int count = 0 ; for ( int i = left - 1 ; i <= right ; i ++ ) if ( arr [ i ] == element ) count ++ ; return count ; }
static void parabola ( int a , int b , int c ) { System . out . println ( " Vertex : ▁ ( " + ( - b / ( 2 * a ) ) , " , ▁ " + ( ( 4 * a * c ) - ( b * b ) ) / ( 4 * a ) ) ; System . out . println ( " Focus : ▁ ( " + ( - b / ( 2 * a ) ) , " , ▁ " + ( ( 4 * a * c ) - ( b * b ) + 1 ) / ( 4 * a ) ) ; System . out . println ( " Directrix : ▁ y = ▁ " + ( c - ( ( b * b ) + 1 ) * 4 * a ) ; System . out . println ( " Directrix : ▁ y = ▁ " + c - ( ( b * b ) + 1 ) * 4 * a ) ; }
static int minproduct ( int a [ ] , int b [ ] , int n , int k ) { int diff = 0 ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int pro = a [ i ] * b [ i ] ; res += pro ; if ( pro < 0 && b [ i ] < 0 ) temp = ( a [ i ] + 2 * k ) * b [ i ] ; else if ( pro > 0 && a [ i ] < 0 ) temp = ( a [ i ] - 2 * k ) * b [ i ] ; else if ( pro > 0 && a [ i ] > 0 ) temp = ( a [ i ] + 2 * k ) * b [ i ] ; else if ( pro < 0 && a [ i ] < 0 ) temp = ( a [ i ] - 2 * k ) * b [ i ] ; else d = Math . abs ( pro - temp ) ; if ( d > diff ) diff = d ; } return res - diff ; }
static int pairsInSortedRotated ( int arr [ ] , int n , int x ) { int l , r , cnt ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > arr [ i + 1 ] ) break ; l = ( i + 1 ) % n ; r = i ; cnt = 0 ; while ( l != r ) { if ( arr [ l ] + arr [ r ] == x ) { cnt ++ ; if ( l == ( r - 1 + n ) % n ) { return cnt ; } l = ( l + 1 ) % n ; r = ( r - 1 + n ) % n ; } else if ( arr [ l ] + arr [ r ] < x ) l = ( l + 1 ) % n ; else r = ( n + r - 1 ) % n ; } } return cnt ; }
static int middleOfThree ( int a , int b , int c ) { int x = a - b ; int y = b - c ; int z = a - c ; if ( x * y > 0 ) return b ; else if ( x * z > 0 ) return a ; else return b ; }
static int maxSubArraySumRepeated ( int a [ ] , int n , int k ) { int max_so_far = Integer . MAX_VALUE ; int max_ending_here = 0 ; for ( int i = 0 ; i < n * k ; i ++ ) { max_ending_here = max_ending_here + a [ i % n ] ; if ( max_so_far < max_ending_here ) { max_so_far = max_ending_here ; } if ( max_ending_here < 0 ) { max_ending_here = 0 ; } } return max_so_far ; }
static int binomialCoeffSum ( int n ) { int [ ] [ ] C = new int [ n + 2 ] [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) C [ i ] [ 0 ] = 1 ; for ( int j = 0 ; j < n ; j ++ ) { if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } int sum = 0 ; for ( int i = 0 ; i <= n ; i ++ ) sum += C [ n ] [ i ] ; return sum ; }
static boolean isEven ( int n ) { return ( n % 2 == 0 ) ; }
static int binarySearch ( int [ ] arr , int low , int high , int key ) { if ( high < low ) return - 1 ; int mid = ( low + high ) / 2 ; if ( key == arr [ int ( mid ) ] ) return mid ; if ( key > arr [ int ( mid ) ] ) return binarySearch ( arr , ( mid + 1 ) , high , key ) ; return ( binarySearch ( arr , low , ( mid - 1 ) , key ) ) ; }
static void MAXMIN ( int arr [ ] [ ] , int n ) { int min = Integer . MAX_VALUE ; int MAX = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n / 2 ; j ++ ) { if ( arr [ i ] [ j ] > arr [ i ] [ n - j - 1 ] ) { if ( MIN > arr [ i ] [ n - j - 1 ] ) { MIN = arr [ i ] [ n - j - 1 ] ; if ( MAX < arr [ i ] [ j ] ) { MAX = arr [ i ] [ j ] ; } } else { if ( MIN > arr [ i ] [ j ] ) { MIN = arr [ i ] [ j ] ; if ( MAX < arr [ i ] [ n - j - 1 ] ) { MAX = arr [ i ] [ n - j - 1 ] ; } } } System . out . println ( " MAXimum ▁ = ▁ " + MAX + " , ▁ MINimum ▁ = ▁ " + MIN ) ; }
static int countPaths ( int n , int m ) { if ( n == 0 || m == 0 ) return 1 ; return countPaths ( n - 1 , m ) + countPaths ( n , m - 1 ) ; }
static int countFriendsPairings ( int n ) { int dp [ ] = new int [ 100 ] ; if ( dp [ n ] != - 1 ) return dp [ n ] ; if ( n > 2 ) { dp [ n ] = ( countFriendsPairings ( n - 1 ) + ( n - 1 ) * countFriendsPairings ( n - 2 ) ) ; return dp [ n ] ; } else { dp [ n ] = n ; } }
static int countRect ( int n ) { int ans = 0 ; for ( int length = 1 ; length <= Math . sqrt ( n ) ; length ++ ) { int height = length ; while ( ans * length <= n ) ans ++ ; height ++ ; } return ans ; }
static int factorial ( int n ) { return n == 1 || n == 0 ) ? 1 : n * factorial ( n - 1 ) ; }
static float correlationCoefficient ( int X [ ] , int Y [ ] , int n ) { int sum_X = 0 , sum_Y = 0 , sum_XY = 0 ; int squareSum_X = 0 , squareSum_Y = 0 ; int i ; for ( i = 0 ; i < n ; i ++ ) { sum_X = sum_X + X [ i ] ; sum_Y = sum_Y + Y [ i ] ; sum_XY = sum_XY + X [ i ] * Y [ i ] ; squareSum_X = squareSum_X + X [ i ] * X [ i ] ; squareSum_Y = squareSum_Y + Y [ i ] * Y [ i ] ; i ++ ; } return corr ; }
static int floorSqrt ( int x ) { if ( x == 0 || x == 1 ) return x ; int i = 1 , result = 1 ; while ( result <= x ) i ++ ; result = i * i ; return i - 1 ; }
static void printMat ( int degseq [ ] [ ] , int n ) { int [ ] [ ] mat = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( degseq [ i ] > 0 && degseq [ j ] > 0 ) { degseq [ i ] -- ; degseq [ j ] -- ; mat [ i ] [ j ] = 1 ; mat [ j ] [ i ] = 1 ; } } System . out . print ( " ▁ ▁ ▁ " ) ; for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( " ▁ " + " ( " + i + " ) " ) ; for ( int j = 0 ; j < n ; j ++ ) { System . out . print ( " ▁ ▁ ▁ ▁ " + mat [ i ] [ j ] + " ▁ " ) ; } System . out . println ( ) ; } }
static int minTime ( int arr [ ] , int n , int m ) { int t = 0 ; while ( 1 ) { int items = 0 ; for ( int i = 0 ; i < n ; i ++ ) items += ( t / arr [ i ] ) ; if ( items >= m ) return t ; } return Integer . MAX_VALUE ; }
static int maxSumBitonicSubArr ( int arr [ ] , int n ) { int [ ] msis = new int [ n ] ; int [ ] msds = new int [ n ] ; int max_sum = 0 ; msis [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > arr [ i - 1 ] ) msis [ i ] = msis [ i - 1 ] + arr [ i ] ; else msis [ i ] = arr [ i ] ; } msds [ n - 1 ] = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] > arr [ i + 1 ] ) msds [ i ] = msds [ i + 1 ] + arr [ i ] ; else msds [ i ] = arr [ i ] ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( max_sum < ( msis [ i ] + msds [ i ] - arr [ i ] ) ) max_sum = ( msis [ i ] + msds [ i ] - arr [ i ] ) ; } return max_sum ; }
static int findMinNumber ( int n ) { int count = 0 ; int ans = 1 ; while ( n % 2 == 0 ) count ++ ; n /= 2 ; if ( count % 2 != 0 ) ans *= 2 ; for ( int i = 3 ; i <= ( int ) ( Math . sqrt ( n ) ) + 1 ; i = 2 ) { count = 0 ; while ( n % i == 0 ) count ++ ; n /= i ; if ( count % 2 is not 0 ) ans *= i ; } if ( n > 2 ) ans *= n ; } return ans ; }
static int rangeGCD ( int n , int m ) { return n if ( n == m ) return 1 ; }
static int assignValue ( int a , int b , int x ) { int arr [ ] = new int [ 2 ] ; return arr [ x ] ; }
static boolean isTriangular ( int num ) { if ( num < 0 ) return false ; int sum = 0 , n = 1 ; while ( sum <= num ) sum = sum + n ; if ( sum == num ) return true ; return false ; }
static int interpolationSearch ( int arr [ ] , int n , int x ) { int lo = 0 , hi = ( n - 1 ) ; while ( lo <= hi && x >= arr [ lo ] && x <= arr [ hi ] ) { if ( lo == hi ) if ( arr [ lo ] == x ) return lo ; return - 1 ; } int pos = lo + ( ( float ) hi - lo ) / ( arr [ hi ] - arr [ lo ] ) ) * ( x - arr [ lo ] ) ) ; else hi = pos - 1 ; return - 1 ; }
static void minSpacePreferLarge ( int w , int m , int n ) { int num_m = 0 ; int num_n = 0 ; int rem = w ; int p = 0 , q = 0 , r = 0 ; while ( w >= n ) { p = w / m ; r = w % m ; if ( r <= rem ) { num_m = p ; num_n = q ; rem = r ; } q ++ ; w -= n ; } System . out . println ( " ▁ " + num_n + " ▁ " + rem ) ; }
static int knapSack ( int W , int wt , int val [ ] , int n ) { int K [ ] [ ] = new int [ W + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= W ; i ++ ) { for ( int w = 0 ; w < n ; w ++ ) { if ( i == 0 || w == 0 ) K [ i ] [ w ] = 0 ; else if ( wt [ i - 1 ] <= w ) K [ i ] [ w ] = Math . max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) ; else K [ i ] [ w ] = K [ i - 1 ] [ w ] ; } } return K [ n ] [ W ] ; }
static int factorial ( int n ) { return n == 1 || n == 0 ) ? 1 : n * factorial ( n - 1 ) ; }
static int findgroups ( int arr [ ] , int n ) { int c [ ] = new int [ 3 ] ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { c [ arr [ i ] % 3 ] ++ ; res += ( c [ 0 ] * ( c [ 0 ] - 1 ) ) >> 1 ; res += ( c [ 1 ] * ( c [ 1 ] - 2 ) ) / 6 ; res += ( c [ 2 ] * ( c [ 2 ] - 1 ) * ( c [ 2 ] - 2 ) ) / 6 ; res += ( c [ 0 ] * ( c [ 2 ] - 1 ) * ( c [ 2 ] - 2 ) ) / 6 ; res += ( c [ 0 ] * ( c [ 0 ] - 1 ) * ( c [ 0 ] - 2 ) ) / 6 ; res += ( c [ 1 ] * ( c [ 1 ] - 2 ) ) / 6 ; res += ( c [ 2 ] * ( c [ 2 ] - 1 ) * ( c [ 2 ] - 2 ) ) / 6 ; res += ( c [ 0 ] * c [ 1 ] * c [ 2 ] ) ; return res ; }
static int findMaxValue ( int mat [ ] [ ] ) { int maxValue = Integer . MAX_VALUE ; int maxArr [ ] [ ] = new int [ N ] [ N ] ; int maxv = mat [ N - 1 ] [ N - 1 ] ; for ( int i = 0 ; i < N - 2 ; i ++ ) { for ( int j = N - 2 ; j >= 0 ; j -- ) { if ( mat [ N - 1 ] [ j ] > maxv ) { maxv = mat [ N - 1 ] [ j ] ; } maxArr [ N - 1 ] [ j ] = maxv ; } maxv = mat [ N - 1 ] [ N - 1 ] ; for ( int i = N - 2 ; i >= 0 ; i -- ) { for ( int j = N - 2 ; j >= 0 ; j -- ) { if ( maxArr [ i ] [ j ] > maxv ) { maxv = mat [ i ] [ j ] ; } maxArr [ i ] [ j ] = max ( maxArr [ i ] [ j + 1 ] - mat [ i ] [ j ] ) ; } maxArr [ i ] [ N - 1 ] = maxv ; } } return maxValue ; }
static int kPrimeFactor ( int n , int k ) { int i ; while ( n % 2 == 0 ) { k = k - 1 ; n = n / 2 ; if ( k == 0 ) return 2 ; } for ( i = 3 ; i <= Math . sqrt ( n ) ; i = i + 2 ) { while ( n % i == 0 ) { if ( k == 1 ) return i ; n = n / i ; } if ( n > 2 && k == 1 ) return n ; } return - 1 ; }
static void SieveOfEratosthenes ( int n , boolean [ ] isPrime ) { isPrime [ 0 ] = isPrime [ 1 ] = false ; for ( int i = 2 ; i <= n ; i ++ ) { isPrime [ i ] = true ; } for ( int p = 2 ; p <= n ; p ++ ) { if ( p * p <= n && isPrime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i ++ ) { isPrime [ i ] = false ; p ++ ; } } }
static int findFirstMissing ( int [ ] array , int start , int end ) { if ( start > end ) return end + 1 ; if ( start != array [ end ] ) return start ; int mid = ( start + end ) / 2 ; if ( array [ mid ] == mid ) return findFirstMissing ( array , mid + 1 , end ) ; return findFirstMissing ( array , start , mid ) ; }
static int factorial ( int n ) { return n == 1 || n == 0 ) ? 1 : n * factorial ( n - 1 ) ; }
static int insertSorted ( int arr [ ] , int n , int key , int capacity ) { if ( n >= capacity ) return n ; for ( int i = n - 1 ; i >= 0 && arr [ i ] > key ; i -- ) arr [ i + 1 ] = arr [ i ] ; arr [ i + 1 ] = key ; return ( n + 1 ) ; }
static void add ( int A [ ] [ ] , int B [ ] [ ] , int C [ ] [ ] ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { C [ i ] [ j ] = A [ i ] [ j ] + B [ i ] [ j ] ; } } }
static int eggDrop ( int n , int k ) { int eggFloor [ ] [ ] = new int [ k + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= k ; i ++ ) { eggFloor [ i ] [ 0 ] = 0 ; } for ( int j = 1 ; j <= k ; j ++ ) { eggFloor [ 1 ] [ j ] = j ; } for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 2 ; j <= k ; j ++ ) { int res = 1 + Math . max ( eggFloor [ i - 1 ] [ x - 1 ] , eggFloor [ i ] [ j - x ] ) ; if ( res < eggFloor [ i ] [ j ] ) { eggFloor [ i ] [ j ] = res ; } } } return eggFloor [ n ] [ k ] ; }
static int minInsertionStepToSortArray ( int arr [ ] , int N ) { int lis [ ] = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) lis [ i ] = 1 ; for ( int i = 1 ; i < N ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ i ] >= arr [ j ] && lis [ i ] < lis [ j ] + 1 ) { lis [ i ] = lis [ j ] + 1 ; } } int max = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( max < lis [ i ] ) max = lis [ i ] ; } return ( N - max ) ; }
static int exactPrimeFactorCount ( int n ) { int count = 0 ; if ( n % 2 == 0 ) count = count + 1 ; while ( n % 2 == 0 ) n = n / 2 ; int i = 3 ; while ( i <= Math . sqrt ( n ) ) { if ( n % i == 0 ) count = count + 1 ; while ( n % i == 0 ) n = n / i ; } i ++ ; if ( n > 2 ) count = count + 1 ; } return count ; }
static int findMinAvgSubarray ( int arr [ ] , int n , int k ) { if ( n < k ) return 0 ; int res_index = 0 ; int curr_sum = 0 ; for ( int i = 0 ; i < k ; i ++ ) { curr_sum += arr [ i ] ; } int min_sum = curr_sum ; for ( int i = 0 ; i < n ; i ++ ) { curr_sum += arr [ i ] - arr [ i - k ] ; if ( curr_sum < min_sum ) { min_sum = curr_sum ; res_index = ( i - k + 1 ) ; } } System . out . println ( " Subarray ▁ between ▁ [ " + res_index + " , ▁ " + ( res_index + k - 1 ) + " ] ▁ has ▁ minimum ▁ average " ) ; return res_index ; }
static int countwalks ( int graph [ ] [ ] , int u , int v , int k ) { if ( k == 0 && u == v ) return 1 ; if ( k == 1 && graph [ u ] [ v ] ) return 1 ; if ( k <= 0 ) return 0 ; for ( int i = 0 ; i < V ; i ++ ) { if ( graph [ u ] [ i ] == 1 ) count += countwalks ( graph , i , v , k - 1 ) ; } return count ; }
static void print_sequence ( int n , int k ) { int b = n / ( k * ( k + 1 ) / 2 ) ; if ( b == 0 ) System . out . println ( " - 1 " ) ; else { int r = 1 ; int x = 1 ; while ( x ** 2 <= n ) { if ( n % x != 0 ) continue ; if ( x <= b && x > r ) { r = x ; } else if ( n / x <= b && n / x > r ) { r = n / x ; x = x + 1 ; } } int i = 1 ; while ( i < k ) System . out . print ( r * i + " ▁ " ) ; i ++ ; } int last_term = n - ( r * ( k * ( k - 1 ) / 2 ) ) ; System . out . println ( last_term ) ; }
static int findS ( int s ) { int _sum = 0 ; int n = 1 ; while ( _sum < s ) { _sum += n * n * n ; n ++ ; } if ( _sum == s ) return n ; return - 1 ; }
static void printFun ( int test ) { if ( test < 1 ) System . out . print ( test + " ▁ " ) ; else System . out . print ( test - 1 + " ▁ " ) ; return ; }
static void shiftMatrixByK ( int mat [ ] [ ] , int k ) { if ( k > N ) System . out . println ( " shifting ▁ is ▁ " + " ▁ not ▁ possible " ) ; return ; } int j = 0 ; while ( j < N ) { for ( int i = 0 ; i < k ; i ++ ) { System . out . print ( " { } ▁ " . format ( mat [ j ] [ i ] ) ) ; } for ( int i = 0 ; i < k ; i ++ ) { System . out . print ( " { } ▁ " + mat [ j ] [ i ] ) ; } System . out . println ( ) ; }
boolean findPair ( int arr [ ] , int n ) { boolean found = false ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { for ( int k = 0 ; k < n ; k ++ ) { if ( arr [ i ] + arr [ j ] == arr [ k ] ) { System . out . println ( arr [ i ] + arr [ j ] ) ; found = true ; } } } if ( found == false ) System . out . println ( " Not ▁ exist " ) ; } return found ; }
static boolean squareRootExists ( int n , int p ) { n = n % p ; for ( int x = 2 ; x <= p ; x ++ ) if ( ( x * x ) % p == n ) return true ; return false ; }
static int count ( int n , int x ) { int cnt = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( x / i <= n && x % i == 0 ) cnt ++ ; } return cnt ; }
static int maxSubArraySum ( int a [ ] , int size ) { int max_so_far = Integer . MAX_VALUE ; int max_ending_here = 0 ; int start = 0 , end = 0 , s = 0 ; for ( int i = 0 ; i < size ; i ++ ) { max_ending_here += a [ i ] ; if ( max_so_far < max_ending_here ) { max_so_far = max_ending_here ; start = s ; end = i ; } if ( max_ending_here < 0 ) { max_ending_here = 0 ; s = i + 1 ; } } return ( end - start + 1 ) ; }
static int countInRange ( int arr [ ] , int n , int x , int y ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] >= x && arr [ i ] <= y ) count ++ ; } return count ; }
static int countPairsWithDiffK ( int arr [ ] , int n , int k ) { int count = 0 ; Arrays . sort ( arr ) ; int l = 0 , r = 0 ; while ( r < n ) { if ( arr [ r ] - arr [ l ] == k ) count ++ ; l ++ ; r ++ ; } else if ( arr [ r ] - arr [ l ] > k ) r ++ ; else if ( arr [ r ] - arr [ l ] > k ) l ++ ; else r ++ ; } return count ; }
static int knapSack ( int W , int wt [ ] , int val [ ] , int n ) { if ( n == 0 || W == 0 ) return 0 ; if ( wt [ n - 1 ] > W ) return knapSack ( W , wt , val , n - 1 ) ; else return Math . max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 ] , wt , val , n - 1 ) , knapSack ( W , wt , val , n - 1 ) ) ; }
static int countNonEmptySubstr ( String str ) { int n = str . length ( ) ; return n * ( n + 1 ) / 2 ; }
static int countDigits ( int a , int b ) { int count = 0 ; double p = Math . abs ( a * b ) ; if ( p == 0 ) return 1 ; while ( p > 0 ) count ++ ; p = p / 10 ; return count ; }
static int maxProfit ( int price [ ] , int n ) { int [ ] profit = new int [ n ] ; int max_price = price [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( price [ i ] > max_price ) max_price = price [ i ] ; profit [ i ] = Math . max ( profit [ i + 1 ] , max_price - price [ i ] ) ; } int min_price = price [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( price [ i ] < min_price ) { min_price = price [ i ] ; } profit [ i ] = Math . max ( profit [ i - 1 ] , profit [ i ] + ( price [ i ] - min_price ) ) ; } int result = profit [ n - 1 ] ; return result ; }
static int countDer ( int n ) { int [ ] der = new int [ n + 1 ] ; der [ 0 ] = 1 ; der [ 1 ] = 0 ; der [ 2 ] = 1 ; for ( int i = 3 ; i <= n ; i ++ ) der [ i ] = ( i - 1 ) * ( der [ i - 1 ] + der [ i - 2 ] ) ; return der [ n ] ; }
static int find_Area ( int r ) { return 2 * r * r ; }
static int isLucky ( int n ) { int [ ] ar = new int [ 10 ] ; while ( n > 0 ) { digit = ( int ) ( n % 10 ) ; if ( ar [ digit ] ) return 0 ; ar [ digit ] = 1 ; n = n / 10 ; } return 1 ; }
static void countWaysToJump ( int arr [ ] , int n ) { int count_jump [ ] = new int [ n ] ; for ( int i = 0 ; i < n - 2 ; i ++ ) { if ( arr [ i ] >= n - i - 1 ) count_jump [ i ] ++ ; } int j ; for ( j = i + 1 ; j < n - 1 && j <= arr [ i ] + i ; j ++ ) { if ( count_jump [ j ] != - 1 ) count_jump [ i ] += count_jump [ j ] ; } if ( count_jump [ i ] == 0 ) count_jump [ i ] = - 1 ; } }
static void zodiac_sign ( int day , int month ) { if ( month == ' december ' ) { System . out . println ( " Sagittarius " + ( day < 22 ) ) ; } else if ( month == ' january ' ) { System . out . println ( " Capricorn " + ( day < 20 ) ) ; } else if ( month == ' february ' ) { System . out . println ( ' Aquarius ' + ( day < 21 ) ) ; } else if ( month == ' march ' ) { System . out . println ( " Pisces " + ( day < 20 ) else ' aries ' ; } else if ( month == ' march ' ) { System . out . println ( " Taurus " + ( day < 21 ) ) ; } else if ( month == ' june ' ) { System . out . println ( " Gemini " + ( day < 23 ) ) ; } else if ( month == ' august ' ) { astro_sign = ' Leo ' + ( day < 23 ) ; } else if ( month == ' october ' ) { astro_sign = ' Libra ' + ( day < 23 ) ; } else { astro_sign = ' Scorpio ' + ( day < 22 ) ; } } System . out . println ( astro_sign ) ; }
static boolean isSymmetric ( int mat [ ] [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) { return false ; } } } return true ; }
static boolean isRectangle ( int m [ ] [ ] ) { int rows = m . length ; if ( rows == 0 ) return false ; int columns = m [ 0 ] . length ; for ( int y1 = 0 ; y1 < rows ; y1 ++ ) { for ( int x1 = 0 ; x1 < columns ; x1 ++ ) { if ( m [ y1 ] [ x1 ] == 1 ) { for ( int y2 = y1 + 1 ; y2 < rows ; y2 ++ ) { for ( int x2 = x1 + 1 ; x2 < columns ; x2 ++ ) { if ( m [ y1 ] [ x2 ] == 1 && m [ y2 ] [ x1 ] == 1 && m [ y2 ] [ x2 ] == 1 ) return true ; } } } } return false ; }
static boolean isDivBy9 ( int n ) { if ( n == 0 || n == 9 ) return true ; if ( n < 9 ) return false ; return isDivBy9 ( ( int ) ( n >> 3 ) - ( int ) ( n & 7 ) ) ; }
static int knapSack ( int W , int wt [ ] , int val [ ] , int n ) { if ( n == 0 || W == 0 ) return 0 ; if ( wt [ n - 1 ] > W ) return knapSack ( W , wt , val , n - 1 ) ; else return Math . max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 ] , wt , val , n - 1 ) , knapSack ( W , wt , val , n - 1 ) ) ; }
static boolean oppositeSigns ( int x , int y ) { return ( ( x ^ y ) < 0 ) ; }
static boolean arraySortedOrNot ( int arr [ ] , int n ) { if ( n == 0 || n == 1 ) return true ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i - 1 ] > arr [ i ] ) return false ; return true ; }
static boolean isOverflow ( int a , int b ) { if ( a == 0 || b == 0 ) return false ; int result = a * b ; if ( result >= 9223372036854775807 || result <= - 9223372036854775808 ) result = 0 ; if ( a == ( result / b ) ) System . out . println ( result / b ) ; else return true ; }
static int countRotations ( String n ) { int l = n . length ( ) ; if ( l == 1 ) return 1 ; int oneDigit = ( int ) ( n . charAt ( 0 ) ) ; if ( oneDigit % 4 == 0 ) return 1 ; int count = 0 ; for ( int i = 0 ; i < l - 1 ; i ++ ) { int twoDigit = ( int ) ( n . charAt ( i ) ) * 10 + ( int ) ( n . charAt ( i + 1 ) ) ; if ( twoDigit % 4 == 0 ) count ++ ; } int twoDigit = ( int ) ( n . charAt ( l - 1 ) ) * 10 + ( int ) ( n . charAt ( 0 ) ) ; if ( twoDigit % 4 == 0 ) count = count + 1 ; } return count ; }
static void findCombinations ( String str , int index , String out ) { if ( index == str . length ( ) ) System . out . println ( out ) ; for ( int i = 0 ; i < index ; i ++ ) { findCombinations ( str , i + 1 , out + " ( " + str . charAt ( index ) + " ) " ) ; } }
static int search ( int arr [ ] , int n , int x ) { int i ; for ( i = 0 ; i <= n - 1 ; i ++ ) if ( arr [ i ] == x ) return i ; return - 1 ; }
static int maxSum ( int stack1 [ ] , int stack2 [ ] , int stack3 [ ] , int n1 , int n2 , int n3 ) { int sum1 = 0 , sum2 = 0 , sum3 = 0 ; for ( int i = 0 ; i < n1 ; i ++ ) sum1 += stack1 [ i ] ; for ( int i = 0 ; i < n2 ; i ++ ) sum2 += stack2 [ i ] ; for ( int i = 0 ; i < n3 ; i ++ ) { sum3 += stack3 [ i ] ; } int top1 , top2 , top3 ; for ( int i = 0 ; i < n1 ; i ++ ) { if ( sum1 == sum2 && sum2 == sum3 ) return sum1 ; if ( sum1 == sum2 && sum2 == sum3 ) return sum1 ; if ( sum1 >= sum2 && sum1 >= sum3 ) sum2 -= stack2 [ top2 ] ; top2 = top2 + 1 ; else if ( sum3 >= sum2 && sum3 >= sum1 ) sum3 -= stack3 [ top3 ] ; top3 = top3 + 1 ; } } return 0 ; }
static int firstFactorialDivisibleNumber ( int x ) { int i = 1 ; int fact = 1 ; for ( i = 1 ; i <= x ; i ++ ) { fact = fact * i ; if ( fact % x == 0 ) break ; } return i ; }
static void sortit ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = i + 1 ; }
static void printMaxSum ( int arr [ ] , int n ) { int dp [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] = arr [ i ] ; int maxi = 0 ; for ( int j = 1 ; j <= Math . pow ( i + 1 , 2 ) ; j ++ ) { if ( ( i + 1 ) % j == 0 && ( i + 1 ) != j ) { if ( dp [ j - 1 ] > maxi ) { maxi = dp [ j - 1 ] ; } if ( dp [ ( i + 1 ) / j - 1 ] > maxi && j != 1 ) { maxi = dp [ ( i + 1 ) / j - 1 ] ; } } } for ( int i = 0 ; i < n ; i ++ ) System . out . print ( dp [ i ] + ' ▁ ' ) ; }
static void exponential ( int n , double x ) { double sum = 1.0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) sum = 1 + x * sum / i ; System . out . println ( " e ^ x ▁ = ▁ " + sum ) ; }
static int maxProd ( int n ) { if ( n == 2 || n == 3 ) return ( n - 1 ) ; int res = 1 ; while ( n > 4 ) n -= 3 ; res *= 3 ; return ( n * res ) ; }
static int countRotations ( int [ ] arr , int low , int high ) { if ( high < low ) return 0 ; if ( high == low ) return low ; int mid = ( low + high ) / 2 ; if ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) return ( mid + 1 ) ; if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) return mid ; if ( arr [ high ] > arr [ mid ] ) return countRotations ( arr , low , mid - 1 ) ; return countRotations ( arr , mid + 1 , high ) ; }
static int findSum ( int n ) { int ans = 0 ; int temp = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( temp < n ) temp = i - 1 ; int num = 1 ; while ( temp < n ) { if ( temp + i <= n ) ans += ( n - temp ) * num ; else temp += i ; num ++ ; } } return ans ; }
static int divSum ( int n ) { int result = 0 ; for ( int i = 2 ; i <= ( int ) Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) result = result + i ; else result = result + ( i + n / i ) ; } } return ( result + n + 1 ) ; }
static void rotateMatrix ( int mat [ ] [ ] ) { int i = N - 1 ; while ( i >= 0 ) { int j = N - 1 ; while ( j >= 0 ) { System . out . print ( mat [ i ] [ j ] + " ▁ " ) ; j = j - 1 ; } System . out . println ( ) ; i = i - 1 ; } }
static void printSpiral ( int [ ] [ ] mat , int r , int c ) { int i , a = 0 , b = 2 ; int low_row = 0 ; int low_column = 0 ; if ( 0 > a ) a = 0 ; int high_row = r - 1 ; int high_column = c - 1 ; while ( ( low_row > 0 - r && low_column > 0 - c ) ) { i = low_column + 1 ; while ( i <= high_row && i < r && high_column < c ) { System . out . print ( mat [ i ] [ high_column ] + " ▁ " ) ; i ++ ; } low_row -- ; while ( ( low_row > 0 - r && low_column > 0 - c ) ) { System . out . print ( mat [ low_row ] [ i ] + " ▁ " ) ; i ++ ; } high_column ++ ; i = high_column - 2 ; while ( i > low_row && i >= 0 && low_column >= 0 ) System . out . print ( mat [ i ] [ low_column ] + " ▁ " ) ; i -- ; } low_column -- ; } System . out . println ( ) ; }
static int countSeq ( int n ) { int nCr = 1 ; int res = 1 ; for ( int r = 1 ; r <= n ; r ++ ) nCr = ( nCr * ( n + 1 - r ) ) / r ; res += nCr * nCr ; return res ; }
static int sumofoddFactors ( int n ) { int res = 1 ; while ( n % 2 == 0 ) n = n / 2 ; for ( int i = 3 ; i <= Math . sqrt ( n ) ; i ++ ) { int count = 0 ; int curr_sum = 1 ; int curr_term = 1 ; while ( n % i == 0 ) count ++ ; n = n / i ; curr_term *= i ; curr_sum += curr_term ; } res *= curr_sum ; if ( n >= 2 ) res *= ( 1 + n ) ; } return res ; }
public static int search ( int [ ] arr , int l , int h , int key ) { if ( l > h ) return - 1 ; int mid = ( l + h ) / 2 ; if ( arr [ mid ] == key ) return mid ; if ( arr [ l ] <= arr [ mid ] ) { if ( key >= arr [ l ] && key <= arr [ mid ] ) search ( arr , l , mid - 1 , key ) ; return search ( arr , mid + 1 , h , key ) ; } if ( key >= arr [ mid ] && key <= arr [ h ] ) search ( a , mid + 1 , h , key ) ; return search ( arr , l , mid - 1 , key ) ; }
static int exponentiation ( int bas , int exp ) { if ( exp == 0 ) return 1 ; if ( exp == 1 ) return bas % N ; int t = exponentiation ( bas , int . MIN_VALUE ) ; if ( exp % 2 == 0 ) return t ; else return ( ( bas % N ) * t ) % N ; }
static int longOddEvenIncSeq ( int arr [ ] , int n ) { int lioes [ ] = new int [ n ] ; int maxLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { lioes . add ( 1 ) ; } for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ i ] > arr [ j ] && ( arr [ i ] + arr [ j ] ) % 2 != 0 && lioes [ i ] < lioes [ j ] + 1 ) lioes [ i ] = lioes [ j ] + 1 ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( maxLen < lioes [ i ] ) maxLen = lioes [ i ] ; } } return maxLen ; }
static int addOne ( int x ) { return ( int ) ( Math . add ( x , 1 ) ) ; }
static int binarySearch ( int [ ] arr , int l , int r , int x ) { if ( r >= l ) return - 1 ; int mid = ( l + r ) / 2 ; if ( arr [ mid ] == x ) return mid ; if ( mid > l && arr [ mid - 1 ] == x ) return ( mid - 1 ) ; if ( mid < r && arr [ mid + 1 ] == x ) return ( mid + 1 ) ; if ( arr [ mid ] > x ) return binarySearch ( arr , l , mid - 2 , x ) ; if ( arr [ mid ] > x ) return binarySearch ( arr , l , mid + 2 , x ) ; return - 1 ; }
static void bresenham ( int x1 , int y1 , int x2 , int y2 ) { int m_new = 2 * ( y2 - y1 ) ; int slope_error_new = m_new - ( x2 - x1 ) ; int y = y1 ; for ( int x = x1 ; x <= x2 ; x ++ ) { System . out . print ( " ( " + x + " , " + y + " ) \n " ) ; slope_error_new = slope_error_new + m_new ; if ( slope_error_new >= 0 ) y ++ ; slope_error_new = slope_error_new - 2 * ( x2 - x1 ) ; } }
static int findMinX ( int num [ ] , int rem [ ] , int k ) { int x = 1 ; while ( true ) { int j ; for ( j = 0 ; j < k ; j ++ ) if ( x % num [ j ] != rem [ j ] ) break ; if ( j == k ) return x ; x ++ ; } return 1 ; }
boolean find3Numbers ( int A [ ] , int arr_size , int sum ) { int i , j , k ; for ( i = 0 ; i < arr_size - 2 ; i ++ ) { for ( j = i + 1 ; j < arr_size - 1 ; j ++ ) { for ( k = j + 1 ; k < arr_size ; k ++ ) { if ( A [ i ] + A [ j ] + A [ k ] == sum ) { System . out . print ( " Triplet ▁ is ▁ " + A [ i ] + " , ▁ " + A [ j ] + " , ▁ " + A [ k ] ) ; return true ; } } } return false ; }
public static double numberOfSticks ( int x ) { return ( 3 * x * ( x + 1 ) ) / 2 ; }
static boolean isDivisibleBy7 ( int num ) { if ( num < 0 ) return isDivisibleBy7 ( - num ) ; if ( num == 0 || num == 7 ) return true ; if ( num < 10 ) return false ; return isDivisibleBy7 ( num / 10 - 2 * ( num - num / 10 * 10 ) ) ; }
static int findSDSFunc ( int n ) { int [ ] DP = new int [ n + 1 ] ; DP [ 0 ] = 0 ; DP [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { if ( ( i % 2 ) == 0 ) DP [ i ] = DP [ int ( i / 2 ) ] ; else DP [ i ] = DP [ int ( i - 1 ) / 2 ] + DP [ int ( i + 1 ) / 2 ] ; } return DP [ n ] ; }
static int recSearch ( int [ ] arr , int l , int r , int x ) { if ( r < l ) return - 1 ; if ( arr [ l ] == x ) return l ; if ( arr [ r ] == x ) return r ; return recSearch ( arr , l + 1 , r - 1 , x ) ; }
static boolean isPossible ( String str , int n ) { int l = str . length ( ) ; if ( l >= n ) return true ; return false ; }
static void center ( int x1 , int x2 , int y1 , int y2 ) { System . out . print ( ( x1 + x2 ) / 2 ) ; System . out . println ( ( y1 + y2 ) / 2 ) ; }
static int minInitialPoints ( int points [ ] [ ] ) { int dp [ ] [ ] = new int [ R ] [ C ] ; int m , n ; for ( m = 0 ; m <= R ; m ++ ) { n = points [ m - 1 ] [ n - 1 ] ; if ( points [ m - 1 ] [ n - 1 ] > 0 ) { dp [ m - 1 ] [ n - 1 ] = 1 ; } else { dp [ m - 1 ] [ n - 1 ] = Math . abs ( points [ m - 1 ] [ n - 1 ] ) + 1 ; } } for ( i = 2 ; i >= 0 ; i -- ) { dp [ i ] [ n - 1 ] = Math . max ( dp [ i + 1 ] [ n - 1 ] - points [ i ] [ n - 1 ] , 1 ) ; } for ( i = m - 2 ; i >= 0 ; i -- ) { for ( j = n - 2 ; j >= 0 ; j -- ) { min_points_on_exit = Math . min ( dp [ i + 1 ] [ j ] , dp [ i ] [ j + 1 ] ) ; dp [ i ] [ j ] = Math . max ( min_points_on_exit - points [ i ] [ j ] , 1 ) ; } } return dp [ 0 ] [ 0 ] ; }
static void printNGE ( int arr [ ] ) { int next = - 1 ; for ( int i = 0 ; i < arr . length ( ) ; i ++ ) { for ( int j = i + 1 ; j < arr . length ( ) ; j ++ ) { if ( arr [ i ] < arr [ j ] ) next = arr [ j ] ; break ; } } System . out . println ( " ▁ - - ▁ " + next ) ; }
