static void firstFit ( int blockSize [ ] , int m , int processSize [ ] , int n ) { int [ ] allocation = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( blockSize [ j ] >= processSize [ i ] ) { allocation [ i ] = j ; blockSize [ j ] -= processSize [ i ] ; break ; } } } System . out . println ( " ▁ Process ▁ No . ▁ Process ▁ Size ▁ ▁ ▁ ▁ ▁ Block ▁ no . " ) ; for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( " ▁ " + i + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " + processSize [ i ] + " ▁ ▁ ▁ ▁ ▁ ▁ " ) ; if ( allocation [ i ] != - 1 ) System . out . print ( allocation [ i ] + 1 ) ; } else { System . out . println ( " Not ▁ Allocated " ) ; } }
static int firstNonRepeating ( int arr [ ] , int n ) { Map < Integer , Integer > myMap = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) myMap [ arr [ i ] ] ++ ; for ( int i = 0 ; i < n ; i ++ ) { if ( myMap [ arr [ i ] ] == 1 ) return arr [ i ] ; } return - 1 ; }
static boolean distributingBalls ( int k , int n , String str ) { int [ ] a = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < n ; i ++ ) a [ str . charAt ( i ) - ' a ' ] ++ ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { if ( a [ i ] > k ) return false ; } return true ; }
static int count_of_ways ( int n ) { int count = 0 ; count = ( n + 1 ) * ( n + 2 ) / 2 ; return count ; }
static int calcAngle ( int h , int m ) { if ( h < 0 || m < 0 || h > 12 || m > 60 ) System . out . println ( ' Wrong ▁ input ' ) ; if ( h == 12 ) h = 0 ; if ( m == 60 ) m = 0 ; hour_angle = 0.5 * ( h * 60 + m ) ; minute_angle = 6 * m ; angle = Math . abs ( hour_angle - minute_angle ) ; angle = Math . min ( 360 - angle , angle ) ; return angle ; }
static int smallest ( int x , int y , int z ) { if ( ! ( y / x ) ) return y ; if ( ! ( x / z ) ) return x ; return y if ( ! ( y / z ) ) else z ; }
static int findExtraCharcter ( String strA , String strB ) { int res = 0 ; for ( int i = 0 ; i < strA . length ( ) ; i ++ ) res = res ^ ( char ) ( strA . charAt ( i ) ) ; for ( int i = 0 ; i < strB . length ( ) ; i ++ ) res = res ^ ( char ) ( strB . charAt ( i ) ) ; return ( res ) ; }
static int findMinimumAngle ( int arr [ ] , int n ) { int l = 0 ; int _sum = 0 ; int ans = 360 ; for ( int i = 0 ; i < n ; i ++ ) { _sum += arr [ i ] ; while ( _sum >= 180 ) { ans = Math . min ( ans , 2 * Math . abs ( 180 - _sum ) ) ; _sum -= arr [ l ] ; l ++ ; } ans = Math . min ( ans , 2 * Math . abs ( 180 - _sum ) ) ; } return ans ; }
static int maxdiff ( int arr [ ] , int n ) { HashMap < Integer , Integer > freq = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { freq [ arr [ i ] ] = 1 ; } int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( freq [ arr [ i ] ] > freq [ arr [ j ] ] && arr [ i ] > arr [ j ] ) ans = Math . max ( ans , freq [ arr [ i ] ] - freq [ arr [ j ] ] ) ; else if ( freq [ arr [ i ] ] < freq [ arr [ j ] ] && arr [ i ] < arr [ j ] ) ans = Math . max ( ans , freq [ arr [ j ] ] - freq [ arr [ i ] ] ) ; } } return ans ; }
static boolean areEqual ( int arr1 [ ] , int arr2 [ ] , int n , int m ) { if ( n != m ) return false ; Arrays . sort ( arr1 ) ; Arrays . sort ( arr2 ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr1 [ i ] != arr2 [ i ] ) { return false ; } } return true ; }
static int PowerOFPINnfactorial ( int n , int p ) { int ans = 0 ; int temp = p ; while ( temp <= n ) ans += n / temp ; return ans ; }
static int search ( int arr [ ] , int n , int x ) { int i ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == x ) return i ; } return - 1 ; }
static boolean isSubSeqDivisible ( String str ) { int n = str . length ( ) ; int dp [ ] [ ] = new int [ 10 ] [ n + 1 ] ; int [ ] arr = new int [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { arr [ i ] = str . charAt ( i - 1 ) ; } for ( int i = 0 ; i <= n ; i ++ ) { dp [ i ] [ arr [ i ] % 8 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 0 ; j < 8 ; j ++ ) { if ( dp [ i - 1 ] [ j ] > dp [ i ] [ ( j * 10 + arr [ i ] ) % 8 ] ) dp [ i ] [ ( j * 10 + arr [ i ] ) % 8 ] = dp [ i - 1 ] [ j ] ; if ( dp [ i - 1 ] [ j ] > dp [ i ] [ j ] ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; } } for ( int i = 1 ; i <= n ; i ++ ) { if ( dp [ i ] [ 0 ] == 1 ) return true ; } return false ; }
static int multiplyWith3Point5 ( int x ) { return ( x << 1 ) + x + ( x >> 1 ) ; }
static int countDivisibleSubseq ( String str , int n ) { int l = str . length ( ) ; int dp [ ] [ ] = new int [ l ] [ n ] ; for ( int [ ] rows : dp ) Arrays . fill ( rows , 0 ) ; for ( int i = 0 ; i < l ; i ++ ) { dp [ 0 ] [ ( str . charAt ( i ) - '0' ) % n ] ++ ; for ( int i = 1 ; i < l ; i ++ ) { dp [ i ] [ ( str . charAt ( i ) - '0' ) ) % n ] ++ ; for ( int j = 0 ; j < n ; j ++ ) { dp [ i ] [ j ] += dp [ i - 1 ] [ j ] ; } } return dp [ l - 1 ] [ 0 ] ; }
static void pairs ( int arr [ ] , int n , int k ) { int smallest = Integer . MAX_VALUE ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( Math . abs ( arr [ i ] + arr [ j ] - k ) < smallest ) { smallest = Math . abs ( arr [ i ] + arr [ j ] - k ) ; count = 1 ; } else if ( Math . abs ( arr [ i ] + arr [ j ] - k ) == smallest ) count ++ ; } } System . out . println ( " Minimal ▁ Value ▁ = ▁ " + smallest ) ; System . out . println ( " Total ▁ Pairs ▁ = ▁ " + count ) ; }
static int maxLen ( int arr [ ] ) { HashMap < Integer , Integer > hash_map = new HashMap < Integer , Integer > ( ) ; int max_len = 0 ; int curr_sum = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { curr_sum += arr [ i ] ; if ( arr [ i ] is 0 && max_len is 0 ) { max_len = 1 ; } if ( curr_sum is 0 ) { max_len = i + 1 ; } else { hash_map [ curr_sum ] = i ; } } return max_len ; }
static int maxLength ( String s , int n ) { int dp [ ] [ ] = new int [ n ] [ n ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( s . charAt ( i ) == ' ( ' && s . charAt ( i + 1 ) == ' ) ' ) dp [ i ] [ i + 1 ] = 2 ; } for ( int l = 2 ; l < n ; l ++ ) { i -- ; if ( s . charAt ( i ) == ' ( ' && s . charAt ( j ) == ' ) ' ) dp [ i ] [ j ] = 2 + dp [ i + 1 ] [ j - 1 ] ; } for ( int k = 0 ; k < i ; k ++ ) { dp [ i ] [ j ] = Math . max ( dp [ i ] [ j ] , dp [ i ] [ k ] + dp [ k + 1 ] [ j ] ) ; } } return dp [ 0 ] [ n - 1 ] ; }
static double summingSeries ( int n ) { return Math . pow ( n , 2 ) ; }
static int moduloMultiplication ( int a , int b , int mod ) { int res = 0 ; a = a % mod ; while ( b ) { if ( b & 1 ) res = ( res + a ) % mod ; a = ( 2 * a ) % mod ; b >>= 1 ; } return res ; }
static int largestPower ( int n , int p ) { int x = 0 ; while ( n > 0 ) n /= p ; x += n ; return x ; }
static int getOddOccurrence ( int arr [ ] ) { int res = 0 ; for ( int element = 0 ; element < arr . length ; element ++ ) res = res ^ element ; return res ; }
static double findArea ( int a ) { double area = ( sqrt ( 5 * ( 5 + 2 * ( sqrt ( 5 ) ) ) * a * a ) / 4 ; return area ; }
static int countRotationsDivBy8 ( String n ) { int l = n . length ( ) ; int count = 0 ; if ( l == 1 ) { oneDigit = n . charAt ( 0 ) ; if ( oneDigit % 8 == 0 ) return 1 ; return 0 ; } if ( l == 2 ) { first = n . charAt ( 0 ) ; second = n . charAt ( 1 ) ; if ( first % 8 == 0 ) count ++ ; if ( second % 8 == 0 ) count ++ ; } int threeDigit = 0 ; for ( int i = 0 ; i < ( l - 2 ) ; i ++ ) { threeDigit = ( int ) n . charAt ( i ) * 100 + int ( n . charAt ( i + 1 ) ) * 10 + int ( n . charAt ( i + 2 ) ) ; if ( threeDigit % 8 == 0 ) count ++ ; } threeDigit = ( int ) n . charAt ( l - 1 ] ) * 100 + int ( n . charAt ( 0 ) ) * 10 + int ( n . charAt ( 1 ) ) ; if ( threeDigit % 8 == 0 ) count ++ ; if ( threeDigit % 8 == 0 ) count ++ ; } return count ; }
static int editDistDP ( String str1 , String str2 , int m , int n ) { int dp [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 ) dp [ i ] [ j ] = j ; else if ( str1 [ i - 1 ] == str2 [ j - 1 ] ) { dp [ i ] [ j ] = i ; } else { dp [ i ] [ j ] = j ; } } } return dp [ m ] [ n ] ; }
static boolean isPower ( int x , int y ) { if ( x == 1 ) return ( y == 1 ) ; int pow = 1 ; while ( pow < y ) pow = pow * x ; return ( pow == y ) ; }
static int maxSum ( int arr [ ] , int N , int k ) { int [ ] MS = new int [ N ] ; MS [ 0 ] = arr [ 0 ] ; MS [ N - 1 ] = arr [ N - 1 ] ; for ( int i = N - 2 ; i >= 0 ; i -- ) { if ( i + k + 1 >= N ) MS [ i ] = Math . max ( arr [ i ] , MS [ i + 1 ] ) ; else MS [ i ] = Math . max ( arr [ i ] + MS [ i + k + 1 ] , MS [ i + 1 ] ) ; } return MS [ 0 ] ; }
static void printGrouped ( String str ) { int n = str . length ( ) ; int [ ] count = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < n ; i ++ ) { count [ str . charAt ( i ) - " a " ] ++ ; } for ( int i = 0 ; i < n ; i ++ ) { while ( count [ str . charAt ( i ) - " a " ] ) System . out . print ( str . charAt ( i ) ) - " a " ) ; -- count [ str . charAt ( i ) - " a " ] ; } for ( int i = 0 ; i < n ; i ++ ) { if ( count [ str . charAt ( i ) - " a " ] ) ; count [ str . charAt ( i ) - " a " ] = 0 ; } }
static int countSub ( String ss ) { int last [ ] = new int [ MAX_CHAR + 1 ] ; int n = ss . length ( ) ; int dp [ ] = new int [ n + 1 ] ; dp [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { dp [ i ] = 2 * dp [ i - 1 ] ; if ( last [ str . charAt ( i - 1 ) ] != - 1 ) { dp [ i ] = dp [ i ] - dp [ last [ str . charAt ( i - 1 ) ] ; last [ str . charAt ( i - 1 ) ] = i - 1 ; } } return dp [ n ] ; }
static void findLIS ( int A [ ] , int n ) { int [ ] hash = new int [ n ] ; int LIS_size , LIS_index = 1 , 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( A [ i ] - 1 not in hash ) hash [ A [ i ] - 1 ] = 0 ; hash [ A [ i ] ] = hash [ A [ i ] - 1 ] + 1 ; if ( LIS_size < hash [ A [ i ] ] ) { LIS_size = hash [ A [ i ] ] ; LIS_index = A [ i ] ; } } System . out . println ( " LIS _ size ▁ = " + LIS_size ) ; System . out . println ( " LIS ▁ : ▁ " ) ; for ( int start = LIS_index - LIS_size + 1 ; start <= LIS_index ; start ++ ) System . out . print ( start + " ▁ " ) ; }
static int maximumZeros ( int arr [ ] [ ] , int n , int k ) { int subset [ ] [ ] = new int [ MAX5 + 5 ] ; subset [ 0 ] [ 0 ] = 0 ; for ( int i = 0 ; i <= k ; i ++ ) { for ( int j = 0 ; j < MAX5 ; j ++ ) { if ( arr [ i ] [ j ] != - 1 ) { subset [ i + 1 ] [ j + pw5 ] = ( Math . max ( subset [ i ] [ j ] + pw2 ) ) ; } } int ans = 0 ; for ( int i = 0 ; i <= k - 1 ; i -- ) { for ( int j = 0 ; j <= MAX5 ; j ++ ) { if ( subset [ i ] [ j ] != - 1 ) { subset [ i + 1 ] [ j + pw5 ] = ( Math . max ( subset [ i + 1 ] [ j + pw5 ] , ( subset [ i ] [ j ] + pw2 ) ) ) ; } } } int ans = 0 ; for ( int i = 0 ; i <= MAX5 ; i ++ ) ans = Math . max ( ans , Math . min ( i , subset [ k ] [ i ] ) ) ; } return ans ; }
static int maxDiff ( int arr [ ] , int n ) { int result = 0 ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( Math . abs ( arr [ i ] ) != Math . abs ( arr [ i + 1 ] ) ) result += Math . abs ( arr [ i ] ) ; else { pass ; } } if ( arr [ n - 2 ] != arr [ n - 1 ] ) result += Math . abs ( arr [ n - 1 ] ) ; else result += Math . abs ( arr [ n - 1 ] ) ; } return result ; }
static int countNums ( int n , int x , int y ) { boolean [ ] arr = new boolean [ n + 2 ] ; if ( x <= n ) arr [ x ] = true ; if ( y <= n ) arr [ y ] = true ; int result = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { if ( arr [ i ] ) { if ( i + x <= n ) arr [ i + x ] = true ; if ( i + y <= n ) arr [ i + y ] = true ; } result ++ ; } return result ; }
static int countPS ( String str ) { int N = str . length ( ) ; int [ ] [ ] cps = new int [ N ] [ N + 2 ] ; for ( int i = 0 ; i < N ; i ++ ) { cps [ i ] [ i ] = 1 ; } for ( int L = 2 ; L <= N ; L ++ ) { for ( int i = 0 ; i < N ; i ++ ) { cps [ i ] [ i ] = 1 ; } for ( int i = 0 ; i < N ; i ++ ) { int k = L + i - 1 ; if ( k < N ) { cps [ i ] [ k ] = ( str . charAt ( i ) == str . charAt ( k ) ) ? ( cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] + 1 ) : ( cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] - cps [ i + 1 ] [ k - 1 ] ) ; } } } return cps [ 0 ] [ N - 1 ] ; }
static int countSetBits ( int n ) { if ( n == 0 ) return 0 ; else return ( n & 1 ) + countSetBits ( n >> 1 ) ; }
static int numofAP ( int a [ ] , int n ) { int minarr = Integer . MAX_VALUE ; int maxarr = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) minarr = Math . min ( minarr , a [ i ] ) ; maxarr = Math . max ( maxarr , a [ i ] ) ; int dp [ ] = new int [ n + 1 ] ; int ans = n + 1 ; for ( int d = ( minarr - maxarr ) , sum = new int [ MAX + 1 ] ; for ( int i = 0 ; i <= MAX ; i ++ ) { dp [ i ] = 1 ; if ( a [ i ] - d >= 1 && a [ i ] - d <= 1000000 ) dp [ i ] += sum [ a [ i ] - d ] ; ans += dp [ i ] - 1 ; sum [ a [ i ] ] += dp [ i ] ; } } return ans ; }
static void spiralFill ( int m , int n , int [ ] a ) { int val = 1 ; int k = 0 , l = 0 ; while ( k < m && l < n ) { for ( int i = l ; i < n ; ++ i ) { a [ k ] [ i ] = val ; val ++ ; } k ++ ; for ( int i = k ; i < m ; ++ i ) { a [ i ] [ n - 1 ] = val ; val ++ ; } n -- ; if ( k < m ) { for ( int i = n - 1 ; i >= l ; -- i ) { a [ m - 1 ] [ i ] = val ; val ++ ; } m -- ; } if ( l < n ) { for ( int i = m - 1 ; i >= k ; -- i ) { a [ i ] [ l ] = val ; val ++ ; } l ++ ; } } }
static void printClosest ( int arr1 [ ] , int arr2 [ ] , int m , int n , int x ) { int diff = Integer . MAX_VALUE ; int l = 0 , r = n - 1 ; while ( l < m && r >= 0 ) { if ( Math . abs ( arr1 [ l ] + arr2 [ r ] - x ) < diff ) { res_l = l ; res_r = r ; diff = Math . abs ( arr1 [ l ] + arr2 [ r ] - x ) ; if ( arr1 [ l ] + arr2 [ r ] > x ) r = r - 1 ; } else l ++ ; } System . out . println ( " The ▁ closest ▁ pair ▁ is ▁ [ " + arr1 [ res_l ] + " , ▁ " + arr2 [ res_r ] + " ] " ) ; }
static int findInteger ( int arr [ ] , int n ) { HashMap < Integer , Integer > hash = new HashMap < Integer , Integer > ( ) ; int maximum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i < 0 ) hash [ abs ( i ) ] = - 1 ; else hash [ abs ( i ) ] -= 1 ; } else { hash [ i ] = hash . get ( i , 0 ) + 1 ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( i < 0 ) hash . put ( i , 0 ) ; else hash . put ( i , hash . get ( i , 0 ) + 1 ) ; } } return - 1 ; }
static int decimalToBinary ( int N ) { int B_Number = 0 ; int cnt = 0 ; while ( N != 0 ) { int rem = N % 2 ; int c = pow ( 10 , cnt ) ; B_Number += rem * c ; N /= 2 ; cnt ++ ; } return B_Number ; }
static int Right_most_setbit ( int num ) { int pos = 1 ; for ( int i = 0 ; i < INT_SIZE ; i ++ ) if ( num & ( 1 << i ) ) pos ++ ; else break ; return pos ; }
static int countDigits ( int a , int b ) { if ( a == 0 || b == 0 ) return 1 ; return Math . floor ( Math . log10 ( a ) ) + Math . log10 ( abs ( b ) ) ) + 1 ; }
static int CountWays ( int n ) { int table [ ] = new int [ n + 1 ] ; table [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = i ; j <= n ; j ++ ) table [ j ] += table [ j - i ] ; } return table [ n ] ; }
static void twoWaySort ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] & 1 ) arr [ i ] *= - 1 ; } }
static void factorize ( int n ) { int count = 0 ; while ( ( n % 2 > 0 ) == false ) n >>= 1 ; count ++ ; for ( int i = 3 ; i <= Math . sqrt ( n ) ; i ++ ) { count = 0 ; while ( n % i == 0 ) count ++ ; n = n / i ; if ( count > 0 ) System . out . print ( i , count ) ; } for ( int i = 3 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( count > 0 ) System . out . print ( i , count ) ; } if ( n > 2 ) System . out . print ( n , 1 ) ; }
static int findSmallestDifference ( int A [ ] , int B [ ] , int m , int n ) { Arrays . sort ( A ) ; Arrays . sort ( B ) ; int a = 0 , b = 0 , result = Integer . MAX_VALUE ; while ( a < m && b < n ) { if ( Math . abs ( A [ a ] - B [ b ] ) < result ) result = Math . abs ( A [ a ] - B [ b ] ) ; if ( A [ a ] < B [ b ] ) a ++ ; else b ++ ; } return result ; }
static boolean isPath ( int arr [ ] [ ] ) { arr [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i < row ; i ++ ) { if ( arr [ i ] [ 0 ] != - 1 ) arr [ i ] [ 0 ] = arr [ i - 1 ] [ 0 ] ; } for ( int j = 1 ; j < col ; j ++ ) { if ( arr [ 0 ] [ j ] != - 1 ) arr [ 0 ] [ j ] = arr [ 0 ] [ j - 1 ] ; } } for ( int i = 1 ; i < row ; i ++ ) { for ( int j = 1 ; j < col ; j ++ ) { if ( arr [ i ] [ j ] != - 1 ) arr [ i ] [ j ] = Math . max ( arr [ i ] [ j - 1 ] , arr [ i - 1 ] [ j ] ) ; } } return ( arr [ row - 1 ] [ col - 1 ] == 1 ) ; }
static int solve ( int dp [ ] [ ] , int a [ ] , int low , int high , int turn ) { if ( low == high ) return a [ low ] * turn ; if ( dp [ low ] [ high ] != 0 ) return dp [ low ] [ high ] ; dp [ low ] [ high ] = Math . max ( a [ low ] * turn + solve ( dp , a , low + 1 , high , turn + 1 ) , a [ high ] * turn + solve ( dp , a , low , high - 1 , turn + 1 ) ) ; return dp [ low ] [ high ] ; }
static int swapNibbles ( int x ) { return ( x & 0x0F ) << 4 | ( x & 0xF0 ) >> 4 ) ; }
public static int countPS ( int i , int j ) { if ( i >= n || j < 0 ) return 0 ; if ( dp [ i ] [ j ] != - 1 ) return dp [ i ] [ j ] ; if ( Math . abs ( i - j ) == 1 ) { if ( str [ i ] == str [ j ] ) dp [ i ] [ j ] = 3 ; else dp [ i ] [ j ] = 2 ; } if ( i == j ) { dp [ 1 ] [ j ] = 1 ; return dp [ 1 ] [ j ] ; } else if ( i == j ) { dp [ 1 ] [ j ] = 1 ; return dp [ 1 ] [ j ] ; } else if ( str [ i ] == str [ j ] ) { dp [ i ] [ j ] = ( countPS ( i + 1 , j ) + countPS ( i , j - 1 ) + 1 ) ; return dp [ i ] [ j ] ; } }
static int addOne ( int x ) { int m = 1 ; while ( ( x & m ) != 0 ) x = x ^ m ; return x ; }
static boolean check ( String str ) { int n = str . length ( ) ; int digitSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) digitSum += ( int ) ( str . charAt ( i ) ) ; return ( digitSum % 9 == 0 ) ; }
static int findMaxGCD ( int arr [ ] , int n ) { int high = 0 ; for ( int i = 0 ; i < n ; ++ i ) { high = Math . max ( high , arr [ i ] ) ; i ++ ; } int [ ] divisors = new int [ high + 1 ] ; for ( int i = 0 ; i < n ; ++ i ) { divisors [ i ] = 0 ; for ( int j = 1 ; j <= Math . sqrt ( arr [ i ] ) ; ++ j ) { if ( arr [ i ] % j == 0 ) divisors [ j ] = divisors [ j ] + 1 ; if ( j != arr [ i ] / j ) divisors [ arr [ i ] / j ] = divisors [ arr [ i ] / j ] ; } } for ( int i = high ; i >= 1 ; -- i ) if ( divisors [ i ] > 1 ) return i ; return 1 ; }
static int minRemove ( int arr [ ] , int n ) { int LIS [ ] = new int [ n ] ; int len = 0 ; for ( int i = 0 ; i < n ; i ++ ) LIS [ i ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ i ] > arr [ j ] && ( i - j ) <= ( arr [ i ] - arr [ j ] ) ) LIS [ i ] = Math . max ( LIS [ i ] , LIS [ j ] + 1 ) ; } } return ( n - len ) ; }
static void computeLPSArray ( char pat [ ] , int M , int lps [ ] ) { int len = 0 ; for ( int i = 1 ; i < M ; i ++ ) { if ( pat [ i ] == pat [ len ] ) { len ++ ; lps [ i ] = len ; i ++ ; } else { if ( len != 0 ) { len = lps [ len - 1 ] ; } else { lps [ i ] = 0 ; } } }
static int numofsubset ( int arr [ ] , int n ) { int [ ] x = Arrays . sort ( arr ) ; int count = 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] + 1 != x [ i + 1 ] ) count ++ ; return count ; }
static int stringReduction ( String str ) { int n = str . length ( ) ; int [ ] count = new int [ 3 ] ; for ( int i = 0 ; i < n ; i ++ ) { count [ str . charAt ( i ) - ' a ' ] ++ ; if ( count [ 0 ] == n || count [ 1 ] == n || count [ 2 ] == n ) return n ; if ( count [ 0 ] == n || count [ 1 ] == n || count [ 2 ] == n ) return n ; if ( count [ 0 ] % 2 == ( count [ 1 ] % 2 ) == ( count [ 2 ] % 2 ) ) return 2 ; } return 1 ; }
static int KnapSack ( int val [ ] , int wt [ ] , int n , int W ) { int dp [ ] = new int [ W ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = W ; j < wt [ i ] ; j ++ ) dp [ j ] = Math . max ( dp [ j ] , val [ i ] + dp [ j - wt [ i ] ] ) ; } return dp [ W ] ; }
static int findSum ( int n ) { int multiTerms = n * ( n + 1 ) / 2 ; int sm = multiTerms ; for ( int i = 2 ; i <= n ; i ++ ) multiTerms = multiTerms - ( i - 1 ) ; sm = sm + multiTerms * i ; return sm ; }
static int getSingle ( int arr [ ] , int n ) { int result = 0 ; for ( int i = 0 ; i < INT_SIZE ; i ++ ) { int sm = 0 ; int x = ( 1 << i ) ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] & x ) sm ++ ; if ( sm % 3 != 0 ) result |= x ; } } return result ; }
static boolean allCharactersSame ( String s ) { int n = s . length ( ) ; for ( int i = 1 ; i < n ; i ++ ) if ( s . charAt ( i ) != s . charAt ( 0 ) ) return false ; return true ; }
static int maxDecimalValue ( int mat [ ] [ ] , int i , int j , int p ) { if ( i >= N || j >= N ) return 0 ; int result = Math . max ( maxDecimalValue ( mat , i , j + 1 , p + 1 ) , maxDecimalValue ( mat , i + 1 , j , p + 1 ) ) ; if ( mat [ i ] [ j ] == 1 ) return pow ( 2 , p ) + result ; else return result ; }
static int countBT ( int h ) { int MOD = 1000000007 ; int dp [ ] = new int [ h + 1 ] ; dp [ 0 ] = 1 ; dp [ 1 ] = 1 ; for ( int i = 2 ; i <= h ; i ++ ) dp [ i ] = dp [ i - 1 ] * ( ( 2 * dp [ i - 2 ] ) % MOD + dp [ i - 1 ] ) % MOD ; return dp [ h ] ; }
static int power ( int x , int y , int p ) { int res = 1 ; x = x % p ; while ( y > 0 ) { if ( ( y & 1 ) == 1 ) res = ( res * x ) % p ; y = y >> 1 ; x = ( x * x ) % p ; } return res ; }
static int swapBits ( int x , int p1 , int p2 , int n ) { int set1 = ( x >> p1 ) & ( ( 1 << n ) - 1 ) ; int set2 = ( x >> p2 ) & ( ( 1 << n ) - 1 ) ; int xor = ( set1 ^ set2 ) ; xor = ( xor << p1 ) | ( xor << p2 ) ; result = x ^ xor ; }
static void findElements ( int arr [ ] , int n ) { int first = Integer . MAX_VALUE ; int second = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > first ) second = first ; first = arr [ i ] ; else if ( arr [ i ] > second ) second = arr [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < second ) System . out . print ( arr [ i ] + " ▁ " ) ; } }
static int findMaximum ( int arr [ ] , int low , int high ) { int max = arr [ low ] ; int i ; for ( i = low ; i <= high ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; } return max ; }
static int longestPrefixSuffix ( String s ) { int n = s . length ( ) ; int [ ] lps = new int [ n ] ; int i = 1 ; for ( i = 1 ; i < n ; i ++ ) { if ( s . charAt ( i ) == s . charAt ( l ) ) l = l + 1 ; lps [ i ] = l ; i ++ ; } else { if ( l != 0 ) l = lps [ l - 1 ] ; else lps [ i ] = 0 ; i ++ ; } } int res = lps [ n - 1 ] ; if ( res > n / 2 ) return n / 2 ; else return res ; }
static int MaxTotalRectangleArea ( int a [ ] , int n ) { Arrays . sort ( a , Collections . reverseOrder ( ) ) ; int sum = 0 ; boolean flag = false ; int len = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( i != 0 ) { i ++ ; } if ( ( a [ i ] == a [ i + 1 ] || a [ i ] - a [ i + 1 ] == 1 ) && flag == false ) { flag = true ; len = a [ i + 1 ] ; i ++ ; } else if ( ( a [ i ] == a [ i + 1 ] || a [ i ] - a [ i + 1 ] == 1 ) && flag == true ) sum += a [ i + 1 ] * len ; flag = false ; i ++ ; } } return sum ; }
boolean isHeap ( int arr [ ] , int i , int n ) { if ( i > ( n - 2 ) / 2 ) return true ; if ( arr [ i ] >= arr [ 2 * i + 1 ] && arr [ i ] >= arr [ 2 * i + 2 ] && isHeap ( arr , 2 * i + 1 , n ) && isHeap ( arr , 2 * i + 2 , n ) ) return true ; return false ; }
static int findLength ( int st [ ] , int n ) { int [ ] total = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) total [ i ] = total [ i - 1 ] + ( st [ i - 1 ] ) - ( '0' ) ; int ans = 0 ; for ( int i = 2 ; i <= n - l ; i ++ ) { int j = i + l - 1 ; if ( total [ i + l ] - total [ i + int ( l / 2 ) ] == total [ i + l ] - total [ i + int ( l / 2 ) ] ) ans = Math . max ( ans , l ) ; } return ans ; }
static int maxDP ( int n ) { int [ ] res = new int [ n + 1 ] ; res . add ( 0 ) ; res . add ( 1 ) ; res . add ( 2 ) ; for ( int i = 2 ; i < n + 1 ; i ++ ) res . add ( Math . max ( i , ( res [ int ( i / 2 ) ] + res [ int ( i / 3 ) ] + res [ int ( i / 4 ) ] + res [ int ( i / 5 ) ] ) ) ; return res [ n ] ; }
static int findDiff ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int count = 0 ; int max_count = 0 , min_count = n ; for ( int i = 0 ; i < ( n - 1 ) ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) count ++ ; else if ( arr [ i ] == arr [ i + 1 ] ) max_count = Math . max ( max_count , count ) ; min_count = min ( min_count , count ) ; count = 0 ; } return max_count - min_count ; }
static int countSink ( int n , int m , int [ ] edgeFrom , int edgeTo ) { int mark [ ] = new int [ m + 1 ] ; for ( int i = 0 ; i < m ; i ++ ) mark [ edgeFrom [ i ] ] = 1 ; int count = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( ! mark [ i ] ) count ++ ; } return count ; }
static int countOfSubstringWithKOnes ( String s , int K ) { int N = s . length ( ) ; int res = 0 ; int countOfOne = 0 ; int freq [ ] = new int [ N + 1 ] ; freq [ 0 ] = 1 ; for ( int i = 1 ; i <= N ; i ++ ) { countOfOne += ( s . charAt ( i ) - '0' ) ; if ( countOfOne >= K ) res += freq [ countOfOne - K ] ; freq [ countOfOne ] ++ ; } return res ; }
static int search ( int arr [ ] , int n , int x ) { for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == x ) return i ; } return - 1 ; }
static int binaryToDecimal ( String n ) { char [ ] num = n . toCharArray ( ) ; int dec_value = 0 ; int base1 = 1 ; int len1 = num . length ( ) ; for ( int i = len1 - 1 ; i >= 0 ; i -- ) { if ( num . charAt ( i ) == '1' ) dec_value += base1 ; base1 = base1 * 2 ; } return dec_value ; }
static String compute ( String str , int n ) { String reverseAlphabet = " zyxwvutsrqponmlkjihgfedcba " ; int l = str . length ( ) ; String answer = " " ; for ( int i = 0 ; i < n ; i ++ ) { answer = answer + str . charAt ( i ) ; } for ( int i = 0 ; i < l ; i ++ ) { answer = answer + reverseAlphabet [ str . charAt ( i ) - ' a ' ] ; } return answer ; }
static int countPairs ( String str ) { int result = 0 ; int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( Math . abs ( str . charAt ( i ) - str . charAt ( j ) ) == Math . abs ( i - j ) ) result ++ ; } } return result ; }
static boolean flipsPossible ( int a [ ] , int n ) { int count_odd = 0 , count_even = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] & 1 ) count_odd ++ ; else count_even ++ ; } if ( count_odd % 2 && count_even % 2 ) return false ; else return true ; }
static int maxSumPairWithDifferenceLessThanK ( int arr [ ] , int N , int K ) { int dp [ ] = new int [ N ] ; Arrays . sort ( arr ) ; for ( int i = 1 ; i < N ; i ++ ) { dp [ i ] = dp [ i - 1 ] ; if ( arr [ i ] - arr [ i - 1 ] < K ) { dp [ i ] = Math . max ( dp [ i ] , dp [ i - 2 ] + arr [ i ] + arr [ i - 1 ] ) ; } else { dp [ i ] = Math . max ( dp [ i ] , arr [ i ] + arr [ i - 1 ] ) ; } } return dp [ N - 1 ] ; }
static void kSmallestPair ( int arr1 [ ] , int n1 , int arr2 [ ] , int n2 , int k ) { if ( k > n1 * n2 ) System . out . println ( " k ▁ pairs ▁ don ' t ▁ exist " ) ; return ; } int [ ] index2 = new int [ n1 ] ; while ( k > 0 ) { index2 [ i ] = 0 ; for ( int i1 = 0 ; i1 < n1 ; i1 ++ ) { if ( index2 [ i1 ] < n2 && arr1 [ i1 ] + arr2 [ index2 [ i1 ] ] < min_sum ) { min_index = i1 ; min_sum = arr1 [ i1 ] + arr2 [ index2 [ i1 ] ] ; } } System . out . println ( " k ▁ pairs ▁ don ' t ▁ exist " ) ; return ; }
static void assign ( int [ ] a , int n ) { Arrays . sort ( a ) ; int [ ] ans = new int [ n ] ; int p = 0 , q = n - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( i + 1 ) % 2 == 0 ) ans [ i ] = a [ q ] ; q = q - 1 ; else ans [ i ] = a [ p ] ; p = p + 1 ; } }
static int findFourElements ( int arr [ ] , int n ) { Map < Integer , Integer > myMap = new HashMap < > ( ) ; for ( int i = 0 ; i < n - 2 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) myMap . put ( arr [ i ] + arr [ j ] , myMap . get ( i ) ) ; } int d = Integer . MIN_VALUE ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int abs_diff = Math . abs ( arr [ i ] - arr [ j ] ) ; if ( abs_diff < 0 ) { int p = myMap . get ( abs_diff ) ; if ( p [ 0 ] != i && p [ 0 ] != j ) d = Math . max ( d , Math . max ( arr [ i ] , arr [ j ] ) ) ; } } return d ; }
static boolean isPrime ( int p ) { int checkNumber = 2 ** p - 1 ; int nextval = 4 % checkNumber ; for ( int i = 1 ; i <= p - 2 ; i ++ ) nextval = ( nextval * nextval - 2 ) % checkNumber ; if ( nextval == 0 ) return true ; else return false ; }
static boolean isPalindrome ( String str ) { int l = 0 , h = str . length ( ) - 1 ; while ( l > h ) l ++ ; h -- ; if ( str . charAt ( l - 1 ) != str . charAt ( h + 1 ) ) return false ; return true ; }
static int maxNumOfChocolates ( int arr [ ] , int n , int k ) { int um [ ] = new int [ k ] ; int maxSum = 0 ; int [ ] sm = new int [ n ] ; sm [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { sm [ i ] = sm [ i - 1 ] + arr [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { curr_rem = sm [ i ] % k ; if ( ! curr_rem && maxSum < sm [ i ] ) { maxSum = sm [ i ] ; } else if ( maxSum < ( sm [ i ] - sm [ um [ curr_rem ] ] ) ) { maxSum = sm [ i ] - sm [ um [ curr_rem ] ] ; } } return maxSum / k ; }
static int isPower ( double x , double y ) { double res1 = Math . log ( y ) / Math . log ( x ) ; double res2 = Math . log ( y ) / Math . log ( x ) ; return 1 if ( res1 == res2 ) else 0 ; }
static void minMaxValues ( int arr [ ] , int n , int m ) { int sum = 0 ; int INF = 1000000 ; int MAX = 50 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; arr [ i ] += 50 ; } int dp [ ] [ ] = new int [ MAX * MAX + 1 ] ; for ( int i = 0 ; i < m ; i ++ ) { dp [ 0 ] [ i ] = 1 ; for ( int k = min ( n , i + 1 ) ; k >= 0 ; k -- ) { for ( int j = 0 ; j <= MAX * MAX + 1 ; j ++ ) { if ( dp [ k - 1 ] [ j ] ) { dp [ k ] [ j + arr [ i ] ] = 1 ; } } } int max_value = Integer . MIN_VALUE ; int min_value = Integer . MIN_VALUE ; for ( int i = 0 ; i <= MAX * MAX + 1 ; i ++ ) { if ( dp [ n ] [ i ] ) { temp = i - 50 * n ; max_value = Math . max ( max_value , temp * ( sum - temp ) ) ; min_value = Math . min ( min_value , temp * ( sum - temp ) ) ; } } System . out . println ( " Maximum ▁ Value : ▁ " + max_value + " " ) ; }
static int superSeq ( int X [ ] , int Y [ ] , int m , int n ) { if ( ! m ) return n ; if ( ! n ) return m ; if ( X [ m - 1 ] == Y [ n - 1 ] ) return 1 + superSeq ( X , Y , m - 1 , n - 1 ) ; return 1 + Math . min ( superSeq ( X , Y , m - 1 , n ) , superSeq ( X , Y , m , n - 1 ) ) ; }
static int longSubarrWthSumDivByK ( int arr [ ] , int n , int k ) { int um [ ] = new int [ 8 ] ; int [ ] mod_arr = new int [ n ] ; int max = 0 ; int curr_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { curr_sum += arr [ i ] ; mod_arr [ i ] = ( curr_sum % k ) + k ; } for ( int i = 0 ; i < n ; i ++ ) { if ( mod_arr [ i ] == 0 ) max = i + 1 ; else if ( mod_arr [ i ] in um ) um [ mod_arr [ i ] ] = i ; else { if ( max < ( i - um [ mod_arr [ i ] ] ) max = i - um [ mod_arr [ i ] ] ; } } return max ; }
static int arrangeBraces ( int n , int [ ] pos , int k ) { boolean h [ ] = new boolean [ N ] [ N ] ; int dp [ ] [ ] = new int [ N ] [ k ] ; for ( int i = 0 ; i < k ; i ++ ) { h [ pos [ i ] ] = true ; } dp [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= 2 * n ; i ++ ) { for ( int j = 2 * n ; j < n ; j ++ ) { if ( h [ i ] ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ; } else { dp [ i ] [ j ] = 0 ; } } } return dp [ 2 * n ] [ 0 ] ; }
static String lexSmallest ( int a [ ] , int n ) { Arrays . sort ( a , Collections . reverseOrder ( ) ) ; String answer = " " ; for ( int i = 0 ; i < n ; i ++ ) answer += a [ i ] ; return answer ; }
static int subset ( int ar [ ] , int n ) { int res = 0 ; Arrays . sort ( ar ) ; for ( int i = 0 ; i < n ; i ++ ) { int count = 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( ar [ i ] == ar [ i + 1 ] ) count ++ ; else break ; } res = Math . max ( res , count ) ; } return res ; }
static String printSubStr ( String str , int low , int high ) { System . out . print ( str . substring ( low , high + 1 ) ) ; System . out . flush ( ) ; return null ; }
static int getMinSquares ( int n ) { int dp [ ] = new int [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { dp . add ( i ) ; for ( int x = 1 ; x <= Math . ceil ( i ) ; x ++ ) { int temp = x * x ; if ( temp > i ) break ; else dp [ i ] = Math . min ( dp [ i ] , 1 + dp [ i - temp ] ) ; } } return dp [ n ] ; }
static void printClosest ( int arr [ ] , int n , int x ) { int res_l , res_r = 0 , l = 0 , r = 0 , diff = 0 ; while ( r > l ) { if ( Math . abs ( arr [ l ] + arr [ r ] - x ) < diff ) { res_l = l ; res_r = r ; diff = Math . abs ( arr [ l ] + arr [ r ] - x ) ; } else { l ++ ; } } System . out . println ( ' The ▁ closest ▁ pair ▁ is ▁ { } ▁ and ▁ ' + arr [ res_l ] + ' ▁ ' + arr [ res_r ] ) ; }
int countSubStr ( char str [ ] , int n ) { int m = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == '1' ) m ++ ; } return m * ( m - 1 ) / 2 ; }
static int countSubstringWithEqualEnds ( String s ) { int result = 0 ; int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( s . charAt ( i ) == s . charAt ( j ) ) result ++ ; } } return result ; }
static int calcMaxValue ( String str ) { int res = str . charAt ( 0 ) - 48 ; for ( int i = 1 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) == '0' || str . charAt ( i ) == '1' || res < 2 ) res += ( char ) str . charAt ( i ) - 48 ; else res *= ( char ) str . charAt ( i ) - 48 ; } return res ; }
static void bestFit ( int blockSize [ ] , int m , int processSize [ ] , int n ) { int [ ] allocation = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { int bestIdx = - 1 ; for ( int j = 0 ; j < m ; j ++ ) { if ( blockSize [ j ] >= processSize [ i ] ) { bestIdx = j ; } else if ( blockSize [ bestIdx ] > blockSize [ j ] ) { bestIdx = j ; } } System . out . println ( " Process ▁ No . ▁ Process ▁ Size ▁ ▁ ▁ Block ▁ no . " ) ; for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( i + 1 + " ▁ ▁ ▁ ▁ ▁ ▁ " + processSize [ i ] + " ▁ ▁ ▁ ▁ ▁ " ) ; if ( allocation [ i ] != - 1 ) System . out . println ( allocation [ i ] + 1 ) ; } }
static void countFreq ( int [ ] a , int n ) { HashMap < Integer , Integer > hm = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) hm . put ( a [ i ] , hm . get ( a [ i ] ) + 1 ) ; int cumul = 0 ; for ( int i = 0 ; i < n ; i ++ ) { cumul += hm . get ( a [ i ] ) ; if ( hm [ a [ i ] ] > 0 ) System . out . println ( a [ i ] + " - > " + cumul ) ; hm . put ( a [ i ] , 0 ) ; } }
static boolean isSubSeqDivisible ( int str [ ] ) { int l = str . length ( ) ; int [ ] arr = new int [ l ] ; for ( int i = 0 ; i < l ; i ++ ) { for ( int j = 0 ; j < l ; j ++ ) { for ( int k = 0 ; k < l ; k ++ ) { if ( arr [ i ] % 8 == 0 ) return true ; else if ( arr [ i ] * 10 + arr [ j ] ) % 8 == 0 && i != j ) return true ; else if ( ( arr [ i ] * 100 + arr [ j ] * 10 + arr [ k ] ) % 8 == 0 && i != j && j != k && i != k ) return true ; } } } return false ; }
static int getAbs ( int n ) { int mask = n >> ( SIZE_INT * CHARBIT - 1 ) ; return ( n + mask ) ^ mask ; }
static boolean isAnBn ( String str ) { int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( str . charAt ( i ) != ' a ' ) break ; if ( i * 2 != n ) return false ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( str . charAt ( j ) != ' b ' ) break ; } } return true ; }
static int maxDistance ( int arr [ ] , int n ) { Map < Integer , Integer > myMap = new HashMap < > ( ) ; int maxDict = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! myMap . containsKey ( arr [ i ] ) ) myMap . put ( arr [ i ] , i ) ; else maxDict = Math . max ( maxDict , i - myMap . get ( arr [ i ] ) ) ; } return maxDict ; }
static int maxSumWO3Consec ( int arr [ ] , int n ) { int [ ] sum = new int [ n ] ; if ( n >= 1 ) sum [ 0 ] = arr [ 0 ] ; if ( n >= 2 ) sum [ 1 ] = arr [ 0 ] + arr [ 1 ] ; if ( n > 2 ) sum [ 2 ] = Math . max ( sum [ 1 ] , Math . max ( arr [ 1 ] + arr [ 2 ] , arr [ 0 ] + arr [ 2 ] ) ) ; for ( int i = 3 ; i < n ; i ++ ) sum [ i ] = Math . max ( sum [ i - 1 ] , sum [ i - 2 ] + arr [ i ] ) , arr [ i ] + arr [ i - 1 ] + sum [ i - 3 ] ) ; return sum [ n - 1 ] ; }
static int nobleInteger ( int arr [ ] ) { Arrays . sort ( arr ) ; int n = arr . length ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) continue ; if ( arr [ i ] == n - i - 1 ) return arr [ i ] ; } if ( arr [ n - 1 ] == 0 ) return arr [ n - 1 ] ; return - 1 ; }
static void productArray ( int arr [ ] , int n ) { if ( n == 1 ) System . out . println ( 0 ) ; return ; } int temp = 1 ; for ( int i = 0 ; i < n ; i ++ ) { prod [ i ] = temp ; temp *= arr [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( prod [ i ] + " ▁ " ) ; } return ; }
static boolean sortedAfterSwap ( int A [ ] , int B [ ] , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( B [ i ] == 1 ) { int j = i ; while ( B [ j ] == 1 ) j ++ ; A [ i ] = j + 1 ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( A [ i ] != i + 1 ) return false ; } return true ; }
static int maxSubarrayXOR ( int arr [ ] , int n ) { int ans = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { int curr_xor = 0 ; for ( int j = i ; j < n ; j ++ ) curr_xor = curr_xor ^ arr [ j ] ; ans = Math . max ( ans , curr_xor ) ; } return ans ; }
static int minRemovalsDP ( int arr [ ] , int n ) { int longest_start = - 1 ; int longest_end = 0 ; for ( int start = 0 ; start < n ; start ++ ) { int min = Integer . MAX_VALUE ; int max = Integer . MAX_VALUE ; for ( int end = start ; end < n ; end ++ ) { int val = arr [ end ] ; if ( val < min ) min = val ; if ( val > max ) max = val ; if ( 2 * min <= max ) break ; if ( end - start > longest_end - longest_start || longest_start == - 1 ) break ; if ( end - start > longest_end - longest_start || longest_start == - 1 ) return n ; } } if ( longest_start == - 1 ) return n ; return ( longest_end - longest_start + 1 ) ; }
static double surface_area_octahedron ( int side ) { return 2 * ( Math . sqrt ( 3 ) ) * ( side * side ) ) ; }
static int countUnique ( int mat [ ] [ ] , int n , int m ) { int rowsum [ ] = new int [ n ] ; int [ ] colsum = new int [ m ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( mat [ i ] [ j ] != 0 ) rowsum [ i ] ++ ; colsum [ j ] ++ ; } } int uniquecount = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( mat [ i ] [ j ] != 0 && rowsum [ i ] == 1 && colsum [ j ] == 1 ) uniquecount ++ ; } } return uniquecount ; }
static int remainder ( String str ) { int ln = str . length ( ) ; int rem = 0 ; for ( int i = 0 ; i < ln ; i ++ ) { int num = rem * 10 + ( int ) ( str . charAt ( i ) ) ; rem = num % 11 ; } return rem ; }
boolean checkReverse ( int arr [ ] , int n ) { if ( n == 1 ) return true ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i - 1 ] < arr [ i ] ) { if ( i == n ) return true ; } int j , k ; for ( j = i ; j < n ; j ++ ) { if ( i > 1 && arr [ j ] < arr [ i - 2 ] ) { if ( i > 1 && arr [ j ] < arr [ i - 1 ] ) { return false ; } if ( j == n ) return true ; } k = j ; if ( arr [ k ] < arr [ i - 1 ] ) { if ( arr [ k ] < arr [ k - 1 ] ) { return false ; } k ++ ; } } return true ; }
static double vol_of_octahedron ( int side ) { return ( Math . pow ( side , 2 ) * ( Math . sqrt ( 2 ) / 3 ) ) ; }
static int maxDifference ( int arr [ ] , int N , int k ) { int S = 0 , S1 = 0 ; int max_difference = 0 ; for ( int i = 0 ; i < N ; i ++ ) S += arr [ i ] ; arr . sort ( reverseOrder = true ) ; int M = Math . max ( k , N - k ) ; for ( int i = 0 ; i < M ; i ++ ) S1 += arr [ i ] ; max_difference = S1 - ( S - S1 ) ; return max_difference ; }
static int maxSumSubarrayRemovingOneEle ( int arr [ ] , int n ) { int fw [ ] = new int [ n ] ; int [ ] bw = new int [ n ] ; int cur_max , max_so_far = arr [ 0 ] , arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { cur_max = Math . max ( arr [ i ] , cur_max + arr [ i ] ) ; max_so_far = Math . max ( max_so_far , cur_max ) ; bw [ i ] = cur_max ; } int fans = max_so_far ; for ( i = 1 ; i <= n - 2 ; i -- ) { cur_max = Math . max ( arr [ i ] , cur_max + arr [ i ] ) ; max_so_far = Math . max ( max_so_far , cur_max ) ; bw [ i ] = cur_max ; } } return fans ; }
static int findMaxPoints ( int A [ ] [ ] ) { int i , j ; int P1S [ ] [ ] = new int [ N + 2 ] [ M + 2 ] ; int [ ] P2S [ ] [ ] = new int [ M + 2 ] ; int [ ] [ ] P2E = new int [ M + 2 ] ; for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < M ; j ++ ) { P1S [ i ] [ j ] = Math . max ( P1S [ i - 1 ] [ j ] , P1S [ i ] [ j - 1 ] ) + A [ i - 1 ] [ j - 1 ] ; } for ( i = 0 ; i <= N ; i ++ ) { for ( j = 1 ; j <= M ; j ++ ) { P1E [ i ] [ j ] = Math . max ( P1E [ i + 1 ] [ j ] , P1S [ i ] [ j + 1 ] ) + A [ i - 1 ] [ j - 1 ] ; } } for ( i = 1 ; i <= N ; i ++ ) { for ( j = 0 ; j <= M ; j ++ ) { P2S [ i ] [ j ] = Math . max ( P2S [ i - 1 ] [ j ] , P2S [ i ] [ j + 1 ] ) + A [ i - 1 ] [ j - 1 ] ; } } for ( i = 2 ; i <= N ; i ++ ) { for ( j = 0 ; j <= M ; j ++ ) { P2E [ i ] [ j ] = Math . max ( P2E [ i - 1 ] [ j ] , P2E [ i ] [ j + 1 ] ) + A [ i - 1 ] [ j - 1 ] ) ; } } } return ans ; }
static int KnapSack ( int val [ ] , int wt [ ] , int n , int W ) { int mat [ ] [ ] = new int [ W ] [ n + 1 ] ; for ( int i = 0 ; i < W ; i ++ ) { mat [ i ] [ 0 ] = val [ i ] + mat [ 0 ] [ j - wt [ i ] ] ; for ( int j = 0 ; j < W ; j ++ ) { if ( wt [ i ] <= j ) { mat [ 1 ] [ j ] = Math . max ( val [ i ] + mat [ 0 ] [ j - wt [ i ] ] , mat [ 0 ] [ j ] ) ; else { mat [ 1 ] [ j ] = mat [ 1 ] [ j ] ; } } } if ( i % 2 == 0 ) { return mat [ 0 ] [ W ] ; } else { mat [ 0 ] [ j ] = mat [ 1 ] [ j ] ; } } } return mat [ 1 ] [ W ] ; }
static boolean isHeap ( int arr [ ] , int n ) { for ( int i = 0 ; i < ( n - 2 ) / 2 ; i ++ ) { if ( arr [ 2 * i + 1 ] > arr [ i ] ) return false ; if ( 2 * i + 2 < n && arr [ 2 * i + 2 ] > arr [ i ] ) return false ; } return true ; }
static void maxProduct ( int arr [ ] , int n ) { if ( n < 2 ) System . out . println ( " No ▁ pairs ▁ exists " ) ; if ( n == 2 ) System . out . println ( arr [ 0 ] + " ▁ " + arr [ 1 ] ) ; return ; } int posa = 0 , posb = 0 , nega = 0 , negb = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > posa ) { posb = posa ; posa = arr [ i ] ; } else if ( arr [ i ] > posb ) { posb = posb ; nega = arr [ i ] ; } else if ( arr [ i ] < 0 && abs ( arr [ i ] > nega ) { negb = nega ; nega = arr [ i ] ; } } if ( nega * negb > posa * posb ) System . out . println ( " Max ▁ product ▁ pair ▁ is ▁ " + nega + " , ▁ " + negb + " } " ) ; }
static int superSeq ( int X [ ] , int Y [ ] , int m , int n ) { int dp [ ] [ ] = new int [ m + 2 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( ! i ) dp [ i ] [ j ] = j ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) { dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; } else { dp [ i ] [ j ] = 1 + Math . min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) ; } } } return dp [ m ] [ n ] ; }
static int minJumps ( int arr [ ] , int n ) { int [ ] jumps = new int [ n ] ; for ( int i = 0 ; i < n - 2 ; i -- ) { if ( arr [ i ] == 0 ) jumps [ i ] = Integer . MIN_VALUE ; else if ( arr [ i ] >= n - i - 1 ) jumps [ i ] = 1 ; else { int min = Integer . MIN_VALUE ; for ( int j = i + 1 ; j <= n ; j ++ ) { if ( j <= arr [ i ] + i ) { if ( min > jumps [ j ] ) { min = jumps [ j ] ; } } } if ( min != Integer . MIN_VALUE ) jumps [ i ] = min + 1 ; else jumps [ i ] = min ; } } return jumps [ 0 ] ; }
static int minAdjustmentCost ( int A [ ] , int n , int M , int target ) { int dp [ ] [ ] = new int [ M + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= M ; i ++ ) { dp [ 0 ] [ i ] = Math . abs ( j - A [ 0 ] ) ; } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= M ; j ++ ) { dp [ i ] [ j ] = 10000000 ; for ( int k = Math . max ( j - target , 0 ) , Math . min ( M , j + target ) + 1 ) ; dp [ i ] [ j ] = Math . min ( dp [ i ] [ j ] , dp [ i - 1 ] [ k ] + Math . abs ( A [ i ] - j ) ) ; } } int res = 10000000 ; for ( int j = 0 ; j <= M ; j ++ ) res = Math . min ( res , dp [ n - 1 ] [ j ] ) ; return res ; }
static int kthSmallest ( int arr [ ] , int n , int k ) { Arrays . sort ( arr ) ; return arr [ k - 1 ] ; }
public static int lis ( int arr [ ] ) { int n = arr . length ; int maximum = 1 ; _lis ( arr , n ) ; return maximum ; }
static int minCoins ( int [ ] coins , int m , int V ) { if ( V == 0 ) return 0 ; int res = Integer . MAX_VALUE ; for ( int i = 0 ; i < m ; i ++ ) { if ( coins [ i ] <= V ) { int sub_res = minCoins ( coins , m , V - coins [ i ] ) ; if ( sub_res != Integer . MAX_VALUE && sub_res + 1 < res ) res = sub_res + 1 ; } } return res ; }
static int minimum_cost ( int a [ ] , int n ) { int mn = Integer . MAX_VALUE ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { mn = Math . min ( a [ i ] , mn ) ; sum += a [ i ] ; } return mn * ( sum - mn ) ; }
static double getArea ( int a ) { double area = ( Math . pi * a * a ) / 4 ; return area ; }
static int evenFibSum ( int limit ) { if ( limit < 2 ) return 0 ; int ef1 = 0 , ef2 = 2 ; int sm = 0 ; for ( ef2 = 2 ; ef2 <= limit ; ef2 ++ ) { int ef3 = 4 * ef2 + ef1 ; if ( ef3 > limit ) break ; ef1 = ef2 ; ef2 = ef3 ; sm = sm + ef2 ; } return sm ; }
static int findSubArray ( int arr [ ] , int n ) { int sum = 0 , maxsize = - 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { sum = sum + ( - 1 ) if ( arr [ i ] == 0 ) else sum + 1 ; for ( int j = i + 1 ; j < n ; j ++ ) { sum = sum + ( - 1 ) if ( arr [ j ] == 0 ) else sum + 1 ; if ( sum == 0 && maxsize < j - i + 1 ) { maxsize = j - i + 1 ; startindex = i ; } } } if ( maxsize == - 1 ) System . out . println ( " No ▁ such ▁ subarray " ) ; else System . out . println ( startindex + " to " + maxsize - 1 ) ; } return maxsize ; }
static int largestSumOfAverages ( int A [ ] , int K ) { int n = A . length ; int [ ] pre_sum = new int [ n ] ; pre_sum [ 0 ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) pre_sum [ i + 1 ] = A [ i ] ; int dp [ ] = new int [ n ] ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] = ( pre_sum [ n ] - pre_sum [ i ] ) / ( n - i ) ; } for ( int k = 0 ; k < K - 1 ; k ++ ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { dp [ i ] = Math . max ( dp [ i ] , ( pre_sum [ j ] - pre_sum [ i ] ) / ( j - i ) + dp [ j ] ) ; } } } return int ( dp [ 0 ] ) ; }
static int getMinSteps ( int n ) { int table [ ] = new int [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) table [ i ] = n - i ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! ( i % 2 ) ) table [ i / 2 ] = Math . min ( table [ i ] + 1 , table [ i / 2 ] ) ; if ( ! ( i % 3 ) ) table [ i / 3 ] = Math . min ( table [ i ] + 1 , table [ i / 3 ] ) ; } return table [ 1 ] ; }
static int eggDrop ( int n , int k ) { if ( k == 1 || k == 0 ) return k ; if ( n == 1 ) return k ; for ( int x = 1 ; x <= k ; x ++ ) { int res = Math . max ( eggDrop ( n - 1 , x - 1 ) , eggDrop ( n , k - x ) ) ; if ( res < min ) { min = res ; } } return min + 1 ; }
static int count ( String s , char c ) { int res = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == c ) res ++ ; } return res ; }
static int findLength ( String str , int n ) { int [ ] sum = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) sum [ i ] = str . charAt ( i - 1 ) ) ; int ans = 0 ; for ( int length = 2 ; length <= n ; length ++ ) { for ( int i = 0 ; i <= n - length ; i ++ ) { int j = i + length - 1 ; if ( sum [ i + length / 2 ] - sum [ i ] == sum [ i + length ] - sum [ i + length / 2 ] ) ans = Math . max ( ans , length ) ; } } return ans ; }
static int maximumNumberDistinctPrimeRange ( int m , int n ) { int [ ] factorCount = new int [ m ] ; boolean [ ] prime = new boolean [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { factorCount [ i ] = 0 ; prime [ i ] = true ; } for ( int i = 2 ; i <= n ; i ++ ) { if ( prime [ i ] == true ) factorCount [ i ] = 1 ; for ( int j = i * 2 ; j <= n + 1 ; j ++ ) { factorCount [ j ] ++ ; prime [ j ] = false ; } } int max = factorCount [ m ] ; int num = m ; for ( int i = 0 ; i <= m ; i ++ ) { if ( factorCount [ i ] > max ) max = factorCount [ i ] ; num = i ; } } return num ; }
static int catalan ( int n ) { if ( n <= 1 ) return 1 ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) res += catalan ( i ) * catalan ( n - i - 1 ) ; return res ; }
static int minRevolutions ( int r , int x1 , int y1 , int x2 , int y2 ) { double d = ( Math . sqrt ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ) ; return ( int ) ( Math . ceil ( d / ( 2 * r ) ) ; }
static int largestKSubmatrix ( int a [ ] [ ] ) { int dp [ ] [ ] = new int [ Row ] [ Col ] ; int result = 0 ; for ( int i = 0 ; i < Row ; i ++ ) { for ( int j = 0 ; j < Col ; j ++ ) { if ( i == 0 || j == 0 ) { dp [ i ] [ j ] = 1 ; } else { if ( a [ i ] [ j ] == a [ i - 1 ] [ j ] && a [ i ] [ j ] == a [ i ] [ j - 1 ] && a [ i ] [ j ] == a [ i - 1 ] [ j - 1 ] ) dp [ i ] [ j ] = Math . min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) + 1 ; else { dp [ i ] [ j ] = 1 ; } } } return result ; }
static int cassini ( int n ) { return n & 1 ; }
static int waysToArrange ( int N , int K , int k [ ] ) { int C [ ] [ ] = new int [ N + 1 ] [ N + 1 ] ; for ( int i = 0 ; i <= N ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) ; } } int dp [ ] = new int [ K ] [ N + 1 ] ; for ( int i = 0 ; i <= K ; i ++ ) { dp [ i + 1 ] = dp [ i ] * C [ count + k [ i ] - 1 ] + C [ i - 1 ] [ k [ i ] - 1 ] ; count += k [ i ] ; } return dp [ K ] ; }
static void findDimen ( int H , int A ) { if ( H * H < 4 * A ) System . out . println ( " Not ▁ Possible " ) ; return ; } double apb = sqrt ( H * H + 4 * A ) ; double asb = sqrt ( H * H - 4 * A ) ; System . out . println ( " P ▁ = ▁ " + " % .2f " + ( apb - asb ) / 2.0 ) ; System . out . println ( " B ▁ = ▁ " + " % .2f " + ( apb + asb ) / 2.0 ) ; System . out . println ( " B ▁ = ▁ " + " % .2f " + ( apb + asb ) / 2.0 ) ; }
static int maxTripletSum ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; return arr [ n - 1 ] + arr [ n - 2 ] + arr [ n - 3 ] ; }
static int MaxDotProduct ( int A [ ] , int B [ ] , int m , int n ) { int dp [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) dp [ i ] [ 0 ] = 0 ; for ( int j = i ; j <= n ; j ++ ) dp [ i ] [ j ] = Math . max ( ( dp [ i - 1 ] [ j - 1 ] + ( A [ j - 1 ] * B [ i - 1 ] ) ) , dp [ i ] [ j - 1 ] ) ; return dp [ n ] [ m ] ; }
static int findMinDiff ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int diff = Integer . MAX_VALUE ; for ( int i = 0 ; i <= n - 1 ; i ++ ) { if ( arr [ i + 1 ] - arr [ i ] < diff ) diff = arr [ i + 1 ] - arr [ i ] ; } return diff ; }
static int findLastIndex ( String str , char x ) { for ( int i = str . length ( ) - 1 ; i >= 0 ; i -- ) if ( str . charAt ( i ) == x ) return i ; return - 1 ; }
static int maxLower ( String str ) { int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( str . charAt ( i ) >= ' A ' && str . charAt ( i ) <= ' Z ' ) break ; int maxCount = 0 ; int [ ] count = new int [ MAX_CHAR ] ; for ( int j = 0 ; j < MAX_CHAR ; j ++ ) { count . add ( 0 ) ; } for ( int j = i ; j < n ; j ++ ) { if ( str . charAt ( j ) >= ' A ' && str . charAt ( j ) <= ' Z ' ) { int currCount = 0 ; for ( int k = 0 ; k < MAX_CHAR && count [ k ] > 0 ; k ++ ) { if ( count [ k ] > 0 ) { currCount ++ ; } } maxCount = Math . max ( maxCount , currCount ) ; } } return maxCount ; }
static String evenlength ( String n ) { String res = "" ; for ( int j = n . length ( ) - 1 ; j >= 0 ; j -- ) res += n . charAt ( j ) ; return res ; }
static int maxLen ( int arr [ ] , int n ) { HashMap < Integer , Integer > hash_map = new HashMap < Integer , Integer > ( ) ; int curr_sum = 0 ; int max_len = 0 ; int ending_index = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) arr [ i ] = - 1 ; else arr [ i ] = 1 ; } for ( int i = 0 ; i < n ; i ++ ) { curr_sum = curr_sum + arr [ i ] ; if ( curr_sum == 0 ) max_len = i + 1 ; ending_index = i ; } else { hash_map [ curr_sum ] = i ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == - 1 ) arr [ i ] = 0 ; else arr [ i ] = 1 ; } } return max_len ; }
static double circumference ( int r ) { return 2 * PI * Math . pow ( r , 2 ) ; }
static void printDistinct ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i < n - 1 && arr [ i ] == arr [ i + 1 ] ) break ; else if ( i < n - 1 && arr [ i ] == arr [ i + 1 ] ) System . out . print ( arr [ i ] + " ▁ " ) ; } }
static int search ( int arr [ ] , int n , int x , int k ) { int i ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == x ) return i ; } System . out . println ( " number ▁ is ▁ not ▁ present ! " ) ; return - 1 ; }
static int countStrings ( int n ) { int [ ] a = new int [ n ] ; int [ ] b = new int [ n ] ; a [ 0 ] = b [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { b [ i ] = a [ i - 1 ] + b [ i - 1 ] ; a [ i ] = a [ i - 1 ] ; b [ i ] = a [ i - 1 ] ; } return a [ n - 1 ] + b [ n - 1 ] ; }
static int minSum ( int arr [ ] , int n ) { int dp [ ] = new int [ n ] ; if ( n == 1 ) return arr [ 0 ] ; if ( n == 2 ) return arr [ 1 ] ; if ( n == 3 ) return Math . min ( arr [ 0 ] , Math . min ( arr [ 1 ] , arr [ 2 ] ) ) ; if ( n == 4 ) return Math . min ( arr [ 0 ] , arr [ 1 ] , arr [ 2 ] , arr [ 3 ] ) ; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] = arr [ i ] + Math . min ( dp [ i - 1 ] , dp [ i - 2 ] ) , Math . min ( dp [ i - 3 ] , dp [ i - 4 ] ) ) ; } dp [ 0 ] = arr [ 0 ] ; dp [ 1 ] = arr [ 1 ] ; dp [ 2 ] = arr [ 2 ] ; dp [ 3 ] = arr [ 3 ] ; for ( int i = 4 ; i < n ; i ++ ) { dp [ i ] = arr [ i ] + Math . min ( dp [ i - 1 ] , dp [ i - 2 ] ) , Math . min ( dp [ i - 4 ] , dp [ i - 3 ] ) ) ; } return min ( dp [ n - 1 ] , dp [ n - 2 ] ) , Math . min ( dp [ n - 4 ] , dp [ n - 3 ] ) ) ; }
static String printSequence ( char arr [ ] , String input ) { int n = input . length ( ) ; String output = " " ; for ( int i = 0 ; i < n ; i ++ ) { if ( input . charAt ( i ) == ' ▁ ' ) output = output + "0" ; else { int position = ( input . charAt ( i ) ) - ' A ' ; output = output + arr [ position ] ; } } return output ; }
static int maxcoefficientvalue ( int n ) { int C [ ] [ ] = new int [ n ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= i ; j ++ ) { if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) ; } } int maxvalue = 0 ; for ( int i = 0 ; i <= n ; i ++ ) maxvalue = Math . max ( maxvalue , C [ n ] [ i ] ) ; return maxvalue ; }
static int gcd ( int a , int b ) { if ( a < b ) return gcd ( b , a ) ; if ( Math . abs ( b ) < 0.001 ) return a ; else if ( Math . abs ( b ) < 0.001 ) return a ; else return ( gcd ( b , a - Math . floor ( a / b ) * b ) ) ; }
static String sortByPattern ( String str , String pat ) { int [ ] count = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { count [ str . charAt ( i ) - 97 ] ++ ; } int index = 0 ; String str = " " ; for ( int i = 0 ; i < pat . length ( ) ; i ++ ) { int j ; for ( j = 0 ; j < count [ pat . charAt ( i ) - ' a ' ] ; j ++ ) { str += pat . charAt ( i ) ; } } return str ; }
static int minJumps ( int arr [ ] , int n ) { int [ ] jumps = new int [ n ] ; if ( n == 0 ) return Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { jumps [ i ] = Integer . MIN_VALUE ; for ( int j = 0 ; j < i ; j ++ ) { if ( i <= j + arr [ j ] ) && ( jumps [ j ] != Integer . MIN_VALUE ) ) { jumps [ i ] = Math . min ( jumps [ i ] , jumps [ j ] + 1 ) ; break ; } } return jumps [ n - 1 ] ; }
static int find_prob ( int n , int P ) { int dp [ ] = new int [ n + 1 ] ; dp [ 0 ] = 1 ; dp [ 1 ] = 0 ; dp [ 2 ] = P ; dp [ 3 ] = 1 - P ; for ( int i = 4 ; i <= N ; i ++ ) dp [ i ] = ( P ) * dp [ i - 2 ] + ( 1 - P ) * dp [ i - 3 ] ; return dp [ N ] ; }
static int countStrings ( int n ) { int [ ] a = new int [ n ] ; int [ ] b = new int [ n ] ; a [ 0 ] = b [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) a [ i ] = a [ i - 1 ] + b [ i - 1 ] ; b [ i ] = a [ i - 1 ] ; return ( 1 << n ) - a [ n - 1 ] - b [ n - 1 ] ; }
static int maximumSegments ( int n , int a , int b , int c ) { int dp [ ] = new int [ n + 10 ] ; dp [ 0 ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( dp [ i ] != - 1 ) { if ( i + a <= n ) dp [ i + a ] = Math . max ( dp [ i ] + 1 , dp [ i + a ] ) ; if ( i + b <= n ) dp [ i + b ] = Math . max ( dp [ i ] + 1 , dp [ i + b ] ) ; if ( i + c <= n ) dp [ i + c ] = Math . max ( dp [ i ] + 1 , dp [ i + c ] ) ; } } return dp [ n ] ; }
static int countWords ( String str , int l ) { int count = 1 ; if ( l == 1 ) return count ; if ( str . length ( ) == 1 ) return count ; for ( int j = 1 ; j <= l - 1 ; j ++ ) { if ( str . charAt ( j ) == str . charAt ( j - 1 ) && str . charAt ( j ) == str . charAt ( j + 1 ) ) count *= 1 ; else if ( str . charAt ( j ) == str . charAt ( j - 1 ) || str . charAt ( j ) == str . charAt ( j + 1 ) || str . charAt ( j - 1 ) == str . charAt ( j + 1 ) || str . charAt ( j - 1 ) == str . charAt ( j + 1 ) ) count *= 2 ; else count *= 3 ; } } if ( str . length ( ) > l - 2 ) count *= 1 ; else count *= 2 ; } return count ; }
static int findMinDiff ( int arr [ ] , int n ) { int diff = Integer . MAX_VALUE ; for ( int i = 0 ; i <= n - 2 ; i ++ ) { for ( int j = i + 1 ; j <= n ; j ++ ) { if ( Math . abs ( arr [ i ] - arr [ j ] ) < diff ) diff = Math . abs ( arr [ i ] - arr [ j ] ) ; } } return diff ; }
static int maxSum ( int arr [ ] , int n ) { int res = - Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { int curr_sum = 0 ; for ( int j = 0 ; j < n ; j ++ ) { int index = ( i + j ) % n ; curr_sum += j * arr [ index ] ; } res = Math . max ( res , curr_sum ) ; } return res ; }
public static double volumeOfEllipsoid ( double r1 , double r2 , double r3 ) { return 1.33 * Math . pi * r1 * r2 * r3 ; }
static int lcsOf3 ( int X [ ] , int Y [ ] , int Z [ ] , int m , int n , int o ) { int L [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { for ( int k = 0 ; k <= o ; k ++ ) { if ( i == 0 || j == 0 || k == 0 ) L [ i ] [ j ] [ k ] = 0 ; else { L [ i ] [ j ] [ k ] = L [ i - 1 ] [ j - 1 ] [ k - 1 ] + 1 ; } } } return L [ m ] [ n ] [ o ] ; }
static int countEndless ( int input_mat [ ] [ ] , int n ) { int row [ ] [ ] = new int [ n ] [ n ] ; int [ ] col = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { isEndless = 1 ; for ( int j = n - 1 ; j >= 0 ; j -- ) { if ( input_mat [ i ] [ j ] == 0 ) { isEndless = 0 ; } col [ i ] [ j ] = isEndless ; } } for ( int i = 0 ; i < n ; i ++ ) { isEndless = 1 ; for ( int j = n - 1 ; j >= 0 ; j -- ) { if ( input_mat [ i ] [ j ] == 0 ) { isEndless = 0 ; row [ i ] [ j ] = isEndless ; } } } int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) { if ( row [ i ] [ j ] && col [ i ] [ j ] ) ans ++ ; } } return ans ; }
static void NextFit ( int blockSize [ ] , int m , int processSize [ ] , int n ) { int [ ] allocation = new int [ n ] ; int j = 0 ; for ( int i = 0 ; i < n ; i ++ ) { allocation [ i ] = - 1 ; j = 0 ; while ( j < m ) { if ( blockSize [ j ] >= processSize [ i ] ) { allocation [ i ] = j ; blockSize [ j ] -= processSize [ i ] ; break ; } j ++ ; } } System . out . println ( " Process ▁ No . ▁ Process ▁ Size ▁ Block ▁ no . " ) ; for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( i + 1 + " ▁ ▁ ▁ ▁ ▁ " + processSize [ i ] + " ▁ " ) ; if ( allocation [ i ] != - 1 ) System . out . println ( allocation [ i ] + 1 ) ; else System . out . println ( " Not ▁ Allocated " ) ; } }
static int lenOfLongestGP ( int [ ] sett , int n ) { if ( n < 2 ) return n ; if ( n == 2 ) return ( sett [ 1 ] % sett [ 0 ] == 0 ) ; int [ ] L = new int [ n ] [ n ] ; int llgp = 1 ; for ( int i = 0 ; i < n ; i ++ ) { L [ i ] [ n - 1 ] = 2 ; } else { L [ i ] [ n - 1 ] = 1 ; } } for ( int j = n - 2 ; for ( int i = 0 , k = j + 1 ; i >= 0 && k <= n - 1 ; i -- ) { if ( sett [ i ] * sett [ k ] < sett [ j ] * sett [ j ] ) { k ++ ; } else { L [ i ] [ j ] = L [ j ] [ k ] + 1 ; if ( L [ i ] [ j ] > llgp ) { llgp = L [ i ] [ j ] ; } i -- ; } } return llgp ; }
static boolean checkValidity ( int a , int b , int c ) { if ( ( a + b <= c ) || ( a + c <= b ) || ( b + c <= a ) ) return false ; else return true ; }
static boolean isDDM ( int m [ ] [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + Math . abs ( m [ i ] [ j ] ) ; sum = sum - Math . abs ( m [ i ] [ i ] ) ; if ( Math . abs ( m [ i ] [ i ] ) < sum ) return false ; } return true ; }
static int shortestDist ( int graph [ ] [ ] ) { int dist [ ] = new int [ N ] ; dist [ N - 1 ] = 0 ; for ( int i = N - 2 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < N ; j ++ ) { if ( graph [ i ] [ j ] == INF ) continue ; dist [ i ] = Math . min ( dist [ i ] , graph [ i ] [ j ] + dist [ j ] ) ; } } return dist [ 0 ] ; }
static int calculateSum ( int n ) { int sum = 0 ; sum = 1 << n ; return ( sum - 1 ) ; }
static int kthdigit ( int a , int b , int k ) { int p = a ** b ; int count = 0 ; while ( p > 0 && count < k ) { int rem = p % 10 ; count ++ ; if ( count == k ) return rem ; p = p / 10 ; } return 0 ; }
static boolean isEven ( int n ) { return ( n & 1 ) == 0 ; }
static void printPath ( String str ) { int i = 0 ; int curX = 0 , curY = 0 ; while ( i < str . length ( ) ) { i ++ ; int nextX = ( str . charAt ( i ) - ' A ' ) / 5 ; int nextY = ( str . charAt ( i ) - ' B ' ) + 1 ) % 5 ; while ( curX > nextX ) { System . out . print ( " Move ▁ Up " ) ; curX -- ; } while ( curY > nextY ) { System . out . print ( " Move ▁ Left " ) ; curY -- ; } while ( curX < nextX ) { System . out . print ( " Move ▁ Down " ) ; curX ++ ; } while ( curY < nextY ) { System . out . print ( " Move ▁ Right " ) ; curY ++ ; } System . out . println ( " Press ▁ OK " ) ; } }
static boolean checkcircle ( int r , int R , int r1 , int x1 , int y1 ) { int dis = ( Math . sqrt ( x1 * x1 + y1 * y1 ) ) ; return ( dis - r1 >= R && dis + r1 <= r ) ; }
static boolean isMinHeap ( int level [ ] , int n ) { for ( int i = n / 2 ; i >= 0 ; i -- ) { if ( level [ i ] > level [ 2 * i + 1 ] ) return false ; if ( 2 * i + 2 < n ) { if ( level [ i ] > level [ 2 * i + 2 ] ) return false ; } } return true ; }
static int countSetBits ( int n ) { int i = 0 ; int ans = 0 ; while ( ( 1 << i ) <= n ) { int k = 0 ; int change = 1 << i ; for ( int j = 0 ; j <= n ; j ++ ) { ans += k ; if ( change == 1 ) { k = ! k ; change = 1 << i ; } else { change -- ; } } return ans ; }
static int getPairsCount ( int arr [ ] , int n , int sum ) { int m [ ] = new int [ 1000 ] ; for ( int i = 0 ; i < n ; i ++ ) m [ arr [ i ] ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) { int twice_count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { twice_count += m [ sum - arr [ i ] ] ; if ( sum - arr [ i ] == arr [ i ] ) twice_count -- ; } return ( twice_count / 2 ) ; }
static void printSorted ( int a , int b , int c ) { int get_max = Math . max ( a , Math . max ( b , c ) ) ; int get_min = Math . max ( - a , Math . max ( - b , - c ) ) ; int get_mid = ( a + b + c ) - ( get_max + get_min ) ; System . out . println ( get_min + " ▁ " + get_mid + " ▁ " + get_max ) ; }
static boolean isDivisible ( int n ) { while ( n / 100 != 0 ) n = n / 10 ; n += last_digit * 3 ; return ( n % 29 == 0 ) ; }
static int minSumPath ( int A [ ] [ ] ) { int [ ] memo = new int [ A . length ] ; int n = A . length - 1 ; for ( int i = 0 ; i < A [ n ] . length ( ) ; i ++ ) memo [ i ] = A [ n ] . get ( i ) ; for ( int i = 0 ; i < A . length ( ) - 2 ; i ++ ) { for ( int j = 0 ; j < A . length ( ) ; j ++ ) { memo [ j ] = A [ i ] [ j ] + Math . min ( memo [ j ] , memo [ j + 1 ] ) ; } } return memo [ 0 ] ; }
static int minXOR ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int minXor = Integer . MAX_VALUE ; int val = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { val = arr [ i ] ^ arr [ i + 1 ] ; minXor = Math . min ( minXor , val ) ; } return minXor ; }
static void luDecomposition ( int mat [ ] [ ] , int n ) { int lower [ ] [ ] = new int [ n ] [ n ] ; int upper [ ] [ ] = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { lower [ i ] [ 0 ] = mat [ i ] [ 0 ] ; upper [ i ] [ 0 ] = mat [ i ] [ 0 ] - sum ; } for ( int k = 0 ; k < n ; k ++ ) { int sum = 0 ; for ( int j = 0 ; j < i ; j ++ ) { sum += ( lower [ i ] [ j ] * upper [ j ] [ k ] ) ; upper [ i ] [ k ] = mat [ i ] [ k ] - sum ; } } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { sum += ( lower [ k ] [ j ] * upper [ j ] [ i ] ) ; lower [ k ] [ i ] = 1 ; } } System . out . println ( " Lower ▁ Triangular\t\tUpper ▁ Triangular " ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { System . out . print ( lower [ i ] [ j ] + " \t " ) ; } System . out . println ( ) ; } }
static int findMinSum ( int a [ ] , int b [ ] , int n ) { Arrays . sort ( a ) ; Arrays . sort ( b ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += Math . abs ( a [ i ] - b [ i ] ) ; return sum ; }
static int minDist ( int arr [ ] , int n , int x , int y ) { int min_dist = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( x == arr [ i ] && y == arr [ j ] || y == arr [ i ] && x == arr [ j ] ) min_dist = Math . abs ( i - j ) ; } } return min_dist ; }
static void findSymPairs ( int arr [ ] [ ] , int row ) { HashMap < Integer , Integer > hM = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < row ; i ++ ) { int first = arr [ i ] [ 0 ] ; int sec = arr [ i ] [ 1 ] ; if ( sec in hM . keySet ( ) && hM . get ( sec ) == first ) System . out . print ( " ( " + sec + " , " + first + " ) " ) ; else hM [ first ] = sec ; } }
static boolean isValidString ( String str ) { int freq [ ] = new int [ CHARS ] ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { freq [ str . charAt ( i ) - ' a ' ] ++ ; } int freq1 = 0 , count_freq1 = 0 , count_freq2 = 0 ; for ( int i = 0 ; i < CHARS ; i ++ ) { if ( freq [ i ] != 0 ) { if ( freq [ j ] == freq1 ) count_freq1 ++ ; else count_freq2 = 1 ; freq2 = freq [ j ] ; break ; } } for ( int k = j + 1 ; k < CHARS ; k ++ ) { if ( freq [ k ] != 0 ) { if ( freq [ k ] == freq1 ) count_freq1 ++ ; if ( freq [ k ] == freq2 ) count_freq2 ++ ; } else { return false ; } } } if ( count_freq1 > 1 && count_freq2 > 1 ) return false ; } return true ; }
static void maximizecube ( int l , int b , int h ) { int side = gcd ( l , gcd ( b , h ) ) ; int num = l / side ; num = num * b / side ; num = num * h / side ; System . out . println ( side , num ) ; }
static void rotate ( ) { int x = arr [ n - 1 ] ; for ( int i = n - 1 ; i >= 0 ; i -- ) arr [ i ] = arr [ i - 1 ] ; arr [ 0 ] = x ; }
static void bonacciseries ( int n , int m ) { int [ ] a = new int [ m ] ; a [ n - 1 ] = 1 ; a [ n ] = 1 ; for ( int i = n ; i < m ; i ++ ) a [ i ] = 2 * a [ i - 1 ] - a [ i - n - 1 ] ; for ( int i = 0 ; i < m ; i ++ ) System . out . print ( a [ i ] + " ▁ " ) ; }
static int findoptimal ( int N ) { if ( N <= 6 ) return N ; int [ ] screen = new int [ N ] ; for ( int n = 1 ; n <= 7 ; n ++ ) screen [ n - 1 ] = n ; for ( int n = 7 ; n <= N ; n ++ ) { screen [ n - 1 ] = n ; } for ( int n = N + 1 ; n <= N ; n ++ ) { screen [ n - 1 ] = Math . max ( 2 * screen [ n - 4 ] , Math . max ( 3 * screen [ n - 5 ] , 4 * screen [ n - 6 ] ) ) ; } return screen [ N - 1 ] ; }
static int fib ( int n ) { if ( n < 6 ) return f [ n ] ; int t = 5 , fn = 5 ; while ( t < n ) fn = round ( fn * PHI ) ; t ++ ; return fn ; }
static int countWays ( int arr [ ] , int m , int N ) { int [ ] count = new int [ m ] ; count [ 0 ] = 1 ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) if ( i >= arr [ j ] ) count [ i ] += count [ i - arr [ j ] ] ; } return count [ N ] ; }
static double sumOfSeries ( int n ) { return ( 0.666 ) * ( 1 - 1 / pow ( 10 , n ) ) ; }
static void findDivision ( String str , int a , int b ) { int len = str . length ( ) ; int lr [ ] = new int [ len ] ; lr [ 0 ] = ( int ) str . charAt ( 0 ) ) % a ; for ( int i = 1 ; i < len ; i ++ ) { lr [ i ] = ( lr [ i - 1 ] * 10 ) % a + \ int . valueOf ( str . charAt ( i ) ) % a ; } int power10 = ( int ) ( b ) ; for ( int i = 0 ; i < lenn - 2 ; i -- ) { rl [ i ] = ( rl [ i + 1 ] + str . charAt ( i ) ) * power10 ; power10 = ( power10 * 10 ) % b ; } for ( int i = 0 ; i <= lenn - 1 ; i -- ) { if ( lr [ i ] != 0 ) { continue ; } if ( rl [ i + 1 ] == 0 ) System . out . print ( " YES " ) ; for ( int k = 0 ; k <= i ; k ++ ) System . out . print ( str . charAt ( k ) + " ▁ " ) ; for ( int i = i + 1 ; i <= len ; i ++ ) System . out . print ( str . charAt ( k ) + " ▁ " ) ; } System . out . println ( ) ; }
static int count ( char a [ ] , char b [ ] ) { int m = a . length , n = b . length ; int [ ] [ ] lookup = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { lookup [ i ] [ 0 ] = 0 ; } for ( int i = 0 ; i <= n ; i ++ ) { lookup [ 0 ] [ i ] = 1 ; } for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( a [ i - 1 ] == b [ j - 1 ] ) lookup [ i ] [ j ] = lookup [ i - 1 ] [ j - 1 ] + lookup [ i - 1 ] [ j ] ; } } return lookup [ m ] [ n ] ; }
static int find_extra_element_index ( int arrA [ ] , int arrB [ ] ) { int extra_element = sum ( arrA ) - sum ( arrB ) ; return arrA . index ( extra_element ) ; }
static int sumNodes ( int l ) { double leafNodeCount = Math . pow ( 2 , l - 1 ) ; int sumLastLevel = 0 ; sumLastLevel = ( leafNodeCount * ( leafNodeCount + 1 ) ) / 2 ; int sum = sumLastLevel * l ; return sum ; }
boolean check ( int degree [ ] , int n ) { int deg_sum = sum ( degree ) ; if ( 2 * ( n - 1 ) == deg_sum ) return true ; else return false ; }
static int findCount ( int n , int sum ) { long start = Math . pow ( 10 , n - 1 ) ; long end = Math . pow ( 10 , n ) - 1 ; int count = 0 ; for ( int i = start ; i <= end ; i ++ ) { int cur = 0 ; int temp = i ; while ( temp != 0 ) { cur += temp % 10 ; temp = temp / 10 ; } if ( cur == sum ) count ++ ; i ++ ; } System . out . println ( count ) ; }
static int smallest ( int x , int y , int z ) { int c = 0 ; while ( x && y && z ) { x = x - 1 ; y = y - 1 ; z = z - 1 ; c ++ ; } return c ; }
static int longLenSub ( int arr [ ] , int n ) { HashMap < Integer , Integer > um = new HashMap < Integer , Integer > ( ) ; int longLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int len1 = 0 ; if ( arr [ i - 1 ] in um && len1 < um [ arr [ i ] - 1 ] ) { len1 = um [ arr [ i ] - 1 ] ; } if ( arr [ i ] + 1 in um && len1 < um [ arr [ i ] + 1 ] ) { len1 = um [ arr [ i ] + 1 ] ; } um [ arr [ i ] ] = len1 + 1 ; if ( longLen < um [ arr [ i ] ] ) { longLen = um [ arr [ i ] ] ; } } return longLen ; }
static int minOperation ( int arr [ ] [ ] ) { int ans = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { for ( int j = M - 1 ; j >= 0 ; j -- ) { if ( arr [ i ] [ j ] == 0 ) ans ++ ; for ( int k = i + 1 ; k <= j ; k ++ ) { for ( int h = j + 1 ; h <= N ; h ++ ) { if ( arr [ k ] [ h ] == 1 ) arr [ k ] [ h ] = 0 ; else arr [ k ] [ h ] = 1 ; } } } return ans ; }
static int nextPowerOf2 ( int n ) { int p = 1 ; if ( n && ! ( n & ( n - 1 ) ) ) return n ; while ( p < n ) p <<= 1 ; return p ; }
static int numberofways ( int n , int m ) { int dp [ ] [ ] = new int [ n + 2 ] [ n + 2 ] ; dp [ 0 ] [ n + 1 ] = 1 ; for ( int k = n ; k <= m - 1 ; k -- ) { for ( int i = n ; i <= n ; i ++ ) { dp [ i ] [ k ] = dp [ i ] [ k + 1 ] ; if ( i - k >= 0 ) { dp [ i ] [ k ] = ( dp [ i ] [ k ] + dp [ i - k ] [ k ] ) ; } } return dp [ n ] [ m ] ; }
static void generate_derangement ( int N ) { int [ ] S = new int [ N + 1 ] ; for ( int i = 0 ; i <= N ; i ++ ) S [ i ] = i ; int D [ ] = new int [ N + 1 ] ; for ( int i = 1 ; i <= N ; i ++ ) D [ i ] = S [ i ] ; for ( int i = 1 ; i <= N ; i ++ ) { if ( i == N ) D [ N ] = S [ N - 1 ] ; else D [ i + 1 ] = i ; } } for ( int i = 1 ; i <= N ; i ++ ) System . out . print ( D [ i ] + " ▁ " ) ; System . out . println ( ) ; }
static int countTriangle ( int g [ ] [ ] , boolean isDirected ) { int nodes = g . length ; int count_Triangle = 0 ; for ( int i = 0 ; i < nodes ; i ++ ) { for ( int j = 0 ; j < nodes ; j ++ ) { for ( int k = 0 ; k < nodes ; k ++ ) { if ( i != j && j != k && g [ i ] [ j ] && g [ j ] [ k ] && g [ k ] [ i ] ) count_Triangle ++ ; } } } return count_Triangle / 3 if ( isDirected else count_Triangle / 6 ; }
static int leonardo ( int n ) { if ( n == 0 || n == 1 ) return 1 ; return leonardo ( n - 1 ) + leonardo ( n - 2 ) + 1 ; }
static int findLargestPlus ( int mat [ ] [ ] ) { int left [ ] [ ] = new int [ N ] [ N ] ; int right [ ] [ ] = new int [ N ] [ N ] ; int bottom [ ] [ ] = new int [ N ] [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { top [ 0 ] [ i ] = mat [ 0 ] [ i ] ; bottom [ N - 1 ] [ i ] = mat [ N - 1 ] [ i ] ; for ( int i = 0 ; i < N ; i ++ ) { left [ i ] [ 0 ] = mat [ i ] [ 0 ] ; right [ i ] [ N - 1 ] = mat [ i ] [ N - 1 ] ; } for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 1 ; j < N ; j ++ ) { if ( mat [ i ] [ j ] == 1 ) top [ j ] [ i ] = top [ i ] [ j - 1 ] + 1 ; else top [ i ] [ j ] = 0 ; } if ( mat [ j ] [ i ] == 1 ) top [ j ] [ i ] = top [ j - 1 ] [ i ] + 1 ; else bottom [ j ] [ i ] = 0 ; } } int n = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 1 ; j < N ; j ++ ) { if ( mat [ i ] [ j ] == 1 ) right [ i ] [ j ] = right [ i ] [ j + 1 ] + 1 ; } else right [ i ] [ j ] = 0 ; } } return n ; }
static int sumAtKthLevel ( String tree , int k ) { int level = - 1 ; int sum = 0 ; int n = tree . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( tree . charAt ( i ) == ' ( ' ) level ++ ; else if ( tree . charAt ( i ) == ' ) level -- ; else { if ( level == k ) sum += ( char ) ( tree . charAt ( i ) - ' 0' ) ; } } return sum ; }
static int countWays ( String s ) { int [ ] count = new int [ 26 ] ; for ( int x = 0 ; x < s . length ( ) ; x ++ ) { count [ x - ' a ' ] = ( count [ x - ' a ' ] ) + 1 ; } count [ s . charAt ( 0 ) - ' a ' ] = 1 ; int ans = 1 ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( count [ i ] != 0 ) ans *= count [ i ] ; } return ans ; }
static int countWays ( int n , int m ) { int [ ] count = new int [ n + 2 ] ; for ( int i = 0 ; i <= n ; i ++ ) count . add ( 0 ) ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i > m ) count [ i ] = count [ i - 1 ] + count [ i - m ] ; else if ( i < m ) count [ i ] = 1 ; else count [ i ] = 2 ; } return count [ n ] ; }
static void printCommonElements ( int mat [ ] [ ] ) { Map < Integer , Integer > myMap = new HashMap < > ( ) ; for ( int i = 0 ; i < M ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) myMap [ mat [ 0 ] [ j ] ] = 1 ; } for ( int i = 1 ; i < M ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( myMap . containsKey ( mat [ i ] [ j ] ) && myMap . get ( mat [ i ] [ j ] ) == i ) myMap . put ( mat [ i ] [ j ] , i + 1 ) ; else myMap . put ( mat [ i ] [ j ] , i + 1 ) ; } } }
static int nextPowerOf2 ( int n ) { int p = 1 ; if ( n && ! ( n & ( n - 1 ) ) ) return n ; while ( p < n ) p <<= 1 ; return p ; }
static void longest ( int [ ] a , int n , int k ) { int freq [ ] = new int [ n ] ; int start = 0 , end = 0 , now = 0 , l = 0 ; for ( int i = 0 ; i < n ; i ++ ) { freq [ a [ i ] ] ++ ; if ( freq [ a [ i ] ] == 1 ) now ++ ; while ( now > k ) { freq [ a [ l ] ] -- ; if ( freq [ a [ l ] ] == 0 ) now -- ; l ++ ; } if ( i - l + 1 >= end - start + 1 ) end = i ; start = l ; } }
public static int findWays ( int m , int n , int x ) { int table [ ] [ ] = new int [ n + 1 ] [ x + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= x ; j ++ ) { table [ 1 ] [ j ] = 1 ; } } for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= x ; j ++ ) { for ( int k = 1 ; k <= Math . min ( m + 1 , j ) ; k ++ ) { table [ i ] [ j ] += table [ i - 1 ] [ j - k ] ; } } return table [ - 1 ] [ - 1 ] ; }
static boolean checkCorrectOrNot ( String s ) { int [ ] count = new int [ MAX_CHAR ] ; int n = s . length ( ) ; if ( n == 1 ) return true ; for ( int i = 0 , j = n - 1 ; i < j ; i ++ , j -- ) { count [ s . charAt ( i ) - ' a ' ] ++ ; count [ s . charAt ( j ) - ' a ' ] -- ; i ++ ; j -- ; } for ( int i = 0 ; i < MAX_CHAR && count [ i ] != 0 ; return false ; }
static int findnumberofTriangles ( int arr [ ] ) { int n = arr . length ; Arrays . sort ( arr ) ; int count = 0 ; for ( int i = 0 ; i < n - 2 ; i ++ ) { int k , j ; for ( j = i + 2 ; j < n ; j ++ ) { while ( k < n && arr [ i ] + arr [ j ] > arr [ k ] ) k ++ ; if ( k > j ) count += k - j - 1 ; } } return count ; }
static int countWays ( int n ) { int [ ] A = new int [ n + 1 ] ; int [ ] B = new int [ n + 1 ] ; A [ 0 ] = 1 ; A [ 1 ] = 0 ; B [ 0 ] = 1 ; B [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) A [ i ] = A [ i - 2 ] + 2 * B [ i - 1 ] ; for ( int i = 2 ; i <= n ; i ++ ) B [ i ] = A [ i - 1 ] + B [ i - 2 ] ; return A [ n ] ; }
static int minValue ( int A [ ] , int B [ ] , int n ) { Arrays . sort ( A ) ; Arrays . sort ( B ) ; int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) result += ( A [ i ] * B [ n - i - 1 ] ) ; return result ; }
static boolean isOneFlip ( String str ) { int sum = 0 ; int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) sum += ( str . charAt ( i ) - '0' ) ; return ( sum == n - 1 || sum == 1 ) ; }
static int MatrixChainOrder ( int p [ ] , int i , int j ) { if ( i == j ) return 0 ; int _min = Integer . MAX_VALUE ; for ( int k = 0 ; k < i ; k ++ ) { int count = ( MatrixChainOrder ( p , i , k ) + MatrixChainOrder ( p , k + 1 , j ) + p [ i - 1 ] * p [ k ] * p [ j ] ) ; if ( count < _min ) { _min = count ; } } return _min ; }
static void worstFit ( int blockSize [ ] , int m , int processSize [ ] , int n ) { int [ ] allocation = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { int wstIdx = - 1 ; for ( int j = 0 ; j < m ; j ++ ) { if ( blockSize [ j ] >= processSize [ i ] ) { wstIdx = j ; } else if ( blockSize [ wstIdx ] < blockSize [ j ] ) { wstIdx = j ; } } if ( wstIdx != - 1 ) { allocation [ i ] = wstIdx ; blockSize [ wstIdx ] -= processSize [ i ] ; } } System . out . println ( " Process ▁ No . ▁ Process ▁ Size ▁ Block ▁ no . " ) ; for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( i + 1 + " ▁ ▁ ▁ ▁ ▁ ▁ " + processSize [ i ] + " ▁ " ) ; if ( allocation [ i ] != - 1 ) System . out . println ( allocation [ i ] + 1 ) ; } else { System . out . println ( " Not ▁ Allocated " ) ; } }
static void prefixSum2D ( int a [ ] [ ] ) { int i , j ; int psa [ ] [ ] = new int [ R ] [ C ] ; for ( i = 0 ; i < C ; i ++ ) { psa [ 0 ] [ i ] = a [ 0 ] [ i ] ; } for ( i = 1 ; i < R ; i ++ ) { psa [ 0 ] [ i ] = ( psa [ 0 ] [ i - 1 ] + a [ 0 ] [ i ] ) ; } for ( i = 0 ; i < R ; i ++ ) { i ] [ 0 ] = ( psa [ i - 1 ] [ 0 ] + a [ i ] [ 0 ] ) ; } for ( i = 1 ; i < R ; i ++ ) { for ( j = 1 ; j < C ; j ++ ) { psa [ i ] [ j ] = ( psa [ i - 1 ] [ j ] + psa [ i ] [ j - 1 ] - psa [ i - 1 ] [ j - 1 ] + a [ i ] [ j ] ) ; } } for ( i = 0 ; i < R ; i ++ ) { for ( j = 0 ; j < C ; j ++ ) System . out . print ( psa [ i ] [ j ] + " ▁ " ) ; } System . out . println ( ) ; } }
static boolean isMultipleOf3 ( int n ) { int odd_count = 0 , even_count = 0 ; if ( n < 0 ) n = - n ; if ( n == 0 ) return 1 ; if ( n == 1 ) return 0 ; while ( n ) { if ( n & 1 ) odd_count ++ ; if ( n & 2 ) even_count ++ ; n = n >> 2 ; } return isMultipleOf3 ( Math . abs ( odd_count - even_count ) ) ; }
static int longestSubsequenceCommonSegment ( int k , String s1 [ ] , String s2 [ ] ) { int n = s1 . length ( ) ; int m = s2 . length ( ) ; int cnt [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = i ; j <= m ; j ++ ) { lcs [ i ] [ j ] = Math . max ( lcs [ i - 1 ] [ j ] , lcs [ i ] [ j - 1 ] ) ; if ( s1 [ i - 1 ] == s2 [ j - 1 ] ) cnt [ i ] [ j ] = cnt [ i - 1 ] [ j - 1 ] + 1 ; if ( cnt [ i ] [ j ] >= k ) { for ( int a = k ; a <= cnt [ i ] [ j ] ; a ++ ) { lcs [ i ] [ j ] = Math . max ( lcs [ i ] [ j ] , lcs [ i - a ] [ j - a ] + a ) ; } } } return lcs [ n ] [ m ] ; }
public static int lcsOf3 ( int i , int j , int k ) { if ( i == - 1 || j == - 1 || k == - 1 ) return 0 ; if ( dp [ i ] [ j ] [ k ] != - 1 ) return dp [ i ] [ j ] [ k ] ; if ( X [ i ] == Y [ j ] && Y [ j ] == Z [ k ] ) { dp [ i ] [ j ] [ k ] = 1 + lcsOf3 ( i - 1 , j - 1 , k - 1 ) ; return dp [ i ] [ j ] [ k ] ; } else { dp [ i ] [ j ] [ k ] = Math . max ( lcsOf3 ( i - 1 , j , k ) , lcsOf3 ( i , j - 1 , k ) ) , lcsOf3 ( i , j , k - 1 ) ) ; return dp [ i ] [ j ] [ k ] ; } } return 0 ; }
static void findLarger ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; for ( int i = 0 ; i < n / 2 ; i ++ ) System . out . print ( x [ i ] ) ; }
static int maxProductSubset ( int [ ] a , int n ) { if ( n == 1 ) return a [ 0 ] ; int max_neg = Integer . MIN_VALUE ; int count_neg = 0 , count_zero = 0 , prod = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) count_zero ++ ; continue ; if ( a [ i ] < 0 ) count_neg ++ ; max_neg = Math . max ( max_neg , a [ i ] ) ; prod = prod * a [ i ] ; } if ( count_zero == n ) return 0 ; if ( count_neg & 1 ) { if ( count_neg == 1 && count_zero > 0 && count_zero + count_neg == n ) return 0 ; prod = Math . min ( prod / max_neg ) ; } return prod ; }
static int russianPeasant ( int a , int b ) { int res = 0 ; while ( b > 0 ) { if ( b & 1 ) res ++ ; a = a << 1 ; b = b >> 1 ; } return res ; }
public static int distance ( double lat1 , double lat2 , double lon1 , double lon2 ) { lon1 = radians ( lon1 ) ; lon2 = radians ( lon2 ) ; lat1 = radians ( lat1 ) ; lat2 = radians ( lat2 ) ; dlon = lon2 - lon1 ; dlat = lat2 - lat1 ; a = sin ( dlat / 2 ) ** 2 + cos ( lat1 ) * cos ( lat2 ) * sin ( dlon / 2 ) ** 2 ; c = 2 * asin ( a ) ) ; r = 6371 ; return ( c * r ) ; }
static boolean isPowerOfTwo ( int n ) { if ( n == 0 ) return false ; while ( n != 1 ) { if ( n % 2 != 0 ) return false ; n = n / 2 ; } return true ; }
static void checkPoint ( int radius , int x , int y , int percent , int startAngle ) { int endAngle = 360 / percent + startAngle ; double polarradius = Math . sqrt ( x * x + y * y ) ; double Angle = Math . atan ( y / x ) ; if ( Angle >= startAngle && Angle <= endAngle && polarradius < radius ) System . out . println ( " Point ▁ ( " + x + " , " + y + " ) does ▁ not exist ▁ in ▁ the ▁ circle ▁ sector " ) ; else { System . out . println ( " Point ▁ ( " + x + " , " + y + " ) does ▁ not ▁ exist ▁ in ▁ the ▁ circle ▁ sector " ) ; } }
static int findSum ( int n ) { int arr [ ] [ ] = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) arr [ i ] [ j ] = Math . abs ( i - j ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) sum += arr [ i ] [ j ] ; return sum ; }
static int discreteLogarithm ( int a , int b , int m ) { int n = ( Math . sqrt ( m ) + 1 ) ; int an = 1 ; for ( int i = 0 ; i < n ; i ++ ) an = ( an * a ) % m ; int [ ] value = new int [ m ] ; int cur = an ; for ( int i = 1 ; i <= n ; i ++ ) { if ( value [ cur ] == 0 ) value [ cur ] = i ; } cur = b ; for ( int i = 1 ; i <= n ; i ++ ) { if ( value [ cur ] > 0 ) { ans = value [ cur ] * n - i ; if ( ans < m ) return ans ; } cur = ( cur * a ) % m ; } return - 1 ; }
boolean isPossibleTriangle ( int arr [ ] , int N ) { if ( N < 3 ) return false ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < N - 2 ; i ++ ) if ( arr [ i ] + arr [ i + 1 ] > arr [ i + 2 ] ) return true ; return false ; }
static int numOfIncSubseqOfSizeK ( int arr [ ] , int n , int k ) { int dp [ ] [ ] = new int [ k ] [ n ] ; for ( int i = 0 ; i < k ; i ++ ) { dp [ 0 ] [ i ] = 1 ; } for ( int l = 1 ; l < k ; l ++ ) { for ( int i = 0 ; i < n ; i ++ ) { dp [ l ] [ i ] = 0 ; for ( int i = l ; i < n ; i ++ ) { if ( arr [ j ] < arr [ i ] ) { dp [ l ] [ i ] += dp [ l - 1 ] [ j ] ; } } } int sum = 0 ; for ( int i = 0 ; i < k ; i ++ ) sum += dp [ k - 1 ] [ i ] ; return sum ; }
static int solve ( char X [ ] , char Y [ ] , int l , int r , int k , int dp [ ] [ ] ) { if ( k == 0 ) return 0 ; if ( l < 0 || r < 0 ) return 1000000000 ; if ( dp [ l ] [ r ] [ k ] != - 1 ) return dp [ l ] [ r ] [ k ] ; int cost = ( ( X [ l ] - ' a ' ) ^ ( Y [ r ] - ' a ' ) ) ; dp [ l ] [ r ] [ k ] = Math . min ( [ cost + solve ( X , Y , l - 1 , r - 1 , k - 1 , dp ) , solve ( X , Y , l - 1 , r , k , dp ) ] ) ; return dp [ l ] [ r ] [ k ] ; }
static boolean isSubSequence ( String string1 , String string2 , int m , int n ) { if ( m == 0 ) return true ; if ( n == 0 ) return false ; if ( string1 [ m - 1 ] == string2 [ n - 1 ] ) return isSubSequence ( string1 , string2 , m - 1 , n - 1 ) ; return isSubSequence ( string1 , string2 , m , n - 1 ) ; }
static int minProductSubset ( int [ ] a , int n ) { if ( n == 1 ) return a [ 0 ] ; int max_neg = Integer . MIN_VALUE ; int min_pos = Integer . MIN_VALUE ; int prod = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) continue ; if ( a [ i ] < 0 ) count_neg ++ ; if ( a [ i ] > 0 ) min_pos = Math . min ( min_pos , a [ i ] ) ; if ( a [ i ] < 0 ) max_neg = Math . max ( max_neg , a [ i ] ) ; if ( a [ i ] > 0 ) prod = prod * a [ i ] ; if ( count_zero == n || ( count_neg == 0 && count_zero > 0 ) ) return 0 ; if ( count_neg == 0 ) return min_pos ; if ( count_neg == 0 ) return 0 ; if ( count_neg == 0 ) return min_pos ; if ( count_neg == 0 ) return 0 ; if ( count_neg & 1 ) == 0 && count_neg != 0 ) prod = int ( prod / max_neg ) ; return prod ; }
static int findDigits ( int n ) { if ( n < 0 ) return 0 ; if ( n <= 1 ) return 1 ; int digits = 0 ; for ( int i = 2 ; i <= n ; i ++ ) digits += Math . log10 ( i ) ; return Math . floor ( digits ) + 1 ; }
static void mergeTwoHalf ( int A [ ] , int n ) { Arrays . sort ( A ) ; for ( int i = 0 ; i < n ; i ++ ) mergeTwoHalf ( A , i ) ; }
static int minPerimeter ( int n ) { int l = Math . sqrt ( n ) ; double sq = l * l ; if ( sq == n ) return l * 4 ; else { int row = n / l ; int perimeter = 2 * ( l + row ) ; if ( n % l != 0 ) perimeter += 2 ; return perimeter ; } }
static void possibleOrNot ( double a1 , double a2 , double b1 , double b2 , double c1 , double c2 ) { double dis1 = ( pow ( a1 - a1 , 2 ) + pow ( b2 - a2 , 2 ) ) ; double dis2 = ( pow ( c1 - b1 , 2 ) + pow ( c2 - b2 , 2 ) ) ; if ( dis1 != dis2 ) System . out . print ( " No " ) ; else if ( b1 == ( ( a1 + c1 ) / 2.0 ) && b2 == ( ( a2 + c2 ) / 2.0 ) ) System . out . print ( " No " ) ; else System . out . println ( " Yes " ) ; }
static int CountSquares ( double a , double b ) { return ( Math . floor ( Math . sqrt ( b ) ) - Math . ceil ( Math . sqrt ( a ) ) + 1 ) ; }
static int countStrings ( int n , int k ) { int dp [ ] [ ] [ ] = new int [ k + 1 ] [ n + 1 ] ; dp [ 0 ] [ 0 ] = 1 ; dp [ 0 ] [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= k ; j ++ ) { dp [ i ] [ j ] [ 0 ] = ( dp [ i - 1 ] [ j ] [ 0 ] + dp [ i - 1 ] [ j ] [ 1 ] ) ; dp [ i ] [ j ] [ 1 ] = dp [ i - 1 ] [ j ] [ 1 ] ; } } return dp [ k ] [ 0 ] + dp [ k ] [ 1 ] ; }
static void findSmallestRange ( int arr [ ] [ ] , int n , int k ) { int i , minval , maxval , minrange , minel , maxel ; int [ ] ptr = new int [ k + 1 ] ; for ( i = 0 ; i <= k ; i ++ ) { ptr [ i ] = 0 ; minrange = 10 ** 9 ; while ( 1 ) { minind = - 1 ; minval = 10 ** 9 ; maxval = - 10 ** 9 ; flag = 0 ; for ( i = 0 ; i < k ; i ++ ) { if ( ptr [ i ] == n ) { minind = i ; minval = arr [ i ] [ ptr [ i ] ] ; } if ( ptr [ i ] < n && arr [ i ] [ ptr [ i ] ] < minval ) { minind = i ; minval = arr [ i ] [ ptr [ i ] ] ; } if ( ptr [ i ] < n && arr [ i ] [ ptr [ i ] ] > maxval ) { maxval = arr [ i ] [ ptr [ i ] ] ; } } if ( flag ) { break ; } ptr [ minind ] ++ ; if ( ( maxval - minval ) < minrange ) { minel = minval ; maxel = maxval ; minrange = maxel - minel ; } } System . out . println ( " The ▁ smallest ▁ range ▁ is ▁ [ " + minel + " ] " ) ; }
static void maxelement ( int arr [ ] [ ] ) { int no_of_rows = arr . length ; int no_of_column = arr [ 0 ] . length ; for ( int i = 0 ; i < no_of_rows ; i ++ ) { int max1 = 0 ; for ( int j = 0 ; j < no_of_column ; j ++ ) { if ( arr [ i ] [ j ] > max1 ) { max1 = arr [ i ] [ j ] ; } } System . out . println ( max1 ) ; } }
static int yMod ( double y , int x ) { return ( y % pow ( 2 , x ) ) ; }
static boolean findthepath ( String S , String v ) { int [ ] result = new int [ S . length ( ) ] ; result [ 0 ] = v ; for ( int i = 1 ; i < S . length ( ) ; i ++ ) { if ( adj [ v ] [ S . charAt ( i ) - ' A ' ] || adj [ S . charAt ( i ) - ' A ' ] [ v ] ) { v = S . charAt ( i ) - ' A ' ; } else if ( adj [ v ] [ S . charAt ( i ) - ' A ' ] || adj [ S . charAt ( i ) - ' A ' ] [ v ] ) { v = S . charAt ( i ) - ' A ' ; } else if ( adj [ v ] [ S . charAt ( i ) - ' A ' + 5 ] || adj [ S . charAt ( i ) - ' A ' + 5 ] [ v ] ) { v = S . charAt ( i ) - ' A ' + 5 ] ; } else if ( adj [ v ] [ S . charAt ( i ) - ' A ' ] + 5 ] [ v ] ) { v = S . charAt ( i ) - ' A ' + 5 ; } } return true ; }
static int getMissingNo ( int A [ ] ) { int n = A . length ( ) ; int total = ( n + 1 ) * ( n + 2 ) / 2 ; int sum_of_A = sum ( A ) ; return total - sum_of_A ; }
static void fitOrNotFit ( int R , int r , int x , int y , int rad ) { double val = Math . sqrt ( Math . pow ( x , 2 ) + Math . pow ( y , 2 ) ) ; if ( val + rad <= R && val - rad >= R - r ) System . out . print ( " Fits \n " ) ; else System . out . print ( " Doesn ' t ▁ Fit " ) ; }
static int findPosition ( int k , int n ) { int f1 = 0 , f2 = 1 ; int i = 2 ; for ( i = 0 ; i != 2 ; i ++ ) { int f3 = f1 + f2 ; f1 = f2 ; f2 = f3 ; if ( f2 % k == 0 ) return n * i ; } return Integer . MAX_VALUE ; }
static int countManipulations ( String s1 , String s2 ) { int count = 0 ; int [ ] char_count = new int [ 26 ] ; for ( int i = 0 ; i < 26 ; i ++ ) { char_count [ i ] = 0 ; } for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) { char_count [ s1 . charAt ( i ) - ' a ' ] ++ ; } for ( int i = 0 ; i < s2 . length ( ) ; i ++ ) { char_count [ s2 . charAt ( i ) - ' a ' ] -- ; if ( char_count [ s2 . charAt ( i ) - ' a ' ] < 0 ) count ++ ; } } return count ; }
static int count ( int n ) { int table [ ] = new int [ n + 1 ] ; table [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) table [ i ] += table [ i - 1 ] ; for ( int i = 5 ; i <= n ; i ++ ) table [ i ] += table [ i - 5 ] ; for ( int i = 10 ; i <= n ; i ++ ) table [ i ] += table [ i - 10 ] ; return table [ n ] ; }
static int findLongestRepeatingSubSeq ( String str ) { int n = str . length ( ) ; int dp [ ] [ ] = new int [ n ] [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( str . charAt ( i - 1 ) == str . charAt ( j - 1 ) && i != j ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = Math . max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ; } } return dp [ n ] [ n ] ; }
static int jumpSearch ( int arr [ ] , int x , int n ) { int step = Math . sqrt ( n ) ; int prev = 0 ; while ( arr [ int ( min ( step , n ) - 1 ) ] < x ) { prev = step ; step += Math . sqrt ( n ) ; if ( prev >= n ) return - 1 ; while ( arr [ int ( prev ) ] < x ) { prev ++ ; if ( prev == min ( step , n ) ) return - 1 ; } if ( arr [ int ( prev ) ] == x ) return prev ; } return - 1 ; }
static int find ( int arr [ ] [ ] ) { int n = arr . length ; int res = - 1 ; for ( int i = 0 , j = n - 1 ; i < n ; i ++ ) { if ( arr [ i ] [ j ] == 0 ) break ; else if ( j == - 1 ) res = i ; else { j -- ; } } if ( res == - 1 ) { for ( int i = 0 , j = n - 1 ; i < n ; i ++ ) { while ( j >= 0 && ( arr [ i ] [ j ] == 1 || i == j ) ) i ++ ; if ( i == n ) res = j ; break ; } else { j -- ; } } if ( res != i && arr [ i ] [ res ] != 1 ) return - 1 ; } return res ; }
static void printArray ( int [ ] a , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( i + " ▁ " ) ; System . out . println ( ) ; }
static void sortSquares ( int arr [ ] , int n ) { int i , j , ind ; for ( K = 0 ; K < n ; K ++ ) { if ( arr [ K ] >= 0 ) break ; int temp [ ] = new int [ n ] ; for ( i = K - 1 ; i >= 0 && j < n ; i ++ ) { if ( arr [ i ] * arr [ i ] < arr [ j ] * arr [ j ] ) { temp [ ind ] = arr [ i ] * arr [ i ] ; i -- ; } else { temp [ ind ] = arr [ j ] * arr [ j ] ; ind ++ ; } } while ( i >= 0 ) { temp [ ind ] = arr [ i ] * arr [ i ] ; i -- ; ind ++ ; } while ( j < n ) { temp [ ind ] = arr [ j ] * arr [ j ] ; j ++ ; ind ++ ; } for ( i = 0 ; i < n ; i ++ ) { arr [ i ] = temp [ i ] ; } }
static int find_maximum ( int a [ ] , int n , int k ) { Map < Integer , Integer > b = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int d = Math . min ( 1 + i , n - i ) ; if ( x not in b . keySet ( ) ) b [ x ] = d ; else b [ x ] = Math . min ( d , b [ x ] ) ; } int ans = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { int x = a [ i ] ; if ( x != ( k - x ) && ( k - x ) in b . keySet ( ) ) ans = Math . min ( b [ x ] , b [ k - x ] ) ; } return ans ; }
static int maxRepeating ( String str ) { int n = str . length ( ) ; int count = 0 ; String res = str . charAt ( 0 ) ; int cur_count = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( i < n - 1 && str . charAt ( i ) == str . charAt ( i + 1 ) ) cur_count ++ ; else if ( cur_count > count ) { count = cur_count ; res = str . charAt ( i ) ; } cur_count = 1 ; } } return res ; }
static int snoob ( int x ) { int next = 0 ; if ( x != 0 ) { int rightOne = x & - ( x ) ; int nextHigherOneBit = x + int ( rightOne ) ; int rightOnesPattern = x ^ int ( nextHigherOneBit ) ; rightOnesPattern = ( int ) ( rightOnesPattern ) / int ( rightOne ) ) ; rightOnesPattern = ( int ) ( rightOnesPattern ) >> 2 ; next = ( nextHigherOneBit | rightOnesPattern ) ; } return next ; }
static boolean isInorder ( int arr [ ] , int n ) { if ( n == 0 || n == 1 ) return true ; for ( int i = 1 ; i <= n ; i ++ ) if ( arr [ i - 1 ] > arr [ i ] ) return false ; return true ; }
public static int lis ( int arr [ ] ) { int n = arr . length ; int maximum = 1 ; _lis ( arr , n ) ; return maximum ; }
static int nCrModp ( int n , int r , int p ) { int [ ] C = new int [ r + 1 ] ; C [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = min ( i , r ) ; j >= 0 ; j -- ) C [ j ] = ( C [ j ] + C [ j - 1 ] ) % p ; } return C [ r ] ; }
static int binarySearch ( int arr [ ] , int l , int r , int x ) { int mid ; for ( mid = l + ( r - l ) / 2 ; mid <= r ; mid ++ ) { if ( arr [ mid ] == x ) return mid ; else if ( arr [ mid ] < x ) l = mid + 1 ; else r = mid - 1 ; } return - 1 ; }
static int minXOR ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int min_xor = Integer . MAX_VALUE ; int val = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n - 1 ; j ++ ) { val = arr [ i ] ^ arr [ j ] ; min_xor = Math . min ( min_xor , val ) ; } } return min_xor ; }
static int rearrange ( int arr [ ] , int n ) { int temp [ ] = new int [ n ] ; int small = 0 , large = n - 1 ; boolean flag = true ; for ( int i = 0 ; i < n ; i ++ ) { temp [ i ] = arr [ large ] ; large -- ; } else { temp [ i ] = arr [ small ] ; small ++ ; } flag = ( boolean ) ( 1 - flag ) ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = temp [ i ] ; } } return arr ; }
static int LCSubStr ( char X [ ] , char Y [ ] , int m , int n ) { int LCSuff [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; int result = 0 ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 || j == 0 ) LCSuff [ i ] [ j ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) LCSuff [ i ] [ j ] = LCSuff [ i - 1 ] [ j - 1 ] + 1 ; result = Math . max ( result , LCSuff [ i ] [ j ] ) ; } else { LCSuff [ i ] [ j ] = 0 ; } } } return result ; }
static int patternCount ( String str ) { char last = str . charAt ( 0 ) ; int counter = 0 ; for ( int i = 1 ; i < str . length ( ) ; ++ i ) { if ( str . charAt ( i ) == '0' && last == '1' ) { while ( str . charAt ( i ) == '0' ) i ++ ; if ( str . charAt ( i ) == '1' ) counter ++ ; } last = str . charAt ( i ) ; } return counter ; }
static void longestSubseqWithK ( String str , int k ) { int n = str . length ( ) ; int [ ] freq = new int [ MAX_CHARS ] ; for ( int i = 0 ; i < n ; i ++ ) { freq [ str . charAt ( i ) - ' a ' ] ++ ; } for ( int i = 0 ; i < n ; i ++ ) { if ( freq [ str . charAt ( i ) - ' a ' ] >= k ) System . out . print ( str . charAt ( i ) ) ; } }
static int nextPowerOf2 ( int n ) { int count = 0 ; if ( n && ! ( n & ( n - 1 ) ) ) return n ; while ( n != 0 ) n >>= 1 ; count ++ ; return 1 << count ; }
static boolean isPowerOfTwo ( int x ) { return ( x && ( ! ( x & ( x - 1 ) ) ) ) ; }
static void decToBinary ( int n ) { int [ ] binaryNum = new int [ n ] ; int i = 0 ; while ( n > 0 ) { binaryNum [ i ] = n % 2 ; n = n / 2 ; i ++ ; } for ( int j = i - 1 ; j >= 0 ; j -- ) System . out . print ( binaryNum [ j ] ) ; }
static int maximumSumSubarray ( int arr [ ] , int n ) { int min_prefix_sum = 0 ; int res = Integer . MIN_VALUE ; Vector < Integer > [ ] prefix_sum = new Vector [ n ] ; prefix_sum . add ( arr [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) prefix_sum . add ( arr [ i ] ) ; for ( int i = 1 ; i < n ; i ++ ) { res = Math . max ( res , prefix_sum [ i ] - min_prefix_sum ) ; min_prefix_sum = Math . min ( min_prefix_sum , prefix_sum [ i ] ) ; } return res ; }
static int countOccurrences ( String s , int K ) { int n = s . length ( ) ; int c1 = 0 , c2 = 0 ; int C = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == ' a ' ) c1 ++ ; if ( s . charAt ( i ) == ' b ' ) c2 ++ ; } return C * K + ( K * ( K - 1 ) / 2 ) * c1 * c2 ; }
static boolean checkDivisibility ( String num ) { int len = num . length ( ) ; if ( len == 1 && num . charAt ( 0 ) == '0' ) return true ; int length = num . length ( ) ; if ( length % 3 == 1 ) num = num . substring ( 0 , 2 ) ; else if ( length % 3 == 2 ) num = num . substring ( 0 , 2 ) ; else if ( length % 3 == 1 ) num = num . substring ( 0 , 1 ) ; int sum = 0 ; int p = 1 ; for ( int i = length - 1 ; i >= 0 ; i -- ) { group += ( num . charAt ( i ) - '0' ) ; group += ( num . charAt ( i ) - '0' ) ) * 10 ; i -- ; group += ( str . charAt ( i ) - '0' ) ) * 100 ; sum = sum + group * p ; p *= ( - 1 ) ; } return ( sum % 13 == 0 ) ; }
static int countSetBits ( int n ) { int count = 0 ; while ( n ) n &= ( n - 1 ) ; count ++ ; return count ; }
static int lenOfLongSubarr ( int arr [ ] , int n ) { int um [ ] = new int [ 10 ] ; int sum = 0 ; int maxLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) sum ++ ; else sum ++ ; if ( sum == 1 ) { maxLen = i + 1 ; } else if ( sum != um ) { um [ sum ] = i ; } if ( sum != um ) { um [ sum ] = i ; } if ( ! um . containsKey ( sum - 1 ) ) { maxLen = i - um [ sum - 1 ] ; } } return maxLen ; }
static int minJumps ( int arr [ ] , int l , int h ) { if ( h == l ) return 0 ; if ( arr [ l ] == 0 ) return Integer . MIN_VALUE ; int min = Integer . MIN_VALUE ; for ( int i = l + 1 ; i <= h ; i ++ ) { if ( i < l + arr [ l ] + 1 ) { int jumps = minJumps ( arr , i , h ) ; if ( jumps != Integer . MIN_VALUE ) { min = jumps + 1 ; } } } return min ; }
static int minTimeForWritingChars ( int N , int insrt , int remov , int cpy ) { if ( N == 0 ) return 0 ; if ( N == 1 ) return insrt ; int dp [ ] = new int [ N + 1 ] ; for ( int i = 1 ; i <= N ; i ++ ) { if ( i % 2 == 0 ) { dp [ i ] = Math . min ( dp [ i - 1 ] + insrt , dp [ i / 2 ] + cpy ) ; } else { dp [ i ] = Math . min ( dp [ i - 1 ] + insrt , dp [ i / 2 ] + cpy ) ; } } return dp [ N ] ; }
static void carveCross ( String str ) { int n = str . length ( ) ; if ( n % 2 == 0 ) System . out . println ( " Not ▁ possible . ▁ Please ▁ enter ▁ " + " odd ▁ length ▁ string . \n " ) ; else { boolean [ ] [ ] arr = new boolean [ n ] [ n ] ; int m = n / 2 ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] [ m ] = str . charAt ( i ) ; } } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { System . out . print ( arr [ i ] [ j ] + " ▁ " ) ; } System . out . println ( ) ; } }
static int MaximumDecimalValue ( int mat [ ] [ ] , int n ) { int dp [ ] [ ] = new int [ n ] [ n ] ; if ( mat [ 0 ] [ 0 ] == 1 ) { dp [ 0 ] [ 0 ] = 1 ; } else { dp [ 0 ] [ 0 ] = dp [ 0 ] [ 0 ] ; } } for ( int i = 1 ; i < n ; i ++ ) { if ( mat [ 0 ] [ i ] == 1 ) { dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + 2 ** i ; } else { dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] ; } } for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) { if ( mat [ i ] [ j ] == 1 ) { dp [ i ] [ j ] = Math . max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) + ( 2 ** ( i + j ) ) ; } else { dp [ i ] [ j ] = Math . max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ; } } } return dp [ n - 1 ] [ n - 1 ] ; }
static int findRepeating ( int arr [ ] , int n ) { int missingElement = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int element = arr [ abs ( arr [ i ] ) ] ; if ( element < 0 ) { missingElement = arr [ i ] ; break ; } arr [ abs ( arr [ i ] ) ] = - arr [ abs ( arr [ i ] ) ] ; } return Math . abs ( missingElement ) ; }
static boolean isPowerOfFour ( int n ) { return n != 0 && ( ( n & ( n - 1 ) ) == 0 ) && ! ( n & 0xAAAAAAAA ) ) ; }
static void decToBinary ( int n ) { char k ; for ( i = 31 ; i >= 0 ; i -- ) { k = n >> i ; if ( k & 1 ) System . out . print ( 1 + k ) ; else System . out . print ( 0 + k ) ; } }
static int countSubstrs ( String str , int i , int j , int n ) { if ( n == 1 ) return 1 ; if ( n <= 0 ) return 0 ; int res = countSubstrs ( str , i + 1 , j , n - 1 ) + countSubstrs ( str , i , j - 1 , n - 1 ) - countSubstrs ( str , i + 1 , j - 1 , n - 2 ) ; if ( str . charAt ( i ) == str . charAt ( j ) ) res ++ ; return res ; }
static int minRotation ( int input , int unlock_code ) { int rotation = 0 ; while ( input > 0 || unlock_code > 0 ) { rotation += Math . min ( Math . abs ( input_digit - code_digit ) , 10 - abs ( input_digit - code_digit ) ) ; input = input / 10 ; unlock_code = unlock_code / 10 ; } return rotation ; }
static boolean checkMarkov ( int m [ ] [ ] ) { int sm = 0 ; for ( int i = 0 ; i < m . length ; i ++ ) { for ( int j = 0 ; j < m [ i ] . length ; j ++ ) { sm = sm + m [ i ] . get ( j ) ; } if ( sm != 1 ) { return false ; } } return true ; }
static boolean areConsecutive ( int arr [ ] , int n ) { if ( n < 1 ) return false ; int Min = Math . min ( arr ) ; int Max = Math . max ( arr ) ; if ( Max - Min + 1 == n ) { boolean [ ] visited = new boolean [ arr . length ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( visited [ arr [ i ] - Min ] != false ) return false ; visited [ arr [ i ] - Min ] = true ; } return true ; }
static int findMod ( int a , int b ) { if ( a < 0 ) a = - a ; if ( b < 0 ) b = - b ; int mod = a ; while ( mod >= b ) mod = mod - b ; if ( a < 0 ) return - mod ; return mod ; }
static int sumOfSubstrings ( String num ) { int n = num . length ( ) ; int [ ] sumofdigit = new int [ n ] ; sumofdigit . add ( num . charAt ( 0 ) ) ; int res = sumofdigit [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { int numi = num . charAt ( i ) ; sumofdigit . add ( ( i + 1 ) * numi + 10 * sumofdigit [ i - 1 ] ) ; res += sumofdigit [ i ] ; } return res ; }
static int findGreatest ( int arr [ ] , int n ) { Map < Integer , Integer > m = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) m . put ( i , 1 ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int j ; for ( j = 0 ; j < i && arr [ j ] <= sqrt ( arr [ i ] ) ; j ++ ) { if ( arr [ i ] % arr [ j ] == 0 ) { int result = arr [ i ] / arr [ j ] ; if ( result != arr [ j ] && ( result in m . keys ( ) ) && m [ result ] > 0 ) return arr [ i ] ; } else if ( result == arr [ j ] && ( result in m . keys ( ) ) && m [ result ] > 1 ) return arr [ i ] ; } } return - 1 ; }
static int getMissingNo ( int a [ ] , int n ) { int i , total = 0 ; for ( i = 2 ; i <= n + 1 ; i ++ ) total += i ; total -= a [ i - 2 ] ; return total ; }
static int nextPowerOf2 ( int n ) { n -- ; n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; return n ; }
static int zigzag ( int n , int k ) { int dp [ ] [ ] = new int [ k + 1 ] [ n + 1 ] ; dp [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { dp [ i ] [ 0 ] = 1 ; } for ( int i = 1 ; i <= k ; i ++ ) { for ( int j = 1 ; j <= k ; j ++ ) { dp [ i ] [ j ] = ( dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ i - j ] ) ; } } return dp [ n ] [ k ] ; }
static int maximumDifferenceSum ( int arr [ ] , int N ) { int dp [ ] [ ] = new int [ N ] [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { dp [ i ] [ 0 ] = dp [ i ] [ 1 ] = 0 ; } for ( int i = 0 ; i < N ; i ++ ) { dp [ i ] [ 1 ] = 0 ; } for ( int i = 0 ; i < N - 1 ; i ++ ) { dp [ i + 1 ] [ 0 ] = Math . max ( dp [ i ] [ 0 ] , dp [ i ] [ 1 ] + Math . abs ( 1 - arr [ i ] ) ) ; dp [ i + 1 ] [ 1 ] = Math . max ( dp [ i ] [ 0 ] + Math . abs ( arr [ i + 1 ] - 1 ) , dp [ i ] [ 1 ] + Math . abs ( arr [ i + 1 ] - arr [ i ] ) ) ; } return Math . max ( dp [ N - 1 ] [ 0 ] , dp [ N - 1 ] [ 1 ] ) ; }
static boolean isMultipleOf10 ( int n ) { return ( n % 15 == 0 ) ; }
static int maxProduct ( int arr [ ] , int n ) { if ( n < 3 ) return - 1 ; Arrays . sort ( arr ) ; return Math . max ( arr [ 0 ] * arr [ 1 ] * arr [ n - 1 ] , arr [ n - 1 ] * arr [ n - 2 ] * arr [ n - 3 ] ) ; }
static int nextPowerOf2 ( int n ) { n -- ; n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; return n ; }
static int findMaxValue ( int arr [ ] , int n ) { if ( n < 4 ) System . out . println ( " The ▁ array ▁ should ▁ have ▁ atlest ▁ 4 ▁ elements " ) ; return MIN ; } int table1 [ ] , table2 [ ] = new int [ n + 1 ] , table3 [ ] , table4 [ ] = new int [ n - 2 ] ; for ( int i = 0 ; i < n - 1 ; i -- ) { table1 [ i ] = Math . max ( table1 [ i + 1 ] , arr [ i ] ) ; } for ( int i = n - 2 ; i >= 0 ; i -- ) { table2 [ i ] = Math . max ( table2 [ i + 1 ] , table1 [ i + 1 ] - arr [ i ] ) ; table3 [ i ] = Math . max ( table3 [ i + 1 ] , table2 [ i + 1 ] + arr [ i ] ) ; } for ( int i = n - 4 ; i >= 0 ; i -- ) { table4 [ i ] = Math . max ( table4 [ i + 1 ] , table3 [ i + 1 ] - arr [ i ] ) ; } return table4 [ 0 ] ; }
static int findMaxGCD ( int arr [ ] , int n ) { int high = 0 ; for ( int i = 0 ; i < n ; i ++ ) high = Math . max ( high , arr [ i ] ) ; int [ ] count = new int [ high + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { count [ arr [ i ] ] = 0 ; } int counter = 0 ; for ( int i = 0 ; i < high ; i ++ ) { for ( int j = i ; j <= high ; j ++ ) { if ( count [ j ] > 0 ) ++ counter ; } if ( counter == 2 ) return i ; } return - 1 ; }
static void smallestSubsegment ( int a [ ] , int n ) { HashMap < Integer , Integer > left = new HashMap < Integer , Integer > ( ) ; int count = new int [ n ] ; int mx = 0 , mn = 0 , strindex = 0 ; for ( int i = 0 ; i < n ; i ++ ) { left [ x ] = i ; count [ x ] = 1 ; } else { count [ x ] ++ ; if ( count [ x ] > mx ) { mx = count [ x ] ; mn = i - left [ x ] + 1 ; strindex = left [ x ] ; } else if ( count [ x ] == mx && i - left [ x ] + 1 < mn ) { mn = i - left [ x ] + 1 ; strindex = left [ x ] ; } } for ( int i = strindex ; i < strindex + mn ; i ++ ) System . out . print ( a [ i ] + " ▁ " ) ; }
static int minRadius ( int k , int x [ ] , int y [ ] , int n ) { int dis [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) dis [ i ] = x [ i ] * x [ i ] + y [ i ] * y [ i ] ; return dis [ k - 1 ] ; }
static void findSmallest ( int m , int s ) { if ( s == 0 ) System . out . println ( " Smallest ▁ number ▁ is ▁ 0 " ) ; else System . out . println ( " Not ▁ possible " ) ; if ( s > 9 * m ) System . out . println ( " Not ▁ possible " ) ; return ; } int res [ ] = new int [ m + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { if ( s > 9 ) res [ i ] = 9 ; s -= 9 ; } else { res [ i ] = s ; s = 0 ; } } res [ 0 ] = s + 1 ; System . out . println ( " Smallest ▁ number ▁ is ▁ " ) ; for ( int i = 0 ; i < m ; i ++ ) System . out . print ( res [ i ] + " " ) ; }
static boolean isPresent ( String s , String q ) { int freq [ ] = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { freq [ s . charAt ( i ) ] ++ ; } for ( int i = 0 ; i < q . length ( ) ; i ++ ) { freq [ q . charAt ( i ) ] -- ; if ( freq [ q . charAt ( i ) ] < 0 ) return false ; } return true ; }
static void sortArray ( int arr [ ] , int n , int A , int B , int C ) { int i , j , k ; for ( i = 0 ; i < n ; i ++ ) { arr [ i ] = A * arr [ i ] * arr [ i ] + B * arr [ i ] + C ; } int index = Integer . MAX_VALUE ; int maximum = Integer . MIN_VALUE ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ j ] ) { new_arr [ k ] = arr [ i ] ; k ++ ; i ++ ; } else { new_arr [ k ] = arr [ j ] ; k ++ ; j -- ; } } while ( i < index ) { new_arr [ k ] = arr [ i ] ; k ++ ; i ++ ; } while ( j > index ) { new_arr [ k ] = arr [ j ] ; k ++ ; j -- ; } } for ( i = 0 ; i < n ; i ++ ) { arr [ i ] = new_arr [ i ] ; } }
static void printDistance ( int mat [ ] [ ] ) { int N = mat . length ; int ans [ ] [ ] = new int [ N ] [ M ] ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < M ; j ++ ) ans [ i ] [ j ] = Integer . MAX_VALUE ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { for ( int k = 0 ; k < N ; k ++ ) { for ( int l = 0 ; l < M ; l ++ ) { if ( mat [ k ] [ l ] == 1 ) ans [ i ] [ j ] = Math . min ( ans [ i ] [ j ] , Math . abs ( i - k ) + Math . abs ( j - l ) ) ; } } } for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) System . out . print ( ans [ i ] [ j ] + " ▁ " ) ; System . out . println ( ) ; } }
static int findLastIndex ( String str , char x ) { int index = - 1 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) == x ) index = i ; } return index ; }
static double vol_of_dodecahedron ( int side ) { return ( ( 15 + ( 7 * ( Math . sqrt ( 5 ) ) ) / 4 ) * ( Math . pow ( side , 3 ) ) ) ; }
static int countTransformation ( int a [ ] , int b [ ] ) { int n = a . length ( ) ; int m = b . length ( ) ; if ( m == 0 ) return 1 ; int dp [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == 0 ) { dp [ i ] [ j ] = 1 ; } else { dp [ i ] [ j ] = 0 ; } } else if ( a [ j ] == b [ i ] ) { dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + 1 ; } else { dp [ i ] [ j ] = dp [ i ] [ j - 1 ] ; } } } return dp [ m - 1 ] [ n - 1 ] ; }
static int sumAtKthLevel ( char tree [ ] , int k , int i , int level ) { if ( tree [ i [ 0 ] ] == ' ( ' ) return 0 ; if ( tree [ i [ 0 ] ] == ' ) ' ) return 0 ; int sum = 0 ; if ( level == k ) { sum = tree [ i [ 0 ] ] ; i [ 0 ] ++ ; return sum ; } int leftsum = sumAtKthLevel ( tree , k , i , level + 1 ) ; i [ 0 ] ++ ; int rightsum = sumAtKthLevel ( tree , k , i , level + 1 ) ; i [ 0 ] ++ ; return sum + leftsum + rightsum ; }
static void printRepeating ( int [ ] arr , int size ) { int [ ] count = new int [ size ] ; System . out . println ( " ▁ Repeating ▁ elements ▁ are ▁ " ) ; for ( int i = 0 ; i < size ; i ++ ) { if ( count [ arr [ i ] ] == 1 ) System . out . print ( arr [ i ] + " ▁ " ) ; else count [ arr [ i ] ] ++ ; } }
static boolean isSubsetSum ( int set [ ] [ ] , int n , int sum ) { boolean [ ] [ ] subset = new boolean [ n + 1 ] [ sum + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) subset [ i ] [ 0 ] = true ; for ( int i = 0 ; i <= sum ; i ++ ) { subset [ 0 ] [ i ] = false ; } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j < set [ i - 1 ] . length ; j ++ ) { if ( j < set [ i - 1 ] . length ) { subset [ i ] [ j ] = subset [ i - 1 ] [ j ] ; } if ( j >= set [ i - 1 ] . length ) { subset [ i ] [ j ] = subset [ i - 1 ] [ j - set [ i - 1 ] ] ; } } return subset [ n ] [ sum ] ; }
static void findMajority ( int arr [ ] , int size ) { HashMap < Integer , Integer > m = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < size ; i ++ ) { if ( m . containsKey ( arr [ i ] ) ) { m . put ( arr [ i ] , m . get ( arr [ i ] ) + 1 ) ; } else { m . put ( arr [ i ] , 1 ) ; } } int count = 0 ; for ( int key = 0 ; key < m . keySet ( ) ; key ++ ) { if ( m . get ( key ) > size / 2 ) { count ++ ; System . out . println ( " Majority ▁ found ▁ : - " + key ) ; break ; } } if ( count == 0 ) System . out . println ( " No ▁ Majority ▁ element " ) ; }
static void replaceOriginal ( String s , int n ) { char [ ] r = new char [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { r [ i ] = s . charAt ( n - 1 - i ) ; if ( s . charAt ( i ) != ' a ' && s . charAt ( i ) != ' e ' && s . charAt ( i ) != ' i ' && s . charAt ( i ) != ' o ' && s . charAt ( i ) != ' u ' ) System . out . print ( r [ i ] ) ; } System . out . println ( ) ; }
static int findMaxPath ( int mat [ ] [ ] ) { int res = - 1 ; for ( int i = 0 ; i < M ; i ++ ) res = Math . max ( res , mat [ 0 ] [ i ] ) ; for ( int i = 1 ; i < N ; i ++ ) { int j ; for ( j = 0 ; j < M ; j ++ ) { if ( j > 0 && j < M - 1 ) { mat [ i ] [ j ] += Math . max ( mat [ i - 1 ] [ j ] , Math . max ( mat [ i - 1 ] [ j - 1 ] , mat [ i - 1 ] [ j + 1 ] ) ) ; } else if ( j > M - 1 ) { mat [ i ] [ j ] += Math . max ( mat [ i - 1 ] [ j ] , mat [ i - 1 ] [ j - 1 ] ) ; } res = Math . max ( mat [ i ] [ j ] , res ) ; } } return res ; }
boolean checkIsAP ( int arr [ ] , int n ) { if ( n == 1 ) return true ; Arrays . sort ( arr ) ; int d = arr [ 0 ] - arr [ 1 ] ; for ( int i = 2 ; i < n ; i ++ ) if ( arr [ i ] - arr [ i - 1 ] != d ) return false ; return true ; }
static boolean check ( String str ) { int n = str . length ( ) ; int oddDigSum = 0 , evenDigSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) oddDigSum = oddDigSum + ( ( int ) ( str . charAt ( i ) ) ) ; else evenDigSum = evenDigSum + ( ( int ) ( str . charAt ( i ) ) ) ; } return ( ( oddDigSum - evenDigSum ) % 11 == 0 ) ; }
static void swap ( int xp [ ] , int yp [ ] ) { xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] ; yp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] ; xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] ; }
static int countSol ( int coeff [ ] , int n , int rhs ) { int dp [ ] = new int [ rhs + 1 ] ; dp [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = coeff [ i ] ; j <= rhs ; j ++ ) dp [ j ] += dp [ j - coeff [ i ] ] ; } return dp [ rhs ] ; }
static void printRepeating ( int arr [ ] , int size ) { int xor = arr [ 0 ] ; int n = size - 2 ; int x = 0 , y = 0 ; for ( int i = 1 ; i < size ; i ++ ) { xor ^= arr [ i ] ; } int set_bit_no = xor & ~ ( xor - 1 ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] & set_bit_no ) { x = x ^ arr [ i ] ; } else { y = y ^ arr [ i ] ; } } for ( int i = 1 ; i <= n ; i ++ ) { if ( i & set_bit_no ) { x = x ^ i ; } else { y = y ^ i ; } } System . out . println ( " The ▁ two ▁ repeating " + " elements ▁ are ▁ " + y + x ) ; }
static int findSubsequenceCount ( char [ ] S , char [ ] T ) { int m = T . length ( ) ; int n = S . length ( ) ; int [ ] [ ] mat = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { mat [ i ] [ 0 ] = 0 ; } for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( T [ i - 1 ] != S [ j - 1 ] ) { mat [ i ] [ j ] = mat [ i ] [ j - 1 ] ; } else { mat [ i ] [ j ] = ( mat [ i ] [ j - 1 ] + mat [ i - 1 ] [ j - 1 ] ) ; } } } return mat [ m ] [ n ] ; }
static int breakSum ( int n ) { int dp [ ] = new int [ n + 1 ] ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) dp [ i ] = Math . max ( dp [ int ( i / 2 ) ] + dp [ int ( i / 3 ) ] + dp [ int ( i / 4 ) ] , i ) ; return dp [ n ] ; }
static void decToHexa ( int n ) { char [ ] hexaDeciNum = new char [ 100 ] ; int i = 0 ; while ( n != 0 ) { int temp = 0 ; temp = n % 16 ; if ( temp < 10 ) hexaDeciNum [ i ] = ( char ) ( temp + 48 ) ; i ++ ; else { hexaDeciNum [ i ] = ( char ) ( temp + 55 ) ; i ++ ; } n = n / 16 ; } j = i - 1 ; while ( j >= 0 ) System . out . print ( hexaDeciNum [ j ] ) ; j -- ; } }
static int gcd ( int a , int b ) { if ( a == b ) return a ; if ( b == 0 ) return b ; if ( a == 0 ) return a ; if ( b == 0 ) return b ; if ( a & 1 ) == 1 ) return gcd ( a >> 1 , b ) ; else if ( ( ~ a & 1 ) == 1 ) return gcd ( a >> 1 , b >> 1 ) ; if ( ( ~ b & 1 ) == 1 ) return gcd ( a , b >> 1 ) ; if ( ( a & 1 ) == 1 ) return gcd ( a , b >> 1 ) ; if ( ( ~ a & 1 ) == 1 ) return gcd ( a , b >> 1 ) ; if ( ( ~ b & 1 ) == 1 ) return gcd ( a , b >> 1 ) ; if ( a > b ) return gcd ( ( a - b ) >> 1 , b ) ; return gcd ( ( b - a ) >> 1 , a ) ; }
static void evaluate ( int n ) { if ( n == 1 || n == 2 ) System . out . println ( " No ▁ Pythagoras ▁ Triplet ▁ exists " ) ; else if ( n % 2 == 0 ) { int var = n * n / 4 ; System . out . println ( " Pythagoras ▁ Triplets ▁ " + " ▁ exist ▁ i . e . ▁ " + int . valueOf ( n ) ) ; System . out . println ( " No ▁ Pythagoras ▁ Triplet ▁ exists ▁ " ) ; } else if ( n % 2 != 0 ) { int var = n * n + 1 ; System . out . println ( " Pythagoras ▁ Triplets ▁ " + " exist ▁ i . e . ▁ " + int . valueOf ( var / 2 - 1 ) + " ▁ " + int . valueOf ( var / 2 ) ) ; } }
static int countPairs ( String str ) { int result = 0 ; int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 1 ; j <= MAX_CHAR ; j ++ ) { if ( ( i + j ) < n ) { if ( ( Math . abs ( str . charAt ( i + j ) - str . charAt ( i ) ) == j ) ) result ++ ; } } } return result ; }
static int solve ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int a = 0 , b = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 != 0 ) a = a * 10 + arr [ i ] ; else b = b * 10 + arr [ i ] ; } return a + b ; }
static int countMinOperations ( int target [ ] , int n ) { int result = 0 ; while ( true ) { int zero_count = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( ( target [ i ] & 1 ) > 0 ) break ; else if ( target [ i ] == 0 ) zero_count ++ ; i ++ ; if ( zero_count == n ) return result ; if ( i == n ) { for ( int j = 0 ; j < n ; ++ j ) { target [ j ] = target [ j ] / 2 ; result ++ ; } } if ( i == n ) { for ( int j = i ; j < n ; ++ j ) { if ( target [ j ] & 1 ) target [ j ] -= 1 ; result ++ ; } } } return result ; }
static boolean canMakeAllSame ( String str ) { int zeros = 0 , ones = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char ch = str . charAt ( i ) ; if ( ch == '0' ) zeros ++ ; else ones ++ ; } return ( zeros == 1 || ones == 1 ) ; }
static void psuedoBinary ( int n ) { while ( n > 0 ) { int temp = n ; int m = 0 , p = 1 ; while ( temp > 0 ) { temp = temp / 10 ; if ( rem != 0 ) m += p ; p *= 10 ; } System . out . println ( m + " ▁ " ) ; n = n - m ; }
static int findmin ( int p [ ] [ ] , int n ) { int a = 0 , b = 0 , c = 0 , d = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( p [ i ] [ 0 ] <= 0 ) a ++ ; else if ( p [ i ] [ 0 ] >= 0 ) b ++ ; if ( p [ i ] [ 1 ] >= 0 ) c ++ ; else if ( p [ i ] [ 1 ] <= 0 ) d ++ ; } return Math . min ( [ a , b , c , d ] ) ; }
static int minCoins ( int coins [ ] , int m , int V ) { int table [ ] = new int [ V + 1 ] ; table [ 0 ] = 0 ; for ( int i = 1 ; i <= V ; i ++ ) { table [ i ] = Integer . MAX_VALUE ; } for ( int i = 1 ; i <= V ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( coins [ j ] <= i ) { int sub_res = table [ i - coins [ j ] ] ; if ( sub_res != Integer . MAX_VALUE && sub_res + 1 < table [ i ] ) table [ i ] = sub_res + 1 ; } } } return table [ V ] ; }
static int maxAlternateSum ( int arr [ ] , int n ) { if ( n == 1 ) return arr [ 0 ] ; int dec [ ] = new int [ n + 1 ] ; int inc [ ] = new int [ n + 1 ] ; int flag ; for ( int i = 0 ; i <= n ; i ++ ) { dec [ i ] = inc [ 0 ] = arr [ 0 ] ; flag = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ j ] > arr [ i ] ) { dec [ i ] = Math . max ( dec [ i ] , inc [ j ] + arr [ i ] ) ; flag = 1 ; } else if ( arr [ j ] < arr [ i ] && flag == 1 ) { inc [ i ] = Math . max ( inc [ i ] , dec [ j ] + arr [ i ] ) ; } } } int result = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { if ( result < inc [ i ] ) { result = inc [ i ] ; } if ( result < dec [ i ] ) { result = dec [ i ] ; } } return result ; }
static void printRepeating ( int arr [ ] , int size ) { System . out . print ( " Repeating ▁ elements ▁ are ▁ " ) ; for ( int i = 0 ; i < size ; i ++ ) { for ( int j = i + 1 ; j < size ; j ++ ) { if ( arr [ i ] == arr [ j ] ) System . out . print ( arr [ i ] + " ▁ " ) ; } } }
static int firstElement ( int arr [ ] , int n , int k ) { HashMap < Integer , Integer > count_map = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( count_map . containsKey ( arr [ i ] ) ) { count_map . put ( arr [ i ] , count_map . get ( arr [ i ] ) + 1 ) ; } else { count_map . put ( arr [ i ] , 1 ) ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( count_map . containsKey ( arr [ i ] ) && count_map . get ( arr [ i ] ) == k ) return arr [ i ] ; } return - 1 ; }
static int maxSum ( int grid [ ] [ ] , int n ) { int incl = Math . max ( grid [ 0 ] [ 0 ] , grid [ 1 ] [ 0 ] ) ; int excl = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int excl_new = Math . max ( excl , incl ) ; excl = excl + Math . max ( grid [ 0 ] [ i ] , grid [ 1 ] [ i ] ) ; incl = excl_new ; } return max ( excl , incl ) ; }
static boolean checkCorrectOrNot ( String s ) { int count1 [ ] = new int [ MAX_CHAR ] , count2 [ ] = new int [ MAX_CHAR ] ; int n = s . length ( ) ; if ( n == 1 ) return true ; for ( int i = 0 , j = n - 1 ; i < j ; i ++ , j -- ) { count1 [ s . charAt ( i ) - ' a ' ] ++ ; count2 [ s . charAt ( j ) - ' a ' ] ++ ; } for ( int i = 0 ; i < MAX_CHAR && count1 [ i ] != count2 [ i ] ; i ++ ) { if ( count1 [ i ] != count2 [ i ] ) return false ; } } return true ; }
static double areaOctagon ( int side ) { return 2 * ( 1 + ( Math . sqrt ( 2 ) ) ) * side * side ; }
static void printSuperSeq ( char a [ ] , char b [ ] ) { int m = a . length , n = b . length ; int dp [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( ! i ) { dp [ i ] [ j ] = j ; } else { dp [ i ] [ j ] = 1 + Math . min ( dp [ i - 1 ] [ j - 1 ] , dp [ i ] [ j - 1 ] ) ; } } int index = dp [ m ] [ n ] ; for ( int i = 0 , j = n ; i > 0 && j > 0 ; i -- ) { if ( a [ i - 1 ] == b [ j - 1 ] ) { res [ index - 1 ] = a [ i - 1 ] ; i -- ; index -- ; } else { res [ index - 1 ] = b [ j - 1 ] ; j -- ; index -- ; } } while ( i > 0 && j > 0 ) { res [ index - 1 ] = a [ i - 1 ] ; i -- ; index -- ; } while ( i > 0 ) { res [ index - 1 ] = a [ i - 1 ] ; i -- ; index -- ; } while ( j > 0 ) { res [ index - 1 ] = b [ j - 1 ] ; j -- ; index -- ; } }
static int numberOfPaths ( int p , int q ) { int dp [ ] = new int [ q ] ; for ( int i = 0 ; i < p - 1 ; i ++ ) dp [ i ] += dp [ i - 1 ] ; for ( int i = 1 ; i < p - 2 ; i ++ ) { for ( int j = 1 ; j < q ; j ++ ) dp [ j ] += dp [ j - 1 ] ; } return dp [ q - 1 ] ; }
static boolean isPowerOfFour ( int n ) { int count = 0 ; if ( n && ( ! ( n & ( n - 1 ) ) ) ) return false ; while ( n > 1 ) n >>= 1 ; count ++ ; if ( count % 2 == 0 ) return true ; else return false ; }
static int findElement ( int arr [ ] , int n ) { int [ ] leftMax = new int [ n ] ; leftMax [ 0 ] = Integer . MIN_VALUE ; for ( int i = 1 ; i < n ; i ++ ) leftMax [ i ] = Math . max ( leftMax [ i - 1 ] , arr [ i - 1 ] ) ; int rightMin = Integer . MIN_VALUE ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( leftMax [ i ] < arr [ i ] && rightMin > arr [ i ] ) return i ; rightMin = Math . min ( rightMin , arr [ i ] ) ; } return - 1 ; }
static void printRepeating ( int arr [ ] , int size ) { System . out . println ( " ▁ The ▁ repeating ▁ elements ▁ are ▁ " ) ; for ( int i = 0 ; i < size ; i ++ ) { if ( arr [ abs ( arr [ i ] ) ] > 0 ) arr [ abs ( arr [ i ] ) ] = ( - 1 ) * arr [ abs ( arr [ i ] ) ; else System . out . print ( arr [ abs ( arr [ i ] ) ; } }
static int height ( int N ) { return ( int ) ( Math . ceil ( Math . log2 ( N + 1 ) ) - 1 ) ; }
static void thirdLargest ( int arr [ ] , int arr_size ) { if ( arr_size < 3 ) System . out . println ( " ▁ Invalid ▁ Input ▁ " ) ; return ; } int first = arr [ 0 ] ; int second = - 1 , third = - 1 ; for ( int i = 1 ; i < arr_size ; i ++ ) { if ( arr [ i ] > first ) { third = second ; second = first ; first = arr [ i ] ; } else if ( arr [ i ] > second ) { third = second ; second = arr [ i ] ; } else if ( arr [ i ] > third ) { third = arr [ i ] ; arr [ i ] = third ; } } System . out . println ( " The ▁ third ▁ Largest " + " element ▁ is ▁ " + third ) ; }
static int getNumStrictMonotone ( int ln ) { int DP [ ] [ ] = new int [ DP_s ] [ DP_s ] ; for ( int i = 0 ; i < DP_s ; i ++ ) DP [ 0 ] [ i ] = i + 1 ; for ( int i = 1 ; i < ln ; i ++ ) { for ( int j = 1 ; j < DP_s ; j ++ ) DP [ i ] [ j ] = DP [ i - 1 ] [ j - 1 ] + DP [ i ] [ j - 1 ] ; } return DP [ ln - 1 ] [ DP_s - 1 ] ; }
static int maxRevenue ( int m , int x [ ] , int revenue [ ] , int n , int t ) { int maxRev [ ] = new int [ m + 1 ] ; int nxtbb ; for ( i = 1 ; i <= m ; i ++ ) { if ( x [ nxtbb ] != i ) maxRev [ i ] = maxRev [ i - 1 ] ; else { if ( i <= t ) maxRev [ i ] = Math . max ( maxRev [ i - t - 1 ] + revenue [ nxtbb ] , maxRev [ i - 1 ] ) ; else { maxRev [ i ] = Math . max ( maxRev [ i - t - 1 ] + revenue [ nxtbb ] , maxRev [ i - 1 ] ) ; } nxtbb ++ ; } } return maxRev [ m ] ; }
static void lineFromPoints ( int P [ ] , int Q [ ] ) { int a = P [ 1 ] - P [ 1 ] ; int b = Q [ 0 ] - Q [ 0 ] ; int c = a * ( P [ 0 ] ) + b * ( P [ 1 ] ) ; if ( b < 0 ) System . out . print ( " The ▁ line ▁ passing ▁ through ▁ points ▁ P ▁ and ▁ Q ▁ is : " + a + " x ▁ " + b + " y ▁ = ▁ " + c + " \n " ) ; else { System . out . print ( " The ▁ line ▁ passing ▁ through ▁ points ▁ P ▁ and ▁ Q ▁ is : " + a + " x ▁ + ▁ " + b + " y ▁ = ▁ " + c + " \n " ) ; } }
static int countSubstringWithEqualEnds ( String s ) { int result = 0 ; int n = s . length ( ) ; int [ ] count = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < n ; i ++ ) { count [ s . charAt ( i ) - ' a ' ] ++ ; } for ( int i = 0 ; i < MAX_CHAR ; i ++ ) result += ( count [ i ] * ( count [ i ] + 1 ) / 2 ) ; return result ; }
static int findRepeatingNumber ( int arr [ ] , int n ) { double sq = Math . sqrt ( n ) ; int [ ] count = new int [ n ] ; int selected_block ; for ( int i = 0 ; i < range__ ; i ++ ) { count [ i ] = arr [ i ] - 1 / sq ; } for ( int i = 0 ; i < n ; i ++ ) { if ( count [ i ] > sq ) { selected_block = i ; break ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( ( count [ i ] > sq ) { selected_block = i ; break ; } } int m [ arr [ i ] ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( selected_block * sq ) < arr [ i ] ) && ( arr [ i ] <= ( selected_block + 1 ) * sq ) ) m [ arr [ i ] ] ++ ; if ( m [ arr [ i ] ] > 1 ) return arr [ i ] ; } } return - 1 ; }
static boolean check ( String str ) { int n = str . length ( ) ; if ( n == 0 ) return false ; if ( n == 1 ) return ( str . charAt ( 0 ) - '0' ) % 4 == 0 ) ; int last = ( int ) ( str . charAt ( n - 1 ) ) ; int second_last = ( int ) ( str . charAt ( n - 2 ) ) ; return ( ( second_last * 10 + last ) % 4 == 0 ) ; }
static int remAnagram ( String str1 , String str2 ) { int count1 [ ] = new int [ CHARS ] , count2 [ ] = new int [ CHARS ] ; int i ; for ( i = 0 ; i < str1 . length ( ) ; i ++ ) { count1 [ str1 . charAt ( i ) - ' a ' ] ++ ; i ++ ; } i = 0 ; while ( i < str2 . length ( ) ) { count2 [ str2 . charAt ( i ) - ' a ' ] ++ ; i ++ ; } int result = 0 ; for ( i = 0 ; i < 26 ; i ++ ) result += Math . abs ( count1 [ i ] - count2 [ i ] ) ; return result ; }
static int mulmod ( int a , int b , int mod ) { int res = 0 ; a = a % mod ; while ( b > 0 ) { if ( b % 2 == 1 ) res = ( res + a ) % mod ; a = ( a * 2 ) % mod ; b /= 2 ; } return res % mod ; }
static String Dragon_Curve_Sequence ( int n ) { String s = "1" ; for ( int i = 2 ; i <= n ; i ++ ) { String temp = "1" ; int prev = '1' ; int zero = '0' ; int one = '1' ; for ( int j = 0 ; j < s . length ( ) ; j ++ ) { temp += s . charAt ( j ) ; if ( prev == '0' ) temp += one ; prev = one ; } else { temp += zero ; prev = zero ; } } return s ; }
static char getSecondMostFreq ( String str ) { int [ ] count = new int [ NO_OF_CHARS ] ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { count [ str . charAt ( i ) ] ++ ; } int first = 0 , second = 0 ; for ( int i = 0 ; i < NO_OF_CHARS ; i ++ ) { if ( count [ i ] > count [ first ] ) { second = first ; first = i ; } else if ( count [ i ] > count [ second ] && count [ i ] != count [ first ] ) { second = i ; } } return str . charAt ( second ) ; }
