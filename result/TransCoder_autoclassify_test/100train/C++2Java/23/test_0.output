static void firstFit ( int blockSize [ ] , int m , int processSize [ ] , int n ) { int allocation [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( blockSize [ j ] >= processSize [ i ] ) { allocation [ i ] = j ; blockSize [ j ] -= processSize [ i ] ; break ; } } } System . out . println ( " Process ▁ No . \tProcess ▁ Size\tBlock ▁ no . \n " ) ; for ( int i = 0 ; i < n ; i ++ ) { System . out . println ( " ▁ " + i + 1 + " \t\t " + processSize [ i ] + " \t\t " ) ; if ( allocation [ i ] != - 1 ) System . out . print ( allocation [ i ] + 1 ) ; else System . out . println ( " Not ▁ Allocated " ) ; }
static boolean distributingBalls ( int k , int n , String str ) { int [ ] a = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ str . charAt ( i ) - ' a ' ] ++ ; } for ( int i = 0 ; i < MAX_CHAR ; i ++ ) if ( a [ i ] > k ) return false ; return true ; }
static ll count_of_ways ( ll n ) { ll count ; count = ( n + 1 ) * ( n + 2 ) / 2 ; return count ; }
static int calcAngle ( double h , double m ) { if ( h < 0 || m < 0 || h > 12 || m > 60 ) System . out . println ( " Wrong ▁ input " ) ; if ( h == 12 ) h = 0 ; if ( m == 60 ) m = 0 ; int hour_angle = 0.5 * ( h * 60 + m ) ; int minute_angle = 6 * m ; int angle = Math . abs ( hour_angle - minute_angle ) ; angle = Math . min ( 360 - angle , angle ) ; return angle ; }
static int smallest ( int x , int y , int z ) { if ( ! ( y / x ) ) return ( ! ( y / z ) ) ? y : z ; return ( ! ( x / z ) ) ? x : z ; }
static char findExtraCharcter ( String strA , String strB ) { int res = 0 , i ; for ( i = 0 ; i < strA . length ( ) ; i ++ ) { res ^= strA . charAt ( i ) ; } for ( i = 0 ; i < strB . length ( ) ; i ++ ) { res ^= strB . charAt ( i ) ; } return ( ( char ) ( res ) ) ; }
static int findMinimumAngle ( int arr [ ] , int n ) { int l = 0 , sum = 0 , ans = 360 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; while ( sum >= 180 ) { ans = Math . min ( ans , 2 * Math . abs ( 180 - sum ) ) ; sum -= arr [ l ] ; l ++ ; } ans = Math . min ( ans , 2 * Math . abs ( 180 - sum ) ) ; } return ans ; }
public static boolean areEqual ( int arr1 [ ] , int arr2 [ ] , int n , int m ) { if ( n != m ) return false ; Arrays . sort ( arr1 ) ; Arrays . sort ( arr2 ) ; for ( int i = 0 ; i < n ; i ++ ) if ( arr1 [ i ] != arr2 [ i ] ) return false ; return true ; }
static int PowerOFPINnfactorial ( int n , int p ) { int ans = 0 ; int temp = p ; while ( temp <= n ) { ans += n / temp ; temp = temp * p ; } return ans ; }
static int search ( int arr [ ] , int n , int x ) { int i ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == x ) return i ; } return - 1 ; }
static boolean isSubSeqDivisible ( String str ) { int n = str . length ( ) ; int dp [ ] [ ] = new int [ n + 1 ] [ 10 ] ; for ( int [ ] rows : dp ) Arrays . fill ( rows , 0 ) ; for ( int i = 1 ; i <= n ; i ++ ) arr [ i ] = str . charAt ( i - 1 ) - '0' ; for ( int i = 1 ; i <= n ; i ++ ) { dp [ i ] [ arr [ i ] % 8 ] = 1 ; } for ( int j = 0 ; j < 8 ; j ++ ) { if ( dp [ i - 1 ] [ j ] > dp [ i ] [ ( j * 10 + arr [ i ] ) % 8 ] ) { dp [ i ] [ ( j * 10 + arr [ i ] ) % 8 ] = dp [ i - 1 ] [ j ] ; if ( dp [ i - 1 ] [ j ] > dp [ i ] [ j ] ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; } } for ( int i = 1 ; i <= n ; i ++ ) { if ( dp [ i ] [ 0 ] == 1 ) return true ; } return false ; }
static int multiplyWith3Point5 ( int x ) { return ( x << 1 ) + x + ( x >> 1 ) ; }
static int countDivisibleSubseq ( String str , int n ) { int len = str . length ( ) ; int dp [ ] [ ] = new int [ len ] [ n ] ; dp [ 0 ] [ ( str . charAt ( 0 ) - '0' ) % n ] ++ ; for ( int i = 1 ; i < len ; i ++ ) { dp [ i ] [ ( str . charAt ( i ) - '0' ) % n ] ++ ; for ( int j = 0 ; j < n ; j ++ ) { dp [ i ] [ j ] += dp [ i - 1 ] [ j ] ; } } return dp [ len - 1 ] [ 0 ] ; }
static void pairs ( int arr [ ] , int n , int k ) { int smallest = Integer . MAX_VALUE ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) { if ( Math . abs ( arr [ i ] + arr [ j ] - k ) < smallest ) { smallest = Math . abs ( arr [ i ] + arr [ j ] - k ) ; count = 1 ; } else if ( Math . abs ( arr [ i ] + arr [ j ] - k ) == smallest ) count ++ ; } System . out . println ( " Minimal ▁ Value ▁ = ▁ " + smallest + " \n " ) ; System . out . println ( " Total ▁ Pairs ▁ = ▁ " + count + " \n " ) ; }
static int maxLength ( char s [ ] , int n ) { int dp [ ] [ ] = new int [ n ] [ n ] ; for ( int [ ] rows : dp ) Arrays . fill ( rows , 0 ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) if ( s [ i ] == ' ( ' && s [ i + 1 ] == ' ) ' ) dp [ i ] [ i + 1 ] = 2 ; for ( int l = 2 ; l < n ; l ++ ) { for ( int i = 0 , j = l ; j < n ; i ++ , j ++ ) { if ( s [ i ] == ' ( ' && s [ j ] == ' ) ' ) dp [ i ] [ j ] = 2 + dp [ i + 1 ] [ j - 1 ] ; for ( int k = i ; k < j ; k ++ ) dp [ i ] [ j ] = Math . max ( dp [ i ] [ j ] , dp [ i ] [ k ] + dp [ k + 1 ] [ j ] ) ; } } return dp [ 0 ] [ n - 1 ] ; }
static int summingSeries ( int n ) { return Math . pow ( n , 2 ) ; }
static long moduloMultiplication ( long long a , long long b , long long mod ) { long long res = 0 ; a %= mod ; while ( b ) { if ( b & 1 ) res = ( res + a ) % mod ; a = ( 2 * a ) % mod ; b >>= 1 ; } return res ; }
static int largestPower ( int n , int p ) { int x = 0 ; while ( n ) { n /= p ; x += n ; } return x ; }
static int getOddOccurrence ( int arr [ ] , int arr_size ) { int res = 0 ; for ( int i = 0 ; i < arr_size ; i ++ ) res = res ^ arr [ i ] ; return res ; }
static float findArea ( int a ) { float area ; area = ( Math . sqrt ( 5 * ( 5 + 2 * ( Math . sqrt ( 5 ) ) ) * a * a ) / 4 ; return area ; }
static int countRotationsDivBy8 ( String n ) { int len = n . length ( ) ; int count = 0 ; if ( len == 1 ) { int oneDigit = n . charAt ( 0 ) - '0' ; if ( oneDigit % 8 == 0 ) return 1 ; return 0 ; } if ( len == 2 ) { int first = ( n . 0 ] - '0' ) * 10 + ( n [ 1 ] - '0' ) ; int second = ( n [ 1 ] - '0' ) ; if ( first % 8 == 0 ) count ++ ; if ( second % 8 == 0 ) count ++ ; return count ; } int threeDigit ; for ( int i = 0 ; i < ( len - 2 ) ; i ++ ) { threeDigit = ( n [ i ] - '0' ) * 100 + ( n [ i + 1 ] - '0' ) * 10 + ( n [ i + 2 ] - '0' ) ; if ( threeDigit % 8 == 0 ) count ++ ; } threeDigit = ( n [ len - 1 ] - '0' ) * 100 + ( n [ 0 ] - '0' ) * 10 + ( n [ 1 ] - '0' ) ; if ( threeDigit % 8 == 0 ) count ++ ; return count ; }
static int editDistDP ( String str1 , String str2 , int m , int n ) { int dp [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 ) dp [ i ] [ j ] = j ; else if ( j == 0 ) dp [ i ] [ j ] = i ; else if ( str1 [ i - 1 ] == str2 [ j - 1 ] ) dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = 1 + Math . min ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ j - 1 ] ) ; } } return dp [ m ] [ n ] ; }
static boolean isPower ( int x , long int y ) { if ( x == 1 ) return ( y == 1 ) ; long int pow = 1 ; while ( pow < y ) pow *= x ; return ( pow == y ) ; }
static int maxSum ( int arr [ ] , int N , int k ) { int MS [ ] = new int [ N ] ; MS [ N - 1 ] = arr [ N - 1 ] ; for ( int i = N - 2 ; i >= 0 ; i -- ) { if ( i + k + 1 >= N ) MS [ i ] = Math . max ( arr [ i ] , MS [ i + 1 ] ) ; else MS [ i ] = Math . max ( arr [ i ] + MS [ i + k + 1 ] , MS [ i + 1 ] ) ; } return MS [ 0 ] ; }
static void printGrouped ( String str ) { int n = str . length ( ) ; int [ ] count = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < n ; i ++ ) { count [ str . charAt ( i ) - ' a ' ] ++ ; } for ( int i = 0 ; i < n ; i ++ ) { while ( count [ str . charAt ( i ) - ' a ' ] -- ) System . out . print ( str . charAt ( i ) ) ; count [ str . charAt ( i ) - ' a ' ] = 0 ; } }
static int countSub ( String str ) { Vector < Integer > last = new Vector < > ( ) ; int n = str . length ( ) ; int dp [ ] = new int [ n + 1 ] ; dp [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { dp [ i ] = 2 * dp [ i - 1 ] ; if ( last . containsKey ( str . charAt ( i - 1 ) ) ) dp [ i ] = dp [ i ] - dp [ last [ str . charAt ( i - 1 ) ] ] ; last . add ( str . charAt ( i - 1 ) , ( i - 1 ) ) ; } return dp [ n ] ; }
static int maximumZeros ( int arr [ ] , int n , int k ) { int subset [ ] [ ] = new int [ k + 1 ] [ MAX5 + 5 ] ; subset [ 0 ] [ 0 ] = 0 ; for ( int p = 0 ; p < n ; p ++ ) { int pw2 = 0 , pw5 = 0 ; while ( arr [ p ] % 2 == 0 ) { pw2 ++ ; arr [ p ] /= 2 ; } while ( arr [ p ] % 5 == 0 ) { pw5 ++ ; arr [ p ] /= 5 ; } for ( int i = k - 1 ; i >= 0 ; i -- ) for ( int j = 0 ; j < MAX5 ; j ++ ) if ( subset [ i ] [ j ] != - 1 ) subset [ i + 1 ] [ j + pw5 ] = Math . max ( subset [ i + 1 ] [ j + pw5 ] , subset [ i ] [ j ] + pw2 ) ; } int ans = 0 ; for ( int i = 0 ; i < MAX5 ; i ++ ) ans = Math . max ( ans , Math . min ( i , subset [ k ] [ i ] ) ) ; return ans ; }
static int maxDiff ( int arr [ ] , int n ) { int result = 0 ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] != arr [ i + 1 ] ) result += Math . abs ( arr [ i ] ) ; else i ++ ; } if ( arr [ n - 2 ] != arr [ n - 1 ] ) result += Math . abs ( arr [ n - 1 ] ) ; return result ; }
static int countNums ( int n , int x , int y ) { Vector < Boolean > arr = new Vector < Boolean > ( ) ; if ( x <= n ) arr [ x ] = true ; if ( y <= n ) arr [ y ] = true ; int result = 0 ; for ( int i = min ( x , y ) ; i <= n ; i ++ ) { if ( arr [ i ] ) { if ( i + x <= n ) arr [ i + x ] = true ; if ( i + y <= n ) arr [ i + y ] = true ; result ++ ; } } return result ; }
static int countPS ( String str ) { int N = str . length ( ) ; int [ ] [ ] cps = new int [ N + 1 ] [ N + 1 ] ; for ( int [ ] rows : cps ) Arrays . fill ( rows , 0 ) ; for ( int i = 0 ; i < N ; i ++ ) { cps [ i ] [ i ] = 1 ; } for ( int L = 2 ; L <= N ; L ++ ) { for ( int i = 0 ; i < N ; i ++ ) { int k = L + i - 1 ; if ( str . charAt ( i ) == str . charAt ( k ) ) cps [ i ] [ k ] = cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] + 1 ; else cps [ i ] [ k ] = cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] - cps [ i + 1 ] [ k - 1 ] ; } } return cps [ 0 ] [ N - 1 ] ; }
static int countSetBits ( int n ) { if ( n == 0 ) return 0 ; else return ( n & 1 ) + countSetBits ( n >> 1 ) ; }
static int numofAP ( int a [ ] , int n ) { int minarr = Integer . MAX_VALUE , maxarr = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { minarr = Math . min ( minarr , a [ i ] ) ; maxarr = Math . max ( maxarr , a [ i ] ) ; } int dp [ ] , sum [ ] = new int [ n ] ; int ans = n + 1 ; for ( int d = ( minarr - maxarr ) ; d <= ( maxarr - minarr ) ; d ++ ) { Arrays . fill ( sum , 0 ) ; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] = 1 ; if ( a [ i ] - d >= 1 && a [ i ] - d <= 1000000 ) { dp [ i ] += sum [ a [ i ] - d ] ; ans += dp [ i ] - 1 ; sum [ a [ i ] ] += dp [ i ] ; } } return ans ; }
static void spiralFill ( int m , int n , int [ ] a ) { int val = 1 ; int k = 0 , l = 0 ; while ( k < m && l < n ) { for ( int i = l ; i < n ; ++ i ) a [ k ] [ i ] = val ++ ; k ++ ; for ( int i = k ; i < m ; ++ i ) a [ i ] [ n - 1 ] = val ++ ; n -- ; if ( k < m ) { for ( int i = n - 1 ; i >= l ; -- i ) a [ m - 1 ] [ i ] = val ++ ; m -- ; } if ( l < n ) { for ( int i = m - 1 ; i >= k ; -- i ) a [ i ] [ l ] = val ++ ; l ++ ; } } }
static void printClosest ( int arr1 [ ] , int arr2 [ ] , int m , int n , int x ) { int diff = Integer . MAX_VALUE ; int res_l , res_r ; int l = 0 , r = n - 1 ; while ( l < m && r >= 0 ) { if ( Math . abs ( arr1 [ l ] + arr2 [ r ] - x ) < diff ) { res_l = l ; res_r = r ; diff = Math . abs ( arr1 [ l ] + arr2 [ r ] - x ) ; } if ( arr1 [ l ] + arr2 [ r ] > x ) r -- ; else l ++ ; } System . out . println ( " The ▁ closest ▁ pair ▁ is ▁ [ " + arr1 [ res_l ] + " , ▁ " + arr2 [ res_r ] + " ] ▁ " ) ; }
static long decimalToBinary ( int N ) { long B_Number = 0 ; int cnt = 0 ; while ( N != 0 ) { int rem = N % 2 ; ull c = ( long ) ( Math . pow ( 10 , cnt ) ) ; B_Number += rem * c ; N /= 2 ; cnt ++ ; } return B_Number ; }
static int Right_most_setbit ( int num ) { int pos = 1 ; for ( int i = 0 ; i < Integer . SIZE ; i ++ ) { if ( ! ( num & ( 1 << i ) ) ) pos ++ ; else break ; } return pos ; }
static int countDigits ( int a , int b ) { if ( a == 0 || b == 0 ) return 1 ; return floor ( log10 ( Math . abs ( a ) ) + log10 ( Math . abs ( b ) ) ) + 1 ; }
static int countWays ( int n ) { int table [ ] = new int [ n + 1 ] ; table [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) for ( int j = i ; j <= n ; j ++ ) table [ j ] += table [ j - i ] ; return table [ n ] ; }
public static void twoWaySort ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] & 1 ) arr [ i ] *= - 1 ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] & 1 ) arr [ i ] *= - 1 ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] & 1 ) arr [ i ] *= - 1 ; }
static void factorize ( long long n ) { int count = 0 ; while ( ! ( n % 2 ) ) { n >>= 1 ; count ++ ; } if ( count ) System . out . print ( 2 + " ▁ " + count ) ; for ( long long i = 3 ; i <= sqrt ( n ) ; i += 2 ) { count = 0 ; while ( n % i == 0 ) { count ++ ; n = n / i ; } if ( count ) System . out . print ( i + " ▁ " + count ) ; } if ( n > 2 ) System . out . print ( n + " ▁ " + 1 + endl ) ; }
static int findSmallestDifference ( int A [ ] , int B [ ] , int m , int n ) { Arrays . sort ( A ) ; Arrays . sort ( B ) ; int a = 0 , b = 0 ; int result = Integer . MAX_VALUE ; while ( a < m && b < n ) { if ( Math . abs ( A [ a ] - B [ b ] ) < result ) result = Math . abs ( A [ a ] - B [ b ] ) ; if ( A [ a ] < B [ b ] ) a ++ ; else b ++ ; } return result ; }
static boolean isPath ( int arr [ ] [ ] ) { arr [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i < row ; i ++ ) if ( arr [ i ] [ 0 ] != - 1 ) arr [ i ] [ 0 ] = arr [ i - 1 ] [ 0 ] ; for ( int j = 1 ; j < col ; j ++ ) if ( arr [ 0 ] [ j ] != - 1 ) arr [ 0 ] [ j ] = arr [ 0 ] [ j - 1 ] ; for ( int i = 1 ; i < row ; i ++ ) for ( int j = 1 ; j < col ; j ++ ) if ( arr [ i ] [ j ] != - 1 ) arr [ i ] [ j ] = Math . max ( arr [ i ] [ j - 1 ] , arr [ i - 1 ] [ j ] ) ; return ( arr [ row - 1 ] [ col - 1 ] == 1 ) ; }
static int solve ( int dp [ ] [ ] , int a [ ] , int low , int high , int turn ) { if ( low == high ) return a [ low ] * turn ; if ( dp [ low ] [ high ] != 0 ) return dp [ low ] [ high ] ; dp [ low ] [ high ] = Math . max ( a [ low ] * turn + solve ( dp , a , low + 1 , high , turn + 1 ) , a [ high ] * turn + solve ( dp , a , low , high - 1 , turn + 1 ) ) ; return dp [ low ] [ high ] ; }
static int swapNibbles ( int x ) { return ( ( x & 0x0F ) << 4 | ( x & 0xF0 ) >> 4 ) ; }
static int countPS ( int i , int j ) { if ( i >= n || j < 0 ) return 0 ; if ( dp [ i ] [ j ] != - 1 ) return dp [ i ] [ j ] ; if ( Math . abs ( i - j ) == 1 ) { if ( str [ i ] == str [ j ] ) return dp [ i ] [ j ] = 3 ; else return dp [ i ] [ j ] = 2 ; } if ( i == j ) return dp [ 1 ] [ j ] = 1 ; else if ( str [ i ] == str [ j ] ) return dp [ 1 ] [ j ] = 1 ; else if ( str [ i ] == str [ j ] ) return dp [ i ] [ j ] = countPS ( i + 1 , j ) + countPS ( i , j - 1 ) + 1 ; else return dp [ i ] [ j ] = countPS ( i + 1 , j ) + countPS ( i , j - 1 ) - countPS ( i + 1 , j - 1 ) ; }
static int addOne ( int x ) { int m = 1 ; while ( x & m ) { x = x ^ m ; m <<= 1 ; } x = x ^ m ; return x ; }
static int check ( String str ) { int n = str . length ( ) ; int digitSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) digitSum += ( str . charAt ( i ) - '0' ) ; return ( digitSum % 9 == 0 ) ; }
static int findMaxGCD ( int arr [ ] , int n ) { int high = 0 ; for ( int i = 0 ; i < n ; i ++ ) high = Math . max ( high , arr [ i ] ) ; int [ ] divisors = new int [ high + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 1 ; j <= Math . sqrt ( arr [ i ] ) ; j ++ ) { if ( arr [ i ] % j == 0 ) { divisors [ j ] ++ ; if ( j != arr [ i ] / j ) divisors [ arr [ i ] / j ] ++ ; } } } for ( int i = high ; i >= 1 ; i -- ) if ( divisors [ i ] > 1 ) return i ; } return Integer . MAX_VALUE ; }
static int minRemove ( int arr [ ] , int n ) { int LIS [ ] = new int [ n ] , len = 0 ; for ( int i = 0 ; i < n ; i ++ ) LIS [ i ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ i ] > arr [ j ] && ( i - j ) <= ( arr [ i ] - arr [ j ] ) ) { LIS [ i ] = Math . max ( LIS [ i ] , LIS [ j ] + 1 ) ; } } len = Math . max ( len , LIS [ i ] ) ; } return n - len ; }
static void computeLPSArray ( char [ ] pat , int M , int lps [ ] ) { int len = 0 ; lps [ 0 ] = 0 ; int i = 1 ; while ( i < M ) { if ( pat [ i ] == pat [ len ] ) { len ++ ; lps [ i ] = len ; i ++ ; } else { if ( len != 0 ) { len = lps [ len - 1 ] ; } else { lps [ i ] = 0 ; i ++ ; } } }
static int numofsubset ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int count = 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] + 1 != arr [ i + 1 ] ) count ++ ; } return count ; }
static int stringReduction ( String str ) { int n = str . length ( ) ; int [ ] count = new int [ 3 ] ; for ( int i = 0 ; i < n ; ++ i ) { count [ str . charAt ( i ) - ' a ' ] ++ ; } if ( count [ 0 ] == n || count [ 1 ] == n || count [ 2 ] == n ) return n ; if ( ( count [ 0 ] % 2 ) == ( count [ 1 ] % 2 ) && ( count [ 2 ] % 2 ) ) return 2 ; return 1 ; }
static int KnapSack ( int val [ ] , int wt [ ] , int n , int W ) { int dp [ ] = new int [ W + 1 ] ; for ( int [ ] rows : dp ) Arrays . fill ( rows , 0 ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = W ; j >= wt [ i ] ; j -- ) dp [ j ] = Math . max ( dp [ j ] , val [ i ] + dp [ j - wt [ i ] ] ) ; return dp [ W ] ; }
static long findSum ( int n ) { long long int multiTerms = n * ( n + 1 ) / 2 ; long long int sum = multiTerms ; for ( int i = 2 ; i <= n ; i ++ ) { multiTerms = multiTerms - ( i - 1 ) ; sum = sum + multiTerms * i ; } return sum ; }
static int getSingle ( int arr [ ] , int n ) { int result = 0 ; int x , sum ; for ( int i = 0 ; i < Integer . SIZE ; i ++ ) { sum = 0 ; x = ( 1 << i ) ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] & x ) sum ++ ; } if ( sum % 3 ) result |= x ; } return result ; }
static boolean allCharactersSame ( String s ) { int n = s . length ( ) ; for ( int i = 1 ; i < n ; i ++ ) if ( s . charAt ( i ) != s . charAt ( 0 ) ) return false ; return true ; }
static long int maxDecimalValue ( int mat [ ] [ ] , int i , int j , int p ) { if ( i >= N || j >= N ) return 0 ; int result = Math . max ( maxDecimalValue ( mat , i , j + 1 , p + 1 ) , maxDecimalValue ( mat , i + 1 , j , p + 1 ) ) ; if ( mat [ i ] [ j ] == 1 ) return ( long ) ( Math . pow ( 2 , p ) + result ) ; else return result ; }
static long long int countBT ( int h ) { long long int dp [ ] = new long long [ h + 1 ] ; dp [ 0 ] = dp [ 1 ] = 1 ; for ( int i = 2 ; i <= h ; i ++ ) { dp [ i ] = ( dp [ i - 1 ] * ( ( 2 * dp [ i - 2 ] ) % mod + dp [ i - 1 ] ) % mod ) % mod ; } return dp [ h ] ; }
static int power ( int x , unsigned int y , int p ) { int res = 1 ; x = x % p ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % p ; y = y >> 1 ; x = ( x * x ) % p ; } return res ; }
static int swapBits ( int x , int p1 , int p2 , int n ) { unsigned int set1 = ( x >> p1 ) & ( ( 1U << n ) - 1 ) ; unsigned int set2 = ( x >> p2 ) & ( ( 1U << n ) - 1 ) ; unsigned int Xor = ( set1 ^ set2 ) ; Xor = ( Xor << p1 ) | ( Xor << p2 ) ; unsigned int result = x ^ Xor ; return result ; }
static void findElements ( int arr [ ] , int n ) { int first = Integer . MIN_VALUE , second = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > first ) { second = first ; first = arr [ i ] ; } else if ( arr [ i ] > second ) second = arr [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] < first ) System . out . print ( arr [ i ] + " ▁ " ) ; }
static int findMaximum ( int arr [ ] , int low , int high ) { int max = arr [ low ] ; int i ; for ( i = low + 1 ; i <= high ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; else break ; } return max ; }
static int longestPrefixSuffix ( String s ) { int n = s . length ( ) ; int [ ] lps = new int [ n ] ; lps [ 0 ] = 0 ; int len = 0 ; int i = 1 ; while ( i < n ) { if ( s . charAt ( i ) == s . charAt ( len ) ) { len ++ ; lps [ i ] = len ; i ++ ; } else { if ( len != 0 ) { len = lps [ len - 1 ] ; } else { lps [ i ] = 0 ; i ++ ; } } } int res = lps [ n - 1 ] ; return ( res > n / 2 ) ? n / 2 : res ; }
static int MaxTotalRectangleArea ( int a [ ] , int n ) { Arrays . sort ( a , Collections . reverseOrder ( ) ) ; int sum = 0 ; boolean flag = false ; int len ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( a [ i ] == a [ i + 1 ] || a [ i ] - a [ i + 1 ] == 1 ) && ( ! flag ) ) { flag = true ; len = a [ i + 1 ] ; i ++ ; } else if ( ( a [ i ] == a [ i + 1 ] || a [ i ] - a [ i + 1 ] == 1 ) && ( flag ) ) { sum = sum + a [ i + 1 ] * len ; flag = false ; i ++ ; } } return sum ; }
static boolean isHeap ( int arr [ ] , int i , int n ) { if ( i > ( n - 2 ) / 2 ) return true ; if ( arr [ i ] >= arr [ 2 * i + 1 ] && arr [ i ] >= arr [ 2 * i + 2 ] && isHeap ( arr , 2 * i + 1 , n ) && isHeap ( arr , 2 * i + 2 , n ) ) return true ; return false ; }
static int findLength ( String str , int n ) { int ans = 0 ; for ( int i = 0 ; i <= n - 2 ; i ++ ) { int l = i , r = i + 1 ; int lsum = 0 , rsum = 0 ; while ( r < n && l >= 0 ) { lsum += str . charAt ( l ) - '0' ; rsum += str . charAt ( r ) - '0' ; if ( lsum == rsum ) ans = Math . max ( ans , r - l + 1 ) ; l -- ; r ++ ; } } return ans ; }
static int maxDP ( int n ) { int [ ] res = new int [ n + 1 ] ; res [ 0 ] = 0 ; res [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res [ i ] = Math . max ( i , ( res [ i / 2 ] + res [ i / 3 ] + res [ i / 4 ] + res [ i / 5 ] ) ) ; return res [ n ] ; }
static int findDiff ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int count = 0 , max_count = 0 , min_count = n ; for ( int i = 0 ; i < ( n - 1 ) ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) { count += 1 ; continue ; } else { max_count = Math . max ( max_count , count ) ; min_count = Math . min ( min_count , count ) ; count = 0 ; } } return ( max_count - min_count ) ; }
static int countSink ( int n , int m , int edgeFrom [ ] , int edgeTo [ ] ) { int mark [ ] = new int [ n ] ; for ( int i = 0 ; i < m ; i ++ ) mark [ edgeFrom [ i ] ] = 1 ; int count = 0 ; for ( int i = 1 ; i <= n ; i ++ ) if ( ! mark [ i ] ) count ++ ; return count ; }
static int countOfSubstringWithKOnes ( String s , int K ) { int N = s . length ( ) ; int res = 0 ; int countOfOne = 0 ; int [ ] freq = new int [ N + 1 ] ; freq [ 0 ] = 1 ; for ( int i = 0 ; i < N ; i ++ ) { countOfOne += ( s . charAt ( i ) - '0' ) ; if ( countOfOne >= K ) { res += freq [ countOfOne - K ] ; } freq [ countOfOne ] ++ ; } return res ; }
static int search ( int arr [ ] , int n , int x ) { int i ; for ( i = 0 ; i < n ; i ++ ) if ( arr [ i ] == x ) return i ; return - 1 ; }
static int binaryToDecimal ( String n ) { String num = n ; int dec_value = 0 ; int base = 1 ; int len = num . length ( ) ; for ( int i = len - 1 ; i >= 0 ; i -- ) { if ( num . charAt ( i ) == '1' ) dec_value += base ; base = base * 2 ; } return dec_value ; }
static String compute ( String str , int n ) { String reverseAlphabet = " zyxwvutsrqponmlkjihgfedcba " ; int l = str . length ( ) ; for ( int i = n ; i < l ; i ++ ) str . charAt ( i ) = reverseAlphabet [ str . charAt ( i ) - ' a ' ] ; return str ; }
static int countPairs ( String str ) { int result = 0 ; int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( Math . abs ( str . charAt ( i ) - str . charAt ( j ) ) == Math . abs ( i - j ) ) result ++ ; return result ; }
static boolean flipsPossible ( int a [ ] , int n ) { int count_odd = 0 , count_even = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] & 1 ) count_odd ++ ; else count_even ++ ; } if ( count_odd % 2 && count_even % 2 ) return false ; else return true ; }
static int maxSumPairWithDifferenceLessThanK ( int arr [ ] , int N , int K ) { Arrays . sort ( arr ) ; int dp [ ] = new int [ N ] ; dp [ 0 ] = 0 ; for ( int i = 1 ; i < N ; i ++ ) { dp [ i ] = dp [ i - 1 ] ; if ( arr [ i ] - arr [ i - 1 ] < K ) { if ( i >= 2 ) dp [ i ] = Math . max ( dp [ i ] , dp [ i - 2 ] + arr [ i ] + arr [ i - 1 ] ) ; else dp [ i ] = Math . max ( dp [ i ] , arr [ i ] + arr [ i - 1 ] ) ; } } return dp [ N - 1 ] ; }
static void kSmallestPair ( int arr1 [ ] , int n1 , int arr2 [ ] , int n2 , int k ) { if ( k > n1 * n2 ) { System . out . println ( " k ▁ pairs ▁ don ' t ▁ exist " ) ; return ; } int [ ] index2 = new int [ n1 ] ; Arrays . fill ( index2 , 0 ) ; while ( k > 0 ) { int min_sum = Integer . MAX_VALUE ; int min_index = 0 ; for ( int i1 = 0 ; i1 < n1 ; i1 ++ ) { if ( index2 [ i1 ] < n2 && arr1 [ i1 ] + arr2 [ index2 [ i1 ] ] < min_sum ) { min_index = i1 ; min_sum = arr1 [ i1 ] + arr2 [ index2 [ i1 ] ] ; } } System . out . println ( " ( " + arr1 [ min_index ] + " , ▁ " + arr2 [ index2 [ min_index ] ] + " ) ▁ " ) ; index2 [ min_index ] ++ ; k -- ; } }
static void assign ( int a [ ] , int n ) { Arrays . sort ( a ) ; int ans [ ] = new int [ n ] ; int p = 0 , q = n - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( i + 1 ) % 2 == 0 ) ans [ i ] = a [ q -- ] ; else ans [ i ] = a [ p ++ ] ; } for ( int i = 0 ; i < n ; i ++ ) System . out . print ( ans [ i ] + " ▁ " ) ; }
static boolean isPrime ( int p ) { long long checkNumber = ( long ) Math . pow ( 2 , p ) - 1 ; long long nextval = 4 % checkNumber ; for ( int i = 1 ; i < p - 1 ; i ++ ) nextval = ( nextval * nextval - 2 ) % checkNumber ; return ( nextval == 0 ) ; }
static boolean isPalindrome ( String str ) { int l = 0 ; int h = str . length ( ) - 1 ; while ( h > l ) if ( str . charAt ( l ++ ) != str . charAt ( h -- ) ) return false ; return true ; }
static boolean isPower ( int x , int y ) { int res1 = Math . log ( y ) / log ( x ) ; double res2 = Math . log ( y ) / log ( x ) ; return ( res1 == res2 ) ; }
static int minMaxValues ( int arr [ ] , int n , int m ) { int sum = 0 ; for ( int i = 0 ; i < ( n + m ) ; i ++ ) { sum += arr [ i ] ; arr [ i ] += 50 ; } boolean dp [ ] [ ] = new boolean [ MAX + 1 ] [ MAX * MAX + 1 ] ; for ( int [ ] rows : dp ) Arrays . fill ( rows , 0 ) ; dp [ 0 ] [ 0 ] = 1 ; for ( int i = 0 ; i < ( n + m ) ; i ++ ) { for ( int k = Math . min ( n , i + 1 ) ; k >= 1 ; k -- ) { for ( int j = 0 ; j < MAX * MAX + 1 ; j ++ ) { if ( dp [ k - 1 ] [ j ] ) { dp [ k ] [ j + arr [ i ] ] = 1 ; } } } int max_value = - INF , min_value = INF ; for ( int i = 0 ; i < MAX * MAX + 1 ; i ++ ) { if ( dp [ n ] [ i ] ) { int temp = i - 50 * n ; max_value = Math . max ( max_value , temp * ( sum - temp ) ) ; min_value = Math . min ( min_value , temp * ( sum - temp ) ) ; } } System . out . println ( " Maximum ▁ Value : ▁ " + max_value + " \n " + " Minimum ▁ Value : ▁ " + min_value + " " ) ; }
static int superSeq ( char [ ] X , char [ ] Y , int m , int n ) { if ( ! m ) return n ; if ( ! n ) return m ; if ( X [ m - 1 ] == Y [ n - 1 ] ) return 1 + superSeq ( X , Y , m - 1 , n - 1 ) ; return 1 + min ( superSeq ( X , Y , m - 1 , n ) , superSeq ( X , Y , m , n - 1 ) ) ; }
static long arrangeBraces ( int n , int pos [ ] , int k ) { boolean [ ] h = new boolean [ N ] ; int dp [ ] [ ] = new int [ N ] [ N ] ; for ( int i = 0 ; i < k ; i ++ ) { h [ pos [ i ] ] = 1 ; } dp [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= 2 * n ; i ++ ) { for ( int j = 0 ; j <= 2 * n ; j ++ ) { if ( h [ i ] ) { if ( j != 0 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = 0 ; } else { if ( j != 0 ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] ; } } } return dp [ 2 * n ] [ 0 ] ; }
static String lexSmallest ( String str , int n ) { Arrays . sort ( a ) ; String answer = " " ; for ( int i = 0 ; i < n ; i ++ ) answer += str . charAt ( i ) ; return answer ; }
static int subset ( int arr [ ] , int n ) { int res = 0 ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < n ; i ++ ) { int count = 1 ; for ( ; i < n - 1 ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) count ++ ; else break ; } res = Math . max ( res , count ) ; } return res ; }
static void printSubStr ( String str , int low , int high ) { for ( int i = low ; i <= high ; ++ i ) System . out . print ( str . charAt ( i ) ) ; }
static int getMinSquares ( int n ) { int dp [ ] = new int [ n + 1 ] ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; dp [ 2 ] = 2 ; dp [ 3 ] = 3 ; for ( int i = 4 ; i <= n ; i ++ ) { dp [ i ] = i ; } for ( int x = 1 ; x <= ceil ( Math . sqrt ( i ) ) ; x ++ ) { int temp = x * x ; if ( temp > i ) break ; else dp [ i ] = Math . min ( dp [ i ] , 1 + dp [ i - temp ] ) ; } } int res = dp [ n ] ; delete [ ] dp ; return res ; }
static void printClosest ( int arr [ ] , int n , int x ) { int res_l , res_r ; int l = 0 , r = n - 1 , diff = Integer . MAX_VALUE ; while ( r > l ) { if ( Math . abs ( arr [ l ] + arr [ r ] - x ) < diff ) { res_l = l ; res_r = r ; diff = Math . abs ( arr [ l ] + arr [ r ] - x ) ; } if ( arr [ l ] + arr [ r ] > x ) r -- ; else l ++ ; } System . out . println ( " ▁ The ▁ closest ▁ pair ▁ is ▁ " + arr [ res_l ] + " ▁ and ▁ " + arr [ res_r ] ) ; }
int countSubStr ( char str [ ] , int n ) { int m = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == '1' ) m ++ ; } return m * ( m - 1 ) / 2 ; }
static int countSubstringWithEqualEnds ( String s ) { int result = 0 ; int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i ; j < n ; j ++ ) if ( s . charAt ( i ) == s . charAt ( j ) ) result ++ ; return result ; }
static int calcMaxValue ( String str ) { int res = str . charAt ( 0 ) - '0' ; for ( int i = 1 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) == '0' || str . charAt ( i ) == '1' || res < 2 ) res += ( str . charAt ( i ) - '0' ) ; else res *= ( str . charAt ( i ) - '0' ) ; } return res ; }
static void bestFit ( int blockSize [ ] , int m , int processSize [ ] , int n ) { int [ ] allocation = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { int bestIdx = - 1 ; for ( int j = 0 ; j < m ; j ++ ) { if ( blockSize [ j ] >= processSize [ i ] ) { if ( bestIdx == - 1 ) bestIdx = j ; else if ( blockSize [ bestIdx ] > blockSize [ j ] ) bestIdx = j ; } } if ( bestIdx != - 1 ) { allocation [ i ] = bestIdx ; blockSize [ bestIdx ] -= processSize [ i ] ; } } System . out . println ( " Process ▁ No . \tProcess ▁ Size\tBlock ▁ no . " ) ; for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( " ▁ " + i + 1 + " \t\t " + processSize [ i ] + " \t\t " ) ; if ( allocation [ i ] != - 1 ) System . out . print ( allocation [ i ] + 1 ) ; else System . out . println ( ) ; } }
static void countFreq ( int [ ] a , int n ) { HashMap < Integer , Integer > hm = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) hm . put ( a [ i ] , hm . get ( a [ i ] ) + 1 ) ; int cumul = 0 ; for ( int i = 0 ; i < n ; i ++ ) { cumul += hm . get ( a [ i ] ) ; if ( hm [ a [ i ] ] ) { System . out . print ( a [ i ] + " - > " + cumul ) ; } hm . put ( a [ i ] , 0 ) ; } }
static boolean isSubSeqDivisible ( String str ) { for ( int i = 0 ; i < l ; i ++ ) { for ( int j = i ; j < l ; j ++ ) { for ( int k = j ; k < l ; k ++ ) { if ( arr [ i ] % 8 == 0 ) return true ; else if ( ( arr [ i ] * 10 + arr [ j ] ) % 8 == 0 && i != j ) return true ; else if ( ( arr [ i ] * 100 + arr [ j ] * 10 + arr [ k ] ) % 8 == 0 && i != j && j != k && i != k ) return true ; } } } return false ; }
static int getAbs ( int n ) { int const mask = n >> ( sizeof ( int ) * CHARBIT - 1 ) ; return ( ( n + mask ) ^ mask ) ; }
static boolean isAnBn ( String str ) { int n = str . length ( ) ; int i ; for ( i = 0 ; i < n ; i ++ ) if ( str . charAt ( i ) != ' a ' ) break ; if ( i * 2 != n ) return false ; int j ; for ( j = i ; j < n ; j ++ ) if ( str . charAt ( j ) != ' b ' ) return false ; return true ; }
static int maxSumWO3Consec ( int arr [ ] , int n ) { int sum [ ] = new int [ n ] ; if ( n >= 1 ) sum [ 0 ] = arr [ 0 ] ; if ( n >= 2 ) sum [ 1 ] = arr [ 0 ] + arr [ 1 ] ; if ( n > 2 ) sum [ 2 ] = Math . max ( sum [ 1 ] , Math . max ( arr [ 1 ] + arr [ 2 ] , arr [ 0 ] + arr [ 2 ] ) ) ; for ( int i = 3 ; i < n ; i ++ ) sum [ i ] = Math . max ( sum [ i - 1 ] , sum [ i - 2 ] + arr [ i ] ) , arr [ i ] + arr [ i - 1 ] + sum [ i - 3 ] ) ; return sum [ n - 1 ] ; }
static int nobleInteger ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) continue ; if ( arr [ i ] == n - i - 1 ) return arr [ i ] ; } if ( arr [ n - 1 ] == 0 ) return arr [ n - 1 ] ; return - 1 ; }
public static void productArray ( int arr [ ] , int n ) { if ( n == 1 ) { System . out . println ( 0 ) ; return ; } int i , temp = 1 ; int [ ] prod = new int [ ( sizeof ( int ) * n ) ] ; Arrays . fill ( prod , 0 ) ; for ( i = 0 ; i < n ; i ++ ) { prod [ i ] = temp ; temp *= arr [ i ] ; } temp = 1 ; for ( i = n - 1 ; i >= 0 ; i -- ) { prod [ i ] *= temp ; temp *= arr [ i ] ; } for ( i = 0 ; i < n ; i ++ ) System . out . print ( prod [ i ] + " ▁ " ) ; return ; }
static boolean sortedAfterSwap ( int A [ ] , boolean B [ ] , int n ) { int i , j ; for ( i = 0 ; i < n - 1 ; i ++ ) { if ( B [ i ] ) { j = i ; while ( B [ j ] ) j ++ ; Arrays . sort ( A + i , A + 1 + j ) ; i = j ; } } for ( i = 0 ; i < n ; i ++ ) { if ( A [ i ] != i + 1 ) { return false ; } return true ; }
static int maxSubarrayXOR ( int arr [ ] , int n ) { int ans = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { int curr_xor = 0 ; for ( int j = i ; j < n ; j ++ ) { curr_xor = curr_xor ^ arr [ j ] ; ans = Math . max ( ans , curr_xor ) ; } } return ans ; }
static int minRemovalsDP ( int arr [ ] , int n ) { int longest_start = - 1 , longest_end = 0 ; for ( int start = 0 ; start < n ; start ++ ) { int min = Integer . MAX_VALUE , max = Integer . MIN_VALUE ; for ( int end = start ; end < n ; end ++ ) { int val = arr [ end ] ; if ( val < min ) min = val ; if ( val > max ) max = val ; if ( 2 * min <= max ) break ; if ( end - start > longest_end - longest_start || longest_start == - 1 ) { longest_start = start ; longest_end = end ; } } } if ( longest_start == - 1 ) return n ; return ( n - ( longest_end - longest_start + 1 ) ) ; }
static double surface_area_octahedron ( double side ) { return ( 2 * ( sqrt ( 3 ) ) * ( side * side ) ) ; }
static int countUnique ( int mat [ ] [ ] , int n , int m ) { int rowsum [ ] = new int [ n ] , colsum [ ] = new int [ m ] ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( mat [ i ] [ j ] ) { rowsum [ i ] ++ ; colsum [ j ] ++ ; } int uniquecount = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( mat [ i ] [ j ] && rowsum [ i ] == 1 && colsum [ j ] == 1 ) uniquecount ++ ; return uniquecount ; }
static int remainder ( String str ) { int len = str . length ( ) ; int num , rem = 0 ; for ( int i = 0 ; i < len ; i ++ ) { num = rem * 10 + ( str . charAt ( i ) - '0' ) ; rem = num % 11 ; } return rem ; }
static boolean checkReverse ( int arr [ ] , int n ) { if ( n == 1 ) return true ; int i ; for ( i = 1 ; i < n && arr [ i - 1 ] < arr [ i ] ; i ++ ) ; if ( i == n ) return true ; int j = i ; while ( arr [ j ] < arr [ j - 1 ] ) { if ( i > 1 && arr [ j ] < arr [ i - 2 ] ) return false ; j ++ ; } if ( j == n ) return true ; int k = j ; if ( arr [ k ] < arr [ i - 1 ] ) return false ; while ( k > 1 && k < n ) { if ( arr [ k ] < arr [ k - 1 ] ) return false ; k ++ ; } return true ; }
static double vol_of_octahedron ( double side ) { return ( ( side * side * side ) * ( Math . sqrt ( 2 ) / 3 ) ) ; }
static int maxDifference ( int arr [ ] , int N , int k ) { int M , S = 0 , S1 = 0 , max_difference = 0 ; for ( int i = 0 ; i < N ; i ++ ) S += arr [ i ] ; Arrays . sort ( arr , Collections . reverseOrder ( ) ) ; M = Math . max ( k , N - k ) ; for ( int i = 0 ; i < M ; i ++ ) S1 += arr [ i ] ; max_difference = S1 - ( S - S1 ) ; return max_difference ; }
static int maxSumSubarrayRemovingOneEle ( int arr [ ] , int n ) { int fw [ ] , bw [ ] = new int [ n ] ; int cur_max = arr [ 0 ] , max_so_far = arr [ 0 ] ; fw [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { cur_max = Math . max ( arr [ i ] , cur_max + arr [ i ] ) ; max_so_far = Math . max ( max_so_far , cur_max ) ; bw [ i ] = cur_max ; } cur_max = max_so_far = bw [ n - 1 ] = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) { cur_max = Math . max ( arr [ i ] , cur_max + arr [ i ] ) ; max_so_far = Math . max ( max_so_far , cur_max ) ; bw [ i ] = cur_max ; } int fans = max_so_far ; for ( int i = 1 ; i < n - 1 ; i ++ ) fans = Math . max ( fans , fw [ i - 1 ] + bw [ i + 1 ] ) ; return fans ; }
static int findMaxPoints ( int A [ ] [ ] ) { int P1S [ ] [ ] = new int [ M + 1 ] [ N + 1 ] ; int P1E [ ] [ ] = new int [ M + 1 ] [ N + 1 ] ; memset ( P1S , 0 , sizeof ( P1S ) ) ; memset ( P1E , 0 , sizeof ( P1E ) ) ; int P2S [ ] [ ] = new int [ ] [ ] ; for ( int i = 1 ; i <= N ; i ++ ) for ( int j = 1 ; j <= M ; j ++ ) P1S [ i ] [ j ] = Math . max ( P1S [ i - 1 ] [ j ] , P1S [ i ] [ j - 1 ] ) + A [ i - 1 ] [ j - 1 ] ; for ( int i = N ; i >= 1 ; i -- ) for ( int j = 1 ; j <= M ; j ++ ) P2S [ i ] [ j ] = Math . max ( P2S [ i + 1 ] [ j ] , P2S [ i ] [ j + 1 ] ) + A [ i - 1 ] [ j - 1 ] ; for ( int i = 1 ; i <= N ; i ++ ) for ( int j = M ; j >= 1 ; j -- ) P2E [ i ] [ j ] = Math . max ( P2E [ i - 1 ] [ j ] , P2E [ i ] [ j + 1 ] ) + A [ i - 1 ] [ j - 1 ] ; for ( int i = 2 ; i < N ; i ++ ) { for ( int j = 2 ; j < M ; j ++ ) { int op1 = P1S [ i ] [ j - 1 ] + P1E [ i ] [ j ] ; op1 = P1S [ i ] [ j - 1 ] + P1E [ i ] [ j + 1 ] ; } } int ans = 0 ; for ( int i = 2 ; i < N ; i ++ ) { for ( int j = 2 ; j < M ; j ++ ) { for ( int j = 2 ; j < M ; j ++ ) { int op1 = P1S [ i ] [ j - 1 ] + P1E [ i ] [ j ] ; op1 + P
static int KnapSack ( int val [ ] , int wt [ ] , int n , int W ) { int [ ] [ ] mat = new int [ 2 ] [ W + 1 ] ; int i = 0 ; while ( i < n ) { int j = 0 ; if ( i % 2 != 0 ) { while ( ++ j <= W ) { if ( wt [ i ] <= j ) mat [ 1 ] [ j ] = Math . max ( val [ i ] + mat [ 0 ] [ j - wt [ i ] ] , mat [ 0 ] [ j ] ) ; else mat [ 1 ] [ j ] = mat [ 0 ] [ j ] ; } } else { while ( ++ j <= W ) { if ( wt [ i ] <= j ) mat [ 0 ] [ j ] = Math . max ( val [ i ] + mat [ 1 ] [ j - wt [ i ] ] , mat [ 1 ] [ j ] ) ; else mat [ 0 ] [ j ] = mat [ 1 ] [ j ] ; } } i ++ ; } return ( n % 2 != 0 ) ? mat [ 0 ] [ W ] : mat [ 1 ] [ W ] ; }
static boolean isHeap ( int arr [ ] , int n ) { for ( int i = 0 ; i <= ( n - 2 ) / 2 ; i ++ ) { if ( arr [ 2 * i + 1 ] > arr [ i ] ) return false ; if ( 2 * i + 2 < n && arr [ 2 * i + 2 ] > arr [ i ] ) return false ; } return true ; }
public static void maxProduct ( int arr [ ] , int n ) { if ( n < 2 ) { System . out . println ( " No ▁ pairs ▁ exists \n " ) ; return ; } if ( n == 2 ) { System . out . println ( arr [ 0 ] + " ▁ " + arr [ 1 ] ) ; return ; } int posa = Integer . MIN_VALUE , posb = Integer . MIN_VALUE ; int nega = Integer . MIN_VALUE ; int negb = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > posa ) { posb = posa ; posa = arr [ i ] ; } else if ( arr [ i ] < 0 && Math . abs ( arr [ i ] ) > Math . abs ( nega ) ) { negb = nega ; nega = arr [ i ] ; } else if ( arr [ i ] < 0 && Math . abs ( arr [ i ] ) > Math . abs ( negb ) ) negb = arr [ i ] ; } if ( nega * negb > posa * posb ) System . out . println ( " Max ▁ product ▁ pair ▁ is ▁ { " + nega + " , ▁ " + negb + " } " ) ; else System . out . println ( " Max ▁ product ▁ pair ▁ is ▁ { " + posa + " , ▁ " + posb + " } " ) ; }
static int superSeq ( char [ ] X , char [ ] Y , int m , int n ) { int dp [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( ! i ) { dp [ i ] [ j ] = j ; } else if ( ! j ) { dp [ i ] [ j ] = i ; } else if ( X [ i - 1 ] == Y [ j - 1 ] ) { dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; } else { dp [ i ] [ j ] = 1 + Math . min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) ; } } } return dp [ m ] [ n ] ; }
static int minJumps ( int arr [ ] , int n ) { int jumps [ ] = new int [ n ] ; int min ; jumps [ n - 1 ] = 0 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] == 0 ) jumps [ i ] = Integer . MAX_VALUE ; else if ( arr [ i ] >= n - i - 1 ) jumps [ i ] = 1 ; else { min = Integer . MAX_VALUE ; for ( int j = i + 1 ; j < n && j <= arr [ i ] + i ; j ++ ) { if ( min > jumps [ j ] ) min = jumps [ j ] ; } if ( min != Integer . MAX_VALUE ) jumps [ i ] = min + 1 ; else jumps [ i ] = min ; } } return jumps [ 0 ] ; }
static int minAdjustmentCost ( int A [ ] , int n , int target ) { int dp [ ] [ ] = new int [ n ] [ M + 1 ] ; for ( int j = 0 ; j <= M ; j ++ ) { dp [ 0 ] [ j ] = Math . abs ( j - A [ 0 ] ) ; } for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j <= M ; j ++ ) { dp [ i ] [ j ] = Integer . MAX_VALUE ; for ( int k = Math . max ( j - target , 0 ) ; k <= Math . min ( M , j + target ) ; k ++ ) { dp [ i ] [ j ] = Math . min ( dp [ i ] [ j ] , dp [ i - 1 ] [ k ] + Math . abs ( A [ i ] - j ) ) ; } } int res = Integer . MAX_VALUE ; for ( int j = 0 ; j <= M ; j ++ ) res = Math . min ( res , dp [ n - 1 ] [ j ] ) ; return res ; }
public static int kthSmallest ( int arr [ ] , int n , int k ) { Arrays . sort ( arr ) ; return arr [ k - 1 ] ; }
static int lis ( int arr [ ] , int n ) { int max = 1 ; _lis ( arr , n , & max ) ; return max ; }
static int minCoins ( int coins [ ] , int m , int V ) { if ( V == 0 ) return 0 ; int res = Integer . MAX_VALUE ; for ( int i = 0 ; i < m ; i ++ ) { if ( coins [ i ] <= V ) { int sub_res = Math . min ( coins , m , V - coins [ i ] ) ; if ( sub_res != Integer . MAX_VALUE && sub_res + 1 < res ) res = sub_res + 1 ; } } return res ; }
static int minimum_cost ( int a [ ] , int n ) { int mn = Integer . MAX_VALUE ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { mn = Math . min ( a [ i ] , mn ) ; sum += a [ i ] ; } return mn * ( sum - mn ) ; }
static double getArea ( int a ) { double area = ( M_PI * a * a ) / 4.0 ; return area ; }
static int evenFibSum ( int limit ) { if ( limit < 2 ) return 0 ; long long int ef1 = 0 , ef2 = 2 ; long long int sum = ef1 + ef2 ; while ( ef2 <= limit ) { long long int ef3 = 4 * ef2 + ef1 ; if ( ef3 > limit ) break ; ef1 = ef2 ; ef2 = ef3 ; sum += ef2 ; } return sum ; }
static int findSubArray ( int arr [ ] , int n ) { int sum = 0 ; int maxsize = - 1 , startindex ; for ( int i = 0 ; i < n - 1 ; i ++ ) { sum = ( arr [ i ] == 0 ) ? - 1 : 1 ; for ( int j = i + 1 ; j < n ; j ++ ) { ( arr [ j ] == 0 ) ? ( sum += - 1 ) : ( sum += 1 ) ; if ( sum == 0 && maxsize < j - i + 1 ) { maxsize = j - i + 1 ; startindex = i ; } } } if ( maxsize == - 1 ) System . out . println ( " No ▁ such ▁ subarray " ) ; else System . out . print ( startindex + " ▁ to ▁ " + startindex + maxsize - 1 ) ; return maxsize ; }
static double largestSumOfAverages ( Vector < Integer > A , int K ) { int n = A . size ( ) ; double [ ] pre_sum = new double [ n + 1 ] ; pre_sum [ 0 ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) pre_sum [ i + 1 ] = pre_sum [ i ] + A [ i ] ; double dp [ ] = new double [ n ] ; double sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] = ( pre_sum [ n ] - pre_sum [ i ] ) / ( n - i ) ; } for ( int k = 0 ; k < K - 1 ; k ++ ) for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) { dp [ i ] = Math . max ( dp [ i ] , ( pre_sum [ j ] - pre_sum [ i ] ) / ( j - i ) + dp [ j ] ) ; } return dp [ 0 ] ; }
static int getMinSteps ( int n ) { int table [ ] = new int [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) table [ i ] = n - i ; for ( int i = n ; i >= 1 ; i -- ) { if ( ! ( i % 2 ) ) table [ i / 2 ] = Math . min ( table [ i ] + 1 , table [ i / 2 ] ) ; if ( ! ( i % 3 ) ) table [ i / 3 ] = Math . min ( table [ i ] + 1 , table [ i / 3 ] ) ; } return table [ 1 ] ; }
static int eggDrop ( int n , int k ) { if ( k == 1 || k == 0 ) return k ; if ( n == 1 ) return k ; int min = Integer . MAX_VALUE , x , res ; for ( x = 1 ; x <= k ; x ++ ) { res = Math . max ( eggDrop ( n - 1 , x - 1 ) , eggDrop ( n , k - x ) ) ; if ( res < min ) min = res ; } return min + 1 ; }
static int count ( String s , char c ) { int res = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) if ( s . charAt ( i ) == c ) res ++ ; return res ; }
static int findLength ( String str , int n ) { int [ ] sum = new int [ n + 1 ] ; sum [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum [ i ] = ( sum [ i - 1 ] + str . charAt ( i - 1 ) - '0' ) ; int ans = 0 ; for ( int len = 2 ; len <= n ; len += 2 ) { for ( int i = 0 ; i <= n - len ; i ++ ) { int j = i + len - 1 ; if ( sum [ i + len / 2 ] - sum [ i ] == sum [ i + len ] - sum [ i + len / 2 ] ) ans = Math . max ( ans , len ) ; } } return ans ; }
static int maximumNumberDistinctPrimeRange ( int m , int n ) { long long factorCount [ ] = new long [ n + 1 ] ; boolean [ ] prime = new boolean [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { factorCount [ i ] = 0 ; prime [ i ] = true ; } for ( int i = 2 ; i <= n ; i ++ ) { if ( prime [ i ] == true ) { factorCount [ i ] = 1 ; for ( int j = i * 2 ; j <= n ; j += i ) { factorCount [ j ] ++ ; prime [ j ] = false ; } } } int max = factorCount [ m ] ; int num = m ; for ( int i = m ; i <= n ; i ++ ) { if ( factorCount [ i ] > max ) { max = factorCount [ i ] ; num = i ; } } return max ; }
static long int catalan ( int n ) { if ( n <= 1 ) return 1 ; unsigned long int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) res += catalan ( i ) * catalan ( n - i - 1 ) ; return res ; }
static int minRevolutions ( double r , int x1 , int y1 , int x2 , int y2 ) { double d = Math . sqrt ( ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ) ; return ceil ( d / ( 2 * r ) ) ; }
static int largestKSubmatrix ( int a [ ] [ ] ) { int dp [ ] [ ] = new int [ Row ] [ Col ] ; int result = 0 ; for ( int i = 0 ; i < Row ; i ++ ) { for ( int j = 0 ; j < Col ; j ++ ) { if ( i == 0 || j == 0 ) dp [ i ] [ j ] = 1 ; else { if ( a [ i ] [ j ] == a [ i - 1 ] [ j ] && a [ i ] [ j ] == a [ i - 1 ] [ j - 1 ] && a [ i ] [ j ] == a [ i - 1 ] [ j - 1 ] ) dp [ i ] [ j ] = Math . min ( Math . min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) , dp [ i - 1 ] [ j - 1 ] ) + 1 ; else dp [ i ] [ j ] = 1 ; } } } return result ; }
static int cassini ( int n ) { return ( n & 1 ) ? - 1 : 1 ; }
static int waysToArrange ( int N , int K , int k [ ] ) { int C [ ] [ ] = new int [ N + 1 ] [ N + 1 ] ; int i , j ; for ( i = 0 ; i <= N ; i ++ ) { for ( j = 0 ; j <= i ; j ++ ) { if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) ; } } int dp [ ] ; int count = 0 ; dp [ 0 ] = 1 ; for ( int i = 0 ; i < K ; i ++ ) { dp [ i + 1 ] = ( dp [ i ] * C [ count + k [ i ] - 1 ] [ k [ i ] - 1 ] ) ; count += k [ i ] ; } return dp [ K ] ; }
static void findDimen ( int H , int A ) { if ( H * H < 4 * A ) { System . out . println ( " Not ▁ Possible " ) ; return ; } double apb = Math . sqrt ( H * H + 4 * A ) ; double asb = Math . sqrt ( H * H - 4 * A ) ; System . out . precision ( 2 ) ; System . out . println ( " P ▁ = ▁ " + fixed + ( apb - asb ) / 2.0 + " \n " ) ; System . out . println ( " B ▁ = ▁ " + ( apb + asb ) / 2.0 ) ; System . out . println ( " B ▁ = ▁ " + ( apb + asb ) / 2.0 ) ; System . out . println ( " B ▁ = ▁ " + ( apb + asb ) / 2.0 ) ; }
static int maxTripletSum ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; return arr [ n - 1 ] + arr [ n - 2 ] + arr [ n - 3 ] ; }
public static long long MaxDotProduct ( int A [ ] , int B [ ] , int m , int n ) { long long int dp [ ] [ ] = new long long [ n + 1 ] [ m + 1 ] ; for ( int [ ] rows : dp ) Arrays . fill ( rows , 0 ) ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = i ; j <= m ; j ++ ) dp [ i ] [ j ] = Math . max ( ( dp [ i - 1 ] [ j - 1 ] + ( A [ j - 1 ] * B [ i - 1 ] ) ) , dp [ i ] [ j - 1 ] ) ; return dp [ n ] [ m ] ; }
static int findMinDiff ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int diff = Integer . MAX_VALUE ; for ( int i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i + 1 ] - arr [ i ] < diff ) diff = arr [ i + 1 ] - arr [ i ] ; return diff ; }
static int findLastIndex ( String str , char x ) { for ( int i = str . length ( ) - 1 ; i >= 0 ; i -- ) if ( str . charAt ( i ) == x ) return i ; return - 1 ; }
static int maxLower ( String str ) { int n = str . length ( ) ; int i = 0 ; for ( ; i < n ; i ++ ) { if ( str . charAt ( i ) >= ' A ' && str . charAt ( i ) <= ' Z ' ) { i ++ ; break ; } } int maxCount = 0 ; int [ ] count = new int [ MAX_CHAR ] ; for ( ; i < n ; i ++ ) { if ( str . charAt ( i ) >= ' A ' && str . charAt ( i ) <= ' Z ' ) { int currCount = 0 ; for ( int j = 0 ; j < MAX_CHAR ; j ++ ) if ( count [ j ] > 0 ) currCount ++ ; maxCount = Math . max ( maxCount , currCount ) ; Arrays . fill ( count , 0 ) ; } if ( str . charAt ( i ) >= ' a ' && str . charAt ( i ) <= ' z ' ) count [ str . charAt ( i ) - ' a ' ] ++ ; } return maxCount ; }
static String evenlength ( String n ) { String res = n ; for ( int j = n . length ( ) - 1 ; j >= 0 ; -- j ) res += n . charAt ( j ) ; return res ; }
static double circumference ( double r ) { double cir = 2 * PI * r ; return cir ; }
static void printDistinct ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; for ( int i = 0 ; i < n ; i ++ ) { while ( i < n - 1 && arr [ i ] == arr [ i + 1 ] ) i ++ ; System . out . print ( arr [ i ] + " ▁ " ) ; } }
static int search ( int arr [ ] , int n , int x , int k ) { int i = 0 ; while ( i < n ) { if ( arr [ i ] == x ) return i ; i = i + Math . max ( 1 , Math . abs ( arr [ i ] - x ) / k ) ; } System . out . println ( " number ▁ is ▁ not ▁ present ! " ) ; return - 1 ; }
static int countStrings ( int n ) { int [ ] a = new int [ n ] , b [ ] = new int [ n ] ; a [ 0 ] = b [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { a [ i ] = a [ i - 1 ] + b [ i - 1 ] ; b [ i ] = a [ i - 1 ] ; } return a [ n - 1 ] + b [ n - 1 ] ; }
static int minSum ( int arr [ ] , int n ) { int dp [ ] = new int [ n ] ; if ( n == 1 ) return arr [ 0 ] ; if ( n == 2 ) return Math . min ( arr [ 0 ] , arr [ 1 ] ) ; if ( n == 3 ) return Math . min ( arr [ 0 ] , arr [ 2 ] ) ) ; if ( n == 4 ) return Math . min ( arr [ 0 ] , arr [ 1 ] , arr [ 2 ] , arr [ 3 ] ) ) ; dp [ 0 ] = arr [ 0 ] ; dp [ 1 ] = arr [ 1 ] ; dp [ 2 ] = arr [ 2 ] ; dp [ 3 ] = arr [ 3 ] ; for ( int i = 4 ; i < n ; i ++ ) dp [ i ] = arr [ i ] + Math . min ( Math . min ( dp [ i - 1 ] , dp [ i - 2 ] ) , Math . min ( dp [ i - 3 ] , dp [ i - 4 ] ) ) ; return Math . min ( Math . min ( dp [ n - 1 ] , dp [ n - 2 ] ) , Math . min ( dp [ n - 4 ] , dp [ n - 3 ] ) ) ; return Math . min ( Math . min ( dp [ n - 1 ] , dp [ n - 2 ] ) , Math . min ( dp [ n - 4 ] , dp [ n - 3 ] ) ) ; }
static String printSequence ( String arr [ ] , String input ) { String output = " " ; int n = input . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( input . charAt ( i ) == ' ▁ ' ) output = output + "0" ; else { int position = input . charAt ( i ) - ' A ' ; output = output + arr [ position ] ; } } return output ; }
static int maxcoefficientvalue ( int n ) { int [ ] [ ] C = new int [ n + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= Math . min ( i , n ) ; j ++ ) { if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } int maxvalue = 0 ; for ( int i = 0 ; i <= n ; i ++ ) maxvalue = Math . max ( maxvalue , C [ n ] [ i ] ) ; return maxvalue ; }
static double gcd ( double a , double b ) { if ( a < b ) return gcd ( b , a ) ; if ( fabs ( b ) < 0.001 ) return a ; else return ( gcd ( b , a - floor ( a / b ) * b ) ) ; }
static void sortByPattern ( String str , String pat ) { int [ ] count = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { count [ str . charAt ( i ) - ' a ' ] ++ ; } int index = 0 ; for ( int i = 0 ; i < pat . length ( ) ; i ++ ) { for ( int j = 0 ; j < count [ pat . charAt ( i ) - ' a ' ] ; j ++ ) { str . insert ( index ++ , pat . charAt ( i ) ) ; } } str . setLength ( index ) ; }
static int minJumps ( int arr [ ] , int n ) { int j ; if ( n == 0 || arr [ 0 ] == 0 ) return Integer . MAX_VALUE ; jumps [ 0 ] = 0 ; for ( i = 1 ; i < n ; i ++ ) { jumps [ i ] = Integer . MAX_VALUE ; for ( j = 0 ; j < i ; j ++ ) { if ( i <= j + arr [ j ] && jumps [ j ] != Integer . MAX_VALUE ) { jumps [ i ] = Math . min ( jumps [ i ] , jumps [ j ] + 1 ) ; break ; } } } return jumps [ n - 1 ] ; }
static double find_prob ( int N , float P ) { double dp [ ] = new double [ N + 1 ] ; dp [ 0 ] = 1 ; dp [ 1 ] = 0 ; dp [ 2 ] = P ; dp [ 3 ] = 1 - P ; for ( int i = 4 ; i <= N ; ++ i ) dp [ i ] = ( P ) * dp [ i - 2 ] + ( 1 - P ) * dp [ i - 3 ] ; return dp [ N ] ; }
static int countStrings ( int n ) { int [ ] a = new int [ n ] , b [ ] = new int [ n ] ; a [ 0 ] = b [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { a [ i ] = a [ i - 1 ] + b [ i - 1 ] ; b [ i ] = a [ i - 1 ] ; } return ( 1 << n ) - a [ n - 1 ] - b [ n - 1 ] ; }
static int maximumSegments ( int n , int a , int b , int c ) { int dp [ ] = new int [ n + 1 ] ; dp [ 0 ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( dp [ i ] != - 1 ) { if ( i + a <= n ) dp [ i + a ] = Math . max ( dp [ i ] + 1 , dp [ i + a ] ) ; if ( i + b <= n ) dp [ i + b ] = Math . max ( dp [ i ] + 1 , dp [ i + b ] ) ; if ( i + c <= n ) dp [ i + c ] = Math . max ( dp [ i ] + 1 , dp [ i + c ] ) ; } } return dp [ n ] ; }
static int countWords ( String str , int len ) { int count = 1 ; if ( len == 1 ) return count ; if ( str . charAt ( 0 ) == str . charAt ( 1 ) ) count *= 1 ; else count *= 2 ; for ( int j = 1 ; j < len - 1 ; j ++ ) { if ( str . charAt ( j ) == str . charAt ( j - 1 ) && str . charAt ( j ) == str . charAt ( j + 1 ) ) count *= 1 ; else if ( str . charAt ( j ) == str . charAt ( j - 1 ) || str . charAt ( j ) == str . charAt ( j + 1 ) || str . j - 1 ] == str . charAt ( j + 1 ) ) count *= 2 ; else count *= 3 ; } if ( str . length - 1 ] == str . charAt ( len - 2 ) ) count *= 1 ; else count *= 2 ; return count ; }
static int findMinDiff ( int arr [ ] , int n ) { int diff = Integer . MAX_VALUE ; for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( Math . abs ( arr [ i ] - arr [ j ] ) < diff ) diff = Math . abs ( arr [ i ] - arr [ j ] ) ; return diff ; }
static int maxSum ( int arr [ ] , int n ) { int res = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { int curr_sum = 0 ; for ( int j = 0 ; j < n ; j ++ ) { int index = ( i + j ) % n ; curr_sum += j * arr [ index ] ; } res = Math . max ( res , curr_sum ) ; } return res ; }
static double volumeOfEllipsoid ( float r1 , float r2 , float r3 ) { float pi = 3.14 ; return 1.33 * pi * r1 * r2 * r3 ; }
static int lcsOf3 ( String X , String Y , String Z , int m , int n , int o ) { int L [ ] [ ] = new int [ m + 1 ] [ n + 1 ] [ o + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { for ( int k = 0 ; k <= o ; k ++ ) { if ( i == 0 || j == 0 || k == 0 ) L [ i ] [ j ] [ k ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] && X [ i - 1 ] == Z [ k - 1 ] ) L [ i ] [ j ] [ k ] = L [ i - 1 ] [ j - 1 ] [ k - 1 ] + 1 ; else L [ i ] [ j ] [ k ] = Math . max ( Math . max ( L [ i - 1 ] [ j ] [ k ] , L [ i ] [ j - 1 ] [ k ] ) , L [ i ] [ j ] [ k - 1 ] ) ; } } } return L [ m ] [ n ] [ o ] ; }
static int countEndless ( boolean input [ ] [ ] , int n ) { boolean row [ ] [ ] = new boolean [ n ] [ n ] , col [ ] [ ] = new boolean [ n ] [ n ] ; for ( int j = 0 ; j < n ; j ++ ) { boolean isEndless = 1 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( input [ i ] [ j ] == 0 ) isEndless = 0 ; col [ i ] [ j ] = isEndless ; } } for ( int i = 0 ; i < n ; i ++ ) { boolean isEndless = 1 ; for ( int j = n - 1 ; j >= 0 ; j -- ) { if ( input [ i ] [ j ] == 0 ) isEndless = 0 ; row [ i ] [ j ] = isEndless ; } } for ( int i = 0 ; i < n ; i ++ ) for ( int j = 1 ; j < n ; j ++ ) if ( row [ i ] [ j ] && col [ i ] [ j ] ) ans ++ ; return ans ; }
static void NextFit ( int blockSize [ ] , int m , int processSize [ ] , int n ) { int allocation [ ] = new int [ n ] , j = 0 ; for ( int i = 0 ; i < n ; i ++ ) { while ( j < m ) { if ( blockSize [ j ] >= processSize [ i ] ) { allocation [ i ] = j ; blockSize [ j ] -= processSize [ i ] ; break ; } j = ( j + 1 ) % m ; } } System . out . println ( " \n Process ▁ No . \tProcess ▁ Size\tBlock ▁ no . \n " ) ; for ( int i = 0 ; i < n ; i ++ ) { System . out . println ( " ▁ " + i + 1 + " \t\t " + processSize [ i ] + " \t\t " ) ; if ( allocation [ i ] != - 1 ) System . out . print ( allocation [ i ] + 1 ) ; else System . out . println ( " Not ▁ Allocated " ) ; }
static int lenOfLongestGP ( int set [ ] , int n ) { if ( n < 2 ) return n ; if ( n == 2 ) return ( set [ 1 ] % set [ 0 ] == 0 ) ; Arrays . sort ( set ) ; int L [ ] [ ] = new int [ n ] [ n ] ; int llgp = 1 ; for ( int i = 0 ; i < n ; ++ i ) if ( set [ n - 1 ] % set [ i ] == 0 ) L [ i ] [ n - 1 ] = 2 ; else L [ i ] [ n - 1 ] = 1 ; for ( int j = n - 2 ; j >= 1 ; -- j ) { int i = j - 1 , k = j + 1 ; while ( i >= 0 && k <= n - 1 ) { if ( set [ i ] * set [ k ] < set [ j ] * set [ j ] ) ++ k ; else if ( set [ i ] * set [ k ] > set [ j ] * set [ j ] ) { if ( set [ j ] % set [ i ] == 0 ) L [ i ] [ j ] = 2 ; else L [ i ] [ j ] = 1 ; -- i ; } } while ( i >= 0 ) { if ( set [ j ] % set [ i ] == 0 ) L [ i ] [ j ] = 2 ; else L [ i ] [ j ] = 1 ; -- i ; } } return llgp ; }
static boolean checkValidity ( int a , int b , int c ) { if ( a + b <= c || a + c <= b || b + c <= a ) return false ; else return true ; }
static boolean isDDM ( int m [ ] [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int sum = 0 ; for ( int j = 0 ; j < n ; j ++ ) sum += Math . abs ( m [ i ] [ j ] ) ; sum -= Math . abs ( m [ i ] [ i ] ) ; if ( Math . abs ( m [ i ] [ i ] ) < sum ) return false ; } return true ; }
static int shortestDist ( int graph [ ] [ ] ) { int dist [ ] = new int [ N ] ; dist [ N - 1 ] = 0 ; for ( int i = N - 2 ; i >= 0 ; i -- ) { dist [ i ] = INF ; } for ( int j = i ; j < N ; j ++ ) { if ( graph [ i ] [ j ] == INF ) continue ; dist [ i ] = Math . min ( dist [ i ] , graph [ i ] [ j ] + dist [ j ] ) ; } } return dist [ 0 ] ; }
static long calculateSum ( int n ) { long long int sum = 0 ; sum = 1 << n ; return ( sum - 1 ) ; }
static int kthdigit ( int a , int b , int k ) { int p = ( int ) ( Math . pow ( a , b ) ) ; int count = 0 ; while ( p > 0 && count < k ) { int rem = p % 10 ; count ++ ; if ( count == k ) return rem ; p = p / 10 ; } return 0 ; }
static boolean isEven ( int n ) { return ( n & 1 ) != 0 ) ; }
static void printPath ( String str ) { int i = 0 ; int curX = 0 , curY = 0 ; while ( i < str . length ( ) ) { int nextX = ( str . charAt ( i ) - ' A ' ) / 5 ; int nextY = ( str . charAt ( i ) - ' B ' + 1 ) % 5 ; while ( curX > nextX ) { System . out . print ( " Move ▁ Up " + endl ) ; curX -- ; } while ( curY > nextY ) { System . out . print ( " Move ▁ Left " + endl ) ; curY -- ; } while ( curX < nextX ) { System . out . print ( " Move ▁ Down " + endl ) ; curX ++ ; } while ( curY < nextY ) { System . out . print ( " Move ▁ Right " + endl ) ; curY ++ ; } System . out . println ( " Press ▁ OK " + endl ) ; i ++ ; } }
static boolean checkcircle ( int r , int R , int r1 , int x1 , int y1 ) { int dis = Math . sqrt ( x1 * x1 + y1 * y1 ) ; return ( dis - r1 >= R && dis + r1 <= r ) ; }
static boolean isMinHeap ( int level [ ] , int n ) { for ( int i = ( n / 2 - 1 ) ; i >= 0 ; i -- ) { if ( level [ i ] > level [ 2 * i + 1 ] ) return false ; if ( 2 * i + 2 < n ) { if ( level [ i ] > level [ 2 * i + 2 ] ) return false ; } } return true ; }
static int countSetBits ( int n ) { int i = 0 ; int ans = 0 ; while ( ( 1 << i ) <= n ) { boolean k = 0 ; int change = 1 << i ; for ( int j = 0 ; j <= n ; j ++ ) { ans += k ; if ( change == 1 ) { k = ! k ; change = 1 << i ; } else { change -- ; } } i ++ ; } return ans ; }
static void printSorted ( int a , int b , int c ) { int get_max = Math . max ( a , Math . max ( b , c ) ) ; int get_min = - Math . max ( - a , Math . max ( - b , - c ) ) ; int get_mid = ( a + b + c ) - ( get_max + get_min ) ; System . out . println ( get_min + " ▁ " + get_mid + " ▁ " + get_max ) ; }
static boolean isDivisible ( long long int n ) { while ( n / 100 ) { int last_digit = n % 10 ; n /= 10 ; n += last_digit * 3 ; } return ( n % 29 == 0 ) ; }
static int minSumPath ( Vector < Vector < Integer > > A ) { int [ ] memo = new int [ A . size ( ) ] ; int n = A . size ( ) - 1 ; for ( int i = 0 ; i < A [ n ] . size ( ) ; i ++ ) memo [ i ] = A [ n ] . get ( i ) ; for ( int i = A . size ( ) - 2 ; i >= 0 ; i -- ) for ( int j = 0 ; j < A [ i ] . size ( ) ; j ++ ) memo [ j ] = A . get ( i ) . get ( j ) + Math . min ( memo [ j ] , memo [ j + 1 ] ) ; return memo [ 0 ] ; }
static int minXOR ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int minXor = Integer . MAX_VALUE ; int val = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { val = arr [ i ] ^ arr [ i + 1 ] ; minXor = Math . min ( minXor , val ) ; } return minXor ; }
static void luDecomposition ( int mat [ ] [ ] , int n ) { int lower [ ] [ ] = new int [ n ] [ n ] , upper [ ] [ ] = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int k = i ; k < n ; k ++ ) { int sum = 0 ; for ( int j = 0 ; j < i ; j ++ ) sum += ( lower [ i ] [ j ] * upper [ j ] [ k ] ) ; upper [ i ] [ k ] = mat [ i ] [ k ] - sum ; } for ( int k = i ; k < n ; k ++ ) { if ( i == k ) lower [ i ] [ i ] = 1 ; else { int sum = 0 ; for ( int j = 0 ; j < i ; j ++ ) sum += ( lower [ k ] [ j ] * upper [ j ] [ i ] ) ; lower [ k ] [ i ] = ( mat [ k ] [ i ] - sum ) / upper [ i ] [ i ] ; } } } System . out . println ( " ▁ Lower ▁ Triangular " + setw ( 32 ) + " Upper ▁ Triangular " ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) System . out . print ( 6 ) + lower [ i ] [ j ] + " \t " ) ; System . out . print ( " \t " ) ; } System . out . println ( ) ; }
static long findMinSum ( int a [ ] , int b [ ] , int n ) { Arrays . sort ( a ) ; Arrays . sort ( b ) ; long long int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum + Math . abs ( a [ i ] - b [ i ] ) ; return sum ; }
static int minDist ( int arr [ ] , int n , int x , int y ) { int i , j ; int min_dist = Integer . MAX_VALUE ; for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { if ( ( x == arr [ i ] && y == arr [ j ] || y == arr [ i ] && x == arr [ j ] ) && min_dist > Math . abs ( i - j ) ) { min_dist = Math . abs ( i - j ) ; } } } return min_dist ; }
static boolean isValidString ( String str ) { int freq [ ] = new int [ CHARS ] ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) freq [ str . charAt ( i ) - ' a ' ] ++ ; int i , freq1 = 0 , count_freq1 = 0 ; for ( i = 0 ; i < CHARS ; i ++ ) { if ( freq [ i ] != 0 ) { freq1 = freq [ i ] ; count_freq1 = 1 ; break ; } } int j , freq2 = 0 , count_freq2 = 0 ; for ( j = i + 1 ; j < CHARS ; j ++ ) { if ( freq [ j ] == freq1 ) count_freq1 ++ ; else { count_freq2 = 1 ; freq2 = freq [ j ] ; break ; } } } for ( int k = j + 1 ; k < CHARS ; k ++ ) { if ( freq [ k ] == freq1 ) count_freq1 ++ ; if ( freq [ k ] == freq2 ) count_freq2 ++ ; else return false ; } if ( count_freq1 > 1 && count_freq2 > 1 ) return false ; } return true ; }
static void maximizecube ( int l , int b , int h ) { int side = Math . max ( __gcd ( l , __gcd ( b , h ) ) ; int num = l / side ; num = ( num * b / side ) ; num = ( num * h / side ) ; System . out . println ( side + " ▁ " + num ) ; }
static void rotate ( int arr [ ] , int n ) { int x = arr [ n - 1 ] , i ; for ( i = n - 1 ; i > 0 ; i -- ) arr [ i ] = arr [ i - 1 ] ; arr [ 0 ] = x ; }
static void bonacciseries ( int n , int m ) { int [ ] a = new int [ m ] ; a [ n - 1 ] = 1 ; a [ n ] = 1 ; for ( int i = n + 1 ; i < m ; i ++ ) a [ i ] = 2 * a [ i - 1 ] - a [ i - n - 1 ] ; for ( int i = 0 ; i < m ; i ++ ) System . out . print ( a [ i ] + " ▁ " ) ; }
static int findoptimal ( int N ) { if ( N <= 6 ) return N ; int [ ] screen = new int [ N ] ; int b ; int n ; for ( n = 1 ; n <= 6 ; n ++ ) screen [ n - 1 ] = n ; for ( n = 7 ; n <= N ; n ++ ) { screen [ n - 1 ] = Math . max ( 2 * screen [ n - 4 ] , Math . max ( 3 * screen [ n - 5 ] , 4 * screen [ n - 6 ] ) ) ; } return screen [ N - 1 ] ; }
static int fib ( int n ) { if ( n < 6 ) return f [ n ] ; int t = 5 , fn = 5 ; while ( t < n ) { fn = Math . round ( fn * PHI ) ; t ++ ; } return fn ; }
static int countWays ( int arr [ ] , int m , int N ) { int [ ] count = new int [ N + 1 ] ; count [ 0 ] = 1 ; for ( int i = 1 ; i <= N ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( i >= arr [ j ] ) count [ i ] += count [ i - arr [ j ] ] ; return count [ N ] ; }
static double sumOfSeries ( int n ) { return ( 0.666 ) * ( 1 - 1 / pow ( 10 , n ) ) ; }
static void findDivision ( String str , int a , int b ) { int len = str . length ( ) ; Vector < Integer > lr = new Vector < > ( len + 1 , 0 ) ; lr [ 0 ] = ( str . charAt ( 0 ) - '0' ) % a ; for ( int i = 1 ; i < len ; i ++ ) lr [ i ] = ( ( lr [ i - 1 ] * 10 ) % a + ( str . charAt ( i ) - '0' ) ) % a ; for ( int i = len - 1 ; i >= 0 ; i -- ) { rl [ i ] = ( rl [ i + 1 ] + ( str . charAt ( i ) - '0' ) * power10 ) % b ; power10 = ( power10 * 10 ) % b ; } for ( int i = 0 ; i < len - 1 ; i ++ ) { if ( lr [ i ] != 0 ) continue ; if ( rl [ i + 1 ] == 0 ) { System . out . print ( " YES " ) ; for ( int k = 0 ; k <= i ; k ++ ) System . out . print ( str . charAt ( k ) ) ; System . out . print ( " , ▁ " ) ; for ( int k = i + 1 ; k < len ; k ++ ) System . out . print ( str . charAt ( k ) ) ; System . out . print ( str . charAt ( k ) ) ; } } System . out . println ( " NO " ) ; }
static int count ( String a , String b ) { int m = a . length ( ) ; int n = b . length ( ) ; int [ ] [ ] lookup = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; ++ i ) lookup [ 0 ] [ i ] = 0 ; for ( int i = 0 ; i <= m ; ++ i ) lookup [ i ] [ 0 ] = 1 ; for ( int i = 1 ; i <= m ; ++ i ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( a . charAt ( i - 1 ) == b . charAt ( j - 1 ) ) lookup [ i ] [ j ] = lookup [ i - 1 ] [ j - 1 ] + lookup [ i - 1 ] [ j ] ; else lookup [ i ] [ j ] = lookup [ i - 1 ] [ j ] ; } } return lookup [ m ] [ n ] ; }
static int find_extra_element_index ( int arrA [ ] , int arrB [ ] , int n , int m ) { int extra_element = sum ( arrA , n ) - sum ( arrB , m ) ; return indexOf ( arrA , extra_element , n ) ; }
static int sumNodes ( int l ) { int leafNodeCount = ( int ) Math . pow ( 2 , l - 1 ) ; int sumLastLevel = 0 ; sumLastLevel = ( leafNodeCount * ( leafNodeCount + 1 ) ) / 2 ; int sum = sumLastLevel * l ; return sum ; }
static boolean check ( int degree [ ] , int n ) { int deg_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) deg_sum += degree [ i ] ; return ( 2 * ( n - 1 ) == deg_sum ) ; }
static void findCount ( int n , int sum ) { int start = ( int ) Math . pow ( 10 , n - 1 ) ; int end = ( int ) Math . pow ( 10 , n ) - 1 ; int count = 0 ; int i = start ; while ( i <= end ) { int cur = 0 ; int temp = i ; while ( temp != 0 ) { cur += temp % 10 ; temp = temp / 10 ; } if ( cur == sum ) { count ++ ; i += 9 ; } else i ++ ; } System . out . println ( count ) ; }
static int smallest ( int x , int y , int z ) { int c = 0 ; while ( x && y && z ) { x -- ; y -- ; z -- ; c ++ ; } return c ; }
static int minOperation ( int arr [ ] [ ] ) { int ans = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { for ( int j = M - 1 ; j >= 0 ; j -- ) { if ( arr [ i ] [ j ] == 0 ) { ans ++ ; for ( int k = 0 ; k <= i ; k ++ ) { for ( int h = 0 ; h <= j ; h ++ ) { if ( arr [ k ] [ h ] == 1 ) arr [ k ] [ h ] = 0 ; else arr [ k ] [ h ] = 1 ; } } } } return ans ; }
static int nextPowerOf2 ( int n ) { int p = 1 ; if ( n && ! ( n & ( n - 1 ) ) ) return n ; while ( p < n ) p <<= 1 ; return p ; }
static int numberofways ( int n , int m ) { int dp [ ] [ ] = new int [ n + 2 ] [ n + 2 ] ; dp [ 0 ] [ n + 1 ] = 1 ; for ( int k = n ; k >= m ; k -- ) { for ( int i = 0 ; i <= n ; i ++ ) { dp [ i ] [ k ] = dp [ i ] [ k + 1 ] ; if ( i - k >= 0 ) dp [ i ] [ k ] = ( dp [ i ] [ k ] + dp [ i - k ] [ k ] ) ; } } return dp [ n ] [ m ] ; }
static void generate_derangement ( int N ) { int [ ] S = new int [ N + 1 ] ; for ( int i = 1 ; i <= N ; i ++ ) S [ i ] = i ; int [ ] D = new int [ N + 1 ] ; for ( int i = 1 ; i <= N ; i += 2 ) { if ( i == N && i % N != 0 ) { int temp = D [ N ] D [ N ] = D [ N - 1 ] ; D [ N - 1 ] = temp ; } else { D [ i ] = i + 1 ; D [ i + 1 ] = i ; } } for ( int i = 1 ; i <= N ; i ++ ) System . out . println ( " % d ▁ " , D [ i ] ) ; System . out . println ( ) ; }
static int countTriangle ( int graph [ ] [ ] , boolean isDirected ) { int count_Triangle = 0 ; for ( int i = 0 ; i < V ; i ++ ) { for ( int j = 0 ; j < V ; j ++ ) { for ( int k = 0 ; k < V ; k ++ ) { if ( graph [ i ] [ j ] && graph [ j ] [ k ] && graph [ k ] [ i ] ) count_Triangle ++ ; } } } isDirected ? count_Triangle /= 3 : count_Triangle /= 6 ; return count_Triangle ; }
static int leonardo ( int n ) { if ( n == 0 || n == 1 ) return 1 ; return leonardo ( n - 1 ) + leonardo ( n - 2 ) + 1 ; }
static int findLargestPlus ( int mat [ ] [ ] ) { int left [ ] [ ] , right [ ] [ ] = new int [ N ] [ N ] , top [ ] [ ] , bottom [ ] [ ] ; for ( int i = 0 ; i < N ; i ++ ) { top [ 0 ] [ i ] = mat [ 0 ] [ i ] ; bottom [ N - 1 ] [ i ] = mat [ N - 1 ] [ i ] ; left [ i ] [ 0 ] = mat [ i ] [ 0 ] ; right [ i ] [ N - 1 ] = mat [ i ] [ N - 1 ] ; } for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 1 ; j < N ; j ++ ) { if ( mat [ i ] [ j ] == 1 ) left [ i ] [ j ] = left [ i ] [ j - 1 ] + 1 ; else left [ i ] [ j ] = 0 ; if ( mat [ j ] [ i ] == 1 ) top [ j ] [ i ] = top [ j - 1 ] [ i ] + 1 ; else top [ j ] [ i ] = 0 ; j = N - 1 - j ; if ( mat [ i ] [ j ] == 1 ) bottom [ j ] [ i ] = bottom [ j + 1 ] [ i ] + 1 ; else bottom [ j ] [ i ] = 0 ; if ( mat [ i ] [ j ] == 1 ) right [ i ] [ j ] = right [ i ] [ j + 1 ] + 1 ; else right [ i ] [ j ] = 0 ; j = N - 1 - j ; } } int n = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { int len = Math . min ( top [ i ] [ j ] , bottom [ i ] [ j ] ) , Math . min ( left [ i ] [ j ] , right [ i ] [ j ] ) ; if ( len > n ) n = len ; } } if ( n ) return 4 * ( n - 1 ) + 1 ) + 1 ) ; } return 0 ; }
static int sumAtKthLevel ( String tree , int k ) { int level = - 1 ; int sum = 0 ; int n = tree . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( tree . charAt ( i ) == ' ( ' ) level ++ ; else if ( tree . charAt ( i ) == ' ( ' ) level -- ; else { if ( level == k ) sum += ( tree . charAt ( i ) - '0' ) ; } } return sum ; }
static int countWays ( String s ) { int [ ] count = new int [ 26 ] ; for ( char x : s ) { count [ x - ' a ' ] ++ ; } count [ s . charAt ( 0 ) - ' a ' ] = 1 ; int ans = 1 ; for ( int i = 0 ; i < 26 ; ++ i ) if ( count [ i ] != 0 ) ans *= count [ i ] ; return ans ; }
static int countWays ( int n , int m ) { int [ ] count = new int [ n + 1 ] ; count [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i > m ) count [ i ] = count [ i - 1 ] + count [ i - m ] ; else if ( i < m ) count [ i ] = 1 ; else count [ i ] = 2 ; } return count [ n ] ; }
static int nextPowerOf2 ( int n ) { int p = 1 ; if ( n && ! ( n & ( n - 1 ) ) ) return n ; while ( p < n ) p <<= 1 ; return p ; }
static void longest ( int [ ] a , int n , int k ) { HashMap < Integer , Integer > freq = new HashMap < Integer , Integer > ( ) ; int start = 0 , end = 0 , now = 0 , l = 0 ; for ( int i = 0 ; i < n ; i ++ ) { freq . put ( a [ i ] , freq . get ( a [ i ] ) + 1 ) ; if ( freq . containsKey ( a [ i ] ) ) now ++ ; while ( now > k ) { freq . put ( a [ l ] , freq . get ( a [ l ] ) - 1 ) ; if ( freq . get ( a [ l ] ] == 0 ) now -- ; l ++ ; } if ( i - l + 1 >= end - start + 1 ) end = i , start = l ; } for ( int i = start ; i <= end ; i ++ ) System . out . print ( a [ i ] + " ▁ " ) ; }
static int findWays ( int m , int n , int x ) { int table [ ] [ ] = new int [ n + 1 ] [ x + 1 ] ; for ( int [ ] rows : table ) Arrays . fill ( rows , 0 ) ; for ( int j = 1 ; j <= m && j <= x ; j ++ ) table [ 1 ] [ j ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) for ( int j = 1 ; j <= x ; j ++ ) for ( int k = 1 ; k <= m && k < j ; k ++ ) table [ i ] [ j ] += table [ i - 1 ] [ j - k ] ; return table [ n ] [ x ] ; }
static boolean checkCorrectOrNot ( String s ) { int [ ] count = new int [ MAX_CHAR ] ; int n = s . length ( ) ; if ( n == 1 ) return true ; for ( int i = 0 , j = n - 1 ; i < j ; i ++ , j -- ) { count [ s . charAt ( i ) - ' a ' ] ++ ; count [ s . charAt ( j ) - ' a ' ] -- ; } for ( int i = 0 ; i < MAX_CHAR ; i ++ ) if ( count [ i ] != 0 ) return false ; return true ; }
static int findNumberOfTriangles ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int count = 0 ; for ( int i = 0 ; i < n - 2 ; ++ i ) { int k = i + 2 ; for ( int j = i + 1 ; j < n ; ++ j ) { while ( k < n && arr [ i ] + arr [ j ] > arr [ k ] ) ++ k ; if ( k > j ) count += k - j - 1 ; } } return count ; }
static int countWays ( int n ) { int A [ ] , B [ ] = new int [ n + 1 ] ; A [ 0 ] = 1 ; A [ 1 ] = 0 ; B [ 0 ] = 0 ; B [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { A [ i ] = A [ i - 2 ] + 2 * B [ i - 1 ] ; B [ i ] = A [ i - 1 ] + B [ i - 2 ] ; } return A [ n ] ; }
static int minValue ( int A [ ] , int B [ ] , int n ) { Arrays . sort ( A ) ; Arrays . sort ( B ) ; int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) result += ( A [ i ] * B [ n - i - 1 ] ) ; return result ; }
static boolean isOneFlip ( String str ) { int sum = 0 ; int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) sum += str . charAt ( i ) - '0' ; return ( sum == n - 1 || sum == 1 ) ; }
static int MatrixChainOrder ( int p [ ] , int i , int j ) { if ( i == j ) return 0 ; int k ; int min = Integer . MAX_VALUE ; int count ; for ( k = i ; k < j ; k ++ ) { count = MatrixChainOrder ( p , i , k ) + MatrixChainOrder ( p , k + 1 , j ) + p [ i - 1 ] * p [ k ] * p [ j ] ; if ( count < min ) min = count ; } return min ; }
static void worstFit ( int blockSize [ ] , int m , int processSize [ ] , int n ) { int allocation [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { int wstIdx = - 1 ; for ( int j = 0 ; j < m ; j ++ ) { if ( blockSize [ j ] >= processSize [ i ] ) { if ( wstIdx == - 1 ) wstIdx = j ; else if ( blockSize [ wstIdx ] < blockSize [ j ] ) wstIdx = j ; } } if ( wstIdx != - 1 ) { allocation [ i ] = wstIdx ; blockSize [ wstIdx ] -= processSize [ i ] ; } } System . out . println ( " Process ▁ No . \tProcess ▁ Size\tBlock ▁ no . " ) ; for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( " ▁ " + i + 1 + " \t\t " + processSize [ i ] + " \t\t " ) ; if ( allocation [ i ] != - 1 ) System . out . print ( allocation [ i ] + 1 ) ; else System . out . println ( ) ; } }
static void prefixSum2D ( int a [ ] [ ] ) { int psa [ ] [ ] = new int [ R ] [ C ] ; psa [ 0 ] [ 0 ] = a [ 0 ] [ 0 ] ; for ( int i = 1 ; i < C ; i ++ ) psa [ 0 ] [ i ] = psa [ 0 ] [ i - 1 ] + a [ 0 ] [ i ] ; for ( int i = 0 ; i < R ; i ++ ) psa [ i ] [ 0 ] = psa [ i - 1 ] [ 0 ] + a [ i ] [ 0 ] ; for ( int i = 1 ; i < R ; i ++ ) { for ( int j = 1 ; j < C ; j ++ ) psa [ i ] [ j ] = psa [ i - 1 ] [ j ] + psa [ i ] [ j - 1 ] - psa [ i - 1 ] [ j - 1 ] + a [ i ] [ j ] ; } for ( int i = 0 ; i < R ; i ++ ) { for ( int j = 0 ; j < C ; j ++ ) System . out . print ( psa [ i ] [ j ] + " ▁ " ) ; System . out . println ( ) ; } }
static int isMultipleOf3 ( int n ) { int odd_count = 0 ; int even_count = 0 ; if ( n < 0 ) n = - n ; if ( n == 0 ) return 1 ; if ( n == 1 ) return 0 ; while ( n ) { if ( n & 1 ) odd_count ++ ; if ( n & 2 ) even_count ++ ; n = n >> 2 ; } return isMultipleOf3 ( Math . abs ( odd_count - even_count ) ) ; }
static int longestSubsequenceCommonSegment ( int k , String s1 , String s2 ) { int n = s1 . length ( ) ; int m = s2 . length ( ) ; int [ ] lcs = new int [ n + 1 ] [ m + 1 ] ; int [ ] cnt = new int [ n + 1 ] [ m + 1 ] ; for ( int [ ] rows : lcs ) Arrays . fill ( rows , 0 ) ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { lcs [ i ] [ j ] = Math . max ( lcs [ i - 1 ] [ j ] , lcs [ i ] [ j - 1 ] ) ; if ( s1 [ i - 1 ] == s2 [ j - 1 ] ) cnt [ i ] [ j ] = cnt [ i - 1 ] [ j - 1 ] + 1 ; if ( cnt [ i ] [ j ] >= k ) { for ( int a = k ; a <= cnt [ i ] [ j ] ; a ++ ) lcs [ i ] [ j ] = Math . max ( lcs [ i ] [ j ] , lcs [ i - a ] [ j - a ] + a ) ; } } } return lcs [ n ] [ m ] ; }
static int lcsOf3 ( int i , int j , int k ) { if ( i == - 1 || j == - 1 || k == - 1 ) return 0 ; if ( dp [ i ] [ j ] [ k ] != - 1 ) return dp [ i ] [ j ] [ k ] ; if ( X [ i ] == Y [ j ] && Y [ j ] == Z [ k ] ) return dp [ i ] [ j ] [ k ] = 1 + lcsOf3 ( i - 1 , j - 1 , k - 1 ) ; else return dp [ i ] [ j ] [ k ] = Math . max ( Math . max ( lcsOf3 ( i - 1 , j , k ) , lcsOf3 ( i , j - 1 , k ) ) , lcsOf3 ( i , j , k - 1 ) ) ; }
static void findLarger ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; for ( int i = n - 1 ; i >= n / 2 ; i -- ) System . out . print ( arr [ i ] + " ▁ " ) ; }
static int maxProductSubset ( int a [ ] , int n ) { if ( n == 1 ) return a [ 0 ] ; int max_neg = Integer . MIN_VALUE ; int count_neg = 0 , count_zero = 0 ; int prod = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) { count_zero ++ ; continue ; } if ( a [ i ] < 0 ) { count_neg ++ ; max_neg = Math . max ( max_neg , a [ i ] ) ; } prod = prod * a [ i ] ; } if ( count_zero == n ) return 0 ; if ( count_neg & 1 ) { if ( count_neg == 1 && count_zero > 0 && count_zero + count_neg == n ) return 0 ; prod = prod / max_neg ; } return prod ; }
static int russianPeasant ( int a , int b ) { int res = 0 ; while ( b > 0 ) { if ( b & 1 ) res = res + a ; a = a << 1 ; b = b >> 1 ; } return res ; }
public static double distance ( long double lat1 , long double long1 , long double lat2 , long double long2 ) { lat1 = toRadians ( lat1 ) ; long2 = toRadians ( long2 ) ; long double dlong = long2 - long1 ; long double dlat = lat2 - lat1 ; long double ans = Math . pow ( sin ( dlat / 2 ) , 2 ) + cos ( lat1 ) * cos ( lat2 ) * pow ( sin ( dlong / 2 ) , 2 ) ; ans = 2 * asin ( sqrt ( ans ) ) ; long double R = 6371 ; ans = ans * R ; return ans ; }
static boolean isPowerOfTwo ( int n ) { if ( n == 0 ) return 0 ; while ( n != 1 ) { if ( n % 2 != 0 ) return 0 ; n = n / 2 ; } return 1 ; }
static void checkPoint ( int radius , int x , int y , float percent , float startAngle ) { float endAngle = 360 / percent + startAngle ; float polarradius = Math . sqrt ( x * x + y * y ) ; float Angle = atan ( y / x ) ; if ( Angle >= startAngle && Angle <= endAngle && polarradius < radius ) System . out . println ( " Point ▁ ( % d , ▁ % d ) ▁ exist ▁ in ▁ the ▁ circle ▁ sector \n " , x , y ) ; else System . out . println ( " Point ▁ ( % d , ▁ % d ) ▁ does ▁ not ▁ exist ▁ in ▁ the ▁ circle ▁ sector \n " , x , y ) ; }
static int findSum ( int n ) { int arr [ ] [ ] = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) arr [ i ] [ j ] = Math . abs ( i - j ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) sum += arr [ i ] [ j ] ; return sum ; }
static int discreteLogarithm ( int a , int b , int m ) { int n = ( int ) Math . sqrt ( m ) + 1 ; int an = 1 ; for ( int i = 0 ; i < n ; ++ i ) an = ( an * a ) % m ; HashMap < Integer , Integer > value = new HashMap < Integer , Integer > ( ) ; for ( int i = 1 , cur = an ; i <= n ; ++ i ) { if ( ! value [ cur ] ) value [ cur ] = i ; cur = ( cur * an ) % m ; } for ( int i = 0 , cur = b ; i <= n ; ++ i ) { if ( value [ cur ] ) { int ans = value [ cur ] * n - i ; if ( ans < m ) return ans ; } cur = ( cur * a ) % m ; } return - 1 ; }
boolean isPossibleTriangle ( int arr [ ] , int N ) { if ( N < 3 ) return false ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < N - 2 ; i ++ ) if ( arr [ i ] + arr [ i + 1 ] > arr [ i + 2 ] ) return true ; return false ; }
static int numOfIncSubseqOfSizeK ( int arr [ ] , int n , int k ) { int dp [ ] [ ] = new int [ k ] [ n ] , sum = 0 ; for ( int [ ] rows : dp ) Arrays . fill ( rows , 0 ) ; for ( int i = 0 ; i < n ; i ++ ) dp [ 0 ] [ i ] = 1 ; for ( int l = 1 ; l < k ; l ++ ) { for ( int i = l ; i < n ; i ++ ) { dp [ l ] [ i ] = 0 ; for ( int j = l - 1 ; j < i ; j ++ ) { if ( arr [ j ] < arr [ i ] ) { dp [ l ] [ i ] += dp [ l - 1 ] [ j ] ; } } } for ( int i = k - 1 ; i < n ; i ++ ) sum += dp [ k - 1 ] [ i ] ; return sum ; }
static int solve ( char X [ ] , char Y [ ] , int l , int r , int k , int dp [ ] [ ] ) { if ( ! k ) return 0 ; if ( l < 0 | r < 0 ) return 1e9 ; if ( dp [ l ] [ r ] [ k ] != - 1 ) return dp [ l ] [ r ] [ k ] ; int cost = ( X [ l ] - ' a ' ) ^ ( Y [ r ] - ' a ' ) ; return dp [ l ] [ r ] [ k ] = Math . min ( { cost + solve ( X , Y , l - 1 , r - 1 , k - 1 , dp ) , solve ( X , Y , l - 1 , r , k , dp ) } ) ; }
static boolean isSubSequence ( char str1 [ ] , char str2 [ ] , int m , int n ) { if ( m == 0 ) return true ; if ( n == 0 ) return false ; if ( str1 [ m - 1 ] == str2 [ n - 1 ] ) return isSubSequence ( str1 , str2 , m - 1 , n - 1 ) ; return isSubSequence ( str1 , str2 , m , n - 1 ) ; }
static int minProductSubset ( int a [ ] , int n ) { if ( n == 1 ) return a [ 0 ] ; int max_neg = Integer . MIN_VALUE ; int min_pos = Integer . MAX_VALUE ; int count_neg = 0 , count_zero = 0 ; int prod = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) { count_zero ++ ; continue ; } if ( a [ i ] < 0 ) { count_neg ++ ; max_neg = Math . max ( max_neg , a [ i ] ) ; } if ( a [ i ] > 0 ) min_pos = Math . min ( min_pos , a [ i ] ) ; prod = prod * a [ i ] ; } if ( count_zero == n || ( count_neg == 0 && count_zero > 0 ) ) return 0 ; if ( count_neg == 0 ) return min_pos ; if ( ! ( count_neg & 1 ) && count_neg != 0 ) { prod = prod / max_neg ; } return prod ; }
static int findDigits ( int n ) { if ( n < 0 ) return 0 ; if ( n <= 1 ) return 1 ; double digits = 0 ; for ( int i = 2 ; i <= n ; i ++ ) digits += log10 ( i ) ; return floor ( digits ) + 1 ; }
static void mergeTwoHalf ( int A [ ] , int n ) { Arrays . sort ( A ) ; Arrays . sort ( A ) ; }
static int minPerimeter ( int n ) { int l = Math . sqrt ( n ) ; int sq = l * l ; if ( sq == n ) return l * 4 ; else { long long int row = n / l ; long long int perimeter = 2 * ( l + row ) ; if ( n % l != 0 ) perimeter += 2 ; return perimeter ; } }
static void possibleOrNot ( long a1 , long long a2 , long b1 , long b2 , long long c1 , long c2 ) { long long dis1 = Math . pow ( b1 - a1 , 2 ) + Math . pow ( b2 - a2 , 2 ) ; long long dis2 = Math . pow ( c1 - b1 , 2 ) + Math . pow ( c2 - b2 , 2 ) ; if ( dis1 != dis2 ) System . out . println ( " No " ) ; else if ( b1 == ( ( a1 + c1 ) / 2.0 ) && b2 == ( ( a2 + c2 ) / 2.0 ) ) System . out . println ( " Yes " ) ; }
static int countSquares ( int a , int b ) { return ( floor ( sqrt ( b ) ) - ceil ( sqrt ( a ) ) + 1 ) ; }
static int countStrings ( int n , int k ) { int dp [ ] [ ] = new int [ n + 1 ] [ k + 1 ] [ 2 ] ; dp [ 0 ] [ 0 ] = 1 ; dp [ 1 ] [ 0 ] [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { dp [ i ] [ j ] [ 0 ] = dp [ i - 1 ] [ j ] [ 0 ] + dp [ i - 1 ] [ j ] [ 1 ] ; dp [ i ] [ j ] [ 1 ] = dp [ i - 1 ] [ j ] [ 0 ] ; if ( j - 1 >= 0 ) { dp [ i ] [ j ] [ 1 ] += dp [ i - 1 ] [ j - 1 ] [ 1 ] ; } } return dp [ n ] [ k ] [ 0 ] + dp [ n ] [ k ] [ 1 ] ; }
static void findSmallestRange ( int arr [ ] [ ] , int n , int k ) { int i , minval , maxval , minrange , minel , maxel , flag , minind ; for ( i = 0 ; i <= k ; i ++ ) ptr [ i ] = 0 ; minrange = Integer . MAX_VALUE ; while ( 1 ) { minind = - 1 ; minval = Integer . MAX_VALUE ; maxval = Integer . MIN_VALUE ; flag = 0 ; for ( i = 0 ; i < k ; i ++ ) { if ( ptr [ i ] == n ) { flag = 1 ; break ; } if ( ptr [ i ] < n && arr [ i ] [ ptr [ i ] ] < minval ) { minind = i ; minval = arr [ i ] [ ptr [ i ] ] ; } if ( ptr [ i ] < n && arr [ i ] [ ptr [ i ] ] > maxval ) { maxval = arr [ i ] [ ptr [ i ] ] ; } } if ( flag ) break ; ptr [ minind ] ++ ; if ( ( maxval - minval ) < minrange ) { minel = minval ; maxel = maxval ; minrange = maxel - minel ; } } System . out . println ( " The ▁ smallest ▁ range ▁ is ▁ [ % d ▁ , ▁ ] ) ; }
static void maxelement ( int no_of_rows , int arr [ ] [ ] ) { int i = 0 ; int max = 0 ; int [ ] result = new int [ no_of_rows ] ; while ( i < no_of_rows ) { for ( int j = 0 ; j < N ; j ++ ) { if ( arr [ i ] [ j ] > max ) { max = arr [ i ] [ j ] ; } } result [ i ] = max ; max = 0 ; i ++ ; } printArray ( result , no_of_rows ) ; }
boolean findthepath ( char [ ] S , int v ) { result [ 0 ] = v + '0' ; for ( int i = 1 ; i < S . length ; i ++ ) { if ( adj [ v ] [ S [ i ] - ' A ' ] || adj [ S [ i ] - ' A ' ] [ v ] ) { v = S [ i ] - ' A ' ; } else if ( adj [ v ] [ S [ i ] - ' A ' + 5 ] || adj [ S [ i ] - ' A ' + 5 ] [ v ] ) { v = S [ i ] - ' A ' + 5 ; } else return false ; result [ i ] = v + '0' ; } return true ; }
static int getMissingNo ( int a [ ] , int n ) { int total = ( n + 1 ) * ( n + 2 ) / 2 ; for ( int i = 0 ; i < n ; i ++ ) total -= a [ i ] ; return total ; }
static void fitOrNotFit ( int R , int r , int x , int y , int rad ) { double val = Math . sqrt ( Math . pow ( x , 2 ) + Math . pow ( y , 2 ) ) ; if ( val + rad <= R && val - rad >= R - r ) System . out . println ( " Fits \n " ) ; else System . out . println ( " Doesn ' t ▁ Fit \n " ) ; }
static int findPosition ( int k , int n ) { long f1 = 0 , f2 = 1 , f3 ; for ( int i = 2 ; i <= MAX ; i ++ ) { f3 = f1 + f2 ; f1 = f2 ; f2 = f3 ; if ( f2 % k == 0 ) return n * i ; } return Integer . MAX_VALUE ; }
static int countManipulations ( String s1 , String s2 ) { int count = 0 ; int [ ] char_count = new int [ 26 ] ; for ( int i = 0 ; i < 26 ; i ++ ) { char_count [ i ] = 0 ; } for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) { char_count [ s1 . charAt ( i ) - ' a ' ] ++ ; } for ( int i = 0 ; i < s2 . length ( ) ; i ++ ) { char_count [ s2 . charAt ( i ) - ' a ' ] -- ; if ( char_count [ s2 . charAt ( i ) - ' a ' ] < 0 ) count ++ ; } return count ; }
static int count ( int n ) { int table [ ] = new int [ n + 1 ] , i ; for ( int j = 0 ; j < n + 1 ; j ++ ) table [ j ] = 0 ; table [ 0 ] = 1 ; for ( i = 3 ; i <= n ; i ++ ) table [ i ] += table [ i - 3 ] ; for ( i = 5 ; i <= n ; i ++ ) table [ i ] += table [ i - 5 ] ; for ( i = 10 ; i <= n ; i ++ ) table [ i ] += table [ i - 10 ] ; return table [ n ] ; }
static int findLongestRepeatingSubSeq ( String str ) { int n = str . length ( ) ; int dp [ ] [ ] = new int [ n + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= n ; j ++ ) { dp [ i ] [ j ] = 0 ; } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( str . charAt ( i - 1 ) == str . charAt ( j - 1 ) && i != j ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = Math . max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ; } } return dp [ n ] [ n ] ; }
static int jumpSearch ( int arr [ ] , int x , int n ) { int step = Math . sqrt ( n ) ; int prev = 0 ; while ( arr [ Math . min ( step , n ) - 1 ] < x ) { prev = step ; step += sqrt ( n ) ; if ( prev >= n ) return - 1 ; } while ( arr [ prev ] < x ) { prev ++ ; if ( prev == Math . min ( step , n ) ) return - 1 ; } if ( arr [ prev ] == x ) return prev ; return - 1 ; }
static int find ( boolean arr [ ] [ ] ) { int i = 0 , j = n - 1 ; int res = - 1 ; while ( i < n && j >= 0 ) { if ( arr [ i ] [ j ] == 0 ) j -- ; if ( j == - 1 ) { res = i ; break ; } else i ++ ; } else { while ( i < n && ( arr [ i ] [ j ] == 1 || i == j ) ) i ++ ; if ( i == n ) { res = j ; break ; } else j -- ; } } if ( res == - 1 ) return res ; for ( int i = 0 ; i < n ; i ++ ) if ( res != i && arr [ i ] [ res ] != 1 ) return - 1 ; for ( int j = 0 ; j < n ; j ++ ) if ( res != j && arr [ res ] [ j ] != 0 ) return - 1 ; return res ; }
static void printArray ( int [ ] a , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( a [ i ] + " ▁ " ) ; System . out . println ( ) ; return ; }
static void sortSquares ( int arr [ ] , int n ) { int K = 0 ; for ( K = 0 ; K < n ; K ++ ) if ( arr [ K ] >= 0 ) break ; int i = K - 1 ; int j = K ; int ind = 0 ; int temp [ ] = new int [ n ] ; while ( i >= 0 && j < n ) { if ( arr [ i ] * arr [ i ] < arr [ j ] * arr [ j ] ) { temp [ ind ] = arr [ i ] * arr [ i ] ; i -- ; } else { temp [ ind ] = arr [ j ] * arr [ j ] ; j ++ ; } ind ++ ; } while ( i >= 0 ) { temp [ ind ] = arr [ i ] * arr [ i ] ; i -- ; ind ++ ; } while ( j < n ) { temp [ ind ] = arr [ j ] * arr [ j ] ; j ++ ; ind ++ ; } for ( i = 0 ; i < n ; i ++ ) arr [ i ] = temp [ i ] ; }
static char maxRepeating ( String str ) { int n = str . length ( ) ; int count = 0 ; char res = str . charAt ( 0 ) ; int cur_count = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i < n - 1 && str . charAt ( i ) == str . charAt ( i + 1 ) ) cur_count ++ ; else { if ( cur_count > count ) { count = cur_count ; res = str . charAt ( i ) ; } cur_count = 1 ; } } return res ; }
static uint_t snoob ( uint_t x ) { uint_t rightOne ; uint_t nextHigherOneBit ; uint_t rightOnesPattern ; uint_t next = 0 ; if ( x ) { rightOne = x & - ( signed ) x ; nextHigherOneBit = x + rightOne ; rightOnesPattern = x ^ nextHigherOneBit ; rightOnesPattern = ( rightOnesPattern ) / rightOne ; rightOnesPattern >>= 2 ; next = nextHigherOneBit | rightOnesPattern ; } return next ; }
static boolean isInorder ( int arr [ ] , int n ) { if ( n == 0 || n == 1 ) return true ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i - 1 ] > arr [ i ] ) return false ; return true ; }
static int lis ( int arr [ ] , int n ) { int max = 1 ; _lis ( arr , n , & max ) ; return max ; }
static int nCrModp ( int n , int r , int p ) { int [ ] C = new int [ r + 1 ] ; C [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = Math . min ( i , r ) ; j > 0 ; j -- ) C [ j ] = ( C [ j ] + C [ j - 1 ] ) % p ; } return C [ r ] ; }
static int binarySearch ( int arr [ ] , int l , int r , int x ) { while ( l <= r ) { int m = l + ( r - l ) / 2 ; if ( arr [ m ] == x ) return m ; if ( arr [ m ] < x ) l = m + 1 ; else r = m - 1 ; } return - 1 ; }
static int minXOR ( int arr [ ] , int n ) { int min_xor = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) min_xor = Math . min ( min_xor , arr [ i ] ^ arr [ j ] ) ; return min_xor ; }
static void rearrange ( int arr [ ] , int n ) { int temp [ ] = new int [ n ] ; int small = 0 , large = n - 1 ; int flag = true ; for ( int i = 0 ; i < n ; i ++ ) { if ( flag ) temp [ i ] = arr [ large -- ] ; else temp [ i ] = arr [ small ++ ] ; flag = ! flag ; } for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = temp [ i ] ; }
static int LCSubStr ( char [ ] X , char [ ] Y , int m , int n ) { int LCSuff [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; int result = 0 ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 || j == 0 ) LCSuff [ i ] [ j ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) { LCSuff [ i ] [ j ] = LCSuff [ i - 1 ] [ j - 1 ] + 1 ; result = Math . max ( result , LCSuff [ i ] [ j ] ) ; } else LCSuff [ i ] [ j ] = 0 ; } } return result ; }
static int patternCount ( String str ) { char last = str . charAt ( 0 ) ; int i = 1 , counter = 0 ; while ( i < str . length ( ) ) { if ( str . charAt ( i ) == '0' && last == '1' ) { while ( str . charAt ( i ) == '0' ) i ++ ; if ( str . charAt ( i ) == '1' ) counter ++ ; } last = str . charAt ( i ) ; i ++ ; } return counter ; }
static void longestSubseqWithK ( String str , int k ) { int n = str . length ( ) ; int [ ] freq = new int [ MAX_CHARS ] ; for ( int i = 0 ; i < n ; i ++ ) freq [ str . charAt ( i ) - ' a ' ] ++ ; for ( int i = 0 ; i < n ; i ++ ) if ( freq [ str . charAt ( i ) - ' a ' ] >= k ) System . out . print ( str . charAt ( i ) ) ; }
static int nextPowerOf2 ( int n ) { unsigned count = 0 ; if ( n && ! ( n & ( n - 1 ) ) ) return n ; while ( n != 0 ) { n >>= 1 ; count += 1 ; } return 1 << count ; }
static boolean isPowerOfTwo ( int x ) { return x && ( ! ( x & ( x - 1 ) ) ) ; }
static void decToBinary ( int n ) { int [ ] binaryNum = new int [ 32 ] ; int i = 0 ; while ( n > 0 ) { binaryNum [ i ] = n % 2 ; n = n / 2 ; i ++ ; } for ( int j = i - 1 ; j >= 0 ; j -- ) System . out . print ( binaryNum [ j ] ) ; }
static int maximumSumSubarray ( int arr [ ] , int n ) { int min_prefix_sum = 0 ; int res = Integer . MIN_VALUE ; int [ ] prefix_sum = new int [ n ] ; prefix_sum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) prefix_sum [ i ] = prefix_sum [ i - 1 ] + arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) { res = Math . max ( res , prefix_sum [ i ] - min_prefix_sum ) ; min_prefix_sum = Math . min ( min_prefix_sum , prefix_sum [ i ] ) ; } return res ; }
static int countOccurrences ( String s , int K ) { int n = s . length ( ) ; int C = 0 , c1 = 0 , c2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == ' a ' ) { c1 ++ ; } if ( s . charAt ( i ) == ' b ' ) { c2 ++ ; C += c1 ; } } return C * K + ( K * ( K - 1 ) / 2 ) * c1 * c2 ; }
static boolean checkDivisibility ( String num ) { int length = num . length ( ) ; if ( length == 1 && num . charAt ( 0 ) == '0' ) return true ; if ( length % 3 == 1 ) { num += "00" ; length += 2 ; } else if ( length % 3 == 2 ) { num += "0" ; length += 1 ; } int sum = 0 , p = 1 ; for ( int i = length - 1 ; i >= 0 ; i -- ) { int group = 0 ; group += num . charAt ( i -- ) - '0' ; group += ( num . charAt ( i -- ) - '0' ) * 10 ; group += ( num . charAt ( i ) - '0' ) * 100 ; sum = sum + group * p ; p *= ( - 1 ) ; } sum = Math . abs ( sum ) ; return ( sum % 13 == 0 ) ; }
static int countSetBits ( int n ) { int count = 0 ; while ( n ) { n &= ( n - 1 ) ; count ++ ; } return count ; }
static int minJumps ( int arr [ ] , int n ) { if ( n == 1 ) return 0 ; int res = Integer . MAX_VALUE ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( i + arr [ i ] >= n - 1 ) { int sub_res = minJumps ( arr , i + 1 ) ; if ( sub_res != Integer . MAX_VALUE ) res = Math . min ( res , sub_res + 1 ) ; } } return res ; }
static int minTimeForWritingChars ( int N , int insert , int remove , int copy ) { if ( N == 0 ) return 0 ; if ( N == 1 ) return insert ; int dp [ ] = new int [ N + 1 ] ; Arrays . fill ( dp , 0 ) ; for ( int i = 1 ; i <= N ; i ++ ) { if ( i % 2 == 0 ) dp [ i ] = Math . min ( dp [ i - 1 ] + insert , dp [ i / 2 ] + copy ) ; else dp [ i ] = Math . min ( dp [ i - 1 ] + insert , dp [ ( i + 1 ) / 2 ] + copy + remove ) ; } return dp [ N ] ; }
static void carveCross ( String str ) { int n = str . length ( ) ; if ( n % 2 == 0 ) { System . out . println ( " Not ▁ possible . ▁ Please ▁ enter ▁ " + " odd ▁ length ▁ string . \n " ) ; } else { char [ ] [ ] arr = new char [ max ] [ max ] ; int m = n / 2 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { arr [ i ] [ j ] = ' X ' ; } } for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] [ m ] = str . charAt ( i ) ; } for ( int i = 0 ; i < n ; i ++ ) { arr [ m ] [ i ] = str . charAt ( i ) ; } for ( int i = 0 ; i < n ; i ++ ) { arr [ m ] [ i ] = str . charAt ( i ) ; } for ( int j = 0 ; j < n ; j ++ ) { System . out . print ( arr [ i ] [ j ] + " ▁ " ) ; } System . out . println ( ) ; } }
static int MaximumDecimalValue ( int mat [ ] [ ] , int n ) { int dp [ ] [ ] = new int [ n ] [ n ] ; if ( mat [ 0 ] [ 0 ] == 1 ) { dp [ 0 ] [ 0 ] = 1 ; } for ( int i = 1 ; i < n ; i ++ ) { if ( mat [ 0 ] [ i ] == 1 ) { dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + pow ( 2 , i ) ; else dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] ; } for ( int i = 1 ; i < n ; i ++ ) { if ( mat [ i ] [ 0 ] == 1 ) { dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + pow ( 2 , i ) ; else dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] ; } } for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) { if ( mat [ i ] [ j ] == 1 ) { dp [ i ] [ j ] = Math . max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) + pow ( 2 , i + j ) ; } else { dp [ i ] [ j ] = Math . max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ; } } } return dp [ n - 1 ] [ n - 1 ] ; }
static int findRepeating ( int arr [ ] , int n ) { int missingElement = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int element = arr [ abs ( arr [ i ] ) ] ; if ( element < 0 ) { missingElement = arr [ i ] ; break ; } arr [ abs ( arr [ i ] ) ] = - arr [ abs ( arr [ i ] ) ] ; } return Math . abs ( missingElement ) ; }
static boolean isPowerOfFour ( int n ) { return n != 0 && ( ( n & ( n - 1 ) ) == 0 ) && ! ( n & 0xAAAAAAAA ) ; }
static int decToBinary ( int n ) { for ( int i = 31 ; i >= 0 ; i -- ) { int k = n >> i ; if ( k & 1 ) System . out . print ( "1" ) ; else System . out . print ( "0" ) ; } return 0 ; }
static int countSubstrs ( String str , int i , int j , int n ) { if ( n == 1 ) return 1 ; if ( n <= 0 ) return 0 ; int res = countSubstrs ( str , i + 1 , j , n - 1 ) + countSubstrs ( str , i , j - 1 , n - 1 ) - countSubstrs ( str , i + 1 , j - 1 , n - 2 ) ; if ( str . charAt ( i ) == str . charAt ( j ) ) res ++ ; return res ; }
static int minRotation ( int input , int unlock_code ) { int rotation = 0 ; int input_digit , code_digit ; while ( input || unlock_code ) { input_digit = input % 10 ; code_digit = unlock_code % 10 ; rotation += Math . min ( Math . abs ( input_digit - code_digit ) , 10 - Math . abs ( input_digit - code_digit ) ) ; input /= 10 ; unlock_code /= 10 ; } return rotation ; }
static boolean checkMarkov ( double m [ ] [ ] ) { double sum = 0 ; for ( int i = 0 ; i < m . length ; i ++ ) { sum = sum + m [ i ] [ j ] ; if ( sum != 1 ) return false ; } return true ; }
static boolean areConsecutive ( int arr [ ] , int n ) { if ( n < 1 ) return false ; int min = getMin ( arr , n ) ; int max = getMax ( arr , n ) ; if ( max - min + 1 == n ) { boolean * visited = ( boolean * ) Arrays . fill ( arr , false ) ; int i ; for ( i = 0 ; i < n ; i ++ ) { if ( visited [ arr [ i ] - min ] != false ) return false ; visited [ arr [ i ] - min ] = true ; } return true ; } return false ; }
static double findMod ( double a , double b ) { double mod ; if ( a < 0 ) mod = - a ; else mod = a ; if ( b < 0 ) b = - b ; while ( mod >= b ) mod = mod - b ; if ( a < 0 ) return - mod ; return mod ; }
static int sumOfSubstrings ( String num ) { int n = num . length ( ) ; int [ ] sumofdigit = new int [ n ] ; sumofdigit [ 0 ] = toDigit ( num . charAt ( 0 ) ) ; int res = sumofdigit [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { int numi = toDigit ( num . charAt ( i ) ) ; sumofdigit [ i ] = ( i + 1 ) * numi + 10 * sumofdigit [ i - 1 ] ; res += sumofdigit [ i ] ; } return res ; }
static int getMissingNo ( int a [ ] , int n ) { int i , total = 1 ; for ( i = 2 ; i <= ( n + 1 ) ; i ++ ) { total += i ; total -= a [ i - 2 ] ; } return total ; }
static int nextPowerOf2 ( int n ) { n -- ; n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; n ++ ; return n ; }
static int zigzag ( int n , int k ) { int dp [ ] [ ] = new int [ n + 1 ] [ k + 1 ] ; dp [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { dp [ i ] [ 0 ] = 0 ; } for ( int i = 1 ; i <= n ; i ++ ) { dp [ i ] [ 0 ] = 1 ; } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) { dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ i - j ] ; return dp [ n ] [ k ] ; } }
static int maximumDifferenceSum ( int arr [ ] , int N ) { int dp [ ] [ ] = new int [ N ] [ 2 ] ; for ( int i = 0 ; i < N ; i ++ ) { dp [ i ] [ 0 ] = dp [ i ] [ 1 ] = 0 ; } for ( int i = 0 ; i < ( N - 1 ) ; i ++ ) { dp [ i + 1 ] [ 0 ] = Math . max ( dp [ i ] [ 0 ] + Math . abs ( 1 - arr [ i ] ) ) ; dp [ i + 1 ] [ 1 ] = Math . max ( dp [ i ] [ 0 ] + Math . abs ( arr [ i + 1 ] - 1 ) , dp [ i ] [ 1 ] + Math . abs ( arr [ i + 1 ] - arr [ i ] ) ) ; } return Math . max ( dp [ N - 1 ] [ 0 ] , dp [ N - 1 ] [ 1 ] ) ; }
static boolean isMultipleOf10 ( int n ) { return ( n % 15 == 0 ) ; }
public static int maxProduct ( int arr [ ] , int n ) { if ( n < 3 ) return - 1 ; Arrays . sort ( arr ) ; return Math . max ( arr [ 0 ] * arr [ 1 ] * arr [ n - 1 ] , arr [ n - 1 ] * arr [ n - 2 ] * arr [ n - 3 ] ) ; }
static int nextPowerOf2 ( int n ) { n -- ; n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; n ++ ; return n ; }
static int findMaxValue ( int arr [ ] , int n ) { if ( n < 4 ) { System . out . println ( " The ▁ array ▁ should ▁ have ▁ atlest ▁ 4 ▁ elements \n " ) ; return MIN ; } int table1 [ ] , table2 [ ] , table3 [ ] , table4 [ ] ; for ( int i = 0 ; i <= n ; i ++ ) table1 [ i ] = table2 [ i ] = table3 [ i ] = table4 [ i ] = MIN ; for ( int i = n - 1 ; i >= 0 ; i -- ) table1 [ i ] = Math . max ( table1 [ i + 1 ] , arr [ i ] ) ; for ( int i = n - 2 ; i >= 0 ; i -- ) table2 [ i ] = Math . max ( table2 [ i + 1 ] , table1 [ i + 1 ] - arr [ i ] ) ; for ( int i = n - 3 ; i >= 0 ; i -- ) table3 [ i ] = Math . max ( table3 [ i + 1 ] , table2 [ i + 1 ] + arr [ i ] ) ; for ( int i = n - 4 ; i >= 0 ; i -- ) table4 [ i ] = Math . max ( table4 [ i + 1 ] , table3 [ i + 1 ] - arr [ i ] ) ; return table4 [ 0 ] ; }
static int findMaxGCD ( int arr [ ] , int n ) { int high = 0 ; for ( int i = 0 ; i < n ; i ++ ) high = Math . max ( high , arr [ i ] ) ; int [ ] count = new int [ high + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { count [ arr [ i ] ] ++ ; } int counter = 0 ; for ( int i = high ; i >= 1 ; i -- ) { int j = i ; counter = 0 ; for ( int j = i ; counter <= high ) { if ( count [ j ] >= 2 ) return j ; else if ( count [ j ] == 1 ) counter ++ ; j += i ; if ( counter == 2 ) return i ; } } }
static int minRadius ( int k , int x [ ] , int y [ ] , int n ) { int dis [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) dis [ i ] = x [ i ] * x [ i ] + y [ i ] * y [ i ] ; Arrays . sort ( dis ) ; return dis [ k - 1 ] ; }
static void findSmallest ( int m , int s ) { if ( s == 0 ) { ( m == 1 ) ? System . out . println ( " Smallest ▁ number ▁ is ▁ " + 0 ) : System . out . println ( " Not ▁ possible " ) ; return ; } if ( s > 9 * m ) { System . out . println ( " Not ▁ possible " ) ; return ; } int [ ] res = new int [ m ] ; s -= 1 ; for ( int i = m - 1 ; i > 0 ; i -- ) { if ( s > 9 ) { res [ i ] = 9 ; s -= 9 ; } else { res [ i ] = s ; s = 0 ; } } res [ 0 ] = s + 1 ; System . out . println ( " Smallest ▁ number ▁ is ▁ " ) ; for ( int i = 0 ; i < m ; i ++ ) System . out . print ( res [ i ] ) ; }
static boolean isPresent ( String s , String q ) { int freq [ ] = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { freq [ s . charAt ( i ) ] ++ ; } for ( int i = 0 ; i < q . length ( ) ; i ++ ) { freq [ q . charAt ( i ) ] -- ; if ( freq [ q . charAt ( i ) ] < 0 ) return false ; } return true ; }
public static void sortArray ( int arr [ ] , int n , int A , int B , int C ) { for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = A * arr [ i ] * arr [ i ] + B * arr [ i ] + C ; int index , maximum = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { if ( maximum < arr [ i ] ) { index = i ; maximum = arr [ i ] ; } } int i = 0 , j = n - 1 ; int new_arr [ ] , k = 0 ; while ( i < index && j > index ) { if ( arr [ i ] < arr [ j ] ) new_arr [ k ++ ] = arr [ i ++ ] ; else new_arr [ k ++ ] = arr [ j -- ] ; } while ( i < index ) new_arr [ k ++ ] = arr [ i ++ ] ; while ( j > index ) new_arr [ k ++ ] = arr [ j -- ] ; } new_arr [ n - 1 ] = maximum ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = new_arr [ i ] ; }
static void printDistance ( int mat [ ] [ ] ) { int ans [ ] [ ] = new int [ N ] [ M ] ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < M ; j ++ ) ans [ i ] [ j ] = Integer . MAX_VALUE ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < M ; j ++ ) { for ( int k = 0 ; k < N ; k ++ ) for ( int l = 0 ; l < M ; l ++ ) { if ( mat [ k ] [ l ] == 1 ) ans [ i ] [ j ] = Math . min ( ans [ i ] [ j ] , Math . abs ( i - k ) + Math . abs ( j - l ) ) ; } } for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) System . out . print ( ans [ i ] [ j ] + " ▁ " ) ; System . out . println ( ) ; } } for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) System . out . print ( ans [ i ] [ j ] + " ▁ " ) ; System . out . println ( ) ; } }
static int findLastIndex ( String str , char x ) { int index = - 1 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) if ( str . charAt ( i ) == x ) index = i ; return index ; }
static double vol_of_dodecahedron ( int side ) { return ( ( ( 15 + ( 7 * ( sqrt ( 5 ) ) ) ) / 4 ) * ( pow ( side , 3 ) ) ) ; }
static int countTransformation ( String a , String b ) { int n = a . length ( ) , m = b . length ( ) ; if ( m == 0 ) return 1 ; int dp [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; for ( int [ ] rows : dp ) Arrays . fill ( rows , 0 ) ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { if ( j == 0 ) dp [ i ] [ j ] = ( a [ j ] == b [ i ] ) ? 1 : 0 ; else if ( a [ j ] == b [ i ] ) dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + 1 ; else dp [ i ] [ j ] = dp [ i ] [ j - 1 ] ; } else { if ( a [ j ] == b [ i ] ) dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = dp [ i ] [ j - 1 ] ; } } } return dp [ m - 1 ] [ n - 1 ] ; }
static int sumAtKthLevel ( String tree , int k , int & i , int level ) { if ( tree . charAt ( i ++ ) == ' ( ' ) { if ( tree . charAt ( i ) == ' ) ' ) return 0 ; int sum = 0 ; if ( level == k ) sum = tree . charAt ( i ) - '0' ; int leftsum = sumAtKthLevel ( tree , k , ++ i , level + 1 ) ; int rightsum = sumAtKthLevel ( tree , k , ++ i , level + 1 ) ; ++ i ; return sum + leftsum + rightsum ; }
static void printRepeating ( int arr [ ] , int size ) { int [ ] count = new int [ sizeof ( int ) * ( size - 2 ) ] ; int i ; System . out . println ( " ▁ Repeating ▁ elements ▁ are ▁ " ) ; for ( i = 0 ; i < size ; i ++ ) { if ( count [ arr [ i ] ] == 1 ) System . out . print ( arr [ i ] + " ▁ " ) ; else count [ arr [ i ] ] ++ ; } }
static boolean isSubsetSum ( int set [ ] , int n , int sum ) { boolean [ ] [ ] subset = new boolean [ n + 1 ] [ sum + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) subset [ i ] [ 0 ] = true ; for ( int i = 1 ; i <= sum ; i ++ ) subset [ 0 ] [ i ] = false ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= sum ; j ++ ) { if ( j < set [ i - 1 ] ) subset [ i ] [ j ] = subset [ i - 1 ] [ j ] ; if ( j >= set [ i - 1 ] ) subset [ i ] [ j ] = subset [ i - 1 ] [ j ] || subset [ i - 1 ] [ j - set [ i - 1 ] ] ; } } return subset [ n ] [ sum ] ; }
static void replaceOriginal ( String s , int n ) { String r = new String ( n , ' ▁ ' ) ; for ( int i = 0 ; i < n ; i ++ ) { r [ i ] = s . charAt ( n - 1 - i ) ; if ( s . charAt ( i ) != ' a ' && s . charAt ( i ) != ' e ' && s . charAt ( i ) != ' i ' && s . charAt ( i ) != ' o ' && s . charAt ( i ) != ' u ' ) { System . out . print ( r [ i ] ) ; } } System . out . println ( ) ; }
static int findMaxPath ( int mat [ ] [ ] ) { for ( int i = 1 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { if ( j > 0 && j < M - 1 ) mat [ i ] [ j ] += Math . max ( mat [ i - 1 ] [ j ] , Math . max ( mat [ i - 1 ] [ j - 1 ] , mat [ i - 1 ] [ j + 1 ] ) ) ; else if ( j > 0 ) mat [ i ] [ j ] += Math . max ( mat [ i - 1 ] [ j ] , mat [ i - 1 ] [ j - 1 ] ) ; else if ( j < M - 1 ) mat [ i ] [ j ] += Math . max ( mat [ i - 1 ] [ j ] , mat [ i - 1 ] [ j + 1 ] ) ; } } int res = 0 ; for ( int j = 0 ; j < M ; j ++ ) res = Math . max ( mat [ N - 1 ] [ j ] , res ) ; return res ; }
static boolean checkIsAP ( int arr [ ] , int n ) { if ( n == 1 ) return true ; Arrays . sort ( arr ) ; int d = arr [ 1 ] - arr [ 0 ] ; for ( int i = 2 ; i < n ; i ++ ) if ( arr [ i ] - arr [ i - 1 ] != d ) return false ; return true ; }
static int check ( String str ) { int n = str . length ( ) ; int oddDigSum = 0 , evenDigSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) oddDigSum += ( str . charAt ( i ) - '0' ) ; else evenDigSum += ( str . charAt ( i ) - '0' ) ; } return ( ( oddDigSum - evenDigSum ) % 11 == 0 ) ; }
static void swap ( int * xp , int * yp ) { * xp = * xp ^ * yp ; * yp = * xp ^ * yp ; }
static int countSol ( int coeff [ ] , int n , int rhs ) { int dp [ ] = new int [ rhs + 1 ] ; dp [ 0 ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = coeff [ i ] ; j <= rhs ; j ++ ) dp [ j ] += dp [ j - coeff [ i ] ] ; return dp [ rhs ] ; }
static void printRepeating ( int arr [ ] , int size ) { int Xor = arr [ 0 ] ; int set_bit_no ; int i ; int n = size - 2 ; int x = 0 , y = 0 ; for ( i = 1 ; i < size ; i ++ ) Xor ^= arr [ i ] ; for ( i = 1 ; i <= n ; i ++ ) Xor ^= i ; set_bit_no = Xor & ~ ( Xor - 1 ) ; for ( i = 0 ; i < size ; i ++ ) { if ( arr [ i ] & set_bit_no ) x = x ^ arr [ i ] ; else y = y ^ arr [ i ] ; } for ( i = 1 ; i <= n ; i ++ ) { if ( i & set_bit_no ) x = x ^ i ; else y = y ^ i ; } System . out . println ( " The ▁ two ▁ repeating ▁ elements ▁ are ▁ " + y + " ▁ " + x ) ; }
static int findSubsequenceCount ( String S , String T ) { int m = T . length ( ) , n = S . length ( ) ; if ( m > n ) return 0 ; int [ ] [ ] mat = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 1 ; i <= m ; i ++ ) mat [ i ] [ 0 ] = 0 ; for ( int j = 0 ; j <= n ; j ++ ) mat [ 0 ] [ j ] = 1 ; for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( T . charAt ( i - 1 ) != S . charAt ( j - 1 ) ) mat [ i ] [ j ] = mat [ i ] [ j - 1 ] ; else mat [ i ] [ j ] = mat [ i ] [ j - 1 ] + mat [ i - 1 ] [ j - 1 ] ; } } return mat [ m ] [ n ] ; }
static int breakSum ( int n ) { int dp [ ] = new int [ n + 1 ] ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) dp [ i ] = Math . max ( dp [ i / 2 ] + dp [ i / 3 ] + dp [ i / 4 ] , i ) ; return dp [ n ] ; }
static void decToHexa ( int n ) { char [ ] hexaDeciNum = new char [ 100 ] ; int i = 0 ; while ( n != 0 ) { int temp = 0 ; temp = n % 16 ; if ( temp < 10 ) { hexaDeciNum [ i ] = temp + 48 ; i ++ ; } else { hexaDeciNum [ i ] = temp + 55 ; i ++ ; } n = n / 16 ; } for ( int j = i - 1 ; j >= 0 ; j -- ) System . out . print ( hexaDeciNum [ j ] ) ; }
static int gcd ( int a , int b ) { if ( a == b ) return a ; if ( a == 0 ) return b ; if ( b == 0 ) return a ; if ( ~ a & 1 ) { if ( b & 1 ) return gcd ( a >> 1 , b ) ; else return gcd ( a >> 1 , b >> 1 ) << 1 ; } if ( ~ b & 1 ) return gcd ( a , b >> 1 ) ; if ( a > b ) return gcd ( ( a - b ) >> 1 , b ) ; return gcd ( ( b - a ) >> 1 , a ) ; return gcd ( ( b - a ) >> 1 , a ) ; }
static void evaluate ( long long int n ) { if ( n == 1 || n == 2 ) System . out . println ( " No ▁ Pythagoras ▁ Triplet ▁ exists " ) ; else if ( n % 2 == 0 ) { long long int var = 1LL * n * n / 4 ; System . out . println ( " Pythagoras ▁ Triplet ▁ exist ▁ i . e . ▁ " ) ; System . out . println ( " No ▁ Pythagoras ▁ Triplet ▁ exists " ) ; else if ( n % 2 != 0 ) { long long int var = 1LL * n * n + 1 ; System . out . println ( " Pythagoras ▁ Triplets ▁ exist ▁ i . e . ▁ " ) ; System . out . println ( " % lld ▁ " + n , var - 1 , var + 1 ) ; } else if ( n % 2 != 0 ) { long long int var = 1LL * n * n + 1 ; System . out . println ( " Pythagoras ▁ Triplets ▁ exist ▁ i . e . ▁ " ) ; System . out . println ( " " ) ; } }
static int countPairs ( String str ) { int result = 0 ; int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 1 ; ( i + j ) < n && j <= MAX_CHAR ; j ++ ) if ( ( Math . abs ( str . charAt ( i + j ) - str . charAt ( i ) ) == j ) ) result ++ ; return result ; }
static int solve ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int a = 0 , b = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i & 1 ) a = a * 10 + arr [ i ] ; else b = b * 10 + arr [ i ] ; } return a + b ; }
static int countMinOperations ( int target [ ] , int n ) { int result = 0 ; while ( 1 ) { int zero_count = 0 ; int i ; for ( i = 0 ; i < n ; i ++ ) { if ( target [ i ] & 1 ) break ; else if ( target [ i ] == 0 ) zero_count ++ ; } if ( zero_count == n ) return result ; if ( i == n ) { for ( int j = 0 ; j < n ; j ++ ) target [ j ] = target [ j ] / 2 ; result ++ ; } for ( int j = i ; j < n ; j ++ ) { if ( target [ j ] & 1 ) { target [ j ] -- ; result ++ ; } } } return result ; }
static boolean canMakeAllSame ( String str ) { int zeros = 0 , ones = 0 ; for ( char ch : str ) ( ch == '0' ) ? ++ zeros : ++ ones ; return ( zeros == 1 || ones == 1 ) ; }
static void psuedoBinary ( int n ) { while ( n > 0 ) { int temp = n , m = 0 , p = 1 ; while ( temp ) { int rem = temp % 10 ; temp = temp / 10 ; if ( rem != 0 ) m += p ; p *= 10 ; } System . out . println ( m + " ▁ " ) ; n = n - m ; } }
static int findmin ( Point p [ ] , int n ) { int a = 0 , b = 0 , c = 0 , d = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( p [ i ] . x <= 0 ) a ++ ; else if ( p [ i ] . x >= 0 ) b ++ ; if ( p [ i ] . y <= 0 ) d ++ ; } return Math . min ( { a , b , c , d } ) ; }
static int minCoins ( int coins [ ] , int m , int V ) { int table [ ] = new int [ V + 1 ] ; table [ 0 ] = 0 ; for ( int i = 1 ; i <= V ; i ++ ) table [ i ] = Integer . MAX_VALUE ; for ( int i = 1 ; i <= V ; i ++ ) { table [ i ] = Integer . MAX_VALUE ; } for ( int i = 1 ; i <= V ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) if ( coins [ j ] <= i ) { int sub_res = table [ i - coins [ j ] ] ; if ( sub_res != Integer . MAX_VALUE && sub_res + 1 < table [ i ] ) table [ i ] = sub_res + 1 ; } } return table [ V ] ; }
static int maxAlternateSum ( int arr [ ] , int n ) { if ( n == 1 ) return arr [ 0 ] ; int dec [ ] = new int [ n ] ; int inc [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ j ] > arr [ i ] ) { dec [ i ] = Math . max ( dec [ i ] , inc [ j ] + arr [ i ] ) ; flag = 1 ; } else if ( arr [ j ] < arr [ i ] && flag == 1 ) inc [ i ] = Math . max ( inc [ i ] , dec [ j ] + arr [ i ] ) ; } } int result = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { if ( result < inc [ i ] ) result = inc [ i ] ; if ( result < dec [ i ] ) result = dec [ i ] ; } return result ; }
static void printRepeating ( int arr [ ] , int size ) { int i , j ; System . out . println ( " ▁ Repeating ▁ elements ▁ are ▁ " ) ; for ( i = 0 ; i < size ; i ++ ) for ( j = i + 1 ; j < size ; j ++ ) if ( arr [ i ] == arr [ j ] ) System . out . print ( arr [ i ] + " ▁ " ) ; }
static int maxSum ( int grid [ ] [ ] , int n ) { int incl = Math . max ( grid [ 0 ] [ 0 ] , grid [ 1 ] [ 0 ] ) ; int excl = 0 , excl_new ; for ( int i = 1 ; i < n ; i ++ ) { excl_new = Math . max ( excl , incl ) ; excl = excl_new ; } return Math . max ( excl , incl ) ; }
static boolean checkCorrectOrNot ( String s ) { int count1 [ ] = new int [ MAX_CHAR ] ; int count2 [ ] = new int [ MAX_CHAR ] ; int n = s . length ( ) ; if ( n == 1 ) return true ; for ( int i = 0 , j = n - 1 ; i < j ; i ++ , j -- ) { count1 [ s . charAt ( i ) - ' a ' ] ++ ; count2 [ s . charAt ( j ) - ' a ' ] ++ ; } for ( int i = 0 ; i < MAX_CHAR ; i ++ ) if ( count1 [ i ] != count2 [ i ] ) return false ; return true ; }
static double areaOctagon ( double side ) { return ( float ) ( 2 * ( 1 + sqrt ( 2 ) ) * side * side ) ; }
static void printSuperSeq ( String a , String b ) { int m = a . length ( ) , n = b . length ( ) ; int dp [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( ! i ) { dp [ i ] [ j ] = j ; } else if ( a [ i - 1 ] == b [ j - 1 ] ) { dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; } else { dp [ i ] [ j ] = 1 + Math . min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) ; } } int index = dp [ m ] [ n ] ; String res = new String ( index + 1 , ' \0' ) ; int i = m , j = n ; while ( i > 0 && j > 0 ) { if ( a [ i - 1 ] == b [ j - 1 ] ) { res [ index - 1 ] = a [ i - 1 ] ; i -- ; j -- ; index -- ; } else { res [ index - 1 ] = b [ j - 1 ] ; j -- ; index -- ; } } System . out . println ( res ) ; }
static int numberOfPaths ( int m , int n ) { int dp [ ] = new int [ n ] ; dp [ 0 ] = 1 ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) { dp [ j ] += dp [ j - 1 ] ; } } return dp [ n - 1 ] ; }
static boolean isPowerOfFour ( int n ) { int count = 0 ; if ( n && ! ( n & ( n - 1 ) ) ) { while ( n > 1 ) { n >>= 1 ; count += 1 ; } return ( count % 2 == 0 ) ? 1 : 0 ; } return 0 ; }
static int findElement ( int arr [ ] , int n ) { int leftMax [ ] = new int [ n ] ; leftMax [ 0 ] = Integer . MIN_VALUE ; for ( int i = 1 ; i < n ; i ++ ) leftMax [ i ] = Math . max ( leftMax [ i - 1 ] , arr [ i - 1 ] ) ; int rightMin = Integer . MAX_VALUE ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( leftMax [ i ] < arr [ i ] && rightMin > arr [ i ] ) return i ; rightMin = Math . min ( rightMin , arr [ i ] ) ; } return - 1 ; }
static void printRepeating ( int arr [ ] , int size ) { int i ; System . out . println ( " The ▁ repeating ▁ elements ▁ are " ) ; for ( i = 0 ; i < size ; i ++ ) { if ( arr [ abs ( arr [ i ] ) ] > 0 ) arr [ abs ( arr [ i ] ) ] = - arr [ abs ( arr [ i ] ) ] ; else System . out . println ( " ▁ " + abs ( arr [ i ] ) + " ▁ " ) ; } }
static void thirdLargest ( int arr [ ] , int arr_size ) { if ( arr_size < 3 ) { System . out . println ( " ▁ Invalid ▁ Input ▁ " ) ; return ; } int first = arr [ 0 ] , second = Integer . MIN_VALUE , third = Integer . MIN_VALUE ; for ( int i = 1 ; i < arr_size ; i ++ ) { if ( arr [ i ] > first ) { third = second ; second = first ; first = arr [ i ] ; } else if ( arr [ i ] > second ) { third = second ; second = arr [ i ] ; } else if ( arr [ i ] > third ) third = arr [ i ] ; } System . out . println ( " The ▁ third ▁ Largest ▁ element ▁ is ▁ " + third ) ; }
static int getNumStrictMonotone ( int len ) { int [ ] [ ] DP = new int [ len ] [ DP_s ] ; for ( int [ ] rows : DP ) Arrays . fill ( rows , 0 ) ; for ( int i = 0 ; i < DP_s ; ++ i ) DP [ 0 ] [ i ] = i + 1 ; for ( int i = 1 ; i < len ; ++ i ) for ( int j = 1 ; j < DP_s ; ++ j ) DP [ i ] [ j ] = DP [ i - 1 ] [ j - 1 ] + DP [ i ] [ j - 1 ] ; return DP [ len - 1 ] [ DP_s - 1 ] ; }
static int maxRevenue ( int m , int x [ ] , int revenue [ ] , int n , int t ) { int maxRev [ ] = new int [ m + 1 ] ; for ( int [ ] rows : maxRev ) Arrays . fill ( rows , 0 ) ; int nxtbb = 0 ; for ( int i = 1 ; i <= m ; i ++ ) { if ( nxtbb < n ) { if ( x [ nxtbb ] != i ) maxRev [ i ] = maxRev [ i - 1 ] ; else { if ( i <= t ) maxRev [ i ] = Math . max ( maxRev [ i - 1 ] , revenue [ nxtbb ] ) ; else maxRev [ i ] = Math . max ( maxRev [ i - t - 1 ] + revenue [ nxtbb ] , maxRev [ i - 1 ] ) ; nxtbb ++ ; } } else maxRev [ i ] = maxRev [ i - 1 ] ; } return maxRev [ m ] ; }
static void lineFromPoints ( pdd P , pdd Q ) { double a = Q . second - P . second ; double b = P . first - Q . first ; double c = a * ( P . first ) + b * ( P . second ) ; if ( b < 0 ) { System . out . println ( " The ▁ line ▁ passing ▁ through ▁ points ▁ P ▁ and ▁ Q ▁ is : ▁ " + a + " x ▁ " + b + " y ▁ = ▁ " + c ) ; } else { System . out . println ( " The ▁ line ▁ passing ▁ through ▁ points ▁ P ▁ and ▁ Q ▁ is : ▁ " + a + " x ▁ + ▁ " + b + " y ▁ = ▁ " + c ) ; } }
static int countSubstringWithEqualEnds ( String s ) { int result = 0 ; int n = s . length ( ) ; int [ ] count = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < n ; i ++ ) { count [ s . charAt ( i ) - ' a ' ] ++ ; } for ( int i = 0 ; i < MAX_CHAR ; i ++ ) result += ( count [ i ] * ( count [ i ] + 1 ) / 2 ) ; return result ; }
static boolean check ( String str ) { int n = str . length ( ) ; if ( n == 0 ) return false ; if ( n == 1 ) return ( ( str . charAt ( 0 ) - '0' ) % 4 == 0 ) ; int last = str . charAt ( n - 1 ) - '0' ; int second_last = str . charAt ( n - 2 ) - '0' ; return ( ( second_last * 10 + last ) % 4 == 0 ) ; }
static int remAnagram ( String str1 , String str2 ) { int count1 [ ] = new int [ CHARS ] , count2 [ ] = new int [ CHARS ] ; for ( int i = 0 ; i < 26 ; i ++ ) { count1 [ str1 . charAt ( i ) - ' a ' ] ++ ; } for ( int i = 0 ; i < 26 ; i ++ ) { count2 [ str2 . charAt ( i ) - ' a ' ] ++ ; } int result = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) { result += Math . abs ( count1 [ i ] - count2 [ i ] ) ; } return result ; }
static ll mulmod ( ll a , ll b , ll mod ) { ll res = 0 ; a = a % mod ; while ( b > 0 ) { if ( b % 2 == 1 ) res = ( res + a ) % mod ; a = ( a * 2 ) % mod ; b /= 2 ; } return res % mod ; }
static String Dragon_Curve_Sequence ( int n ) { String s = "1" ; for ( int i = 2 ; i <= n ; i ++ ) { String temp = "1" ; char prev = '1' , zero = '0' , one = '1' ; for ( int j = 0 ; j < s . length ( ) ; j ++ ) { temp += s . charAt ( j ) ; if ( prev == '0' ) { temp += one ; prev = one ; } else { temp += zero ; prev = zero ; } } s = temp ; } return s ; }
static char getSecondMostFreq ( String str ) { int [ ] count = new int [ NO_OF_CHARS ] , i ; for ( i = 0 ; i < str . length ( ) ; i ++ ) ( count [ str . charAt ( i ) ] ) ++ ; int first = 0 , second = 0 ; for ( i = 0 ; i < NO_OF_CHARS ; i ++ ) { if ( count [ i ] > count [ first ] ) { second = first ; first = i ; } else if ( count [ i ] > count [ second ] && count [ i ] != count [ first ] ) second = i ; } return second ; }
