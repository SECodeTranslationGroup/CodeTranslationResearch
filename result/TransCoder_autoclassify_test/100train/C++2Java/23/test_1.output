static void printPairs ( int arr [ ] , int n ) { Vector < Integer > v = new Vector < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( Math . abs ( arr [ i ] ) == Math . abs ( arr [ j ] ) ) v . add ( Math . abs ( arr [ i ] ) ) ; if ( v . size ( ) == 0 ) return ; sort ( v ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( - v . get ( i ) + " ▁ " + v . get ( i ) ) ; }
static float findArea ( float a , float b , float c ) { if ( a < 0 || b < 0 || c < 0 || ( a + b <= c ) || a + c <= b || b + c <= a ) { System . out . println ( " Not ▁ a ▁ valid ▁ trianglen " ) ; exit ( 0 ) ; } float s = ( a + b + c ) / 2 ; return Math . sqrt ( s * ( s - a ) * ( s - b ) * ( s - c ) ) ; }
static boolean isMajority ( int a [ ] , int n ) { HashMap < Integer , Integer > myMap = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) myMap . put ( a [ i ] , myMap . get ( a [ i ] ) + 1 ) ; for ( auto x : myMap ) if ( x . second >= n / 2 ) return true ; return false ; }
static int firstNonRepeating ( int arr [ ] , int n ) { HashMap < Integer , Integer > myMap = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) myMap . put ( arr [ i ] , myMap . get ( arr [ i ] ) + 1 ) ; for ( int i = 0 ; i < n ; i ++ ) if ( myMap . containsKey ( arr [ i ] ) ) return arr [ i ] ; return - 1 ; }
static void recaman ( int n ) { if ( n <= 0 ) return ; System . out . println ( " Reaman " + n ) ; HashSet < Integer > s = new HashSet < Integer > ( ) ; s . add ( 0 ) ; int prev = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int curr = prev - i ; if ( curr < 0 || s . contains ( curr ) ) curr = prev + i ; s . add ( curr ) ; System . out . println ( " % d , ▁ " + curr ) ; prev = curr ; } }
static int maxdiff ( int arr [ ] , int n ) { HashMap < Integer , Integer > freq = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) freq . put ( arr [ i ] , freq . get ( arr [ j ] ) + 1 ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( freq [ arr [ i ] ] > freq [ arr [ j ] ] && arr [ i ] > arr [ j ] ) ans = Math . max ( ans , freq [ arr [ i ] ] - freq [ arr [ j ] ] ) ; else if ( freq [ arr [ i ] ] < freq . get ( arr [ j ] ] && arr [ i ] < arr [ j ] ) ans = Math . max ( ans , freq [ arr [ j ] ] - freq [ arr [ i ] ] ) ; } } return ans ; }
static int findLength ( String str ) { int n = str . length ( ) ; int maxlen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j += 2 ) { int length = j - i + 1 ; int leftsum = 0 , rightsum = 0 ; for ( int k = 0 ; k < length / 2 ; k ++ ) { leftsum += ( str . charAt ( i + k ) - '0' ) ; rightsum += ( str . charAt ( i + k + length / 2 ) - '0' ) ; } if ( leftsum == rightsum && maxlen < length ) maxlen = length ; } } return maxlen ; }
static boolean prevPermutation ( String str ) { int n = str . length ( ) - 1 ; int i = n ; while ( i > 0 && str . charAt ( i - 1 ) <= str . charAt ( i ) ) i -- ; if ( i <= 0 ) return false ; int j = i - 1 ; while ( j + 1 <= n && str . charAt ( j + 1 ) <= str . charAt ( i - 1 ) ) j ++ ; swap ( str . charAt ( i - 1 ) , str . charAt ( j ) ) ; reverse ( str . begin ( ) + i , str . end ( ) ) ; return true ; }
static String findSubString ( String str , String pat ) { int len1 = str . length ( ) ; int len2 = pat . length ( ) ; if ( len1 < len2 ) { System . out . println ( " No ▁ such ▁ window ▁ exists " ) ; return " " ; } int [ ] hash_pat = new int [ no_of_chars ] ; int [ ] hash_str = new int [ no_of_chars ] ; for ( int i = 0 ; i < len2 ; i ++ ) hash_pat [ pat . charAt ( i ) ] ++ ; int start = 0 , start_index = - 1 , min_len = Integer . MAX_VALUE ; int count = 0 ; for ( int j = 0 ; j < len1 ; j ++ ) { hash_str [ str . charAt ( j ) ] ++ ; if ( hash_pat [ str . charAt ( j ) ] != 0 && hash_str [ str . charAt ( j ) ] <= hash_pat [ str . charAt ( j ) ] ) count ++ ; if ( count == len2 ) { while ( hash_str [ str [ start ] ] > hash_pat [ str . charAt ( start ) ] || hash_pat [ str . start ] ] == 0 ) { if ( hash_str [ str . charAt ( start ) ] > hash_pat [ str . charAt ( start ) ] ) hash_str [ str . charAt ( start ) ] == 0 ) { if ( hash_str [ str . charAt ( start ) ] ) hash_str [ str . charAt ( start ) ] -- ; start ++ ; } } } if ( start_index == - 1 ) { System . out . println ( " No ▁ such ▁ window ▁ exists " ) ; return " " ; } return str . substring ( start_index , min_len ) ; }
static void shuffle ( int card [ ] , int n ) { srand ( time ( 0 ) ) ; for ( int i = 0 ; i < n ; i ++ ) { int r = i + ( rand ( ) % ( 52 - i ) ) ; swap ( card [ i ] , card [ r ] ) ; } }
static int maxLen ( int arr [ ] , int n ) { HashMap < Integer , Integer > presum = new HashMap < Integer , Integer > ( ) ; int sum = 0 ; int max_len = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( arr [ i ] == 0 && max_len == 0 ) max_len = 1 ; if ( sum == 0 ) max_len = i + 1 ; if ( presum . containsKey ( sum ) ) max_len = i + 1 ; if ( sum == 0 ) max_len = i + 1 ; if ( presum . containsKey ( sum ) ) max_len = Math . max ( max_len , i - presum [ sum ] ) ; } else { presum . put ( sum , i ) ; } } return max_len ; }
static int removeConsecutiveSame ( StringVector v ) { Stack < String > st = new Stack < String > ( ) ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) { if ( st . isEmpty ( ) ) st . add ( v . get ( i ) ) ; else { String str = st . peek ( ) ; if ( str . compareTo ( v . get ( i ) ) == 0 ) st . remove ( ) ; else st . add ( v . get ( i ) ) ; } } return st . size ( ) ; }
public static void find ( LinkedList < String > list1 , LinkedList < String > list2 ) { Vector < String > res = new Vector < String > ( ) ; int max_possible_sum = list1 . size ( ) + list2 . size ( ) - 2 ; for ( int sum = 0 ; sum <= max_possible_sum ; sum ++ ) { for ( int i = 0 ; i <= sum ; i ++ ) if ( i < list1 . size ( ) && ( sum - i ) < list2 . size ( ) && list1 . get ( i ) == list2 . get ( sum - i ) ) res . add ( list1 . get ( i ) ) ; if ( res . size ( ) > 0 ) break ; } for ( int i = 0 ; i < res . size ( ) ; i ++ ) System . out . print ( res . get ( i ) + " ▁ " ) ; }
static int getLevenstein ( String input ) { String revInput = input . substring ( 1 ) ; int n = input . length ( ) ; Vector < Integer > dp = new Vector < > ( n + 1 ) ; for ( int i = 0 ; i <= n ; ++ i ) { dp [ 0 ] [ i ] = i ; dp [ i ] [ 0 ] = i ; } for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j <= n ; ++ j ) { if ( input . charAt ( i - 1 ) == revInput . charAt ( j - 1 ) ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ; } else { dp [ i ] [ j ] = 1 + Math . min ( { dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] } ) ; } } int res = Integer . MAX_VALUE ; for ( int i = n , j = 0 ; i >= 0 ; -- i , ++ j ) { res = Math . min ( res , dp [ i ] [ j ] ) ; if ( i < n ) res = Math . min ( res , dp [ i + 1 ] [ j ] ) ; if ( i > 0 ) res = Math . min ( res , dp [ i - 1 ] [ j ] ) ; } return res ; }
static void countDistinct ( int arr [ ] , int k , int n ) { Map < Integer , Integer > hm = new HashMap < > ( ) ; int dist_count = 0 ; for ( int i = 0 ; i < k ; i ++ ) { if ( hm . containsKey ( arr [ i ] ) ) { dist_count ++ ; } hm . put ( arr [ i ] , 1 ) ; } System . out . println ( dist_count ) ; for ( int i = k ; i < n ; i ++ ) { if ( hm . containsKey ( arr [ i - k ] ) ) { dist_count -- ; } hm [ arr [ i - k ] ] -= 1 ; if ( hm [ arr [ i ] ] == 0 ) { dist_count ++ ; } hm [ arr [ i ] ] += 1 ; System . out . println ( dist_count ) ; } }
static int lcs ( int dp [ ] [ ] , int arr1 [ ] , int n , int arr2 [ ] , int m , int k ) { if ( k < 0 ) return - 1e7 ; if ( n < 0 || m < 0 ) return 0 ; int & ans = dp [ n ] [ m ] [ k ] ; if ( ans != - 1 ) return ans ; ans = Math . max ( lcs ( dp , arr1 , n - 1 , arr2 , m , k ) ) ; if ( arr1 [ n - 1 ] == arr2 [ m - 1 ] ) ans = Math . max ( ans , 1 + lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k ) ) ; if ( arr1 [ n - 1 ] == arr2 [ m - 1 ] ) ans = Math . max ( ans , 1 + lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k ) ) ; if ( arr1 [ n - 1 ] == arr2 [ m - 1 ] ) ans = Math . max ( ans , 1 + lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k - 1 ) ) ; return ans ; }
static void printDivisors ( int n ) { Vector < Integer > v = new Vector < > ( ) ; for ( int i = 1 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) System . out . println ( " % d ▁ " + i ) ; else { System . out . println ( " % d ▁ " + i ) ; v . add ( n / i ) ; } } } for ( int i = v . size ( ) - 1 ; i >= 0 ; i -- ) System . out . println ( " % d ▁ " , v . get ( i ) ) ; } }
static int findLIS ( int A [ ] , int n ) { HashMap < Integer , Integer > hM = new HashMap < Integer , Integer > ( ) ; int LIS_size = 1 ; int LIS_index = 0 ; hash [ A [ 0 ] ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { hash [ A [ i ] ] = hash [ A [ i ] - 1 ] + 1 ; if ( LIS_size < hash [ A [ i ] ] ) { LIS_size = hash [ A [ i ] ] ; LIS_index = A [ i ] ; } } System . out . println ( " LIS _ size ▁ = ▁ " + LIS_size + " \n " ) ; System . out . println ( " LIS _ index ▁ = ▁ " + LIS_index - LIS_size + 1 ; while ( start <= LIS_index ) { System . out . print ( start + " ▁ " ) ; start ++ ; } } System . out . println ( " LIS ▁ : ▁ " ) ; int start = LIS_index - LIS_size + 1 ; while ( start <= LIS_index ) { System . out . print ( start + " ▁ " ) ; start ++ ; } }
static int largestSubset ( int a [ ] , int n ) { Arrays . sort ( a ) ; int dp [ ] = new int [ n ] ; dp [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { int mxm = 0 ; for ( int j = i + 1 ; j < n ; j ++ ) if ( a [ j ] % a [ i ] == 0 ) mxm = Math . max ( mxm , dp [ j ] ) ; dp [ i ] = 1 + mxm ; } return * max_element ( dp , dp + n ) ; }
static char encodedChar ( String str , int k ) { String expand = " " ; String temp ; int freq = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { temp = " " ; freq = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { while ( str . charAt ( i ) >= ' a ' && str . charAt ( i ) <= ' z ' ) { temp . add ( str . charAt ( i ) ) ; i ++ ; } while ( str . charAt ( i ) >= '1' && str . charAt ( i ) <= '9' ) { freq = freq * 10 + str . charAt ( i ) - '0' ; i ++ ; } for ( int j = 1 ; j <= freq ; j ++ ) expand . append ( temp ) ; } if ( freq == 0 ) expand . append ( temp ) ; return expand [ k - 1 ] ; }
static int countNum ( int arr [ ] , int n ) { HashSet < Integer > s = new HashSet < Integer > ( ) ; int count = 0 , maxm = Integer . MIN_VALUE , minm = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { s . add ( arr [ i ] ) ; if ( arr [ i ] < minm ) minm = arr [ i ] ; if ( arr [ i ] > maxm ) maxm = arr [ i ] ; } for ( int i = minm ; i <= maxm ; i ++ ) if ( s . contains ( arr [ i ] ) ) count ++ ; return count ; }
static int countPairs ( int arr [ ] , int n ) { HashMap < Integer , Integer > myMap = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) myMap . put ( arr [ i ] , myMap . get ( arr [ i ] ) + 1 ) ; int ans = 0 ; for ( AutoCloseable it = myMap . get ( arr [ 0 ] ) ; it != myMap . end ( ) ; it ++ ) { int count = it -> second ; ans += ( count * ( count - 1 ) ) / 2 ; } return ans ; }
static String decimalToBinary ( double num , int k_prec ) { String binary = " " ; int Integral = num ; double fractional = num - Integral ; while ( Integral ) { int rem = Integral % 2 ; binary . add ( rem + '0' ) ; Integral /= 2 ; } reverse ( binary . begin ( ) , binary . end ( ) ) ; binary . add ( ' . ' ) ; while ( k_prec -- ) { fractional *= 2 ; int fract_bit = fractional ; if ( fract_bit == 1 ) { fractional -= fract_bit ; binary . add_back ( 1 + '0' ) ; } else binary . add_back ( 0 + '0' ) ; } return binary ; }
static int evaluateBoolExpr ( String s ) { int n = s . length ( ) ; for ( int i = 0 ; i < n ; i += 2 ) { if ( s . charAt ( i + 1 ) == ' A ' ) { if ( s . charAt ( i + 2 ) == '0' || s . charAt ( i ) == '0' ) s . insert ( i + 2 , '0' ) ; else s . insert ( i + 2 , '1' ) ; } else if ( s . charAt ( i + 1 ) == ' B ' ) { if ( s . charAt ( i + 2 ) == '1' || s . charAt ( i ) == '1' ) s . insert ( i + 2 , '1' ) ; else s [ i + 2 ] = '0' ; } else { if ( s . charAt ( i + 2 ) == s . charAt ( i ) ) s . insert ( i + 2 , '0' ) ; else s . insert ( i + 2 , '1' ) ; } } return s . charAt ( n - 1 ) - '0' ) ; }
static int minSwaps ( int arr [ ] , int n ) { Pair < Integer , Integer > arrPos [ ] = new Pair < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { arrPos [ i ] . first = arr [ i ] ; arrPos [ i ] . second = i ; } Arrays . sort ( arrPos ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( vis [ i ] || arrPos [ i ] . second == i ) continue ; int cycle_size = 0 ; int j = i ; while ( ! vis [ j ] ) { vis [ j ] = 1 ; j = arrPos [ j ] . second ; cycle_size ++ ; } if ( cycle_size > 0 ) { ans += ( cycle_size - 1 ) ; } } return ans ; }
static int minimumBox ( int arr [ ] , int n ) { Queue < Integer > q = new LinkedList < Integer > ( ) ; q . add ( arr [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { int now = q . peek ( ) ; if ( arr [ i ] >= 2 * now ) q . remove ( ) ; q . add ( arr [ i ] ) ; } return q . size ( ) ; }
static int findInteger ( int arr [ ] , int n ) { HashMap < Integer , Integer > hash = new HashMap < Integer , Integer > ( ) ; int maximum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < 0 ) hash [ Math . abs ( arr [ i ] ) ] -= 1 ; else hash [ arr [ i ] ] += 1 ; } for ( int i = 0 ; i < n ; i ++ ) if ( hash [ arr [ i ] ] != 0 ) return arr [ i ] ; return - 1 ; }
static void convertOpposite ( String str ) { int ln = str . length ( ) ; for ( int i = 0 ; i < ln ; i ++ ) { if ( str . charAt ( i ) >= ' a ' && str . charAt ( i ) <= ' z ' ) str . set ( i , str . charAt ( i ) - 32 ) ; else if ( str . charAt ( i ) >= ' A ' && str . charAt ( i ) <= ' Z ' ) str . set ( i , str . charAt ( i ) + 32 ) ; } }
static int findRepeating ( int arr [ ] , int n ) { HashSet < Integer > s = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . contains ( arr [ i ] ) ) return arr [ i ] ; s . add ( arr [ i ] ) ; } return - 1 ; }
static void transpose ( int A [ ] [ ] ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = i + 1 ; j < N ; j ++ ) swap ( A [ i ] [ j ] , A [ j ] [ i ] ) ; }
static void printSubsequences ( String str ) { int n = str . length ( ) ; long opsize = ( long ) Math . pow ( 2 , n - 1 ) ; for ( int counter = 0 ; counter < opsize ; counter ++ ) { for ( int j = 0 ; j < n ; j ++ ) { System . out . print ( str . charAt ( j ) ) ; if ( ( counter & ( 1 << j ) ) > 0 ) System . out . print ( " ▁ " ) ; } System . out . println ( ) ; } }
static int printRoman ( int number ) { int num [ ] = new int [ num . length ] ; String sym [ ] = new String [ num . length ] ; int i = 12 ; while ( number > 0 ) { int div = number / num [ i ] ; number = number % num [ i ] ; while ( div -- ) { System . out . print ( sym [ i ] ) ; } i -- ; } }
boolean findTriplet ( int a1 [ ] , int a2 [ ] , int a3 [ ] , int sum ) { HashSet < Integer > s = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n1 ; i ++ ) s . add ( a1 [ i ] ) ; for ( int i = 0 ; i < n2 ; i ++ ) { for ( int j = 0 ; j < n3 ; j ++ ) { if ( s . contains ( sum - a2 [ i ] - a3 [ j ] ) ) return true ; } } return false ; }
static boolean check ( String s ) { if ( s . length ( ) >= 10 ) return true ; for ( int i = 1 ; i < s . size ( ) ; i ++ ) { for ( int j = i + 1 ; j < s . size ( ) ; j ++ ) { for ( int k = j + 1 ; k < s . size ( ) ; k ++ ) { String s1 = s . substring ( 0 , i ) ; String s2 = s . substring ( i , j - i ) ; String s3 = s . substring ( j , k - j ) ; String s4 = s . substring ( k , s . size ( ) - k ) ; if ( s1 != s2 && s1 != s3 && s1 != s4 && s2 != s3 && s2 != s4 && s3 != s4 ) return true ; } } } return false ; }
static void bitonicGenerator ( int arr [ ] , int n ) { int i = 1 ; int j = n - 1 ; if ( j % 2 != 0 ) j -- ; while ( i < j ) { swap ( arr [ i ] , arr [ j ] ) ; i += 2 ; j -= 2 ; } Arrays . sort ( arr ) ; Arrays . sort ( arr + ( n + 1 ) / 2 ) ; Arrays . sort ( arr + ( n + 1 ) / 2 , Collections . reverseOrder ( ) ) ; }
static void splitString ( String str ) { String alpha , num , special ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( isdigit ( str . charAt ( i ) ) ) num . add ( str . charAt ( i ) ) ; else if ( ( str . charAt ( i ) >= ' A ' && str . charAt ( i ) <= ' Z ' ) || ( str . charAt ( i ) >= ' a ' && str . charAt ( i ) <= ' z ' ) ) alpha . add ( str . charAt ( i ) ) ; else special . add ( str . charAt ( i ) ) ; } System . out . print ( alpha + endl ) ; System . out . print ( num + endl ) ; System . out . print ( special ) ; }
static int binaryMedian ( int m [ ] [ ] , int r , int c ) { int min = Integer . MAX_VALUE , max = Integer . MIN_VALUE ; for ( int i = 0 ; i < r ; i ++ ) { if ( m [ i ] [ 0 ] < min ) min = m [ i ] [ 0 ] ; if ( m [ i ] [ c - 1 ] > max ) max = m [ i ] [ c - 1 ] ; } int desired = ( r * c + 1 ) / 2 ; while ( min < max ) { int mid = min + ( max - min ) / 2 ; int place = 0 ; for ( int i = 0 ; i < r ; ++ i ) place += upper_bound ( m [ i ] , m [ i ] + c , mid ) - m [ i ] ; if ( place < desired ) min = mid + 1 ; else max = mid ; } return min ; }
static void printDuplicates ( int arr [ ] , int n ) { HashMap < Integer , Integer > freq = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) freq . put ( arr [ i ] , freq . get ( arr [ i ] ) + 1 ) ; boolean dup = false ; HashMap < Integer , Integer > hM = new HashMap < Integer , Integer > ( ) ; for ( int itr = freq . begin ( ) ; itr != freq . end ( ) ; itr ++ ) { if ( itr -> second > 1 ) { System . out . print ( itr -> first + " ▁ " ) ; dup = true ; } } if ( dup == false ) System . out . println ( " - 1" ) ; }
public static void stoogesort ( int arr [ ] , int l , int h ) { if ( l >= h ) return ; if ( arr [ l ] > arr [ h ] ) swap ( arr [ l ] , arr [ h ] ) ; if ( h - l + 1 > 2 ) { int t = ( h - l + 1 ) / 3 ; stoogesort ( arr , l , h - t ) ; stoogesort ( arr , l + t , h ) ; stoogesort ( arr , l , h - t ) ; } else { int t = ( h - l + 1 ) / 3 ; stoogesort ( arr , l , h - t ) ; stoogesort ( arr , l + t , h ) ; stoogesort ( arr , l , h - t ) ; } }
static void printEqualModNumbers ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int d = arr [ n - 1 ] - arr [ 0 ] ; Vector < Integer > v = new Vector < > ( ) ; for ( int i = 1 ; i * i <= d ; i ++ ) { if ( d % i == 0 ) { v . add ( i ) ; if ( i != d / i ) v . add ( d / i ) ; } } for ( int i = 0 ; i < v . size ( ) ; i ++ ) { int temp = arr [ 0 ] % v [ i ] ; int j ; for ( j = 1 ; j < n ; j ++ ) if ( arr [ j ] % v [ i ] != temp ) break ; if ( j == n ) System . out . print ( v [ i ] + " ▁ " ) ; } } for ( int i = 0 ; i < v . size ( ) ; i ++ ) { int temp = arr [ 0 ] % v [ i ] ; int j ; for ( j = 1 ; j < n ; j ++ ) if ( arr [ j ] % v [ i ] != temp ) break ; if ( j == n ) System . out . print ( v [ i ] + " ▁ " ) ; } }
static void recursiveReverse ( String str ) { Stack < Character > st = new Stack < Character > ( ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) st . push ( str . charAt ( i ) ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { str . charAt ( i ) = st . peek ( ) ; st . pop ( ) ; } }
static void printRect ( int X [ ] , int Y [ ] , int n ) { int Xmax = Arrays . stream ( X ) . max ( ) . getAsInt ( ) ; int Xmin = Arrays . stream ( X ) . min ( ) . getAsInt ( ) ; int Ymax = Arrays . stream ( Y ) . max ( ) . getAsInt ( ) ; int Ymin = Arrays . stream ( Y ) . min ( ) . getAsInt ( ) ; System . out . print ( " { " + Xmin + " , ▁ " + Ymin + " } " ) ; System . out . print ( " { " + Xmax + " , ▁ " + Ymax + " } " ) ; System . out . print ( " { " + Xmax + " , ▁ " + Ymin + " } " ) ; System . out . print ( " { " + Xmax + " , ▁ " + Ymax + " } " ) ; System . out . print ( " " ) ; }
static void NFG ( int a [ ] , int n , int freq [ ] ) { Stack < Integer > s = new Stack < > ( ) ; s . push ( 0 ) ; int [ ] res = new int [ n ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( freq [ a [ s . peek ( ) ] ] > freq [ a [ i ] ] ) s . push ( i ) ; else { while ( freq [ a [ s . peek ( ) ] ] < freq [ a [ i ] ] && ! s . empty ( ) ) { res [ s . peek ( ) ] = a [ i ] ; s . pop ( ) ; } s . push ( i ) ; } } while ( ! s . empty ( ) ) { res [ s . peek ( ) ] = - 1 ; s . pop ( ) ; } for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( res [ i ] + " ▁ " ) ; } }
static void printEqualSumSets ( int arr [ ] , int n ) { int i , currSum ; int sum = 0 ; if ( sum & 1 ) { System . out . println ( " - 1 " ) ; return ; } int k = sum >> 1 ; boolean dp [ ] [ ] = new boolean [ n + 1 ] [ k + 1 ] ; for ( i = 0 ; i <= n ; i ++ ) { dp [ 0 ] [ i ] = false ; } for ( i = 1 ; i <= n ; i ++ ) { dp [ i ] [ 0 ] = true ; } for ( i = 1 ; i <= n ; i ++ ) { for ( currSum = 1 ; currSum <= k ; currSum ++ ) { dp [ i ] [ currSum ] = dp [ i - 1 ] [ currSum ] ; if ( arr [ i - 1 ] <= currSum ) { dp [ i ] [ currSum ] = dp [ i ] [ currSum ] | dp [ i - 1 ] [ currSum - arr [ i - 1 ] ] ; } } vector < Integer > set1 , set2 ; if ( ! dp [ n ] [ k ] ) { System . out . println ( " - 1 " ) ; return ; } i = n ; currSum = k ; while ( i > 0 && currSum >= 0 ) { if ( dp [ i - 1 ] [ currSum ] ) { i -- ; currSum -= arr [ i ] ; } } System . out . println ( " Set ▁ 1 ▁ elements : ▁ " ) ; for ( i = 0 ; i < set1 . size ( ) ; i ++ ) System . out . print ( set1 [ i ] + " ▁ " ) ; i ++ ) System . out . print ( " " ) ; i ++ ) System . out . print ( set2 [ i ] + " ▁ " ) ; } System . out . println ( " Set ▁ 2 ▁ elements : ▁ " ) ; for ( i = 0 ; i < set2 . size ( ) ; i ++ ) System . out . print ( set2 [ i ] + " ▁ " ) ; i ++ ) System . out . print ( " " ) ; i ++ ) System . out . print ( set2 [ i ] + " �
static void reverseStr ( String str ) { int n = str . length ( ) ; for ( int i = 0 , j = n - 1 ; i < j ; i ++ , j -- ) swap ( str . charAt ( i ) , str . charAt ( j ) ) ; }
static void minimizeWithKSwaps ( int arr [ ] , int n , int k ) { for ( int i = 0 ; i < n - 1 && k > 0 ; ++ i ) { int pos = i ; for ( int j = i + 1 ; j < n ; ++ j ) { if ( j - i > k ) break ; if ( arr [ j ] < arr [ pos ] ) pos = j ; } for ( int j = pos ; j > i ; -- j ) swap ( arr [ j ] , arr [ j - 1 ] ) ; k -= pos - i ; } }
static int countSubarrays ( int arr [ ] , int n ) { int difference = 0 ; int ans = 0 ; int [ ] hash_positive = new int [ n + 1 ] , hash_negative = new int [ n + 1 ] ; fill_n ( hash_positive , n + 1 , 0 ) ; fill_n ( hash_negative , n + 1 , 0 ) ; hash_positive [ 0 ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] & 1 == 1 ) difference ++ ; else difference -- ; if ( difference < 0 ) { ans += hash_negative [ - difference ] ; hash_negative [ - difference ] ++ ; } else { ans += hash_positive [ difference ] ; hash_positive [ difference ] ++ ; } } return ans ; }
boolean findPairs ( int arr [ ] , int n ) { HashMap < Integer , Integer > Hash = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; ++ i ) { for ( int j = i + 1 ; j < n ; ++ j ) { int sum = arr [ i ] + arr [ j ] ; if ( Hash . containsKey ( sum ) ) Hash . put ( sum , make_pair ( i , j ) ) ; else { pair < int , Integer > pp = Hash . get ( sum ) ; System . out . println ( " ( " + arr [ pp . first ] + " , ▁ " + arr [ pp . second ] + " ) ▁ and ▁ ( " + arr [ i ] + " , ▁ " + arr [ j ] + " ) n " ) ; return true ; } } } System . out . println ( " No ▁ pairs ▁ found " ) ; return false ; }
static boolean check ( String s1 , String s2 ) { int n = s1 . length ( ) ; int m = s2 . length ( ) ; boolean dp [ ] [ ] = new boolean [ n + 1 ] [ m + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= m ; j ++ ) { dp [ i ] [ j ] = false ; } } dp [ 0 ] [ 0 ] = true ; for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) { for ( int j = 0 ; j <= s2 . length ( ) ; j ++ ) { if ( dp [ i ] [ j ] ) { if ( j < s2 . length ( ) && ( toupper ( s1 . charAt ( i ) ) == s2 . charAt ( j ) ) ) { dp [ i + 1 ] [ j + 1 ] = true ; if ( ! isupper ( s1 . charAt ( i ) ) ) { dp [ i + 1 ] [ j ] = true ; } } } return ( dp [ n ] [ m ] ) ; }
static Boolean checkDuplicatesWithinK ( int arr [ ] , int n , int k ) { HashMap < Integer , Integer > myset = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( myset . contains ( arr [ i ] ) ) return true ; myset . add ( arr [ i ] ) ; if ( i >= k ) myset . remove ( arr [ i - k ] ) ; } return false ; }
static int minOperation ( int arr [ ] , int n ) { HashMap < Integer , Integer > hash = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) hash . put ( arr [ i ] , hash . get ( arr [ i ] ) + 1 ) ; int max_count = 0 ; for ( auto i : hash ) if ( max_count < i . second ) max_count = i . second ; return ( n - max_count ) ; }
static int findSum ( String str ) { String temp = " " ; int sum = 0 ; for ( char ch : str ) { if ( isdigit ( ch ) ) temp += ch ; else { sum += atoi ( temp . c_str ( ) ) ; temp = " " ; } } return sum + atoi ( temp . c_str ( ) ) ; }
static int mostFrequent ( int arr [ ] , int n ) { HashMap < Integer , Integer > hash = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) hash . put ( arr [ i ] , hash . get ( arr [ i ] ) + 1 ) ; int max_count = 0 , res = - 1 ; for ( auto i : hash ) { if ( max_count < i . second ) { res = i . first ; max_count = i . second ; } } return res ; }
static String firstLetterWord ( String str ) { String result = " " ; boolean v = true ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) == ' ▁ ' ) v = true ; else if ( str . charAt ( i ) != ' ▁ ' && v == true ) { result += str . charAt ( i ) ; v = false ; } } return result ; }
static int findFourElements ( int arr [ ] , int n ) { HashMap < Integer , Integer > myMap = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) myMap . put ( arr [ i ] + arr [ j ] , myMap . get ( arr [ i ] + arr [ j ] ) ) ; int d = Integer . MIN_VALUE ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int abs_diff = Math . abs ( arr [ i ] - arr [ j ] ) ; if ( myMap . containsKey ( abs_diff ) ) myMap . put ( abs_diff , myMap . get ( arr [ i ] + arr [ j ] ) ) ; } } return d ; }
static int maxNumOfChocolates ( int arr [ ] , int n , int k ) { HashMap < Integer , Integer > hM = new HashMap < Integer , Integer > ( ) ; int sum [ ] = new int [ n ] , curr_rem ; int maxSum = 0 ; sum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) sum [ i ] = sum [ i - 1 ] + arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) { curr_rem = sum [ i ] % k ; if ( curr_rem == 0 ) { if ( maxSum < sum [ i ] ) maxSum = sum [ i ] ; } else if ( um . containsKey ( curr_rem ) ) um [ curr_rem ] = i ; else if ( maxSum < ( sum [ i ] - sum [ um [ curr_rem ] ] ) ) maxSum = sum [ i ] - sum [ um [ curr_rem ] ] ; } return ( maxSum / k ) ; }
static String decode ( String str ) { Stack < Integer > integerstack = new Stack < > ( ) ; Stack < Character > stringstack = new Stack < Character > ( ) ; String temp = " " , result = " " ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { int count = 0 ; if ( str . charAt ( i ) >= '0' && str . charAt ( i ) <= '9' ) { while ( str . charAt ( i ) >= '0' && str . charAt ( i ) <= '9' ) { count = count * 10 + str . charAt ( i ) - '0' ; i ++ ; } i -- ; integerstack . add ( count ) ; } else if ( str . charAt ( i ) == ' [ ' ) { temp = " " ; count = 0 ; if ( ! integerstack . empty ( ) ) { count = integerstack . peek ( ) ; integerstack . pop ( ) ; } if ( ! stringstack . empty ( ) && stringstack . peek ( ) == ' [ ' ) { temp = stringstack . peek ( ) + temp ; stringstack . pop ( ) ; } if ( ! stringstack . isEmpty ( ) ) { result = stringstack . peek ( ) + result ; stringstack . pop ( ) ; } return result ; }
static int minSum ( int A [ ] , int n ) { int min_val = * min_element ( A , A + n ) ; return ( min_val * ( n - 1 ) ) ; }
static int countWords ( String str , int n ) { HashMap < String , Integer > m = new HashMap < String , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) m . put ( str , m . get ( str . charAt ( i ) ) + 1 ) ; int res = 0 ; for ( auto it = m . begin ( ) ; it != m . end ( ) ; it ++ ) if ( ( it -> second == 2 ) ) res ++ ; return res ; }
static void sortUsingHash ( int a [ ] , int n ) { int max = Arrays . stream ( a ) . max ( ) . getAsInt ( ) ; int [ ] hash = new int [ max + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) hash [ a [ i ] ] += 1 ; for ( int i = 0 ; i <= max ; i ++ ) { if ( hash [ i ] ) { for ( int j = 0 ; j < hash [ i ] ; j ++ ) { System . out . print ( i + " ▁ " ) ; } } } }
static boolean isDivisible ( String str , int k ) { int n = str . length ( ) ; int c = 0 ; for ( int i = 0 ; i < k ; i ++ ) if ( str . charAt ( n - i - 1 ) == '0' ) c ++ ; return ( c == k ) ; }
static int divisible ( String num ) { int n = num . length ( ) ; int sum = accumulate ( begin ( num ) , end ( num ) , 0 ) - '0' * 1 ; if ( sum % 3 == 0 ) return 0 ; if ( n == 1 ) return - 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( sum % 3 == ( num . charAt ( i ) - '0' ) % 3 ) return 1 ; if ( n == 2 ) return - 1 ; return 2 ; }
static int longSubarrWthSumDivByK ( int arr [ ] , int n , int k ) { HashMap < Integer , Integer > um = new HashMap < Integer , Integer > ( ) ; int max = 0 ; int curr_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { curr_sum += arr [ i ] ; mod_arr [ i ] = ( ( curr_sum % k ) + k ) % k ; } for ( int i = 0 ; i < n ; i ++ ) { if ( mod_arr [ i ] == 0 ) max = i + 1 ; else if ( um . containsKey ( mod_arr [ i ] ) ) um . put ( mod_arr [ i ] , i ) ; else if ( max < ( i - um [ mod_arr [ i ] ] ) ) max = i - um [ mod_arr [ i ] ] ; } return max ; }
static void reverse ( String str ) { if ( str . length ( ) == 0 ) { return ; } reverse ( str . substring ( 1 ) ) ; System . out . print ( str . charAt ( 0 ) ) ; }
static boolean isDvisibleBy12 ( String num ) { if ( num . length ( ) >= 3 ) { int d1 = ( int ) num . charAt ( num . length ( ) - 1 ) ; if ( d1 % 2 != 0 ) return ( 0 ) ; int d2 = ( int ) num . charAt ( num . length ( ) - 2 ) ; int sum = 0 ; for ( int i = 0 ; i < num . length ( ) ; i ++ ) sum += num . charAt ( i ) ; return ( sum % 3 == 0 && ( d2 * 10 + d1 ) % 4 == 0 ) ; } else { int number = stoi ( num ) ; return ( number % 12 == 0 ) ; } }
static int xorZero ( String str ) { int one_count = 0 , zero_count = 0 ; int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) if ( str . charAt ( i ) == '1' ) one_count ++ ; else zero_count ++ ; if ( one_count % 2 == 0 ) return zero_count ; return one_count ; }
static double nthRoot ( int A , int N ) { double xPre = rand ( ) % 10 ; double eps = 1e - 3 ; double delX = Integer . MAX_VALUE ; double xK = ( ( N - 1.0 ) * xPre + ( double ) A / pow ( xPre , N - 1 ) ) / ( double ) N ; delX = Math . abs ( xK - xPre ) ; xPre = xK ; } return xK ; }
static String findLeft ( String str ) { int n = str . length ( ) ; while ( n -- ) { if ( str . charAt ( n ) == ' d ' ) { str . charAt ( n ) = ' c ' ; break ; } if ( str . charAt ( n ) == ' b ' ) { str . charAt ( n ) = ' a ' ; break ; } if ( str . charAt ( n ) == ' a ' ) { str . charAt ( n ) = ' b ' ; } else if ( str . charAt ( n ) == ' c ' ) str . charAt ( n ) = ' d ' ; } return str ; }
static void minRange ( int arr [ ] , int n , int k ) { int l = 0 , r = n ; for ( int i = 0 ; i < n ; i ++ ) { HashMap < Integer , Integer > hM = new HashMap < Integer , Integer > ( ) ; int j ; for ( j = i ; j < n ; j ++ ) { s . add ( arr [ j ] ) ; if ( s . size ( ) == k ) { if ( ( j - i ) < ( r - l ) ) { r = j ; l = i ; } break ; } } if ( j == n ) break ; } if ( l == 0 && r == n ) System . out . println ( " Invalid ▁ k " ) ; else System . out . print ( l + " ▁ " + r ) ; }
static int findSum ( int A [ ] , int B [ ] , int n ) { HashMap < Integer , Integer > hash = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { hash . put ( A [ i ] , hash . get ( B [ i ] ) + 1 ) ; } int sum = 0 ; for ( auto x : hash ) if ( x . second == 1 ) sum += x . first ; return sum ; }
static void arrayEvenAndOdd ( int arr [ ] , int n ) { int i = - 1 , j = 0 ; int t ; while ( j != n ) { if ( arr [ j ] % 2 == 0 ) { i ++ ; swap ( arr [ i ] , arr [ j ] ) ; } j ++ ; } for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; }
static boolean containsOdd ( int G [ ] [ ] , int src ) { int colorArr [ ] = new int [ V ] ; for ( int i = 0 ; i < V ; ++ i ) colorArr [ i ] = - 1 ; colorArr [ src ] = 1 ; Queue < Integer > q = new LinkedList < Integer > ( ) ; q . add ( src ) ; while ( ! q . isEmpty ( ) ) { int u = q . peek ( ) ; q . remove ( ) ; if ( G [ u ] [ u ] == 1 ) return true ; for ( int v = 0 ; v < V ; ++ v ) { if ( G [ u ] [ v ] && colorArr [ v ] == - 1 ) { colorArr [ v ] = 1 - colorArr [ u ] ; q . add ( v ) ; } else if ( G [ u ] [ v ] && colorArr [ v ] == colorArr [ u ] ) return true ; } } return false ; }
static int getMinSquares ( int n ) { if ( ( n ) - floor ( Math . sqrt ( n ) ) == 0 ) return 1 ; if ( n <= 3 ) return n ; int res = n ; for ( int x = 1 ; x <= n ; x ++ ) { int temp = x * x ; if ( temp > n ) break ; else res = Math . min ( res , 1 + getMinSquares ( n - temp ) ) ; } return res ; }
static int maxDistance ( int arr [ ] , int n ) { HashMap < Integer , Integer > myMap = new HashMap < Integer , Integer > ( ) ; int max_dist = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! myMap . containsKey ( arr [ i ] ) ) myMap . put ( arr [ i ] , i ) ; else max_dist = Math . max ( max_dist , i - myMap . get ( arr [ i ] ) ) ; } return max_dist ; }
static int selectRandom ( int x ) { static int res ; static int count = 0 ; count ++ ; if ( count == 1 ) res = x ; else { int i = rand ( ) % count ; if ( i == count - 1 ) res = x ; } return res ; }
static int cost ( int a [ ] , int n ) { return ( n - 1 ) * ( * min_element ( a , a + n ) ) ; }
public static void gnomeSort ( int arr [ ] , int n ) { int index = 0 ; while ( index < n ) { if ( index == 0 ) index ++ ; if ( arr [ index ] >= arr [ index - 1 ] ) index ++ ; else { if ( arr [ index ] >= arr [ index - 1 ] ) index -- ; } } return ; }
static boolean sortedAfterSwap ( int A [ ] , boolean B [ ] , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( B [ i ] ) { if ( A [ i ] != i + 1 ) swap ( A [ i ] , A [ i + 1 ] ) ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( A [ i ] != i + 1 ) return false ; } return true ; }
static void moveSpaceInFront ( String str ) { int i = str . length ( ) ; for ( int j = i ; j >= 0 ; j -- ) if ( str [ j ] != ' ▁ ' ) str [ i -- ] = str . charAt ( j ) ; while ( i >= 0 ) str [ i -- ] = ' ▁ ' ; }
static int countOfBinaryNumberLessThanN ( int N ) { Queue < Integer > q = new LinkedList < Integer > ( ) ; q . add ( 1 ) ; int cnt = 0 ; int t ; while ( ! q . isEmpty ( ) ) { t = q . peek ( ) ; q . remove ( ) ; if ( t <= N ) { cnt ++ ; q . add ( t * 10 ) ; q . add ( t * 10 + 1 ) ; } } return cnt ; }
static int substringConversions ( String str , int k , int b ) { int i = 0 , sum = 0 , counter = k - 1 ; for ( i ; i < k ; i ++ ) { sum = sum + ( ( str . charAt ( i ) - '0' ) * pow ( b , counter ) ) ; counter -- ; } System . out . println ( sum + " ▁ " ) ; int prev = sum ; sum = 0 , counter = 0 ; for ( i ; i < str . size ( ) ; i ++ ) { sum = prev - ( ( str . charAt ( i - k ) - '0' ) * pow ( b , k - 1 ) ) ; sum = sum * b ; sum = sum + ( str . charAt ( i ) - '0' ) ; System . out . println ( sum + " ▁ " ) ; prev = sum ; counter ++ ; } }
static String longestRepeatedSubSeq ( String str ) { int n = str . length ( ) ; int dp [ ] [ ] = new int [ n + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= n ; j ++ ) { dp [ i ] [ j ] = 0 ; } for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= n ; j ++ ) if ( str . charAt ( i - 1 ) == str . charAt ( j - 1 ) && i != j ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = Math . max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ; String res = " " ; int i = n , j = n ; while ( i > 0 && j > 0 ) { if ( dp [ i ] [ j ] == dp [ i - 1 ] [ j - 1 ] + 1 ) { res = res + str . charAt ( i - 1 ) ; i -- ; j -- ; } else if ( dp [ i ] [ j ] == dp [ i - 1 ] [ j ] ) i -- ; else j -- ; } reverse ( res . begin ( ) , res . end ( ) ) ; return res ; }
static void rearrange ( int a [ ] , int size ) { int positive = 0 , negative = 1 ; while ( true ) { while ( positive < size && a [ positive ] >= 0 ) positive += 2 ; while ( negative < size && a [ negative ] <= 0 ) negative += 2 ; if ( positive < size && negative < size ) swap ( a [ positive ] , a [ negative ] ) ; else break ; } }
public static void bubbleSort ( int arr [ ] , int n ) { int i , j ; for ( i = 0 ; i < n - 1 ; i ++ ) for ( j = 0 ; j < n - i - 1 ; j ++ ) if ( arr [ j ] > arr [ j + 1 ] ) swap ( & arr [ j ] , & arr [ j + 1 ] ) ; }
static String reversingString ( String str , int start , int end ) { while ( start < end ) { str [ start ] ^= str [ end ] ; str [ end ] ^= str [ start ] ; str [ start ] ^= str [ end ] ; ++ start ; -- end ; } return str ; }
static int minimalSteps ( String s , int n ) { int dp [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] = Integer . MAX_VALUE ; } String s1 = " " , s2 = " " ; dp [ 0 ] = 1 ; s1 += s . charAt ( 0 ) ; for ( int i = 1 ; i < n ; i ++ ) { s1 += s . charAt ( i ) ; s2 = s . charAt ( i + 1 , i + 1 ) ; dp [ i ] = Math . min ( dp [ i ] , dp [ i - 1 ] + 1 ) ; if ( s1 == s2 ) { dp [ i * 2 + 1 ] = Math . min ( dp [ i ] + 1 , dp [ i * 2 + 1 ] ) ; } } return dp [ n - 1 ] ; }
static int MinimumCost ( int cost [ ] , int n , int W ) { Vector < Integer > val = new Vector < > ( ) ; Vector < Integer > wt = new Vector < > ( ) ; int size = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( cost [ i ] != - 1 ) { val . add ( cost [ i ] ) ; wt . add ( i + 1 ) ; size ++ ; } } n = size ; int min_cost [ n + 1 ] [ W + 1 ] ; for ( int i = 0 ; i <= W ; i ++ ) min_cost [ 0 ] [ i ] = INF ; for ( int i = 1 ; i <= n ; i ++ ) min_cost [ i ] [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= W ; j ++ ) { if ( wt [ i - 1 ] > j ) min_cost [ i ] [ j ] = min_cost [ i - 1 ] [ j ] ; else min_cost [ i ] [ j ] = Math . min ( min_cost [ i - 1 ] [ j ] , min_cost [ i ] [ j - wt [ i - 1 ] ] + val [ i - 1 ] ) ; } } return ( min_cost [ n ] [ W ] == INF ) ? - 1 : min_cost [ n ] [ W ] ; }
static void bitonicGenerator ( int arr [ ] , int n ) { Vector < Integer > evenArr = new Vector < > ( ) ; Vector < Integer > oddArr = new Vector < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! ( i % 2 ) ) evenArr . add ( arr [ i ] ) ; else oddArr . add ( arr [ i ] ) ; } Arrays . sort ( evenArr ) ; Arrays . sort ( oddArr ) ; int i = 0 ; for ( int j = 0 ; j < evenArr . size ( ) ; j ++ ) arr [ i ++ ] = evenArr [ j ] ; for ( int j = 0 ; j < oddArr . size ( ) ; j ++ ) arr [ i ++ ] = oddArr [ j ] ; } for ( int i = 0 ; i < evenArr . size ( ) ; j ++ ) arr [ i ++ ] = evenArr [ j ] ; for ( int j = 0 ; j < oddArr . size ( ) ; j ++ ) arr [ i ++ ] = oddArr [ j ] ; }
static void printFirstRepeating ( int arr [ ] , int n ) { int min = - 1 ; HashSet < Integer > myset = new HashSet < Integer > ( ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( myset . contains ( arr [ i ] ) ) min = i ; else myset . add ( arr [ i ] ) ; } if ( min != - 1 ) System . out . println ( " The ▁ first ▁ repeating ▁ element ▁ is ▁ " + arr [ min ] ) ; else System . out . println ( " There ▁ are ▁ no ▁ repeating ▁ elements " ) ; }
static int lps ( String str ) { int n = str . length ( ) ; int [ ] [ ] L = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) L [ i ] [ i ] = 1 ; for ( cl = 2 ; cl <= n ; cl ++ ) { for ( i = 0 ; i < n - cl + 1 ; i ++ ) { j = i + cl - 1 ; if ( str . charAt ( i ) == str . charAt ( j ) && cl == 2 ) L [ i ] [ j ] = 2 ; else if ( str . charAt ( i ) == str . charAt ( j ) ) L [ i ] [ j ] = L [ i + 1 ] [ j - 1 ] + 2 ; else L [ i ] [ j ] = Math . max ( L [ i ] [ j - 1 ] , L [ i + 1 ] [ j ] ) ; } } return L [ 0 ] [ n - 1 ] ; }
static String censor ( String text , String word ) { List < String > word_list = new ArrayList < String > ( ) ; boost :: split ( word_list , text , boost :: is_any_of ( " \\ ▁ + " ) ) ; String result = " " ; String stars = " " ; for ( int i = 0 ; i < word . size ( ) ; i ++ ) stars += ' * ' ; int index = 0 ; for ( String i : word_list ) { if ( i . compareTo ( word ) == 0 ) { word_list [ index ] = stars ; } index ++ ; } for ( String i : word_list ) { result += i + ' ▁ ' ; } return result ; }
static boolean isRotated ( String str1 , String str2 ) { if ( str1 . length ( ) != str2 . length ( ) ) return false ; String clock_rot = " " ; String anticlock_rot = " " ; int len = str2 . length ( ) ; anticlock_rot = anticlock_rot + str2 . substr ( len - 2 , 2 ) + str2 . substr ( 0 , len - 2 ) ; clock_rot = clock_rot + str2 . substr ( 2 ) + str2 . substr ( 0 , 2 ) ; return ( str1 . compareTo ( clock_rot ) == 0 || str1 . compareTo ( anticlock_rot ) == 0 ) ; }
static int findDiff ( int arr [ ] , int n ) { HashMap < Integer , Integer > hm = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) hm . put ( arr [ i ] , hm . get ( arr [ i ] ) + 1 ) ; int max_count = 0 , min_count = n ; for ( auto x : hm ) { max_count = Math . max ( max_count , x . second ) ; min_count = Math . min ( min_count , x . second ) ; } return ( max_count - min_count ) ; }
static int playGame ( int arr [ ] , int n ) { HashMap < Integer , Integer > hash = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) hash . add ( arr [ i ] ) ; return ( hash . size ( ) % 2 == 0 ? 1 : 2 ) ; }
static int subset ( int arr [ ] ) { HashMap < Integer , Integer > myMap = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < arr . length ; i ++ ) myMap . put ( arr [ i ] , myMap . get ( arr [ i ] ) + 1 ) ; int res = 0 ; for ( AutoMap < Integer , Integer > x : myMap ) res = Math . max ( res , x . second ) ; return res ; }
boolean isProduct ( int arr [ ] , int n , int x ) { if ( n < 2 ) return false ; HashSet < Integer > s = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) { if ( x == 0 ) return true ; else continue ; } if ( x % arr [ i ] == 0 ) { if ( s . contains ( arr [ i ] ) ) return true ; s . add ( arr [ i ] ) ; } } return false ; }
static int findRotations ( String str ) { String tmp = str + str ; int n = str . length ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { String substring = tmp . substring ( i , str . size ( ) ) ; if ( str == substring ) return i ; } return n ; }
static void randomize ( int arr [ ] , int n ) { Random rand = new Random ( ) ; for ( int i = n - 1 ; i > 0 ; i -- ) { int j = rand ( ) % ( i + 1 ) ; swap ( & arr [ i ] , & arr [ j ] ) ; } }
static void translate ( String str ) { int len = str . length ( ) ; if ( len < 2 ) return ; int i = 0 ; int j = 0 ; while ( j < len - 1 ) { if ( str . charAt ( j ) == ' A ' && str . charAt ( j + 1 ) == ' B ' ) { j = j + 2 ; str . charAt ( i ++ ) = ' C ' ; continue ; } str [ i ++ ] = str . charAt ( j ++ ) ; } if ( j == len - 1 ) str [ i ++ ] = str . charAt ( j ) ; str [ i ] = '' ; }
static int maxLen ( int arr [ ] , int n ) { HashMap < Integer , Integer > hM = new HashMap < Integer , Integer > ( ) ; int sum = 0 ; int max_len = 0 ; int ending_index = - 1 ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = ( arr [ i ] == 0 ) ? - 1 : 1 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( sum == 0 ) { max_len = i + 1 ; ending_index = i ; } if ( hM . containsKey ( sum + n ) ) { if ( max_len < i - hM [ sum + n ] ) { max_len = i - hM [ sum + n ] ; ending_index = i ; } } else hM . put ( sum + n , i ) ; } for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = ( arr [ i ] == - 1 ) ? 0 : 1 ; System . out . println ( " % d ▁ to ▁ " + ending_index - max_len + 1 , ending_index ) ; return max_len ; }
static int numberofways ( String A , String B , int N , int M ) { Vector < Integer > [ ] pos = new Vector [ MAX ] ; for ( int i = 0 ; i < M ; i ++ ) pos [ B [ i ] ] . add ( i + 1 ) ; int dpl [ ] [ ] = new int [ N + 2 ] [ M + 2 ] ; Arrays . fill ( dpl , 0 ) ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 1 ; j <= M ; j ++ ) { if ( A [ i - 1 ] == B [ j - 1 ] ) dpl [ i ] [ j ] = dpl [ i - 1 ] [ j - 1 ] + 1 ; else dpl [ i ] [ j ] = Math . max ( dpl [ i + 1 ] [ j ] , dpl [ i ] [ j - 1 ] ) ; } } int LCS = dpl [ N ] [ M ] ; for ( int i = N ; i >= 1 ; i -- ) { for ( int j = M ; j >= 1 ; j -- ) { if ( A [ i - 1 ] == B [ j - 1 ] ) dpr [ i ] [ j ] = dpr [ i + 1 ] [ j + 1 ] + 1 ; else dpr [ i ] [ j ] = Math . max ( dpr [ i + 1 ] [ j ] , dpr [ i ] [ j + 1 ] ) ; } } return ans ; }
static int substringConversions ( String str , int k , int b ) { for ( int i = 0 ; i + k <= str . length ( ) ; i ++ ) { String sub = str . substring ( i , k ) ; int sum = 0 , counter = 0 ; for ( int i = sub . size ( ) - 1 ; i >= 0 ; i -- ) { sum = sum + ( ( sub . charAt ( i ) - '0' ) * pow ( b , counter ) ) ; counter ++ ; } System . out . println ( sum + " ▁ " ) ; } return 0 ; }
static int SumOfKsubArray ( int arr [ ] , int n , int k ) { int sum = 0 ; deque < Integer > S = new LinkedList < Integer > ( ) , G = new LinkedList < Integer > ( ) ; int i = 0 ; for ( i = 0 ; i < k ; i ++ ) { while ( ( ! S . empty ( ) ) && arr [ S . back ( ) ] >= arr [ i ] ) S . pop_back ( ) ; while ( ( ! G . empty ( ) ) && arr [ G . back ( ) ] <= arr [ i ] ) G . pop_back ( ) ; S . add ( i ) ; S . add_back ( i ) ; } for ( ; i < n ; i ++ ) { sum += arr [ S . peek ( ) ] + arr [ G . peek ( ) ] ; while ( ! S . empty ( ) ) && arr [ S . back ( ) ] >= arr [ i ] ) S . pop_back ( ) ; while ( ( ! G . empty ( ) ) && arr [ G . back ( ) ] <= arr [ i ] ) G . pop_back ( ) ; S . add_back ( i ) ; } sum += arr [ S . peek ( ) ] + arr [ G . peek ( ) ] ; return sum ; }
static String arrangeString ( String str ) { int [ ] char_count = new int [ MAX_CHAR ] ; int sum = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) >= ' A ' && str . charAt ( i ) <= ' Z ' ) char_count [ str . charAt ( i ) - ' A ' ] ++ ; else sum = sum + ( str . charAt ( i ) - ' 0' ) ; } String res = " " ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { char ch = ( char ) ( ' A ' + i ) ; while ( char_count [ i ] -- ) res = res + ch ; } if ( sum > 0 ) res = res + String . valueOf ( sum ) ; return res ; }
static int waysToIncreaseLCSBy1 ( String str1 , String str2 ) { int m = str1 . length ( ) , n = str2 . length ( ) ; Vector < Integer > position [ ] = new Vector [ M ] ; for ( int i = 0 ; i <= n ; i ++ ) position [ toInt ( str2 . charAt ( i - 1 ) ] . add ( i ) ; int lcsl [ ] [ ] = new int [ m + 2 ] [ n + 2 ] ; for ( int i = 0 ; i <= m + 1 ; i ++ ) for ( int j = 0 ; j <= n + 1 ; j ++ ) lcsl [ i ] [ j ] = lcsr [ i ] [ j ] = 0 ; for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( str1 [ i - 1 ] == str2 [ j - 1 ] ) lcsl [ i ] [ j ] = 1 + lcsl [ i - 1 ] [ j - 1 ] ; else lcsl [ i ] [ j ] = Math . max ( lcsl [ i + 1 ] [ j ] , lccsr [ i ] [ j + 1 ] ) ; } } for ( int i = m ; i >= 1 ; i -- ) { for ( int j = n ; j >= 1 ; j -- ) { if ( str1 [ i - 1 ] == str2 [ j - 1 ] ) lcsr [ i ] [ j ] = 1 + lcsr [ i + 1 ] [ j + 1 ] ; else lcsr [ i ] [ j ] = Math . max ( lcsr [ i + 1 ] [ j ] , lcsr [ i ] [ j + 1 ] ) ; } } } return ways ; }
static int lis ( int arr [ ] , int n ) { int lis [ ] = new int [ n ] ; lis [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { lis [ i ] = 1 ; } for ( int j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; } return * max_element ( lis , lis + n ) ; }
static void SternSequenceFunc ( Vector < Integer > BrocotSequence , int n ) { for ( int i = 1 ; BrocotSequence . size ( ) < n ; i ++ ) { int considered_element = BrocotSequence . get ( i ) ; int precedent = BrocotSequence . get ( i - 1 ) ; BrocotSequence . add ( considered_element + precedent ) ; BrocotSequence . add ( considered_element ) ; } for ( int i = 0 ; i < 15 ; ++ i ) System . out . print ( BrocotSequence [ i ] + " ▁ " ) ; }
static void printBracketNumber ( String exp , int n ) { int left_bnum = 1 ; Stack < Integer > right_bnum = new Stack < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( exp . charAt ( i ) == ' ( ' ) { System . out . print ( left_bnum + " ▁ " ) ; right_bnum . push ( left_bnum ) ; left_bnum ++ ; } else if ( exp . charAt ( i ) == ' ( ' ) { System . out . print ( right_bnum . peek ( ) + " ▁ " ) ; right_bnum . remove ( ) ; } } }
static int returnMaxSum ( int A [ ] , int B [ ] , int n ) { HashMap < Integer , Integer > hM = new HashMap < Integer , Integer > ( ) ; int result = 0 ; int curr_sum = 0 , curr_begin = 0 ; for ( int i = 0 ; i < n ; ++ i ) { while ( hM . contains ( A [ i ] ) ) { hM . remove ( A [ curr_begin ] ) ; curr_sum -= B [ curr_begin ] ; curr_begin ++ ; } hM . add ( A [ i ] ) ; curr_sum += B [ i ] ; result = Math . max ( result , curr_sum ) ; } return result ; }
static int getPairsCount ( int arr [ ] , int n , int sum ) { HashMap < Integer , Integer > m = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) m . put ( arr [ i ] , m . get ( arr [ i ] ) + 1 ) ; int twice_count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { twice_count += m . get ( sum - arr [ i ] ) ; if ( sum - arr [ i ] == arr [ i ] ) twice_count -- ; } return twice_count / 2 ; }
static void rearrange ( int arr [ ] , int n ) { int i = - 1 ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] < 0 ) { i ++ ; swap ( & arr [ i ] , & arr [ j ] ) ; } } int pos = i + 1 , neg = 0 ; while ( pos < n && neg < pos && arr [ neg ] < 0 ) { temp = arr [ neg ] ; pos ++ ; neg += 2 ; } }
static int largestGCDSubsequence ( int arr [ ] , int n ) { int ans = 0 ; int maxele = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; for ( int i = 2 ; i <= maxele ; ++ i ) { int count = 0 ; for ( int j = 0 ; j < n ; ++ j ) { if ( arr [ j ] % i == 0 ) ++ count ; } ans = Math . max ( ans , count ) ; } return ans ; }
static boolean isNumber ( String s ) { for ( int i = 0 ; i < s . length ( ) ; i ++ ) if ( isdigit ( s . charAt ( i ) ) == false ) return false ; return true ; }
static int countPairs ( int arr1 [ ] , int arr2 [ ] , int m , int n , int x ) { int count = 0 ; HashSet < Integer > us = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < m ; i ++ ) us . add ( arr1 [ i ] ) ; for ( int j = 0 ; j < n ; j ++ ) if ( us . contains ( x - arr2 [ j ] ) ) count ++ ; return count ; }
static int lis ( int arr [ ] , int n ) { int lis [ ] = new int [ n ] ; lis [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { lis [ i ] = 1 ; } for ( int j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; } return * max_element ( lis , lis + n ) ; }
static String findSubString ( String str ) { int n = str . length ( ) ; int dist_count = 0 ; boolean [ ] visited = new boolean [ MAX_CHARS ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( visited [ str . charAt ( i ) ] == false ) { visited [ str . charAt ( i ) ] = true ; dist_count ++ ; } } int start = 0 , start_index = - 1 , min_len = Integer . MAX_VALUE ; int count = 0 ; int curr_count [ ] = new int [ MAX_CHARS ] ; for ( int j = 0 ; j < n ; j ++ ) { curr_count [ str . charAt ( j ) ] ++ ; if ( curr_count [ str . charAt ( j ) ] == 1 ) count ++ ; if ( count == dist_count ) { while ( curr_count [ str . start ] ] > 1 ) { if ( curr_count [ str . start ] ] > 1 ) { curr_count [ str . start ] ] -- ; start ++ ; } } int len_window = j - start + 1 ; if ( min_len > len_window ) { min_len = len_window ; start_index = start ; } } } return str . substring ( start_index , min_len ) ; }
static void printSubsequences ( int arr [ ] , int n ) { long opsize = ( long ) Math . pow ( 2 , n ) ; for ( int counter = 1 ; counter < opsize ; counter ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( ( counter & ( 1 << j ) ) > 0 ) System . out . print ( arr [ j ] + " ▁ " ) ; } System . out . println ( ) ; } }
static void bin ( int n ) { if ( n > 1 ) bin ( n >> 1 ) ; System . out . println ( " % d " , n & 1 ) ; }
static int minimumSquare ( int a , int b ) { long long result = 0 , rem = 0 ; if ( a < b ) swap ( a , b ) ; while ( b > 0 ) { result += a / b ; long long rem = a % b ; a = b ; b = rem ; } return result ; }
static void deleteElements ( int arr [ ] , int n , int k ) { Stack < Integer > s = new Stack < > ( ) ; int count = 0 ; for ( int i = 1 ; i < n ; i ++ ) { while ( ! s . empty ( ) && s . peek ( ) < arr [ i ] && count < k ) { s . pop ( ) ; count ++ ; } s . add ( arr [ i ] ) ; } int m = s . size ( ) ; Vector < Integer > v = new Vector < > ( m ) ; while ( ! s . empty ( ) ) { v [ -- m ] = s . peek ( ) ; s . pop ( ) ; } for ( auto x : v ) System . out . print ( x + " ▁ " ) ; System . out . println ( ) ; }
static char first ( String str ) { for ( int i = 0 ; i < str . length ( ) ; i ++ ) if ( isupper ( str . charAt ( i ) ) ) return str . charAt ( i ) ; return 0 ; }
static void findSymPairs ( int arr [ ] [ ] , int row ) { HashMap < Integer , Integer > hM = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < row ; i ++ ) { int first = arr [ i ] [ 0 ] ; int sec = arr [ i ] [ 1 ] ; if ( hM . containsKey ( sec ) && hM . get ( sec ) == first ) System . out . println ( " ( " + sec + " , ▁ " + first + " ) " ) ; else hM . put ( first , sec ) ; } }
static int isPossible ( int n , int index , int modulo , int M , int arr [ ] , int dp [ ] [ ] ) { modulo = ( ( modulo % M ) + M ) % M ; if ( index == n ) { if ( modulo == 0 ) return 1 ; return 0 ; } if ( dp [ index ] [ modulo ] != - 1 ) return dp [ index ] [ modulo ] ; int placeAdd = isPossible ( n , index + 1 , modulo + arr [ index ] , M , arr , dp ) ; int placeMinus = isPossible ( n , index + 1 , modulo - arr [ index ] , M , arr , dp ) ; boolean res = ( placeAdd || placeMinus ) ; dp [ index ] [ modulo ] = res ; return res ; }
static void amendSentence ( String str ) { for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) >= ' A ' && str . charAt ( i ) <= ' Z ' ) { str . charAt ( i ) = str . charAt ( i ) + 32 ; if ( i != 0 ) System . out . print ( " ▁ " ) ; System . out . print ( str . charAt ( i ) ) ; } else System . out . print ( str . charAt ( i ) ) ; } }
static int find ( int a [ ] , int b [ ] , int k , int n1 , int n2 ) { HashSet < Integer > s = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n2 ; i ++ ) s . add ( b [ i ] ) ; int missing = 0 ; for ( int i = 0 ; i < n1 ; i ++ ) { if ( s . contains ( a [ i ] ) ) missing ++ ; if ( missing == k ) return a [ i ] ; } return - 1 ; }
static int countNumber ( int n ) { int result = 0 ; for ( int i = 1 ; i <= 9 ; i ++ ) { Stack < Integer > s = new Stack < > ( ) ; if ( i <= n ) { s . add ( i ) ; result ++ ; } while ( ! s . isEmpty ( ) ) { int tp = s . peek ( ) ; s . remove ( ) ; for ( int j = tp % 10 ; j <= 9 ; j ++ ) { int x = tp * 10 + j ; if ( x <= n ) { s . add ( x ) ; result ++ ; } } } return result ; }
static char getMaxOccuringChar ( String str ) { int count [ ] = new int [ ASCII_SIZE ] ; int len = str . length ( ) ; char result = ' ' ; for ( int i = 0 ; i < len ; i ++ ) { count [ str . charAt ( i ) ] ++ ; if ( max < count [ str . charAt ( i ) ] ) { max = count [ str . charAt ( i ) ] ; result = str . charAt ( i ) ; } } return result ; }
static int longLenSub ( int arr [ ] , int n ) { HashMap < Integer , Integer > um = new HashMap < Integer , Integer > ( ) ; int longLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int len = 0 ; if ( um . containsKey ( arr [ i ] - 1 ) && len < um [ arr [ i ] - 1 ] ) len = um [ arr [ i ] - 1 ] ; if ( um . containsKey ( arr [ i ] + 1 ) && len < um [ arr [ i ] + 1 ] ) len = um [ arr [ i ] + 1 ] ; um . put ( arr [ i ] , len + 1 ) ; if ( longLen < um [ arr [ i ] ] ) longLen = um [ arr [ i ] ] ; } return longLen ; }
static int getMinDiff ( int arr [ ] , int n , int k ) { if ( n == 1 ) return 0 ; Arrays . sort ( arr ) ; int ans = arr [ n - 1 ] - arr [ 0 ] ; int small = arr [ 0 ] + k ; int big = arr [ n - 1 ] - k ; if ( small > big ) swap ( small , big ) ; for ( int i = 1 ; i < n - 1 ; i ++ ) { int subtract = arr [ i ] - k ; int add = arr [ i ] + k ; if ( subtract >= small || add <= big ) continue ; if ( big - subtract <= add - small ) small = subtract ; else big = add ; } return Math . min ( ans , big - small ) ; }
static void printCommonElements ( int mat [ ] [ ] ) { HashMap < Integer , Integer > myMap = new HashMap < Integer , Integer > ( ) ; for ( int j = 0 ; j < N ; j ++ ) myMap . put ( mat [ 0 ] [ j ] , myMap . get ( mat [ 0 ] [ j ] ) + 1 ) ; for ( int i = 1 ; i < M ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( myMap . containsKey ( mat [ i ] [ j ] ) ) { myMap . put ( mat [ i ] [ j ] , myMap . get ( mat [ i ] [ j ] ) + " ▁ " ) ; } } } }
static void printkthnode ( Vector < Pair < Integer , Integer > > adj [ ] , int wt [ ] , int n , int k ) { for ( int i = 0 ; i < n ; i ++ ) Arrays . sort ( adj [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) Arrays . sort ( adj [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( adj [ i ] . size ( ) >= k ) System . out . print ( adj [ i ] . get ( ) - k ] . second ) ; else System . out . print ( " - 1" ) ; } }
static void commonCharacters ( String str , int n ) { boolean [ ] prim = new boolean [ MAX_CHAR ] ; for ( int i = 0 ; i < n ; i ++ ) { boolean [ ] sec = new boolean [ MAX_CHAR ] ; for ( int j = 0 ; j < str . length ( ) ; j ++ ) { if ( prim [ str . charAt ( i ) [ j ] - ' a ' ] ) sec [ str . charAt ( i ) [ j ] - ' a ' ] = true ; } memcpy ( prim , sec , MAX_CHAR ) ; } for ( int i = 0 ; i < 26 ; i ++ ) if ( prim [ i ] ) System . out . println ( " % c ▁ " , i + ' a ' ) ; }
static boolean canMakeStr2 ( String str1 , String str2 ) { int [ ] count = new int [ MAX ] ; for ( int i = 0 ; i < str1 . length ( ) ; i ++ ) { if ( count [ str1 . charAt ( i ) ] == 0 ) return false ; count [ str1 . charAt ( i ) ] -- ; } for ( int i = 0 ; i < str2 . length ( ) ; i ++ ) { if ( count [ str2 . charAt ( i ) ] == 0 ) return false ; count [ str2 . charAt ( i ) ] -- ; } return true ; }
static int count ( String a , String b , int m , int n ) { if ( ( m == 0 && n == 0 ) || n == 0 ) return 1 ; if ( m == 0 ) return 0 ; if ( a . length ( ) > 1 && b . length ( ) == 0 ) return 0 ; if ( a . length ( ) > 1 && b . length ( ) == 0 ) return count ( a , b , m - 1 , n - 1 ) + count ( a , b , m - 1 , n ) ; else return count ( a , b , m - 1 , n ) ; }
static int numofArray ( int n , int m ) { int dp [ ] [ ] = new int [ MAX ] [ MAX ] ; Vector < Integer > [ ] di = new Vector [ MAX ] ; Vector < Integer > mu [ ] = new Vector [ MAX ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 2 * i ; j <= m ; j += i ) { di [ j ] . add ( i ) ; mu [ i ] . add ( j ) ; } di [ i ] . add ( i ) ; } for ( int i = 1 ; i <= m ; i ++ ) { dp [ 1 ] [ i ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { dp [ i ] [ j ] = 0 ; for ( auto x : di [ j ] ) dp [ i ] [ j ] += dp [ i - 1 ] [ x ] ; for ( auto x : mu [ j ] ) dp [ i ] [ j ] += dp [ i - 1 ] [ x ] ; } } int ans = 0 ; for ( int i = 1 ; i <= m ; i ++ ) { ans += dp [ n ] [ i ] ; di [ i ] . clear ( ) ; mu [ i ] . clear ( ) ; } return ans ; }
static int findSubarraySum ( int arr [ ] , int n ) { int res = 0 ; HashMap < Integer , Integer > m = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int sum = 0 ; for ( int j = i ; j < n ; j ++ ) { sum += arr [ j ] ; m . put ( sum , 1 ) ; } } for ( auto x : m ) if ( x . second == 1 ) res += x . first ; return res ; }
static void findpath ( int graph [ ] [ ] , int n ) { Vector < Integer > numofadj = new Vector < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) numofadj . add ( accumulate ( graph [ i ] , graph [ i ] + 5 , 0 ) ) ; int startpoint = 0 , numofodd = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( numofadj [ i ] % 2 == 1 ) { numofodd ++ ; startpoint = i ; } } if ( numofodd > 2 ) { System . out . println ( " No ▁ Solution " ) ; return ; } Stack < Integer > stack = new Stack < > ( ) ; Vector < Integer > path = new Vector < > ( ) ; int cur = startpoint ; while ( ! stack . isEmpty ( ) or accumulate ( graph [ cur ] , graph [ cur ] + 5 , 0 ) != 0 ) { if ( accumulate ( graph [ cur ] , graph [ cur ] + 5 , 0 ) == 0 ) { path . add ( cur ) ; cur = stack . peek ( ) ; stack . remove ( ) ; } else { for ( int i = 0 ; i < n ; i ++ ) { if ( graph [ cur ] [ i ] == 1 ) { stack . add ( cur ) ; graph [ cur ] [ i ] = 0 ; graph [ i ] [ cur ] = 0 ; cur = i ; break ; } } } } for ( auto ele : path ) System . out . println ( ele + " ▁ - > ▁ " ) ; System . out . println ( ) ; }
public static int sumBetweenTwoKth ( int arr [ ] , int n , int k1 , int k2 ) { Arrays . sort ( arr ) ; return accumulate ( arr + k1 , arr + k2 - 1 , 0 ) ; }
static int calculate ( int a [ ] , int n ) { int maximum [ ] = new int [ n ] ; int [ ] frequency = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { frequency [ a [ i ] ] += 1 ; } int answer = 0 ; for ( int i = 0 ; i < ( * maximum ) + 1 ; i ++ ) { answer = answer + frequency [ i ] * ( frequency [ i ] - 1 ) ; } return answer / 2 ; }
static int sumNodes ( int l ) { int leafNodeCount = ( int ) Math . pow ( 2 , l - 1 ) ; Vector < Integer > [ ] vec = new Vector [ l ] ; for ( int i = 1 ; i <= leafNodeCount ; i ++ ) vec [ l - 1 ] . add ( i ) ; for ( int i = l - 2 ; i >= 0 ; i -- ) { int k = 0 ; while ( k < vec [ i + 1 ] . size ( ) - 1 ) { vec [ i ] . add ( vec [ i + 1 ] . get ( k ) + vec [ i + 1 ] . get ( k + 1 ) ) ; k += 2 ; } } int sum = 0 ; for ( int i = 0 ; i < l ; i ++ ) { for ( int j = 0 ; j < vec [ i ] . size ( ) ; j ++ ) sum += vec [ i ] . get ( j ) ; } return sum ; }
static String encrypt ( String text , int s ) { String result = " " ; for ( int i = 0 ; i < text . length ( ) ; i ++ ) { if ( isupper ( text . charAt ( i ) ) ) result += char ( int ( text . charAt ( i ) + s - 65 ) % 26 + 65 ) ; else result += char ( int ( text . charAt ( i ) + s - 97 ) % 26 + 97 ) ; } return result ; }
static int gcd ( int a , int b ) { if ( a == 0 ) return b ; if ( b == 0 ) return a ; int k ; for ( k = 0 ; ( ( a | b ) && 1 ) == 0 ; ++ k ) { a >>= 1 ; b >>= 1 ; } while ( ( a > 1 ) == 0 ) a >>= 1 ; do { while ( ( b > 1 ) == 0 ) b >>= 1 ; if ( a > b ) swap ( a , b ) ; b = ( b - a ) ; } while ( b != 0 ) ; return a << k ; }
static int calculateSum ( String arr [ ] , int n ) { if ( n == 0 ) return 0 ; String s = arr [ 0 ] ; int value = stoi ( s ) ; int sum = value ; for ( int i = 2 ; i < n ; i = i + 2 ) { s = arr [ i ] ; int value = stoi ( s ) ; int operation = arr [ i - 1 ] [ 0 ] ; if ( operation == ' + ' ) sum += value ; else sum -= value ; } return sum ; }
static String replace ( String s , char c1 , char c2 ) { int l = s . length ( ) ; for ( int i = 0 ; i < l ; i ++ ) { if ( s . charAt ( i ) == c1 ) s . charAt ( i ) = c2 ; else if ( s . charAt ( i ) == c2 ) s . charAt ( i ) = c1 ; } return s ; }
static String lexicographicSubConcat ( String s ) { int n = s . length ( ) ; int sub_count = n * ( n + 1 ) / 2 ; String [ ] arr = new String [ sub_count ] ; int index = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int len = 1 ; len <= n - i ; len ++ ) arr [ index ++ ] = s . substring ( i , len ) ; Arrays . sort ( arr ) ; String res = " " ; for ( int i = 0 ; i < sub_count ; i ++ ) res += arr [ i ] ; return res ; }
static int findpos ( String n ) { int i = 0 , pos = 0 ; while ( n . charAt ( i ) != ' \0' ) { switch ( n . charAt ( i ) ) { case '4' : pos = pos * 2 + 1 ; break ; case '7' : pos = pos * 2 + 2 ; break ; } i ++ ; } return pos ; }
static long long int yMod ( long long int y , long long int x ) { if ( log2 ( y ) < x ) return y ; if ( x > 63 ) return y ; return ( y % ( 1 << x ) ) ; }
static ll lis ( ll arr [ ] , ll n ) { ll mpis [ ] = new ll [ n ] ; for ( int i = 0 ; i < n ; i ++ ) mpis [ i ] = arr [ i ] ; for ( int i = 1 ; i < n ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && mpis [ i ] < ( mpis [ j ] * arr [ i ] ) ) mpis [ i ] = mpis [ j ] * arr [ i ] ; return * max_element ( mpis , mpis + n ) ; }
static boolean checkSorted ( int n , Queue < Integer > q ) { Stack < Integer > st = new Stack < > ( ) ; int expected = 1 ; int fnt ; while ( ! q . isEmpty ( ) ) { fnt = q . peek ( ) ; q . remove ( ) ; if ( fnt == expected ) expected ++ ; else { if ( st . isEmpty ( ) ) { st . add ( fnt ) ; } else if ( ! st . empty ( ) && st . peek ( ) < fnt ) { return false ; } else st . add ( fnt ) ; } while ( ! st . empty ( ) && st . peek ( ) == expected ) { st . pop ( ) ; expected ++ ; } } if ( expected - 1 == n && st . isEmpty ( ) ) return true ; return false ; }
static void generate ( HashSet < String > st , String s ) { if ( s . size ( ) == 0 ) return ; if ( st . contains ( s ) ) { st . add ( s ) ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { String t = s ; t . erase ( i , 1 ) ; generate ( st , t ) ; } } return ; }
static String minLexRotation ( String str ) { int n = str . length ( ) ; String [ ] arr = new String [ n ] ; String concat = str + str ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = concat . substring ( i , n ) ; Arrays . sort ( arr ) ; return arr [ 0 ] ; }
static boolean isPossible ( int a [ ] , int b [ ] , int n , int k ) { Arrays . sort ( a ) ; Arrays . sort ( b ) ; for ( int i = 0 ; i < n ; i ++ ) if ( a [ i ] + b [ i ] < k ) return false ; return true ; }
static boolean isCornerPresent ( String str , String corner ) { int n = str . length ( ) ; int cl = corner . length ( ) ; if ( n < cl ) return false ; return ( str . substring ( 0 , cl ) . compareTo ( corner ) == 0 && str . substring ( n - cl , cl ) . compareTo ( corner ) == 0 && str . substring ( n - cl , cl ) . compareTo ( corner ) == 0 ) ; }
static String longDivision ( String number , int divisor ) { String ans = "0" ; int idx = 0 ; int temp = number . charAt ( idx ) - '0' ; while ( temp < divisor ) temp = temp * 10 + ( number . charAt ( ++ idx ) - '0' ) ; while ( number . size ( ) > idx ) { ans += ( temp / divisor ) + '0' ; temp = ( temp % divisor ) * 10 + number . charAt ( ++ idx ) - '0' ; } if ( ans . length ( ) == 0 ) return "0" ; return ans ; }
static void sort012 ( int a [ ] , int arr_size ) { int lo = 0 ; int hi = arr_size - 1 ; int mid = 0 ; while ( mid <= hi ) { switch ( a [ mid ] ) { case 0 : swap ( a [ lo ++ ] , a [ mid ++ ] ) ; break ; case 1 : mid ++ ; break ; case 2 : swap ( a [ mid ] , a [ hi -- ] ) ; break ; } } }
static boolean canRepresentBST ( int pre [ ] , int n ) { Stack < Integer > s = new Stack < > ( ) ; int root = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { if ( pre [ i ] < root ) return false ; while ( ! s . isEmpty ( ) && s . peek ( ) < pre [ i ] ) { root = s . peek ( ) ; s . remove ( ) ; } s . push ( pre [ i ] ) ; } return true ; }
static int find_maximum ( int a [ ] , int n , int k ) { HashMap < Integer , Integer > b = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int x = a [ i ] ; int d = Math . min ( 1 + i , n - i ) ; if ( b . containsKey ( x ) ) b [ x ] = d ; else b [ x ] = Math . min ( d , b [ x ] ) ; } int ans = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { int x = a [ i ] ; if ( x != k - x && b . containsKey ( k - x ) ) ans = Math . min ( Math . max ( b [ x ] , b [ k - x ] ) , ans ) ; } return ans ; }
static int solveQuery ( int start , int end , int arr [ ] ) { HashMap < Integer , Integer > frequency = new HashMap < Integer , Integer > ( ) ; for ( int i = start ; i <= end ; i ++ ) frequency . put ( arr [ i ] , frequency . get ( arr [ i ] ) + 1 ) ; int count = 0 ; for ( Auto x : frequency ) if ( x . first == x . second ) count ++ ; return count ; }
static boolean divisibleBy20 ( String num ) { int lastTwoDigits = stoi ( num . substring ( num . length ( ) - 2 ) ) ; return ( ( lastTwoDigits % 5 == 0 ) && ( lastTwoDigits % 4 == 0 ) ) ; }
static void CountTriangles ( int [ ] A ) { int n = A . size ( ) ; Arrays . sort ( A ) ; int count = 0 ; for ( int i = n - 1 ; i >= 1 ; i -- ) { int l = 0 , r = i - 1 ; while ( l < r ) { if ( A . get ( l ) + A [ r ] > A [ i ] ) { count += r - l ; r -- ; } else l ++ ; } } System . out . println ( " No ▁ of ▁ possible ▁ solutions : ▁ " + count ) ; }
static void countFreq ( int [ ] a , int n ) { HashMap < Integer , Integer > hm = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) hm . put ( a [ i ] , hm . get ( a [ i ] ) + 1 ) ; HashSet < Integer > st = new HashSet < Pair < Integer , Integer > ( ) ; for ( Integer i = 0 ; i < n ; i ++ ) { st . add ( { x . first , x . second } ) ; } int cumul = 0 ; for ( Auto x : hm ) { cumul += x . second ; System . out . print ( x . first + " ▁ " + cumul ) ; } }
public static void CocktailSort ( int a [ ] , int n ) { boolean swapped = true ; int start = 0 ; int end = n - 1 ; while ( swapped ) { swapped = false ; for ( int i = start ; i < end ; ++ i ) { if ( a [ i ] > a [ i + 1 ] ) { swap ( a [ i ] , a [ i + 1 ] ) ; swapped = true ; } } if ( ! swapped ) break ; swapped = false ; -- end ; for ( int i = end - 1 ; i >= start ; -- i ) { if ( a [ i ] > a [ i + 1 ] ) { swap ( a [ i ] , a [ i + 1 ] ) ; swapped = true ; } } ++ start ; } }
static char first ( String str , int i ) { if ( str . length ( ) == 0 ) return 0 ; if ( isupper ( str . charAt ( i ) ) ) return str . charAt ( i ) ; return first ( str , i + 1 ) ; }
static int longestNull ( String str ) { Vector < Pair < Character , Integer > > arr = new Vector < Pair < Character , Integer > ( ) ; int maxlen = 0 ; for ( int i = 0 ; i < str . length ( ) ; ++ i ) { arr . add ( { str . charAt ( i ) , i } ) ; while ( arr . size ( ) >= 3 && arr [ arr . size ( ) - 3 ] . first == '1' && arr [ arr . size ( ) - 2 ] . first == '0' && arr [ arr . size ( ) - 1 ] . first == '0' ) { arr . remove ( ) ; arr . remove ( ) ; arr . remove ( ) ; } int tmp = arr . back ( ) . second ; maxlen = Math . max ( maxlen , i - tmp ) ; } return maxlen ; }
static void reverse ( char str [ ] ) { int n = str . length ( ) ; for ( int i = 0 ; i < n / 2 ; i ++ ) swap ( & str [ i ] , & str [ n - i - 1 ] ) ; }
static String nextWord ( String s ) { if ( s . length ( ) == 0 ) return " a " ; int i = s . length ( ) - 1 ; while ( s . charAt ( i ) == ' z ' && i >= 0 ) i -- ; if ( i == - 1 ) s = s + ' a ' ; else s . charAt ( i ) ++ ; return s ; }
static boolean isRectangle ( int [ ] matrix ) { int rows = matrix . size ( ) ; if ( rows == 0 ) return false ; int columns = matrix [ 0 ] . size ( ) ; HashMap < Integer , Integer > hM = new HashMap < Integer , Integer > ( ) ; HashMap < Integer , Integer > table = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < rows ; ++ i ) { for ( int j = 0 ; j < columns - 1 ; ++ j ) { for ( int k = j + 1 ; k < columns ; ++ k ) { if ( matrix [ i ] . get ( j ) == 1 && matrix [ i ] . get ( k ) == 1 ) { if ( table . containsKey ( j ) && table . get ( k ) != null ) return true ; table . put ( j , k ) ; } } } return false ; }
static int lenOfLongSubarr ( int arr [ ] , int n ) { HashMap < Integer , Integer > um = new HashMap < Integer , Integer > ( ) ; int sum = 0 , maxLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] == 0 ? - 1 : 1 ; if ( sum == 1 ) maxLen = i + 1 ; else if ( um . containsKey ( sum ) ) um . put ( sum , i ) ; else if ( um . containsKey ( sum ) ) um . put ( sum , i ) ; if ( um . containsKey ( sum - 1 ) ) { if ( maxLen < ( i - um [ sum - 1 ] ) ) maxLen = i - um [ sum - 1 ] ; } } return maxLen ; }
static int sumoflength ( int arr [ ] , int n ) { HashSet < Integer > s = new HashSet < Integer > ( ) ; int j = 0 , ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { while ( j < n && s . contains ( arr [ j ] ) ) { s . remove ( arr [ j ] ) ; j ++ ; } ans += ( ( j - i ) * ( j - i + 1 ) ) / 2 ; s . add ( arr [ i ] ) ; } return ans ; }
static void findTriplets ( int arr [ ] , int n ) { boolean found = false ; for ( int i = 0 ; i < n - 1 ; i ++ ) { HashMap < Integer , Integer > hM = new HashMap < Integer , Integer > ( ) ; for ( int j = i + 1 ; j < n ; j ++ ) { int x = - ( arr [ i ] + arr [ j ] ) ; if ( hM . get ( x ) != null ) { System . out . print ( " ▁ " + arr [ i ] + " ▁ " + arr [ j ] ) ; found = true ; } else s . add ( arr [ j ] ) ; } } if ( found == false ) System . out . println ( " ▁ No ▁ Triplet ▁ Found " ) ; }
static int maxPrefix ( char s [ ] , char t [ ] ) { int count = 0 ; for ( int i = 0 ; i < strlen ( t ) ; i ++ ) { if ( count == strlen ( s ) ) break ; if ( t [ i ] == s [ count ] ) count ++ ; } return count ; }
static void segregateElements ( int arr [ ] , int n ) { int temp [ ] = new int [ n ] ; int j = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] >= 0 ) temp [ j ++ ] = arr [ i ] ; if ( j == n || j == 0 ) return ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] < 0 ) temp [ j ++ ] = arr [ i ] ; memcpy ( arr , temp , sizeof ( temp ) ) ; return ; }
static void mergeIntervals ( Interval arr [ ] , int n ) { Arrays . sort ( arr ) ; int index = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ index ] . e >= arr [ i ] . s ) { arr [ index ] . e = Math . max ( arr [ index ] . e , arr [ i ] . e ) ; arr [ index ] . s = Math . min ( arr [ index ] . s , arr [ i ] . s ) ; } else { arr [ index ] = arr [ i ] ; index ++ ; } } System . out . println ( " ▁ The ▁ Merged ▁ Intervals ▁ are : ▁ " ) ; for ( int i = 0 ; i <= index ; i ++ ) System . out . println ( " [ " + arr [ i ] . s + " , ▁ " + arr [ i ] . e + " ] ▁ " ) ; }
static int findArea ( int arr [ ] , int n ) { Arrays . sort ( arr , Collections . reverseOrder ( ) ) ; int [ ] dimension = new int [ 2 ] ; for ( int i = 0 , j = 0 ; i < n - 1 && j < 2 ; i ++ ) if ( arr [ i ] == arr [ i + 1 ] ) dimension [ j ++ ] = arr [ i ++ ] ; return ( dimension [ 0 ] * dimension [ 1 ] ) ; }
static int minOps ( int arr [ ] , int n , int k ) { int max = * max_element ( arr , arr + n ) ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( max - arr [ i ] ) % k != 0 ) return - 1 ; else res += ( max - arr [ i ] ) / k ; } return res ; }
static int isdivisible7 ( String num ) { int n = num . length ( ) , gSum = 0 ; if ( n == 0 && num . charAt ( 0 ) == ' \n ' ) return 1 ; if ( n % 3 == 1 ) { strcat ( num , "00" ) ; n += 2 ; } else if ( n % 3 == 2 ) { strcat ( num , "0" ) ; n ++ ; } int i , GSum = 0 , p = 1 ; for ( i = n - 1 ; i >= 0 ; i -- ) { int group = 0 ; group += num . charAt ( i -- ) - '0' ; group += ( num . charAt ( i -- ) - '0' ) * 10 ; group += ( num . charAt ( i ) - '0' ) * 100 ; gSum = gSum + group * p ; p *= ( - 1 ) ; } return ( gSum % 7 == 0 ) ; }
static boolean isDivisible999 ( String num ) { int n = num . length ( ) ; if ( n == 0 && num . charAt ( 0 ) == '0' ) return true ; if ( n % 3 == 1 ) num = "00" + num ; if ( n % 3 == 2 ) num = "0" + num ; if ( n % 3 == 3 ) num = "0" + num ; if ( n % 3 == 3 ) num = "0" + num ; int gSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int group = 0 ; group += ( num . charAt ( i ++ ) - '0' ) * 100 ; group += ( num . charAt ( i ++ ) - '0' ) * 10 ; group += num [ i ] - '0' ; gSum += group ; } if ( gSum > 1000 ) { num = to_string ( gSum ) ; n = num . length ( ) ; gSum = isDivisible999 ( num ) ; } return ( gSum == 999 ) ; }
static boolean checkPangram ( String str ) { Vector < Boolean > mark = new Vector < Boolean > ( ) ; int index ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( ' A ' <= str . charAt ( i ) && str . charAt ( i ) <= ' Z ' ) index = str . charAt ( i ) - ' A ' ; else if ( ' a ' <= str . charAt ( i ) && str . charAt ( i ) <= ' z ' ) index = str . charAt ( i ) - ' a ' ; mark [ index ] = true ; } for ( int i = 0 ; i <= 25 ; i ++ ) if ( mark [ i ] == false ) return ( false ) ; return ( true ) ; }
static void kLargest ( int arr [ ] , int n , int k ) { Arrays . sort ( arr , Collections . reverseOrder ( ) ) ; for ( int i = 0 ; i < k ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; }
static int kthLargestSum ( int arr [ ] , int n , int k ) { int sum [ ] = new int [ n + 1 ] ; sum [ 0 ] = 0 ; sum [ 1 ] = arr [ 0 ] ; for ( int i = 2 ; i <= n ; i ++ ) sum [ i ] = sum [ i - 1 ] + arr [ i - 1 ] ; priority_queue < Integer , Vector < Integer > > Q = new LinkedList < > ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = i ; j <= n ; j ++ ) { int x = sum [ j ] - sum [ i - 1 ] ; if ( Q . size ( ) < k ) Q . add ( x ) ; else { if ( Q . peek ( ) < x ) { Q . remove ( ) ; Q . add ( x ) ; } } } return Q . peek ( ) ; }
static void printDistinct ( int arr [ ] , int n ) { HashSet < Integer > s = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! s . contains ( arr [ i ] ) ) { s . add ( arr [ i ] ) ; System . out . print ( arr [ i ] + " ▁ " ) ; } } }
static int abFree ( String s ) { int n = s . length ( ) ; StringBuffer sb = new StringBuffer ( s ) ; sb . append ( s ) ; int b_count = 0 ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( char_array [ n - i - 1 ] == ' a ' ) { res = ( res + b_count ) ; b_count = ( b_count * 2 ) ; } else { b_count += 1 ; } } return res ; }
static void findFibSubset ( int arr [ ] , int n ) { int max = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; int a = 0 , b = 1 ; HashMap < Integer , Integer > hM = new HashMap < Integer , Integer > ( ) ; hash . add ( a ) ; hash . add ( b ) ; while ( b < max ) { int c = a + b ; a = b ; b = c ; hash . add ( b ) ; } for ( int i = 0 ; i < n ; i ++ ) if ( hash . contains ( arr [ i ] ) ) System . out . println ( " % d ▁ " + arr [ i ] ) ; }
static void recursiveReverse ( String str , int i ) { int n = str . length ( ) ; if ( i == n / 2 ) return ; swap ( str . charAt ( i ) , str . charAt ( n - i - 1 ) ) ; recursiveReverse ( str , i + 1 ) ; }
static int findGreatest ( int arr [ ] , int n ) { HashMap < Integer , Integer > m = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { m . put ( arr [ i ] , m . get ( arr [ i ] ) + 1 ) ; } for ( int i = n - 1 ; i > 1 ; i -- ) { for ( int j = 0 ; j < i && arr [ j ] <= sqrt ( arr [ i ] ) ; j ++ ) { if ( arr [ i ] % arr [ j ] == 0 ) { int result = arr [ i ] / arr [ j ] ; if ( result != arr [ j ] && m [ result ] > 0 ) return arr [ i ] ; else if ( result == arr [ j ] && m [ result ] > 1 ) return arr [ i ] ; } } } return - 1 ; }
static String noAdjacentDup ( String s ) { int n = s . length ( ) ; for ( int i = 1 ; i < n ; i ++ ) { if ( s . charAt ( i ) == s . charAt ( i - 1 ) ) { s . charAt ( i ) = ' a ' ; while ( s . charAt ( i ) == s . charAt ( i - 1 ) || ( i + 1 < n && s . charAt ( i ) == s . charAt ( i + 1 ) ) s . charAt ( i ) ++ ; i ++ ; } } return s ; }
static void query ( String s , int i , int j ) { int n = s . length ( ) ; i %= n ; j %= n ; ( s . charAt ( i ) == s . charAt ( j ) ) ? ( System . out . println ( " Yes " ) ) : ( System . out . println ( " No " ) ) ; }
static int countPairs ( int arr [ ] , int n ) { int result = 0 ; HashSet < Integer > Hash = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) Hash . add ( arr [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int product = arr [ i ] * arr [ j ] ; if ( Hash . contains ( product ) ) result ++ ; } } return result ; }
static void printInSortedOrder ( String arr [ ] , int n ) { int [ ] index = new int [ n ] ; int i , j , min ; for ( i = 0 ; i < n ; i ++ ) index [ i ] = i ; for ( i = 0 ; i < n - 1 ; i ++ ) { min = i ; for ( j = i + 1 ; j < n ; j ++ ) { if ( arr [ index [ min ] ] . compareTo ( arr [ index [ j ] ] ) > 0 ) min = j ; } if ( min != i ) { int temp = index [ min ] ; index [ min ] = index [ i ] ; index [ i ] = temp ; } } for ( i = 0 ; i < n ; i ++ ) System . out . print ( arr [ index [ i ] ] + " ▁ " ) ; }
static void sortUsingHash ( int a [ ] , int n ) { int max = Math . abs ( * Math . max_element ( a , a + n ) ) ; int min = Math . abs ( * Math . min_element ( a , a + n ) ) ; int [ ] hashpos = new int [ max + 1 ] ; int [ ] hashneg = new int [ min + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] >= 0 ) hashpos [ a [ i ] ] += 1 ; else hashneg [ Math . abs ( a [ i ] ) ] += 1 ; } for ( int i = min ; i > 0 ; i -- ) { if ( hashneg [ i ] ) { for ( int j = 0 ; j < hashneg [ i ] ; j ++ ) { System . out . print ( ( - 1 ) * i + " ▁ " ) ; } } } for ( int i = 0 ; i <= max ; i ++ ) { if ( hashpos [ i ] ) { for ( int j = 0 ; j < hashpos [ i ] ; j ++ ) { System . out . print ( i + " ▁ " ) ; } } } }
static void smallestSubsegment ( int a [ ] , int n ) { HashMap < Integer , Integer > left = new HashMap < Integer , Integer > ( ) ; HashMap < Integer , Integer > count = new HashMap < Integer , Integer > ( ) ; int mx = 0 ; int mn , strindex ; for ( int i = 0 ; i < n ; i ++ ) { int x = a [ i ] ; if ( count [ x ] == 0 ) { left [ x ] = i ; count [ x ] = 1 ; } else count [ x ] ++ ; if ( count [ x ] > mx ) { mx = count [ x ] ; mn = i - left [ x ] + 1 ; strindex = left [ x ] ; } else if ( count [ x ] == mx && i - left [ x ] + 1 < mn ) { mn = i - left [ x ] + 1 ; strindex = left [ x ] ; } } for ( int i = strindex ; i < strindex + mn ; i ++ ) System . out . print ( a [ i ] + " ▁ " ) ; }
static void findRandomIndexOfMax ( int arr [ ] , int n ) { HashMap < Integer , Integer > freq = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) freq . put ( arr [ i ] , freq . get ( arr [ i ] ) + 1 ) ; int max_element ; int max_so_far = Integer . MIN_VALUE ; for ( Pair < Integer , Integer > p : freq ) { if ( p . second > max_so_far ) { max_so_far = p . second ; max_element = p . first ; } } int r = ( rand ( ) % max_so_far ) + 1 ; for ( int i = 0 , count = 0 ; i < n ; i ++ ) { if ( arr [ i ] == max_element ) count ++ ; if ( count == r ) { System . out . println ( " Element ▁ with ▁ maximum ▁ frequency ▁ present ▁ " + i + " at ▁ index ▁ " + i ) ; break ; } } }
static int singleNumber ( int a [ ] , int n ) { HashSet < Integer > s = new HashSet < Integer > ( ) ; int arr_sum = accumulate ( a , a + n , 0 ) ; int set_sum = accumulate ( s . begin ( ) , s . end ( ) , 0 ) ; return ( 3 * set_sum - arr_sum ) / 2 ; }
static void printAllAPTriplets ( int arr [ ] , int n ) { HashSet < Integer > s = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int diff = arr [ j ] - arr [ i ] ; if ( s . contains ( arr [ i ] - diff ) ) System . out . print ( arr [ i ] - diff + " ▁ " + arr [ i ] + " ▁ " + arr [ j ] ) ; } s . add ( arr [ i ] ) ; } }
static char [ ] simplify ( String str ) { int len = str . length ( ) ; char [ ] res = new char [ len ] ; int index = 0 , i = 0 ; Stack < Integer > s = new Stack < > ( ) ; s . push ( 0 ) ; while ( i < len ) { if ( str . charAt ( i ) == ' + ' ) { if ( s . peek ( ) == 1 ) res [ index ++ ] = ' - ' ; } else if ( str . charAt ( i ) == ' - ' ) { if ( s . peek ( ) == 1 ) res [ index ++ ] = ' + ' ; else if ( s . peek ( ) == 0 ) res [ index ++ ] = ' - ' ; } else if ( str . charAt ( i ) == ' ( ' && i > 0 ) { if ( str . charAt ( i - 1 ) == ' - ' ) { int x = ( s . peek ( ) == 1 ) ? 0 : 1 ; s . add ( x ) ; } else if ( str . charAt ( i - 1 ) == ' + ' ) s . add ( s . peek ( ) ) ; } else if ( str . charAt ( i ) == ' ) ' ) s . pop ( ) ; else res [ index ++ ] = str . charAt ( i ) ; } return res ; }
static void findMajority ( int arr [ ] , int size ) { HashMap < Integer , Integer > m = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < size ; i ++ ) m . put ( arr [ i ] , m . get ( arr [ i ] ) + 1 ) ; int count = 0 ; for ( auto i : m ) { if ( i . second > size / 2 ) { count = 1 ; System . out . println ( " Majority ▁ found ▁ : - ▁ " + i . first ) ; break ; } } if ( count == 0 ) System . out . println ( " No ▁ Majority ▁ element " + endl ) ; }
static void findPair ( int arr [ ] , int n ) { HashSet < Integer > s = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) s . add ( arr [ i ] ) ; boolean found = false ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( s . contains ( arr [ i ] + arr [ j ] ) ) { System . out . print ( arr [ i ] + " ▁ " + arr [ j ] ) ; found = true ; } } } if ( found == false ) System . out . println ( " Not ▁ exist " ) ; }
static void strToBinary ( String s ) { int n = s . length ( ) ; for ( int i = 0 ; i <= n ; i ++ ) { int val = int ( s . charAt ( i ) ) ; String bin = " " ; while ( val > 0 ) { ( val % 2 ) ? bin . insert ( '1' ) : bin . insert ( '0' ) ; val /= 2 ; } reverse ( bin . begin ( ) , bin . end ( ) ) ; System . out . print ( bin + " ▁ " ) ; } }
static int findDuplicateparenthesis ( String str ) { Stack < Character > Stack = new Stack < Character > ( ) ; for ( char ch : str ) { if ( ch == ' ) ' ) { char top = Stack . peek ( ) ; Stack . pop ( ) ; int elementsInside = 0 ; while ( top != ' ( ' ) { elementsInside ++ ; top = Stack . peek ( ) ; Stack . pop ( ) ; } if ( elementsInside < 1 ) { return 1 ; } } else Stack . push ( ch ) ; } return false ; }
static void findTriplets ( int x ) { Vector < Integer > fact = new Vector < Integer > ( ) ; HashSet < Integer > factors = new HashSet < Integer > ( ) ; for ( int i = 2 ; i <= sqrt ( x ) ; i ++ ) { if ( x % i == 0 ) { fact . add ( i ) ; if ( x / i != i ) fact . add ( x / i ) ; factors . add ( i ) ; factors . add ( x / i ) ; } } boolean found = false ; int k = fact . size ( ) ; for ( int i = 0 ; i < k ; i ++ ) { int a = fact . get ( i ) ; for ( int j = 0 ; j < k ; j ++ ) { int b = fact . get ( j ) ; if ( ( a != b ) && ( x % ( a * b ) == 0 ) && ( x / ( a * b ) != b ) && ( x / ( a * b ) != 1 ) ) { System . out . print ( a + " ▁ " + b + " ▁ " + ( x / ( a * b ) ) ; found = true ; break ; } } if ( found ) break ; } if ( ! found ) System . out . println ( " - 1" ) ; }
static void findMissing ( int a [ ] , int b [ ] , int n , int m ) { HashSet < Integer > s = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < m ; i ++ ) s . add ( b [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) if ( s . contains ( a [ i ] ) ) System . out . print ( a [ i ] + " ▁ " ) ; }
static void minheapify ( int a [ ] , int index ) { int small = index ; int l = 2 * index + 1 ; int r = 2 * index + 2 ; if ( l < n && a [ l ] < a [ small ] ) small = l ; if ( r < n && a [ r ] < a [ small ] ) small = r ; if ( small != index ) { swap ( a [ small ] , a [ index ] ) ; minheapify ( a , small ) ; } }
static void KMP ( int m , int n , String str2 , String str1 ) { int pos = 0 , len = 0 ; int [ ] p = new int [ m + 1 ] ; int k = 0 ; p [ 1 ] = 0 ; for ( int i = 2 ; i <= n ; i ++ ) { while ( k > 0 && str1 [ k ] != str1 [ i - 1 ] ) k = p [ k ] ; if ( str1 [ k ] == str1 [ i - 1 ] ) ++ k ; p [ i ] = k ; } for ( int j = 0 , i = 0 ; i < m ; i ++ ) { while ( j > 0 && str1 [ j ] != str2 [ i ] ) j = p [ j ] ; if ( str1 [ j ] == str2 [ i ] ) j ++ ; if ( j > len ) { len = j ; pos = i - j + 1 ; } } System . out . println ( " Shift ▁ = ▁ " + pos + " Prefix ▁ = ▁ " + str1 . substring ( 0 , len ) ) ; System . out . println ( " Prefix ▁ = ▁ " + str1 . substring ( 0 , len ) ) ; }
static void swapDiagonal ( int matrix [ ] [ ] ) { for ( int i = 0 ; i < N ; i ++ ) swap ( matrix [ i ] [ i ] , matrix [ i ] [ N - i - 1 ] ) ; }
static String maximumPalinUsingKChanges ( String str , int k ) { String palin = str ; int l = 0 ; int r = str . length ( ) - 1 ; while ( l < r ) { if ( str . charAt ( l ) != str . charAt ( r ) ) { palin [ l ] = palin [ r ] = Math . max ( str . charAt ( l ) , str . charAt ( r ) ) ; k -- ; } l ++ ; r -- ; } if ( k < 0 ) return " Not ▁ possible " ; l = 0 ; r = str . length ( ) - 1 ; while ( l <= r ) { if ( l == r ) { if ( k > 0 ) palin [ l ] = '9' ; } if ( palin [ l ] < '9' ) { if ( k >= 2 && palin [ l ] == str . charAt ( l ) && palin [ r ] == str . charAt ( r ) ) { k -= 2 ; palin [ l ] = palin [ r ] = '9' ; } else if ( k >= 1 && ( palin [ l ] != str . charAt ( l ) || palin [ r ] != str . charAt ( r ) ) { k -- ; palin [ l ] = palin [ r ] = '9' ; } } l ++ ; r -- ; } return palin ; }
static int findMinRooms ( String slots [ ] , int n , int m ) { int [ ] counts = new int [ m ] ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( slots [ i ] . charAt ( j ) == '1' ) counts [ j ] ++ ; return * max_element ( counts , counts + m ) ; }
public static int minProduct ( int arr [ ] , int n , int k ) { PriorityQueue < Integer , Vector < Integer > > pq = new PriorityQueue < Integer , Vector < Integer > > ( ) ; for ( int i = 0 ; i < n ; i ++ ) pq . add ( arr [ i ] ) ; int count = 0 , ans = 1 ; while ( pq . isEmpty ( ) == false && count < k ) { ans = ans * pq . peek ( ) ; pq . remove ( ) ; count ++ ; } return ans ; }
public static int largest ( int arr [ ] , int n ) { return * Math . max_element ( arr , arr + n ) ; }
static int firstElement ( int arr [ ] , int n , int k ) { HashMap < Integer , Integer > count_map = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( count_map . containsKey ( arr [ i ] ) ) return arr [ i ] ; return - 1 ; }
static int findLongestConseqSubseq ( int arr [ ] , int n ) { HashSet < Integer > S = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; ++ i ) S . add ( arr [ i ] ) ; int ans = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( ! S . contains ( arr [ i ] - 1 ) ) { int j = arr [ i ] ; while ( S . contains ( j ) ) j ++ ; if ( ans < j - arr [ i ] ) ans = j - arr [ i ] ; } } return ans ; }
static void divisibilityCheck ( int arr [ ] , int n ) { HashSet < Integer > s = new HashSet < Integer > ( ) ; int max_ele = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { s . add ( arr [ i ] ) ; max_ele = Math . max ( max_ele , arr [ i ] ) ; } HashSet < Integer > res = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != 0 ) { for ( int j = arr [ i ] * 2 ; j <= max_ele ; j += arr [ i ] ) { if ( s . contains ( j ) ) res . add ( j ) ; } } } HashMap < Integer , Integer > myMap = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != 0 ) { for ( int j = arr [ i ] * 2 ; j <= max_ele ; j += arr [ i ] ) { if ( s . containsKey ( j ) ) res . put ( j , myMap . get ( it -> first ) + " ▁ " ) ; } } for ( auto x : ans ) System . out . println ( x + " ▁ " ) ; }
static int minPalPartion ( String str ) { int n = str . length ( ) ; int [ ] [ ] C = new int [ n ] [ n ] ; boolean [ ] [ ] P = new boolean [ n ] [ n ] ; int i , j , k , L ; for ( i = 0 ; i < n ; i ++ ) { P [ i ] [ i ] = true ; C [ i ] [ i ] = 0 ; } for ( L = 2 ; L <= n ; L ++ ) { for ( i = 0 ; i < n - L + 1 ; i ++ ) { j = i + L - 1 ; if ( L == 2 ) P [ i ] [ j ] = ( str . charAt ( i ) == str . charAt ( j ) ) ; else P [ i ] [ j ] = ( str . charAt ( i ) == str . charAt ( j ) ) && P [ i + 1 ] [ j - 1 ] ; if ( P [ i ] [ j ] == true ) C [ i ] [ j ] = 0 ; else { C [ i ] [ j ] = Integer . MAX_VALUE ; for ( k = i ; k <= j - 1 ; k ++ ) C [ i ] [ j ] = Math . min ( C [ i ] [ j ] , C [ i ] [ k ] + C [ k + 1 ] [ j ] + 1 ) ; } } } return C [ 0 ] [ n - 1 ] ; }
static int height ( int N ) { return ( int ) ( Math . ceil ( log2 ( N + 1 ) ) - 1 ) ; }
static Boolean checkCount ( int arr [ ] , int n , int k ) { HashMap < Integer , Integer > hash = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) hash . put ( arr [ i ] , hash . get ( arr [ i ] ) + 1 ) ; for ( auto x : hash ) if ( x . second > 2 * k ) return false ; return true ; }
static void removeDuplicates ( char S [ ] , int n ) { if ( n < 2 ) return ; int j = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( S [ j ] != S [ i ] ) { j ++ ; S [ j ] = S [ i ] ; } } j ++ ; S [ j ] = ' \0' ; }
static void KMaxCombinations ( int A [ ] , int B [ ] , int N , int K ) { PriorityQueue < Integer > pq = new PriorityQueue < Integer > ( ) ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) pq . add ( A [ i ] + B [ j ] ) ; int count = 0 ; while ( count < K ) { System . out . print ( pq . peek ( ) + " " ) ; count ++ ; } }
static int findRepeatingNumber ( int arr [ ] , int n ) { int sq = ( n / sq ) + 1 ; int [ ] count = new int [ range ] ; for ( int i = 0 ; i <= n ; i ++ ) { count [ ( arr [ i ] - 1 ) / sq ] ++ ; } int selected_block = range - 1 ; for ( int i = 0 ; i < range - 1 ; i ++ ) { if ( count [ i ] > sq ) { selected_block = i ; break ; } } HashMap < Integer , Integer > ( ) { Map < Integer , Integer > m = new HashMap < > ( ) ; for ( int i = 0 ; i <= n ; i ++ ) { if ( ( selected_block * sq ) < arr [ i ] ) && ( arr [ i ] <= ( ( selected_block + 1 ) * sq ) ) ) { m . put ( arr [ i ] , m . get ( arr [ i ] ) + 1 ) ; } } return - 1 ; }
static String to_upper ( String in ) { for ( int i = 0 ; i < in . length ( ) ; i ++ ) if ( ' a ' <= in . charAt ( i ) <= ' z ' ) in [ i ] = in . charAt ( i ) - ' a ' + ' A ' ; return in ; }
static void sortInWave ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i += 2 ) { if ( i > 0 && arr [ i - 1 ] > arr [ i ] ) swap ( & arr [ i ] , & arr [ i - 1 ] ) ; if ( i < n - 1 && arr [ i ] < arr [ i + 1 ] ) swap ( & arr [ i ] , & arr [ i + 1 ] ) ; } }
static String getMinNumberForPattern ( String seq ) { int n = seq . length ( ) ; if ( n >= 9 ) return " - 1" ; String result = new String ( n + 1 , ' ▁ ' ) ; int count = 1 ; for ( int i = 0 ; i <= n ; i ++ ) { if ( i == n || seq . charAt ( i ) == ' I ' ) { for ( int j = i - 1 ; j >= - 1 ; j -- ) { result [ j + 1 ] = '0' + count ++ ; if ( j >= 0 && seq . charAt ( j ) == ' I ' ) break ; } } } return result ; }
static void findMin ( int V ) { Vector < Integer > ans = new Vector < Integer > ( ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { while ( V >= deno [ i ] ) { V -= deno [ i ] ; ans . add ( deno [ i ] ) ; } } for ( int i = 0 ; i < ans . size ( ) ; i ++ ) System . out . print ( ans . get ( i ) + " ▁ " ) ; }
static int findRepeating ( int arr [ ] , int n ) { return accumulate ( arr , arr + n , 0 ) - ( ( n - 1 ) * n / 2 ) ; }
static String findSum ( String str1 , String str2 ) { if ( str1 . length ( ) > str2 . length ( ) ) swap ( str1 , str2 ) ; String str = " " ; int n1 = str1 . length ( ) , n2 = str2 . length ( ) ; reverse ( str1 . begin ( ) , str1 . end ( ) ) ; reverse ( str2 . begin ( ) , str2 . end ( ) ) ; int carry = 0 ; for ( int i = 0 ; i < n1 ; i ++ ) { int sum = ( ( str1 . charAt ( i ) - '0' ) + ( str2 . charAt ( i ) - '0' ) + carry ) ; str . push_back ( sum % 10 + '0' ) ; carry = sum / 10 ; } for ( int i = n1 ; i < n2 ; i ++ ) { int sum = ( ( str2 . charAt ( i ) - '0' ) + carry ) ; str . push_back ( sum % 10 + '0' ) ; carry = sum / 10 ; } if ( carry ) str . add ( carry + '0' ) ; return str ; }
