def printPairs ( arr , n ) : NEW_LINE INDENT v = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] ) == abs ( arr [ j ] ) : NEW_LINE INDENT v . append ( abs ( arr [ i ] ) ) NEW_LINE DEDENT DEDENT if ( len ( v ) == 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT v . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( - v [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def findArea ( a , b , c ) : NEW_LINE INDENT if ( a < 0 or b < 0 or c < 0 or ( a + b <= c ) or a + c <= b or b + c <= a ) : NEW_LINE INDENT print ( " Not ▁ a ▁ valid ▁ triangle " ) NEW_LINE DEDENT print ( " Not ▁ a ▁ valid ▁ triangle " ) NEW_LINE DEDENT
def isMajority ( a , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if mp . get ( a [ i ] ) : NEW_LINE INDENT mp [ a [ i ] ] = mp [ a [ i ] ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ a [ i ] ] = 1 NEW_LINE DEDENT DEDENT for x in mp . keys ( ) : NEW_LINE INDENT if x . getValue ( ) >= n // 2 : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def recaman ( n ) : NEW_LINE INDENT if ( n <= 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT s = Set ( ) NEW_LINE s . add ( 0 ) NEW_LINE prev = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT curr = prev - i NEW_LINE if ( curr < 0 or s . contains ( curr ) ) : NEW_LINE INDENT curr = prev + i NEW_LINE DEDENT s . add ( curr ) NEW_LINE DEDENT print ( " % d , ▁ " , curr ) NEW_LINE prev = curr NEW_LINE DEDENT DEDENT
def findLength ( str1 ) : NEW_LINE INDENT n = len ( str1 ) NEW_LINE maxlen = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n + 2 ) : NEW_LINE INDENT length = j - i + 1 NEW_LINE leftsum = 0 NEW_LINE rightsum = 0 NEW_LINE for k in range ( 0 , length // 2 ) : NEW_LINE INDENT leftsum += ( str1 [ i + k ] - '0' ) NEW_LINE DEDENT if ( leftsum == rightsum and maxlen < length ) : NEW_LINE INDENT maxlen = length NEW_LINE DEDENT DEDENT DEDENT return maxlen NEW_LINE DEDENT
def prevPermutation ( str1 ) : NEW_LINE INDENT n = len ( str1 ) NEW_LINE i = n NEW_LINE while ( i > 0 and str1 [ i - 1 ] <= str1 [ i ] ) : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT if ( i <= 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT j = i - 1 NEW_LINE while ( j + 1 <= n and str1 [ j + 1 ] <= str [ i - 1 ] ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT swap ( str , i - 1 , j ) NEW_LINE temp = string ( str1 ) NEW_LINE temp . reverse ( ) NEW_LINE str = string ( temp1 ) NEW_LINE temp . reverse ( ) NEW_LINE str = string ( temp1 ) NEW_LINE temp . reverse ( ) NEW_LINE str = string ( temp1 ) NEW_LINE return True NEW_LINE DEDENT
def findSubString ( str , pat ) : NEW_LINE INDENT len1 = len ( str ) NEW_LINE len2 = len ( pat ) NEW_LINE if ( len1 < len2 ) : NEW_LINE INDENT return " " NEW_LINE DEDENT hash_pat = [ 0 ] * ( no_of_chars ) NEW_LINE hash_str = [ 0 ] * ( no_of_chars ) NEW_LINE for i in range ( len2 ) : NEW_LINE INDENT hash_str [ ord ( str [ j ] ) ] += 1 NEW_LINE DEDENT if ( hash_pat [ ord ( str [ j ] ) ] != 0 and hash_str [ ord ( str [ j ] ) ] <= hash_pat [ ord ( str [ start ] ) ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( count == len2 ) : NEW_LINE INDENT while ( hash_str [ ord ( str [ start ] ) ] > hash_pat [ ord ( str [ start ] ) ] or hash_pat [ ord ( str [ start ] ) ] == 0 ) : NEW_LINE INDENT if ( hash_str [ ord ( str [ start ] ) ] > hash_pat [ ord ( str [ start ] ) ] ) : NEW_LINE INDENT hash_str [ ord ( str [ start ] ) ] -= 1 NEW_LINE start += 1 NEW_LINE DEDENT DEDENT if ( min_len > len_window ) : NEW_LINE INDENT min_len = len_window NEW_LINE start_index = start NEW_LINE DEDENT DEDENT if ( start_index == - 1 ) : NEW_LINE INDENT print ( " No ▁ such ▁ window ▁ exists " ) NEW_LINE DEDENT return str [ start_index : NEW_LINE DEDENT
def shuffle ( card , n ) : NEW_LINE INDENT rand = new Random ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT r = i + rand . nextInt ( 52 - i ) NEW_LINE card [ r ] = card [ i ] NEW_LINE card [ i ] = temp NEW_LINE DEDENT DEDENT
def removeConsecutiveSame ( v ) : NEW_LINE INDENT st = [ ] NEW_LINE for i in range ( len ( v ) ) : NEW_LINE INDENT if ( st . empty ( ) ) : NEW_LINE INDENT st . append ( v [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT str = st [ - 1 ] NEW_LINE if ( str . equals ( v [ i ] ) ) : NEW_LINE INDENT st . pop ( ) NEW_LINE DEDENT else : NEW_LINE INDENT st . append ( v [ i ] ) NEW_LINE DEDENT DEDENT return st . size ( ) NEW_LINE DEDENT
def find ( list1 , list2 ) : NEW_LINE INDENT res = [ ] NEW_LINE max_possible_sum = max ( list1 . size ( ) + list2 . size ( ) - 2 ) NEW_LINE for sum in range ( 0 , max_possible_sum + 1 ) : NEW_LINE INDENT for i in range ( 0 , sum + 1 ) : NEW_LINE INDENT if ( i < list1 . size ( ) and ( sum - i ) < list2 . size ( ) and list1 [ i ] == list2 [ sum - i ] ) : NEW_LINE INDENT res . append ( list1 [ i ] ) NEW_LINE DEDENT DEDENT if ( res . size ( ) > 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT for i in range ( 0 , res . size ( ) ) : NEW_LINE INDENT print ( res [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def getLevenstein ( input ) : NEW_LINE INDENT revInput = reverse ( input ) NEW_LINE n = len ( input ) NEW_LINE dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT dp [ 0 ] [ i ] = i NEW_LINE dp [ i ] [ 0 ] = i NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( input [ i - 1 ] == revInput [ j - 1 ] ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = 1 + min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT res = + 2147483647 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT res = min ( res , dp [ i ] [ j ] ) NEW_LINE if ( i < n ) : NEW_LINE INDENT res = min ( res , dp [ i + 1 ] [ j ] ) NEW_LINE DEDENT if ( i > 0 ) : NEW_LINE INDENT res = min ( res , dp [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def countDistinct ( arr , k ) : NEW_LINE INDENT s = set ( ) NEW_LINE dist_count = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT if ( arr [ i ] == None ) : NEW_LINE INDENT hM [ arr [ i ] ] = 1 NEW_LINE dist_count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count = hM [ arr [ i ] ] NEW_LINE hM [ arr [ i ] ] = count + 1 NEW_LINE DEDENT DEDENT print ( dist_count ) NEW_LINE for i in range ( k ) : NEW_LINE INDENT if ( hM [ arr [ i - k ] ] == 1 ) : NEW_LINE INDENT hM [ arr [ i - k ] ] = - 1 NEW_LINE DEDENT else : NEW_LINE INDENT count = hM [ arr [ i - k ] ] NEW_LINE s . append ( arr [ i ] ) NEW_LINE hM [ arr [ i ] ] = count + 1 NEW_LINE DEDENT DEDENT print ( dist_count ) NEW_LINE DEDENT DEDENT
def lcs ( dp , arr1 , n , arr2 , m , k ) : NEW_LINE INDENT if ( k < 0 ) : NEW_LINE INDENT return - 10000000 NEW_LINE DEDENT if ( n < 0 or m < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = dp [ n ] [ m ] [ k ] NEW_LINE if ( ans != - 1 ) : NEW_LINE INDENT return ans NEW_LINE DEDENT try : NEW_LINE INDENT ans = max ( lcs ( dp , arr1 , n - 1 , arr2 , m , k ) , lcs ( dp , arr1 , n , arr2 , m - 1 , k ) ) NEW_LINE DEDENT if ( arr1 [ n - 1 ] == arr2 [ m - 1 ] ) : NEW_LINE INDENT ans = max ( ans , 1 + lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k ) ) NEW_LINE DEDENT ans = max ( ans , 1 + lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k - 1 ) ) NEW_LINE DEDENT catch ( Exception e ) : NEW_LINE INDENT ans = max ( ans , 1 + lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k - 1 ) ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def printDivisors ( n ) : NEW_LINE INDENT v = [ 0 ] * 10 NEW_LINE for i in range ( 1 , math . sqrt ( n ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( n / i == i ) : NEW_LINE INDENT print ( " % d ▁ " , i ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " % d ▁ " , i ) NEW_LINE DEDENT v . append ( n // i ) NEW_LINE DEDENT DEDENT for i in range ( len ( v ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( " % d ▁ " , v [ i ] ) NEW_LINE DEDENT DEDENT
def largestSubset ( a , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE dp = [ 0 ] * ( n + 1 ) NEW_LINE dp [ n - 1 ] = 1 NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT mxm = 0 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( a [ j ] % a [ i ] == 0 ) : NEW_LINE INDENT mxm = max ( mxm , dp [ j ] ) NEW_LINE DEDENT DEDENT dp [ i ] = 1 + mxm NEW_LINE DEDENT return max ( dp ) . max ( ) . getAsInt ( ) NEW_LINE DEDENT
def encodedChar ( str , k ) : NEW_LINE INDENT expand = " " NEW_LINE temp = " " NEW_LINE freq = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT temp = " " NEW_LINE freq = 0 NEW_LINE while ( i < len ( str ) and str [ i ] >= ' a ' and str [ i ] <= ' z ' ) : NEW_LINE INDENT temp += str [ i ] NEW_LINE i += 1 NEW_LINE DEDENT while ( i < len ( str ) and str [ i ] >= '1' and str [ i ] <= '9' ) : NEW_LINE INDENT freq = freq * 10 + str [ i ] - '0' NEW_LINE i += 1 NEW_LINE DEDENT DEDENT if ( freq == 0 ) : NEW_LINE INDENT expand += temp NEW_LINE DEDENT DEDENT if ( freq == 0 ) : NEW_LINE INDENT expand += temp NEW_LINE DEDENT return expand [ k - 1 ] NEW_LINE DEDENT
def countNum ( arr , n ) : NEW_LINE INDENT s = Set ( ) NEW_LINE count = 0 NEW_LINE maxm = 10 ** 9 NEW_LINE minm = 10 ** 9 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . add ( arr [ i ] ) NEW_LINE if arr [ i ] < minm : NEW_LINE INDENT minm = arr [ i ] NEW_LINE DEDENT if arr [ i ] > maxm : NEW_LINE INDENT maxm = arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( minm , maxm + 1 ) : NEW_LINE INDENT if ( arr [ i ] not in s ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def countPairs ( arr , n ) : NEW_LINE INDENT hm = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] in hm ) : NEW_LINE INDENT hm [ arr [ i ] ] = hm [ arr [ i ] ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT hm [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for it in hm . keys ( ) : NEW_LINE INDENT count = it . getValue ( ) NEW_LINE ans += ( count * ( count - 1 ) ) // 2 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def decimalToBinary ( num , k_prec ) : NEW_LINE INDENT binary = " " NEW_LINE Integral = ( int ) num NEW_LINE fractional = ( double ) num NEW_LINE while ( Integral > 0 ) : NEW_LINE INDENT rem = Integral % 2 NEW_LINE binary += chr ( rem + '0' ) NEW_LINE Integral /= 2 NEW_LINE DEDENT binary = reverse ( binary ) NEW_LINE binary += ( ' . ' ) NEW_LINE while ( k_prec -- > 0 ) : NEW_LINE INDENT fractional *= 2 NEW_LINE fract_bit = ( int ) fractional NEW_LINE if ( fract_bit == 1 ) : NEW_LINE INDENT fractional -= fract_bit NEW_LINE binary += ( char ) ( 1 + '0' ) NEW_LINE DEDENT else : NEW_LINE INDENT binary += chr ( 0 + '0' ) NEW_LINE DEDENT DEDENT return binary NEW_LINE DEDENT
def evaluateBoolExpr ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i + 1 < n and i + 2 < n ) : NEW_LINE INDENT if ( s [ i + 1 ] == ' A ' ) : NEW_LINE INDENT if ( s [ i + 2 ] == '0' or s [ i ] == 0 ) : NEW_LINE INDENT s [ i + 2 ] = '0' NEW_LINE DEDENT else : NEW_LINE INDENT if ( s [ i + 2 ] == '1' or s [ i ] == '1' ) : NEW_LINE INDENT s [ i + 2 ] = '1' NEW_LINE DEDENT else : NEW_LINE INDENT if ( s [ i + 2 ] == s [ i ] ) : NEW_LINE INDENT s [ i + 2 ] = '0' NEW_LINE DEDENT else : NEW_LINE INDENT s [ i + 2 ] = '1' NEW_LINE DEDENT DEDENT DEDENT return s [ n - 1 ] - '0' NEW_LINE DEDENT
def minSwaps ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE arrpos = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT arrpos . append ( arr [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( o1 . getKey ( ) > o2 . getKey ( ) ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT elif ( o1 . getKey ( ) == o2 . getKey ( ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT vis = [ False ] * ( n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( vis [ i ] or arrpos [ i ] . getValue ( ) == i ) : NEW_LINE INDENT continue NEW_LINE DEDENT cycle_size = 0 NEW_LINE j = i NEW_LINE while ( vis [ j ] == False ) : NEW_LINE INDENT vis [ j ] = True NEW_LINE j = arrpos [ j ] . getValue ( ) NEW_LINE cycle_size += 1 NEW_LINE DEDENT if ( cycle_size > 0 ) : NEW_LINE INDENT ans += ( cycle_size - 1 ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def minimumBox ( arr , n ) : NEW_LINE INDENT q = Queue ( ) NEW_LINE arr . sort ( ) NEW_LINE q . put ( arr [ 0 ] ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT now = q . element ( ) NEW_LINE if ( arr [ i ] >= 2 * now ) : NEW_LINE INDENT q . get ( ) NEW_LINE DEDENT q . put ( arr [ i ] ) NEW_LINE DEDENT DEDENT return q . size ( ) NEW_LINE DEDENT
def convertOpposite ( str ) : NEW_LINE INDENT ln = len ( str ) NEW_LINE for i in range ( ln ) : NEW_LINE INDENT c = ord ( str [ i ] ) NEW_LINE if ( Character . isLowerCase ( c ) ) : NEW_LINE INDENT str [ i , i + 1 ] = ord ( c ) + " " NEW_LINE DEDENT else : NEW_LINE INDENT str [ i , i + 1 ] = ord ( c ) + " " NEW_LINE DEDENT DEDENT
def findRepeating ( arr , n ) : NEW_LINE INDENT s = Set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] in s ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT s . add ( arr [ i ] ) NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def transpose ( A ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT temp = A [ i ] [ j ] NEW_LINE A [ i ] [ j ] = A [ j ] [ i ] NEW_LINE A [ j ] [ i ] = temp NEW_LINE DEDENT DEDENT
def printSubsequences ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE opsize = ( int ) ( math . pow ( 2 , n - 1 ) ) NEW_LINE for counter in range ( 0 , opsize ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT print ( s [ j ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT
def printRoman ( number ) : NEW_LINE INDENT c = [ 0 ] * 10001 NEW_LINE i = 0 NEW_LINE if ( number <= 0 ) : NEW_LINE INDENT return None NEW_LINE DEDENT if ( number >= 1000 ) : NEW_LINE INDENT i = digit ( ' M ' , number / 1000 , i , c ) NEW_LINE number = number % 1000 NEW_LINE DEDENT elif ( number >= 500 ) : NEW_LINE INDENT if ( number < 900 ) : NEW_LINE INDENT i = digit ( ' D ' , number / 500 , i , c ) NEW_LINE number = number % 500 NEW_LINE DEDENT else : NEW_LINE INDENT i = sub_digit ( ' C ' , ' M ' , i , c ) NEW_LINE number = number % 100 NEW_LINE DEDENT DEDENT elif ( number >= 100 ) : NEW_LINE INDENT if ( number < 10 ) : NEW_LINE INDENT if ( number < 40 ) : NEW_LINE INDENT i = digit ( ' X ' , number / 10 , i , c ) NEW_LINE number = number % 10 NEW_LINE DEDENT else : NEW_LINE INDENT i = sub_digit ( ' X ' , ' L ' , i , c ) NEW_LINE number = number % 10 NEW_LINE DEDENT DEDENT elif ( number >= 5 ) : NEW_LINE INDENT if ( number < 9 ) : NEW_LINE INDENT i = digit ( ' V ' , number // 5 , i , c ) NEW_LINE number = number % 5 NEW_LINE DEDENT else : NEW_LINE INDENT i = sub_digit ( ' I ' , ' V ' , i , c ) NEW_LINE number = 0 NEW_LINE DEDENT DEDENT DEDENT
def findTriplet ( a1 , a2 , a3 , n1 , n2 , n3 , sum ) : NEW_LINE INDENT s = Set ( ) NEW_LINE for i in range ( n1 ) : NEW_LINE INDENT s . add ( a1 [ i ] ) NEW_LINE DEDENT al = Set ( ) NEW_LINE for i in range ( n2 ) : NEW_LINE INDENT for j in range ( n3 ) : NEW_LINE INDENT if ( al . contains ( sum - a2 [ i ] - a3 [ j ] ) and al . indexOf ( sum - a2 [ i ] - a3 [ j ] ) != al [ len ( al ) - 1 ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT
def check ( s ) : NEW_LINE INDENT if ( len ( s ) >= 10 ) : NEW_LINE INDENT return True NEW_LINE DEDENT for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT for j in range ( 1 , len ( s ) ) : NEW_LINE INDENT for k in range ( j + 1 , len ( s ) ) : NEW_LINE INDENT s1 = " " NEW_LINE s2 = " " NEW_LINE s3 = " " NEW_LINE s4 = " " NEW_LINE try : NEW_LINE INDENT s1 = s [ 0 : 0 + i ] NEW_LINE s2 = s [ i : j - i ] NEW_LINE s3 = s [ j : k - j ] NEW_LINE s4 = s [ k : len ( s ) - k ] NEW_LINE DEDENT except ( StringIndexOutOfBoundsException e ) : NEW_LINE INDENT } NEW_LINE INDENT if ( strcheck ( s1 , s2 ) and strcheck ( s1 , s3 ) and strcheck ( s2 , s4 ) and strcheck ( s3 , s4 ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT
def bitonicGenerator ( arr , n ) : NEW_LINE INDENT i = 1 NEW_LINE j = n - 1 NEW_LINE if ( j % 2 != 0 ) : NEW_LINE INDENT j -= 2 NEW_LINE DEDENT while ( i < j ) : NEW_LINE INDENT arr = swap ( arr , i , j ) NEW_LINE i += 2 NEW_LINE j -= 2 NEW_LINE DEDENT while ( i < j ) : NEW_LINE INDENT arr = swap ( arr , i , j ) NEW_LINE i += 2 NEW_LINE j -= 2 NEW_LINE DEDENT while ( low < high ) : NEW_LINE INDENT temp = arr [ low ] NEW_LINE arr [ low ] = arr [ high ] NEW_LINE arr [ high ] = temp NEW_LINE low += 1 NEW_LINE high -= 1 NEW_LINE DEDENT DEDENT
def splitString ( str ) : NEW_LINE INDENT alpha = [ 0 ] * 10 NEW_LINE num = [ 0 ] * 10 NEW_LINE special = [ 0 ] * 10 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( Character . isDigit ( str [ i ] ) ) : NEW_LINE INDENT num . append ( str [ i ] ) NEW_LINE DEDENT elif ( Character . isAlphabetic ( str [ i ] ) ) : NEW_LINE INDENT alpha . append ( str [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT special . append ( str [ i ] ) NEW_LINE DEDENT DEDENT print ( alpha ) NEW_LINE num NEW_LINE print ( num ) NEW_LINE DEDENT
def binaryMedian ( m , r , c ) : NEW_LINE INDENT max = - float ( ' inf ' ) NEW_LINE min = + float ( ' inf ' ) NEW_LINE for i in range ( r ) : NEW_LINE INDENT if ( m [ i ] [ 0 ] < min ) : NEW_LINE INDENT min = m [ i ] [ 0 ] NEW_LINE DEDENT if ( m [ i ] [ c - 1 ] > max ) : NEW_LINE INDENT max = m [ i ] [ c - 1 ] NEW_LINE DEDENT DEDENT desired = ( r * c + 1 ) / 2 NEW_LINE while ( min < max ) : NEW_LINE INDENT mid = min + ( max - min ) / 2 NEW_LINE get = 0 NEW_LINE for i in range ( r ) : NEW_LINE INDENT get = binarySearch ( m [ i ] , mid ) NEW_LINE if ( get < 0 ) : NEW_LINE INDENT get = abs ( get ) - 1 NEW_LINE DEDENT else : NEW_LINE INDENT get = get + 1 NEW_LINE DEDENT place = place + get NEW_LINE DEDENT if ( place < desired ) : NEW_LINE INDENT min = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT max = mid NEW_LINE DEDENT DEDENT return min NEW_LINE DEDENT
def printDuplicates ( arr , n ) : NEW_LINE INDENT map = dict ( ) NEW_LINE count = 0 NEW_LINE dup = False NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] in map ) : NEW_LINE INDENT count = map [ arr [ i ] ] NEW_LINE DEDENT map [ arr [ i ] ] = count + 1 NEW_LINE DEDENT else : NEW_LINE INDENT map [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT for entry in range ( map . keys ( ) ) : NEW_LINE INDENT if ( entry . getValue ( ) > 1 ) : NEW_LINE INDENT print ( entry . getKey ( ) , end = " ▁ " ) NEW_LINE dup = True NEW_LINE DEDENT DEDENT if ( dup ) : NEW_LINE INDENT print ( " - 1 " ) NEW_LINE DEDENT DEDENT
def stoogesort ( arr , l , h ) : NEW_LINE INDENT if ( l >= h ) : NEW_LINE INDENT return None NEW_LINE DEDENT if arr [ l ] > arr [ h ] : NEW_LINE INDENT t = arr [ l ] NEW_LINE arr [ l ] = arr [ h ] NEW_LINE arr [ h ] = t NEW_LINE DEDENT if ( h - l + 1 > 2 ) : NEW_LINE INDENT t = ( h - l + 1 ) / 3 NEW_LINE stoogesort ( arr , l , h - t ) NEW_LINE stoogesort ( arr , l + t , h ) NEW_LINE DEDENT DEDENT
def printEqualModNumbers ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE d = arr [ n - 1 ] - arr [ 0 ] NEW_LINE v = [ ] NEW_LINE for i in range ( 1 , d + 1 ) : NEW_LINE INDENT if ( d % i == 0 ) : NEW_LINE INDENT v . append ( i ) NEW_LINE DEDENT if ( i != d / i ) : NEW_LINE INDENT v . append ( d / i ) NEW_LINE DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT temp = arr [ 0 ] % v [ i ] NEW_LINE j = 1 NEW_LINE while j < n : NEW_LINE INDENT if ( arr [ j ] % v [ i ] != temp ) : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if ( j == n ) : NEW_LINE INDENT print ( v [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def recursiveReverse ( st ) : NEW_LINE INDENT st . append ( st [ 0 ] ) NEW_LINE for i in range ( len ( st ) ) : NEW_LINE INDENT str [ i ] = st [ - 1 ] NEW_LINE st . pop ( ) NEW_LINE DEDENT return ' ' . join ( str ) NEW_LINE DEDENT
def printRect ( X , Y , n ) : NEW_LINE INDENT Xmax = max ( Arrays . asList ( X ) ) NEW_LINE Xmin = min ( Arrays . asList ( X ) ) NEW_LINE Ymax = max ( Arrays . asList ( Y ) ) NEW_LINE Ymin = min ( Arrays . asList ( Y ) ) NEW_LINE print ( " { " , Xmin , " , ▁ " , Ymin , " } " ) NEW_LINE print ( " { " , Xmax , " , ▁ " , Ymax , " } " ) NEW_LINE print ( " { " , Xmin , " , ▁ " , Ymin , " } " ) NEW_LINE DEDENT print ( " { " , Xmax , " , ▁ " , Ymax , " } " ) NEW_LINE DEDENT print ( " { " , Xmax , " , ▁ " , Ymin , " } " ) NEW_LINE DEDENT
def NFG ( a , n , freq ) : NEW_LINE INDENT s = [ 0 ] * n NEW_LINE res = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( freq [ a [ s . queue ] ] > freq [ a [ i ] ] ) : NEW_LINE INDENT s . append ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT while ( freq [ a [ s . queue ] ] < freq [ a [ i ] ] and len ( s ) > 0 ) : NEW_LINE INDENT res [ s . queue [ - 1 ] = a [ i ] NEW_LINE s . pop ( ) NEW_LINE DEDENT DEDENT while ( len ( s ) > 0 ) : NEW_LINE INDENT res [ s . queue ] = - 1 NEW_LINE s . pop ( ) NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( res [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def printEqualSumSets ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , len ( arr ) ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT k = sum > > 1 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT dp = [ [ False for x in range ( k + 1 ) ] for y in range ( n + 1 ) ] NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for currSum in range ( 1 , k + 1 ) : NEW_LINE INDENT dp [ i ] [ currSum ] = dp [ i - 1 ] [ currSum ] NEW_LINE if ( arr [ i - 1 ] <= currSum ) : NEW_LINE INDENT dp [ i ] [ currSum ] = dp [ i ] [ currSum ] | dp [ i - 1 ] [ currSum - arr [ i - 1 ] ] NEW_LINE DEDENT DEDENT DEDENT set1 = [ ] NEW_LINE set2 = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( dp [ i - 1 ] [ currSum ] ) : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT currSum -= arr [ i ] NEW_LINE DEDENT DEDENT print ( " Set ▁ 1 ▁ elements : ▁ " ) NEW_LINE for i in range ( set1 . size ( ) ) : NEW_LINE INDENT print ( set1 [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT print ( " \n Set ▁ 2 ▁ elements : ▁ " ) NEW_LINE DEDENT
def reverseStr ( str1 ) : NEW_LINE INDENT n = len ( str1 ) NEW_LINE ch = string1 [ : n ] NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT temp = ch [ i ] NEW_LINE ch [ i ] = ch [ j ] NEW_LINE ch [ j ] = temp NEW_LINE DEDENT print ( ch ) NEW_LINE DEDENT
def minimizeWithKSwaps ( arr , n , k ) : NEW_LINE INDENT for i in range ( 0 , n - 1 and k > 0 ) : NEW_LINE INDENT pos = i NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( j - i > k ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( arr [ j ] < arr [ pos ] ) : NEW_LINE INDENT pos = j NEW_LINE DEDENT DEDENT temp = arr [ j ] NEW_LINE arr [ j ] = arr [ j - 1 ] NEW_LINE arr [ j - 1 ] = arr [ j - 1 ] NEW_LINE DEDENT k -= pos - i NEW_LINE DEDENT DEDENT
def countSubarrays ( arr , n ) : NEW_LINE INDENT difference = 0 NEW_LINE ans = 0 NEW_LINE hash_positive = [ 0 ] * ( n + 1 ) NEW_LINE hash_negative = [ 0 ] * ( n + 1 ) NEW_LINE hash_positive [ 0 ] = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] & 1 ) == 1 ) : NEW_LINE INDENT difference += 1 NEW_LINE DEDENT else : NEW_LINE INDENT difference -= 1 NEW_LINE DEDENT if ( difference < 0 ) : NEW_LINE INDENT ans += hash_negative [ - difference ] NEW_LINE hash_negative [ - difference ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += hash_positive [ difference ] NEW_LINE hash_positive [ difference ] += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def findPairs ( arr ) : NEW_LINE INDENT map = dict ( ) NEW_LINE n = len ( arr ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT sum = arr [ i ] + arr [ j ] NEW_LINE if ( sum not in map ) : NEW_LINE INDENT map [ sum ] = new pair ( i , j ) NEW_LINE DEDENT else : NEW_LINE INDENT p = map [ sum ] NEW_LINE print ( " ( " , arr [ p . first ] , ' , ▁ ' , arr [ p . second ] , ' ) ▁ and ▁ ( " , arr [ i ] , " , ▁ " , arr [ j ] , " ) " ) NEW_LINE return True NEW_LINE DEDENT DEDENT DEDENT
def check ( s1 , s2 ) : NEW_LINE INDENT n = len ( s1 ) NEW_LINE m = len ( s2 ) NEW_LINE dp = [ [ False for x in range ( n + 1 ) ] for y in range ( m + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( m + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = False NEW_LINE DEDENT DEDENT dp [ 0 ] [ 0 ] = True NEW_LINE for i in range ( len ( s1 ) ) : NEW_LINE INDENT for j in range ( len ( s2 ) ) : NEW_LINE INDENT if ( dp [ i ] [ j ] ) : NEW_LINE INDENT if ( j < len ( s1 ) and ( s1 [ i ] ) == s2 [ j ] ) : NEW_LINE INDENT dp [ i + 1 ] [ j + 1 ] = True NEW_LINE DEDENT DEDENT DEDENT return ( dp [ n ] [ m ] ) NEW_LINE DEDENT
def checkDuplicatesWithinK ( arr , k ) : NEW_LINE INDENT set = Set ( ) NEW_LINE for i in range ( 0 , arr . length ) : NEW_LINE INDENT if ( arr [ i ] in set ) : NEW_LINE INDENT return True NEW_LINE DEDENT set . add ( arr [ i ] ) NEW_LINE if ( i >= k ) : NEW_LINE INDENT set . remove ( arr [ i - k ] ) NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def minOperation ( arr , n ) : NEW_LINE INDENT hash = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] in hash ) : NEW_LINE INDENT hash [ arr [ i ] ] = hash [ arr [ i ] ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT hash [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT max_count = 0 NEW_LINE s = set ( s ) NEW_LINE for i in range ( s ) : NEW_LINE INDENT if ( max_count < hash [ i ] ) : NEW_LINE INDENT max_count = hash [ i ] NEW_LINE DEDENT DEDENT return ( n - max_count ) NEW_LINE DEDENT
def findSum ( str ) : NEW_LINE INDENT temp = " " NEW_LINE sum = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT ch = ord ( str [ i ] ) NEW_LINE if ( Character . isDigit ( ch ) ) : NEW_LINE INDENT temp += chr ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT sum += int ( temp ) NEW_LINE temp = "0" NEW_LINE DEDENT DEDENT return sum + int ( temp ) NEW_LINE DEDENT
def mostFrequent ( arr , n ) : NEW_LINE INDENT hp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT key = arr [ i ] NEW_LINE if ( hp . get ( key ) ) : NEW_LINE INDENT freq = hp [ key ] NEW_LINE freq += 1 NEW_LINE DEDENT else : NEW_LINE INDENT hp [ key ] = 1 NEW_LINE DEDENT DEDENT max_count = 0 NEW_LINE for val in hp . keys ( ) : NEW_LINE INDENT if ( max_count < val . getValue ( ) ) : NEW_LINE INDENT res = val . getKey ( ) NEW_LINE max_count = val . getValue ( ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def firstLetterWord ( str1 ) : NEW_LINE INDENT result = " " NEW_LINE v = True NEW_LINE for i in range ( len ( str1 ) ) : NEW_LINE INDENT if ( str1 [ i ] == ' ▁ ' ) : NEW_LINE INDENT v = True NEW_LINE DEDENT elif ( str1 [ i ] != ' ▁ ' and v == True ) : NEW_LINE INDENT result = result + ( str1 [ i ] ) NEW_LINE v = False NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def decode ( str1 ) : NEW_LINE INDENT integerstack = [ 0 ] * 10 NEW_LINE stringstack = [ ] NEW_LINE temp = " " NEW_LINE count = 0 NEW_LINE if ( ord ( str1 [ i ] ) == ord ( str1 [ i ] ) ) : NEW_LINE INDENT count = count * 10 + ord ( str1 [ i ] ) - ord ( '0' ) NEW_LINE i += 1 NEW_LINE DEDENT elif ( ord ( str1 [ i ] ) == ord ( ' [ ' ) ) : NEW_LINE INDENT temp = " " NEW_LINE count = 0 NEW_LINE if ( not integerstack . empty ( ) and stringstack . peek ( ) != ' [ ' ) : NEW_LINE INDENT temp = stringstack [ 0 ] + temp NEW_LINE stringstack . pop ( ) NEW_LINE DEDENT if ( not stringstack . empty ( ) and stringstack [ 0 ] == ' [ ' ) : NEW_LINE INDENT result = result + temp NEW_LINE for j in range ( count ) : NEW_LINE INDENT result = result + result [ j ] NEW_LINE DEDENT result = " " NEW_LINE DEDENT elif ( str1 [ i ] == ' [ ' ) : NEW_LINE INDENT stringstack . append ( str1 [ i ] ) NEW_LINE integerstack . append ( 1 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT stringstack . append ( str1 [ i ] ) NEW_LINE DEDENT DEDENT
def minSum ( A , n ) : NEW_LINE INDENT min_val = min ( A ) NEW_LINE return ( min_val * ( n - 1 ) ) NEW_LINE DEDENT
def countWords ( str , n ) : NEW_LINE INDENT m = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( m . get ( str [ i ] ) ) : NEW_LINE INDENT get = m [ str [ i ] ] NEW_LINE m [ str [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT m [ str [ i ] ] = 1 NEW_LINE DEDENT DEDENT res = 0 NEW_LINE for it in range ( m . keys ( ) ) : NEW_LINE INDENT if ( it . getValue ( ) == 2 ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def sortUsingHash ( a , n ) : NEW_LINE INDENT max = max ( a ) NEW_LINE hash = ( max + 1 ) * [ 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT hash [ a [ i ] ] += 1 NEW_LINE DEDENT for i in range ( max + 1 ) : NEW_LINE INDENT if ( hash [ i ] != 0 ) : NEW_LINE INDENT for j in range ( hash [ i ] ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
def isDivisible ( str , k ) : NEW_LINE INDENT n = len ( str ) NEW_LINE c = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT if ( str [ n - i - 1 ] == '0' ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT return ( c == k ) NEW_LINE DEDENT
def divisible ( num ) : NEW_LINE INDENT n = len ( num ) NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += ord ( num [ i ] ) NEW_LINE DEDENT if ( sum % 3 == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( sum % 3 == ( num [ i ] - '0' ) % 3 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n == 2 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return 2 NEW_LINE DEDENT
def reverse ( str ) : NEW_LINE INDENT if ( ( str == null ) or ( len ( str ) <= 1 ) ) : NEW_LINE INDENT print ( str ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( str [ 0 : len ( str ) - 1 ] ) NEW_LINE reverse ( str [ 0 : len ( str ) - 1 ] ) NEW_LINE DEDENT DEDENT
def isDvisibleBy12 ( num ) : NEW_LINE INDENT if ( len ( num ) >= 3 ) : NEW_LINE INDENT d1 = ( int ) num [ len ( num ) - 1 ] NEW_LINE if ( d1 % 2 != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT d2 = ( int ) num [ len ( num ) - 2 ] NEW_LINE sum = 0 NEW_LINE for i in range ( len ( num ) ) : NEW_LINE INDENT sum += num [ i ] NEW_LINE DEDENT return ( sum % 3 == 0 and ( d2 * 10 + d1 ) % 4 == 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT number = int ( num ) NEW_LINE return ( number % 12 == 0 ) NEW_LINE DEDENT DEDENT
def xorZero ( s ) : NEW_LINE INDENT one_count = 0 NEW_LINE zero_count = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT one_count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT zero_count += 1 NEW_LINE DEDENT DEDENT if ( one_count % 2 == 0 ) : NEW_LINE INDENT return zero_count NEW_LINE DEDENT return one_count NEW_LINE DEDENT
def nthRoot ( A , N ) : NEW_LINE INDENT xPre = random ( ) % 10 NEW_LINE eps = 0.001 NEW_LINE delX = 2147483647 NEW_LINE xK = 0.0 NEW_LINE while ( delX > eps ) : NEW_LINE INDENT xK = ( ( N - 1.0 ) * xPre + ( double ) A / math . pow ( xPre , N - 1 ) ) / ( double ) N NEW_LINE delX = abs ( xK - xPre ) NEW_LINE xPre = xK NEW_LINE DEDENT return xK NEW_LINE DEDENT
def findLeft ( str1 ) : NEW_LINE INDENT n = len ( str1 ) NEW_LINE while ( n > 0 ) : NEW_LINE INDENT n -= 1 NEW_LINE if ( str1 [ n ] == ' d ' ) : NEW_LINE INDENT str1 [ n ] = ' c ' NEW_LINE break NEW_LINE DEDENT if ( str1 [ n ] == ' b ' ) : NEW_LINE INDENT str1 [ n ] = ' a ' NEW_LINE break NEW_LINE DEDENT if ( str1 [ n ] == ' a ' ) : NEW_LINE INDENT str1 [ n ] = ' b ' NEW_LINE DEDENT elif ( str1 [ n ] == ' c ' ) : NEW_LINE INDENT str1 [ n ] = ' d ' NEW_LINE DEDENT DEDENT return str1 NEW_LINE DEDENT
def minRange ( arr , n , k ) : NEW_LINE INDENT l = 0 NEW_LINE r = n NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = Set ( ) NEW_LINE j = i NEW_LINE for j in range ( n ) : NEW_LINE INDENT s . add ( arr [ j ] ) NEW_LINE if ( s . size ( ) == k ) : NEW_LINE INDENT if ( ( j - i ) < ( r - l ) ) : NEW_LINE INDENT r = j NEW_LINE l = i NEW_LINE DEDENT break NEW_LINE DEDENT DEDENT if ( j == n ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( l == 0 and r == n ) : NEW_LINE INDENT print ( " Invalid ▁ k " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( l + " ▁ " , r ) NEW_LINE DEDENT DEDENT
def findSum ( A , B , n ) : NEW_LINE INDENT hash = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if hash . get ( A [ i ] ) : NEW_LINE INDENT hash [ A [ i ] ] = 1 + hash [ A [ i ] ] NEW_LINE DEDENT else : NEW_LINE INDENT hash [ A [ i ] ] = 1 NEW_LINE DEDENT DEDENT sum = 0 NEW_LINE for entry in hash . keys ( ) : NEW_LINE INDENT if hash . get ( B [ i ] ) : NEW_LINE INDENT hash [ B [ i ] ] = 1 + hash [ B [ i ] ] NEW_LINE DEDENT else : NEW_LINE INDENT hash [ B [ i ] ] = 1 NEW_LINE DEDENT DEDENT sum += 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT
def arrayEvenAndOdd ( arr , n ) : NEW_LINE INDENT i , j = - 1 , 0 NEW_LINE while ( j != n ) : NEW_LINE INDENT if ( arr [ j ] % 2 == 0 ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT arr [ i ] = arr [ j ] NEW_LINE arr [ j ] = arr [ i ] NEW_LINE arr [ i ] = arr [ j ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT for k in range ( n ) : NEW_LINE INDENT print ( arr [ k ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def containsOdd ( G , src ) : NEW_LINE INDENT colorArr = [ 0 for i in range ( V + 1 ) ] NEW_LINE for i in range ( V ) : NEW_LINE INDENT colorArr [ i ] = - 1 NEW_LINE DEDENT colorArr [ src ] = 1 NEW_LINE q = [ src ] NEW_LINE while ( not q . empty ( ) ) : NEW_LINE INDENT u = q [ 0 ] NEW_LINE q . remove ( q [ 0 ] ) NEW_LINE if ( G [ u ] [ u ] == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT for v in range ( V ) : NEW_LINE INDENT if ( G [ u ] [ v ] == 1 and colorArr [ v ] == - 1 ) : NEW_LINE INDENT colorArr [ v ] = 1 - colorArr [ u ] NEW_LINE q . append ( v ) NEW_LINE DEDENT elif ( G [ u ] [ v ] == 1 and colorArr [ v ] == colorArr [ u ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT
def getMinSquares ( n ) : NEW_LINE INDENT if ( n <= 3 ) : NEW_LINE INDENT return n NEW_LINE DEDENT res = n NEW_LINE x = 1 NEW_LINE while ( x <= n ) : NEW_LINE INDENT temp = x * x NEW_LINE if ( temp > n ) : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT res = min ( res , 1 + getMinSquares ( n - temp ) ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def selectRandom ( x ) : NEW_LINE INDENT count += 1 NEW_LINE if ( count == 1 ) : NEW_LINE INDENT res = x NEW_LINE DEDENT else : NEW_LINE INDENT r = new Random ( ) NEW_LINE i = r . nextInt ( count ) NEW_LINE if ( i == count - 1 ) : NEW_LINE INDENT res = x NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def cost ( a , n ) : NEW_LINE INDENT min = a [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( a [ i ] < min ) : NEW_LINE INDENT min = a [ i ] NEW_LINE DEDENT DEDENT return ( n - 1 ) * min NEW_LINE DEDENT
def gnomeSort ( arr , n ) : NEW_LINE INDENT index = 0 NEW_LINE while ( index < n ) : NEW_LINE INDENT if ( index == 0 ) : NEW_LINE INDENT index += 1 NEW_LINE DEDENT if ( arr [ index ] >= arr [ index - 1 ] ) : NEW_LINE INDENT index += 1 NEW_LINE DEDENT else : NEW_LINE INDENT temp = 0 NEW_LINE arr [ index ] = arr [ index - 1 ] NEW_LINE arr [ index - 1 ] = arr [ index - 1 ] NEW_LINE index -= 1 NEW_LINE DEDENT DEDENT return NEW_LINE DEDENT
def sortedAfterSwap ( A , B , n ) : NEW_LINE INDENT t = 0 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( B [ i ] != 0 ) : NEW_LINE INDENT if ( A [ i ] != i + 1 ) : NEW_LINE INDENT t = A [ i ] NEW_LINE DEDENT A [ i ] = A [ i + 1 ] NEW_LINE A [ i + 1 ] = t NEW_LINE DEDENT DEDENT for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( A [ i ] != i + 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT
def moveSpaceInFront ( st , n ) : NEW_LINE INDENT i = n - 1 NEW_LINE j = i - 1 NEW_LINE while ( j >= 0 ) : NEW_LINE INDENT if ( st [ j ] != ' ▁ ' ) : NEW_LINE INDENT str [ i - ] = st [ j ] NEW_LINE DEDENT j -= 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT str [ i - ] = ' ▁ ' NEW_LINE DEDENT DEDENT
def countOfBinaryNumberLessThanN ( N ) : NEW_LINE INDENT q = Queue ( ) NEW_LINE q . put ( 1 ) NEW_LINE cnt = 0 NEW_LINE while ( not q . empty ( ) ) : NEW_LINE INDENT t = q [ 0 ] NEW_LINE q . get ( ) NEW_LINE if ( t <= N ) : NEW_LINE INDENT cnt += 1 NEW_LINE q . put ( t * 10 ) NEW_LINE q . put ( t * 10 + 1 ) NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT
def substringConversions ( str , k , b ) : NEW_LINE INDENT i = 0 NEW_LINE sum = 0 NEW_LINE counter = k - 1 NEW_LINE for i in range ( 0 , k ) : NEW_LINE INDENT sum = ( int ) ( sum + ( ( str [ i ] - '0' ) * math . pow ( b , counter ) ) ) NEW_LINE counter -= 1 NEW_LINE DEDENT print ( sum , end = " ▁ " ) NEW_LINE prev = sum NEW_LINE sum = 0 NEW_LINE counter = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT sum = ( prev - ( ( str [ i - k ] - '0' ) * math . pow ( b , k - 1 ) ) ) NEW_LINE Sum = sum * b NEW_LINE Sum = sum + ( str [ i ] - '0' ) NEW_LINE DEDENT print ( sum , end = " ▁ " ) NEW_LINE prev = sum NEW_LINE counter += 1 NEW_LINE DEDENT DEDENT
def longestRepeatedSubSeq ( str1 ) : NEW_LINE INDENT n = len ( str1 ) NEW_LINE dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( str1 [ i - 1 ] == str1 [ j - 1 ] and i != j ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT res = " " NEW_LINE i = n NEW_LINE j = n NEW_LINE while ( i > 0 and j > 0 ) : NEW_LINE INDENT if ( dp [ i ] [ j ] == dp [ i - 1 ] [ j - 1 ] + 1 ) : NEW_LINE INDENT res = res + str1 [ i - 1 ] NEW_LINE i -= 1 NEW_LINE j -= 1 NEW_LINE DEDENT elif ( dp [ i ] [ j ] == dp [ i - 1 ] [ j ] ) : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT DEDENT reverse = " " NEW_LINE for k in range ( len ( res ) - 1 , - 1 ) : NEW_LINE INDENT reverse = reverse + res [ k ] NEW_LINE DEDENT return reverse NEW_LINE DEDENT
def rearrange ( a , size ) : NEW_LINE INDENT positive = 0 NEW_LINE negative = 1 NEW_LINE while ( positive < size and a [ positive ] >= 0 ) : NEW_LINE INDENT positive += 2 NEW_LINE DEDENT while ( negative < size and a [ negative ] <= 0 ) : NEW_LINE INDENT negative += 2 NEW_LINE DEDENT if ( positive < size and negative < size ) : NEW_LINE INDENT temp = a [ positive ] NEW_LINE a [ positive ] = a [ negative ] NEW_LINE a [ negative ] = temp NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT
def bubbleSort ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT for j in range ( 0 , n - i - 1 ) : NEW_LINE INDENT if arr [ j ] > arr [ j + 1 ] : NEW_LINE INDENT arr [ j ] , arr [ j + 1 ] = arr [ j + 1 ] , arr [ j ] NEW_LINE DEDENT DEDENT DEDENT
def reversingString ( str , start , end ) : NEW_LINE INDENT while ( start < end ) : NEW_LINE INDENT str [ start ] ^= str [ end ] NEW_LINE str [ end ] ^= str [ start ] NEW_LINE str [ start ] ^= str [ end ] NEW_LINE start += 1 NEW_LINE -- end NEW_LINE DEDENT return ' ' . join ( str ) NEW_LINE DEDENT
def minimalSteps ( s , n ) : NEW_LINE INDENT dp = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp [ i ] = + 2147483647 NEW_LINE s1 = " " NEW_LINE s2 = " " NEW_LINE dp [ 0 ] = 1 NEW_LINE s1 += s [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT s1 += s [ i ] NEW_LINE s2 = s [ i + 1 : i + 1 ] NEW_LINE DEDENT dp [ i ] = min ( dp [ i ] , dp [ i - 1 ] + 1 ) NEW_LINE if ( s1 == s2 ) : NEW_LINE INDENT dp [ i * 2 + 1 ] = min ( dp [ i ] + 1 , dp [ i * 2 + 1 ] ) NEW_LINE DEDENT DEDENT return dp [ n - 1 ] NEW_LINE DEDENT
def MinimumCost ( cost , n , W ) : NEW_LINE INDENT val = [ 0 ] * ( n + 1 ) NEW_LINE wt = [ 0 ] * ( W + 1 ) NEW_LINE size = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( cost [ i ] != - 1 ) : NEW_LINE INDENT val . append ( cost [ i ] ) NEW_LINE wt . append ( i + 1 ) NEW_LINE size += 1 NEW_LINE DEDENT DEDENT min_cost = [ [ 0 for i in range ( 1 , n + 1 ) ] NEW_LINE for i in range ( 1 , W + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( wt [ i - 1 ] > j ) : NEW_LINE INDENT min_cost [ i ] [ j ] = min_cost [ i - 1 ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT min_cost [ i ] [ j ] = min ( min_cost [ i - 1 ] [ j ] , min_cost [ i ] [ j - wt . get ( i - 1 ) ] + val [ i - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return ( min_cost [ n ] [ W ] == - 1 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT
def bitonicGenerator ( arr , n ) : NEW_LINE INDENT evenArr = [ ] NEW_LINE oddArr = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i % 2 != 1 ) : NEW_LINE INDENT evenArr . append ( arr [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT oddArr . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT sort ( evenArr ) NEW_LINE for j in range ( len ( oddArr ) ) : NEW_LINE INDENT arr [ i ] = evenArr [ j ] NEW_LINE DEDENT for j in range ( len ( oddArr ) ) : NEW_LINE INDENT arr [ i ] = oddArr [ j ] NEW_LINE i += 1 NEW_LINE DEDENT DEDENT
def printFirstRepeating ( arr ) : NEW_LINE INDENT min = - 1 NEW_LINE set = Set ( ) NEW_LINE for i in range ( 0 , arr . length - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] in set ) : NEW_LINE INDENT min = i NEW_LINE DEDENT else : NEW_LINE INDENT set . add ( arr [ i ] ) NEW_LINE DEDENT DEDENT if ( min != - 1 ) : NEW_LINE INDENT print ( " The ▁ first ▁ repeating ▁ element ▁ is " , arr [ min ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " There ▁ are ▁ no ▁ repeating ▁ elements " ) NEW_LINE DEDENT DEDENT
def lps ( seq ) : NEW_LINE INDENT n = len ( seq ) NEW_LINE L = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT L [ i ] [ i ] = 1 NEW_LINE DEDENT for cl in range ( 2 , n + 1 ) : NEW_LINE INDENT for i in range ( n - cl + 1 ) : NEW_LINE INDENT j = i + cl - 1 NEW_LINE if ( seq [ i ] == seq [ j ] and cl == 2 ) : NEW_LINE INDENT L [ i ] [ j ] = 2 NEW_LINE DEDENT elif ( seq [ i ] == seq [ j ] ) : NEW_LINE INDENT L [ i ] [ j ] = L [ i + 1 ] [ j - 1 ] + 2 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] = max ( L [ i ] [ j - 1 ] , L [ i + 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return L [ 0 ] [ n - 1 ] NEW_LINE DEDENT
def censor ( text , word ) : NEW_LINE INDENT word_list = word . split ( " \\s + " ) NEW_LINE result = " " NEW_LINE stars = " " NEW_LINE for i in range ( len ( word ) ) : NEW_LINE INDENT stars += ' * ' NEW_LINE DEDENT index = 0 NEW_LINE for i in range ( len ( word_list ) ) : NEW_LINE INDENT if ( i . compareTo ( word ) == 0 ) : NEW_LINE INDENT word_list [ index ] = stars NEW_LINE index += 1 NEW_LINE DEDENT DEDENT for i in range ( word_list ) : NEW_LINE INDENT result = result + i + ' ▁ ' NEW_LINE DEDENT return result NEW_LINE DEDENT
def isRotated ( str1 , str2 ) : NEW_LINE INDENT if ( len ( str1 ) != len ( str2 ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT clock_rot = " " NEW_LINE anticlock_rot = " " NEW_LINE len = len ( str2 ) NEW_LINE anticlock_rot = anticlock_rot + str2 [ ( len - 2 , len ) + str2 [ 0 : len - 2 ] NEW_LINE clock_rot = clock_rot + str2 [ 2 ] + str2 [ 0 : 2 ] NEW_LINE return ( str1 . equals ( clock_rot ) or str1 . equals ( anticlock_rot ) ) NEW_LINE DEDENT
def findDiff ( arr , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if mp . get ( arr [ i ] ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT max_count = 0 NEW_LINE min_count = n NEW_LINE for x in mp : NEW_LINE INDENT max_count = max ( max_count , x . getValue ( ) ) NEW_LINE min_count = min ( min_count , x . getValue ( ) ) NEW_LINE DEDENT return ( max_count - min_count ) NEW_LINE DEDENT
def playGame ( arr ) : NEW_LINE INDENT sett = Set ( ) NEW_LINE for i in arr : NEW_LINE INDENT sett . add ( i ) NEW_LINE DEDENT return ( len ( sett ) % 2 == 0 ) ? 1 : 2 NEW_LINE DEDENT
def subset ( arr , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] = mp [ arr [ i ] ] + 1 NEW_LINE DEDENT res = 0 NEW_LINE for entry in mp . entrySet ( ) : NEW_LINE INDENT res = max ( res , entry . getValue ( ) ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def isProduct ( arr , n , x ) : NEW_LINE INDENT s = Set ( ) NEW_LINE if ( n < 2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] == 0 ) : NEW_LINE INDENT if ( x == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT continue NEW_LINE DEDENT DEDENT if ( x % arr [ i ] == 0 ) : NEW_LINE INDENT if ( s . add ( x // arr [ i ] ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT s . add ( arr [ i ] ) NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def findRotations ( str ) : NEW_LINE INDENT tmp = str + str NEW_LINE n = len ( str ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT substring = tmp [ i : ] NEW_LINE if ( str == substring ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return n NEW_LINE DEDENT
def randomize ( arr , n ) : NEW_LINE INDENT r = new Random ( ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT j = r . nextInt ( i + 1 ) NEW_LINE arr [ i ] = arr [ j ] NEW_LINE arr [ j ] = temp NEW_LINE DEDENT print ( arr ) NEW_LINE DEDENT
def translate ( st ) : NEW_LINE INDENT lenn = len ( st ) NEW_LINE if ( lenn < 2 ) : NEW_LINE INDENT return None NEW_LINE DEDENT i = 0 NEW_LINE j = 0 NEW_LINE while ( j < len - 1 ) : NEW_LINE INDENT if ( st [ j ] == ' A ' and st [ j + 1 ] == ' B ' ) : NEW_LINE INDENT j = j + 2 NEW_LINE str [ i ] = ' C ' NEW_LINE continue NEW_LINE DEDENT DEDENT if ( j == len - 1 ) : NEW_LINE INDENT str [ i ] = st [ j ] NEW_LINE i += 1 NEW_LINE DEDENT str [ i ] = ' ▁ ' NEW_LINE str [ len - 1 ] = ' ▁ ' NEW_LINE DEDENT DEDENT
def numberofways ( A , B , N , M ) : NEW_LINE INDENT pos = [ [ 0 for i in range ( MAX ) ] for j in range ( M ) ] NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT for j in range ( 1 , M + 1 ) : NEW_LINE INDENT if ( A [ i - 1 ] == B [ j - 1 ] ) : NEW_LINE INDENT dpl [ i ] [ j ] = max ( dpl [ i - 1 ] [ j ] , dpl [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT LCS = dpl [ N ] [ M ] NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT for j in range ( 1 , M + 1 ) : NEW_LINE INDENT if ( A [ i - 1 ] == B [ j - 1 ] ) : NEW_LINE INDENT dpr [ i ] [ j ] = dpr [ i + 1 ] [ j + 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT dpr [ i ] [ j ] = max ( dpr [ i + 1 ] [ j ] , dpr [ i ] [ j + 1 ] ) NEW_LINE DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT for j in range ( MAX ) : NEW_LINE INDENT if ( dpl [ i ] [ x - 1 ] + dpr [ i + 1 ] [ x + 1 ] == LCS ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def substringConversions ( str , k , b ) : NEW_LINE INDENT for i in range ( len ( str ) - k + 1 ) : NEW_LINE INDENT sub = str [ i : i + k ] NEW_LINE sum = 0 NEW_LINE counter = 0 NEW_LINE for j in range ( len ( sub ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT sum = sum + ( ( sub [ j ] - '0' ) * pow ( b , counter ) ) NEW_LINE counter += 1 NEW_LINE DEDENT print ( sum , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def SumOfKsubArray ( arr , k ) : NEW_LINE INDENT sum = 0 NEW_LINE S = [ ] NEW_LINE G = [ ] NEW_LINE i = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT while ( not S . empty ( ) and arr [ S . peekLast ( ) ] >= arr [ i ] ) : NEW_LINE INDENT S . removeLast ( ) NEW_LINE DEDENT while ( not G . empty ( ) and arr [ G . peekLast ( ) ] <= arr [ i ] ) : NEW_LINE INDENT G . removeLast ( ) NEW_LINE DEDENT S . append ( arr [ S . peekFirst ( ) ] + arr [ G . peekFirst ( ) ] NEW_LINE while ( not S . empty ( ) and arr [ S . peekLast ( ) ] >= arr [ i ] ) : NEW_LINE INDENT S . removeLast ( ) NEW_LINE DEDENT while ( not G . empty ( ) and arr [ G . peekLast ( ) ] <= arr [ i ] ) : NEW_LINE INDENT G . removeLast ( ) NEW_LINE DEDENT G . append ( i ) NEW_LINE S . append ( i ) NEW_LINE DEDENT DEDENT sum += arr [ S . peekFirst ( ) ] + arr [ G . peekFirst ( ) ] NEW_LINE return sum NEW_LINE DEDENT
def arrangeString ( str ) : NEW_LINE INDENT global MAX_CHAR NEW_LINE char_count = [ 0 ] * MAX_CHAR NEW_LINE sum = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( Character . isUpperCase ( str [ i ] ) ) : NEW_LINE INDENT char_count [ ord ( str [ i ] ) - ord ( ' A ' ) ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT sum = sum + ord ( str [ i ] - ord ( ' 0' ) ) NEW_LINE DEDENT DEDENT res = " " NEW_LINE for i in range ( MAX_CHAR ) : NEW_LINE INDENT ch = ord ( ' A ' + i ) NEW_LINE while ( char_count [ i ] -= 1 ) : NEW_LINE INDENT res = res + chr ( ord ( ch ) - ord ( ' A ' ) ) NEW_LINE DEDENT if ( sum > 0 ) : NEW_LINE INDENT res = res + sum NEW_LINE DEDENT return res NEW_LINE DEDENT
def waysToIncreaseLCSBy1 ( str1 , str2 ) : NEW_LINE INDENT m = len ( str1 ) NEW_LINE n = len ( str2 ) NEW_LINE position = [ [ 0 for i in range ( M + 1 ) ] for j in range ( n + 2 ) ] NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( str1 [ i - 1 ] == str2 [ j - 1 ] ) : NEW_LINE INDENT lcsl [ i ] [ j ] = 1 + lcsl [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT lcsl [ i ] [ j ] = max ( lcsl [ i - 1 ] [ j ] , lcsl [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( str1 [ i - 1 ] == str2 [ j - 1 ] ) : NEW_LINE INDENT lcsl [ i ] [ j ] = 1 + lcsl [ i + 1 ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT lcsr [ i ] [ j ] = max ( lcsr [ i + 1 ] [ j ] , lcsr [ i ] [ j + 1 ] ) NEW_LINE DEDENT DEDENT DEDENT ways = 0 NEW_LINE for i in range ( 26 , m + 1 ) : NEW_LINE INDENT for j in range ( 1 , m + 1 ) : NEW_LINE INDENT if ( lcsr [ i ] [ j ] == lcsr [ i + 1 ] [ j ] , lcsr [ i ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT
def lis ( arr , n ) : NEW_LINE INDENT lis = [ 0 ] * n NEW_LINE max = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT lis [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and lis [ i ] < lis [ j ] + 1 ) : NEW_LINE INDENT lis [ i ] = lis [ j ] + 1 NEW_LINE DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( max < lis [ i ] ) : NEW_LINE INDENT max = lis [ i ] NEW_LINE DEDENT DEDENT return max NEW_LINE DEDENT
def SternSequenceFunc ( BrocotSequence , n ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT considered_element = BrocotSequence [ i ] NEW_LINE precedent = BrocotSequence [ i - 1 ] NEW_LINE BrocotSequence . append ( considered_element + precedent ) NEW_LINE BrocotSequence . append ( considered_element ) NEW_LINE DEDENT for i in range ( 15 ) : NEW_LINE INDENT print ( BrocotSequence [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def printBracketNumber ( exp , n ) : NEW_LINE INDENT left_bnum = 1 NEW_LINE right_bnum = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( exp [ i ] == ' ( ' ) : NEW_LINE INDENT print ( left_bnum , end = " ▁ " ) NEW_LINE right_bnum . append ( left_bnum ) NEW_LINE left_bnum += 1 NEW_LINE DEDENT elif ( exp [ i ] == ' ( ' ) : NEW_LINE INDENT print ( right_bnum [ - 1 ] , end = " ▁ " ) NEW_LINE right_bnum . pop ( ) NEW_LINE DEDENT DEDENT DEDENT
def returnMaxSum ( A , B , n ) : NEW_LINE INDENT mp = Set ( ) NEW_LINE result = 0 NEW_LINE curr_sum = 0 NEW_LINE curr_begin = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT while ( A [ i ] in mp ) : NEW_LINE INDENT mp . remove ( A [ curr_begin ] ) NEW_LINE curr_sum -= B [ curr_begin ] NEW_LINE curr_begin += 1 NEW_LINE DEDENT mp . add ( A [ i ] ) NEW_LINE curr_sum += B [ i ] NEW_LINE result = max ( result , curr_sum ) NEW_LINE DEDENT return result NEW_LINE DEDENT
def rearrange ( arr , n ) : NEW_LINE INDENT i = - 1 NEW_LINE temp = 0 NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT if arr [ j ] < 0 : NEW_LINE INDENT i += 1 NEW_LINE arr [ i ] = arr [ j ] NEW_LINE arr [ j ] = temp NEW_LINE DEDENT DEDENT pos = i + 1 NEW_LINE neg = 0 NEW_LINE while ( pos < n and neg < pos and arr [ neg ] < 0 ) : NEW_LINE INDENT temp = arr [ neg ] NEW_LINE arr [ neg ] = arr [ pos ] NEW_LINE arr [ pos ] = arr [ pos ] NEW_LINE pos += 1 NEW_LINE neg += 2 NEW_LINE DEDENT DEDENT
def largestGCDSubsequence ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE maxele = max ( arr ) NEW_LINE for i in range ( 2 , maxele + 1 ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ j ] % i == 0 ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT ans = max ( ans , count ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def isNumber ( s ) : NEW_LINE INDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if ( ord ( s [ i ] ) == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def countPairs ( arr1 , arr2 , m , n , x ) : NEW_LINE INDENT count = 0 NEW_LINE us = Set ( ) NEW_LINE for i in range ( 0 , m ) : NEW_LINE INDENT us . add ( arr1 [ i ] ) NEW_LINE DEDENT for j in range ( 0 , n ) : NEW_LINE INDENT if ( us . contains ( x - arr2 [ j ] ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def lis ( arr , n ) : NEW_LINE INDENT lis = [ 0 ] * n NEW_LINE max = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT lis [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and lis [ i ] < lis [ j ] + 1 ) : NEW_LINE INDENT lis [ i ] = lis [ j ] + 1 NEW_LINE DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( max < lis [ i ] ) : NEW_LINE INDENT max = lis [ i ] NEW_LINE DEDENT DEDENT return max NEW_LINE DEDENT
def findSubString ( str1 ) : NEW_LINE INDENT n = len ( str1 ) NEW_LINE dist_count = 0 NEW_LINE visited = [ False for i in range ( MAX_CHARS ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( visited [ ord ( str1 [ i ] ) ] == False ) : NEW_LINE INDENT visited [ ord ( str1 [ i ] ) ] = True NEW_LINE DEDENT dist_count += 1 NEW_LINE DEDENT for j in range ( n ) : NEW_LINE INDENT curr_count [ ord ( str1 [ j ] ) ] += 1 NEW_LINE if ( curr_count [ ord ( str1 [ j ] ) ] == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( count == dist_count ) : NEW_LINE INDENT while ( curr_count [ ord ( str1 [ start ] ) ] > 1 ) : NEW_LINE INDENT if ( curr_count [ ord ( str1 [ start ] ) ] > 1 ) : NEW_LINE INDENT curr_count [ ord ( str1 [ start ] ) ] -= 1 NEW_LINE start += 1 NEW_LINE DEDENT DEDENT len_window = j - start + 1 NEW_LINE if ( min_len > len_window ) : NEW_LINE INDENT min_len = len_window NEW_LINE start_index = start NEW_LINE DEDENT DEDENT return str1 [ start_index ]
def printSubsequences ( n ) : NEW_LINE INDENT opsize = ( int ) ( math . pow ( 2 , n ) ) NEW_LINE counter = 1 NEW_LINE for counter in range ( 1 , opsize ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT if ( BigInteger . valueOf ( counter ) . testBit ( j ) ) : NEW_LINE INDENT print ( arr [ j ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT
def bin ( n ) : NEW_LINE INDENT if ( n > 1 ) : NEW_LINE INDENT bin ( n > > 1 ) NEW_LINE DEDENT print ( " % d " , n & 1 ) NEW_LINE DEDENT
def minimumSquare ( a , b ) : NEW_LINE INDENT result = 0 NEW_LINE rem = 0 NEW_LINE if ( a < b ) : NEW_LINE INDENT swap ( a , b ) NEW_LINE DEDENT while ( b > 0 ) : NEW_LINE INDENT result += a // b NEW_LINE rem = a % b NEW_LINE a = b NEW_LINE b = rem NEW_LINE DEDENT return result NEW_LINE DEDENT
def deleteElements ( arr , n , k ) : NEW_LINE INDENT s = [ ] NEW_LINE s . append ( arr [ 0 ] ) NEW_LINE count = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT while ( len ( s ) > 0 and s [ - 1 ] < arr [ i ] and count < k ) : NEW_LINE INDENT s . pop ( ) NEW_LINE count += 1 NEW_LINE DEDENT s . append ( arr [ i ] ) NEW_LINE DEDENT m = len ( s ) NEW_LINE v = [ 0 ] * m NEW_LINE while ( len ( s ) > 0 ) : NEW_LINE INDENT v [ -- m ] = s [ - 1 ] NEW_LINE s . pop ( ) NEW_LINE DEDENT for x in range ( v ) : NEW_LINE INDENT print ( x , end = " ▁ " ) NEW_LINE DEDENT DEDENT print ( " " ) NEW_LINE DEDENT
def first ( str ) : NEW_LINE INDENT for i in string : NEW_LINE INDENT if ( Character . isUpperCase ( str [ i ] ) ) : NEW_LINE INDENT return str [ i ] NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT
def isPossible ( n , index , modulo , M , arr , dp ) : NEW_LINE INDENT modulo = ( ( modulo % M ) + M ) % M NEW_LINE if ( index == n ) : NEW_LINE INDENT if ( modulo == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT if ( dp [ index ] [ modulo ] != - 1 ) : NEW_LINE INDENT return dp [ index ] [ modulo ] NEW_LINE DEDENT placeAdd = isPossible ( n , index + 1 , modulo + arr [ index ] , M , arr , dp ) NEW_LINE placeMinus = isPossible ( n , index + 1 , modulo - arr [ index ] , M , arr , dp ) NEW_LINE res = placeAdd NEW_LINE dp [ index ] [ modulo ] = res NEW_LINE DEDENT return res NEW_LINE DEDENT
def amendSentence ( sstr ) : NEW_LINE INDENT for i in range ( len ( sstr ) ) : NEW_LINE INDENT if str [ i ] >= ' A ' and str [ i ] <= ' Z ' : NEW_LINE INDENT str [ i ] = chr ( str [ i ] + 32 ) NEW_LINE if ( i != 0 ) : NEW_LINE INDENT print ( " ▁ " , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( str [ i ] ) NEW_LINE DEDENT DEDENT
def find ( a , b , k , n1 , n2 ) : NEW_LINE INDENT s = Set ( ) NEW_LINE for i in range ( n2 ) : NEW_LINE INDENT s . add ( b [ i ] ) NEW_LINE DEDENT missing = 0 NEW_LINE for i in range ( n1 ) : NEW_LINE INDENT if ( not s . contains ( a [ i ] ) ) : NEW_LINE INDENT missing += 1 NEW_LINE DEDENT if ( missing == k ) : NEW_LINE INDENT return a [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def countNumber ( n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 1 , 9 ) : NEW_LINE INDENT s = [ ] NEW_LINE if ( i <= n ) : NEW_LINE INDENT s . append ( i ) NEW_LINE result += 1 NEW_LINE DEDENT while ( not s . empty ( ) ) : NEW_LINE INDENT tp = s [ - 1 ] NEW_LINE s . pop ( ) NEW_LINE for j in range ( tp % 10 , 9 ) : NEW_LINE INDENT x = tp * 10 + j NEW_LINE if ( x <= n ) : NEW_LINE INDENT s . append ( x ) NEW_LINE result += 1 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
def getMaxOccuringChar ( str1 ) : NEW_LINE INDENT count = [ 0 ] * ASCII_SIZE NEW_LINE len = len ( str1 ) NEW_LINE for i in range ( len ) : NEW_LINE INDENT count [ ord ( str1 [ i ] ) ] += 1 NEW_LINE DEDENT max = - 1 NEW_LINE result = ' ▁ ' NEW_LINE for i in range ( len ) : NEW_LINE INDENT if ( max < count [ ord ( str1 [ i ] ) ] ) : NEW_LINE INDENT max = count [ ord ( str1 [ i ] ) ] NEW_LINE result = str1 [ i ] NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def getMinDiff ( arr , n , k ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = arr [ n - 1 ] - arr [ 0 ] NEW_LINE small = arr [ 0 ] + k NEW_LINE big = arr [ n - 1 ] - k NEW_LINE temp = 0 NEW_LINE if ( small > big ) : NEW_LINE INDENT temp = small NEW_LINE small = big NEW_LINE big = temp NEW_LINE DEDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT subtract = arr [ i ] - k NEW_LINE add = arr [ i ] + k NEW_LINE if ( subtract >= small or add <= big ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( big - subtract <= add - small ) : NEW_LINE INDENT small = subtract NEW_LINE DEDENT else : NEW_LINE INDENT big = add NEW_LINE DEDENT DEDENT return min ( ans , big - small ) NEW_LINE DEDENT
def printkthnode ( adj , wt , n , k ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT sort ( adj [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( adj [ i ] . size ( ) >= k ) : NEW_LINE INDENT print ( adj [ i ] [ adj [ i ] . size ( ) - k ] . second , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " - 1 " ) NEW_LINE DEDENT DEDENT DEDENT
def commonCharacters ( st , n ) : NEW_LINE INDENT prim = [ False ] * MAX_CHAR NEW_LINE sec = [ False ] * MAX_CHAR NEW_LINE for i in range ( n ) : NEW_LINE INDENT sec [ ord ( st [ i ] ) - ord ( ' a ' ) ] = True NEW_LINE DEDENT for j in range ( len ( st [ i ] ) ) : NEW_LINE INDENT if ( prim [ ord ( st [ i ] [ j ] ) - ord ( ' a ' ) ] ) : NEW_LINE INDENT sec [ ord ( st [ i ] [ j ] ) - ord ( ' a ' ) ] = True NEW_LINE DEDENT DEDENT print ( " ▁ " ) NEW_LINE DEDENT DEDENT
def canMakeStr2 ( str1 , str2 ) : NEW_LINE INDENT count = [ 0 ] * MAX NEW_LINE for i in range ( len ( str1 ) ) : NEW_LINE INDENT count [ ord ( str1 [ i ] ) ] += 1 NEW_LINE DEDENT str3 = str2 [ 0 ] NEW_LINE for i in range ( len ( str3 ) ) : NEW_LINE INDENT if ( count [ ord ( str3 [ i ] ) ] == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT count [ ord ( str4 [ i ] ) ] -= 1 NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def count ( a , b , m , n ) : NEW_LINE INDENT if ( ( m == 0 and n == 0 ) or n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( m == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( b [ n - 1 ] == a [ m - 1 ] ) : NEW_LINE INDENT return count ( a , b , m - 1 , n - 1 ) + count ( a , b , m - 1 , n ) NEW_LINE DEDENT else : NEW_LINE INDENT return count ( a , b , m - 1 , n ) NEW_LINE DEDENT DEDENT
def numofArray ( n , m ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( MAX + 1 ) ] for j in range ( MAX + 1 ) ] NEW_LINE mu = [ [ 0 for i in range ( MAX + 1 ) ] for j in range ( MAX + 1 ) ] NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT for j in range ( MAX ) : NEW_LINE INDENT dp [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , m + 1 ) : NEW_LINE INDENT dp [ 1 ] [ i ] = 1 NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , m + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = 0 NEW_LINE for x in range ( di [ j ] ) : NEW_LINE INDENT dp [ i ] [ j ] += dp [ i - 1 ] [ x ] NEW_LINE DEDENT for x in range ( mu [ j ] ) : NEW_LINE INDENT dp [ i ] [ j ] += dp [ i - 1 ] [ x ] NEW_LINE DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT ans += dp [ n ] [ i ] NEW_LINE di [ i ] . clear ( ) NEW_LINE mu [ i ] . clear ( ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def findSubarraySum ( arr , n ) : NEW_LINE INDENT res = 0 NEW_LINE m = dict ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT sum += arr [ j ] NEW_LINE if ( m . get ( sum ) ) : NEW_LINE INDENT m [ sum ] = m [ sum ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT m [ sum ] = 1 NEW_LINE DEDENT DEDENT for x in sorted ( m ) : NEW_LINE INDENT if ( x . getValue ( ) == 1 ) : NEW_LINE INDENT res += x . getKey ( ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def findpath ( graph , n ) : NEW_LINE INDENT numofadj = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT numofadj . append ( accumulate ( graph [ i ] , 0 ) ) NEW_LINE DEDENT startPoint = 0 NEW_LINE numofodd = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( numofadj [ i ] % 2 == 1 ) : NEW_LINE INDENT numofodd += 1 NEW_LINE startPoint = i NEW_LINE DEDENT DEDENT if ( numofodd > 2 ) : NEW_LINE INDENT print ( " No ▁ Solution " ) NEW_LINE return NEW_LINE DEDENT stack = [ ] NEW_LINE path = [ ] NEW_LINE cur = startPoint NEW_LINE while ( len ( stack ) != 0 or accumulate ( graph [ cur ] , 0 ) == 0 ) : NEW_LINE INDENT path . append ( cur ) NEW_LINE cur = stack . pop ( ) NEW_LINE DEDENT DEDENT for ele in range ( path ) : NEW_LINE INDENT print ( ele , end = " ▁ - > ▁ " ) NEW_LINE DEDENT print ( cur ) NEW_LINE DEDENT
def sumBetweenTwoKth ( arr , k1 , k2 ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE result = 0 NEW_LINE for i in range ( k1 , k2 - 1 ) : NEW_LINE INDENT result += arr [ i ] NEW_LINE DEDENT return result NEW_LINE DEDENT
def calculate ( a , n ) : NEW_LINE INDENT maximum = max ( a ) NEW_LINE frequency = ( maximum + 1 ) * [ 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT frequency [ a [ i ] ] += 1 NEW_LINE DEDENT answer = 0 NEW_LINE for i in range ( ( maximum ) + 1 ) : NEW_LINE INDENT answer = answer + frequency [ i ] * ( frequency [ i ] - 1 ) NEW_LINE DEDENT return answer // 2 NEW_LINE DEDENT
def sumNodes ( l ) : NEW_LINE INDENT leafNodeCount = ( int ) ( math . pow ( 2 , l - 1 ) ) NEW_LINE vec = [ [ 0 for i in range ( l + 1 ) ] for j in range ( l + 1 ) ] NEW_LINE for i in range ( 1 , leafNodeCount + 1 ) : NEW_LINE INDENT vec . append ( [ 0 for i in range ( l + 1 ) ] ) NEW_LINE DEDENT for i in range ( 1 , l + 1 ) : NEW_LINE INDENT vec [ l - 1 ] . append ( i ) NEW_LINE DEDENT for i in range ( l - 2 , - 1 , - 1 ) : NEW_LINE INDENT k = 0 NEW_LINE while ( k < len ( vec [ i + 1 ] ) - 1 ) : NEW_LINE INDENT vec [ i ] . append ( vec [ i + 1 ] [ k ] + vec [ i + 1 ] [ k + 1 ] ) NEW_LINE k += 2 NEW_LINE DEDENT DEDENT sum = 0 NEW_LINE for i in range ( l ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT sum += vec [ i ] [ j ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def encrypt ( text , s ) : NEW_LINE INDENT result = [ ] NEW_LINE for i in range ( len ( text ) ) : NEW_LINE INDENT if ( Character . isUpperCase ( text [ i ] ) ) : NEW_LINE INDENT ch = ( char ) ( ( ( int ) text [ i ] + s - 65 ) % 26 + 65 ) NEW_LINE result . append ( ch ) NEW_LINE DEDENT else : NEW_LINE INDENT ch = ( char ) ( ( ( int ) text [ i ] + s - 97 ) % 26 + 97 ) NEW_LINE result . append ( ch ) NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT return b NEW_LINE DEDENT if ( ( a | b ) & 1 ) == 0 : NEW_LINE INDENT return a NEW_LINE DEDENT k = 0 NEW_LINE while ( ( a | b ) & 1 ) == 0 : NEW_LINE INDENT a >>= 1 NEW_LINE b >>= 1 NEW_LINE DEDENT while ( ( a & 1 ) == 0 ) : NEW_LINE INDENT a >>= 1 NEW_LINE DEDENT while ( ( b & 1 ) == 0 ) : NEW_LINE INDENT b >>= 1 NEW_LINE DEDENT while ( a > b ) : NEW_LINE INDENT temp = a NEW_LINE a = b NEW_LINE b = temp NEW_LINE DEDENT b = ( b - a ) NEW_LINE DEDENT while ( b != 0 ) : NEW_LINE INDENT return a << k NEW_LINE DEDENT
def calculateSum ( arr , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT s = arr [ 0 ] NEW_LINE value = int ( s ) NEW_LINE sum = value NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT s = arr [ i ] NEW_LINE value = int ( s ) NEW_LINE operation = arr [ i - 1 ] [ 0 ] NEW_LINE if ( operation == ' + ' ) : NEW_LINE INDENT sum += value NEW_LINE DEDENT else : NEW_LINE INDENT sum -= value NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def replace ( s , c1 , c2 ) : NEW_LINE INDENT l = len ( s ) NEW_LINE arr = [ 0 ] * l NEW_LINE for i in range ( l ) : NEW_LINE INDENT if arr [ i ] == c1 : NEW_LINE INDENT arr [ i ] = c2 NEW_LINE DEDENT elif arr [ i ] == c2 : NEW_LINE INDENT arr [ i ] = c1 NEW_LINE DEDENT DEDENT return String ( arr ) NEW_LINE DEDENT
def lexicographicSubConcat ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE sub_count = int ( ( n + 1 ) / 2 ) NEW_LINE arr = [ " " ] * ( n + 1 ) / 2 NEW_LINE index = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for len in range ( 1 , n - i + 1 ) : NEW_LINE INDENT arr [ index ] = s [ i : i + len ] NEW_LINE DEDENT index += 1 NEW_LINE DEDENT arr . sort ( ) NEW_LINE res = " " NEW_LINE for i in range ( sub_count ) : NEW_LINE INDENT res = res + arr [ i ] NEW_LINE DEDENT return res NEW_LINE DEDENT
def findpos ( n ) : NEW_LINE INDENT k = 0 NEW_LINE pos = 0 NEW_LINE i = 0 NEW_LINE while ( k != len ( n ) ) : NEW_LINE INDENT switch ( n [ i ] ) : NEW_LINE INDENT pos = pos * 2 + 1 NEW_LINE break NEW_LINE DEDENT case '4' : NEW_LINE INDENT pos = pos * 2 + 2 NEW_LINE break NEW_LINE DEDENT case '7' : NEW_LINE INDENT pos = pos * 2 + 2 NEW_LINE break NEW_LINE DEDENT i += 1 NEW_LINE k += 1 NEW_LINE DEDENT return pos NEW_LINE DEDENT
def lis ( arr , n ) : NEW_LINE INDENT mpis = [ 0 ] * n NEW_LINE max = - float ( ' inf ' ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and mpis [ i ] < ( mpis [ j ] * arr [ i ] ) ) : NEW_LINE INDENT mpis [ i ] = mpis [ j ] * arr [ i ] NEW_LINE DEDENT DEDENT for k in range ( mpis . length ) : NEW_LINE INDENT if ( mpis [ k ] > max ) : NEW_LINE INDENT max = mpis [ k ] NEW_LINE DEDENT DEDENT DEDENT return max NEW_LINE DEDENT
def checkSorted ( q , n ) : NEW_LINE INDENT st = [ 0 ] * n NEW_LINE expected = 1 NEW_LINE while ( not q . empty ( ) ) : NEW_LINE INDENT fnt = q . get ( ) NEW_LINE if ( fnt == expected ) : NEW_LINE INDENT expected += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( len ( st ) == 0 ) : NEW_LINE INDENT st . append ( fnt ) NEW_LINE DEDENT elif ( len ( st ) != 0 and st [ 0 ] < fnt ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT st . append ( fnt ) NEW_LINE DEDENT DEDENT while len ( st ) != 0 and st [ - 1 ] == expected : NEW_LINE INDENT st . pop ( ) NEW_LINE expected += 1 NEW_LINE DEDENT DEDENT if ( expected - 1 == n and st . size ( ) == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def generate ( st , s ) : NEW_LINE INDENT if ( len ( s ) == 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( s in st ) : NEW_LINE INDENT return NEW_LINE DEDENT st . add ( s ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT t = s NEW_LINE t = t [ 0 : 0 + i ] + t [ i + 1 : ] NEW_LINE generate ( st , t ) NEW_LINE DEDENT DEDENT return NEW_LINE DEDENT
def minLexRotation ( string ) : NEW_LINE INDENT n = len ( string ) NEW_LINE arr = [ "" ] * ( n + 1 ) NEW_LINE concat = string + string NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr [ i ] = concat [ i : i + n ] NEW_LINE DEDENT arr . sort ( ) NEW_LINE return arr [ 0 ] NEW_LINE DEDENT
def isPossible ( a , b , n , k ) : NEW_LINE INDENT a . sort ( reverse = True ) NEW_LINE b . sort ( reverse = True ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] + b [ i ] < k ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def isCornerPresent ( str , corner ) : NEW_LINE INDENT n = len ( str ) NEW_LINE cl = len ( corner ) NEW_LINE if ( n < cl ) : NEW_LINE INDENT return False NEW_LINE DEDENT return ( str [ 0 : cl ] . equals ( corner ) and str [ n - cl : n ] . equals ( corner ) ) NEW_LINE DEDENT
def longDivision ( number , divisor ) : NEW_LINE INDENT ans = " " NEW_LINE idx = 0 NEW_LINE temp = num [ idx ] - '0' NEW_LINE while ( temp < divisor ) : NEW_LINE INDENT temp = temp * 10 + ( num [ idx ] - '0' ) NEW_LINE idx += 1 NEW_LINE while ( num . length > idx ) : NEW_LINE INDENT ans = ans + ( temp / divisor ) NEW_LINE temp = ( temp % divisor ) * 10 + num [ idx ] - '0' NEW_LINE DEDENT if ( len ( ans ) == 0 ) : NEW_LINE INDENT return "0" NEW_LINE DEDENT return ans NEW_LINE DEDENT
def sort012 ( a , arr_size ) : NEW_LINE INDENT lo = 0 NEW_LINE hi = arr_size - 1 NEW_LINE mid = 0 NEW_LINE temp = 0 NEW_LINE while ( mid <= hi ) : NEW_LINE INDENT switch ( a [ mid ] ) : NEW_LINE INDENT temp = a [ lo ] NEW_LINE a [ lo ] = a [ mid ] NEW_LINE a [ mid ] = temp NEW_LINE lo += 1 NEW_LINE mid += 1 NEW_LINE break NEW_LINE DEDENT case 0 : NEW_LINE INDENT temp = a [ mid ] NEW_LINE a [ mid ] = a [ hi ] NEW_LINE a [ hi ] = temp NEW_LINE hi -= 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT
def canRepresentBST ( pre , n ) : NEW_LINE INDENT s = [ ] NEW_LINE root = - float ( ' inf ' ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( pre [ i ] < root ) : NEW_LINE INDENT return False NEW_LINE DEDENT while len ( s ) > 0 : NEW_LINE INDENT root = s [ - 1 ] NEW_LINE s . pop ( ) NEW_LINE DEDENT DEDENT
def solveQuery ( start , end , arr ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( start , end + 1 ) : NEW_LINE INDENT mp [ arr [ i ] ] = mp [ arr [ i ] ] + 1 NEW_LINE DEDENT count = 0 NEW_LINE for entry in mp . entrySet ( ) : NEW_LINE INDENT if ( entry . getKey ( ) == entry . getValue ( ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def divisibleBy20 ( num ) : NEW_LINE INDENT lastTwoDigits = int ( num [ len ( num ) - 2 : ] ) NEW_LINE return ( ( lastTwoDigits % 5 == 0 ) and ( lastTwoDigits % 4 == 0 ) ) NEW_LINE DEDENT
def CountTriangles ( A ) : NEW_LINE INDENT n = len ( A ) NEW_LINE A . sort ( ) NEW_LINE count = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT l = 0 NEW_LINE r = i - 1 NEW_LINE while ( l < r ) : NEW_LINE INDENT if ( A [ l ] + A [ r ] > A [ i ] ) : NEW_LINE INDENT count += r - l NEW_LINE r -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT l += 1 NEW_LINE DEDENT DEDENT print ( " No ▁ of ▁ possible ▁ solutions : ▁ " , count ) NEW_LINE DEDENT
def countFreq ( a , n ) : NEW_LINE INDENT hm = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT hm [ a [ i ] ] = hm [ a [ i ] ] + 1 NEW_LINE DEDENT st = dict ( ) NEW_LINE for x in range ( hm . keys ( ) ) : NEW_LINE INDENT st . put ( x . getKey ( ) , x . getValue ( ) ) NEW_LINE DEDENT cumul = 0 NEW_LINE for x in range ( st . keys ( ) ) : NEW_LINE INDENT cumul += x . getValue ( ) NEW_LINE print ( x . getKey ( ) , " ▁ " , cumul ) NEW_LINE DEDENT DEDENT
def cocktailSort ( a ) : NEW_LINE INDENT swapped = True NEW_LINE start = 0 NEW_LINE end = len ( a ) NEW_LINE while ( swapped == True ) : NEW_LINE INDENT swapped = False NEW_LINE for i in range ( start , end - 1 ) : NEW_LINE INDENT if ( a [ i ] > a [ i + 1 ] ) : NEW_LINE INDENT a [ i ] , a [ i + 1 ] = a [ i + 1 ] , a [ i ] NEW_LINE swapped = True NEW_LINE DEDENT DEDENT if ( swapped == False ) : NEW_LINE INDENT break NEW_LINE DEDENT swapped = False NEW_LINE end = end - 1 NEW_LINE for i in range ( start , end - 1 ) : NEW_LINE INDENT if ( a [ i ] > a [ i + 1 ] ) : NEW_LINE INDENT a [ i ] , a [ i + 1 ] = a [ i + 1 ] , a [ i ] NEW_LINE swapped = True NEW_LINE DEDENT DEDENT start = start + 1 NEW_LINE DEDENT DEDENT
def first ( str , i ) : NEW_LINE INDENT if ( str [ i ] == ' \0' ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( ord ( str [ i ] ) == ' ' ) : NEW_LINE INDENT return ord ( str [ i ] ) NEW_LINE DEDENT return first ( str , i + 1 ) NEW_LINE DEDENT
def longestNull ( str1 ) : NEW_LINE INDENT arr = [ ] NEW_LINE maxlen = 0 NEW_LINE for i in range ( len ( str1 ) ) : NEW_LINE INDENT arr . append ( new Pair ( ' @ ' , - 1 ) ) NEW_LINE maxlen = max ( maxlen , i - len ( str1 ) ) NEW_LINE DEDENT for i in range ( len ( str1 ) ) : NEW_LINE INDENT arr . append ( new Pair ( str1 [ i ] , i ) ) NEW_LINE DEDENT while arr . count ( ) >= 3 and arr [ arr . get ( arr . size ( ) - 3 ) . first == '1' and arr [ arr . get ( arr . size ( ) - 2 ) . first == '0' and arr [ arr . get ( arr . size ( ) - 1 ) . first == '0' ) : NEW_LINE INDENT arr . remove ( arr . get ( arr . size ( ) - 1 ) ) NEW_LINE DEDENT DEDENT tmp = arr [ 0 ] NEW_LINE arr . remove ( arr . size ( ) - 1 ) NEW_LINE DEDENT maxlen = max ( maxlen , i - tmp ) NEW_LINE DEDENT DEDENT return maxlen NEW_LINE DEDENT
def reverse ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE i = 0 NEW_LINE for i in range ( n // 2 ) : NEW_LINE INDENT swap ( str , i , n - i - 1 ) NEW_LINE DEDENT DEDENT
def nextWord ( str ) : NEW_LINE INDENT if ( str == " " ) : NEW_LINE INDENT return " a " NEW_LINE DEDENT i = len ( str ) - 1 NEW_LINE while ( str [ i ] == ' z ' and i >= 0 ) : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT if ( i == - 1 ) : NEW_LINE INDENT str = str + ' a ' NEW_LINE DEDENT else : NEW_LINE INDENT str = str [ 0 : ] + chr ( ord ( str [ i ] ) + 1 ) + str [ i + 1 : ] NEW_LINE DEDENT return str NEW_LINE DEDENT
def isRectangle ( matrix ) : NEW_LINE INDENT rows = len ( matrix ) NEW_LINE if ( rows == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT columns = len ( matrix [ 0 ] ) NEW_LINE table = dict ( ) NEW_LINE for i in range ( rows ) : NEW_LINE INDENT for j in range ( columns - 1 ) : NEW_LINE INDENT for k in range ( columns ) : NEW_LINE INDENT if ( matrix [ i ] [ j ] == 1 and matrix [ i ] [ k ] == 1 ) : NEW_LINE INDENT if ( table [ j ] and table [ j ] [ k ] == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( table [ k ] and table [ k ] [ j ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( table [ j ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( table [ k ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( table [ j ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( table [ k ] ) : NEW_LINE INDENT x = [ ] NEW_LINE x . append ( j ) NEW_LINE table [ k ] . append ( j ) NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT
def sumoflength ( arr , n ) : NEW_LINE INDENT s = Set ( ) NEW_LINE j = 0 NEW_LINE ans = 0 NEW_LINE for ele in arr : NEW_LINE INDENT s . add ( ele ) NEW_LINE j += 1 NEW_LINE DEDENT ans += ( ( j - i ) * ( j - i + 1 ) ) / 2 NEW_LINE s . remove ( arr [ i ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def findTriplets ( arr , n ) : NEW_LINE INDENT found = 0 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT s = Set ( ) NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT x = - ( arr [ i ] + arr [ j ] ) NEW_LINE if ( s . contains ( x ) ) : NEW_LINE INDENT print ( " % d ▁ % d ▁ % d \n " , x , arr [ i ] , arr [ j ] ) NEW_LINE found = True NEW_LINE DEDENT else : NEW_LINE INDENT s . add ( arr [ j ] ) NEW_LINE DEDENT DEDENT DEDENT if ( found == False ) : NEW_LINE INDENT print ( " ▁ No ▁ Triplet ▁ Found \n " ) NEW_LINE DEDENT DEDENT
def maxPrefix ( s , t ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( count == len ( t ) ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( t [ i ] == s [ count ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def segregateElements ( arr , n ) : NEW_LINE INDENT temp = [ 0 ] * n NEW_LINE j = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if arr [ i ] >= 0 : NEW_LINE INDENT temp [ j ] = arr [ i ] NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if ( j == n or j == 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if arr [ i ] < 0 : NEW_LINE INDENT temp [ j ] = arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT arr [ i ] = temp [ i ] NEW_LINE DEDENT DEDENT
def mergeIntervals ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE index = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ index ] . end >= arr [ i ] . start ) : NEW_LINE INDENT arr [ index ] . end = max ( arr [ index ] . end , arr [ i ] . end ) NEW_LINE arr [ index ] . start = min ( arr [ index ] . start , arr [ i ] . start ) NEW_LINE DEDENT else : NEW_LINE INDENT arr [ index ] = arr [ i ] NEW_LINE index += 1 NEW_LINE DEDENT DEDENT print ( " The ▁ Merged ▁ Intervals ▁ are : ▁ " ) NEW_LINE for i in range ( index + 1 , n + 1 ) : NEW_LINE INDENT print ( " [ " , arr [ i ] . start , " , " , arr [ i ] . end , " ] " ) NEW_LINE DEDENT DEDENT
def findArea ( arr , n ) : NEW_LINE INDENT arr . sort ( reverse = True ) NEW_LINE dimension = [ 0 , 0 ] NEW_LINE for i in range ( 0 , n - 1 , 2 ) : NEW_LINE INDENT if arr [ i ] == arr [ i + 1 ] : NEW_LINE INDENT dimension [ j ] = arr [ i ] NEW_LINE i += 1 NEW_LINE DEDENT DEDENT return ( dimension [ 0 ] * dimension [ 1 ] ) NEW_LINE DEDENT
def minOps ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE max = arr [ 0 ] NEW_LINE res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( max - arr [ i ] ) % k != 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT res += ( max - arr [ i ] ) / k NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def isDivisible7 ( num ) : NEW_LINE INDENT n = len ( num ) NEW_LINE if ( n == 0 and num [ 0 ] == '0' ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 3 == 1 ) : NEW_LINE INDENT num = "00" + num NEW_LINE DEDENT if ( n % 3 == 2 ) : NEW_LINE INDENT num = "0" + num NEW_LINE DEDENT gSum = 0 NEW_LINE p = 1 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT group = 0 NEW_LINE group += num [ i - ] - '0' NEW_LINE group += ( num [ i ] - '0' ) * 10 NEW_LINE group += ( num [ i ] - '0' ) * 100 NEW_LINE gSum = gSum + group * p NEW_LINE p = p * - 1 NEW_LINE DEDENT return ( gSum % 7 == 0 ) NEW_LINE DEDENT
def isDivisible999 ( num ) : NEW_LINE INDENT n = len ( num ) NEW_LINE if ( n == 0 and num [ 0 ] == '0' ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 3 == 1 ) : NEW_LINE INDENT num = "00" + num NEW_LINE DEDENT if ( n % 3 == 2 ) : NEW_LINE INDENT num = "0" + num NEW_LINE DEDENT gSum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT group = 0 NEW_LINE group += ( num [ i ] - '0' ) * 100 NEW_LINE group += ( num [ i ] - '0' ) * 10 NEW_LINE group += num [ i ] - '0' NEW_LINE gSum += group NEW_LINE DEDENT if ( gSum > 1000 ) : NEW_LINE INDENT num = str ( gSum ) NEW_LINE n = len ( num ) NEW_LINE gSum = int ( gSum ) NEW_LINE DEDENT if ( gSum > 999 ) : NEW_LINE INDENT num = int ( num ) NEW_LINE n = len ( num ) NEW_LINE gSum = isDivisible999 ( num ) ? 1 : 0 NEW_LINE DEDENT DEDENT return ( gSum == 999 ) NEW_LINE DEDENT
def checkPangram ( string ) : NEW_LINE INDENT mark = [ False ] * 26 NEW_LINE index = 0 NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT if ( ' A ' <= str [ i ] and str [ i ] <= ' Z ' ) : NEW_LINE INDENT index = ord ( string [ i ] ) - ord ( ' A ' ) NEW_LINE DEDENT elif ( ' a ' <= str [ i ] and str [ i ] <= ' z ' ) : NEW_LINE INDENT index = ord ( string [ i ] ) - ord ( ' a ' ) NEW_LINE DEDENT mark [ index ] = True NEW_LINE DEDENT DEDENT for i in range ( 25 ) : NEW_LINE INDENT if ( mark [ i ] == False ) : NEW_LINE INDENT return ( False ) NEW_LINE DEDENT return ( True ) NEW_LINE DEDENT
def kLargest ( arr , k ) : NEW_LINE INDENT arr . sort ( reverse = True ) NEW_LINE for i in range ( k ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def kthLargestSum ( arr , n , k ) : NEW_LINE INDENT sum = [ 0 ] * ( n + 1 ) NEW_LINE sum [ 0 ] = 0 NEW_LINE sum [ 1 ] = arr [ 0 ] NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT sum [ i ] = sum [ i - 1 ] + arr [ i - 1 ] NEW_LINE DEDENT Q = Queue ( ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT x = sum [ j ] - sum [ i - 1 ] NEW_LINE if ( Q . qsize ( ) < k ) : NEW_LINE INDENT Q . put ( x ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( Q . queue [ 0 ] < x ) : NEW_LINE INDENT Q . get ( ) NEW_LINE Q . put ( x ) NEW_LINE DEDENT DEDENT DEDENT return Q . get ( ) NEW_LINE DEDENT
def printDistinct ( arr ) : NEW_LINE INDENT sett = Set ( ) NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT if ( arr [ i ] not in sett ) : NEW_LINE INDENT sett . add ( arr [ i ] ) NEW_LINE print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
def abFree ( s ) : NEW_LINE INDENT b_count = 0 NEW_LINE res = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == ' a ' ) : NEW_LINE INDENT res = ( res + b_count ) NEW_LINE b_count = ( b_count * 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT b_count += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def findFibSubset ( x ) : NEW_LINE INDENT max = max ( x ) NEW_LINE fib = [ ] NEW_LINE result = [ ] NEW_LINE a = 0 NEW_LINE b = 1 NEW_LINE while ( b < max ) : NEW_LINE INDENT c = a + b NEW_LINE a = b NEW_LINE b = c NEW_LINE fib . append ( c ) NEW_LINE DEDENT for i in range ( len ( x ) ) : NEW_LINE INDENT if ( fib [ i ] in range ( x . length ) ) : NEW_LINE INDENT result . append ( x [ i ] ) NEW_LINE DEDENT DEDENT print ( result ) NEW_LINE DEDENT
def recursiveReverse ( str , i ) : NEW_LINE INDENT n = len ( str ) NEW_LINE if ( i == n // 2 ) : NEW_LINE INDENT return NEW_LINE DEDENT swap ( str , i , n - i - 1 ) NEW_LINE recursiveReverse ( str , i + 1 ) NEW_LINE DEDENT
def noAdjacentDup ( s1 ) : NEW_LINE INDENT n = len ( s1 ) NEW_LINE s = s1 . toCharArray ( ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if s [ i ] == s [ i - 1 ] : NEW_LINE INDENT s [ i ] = ' a ' NEW_LINE while ( s [ i ] == s [ i - 1 ] or ( i + 1 < n and s [ i ] == s [ i + 1 ] ) : NEW_LINE INDENT s [ i ] += 1 NEW_LINE i += 1 NEW_LINE DEDENT DEDENT DEDENT return ( s ) NEW_LINE DEDENT
def query ( s , i , j ) : NEW_LINE INDENT n = len ( s ) NEW_LINE i %= n NEW_LINE j %= n NEW_LINE if ( s [ i ] == s [ j ] ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def countPairs ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE Hash = Set ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT Hash . add ( arr [ i ] ) NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT product = arr [ i ] * arr [ j ] NEW_LINE if ( Hash . contains ( product ) ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
def printInSortedOrder ( arr , n ) : NEW_LINE INDENT index = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT index [ i ] = i NEW_LINE DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT min = i NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ index [ min ] ] . compareTo ( arr [ index [ j ] ] ) > 0 ) : NEW_LINE INDENT min = j NEW_LINE DEDENT DEDENT if ( min != i ) : NEW_LINE INDENT temp = index [ min ] NEW_LINE index [ min ] = index [ i ] NEW_LINE index [ i ] = temp NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ index [ i ] ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def sortUsingHash ( a , n ) : NEW_LINE INDENT max = max ( a ) NEW_LINE min = abs ( a ) NEW_LINE hashpos = [ 0 ] * ( max + 1 ) NEW_LINE hashneg = [ 0 ] * ( min + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] >= 0 ) : NEW_LINE INDENT hashpos [ a [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT hashneg [ abs ( a [ i ] ) ] += 1 NEW_LINE DEDENT DEDENT for i in range ( min , max + 1 ) : NEW_LINE INDENT if ( hashneg [ i ] > 0 ) : NEW_LINE INDENT for j in range ( hashneg [ i ] , 1 ) : NEW_LINE INDENT print ( ( - 1 ) * i , " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , max + 1 ) : NEW_LINE INDENT if ( hashpos [ i ] > 0 ) : NEW_LINE INDENT for j in range ( hashpos [ i ] , 1 ) : NEW_LINE INDENT print ( i , " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
def findRandomIndexOfMax ( arr , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if mp . get ( arr [ i ] ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT max_element = 10 ** 9 NEW_LINE max_so_far = 10 ** 9 NEW_LINE for p in range ( mp . keys ( ) ) : NEW_LINE INDENT if ( p . getValue ( ) > max_so_far ) : NEW_LINE INDENT max_so_far = p . getValue ( ) NEW_LINE max_element = p . getKey ( ) NEW_LINE DEDENT DEDENT r = ( int ) ( ( random ( ) . nextInt ( max_so_far ) % max_so_far ) + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == max_element ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( count == r ) : NEW_LINE INDENT print ( " Element ▁ with ▁ maximum ▁ frequency ▁ present " , " at ▁ index ▁ " , i , " \n " ) NEW_LINE break NEW_LINE DEDENT DEDENT
def singleNumber ( a , n ) : NEW_LINE INDENT s = Set ( ) NEW_LINE for i in range ( a ) : NEW_LINE INDENT s . add ( i ) NEW_LINE DEDENT arr_sum = 0 NEW_LINE for i in range ( a ) : NEW_LINE INDENT arr_sum += i NEW_LINE DEDENT set_sum = 0 NEW_LINE for i in range ( s ) : NEW_LINE INDENT set_sum += i NEW_LINE DEDENT return ( 3 * set_sum - arr_sum ) // 2 NEW_LINE DEDENT
def printAllAPTriplets ( arr , n ) : NEW_LINE INDENT s = [ ] NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT diff = arr [ j ] - arr [ i ] NEW_LINE exists = s . contains ( arr [ i ] - diff ) NEW_LINE if ( exists ) : NEW_LINE INDENT print ( arr [ i ] - diff , end = " ▁ " , arr [ i ] , end = " ▁ " , arr [ j ] ) NEW_LINE DEDENT DEDENT s . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT
def simplify ( str1 ) : NEW_LINE INDENT lenn = len ( str1 ) NEW_LINE res = [ 0 ] * ( lenn ) NEW_LINE index = 0 NEW_LINE i = 0 NEW_LINE s = [ 0 ] * ( lenn ) NEW_LINE while ( i < len ( str1 ) ) : NEW_LINE INDENT if ( s [ - 1 ] == 1 ) : NEW_LINE INDENT res [ index += 1 ] = ' - ' NEW_LINE DEDENT elif ( s [ - 1 ] == 0 ) : NEW_LINE INDENT res [ index += 1 ] = ' + ' NEW_LINE DEDENT elif ( str1 [ i ] == ' ( ' and i > 0 ) : NEW_LINE INDENT if ( str1 [ i - 1 ] == ' - ' ) : NEW_LINE INDENT x = 0 NEW_LINE DEDENT s . append ( x ) NEW_LINE DEDENT elif ( str1 [ i - 1 ] == ' + ' ) : NEW_LINE INDENT s . append ( s [ - 1 ] ) NEW_LINE DEDENT elif ( str1 [ i ] == ' ) ' : NEW_LINE INDENT s . pop ( ) NEW_LINE DEDENT else : NEW_LINE INDENT res [ index += 1 ] = str1 [ i ] NEW_LINE i += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT res [ index += 1 ] = str1 [ i ] NEW_LINE i += 1 NEW_LINE DEDENT DEDENT
def findPair ( arr , n ) : NEW_LINE INDENT s = Set ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT s . add ( i ) NEW_LINE DEDENT found = False NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT sum = arr [ i ] + arr [ j ] NEW_LINE if ( s . contains ( sum ) ) : NEW_LINE INDENT found = True NEW_LINE DEDENT print ( arr [ i ] , " ▁ " , arr [ j ] ) NEW_LINE DEDENT DEDENT if ( found == False ) : NEW_LINE INDENT print ( " Not ▁ Exist ▁ " ) NEW_LINE DEDENT DEDENT
def strToBinary ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT val = int ( s [ i ] ) NEW_LINE bin = " " NEW_LINE while ( val > 0 ) : NEW_LINE INDENT if ( val % 2 == 1 ) : NEW_LINE INDENT bin += '1' NEW_LINE DEDENT else : NEW_LINE INDENT bin += '0' NEW_LINE DEDENT val /= 2 NEW_LINE DEDENT bin = reverse ( bin ) NEW_LINE print ( bin , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def findDuplicateparenthesis ( s ) : NEW_LINE INDENT Stack = [ ] NEW_LINE str = [ ] NEW_LINE for ch in string : NEW_LINE INDENT if ( ch == ' ( ' ) ' ) : NEW_LINE INDENT top = Stack [ - 1 ] NEW_LINE Stack . pop ( ) NEW_LINE elementsInside = 0 NEW_LINE while ( top != ' ( ' ) ) : NEW_LINE INDENT elementsInside += 1 NEW_LINE top = Stack [ - 1 ] NEW_LINE Stack . pop ( ) NEW_LINE DEDENT if ( elementsInside < 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT Stack . append ( ch ) NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def findTriplets ( x ) : NEW_LINE INDENT fact = [ 0 ] * 10 NEW_LINE factors = [ 0 ] * 10 NEW_LINE for i in range ( 2 , math . sqrt ( x ) + 1 ) : NEW_LINE INDENT if ( x % i == 0 ) : NEW_LINE INDENT fact . append ( i ) NEW_LINE DEDENT if ( x / i != i ) : NEW_LINE INDENT fact . append ( x / i ) NEW_LINE DEDENT factors . append ( i ) NEW_LINE DEDENT DEDENT found = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT a = fact [ i ] NEW_LINE for j in range ( k ) : NEW_LINE INDENT b = fact [ j ] NEW_LINE if ( ( a != b ) and ( x / ( a * b ) != a ) and ( x / ( a * b ) != b ) : NEW_LINE INDENT print ( a + " ▁ " , b , " ▁ " , ( x / ( a * b ) ) NEW_LINE found = True NEW_LINE break NEW_LINE DEDENT DEDENT if ( found ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( not found ) : NEW_LINE INDENT print ( " - 1 " ) NEW_LINE DEDENT DEDENT
def findMissing ( a , b , n , m ) : NEW_LINE INDENT s = Set ( ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT s . add ( b [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( not s . contains ( a [ i ] ) ) : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def minheapify ( a , index ) : NEW_LINE INDENT small = index NEW_LINE l = 2 * index + 1 NEW_LINE r = 2 * index + 2 NEW_LINE if ( l < n and a [ l ] < a [ small ] ) : NEW_LINE INDENT small = l NEW_LINE DEDENT if ( r < n and a [ r ] < a [ small ] ) : NEW_LINE INDENT small = r NEW_LINE DEDENT if ( l < n and a [ l ] < a [ small ] ) : NEW_LINE INDENT small = l NEW_LINE DEDENT if ( small != index ) : NEW_LINE INDENT t = a [ small ] NEW_LINE a [ small ] = a [ index ] NEW_LINE a [ index ] = t NEW_LINE minheapify ( a , small ) NEW_LINE DEDENT DEDENT
def KMP ( m , n , str1 , str2 ) : NEW_LINE INDENT pos = 0 NEW_LINE len = 0 NEW_LINE p = [ 0 ] * ( m + 1 ) NEW_LINE k = 0 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT while ( k > 0 and ch1 [ k ] != ch1 [ i - 1 ] ) : NEW_LINE INDENT k = p [ k ] NEW_LINE DEDENT if ( ch1 [ k ] == ch1 [ i - 1 ] ) : NEW_LINE INDENT k = p [ k ] NEW_LINE DEDENT if ( j < n and ch1 [ j ] == ch2 [ i ] ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT if ( j > len ) : NEW_LINE INDENT len = j NEW_LINE pos = i - j + 1 NEW_LINE DEDENT DEDENT print ( " Shift ▁ = ▁ " , pos ) NEW_LINE DEDENT
def swapDiagonal ( matrix , N ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT temp = matrix [ i ] [ i ] NEW_LINE matrix [ i ] [ i ] = matrix [ i ] [ N - i - 1 ] NEW_LINE matrix [ i ] [ N - i - 1 ] = temp NEW_LINE DEDENT DEDENT
def maximumPalinUsingKChanges ( str , k ) : NEW_LINE INDENT palin = [ 0 ] * 10 NEW_LINE ans = " " NEW_LINE l = 0 NEW_LINE r = len ( str ) - 1 NEW_LINE while ( l < r ) : NEW_LINE INDENT if ( str [ l ] != str [ r ] ) : NEW_LINE INDENT palin [ l ] = palin [ r ] = ( char ) max ( str [ l ] , str [ r ] ) NEW_LINE k -= 1 NEW_LINE DEDENT l += 1 NEW_LINE r -= 1 NEW_LINE DEDENT if ( k < 0 ) : NEW_LINE INDENT return " Not ▁ possible " NEW_LINE DEDENT if ( l == r ) : NEW_LINE INDENT if ( k >= 2 and palin [ l ] == str [ l ] and palin [ r ] == str [ r ] ) : NEW_LINE INDENT k -= 2 NEW_LINE palin [ l ] = palin [ r ] = '9' NEW_LINE DEDENT elif ( k >= 1 and ( palin [ l ] != str [ l ] or palin [ r ] != str [ r ] ) : NEW_LINE INDENT k -= 1 NEW_LINE palin [ l ] = palin [ r ] = '9' NEW_LINE DEDENT DEDENT l += 1 NEW_LINE r -= 1 NEW_LINE DEDENT DEDENT for i in range ( len ( palin ) ) : NEW_LINE INDENT ans += palin [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT
def findMinRooms ( slots , n , m ) : NEW_LINE INDENT counts = [ 0 for i in range ( m ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( slots [ i ] [ j ] == '1' ) : NEW_LINE INDENT counts [ j ] += 1 NEW_LINE DEDENT DEDENT DEDENT max = - 1 NEW_LINE for i in range ( m ) : NEW_LINE INDENT if ( max < counts [ i ] ) : NEW_LINE INDENT max = counts [ i ] NEW_LINE DEDENT DEDENT return max NEW_LINE DEDENT
def minProduct ( arr , n , k ) : NEW_LINE INDENT pq = PriorityQueue ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT pq . put ( arr [ i ] ) NEW_LINE DEDENT count = 0 NEW_LINE ans = 1 NEW_LINE while ( pq . empty ( ) == False and count < k ) : NEW_LINE INDENT ans = ans * pq . element ( ) NEW_LINE pq . get ( ) NEW_LINE count += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def largest ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE return arr [ n - 1 ] NEW_LINE DEDENT
def findLongestConseqSubseq ( arr , n ) : NEW_LINE INDENT s = Set ( ) NEW_LINE for ele in arr : NEW_LINE INDENT s . add ( ele ) NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] in s ) : NEW_LINE INDENT j = arr [ i ] NEW_LINE while ( j in s ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT ans = max ( ans , j - arr [ i ] ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def divisibilityCheck ( arr , n ) : NEW_LINE INDENT s = [ ] NEW_LINE max_ele = 10 ** 9 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . append ( arr [ i ] ) NEW_LINE max_ele = max ( max_ele , arr [ i ] ) NEW_LINE DEDENT res = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] != 0 ) : NEW_LINE INDENT for j in range ( arr [ i ] * 2 , max_ele + arr [ i ] ) : NEW_LINE INDENT if ( s . contains ( j ) ) : NEW_LINE INDENT res . append ( j ) NEW_LINE DEDENT DEDENT DEDENT list = sorted ( res ) NEW_LINE reverse ( list ) NEW_LINE for temp in list : NEW_LINE INDENT print ( temp , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def minPalPartion ( str1 ) : NEW_LINE INDENT n = len ( str1 ) NEW_LINE C = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE P = [ [ False for x in range ( n + 1 ) ] for y in range ( n + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT P [ i ] [ i ] = True NEW_LINE C [ i ] [ i ] = 0 NEW_LINE DEDENT for L in range ( 2 , n + 1 ) : NEW_LINE INDENT for i in range ( n - L + 1 ) : NEW_LINE INDENT j = i + L - 1 NEW_LINE if ( L == 2 ) : NEW_LINE INDENT P [ i ] [ j ] = ( str1 [ i ] == str1 [ j ] ) NEW_LINE DEDENT else : NEW_LINE INDENT P [ i ] [ j ] = ( ( str1 [ i ] == str1 [ j ] ) and P [ i + 1 ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT if ( P [ i ] [ j ] == True ) : NEW_LINE INDENT C [ i ] [ j ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = sys . maxsize NEW_LINE for k in range ( i , j - 1 ) : NEW_LINE INDENT C [ i ] [ j ] = min ( C [ i ] [ j ] , C [ k + 1 ] [ j ] + 1 ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return C [ 0 ] [ n - 1 ] NEW_LINE DEDENT
def checkCount ( arr , n , k ) : NEW_LINE INDENT hash = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] not in hash ) : NEW_LINE INDENT hash [ arr [ i ] ] = 0 NEW_LINE DEDENT hash [ arr [ i ] ] = hash [ arr [ i ] ] + 1 NEW_LINE DEDENT for x in range ( hash . keys ( ) ) : NEW_LINE INDENT if ( x . getValue ( ) > 2 * k ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def removeDuplicates ( S ) : NEW_LINE INDENT n = len ( S ) NEW_LINE if ( n < 2 ) : NEW_LINE INDENT return NEW_LINE DEDENT j = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( S [ j ] != S [ i ] ) : NEW_LINE INDENT j += 1 NEW_LINE S [ j ] = S [ i ] NEW_LINE DEDENT DEDENT print ( S ) NEW_LINE DEDENT
def KMaxCombinations ( A , B , N , K ) : NEW_LINE INDENT pq = PriorityQueue ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT pq . put ( A [ i ] + B [ j ] ) NEW_LINE DEDENT DEDENT count = 0 NEW_LINE while ( count < K ) : NEW_LINE INDENT print ( pq . get ( ) ) NEW_LINE pq . get ( ) NEW_LINE count += 1 NEW_LINE DEDENT DEDENT
def to_upper ( in ) : NEW_LINE INDENT for i in range ( len ( in ) ) : NEW_LINE INDENT if ( ' a ' <= in [ i ] and in [ i ] <= ' z ' ) : NEW_LINE INDENT in [ i ] = chr ( in [ i ] - ord ( ' a ' ) + ord ( ' A ' ) ) NEW_LINE DEDENT DEDENT return ' ' . join ( in ) NEW_LINE DEDENT
def sortInWave ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n , 2 ) : NEW_LINE INDENT if i > 0 and arr [ i - 1 ] > arr [ i ] : NEW_LINE INDENT swap ( arr , i - 1 , i ) NEW_LINE DEDENT if i < n - 1 and arr [ i ] < arr [ i + 1 ] : NEW_LINE INDENT swap ( arr , i , i + 1 ) NEW_LINE DEDENT DEDENT DEDENT
def getMinNumberForPattern ( seq ) : NEW_LINE INDENT n = len ( seq ) NEW_LINE if ( n >= 9 ) : NEW_LINE INDENT return " - 1" NEW_LINE DEDENT result = [ 0 ] * ( n + 1 ) NEW_LINE count = 1 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT if ( i == n or seq [ i ] == ' I ' ) : NEW_LINE INDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT result [ j + 1 ] = chr ( ( int ) '0' + count += 1 NEW_LINE DEDENT if ( j >= 0 and seq [ j ] == ' I ' ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT return new String ( result ) NEW_LINE DEDENT
def findMin ( V ) : NEW_LINE INDENT ans = [ ] NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT while ( V >= deno [ i ] ) : NEW_LINE INDENT V -= deno [ i ] NEW_LINE ans . append ( deno [ i ] ) NEW_LINE DEDENT DEDENT for i in range ( len ( ans ) ) : NEW_LINE INDENT print ( " ▁ " , ans [ i ] ) NEW_LINE DEDENT DEDENT
def findRepeating ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT return sum - ( ( ( n - 1 ) * n ) // 2 ) NEW_LINE DEDENT
def findSum ( str1 , str2 ) : NEW_LINE INDENT if ( len ( str1 ) > len ( str2 ) ) : NEW_LINE INDENT t = str1 NEW_LINE str1 = str2 NEW_LINE str2 = str2 NEW_LINE n1 = len ( str1 ) NEW_LINE n2 = len ( str2 ) NEW_LINE str = " " NEW_LINE str1 = str1 . reverse ( ) . toString ( ) NEW_LINE str2 = str2 . reverse ( ) NEW_LINE carry = 0 NEW_LINE for i in range ( n1 ) : NEW_LINE INDENT sum = ( ( int ) ( str1 [ i ] - '0' ) + ( int ) ( str2 [ i ] - '0' ) + carry ) NEW_LINE str += ( char ) ( sum % 10 + '0' ) NEW_LINE carry = sum / 10 NEW_LINE DEDENT for i in range ( n1 , n2 ) : NEW_LINE INDENT sum = ( ( int ) ( str2 [ i ] - '0' ) + carry ) NEW_LINE str += ( char ) ( sum % 10 + '0' ) NEW_LINE carry = sum / 10 NEW_LINE DEDENT if ( carry > 0 ) : NEW_LINE INDENT str += ( char ) ( carry + '0' ) NEW_LINE DEDENT DEDENT return str NEW_LINE DEDENT
