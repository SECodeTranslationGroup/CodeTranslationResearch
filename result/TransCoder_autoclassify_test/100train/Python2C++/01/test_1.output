int nonDecNums ( int n ) { int a [ n + 1 ] [ 10 ] ; for ( int i = 0 ; i <= 9 ; i ++ ) a [ 0 ] [ i ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) a [ i ] [ 9 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 8 ; j < ; j ++ ) a [ i ] [ j ] = a [ i - 1 ] [ j ] + a [ i ] [ j + 1 ] ; return a [ n ] [ 0 ] ; }
int maxSum ( int arr [ ] , int n ) { int cum_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) cum_sum += arr [ i ] ; int curr_val = 0 ; for ( int i = 0 ; i < n ; i ++ ) curr_val += i * arr [ i ] ; int res = curr_val ; for ( int i = 1 ; i < n ; i ++ ) { int next_val = ( curr_val - ( cum_sum - arr [ i - 1 ] ) + arr [ i - 1 ] * ( n - 1 ) ) ; curr_val = next_val ; res = max ( res , next_val ) ; } return res ; }
void countSubsequence ( char s [ ] , int n ) { int cntG = 0 , cntF = 0 ; int result = 0 , C = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ' G ' ) cntG ++ ; result += C ; continue ; if ( s [ i ] == ' F ' ) cntF ++ ; C ++ ; } else if ( result == 0 ) cout << result << endl ; }
int countFriendsPairings ( int n ) { int a = 1 , b = 2 , c = 1 ; if ( n <= 2 ) return n ; for ( int i = 3 ; i <= n ; i ++ ) c = b + ( i - 1 ) * a ; a = b ; b = c ; } return c ; }
void subArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { for ( int k = i ; k <= j ; k ++ ) cout << arr [ k ] << " ▁ " ; cout << endl ; } } }
int solve ( int i , int par , int a [ ] , int n , int k , int current_ans ) { if ( par > k ) return 0 ; if ( par == k && i == n - 1 ) ans = min ( ans , current_ans ) ; return 0 ; } for ( int j = i ; j < n ; j ++ ) { solve ( j , par + 1 , a , n , k , current_ans + ( a [ j ] - a [ i + 1 ] ) * ( a [ j ] - a [ i + 1 ] ) ; } }
int squareRoot ( int n ) { int x = n ; int y = 1 ; double e = 0.000001 ; while ( x - y > e ) { x = ( x + y ) / 2 ; y = n / x ; } return x ; }
int CountPairs ( int n ) { int k = n ; int imin = 1 ; int ans = 0 ; while ( k <= n ) { int imax = n / k ; ans += k * ( imax - imin + 1 ) ; imin = imax + 1 ; k = n / imin ; } return ans ; }
int polygonArea ( double X [ ] , double Y [ ] , int n ) { double area = 0.0 ; int j = n - 1 ; for ( int i = 0 ; i < n ; i ++ ) { area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) ; j = i ; } return abs ( area / 2.0 ) ; }
int equilibrium ( int arr [ ] ) { int leftsum = 0 , rightsum = 0 ; int n = arr . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { leftsum = 0 ; rightsum = 0 ; for ( int j = i ; j < n ; j ++ ) { leftsum += arr [ j ] ; } if ( leftsum == rightsum ) return i ; } return - 1 ; }
int chordCnt ( int A ) { int n = 2 * A ; int dpArray [ n + 1 ] ; dpArray [ 0 ] = 1 , dpArray [ 2 ] = 1 ; for ( int i = 4 ; i <= n ; i ++ ) dpArray [ i ] = 1 ; for ( int j = 0 ; j <= i - 1 ; j ++ ) dpArray [ i ] += ( dpArray [ j ] * dpArray [ i - 2 - j ] ) ; return int ( dpArray [ n ] ) ; }
int compute ( int a , int b ) { int AM = ( a + b ) / 2 ; int GM = ( a * b ) ; int HM = ( GM * GM ) / AM ; return HM ; }
void findMajority ( int arr [ ] , int n ) { int maxCount = 0 ; int index = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) if ( arr [ i ] == arr [ j ] ) count ++ ; if ( count > maxCount ) { maxCount = count ; index = i ; } } if ( maxCount > n / 2 ) cout << arr [ index ] << " No ▁ Majority ▁ Element " ; else cout << " No ▁ Majority ▁ Element " ; }
bool isPerfectSquare ( int n ) { int i = 1 ; int the_sum = 0 ; while ( the_sum < n ) { the_sum += i ; if ( the_sum == n ) return true ; i += 2 ; } return false ; }
int nearestSmallerEqFib ( int n ) { if ( n == 0 || n == 1 ) return n ; int f1 = 0 , f2 = 1 , f3 = 0 ; while ( f3 <= n ) { f1 = f2 ; f2 = f3 ; f3 = f1 + f2 ; } return f2 ; }
bool isSubsetSum ( int arr [ ] , int n , int sum ) { bool subset [ 3 ] [ n + 1 ] ; for ( int i = 0 ; i <= 3 ; i ++ ) subset [ i ] [ 0 ] = true ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= sum ; j ++ ) { if ( i == 0 ) subset [ i % 2 ] [ j ] = false ; else if ( arr [ i - 1 ] <= j ) { subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j - arr [ i - 1 ] ] || subset [ ( i + 1 ) % 2 ] [ j ] ; } else { subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j ] ; } } } return subset [ n % 2 ] [ sum ] ; }
int findExtra ( int arr1 [ ] , int arr2 [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) if ( arr1 [ i ] != arr2 [ i ] ) return i ; return n ; }
int numberOfPermWithKInversion ( int N , int K ) { if ( N == 0 ) return 0 ; if ( K == 0 ) return 1 ; int sum = 0 ; for ( int i = 0 ; i <= K ; i ++ ) { if ( i <= N - 1 ) sum += numberOfPermWithKInversion ( N - 1 , K - i ) ; } memo [ N ] [ K ] = sum ; } return sum ; }
int firstNonRepeating ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < n ; j ++ ) if ( i != j && arr [ i ] == arr [ j ] ) break ; if ( j == n ) return arr [ i ] ; } return - 1 ; }
int search ( int arr [ ] , int x ) { int n = arr . size ( ) ; for ( int j = 0 ; j < n ; j ++ ) if ( x == arr [ j ] ) return j ; return - 1 ; }
void middlesum ( int mat [ ] [ MAX ] , int n ) { int row_sum = 0 , col_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) row_sum += mat [ n / 2 ] [ i ] ; cout << " sum ▁ of ▁ middle ▁ row ▁ = ▁ " << row_sum << " col sum ▁ " << col_sum << endl ; for ( int i = 0 ; i < n ; i ++ ) { col_sum += mat [ i ] [ n / 2 ] ; cout << " sum ▁ of ▁ middle ▁ column ▁ = ▁ " << col_sum << endl ; }
void pythagoreanTriplets ( int limits ) { int c = 0 , m = 2 ; while ( c < limits ) { c = m + 1 ; while ( m < m ) { for ( int n = 1 ; n <= m ; n ++ ) { int a = m * m - n * n ; int b = 2 * m * n ; c = m * m + n * n ; if ( c > limits ) break ; c = m * m + n * n ; if ( c > limits ) break ; c = m * m + n * n ; if ( c > limits ) break ; c = m * m + n * n ; } m ++ ; } } cout << a << b << c ; }
int findSum ( int n ) { return n * ( n + 1 ) * ( n + 2 ) * ( 3 * n + 1 ) / 24 ; }
int fib ( int n ) { if ( n == 0 ) return 0 ; if ( n == 1 || n == 2 ) return 1 ; if ( f [ n ] ) return f [ n ] ; if ( n & 1 ) { int k = ( n + 1 ) / 2 ; else { int k = ( n + 1 ) / 2 ; if ( n & 1 ) { f [ n ] = fib ( k ) * fib ( k ) + fib ( k - 1 ) * fib ( k - 1 ) ; } else { f [ n ] = ( 2 * fib ( k - 1 ) + fib ( k ) ) * fib ( k - 1 ) ; } } return f [ n ] ; }
bool isIdentity ( int mat [ ] [ N ] ) { int row , col ; for ( row = 0 ; row < N ; row ++ ) { for ( col = 0 ; col < N ; col ++ ) { if ( row == col && mat [ row ] [ col ] != 1 ) return false ; else if ( row != col && mat [ row ] [ col ] != 0 ) return false ; } } return true ; }
int minCells ( int mat [ ] [ MAX ] , int m , int n ) { int dp [ m ] [ n ] ; memset ( dp , 0 , sizeof ( dp ) ) ; dp [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( dp [ i ] [ j ] != MAX && ( j + mat [ i ] [ j ] ) < n && ( dp [ i ] [ j ] + 1 ) < dp [ i ] [ j + mat [ i ] [ j ] ] ) dp [ i ] [ j + mat [ i ] [ j ] = dp [ i ] [ j ] + 1 ; } } if ( dp [ m - 1 ] [ n - 1 ] != MAX ) return dp [ m - 1 ] [ n - 1 ] ; return - 1 ; }
void arrangeString ( string str , int x , int y ) { int count_0 = 0 , count_1 = 0 ; int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == '0' ) count_0 ++ ; else count_1 ++ ; } while ( count_0 > 0 || count_1 > 0 ) { for ( int i = 0 ; i < x ; i ++ ) { if ( count_0 > 0 ) cout << " 0 " ; count_0 -- ; } for ( int j = 0 ; j < y ; j ++ ) cout << " 1 " ; } }
int carAssembly ( int a [ ] [ MAX ] , int t [ ] , int e , int x [ ] ) { int NUM_STATION = a [ 0 ] . size ( ) ; int T1 [ NUM_STATION ] , T2 [ NUM_STATION ] ; for ( int i = 0 ; i < NUM_STATION ; i ++ ) T1 [ i ] = e [ 0 ] + a [ 0 ] [ 0 ] ; T2 [ 0 ] = e [ 1 ] + a [ 1 ] [ 0 ] ; for ( int i = 1 ; i < NUM_STATION ; i ++ ) { T1 [ i ] = min ( T1 [ i - 1 ] + a [ 0 ] [ i ] , T2 [ i - 1 ] + t [ 1 ] [ i ] + a [ 1 ] [ i ] ) ; T2 [ i ] = min ( T2 [ i - 1 ] + a [ 1 ] [ i ] , T1 [ i - 1 ] + t [ 0 ] [ i ] + a [ 1 ] [ i ] ) ; } return min ( T1 [ NUM_STATION - 1 ] + x [ 0 ] , T2 [ NUM_STATION - 1 ] + x [ 1 ] ) ; }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
void findTriplets ( int arr [ ] , int n ) { bool found = false ; sort ( arr , arr + n ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int l = i + 1 ; int r = n - 1 ; int x = arr [ i ] ; while ( l < r ) { if ( x + arr [ l ] + arr [ r ] == 0 ) cout << x << arr [ l ] << arr [ r ] << endl ; else if ( x + arr [ l ] + arr [ r ] < 0 ) l ++ ; else r -- ; } } if ( found == false ) cout << " ▁ No ▁ Triplet ▁ Found " ; }
int maxTasks ( int high [ ] , int low [ ] , int n ) { if ( n <= 0 ) return 0 ; return max ( high [ n - 1 ] + maxTasks ( high , low , ( n - 2 ) ) , low [ n - 1 ] + maxTasks ( high , low , ( n - 1 ) ) ; }
void printOtherSides ( int n ) { if ( n & 1 ) { if ( n == 1 ) cout << - 1 << " ▁ " ; else { int b = ( n * n - 1 ) / 2 ; int c = ( n * n + 1 ) / 2 ; cout << " b ▁ = " << b << " , ▁ c ▁ = " << c ; } } else { if ( n == 2 ) cout << - 1 << " ▁ " ; else { b = n * n / 4 - 1 ; cout << n * n / 4 + 1 << " ▁ " ; } } }
void printUnsorted ( int arr [ ] , int n ) { int e = n - 1 ; for ( int s = 0 ; s < n - 1 ; s ++ ) { if ( arr [ s ] > arr [ s + 1 ] ) break ; if ( s == n - 1 ) cout << " The ▁ complete ▁ array ▁ is ▁ sorted " << endl ; } int max = arr [ s ] ; int min = arr [ s ] ; for ( int i = s + 1 ; i <= e ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; if ( arr [ i ] < min ) min = arr [ i ] ; } } cout << " The ▁ unsorted ▁ subarray ▁ which ▁ makes ▁ the ▁ given ▁ array " << endl ; for ( int i = n - 1 ; i >= e + 1 ; i -- ) { if ( arr [ i ] < max ) e = i ; break ; } } cout << " The ▁ unsorted ▁ subarray ▁ which ▁ makes ▁ the ▁ given ▁ array ▁ " << endl ; }
int circle ( int x1 , int y1 , int x2 , int y2 , int r1 , int r2 ) { int distSq = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ; int radSumSq = ( r1 + r2 ) * ( r1 + r2 ) ; if ( distSq == radSumSq ) return 1 ; else return - 1 ; }
int countOps ( int A [ ] [ MAX ] , int B [ ] [ MAX ] , int m , int n ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) A [ i ] [ j ] -= B [ i ] [ j ] ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) { if ( A [ i ] [ j ] - A [ i ] [ 0 ] - A [ 0 ] [ j ] + A [ 0 ] [ 0 ] != 0 ) return - 1 ; } } int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) result += abs ( A [ i ] [ 0 ] ) ; return ( result ) ; }
void longestAlternating ( int arr [ ] , int n ) { int count [ n ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] * arr [ i + 1 ] < 0 ) count [ i ] = count [ i + 1 ] + 1 ; else count [ i ] = 1 ; } i = 0 ; while ( i < n ) cout << count [ i ] << " ▁ ▁ " ; }
int sortedCount ( int mat [ R ] [ C ] ) { int result = 0 ; for ( int i = 0 ; i < r ; i ++ ) { int j ; for ( j = 0 ; j < c - 1 ; j ++ ) if ( mat [ i ] [ j + 1 ] <= mat [ i ] [ j ] ) break ; if ( j == c - 2 ) result ++ ; for ( int i = 0 ; i < r ; i ++ ) { for ( j = 0 ; j < c - 1 ; j ++ ) { if ( mat [ i ] [ j - 1 ] <= mat [ i ] [ j ] ) break ; if ( c > 1 && j == 1 ) result ++ ; } } return result ; }
void printMaxOfMin ( int arr [ ] , int n ) { for ( int k = 1 ; k <= n ; k ++ ) { int maxOfMin = INT_MIN ; for ( int i = 0 ; i <= n - k ; i ++ ) { int min = arr [ i ] ; for ( int j = 0 ; j < k ; j ++ ) { if ( arr [ i + j ] < min ) min = arr [ i + j ] ; } if ( min > maxOfMin ) maxOfMin = min ; } cout << maxOfMin << " ▁ " ; }
int middleOfThree ( int a , int b , int c ) { if ( ( a < b && b < c ) || ( c < b && b < a ) ) return b ; if ( ( b < a && a < c ) || ( c < a && a < b ) ) return a ; else return c ; }
int countarray ( int n , int k , int x ) { int dp [ n ] ; dp . push ( 0 ) ; dp . push ( 1 ) ; for ( int i = 2 ; i < n ; i ++ ) dp . push ( ( k - 2 ) * dp [ i - 1 ] + ( k - 1 ) * dp [ i - 2 ] ) ; return ( ( k - 1 ) * dp [ n - 2 ] if ( x == 1 else dp [ n - 1 ] ) ; }
int nswp ( int n ) { if ( n == 0 || n == 1 ) return 1 ; return 2 * nswp ( n - 1 ) + nswp ( n - 2 ) ; }
int fib ( int n , int lookup [ ] ) { if ( n == 0 || n == 1 ) lookup [ n ] = n ; else if ( lookup [ n ] is None ) lookup [ n ] = fib ( n - 1 , lookup ) + fib ( n - 2 , lookup ) ; return lookup [ n ] ; }
void countParenth ( char symb [ ] , char oper [ ] , int n ) { int F [ n ] [ n ] ; int T [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { F [ i ] [ i ] = 1 ; else T [ i ] [ i ] = 0 ; } for ( int gap = 1 ; gap <= n ; gap ++ ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < gap ; j ++ ) { int tik = T [ i ] [ k ] + F [ i ] [ k ] ; int tkj = T [ k + 1 ] [ j ] + F [ k + 1 ] [ j ] ; if ( oper [ k ] == ' & ' ) { T [ i ] [ j ] += T [ i ] [ k ] * T [ k + 1 ] [ j ] ; F [ i ] [ j ] += ( tik * tkj - T [ i ] [ k ] * T [ k + 1 ] [ j ] ) ; } if ( oper [ k ] == ' | ' ) { F [ i ] [ j ] += F [ i ] [ k ] * F [ k + 1 ] [ j ] ; T [ i ] [ j ] += ( tik * tkj - T [ i ] [ k ] * F [ k + 1 ] [ j ] ) ; } if ( oper [ k ] == ' ^ ' ) { T [ i ] [ j ] += ( F [ i ] [ k ] * T [ k + 1 ] [ j ] ; } } }
int longestCommonSum ( int arr1 [ ] , int arr2 [ ] , int n ) { int maxLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int sum1 = 0 , sum2 = 0 ; for ( int j = 0 ; j < n ; j ++ ) { sum1 += arr1 [ j ] ; sum2 += arr2 [ j ] ; if ( sum1 == sum2 ) { int len = j - i + 1 ; if ( len > maxLen ) maxLen = len ; } } } return maxLen ; }
int maxTripletSum ( int arr [ ] , int n ) { int sm = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) { if ( sm < ( arr [ i ] + arr [ j ] + arr [ k ] ) ) sm = arr [ i ] + arr [ j ] + arr [ k ] ; } } return sm ; }
int findNth ( int n ) { int nthElement = 19 + ( n - 1 ) * 9 ; int outliersCount = log10 ( nthElement ) ; nthElement += 9 * outliersCount ; return nthElement ; }
int countSol ( int coeff [ ] , int start , int end , int rhs ) { if ( rhs == 0 ) return 1 ; int result = 0 ; for ( int i = start ; i <= end ; i ++ ) { if ( coeff [ i ] <= rhs ) result += countSol ( coeff , i , end , rhs - coeff [ i ] ) ; } return result ; }
void findConsecutive ( int n ) { int start = 1 , end = ( N + 1 ) / 2 ; while ( start < end ) { int sum = 0 ; for ( int i = start ; i <= end ; i ++ ) { sum = sum + i ; if ( sum == N ) break ; for ( int j = start ; j <= end ; j ++ ) cout << j << " ▁ " ; } cout << endl ; } }
int maxArea ( int a , int b , int c , int d ) { int semiperimeter = ( a + b + c + d ) / 2 ; return ( semiperimeter - a ) * ( semiperimeter - b ) * ( semiperimeter - c ) * ( semiperimeter - d ) ; }
bool isSubsetSum ( int set [ ] , int n , int sum ) { if ( sum == 0 ) return true ; if ( n == 0 && sum != 0 ) return false ; if ( set [ n - 1 ] > sum ) return isSubsetSum ( set , n - 1 , sum ) ; return isSubsetSum ( set , n - 1 , sum ) || isSubsetSum ( set , n - 1 , sum - set [ n - 1 ] ) ; }
int PowerOFPINnfactorial ( int n , int p ) { int ans = 0 ; int temp = p ; while ( temp <= n ) ans += n / temp ; return ans ; }
int findMaxValue ( int mat [ R ] [ C ] ) { int maxValue = 0 ; for ( int a = 0 ; a <= N - 2 ; a ++ ) { for ( int b = 0 ; b <= N - 1 ; b ++ ) { for ( int d = a + 1 ; d <= N ; d ++ ) { for ( int e = b + 1 ; e <= N ; e ++ ) { if ( maxValue < int ( mat [ d ] [ e ] - mat [ a ] [ b ] ) ) { maxValue = int ( mat [ d ] [ e ] - mat [ a ] [ b ] ) ; } } } return maxValue ; }
int getOddOccurrence ( int arr [ ] , int arr_size ) { for ( int i = 0 ; i < arr_size ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < arr_size ; j ++ ) if ( arr [ i ] == arr [ j ] ) ++ count ; if ( count % 2 != 0 ) return arr [ i ] ; } return - 1 ; }
void direction ( int R , int C ) { if ( R != C && R % 2 == 0 && C % 2 != 0 && R < C ) cout << " Left " ; if ( R != C && R % 2 == 0 && C % 2 != 0 && R < C ) cout << " Up " ; if ( R != C && R % 2 != 0 && C % 2 != 0 && R > C ) cout << " Right " ; if ( R != C && R % 2 != 0 && C % 2 != 0 && R < C ) cout << " Up " ; if ( R != C && R % 2 != 0 && R < C ) cout << " Right " ; if ( R != C && R % 2 != 0 && R < C ) cout << " Down " ; if ( R != C && R % 2 != 0 && C % 2 != 0 && R > C ) cout << " Left " ; return ; if ( R != C && R % 2 != 0 && C % 2 != 0 && R < C ) cout << " Right " ; return ; }
void fib ( int n ) { int a = 0 , b = 1 ; if ( n >= 0 ) cout << a << ' ▁ ' ; if ( n >= 1 ) cout << b << ' ▁ ' ; for ( int i = 2 ; i <= n ; i ++ ) cout << a + b << ' ▁ ' ; }
int divisorSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += ( n / i ) * i ; return sum ; }
void solve ( int n , int t , char p [ ] ) { char s [ n ] ; for ( int i = 0 ; i < t ; i ++ ) { for ( int j = 0 ; j < n - 1 ; j ++ ) { if ( s [ j ] == ' B ' && s [ j + 1 ] == ' G ' ) { s [ j ] = s [ j + 1 ] ; s [ j + 1 ] = temp ; j = j + 1 ; } } cout << s << endl ; }
int turnOffK ( int n , int k ) { if ( k <= 0 ) return n ; return ( n & ~ ( 1 << ( k - 1 ) ) ) ; }
int findMaximum ( int * arr , int low , int high ) { if ( low == high ) return arr [ low ] ; if ( high == low + 1 && arr [ low ] >= arr [ high ] ) return arr [ low ] ; if ( high == low + 1 && arr [ low ] < arr [ high ] ) return arr [ high ] ; if ( high == low + 1 && arr [ low ] < arr [ high ] ) return arr [ low ] ; int mid = ( low + high ) / 2 ; if ( arr [ mid ] > arr [ mid + 1 ] && arr [ mid ] > arr [ mid - 1 ] ) return arr [ mid ] ; if ( arr [ mid ] > arr [ mid + 1 ] && arr [ mid ] < arr [ mid - 1 ] ) return findMaximum ( arr , low , mid - 1 ) ; else findMaximum ( arr , mid + 1 , high ) ; }
int subArraySum ( int arr [ ] , int n , int sum ) { for ( int i = 0 ; i < n ; i ++ ) { int curr_sum = arr [ i ] ; int j ; for ( j = i + 1 ; j <= n ; j ++ ) { if ( curr_sum == sum ) cout << " sum ▁ found ▁ between " << ( i , j - 1 ) << " " ; return 1 ; } curr_sum = curr_sum + arr [ j ] ; if ( curr_sum > sum || j == n ) break ; curr_sum = curr_sum + arr [ j ] ; } cout << " No ▁ subarray ▁ found " ; return 0 ; }
int getModulo ( int n , int d ) { return ( n & ( d - 1 ) ) ; }
int getInvCount ( int arr [ ] , int n ) { int inv_count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] > arr [ j ] ) inv_count ++ ; } return inv_count ; }
int dealnnoy ( int n , int m ) { int dp [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) dp [ 0 ] [ i ] = 1 ; for ( int i = 1 ; i <= m ; i ++ ) dp [ i ] [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) dp [ 1 ] [ i ] = 1 ; for ( int i = 1 ; i <= m ; i ++ ) dp [ i ] [ 0 ] = 1 ; for ( int i = 1 ; i <= m ; i ++ ) for ( int j = 1 ; j <= n ; j ++ ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] + dp [ i ] [ j - 1 ] ; return dp [ m ] [ n ] ; }
bool isValidISBN ( string isbn ) { if ( isbn . length ( ) != 10 ) return false ; int _sum = 0 ; for ( int i = 0 ; i < 9 ; i ++ ) { if ( 0 <= int ( isbn [ i ] ) <= 9 ) _sum += int ( isbn [ i ] ) * ( 10 - i ) ; else if ( isbn [ i ] != ' X ' && 0 <= int ( isbn [ 9 ] ) <= 9 ) return false ; _sum += 10 if ( isbn [ 9 ] == ' X ' ) return false ; _sum += isbn [ 9 ] == ' X ' else int ( isbn [ 9 ] ) ; return ( _sum % 11 == 0 ) ; }
int power ( int n ) { if ( n == 1 ) return 2 ; return 2 * power ( n - 1 ) ; }
int lastPosition ( int n , int m , int k ) { if ( m <= n - k + 1 ) return m + k - 1 ; m = m - ( n - k + 1 ) ; if ( m % n == 0 ) return n ; else return m % n ; }
void printFibonacciNumbers ( int n ) { int f1 = 0 , f2 = 1 ; if ( n < 1 ) return ; for ( int x = 0 ; x < n ; x ++ ) { cout << f2 << " ▁ " ; f1 = f2 ; f2 = next ; } }
int knapSack ( int W , int wt , int val [ ] , int n ) { int K [ n + 1 ] [ W + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) K [ i ] [ 0 ] = 0 ; for ( int w = 0 ; w <= W ; w ++ ) { if ( i == 0 || w == 0 ) K [ i ] [ w ] = 0 ; else if ( wt [ i - 1 ] <= w ) K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] , K [ i - 1 ] [ w ] ) ; else K [ i ] [ w ] = K [ i - 1 ] [ w ] ; } } return K [ n ] [ W ] ; }
void multiply ( int A [ ] [ N ] , int B [ ] [ N ] , int C [ ] [ N ] ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) C [ i ] [ j ] = A [ i ] [ j ] - B [ i ] [ j ] ; } }
int countNegative ( int M [ ] [ MAX ] , int n , int m ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) if ( M [ i ] [ j ] < 0 ) count ++ ; else break ; } return count ; }
int middleOfThree ( int a , int b , int c ) { if ( a > b ) if ( b > c ) return b ; else if ( a > c ) return c ; else return a ; }
int countWays ( int n ) { int dp [ n + 1 ] ; dp [ 0 ] [ 1 ] = 1 , dp [ 1 ] [ 1 ] = 2 ; for ( int i = 2 ; i <= n ; i ++ ) dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + dp [ 1 ] [ i - 1 ] ; dp [ 1 ] [ i ] = dp [ 0 ] [ i - 1 ] * 2 + dp [ 1 ] [ i - 1 ] ; return dp [ 0 ] [ n ] + dp [ 1 ] [ n ] ; }
int maxLenSub ( int arr [ ] , int n ) { int mls [ n ] ; int max = 0 ; for ( int i = 0 ; i < n ; i ++ ) mls [ i ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( abs ( arr [ i ] - arr [ j ] ) <= 1 && mls [ i ] < mls [ j ] + 1 ) mls [ i ] = mls [ j ] + 1 ; } } for ( int i = 0 ; i < n ; i ++ ) if ( max < mls [ i ] ) max = mls [ i ] ; } return max ; }
int exponentiation ( int bas , int exp ) { int t = 1 ; while ( exp > 0 ) { if ( exp % 2 != 0 ) t = ( t * bas ) % N ; bas = ( bas * bas ) % N ; exp = int ( exp / 2 ) ; } return t % N ; }
int sequence ( int n ) { int f [ n + 1 ] ; f . push_back ( ' i ' ) ; for ( int i = 3 ; i <= n ; i ++ ) { int r = f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ] ; f . push_back ( r ) ; } return r ; }
int lbs ( int arr [ ] ) { int n = arr . size ( ) ; int lis [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) lis [ i ] = 1 ; for ( int j = 0 ; j <= i ; j ++ ) lis [ 0 ] = i + 1 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 0 ; j <= i ; j ++ ) { if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; } } int maximum = lis [ 0 ] + lds [ 0 ] - 1 ; for ( int i = 1 ; i <= n ; i ++ ) maximum = max ( ( lis [ i ] + lds [ i ] - 1 ) , maximum ) ; return maximum ; }
int maximumSum ( int a [ ] [ MAX ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) a [ i ] [ sort ( a [ i ] , a [ n - 1 ] [ M - 1 ] ) ; int sum = a [ n - 1 ] [ M - 1 ] ; int prev = a [ n - 1 ] [ M - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) { for ( int j = M - 1 ; j >= 0 ; j -- ) { if ( a [ i ] [ j ] < prev ) prev = a [ i ] [ j ] ; sum += prev ; break ; } } if ( j == - 1 ) return 0 ; } return sum ; }
int fib ( int n ) { if ( n <= 1 ) return n ; return fib ( n - 1 ) + fib ( n - 2 ) ; }
void diagonalsquare ( int mat [ ROW ] [ COL ] , int row , int column ) { cout << " Diagonal ▁ one ▁ : ▁ " << endl ; for ( int i = 0 ; i < row ; i ++ ) cout << mat [ i ] [ i ] * mat [ i ] [ i ] << endl ; cout << " \n \n " ; for ( int i = 0 ; i < row ; i ++ ) cout << mat [ i ] [ row - i - 1 ] << " ▁ " << endl ; }
int maxArea ( int mat [ R ] [ C ] ) { int hist [ R ] [ C ] ; memset ( hist , 0 , sizeof ( hist ) ) ; for ( int i = 0 ; i < C ; i ++ ) hist [ 0 ] [ i ] = mat [ 0 ] [ i ] ; for ( int i = 1 ; i < R ; i ++ ) { for ( int j = 1 ; j < R ; j ++ ) { if ( mat [ j ] [ i ] == 0 ) hist [ j ] [ i ] = 0 ; else hist [ j ] [ i ] = hist [ j - 1 ] [ i ] + 1 ; } } for ( int i = 0 ; i < R ; i ++ ) { for ( int j = R ; j >= 0 ; j -- ) { if ( count [ j ] > 0 ) { for ( int k = 0 ; k < count [ j ] ; k ++ ) hist [ i ] [ col_no ] = j ; col_no ++ ; } } } int max_area = INT_MIN ; for ( int i = 0 ; i < R ; i ++ ) { for ( int j = 0 ; j < C ; j ++ ) { int curr_area = ( j + 1 ) * hist [ i ] [ j ] ; if ( curr_area > max_area ) { max_area = curr_area ; } } } return max_area ; }
int longestSubseqWithDiffOne ( int arr [ ] , int n ) { int dp [ n ] ; for ( int i = 0 ; i < n ; i ++ ) dp [ i ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( ( arr [ i ] == arr [ j ] + 1 ) || ( arr [ i ] == arr [ j ] - 1 ) ) dp [ i ] = max ( dp [ i ] , dp [ j ] + 1 ) ; int result = 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( result < dp [ i ] ) result = dp [ i ] ; return result ; }
int maxSquare ( int b , int m ) { return ( b / m - 1 ) * ( b / m ) / 2 ; }
void spiralPrint ( int m , int n , int a [ R ] [ C ] ) { int i , k = 0 , l = 0 ; while ( k < m && l < n ) { for ( i = l ; i < n ; ++ i ) { cout << a [ k ] [ i ] << " ▁ " ; } k ++ ; for ( i = k ; i < m ; ++ i ) { cout << a [ i ] [ n - 1 ] << " ▁ " ; } n -- ; if ( k < m ) { for ( i = n - 1 ; i >= l ; -- i ) { cout << a [ m - 1 ] [ i ] << " ▁ " ; } m -- ; } if ( l < n ) { for ( i = m - 1 ; i >= k ; -- i ) { cout << a [ i ] [ l ] << " ▁ " ; } l ++ ; } }
int pentagonalNum ( int n ) { return ( 3 * n * n - n ) / 2 ; }
int countNonDecreasing ( int n ) { int N = 10 ; int count = 1 ; for ( int i = 1 ; i <= n ; i ++ ) count = count * ( N + i - 1 ) ; count = count / i ; return count ; }
int kth ( int arr1 [ ] , int arr2 [ ] , int m , int n , int k ) { int sorted1 [ m + n ] ; int i = 0 , j = 0 , d = 0 ; while ( i < m && j < n ) { if ( arr1 [ i ] < arr2 [ j ] ) sorted1 [ d ] = arr1 [ i ] ; i ++ ; } else { sorted1 [ d ] = arr2 [ j ] ; j ++ ; } d ++ ; } while ( i < m ) { sorted1 [ d ] = arr1 [ i ] ; d ++ ; i ++ ; } while ( j < n ) { sorted1 [ d ] = arr2 [ j ] ; d ++ ; j ++ ; } return sorted1 [ k - 1 ] ; }
int binomialCoeff ( int n , int k ) { if ( k == 0 || k == n ) return 1 ; return binomialCoeff ( n - 1 , k - 1 ) + binomialCoeff ( n - 1 , k ) ; }
void printDistinct ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int d = 0 ; for ( int j = 0 ; j < i ; j ++ ) if ( arr [ i ] == arr [ j ] ) d = 1 ; break ; if ( d == 0 ) cout << arr [ i ] ; } }
int countSolutions ( int n ) { int res = 0 ; int x = 0 ; while ( x * x < n ) { int y = 0 ; while ( x * x + y * y < n ) { res ++ ; y = y + 1 ; } x = x + 1 ; } return res ; }
void relativeComplement ( int arr1 [ ] , int arr2 [ ] , int n , int m ) { int i = 0 , j = 0 ; while ( i < n && j < m ) { if ( arr1 [ i ] < arr2 [ j ] ) cout << arr1 [ i ] << " ▁ " ; else if ( arr1 [ i ] > arr2 [ j ] ) { j ++ ; } else if ( arr1 [ i ] == arr2 [ j ] ) i ++ ; j ++ ; } } while ( i < n ) cout << arr1 [ i ++ ] << " ▁ " ; }
int findTrailingZeros ( int n ) { int count = 0 ; int i = 5 ; while ( n / i >= 1 ) count += n / i ; return count ; }
int CountSubString ( char str [ ] , int n ) { int ans = ( n * ( n + 1 ) ) / 2 ; int a_index = 0 , b_index = 0 , c_index = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == ' a ' ) a_index = i + 1 ; ans -= min ( b_index , c_index ) ; else if ( str [ i ] == ' b ' ) b_index = i + 1 ; ans -= min ( a_index , b_index ) ; else c_index = i + 1 ; } return ans ; }
int findLargestd ( int S [ ] , int n ) { bool found = false ; sort ( S , S + n ) ; for ( int i = 0 ; i <= n - 2 ; i -- ) { for ( int j = 0 ; j <= n ; j ++ ) { for ( int k = 0 ; k < n ; k ++ ) { if ( i == j ) continue ; for ( int l = 0 ; l <= n ; l ++ ) { if ( S [ i ] == S [ j ] + S [ k ] + S [ l ] ) found = true ; return S [ i ] ; } } } if ( found == false ) return - 1 ; }
int constructTree ( int n , int d , int h ) { if ( d == 1 ) cout << " 1 ▁ 2 " << endl ; if ( d > 2 * h ) cout << " - 1" ; return 0 ; } for ( int i = 1 ; i <= h ; i ++ ) cout << i << " ▁ " << i + 1 << endl ; for ( int i = h + 1 ; i <= n ; i ++ ) { cout << i << " ▁ " << i + 1 << endl ; if ( d > h ) cout << 1 << " ▁ ▁ " << h + 2 << endl ; for ( int i = d + 1 ; i <= n ; i ++ ) cout << k << " ▁ " << i + 1 << endl ; }
int rectCount ( int n , int m ) { return ( m * n * ( n + 1 ) * ( m + 1 ) ) / 4 ; }
void subarrayDivisibleByK ( int arr [ ] , int n , int k ) { int mp [ 1000 ] ; int s = 0 , e = 0 , maxs = 0 , maxe = 0 ; for ( int i = 1 ; i < n ; i ++ ) { mp [ arr [ 0 ] % k ] = mp [ arr [ 0 ] % k ] + 1 ; for ( int i = 1 ; i < n ; i ++ ) { int mod = arr [ i ] % k ; while ( mp [ k - mod ] != 0 || ( mod == 0 && mp [ mod ] != 0 ) { mp [ arr [ s ] % k ] = mp [ arr [ s ] % k ] - 1 ; s = s + 1 ; } mp [ mod ] = mp [ mod ] + 1 ; e = e + 1 ; if ( ( e - s ) > ( maxe - maxs ) ) { maxe = e ; maxs = s ; } } cout << " The ▁ maximum ▁ size ▁ is ▁ { } ▁ and ▁ the ▁ " << ( maxe - maxs + 1 ) << " \n " ; }
void swapUpperToLower ( int arr [ ] [ MAX ] , int n ) { int i , j ; for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { int temp = arr [ i ] [ j ] ; arr [ i ] [ j ] = arr [ j ] [ i ] ; arr [ j ] [ i ] = temp ; } } for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < n ; j ++ ) cout << arr [ i ] [ j ] << " ▁ " ; cout << " ▁ " ; } cout << endl ; }
int kthgroupsum ( int k ) { int cur = ( k * ( k - 1 ) ) + 1 ; int sum = 0 ; while ( k ) { sum += cur ; cur += 2 ; k = k - 1 ; } return sum ; }
bool isMagicSquare ( int mat [ N ] [ N ] ) { int s = 0 ; for ( int i = 0 ; i < N ; i ++ ) s = s + mat [ i ] [ i ] ; int s2 = 0 ; for ( int i = 0 ; i < N ; i ++ ) s2 = s2 + mat [ i ] [ N - i - 1 ] ; if ( s != s2 ) return false ; for ( int i = 0 ; i < N ; i ++ ) { int rowSum = 0 ; for ( int j = 0 ; j < N ; j ++ ) rowSum += mat [ i ] [ j ] ; if ( rowSum != s ) return false ; } for ( int i = 0 ; i < N ; i ++ ) { int colSum = 0 ; for ( int j = 0 ; j < N ; j ++ ) colSum += mat [ j ] [ i ] ; if ( s != colSum ) return false ; } return true ; }
bool isScalarMatrix ( int mat [ N ] [ N ] ) { int i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < N ; j ++ ) if ( ( i != j ) && ( mat [ i ] [ j ] != 0 ) ) return false ; for ( i = 0 ; i < N - 1 ; i ++ ) { if ( mat [ i ] [ i ] != mat [ i + 1 ] [ i + 1 ] ) return false ; } return true ; }
int maxDiff ( int arr [ ] , int n ) { int SubsetSum_1 = 0 , SubsetSum_2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { bool isSingleOccurance = true ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] == arr [ j ] ) { isSingleOccurance = false ; arr [ i ] = arr [ j ] = 0 ; break ; } } if ( isSingleOccurance == true ) { if ( arr [ i ] > 0 ) SubsetSum_1 += arr [ i ] ; else SubsetSum_2 += arr [ i ] ; } } return abs ( SubsetSum_1 - SubsetSum_2 ) ; }
int maxCost ( int mat [ ] [ N ] ) { int dp [ N ] [ N ] ; memset ( dp , 0 , sizeof ( dp ) ) ; dp [ 0 ] [ 0 ] = mat [ 0 ] [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) dp [ i ] [ 0 ] = mat [ i ] [ 0 ] + dp [ i - 1 ] [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) { for ( int j = 1 ; j <= min ( i + 1 , N ) ; j ++ ) dp [ i ] [ j ] = mat [ i ] [ j ] + \ NEW_LINE INDENT max ( dp [ i - 1 ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ; } } int result = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( result < dp [ N - 1 ] [ i ] ) result = dp [ N - 1 ] [ i ] ; return result ; }
int evenSum ( int n ) { int C [ n ] [ n + 1 ] ; int i , j ; for ( i = 0 ; i < n ; i ++ ) C [ i ] [ 0 ] = 1 ; for ( j = 0 ; j < min ( i , n + 1 ) ; j ++ ) C [ 0 ] [ j ] = 0 ; for ( i = 1 ; i < n ; i ++ ) { for ( j = 0 ; j < i ; j ++ ) { if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } int sum = 0 ; for ( i = 0 ; i < n ; i ++ ) sum = sum + C [ n ] [ i ] ; return sum ; }
void diagonalsquare ( int mat [ ] [ MAX ] , int row , int column ) { cout << " Diagonal ▁ one ▁ : ▁ " << endl ; for ( int i = 0 ; i < row ; i ++ ) { for ( int j = 0 ; j < column ; j ++ ) { if ( i == j ) cout << " { } ▁ " << mat [ i ] [ j ] * mat [ i ] [ j ] << endl ; } cout << " ▁ \n " ; for ( int i = 0 ; i < row ; i ++ ) { for ( int j = 0 ; j < column ; j ++ ) { if ( i + j == column - 1 ) cout << " { } ▁ " << mat [ i ] [ j ] * mat [ i ] [ j ] << endl ; } } cout << " ▁ \n \n " ; for ( int i = 0 ; i < row ; i ++ ) { for ( int j = 0 ; j < column ; j ++ ) { if ( i + j == column - 1 ) cout << " { } ▁ " << mat [ i ] [ j ] * mat [ i ] [ j ] << endl ; } }
int areSumSame ( int a [ ] [ MAX ] , int n , int m ) { int sum1 = 0 , sum2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum1 = 0 , sum2 = 0 ; for ( int j = 0 ; j < m ; j ++ ) { sum1 += a [ i ] [ j ] ; sum2 += a [ j ] [ i ] ; } if ( sum1 == sum2 ) return 1 ; } return 0 ; }
int countPairs ( int arr [ ] , int n ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int product = arr [ i ] * arr [ j ] ; for ( int k = 0 ; k < n ; k ++ ) if ( arr [ k ] == product ) result ++ ; break ; } } return result ; }
int minCost ( int a [ ] , int n , int k ) { int dp [ k + 1 ] [ n + 1 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; dp [ 0 ] [ 0 ] = 0 ; for ( int i = 1 ; i <= k ; i ++ ) dp [ i ] [ 0 ] = 0 ; for ( int j = 1 ; j <= n ; j ++ ) dp [ 0 ] [ 0 ] = 0 ; for ( int i = 1 ; i <= k ; i ++ ) { for ( int j = 1 ; j <= k ; j ++ ) { for ( int m = i - 1 ; m >= 0 ; m -- ) dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ m ] [ j - 1 ] + ( a [ i - 1 ] - a [ m ] ) * ( a [ i - 1 ] - a [ m ] ) ; } } return dp [ k ] [ n ] ; }
unsigned int countSetBits ( unsigned int n ) { if ( n == 0 ) return 0 ; else return 1 + countSetBits ( n & ( n - 1 ) ) ; }
int checkEulerFourSquareIdentity ( int a , int b ) { int ab = a * b ; bool flag = false ; int i = 0 ; while ( i * i <= ab ) { int j = i ; while ( i * i + j * j <= ab ) { int k = j ; while ( i * i + j * j + k * k <= ab ) { int l = ( ab - ( i * i + j * j + k * k ) ) ** ( 0.5 ) ; if ( l == int ) && l >= k ) { flag = true ; cout << " i ▁ = ▁ " << i << " j << " ▁ k << " ▁ l " << endl ; } else { cout << " Solution ▁ doesn't ▁ exist ! " ; return ; } } if ( flag == false ) cout << " Solution ▁ doesn't ▁ exist ! " ; return ; }
int countIslands ( char mat [ M ] [ N ] ) { int count = 0 ; for ( int i = 0 ; i < M ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( mat [ i ] [ j ] == ' X ' ) { if ( i == 0 || mat [ i - 1 ] [ j ] == ' O ' ) count = count + 1 ; } } } return count ; }
int getInvCount ( int arr [ ] , int n ) { int invcount = 0 ; for ( int i = 1 ; i <= n - 2 ; i ++ ) { int small = 0 ; for ( int j = i + 1 ; j <= n ; j ++ ) if ( arr [ i ] > arr [ j ] ) small ++ ; int great = 0 ; for ( int i = i - 1 ; i >= 0 ; i -- ) { if ( arr [ i ] < arr [ j ] ) great ++ ; } invcount += small * small ; } return invcount ; }
int find ( int n , int k ) { if ( n + 1 >= k ) return ( k - 1 ) ; else return ( 2 * n + 1 - k ) ; }
void generate ( int ones , int zeroes , string str , int len1 ) { if ( len1 == str . length ( ) ) cout << str << " ▁ " ; return ; } generate ( ones + 1 , zeroes , str + "1" , len1 ) ; if ( ones > zeroes ) generate ( ones , zeroes + 1 , str + "0" , len1 ) ; if ( ones > zeroes ) generate ( ones , zeroes + 1 , str + "0" , len1 ) ; }
void midPointCircleDraw ( int x_centre , int y_centre , int r ) { int x = r ; int y = 0 ; cout << " ( " << x + x_centre << " , ▁ " << y + y_centre << " ) " << endl ; if ( r > 0 ) cout << " ( " << x + x_centre << " , ▁ " << y + y_centre << " ) " << endl ; else { int P = 1 - r ; while ( x > y ) { y ++ ; if ( P <= 0 ) P = P + 2 * y + 1 ; else { x -- ; P = P + 2 * y - 2 * x + 1 ; } } cout << " ( " << " , - x + x_centre << " , ▁ " << y + y_centre << " ) " << endl ; if ( x < y ) break ; cout << " ( " << " , - x + x_centre << " , ▁ " << y + y_centre << " ) " << endl ; }
void printFactorialNums ( int n ) { int fact = 1 ; int x = 2 ; while ( fact <= n ) { cout << fact << x << endl ; fact = fact * x ; x ++ ; } }
int countFriendsPairings ( int n ) { int dp [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) dp [ i ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i <= 2 ) dp [ i ] = i ; else dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; } return dp [ n ] ; }
int findNth ( int n ) { int count = 0 ; for ( int curr = 0 ; curr < n ; curr ++ ) { int sum = 0 ; int x = curr ; while ( x ) { sum = sum + x % 10 ; x = x / 10 ; if ( sum == 10 ) count ++ ; if ( count == n ) return curr ; } return - 1 ; }
int maximumSum ( int arr [ ] , int n , int k ) { for ( int i = 1 ; i <= k ; i ++ ) { int min = INT_MAX ; int index = - 1 ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] < min ) { min = arr [ j ] ; index = j ; } } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; } return sum ; }
void printSquares ( int n ) { int square = 0 , odd = 1 ; for ( int x = 0 ; x < n ; x ++ ) { cout << square << odd << 2 ; } }
int numberOfPaths ( int m , int n ) { if ( m == 1 || n == 1 ) return 1 ; return numberOfPaths ( m - 1 , n ) + numberOfPaths ( m , n - 1 ) ; }
int binarySearch ( int * arr , int l , int r , int x ) { if ( r >= l ) { int mid = ( l + r ) / 2 ; if ( arr [ mid ] == x ) return mid ; else if ( arr [ mid ] > x ) return binarySearch ( arr , l , mid - 1 , x ) ; else if ( arr [ mid ] > x ) return binarySearch ( arr , mid + 1 , r , x ) ; else return - 1 ; }
int numberOfPaths ( int m , int n ) { int count [ m ] [ n ] ; for ( int i = 0 ; i < m ; i ++ ) count [ i ] [ 0 ] = 1 ; for ( int j = 0 ; j < n ; j ++ ) count [ 0 ] [ j ] = 1 ; for ( int i = 1 ; i < m ; i ++ ) for ( int j = 1 ; j < n ; j ++ ) count [ 0 ] [ j ] = 1 ; for ( int i = 1 ; i < m ; i ++ ) for ( int j = 1 ; j < n ; j ++ ) count [ i ] [ j ] = count [ i - 1 ] [ j ] + count [ i ] [ j - 1 ] ; return count [ m - 1 ] [ n - 1 ] ; }
int answer ( int n ) { int dp [ n + 1 ] [ 10 ] ; if ( n == 1 ) return 10 ; for ( int j = 0 ; j <= 9 ; j ++ ) dp [ 1 ] [ j ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= 9 ; j ++ ) dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] ; else if ( j == 0 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] ; } } int sum = 0 ; for ( int j = 1 ; j <= n ; j ++ ) sum = sum + dp [ n ] [ j ] ; return sum ; }
void recaman ( int n ) { int arr [ n ] ; arr [ 0 ] = 0 ; cout << arr [ 0 ] << " ▁ " ; for ( int i = 1 ; i < n ; i ++ ) { int curr = arr [ i - 1 ] - i ; for ( int j = 0 ; j < i ; j ++ ) { if ( ( arr [ j ] == curr ) || curr < 0 ) { curr = arr [ i - 1 ] + i ; break ; } } arr [ i ] = curr ; cout << arr [ i ] << " , ▁ " ; } }
int modInverse ( int a , int m ) { a = a % m ; for ( int x = 1 ; x < m ; x ++ ) if ( ( a * x ) % m == 1 ) return x ; return 1 ; }
int lenghtOfLongestAP ( int * set , int n ) { if ( n <= 2 ) return n ; int L [ n ] [ n - 1 ] ; for ( int i = 0 ; i < n ; i ++ ) L [ i ] [ n - 1 ] = 2 ; for ( int j = n - 2 ; j >= 0 ; j -- ) { int i = j - 1 ; int k = j + 1 ; while ( i >= 0 && k <= n - 1 ) { if ( set [ i ] + set [ k ] < 2 * set [ j ] ) k ++ ; else L [ i ] [ j ] = L [ j ] [ k ] + 1 ; llap = max ( llap , L [ i ] [ j ] ) ; i -- ; k ++ ; } } return llap ; }
int findIndex ( int n ) { if ( n <= 1 ) return n ; int a = 0 , b = 1 , c = 1 ; int res = 1 ; while ( c < n ) { c = a + b ; res = res + 1 ; a = b ; b = c ; } return res ; }
int maxSumPairWithDifferenceLessThanK ( int arr [ ] , int N , int k ) { int maxSum = 0 ; sort ( arr , arr + N ) ; for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( arr [ i ] - arr [ i - 1 ] < k ) maxSum += arr [ i ] ; maxSum += arr [ i - 1 ] ; } return maxSum ; }
int calculateEnergy ( int mat [ ] [ MAX ] , int n ) { int tot_energy = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { int q = mat [ i ] [ j ] / n ; int i_des = q ; int j_des = q ; tot_energy += ( abs ( i_des - i ) + abs ( j_des - j ) ) ; } } return tot_energy ; }
void antiSpiralTraversal ( int m , int n , int a [ R ] [ C ] ) { int i , k = 0 , l = 0 ; vector < int > stk ; for ( i = l ; i <= n ; ++ i ) { stk . push ( a [ k ] [ i ] ) ; } k ++ ; for ( i = k ; i <= m ; ++ i ) { stk . push ( a [ i ] [ n ] ) ; } n -- ; if ( k <= m ) { for ( i = n ; i <= l ; -- i ) { stk . push ( a [ m ] [ i ] ) ; m -- ; } if ( l <= n ) { for ( i = m ; i >= k ; -- i ) { stk . push ( a [ i ] [ l ] ) ; } l ++ ; } } while ( stk . empty ( ) ) cout << " ▁ " ; }
int findMaxVal ( int arr [ ] , int n , int num , int maxLimit ) { int ind = - 1 , val = - 1 ; int dp [ n ] [ maxLimit + 1 ] ; for ( ind = 0 ; ind < n ; ind ++ ) dp [ 0 ] [ i ] = 1 ; for ( val = 0 ; val < maxLimit ; val ++ ) dp [ 0 ] [ val ] = 0 ; for ( ind = 1 ; ind < n ; ind ++ ) { for ( val = 1 ; val < maxLimit ; val ++ ) { if ( num - arr [ ind ] == val || num + arr [ ind ] == val ) dp [ ind ] [ val ] = 1 ; else dp [ ind ] [ val ] = 0 ; } } for ( val = maxLimit ; val >= 0 && val + arr [ ind ] <= maxLimit ; val ++ ) { if ( dp [ ind - 1 ] [ val - arr [ ind ] ] == 1 || dp [ ind - 1 ] [ val + arr [ ind ] ] == 1 ) dp [ ind ] [ val ] = dp [ ind - 1 ] [ val - arr [ ind ] ] ; else dp [ ind ] [ val ] = dp [ ind - 1 ] [ val + arr [ ind ] ] ; } } return - 1 ; }
int Resources ( int process , int need ) { int minResources = 0 ; minResources = process * ( need - 1 ) + 1 ; return minResources ; }
int countIntegralSolutions ( int n ) { int result = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { for ( int k = 0 ; k <= n ; k ++ ) if ( i + j + k == n ) result ++ ; } } return result ; }
int minCost ( int cost [ ] [ N ] ) { int dist [ N ] ; memset ( dist , 0 , sizeof dist ) ; for ( int i = 0 ; i < N ; i ++ ) dist [ i ] = INF ; dist [ 0 ] = 0 ; for ( int i = 1 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( dist [ j ] > dist [ i ] + cost [ i ] [ j ] ) dist [ j ] = dist [ i ] + cost [ i ] [ j ] ; } } return dist [ N - 1 ] ; }
int countDivisibles ( int arr [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] % arr [ j ] == 0 || arr [ j ] % arr [ i ] == 0 ) res ++ ; } return res ; }
void pairSum ( int mat [ ] [ MAX ] , int n , int sum ) { for ( int i = 0 ; i < n ; i ++ ) sort ( mat [ i ] , mat [ i + 1 ] ) ; for ( int i = 0 ; i < n - 2 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int left = 0 , right = n - 1 ; while ( left < n && right >= 0 ) { if ( ( mat [ i ] [ left ] + mat [ j ] [ right ] ) == sum ) cout << " ( " << mat [ i ] [ left ] << " , ▁ " << mat [ j ] [ right ] << " ) << ▁ " ; left ++ ; right -- ; } else { if ( ( mat [ i ] [ left ] + mat [ j ] [ right ] ) < sum ) left ++ ; else right -- ; } } }
bool isPowerOfFour ( int n ) { if ( n == 0 ) return false ; while ( n != 1 ) { if ( n % 4 != 0 ) return false ; n = n / 4 ; } return true ; }
int distancesum ( int x [ ] , int y [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) sum += ( abs ( x [ i ] - x [ j ] ) + abs ( y [ i ] - y [ j ] ) ) ; } return sum ; }
void findMax ( int arr [ ] [ N ] ) { int row = 0 , j = N - 1 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] [ j ] == 1 ) { row = i ; j -- ; } } cout << " Row ▁ number ▁ = ▁ " << row + 1 << " , ▁ MaxCount ▁ = ▁ " << N - 1 - j << endl ; }
int lastNon0Digit ( int n ) { if ( n < 10 ) return dig [ n ] ; if ( ( ( n / 10 ) % 10 ) % 2 == 0 ) return 6 * lastNon0Digit ( n / 5 ) * dig [ n % 10 ] ; else return 4 * lastNon0Digit ( n / 5 ) * dig [ n % 10 ] ; }
int search ( int arr [ ] , int n , int x ) { int i ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == x ) return i ; i += abs ( arr [ i ] - x ) ; } cout << " number ▁ is ▁ not ▁ present ! " ; return - 1 ; }
void printHosoya ( int n ) { int dp [ N ] [ N ] ; memset ( dp , 0 , sizeof ( dp ) ) ; dp [ 0 ] [ 0 ] = dp [ 1 ] [ 0 ] = dp [ 1 ] [ 1 ] = 1 ; for ( int i = 2 ; i < n ; i ++ ) dp [ 0 ] [ 0 ] = dp [ 1 ] [ 0 ] = dp [ 0 ] [ 1 ] = 1 ; for ( int i = 2 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i > j ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 2 ] [ j ] ; else dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 2 ] [ j - 2 ] ; } } for ( int i = 0 ; i <= n ; i ++ ) cout << dp [ i ] [ j ] << ' ▁ ' ; cout << endl ; }
void insertionSortRecursive ( int arr [ ] , int n ) { if ( n <= 1 ) return ; insertionSortRecursive ( arr , n - 1 ) ; int j , last = arr [ n - 1 ] ; for ( j = n - 2 ; j >= 0 && arr [ j ] > last ; j -- ) arr [ j + 1 ] = arr [ j ] ; arr [ j + 1 ] = last ; }
int nthTerm ( int n ) { return ( n * n ) + ( n * n * n ) ; }
int findMaxAverage ( int arr [ ] , int n , int k ) { if ( k > n ) return - 1 ; int sum = arr [ 0 ] ; for ( int i = 1 ; i < k ; i ++ ) sum += arr [ i ] ; int max_sum = sum ; int max_end = k - 1 ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + arr [ i ] - arr [ i - k ] ; if ( sum > max_sum ) { max_sum = sum ; max_end = i ; } } return max_end - k + 1 ; }
int sumOfSeries ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum = sum + ( 2 * i - 1 ) * ( 2 * i - 1 ) ; return sum ; }
void printString ( char str [ ] , char ch , int count ) { int occ = 0 ; if ( count == 0 ) cout << str << " \n " ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] == ch ) ++ occ ; if ( occ == count ) break ; if ( i < str . length ( ) - 1 ) cout << str [ i + 1 ] ; else cout << " Empty ▁ string " ; } }
void printPascal ( int n ) { int arr [ n ] [ n ] ; for ( int line = 0 ; line < n ; line ++ ) { for ( int i = 0 ; i < line ; i ++ ) { if ( i is 0 || i is line ) { arr [ line ] [ i ] = 1 ; cout << arr [ line ] [ i ] << " ▁ " ; } else { arr [ line ] [ i ] = ( arr [ line - 1 ] [ i - 1 ] + arr [ line - 1 ] [ i ] ) ; cout << arr [ line ] [ i ] << " ▁ " ; } } cout << " \n " ; }
int answer_query ( char a [ ] , int n , int l , int r ) { int count = 0 ; for ( int i = l ; i < r ; i ++ ) if ( a [ i ] == a [ i + 1 ] ) count ++ ; return count ; }
int compute_average ( int a , int b ) { return ( a + b ) / 2 ; }
void findElements ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) if ( arr [ j ] > arr [ i ] ) ++ count ; if ( count >= 2 ) cout << arr [ i ] << " ▁ " ; } }
int possibleStrings ( int n , int r , int b , int g ) { int fact [ n + 1 ] ; fact [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) fact [ i ] = fact [ i - 1 ] * i ; int left = n - ( r + g + b ) ; int sum = 0 ; for ( int i = 0 ; i <= left ; i ++ ) { for ( int j = 0 ; j < left - i ; j ++ ) { int k = left - ( i + j ) ; sum = sum + fact [ n ] / ( fact [ i + r ] * fact [ j + b ] * fact [ k + g ] ) ; } } return sum ; }
int maxPathSum ( int tri [ ] [ MAX ] , int m , int n ) { for ( int i = m - 1 ; i >= 0 ; i -- ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( tri [ i + 1 ] [ j ] > tri [ i + 1 ] [ j + 1 ] ) { tri [ i ] [ j ] += tri [ i + 1 ] [ j ] ; else { tri [ i ] [ j ] += tri [ i + 1 ] [ j + 1 ] ; } } } return tri [ 0 ] [ 0 ] ; }
int fun ( int n ) { return n & ( n - 1 ) ; }
int mirrorImage ( int a , int b , int c , int x1 , int y1 ) { int temp = ( a * x1 + b * y1 + c ) / ( a * a + b * b ) ; int x = temp * a + x1 ; int y = temp * b + y1 ; return ( x , y ) ; }
int printIntersection ( int arr1 [ ] , int arr2 [ ] , int m , int n ) { int i = 0 , j = 0 ; while ( i < m && j < n ) { if ( arr1 [ i ] < arr2 [ j ] ) i ++ ; else if ( arr2 [ j ] < arr1 [ i ] ) j ++ ; else cout << arr2 [ j ++ ] << " ▁ " ; } }
int rotateMatrix ( int mat [ R ] [ C ] ) { if ( mat == NULL ) return ; int top = 0 , bottom = mat . size ( ) - 1 ; int left = 0 , right = mat [ 0 ] [ C ] ; int prev = mat [ top + 1 ] [ left ] ; while ( left < right && top < bottom ) { for ( int i = left ; i <= right ; i ++ ) { int curr = mat [ top ] [ i ] ; mat [ top ] [ i ] = prev ; prev = curr ; } top ++ ; for ( int i = top ; i <= bottom ; i ++ ) { int curr = mat [ i ] [ right ] ; mat [ i ] [ right ] = prev ; prev = curr ; } right -- ; for ( int i = bottom ; i >= top - 1 ; i -- ) { curr = mat [ bottom ] [ i ] ; mat [ bottom ] [ i ] = prev ; prev = curr ; } } return mat ; }
void rearrange ( int arr [ ] , int n ) { int max_idx = n - 1 ; int min_idx = 0 ; int max_elem = arr [ n - 1 ] + 1 ; int i ; for ( i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) arr [ i ] += ( arr [ max_idx ] % max_elem ) * max_elem ; max_idx -- ; else { arr [ i ] += ( arr [ min_idx ] % max_elem ) * max_elem ; min_idx ++ ; } } for ( i = 0 ; i < n ; i ++ ) { arr [ i ] = arr [ i ] / max_elem ; } }
void printTreeEdges ( int prufer [ ] , int m ) { int vertices = m + 2 ; int vertex_set [ vertices ] ; for ( int i = 0 ; i < vertices - 2 ; i ++ ) vertex_set [ prufer [ i ] - 1 ] ++ ; cout << " The ▁ edge ▁ set ▁ E ( G ) ▁ is ▁ : \n " ; for ( int i = 0 ; i < vertices - 2 ; i ++ ) { for ( int j = 0 ; j < vertices ; j ++ ) { if ( vertex_set [ j ] == 0 ) vertex_set [ j ] = - 1 ; cout << " ( " << ( j + 1 ) << " , ▁ " << prufer [ i ] << " ) ▁ " << endl ; break ; } } int j = 0 ; for ( int i = 0 ; i < vertices ; i ++ ) { if ( vertex_set [ i ] == 0 && j == 0 ) cout << " ( " << ( i + 1 ) << " , ▁ " << prufer [ i ] << " ) ▁ " << endl ; } }
int countDecodingDP ( char digits [ ] , int n ) { int count [ n + 1 ] ; count [ 0 ] = 1 , count [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { count [ i ] = 0 ; if ( digits [ i - 1 ] > '0' ) count [ i ] = count [ i - 1 ] ; if ( digits [ i - 2 ] == '1' || ( digits [ i - 2 ] == '2' && digits [ i - 1 ] < '7' ) count [ i ] += count [ i - 2 ] ; } return count [ n ] ; }
int largest ( int arr [ ] , int n ) { int max = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; } return max ; }
void transpose ( int A [ ] [ N ] , int B [ ] [ N ] ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) B [ i ] [ j ] = A [ j ] [ i ] ; }
int sumEqualProduct ( int a [ ] , int n ) { int zero = 0 , two = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) zero ++ ; if ( a [ i ] == 2 ) two ++ ; } int cnt = ( zero * ( zero - 1 ) ) / 2 + \ NEW_LINE INDENT ( two * ( two - 1 ) ) / 2 ; return cnt ; }
bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 || n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
void fib ( int n ) { int a = 0 , b = 1 ; if ( n >= 0 ) cout << a << ' ▁ ' ; if ( n >= 1 ) cout << b << ' ▁ ' ; for ( int i = 2 ; i <= n ; i ++ ) cout << a + b << ' ▁ ' ; if ( n >= 2 ) cout << b << a << ' ▁ ' ; }
void thirdLargest ( int arr [ ] , int arr_size ) { if ( arr_size < 3 ) cout << " ▁ Invalid ▁ Input ▁ " << endl ; int first = arr [ 0 ] ; for ( int i = 1 ; i < arr_size ; i ++ ) first = arr [ i ] ; int second = INT_MIN ; for ( int i = 0 ; i < arr_size ; i ++ ) { if ( arr [ i ] > second && arr [ i ] < first ) second = arr [ i ] ; } int third = INT_MAX ; for ( int i = 0 ; i < arr_size ; i ++ ) { if ( arr [ i ] > third && arr [ i ] < second ) third = arr [ i ] ; } cout << " The ▁ Third ▁ Largest " << " element ▁ is ▁ " << third ; }
int maxHamming ( int arr [ ] , int n ) { int brr [ n ] ; for ( int i = 0 ; i < n ; i ++ ) brr [ i ] = arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) brr [ n + i ] = arr [ i ] ; for ( int i = 1 ; i < n ; i ++ ) { int currHam = 0 , k = 0 ; for ( int j = i ; j < n ; j ++ ) if ( brr [ j ] != arr [ k ] ) currHam ++ ; k ++ ; } if ( currHam == n ) return n ; maxHam = max ( maxHam , currHam ) ; } return maxHam ; }
int findSum ( int n , int K ) { int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) ans += ( i % K ) ; return ans ; }
double seriesSum ( int n ) { int i = 1 ; double res = 0.0 ; bool sign = true ; while ( n > 0 ) { n -- ; if ( sign ) { sign = false ; res = res + ( i + 1 ) / ( i + 2 ) ; i = i + 2 ; } else { sign = true ; res = res - ( i + 1 ) / ( i + 2 ) ; i = i + 2 ; } } return res ; }
bool isDiagonalMatrix ( int mat [ ] [ N ] ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( ( i != j ) && ( mat [ i ] [ j ] != 0 ) ) return false ; } } return true ; }
int getSingle ( int arr [ ] , int n ) { int ones = 0 , twos = 0 ; for ( int i = 0 ; i < n ; i ++ ) { twos = twos | ( ones & arr [ i ] ) ; ones = ones ^ arr [ i ] ; common_bit_mask = ~ ( ones & twos ) ; ones &= common_bit_mask ; twos &= common_bit_mask ; } return ones ; }
int countNum ( int arr [ ] , int n ) { int count = 0 ; sort ( arr , arr + n ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] != arr [ i + 1 ] && arr [ i ] != arr [ i + 1 ] - 1 ) count += arr [ i + 1 ] - arr [ i ] - 1 ; } return count ; }
int CountSquares ( int a , int b ) { int cnt = 0 ; for ( int i = a ; i <= b ; i ++ ) { int j ; for ( j = 1 ; j * j <= i ; j ++ ) if ( j * j == i ) cnt ++ ; } return cnt ; }
int minSum ( int n ) { int sum = 0 ; while ( n > 0 ) { sum += ( n % 10 ) ; n /= 10 ; if ( sum == 1 ) return 10 ; return sum ; }
int nonFibonacci ( int n ) { int prevPrev = 1 , prev = 2 , curr = 3 ; while ( n > 0 ) { prevPrev = prev ; prev = curr ; curr = prevPrev + prev ; n = n - ( curr - prev - 1 ) ; } return prev + n ; }
void leftRotate ( int arr [ ] , int n , int k ) { for ( int i = k ; i < k + n ; i ++ ) cout << arr [ i % n ] << " ▁ " ; }
string repeat ( string s , int n ) { string s1 = s ; for ( int i = 1 ; i < n ; i ++ ) s += s1 ; return s ; }
int findStep ( int n ) { if ( n == 1 || n == 0 ) return 1 ; else if ( n == 2 ) return 2 ; else return findStep ( n - 3 ) + findStep ( n - 2 ) + findStep ( n - 1 ) ; }
int CountPS ( char * str , int n ) { int dp [ n ] [ n ] ; bool P [ n ] [ n ] ; int i , j , k , L ; for ( i = 0 ; i < n ; i ++ ) { P [ i ] [ i ] = true ; dp [ i ] [ i + 1 ] = 1 ; } for ( gap = 2 ; gap < n ; gap ++ ) { for ( i = 0 ; i < n - gap ; i ++ ) { if ( str [ i ] == str [ j ] && P [ i + 1 ] [ j - 1 ] ) P [ i ] [ j ] = true ; else dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] - dp [ i + 1 ] [ j - 1 ] ; } } return dp [ 0 ] [ n - 1 ] ; }
void modularEquation ( int a , int b ) { if ( a < b ) cout << " No ▁ solution ▁ possible ▁ " << endl ; if ( a == b ) cout << " Infinite ▁ Solution ▁ possible ▁ " << endl ; return ; } int count = 0 ; for ( int i = 1 ; i <= y ; i ++ ) { if ( n % i == 0 ) { if ( n / i > b ) count ++ ; if ( i > b ) count ++ ; } } if ( y * y == n && y > b ) count -- ; cout << count ; }
int maxSum ( int mat [ ] [ MAX ] , int n ) { if ( n == 1 ) return mat [ 0 ] [ 0 ] ; int dp [ n ] [ n ] ; int maxSum = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) dp [ 0 ] [ i ] = mat [ 0 ] [ i ] ; for ( int i = 1 ; i < n - 2 ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) { int maxi = INT_MIN ; if ( ( ( j - 1 ) >= 0 ) && ( maxi < dp [ i + 1 ] [ j - 1 ] ) ) maxi = dp [ i + 1 ] [ j - 1 ] ; if ( ( ( j + 1 ) < n ) maxi = dp [ i + 1 ] [ j + 1 ] ; dp [ i ] [ j ] = mat [ i ] [ j ] + maxi ; } } for ( int j = 0 ; j < n ; j ++ ) { if ( maxSum < dp [ 0 ] [ j ] ) maxSum = dp [ 0 ] [ j ] ; } } return maxSum ; }
double arcLength ( double diameter , double angle ) { if ( angle >= 360 ) cout << " Angle ▁ cannot ▁ be ▁ formed " ; else arc = ( 3.142857142857143 * diameter ) * ( angle / 360.0 ) ; return arc ; }
bool isPrime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i <= n ; i ++ ) if ( n % i == 0 ) return false ; return true ; }
int findMaxAverage ( int arr [ ] , int n , int k ) { if ( k > n ) return - 1 ; int csum [ n ] ; csum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) csum [ i ] = csum [ i - 1 ] + arr [ i ] ; int max_sum = csum [ k - 1 ] ; int max_end = k - 1 ; for ( int i = 0 ; i < k ; i ++ ) { int curr_sum = csum [ i ] - csum [ i - k ] ; if ( curr_sum > max_sum ) { max_sum = curr_sum ; max_end = i ; } } return max_end - k + 1 ; }
int horner ( int poly [ ] , int n , int x ) { int result = poly [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) result = result * x + poly [ i ] ; return result ; }
int numberOfWays ( int x ) { if ( x == 0 || x == 1 ) return 1 ; else return numberOfWays ( x - 1 ) + ( x - 1 ) * numberOfWays ( x - 2 ) ; }
int maxRowDiff ( int mat [ ] [ MAX ] , int m , int n ) { int rowSum [ m ] ; for ( int i = 0 ; i < m ; i ++ ) sum = 0 ; for ( int j = 0 ; j < n ; j ++ ) sum += mat [ i ] [ j ] ; rowSum [ i ] = sum ; int max_diff = rowSum [ 1 ] - rowSum [ 0 ] ; int min_element = rowSum [ 0 ] ; for ( int i = 1 ; i < m ; i ++ ) { if ( rowSum [ i ] - min_element > max_diff ) max_diff = rowSum [ i ] - min_element ; if ( rowSum [ i ] < min_element ) min_element = rowSum [ i ] ; } return max_diff ; }
int minCost ( int cost [ ] [ C ] , int m , int n ) { int tc [ R ] [ C ] ; tc [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] ; for ( int i = 1 ; i <= m ; i ++ ) tc [ i ] [ 0 ] = tc [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ] ; for ( int j = 1 ; j <= n ; j ++ ) tc [ 0 ] [ j ] = tc [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ] ; for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) tc [ i ] [ j ] = min ( tc [ i - 1 ] [ j - 1 ] , tc [ i - 1 ] [ j ] , tc [ i ] [ j - 1 ] ) + cost [ i ] [ j ] ; } return tc [ m ] [ n ] ; }
int count_of_ways ( int n ) { int count = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { for ( int k = 0 ; k <= n ; k ++ ) if ( i + j + k == n ) count ++ ; } } return count ; }
int countCommon ( int mat [ ] [ MAX ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( mat [ i ] [ i ] == mat [ i ] [ n - i - 1 ] ) res ++ ; return res ; }
int hexagonalNum ( int n ) { return n * ( 2 * n - 1 ) ; }
int findGreatest ( int arr [ ] , int n ) { int result = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n - 1 ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) if ( arr [ j ] * arr [ k ] == arr [ i ] ) result = max ( result , arr [ i ] ) ; } } return result ; }
int squareRoot ( int n , int p ) { n = n % p ; for ( int x = 2 ; x < p ; x ++ ) { if ( ( x * x ) % p == n ) cout << " Square ▁ root ▁ is ▁ " << x ; return ; } cout << " Square ▁ root ▁ doesn't exist " ; }
int leonardo ( int n ) { int dp [ n + 1 ] ; dp . push ( 1 ) ; dp . push ( 1 ) ; for ( int i = 2 ; i <= n ; i ++ ) dp . push ( dp [ i - 1 ] + dp [ i - 2 ] + 1 ) ; return dp [ n ] ; }
unsigned long evenbinomialCoeffSum ( int n ) { return ( 1 << ( n - 1 ) ) ; }
int findMin ( int * arr , int low , int high ) { if ( high < low ) return arr [ 0 ] ; if ( high == low ) { printf ( " The ▁ required ▁ element ▁ is ▁ % d ▁ " , arr [ low ] ) ; return arr [ low ] ; } int mid = ( low + high ) / 2 ; if ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) return arr [ mid + 1 ] ; if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) return findMin ( arr , low , mid - 1 ) ; if ( arr [ high ] > arr [ mid ] ) return findMin ( arr , low , mid + 1 , high ) ; }
int findS ( int s ) { int _sum = 0 ; int n = 1 ; while ( _sum < s ) { _sum += n * n ; n ++ ; } if ( _sum == s ) return n ; return - 1 ; }
int countStr ( int n ) { return 1 + ( n * 2 ) + ( n * ( ( n * n ) - 1 ) / 2 ) ; }
void printSumSimple ( int mat [ ] [ MAX ] , int k , int n ) { if ( k > n ) return ; for ( int i = 0 ; i <= k ; i ++ ) { for ( int j = 0 ; j <= n - k ; j ++ ) { int sum = 0 ; for ( int p = 0 ; p <= i ; p ++ ) for ( int q = 0 ; q <= j ; q ++ ) sum += mat [ p ] [ q ] ; cout << sum << " ▁ " ; } cout << endl ; } }
int countGroups ( int position , int previous_sum , int length , int num [ ] ) { if ( position == length ) return 1 ; if ( dp [ position ] [ previous_sum ] != - 1 ) return dp [ position ] [ previous_sum ] ; int res = 0 ; int sum = 0 ; for ( int i = position ; i < length ; i ++ ) { sum += ( num [ i ] - '0' ) ; if ( sum >= previous_sum ) res += countGroups ( i + 1 , sum , length , num ) ; } dp [ position ] [ previous_sum ] = res ; } return res ; }
int intersection ( int n ) { return n * ( n - 1 ) ; }
int findSum ( int n ) { n -- ; int sum = 0 ; sum += n * ( n + 1 ) * ( 2 * n + 1 ) ; sum += ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; return sum ; }
int findRepeatingElement ( int * arr , int low , int high ) { if ( low > high ) return - 1 ; int mid = ( low + high ) / 2 ; if ( arr [ mid ] != mid + 1 ) { if ( mid > 0 && arr [ mid ] == arr [ mid - 1 ] ) return mid ; return findRepeatingElement ( arr , low , mid - 1 ) ; } return findRepeatingElement ( arr , mid + 1 , high ) ; }
int maxAverageOfPath ( int cost [ ] [ N ] ) { int dp [ N ] [ N + 1 ] ; dp [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] ; for ( int i = 1 ; i <= N ; i ++ ) dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ] ; for ( int j = 1 ; j <= N ; j ++ ) dp [ 0 ] [ j ] = dp [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ] ; for ( int i = 1 ; i <= N ; i ++ ) for ( int j = 1 ; j <= N ; j ++ ) dp [ 0 ] [ j ] = dp [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ] ; for ( int i = 1 ; i <= N ; i ++ ) for ( int j = 1 ; j <= N ; j ++ ) dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) + cost [ i ] [ j ] ; return dp [ N - 1 ] [ N - 1 ] / ( 2 * N - 1 ) ; }
int countPairsWithDiffK ( int arr [ ] , int n , int k ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] - arr [ j ] == k || arr [ j ] - arr [ i ] == k ) count ++ ; } return count ; }
bool isPrime ( int n , int i = 2 ) { if ( n <= 2 ) return true if ( n == 2 ) else false ; if ( n % i == 0 ) return false ; if ( i * i > n ) return true ; return isPrime ( n , i + 1 ) ; }
int computeLastDigit ( int A , int B ) { int variable = 1 ; if ( A == B ) return 1 ; else if ( ( B - A ) >= 5 ) return 0 ; else { for ( int i = A + 1 ; i <= B ; i ++ ) variable = ( variable * ( i % 10 ) ) % 10 ; return variable % 10 ; } }
bool check ( int n ) { return 1162261467 % n == 0 ; }
int sequence ( int n ) { if ( n == 1 || n == 2 ) return 1 ; else return sequence ( n - 1 ) ) + sequence ( n - sequence ( n - 1 ) ) ; }
int findHeight ( int parent [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int p = i ; int current = 1 ; while ( parent [ p ] != - 1 ) current ++ ; res = max ( res , current ) ; } return res ; }
int HalfDiagonalSums ( int mat [ ] [ MAX ] , int n ) { int diag1_left = 0 , diag1_right = 0 , diag2_left = 0 , diag2_right = 0 ; int i = 0 , j = n - 1 ; while ( i < n ) { if ( i < n / 2 ) { diag1_left += mat [ i ] [ i ] ; diag2_left += mat [ j ] [ i ] ; } else if ( i > n / 2 ) { diag1_right += mat [ i ] [ i ] ; diag2_right += mat [ j ] [ i ] ; } i ++ ; j -- ; } return ( diag1_left == diag2_right && diag2_left == diag2_left && diag1_right == diag2_right && diag1_right == diag2_left && diag2_right == mat [ n / 2 ] [ n / 2 ] ) ; }
void LeibnizHarmonicTriangle ( int n ) { int C [ n ] [ n + 1 ] ; int i , j ; for ( i = 0 ; i <= n ; i ++ ) C [ i ] [ 0 ] = 1 ; for ( j = 0 ; j <= min ( i , n ) ; j ++ ) C [ 0 ] [ j ] = 0 ; for ( i = 1 ; i <= n ; i ++ ) { for ( j = 1 ; j <= i ; j ++ ) { if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) ; } } for ( i = 1 ; i <= n ; i ++ ) cout << " 1 / " << endl ; for ( j = 1 ; j <= i ; j ++ ) cout << i * C [ i - 1 ] [ j - 1 ] << " ▁ " ; cout << endl ; }
int floorSearch ( int * arr , int low , int high , int x ) { if ( low > high ) return - 1 ; if ( x >= arr [ high ] ) return high ; int mid = ( low + high ) / 2 ; if ( arr [ mid ] == x ) return mid ; if ( mid > 0 && arr [ mid - 1 ] <= x && x < arr [ mid ] ) return mid - 1 ; if ( x < arr [ mid ] ) return floorSearch ( arr , low , mid - 1 , x ) ; return floorSearch ( arr , low , mid + 1 , high , x ) ; }
int minimumflip ( int mat [ ] [ MAX ] , int n ) { int flip = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) flip ++ ; } return flip ; }
int breakSum ( int n ) { if ( n == 0 || n == 1 ) return n ; return max ( ( breakSum ( n / 2 ) + breakSum ( n / 3 ) + breakSum ( n / 4 ) ) ; }
int countPairs ( int arr1 [ ] , int arr2 [ ] , int m , int n , int x ) { int count = 0 ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) if ( arr1 [ i ] + arr2 [ j ] == x ) count ++ ; } return count ; }
void alternateSubarray ( bool arr [ ] , int n ) { int len [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) len . push_back ( 0 ) ; len [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] ^ arr [ i + 1 ] == true ) len [ i ] = len [ i + 1 ] + 1 ; else len [ i ] = 1 ; } }
void subsequence ( char s [ ] , char t [ ] , int n , int k ) { int i , cnt = 0 ; int new_last = 0 , size = 0 ; string str = ' zyxwvutsrqponmlkjihgfedcba ' ; for ( ch = ' \0' ; ch < s . length ( ) ; ++ ch ) { cnt ++ ; for ( i = last ; i < n ; ++ i ) { if ( s [ i ] == ch ) ++ cnt ; if ( cnt >= k ) { for ( i = last ; i < n ; ++ i ) { if ( s [ i ] == ch ) ++ cnt ; } } last = new_last ; } }
int maxLen ( int arr [ ] ) { int max_len = 0 ; for ( int i = 0 ; i < arr . size ( ) ; i ++ ) { int curr_sum = 0 ; for ( int j = i ; j < arr . size ( ) ; j ++ ) { curr_sum += arr [ j ] ; if ( curr_sum == 0 ) max_len = max ( max_len , j - i + 1 ) ; } } return max_len ; }
int lcs ( int X [ ] , int Y [ ] , int m , int n ) { if ( m == 0 || n == 0 ) return 0 ; else if ( X [ m - 1 ] == Y [ n - 1 ] ) return 1 + lcs ( X , Y , m - 1 , n - 1 ) ; else if ( X [ m - 1 ] == Y [ n - 1 ] ) return 1 + lcs ( X , Y , m - 1 , n - 1 ) ; else return max ( lcs ( X , Y , m , n - 1 ) , lcs ( X , Y , m - 1 , n ) ) ; } }
int multiply ( int x , int y ) { if ( y == 0 ) return 0 ; if ( y > 0 ) return x + multiply ( x , y - 1 ) ; if ( y < 0 ) return - multiply ( x , - y ) ; }
int countP ( int n , int k ) { int dp [ k + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= k ; i ++ ) dp [ i ] [ 0 ] = 0 ; for ( int i = 0 ; i <= n ; i ++ ) dp [ 0 ] [ i ] = 0 ; for ( int i = 1 ; i <= k ; i ++ ) dp [ 0 ] [ k ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= k ; j ++ ) dp [ i ] [ j ] = 1 ; else dp [ i ] [ j ] = ( j * dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] ) ; } } return dp [ n ] [ k ] ; }
int maxvolume ( int s ) { int length = s / 3 ; s -= length ; int breadth = s / 2 ; int height = s - breadth ; return length * breadth * height ; }
int findLength ( string & str ) { int n = str . length ( ) ; int maxlen = 0 ; int sum [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) sum [ i ] [ i ] = str [ i ] ; for ( int length = 2 ; length <= n ; length ++ ) { for ( int i = 0 ; i < n - length + 1 ; i ++ ) { int j = i + length - 1 ; int k = length / 2 ; sum [ i ] [ j ] = sum [ i ] [ j - k ] + sum [ j - k + 1 ] [ j ] ; if ( length % 2 == 0 && sum [ i ] [ j - k ] == sum [ ( j - k + 1 ) ] [ j ] ) ; if ( length % 2 == 0 && sum [ i ] [ j - k ] == sum [ ( j - k + 1 ) ] [ j ] ) { maxlen = length ; } } } return maxlen ; }
int subArraySum ( int arr [ ] , int n , int sum ) { int curr_sum = arr [ 0 ] ; int start = 0 ; int i ; for ( i = 1 ; i <= n ; i ++ ) { while ( curr_sum > sum && start < i - 1 ) { curr_sum = curr_sum - arr [ start ] ; start ++ ; } if ( curr_sum == sum ) cout << " sum ▁ found ▁ between ▁ indexes " << endl ; if ( i < n ) curr_sum = curr_sum + arr [ i ] ; } cout << " No ▁ subarray ▁ found " ; return 0 ; }
void generateSquare ( int n ) { int magicSquare [ n ] [ n ] ; int i = n / 2 ; int j = n - 1 ; int num = 1 ; while ( num <= ( n * n ) ) { if ( i == - 1 && j == n ) { i = 0 ; } else { if ( i < 0 ) { i = n - 1 ; continue ; } else { magicSquare [ int ( i ) ] [ int ( j ) ] = num ; num = num + 1 ; } } cout << " Magic ▁ Squre ▁ for ▁ n ▁ = " << n << " \n " ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { cout << ' % 2d ▁ ' << magicSquare [ i ] [ j ] ) << ' ▁ ' ; if ( j == n - 1 ) cout << endl ; } }
int countOnes ( int * arr , int low , int high ) { if ( high >= low ) { int mid = ( low + high ) / 2 ; if ( ( mid == high || arr [ mid + 1 ] == 0 ) && ( arr [ mid ] == 1 ) ) return mid + 1 ; if ( arr [ mid ] == 1 ) return countOnes ( arr , ( mid + 1 ) , high ) ; return countOnes ( arr , low , mid - 1 ) ; } return 0 ; }
int ceilSearch ( int * arr , int low , int high , int x ) { if ( x <= arr [ low ] ) return low ; if ( x > arr [ high ] ) return - 1 ; int mid = ( low + high ) / 2 ; if ( arr [ mid ] == x ) return mid ; else if ( arr [ mid ] < x ) { if ( mid + 1 <= high && x <= arr [ mid + 1 ] ) return mid + 1 ; else return ceilSearch ( arr , mid + 1 , high , x ) ; } else { if ( mid - 1 >= low && x > arr [ mid - 1 ] ) return mid ; else return ceilSearch ( arr , low , mid - 1 , x ) ; } }
string decToBin ( int n ) { if ( n == 0 ) return "0" ; string bin = " " ; while ( n > 0 ) { if ( n & 1 == 0 ) bin = '0' + bin ; else bin = '1' + bin ; n = n >> 1 ; } return bin ; }
void printNos ( int n ) { if ( n > 0 ) cout << n << ' ▁ ' ; else cout << n << ' ▁ ' ; }
int eulerian ( int n , int m ) { if ( m >= n || n == 0 ) return 0 ; if ( m >= n || n == 0 ) return 1 ; return ( n - m ) * eulerian ( n - 1 , m - 1 ) + ( m + 1 ) * eulerian ( n - 1 , m ) ; }
int areaSquare ( int side ) { int area = side * side ; return area ; }
int spiralDiaSum ( int n ) { if ( n == 1 ) return 1 ; return 4 * n * n - 6 * n + 6 + spiralDiaSum ( n - 2 ) ; }
int countOccurrences ( int arr [ ] , int n , int x ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( x == arr [ i ] ) res ++ ; return res ; }
int doublefactorial ( int n ) { int res = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( i == 0 || i == 1 ) return res ; else res *= i ; } }
int lcs ( int X [ ] , int Y [ ] , int m , int n ) { if ( m == 0 || n == 0 ) return 0 ; else if ( X [ m - 1 ] == Y [ n - 1 ] ) return 1 + lcs ( X , Y , m - 1 , n - 1 ) ; else if ( X [ m - 1 ] == Y [ n - 1 ] ) return 1 + lcs ( X , Y , m - 1 , n - 1 ) ; else return max ( lcs ( X , Y , m , n - 1 ) , lcs ( X , Y , m - 1 , n ) ) ; } }
int offeringNumber ( int n , int templeHeight [ ] ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int left = 0 , right = 0 ; for ( int j = i - 1 ; j >= 0 ; j -- ) { if ( templeHeight [ j ] < templeHeight [ j + 1 ] ) left ++ ; else right ++ ; } for ( int j = i + 1 ; j < n ; j ++ ) { if ( templeHeight [ j ] < templeHeight [ j - 1 ] ) right ++ ; else break ; } sum += max ( right , left ) + 1 ; } return sum ; }
string constructPalin ( string str , int l ) { vector < char > str ; int i = - 1 , j = l ; while ( i < j ) { if ( str [ i ] == str [ j ] && str [ i ] != ' * ' ) continue ; if ( str [ i ] == str [ j ] && str [ i ] == ' * ' ) { string [ i ] = ' a ' ; string [ j ] = ' a ' ; continue ; } else if ( str [ i ] == str [ j ] && str [ i ] == ' * ' ) { string [ i ] = ' a ' ; string [ j ] = ' a ' ; continue ; } else if ( str [ i ] == ' * ' ) string [ i ] = string [ j ] ; continue ; } return str ; }
int countPairs ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] == arr [ j ] ) ans ++ ; } return ans ; }
int evenFib ( int n ) { if ( n < 1 ) return n ; if ( n == 1 ) return 2 ; return ( 4 * evenFib ( n - 1 ) ) + evenFib ( n - 2 ) ; }
int findSum ( int n ) { int sm = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = i + 1 ; j <= n ; j ++ ) sm = sm + i * j ; return sm ; }
unsigned int binomialCoeffSum ( int n ) { return 1 << n ; }
int printknapSack ( int W , int wt , int val [ ] , int n ) { int K [ n ] [ W ] ; for ( int i = 0 ; i <= n ; i ++ ) K [ i ] [ 0 ] = 0 ; for ( int i = 0 ; i <= W ; i ++ ) { for ( int w = 0 ; w <= n ; w ++ ) { if ( i == 0 || w == 0 ) K [ i ] [ w ] = 0 ; else K [ i ] [ w ] = K [ i - 1 ] [ w ] ; } } int res = K [ n ] [ W ] ; for ( int i = 0 ; i <= n ; i ++ ) { if ( res <= 0 ) break ; if ( res == K [ i - 1 ] [ w ] ) break ; if ( res == K [ i - 1 ] [ w ] ) continue ; else { cout << wt [ i - 1 ] ) ; res = res - val [ i - 1 ] ; w = w - wt [ i - 1 ] ; } } }
int getTotalNumberOfSequences ( int m , int n ) { int T [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) T [ i ] [ 0 ] = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 || j == 0 ) T [ i ] [ j ] = 0 ; else if ( i < j ) T [ i ] [ j ] = 0 ; else if ( j == 1 ) T [ i ] [ j ] = i ; else T [ i ] [ j ] = T [ i - 1 ] [ j ] + T [ i / 2 ] [ j - 1 ] ; } } return T [ m ] [ n ] ; }
int maxPrimeFactors ( int n ) { int maxPrime = - 1 ; while ( n % 2 == 0 ) maxPrime = 2 ; n >>= 1 ; for ( int i = 3 ; i <= 2 ; i ++ ) { while ( n % i == 0 ) maxPrime = i ; n = n / i ; } if ( n > 2 ) maxPrime = n ; } return int ( maxPrime ) ; }
int remainderWith7 ( int num ) { int series [ 6 ] ; int series_index = 0 ; int result = 0 ; for ( int i = 0 ; i < ( num . length ( ) - 1 ) ; i ++ ) { digit = num [ i ] - 48 ; result += digit * series [ series_index ] ; series_index = ( series_index + 1 ) % 6 ; result %= 7 ; } if ( result < 0 ) result = ( result + 7 ) % 7 ; return result ; }
int getRemainder ( int num , int divisor ) { return ( num - divisor * ( num / divisor ) ) ; }
int getSum ( int n ) { int sum = 0 ; while ( n != 0 ) { sum = sum + n % 10 ; n = n / 10 ; } return sum ; }
void fill0X ( int m , int n ) { int i , k = 0 , l = 0 , r = m , c = n ; int a [ m ] [ n ] ; char x = ' X ' ; while ( k < m && l < n ) { for ( i = l ; i < n ; ++ i ) { a [ k ] [ i ] = x ; } k ++ ; for ( i = k ; i < m ; ++ i ) { a [ i ] [ n - 1 ] = x ; } n -- ; if ( k < m ) { for ( i = n - 1 ; i >= l ; -- i ) { a [ m - 1 ] [ i ] = x ; } m -- ; } if ( l < n ) { for ( i = m - 1 ; i >= k ; -- i ) { a [ i ] [ l ] = x ; } l ++ ; } x = ' X ' if ( x == '0' ) cout << a [ i ] [ j ] << " ▁ " ; } cout << endl ; }
float slope ( int x1 , int y1 , int x2 , int y2 ) { return ( float ) ( y2 - y1 ) / ( x2 - x1 ) ; }
int countNegative ( int M [ ] [ MAX ] , int n , int m ) { int count = 0 ; int i = 0 , j = m - 1 ; while ( j >= 0 && i < n ) { if ( M [ i ] [ j ] < 0 ) count += ( j + 1 ) ; i ++ ; } return count ; }
int maxSumIS ( int arr [ ] , int n ) { int max = 0 ; int msis [ n ] ; for ( int i = 0 ; i < n ; i ++ ) msis [ i ] = arr [ i ] ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ i ] > arr [ j ] && msis [ i ] < msis [ j ] + arr [ i ] ) msis [ i ] = msis [ j ] + arr [ i ] ; } } for ( int i = 0 ; i < n ; i ++ ) max = msis [ i ] ; } return max ; }
int maxLength ( string s , int n ) { int invalidOpenBraces = 0 , invalidCloseBraces = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ' ( ' ) invalidOpenBraces ++ ; else if ( invalidOpenBraces == 0 ) invalidCloseBraces ++ ; else if ( invalidOpenBraces == 0 ) invalidOpenBraces -- ; else invalidOpenBraces -- ; } return ( n - ( invalidOpenBraces + invalidCloseBraces ) ) ; }
void tower ( int n , int sourcePole , int destinationPole , int auxiliaryPole ) { if ( 0 == n ) return ; tower ( n - 1 , sourcePole , auxiliaryPole , destinationPole ) ; cout << " Move ▁ the ▁ disk " << sourcePole << " to ▁ " << destinationPole << " endl ; }
int findMaximumPieces ( int n ) { return 1 + n * ( n + 1 ) / 2 ; }
int findMinInsertions ( char * str , int l , int h ) { if ( l > h ) return INT_MAX ; if ( l == h ) return 0 ; if ( l == h - 1 ) return 1 ; if ( str [ l ] == str [ h ] ) return findMinInsertions ( str , l + 1 , h - 1 ) ; else if ( str [ l ] == str [ h ] ) return findMinInsertions ( str , l + 1 , h - 1 ) ; else return min ( findMinInsertions ( str , l , h - 1 ) , findMinInsertions ( str , l + 1 , h ) ) + 1 ; }
int octalToDecimal ( int n ) { int num = n ; int dec_value = 0 ; int base = 1 ; int temp ; num = num ; while ( temp ) { int last_digit = temp % 10 ; temp = temp / 10 ; dec_value += last_digit * base ; base = base * 8 ; } return dec_value ; }
void printSquares ( int n ) { int square = 0 , prev_x = 0 ; for ( int x = 0 ; x < n ; x ++ ) { square = ( square + x + prev_x ) ; cout << square << " ▁ " ; prev_x = x ; } }
void sequence ( int n ) { int f [ n + 1 ] ; cout << f [ 0 ] << " ▁ " << f [ 1 ] << " ▁ " << f [ 2 ] << " ▁ " << endl ; for ( int i = 3 ; i <= n ; i ++ ) { f . push ( f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ] ) ; cout << f [ i ] << " ▁ " ; } }
int maxSubsequenceSubstring ( int x [ ] , int y [ ] , int n , int m ) { int dp [ MAX ] [ MAX + 1 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; for ( int i = 0 ; i <= m ; i ++ ) dp [ i ] [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = i ; j <= m ; j ++ ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = dp [ i ] [ j - 1 ] ; } int ans = 0 ; for ( int i = 1 ; i <= m ; i ++ ) ans = max ( ans , dp [ i ] [ n ] ) ; return ans ; }
int getMedian ( int ar1 [ ] , int ar2 [ ] , int n ) { int i = 0 , j = 0 ; int m1 = - 1 , m2 = - 1 ; int count = 0 ; while ( count < n + 1 ) { if ( i == n ) { m1 = m2 ; m2 = ar2 [ 0 ] ; break ; } else if ( j == n ) { m1 = m2 ; m2 = ar1 [ 0 ] ; break ; } else { m1 = m2 ; m2 = ar2 [ j ] ; j ++ ; } } return ( m1 + m2 ) / 2 ; }
int countZeroes ( int mat [ ROW ] [ COL ] ) { int N = mat [ N ] . size ( ) ; int row = N - 1 ; int col = 0 ; int count = 0 ; while ( col < N ) { while ( mat [ row ] [ col ] ) { if ( row < 0 ) return count ; row -- ; } count = count + ( row + 1 ) ; col ++ ; } return count ; }
int solution ( int a , int b , int n ) { int i ; for ( i = 0 ; i * a <= n ; i ++ ) { if ( ( n - ( i * a ) ) % b == 0 ) cout << " x ▁ = ▁ " << i << " , ▁ y ▁ = ▁ " << int ( ( n - ( i * a ) ) / b ; return 0 ; }
int Circumference ( int a ) { return ( 4 * a ) ; }
int numberOfPaths ( int m , int n ) { int path = 1 ; for ( int i = n ; i <= ( m + n - 1 ) ; i ++ ) path *= i ; path /= ( i - n + 1 ) ; return path ; }
void pointClip ( int XY [ ] [ MAX ] , int n , int Xmin , int Ymin , int Xmax , int Ymax ) { cout << " Point ▁ inside ▁ the ▁ viewing ▁ pane : \n " ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( XY [ i ] [ 0 ] >= Xmin ) && ( XY [ i ] [ 0 ] <= Xmax ) ) cout << " [ " << XY [ i ] [ 0 ] << " , ▁ " << XY [ i ] [ 1 ] << " ] " ; } cout << " \n \n " ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( XY [ i ] [ 0 ] < Xmin ) || ( XY [ i ] [ 0 ] > Xmax ) ) cout << " [ " << XY [ i ] [ 0 ] << " , ▁ " << XY [ i ] [ 1 ] << " ] " << " ▁ " << endl ; } cout << " \n " ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( XY [ i ] [ 0 ] < Xmin ) || ( XY [ i ] [ 0 ] > Xmax ) ) cout << " [ " << XY [ i ] [ 0 ] << " , ▁ " << XY [ i ] [ 1 ] << " ] " << " ▁ " << " ▁ " << endl ; } }
int pre_compute ( int a [ ] , int n , int index , int k ) { int dp [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) dp [ 0 ] [ i ] = a [ i ] + a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] > a [ 0 ] ) dp [ 0 ] [ i ] = a [ i ] + a [ 0 ] ; else dp [ 0 ] [ i ] = a [ i ] ; } for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( a [ j ] > a [ i ] && j > i ) dp [ i ] [ j ] = dp [ i - 1 ] [ i ] + a [ j ] ; else dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; } } return dp [ index ] [ k ] ; }
void splitArr ( int arr [ ] , int n , int k ) { for ( int i = 0 ; i < k ; i ++ ) { int x = arr [ 0 ] ; for ( int j = 0 ; j < n - 1 ; j ++ ) arr [ j ] = arr [ j + 1 ] ; arr [ n - 1 ] = x ; } }
int smallestSubWithSum ( int arr [ ] , int n , int x ) { int curr_sum = 0 ; int min_len = n + 1 ; int start = 0 , end = 0 ; while ( end < n ) { while ( curr_sum <= x && end < n ) { if ( curr_sum <= 0 && x > 0 ) { start = end ; curr_sum = 0 ; } curr_sum += arr [ end ] ; end ++ ; } while ( curr_sum > x && start < n ) { if ( end - start < min_len ) min_len = end - start ; curr_sum -= arr [ start ] ; start ++ ; } } return min_len ; }
int winner ( int a [ ] , int n , int k ) { if ( k >= n - 1 ) return n ; int best = 0 ; int times = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > best ) { best = a [ i ] ; if ( i == true ) times ++ ; else times ++ ; } if ( times >= k ) return best ; } return best ; }
int countSolutions ( int n ) { int x = 0 , res = 0 ; int yCount = 0 ; while ( yCount * yCount < n ) yCount ++ ; while ( yCount != 0 && ( x * x + ( yCount - 1 ) * ( yCount - 1 ) >= n ) ) yCount -- ; return res ; }
int maxProduct ( int arr [ ] , int n ) { if ( n < 3 ) return - 1 ; int max_product = INT_MIN ; for ( int i = 0 ; i <= n - 2 ; i ++ ) { for ( int j = i + 1 ; j <= n - 1 ; j ++ ) { for ( int k = j + 1 ; k <= n ; k ++ ) max_product = max ( max_product , arr [ i ] * arr [ j ] * arr [ k ] ) ; } } return max_product ; }
void solveWordWrap ( int arr [ ] , int n , int k ) { int dp [ n ] ; int ans [ n ] ; for ( int i = 0 ; i < n - 2 ; i ++ ) dp [ i ] = 0 , ans [ n - 1 ] = n - 1 ; for ( int i = 0 ; i < n - 2 ; i ++ ) { int currlen = - 1 ; dp [ i ] = INT_MAX ; for ( int j = i ; j < n ; j ++ ) { int cost = INT_MIN ; if ( currlen > k ) break ; if ( j == n - 1 ) cost = ( k - currlen ) * ( k - currlen ) + dp [ j + 1 ] ; if ( cost < dp [ i ] ) dp [ i ] = cost ; ans [ i ] = j ; } } i = 0 ; while ( i < n ) cout << i + 1 << " ▁ " ; i = ans [ i ] + 1 ; }
int sumofFactors ( int n ) { if ( n % 2 != 0 ) return 0 ; int res = 1 ; for ( int i = 2 ; i <= sqrt ( n ) ; i ++ ) { int count = 0 ; int curr_sum = 1 ; int curr_term = 1 ; while ( n % i == 0 ) ++ count ; n = n / i ; if ( i == 2 && count == 1 ) curr_sum = 0 ; curr_term = curr_term * i ; curr_sum = curr_sum + curr_term ; } if ( n >= 2 ) res = res * ( 1 + n ) ; return res ; }
int maxGameByWinner ( int N ) { int dp [ N ] ; dp [ 0 ] = 1 , dp [ 1 ] = 2 ; int i ; for ( i = 1 ; i <= N ; i ++ ) dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] ; return ( i - 1 ) ; }
int equilibrium ( int arr [ ] ) { int total_sum = sum ( arr ) ; int leftsum = 0 ; for ( int i = 0 ; i < arr . length ( ) ; i ++ ) { total_sum -= num ; if ( leftsum == total_sum ) return i ; leftsum += num ; } return - 1 ; }
double procal ( double n ) { return ( 3.0 * n ) / ( 4.0 * ( n * n ) - 1 ) ; }
void greatest ( string s ) { int n = s . length ( ) ; int a [ n ] ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) a [ i ] = s [ i ] - '0' ; sum += a [ i ] ; if ( a [ n - 1 ] % 2 ) { if ( a [ n - 2 ] % 2 != 0 || ( sum - a [ n - 1 ] ) % 3 != 0 ) cout << " - 1" ; else cout << n ; } else { int re = sum % 3 ; int dell = - 1 ; int flag = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( a [ i ] % 3 == re ) { dell = i ; flag = 1 ; break ; } else { dell = i ; } } if ( flag == 0 ) { if ( a [ n - 2 ] % 2 == 0 && re == a [ n - 1 ] % 3 ) dell = n - 1 ; } }
bool isChangeable ( int notes [ ] , int n ) { int fiveCount = 0 , tenCount = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( notes [ i ] == 5 ) fiveCount ++ ; else if ( notes [ i ] == 10 ) { if ( fiveCount > 0 ) fiveCount -- ; tenCount ++ ; else if ( fiveCount >= 3 ) fiveCount -= 3 ; else return 0 ; } } return 1 ; }
int maxSumWO3Consec ( int n ) { if ( sum [ n ] != - 1 ) return sum [ n ] ; if ( n == 0 ) sum [ n ] = 0 ; return sum [ n ] ; if ( n == 1 ) sum [ n ] = arr [ 0 ] ; return sum [ n ] ; if ( n == 2 ) sum [ n ] = arr [ 1 ] + arr [ 0 ] ; return sum [ n ] ; } sum [ n ] = max ( maxSumWO3Consec ( n - 1 ) , maxSumWO3Consec ( n - 2 ) + arr [ n - 1 ] ) , arr [ n - 2 ] + arr [ n - 1 ] + maxSumWO3Consec ( n - 3 ) ) ; return sum [ n ] ; }
int findMinZero ( int p ) { int first = 1 , second = 1 , number = 2 ; int next ; for ( next = 1 ; next ; next = next ) { first = second ; second = next ; number = number + 1 ; } return number ; }
void reorder ( int arr [ ] , int index [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { while ( index [ i ] != i ) { int oldTargetI = index [ index [ i ] ] ; int oldTargetE = arr [ index [ i ] ] ; arr [ index [ i ] ] = arr [ i ] ; index [ i ] = index [ i ] ; } }
int calculateSum ( int n ) { if ( n <= 0 ) return 0 ; int fibo [ n + 1 ] ; int sm = fibo [ 0 ] + fibo [ 1 ] ; for ( int i = 2 ; i <= n ; i ++ ) fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ; sm = sm + fibo [ i ] ; return sm ; }
int shortestPath ( int graph [ ] [ V ] , int u , int v , int k ) { int V = 4 ; int INF = 999999999999 ; if ( k == 0 && u == v ) return 0 ; if ( k == 1 && graph [ u ] [ v ] != INF ) return graph [ u ] [ v ] ; if ( k <= 0 ) return INF ; int res = INF ; for ( int i = 0 ; i < V ; i ++ ) { if ( graph [ u ] [ i ] != INF && u != i && v != i ) { int rec_res = shortestPath ( graph , i , v , k - 1 ) ; if ( rec_res != INF ) res = min ( res , graph [ u ] [ i ] + rec_res ) ; } } return res ; }
int sumofsquare ( int n ) { int C [ n ] [ n + 1 ] ; memset ( C , 0 , sizeof ( C ) ) ; for ( int i = 0 ; i < n ; i ++ ) C [ 0 ] [ i + 1 ] = 0 ; for ( int i = 1 ; i < n ; i ++ ) for ( int j = 0 ; j <= min ( i , n ) ; j ++ ) C [ i ] [ j ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j <= i ; j ++ ) { C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) ; } } int sum = 0 ; for ( int i = 0 ; i <= n ; i ++ ) sum = sum + ( C [ n ] [ i ] * C [ n ] [ i ] ) ; return sum ; }
void constructArr ( int arr [ ] , int pair [ ] , int n ) { arr [ 0 ] = ( pair [ 0 ] + pair [ 1 ] - pair [ n - 1 ] ) / 2 ; for ( int i = 1 ; i < n ; i ++ ) arr [ i ] = ( pair [ i - 1 ] - arr [ 0 ] ) / 2 ; }
int findFrequency ( int arr [ ] , int n , int left , int right , int element ) { int count = 0 ; for ( int i = left - 1 ; i < right ; i ++ ) if ( arr [ i ] == element ) count ++ ; return count ; }
void parabola ( int a , int b , int c ) { cout << " Vertex : ▁ ( " << ( - b / ( 2 * a ) ) << " , ▁ " << ( ( 4 * a * c ) - ( b * b ) ) / ( 4 * a ) << " ) " << endl ; cout << " Focus : ▁ ( " << ( - b / ( 2 * a ) ) << " , ▁ " << ( ( 4 * a * c ) - ( b * b ) + 1 ) / ( 4 * a ) << " ) " << endl ; cout << " Directrix : ▁ y = ▁ " << c - ( ( b * b ) + 1 ) * 4 * a << endl ; }
int minproduct ( int a [ ] , int b [ ] , int n , int k ) { int diff = 0 ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int pro = a [ i ] * b [ i ] ; res = res + pro ; if ( pro < 0 && b [ i ] < 0 ) { int temp = ( a [ i ] + 2 * k ) * b [ i ] ; else if ( pro > 0 && a [ i ] > 0 ) { temp = ( a [ i ] - 2 * k ) * b [ i ] ; } int d = abs ( pro - temp ) ; if ( d > diff ) diff = d ; } return res - diff ; }
int pairsInSortedRotated ( int arr [ ] , int n , int x ) { for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > arr [ i + 1 ] ) break ; int l = ( i + 1 ) % n ; int r = i ; int cnt = 0 ; while ( l != r ) { if ( arr [ l ] + arr [ r ] == x ) { cnt ++ ; if ( l == ( r - 1 + n ) % n ) return cnt ; } l = ( l + 1 ) % n ; r = ( r - 1 + n ) % n ; } else if ( arr [ l ] + arr [ r ] < x ) l = ( l + 1 ) % n ; else r = ( n + r - 1 ) % n ; } return cnt ; }
int middleOfThree ( int a , int b , int c ) { int x = a - b ; int y = b - c ; int z = a - c ; if ( x * y > 0 ) return b ; else if ( x * z > 0 ) return a ; else return b ; }
int maxSubArraySumRepeated ( int a [ ] , int n , int k ) { int max_so_far = INT_MAX ; int max_ending_here = 0 ; for ( int i = 0 ; i < n * k ; i ++ ) { max_ending_here = max_ending_here + a [ i % n ] ; if ( max_so_far < max_ending_here ) { max_so_far = max_ending_here ; } if ( max_ending_here < 0 ) max_ending_here = 0 ; } return max_so_far ; }
int binomialCoeffSum ( int n ) { int C [ n ] [ n + 2 ] ; memset ( C , 0 , sizeof C ) ; for ( int i = 0 ; i < n ; i ++ ) C [ 0 ] [ i + 1 ] = C [ 0 ] [ i ] ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < min ( i , n ) ; j ++ ) { if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } int sum = 0 ; for ( int i = 0 ; i <= n ; i ++ ) sum += C [ n ] [ i ] ; return sum ; }
bool isEven ( int n ) { return ( n % 2 == 0 ) ; }
int binarySearch ( int * arr , int low , int high , int key ) { if ( high < low ) return - 1 ; int mid = ( low + high ) / 2 ; if ( key == arr [ int ( mid ) ] ) return mid ; if ( key > arr [ int ( mid ) ] ) return binarySearch ( arr , ( mid + 1 ) , high , key ) ; return binarySearch ( arr , low , ( mid - 1 ) , key ) ; }
void MAXMIN ( int arr [ ] [ MAX ] , int n ) { int MIN = INT_MAX ; int MAX = INT_MIN ; for ( int i = 0 ; i < n / 2 ; i ++ ) { for ( int j = 0 ; j <= n / 2 ; j ++ ) { if ( arr [ i ] [ j ] > arr [ i ] [ n - j - 1 ] ) { if ( MIN > arr [ i ] [ n - j - 1 ] ) min = arr [ i ] [ n - j - 1 ] ; if ( MAX < arr [ i ] [ j ] ) MAX = arr [ i ] [ j ] ; } else { if ( MIN > arr [ i ] [ j ] ) { MIN = arr [ i ] [ j ] ; if ( MAX < arr [ i ] [ n - j - 1 ] ) MAX = arr [ i ] [ n - j - 1 ] ; } } } cout << " MAXimum ▁ = ▁ " << MAX << " , ▁ MINimum ▁ = ▁ " << MIN << endl ; }
int countPaths ( int n , int m ) { if ( n == 0 || m == 0 ) return 1 ; return countPaths ( n - 1 , m ) + countPaths ( n , m - 1 ) ; }
int countFriendsPairings ( int n ) { int dp [ 100 ] ; if ( dp [ n ] != - 1 ) return dp [ n ] ; if ( n > 2 ) dp [ n ] = countFriendsPairings ( n - 1 ) + ( n - 1 ) * countFriendsPairings ( n - 2 ) ; else dp [ n ] = n ; }
int countRect ( int n ) { int ans = 0 ; for ( int length = 1 ; length <= n ; length ++ ) { int height = length ; while ( height * length <= n ) ans ++ ; height ++ ; } return ans ; }
unsigned int factorial ( unsigned int n ) { return n == 1 || n == 0 ? 1 : n * factorial ( n - 1 ) ; }
float correlationCoefficient ( int X [ ] , int Y [ ] , int n ) { int sum_X = 0 , sum_Y = 0 , sum_XY = 0 ; int squareSum_X = 0 , squareSum_Y = 0 ; int i ; for ( i = 0 ; i < n ; i ++ ) { sum_X = sum_X + X [ i ] ; sum_Y = sum_Y + Y [ i ] ; sum_XY = sum_XY + X [ i ] * Y [ i ] ; squareSum_X = squareSum_X + X [ i ] * X [ i ] ; squareSum_Y = squareSum_Y + Y [ i ] * Y [ i ] ; i ++ ; } double corr = ( n * sum_XY - sum_X * sum_Y ) / ( n * squareSum_X - sum_X * sum_X ) * ( n * squareSum_Y - sum_Y * sum_Y ) ; return corr ; }
int floorSqrt ( int x ) { if ( x == 0 || x == 1 ) return x ; int i = 1 , result = 1 ; while ( result <= x ) i ++ ; result = i * i ; return i - 1 ; }
void printMat ( int degseq [ ] , int n ) { int mat [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( degseq [ i ] > 0 && degseq [ j ] > 0 ) { degseq [ i ] -- ; degseq [ j ] -- ; mat [ i ] [ j ] = 1 ; mat [ j ] [ i ] = 1 ; } } cout << " ▁ ▁ ▁ " << endl ; for ( int i = 0 ; i < n ; i ++ ) { cout << " ▁ " << " ( " << i << " ) " << endl ; for ( int j = 0 ; j < n ; j ++ ) { cout << " ▁ ▁ ▁ ▁ " << mat [ i ] [ j ] << endl ; } cout << endl ; } }
int minTime ( int arr [ ] , int n , int m ) { int t = 0 ; while ( 1 ) { int items = 0 ; for ( int i = 0 ; i < n ; i ++ ) items += ( t / arr [ i ] ) ; if ( items >= m ) return t ; t ++ ; } }
int maxSumBitonicSubArr ( int arr [ ] , int n ) { int msis [ n ] ; int msds [ n ] ; int max_sum = 0 ; msis [ 0 ] = arr [ 0 ] ; msds [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > arr [ i - 1 ] ) msis [ i ] = msis [ i - 1 ] + arr [ i ] ; else msds [ i ] = arr [ i ] ; } for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] > arr [ i + 1 ] ) msds [ i ] = msds [ i + 1 ] + arr [ i ] ; else msds [ i ] = arr [ i ] ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( max_sum < ( msis [ i ] + msds [ i ] - arr [ i ] ) ) max_sum = ( msis [ i ] + msds [ i ] - arr [ i ] ) ; } return max_sum ; }
int findMinNumber ( int n ) { int count = 0 ; int ans = 1 ; while ( n % 2 == 0 ) count ++ ; n /= 2 ; if ( count % 2 is not 0 ) ans *= 2 ; for ( int i = 3 ; i <= sqrt ( n ) ; i ++ ) { count = 0 ; while ( n % i == 0 ) count ++ ; n /= i ; if ( count % 2 is not 0 ) ans *= i ; } if ( n > 2 ) ans *= n ; } return ans ; }
int rangeGCD ( int n , int m ) { return n if ( n == m ) return 1 ; }
int assignValue ( int a , int b , int x ) { int arr [ 2 ] ; memset ( arr , 0 , sizeof arr ) ; return arr [ x ] ; }
bool isTriangular ( int num ) { if ( num < 0 ) return false ; int sum = 0 , n = 1 ; while ( sum <= num ) { sum = sum + n ; if ( sum == num ) return true ; n ++ ; } return false ; }
int interpolationSearch ( int arr [ ] , int n , int x ) { int lo = 0 , hi = ( n - 1 ) ; while ( lo <= hi && x >= arr [ lo ] && x <= arr [ hi ] ) { if ( lo == hi ) if ( arr [ lo ] == x ) return lo ; return - 1 ; } int pos = lo + ( ( float ) ( hi - lo ) / ( arr [ hi ] - arr [ lo ] ) ) * ( x - arr [ lo ] ) ; if ( arr [ pos ] == x ) return pos ; if ( arr [ pos ] < x ) lo ++ ; else hi -- ; } return - 1 ; }
void minSpacePreferLarge ( int w , int m , int n ) { int num_m = 0 , num_n = 0 ; int rem = w ; int p = 0 , q = 0 , r = 0 ; while ( w >= n ) { p = w / m ; r = w % m ; if ( r <= rem ) { num_m = p ; num_n = q ; rem = r ; } q ++ ; w -= n ; } cout << str ( int ) << " ▁ ▁ " << num_m << " ▁ " << num_n << " ▁ " << rem << endl ; }
int knapSack ( int W , int wt , int val [ ] , int n ) { int K [ n + 1 ] [ W + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) K [ i ] [ 0 ] = 0 ; for ( int w = 0 ; w <= W ; w ++ ) { if ( i == 0 || w == 0 ) K [ i ] [ w ] = 0 ; else if ( wt [ i - 1 ] <= w ) K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] , K [ i - 1 ] [ w ] ) ; else K [ i ] [ w ] = K [ i - 1 ] [ w ] ; } } return K [ n ] [ W ] ; }
unsigned int factorial ( unsigned int n ) { return n == 1 || n == 0 ? 1 : n * factorial ( n - 1 ) ; }
int findgroups ( int arr [ ] , int n ) { int c [ 3 ] = { 0 , 0 , 0 } ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) c [ arr [ i ] % 3 ] ++ ; res += ( c [ 0 ] * ( c [ 0 ] - 1 ) ) >> 1 ; res += c [ 1 ] * c [ 2 ] ; res += ( c [ 0 ] * ( c [ 0 ] - 1 ) ) / 6 ; res += ( c [ 1 ] * ( c [ 1 ] - 2 ) ) / 6 ; res += ( c [ 2 ] * ( c [ 2 ] - 1 ) * ( c [ 2 ] - 2 ) ) / 6 ; res += c [ 0 ] * c [ 1 ] * c [ 2 ] ; return res ; }
int findMaxValue ( int mat [ N ] [ N ] ) { int maxValue = INT_MIN ; int maxArr [ N ] [ N ] ; int i , j ; for ( i = 0 ; i < N ; i ++ ) { maxArr [ N - 1 ] [ N - 1 ] = mat [ N - 1 ] [ i ] ; maxArr [ N - 1 ] [ j ] = maxv ; } maxv = mat [ N - 1 ] [ N - 1 ] ; for ( j = N - 2 ; j >= 0 ; j -- ) { if ( mat [ N - 1 ] [ j ] > maxv ) maxv = mat [ N - 1 ] [ j ] ; maxArr [ N - 1 ] [ j ] = maxv ; } } for ( i = 0 ; i < N - 2 ; i ++ ) { for ( j = 0 ; j <= N - 2 ; j ++ ) { if ( maxArr [ i ] [ j + 1 ] - mat [ i ] [ j ] > maxValue ) { maxValue = ( maxArr [ i + 1 ] [ j + 1 ] - mat [ i ] [ j ] ) ; maxArr [ i ] [ j ] = max ( maxArr [ i ] [ j ] , max ( maxArr [ i ] [ j + 1 ] , maxArr [ i + 1 ] [ j + 1 ] ) ) ; } } return maxValue ; }
int kPrimeFactor ( int n , int k ) { while ( n % 2 == 0 ) k = k - 1 ; n = n / 2 ; if ( k == 0 ) return 2 ; int i ; for ( i = 3 ; i <= math . sqrt ( n ) ; i ++ ) { while ( n % i == 0 ) { if ( k == 1 ) return i ; k = k - 1 ; n = n / i ; } i = i + 2 ; } if ( n > 2 && k == 1 ) return n ; } return - 1 ; }
void SieveOfEratosthenes ( int n , bool isPrime [ ] ) { isPrime [ 0 ] = isPrime [ 1 ] = false ; for ( int i = 2 ; i <= n ; i ++ ) isPrime [ i ] = true ; for ( int p = 2 ; p <= n ; p ++ ) { if ( p * p <= n && isPrime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i ++ ) isPrime [ i ] = false ; p ++ ; } } }
int findFirstMissing ( int array [ ] , int start , int end ) { if ( start > end ) return end + 1 ; if ( start != array [ start ] ) return start ; int mid = ( start + end ) / 2 ; if ( array [ mid ] == mid ) return findFirstMissing ( array , mid + 1 , end ) ; return findFirstMissing ( array , start , mid ) ; }
unsigned int factorial ( unsigned int n ) { return n == 1 || n == 0 ? 1 : n * factorial ( n - 1 ) ; }
int insertSorted ( int arr [ ] , int n , int key , int capacity ) { if ( n >= capacity ) return n ; int i ; for ( i = n - 1 ; i >= 0 && arr [ i ] > key ; i -- ) arr [ i + 1 ] = arr [ i ] ; arr [ i + 1 ] = key ; return ( n + 1 ) ; }
void add ( int A [ ] [ N ] , int B [ ] [ N ] , int C [ ] [ N ] ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) C [ i ] [ j ] = A [ i ] [ j ] + B [ i ] [ j ] ; } }
int eggDrop ( int n , int k ) { int eggFloor [ k + 1 ] [ n + 1 ] ; for ( int i = 1 ; i <= k ; i ++ ) eggFloor [ i ] [ 1 ] = 1 ; for ( int j = 1 ; j <= n ; j ++ ) eggFloor [ 1 ] [ j ] = j ; for ( int i = 2 ; i <= k ; i ++ ) { for ( int j = 2 ; j <= n ; j ++ ) { eggFloor [ i ] [ j ] = INT_MAX ; for ( int x = 1 ; x <= j ; x ++ ) res = 1 + max ( eggFloor [ i - 1 ] [ x - 1 ] , eggFloor [ i ] [ j - x ] ) ; if ( res < eggFloor [ i ] [ j ] ) eggFloor [ i ] [ j ] = res ; } } return eggFloor [ k ] [ n ] ; }
int minInsertionStepToSortArray ( int arr [ ] , int N ) { int lis [ N ] ; memset ( lis , 0 , sizeof lis ) ; for ( int i = 0 ; i < N ; i ++ ) lis [ i ] = 1 ; for ( int i = 1 ; i < N ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ i ] >= arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; } } int max = INT_MIN ; for ( int i = 0 ; i < N ; i ++ ) max = lis [ i ] ; return ( N - max ) ; }
int exactPrimeFactorCount ( int n ) { int count = 0 ; if ( n % 2 == 0 ) count = count + 1 ; while ( n % 2 == 0 ) n = n / 2 ; while ( i <= int . sqrt ( n ) ) { if ( n % i == 0 ) count = count + 1 ; while ( n % i == 0 ) n = n / i ; } i ++ ; if ( n > 2 ) count = count + 1 ; } return count ; }
int findMinAvgSubarray ( int arr [ ] , int n , int k ) { if ( n < k ) return 0 ; int res_index = 0 ; int curr_sum = 0 ; int min_sum = 0 ; for ( int i = 0 ; i < k ; i ++ ) curr_sum += arr [ i ] ; if ( curr_sum < min_sum ) { min_sum = curr_sum ; res_index = ( i - k + 1 ) ; } } cout << " Subarray ▁ between ▁ [ ▁ " << res_index << " , ▁ " << ( res_index + k - 1 ) << " ] ▁ has ▁ minimum ▁ average " << endl ; }
int countwalks ( int graph [ ] [ V ] , int u , int v , int k ) { if ( k == 0 && u == v ) return 1 ; if ( k == 1 && graph [ u ] [ v ] ) return 1 ; if ( k <= 0 ) return 0 ; for ( int i = 0 ; i < V ; i ++ ) { if ( graph [ u ] [ i ] == 1 ) count += countwalks ( graph , i , v , k - 1 ) ; } return count ; }
void print_sequence ( int n , int k ) { int b = n / ( k * ( k + 1 ) / 2 ) ; if ( b == 0 ) cout << " - 1 " ; else { int r = 1 ; int x = 1 ; while ( x ** 2 <= n ) { if ( n % x != 0 ) continue ; if ( x <= b && x > r ) r = x ; else if ( n / x <= b && n / x > r ) r = n / x ; else if ( n / x <= b && n / x > r ) r = n / x ; x ++ ; } } int i = 1 ; while ( i < k ) cout << r * i << " ▁ " ; last_term = n - ( r * ( k * ( k - 1 ) / 2 ) ; cout << last_term ; }
int findS ( int s ) { int _sum = 0 ; int n = 1 ; while ( _sum < s ) { _sum += n * n * n ; n ++ ; } if ( _sum == s ) return n ; return - 1 ; }
void printFun ( int test ) { if ( test < 1 ) return ; else { cout << test << " ▁ " ; cout << endl ; } }
void shiftMatrixByK ( int mat [ ] [ N ] , int k ) { if ( k > N ) cout << " shifting ▁ is ▁ " << " ▁ not ▁ possible " << endl ; int j = 0 ; while ( j < N ) { for ( int i = 0 ; i < k ; i ++ ) cout << " { } ▁ " << mat [ j ] [ i ] << " ▁ " << endl ; for ( int i = 0 ; i < k ; i ++ ) cout << " ▁ " << mat [ j ] [ i ] << " ▁ " << endl ; } j ++ ; }
void findPair ( int arr [ ] , int n ) { bool found = false ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { for ( int k = 0 ; k < n ; k ++ ) { if ( arr [ i ] + arr [ j ] == arr [ k ] ) { printf ( " ▁ found ▁ % d " , arr [ i ] , arr [ j ] ) ; found = true ; } } } if ( found == false ) cout << " Not ▁ exist " ; }
bool squareRootExists ( int n , int p ) { n = n % p ; for ( int x = 2 ; x <= p ; x ++ ) if ( ( x * x ) % p == n ) return true ; return false ; }
int count ( int n , int x ) { int cnt = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i <= x ) if ( x / i <= n && x % i == 0 ) cnt ++ ; } return cnt ; }
int maxSubArraySum ( int a [ ] , int size ) { int max_so_far = INT_MAX ; int max_ending_here = 0 ; int start = 0 , end = 0 , s = 0 ; for ( int i = 0 ; i < size ; i ++ ) { max_ending_here += a [ i ] ; if ( max_so_far < max_ending_here ) { max_so_far = max_ending_here ; start = s ; end = i ; } if ( max_ending_here < 0 ) { max_ending_here = 0 ; s = i + 1 ; } } return ( end - start + 1 ) ; }
int countInRange ( int arr [ ] , int n , int x , int y ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] >= x && arr [ i ] <= y ) count ++ ; return count ; }
int countPairsWithDiffK ( int arr [ ] , int n , int k ) { int count = 0 ; sort ( arr , arr + n ) ; int l = 0 , r = 0 ; while ( r < n ) { if ( arr [ r ] - arr [ l ] == k ) count ++ ; l ++ ; r ++ ; } else if ( arr [ r ] - arr [ l ] > k ) l ++ ; else r ++ ; } return count ; }
int knapSack ( int W , int wt , int val [ ] , int n ) { if ( n == 0 || W == 0 ) return 0 ; if ( wt [ n - 1 ] > W ) return knapSack ( W , wt , val , n - 1 ) ; else { return val [ n - 1 ] + knapSack ( W - wt [ n - 1 ] , wt , val , n - 1 ) ; } }
int countNonEmptySubstr ( string str ) { int n = str . length ( ) ; return n * ( n + 1 ) / 2 ; }
int countDigits ( int a , int b ) { int count = 0 ; int p = abs ( a * b ) ; if ( p == 0 ) return 1 ; while ( p > 0 ) { count ++ ; p = p / 10 ; } return count ; }
int maxProfit ( int price [ ] , int n ) { int profit [ n ] ; int max_price = price [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) profit [ i ] = INT_MIN ; for ( int i = 0 ; i < n - 2 ; i ++ ) { if ( price [ i ] > max_price ) max_price = price [ i ] ; profit [ i ] = max ( profit [ i - 1 ] , profit [ i ] + ( price [ i ] - max_price ) ) ; } int min_price = price [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) profit [ i ] = max ( profit [ i - 1 ] , profit [ i ] + ( price [ i ] - min_price ) ) ; } int result = profit [ n - 1 ] ; return result ; }
int countDer ( int n ) { int der [ n + 1 ] ; der [ 0 ] = 1 , der [ 1 ] = 0 , der [ 2 ] = 1 ; for ( int i = 3 ; i <= n ; i ++ ) der [ i ] = ( i - 1 ) * ( der [ i - 1 ] + der [ i - 2 ] ) ; return der [ n ] ; }
float find_Area ( float r ) { return ( 2 * r * r ) ; }
int isLucky ( int n ) { int ar [ 10 ] ; while ( n > 0 ) { int digit = n % 10 ; if ( ar [ digit ] ) return 0 ; ar [ digit ] = 1 ; n = n / 10 ; } return 1 ; }
void countWaysToJump ( int arr [ ] , int n ) { int count_jump [ n ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) count_jump [ i ] = 0 ; for ( int i = 0 ; i < n - 2 ; i -- ) { if ( arr [ i ] >= n - i - 1 ) count_jump [ i ] ++ ; int j ; for ( j = i + 1 ; j < n - 1 && j <= arr [ i ] + i ) { if ( count_jump [ j ] != - 1 ) count_jump [ i ] += count_jump [ j ] ; } j ++ ; if ( count_jump [ i ] == 0 ) count_jump [ i ] = - 1 ; } }
void zodiac_sign ( int day , int month ) { if ( month == ' december ' ) astro_sign = ' Sagittarius ' if ( day < 22 ) else ' capricorn ' ; else if ( month == ' january ' ) astro_sign = ' Aquarius ' if ( day < 19 ) else ' pisces ' ; else if ( month == ' february ' ) astro_sign = ' Aquarius ' if ( day < 21 ) else ' aries ' ; else if ( month == ' march ' ) astro_sign = ' Aquarius ' if ( day < 20 ) else ' aries ' ; else if ( month == ' june ' ) astro_sign = ' Gemini ' if ( day < 21 ) else ' cancer ' ; else if ( month == ' august ' ) astro_sign = ' Leo ' if ( day < 23 ) else ' libra ' ; else if ( month == ' october ' ) astro_sign = ' Libra ' if ( day < 23 ) else ' scorpio ' ; else if ( month == ' november ' ) astro_sign = ' scorpio ' if ( day < 22 ) else ' sagittarius ' ; else if ( month == ' november ' ) astro_sign = ' scorpio ' if ( day < 22 ) else ' sagittarius ' ; } cout << astro_sign << ' \n ' ; }
bool isSymmetric ( int mat [ MAX ] [ N ] ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) return false ; } return true ; }
bool isRectangle ( bool m [ ROW ] [ COL ] ) { int rows = m [ ROW ] [ COL ] ; if ( rows == 0 ) return false ; int columns = m [ 0 ] [ COL ] ; for ( int y1 = 0 ; y1 < rows ; y1 ++ ) { for ( int x1 = 0 ; x1 < columns ; x1 ++ ) { if ( m [ y1 ] [ x1 ] == 1 ) { for ( int y2 = y1 + 1 ; y2 < rows ; y2 ++ ) { if ( m [ y1 ] [ x2 ] == 1 && m [ y2 ] [ x1 ] == 1 && m [ y2 ] [ x2 ] == 1 ) return true ; } } } return false ; }
bool isDivBy9 ( int n ) { if ( n == 0 || n == 9 ) return true ; if ( n < 9 ) return false ; return isDivBy9 ( n >> 3 ) - ( int ) ( n & 7 ) ; }
int knapSack ( int W , int wt , int val [ ] , int n ) { if ( n == 0 || W == 0 ) return 0 ; if ( wt [ n - 1 ] > W ) return knapSack ( W , wt , val , n - 1 ) ; else { return val [ n - 1 ] + knapSack ( W - wt [ n - 1 ] , wt , val , n - 1 ) ; } }
bool oppositeSigns ( int x , int y ) { return ( ( x ^ y ) < 0 ) ; }
bool arraySortedOrNot ( int arr [ ] , int n ) { if ( n == 0 || n == 1 ) return true ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i - 1 ] > arr [ i ] ) return false ; return true ; }
bool isOverflow ( int a , int b ) { if ( a == 0 || b == 0 ) return false ; int result = ( a * b ) ; if ( result >= 9223372036854775807 || result <= - 9223372036854775808 ) result = 0 ; if ( a == ( result / b ) ) return false ; else return true ; }
int countRotations ( char n [ ] ) { int l = n . length ( ) ; if ( l == 1 ) return 1 ; int oneDigit = n [ 0 ] ; if ( oneDigit % 4 == 0 ) return 0 ; int count = 0 ; for ( int i = 1 ; i < l - 1 ; i ++ ) { int twoDigit = ( int ) ( n [ i ] ) * 10 + ( int ) ( n [ i + 1 ] ) ; if ( twoDigit % 4 == 0 ) count ++ ; } int twoDigit = ( int ) ( n [ l - 1 ] ) * 10 + ( int ) ( n [ 0 ] ) ; if ( twoDigit % 4 == 0 ) count = count + 1 ; } return count ; }
void findCombinations ( string str [ ] , int index , string out ) { if ( index == 0 ) cout << str << ' \n ' ; for ( int i = 0 ; i < ( index + 1 ) ; i ++ ) findCombinations ( str , i + 1 , out + " ( " + str [ index : i + 1 ] + " ) " ; }
int search ( int arr [ ] , int n , int x ) { int i ; for ( i = 0 ; i <= n - 1 ; i ++ ) if ( arr [ i ] == x ) return i ; return - 1 ; }
int maxSum ( int stack1 [ ] , int stack2 [ ] , int stack3 [ ] , int n1 , int n2 , int n3 ) { int sum1 = 0 , sum2 = 0 , sum3 = 0 ; for ( int i = 0 ; i < n1 ; i ++ ) sum1 += stack1 [ i ] ; for ( int i = 0 ; i < n2 ; i ++ ) sum2 += stack2 [ i ] ; for ( int i = 0 ; i < n3 ; i ++ ) sum3 += stack3 [ i ] ; int top1 , top2 , top3 ; int ans = 0 ; while ( 1 ) { if ( sum1 == sum2 && sum2 == sum3 ) return sum1 ; if ( sum3 >= sum2 && sum3 >= sum1 ) sum3 -= stack3 [ top3 ] ; top3 = top3 + 1 ; } } while ( 1 ) { if ( sum1 >= sum2 && sum1 >= sum3 ) sum1 -= stack1 [ top1 ] ; top1 = top1 + 1 ; } else if ( sum3 >= sum2 && sum3 >= sum1 ) sum3 -= stack3 [ top3 ] ; top3 = top3 + 1 ; } }
int firstFactorialDivisibleNumber ( int x ) { int i = 1 , fact = 1 ; for ( i = 1 ; i <= x ; i ++ ) { fact = fact * i ; if ( fact % x == 0 ) break ; } return i ; }
void sortit ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = i + 1 ; }
void printMaxSum ( int arr [ ] , int n ) { int dp [ n ] ; for ( int i = 0 ; i < n ; i ++ ) dp [ i ] = arr [ i ] ; int maxi = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= ( i + 1 ) ** 0.5 ; j ++ ) { if ( ( i + 1 ) % j == 0 && ( i + 1 ) != j ) { if ( dp [ j - 1 ] > maxi ) maxi = dp [ j - 1 ] ; if ( dp [ ( i + 1 ) / j - 1 ] > maxi && j != 1 ) maxi = dp [ ( i + 1 ) / j - 1 ] ; } } dp [ i ] += maxi ; }
void exponential ( int n , double x ) { double sum = 1.0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) sum = 1 + x * sum / i ; cout << " e ^ x ▁ = ▁ " << sum ; }
int maxProd ( int n ) { if ( n == 2 || n == 3 ) return n - 1 ; int res = 1 ; while ( n > 4 ) n -- ; res *= 3 ; return ( n * res ) ; }
int countRotations ( int * arr , int low , int high ) { if ( high < low ) return 0 ; if ( high == low ) { printf ( " The ▁ required ▁ element ▁ is ▁ % d ▁ " , arr [ low ] ) ; return low ; } int mid = ( low + high ) / 2 ; if ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) return mid + 1 ; if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) return mid ; if ( arr [ high ] > arr [ mid ] ) countRotations ( arr , low , mid - 1 ) ; return countRotations ( arr , mid + 1 , high ) ; }
int findSum ( int n ) { int ans = 0 ; int temp = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( temp < n ) { temp ++ ; num = 1 ; while ( temp < n ) { if ( temp + i <= n ) ans += ( n - temp ) * num ; else temp ++ ; num ++ ; } } return ans ; }
int divSum ( int n ) { int result = 0 ; for ( int i = 2 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) result = result + i ; else result = result + ( i + n / i ) ; } } return ( result + n + 1 ) ; }
void rotateMatrix ( int mat [ ] [ N ] ) { int i = N - 1 ; while ( i >= 0 ) { int j ; for ( j = N - 1 ; j >= 0 ; j -- ) { cout << mat [ i ] [ j ] << " ▁ " ; i = i - 1 ; } cout << endl ; } }
void printSpiral ( int mat [ R ] [ C ] , int r , int c ) { int i ; int a = 0 , b = 2 ; int low_row = 0 , low_column = 0 ; int high_row = r - 1 ; int high_column = c - 1 if ( ( a + 1 ) >= r ) else a + 1 ; while ( ( low_row > 0 - r && low_column > 0 - c ) ) { i = low_column + 1 ; while ( i <= high_row && i < c ) { cout << mat [ low_row ] [ i ] << " ▁ " ; i ++ ; } low_row -- ; i = low_row + 2 ; while ( i >= low_column && i >= 0 && high_row < r ) { cout << mat [ i ] [ high_column ] << " ▁ " ; i -- ; } high_row ++ ; i = high_row - 2 ; while ( i > low_row && i >= 0 && low_column >= 0 ) { cout << mat [ i ] [ low_column ] << " ▁ " ; i -- ; } low_column -- ; } cout << endl ; }
int countSeq ( int n ) { int nCr = 1 ; int res = 1 ; for ( int r = 1 ; r <= n ; r ++ ) nCr = ( nCr * ( n + 1 - r ) ) / r ; res += nCr * nCr ; return res ; }
int sumofoddFactors ( int n ) { int res = 1 ; while ( n % 2 == 0 ) n = n / 2 ; for ( int i = 3 ; i <= 9 ; i ++ ) { int count = 0 ; int curr_sum = 1 ; int curr_term = 1 ; while ( n % i == 0 ) count ++ ; n = n / i ; curr_sum += curr_term ; res *= curr_sum ; } if ( n >= 2 ) res *= ( 1 + n ) ; return res ; }
int search ( int * arr , int l , int h , int key ) { if ( l > h ) return - 1 ; int mid = ( l + h ) / 2 ; if ( arr [ mid ] == key ) return mid ; if ( arr [ l ] <= arr [ mid ] ) { if ( key >= arr [ l ] && key <= arr [ mid ] ) search ( arr , l , mid - 1 , key ) ; return search ( arr , mid + 1 , h , key ) ; } if ( key >= arr [ mid ] && key <= arr [ h ] ) search ( a , mid + 1 , h , key ) ; return search ( arr , l , mid - 1 , key ) ; }
int exponentiation ( int bas , int exp ) { if ( exp == 0 ) return 1 ; if ( exp == 1 ) return bas % N ; int t = exponentiation ( bas , int ( exp / 2 ) ) ; t = ( t * t ) % N ; if ( exp % 2 == 0 ) return t ; else return ( ( bas % N ) * t ) % N ; }
int longOddEvenIncSeq ( int arr [ ] , int n ) { int lioes [ n ] ; int maxLen = 0 ; for ( int i = 1 ; i < n ; i ++ ) lioes . push_back ( 1 ) ; maxLen = 0 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ i ] > arr [ j ] && ( arr [ i ] + arr [ j ] ) % 2 != 0 && lioes [ i ] < lioes [ j ] + 1 ) ) lioes [ i ] = lioes [ j ] + 1 ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( maxLen < lioes [ i ] ) maxLen = lioes [ i ] ; } } return maxLen ; }
int addOne ( int x ) { return ( - ( ~ x ) ) ; }
int binarySearch ( int * arr , int l , int r , int x ) { if ( r >= l ) { int mid = ( l + r ) / 2 ; if ( arr [ mid ] == x ) return mid ; if ( mid > l && arr [ mid - 1 ] == x ) return mid - 1 ; if ( mid < r && arr [ mid + 1 ] == x ) return mid + 1 ; if ( arr [ mid ] > x ) return binarySearch ( arr , l , mid - 2 , x ) ; return binarySearch ( arr , mid + 2 , r , x ) ; } return - 1 ; }
void bresenham ( int x1 , int y1 , int x2 , int y2 ) { int m_new = 2 * ( y2 - y1 ) ; int slope_error_new = m_new - ( x2 - x1 ) ; int y = y1 ; for ( int x = x1 ; x <= x2 ; x ++ ) { cout << " ( " << x << " , " << y << " ) \n " ; if ( slope_error_new >= 0 ) { y ++ ; slope_error_new = slope_error_new - 2 * ( x2 - x1 ) ; } } }
int findMinX ( int num [ ] , int rem [ ] , int k ) { int x = 1 ; while ( true ) { int j ; for ( j = 0 ; j < k ; j ++ ) if ( x % num [ j ] != rem [ j ] ) break ; if ( j == k ) return x ; x ++ ; } }
bool find3Numbers ( int A [ ] , int arr_size , int sum ) { for ( int i = 0 ; i < arr_size - 2 ; i ++ ) { for ( int j = i + 1 ; j < arr_size - 1 ; j ++ ) { for ( int k = j + 1 ; k < arr_size ; k ++ ) { if ( A [ i ] + A [ j ] + A [ k ] == sum ) { printf ( " Triplet ▁ is ▁ % d , ▁ % d , ▁ % d " , A [ i ] , A [ j ] , A [ k ] ) ; return true ; } } } return false ; }
int numberOfSticks ( int x ) { return ( 3 * x * ( x + 1 ) ) / 2 ; }
bool isDivisibleBy7 ( int num ) { if ( num < 0 ) return isDivisibleBy7 ( - num ) ; if ( num == 0 || num == 7 ) return true ; if ( num < 10 ) return false ; return isDivisibleBy7 ( num / 10 - 2 * ( num - num / 10 * 10 ) ) ; }
int findSDSFunc ( int n ) { int DP [ n + 1 ] ; DP [ 0 ] = 0 , DP [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) DP [ i ] = DP [ int ( i / 2 ) ] ; for ( int i = 2 ; i <= n ; i ++ ) { if ( i % 2 == 0 ) DP [ i ] = DP [ int ( i / 2 ) ] ; else { DP [ i ] = DP [ int ( i - 1 ) / 2 ] + DP [ int ( i + 1 ) / 2 ] ; } } return DP [ n ] ; }
int recSearch ( int arr [ ] , int l , int r , int x ) { if ( r < l ) return - 1 ; if ( arr [ l ] == x ) return l ; if ( arr [ r ] == x ) return r ; return recSearch ( arr , l + 1 , r - 1 , x ) ; }
bool isPossible ( string str , int n ) { int l = str . length ( ) ; if ( l >= n ) return true ; return false ; }
void center ( int x1 , int x2 , int y1 , int y2 ) { cout << ( int ) ( x1 + x2 ) / 2 ; cout << " , " << ( y1 + y2 ) / 2 ; cout << endl ; }
int minInitialPoints ( int points [ ] [ R ] ) { int dp [ R ] [ C ] ; int m , n ; for ( m = 0 ; m <= R ; m ++ ) { n = C ; if ( points [ m - 1 ] [ n - 1 ] > 0 ) dp [ m - 1 ] [ n - 1 ] = 1 ; else dp [ m - 1 ] [ n - 1 ] = abs ( points [ m - 1 ] [ n - 1 ] ) + 1 ; for ( i = 2 ; i >= m - 2 ; i -- ) { dp [ i ] [ n - 1 ] = max ( dp [ i + 1 ] [ n - 1 ] - points [ i ] [ n - 1 ] , 1 ) ; } for ( i = 0 ; i <= m - 2 ; i -- ) { for ( j = n - 2 ; j >= 0 ; j -- ) { min_points_on_exit = min ( dp [ i + 1 ] [ j ] , dp [ i ] [ j + 1 ] ) ; dp [ i ] [ j ] = max ( min_points_on_exit - points [ i ] [ j ] , 1 ) ; } } return dp [ 0 ] [ 0 ] ; }
void printNGE ( int arr [ ] ) { for ( int i = 0 ; i < arr . size ( ) ; i ++ ) { int next = - 1 ; for ( int j = i + 1 ; j < arr . size ( ) ; j ++ ) { if ( arr [ i ] < arr [ j ] ) next = arr [ j ] ; break ; } cout << str ( arr [ i ] ) + " ▁ ▁ " << next << endl ; } }
