def nonDecNums ( n ) : NEW_LINE INDENT a = [ [ 0 for i in range ( n + 1 ) ] for j in range ( 10 ) ] NEW_LINE for i in range ( 0 , 9 ) : NEW_LINE INDENT a [ 0 ] [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT a [ i ] [ 9 ] = 1 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 8 ) : NEW_LINE INDENT a [ i ] [ j ] = a [ i - 1 ] [ j ] + a [ i ] [ j + 1 ] NEW_LINE DEDENT DEDENT return a [ n ] [ 0 ] NEW_LINE DEDENT
def maxSum ( arr , n ) : NEW_LINE INDENT cum_sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT cum_sum += arr [ i ] NEW_LINE DEDENT curr_val = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT curr_val += i * arr [ i ] NEW_LINE DEDENT res = curr_val NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT next_val = curr_val - ( cum_sum - arr [ i - 1 ] ) + arr [ i - 1 ] * ( n - 1 ) NEW_LINE curr_val = next_val NEW_LINE res = max ( res , next_val ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def countSubsequence ( s , n ) : NEW_LINE INDENT cntG = 0 NEW_LINE cntF = 0 NEW_LINE result = 0 NEW_LINE C = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT switch ( s [ i ] ) : NEW_LINE INDENT cntG += 1 NEW_LINE result += C NEW_LINE break NEW_LINE DEDENT case ' F ' : NEW_LINE INDENT cntF += 1 NEW_LINE C += cntG NEW_LINE break NEW_LINE DEDENT default : NEW_LINE INDENT continue NEW_LINE DEDENT DEDENT print ( result ) NEW_LINE DEDENT
def countFriendsPairings ( n ) : NEW_LINE INDENT a = 1 NEW_LINE b = 2 NEW_LINE c = 0 NEW_LINE if n <= 2 : NEW_LINE INDENT return n NEW_LINE DEDENT for i in range ( 3 , n + 1 ) : NEW_LINE INDENT c = b + ( i - 1 ) * a NEW_LINE a = b NEW_LINE b = c NEW_LINE DEDENT return c NEW_LINE DEDENT
def subArray ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT for k in range ( i , j + 1 ) : NEW_LINE INDENT print ( arr [ k ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT
def solve ( i , par , a , n , k , current_ans ) : NEW_LINE INDENT if ( par > k ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( par == k and i == n - 1 ) : NEW_LINE INDENT ans = min ( ans , current_ans ) NEW_LINE return NEW_LINE DEDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT solve ( j , par + 1 , a , n , k , current_ans + ( a [ j ] - a [ i + 1 ] ) * ( a [ j ] - a [ i + 1 ] ) ) NEW_LINE DEDENT DEDENT
def squareRoot ( n ) : NEW_LINE INDENT x = n NEW_LINE y = 1 NEW_LINE e = 0.000001 NEW_LINE while ( x - y > e ) : NEW_LINE INDENT x = ( x + y ) // 2 NEW_LINE y = n / x NEW_LINE DEDENT return x NEW_LINE DEDENT
def CountPairs ( n ) : NEW_LINE INDENT k = n NEW_LINE imin = 1 NEW_LINE ans = 0 NEW_LINE while ( imin <= n ) : NEW_LINE INDENT imax = n // k NEW_LINE ans += k * ( imax - imin + 1 ) NEW_LINE imin = imax + 1 NEW_LINE k = n / imin NEW_LINE DEDENT return ans NEW_LINE DEDENT
def polygonArea ( X , Y , n ) : NEW_LINE INDENT area = 0.0 NEW_LINE j = n - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT area = area + ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) NEW_LINE j = i NEW_LINE DEDENT return abs ( area // 2.0 ) NEW_LINE DEDENT
def equilibrium ( arr , n ) : NEW_LINE INDENT i = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT leftsum = 0 NEW_LINE for j in range ( 0 , i ) : NEW_LINE INDENT leftsum += arr [ j ] NEW_LINE DEDENT rightsum = 0 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT rightsum += arr [ j ] NEW_LINE DEDENT if ( leftsum == rightsum ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def chordCnt ( A ) : NEW_LINE INDENT n = 2 * A NEW_LINE dpArray = [ 0 for i in range ( n + 1 ) ] NEW_LINE dpArray [ 0 ] = 1 NEW_LINE dpArray [ 2 ] = 1 NEW_LINE for i in range ( 4 , n + 2 ) : NEW_LINE INDENT for j in range ( 0 , i - 1 , 2 ) : NEW_LINE INDENT dpArray [ i ] += ( dpArray [ j ] * dpArray [ i - 2 - j ] ) NEW_LINE DEDENT DEDENT return dpArray [ n ] NEW_LINE DEDENT
def compute ( a , b ) : NEW_LINE INDENT AM = ( a + b ) // 2 NEW_LINE GM = math . sqrt ( a * b ) NEW_LINE HM = ( GM * GM ) / AM NEW_LINE return HM NEW_LINE DEDENT
def findMajority ( arr , n ) : NEW_LINE INDENT maxCount = 0 NEW_LINE index = - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] == arr [ j ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( count > maxCount ) : NEW_LINE INDENT maxCount = count NEW_LINE index = i NEW_LINE DEDENT DEDENT if ( maxCount > n // 2 ) : NEW_LINE INDENT print ( arr [ index ] , end = " No ▁ Majority ▁ Element " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No ▁ Majority ▁ Element " ) NEW_LINE DEDENT DEDENT
def isPerfectSquare ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE i = 1 NEW_LINE while sum < n : NEW_LINE INDENT sum += i NEW_LINE if sum == n : NEW_LINE INDENT return True NEW_LINE DEDENT i += 2 NEW_LINE DEDENT return False NEW_LINE DEDENT
def nearestSmallerEqFib ( n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT f1 = 0 NEW_LINE f2 = 1 NEW_LINE f3 = 1 NEW_LINE while ( f3 <= n ) : NEW_LINE INDENT f1 = f2 NEW_LINE f2 = f3 NEW_LINE f3 = f1 + f2 NEW_LINE DEDENT return f2 NEW_LINE DEDENT
def isSubsetSum ( arr , n , Sum ) : NEW_LINE INDENT subset = [ [ False for x in range ( sum + 1 ) ] for y in range ( 2 ) ] NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT for j in range ( 0 , Sum + 1 ) : NEW_LINE INDENT if ( j == 0 ) : NEW_LINE INDENT subset [ i % 2 ] [ j ] = True NEW_LINE DEDENT elif ( i == 0 ) : NEW_LINE INDENT subset [ i % 2 ] [ j ] = False NEW_LINE DEDENT elif ( arr [ i - 1 ] <= j ) : NEW_LINE INDENT subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j - arr [ i - 1 ] ] or subset [ ( i + 1 ) % 2 ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return subset [ n % 2 ] [ Sum ] NEW_LINE DEDENT
def findExtra ( arr1 , arr2 , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr1 [ i ] != arr2 [ i ] ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return n NEW_LINE DEDENT
def numberOfPermWithKInversion ( N , K ) : NEW_LINE INDENT if N == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if K == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if memo [ N ] [ K ] != 0 : NEW_LINE INDENT return memo [ N ] [ K ] NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( K + 1 ) : NEW_LINE INDENT if i <= N - 1 : NEW_LINE INDENT sum += numberOfPermWithKInversion ( N - 1 , K - i ) NEW_LINE DEDENT DEDENT memo [ N ] [ K ] = sum NEW_LINE return sum NEW_LINE DEDENT
def firstNonRepeating ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT j = 0 NEW_LINE while j < n : NEW_LINE INDENT if ( i != j and arr [ i ] == arr [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if ( j == n ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def search ( arr , n , x ) : NEW_LINE INDENT for i in arr : NEW_LINE INDENT if x == i : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def middlesum ( mat , n ) : NEW_LINE INDENT row_sum = 0 NEW_LINE col_sum = 0 NEW_LINE for i in range ( 0 , n / 2 ) : NEW_LINE INDENT row_sum += mat [ n // 2 ] [ i ] NEW_LINE DEDENT print ( " Sum ▁ of ▁ middle ▁ row ▁ = ▁ " , row_sum ) NEW_LINE DEDENT for i in range ( 0 , n / 2 ) : NEW_LINE INDENT col_sum += mat [ i ] [ n // 2 ] NEW_LINE DEDENT print ( " Sum ▁ of ▁ middle ▁ column ▁ = " , col_sum ) NEW_LINE DEDENT
def pythagoreanTriplets ( limit ) : NEW_LINE INDENT c = 0 NEW_LINE m = 2 NEW_LINE while ( c < limit ) : NEW_LINE INDENT for n in range ( 1 , m ) : NEW_LINE INDENT a = m * m - n * n NEW_LINE b = 2 * m * n NEW_LINE c = m * m + n * n NEW_LINE if ( c > limit ) : NEW_LINE INDENT break NEW_LINE DEDENT print ( ' % d ▁ % d ▁ % d ' , a , b , c ) NEW_LINE DEDENT m += 1 NEW_LINE DEDENT DEDENT
def findSum ( n ) : NEW_LINE INDENT return ( n * ( n + 1 ) * ( n + 2 ) * ( 3 * n + 1 ) / 24 ) NEW_LINE DEDENT
def fib ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n == 1 or n == 2 ) : NEW_LINE INDENT return ( f [ n ] = 1 ) NEW_LINE DEDENT if ( f [ n ] != 0 ) : NEW_LINE INDENT return f [ n ] NEW_LINE DEDENT k = ( n & 1 ) ? ( n + 1 ) / 2 : n / 2 NEW_LINE if ( k & 1 ) : ( n / 2 ) NEW_LINE k = ( ( n & 1 ) ? ( fib ( k ) * fib ( k ) + fib ( k - 1 ) * fib ( k - 1 ) ) : ( 2 * fib ( k - 1 ) + fib ( k ) ) * fib ( k ) ) NEW_LINE return f [ n ] NEW_LINE DEDENT
def isIdentity ( mat , N ) : NEW_LINE INDENT for row in range ( 0 , N ) : NEW_LINE INDENT for col in range ( 0 , N ) : NEW_LINE INDENT if ( row == col and mat [ row ] [ col ] != 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT elif ( row != col and mat [ row ] [ col ] != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT
def minCells ( mat , m , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT dp [ i ] [ j ] = sys . maxsize NEW_LINE DEDENT DEDENT for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( dp [ i ] [ j ] != INT_MAX and ( j + mat [ i ] [ j ] ) < n and ( dp [ i ] [ j + mat [ i ] [ j ] ) < dp [ i ] [ j + mat [ i ] [ j ] ] ) : NEW_LINE INDENT dp [ i ] [ j + mat [ i ] [ j ] ] = dp [ i ] [ j ] + 1 NEW_LINE DEDENT if ( dp [ i ] [ j ] != INT_MAX and ( i + mat [ i ] [ j ] ) < m and ( dp [ i ] [ j ] + 1 ) < dp [ i + mat [ i ] [ j ] ] [ j ] ) : NEW_LINE INDENT dp [ i + mat [ i ] [ j ] ] [ j ] = dp [ i ] [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT if ( dp [ m - 1 ] [ n - 1 ] != INT_MAX ) : NEW_LINE INDENT return dp [ m - 1 ] [ n - 1 ] NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def arrangeString ( string , x , y ) : NEW_LINE INDENT count_0 = 0 NEW_LINE count_1 = 0 NEW_LINE len = len ( string ) NEW_LINE for i in range ( len ) : NEW_LINE INDENT if ( string [ i ] == '0' ) : NEW_LINE INDENT count_0 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_1 += 1 NEW_LINE DEDENT DEDENT while ( count_0 > 0 or count_1 > 0 ) : NEW_LINE INDENT for j in range ( x and count_0 > 0 ) : NEW_LINE INDENT if ( count_0 > 0 ) : NEW_LINE INDENT print ( "0" , end = " 0 " ) NEW_LINE count_0 -= 1 NEW_LINE DEDENT DEDENT for j in range ( y and count_1 > 0 ) : NEW_LINE INDENT if ( count_1 > 0 ) : NEW_LINE INDENT print ( "1" , end = " 1 " ) NEW_LINE count_1 -= 1 NEW_LINE DEDENT DEDENT DEDENT
def carAssembly ( a , t , e , x ) : NEW_LINE INDENT T1 = [ 0 ] * NUM_STATION NEW_LINE T2 = [ 0 ] * NUM_STATION NEW_LINE for i in range ( 1 , NUM_STATION ) : NEW_LINE INDENT T1 [ 0 ] = e [ 0 ] + a [ 0 ] [ 0 ] NEW_LINE T2 [ 0 ] = e [ 1 ] + a [ 1 ] [ 0 ] NEW_LINE for i in range ( 1 , NUM_STATION ) : NEW_LINE INDENT T1 [ i ] = min ( T1 [ i - 1 ] + a [ 0 ] [ i ] , T2 [ i - 1 ] + t [ 1 ] [ i ] + a [ 0 ] [ i ] ) NEW_LINE T2 [ i ] = min ( T2 [ i - 1 ] + a [ 1 ] [ i ] , T1 [ i - 1 ] + t [ 0 ] [ i ] + a [ 1 ] [ i ] ) NEW_LINE DEDENT DEDENT return min ( T1 [ NUM_STATION - 1 ] + x [ 0 ] , T2 [ NUM_STATION - 1 ] + x [ 1 ] ) NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT
def findTriplets ( arr , n ) : NEW_LINE INDENT found = False NEW_LINE arr . sort ( ) NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT l = i + 1 NEW_LINE r = n - 1 NEW_LINE x = arr [ i ] NEW_LINE while ( l < r ) : NEW_LINE INDENT if ( x + arr [ l ] + arr [ r ] == 0 ) : NEW_LINE INDENT print ( " % d ▁ % d ▁ " , x , arr [ l ] , arr [ r ] ) NEW_LINE l += 1 NEW_LINE r -= 1 NEW_LINE DEDENT elif ( x + arr [ l ] + arr [ r ] < 0 ) : NEW_LINE INDENT l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT DEDENT DEDENT if ( found == False ) : NEW_LINE INDENT print ( " ▁ No ▁ Triplet ▁ Found " ) NEW_LINE DEDENT DEDENT
def maxTasks ( high , low , n ) : NEW_LINE INDENT if ( n <= 0 ) : return 0 NEW_LINE DEDENT return max ( high [ n - 1 ] + maxTasks ( high , low , ( n - 2 ) ) , low [ n - 1 ] + maxTasks ( high , low , ( n - 1 ) ) ) NEW_LINE DEDENT
def printOtherSides ( n ) : NEW_LINE INDENT if ( n & 1 ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT b = ( n * n - 1 ) / 2 NEW_LINE c = ( n * n + 1 ) / 2 NEW_LINE print ( " b ▁ = ▁ " , b , " , ▁ c ▁ = " , c ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( n == 2 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT b = ( n * n // 4 - 1 ) NEW_LINE c = n * n / 4 + 1 NEW_LINE print ( " b ▁ = ▁ " , b , " , ▁ c ▁ = ▁ " , c ) NEW_LINE DEDENT DEDENT DEDENT
def printUnsorted ( arr , n ) : NEW_LINE INDENT s = 0 NEW_LINE e = n - 1 NEW_LINE if arr [ s ] > arr [ s + 1 ] : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if arr [ e ] < arr [ e - 1 ] : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT max = arr [ s ] NEW_LINE min = arr [ s ] NEW_LINE for i in range ( s + 1 , e + 1 ) : NEW_LINE INDENT if arr [ i ] > max : NEW_LINE INDENT max = arr [ i ] NEW_LINE DEDENT if arr [ i ] < min : NEW_LINE INDENT min = arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( s ) : NEW_LINE INDENT if arr [ i ] > min : NEW_LINE INDENT s = i NEW_LINE break NEW_LINE DEDENT DEDENT for i in range ( n - 1 , e + 1 , - 1 ) : NEW_LINE INDENT if arr [ i ] < max : NEW_LINE INDENT e = i NEW_LINE break NEW_LINE DEDENT DEDENT print ( " The ▁ unsorted ▁ subarray ▁ which " , " ▁ makes ▁ the ▁ given ▁ array " , end = " sorted ▁ lies ▁ between ▁ the ▁ indees " , s , " and ▁ " , e ) NEW_LINE return NEW_LINE DEDENT
def circle ( x1 , y1 , x2 , y2 , r1 , r2 ) : NEW_LINE INDENT distSq = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) NEW_LINE radSumSq = ( r1 + r2 ) * ( r1 + r2 ) NEW_LINE if ( distSq == radSumSq ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( distSq > radSumSq ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT
def countOps ( A , B , m , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , m ) : NEW_LINE INDENT A [ i ] [ j ] -= B [ i ] [ j ] NEW_LINE DEDENT DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( 1 , m ) : NEW_LINE INDENT if ( A [ i ] [ j ] - A [ i ] [ 0 ] - A [ 0 ] [ j ] + A [ 0 ] [ 0 ] != 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT result = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT result += abs ( A [ i ] [ 0 ] ) NEW_LINE DEDENT for j in range ( 0 , m ) : NEW_LINE INDENT result += abs ( A [ 0 ] [ j ] - A [ 0 ] [ 0 ] ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def longestAlternating ( arr , n ) : NEW_LINE INDENT count = [ 0 ] * n NEW_LINE count [ n - 1 ] = 1 NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] * arr [ i + 1 ] < 0 ) : NEW_LINE INDENT count [ i ] = count [ i + 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT count [ i ] = 1 NEW_LINE DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( count [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def sortedCount ( mat , r , c ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 0 , r ) : NEW_LINE INDENT j = 0 NEW_LINE while j < c - 1 : NEW_LINE INDENT if ( mat [ i ] [ j + 1 ] <= mat [ i ] [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if ( j == c - 1 ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT for i in range ( r ) : NEW_LINE INDENT j = c - 1 NEW_LINE while ( j > 0 ) : NEW_LINE INDENT if ( mat [ i ] [ j - 1 ] <= mat [ i ] [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( c > 1 and j == 0 ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def printMaxOfMin ( arr , n ) : NEW_LINE INDENT for k in range ( 1 , n + 1 ) : NEW_LINE INDENT maxOfMin = - 2147483647 NEW_LINE for i in range ( 0 , n - k + 1 ) : NEW_LINE INDENT min = arr [ i ] NEW_LINE for j in range ( 1 , k + 1 ) : NEW_LINE INDENT if ( arr [ i + j ] < min ) : NEW_LINE INDENT min = arr [ i + j ] NEW_LINE DEDENT DEDENT if ( min > maxOfMin ) : NEW_LINE INDENT maxOfMin = min NEW_LINE DEDENT DEDENT print ( maxOfMin , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def middleOfThree ( a , b , c ) : NEW_LINE INDENT if ( ( a < b and b < c ) or ( c < b and b < a ) ) : NEW_LINE INDENT return b NEW_LINE DEDENT elif ( ( b < a and a < c ) or ( c < a and a < b ) ) : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return c NEW_LINE DEDENT DEDENT
def countarray ( n , k , x ) : NEW_LINE INDENT dp = [ 0 ] * MAXN NEW_LINE dp [ 0 ] = 0 NEW_LINE dp [ 1 ] = 1 NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT dp [ i ] = ( k - 2 ) * dp [ i - 1 ] + ( k - 1 ) * dp [ i - 2 ] ) NEW_LINE DEDENT return ( x == 1 ? ( k - 1 ) * dp [ n - 2 ] : dp [ n - 1 ] ) NEW_LINE DEDENT
def nswp ( n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 2 * nswp ( n - 1 ) + nswp ( n - 2 ) NEW_LINE DEDENT
def fib ( n ) : NEW_LINE INDENT if lookup [ n ] == NIL : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT lookup [ n ] = n NEW_LINE DEDENT else : NEW_LINE INDENT lookup [ n ] = fib ( n - 1 ) + fib ( n - 2 ) NEW_LINE DEDENT DEDENT return lookup [ n ] NEW_LINE DEDENT
def countParenth ( symb , oper , n ) : NEW_LINE INDENT F = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] NEW_LINE T = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT F [ i ] [ i ] = 1 NEW_LINE DEDENT T [ i ] [ i ] = ( symb [ i ] == ' T ' ) ? 1 : 0 NEW_LINE DEDENT for gap in range ( 1 , n ) : NEW_LINE INDENT for i in range ( gap , n ) : NEW_LINE INDENT T [ i ] [ j ] = F [ i ] [ j ] = 0 NEW_LINE for g in range ( gap , n ) : NEW_LINE INDENT k = i + g NEW_LINE tik = T [ i ] [ k ] + F [ i ] [ k ] NEW_LINE tkj = T [ k + 1 ] [ j ] + F [ k + 1 ] [ j ] NEW_LINE if ( oper [ k ] == ' & ' ) : NEW_LINE INDENT T [ i ] [ j ] += T [ i ] [ k ] * T [ k + 1 ] [ j ] NEW_LINE F [ i ] [ j ] += ( tik * tkj - T [ i ] [ k ] * T [ k + 1 ] [ j ] ) NEW_LINE DEDENT if ( oper [ k ] == ' | ' ) : NEW_LINE INDENT F [ i ] [ j ] += F [ i ] [ k ] * F [ k + 1 ] [ j ] NEW_LINE T [ i ] [ j ] += ( tik * tkj - F [ i ] [ k ] * F [ k + 1 ] [ j ] ) NEW_LINE DEDENT if ( oper [ k ] == ' ^ ' ) : NEW_LINE INDENT T [ i ] [ j ] += F [ i ] [ k ] * T [ k + 1 ] [ j ] + T [ i ] [ k ] * F [ k + 1 ] [ j ] NEW_LINE F [ i ] [ j ] += T [ i ] [ k ] * F [ k + 1 ] [ j ] NEW_LINE DEDENT k += 1 NEW_LINE DEDENT DEDENT DEDENT return T [ 0 ] [ n
def longestCommonSum ( arr1 , arr2 , n ) : NEW_LINE INDENT maxLen = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum1 = 0 NEW_LINE sum2 = 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT sum1 += arr1 [ j ] NEW_LINE sum2 += arr2 [ j ] NEW_LINE if ( sum1 == sum2 ) : NEW_LINE INDENT maxLen = j - i + 1 NEW_LINE DEDENT DEDENT DEDENT return maxLen NEW_LINE DEDENT
def maxTripletSum ( arr , n ) : NEW_LINE INDENT sum = - float ( ' inf ' ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT if ( sum < arr [ i ] + arr [ j ] + arr [ k ] ) : NEW_LINE INDENT sum = arr [ i ] + arr [ j ] + arr [ k ] NEW_LINE DEDENT DEDENT DEDENT return sum NEW_LINE DEDENT
def findNth ( n ) : NEW_LINE INDENT nthElement = 19 + ( n - 1 ) * 9 NEW_LINE outliersCount = ( int ) ( math . log10 ( nthElement ) - 1 ) NEW_LINE nthElement += 9 * outliersCount NEW_LINE return nthElement NEW_LINE DEDENT
def countSol ( coeff , start , end , rhs ) : NEW_LINE INDENT if ( rhs == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT result = 0 NEW_LINE for i in range ( start , end + 1 ) : NEW_LINE INDENT if ( coeff [ i ] <= rhs ) : NEW_LINE INDENT result += countSol ( coeff , i , end , rhs - coeff [ i ] ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def findConsecutive ( N ) : NEW_LINE INDENT start = 1 NEW_LINE end = ( N + 1 ) // 2 NEW_LINE while ( start < end ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( start , end + 1 ) : NEW_LINE INDENT sum = sum + i NEW_LINE if ( sum == N ) : NEW_LINE INDENT for j in range ( start , i + 1 ) : NEW_LINE INDENT print ( ' % d ▁ ' , j ) NEW_LINE DEDENT print ( " \n " , end - start , end ) NEW_LINE DEDENT break NEW_LINE DEDENT if ( sum > N ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT sum = 0 NEW_LINE start += 1 NEW_LINE DEDENT DEDENT
def maxArea ( a , b , c , d ) : NEW_LINE INDENT semiperimeter = ( a + b + c + d ) / 2 NEW_LINE return math . sqrt ( ( semiperimeter - a ) * ( semiperimeter - b ) * ( semiperimeter - c ) * ( semiperimeter - d ) ) NEW_LINE DEDENT
def isSubsetSum ( set , n , Sum ) : NEW_LINE INDENT if ( Sum == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n == 0 and Sum != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( set [ n - 1 ] > Sum ) : NEW_LINE INDENT return isSubsetSum ( set , n - 1 , Sum ) NEW_LINE DEDENT return isSubsetSum ( set , n - 1 , Sum ) or isSubsetSum ( set , n - 1 , Sum - set [ n - 1 ] ) NEW_LINE DEDENT
def PowerOFPINnfactorial ( n , p ) : NEW_LINE INDENT ans = 0 NEW_LINE temp = p NEW_LINE while ( temp <= n ) : NEW_LINE INDENT ans += n / temp NEW_LINE temp = temp * p NEW_LINE DEDENT return ans NEW_LINE DEDENT
def findMaxValue ( mat ) : NEW_LINE INDENT maxValue = - float ( ' inf ' ) NEW_LINE for a in range ( N - 1 ) : NEW_LINE INDENT for b in range ( N - 1 ) : NEW_LINE INDENT for d in range ( a + 1 , N ) : NEW_LINE INDENT for e in range ( b + 1 , N ) : NEW_LINE INDENT if ( maxValue < ( mat [ d ] [ e ] - mat [ a ] [ b ] ) ) : NEW_LINE INDENT maxValue = mat [ d ] [ e ] - mat [ a ] [ b ] NEW_LINE DEDENT DEDENT DEDENT return maxValue NEW_LINE DEDENT
def getOddOccurrence ( arr , arr_size ) : NEW_LINE INDENT for i in range ( 0 , arr_size ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( 0 , arr_size ) : NEW_LINE INDENT if ( arr [ i ] == arr [ j ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( count % 2 != 0 ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def direction ( R , C ) : NEW_LINE INDENT if ( R != C and R % 2 == 0 and C % 2 != 0 and R < C ) : NEW_LINE INDENT print ( " Left " ) NEW_LINE return NEW_LINE DEDENT if ( R != C and R % 2 != 0 and C % 2 == 0 and R > C ) : NEW_LINE INDENT print ( " Up " ) NEW_LINE return NEW_LINE DEDENT if ( R == C and R % 2 != 0 and C % 2 != 0 and R < C ) : NEW_LINE INDENT print ( " Right " ) NEW_LINE return NEW_LINE DEDENT if ( R != C and R % 2 == 0 and C % 2 != 0 and R < C ) : NEW_LINE INDENT print ( " Left " ) NEW_LINE return NEW_LINE DEDENT if ( R != C and R % 2 == 0 and C % 2 == 0 and R > C ) : NEW_LINE INDENT print ( " Down " ) NEW_LINE return NEW_LINE DEDENT if ( R != C and R % 2 == 0 and C % 2 == 0 and R > C ) : NEW_LINE INDENT print ( " Left " ) NEW_LINE return NEW_LINE DEDENT if ( R != C and R % 2 == 0 and C % 2 == 0 and R > C ) : NEW_LINE INDENT print ( " Up " ) NEW_LINE return NEW_LINE DEDENT if ( R != C and R % 2 == 0 and C % 2 == 0 and R > C ) : NEW_LINE INDENT print ( " Down " ) NEW_LINE return NEW_LINE DEDENT if ( R != C and R % 2 == 0 and C % 2 == 0 and R > C ) : NEW_LINE INDENT print ( " Down " ) NEW_LINE return NEW_LINE DEDENT DEDENT if ( R != C and R % 2 == 0 and C % 2 == 0 and R > C ) : NEW_LINE INDENT print ( " Right " ) NEW_LINE return NEW_LINE DEDENT DEDENT
def fib ( n ) : NEW_LINE INDENT a = 0 NEW_LINE b = 1 NEW_LINE if n >= 0 : NEW_LINE INDENT print ( a ) NEW_LINE DEDENT if n >= 1 : NEW_LINE INDENT print ( b ) NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT c = a + b NEW_LINE print ( c ) NEW_LINE a = b NEW_LINE b = c NEW_LINE DEDENT DEDENT
def divisorSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += ( n // i ) * i NEW_LINE DEDENT return sum NEW_LINE DEDENT
def solve ( n , t , s ) : NEW_LINE INDENT for i in range ( t ) : NEW_LINE INDENT for j in range ( n - 1 ) : NEW_LINE INDENT if ( s [ j ] == ' B ' and s [ j + 1 ] == ' G ' ) : NEW_LINE INDENT temp = s [ j ] NEW_LINE s [ j ] = s [ j + 1 ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT print ( s ) NEW_LINE DEDENT
def turnOffK ( n , k ) : NEW_LINE INDENT if ( k <= 0 ) : return n NEW_LINE DEDENT return ( n & ~ ( 1 << ( k - 1 ) ) ) NEW_LINE DEDENT
def findMaximum ( arr , low , high ) : NEW_LINE INDENT if low == high : NEW_LINE INDENT return arr [ low ] NEW_LINE DEDENT if ( high == low + 1 ) and arr [ low ] >= arr [ high ] ) : NEW_LINE INDENT return arr [ low ] NEW_LINE DEDENT if ( ( high == low + 1 ) and arr [ low ] < arr [ high ] ) : NEW_LINE INDENT return arr [ high ] NEW_LINE DEDENT mid = ( low + high ) // 2 NEW_LINE if ( arr [ mid ] > arr [ mid + 1 ] and arr [ mid ] > arr [ mid - 1 ] ) : NEW_LINE INDENT return arr [ mid ] NEW_LINE DEDENT if ( arr [ mid ] > arr [ mid + 1 ] and arr [ mid ] < arr [ mid - 1 ] ) : NEW_LINE INDENT return findMaximum ( arr , low , mid - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return findMaximum ( arr , mid + 1 , high ) NEW_LINE DEDENT DEDENT
def subArraySum ( arr , n , Sum ) : NEW_LINE INDENT curr_sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT curr_sum = arr [ i ] NEW_LINE j = i + 1 NEW_LINE while ( j <= n ) : NEW_LINE INDENT if ( curr_sum == Sum ) : NEW_LINE INDENT print ( " Sum ▁ found ▁ between ▁ indexes ▁ and ▁ " , i , " ▁ and " , j - 1 ) NEW_LINE return 1 NEW_LINE DEDENT if ( curr_sum > Sum or j == n ) : NEW_LINE INDENT break NEW_LINE DEDENT curr_sum = curr_sum + arr [ j ] NEW_LINE DEDENT DEDENT print ( " No ▁ subarray ▁ found " ) NEW_LINE return 0 NEW_LINE DEDENT
def getModulo ( n , d ) : NEW_LINE INDENT return ( n & ( d - 1 ) ) NEW_LINE DEDENT
def getInvCount ( arr , n ) : NEW_LINE INDENT inv_count = 0 NEW_LINE for i in arr : NEW_LINE INDENT for j in arr : NEW_LINE INDENT if i > j : NEW_LINE INDENT inv_count += 1 NEW_LINE DEDENT DEDENT DEDENT return inv_count NEW_LINE DEDENT
def dealnnoy ( n , m ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( m + 1 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 0 , m + 1 ) : NEW_LINE INDENT dp [ 0 ] [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] + dp [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT return dp [ m ] [ n ] NEW_LINE DEDENT
def isValidISBN ( isbn ) : NEW_LINE INDENT n = len ( isbn ) NEW_LINE if ( n != 10 ) : NEW_LINE INDENT return False NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( 9 ) : NEW_LINE INDENT digit = isbn [ i ] - ord ( '0' ) NEW_LINE if ( 0 > digit or 9 < digit ) : NEW_LINE INDENT return False NEW_LINE DEDENT sum += ( digit * ( 10 - i ) ) NEW_LINE DEDENT last = isbn [ 9 ] NEW_LINE if ( last != ' X ' and ( last < '0' or last > '9' ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT sum += ( ( last == ' X ' ) else 10 : ( last - ord ( '0' ) ) NEW_LINE DEDENT return ( sum % 11 == 0 ) NEW_LINE DEDENT
def power ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT return 2 * power ( n - 1 ) NEW_LINE DEDENT
def lastPosition ( n , m , k ) : NEW_LINE INDENT if ( m <= n - k + 1 ) : NEW_LINE INDENT return m + k - 1 NEW_LINE DEDENT m = m - ( n - k + 1 ) NEW_LINE return ( m % n == 0 ) ? n : ( m % n ) NEW_LINE DEDENT
def printFibonacciNumbers ( n ) : NEW_LINE INDENT f1 = 0 NEW_LINE f2 = 1 NEW_LINE if ( n < 1 ) : NEW_LINE INDENT return NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( f2 , end = " ▁ " ) NEW_LINE f1 = f2 NEW_LINE f2 = next NEW_LINE DEDENT DEDENT
def knapSack ( W , wt , val , n ) : NEW_LINE INDENT K = [ [ 0 for i in range ( W + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for w in range ( W + 1 ) : NEW_LINE INDENT if ( i == 0 or w == 0 ) : NEW_LINE INDENT K [ i ] [ w ] = 0 NEW_LINE DEDENT elif ( wt [ i - 1 ] <= w ) : NEW_LINE INDENT K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) NEW_LINE DEDENT else : NEW_LINE INDENT K [ i ] [ w ] = K [ i - 1 ] [ w ] NEW_LINE DEDENT DEDENT DEDENT return K [ n ] [ W ] NEW_LINE DEDENT
def multiply ( A , B , C ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT C [ i ] [ j ] = A [ i ] [ j ] - B [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT
def countNegative ( M , n , m ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , m ) : NEW_LINE INDENT if ( M [ i ] [ j ] < 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def middleOfThree ( a , b , c ) : NEW_LINE INDENT if a > b : NEW_LINE INDENT if b > c : NEW_LINE INDENT return b NEW_LINE DEDENT elif a > c : NEW_LINE INDENT return a NEW_LINE DEDENT elif b > c : NEW_LINE INDENT return c NEW_LINE DEDENT else : NEW_LINE INDENT return b NEW_LINE DEDENT DEDENT
def countWays ( n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( 2 , n + 1 ) ] NEW_LINE dp [ 0 ] [ 1 ] = 1 NEW_LINE dp [ 1 ] [ 1 ] = 2 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + dp [ 1 ] [ i - 1 ] NEW_LINE dp [ 1 ] [ i ] = dp [ 0 ] [ i - 1 ] * 2 + dp [ 1 ] [ i - 1 ] NEW_LINE DEDENT return dp [ 0 ] [ n ] + dp [ 1 ] [ n ] NEW_LINE DEDENT
def maxLenSub ( arr , n ) : NEW_LINE INDENT mls = [ 0 ] * n NEW_LINE max = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT mls [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( 0 , i ) : NEW_LINE INDENT if ( abs ( arr [ i ] - arr [ j ] ) <= 1 and mls [ i ] < mls [ j ] + 1 ) : NEW_LINE INDENT mls [ i ] = mls [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( max < mls [ i ] ) : NEW_LINE INDENT max = mls [ i ] NEW_LINE DEDENT DEDENT return max NEW_LINE DEDENT
def exponentiation ( base , exp ) : NEW_LINE INDENT t = 1L NEW_LINE while ( exp > 0 ) : NEW_LINE INDENT if ( exp % 2 != 0 ) : NEW_LINE INDENT t = ( t * base ) % N NEW_LINE DEDENT base = ( base * base ) % N NEW_LINE exp /= 2 NEW_LINE DEDENT return t % N NEW_LINE DEDENT
def sequence ( n ) : NEW_LINE INDENT f = [ 0 ] * ( n + 1 ) NEW_LINE f [ 0 ] = 0 NEW_LINE f [ 1 ] = 1 NEW_LINE f [ 2 ] = 1 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT f [ i ] = f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ] NEW_LINE DEDENT return f [ n ] NEW_LINE DEDENT
def lbs ( arr , n ) : NEW_LINE INDENT lis = [ 0 ] * n NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT lis [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and lis [ i ] < lis [ j ] + 1 ) : NEW_LINE INDENT lis [ i ] = lis [ j ] + 1 NEW_LINE DEDENT DEDENT lds = [ 0 ] * ( n - 1 ) NEW_LINE for i in range ( 0 , n - 1 , - 1 ) : NEW_LINE INDENT for j in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and lds [ i ] < lds [ j ] + 1 ) : NEW_LINE INDENT lds [ i ] = lds [ j ] + 1 NEW_LINE DEDENT DEDENT max = lis [ 0 ] + lds [ 0 ] - 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( lis [ i ] + lds [ i ] - 1 > max ) : NEW_LINE INDENT max = lis [ i ] + lds [ i ] - 1 NEW_LINE DEDENT DEDENT return max NEW_LINE DEDENT
def maximumSum ( a , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT a [ i ] . sort ( ) NEW_LINE DEDENT sum = a [ n - 1 ] [ M - 1 ] NEW_LINE prev = a [ n - 1 ] [ M - 1 ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( M - 1 , - 1 , - 1 ) : NEW_LINE INDENT if a [ i ] [ j ] < prev : NEW_LINE INDENT prev = a [ i ] [ j ] NEW_LINE sum += prev NEW_LINE break NEW_LINE DEDENT DEDENT if j == - 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def fib ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT return fib ( n - 1 ) + fib ( n - 2 ) NEW_LINE DEDENT
def diagonalsquare ( mat , row , column ) : NEW_LINE INDENT print ( " ▁ \n Diagonal ▁ one ▁ : ▁ " ) NEW_LINE for i in range ( row ) : NEW_LINE INDENT print ( mat [ i ] [ i ] * mat [ i ] [ i ] , end = " ▁ " ) NEW_LINE DEDENT print ( " ▁ \n Diagonal ▁ two ▁ : ▁ " ) NEW_LINE for i in range ( row ) : NEW_LINE INDENT print ( mat [ i ] [ row - i - 1 ] * mat [ i ] [ row - i - 1 ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def maxArea ( mat ) : NEW_LINE INDENT hist = [ [ 0 for i in range ( C + 1 ) ] for j in range ( R + 1 ) ] NEW_LINE for i in range ( R ) : NEW_LINE INDENT hist [ 0 ] [ i ] = mat [ 0 ] [ i ] NEW_LINE DEDENT for j in range ( 1 , R ) : NEW_LINE INDENT hist [ j ] [ i ] = ( mat [ j ] [ i ] == 0 ) : NEW_LINE INDENT hist [ j ] [ i ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT hist [ j - 1 ] [ i ] + 1 NEW_LINE DEDENT DEDENT for i in range ( R ) : NEW_LINE INDENT count = [ 0 ] * hist [ i ] [ j ] NEW_LINE for j in range ( C ) : NEW_LINE INDENT if ( count [ j ] > 0 ) : NEW_LINE INDENT for k in range ( count [ j ] ) : NEW_LINE INDENT hist [ i ] [ col_no ] = j NEW_LINE col_no += 1 NEW_LINE DEDENT DEDENT DEDENT curr_area = 0 NEW_LINE for i in range ( R ) : NEW_LINE INDENT for j in range ( C ) : NEW_LINE INDENT curr_area = ( j + 1 ) * hist [ i ] [ j ] NEW_LINE if ( curr_area > max_area ) : NEW_LINE INDENT max_area = curr_area NEW_LINE DEDENT DEDENT DEDENT return max_area NEW_LINE DEDENT
def longestSubseqWithDiffOne ( arr , n ) : NEW_LINE INDENT dp = [ 0 ] * n NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT dp [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( 0 , i ) : NEW_LINE INDENT if ( ( arr [ i ] == arr [ j ] + 1 ) or ( arr [ i ] == arr [ j ] - 1 ) ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i ] , dp [ j ] + 1 ) NEW_LINE DEDENT DEDENT DEDENT result = 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if result < dp [ i ] : NEW_LINE INDENT result = dp [ i ] NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def maxSquare ( b , m ) : NEW_LINE INDENT return ( b // m - 1 ) * ( b / m ) / 2 NEW_LINE DEDENT
def spiralPrint ( m , n , a ) : NEW_LINE INDENT k = 0 l = 0 NEW_LINE while ( k < m and l < n ) : NEW_LINE INDENT for i in range ( l , n ) : NEW_LINE INDENT print ( a [ k ] [ i ] , end = " ▁ " ) NEW_LINE DEDENT k += 1 NEW_LINE for i in range ( k , m ) : NEW_LINE INDENT print ( a [ i ] [ n - 1 ] , end = " ▁ " ) NEW_LINE DEDENT n -= 1 NEW_LINE if ( k < m ) : NEW_LINE INDENT for i in range ( n - 1 , l - 1 , - 1 ) : NEW_LINE INDENT print ( a [ m - 1 ] [ i ] , end = " ▁ " ) NEW_LINE DEDENT m -= 1 NEW_LINE DEDENT if ( l < n ) : NEW_LINE INDENT for i in range ( m - 1 , k - 1 , - 1 ) : NEW_LINE INDENT print ( a [ i ] [ l ] , end = " ▁ " ) NEW_LINE DEDENT l += 1 NEW_LINE DEDENT DEDENT
def pentagonalNum ( n ) : NEW_LINE INDENT return ( 3 * n * n - n ) / 2 NEW_LINE DEDENT
def countNonDecreasing ( n ) : NEW_LINE INDENT N = 10 NEW_LINE count = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT count *= ( N + i - 1 ) NEW_LINE count /= i NEW_LINE DEDENT return count NEW_LINE DEDENT
def kth ( arr1 , arr2 , m , n , k ) : NEW_LINE INDENT sorted1 = [ 0 ] * m NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE d = 0 NEW_LINE while ( i < m and j < n ) : NEW_LINE INDENT if ( arr1 [ i ] < arr2 [ j ] ) : NEW_LINE INDENT sorted1 [ d ] = arr1 [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT sorted1 [ d ] = arr2 [ j ] NEW_LINE DEDENT DEDENT while ( i < m ) : NEW_LINE INDENT sorted1 [ d ] = arr1 [ i ] NEW_LINE i += 1 NEW_LINE DEDENT while ( j < n ) : NEW_LINE INDENT sorted1 [ d ] = arr2 [ j ] NEW_LINE j += 1 NEW_LINE DEDENT return sorted1 [ k - 1 ] NEW_LINE DEDENT
def binomialCoeff ( n , k ) : NEW_LINE INDENT if ( k == 0 or k == n ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return binomialCoeff ( n - 1 , k - 1 ) + binomialCoeff ( n - 1 , k ) NEW_LINE DEDENT
def printDistinct ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT j = 0 NEW_LINE while j < i : NEW_LINE INDENT if ( arr [ i ] == arr [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if ( i == j ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
def countSolutions ( n ) : NEW_LINE INDENT res = 0 NEW_LINE for x in range ( 0 , n ) : NEW_LINE INDENT for y in range ( 0 , x * x + y * y < n ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def relativeComplement ( arr1 , arr2 , n , m ) : NEW_LINE INDENT i , j = 0 , 0 NEW_LINE while i < n and j < m : NEW_LINE INDENT if arr1 [ i ] < arr2 [ j ] : NEW_LINE INDENT print ( arr1 [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT elif arr1 [ i ] > arr2 [ j ] : NEW_LINE INDENT j += 1 NEW_LINE DEDENT elif arr1 [ i ] == arr2 [ j ] : NEW_LINE INDENT i += 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT while i < n : NEW_LINE INDENT print ( arr1 [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT
def findTrailingZeros ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 5 ) : NEW_LINE INDENT count += n // i NEW_LINE DEDENT return count NEW_LINE DEDENT
def CountSubstring ( str , n ) : NEW_LINE INDENT ans = ( n * ( n + 1 ) ) / 2 NEW_LINE a_index = 0 NEW_LINE b_index = 0 NEW_LINE c_index = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( str [ i ] == ' a ' ) : NEW_LINE INDENT a_index = i + 1 NEW_LINE ans -= min ( b_index , c_index ) NEW_LINE DEDENT elif ( str [ i ] == ' b ' ) : NEW_LINE INDENT b_index = i + 1 NEW_LINE ans -= min ( a_index , c_index ) NEW_LINE DEDENT else : NEW_LINE INDENT c_index = i + 1 NEW_LINE ans -= min ( a_index , b_index ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def findLargestd ( S , n ) : NEW_LINE INDENT found = False NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT continue NEW_LINE DEDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT if ( i == k ) : NEW_LINE INDENT continue NEW_LINE DEDENT for l in range ( k + 1 , n ) : NEW_LINE INDENT if ( i == l ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( S [ i ] == S [ j ] + S [ k ] + S [ l ] ) : NEW_LINE INDENT found = True NEW_LINE return S [ i ] NEW_LINE DEDENT DEDENT DEDENT DEDENT if ( found == False ) : NEW_LINE INDENT return INT_MIN NEW_LINE DEDENT DEDENT
def constructTree ( n , d , h ) : NEW_LINE INDENT if ( d == 1 ) : NEW_LINE INDENT if ( n == 2 and h == 1 ) : NEW_LINE INDENT print ( "1 ▁ 2" ) NEW_LINE return NEW_LINE DEDENT print ( " - 1" ) NEW_LINE return NEW_LINE DEDENT if ( d > 2 * h ) : NEW_LINE INDENT print ( " - 1" ) NEW_LINE return NEW_LINE DEDENT for i in range ( 1 , h + 1 ) : NEW_LINE INDENT print ( i , " ▁ " , i + 1 ) NEW_LINE DEDENT DEDENT if ( d > h ) : NEW_LINE INDENT print ( "1" , " ▁ " , h + 2 ) NEW_LINE for i in range ( h + 2 , d + 1 ) : NEW_LINE INDENT print ( i , " ▁ " , i + 1 ) NEW_LINE DEDENT DEDENT for i in range ( d + 1 , n ) : NEW_LINE INDENT k = 1 NEW_LINE if ( d == h ) : NEW_LINE INDENT k = 2 NEW_LINE DEDENT print ( k , " ▁ " , i + 1 ) NEW_LINE DEDENT DEDENT
def rectCount ( n , m ) : NEW_LINE INDENT return ( m * n * ( n + 1 ) * ( m + 1 ) ) / 4 NEW_LINE DEDENT
def subarrayDivisibleByK ( arr , n , k ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE s = 0 NEW_LINE e = 0 NEW_LINE maxs = 0 NEW_LINE maxe = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT mod = arr [ i ] % k NEW_LINE while ( mp [ k - mod ] != 0 or ( mod == 0 and mp [ mod ] != 0 ) ) : NEW_LINE INDENT mp [ arr [ s ] % k ] -= 1 NEW_LINE s += 1 NEW_LINE DEDENT mp [ mod ] += 1 NEW_LINE e += 1 NEW_LINE if ( ( e - s ) > ( maxe - maxs ) ) : NEW_LINE INDENT maxe = e NEW_LINE maxs = s NEW_LINE DEDENT DEDENT print ( " The ▁ maximum ▁ size ▁ is : ▁ { 0 : d } " . format ( maxe - maxs + 1 ) , " ▁ and ▁ " ) NEW_LINE for i in range ( maxs , maxe + 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def swapUpperToLower ( arr ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT temp = arr [ i ] [ j ] NEW_LINE arr [ i ] [ j ] = arr [ j ] [ i ] NEW_LINE arr [ j ] [ i ] = temp NEW_LINE DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] [ j ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT
def kthgroupsum ( k ) : NEW_LINE INDENT cur = ( k * ( k - 1 ) ) + 1 NEW_LINE sum = 0 NEW_LINE while ( k -- ) : NEW_LINE INDENT sum += cur NEW_LINE cur += 2 NEW_LINE DEDENT return sum NEW_LINE DEDENT
def isMagicSquare ( mat ) : NEW_LINE INDENT sum = 0 NEW_LINE sum2 = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum = sum + mat [ i ] [ i ] NEW_LINE DEDENT for i in range ( N - 1 ) : NEW_LINE INDENT sum2 = sum2 + mat [ i ] [ N - 1 - i ] NEW_LINE DEDENT if ( sum != sum2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT rowSum = 0 NEW_LINE for j in range ( N ) : NEW_LINE INDENT rowSum += mat [ i ] [ j ] NEW_LINE DEDENT if ( rowSum != sum ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT colSum = 0 NEW_LINE for j in range ( N ) : NEW_LINE INDENT colSum += mat [ j ] [ i ] NEW_LINE DEDENT if ( sum != colSum ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def isScalarMatrix ( mat ) : NEW_LINE INDENT for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( 0 , N ) : NEW_LINE INDENT if ( ( i != j ) and ( mat [ i ] [ j ] != 0 ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT for i in range ( 0 , N - 1 ) : NEW_LINE INDENT if ( mat [ i ] [ i ] != mat [ i + 1 ] [ i + 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT
def maxDiff ( arr , n ) : NEW_LINE INDENT SubsetSum_1 = 0 NEW_LINE SubsetSum_2 = 0 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT isSingleOccurance = True NEW_LINE for j in range ( i + 1 , n - 1 ) : NEW_LINE INDENT if ( arr [ i ] == arr [ j ] ) : NEW_LINE INDENT isSingleOccurance = False NEW_LINE DEDENT arr [ i ] = arr [ j ] = 0 NEW_LINE break NEW_LINE DEDENT DEDENT if ( isSingleOccurance ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT SubsetSum_1 += arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT SubsetSum_2 += arr [ i ] NEW_LINE DEDENT DEDENT DEDENT return abs ( SubsetSum_1 - SubsetSum_2 ) NEW_LINE DEDENT
def maxCost ( mat , N ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( N ) ] for j in range ( N ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( 1 , i + 1 and j < N ) : NEW_LINE INDENT dp [ i ] [ j ] = mat [ i ] [ j ] + max ( dp [ i - 1 ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT result = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if result < dp [ N - 1 ] [ i ] : NEW_LINE INDENT result = dp [ N - 1 ] [ i ] NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def evenSum ( n ) : NEW_LINE INDENT C = [ [ 0 for j in range ( n + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( min ( i , n + 1 ) ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT sum = 0 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT sum += C [ n ] [ i ] NEW_LINE DEDENT return sum NEW_LINE DEDENT
def diagonalsquare ( mat , row , column ) : NEW_LINE INDENT print ( " Diagonal ▁ one ▁ : ▁ " ) NEW_LINE for i in range ( row ) : NEW_LINE INDENT for j in range ( column ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT print ( mat [ i ] [ j ] * mat [ i ] [ j ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT print ( " ▁ \n " , mat [ i ] [ j ] ) NEW_LINE DEDENT DEDENT
def areSumSame ( a , n , m ) : NEW_LINE INDENT sum1 = 0 NEW_LINE sum2 = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum1 = 0 NEW_LINE sum2 = 0 NEW_LINE for j in range ( 0 , m ) : NEW_LINE INDENT sum1 += a [ i ] [ j ] NEW_LINE sum2 += a [ j ] [ i ] NEW_LINE DEDENT if ( sum1 == sum2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def countPairs ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT product = arr [ i ] * arr [ j ] NEW_LINE for k in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ k ] == product ) : NEW_LINE INDENT result += 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
def minCost ( a , n , k ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( k + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( k + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = inf NEW_LINE DEDENT DEDENT dp [ 0 ] [ 0 ] = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , k + 1 ) : NEW_LINE INDENT for m in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ m ] [ j - 1 ] + ( a [ i - 1 ] - a [ m ] ) * ( a [ i - 1 ] - a [ m ] ) ) NEW_LINE DEDENT DEDENT return dp [ n ] [ k ] NEW_LINE DEDENT
def countSetBits ( n ) : NEW_LINE INDENT if ( n == 0 ) : return 0 NEW_LINE else : NEW_LINE INDENT return 1 + countSetBits ( n & ( n - 1 ) ) NEW_LINE DEDENT DEDENT
def checkEulerFourSquareIdentity ( a , b ) : NEW_LINE INDENT ab = a * b NEW_LINE flag = False NEW_LINE i = 0 NEW_LINE while ( i * i <= ab ) : NEW_LINE INDENT j = i NEW_LINE while ( j * j <= ab ) : NEW_LINE INDENT k = j NEW_LINE while ( i * i + j * j + k * k <= ab ) : NEW_LINE INDENT l = math . sqrt ( ab - ( i * i + j * j + k * k ) ) NEW_LINE if ( floor ( l ) == ceil ( l ) and l >= k ) : NEW_LINE INDENT flag = True NEW_LINE print ( " i ▁ = ▁ " , i , " \n " , j , " \n " , k , " \n " , l ) NEW_LINE print ( " Product ▁ of ▁ and ▁ can ▁ be ▁ written ▁ as ▁ sum ▁ of ▁ squares " , " ▁ of ▁ i , ▁ j , ▁ k , ▁ l " ) NEW_LINE print ( ab + " ▁ = ▁ " , i , " ▁ + ▁ " , j , " ▁ + ▁ " , k , " * " , k , " ▁ + ▁ " , ( int ) l , " \n " ) NEW_LINE DEDENT k += 1 NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if ( flag == False ) : NEW_LINE INDENT print ( " Solution ▁ doesn ' t ▁ exist ! " ) NEW_LINE return - 1 NEW_LINE DEDENT DEDENT
def countIslands ( mat ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , M ) : NEW_LINE INDENT for j in range ( 0 , N ) : NEW_LINE INDENT if ( mat [ i ] [ j ] == ' X ' ) : NEW_LINE INDENT if ( ( i == 0 or mat [ i - 1 ] [ j ] == ' O ' ) and ( j == 0 or mat [ i ] [ j - 1 ] == ' O ' ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def getInvCount ( arr , n ) : NEW_LINE INDENT invcount = 0 NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT small = 0 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] ) : NEW_LINE INDENT small += 1 NEW_LINE DEDENT DEDENT great = 0 NEW_LINE for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] < arr [ j ] ) : NEW_LINE INDENT great += 1 NEW_LINE DEDENT DEDENT invcount += great * small NEW_LINE DEDENT return invcount NEW_LINE DEDENT
def find ( n , k ) : NEW_LINE INDENT if ( n + 1 >= k ) : NEW_LINE INDENT return ( k - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( 2 * n + 1 - k ) NEW_LINE DEDENT DEDENT
def generate ( ones , zeroes , str , len ) : NEW_LINE INDENT if ( len == len ( str ) ) : NEW_LINE INDENT print ( str , end = " ▁ " ) NEW_LINE return NEW_LINE DEDENT generate ( ones + 1 , zeroes , str + "1" , len ) NEW_LINE if ( ones > zeroes ) : NEW_LINE INDENT generate ( ones , zeroes + 1 , str + "0" , len ) NEW_LINE DEDENT DEDENT
def midPointCircleDraw ( x_centre , y_centre , r ) : NEW_LINE INDENT x = r NEW_LINE y = 0 NEW_LINE if r > 0 : NEW_LINE INDENT print ( " ( " , x + x_centre , " , ▁ " , y + y_centre , " ) ▁ " ) NEW_LINE if r > 0 : NEW_LINE INDENT print ( " ( " , x + x_centre , " , ▁ " , y + y_centre , " ) ▁ " ) NEW_LINE if r > 0 : NEW_LINE INDENT print ( " ( " , x + x_centre , " , ▁ " , y + y_centre , " ) ▁ " ) NEW_LINE print ( " ( " , y + x_centre , " , ▁ " , x + y_centre , " ) ▁ " ) NEW_LINE P = 1 - r NEW_LINE while x > y : NEW_LINE INDENT y += 1 NEW_LINE if P <= 0 : NEW_LINE INDENT P = P + 2 * y + 1 NEW_LINE DEDENT else : NEW_LINE INDENT x -= 1 NEW_LINE P = P + 2 * y - 2 * x + 1 NEW_LINE DEDENT if x < y : NEW_LINE INDENT break NEW_LINE DEDENT print ( " , x + x_centre , " , ▁ " , y + y_centre , " ) ▁ " ) NEW_LINE print ( " , - x + x_centre , " , ▁ " , - y + y_centre ) NEW_LINE print ( " , y + x_centre , " , ▁ " , x + y_centre ) NEW_LINE print ( ) NEW_LINE DEDENT
def printFactorialNums ( n ) : NEW_LINE INDENT fact = 1 NEW_LINE x = 2 NEW_LINE while ( fact <= n ) : NEW_LINE INDENT print ( fact , end = " ▁ " ) NEW_LINE fact = fact * x NEW_LINE x += 1 NEW_LINE DEDENT DEDENT
def countFriendsPairings ( n ) : NEW_LINE INDENT dp = [ 0 for _ in range ( n + 1 ) ] NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT if i <= 2 : NEW_LINE INDENT dp [ i ] = i NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] NEW_LINE DEDENT DEDENT return dp [ n ] NEW_LINE DEDENT
def findNth ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for curr in range ( 1 , n + 1 ) : NEW_LINE INDENT sum = 0 NEW_LINE for x in range ( curr , 10 ) : NEW_LINE INDENT sum = sum + x % 10 NEW_LINE DEDENT if ( sum == 10 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( count == n ) : NEW_LINE INDENT return curr NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def maximumSum ( arr , n , k ) : NEW_LINE INDENT for i in range ( 1 , k + 1 ) : NEW_LINE INDENT min = sys . maxsize NEW_LINE index = - 1 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( arr [ j ] < min ) : NEW_LINE INDENT min = arr [ j ] NEW_LINE index = j NEW_LINE DEDENT DEDENT if ( min == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT arr [ index ] = - arr [ index ] NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT return sum NEW_LINE DEDENT
def printSquares ( n ) : NEW_LINE INDENT square = 0 NEW_LINE odd = 1 NEW_LINE for x in range ( n ) : NEW_LINE INDENT print ( square , end = " ▁ " ) NEW_LINE square = square + odd NEW_LINE odd = odd + 2 NEW_LINE DEDENT DEDENT
def numberOfPaths ( m , n ) : NEW_LINE INDENT if ( m == 1 or n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return numberOfPaths ( m - 1 , n ) + numberOfPaths ( m , n - 1 ) NEW_LINE DEDENT
def binarySearch ( arr , l , r , x ) : NEW_LINE INDENT if ( r >= l ) : NEW_LINE INDENT mid = l + ( r - l ) // 2 NEW_LINE if ( arr [ mid ] == x ) : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( arr [ mid ] > x ) : NEW_LINE INDENT return binarySearch ( arr , l , mid - 1 , x ) NEW_LINE DEDENT return binarySearch ( arr , mid + 1 , r , x ) NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def numberOfPaths ( m , n ) : NEW_LINE INDENT count = [ [ 0 for i in range ( n ) ] for j in range ( m ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT count [ i ] [ 0 ] = 1 NEW_LINE DEDENT for j in range ( n ) : NEW_LINE INDENT count [ 0 ] [ j ] = 1 NEW_LINE DEDENT for i in range ( 1 , m ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT count [ i ] [ j ] = ( count [ i - 1 ] [ j ] + count [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT return count [ m - 1 ] [ n - 1 ] NEW_LINE DEDENT
def answer ( n ) : NEW_LINE INDENT dp = [ [ 0 for j in range ( 10 ) ] for i in range ( n + 1 ) ] NEW_LINE if n == 1 : NEW_LINE INDENT return 10 NEW_LINE DEDENT for j in range ( 0 , 9 ) : NEW_LINE INDENT dp [ 1 ] [ j ] = 1 NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT for j in range ( 0 , 9 ) : NEW_LINE INDENT if j == 0 : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] NEW_LINE DEDENT elif j == 9 : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] NEW_LINE DEDENT DEDENT DEDENT sum = 0 NEW_LINE for j in range ( 1 , 9 ) : NEW_LINE INDENT sum += dp [ n ] [ j ] NEW_LINE DEDENT return sum NEW_LINE DEDENT
def recaman ( n ) : NEW_LINE INDENT arr = [ 0 for i in range ( n ) ] NEW_LINE arr [ 0 ] = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT curr = arr [ i - 1 ] - i NEW_LINE j = 0 NEW_LINE while ( j < i ) : NEW_LINE INDENT if ( ( arr [ j ] == curr ) or curr < 0 ) : NEW_LINE INDENT curr = arr [ i - 1 ] + i NEW_LINE break NEW_LINE DEDENT DEDENT arr [ i ] = curr NEW_LINE print ( " % d , ▁ " , arr [ i ] ) NEW_LINE DEDENT DEDENT
def modInverse ( a , m ) : NEW_LINE INDENT a = a % m NEW_LINE for x in range ( 1 , m ) : NEW_LINE INDENT if ( ( a * x ) % m == 1 ) : NEW_LINE INDENT return x NEW_LINE DEDENT DEDENT DEDENT
def lenghtOfLongestAP ( set , n ) : NEW_LINE INDENT if ( n <= 2 ) : NEW_LINE INDENT return n NEW_LINE DEDENT L = [ [ 0 for i in range ( n ) ] for j in range ( n - 2 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT L [ i ] [ n - 1 ] = 2 NEW_LINE DEDENT for j in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT i = j - 1 NEW_LINE k = j + 1 NEW_LINE while ( i >= 0 and k <= n - 1 ) : NEW_LINE INDENT if ( set [ i ] + set [ k ] < 2 * set [ j ] ) : NEW_LINE INDENT k += 1 NEW_LINE DEDENT elif ( set [ i ] + set [ k ] > 2 * set [ j ] ) : NEW_LINE INDENT L [ i ] [ j ] = 2 , i -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] = L [ j ] [ k ] + 1 NEW_LINE llap = max ( llap , L [ i ] [ j ] ) NEW_LINE i -= 1 NEW_LINE k += 1 NEW_LINE DEDENT DEDENT while i >= 0 : NEW_LINE INDENT L [ i ] [ j ] = 2 NEW_LINE i -= 1 NEW_LINE DEDENT DEDENT return llap NEW_LINE DEDENT
def findIndex ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT a = 0 NEW_LINE b = 1 NEW_LINE c = 1 NEW_LINE res = 1 NEW_LINE while ( c < n ) : NEW_LINE INDENT c = a + b NEW_LINE res += 1 NEW_LINE a = b NEW_LINE b = c NEW_LINE DEDENT return res NEW_LINE DEDENT
def maxSumPairWithDifferenceLessThanK ( arr , N , k ) : NEW_LINE INDENT maxSum = 0 NEW_LINE arr . sort ( ) NEW_LINE i = N - 1 NEW_LINE while i > 0 : NEW_LINE INDENT if ( arr [ i ] - arr [ i - 1 ] < k ) : NEW_LINE INDENT maxSum += arr [ i ] NEW_LINE maxSum += arr [ i - 1 ] NEW_LINE i -= 1 NEW_LINE DEDENT DEDENT return maxSum NEW_LINE DEDENT
def calculateEnergy ( mat , n ) : NEW_LINE INDENT tot_energy = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT q = mat [ i ] [ j ] / n NEW_LINE i_des = q NEW_LINE j_des = mat [ i ] [ j ] - ( n * q ) NEW_LINE tot_energy += abs ( i_des - i ) + abs ( j_des - j ) NEW_LINE DEDENT DEDENT return tot_energy NEW_LINE DEDENT
def antiSpiralTraversal ( m , n , a ) : NEW_LINE INDENT k = 0 l = 0 NEW_LINE stk = [ ] NEW_LINE while ( k <= m and l <= n ) : NEW_LINE INDENT for i in range ( l , n + 1 ) : NEW_LINE INDENT stk . append ( a [ k ] [ i ] ) NEW_LINE k += 1 NEW_LINE DEDENT for i in range ( k , m + 1 ) : NEW_LINE INDENT stk . append ( a [ i ] [ n ] ) NEW_LINE n -= 1 NEW_LINE DEDENT if ( k <= m ) : NEW_LINE INDENT for i in range ( n , l - 1 , - 1 ) : NEW_LINE INDENT stk . append ( a [ m ] [ i ] ) NEW_LINE m -= 1 NEW_LINE DEDENT if ( l <= n ) : NEW_LINE INDENT for i in range ( m , k , - 1 ) : NEW_LINE INDENT stk . append ( a [ i ] [ l ] ) NEW_LINE l += 1 NEW_LINE DEDENT DEDENT while ( len ( stk ) > 0 ) : NEW_LINE INDENT print ( stk [ - 1 ] , end = " ▁ " ) NEW_LINE stk . pop ( ) NEW_LINE DEDENT DEDENT
def findMaxVal ( arr , n , num , maxLimit ) : NEW_LINE INDENT dp = [ [ 0 for ind in range ( maxLimit + 1 ) ] for i in range ( n ) ] NEW_LINE for val in range ( maxLimit + 1 ) : NEW_LINE INDENT if ( ind == 0 ) : NEW_LINE INDENT if ( num - arr [ ind ] == val or num + arr [ ind ] == val ) : NEW_LINE INDENT dp [ ind ] [ val ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ ind ] [ val ] = 0 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( val - arr [ ind ] >= 0 and val + arr [ ind ] <= maxLimit ) : NEW_LINE INDENT dp [ ind ] [ val ] = dp [ ind - 1 ] [ val - arr [ ind ] ] or dp [ ind - 1 ] [ val + arr [ ind ] ] NEW_LINE DEDENT elif ( val - arr [ ind ] >= 0 ) : NEW_LINE INDENT dp [ ind ] [ val ] = dp [ ind - 1 ] [ val - arr [ ind ] ] NEW_LINE DEDENT elif ( val + arr [ ind ] <= maxLimit ) : NEW_LINE INDENT dp [ ind ] [ val ] = dp [ ind - 1 ] [ val + arr [ ind ] ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ ind ] [ val ] = 0 NEW_LINE DEDENT DEDENT DEDENT for val in range ( maxLimit , - 1 , - 1 ) : NEW_LINE INDENT if dp [ n - 1 ] [ val ] == 0 : NEW_LINE INDENT return val NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def Resources ( process , need ) : NEW_LINE INDENT minResources = 0 NEW_LINE minResources = process * ( need - 1 ) + 1 NEW_LINE return minResources NEW_LINE DEDENT
def countIntegralSolutions ( n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 0 , n - 1 ) : NEW_LINE INDENT for k in range ( 0 , ( n - i - j ) + 1 ) : NEW_LINE INDENT if ( i + j + k == n ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
def minCost ( cost ) : NEW_LINE INDENT dist = [ INF for i in range ( N ) ] NEW_LINE for j in range ( N ) : NEW_LINE INDENT if dist [ j ] > dist [ i ] + cost [ i ] [ j ] : NEW_LINE INDENT dist [ j ] = dist [ i ] + cost [ i ] [ j ] NEW_LINE DEDENT DEDENT return dist [ N - 1 ] NEW_LINE DEDENT
def countDivisibles ( arr , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] % arr [ j ] == 0 or arr [ j ] % arr [ i ] == 0 ) : NEW_LINE INDENT res = res + 1 NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT
def pairSum ( mat , n , sum ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT mat . sort ( ) NEW_LINE DEDENT for i in range ( 0 , n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT left = 0 NEW_LINE right = n - 1 NEW_LINE while ( left < n and right >= 0 ) : NEW_LINE INDENT if ( ( mat [ i ] [ left ] + mat [ j ] [ right ] ) == sum ) : NEW_LINE INDENT print ( " ( " , mat [ i ] [ left ] , " , ▁ " , mat [ j ] [ right ] , " ) , ▁ " ) NEW_LINE left += 1 NEW_LINE right -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( ( mat [ i ] [ left ] + mat [ j ] [ right ] ) < sum ) : NEW_LINE INDENT left += 1 NEW_LINE DEDENT else : NEW_LINE INDENT right -= 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT
def isPowerOfFour ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT while ( n != 1 ) : NEW_LINE INDENT if ( n % 4 != 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT n = n // 4 NEW_LINE DEDENT return 1 NEW_LINE DEDENT
def distancesum ( x , y , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT sum += ( abs ( x [ i ] - x [ j ] ) + abs ( y [ i ] - y [ j ] ) ) NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def findMax ( arr ) : NEW_LINE INDENT row = 0 NEW_LINE j = N - 1 NEW_LINE for i in range ( N ) : NEW_LINE INDENT while ( arr [ i ] [ j ] == 1 and j >= 0 ) : NEW_LINE INDENT row = i NEW_LINE j -= 1 NEW_LINE DEDENT DEDENT print ( " Row ▁ number ▁ = " , row + 1 ) NEW_LINE print ( " , ▁ MaxCount ▁ = " , N - 1 - j ) NEW_LINE DEDENT
def lastNon0Digit ( n ) : NEW_LINE INDENT if ( n < 10 ) : NEW_LINE INDENT return dig [ n ] NEW_LINE DEDENT if ( ( ( n // 10 ) % 10 ) % 2 == 0 ) : NEW_LINE INDENT return ( 6 * lastNon0Digit ( n // 5 ) * dig [ n % 10 ] ) % 10 NEW_LINE DEDENT else : NEW_LINE INDENT return ( 4 * lastNon0Digit ( n // 5 ) * dig [ n % 10 ] ) % 10 NEW_LINE DEDENT DEDENT
def search ( arr , n , x ) : NEW_LINE INDENT i = 0 NEW_LINE while i < n : NEW_LINE INDENT if arr [ i ] == x : NEW_LINE INDENT return i NEW_LINE DEDENT i = i + abs ( arr [ i ] - x ) NEW_LINE DEDENT print ( " number ▁ is ▁ not ▁ present ! " ) NEW_LINE return - 1 NEW_LINE DEDENT
def printHosoya ( n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( N ) ] for j in range ( N ) ] NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT if ( i > j ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 2 ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 2 ] [ j - 2 ] NEW_LINE DEDENT DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , i + 1 ) : NEW_LINE INDENT print ( dp [ i ] [ j ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT
def insertionSortRecursive ( arr , n ) : NEW_LINE INDENT if ( n <= 1 ) : return NEW_LINE DEDENT last = arr [ n - 1 ] NEW_LINE j = n - 2 NEW_LINE while ( j >= 0 and arr [ j ] > last ) : NEW_LINE INDENT arr [ j + 1 ] = arr [ j ] NEW_LINE j -= 1 NEW_LINE DEDENT arr [ j + 1 ] = last NEW_LINE DEDENT DEDENT
def nthTerm ( n ) : NEW_LINE INDENT return ( n * n ) + ( n * n * n ) NEW_LINE DEDENT
def findMaxAverage ( arr , n , k ) : NEW_LINE INDENT if ( k > n ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT sum = arr [ 0 ] NEW_LINE for i in range ( 1 , k ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT max_sum = sum NEW_LINE max_end = k - 1 NEW_LINE for i in range ( k , n ) : NEW_LINE INDENT sum = sum + arr [ i ] - arr [ i - k ] NEW_LINE if ( sum > max_sum ) : NEW_LINE INDENT max_sum = sum NEW_LINE max_end = i NEW_LINE DEDENT DEDENT return max_end - k + 1 NEW_LINE DEDENT
def sumOfSeries ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum = sum + ( 2 * i - 1 ) * ( 2 * i - 1 ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
def printString ( str , ch , count ) : NEW_LINE INDENT occ = 0 NEW_LINE if ( count == 0 ) : NEW_LINE INDENT print ( str ) NEW_LINE return NEW_LINE DEDENT i = 0 NEW_LINE while i < len ( str ) : NEW_LINE INDENT if ( str [ i ] == ch ) : NEW_LINE INDENT occ += 1 NEW_LINE DEDENT if ( occ == count ) : NEW_LINE INDENT break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if ( i < len ( str ) - 1 ) : NEW_LINE INDENT print ( str [ i + 1 : ] , end = " ▁ string " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Empty ▁ string " ) NEW_LINE DEDENT DEDENT
def printPascal ( n ) : NEW_LINE INDENT arr = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] NEW_LINE for line in range ( n ) : NEW_LINE INDENT for i in range ( 0 , n + 1 ) : NEW_LINE INDENT if ( line == i or i == 0 ) : NEW_LINE INDENT arr [ line ] [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ line ] [ i ] = arr [ line - 1 ] [ i - 1 ] + arr [ line - 1 ] [ i ] NEW_LINE DEDENT print ( arr [ line ] [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT
def answer_query ( a , n , l , r ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( l , r ) : NEW_LINE INDENT if ( a [ i ] == a [ i + 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def compute_average ( a , b ) : NEW_LINE INDENT return ( a + b ) // 2 NEW_LINE DEDENT
def findElements ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ j ] > arr [ i ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( count >= 2 ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def possibleStrings ( n , r , b , g ) : NEW_LINE INDENT fact = [ 0 for i in range ( n + 1 ) ] NEW_LINE fact [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT fact [ i ] = fact [ i - 1 ] * i NEW_LINE DEDENT left = n - ( r + g + b ) NEW_LINE sum = 0 NEW_LINE for i in range ( 0 , left + 1 ) : NEW_LINE INDENT for j in range ( 0 , left - i + 1 ) : NEW_LINE INDENT k = left - ( i + j ) NEW_LINE sum = sum + fact [ n ] / ( fact [ i + r ] * fact [ j + b ] * fact [ k + g ] ) NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def maxPathSum ( tri , m , n ) : NEW_LINE INDENT for i in range ( m - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( tri [ i + 1 ] [ j ] > tri [ i + 1 ] [ j + 1 ] ) : NEW_LINE INDENT tri [ i ] [ j ] += tri [ i + 1 ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT tri [ i ] [ j ] += tri [ i + 1 ] [ j + 1 ] NEW_LINE DEDENT DEDENT DEDENT return tri [ 0 ] [ 0 ] NEW_LINE DEDENT
def fun ( n ) : NEW_LINE INDENT return n & ( n - 1 ) NEW_LINE DEDENT
def mirrorImage ( a , b , c , x1 , y1 ) : NEW_LINE INDENT temp = - 2 * ( a * x1 + b * y1 + c ) / ( a * a + b * b ) NEW_LINE x = temp * a + x1 NEW_LINE y = temp * b + y1 NEW_LINE return make_pair ( x , y ) NEW_LINE DEDENT
def printIntersection ( arr1 , arr2 , m , n ) : NEW_LINE INDENT i , j = 0 , 0 NEW_LINE while i < m and j < n : NEW_LINE INDENT if arr1 [ i ] < arr2 [ j ] : NEW_LINE INDENT i += 1 NEW_LINE DEDENT elif arr2 [ j ] < arr1 [ i ] : NEW_LINE INDENT j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( arr2 [ j ] , end = " ▁ " ) NEW_LINE j += 1 NEW_LINE DEDENT DEDENT DEDENT
def rotatematrix ( m , n , mat ) : NEW_LINE INDENT row = 0 NEW_LINE col = 0 NEW_LINE curr = None NEW_LINE while ( row < m and col < n ) : NEW_LINE INDENT if ( row + 1 == m or col + 1 == n ) : NEW_LINE INDENT break NEW_LINE DEDENT prev = mat [ row + 1 ] [ col ] NEW_LINE for i in range ( col , n ) : NEW_LINE INDENT curr = mat [ row ] [ i ] NEW_LINE mat [ row ] [ i ] = prev NEW_LINE prev = curr NEW_LINE DEDENT row += 1 NEW_LINE for i in range ( row , m ) : NEW_LINE INDENT curr = mat [ i ] [ n - 1 ] NEW_LINE mat [ i ] [ n - 1 ] = prev NEW_LINE prev = curr NEW_LINE DEDENT n -= 1 NEW_LINE if ( row < m ) : NEW_LINE INDENT for i in range ( n - 1 , col - 1 , - 1 ) : NEW_LINE INDENT curr = mat [ m - 1 ] [ i ] NEW_LINE mat [ m - 1 ] [ i ] = prev NEW_LINE prev = curr NEW_LINE DEDENT DEDENT m -= 1 NEW_LINE if ( col < n ) : NEW_LINE INDENT for i in range ( R ) : NEW_LINE INDENT for j in range ( C ) : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT
def rearrange ( arr , n ) : NEW_LINE INDENT max_idx = n - 1 NEW_LINE min_idx = 0 NEW_LINE max_elem = arr [ n - 1 ] + 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT arr [ i ] = ( arr [ max_idx ] % max_elem ) * max_elem NEW_LINE max_idx -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = ( arr [ min_idx ] % max_elem ) * max_elem NEW_LINE min_idx += 1 NEW_LINE DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT arr [ i ] = arr [ i ] / max_elem NEW_LINE DEDENT DEDENT
def printTreeEdges ( prufer , m ) : NEW_LINE INDENT vertices = m + 2 NEW_LINE vertex_set = [ 0 ] * vertices NEW_LINE for i in range ( 0 , vertices ) : NEW_LINE INDENT vertex_set [ i ] = 0 NEW_LINE DEDENT for i in range ( 0 , vertices - 2 ) : NEW_LINE INDENT vertex_set [ prufer [ i ] - 1 ] += 1 NEW_LINE DEDENT print ( " The ▁ edge ▁ set ▁ E ( G ) ▁ is : " ) NEW_LINE j = 0 NEW_LINE for j in range ( 0 , vertices ) : NEW_LINE INDENT if ( vertex_set [ j ] == 0 ) : NEW_LINE INDENT vertex_set [ j ] = - 1 NEW_LINE print ( " ( " , ( j + 1 ) , " , ▁ " , prufer [ i ] , " ) ▁ " ) NEW_LINE vertex_set [ prufer [ i ] - 1 ] -= 1 NEW_LINE break NEW_LINE DEDENT DEDENT j = 0 NEW_LINE for i in range ( 0 , vertices ) : NEW_LINE INDENT if ( vertex_set [ i ] == 0 and j == 0 ) : NEW_LINE INDENT print ( " , ( i + 1 ) , " , ▁ " , j += 1 NEW_LINE DEDENT elif ( vertex_set [ i ] == 0 and j == 1 ) : NEW_LINE INDENT print ( ( i + 1 ) , " , ▁ " ) NEW_LINE j += 1 NEW_LINE DEDENT DEDENT DEDENT
def countDecodingDP ( digits , n ) : NEW_LINE INDENT count = [ 0 for i in range ( n + 1 ) ] NEW_LINE count [ 0 ] = 1 NEW_LINE count [ 1 ] = 1 NEW_LINE if ( digits [ 0 ] == '0' ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT count [ i ] = 0 NEW_LINE if ( digits [ i - 1 ] > '0' ) : NEW_LINE INDENT count [ i ] = count [ i - 1 ] NEW_LINE DEDENT if ( digits [ i - 2 ] == '1' or ( digits [ i - 2 ] == '2' and digits [ i - 1 ] < '7' ) ) : NEW_LINE INDENT count [ i ] += count [ i - 2 ] NEW_LINE DEDENT DEDENT return count [ n ] NEW_LINE DEDENT
def largest ( arr , n ) : NEW_LINE INDENT max = arr [ 0 ] NEW_LINE i = 1 NEW_LINE while i < n : NEW_LINE INDENT if max > arr [ i ] : NEW_LINE INDENT max = arr [ i ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return max NEW_LINE DEDENT
def transpose ( A , B ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT B [ i ] [ j ] = A [ j ] [ i ] NEW_LINE DEDENT DEDENT DEDENT
def sumEqualProduct ( a , n ) : NEW_LINE INDENT zero = 0 NEW_LINE two = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( a [ i ] == 0 ) : NEW_LINE INDENT zero += 1 NEW_LINE DEDENT if ( a [ i ] == 2 ) : NEW_LINE INDENT two += 1 NEW_LINE DEDENT DEDENT cnt = ( zero * ( zero - 1 ) ) / 2 + ( two * ( two - 1 ) ) / 2 NEW_LINE return cnt NEW_LINE DEDENT
def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return True NEW_LINE DEDENT
def fib ( n ) : NEW_LINE INDENT a = 0 NEW_LINE b = 1 NEW_LINE if n >= 0 : NEW_LINE INDENT print ( a , end = " ▁ " ) NEW_LINE if n >= 1 : NEW_LINE INDENT print ( b , end = " ▁ " ) NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT print ( a + b , end = " ▁ " ) NEW_LINE b = a + b NEW_LINE a = b - a NEW_LINE DEDENT DEDENT
def thirdLargest ( arr , arr_size ) : NEW_LINE INDENT if arr_size < 3 : NEW_LINE INDENT print ( " ▁ Invalid ▁ Input ▁ " ) NEW_LINE return - 1 NEW_LINE DEDENT first = arr [ 0 ] NEW_LINE for i in range ( 1 , arr_size ) : NEW_LINE INDENT if arr [ i ] > first : NEW_LINE INDENT first = arr [ i ] NEW_LINE DEDENT DEDENT second = INT_MIN NEW_LINE for i in range ( 0 , arr_size ) : NEW_LINE INDENT if arr [ i ] > second and arr [ i ] < first : NEW_LINE INDENT second = arr [ i ] NEW_LINE DEDENT DEDENT third = INT_MIN NEW_LINE for i in range ( 0 , arr_size ) : NEW_LINE INDENT if arr [ i ] > third and arr [ i ] < second : NEW_LINE INDENT third = arr [ i ] NEW_LINE DEDENT DEDENT print ( " The ▁ third ▁ Largest ▁ element ▁ is " , third ) NEW_LINE DEDENT
def maxHamming ( arr , n ) : NEW_LINE INDENT brr = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT brr [ i ] = arr [ i ] NEW_LINE DEDENT for i in range ( n + 1 ) : NEW_LINE INDENT brr [ n + i ] = arr [ i ] NEW_LINE DEDENT maxHam = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT currHam = 0 NEW_LINE for j in range ( i , i + n ) : NEW_LINE INDENT if ( brr [ j ] != arr [ k ] ) : NEW_LINE INDENT currHam += 1 NEW_LINE DEDENT DEDENT if ( currHam == n ) : NEW_LINE INDENT return n NEW_LINE DEDENT maxHam = max ( maxHam , currHam ) NEW_LINE DEDENT return maxHam NEW_LINE DEDENT
def findSum ( N , K ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT ans += i % K NEW_LINE DEDENT return ans NEW_LINE DEDENT
def seriesSum ( n ) : NEW_LINE INDENT i = 1 NEW_LINE res = 0.0 NEW_LINE sign = True NEW_LINE while ( n > 0 ) : NEW_LINE INDENT n -= 1 NEW_LINE if ( sign ) : NEW_LINE INDENT sign = not sign NEW_LINE res = res + ( double ) ++ i / i NEW_LINE DEDENT else : NEW_LINE INDENT sign = not sign NEW_LINE res = res - ( double ) ++ i / i NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def isDiagonalMatrix ( mat ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if ( ( i != j ) and ( mat [ i ] [ j ] != 0 ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT
def getSingle ( arr , n ) : NEW_LINE INDENT ones = 0 NEW_LINE twos = 0 NEW_LINE common_bit_mask = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT twos = twos | ( ones & arr [ i ] ) NEW_LINE ones = ones ^ arr [ i ] NEW_LINE common_bit_mask = ~ ( ones & twos ) NEW_LINE ones &= common_bit_mask NEW_LINE twos &= common_bit_mask NEW_LINE DEDENT return ones NEW_LINE DEDENT
def countNum ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE arr . sort ( ) NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( arr [ i ] != arr [ i + 1 ] and arr [ i ] != arr [ i + 1 ] - 1 ) : NEW_LINE INDENT count += arr [ i + 1 ] - arr [ i ] - 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def countSquares ( a , b ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( a , b + 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT if ( j * j == i ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT
def minSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT sum += ( n % 10 ) NEW_LINE n /= 10 NEW_LINE DEDENT if ( sum == 1 ) : NEW_LINE INDENT return 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT
def nonFibonacci ( n ) : NEW_LINE INDENT prevPrev = 1 NEW_LINE prev = 2 NEW_LINE curr = 3 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT prevPrev = prev NEW_LINE prev = curr NEW_LINE curr = prevPrev + prev NEW_LINE n = n - ( curr - prev - 1 ) NEW_LINE DEDENT n = n + ( curr - prev - 1 ) NEW_LINE return prev + n NEW_LINE DEDENT
def leftRotate ( arr , n , k ) : NEW_LINE INDENT for i in range ( k , n + 1 ) : NEW_LINE INDENT print ( arr [ i % n ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def repeat ( s , n ) : NEW_LINE INDENT s1 = s NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT s += s1 NEW_LINE DEDENT return s NEW_LINE DEDENT
def findStep ( n ) : NEW_LINE INDENT if ( n == 1 or n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( n == 2 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT else : NEW_LINE INDENT return findStep ( n - 3 ) + findStep ( n - 2 ) + findStep ( n - 1 ) NEW_LINE DEDENT DEDENT
def CountPS ( Str , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] NEW_LINE P = [ False for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT P [ i ] [ i ] = True NEW_LINE DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT if ( Str [ i ] == Str [ i + 1 ] ) : NEW_LINE INDENT P [ i ] [ i + 1 ] = True NEW_LINE dp [ i ] [ i + 1 ] = 1 NEW_LINE DEDENT DEDENT for gap in range ( 2 , n ) : NEW_LINE INDENT for i in range ( n - gap , 2 ) : NEW_LINE INDENT j = gap + i NEW_LINE if ( Str [ i ] == Str [ j ] and P [ i + 1 ] [ j - 1 ] ) : NEW_LINE INDENT P [ i ] [ j ] = True NEW_LINE DEDENT if ( P [ i ] [ j ] == True ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] + 1 - dp [ i + 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] - dp [ i + 1 ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT return dp [ 0 ] [ n - 1 ] NEW_LINE DEDENT
def modularEquation ( a , b ) : NEW_LINE INDENT if a < b : NEW_LINE INDENT print ( " No ▁ solution ▁ possible ▁ " ) NEW_LINE return - 1 NEW_LINE DEDENT if a == b : NEW_LINE INDENT print ( " Infinite ▁ Solution ▁ possible ▁ " ) NEW_LINE return - 1 NEW_LINE DEDENT count = 0 NEW_LINE n = a - b NEW_LINE y = sqrt ( a - b ) NEW_LINE for i in range ( 1 , y + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT if n // i > b : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if i > b : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if y * y == n and y > b : NEW_LINE INDENT count -= 1 NEW_LINE DEDENT print ( count ) NEW_LINE DEDENT
def maxSum ( mat , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return mat [ 0 ] [ 0 ] NEW_LINE DEDENT dp = [ [ 0 for k in range ( n ) ] for l in range ( n ) ] NEW_LINE maxSum = - float ( ' inf ' ) ] NEW_LINE for j in range ( n ) : NEW_LINE INDENT max = INT_MIN NEW_LINE if ( ( j - 1 ) >= 0 ) and ( max < dp [ i + 1 ] [ j - 1 ] ) ) : NEW_LINE INDENT max = dp [ i + 1 ] [ j - 1 ] NEW_LINE DEDENT if ( ( ( j + 1 ) < n ) and ( max < dp [ i + 1 ] [ j + 1 ] ) ) : NEW_LINE INDENT max = dp [ i + 1 ] [ j + 1 ] NEW_LINE DEDENT dp [ i ] [ j ] = mat [ i ] [ j ] + max NEW_LINE DEDENT DEDENT for j in range ( n ) : NEW_LINE INDENT if ( maxSum < dp [ 0 ] [ j ] ) : NEW_LINE INDENT maxSum = dp [ 0 ] [ j ] NEW_LINE DEDENT DEDENT return maxSum NEW_LINE DEDENT
def arcLength ( diameter , angle ) : NEW_LINE INDENT pi = 22.0 / 7.0 NEW_LINE arc = 0 NEW_LINE if angle >= 360 : NEW_LINE INDENT print ( " Angle ▁ cannot " , " ▁ be ▁ formed " ) NEW_LINE return 0 NEW_LINE DEDENT else : NEW_LINE INDENT arc = ( pi * diameter ) * ( angle / 360.0 ) NEW_LINE return arc NEW_LINE DEDENT DEDENT
def isPrime ( n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def findMaxAverage ( arr , n , k ) : NEW_LINE INDENT if ( k > n ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT csum = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT csum [ i ] = csum [ i - 1 ] + arr [ i ] NEW_LINE DEDENT max_sum = csum [ k - 1 ] NEW_LINE max_end = k - 1 NEW_LINE for i in range ( k , n ) : NEW_LINE INDENT curr_sum = csum [ i ] - csum [ i - k ] NEW_LINE if curr_sum > max_sum : NEW_LINE INDENT max_sum = curr_sum NEW_LINE max_end = i NEW_LINE DEDENT DEDENT return max_end - k + 1 NEW_LINE DEDENT
def horner ( poly , n , x ) : NEW_LINE INDENT result = poly [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT result = result * x + poly [ i ] NEW_LINE DEDENT return result NEW_LINE DEDENT
def numberOfWays ( x ) : NEW_LINE INDENT dp = [ 0 for i in range ( x + 1 ) ] NEW_LINE dp [ 0 ] = dp [ 1 ] = 1 NEW_LINE for i in range ( 2 , x + 1 ) : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] NEW_LINE DEDENT return dp [ x ] NEW_LINE DEDENT
def maxRowDiff ( mat , m , n ) : NEW_LINE INDENT rowSum = [ 0 for i in range ( m ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT sum = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT sum += mat [ i ] [ j ] NEW_LINE DEDENT rowSum [ i ] = sum NEW_LINE DEDENT max_diff = rowSum [ 1 ] - rowSum [ 0 ] NEW_LINE min_element = rowSum [ 0 ] NEW_LINE for i in range ( 1 , m ) : NEW_LINE INDENT if ( rowSum [ i ] - min_element > max_diff ) : NEW_LINE INDENT max_diff = rowSum [ i ] - min_element NEW_LINE DEDENT if ( rowSum [ i ] < min_element ) : NEW_LINE INDENT min_element = rowSum [ i ] NEW_LINE DEDENT DEDENT return max_diff NEW_LINE DEDENT
def minCost ( cost , m , n ) : NEW_LINE INDENT tc = [ [ 0 for k in range ( n ) ] for l in range ( R ) ] NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT tc [ i ] [ 0 ] = cost [ 0 ] [ 0 ] NEW_LINE for j in range ( 1 , n + 1 ) : NEW_LINE INDENT tc [ 0 ] [ j ] = tc [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ] NEW_LINE DEDENT for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT tc [ i ] [ j ] = min ( tc [ i - 1 ] [ j - 1 ] , tc [ i - 1 ] [ j ] , tc [ i ] [ j - 1 ] ) + cost [ i ] [ j ] NEW_LINE DEDENT DEDENT return tc [ m ] [ n ] NEW_LINE DEDENT
def count_of_ways ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT for k in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( i + j + k == n ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def countCommon ( mat , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( mat [ i ] [ i ] == mat [ i ] [ n - i - 1 ] ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def hexagonalNum ( n ) : NEW_LINE INDENT return ( n * ( 2 * n - 1 ) ) NEW_LINE DEDENT
def findGreatest ( arr , n ) : NEW_LINE INDENT result = - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , n - 1 ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT if ( arr [ j ] * arr [ k ] == arr [ i ] ) : NEW_LINE INDENT result = max ( result , arr [ i ] ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def squareRoot ( n , p ) : NEW_LINE INDENT n = n % p NEW_LINE x = 2 NEW_LINE for x in range ( p ) : NEW_LINE INDENT if ( ( x * x ) % p == n ) : NEW_LINE INDENT print ( " Square ▁ root ▁ is ▁ " , x ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( " Square ▁ root ▁ doesn 't ▁ exist " ) NEW_LINE DEDENT
def leonardo ( n ) : NEW_LINE INDENT dp = [ 0 for i in range ( n + 1 ) ] NEW_LINE dp [ 0 ] = dp [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] + 1 NEW_LINE DEDENT return dp [ n ] NEW_LINE DEDENT
def evenbinomialCoeffSum ( n ) : NEW_LINE INDENT return ( 1 << ( n - 1 ) ) NEW_LINE DEDENT
def findMin ( arr , low , high ) : NEW_LINE INDENT if ( high < low ) : NEW_LINE INDENT return arr [ 0 ] NEW_LINE DEDENT if ( high == low ) : NEW_LINE INDENT return arr [ low ] NEW_LINE DEDENT mid = low + ( high - low ) // 2 NEW_LINE if ( mid < high and arr [ mid + 1 ] < arr [ mid ] ) : NEW_LINE INDENT return arr [ mid + 1 ] NEW_LINE DEDENT if ( mid > low and arr [ mid ] < arr [ mid - 1 ] ) : NEW_LINE INDENT return arr [ mid ] NEW_LINE DEDENT if ( arr [ high ] > arr [ mid ] ) : NEW_LINE INDENT return findMin ( arr , low , mid - 1 ) NEW_LINE DEDENT return findMin ( arr , mid + 1 , high ) NEW_LINE DEDENT
def findS ( s ) : NEW_LINE INDENT sum = 0 NEW_LINE for n in range ( 1 , s ) : NEW_LINE INDENT sum += n * n NEW_LINE if ( sum == s ) : NEW_LINE INDENT return n NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def countStr ( n ) : NEW_LINE INDENT return 1 + ( n * 2 ) + ( n * ( ( n * n ) - 1 ) / 2 ) NEW_LINE DEDENT
def printSumSimple ( mat , k ) : NEW_LINE INDENT global n NEW_LINE if k > n : NEW_LINE INDENT return NEW_LINE DEDENT for i in range ( n - k + 1 ) : NEW_LINE INDENT for j in range ( n - k + 1 ) : NEW_LINE INDENT sum = 0 NEW_LINE for p in range ( i , k + i ) : NEW_LINE INDENT for q in range ( j , k + j ) : NEW_LINE INDENT sum += mat [ p ] [ q ] NEW_LINE DEDENT print ( sum , end = " ▁ " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT
def countGroups ( position , previous_sum , length , num ) : NEW_LINE INDENT if ( position == length ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( previous_sum != - 1 ) : NEW_LINE INDENT return dp [ position ] [ previous_sum ] NEW_LINE DEDENT res = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( position , length ) : NEW_LINE INDENT sum += ( num [ i ] - ord ( '0' ) ) NEW_LINE if ( sum >= previous_sum ) : NEW_LINE INDENT res += countGroups ( i + 1 , sum , length , num ) NEW_LINE DEDENT dp [ position ] [ previous_sum ] = res NEW_LINE return res NEW_LINE DEDENT
def intersection ( n ) : NEW_LINE INDENT return n * ( n - 1 ) NEW_LINE DEDENT
def findSum ( n ) : NEW_LINE INDENT n -= 1 NEW_LINE sum = 0 NEW_LINE sum += ( n * ( n + 1 ) ) / 2 NEW_LINE sum += ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 NEW_LINE return int ( sum ) NEW_LINE DEDENT
def findRepeatingElement ( arr , low , high ) : NEW_LINE INDENT if low > high : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = low + ( high - low ) / 2 NEW_LINE if arr [ mid ] != mid + 1 : NEW_LINE INDENT if mid > 0 and arr [ mid ] == arr [ mid - 1 ] : NEW_LINE INDENT return mid NEW_LINE DEDENT return findRepeatingElement ( arr , low , mid - 1 ) NEW_LINE DEDENT
def maxAverageOfPath ( cost , N ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( N + 1 ) ] for j in range ( N ) ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT dp [ i ] [ 0 ] = cost [ 0 ] [ 0 ] NEW_LINE for j in range ( 1 , N + 1 ) : NEW_LINE INDENT dp [ 0 ] [ j ] = dp [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ] NEW_LINE DEDENT DEDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( 1 , N + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) + cost [ i ] [ j ] NEW_LINE DEDENT DEDENT return ( double ) dp [ N - 1 ] [ N - 1 ] / ( 2 * N - 1 ) NEW_LINE DEDENT
def countPairsWithDiffK ( arr , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] - arr [ j ] == k or arr [ j ] - arr [ i ] == k ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def isPrime ( n , i ) : NEW_LINE INDENT if ( n <= 2 ) : NEW_LINE INDENT return ( n == 2 ) else False NEW_LINE DEDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( i * i > n ) : NEW_LINE INDENT return True NEW_LINE DEDENT return isPrime ( n , i + 1 ) NEW_LINE DEDENT
def computeLastDigit ( A , B ) : NEW_LINE INDENT variable = 1 NEW_LINE if A == B : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( B - A ) >= 5 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( A + 1 , B + 1 ) : NEW_LINE INDENT variable = ( variable * ( i % 10 ) ) % 10 NEW_LINE DEDENT return variable % 10 NEW_LINE DEDENT DEDENT
def check ( n ) : NEW_LINE INDENT return 1162261467 % n == 0 NEW_LINE DEDENT
def sequence ( n ) : NEW_LINE INDENT if ( n == 1 or n == 2 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return sequence ( sequence ( n - 1 ) ) + sequence ( n - sequence ( n - 1 ) ) NEW_LINE DEDENT DEDENT
def findHeight ( parent , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT p = i NEW_LINE current = 1 NEW_LINE while ( parent [ p ] != - 1 ) : NEW_LINE INDENT current += 1 NEW_LINE p = parent [ p ] NEW_LINE DEDENT res = max ( res , current ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def HalfDiagonalSums ( mat , n ) : NEW_LINE INDENT diag1_left = 0 NEW_LINE diag1_right = 0 NEW_LINE diag2_left = 0 NEW_LINE diag2_right = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( i < n // 2 ) : NEW_LINE INDENT diag1_left += mat [ i ] [ i ] NEW_LINE diag2_left += mat [ j ] [ i ] NEW_LINE DEDENT elif ( i > n // 2 ) : NEW_LINE INDENT diag1_right += mat [ i ] [ i ] NEW_LINE diag2_right += mat [ j ] [ i ] NEW_LINE DEDENT DEDENT return ( diag1_left == diag2_right and diag2_right == diag2_left and diag1_right == diag2_left and diag2_right == mat [ n // 2 ] [ n // 2 ] ) NEW_LINE DEDENT
def LeibnizHarmonicTriangle ( n ) : NEW_LINE INDENT C = [ [ 0 for j in range ( n + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 0 , min ( i , n + 1 ) ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT print ( i * C [ i - 1 ] [ j - 1 ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT
def floorSearch ( arr , n , x ) : NEW_LINE INDENT if x >= arr [ n - 1 ] : NEW_LINE INDENT return n - 1 NEW_LINE DEDENT if x < arr [ 0 ] : NEW_LINE INDENT return - 1 NEW_LINE DEDENT i = 1 NEW_LINE while i < n : NEW_LINE INDENT if arr [ i ] > x : NEW_LINE INDENT return ( i - 1 ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def minimumflip ( mat , n ) : NEW_LINE INDENT flip = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , i ) : NEW_LINE INDENT if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) : NEW_LINE INDENT flip += 1 NEW_LINE DEDENT DEDENT DEDENT return flip NEW_LINE DEDENT
def breakSum ( n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT return max ( ( breakSum ( n // 2 ) + breakSum ( n / 3 ) + breakSum ( n // 4 ) ) , n ) NEW_LINE DEDENT
def countPairs ( arr1 , arr2 , m , n , x ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , m ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT if ( ( arr1 [ i ] + arr2 [ j ] ) == x ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def alternateSubarray ( arr , n ) : NEW_LINE INDENT len = [ 0 ] * n NEW_LINE len [ n - 1 ] = 1 NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] ^ arr [ i + 1 ] == 1 ) : NEW_LINE INDENT len [ i ] = len [ i + 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT len [ i ] = 1 NEW_LINE DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( len [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def subsequence ( s , t , n , k ) : NEW_LINE INDENT last = 0 NEW_LINE cnt = 0 NEW_LINE new_last = 0 NEW_LINE size = 0 NEW_LINE for ch in range ( ' z ' , - 1 , - 1 ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( last , n ) : NEW_LINE INDENT if ( s [ i ] == ch ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT if ( cnt >= k ) : NEW_LINE INDENT for i in range ( last , n ) : NEW_LINE INDENT if ( s [ i ] == ch ) : NEW_LINE INDENT t [ size ] = ch NEW_LINE new_last = i NEW_LINE DEDENT DEDENT last = new_last NEW_LINE DEDENT DEDENT t [ size ] = ' \0 ' NEW_LINE DEDENT
def maxLen ( arr , n ) : NEW_LINE INDENT max_len = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT curr_sum = 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT curr_sum += arr [ j ] NEW_LINE if curr_sum == 0 : NEW_LINE INDENT max_len = max ( max_len , j - i + 1 ) NEW_LINE DEDENT DEDENT return max_len NEW_LINE DEDENT
def lcs ( X , Y , m , n ) : NEW_LINE INDENT if ( m == 0 or n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( X [ m - 1 ] == Y [ n - 1 ] ) : NEW_LINE INDENT return 1 + lcs ( X , Y , m - 1 , n - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return max ( lcs ( X , Y , m , n - 1 ) , lcs ( X , Y , m - 1 , n ) ) NEW_LINE DEDENT DEDENT
def multiply ( x , y ) : NEW_LINE INDENT if ( y == 0 ) : return 0 NEW_LINE if ( y > 0 ) : NEW_LINE INDENT return ( x + multiply ( x , y - 1 ) ) NEW_LINE DEDENT if ( y < 0 ) : NEW_LINE INDENT return - multiply ( x , - y ) NEW_LINE DEDENT DEDENT
def countP ( n , k ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( k + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = 0 NEW_LINE DEDENT for i in range ( k + 1 ) : NEW_LINE INDENT dp [ 0 ] [ k ] = 0 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT if ( j == 1 or i == j ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = j * dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT return dp [ n ] [ k ] NEW_LINE DEDENT
def maxvolume ( s ) : NEW_LINE INDENT length = s // 3 NEW_LINE s -= length NEW_LINE breadth = s // 2 NEW_LINE height = s - breadth NEW_LINE return length * breadth * height NEW_LINE DEDENT
def findLength ( str1 ) : NEW_LINE INDENT n = len ( str1 ) NEW_LINE maxlen = 0 NEW_LINE sum = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum [ i ] [ i ] = ord ( str1 [ i ] ) - ord ( '0' ) NEW_LINE DEDENT for len in range ( 2 , n + 1 ) : NEW_LINE INDENT for i in range ( n - len + 1 ) : NEW_LINE INDENT j = i + len - 1 NEW_LINE k = len // 2 NEW_LINE if ( len % 2 == 0 and sum [ i ] [ j - k ] == sum [ ( j - k + 1 ) ] [ j ] and len > maxlen ) : NEW_LINE INDENT maxlen = len NEW_LINE DEDENT DEDENT DEDENT return maxlen NEW_LINE DEDENT
def subArraySum ( arr , n , Sum ) : NEW_LINE INDENT curr_sum = arr [ 0 ] NEW_LINE start = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT while ( curr_sum > Sum and start < i - 1 ) : NEW_LINE INDENT curr_sum = curr_sum - arr [ start ] NEW_LINE start += 1 NEW_LINE DEDENT if ( curr_sum == Sum ) : NEW_LINE INDENT print ( " Sum ▁ found ▁ between ▁ indexes ▁ start , " and ▁ " , i - 1 ) NEW_LINE return 1 NEW_LINE DEDENT if ( i < n ) : NEW_LINE INDENT curr_sum = curr_sum + arr [ i ] NEW_LINE DEDENT DEDENT print ( " No ▁ subarray ▁ found " ) NEW_LINE return 0 NEW_LINE DEDENT
def generateSquare ( n ) : NEW_LINE INDENT magicSquare = [ [ 0 for x in range ( n + 1 ) ] for y in range ( n + 1 ) ] NEW_LINE i = n // 2 NEW_LINE j = n - 1 NEW_LINE for num in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( i == - 1 and j == n ) : NEW_LINE INDENT j = n - 2 NEW_LINE i = 0 NEW_LINE DEDENT else : NEW_LINE INDENT if ( i < 0 ) : NEW_LINE INDENT i = n - 1 NEW_LINE DEDENT DEDENT if ( magicSquare [ i ] [ j ] ) : NEW_LINE INDENT j -= 2 NEW_LINE i += 1 NEW_LINE continue NEW_LINE DEDENT else : NEW_LINE INDENT magicSquare [ i ] [ j ] = num NEW_LINE j += 1 NEW_LINE i -= 1 NEW_LINE DEDENT DEDENT print ( " The ▁ Magic ▁ Square ▁ for ▁ n = " , n , " : \n " ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT print ( magicSquare [ i ] [ j ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT
def countOnes ( arr , low , high ) : NEW_LINE INDENT if ( high >= low ) : NEW_LINE INDENT mid = low + ( high - low ) // 2 NEW_LINE if ( ( mid == high or arr [ mid + 1 ] == 0 ) and ( arr [ mid ] == 1 ) ) : NEW_LINE INDENT return mid + 1 NEW_LINE DEDENT if ( arr [ mid ] == 1 ) : NEW_LINE INDENT return countOnes ( arr , ( mid + 1 ) , high ) NEW_LINE DEDENT return countOnes ( arr , low , ( mid - 1 ) ) NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT
def ceilSearch ( arr , low , high , x ) : NEW_LINE INDENT if x <= arr [ low ] : NEW_LINE INDENT return low NEW_LINE DEDENT if x > arr [ high ] : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = low + ( high - low ) / 2 NEW_LINE if arr [ mid ] == x : NEW_LINE INDENT return mid NEW_LINE DEDENT elif arr [ mid ] < x : NEW_LINE INDENT if mid + 1 <= high and x <= arr [ mid + 1 ] : NEW_LINE INDENT return mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT return ceilSearch ( arr , mid + 1 , high , x ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if mid - 1 >= low and x > arr [ mid - 1 ] : NEW_LINE INDENT return mid NEW_LINE DEDENT else : NEW_LINE INDENT return ceilSearch ( arr , low , mid - 1 , x ) NEW_LINE DEDENT DEDENT DEDENT
def decToBin ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return "0" NEW_LINE DEDENT bin = " " NEW_LINE while ( n > 0 ) : NEW_LINE INDENT bin = ( ( n & 1 ) == 0 ? '0' : '1' ) + bin NEW_LINE n >>= 1 NEW_LINE DEDENT return bin NEW_LINE DEDENT
def printNos ( n ) : NEW_LINE INDENT printNos ( n - 1 ) NEW_LINE print ( n , end = " ▁ " ) NEW_LINE DEDENT return NEW_LINE DEDENT
def eulerian ( n , m ) : NEW_LINE INDENT if ( m >= n or n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( m == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return ( n - m ) * eulerian ( n - 1 , m - 1 ) + ( m + 1 ) * eulerian ( n - 1 , m ) ) NEW_LINE DEDENT
def areaSquare ( side ) : NEW_LINE INDENT area = side * side NEW_LINE return area NEW_LINE DEDENT
def spiralDiaSum ( n ) : NEW_LINE INDENT if ( n == 1 ) : return 1 NEW_LINE return ( 4 * n * n - 6 * n + 6 + spiralDiaSum ( n - 2 ) ) NEW_LINE DEDENT
def countOccurrences ( arr , n , x ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( x == arr [ i ] ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def doublefactorial ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( n - 2 ) : NEW_LINE INDENT if i == 0 or i == 1 : NEW_LINE INDENT return res NEW_LINE DEDENT else : NEW_LINE INDENT res = res * i NEW_LINE DEDENT DEDENT DEDENT
def lcs ( X , Y , m , n ) : NEW_LINE INDENT if ( m == 0 or n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( X [ m - 1 ] == Y [ n - 1 ] ) : NEW_LINE INDENT return 1 + lcs ( X , Y , m - 1 , n - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return max ( lcs ( X , Y , m , n - 1 ) , lcs ( X , Y , m - 1 , n ) ) NEW_LINE DEDENT DEDENT
def offeringNumber ( n , templeHeight ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT left = 0 NEW_LINE right = 0 NEW_LINE for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( templeHeight [ j ] < templeHeight [ j + 1 ] ) : NEW_LINE INDENT left += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( templeHeight [ j ] < templeHeight [ j - 1 ] ) : NEW_LINE INDENT right += 1 NEW_LINE DEDENT else : NEW_LINE INDENT DEDENT sum += max ( right , left ) + 1 NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def constructPalin ( str , len ) : NEW_LINE INDENT i , j = 0 , len - 1 NEW_LINE while i < j : NEW_LINE INDENT if ( str [ i ] == str [ j ] and str [ i ] != ' * ' ) : NEW_LINE INDENT continue NEW_LINE DEDENT elif ( str [ i ] == str [ j ] and str [ i ] == ' * ' ) : NEW_LINE INDENT str [ i ] = ' a ' NEW_LINE str [ j ] = ' a ' NEW_LINE continue NEW_LINE DEDENT elif ( str [ i ] == str [ j ] and str [ i ] == ' * ' ) : NEW_LINE INDENT str [ i ] = str [ j ] NEW_LINE continue NEW_LINE DEDENT elif ( str [ j ] == ' * ' ) : NEW_LINE INDENT str [ j ] = str [ i ] NEW_LINE continue NEW_LINE DEDENT elif ( str [ i ] == ' * ' ) : NEW_LINE INDENT str [ i ] = str [ j ] NEW_LINE continue NEW_LINE DEDENT elif ( str [ j ] == ' * ' ) : NEW_LINE INDENT str [ j ] = str [ i ] NEW_LINE continue NEW_LINE DEDENT DEDENT print ( " Not ▁ Possible " ) NEW_LINE return " " NEW_LINE DEDENT
def countPairs ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] == arr [ j ] ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def evenFib ( n ) : NEW_LINE INDENT if ( n < 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT return ( ( 4 * evenFib ( n - 1 ) ) + evenFib ( n - 2 ) ) NEW_LINE DEDENT
def findSum ( N ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( i , N + 1 ) : NEW_LINE INDENT sum = sum + i * j NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def binomialCoeffSum ( n ) : NEW_LINE INDENT return ( 1 << n ) NEW_LINE DEDENT
def printknapSack ( W , wt , val , n ) : NEW_LINE INDENT K = [ [ 0 for i in range ( W + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for w in range ( W + 1 ) : NEW_LINE INDENT if ( i == 0 or w == 0 ) : NEW_LINE INDENT K [ i ] [ w ] = 0 NEW_LINE DEDENT elif ( wt [ i - 1 ] <= w ) : NEW_LINE INDENT K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) NEW_LINE DEDENT else : NEW_LINE INDENT K [ i ] [ w ] = K [ i - 1 ] [ w ] NEW_LINE DEDENT DEDENT DEDENT res = K [ n ] [ W ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT if ( res == K [ i - 1 ] [ w ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT print ( " % d ▁ " , wt [ i - 1 ] ) NEW_LINE res = res - val [ i - 1 ] NEW_LINE w = w - wt [ i - 1 ] NEW_LINE DEDENT DEDENT DEDENT
def getTotalNumberOfSequences ( m , n ) : NEW_LINE INDENT T = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if ( i == 0 or j == 0 ) : NEW_LINE INDENT T [ i ] [ j ] = 0 NEW_LINE DEDENT elif ( i < j ) : NEW_LINE INDENT T [ i ] [ j ] = 0 NEW_LINE DEDENT elif ( j == 1 ) : NEW_LINE INDENT T [ i ] [ j ] = i NEW_LINE DEDENT else : NEW_LINE INDENT T [ i ] [ j ] = T [ i - 1 ] [ j ] + T [ i // 2 ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT return T [ m ] [ n ] NEW_LINE DEDENT
def maxPrimeFactors ( n ) : NEW_LINE INDENT maxPrime = - 1 NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT maxPrime = 2 NEW_LINE n >>= 1 NEW_LINE DEDENT for i in range ( 3 , int ( m . sqrt ( n ) + 2 ) ) : NEW_LINE INDENT while ( n % i == 0 ) : NEW_LINE INDENT maxPrime = i NEW_LINE n = n / i NEW_LINE DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT maxPrime = n NEW_LINE DEDENT return maxPrime NEW_LINE DEDENT
def remainderWith7 ( num ) : NEW_LINE INDENT series = [ 1 , 3 , 2 , - 1 , - 3 , - 2 ] NEW_LINE result = 0 NEW_LINE series_index = 0 NEW_LINE for i in range ( len ( num ) - 1 ) : NEW_LINE INDENT digit = ord ( num [ i ] ) - ord ( '0' ) NEW_LINE result += digit * series [ series_index ] NEW_LINE series_index = ( series_index + 1 ) % 6 NEW_LINE result %= 7 NEW_LINE DEDENT if result < 0 : NEW_LINE INDENT result = ( result + 7 ) % 7 NEW_LINE DEDENT return result NEW_LINE DEDENT
def getRemainder ( num , divisor ) : NEW_LINE INDENT return ( num - divisor * ( num / divisor ) ) NEW_LINE DEDENT
def getSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT sum = sum + n % 10 NEW_LINE n = int ( n / 10 ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
def fill0X ( m , n ) : NEW_LINE INDENT k = 0 l = 0 NEW_LINE r = m NEW_LINE c = n NEW_LINE a = [ [ 0 for i in range ( n ) ] for j in range ( m ) ] NEW_LINE x = ' X ' NEW_LINE while ( k < m and l < n ) : NEW_LINE INDENT for i in range ( l , n ) : NEW_LINE INDENT a [ k ] [ i ] = x NEW_LINE k += 1 NEW_LINE DEDENT for i in range ( k , m ) : NEW_LINE INDENT a [ i ] [ n - 1 ] = x NEW_LINE n -= 1 NEW_LINE DEDENT if ( k < m ) : NEW_LINE INDENT for i in range ( n - 1 , l - 1 , - 1 ) : NEW_LINE INDENT a [ m - 1 ] [ i ] = x NEW_LINE DEDENT m -= 1 NEW_LINE DEDENT if ( l < n ) : NEW_LINE INDENT for i in range ( m - 1 , k - 1 , - 1 ) : NEW_LINE INDENT a [ i ] [ l ] = x NEW_LINE l += 1 NEW_LINE DEDENT DEDENT x = ( x == '0' ) ? ' X ' : '0' ) NEW_LINE DEDENT DEDENT for i in range ( r ) : NEW_LINE INDENT for j in range ( c ) : NEW_LINE INDENT print ( a [ i ] [ j ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def slope ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT return ( y2 - y1 ) / ( x2 - x1 ) NEW_LINE DEDENT
def countNegative ( M , n , m ) : NEW_LINE INDENT count = 0 NEW_LINE i = 0 NEW_LINE j = m - 1 NEW_LINE while ( j >= 0 and i < n ) : NEW_LINE INDENT if ( M [ i ] [ j ] < 0 ) : NEW_LINE INDENT count += j + 1 NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def maxSumIS ( arr , n ) : NEW_LINE INDENT max = 0 NEW_LINE msis = [ 0 ] * n NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT msis [ i ] = arr [ i ] NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( 0 , i ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and msis [ i ] < msis [ j ] + arr [ i ] ) : NEW_LINE INDENT msis [ i ] = msis [ j ] + arr [ i ] NEW_LINE DEDENT DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( max < msis [ i ] ) : NEW_LINE INDENT max = msis [ i ] NEW_LINE DEDENT DEDENT return max NEW_LINE DEDENT
def maxLength ( s , n ) : NEW_LINE INDENT invalidOpenBraces = 0 NEW_LINE invalidCloseBraces = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == ' ( ' ) : NEW_LINE INDENT invalidOpenBraces += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( invalidOpenBraces == 0 ) : NEW_LINE INDENT invalidCloseBraces += 1 NEW_LINE DEDENT else : NEW_LINE INDENT invalidOpenBraces -= 1 NEW_LINE DEDENT DEDENT return ( n - ( invalidOpenBraces + invalidCloseBraces ) ) NEW_LINE DEDENT
def tower ( n , sourcePole , destinationPole , auxiliaryPole ) : NEW_LINE INDENT if ( 0 == n ) : NEW_LINE INDENT return NEW_LINE DEDENT tower ( n - 1 , sourcePole , auxiliaryPole , destinationPole ) NEW_LINE print ( " Move ▁ the ▁ disk ▁ " , n , " ▁ from ▁ " , sourcePole , " ▁ to " , destinationPole ) NEW_LINE print ( " Move ▁ the ▁ disk ▁ " , n , " ▁ to " , destinationPole ) NEW_LINE DEDENT
def findMaximumPieces ( n ) : NEW_LINE INDENT return 1 + n * ( n + 1 ) / 2 NEW_LINE DEDENT
def findMinInsertions ( str , l , h ) : NEW_LINE INDENT if ( l > h ) : NEW_LINE INDENT return sys . maxsize NEW_LINE DEDENT if ( l == h - 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( str [ l ] == str [ h ] ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return ( findMinInsertions ( str , l + 1 , h - 1 ) ) NEW_LINE DEDENT
def octalToDecimal ( n ) : NEW_LINE INDENT num = n NEW_LINE dec_value = 0 NEW_LINE base = 1 NEW_LINE temp = num NEW_LINE while ( temp ) : NEW_LINE INDENT last_digit = temp % 10 NEW_LINE temp = int ( temp / 10 ) NEW_LINE dec_value += last_digit * base NEW_LINE base = base * 8 NEW_LINE DEDENT return dec_value NEW_LINE DEDENT
def printSquares ( n ) : NEW_LINE INDENT square = 0 NEW_LINE prev_x = 0 NEW_LINE for x in range ( n ) : NEW_LINE INDENT square = ( square + x + prev_x ) NEW_LINE print ( square , end = " ▁ " ) NEW_LINE prev_x = x NEW_LINE DEDENT DEDENT
def sequence ( n ) : NEW_LINE INDENT f = [ 0 for i in range ( n + 1 ) ] NEW_LINE f [ 0 ] = 0 NEW_LINE f [ 1 ] = 1 NEW_LINE f [ 2 ] = 1 NEW_LINE print ( f [ 1 ] , end = " ▁ " ) NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT f [ i ] = f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ] NEW_LINE print ( f [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def maxSubsequenceSubstring ( x , y , n , m ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( MAX ) ] for j in range ( MAX ) ] NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( x [ j - 1 ] == y [ i - 1 ] ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT ans = max ( ans , dp [ i ] [ n ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def getMedian ( ar1 , ar2 , n ) : NEW_LINE INDENT i = 0 NEW_LINE j = 0 NEW_LINE count = 0 NEW_LINE m1 = - 1 NEW_LINE m2 = - 1 NEW_LINE for count in range ( n + 1 ) : NEW_LINE INDENT if i == n : NEW_LINE INDENT m1 = m2 NEW_LINE m2 = ar2 [ 0 ] NEW_LINE break NEW_LINE DEDENT elif j == n : NEW_LINE INDENT m1 = m2 NEW_LINE m2 = ar1 [ 0 ] NEW_LINE break NEW_LINE DEDENT if i == n : NEW_LINE INDENT m1 = m2 NEW_LINE m2 = ar2 [ 0 ] NEW_LINE break NEW_LINE DEDENT elif i == n : NEW_LINE INDENT m1 = m2 NEW_LINE m2 = ar1 [ 0 ] NEW_LINE break NEW_LINE DEDENT elif j == n : NEW_LINE INDENT m1 = m2 NEW_LINE m2 = ar1 [ 0 ] NEW_LINE break NEW_LINE DEDENT if ar1 [ i ] < ar2 [ j ] : NEW_LINE INDENT m1 = m2 NEW_LINE m2 = ar1 [ i ] NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT m1 = m2 NEW_LINE m2 = ar2 [ j ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT return ( m1 + m2 ) // 2 NEW_LINE DEDENT
def countZeroes ( mat ) : NEW_LINE INDENT row = N - 1 NEW_LINE col = 0 NEW_LINE count = 0 NEW_LINE while ( col < N ) : NEW_LINE INDENT while ( mat [ row ] [ col ] ) : NEW_LINE INDENT if ( -- row < 0 ) : NEW_LINE INDENT return count NEW_LINE DEDENT count += ( row + 1 ) NEW_LINE col += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def solution ( a , b , n ) : NEW_LINE INDENT for i in range ( 0 , a + 1 ) : NEW_LINE INDENT if ( ( n - ( i * a ) ) % b == 0 ) : NEW_LINE INDENT print ( " x ▁ = ▁ " , i , " , ▁ y ▁ = ▁ " , ( n - ( i * a ) ) / b ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( " No ▁ solution " ) NEW_LINE DEDENT
def Circumference ( a ) : NEW_LINE INDENT return 4 * a NEW_LINE DEDENT
def numberOfPaths ( m , n ) : NEW_LINE INDENT path = 1 NEW_LINE for i in range ( n , ( m + n - 1 ) ) : NEW_LINE INDENT path = path * i NEW_LINE path /= ( i - n + 1 ) NEW_LINE DEDENT return path NEW_LINE DEDENT
def pointClip ( XY , n , Xmin , Ymin , Xmax , Ymax ) : NEW_LINE INDENT print ( " Point ▁ inside ▁ the ▁ viewing ▁ pane : " ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( ( XY [ i ] [ 0 ] >= Xmin ) and ( XY [ i ] [ 0 ] <= Xmax ) ) : NEW_LINE INDENT if ( ( XY [ i ] [ 1 ] >= Ymin ) and ( XY [ i ] [ 1 ] <= Ymax ) ) : NEW_LINE INDENT print ( " [ " , XY [ i ] [ 0 ] , " , " , XY [ i ] [ 1 ] , " ] ▁ " ) NEW_LINE DEDENT DEDENT DEDENT print ( " Point ▁ outside ▁ the ▁ viewing ▁ pane : " ) NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( ( XY [ i ] [ 0 ] < Xmin ) or ( XY [ i ] [ 0 ] > Xmax ) ) : NEW_LINE INDENT print ( " [ " , XY [ i ] [ 0 ] , " , " , XY [ i ] [ 1 ] , " ] ▁ " ) NEW_LINE DEDENT DEDENT
def pre_compute ( a , n , index , k ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] > a [ 0 ] ) : NEW_LINE INDENT dp [ 0 ] [ i ] = a [ i ] + a [ 0 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ 0 ] [ i ] = a [ i ] NEW_LINE DEDENT DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( a [ j ] > a [ i ] and j > i ) : NEW_LINE INDENT if ( dp [ i - 1 ] [ i ] + a [ j ] > dp [ i - 1 ] [ j ] ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ i ] + a [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return dp [ index ] [ k ] NEW_LINE DEDENT
def splitArr ( arr , n , k ) : NEW_LINE INDENT for i in range ( k ) : NEW_LINE INDENT x = arr [ 0 ] NEW_LINE for j in range ( n - 1 ) : NEW_LINE INDENT arr [ j ] = arr [ j + 1 ] NEW_LINE j += 1 NEW_LINE DEDENT arr [ n - 1 ] = x NEW_LINE DEDENT DEDENT
def smallestSubWithSum ( arr , n , x ) : NEW_LINE INDENT curr_sum = 0 NEW_LINE min_len = n + 1 NEW_LINE start = 0 NEW_LINE end = 0 NEW_LINE while ( end < n ) : NEW_LINE INDENT while ( curr_sum <= x and end < n ) : NEW_LINE INDENT if ( curr_sum <= 0 and x > 0 ) : NEW_LINE INDENT start = end NEW_LINE curr_sum = 0 NEW_LINE DEDENT curr_sum += arr [ end ] NEW_LINE DEDENT while ( curr_sum > x and start < n ) : NEW_LINE INDENT if ( end - start < min_len ) : NEW_LINE INDENT min_len = end - start NEW_LINE DEDENT curr_sum -= arr [ start ] NEW_LINE DEDENT DEDENT return min_len NEW_LINE DEDENT
def winner ( a , n , k ) : NEW_LINE INDENT if ( k >= n - 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT best = 0 NEW_LINE times = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] > best ) : NEW_LINE INDENT best = a [ i ] NEW_LINE if ( i ) : NEW_LINE INDENT times = 1 NEW_LINE DEDENT else : NEW_LINE INDENT times += 1 NEW_LINE DEDENT if ( times >= k ) : NEW_LINE INDENT return best NEW_LINE DEDENT DEDENT return best NEW_LINE DEDENT
def countSolutions ( n ) : NEW_LINE INDENT x = 0 NEW_LINE yCount = 0 NEW_LINE res = 0 NEW_LINE for yCount in range ( n ) : NEW_LINE INDENT res += yCount NEW_LINE x += 1 NEW_LINE while ( yCount != 0 ) : NEW_LINE INDENT res += yCount NEW_LINE x += 1 NEW_LINE while ( yCount != 0 and ( x * x + ( yCount - 1 ) * ( yCount - 1 ) >= n ) : NEW_LINE INDENT yCount -= 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def maxProduct ( arr , n ) : NEW_LINE INDENT if ( n < 3 ) : return - 1 NEW_LINE DEDENT max_product = - 1 NEW_LINE for i in range ( 0 , n - 2 ) : NEW_LINE INDENT for j in range ( i + 1 , n - 1 ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT max_product = max ( max_product , arr [ i ] * arr [ j ] * arr [ k ] ) NEW_LINE DEDENT DEDENT return max_product NEW_LINE DEDENT
def solveWordWrap ( arr , n , k ) : NEW_LINE INDENT currlen = - 1 NEW_LINE dp = [ 0 ] * ( n - 1 ) NEW_LINE ans = [ n - 1 ] * ( n - 1 ) NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT currlen = - 1 NEW_LINE dp [ i ] = sys . maxsize NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT currlen += ( arr [ j ] + 1 ) NEW_LINE if ( currlen > k ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( j == n - 1 ) : NEW_LINE INDENT cost = 0 NEW_LINE DEDENT else : NEW_LINE INDENT cost = ( k - currlen ) * ( k - currlen ) + dp [ j + 1 ] NEW_LINE if ( cost < dp [ i ] ) : NEW_LINE INDENT dp [ i ] = cost NEW_LINE ans [ i ] = j NEW_LINE DEDENT DEDENT DEDENT i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT print ( i + 1 , " ▁ " , ans [ i ] + 1 , " ▁ " ) NEW_LINE i = ans [ i ] + 1 NEW_LINE DEDENT DEDENT
def sumofFactors ( n ) : NEW_LINE INDENT if ( n % 2 != 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT res = 1 NEW_LINE for i in range ( 2 , int ( m . sqrt ( n ) + 1 ) ) : NEW_LINE INDENT count = 0 NEW_LINE curr_sum = 1 NEW_LINE curr_term = 1 NEW_LINE while ( n % i == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE n = n / i NEW_LINE if ( i == 2 and count == 1 ) : NEW_LINE INDENT curr_sum = 0 NEW_LINE curr_term = curr_term * i NEW_LINE curr_sum += curr_term NEW_LINE DEDENT res = res * curr_sum NEW_LINE DEDENT if ( n > 2 ) : NEW_LINE INDENT res = res * ( 1 + n ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def maxGameByWinner ( N ) : NEW_LINE INDENT dp = [ 0 for i in range ( N ) ] NEW_LINE dp [ 0 ] = 1 NEW_LINE dp [ 1 ] = 2 NEW_LINE i = 2 NEW_LINE while ( i <= N ) : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] NEW_LINE i += 1 NEW_LINE DEDENT return ( i - 2 ) NEW_LINE DEDENT
def equilibrium ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE leftsum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT sum -= arr [ i ] NEW_LINE if ( leftsum == sum ) : NEW_LINE INDENT return i NEW_LINE DEDENT leftsum += arr [ i ] NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def procal ( n ) : NEW_LINE INDENT return ( 3.0 * n ) / ( 4.0 * ( n * n ) - 1 ) NEW_LINE DEDENT
def greatest ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE a = [ 0 ] * n NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT a [ i ] = ord ( s [ i ] ) - ord ( '0' ) NEW_LINE sum += a [ i ] NEW_LINE DEDENT if ( a [ n - 1 ] % 2 ) : NEW_LINE INDENT if ( a [ n - 2 ] % 2 != 0 or ( sum - a [ n - 1 ] ) % 3 != 0 ) : NEW_LINE INDENT print ( " - 1" , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n , end = " " ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT re = sum % 3 NEW_LINE del = - 1 NEW_LINE flag = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( a [ i ] ) % 3 == re ) : NEW_LINE INDENT if ( a [ i + 1 ] > a [ i ] ) : NEW_LINE INDENT del = i NEW_LINE flag = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag == 0 ) : NEW_LINE INDENT if ( a [ n - 2 ] % 2 == 0 and re == a [ n - 1 ] % 3 ) : NEW_LINE INDENT del = n - 1 NEW_LINE DEDENT DEDENT if ( del == - 1 ) : NEW_LINE INDENT print ( - 1 , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( del + 1 , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def isChangeable ( notes , n ) : NEW_LINE INDENT fiveCount = 0 NEW_LINE tenCount = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( notes [ i ] == 5 ) : NEW_LINE INDENT fiveCount += 1 NEW_LINE DEDENT elif ( notes [ i ] == 10 ) : NEW_LINE INDENT if ( fiveCount > 0 ) : NEW_LINE INDENT fiveCount -= 1 NEW_LINE tenCount += 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( fiveCount > 0 and tenCount > 0 ) : NEW_LINE INDENT fiveCount -= 1 NEW_LINE tenCount -= 1 NEW_LINE DEDENT elif ( fiveCount >= 3 ) : NEW_LINE INDENT fiveCount -= 3 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT DEDENT return 1 NEW_LINE DEDENT
def maxSumWO3Consec ( n ) : NEW_LINE INDENT if sum [ n ] != - 1 : NEW_LINE INDENT return sum [ n ] NEW_LINE DEDENT if n == 0 : NEW_LINE INDENT return sum [ n ] = 0 NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT return sum [ n ] = arr [ 0 ] NEW_LINE if n == 2 : NEW_LINE INDENT return sum [ n ] = arr [ 1 ] + arr [ 0 ] NEW_LINE DEDENT return sum [ n ] = max ( max ( maxSumWO3Consec ( n - 1 ) , maxSumWO3Consec ( n - 2 ) + arr [ n - 1 ] ) , arr [ n - 2 ] + arr [ n - 1 ] + maxSumWO3Consec ( n - 3 ) ) NEW_LINE DEDENT
def findMinZero ( p ) : NEW_LINE INDENT first = 1 NEW_LINE second = 1 NEW_LINE number = 2 NEW_LINE while ( next ) : NEW_LINE INDENT next = ( first + second ) % p NEW_LINE first = second NEW_LINE second = next NEW_LINE number += 1 NEW_LINE DEDENT return number NEW_LINE DEDENT
def reorder ( arr , index , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT while ( index [ i ] != i ) : NEW_LINE INDENT oldTargetI = index [ index [ i ] ] NEW_LINE oldTargetE = arr [ index [ i ] ] NEW_LINE arr [ index [ i ] ] = arr [ i ] NEW_LINE index [ i ] = oldTargetI NEW_LINE arr [ i ] = oldTargetE NEW_LINE DEDENT DEDENT
def calculateSum ( n ) : NEW_LINE INDENT if ( n <= 0 ) : return 0 NEW_LINE fibo = [ 0 for i in range ( n + 1 ) ] NEW_LINE fibo [ 0 ] = 0 NEW_LINE fibo [ 1 ] = 1 NEW_LINE sum = fibo [ 0 ] + fibo [ 1 ] NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] NEW_LINE sum += fibo [ i ] NEW_LINE DEDENT return sum NEW_LINE DEDENT
def shortestPath ( graph , u , v , k ) : NEW_LINE INDENT if ( k == 0 and u == v ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( k == 1 and graph [ u ] [ v ] != INF ) : NEW_LINE INDENT return graph [ u ] [ v ] NEW_LINE DEDENT if ( k <= 0 ) : NEW_LINE INDENT return INF NEW_LINE DEDENT res = INF NEW_LINE for i in range ( V ) : NEW_LINE INDENT if ( graph [ u ] [ i ] != INF and u != i and v != i ) : NEW_LINE INDENT rec_res = shortestPath ( graph , i , v , k - 1 ) NEW_LINE if ( rec_res != INF ) : NEW_LINE INDENT res = min ( res , graph [ u ] [ i ] + rec_res ) NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT
def sumofsquare ( n ) : NEW_LINE INDENT C = [ [ 0 for j in range ( n + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( min ( i , n + 1 ) ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT sum = 0 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT sum += ( C [ n ] [ i ] * C [ n ] [ i ] ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
def constructArr ( arr , pair , n ) : NEW_LINE INDENT arr [ 0 ] = ( pair [ 0 ] + pair [ 1 ] - pair [ n - 1 ] ) // 2 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT arr [ i ] = ( pair [ i - 1 ] - arr [ 0 ] ) / 2 NEW_LINE DEDENT DEDENT
def findFrequency ( arr , n , left , right , element ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( left - 1 , right + 1 ) : NEW_LINE INDENT if ( arr [ i ] == element ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def parabola ( a , b , c ) : NEW_LINE INDENT print ( " Vertex : ▁ ( " , ( - b / ( 2 * a ) ) , " , ▁ " , ( ( 4 * a * c ) - ( b * b ) ) / ( 4 * a ) ) , " ) " ) NEW_LINE print ( " Focus : ▁ ( " , ( - b / ( 2 * a ) ) , " , ▁ " , ( ( ( 4 * a * c ) - ( b * b ) + 1 ) / ( 4 * a ) ) , " ) " , end = " " ) NEW_LINE print ( " Directrix : ▁ y = " , c - ( ( b * b ) + 1 ) * 4 * a ) NEW_LINE print ( " Directrix : ▁ y = " , c - ( ( b * b ) + 1 ) * 4 * a ) NEW_LINE DEDENT DEDENT
def minproduct ( a , b , n , k ) : NEW_LINE INDENT diff = 0 NEW_LINE res = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT pro = a [ i ] * b [ i ] NEW_LINE res = res + pro NEW_LINE if ( pro < 0 and b [ i ] < 0 ) : NEW_LINE INDENT temp = ( a [ i ] + 2 * k ) * b [ i ] NEW_LINE DEDENT elif ( pro < 0 and a [ i ] < 0 ) : NEW_LINE INDENT temp = ( a [ i ] - 2 * k ) * b [ i ] NEW_LINE DEDENT elif ( pro > 0 and a [ i ] > 0 ) : NEW_LINE INDENT temp = ( a [ i ] + 2 * k ) * b [ i ] NEW_LINE DEDENT elif ( pro > 0 and a [ i ] < 0 ) : NEW_LINE INDENT temp = ( a [ i ] - 2 * k ) * b [ i ] NEW_LINE DEDENT elif ( pro > 0 and a [ i ] > 0 ) : NEW_LINE INDENT temp = ( a [ i ] - 2 * k ) * b [ i ] NEW_LINE DEDENT d = abs ( pro - temp ) NEW_LINE diff = d NEW_LINE DEDENT return res - diff NEW_LINE DEDENT
def pairsInSortedRotated ( arr , n , x ) : NEW_LINE INDENT for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if arr [ i ] > arr [ i + 1 ] : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT l = i NEW_LINE r = i NEW_LINE cnt = 0 NEW_LINE while ( l != r ) : NEW_LINE INDENT if ( arr [ l ] + arr [ r ] == x ) : NEW_LINE INDENT cnt += 1 NEW_LINE if ( l == ( r - 1 + n ) % n ) : NEW_LINE INDENT return cnt NEW_LINE DEDENT l = ( l + 1 ) % n NEW_LINE r = ( r - 1 + n ) % n NEW_LINE DEDENT elif ( arr [ l ] + arr [ r ] < x ) : NEW_LINE INDENT l = ( l + 1 ) % n NEW_LINE DEDENT else : NEW_LINE INDENT r = ( n + r - 1 ) % n NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT
def middleOfThree ( a , b , c ) : NEW_LINE INDENT x = a - b NEW_LINE y = b - c NEW_LINE z = a - c NEW_LINE if ( x * y > 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT elif ( x * z > 0 ) : NEW_LINE INDENT return c NEW_LINE DEDENT else : NEW_LINE INDENT return a NEW_LINE DEDENT DEDENT
def maxSubArraySumRepeated ( a , n , k ) : NEW_LINE INDENT max_so_far = - 2147483647 NEW_LINE max_ending_here = 0 NEW_LINE for i in range ( n * k ) : NEW_LINE INDENT max_ending_here = max_ending_here + a [ i % n ] NEW_LINE if ( max_so_far < max_ending_here ) : NEW_LINE INDENT max_so_far = max_ending_here NEW_LINE DEDENT if ( max_ending_here < 0 ) : NEW_LINE INDENT max_ending_here = 0 NEW_LINE DEDENT DEDENT return max_so_far NEW_LINE DEDENT
def binomialCoeffSum ( n ) : NEW_LINE INDENT C = [ [ 0 for j in range ( n + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( min ( i , n + 1 ) ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT sum = 0 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT sum += C [ n ] [ i ] NEW_LINE DEDENT return sum NEW_LINE DEDENT
def isEven ( n ) : NEW_LINE INDENT return ( n % 2 == 0 ) NEW_LINE DEDENT
def binarySearch ( arr , low , high , key ) : NEW_LINE INDENT if ( high < low ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = low + ( high - low ) / 2 NEW_LINE if ( key == arr [ mid ] ) : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( key > arr [ mid ] ) : NEW_LINE INDENT return binarySearch ( arr , ( mid + 1 ) , high , key ) NEW_LINE DEDENT return binarySearch ( arr , low , ( mid - 1 ) , key ) NEW_LINE DEDENT
def maxMin ( arr , n ) : NEW_LINE INDENT min = 10000000000 NEW_LINE max = 10000000000 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , int ( n / 2 ) ) : NEW_LINE INDENT if ( arr [ i ] [ j ] > arr [ i ] [ n - j - 1 ] ) : NEW_LINE INDENT if ( min > arr [ i ] [ n - j - 1 ] ) : NEW_LINE INDENT min = arr [ i ] [ n - j - 1 ] NEW_LINE DEDENT if ( max < arr [ i ] [ j ] ) : NEW_LINE INDENT max = arr [ i ] [ j ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( min > arr [ i ] [ j ] ) : NEW_LINE INDENT min = arr [ i ] [ j ] NEW_LINE DEDENT if ( max < arr [ i ] [ n - j - 1 ] ) : NEW_LINE INDENT max = arr [ i ] [ n - j - 1 ] NEW_LINE DEDENT DEDENT DEDENT print ( " Maximum ▁ = " , max ) NEW_LINE print ( " , ▁ Minimum ▁ = " , min ) NEW_LINE DEDENT
def countPaths ( n , m ) : NEW_LINE INDENT if ( n == 0 or m == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return ( countPaths ( n - 1 , m ) + countPaths ( n , m - 1 ) ) NEW_LINE DEDENT
def countFriendsPairings ( n ) : NEW_LINE INDENT if dp [ n ] != - 1 : NEW_LINE INDENT return dp [ n ] NEW_LINE DEDENT if n > 2 : NEW_LINE INDENT return dp [ n ] = ( countFriendsPairings ( n - 1 ) + ( n - 1 ) * countFriendsPairings ( n - 2 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return dp [ n ] = n NEW_LINE DEDENT DEDENT
def countRect ( n ) : NEW_LINE INDENT ans = 0 NEW_LINE for length in range ( 1 , int ( m . sqrt ( n ) + 1 ) ) : NEW_LINE INDENT for height in range ( length , int ( m . sqrt ( n ) + 1 ) ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def factorial ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT res = res * i NEW_LINE DEDENT return res NEW_LINE DEDENT
def correlationCoefficient ( X , Y , n ) : NEW_LINE INDENT sum_X = 0 NEW_LINE sum_Y = 0 NEW_LINE sum_XY = 0 NEW_LINE squareSum_X = 0 NEW_LINE squareSum_Y = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum_X = sum_X + X [ i ] NEW_LINE sum_Y = sum_Y + Y [ i ] NEW_LINE sum_XY = sum_XY + X [ i ] * Y [ i ] NEW_LINE squareSum_X = squareSum_X + X [ i ] * X [ i ] NEW_LINE squareSum_Y = squareSum_Y + Y [ i ] * Y [ i ] NEW_LINE DEDENT corr = ( float ) ( n * sum_XY - sum_X * sum_Y ) / sqrt ( ( n * squareSum_X - sum_X * sum_X ) * ( n * squareSum_Y - sum_Y * sum_Y ) ) NEW_LINE return float ( corr ) NEW_LINE DEDENT
def floorSqrt ( x ) : NEW_LINE INDENT if ( x == 0 or x == 1 ) : NEW_LINE INDENT return x NEW_LINE DEDENT i = 1 NEW_LINE result = 1 NEW_LINE while ( result <= x ) : NEW_LINE INDENT i += 1 NEW_LINE result = i * i NEW_LINE DEDENT return i - 1 NEW_LINE DEDENT
def printMat ( degseq , n ) : NEW_LINE INDENT mat = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( degseq [ i ] > 0 and degseq [ j ] > 0 ) : NEW_LINE INDENT degseq [ i ] -= 1 NEW_LINE degseq [ j ] -= 1 NEW_LINE mat [ i ] [ j ] = 1 NEW_LINE mat [ j ] [ i ] = 1 NEW_LINE DEDENT DEDENT DEDENT print ( " \n " , setw ( 3 ) , " ▁ " ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( setw ( 4 ) , " ( " , i , " ) " ) NEW_LINE for j in range ( n ) : NEW_LINE INDENT print ( setw ( 5 ) , mat [ i ] [ j ] ) NEW_LINE DEDENT print ( " \n " ) NEW_LINE DEDENT DEDENT
def minTime ( arr , n , m ) : NEW_LINE INDENT t = 0 NEW_LINE while 1 : NEW_LINE INDENT items = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT items += ( t // arr [ i ] ) NEW_LINE DEDENT if ( items >= m ) : NEW_LINE INDENT return t NEW_LINE DEDENT t += 1 NEW_LINE DEDENT DEDENT
def maxSumBitonicSubArr ( arr , n ) : NEW_LINE INDENT msis = [ 0 ] * n NEW_LINE msds = [ 0 ] * n NEW_LINE max_sum = - float ( ' inf ' ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i - 1 ] ) : NEW_LINE INDENT msis [ i ] = msis [ i - 1 ] + arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT msis [ i ] = arr [ i ] NEW_LINE DEDENT DEDENT msds [ n - 1 ] = arr [ n - 1 ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( max_sum < ( msis [ i ] + msds [ i ] - arr [ i ] ) ) : NEW_LINE INDENT max_sum = msis [ i ] + msds [ i ] - arr [ i ] NEW_LINE DEDENT DEDENT return max_sum NEW_LINE DEDENT
def findMinNumber ( n ) : NEW_LINE INDENT count = 0 NEW_LINE ans = 1 NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE n /= 2 NEW_LINE DEDENT if ( count % 2 ) : NEW_LINE INDENT ans = ans * 2 NEW_LINE DEDENT for i in range ( 3 , int ( m . sqrt ( n ) + 2 ) ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n % i == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE n /= i NEW_LINE DEDENT if ( count % 2 ) : NEW_LINE INDENT ans = ans * i NEW_LINE DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT ans = ans * n NEW_LINE DEDENT return ans NEW_LINE DEDENT
def rangeGCD ( n , m ) : NEW_LINE INDENT return ( n == m ) ? n : 1 NEW_LINE DEDENT
def assignValue ( a , b , x ) : NEW_LINE INDENT arr = [ a , b ] NEW_LINE return ( arr [ x ] ) NEW_LINE DEDENT
def isTriangular ( num ) : NEW_LINE INDENT if ( num < 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT sum = 0 NEW_LINE for n in range ( 1 , num + 1 ) : NEW_LINE INDENT sum = sum + n NEW_LINE if ( sum == num ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def interpolationSearch ( arr , n , x ) : NEW_LINE INDENT lo = 0 NEW_LINE hi = ( n - 1 ) NEW_LINE while ( lo <= hi and x >= arr [ lo ] and x <= arr [ hi ] ) : NEW_LINE INDENT if ( lo == hi ) : NEW_LINE INDENT if ( arr [ lo ] == x ) : NEW_LINE INDENT return lo NEW_LINE DEDENT return - 1 NEW_LINE DEDENT pos = lo + ( ( ( double ) ( hi - lo ) / ( arr [ hi ] - arr [ lo ] ) ) * ( x - arr [ lo ] ) ) NEW_LINE if ( arr [ pos ] == x ) : NEW_LINE INDENT return pos NEW_LINE DEDENT if ( arr [ pos ] < x ) : NEW_LINE INDENT lo = pos + 1 NEW_LINE DEDENT else : NEW_LINE INDENT hi = pos - 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def minSpacePreferLarge ( wall , m , n ) : NEW_LINE INDENT num_m = 0 NEW_LINE num_n = 0 NEW_LINE min_empty = wall NEW_LINE p = 0 NEW_LINE q = 0 NEW_LINE rem = wall % m NEW_LINE if ( rem <= min_empty ) : NEW_LINE INDENT num_m = p NEW_LINE num_n = q NEW_LINE min_empty = rem NEW_LINE DEDENT q += 1 NEW_LINE wall = wall - n NEW_LINE DEDENT print ( num_m , num_n , " ▁ " , min_empty ) NEW_LINE DEDENT
def knapSack ( W , wt , val , n ) : NEW_LINE INDENT K = [ [ 0 for i in range ( W + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for w in range ( W + 1 ) : NEW_LINE INDENT if ( i == 0 or w == 0 ) : NEW_LINE INDENT K [ i ] [ w ] = 0 NEW_LINE DEDENT elif ( wt [ i - 1 ] <= w ) : NEW_LINE INDENT K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) NEW_LINE DEDENT else : NEW_LINE INDENT K [ i ] [ w ] = K [ i - 1 ] [ w ] NEW_LINE DEDENT DEDENT DEDENT return K [ n ] [ W ] NEW_LINE DEDENT
def factorial ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return n * factorial ( n - 1 ) NEW_LINE DEDENT
def findgroups ( arr , n ) : NEW_LINE INDENT c = [ 0 for i in range ( n ) ] NEW_LINE res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT c [ arr [ i ] % 3 ] = 1 NEW_LINE DEDENT res += ( ( c [ 0 ] * ( c [ 0 ] - 1 ) ) >> 1 ) NEW_LINE res += ( c [ 1 ] * c [ 2 ] ) NEW_LINE res += ( ( c [ 0 ] * ( c [ 0 ] - 1 ) * ( c [ 0 ] - 2 ) ) / 6 NEW_LINE res += ( ( c [ 1 ] * ( c [ 1 ] - 1 ) * ( c [ 1 ] - 2 ) ) / 6 ) NEW_LINE res += ( ( c [ 2 ] * ( c [ 2 ] - 1 ) * ( c [ 2 ] - 2 ) ) / 6 ) NEW_LINE res += c [ 0 ] * c [ 1 ] * c [ 2 ] NEW_LINE return res NEW_LINE DEDENT
def findMaxValue ( mat ) : NEW_LINE INDENT maxValue = - float ( ' inf ' ) NEW_LINE maxArr = [ [ 0 for i in range ( N ) ] for j in range ( N - 1 ) ] NEW_LINE maxv = mat [ N - 1 ] [ N - 1 ] NEW_LINE for j in range ( N - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( mat [ N - 1 ] [ j ] > maxv ) : NEW_LINE INDENT maxv = mat [ N - 1 ] [ j ] NEW_LINE DEDENT maxArr [ N - 1 ] [ j ] = maxv NEW_LINE DEDENT maxv = mat [ N - 1 ] [ N - 1 ] NEW_LINE for i in range ( N - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( mat [ i ] [ N - 1 ] > maxv ) : NEW_LINE INDENT maxv = mat [ i ] [ N - 1 ] NEW_LINE DEDENT maxArr [ i ] [ N - 1 ] = maxv NEW_LINE DEDENT for i in range ( N - 2 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( N - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( maxArr [ i + 1 ] [ j + 1 ] - mat [ i ] [ j ] > maxValue ) : NEW_LINE INDENT maxValue = maxArr [ i + 1 ] [ j + 1 ] - mat [ i ] [ j ] NEW_LINE DEDENT maxArr [ i ] [ j ] = max ( mat [ i ] [ j ] , max ( maxArr [ i ] [ j + 1 ] , maxArr [ i + 1 ] [ j ] ) ) NEW_LINE DEDENT DEDENT DEDENT return maxValue NEW_LINE DEDENT
def kPrimeFactor ( n , k ) : NEW_LINE INDENT while ( n % 2 == 0 ) : NEW_LINE INDENT k -= 1 NEW_LINE n = n / 2 NEW_LINE if ( k == 0 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT for i in range ( 3 , int ( m . sqrt ( n ) + 2 ) ) : NEW_LINE INDENT while ( n % i == 0 ) : NEW_LINE INDENT if ( k == 1 ) : NEW_LINE INDENT return i NEW_LINE k -= 1 NEW_LINE n = n / i NEW_LINE DEDENT DEDENT if ( n > 2 and k == 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def SieveOfEratosthenes ( n , isPrime ) : NEW_LINE INDENT isPrime [ 0 ] = isPrime [ 1 ] = False NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT isPrime [ i ] = True NEW_LINE DEDENT for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if isPrime [ p ] == True : NEW_LINE INDENT for i in range ( p * 2 , n + p ) : NEW_LINE INDENT isPrime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT
def findFirstMissing ( array , start , end ) : NEW_LINE INDENT if ( start > end ) : NEW_LINE INDENT return end + 1 NEW_LINE DEDENT if ( start != array [ start ] ) : NEW_LINE INDENT return start NEW_LINE DEDENT mid = ( start + end ) // 2 NEW_LINE if ( array [ mid ] == mid ) : NEW_LINE INDENT return findFirstMissing ( array , mid + 1 , end ) NEW_LINE DEDENT return findFirstMissing ( array , start , mid ) NEW_LINE DEDENT
def factorial ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return n * factorial ( n - 1 ) NEW_LINE DEDENT
def insertSorted ( arr , n , key , capacity ) : NEW_LINE INDENT if ( n >= capacity ) : return n NEW_LINE DEDENT i = n - 1 NEW_LINE while ( i >= 0 and arr [ i ] > key ) : NEW_LINE INDENT arr [ i + 1 ] = arr [ i ] NEW_LINE i -= 1 NEW_LINE DEDENT arr [ i + 1 ] = key NEW_LINE return ( n + 1 ) NEW_LINE DEDENT
def add ( A , B , C ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT C [ i ] [ j ] = A [ i ] [ j ] + B [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT
def eggDrop ( n , k ) : NEW_LINE INDENT eggFloor = [ [ 0 for i in range ( k + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT eggFloor [ i ] [ 1 ] = 1 NEW_LINE eggFloor [ i ] [ 0 ] = 0 NEW_LINE DEDENT for j in range ( 1 , k + 1 ) : NEW_LINE INDENT eggFloor [ 1 ] [ j ] = j NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT for j in range ( 2 , k + 1 ) : NEW_LINE INDENT eggFloor [ i ] [ j ] = sys . maxint NEW_LINE for x in range ( 1 , j + 1 ) : NEW_LINE INDENT res = 1 + max ( eggFloor [ i - 1 ] [ x - 1 ] , eggFloor [ i ] [ j - x ] ) NEW_LINE if res < eggFloor [ i ] [ j ] ) : NEW_LINE INDENT eggFloor [ i ] [ j ] = res NEW_LINE DEDENT DEDENT DEDENT DEDENT return eggFloor [ n ] [ k ] NEW_LINE DEDENT
def minInsertionStepToSortArray ( arr , N ) : NEW_LINE INDENT lis = [ 0 ] * N NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT lis [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , N ) : NEW_LINE INDENT for j in range ( 0 , i ) : NEW_LINE INDENT if ( arr [ i ] >= arr [ j ] and lis [ i ] < lis [ j ] + 1 ) : NEW_LINE INDENT lis [ i ] = lis [ j ] + 1 NEW_LINE DEDENT DEDENT max = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT if ( max < lis [ i ] ) : NEW_LINE INDENT max = lis [ i ] NEW_LINE DEDENT DEDENT return ( N - max ) NEW_LINE DEDENT
def exactPrimeFactorCount ( n ) : NEW_LINE INDENT count = 0 NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT n = n / 2 NEW_LINE DEDENT DEDENT for i in range ( 3 , int ( m . sqrt ( n ) + 2 ) ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE while ( n % i == 0 ) : NEW_LINE INDENT n = n / i NEW_LINE DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def findMinAvgSubarray ( arr , n , k ) : NEW_LINE INDENT if ( n < k ) : NEW_LINE INDENT return NEW_LINE DEDENT res_index = 0 NEW_LINE curr_sum = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT curr_sum += arr [ i ] NEW_LINE DEDENT min_sum = curr_sum NEW_LINE for i in range ( n ) : NEW_LINE INDENT curr_sum += arr [ i ] - arr [ i - k ] NEW_LINE if ( curr_sum < min_sum ) : NEW_LINE INDENT min_sum = curr_sum NEW_LINE res_index = ( i - k + 1 ) NEW_LINE DEDENT DEDENT print ( " Subarray ▁ between ▁ [ " , res_index , " , ▁ " , res_index + k - 1 , " ] ▁ has ▁ minimum ▁ average " ) NEW_LINE DEDENT
def countwalks ( graph , u , v , k ) : NEW_LINE INDENT if ( k == 0 and u == v ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( k == 1 and graph [ u ] [ v ] ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( k <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( V ) : NEW_LINE INDENT if ( graph [ u ] [ i ] == 1 ) : NEW_LINE INDENT count += countwalks ( graph , i , v , k - 1 ) NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def print_sequence ( n , k ) : NEW_LINE INDENT b = n // ( k * ( k + 1 ) / 2 ) NEW_LINE if ( b == 0 ) : NEW_LINE INDENT print ( - 1 , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT r = 1 NEW_LINE for x in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( n % x != 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( x <= b and x > r ) : NEW_LINE INDENT r = x NEW_LINE DEDENT if ( n // x <= b and n // x > r ) : NEW_LINE INDENT r = n / x NEW_LINE DEDENT DEDENT for i in range ( 1 , k ) : NEW_LINE INDENT print ( r * i , end = " ▁ " ) NEW_LINE DEDENT res = n - ( r * ( k * ( k - 1 ) // 2 ) ) NEW_LINE print ( res , end = " " ) NEW_LINE DEDENT DEDENT
def findS ( s ) : NEW_LINE INDENT sum = 0 NEW_LINE for n in range ( 1 , s ) : NEW_LINE INDENT sum += n * n * n NEW_LINE if ( sum == s ) : NEW_LINE INDENT return n NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def printFun ( test ) : NEW_LINE INDENT if test < 1 : NEW_LINE INDENT return NEW_LINE DEDENT else : NEW_LINE INDENT print ( test , end = " ▁ " ) NEW_LINE printFun ( test - 1 ) NEW_LINE print ( test , end = " ▁ " ) NEW_LINE return NEW_LINE DEDENT DEDENT
def shiftMatrixByK ( mat , k ) : NEW_LINE INDENT global N NEW_LINE if k > N : NEW_LINE INDENT print ( " shifting ▁ is ▁ not ▁ possible " ) NEW_LINE return NEW_LINE DEDENT j = 0 NEW_LINE while ( j < N ) : NEW_LINE INDENT for i in range ( k , N ) : NEW_LINE INDENT print ( mat [ j ] [ i ] , end = " ▁ " ) NEW_LINE DEDENT for i in range ( k , N ) : NEW_LINE INDENT print ( mat [ j ] [ i ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE j += 1 NEW_LINE DEDENT DEDENT
def findPair ( arr , n ) : NEW_LINE INDENT found = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT for k in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] + arr [ j ] == arr [ k ] ) : NEW_LINE INDENT print ( arr [ i ] , arr [ j ] ) NEW_LINE found = True NEW_LINE DEDENT DEDENT DEDENT if ( found == False ) : NEW_LINE INDENT print ( " Not ▁ exist " ) NEW_LINE DEDENT DEDENT
def squareRootExists ( n , p ) : NEW_LINE INDENT n = n % p NEW_LINE for x in range ( 2 , p ) : NEW_LINE INDENT if ( ( x * x ) % p == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def count ( n , x ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( x // i <= n and x % i == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def maxSubArraySum ( a , size ) : NEW_LINE INDENT max_so_far = - 2147483647 NEW_LINE max_ending_here = 0 NEW_LINE start = 0 NEW_LINE end = 0 NEW_LINE s = 0 NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT max_ending_here += a [ i ] NEW_LINE if ( max_so_far < max_ending_here ) : NEW_LINE INDENT max_so_far = max_ending_here NEW_LINE start = s NEW_LINE end = i NEW_LINE DEDENT if ( max_ending_here < 0 ) : NEW_LINE INDENT max_ending_here = 0 NEW_LINE s = i + 1 NEW_LINE DEDENT DEDENT return ( end - start + 1 ) NEW_LINE DEDENT
def countInRange ( arr , n , x , y ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] >= x and arr [ i ] <= y ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def countPairsWithDiffK ( arr , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE arr . sort ( ) NEW_LINE l = 0 NEW_LINE r = 0 NEW_LINE while ( r < n ) : NEW_LINE INDENT if ( arr [ r ] - arr [ l ] == k ) : NEW_LINE INDENT count += 1 NEW_LINE l += 1 NEW_LINE r += 1 NEW_LINE DEDENT elif ( arr [ r ] - arr [ l ] > k ) : NEW_LINE INDENT l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT r += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def knapSack ( W , wt , val , n ) : NEW_LINE INDENT if ( n == 0 or W == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( wt [ n - 1 ] > W ) : NEW_LINE INDENT return knapSack ( W , wt , val , n - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 ] , wt , val , n - 1 ) , knapSack ( W , wt , val , n - 1 ) ) NEW_LINE DEDENT DEDENT
def countNonEmptySubstr ( string ) : NEW_LINE INDENT n = len ( string ) NEW_LINE return ( n * ( n + 1 ) / 2 ) NEW_LINE DEDENT
def countDigits ( a , b ) : NEW_LINE INDENT count = 0 NEW_LINE p = abs ( a * b ) NEW_LINE if ( p == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT while ( p > 0 ) : NEW_LINE INDENT count += 1 NEW_LINE p = p // 10 NEW_LINE DEDENT return count NEW_LINE DEDENT
def maxProfit ( prices , n ) : NEW_LINE INDENT profit = [ 0 ] * n NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT profit [ i ] = 0 NEW_LINE DEDENT max_price = prices [ n - 1 ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if prices [ i ] > max_price : NEW_LINE INDENT max_price = price [ i ] NEW_LINE DEDENT profit [ i ] = max ( profit [ i + 1 ] , max_price - price [ i ] ) NEW_LINE DEDENT min_price = prices [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if prices [ i ] < min_price : NEW_LINE INDENT min_price = price [ i ] NEW_LINE DEDENT profit [ i ] = max ( profit [ i - 1 ] , profit [ i ] + ( price [ i ] - min_price ) ) NEW_LINE DEDENT DEDENT result = profit [ n - 1 ] NEW_LINE delete [ ] profit NEW_LINE return result NEW_LINE DEDENT
def countDer ( n ) : NEW_LINE INDENT der = [ 0 ] * ( n + 1 ) NEW_LINE der [ 0 ] = 1 NEW_LINE der [ 1 ] = 0 NEW_LINE der [ 2 ] = 1 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT der [ i ] = ( i - 1 ) * ( der [ i - 1 ] + der [ i - 2 ] ) NEW_LINE DEDENT return der [ n ] NEW_LINE DEDENT
def find_Area ( r ) : NEW_LINE INDENT return ( 2 * r * r ) NEW_LINE DEDENT
def isLucky ( n ) : NEW_LINE INDENT arr = [ False for i in range ( 10 ) ] NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT arr [ i ] = False NEW_LINE DEDENT while ( n > 0 ) : NEW_LINE INDENT digit = n % 10 NEW_LINE if ( arr [ digit ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT arr [ digit ] = True NEW_LINE n = n // 10 NEW_LINE DEDENT return True NEW_LINE DEDENT
def countWaysToJump ( arr , n ) : NEW_LINE INDENT count_jump = [ 0 ] * n NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] >= n - i - 1 ) : NEW_LINE INDENT count_jump [ i ] += 1 NEW_LINE DEDENT for j in range ( i + 1 , n - 1 , - 1 ) : NEW_LINE INDENT if ( count_jump [ j ] != - 1 ) : NEW_LINE INDENT count_jump [ i ] += count_jump [ j ] NEW_LINE DEDENT DEDENT if ( count_jump [ i ] == 0 ) : NEW_LINE INDENT count_jump [ i ] = - 1 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( count_jump [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def zodiac_sign ( day , month ) : NEW_LINE INDENT astro_sign = " " NEW_LINE if ( month == " december " ) : NEW_LINE INDENT if ( day < 22 ) : NEW_LINE INDENT astro_sign = " Sagittarius " NEW_LINE DEDENT else : NEW_LINE INDENT astro_sign = " capricorn " NEW_LINE DEDENT elif ( month == " january " ) : NEW_LINE INDENT if ( day < 20 ) : NEW_LINE INDENT astro_sign = " Capricorn " NEW_LINE DEDENT else : NEW_LINE INDENT astro_sign = " aquarius " NEW_LINE DEDENT elif ( month == " march " ) : NEW_LINE INDENT if ( day < 21 ) : NEW_LINE INDENT astro_sign = " Aquarius " NEW_LINE DEDENT else : NEW_LINE INDENT astro_LINE INDENT astro_LINE INDENT astro_LINE INDENT astro_LINE INDENT astro_sign = " Pisces " NEW_LINE DEDENT elif ( month == " may " ) : NEW_LINE INDENT if ( day < 21 ) : NEW_LINE INDENT astro_sign = " Taurus " NEW_LINE DEDENT else : NEW_LINE INDENT astro_sign = " gemini " NEW_LINE DEDENT elif ( month == " june " ) : NEW_LINE INDENT if ( day < 23 ) : NEW_LINE INDENT astro_sign = " Cancer " NEW_LINE DEDENT else : NEW_LINE INDENT astro_sign = " Leo " NEW_LINE DEDENT elif ( month == " september " ) : NEW_LINE INDENT if ( day < 23 ) : NEW_LINE INDENT astro_sign = " Virgo " NEW_LINE DEDENT else : NEW_LINE INDENT astro_sign = " Libra " NEW_LINE DEDENT else : NEW_LINE INDENT astro_LINE INDENT astro_LINE INDENT astro_LINE INDENT astro_LINE INDENT astro_LINE INDENT astro_LINE INDENT print ( ) NEW_LINE DEDENT elif ( month == " october " ) : NEW_LINE INDENT if ( day < 23 ) : NEW_LINE INDENT astro_sign = " Virgo " NEW_LINE DEDENT else : NEW_LINE INDENT astro_
def isSymmetric ( mat , N ) : NEW_LINE INDENT for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( 0 , N ) : NEW_LINE INDENT if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT
def isRectangle ( mat ) : NEW_LINE INDENT rows = len ( mat ) NEW_LINE if ( rows == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT columns = len ( mat [ 0 ] ) NEW_LINE for y1 in range ( rows ) : NEW_LINE INDENT for x1 in range ( columns ) : NEW_LINE INDENT if ( mat [ y1 ] [ x1 ] == 1 ) : NEW_LINE INDENT for y2 in range ( y1 + 1 , rows ) : NEW_LINE INDENT for x2 in range ( x1 + 1 , columns ) : NEW_LINE INDENT if ( mat [ y1 ] [ x2 ] == 1 and mat [ y2 ] [ x1 ] == 1 and mat [ y2 ] [ x2 ] == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT
def isDivBy9 ( n ) : NEW_LINE INDENT if ( n == 0 or n == 9 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n < 9 ) : NEW_LINE INDENT return False NEW_LINE DEDENT return isDivBy9 ( ( int ) ( n >> 3 ) - ( int ) ( n & 7 ) ) NEW_LINE DEDENT
def knapSack ( W , wt , val , n ) : NEW_LINE INDENT if ( n == 0 or W == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( wt [ n - 1 ] > W ) : NEW_LINE INDENT return knapSack ( W , wt , val , n - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 ] , wt , val , n - 1 ) , knapSack ( W , wt , val , n - 1 ) ) NEW_LINE DEDENT DEDENT
def oppositeSigns ( x , y ) : NEW_LINE INDENT return ( ( x ^ y ) < 0 ) NEW_LINE DEDENT
def arraySortedOrNot ( arr , n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i - 1 ] > arr [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def isOverflow ( a , b ) : NEW_LINE INDENT if ( a == 0 or b == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT result = a * b NEW_LINE if ( a == result / b ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT
def countRotations ( n ) : NEW_LINE INDENT length = len ( n ) NEW_LINE if ( len == 1 ) : NEW_LINE INDENT oneDigit = ord ( n [ 0 ] ) - ord ( '0' ) NEW_LINE if ( oneDigit % 4 == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT twoDigit = 0 NEW_LINE count = 0 NEW_LINE for i in range ( len - 1 ) : NEW_LINE INDENT twoDigit = ( ord ( n [ i ] ) - ord ( '0' ) ) * 10 + ( n . at ( i + 1 ) - ord ( '0' ) ) NEW_LINE if ( twoDigit % 4 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT twoDigit = ( ord ( n [ len - 1 ] ) - ord ( '0' ) ) * 10 + ( n . at ( 0 ) - ord ( '0' ) ) NEW_LINE if ( twoDigit % 4 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def findCombinations ( str , index , out ) : NEW_LINE INDENT if index == len ( str ) - 1 : NEW_LINE INDENT print ( out ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( index , len ( str ) - 1 ) : NEW_LINE INDENT findCombinations ( str , i + 1 , out + " ( " + str . substr ( index , i + 1 - index ) + " ) " ) NEW_LINE DEDENT DEDENT
def search ( arr , n , x ) : NEW_LINE INDENT i = 0 NEW_LINE while i <= n - 1 : NEW_LINE INDENT if arr [ i ] == x : NEW_LINE INDENT return i NEW_LINE DEDENT i += abs ( arr [ i ] - x ) NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def maxSum ( stack1 , stack2 , stack3 , n1 , n2 , n3 ) : NEW_LINE INDENT sum1 = 0 NEW_LINE sum2 = 0 NEW_LINE sum3 = 0 NEW_LINE for i in range ( n1 ) : NEW_LINE INDENT sum1 += stack1 [ i ] NEW_LINE DEDENT for i in range ( n2 ) : NEW_LINE INDENT sum2 += stack2 [ i ] NEW_LINE DEDENT for i in range ( n3 ) : NEW_LINE INDENT sum3 += stack3 [ i ] NEW_LINE DEDENT top1 = 0 NEW_LINE top2 = 0 NEW_LINE top3 = 0 NEW_LINE while ( 1 ) : NEW_LINE INDENT if ( top1 == n1 or top2 == n2 or top3 == n3 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( sum1 == sum2 and sum2 == sum3 ) : NEW_LINE INDENT return sum1 NEW_LINE DEDENT if ( sum1 >= sum2 and sum1 >= sum3 ) : NEW_LINE INDENT sum1 -= stack1 [ top1 ] NEW_LINE DEDENT elif ( sum2 >= sum3 and sum2 >= sum3 ) : NEW_LINE INDENT sum2 -= stack2 [ top2 ] NEW_LINE DEDENT elif ( sum3 >= sum2 and sum3 >= sum1 ) : NEW_LINE INDENT sum3 -= stack3 [ top3 ] NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT
def firstFactorialDivisibleNumber ( x ) : NEW_LINE INDENT i = 1 NEW_LINE fact = 1 NEW_LINE for i in range ( 1 , x ) : NEW_LINE INDENT fact = fact * i NEW_LINE if ( fact % x == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return i NEW_LINE DEDENT
def sortit ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT arr [ i ] = i + 1 NEW_LINE DEDENT DEDENT
def printMaxSum ( arr , n ) : NEW_LINE INDENT dp = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT dp [ i ] = arr [ i ] NEW_LINE maxi = 0 NEW_LINE for j in range ( 1 , int ( m . sqrt ( i + 1 ) + 1 ) ) : NEW_LINE INDENT if ( ( ( i + 1 ) % j == 0 ) and ( i + 1 ) != j ) : NEW_LINE INDENT if ( dp [ j - 1 ] > maxi ) : NEW_LINE INDENT maxi = dp [ j - 1 ] NEW_LINE DEDENT if ( dp [ ( i + 1 ) / j - 1 ] > maxi and j != 1 ) : NEW_LINE INDENT maxi = dp [ ( i + 1 ) / j - 1 ] NEW_LINE DEDENT DEDENT DEDENT dp [ i ] += maxi NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( dp [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def exponential ( n , x ) : NEW_LINE INDENT sum = 1.0f NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT sum = sum + x * sum / i NEW_LINE DEDENT return float ( sum ) NEW_LINE DEDENT
def maxProd ( n ) : NEW_LINE INDENT if ( n == 2 or n == 3 ) : NEW_LINE INDENT return ( n - 1 ) NEW_LINE DEDENT res = 1 NEW_LINE while ( n > 4 ) : NEW_LINE INDENT n -= 3 NEW_LINE res = res * 3 NEW_LINE DEDENT return ( n * res ) NEW_LINE DEDENT
def countRotations ( arr , low , high ) : NEW_LINE INDENT if ( high < low ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( high == low ) : NEW_LINE INDENT return low NEW_LINE DEDENT mid = low + ( high - low ) // 2 NEW_LINE if ( mid < high and arr [ mid + 1 ] < arr [ mid ] ) : NEW_LINE INDENT return ( mid + 1 ) NEW_LINE DEDENT if ( mid > low and arr [ mid ] < arr [ mid - 1 ] ) : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( arr [ high ] > arr [ mid ] ) : NEW_LINE INDENT return countRotations ( arr , low , mid - 1 ) NEW_LINE DEDENT return countRotations ( arr , mid + 1 , high ) NEW_LINE DEDENT
def findSum ( n ) : NEW_LINE INDENT ans = 0 NEW_LINE temp = 0 NEW_LINE num = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT temp = i - 1 NEW_LINE num = 1 NEW_LINE while ( temp < n ) : NEW_LINE INDENT if ( temp + i <= n ) : NEW_LINE INDENT ans += ( i * num ) NEW_LINE DEDENT else : NEW_LINE INDENT ans += ( ( n - temp ) * num ) NEW_LINE DEDENT temp += i NEW_LINE num += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def divSum ( n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 2 , int ( m . sqrt ( n ) + 1 ) ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( i == ( n // i ) ) : NEW_LINE INDENT result += i NEW_LINE DEDENT else : NEW_LINE INDENT result += ( i + n / i ) NEW_LINE DEDENT DEDENT DEDENT return ( result + n + 1 ) NEW_LINE DEDENT
def rotateMatrix ( mat ) : NEW_LINE INDENT for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( mat [ i ] [ j ] ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT
def printSpiral ( mat , r , c ) : NEW_LINE INDENT a = 0 NEW_LINE b = 2 NEW_LINE low_row = 0 NEW_LINE low_column = 0 NEW_LINE if ( 0 > a ) : NEW_LINE INDENT a = 0 NEW_LINE b = 2 NEW_LINE low_row = 0 NEW_LINE low_column = 0 NEW_LINE if ( 0 > b ) : NEW_LINE INDENT b = 0 NEW_LINE DEDENT high_row = ( r - 1 ) NEW_LINE high_column = ( ( b + 1 ) >= c ) : NEW_LINE INDENT print ( mat [ low_row ] [ i ] , end = " ▁ " ) NEW_LINE low_row -= 1 NEW_LINE for i in range ( low_column + 1 , high_column < c ) : NEW_LINE INDENT print ( mat [ i ] [ high_column ] , end = " ▁ " ) NEW_LINE high_column += 1 NEW_LINE DEDENT for i in range ( high_column - 2 , low_column >= 0 and high_row < r ) : NEW_LINE INDENT print ( mat [ high_row ] [ i ] , end = " ▁ " ) NEW_LINE high_row += 1 NEW_LINE DEDENT for i in range ( high_row - 2 , low_row and i >= 0 and low_column >= 0 : NEW_LINE INDENT print ( mat [ i ] [ low_column ] , end = " ▁ " ) NEW_LINE low_column -= 1 NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT
def countSeq ( n ) : NEW_LINE INDENT nCr = 1 NEW_LINE res = 1 NEW_LINE for r in range ( 1 , n + 1 ) : NEW_LINE INDENT nCr = ( nCr * ( n + 1 - r ) ) / r NEW_LINE res += nCr * nCr NEW_LINE DEDENT return res NEW_LINE DEDENT
def sumofoddFactors ( n ) : NEW_LINE INDENT res = 1 NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT n = n / 2 NEW_LINE DEDENT for i in range ( 3 , int ( m . sqrt ( n ) + 1 ) ) : NEW_LINE INDENT count = 0 NEW_LINE curr_sum = 1 NEW_LINE curr_term = 1 NEW_LINE while ( n % i == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE n = n / i NEW_LINE curr_term = curr_term * i NEW_LINE curr_sum += curr_term NEW_LINE DEDENT res = res * curr_sum NEW_LINE DEDENT if ( n > 2 ) : NEW_LINE INDENT res = res * ( 1 + n ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def search ( arr , l , h , key ) : NEW_LINE INDENT if ( l > h ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = ( l + h ) // 2 NEW_LINE if ( arr [ mid ] == key ) : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( arr [ l ] <= arr [ mid ] ) : NEW_LINE INDENT if ( key >= arr [ l ] and key <= arr [ mid ] ) : NEW_LINE INDENT return search ( arr , l , mid - 1 , key ) NEW_LINE DEDENT return search ( arr , mid + 1 , h , key ) NEW_LINE DEDENT if ( key >= arr [ mid ] and key <= arr [ h ] ) : NEW_LINE INDENT return search ( arr , mid + 1 , h , key ) NEW_LINE DEDENT return search ( arr , l , mid - 1 , key ) NEW_LINE DEDENT
def exponentiation ( base , exp ) : NEW_LINE INDENT if ( exp == 0 ) : return 1 NEW_LINE if ( exp == 1 ) : return base % N NEW_LINE DEDENT t = exponentiation ( base , exp // 2 ) NEW_LINE t = ( t * t ) % N NEW_LINE if ( exp % 2 == 0 ) : NEW_LINE INDENT return t NEW_LINE DEDENT else : NEW_LINE INDENT return ( ( base % N ) * t ) % N NEW_LINE DEDENT DEDENT
def longOddEvenIncSeq ( arr , n ) : NEW_LINE INDENT lioes = [ 0 ] * n NEW_LINE maxLen = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT lioes [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( 0 , i ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and ( arr [ i ] + arr [ j ] ) % 2 != 0 and lioes [ i ] < lioes [ j ] + 1 ) : NEW_LINE INDENT lioes [ i ] = lioes [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( maxLen < lioes [ i ] ) : NEW_LINE INDENT maxLen = lioes [ i ] NEW_LINE DEDENT DEDENT return maxLen NEW_LINE DEDENT
def addOne ( x ) : NEW_LINE INDENT return ( - x ) NEW_LINE DEDENT
def binarySearch ( arr , l , r , x ) : NEW_LINE INDENT if ( r >= l ) : NEW_LINE INDENT mid = l + ( r - l ) // 2 NEW_LINE if ( arr [ mid ] == x ) : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( mid > l and arr [ mid - 1 ] == x ) : NEW_LINE INDENT return ( mid - 1 ) NEW_LINE DEDENT if ( mid < r and arr [ mid + 1 ] == x ) : NEW_LINE INDENT return ( mid + 1 ) NEW_LINE DEDENT if ( arr [ mid ] > x ) : NEW_LINE INDENT return binarySearch ( arr , l , mid - 2 , x ) NEW_LINE DEDENT return binarySearch ( arr , mid + 2 , r , x ) NEW_LINE DEDENT
def bresenham ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT m_new = 2 * ( y2 - y1 ) NEW_LINE slope_error_new = m_new - ( x2 - x1 ) NEW_LINE for x in range ( x1 , y1 + 1 ) : NEW_LINE INDENT print ( " ( " , x , " , " , y ) " ) NEW_LINE slope_error_new += m_new NEW_LINE if slope_error_new >= 0 : NEW_LINE INDENT y += 1 NEW_LINE slope_error_new -= 2 * ( x2 - x1 ) NEW_LINE DEDENT DEDENT DEDENT
def findMinX ( num , rem , k ) : NEW_LINE INDENT x = 1 NEW_LINE while ( True ) : NEW_LINE INDENT j = 0 NEW_LINE while ( j < k ) : NEW_LINE INDENT if ( x % num [ j ] != rem [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if ( j == k ) : NEW_LINE INDENT return x NEW_LINE DEDENT x += 1 NEW_LINE DEDENT return x NEW_LINE DEDENT
def find3Numbers ( A , arr_size , sum ) : NEW_LINE INDENT for i in range ( 0 , arr_size - 2 ) : NEW_LINE INDENT for j in range ( i + 1 , arr_size - 1 ) : NEW_LINE INDENT for k in range ( j + 1 , arr_size ) : NEW_LINE INDENT if ( A [ i ] + A [ j ] + A [ k ] == sum ) : NEW_LINE INDENT print ( " Triplet ▁ is " , A [ i ] , " , ▁ " , A [ j ] , " , ▁ " , A [ k ] ) NEW_LINE return True NEW_LINE DEDENT DEDENT DEDENT DEDENT return False NEW_LINE DEDENT
def numberOfSticks ( x ) : NEW_LINE INDENT return ( 3 * x * ( x + 1 ) ) / 2 NEW_LINE DEDENT
def isDivisibleBy7 ( num ) : NEW_LINE INDENT if ( num < 0 ) : NEW_LINE INDENT return isDivisibleBy7 ( - num ) NEW_LINE DEDENT if ( num == 0 or num == 7 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( num < 10 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return isDivisibleBy7 ( num // 10 - 2 * ( num - num // 10 * 10 ) ) NEW_LINE DEDENT
def findSDSFunc ( n ) : NEW_LINE INDENT DP = [ 0 for i in range ( n + 1 ) ] NEW_LINE DP [ 0 ] = 0 NEW_LINE DP [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT DP [ i ] = DP [ i // 2 ] NEW_LINE DEDENT else : NEW_LINE INDENT DP [ i ] = DP [ ( i - 1 ) // 2 ] + DP [ ( i + 1 ) // 2 ] NEW_LINE DEDENT DEDENT return DP [ n ] NEW_LINE DEDENT
def recSearch ( arr , l , r , x ) : NEW_LINE INDENT if ( r < l ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( arr [ l ] == x ) : NEW_LINE INDENT return l NEW_LINE DEDENT if ( arr [ r ] == x ) : NEW_LINE INDENT return r NEW_LINE DEDENT return recSearch ( arr , l + 1 , r - 1 , x ) ; NEW_LINE DEDENT
def isPossible ( string , n ) : NEW_LINE INDENT len = len ( string ) NEW_LINE if ( len >= n ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def center ( x1 , x2 , y1 , y2 ) : NEW_LINE INDENT print ( ( float ) ( x1 + x2 ) / 2 , " , ▁ " , ( float ) ( y1 + y2 ) / 2 ) NEW_LINE DEDENT
def minInitialPoints ( points ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( C ) ] for j in range ( R ) ] NEW_LINE m = R NEW_LINE n = C NEW_LINE for i in range ( m - 2 ) : NEW_LINE INDENT dp [ i ] [ n - 1 ] = 1 if points [ m - 1 ] [ n - 1 ] > 0 else abs ( points [ m - 1 ] [ n - 1 ] ) + 1 NEW_LINE DEDENT for j in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT dp [ m - 1 ] [ j ] = max ( dp [ m - 1 ] [ j + 1 ] - points [ m - 1 ] [ j ] , 1 ) NEW_LINE DEDENT DEDENT for i in range ( m - 2 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT min_points_on_exit = min ( dp [ i + 1 ] [ j ] , dp [ i ] [ j + 1 ] ) NEW_LINE dp [ i ] [ j ] = max ( min_points_on_exit - points [ i ] [ j ] , 1 ) NEW_LINE DEDENT DEDENT DEDENT return dp [ 0 ] [ 0 ] NEW_LINE DEDENT
def printNGE ( arr , n ) : NEW_LINE INDENT next = - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT next = - 1 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] < arr [ j ] ) : NEW_LINE INDENT next = arr [ j ] NEW_LINE break NEW_LINE DEDENT DEDENT print ( arr [ i ] , end = " ▁ - - ▁ " , next ) NEW_LINE DEDENT DEDENT
