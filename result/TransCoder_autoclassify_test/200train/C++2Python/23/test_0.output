def firstFit ( blockSize , m , processSize , n ) : NEW_LINE INDENT allocation = [ - 1 for i in range ( n ) ] NEW_LINE for j in range ( m ) : NEW_LINE INDENT if ( blockSize [ j ] >= processSize [ i ] ) : NEW_LINE INDENT allocation [ i ] = j NEW_LINE blockSize [ j ] -= processSize [ i ] NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT print ( " Process ▁ No . \tProcess ▁ Size\tBlock ▁ no . " ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( " ▁ " , i + 1 , " \t\t " , processSize [ i ] , " \t\t " ) NEW_LINE if ( allocation [ i ] != - 1 ) : NEW_LINE INDENT print ( allocation [ i ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ Allocated " ) NEW_LINE DEDENT DEDENT
def firstNonRepeating ( arr , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if mp . get ( arr [ i ] ) == 1 : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def distributingBalls ( k , n , str ) : NEW_LINE INDENT a = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( n ) : NEW_LINE INDENT a [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( MAX_CHAR ) : NEW_LINE INDENT if ( a [ i ] > k ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def count_of_ways ( n ) : NEW_LINE INDENT count = ( n + 1 ) * ( n + 2 ) / 2 NEW_LINE return round ( count , 2 ) NEW_LINE DEDENT
def calcAngle ( h , m ) : NEW_LINE INDENT if ( h < 0 or m < 0 or h > 12 or m > 60 ) : NEW_LINE INDENT print ( " Wrong ▁ input " ) NEW_LINE DEDENT if ( h == 12 ) : NEW_LINE INDENT h = 0 NEW_LINE DEDENT if ( m == 60 ) : NEW_LINE INDENT m = 0 NEW_LINE DEDENT hour_angle = 0.5 * ( h * 60 + m ) NEW_LINE minute_angle = 6 * m NEW_LINE angle = abs ( hour_angle - minute_angle ) NEW_LINE angle = min ( 360 - angle , angle ) NEW_LINE return angle NEW_LINE DEDENT
def smallest ( x , y , z ) : NEW_LINE INDENT if ( not ( y // x ) ) : NEW_LINE INDENT return ( not ( y // z ) ) ? y : z NEW_LINE DEDENT return ( not ( x // z ) ) ? x : z NEW_LINE DEDENT
def findExtraCharcter ( strA , strB ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( len ( strA ) ) : NEW_LINE INDENT res ^= strA [ i ] NEW_LINE DEDENT for i in range ( len ( strB ) ) : NEW_LINE INDENT res ^= strB [ i ] NEW_LINE DEDENT return ( ( char ) ( res ) ) NEW_LINE DEDENT
def findMinimumAngle ( arr , n ) : NEW_LINE INDENT l = 0 NEW_LINE sum = 0 NEW_LINE ans = 360 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE while ( sum >= 180 ) : NEW_LINE INDENT ans = min ( ans , 2 * abs ( 180 - sum ) ) NEW_LINE sum -= arr [ l ] NEW_LINE l += 1 NEW_LINE DEDENT ans = min ( ans , 2 * abs ( 180 - sum ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def maxdiff ( arr , n ) : NEW_LINE INDENT freq = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ arr [ i ] ] = 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( freq [ arr [ i ] ] > freq [ arr [ j ] ] and arr [ i ] > arr [ j ] ) : NEW_LINE INDENT ans = max ( ans , freq [ arr [ i ] ] - freq [ arr [ j ] ] ) NEW_LINE DEDENT elif ( freq [ arr [ i ] ] < freq [ arr [ j ] ] and arr [ i ] < arr [ j ] ) : NEW_LINE INDENT ans = max ( ans , freq [ arr [ j ] ] - freq [ arr [ i ] ] ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def areEqual ( arr1 , arr2 , n , m ) : NEW_LINE INDENT if n != m : NEW_LINE INDENT return False NEW_LINE DEDENT arr1 . sort ( ) NEW_LINE arr2 . sort ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if arr1 [ i ] != arr2 [ i ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def PowerOFPINnfactorial ( n , p ) : NEW_LINE INDENT ans = 0 NEW_LINE temp = p NEW_LINE while ( temp <= n ) : NEW_LINE INDENT ans += n / temp NEW_LINE temp = temp * p NEW_LINE DEDENT return ans NEW_LINE DEDENT
def search ( arr , n , x ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] == x ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def isSubSeqDivisible ( str1 ) : NEW_LINE INDENT n = len ( str1 ) NEW_LINE dp = [ [ 0 for i in range ( 10 ) ] for j in range ( 10 ) ] NEW_LINE arr = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT arr [ i ] = str1 [ i - 1 ] - '0' NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT dp [ i ] [ arr [ i ] % 8 ] = 1 NEW_LINE DEDENT for j in range ( 8 ) : NEW_LINE INDENT if ( dp [ i - 1 ] [ j ] > dp [ i ] [ ( j * 10 + arr [ i ] ) % 8 ] ) : NEW_LINE INDENT dp [ i ] [ ( j * 10 + arr [ i ] ) % 8 ] = dp [ i - 1 ] [ j ] NEW_LINE DEDENT if ( dp [ i - 1 ] [ j ] > dp [ i ] [ j ] ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( dp [ i ] [ 0 ] == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def multiplyWith3Point5 ( x ) : NEW_LINE INDENT return ( x << 1 ) + x + ( x >> 1 ) NEW_LINE DEDENT
def countDivisibleSubseq ( str1 , n ) : NEW_LINE INDENT lenn = len ( str1 ) NEW_LINE dp = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] NEW_LINE for i in range ( 1 , lenn ) : NEW_LINE INDENT dp [ i ] [ ( ord ( str1 [ i ] ) - ord ( '0' ) ) % n ] += 1 NEW_LINE DEDENT for i in range ( 1 , lenn ) : NEW_LINE INDENT dp [ i ] [ ( ord ( str1 [ i ] ) - ord ( '0' ) ) % n ] += 1 NEW_LINE DEDENT for j in range ( n ) : NEW_LINE INDENT dp [ i ] [ j ] += dp [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT return dp [ len - 1 ] [ 0 ] NEW_LINE DEDENT
def pairs ( arr , n , k ) : NEW_LINE INDENT smallest = sys . maxsize NEW_LINE count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( abs ( arr [ i ] + arr [ j ] - k ) < smallest ) : NEW_LINE INDENT smallest = abs ( arr [ i ] + arr [ j ] - k ) NEW_LINE count = 1 NEW_LINE DEDENT elif ( abs ( arr [ i ] + arr [ j ] - k ) == smallest ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( " Minimal ▁ Value ▁ = " , smallest ) NEW_LINE print ( " Total ▁ Pairs ▁ = " , count ) NEW_LINE DEDENT
def maxLen ( arr , n ) : NEW_LINE INDENT presum = dict ( ) NEW_LINE Sum = 0 NEW_LINE max_len = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT Sum += arr [ i ] NEW_LINE if ( arr [ i ] == 0 and max_len == 0 ) : NEW_LINE INDENT max_len = 1 NEW_LINE DEDENT if ( Sum == 0 ) : NEW_LINE INDENT max_len = i + 1 NEW_LINE DEDENT if ( Sum in presum ) : NEW_LINE INDENT max_len = max ( max_len , i - presum [ Sum ] ) NEW_LINE DEDENT else : NEW_LINE INDENT presum [ Sum ] = i NEW_LINE DEDENT DEDENT return max_len NEW_LINE DEDENT
def maxLength ( s , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] NEW_LINE for i in range ( n - 1 , 1 ) : NEW_LINE INDENT if ( s [ i ] == ' ( ' and s [ i + 1 ] == ' ) ' ) : NEW_LINE INDENT dp [ i ] [ i + 1 ] = 2 NEW_LINE DEDENT DEDENT for l in range ( 2 , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT j = l NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( s [ i ] == ' ( ' and s [ j ] == ' ) ' ) : NEW_LINE INDENT dp [ i ] [ j ] = 2 + dp [ i + 1 ] [ j - 1 ] NEW_LINE DEDENT DEDENT for i in range ( i , j ) : NEW_LINE INDENT if ( s [ i ] == ' ( ' and s [ j ] == ' ) ' ) : NEW_LINE INDENT dp [ i ] [ j ] = 2 + dp [ i + 1 ] [ j - 1 ] NEW_LINE DEDENT DEDENT for k in range ( i , j ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i ] [ k ] + dp [ k + 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ 0 ] [ n - 1 ] NEW_LINE DEDENT
def summingSeries ( n ) : NEW_LINE INDENT return math . pow ( n , 2 ) NEW_LINE DEDENT
def moduloMultiplication ( a , b , mod ) : NEW_LINE INDENT res = 0 NEW_LINE a %= mod NEW_LINE while ( b ) : NEW_LINE INDENT if ( b & 1 ) : NEW_LINE INDENT res = ( res + a ) % mod NEW_LINE DEDENT a = ( 2 * a ) % mod NEW_LINE b >>= 1 NEW_LINE DEDENT return res NEW_LINE DEDENT
def largestPower ( n , p ) : NEW_LINE INDENT x = 0 NEW_LINE while ( n ) : NEW_LINE INDENT n /= p NEW_LINE x += n NEW_LINE DEDENT return x NEW_LINE DEDENT
def getOddOccurrence ( ar , ar_size ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 0 , ar_size ) : NEW_LINE INDENT res = res ^ ar [ i ] NEW_LINE DEDENT return res NEW_LINE DEDENT
def findArea ( a ) : NEW_LINE INDENT area = ( math . sqrt ( 5 * ( 5 + 2 * ( math . sqrt ( 5 ) ) ) * a * a ) / 4 ) NEW_LINE return math . sqrt ( area ) NEW_LINE DEDENT
def countRotationsDivBy8 ( n ) : NEW_LINE INDENT length = len ( n ) NEW_LINE count = 0 NEW_LINE if ( len == 1 ) : NEW_LINE INDENT oneDigit = ord ( n [ 0 ] ) - ord ( '0' ) NEW_LINE if ( oneDigit % 8 == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT if ( len == 2 ) : NEW_LINE INDENT first = ( n [ 0 ] - '0' ) * 10 + ( n [ 1 ] - '0' ) NEW_LINE second = ( n [ 1 ] - '0' ) * 10 + ( n [ 0 ] - '0' ) NEW_LINE if ( first % 8 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( second % 8 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT DEDENT threeDigit = ( n [ len - 1 ] - '0' ) * 100 + ( n [ 0 ] - '0' ) * 10 + ( n [ 1 ] - '0' ) NEW_LINE if ( threeDigit % 8 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT threeDigit = ( n [ len - 2 ] - '0' ) * 100 + ( n [ len - 1 ] - '0' ) * 10 + ( n [ 0 ] - '0' ) NEW_LINE if ( threeDigit % 8 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def editDistDP ( str1 , str2 , m , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT dp [ i ] [ j ] = j NEW_LINE DEDENT elif j == 0 : NEW_LINE INDENT dp [ i ] [ j ] = i NEW_LINE DEDENT elif ( str1 [ i - 1 ] == str2 [ j - 1 ] ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = 1 + min ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ m ] [ n ] NEW_LINE DEDENT
def isPower ( x , y ) : NEW_LINE INDENT if ( x == 1 ) : NEW_LINE INDENT return ( y == 1 ) NEW_LINE DEDENT pow = 1 NEW_LINE while ( pow < y ) : NEW_LINE INDENT pow *= x NEW_LINE DEDENT return ( pow == y ) NEW_LINE DEDENT
def maxSum ( arr , N , k ) : NEW_LINE INDENT MS = [ 0 ] * N NEW_LINE MS [ N - 1 ] = arr [ N - 1 ] NEW_LINE for i in range ( N - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( i + k + 1 >= N ) : NEW_LINE INDENT MS [ i ] = max ( arr [ i ] , MS [ i + 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT MS [ i ] = max ( arr [ i ] + MS [ i + k + 1 ] , MS [ i + 1 ] ) NEW_LINE DEDENT DEDENT return MS [ 0 ] NEW_LINE DEDENT
def printGrouped ( Str ) : NEW_LINE INDENT n = len ( Str ) NEW_LINE count = [ 0 for i in range ( MAX_CHAR ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT count [ ord ( Str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT while ( count [ ord ( Str [ i ] ) - ord ( ' a ' ) ] -= 1 ) : NEW_LINE INDENT print ( Str [ i ] ) NEW_LINE DEDENT count [ ord ( Str [ i ] ) - ord ( ' a ' ) ] = 0 NEW_LINE DEDENT DEDENT
def countSub ( str1 ) : NEW_LINE INDENT last = vector ( MAX_CHAR , - 1 ) NEW_LINE dp = [ 0 for _ in range ( n + 1 ) ] NEW_LINE n = len ( str1 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT dp [ i ] = 2 * dp [ i - 1 ] NEW_LINE if ( last [ str1 [ i - 1 ] ] != - 1 ) : NEW_LINE INDENT dp [ i ] = dp [ i ] - dp [ last [ str1 [ i - 1 ] ] ] NEW_LINE DEDENT last [ str1 [ i - 1 ] ] = ( i - 1 ) NEW_LINE DEDENT return dp [ n ] NEW_LINE DEDENT
def findLIS ( A , n ) : NEW_LINE INDENT hash = dict ( ) NEW_LINE LIS_size = 1 NEW_LINE LIS_index = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT hash [ A [ i ] ] = hash [ A [ i ] - 1 ] + 1 NEW_LINE if ( LIS_size < hash [ A [ i ] ] ) : NEW_LINE INDENT LIS_size = hash [ A [ i ] ] NEW_LINE LIS_index = A [ i ] NEW_LINE DEDENT DEDENT print ( " LIS _ size ▁ = ▁ " , LIS_size , " \n " ) NEW_LINE print ( " LIS ▁ : ▁ " ) NEW_LINE start = LIS_index - LIS_size + 1 NEW_LINE while ( start <= LIS_index ) : NEW_LINE INDENT print ( start , end = " ▁ " ) NEW_LINE start += 1 NEW_LINE DEDENT DEDENT
def maximumZeros ( arr , n , k ) : NEW_LINE INDENT subset = [ [ 0 for i in range ( k + 1 ) ] for j in range ( MAX5 + 5 ) ] NEW_LINE for p in range ( n ) : NEW_LINE INDENT pw2 = 0 NEW_LINE pw5 = 0 NEW_LINE while ( arr [ p ] % 2 == 0 ) : NEW_LINE INDENT pw2 += 1 NEW_LINE arr [ p ] /= 2 NEW_LINE DEDENT while ( arr [ p ] % 5 == 0 ) : NEW_LINE INDENT pw5 += 1 NEW_LINE arr [ p ] /= 5 NEW_LINE DEDENT for i in range ( k - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( MAX5 ) : NEW_LINE INDENT if ( subset [ i ] [ j ] != - 1 ) : NEW_LINE INDENT subset [ i + 1 ] [ j + pw5 ] = max ( subset [ i + 1 ] [ j + pw5 ] , subset [ i ] [ j ] + pw2 ) NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( MAX5 ) : NEW_LINE INDENT ans = max ( ans , min ( i , subset [ k ] [ i ] ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def maxDiff ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE arr . sort ( ) NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if arr [ i ] != arr [ i + 1 ] : NEW_LINE INDENT result += abs ( arr [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT if arr [ n - 2 ] != arr [ n - 1 ] : NEW_LINE INDENT result += abs ( arr [ n - 1 ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT
def countNums ( n , x , y ) : NEW_LINE INDENT arr = [ False for x in range ( n + 1 ) ] NEW_LINE if x <= n : NEW_LINE INDENT arr [ x ] = True NEW_LINE DEDENT if y <= n : NEW_LINE INDENT arr [ y ] = True NEW_LINE DEDENT result = 0 NEW_LINE for i in range ( min ( x , y ) + 1 ) : NEW_LINE INDENT if arr [ i ] == True : NEW_LINE INDENT arr [ i ] = True NEW_LINE DEDENT if i + x <= n : NEW_LINE INDENT arr [ i + x ] = True NEW_LINE DEDENT if i + y <= n : NEW_LINE INDENT arr [ i + y ] = True NEW_LINE DEDENT result += 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def countPS ( str1 ) : NEW_LINE INDENT N = len ( str1 ) NEW_LINE cps = [ [ 0 for i in range ( N + 1 ) ] for j in range ( N + 1 ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT cps [ i ] [ i ] = 1 NEW_LINE DEDENT for L in range ( 2 , N + 1 ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT k = L + i - 1 NEW_LINE if ( str1 [ i ] == str1 [ k ] ) : NEW_LINE INDENT cps [ i ] [ k ] = cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT cps [ i ] [ k ] = cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] - cps [ i + 1 ] [ k - 1 ] NEW_LINE DEDENT DEDENT DEDENT return cps [ 0 ] [ N - 1 ] NEW_LINE DEDENT
def countSetBits ( n ) : NEW_LINE INDENT if ( n == 0 ) : return 0 NEW_LINE else : NEW_LINE INDENT return ( n & 1 ) + countSetBits ( n >> 1 ) NEW_LINE DEDENT DEDENT
def numofAP ( a , n ) : NEW_LINE INDENT minarr = 2147483647 NEW_LINE maxarr = 2147483647 NEW_LINE for i in range ( n ) : NEW_LINE INDENT minarr = min ( minarr , a [ i ] ) NEW_LINE maxarr = max ( maxarr , a [ i ] ) NEW_LINE DEDENT dp = [ 0 for i in range ( n ) ] NEW_LINE sum = [ 0 for i in range ( minarr - maxarr ) ] NEW_LINE for d in range ( ( minarr - maxarr ) + 1 ) : NEW_LINE INDENT memset ( sum , 0 , sizeof sum ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp [ i ] = 1 NEW_LINE if ( a [ i ] - d >= 1 and a [ i ] - d <= 1000000 ) : NEW_LINE INDENT dp [ i ] += sum [ a [ i ] - d ] NEW_LINE DEDENT ans += dp [ i ] - 1 NEW_LINE DEDENT sum [ a [ i ] ] += dp [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT
def spiralFill ( m , n , a ) : NEW_LINE INDENT val = 1 NEW_LINE k = 0 l = 0 NEW_LINE while ( k < m and l < n ) : NEW_LINE INDENT for i in range ( l , n ) : NEW_LINE INDENT a [ k ] [ i ] = val += 1 NEW_LINE DEDENT k += 1 NEW_LINE DEDENT for i in range ( k , m ) : NEW_LINE INDENT a [ i ] [ n - 1 ] = val += 1 NEW_LINE DEDENT n -= 1 NEW_LINE if ( k < m ) : NEW_LINE INDENT for i in range ( n - 1 , l - 1 , - 1 ) : NEW_LINE INDENT a [ m - 1 ] [ i ] = val += 1 NEW_LINE DEDENT m -= 1 NEW_LINE DEDENT if ( l < n ) : NEW_LINE INDENT for i in range ( m - 1 , k - 1 , - 1 ) : NEW_LINE INDENT a [ i ] [ l ] = val += 1 NEW_LINE DEDENT l += 1 NEW_LINE DEDENT DEDENT DEDENT
def printClosest ( ar1 , ar2 , m , n , x ) : NEW_LINE INDENT diff = sys . maxsize NEW_LINE res_l = res_r = l = 0 NEW_LINE r = n - 1 NEW_LINE while ( l < m and r >= 0 ) : NEW_LINE INDENT if ( abs ( ar1 [ l ] + ar2 [ r ] - x ) < diff ) : NEW_LINE INDENT res_l = l NEW_LINE res_r = r NEW_LINE diff = abs ( ar1 [ l ] + ar2 [ r ] - x ) NEW_LINE DEDENT if ( ar1 [ l ] + ar2 [ r ] > x ) : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT l += 1 NEW_LINE DEDENT DEDENT print ( " The ▁ closest ▁ pair ▁ is " , ar1 [ res_l ] , " , ▁ " , ar2 [ res_r ] ) NEW_LINE DEDENT
def findInteger ( arr , n ) : NEW_LINE INDENT hash = dict ( ) NEW_LINE maximum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] < 0 ) : NEW_LINE INDENT hash [ abs ( arr [ i ] ) ] -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT hash [ arr [ i ] ] += 1 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( hash [ arr [ i ] ] != 0 ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def decimalToBinary ( N ) : NEW_LINE INDENT B_Number = 0 NEW_LINE cnt = 0 NEW_LINE while ( N != 0 ) : NEW_LINE INDENT rem = N % 2 NEW_LINE c = pow ( 10 , cnt ) NEW_LINE B_Number += rem * c NEW_LINE N /= 2 NEW_LINE cnt += 1 NEW_LINE DEDENT return B_Number NEW_LINE DEDENT
def Right_most_setbit ( num ) : NEW_LINE INDENT pos = 1 NEW_LINE for i in range ( 0 , INT_SIZE ) : NEW_LINE INDENT if ( not ( num & ( 1 << i ) ) ) : NEW_LINE INDENT pos += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return pos NEW_LINE DEDENT
def countDigits ( a , b ) : NEW_LINE INDENT if ( a == 0 or b == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return math . floor ( math . log10 ( abs ( a ) ) + math . log10 ( abs ( b ) ) ) + 1 NEW_LINE DEDENT
def countWays ( n ) : NEW_LINE INDENT table = [ 0 for i in range ( n + 1 ) ] NEW_LINE for j in range ( n + 1 ) : NEW_LINE INDENT table [ j ] = 1 NEW_LINE DEDENT return table [ n ] NEW_LINE DEDENT
def twoWaySort ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] & 1 ) : NEW_LINE INDENT arr [ i ] = arr [ i ] * - 1 NEW_LINE DEDENT DEDENT arr . sort ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] & 1 ) : NEW_LINE INDENT arr [ i ] = arr [ i ] * - 1 NEW_LINE DEDENT DEDENT
def factorize ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( not ( n % 2 ) ) : NEW_LINE INDENT n >>= 1 NEW_LINE count += 1 NEW_LINE DEDENT if ( count ) : NEW_LINE INDENT print ( 2 , end = " ▁ " ) NEW_LINE count += 1 NEW_LINE DEDENT for i in range ( 3 , int ( m . sqrt ( n ) + 2 ) ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n % i == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE n = n / i NEW_LINE DEDENT if ( count ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE count += 1 NEW_LINE DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT print ( n , end = " ▁ " ) NEW_LINE 1 NEW_LINE DEDENT DEDENT
def findSmallestDifference ( A , B , m , n ) : NEW_LINE INDENT A . sort ( ) NEW_LINE B . sort ( ) NEW_LINE a = 0 ; b = 0 NEW_LINE result = 10 ** 9 NEW_LINE while ( a < m and b < n ) : NEW_LINE INDENT if ( abs ( A [ a ] - B [ b ] ) < result ) : NEW_LINE INDENT result = abs ( A [ a ] - B [ b ] ) NEW_LINE DEDENT if ( A [ a ] < B [ b ] ) : NEW_LINE INDENT a += 1 NEW_LINE DEDENT else : NEW_LINE INDENT b += 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def isPath ( arr ) : NEW_LINE INDENT arr [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , row ) : NEW_LINE INDENT if arr [ i ] [ 0 ] != - 1 : NEW_LINE INDENT arr [ i ] [ 0 ] = arr [ i - 1 ] [ 0 ] NEW_LINE DEDENT DEDENT for j in range ( 1 , col ) : NEW_LINE INDENT if arr [ 0 ] [ j ] != - 1 : NEW_LINE INDENT arr [ 0 ] [ j ] = arr [ 0 ] [ j - 1 ] NEW_LINE DEDENT DEDENT for i in range ( 1 , row ) : NEW_LINE INDENT for j in range ( 1 , col ) : NEW_LINE INDENT if arr [ i ] [ j ] != - 1 : NEW_LINE INDENT arr [ i ] [ j ] = max ( arr [ i ] [ j - 1 ] , arr [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return ( arr [ row - 1 ] [ col - 1 ] == 1 ) NEW_LINE DEDENT
def solve ( dp , a , low , high , turn ) : NEW_LINE INDENT if low == high : NEW_LINE INDENT return a [ low ] * turn NEW_LINE DEDENT if dp [ low ] [ high ] != 0 : NEW_LINE INDENT return dp [ low ] [ high ] NEW_LINE DEDENT dp [ low ] [ high ] = max ( a [ low ] * turn + solve ( dp , a , low + 1 , high , turn + 1 ) , a [ high ] * turn + solve ( dp , a , low , high - 1 , turn + 1 ) ) NEW_LINE return dp [ low ] [ high ] NEW_LINE DEDENT
def swapNibbles ( x ) : NEW_LINE INDENT return ( ( x & 0x0F ) << 4 | ( x & 0xF0 ) >> 4 ) NEW_LINE DEDENT
def countPS ( i , j ) : NEW_LINE INDENT if ( i >= n or j < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ i ] [ j ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ j ] NEW_LINE DEDENT if ( abs ( i - j ) == 1 ) : NEW_LINE INDENT if ( str [ i ] == str [ j ] ) : NEW_LINE INDENT return dp [ i ] [ j ] = 3 NEW_LINE DEDENT else : NEW_LINE INDENT return dp [ i ] [ j ] = 2 NEW_LINE DEDENT DEDENT if ( i == j ) : NEW_LINE INDENT return dp [ 1 ] [ j ] = 1 NEW_LINE DEDENT elif ( str [ i ] == str [ j ] ) : NEW_LINE INDENT return dp [ i ] [ j ] = countPS ( i + 1 , j ) + countPS ( i , j - 1 ) + 1 NEW_LINE DEDENT else : NEW_LINE INDENT return dp [ i ] [ j ] = ( countPS ( i + 1 , j ) + countPS ( i , j - 1 ) - countPS ( i + 1 , j - 1 ) ) NEW_LINE DEDENT DEDENT
def addOne ( x ) : NEW_LINE INDENT m = 1 NEW_LINE while ( x & m ) : NEW_LINE INDENT x = x ^ m NEW_LINE m <<= 1 NEW_LINE DEDENT x = x ^ m NEW_LINE return x NEW_LINE DEDENT
def check ( string ) : NEW_LINE INDENT n = len ( string ) NEW_LINE digitSum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT digitSum += ( ord ( string [ i ] ) - ord ( '0' ) ) NEW_LINE DEDENT return ( digitSum % 9 == 0 ) NEW_LINE DEDENT
def findMaxGCD ( arr , n ) : NEW_LINE INDENT high = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT high = max ( high , arr [ i ] ) NEW_LINE DEDENT divisors = [ 0 ] * ( high + 1 ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 1 , int ( m . sqrt ( arr [ i ] ) + 1 ) : NEW_LINE INDENT if ( arr [ i ] % j == 0 ) : NEW_LINE INDENT divisors [ j ] += 1 NEW_LINE if ( j != arr [ i ] // j ) : NEW_LINE INDENT divisors [ arr [ i ] // j ] += 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( high + 1 ) : NEW_LINE INDENT if ( divisors [ i ] > 1 ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT
def minRemove ( arr , n ) : NEW_LINE INDENT LIS = [ 0 ] * n NEW_LINE len = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT LIS [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( 0 , i ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and ( i - j ) <= ( arr [ i ] - arr [ j ] ) ) : NEW_LINE INDENT LIS [ i ] = max ( LIS [ i ] , LIS [ j ] + 1 ) NEW_LINE DEDENT DEDENT len = max ( len , LIS [ i ] ) NEW_LINE DEDENT return n - len NEW_LINE DEDENT
def computeLPSArray ( pat , M , lps ) : NEW_LINE INDENT len = 0 NEW_LINE lps [ 0 ] = 0 NEW_LINE i = 1 NEW_LINE while i < M : NEW_LINE INDENT if pat [ i ] == pat [ len ] : NEW_LINE INDENT len += 1 NEW_LINE lps [ i ] = len NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if len != 0 : NEW_LINE INDENT len = lps [ len - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT lps [ i ] = 0 NEW_LINE i += 1 NEW_LINE DEDENT DEDENT DEDENT
def numofsubset ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE count = 1 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( arr [ i ] + 1 != arr [ i + 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def stringReduction ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE count = [ 0 for i in range ( 3 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT count [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT if ( count [ 0 ] == n or count [ 1 ] == n or count [ 2 ] == n ) : NEW_LINE INDENT return n NEW_LINE DEDENT if ( ( count [ 0 ] % 2 ) == ( count [ 1 ] % 2 ) and ( count [ 2 ] % 2 ) ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT
def KnapSack ( val , wt , n , W ) : NEW_LINE INDENT dp = [ 0 for _ in range ( W + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( W ) : NEW_LINE INDENT dp [ j ] = max ( dp [ j ] , val [ i ] + dp [ j - wt [ i ] ] ) NEW_LINE DEDENT DEDENT return dp [ W ] NEW_LINE DEDENT
def findSum ( n ) : NEW_LINE INDENT multiTerms = n * ( n + 1 ) / 2 NEW_LINE sum = multiTerms NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT multiTerms = multiTerms - ( i - 1 ) NEW_LINE sum = sum + multiTerms * i NEW_LINE DEDENT return sum NEW_LINE DEDENT
def getSingle ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 0 , INT_SIZE ) : NEW_LINE INDENT sum = 0 NEW_LINE x = ( 1 << i ) NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ j ] & x ) : NEW_LINE INDENT sum += 1 NEW_LINE DEDENT DEDENT if ( sum % 3 ) : NEW_LINE INDENT result |= x NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def allCharactersSame ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( s [ i ] != s [ 0 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def maxDecimalValue ( mat , i , j , p ) : NEW_LINE INDENT if ( i >= N or j >= N ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT result = max ( maxDecimalValue ( mat , i , j + 1 , p + 1 ) , maxDecimalValue ( mat , i + 1 , j , p + 1 ) ) NEW_LINE if ( mat [ i ] [ j ] == 1 ) : NEW_LINE INDENT return pow ( 2 , p ) + result NEW_LINE DEDENT else : NEW_LINE INDENT return result NEW_LINE DEDENT DEDENT
def countBT ( h ) : NEW_LINE INDENT dp = [ 0 for i in range ( h + 1 ) ] NEW_LINE dp [ 0 ] = dp [ 1 ] = 1 NEW_LINE for i in range ( 2 , h + 1 ) : NEW_LINE INDENT dp [ i ] = ( dp [ i - 1 ] * ( ( 2 * dp [ i - 2 ] ) % mod + dp [ i - 1 ] ) % mod ) % mod NEW_LINE DEDENT return dp [ h ] NEW_LINE DEDENT
def power ( x , y , p ) : NEW_LINE INDENT res = 1 NEW_LINE x = x % p NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT y = int ( y >> 1 ) NEW_LINE x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT
def swapBits ( x , p1 , p2 , n ) : NEW_LINE INDENT set1 = ( x >> p1 ) & ( ( 1U << n ) - 1 ) NEW_LINE set2 = ( x >> p2 ) & ( ( 1U << n ) - 1 ) NEW_LINE Xor = ( set1 ^ set2 ) NEW_LINE Xor = ( Xor << p1 ) | ( Xor << p2 ) NEW_LINE result = x ^ Xor NEW_LINE return result NEW_LINE DEDENT
def findElements ( arr , n ) : NEW_LINE INDENT first = - 2147483647 NEW_LINE second = - 2147483647 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if arr [ i ] > first : NEW_LINE INDENT second = first NEW_LINE first = arr [ i ] NEW_LINE DEDENT elif arr [ i ] > second : NEW_LINE INDENT second = arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if arr [ i ] < second : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
def findMaximum ( arr , low , high ) : NEW_LINE INDENT max = arr [ low ] NEW_LINE i = low + 1 NEW_LINE while i <= high : NEW_LINE INDENT if arr [ i ] > max : NEW_LINE INDENT max = arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return max NEW_LINE DEDENT
def longestPrefixSuffix ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE lps = [ 0 for i in range ( n ) ] NEW_LINE lps [ 0 ] = 0 NEW_LINE len = 0 NEW_LINE i = 1 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( s [ i ] == s [ len ] ) : NEW_LINE INDENT len += 1 NEW_LINE lps [ i ] = len NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( len != 0 ) : NEW_LINE INDENT len = lps [ len - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT lps [ i ] = 0 NEW_LINE i += 1 NEW_LINE DEDENT DEDENT res = lps [ n - 1 ] NEW_LINE return res > n // 2 NEW_LINE DEDENT
def MaxTotalRectangleArea ( a , n ) : NEW_LINE INDENT a . sort ( reverse = True ) NEW_LINE sum = 0 NEW_LINE flag = False NEW_LINE len = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT if ( ( a [ i ] == a [ i + 1 ] or a [ i ] - a [ i + 1 ] == 1 ) and ( not flag ) ) : NEW_LINE INDENT flag = True NEW_LINE len = a [ i + 1 ] NEW_LINE i += 1 NEW_LINE DEDENT elif ( ( a [ i ] == a [ i + 1 ] or a [ i ] - a [ i + 1 ] == 1 ) and ( flag ) ) : NEW_LINE INDENT sum = sum + a [ i + 1 ] * len NEW_LINE flag = False NEW_LINE i += 1 NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def isHeap ( arr , i , n ) : NEW_LINE INDENT if ( i > ( n - 2 ) // 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( arr [ i ] >= arr [ 2 * i + 1 ] and arr [ i ] >= arr [ 2 * i + 2 ] and isHeap ( arr , 2 * i + 1 , n ) and isHeap ( arr , 2 * i + 2 , n ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def findLength ( string , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT l = i NEW_LINE r = i + 1 NEW_LINE lsum = 0 NEW_LINE rsum = 0 NEW_LINE while ( r < n and l >= 0 ) : NEW_LINE INDENT lsum += ord ( string [ l ] ) - ord ( '0' ) NEW_LINE rsum += ord ( string [ r ] ) - ord ( '0' ) NEW_LINE if ( lsum == rsum ) : NEW_LINE INDENT ans = max ( ans , r - l + 1 ) NEW_LINE DEDENT l -= 1 NEW_LINE r += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def maxDP ( n ) : NEW_LINE INDENT res = [ 0 for i in range ( n + 1 ) ] NEW_LINE res [ 0 ] = 0 NEW_LINE res [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT res [ i ] = max ( i , ( res [ i // 2 ] + res [ i // 3 ] + res [ i // 4 ] + res [ i // 5 ] ) ) NEW_LINE DEDENT return res [ n ] NEW_LINE DEDENT
def findDiff ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE count = 0 NEW_LINE max_count = 0 NEW_LINE min_count = n NEW_LINE for i in range ( ( n - 1 ) ) : NEW_LINE INDENT if ( arr [ i ] == arr [ i + 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE continue NEW_LINE DEDENT else : NEW_LINE INDENT max_count = max ( max_count , count ) NEW_LINE min_count = min ( min_count , count ) NEW_LINE count = 0 NEW_LINE DEDENT DEDENT return ( max_count - min_count ) NEW_LINE DEDENT
def countSink ( n , m , edgeFrom , edgeTo ) : NEW_LINE INDENT mark = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT mark [ edgeFrom [ i ] ] = 1 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( not mark [ i ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def countOfSubstringWithKOnes ( s , K ) : NEW_LINE INDENT N = len ( s ) NEW_LINE res = 0 NEW_LINE countOfOne = 0 NEW_LINE freq = [ 0 for i in range ( N + 1 ) ] NEW_LINE freq [ 0 ] = 1 NEW_LINE for i in range ( N ) : NEW_LINE INDENT countOfOne += ( ord ( s [ i ] ) - ord ( '0' ) ) NEW_LINE if ( countOfOne >= K ) : NEW_LINE INDENT res += freq [ countOfOne - K ] NEW_LINE DEDENT freq [ countOfOne ] += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT
def search ( arr , n , x ) : NEW_LINE INDENT for i in arr : NEW_LINE INDENT if x == i : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def binaryToDecimal ( n ) : NEW_LINE INDENT num = n NEW_LINE dec_value = 0 NEW_LINE base = 1 NEW_LINE len = len ( num ) NEW_LINE for i in range ( len - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( num [ i ] == '1' ) : NEW_LINE INDENT dec_value += base NEW_LINE base = base * 2 NEW_LINE DEDENT DEDENT return dec_value NEW_LINE DEDENT
def compute ( str , n ) : NEW_LINE INDENT reverseAlphabet = " zyxwvutsrqponmlkjihgfedcba " NEW_LINE l = len ( str ) NEW_LINE for i in range ( n , l ) : NEW_LINE INDENT str [ i ] = reverseAlphabet [ ord ( str [ i ] ) - ord ( ' a ' ) ] NEW_LINE DEDENT return str NEW_LINE DEDENT
def countPairs ( str ) : NEW_LINE INDENT result = 0 NEW_LINE n = len ( str ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( abs ( str [ i ] - str [ j ] ) == abs ( i - j ) ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
def flipsPossible ( a , n ) : NEW_LINE INDENT count_odd = 0 NEW_LINE count_even = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] & 1 ) : NEW_LINE INDENT count_odd += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_even += 1 NEW_LINE DEDENT DEDENT if ( count_odd % 2 and count_even % 2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT
def maxSumPairWithDifferenceLessThanK ( arr , N , K ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE dp = [ 0 for _ in range ( N ) ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] NEW_LINE if ( arr [ i ] - arr [ i - 1 ] < K ) : NEW_LINE INDENT if ( i >= 2 ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i ] , dp [ i - 2 ] + arr [ i ] + arr [ i - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] = max ( dp [ i ] , arr [ i ] + arr [ i - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ N - 1 ] NEW_LINE DEDENT
def kSmallestPair ( arr1 , n1 , arr2 , n2 , k ) : NEW_LINE INDENT if ( k > n1 * n2 ) : NEW_LINE INDENT print ( " k ▁ pairs ▁ don ' t ▁ exist " ) NEW_LINE return NEW_LINE DEDENT index2 = [ 0 for i in range ( n1 ) ] NEW_LINE while ( k > 0 ) : NEW_LINE INDENT min_sum = sys . maxsize NEW_LINE min_index = 0 NEW_LINE for i1 in range ( n1 ) : NEW_LINE INDENT if ( index2 [ i1 ] < n2 and arr1 [ i1 ] + arr2 [ index2 [ i1 ] ] < min_sum ) : NEW_LINE INDENT min_index = i1 NEW_LINE min_sum = arr1 [ i1 ] + arr2 [ index2 [ i1 ] ] NEW_LINE DEDENT DEDENT print ( " ( " , arr1 [ min_index ] , " , ▁ " , arr2 [ index2 [ min_index ] ] , " ) ▁ " ) NEW_LINE index2 [ min_index ] += 1 NEW_LINE k -= 1 NEW_LINE DEDENT DEDENT
def assign ( a , n ) : NEW_LINE INDENT np . sort ( a ) NEW_LINE ans = [ 0 ] * n NEW_LINE p = 0 NEW_LINE q = n - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( ( i + 1 ) % 2 == 0 ) : NEW_LINE INDENT ans [ i ] = a [ q -= 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT ans [ i ] = a [ p ] NEW_LINE DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( ans [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def findFourElements ( arr , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT mp [ arr [ i ] + arr [ j ] ] = { i , j } NEW_LINE DEDENT DEDENT d = - 1 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT abs_diff = abs ( arr [ i ] - arr [ j ] ) NEW_LINE if ( mp . get ( abs_diff ) ) : NEW_LINE INDENT p = mp [ abs_diff ] NEW_LINE if ( p . first != i and p . first != j and p . second != i and p . second != j ) : NEW_LINE INDENT d = max ( d , max ( arr [ i ] , arr [ j ] ) ) NEW_LINE DEDENT DEDENT DEDENT return d NEW_LINE DEDENT
def isPrime ( p ) : NEW_LINE INDENT checkNumber = ( int ) ( math . pow ( 2 , p ) - 1 ) NEW_LINE nextval = 4 % checkNumber NEW_LINE for i in range ( 1 , p - 1 ) : NEW_LINE INDENT nextval = ( nextval * nextval - 2 ) % checkNumber NEW_LINE DEDENT return ( nextval == 0 ) NEW_LINE DEDENT
def isPalindrome ( str ) : NEW_LINE INDENT l = 0 NEW_LINE h = len ( str ) - 1 NEW_LINE while ( h > l ) : NEW_LINE INDENT if ( str [ l ] != str [ h - 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT l += 1 NEW_LINE h -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT
def maxNumOfChocolates ( arr , n , k ) : NEW_LINE INDENT um = dict ( ) NEW_LINE sum = [ 0 ] * n NEW_LINE maxSum = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT sum [ i ] = sum [ i - 1 ] + arr [ i ] NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT curr_rem = sum [ i ] % k NEW_LINE if ( curr_rem == 0 ) : NEW_LINE INDENT if ( maxSum < sum [ i ] ) : NEW_LINE INDENT maxSum = sum [ i ] NEW_LINE DEDENT elif ( curr_rem in um . keys ( ) ) : NEW_LINE INDENT um [ curr_rem ] = i NEW_LINE DEDENT elif ( maxSum < ( sum [ i ] - sum [ um [ curr_rem ] ] ) ) : NEW_LINE INDENT maxSum = sum [ i ] - sum [ um [ curr_rem ] ] NEW_LINE DEDENT DEDENT return ( maxSum // k ) NEW_LINE DEDENT
def isPower ( x , y ) : NEW_LINE INDENT res1 = math . log ( y ) / math . log ( x ) NEW_LINE res2 = math . log ( y ) / math . log ( x ) NEW_LINE return ( res1 == res2 ) NEW_LINE DEDENT
def minMaxValues ( arr , n , m ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n + m ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE arr [ i ] += 50 NEW_LINE DEDENT dp = [ [ 0 for i in range ( MAX + 1 ) ] for j in range ( MAX * MAX + 1 ) ] NEW_LINE for i in range ( n + m ) : NEW_LINE INDENT for k in range ( min ( n , i + 1 ) , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( MAX * MAX + 1 ) : NEW_LINE INDENT if ( dp [ k - 1 ] [ j ] ) : NEW_LINE INDENT dp [ k ] [ j + arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT DEDENT max_value = - INF NEW_LINE min_value = INF NEW_LINE for i in range ( MAX * MAX + 1 ) : NEW_LINE INDENT if ( dp [ n ] [ i ] ) : NEW_LINE INDENT temp = i - 50 * n NEW_LINE max_value = max ( max_value , temp * ( sum - temp ) ) NEW_LINE min_value = min ( min_value , temp * ( sum - temp ) ) NEW_LINE DEDENT DEDENT print ( " Maximum ▁ Value : ▁ " , max_value ) NEW_LINE print ( " Minimum ▁ Value : ▁ " , min_value ) NEW_LINE DEDENT
def superSeq ( X , Y , m , n ) : NEW_LINE INDENT if ( not m ) : NEW_LINE INDENT return n NEW_LINE DEDENT if ( not n ) : NEW_LINE INDENT return m NEW_LINE DEDENT if ( X [ m - 1 ] == Y [ n - 1 ] ) : NEW_LINE INDENT return 1 + superSeq ( X , Y , m - 1 , n - 1 ) NEW_LINE DEDENT return 1 + min ( superSeq ( X , Y , m , n - 1 ) ) NEW_LINE DEDENT
def longSubarrWthSumDivByK ( arr , n , k ) : NEW_LINE INDENT um = dict ( ) NEW_LINE mod_arr = [ 0 ] * n NEW_LINE max = 0 NEW_LINE curr_sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT curr_sum += arr [ i ] NEW_LINE mod_arr [ i ] = ( ( curr_sum % k ) + k ) % k NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( mod_arr [ i ] == 0 ) : NEW_LINE INDENT max = i + 1 NEW_LINE DEDENT elif ( mod_arr [ i ] not in um ) : NEW_LINE INDENT um [ mod_arr [ i ] ] = i NEW_LINE DEDENT elif ( max < ( i - um [ mod_arr [ i ] ] ) ) : NEW_LINE INDENT max = i - um [ mod_arr [ i ] ] NEW_LINE DEDENT DEDENT return max NEW_LINE DEDENT
def arrangeBraces ( n , pos , k ) : NEW_LINE INDENT h = [ False for i in range ( k ) ] NEW_LINE dp = [ [ 0 for i in range ( k ) ] for j in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT h [ pos [ i ] ] = 1 NEW_LINE DEDENT dp [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , 2 * n + 1 ) : NEW_LINE INDENT for j in range ( 0 , 2 * n + 1 ) : NEW_LINE INDENT if ( h [ i ] != 0 ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT DEDENT return dp [ 2 * n ] [ 0 ] NEW_LINE DEDENT
def lexSmallest ( a , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE answer = " " NEW_LINE for i in range ( n ) : NEW_LINE INDENT answer += a [ i ] NEW_LINE DEDENT return answer NEW_LINE DEDENT
def subset ( ar , n ) : NEW_LINE INDENT res = 0 NEW_LINE ar . sort ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT count = 1 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( ar [ i ] == ar [ i + 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT res = max ( res , count ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def printSubStr ( Str , low , high ) : NEW_LINE INDENT for i in range ( low , high + 1 ) : NEW_LINE INDENT print ( Str [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def getMinSquares ( n ) : NEW_LINE INDENT dp = [ 0 for _ in range ( n + 1 ) ] NEW_LINE dp [ 0 ] = 0 NEW_LINE dp [ 1 ] = 1 NEW_LINE dp [ 2 ] = 2 NEW_LINE dp [ 3 ] = 3 NEW_LINE for i in range ( 4 , n + 1 ) : NEW_LINE INDENT dp [ i ] = i NEW_LINE for x in range ( 1 , ceil ( math . sqrt ( i ) ) + 1 ) : NEW_LINE INDENT temp = x * x NEW_LINE if temp > i : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] = min ( dp [ i ] , 1 + dp [ i - temp ] ) NEW_LINE DEDENT DEDENT DEDENT res = dp [ n ] NEW_LINE delete [ dp ] NEW_LINE return res NEW_LINE DEDENT
def printClosest ( arr , n , x ) : NEW_LINE INDENT res_l = res_r = l = 0 NEW_LINE r = n - 1 NEW_LINE diff = sys . maxsize NEW_LINE while ( r > l ) : NEW_LINE INDENT if ( abs ( arr [ l ] + arr [ r ] - x ) < diff ) : NEW_LINE INDENT res_l = l NEW_LINE res_r = r NEW_LINE diff = abs ( arr [ l ] + arr [ r ] - x ) NEW_LINE DEDENT if ( arr [ l ] + arr [ r ] > x ) : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT l += 1 NEW_LINE DEDENT DEDENT print ( " ▁ The ▁ closest ▁ pair ▁ is " , arr [ res_l ] , " and " , arr [ res_r ] ) NEW_LINE DEDENT
def countSubStr ( st , n ) : NEW_LINE INDENT m = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( st [ i ] == '1' ) : NEW_LINE INDENT m += 1 NEW_LINE DEDENT DEDENT return m * ( m - 1 ) / 2 NEW_LINE DEDENT
def countSubstringWithEqualEnds ( s ) : NEW_LINE INDENT result = 0 NEW_LINE n = len ( s ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT if ( s [ i ] == s [ j ] ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
def calcMaxValue ( str ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 1 , len ( str ) ) : NEW_LINE INDENT if ( str [ i ] == '0' or str [ i ] == '1' or res < 2 ) : NEW_LINE INDENT res += ( ord ( str [ i ] ) - ord ( '0' ) ) NEW_LINE DEDENT else : NEW_LINE INDENT res *= ( ord ( str [ i ] ) - ord ( '0' ) ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def bestFit ( blockSize , m , processSize , n ) : NEW_LINE INDENT allocation = [ - 1 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT bestIdx = - 1 NEW_LINE for j in range ( m ) : NEW_LINE INDENT if ( blockSize [ j ] >= processSize [ i ] ) : NEW_LINE INDENT if ( bestIdx == - 1 ) : NEW_LINE INDENT bestIdx = j NEW_LINE DEDENT elif ( blockSize [ bestIdx ] > blockSize [ j ] ) : NEW_LINE INDENT bestIdx = j NEW_LINE DEDENT DEDENT DEDENT if ( bestIdx != - 1 ) : NEW_LINE INDENT allocation [ i ] = bestIdx NEW_LINE blockSize [ bestIdx ] -= processSize [ i ] NEW_LINE DEDENT DEDENT print ( " Process ▁ No . \tProcess ▁ Size\tBlock ▁ no . " ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( " ▁ " , i + 1 , " \t\t " , processSize [ i ] , " \t\t " , allocation [ i ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ Allocated " ) NEW_LINE DEDENT DEDENT
def countFreq ( a , n ) : NEW_LINE INDENT hm = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT hm [ a [ i ] ] = hm . get ( a [ i ] ) + 1 NEW_LINE DEDENT cumul = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT cumul += hm [ a [ i ] ] NEW_LINE if hm [ a [ i ] ] == 0 : NEW_LINE INDENT print ( a [ i ] , end = " - > " , cumul ) NEW_LINE DEDENT hm [ a [ i ] ] = 0 NEW_LINE DEDENT DEDENT
def isSubSeqDivisible ( arr ) : NEW_LINE INDENT for i in range ( 0 , l ) : NEW_LINE INDENT for j in range ( i , l ) : NEW_LINE INDENT for k in range ( j , l ) : NEW_LINE INDENT if ( arr [ i ] % 8 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT elif ( arr [ i ] * 10 + arr [ j ] ) % 8 == 0 and i != j ) : NEW_LINE INDENT return True NEW_LINE DEDENT elif ( ( arr [ i ] * 100 + arr [ j ] * 10 + arr [ k ] ) % 8 == 0 and i != j and j != k and i != k ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT DEDENT return False NEW_LINE DEDENT
def getAbs ( n ) : NEW_LINE INDENT mask = n >> ( sizeof ( int ) * CHARBIT - 1 ) NEW_LINE return ( ( n + mask ) ^ mask ) NEW_LINE DEDENT
def isAnBn ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT if ( str [ i ] != ' a ' ) : NEW_LINE INDENT break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if ( i * 2 != n ) : NEW_LINE INDENT return False NEW_LINE DEDENT j = i NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( str [ j ] != ' b ' ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def maxDistance ( arr , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE max_dist = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if mp . get ( arr [ i ] ) == mp . end ( ) : NEW_LINE INDENT mp [ arr [ i ] ] = i NEW_LINE DEDENT else : NEW_LINE INDENT max_dist = max ( max_dist , i - mp [ arr [ i ] ] ) NEW_LINE DEDENT DEDENT return max_dist NEW_LINE DEDENT
def maxSumWO3Consec ( arr , n ) : NEW_LINE INDENT sum = [ 0 ] * n NEW_LINE if ( n >= 1 ) : NEW_LINE INDENT sum [ 0 ] = arr [ 0 ] NEW_LINE if ( n >= 2 ) : NEW_LINE INDENT sum [ 1 ] = arr [ 0 ] + arr [ 1 ] NEW_LINE if ( n > 2 ) : NEW_LINE INDENT sum [ 2 ] = max ( sum [ 1 ] , max ( arr [ 1 ] + arr [ 2 ] , arr [ 0 ] + arr [ 2 ] ) ) NEW_LINE DEDENT for i in range ( 3 , n ) : NEW_LINE INDENT sum [ i ] = max ( max ( sum [ i - 1 ] , sum [ i - 2 ] + arr [ i ] ) , arr [ i ] + arr [ i - 1 ] + sum [ i - 3 ] ) NEW_LINE DEDENT return sum [ n - 1 ] NEW_LINE DEDENT
def nobleInteger ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if arr [ i ] == arr [ i + 1 ] : NEW_LINE INDENT continue NEW_LINE DEDENT if arr [ i ] == n - i - 1 : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT if arr [ n - 1 ] == 0 : NEW_LINE INDENT return arr [ n - 1 ] NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def productArray ( arr , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT print ( "0 ▁ " ) NEW_LINE return NEW_LINE DEDENT temp = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT prod [ i ] = temp NEW_LINE temp *= arr [ i ] NEW_LINE DEDENT temp = 1 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT prod [ i ] = temp NEW_LINE temp = arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( prod [ i ] , end = " ▁ " ) NEW_LINE DEDENT return NEW_LINE DEDENT
def sortedAfterSwap ( A , B , n ) : NEW_LINE INDENT for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( B [ i ] ) : NEW_LINE INDENT j = i NEW_LINE while ( B [ j ] ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT A [ i ] = i + 1 NEW_LINE DEDENT return True NEW_LINE DEDENT
def maxSubarrayXOR ( arr , n ) : NEW_LINE INDENT ans = - float ( ' inf ' ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT curr_xor = 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT curr_xor = curr_xor ^ arr [ j ] NEW_LINE ans = max ( ans , curr_xor ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def minRemovalsDP ( arr , n ) : NEW_LINE INDENT longest_start = - 1 NEW_LINE longest_end = 0 NEW_LINE for start in range ( n ) : NEW_LINE INDENT min = sys . maxsize NEW_LINE max = sys . maxsize NEW_LINE for end in range ( start , n ) : NEW_LINE INDENT val = arr [ end ] NEW_LINE if ( val < min ) : NEW_LINE INDENT min = val NEW_LINE DEDENT if ( val > max ) : NEW_LINE INDENT max = val NEW_LINE DEDENT if ( 2 * min <= max ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( end - start > longest_end - longest_start or longest_start == - 1 ) : NEW_LINE INDENT longest_start = start NEW_LINE longest_end = end NEW_LINE DEDENT DEDENT DEDENT if ( longest_start == - 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT return ( n - ( longest_end - longest_start + 1 ) ) NEW_LINE DEDENT
def surface_area_octahedron ( side ) : NEW_LINE INDENT return ( 2 * ( math . sqrt ( 3 ) ) * ( side * side ) ) NEW_LINE DEDENT
def countUnique ( mat , n , m ) : NEW_LINE INDENT rowsum = [ 0 ] * n NEW_LINE colsum = [ 0 for x in range ( m ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( mat [ i ] [ j ] ) : NEW_LINE INDENT rowsum [ i ] += 1 NEW_LINE colsum [ j ] += 1 NEW_LINE DEDENT DEDENT uniquecount = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( mat [ i ] [ j ] and rowsum [ i ] == 1 and colsum [ j ] == 1 ) : NEW_LINE INDENT uniquecount += 1 NEW_LINE DEDENT DEDENT return uniquecount NEW_LINE DEDENT
def remainder ( str ) : NEW_LINE INDENT lenn = len ( str ) NEW_LINE rem = 0 NEW_LINE for i in range ( lenn ) : NEW_LINE INDENT num = rem * 10 + ( ord ( str [ i ] ) - ord ( '0' ) ) NEW_LINE rem = num % 11 NEW_LINE DEDENT return rem NEW_LINE DEDENT
def checkReverse ( arr , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT i = 1 NEW_LINE while ( i < n and arr [ i - 1 ] < arr [ i ] ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT if ( i == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT j = i NEW_LINE while ( arr [ j ] < arr [ j - 1 ] ) : NEW_LINE INDENT if ( i > 1 and arr [ j ] < arr [ i - 2 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if ( j == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT k = j NEW_LINE if ( arr [ k ] < arr [ i - 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT while ( k > 1 and k < n ) : NEW_LINE INDENT if ( arr [ k ] < arr [ k - 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT k += 1 NEW_LINE DEDENT return True NEW_LINE DEDENT
def vol_of_octahedron ( side ) : NEW_LINE INDENT return ( side * side * side ) * ( math . sqrt ( 2 ) / 3 ) ) NEW_LINE DEDENT
def maxDifference ( arr , N , k ) : NEW_LINE INDENT S = 0 NEW_LINE S1 = 0 NEW_LINE max_difference = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT S += arr [ i ] NEW_LINE DEDENT arr . sort ( reverse = True ) NEW_LINE M = max ( k , N - k ) NEW_LINE for i in range ( 0 , M ) : NEW_LINE INDENT S1 += arr [ i ] NEW_LINE DEDENT max_difference = S1 - ( S - S1 ) NEW_LINE return max_difference NEW_LINE DEDENT
def maxSumSubarrayRemovingOneEle ( arr , n ) : NEW_LINE INDENT fw = [ 0 ] * n NEW_LINE bw = [ 0 ] * n NEW_LINE cur_max = max_so_far = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT cur_max = max ( arr [ i ] , cur_max + arr [ i ] ) NEW_LINE max_so_far = max ( max_so_far , cur_max ) NEW_LINE bw [ i ] = cur_max NEW_LINE DEDENT cur_max = max_so_far = bw [ n - 1 ] = arr [ n - 1 ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT cur_max = max ( arr [ i ] , cur_max + arr [ i ] ) NEW_LINE max_so_far = max ( max_so_far , cur_max ) NEW_LINE bw [ i ] = cur_max NEW_LINE DEDENT fans = max_so_far NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT fans = max ( fans , fw [ i - 1 ] + bw [ i + 1 ] ) NEW_LINE DEDENT return fans NEW_LINE DEDENT
def findMaxPoints ( A ) : NEW_LINE INDENT P1S = [ [ 0 for i in range ( N + 1 ) ] for j in range ( M + 1 ) ] NEW_LINE P1E = [ [ 0 for i in range ( N + 1 ) ] for j in range ( M + 1 ) ] NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( 1 , M + 1 ) : NEW_LINE INDENT P1S [ i ] [ j ] = max ( P1S [ i - 1 ] [ j ] , P1S [ i ] [ j - 1 ] ) + A [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT DEDENT for i in range ( N + 1 , M + 1 ) : NEW_LINE INDENT for j in range ( 1 , M + 1 ) : NEW_LINE INDENT P1E [ i ] [ j ] = max ( P1E [ i + 1 ] [ j ] , P1E [ i ] [ j + 1 ] ) + A [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT DEDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( 1 , M + 1 ) : NEW_LINE INDENT P2E [ i ] [ j ] = max ( P2E [ i - 1 ] [ j ] , P2E [ i ] [ j + 1 ] ) + A [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT for j in range ( 2 , M + 1 ) : NEW_LINE INDENT op1 = P1S [ i ] [ j - 1 ] + P1E [ i ] [ j + 1 ] NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE DEDENT
def KnapSack ( val , wt , n , W ) : NEW_LINE INDENT mat = [ [ 0 for i in range ( W + 1 ) ] for j in range ( 2 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT j = 0 NEW_LINE if ( i % 2 != 0 ) : NEW_LINE INDENT while ( j <= W ) : NEW_LINE INDENT if ( wt [ i ] <= j ) : NEW_LINE INDENT mat [ 1 ] [ j ] = max ( val [ i ] + mat [ 0 ] [ j - wt [ i ] ] , mat [ 0 ] [ j ] ) NEW_LINE DEDENT else : NEW_LINE INDENT mat [ 1 ] [ j ] = mat [ 0 ] [ j ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT while ( j <= W ) : NEW_LINE INDENT if ( wt [ i ] <= j ) : NEW_LINE INDENT mat [ 0 ] [ j ] = max ( val [ i ] + mat [ 1 ] [ j - wt [ i ] ] , mat [ 1 ] [ j ] ) NEW_LINE DEDENT else : NEW_LINE INDENT mat [ 0 ] [ j ] = mat [ 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT i += 1 NEW_LINE DEDENT return ( n % 2 != 0 ) ? mat [ 0 ] [ W ] : mat [ 1 ] [ W ] NEW_LINE DEDENT
def isHeap ( arr , n ) : NEW_LINE INDENT for i in range ( ( n - 2 ) // 2 + 1 ) : NEW_LINE INDENT if ( arr [ 2 * i + 1 ] > arr [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( 2 * i + 2 < n and arr [ 2 * i + 2 ] > arr [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def maxProduct ( arr , n ) : NEW_LINE INDENT if ( n < 2 ) : NEW_LINE INDENT print ( " No ▁ pairs ▁ exists " ) NEW_LINE return - 1 NEW_LINE DEDENT if ( n == 2 ) : NEW_LINE INDENT print ( arr [ 0 ] , arr [ 1 ] ) NEW_LINE return - 1 NEW_LINE DEDENT posa = 10 ** 9 NEW_LINE posb = 10 ** 9 NEW_LINE nega = 10 ** 9 NEW_LINE negb = 10 ** 9 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] > posa ) : NEW_LINE INDENT posb = posa NEW_LINE posa = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] < 0 and abs ( arr [ i ] ) > abs ( nega ) ) : NEW_LINE INDENT negb = nega NEW_LINE nega = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] < 0 and abs ( arr [ i ] ) > abs ( negb ) ) : NEW_LINE INDENT negb = arr [ i ] NEW_LINE DEDENT DEDENT if ( nega * negb > posa * posb ) : NEW_LINE INDENT print ( " Max ▁ product ▁ pair ▁ is " , nega , " , ▁ " , negb ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Max ▁ product ▁ pair ▁ is " , posa , " , ▁ " , posb ) NEW_LINE DEDENT DEDENT
def superSeq ( x , y , m , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( m + 1 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if ( not i ) : NEW_LINE INDENT dp [ i ] [ j ] = j NEW_LINE DEDENT elif ( not j ) : NEW_LINE INDENT dp [ i ] [ j ] = i NEW_LINE DEDENT elif ( x [ i - 1 ] == y [ j - 1 ] ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = 1 + min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ m ] [ n ] NEW_LINE DEDENT
def minJumps ( arr , n ) : NEW_LINE INDENT jumps = [ 0 ] * n NEW_LINE jumps [ n - 1 ] = 0 NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if arr [ i ] == 0 : NEW_LINE INDENT jumps [ i ] = sys . maxsize NEW_LINE DEDENT elif arr [ i ] >= n - i - 1 : NEW_LINE INDENT jumps [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT min = sys . maxsize NEW_LINE for j in range ( i + 1 , n and j <= arr [ i ] + i ) : NEW_LINE INDENT if min > jumps [ j ] : NEW_LINE INDENT min = jumps [ j ] NEW_LINE DEDENT DEDENT if min != sys . maxsize : NEW_LINE INDENT jumps [ i ] = min + 1 NEW_LINE DEDENT else : NEW_LINE INDENT jumps [ i ] = min NEW_LINE DEDENT DEDENT return jumps [ 0 ] NEW_LINE DEDENT
def minAdjustmentCost ( A , n , M , target ) : NEW_LINE INDENT dp = [ [ 0 for j in range ( M + 1 ) ] for i in range ( n ) ] NEW_LINE for j in range ( M + 1 ) : NEW_LINE INDENT dp [ 0 ] [ j ] = abs ( j - A [ 0 ] ) NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( 1 , M + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = sys . maxint NEW_LINE for k in range ( max ( j - target , 0 ) , min ( M , j + target ) + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ i - 1 ] [ k ] + abs ( A [ i ] - j ) ) NEW_LINE DEDENT DEDENT DEDENT res = sys . maxsize NEW_LINE for j in range ( M + 1 ) : NEW_LINE INDENT res = min ( res , dp [ n - 1 ] [ j ] ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def kthSmallest ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE return arr [ k - 1 ] NEW_LINE DEDENT
def lis ( arr , n ) : NEW_LINE INDENT max = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT max = max + 1 NEW_LINE DEDENT _lis ( arr , n , & max ) NEW_LINE return max NEW_LINE DEDENT
def minCoins ( coins , m , V ) : NEW_LINE INDENT if ( V == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT res = 10 ** 9 NEW_LINE for i in range ( m ) : NEW_LINE INDENT if ( coins [ i ] <= V ) : NEW_LINE INDENT sub_res = minCoins ( coins , m , V - coins [ i ] ) NEW_LINE if ( sub_res != 10 ** 9 ) : NEW_LINE INDENT res = sub_res + 1 NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT
def minimum_cost ( a , n ) : NEW_LINE INDENT mn = sys . maxsize NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT mn = min ( a [ i ] , mn ) NEW_LINE sum += a [ i ] NEW_LINE DEDENT return mn * ( sum - mn ) NEW_LINE DEDENT
def getArea ( a ) : NEW_LINE INDENT area = ( M_PI * a * a ) / 4.0 NEW_LINE return area NEW_LINE DEDENT
def evenFibSum ( limit ) : NEW_LINE INDENT if ( limit < 2 ) : return 0 NEW_LINE ef1 = 0 NEW_LINE ef2 = 2 NEW_LINE sum = ef1 + ef2 NEW_LINE while ( ef2 <= limit ) : NEW_LINE INDENT ef3 = 4 * ef2 + ef1 NEW_LINE if ( ef3 > limit ) : NEW_LINE INDENT break NEW_LINE DEDENT ef1 = ef2 NEW_LINE ef2 = ef3 NEW_LINE sum += ef2 NEW_LINE DEDENT return sum NEW_LINE DEDENT
def findSubArray ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE maxsize = - 1 NEW_LINE startindex = 0 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT sum = ( arr [ i ] == 0 ) ? - 1 : 1 NEW_LINE DEDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT ( arr [ j ] == 0 ) : NEW_LINE INDENT ( sum += - 1 ) NEW_LINE DEDENT ( sum += 1 ) NEW_LINE if ( sum == 0 and maxsize < j - i + 1 ) : NEW_LINE INDENT maxsize = j - i + 1 NEW_LINE startindex = i NEW_LINE DEDENT DEDENT DEDENT if ( maxsize == - 1 ) : NEW_LINE INDENT print ( " No ▁ such ▁ subarray " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( startindex , " ▁ to ▁ " , startindex + maxsize - 1 ) NEW_LINE DEDENT return maxsize NEW_LINE DEDENT
def largestSumOfAverages ( A , K ) : NEW_LINE INDENT n = len ( A ) NEW_LINE pre_sum = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT pre_sum [ i + 1 ] = pre_sum [ i ] + A [ i ] NEW_LINE DEDENT dp = [ 0 ] * ( n + 1 ) NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp [ i ] = ( pre_sum [ n ] - pre_sum [ i ] ) / ( n - i ) NEW_LINE DEDENT for k in range ( K - 1 ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i ] , ( pre_sum [ j ] - pre_sum [ i ] ) / ( j - i ) + dp [ j ] ) NEW_LINE DEDENT DEDENT return dp [ 0 ] NEW_LINE DEDENT
def getMinSteps ( n ) : NEW_LINE INDENT table = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT table [ i ] = n - i NEW_LINE DEDENT for i in range ( n + 1 ) : NEW_LINE INDENT if ( not ( i % 2 ) ) : NEW_LINE INDENT table [ i // 2 ] = min ( table [ i ] + 1 , table [ i // 2 ] ) NEW_LINE DEDENT if ( not ( i % 3 ) ) : NEW_LINE INDENT table [ i // 3 ] = min ( table [ i ] + 1 , table [ i // 3 ] ) NEW_LINE DEDENT DEDENT return table [ 1 ] NEW_LINE DEDENT
def eggDrop ( n , k ) : NEW_LINE INDENT if ( k == 1 or k == 0 ) : NEW_LINE INDENT return k NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return k NEW_LINE DEDENT min = 2147483647 NEW_LINE for x in range ( k + 1 ) : NEW_LINE INDENT res = max ( eggDrop ( n - 1 , x - 1 ) , eggDrop ( n , k - x ) ) NEW_LINE if ( res < min ) : NEW_LINE INDENT min = res NEW_LINE DEDENT DEDENT return min + 1 NEW_LINE DEDENT
def count ( s , c ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == c ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def findLength ( string , n ) : NEW_LINE INDENT sum = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum [ i ] = ( sum [ i - 1 ] + string [ i - 1 ] - '0' ) NEW_LINE DEDENT ans = 0 NEW_LINE for len in range ( 2 , n + 2 ) : NEW_LINE INDENT for i in range ( 0 , n + 1 ) : NEW_LINE INDENT j = i + len - 1 NEW_LINE if ( sum [ i + len // 2 ] - sum [ i ] == sum [ i + len ] - sum [ i + len // 2 ] ) : NEW_LINE INDENT ans = max ( ans , len ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def maximumNumberDistinctPrimeRange ( m , n ) : NEW_LINE INDENT factorCount = [ 0 for i in range ( n + 1 ) ] NEW_LINE prime = [ False for i in range ( n + 1 ) ] NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT factorCount [ i ] = 0 NEW_LINE prime [ i ] = True NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ i ] == True ) : NEW_LINE INDENT factorCount [ i ] = 1 NEW_LINE for j in range ( i * 2 , n + i ) : NEW_LINE INDENT factorCount [ j ] += 1 NEW_LINE prime [ j ] = False NEW_LINE DEDENT DEDENT DEDENT max = factorCount [ m ] NEW_LINE num = m NEW_LINE for i in range ( m , n + 1 ) : NEW_LINE INDENT if ( factorCount [ i ] > max ) : NEW_LINE INDENT max = factorCount [ i ] NEW_LINE num = i NEW_LINE DEDENT DEDENT return num NEW_LINE DEDENT
def catalan ( n ) : NEW_LINE INDENT if ( n <= 1 ) : return 1 NEW_LINE DEDENT res = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT res += catalan ( i ) * catalan ( n - i - 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def minRevolutions ( r , x1 , y1 , x2 , y2 ) : NEW_LINE INDENT d = math . sqrt ( ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ) NEW_LINE return ceil ( d / ( 2 * r ) ) NEW_LINE DEDENT
def largestKSubmatrix ( a ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( Col ) ] for j in range ( Row ) ] NEW_LINE result = 0 NEW_LINE for i in range ( Row ) : NEW_LINE INDENT for j in range ( Col ) : NEW_LINE INDENT if ( i == 0 or j == 0 ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( a [ i ] [ j ] == a [ i - 1 ] [ j ] and a [ i ] [ j ] == a [ i ] [ j - 1 ] and a [ i ] [ j ] == a [ i - 1 ] [ j - 1 ] ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) + 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = 1 NEW_LINE DEDENT DEDENT result = max ( result , dp [ i ] [ j ] ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def cassini ( n ) : NEW_LINE INDENT return - 1 if ( n & 1 ) else 1 NEW_LINE DEDENT
def waysToArrange ( N , K , k ) : NEW_LINE INDENT C = [ [ 0 for j in range ( N + 1 ) ] for i in range ( N + 1 ) ] NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT for j in range ( 0 , N + 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT dp = [ 0 ] * ( K + 1 ) NEW_LINE count = 0 NEW_LINE for i in range ( K ) : NEW_LINE INDENT dp [ i + 1 ] = ( dp [ i ] * C [ count + k [ i ] - 1 ] [ k [ i ] - 1 ] ) NEW_LINE count += k [ i ] NEW_LINE DEDENT return dp [ K ] NEW_LINE DEDENT
def findDimen ( H , A ) : NEW_LINE INDENT if ( H * H < 4 * A ) : NEW_LINE INDENT print ( " Not ▁ Possible " ) NEW_LINE return - 1 NEW_LINE DEDENT apb = math . sqrt ( H * H + 4 * A ) NEW_LINE asb = math . sqrt ( H * H - 4 * A ) NEW_LINE print ( " P ▁ = ▁ " , fixed , ( apb - asb ) / 2.0 , " \n " ) NEW_LINE print ( " B ▁ = ▁ " , ( apb + asb ) / 2.0 , " \n " ) NEW_LINE DEDENT
def maxTripletSum ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE return arr [ n - 1 ] + arr [ n - 2 ] + arr [ n - 3 ] NEW_LINE DEDENT
def MaxDotProduct ( A , B , m , n ) : NEW_LINE INDENT dp = [ [ 0 for x in range ( m + 1 ) ] for y in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , m + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( ( dp [ i - 1 ] [ j - 1 ] + ( A [ j - 1 ] * B [ i - 1 ] ) ) , dp [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT return dp [ n ] [ m ] NEW_LINE DEDENT
def findMinDiff ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE diff = 2147483647 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( arr [ i + 1 ] - arr [ i ] < diff ) : NEW_LINE INDENT diff = arr [ i + 1 ] - arr [ i ] NEW_LINE DEDENT DEDENT return diff NEW_LINE DEDENT
def findLastIndex ( str , x ) : NEW_LINE INDENT for i in range ( len ( str ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( str [ i ] == x ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def maxLower ( str1 ) : NEW_LINE INDENT n = len ( str1 ) NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT if ( str1 [ i ] >= ' A ' and str1 [ i ] <= ' Z ' ) : NEW_LINE INDENT i += 1 NEW_LINE break NEW_LINE DEDENT DEDENT maxCount = 0 NEW_LINE count = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( str1 [ i ] >= ' A ' and str1 [ i ] <= ' Z ' ) : NEW_LINE INDENT currCount = 0 NEW_LINE for j in range ( MAX_CHAR ) : NEW_LINE INDENT if ( count [ j ] > 0 ) : NEW_LINE INDENT currCount += 1 NEW_LINE DEDENT DEDENT maxCount = max ( maxCount , currCount ) NEW_LINE memset ( count , 0 , sizeof ( count ) ) NEW_LINE DEDENT if ( str1 [ i ] >= ' a ' and str1 [ i ] <= ' z ' ) : NEW_LINE INDENT count [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT DEDENT return maxCount NEW_LINE DEDENT
def evenlength ( n ) : NEW_LINE INDENT res = n NEW_LINE for j in range ( len ( n ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT res += n [ j ] NEW_LINE DEDENT return res NEW_LINE DEDENT
def maxLen ( arr , n ) : NEW_LINE INDENT hM = dict ( ) NEW_LINE Sum = 0 NEW_LINE max_len = 0 NEW_LINE ending_index = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT Sum += arr [ i ] NEW_LINE if Sum == 0 : NEW_LINE INDENT max_len = i + 1 NEW_LINE ending_index = i NEW_LINE DEDENT if Sum in hM . keys ( ) : NEW_LINE INDENT if max_len < i - hM [ Sum + n ] : NEW_LINE INDENT max_len = i - hM [ Sum + n ] NEW_LINE ending_index = i NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT hM [ Sum + n ] = i NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = ( arr [ i ] == - 1 ) : NEW_LINE INDENT arr [ i ] = 0 NEW_LINE DEDENT DEDENT print ( " % d ▁ to ▁ % d " , ending_index - max_len + 1 , ending_index ) NEW_LINE return max_len NEW_LINE DEDENT
def circumference ( r ) : NEW_LINE INDENT cir = 2 * PI * r NEW_LINE return cir NEW_LINE DEDENT
def printDistinct ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT while i < n - 1 and arr [ i ] == arr [ i + 1 ] : NEW_LINE INDENT i += 1 NEW_LINE DEDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def search ( arr , n , x , k ) : NEW_LINE INDENT i = 0 NEW_LINE while i < n : NEW_LINE INDENT if arr [ i ] == x : NEW_LINE INDENT return i NEW_LINE DEDENT i = i + max ( 1 , abs ( arr [ i ] - x ) / k ) NEW_LINE DEDENT print ( " number ▁ is ▁ not ▁ present ! " ) NEW_LINE return - 1 NEW_LINE DEDENT
def countStrings ( n ) : NEW_LINE INDENT a = [ 0 ] * n NEW_LINE b = [ 0 ] * n NEW_LINE a [ 0 ] = b [ 0 ] = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT a [ i ] = a [ i - 1 ] + b [ i - 1 ] NEW_LINE b [ i ] = a [ i - 1 ] NEW_LINE DEDENT return a [ n - 1 ] + b [ n - 1 ] NEW_LINE DEDENT
def minSum ( arr , n ) : NEW_LINE INDENT if ( n == 1 ) : return arr [ 0 ] NEW_LINE if ( n == 2 ) : return min ( arr [ 0 ] , arr [ 1 ] ) NEW_LINE if ( n == 3 ) : return min ( arr [ 0 ] , arr [ 1 ] , arr [ 2 ] ) NEW_LINE if ( n == 4 ) : return min ( min ( arr [ 0 ] , arr [ 1 ] , arr [ 2 ] , arr [ 3 ] ) ) NEW_LINE DEDENT dp = [ 0 ] NEW_LINE dp [ 1 ] = arr [ 1 ] NEW_LINE dp [ 2 ] = arr [ 2 ] NEW_LINE dp [ 3 ] = arr [ 3 ] NEW_LINE for i in range ( 4 , n ) : NEW_LINE INDENT dp [ i ] = arr [ i ] + min ( min ( dp [ i - 1 ] , dp [ i - 2 ] ) , min ( dp [ i - 3 ] , dp [ i - 4 ] ) ) NEW_LINE DEDENT return min ( min ( dp [ n - 1 ] , dp [ n - 2 ] ) , min ( dp [ n - 4 ] , dp [ n - 3 ] ) ) NEW_LINE DEDENT
def printSequence ( arr , input ) : NEW_LINE INDENT output = " " NEW_LINE n = len ( input ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( input [ i ] == ' ▁ ' ) : NEW_LINE INDENT output = output + "0" NEW_LINE DEDENT else : NEW_LINE INDENT position = ord ( input [ i ] ) - ord ( ' A ' ) NEW_LINE output = output + arr [ position ] NEW_LINE DEDENT DEDENT return output NEW_LINE DEDENT
def maxcoefficientvalue ( n ) : NEW_LINE INDENT C = [ [ 0 for j in range ( n + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( min ( i , n + 1 ) ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT maxvalue = 0 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT maxvalue = max ( maxvalue , C [ n ] [ i ] ) NEW_LINE DEDENT return maxvalue NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( a < b ) : NEW_LINE INDENT return gcd ( b , a ) NEW_LINE DEDENT if ( fabs ( b ) < 0.001 ) : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return ( gcd ( b , a - floor ( a / b ) * b ) ) NEW_LINE DEDENT DEDENT
def sortByPattern ( str , pat ) : NEW_LINE INDENT count = [ 0 for i in range ( MAX_CHAR ) ] NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT count [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT index = 0 NEW_LINE for i in range ( len ( pat ) ) : NEW_LINE INDENT for j in range ( count [ ord ( pat [ i ] ) - ord ( ' a ' ) ] ) : NEW_LINE INDENT str [ index ] = pat [ i ] NEW_LINE DEDENT DEDENT DEDENT
def minJumps ( arr , n ) : NEW_LINE INDENT jumps = [ 0 for x in range ( n ) ] NEW_LINE if ( n == 0 or arr [ 0 ] == 0 ) : NEW_LINE INDENT return sys . maxsize NEW_LINE DEDENT jumps [ 0 ] = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT jumps [ i ] = sys . maxsize NEW_LINE for j in range ( 0 , i ) : NEW_LINE INDENT if ( i <= j + arr [ j ] and jumps [ j ] != INT_MAX ) : NEW_LINE INDENT jumps [ i ] = min ( jumps [ i ] , jumps [ j ] + 1 ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT return jumps [ n - 1 ] NEW_LINE DEDENT
def find_prob ( N , P ) : NEW_LINE INDENT dp = [ 0 for i in range ( N + 1 ) ] NEW_LINE dp [ 0 ] = 1 NEW_LINE dp [ 1 ] = 0 NEW_LINE dp [ 2 ] = P NEW_LINE dp [ 3 ] = 1 - P NEW_LINE for i in range ( 4 , N + 1 ) : NEW_LINE INDENT dp [ i ] = ( P ) * dp [ i - 2 ] + ( 1 - P ) * dp [ i - 3 ] NEW_LINE DEDENT return dp [ N ] NEW_LINE DEDENT
def countStrings ( n ) : NEW_LINE INDENT a = [ 0 ] * n NEW_LINE b = [ 0 ] * n NEW_LINE a [ 0 ] = b [ 0 ] = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT a [ i ] = a [ i - 1 ] + b [ i - 1 ] NEW_LINE b [ i ] = a [ i - 1 ] NEW_LINE DEDENT return ( 1 << n ) - a [ n - 1 ] - b [ n - 1 ] NEW_LINE DEDENT
def maximumSegments ( n , a , b , c ) : NEW_LINE INDENT dp = [ - 1 for i in range ( n + 1 ) ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if dp [ i ] != - 1 : NEW_LINE INDENT if i + a <= n : NEW_LINE INDENT dp [ i + a ] = max ( dp [ i ] + 1 , dp [ i + a ] ) NEW_LINE DEDENT if i + b <= n : NEW_LINE INDENT dp [ i + b ] = max ( dp [ i ] + 1 , dp [ i + b ] ) NEW_LINE DEDENT if i + c <= n : NEW_LINE INDENT dp [ i + c ] = max ( dp [ i ] + 1 , dp [ i + c ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ n ] NEW_LINE DEDENT
def countWords ( str , len ) : NEW_LINE INDENT count = 1 NEW_LINE if ( len == 1 ) : NEW_LINE INDENT return count NEW_LINE DEDENT if ( str [ 0 ] == str [ 1 ] ) : NEW_LINE INDENT count = 1 NEW_LINE DEDENT else : NEW_LINE INDENT count = 2 NEW_LINE DEDENT for j in range ( 1 , len - 1 ) : NEW_LINE INDENT if ( str [ j ] == str [ j - 1 ] and str [ j ] == str [ j + 1 ] ) : NEW_LINE INDENT count *= 1 NEW_LINE DEDENT elif ( str [ j ] == str [ j - 1 ] or str [ j ] == str [ j + 1 ] or str [ j - 1 ] == str [ j + 1 ] ) : NEW_LINE INDENT count = 2 NEW_LINE DEDENT else : NEW_LINE INDENT count *= 3 NEW_LINE DEDENT DEDENT if ( str [ len - 1 ] == str [ len - 2 ] ) : NEW_LINE INDENT count = 1 NEW_LINE DEDENT else : NEW_LINE INDENT count = 2 NEW_LINE DEDENT return count NEW_LINE DEDENT
def findMinDiff ( arr , n ) : NEW_LINE INDENT diff = 2147483647 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( abs ( arr [ i ] - arr [ j ] ) < diff ) : NEW_LINE INDENT diff = abs ( arr [ i ] - arr [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return diff NEW_LINE DEDENT
def maxSum ( arr , n ) : NEW_LINE INDENT res = - float ( ' inf ' ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT curr_sum = 0 NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT index = ( i + j ) % n NEW_LINE curr_sum += j * arr [ index ] NEW_LINE DEDENT res = max ( res , curr_sum ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def volumeOfEllipsoid ( r1 , r2 , r3 ) : NEW_LINE INDENT pi = 3.14 NEW_LINE return 1.33 * pi * r1 * r2 * r3 NEW_LINE DEDENT
def lcsOf3 ( x , y , z , m , n , o ) : NEW_LINE INDENT L = [ [ 0 for i in range ( o + 1 ) ] for j in range ( m + 1 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT for k in range ( o + 1 ) : NEW_LINE INDENT if ( i == 0 or j == 0 or k == 0 ) : NEW_LINE INDENT L [ i ] [ j ] [ k ] = 0 NEW_LINE DEDENT elif ( x [ i - 1 ] == y [ j - 1 ] and x [ i - 1 ] == Z [ k - 1 ] ) : NEW_LINE INDENT L [ i ] [ j ] [ k ] = L [ i - 1 ] [ j - 1 ] [ k - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] [ k ] = max ( L [ i - 1 ] [ j ] [ k ] , L [ i ] [ j - 1 ] [ k ] ) , L [ i ] [ j ] [ k - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return L [ m ] [ n ] [ o ] NEW_LINE DEDENT
def countEndless ( input , n ) : NEW_LINE INDENT row = [ [ False for x in range ( n ) ] for y in range ( n ) ] NEW_LINE col = [ [ False for x in range ( n ) ] for y in range ( n ) ] NEW_LINE for j in range ( n ) : NEW_LINE INDENT isEndless = 1 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( input [ i ] [ j ] == 0 ) : NEW_LINE INDENT isEndless = 0 NEW_LINE DEDENT col [ i ] [ j ] = isEndless NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT isEndless = 1 NEW_LINE for j in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( input [ i ] [ j ] == 0 ) : NEW_LINE INDENT isEndless = 0 NEW_LINE DEDENT row [ i ] [ j ] = isEndless NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT if ( row [ i ] [ j ] and col [ i ] [ j ] ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def NextFit ( blockSize , m , processSize , n ) : NEW_LINE INDENT allocation = [ - 1 ] * n NEW_LINE j = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT while ( j < m ) : NEW_LINE INDENT if ( blockSize [ j ] >= processSize [ i ] ) : NEW_LINE INDENT allocation [ i ] = j NEW_LINE blockSize [ j ] -= processSize [ i ] NEW_LINE break NEW_LINE DEDENT j = ( j + 1 ) % m NEW_LINE DEDENT DEDENT print ( " \n Process ▁ No . \tProcess ▁ Size\tBlock ▁ no . " ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( " ▁ " , i + 1 , " \t\t " , processSize [ i ] , " \t\t " ) NEW_LINE if ( allocation [ i ] != - 1 ) : NEW_LINE INDENT print ( allocation [ i ] + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ Allocated " ) NEW_LINE DEDENT DEDENT
def lenOfLongestGP ( set , n ) : NEW_LINE INDENT if ( n < 2 ) : NEW_LINE INDENT return n NEW_LINE DEDENT if ( n == 2 ) : NEW_LINE INDENT return ( set [ 1 ] % set [ 0 ] == 0 ) NEW_LINE DEDENT L = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( set [ n - 1 ] % set [ i ] == 0 ) : NEW_LINE INDENT L [ i ] [ n - 1 ] = 2 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ n - 1 ] = 1 NEW_LINE DEDENT DEDENT for j in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT i = j - 1 NEW_LINE k = j + 1 NEW_LINE while ( i >= 0 and k <= n - 1 ) : NEW_LINE INDENT if ( set [ i ] * set [ k ] < set [ j ] * set [ j ] ) : NEW_LINE INDENT if ( set [ i ] * set [ k ] > set [ j ] * set [ j ] ) : NEW_LINE INDENT if ( set [ j ] % set [ i ] == 0 ) : NEW_LINE INDENT L [ i ] [ j ] = 2 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] = 1 NEW_LINE DEDENT DEDENT i = - 1 NEW_LINE DEDENT return llgp NEW_LINE DEDENT
def checkValidity ( a , b , c ) : NEW_LINE INDENT if ( a + b <= c or a + c <= b or b + c <= a ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT
def isDDM ( m , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT sum += abs ( m [ i ] [ j ] ) NEW_LINE DEDENT sum -= abs ( m [ i ] [ i ] ) NEW_LINE if ( abs ( m [ i ] [ i ] ) < sum ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def shortestDist ( graph ) : NEW_LINE INDENT dist = [ None ] * N NEW_LINE dist [ N - 1 ] = 0 NEW_LINE for i in range ( N - 2 , - 1 , - 1 ) : NEW_LINE INDENT dist [ i ] = INF NEW_LINE for j in range ( i , N ) : NEW_LINE INDENT if ( graph [ i ] [ j ] == INF ) : NEW_LINE INDENT continue NEW_LINE DEDENT dist [ i ] = min ( dist [ i ] , graph [ i ] [ j ] + dist [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return dist [ 0 ] NEW_LINE DEDENT
def calculateSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE sum = 1 << n NEW_LINE return ( sum - 1 ) NEW_LINE DEDENT
def kthdigit ( a , b , k ) : NEW_LINE INDENT p = pow ( a , b ) NEW_LINE count = 0 NEW_LINE while ( p > 0 and count < k ) : NEW_LINE INDENT rem = p % 10 NEW_LINE count += 1 NEW_LINE if ( count == k ) : NEW_LINE INDENT return rem NEW_LINE DEDENT p = p // 10 NEW_LINE DEDENT return 0 NEW_LINE DEDENT
def isEven ( n ) : NEW_LINE INDENT return ( not ( n & 1 ) ) NEW_LINE DEDENT
def printPath ( str ) : NEW_LINE INDENT i = 0 NEW_LINE curX = 0 NEW_LINE curY = 0 NEW_LINE while i < len ( str ) : NEW_LINE INDENT nextX = ( ord ( str [ i ] ) - ord ( ' A ' ) ) // 5 NEW_LINE nextY = ( ord ( str [ i ] ) - ord ( ' B ' ) + 1 ) % 5 NEW_LINE while ( curX > nextX ) : NEW_LINE INDENT print ( " Move ▁ Up " , end = " " ) NEW_LINE curX -= 1 NEW_LINE DEDENT while ( curY > nextY ) : NEW_LINE INDENT print ( " Move ▁ Left " , end = " " ) NEW_LINE curY -= 1 NEW_LINE DEDENT while ( curX < nextX ) : NEW_LINE INDENT print ( " Move ▁ Down " , end = " " ) NEW_LINE curX += 1 NEW_LINE DEDENT while ( curY < nextY ) : NEW_LINE INDENT print ( " Move ▁ Right " , end = " " ) NEW_LINE curY += 1 NEW_LINE DEDENT print ( " Press ▁ OK " , end = " " ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT
def checkcircle ( r , R , r1 , x1 , y1 ) : NEW_LINE INDENT dis = math . sqrt ( x1 * x1 + y1 * y1 ) NEW_LINE return ( dis - r1 >= R and dis + r1 <= r ) NEW_LINE DEDENT
def isMinHeap ( level , n ) : NEW_LINE INDENT for i in range ( ( n // 2 - 1 ) , - 1 , - 1 ) : NEW_LINE INDENT if ( level [ i ] > level [ 2 * i + 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( 2 * i + 2 < n ) : NEW_LINE INDENT if ( level [ i ] > level [ 2 * i + 2 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def countSetBits ( n ) : NEW_LINE INDENT i = 0 NEW_LINE ans = 0 NEW_LINE while ( ( 1 << i ) <= n ) : NEW_LINE INDENT k = 0 NEW_LINE change = 1 << i NEW_LINE for j in range ( n + 1 ) : NEW_LINE INDENT ans += k NEW_LINE if ( change == 1 ) : NEW_LINE INDENT k = not k NEW_LINE change = 1 << i NEW_LINE DEDENT else : NEW_LINE INDENT change -= 1 NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def getPairsCount ( arr , n , sum ) : NEW_LINE INDENT m = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT m [ arr [ i ] ] += 1 NEW_LINE DEDENT twice_count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT twice_count += m [ sum - arr [ i ] ] NEW_LINE if sum - arr [ i ] == arr [ i ] : NEW_LINE INDENT twice_count -= 1 NEW_LINE DEDENT DEDENT return twice_count // 2 NEW_LINE DEDENT
def printSorted ( a , b , c ) : NEW_LINE INDENT get_max = max ( a , b , c ) NEW_LINE get_min = - max ( - a , max ( - b , - c ) ) NEW_LINE get_mid = ( a + b + c ) - ( get_max + get_min ) NEW_LINE print ( get_min , " ▁ " , get_mid , " ▁ " , get_max ) NEW_LINE DEDENT
def isDivisible ( n ) : NEW_LINE INDENT while ( n // 100 ) : NEW_LINE INDENT last_digit = n % 10 NEW_LINE n /= 10 NEW_LINE last_digit += 1 NEW_LINE DEDENT return ( n % 29 == 0 ) NEW_LINE DEDENT
def minSumPath ( A ) : NEW_LINE INDENT memo = [ 0 for x in range ( A . size ( ) ) ] NEW_LINE n = len ( A [ n ] ) - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT memo [ i ] = A [ n ] [ i ] NEW_LINE DEDENT for i in range ( 0 , - 2 , - 1 ) : NEW_LINE INDENT for j in range ( 0 , A [ i ] . size ( ) ) : NEW_LINE INDENT memo [ j ] = A [ i ] [ j ] + min ( memo [ j ] , memo [ j + 1 ] ) NEW_LINE DEDENT DEDENT return memo [ 0 ] NEW_LINE DEDENT
def minXOR ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE minXor = 2147483647 NEW_LINE val = 0 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT val = arr [ i ] ^ arr [ i + 1 ] NEW_LINE minXor = min ( minXor , val ) NEW_LINE DEDENT return minXor NEW_LINE DEDENT
def luDecomposition ( mat , n ) : NEW_LINE INDENT lower = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] NEW_LINE upper = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] NEW_LINE for k in range ( i , n ) : NEW_LINE INDENT Sum = 0 NEW_LINE for j in range ( i ) : NEW_LINE INDENT Sum += ( lower [ i ] [ j ] * upper [ j ] [ k ] ) NEW_LINE DEDENT upper [ i ] [ k ] = mat [ i ] [ k ] - Sum NEW_LINE DEDENT DEDENT for k in range ( i , n ) : NEW_LINE INDENT if ( i == k ) : NEW_LINE INDENT lower [ i ] [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT Sum = 0 NEW_LINE for j in range ( i ) : NEW_LINE INDENT Sum += ( lower [ k ] [ j ] * upper [ j ] [ i ] ) NEW_LINE DEDENT lower [ k ] [ i ] = ( mat [ k ] [ i ] - Sum ) / upper [ i ] [ i ] NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT
def findMinSum ( a , b , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE b . sort ( ) NEW_LINE sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum = sum + abs ( a [ i ] - b [ i ] ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
def minDist ( arr , n , x , y ) : NEW_LINE INDENT min_dist = sys . maxsize NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( ( x == arr [ i ] and y == arr [ j ] or y == arr [ i ] and x == arr [ j ] ) and min_dist > abs ( i - j ) ) : NEW_LINE INDENT min_dist = abs ( i - j ) NEW_LINE DEDENT DEDENT DEDENT return min_dist NEW_LINE DEDENT
def findSymPairs ( arr , row ) : NEW_LINE INDENT hM = dict ( ) NEW_LINE for i in range ( row ) : NEW_LINE INDENT first = arr [ i ] [ 0 ] NEW_LINE sec = arr [ i ] [ 1 ] NEW_LINE if ( sec in hM ) : NEW_LINE INDENT print ( " ( " , sec , " , ▁ " , first , " ) " ) NEW_LINE DEDENT else : NEW_LINE INDENT hM [ first ] = sec NEW_LINE DEDENT DEDENT DEDENT
def isValidString ( string ) : NEW_LINE INDENT freq = [ 0 for i in range ( CHARS ) ] NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT freq [ ord ( string [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT i = 0 NEW_LINE count_freq1 = 0 NEW_LINE for i in range ( CHARS ) : NEW_LINE INDENT if ( freq [ i ] != 0 ) : NEW_LINE INDENT freq1 = freq [ i ] NEW_LINE count_freq1 = 1 NEW_LINE break NEW_LINE DEDENT DEDENT j = 0 NEW_LINE count_freq2 = 0 NEW_LINE for j in range ( i + 1 , CHARS ) : NEW_LINE INDENT if ( freq [ j ] != 0 ) : NEW_LINE INDENT if ( freq [ j ] == freq1 ) : NEW_LINE INDENT count_freq1 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_freq2 = 1 NEW_LINE freq2 = freq [ j ] NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT for k in range ( j + 1 , CHARS ) : NEW_LINE INDENT if ( freq [ k ] != 0 ) : NEW_LINE INDENT if ( freq [ k ] == freq1 ) : NEW_LINE INDENT count_freq1 += 1 NEW_LINE DEDENT if ( freq [ k ] == freq2 ) : NEW_LINE INDENT count_freq2 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT if ( count_freq1 > 1 and count_freq2 > 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def maximizecube ( l , b , h ) : NEW_LINE INDENT side = __gcd ( l , b , h ) NEW_LINE num = l / side NEW_LINE num = ( num * b / side ) NEW_LINE num = ( num * h / side ) NEW_LINE print ( side , " ▁ " , num ) NEW_LINE DEDENT
def rotate ( arr , n ) : NEW_LINE INDENT x = arr [ n - 1 ] NEW_LINE i = n - 1 NEW_LINE while i > 0 : NEW_LINE INDENT arr [ i ] = arr [ i - 1 ] NEW_LINE i -= 1 NEW_LINE DEDENT arr [ 0 ] = x NEW_LINE DEDENT
def bonacciseries ( n , m ) : NEW_LINE INDENT a = [ 0 ] * m NEW_LINE a [ n - 1 ] = 1 NEW_LINE a [ n ] = 1 NEW_LINE for i in range ( n + 1 , m ) : NEW_LINE INDENT a [ i ] = 2 * a [ i - 1 ] - a [ i - n - 1 ] NEW_LINE DEDENT for i in range ( 0 , m ) : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def findoptimal ( N ) : NEW_LINE INDENT if N <= 6 : NEW_LINE INDENT return N NEW_LINE DEDENT screen = [ 0 ] * N NEW_LINE for n in range ( 1 , 6 + 1 ) : NEW_LINE INDENT screen [ n - 1 ] = n NEW_LINE DEDENT for n in range ( 7 , N + 1 ) : NEW_LINE INDENT screen [ n - 1 ] = max ( 2 * screen [ n - 4 ] , max ( 3 * screen [ n - 5 ] , 4 * screen [ n - 6 ] ) ) NEW_LINE DEDENT return screen [ N - 1 ] NEW_LINE DEDENT
def fib ( n ) : NEW_LINE INDENT if ( n < 6 ) : NEW_LINE INDENT return f [ n ] NEW_LINE DEDENT t = 5 NEW_LINE fn = 5 NEW_LINE while ( t < n ) : NEW_LINE INDENT fn = round ( fn * PHI ) NEW_LINE t += 1 NEW_LINE DEDENT return fn NEW_LINE DEDENT
def countWays ( arr , m , N ) : NEW_LINE INDENT count = [ 0 for i in range ( N + 1 ) ] NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( i >= arr [ j ] ) : NEW_LINE INDENT count [ i ] += count [ i - arr [ j ] ] NEW_LINE DEDENT DEDENT DEDENT return count [ N ] NEW_LINE DEDENT
def sumOfSeries ( n ) : NEW_LINE INDENT return ( 0.666 ) * ( 1 - 1 / pow ( 10 , n ) ) NEW_LINE DEDENT
def findDivision ( str , a , b ) : NEW_LINE INDENT lenn = len ( str ) NEW_LINE lr = [ 0 for i in range ( lenn ) ] NEW_LINE lr [ 0 ] = ( str [ 0 ] - '0' ) % a NEW_LINE for i in range ( 1 , lenn ) : NEW_LINE INDENT lr [ i ] = ( ( lr [ i - 1 ] * 10 ) % a + ( str [ i ] - '0' ) ) % a NEW_LINE DEDENT rl = [ 0 for i in range ( lenn ) : NEW_LINE INDENT rl [ i ] = ( ( rl [ i - 1 ] * 10 ) % a + ( str [ i ] - '0' ) ) % b NEW_LINE power10 = 10 NEW_LINE for i in range ( lenn ) : NEW_LINE INDENT if ( lr [ i ] != 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( rl [ i + 1 ] == 0 ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE for k in range ( i + 1 , lenn ) : NEW_LINE INDENT print ( str [ k ] , end = " ▁ " ) NEW_LINE for k in range ( i + 1 , lenn ) : NEW_LINE INDENT print ( str [ k ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT
def count ( a , b ) : NEW_LINE INDENT m = len ( a ) NEW_LINE n = len ( b ) NEW_LINE lookup = [ [ 0 for i in range ( n + 1 ) ] for j in range ( m + 1 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT lookup [ 0 ] [ i ] = 0 NEW_LINE DEDENT for i in range ( n + 1 ) : NEW_LINE INDENT lookup [ i ] [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( a [ i - 1 ] == b [ j - 1 ] ) : NEW_LINE INDENT lookup [ i ] [ j ] = lookup [ i - 1 ] [ j - 1 ] + lookup [ i - 1 ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT lookup [ i ] [ j ] = lookup [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return lookup [ m ] [ n ] NEW_LINE DEDENT
def find_extra_element_index ( arrA , arrB , n , m ) : NEW_LINE INDENT extra_element = sum ( arrA , n ) - sum ( arrB , m ) NEW_LINE return indexOf ( arrA , extra_element , n ) NEW_LINE DEDENT
def sumNodes ( l ) : NEW_LINE INDENT leafNodeCount = ( int ) ( math . pow ( 2 , l - 1 ) ) NEW_LINE sumLastLevel = 0 NEW_LINE sumLastLevel = ( leafNodeCount * ( leafNodeCount + 1 ) ) / 2 NEW_LINE sum = sumLastLevel * l NEW_LINE return sum NEW_LINE DEDENT
def check ( degree , n ) : NEW_LINE INDENT deg_sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT deg_sum += degree [ i ] NEW_LINE DEDENT return ( 2 * ( n - 1 ) == deg_sum ) NEW_LINE DEDENT
def findCount ( n , sum ) : NEW_LINE INDENT start = pow ( 10 , n - 1 ) NEW_LINE end = pow ( 10 , n ) - 1 NEW_LINE count = 0 NEW_LINE i = start NEW_LINE while ( i <= end ) : NEW_LINE INDENT cur = 0 NEW_LINE temp = i NEW_LINE while ( temp != 0 ) : NEW_LINE INDENT cur += temp % 10 NEW_LINE temp = int ( temp / 10 ) NEW_LINE DEDENT if ( cur == sum ) : NEW_LINE INDENT count += 1 NEW_LINE i += 9 NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT
def smallest ( x , y , z ) : NEW_LINE INDENT c = 0 NEW_LINE while ( x and y and z ) : NEW_LINE INDENT x -= 1 NEW_LINE y -= 1 NEW_LINE z -= 1 NEW_LINE c += 1 NEW_LINE DEDENT return c NEW_LINE DEDENT
def longLenSub ( arr , n ) : NEW_LINE INDENT um = dict ( ) NEW_LINE longLen = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT len = 0 NEW_LINE if um . get ( arr [ i ] - 1 ) in um . values ( ) : NEW_LINE INDENT len = um . get ( arr [ i ] - 1 ) NEW_LINE DEDENT if um . get ( arr [ i ] + 1 ) in um . values ( ) : NEW_LINE INDENT len = um [ arr [ i ] + 1 ] NEW_LINE DEDENT um [ arr [ i ] ] = len + 1 NEW_LINE if longLen < um [ arr [ i ] ] : NEW_LINE INDENT longLen = um [ arr [ i ] ] NEW_LINE DEDENT DEDENT return longLen NEW_LINE DEDENT
def minOperation ( arr ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( M - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] [ j ] == 0 ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT for k in range ( i + 1 , - 1 ) : NEW_LINE INDENT for h in range ( j + 1 , 1 ) : NEW_LINE INDENT if ( arr [ k ] [ h ] == 1 ) : NEW_LINE INDENT arr [ k ] [ h ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ k ] [ h ] = 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def nextPowerOf2 ( n ) : NEW_LINE INDENT p = 1 NEW_LINE if ( n and not ( n & ( n - 1 ) ) ) : NEW_LINE INDENT return n NEW_LINE DEDENT while ( p < n ) : NEW_LINE INDENT p <<= 1 NEW_LINE DEDENT return p NEW_LINE DEDENT
def numberofways ( n , m ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n + 2 ) ] for j in range ( n + 2 ) ] NEW_LINE for k in range ( n , m + 1 ) : NEW_LINE INDENT for i in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ k ] = dp [ i ] [ k + 1 ] NEW_LINE if i - k >= 0 : NEW_LINE INDENT dp [ i ] [ k ] = ( dp [ i ] [ k ] + dp [ i - k ] [ k ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ n ] [ m ] NEW_LINE DEDENT
def generate_derangement ( N ) : NEW_LINE INDENT S = [ 0 ] * N NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT S [ i ] = i NEW_LINE DEDENT D = [ 0 ] * N + 1 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT D [ i ] = i + 1 NEW_LINE D [ i + 1 ] = i NEW_LINE DEDENT DEDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( i == N and i % N != 0 ) : NEW_LINE INDENT temp = D [ N ] NEW_LINE D [ N ] = D [ N - 1 ] NEW_LINE D [ N - 1 ] = temp NEW_LINE DEDENT else : NEW_LINE INDENT D [ i ] = i + 1 NEW_LINE D [ i + 1 ] = i NEW_LINE DEDENT DEDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT print ( " % d ▁ " , D [ i ] ) NEW_LINE DEDENT print ( " \n " ) NEW_LINE DEDENT DEDENT
def countTriangle ( graph , isDirected ) : NEW_LINE INDENT count_Triangle = 0 NEW_LINE for i in range ( V ) : NEW_LINE INDENT for j in range ( V ) : NEW_LINE INDENT for k in range ( V ) : NEW_LINE INDENT if ( graph [ i ] [ j ] and graph [ j ] [ k ] and graph [ k ] [ i ] ) : NEW_LINE INDENT count_Triangle += 1 NEW_LINE DEDENT DEDENT DEDENT isDirected and count_Triangle /= 3 NEW_LINE DEDENT return count_Triangle NEW_LINE DEDENT
def leonardo ( n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return leonardo ( n - 1 ) + leonardo ( n - 2 ) + 1 NEW_LINE DEDENT
def findLargestPlus ( mat ) : NEW_LINE INDENT global N NEW_LINE left = [ [ 0 for i in range ( N ) ] for j in range ( N ) ] NEW_LINE right = [ [ 0 for i in range ( N ) ] for j in range ( N ) ] NEW_LINE top [ 0 ] [ i ] = mat [ 0 ] [ i ] NEW_LINE bottom [ N - 1 ] [ i ] = mat [ N - 1 ] [ i ] NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( 1 , N ) : NEW_LINE INDENT if ( mat [ i ] [ j ] == 1 ) : NEW_LINE INDENT left [ i ] [ j ] = left [ i ] [ j - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT top [ j ] [ i ] = 0 NEW_LINE DEDENT j = N - 1 - j NEW_LINE if ( mat [ j ] [ i ] == 1 ) : NEW_LINE INDENT bottom [ j ] [ i ] = bottom [ j + 1 ] [ i ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT bottom [ j ] [ i ] = 0 NEW_LINE DEDENT j = N - 1 - j NEW_LINE DEDENT DEDENT n = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT len = min ( min ( top [ i ] [ j ] , bottom [ i ] [ j ] ) , min ( left [ i ] [ j ] , right [ i ] [ j ] ) ) NEW_LINE if ( len > n ) : NEW_LINE INDENT n = len NEW_LINE DEDENT DEDENT DEDENT if ( n ) : NEW_LINE INDENT return 4 * ( n - 1 ) + 1 NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT
def sumAtKthLevel ( tree , k ) : NEW_LINE INDENT level = - 1 NEW_LINE sum = 0 NEW_LINE n = len ( tree ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( tree [ i ] == ' ( ' ) : NEW_LINE INDENT level += 1 NEW_LINE DEDENT elif ( tree [ i ] == ' ( ' ) : NEW_LINE INDENT level -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( level == k ) : NEW_LINE INDENT sum += ( tree [ i ] - '0' ) NEW_LINE DEDENT DEDENT DEDENT return sum NEW_LINE DEDENT
def countWays ( s ) : NEW_LINE INDENT count = [ 0 for x in range ( 26 ) ] NEW_LINE for x in range ( s ) : NEW_LINE INDENT count [ ord ( x ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT count [ ord ( s [ 0 ] ) - ord ( ' a ' ) ] = 1 NEW_LINE ans = 1 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if ( count [ i ] != 0 ) : NEW_LINE INDENT ans = ans * count [ i ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def countWays ( n , m ) : NEW_LINE INDENT count = [ 0 for _ in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if i > m : NEW_LINE INDENT count [ i ] = count [ i - 1 ] + count [ i - m ] NEW_LINE DEDENT elif i < m : NEW_LINE INDENT count [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT count [ i ] = 2 NEW_LINE DEDENT DEDENT return count [ n ] NEW_LINE DEDENT
def printCommonElements ( mat ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for j in range ( N ) : NEW_LINE INDENT mp [ mat [ 0 ] [ j ] ] = 1 NEW_LINE DEDENT for i in range ( 1 , M ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if ( mp [ mat [ i ] [ j ] ] == i ) : NEW_LINE INDENT mp [ mat [ i ] [ j ] ] = i + 1 NEW_LINE if ( i == M - 1 ) : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def nextPowerOf2 ( n ) : NEW_LINE INDENT p = 1 NEW_LINE if ( n and not ( n & ( n - 1 ) ) ) : NEW_LINE INDENT return n NEW_LINE DEDENT while ( p < n ) : NEW_LINE INDENT p <<= 1 NEW_LINE DEDENT return p NEW_LINE DEDENT
def longest ( a , n , k ) : NEW_LINE INDENT freq = dict ( ) NEW_LINE start = 0 NEW_LINE end = 0 NEW_LINE now = 0 l = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ a [ i ] ] += 1 NEW_LINE if freq [ a [ i ] ] == 1 : NEW_LINE INDENT now += 1 NEW_LINE DEDENT while now > k : NEW_LINE INDENT freq [ a [ l ] ] -= 1 NEW_LINE if freq [ a [ l ] ] == 0 : NEW_LINE INDENT now -= 1 NEW_LINE DEDENT l += 1 NEW_LINE DEDENT if i - l + 1 >= end - start + 1 : NEW_LINE INDENT end = i NEW_LINE start = l NEW_LINE DEDENT DEDENT for i in range ( start , end + 1 ) : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def findWays ( m , n , x ) : NEW_LINE INDENT table = [ [ 0 for i in range ( x + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for j in range ( 1 , m + 1 ) : NEW_LINE INDENT table [ 1 ] [ j ] = 1 NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , x + 1 ) : NEW_LINE INDENT table [ i ] [ j ] = 1 NEW_LINE DEDENT for k in range ( 1 , m + 1 ) : NEW_LINE INDENT table [ i ] [ j ] += table [ i - 1 ] [ j - k ] NEW_LINE DEDENT DEDENT return table [ n ] [ x ] NEW_LINE DEDENT
def checkCorrectOrNot ( s ) : NEW_LINE INDENT count = [ 0 ] * MAX_CHAR NEW_LINE n = len ( s ) NEW_LINE if ( n == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT for i in range ( 0 , n - 1 , - 1 ) : NEW_LINE INDENT count [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE count [ ord ( s [ j ] ) - ord ( ' a ' ) ] -= 1 NEW_LINE DEDENT for i in range ( 0 , MAX_CHAR ) : NEW_LINE INDENT if ( count [ i ] != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def findNumberOfTriangles ( arr , n ) : NEW_LINE INDENT arr = sorted ( arr ) NEW_LINE count = 0 NEW_LINE for i in range ( 0 , n - 2 ) : NEW_LINE INDENT k = i + 2 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT while ( k < n and arr [ i ] + arr [ j ] > arr [ k ] ) : NEW_LINE INDENT k += 1 NEW_LINE DEDENT if ( k > j ) : NEW_LINE INDENT count += k - j - 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def countWays ( n ) : NEW_LINE INDENT A = [ 0 ] * ( n + 1 ) NEW_LINE B = [ 0 ] * ( n + 1 ) NEW_LINE A [ 0 ] = 1 NEW_LINE A [ 1 ] = 0 NEW_LINE B [ 0 ] = 0 NEW_LINE B [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT A [ i ] = A [ i - 2 ] + 2 * B [ i - 1 ] NEW_LINE B [ i ] = A [ i - 1 ] + B [ i - 2 ] NEW_LINE DEDENT return A [ n ] NEW_LINE DEDENT
def minValue ( A , B , n ) : NEW_LINE INDENT A . sort ( ) NEW_LINE B . sort ( ) NEW_LINE result = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT result += ( A [ i ] * B [ n - i - 1 ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT
def isOneFlip ( str ) : NEW_LINE INDENT sum = 0 NEW_LINE n = len ( str ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += ord ( str [ i ] ) - ord ( '0' ) NEW_LINE DEDENT return ( sum == n - 1 or sum == 1 ) NEW_LINE DEDENT
def MatrixChainOrder ( p , i , j ) : NEW_LINE INDENT if i == j : NEW_LINE INDENT return 0 NEW_LINE DEDENT k = i NEW_LINE min = 2147483647 NEW_LINE for k in range ( j ) : NEW_LINE INDENT count = ( MatrixChainOrder ( p , i , k ) + MatrixChainOrder ( p , k + 1 , j ) + p [ i - 1 ] * p [ k ] * p [ j ] ) NEW_LINE if ( count < min ) : NEW_LINE INDENT min = count NEW_LINE DEDENT DEDENT return min NEW_LINE DEDENT
def worstFit ( blockSize , m , processSize , n ) : NEW_LINE INDENT allocation = [ - 1 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT wstIdx = - 1 NEW_LINE for j in range ( m ) : NEW_LINE INDENT if ( blockSize [ j ] >= processSize [ i ] ) : NEW_LINE INDENT if ( wstIdx == - 1 ) : NEW_LINE INDENT wstIdx = j NEW_LINE DEDENT elif ( blockSize [ wstIdx ] < blockSize [ j ] ) : NEW_LINE INDENT wstIdx = j NEW_LINE DEDENT DEDENT DEDENT if ( wstIdx != - 1 ) : NEW_LINE INDENT allocation [ i ] = wstIdx NEW_LINE blockSize [ wstIdx ] -= processSize [ i ] NEW_LINE DEDENT DEDENT print ( " Process ▁ No . \tProcess ▁ Size\tBlock ▁ no . " ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( " ▁ " , i + 1 , " \t\t " , processSize [ i ] , " \t\t " , allocation [ i ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ Allocated " ) NEW_LINE DEDENT DEDENT
def prefixSum2D ( a ) : NEW_LINE INDENT psa = [ [ 0 for i in range ( C ) ] for j in range ( R ) ] NEW_LINE for i in range ( 1 , C ) : NEW_LINE INDENT psa [ 0 ] [ i ] = psa [ 0 ] [ i - 1 ] + a [ 0 ] [ i ] NEW_LINE DEDENT for i in range ( 0 , R ) : NEW_LINE INDENT psa [ i ] [ 0 ] = psa [ i - 1 ] [ 0 ] + a [ i ] [ 0 ] NEW_LINE DEDENT for i in range ( 1 , R ) : NEW_LINE INDENT for j in range ( 1 , C ) : NEW_LINE INDENT psa [ i ] [ j ] = psa [ i - 1 ] [ j ] + psa [ i ] [ j - 1 ] - psa [ i - 1 ] [ j - 1 ] + a [ i ] [ j ] NEW_LINE DEDENT DEDENT for i in range ( R ) : NEW_LINE INDENT for j in range ( 0 , C ) : NEW_LINE INDENT print ( psa [ i ] [ j ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT
def isMultipleOf3 ( n ) : NEW_LINE INDENT odd_count = 0 NEW_LINE even_count = 0 NEW_LINE if ( n < 0 ) : NEW_LINE INDENT n = - n NEW_LINE DEDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT while ( n ) : NEW_LINE INDENT if ( n & 1 ) : NEW_LINE INDENT odd_count += 1 NEW_LINE DEDENT if ( n & 2 ) : NEW_LINE INDENT even_count += 1 NEW_LINE DEDENT n = n >> 2 NEW_LINE DEDENT return isMultipleOf3 ( abs ( odd_count - even_count ) ) NEW_LINE DEDENT
def longestSubsequenceCommonSegment ( k , s1 , s2 ) : NEW_LINE INDENT n = len ( s1 ) NEW_LINE m = len ( s2 ) NEW_LINE lcs = [ [ 0 for i in range ( m + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE cnt = [ [ 0 for i in range ( m + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , m + 1 ) : NEW_LINE INDENT lcs [ i ] [ j ] = max ( lcs [ i - 1 ] [ j ] , lcs [ i ] [ j - 1 ] ) NEW_LINE if ( s1 [ i - 1 ] == s2 [ j - 1 ] ) : NEW_LINE INDENT cnt [ i ] [ j ] = cnt [ i - 1 ] [ j - 1 ] + 1 NEW_LINE DEDENT if ( cnt [ i ] [ j ] >= k ) : NEW_LINE INDENT for a in range ( k , cnt [ i ] [ j ] + a ) : NEW_LINE INDENT lcs [ i ] [ j ] = max ( lcs [ i ] [ j ] , lcs [ i - a ] [ j - a ] + a ) NEW_LINE DEDENT DEDENT DEDENT return lcs [ n ] [ m ] NEW_LINE DEDENT
def lcsOf3 ( i , j , k ) : NEW_LINE INDENT if ( i == - 1 or j == - 1 or k == - 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if dp [ i ] [ j ] [ k ] != - 1 : NEW_LINE INDENT return dp [ i ] [ j ] [ k ] NEW_LINE DEDENT if X [ i ] == Y [ j ] and Y [ j ] == Z [ k ] : NEW_LINE INDENT return 1 + lcsOf3 ( i - 1 , j - 1 , k - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return dp [ i ] [ j ] [ k ] = max ( max ( lcsOf3 ( i - 1 , j , k ) , lcsOf3 ( i , j - 1 , k ) ) , lcsOf3 ( i , j , k - 1 ) ) NEW_LINE DEDENT DEDENT
def findLarger ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def maxProductSubset ( a , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return a [ 0 ] NEW_LINE DEDENT max_neg = - 2147483647 NEW_LINE count_neg = 0 NEW_LINE count_zero = 0 NEW_LINE prod = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == 0 ) : NEW_LINE INDENT count_zero += 1 NEW_LINE continue NEW_LINE DEDENT if ( a [ i ] < 0 ) : NEW_LINE INDENT count_neg += 1 NEW_LINE max_neg = max ( max_neg , a [ i ] ) NEW_LINE DEDENT prod = prod * a [ i ] NEW_LINE DEDENT if ( count_zero == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( count_neg & 1 ) : NEW_LINE INDENT if ( count_neg == 1 and count_zero > 0 and count_zero + count_neg == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT prod = prod // max_neg NEW_LINE DEDENT return prod NEW_LINE DEDENT
def russianPeasant ( a , b ) : NEW_LINE INDENT res = 0 NEW_LINE while ( b > 0 ) : NEW_LINE INDENT if ( b & 1 ) : NEW_LINE INDENT res = res + a NEW_LINE DEDENT a = a << 1 NEW_LINE b = b >> 1 NEW_LINE DEDENT return res NEW_LINE DEDENT
def distance ( lat1 , long1 , lat2 , long2 ) : NEW_LINE INDENT lat1 = toRadians ( lat1 ) NEW_LINE long1 = toRadians ( long1 ) NEW_LINE lat2 = toRadians ( lat2 ) NEW_LINE long2 = toRadians ( long2 ) NEW_LINE dlong = long2 - long1 NEW_LINE dlat = lat2 - lat1 NEW_LINE ans = ( pow ( sin ( dlat / 2 ) , 2 ) + cos ( lat1 ) * cos ( lat2 ) * pow ( sin ( dlong / 2 ) , 2 ) ) NEW_LINE ans = 2 * asin ( ans ) ) NEW_LINE R = 6371 NEW_LINE ans = ans * R NEW_LINE return ans NEW_LINE DEDENT
def isPowerOfTwo ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT while ( n != 1 ) : NEW_LINE INDENT if ( n % 2 != 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT n = n // 2 NEW_LINE DEDENT return 1 NEW_LINE DEDENT
def checkPoint ( radius , x , y , percent , startAngle ) : NEW_LINE INDENT endAngle = 360 / percent + startAngle NEW_LINE polarradius = math . sqrt ( x * x + y * y ) NEW_LINE Angle = atan ( y / x ) NEW_LINE if ( Angle >= startAngle and Angle <= endAngle and polarradius < radius ) : NEW_LINE INDENT print ( " Point ▁ ( % d , ▁ % d ) ▁ exist ▁ in ▁ the ▁ circle ▁ sector " , x , y ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Point ▁ ( % d , ▁ % d ) ▁ does ▁ not ▁ exist " , x , y ) NEW_LINE DEDENT DEDENT
def findSum ( n ) : NEW_LINE INDENT arr = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT arr [ i ] [ j ] = abs ( i - j ) NEW_LINE DEDENT DEDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT sum += arr [ i ] [ j ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def discreteLogarithm ( a , b , m ) : NEW_LINE INDENT n = ( int ) ( math . sqrt ( m ) + 1 ) NEW_LINE an = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT an = ( an * a ) % m NEW_LINE DEDENT value = dict ( ) NEW_LINE for cur in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( value [ cur ] == 0 ) : NEW_LINE INDENT value [ cur ] = i NEW_LINE DEDENT cur = ( cur * an ) % m NEW_LINE DEDENT for i in range ( 1 , b + 1 ) : NEW_LINE INDENT if ( value [ cur ] == 0 ) : NEW_LINE INDENT ans = value [ cur ] * n - i NEW_LINE if ( ans < m ) : NEW_LINE INDENT return ans NEW_LINE DEDENT DEDENT cur = ( cur * a ) % m NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def isPossibleTriangle ( arr , N ) : NEW_LINE INDENT if ( N < 3 ) : NEW_LINE INDENT return False NEW_LINE DEDENT arr . sort ( ) NEW_LINE for i in range ( 0 , N - 2 ) : NEW_LINE INDENT if ( arr [ i ] + arr [ i + 1 ] > arr [ i + 2 ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT
def numOfIncSubseqOfSizeK ( arr , n , k ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( k ) ] for j in range ( n ) ] NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp [ 0 ] [ i ] = 1 NEW_LINE DEDENT for l in range ( 1 , k ) : NEW_LINE INDENT for i in range ( l ) : NEW_LINE INDENT dp [ l ] [ i ] = 0 NEW_LINE for j in range ( l - 1 , i ) : NEW_LINE INDENT if ( arr [ j ] < arr [ i ] ) : NEW_LINE INDENT dp [ l ] [ i ] += dp [ l - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT sum += dp [ n ] [ i ] NEW_LINE DEDENT return sum NEW_LINE DEDENT
def solve ( X , Y , l , r , k , dp ) : NEW_LINE INDENT if ( k == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( l < 0 | r < 0 ) : NEW_LINE INDENT return 1e9 NEW_LINE DEDENT if ( dp [ l ] [ r ] [ k ] != - 1 ) : NEW_LINE INDENT return dp [ l ] [ r ] [ k ] NEW_LINE DEDENT cost = ( X [ l ] - ord ( ' a ' ) ) ^ ( Y [ r ] - ord ( ' a ' ) ) NEW_LINE return dp [ l ] [ r ] [ k ] = min ( { cost + solve ( X , Y , l - 1 , r - 1 , k - 1 , dp ) , solve ( X , Y , l - 1 , r , k , dp ) } ) NEW_LINE DEDENT
def isSubSequence ( str1 , str2 , m , n ) : NEW_LINE INDENT if m == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT if n == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT if str1 [ m - 1 ] == str2 [ n - 1 ] : NEW_LINE INDENT return isSubSequence ( str1 , str2 , m - 1 , n - 1 ) NEW_LINE DEDENT return isSubSequence ( str1 , str2 , m , n - 1 ) NEW_LINE DEDENT
def minProductSubset ( a , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return a [ 0 ] NEW_LINE DEDENT max_neg = - 2147483647 NEW_LINE min_pos = 2147483647 NEW_LINE count_neg = 0 NEW_LINE count_zero = 0 NEW_LINE prod = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == 0 ) : NEW_LINE INDENT count_zero += 1 NEW_LINE continue NEW_LINE DEDENT if ( a [ i ] < 0 ) : NEW_LINE INDENT count_neg += 1 NEW_LINE max_neg = max ( max_neg , a [ i ] ) NEW_LINE DEDENT if ( a [ i ] > 0 ) : NEW_LINE INDENT min_pos = min ( min_pos , a [ i ] ) NEW_LINE DEDENT prod = prod * a [ i ] NEW_LINE DEDENT if ( count_zero == n or ( count_neg == 0 and count_zero > 0 ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( count_neg == 0 ) : NEW_LINE INDENT return min_pos NEW_LINE DEDENT if ( count_neg & 1 ) and count_neg != 0 ) : NEW_LINE INDENT prod = prod // max_neg NEW_LINE DEDENT return prod NEW_LINE DEDENT
def findDigits ( n ) : NEW_LINE INDENT if ( n < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n <= 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT digits = 0 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT digits += math . log10 ( i ) NEW_LINE DEDENT return math . floor ( digits ) + 1 NEW_LINE DEDENT
def mergeTwoHalf ( A , n ) : NEW_LINE INDENT A . sort ( ) NEW_LINE DEDENT
def minPerimeter ( n ) : NEW_LINE INDENT l = math . sqrt ( n ) NEW_LINE sq = l * l NEW_LINE if ( sq == n ) : NEW_LINE INDENT return l * 4 NEW_LINE DEDENT else : NEW_LINE INDENT row = n // l NEW_LINE perimeter = 2 * ( l + row ) NEW_LINE if ( n % l != 0 ) : NEW_LINE INDENT perimeter += 2 NEW_LINE DEDENT return perimeter NEW_LINE DEDENT
def possibleOrNot ( a1 , a2 , b1 , b2 , c1 , c2 ) : NEW_LINE INDENT dis1 = pow ( b1 - a1 , 2 ) + pow ( b2 - a2 , 2 ) NEW_LINE dis2 = pow ( c1 - b1 , 2 ) + pow ( c2 - b2 , 2 ) NEW_LINE if ( dis1 != dis2 ) : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT elif ( b1 == ( ( a1 + c1 ) // 2.0 ) and b2 == ( ( a2 + c2 ) // 2.0 ) ) : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT DEDENT
def countSquares ( a , b ) : NEW_LINE INDENT return ( floor ( math . sqrt ( b ) ) - ceil ( math . sqrt ( a ) ) + 1 ) NEW_LINE DEDENT
def countStrings ( n , k ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( k + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT dp [ i ] [ j ] = [ 0 for i in range ( k + 1 ) ] NEW_LINE dp [ i ] [ j ] [ 0 ] = 1 NEW_LINE dp [ i ] [ j ] [ 1 ] = 1 NEW_LINE DEDENT DEDENT DEDENT return dp [ n ] [ k ] [ 0 ] + dp [ n ] [ k ] [ 1 ] NEW_LINE DEDENT
def findSmallestRange ( arr , n , k ) : NEW_LINE INDENT ptr = [ 0 ] * k NEW_LINE minval = 10 ** 9 NEW_LINE maxval = 10 ** 9 NEW_LINE flag = 0 NEW_LINE for i in range ( k + 1 ) : NEW_LINE INDENT if ptr [ i ] == n : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT if ptr [ i ] < n and arr [ i ] [ ptr [ i ] ] < minval : NEW_LINE INDENT minind = i NEW_LINE minval = arr [ i ] [ ptr [ i ] ] NEW_LINE DEDENT if ptr [ i ] < n and arr [ i ] [ ptr [ i ] ] > maxval : NEW_LINE INDENT maxval = arr [ i ] [ ptr [ i ] ] NEW_LINE DEDENT DEDENT if flag == 0 : NEW_LINE INDENT break NEW_LINE DEDENT ptr [ minind ] += 1 NEW_LINE if ( ( maxval - minval ) < minrange ) : NEW_LINE INDENT minel = minval NEW_LINE maxel = maxval NEW_LINE minrange = maxel - minel NEW_LINE DEDENT DEDENT print ( " The ▁ smallest ▁ range ▁ is " , minel , maxel ) NEW_LINE DEDENT
def maxelement ( no_of_rows , arr ) : NEW_LINE INDENT i = 0 NEW_LINE max = 0 NEW_LINE result = [ 0 ] * no_of_rows NEW_LINE for i in range ( no_of_rows ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if ( arr [ i ] [ j ] > max ) : NEW_LINE INDENT max = arr [ i ] [ j ] NEW_LINE DEDENT DEDENT result [ i ] = max NEW_LINE max = 0 NEW_LINE i += 1 NEW_LINE DEDENT printArray ( result , no_of_rows ) NEW_LINE DEDENT
def yMod ( y , x ) : NEW_LINE INDENT if ( math . log2 ( y ) < x ) : NEW_LINE INDENT return y NEW_LINE DEDENT if ( math . log2 ( y ) > x ) : NEW_LINE INDENT return y NEW_LINE DEDENT if ( x > 63 ) : NEW_LINE INDENT return y NEW_LINE DEDENT return ( y % ( 1 << x ) ) NEW_LINE DEDENT
def findthepath ( S , v ) : NEW_LINE INDENT result = [ None ] * 10 NEW_LINE for i in range ( 1 , len ( S ) ) : NEW_LINE INDENT if ( adj [ v ] [ S [ i ] - ' A ' ] or adj [ S [ i ] - ' A ' ] [ v ] ) : NEW_LINE INDENT v = S [ i ] - ' A ' NEW_LINE DEDENT elif ( adj [ v ] [ S [ i ] - ' A ' + 5 ] or adj [ S [ i ] - ' A ' + 5 ] [ v ] ) : NEW_LINE INDENT v = S [ i ] - ' A ' + 5 NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT result [ i ] = v + '0' NEW_LINE DEDENT return True NEW_LINE DEDENT
def getMissingNo ( a , n ) : NEW_LINE INDENT total = ( n + 1 ) * ( n + 2 ) / 2 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT total -= a [ i ] NEW_LINE DEDENT return total NEW_LINE DEDENT
def fitOrNotFit ( R , r , x , y , rad ) : NEW_LINE INDENT val = math . sqrt ( pow ( x , 2 ) + pow ( y , 2 ) ) NEW_LINE if ( val + rad <= R and val - rad >= R - r ) : NEW_LINE INDENT print ( " Fits " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Doesn ' t ▁ Fit " ) NEW_LINE DEDENT DEDENT
def findPosition ( k , n ) : NEW_LINE INDENT f1 = 0 NEW_LINE f2 = 1 NEW_LINE f3 = 0 NEW_LINE while ( 2 <= MAX ) : NEW_LINE INDENT f3 = f1 + f2 NEW_LINE f1 = f2 NEW_LINE f2 = f3 NEW_LINE if ( f2 % k == 0 ) : NEW_LINE INDENT return n * i NEW_LINE DEDENT DEDENT DEDENT
def countManipulations ( s1 , s2 ) : NEW_LINE INDENT count = 0 NEW_LINE char_count = [ 0 ] * 26 NEW_LINE for i in range ( 0 , 26 ) : NEW_LINE INDENT char_count [ i ] = 0 NEW_LINE DEDENT for i in range ( len ( s1 ) ) : NEW_LINE INDENT char_count [ ord ( s1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( len ( s2 ) ) : NEW_LINE INDENT char_count [ ord ( s2 [ i ] ) - ord ( ' a ' ) ] -= 1 NEW_LINE if ( char_count [ ord ( s2 [ i ] ) - ord ( ' a ' ) ] < 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def count ( n ) : NEW_LINE INDENT table = [ 0 for j in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT table [ i ] = 0 NEW_LINE DEDENT for i in range ( 3 , n + 1 ) : NEW_LINE INDENT table [ i ] = table [ i - 3 ] NEW_LINE DEDENT for i in range ( 5 , n + 1 ) : NEW_LINE INDENT table [ i ] += table [ i - 5 ] NEW_LINE DEDENT for i in range ( 10 , n + 1 ) : NEW_LINE INDENT table [ i ] += table [ i - 10 ] NEW_LINE DEDENT return table [ n ] NEW_LINE DEDENT
def findLongestRepeatingSubSeq ( str1 ) : NEW_LINE INDENT n = len ( str1 ) NEW_LINE dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( str1 [ i - 1 ] == str1 [ j - 1 ] and i != j ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ n ] [ n ] NEW_LINE DEDENT
def jumpSearch ( arr , x , n ) : NEW_LINE INDENT step = math . sqrt ( n ) NEW_LINE prev = 0 NEW_LINE while ( arr [ min ( step , n ) - 1 ] < x ) : NEW_LINE INDENT prev = step NEW_LINE step += math . sqrt ( n ) NEW_LINE if ( prev >= n ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT while ( arr [ prev ] < x ) : NEW_LINE INDENT prev += 1 NEW_LINE if ( prev == min ( step , n ) ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT if ( arr [ prev ] == x ) : NEW_LINE INDENT return prev NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def find ( arr ) : NEW_LINE INDENT i = 0 NEW_LINE j = n - 1 NEW_LINE res = - 1 NEW_LINE while i < n and j >= 0 : NEW_LINE INDENT if arr [ i ] [ j ] == 0 : NEW_LINE INDENT while j >= 0 and ( arr [ i ] [ j ] == 0 or i == j ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT if j == - 1 : NEW_LINE INDENT res = i NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT while i < n and ( arr [ i ] [ j ] == 1 or i == j ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT if i == n : NEW_LINE INDENT res = j NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT DEDENT if res == - 1 : NEW_LINE INDENT return res NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if res != i and arr [ i ] [ res ] != 1 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT for j in range ( 0 , n ) : NEW_LINE INDENT if res != j and arr [ res ] [ j ] != 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def printArray ( a , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE return NEW_LINE DEDENT
def sortSquares ( arr , n ) : NEW_LINE INDENT K = 0 NEW_LINE for K in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ K ] >= 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT i = K - 1 NEW_LINE j = K NEW_LINE ind = 0 NEW_LINE temp = [ 0 ] * ( n + 1 ) NEW_LINE while ( i >= 0 and j < n ) : NEW_LINE INDENT if ( arr [ i ] * arr [ i ] < arr [ j ] * arr [ j ] ) : NEW_LINE INDENT temp [ ind ] = arr [ i ] * arr [ i ] NEW_LINE i -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT temp [ ind ] = arr [ j ] * arr [ j ] NEW_LINE j += 1 NEW_LINE DEDENT ind += 1 NEW_LINE DEDENT while ( i >= 0 ) : NEW_LINE INDENT temp [ ind ] = arr [ i ] * arr [ i ] NEW_LINE i -= 1 NEW_LINE ind += 1 NEW_LINE DEDENT while ( j < n ) : NEW_LINE INDENT temp [ ind ] = arr [ j ] * arr [ j ] NEW_LINE j += 1 NEW_LINE ind += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = temp [ i ] NEW_LINE DEDENT DEDENT
def find_maximum ( a , n , k ) : NEW_LINE INDENT b = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = a [ i ] NEW_LINE d = min ( 1 + i , n - i ) NEW_LINE if ( b . get ( x ) == b . end ( ) ) : NEW_LINE INDENT b [ x ] = d NEW_LINE DEDENT else : NEW_LINE INDENT b [ x ] = min ( d , b [ x ] ) NEW_LINE DEDENT DEDENT ans = 2147483647 NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = a [ i ] NEW_LINE if ( x != k - x and b . get ( k - x ) == b . get ( ) ) : NEW_LINE INDENT ans = min ( max ( b [ x ] , b [ k - x ] ) , ans ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def maxRepeating ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE count = 0 NEW_LINE res = str [ 0 ] NEW_LINE cur_count = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i < n - 1 and str [ i ] == str [ i + 1 ] ) : NEW_LINE INDENT cur_count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( cur_count > count ) : NEW_LINE INDENT count = cur_count NEW_LINE res = str [ i ] NEW_LINE DEDENT cur_count = 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def snoob ( x ) : NEW_LINE INDENT rightOne = x & - ( signed ) x NEW_LINE nextHigherOneBit = x + rightOne NEW_LINE rightOnesPattern = x ^ nextHigherOneBit NEW_LINE next = nextHigherOneBit | rightOnesPattern NEW_LINE DEDENT return next NEW_LINE DEDENT
def isInorder ( arr , n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i - 1 ] > arr [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def lis ( arr , n ) : NEW_LINE INDENT max = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT max = max + 1 NEW_LINE DEDENT _lis ( arr , n , & max ) NEW_LINE return max NEW_LINE DEDENT
def nCrModp ( n , r , p ) : NEW_LINE INDENT C = [ 0 for i in range ( r + 1 ) ] NEW_LINE C [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( min ( i , r + 1 ) ) : NEW_LINE INDENT C [ j ] = ( C [ j ] + C [ j - 1 ] ) % p NEW_LINE DEDENT DEDENT return C [ r ] NEW_LINE DEDENT
def binarySearch ( arr , l , r , x ) : NEW_LINE INDENT while ( l <= r ) : NEW_LINE INDENT m = l + ( r - l ) // 2 NEW_LINE if ( arr [ m ] == x ) : NEW_LINE INDENT return m NEW_LINE DEDENT if ( arr [ m ] < x ) : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT else : NEW_LINE INDENT r = m - 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def minXOR ( arr , n ) : NEW_LINE INDENT min_xor = + 2147483647 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT min_xor = min ( min_xor , arr [ i ] ^ arr [ j ] ) NEW_LINE DEDENT DEDENT return min_xor NEW_LINE DEDENT
def rearrange ( arr , n ) : NEW_LINE INDENT temp = [ 0 ] * n NEW_LINE small = 0 NEW_LINE large = n - 1 NEW_LINE flag = True NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( flag ) : NEW_LINE INDENT temp [ i ] = arr [ large -= 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT temp [ i ] = arr [ small ] NEW_LINE DEDENT flag = not flag NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT arr [ i ] = temp [ i ] NEW_LINE DEDENT DEDENT
def LCSubStr ( X , Y , m , n ) : NEW_LINE INDENT LCSuff = [ [ 0 for i in range ( n + 1 ) ] for j in range ( m + 1 ) ] NEW_LINE result = 0 NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if ( i == 0 or j == 0 ) : NEW_LINE INDENT LCSuff [ i ] [ j ] = 0 NEW_LINE DEDENT elif ( X [ i - 1 ] == Y [ j - 1 ] ) : NEW_LINE INDENT LCSuff [ i ] [ j ] = LCSuff [ i - 1 ] [ j - 1 ] + 1 NEW_LINE result = max ( result , LCSuff [ i ] [ j ] ) NEW_LINE DEDENT else : NEW_LINE INDENT LCSuff [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
def patternCount ( str ) : NEW_LINE INDENT last = str [ 0 ] NEW_LINE i = 1 NEW_LINE counter = 0 NEW_LINE while ( i < len ( str ) ) : NEW_LINE INDENT if ( str [ i ] == '0' and last == '1' ) : NEW_LINE INDENT while ( str [ i ] == '0' ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT if ( str [ i ] == '1' ) : NEW_LINE INDENT counter += 1 NEW_LINE DEDENT DEDENT last = str [ i ] NEW_LINE i += 1 NEW_LINE DEDENT return counter NEW_LINE DEDENT
def longestSubseqWithK ( str , k ) : NEW_LINE INDENT n = len ( str ) NEW_LINE freq = [ 0 for i in range ( MAX_CHARS ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] >= k ) : NEW_LINE INDENT print ( str [ i ] , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def nextPowerOf2 ( n ) : NEW_LINE INDENT count = 0 NEW_LINE if ( n and not ( n & ( n - 1 ) ) ) : NEW_LINE INDENT return n NEW_LINE DEDENT while ( n != 0 ) : NEW_LINE INDENT n >>= 1 NEW_LINE count += 1 NEW_LINE DEDENT return 1 << count NEW_LINE DEDENT
def isPowerOfTwo ( x ) : NEW_LINE INDENT return x and ( not ( x & ( x - 1 ) ) ) NEW_LINE DEDENT
def decToBinary ( n ) : NEW_LINE INDENT binaryNum = [ 0 ] * 32 NEW_LINE i = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT binaryNum [ i ] = n % 2 NEW_LINE n = int ( n / 2 ) NEW_LINE i += 1 NEW_LINE DEDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( binaryNum [ j ] , end = " " ) NEW_LINE DEDENT DEDENT
def maximumSumSubarray ( arr , n ) : NEW_LINE INDENT min_prefix_sum = 0 NEW_LINE res = - float ( ' inf ' ) NEW_LINE prefix_sum = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT prefix_sum [ i ] = prefix_sum [ i - 1 ] + arr [ i ] NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT res = max ( res , prefix_sum [ i ] - min_prefix_sum ) NEW_LINE min_prefix_sum = min ( min_prefix_sum , prefix_sum [ i ] ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def countOccurrences ( s , K ) : NEW_LINE INDENT n = len ( s ) NEW_LINE C = 0 NEW_LINE c1 = 0 NEW_LINE c2 = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( s [ i ] == ' a ' ) : NEW_LINE INDENT c1 += 1 NEW_LINE DEDENT if ( s [ i ] == ' b ' ) : NEW_LINE INDENT c2 += 1 NEW_LINE DEDENT C += c1 NEW_LINE DEDENT DEDENT return C * K + ( K * ( K - 1 ) // 2 ) * c1 * c2 NEW_LINE DEDENT
def checkDivisibility ( num ) : NEW_LINE INDENT length = len ( num ) NEW_LINE if ( length == 1 and num [ 0 ] == '0' ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( length % 3 == 1 ) : NEW_LINE INDENT num += "00" NEW_LINE length += 2 NEW_LINE DEDENT elif ( length % 3 == 2 ) : NEW_LINE INDENT num += "0" NEW_LINE length += 1 NEW_LINE DEDENT sum = 0 NEW_LINE p = 1 NEW_LINE for i in range ( length - 1 , - 1 , - 1 ) : NEW_LINE INDENT group = 0 NEW_LINE group += ( num [ i ] - '0' ) * 10 NEW_LINE group += ( num [ i ] - '0' ) * 100 NEW_LINE sum = sum + group * p NEW_LINE p = p * ( - 1 ) NEW_LINE DEDENT sum = abs ( sum ) NEW_LINE return ( sum % 13 == 0 ) NEW_LINE DEDENT
def countSetBits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT n &= ( n - 1 ) NEW_LINE count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def lenOfLongSubarr ( arr , n ) : NEW_LINE INDENT um = dict ( ) NEW_LINE Sum = 0 NEW_LINE maxLen = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT Sum += arr [ i ] == 0 ? - 1 : 1 NEW_LINE if Sum == 1 : NEW_LINE INDENT maxLen = i + 1 NEW_LINE DEDENT elif Sum in um : NEW_LINE INDENT um [ Sum ] = i NEW_LINE DEDENT if ( Sum - 1 ) in um : NEW_LINE INDENT if ( maxLen < ( i - um [ Sum - 1 ] ) ) : NEW_LINE INDENT maxLen = i - um [ Sum - 1 ] NEW_LINE DEDENT DEDENT DEDENT return maxLen NEW_LINE DEDENT
def minJumps ( arr , n ) : NEW_LINE INDENT if ( n == 1 ) : return 0 NEW_LINE res = 2147483647 NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( i + arr [ i ] >= n - 1 ) : NEW_LINE INDENT sub_res = minJumps ( arr , i + 1 ) NEW_LINE if ( sub_res != INT_MAX ) : NEW_LINE INDENT res = min ( res , sub_res + 1 ) NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT
def minTimeForWritingChars ( N , insert , remove , copy ) : NEW_LINE INDENT if N == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if N == 1 : NEW_LINE INDENT return insert NEW_LINE DEDENT dp = [ 0 for i in range ( N + 1 ) ] NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT dp [ i ] = min ( dp [ i - 1 ] + insert , dp [ i // 2 ] + copy ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] = min ( dp [ i - 1 ] + insert , dp [ ( i + 1 ) // 2 ] + copy + remove ) NEW_LINE DEDENT DEDENT return dp [ N ] NEW_LINE DEDENT
def carveCross ( str1 ) : NEW_LINE INDENT n = len ( str1 ) NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT print ( " Not ▁ possible . ▁ Please ▁ enter ▁ " , " odd ▁ length ▁ string . " ) NEW_LINE DEDENT else : NEW_LINE INDENT arr = [ [ 0 for i in range ( max ) ] for j in range ( n ) ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] [ m ] = str1 [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ m ] [ i ] = str1 [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT print ( arr [ i ] [ j ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT
def MaximumDecimalValue ( mat , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] NEW_LINE if ( mat [ 0 ] [ 0 ] == 1 ) : NEW_LINE INDENT dp [ 0 ] [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( mat [ 0 ] [ i ] == 1 ) : NEW_LINE INDENT dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + pow ( 2 , i ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] NEW_LINE DEDENT DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT if ( mat [ i ] [ j ] == 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) + pow ( 2 , i + j ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ n - 1 ] [ n - 1 ] NEW_LINE DEDENT
def findRepeating ( arr , n ) : NEW_LINE INDENT missingElement = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT element = arr [ abs ( arr [ i ] ) ] NEW_LINE if ( element < 0 ) : NEW_LINE INDENT missingElement = arr [ i ] NEW_LINE break NEW_LINE DEDENT arr [ abs ( arr [ i ] ) ] = - arr [ abs ( arr [ i ] ) ] NEW_LINE DEDENT return abs ( missingElement ) NEW_LINE DEDENT
def isPowerOfFour ( n ) : NEW_LINE INDENT return ( n != 0 and ( ( n & ( n - 1 ) ) == 0 ) and not ( n & 0xAAAAAAAA ) ) NEW_LINE DEDENT
def decToBinary ( n ) : NEW_LINE INDENT for i in range ( 31 ) : NEW_LINE INDENT k = n >> i NEW_LINE if ( k & 1 ) : NEW_LINE INDENT print ( "1" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "0" ) NEW_LINE DEDENT DEDENT DEDENT
def countSubstrs ( str , i , j , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT res = ( countSubstrs ( str , i + 1 , j , n - 1 ) + countSubstrs ( str , i , j - 1 , n - 1 ) - countSubstrs ( str , i + 1 , j - 1 , n - 2 ) ) NEW_LINE if ( str [ i ] == str [ j ] ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT
def minRotation ( input , unlock_code ) : NEW_LINE INDENT rotation = 0 NEW_LINE input_digit = input % 10 NEW_LINE code_digit = unlock_code % 10 NEW_LINE rotation += min ( abs ( input_digit - code_digit ) , 10 - abs ( input_digit - code_digit ) ) NEW_LINE input /= 10 NEW_LINE unlock_code /= 10 NEW_LINE DEDENT return rotation NEW_LINE DEDENT
def checkMarkov ( mat , n , m ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT sum = sum + mat [ i ] [ j ] NEW_LINE DEDENT if ( sum != 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def areConsecutive ( arr , n ) : NEW_LINE INDENT if ( n < 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT min = getMin ( arr , n ) NEW_LINE max = getMax ( arr , n ) NEW_LINE if ( max - min + 1 == n ) : NEW_LINE INDENT visited = [ False ] * ( n + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( visited [ arr [ i ] - min ] != False ) : NEW_LINE INDENT return False NEW_LINE DEDENT visited [ arr [ i ] - min ] = True NEW_LINE DEDENT return True NEW_LINE DEDENT
def findMod ( a , b ) : NEW_LINE INDENT if a < 0 : NEW_LINE INDENT mod = - a NEW_LINE DEDENT else : NEW_LINE INDENT mod = a NEW_LINE DEDENT if b < 0 : NEW_LINE INDENT b = - b NEW_LINE while mod >= b : NEW_LINE INDENT mod = mod - b NEW_LINE DEDENT if a < 0 : NEW_LINE INDENT return - mod NEW_LINE DEDENT return mod NEW_LINE DEDENT
def sumOfSubstrings ( num ) : NEW_LINE INDENT n = len ( num ) NEW_LINE sumofdigit = [ 0 for i in range ( n ) ] NEW_LINE sumofdigit [ 0 ] = toDigit ( num [ 0 ] ) NEW_LINE res = sumofdigit [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT numi = ord ( num [ i ] ) NEW_LINE sumofdigit [ i ] = ( i + 1 ) * numi + 10 * sumofdigit [ i - 1 ] NEW_LINE res += sumofdigit [ i ] NEW_LINE DEDENT return res NEW_LINE DEDENT
def findGreatest ( arr , n ) : NEW_LINE INDENT m = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT m [ arr [ i ] ] = 1 NEW_LINE DEDENT arr . sort ( ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ j ] <= math . sqrt ( arr [ i ] ) ) : NEW_LINE INDENT result = arr [ i ] // arr [ j ] NEW_LINE if ( result != arr [ j ] and m [ result ] > 0 ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT elif ( result == arr [ j ] and m [ result ] > 1 ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT DEDENT DEDENT return - 1 NEW_LINE DEDENT
def getMissingNo ( a , n ) : NEW_LINE INDENT total = 1 NEW_LINE for i in range ( 2 , ( n + 1 ) + 1 ) : NEW_LINE INDENT total += i NEW_LINE total -= a [ i - 2 ] NEW_LINE DEDENT return total NEW_LINE DEDENT
def nextPowerOf2 ( n ) : NEW_LINE INDENT n -= 1 NEW_LINE n |= n >> 1 NEW_LINE n |= n >> 2 NEW_LINE n |= n >> 4 NEW_LINE n |= n >> 8 NEW_LINE n |= n >> 16 NEW_LINE n += 1 NEW_LINE return n NEW_LINE DEDENT
def zigzag ( n , k ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( k + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ i - j ] NEW_LINE DEDENT DEDENT return dp [ n ] [ k ] NEW_LINE DEDENT
def maximumDifferenceSum ( arr , N ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( N ) ] for j in range ( 2 ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i ] [ 1 ] = 0 NEW_LINE DEDENT for i in range ( ( N - 1 ) ) : NEW_LINE INDENT dp [ i + 1 ] [ 0 ] = max ( dp [ i ] [ 0 ] , dp [ i ] [ 1 ] + abs ( 1 - arr [ i ] ) ) NEW_LINE dp [ i + 1 ] [ 1 ] = max ( dp [ i ] [ 0 ] + abs ( arr [ i + 1 ] - 1 ) , dp [ i ] [ 1 ] + abs ( arr [ i + 1 ] - arr [ i ] ) ) NEW_LINE DEDENT DEDENT return max ( dp [ N - 1 ] [ 0 ] , dp [ N - 1 ] [ 1 ] ) NEW_LINE DEDENT
def isMultipleOf10 ( n ) : NEW_LINE INDENT return ( n % 15 == 0 ) NEW_LINE DEDENT
def maxProduct ( arr , n ) : NEW_LINE INDENT if ( n < 3 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT arr . sort ( ) NEW_LINE return max ( arr [ 0 ] * arr [ 1 ] * arr [ n - 1 ] , arr [ n - 1 ] * arr [ n - 2 ] * arr [ n - 3 ] ) NEW_LINE DEDENT
def nextPowerOf2 ( n ) : NEW_LINE INDENT n -= 1 NEW_LINE n |= n >> 1 NEW_LINE n |= n >> 2 NEW_LINE n |= n >> 4 NEW_LINE n |= n >> 8 NEW_LINE n |= n >> 16 NEW_LINE n += 1 NEW_LINE return n NEW_LINE DEDENT
def findMaxValue ( arr , n ) : NEW_LINE INDENT if ( n < 4 ) : NEW_LINE INDENT print ( " The ▁ array ▁ should ▁ have ▁ atlest ▁ 4 ▁ elements " ) NEW_LINE return MIN NEW_LINE DEDENT table1 = [ 0 ] * ( n + 1 ) NEW_LINE table2 = [ 0 ] * ( n + 1 ) NEW_LINE table3 = [ 0 ] * ( n - 2 ) NEW_LINE table4 = [ 0 ] * ( n - 3 ) NEW_LINE for i in range ( n - 4 ) : NEW_LINE INDENT table4 [ i ] = max ( table4 [ i + 1 ] , table3 [ i + 1 ] - arr [ i ] ) NEW_LINE DEDENT for i in range ( n - 2 ) : NEW_LINE INDENT table2 [ i ] = max ( table2 [ i + 1 ] , table1 [ i + 1 ] - arr [ i ] ) NEW_LINE DEDENT for i in range ( n - 3 ) : NEW_LINE INDENT table3 [ i ] = max ( table3 [ i + 1 ] , table2 [ i + 1 ] + arr [ i ] ) NEW_LINE DEDENT DEDENT return table4 [ 0 ] NEW_LINE DEDENT
def findMaxGCD ( arr , n ) : NEW_LINE INDENT high = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT high = max ( high , arr [ i ] ) NEW_LINE DEDENT count = [ 0 for i in range ( high + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT count [ arr [ i ] ] += 1 NEW_LINE DEDENT counter = 0 NEW_LINE for i in range ( high + 1 ) : NEW_LINE INDENT counter += 1 NEW_LINE DEDENT for i in range ( high + 1 ) : NEW_LINE INDENT j = i NEW_LINE counter = 0 NEW_LINE while ( j <= high ) : NEW_LINE INDENT if ( count [ j ] >= 2 ) : NEW_LINE INDENT return j NEW_LINE DEDENT elif ( count [ j ] == 1 ) : NEW_LINE INDENT counter += 1 NEW_LINE DEDENT j += i NEW_LINE DEDENT if ( counter == 2 ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT DEDENT
def smallestSubsegment ( a , n ) : NEW_LINE INDENT left = dict ( ) NEW_LINE count = dict ( ) NEW_LINE mx = 0 NEW_LINE mn = 0 NEW_LINE strindex = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = a [ i ] NEW_LINE if count [ x ] == 0 : NEW_LINE INDENT left [ x ] = i NEW_LINE count [ x ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT count [ x ] += 1 NEW_LINE DEDENT if count [ x ] > mx : NEW_LINE INDENT mx = count [ x ] NEW_LINE mn = i - left [ x ] + 1 NEW_LINE strindex = left [ x ] NEW_LINE DEDENT elif count [ x ] == mx and i - left [ x ] + 1 < mn : NEW_LINE INDENT mn = i - left [ x ] + 1 NEW_LINE strindex = left [ x ] NEW_LINE DEDENT DEDENT for i in range ( strindex , strindex + mn ) : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def minRadius ( k , x , y , n ) : NEW_LINE INDENT dis = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT dis [ i ] = x [ i ] * x [ i ] + y [ i ] * y [ i ] NEW_LINE DEDENT dis . sort ( ) NEW_LINE return dis [ k - 1 ] NEW_LINE DEDENT
def findSmallest ( m , s ) : NEW_LINE INDENT if ( s == 0 ) : NEW_LINE INDENT ( m == 1 ) : NEW_LINE INDENT print ( " Smallest ▁ number ▁ is ▁ " , 0 ) NEW_LINE DEDENT if ( s > 9 * m ) : NEW_LINE INDENT print ( " Not ▁ possible " ) NEW_LINE return NEW_LINE DEDENT res = [ 0 ] * m NEW_LINE s -= 1 NEW_LINE for i in range ( m - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( s > 9 ) : NEW_LINE INDENT res [ i ] = 9 NEW_LINE s -= 9 NEW_LINE DEDENT else : NEW_LINE INDENT res [ i ] = s NEW_LINE s = 0 NEW_LINE DEDENT DEDENT res [ 0 ] = s + 1 NEW_LINE print ( " Smallest ▁ number ▁ is " ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT print ( res [ i ] ) NEW_LINE DEDENT DEDENT
def isPresent ( s , q ) : NEW_LINE INDENT freq = [ 0 for i in range ( MAX_CHAR ) ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT freq [ ord ( s [ i ] ) - 97 ] += 1 NEW_LINE DEDENT for i in range ( len ( q ) ) : NEW_LINE INDENT freq [ ord ( q [ i ] ) - 97 ] -= 1 NEW_LINE if ( freq [ q [ i ] ] < 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def sortArray ( arr , n , A , B , C ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT arr [ i ] = A * arr [ i ] * arr [ i ] + B * arr [ i ] + C NEW_LINE DEDENT index = - 1 NEW_LINE maximum = - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( maximum < arr [ i ] ) : NEW_LINE INDENT index = i NEW_LINE maximum = arr [ i ] NEW_LINE DEDENT DEDENT i = 0 , j = n - 1 NEW_LINE new_arr = [ 0 ] * ( n - 1 ) NEW_LINE k = 0 NEW_LINE while ( i < index and j > index ) : NEW_LINE INDENT if ( arr [ i ] < arr [ j ] ) : NEW_LINE INDENT new_arr [ k ] = arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT new_arr [ k ] = arr [ j -= 1 NEW_LINE DEDENT DEDENT while ( i < index ) : NEW_LINE INDENT new_arr [ k ] = arr [ i ] NEW_LINE i += 1 NEW_LINE DEDENT while ( j > index ) : NEW_LINE INDENT new_arr [ k ] = arr [ j ] NEW_LINE j -= 1 NEW_LINE DEDENT new_arr [ n - 1 ] = maximum NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT arr [ i ] = new_arr [ i ] NEW_LINE DEDENT DEDENT
def printDistance ( mat ) : NEW_LINE INDENT ans = [ [ 0 for i in range ( M ) ] for j in range ( M ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT for k in range ( N ) : NEW_LINE INDENT for l in range ( M ) : NEW_LINE INDENT if ( mat [ k ] [ l ] == 1 ) : NEW_LINE INDENT ans [ i ] [ j ] = min ( ans [ i ] [ j ] , abs ( i - k ) + abs ( j - l ) ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT print ( ans [ i ] [ j ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT
def findLastIndex ( str , x ) : NEW_LINE INDENT index = - 1 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] == x ) : NEW_LINE INDENT index = i NEW_LINE DEDENT DEDENT return index NEW_LINE DEDENT
def vol_of_dodecahedron ( side ) : NEW_LINE INDENT return ( ( ( 15 + ( 7 * ( math . sqrt ( 5 ) ) ) / 4 ) * ( pow ( side , 3 ) ) ) NEW_LINE DEDENT
def countTransformation ( a , b ) : NEW_LINE INDENT n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE if ( m == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( m + 1 ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT if ( j == 0 ) : NEW_LINE INDENT dp [ i ] [ j ] = ( a [ j ] == b [ i ] ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 NEW_LINE DEDENT elif ( a [ j ] == b [ i ] ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT elif ( a [ j ] == b [ i ] ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT return dp [ m - 1 ] [ n - 1 ] NEW_LINE DEDENT
def sumAtKthLevel ( tree , k , i , level ) : NEW_LINE INDENT if ( tree [ i ] == ' ( ' ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT sum = 0 NEW_LINE if ( level == k ) : NEW_LINE INDENT sum = tree [ i ] - '0' NEW_LINE DEDENT leftsum = 0 NEW_LINE if ( level == k ) : NEW_LINE INDENT leftsum = tree [ i ] - '0' NEW_LINE DEDENT rightsum = 0 NEW_LINE if ( level == k ) : NEW_LINE INDENT rightsum = sumAtKthLevel ( tree , k , i , level + 1 ) NEW_LINE i += 1 NEW_LINE DEDENT return sum + leftsum + rightsum NEW_LINE DEDENT
def printRepeating ( arr , size ) : NEW_LINE INDENT count = [ 0 for i in range ( size - 2 ) ] NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT if ( count [ arr [ i ] ] == 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT count [ arr [ i ] ] += 1 NEW_LINE DEDENT DEDENT DEDENT
def isSubsetSum ( set , n , Sum ) : NEW_LINE INDENT subset = [ [ False for x in range ( Sum + 1 ) ] for y in range ( n + 1 ) ] NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT subset [ i ] [ 0 ] = True NEW_LINE DEDENT for i in range ( 1 , Sum + 1 ) : NEW_LINE INDENT subset [ 0 ] [ i ] = False NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , Sum + 1 ) : NEW_LINE INDENT if ( j < set [ i - 1 ] ) : NEW_LINE INDENT subset [ i ] [ j ] = subset [ i - 1 ] [ j ] NEW_LINE DEDENT if ( j >= Set [ i - 1 ] ) : NEW_LINE INDENT subset [ i ] [ j ] = subset [ i - 1 ] [ j ] or subset [ i - 1 ] [ j - set [ i - 1 ] ] NEW_LINE DEDENT DEDENT DEDENT return subset [ n ] [ Sum ] NEW_LINE DEDENT
def findMajority ( arr , size ) : NEW_LINE INDENT m = dict ( ) NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT m [ arr [ i ] ] += 1 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT if ( i . second > size // 2 ) : NEW_LINE INDENT count = 1 NEW_LINE print ( " Majority ▁ found ▁ : - ▁ " , i . first ) NEW_LINE break NEW_LINE DEDENT DEDENT if ( count == 0 ) : NEW_LINE INDENT print ( " No ▁ Majority ▁ element " ) NEW_LINE DEDENT DEDENT
def replaceOriginal ( s , n ) : NEW_LINE INDENT r = [ ' ▁ ' ] * ( n + 1 ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT r [ i ] = s [ n - 1 - i ] NEW_LINE if ( s [ i ] != ' a ' and s [ i ] != ' e ' and s [ i ] != ' i ' and s [ i ] != ' o ' and s [ i ] != ' u ' ) : NEW_LINE INDENT print ( r [ i ] ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT
def findMaxPath ( mat ) : NEW_LINE INDENT for i in range ( 1 , N ) : NEW_LINE INDENT for j in range ( 0 , M ) : NEW_LINE INDENT if ( j > 0 and j < M - 1 ) : NEW_LINE INDENT mat [ i ] [ j ] = max ( mat [ i - 1 ] [ j ] , max ( mat [ i - 1 ] [ j - 1 ] , mat [ i - 1 ] [ j + 1 ] ) ) NEW_LINE DEDENT elif ( j > 0 ) : NEW_LINE INDENT mat [ i ] [ j ] += max ( mat [ i - 1 ] [ j ] , mat [ i - 1 ] [ j - 1 ] ) NEW_LINE DEDENT elif ( j < M - 1 ) : NEW_LINE INDENT mat [ i ] [ j ] += max ( mat [ i - 1 ] [ j ] , mat [ i - 1 ] [ j + 1 ] ) NEW_LINE DEDENT DEDENT DEDENT res = 0 NEW_LINE for j in range ( M ) : NEW_LINE INDENT res = max ( mat [ N - 1 ] [ j ] , res ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def checkIsAP ( arr , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT arr . sort ( ) NEW_LINE d = arr [ 1 ] - arr [ 0 ] NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT if ( arr [ i ] - arr [ i - 1 ] != d ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def check ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE oddDigSum = 0 NEW_LINE evenDigSum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT oddDigSum += ( ord ( str [ i ] ) - ord ( '0' ) ) NEW_LINE DEDENT else : NEW_LINE INDENT evenDigSum += ( ord ( str [ i ] ) - ord ( '0' ) ) NEW_LINE DEDENT DEDENT return ( ( oddDigSum - evenDigSum ) % 11 == 0 ) NEW_LINE DEDENT
def swap ( xp , yp ) : NEW_LINE INDENT xp = * xp ^ * yp NEW_LINE yp = * xp ^ * yp NEW_LINE * xp = * xp ^ * yp NEW_LINE DEDENT
def countSol ( coeff , n , rhs ) : NEW_LINE INDENT dp = [ 0 for _ in range ( rhs + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( coeff [ i ] , rhs + 1 ) : NEW_LINE INDENT dp [ j ] = dp [ j - coeff [ i ] ] NEW_LINE DEDENT DEDENT return dp [ rhs ] NEW_LINE DEDENT
def printRepeating ( arr , size ) : NEW_LINE INDENT Xor = arr [ 0 ] NEW_LINE set_bit_no = 0 NEW_LINE x = 0 NEW_LINE y = 0 NEW_LINE for i in range ( 1 , size - 1 ) : NEW_LINE INDENT Xor ^= arr [ i ] NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT Xor ^= i NEW_LINE DEDENT set_bit_no = Xor & ~ ( Xor - 1 ) NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT if ( arr [ i ] & set_bit_no ) : NEW_LINE INDENT x = x ^ arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT y = y ^ arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( i & set_bit_no ) : NEW_LINE INDENT x = x ^ i NEW_LINE DEDENT else : NEW_LINE INDENT y = y ^ i NEW_LINE DEDENT DEDENT print ( " The ▁ two ▁ repeating ▁ elements ▁ are " , y , " " , x ) NEW_LINE DEDENT
def findSubsequenceCount ( S , T ) : NEW_LINE INDENT m = len ( S ) NEW_LINE n = len ( T ) NEW_LINE if m > n : NEW_LINE INDENT return 0 NEW_LINE DEDENT mat = [ [ 0 for i in range ( n + 1 ) ] for j in range ( m + 1 ) ] NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT mat [ i ] [ 0 ] = 0 NEW_LINE DEDENT for j in range ( 0 , n + 1 ) : NEW_LINE INDENT mat [ 0 ] [ j ] = 1 NEW_LINE DEDENT for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if T [ i - 1 ] != S [ j - 1 ] : NEW_LINE INDENT mat [ i ] [ j ] = mat [ i ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT mat [ i ] [ j ] = mat [ i ] [ j - 1 ] + mat [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT return mat [ m ] [ n ] NEW_LINE DEDENT
def breakSum ( n ) : NEW_LINE INDENT dp = [ 0 for i in range ( n + 1 ) ] NEW_LINE dp [ 0 ] = 0 NEW_LINE dp [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i // 2 ] + dp [ i // 3 ] + dp [ i // 4 ] , i ) NEW_LINE DEDENT return dp [ n ] NEW_LINE DEDENT
def decToHexa ( n ) : NEW_LINE INDENT hexaDeciNum = [ 0 ] * 100 NEW_LINE i = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT temp = 0 NEW_LINE temp = n % 16 NEW_LINE if ( temp < 10 ) : NEW_LINE INDENT hexaDeciNum [ i ] = temp + 48 NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT hexaDeciNum [ i ] = temp + 55 NEW_LINE i += 1 NEW_LINE DEDENT n = int ( n / 16 ) NEW_LINE DEDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( hexaDeciNum [ j ] , end = " " ) NEW_LINE DEDENT DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( a == b ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( ~ a & 1 ) : NEW_LINE INDENT return gcd ( a >> 1 , b ) NEW_LINE DEDENT else : NEW_LINE INDENT return gcd ( a >> 1 , b >> 1 ) << 1 NEW_LINE DEDENT if ( ~ b & 1 ) : NEW_LINE INDENT return gcd ( a , b >> 1 ) NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT return gcd ( ( a - b ) >> 1 , b ) NEW_LINE DEDENT return gcd ( ( b - a ) >> 1 , a ) NEW_LINE DEDENT
def evaluate ( n ) : NEW_LINE INDENT if ( n == 1 or n == 2 ) : NEW_LINE INDENT print ( " No ▁ Pythagoras ▁ Triplet ▁ exists " ) NEW_LINE DEDENT elif ( n % 2 == 0 ) : NEW_LINE INDENT var = 1LL * n * n / 4 NEW_LINE print ( " Pythagoras ▁ Triplets ▁ exist ▁ i . e . ▁ " ) NEW_LINE print ( " % lld ▁ % lld ▁ % lld " , n , var - 1 , var + 1 ) NEW_LINE DEDENT elif ( n % 2 != 0 ) : NEW_LINE INDENT var = 1LL * n * n + 1 NEW_LINE print ( " Pythagoras ▁ Triplets ▁ exist ▁ i . e . ▁ " ) NEW_LINE print ( " % lld ▁ % lld " , n , var // 2 - 1 , var // 2 ) NEW_LINE DEDENT DEDENT
def countPairs ( str ) : NEW_LINE INDENT result = 0 NEW_LINE n = len ( str ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( 1 , MAX_CHAR + 1 ) : NEW_LINE INDENT if ( ( abs ( str [ i + j ] - str [ i ] ) == j ) ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
def solve ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE a = 0 NEW_LINE b = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( i & 1 ) : NEW_LINE INDENT a = a * 10 + arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT b = b * 10 + arr [ i ] NEW_LINE DEDENT DEDENT return a + b NEW_LINE DEDENT
def countMinOperations ( target , n ) : NEW_LINE INDENT result = 0 NEW_LINE while 1 : NEW_LINE INDENT zero_count = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT if ( target [ i ] & 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT elif ( target [ i ] == 0 ) : NEW_LINE INDENT zero_count += 1 NEW_LINE DEDENT DEDENT if ( zero_count == n ) : NEW_LINE INDENT return result NEW_LINE DEDENT if ( i == n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT if ( target [ j ] & 1 ) : NEW_LINE INDENT target [ j ] = target [ j ] // 2 NEW_LINE result += 1 NEW_LINE DEDENT DEDENT for j in range ( i , n ) : NEW_LINE INDENT if ( target [ j ] & 1 ) : NEW_LINE INDENT target [ j ] -= 1 NEW_LINE result += 1 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
def canMakeAllSame ( string ) : NEW_LINE INDENT zeros = 0 NEW_LINE ones = 0 NEW_LINE for ch in string : NEW_LINE INDENT if ( ch == '0' ) : NEW_LINE INDENT zeros += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ones += 1 NEW_LINE DEDENT DEDENT return ( zeros == 1 or ones == 1 ) NEW_LINE DEDENT
def psuedoBinary ( n ) : NEW_LINE INDENT temp = n NEW_LINE m = 0 NEW_LINE p = 1 NEW_LINE while ( temp ) : NEW_LINE INDENT rem = temp % 10 NEW_LINE temp = int ( temp / 10 ) NEW_LINE if ( rem != 0 ) : NEW_LINE INDENT m += p NEW_LINE p = int ( temp / 10 ) NEW_LINE DEDENT print ( m , end = " ▁ " ) NEW_LINE n = n - m NEW_LINE DEDENT DEDENT
def findmin ( p , n ) : NEW_LINE INDENT a = 0 NEW_LINE b = 0 NEW_LINE c = 0 NEW_LINE d = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( p [ i ] . x <= 0 ) : NEW_LINE INDENT a += 1 NEW_LINE DEDENT elif ( p [ i ] . x >= 0 ) : NEW_LINE INDENT b += 1 NEW_LINE DEDENT if ( p [ i ] . y <= 0 ) : NEW_LINE INDENT d += 1 NEW_LINE DEDENT DEDENT return min ( { a , b , c , d } ) NEW_LINE DEDENT
def minCoins ( coins , m , V ) : NEW_LINE INDENT table = [ 0 for i in range ( V + 1 ) ] NEW_LINE for i in range ( 1 , V + 1 ) : NEW_LINE INDENT table [ i ] = 0 NEW_LINE DEDENT for i in range ( 1 , V + 1 ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( coins [ j ] <= i ) : NEW_LINE INDENT sub_res = table [ i - coins [ j ] ] NEW_LINE if ( sub_res != 0 and sub_res + 1 < table [ i ] ) : NEW_LINE INDENT table [ i ] = sub_res + 1 NEW_LINE DEDENT DEDENT DEDENT return table [ V ] NEW_LINE DEDENT
def maxAlternateSum ( arr , n ) : NEW_LINE INDENT if ( n == 1 ) : return arr [ 0 ] NEW_LINE DEDENT inc = [ 0 for i in range ( n ) ] NEW_LINE dec = [ 0 for j in range ( n ) ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ j ] > arr [ i ] ) : NEW_LINE INDENT dec [ i ] = max ( dec [ i ] , inc [ j ] + arr [ i ] ) NEW_LINE flag = 1 NEW_LINE DEDENT elif ( arr [ j ] < arr [ i ] and flag == 1 ) : NEW_LINE INDENT inc [ i ] = max ( inc [ i ] , dec [ j ] + arr [ i ] ) NEW_LINE DEDENT DEDENT DEDENT result = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( result < inc [ i ] ) : NEW_LINE INDENT result = inc [ i ] NEW_LINE DEDENT if ( result < dec [ i ] ) : NEW_LINE INDENT result = dec [ i ] NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def printRepeating ( arr , size ) : NEW_LINE INDENT print ( " ▁ Repeating ▁ elements ▁ are " ) NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT for j in range ( i + 1 , size ) : NEW_LINE INDENT if ( arr [ i ] == arr [ j ] ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
def firstElement ( arr , n , k ) : NEW_LINE INDENT count_map = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if count_map . get ( arr [ i ] ) : NEW_LINE INDENT count_map [ arr [ i ] ] += 1 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if count_map [ arr [ i ] ] == k : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def maxSum ( grid , n ) : NEW_LINE INDENT incl = max ( grid [ 0 ] [ 0 ] , grid [ 1 ] [ 0 ] ) NEW_LINE excl = 0 NEW_LINE excl_new = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT excl_new = max ( excl , incl ) NEW_LINE incl = excl + max ( grid [ 0 ] [ i ] , grid [ 1 ] [ i ] ) NEW_LINE excl = excl_new NEW_LINE DEDENT return max ( excl , incl ) NEW_LINE DEDENT
def checkCorrectOrNot ( s ) : NEW_LINE INDENT count1 = [ 0 ] * MAX_CHAR NEW_LINE count2 = [ 0 ] * MAX_CHAR NEW_LINE n = len ( s ) NEW_LINE if ( n == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT for i in range ( 0 , n - 1 , - 1 ) : NEW_LINE INDENT count1 [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE count2 [ ord ( s [ j ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( 0 , MAX_CHAR ) : NEW_LINE INDENT if ( count1 [ i ] != count2 [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def areaOctagon ( side ) : NEW_LINE INDENT return ( float ) ( 2 * ( 1 + math . sqrt ( 2 ) ) * side * side ) NEW_LINE DEDENT
def printSuperSeq ( a , b ) : NEW_LINE INDENT m = len ( a ) NEW_LINE n = len ( b ) NEW_LINE dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if ( not i ) : NEW_LINE INDENT dp [ i ] [ j ] = j NEW_LINE DEDENT elif ( not j ) : NEW_LINE INDENT dp [ i ] [ j ] = i NEW_LINE DEDENT elif ( a [ i - 1 ] == b [ j - 1 ] ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = 1 + min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT index = dp [ m ] [ n ] NEW_LINE res = " " NEW_LINE i = m NEW_LINE j = n NEW_LINE while ( i > 0 and j > 0 ) : NEW_LINE INDENT if a [ i - 1 ] == b [ j - 1 ] : NEW_LINE INDENT res [ index - 1 ] = a [ i - 1 ] NEW_LINE i -= 1 NEW_LINE j -= 1 NEW_LINE index -= 1 NEW_LINE DEDENT elif dp [ i - 1 ] [ j ] < dp [ i ] [ j - 1 ] : NEW_LINE INDENT res [ index - 1 ] = b [ j - 1 ] NEW_LINE j -= 1 NEW_LINE index -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT res [ index - 1 ] = b [ j - 1 ] NEW_LINE j -= 1 NEW_LINE index -= 1 NEW_LINE DEDENT DEDENT while i > 0 : NEW_LINE INDENT res [ index - 1 ] = a [ i - 1 ] NEW_LINE i -= 1 NEW_LINE index -= 1 NEW_LINE DEDENT DEDENT
def numberOfPaths ( m , n ) : NEW_LINE INDENT dp = [ 0 for _ in range ( n ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT dp [ j ] = dp [ j - 1 ] + 1 NEW_LINE DEDENT DEDENT return dp [ n - 1 ] NEW_LINE DEDENT
def isPowerOfFour ( n ) : NEW_LINE INDENT count = 0 NEW_LINE if ( n and not ( n & ( n - 1 ) ) ) : NEW_LINE INDENT while ( n > 1 ) : NEW_LINE INDENT n >>= 1 NEW_LINE count += 1 NEW_LINE DEDENT return 1 NEW_LINE DEDENT
def findElement ( arr , n ) : NEW_LINE INDENT leftMax = [ 0 for i in range ( n ) ] NEW_LINE leftMax [ 0 ] = INT_MIN NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT leftMax [ i ] = max ( leftMax [ i - 1 ] , arr [ i - 1 ] ) NEW_LINE DEDENT rightMin = sys . maxsize NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( leftMax [ i ] < arr [ i ] and rightMin > arr [ i ] ) : NEW_LINE INDENT return i NEW_LINE DEDENT rightMin = min ( rightMin , arr [ i ] ) NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def printRepeating ( arr , size ) : NEW_LINE INDENT print ( " The ▁ repeating ▁ elements ▁ are " ) NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT if ( arr [ abs ( arr [ i ] ) ] > 0 ) : NEW_LINE INDENT arr [ abs ( arr [ i ] ) ] = - arr [ abs ( arr [ i ] ) ] NEW_LINE DEDENT else : NEW_LINE INDENT print ( " ▁ " , abs ( arr [ i ] ) , " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
def height ( N ) : NEW_LINE INDENT return math . ceil ( math . log2 ( N + 1 ) ) - 1 NEW_LINE DEDENT
def thirdLargest ( arr , arr_size ) : NEW_LINE INDENT if arr_size < 3 : NEW_LINE INDENT print ( " ▁ Invalid ▁ Input ▁ " ) NEW_LINE return - 1 NEW_LINE DEDENT first = arr [ 0 ] NEW_LINE second = arr [ 0 ] NEW_LINE third = INT_MIN NEW_LINE for i in range ( 1 , arr_size ) : NEW_LINE INDENT if arr [ i ] > first : NEW_LINE INDENT third = second NEW_LINE second = first NEW_LINE first = arr [ i ] NEW_LINE DEDENT elif arr [ i ] > second : NEW_LINE INDENT third = second NEW_LINE second = arr [ i ] NEW_LINE DEDENT elif arr [ i ] > third : NEW_LINE INDENT third = arr [ i ] NEW_LINE DEDENT DEDENT print ( " The ▁ third ▁ Largest ▁ element ▁ is : ▁ % d " , third ) NEW_LINE DEDENT
def getNumStrictMonotone ( len ) : NEW_LINE INDENT DP = [ [ 0 for i in range ( DP_s ) ] for j in range ( DP_s ) ] NEW_LINE for i in range ( len ) : NEW_LINE INDENT for j in range ( 1 , DP_s ) : NEW_LINE INDENT DP [ i ] [ j ] = DP [ i - 1 ] [ j - 1 ] + DP [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT return DP [ len - 1 ] [ DP_s - 1 ] NEW_LINE DEDENT
def maxRevenue ( m , x , revenue , n , t ) : NEW_LINE INDENT maxRev = [ 0 for i in range ( m + 1 ) ] NEW_LINE maxRev [ 0 ] = 0 NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT if ( nxtbb < n ) : NEW_LINE INDENT if ( x [ nxtbb ] != i ) : NEW_LINE INDENT maxRev [ i ] = maxRev [ i - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT if ( i <= t ) : NEW_LINE INDENT maxRev [ i ] = max ( maxRev [ i - 1 ] , revenue [ nxtbb ] ) NEW_LINE DEDENT else : NEW_LINE INDENT maxRev [ i ] = max ( maxRev [ i - t - 1 ] + revenue [ nxtbb ] , maxRev [ i - 1 ] ) NEW_LINE nxtbb += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT maxRev [ i ] = max ( maxRev [ i - t - 1 ] + revenue [ nxtbb ] , maxRev [ i - 1 ] ) NEW_LINE DEDENT nxtbb += 1 NEW_LINE DEDENT DEDENT return maxRev [ m ] NEW_LINE DEDENT
def lineFromPoints ( P , Q ) : NEW_LINE INDENT a = Q . second - P . second NEW_LINE b = P . first - Q . first NEW_LINE c = a * ( P . first ) + b * ( P . second ) NEW_LINE if ( b < 0 ) : NEW_LINE INDENT print ( " The ▁ line ▁ passing ▁ through ▁ points ▁ P ▁ and ▁ Q ▁ is : ▁ " , a , " x ▁ " , b , " y ▁ = ▁ " , c ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " The ▁ line ▁ passing ▁ through ▁ points ▁ P ▁ and ▁ Q ▁ is : ▁ " , a , " x ▁ + ▁ " , b , " y ▁ = " , c ) NEW_LINE DEDENT DEDENT
def countSubstringWithEqualEnds ( s ) : NEW_LINE INDENT result = 0 NEW_LINE n = len ( s ) NEW_LINE count = [ 0 for i in range ( MAX_CHAR ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT count [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( 0 , MAX_CHAR ) : NEW_LINE INDENT result += ( count [ i ] * ( count [ i ] + 1 ) / 2 ) NEW_LINE DEDENT return result NEW_LINE DEDENT
def findRepeatingNumber ( arr , n ) : NEW_LINE INDENT sq = math . sqrt ( n ) NEW_LINE range = ( n // sq ) + 1 NEW_LINE count = [ 0 for i in range ( range ) ] NEW_LINE for i in range ( range ) : NEW_LINE INDENT count [ ( arr [ i ] - 1 ) / sq ] += 1 NEW_LINE DEDENT selected_block = range - 1 NEW_LINE for i in range ( range - 1 ) : NEW_LINE INDENT if ( count [ i ] > sq ) : NEW_LINE INDENT selected_block = i NEW_LINE break NEW_LINE DEDENT DEDENT m = dict ( ) NEW_LINE for i in range ( range - 1 ) : NEW_LINE INDENT if ( ( ( selected_block * sq ) < arr [ i ] ) and ( arr [ i ] <= ( ( selected_block + 1 ) * sq ) ) ) : NEW_LINE INDENT m [ arr [ i ] ] += 1 NEW_LINE if ( m [ arr [ i ] ] > 1 ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT DEDENT return - 1 NEW_LINE DEDENT
def check ( string ) : NEW_LINE INDENT n = len ( string ) NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return ( ( string [ 0 ] - '0' ) % 4 == 0 ) NEW_LINE DEDENT last = ord ( string [ n - 1 ] ) - ord ( '0' ) NEW_LINE second_last = ord ( string [ n - 2 ] ) - ord ( '0' ) NEW_LINE return ( ( second_last * 10 + last ) % 4 == 0 ) NEW_LINE DEDENT
def remAnagram ( str1 , str2 ) : NEW_LINE INDENT count1 = [ 0 ] * 26 NEW_LINE count2 = [ 0 ] * 26 NEW_LINE for i in range ( len ( str1 ) ) : NEW_LINE INDENT count1 [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( len ( str2 ) ) : NEW_LINE INDENT count2 [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT result = 0 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT result += abs ( count1 [ i ] - count2 [ i ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT
def mulmod ( a , b , mod ) : NEW_LINE INDENT res = 0 NEW_LINE a = a % mod NEW_LINE while ( b > 0 ) : NEW_LINE INDENT if ( b % 2 == 1 ) : NEW_LINE INDENT res = ( res + a ) % mod NEW_LINE DEDENT a = ( a * 2 ) % mod NEW_LINE b = int ( b / 2 ) NEW_LINE DEDENT return res % mod NEW_LINE DEDENT
def Dragon_Curve_Sequence ( n ) : NEW_LINE INDENT s = "1" NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT temp = "1" NEW_LINE prev = '1' NEW_LINE zero = '0' NEW_LINE one = '1' NEW_LINE for j in range ( len ( s ) ) : NEW_LINE INDENT temp += s [ j ] NEW_LINE if ( prev == '0' ) : NEW_LINE INDENT temp += one NEW_LINE prev = one NEW_LINE DEDENT else : NEW_LINE INDENT temp += zero NEW_LINE prev = zero NEW_LINE DEDENT DEDENT s = temp NEW_LINE DEDENT return s NEW_LINE DEDENT
def getSecondMostFreq ( Str ) : NEW_LINE INDENT count = [ 0 for i in range ( NO_OF_CHARS ) ] NEW_LINE for i in range ( len ( Str ) ) : NEW_LINE INDENT ( count [ Str [ i ] ] ) += 1 NEW_LINE DEDENT first = 0 NEW_LINE second = 0 NEW_LINE for i in range ( NO_OF_CHARS ) : NEW_LINE INDENT if ( count [ i ] > count [ first ] ) : NEW_LINE INDENT second = first NEW_LINE first = i NEW_LINE DEDENT elif ( count [ i ] > count [ second ] and count [ i ] != count [ first ] ) : NEW_LINE INDENT second = i NEW_LINE DEDENT DEDENT return second NEW_LINE DEDENT
