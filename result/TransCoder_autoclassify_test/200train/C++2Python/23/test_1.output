def printPairs ( arr , n ) : NEW_LINE INDENT v = [ ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( abs ( arr [ i ] ) == abs ( arr [ j ] ) ) : NEW_LINE INDENT v . append ( abs ( arr [ i ] ) ) NEW_LINE DEDENT DEDENT if ( len ( v ) == 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT v . sort ( ) NEW_LINE for i in range ( 0 , v . size ( ) ) : NEW_LINE INDENT print ( - v [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def findArea ( a , b , c ) : NEW_LINE INDENT if ( a < 0 or b < 0 or c < 0 or ( a + b <= c ) or a + c <= b or b + c <= a ) : NEW_LINE INDENT print ( " Not ▁ a ▁ valid ▁ trianglen " ) NEW_LINE exit ( 0 ) NEW_LINE DEDENT s = ( a + b + c ) / 2 NEW_LINE return math . sqrt ( s * ( s - a ) * ( s - b ) * ( s - c ) ) NEW_LINE DEDENT
def isMajority ( a , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ a [ i ] ] += 1 NEW_LINE DEDENT for auto in mp : NEW_LINE INDENT if x . second >= n // 2 : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def recaman ( n ) : NEW_LINE INDENT if ( n <= 0 ) : return NEW_LINE DEDENT s = set ( ) NEW_LINE prev = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT curr = prev - i NEW_LINE if curr < 0 or curr in s : NEW_LINE INDENT curr = prev + i NEW_LINE DEDENT s . add ( curr ) NEW_LINE print ( " % d , ▁ " , curr ) NEW_LINE prev = curr NEW_LINE DEDENT DEDENT
def findLength ( str1 ) : NEW_LINE INDENT n = len ( str1 ) NEW_LINE maxlen = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT length = j - i + 1 NEW_LINE leftsum = 0 NEW_LINE rightsum = 0 NEW_LINE for k in range ( 0 , int ( length / 2 ) ) : NEW_LINE INDENT leftsum += ( ord ( str1 [ i + k ] ) - ord ( '0' ) ) NEW_LINE rightsum += ( ord ( str1 [ i + k + length // 2 ] ) - ord ( '0' ) ) NEW_LINE DEDENT if ( leftsum == rightsum and maxlen < length ) : NEW_LINE INDENT maxlen = length NEW_LINE DEDENT DEDENT DEDENT return maxlen NEW_LINE DEDENT
def prevPermutation ( str1 ) : NEW_LINE INDENT n = len ( str1 ) - 1 NEW_LINE i = n NEW_LINE while i > 0 and str1 [ i - 1 ] <= str1 [ i ] : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT if i <= 0 : NEW_LINE INDENT return False NEW_LINE DEDENT j = i - 1 NEW_LINE while j + 1 <= n and str1 [ j + 1 ] <= str1 [ i - 1 ] : NEW_LINE INDENT j += 1 NEW_LINE DEDENT swap ( str1 [ i - 1 ] , str1 [ j ] ) NEW_LINE return True NEW_LINE DEDENT
def findSubString ( str , pat ) : NEW_LINE INDENT len1 = len ( str ) NEW_LINE len2 = len ( pat ) NEW_LINE if ( len1 < len2 ) : NEW_LINE INDENT print ( " No ▁ such ▁ window ▁ exists " ) NEW_LINE return " " NEW_LINE DEDENT hash_pat = [ 0 for i in range ( len2 ) ] NEW_LINE hash_str = [ 0 for i in range ( len1 ) ] NEW_LINE for j in range ( len1 ) : NEW_LINE INDENT hash_str [ ord ( str [ j ] ) ] += 1 NEW_LINE if ( hash_pat [ ord ( str [ j ] ) ] != 0 and hash_str [ ord ( str [ j ] ) ] <= hash_pat [ ord ( str [ j ] ) ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( count == len2 ) : NEW_LINE INDENT while ( hash_str [ ord ( str [ start ] ) ] > hash_pat [ ord ( str [ start ] ) ] or hash_pat [ ord ( str [ start ] ) ] == 0 ) : NEW_LINE INDENT if ( hash_str [ ord ( str [ start ] ) ] > hash_pat [ ord ( str [ start ] ) ] ) : NEW_LINE INDENT hash_str [ ord ( str [ start ] ) ] -= 1 NEW_LINE start += 1 NEW_LINE DEDENT DEDENT len_window = j - start + 1 NEW_LINE if ( min_len > len_window ) : NEW_LINE INDENT min_len = len_window NEW_LINE start_index = start NEW_LINE DEDENT DEDENT return str [ start_index , min_len ) NEW_LINE DEDENT
def shuffle ( card , n ) : NEW_LINE INDENT srand ( time ( 0 ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT r = i + ( rand ( ) % ( 52 - i ) ) NEW_LINE card [ i ] = card [ r ] , card [ r ] = card [ i ] , card [ r ] NEW_LINE DEDENT DEDENT
def removeConsecutiveSame ( v ) : NEW_LINE INDENT st = [ ] NEW_LINE for i in range ( len ( v ) ) : NEW_LINE INDENT if ( st . empty ( ) ) : NEW_LINE INDENT st . append ( v [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT str = st . pop ( ) NEW_LINE if ( str == v [ i ] ) : NEW_LINE INDENT st . remove ( ) NEW_LINE DEDENT else : NEW_LINE INDENT st . append ( v [ i ] ) NEW_LINE DEDENT DEDENT return len ( st ) NEW_LINE DEDENT
def find ( list1 , list2 ) : NEW_LINE INDENT res = [ ] NEW_LINE max_possible_sum = len ( list1 ) + len ( list2 ) - 2 NEW_LINE for sum in range ( max_possible_sum + 1 ) : NEW_LINE INDENT for i in range ( 0 , max_possible_sum + 1 ) : NEW_LINE INDENT if ( ( i < list1 . size ( ) and ( sum - i ) < list2 . size ( ) and list1 [ i ] == list2 [ sum - i ] ) : NEW_LINE INDENT res . append ( list1 [ i ] ) NEW_LINE DEDENT DEDENT if ( res . size ( ) > 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT for i in range ( 0 , res . size ( ) ) : NEW_LINE INDENT print ( res [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def getLevenstein ( input ) : NEW_LINE INDENT revInput = ( input [ 0 ] == revInput [ 0 ] ) NEW_LINE n = len ( input ) NEW_LINE dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT dp [ 0 ] [ i ] = i NEW_LINE dp [ i ] [ 0 ] = i NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( input [ i - 1 ] == revInput [ j - 1 ] ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = 1 + min ( { dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] } ) NEW_LINE DEDENT DEDENT DEDENT res = - float ( ' inf ' ) NEW_LINE for i in range ( n + 1 , - 1 ) : NEW_LINE INDENT res = min ( res , dp [ i ] [ j ] ) NEW_LINE if ( i < n ) : NEW_LINE INDENT res = min ( res , dp [ i + 1 ] [ j ] ) NEW_LINE DEDENT if ( i > 0 ) : NEW_LINE INDENT res = min ( res , dp [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def countDistinct ( arr , k , n ) : NEW_LINE INDENT hm = dict ( ) NEW_LINE dist_count = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT if hm . get ( arr [ i ] ) == 0 : NEW_LINE INDENT dist_count += 1 NEW_LINE DEDENT hm [ arr [ i ] ] += 1 NEW_LINE DEDENT print ( dist_count ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if hm [ arr [ i - k ] ] == 1 : NEW_LINE INDENT dist_count -= 1 NEW_LINE DEDENT hm [ arr [ i - k ] ] -= 1 NEW_LINE if hm [ arr [ i ] ] == 0 : NEW_LINE INDENT dist_count += 1 NEW_LINE DEDENT hm [ arr [ i ] ] += 1 NEW_LINE print ( dist_count ) NEW_LINE DEDENT DEDENT
def lcs ( dp , arr1 , n , arr2 , m , k ) : NEW_LINE INDENT if ( k < 0 ) : NEW_LINE INDENT return - 1e7 NEW_LINE DEDENT if ( n < 0 or m < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = dp [ n ] [ m ] [ k ] NEW_LINE if ( ans != - 1 ) : NEW_LINE INDENT return ans NEW_LINE DEDENT ans = max ( lcs ( dp , arr1 , n - 1 , arr2 , m , k ) , lcs ( dp , arr1 , n , arr2 , m - 1 , k ) ) NEW_LINE if ( arr1 [ n - 1 ] == arr2 [ m - 1 ] ) : NEW_LINE INDENT ans = max ( ans , 1 + lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k ) ) NEW_LINE DEDENT ans = max ( ans , 1 + lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k - 1 ) ) NEW_LINE return ans NEW_LINE DEDENT
def printDivisors ( n ) : NEW_LINE INDENT v = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( 1 , int ( m . sqrt ( n ) + 1 ) ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( n // i == i ) : NEW_LINE INDENT print ( " % d ▁ " , i ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " % d ▁ " , i ) NEW_LINE v . append ( n // i ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( len ( v ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( v [ i ] ) NEW_LINE DEDENT DEDENT
def largestSubset ( a , n ) : NEW_LINE INDENT np . sort ( a ) NEW_LINE dp = [ 0 for x in range ( n ) ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT mxm = 0 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( a [ j ] % a [ i ] == 0 ) : NEW_LINE INDENT mxm = max ( mxm , dp [ j ] ) NEW_LINE DEDENT dp [ i ] = 1 + mxm NEW_LINE DEDENT return * max_element ( dp , dp + n ) NEW_LINE DEDENT
def encodedChar ( str , k ) : NEW_LINE INDENT expand = " " NEW_LINE temp = " " NEW_LINE freq = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT temp . append ( str [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT while len ( str ) > i : NEW_LINE INDENT temp . append ( str [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT while ( str [ i ] >= '1' and str [ i ] <= '9' ) : NEW_LINE INDENT freq = freq * 10 + str [ i ] - '0' NEW_LINE i += 1 NEW_LINE DEDENT for j in range ( 1 , freq + 1 ) : NEW_LINE INDENT expand . append ( temp ) NEW_LINE DEDENT DEDENT if freq == 0 : NEW_LINE INDENT expand . append ( temp ) NEW_LINE DEDENT return expand [ k - 1 ] NEW_LINE DEDENT
def countNum ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE count = 0 NEW_LINE maxm = 10 ** 9 NEW_LINE minm = 10 ** 9 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . add ( arr [ i ] ) NEW_LINE if arr [ i ] < minm : NEW_LINE INDENT minm = arr [ i ] NEW_LINE DEDENT if arr [ i ] > maxm : NEW_LINE INDENT maxm = arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( minm , maxm + 1 ) : NEW_LINE INDENT if arr [ i ] not in s : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def countPairs ( arr , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE for it in mp . values ( ) : NEW_LINE INDENT count = it -> first NEW_LINE ans += ( count * ( count - 1 ) ) / 2 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def decimalToBinary ( num , k_prec ) : NEW_LINE INDENT binary = " " NEW_LINE Integral = num NEW_LINE fractional = num - Integral NEW_LINE while ( Integral ) : NEW_LINE INDENT rem = Integral % 2 NEW_LINE binary . append ( rem + '0' ) NEW_LINE Integral /= 2 NEW_LINE DEDENT binary . reverse ( ) NEW_LINE binary . append ( ' . ' ) NEW_LINE while ( k_prec -- ) : NEW_LINE INDENT fractional = fractional * 2 NEW_LINE fract_bit = fractional NEW_LINE if ( fract_bit == 1 ) : NEW_LINE INDENT fractional -= fract_bit NEW_LINE binary . append ( 1 + '0' ) NEW_LINE DEDENT else : NEW_LINE INDENT binary . append ( 0 + '0' ) NEW_LINE DEDENT DEDENT return binary NEW_LINE DEDENT
def evaluateBoolExpr ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE for i in range ( 0 , n , 2 ) : NEW_LINE INDENT if ( s [ i + 1 ] == ' A ' ) : NEW_LINE INDENT if ( s [ i + 2 ] == '0' or s [ i ] == '0' ) : NEW_LINE INDENT s [ i + 2 ] = '0' NEW_LINE DEDENT else : NEW_LINE INDENT s [ i + 2 ] = '1' NEW_LINE DEDENT DEDENT elif ( s [ i + 1 ] == ' B ' ) : NEW_LINE INDENT if ( s [ i + 2 ] == '1' or s [ i ] == '1' ) : NEW_LINE INDENT s [ i + 2 ] = '1' NEW_LINE DEDENT else : NEW_LINE INDENT s [ i + 2 ] = '0' NEW_LINE DEDENT DEDENT i += 2 NEW_LINE DEDENT return s [ n - 1 ] - '0' NEW_LINE DEDENT
def minSwaps ( arr , n ) : NEW_LINE INDENT arrPos = [ None ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT arrPos [ i ] . first = arr [ i ] NEW_LINE arrPos [ i ] . second = i NEW_LINE DEDENT arrPos . sort ( ) NEW_LINE vis = [ False for i in range ( n ) ] NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( vis [ i ] or arrPos [ i ] . second == i ) : NEW_LINE INDENT continue NEW_LINE DEDENT cycle_size = 0 NEW_LINE j = i NEW_LINE while ( j == arrPos [ j ] . second ) : NEW_LINE INDENT vis [ j ] = 1 NEW_LINE j = arrPos [ j ] . second NEW_LINE cycle_size += 1 NEW_LINE DEDENT if ( cycle_size > 0 ) : NEW_LINE INDENT ans += ( cycle_size - 1 ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def minimumBox ( arr , n ) : NEW_LINE INDENT q = Queue ( ) NEW_LINE arr . sort ( ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT now = q . get ( ) NEW_LINE if arr [ i ] >= 2 * now : NEW_LINE INDENT q . get ( ) NEW_LINE DEDENT q . put ( arr [ i ] ) NEW_LINE DEDENT return q . qsize ( ) NEW_LINE DEDENT
def convertOpposite ( str ) : NEW_LINE INDENT ln = len ( str ) NEW_LINE for i in range ( ln ) : NEW_LINE INDENT if ( str [ i ] >= ' a ' and str [ i ] <= ' z ' ) : NEW_LINE INDENT str [ i ] = str [ i ] - 32 NEW_LINE DEDENT elif ( str [ i ] >= ' A ' and str [ i ] <= ' Z ' ) : NEW_LINE INDENT str [ i ] = str [ i ] + 32 NEW_LINE DEDENT DEDENT DEDENT
def findRepeating ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] not in s : NEW_LINE INDENT s . add ( arr [ i ] ) NEW_LINE DEDENT DEDENT for i in s : NEW_LINE INDENT if arr [ i ] not in s : NEW_LINE INDENT s . add ( arr [ i ] ) NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def transpose ( A ) : NEW_LINE INDENT for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT A [ i ] [ j ] , A [ j ] [ i ] = A [ i ] [ j ] , A [ j ] [ i ] NEW_LINE DEDENT DEDENT DEDENT
def printSubsequences ( Str ) : NEW_LINE INDENT n = len ( Str ) NEW_LINE opsize = ( int ) ( math . pow ( 2 , n - 1 ) ) NEW_LINE for counter in range ( 0 , opsize ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT print ( Str [ j ] , end = " ▁ " ) NEW_LINE if ( ( counter & ( 1 << j ) ) > 0 ) : NEW_LINE INDENT print ( " ▁ " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT
def printRoman ( number ) : NEW_LINE INDENT num = [ 1 , 4 , 5 , 9 , 10 , 40 , 50 , 90 , 100 , 400 , 500 , 900 , 1000 ] NEW_LINE sym = [ " I " , " IV " , " IX " , " X " , " XL " , " L " , " XC " , " C " , " CD " , " D " , " CM " , " M " ] NEW_LINE i = 12 NEW_LINE while ( number > 0 ) : NEW_LINE INDENT div = number // num [ i ] NEW_LINE number = number % num [ i ] NEW_LINE while ( div -= 1 ) : NEW_LINE INDENT print ( sym [ i ] , end = " " ) NEW_LINE i -= 1 NEW_LINE DEDENT DEDENT
def findTriplet ( a1 , a2 , a3 , n1 , n2 , n3 , sum ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( n1 ) : NEW_LINE INDENT s . add ( a1 [ i ] ) NEW_LINE DEDENT for i in range ( n2 ) : NEW_LINE INDENT for j in range ( n3 ) : NEW_LINE INDENT if ( sum - a2 [ i ] - a3 [ j ] ) in s : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT
def check ( s ) : NEW_LINE INDENT if len ( s ) >= 10 : NEW_LINE INDENT return True NEW_LINE DEDENT for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT for j in range ( i + 1 , len ( s ) ) : NEW_LINE INDENT for k in range ( j + 1 , len ( s ) ) : NEW_LINE INDENT s1 = s [ 0 : 0 + i ] NEW_LINE s2 = s [ i , j - i ] NEW_LINE s3 = s . substr ( j , k - j ) NEW_LINE s4 = s . substr ( k , len ( s ) - k ) NEW_LINE if ( s1 != s2 and s1 != s3 and s1 != s4 and s2 != s3 and s2 != s4 and s3 != s4 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT
def bitonicGenerator ( arr , n ) : NEW_LINE INDENT i = 1 NEW_LINE j = n - 1 NEW_LINE if ( j % 2 != 0 ) : NEW_LINE INDENT j -= 2 NEW_LINE DEDENT while ( i < j ) : NEW_LINE INDENT arr [ i ] , arr [ j ] = arr [ i ] , arr [ j ] NEW_LINE i += 2 NEW_LINE j -= 2 NEW_LINE DEDENT while ( i < j ) : NEW_LINE INDENT arr [ i ] , arr [ j ] = arr [ i ] , arr [ j ] NEW_LINE j = j - 2 NEW_LINE DEDENT arr . sort ( ) NEW_LINE DEDENT
def splitString ( str ) : NEW_LINE INDENT alpha = " " NEW_LINE num = " " NEW_LINE special = " " NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( ord ( str [ i ] ) in range ( 10 ) ) : NEW_LINE INDENT num . append ( ord ( str [ i ] ) ) NEW_LINE DEDENT elif ( ord ( str [ i ] ) >= ' A ' and ord ( str [ i ] ) <= ' Z ' ) ) : NEW_LINE INDENT alpha . append ( str [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT special . append ( str [ i ] ) NEW_LINE DEDENT DEDENT print ( alpha ) NEW_LINE num += endl NEW_LINE print ( special ) NEW_LINE DEDENT
def binaryMedian ( m , r , c ) : NEW_LINE INDENT min = 2147483647 NEW_LINE max = 2147483647 NEW_LINE for i in range ( r ) : NEW_LINE INDENT if ( m [ i ] [ 0 ] < min ) : NEW_LINE INDENT min = m [ i ] [ 0 ] NEW_LINE DEDENT if ( m [ i ] [ c - 1 ] > max ) : NEW_LINE INDENT max = m [ i ] [ c - 1 ] NEW_LINE DEDENT DEDENT desired = ( r * c + 1 ) // 2 NEW_LINE while ( min < max ) : NEW_LINE INDENT mid = min + ( max - min ) // 2 NEW_LINE place = 0 NEW_LINE for i in range ( r ) : NEW_LINE INDENT place += upper_bound ( m [ i ] , m [ i ] + c , mid ) - m [ i ] NEW_LINE DEDENT if ( place < desired ) : NEW_LINE INDENT min = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT max = mid NEW_LINE DEDENT DEDENT return min NEW_LINE DEDENT
def printDuplicates ( arr , n ) : NEW_LINE INDENT freq = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ arr [ i ] ] += 1 NEW_LINE DEDENT dup = False NEW_LINE for itr in freq . values ( ) : NEW_LINE INDENT if itr -> second > 1 : NEW_LINE INDENT print ( itr -> first , end = " ▁ " ) NEW_LINE dup = True NEW_LINE DEDENT DEDENT if dup == False : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT DEDENT
def stoogesort ( arr , l , h ) : NEW_LINE INDENT if l >= h : NEW_LINE INDENT return None NEW_LINE DEDENT if arr [ l ] > arr [ h ] : NEW_LINE INDENT arr [ l ] , arr [ h ] = arr [ l ] , arr [ h ] NEW_LINE DEDENT if ( h - l + 1 > 2 ) : NEW_LINE INDENT t = ( h - l + 1 ) / 3 NEW_LINE stoogesort ( arr , l , h - t ) NEW_LINE stoogesort ( arr , l + t , h ) NEW_LINE stoogesort ( arr , l , h - t ) NEW_LINE DEDENT DEDENT
def printEqualModNumbers ( arr , n ) : NEW_LINE INDENT arr = sorted ( arr ) NEW_LINE d = arr [ n - 1 ] - arr [ 0 ] NEW_LINE v = [ ] NEW_LINE for i in range ( 1 , d + 1 ) : NEW_LINE INDENT if ( d % i == 0 ) : NEW_LINE INDENT v . append ( i ) NEW_LINE DEDENT if ( i != d // i ) : NEW_LINE INDENT v . append ( d // i ) NEW_LINE DEDENT DEDENT for i in range ( 0 , v . size ( ) ) : NEW_LINE INDENT temp = arr [ 0 ] % v [ i ] NEW_LINE j = 1 NEW_LINE while ( j < n ) : NEW_LINE INDENT if ( arr [ j ] % v [ i ] != temp ) : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if ( j == n ) : NEW_LINE INDENT print ( v [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
def recursiveReverse ( str ) : NEW_LINE INDENT st = [ ] NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT st . append ( str [ i ] ) NEW_LINE DEDENT for i in range ( len ( str ) ) : NEW_LINE INDENT str [ i ] = st . pop ( ) NEW_LINE DEDENT DEDENT
def printRect ( X , Y , n ) : NEW_LINE INDENT Xmax = * max_element ( X , X + n ) NEW_LINE Xmin = * min_element ( X , X + n ) NEW_LINE Ymax = * max_element ( Y , Y + n ) NEW_LINE Ymin = * min_element ( Y , Y + n ) NEW_LINE print ( " { " , Xmin , " , ▁ " , Ymax , " } " ) NEW_LINE print ( " { " , Xmin , " , ▁ " , Ymin , " } " ) NEW_LINE print ( " { " , Xmax , " , ▁ " , Ymax , " } " ) NEW_LINE print ( " { " , Xmax , " , ▁ " , Ymin , " } " ) NEW_LINE print ( " { " , Xmax , " , ▁ " , Ymin , " } " ) NEW_LINE DEDENT
def NFG ( a , n , freq ) : NEW_LINE INDENT s = [ ] NEW_LINE res = [ 0 ] * n NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if freq [ a [ s . top ( ) ] ] > freq [ a [ i ] ] : NEW_LINE INDENT s . append ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT while freq [ a [ s . top ( ) ] ] < freq [ a [ i ] ] and not s . empty ( ) : NEW_LINE INDENT res [ s . pop ( ) ] = a [ i ] NEW_LINE s . pop ( ) NEW_LINE DEDENT DEDENT while len ( s ) != 0 : NEW_LINE INDENT res [ s . top ( ) ] = - 1 NEW_LINE s . pop ( ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( res [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def printEqualSumSets ( arr , n ) : NEW_LINE INDENT sum = sum ( arr , n ) NEW_LINE if ( sum & 1 ) : NEW_LINE INDENT print ( " - 1 " ) NEW_LINE return NEW_LINE DEDENT k = sum >> 1 NEW_LINE dp = [ [ False for i in range ( k + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT dp [ 0 ] [ i ] = False NEW_LINE DEDENT for i in range ( 1 , k + 1 ) : NEW_LINE INDENT dp [ i ] [ currSum ] = dp [ i - 1 ] [ currSum ] NEW_LINE if ( arr [ i - 1 ] <= currSum ) : NEW_LINE INDENT dp [ i ] [ currSum ] = dp [ i ] [ currSum ] | dp [ i - 1 ] [ currSum - arr [ i - 1 ] NEW_LINE DEDENT DEDENT DEDENT set1 , set2 = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT currSum = k NEW_LINE while ( i > 0 and currSum >= 0 ) : NEW_LINE INDENT if ( dp [ i - 1 ] [ currSum ] ) : NEW_LINE INDENT i -= 1 NEW_LINE set2 . append ( arr [ i ] ) NEW_LINE DEDENT elif ( dp [ i - 1 ] [ currSum - arr [ i - 1 ] ) : NEW_LINE INDENT print ( set1 [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT print ( " Set ▁ 1 ▁ elements : ▁ " ) NEW_LINE for i in range ( len ( set1 ) ) : NEW_LINE INDENT print ( set2 [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def reverseStr ( str1 ) : NEW_LINE INDENT n = len ( str1 ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT str1 [ i ] , str1 [ j ] = str1 [ i ] , str1 [ j ] NEW_LINE j = j - 1 NEW_LINE DEDENT DEDENT
def minimizeWithKSwaps ( n , k ) : NEW_LINE INDENT global arr NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( k > 0 ) : NEW_LINE INDENT pos = i NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( j - i > k ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( arr [ j ] < arr [ pos ] ) : NEW_LINE INDENT pos = j NEW_LINE DEDENT DEDENT for j in range ( pos , i , - 1 ) : NEW_LINE INDENT t = arr [ j ] NEW_LINE arr [ j ] = arr [ j - 1 ] NEW_LINE arr [ j - 1 ] = t NEW_LINE DEDENT k = k - pos - i NEW_LINE DEDENT DEDENT DEDENT
def countSubarrays ( arr , n ) : NEW_LINE INDENT difference = 0 NEW_LINE ans = 0 NEW_LINE hash_positive = [ 0 ] * ( n + 1 ) NEW_LINE hash_negative = [ 0 ] * ( n + 1 ) NEW_LINE fill_n ( hash_positive , n + 1 , 0 ) NEW_LINE hash_negative [ 0 ] = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] & 1 == 1 ) : NEW_LINE INDENT difference += 1 NEW_LINE DEDENT else : NEW_LINE INDENT difference -= 1 NEW_LINE DEDENT if ( difference < 0 ) : NEW_LINE INDENT ans += hash_negative [ - difference ] NEW_LINE hash_negative [ - difference ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += hash_positive [ difference ] NEW_LINE hash_positive [ difference ] += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def findPairs ( arr , n ) : NEW_LINE INDENT Hash = { } NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT Sum = arr [ i ] + arr [ j ] NEW_LINE if ( Sum in Hash ) : NEW_LINE INDENT Hash [ Sum ] = make_pair ( i , j ) NEW_LINE DEDENT else : NEW_LINE INDENT Hash [ Sum ] = make_pair ( i , j ) NEW_LINE DEDENT DEDENT DEDENT print ( " No ▁ pairs ▁ found " ) NEW_LINE return False NEW_LINE DEDENT DEDENT
def check ( s1 , s2 ) : NEW_LINE INDENT n = len ( s1 ) NEW_LINE m = len ( s2 ) NEW_LINE dp = [ [ False for x in range ( m + 1 ) ] for y in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( m + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = False NEW_LINE DEDENT DEDENT dp [ 0 ] [ 0 ] = True NEW_LINE for i in range ( len ( s1 ) ) : NEW_LINE INDENT for j in range ( 0 , len ( s2 ) + 1 ) : NEW_LINE INDENT if ( dp [ i ] [ j ] ) : NEW_LINE INDENT if ( j < len ( s1 ) and ( toupper ( s1 [ i ] ) == s2 [ j ] ) ) : NEW_LINE INDENT dp [ i + 1 ] [ j + 1 ] = True NEW_LINE DEDENT if ( not isupper ( s1 [ i ] ) ) : NEW_LINE INDENT dp [ i + 1 ] [ j ] = True NEW_LINE DEDENT DEDENT DEDENT return ( dp [ n ] [ m ] ) NEW_LINE DEDENT
def checkDuplicatesWithinK ( arr , n , k ) : NEW_LINE INDENT myset = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] in myset : NEW_LINE INDENT return True NEW_LINE DEDENT myset . add ( arr [ i ] ) NEW_LINE if i >= k : NEW_LINE INDENT myset . remove ( arr [ i - k ] ) NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def minOperation ( arr , n ) : NEW_LINE INDENT hash = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT hash [ arr [ i ] ] += 1 NEW_LINE DEDENT max_count = 0 NEW_LINE for i in range ( auto ) : NEW_LINE INDENT if ( max_count < i . second ) : NEW_LINE INDENT max_count = i . second NEW_LINE DEDENT DEDENT return ( n - max_count ) NEW_LINE DEDENT
def findSum ( string ) : NEW_LINE INDENT temp = string NEW_LINE sum = 0 NEW_LINE for ch in string : NEW_LINE INDENT if ( isdigit ( ch ) ) : NEW_LINE INDENT temp += ch NEW_LINE DEDENT else : NEW_LINE INDENT sum += ord ( temp ) NEW_LINE temp = " " NEW_LINE DEDENT DEDENT return sum + atoi ( temp ) NEW_LINE DEDENT
def mostFrequent ( arr , n ) : NEW_LINE INDENT hash = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT hash [ arr [ i ] ] += 1 NEW_LINE DEDENT max_count = 0 NEW_LINE res = - 1 NEW_LINE for i in hash : NEW_LINE INDENT if ( max_count < i . second ) : NEW_LINE INDENT res = i . first NEW_LINE max_count = i . second NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def firstLetterWord ( str ) : NEW_LINE INDENT result = " " NEW_LINE v = True NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] == ' ▁ ' ) : NEW_LINE INDENT v = True NEW_LINE DEDENT elif ( str [ i ] != ' ▁ ' and v == True ) : NEW_LINE INDENT result . append ( str [ i ] ) NEW_LINE v = False NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def decode ( str ) : NEW_LINE INDENT integerstack = [ ] NEW_LINE stringstack = [ ] NEW_LINE result = " " NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT count = 0 NEW_LINE if ( str [ i ] >= '0' and str [ i ] <= '9' ) : NEW_LINE INDENT while ( str [ i ] >= '0' and str [ i ] <= '9' ) : NEW_LINE INDENT count = count * 10 + str [ i ] - '0' NEW_LINE i += 1 NEW_LINE DEDENT integerstack . append ( count ) NEW_LINE DEDENT elif ( str [ i ] == ' [ ' ) : NEW_LINE INDENT temp = " " NEW_LINE count = 0 NEW_LINE if ( not integerstack . empty ( ) ) : NEW_LINE INDENT count = integerstack . top ( ) NEW_LINE stringstack . pop ( ) NEW_LINE DEDENT if ( not stringstack . empty ( ) and stringstack . top ( ) == ' [ ' ) : NEW_LINE INDENT stringstack . append ( result ) NEW_LINE DEDENT result = " " NEW_LINE DEDENT elif ( str [ i ] == ' [ ' ) : NEW_LINE INDENT if ( str [ i - 1 ] >= '0' and str [ i - 1 ] <= '9' ) : NEW_LINE INDENT stringstack . append ( str [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT stringstack . append ( str [ i ] ) NEW_LINE integerstack . append ( 1 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT stringstack . append ( str [ i ] ) NEW_LINE DEDENT DEDENT while ( stringstack . empty ( ) ) : NEW_LINE INDENT result = stringstack . top ( ) + result NEW_LINE stringstack . pop ( ) NEW_LINE DEDENT return result NEW_LINE DEDENT
def minSum ( A , n ) : NEW_LINE INDENT min_val = * min_element ( A , A + n ) NEW_LINE return ( min_val * ( n - 1 ) ) NEW_LINE DEDENT
def countWords ( str , n ) : NEW_LINE INDENT m = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT m [ ord ( str [ i ] ) - 97 ] += 1 NEW_LINE DEDENT res = 0 NEW_LINE for it in m : NEW_LINE INDENT if ( ( it -> second == 2 ) ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def sortUsingHash ( a , n ) : NEW_LINE INDENT max = max ( a , n ) NEW_LINE hash = [ 0 for i in range ( max + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT hash [ a [ i ] ] += 1 NEW_LINE DEDENT for i in range ( max + 1 ) : NEW_LINE INDENT if ( hash [ i ] != 0 ) : NEW_LINE INDENT for j in range ( hash [ i ] ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
def isDivisible ( str , k ) : NEW_LINE INDENT n = len ( str ) NEW_LINE c = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT if ( str [ n - i - 1 ] == '0' ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT return ( c == k ) NEW_LINE DEDENT
def divisible ( num ) : NEW_LINE INDENT n = len ( num ) NEW_LINE sum = accumulate ( begin ( num ) , end ( num ) , 0 ) - '0' * 1 NEW_LINE if ( sum % 3 == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( sum % 3 == ( num [ i ] - '0' ) % 3 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n == 2 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return 2 NEW_LINE DEDENT
def reverse ( str ) : NEW_LINE INDENT if ( len ( str ) == 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT reverse ( str ) NEW_LINE print ( str [ 0 ] , end = " " ) NEW_LINE DEDENT
def isDvisibleBy12 ( num ) : NEW_LINE INDENT if ( len ( num ) >= 3 ) : NEW_LINE INDENT d1 = ord ( num [ 0 ] ) NEW_LINE if ( d1 % 2 != 0 ) : NEW_LINE INDENT return ( 0 ) NEW_LINE DEDENT d2 = ( int ) num [ len ( num ) - 2 ] NEW_LINE sum = 0 NEW_LINE for i in range ( 0 , len ( num ) ) : NEW_LINE INDENT sum += num [ i ] NEW_LINE DEDENT return ( sum % 3 == 0 and ( d2 * 10 + d1 ) % 4 == 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT number = ord ( num ) NEW_LINE return ( number % 12 == 0 ) NEW_LINE DEDENT DEDENT
def xorZero ( str ) : NEW_LINE INDENT one_count = 0 NEW_LINE zero_count = 0 NEW_LINE n = len ( str ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( str [ i ] == '1' ) : NEW_LINE INDENT one_count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT zero_count += 1 NEW_LINE DEDENT DEDENT if ( one_count % 2 == 0 ) : NEW_LINE INDENT return zero_count NEW_LINE DEDENT return one_count NEW_LINE DEDENT
def nthRoot ( A , N ) : NEW_LINE INDENT xPre = rand ( ) % 10 NEW_LINE eps = 1e - 3 NEW_LINE delX = sys . maxsize NEW_LINE xK = ( ( N - 1.0 ) * xPre + ( double ) A / pow ( xPre , N - 1 ) ) / ( double ) N NEW_LINE delX = abs ( xK - xPre ) NEW_LINE xPre = xK NEW_LINE DEDENT return xK NEW_LINE DEDENT
def findLeft ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE while n >= 0 : NEW_LINE INDENT if str [ n ] == ' d ' : NEW_LINE INDENT str [ n ] = ' c ' NEW_LINE break NEW_LINE DEDENT if str [ n ] == ' b ' : NEW_LINE INDENT str [ n ] = ' a ' NEW_LINE break NEW_LINE DEDENT if str [ n ] == ' a ' : NEW_LINE INDENT str [ n ] = ' b ' NEW_LINE break NEW_LINE DEDENT if str [ n ] == ' b ' : NEW_LINE INDENT str [ n ] = ' a ' NEW_LINE DEDENT elif str [ n ] == ' c ' : NEW_LINE INDENT str [ n ] = ' d ' NEW_LINE DEDENT DEDENT return str NEW_LINE DEDENT
def minRange ( arr , n , k ) : NEW_LINE INDENT l = 0 NEW_LINE r = n NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE j = i NEW_LINE while ( j < n ) : NEW_LINE INDENT s . add ( arr [ j ] ) NEW_LINE if ( s . size ( ) == k ) : NEW_LINE INDENT if ( ( j - i ) < ( r - l ) ) : NEW_LINE INDENT r = j NEW_LINE l = i NEW_LINE DEDENT break NEW_LINE DEDENT DEDENT if ( j == n ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( l == 0 and r == n ) : NEW_LINE INDENT print ( " Invalid ▁ k " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( l , " ▁ " , r ) NEW_LINE DEDENT DEDENT
def findSum ( A , B , n ) : NEW_LINE INDENT hash = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT hash [ A [ i ] ] += 1 NEW_LINE hash [ B [ i ] ] += 1 NEW_LINE DEDENT sum = 0 NEW_LINE for auto in hash : NEW_LINE INDENT if ( x . second == 1 ) : NEW_LINE INDENT sum += x . first NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def arrayEvenAndOdd ( arr , n ) : NEW_LINE INDENT i = - 1 NEW_LINE j = 0 NEW_LINE while ( j != n ) : NEW_LINE INDENT if ( arr [ j ] % 2 == 0 ) : NEW_LINE INDENT i += 1 NEW_LINE arr [ i ] , arr [ j ] = arr [ i ] , arr [ j ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def containsOdd ( G , src ) : NEW_LINE INDENT colorArr = [ 0 ] * V NEW_LINE for i in range ( V ) : NEW_LINE INDENT colorArr [ i ] = - 1 NEW_LINE DEDENT colorArr [ src ] = 1 NEW_LINE q = queue . Queue ( ) NEW_LINE q . put ( src ) NEW_LINE while ( not q . empty ( ) ) : NEW_LINE INDENT u = q . get ( ) NEW_LINE if ( G [ u ] [ u ] == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT for v in range ( V ) : NEW_LINE INDENT if ( G [ u ] [ v ] and colorArr [ v ] == - 1 ) : NEW_LINE INDENT colorArr [ v ] = 1 - colorArr [ u ] NEW_LINE q . put ( v ) NEW_LINE DEDENT elif ( G [ u ] [ v ] and colorArr [ v ] == colorArr [ u ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT
def getMinSquares ( n ) : NEW_LINE INDENT if ( math . sqrt ( n ) - floor ( math . sqrt ( n ) ) == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return n NEW_LINE DEDENT res = n NEW_LINE for x in range ( 1 , n + 1 ) : NEW_LINE INDENT temp = x * x NEW_LINE if ( temp > n ) : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT res = min ( res , 1 + getMinSquares ( n - temp ) ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def selectRandom ( x ) : NEW_LINE INDENT res = x NEW_LINE count += 1 NEW_LINE if ( count == 1 ) : NEW_LINE INDENT res = x NEW_LINE DEDENT else : NEW_LINE INDENT i = rand ( ) % count NEW_LINE if ( i == count - 1 ) : NEW_LINE INDENT res = x NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def cost ( a , n ) : NEW_LINE INDENT return ( n - 1 ) * ( * min_element ( a , a + n ) ) NEW_LINE DEDENT
def gnomeSort ( arr , n ) : NEW_LINE INDENT index = 0 NEW_LINE while index < n : NEW_LINE INDENT if index == 0 : NEW_LINE INDENT index += 1 NEW_LINE DEDENT if arr [ index ] >= arr [ index - 1 ] : NEW_LINE INDENT index += 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ index ] , arr [ index - 1 ] = arr [ index ] , arr [ index - 1 ] NEW_LINE index -= 1 NEW_LINE DEDENT DEDENT return NEW_LINE DEDENT
def sortedAfterSwap ( A , B , n ) : NEW_LINE INDENT for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( B [ i ] ) : NEW_LINE INDENT if ( A [ i ] != i + 1 ) : NEW_LINE INDENT t = A [ i ] NEW_LINE A [ i ] = t + 1 NEW_LINE DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( A [ i ] != i + 1 ) : NEW_LINE INDENT t = A [ i ] NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def moveSpaceInFront ( str ) : NEW_LINE INDENT i = len ( str ) NEW_LINE for j in range ( i ) : NEW_LINE INDENT if ( str [ j ] != ' ▁ ' ) : NEW_LINE INDENT str [ i - ] = str [ j ] NEW_LINE DEDENT DEDENT while i >= 0 : NEW_LINE INDENT str [ i - ] = ' ▁ ' NEW_LINE DEDENT DEDENT
def countOfBinaryNumberLessThanN ( N ) : NEW_LINE INDENT q = Queue ( ) NEW_LINE q . put ( 1 ) NEW_LINE cnt = 0 NEW_LINE t = 0 NEW_LINE while ( not q . empty ( ) ) : NEW_LINE INDENT t = q . get ( ) NEW_LINE q . get ( ) NEW_LINE if ( t <= N ) : NEW_LINE INDENT cnt += 1 NEW_LINE q . put ( t * 10 ) NEW_LINE q . put ( t * 10 + 1 ) NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT
def substringConversions ( str , k , b ) : NEW_LINE INDENT i = 0 NEW_LINE sum = 0 NEW_LINE counter = k - 1 NEW_LINE for i in range ( 0 , k ) : NEW_LINE INDENT Sum = Sum + ( ( ord ( str [ i ] ) - ord ( '0' ) * pow ( b , counter ) ) NEW_LINE counter -= 1 NEW_LINE DEDENT print ( Sum , end = " ▁ " ) NEW_LINE prev = Sum NEW_LINE sum = 0 NEW_LINE counter = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT Sum = prev - ( ord ( str [ i - k ) - ord ( '0' ) ) * pow ( b , k - 1 ) ) NEW_LINE Sum = sum * b NEW_LINE Sum = sum + ( ord ( str [ i ] ) - ord ( '0' ) ) NEW_LINE print ( Sum , end = " ▁ " ) NEW_LINE prev = Sum NEW_LINE counter += 1 NEW_LINE DEDENT DEDENT
def longestRepeatedSubSeq ( str1 ) : NEW_LINE INDENT n = len ( str1 ) NEW_LINE dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( str1 [ i - 1 ] == str1 [ j - 1 ] and i != j ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT res = " " NEW_LINE i = n NEW_LINE j = n NEW_LINE while i > 0 and j > 0 : NEW_LINE INDENT if ( dp [ i ] [ j ] == dp [ i - 1 ] [ j - 1 ] + 1 ) : NEW_LINE INDENT res = res + str1 [ i - 1 ] NEW_LINE i -= 1 NEW_LINE j -= 1 NEW_LINE DEDENT elif ( dp [ i ] [ j ] == dp [ i - 1 ] [ j ] ) : NEW_LINE INDENT i -= 1 NEW_LINE j -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def rearrange ( a , size ) : NEW_LINE INDENT positive = 0 NEW_LINE negative = 1 NEW_LINE while ( True ) : NEW_LINE INDENT while ( positive < size and a [ positive ] >= 0 ) : NEW_LINE INDENT positive += 2 NEW_LINE DEDENT while ( negative < size and a [ negative ] <= 0 ) : NEW_LINE INDENT negative += 2 NEW_LINE DEDENT if ( positive < size and negative < size ) : NEW_LINE INDENT swap ( a [ positive ] , a [ negative ] ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT
def bubbleSort ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n - 1 ) : NEW_LINE INDENT for j in range ( 0 , n - i - 1 ) : NEW_LINE INDENT if arr [ j ] > arr [ j + 1 ] : NEW_LINE INDENT arr [ j ] , arr [ j + 1 ] = arr [ j + 1 ] , arr [ j ] NEW_LINE DEDENT DEDENT DEDENT
def reversingString ( str , start , end ) : NEW_LINE INDENT while ( start < end ) : NEW_LINE INDENT str [ start ] ^= str [ end ] NEW_LINE str [ end ] ^= str [ start ] NEW_LINE start += 1 NEW_LINE end -= 1 NEW_LINE DEDENT return str NEW_LINE DEDENT
def minimalSteps ( s , n ) : NEW_LINE INDENT dp = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp [ i ] = sys . maxsize NEW_LINE DEDENT s1 = " " NEW_LINE s2 = " " NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT s1 += s [ i ] NEW_LINE s2 = s . substr ( i + 1 , i + 1 ) NEW_LINE dp [ i ] = min ( dp [ i ] , dp [ i - 1 ] + 1 ) NEW_LINE if ( s1 == s2 ) : NEW_LINE INDENT dp [ i * 2 + 1 ] = min ( dp [ i ] + 1 , dp [ i * 2 + 1 ] ) NEW_LINE DEDENT DEDENT return dp [ n - 1 ] NEW_LINE DEDENT
def MinimumCost ( cost , n , W ) : NEW_LINE INDENT val = [ 0 ] * W NEW_LINE wt = [ 0 for i in range ( W + 1 ) ] NEW_LINE size = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( cost [ i ] != - 1 ) : NEW_LINE INDENT val . append ( cost [ i ] ) NEW_LINE wt . append ( i + 1 ) NEW_LINE size += 1 NEW_LINE DEDENT DEDENT min_cost = [ [ 0 for i in range ( 1 , n + 1 ) ] NEW_LINE for j in range ( 1 , W + 1 ) : NEW_LINE INDENT if ( wt [ i - 1 ] > j ) : NEW_LINE INDENT min_cost [ i ] [ j ] = min_cost [ i - 1 ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT min_cost [ i ] [ j ] = min ( min_cost [ i - 1 ] [ j ] , min_cost [ i ] [ j - wt [ i - 1 ] + val [ i - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return - 1 if min_cost [ n ] [ W ] == INF else min_cost [ n ] [ W ] NEW_LINE DEDENT
def bitonicGenerator ( arr , n ) : NEW_LINE INDENT evenArr = [ 0 ] * n NEW_LINE oddArr = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( not ( i % 2 ) ) : NEW_LINE INDENT evenArr . append ( arr [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT oddArr . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT sort ( evenArr ) NEW_LINE for j in range ( 0 , evenArr . size ( ) ) : NEW_LINE INDENT arr [ i ] = evenArr [ j ] NEW_LINE DEDENT for j in range ( 0 , oddArr . size ( ) ) : NEW_LINE INDENT arr [ i ] = oddArr [ j ] NEW_LINE DEDENT DEDENT
def printFirstRepeating ( arr , n ) : NEW_LINE INDENT min = - 1 NEW_LINE myset = set ( ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if arr [ i ] in myset : NEW_LINE INDENT min = i NEW_LINE DEDENT else : NEW_LINE INDENT myset . add ( arr [ i ] ) NEW_LINE DEDENT DEDENT if min != - 1 : NEW_LINE INDENT print ( " The ▁ first ▁ repeating ▁ element ▁ is : ▁ " , arr [ min ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " There ▁ are ▁ no ▁ repeating ▁ elements " ) NEW_LINE DEDENT DEDENT
def lps ( str1 ) : NEW_LINE INDENT n = len ( str1 ) NEW_LINE L = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT L [ i ] [ i ] = 1 NEW_LINE DEDENT for cl in range ( 2 , n + 1 ) : NEW_LINE INDENT for i in range ( n - cl + 1 ) : NEW_LINE INDENT j = i + cl - 1 NEW_LINE if ( str1 [ i ] == str1 [ j ] and cl == 2 ) : NEW_LINE INDENT L [ i ] [ j ] = 2 NEW_LINE DEDENT elif ( str1 [ i ] == str1 [ j ] ) : NEW_LINE INDENT L [ i ] [ j ] = L [ i + 1 ] [ j - 1 ] + 2 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] = max ( L [ i ] [ j - 1 ] , L [ i + 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return L [ 0 ] [ n - 1 ] NEW_LINE DEDENT
def censor ( text , word ) : NEW_LINE INDENT word_list = [ ] NEW_LINE result = [ ] NEW_LINE stars = [ ] NEW_LINE for i in range ( len ( word ) ) : NEW_LINE INDENT stars += chr ( i ) NEW_LINE DEDENT index = 0 NEW_LINE for i in range ( len ( word_list ) ) : NEW_LINE INDENT if ( word [ index ] == word ) : NEW_LINE INDENT word_list [ index ] = stars NEW_LINE DEDENT index += 1 NEW_LINE DEDENT DEDENT for i in word_list : NEW_LINE INDENT result += i + ' ▁ ' NEW_LINE DEDENT return result NEW_LINE DEDENT
def isRotated ( str1 , str2 ) : NEW_LINE INDENT if ( len ( str1 ) != len ( str2 ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT clock_rot = " " NEW_LINE anticlock_rot = " " NEW_LINE len = len ( str2 ) NEW_LINE anticlock_rot = anticlock_rot + str2 . substr ( len - 2 , 2 ) + str2 . substr ( 0 , len - 2 ) NEW_LINE clock_rot = clock_rot + str2 . substr ( 2 ) + str2 [ 0 , 2 ) NEW_LINE return ( str1 . compare ( clock_rot ) == 0 or str1 . compare ( anticlock_rot ) == 0 ) NEW_LINE DEDENT
def findDiff ( arr , n ) : NEW_LINE INDENT hm = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT hm [ arr [ i ] ] += 1 NEW_LINE DEDENT max_count = 0 NEW_LINE min_count = n NEW_LINE for x in hm : NEW_LINE INDENT max_count = max ( max_count , x . second ) NEW_LINE min_count = min ( min_count , x . second ) NEW_LINE DEDENT return ( max_count - min_count ) NEW_LINE DEDENT
def playGame ( arr , n ) : NEW_LINE INDENT hash = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT hash . add ( arr [ i ] ) NEW_LINE DEDENT return ( len ( hash ) % 2 == 0 ? 1 : 2 ) NEW_LINE DEDENT
def subset ( arr , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT res = 0 NEW_LINE for auto in mp : NEW_LINE INDENT res = max ( res , x . first ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def isProduct ( arr , n , x ) : NEW_LINE INDENT if ( n < 2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT s = set ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] == 0 ) : NEW_LINE INDENT if ( x == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT continue NEW_LINE DEDENT DEDENT if ( x % arr [ i ] == 0 ) : NEW_LINE INDENT if ( x // arr [ i ] ) in s : NEW_LINE INDENT return True NEW_LINE DEDENT s . add ( arr [ i ] ) NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def findRotations ( str ) : NEW_LINE INDENT tmp = str + str NEW_LINE n = len ( str ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT substring = tmp [ i : ] NEW_LINE if ( str == substring ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return n NEW_LINE DEDENT
def randomize ( arr , n ) : NEW_LINE INDENT srand = random . rand ( ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT j = rand ( ) % ( i + 1 ) NEW_LINE arr [ i ] = arr [ j ] NEW_LINE arr [ j ] = arr [ i ] NEW_LINE DEDENT DEDENT
def translate ( st ) : NEW_LINE INDENT lenn = len ( st ) NEW_LINE if ( lenn < 2 ) : NEW_LINE INDENT return NEW_LINE DEDENT i = 0 NEW_LINE j = 0 NEW_LINE while ( j < lenn ) : NEW_LINE INDENT if ( st [ j ] == ' A ' and st [ j + 1 ] == ' B ' ) : NEW_LINE INDENT j = j + 2 NEW_LINE str [ i ] = ' C ' NEW_LINE continue NEW_LINE DEDENT st [ i ] = st [ j ] NEW_LINE j += 1 NEW_LINE DEDENT if ( j == len - 1 ) : NEW_LINE INDENT st [ i ] = st [ j ] NEW_LINE i += 1 NEW_LINE DEDENT st [ i ] = ' ' NEW_LINE DEDENT DEDENT
def numberofways ( A , B , N , M ) : NEW_LINE INDENT pos = [ ] NEW_LINE for i in range ( M ) : NEW_LINE INDENT pos [ B [ i ] ] . append ( i + 1 ) NEW_LINE DEDENT dpl = [ [ 0 for i in range ( N + 2 ) ] for j in range ( M + 2 ) ] NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( 1 , M + 1 ) : NEW_LINE INDENT if ( A [ i - 1 ] == B [ j - 1 ] ) : NEW_LINE INDENT dpl [ i ] [ j ] = dpl [ i - 1 ] [ j - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT dpl [ i ] [ j ] = max ( dpl [ i - 1 ] [ j ] , dpl [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT LCS = dpr [ N ] [ M ] NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( 1 , M + 1 ) : NEW_LINE INDENT if ( A [ i - 1 ] == B [ j - 1 ] ) : NEW_LINE INDENT dpr [ i ] [ j ] = dpr [ i + 1 ] [ j + 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT dpr [ i ] [ j ] = max ( dpr [ i + 1 ] [ j ] , dpr [ i ] [ j + 1 ] ) NEW_LINE DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT for j in range ( MAX ) : NEW_LINE INDENT if ( dpl [ i ] [ x - 1 ] + dpr [ i + 1 ] [ x + 1 ] == LCS ) : NEW_LINE INDENT ans += 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def substringConversions ( str , k , b ) : NEW_LINE INDENT for i in range ( k ) : NEW_LINE INDENT sub = str [ i : i + k ] NEW_LINE sum = 0 NEW_LINE counter = 0 NEW_LINE for i in range ( len ( sub ) - 1 ) : NEW_LINE INDENT sum = sum + ( ( sub [ i ] - ord ( '0' ) ) * pow ( b , counter ) ) NEW_LINE counter = counter + 1 NEW_LINE DEDENT print ( sum , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def SumOfKsubArray ( arr , n , k ) : NEW_LINE INDENT sum = 0 NEW_LINE s = deque ( k ) NEW_LINE G = deque ( k ) NEW_LINE for i in range ( k ) : NEW_LINE INDENT while ( len ( s ) > 0 ) and arr [ S . back ( ) ] >= arr [ i ] ) : NEW_LINE INDENT S . remove ( s [ 0 ] ) NEW_LINE DEDENT while ( len ( G ) > 0 ) and arr [ G . back ( ) ] <= arr [ i ] ) : NEW_LINE INDENT G . pop_back ( ) NEW_LINE DEDENT G . append ( i ) NEW_LINE S . append ( i ) NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT sum += arr [ S . front ( ) ] + arr [ G . front ( ) ] NEW_LINE while ( len ( s ) > 0 ) and arr [ S . back ( ) ] <= arr [ i ] ) : NEW_LINE INDENT S . pop_back ( ) NEW_LINE DEDENT while ( len ( G ) > 0 ) and arr [ G . back ( ) ] <= arr [ i ] ) : NEW_LINE INDENT G . pop_back ( ) NEW_LINE DEDENT G . append ( i ) NEW_LINE S . append ( i ) NEW_LINE DEDENT DEDENT sum += arr [ S . front ( ) ] + arr [ G . front ( ) ] NEW_LINE return sum NEW_LINE DEDENT
def arrangeString ( str ) : NEW_LINE INDENT char_count = [ 0 for i in range ( MAX_CHAR ) ] NEW_LINE sum = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] >= ' A ' and str [ i ] <= ' Z ' ) : NEW_LINE INDENT char_count [ ord ( str [ i ] ) - ord ( ' A ' ) ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT sum = sum + ( ord ( str [ i ] ) - ord ( '0' ) ) NEW_LINE DEDENT DEDENT res = " " NEW_LINE for i in range ( MAX_CHAR ) : NEW_LINE INDENT ch = ord ( ' A ' + i ) NEW_LINE while ( char_count [ i ] > 0 ) : NEW_LINE INDENT res = res + chr ( ord ( res ) ) NEW_LINE DEDENT DEDENT if ( sum > 0 ) : NEW_LINE INDENT res = res + to_string ( sum ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def waysToIncreaseLCSBy1 ( str1 , str2 ) : NEW_LINE INDENT m = len ( str1 ) NEW_LINE n = len ( str2 ) NEW_LINE position = [ [ 0 for i in range ( n + 2 ) ] for j in range ( n + 2 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( str1 [ i - 1 ] == str2 [ j - 1 ] ) : NEW_LINE INDENT lcsl [ i ] [ j ] = 1 + lcsl [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT lcsl [ i ] [ j ] = max ( lcsl [ i - 1 ] [ j ] , lcsl [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( str1 [ i - 1 ] == str2 [ j - 1 ] ) : NEW_LINE INDENT lcsl [ i ] [ j ] = 1 + lcsl [ i + 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT lcsr [ i ] [ j ] = max ( lcsr [ i + 1 ] [ j ] , lcsr [ i ] [ j + 1 ] ) NEW_LINE DEDENT DEDENT DEDENT ways = 0 NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for c in range ( ' a ' , ' z ' ) : NEW_LINE INDENT for j in range ( len ( position ) ) : NEW_LINE INDENT p = position [ toInt ( c ) ] [ j ] NEW_LINE DEDENT if ( lcsl [ i ] [ p - 1 ] + lcsr [ i + 1 ] [ p + 1 ] == lcsl [ m ] [ n ] ) : NEW_LINE INDENT ways += 1 NEW_LINE DEDENT DEDENT DEDENT return ways NEW_LINE DEDENT
def lis ( arr , n ) : NEW_LINE INDENT lis = [ 0 for i in range ( n ) ] NEW_LINE lis [ 0 ] = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT lis [ i ] = 1 NEW_LINE for j in range ( i ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and lis [ i ] < lis [ j ] + 1 ) : NEW_LINE INDENT lis [ i ] = lis [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT return * max_element ( lis , lis + n ) NEW_LINE DEDENT
def SternSequenceFunc ( BrocotSequence , n ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT considered_element = BrocotSequence [ i ] NEW_LINE precedent = BrocotSequence [ i - 1 ] NEW_LINE BrocotSequence . append ( considered_element + precedent ) NEW_LINE BrocotSequence . append ( considered_element ) NEW_LINE DEDENT for i in range ( 15 ) : NEW_LINE INDENT print ( BrocotSequence [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def printBracketNumber ( exp , n ) : NEW_LINE INDENT left_bnum = 1 NEW_LINE right_bnum = [ 0 ] * n NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if exp [ i ] == ' ( ' ) : NEW_LINE INDENT print ( left_bnum , end = " ▁ " ) NEW_LINE right_bnum . append ( left_bnum ) NEW_LINE left_bnum += 1 NEW_LINE DEDENT elif exp [ i ] == ' ( ' ) : NEW_LINE INDENT print ( right_bnum [ - 1 ] , end = " ▁ " ) NEW_LINE right_bnum . pop ( ) NEW_LINE DEDENT DEDENT DEDENT
def returnMaxSum ( A , B , n ) : NEW_LINE INDENT mp = set ( ) NEW_LINE result = 0 NEW_LINE curr_sum = 0 NEW_LINE curr_begin = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT while mp . add ( A [ i ] ) : NEW_LINE INDENT curr_sum -= B [ curr_begin ] NEW_LINE curr_begin += 1 NEW_LINE DEDENT mp . add ( A [ i ] ) NEW_LINE curr_sum += B [ i ] NEW_LINE result = max ( result , curr_sum ) NEW_LINE DEDENT return result NEW_LINE DEDENT
def rearrange ( arr , n ) : NEW_LINE INDENT i = - 1 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if arr [ j ] < 0 : NEW_LINE INDENT i += 1 NEW_LINE DEDENT arr [ j ] = - arr [ j ] NEW_LINE DEDENT DEDENT pos = i + 1 NEW_LINE neg = 0 NEW_LINE while pos < n and neg < pos and arr [ neg ] < 0 : NEW_LINE INDENT arr [ neg ] , arr [ pos ] = arr [ neg ] , arr [ pos ] NEW_LINE pos += 1 NEW_LINE neg += 2 NEW_LINE DEDENT DEDENT
def largestGCDSubsequence ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE maxele = * max_element ( arr , arr + n ) NEW_LINE for i in range ( 2 , maxele + 1 ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( arr [ j ] % i == 0 ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT ans = max ( ans , count ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def isNumber ( s ) : NEW_LINE INDENT for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT if ( isdigit ( s [ i ] ) == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def countPairs ( arr1 , arr2 , m , n , x ) : NEW_LINE INDENT count = 0 NEW_LINE us = set ( ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT us . add ( arr1 [ i ] ) NEW_LINE DEDENT for j in range ( n ) : NEW_LINE INDENT if ( x - arr2 [ j ] ) not in us : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def lis ( arr , n ) : NEW_LINE INDENT lis = [ 0 for i in range ( n ) ] NEW_LINE lis [ 0 ] = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT lis [ i ] = 1 NEW_LINE for j in range ( i ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and lis [ i ] < lis [ j ] + 1 ) : NEW_LINE INDENT lis [ i ] = lis [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT return * max_element ( lis , lis + n ) NEW_LINE DEDENT
def findSubString ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE dist_count = 0 NEW_LINE visited = [ False ] * MAX_CHARS NEW_LINE for i in range ( n ) : NEW_LINE INDENT if visited [ ord ( str [ i ] ) ] == False : NEW_LINE INDENT visited [ ord ( str [ i ] ) ] = True NEW_LINE dist_count += 1 NEW_LINE DEDENT DEDENT start = 0 NEW_LINE start_index = - 1 NEW_LINE min_len = 10 ** 9 NEW_LINE count = 0 NEW_LINE curr_count = [ 0 ] * MAX_CHARS NEW_LINE for j in range ( n ) : NEW_LINE INDENT curr_count [ ord ( str [ j ] ) ] += 1 NEW_LINE if curr_count [ ord ( str [ start ] ) ] == 1 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( count == dist_count ) : NEW_LINE INDENT while curr_count [ ord ( str [ start ] ) ] > 1 ) : NEW_LINE INDENT if curr_count [ ord ( str [ start ] ) ] > 1 : NEW_LINE INDENT curr_count [ ord ( str [ start ] ) ] -= 1 NEW_LINE start += 1 NEW_LINE DEDENT DEDENT len_window = j - start + 1 NEW_LINE if min_len > len_window : NEW_LINE INDENT min_len = len_window NEW_LINE start_index = start NEW_LINE DEDENT DEDENT return str [ start_index , min_len NEW_LINE DEDENT
def printSubsequences ( arr , n ) : NEW_LINE INDENT opsize = ( int ) ( math . pow ( 2 , n ) ) NEW_LINE counter = 1 NEW_LINE for counter in range ( 1 , opsize ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT if ( ( counter & ( 1 << j ) ) > 0 ) : NEW_LINE INDENT print ( arr [ j ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT
def bin ( n ) : NEW_LINE INDENT if ( n > 1 ) : NEW_LINE INDENT bin ( n >> 1 ) NEW_LINE DEDENT print ( " % d " , n & 1 ) NEW_LINE DEDENT
def minimumSquare ( a , b ) : NEW_LINE INDENT result = 0 NEW_LINE rem = 0 NEW_LINE if a < b : NEW_LINE INDENT swap ( a , b ) NEW_LINE DEDENT while b > 0 : NEW_LINE INDENT result += a // b NEW_LINE rem = a % b NEW_LINE a = b NEW_LINE b = rem NEW_LINE DEDENT return result NEW_LINE DEDENT
def deleteElements ( arr , n , k ) : NEW_LINE INDENT s = [ ] NEW_LINE s . append ( arr [ 0 ] ) NEW_LINE count = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT while ( len ( s ) > 0 and s [ - 1 ] < arr [ i ] and count < k ) : NEW_LINE INDENT s . pop ( ) NEW_LINE count += 1 NEW_LINE DEDENT s . append ( arr [ i ] ) NEW_LINE DEDENT m = len ( s ) NEW_LINE v = [ 0 ] * m NEW_LINE while ( len ( s ) > 0 ) : NEW_LINE INDENT v [ m ] = s [ - 1 ] NEW_LINE s . pop ( ) NEW_LINE DEDENT for auto x in v : NEW_LINE INDENT print ( x , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT
def first ( str ) : NEW_LINE INDENT for i in range ( len ( str ) ) : NEW_LINE INDENT if ( isupper ( str [ i ] ) ) : NEW_LINE INDENT return str [ i ] NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT
def isPossible ( n , index , modulo , M , arr , dp ) : NEW_LINE INDENT M = ( ( modulo % M ) + M ) % M NEW_LINE if ( index == n ) : NEW_LINE INDENT if ( modulo == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT if ( dp [ index ] [ modulo ] != - 1 ) : NEW_LINE INDENT return dp [ index ] [ modulo ] NEW_LINE DEDENT placeAdd = isPossible ( n , index + 1 , modulo + arr [ index ] , M , arr , dp ) NEW_LINE placeMinus = isPossible ( n , index + 1 , modulo - arr [ index ] , M , arr , dp ) NEW_LINE res = ( placeAdd or placeMinus ) NEW_LINE dp [ index ] [ modulo ] = res NEW_LINE return res NEW_LINE DEDENT
def amendSentence ( str ) : NEW_LINE INDENT for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] >= ' A ' and str [ i ] <= ' Z ' ) : NEW_LINE INDENT str [ i ] = str [ i ] + 32 NEW_LINE if ( i != 0 ) : NEW_LINE INDENT print ( str [ i ] , end = " ▁ " ) NEW_LINE DEDENT print ( str [ i ] ) NEW_LINE DEDENT DEDENT
def find ( a , b , k , n1 , n2 ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( n2 ) : NEW_LINE INDENT s . add ( b [ i ] ) NEW_LINE DEDENT missing = 0 NEW_LINE for i in range ( n1 ) : NEW_LINE INDENT if ( a [ i ] not in s ) : NEW_LINE INDENT missing += 1 NEW_LINE DEDENT if ( missing == k ) : NEW_LINE INDENT return a [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def countNumber ( n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 1 , 9 ) : NEW_LINE INDENT s = [ ] NEW_LINE if i <= n : NEW_LINE INDENT s . append ( i ) NEW_LINE result += 1 NEW_LINE DEDENT DEDENT while len ( s ) > 0 : NEW_LINE INDENT tp = s [ - 1 ] NEW_LINE s . pop ( ) NEW_LINE for j in range ( tp % 10 , 9 ) : NEW_LINE INDENT x = tp * 10 + j NEW_LINE if x <= n : NEW_LINE INDENT s . append ( x ) NEW_LINE result += 1 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
def getMaxOccuringChar ( str ) : NEW_LINE INDENT count = [ 0 for i in range ( ASCII_SIZE ) ] NEW_LINE max = 0 NEW_LINE result = ' ' NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT count [ ord ( str [ i ] ) ] += 1 NEW_LINE if ( max < count [ ord ( str [ i ] ) ] ) : NEW_LINE INDENT max = count [ ord ( str [ i ] ) ] NEW_LINE result = str [ i ] NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def getMinDiff ( arr , n , k ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT arr . sort ( ) NEW_LINE ans = arr [ n - 1 ] - arr [ 0 ] NEW_LINE small = arr [ 0 ] + k NEW_LINE big = arr [ n - 1 ] - k NEW_LINE if ( small > big ) : NEW_LINE INDENT big = arr [ n - 1 ] - k NEW_LINE DEDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT subtract = arr [ i ] - k NEW_LINE add = arr [ i ] + k NEW_LINE if ( subtract >= small or add <= big ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( big - subtract <= add - small ) : NEW_LINE INDENT small = subtract NEW_LINE DEDENT else : NEW_LINE INDENT big = add NEW_LINE DEDENT DEDENT return min ( ans , big - small ) NEW_LINE DEDENT
def printkthnode ( adj , wt , n , k ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( adj [ i ] . size ( ) >= k ) : NEW_LINE INDENT print ( adj [ i ] [ adj [ i ] . size ( ) - k ] . second ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT DEDENT DEDENT
def commonCharacters ( str , n ) : NEW_LINE INDENT prim = [ False for i in range ( MAX_CHAR ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT sec = [ False for j in range ( MAX_CHAR ) ] NEW_LINE for i in range ( len ( str [ i ] ) ) : NEW_LINE INDENT if ( prim [ ord ( str [ i ] [ j ] ) - ord ( ' a ' ) ] == 0 ) : NEW_LINE INDENT sec [ ord ( str [ i ] [ j ] ) - ord ( ' a ' ) ] = True NEW_LINE DEDENT DEDENT memcpy ( prim , sec , MAX_CHAR ) NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT if ( prim [ i ] ) : NEW_LINE INDENT print ( " % c ▁ " , i + ord ( ' a ' ) ) NEW_LINE DEDENT DEDENT DEDENT
def canMakeStr2 ( str1 , str2 ) : NEW_LINE INDENT count = [ 0 ] * MAX NEW_LINE for i in range ( len ( str1 ) ) : NEW_LINE INDENT count [ ord ( str1 [ i ] ) - 97 ] += 1 NEW_LINE DEDENT for i in range ( len ( str2 ) ) : NEW_LINE INDENT if ( count [ ord ( str2 [ i ] ) ] == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT count [ ord ( str2 [ i ] ) ] -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT
def count ( a , b , m , n ) : NEW_LINE INDENT if ( ( m == 0 and n == 0 ) or n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( m == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( a [ m - 1 ] == b [ n - 1 ] ) : NEW_LINE INDENT return count ( a , b , m - 1 , n - 1 ) + count ( a , b , m - 1 , n ) NEW_LINE DEDENT else : NEW_LINE INDENT return count ( a , b , m - 1 , n ) NEW_LINE DEDENT DEDENT
def numofArray ( n , m ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( MAX ) ] for j in range ( MAX ) ] NEW_LINE di = [ [ 0 for i in range ( MAX ) ] for j in range ( MAX ) ] NEW_LINE mu = [ [ 0 for i in range ( MAX ) ] for j in range ( MAX ) ] NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 2 * i , m + i ) : NEW_LINE INDENT di [ j ] . append ( i ) NEW_LINE mu [ i ] . append ( j ) NEW_LINE DEDENT di [ i ] . append ( i ) NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , m + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = 0 NEW_LINE for auto x in di [ j ] : NEW_LINE INDENT dp [ i ] [ j ] += dp [ i - 1 ] [ x ] NEW_LINE DEDENT for auto x in mu [ j ] : NEW_LINE INDENT dp [ i ] [ j ] += dp [ i - 1 ] [ x ] NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT ans += dp [ n ] [ i ] NEW_LINE di [ i ] . clear ( ) NEW_LINE mu [ i ] . clear ( ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def findSubarraySum ( arr , n ) : NEW_LINE INDENT res = 0 NEW_LINE m = dict ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT Sum = 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT Sum += arr [ j ] NEW_LINE m [ Sum ] += 1 NEW_LINE DEDENT DEDENT for auto in m : NEW_LINE INDENT if ( x . second == 1 ) : NEW_LINE INDENT res = res + x . first NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def findpath ( graph , n ) : NEW_LINE INDENT numofadj = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT numofadj . append ( accumulate ( graph [ i ] , graph [ i ] + 5 , 0 ) ) NEW_LINE DEDENT startpoint = 0 NEW_LINE numofodd = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( numofadj [ i ] % 2 == 1 ) : NEW_LINE INDENT numofodd += 1 NEW_LINE startpoint = i NEW_LINE DEDENT DEDENT if ( numofodd > 2 ) : NEW_LINE INDENT print ( " No ▁ Solution " ) NEW_LINE return NEW_LINE DEDENT stack = [ ] NEW_LINE cur = startpoint NEW_LINE while ( len ( stack ) > 0 ) : NEW_LINE INDENT if ( accumulate ( graph [ cur ] , graph [ cur ] + 5 , 0 ) == 0 ) : NEW_LINE INDENT path . append ( cur ) NEW_LINE cur = stack . get ( ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( graph [ cur ] [ i ] == 1 ) : NEW_LINE INDENT stack . append ( cur ) NEW_LINE graph [ cur ] [ i ] = 0 NEW_LINE graph [ i ] [ cur ] = 0 NEW_LINE cur = i NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT for ele in path : NEW_LINE INDENT print ( ele , end = " ▁ - > ▁ " ) NEW_LINE DEDENT print ( cur ) NEW_LINE DEDENT
def sumBetweenTwoKth ( arr , n , k1 , k2 ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE return accumulate ( arr + k1 , arr + k2 - 1 , 0 ) NEW_LINE DEDENT
def calculate ( a , n ) : NEW_LINE INDENT maximum = max_element ( a , n + 5 ) NEW_LINE frequency = [ 0 for i in range ( * maximum + 1 ) ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT frequency [ a [ i ] ] += 1 NEW_LINE DEDENT answer = 0 NEW_LINE for i in range ( 0 , ( * maximum ) + 1 ) : NEW_LINE INDENT answer = answer + frequency [ i ] * ( frequency [ i ] - 1 ) NEW_LINE DEDENT return answer // 2 NEW_LINE DEDENT
def sumNodes ( l ) : NEW_LINE INDENT leafNodeCount = ( int ) ( math . pow ( 2 , l - 1 ) ) NEW_LINE vec = [ [ 0 for i in range ( leafNodeCount + 1 ) ] for j in range ( l ) ] NEW_LINE for i in range ( 1 , leafNodeCount + 1 ) : NEW_LINE INDENT vec [ l - 1 ] . append ( i ) NEW_LINE DEDENT for i in range ( l - 2 , - 1 , - 1 ) : NEW_LINE INDENT k = 0 NEW_LINE while ( k < len ( vec [ i + 1 ] ) - 1 ) : NEW_LINE INDENT vec [ i ] . append ( vec [ i + 1 ] [ k ] + vec [ i + 1 ] [ k + 1 ] ) NEW_LINE k += 2 NEW_LINE DEDENT DEDENT sum = 0 NEW_LINE for i in range ( l ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT sum += vec [ i ] [ j ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def encrypt ( text , s ) : NEW_LINE INDENT result = " " NEW_LINE for i in range ( 0 , len ( text ) ) : NEW_LINE INDENT if ( isupper ( text [ i ] ) ) : NEW_LINE INDENT result += chr ( int ( text [ i ] + s - 65 ) % 26 + 65 ) NEW_LINE DEDENT else : NEW_LINE INDENT result += chr ( int ( text [ i ] + s - 97 ) % 26 + 97 ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT return b NEW_LINE DEDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT k = 0 NEW_LINE while ( ( a | b ) and 1 ) == 0 : NEW_LINE INDENT k = k + 1 NEW_LINE DEDENT while ( ( a > 1 ) == 0 ) : NEW_LINE INDENT a >>= 1 NEW_LINE b >>= 1 NEW_LINE DEDENT while ( ( b > 1 ) == 0 ) : NEW_LINE INDENT b >>= 1 NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT a >>= 1 NEW_LINE DEDENT b = ( b - a ) NEW_LINE DEDENT while ( b != 0 ) : NEW_LINE INDENT return a << k NEW_LINE DEDENT
def calculateSum ( arr , n ) : NEW_LINE INDENT if ( n == 0 ) : return 0 NEW_LINE s = arr [ 0 ] NEW_LINE value = stoi ( s ) NEW_LINE sum = value NEW_LINE i = 2 NEW_LINE while ( i < n ) : NEW_LINE INDENT s = arr [ i ] NEW_LINE value = stoi ( s ) NEW_LINE operation = arr [ i - 1 ] [ 0 ] NEW_LINE if ( operation == ' + ' ) : NEW_LINE INDENT sum += value NEW_LINE DEDENT else : NEW_LINE INDENT sum -= value NEW_LINE DEDENT i = i + 2 NEW_LINE DEDENT return sum NEW_LINE DEDENT
def replace ( s , c1 , c2 ) : NEW_LINE INDENT l = len ( s ) NEW_LINE for i in range ( 0 , l ) : NEW_LINE INDENT if ( s [ i ] == c1 ) : NEW_LINE INDENT s [ i ] = c2 NEW_LINE DEDENT elif ( s [ i ] == c2 ) : NEW_LINE INDENT s [ i ] = c1 NEW_LINE DEDENT DEDENT return s NEW_LINE DEDENT
def lexicographicSubConcat ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE sub_count = int ( ( n + 1 ) / 2 ) NEW_LINE arr = [ ' ' * ( sub_count + 1 ) / 2 ] NEW_LINE index = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for len in range ( 1 , n - i + 1 ) : NEW_LINE INDENT arr [ index ] = s [ i ] NEW_LINE DEDENT index += 1 NEW_LINE DEDENT arr . sort ( ) NEW_LINE for i in range ( sub_count ) : NEW_LINE INDENT res = res + arr [ i ] NEW_LINE DEDENT return res NEW_LINE DEDENT
def findpos ( n ) : NEW_LINE INDENT i = 0 NEW_LINE pos = 0 NEW_LINE while i < len ( n ) and n [ i ] != ' \0' : NEW_LINE INDENT switch n [ i ] : NEW_LINE INDENT case '4' : NEW_LINE INDENT pos = pos * 2 + 1 NEW_LINE break NEW_LINE DEDENT case '7' : NEW_LINE INDENT pos = pos * 2 + 2 NEW_LINE break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return pos NEW_LINE DEDENT
def lis ( arr , n ) : NEW_LINE INDENT mpis = [ 0 ] * n NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT mpis [ i ] = arr [ i ] NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( 0 , i ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and mpis [ i ] < ( mpis [ j ] * arr [ i ] ) ) : NEW_LINE INDENT mpis [ i ] = mpis [ j ] * arr [ i ] NEW_LINE DEDENT DEDENT DEDENT return * max_element ( mpis , mpis + n ) NEW_LINE DEDENT
def checkSorted ( n , q ) : NEW_LINE INDENT st = [ ] NEW_LINE expected = 1 NEW_LINE fnt = - 1 NEW_LINE while ( not q . empty ( ) ) : NEW_LINE INDENT fnt = q . get ( ) NEW_LINE if ( fnt == expected ) : NEW_LINE INDENT expected += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( st . empty ( ) ) : NEW_LINE INDENT st . append ( fnt ) NEW_LINE DEDENT elif ( not st . empty ( ) and st . top ( ) < fnt ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT st . append ( fnt ) NEW_LINE DEDENT DEDENT while ( expected - 1 == n and st . empty ( ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def generate ( st , s ) : NEW_LINE INDENT if len ( s ) == 0 : NEW_LINE INDENT return NEW_LINE DEDENT if st . get ( s ) == None : NEW_LINE INDENT st . add ( s ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT t = s NEW_LINE t . erase ( i , 1 ) NEW_LINE generate ( st , t ) NEW_LINE DEDENT DEDENT return NEW_LINE DEDENT
def minLexRotation ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE arr = [ ' ' ] * ( n + 1 ) NEW_LINE concat = str + str NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr [ i ] = concat [ i : ] NEW_LINE DEDENT arr . sort ( ) NEW_LINE return arr [ 0 ] NEW_LINE DEDENT
def isPossible ( a , b , n , k ) : NEW_LINE INDENT a . sort ( ) NEW_LINE b . sort ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if a [ i ] + b [ i ] < k : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def isCornerPresent ( str , corner ) : NEW_LINE INDENT n = len ( str ) NEW_LINE cl = len ( corner ) NEW_LINE if ( n < cl ) : NEW_LINE INDENT return False NEW_LINE DEDENT return ( str [ 0 : cl ] . compare ( corner ) == 0 and str [ n - cl : cl ] . compare ( corner ) == 0 ) NEW_LINE DEDENT
def longDivision ( number , divisor ) : NEW_LINE INDENT ans = " " NEW_LINE idx = 0 NEW_LINE temp = number [ idx ] - '0' NEW_LINE while ( temp < divisor ) : NEW_LINE INDENT temp = temp * 10 + ( number [ idx ] - '0' ) NEW_LINE DEDENT while ( number . size ( ) > idx ) : NEW_LINE INDENT ans += ( temp // divisor ) + '0' NEW_LINE temp = ( temp % divisor ) * 10 + number [ idx ] - '0' NEW_LINE DEDENT if ( ans . length ( ) == 0 ) : NEW_LINE INDENT return "0" NEW_LINE DEDENT return ans NEW_LINE DEDENT
def sort012 ( a , arr_size ) : NEW_LINE INDENT lo = 0 NEW_LINE hi = arr_size - 1 NEW_LINE mid = 0 NEW_LINE while ( mid <= hi ) : NEW_LINE INDENT switch a [ mid ] : NEW_LINE INDENT lo += 1 NEW_LINE mid += 1 NEW_LINE break NEW_LINE DEDENT case 0 : NEW_LINE INDENT a [ lo ] , a [ mid ] = a [ mid ] , a [ hi - 1 ] NEW_LINE break NEW_LINE DEDENT case 1 : NEW_LINE INDENT mid += 1 NEW_LINE DEDENT break NEW_LINE DEDENT DEDENT
def canRepresentBST ( pre , n ) : NEW_LINE INDENT s = [ ] NEW_LINE root = INT_MIN NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( pre [ i ] < root ) : NEW_LINE INDENT return False NEW_LINE DEDENT while ( not s . empty ( ) and s . top ( ) < pre [ i ] ) : NEW_LINE INDENT root = s . pop ( ) NEW_LINE DEDENT s . append ( pre [ i ] ) NEW_LINE DEDENT return True NEW_LINE DEDENT
def solveQuery ( start , end , arr ) : NEW_LINE INDENT frequency = dict ( ) NEW_LINE for i in range ( start , end + 1 ) : NEW_LINE INDENT frequency [ arr [ i ] ] += 1 NEW_LINE DEDENT count = 0 NEW_LINE for auto in frequency : NEW_LINE INDENT if x . first == x . second : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def divisibleBy20 ( num ) : NEW_LINE INDENT lastTwoDigits = int ( num [ len ( num ) - 2 : ] ) NEW_LINE if ( ( lastTwoDigits % 5 == 0 ) and ( lastTwoDigits % 4 == 0 ) ) : NEW_LINE INDENT return ( ( lastTwoDigits % 5 == 0 ) and ( lastTwoDigits % 4 == 0 ) ) NEW_LINE DEDENT
def CountTriangles ( A ) : NEW_LINE INDENT n = len ( A ) NEW_LINE A . sort ( ) NEW_LINE count = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT l = 0 NEW_LINE r = i - 1 NEW_LINE while ( l < r ) : NEW_LINE INDENT if ( A [ l ] + A [ r ] > A [ i ] ) : NEW_LINE INDENT count += r - l NEW_LINE r -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT l += 1 NEW_LINE DEDENT DEDENT print ( " No ▁ of ▁ possible ▁ solutions : ▁ " , count ) NEW_LINE DEDENT
def countFreq ( a , n ) : NEW_LINE INDENT hm = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT hm [ a [ i ] ] += 1 NEW_LINE DEDENT st = set ( ) NEW_LINE for auto in hm : NEW_LINE INDENT st . add ( { x . first , x . second } ) NEW_LINE DEDENT cumul = 0 NEW_LINE for x in st : NEW_LINE INDENT cumul += x . second NEW_LINE DEDENT print ( x . first , " ▁ " , cumul ) NEW_LINE DEDENT DEDENT
def CocktailSort ( a , n ) : NEW_LINE INDENT swapped = True NEW_LINE start = 0 NEW_LINE end = n - 1 NEW_LINE while ( swapped ) : NEW_LINE INDENT swapped = False NEW_LINE for i in range ( start , end ) : NEW_LINE INDENT if a [ i ] > a [ i + 1 ] : NEW_LINE INDENT a [ i ] , a [ i + 1 ] = a [ i + 1 ] , a [ i ] NEW_LINE swapped = True NEW_LINE DEDENT DEDENT if ( not swapped ) : NEW_LINE INDENT break NEW_LINE DEDENT swapped = False NEW_LINE DEDENT end = end - 1 NEW_LINE for i in range ( start , end - 1 , - 1 ) : NEW_LINE INDENT if a [ i ] > a [ i + 1 ] : NEW_LINE INDENT a [ i ] , a [ i + 1 ] = a [ i + 1 ] , a [ i ] NEW_LINE swapped = True NEW_LINE DEDENT DEDENT start = start + 1 NEW_LINE DEDENT DEDENT
def first ( str , i ) : NEW_LINE INDENT if ( i == len ( str ) - 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( isupper ( str [ i ] ) ) : NEW_LINE INDENT return str [ i ] NEW_LINE DEDENT return first ( str , i + 1 ) NEW_LINE DEDENT
def longestNull ( Str ) : NEW_LINE INDENT arr = [ [ ' @ ' , - 1 ] for i in range ( len ( Str ) ) ] NEW_LINE maxlen = 0 NEW_LINE for i in range ( len ( Str ) ) : NEW_LINE INDENT arr . append ( { Str [ i ] , i } ) NEW_LINE while len ( arr ) >= 3 and arr [ len ( arr ) - 3 ] . first == '1' and arr [ len ( arr ) - 2 ] . first == '0' and arr [ len ( arr ) - 1 ] . first == '0' : NEW_LINE INDENT arr . pop ( ) NEW_LINE arr . pop ( ) NEW_LINE DEDENT tmp = arr . back ( ) . second NEW_LINE maxlen = max ( maxlen , i - tmp ) NEW_LINE DEDENT return maxlen NEW_LINE DEDENT
def reverse ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE for i in range ( 0 , int ( n / 2 ) ) : NEW_LINE INDENT str [ i ] , str [ n - i - 1 ] = str [ i ] , str [ n - i - 1 ] NEW_LINE DEDENT DEDENT
def nextWord ( s ) : NEW_LINE INDENT if ( s == " " ) : NEW_LINE INDENT return " a " NEW_LINE DEDENT i = len ( s ) - 1 NEW_LINE while i >= 0 : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT if ( i == - 1 ) : NEW_LINE INDENT s = s + ' a ' NEW_LINE DEDENT else : NEW_LINE INDENT s [ i ] = ord ( s [ i ] ) NEW_LINE DEDENT DEDENT return s NEW_LINE DEDENT
def isRectangle ( matrix ) : NEW_LINE INDENT rows = len ( matrix ) NEW_LINE if ( rows == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT columns = len ( matrix [ 0 ] ) NEW_LINE table = dict ( ) NEW_LINE for i in range ( rows ) : NEW_LINE INDENT for j in range ( columns - 1 ) : NEW_LINE INDENT for k in range ( j + 1 , columns ) : NEW_LINE INDENT if ( matrix [ i ] [ j ] == 1 and matrix [ i ] [ k ] == 1 ) : NEW_LINE INDENT if ( table [ j ] . get ( k ) in table [ j ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT table [ j ] . add ( k ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return False NEW_LINE DEDENT
def sumoflength ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE j = 0 NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT while ( j < n and arr [ j ] not in s ) : NEW_LINE INDENT s . add ( arr [ j ] ) NEW_LINE j += 1 NEW_LINE DEDENT ans += ( ( j - i ) * ( j - i + 1 ) ) / 2 NEW_LINE DEDENT return int ( ans ) NEW_LINE DEDENT
def findTriplets ( arr , n ) : NEW_LINE INDENT found = 0 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT s = set ( ) NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT x = - ( arr [ i ] + arr [ j ] ) NEW_LINE if s . get ( x ) : NEW_LINE INDENT print ( " % d ▁ % d ▁ " , x , arr [ i ] , arr [ j ] ) NEW_LINE found = True NEW_LINE DEDENT else : NEW_LINE INDENT s . add ( arr [ j ] ) NEW_LINE DEDENT DEDENT DEDENT if found == False : NEW_LINE INDENT print ( " ▁ No ▁ Triplet ▁ Found " ) NEW_LINE DEDENT DEDENT
def maxPrefix ( s , t ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( t ) ) : NEW_LINE INDENT if ( count == len ( s ) ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( t [ i ] == s [ count ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def segregateElements ( arr , n ) : NEW_LINE INDENT temp = [ 0 ] * n NEW_LINE j = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] >= 0 ) : NEW_LINE INDENT temp [ j ] = arr [ i ] NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if ( j == n or j == 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] < 0 ) : NEW_LINE INDENT temp [ j ] = arr [ i ] NEW_LINE DEDENT DEDENT memcpy ( arr , temp , sizeof ( temp ) ) NEW_LINE DEDENT DEDENT
def mergeIntervals ( arr , n ) : NEW_LINE INDENT arr = sorted ( arr ) NEW_LINE index = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if arr [ index ] . e >= arr [ i ] . s : NEW_LINE INDENT arr [ index ] . e = max ( arr [ index ] . e , arr [ i ] . e ) NEW_LINE arr [ index ] . s = min ( arr [ index ] . s , arr [ i ] . s ) NEW_LINE DEDENT else : NEW_LINE INDENT arr [ index ] = arr [ i ] NEW_LINE index += 1 NEW_LINE DEDENT DEDENT print ( " \n ▁ The ▁ Merged ▁ Intervals ▁ are : ▁ " ) NEW_LINE for i in range ( index + 1 , n + 1 ) : NEW_LINE INDENT print ( " [ " , arr [ i ] . s , " , ▁ " , arr [ i ] . e , " ] " ) NEW_LINE DEDENT DEDENT
def findArea ( arr , n ) : NEW_LINE INDENT arr . sort ( reverse = True ) NEW_LINE dimension = [ 0 , 0 ] * ( n + 1 ) NEW_LINE j = 0 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( arr [ i ] == arr [ i + 1 ] ) : NEW_LINE INDENT dimension [ j ] = arr [ i ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT return ( dimension [ 0 ] * dimension [ 1 ] ) NEW_LINE DEDENT
def minOps ( arr , n , k ) : NEW_LINE INDENT max = * max_element ( arr , arr + n ) NEW_LINE res = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( ( max - arr [ i ] ) % k != 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT res += ( max - arr [ i ] ) / k NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def isdivisible7 ( num ) : NEW_LINE INDENT n = len ( num ) NEW_LINE gSum = 0 NEW_LINE if ( n == 0 and num [ 0 ] == ' \n ' ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n % 3 == 1 ) : NEW_LINE INDENT strcat ( num , "00" ) NEW_LINE n += 2 NEW_LINE DEDENT elif ( n % 3 == 2 ) : NEW_LINE INDENT strcat ( num , "0" ) NEW_LINE n += 2 NEW_LINE DEDENT DEDENT i = n - 1 NEW_LINE while i >= 0 : NEW_LINE INDENT group = 0 NEW_LINE group += ord ( num [ i ] ) - ord ( '0' ) NEW_LINE group += ( num [ i ] - ord ( '0' ) ) * 10 NEW_LINE group += ( num [ i ] - ord ( '0' ) ) * 100 NEW_LINE gSum = gSum + group * p NEW_LINE p = 1 NEW_LINE DEDENT return ( gSum % 7 == 0 ) NEW_LINE DEDENT
def isDivisible999 ( num ) : NEW_LINE INDENT n = len ( num ) NEW_LINE if ( n == 0 and num [ 0 ] == '0' ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 3 == 1 ) : NEW_LINE INDENT num = "00" + num NEW_LINE DEDENT if ( n % 3 == 2 ) : NEW_LINE INDENT num = "0" + num NEW_LINE DEDENT gSum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT group = 0 NEW_LINE group += ( num [ i ] - ord ( '0' ) ) * 100 NEW_LINE group += ( num [ i ] - ord ( '0' ) ) * 10 NEW_LINE gSum += group NEW_LINE DEDENT if ( gSum > 1000 ) : NEW_LINE INDENT num = to_string ( gSum ) NEW_LINE n = len ( num ) NEW_LINE gSum = isDivisible999 ( num ) NEW_LINE DEDENT return ( gSum == 999 ) NEW_LINE DEDENT
def checkPangram ( strr ) : NEW_LINE INDENT mark = [ False for i in range ( 26 ) ] NEW_LINE for i in range ( len ( strr ) ) : NEW_LINE INDENT if ( ' A ' <= strr [ i ] and strr [ i ] <= ' Z ' ) : NEW_LINE INDENT index = strr [ i ] - ord ( ' A ' ) NEW_LINE DEDENT elif ( ' a ' <= strr [ i ] and strr [ i ] <= ' z ' ) : NEW_LINE INDENT index = strr [ i ] - ord ( ' a ' ) NEW_LINE DEDENT mark [ index ] = True NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT if ( mark [ i ] == False ) : NEW_LINE INDENT return ( False ) NEW_LINE DEDENT DEDENT return ( True ) NEW_LINE DEDENT
def kLargest ( arr , n , k ) : NEW_LINE INDENT arr . sort ( reverse = True ) NEW_LINE for i in range ( k ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def kthLargestSum ( arr , n , k ) : NEW_LINE INDENT sum = [ 0 for i in range ( n + 1 ) ] NEW_LINE sum [ 0 ] = 0 NEW_LINE sum [ 1 ] = arr [ 0 ] NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT sum [ i ] = sum [ i - 1 ] + arr [ i - 1 ] NEW_LINE DEDENT Q = Queue ( ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( i , n + 1 ) : NEW_LINE INDENT x = sum [ j ] - sum [ i - 1 ] NEW_LINE if Q . qsize ( ) < k : NEW_LINE INDENT Q . put ( x ) NEW_LINE DEDENT else : NEW_LINE INDENT if Q . get ( ) < x ) : NEW_LINE INDENT Q . get ( ) NEW_LINE Q . put ( x ) NEW_LINE DEDENT DEDENT DEDENT return Q . get ( ) NEW_LINE DEDENT
def printDistinct ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] not in s : NEW_LINE INDENT s . add ( arr [ i ] ) NEW_LINE DEDENT DEDENT for i in s : NEW_LINE INDENT if arr [ i ] not in s : NEW_LINE INDENT s . add ( arr [ i ] ) NEW_LINE print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
def abFree ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE char_array = [ 0 ] * ( n + 1 ) NEW_LINE char_array [ n - i - 1 ] = ' a ' NEW_LINE b_count = 0 NEW_LINE res = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( char_array [ n - i - 1 ] == ' a ' ) : NEW_LINE INDENT res = ( res + b_count ) NEW_LINE b_count = ( b_count * 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT b_count += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def findFibSubset ( arr , n ) : NEW_LINE INDENT max = max ( arr ) NEW_LINE a = 0 NEW_LINE b = 1 NEW_LINE hash = Set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a + b ) in hash : NEW_LINE INDENT c = a + b NEW_LINE a = b NEW_LINE b = c NEW_LINE hash . add ( b ) NEW_LINE DEDENT while ( b < max ) : NEW_LINE INDENT c = a + b NEW_LINE b = c NEW_LINE hash . add ( b ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] in hash ) : NEW_LINE INDENT print ( " % d ▁ " , arr [ i ] ) NEW_LINE DEDENT DEDENT DEDENT
def recursiveReverse ( str , i ) : NEW_LINE INDENT n = len ( str ) NEW_LINE if ( i == n // 2 ) : NEW_LINE INDENT return NEW_LINE DEDENT swap ( str [ i ] , str [ n - i - 1 ] ) NEW_LINE recursiveReverse ( str , i + 1 ) NEW_LINE DEDENT
def noAdjacentDup ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( s [ i ] == s [ i - 1 ] ) : NEW_LINE INDENT s [ i ] = ' a ' NEW_LINE while ( i + 1 < n and s [ i ] == s [ i + 1 ] ) : NEW_LINE INDENT s [ i ] += 1 NEW_LINE i += 1 NEW_LINE DEDENT DEDENT return s NEW_LINE DEDENT
def query ( s , i , j ) : NEW_LINE INDENT n = len ( s ) NEW_LINE i %= n NEW_LINE j %= n NEW_LINE if ( s [ i ] == s [ j ] ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def countPairs ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE for ele in arr : NEW_LINE INDENT Hash . add ( ele ) NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT product = arr [ i ] * arr [ j ] NEW_LINE if ( product in Hash ) : NEW_LINE INDENT result = result + 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def printInSortedOrder ( arr , n ) : NEW_LINE INDENT index = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT index [ i ] = i NEW_LINE DEDENT for i in range ( 0 , n - 1 ) : NEW_LINE INDENT min = i NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ index [ min ] ] . compare ( arr [ index [ j ] ] ) > 0 ) : NEW_LINE INDENT min = j NEW_LINE DEDENT DEDENT if ( min != i ) : NEW_LINE INDENT temp = index [ min ] NEW_LINE index [ min ] = index [ i ] NEW_LINE index [ i ] = temp NEW_LINE DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ index [ i ] ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def sortUsingHash ( a , n ) : NEW_LINE INDENT max = len ( a ) NEW_LINE min = abs ( len ( a ) ) NEW_LINE hashpos = [ 0 ] * ( max + 1 ) NEW_LINE hashneg = [ 0 ] * ( min + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] >= 0 ) : NEW_LINE INDENT hashpos [ a [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT hashneg [ abs ( a [ i ] ) ] += 1 NEW_LINE DEDENT DEDENT for i in range ( min , max + 1 ) : NEW_LINE INDENT if ( hashneg [ i ] != 0 ) : NEW_LINE INDENT for j in range ( hashneg [ i ] + 1 ) : NEW_LINE INDENT print ( ( - 1 ) * i , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( max + 1 ) : NEW_LINE INDENT if ( hashpos [ i ] != 0 ) : NEW_LINE INDENT for j in range ( hashpos [ i ] + 1 ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
def findRandomIndexOfMax ( arr , n ) : NEW_LINE INDENT freq = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ arr [ i ] ] += 1 NEW_LINE DEDENT max_element = - 1 NEW_LINE max_so_far = INT_MIN NEW_LINE for p in freq : NEW_LINE INDENT if p . second > max_so_far : NEW_LINE INDENT max_so_far = p . second NEW_LINE max_element = p . first NEW_LINE DEDENT DEDENT r = ( rand ( ) % max_so_far ) + 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == max_element ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( count == r ) : NEW_LINE INDENT print ( " Element ▁ with ▁ maximum ▁ frequency ▁ present ▁ " , " at ▁ index ▁ " , i ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT
def singleNumber ( a , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE arr_sum = accumulate ( a , a + n , 0 ) NEW_LINE set_sum = accumulate ( s , s . begin ( ) , s . end ( ) , 0 ) NEW_LINE return ( 3 * set_sum - arr_sum ) // 2 NEW_LINE DEDENT
def printAllAPTriplets ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT diff = arr [ j ] - arr [ i ] NEW_LINE if ( arr [ i ] - diff ) in s : NEW_LINE INDENT print ( arr [ i ] - diff , end = " ▁ " , arr [ j ] ) NEW_LINE DEDENT DEDENT s . add ( arr [ i ] ) NEW_LINE DEDENT DEDENT
def simplify ( Str ) : NEW_LINE INDENT lenn = len ( Str ) NEW_LINE res = [ 0 ] * ( lenn ) NEW_LINE index = 0 NEW_LINE i = 0 NEW_LINE s = [ ] NEW_LINE while i < lenn : NEW_LINE INDENT if ( Str [ i ] == ' + ' ) : NEW_LINE INDENT if ( s . top ( ) == 1 ) : NEW_LINE INDENT res [ index ] = ' - ' NEW_LINE DEDENT if ( s . top ( ) == 0 ) : NEW_LINE INDENT res [ index ] = ' + ' NEW_LINE DEDENT elif ( Str [ i ] == ' - ' ) : NEW_LINE INDENT if ( s . top ( ) == 1 ) : NEW_LINE INDENT res [ index ] = ' - ' NEW_LINE DEDENT if ( s . top ( ) == 0 ) : NEW_LINE INDENT res [ index ] = ' - ' NEW_LINE DEDENT DEDENT elif ( Str [ i ] == ' ( ' and i > 0 ) : NEW_LINE INDENT if ( Str [ i - 1 ] == ' - ' ) : NEW_LINE INDENT x = 0 NEW_LINE DEDENT s . append ( x ) NEW_LINE DEDENT elif ( Str [ i - 1 ] == ' + ' ) : NEW_LINE INDENT s . append ( s . top ( ) ) NEW_LINE DEDENT DEDENT elif ( Str [ i ] == ' \n ' ) : NEW_LINE INDENT res [ index ] = ' ' NEW_LINE DEDENT else : NEW_LINE INDENT res [ index ] = Str [ i ] NEW_LINE i += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def findPair ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE for ele in arr : NEW_LINE INDENT s . add ( ele ) NEW_LINE DEDENT found = False NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] + arr [ j ] in s ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) , arr [ j ] NEW_LINE found = True NEW_LINE DEDENT DEDENT DEDENT if ( found == False ) : NEW_LINE INDENT print ( " Not ▁ exist " ) NEW_LINE DEDENT DEDENT
def strToBinary ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT val = int ( s [ i ] ) NEW_LINE bin = " " NEW_LINE while ( val > 0 ) : NEW_LINE INDENT ( val % 2 ) ? NEW_LINE INDENT bin . append ( '1' ) : NEW_LINE INDENT bin . append ( '0' ) NEW_LINE val /= 2 NEW_LINE DEDENT DEDENT
def findDuplicateparenthesis ( Str ) : NEW_LINE INDENT Stack = [ ] NEW_LINE for ch in Str : NEW_LINE INDENT if ch == ' ( ' ) ' : NEW_LINE INDENT top = Stack . top ( ) NEW_LINE Stack . pop ( ) NEW_LINE elementsInside = 0 NEW_LINE while top != ' ( ' ) : NEW_LINE INDENT elementsInside += 1 NEW_LINE top = Stack . top ( ) NEW_LINE Stack . pop ( ) NEW_LINE DEDENT if elementsInside < 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT Stack . append ( ch ) NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def findTriplets ( x ) : NEW_LINE INDENT fact = [ 0 ] * ( x + 1 ) NEW_LINE factors = set ( ) NEW_LINE for i in range ( 2 , int ( m . sqrt ( x ) + 1 ) ) : NEW_LINE INDENT if ( x % i == 0 ) : NEW_LINE INDENT fact . append ( i ) NEW_LINE if ( x // i != i ) : NEW_LINE INDENT fact . append ( x / i ) NEW_LINE DEDENT factors . add ( i ) NEW_LINE DEDENT DEDENT found = False NEW_LINE k = len ( fact ) NEW_LINE for i in range ( k ) : NEW_LINE INDENT a = fact [ i ] NEW_LINE for j in range ( k ) : NEW_LINE INDENT b = fact [ j ] NEW_LINE if ( ( a != b ) and ( x % ( a * b ) == 0 ) and ( x / ( a * b ) != a ) and ( x / ( a * b ) != b ) and ( x / ( a * b ) != 1 ) ) : NEW_LINE INDENT print ( a , " ▁ " , b , " ▁ " , x / ( a * b ) ) NEW_LINE found = True NEW_LINE break NEW_LINE DEDENT DEDENT if ( found ) : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT DEDENT
def findMissing ( a , b , n , m ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT s . add ( b [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if s . find ( a [ i ] ) == s . end ( ) : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
def minheapify ( a , index ) : NEW_LINE INDENT small = index NEW_LINE l = 2 * index + 1 NEW_LINE r = 2 * index + 2 NEW_LINE if ( l < n and a [ l ] < a [ small ] ) : NEW_LINE INDENT small = l NEW_LINE DEDENT if ( r < n and a [ r ] < a [ small ] ) : NEW_LINE INDENT small = r NEW_LINE DEDENT if ( small != index ) : NEW_LINE INDENT a [ small ] , a [ index ] = a [ index ] , a [ small ] NEW_LINE DEDENT minheapify ( a , small ) NEW_LINE DEDENT DEDENT
def KMP ( m , n , str2 , str1 ) : NEW_LINE INDENT pos = 0 NEW_LINE len = 0 NEW_LINE p = [ 0 ] * m + 1 NEW_LINE k = 0 NEW_LINE p [ 1 ] = 0 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT while ( k > 0 and str1 [ k ] != str1 [ i - 1 ] ) : NEW_LINE INDENT k = p [ k ] NEW_LINE DEDENT if ( str1 [ k ] == str1 [ i - 1 ] ) : NEW_LINE INDENT k = p [ k ] NEW_LINE DEDENT p [ i ] = k NEW_LINE DEDENT for j in range ( 0 , m + 1 ) : NEW_LINE INDENT while ( j > 0 and str1 [ j ] != str2 [ i ] ) : NEW_LINE INDENT j = p [ j ] NEW_LINE DEDENT if ( str1 [ j ] == str2 [ i ] ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT if ( j > len ) : NEW_LINE INDENT len = j NEW_LINE pos = i - j + 1 NEW_LINE DEDENT DEDENT print ( " Shift ▁ = ▁ " , pos ) NEW_LINE DEDENT
def swapDiagonal ( matrix ) : NEW_LINE INDENT for i in range ( 0 , N ) : NEW_LINE INDENT swap ( matrix [ i ] [ i ] , matrix [ i ] [ N - i - 1 ] ) NEW_LINE DEDENT DEDENT
def maximumPalinUsingKChanges ( str , k ) : NEW_LINE INDENT palin = str NEW_LINE l = 0 NEW_LINE r = len ( str ) - 1 NEW_LINE while ( l < r ) : NEW_LINE INDENT if ( str [ l ] != str [ r ] ) : NEW_LINE INDENT palin [ l ] = palin [ r ] = max ( str [ l ] , str [ r ] ) NEW_LINE k -= 1 NEW_LINE DEDENT l += 1 NEW_LINE r -= 1 NEW_LINE DEDENT if ( k < 0 ) : NEW_LINE INDENT return " Not ▁ possible " NEW_LINE DEDENT l = 0 NEW_LINE r = len ( str ) - 1 NEW_LINE while ( l <= r ) : NEW_LINE INDENT if ( k > 0 ) : NEW_LINE INDENT palin [ l ] = '9' NEW_LINE DEDENT if ( palin [ l ] < '9' ) : NEW_LINE INDENT if ( k >= 2 and palin [ l ] == str [ l ] and palin [ r ] == str [ r ] ) : NEW_LINE INDENT k -= 2 NEW_LINE palin [ l ] = palin [ r ] = '9' NEW_LINE DEDENT elif ( k >= 1 and ( palin [ l ] != str [ l ] or palin [ r ] != str [ r ] ) : NEW_LINE INDENT k -= 1 NEW_LINE palin [ l ] = palin [ r ] = '9' NEW_LINE DEDENT DEDENT l += 1 NEW_LINE r -= 1 NEW_LINE DEDENT return palin NEW_LINE DEDENT
def findMinRooms ( slots , n , m ) : NEW_LINE INDENT counts = [ 0 for i in range ( m ) ] NEW_LINE for j in range ( m ) : NEW_LINE INDENT if ( slots [ i ] [ j ] == '1' ) : NEW_LINE INDENT counts [ j ] += 1 NEW_LINE DEDENT DEDENT DEDENT return * max_element ( counts , counts + m ) NEW_LINE DEDENT
def minProduct ( arr , n , k ) : NEW_LINE INDENT pq = Queue ( ) NEW_LINE for ele in arr : NEW_LINE INDENT pq . put ( ele ) NEW_LINE DEDENT count = 0 NEW_LINE ans = 1 NEW_LINE while ( count < k ) : NEW_LINE INDENT ans = ans * pq . get ( ) NEW_LINE count += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def largest ( arr , n ) : NEW_LINE INDENT return * max_element ( arr , arr + n ) NEW_LINE DEDENT
def findLongestConseqSubseq ( arr , n ) : NEW_LINE INDENT s = Set ( ) NEW_LINE for ele in arr : NEW_LINE INDENT s . add ( ele ) NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] - 1 ) not in s : NEW_LINE INDENT j = arr [ i ] NEW_LINE while ( j in s ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT ans = max ( ans , j - arr [ i ] ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def divisibilityCheck ( arr , n ) : NEW_LINE INDENT s = Set ( ) NEW_LINE max_ele = - 1 NEW_LINE for ele in arr : NEW_LINE INDENT s . add ( ele ) NEW_LINE max_ele = max ( max_ele , arr [ i ] ) NEW_LINE DEDENT res = Set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] != 0 ) : NEW_LINE INDENT for j in range ( arr [ i ] * 2 , max_ele + arr [ i ] ) : NEW_LINE INDENT if ( s . get ( j ) in s ) : NEW_LINE INDENT res . add ( j ) NEW_LINE DEDENT DEDENT DEDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT ans = [ ] NEW_LINE for it in mp : NEW_LINE INDENT if ( it -> second >= 2 ) : NEW_LINE INDENT if ( res . get ( it -> first ) == res . end ( ) ) : NEW_LINE INDENT val = it -> second NEW_LINE while ( val -= 1 ) : NEW_LINE INDENT ans . append ( it -> first ) NEW_LINE DEDENT DEDENT if ( res . get ( it -> first ) != res . end ( ) ) : NEW_LINE INDENT val = it -> second NEW_LINE while ( val -= 1 ) : NEW_LINE INDENT ans . append ( it -> first ) NEW_LINE DEDENT DEDENT for auto x in ans : NEW_LINE INDENT print ( x ) NEW_LINE DEDENT DEDENT
def minPalPartion ( str1 ) : NEW_LINE INDENT n = len ( str1 ) NEW_LINE C = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE P = [ [ False for x in range ( n + 1 ) ] for y in range ( n + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT P [ i ] [ i ] = True NEW_LINE C [ i ] [ i ] = 0 NEW_LINE DEDENT for L in range ( 2 , n + 1 ) : NEW_LINE INDENT for i in range ( n - L + 1 ) : NEW_LINE INDENT j = i + L - 1 NEW_LINE if ( L == 2 ) : NEW_LINE INDENT P [ i ] [ j ] = ( str1 [ i ] == str1 [ j ] ) NEW_LINE DEDENT else : NEW_LINE INDENT P [ i ] [ j ] = ( ( str1 [ i ] == str1 [ j ] ) and P [ i + 1 ] [ j - 1 ] ) NEW_LINE DEDENT if ( P [ i ] [ j ] == True ) : NEW_LINE INDENT C [ i ] [ j ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = sys . maxsize NEW_LINE for k in range ( i , j - 1 ) : NEW_LINE INDENT C [ i ] [ j ] = min ( C [ i ] [ j ] , C [ i ] [ k ] + C [ k + 1 ] [ j ] + 1 ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return C [ 0 ] [ n - 1 ] NEW_LINE DEDENT
def checkCount ( arr , n , k ) : NEW_LINE INDENT hash = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT hash [ arr [ i ] ] += 1 NEW_LINE DEDENT for auto in hash : NEW_LINE INDENT if x . second > 2 * k : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def removeDuplicates ( S ) : NEW_LINE INDENT n = len ( S ) NEW_LINE if ( n < 2 ) : NEW_LINE INDENT return NEW_LINE DEDENT j = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( S [ j ] != S [ i ] ) : NEW_LINE INDENT j += 1 NEW_LINE S [ j ] = S [ i ] NEW_LINE DEDENT DEDENT j += 1 NEW_LINE DEDENT S [ j ] = ' \0' NEW_LINE DEDENT
def KMaxCombinations ( A , B , N , K ) : NEW_LINE INDENT pq = Queue ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT pq . put ( A [ i ] + B [ j ] ) NEW_LINE DEDENT DEDENT count = 0 NEW_LINE while ( count < K ) : NEW_LINE INDENT print ( pq . get ( ) , end = " " ) NEW_LINE count += 1 NEW_LINE DEDENT DEDENT
def to_upper ( in ) : NEW_LINE INDENT for i in range ( 0 , len ( in ) ) : NEW_LINE INDENT if ( ' a ' <= in [ i ] <= ' z ' ) : NEW_LINE INDENT in [ i ] = ord ( in [ i ] ) - ord ( ' a ' ) + ord ( ' A ' ) NEW_LINE DEDENT DEDENT return in NEW_LINE DEDENT
def sortInWave ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n , 2 ) : NEW_LINE INDENT if i > 0 and arr [ i - 1 ] > arr [ i ] : NEW_LINE INDENT arr [ i ] , arr [ i - 1 ] = arr [ i ] , arr [ i - 1 ] NEW_LINE DEDENT if i < n - 1 and arr [ i ] < arr [ i + 1 ] : NEW_LINE INDENT arr [ i ] , arr [ i + 1 ] = arr [ i + 1 ] , arr [ i ] NEW_LINE DEDENT DEDENT DEDENT
def getMinNumberForPattern ( seq ) : NEW_LINE INDENT n = len ( seq ) NEW_LINE if ( n >= 9 ) : NEW_LINE INDENT return " - 1" NEW_LINE DEDENT result = " " NEW_LINE count = 1 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT if ( i == n or seq [ i ] == ' I ' ) : NEW_LINE INDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT result [ j + 1 ] = '0' + count += 1 NEW_LINE if ( j >= 0 and seq [ j ] == ' I ' ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
def findMin ( V ) : NEW_LINE INDENT ans = [ ] NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT while ( V >= deno [ i ] ) : NEW_LINE INDENT V -= deno [ i ] NEW_LINE ans . append ( deno [ i ] ) NEW_LINE DEDENT DEDENT for i in range ( 0 , len ( ans ) ) : NEW_LINE INDENT print ( ans [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def findRepeating ( arr , n ) : NEW_LINE INDENT return accumulate ( arr , arr + n , 0 ) - ( ( n - 1 ) * n / 2 ) NEW_LINE DEDENT
def findSum ( str1 , str2 ) : NEW_LINE INDENT if ( str1 . length ( ) > str2 . length ( ) ) : NEW_LINE INDENT swap ( str1 , str2 ) NEW_LINE DEDENT str = " " NEW_LINE n1 = len ( str1 ) NEW_LINE n2 = len ( str2 ) NEW_LINE for i in range ( n1 ) : NEW_LINE INDENT sum = ( ( str1 [ i ] - '0' ) + ( str2 [ i ] - '0' ) + carry ) NEW_LINE str . append ( sum % 10 + '0' ) NEW_LINE carry = sum // 10 NEW_LINE DEDENT for i in range ( n1 , n2 ) : NEW_LINE INDENT sum = ( ( str2 [ i ] - '0' ) + carry ) NEW_LINE str . append ( sum % 10 + '0' ) NEW_LINE carry = sum // 10 NEW_LINE DEDENT if ( carry ) : NEW_LINE INDENT str . append ( carry + '0' ) NEW_LINE DEDENT DEDENT return str NEW_LINE DEDENT
