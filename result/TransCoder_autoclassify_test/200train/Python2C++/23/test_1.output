void printPairs ( int arr [ ] , int n ) { vector < int > v ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( abs ( arr [ i ] ) == abs ( arr [ j ] ) ) v . push_back ( abs ( arr [ i ] ) ) ; } } sort ( v , v + n ) ; for ( int i = 0 ; i < n ; i ++ ) { cout << - v [ i ] << " ▁ " ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) cout << v [ i ] << " ▁ " ; } }
void findArea ( int a , int b , int c ) { if ( a < 0 || b < 0 || c < 0 || a + b <= c ) || a + c <= b ) cout << " Not ▁ a ▁ valid ▁ trianglen " ; return ; } int s = ( a + b + c ) / 2 ; float area = ( s * ( s - a ) * ( s - b ) * ( s - c ) ) ** 0.5 ; cout << " Area ▁ of ▁ a ▁ traingle ▁ is ▁ % f " << area ; }
bool isMajority ( int a [ ] ) { map < int , int > mp ; for ( int i = 0 ; i < a . length ( ) ; i ++ ) mp [ i ] ++ ; for ( int x = 0 ; x < mp . size ( ) ; x ++ ) if ( mp [ x ] >= ( a . length ( ) / 2 ) ) return true ; return false ; }
void recaman ( int n ) { if ( n <= 0 ) return ; unordered_set < int > s ; cout << 0 << " , " << endl ; for ( int i = 1 ; i < n ; i ++ ) { int curr = prev - i ; if ( curr < 0 || curr in s ) curr = prev + i ; s . insert ( curr ) ; cout << curr << " , " << endl ; prev = curr ; } }
int findLength ( string str ) { int n = str . length ( ) ; int maxlen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int length = j - i + 1 ; int leftsum = 0 , rightsum = 0 ; for ( int k = 0 ; k < length / 2 ; k ++ ) { leftsum += ( str [ i + k ] - '0' ) ; rightsum += ( str [ i + k + int ( length / 2 ) ] - '0' ) ; } if ( leftsum == rightsum && maxlen < length ) maxlen = length ; } } return maxlen ; }
bool prevPermutation ( char str [ ] ) { int n = strlen ( str ) - 1 ; int i = n ; while ( i > 0 && str [ i - 1 ] <= str [ i ] ) i -- ; if ( i <= 0 ) return false ; int j = i - 1 ; while ( j + 1 <= n && str [ j + 1 ] <= str [ i - 1 ] ) j ++ ; str [ i - 1 ] = str [ j ] ; return true , str ; }
string findSubString ( string str , string pat ) { int len1 = str . length ( ) ; int len2 = pat . length ( ) ; if ( len1 < len2 ) cout << " No ▁ such ▁ window ▁ exists " ; return " " ; }
void shuffle ( int card [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int r = i + ( random . nextInt ( 0 , 55 ) % ( 52 - i ) ) ; int tmp = card [ i ] ; card [ i ] = card [ r ] ; card [ r ] = tmp ; } }
int removeConsecutiveSame ( int v [ ] ) { vector < int > st ; for ( int i = 0 ; i < v . length ( ) ; i ++ ) { if ( st . empty ( ) ) st . push_back ( v [ i ] ) ; else { string str = st . top ( ) ; if ( str == v [ i ] ) st . pop ( ) ; else st . push_back ( v [ i ] ) ; } } return st . size ( ) ; }
void find ( char * list1 , char * list2 ) { vector < char > res ; int max_possible_sum = ( int ) ( list1 . size ( ) + list2 . size ( ) - 2 ) ; for ( int sum = 0 ; sum <= max_possible_sum ; sum ++ ) { for ( int i = 0 ; i <= sum ; i ++ ) { if ( i < ( int ) list1 . size ( ) && ( sum - i ) < ( list2 . size ( ) ) && list1 [ i ] == list2 [ sum - i ] ) res . push_back ( list1 [ i ] ) ; } } if ( res . size ( ) > 0 ) break ; for ( int i = 0 ; i < res . size ( ) ; i ++ ) cout << res [ i ] << " ▁ " ; }
int getLevenstein ( int inpt [ ] ) { int revInput [ 2 * n + 1 ] ; int dp [ n + 1 ] [ n + 1 ] ; memset ( dp , - 1 , sizeof ( dp ) ) ; for ( int i = 0 ; i <= n ; i ++ ) dp [ 0 ] [ i ] = i ; dp [ i ] [ 0 ] = i ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( inpt [ i - 1 ] == revInput [ j - 1 ] ) dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = 1 + min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) ; } } int res = INT_MAX ; for ( int i = n ; i >= 0 ; i -- ) { res = min ( res , dp [ i ] [ j ] ) ; if ( i < n ) res = min ( res , dp [ i + 1 ] [ j ] ) ; if ( i > 0 ) res = min ( res , dp [ i - 1 ] [ j ] ) ; } return res ; }
void countDistinct ( int arr [ ] , int k , int n ) { map < int , int > mp ; int dist_count = 0 ; for ( int i = 0 ; i < k ; i ++ ) { if ( mp [ arr [ i ] ] == 0 ) dist_count ++ ; mp [ arr [ i ] ] ++ ; } cout << dist_count << endl ; for ( int i = k ; i < n ; i ++ ) { if ( mp [ arr [ i - k ] ] == 1 ) dist_count -- ; mp [ arr [ i - k ] ] -- ; if ( mp [ arr [ i ] ] == 0 ) dist_count ++ ; mp [ arr [ i ] ] ++ ; cout << dist_count ; } }
int lcs ( int dp [ ] [ MAX ] , int arr1 [ ] , int n , int arr2 [ ] , int m , int k ) { if ( k < 0 ) return - ( 10 ** 7 ) ; if ( n < 0 || m < 0 ) return 0 ; int ans = dp [ n ] [ m ] [ k ] ; if ( ans != - 1 ) return ans ; ans = lcs ( dp , arr1 , n - 1 , arr2 , m , k ) , lcs ( dp , arr1 , n , arr2 , m - 1 , k ) ) ; if ( arr1 [ n - 1 ] == arr2 [ m - 1 ] ) ans = max ( ans , 1 + lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k ) ) ; ans = max ( ans , lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k - 1 ) ) ; return ans ; }
void printDivisors ( int n ) { vector < int > list ; for ( int i = 1 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) cout << i << " ▁ " ; else list . push_back ( int ( n / i ) ) ; } } for ( int i = list . top ( ) ; i >= 0 ; i -- ) cout << i << " ▁ " ; }
int largestSubset ( int a [ ] , int n ) { vector < int > dp ; sort ( a , a + n ) ; dp [ 0 ] = 0 ; dp [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { int mxm = 0 ; for ( int j = i + 1 ; j < n ; j ++ ) if ( a [ j ] % a [ i ] == 0 ) mxm = max ( mxm , dp [ j ] ) ; } return max ( dp ) ; }
string encodedChar ( string str , int k ) { string expand = " " ; int freq = 0 ; int i = 0 ; while ( i < str . length ( ) ) { string temp = " " ; freq = 0 ; while ( i < str . length ( ) && str [ i ] >= ' a ' && str [ i ] <= ' z ' ) { temp += str [ i ] ; i ++ ; } while ( i < str . length ( ) && str [ i ] >= '1' && str [ i ] <= '9' ) { freq = freq * 10 + ( str [ i ] - '0' ) ; i ++ ; } for ( int j = 1 ; j <= freq ; j ++ ) expand += temp ; if ( freq == 0 ) expand += temp ; return expand [ k - 1 ] ; }
int countNum ( int arr [ ] , int n ) { unordered_map < int , int > s ; int count = 0 , maxm = INT_MIN , minm = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { s [ arr [ i ] ] = 1 ; if ( arr [ i ] < minm ) minm = arr [ i ] ; if ( arr [ i ] > maxm ) maxm = arr [ i ] ; } for ( int i = minm ; i <= maxm ; i ++ ) if ( s [ i ] == 1 ) count ++ ; return count ; }
int countPairs ( int arr [ ] , int n ) { map < int , int > mp ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp [ arr [ i ] ] ) mp [ arr [ i ] ] ++ ; else mp [ arr [ i ] ] = 1 ; } int ans = 0 ; for ( int it = 0 ; it < mp . size ( ) ; it ++ ) { int count = mp [ it ] ; ans += ( count * ( count - 1 ) ) / 2 ; } return ans ; }
string decimalToBinary ( int num , int k_prec ) { string binary = " " ; int Integral = num - Integral ; int fractional = num - Integral ; while ( Integral ) { int rem = Integral % 2 ; binary += str ( rem ) ; Integral /= 2 ; } binary = binary [ : : - 1 ] ; binary += ' . ' ; while ( k_prec ) { fractional *= 2 ; int fract_bit = fractional ; if ( fract_bit == 1 ) fractional -= fract_bit ; binary += '1' ; } else { binary += '0' ; } k_prec -- ; } return binary ; }
int evaluateBoolExpr ( string s ) { int n = s . length ( ) ; for ( int i = 0 ; i <= n - 2 ; i += 2 ) { if ( s [ i + 1 ] == " A " ) { if ( s [ i + 2 ] == "0" || s [ i ] == "0" ) s [ i + 2 ] = "0" ; else s [ i + 2 ] = "1" ; } else if ( s [ i + 1 ] == " B " ) { if ( s [ i + 2 ] == "1" || s [ i ] == "1" ) s [ i + 2 ] = "1" ; else s [ i + 2 ] = "0" ; } else { if ( s [ i + 2 ] == s [ i ] ) s [ i + 2 ] = "0" ; else s [ i + 2 ] = "1" ; } } return s [ n - 1 ] - '0' ; }
int minSwaps ( int arr [ ] [ MAX ] ) { int n = arr . size ( ) ; int arrpos [ n ] [ MAX ] ; sort ( arr , arrpos + n ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( vis [ i ] || arrpos [ i ] [ 0 ] == i ) continue ; int cycle_size = 0 ; for ( int j = i ; j < n ; j ++ ) { vis [ j ] = true ; j = arrpos [ j ] [ 0 ] ; cycle_size ++ ; } if ( cycle_size > 0 ) ans += ( cycle_size - 1 ) ; } return ans ; }
int minimumBox ( int arr [ ] , int n ) { queue < int > q ; sort ( arr , arr + n ) ; q . push_back ( arr [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { int now = q [ 0 ] ; if ( arr [ i ] >= 2 * now ) q . popleft ( ) ; q . push ( arr [ i ] ) ; } return q . size ( ) ; }
void convertOpposite ( char str [ ] ) { int ln = strlen ( str ) ; for ( int i = 0 ; i < ln ; i ++ ) { if ( str [ i ] >= ' a ' && str [ i ] <= ' z ' ) str [ i ] = ( char ) ( str [ i ] - 32 ) ; else if ( str [ i ] >= ' A ' && str [ i ] <= ' Z ' ) str [ i ] = ( char ) ( str [ i ] + 32 ) ; } }
int findRepeating ( int arr [ ] , int n ) { unordered_set < int > s ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . find ( arr [ i ] ) != s . end ( ) ) return arr [ i ] ; s . insert ( arr [ i ] ) ; } return - 1 ; }
void transpose ( int A [ ] [ N ] ) { int i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = i + 1 ; j < N ; j ++ ) A [ i ] [ j ] , A [ j ] [ i ] = A [ j ] [ i ] , A [ i ] [ j ] ; }
void printSubsequences ( char * str ) { int n = strlen ( str ) ; int opsize = pow ( 2 , n - 1 ) ; for ( int counter = 0 ; counter < opsize ; counter ++ ) { for ( int j = 0 ; j < n ; j ++ ) { cout << str [ j ] << " ▁ " ; if ( counter & ( 1 << j ) ) cout << " ▁ " ; } cout << endl ; } }
void printRoman ( int number ) { int num [ 12 ] = { 1 , 4 , 5 , 9 , 10 , 40 , 50 , 90 , 100 , 400 , 500 , 900 , 1000 } ; string sym [ 12 ] = { " I " , " IV " , " X " , " XL " , " L " , " XC " , " C " , " D " , " CM " , " M " } ; for ( int i = 12 ; number ; i ++ ) { int div = number / num [ i ] ; number %= num [ i ] ; while ( div ) cout << sym [ i ] ; div -- ; } i -- ; }
bool findTriplet ( int a1 [ ] , int a2 [ ] , int a3 [ ] , int n1 , int n2 , int n3 , int sum ) { int s [ n1 ] ; for ( int i = 0 ; i < n1 ; i ++ ) s . insert ( a1 [ i ] ) ; for ( int i = 0 ; i < n2 ; i ++ ) for ( int j = 0 ; j < n3 ; j ++ ) if ( sum - a2 [ i ] - a3 [ j ] in s ) return true ; return false ; }
bool check ( string s ) { if ( s . length ( ) >= 10 ) return true ; for ( int i = 1 ; i <= s . length ( ) ; i ++ ) { for ( int j = i + 1 ; j <= s . length ( ) ; j ++ ) { for ( int k = j + 1 ; k <= s . length ( ) ; k ++ ) { string s1 = s [ 0 : i ] ; string s2 = s [ i : j - i ] ; string s3 = s [ j : k - j ] ; string s4 = s [ k : s . length ( ) - k ] ; if ( s1 != s2 && s1 != s3 && s1 != s4 && s2 != s3 && s2 != s4 && s3 != s4 ) return true ; } } } return false ; }
int bitonicGenerator ( int arr [ ] , int n ) { int i = 1 , j = n - 1 ; if ( j % 2 != 0 ) j -- ; while ( i < j ) { swap ( arr [ j ] , arr [ i ] ) ; i = i + 2 ; j = j - 2 ; } int arr_f [ ] , arr_s [ ] ; for ( int i = 0 ; i < n ; i ++ ) { arr_f . push_back ( arr [ i ] ) ; } sort ( arr_f , arr + n ) ; for ( int i = 0 ; i < n ; i ++ ) { arr_s . push_back ( arr [ i ] ) ; i ++ ; } sort ( arr_f , arr_s ) ; for ( int i = 0 ; i < n ; i ++ ) { arr_f . push_back ( i ) ; } return arr_f ; }
void splitString ( string str ) { string alpha = " " , num = " " , special = " " ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] . isdigit ( ) ) num = num + str [ i ] ; else if ( str [ i ] >= ' A ' && str [ i ] <= ' Z ' ) alpha += str [ i ] ; else if ( str [ i ] >= ' a ' && str [ i ] <= ' z ' ) special += str [ i ] ; } cout << alpha << " , num << " , special << endl ; }
void binaryMedian ( int m [ R ] [ MAX ] , int r , int d ) { int mi = m [ 0 ] [ 0 ] ; int mx = 0 ; for ( int i = 0 ; i < r ; i ++ ) { if ( m [ i ] [ 0 ] < mi ) mi = m [ i ] [ 0 ] ; if ( m [ i ] [ d - 1 ] > mx ) mx = m [ i ] [ d - 1 ] ; } int desired = ( r * d + 1 ) / 2 ; while ( mi < mx ) { int mid = mi + ( mx - mi ) / 2 ; int place [ r ] = m [ i ] [ r ] ; place [ 0 ] = place [ 0 ] + j ; if ( place [ 0 ] < desired ) mi = mid + 1 ; else mx = mid ; } cout << " Median ▁ is ▁ " << mi << endl ; }
void printDuplicates ( int arr [ ] , int n ) { unordered_map < int , int > dict ; for ( int i = 0 ; i < n ; i ++ ) { dict [ i ] = 1 ; } for ( int item = 0 ; item < n ; item ++ ) { if ( dict [ item ] > 1 ) cout << item << " ▁ " ; } cout << endl ; }
void stoogesort ( int arr [ ] , int l , int h ) { if ( l >= h ) return ; if ( arr [ l ] > arr [ h ] ) { int t = arr [ l ] ; arr [ l ] = arr [ h ] ; arr [ h ] = t ; } if ( h - l + 1 > 2 ) { t = ( int ) ( h - l + 1 ) / 3 ; stoogesort ( arr , l , ( h - t ) ) ; stoogesort ( arr , l + t , ( h ) ) ; stoogesort ( arr , l , ( h - t ) ) ; } }
void printEqualModNumbers ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int d = arr [ n - 1 ] - arr [ 0 ] ; int v [ n ] ; for ( int i = 1 ; i * i <= d ; ++ i ) { if ( d % i == 0 ) v . push_back ( i ) ; if ( i != d / i ) v . push_back ( d / i ) ; } for ( int i = 0 ; i < n ; ++ i ) { int temp = arr [ 0 ] % v [ i ] ; int j ; for ( j = 1 ; j < n ; ++ j ) if ( arr [ j ] % v [ i ] != temp ) break ; if ( j == n ) cout << v [ i ] << " ▁ " ; } }
void recursiveReverse ( char str [ ] ) { stack < char > stack ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) stack . push_back ( str [ i ] ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) str [ i ] = stack . pop ( ) ; }
void printRect ( int X , int Y , int n ) { int Xmax = max ( X ) ; int Xmin = min ( X ) ; int Ymax = max ( Y ) ; int Ymin = min ( Y ) ; cout << " { " << Xmin << " , ▁ " << Ymin << " } " ; cout << " { " << Xmax << " , ▁ " << Ymax << " } " ; cout << " { " << Xmin << " , ▁ " << Ymin << " } " ; cout << " { " << Xmax << " , ▁ " << Ymax << " } " ; cout << " { " << Xmax << " , ▁ " << Ymin << " } " ; }
int NFG ( int a [ ] , int n ) { if ( n <= 0 ) { cout << " List ▁ empty " ; return 0 ; } int stack [ n ] ; int freq [ n ] ; for ( int i = 0 ; i < a . length ( ) ; i ++ ) freq [ a [ i ] ] = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( freq [ a [ stack [ top ] ] ] > freq [ a [ i ] ] ) top ++ ; stack [ top ] = i ; } else { while ( top > - 1 && freq [ a [ stack [ top ] ] < freq [ a [ i ] ] ) top -- ; stack [ top ] = i ; } } while ( top > - 1 ) res [ stack [ top ] ] = - 1 ; top -- ; return res ; }
void printEqualSumSets ( int arr [ ] , int n ) { int sum_array = sum ( arr ) ; if ( sum_array & 1 ) cout << " - 1" ; return ; } int k = sum_array >> 1 ; int dp [ n + 1 ] [ k + 1 ] ; for ( int i = 1 ; i < k + 1 ; i ++ ) dp [ 0 ] [ i ] = false ; for ( int i = 0 ; i < n + 1 ; i ++ ) { for ( int currSum = 1 ; currSum <= k ; currSum ++ ) { dp [ i ] [ currSum ] = dp [ i - 1 ] [ currSum ] ; if ( arr [ i - 1 ] <= currSum ) dp [ i ] [ currSum ] = ( dp [ i ] [ currSum ] || dp [ i - 1 ] [ currSum - arr [ i - 1 ] ] ) ; } } int set1 [ ] , set2 [ ] ; for ( int i = n ; i > 0 && currSum >= 0 ; i -- ) { if ( dp [ i - 1 ] [ currSum ] ) i -= 1 ; set2 . push_back ( arr [ i ] ) ; } else if ( dp [ i - 1 ] [ currSum - arr [ i - 1 ] ) { i -= 1 ; currSum -= arr [ i ] ; set1 . push_back ( arr [ i ] ) ; } cout << " Set ▁ 1 ▁ elements : " << " ▁ ▁ " ; for ( int i = 0 ; i < set1 . size ( ) ; i ++ ) { cout << set1 [ i ] << " ▁ " ; } cout << " \n " ; }
void reverseStr ( char str [ ] ) { int n = strlen ( str ) ; int j ; for ( int i = 0 , j = n - 1 ; i < j ; i ++ , j -- ) { str [ i ] , str [ j ] = str [ j ] ; } }
void minimizeWithKSwaps ( int arr [ ] , int n , int k ) { for ( int i = 0 ; i < n - 1 && k > 0 ; ++ i ) { int pos = i ; for ( int j = i + 1 ; j < n ; ++ j ) if ( j - i > k ) break ; if ( arr [ j ] < arr [ pos ] ) pos = j ; } for ( int j = pos ; j > i ; -- j ) swap ( arr [ j ] , arr [ j - 1 ] ) ; k -= pos - i ; }
int countSubarrays ( int arr [ ] , int n ) { int difference = 0 ; int ans = 0 ; int hash_positive [ n + 1 ] = { 0 } , hash_negative [ n + 1 ] = { 0 } ; hash_positive [ 0 ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] & 1 == 1 ) difference = difference + 1 ; else difference = difference - 1 ; if ( difference < 0 ) ans += hash_negative [ - difference ] ; hash_negative [ - difference ] = hash_negative [ - difference ] + 1 ; else ans += hash_positive [ difference ] ; hash_positive [ difference ] = hash_positive [ difference ] + 1 ; } return ans ; }
bool findPairs ( int arr [ ] , int n ) { unordered_map < int , int > Hash ; for ( int i = 0 ; i <= n - 2 ; i ++ ) { for ( int j = i + 1 ; j <= n ; j ++ ) { int sum = arr [ i ] + arr [ j ] ; if ( Hash . find ( sum ) != Hash . end ( ) ) { printf ( " ▁ and ▁ ( % d , ▁ % d ) " , arr [ i ] , arr [ j ] ) ; return true ; } else Hash [ sum ] = ( arr [ i ] , arr [ j ] ) ; } } return false ; }
bool check ( string s1 , string s2 ) { int n = s1 . length ( ) ; int m = s2 . length ( ) ; bool dp [ n + 1 ] [ m + 1 ] ; memset ( dp , false , sizeof ( dp ) ) ; dp [ 0 ] [ 0 ] = true ; for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) { for ( int j = 0 ; j <= s2 . length ( ) ; j ++ ) { if ( dp [ i ] [ j ] ) { if ( j < ( s2 . length ( ) && ( s1 [ i ] . upper ( ) == s2 [ j ] ) ) dp [ i + 1 ] [ j + 1 ] = true ; if ( s1 [ i ] . isupper ( ) == false ) dp [ i + 1 ] [ j ] = true ; } } } return ( dp [ n ] [ m ] ) ; }
bool checkDuplicatesWithinK ( int arr [ ] , int n , int k ) { unordered_set < int > myset ; for ( int i = 0 ; i < n ; i ++ ) { if ( findContains ( arr [ i ] , myset . end ( ) ) ) return true ; myset . push_back ( arr [ i ] ) ; if ( i >= k ) myset . remove ( arr [ i - k ] ) ; } return false ; }
int minOperation ( int arr [ ] , int n ) { unordered_map < int , int > Hash ; for ( int i = 0 ; i < n ; i ++ ) Hash [ arr [ i ] ] ++ ; int max_count = 0 ; for ( int i = 0 ; i < Hash . size ( ) ; i ++ ) { if ( max_count < Hash [ i ] ) max_count = Hash [ i ] ; } return n - max_count ; }
int findSum ( string str ) { string temp = " " ; int sum = 0 ; for ( char ch = 0 ; ch < str . length ( ) ; ch ++ ) { if ( ch . isdigit ( ) ) temp += ch ; else sum += int ( temp ) ; temp = "0" ; } return sum + int ( temp ) ; }
int mostFrequent ( int arr [ ] , int n ) { unordered_map < int , int > Hash ; for ( int i = 0 ; i < n ; i ++ ) { if ( Hash [ arr [ i ] ] ) Hash [ arr [ i ] ] ++ ; else Hash [ arr [ i ] ] = 1 ; } int max_count = 0 ; int res = - 1 ; for ( int i = 0 ; i < Hash . size ( ) ; i ++ ) { if ( max_count < Hash [ i ] ) res = i ; max_count = Hash [ i ] ; } return res ; }
string firstLetterWord ( string str ) { string result = " " ; bool v = true ; for ( int i = 0 ; i < str . size ( ) ; i ++ ) { if ( str [ i ] == ' ▁ ' ) v = true ; else if ( str [ i ] != ' ▁ ' && v == true ) result += ( str [ i ] ) ; v = false ; } return result ; }
void decode ( string str ) { vector < int > integerstack ; vector < char > stringstack ; string temp ; string result ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { int count = 0 ; if ( str [ i ] >= '0' && str [ i ] <= '9' ) count = count * 10 + ( str [ i ] - '0' ) ; i -- ; integerstack . push ( count ) ; } else if ( str [ i ] == ' [ ' ) { temp = " " ; count = 0 ; if ( integerstack . empty ( ) ) { count = integerstack [ - 1 ] ; integerstack . pop ( ) ; } if ( stringstack . empty ( ) ) { result = result + temp ; stringstack . push_back ( result [ 0 ] ) ; result = " " ; } else if ( str [ i ] == ' [ ' ) { if ( str [ i - 1 ] >= '0' && str [ i - 1 ] <= '9' ) { stringstack . push_back ( str [ i ] ) ; integerstack . push_back ( 1 ) ; } else { stringstack . push_back ( str [ i ] ) ; integerstack . push_back ( 1 ) ; } } else { stringstack . push_back ( str [ i ] ) ; } }
int minSum ( int A [ ] ) { int min_val = min ( A ) ; return min_val * ( A . length ( ) - 1 ) ; }
int countWords ( int stri [ ] , int n ) { unordered_map < int , int > m ; for ( int i = 0 ; i < n ; i ++ ) m [ stri [ i ] ] ++ ; int res = 0 ; for ( int i = 0 ; i < m . size ( ) ; i ++ ) if ( m [ stri [ i ] ] == 0 ) res ++ ; return res ; }
void sortUsingHash ( int a [ ] , int n ) { int Max = max ( a ) ; int Hash [ Max + 1 ] ; memset ( Hash , 0 , sizeof ( Hash ) ) ; for ( int i = 0 ; i < n ; i ++ ) Hash [ a [ i ] ] ++ ; for ( int i = 0 ; i <= Max ; i ++ ) { if ( Hash [ i ] != 0 ) for ( int j = 0 ; j < Hash [ i ] ; j ++ ) cout << i << " ▁ " ; } }
bool isDivisible ( string str , int k ) { int n = str . length ( ) ; int c = 0 ; for ( int i = 0 ; i < k ; i ++ ) if ( str [ n - i - 1 ] == '0' ) c ++ ; return ( c == k ) ; }
int divisible ( string num ) { int n = num . length ( ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += num [ i ] ; if ( sum % 3 == 0 ) return 0 ; if ( n == 1 ) return - 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( sum % 3 == int ( num [ i ] ) % 3 ) return 1 ; if ( n == 2 ) return - 2 ; return 2 ; }
void reverse ( char * str ) { if ( str == NULL ) return ; char temp = * str ; strcpy ( temp , str ) ; strcat ( temp , str ) ; }
bool isDvisibleBy12 ( string num ) { if ( num . length ( ) >= 3 ) { int d1 = num [ len ( num ) - 1 ] ; if ( d1 % 2 != 0 ) return false ; int d2 = num [ len ( num ) - 2 ] ; int sum = 0 ; for ( int i = 0 ; i < num . length ( ) ; i ++ ) sum += num [ i ] ; return ( sum % 3 == 0 && ( d2 * 10 + d1 ) % 4 == 0 ) ; } else { int number = num ; if ( number % 12 == 0 ) number = number % 12 ; return ( number % 12 == 0 ) ; } }
int xorZero ( string str ) { int one_count = 0 , zero_count = 0 ; int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == '1' ) one_count ++ ; else zero_count ++ ; } if ( one_count % 2 == 0 ) return zero_count ; return one_count ; }
double nthRoot ( double A , double N ) { int xPre = random . randint ( 1 , 101 ) % 10 ; double eps = 0.001 ; double delX = INT_MAX ; double xK = 0.0 ; while ( delX > eps ) { xK = ( ( N - 1.0 ) * xPre + A / pow ( xPre , N - 1 ) ) / N ; delX = abs ( xK - xPre ) ; xPre = xK ; } return xK ; }
string findLeft ( string str ) { int n = str . length ( ) - 1 ; while ( n >= 0 ) { if ( str [ n ] == ' d ' ) str = str [ 0 : n ] + ' c ' + str [ n + 1 : ] ; break ; if ( str [ n ] == ' b ' ) str = str [ 0 : n ] + ' a ' + str [ n + 1 : ] ; break ; if ( str [ n ] == ' a ' ) str = str [ 0 : n ] + ' b ' + str [ n + 1 : ] ; else if ( str [ n ] == ' c ' ) str = str [ 0 : n ] + ' d ' + str [ n + 1 : ] ; n -- ; } } return str ; }
void minRange ( int arr [ ] , int n , int k ) { int l = 0 , r = n ; for ( int i = 0 ; i < n ; i ++ ) { vector < int > s ; for ( int j = i ; j < n ; j ++ ) { s . push_back ( arr [ j ] ) ; if ( s . length ( ) == k ) { if ( ( j - i ) < ( r - l ) ) { r = j ; l = i ; } break ; } } if ( j == n ) break ; } if ( l == 0 && r == n ) cout << " Invalid ▁ k " ; else cout << l << " ▁ " << r << endl ; }
int findSum ( int A [ ] , int B [ ] , int n ) { int Hash [ n ] ; memset ( Hash , 0 , sizeof ( Hash ) ) ; for ( int i = 0 ; i < n ; i ++ ) Hash [ A [ i ] ] ++ ; int sum = 0 ; for ( int x = 0 ; x < n ; x ++ ) if ( Hash [ x ] == 1 ) sum += x ; return sum ; }
void arrayEvenAndOdd ( int arr [ ] , int n ) { int i = - 1 , j = 0 ; while ( j != n ) { if ( arr [ j ] % 2 == 0 ) { i ++ ; arr [ j ] = arr [ j ] ; } j ++ ; } for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; }
bool containsOdd ( int G [ ] [ V ] , int src ) { int colorArr [ V ] ; queue < int > q ; colorArr [ src ] = 1 ; q . push ( src ) ; while ( ! q . empty ( ) ) { int u = q . front ( ) ; q . pop ( ) ; if ( G [ u ] [ u ] == 1 ) return true ; for ( int v = 0 ; v < V ; v ++ ) { if ( G [ u ] [ v ] && colorArr [ v ] == - 1 ) colorArr [ v ] = 1 - colorArr [ u ] ; q . push ( v ) ; } else if ( G [ u ] [ v ] && colorArr [ v ] == colorArr [ u ] ) return true ; } return false ; }
int getMinSquares ( int n ) { if ( n <= 3 ) return n ; int res = n ; for ( int x = 1 ; x <= n ; x ++ ) { int temp = x * x ; if ( temp > n ) break ; else res = min ( res , 1 + getMinSquares ( n - temp ) ) ; } return res ; }
int selectRandom ( int x ) { int res = 0 ; int count = 0 ; while ( count < 1 ) { count ++ ; if ( count == 1 ) res = x ; else { int i = random . nextInt ( count ) ; if ( i == count - 1 ) res = x ; } } return res ; }
int cost ( int a , int n ) { return ( ( n - 1 ) * min ( a ) ) ; }
int gnomeSort ( int arr [ ] , int n ) { int index = 0 ; while ( index < n ) { if ( index == 0 ) index = index + 1 ; if ( arr [ index ] >= arr [ index - 1 ] ) index = index + 1 ; else { swap ( arr [ index ] , arr [ index - 1 ] ) ; index = index - 1 ; } } return arr ; }
bool sortedAfterSwap ( int A [ ] , int B [ ] , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( B [ i ] ) { if ( A [ i ] != i + 1 ) A [ i ] , A [ i + 1 ] = A [ i + 1 ] ; } } for ( int i = 0 ; i < n ; i ++ ) if ( A [ i ] != i + 1 ) return false ; return true ; }
string moveSpaceInFront ( string s ) { int i = s . length ( ) - 1 ; for ( int j = i ; j >= 0 ; j -- ) if ( s [ j ] != ' ▁ ' ) { s = s [ : i ] + s [ j ] + s [ i + 1 : ] ; i -- ; } while ( i >= 0 ) { s = s [ : i ] + ' ▁ ' + s [ i + 1 : ] ; i -- ; } return s ; }
int countOfBinaryNumberLessThanN ( int N ) { queue < int > q ; q . push ( 1 ) ; q . push ( 1 ) ; int cnt = 0 ; while ( q . empty ( ) ) { int t = q . front ( ) ; if ( t <= N ) { cnt ++ ; q . push ( t * 10 ) ; q . push ( t * 10 + 1 ) ; } } return cnt ; }
void substringConversions ( string str , int k , int b ) { for ( int i = 0 ; i <= k ; i ++ ) { string sub = str [ i : k + i ] ; int sum = 0 ; int counter = 0 ; for ( int i = 0 ; i < sub . length ( ) - 1 ; i -- ) { sum = sum + ( ( sub [ i ] - '0' ) * pow ( b , counter ) ) ; counter ++ ; } cout << sum << " ▁ " ; } }
string longestRepeatedSubSeq ( string str ) { int n = str . length ( ) ; int dp [ n + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) dp [ 0 ] [ i + 1 ] = str [ i ] ; for ( int j = 0 ; j <= n ; j ++ ) { if ( str [ i - 1 ] == str [ j - 1 ] && i != j ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ; } string res = " " ; int i = n , j = n ; while ( i > 0 && j > 0 ) { if ( dp [ i ] [ j ] == dp [ i - 1 ] [ j - 1 ] + 1 ) res += str [ i - 1 ] ; i -- , j -- ; } else if ( dp [ i ] [ j ] == dp [ i - 1 ] [ j ] ) i -- , j -- ; else if ( dp [ i ] [ j ] == dp [ i - 1 ] [ j ] ) j -- ; } return res ; }
void rearrange ( int a [ ] , int size ) { int positive = 0 , negative = 1 ; while ( true ) { while ( positive < size && a [ positive ] >= 0 ) positive = positive + 2 ; while ( negative < size && a [ negative ] <= 0 ) negative = negative + 2 ; if ( positive < size && negative < size ) { int temp = a [ positive ] ; a [ positive ] = a [ negative ] ; a [ negative ] = temp ; } else break ; } }
void bubbleSort ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n - i - 1 ; j ++ ) { if ( arr [ j ] > arr [ j + 1 ] ) { swap ( arr [ j ] , arr [ j + 1 ] ) ; } } }
string reversingString ( string str , int start , int end ) { while ( start < end ) { str = str [ : start ] + ( char ) ( str [ start ] ^ ord ( str [ end ] ) ) + str [ start + 1 : ] ; str = str [ : end ] + ( char ) ( str [ start ] ^ ord ( str [ end ] ) ) + str [ end + 1 : ] ; start ++ ; end -- ; } return str ; }
int minimalSteps ( string s , int n ) { int dp [ n ] ; dp [ 0 ] = 1 ; s1 += s [ 0 ] ; s2 = " " ; for ( int i = 1 ; i < n ; i ++ ) { s1 += s [ i ] ; s2 = s [ i + 1 : i + 1 + i + 1 ] ; dp [ i ] = min ( dp [ i ] , dp [ i - 1 ] + 1 ) ; if ( s1 == s2 ) dp [ i * 2 + 1 ] = min ( dp [ i ] , dp [ i * 2 + 1 ] ) ; } return dp [ n - 1 ] ; }
int MinimumCost ( int cost [ ] , int n , int W ) { vector < int > val ; vector < int > wt ; int size = 0 ; for ( int i = 0 ; i < n ; i ++ ) { val . push_back ( cost [ i ] ) ; wt . push_back ( i + 1 ) ; size ++ ; } int min_cost [ W + 1 ] [ n + 1 ] ; for ( int i = 0 ; i < W + 1 ; i ++ ) min_cost [ 0 ] [ i ] = INF ; for ( int i = 1 ; i < n + 1 ; i ++ ) { min_cost [ i ] [ 0 ] = 0 ; for ( int j = 1 ; j <= W ; j ++ ) { if ( wt [ i - 1 ] > j ) min_cost [ i ] [ j ] = min_cost [ i - 1 ] [ j ] ; else min_cost [ i ] [ j ] = min ( min_cost [ i - 1 ] [ j ] , min_cost [ i ] [ j - wt [ i - 1 ] ] + val [ i - 1 ] ) ; } } if ( min_cost [ n ] [ W ] == INF ) return - 1 ; else return min_cost [ n ] [ W ] ; }
void bitonicGenerator ( int arr [ ] , int n ) { int evenArr [ n ] ; int oddArr [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( i % 2 ) == 0 ) evenArr . push_back ( arr [ i ] ) ; else oddArr . push_back ( arr [ i ] ) ; } sort ( evenArr , evenArr + n ) ; sort ( oddArr , oddArr + n ) ; int i = 0 ; for ( int j = 0 ; j < evenArr . size ( ) ; j ++ ) arr [ i ++ ] = evenArr [ j ] ; for ( int j = 0 ; j < oddArr . size ( ) ; j ++ ) arr [ i ++ ] = oddArr [ j ] ; i ++ ; }
void printFirstRepeating ( int arr [ ] , int n ) { int Min = - 1 ; unordered_map < int , int > myset ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( myset . find ( arr [ i ] ) == myset . end ( ) ) { Min = i ; myset [ arr [ i ] ] = 1 ; } } if ( Min != - 1 ) cout << " The ▁ first ▁ repeating ▁ element ▁ is ▁ " << arr [ Min ] ; else cout << " There ▁ are ▁ no ▁ repeating ▁ elements " ; }
int lps ( char * str ) { int n = strlen ( str ) ; int L [ n ] [ n ] ; int i , j , k , L [ n ] [ n ] ; for ( i = 0 ; i < n ; i ++ ) L [ i ] [ i ] = 1 ; for ( cl = 2 ; cl <= n ; cl ++ ) { for ( i = 0 ; i < n - cl + 1 ; i ++ ) { j = i + cl - 1 ; if ( str [ i ] == str [ j ] && cl == 2 ) L [ i ] [ j ] = 2 ; else if ( str [ i ] == str [ j ] ) L [ i ] [ j ] = L [ i + 1 ] [ j - 1 ] + 2 ; else L [ i ] [ j ] = max ( L [ i ] [ j - 1 ] , L [ i + 1 ] [ j ] ) ; } } return L [ 0 ] [ n - 1 ] ; }
string censor ( string text , string word ) { vector < char > word_list ; string result = " " ; string stars = " " ; int count = 0 , index = 0 ; for ( auto i = 0 ; i < word_list . size ( ) ; i ++ ) { if ( i == word ) { word_list [ index ] = stars ; index ++ ; } } result = ' ▁ ' . join ( word_list ) ; return result ; }
bool isRotated ( string str1 , string str2 ) { if ( str1 . length ( ) != str2 . length ( ) ) return false ; string clock_rot = " " , anticlock_rot = " " ; int l = str2 . length ( ) ; anticlock_rot = ( anticlock_rot + str2 [ l - 2 : ] + str2 [ 0 : l - 2 ] ) ; clock_rot = clock_rot + str2 [ 2 : ] + str2 [ 0 : 2 ] ; return ( str1 == clock_rot || str1 == anticlock_rot ) ; }
int findDiff ( int arr [ ] , int n ) { map < int , int > mp ; for ( int i = 0 ; i < n ; i ++ ) mp [ arr [ i ] ] ++ ; int max_count = 0 , min_count = n ; for ( int key = 0 ; key < mp . size ( ) ; key ++ ) { max_count = max ( max_count , values ) ; min_count = min ( min_count , values ) ; } return max_count - min_count ; }
int playGame ( int arr [ ] , int n ) { unordered_set < int > s ; for ( int i = 0 ; i < n ; i ++ ) { s . insert ( arr [ i ] ) ; } return ( s . size ( ) % 2 == 0 ) ? 1 : 2 ; }
int subset ( int arr [ ] , int n ) { map < int , int > mp ; for ( int i = 0 ; i < n ; i ++ ) mp [ arr [ i ] ] ++ ; int res = 0 ; for ( int key = 0 ; key < 10 ; key ++ ) res = max ( res , value ) ; return res ; }
bool isProduct ( int arr [ ] , int n , int x ) { if ( n < 2 ) return false ; unordered_set < int > s ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) if ( x == 0 ) return true ; else continue ; if ( x % arr [ i ] == 0 ) { if ( x / arr [ i ] in s ) return true ; s . insert ( arr [ i ] ) ; } } return false ; }
int findRotations ( char str [ ] ) { char tmp [ 2 * n + 1 ] ; strcpy ( tmp , str ) ; strcat ( tmp , str ) ; for ( int i = 1 ; i <= n ; i ++ ) { char substring = tmp [ i : n ] ; if ( str == substring ) return i ; } return n ; }
int randomize ( int arr [ ] , int n ) { for ( int i = n - 1 ; i >= 0 ; i -- ) { int j = random . randint ( 0 , i + 1 ) ; arr [ i ] = arr [ j ] ; } return arr ; }
void translate ( char * str ) { int l = str . length ( ) ; if ( l < 2 ) return ; int i = 0 , j = 0 ; while ( j < l - 1 ) { if ( str [ j ] == ' A ' && str [ j + 1 ] == ' B ' ) { j ++ ; st [ i ] = ' C ' ; i ++ ; continue ; } str [ i ] = str [ j ] ; i ++ ; j ++ ; } if ( j == l - 1 ) { str [ i ] = str [ j ] ; i ++ ; } st [ i ] = ' ▁ ' ; st [ l - 1 ] = ' ▁ ' ; }
int numberofways ( int A [ ] , int B [ ] , int N , int M ) { vector < int > pos [ MAX ] ; for ( int i = 0 ; i < M ; i ++ ) pos [ B [ i ] ] . push_back ( i + 1 ) ; int dpl [ N + 2 ] [ M ] ; int LCS = dpl [ N ] [ M ] ; int dpr [ N ] [ M ] ; for ( int i = 1 ; i < N + 1 ; i ++ ) { for ( int j = 1 ; j < M + 1 ; j ++ ) { if ( A [ i - 1 ] == B [ j - 1 ] ) dpl [ i ] [ j ] = dpl [ i - 1 ] [ j - 1 ] + 1 ; else dpl [ i ] [ j ] = max ( dpl [ i - 1 ] [ j ] , dpr [ i ] [ j - 1 ] ) ; } } int ans = 0 ; for ( int i = 0 ; i < N + 1 ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { if ( A [ i - 1 ] == B [ j - 1 ] ) dpr [ i ] [ j ] = dpr [ i + 1 ] [ j + 1 ] + 1 ; else dpr [ i ] [ j ] = max ( dpr [ i + 1 ] [ j ] , dpr [ i ] [ j + 1 ] ) ; } } return ans ; }
void substringConversions ( string s , int k , int b ) { int l = s . length ( ) ; for ( int i = 0 ; i < l ; i ++ ) { if ( ( i + k ) < l + 1 ) { string sub = s [ i : i + k ] ; int sum = 0 , counter = 0 ; for ( int i = 0 ; i < sub . length ( ) - 1 ; i -- ) { sum = sum + ( sub [ i ] - '0' ) * pow ( b , counter ) ; counter ++ ; } cout << sum << " ▁ " ; } }
int sumOfKsubArray ( int arr [ ] , int n , int k ) { int sum = 0 ; deque < int > S , G ; for ( int i = 0 ; i < k ; i ++ ) { while ( ! S . empty ( ) && arr [ S [ - 1 ] ] >= arr [ i ] ) S . pop ( ) ; while ( ! G . empty ( ) && arr [ G [ - 1 ] ] <= arr [ i ] ) G . push ( i ) ; S . push ( i ) ; } for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ S [ 0 ] ] + arr [ G [ 0 ] ] ; while ( ! S . empty ( ) && S [ 0 ] <= i - k ) { S . popleft ( ) ; } while ( ! G . empty ( ) && arr [ G [ - 1 ] ] >= arr [ i ] ) { G . pop ( ) ; } G . push ( i ) ; S . push ( i ) ; } return sum ; }
string arrangeString ( string str ) { int char_count [ MAX_CHAR ] = { 0 } ; int s = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] >= " A " && str [ i ] <= " Z " ) char_count [ str [ i ] - " A " ] ++ ; else s += str [ i ] - "0" ; } string res = " " ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { char ch = ( char ) ( " A " + i ) ; while ( char_count [ i ] ) res += ch ; char_count [ i ] -- ; } if ( s > 0 ) res += str ( s ) ; return res ; }
void waysToIncreaseLCSBy1 ( string str1 , string str2 ) { int M = str1 . length ( ) ; int n = str2 . length ( ) ; vector < int > position [ M ] ; for ( int i = 1 ; i < M ; i ++ ) position [ str2 [ i - 1 ] - 97 ] . push_back ( i ) ; int lcsl [ M ] [ n + 2 ] ; int lcsr [ M ] [ n + 2 ] ; memset ( lcsl , 0 , sizeof ( lcsl ) ) ; for ( int i = 1 ; i < m + 1 ; i ++ ) { for ( int j = 1 ; j < n + 1 ; j ++ ) { if ( str1 [ i - 1 ] == str2 [ j - 1 ] ) lcsl [ i ] [ j ] = 1 + lcsl [ i - 1 ] [ j - 1 ] ; else lcsl [ i ] [ j ] = max ( lcsl [ i - 1 ] [ j ] , lcsl [ i ] [ j - 1 ] ) ; } } int ways = 0 ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( str1 [ i - 1 ] == str2 [ j - 1 ] ) lcsr [ i ] [ j ] = 1 + lcsr [ i + 1 ] [ j + 1 ] ; else lcsr [ i ] [ j ] = max ( lcsr [ i ] [ j ] , lcsr [ i ] [ j + 1 ] ) ; } } for ( int i = 0 ; i <= m ; i ++ ) { for ( int C = 0 ; C <= 25 ; C ++ ) { for ( int j = 0 ; j < position [ C ] . size ( ) ; j ++ ) { p = position [ C ] [ j ] ; if ( lcsl [ i ] [ p - 1 ] ) lcsl [ i ] [ p - 1 ] ; } } ways ++ ; } }
int lis ( int arr [ ] ) { int n = arr . length ( ) ; int lis [ n ] ; for ( int i = 1 ; i < n ; i ++ ) lis [ i ] = 1 ; for ( int j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; int maximum = 0 ; for ( int i = 0 ; i < n ; i ++ ) maximum = max ( maximum , lis [ i ] ) ; return maximum ; }
void SternSequenceFunc ( vector < int > & BrocotSequence , int n ) { for ( int i = 1 ; i < n ; i ++ ) { int considered_element = BrocotSequence [ i ] ; int precedent = BrocotSequence [ i - 1 ] ; BrocotSequence . push_back ( considered_element + precedent ) ; BrocotSequence . push_back ( considered_element ) ; } for ( int i = 0 ; i < 15 ; i ++ ) cout << BrocotSequence [ i ] << " ▁ " ; }
void printBracketNumber ( string exp , int n ) { int left_bnum = 1 ; vector < int > right_bnum ; for ( int i = 0 ; i < n ; i ++ ) { if ( exp [ i ] == ' ( ' ) { cout << left_bnum << " ▁ " ; right_bnum . push_back ( left_bnum ) ; left_bnum ++ ; } else if ( exp [ i ] == ' ) ' { cout << right_bnum [ - 1 ] << " ▁ " ; right_bnum . pop ( ) ; } } }
int returnMaxSum ( int A [ ] , int B [ ] , int n ) { unordered_set < int > mp ; int result = 0 ; int curr_sum = 0 , curr_begin = 0 ; for ( int i = 0 ; i < n ; i ++ ) { while ( A [ curr_begin ] != mp . end ( ) ) { mp . insert ( A [ curr_begin ] ) ; curr_sum -= B [ curr_begin ] ; curr_begin ++ ; } mp . insert ( A [ i ] ) ; curr_sum += B [ i ] ; result = max ( result , curr_sum ) ; } return result ; }
void rearrange ( int arr [ ] , int n ) { int i = - 1 ; for ( int j = 0 ; j < n ; j ++ ) if ( arr [ j ] < 0 ) i ++ ; for ( int pos = i + 1 , neg = 0 ; pos < n && neg < pos && arr [ neg ] < 0 ; pos ++ , neg ++ ) { swap ( arr [ neg ] , arr [ pos ] ) ; } }
int largestGCDSubsequence ( int arr [ ] , int n ) { int ans = 0 ; int maxele = max ( arr , arr + n ) ; for ( int i = 2 ; i <= maxele ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) if ( arr [ j ] % i == 0 ) count ++ ; ans = max ( ans , count ) ; } return ans ; }
bool isNumber ( string s ) { for ( int i = 0 ; i < s . length ( ) ; i ++ ) if ( s [ i ] . isdigit ( ) != true ) return false ; return true ; }
int countPairs ( int arr1 [ ] , int arr2 [ ] , int m , int n , int x ) { int count = 0 ; unordered_set < int > us ; for ( int i = 0 ; i < m ; i ++ ) us . insert ( arr1 [ i ] ) ; for ( int j = 0 ; j < n ; j ++ ) if ( x - arr2 [ j ] in us ) count ++ ; return count ; }
int lis ( int arr [ ] ) { int n = arr . length ( ) ; int lis [ n ] ; for ( int i = 1 ; i < n ; i ++ ) lis [ i ] = 1 ; for ( int j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; int maximum = 0 ; for ( int i = 0 ; i < n ; i ++ ) maximum = max ( maximum , lis [ i ] ) ; return maximum ; }
string findSubString ( string str ) { int n = str . length ( ) ; int dist_count = count ( ) ; int start , start_index , min_len = INT_MAX ; unordered_map < int , int > curr_count ; for ( int j = 0 ; j < n ; j ++ ) { curr_count [ str [ j ] ] ++ ; if ( curr_count [ str [ j ] ] == 1 ) count ++ ; if ( count == dist_count ) { while ( curr_count [ str [ start ] ] > 1 ) { if ( curr_count [ str [ start ] ] > 1 ) curr_count [ str [ start ] ] -- ; start ++ ; } } int len_window = j - start + 1 ; if ( min_len > len_window ) min_len = len_window ; start_index = start ; } } return str [ start_index : start_index + min_len ] ; }
void printSubsequences ( int arr [ ] , int n ) { unsigned int opsize = pow ( 2 , n ) ; for ( int counter = 1 ; counter <= opsize ; counter ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( counter & ( 1 << j ) ) cout << arr [ j ] << " ▁ " ; } cout << endl ; } }
void bin ( int n ) { if ( n > 1 ) bin ( n >> 1 ) ; cout << n & 1 << " \n " ; }
int minimumSquare ( int a , int b ) { int result = 0 ; int rem = 0 ; if ( a < b ) { a , b = b , a ; } while ( b > 0 ) { result += ( a / b ) ; rem = ( a % b ) ; a = b ; b = rem ; } return result ; }
void deleteElements ( int arr [ ] , int n , int k ) { vector < int > st ; st . push_back ( arr [ 0 ] ) ; int top = 0 , count = 0 ; for ( int i = 1 ; i < n ; i ++ ) { while ( ! st . empty ( ) && count < k && st [ top ] < arr [ i ] ) { count ++ ; top -- ; } st . push_back ( arr [ i ] ) ; top ++ ; } for ( int i = 0 ; i < n ; i ++ ) cout << st [ i ] << " ▁ " ; }
int first ( string str ) { for ( int i = 0 ; i < str . size ( ) ; i ++ ) if ( str [ i ] . istitle ( ) ) return str [ i ] ; return 0 ; }
int isPossible ( int n , int index , int modulo , int M , int arr [ ] , int dp [ ] [ MAX ] ) { if ( index == n ) { if ( modulo == 0 ) return 1 ; return 0 ; } if ( dp [ index ] [ modulo ] ) return dp [ index ] [ modulo ] ; bool placeAdd = isPossible ( n , index + 1 , modulo + arr [ index ] , M , arr , dp ) ; bool placeMinus = isPossible ( n , index + 1 , modulo - arr [ index ] , M , arr , dp ) ; res = bool ( placeAdd || placeMinus ) ; dp [ index ] [ modulo ] = res ; return res ; }
void amendSentence ( char * str ) { strcpy ( str , str ) ; strcat ( str , str ) ; for ( int i = 0 ; * ( str + i ) ; i ++ ) { if ( * ( str + i ) >= ' A ' && * ( str + i ) <= ' Z ' ) { str [ i ] = ' ▁ ' ; i ++ ; } printf ( " % c " , str [ i ] ) ; } }
int find ( int a [ ] , int b [ ] , int k , int n1 , int n2 ) { unordered_set < int > s ; for ( int i = 0 ; i < n2 ; i ++ ) s . insert ( b [ i ] ) ; int missing = 0 ; for ( int i = 0 ; i < n1 ; i ++ ) { if ( s . find ( a [ i ] ) == s . end ( ) ) missing ++ ; if ( missing == k ) return a [ i ] ; } return - 1 ; }
int countNumber ( int n ) { int result = 0 ; for ( int i = 1 ; i <= 10 ; i ++ ) { vector < int > s ; if ( i <= n ) s . push_back ( i ) ; result ++ ; } while ( ! s . empty ( ) ) { int tp = s . top ( ) ; s . pop ( ) ; for ( int j = 0 ; j < 10 ; j ++ ) { int x = tp * 10 + j ; if ( x <= n ) s . push_back ( x ) ; result ++ ; } } return result ; }
string getMaxOccuringChar ( string str ) { int count [ ASCII_SIZE ] ; int max = INT_MIN ; string c = " " ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) count [ i ] ++ ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( max < count [ i ] ) { max = count [ i ] ; c = i ; } } return c ; }
int getMinDiff ( int arr [ ] , int n , int k ) { if ( n == 1 ) return 0 ; sort ( arr , arr + n ) ; int ans = arr [ n - 1 ] - arr [ 0 ] ; int small = arr [ 0 ] + k ; int big = arr [ n - 1 ] - k ; if ( small > big ) { small , big = big , small ; } for ( int i = 1 ; i < n - 1 ; i ++ ) { int subtract = arr [ i ] - k ; int add = arr [ i ] + k ; if ( subtract >= small || add <= big ) continue ; if ( big - subtract <= add - small ) small = subtract ; else big = add ; } return min ( ans , big - small ) ; }
void printkthnode ( int adj [ ] [ MAX ] , int wt , int n , int k ) { sort ( adj , adj + n ) ; for ( int i = 0 ; i < n ; i ++ ) adj [ i ] . sort ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( adj [ i ] . size ( ) >= k ) cout << adj [ i ] [ len ( adj [ i ] ) - k ] [ 1 ] << " ▁ " ; else cout << - 1 << " ▁ " ; } }
void commonCharacters ( char * str , int n ) { bool prim [ MAX_CHAR ] ; bool sec [ MAX_CHAR ] ; for ( int i = 0 ; i < n ; i ++ ) { prim [ i ] = true ; } for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { sec [ * ( str + i ) - ' a ' ] = true ; } for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { prim [ i ] = sec [ i ] ; } for ( int i = 0 ; i < 26 ; i ++ ) if ( prim [ i ] ) cout << " % c ▁ " << ( i + ' a ' ) ; }
bool canMakeStr2 ( string s1 , string s2 ) { int count [ s1 . length ( ) ] ; for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) count [ s1 [ i ] ] ++ ; for ( int i = 0 ; i < s2 . length ( ) ; i ++ ) if ( count [ s2 [ i ] ] == 0 ) return false ; count [ s2 [ i ] ] -- ; return true ; }
int count ( int a [ ] , int b [ ] , int m , int n ) { if ( ( m == 0 && n == 0 ) || n == 0 ) return 1 ; if ( m == 0 ) return 0 ; if ( b [ n - 1 ] == a [ m - 1 ] ) return count ( a , b , m - 1 , n - 1 ) + count ( a , b , m - 1 , n ) ; else return count ( a , b , m - 1 , n ) ; }
int numofArray ( int n , int m ) { long int dp [ MAX ] [ MAX ] ; int di [ MAX ] [ MAX ] ; int mu [ MAX ] [ MAX ] ; memset ( dp , 0 , sizeof dp ) ; memset ( di , 0 , sizeof di ) ; memset ( mu , 0 , sizeof mu ) ; for ( int i = 1 ; i < m + 1 ; i ++ ) { for ( int j = 2 * i ; j < m + 1 ; j ++ ) { di [ j ] . push_back ( i ) ; mu [ i ] . push_back ( j ) ; } di [ i ] . push_back ( i ) ; } int ans = 0 ; for ( int i = 1 ; i < n + 1 ; i ++ ) { for ( int j = 1 ; j < m + 1 ; j ++ ) { dp [ i ] [ j ] = 0 ; for ( int x = di [ j ] ; x < mu [ j ] ; x ++ ) dp [ i ] [ j ] += dp [ i - 1 ] [ x ] ; } } ans += dp [ n ] [ i ] ; di [ i ] . clear ( ) ; mu [ i ] . clear ( ) ; return ans ; }
int findSubarraySum ( int arr [ ] , int n ) { int res = 0 ; unordered_map < int , int > m ; for ( int i = 0 ; i < n ; i ++ ) { int sum = 0 ; for ( int j = i ; j < n ; j ++ ) sum += arr [ j ] ; m [ sum ] = m [ sum ] + 1 ; } for ( int x = 0 ; x < m . size ( ) ; x ++ ) if ( m [ x ] == 1 ) res += x ; return res ; }
void findpath ( int graph [ ] [ MAX ] , int n ) { int numofadj [ n ] ; int startpoint = 0 ; int numofodd = 0 ; for ( int i = 0 ; i < n ; i ++ ) numofadj . push_back ( sum ( graph [ i ] ) ) ; if ( numofodd > 2 ) cout << " No ▁ Solution " ; return ; } stack < int > path ; for ( int cur = startpoint ; cur < n ; cur ++ ) { if ( stack . empty ( ) || sum ( graph [ cur ] ) == 0 ) { path . push_back ( cur + 1 ) ; cur = stack . pop ( - 1 ) ; } else { for ( int i = 0 ; i < n ; i ++ ) { if ( graph [ cur ] [ i ] == 1 ) { stack . push ( cur ) ; graph [ cur ] [ i ] = 0 ; graph [ i ] [ cur ] = 0 ; cur = i ; break ; } } } for ( int ele : path ) cout << ele << " - > ▁ ▁ " << endl ; cout << cur + 1 ; }
int sumBetweenTwoKth ( int arr [ ] , int n , int k1 , int k2 ) { sort ( arr , arr + n ) ; int result = 0 ; for ( int i = k1 ; i <= k2 - 1 ; i ++ ) result += arr [ i ] ; return result ; }
int calculate ( int a [ ] , int maximum ) { int frequency [ maximum + 1 ] ; memset ( frequency , 0 , sizeof ( frequency ) ) ; for ( int i = 0 ; i <= maximum ; i ++ ) frequency [ i ] ++ ; int answer = 0 ; for ( int i = 0 ; i <= frequency . size ( ) ; i ++ ) answer += i * ( i - 1 ) / 2 ; return answer ; }
int sumNodes ( int l ) { unsigned int leafNodeCount = pow ( 2 , l - 1 ) ; int vec [ l ] [ leafNodeCount + 1 ] ; for ( int i = 1 ; i <= leafNodeCount ; i ++ ) vec [ l - 1 ] . push_back ( i ) ; for ( int i = l - 2 ; i >= 0 ; i -- ) { int k ; for ( k = 0 ; k < ( int ) vec [ i + 1 ] . size ( ) - 1 ; k ++ ) vec [ i ] . push_back ( vec [ i + 1 ] [ k ] + vec [ i + 1 ] [ k + 1 ] ) ; } int sum = 0 ; for ( int i = 0 ; i < l ; i ++ ) for ( int j = 0 ; j < ( int ) vec [ i ] . size ( ) ; j ++ ) sum += vec [ i ] [ j ] ; return sum ; }
string encrypt ( string text , int s ) { string result = " " ; for ( int i = 0 ; i < text . length ( ) ; i ++ ) { char = text [ i ] ; if ( char . isupper ( ) ) result += ( ( char ) + s - 65 ) % 26 + 65 ; else result += ( ( char ) + s - 97 ) % 26 + 97 ; } return result ; }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; if ( b == 0 ) return a ; int k = 0 ; while ( ( ( a | b ) & 1 ) == 0 ) { a = a >> 1 ; b = b >> 1 ; k ++ ; } while ( ( a & 1 ) == 0 ) a = a >> 1 ; while ( ( b & 1 ) == 0 ) b = b >> 1 ; if ( a > b ) { temp = a ; a = b ; b = temp ; } b = ( b - a ) ; } return ( a << k ) ; }
int calculateSum ( int arr [ ] , int n ) { if ( n == 0 ) return 0 ; int s = arr [ 0 ] ; int value = int ( s ) ; int sum = value ; for ( int i = 1 ; i < n ; i += 2 ) { s = arr [ i ] ; value = int ( s ) ; operation = arr [ i - 1 ] [ 0 ] ; if ( operation == ' + ' ) sum += value ; else sum -= value ; } return sum ; }
string replace ( string s , char c1 , char c2 ) { int l = s . length ( ) ; for ( int i = 0 ; i < l ; i ++ ) { if ( s [ i ] == c1 ) s = s [ 0 : i ] + c2 + s [ i + 1 : ] ; else if ( s [ i ] == c2 ) s = s [ 0 : i ] + c1 + s [ i + 1 : ] ; } return s ; }
string lexicographicSubConcat ( string s ) { int n = s . length ( ) ; int sub_count = ( n * ( n + 1 ) ) / 2 ; int arr [ sub_count ] ; int index = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 1 ; j <= n - i ; j ++ ) arr [ index ++ ] = s [ i : i + j ] ; index ++ ; } sort ( arr , arr + sub_count ) ; string res = " " ; for ( int i = 0 ; i < sub_count ; i ++ ) res += arr [ i ] ; return res ; }
int findpos ( string n ) { int i = 0 , j = n . length ( ) ; int pos = 0 ; while ( i < j ) { if ( n [ i ] == '4' ) pos = pos * 2 + 1 ; if ( n [ i ] == '7' ) pos = pos * 2 + 2 ; i ++ ; } return pos ; }
int lis ( int arr [ ] , int n ) { int mpis [ n ] ; for ( int i = 0 ; i < n ; i ++ ) mpis [ i ] = arr [ i ] ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && mpis [ i ] < ( mpis [ j ] * arr [ i ] ) ) mpis [ i ] = mpis [ j ] * arr [ i ] ; } } return max ( mpis ) ; }
bool checkSorted ( int n , queue < int > & q ) { vector < int > st ; int expected = 1 ; int fnt = null ; while ( ! q . empty ( ) ) { fnt = q . front ( ) ; q . pop ( ) ; if ( fnt == expected ) expected ++ ; else { if ( st . empty ( ) ) { st . push_back ( fnt ) ; } else { if ( st . empty ( ) ) { st . push_back ( fnt ) ; } else { if ( st . empty ( ) ) { st . push_back ( fnt ) ; } else { st . push_back ( fnt ) ; } } } while ( st . empty ( ) && st [ - 1 ] == expected ) { st . pop ( ) ; expected ++ ; } if ( expected - 1 == n && st . empty ( ) ) return true ; return false ; }
void generate ( vector < char > & str ) { if ( s . length ( ) == 0 ) return ; if ( str [ 0 ] == '' ) return ; if ( str [ 0 ] == '' ) return ; for ( int i = 0 ; str [ i ] != '' ; i ++ ) { string t = str [ i ] ; str [ i ] = str [ i ] ; generate ( str , str [ i ] ) ; } }
int minLexRotation ( char str [ ] ) { int n = strlen ( str ) ; int arr [ n ] ; char concat [ 2 * n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) concat [ i ] = str [ i ] ; sort ( arr , arr + n ) ; return arr [ 0 ] ; }
bool isPossible ( int a [ ] , int b [ ] , int n , int k ) { sort ( a , a + n ) ; sort ( b , b + n ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] + b [ i ] < k ) return false ; } return true ; }
bool isCornerPresent ( string str , string corner ) { int n = str . length ( ) ; int cl = corner . length ( ) ; if ( n < cl ) return false ; return ( str [ : cl ] == corner ) && ( str [ n - cl : ] == corner ) ; }
string longDivision ( string number , int divisor ) { string ans = " " ; int idx = 0 ; int temp = number [ idx ] - '0' ; while ( temp < divisor ) { temp = ( temp * 10 + ( number [ idx + 1 ] - '0' ) ) ; idx ++ ; } while ( ( len ( number ) ) > idx ) { ans += ( floor ( temp / divisor ) + '0' ) ; temp = ( floor ( temp % divisor ) * 10 + ( number [ idx ] - '0' ) ) ; idx ++ ; } ans += ( floor ( temp / divisor ) + '0' ) ; if ( len ( ans ) == 0 ) return "0" ; } return ans ; }
void sort012 ( int a [ ] , int arr_size ) { int lo = 0 , hi = arr_size - 1 ; int mid = 0 ; while ( mid <= hi ) { if ( a [ mid ] == 0 ) { swap ( a [ lo ] , a [ mid ] ) ; lo = lo + 1 ; mid = mid + 1 ; } else if ( a [ mid ] == 1 ) { mid = mid + 1 ; } else if ( a [ mid ] == 0 ) { swap ( a [ lo ] , a [ mid ] ) ; hi = hi - 1 ; } }
bool canRepresentBST ( int pre [ ] ) { stack < int > s ; int root = INT_MIN ; for ( int value = 0 ; value < pre . length ( ) ; value ++ ) { if ( value < root ) return false ; while ( s . empty ( ) && s [ - 1 ] < value ) { root = s . pop ( ) ; s . push_back ( value ) ; } s . push_back ( value ) ; } return true ; }
int solveQuery ( int start , int end , int arr [ ] ) { unordered_map < int , int > frequency ; for ( int i = start ; i <= end ; i ++ ) { if ( frequency [ arr [ i ] ] ) frequency [ arr [ i ] ] ++ ; else frequency [ arr [ i ] ] = 1 ; } int count = 0 ; for ( int x = 0 ; x < frequency . size ( ) ; x ++ ) if ( x == frequency [ x ] ) count ++ ; return count ; }
bool divisibleBy20 ( string num ) { int lastTwoDigits = num . length ( ) ; return ( ( lastTwoDigits % 5 == 0 && lastTwoDigits % 4 == 0 ) ) ; }
void CountTriangles ( int A [ ] ) { int n = A . size ( ) ; sort ( A , A + n ) ; int count = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { int l = 0 , r = i - 1 ; while ( l < r ) { if ( A [ l ] + A [ r ] > A [ i ] ) count += r - l ; r -- ; } else l ++ ; } cout << " No ▁ of ▁ possible ▁ solutions : ▁ " << count << endl ; }
void countFreq ( int a [ ] , int n ) { unordered_map < int , int > hm ; for ( int i = 0 ; i < n ; i ++ ) hm [ a [ i ] ] ++ ; int st ; for ( int x = 0 ; x < hm . size ( ) ; x ++ ) { st . insert ( ( x , hm [ x ] ) ) ; } int cumul = 0 ; for ( int x : st ) cumul += x [ 1 ] ; cout << x [ 0 ] << " ▁ " << cumul ; }
void cocktailSort ( int a [ ] , int n ) { int swapped = true ; int start = 0 , end = n - 1 ; while ( swapped == true ) { swapped = false ; for ( int i = start ; i <= end ; i ++ ) { if ( a [ i ] > a [ i + 1 ] ) { swap ( a [ i ] , a [ i + 1 ] ) ; swapped = true ; } } if ( swapped == false ) break ; int end = end - 1 ; for ( int i = end - 1 ; i >= start ; i -- ) { if ( a [ i ] > a [ i + 1 ] ) { swap ( a [ i ] , a [ i + 1 ] ) ; swapped = true ; } } start = start + 1 ; } }
int first ( string str , int i = 0 ) { if ( str [ i ] == ' \0' ) return 0 ; if ( str [ i ] . isupper ( ) ) return str [ i ] ; return first ( str , i + 1 ) ; }
int longestNull ( char * S ) { vector < char > arr ; arr . push_back ( ' @ ' ) ; arr . push_back ( - 1 ) ; int maxlen = 0 ; for ( int i = 0 ; i < S . length ( ) ; i ++ ) { arr . push_back ( S [ i ] , i ) ; while ( arr . size ( ) >= 3 && arr [ arr . size ( ) - 3 ] [ 0 ] == '1' && arr [ arr . size ( ) - 2 ] [ 0 ] == '0' && arr [ arr . size ( ) - 1 ] [ 0 ] == '0' ) { arr . pop ( ) ; arr . pop ( ) ; } tmp = arr [ - 1 ] ; maxlen = max ( maxlen , i - tmp [ 1 ] ) ; } return maxlen ; }
string reverse ( string str ) { str [ : : - 1 ] ; return str ; }
string nextWord ( string s ) { if ( s == " ▁ " ) return " a " ; int i ; for ( i = s . length ( ) - 1 ; i >= 0 ; i -- ) if ( s [ i ] == ' z ' && i >= 0 ) s [ i ] = ' a ' ; if ( i == - 1 ) s = s + ' a ' ; else s . push_back ( s [ i ] ) ; } return s ; }
bool isRectangle ( int matrix [ ] [ MAX ] ) { int rows = matrix [ 0 ] . size ( ) ; if ( rows == 0 ) return false ; int columns = matrix [ 0 ] . size ( ) ; int table [ rows ] [ columns ] ; for ( int i = 0 ; i < rows ; i ++ ) { for ( int j = 0 ; j <= columns - 1 ; j ++ ) { for ( int k = j + 1 ; k <= columns ; k ++ ) { if ( j in table && k in table [ j ] ) return true ; if ( table [ k ] . find ( j ) != table . end ( ) ) return true ; if ( j in table && k in table [ j ] ) return true ; if ( table [ k ] . find ( j ) != table [ j ] . end ( ) ) return true ; } } } return false ; }
int sumoflength ( int arr [ ] , int n ) { vector < int > s ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { while ( s . empty ( ) ) { s . push_back ( arr [ j ] ) ; j ++ ; } ans += ( ( j - i ) * ( j - i + 1 ) ) / 2 ; s . remove ( arr [ i ] ) ; } return ans ; }
void findTriplets ( int arr [ ] , int n ) { bool found = false ; for ( int i = 0 ; i < n - 1 && ! found ; i ++ ) { unordered_set < int > s ; for ( int j = i + 1 ; j < n ; j ++ ) { int x = ( arr [ i ] + arr [ j ] ) ; if ( x != s . end ( ) ) { cout << x << " ▁ ▁ Found " << arr [ i ] << " ▁ " << arr [ j ] << endl ; found = true ; } else s . insert ( arr [ j ] ) ; } } if ( found == false ) cout << " No ▁ Triplet ▁ Found " ; }
int maxPrefix ( string s , string t ) { int count = 0 ; for ( int i = 0 ; i < t . size ( ) ; i ++ ) { if ( count == ( s . length ( ) ) ) break ; if ( t [ i ] == s [ count ] ) count ++ ; } return count ; }
void segregateElements ( int arr [ ] , int n ) { int temp [ n ] ; int j = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] >= 0 ) temp [ j ] = arr [ i ] ; j ++ ; } if ( j == n || j == 0 ) return ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < 0 ) temp [ j ] = arr [ i ] ; j ++ ; } for ( int k = 0 ; k < n ; k ++ ) arr [ k ] = temp [ k ] ; }
void mergeIntervals ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int m [ n ] ; int s = INT_MIN , max = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { int a = arr [ i ] ; if ( a [ 0 ] > max ) { if ( i != 0 ) m . push_back ( [ s , max ] ) ; max = a [ 1 ] ; s = a [ 0 ] ; } else { if ( a [ 1 ] >= max ) { max = a [ 1 ] ; } } } if ( max != - 100000 && m . empty ( ) ) cout << " The ▁ Merged ▁ Intervals ▁ are ▁ : \n " << endl ; for ( int i = 0 ; i < m . size ( ) ; i ++ ) cout << m [ i ] << " ▁ " ; }
int findArea ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int dimension [ 2 ] ; memset ( dimension , 0 , sizeof ( dimension ) ) ; for ( int i = 0 , j = 0 ; i < n - 1 && j < 2 ; ++ i , ++ j ) { if ( arr [ i ] == arr [ i + 1 ] ) dimension [ j ] = arr [ i ] ; j ++ ; } i ++ ; } return ( dimension [ 0 ] * dimension [ 1 ] ) ; }
int minOps ( int arr [ ] , int n , int k ) { int max1 = max ( arr , arr + n ) ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( max1 - arr [ i ] ) % k != 0 ) return - 1 ; else res += ( max1 - arr [ i ] ) / k ; } return res ; }
bool isdivisible7 ( string num ) { int n = num . length ( ) ; if ( n == 0 && num [ 0 ] == ' \n ' ) return 1 ; if ( n % 3 == 1 ) num = str ( num ) + "00" ; n ++ ; else if ( n % 3 == 2 ) num = str ( num ) + "0" ; n ++ ; int GSum = 0 ; int p = 1 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { group += ( num [ i ] - '0' ) ; i -- ; group += ( num [ i ] - '0' ) * 10 ; i -- ; group += ( num [ i ] - '0' ) * 100 ; GSum = GSum + group * p ; p *= ( - 1 ) ; } return ( GSum % 7 == 0 ) ; }
bool isDivisible999 ( string num ) { int n = num . length ( ) ; if ( n == 0 || num [ 0 ] == '0' ) return true ; if ( ( n % 3 ) == 1 ) num = "00" + num ; if ( ( n % 3 ) == 2 ) num = "0" + num ; int gSum = 0 ; for ( int i = 0 ; i < n ; i += 3 ) { int group = ( num [ i ] - 48 ) * 100 ; group += ( num [ i + 1 ] - 48 ) * 10 ; group += ( num [ i + 2 ] - 48 ) ; gSum += group ; } if ( gSum > 1000 ) num = str ( gSum ) ; n = num . length ( ) ; gSum = isDivisible999 ( num ) ; return ( gSum == 999 ) ; }
bool checkPangram ( string s ) { vector < bool > list ; for ( int i = 0 ; i < 26 ; i ++ ) list . push_back ( false ) ; for ( char c = 0 ; c < s . length ( ) ; c ++ ) { if ( ! c . equals ( " ▁ " ) list [ c - ' a ' ] = true ; } for ( char ch : list ) if ( ch == false ) return false ; } return true ; }
void kLargest ( int arr [ ] , int k ) { sort ( arr , arr + k ) ; for ( int i = 0 ; i < k ; i ++ ) cout << arr [ i ] << " ▁ " ; }
int kthLargestSum ( int arr [ ] , int n , int k ) { int sum [ n + 1 ] ; sum . push_back ( arr [ 0 ] ) ; for ( int i = 2 ; i <= n ; i ++ ) sum . push_back ( arr [ i - 1 ] ) ; queue < int > Q ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = i ; j <= n ; j ++ ) { int x = sum [ j ] - sum [ i - 1 ] ; if ( Q . size ( ) < k ) heapq . push_back ( Q , x ) ; else { if ( Q [ 0 ] < x ) heapq . push_back ( Q , x ) ; } } } return Q [ 0 ] ; }
void printDistinct ( int arr [ ] , int n ) { unordered_map < int , int > s ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . find ( arr [ i ] ) == s . end ( ) ) { s [ arr [ i ] ] = arr [ i ] ; cout << arr [ i ] << " ▁ " ; } } }
int abFree ( string s ) { int b_count = 0 ; int res = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s [ ~ i ] == ' a ' ) { res += b_count ; b_count = ( b_count * 2 ) ; } else b_count ++ ; } return res ; }
void findFibSubset ( int arr [ ] , int n ) { int m = max ( arr , arr + n ) ; int a = 0 , b = 1 , hash [ m ] ; hash . push_back ( a ) ; hash . push_back ( b ) ; while ( b < m ) { int c = a + b ; a = b ; b = c ; hash . push_back ( b ) ; } for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] in hash ) cout << arr [ i ] << " ▁ " ; } }
void recursiveReverse ( char str [ ] , int i = 0 ) { int n = str . size ( ) ; if ( i == n / 2 ) return ; str [ i ] , str [ n - i - 1 ] = str [ n - i - 1 ] ; recursiveReverse ( str , i + 1 ) ; }
string noAdjacentDup ( string s ) { int n = s . length ( ) ; for ( int i = 1 ; i < n ; i ++ ) { if ( s [ i ] == s [ i - 1 ] ) { s [ i ] = " a " ; while ( s [ i ] == s [ i - 1 ] || ( i + 1 < n && s [ i ] == s [ i + 1 ] ) ) s [ i ] ++ ; i ++ ; } } return s ; }
void query ( char s [ ] , int i , int j ) { int n = strlen ( s ) ; i %= n ; j %= n ; if ( s [ i ] == s [ j ] ) cout << " Yes " ; else cout << " No " ; }
int countPairs ( int arr [ ] , int n ) { int result = 0 ; unordered_set < int > Hash ; for ( int i = 0 ; i < n ; i ++ ) Hash . insert ( arr [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int product = arr [ i ] * arr [ j ] ; if ( product in ( Hash ) ) result ++ ; } } return result ; }
void printInSortedOrder ( int arr [ ] , int n ) { int index [ n ] ; for ( int i = 0 ; i < n ; i ++ ) index [ i ] = i ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int min = i ; for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ index [ min ] ] > arr [ index [ j ] ] ) min = j ; if ( min != i ) index [ min ] , index [ i ] = index [ i ] , index [ min ] ; } for ( int i = 0 ; i < n ; i ++ ) cout << arr [ index [ i ] ] << " ▁ " ; }
void sortUsingHash ( int a [ ] , int n ) { int Max = max ( a ) ; int Min = abs ( min ( a ) ) ; int hashpos [ Max + 1 ] ; int hashneg [ Min + 1 ] ; memset ( hashpos , 0 , sizeof hashpos ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] >= 0 ) hashpos [ a [ i ] ] ++ ; else hashneg [ abs ( a [ i ] ) ] ++ ; } for ( int i = Min ; i >= 0 ; i -- ) { if ( hashneg [ i ] != 0 ) for ( int j = 0 ; j < hashneg [ i ] ; j ++ ) cout << ( - 1 ) * i << " ▁ " ; } for ( int i = 0 ; i <= Max ; i ++ ) { if ( hashpos [ i ] != 0 ) for ( int j = 0 ; j < hashpos [ i ] ; j ++ ) cout << ( i << " ▁ " ) ; } }
void findRandomIndexOfMax ( int arr [ ] , int n ) { map < int , int > mp ; for ( int i = 0 ; i < n ; i ++ ) mp [ arr [ i ] ] ++ ; int max_element = INT_MIN , max_so_far = INT_MAX ; for ( int p = 0 ; p < mp . size ( ) ; p ++ ) { if ( mp [ p ] > max_so_far ) { max_so_far = mp [ p ] ; max_element = p ; } } int r = ( random . randrange ( 1 , max_so_far , 2 ) % max_so_far ) + 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == max_element ) count ++ ; if ( count == r ) cout << " Element ▁ with ▁ maximum ▁ frequency ▁ present ▁ at ▁ index ▁ " << i << endl ; break ; } }
double singleNumber ( double nums [ ] ) { return ( 3 * sum ( set ( nums ) ) - sum ( nums ) ) / 2 ; }
void printAllAPTriplets ( int arr [ ] , int n ) { vector < int > s ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int diff = arr [ j ] - arr [ i ] ; if ( ( arr [ i ] - diff ) in arr ) cout << " { } ▁ { } ▁ " << ( arr [ i ] - diff ) << " ▁ " << ( arr [ j ] - diff ) << " ▁ " << endl ; } s . push_back ( arr [ i ] ) ; }
string simplify ( string str ) { int Len = str . length ( ) ; string res [ Len ] ; int index = 0 ; vector < char > s ; while ( i < Len ) { if ( str [ i ] == ' + ' ) { if ( s [ - 1 ] == 1 ) res [ index ] = ' - ' ; index ++ ; } else if ( str [ i ] == ' - ' ) { if ( s [ - 1 ] == 1 ) res [ index ] = ' + ' ; index ++ ; } else if ( s [ - 1 ] == 0 ) res [ index ] = ' - ' ; index ++ ; } else if ( str [ i ] == ' ( ' && i > 0 ) { if ( str [ i - 1 ] == ' - ' ) { int x = 0 if ( s [ - 1 ] == 1 ) else 1 ; s . push_back ( x ) ; } else if ( str [ i - 1 ] == ' + ' ) s . push_back ( s [ - 1 ] ) ; } else res [ index ] = str [ i ] ; index ++ ; } return res ; }
void findPair ( int arr [ ] , int n ) { unordered_map < int , int > s ; bool found = false ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( s . find ( arr [ i ] + arr [ j ] ) != s . end ( ) ) { cout << arr [ i ] << " ▁ " << arr [ j ] << endl ; found = true ; } } } if ( found == false ) cout << " Not ▁ exist " ; }
string strToBinary ( string s ) { string bin_conv = [ ] ; for ( char c = 0 ; c < s . length ( ) ; c ++ ) { int ascii_val = to_int ( c ) ; int binary_val = to_binary ( ascii_val ) ; bin_conv . push_back ( binary_val ) ; } return ( " ▁ " . join ( bin_conv ) ) ; }
bool findDuplicateparenthesis ( string str ) { stack < char > stack ; for ( char ch : str ) { if ( ch == ' ) ' ) { char top = Stack . top ( ) ; int elementsInside = 0 ; while ( top != ' ( ' ) elementsInside ++ ; top = Stack . pop ( ) ; if ( elementsInside < 1 ) return true ; } else Stack . push_back ( ch ) ; } return false ; }
void findTriplets ( int x ) { vector < int > fact ; vector < int > factors ; for ( int i = 2 ; i < sqrt ( x ) ; i ++ ) { if ( x % i == 0 ) fact . push_back ( i ) ; if ( x / i != i ) fact . push_back ( x / i ) ; factors . add ( i ) ; } bool found = false ; for ( int i = 0 ; i < k ; i ++ ) { int b = fact [ i ] ; for ( int j = 0 ; j < k ; j ++ ) { if ( a != b ) && ( x % ( a * b ) == 0 ) && ( x / ( a * b ) != a ) && ( x / ( a * b ) != b ) && ( x / ( a * b ) != 1 ) ) cout << a << " ▁ " << b << x / ( a * b ) ; found = true ; break ; } } if ( found ) cout << " - 1" ; }
void findMissing ( char a [ ] , char b [ ] , int n , int m ) { unordered_map < char , int > s ; for ( int i = 0 ; i < m ; i ++ ) s [ b [ i ] ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . find ( a [ i ] ) == s . end ( ) ) cout << a [ i ] << " ▁ " ; } }
void minheapify ( int a [ ] , int index ) { int small = index ; int l = 2 * index + 1 ; int r = 2 * index + 2 ; if ( l < n && a [ l ] < a [ small ] ) small = l ; if ( r < n && a [ r ] < a [ small ] ) small = r ; if ( small != index ) { swap ( a [ small ] , a [ index ] ) ; minheapify ( a , small ) ; } }
void KMP ( int m , int n , char str2 [ ] , char str1 [ ] ) { int pos = 0 , Len = 0 ; int p [ m + 1 ] ; for ( int i = 2 ; i <= n ; i ++ ) { int k = 0 ; for ( k = 0 ; k > 0 && str1 [ k ] != str1 [ i - 1 ] ; k ++ ) if ( str1 [ k ] == str1 [ i - 1 ] ) k ++ ; int j = 0 ; for ( int i = 0 ; i < m ; i ++ ) { while ( j > 0 && j < n && str1 [ j ] != str2 [ i ] ) j = p [ j ] ; if ( j < n && str1 [ j ] == str2 [ i ] ) j ++ ; if ( j > Len ) Len = j ; pos = i - j + 1 ; } } cout << " Shift ▁ = ▁ " << pos << " Prefix ▁ = ▁ " << str1 [ : Len ] << endl ; }
void swapDiagonal ( int matrix [ ] [ N ] ) { int i ; for ( i = 0 ; i < N ; i ++ ) { swap ( matrix [ i ] [ i ] , matrix [ i ] [ N - i - 1 ] ) ; } }
string maximumPalinUsingKChanges ( string str , int k ) { string palin = str ; int l = 0 , r = str . length ( ) - 1 ; while ( l <= r ) { if ( str [ l ] != str [ r ] ) { palin [ l ] = palin [ r ] = max ( str [ l ] , str [ r ] ) ; k -- ; } l ++ ; r -- ; } if ( k < 0 ) return " Not ▁ possible " ; } l = 0 ; r = str . length ( ) - 1 ; while ( l <= r ) { if ( l == r ) { if ( k > 0 ) palin [ l ] = '9' ; if ( palin [ l ] < '9' ) { if ( k >= 2 && palin [ l ] == str [ l ] && palin [ r ] == str [ r ] ) k -= 1 ; palin [ l ] = palin [ r ] = '9' ; } else if ( k >= 1 && ( palin [ l ] != str [ l ] || palin [ r ] != str [ r ] ) ) k -= 1 ; palin [ l ] = palin [ r ] = '9' ; } } l ++ , r -- ; } return palin ; }
int findMinRooms ( char slots [ ] [ MAX ] , int n , int m ) { int counts [ m ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( slots [ i ] [ j ] == '1' ) counts [ j ] ++ ; return max ( counts ) ; }
int minProduct ( int arr [ ] , int n , int k ) { heapify ( arr , arr + n ) ; int count = 0 ; int ans = 1 ; while ( arr . size ( ) > 0 && count < k ) { int x = heapq . front ( arr ) ; ans = ans * x ; count ++ ; } return ans ; }
int largest ( int arr [ ] , int n ) { return max ( arr , n - 1 ) ; }
int findLongestConseqSubseq ( int arr [ ] , int n ) { unordered_set < int > S ; for ( int i = 0 ; i < n ; i ++ ) S . insert ( arr [ i ] ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( S . find ( arr [ i ] ) != S . end ( ) ) { int j = arr [ i ] ; while ( S . find ( j ) != S . end ( ) ) j ++ ; ans = max ( ans , j - arr [ i ] ) ; } } return ans ; }
void divisibilityCheck ( int arr [ ] , int n ) { unordered_map < int , int > s ; int max_ele = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { s [ arr [ i ] ] = 1 ; max_ele = max ( max_ele , arr [ i ] ) ; } int res [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != 0 ) { for ( int j = arr [ i ] * 2 ; j <= max_ele ; j ++ ) if ( s . find ( j ) != s . end ( ) ) res [ j ] = 1 ; } } for ( int x : res ) cout << x << " ▁ " ; }
int minPalPartion ( char * str ) { int n = strlen ( str ) ; int C [ n ] [ n ] ; bool P [ n ] [ n ] ; int j = 0 , k = 0 , L = 0 ; for ( int i = 0 ; i < n ; i ++ ) { P [ i ] [ i ] = true ; C [ i ] [ i ] = 0 ; } for ( int L = 2 ; L <= n ; L ++ ) { for ( int i = 0 ; i < n - L + 1 ; i ++ ) { j = i + L - 1 ; if ( L == 2 ) P [ i ] [ j ] = ( str [ i ] == str [ j ] ) ; else P [ i ] [ j ] = ( str [ i ] == str [ j ] ) && P [ i + 1 ] [ j - 1 ] ; if ( P [ i ] [ j ] == true ) C [ i ] [ j ] = 0 ; else { C [ i ] [ j ] = 100000000 ; for ( int k = i ; k <= j ; k ++ ) { C [ i ] [ j ] = min ( C [ i ] [ j ] , C [ i ] [ k ] + C [ k + 1 ] [ j ] + 1 ) ; } } } return C [ 0 ] [ n - 1 ] ; }
bool checkCount ( int arr [ ] , int n , int k ) { map < int , int > mp ; for ( int i = 0 ; i < n ; i ++ ) mp [ arr [ i ] ] ++ ; for ( int key = 0 ; key < n ; key ++ ) { if ( mp [ key ] > 2 * k ) return false ; } return true ; }
string removeDuplicates ( string S ) { int n = S . length ( ) ; if ( n < 2 ) return S ; int j = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( S [ j ] != S [ i ] ) j ++ ; S [ j ] = S [ i ] ; } j ++ ; S = S [ : j ] ; } return S ; }
void KMaxCombinations ( int A [ ] , int B [ ] , int N , int K ) { PriorityQueue < int > pq ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { int a = A [ i ] + B [ j ] ; pq . push ( ( - a , a ) ) ; } } int count = 0 ; while ( count < K ) cout << pq . front ( ) [ 1 ] ; count ++ ; }
string to_upper ( string str ) { for ( int i = 0 ; i < str . length ( ) ; i ++ ) if ( ' a ' <= str [ i ] <= ' z ' ) string = ( str [ 0 : i ] + ( str [ i ] - ' a ' ) + ' A ' ) + str [ i + 1 : ] ; return str ; }
void sortInWave ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i += 2 ) { if ( i > 0 && arr [ i ] < arr [ i - 1 ] ) arr [ i ] , arr [ i - 1 ] = arr [ i - 1 ] ; if ( i < n - 1 && arr [ i ] < arr [ i + 1 ] ) arr [ i ] , arr [ i + 1 ] = arr [ i + 1 ] ; } }
string getMinNumberForPattern ( string seq ) { int n = seq . length ( ) ; if ( n >= 9 ) return " - 1" ; string result [ n + 1 ] ; int count = 1 ; for ( int i = 0 ; i <= n ; i ++ ) { if ( i == n || seq [ i ] == ' I ' ) { for ( int j = i - 1 ; j >= 0 && seq [ j ] == ' I ' ; j -- ) result [ j + 1 ] = '0' + ( count ) ; count ++ ; if ( j >= 0 && seq [ j ] == ' I ' ) break ; } } return result ; }
void findMin ( int V ) { int deno [ 2 ] = { 1 , 2 , 5 , 10 , 20 , 50 , 100 , 500 , 1000 } ; int ans [ n ] ; for ( int i = n - 1 ; i >= 0 ; i -- ) { while ( V >= deno [ i ] ) { V -= deno [ i ] ; ans . push_back ( deno [ i ] ) ; } i -- ; } for ( int i = 0 ; i < n ; i ++ ) { while ( V >= deno [ i ] ) { V -= deno [ i ] ; ans . push_back ( deno [ i ] ) ; } for ( int i = 0 ; i < ans . size ( ) ; i ++ ) cout << ans [ i ] << " ▁ " ; }
int findRepeating ( int arr [ ] , int n ) { return sum ( arr ) - ( ( ( n - 1 ) * n ) / 2 ) ; }
string findSum ( string str1 , string str2 ) { if ( str1 . length ( ) > str2 . length ( ) ) { string t = str1 ; str1 = str2 ; str2 = t ; } string str = " " ; int n1 = str1 . size ( ) ; int n2 = str2 . size ( ) ; str1 = str1 [ : : - 1 ] ; str2 = str2 [ : : - 1 ] ; int carry = 0 ; for ( int i = 0 ; i < n1 ; i ++ ) { int sum = ( ( str1 [ i ] - 48 ) + ( ( str2 [ i ] - 48 ) + carry ) ; str += ( sum % 10 + 48 ) ; carry = ( int ) ( sum / 10 ) ; } for ( int i = n1 ; i < n2 ; i ++ ) { int sum = ( ( str2 [ i ] - 48 ) + carry ) ; str += ( sum % 10 + 48 ) ; carry = ( int ) ( sum / 10 ) ; } if ( carry ) str += ( carry + 48 ) ; return str ; }
