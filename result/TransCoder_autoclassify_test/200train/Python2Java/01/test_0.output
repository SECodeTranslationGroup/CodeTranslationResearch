static void printPairs ( int arr [ ] , int n ) { int [ ] v = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( Math . abs ( arr [ i ] ) == Math . abs ( arr [ j ] ) ) v . add ( Math . abs ( arr [ i ] ) ) ; } } Collections . sort ( v ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( - v [ i ] + " ▁ " ) ; }
static void findArea ( int a , int b , int c ) { if ( a < 0 || b < 0 || c < 0 || ( a + b <= c ) || ( a + c <= b ) || ( b + c <= a ) ) System . out . println ( " Not ▁ a ▁ valid ▁ trianglen " ) ; return ; } int s = ( a + b + c ) / 2 ; double area = ( s * ( s - a ) * ( s - b ) * ( s - c ) ) ** 0.5 ; System . out . println ( ' Area ▁ of ▁ a ▁ traingle ▁ is ▁ % f ' % area ) ; }
static boolean isMajority ( int [ ] a ) { int [ ] mp = new int [ a . length ] ; for ( int i = 0 ; i < a . length ; i ++ ) { if ( mp . containsKey ( i ) ) { mp . put ( i , 1 ) ; } else { mp . put ( i , 1 ) ; } } for ( int x = 0 ; x < mp . length ; x ++ ) { if ( mp . get ( x ) >= a . length / 2 ) return true ; } return false ; }
static int nonDecNums ( int n ) { int [ ] [ ] a = new int [ n + 1 ] [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) a [ 0 ] [ i ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) a [ i ] [ 9 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 8 ; j <= - 1 ; j ++ ) a [ i ] [ j ] = a [ i - 1 ] [ j ] + a [ i ] [ j + 1 ] ; } return a [ n ] [ 0 ] ; }
static void firstFit ( int blockSize [ ] , int m , int processSize [ ] , int n ) { int [ ] allocation = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( blockSize [ j ] >= processSize [ i ] ) { allocation [ i ] = j ; blockSize [ j ] -= processSize [ i ] ; break ; } } } System . out . println ( " ▁ Process ▁ No . ▁ Process ▁ Size ▁ ▁ ▁ Block ▁ No . " ) ; for ( int i = 0 ; i < n ; i ++ ) { System . out . println ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " ) ; if ( allocation [ i ] != - 1 ) System . out . println ( allocation [ i ] + 1 ) ; else System . out . println ( " Not ▁ Allocated " ) ; } }
static int firstNonRepeating ( int arr [ ] , int n ) { Map < Integer , Integer > myMap = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) myMap . put ( arr [ i ] , myMap . get ( arr [ i ] ) + 1 ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( myMap . get ( arr [ i ] ) == 1 ) return arr [ i ] ; } return - 1 ; }
static boolean distributingBalls ( int k , int n , String str ) { int [ ] a = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < n ; i ++ ) a [ str . charAt ( i ) - ' a ' ] ++ ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) if ( a [ i ] > k ) return false ; return true ; }
static int count_of_ways ( int n ) { int count = 0 ; count = ( n + 1 ) * ( n + 2 ) / 2 ; return count ; }
static int maxSum ( int arr [ ] , int n ) { int cum_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { cum_sum += arr [ i ] ; } int curr_val = 0 ; for ( int i = 0 ; i < n ; i ++ ) { curr_val += i * arr [ i ] ; } int res = curr_val ; for ( int i = 1 ; i < n ; i ++ ) { int next_val = ( curr_val - ( cum_sum - arr [ i - 1 ] ) + arr [ i - 1 ] * ( n - 1 ) ) ; curr_val = next_val ; res = Math . max ( res , next_val ) ; } return res ; }
static int calcAngle ( int h , int m ) { if ( h < 0 || m < 0 || h > 12 || m > 60 ) System . out . println ( " Wrong ▁ input " ) ; if ( h == 12 ) h = 0 ; if ( m == 60 ) m = 0 ; int hour_angle = 0.5 * ( h * 60 + m ) ; int minute_angle = 6 * m ; int angle = Math . abs ( hour_angle - minute_angle ) ; angle = Math . min ( 360 - angle , angle ) ; return angle ; }
static int smallest ( int x , int y , int z ) { if ( ! ( y / x ) ) return y ; return x if ( ! ( x / z ) ) else z ; }
static char findExtraCharcter ( String strA , String strB ) { int res = 0 ; for ( int i = 0 ; i < strA . length ( ) ; i ++ ) res = res ^ ( char ) ( strA . charAt ( i ) ) ; for ( int i = 0 ; i < strB . length ( ) ; i ++ ) res = res ^ ( char ) ( strB . charAt ( i ) ) ; return ( ( char ) ( res ) ) ; }
static void recaman ( int n ) { if ( n <= 0 ) return ; HashSet < Integer > s = new HashSet < Integer > ( ) ; System . out . print ( 0 + " , " ) ; int prev = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int curr = prev - i ; if ( curr < 0 || curr >= s ) curr = prev + i ; s . add ( curr ) ; System . out . print ( curr + " , " ) ; prev = curr ; } }
static int findMinimumAngle ( int arr [ ] , int n ) { int l = 0 ; int _sum = 0 ; int ans = 360 ; for ( int i = 0 ; i < n ; i ++ ) { _sum += arr [ i ] ; while ( _sum >= 180 ) { ans = Math . min ( ans , 2 * Math . abs ( 180 - _sum ) ) ; _sum -= arr [ l ] ; l ++ ; } ans = Math . min ( ans , 2 * Math . abs ( 180 - _sum ) ) ; } return ans ; }
static void countSubsequence ( String s , int n ) { int cntG = 0 , cntF = 0 ; int result = 0 ; int C = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == ' G ' ) cntG ++ ; result += C ; continue ; if ( s . charAt ( i ) == ' F ' ) cntF ++ ; C += cntG ; continue ; } System . out . println ( result ) ; }
static int maxdiff ( int arr [ ] , int n ) { int freq [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) freq [ arr [ i ] ] ++ ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( freq [ arr [ i ] ] > freq [ arr [ j ] ] && arr [ i ] > arr [ j ] ) ans = Math . max ( ans , freq [ arr [ i ] ] - freq [ arr [ j ] ] ) ; else if ( freq [ arr [ i ] ] < freq [ arr [ j ] ] && arr [ i ] < arr [ j ] ) ans = Math . max ( ans , freq [ arr [ j ] ] - freq [ arr [ i ] ] ) ; } } return ans ; }
static boolean areEqual ( int arr1 [ ] , int arr2 [ ] , int n , int m ) { if ( n != m ) return false ; Arrays . sort ( arr1 ) ; Arrays . sort ( arr2 ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr1 [ i ] != arr2 [ i ] ) return false ; } return true ; }
static int countFriendsPairings ( int n ) { int a = 1 , b = 2 , c = 0 ; if ( n <= 2 ) return n ; for ( int i = 3 ; i <= n ; i ++ ) { c = b + ( i - 1 ) * a ; a = b ; b = c ; } return c ; }
static int PowerOFPINnfactorial ( int n , int p ) { int ans = 0 ; int temp = p ; while ( temp <= n ) ans += n / temp ; temp = temp * p ; return ans ; }
static int findLength ( String str ) { int n = str . length ( ) ; int maxlen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int length = j - i + 1 ; int leftsum = 0 , rightsum = 0 ; for ( int k = 0 ; k < length / 2 ; k ++ ) { leftsum += ( str . charAt ( i + k ) - '0' ) ; rightsum += ( str . charAt ( i + k + int ( length / 2 ) ) - '0' ) ; } if ( leftsum == rightsum && maxlen < length ) { maxlen = length ; } } } return maxlen ; }
static int search ( int arr [ ] , int n , int x ) { int i ; for ( i = 0 ; i < n ; i ++ ) if ( arr [ i ] == x ) return i ; return - 1 ; }
static void subArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { for ( int k = i ; k <= j ; k ++ ) System . out . print ( arr [ k ] + " ▁ " ) ; System . out . println ( ) ; } } }
static boolean isSubSeqDivisible ( String str ) { int n = str . length ( ) ; int dp [ ] [ ] = new int [ n + 1 ] [ 8 ] ; int arr [ ] = new int [ n + 1 ] [ 8 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) { dp [ i ] [ 0 ] = i ; } for ( int i = 1 ; i <= n ; i ++ ) { arr [ i ] = str . charAt ( i - 1 ) ; } for ( int i = 1 ; i <= n ; i ++ ) { dp [ i ] [ arr [ i ] % 8 ] = 1 ; for ( int j = 0 ; j <= 9 ; j ++ ) { if ( dp [ i - 1 ] [ j ] > dp [ i ] [ ( j * 10 + arr [ i ] ) % 8 ] ) { dp [ i ] [ ( j * 10 + arr [ i ] ) % 8 ] = dp [ i - 1 ] [ j ] ; } if ( dp [ i - 1 ] [ j ] > dp [ i ] [ j ] ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; } } } for ( int i = 1 ; i <= n ; i ++ ) if ( dp [ i ] [ 0 ] == 1 ) return true ; return false ; }
static int solve ( int i , int par , int a [ ] , int n , int k , int current_ans ) { if ( par > k ) return 0 ; if ( par == k && i == n - 1 ) ans = Math . min ( ans , current_ans ) ; for ( int j = i + 1 ; j < n ; j ++ ) solve ( j , par + 1 , a , n , k , current_ans + ( a [ j ] - a [ i + 1 ] ) * ( a [ j ] - a [ i + 1 ] ) ) ; return 0 ; }
static int squareRoot ( int n ) { int x = n ; int y = 1 ; double e = 0.000001 ; while ( x - y > e ) { x = ( x + y ) / 2 ; y = n / x ; } return x ; }
static int CountPairs ( int n ) { int k = n ; int imin = 1 ; int ans = 0 ; while ( imin <= n ) { int imax = n / k ; ans += k * ( imax - imin + 1 ) ; imin = imax + 1 ; k = n / imin ; } return ans ; }
static int multiplyWith3Point5 ( int x ) { return ( x << 1 ) + x + ( x >> 1 ) ; }
static boolean prevPermutation ( String str ) { int n = str . length ( ) - 1 ; int i = n ; while ( i > 0 && str . charAt ( i - 1 ) <= str . charAt ( i ) ) i -- ; if ( i <= 0 ) return false ; int j = i - 1 ; while ( j + 1 <= n && str . charAt ( j + 1 ) <= str . charAt ( i - 1 ) ) j ++ ; str . append ( str . charAt ( i - 1 ) ) ; return true ; }
static int polygonArea ( double X [ ] , double Y [ ] , int n ) { double area = 0.0 ; int j = n - 1 ; for ( int i = 0 ; i < n ; i ++ ) { area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) ; j = i ; } return Math . abs ( area / 2.0 ) ; }
static int equilibrium ( int arr [ ] ) { int leftsum = 0 , rightsum = 0 ; int n = arr . length ; for ( int i = 0 ; i < n ; i ++ ) { leftsum = 0 ; rightsum = 0 ; for ( int j = i ; j < n ; j ++ ) leftsum += arr [ j ] ; if ( leftsum == rightsum ) return i ; } return - 1 ; }
static int chordCnt ( int A ) { int n = 2 * A ; int [ ] dpArray = new int [ n + 1 ] ; dpArray [ 0 ] = 1 ; dpArray [ 2 ] = 1 ; for ( int i = 4 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= i - 2 ; j ++ ) dpArray [ i ] += ( dpArray [ j ] * dpArray [ i - 2 - j ] ) ; } return dpArray [ n ] ; }
static int compute ( int a , int b ) { int AM = ( a + b ) / 2 ; int GM = ( a * b ) / 2 ; int HM = ( GM * GM ) / AM ; return HM ; }
static void findMajority ( int arr [ ] , int n ) { int maxCount = 0 ; int index = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) if ( arr [ i ] == arr [ j ] ) count ++ ; if ( count > maxCount ) { maxCount = count ; index = i ; } } if ( maxCount > n / 2 ) System . out . println ( arr [ index ] + " ▁ Majority ▁ Element " ) ; else System . out . println ( " No ▁ Majority ▁ Element " ) ; }
static boolean isPerfectSquare ( int n ) { int i = 1 ; int the_sum = 0 ; while ( the_sum < n ) { the_sum += i ; if ( the_sum == n ) return true ; i += 2 ; } return false ; }
static String findSubString ( String str , String pat ) { int len1 = str . length ( ) ; int len2 = pat . length ( ) ; if ( len1 < len2 ) System . out . println ( " No ▁ such ▁ window ▁ exists " ) ; return null ; }
static int countDivisibleSubseq ( String str , int n ) { int l = str . length ( ) ; int dp [ ] [ ] = new int [ l ] [ n ] ; for ( int i = 1 ; i < l ; i ++ ) { dp [ 0 ] [ ( str . charAt ( i ) - '0' ) % n ] ++ ; for ( int i = 1 ; i < l ; i ++ ) { dp [ i ] [ ( str . charAt ( i ) - '0' ) % n ] ++ ; for ( int j = 0 ; j < n ; j ++ ) { dp [ i ] [ j ] += dp [ i - 1 ] [ j ] ; } } return dp [ l - 1 ] [ 0 ] ; }
static void pairs ( int arr [ ] , int n , int k ) { int smallest = Integer . MAX_VALUE ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( Math . abs ( arr [ i ] + arr [ j ] - k ) < smallest ) smallest = Math . abs ( arr [ i ] + arr [ j ] - k ) ; count ++ ; } else if ( Math . abs ( arr [ i ] + arr [ j ] - k ) == smallest ) count ++ ; } System . out . println ( " Minimal ▁ Value ▁ = ▁ " + smallest + " Total ▁ Pairs ▁ = ▁ " + count ) ; }
static int nearestSmallerEqFib ( int n ) { if ( n == 0 || n == 1 ) return n ; int f1 = 0 , f2 = 1 , f3 = 0 ; while ( f3 <= n ) { f1 = f2 ; f2 = f3 ; f3 = f1 + f2 ; } return f2 ; }
static void shuffle ( int card [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int r = i + ( random . nextInt ( 0 , 55 ) % ( 52 - i ) ) ; int tmp = card [ i ] ; card [ i ] = card [ r ] ; card [ r ] = tmp ; } }
static int maxLen ( int arr [ ] ) { int max_len = 0 ; int curr_sum = 0 ; int start = 0 ; int end = - 1 ; HashMap < Integer , Integer > hash_map = new HashMap < > ( ) ; for ( int i = 0 ; i < arr . length ; i ++ ) { curr_sum += arr [ i ] ; if ( arr [ i ] is 0 && max_len == 0 ) { max_len = 1 ; } if ( curr_sum is 0 ) { max_len = i + 1 ; } if ( hash_map . containsKey ( curr_sum ) ) { max_len = Math . max ( max_len , i - hash_map . get ( curr_sum ) ) ; } else hash_map . put ( curr_sum , i ) ; } return max_len ; }
static int maxLength ( String s , int n ) { int [ ] [ ] dp = new int [ n ] [ n ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( s . charAt ( i ) == ' ( ' && s . charAt ( i + 1 ) == ' ) ' ) dp [ i ] [ i + 1 ] = 2 ; for ( int l = 2 ; l < n ; l ++ ) { i -- ; if ( s . charAt ( i ) == ' ( ' && s . charAt ( j ) == ' ) ' ) dp [ i ] [ j ] = 2 + dp [ i + 1 ] [ j - 1 ] ; for ( int k = i ; k < j ; k ++ ) { dp [ i ] [ j ] = Math . max ( dp [ i ] [ j ] , dp [ i ] [ k ] + dp [ k + 1 ] [ j ] ) ; } } } return dp [ 0 ] [ n - 1 ] ; }
static double summingSeries ( int n ) { return Math . pow ( n , 2 ) ; }
static boolean isSubsetSum ( int arr [ ] , int n , int sum ) { boolean [ ] [ ] subset = new boolean [ 3 ] [ sum + 1 ] ; for ( int i = 0 ; i <= 3 ; i ++ ) { for ( int j = 0 ; j <= sum ; j ++ ) { if ( j == 0 ) subset [ i % 2 ] [ j ] = true ; else if ( i == 0 ) subset [ i % 2 ] [ j ] = false ; else if ( arr [ i - 1 ] <= j ) subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j - arr [ i - 1 ] ] || subset [ ( i + 1 ) % 2 ] [ j ] ; else { subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j ] ; } } } return subset [ n % 2 ] [ sum ] ; }
static int findExtra ( int arr1 [ ] , int arr2 [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) if ( arr1 [ i ] != arr2 [ i ] ) return i ; return n ; }
public static int numberOfPermWithKInversion ( int N , int K ) { if ( N == 0 ) return 0 ; if ( K == 0 ) return 1 ; if ( memo [ N ] [ K ] != 0 ) return memo [ N ] [ K ] ; int sum = 0 ; for ( int i = 0 ; i <= K ; i ++ ) { if ( i <= N - 1 ) sum += numberOfPermWithKInversion ( N - 1 , K - i ) ; } } memo [ N ] [ K ] = sum ; return sum ; }
static int removeConsecutiveSame ( String v ) { Stack < Character > st = new Stack < Character > ( ) ; for ( int i = 0 ; i < v . length ( ) ; i ++ ) { if ( st . size ( ) == 0 ) { st . add ( v [ i ] ) ; } else { Character str = st . peek ( ) ; if ( str == v [ i ] ) { st . pop ( ) ; } else { str . append ( v [ i ] ) ; } } return st . size ( ) ; }
public static void find ( int [ ] list1 , int [ ] list2 ) { List < Integer > res = new ArrayList < Integer > ( ) ; int max_possible_sum = Math . max ( list1 . length , list2 . length ) - 2 ; for ( int sum = 0 ; sum <= max_possible_sum ; sum ++ ) { for ( int i = 0 ; i <= sum ; i ++ ) { if ( i < list1 . length && ( sum - i ) < list2 . length && list1 . get ( i ) == list2 . get ( sum - i ) ) res . add ( list1 [ i ] ) ; } if ( res . length > 0 ) break ; for ( int i = 0 ; i < res . length ; i ++ ) System . out . print ( res [ i ] + " ▁ " ) ; }
static int firstNonRepeating ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < n ; j ++ ) if ( i != j && arr [ i ] == arr [ j ] ) break ; if ( j == n ) return arr [ i ] ; } return - 1 ; }
static int search ( int arr [ ] , int x ) { int n = arr . length ; for ( int j = 0 ; j < n ; j ++ ) if ( arr [ j ] == x ) return j ; return - 1 ; }
static void middlesum ( int [ ] [ ] mat , int n ) { int row_sum = 0 , col_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) row_sum += mat [ n / 2 ] [ i ] ; System . out . println ( " Sum ▁ of ▁ middle ▁ row ▁ = ▁ " + row_sum ) ; for ( int i = 0 ; i < n ; i ++ ) col_sum += mat [ i ] [ n / 2 ] ; System . out . println ( " Sum ▁ of ▁ middle ▁ column ▁ = ▁ " + col_sum ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . println ( " Sum ▁ of ▁ middle ▁ column ▁ = ▁ " + col_sum ) ; }
static int moduloMultiplication ( int a , int b , int mod ) { int res = 0 ; a = a % mod ; b = b % mod ; while ( b ) { if ( b & 1 ) res += ( res + a ) % mod ; a = ( 2 * a ) % mod ; b >>= 1 ; } return res ; }
static void pythagoreanTriplets ( int limits ) { int c = 0 , m = 2 ; while ( c < limits ) { for ( int n = 1 ; n < m ; n ++ ) { int a = m * m - n * n ; int b = 2 * m * n ; c = m * m + n * n ; if ( c > limits ) break ; System . out . println ( a + " ▁ " + b + " ▁ " ) ; } m ++ ; } }
static int findSum ( int n ) { return n * ( n + 1 ) * ( n + 2 ) * ( 3 * n + 1 ) / 24 ; }
static int fib ( int n ) { if ( n == 0 ) return 0 ; if ( n == 1 || n == 2 ) return 1 ; if ( f [ n ] ) return ( f [ n ] ) ; if ( f [ n ] ) return f [ n ] ; if ( n & 1 ) { int k = ( n + 1 ) / 2 ; else { k = n / 2 ; } if ( ( n & 1 ) ) { f [ n ] = ( fib ( k ) * fib ( k ) + fib ( k - 1 ) * fib ( k - 1 ) ) ; } else { f [ n ] = ( 2 * fib ( k - 1 ) + fib ( k ) ) * fib ( k ) ; } return f [ n ] ; }
static int largestPower ( int n , int p ) { int x = 0 ; while ( n > 0 ) { n /= p ; x += n ; } return x ; }
static boolean isIdentity ( int mat [ ] [ ] , int N ) { for ( int row = 0 ; row < N ; row ++ ) { for ( int col = 0 ; col < N ; col ++ ) { if ( row == col && mat [ row ] [ col ] != 1 ) return false ; else if ( row != col && mat [ row ] [ col ] != 0 ) return false ; } } return true ; }
static int minCells ( int mat [ ] [ ] , int m , int n ) { int dp [ ] [ ] = new int [ m ] [ n ] ; dp [ 0 ] [ 0 ] = 1 ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( dp [ i ] [ j ] != MAX && ( j + mat [ i ] [ j ] ) < n && ( dp [ i ] [ j ] + 1 ) < dp [ i ] [ j + mat [ i ] [ j ] ] ) dp [ i ] [ j + mat [ i ] [ j ] ] = dp [ i ] [ j ] + 1 ; if ( dp [ i ] [ j ] != MAX && ( i + mat [ i ] [ j ] ) < m && ( dp [ i ] [ j ] + 1 ) < dp [ i + mat [ i ] [ j ] ] [ j ] ) dp [ i ] [ j ] = dp [ i ] [ j ] + 1 ; } } } if ( dp [ m - 1 ] [ n - 1 ] != MAX ) return dp [ m - 1 ] [ n - 1 ] ; return - 1 ; }
static void arrangeString ( String str , int x , int y ) { int count_0 = 0 , count_1 = 0 ; int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( str . charAt ( i ) == '0' ) count_0 ++ ; else count_1 ++ ; } while ( count_0 > 0 || count_1 > 0 ) { for ( int i = 0 ; i < x ; i ++ ) { if ( count_0 > 0 ) System . out . print ( "0 ▁ " ) ; count_0 -- ; } for ( int j = 0 ; j < y ; j ++ ) { if ( count_1 > 0 ) System . out . print ( " 1 ▁ " ) ; count_1 -- ; } } }
static int getLevenstein ( int inpt [ ] ) { int revInput [ ] = inpt [ : : - 1 ] ; int n = inpt . length ; int dp [ ] [ ] = new int [ n + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { dp [ 0 ] [ i ] = i ; dp [ i ] [ 0 ] = i ; } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( inpt [ i - 1 ] == revInput [ j - 1 ] ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ; } else { dp [ i ] [ j ] = 1 + Math . min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) ; } } } int res = Integer . MAX_VALUE ; for ( int i = n ; i >= 0 ; i -- ) { res = Math . min ( res , dp [ i ] [ j ] ) ; if ( i < n ) res = Math . min ( res , dp [ i + 1 ] [ j ] ) ; if ( i > 0 ) res = Math . min ( res , dp [ i - 1 ] [ j ] ) ; i -- ; j ++ ; } } return res ; }
static int carAssembly ( int a [ ] [ ] , int t , int e , int x [ ] ) { int NUM_STATION = a . length ; int T1 [ ] = new int [ NUM_STATION ] ; int T2 [ ] = new int [ NUM_STATION ] ; for ( int i = 0 ; i < NUM_STATION ; i ++ ) T1 [ i ] = e [ 0 ] + a [ 0 ] [ 0 ] ; T2 [ 0 ] = e [ 1 ] + a [ 1 ] [ 0 ] ; for ( int i = 1 ; i < NUM_STATION ; i ++ ) { T1 [ i ] = Math . min ( T1 [ i - 1 ] + a [ 0 ] [ i ] , T2 [ i - 1 ] + t [ 1 ] [ i ] + a [ 1 ] [ i ] ) ; T2 [ i ] = Math . min ( T2 [ i - 1 ] + a [ 1 ] [ i ] , T1 [ i - 1 ] + t [ 0 ] [ i ] + a [ 1 ] [ i ] ) ; } return Math . min ( T1 [ NUM_STATION - 1 ] + x [ 0 ] , T2 [ NUM_STATION - 1 ] + x [ 1 ] ) ; }
static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
static void findTriplets ( int arr [ ] , int n ) { boolean found = false ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < n - 1 && ! found ; ++ i ) { int l = i + 1 ; int r = n - 1 ; int x = arr [ i ] ; while ( l < r ) { if ( x + arr [ l ] + arr [ r ] == 0 ) System . out . println ( x + arr [ l ] + arr [ r ] ) ; l ++ ; r -- ; found = true ; } else if ( x + arr [ l ] + arr [ r ] < 0 ) l ++ ; else r -- ; } if ( found == false ) System . out . println ( " ▁ No ▁ Triplet ▁ Found " ) ; }
static int getOddOccurrence ( int arr [ ] ) { int res = 0 ; for ( int element = 0 ; element < arr . length ; element ++ ) res = res ^ element ; return res ; }
static int maxTasks ( int high [ ] , int low [ ] , int n ) { if ( n <= 0 ) return 0 ; return Math . max ( high [ n - 1 ] + maxTasks ( high , low , ( n - 2 ) ) , low [ n - 1 ] + maxTasks ( high , low , ( n - 1 ) ) ) ; }
static void printOtherSides ( int n ) { if ( n & 1 ) { if ( n == 1 ) System . out . println ( - 1 ) ; else { int b = ( n * n - 1 ) / 2 ; int c = ( n * n + 1 ) / 2 ; System . out . println ( " b ▁ = ▁ " + b + " , ▁ c ▁ = " + c ) ; } } else { if ( n & 2 ) { System . out . println ( - 1 ) ; } else { int b = n * n / 4 - 1 ; int c = n * n / 4 + 1 ; System . out . println ( " b ▁ = ▁ " + b + " , ▁ c ▁ = ▁ " + c ) ; } } }
static void printUnsorted ( int arr [ ] , int n ) { int e , s ; for ( s = 0 ; s < n - 1 ; s ++ ) { if ( arr [ s ] > arr [ s + 1 ] ) { break ; } } if ( s == n - 1 ) { System . out . println ( " The ▁ complete ▁ array ▁ is ▁ sorted " ) ; exit ( ) ; } e = n - 1 ; while ( e > 0 ) { if ( arr [ e ] < arr [ e - 1 ] ) { break ; } int max = arr [ s ] ; int min = arr [ s ] ; for ( int i = s + 1 ; i <= e ; i -- ) { if ( arr [ i ] > min ) { s = i ; break ; } } for ( int i = n - 1 ; i >= e + 1 ; i -- ) { if ( arr [ i ] < max ) { e = i ; break ; } } System . out . println ( " The ▁ unsorted ▁ subarray ▁ which ▁ makes ▁ the ▁ given ▁ array ▁ " ) ; System . out . println ( " sorted ▁ lies ▁ between ▁ the ▁ indexes ▁ % d ▁ and ▁ " + s + " " ) ; } System . out . println ( ) ; }
static int circle ( int x1 , int y1 , int x2 , int y2 , int r1 , int r2 ) { int distSq = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ; double radSumSq = ( r1 + r2 ) * ( r1 + r2 ) ; if ( distSq == radSumSq ) return 1 ; else if ( distSq > radSumSq ) return - 1 ; else return 0 ; }
static void countDistinct ( int arr [ ] , int k , int n ) { int dist_count = 0 ; HashMap < Integer , Integer > myMap = new HashMap < > ( ) ; for ( int i = 0 ; i < k ; i ++ ) { if ( myMap . containsKey ( arr [ i ] ) ) dist_count ++ ; myMap . put ( arr [ i ] , myMap . get ( arr [ i ] ) + 1 ) ; } System . out . println ( dist_count ) ; for ( int i = k ; i < n ; i ++ ) { if ( myMap . containsKey ( arr [ i - k ] ) ) dist_count -- ; mp . put ( arr [ i - k ] , myMap . get ( arr [ i - k ] ) - 1 ) ; if ( myMap . containsKey ( arr [ i ] ) ) myMap . put ( arr [ i ] , myMap . get ( arr [ i ] ) + 1 ) ; System . out . println ( dist_count ) ; } }
static double findArea ( int a ) { double area = ( sqrt ( 5 * ( 5 + 2 * ( sqrt ( 5 ) ) ) * a * a ) / 4 ) ; return area ; }
static int countRotationsDivBy8 ( int n [ ] ) { int l = n . length ; int count = 0 ; if ( l == 1 ) { int oneDigit = n [ 0 ] ; if ( oneDigit % 8 == 0 ) return 1 ; return 0 ; } if ( l == 2 ) { int first = n [ 0 ] * 10 + int ( n [ 1 ] ) ; int second = n [ 1 ] * 10 + int ( n [ 0 ] ) ; if ( first % 8 == 0 ) count ++ ; if ( second % 8 == 0 ) count ++ ; if ( second % 8 == 0 ) count ++ ; } int threeDigit = 0 ; for ( int i = 0 ; i < ( l - 2 ) ; i ++ ) { threeDigit = ( int ) n [ i ] * 100 + int ( n [ i + 1 ] ) * 10 + int ( n [ i + 2 ] ) ) ; if ( threeDigit % 8 == 0 ) count ++ ; } threeDigit = ( int ) n [ l - 1 ] * 100 + int ( n [ 0 ] ) * 10 + int ( n [ 1 ] ) ; if ( threeDigit % 8 == 0 ) count ++ ; return count ; }
static int lcs ( int dp [ ] [ ] , int n , int arr2 [ ] , int m , int k ) { if ( k < 0 ) return - ( 10 ** 7 ) ; if ( n < 0 || m < 0 ) return 0 ; int ans = dp [ n ] [ m ] [ k ] ; if ( ans != - 1 ) return ans ; ans = Math . max ( lcs ( dp , arr1 , n - 1 , arr2 , m , k ) , lcs ( dp , arr1 , n , arr2 , m - 1 , k ) ) ; if ( arr1 [ n - 1 ] == arr2 [ m - 1 ] ) ans = 1 + lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k ) ; ans = Math . max ( ans , lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k - 1 ) ) ; return ans ; }
static int editDistDP ( String str1 [ ] , String str2 [ ] , int m , int n ) { int [ ] [ ] dp = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 ) dp [ i ] [ j ] = j ; else if ( j == 0 ) dp [ i ] [ j ] = i ; else if ( str1 [ i - 1 ] == str2 [ j - 1 ] ) dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ; else { dp [ i ] [ j ] = 1 + Math . min ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ j - 1 ] ) ; } } } return dp [ m ] [ n ] ; }
static int countOps ( int A [ ] [ ] , int B [ ] [ ] , int m , int n ) { int i , j ; for ( i = 0 ; i < n ; i ++ ) for ( j = 0 ; j < m ; j ++ ) A [ i ] [ j ] -= B [ i ] [ j ] ; for ( i = 1 ; i < n ; i ++ ) { for ( j = 1 ; j < n ; j ++ ) { if ( A [ i ] [ j ] - A [ i ] [ 0 ] - A [ 0 ] [ j ] + A [ 0 ] [ 0 ] != 0 ) return - 1 ; } } int result = 0 ; for ( i = 0 ; i < n ; i ++ ) result += Math . abs ( A [ i ] [ 0 ] ) ; for ( j = 0 ; j < m ; j ++ ) result += Math . abs ( A [ 0 ] [ j ] - A [ 0 ] [ 0 ] ) ; return result ; }
static void longestAlternating ( int arr [ ] , int n ) { int [ ] count = new int [ n ] ; count [ n - 1 ] = 1 ; int i ; for ( i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] * arr [ i + 1 ] < 0 ) count [ i ] = count [ i + 1 ] + 1 ; else count [ i ] = 1 ; } i = 0 ; while ( i < n ) System . out . print ( count [ i ] + " ▁ " ) ; i ++ ; }
static void printDivisors ( int n ) { List < Integer > list = new ArrayList < Integer > ( ) ; for ( int i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) System . out . print ( i + " ▁ " ) ; else list . add ( n / i ) ; } } for ( int i = list . size ( ) ; i > 0 ; i -- ) System . out . print ( i + " ▁ " ) ; }
static boolean isPower ( int x , int y ) { if ( x == 1 ) return ( y == 1 ) ; int pow = 1 ; while ( pow < y ) pow = pow * x ; return ( pow == y ) ; }
static int maxSum ( int arr [ ] , int N , int k ) { int MS [ ] = new int [ N ] ; MS [ N - 1 ] = arr [ N - 1 ] ; for ( int i = N - 2 ; i >= 0 ; i -- ) { if ( i + k + 1 >= N ) MS [ i ] = Math . max ( arr [ i ] , MS [ i + 1 ] ) ; else MS [ i ] = Math . max ( arr [ i ] + MS [ i + k + 1 ] , MS [ i + 1 ] ) ; } return MS [ 0 ] ; }
static void printGrouped ( String str ) { int n = str . length ( ) ; int [ ] count = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < n ; i ++ ) { count [ str . charAt ( i ) - ' a ' ] ++ ; } for ( int i = 0 ; i < n ; i ++ ) { while ( count [ str . charAt ( i ) - ' a ' ] != 0 ) { System . out . print ( str . charAt ( i ) - ' a ' ) ; count [ str . charAt ( i ) - ' a ' ] -- ; } count [ str . charAt ( i ) - ' a ' ] = 0 ; } }
static int sortedCount ( int mat [ ] [ ] , int r , int c ) { int result = 0 ; for ( int i = 0 ; i < r ; ++ i ) { int j ; for ( j = 0 ; j < c - 1 ; ++ j ) if ( mat [ i ] [ j + 1 ] <= mat [ i ] [ j ] ) break ; if ( j == c - 2 ) result ++ ; } for ( int i = 0 ; i < r ; ++ i ) { j = 0 ; for ( int j = 0 ; j < c - 1 ; ++ j ) if ( mat [ i ] [ j - 1 ] <= mat [ i ] [ j ] ) break ; if ( c > 1 && j == 1 ) result ++ ; } return result ; }
static int countSub ( char ss [ ] ) { int [ ] last = new int [ MAX_CHAR + 1 ] ; int n = ss . length ; int dp [ ] = new int [ n + 1 ] ; dp [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { dp [ i ] = 2 * dp [ i - 1 ] ; if ( last [ ( int ) ss [ i - 1 ] ] != - 1 ) dp [ i ] = dp [ i ] - dp [ last [ ( int ) ss [ i - 1 ] ] ; last [ ( int ) ss [ i - 1 ] ] = i - 1 ; } return dp [ n ] ; }
static void findLIS ( int A [ ] , int n ) { int LIS_size = 1 , LIS_index = 0 ; HashMap < Integer , Integer > hash = new HashMap < Integer , Integer > ( ) ; hash . put ( A [ 0 ] , 1 ) ; for ( int i = 1 ; i < n ; i ++ ) { if ( ! hash . containsKey ( A [ i ] - 1 ) ) { hash . put ( A [ i ] - 1 , hash . get ( A [ i ] - 1 ) + 1 ) ; } else { LIS_size = hash . get ( A [ i ] ) ; LIS_index = A [ i ] ; } } System . out . println ( " LIS _ size ▁ = " + LIS_size + " ▁ " ) ; start = LIS_index - LIS_size + 1 ; while ( start <= LIS_index ) System . out . print ( start + " ▁ " ) ; start ++ ; }
static void printMaxOfMin ( int arr [ ] , int n ) { for ( int k = 1 ; k <= n ; k ++ ) { int maxOfMin = Integer . MIN_VALUE ; for ( int i = 0 ; i <= n - k ; i ++ ) { int min = arr [ i ] ; for ( int j = 0 ; j <= k ; j ++ ) { if ( arr [ i + j ] < min ) min = arr [ i + j ] ; } if ( min > maxOfMin ) maxOfMin = min ; } System . out . print ( maxOfMin + " ▁ " ) ; }
static int maximumZeros ( int arr [ ] [ ] , int n , int k ) { int subset [ ] [ ] = new int [ k + 1 ] [ MAX5 + 5 ] ; subset [ 0 ] [ 0 ] = 0 ; for ( int p = 0 ; p <= n ; p ++ ) { int pw2 , pw5 = 0 ; while ( ! p % 2 ) pw2 ++ ; p /= 2 ; while ( ! p % 5 ) pw5 ++ ; p /= 5 ; } for ( int i = k - 1 ; i >= 0 ; i -- ) { for ( int j = 0 ; j <= MAX5 ; j ++ ) { if ( subset [ i ] [ j ] != - 1 ) { subset [ i + 1 ] [ j + pw5 ] = ( Math . max ( subset [ i + 1 ] [ j + pw5 ] , ( subset [ i ] [ j ] + pw2 ) ) ; } } } int ans = 0 ; for ( int i = 0 ; i <= MAX5 ; i ++ ) ans = Math . max ( ans , Math . min ( i , subset [ k ] [ i ] ) ) ; return ans ; }
static int largestSubset ( int a [ ] , int n ) { Arrays . sort ( a ) ; int dp [ ] = new int [ n ] ; dp [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { int mxm = 0 ; for ( int j = i + 1 ; j < n ; j ++ ) if ( a [ j ] % a [ i ] == 0 ) mxm = Math . max ( mxm , dp [ j ] ) ; } dp [ i ] = 1 + mxm ; return Math . max ( dp , 1 + mxm ) ; }
static String encodedChar ( String str , int k ) { String expand = " " ; int freq = 0 ; int i = 0 ; while ( i < str . length ( ) ) { String temp = " " ; freq = 0 ; while ( i < str . length ( ) && ( str . charAt ( i ) >= ' a ' && str . charAt ( i ) <= ' z ' ) ) { temp += str . charAt ( i ) ; i ++ ; } while ( i < str . length ( ) && ( str . charAt ( i ) >= '1' && str . charAt ( i ) <= '9' ) ) { freq = freq * 10 + ( str . charAt ( i ) - '0' ) ; i ++ ; } for ( int j = 1 ; j <= freq ; j ++ ) expand += temp ; if ( freq == 0 ) expand += temp ; } return expand [ k - 1 ] ; }
static int countNum ( int arr [ ] , int n ) { Map < Integer , Integer > s = new HashMap < Integer , Integer > ( ) ; int count = 0 , maxm = - 10 ** 9 , 10 ** 9 ; for ( int i = 0 ; i < n ; i ++ ) { s . put ( arr [ i ] , 1 ) ; if ( arr [ i ] < minm ) minm = arr [ i ] ; if ( arr [ i ] > maxm ) maxm = arr [ i ] ; } for ( int i = minm ; i <= maxm ; i ++ ) { if ( ! s . containsKey ( i ) ) count ++ ; } } return count ; }
static int countPairs ( int arr [ ] , int n ) { Map < Integer , Integer > myMap = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( myMap . containsKey ( arr [ i ] ) ) myMap . put ( arr [ i ] , myMap . get ( arr [ i ] ) + 1 ) ; else myMap . put ( arr [ i ] , 1 ) ; } int ans = 0 ; for ( int it = 0 ; it < n ; it ++ ) ans += ( count * ( count - 1 ) ) / 2 ; return ans ; }
static int maxDiff ( int arr [ ] , int n ) { int result = 0 ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( Math . abs ( arr [ i ] ) != Math . abs ( arr [ i + 1 ] ) ) result += Math . abs ( arr [ i ] ) ; else pass ; if ( arr [ n - 2 ] != arr [ n - 1 ] ) result += Math . abs ( arr [ n - 1 ] ) ; return result ; }
static int middleOfThree ( int a , int b , int c ) { if ( ( a < b && b < c ) || ( c < b && b < a ) ) return b ; if ( ( b < a && a < c ) || ( c < a && a < b ) ) return a ; else return c ; }
static int countarray ( int n , int k , int x ) { List < Integer > dp = new ArrayList < > ( ) ; dp . add ( 0 ) ; dp . add ( 1 ) ; for ( int i = 2 ; i < n ; i ++ ) dp . add ( ( k - 2 ) * dp [ i - 1 ] + ( k - 1 ) * dp [ i - 2 ] ) ; return ( ( k - 1 ) * dp [ n - 2 ] if ( x == 1 else dp [ n - 1 ] ) ; }
static long nswp ( int n ) { if ( n == 0 || n == 1 ) return 1 ; return 2 * nswp ( n - 1 ) + nswp ( n - 2 ) ; }
static int fib ( int n , int lookup [ ] ) { if ( n == 0 || n == 1 ) lookup [ n ] = n ; if ( lookup [ n ] == null ) lookup [ n ] = fib ( n - 1 , lookup ) + fib ( n - 2 , lookup ) ; return lookup [ n ] ; }
static int countNums ( int n , int x , int y ) { boolean [ ] arr = new boolean [ n + 2 ] ; if ( x <= n ) arr [ x ] = true ; if ( y <= n ) arr [ y ] = true ; int result = 0 ; for ( int i = min ( x , y ) ; i <= n ; i ++ ) { if ( arr [ i ] ) { if ( i + x <= n ) arr [ i + x ] = true ; if ( i + y <= n ) arr [ i + y ] = true ; result ++ ; } } return result ; }
static int countPS ( String str ) { int N = str . length ( ) ; int [ ] [ ] cps = new int [ N ] [ N + 2 ] ; for ( int i = 0 ; i < N ; i ++ ) cps [ i ] [ i ] = 1 ; for ( int L = 2 ; L <= N ; L ++ ) { for ( int i = 0 ; i < N ; i ++ ) { int k ; for ( k = L + i - 1 ; k < N ; k ++ ) { if ( str . charAt ( i ) == str . charAt ( k ) ) cps [ i ] [ k ] = ( cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] + 1 ) ; else cps [ i ] [ k ] = ( cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] - cps [ i + 1 ] [ k - 1 ] ) ; } } } return cps [ 0 ] [ N - 1 ] ; }
static String decimalToBinary ( int num , int k_prec ) { String binary = " " ; int Integral = num ; int fractional = num - Integral ; while ( Integral > 0 ) { int rem = Integral % 2 ; binary += String . valueOf ( rem ) ; Integral /= 2 ; } binary += ' . ' ; while ( k_prec > 0 ) { fractional *= 2 ; int fract_bit = int . valueOf ( fractional ) ; if ( fract_bit == 1 ) fractional -= fract_bit ; else binary += '0' ; } k_prec -- ; } return binary ; }
static void countParenth ( char symb [ ] [ ] , char oper [ ] , int n ) { int F [ ] [ ] = new int [ n + 1 ] [ n + 1 ] ; int T [ ] [ ] = new int [ n + 1 ] [ n + 1 ] ; int gap , i , j , k , l , a , b , c , d , e ; for ( i = 0 ; i < n ; i ++ ) { if ( symb [ i ] == ' F ' ) F [ i ] [ i ] = 1 ; else { F [ i ] [ i ] = 0 ; } if ( symb [ i ] == ' T ' ) T [ i ] [ i ] = 1 ; else { T [ i ] [ i ] = 0 ; } } for ( gap = 1 ; gap < n ; ++ gap ) { i = 0 ; for ( j = 0 ; j < gap ; ++ j ) { T [ i ] [ j ] = F [ i ] [ j ] = 0 ; for ( g = 0 ; g < gap ; ++ g ) { k = i + g ; tik = T [ i ] [ k ] + F [ i ] [ k ] ; tkj = T [ k + 1 ] [ j ] + F [ k + 1 ] [ j ] ; if ( oper [ k ] == ' & ' ) { T [ i ] [ j ] += T [ i ] [ k ] * T [ k + 1 ] [ j ] ; F [ i ] [ j ] += ( tik * tkj - F [ i ] [ k ] * F [ k + 1 ] [ j ] ) ; T [ i ] [ j ] += ( tik * tkj - F [ i ] [ k ] * F [ k + 1 ] [ j ] ) ; } if ( oper [ k ] == ' ^ ' ) { T [ i ] [ j ] += ( F [ i ] [ k ] * T [ k + 1 ] [ j ] + T [ i ] [ k ] * F [ k + 1 ] [ j ] ) ; } if ( oper [ k ] == ' ^ ' ) { T [ i ] [ j ] += ( F [ i ] [ k ] * T [ k + 1 ] [ j ] ) ; } } } } return ; }
static int countSetBits ( int n ) { if ( n == 0 ) return 0 ; else return ( n & 1 ) + countSetBits ( n >> 1 ) ; }
static int longestCommonSum ( int n ) { int maxLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int sum1 = 0 , sum2 = 0 ; for ( int j = 0 ; j < n ; j ++ ) { sum1 += arr1 [ j ] ; sum2 += arr2 [ j ] ; if ( sum1 == sum2 ) { len = j - i + 1 ; if ( len > maxLen ) maxLen = len ; } } } return maxLen ; }
static int maxTripletSum ( int arr [ ] , int n ) { int sm = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) { if ( sm < ( arr [ i ] + arr [ j ] + arr [ k ] ) ) sm = arr [ i ] + arr [ j ] + arr [ k ] ; } } } return sm ; }
static int evaluateBoolExpr ( String s ) { int n = s . length ( ) ; for ( int i = 0 ; i < n - 2 ; i += 2 ) { if ( s . charAt ( i + 1 ) == ' A ' ) { if ( s . charAt ( i + 2 ) == "0" || s . charAt ( i ) == "0" ) s . set ( i + 2 , "0" ) ; else s . set ( i + 2 , "1" ) ; } else { s . set ( i + 2 , "0" ) ; } } return ( s . charAt ( n - 1 ) - '0' ) ; }
static int findNth ( int n ) { int nthElement = 19 + ( n - 1 ) * 9 ; int outliersCount = ( int ) Math . log10 ( nthElement ) ; nthElement += 9 * outliersCount ; return nthElement ; }
static int numofAP ( int a [ ] , int n ) { int minarr = + 2147483647 ; int maxarr = - 2147483648 ; for ( int i = 0 ; i < n ; i ++ ) { minarr = Math . min ( minarr , a [ i ] ) ; maxarr = Math . max ( maxarr , a [ i ] ) ; } int dp [ ] = new int [ n + 1 ] ; int ans = n + 1 ; for ( int d = ( minarr - maxarr ) ; d <= ( maxarr - minarr ) ; d ++ ) { sum [ i ] = 1 ; if ( a [ i ] - d >= 1 && a [ i ] - d <= 1000000 ) dp [ i ] += sum [ a [ i ] - d ] ; ans += dp [ i ] - 1 ; sum [ a [ i ] ] += dp [ i ] ; } return ans ; }
static int countSol ( int coeff [ ] , int start , int end , int rhs ) { if ( rhs == 0 ) return 1 ; int result = 0 ; for ( int i = start ; i <= end ; i ++ ) if ( coeff [ i ] <= rhs ) result += countSol ( coeff , i , end , rhs - coeff [ i ] ) ; return result ; }
static int minSwaps ( int arr [ ] [ ] ) { int n = arr . length ; Arrays . sort ( arr ) ; int [ ] arrpos = new int [ n ] ; boolean vis [ ] = new boolean [ n ] ; Arrays . sort ( arr ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( vis [ i ] || arrpos [ i ] [ 0 ] == i ) continue ; int cycle_size = 0 ; for ( int j = i ; j < arrpos [ j ] [ 0 ] ; cycle_size ++ ; if ( cycle_size > 0 ) ans += ( cycle_size - 1 ) ; } return ans ; }
static void spiralFill ( int m , int n , int a [ ] [ ] ) { int val = 1 ; int k = 0 , l = 0 ; while ( k < m && l < n ) { for ( int i = l ; i < n ; i ++ ) a [ k ] [ i ] = val ; val ++ ; k ++ ; for ( int i = k ; i < m ; i ++ ) a [ i ] [ n - 1 ] = val ; val ++ ; } n -- ; if ( k < m ) { for ( int i = n - 1 ; i >= l ; i -- ) { a [ m - 1 ] [ i ] = val ; val ++ ; } m -- ; } if ( l < n ) { for ( int i = m - 1 ; i >= k ; i -- ) { a [ i ] [ l ] = val ; val ++ ; } l ++ ; } } }
static void printClosest ( int arr1 [ ] , int arr2 [ ] , int m , int n , int x ) { int diff = Integer . MAX_VALUE ; int l = 0 , r = n - 1 ; while ( l < m && r >= 0 ) { int res_l = l ; int res_r = r ; diff = Math . abs ( arr1 [ l ] + arr2 [ r ] - x ) ; if ( Math . abs ( arr1 [ l ] + arr2 [ r ] - x ) < diff ) res_l = l ; res_r = r ; diff = Math . abs ( arr1 [ l ] + arr2 [ r ] - x ) ; if ( arr1 [ l ] + arr2 [ r ] > x ) r = r - 1 ; else l = l + 1 ; } } System . out . println ( " The ▁ closest ▁ pair ▁ is ▁ [ ▁ " + arr1 [ res_l ] + " , ▁ " + arr2 [ res_r ] + " ] " ) ; }
static int minimumBox ( int arr [ ] , int n ) { Deque < Integer > q = new LinkedList < Integer > ( ) ; Arrays . sort ( arr ) ; q . add ( arr [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { int now = q . peek ( ) ; if ( arr [ i ] >= 2 * now ) q . pop ( ) ; q . add ( arr [ i ] ) ; } return q . size ( ) ; }
static int findInteger ( int [ ] arr , int n ) { HashMap < Integer , Integer > hash = new HashMap < Integer , Integer > ( ) ; int maximum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i < 0 ) { if ( hash . containsKey ( abs ( i ) ) ) hash . put ( abs ( i ) , - 1 ) ; else hash . put ( abs ( i ) , 1 ) ; } else { hash . put ( i , hash . get ( i ) + 1 ) ; } } for ( int i = 0 ; i < arr . length ; i ++ ) if ( i in hash . keys ( ) && hash . get ( i ) > 0 ) return i ; return - 1 ; }
static void convertOpposite ( String str ) { int ln = str . length ( ) ; for ( int i = 0 ; i < ln ; i ++ ) { if ( str . charAt ( i ) >= ' a ' && str . charAt ( i ) <= ' z ' ) str . charAt ( i ) = ( char ) ( str . charAt ( i ) - 32 ) ; else if ( str . charAt ( i ) >= ' A ' && str . charAt ( i ) <= ' Z ' ) str . charAt ( i ) = ( char ) ( str . charAt ( i ) + 32 ) ; } }
static int decimalToBinary ( int N ) { int B_Number = 0 ; int cnt = 0 ; while ( N != 0 ) { int rem = N % 2 ; int c = pow ( 10 , cnt ) ; B_Number += rem * c ; N /= 2 ; cnt ++ ; } return B_Number ; }
static int findRepeating ( int arr [ ] , int n ) { HashMap < Integer , Integer > hM = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( hM . get ( arr [ i ] ) != null ) return arr [ i ] ; hM . put ( arr [ i ] , i ) ; } return - 1 ; }
static void transpose ( int A [ ] [ ] ) { int i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = i + 1 ; j < N ; j ++ ) A [ i ] [ j ] = A [ j ] [ i ] ; }
static void findConsecutive ( int N ) { int start = 1 , end = ( N + 1 ) / 2 ; while ( start < end ) { int sum = 0 ; for ( int i = start ; i <= end ; i ++ ) { sum = sum + i ; if ( sum == N ) { for ( int j = start ; j <= i ; j ++ ) System . out . print ( j + " ▁ " ) ; } System . out . println ( ) ; } } sum = 0 ; start ++ ; }
static void printSubsequences ( String str ) { int n = str . length ( ) ; int opsize = ( int ) Math . pow ( 2 , n - 1 ) ; for ( int counter = 0 ; counter < opsize ; counter ++ ) { for ( int j = 0 ; j < n ; j ++ ) { System . out . print ( str . charAt ( j ) ) ; if ( counter & ( 1 << j ) ) System . out . print ( " ▁ " ) ; } System . out . println ( ) ; } }
static double maxArea ( int a , int b , int c , int d ) { int semiperimeter = ( a + b + c + d ) / 2 ; return Math . sqrt ( ( semiperimeter - a ) * ( semiperimeter - b ) * ( semiperimeter - c ) * ( semiperimeter - d ) ) ; }
static int Right_most_setbit ( int num ) { int pos = 1 ; for ( int i = 0 ; i < INT_SIZE ; i ++ ) { if ( num & ( 1 << i ) ) pos ++ ; else break ; } return pos ; }
static void printRoman ( int number ) { int [ ] num = new int [ ] { 1 , 4 , 5 , 9 , 10 , 40 , 50 , 90 , 100 , 400 , 500 , 900 , 1000 } ; String [ ] sym = new String [ ] { " I " , " IV " , " X " , " XL " , " L " , " XC " , " C " , " CD " , " M" } ; for ( int i = 12 ; number > 0 ; i -- ) { int div = number / num [ i ] ; number %= num [ i ] ; while ( div ) System . out . print ( sym [ i ] ) ; div -- ; } i -- ; }
static boolean isSubsetSum ( int [ ] set , int n , int sum ) { if ( sum == 0 ) return true ; if ( n == 0 && sum != 0 ) return false ; if ( set [ n - 1 ] > sum ) return isSubsetSum ( set , n - 1 , sum ) ; return isSubsetSum ( set , n - 1 , sum ) || isSubsetSum ( set , n - 1 , sum - set [ n - 1 ] ) ; }
static long countDigits ( int a , int b ) { if ( a == 0 || b == 0 ) return 1 ; return Math . floor ( Math . log10 ( Math . abs ( a ) ) + Math . log10 ( Math . abs ( b ) ) ) + 1 ; }
static int CountWays ( int n ) { int table [ ] = new int [ n + 1 ] ; table [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = i ; j <= n ; j ++ ) table [ j ] += table [ j - i ] ; } return table [ n ] ; }
public static void twoWaySort ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] & 1 ) arr [ i ] *= - 1 ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] & 1 ) arr [ i ] *= - 1 ; }
static int PowerOFPINnfactorial ( int n , int p ) { int ans = 0 ; int temp = p ; while ( temp <= n ) ans += n / temp ; return ans ; }
static int findMaxValue ( int mat [ ] [ ] ) { int maxValue = 0 ; for ( int a = 0 ; a <= N - 2 ; a ++ ) { for ( int b = 0 ; b <= N - 1 ; b ++ ) { for ( int d = a + 1 ; d < N ; d ++ ) { for ( int e = b + 1 ; e <= N ; e ++ ) { if ( maxValue < Math . abs ( mat [ d ] [ e ] - mat [ a ] [ b ] ) ) maxValue = Math . abs ( mat [ d ] [ e ] - mat [ a ] [ b ] ) ; } } } return maxValue ; }
static Boolean findTriplet ( int a1 [ ] , int a2 [ ] , int a3 [ ] , int n1 , int n2 , int n3 , int sum ) { HashSet < Integer > s = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n1 ; i ++ ) { s . add ( a1 [ i ] ) ; } for ( int i = 0 ; i < n2 ; i ++ ) { for ( int j = 0 ; j < n3 ; j ++ ) { if ( sum - a2 [ i ] - a3 [ j ] in s ) return true ; } } return false ; }
public static int getOddOccurrence ( int arr [ ] ) { int arr_size = arr . length ; for ( int i = 0 ; i < arr_size ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < arr_size ; j ++ ) if ( arr [ i ] == arr [ j ] ) count ++ ; if ( count % 2 != 0 ) return arr [ i ] ; } return - 1 ; }
static void factorize ( int n ) { int count = 0 ; while ( ( n % 2 > 0 ) == false ) n >>= 1 ; count ++ ; if ( count > 0 ) System . out . print ( 2 , count ) ; for ( int i = 3 ; i <= Math . sqrt ( n ) ; i ++ ) { count = 0 ; while ( n % i == 0 ) count ++ ; n = n / i ; if ( count > 0 ) System . out . print ( i , count ) ; } if ( n > 2 ) System . out . print ( n , 1 ) ; } }
static int findSmallestDifference ( int A [ ] , int B [ ] , int m , int n ) { int a = 0 , b = 0 , result = Integer . MAX_VALUE ; Arrays . sort ( A ) ; Arrays . sort ( B ) ; while ( a < m && b < n ) { if ( Math . abs ( A [ a ] - B [ b ] ) < result ) result = Math . abs ( A [ a ] - B [ b ] ) ; if ( A [ a ] < B [ b ] ) a ++ ; else b ++ ; } return result ; }
static boolean check ( String s ) { if ( s . length ( ) >= 10 ) return true ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) { for ( int j = i + 1 ; j < s . length ( ) ; j ++ ) { for ( int k = j + 1 ; k < s . length ( ) ; k ++ ) { String s1 = s . substring ( 0 , i ) ; String s2 = s . substring ( i , j - i ) ; String s3 = s . substring ( j , k - j ) ; String s4 = s . substring ( k , s . length ( ) - k ) ; if ( s1 != s2 && s1 != s3 && s1 != s4 && s2 != s3 && s2 != s4 && s3 != s4 ) return true ; } } } return false ; }
static boolean isPath ( int arr [ ] [ ] ) { arr [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i < row ; i ++ ) { if ( arr [ i ] [ 0 ] != - 1 ) arr [ i ] [ 0 ] = arr [ i - 1 ] [ 0 ] ; for ( int j = 1 ; j < col ; j ++ ) { if ( arr [ 0 ] [ j ] != - 1 ) arr [ 0 ] [ j ] = arr [ 0 ] [ j - 1 ] ; } } for ( int i = 1 ; i < row ; i ++ ) { for ( int j = 1 ; j < col ; j ++ ) { if ( arr [ i ] [ j ] != - 1 ) arr [ i ] [ j ] = Math . max ( arr [ i ] [ j - 1 ] , arr [ i - 1 ] [ j ] ) ; } } } return ( arr [ row - 1 ] [ col - 1 ] == 1 ) ; }
static int bitonicGenerator ( int arr [ ] , int n ) { int i = 1 , j = n - 1 ; if ( j % 2 != 0 ) j = j - 1 ; while ( i < j ) { arr [ j ] = arr [ i ] ; arr [ i ] = arr [ j ] ; j = j - 2 ; } int arr_f [ ] = new int [ n + 1 ] ; int arr_s [ ] = new int [ n + 1 ] ; Arrays . sort ( arr_f , Collections . reverseOrder ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) { arr_s . add ( arr [ i ] ) ; i ++ ; } arr_f . sort ( ) ; arr_s . sort ( reverse = true ) ; for ( int i = arr_s [ 0 ] ; i < n ; i ++ ) { arr_f . add ( arr [ i ] ) ; i ++ ; } return arr_f ; }
static int solve ( int dp [ ] [ ] , int a [ ] , int low , int high , int turn ) { if ( low == high ) return a [ low ] * turn ; if ( dp [ low ] [ high ] != 0 ) return dp [ low ] [ high ] ; dp [ low ] [ high ] = Math . max ( a [ low ] * turn + solve ( dp , a , low + 1 , high , turn + 1 ) , a [ high ] * turn + solve ( dp , a , low , high - 1 , turn + 1 ) ) ; return dp [ low ] [ high ] ; }
static void direction ( int R , int C ) { if ( R != C && R % 2 == 0 && C % 2 != 0 && R < C ) System . out . println ( " Left " ) ; if ( R != C && R % 2 == 0 && C % 2 != 0 && R > C ) System . out . println ( " Up " ) ; if ( R == C && R % 2 == 0 && C % 2 != 0 && R < C ) System . out . println ( " Right " ) ; if ( R != C && R % 2 != 0 && C % 2 != 0 && R < C ) System . out . println ( " Left " ) ; if ( R != C && R % 2 != 0 && C % 2 != 0 && R < C ) System . out . println ( " Down " ) ; if ( R != C && R % 2 == 0 && C % 2 != 0 && R < C ) System . out . println ( " Left " ) ; if ( R != C && R % 2 != 0 && C % 2 != 0 && R > C ) System . out . println ( " Down " ) ; if ( R != C && R % 2 != 0 && C % 2 != 0 && R < C ) System . out . println ( " Left " ) ; if ( R != C && R % 2 != 0 && C % 2 != 0 && R < C ) System . out . println ( " Right " ) ; return ; }
static void splitString ( String str ) { String alpha = " " , num = " " , special = " " ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) == ' ' ) num = num + str . charAt ( i ) ; else if ( str . charAt ( i ) >= ' A ' && str . charAt ( i ) <= ' Z ' ) || ( str . charAt ( i ) >= ' a ' && str . charAt ( i ) <= ' z ' ) ) alpha += str . charAt ( i ) ; else special += str . charAt ( i ) ; } System . out . println ( alpha + num + special ) ; }
static void binaryMedian ( int m [ ] [ ] , int r , int d ) { int mi = m [ 0 ] [ 0 ] ; int mx = 0 ; for ( int i = 0 ; i < r ; i ++ ) { if ( m [ i ] [ 0 ] < mi ) mi = m [ i ] [ 0 ] ; if ( m [ i ] [ d - 1 ] > mx ) mx = m [ i ] [ d - 1 ] ; } int desired = ( r * d + 1 ) / 2 ; while ( mi < mx ) { int mid = mi + ( mx - mi ) / 2 ; int place [ ] = new int [ r ] [ 0 ] ; for ( int i = 0 ; i < r ; i ++ ) { int j = upper_bound ( m [ i ] , mid ) ; place [ 0 ] = place [ 0 ] + j ; if ( place [ 0 ] < desired ) mi = mid + 1 ; else mx = mid ; } } System . out . println ( " Median ▁ is ▁ " + mi ) ; return ; }
static void printDuplicates ( int [ ] arr ) { int dict [ ] = new int [ arr . length ] ; for ( int ele : arr ) { if ( dict . containsKey ( ele ) ) { dict [ ele ] ++ ; } else { dict [ ele ] = 1 ; } } for ( int item : dict ) { if ( dict . containsKey ( item ) ) System . out . print ( item + " ▁ " ) ; } System . out . println ( ) ; }
static void fib ( int n ) { int a = 0 , b = 1 ; if ( n >= 0 ) System . out . print ( a + " ▁ " ) ; if ( n >= 1 ) System . out . print ( b + " ▁ " ) ; for ( int i = 2 ; i <= n ; i ++ ) { int c = a + b ; System . out . print ( c + " ▁ " ) ; a = b ; b = c ; } }
static int swapNibbles ( int x ) { return ( ( x & 0x0F ) << 4 | ( x & 0xF0 ) >> 4 ) ; }
static int countPS ( int i , int j ) { if ( i >= n || j < 0 ) return 0 ; if ( dp [ i ] [ j ] != - 1 ) return dp [ i ] [ j ] ; if ( Math . abs ( i - j ) == 1 ) { if ( str [ i ] == str [ j ] ) dp [ i ] [ j ] = 3 ; else dp [ i ] [ j ] = 2 ; return dp [ i ] [ j ] ; } if ( i == j ) { dp [ 1 ] [ j ] = 1 ; return dp [ 1 ] [ j ] ; } else if ( str [ i ] == str [ j ] ) { dp [ i ] [ j ] = countPS ( i + 1 , j ) + countPS ( i , j - 1 ) + 1 ; return dp [ i ] [ j ] ; } else { dp [ i ] [ j ] = countPS ( i + 1 , j ) + countPS ( i , j - 1 ) - countPS ( i + 1 , j - 1 ) ; return dp [ i ] [ j ] ; } }
static int divisorSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += ( n / i ) * i ; return sum ; }
static int addOne ( int x ) { int m = 1 ; while ( ( x & m ) == 0 ) x = x ^ m ; m <<= 1 ; x = x ^ m ; return x ; }
static boolean check ( String str ) { int n = str . length ( ) ; int digitSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) digitSum = digitSum + ( int ) str . charAt ( i ) ; return ( digitSum % 9 == 0 ) ; }
static int findMaxGCD ( int arr [ ] , int n ) { int high = 0 ; for ( int i = 0 ; i < n ; ++ i ) { high = Math . max ( high , arr [ i ] ) ; i ++ ; } int [ ] divisors = new int [ high + 1 ] ; for ( int i = 0 ; i < n ; ++ i ) { for ( int j = 1 ; j <= Math . sqrt ( arr [ i ] ) ; ++ j ) { if ( arr [ i ] % j == 0 ) divisors [ j ] = divisors [ j ] + 1 ; if ( j != arr [ i ] / j ) divisors [ arr [ i ] / j ] = divisors [ arr [ i ] / j ] ; } } int i = high ; while ( i >= 1 ) if ( divisors [ i ] > 1 ) return i ; i = i - 1 ; return 1 ; }
static int minRemove ( int arr [ ] , int n ) { int LIS [ ] = new int [ n ] ; int len = 0 ; for ( int i = 0 ; i < n ; i ++ ) LIS [ i ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ i ] > arr [ j ] && ( i - j ) <= ( arr [ i ] - arr [ j ] ) ) LIS [ i ] = Math . max ( LIS [ i ] , LIS [ j ] + 1 ) ; } } len = Math . max ( len , LIS [ i ] ) ; return ( n - len ) ; }
static void computeLPSArray ( char pat [ ] , int M , int lps [ ] ) { int len = 0 ; lps [ 0 ] = 0 ; int i = 1 ; while ( i < M ) { if ( pat [ i ] == pat [ len ] ) len ++ ; lps [ i ] = len ; else { if ( pat [ i ] == pat [ len ] ) { len ++ ; lps [ i ] = len ; i ++ ; } else { if ( len != 0 ) len = lps [ len - 1 ] ; else lps [ i ] = 0 ; } } }
static int numofsubset ( int arr [ ] , int n ) { int [ ] x = Arrays . stream ( arr ) ; int count = 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] + 1 != arr [ i + 1 ] ) count ++ ; return count ; }
public static void stoogesort ( int arr [ ] , int l , int h ) { if ( l >= h ) return ; if ( arr [ l ] > arr [ h ] ) { int t = arr [ l ] ; arr [ l ] = arr [ h ] ; arr [ h ] = t ; } if ( h - l + 1 > 2 ) { int t = ( int ) ( ( h - l + 1 ) / 3 ) ; stoogesort ( arr , l , ( h - t ) ) ; stoogesort ( arr , l + t , ( h ) ) ; stoogesort ( arr , l , ( h - t ) ) ; } }
static void solve ( int n , int t , int [ ] p ) { List < Integer > s = new ArrayList < > ( ) ; for ( int i = 0 ; i < t ; i ++ ) { for ( int j = 0 ; j < n - 1 ; j ++ ) { if ( s [ j ] == ' B ' && s [ j + 1 ] == ' G ' ) { int temp = s [ j ] ; s [ j ] = s [ j + 1 ] ; s [ j + 1 ] = temp ; s [ j ] = s [ j + 1 ] ; s [ j + 1 ] = temp ; } } } System . out . println ( " " ) ; }
static int turnOffK ( int n , int k ) { if ( k <= 0 ) return n ; return ( n & ~ ( 1 << ( k - 1 ) ) ) ; }
static void printEqualModNumbers ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int d = arr [ n - 1 ] - arr [ 0 ] ; int [ ] v = new int [ n ] ; for ( int i = 1 ; i * i <= d ; i ++ ) { if ( d % i == 0 ) v . add ( i ) ; if ( i != d / i ) v . add ( d / i ) ; } for ( int i = 0 ; i < n ; i ++ ) { int temp = arr [ 0 ] % v [ i ] ; int j ; for ( j = 1 ; j < n ; j ++ ) if ( arr [ j ] % v [ i ] != temp ) break ; if ( j == n ) System . out . print ( v [ i ] + " ▁ " ) ; } }
static int findMaximum ( int [ ] arr , int low , int high ) { if ( low == high ) { return arr [ low ] ; } if ( high == low + 1 && arr [ low ] >= arr [ high ] ) return arr [ low ] ; if ( high == low + 1 && arr [ low ] < arr [ high ] ) return arr [ high ] ; int mid = ( low + high ) / 2 ; if ( arr [ mid ] > arr [ mid + 1 ] && arr [ mid ] > arr [ mid - 1 ] ) return arr [ mid ] ; if ( arr [ mid ] > arr [ mid + 1 ] && arr [ mid ] < arr [ mid - 1 ] ) return findMaximum ( arr , low , mid - 1 ) ; else return findMaximum ( arr , mid + 1 , high ) ; }
static int stringReduction ( String str ) { int n = str . length ( ) ; int [ ] count = new int [ 3 ] ; for ( int i = 0 ; i < n ; i ++ ) { count [ str . charAt ( i ) - ' a ' ] ++ ; } if ( count [ 0 ] == n || count [ 1 ] == n || count [ 2 ] == n ) return n ; if ( count [ 0 ] % 2 == ( count [ 1 ] % 2 ) && ( count [ 1 ] % 2 ) == ( count [ 2 ] % 2 ) ) return 2 ; return 1 ; }
static int KnapSack ( int val [ ] , int wt [ ] , int n , int W ) { int [ ] dp = new int [ W + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = W ; j >= wt [ i ] ; j -- ) dp [ j ] = Math . max ( dp [ j ] , val [ i ] + dp [ j - wt [ i ] ] ) ; } return dp [ W ] ; }
static int findSum ( int n ) { int multiTerms = n * ( n + 1 ) / 2 ; int sm = multiTerms ; for ( int i = 2 ; i <= n ; i ++ ) { multiTerms = multiTerms - ( i - 1 ) ; sm = sm + multiTerms * i ; } return sm ; }
static void recursiveReverse ( String str ) { Stack < Character > stack = new Stack < Character > ( ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) stack . push ( str . charAt ( i ) ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) str . charAt ( i ) = stack . peek ( ) ; }
static int subArraySum ( int arr [ ] , int n , int sum ) { for ( int i = 0 ; i < n ; i ++ ) { int curr_sum = arr [ i ] ; int j = i + 1 ; while ( j <= n ) { if ( curr_sum == sum ) { System . out . println ( " Sum ▁ found ▁ between ▁ " + ( i , j - 1 ) ) ; return 1 ; } if ( curr_sum > sum || j == n ) break ; curr_sum = curr_sum + arr [ j ] ; j ++ ; } } System . out . println ( " No ▁ subarray ▁ found " ) ; return 0 ; }
static int getSingle ( int arr [ ] , int n ) { int result = 0 ; for ( int i = 0 ; i < INT_SIZE ; i ++ ) { int sm = 0 ; int x = ( 1 << i ) ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] & x ) sm ++ ; if ( sm % 3 != 0 ) result |= x ; } } return result ; }
static int getModulo ( int n , int d ) { return ( n & ( d - 1 ) ) ; }
static boolean allCharactersSame ( String s ) { int n = s . length ( ) ; for ( int i = 1 ; i < n ; i ++ ) if ( s . charAt ( i ) != s . charAt ( 0 ) ) return false ; return true ; }
static int maxDecimalValue ( int mat [ ] [ ] , int i , int j , int p ) { if ( i >= N || j >= N ) return 0 ; int result = Math . max ( maxDecimalValue ( mat , i , j + 1 , p + 1 ) , maxDecimalValue ( mat , i + 1 , j , p + 1 ) ) ; if ( mat [ i ] [ j ] == 1 ) return pow ( 2 , p ) + result ; else return result ; }
static int countBT ( int h ) { int MOD = 1000000007 ; int [ ] dp = new int [ h + 1 ] ; dp [ 0 ] = 1 ; dp [ 1 ] = 1 ; for ( int i = 2 ; i <= h ; i ++ ) dp [ i ] = dp [ i - 1 ] * ( ( 2 * dp [ i - 2 ] ) % MOD + dp [ i - 1 ] ) % MOD ; return dp [ h ] ; }
static int getInvCount ( int arr [ ] , int n ) { int inv_count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] > arr [ j ] ) inv_count ++ ; } return inv_count ; }
static void printRect ( int X , int Y , int n ) { int Xmax = Math . max ( X ) ; int Xmin = Math . min ( X ) ; int Ymax = Math . max ( Y ) ; int Ymin = Math . min ( Y ) ; System . out . println ( " { " + Xmin + " , ▁ " + Ymin + " } " ) ; System . out . println ( " { " + Xmin + " , ▁ " + Ymax + " } " ) ; System . out . println ( " { " + Xmin + " , ▁ " + Ymin + " } " ) ; System . out . println ( " { " + Xmax + " , ▁ " + Ymax + " } " ) ; System . out . println ( " { " + Xmax + " , ▁ " + Ymin + " } " ) ; }
public static int dealnnoy ( int n , int m ) { int [ ] [ ] dp = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i < m ; i ++ ) { dp [ i ] [ 0 ] = 1 ; } for ( int i = 1 ; i <= m ; i ++ ) { dp [ 0 ] [ i ] = 1 ; } for ( int i = 1 ; i <= m ; i ++ ) { dp [ i ] [ 0 ] = 1 ; } for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n + 1 ; j ++ ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] + dp [ i ] [ j - 1 ] ; } } return dp [ m ] [ n ] ; }
static int power ( int x , int y , int p ) { int res = 1 ; x = x % p ; while ( y > 0 ) { if ( ( y & 1 ) == 1 ) res = ( res * x ) % p ; y = y >> 1 ; x = ( x * x ) % p ; } return res ; }
static boolean isValidISBN ( String isbn ) { if ( isbn . length ( ) != 10 ) return false ; int _sum = 0 ; for ( int i = 0 ; i < 9 ; i ++ ) { if ( 0 <= isbn . charAt ( i ) <= 9 ) _sum += ( int ) isbn . charAt ( i ) * ( 10 - i ) ; else return false ; } if ( isbn . charAt ( 9 ) != ' X ' && 0 <= isbn . charAt ( 9 ) <= 9 ) return false ; return true ; }
public static void NFG ( int [ ] a , int n ) { if ( n <= 0 ) System . out . println ( " List ▁ empty " ) ; return ; } int stack [ ] = new int [ n ] ; int freq [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { freq [ a [ i ] ] = 0 ; } for ( int i = 0 ; i < n ; i ++ ) { if ( freq [ a [ stack [ top ] ] ] > freq [ a [ i ] ] ) top ++ ; stack [ top ] = i ; else { while ( top > - 1 && freq [ a [ stack [ top ] ] < freq [ a [ i ] ] ) res [ stack [ top ] ] = a [ i ] ; top -- ; stack [ top ] = i ; } } while ( top > - 1 ) res [ stack [ top ] ] = - 1 ; top -- ; } return res ; }
static int swapBits ( int x , int p1 , int p2 , int n ) { int set1 = ( x >> p1 ) & ( ( 1 << n ) - 1 ) ; int set2 = ( x >> p2 ) & ( ( 1 << n ) - 1 ) ; int xor = ( set1 ^ set2 ) ; xor = ( xor << p1 ) | ( xor << p2 ) ; x = x ^ xor ; }
static void printEqualSumSets ( int arr [ ] , int n ) { int sum_array = sum ( arr ) ; if ( sum_array & 1 ) System . out . println ( " - 1" ) ; return ; } int k = sum_array >> 1 ; int dp [ ] [ ] = new boolean [ n + 1 ] [ k + 1 ] ; for ( int i = 0 ; i <= k ; i ++ ) { dp [ i ] [ 0 ] = false ; } for ( int i = 1 ; i <= n ; i ++ ) { for ( int currSum = 1 ; currSum <= k ; currSum ++ ) { dp [ i ] [ currSum ] = dp [ i - 1 ] [ currSum ] ; if ( arr [ i - 1 ] <= currSum ) { dp [ i ] [ currSum ] = ( dp [ i ] [ currSum ] || dp [ i - 1 ] [ currSum - arr [ i - 1 ] ] ) ; } } int set1 [ ] = new ArrayList < Integer > ( ) ; set2 [ 0 ] = arr [ i ] ; } System . out . println ( " Set ▁ 1 ▁ elements : \n " ) ; for ( int i = 0 ; i > 0 && currSum >= 0 ; i -- ) { if ( dp [ i - 1 ] [ currSum ] ) i -= 1 ; set2 . add ( arr [ i ] ) ; } else { System . out . println ( " Set ▁ 2 ▁ elements : \n " ) ; for ( int i = 0 ; i < set1 . length ; i ++ ) System . out . print ( set1 [ i ] + " ▁ " ) ; } System . out . println ( ) ; }
static int power ( int n ) { if ( n == 1 ) return 2 ; return 2 * power ( n - 1 ) ; }
static void findElements ( int arr [ ] , int n ) { int first = - 2147483647 ; int second = 2147483647 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > first ) { second = first ; first = arr [ i ] ; } else if ( arr [ i ] > second ) { second = arr [ i ] ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < second ) System . out . print ( arr [ i ] + " ▁ " ) ; } }
static int lastPosition ( int n , int m , int k ) { if ( m <= n - k + 1 ) return m + k - 1 ; m = m - ( n - k + 1 ) ; if ( m % n == 0 ) return n ; else return m % n ; }
static void reverseStr ( String str ) { int n = str . length ( ) ; for ( int i = 0 , j = n - 1 ; i < j ; i ++ , j -- ) { str . charAt ( i ) = str . charAt ( j ) ; str . charAt ( j ) = str . charAt ( i ) ; } }
static int findMaximum ( int arr [ ] , int low , int high ) { int max = arr [ low ] ; int i ; for ( i = low ; i <= high ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; } return max ; }
static int longestPrefixSuffix ( String s ) { int n = s . length ( ) ; int lps [ ] = new int [ n ] ; int i = 1 ; while ( i < n ) { if ( s . charAt ( i ) == s . charAt ( l ) ) { l ++ ; lps [ i ] = l ; i ++ ; } else { if ( l != 0 ) l = lps [ l - 1 ] ; else lps [ i ] = 0 ; i ++ ; } } int res = lps [ n - 1 ] ; if ( res > n / 2 ) return n / 2 ; else return res ; }
static int MaxTotalRectangleArea ( int a [ ] , int n ) { Arrays . sort ( a , Collections . reverseOrder ( ) ) ; int sum = 0 ; int flag = false , len = 0 ; int i = 0 ; while ( i < n - 1 ) { if ( i != 0 ) { i ++ ; } if ( a [ i ] == a [ i + 1 ] || a [ i ] - a [ i + 1 ] == 1 ) { flag = true ; len = a [ i + 1 ] ; i ++ ; } else if ( ( a [ i ] == a [ i + 1 ] || a [ i ] - a [ i + 1 ] == 1 ) && flag == false ) { sum = sum + a [ i + 1 ] * len ; flag = false ; i ++ ; } } return sum ; }
static void printFibonacciNumbers ( int n ) { int f1 = 0 , f2 = 1 ; if ( n < 1 ) return ; for ( int x = 0 ; x < n ; x ++ ) { System . out . print ( f2 + " ▁ " ) ; f1 = f2 ; f2 = next ; } }
static void minimizeWithKSwaps ( int arr [ ] , int n , int k ) { for ( int i = 0 ; i < n - 1 && k > 0 ; ++ i ) { int pos = i ; for ( int j = i + 1 ; j < n ; ++ j ) { if ( j - i > k ) break ; if ( arr [ j ] < arr [ pos ] ) pos = j ; } for ( int j = pos ; j > i ; -- j ) SwapInts ( arr , j , j - 1 ) ; k -= pos - i ; } }
static boolean isHeap ( int arr [ ] , int i , int n ) { if ( i > ( n - 2 ) / 2 ) return true ; if ( arr [ i ] >= arr [ 2 * i + 1 ] && arr [ i ] >= arr [ 2 * i + 2 ] && isHeap ( arr , 2 * i + 1 , n ) && isHeap ( arr , 2 * i + 2 , n ) ) return true ; return false ; }
static int findLength ( int st [ ] , int n ) { int [ ] total = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) total [ i ] = ( total [ i - 1 ] + ( st [ i - 1 ] ) - '0' ) ; int ans = 0 ; int l = 2 ; while ( l <= n ) { for ( int i = 1 ; i <= n - l ; i ++ ) { int j = i + l - 1 ; if ( total [ i + int ( l / 2 ) ] - total [ i ] == total [ i + l ] - total [ i + int ( l / 2 ) ] ) ans = Math . max ( ans , l ) ; } l = l + 2 ; } return ans ; }
static int countSubarrays ( int arr [ ] , int n ) { int difference = 0 ; int ans = 0 ; int [ ] hash_positive = new int [ n + 1 ] ; int [ ] hash_negative = new int [ n + 1 ] ; hash_positive [ 0 ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] & 1 == 1 ) difference ++ ; else difference -- ; if ( difference < 0 ) ans += hash_negative [ - difference ] ; else ans += hash_positive [ difference ] ; hash_positive [ difference ] = hash_positive [ difference ] + 1 ; } return ans ; }
static int knapSack ( int W , int wt , int val [ ] , int n ) { int K [ ] [ ] = new int [ n + 1 ] [ W + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int w = 0 ; w <= W ; w ++ ) { if ( i == 0 || w == 0 ) K [ i ] [ w ] = 0 ; else if ( wt [ i - 1 ] <= w ) K [ i ] [ w ] = Math . max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] , K [ i - 1 ] [ w ] ) ; else K [ i ] [ w ] = K [ i - 1 ] [ w ] ; } } } return K [ n ] [ W ] ; }
static void multiply ( int A [ ] [ ] , int B [ ] [ ] , int C [ ] [ ] ) { int i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < N ; j ++ ) C [ i ] [ j ] = A [ i ] [ j ] - B [ i ] [ j ] ; }
static int maxDP ( int n ) { List < Integer > res = new ArrayList < Integer > ( ) ; res . add ( 0 ) ; res . add ( 1 ) ; for ( int i = 2 ; i <= n ; i ++ ) res . add ( Math . max ( i , ( res [ i / 2 ] + res [ i / 3 ] + res [ i / 4 ] + res [ i / 5 ] ) ) ; return res [ n ] ; }
static int findDiff ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int count = 0 , max_count = 0 , min_count = n ; for ( int i = 0 ; i < ( n - 1 ) ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) count ++ ; else { max_count = Math . max ( max_count , count ) ; min_count = Math . min ( min_count , count ) ; count = 0 ; } } return max_count - min_count ; }
static int countSink ( int n , int m , int edgeFrom [ ] , int edgeTo [ ] ) { int mark [ ] = new int [ n + 1 ] ; for ( int i = 0 ; i < m ; i ++ ) mark [ edgeFrom [ i ] ] = 1 ; int count = 0 ; for ( int i = 1 ; i <= n ; i ++ ) if ( ! mark [ i ] ) count ++ ; return count ; }
static int countNegative ( int M [ ] [ ] , int n , int m ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) if ( M [ i ] [ j ] < 0 ) count ++ ; else break ; } return count ; }
static int middleOfThree ( int a , int b , int c ) { if ( a > b ) { if ( b > c ) return b ; else if ( a > c ) return a ; else if ( b > c ) return c ; else return a ; } else { if ( a > b ) if ( b > c ) return b ; else return b ; } }
static int countOfSubstringWithKOnes ( String s , int K ) { int N = s . length ( ) ; int res = 0 ; int countOfOne = 0 ; int freq [ ] = new int [ N + 1 ] ; freq [ 0 ] = 1 ; for ( int i = 0 ; i <= N ; i ++ ) { countOfOne += s . charAt ( i ) - '0' ; if ( countOfOne >= K ) res += freq [ countOfOne - K ] ; freq [ countOfOne ] ++ ; } return res ; }
static Boolean findPairs ( int arr [ ] , int n ) { HashMap < Integer , Integer > Hash = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i <= n - 2 ; i ++ ) { for ( int j = i + 1 ; j <= n ; j ++ ) { int sum = arr [ i ] + arr [ j ] ; if ( Hash . containsKey ( sum ) ) { int prev = Hash . get ( sum ) ; System . out . print ( str ( prev ) + " ▁ and ▁ ( % d , ▁ % d ) " ) ; return true ; } else { Hash . put ( sum , arr [ i ] + arr [ j ] ) ; } } } return false ; }
static int search ( int arr [ ] , int n , int x ) { for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == x ) return i ; return - 1 ; }
static boolean check ( String s1 , String s2 ) { int n = s1 . length ( ) ; int m = s2 . length ( ) ; boolean [ ] [ ] dp = new boolean [ n + 1 ] [ m + 1 ] ; Arrays . fill ( dp , false ) ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= s2 . length ( ) ; j ++ ) { if ( dp [ i ] [ j ] ) { if ( ( j < s2 . length ( ) && ( s1 . charAt ( i ) . toUpperCase ( ) == s2 . charAt ( j ) ) ) dp [ i + 1 ] [ j + 1 ] = true ; if ( s1 . charAt ( i ) . isupper ( ) == false ) dp [ i + 1 ] [ j ] = true ; } } } return ( dp [ n ] [ m ] ) ; }
static int binaryToDecimal ( String n ) { String num = n ; int dec_value = 0 ; int base1 = 1 ; int len1 = num . length ( ) ; for ( int i = len1 - 1 ; i >= 0 ; i -- ) { if ( num . charAt ( i ) == '1' ) dec_value += base1 ; base1 = base1 * 2 ; } return dec_value ; }
static int countWays ( int n ) { int [ ] [ ] dp = new int [ 2 ] [ n + 1 ] ; dp [ 0 ] [ 1 ] = 1 ; dp [ 1 ] [ 1 ] = 2 ; for ( int i = 2 ; i <= n ; i ++ ) { dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + dp [ 1 ] [ i - 1 ] ; dp [ 1 ] [ i ] = ( dp [ 0 ] [ i - 1 ] * 2 + dp [ 1 ] [ i - 1 ] ) ; } return dp [ 0 ] [ n ] + dp [ 1 ] [ n ] ; }
static String compute ( String str , int n ) { String reverseAlphabet = " zyxwvutsrqponmlkjihgfedcba " ; int l = str . length ( ) ; String answer = " " ; for ( int i = 0 ; i < n ; i ++ ) answer += str . charAt ( i ) ; for ( int i = 0 ; i < l ; i ++ ) answer = answer + reverseAlphabet . charAt ( str . charAt ( i ) - ' a ' ) ; return answer ; }
static int maxLenSub ( int arr [ ] , int n ) { int mls [ ] = new int [ n ] ; int max = 0 ; for ( int i = 0 ; i < n ; i ++ ) mls [ i ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( Math . abs ( arr [ i ] - arr [ j ] ) <= 1 && mls [ i ] < mls [ j ] + 1 ) mls [ i ] = mls [ j ] + 1 ; } } for ( int i = 0 ; i < n ; i ++ ) if ( max < mls [ i ] ) max = mls [ i ] ; return max ; }
static int exponentiation ( int bas , int exp ) { int t = 1 ; while ( exp > 0 ) { if ( exp % 2 != 0 ) t = ( t * bas ) % N ; bas = ( bas * bas ) % N ; exp = exp / 2 ; } return t % N ; }
static int sequence ( int n ) { int [ ] f = new int [ n + 1 ] ; for ( int i = 3 ; i <= n ; i ++ ) { int r = f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ] ; f . add ( r ) ; } return r ; }
static int lbs ( int arr [ ] ) { int n = arr . length ; int lis [ ] = new int [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= i ; j ++ ) { if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; } } int lds [ ] = new int [ n - 1 ] ; for ( int i = 0 ; i <= n - 2 ; i ++ ) { for ( int j = i - 1 ; j <= n ; j ++ ) { if ( arr [ i ] > arr [ j ] && lds [ i ] < lds [ j ] + 1 ) lds [ i ] = lds [ j ] + 1 ; } } int maximum = lis [ 0 ] + lds [ 0 ] - 1 ; for ( int i = 1 ; i <= n ; i ++ ) maximum = Math . max ( ( lis [ i ] + lds [ i ] - 1 ) , maximum ) ; return maximum ; }
static int maximumSum ( int a [ ] [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { Arrays . sort ( a [ i ] ) ; int sum = a [ n - 1 ] [ M - 1 ] ; int prev = a [ n - 1 ] [ M - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) { for ( int j = M - 1 ; j >= 0 ; j -- ) { if ( a [ i ] [ j ] < prev ) { prev = a [ i ] [ j ] ; sum += prev ; break ; } } if ( j == - 1 ) { return 0 ; } } return sum ; }
static int fib ( int n ) { if ( n <= 1 ) return n ; return fib ( n - 1 ) + fib ( n - 2 ) ; }
static int countPairs ( String str ) { int result = 0 ; int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( Math . abs ( str . charAt ( i ) - str . charAt ( j ) ) == Math . abs ( i - j ) ) result ++ ; } } return result ; }
static boolean flipsPossible ( int a [ ] , int n ) { int count_odd = 0 , count_even = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] & 1 ) count_odd ++ ; else count_even ++ ; } if ( count_odd % 2 && count_even % 2 ) return false ; else return true ; }
static boolean checkDuplicatesWithinK ( int arr [ ] , int n , int k ) { HashSet < Integer > myset = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( myset . contains ( arr [ i ] ) ) return true ; myset . add ( arr [ i ] ) ; if ( i >= k ) myset . remove ( arr [ i - k ] ) ; } return false ; }
static void diagonalsquare ( int mat [ ] [ ] , int row , int column ) { System . out . print ( " Diagonal ▁ one ▁ : ▁ " ) ; for ( int i = 0 ; i < row ; i ++ ) System . out . print ( mat [ i ] [ i ] * mat [ i ] [ i ] + " ▁ " ) ; System . out . print ( " \n \n Diagonal ▁ two ▁ : ▁ " ) ; for ( int i = 0 ; i < row ; i ++ ) System . out . print ( mat [ i ] [ row - i - 1 ] * mat [ i ] [ row - i - 1 ] + " ▁ " ) ; System . out . println ( ) ; }
static int maxArea ( int mat [ ] [ ] ) { int hist [ ] [ ] = new int [ R ] [ C ] ; for ( int i = 0 ; i < R + 1 ; i ++ ) { hist [ i ] [ i ] = mat [ 0 ] [ i ] ; for ( int j = 0 ; j < R ; j ++ ) { if ( mat [ j ] [ i ] == 0 ) hist [ j ] [ i ] = 0 ; else hist [ j ] [ i ] = hist [ j - 1 ] [ i ] + 1 ; } } for ( int i = 0 ; i < R ; i ++ ) { int count [ ] = new int [ R + 1 ] ; for ( int j = 0 ; j < C ; j ++ ) { if ( count [ j ] > 0 ) { for ( int k = 0 ; k < count [ j ] ; k ++ ) { hist [ i ] [ col_no ] = j ; col_no ++ ; } } j -- ; } } int max_area = 0 ; for ( int i = 0 ; i < R ; i ++ ) { for ( int j = 0 ; j < C ; j ++ ) { int curr_area = ( j + 1 ) * hist [ i ] [ j ] ; if ( curr_area > max_area ) max_area = curr_area ; } } } return max_area ; }
static int longestSubseqWithDiffOne ( int arr [ ] , int n ) { int dp [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ i ] == arr [ j ] + 1 || arr [ i ] == arr [ j ] - 1 ) { dp [ i ] = Math . max ( dp [ i ] , dp [ j ] + 1 ) ; } } } int result = 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( result < dp [ i ] ) result = dp [ i ] ; return result ; }
static int maxSquare ( int b , int m ) { return ( b / m - 1 ) * ( b / m ) / 2 ; }
static int maxSumPairWithDifferenceLessThanK ( int arr [ ] , int N , int K ) { Arrays . sort ( arr ) ; int dp [ ] = new int [ N ] ; dp [ 0 ] = 0 ; for ( int i = 1 ; i < N ; i ++ ) { dp [ i ] = dp [ i - 1 ] ; if ( arr [ i ] - arr [ i - 1 ] < K ) { if ( i >= 1 ) dp [ i ] = Math . max ( dp [ i ] , dp [ i - 2 ] + arr [ i ] + arr [ i - 1 ] ) ; else dp [ i ] = Math . max ( dp [ i ] , arr [ i ] + arr [ i - 1 ] ) ; } } return dp [ N - 1 ] ; }
static int minOperation ( int arr [ ] , int n ) { int Hash [ ] = new int [ arr . length ] ; for ( int i = 0 ; i < n ; i ++ ) Hash [ arr [ i ] ] ++ ; int max_count = 0 ; for ( int i = 0 ; i < Hash . length ; i ++ ) { if ( max_count < Hash [ i ] ) max_count = Hash [ i ] ; } return n - max_count ; }
static void kSmallestPair ( int arr1 [ ] , int n1 , int arr2 [ ] , int n2 , int k ) { if ( k > n1 * n2 ) System . out . println ( " k ▁ pairs ▁ don ' t ▁ exist " ) ; return ; }
static void spiralPrint ( int m , int n , int a [ ] [ ] ) { int i , k = 0 , l = 0 ; while ( k < m && l < n ) { for ( i = l ; i < n ; i ++ ) { System . out . print ( a [ k ] [ i ] + " ▁ " ) ; } k ++ ; for ( i = k ; i < m ; ++ i ) { System . out . print ( a [ i ] [ n - 1 ] + " ▁ " ) ; } n -- ; if ( k < m ) { for ( i = n - 1 ; i >= ( l - 1 ) ; -- i ) { System . out . print ( a [ m - 1 ] [ i ] + " ▁ " ) ; } m -- ; } if ( l < n ) { for ( i = m - 1 ; i >= k ; -- i ) { System . out . print ( a [ i ] [ l ] + " ▁ " ) ; } l ++ ; } } }
static int findSum ( String str ) { String temp = " " ; int sum = 0 ; for ( char ch = 0 ; ch < str . length ( ) ; ch ++ ) { if ( ch . isdigit ( ) ) temp += ch ; else sum += ( int ) temp ; } return sum + ( int ) temp ; }
public static double pentagonalNum ( int n ) { return ( 3 * n * n - n ) / 2 ; }
static int countNonDecreasing ( int n ) { int N = 10 ; int count = 1 ; for ( int i = 1 ; i <= n ; i ++ ) count = count * ( N + i - 1 ) ; count = count / i ; return count ; }
static int mostFrequent ( int arr [ ] , int n ) { int Hash = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( Hash . containsKey ( arr [ i ] ) ) Hash . put ( arr [ i ] , Hash . get ( arr [ i ] ) + 1 ) ; else Hash . put ( arr [ i ] , 1 ) ; } int max_count = 0 ; int res = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( max_count < Hash . get ( i ) ) res = i ; max_count = Hash . get ( i ) ; } return res ; }
public static int kth ( int arr1 [ ] , int arr2 [ ] , int m , int n , int k ) { int sorted1 [ ] = new int [ m + n ] ; int i = 0 , j = 0 , d = 0 ; while ( i < m && j < n ) { if ( arr1 [ i ] < arr2 [ j ] ) sorted1 [ d ] = arr1 [ i ++ ] ; else sorted1 [ d ] = arr2 [ j ++ ] ; d ++ ; } while ( i < m ) { sorted1 [ d ] = arr1 [ i ++ ] ; i ++ ; } while ( j < n ) { sorted1 [ d ] = arr2 [ j ++ ] ; d ++ ; } return sorted1 [ k - 1 ] ; }
static int binomialCoeff ( int n , int k ) { if ( k == 0 || n == k ) return 1 ; return binomialCoeff ( n - 1 , k - 1 ) + binomialCoeff ( n - 1 , k ) ; }
static String firstLetterWord ( String str ) { String result = " " ; boolean v = true ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) == ' ▁ ' ) v = true ; else if ( str . charAt ( i ) != ' ▁ ' && v == true ) result += ( str . charAt ( i ) ) ; } return result ; }
static void assign ( int [ ] a , int n ) { Arrays . sort ( a ) ; int [ ] ans = new int [ n ] ; int p = 0 , q = n - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( i + 1 ) % 2 == 0 ) { ans [ i ] = a [ q ] ; q = q - 1 ; } else { ans [ i ] = a [ p ] ; p = p + 1 ; } } for ( int i = 0 ; i < n ; i ++ ) System . out . print ( ans [ i ] + " ▁ " ) ; }
static void printDistinct ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int d = 0 ; for ( int j = 0 ; j < i ; j ++ ) if ( arr [ i ] == arr [ j ] ) d = 1 ; if ( d == 0 ) System . out . print ( arr [ i ] ) ; } }
static int countSolutions ( int n ) { int res = 0 ; int x = 0 ; while ( x * x < n ) { int y = 0 ; while ( x * x + y * y < n ) res ++ ; y = y + 1 ; x = x + 1 ; } return res ; }
static void relativeComplement ( int arr1 [ ] , int arr2 [ ] , int n , int m ) { int i = 0 , j = 0 ; while ( i < n && j < m ) { if ( arr1 [ i ] < arr2 [ j ] ) System . out . print ( arr1 [ i ++ ] + " ▁ " ) ; else if ( arr1 [ i ] > arr2 [ j ] ) j ++ ; else if ( arr1 [ i ] == arr2 [ j ] ) i ++ ; else if ( arr1 [ i ] == arr2 [ j ] ) i ++ ; } while ( i < n ) System . out . print ( arr1 [ i ++ ] + " ▁ " ) ; }
static int findFourElements ( int arr [ ] , int n ) { Map < Integer , Integer > myMap = new HashMap < > ( ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { myMap . put ( arr [ i ] + arr [ j ] , myMap . get ( arr [ i ] + arr [ j ] ) ) ; } } int d = - 10 ** 9 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int abs_diff = Math . abs ( arr [ i ] - arr [ j ] ) ; if ( abs_diff >= 0 && myMap . get ( abs_diff ) != i && myMap . get ( abs_diff ) != j ) d = Math . max ( d , Math . max ( arr [ i ] , arr [ j ] ) ) ; } } return d ; }
static int findTrailingZeros ( int n ) { int count = 0 ; for ( int i = 5 ; n / i >= 1 ; i *= 5 ) count += ( n / i ) ; return count ; }
static boolean isPrime ( int p ) { int checkNumber = ( 2 ** p - 1 ) ; int nextval = 4 % checkNumber ; for ( int i = 1 ; i < p ; i ++ ) nextval = ( nextval * nextval - 2 ) % checkNumber ; if ( nextval == 0 ) return true ; else return false ; }
static int CountSubString ( String str , int n ) { int ans = ( n * ( n + 1 ) ) / 2 ; int a_index = 0 , b_index = 0 , c_index = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str . charAt ( i ) == ' a ' ) a_index = i + 1 ; ans -= Math . min ( b_index , c_index ) ; else if ( str . charAt ( i ) == ' b ' ) b_index = i + 1 ; ans -= Math . min ( a_index , c_index ) ; else c_index = i + 1 ; ans -= Math . min ( a_index , b_index ) ; } return ans ; }
static boolean isPalindrome ( String str ) { int l = 0 , h = str . length ( ) - 1 ; while ( h > l ) { l ++ ; h -- ; if ( str . charAt ( l - 1 ) != str . charAt ( h + 1 ) ) { return false ; } } return true ; }
static int maxNumOfChocolates ( int arr [ ] , int n , int k ) { int um [ ] = new int [ 2 * n + 1 ] ; int sm [ ] = new int [ n ] ; sm [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { sm [ i ] = sm [ i - 1 ] + arr [ i ] ; } for ( int i = 1 ; i < n ; i ++ ) { curr_rem = sm [ i ] % k ; if ( ! curr_rem && maxSum < sm [ i ] ) maxSum = sm [ i ] ; else if ( maxSum < ( sm [ i ] - sm [ um [ curr_rem ] ] ) ) maxSum = sm [ i ] - sm [ um [ curr_rem ] ] ; } return maxSum / k ; }
static void decode ( String str ) { Vector < Integer > integerstack = new Vector < > ( ) ; Vector < Integer > stringstack = new Vector < > ( ) ; String temp = " " ; String result = " " ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { int count = 0 ; if ( str . charAt ( i ) >= '0' && str . charAt ( i ) <= '9' ) { while ( str . charAt ( i ) >= '0' && str . charAt ( i ) <= '9' ) { count = count * 10 + ( char ) ( str . charAt ( i ) - '0' ) ; i ++ ; } i -- ; integerstack . add ( count ) ; } else if ( str . charAt ( i ) == ' [ ' ) { temp = " " ; count = integerstack . peek ( ) ; if ( stringstack . size ( ) != 0 && stringstack . peek ( ) != ' [ ' ) { temp = stringstack . peek ( ) + temp ; stringstack . pop ( ) ; } for ( int j = 0 ; j < count ; j ++ ) { result = result + temp ; } result = " " ; } else if ( str . charAt ( i ) == ' [ ' ) { if ( str . charAt ( i - 1 ) >= '0' && str . charAt ( i - 1 ) <= '9' ) { stringstack . add ( str . charAt ( i ) ) ; integerstack . add ( 1 ) ; } else { stringstack . add ( str . charAt ( i ) ) ; } } while ( strstack . size ( ) != 0 ) { result = stringstack . peek ( ) ; } }
static int minSum ( int A [ ] ) { int min_val = Math . min ( A ) ; return min_val * ( A . length - 1 ) ; }
static int isPower ( int x , int y ) { int res1 = Math . log ( y ) / Math . log ( x ) ; int res2 = Math . log ( y ) / Math . log ( x ) ; return 1 if ( res1 == res2 ) else 0 ; }
static int countWords ( String str , int n ) { Map < Character , Integer > m = new HashMap < Character , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) m . put ( str , i ) ; int res = 0 ; for ( int i = 0 ; i < m . size ( ) ; i ++ ) { if ( m . containsKey ( stri [ i ] ) ) res ++ ; } return res ; }
static int findLargestd ( int S [ ] , int n ) { boolean found = false ; Arrays . sort ( S ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == j ) continue ; for ( int k = j + 1 ; k < n ; k ++ ) { if ( i == k ) continue ; for ( int l = k + 1 ; l < n ; l ++ ) { if ( i == l ) continue ; if ( S [ i ] == S [ j ] + S [ k ] + S [ l ] ) found = true ; return S [ i ] ; } } } if ( found == false ) return - 1 ; }
static void minMaxValues ( int arr [ ] , int n , int m ) { int sum = 0 ; int INF = 1000000000 ; int MAX = 50 ; for ( int i = 0 ; i < ( n + m ) ; i ++ ) { sum += arr [ i ] ; arr [ i ] += 50 ; } int dp [ ] [ ] = new int [ MAX * MAX + 1 ] [ MAX + 1 ] ; for ( int i = 0 ; i < ( n + m ) ; i ++ ) { for ( int k = Math . min ( n , i + 1 ) ; k >= 0 ; k -- ) { for ( int j = 0 ; j <= MAX * MAX ; j ++ ) { if ( dp [ k - 1 ] [ j ] ) { dp [ k ] [ j + arr [ i ] ] = 1 ; } } } int max_value = Integer . MIN_VALUE ; int min_value = Integer . MAX_VALUE ; for ( int i = 0 ; i < MAX * MAX + 1 ; i ++ ) { if ( dp [ n ] [ i ] ) { temp = i - 50 * n ; max_value = Math . max ( max_value , temp * ( sum - temp ) ) ; min_value = Math . min ( min_value , temp * ( sum - temp ) ) ; } } System . out . println ( " Maximum ▁ Value : ▁ { } \n Minimum ▁ Value : ▁ { } " ) ; }
static void constructTree ( int n , int d , int h ) { if ( d == 1 ) { if ( n == 2 && h == 1 ) System . out . println ( " 1 ▁ 2 " ) ; return ; } if ( d > 2 * h ) System . out . println ( " - 1" ) ; return ; for ( int i = 1 ; i <= h ; i ++ ) { System . out . println ( i + " ▁ " + i + 1 ) ; } if ( d > h ) { System . out . println ( 1 + " ▁ ▁ " + h + 2 ) ; for ( int i = h + 2 ; i <= d ; i ++ ) { System . out . println ( i + " ▁ " + i + 1 ) ; } } for ( int i = d + 1 ; i <= n ; i ++ ) { int k = 1 ; if ( d == h ) k = 2 ; System . out . println ( k + " ▁ " + i + 1 ) ; } }
static int rectCount ( int n , int m ) { return ( m * n * ( n + 1 ) * ( m + 1 ) ) / 4 ; }
static void sortUsingHash ( int [ ] a , int n ) { int Max = Arrays . stream ( a ) . max ( ) . getAsInt ( ) ; int [ ] Hash = new int [ Max + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) Hash [ a [ i ] ] ++ ; for ( int i = 0 ; i <= Max ; i ++ ) { if ( Hash [ i ] != 0 ) { for ( int j = 0 ; j < Hash [ i ] ; j ++ ) System . out . print ( i + " ▁ " ) ; } } }
static void subarrayDivisibleByK ( int arr [ ] , int n , int k ) { int m [ ] = new int [ 1000 ] ; int s = 0 , e = 0 , maxs = 0 , maxe = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int mod = arr [ i ] % k ; while ( mp [ k - mod ] != 0 || mod == 0 && mp [ mod ] != 0 ) { m [ arr [ s ] % k ] = mp [ arr [ s ] % k ] - 1 ; s = s + 1 ; } mp [ k ] = mp [ arr [ s ] % k ] + 1 ; e = e + 1 ; if ( ( e - s ) > ( maxe - maxs ) ) { maxe = e ; maxs = s ; } } System . out . println ( " The ▁ maximum ▁ size ▁ is ▁ { } ▁ and ▁ the ▁ " ) ; for ( int i = maxs ; i <= maxe ; i ++ ) System . out . println ( " ▁ " + ( maxe - maxs + 1 ) ) ; }
static boolean isDivisible ( String str , int k ) { int n = str . length ( ) ; int c = 0 ; for ( int i = 0 ; i < k ; i ++ ) if ( str . charAt ( n - i - 1 ) == '0' ) c ++ ; return ( c == k ) ; }
static int divisible ( String num ) { int n = num . length ( ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += num . charAt ( i ) ; if ( sum % 3 == 0 ) return 0 ; if ( n == 1 ) return - 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( sum % 3 == int ( num . charAt ( i ) ) % 3 ) return 1 ; if ( n == 2 ) return - 1 ; return 2 ; }
static int superSeq ( int X [ ] , int Y [ ] , int m , int n ) { if ( ! m ) return n ; if ( ! n ) return m ; if ( X [ m - 1 ] == Y [ n - 1 ] ) return 1 + superSeq ( X , Y , m - 1 , n - 1 ) ; return 1 + Math . min ( superSeq ( X , Y , m - 1 , n ) , superSeq ( X , Y , m , n - 1 ) ) ; }
static void swapUpperToLower ( int arr [ ] [ ] ) { int n = arr . length ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int temp = arr [ i ] [ j ] ; arr [ i ] [ j ] = arr [ j ] [ i ] ; arr [ j ] [ i ] = temp ; } } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) System . out . print ( arr [ i ] [ j ] + " ▁ " ) ; } System . out . println ( ) ; }
public static int kthgroupsum ( int k ) { int cur = ( k * ( k - 1 ) ) + 1 ; int sum = 0 ; while ( k ) { sum += cur ; cur += 2 ; k = k - 1 ; } return sum ; }
static boolean isMagicSquare ( int mat [ ] [ ] ) { int s = 0 ; for ( int i = 0 ; i < N ; i ++ ) { s = s + mat [ i ] [ i ] ; } int s2 = 0 ; for ( int i = 0 ; i < N ; i ++ ) { s2 = s2 + mat [ i ] [ N - i - 1 ] ; } if ( s != s2 ) return false ; for ( int i = 0 ; i < N ; i ++ ) { int rowSum = 0 ; for ( int j = 0 ; j < N ; j ++ ) rowSum += mat [ i ] [ j ] ; if ( rowSum != s ) return false ; } for ( int i = 0 ; i < N ; i ++ ) { int colSum = 0 ; for ( int j = 0 ; j < N ; j ++ ) colSum += mat [ j ] [ i ] ; if ( s != colSum ) return false ; } return true ; }
static boolean isScalarMatrix ( int mat [ ] [ ] ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) { if ( ( i != j ) && ( mat [ i ] [ j ] != 0 ) ) return false ; } } for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( mat [ i ] [ i ] != mat [ i + 1 ] [ i + 1 ] ) return false ; } return true ; }
static int longSubarrWthSumDivByK ( int arr [ ] , int n , int k ) { int um [ ] = new int [ 8 ] ; int [ ] mod_arr = new int [ n ] ; int max = 0 ; int curr_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { curr_sum += arr [ i ] ; mod_arr [ i ] = ( ( curr_sum % k ) + k ) % k ; } for ( int i = 0 ; i < n ; i ++ ) { if ( mod_arr [ i ] == 0 ) max = i + 1 ; else if ( mod_arr [ i ] == um [ mod_arr [ i ] ] == - 1 ) um [ mod_arr [ i ] ] = i ; else { if ( max < ( i - um [ mod_arr [ i ] ] ) ) max = i - um [ mod_arr [ i ] ] ; } } return max ; }
static void reverse ( String str ) { if ( str . length ( ) == 0 ) return ; String temp = str . charAt ( 0 ) ; reverse ( str . substring ( 1 ) ) ; System . out . print ( temp ) ; }
static int arrangeBraces ( int n , int pos [ ] , int k ) { boolean [ ] [ ] h = new boolean [ N ] [ N ] ; int [ ] [ ] dp = new int [ N ] [ N ] ; for ( int i = 0 ; i < k ; i ++ ) { h [ i ] = false ; } for ( int i = 0 ; i < N ; i ++ ) { dp [ i ] [ 0 ] = 1 ; } for ( int i = 1 ; i <= 2 * n ; i ++ ) { for ( int j = 2 * n + 1 ; j <= k ; j ++ ) { if ( h [ i ] ) { if ( j != 0 ) { dp [ i ] [ j ] = ( dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] ) ; } else { dp [ i ] [ j ] = 0 ; } } } return dp [ 2 * n ] [ 0 ] ; }
static boolean isDvisibleBy12 ( String num ) { if ( num . length ( ) >= 3 ) { int d1 = num . charAt ( num . length ( ) - 1 ) ; if ( d1 % 2 != 0 ) return false ; int d2 = num . charAt ( num . length ( ) - 2 ) ; int sum = 0 ; for ( int i = 0 ; i < num . length ( ) ; i ++ ) sum += num . charAt ( i ) ; return ( sum % 3 == 0 && ( d2 * 10 + d1 ) % 4 == 0 ) ; } else { int number = num . charAt ( 0 ) ; return ( number % 12 == 0 ) ; } }
public static int maxDiff ( int arr [ ] , int n ) { int SubsetSum_1 = 0 , SubsetSum_2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { boolean isSingleOccurance = true ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] == arr [ j ] ) { isSingleOccurance = false ; arr [ i ] = arr [ j ] = 0 ; break ; } } if ( isSingleOccurance == true ) { if ( arr [ i ] > 0 ) SubsetSum_1 += arr [ i ] ; else SubsetSum_2 += arr [ i ] ; } } return Math . abs ( SubsetSum_1 - SubsetSum_2 ) ; }
static String lexSmallest ( Integer [ ] a , int n ) { Arrays . sort ( a ) ; String answer = " " ; for ( int i = 0 ; i < n ; i ++ ) answer += a [ i ] ; return answer ; }
static int maxCost ( int mat [ ] [ ] , int N ) { int [ ] [ ] dp = new int [ N ] [ N ] ; dp [ 0 ] [ 0 ] = mat [ 0 ] [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { dp [ i ] [ j ] = mat [ i ] [ j ] + dp [ i - 1 ] [ 0 ] ; } } for ( int i = 1 ; i < N ; i ++ ) { for ( int j = 1 ; j <= Math . min ( i + 1 , N ) ; j ++ ) { dp [ i ] [ j ] = mat [ i ] [ j ] + \ Math . max ( dp [ i - 1 ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ; } } int result = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( result < dp [ N - 1 ] [ i ] ) result = dp [ N - 1 ] [ i ] ; return result ; }
static int xorZero ( String str ) { int one_count = 0 , zero_count = 0 ; int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( str . charAt ( i ) == '1' ) one_count ++ ; else zero_count ++ ; } if ( one_count % 2 == 0 ) return zero_count ; return one_count ; }
static double nthRoot ( double A , int N ) { int xPre = random . randint ( 1 , 101 ) % 10 ; double eps = 0.001 ; double delX = 2147483647 ; double xK = 0.0 ; while ( delX > eps ) { xK = ( N - 1.0 ) * xPre + A / pow ( xPre , N - 1 ) ) / N ; delX = Math . abs ( xK - xPre ) ; xPre = xK ; } return xK ; }
static String findLeft ( String str ) { int n = str . length ( ) - 1 ; while ( n > 0 ) { if ( str . charAt ( n ) == ' d ' ) str = str . charAt ( 0 : n ) + ' c ' + str . charAt ( n + 1 ) ; break ; if ( str . charAt ( n ) == ' b ' ) str = str . charAt ( 0 : n ) + ' a ' + str . charAt ( n + 1 ) ; break ; if ( str . charAt ( n ) == ' a ' ) str = str . charAt ( 0 : n ) + ' b ' + str . charAt ( n + 1 ) ; else if ( str . charAt ( n ) == ' c ' ) str = str . charAt ( 0 : n ) + ' d ' + str . charAt ( n + 1 ) ; } n -- ; } return str ; }
static int subset ( int ar [ ] , int n ) { int res = 0 ; Arrays . sort ( ar ) ; for ( int i = 0 ; i < n ; i ++ ) { int count = 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( ar [ i ] == ar [ i + 1 ] ) count ++ ; else break ; } res = Math . max ( res , count ) ; } return res ; }
static void minRange ( int arr [ ] , int n , int k ) { int l = 0 , r = n ; for ( int i = 0 ; i < n ; i ++ ) { int [ ] s = new int [ k ] ; for ( int j = i ; j < n ; j ++ ) { s . add ( arr [ j ] ) ; if ( s . length == k ) { if ( ( j - i ) < ( r - l ) ) { r = j ; l = i ; } break ; } } if ( j == n ) break ; if ( l == 0 && r == n ) System . out . println ( " Invalid ▁ k " ) ; else System . out . println ( l + " ▁ r " ) ; }
static int findSum ( int A [ ] , int B [ ] , int n ) { int Hash [ ] = new int [ 2 * n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) Hash [ A [ i ] ] ++ ; Hash [ B [ i ] ] ++ ; int sum = 0 ; for ( int x = 0 ; x < Hash . length ; x ++ ) if ( Hash [ x ] == 1 ) sum += x ; return sum ; }
static String printSubStr ( String str , int low , int high ) { System . out . print ( str . charAt ( low ) ) ; System . out . flush ( ) ; return null ; }
static int evenSum ( int n ) { int [ ] [ ] C = new int [ n + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= Math . min ( i , n + 1 ) ; j ++ ) { if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } int sum = 0 ; for ( int i = 0 ; i <= n ; i ++ ) if ( n % 2 == 0 ) sum = sum + C [ n ] [ i ] ; return sum ; }
static int getMinSquares ( int n ) { int [ ] dp = new int [ n + 1 ] ; dp . add ( 0 ) ; for ( int i = 4 ; i <= n ; i ++ ) { dp . add ( i ) ; for ( int x = 1 ; x <= Math . sqrt ( i ) ; x ++ ) { int temp = x * x ; if ( temp > i ) break ; else dp [ i ] = Math . min ( dp [ i ] , 1 + dp [ i - temp ] ) ; } } return dp [ n ] ; }
static void arrayEvenAndOdd ( int arr [ ] , int n ) { int i = - 1 , j = 0 ; while ( j != n ) { if ( arr [ j ] % 2 == 0 ) { i ++ ; arr [ i ] = arr [ j ] ; arr [ j ] = arr [ i ] ; } } for ( int i = 0 ; i < arr . length ; i ++ ) System . out . print ( str ( i ) + " ▁ " ) ; }
static void diagonalsquare ( int mat [ ] [ ] , int row , int column ) { System . out . print ( " Diagonal ▁ one ▁ : ▁ " ) ; for ( int i = 0 ; i < row ; i ++ ) { for ( int j = 0 ; j < column ; j ++ ) { if ( i == j ) System . out . print ( mat [ i ] [ j ] * mat [ i ] [ j ] ) ; System . out . println ( ) ; } } System . out . print ( " ▁ \n \n Diagonal ▁ two ▁ : ▁ " ) ; for ( int i = 0 ; i < row ; i ++ ) { for ( int j = 0 ; j < column ; j ++ ) { if ( i + j == column - 1 ) System . out . print ( mat [ i ] [ j ] * mat [ i ] [ j ] ) ; System . out . println ( ) ; } } }
static int areSumSame ( int a [ ] [ ] , int n , int m ) { int sum1 = 0 , sum2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum1 = 0 ; sum2 = 0 ; for ( int j = 0 ; j < m ; j ++ ) { sum1 += a [ i ] [ j ] ; sum2 += a [ j ] [ i ] ; } if ( sum1 == sum2 ) return 1 ; } return 0 ; }
static void printClosest ( int arr [ ] , int n , int x ) { int res_l , res_r = 0 , diff = 0 , n - 1 , MAX_VAL ; while ( r > l ) { if ( Math . abs ( arr [ l ] + arr [ r ] - x ) < diff ) res_l = l ; res_r = r ; diff = Math . abs ( arr [ l ] + arr [ r ] - x ) ; if ( arr [ l ] + arr [ r ] > x ) r -- ; else l ++ ; } System . out . println ( " The ▁ closest ▁ pair ▁ is ▁ { } ▁ and ▁ " + arr [ res_l ] + " ▁ " + arr [ res_r ] ) ; }
static int countSubStr ( char str [ ] , int n ) { int m = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == '1' ) m ++ ; } return m * ( m - 1 ) / 2 ; }
static int countSubstringWithEqualEnds ( String s ) { int result = 0 ; int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) if ( s . charAt ( i ) == s . charAt ( j ) ) result ++ ; } return result ; }
static int calcMaxValue ( String str ) { int res = ( str . charAt ( 0 ) - 48 ) ; for ( int i = 1 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) == '0' || str . charAt ( i ) == '1' || res < 2 ) res += ( str . charAt ( i ) - 48 ) ; else res *= ( str . charAt ( i ) - 48 ) ; } return res ; }
static void bestFit ( int blockSize [ ] , int m , int processSize [ ] , int n ) { int [ ] allocation = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { int bestIdx = - 1 ; for ( int j = 0 ; j < m ; j ++ ) { if ( blockSize [ j ] >= processSize [ i ] ) bestIdx = j ; else if ( blockSize [ bestIdx ] > blockSize [ j ] ) bestIdx = j ; } } if ( bestIdx != - 1 ) { allocation [ i ] = bestIdx ; blockSize [ bestIdx ] -= processSize [ i ] ; } } System . out . println ( " Process ▁ No . ▁ Process ▁ Size ▁ ▁ ▁ Block ▁ no . " ) ; for ( int i = 0 ; i < n ; i ++ ) { System . out . println ( i + 1 + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ " + processSize [ i ] + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " ) ; if ( allocation [ i ] != - 1 ) System . out . println ( allocation [ i ] + " Not ▁ Allocated " ) ; else System . out . println ( " Not ▁ Allocated " ) ; } }
static void countFreq ( int [ ] a , int n ) { HashMap < Integer , Integer > hm = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) hm . put ( a [ i ] , hm . get ( a [ i ] ) + 1 ) ; int cumul = 0 ; for ( int i = 0 ; i < n ; i ++ ) { cumul += hm . get ( a [ i ] ) ; if ( hm . containsKey ( a [ i ] ) ) System . out . println ( a [ i ] + " - > " + cumul ) ; hm . put ( a [ i ] , 0 ) ; } }
static boolean isSubSeqDivisible ( int st [ ] ) { int l = st . length ; int arr [ ] = new int [ l ] ; for ( int i = 0 ; i < l ; i ++ ) { for ( int j = i ; j < l ; j ++ ) { for ( int k = j ; k < l ; k ++ ) { if ( arr [ i ] % 8 == 0 ) return true ; else if ( ( arr [ i ] * 10 + arr [ j ] ) % 8 == 0 && i != j ) return true ; else if ( ( arr [ i ] * 100 + arr [ j ] * 10 + arr [ k ] ) % 8 == 0 && i != j && j != k && i != k ) return true ; } } } return false ; }
static int getAbs ( int n ) { int mask = n >> ( SIZE_INT * CHARBIT - 1 ) ; return ( n + mask ) ^ mask ; }
static int countPairs ( int arr [ ] , int n ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int product = arr [ i ] * arr [ j ] ; for ( int k = 0 ; k < n ; k ++ ) if ( arr [ k ] == product ) result ++ ; } } return result ; }
static int minCost ( int a [ ] , int n , int k ) { int [ ] [ ] dp = new int [ k + 1 ] [ n + 1 ] ; dp [ 0 ] [ 0 ] = 0 ; for ( int i = 0 ; i <= k ; i ++ ) { for ( int j = i ; j <= n ; j ++ ) { for ( int m = i - 1 ; m >= 0 ; m -- ) dp [ i ] [ j ] = Math . min ( dp [ i ] [ j ] , dp [ m ] [ j - 1 ] + ( a [ i - 1 ] - a [ m ] ) * ( a [ i - 1 ] - a [ m ] ) ) ; } } return dp [ n ] [ k ] ; }
static boolean containsOdd ( int G [ ] [ ] , int src ) { int colorArr [ ] = new int [ V ] ; int q [ ] = new LinkedList < Integer > ( ) ; q . add ( src ) ; while ( ! q . isEmpty ( ) ) { int u = q . peek ( ) ; if ( G [ u ] [ u ] == 1 ) return true ; for ( int v = 0 ; v < V ; v ++ ) { if ( G [ u ] [ v ] && colorArr [ v ] == - 1 ) colorArr [ v ] = 1 - colorArr [ u ] ; q . add ( v ) ; } else if ( G [ u ] [ v ] && colorArr [ v ] == colorArr [ u ] ) return true ; } return false ; }
static int countSetBits ( int n ) { if ( n == 0 ) return 0 ; else return 1 + countSetBits ( n & ( n - 1 ) ) ; }
static boolean isAnBn ( String str ) { int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( str . charAt ( i ) != ' a ' ) break ; if ( i * 2 != n ) return false ; for ( int j = i ; j < n ; j ++ ) { if ( str . charAt ( j ) != ' b ' ) return false ; } } return true ; }
static int getMinSquares ( int n ) { if ( n <= 3 ) return n ; int res = n ; for ( int x = 1 ; x <= n ; x ++ ) { int temp = x * x ; if ( temp > n ) break ; else res = Math . min ( res , 1 + getMinSquares ( n - temp ) ) ; } return res ; }
static int maxDistance ( int arr [ ] , int n ) { int maxDict = 0 ; Map < Integer , Integer > myMap = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! myMap . containsKey ( arr [ i ] ) ) myMap . put ( arr [ i ] , i ) ; else maxDict = Math . max ( maxDict , i - myMap . get ( arr [ i ] ) ) ; } return maxDict ; }
static int maxSumWO3Consec ( int arr [ ] , int n ) { int sum [ ] = new int [ n ] ; if ( n >= 1 ) sum [ 0 ] = arr [ 0 ] ; if ( n >= 2 ) sum [ 1 ] = arr [ 0 ] + arr [ 1 ] ; if ( n > 2 ) sum [ 2 ] = Math . max ( sum [ 1 ] , Math . max ( arr [ 1 ] + arr [ 2 ] , arr [ 0 ] + arr [ 2 ] ) ) ; for ( int i = 3 ; i < n ; i ++ ) sum [ i ] = Math . max ( sum [ i - 1 ] , Math . max ( sum [ i - 2 ] + arr [ i ] , arr [ i ] + arr [ i - 1 ] + sum [ i - 3 ] ) ) ; return sum [ n - 1 ] ; }
static void checkEulerFourSquareIdentity ( int a , int b ) { int ab = a * b ; boolean flag = false ; for ( int i = 0 ; i <= ab ; i ++ ) { int j = i ; while ( i * i + j * j <= ab ) { int k = j ; while ( i * i + j * j + k * k <= ab ) { int l = ( ab - ( i * i + j * j + k * k ) ) ** ( 0.5 ) ; if ( l == int . MIN_VALUE ) && l >= k ) { flag = true ; System . out . println ( " i ▁ = ▁ " + i ) ; System . out . println ( " j ▁ = ▁ " + j ) ; System . out . println ( " k ▁ = ▁ " + k ) ; System . out . println ( " l ▁ = ▁ " + l ) ; } } j ++ ; } if ( flag == false ) System . out . println ( " Solution ▁ doesn't ▁ exist ! " ) ; return ; }
public static int nobleInteger ( int arr [ ] ) { Arrays . sort ( arr ) ; int n = arr . length ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) continue ; if ( arr [ i ] == n - i - 1 ) return arr [ i ] ; } if ( arr [ n - 1 ] == 0 ) return arr [ n - 1 ] ; return - 1 ; }
static int countIslands ( char mat [ ] [ ] ) { int count = 0 ; for ( int i = 0 ; i < M ; ++ i ) { for ( int j = 0 ; j < N ; ++ j ) { if ( mat [ i ] [ j ] == ' X ' ) { if ( i == 0 || mat [ i - 1 ] [ j ] == ' O ' ) && ( j == 0 || mat [ i ] [ j - 1 ] == ' O ' ) ) count ++ ; } } } return count ; }
static int selectRandom ( int x ) { int res = 0 ; int count = 0 ; while ( count < 1 ) { count ++ ; if ( count == 1 ) res = x ; else { int i = random . nextInt ( count ) ; if ( i == count - 1 ) res = x ; } } return res ; }
static void productArray ( int arr [ ] , int n ) { if ( n == 1 ) System . out . println ( 0 ) ; return ; } int prod [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) prod [ i ] = temp ; temp *= arr [ i ] ; for ( int i = n - 1 ; i >= 0 ; i -- ) prod [ i ] *= temp ; temp *= arr [ i ] ; for ( int i = n - 1 ; i >= 0 ; i -- ) { prod [ i ] *= temp ; temp *= arr [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) System . out . print ( prod [ i ] + " ▁ " ) ; }
static boolean sortedAfterSwap ( int A [ ] , int B [ ] , int n ) { for ( int i = 0 ; i < n - 1 ; ++ i ) { if ( B [ i ] == 1 ) ++ j ; A [ 0 ] = i + sorted ( A [ i : j + 1 ] ) + A [ j + 1 : ] ; } for ( int i = 0 ; i < n ; ++ i ) if ( A [ i ] != i + 1 ) return false ; return true ; }
static int maxSubarrayXOR ( int arr [ ] , int n ) { int ans = - 2147483648 ; for ( int i = 0 ; i < n ; i ++ ) { int curr_xor = 0 ; for ( int j = i ; j < n ; j ++ ) curr_xor = curr_xor ^ arr [ j ] ; ans = Math . max ( ans , curr_xor ) ; } return ans ; }
static int cost ( int a [ ] , int n ) { return ( ( n - 1 ) * min ( a ) ) ; }
static int minRemovalsDP ( int arr [ ] , int n ) { int longest_start = - 1 , longest_end = 0 ; for ( int start = 0 ; start < n ; start ++ ) { int min = 2147483647 ; int max = 2147483647 ; for ( int end = start ; end < n ; end ++ ) { int val = arr [ end ] ; if ( val < min ) min = val ; if ( val > max ) max = val ; if ( 2 * min <= max ) break ; if ( 2 * min <= max ) break ; if ( end - start > longest_end - longest_start || longest_start == - 1 ) longest_start = start ; longest_end = end ; } } if ( longest_start == - 1 ) return n ; return ( n - ( longest_end - longest_start + 1 ) ) ; }
static int getInvCount ( int arr [ ] , int n ) { int invcount = 0 ; for ( int i = 1 ; i <= n - 2 ; i ++ ) { int small = 0 ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] > arr [ j ] ) small ++ ; } int great = 0 ; for ( int j = i - 1 ; j >= 0 ; j -- ) { if ( arr [ i ] < arr [ j ] ) great ++ ; } invcount += great * small ; } return invcount ; }
public static double surface_area_octahedron ( int side ) { return ( 2 * ( Math . sqrt ( 3 ) ) * ( side * side ) ) ; }
public static int gnomeSort ( int arr [ ] , int n ) { int index = 0 ; while ( index < n ) { if ( index == 0 ) index ++ ; if ( arr [ index ] >= arr [ index - 1 ] ) index ++ ; else { arr [ index ] = arr [ index - 1 ] ; arr [ index - 1 ] = arr [ index ] ; index = index - 1 ; } } return arr ; }
static int find ( int n , int k ) { if ( n + 1 >= k ) return ( k - 1 ) ; else return ( 2 * n + 1 - k ) ; }
static int countUnique ( int mat [ ] [ ] , int n , int m ) { int rowsum [ ] = new int [ n ] ; int colsum [ ] = new int [ m ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( mat [ i ] [ j ] != 0 ) rowsum [ i ] ++ ; colsum [ j ] ++ ; } } int uniquecount = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( mat [ i ] [ j ] != 0 && rowsum [ i ] == 1 && colsum [ j ] == 1 ) uniquecount ++ ; } } return uniquecount ; }
static void generate ( int ones , int zeroes , String str , int len1 ) { if ( len1 == str . length ( ) ) System . out . print ( str + " ▁ " ) ; return ; }
static void midPointCircleDraw ( int x_centre , int y_centre , int r ) { int x = r ; int y = 0 ; if ( r > 0 ) System . out . print ( " ( " + x + x_centre + " , ▁ " + y + y_centre + " ) " ) ; if ( r > 0 ) System . out . print ( " ( " + x + x_centre + " , ▁ " + y + y_centre + " ) " ) ; if ( r > 0 ) System . out . print ( " ( " + x + x_centre + " , ▁ " + - y + y_centre + " ) " ) ; if ( P <= 0 ) P = P + 2 * y + 1 ; else { P = P + 2 * y - 2 * x + 1 ; } if ( x < y ) break ; System . out . print ( " ( " + x + x_centre + " , ▁ " + y + y_centre + " ) " ) ; System . out . print ( " ( " + - x + x_centre + " , ▁ " + - y + y_centre + " ) " ) ; if ( x != y ) { System . out . print ( " ( " + - x + x_centre + " , ▁ " + - y + y_centre + " ) " ) ; return ; } }
static void printFactorialNums ( int n ) { int fact = 1 ; int x = 2 ; while ( fact <= n ) { System . out . print ( fact + " ▁ " ) ; fact = fact * x ; x ++ ; } }
static int countFriendsPairings ( int n ) { int [ ] dp = new int [ n + 1 ] ; dp [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i >= 1 && i <= 2 ) dp [ i ] = i ; else { dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; } } return dp [ n ] ; }
static int remainder ( char str [ ] ) { int ln = str . length ; int rem = 0 ; for ( int i = 0 ; i < ln ; i ++ ) { int num = rem * 10 + ( int ) ( str [ i ] ) ; rem = num % 11 ; } return rem ; }
static int findNth ( int n ) { int count = 0 ; for ( int curr = 0 ; curr < n ; ++ curr ) { int sum = 0 ; int x = curr ; while ( x > 0 ) { sum = sum + x % 10 ; x = x / 10 ; } if ( sum == 10 ) count ++ ; if ( count == n ) return curr ; } return - 1 ; }
static boolean sortedAfterSwap ( int A [ ] , int B [ ] , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( B [ i ] != i + 1 ) { A [ i ] = A [ i + 1 ] ; A [ i + 1 ] = A [ i ] ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( A [ i ] != i + 1 ) { return false ; } } return true ; }
static int maximumSum ( int arr [ ] , int n , int k ) { for ( int i = 1 ; i <= k ; i ++ ) { int min = Integer . MAX_VALUE ; int index = - 1 ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] < min ) min = arr [ j ] ; index = j ; } if ( min == 0 ) break ; arr [ index ] = - arr [ index ] ; } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; return sum ; }
static void printSquares ( int n ) { int square = 0 ; int odd = 1 ; for ( int x = 0 ; x < n ; x ++ ) { System . out . print ( square + " ▁ " ) ; square = square + odd ; odd = odd + 2 ; } }
static boolean checkReverse ( int arr [ ] , int n ) { if ( n == 1 ) return true ; int i , j , k ; for ( i = 1 ; i < n ; i ++ ) { if ( arr [ i - 1 ] < arr [ i ] ) { if ( i == n ) return true ; } } j = i ; while ( arr [ j ] < arr [ j - 1 ] ) { if ( i > 1 && arr [ j ] < arr [ i - 2 ] ) { return false ; } j ++ ; if ( j == n ) return true ; } k = j ; if ( arr [ k ] < arr [ i - 1 ] ) { return false ; } do { if ( arr [ k ] < arr [ k - 1 ] ) { return false ; } k ++ ; } while ( k > 1 && k < n ) { if ( arr [ k ] < arr [ k - 1 ] ) { return false ; } k ++ ; } return true ; }
static double vol_of_octahedron ( int side ) { return ( ( side * side * side ) * ( Math . sqrt ( 2 ) / 3 ) ) ; }
public static int numberOfPaths ( int m , int n ) { if ( m == 1 || n == 1 ) return 1 ; return numberOfPaths ( m - 1 , n ) + numberOfPaths ( m , n - 1 ) ; }
static int binarySearch ( int arr [ ] , int l , int r , int x ) { if ( r >= l ) { int mid = l + ( r - l ) / 2 ; if ( arr [ mid ] == x ) return mid ; else if ( arr [ mid ] > x ) return binarySearch ( arr , l , mid - 1 , x ) ; else return binarySearch ( arr , mid + 1 , r , x ) ; } else return - 1 ; }
public static int numberOfPaths ( int m , int n ) { int [ ] [ ] count = new int [ m ] [ n ] ; for ( int i = 0 ; i < m ; i ++ ) { count [ i ] [ 0 ] = 1 ; } for ( int j = 0 ; j < n ; j ++ ) count [ 0 ] [ j ] = 1 ; for ( int i = 1 ; i < m ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) { count [ i ] [ j ] = count [ i - 1 ] [ j ] + count [ i ] [ j - 1 ] ; } } return count [ m - 1 ] [ n - 1 ] ; }
static long answer ( int n ) { long [ ] [ ] dp = new long [ n + 1 ] [ 10 ] ; if ( n == 1 ) return 10 ; for ( int j = 0 ; j < 10 ; j ++ ) dp [ x ] [ j ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= 9 ; j ++ ) { if ( j == 0 ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] ; } else if ( j == 9 ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ; } else { dp [ i ] [ j ] = ( dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] ) ; } } } long sum = 0 ; for ( int j = 1 ; j <= 10 ; j ++ ) { sum = ( sum + dp [ n ] [ j ] ) ; } return sum ; }
static int maxDifference ( int arr [ ] , int N , int k ) { int S = 0 , S1 = 0 ; int max_difference = 0 ; for ( int i = 0 ; i < N ; i ++ ) S += arr [ i ] ; Arrays . sort ( arr ) ; int M = Math . max ( k , N - k ) ; for ( int i = 0 ; i < M ; i ++ ) S1 += arr [ i ] ; max_difference = S1 - ( S - S1 ) ; return max_difference ; }
static int maxSumSubarrayRemovingOneEle ( int arr [ ] , int n ) { int fw [ ] = new int [ n ] ; int bw [ ] = new int [ n ] ; int cur_max , max_so_far = arr [ 0 ] , arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { cur_max = Math . max ( arr [ i ] , cur_max + arr [ i ] ) ; max_so_far = Math . max ( max_so_far , cur_max ) ; bw [ i ] = cur_max ; } int fans = max_so_far ; for ( int i = n - 2 ; i >= 0 ; i -- ) { cur_max = Math . max ( arr [ i ] , cur_max + arr [ i ] ) ; max_so_far = Math . max ( max_so_far , cur_max ) ; bw [ i ] = cur_max ; } fans = max_so_far ; for ( int i = 1 ; i < n - 1 ; i ++ ) fans = Math . max ( fans , fw [ i - 1 ] + bw [ i + 1 ] ) ; return fans ; }
static String moveSpaceInFront ( String s ) { int i = s . length ( ) - 1 ; for ( int j = i ; j >= 0 ; j -- ) if ( s . charAt ( j ) != ' ▁ ' ) s = s . substring ( i , j + 1 ) ; while ( i >= 0 ) s = s . substring ( : i ) + ' ▁ ' + s . charAt ( i + 1 ) ; i -- ; } return s ; }
static void recaman ( int n ) { int [ ] arr = new int [ n ] ; arr [ 0 ] = 0 ; System . out . print ( arr [ 0 ] + " , ▁ " ) ; for ( int i = 1 ; i < n ; i ++ ) { int curr = arr [ i - 1 ] - i ; for ( int j = 0 ; j < i ; j ++ ) if ( ( arr [ j ] == curr ) || curr < 0 ) curr = arr [ i - 1 ] + i ; break ; arr [ i ] = curr ; System . out . print ( arr [ i ] + " , ▁ " ) ; } }
static void findMaxPoints ( int A [ ] [ ] ) { int [ ] [ ] P1S = new int [ N + 2 ] [ ] ; int [ ] [ ] P1E = new int [ N + 2 ] [ M + 2 ] ; int [ ] [ ] P2S = new int [ N + 2 ] [ M + 2 ] ; int [ ] [ ] P2E = new int [ N + 2 ] [ M + 2 ] ; for ( int i = 0 ; i < N + 1 ; i ++ ) { for ( int j = 0 ; j < M + 2 ; j ++ ) { P1S [ i ] [ j ] = Math . max ( P1S [ i - 1 ] [ j ] , P1S [ i ] [ j - 1 ] ) + A [ i - 1 ] [ j - 1 ] ; } } for ( int i = 0 ; i < N + 1 ; i ++ ) { for ( int j = 1 ; j < M + 1 ; j ++ ) { P1E [ i ] [ j ] = Math . max ( P1E [ i + 1 ] [ j ] , P1E [ i ] [ j + 1 ] ) + A [ i - 1 ] [ j - 1 ] ; } } for ( int i = 1 ; i < N + 1 ; i ++ ) { for ( int j = 0 ; j < M + 1 ; j ++ ) { P2S [ i ] [ j ] = Math . max ( P2S [ i ] [ j ] , P2S [ i ] [ j - 1 ] ) + A [ i - 1 ] [ j - 1 ] ; } } int ans = 0 ; for ( int i = 2 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { P2E [ i ] [ j ] = Math . max ( P2E [ i - 1 ] [ j ] , P2E [ i ] [ j + 1 ] ) + A [ i - 1 ] [ j - 1 ] ) + A [ i - 1 ] [ j - 1 ] ; } } ans = 0 ; } for ( int i = 2 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { P2E [ i ] [ j ] = Math . max ( P2
static int KnapSack ( int val [ ] , int wt [ ] , int n , int W ) { int [ ] [ ] mat = new int [ 2 ] [ W + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < W ; j ++ ) { if ( wt [ i ] <= j ) { mat [ 1 ] [ j ] = Math . max ( val [ i ] + mat [ 0 ] [ j - wt [ i ] ] , mat [ 0 ] [ j ] ) ; else { mat [ 1 ] [ j ] = mat [ 0 ] [ j ] ; } } } if ( i % 2 == 0 ) { for ( int j = 0 ; j < W ; j ++ ) { if ( wt [ i ] <= j ) { mat [ 0 ] [ j ] = Math . max ( val [ i ] + mat [ 1 ] [ j - wt [ i ] ] , mat [ 1 ] [ j ] ) ; } else { mat [ 0 ] [ j ] = mat [ 1 ] [ j ] ; } } } return mat [ 0 ] [ W ] ; }
static int modInverse ( int a , int m ) { a = a % m ; for ( int x = 1 ; x < m ; x ++ ) if ( ( a * x ) % m == 1 ) return x ; return 1 ; }
static int lenghtOfLongestAP ( int set [ ] , int n ) { if ( n <= 2 ) return n ; int L [ ] [ ] = new int [ n ] [ n - 1 ] ; int llap = 2 ; for ( int i = 0 ; i < n ; i ++ ) L [ i ] [ n - 1 ] = 2 ; for ( int j = n - 2 ; j >= 0 ; j -- ) { int i = j - 1 ; int k = j + 1 ; while ( i >= 0 && k <= n - 1 ) { if ( set [ i ] + set [ k ] < 2 * set [ j ] ) k ++ ; else if ( set [ i ] + set [ k ] > 2 * set [ j ] ) L [ i ] [ j ] = 2 ; i -- ; } else { L [ i ] [ j ] = L [ j ] [ k ] + 1 ; llap = Math . max ( llap , L [ i ] [ j ] ) ; i -- ; } } } return llap ; }
static int countOfBinaryNumberLessThanN ( int N ) { LinkedList < Integer > q = new LinkedList < Integer > ( ) ; q . add ( 1 ) ; int cnt = 0 ; while ( q . size ( ) > 0 ) { int t = q . peek ( ) ; if ( t <= N ) { cnt ++ ; q . add ( t * 10 ) ; q . add ( t * 10 + 1 ) ; } } return cnt ; }
static int findIndex ( int n ) { if ( n <= 1 ) return n ; int a = 0 , b = 1 , c = 1 , res = 1 ; while ( c < n ) { c = a + b ; res ++ ; a = b ; b = c ; } return res ; }
static void substringConversions ( String str , int k , int b ) { for ( int i = 0 ; i < str . length ( ) - k + 1 ; i ++ ) { String sub = str . substring ( i , k + i ) ; int sum = 0 ; int counter = 0 ; for ( int i = 0 ; i < sub . length ( ) - 1 ; i >= 0 ; i -- ) { sum = sum + ( ( sub . charAt ( i ) - '0' ) * pow ( b , counter ) ) ; counter ++ ; } System . out . print ( sum + " ▁ " ) ; } }
static int maxSumPairWithDifferenceLessThanK ( int arr [ ] , int N , int k ) { int maxSum = 0 ; Arrays . sort ( arr ) ; for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( arr [ i ] - arr [ i - 1 ] < k ) maxSum += arr [ i ] ; maxSum += arr [ i - 1 ] ; } return maxSum ; }
static String longestRepeatedSubSeq ( String str ) { int n = str . length ( ) ; int dp [ ] [ ] = new int [ n + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( str . charAt ( i - 1 ) == str . charAt ( j - 1 ) && i != j ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = Math . max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ; } } String res = " " ; int i = n , j = n ; while ( i > 0 && j > 0 ) { if ( dp [ i ] [ j ] == dp [ i - 1 ] [ j - 1 ] + 1 ) res += str . charAt ( i - 1 ) ; i -- ; j -- ; } else if ( dp [ i ] [ j ] == dp [ i - 1 ] [ j ] ) i -- ; else j -- ; } res = " " ; return res ; }
static boolean isHeap ( int arr [ ] , int n ) { for ( int i = 0 ; i <= ( n - 2 ) / 2 ; i ++ ) { if ( arr [ 2 * i + 1 ] > arr [ i ] ) return false ; if ( 2 * i + 2 < n && arr [ 2 * i + 2 ] > arr [ i ] ) return false ; } return true ; }
static int calculateEnergy ( int mat [ ] [ ] , int n ) { int tot_energy = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { int q = mat [ i ] [ j ] / n ; int i_des = q ; int j_des = mat [ i ] [ j ] - ( n * q ) ; tot_energy += Math . abs ( i_des - i ) + Math . abs ( j_des - j ) ; } } return tot_energy ; }
static void rearrange ( int [ ] a , int size ) { int positive = 0 , negative = 1 ; while ( true ) { while ( positive < size && a [ positive ] >= 0 ) ++ positive ; while ( negative < size && a [ negative ] <= 0 ) ++ negative ; if ( positive < size && negative < size ) { int temp = a [ positive ] ; a [ positive ] = a [ negative ] ; a [ negative ] = temp ; } else break ; } }
static void antiSpiralTraversal ( int m , int n , int a [ ] [ ] ) { int i , k = 0 , l = 0 ; Vector < Integer > stk = new Vector < > ( ) ; while ( k <= m && l <= n ) { for ( i = l ; i <= n ; i ++ ) { stk . add ( a [ k ] [ i ] ) ; k ++ ; } for ( i = k ; i <= m ; i ++ ) { stk . add ( a [ i ] [ n ] ) ; n -- ; if ( k <= m ) { for ( i = n ; i <= l - 1 ; i -- ) { stk . add ( a [ m ] [ i ] ) ; } m -- ; } if ( l <= n ) { for ( i = m ; i >= k ; i -- ) { stk . add ( a [ i ] [ l ] ) ; l ++ ; } } while ( stk . size ( ) != 0 ) System . out . print ( str ( stk . peek ( ) + " ▁ " ) ; stk . pop ( ) ; } }
static void maxProduct ( int arr [ ] , int n ) { if ( n < 2 ) System . out . println ( " No ▁ pairs ▁ exists " ) ; if ( n == 2 ) System . out . println ( arr [ 0 ] + " ▁ " + arr [ 1 ] ) ; return ; int posa = 0 , posb = 0 , nega = 0 , negb = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > posa ) { posb = posa ; posa = arr [ i ] ; } else if ( arr [ i ] > posb ) { posb = posb ; posb = arr [ i ] ; } if ( arr [ i ] < 0 && Math . abs ( arr [ i ] ) > Math . abs ( nega ) ) { nega = nega ; nega = arr [ i ] ; } else if ( arr [ i ] < 0 && Math . abs ( arr [ i ] ) > Math . abs ( negb ) ) { negb = negb ; } } if ( nega * negb > posa * posb ) { System . out . println ( " Max ▁ product ▁ pair ▁ is ▁ " + nega + " \n " ) ; } else { System . out . println ( " Max ▁ product ▁ pair ▁ is ▁ " + posa + " \n " ) ; } }
static int findMaxVal ( int arr [ ] , int n , int num , int maxLimit ) { int ind = - 1 , val = - 1 ; int dp [ ] [ ] = new int [ n ] [ maxLimit + 1 ] ; for ( int [ ] rows : dp ) Arrays . fill ( rows , 0 ) ; for ( int ind = 0 ; ind < n ; ind ++ ) { for ( int val = 0 ; val <= maxLimit ; val ++ ) { if ( num - arr [ ind ] == val || num + arr [ ind ] == val ) dp [ ind ] [ val ] = 1 ; else dp [ ind ] [ val ] = 0 ; } } for ( int val = 0 ; val <= maxLimit ; val ++ ) { if ( val - arr [ ind ] >= 0 && val + arr [ ind ] <= maxLimit ) { if ( dp [ ind - 1 ] [ val - arr [ ind ] ] == 1 || dp [ ind - 1 ] [ val + arr [ ind ] ] == 1 ) dp [ ind ] [ val ] = 1 ; else if ( val + arr [ ind ] <= maxLimit ) dp [ ind ] [ val ] = dp [ ind - 1 ] [ val + arr [ ind ] ] ; else { dp [ ind ] [ val ] = 0 ; } } } for ( int val = maxLimit ; val >= 0 ; val -- ) { if ( dp [ n - 1 ] [ val ] == 1 ) return val ; } return - 1 ; }
static int Resources ( int process , int need ) { int minResources = 0 ; minResources = process * ( need - 1 ) + 1 ; return minResources ; }
public static void bubbleSort ( int arr [ ] , int n ) { int copy [ ] = Arrays . copyOf ( arr , arr . length ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n - i - 1 ; j ++ ) { if ( arr [ j ] > arr [ j + 1 ] ) { copy [ j ] , arr [ j + 1 ] = copy [ j ] ; } } } }
static int superSeq ( int X [ ] , int Y [ ] , int m , int n ) { int [ ] [ ] dp = new int [ m + 2 ] [ n + 2 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( ! i ) dp [ i ] [ j ] = j ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = 1 + Math . min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) ; } } return dp [ m ] [ n ] ; }
static int countIntegralSolutions ( int n ) { int result = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { for ( int k = 0 ; k <= n ; k ++ ) { if ( i + j + k == n ) result ++ ; } } } return result ; }
static int minJumps ( int arr [ ] , int n ) { int [ ] jumps = new int [ n ] ; for ( int i = 0 ; i < n - 2 ; i ++ ) { if ( arr [ i ] == 0 ) jumps [ i ] = float ( ' inf ' ) ; else if ( arr [ i ] >= n - i - 1 ) jumps [ i ] = 1 ; else { int min = Integer . MAX_VALUE ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( j <= arr [ i ] + i ) { if ( min > jumps [ j ] ) min = jumps [ j ] ; } } if ( min != Integer . MAX_VALUE ) jumps [ i ] = min + 1 ; else jumps [ i ] = min ; } } return jumps [ 0 ] ; }
static int minAdjustmentCost ( int A [ ] , int n , int target ) { int dp [ ] [ ] = new int [ M + 1 ] [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j <= M ; j ++ ) { dp [ i ] [ j ] = Math . abs ( j - A [ 0 ] ) ; } } for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j <= M ; j ++ ) { dp [ i ] [ j ] = Math . min ( dp [ i ] [ j ] , dp [ i - 1 ] [ k ] + Math . abs ( A [ i ] - j ) ) ; } } int res = Integer . MAX_VALUE ; for ( int j = 0 ; j <= M ; j ++ ) res = Math . min ( res , dp [ n - 1 ] [ j ] ) ; return res ; }
public static int kthSmallest ( int arr [ ] , int n , int k ) { Arrays . sort ( arr ) ; return arr [ k - 1 ] ; }
static int minCost ( int cost [ ] [ ] ) { int dist [ ] = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) dist [ i ] = INF ; dist [ 0 ] = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) if ( dist [ j ] > dist [ i ] + cost [ i ] [ j ] ) dist [ j ] = dist [ i ] + cost [ i ] [ j ] ; } return dist [ N - 1 ] ; }
static String reversingString ( String str , int start , int end ) { while ( start < end ) { str = ( str [ : start ] + ( char ) ( str [ start ] ) ^ ( char ) str [ end ] ) + str [ start + 1 : ] ) ; str = ( str [ : end ] + ( char ) ( str [ start ] ) ^ ( char ) str [ end ] ) + str [ end + 1 : ] ) ; str = ( str [ : start ] + ( char ) ( str [ start ] ) ^ ord ( str [ end ] ) ) + str [ start + 1 : ] ) ; start ++ ; end -- ; } return str ; }
static int minimalSteps ( String s , int n ) { int [ ] dp = new int [ n ] ; String s1 = " " , s2 = " " ; dp [ 0 ] = 1 ; s1 += s [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { s1 += s [ i ] ; s2 = s [ i + 1 : i + 1 + i + 1 ] ; dp [ i ] = Math . min ( dp [ i ] , dp [ i - 1 ] + 1 ) ; if ( s1 == s2 ) { dp [ i * 2 + 1 ] = Math . min ( dp [ i ] + 1 , dp [ i * 2 + 1 ] ) ; } } return dp [ n - 1 ] ; }
static int MinimumCost ( int cost [ ] , int n , int W ) { List < Integer > val = new ArrayList < Integer > ( ) ; List < Integer > wt = new ArrayList < Integer > ( ) ; int size = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( cost [ i ] != - 1 ) { val . add ( cost [ i ] ) ; wt . add ( i + 1 ) ; size ++ ; } } int min_cost [ ] [ ] = new int [ W + 1 ] [ n + 1 ] ; for ( int i = 0 ; i < W + 1 ; i ++ ) { min_cost [ 0 ] [ i ] = INF ; } for ( int i = 1 ; i < n + 1 ; i ++ ) { min_cost [ i ] [ 0 ] = 0 ; } for ( int i = 1 ; i < n + 1 ; i ++ ) { for ( int j = 1 ; j < W + 1 ; j ++ ) { if ( wt [ i - 1 ] > j ) min_cost [ i ] [ j ] = Math . min ( min_cost [ i - 1 ] [ j ] , min_cost [ i ] [ j - wt [ i - 1 ] ] + val [ i - 1 ] ) ; } } if ( min_cost [ n ] [ W ] == INF ) return - 1 ; else return min_cost [ n ] [ W ] ; }
static void bitonicGenerator ( int arr [ ] , int n ) { int [ ] evenArr = new int [ n ] ; int [ ] oddArr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( i % 2 ) == 0 ) ++ evenArr . add ( arr [ i ] ) ; else ++ oddArr . add ( arr [ i ] ) ; } Arrays . sort ( evenArr ) ; Arrays . sort ( oddArr ) ; int i = 0 ; for ( int j = 0 ; j < evenArr . length ; j ++ ) arr [ i ] = evenArr [ j ] ; i ++ ; for ( int j = 0 ; j < oddArr . length ; j ++ ) arr [ i ] = oddArr [ j ] ; i ++ ; } for ( int j = 0 ; j < evenArr . length ; j ++ ) arr [ i ] = evenArr [ j ] ; i ++ ; }
static int countDivisibles ( int arr [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] % arr [ j ] == 0 || arr [ j ] % arr [ i ] == 0 ) res ++ ; } return res ; }
static int lis ( int arr [ ] ) { int n = arr . length ; int maximum = 1 ; _lis ( arr , 0 ) ; return maximum ; }
static void printFirstRepeating ( int arr [ ] , int n ) { int Min = - 1 ; Map < Integer , Integer > myset = new HashMap < Integer , Integer > ( ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( myset . containsKey ( arr [ i ] ) ) { Min = i ; } else { myset . put ( arr [ i ] , 1 ) ; } } if ( Min != - 1 ) System . out . println ( " The ▁ first ▁ repeating ▁ element ▁ is ▁ " + arr [ Min ] ) ; else System . out . println ( " There ▁ are ▁ no ▁ repeating ▁ elements " ) ; }
static int minCoins ( int coins [ ] , int m , int V ) { if ( V == 0 ) return 0 ; int res = Integer . MAX_VALUE ; for ( int i = 0 ; i < m ; i ++ ) { if ( coins [ i ] <= V ) { int sub_res = minCoins ( coins , m , V - coins [ i ] ) ; if ( sub_res != Integer . MAX_VALUE && sub_res + 1 < res ) res = sub_res + 1 ; } } return res ; }
static void pairSum ( int mat [ ] [ ] , int n , int sum ) { for ( int i = 0 ; i < n ; i ++ ) { Arrays . sort ( mat [ i ] ) ; } for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int left = 0 , right = n - 1 ; while ( left < n && right >= 0 ) { if ( ( mat [ i ] [ left ] + mat [ j ] [ right ] ) == sum ) { System . out . print ( " ( ▁ " + mat [ i ] [ left ] + " , ▁ " + mat [ j ] [ right ] + " ) , ▁ " ) ; left ++ ; right -- ; } else { if ( ( mat [ i ] [ left ] + mat [ j ] [ right ] ) < sum ) left ++ ; else right -- ; } } } }
static int minimum_cost ( int a [ ] , int n ) { int mn = 2147483647 ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { mn = Math . min ( a [ i ] , mn ) ; sum += a [ i ] ; } return mn * ( sum - mn ) ; }
static int lps ( String str ) { int n = str . length ( ) ; int [ ] [ ] L = new int [ n ] [ n ] ; int i , j , k , L [ ] [ ] = new int [ n ] [ n ] ; for ( i = 0 ; i < n ; i ++ ) L [ i ] [ i ] = 1 ; for ( cl = 2 ; cl <= n ; cl ++ ) { for ( i = 0 ; i < n - cl + 1 ; i ++ ) { j = i + cl - 1 ; if ( str . charAt ( i ) == str . charAt ( j ) && cl == 2 ) L [ i ] [ j ] = 2 ; else if ( str . charAt ( i ) == str . charAt ( j ) ) L [ i ] [ j ] = L [ i + 1 ] [ j - 1 ] + 2 ; else L [ i ] [ j ] = Math . max ( L [ i ] [ j - 1 ] , L [ i + 1 ] [ j ] ) ; } } return L [ 0 ] [ n - 1 ] ; }
static String censor ( String text , String word ) { List < Character > word_list = text . split ( ) ; String stars = " * " ; int count = 0 ; int index = 0 ; for ( Character i = 0 ; i < word_list . size ( ) ; i ++ ) { if ( i == word ) word_list [ index ] = stars ; count ++ ; } result = ' ▁ ' . join ( word_list ) ; return result ; }
static boolean isPowerOfFour ( int n ) { if ( n == 0 ) return false ; while ( n != 1 ) { if ( n % 4 != 0 ) return false ; n = n / 4 ; } return true ; }
static double getArea ( int a ) { double area = ( Math . pi * a * a ) / 4 ; return area ; }
static int distancesum ( int x [ ] , int y [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) sum += Math . abs ( x [ i ] - x [ j ] ) + Math . abs ( y [ i ] - y [ j ] ) ; } return sum ; }
static void findMax ( int arr [ ] [ ] ) { int row = 0 , j = N - 1 ; for ( int i = 0 ; i < N ; i ++ ) { while ( arr [ i ] [ j ] == 1 && j >= 0 ) row = i ; j -- ; } System . out . println ( " Row ▁ number ▁ = ▁ " + row + 1 + " , ▁ MaxCount ▁ = ▁ " + N - 1 - j ) ; }
static int lastNon0Digit ( int n ) { if ( n < 10 ) return dig [ n ] ; if ( ( ( n / 10 ) % 10 ) % 2 == 0 ) return 6 * lastNon0Digit ( n / 5 ) * dig [ n % 10 ] ) % 10 ; else return 4 * lastNon0Digit ( n / 5 ) * dig [ n % 10 ] ; }
static int evenFibSum ( int limit ) { if ( limit < 2 ) return 0 ; int ef1 = 0 , ef2 = 2 ; int sm = ef1 + ef2 ; while ( ef2 <= limit ) { int ef3 = 4 * ef2 + ef1 ; if ( ef3 > limit ) break ; ef1 = ef2 ; ef2 = ef3 ; sm = sm + ef2 ; } return sm ; }
static int search ( int arr [ ] , int n , int x ) { int i = 0 ; while ( i < n ) { if ( arr [ i ] == x ) return i ; i = i + Math . abs ( arr [ i ] - x ) ; } System . out . println ( " number ▁ is ▁ not ▁ present ! " ) ; return - 1 ; }
static boolean isRotated ( String str1 , String str2 ) { if ( str1 . length ( ) != str2 . length ( ) ) return false ; String clock_rot = " " , anticlock_rot = " " ; int l = str2 . length ( ) ; anticlock_rot = ( anticlock_rot + str2 . charAt ( l - 2 ) + str2 . charAt ( 0 : l - 2 ) ) ; clock_rot = clock_rot + str2 . charAt ( 2 : ] + str2 . charAt ( 0 : 2 ) ) ; return ( str1 == clock_rot || str1 == anticlock_rot ) ; }
static void printHosoya ( int n ) { int [ ] [ ] dp = new int [ N ] [ N ] ; Arrays . fill ( dp , 0 ) [ 0 ] = dp [ 0 ] [ 1 ] = 1 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i > j ) { dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] + dp [ i - 2 ] [ j ] ) ; } else { dp [ i ] [ j ] = ( dp [ i - 1 ] [ j - 1 ] + dp [ i - 2 ] [ j - 2 ] ) ; } } } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j <= i ; j ++ ) System . out . print ( dp [ i ] [ j ] + " ▁ " ) ; } System . out . println ( ) ; } }
static int findSubArray ( int arr [ ] , int n ) { int sum = 0 ; int maxsize = - 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { sum = sum - ( arr [ i ] == 0 ) ? 1 : sum + 1 ; for ( int j = i + 1 ; j < n ; j ++ ) { sum = sum + ( arr [ j ] == 0 ) ? sum + 1 : sum + 1 ; if ( sum == 0 && maxsize < j - i + 1 ) maxsize = j - i + 1 ; startindex = i ; } } if ( maxsize == - 1 ) System . out . println ( " No ▁ such ▁ subarray " ) ; else System . out . println ( startindex + " to ▁ " + startindex + maxsize - 1 ) ; return maxsize ; }
static void insertionSortRecursive ( int arr [ ] , int n ) { if ( n <= 1 ) return ; insertionSortRecursive ( arr , n - 1 ) ; int j , last = arr [ n - 1 ] ; for ( j = n - 2 ; j >= 0 && arr [ j ] > last ; j -- ) arr [ j + 1 ] = arr [ j ] ; arr [ j + 1 ] = last ; }
static int findDiff ( int arr [ ] , int n ) { Map < Integer , Integer > myMap = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) myMap . put ( arr [ i ] , myMap . get ( arr [ i ] ) + 1 ) ; int max_count = 0 , min_count = n ; for ( int key = 0 ; key < myMap . keySet ( ) ; key ++ ) { max_count = Math . max ( max_count , values ) ; min_count = Math . min ( min_count , values ) ; } return max_count - min_count ; }
static int playGame ( int arr [ ] , int n ) { HashSet < Integer > s = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { s . add ( arr [ i ] ) ; } return 1 if ( s . size ( ) % 2 == 0 ) return 2 ; }
static int subset ( int arr [ ] , int n ) { Map < Integer , Integer > myMap = new HashMap < > ( ) ; for ( int i = 0 ; i < 10 ; i ++ ) myMap . put ( arr [ i ] , myMap . get ( arr [ i ] ) + 1 ) ; int res = 0 ; for ( int key = 0 ; key < myMap . size ( ) ; key ++ ) res = Math . max ( res , value ) ; return res ; }
boolean isProduct ( int arr [ ] , int n , int x ) { if ( n < 2 ) return false ; HashSet < Integer > s = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) { if ( x == 0 ) return true ; else continue ; } if ( x % arr [ i ] == 0 ) { if ( x / arr [ i ] == 0 ) { if ( s . contains ( arr [ i ] ) ) return true ; s . add ( arr [ i ] ) ; } } return false ; }
static int largestSumOfAverages ( int A [ ] , int K ) { int n = A . length ; int pre_sum [ ] = new int [ n + 1 ] ; pre_sum [ 0 ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { pre_sum [ i + 1 ] = pre_sum [ i ] + A [ i ] ; } int dp [ ] = new int [ n ] ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] = ( pre_sum [ n ] - pre_sum [ i ] ) / ( n - i ) + dp [ i ] ; } for ( int k = 0 ; k <= K - 2 ; k ++ ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { dp [ i ] = Math . max ( dp [ i ] , ( pre_sum [ j ] - pre_sum [ i ] ) / ( j - i ) + dp [ j ] ) ; } } } return dp [ 0 ] ; }
static int getMinSteps ( int n ) { int table [ ] = new int [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) table [ i ] = n - i ; for ( int i = 0 ; i <= n ; i ++ ) { if ( ! ( i % 2 ) ) table [ i / 2 ] = Math . min ( table [ i ] + 1 , table [ i / 2 ] ) ; if ( ! ( i % 3 ) ) table [ i / 3 ] = Math . min ( table [ i ] + 1 , table [ i / 3 ] ) ; } return table [ 1 ] ; }
static int nthTerm ( int n ) { return ( n * n ) + ( n * n * n ) ; }
static int findMaxAverage ( int arr [ ] , int n , int k ) { if ( k > n ) return - 1 ; int sum = arr [ 0 ] ; for ( int i = 1 ; i < k ; i ++ ) sum += arr [ i ] ; int max_sum = sum ; int max_end = k - 1 ; for ( int i = k ; i < n ; i ++ ) { sum = sum + arr [ i ] - arr [ i - k ] ; if ( sum > max_sum ) { max_sum = sum ; max_end = i ; } } return max_end - k + 1 ; }
static int eggDrop ( int n , int k ) { if ( k == 1 || k == 0 ) return k ; if ( n == 1 ) return k ; int min = 2147483647 ; for ( int x = 1 ; x <= k ; x ++ ) { int res = Math . max ( eggDrop ( n - 1 , x - 1 ) , eggDrop ( n , k - x ) ) ; if ( res < min ) min = res ; } return min + 1 ; }
static int count ( String s , char c ) { int res = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) if ( s . charAt ( i ) == c ) res ++ ; return res ; }
static int findRotations ( String str ) { String tmp = " " ; int n = str . length ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { String substring = tmp . substring ( i , n ) ; if ( str == substring ) return i ; } return n ; }
static int randomize ( int arr [ ] , int n ) { for ( int i = n - 1 ; i >= 0 ; i -- ) { int j = random . nextInt ( 0 , i + 1 ) ; arr [ i ] = arr [ j ] ; arr [ j ] = arr [ i ] ; } return arr ; }
static int findLength ( String str , int n ) { int sum [ ] = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) sum [ i ] = ( sum [ i - 1 ] + ( str . charAt ( i - 1 ) ) ) ; int ans = 0 ; for ( int length = 2 ; length <= n ; length ++ ) { for ( int i = 0 ; i <= n - length ; i ++ ) { int j = i + length - 1 ; if ( sum [ i + length / 2 ] - sum [ i ] == sum [ i + length ] - sum [ i + length / 2 ] ) ans = Math . max ( ans , length ) ; } } return ans ; }
static void translate ( char str [ ] ) { int l = str . length ; if ( l < 2 ) return ; int i = 0 , j = 0 ; while ( j < l - 1 ) { if ( str [ j ] == ' A ' && str [ j + 1 ] == ' B ' ) { j ++ ; continue ; } str [ i ] = str [ j ] ; i ++ ; j ++ ; } if ( j == l - 1 ) { str [ i ] = str [ j ] ; i ++ ; } str [ i ] = ' ▁ ' ; str [ l - 1 ] = ' ▁ ' ; } else { str [ i ] = ' ▁ ' ; str [ l - 1 ] = ' ▁ ' ; } }
static int maximumNumberDistinctPrimeRange ( int m , int n ) { int [ ] factorCount = new int [ n + 1 ] ; boolean [ ] prime = new boolean [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { factorCount [ i ] = 0 ; prime [ i ] = true ; } for ( int i = 2 ; i <= n ; i ++ ) { if ( prime [ i ] == true ) factorCount [ i ] = 1 ; for ( int j = i * 2 ; j <= n + 1 ; j ++ ) factorCount [ j ] ++ ; prime [ j ] = false ; } } int max = factorCount [ m ] ; int num = m ; for ( int i = m ; i <= n ; i ++ ) { if ( factorCount [ i ] > max ) { max = factorCount [ i ] ; num = i ; } } return num ; }
static int catalan ( int n ) { if ( n <= 1 ) return 1 ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) res += catalan ( i ) * catalan ( n - i - 1 ) ; return res ; }
static long sumOfSeries ( int n ) { long sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { sum = sum + ( 2 * i - 1 ) * ( 2 * i - 1 ) ; } return sum ; }
static double minRevolutions ( int r , int x1 , int y1 , int x2 , int y2 ) { double d = Math . sqrt ( ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ) ; return Math . ceil ( d / ( 2 * r ) ) ; }
static void printString ( String str , char ch , int count ) { int occ , i ; if ( count == 0 ) System . out . println ( str ) ; else { occ = 0 ; for ( i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) == ch ) { occ ++ ; if ( occ == count ) break ; } } if ( i < str . length ( ) - 1 ) System . out . println ( str . charAt ( i + 1 ) + " ▁ " ) ; else System . out . println ( " Empty ▁ string " ) ; }
static int largestKSubmatrix ( int a [ ] [ ] ) { int dp [ ] [ ] = new int [ Row ] [ Col ] ; int result = 0 ; for ( int i = 0 ; i < Row ; i ++ ) { for ( int j = 0 ; j < Col ; j ++ ) { if ( i == 0 || j == 0 ) { dp [ i ] [ j ] = 1 ; } else { if ( a [ i ] [ j ] == a [ i - 1 ] [ j ] && a [ i ] [ j ] == a [ i ] [ j - 1 ] && a [ i ] [ j ] == a [ i - 1 ] [ j - 1 ] ) { dp [ i ] [ j ] = Math . min ( Math . min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) , dp [ i - 1 ] [ j - 1 ] ) + 1 ; } else { dp [ i ] [ j ] = 1 ; } } } result = Math . max ( result , dp [ i ] [ j ] ) ; } return result ; }
static void printPascal ( int n ) { int [ ] [ ] arr = new int [ n ] [ n ] ; int line , i ; for ( line = 0 ; line < n ; line ++ ) { for ( i = 0 ; i <= line ; i ++ ) { if ( i == 0 || i is line ) arr [ line ] [ i ] = 1 ; else arr [ line ] [ i ] = ( arr [ line - 1 ] [ i - 1 ] + arr [ line - 1 ] [ i ] ) ; System . out . print ( arr [ line ] [ i ] + " ▁ " ) ; } System . out . println ( ) ; } }
static int answer_query ( int a [ ] , int n , int l , int r ) { int count = 0 ; for ( int i = l ; i < r ; i += 2 ) if ( a [ i ] == a [ i + 1 ] ) count ++ ; return count ; }
static int cassini ( int n ) { return ( n & 1 ) ? - 1 : 1 ; }
static int compute_average ( int a , int b ) { return ( a + b ) / 2 ; }
static int waysToArrange ( int N , int K , int k ) { int [ ] [ ] C = new int [ N + 1 ] [ N + 1 ] ; for ( int i = 0 ; i <= N ; i ++ ) { for ( int j = 0 ; j <= i ; j ++ ) { if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) ; } } int dp [ ] = new int [ K + 1 ] ; for ( int i = 0 ; i <= K ; i ++ ) { dp [ i + 1 ] = dp [ i ] * C [ count + k [ i ] - 1 ] [ k [ i ] - 1 ] ; count += k [ i ] ; } return dp [ K ] ; }
static void findDimen ( int H , int A ) { if ( H * H < 4 * A ) { System . out . println ( " Not ▁ Possible " ) ; return ; } double apb = sqrt ( H * H + 4 * A ) ; double asb = sqrt ( H * H - 4 * A ) ; System . out . println ( " P ▁ = ▁ " + " % .2f " + ( apb - asb ) / 2.0 ) ; System . out . println ( " B ▁ = ▁ " + " % .2f " + ( ( apb + asb ) / 2.0 ) ) ; }
static int maxTripletSum ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; return ( arr [ n - 1 ] + arr [ n - 2 ] + arr [ n - 3 ] ) ; }
static int MaxDotProduct ( int A [ ] [ ] , int B [ ] , int m , int n ) { int [ ] [ ] dp = new int [ n + 1 ] [ m + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = i ; j <= m ; j ++ ) dp [ i ] [ j ] = Math . max ( ( dp [ i - 1 ] [ j - 1 ] + ( A [ j - 1 ] * B [ i - 1 ] ) ) , dp [ i ] [ j - 1 ] ) ; } return dp [ n ] [ m ] ; }
static int findMinDiff ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int diff = Integer . MAX_VALUE ; for ( int i = 0 ; i <= n - 2 ; i ++ ) { if ( arr [ i + 1 ] - arr [ i ] < diff ) diff = arr [ i + 1 ] - arr [ i ] ; } return diff ; }
static int findLastIndex ( String str , char x ) { for ( int i = str . length ( ) - 1 ; i >= 0 ; i -- ) if ( str . charAt ( i ) == x ) return i ; return - 1 ; }
static int maxLower ( String str ) { int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( str . charAt ( i ) >= ' A ' && str . charAt ( i ) <= ' Z ' ) { i ++ ; break ; } } int maxCount = 0 ; int [ ] count = new int [ MAX_CHAR ] ; for ( int j = 0 ; j < MAX_CHAR ; j ++ ) { if ( str . charAt ( j ) >= ' A ' && str . charAt ( j ) <= ' Z ' ) { count . add ( 0 ) ; } for ( int k = 0 ; k < MAX_CHAR ; k ++ ) { if ( count . containsKey ( k ) ) { currCount ++ ; } } maxCount = Math . max ( maxCount , currCount ) ; for ( int y = 0 ; y < count . size ( ) ; y ++ ) { if ( str . charAt ( j ) >= ' a ' && str . charAt ( j ) <= ' z ' ) count . add ( ( int ) str . charAt ( j ) - ' a ' ) ] ++ ; } } return maxCount ; }
static void findElements ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) if ( arr [ j ] > arr [ i ] ) count ++ ; if ( count >= 2 ) System . out . print ( arr [ i ] + " ▁ " ) ; } }
static String evenlength ( String n ) { String res = "" ; for ( int j = n . length ( ) - 1 ; j >= 0 ; j -- ) res += n . charAt ( j ) ; return res ; }
static int maxLen ( int arr [ ] , int n ) { int cur_sum = 0 ; int max_len = 0 ; int ending_index = - 1 ; HashMap < Integer , Integer > hash_map = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) arr [ i ] = - 1 ; else arr [ i ] = 1 ; } for ( int i = 0 ; i < n ; i ++ ) { cur_sum = cur_sum + arr [ i ] ; if ( cur_sum == 0 ) { max_len = i + 1 ; ending_index = i ; } else { hash_map . put ( cur_sum , i ) ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == - 1 ) arr [ i ] = 0 ; else arr [ i ] = 1 ; } } System . out . print ( ending_index - max_len + " ▁ " ) ; System . out . print ( " to ▁ " ) ; return max_len ; }
static int possibleStrings ( int n , int r , int b , int g ) { int fact [ ] = new int [ n + 1 ] ; fact [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) fact [ i ] = fact [ i - 1 ] * i ; int left = n - ( r + g + b ) ; int sum = 0 ; for ( int i = 0 ; i <= left ; i ++ ) { for ( int j = 0 ; j <= left - i ; j ++ ) { int k = left - ( i + j ) ; sum = ( sum + fact [ n ] / ( fact [ i + r ] * fact [ j + b ] * fact [ k + g ] ) ) ; } } return sum ; }
static int numberofways ( int A [ ] , int B [ ] , int N , int M ) { int [ ] [ ] pos = new int [ MAX ] [ M ] ; for ( int i = 0 ; i < M ; i ++ ) { pos [ B [ i ] ] . add ( i + 1 ) ; } int dpl [ ] [ ] = new int [ N + 2 ] ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 1 ; j <= M ; j ++ ) { if ( A [ i - 1 ] == B [ j - 1 ] ) dpl [ i ] [ j ] = dpl [ i - 1 ] [ j - 1 ] + 1 ; else dpl [ i ] [ j ] = Math . max ( dpl [ i - 1 ] [ j ] , dpl [ i ] [ j - 1 ] ) ; } } int LCS = dpl [ N ] [ M ] ; int dpr [ ] [ ] = new int [ N + 1 ] [ M ] ; for ( int i = 0 ; i <= N ; i ++ ) { for ( int j = M ; j >= 0 ; j -- ) { if ( A [ i - 1 ] == B [ j - 1 ] ) dpr [ i ] [ j ] = dpr [ i + 1 ] [ j + 1 ] + 1 ; else dpr [ i ] [ j ] = Math . max ( dpr [ i + 1 ] [ j ] , dpr [ i ] [ j + 1 ] ) ; } } int ans = 0 ; for ( int i = 0 ; i <= N ; i ++ ) { for ( int j = 0 ; j <= MAX ; j ++ ) { if ( dpl [ i ] [ x - 1 ] + dpr [ i + 1 ] [ x + 1 ] == LCS ) ans ++ ; break ; } } return ans ; }
static double circumference ( int r ) { return ( 2 * PI * r ) ; }
static void substringConversions ( String s , int k , int b ) { int l = s . length ( ) ; for ( int i = 0 ; i < l ; i ++ ) { if ( ( i + k ) < l + 1 ) { String sub = s . substring ( i , i + k ) ; int sum = 0 ; int counter = 0 ; for ( int i = 0 ; i < sub . length ( ) - 1 ; i >= 0 ; i -- ) { sum += ( ( sub . charAt ( i ) - '0' ) * pow ( b , counter ) ) ; counter ++ ; } System . out . print ( sum + " ▁ " ) ; } }
static int maxPathSum ( int tri [ ] [ ] , int m , int n ) { for ( int i = m - 1 ; i >= 0 ; i -- ) { for ( int j = i ; j <= n - 1 ; j ++ ) { if ( tri [ i + 1 ] [ j ] > tri [ i + 1 ] [ j + 1 ] ) tri [ i ] [ j ] += tri [ i + 1 ] [ j ] ; else tri [ i ] [ j ] += tri [ i + 1 ] [ j + 1 ] ; } } return tri [ 0 ] [ 0 ] ; }
static int sumOfKsubArray ( int arr [ ] , int n , int k ) { int sum = 0 ; Stack < Integer > S = new Stack < > ( ) ; Stack < Integer > G = new Stack < > ( ) ; for ( int i = 0 ; i < k ; i ++ ) { while ( S . size ( ) > 0 && arr [ S . peek ( ) ] >= arr [ i ] ) S . pop ( ) ; while ( G . size ( ) > 0 && arr [ G . peek ( ) <= arr [ i ] ) G . pop ( ) ; S . push ( i ) ; } for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ S [ 0 ] ] + arr [ G [ 0 ] ] ; while ( S . size ( ) > 0 && S . peek ( ) <= i - k ) { S . pop ( ) ; } while ( G . size ( ) > 0 && G . peek ( ) <= arr [ i ] ) { G . pop ( ) ; } S . push ( i ) ; } sum += arr [ S [ 0 ] ] + arr [ G [ 0 ] ] ; return sum ; }
static int fun ( int n ) { return n & ( n - 1 ) ; }
static int mirrorImage ( int a , int b , int c , int x1 , int y1 ) { int temp = ( a * x1 + b * y1 + c ) / ( a * a + b * b ) ; int x = temp * a + x1 ; int y = temp * b + y1 ; return ( x , y ) ; }
static void printDistinct ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i < n - 1 && arr [ i ] == arr [ i + 1 ] ) i ++ ; else System . out . print ( arr [ i ] + " ▁ " ) ; } }
static int printIntersection ( int arr1 [ ] , int arr2 [ ] , int m , int n ) { int i = 0 , j = 0 ; while ( i < m && j < n ) { if ( arr1 [ i ] < arr2 [ j ] ) i ++ ; else if ( arr2 [ j ] < arr1 [ i ] ) j ++ ; else System . out . print ( arr2 [ j ++ ] + " ▁ " ) ; } }
static int search ( int arr [ ] , int n , int x , int k ) { int i ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == x ) return i ; } System . out . println ( " number ▁ is ▁ not ▁ present ! " ) ; return - 1 ; }
static String arrangeString ( String str ) { int [ ] char_count = new int [ MAX_CHAR ] ; int s = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) >= ' A ' && str . charAt ( i ) <= ' Z ' ) char_count [ str . charAt ( i ) - ' A ' ] ++ ; else s += str . charAt ( i ) - '0' ; } String res = " " ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { char ch = ( char ) ( " A " + i ) ; while ( char_count [ i ] ) res += ch ; char_count [ i ] -- ; } if ( s > 0 ) res += String . valueOf ( s ) ; return res ; }
static int countStrings ( int n ) { int [ ] a = new int [ n ] ; int [ ] b = new int [ n ] ; a [ 0 ] = b [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) a [ i ] = a [ i - 1 ] + b [ i - 1 ] ; b [ i ] = a [ i - 1 ] ; for ( int i = 1 ; i < n ; i ++ ) { a [ i ] = a [ i - 1 ] + b [ i - 1 ] ; b [ i ] = a [ i - 1 ] ; } return a [ n - 1 ] + b [ n - 1 ] ; }
static int minSum ( int arr [ ] , int n ) { int dp [ ] = new int [ n ] ; if ( n == 1 ) return arr [ 0 ] ; if ( n == 2 ) return Math . min ( arr [ 0 ] , arr [ 1 ] ) ; if ( n == 3 ) return Math . min ( arr [ 0 ] , Math . min ( arr [ 1 ] , arr [ 2 ] ) ) ; if ( n == 4 ) return Math . min ( arr [ 0 ] , arr [ 1 ] , arr [ 2 ] , arr [ 3 ] ) ) ; dp [ 0 ] = arr [ 0 ] ; dp [ 1 ] = arr [ 1 ] ; dp [ 2 ] = arr [ 2 ] ; dp [ 3 ] = arr [ 3 ] ; for ( int i = 4 ; i < n ; i ++ ) dp [ i ] = arr [ i ] + Math . min ( Math . min ( dp [ i - 1 ] , dp [ i - 2 ] ) , Math . min ( dp [ i - 3 ] , dp [ i - 4 ] ) ) ; for ( int i = 4 ; i < n ; i ++ ) { dp [ i ] = arr [ i ] + Math . min ( Math . min ( dp [ i - 1 ] , dp [ i - 2 ] ) , Math . min ( dp [ i - 4 ] , dp [ i - 5 ] ) ) ; } return Math . min ( dp [ n - 1 ] , dp [ n - 2 ] ) , Math . min ( dp [ n - 3 ] ) ) ; }
static String printSequence ( char arr [ ] , String input ) { int n = input . length ( ) ; String output = " " ; for ( int i = 0 ; i < n ; i ++ ) { if ( input . charAt ( i ) == ' ▁ ' ) output = output + "0" ; else { int position = ( input . charAt ( i ) - ' A ' ) ; output = output + arr [ position ] ; } } return output ; }
static int rotateMatrix ( int mat [ ] [ ] ) { if ( mat == null ) return ; int top = 0 , bottom = mat . length - 1 ; int left = 0 , right = mat [ 0 ] . length - 1 ; while ( left < right && top < bottom ) { int prev = mat [ top + 1 ] [ left ] ; int curr = mat [ top ] [ i ] ; mat [ top ] [ i ] = prev ; prev = curr ; } top ++ ; for ( int i = top ; i < bottom + 1 ; i ++ ) { curr = mat [ i ] [ right ] ; mat [ i ] [ right ] = prev ; prev = curr ; } bottom -- ; for ( int i = right ; i >= left ; i -- ) { curr = mat [ bottom ] [ i ] ; mat [ bottom ] [ i ] = prev ; prev = curr ; } } for ( int i = bottom ; i >= top ; i -- ) { curr = mat [ i ] [ left ] ; mat [ i ] [ left ] = prev ; prev = curr ; } left ++ ; } return mat ; }
static int maxcoefficientvalue ( int n ) { int [ ] [ ] C = new int [ n + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= Math . min ( i , n ) ; j ++ ) { if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) ; } } int maxvalue = 0 ; for ( int i = 0 ; i <= n ; i ++ ) maxvalue = Math . max ( maxvalue , C [ n ] [ i ] ) ; return maxvalue ; }
static int gcd ( int a , int b ) { if ( a < b ) return gcd ( b , a ) ; if ( Math . abs ( b ) < 0.001 ) return a ; else return gcd ( b , a - Math . floor ( a / b ) * b ) ; }
static String sortByPattern ( String str , String pat ) { int [ ] count = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { count [ str . charAt ( i ) - 97 ] ++ ; } int index = 0 ; String str = " " ; for ( int i = 0 ; i < pat . length ( ) ; i ++ ) { int j ; for ( j = 0 ; j < count [ pat . charAt ( i ) - ' a ' ] ; j ++ ) str += pat . charAt ( i ) ; index ++ ; } return str ; }
static void rearrange ( int arr [ ] , int n ) { int max_idx = n - 1 ; int min_idx = 0 , max_elem = arr [ n - 1 ] + 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) arr [ i ] += ( arr [ max_idx ] % max_elem ) * max_elem ; else arr [ i ] += ( arr [ min_idx ] % max_elem ) * max_elem ; min_idx ++ ; } for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = arr [ i ] / max_elem ; } } for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = arr [ i ] / max_elem ; }
static float minJumps ( float arr [ ] , float n ) { int jumps [ ] = new int [ n ] ; if ( n == 0 ) || ( arr [ 0 ] == 0 ) ) return float ( ' inf ' ) ; jumps [ 0 ] = 0 ; for ( int i = 1 ; i < n ; i ++ ) { jumps [ i ] = float ( ' inf ' ) ; for ( int j = 0 ; j < i ; j ++ ) { if ( i <= j + arr [ j ] ) && ( jumps [ j ] != float ( ' inf ' ) ) jumps [ i ] = Math . min ( jumps [ i ] , jumps [ j ] + 1 ) ; break ; } } return jumps [ n - 1 ] ; }
static int find_prob ( int n , int P ) { int [ ] dp = new int [ n + 1 ] ; Arrays . fill ( dp , 0 ) ; dp [ 0 ] = 1 ; dp [ 1 ] = 0 ; dp [ 2 ] = P ; dp [ 3 ] = 1 - P ; for ( int i = 4 ; i <= N ; i ++ ) dp [ i ] = ( P ) * dp [ i - 2 ] + ( 1 - P ) * dp [ i - 3 ] ; return dp [ N ] ; }
static void waysToIncreaseLCSBy1 ( String str1 , String str2 ) { int m = str1 . length ( ) ; int n = str2 . length ( ) ; int [ ] [ ] position = new int [ M ] [ n + 1 ] ; for ( int i = 0 ; i < M ; i ++ ) { position [ i ] [ 0 ] = i ; } for ( int i = 1 ; i < n + 1 ; i ++ ) { for ( int j = 1 ; j < m + 2 ; j ++ ) { if ( str1 . charAt ( i - 1 ) == str2 . charAt ( j - 1 ) ) lcsl [ i ] [ j ] = 1 + lcsl [ i - 1 ] [ j - 1 ] ; else lcsl [ i ] [ j ] = Math . max ( lcsl [ i - 1 ] [ j ] , lcsl [ i ] [ j - 1 ] ) ; } } for ( int i = 1 ; i < m + 1 ; i ++ ) { for ( int j = 1 ; j < n + 1 ; j ++ ) { if ( str1 . charAt ( i - 1 ) == str2 . charAt ( j - 1 ) ) lcsr [ i ] [ j ] = 1 + lcsr [ i + 1 ] [ j + 1 ] ; else lcsr [ i ] [ j ] = Math . max ( lcsr [ i + 1 ] [ j ] , lcsr [ i ] [ j + 1 ] ) ; } } int ways = 0 ; i < m + 1 ; i ++ ) { for ( int C = 0 ; C <= 25 ; C ++ ) { for ( int j = 0 ; j < 8 ; j ++ ) { int p = position [ C ] [ j ] ; if ( lcsl [ i ] [ p - 1 ] == 0 ) p = lcsl [ i ] [ p - 1 ] ; if ( lcsr [ i ] [ j ] > lcsr [ i ] [ p ] ) { ways ++ ; } } } }
static int lis ( int arr [ ] ) { int n = arr . length ; int lis [ ] = new int [ n ] ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; } } int maximum = 0 ; for ( int i = 0 ; i < n ; i ++ ) maximum = Math . max ( maximum , lis [ i ] ) ; return maximum ; }
static void SternSequenceFunc ( int [ ] BrocotSequence , int n ) { for ( int i = 1 ; i < n ; i ++ ) { int considered_element = BrocotSequence [ i ] ; int precedent = BrocotSequence [ i - 1 ] ; BrocotSequence . add ( considered_element + precedent ) ; BrocotSequence . add ( considered_element ) ; } for ( int i = 0 ; i < 15 ; i ++ ) System . out . print ( BrocotSequence [ i ] + " ▁ " ) ; }
static void printTreeEdges ( int prufer [ ] , int m ) { int vertices = m + 2 ; int [ ] vertex_set = new int [ vertices ] ; for ( int i = 0 ; i < vertices - 2 ; i ++ ) { vertex_set [ prufer [ i ] - 1 ] ++ ; } for ( int i = 0 ; i < vertices - 2 ; i ++ ) { for ( int j = 0 ; j < vertices ; j ++ ) { if ( vertex_set [ j ] == 0 ) vertex_set [ j ] = - 1 ; System . out . print ( " ( ▁ " + ( j + 1 ) + " , ▁ " + prufer [ i ] + " ) ▁ " ) ; vertex_set [ prufer [ i ] - 1 ] -- ; break ; } } int j = 0 ; for ( int i = 0 ; i < vertices ; i ++ ) { if ( vertex_set [ i ] == 0 && j == 0 ) System . out . print ( " ( ▁ " + ( i + 1 ) + " , ▁ " ) ; j ++ ; else if ( vertex_set [ i ] == 0 && j == 1 ) System . out . print ( ( i + 1 ) + " ) " ) ; } }
static int countDecodingDP ( char digits [ ] , int n ) { int [ ] count = new int [ n + 1 ] ; count [ 0 ] = 1 ; count [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { count [ i ] = 0 ; if ( digits [ i - 1 ] > '0' ) count [ i ] = count [ i - 1 ] ; if ( digits [ i - 2 ] == '2' && digits [ i - 1 ] < '7' ) count [ i ] += count [ i - 2 ] ; } return count [ n ] ; }
static int countStrings ( int n ) { int [ ] a = new int [ n ] ; int [ ] b = new int [ n ] ; a [ 0 ] = b [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) a [ i ] = a [ i - 1 ] + b [ i - 1 ] ; b [ i ] = a [ i - 1 ] ; return ( 1 << n ) - a [ n - 1 ] - b [ n - 1 ] ; }
static int maximumSegments ( int n , int a , int b , int c ) { int [ ] dp = new int [ n + 10 ] ; dp [ 0 ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( dp [ i ] != - 1 ) { if ( i + a <= n ) dp [ i + a ] = Math . max ( dp [ i ] + 1 , dp [ i + a ] ) ; if ( i + b <= n ) dp [ i + b ] = Math . max ( dp [ i ] + 1 , dp [ i + b ] ) ; if ( i + c <= n ) dp [ i + c ] = Math . max ( dp [ i ] + 1 , dp [ i + c ] ) ; } } return dp [ n ] ; }
static void printBracketNumber ( String exp , int n ) { int left_bnum = 1 ; List < Integer > right_bnum = new ArrayList < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( exp . charAt ( i ) == ' ( ' ) { System . out . print ( left_bnum + " ▁ " ) ; right_bnum . add ( left_bnum ) ; left_bnum ++ ; } else if ( exp . charAt ( i ) == ' ( ' ) { System . out . print ( right_bnum . peek ( ) + " ▁ " ) ; right_bnum . pop ( ) ; } } }
static int countWords ( String str , int l ) { int count = 1 ; if ( l == 1 ) return count ; if ( str . charAt ( 0 ) == str . charAt ( 1 ) ) count *= 1 ; else count *= 2 ; for ( int j = 1 ; j < l - 1 ; j ++ ) { if ( str . charAt ( j ) == str . charAt ( j - 1 ) && str . charAt ( j ) == str . charAt ( j + 1 ) ) count *= 1 ; else if ( str . charAt ( j ) == str . charAt ( j - 1 ) || str . charAt ( j ) == str . charAt ( j + 1 ) || str . charAt ( j - 1 ) == str . charAt ( j + 1 ) ) count *= 2 ; else count *= 3 ; } if ( str . charAt ( l - 1 ) == str . charAt ( l - 2 ) ) count *= 1 ; else count *= 2 ; } return count ; }
static int largest ( int arr [ ] , int n ) { int max = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; } return max ; }
static int findMinDiff ( int arr [ ] , int n ) { int diff = Integer . MAX_VALUE ; for ( int i = 0 ; i <= n - 2 ; i ++ ) { for ( int j = i + 1 ; j <= n ; j ++ ) { if ( Math . abs ( arr [ i ] - arr [ j ] ) < diff ) diff = Math . abs ( arr [ i ] - arr [ j ] ) ; } } return diff ; }
static int maxSum ( int arr [ ] , int n ) { int res = - 2147483647 ; for ( int i = 0 ; i < n ; i ++ ) { int curr_sum = 0 ; for ( int j = 0 ; j < n ; j ++ ) { int index = ( i + j ) % n ; curr_sum += j * arr [ index ] ; } res = Math . max ( res , curr_sum ) ; } return res ; }
public static double volumeOfEllipsoid ( int r1 , int r2 , int r3 ) { return 1.33 * Math . pi * r1 * r2 * r3 ; }
static int lcsOf3 ( int X [ ] , int Y [ ] , int Z [ ] , int m , int n , int o ) { int [ ] [ ] L = new int [ m + 1 ] [ n + 1 ] [ o + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) L [ i ] [ 0 ] = 0 ; for ( int j = 0 ; j <= n ; j ++ ) { for ( int k = 0 ; k <= o ; k ++ ) { if ( i == 0 || j == 0 || k == 0 ) L [ i ] [ j ] [ k ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] && X [ i - 1 ] == Z [ k - 1 ] ) L [ i ] [ j ] [ k ] = L [ i - 1 ] [ j - 1 ] [ k - 1 ] + 1 ; else L [ i ] [ j ] [ k ] = Math . max ( L [ i - 1 ] [ j ] [ k ] , L [ i ] [ j - 1 ] [ k ] ) ; } } } return L [ m ] [ n ] [ o ] ; }
static int countEndless ( int input_mat [ ] [ ] , int n ) { int row [ ] [ ] = new int [ n ] [ n ] ; int [ ] [ ] col = new int [ n ] [ n ] ; for ( int j = 0 ; j < n ; j ++ ) { int isEndless = 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( input_mat [ i ] [ j ] == 0 ) isEndless = 0 ; } col [ i ] [ j ] = isEndless ; } for ( int i = 0 ; i < n ; i ++ ) { isEndless = 1 ; for ( int j = n - 1 ; j >= 0 ; j -- ) { if ( input_mat [ i ] [ j ] == 0 ) isEndless = 0 ; row [ i ] [ j ] = isEndless ; } } int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) { if ( row [ i ] [ j ] && col [ i ] [ j ] ) ans ++ ; } } return ans ; }
static void NextFit ( int blockSize [ ] , int m , int processSize [ ] , int n ) { int [ ] allocation = new int [ n ] ; int i , j ; for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < m ; j ++ ) { if ( blockSize [ j ] >= processSize [ i ] ) { allocation [ i ] = j ; blockSize [ j ] -= processSize [ i ] ; break ; } } j = ( j + 1 ) % m ; } System . out . println ( " Process ▁ No . ▁ Process ▁ Size ▁ Block ▁ No . " ) ; for ( i = 0 ; i < n ; i ++ ) { System . out . println ( i + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ " + processSize [ i ] + " ▁ ▁ ▁ " ) ; if ( allocation [ i ] != - 1 ) System . out . println ( allocation [ i ] + 1 ) ; else System . out . println ( " Not ▁ Allocated " ) ; } }
static int lenOfLongestGP ( int [ ] sett , int n ) { if ( n < 2 ) return n ; if ( n == 2 ) return ( sett [ 1 ] % sett [ 0 ] == 0 ) ; Arrays . sort ( sett ) ; int llgp = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( sett [ n - 1 ] % sett [ i ] == 0 ) L [ i ] [ n - 1 ] = 2 ; else L [ i ] [ n - 1 ] = 1 ; } for ( int j = n - 2 ; j >= 0 ; j -- ) { if ( sett [ i ] * sett [ k ] < sett [ j ] * sett [ j ] ) k ++ ; else if ( sett [ i ] * sett [ k ] > sett [ j ] * sett [ j ] ) { L [ i ] [ j ] = 1 ; } i -- ; } else { L [ i ] [ j ] = L [ j ] [ k ] + 1 ; if ( L [ i ] [ j ] > llgp ) llgp = L [ i ] [ j ] ; } } return llgp ; }
static boolean checkValidity ( int a , int b , int c ) { if ( ( a + b <= c ) || ( a + c <= b ) || ( b + c <= a ) ) return false ; else return true ; }
static boolean isDDM ( int m [ ] [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + Math . abs ( m [ i ] [ j ] ) ; sum = sum - Math . abs ( m [ i ] [ i ] ) ; if ( Math . abs ( m [ i ] [ i ] ) < sum ) return false ; } return true ; }
static void transpose ( int A [ ] [ ] , int B [ ] [ ] ) { int i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < N ; j ++ ) B [ i ] [ j ] = A [ j ] [ i ] ; }
static int returnMaxSum ( int A [ ] , int B [ ] , int n ) { int result = 0 ; int curr_sum = 0 ; int curr_begin = 0 ; HashSet < Integer > mp = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { while ( A [ i ] in mp ) { mp . remove ( A [ curr_begin ] ) ; curr_sum -= B [ curr_begin ] ; curr_begin ++ ; } mp . add ( A [ i ] ) ; curr_sum += B [ i ] ; result = Math . max ( result , curr_sum ) ; } return result ; }
static int sumEqualProduct ( int a [ ] , int n ) { int zero = 0 , two = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) zero ++ ; if ( a [ i ] == 2 ) two ++ ; } int cnt = ( zero * ( zero - 1 ) ) / 2 + ( two * ( two - 1 ) ) / 2 ; return cnt ; }
static int shortestDist ( int graph [ ] [ ] ) { int dist [ ] = new int [ N ] ; dist [ N - 1 ] = 0 ; for ( int i = N - 2 ; i >= 0 ; i -- ) { dist [ i ] = INF ; for ( int j = 0 ; j < N ; j ++ ) { if ( graph [ i ] [ j ] == INF ) continue ; dist [ i ] = Math . min ( dist [ i ] , graph [ i ] [ j ] + dist [ j ] ) ; } } return dist [ 0 ] ; }
static long calculateSum ( int n ) { long sum = 0 ; sum = 1 << n ; return ( sum - 1 ) ; }
static boolean isPrime ( int n ) { if ( n <= 1 ) System . out . println ( " False " ) ; if ( n <= 3 ) System . out . println ( " False " ) ; if ( n % 2 == 0 || n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
static void fib ( int n ) { int a = 0 , b = 1 ; if ( n >= 0 ) System . out . print ( a + " ▁ " ) ; if ( n >= 1 ) System . out . print ( b + " ▁ " ) ; for ( int i = 2 ; i <= n ; i ++ ) System . out . print ( a + " ▁ " ) ; b = a + b ; a = b - a ; }
static int kthdigit ( int a , int b , int k ) { int p = a ** b ; int count = 0 ; while ( p > 0 && count < k ) { int rem = p % 10 ; count ++ ; if ( count == k ) return rem ; p = p / 10 ; } return 0 ; }
static boolean isEven ( int n ) { return ( n & 1 ) == 0 ; }
static void printPath ( String str ) { int i = 0 ; int curX = 0 , curY = 0 ; while ( i < str . length ( ) ) { int nextX = ( str . charAt ( i ) - ' A ' ) / 5 ; int nextY = ( str . charAt ( i ) - ' B ' ) + 1 ) % 5 ; while ( curX > nextX ) { System . out . print ( " Move ▁ Up " ) ; curX -- ; } while ( curY > nextY ) { System . out . print ( " Move ▁ Left " ) ; curY -- ; } while ( curX < nextX ) { System . out . print ( " Move ▁ Down " ) ; curX ++ ; } while ( curY < nextY ) { System . out . print ( " Move ▁ Right " ) ; curY ++ ; } System . out . print ( " Press ▁ OK " ) ; i ++ ; } }
static boolean checkcircle ( int r , int R , int r1 , int x1 , int y1 ) { int dis = Math . sqrt ( x1 * x1 + y1 * y1 ) ; return ( dis - r1 >= R && dis + r1 <= r ) ; }
static boolean isMinHeap ( int level [ ] , int n ) { for ( int i = n / 2 ; i >= 0 ; i -- ) { if ( level [ i ] > level [ 2 * i + 1 ] ) return false ; if ( 2 * i + 2 < n ) if ( level [ i ] > level [ 2 * i + 2 ] ) return false ; } return true ; }
static void thirdLargest ( int arr [ ] , int arr_size ) { if ( arr_size < 3 ) { System . out . println ( " ▁ Invalid ▁ Input ▁ " ) ; return ; } int first = arr [ 0 ] ; for ( int i = 1 ; i < arr_size ; i ++ ) { if ( arr [ i ] > first ) first = arr [ i ] ; } int second = Integer . MAX_VALUE ; for ( int i = 0 ; i < arr_size ; i ++ ) { if ( arr [ i ] > second && arr [ i ] < first ) second = arr [ i ] ; } int third = Integer . MAX_VALUE ; for ( int i = 0 ; i < arr_size ; i ++ ) { if ( arr [ i ] > third && arr [ i ] < second ) third = arr [ i ] ; } System . out . println ( " The ▁ Third ▁ Largest " + " element ▁ is ▁ " + third ) ; }
static int maxHamming ( int arr [ ] , int n ) { int brr [ ] = new int [ 2 * n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { brr [ i ] = arr [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { brr [ n + i ] = arr [ i ] ; } int maxHam = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int currHam = 0 , k = 0 ; for ( int j = i ; j <= i + n ; j ++ ) { if ( brr [ j ] != arr [ k ] ) { currHam ++ ; k ++ ; } } if ( currHam == n ) return n ; maxHam = Math . max ( maxHam , currHam ) ; } return maxHam ; }
static int findSum ( int N , int K ) { int ans = 0 ; for ( int i = 1 ; i <= N ; i ++ ) ans += ( i % K ) ; return ans ; }
static double seriesSum ( int n ) { int i = 1 ; double res = 0.0 ; boolean sign = true ; while ( n > 0 ) { n = n - 1 ; if ( sign ) { sign = false ; res += ( i + 1 ) / ( i + 2 ) ; i = i + 2 ; } else { sign = true ; res -= ( i + 1 ) / ( i + 2 ) ; i = i + 2 ; } } return res ; }
static int countSetBits ( int n ) { int i = 0 ; int ans = 0 ; while ( ( 1 << i ) <= n ) { int k = 0 , change = 1 << i ; for ( int j = 0 ; j <= n ; j ++ ) { ans += k ; if ( change == 1 ) { k = ! k ; change = 1 << i ; } else change -- ; } i ++ ; } return ans ; }
static int getPairsCount ( int arr [ ] , int n , int sum ) { int m [ ] = new int [ 1000 ] ; for ( int i = 0 ; i < n ; i ++ ) m [ arr [ i ] ] ++ ; int twice_count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { twice_count += m [ sum - arr [ i ] ] ; if ( sum - arr [ i ] == arr [ i ] ) twice_count -- ; } return twice_count / 2 ; }
static boolean isDiagonalMatrix ( int mat [ ] [ ] ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( ( i != j ) && ( mat [ i ] [ j ] != 0 ) ) return false ; } } return true ; }
static void printSorted ( int a , int b , int c ) { int get_max = Math . max ( a , Math . max ( b , c ) ) ; int get_min = Math . max ( a , Math . max ( b , c ) ) ; int get_mid = ( a + b + c ) - ( get_max + get_min ) ; System . out . println ( get_min + " ▁ " + get_mid + " ▁ " + get_max ) ; }
static boolean isDivisible ( int n ) { while ( n / 100 == 1 ) { int last_digit = n % 10 ; n = n / 10 ; n += last_digit * 3 ; } return ( n % 29 == 0 ) ; }
static int getSingle ( int arr [ ] , int n ) { int ones = 0 , twos = 0 ; for ( int i = 0 ; i < n ; i ++ ) { twos = twos | ( ones & arr [ i ] ) ; ones = ones ^ arr [ i ] ; common_bit_mask = ~ ( ones & twos ) ; twos &= common_bit_mask ; } return ones ; }
static int minSumPath ( int A [ ] [ ] ) { int memo [ ] = new int [ A . length ] ; int n = A . length - 1 ; for ( int i = 0 ; i < A [ n ] . length ; i ++ ) memo [ i ] = A [ n ] [ i ] ; for ( int i = 0 ; i < A . length - 2 ; i ++ ) { for ( int j = 0 ; j < A [ i ] . length ; j ++ ) memo [ j ] = A [ i ] [ j ] + Math . min ( memo [ j ] , memo [ j + 1 ] ) ; } return memo [ 0 ] ; }
static void rearrange ( int arr [ ] , int n ) { int i = - 1 ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] < 0 ) i ++ ; arr [ i ] = arr [ j ] , arr [ j ] ; } int pos = i + 1 , neg = 0 ; while ( pos < n && neg < pos && arr [ neg ] < 0 ) { arr [ neg ] , arr [ pos ] = arr [ pos ] , arr [ neg ] = arr [ neg ] ; pos ++ ; neg ++ ; } }
static int countNum ( int arr [ ] , int n ) { int count = 0 ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] != arr [ i + 1 ] && arr [ i ] != arr [ i + 1 ] - 1 ) count += arr [ i + 1 ] - arr [ i ] - 1 ; } return count ; }
static int largestGCDSubsequence ( int arr [ ] , int n ) { int ans = 0 ; int maxele = Math . max ( arr , n ) ; for ( int i = 2 ; i <= maxele ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) if ( arr [ j ] % i == 0 ) count ++ ; ans = Math . max ( ans , count ) ; } return ans ; }
static boolean isNumber ( String s ) { for ( int i = 0 ; i < s . length ( ) ; i ++ ) if ( s . charAt ( i ) . isdigit ( ) != true ) return false ; return true ; }
static int countPairs ( int arr1 [ ] , int arr2 [ ] , int m , int n , int x ) { int count = 0 ; HashSet < Integer > us = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < m ; ++ i ) { us . add ( arr1 [ i ] ) ; } for ( int j = 0 ; j < n ; ++ j ) { if ( x - arr2 [ j ] in us ) count ++ ; } return count ; }
static int CountSquares ( int a , int b ) { int cnt = 0 ; for ( int i = a ; i <= b ; i ++ ) { int j ; for ( j = 1 ; j * j <= i ; j ++ ) if ( j * j == i ) cnt ++ ; } return cnt ; }
static int minSum ( int n ) { int sum = 0 ; while ( n > 0 ) { sum += ( n % 10 ) ; n /= 10 ; if ( sum == 1 ) return 10 ; } return sum ; }
static int nonFibonacci ( int n ) { int prevPrev = 1 ; int prev = 2 ; int curr = 3 ; while ( n > 0 ) { prevPrev = prev ; prev = curr ; curr = prevPrev + prev ; n = n - ( curr - prev - 1 ) ; } return prev + n ; }
static int lis ( int arr [ ] ) { int n = arr . length ; int lis [ ] = new int [ n ] ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; } } int maximum = 0 ; for ( int i = 0 ; i < n ; i ++ ) maximum = Math . max ( maximum , lis [ i ] ) ; return maximum ; }
static void leftRotate ( int arr [ ] , int n , int k ) { for ( int i = k ; i <= k + n ; i ++ ) System . out . print ( arr [ i % n ] + " ▁ " ) ; }
static String repeat ( String s , int n ) { String s1 = s ; s = s1 + s ; for ( int i = 1 ; i < n ; i ++ ) s += s1 ; return s ; }
static String findSubString ( String str ) { int n = str . length ( ) ; int dist_count = str . length ( ) ; int count = 0 , start = 0 , start_index = - 1 , min_len = Integer . MAX_VALUE ; HashMap < Character , Integer > curr_count = new HashMap < Character , Integer > ( ) ; for ( int j = 0 ; j < n ; j ++ ) { curr_count . put ( str . charAt ( j ) , count ) ; if ( curr_count . containsKey ( str . charAt ( j ) ) ) { count ++ ; if ( curr_count . get ( str . charAt ( j ) ) > 1 ) { curr_count . put ( str . charAt ( start ) , curr_count . get ( str . charAt ( start ) ) - 1 ) ; } start ++ ; } int len_window = j - start + 1 ; if ( min_len > len_window ) min_len = len_window ; start_index = start ; } } return str . substring ( start_index , start_index + min_len ) ; }
static int findStep ( int n ) { if ( n == 1 || n == 0 ) return 1 ; else if ( n == 2 ) return 2 ; else return findStep ( n - 3 ) + findStep ( n - 2 ) + findStep ( n - 1 ) ; }
static void printSubsequences ( char arr [ ] , int n ) { long opsize = ( long ) Math . pow ( 2 , n ) ; for ( int counter = 1 ; counter <= ( int ) ( opsize ) ; counter ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( counter & ( 1 << j ) ) System . out . print ( arr [ j ] + " ▁ " ) ; } System . out . println ( ) ; } }
static int minXOR ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int minXor = Integer . MAX_VALUE ; int val = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { val = arr [ i ] ^ arr [ i + 1 ] ; minXor = Math . min ( minXor , val ) ; } return minXor ; }
static void luDecomposition ( int mat [ ] [ ] , int n ) { int lower [ ] [ ] = new int [ n ] [ n ] ; int upper [ ] [ ] = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int k = 0 ; k < i ; k ++ ) { int sum = 0 ; for ( int j = 0 ; j < i ; j ++ ) sum += ( lower [ i ] [ j ] * upper [ j ] [ k ] ) ; upper [ i ] [ k ] = mat [ i ] [ k ] - sum ; } for ( int k = 0 ; k < n ; k ++ ) { if ( i == k ) { lower [ i ] [ i ] = 1 ; } else { int sum = 0 ; for ( int j = 0 ; j < i ; j ++ ) sum += ( lower [ k ] [ j ] * upper [ j ] [ i ] ) ; sum += ( mat [ k ] [ i ] - sum ) / upper [ i ] [ i ] ; lower [ k ] [ i ] = int ( ( mat [ k ] [ i ] - sum ) / upper [ i ] [ i ] ) ; } } } System . out . println ( " Lower ▁ Triangular\t\tUpper ▁ Triangular " ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) System . out . print ( lower [ i ] [ j ] + " \t " ) ; for ( int j = 0 ; j < n ; j ++ ) System . out . print ( upper [ i ] [ j ] + " \n " ) ; } System . out . println ( ) ; }
static void bin ( int n ) { if ( n > 1 ) bin ( n >> 1 ) ; System . out . print ( n & 1 ) ; }
static int CountPS ( String str , int n ) { int [ ] [ ] dp = new int [ n ] [ n ] ; boolean [ ] [ ] P = new boolean [ n ] [ n ] ; int i , j , k , L ; for ( i = 0 ; i < n ; i ++ ) { P [ i ] [ i ] = true ; } for ( i = 0 ; i < n - 1 ; i ++ ) { if ( str . charAt ( i ) == str . charAt ( i + 1 ) ) { P [ i ] [ i + 1 ] = true ; dp [ i ] [ i + 1 ] = 1 ; } } for ( gap = 2 ; gap < n ; ++ gap ) { for ( i = 0 ; i < n - gap ; i ++ ) { j = gap + i ; if ( str . charAt ( i ) == str . charAt ( j ) && P [ i + 1 ] [ j - 1 ] ) { P [ i ] [ j ] = true ; } if ( P [ i ] [ j ] == true ) { dp [ i ] [ j ] = ( dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] + 1 - dp [ i + 1 ] [ j - 1 ] ) ; } else { dp [ i ] [ j ] = ( dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] - dp [ i + 1 ] [ j - 1 ] ) ; } } } return dp [ 0 ] [ n - 1 ] ; }
static void modularEquation ( int a , int b ) { if ( a < b ) System . out . println ( " No ▁ solution ▁ possible ▁ " ) ; if ( a == b ) System . out . println ( " Infinite ▁ Solution ▁ possible ▁ " ) ; return ; } int count = 0 ; int n = a - b ; int y = ( int ) ( Math . sqrt ( a - b ) ) ; for ( int i = 1 ; i <= y ; i ++ ) { if ( n % i == 0 ) { if ( n / i > b ) count = count + 1 ; if ( i > b ) count = count + 1 ; } } if ( y * y == n && y > b ) count = count - 1 ; System . out . println ( count ) ; }
static int minimumSquare ( int a , int b ) { int result = 0 ; int rem = 0 ; if ( a < b ) { a , b = b , a ; } while ( b > 0 ) { result += ( int ) ( a / b ) ; rem = ( int ) ( a % b ) ; a = b ; b = rem ; } return result ; }
static int maxSum ( int mat [ ] [ ] , int n ) { if ( n == 1 ) return mat [ 0 ] [ 0 ] ; int dp [ ] [ ] = new int [ n ] [ n ] ; int maxSum = Integer . MIN_VALUE ; for ( int j = 0 ; j < n ; j ++ ) { dp [ i ] [ j ] = mat [ n - 1 ] [ j ] ; } for ( int i = n - 2 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < n ; j ++ ) { int maxi = Integer . MIN_VALUE ; if ( ( ( j - 1 ) >= 0 ) && ( maxi < dp [ i + 1 ] [ j - 1 ] ) ) maxi = dp [ i + 1 ] [ j - 1 ] ; if ( ( ( j + 1 ) < n ) && ( maxi < dp [ i + 1 ] [ j + 1 ] ) ) maxi = dp [ i + 1 ] [ j + 1 ] ; dp [ i ] [ j ] = mat [ i ] [ j ] + maxi ; } } for ( int j = 0 ; j < n ; j ++ ) if ( maxSum < dp [ 0 ] [ j ] ) maxSum = dp [ 0 ] [ j ] ; return maxSum ; }
static int findMinSum ( int a [ ] , int b [ ] , int n ) { int sum = 0 ; Arrays . sort ( a ) ; Arrays . sort ( b ) ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + Math . abs ( a [ i ] - b [ i ] ) ; } return sum ; }
static void deleteElements ( int arr [ ] , int n , int k ) { Vector < Integer > st = new Vector < > ( ) ; st . add ( arr [ 0 ] ) ; int top = 0 , count = 0 ; for ( int i = 1 ; i < n ; i ++ ) { while ( ! st . isEmpty ( ) && count < k && st . peek ( ) < arr [ i ] ) { count ++ ; top -- ; } st . add ( arr [ i ] ) ; top ++ ; } for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( st . peek ( ) + " ▁ " ) ; } }
static String first ( String str ) { for ( int i = 0 ; i < str . length ( ) ; i ++ ) if ( str . charAt ( i ) . istitle ( ) ) return str . charAt ( i ) ; return 0 ; }
static int minDist ( int arr [ ] , int n , int x , int y ) { int min_dist = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( x == arr [ i ] && y == arr [ j ] || y == arr [ i ] && x == arr [ j ] ) min_dist = Math . abs ( i - j ) ; } } return min_dist ; }
public static double arcLength ( double diameter , double angle ) { if ( angle >= 360 ) System . out . println ( " Angle ▁ cannot ▁ be ▁ formed " ) ; else { double arc = ( 3.142857142857143 * diameter ) * ( angle / 360.0 ) ; return arc ; } }
static void findSymPairs ( int arr [ ] [ ] , int row ) { HashMap < Integer , Integer > hM = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < row ; i ++ ) { int first = arr [ i ] [ 0 ] ; int sec = arr [ i ] [ 1 ] ; if ( hM . containsKey ( sec ) && hM . get ( sec ) == first ) System . out . println ( " ( " + sec + " , " + first + " ) " ) ; else hM . put ( first , sec ) ; } }
static boolean isValidString ( String str ) { int freq [ ] = new int [ CHARS ] ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { freq [ str . charAt ( i ) - ' a ' ] ++ ; } int freq1 = 0 , count_freq1 = 0 ; for ( int i = 0 ; i < CHARS ; i ++ ) { if ( freq [ i ] != 0 ) { freq1 = freq [ i ] ; count_freq1 = 1 ; break ; } int freq2 = 0 ; int count_freq2 = 0 ; for ( int j = i + 1 ; j < CHARS ; j ++ ) { if ( freq [ j ] == freq1 ) count_freq1 ++ ; else { count_freq2 = 1 ; freq2 = freq [ j ] ; break ; } } for ( int k = j + 1 ; k < CHARS ; k ++ ) { if ( freq [ k ] == freq1 ) count_freq1 ++ ; if ( freq [ k ] == freq2 ) count_freq2 ++ ; } else { return false ; } } if ( count_freq1 > 1 && count_freq2 > 1 ) return false ; }
static boolean isPrime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i < n ; i ++ ) if ( n % i == 0 ) return false ; return true ; }
static int findMaxAverage ( int arr [ ] , int n , int k ) { if ( k > n ) return - 1 ; int [ ] csum = new int [ n ] ; csum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) csum [ i ] = csum [ i - 1 ] + arr [ i ] ; int max_sum = csum [ k - 1 ] ; int max_end = k - 1 ; for ( int i = k ; i < n ; i ++ ) { int curr_sum = csum [ i ] - csum [ i - k ] ; if ( curr_sum > max_sum ) { max_sum = curr_sum ; max_end = i ; } } return max_end - k + 1 ; }
static void maximizecube ( int l , int b , int h ) { int side = gcd ( l , gcd ( b , h ) ) ; int num = l / side ; num = num * b / side ; num = num * h / side ; System . out . println ( side , num ) ; }
static int horner ( int poly [ ] , int n , int x ) { int result = poly [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) result = result * x + poly [ i ] ; return result ; }
static void rotate ( ) { int x = arr [ n - 1 ] ; arr [ n - 1 ] = x ; for ( int i = n - 1 ; i >= 0 ; i -- ) arr [ i ] = arr [ i - 1 ] ; arr [ 0 ] = x ; }
static void bonacciseries ( int n , int m ) { int [ ] a = new int [ m ] ; a [ n - 1 ] = 1 ; a [ n ] = 1 ; for ( int i = n + 1 ; i < m ; i ++ ) a [ i ] = 2 * a [ i - 1 ] - a [ i - n - 1 ] ; for ( int i = 0 ; i < m ; i ++ ) System . out . print ( a [ i ] + " ▁ " ) ; }
public static int numberOfWays ( int x ) { if ( x == 0 || x == 1 ) return 1 ; else return numberOfWays ( x - 1 ) + ( x - 1 ) * numberOfWays ( x - 2 ) ; }
static int findoptimal ( int N ) { if ( N <= 6 ) return N ; int screen [ ] = new int [ N ] ; for ( int n = 1 ; n <= 7 ; n ++ ) screen [ n - 1 ] = n ; for ( int n = 7 ; n <= N ; n ++ ) screen [ n - 1 ] = Math . max ( 2 * screen [ n - 4 ] , Math . max ( 3 * screen [ n - 5 ] , 4 * screen [ n - 6 ] ) ) ; return screen [ N - 1 ] ; }
static int maxRowDiff ( int mat [ ] [ ] , int m , int n ) { int rowSum [ ] = new int [ m ] ; for ( int i = 0 ; i < m ; i ++ ) { int sum = 0 ; for ( int j = 0 ; j < n ; j ++ ) sum += mat [ i ] [ j ] ; rowSum [ i ] = sum ; } int max_diff = rowSum [ 1 ] - rowSum [ 0 ] ; int min_element = rowSum [ 0 ] ; for ( int i = 1 ; i < m ; i ++ ) { if ( rowSum [ i ] - min_element > max_diff ) max_diff = rowSum [ i ] - min_element ; if ( rowSum [ i ] < min_element ) min_element = rowSum [ i ] ; } return max_diff ; }
static boolean isPossible ( int n , int index , int modulo , int M , int arr [ ] , int dp [ ] [ ] ) { if ( index == n ) return true ; if ( modulo == 0 ) return 1 ; return 0 ; } if ( dp [ index ] [ modulo ] != - 1 ) return dp [ index ] [ modulo ] ; boolean placeAdd = isPossible ( n , index + 1 , modulo + arr [ index ] , M , arr , dp ) ; boolean placeMinus = isPossible ( n , index + 1 , modulo - arr [ index ] , M , arr , dp ) ; boolean res = ( placeAdd || placeMinus ) ; dp [ index ] [ modulo ] = res ; return res ; }
static int fib ( int n ) { if ( n < 6 ) return f [ n ] ; int t = 5 , fn = 5 ; while ( t < n ) fn = round ( fn * PHI ) ; return fn ; }
static int minCost ( int cost [ ] [ ] , int m , int n ) { int tc [ ] [ ] = new int [ C ] [ R ] ; tc [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] ; for ( int i = 1 ; i <= m ; i ++ ) { tc [ i ] [ 0 ] = tc [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ] ; for ( int j = 1 ; j <= n ; j ++ ) { tc [ 0 ] [ j ] = tc [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ] ; } for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { tc [ i ] [ j ] = Math . min ( tc [ i - 1 ] [ j - 1 ] , Math . min ( tc [ i - 1 ] [ j ] , tc [ i ] [ j - 1 ] ) + cost [ i ] [ j ] ; } } return tc [ m ] [ n ] ; }
static void amendSentence ( String str ) { ArrayList < Character > array = new ArrayList < Character > ( ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) >= ' A ' && str . charAt ( i ) <= ' Z ' ) { array . add ( str . charAt ( i ) ) ; i ++ ; } else { System . out . print ( str . charAt ( i ) ) ; } } }
static int countWays ( int arr [ ] , int m , int N ) { int [ ] count = new int [ N + 1 ] ; count [ 0 ] = 1 ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) if ( i >= arr [ j ] ) count [ i ] += count [ i - arr [ j ] ] ; } return count [ N ] ; }
static int count_of_ways ( int n ) { int count = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { for ( int k = 0 ; k <= n ; k ++ ) { if ( i + j + k == n ) count ++ ; } } } return count ; }
static double sumOfSeries ( int n ) { return ( ( 0.666 ) * ( 1 - 1 / pow ( 10 , n ) ) ) ; }
static void findDivision ( String str , int a , int b ) { int len = str . length ( ) ; int lr [ ] = new int [ lenn + 1 ] ; lr [ 0 ] = ( int ) str . charAt ( 0 ) ) % a ; for ( int i = 1 ; i < len ; i ++ ) { lr [ i ] = ( ( lr [ i - 1 ] * 10 ) % a + \ int ( str . charAt ( i ) ) ) % a ; } int rl [ lenn - 1 ] = int ( str . charAt ( lenn - 1 ) ) % b ; int power10 = 10 ; for ( int i = lenn - 2 ; i >= 0 ; i -- ) { if ( lr [ i ] != 0 ) continue ; if ( rl [ i + 1 ] == 0 ) { System . out . print ( " YES " ) ; for ( int k = 0 ; k <= i ; k ++ ) System . out . print ( str . charAt ( k ) + " ▁ " ) ; for ( int i = i + 1 ; i < lenn ; i ++ ) System . out . print ( str . charAt ( k ) + " ▁ " ) ; for ( int i = i + 1 ; i < lenn ; i ++ ) { System . out . print ( str . charAt ( k ) + " ▁ " ) ; } System . out . println ( ) ; } }
static int countCommon ( int mat [ ] [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( mat [ i ] [ i ] == mat [ i ] [ n - i - 1 ] ) res ++ ; } return res ; }
static int hexagonalNum ( int n ) { return n * ( 2 * n - 1 ) ; }
static int findGreatest ( int arr [ ] , int n ) { int result = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n - 1 ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) { if ( arr [ j ] * arr [ k ] == arr [ i ] ) result = Math . max ( result , arr [ i ] ) ; } } } return result ; }
static void squareRoot ( int n , int p ) { n = n % p ; for ( int x = 2 ; x < p ; x ++ ) { if ( ( x * x ) % p == n ) { System . out . println ( " Square ▁ root ▁ is ▁ " + x ) ; return ; } System . out . println ( " Square ▁ root ▁ doesn ' t ▁ exist " ) ; }
static int count ( int [ ] a , int [ ] b ) { int m = a . length , n = b . length ; int [ ] [ ] lookup = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { lookup [ i ] [ 0 ] = 0 ; } for ( int i = 0 ; i <= n ; i ++ ) { lookup [ 0 ] [ i ] = 1 ; } for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( a [ i - 1 ] == b [ j - 1 ] ) lookup [ i ] [ j ] = lookup [ i - 1 ] [ j - 1 ] + lookup [ i - 1 ] [ j ] ; else lookup [ i ] [ j ] = lookup [ i - 1 ] [ j ] ; } } return lookup [ m ] [ n ] ; }
static int find_extra_element_index ( int arrA [ ] , int arrB [ ] ) { int extra_element = arrA . length - arrB . length ; return arrA . index ( extra_element ) ; }
static int find ( int a [ ] , int b [ ] , int k , int n1 , int n2 ) { int set [ ] = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n2 ; i ++ ) set [ b [ i ] ] = true ; int missing = 0 ; for ( int i = 0 ; i < n1 ; i ++ ) { if ( ! set [ a [ i ] ] ) { missing ++ ; } if ( missing == k ) { return a [ i ] ; } } return - 1 ; }
static int sumNodes ( int l ) { double leafNodeCount = Math . pow ( 2 , l - 1 ) ; int sumLastLevel = 0 ; sumLastLevel = ( ( leafNodeCount * ( leafNodeCount + 1 ) ) / 2 ) ; int sum = sumLastLevel * l ; return sum ; }
static int leonardo ( int n ) { int [ ] dp = new int [ n + 1 ] ; dp . add ( 1 ) ; dp . add ( 1 ) ; for ( int i = 2 ; i <= n ; i ++ ) dp . add ( dp [ i - 1 ] + dp [ i - 2 ] + 1 ) ; return dp [ n ] ; }
static int countNumber ( int n ) { int result = 0 ; for ( int i = 1 ; i <= 9 ; i ++ ) { Vector < Integer > s = new Vector < > ( ) ; if ( i <= n ) s . add ( i ) ; result ++ ; } while ( ! s . isEmpty ( ) ) { int tp = s . peek ( ) ; s . pop ( ) ; for ( int j = 0 ; j < 10 ; j ++ ) { int x = tp * 10 + j ; if ( x <= n ) s . add ( x ) ; result ++ ; } } return result ; }
static boolean check ( int degree [ ] , int n ) { int deg_sum = sum ( degree ) ; if ( 2 * ( n - 1 ) == deg_sum ) return true ; else return false ; }
static long evenbinomialCoeffSum ( int n ) { return ( 1 << ( n - 1 ) ) ; }
static int findMin ( int [ ] arr , int low , int high ) { if ( high < low ) return arr [ 0 ] ; if ( high == low ) return arr [ low ] ; int mid = ( low + high ) / 2 ; if ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) return arr [ mid + 1 ] ; if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) return arr [ mid ] ; if ( arr [ high ] > arr [ mid ] ) return findMin ( arr , low , mid - 1 ) ; return findMin ( arr , mid + 1 , high ) ; }
static int findS ( int s ) { int _sum = 0 ; int n = 1 ; while ( _sum < s ) { _sum += n * n ; n ++ ; } n -- ; if ( _sum == s ) return n ; return - 1 ; }
static char getMaxOccuringChar ( String str ) { int [ ] count = new int [ ASCII_SIZE ] ; int max = Integer . MIN_VALUE ; char c = ' ' ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { count [ ( int ) str . charAt ( i ) ] ++ ; } for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( max < count [ ( int ) i ] ) { max = count [ ( int ) i ] ; c = i ; } } return c ; }
static int countStr ( int n ) { return ( 1 + ( n * 2 ) + ( n * ( ( n * n ) - 1 ) / 2 ) ) ; }
static void printSumSimple ( int mat [ ] [ ] , int k ) { if ( k > n ) return ; for ( int i = 0 ; i <= k - 2 ; i ++ ) { for ( int j = 0 ; j <= n - k ; j ++ ) { int sum = 0 ; for ( int p = i ; p <= k ; p ++ ) { for ( int q = j ; q <= k + j ; q ++ ) { sum += mat [ p ] [ q ] ; } } System . out . print ( sum + " ▁ " ) ; } System . out . println ( ) ; } }
static void findCount ( int n , int sum ) { long start = Math . pow ( 10 , n - 1 ) ; long end = Math . pow ( 10 , n ) - 1 ; int count = 0 ; for ( int i = start ; i <= end ; i ++ ) { int cur = 0 ; int temp = i ; while ( temp != 0 ) { cur += temp % 10 ; temp = temp / 10 ; } if ( cur == sum ) count ++ ; i ++ ; } else System . out . println ( count ) ; }
static int countGroups ( int position , int previous_sum , int length , int num [ ] ) { if ( position == length ) return 1 ; if ( dp [ position ] [ previous_sum ] != - 1 ) return dp [ position ] [ previous_sum ] ; int res = 0 ; int sum = 0 ; for ( int i = 0 ; i < position ; i ++ ) { sum += ( num [ i ] - '0' ) ; if ( sum >= previous_sum ) res += countGroups ( i + 1 , sum , length , num ) ; } dp [ position ] [ previous_sum ] = res ; } return res ; }
static int intersection ( int n ) { return n * ( n - 1 ) ; }
static int findSum ( int n ) { n -- ; int sum = 0 ; sum += ( n * ( n + 1 ) ) / 2 ; sum += ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; return sum ; }
static int findRepeatingElement ( int [ ] arr , int low , int high ) { if ( low > high ) return - 1 ; int mid = ( low + high ) / 2 ; if ( arr [ mid ] != mid + 1 ) { if ( mid > 0 && arr [ mid ] == arr [ mid - 1 ] ) return mid ; return findRepeatingElement ( arr , low , mid - 1 ) ; } return findRepeatingElement ( arr , mid + 1 , high ) ; }
static int smallest ( int x , int y , int z ) { int c = 0 ; while ( x && y && z ) { x = x - 1 ; y = y - 1 ; z = z - 1 ; c ++ ; } return c ; }
static int maxAverageOfPath ( int cost [ ] [ ] , int N ) { int [ ] [ ] dp = new int [ N ] [ N + 1 ] ; dp [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) { for ( int j = 1 ; j < N ; j ++ ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + cost [ i ] [ j ] ; } } for ( int i = 1 ; i < N ; i ++ ) { dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + cost [ 0 ] [ 0 ] ; } for ( int j = 1 ; j < N ; j ++ ) { dp [ i ] [ j ] = Math . max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) + cost [ i ] [ j ] ; } } return dp [ N - 1 ] [ N - 1 ] / ( 2 * N - 1 ) ; }
static int countPairsWithDiffK ( int arr [ ] , int n , int k ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] - arr [ j ] == k || arr [ j ] - arr [ i ] == k ) count ++ ; } return count ; }
static int longLenSub ( int arr [ ] , int n ) { int len1 = 0 ; int um [ ] = new int [ arr . length ] ; int longLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { len1 = 0 ; if ( arr [ i - 1 ] in um && len1 < um [ arr [ i ] - 1 ] ) len1 = um [ arr [ i ] - 1 ] ; if ( arr [ i ] + 1 in um && len1 < um [ arr [ i ] + 1 ] ) len1 = um [ arr [ i ] + 1 ] ; um [ arr [ i ] ] = len1 + 1 ; if ( longLen < um [ arr [ i ] ] ) longLen = um [ arr [ i ] ] ; } return longLen ; }
static boolean isPrime ( int n , int i ) { if ( n <= 2 ) return true if ( n == 2 ) else false ; if ( n % i == 0 ) return false ; if ( i * i > n ) return true ; return isPrime ( n , i + 1 ) ; }
static int computeLastDigit ( int A , int B ) { int variable = 1 ; if ( A == B ) return 1 ; else if ( ( B - A ) >= 5 ) return 0 ; else { for ( int i = A + 1 ; i <= B ; i ++ ) variable *= ( i % 10 ) ; return variable % 10 ; } }
static int minOperation ( int arr [ ] [ ] ) { int ans = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { for ( int j = M - 1 ; j >= 0 ; j -- ) { if ( arr [ i ] [ j ] == 0 ) ans ++ ; for ( int k = i + 1 ; k <= j ; k ++ ) { for ( int h = j + 1 ; h <= j ; h ++ ) { if ( arr [ k ] [ h ] == 1 ) arr [ k ] [ h ] = 0 ; else arr [ k ] [ h ] = 1 ; } } } return ans ; }
static int nextPowerOf2 ( int n ) { int p = 1 ; if ( n && ! ( n & ( n - 1 ) ) ) return n ; while ( p < n ) p <<= 1 ; return p ; }
static int getMinDiff ( int arr [ ] , int n , int k ) { if ( n == 1 ) return 0 ; Arrays . sort ( arr ) ; int ans = arr [ n - 1 ] - arr [ 0 ] ; int small = arr [ 0 ] + k ; int big = arr [ n - 1 ] - k ; if ( small > big ) { small , big = big , small ; } for ( int i = 1 ; i < n ; i ++ ) { int subtract = arr [ i ] - k ; int add = arr [ i ] + k ; if ( subtract >= small || add <= big ) continue ; if ( big - subtract <= add - small ) small = subtract ; else big = add ; } return Math . min ( ans , big - small ) ; }
public static int numberofways ( int n , int m ) { int [ ] [ ] dp = new int [ n + 2 ] [ n + 2 ] ; dp [ 0 ] [ n + 1 ] = 1 ; for ( int k = n ; k <= m - 2 ; k ++ ) { for ( int i = n + 1 ; i <= n ; i ++ ) { dp [ i ] [ k ] = dp [ i ] [ k + 1 ] ; if ( i - k >= 0 ) dp [ i ] [ k ] = ( dp [ i ] [ k ] + dp [ i - k ] [ k ] ) ; } } return dp [ n ] [ m ] ; }
static boolean check ( int n ) { return 1162261467 % n == 0 ; }
static int sequence ( int n ) { if ( n == 1 || n == 2 ) return 1 ; else return sequence ( sequence ( n - 1 ) ) + sequence ( n - sequence ( n - 1 ) ) ; }
static void generate_derangement ( int N ) { int [ ] S = new int [ N + 1 ] ; for ( int i = 1 ; i <= N ; i ++ ) S [ i ] = i ; int [ ] D = new int [ N + 1 ] ; for ( int i = 1 ; i <= N ; i ++ ) D [ i ] = i ; for ( int i = 1 ; i <= N ; i ++ ) { System . out . print ( S [ i ] + " ▁ " ) ; } System . out . println ( ) ; } for ( int i = 1 ; i <= N ; i ++ ) System . out . print ( D [ i ] + " ▁ " ) ; }
static int countTriangle ( int g [ ] [ ] , int isDirected ) { int nodes = g . length ; int count_Triangle = 0 ; for ( int i = 0 ; i < nodes ; i ++ ) { for ( int j = 0 ; j < nodes ; j ++ ) { for ( int k = 0 ; k < nodes ; k ++ ) { if ( i != j && i != k && j != k && g [ i ] [ j ] && g [ j ] [ k ] && g [ k ] [ i ] ) count_Triangle ++ ; } } } return count_Triangle / 3 if ( isDirected ) count_Triangle / 6 ; }
static int findHeight ( int parent [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int p = i ; int current = 1 ; while ( parent [ p ] != - 1 ) current ++ ; p = parent [ p ] ; res = Math . max ( res , current ) ; } return res ; }
static int leonardo ( int n ) { if ( n == 0 || n == 1 ) return 1 ; return leonardo ( n - 1 ) + leonardo ( n - 2 ) + 1 ; }
static void findLargestPlus ( int mat [ ] [ ] ) { int [ ] [ ] left = new int [ N ] [ N ] ; int [ ] [ ] right = new int [ N ] [ N ] ; int top [ ] [ ] = new int [ N ] [ N ] ; int bottom [ ] [ ] = new int [ N ] [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 1 ; j < N ; j ++ ) { left [ i ] [ j ] = mat [ i ] [ j - 1 ] + 1 ; right [ i ] [ N - 1 ] = mat [ i ] [ N - 1 ] ; } for ( int i = 0 ; i < N ; i ++ ) { top [ 0 ] [ i ] = mat [ 0 ] [ i ] ; bottom [ N - 1 ] [ i ] = mat [ i ] [ N - 1 ] ; left [ i ] [ 0 ] = mat [ i ] [ 0 ] ; right [ i ] [ N - 1 ] = mat [ i ] [ N - 1 ] ; } for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 1 ; j < N ; j ++ ) { if ( mat [ i ] [ j ] == 1 ) { top [ j ] [ i ] = top [ j - 1 ] [ i ] + 1 ; } else { top [ j ] [ i ] = 0 ; } } } int n = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 1 ; j < N ; j ++ ) { if ( mat [ i ] [ j ] == 1 ) { bottom [ j ] [ i ] = bottom [ j + 1 ] [ i ] + 1 ; } else { bottom [ j ] [ i ] = 0 ; } } if ( mat [ i ] [ j ] == 1 ) { right [ i ] [ j ] = right [ i ] [ j + 1 ] + 1 ; } else { right [ i ] [ j ] = 0 ; } } n = N - 1 - j ; } } return ; }
static boolean HalfDiagonalSums ( int mat [ ] [ ] , int n ) { int diag1_left = 0 , diag1_right = 0 ; int diag2_left = 0 , diag2_right = 0 ; int i = 0 , j = n - 1 ; while ( i < n ) { if ( i < n / 2 ) { diag1_left += mat [ i ] [ i ] ; diag2_left += mat [ j ] [ i ] ; } else if ( i > n / 2 ) { diag1_right += mat [ i ] [ i ] ; diag2_right += mat [ j ] [ i ] ; } i ++ ; j -- ; } return ( diag1_left == diag2_right && diag2_right == diag2_left && diag1_right == diag2_left && diag2_right == mat [ n / 2 ] [ n / 2 ] ) ; }
static int sumAtKthLevel ( char tree [ ] , int k ) { int level = - 1 ; int sum = 0 ; int n = tree . length ; for ( int i = 0 ; i < n ; i ++ ) { if ( tree [ i ] == ' ( ' ) level ++ ; else if ( tree [ i ] == ' ) ' level -- ; else { if ( level == k ) sum += ( tree [ i ] - '0' ) ; } } return sum ; }
static void LeibnizHarmonicTriangle ( int n ) { int [ ] [ ] C = new int [ n + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= Math . min ( i , n ) ; j ++ ) { if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) ; } } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) { System . out . print ( i * C [ i - 1 ] [ j - 1 ] + " ▁ " ) ; } System . out . println ( ) ; } }
static int countWays ( String s ) { int [ ] count = new int [ 26 ] ; for ( int x = 0 ; x < s . length ( ) ; x ++ ) { count [ x - ' a ' ] = ( count [ x - ' a ' ] ) + 1 ; } count [ s . charAt ( 0 ) - ' a ' ] = 1 ; int ans = 1 ; for ( int i = 0 ; i < 26 ; i ++ ) if ( count [ i ] != 0 ) ans *= count [ i ] ; return ans ; }
static int countWays ( int n , int m ) { int [ ] count = new int [ n + 2 ] ; count . add ( 0 ) ; count [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i > m ) count [ i ] = count [ i - 1 ] + count [ i - m ] ; else if ( i < m ) count [ i ] = 1 ; else count [ i ] = 2 ; } return count [ n ] ; }
static void printCommonElements ( int [ ] [ ] mat ) { Map < Integer , Integer > myMap = new HashMap < > ( ) ; for ( int j = 0 ; j < N ; j ++ ) myMap . put ( mat [ 0 ] [ j ] , 1 ) ; for ( int i = 1 ; i < M ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) myMap . put ( mat [ i ] [ j ] , i + 1 ) ; if ( i == M - 1 ) System . out . print ( mat [ i ] [ j ] + " ▁ " ) ; } } }
static int floorSearch ( int [ ] arr , int low , int high , int x ) { if ( low > high ) return - 1 ; if ( x >= arr [ high ] ) return high ; int mid = ( low + high ) / 2 ; if ( arr [ mid ] == x ) return mid ; if ( mid > 0 && arr [ mid - 1 ] <= x && x < arr [ mid ] ) return mid - 1 ; if ( x < arr [ mid ] ) return floorSearch ( arr , low , mid - 1 , x ) ; if ( x < arr [ mid ] ) return floorSearch ( arr , low , mid + 1 , x ) ; return floorSearch ( arr , low , mid + 1 , high , x ) ; }
static int nextPowerOf2 ( int n ) { int p = 1 ; if ( n && ! ( n & ( n - 1 ) ) ) return n ; while ( p < n ) p <<= 1 ; return p ; }
static void printkthnode ( int adj [ ] [ ] , int wt , int n , int k ) { for ( int i = 0 ; i < n ; i ++ ) Arrays . sort ( adj [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( adj [ i ] . length >= k ) System . out . print ( adj [ i ] [ adj [ i ] . length - k ] [ 1 ] + " ▁ " ) ; else System . out . print ( - 1 + " ▁ " ) ; } }
static void longest ( int [ ] a , int n , int k ) { int freq [ ] = new int [ n ] ; int start = 0 , end = 0 , now = 0 , l = 0 ; for ( int i = 0 ; i < n ; i ++ ) { freq [ a [ i ] ] ++ ; if ( freq [ a [ i ] ] == 1 ) now ++ ; while ( now > k ) { freq [ a [ l ] ] -- ; if ( freq [ a [ l ] ] == 0 ) now -- ; l ++ ; } if ( i - l + 1 >= end - start + 1 ) { end = i ; start = l ; } } for ( int i = start ; i <= end ; i ++ ) System . out . print ( a [ i ] + " ▁ " ) ; }
static int minimumflip ( int mat [ ] [ ] , int n ) { int flip = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) flip ++ ; } return flip ; }
static int breakSum ( int n ) { if ( n == 0 || n == 1 ) return n ; return Math . max ( breakSum ( n / 2 ) + breakSum ( n / 3 ) + breakSum ( n / 4 ) , n ) ; }
static int countPairs ( int arr1 [ ] , int arr2 [ ] , int m , int n , int x ) { int count = 0 ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( arr1 [ i ] + arr2 [ j ] == x ) count ++ ; return count ; }
static void alternateSubarray ( boolean arr [ ] , int n ) { int [ ] len = new int [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) len . add ( 0 ) ; len [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] ^ arr [ i + 1 ] == true ) len [ i ] = len [ i + 1 ] + 1 ; else len [ i ] = 1 ; } for ( int i = 0 ; i < n ; i ++ ) System . out . print ( len [ i ] + " ▁ " ) ; }
static void subsequence ( char s [ ] , char t [ ] , int n , int k ) { int i ; int last = 0 , cnt = 0 ; int new_last = 0 , size = 0 ; String str = " zyxwvutsrqponmlkjihgfedcba " ; for ( ch = 0 ; ch < str . length ( ) ; ch ++ ) { cnt ++ ; if ( cnt >= k ) { for ( i = last ; i < n ; i ++ ) { if ( s [ i ] == ch ) { cnt ++ ; } } if ( cnt >= k ) { for ( i = last ; i < n ; i ++ ) { if ( s [ i ] == ch ) { t [ size ] = ch ; new_last = i ; size ++ ; } } last = new_last ; } }
static int maxLen ( int arr [ ] ) { int max_len = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { int curr_sum = 0 ; for ( int j = i ; j < arr . length ; j ++ ) { curr_sum += arr [ j ] ; if ( curr_sum == 0 ) max_len = j - i + 1 ; } } return max_len ; }
static int findWays ( int m , int n , int x ) { int table [ ] [ ] = new int [ n + 1 ] [ x + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) table [ i ] [ 0 ] = 1 ; for ( int j = 1 ; j <= x ; j ++ ) table [ 1 ] [ j ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= x ; j ++ ) { for ( int k = 1 ; k <= Math . min ( m + 1 , j ) ; k ++ ) table [ i ] [ j ] += table [ i - 1 ] [ j - k ] ; } } return table [ - 1 ] [ - 1 ] ; }
static boolean checkCorrectOrNot ( String s ) { int [ ] count = new int [ MAX_CHAR ] ; int n = s . length ( ) ; if ( n == 1 ) return true ; for ( int i = 0 , j = n - 1 ; i < j ; i ++ , j -- ) { count [ s . charAt ( i ) - ' a ' ] ++ ; count [ s . charAt ( j ) - ' a ' ] -- ; } for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { if ( count [ i ] != 0 ) return false ; } return true ; }
static int findnumberofTriangles ( int arr [ ] ) { int n = arr . length ; Arrays . sort ( arr ) ; int count = 0 ; for ( int i = 0 ; i < n - 2 ; i ++ ) { int k = i + 2 ; for ( int j = i + 1 ; j < n ; j ++ ) { while ( k < n && arr [ i ] + arr [ j ] > arr [ k ] ) k ++ ; if ( k > j ) count += k - j - 1 ; } } return count ; }
static int countWays ( int n ) { int [ ] A = new int [ n + 1 ] ; int [ ] B = new int [ n + 1 ] ; A [ 0 ] = 1 ; A [ 1 ] = 0 ; B [ 0 ] = 0 ; B [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) A [ i ] = A [ i - 2 ] + 2 * B [ i - 1 ] ; for ( int i = 2 ; i <= n ; i ++ ) A [ i ] = A [ i - 2 ] + 2 * B [ i - 1 ] ; B [ i ] = A [ i - 1 ] + B [ i - 2 ] ; return A [ n ] ; }
static int lcs ( int X [ ] , int Y [ ] , int m , int n ) { if ( m == 0 || n == 0 ) return 0 ; else if ( X [ m - 1 ] == Y [ n - 1 ] ) return 1 + lcs ( X , Y , m - 1 , n - 1 ) ; else return Math . max ( lcs ( X , Y , m , n - 1 ) , lcs ( X , Y , m - 1 , n ) ) ; }
static int minValue ( int A [ ] , int B [ ] , int n ) { Arrays . sort ( A ) ; Arrays . sort ( B ) ; int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) result += A [ i ] * B [ n - i - 1 ] ; return result ; }
static boolean isOneFlip ( String str ) { int sum = 0 ; int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) sum += ( str . charAt ( i ) - '0' ) ; return ( sum == n - 1 || sum == 1 ) ; }
static int MatrixChainOrder ( int p [ ] , int i , int j ) { if ( i == j ) return 0 ; int _min = 2147483647 ; for ( int k = i ; k < j ; k ++ ) { int count = MatrixChainOrder ( p , i , k ) + MatrixChainOrder ( p , k + 1 , j ) + p [ i - 1 ] * p [ k ] * p [ j ] ; if ( count < _min ) _min = count ; } return _min ; }
static int multiply ( int x , int y ) { if ( y == 0 ) return 0 ; if ( y > 0 ) return ( x + multiply ( x , y - 1 ) ) ; if ( y < 0 ) return - multiply ( x , - y ) ; return 0 ; }
static int countP ( int n , int k ) { int [ ] [ ] dp = new int [ n + 1 ] [ k + 1 ] ; for ( int i = 0 ; i <= k ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { dp [ i ] [ j ] = 0 ; } } for ( int i = 0 ; i <= k ; i ++ ) { dp [ 0 ] [ i ] = 0 ; } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= k ; j ++ ) { if ( j == 1 || i == j ) { dp [ i ] [ j ] = 1 ; } else { dp [ i ] [ j ] = ( j * dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] ) ; } } } return dp [ n ] [ k ] ; }
static void worstFit ( int blockSize [ ] , int m , int processSize [ ] , int n ) { int [ ] allocation = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { int wstIdx = - 1 ; for ( int j = 0 ; j < m ; j ++ ) { if ( blockSize [ j ] >= processSize [ i ] ) { wstIdx = j ; } else if ( blockSize [ wstIdx ] < blockSize [ j ] ) { wstIdx = j ; } } if ( wstIdx != - 1 ) { allocation [ i ] = wstIdx ; blockSize [ wstIdx ] -= processSize [ i ] ; } } System . out . println ( " Process ▁ No . ▁ Process ▁ Size ▁ Block ▁ No . " ) ; for ( int i = 0 ; i < n ; i ++ ) { System . out . println ( i + 1 + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " + processSize [ i ] + " ▁ ▁ ▁ ▁ " ) ; if ( allocation [ i ] != - 1 ) System . out . println ( allocation [ i ] + " Not ▁ Allocated " ) ; } else { System . out . println ( " Not ▁ Allocated " ) ; } }
static int maxvolume ( int s ) { int length = s / 3 ; s -= length ; int breadth = s / 2 ; int height = s - breadth ; return length * breadth * height ; }
static int findLength ( String str ) { int n = str . length ( ) ; int maxlen = 0 ; int [ ] [ ] sum = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) sum [ i ] [ i ] = str . charAt ( i ) ; for ( int length = 2 ; length <= n ; length ++ ) { for ( int i = 0 ; i < n - length + 1 ; i ++ ) { int j = i + length - 1 ; int k = length / 2 ; sum [ i ] [ j ] = ( sum [ i ] [ j - k ] + sum [ j - k + 1 ] [ j ] ) ; if ( length % 2 == 0 && sum [ i ] [ j - k ] == sum [ ( j - k + 1 ) ] [ j ] && length > maxlen ) maxlen = length ; } } return maxlen ; }
static int subArraySum ( int [ ] arr , int n , int sum ) { int curr_sum = arr [ 0 ] ; int start = 0 ; int i = 1 ; while ( i <= n ) { while ( curr_sum > sum && start < i - 1 ) { curr_sum = curr_sum - arr [ start ] ; start ++ ; } if ( curr_sum == sum ) { System . out . println ( " Sum ▁ found ▁ between ▁ indexes ▁ " + ( start - 1 ) ) ; return 1 ; } if ( i < n ) { curr_sum = curr_sum + arr [ i ] ; } i ++ ; } System . out . println ( " No ▁ subarray ▁ found " ) ; return 0 ; }
static void commonCharacters ( String str [ ] , int n ) { boolean [ ] prim = new boolean [ MAX_CHAR ] ; boolean [ ] sec = new boolean [ MAX_CHAR ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < str . length ( ) ; j ++ ) { if ( prim [ str . charAt ( i ) . charAt ( j ) - ' a ' ] == false ) sec [ str . charAt ( i ) . charAt ( j ) - ' a ' ] = true ; } for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { if ( prim [ i ] ) { System . out . print ( " % c ▁ " + ( i + ' a ' ) ) ; } } } for ( int i = 0 ; i < 26 ; i ++ ) { if ( prim [ i ] ) { System . out . print ( " % c ▁ " + ( i + ' a ' ) ; } } }
static boolean canMakeStr2 ( char s1 [ ] , char s2 [ ] ) { int [ ] count = new int [ s1 . length ] ; for ( int i = 0 ; i < s1 . length ; i ++ ) { count [ s1 [ i ] ] ++ ; } for ( int i = 0 ; i < s2 . length ; i ++ ) { if ( count [ s2 [ i ] ] == 0 ) return false ; count [ s2 [ i ] ] -- ; } return true ; }
static void generateSquare ( int n ) { int [ ] [ ] magicSquare = new int [ n ] [ n ] ; int i , j , num ; for ( i = 0 ; i <= n / 2 ; i ++ ) { for ( j = n - 1 ; j <= n ; j ++ ) { if ( i == - 1 && j == n ) i = 0 ; else { if ( j == n ) j = n - 2 ; i = 0 ; } else { if ( i < 0 ) i = n - 1 ; } else { if ( magicSquare [ int ( i ) ] [ int ( j ) ] == 0 ) { j = j - 2 ; i = i + 1 ; continue ; } else { magicSquare [ int ( i ) ] [ int ( j ) ] = num ; num = num + 1 ; } } } System . out . println ( " Magic ▁ Squre ▁ for ▁ n ▁ = " + n ) ; for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < n ; j ++ ) { System . out . print ( " % 2d ▁ " + magicSquare [ i ] [ j ] ) ; if ( j == n - 1 ) System . out . println ( ) ; } } }
static int count ( int [ ] a , int [ ] b , int m , int n ) { if ( ( m == 0 && n == 0 ) || n == 0 ) return 1 ; if ( m == 0 ) return 0 ; if ( b [ m - 1 ] == b [ n - 1 ] ) return count ( a , b , m - 1 , n - 1 ) + count ( a , b , m - 1 , n ) ; else return count ( a , b , m - 1 , n ) ; }
static int numofArray ( int n , int m ) { int [ ] [ ] dp = new int [ MAX ] [ MAX ] ; int [ ] [ ] mu = new int [ MAX ] [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) { for ( int j = 0 ; j < MAX ; j ++ ) { dp [ i ] [ j ] = 0 ; mu [ i ] [ j ] = 0 ; } } for ( int i = 1 ; i < m + 1 ; i ++ ) { for ( int j = 2 * i ; j <= m + 1 ; j ++ ) { di [ j ] . add ( i ) ; mu [ i ] . add ( j ) ; } di [ i ] . add ( i ) ; } for ( int i = 1 ; i < n + 1 ; i ++ ) { for ( int j = 1 ; j <= m + 1 ; j ++ ) { dp [ i ] [ j ] = 0 ; for ( int x = di [ j ] ; x <= mu [ j ] ; x ++ ) { dp [ i ] [ j ] += dp [ i - 1 ] [ x ] ; } } } int ans = 0 ; for ( int i = 1 ; i < m + 1 ; i ++ ) ans += dp [ n ] [ i ] ; di [ i ] . clear ( ) ; mu [ i ] . clear ( ) ; } return ans ; }
static int countOnes ( int arr [ ] , int low , int high ) { if ( high >= low ) { int mid = ( low + high ) / 2 ; if ( mid == high || arr [ mid + 1 ] == 0 ) && ( arr [ mid ] == 1 ) ) return mid + 1 ; if ( arr [ mid ] == 1 ) return countOnes ( arr , ( mid + 1 ) , high ) ; return countOnes ( arr , low , mid - 1 ) ; } return 0 ; }
static int ceilSearch ( int arr [ ] , int low , int high , int x ) { if ( x <= arr [ low ] ) return low ; if ( x > arr [ high ] ) return - 1 ; int mid = ( low + high ) / 2 ; if ( arr [ mid ] == x ) return mid ; else if ( arr [ mid ] < x ) { if ( mid + 1 <= high && x <= arr [ mid + 1 ] ) return mid + 1 ; else return ceilSearch ( arr , mid + 1 , high , x ) ; } else if ( arr [ mid ] < x ) { if ( mid + 1 <= low && arr [ mid + 1 ] == x ) return mid ; else if ( mid - 1 >= low && x > arr [ mid - 1 ] ) return mid ; else return ceilSearch ( arr , low , mid - 1 , x ) ; } }
static String decToBin ( int n ) { if ( n == 0 ) return "0" ; String bin = " " ; while ( n > 0 ) { if ( n & 1 == 0 ) bin = '0' + bin ; else bin = '1' + bin ; n = n >> 1 ; } return bin ; }
static void printNos ( int n ) { if ( n > 0 ) System . out . print ( n - 1 + " ▁ " ) ; }
static void prefixSum2D ( int a [ ] [ ] ) { int [ ] [ ] psa = new int [ R ] [ C ] ; for ( int i = 0 ; i < R ; i ++ ) { psa [ i ] [ 0 ] = a [ 0 ] [ i ] ; } for ( int i = 1 ; i < C ; i ++ ) { psa [ 0 ] [ i ] = ( psa [ 0 ] [ i - 1 ] + a [ 0 ] [ i ] ) ; } for ( int i = 0 ; i < R ; i ++ ) { psa [ i ] [ 0 ] = ( psa [ i - 1 ] [ 0 ] + a [ i ] [ 0 ] ) ; } for ( int i = 1 ; i < R ; i ++ ) { for ( int j = 1 ; j < C ; j ++ ) { psa [ i ] [ j ] = ( psa [ i - 1 ] [ j ] + psa [ i ] [ j - 1 ] - psa [ i - 1 ] [ j - 1 ] + a [ i ] [ j ] ) ; } } for ( int i = 0 ; i < R ; i ++ ) { for ( int j = 0 ; j < C ; j ++ ) { System . out . print ( psa [ i ] [ j ] + " ▁ " ) ; } System . out . println ( ) ; } }
static int eulerian ( int n , int m ) { if ( m >= n || n == 0 ) return 0 ; if ( m == 0 ) return 1 ; return ( ( n - m ) * eulerian ( n - 1 , m - 1 ) + ( m + 1 ) * eulerian ( n - 1 , m ) ) ; }
static int findSubarraySum ( int arr [ ] , int n ) { int res = 0 ; Map < Integer , Integer > m = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int sum = 0 ; for ( int j = i ; j < n ; j ++ ) sum += arr [ j ] ; m . put ( sum , m . get ( sum ) + 1 ) ; } for ( int x = 0 ; x < n ; x ++ ) if ( m . containsKey ( x ) ) res += x ; return res ; }
static boolean isMultipleOf3 ( int n ) { int odd_count = 0 , even_count = 0 ; if ( n < 0 ) n = - n ; if ( n == 0 ) return 1 ; if ( n == 1 ) return 0 ; while ( n ) { if ( n & 1 ) odd_count ++ ; if ( n & 2 ) even_count ++ ; n = n >> 2 ; } return isMultipleOf3 ( Math . abs ( odd_count - even_count ) ) ; }
static int longestSubsequenceCommonSegment ( int k , int s1 [ ] , int s2 [ ] ) { int n = s1 . length , m = s2 . length ; int cnt [ ] [ ] = new int [ n + 1 ] [ m + 1 ] ; int lcs [ ] [ ] = new int [ n + 1 ] [ m + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { lcs [ i ] [ j ] = Math . max ( lcs [ i - 1 ] [ j ] , lcs [ i ] [ j - 1 ] ) ; if ( s1 [ i - 1 ] == s2 [ j - 1 ] ) cnt [ i ] [ j ] = cnt [ i - 1 ] [ j - 1 ] + 1 ; if ( cnt [ i ] [ j ] >= k ) lcs [ i ] [ j ] = Math . max ( lcs [ i ] [ j ] , lcs [ i - a ] [ j - a ] + a ) ; } } } return lcs [ n ] [ m ] ; }
static int areaSquare ( int side ) { int area = side * side ; return area ; }
static void findpath ( int graph [ ] [ ] ) { int n = graph . length ; int numofadj [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) numofadj . add ( graph [ i ] [ 0 ] ) ; int startpoint = 0 , numofodd = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( numofadj [ i ] % 2 == 1 ) { numofodd ++ ; startpoint = i ; } } Stack < Integer > stack = new Stack < > ( ) ; Stack < Integer > path = new Stack < > ( ) ; int cur = startpoint ; while ( stack != null || sum ( graph [ cur ] ) == 0 ) { path . add ( cur + 1 ) ; cur = stack . pop ( - 1 ) ; } else { for ( int i = 0 ; i < n ; i ++ ) { if ( graph [ cur ] [ i ] == 1 ) { stack . add ( cur ) ; graph [ cur ] [ i ] = 0 ; graph [ i ] [ cur ] = 0 ; cur = i ; break ; } } } for ( int ele : path ) System . out . print ( ele + " - > ▁ " ) ; System . out . print ( cur + 1 ) ; }
static int lcsOf3 ( int i , int j , int k ) { if ( i == - 1 || j == - 1 || k == - 1 ) return 0 ; if ( dp [ i ] [ j ] [ k ] != - 1 ) return dp [ i ] [ j ] [ k ] ; if ( X [ i ] == Y [ j ] && Y [ j ] == Z [ k ] ) return 1 + lcsOf3 ( i - 1 , j - 1 , k - 1 ) ; else { dp [ i ] [ j ] [ k ] = 1 + lcsOf3 ( i - 1 , j - 1 , k - 1 ) ; return dp [ i ] [ j ] [ k ] ; } }
static void findLarger ( int arr [ ] , int n ) { List < Integer > x = Arrays . stream ( arr ) ; Arrays . sort ( x ) ; for ( int i = 0 ; i < n / 2 ; i ++ ) System . out . println ( x [ i ] ) ; }
static int spiralDiaSum ( int n ) { if ( n == 1 ) return 1 ; return 4 * n * n - 6 * n + 6 + spiralDiaSum ( n - 2 ) ; }
static int countOccurrences ( int arr [ ] , int n , int x ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( x == arr [ i ] ) res ++ ; return res ; }
static int sumBetweenTwoKth ( int arr [ ] , int n , int k1 , int k2 ) { Arrays . sort ( arr ) ; int result = 0 ; for ( int i = k1 ; i <= k2 ; i ++ ) result += arr [ i ] ; return result ; }
static int calculate ( int [ ] a ) { int maximum = Arrays . stream ( a ) . max ( ) . getAsInt ( ) ; int [ ] frequency = new int [ maximum + 1 ] ; for ( int i = 0 ; i <= maximum ; i ++ ) frequency [ i ] ++ ; int answer = 0 ; for ( int i = 0 ; i <= frequency . length ; i ++ ) answer += i * ( i - 1 ) / 2 ; return answer ; }
static long doublefactorial ( long n ) { long res = 1 ; for ( int i = n ; i >= 0 ; i -- ) { if ( i == 0 || i == 1 ) return res ; else res *= i ; } return res ; }
static int lcs ( int X [ ] , int Y [ ] , int m , int n ) { if ( m == 0 || n == 0 ) return 0 ; else if ( X [ m - 1 ] == Y [ n - 1 ] ) return 1 + lcs ( X , Y , m - 1 , n - 1 ) ; else return Math . max ( lcs ( X , Y , m , n - 1 ) , lcs ( X , Y , m - 1 , n ) ) ; }
static int maxProductSubset ( int a [ ] , int n ) { if ( n == 1 ) return a [ 0 ] ; int max_neg = - 999999999999 ; int count_neg = 0 , count_zero = 0 ; int prod = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) { count_zero ++ ; continue ; } if ( a [ i ] < 0 ) { count_neg ++ ; max_neg = Math . max ( max_neg , a [ i ] ) ; } prod *= a [ i ] ; if ( count_zero == n ) return 0 ; if ( count_neg & 1 ) { if ( count_neg == 1 && count_zero > 0 && count_zero + count_neg == n ) return 0 ; prod = prod / max_neg ; } return prod ; }
static int offeringNumber ( int n , int templeHeight [ ] ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int left = 0 , right = 0 ; for ( int j = i - 1 ; j >= 0 ; j -- ) { if ( templeHeight [ j ] < templeHeight [ j + 1 ] ) left ++ ; else right ++ ; } sum += Math . max ( right , left ) + 1 ; } return sum ; }
static int sumNodes ( int l ) { long leafNodeCount = ( long ) Math . pow ( 2 , l - 1 ) ; int [ ] [ ] vec = new int [ l ] [ leafNodeCount + 1 ] ; for ( int i = 1 ; i <= leafNodeCount ; i ++ ) vec [ i ] [ 0 ] = i ; for ( int i = 1 ; i <= l - 2 ; i ++ ) { vec [ l - 1 ] . add ( i ) ; } for ( int i = l - 2 ; i >= 0 ; i -- ) { int k ; for ( k = 0 ; k < ( vec [ i + 1 ] ) . length - 1 ; k ++ ) vec [ i ] . add ( vec [ i + 1 ] [ k ] + vec [ i + 1 ] [ k + 1 ] ) ; } int sum = 0 ; for ( int i = 0 ; i <= l ; i ++ ) for ( int j = 0 ; j < vec [ i ] . length ; j ++ ) sum += vec [ i ] [ j ] ; return sum ; }
static String constructPalin ( String str , int l ) { ArrayList < Character > str = new ArrayList < Character > ( ) ; int i = - 1 , j = l ; while ( i < j ) { if ( str . charAt ( i ) == str . charAt ( j ) && str . charAt ( i ) != ' * ' ) continue ; else if ( str . charAt ( i ) == str . charAt ( j ) && str . charAt ( i ) == ' * ' ) { str . insert ( i , ' a ' ) ; string . insert ( j , ' a ' ) ; continue ; } else if ( str . charAt ( i ) == str . charAt ( j ) ) { str . insert ( i , ' a ' ) ; str . insert ( j , ' a ' ) ; continue ; } else if ( str . charAt ( i ) == ' * ' ) str . insert ( i , str . charAt ( j ) ) ; else if ( str . charAt ( j ) == ' * ' ) str . insert ( j , str . charAt ( i ) ) ; continue ; } System . out . println ( " Not ▁ Possible " ) ; return " " ; }
static int countPairs ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] == arr [ j ] ) ans ++ ; } return ans ; }
static int russianPeasant ( int a , int b ) { int res = 0 ; while ( b > 0 ) { if ( b & 1 ) res += a ; a = a << 1 ; b = b >> 1 ; } return res ; }
static String encrypt ( String text , int s ) { String result = " " ; for ( int i = 0 ; i < text . length ( ) ; i ++ ) { char char = text . charAt ( i ) ; if ( char . isupper ( ) ) result += ( ( char ) + s - 65 ) % 26 + 65 ; else result += ( ( char ) + s - 97 ) % 26 + 97 ; } return result ; }
public static double distance ( double lat1 , double lat2 , double lon1 , double lon2 ) { lon1 = radians ( lon1 ) ; lon2 = radians ( lon2 ) ; lat1 = radians ( lat1 ) ; lat2 = radians ( lat2 ) ; dlon = lon2 - lon1 ; dlat = lat2 - lat1 ; a = sin ( dlat / 2 ) ** 2 + cos ( lat1 ) * cos ( lat2 ) * sin ( dlon / 2 ) ** 2 ; c = 2 * asin ( sqrt ( a ) ) ; r = 6371 ; return ( c * r ) ; }
static int evenFib ( int n ) { if ( n < 1 ) return n ; if ( n == 1 ) return 2 ; return ( ( 4 * evenFib ( n - 1 ) ) + evenFib ( n - 2 ) ) ; }
static int gcd ( int a , int b ) { if ( a == 0 ) return b ; if ( b == 0 ) return a ; int k = 0 ; while ( ( ( a | b ) & 1 ) == 0 ) { a = a >> 1 ; b = b >> 1 ; k ++ ; } while ( ( a & 1 ) == 0 ) { a = a >> 1 ; b = b >> 1 ; k ++ ; } while ( ( b & 1 ) == 0 ) { b = b >> 1 ; } if ( a != 0 ) { while ( ( b & 1 ) == 0 ) { b = b >> 1 ; } if ( a > b ) { int temp = a ; a = b ; b = temp ; } b = ( b - a ) ; } return ( a << k ) ; }
static boolean isPowerOfTwo ( int n ) { if ( n == 0 ) return false ; while ( n != 1 ) { if ( n % 2 != 0 ) return false ; n = n / 2 ; } return true ; }
static int findSum ( int n ) { int sm = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = i ; j <= n ; j ++ ) sm = sm + i * j ; return sm ; }
static long binomialCoeffSum ( int n ) { return ( 1 << n ) ; }
static int calculateSum ( int arr [ ] , int n ) { if ( n == 0 ) return 0 ; int s = arr [ 0 ] ; int value = s ; int sum = value ; for ( int i = 1 ; i < n ; i += 2 ) { s = arr [ i ] ; value = s ; operation = arr [ i - 1 ] [ 0 ] ; if ( operation == ' + ' ) sum += value ; else sum -= value ; } return sum ; }
static void checkPoint ( double radius , double x , double y , double percent , double startAngle ) { double endAngle = 360 / percent + startAngle ; double polarradius = Math . sqrt ( x * x + y * y ) ; double Angle = Math . atan ( y / x ) ; if ( Angle >= startAngle && Angle <= endAngle && polarradius < radius ) { System . out . println ( " Point ▁ ( " + x + " , " + y + " ) ▁ exist ▁ in ▁ the ▁ circle ▁ sector " ) ; } else { System . out . println ( " Point ▁ ( " + x + " , " + y + " ) does ▁ not ▁ exist ▁ in ▁ the ▁ circle ▁ sector " ) ; } }
static void printknapSack ( int W , int wt , int val [ ] , int n ) { int K [ ] [ ] = new int [ n + 1 ] [ W + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int w = 0 ; w <= W ; w ++ ) { if ( i == 0 || w == 0 ) K [ i ] [ w ] = 0 ; else if ( wt [ i - 1 ] <= w ) K [ i ] [ w ] = Math . max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] , K [ i - 1 ] [ w ] ) ; else K [ i ] [ w ] = K [ i - 1 ] [ w ] ; } } int res = K [ n ] [ W ] ; int w = W ; for ( int i = n ; i >= 0 ; i -- ) { if ( res <= 0 ) break ; if ( res == K [ i - 1 ] [ w ] ) continue ; else { System . out . print ( wt [ i - 1 ] ) ; res = res - val [ i - 1 ] ; w = w - wt [ i - 1 ] ; } } }
static int getTotalNumberOfSequences ( int m , int n ) { int [ ] [ ] T = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 || j == 0 ) T [ i ] [ j ] = 0 ; else if ( i < j ) T [ i ] [ j ] = 0 ; else if ( j == 1 ) T [ i ] [ j ] = i ; else { T [ i ] [ j ] = T [ i - 1 ] [ j ] + T [ i / 2 ] [ j - 1 ] ; } } } return T [ m ] [ n ] ; }
static int findSum ( int n ) { int arr [ ] [ ] = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) arr [ i ] [ j ] = Math . abs ( i - j ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) sum += arr [ i ] [ j ] ; return sum ; }
static String replace ( String s , char c1 , char c2 ) { int l = s . length ( ) ; for ( int i = 0 ; i < l ; i ++ ) { if ( s . charAt ( i ) == c1 ) s = s . substring ( 0 , i + c2 + s . charAt ( i + 1 ) ) ; else if ( s . charAt ( i ) == c2 ) s = s . substring ( 0 , i + c1 + s . charAt ( i + 1 ) ) ; } return s ; }
static int discreteLogarithm ( int a , int b , int m ) { int n = ( int ) Math . sqrt ( m ) + 1 ; int an = 1 ; for ( int i = 0 ; i < n ; i ++ ) an = ( an * a ) % m ; int value [ ] = new int [ n + 1 ] ; int cur = an ; for ( int i = 1 ; i <= n ; i ++ ) { if ( value [ cur ] == 0 ) value [ cur ] = i ; cur = ( cur * an ) % m ; } cur = b ; for ( int i = 0 ; i <= n ; i ++ ) { if ( value [ cur ] > 0 ) { int ans = value [ cur ] * n - i ; if ( ans < m ) return ans ; } cur = ( cur * a ) % m ; } return - 1 ; }
static int maxPrimeFactors ( int n ) { int maxPrime = - 1 ; while ( n % 2 == 0 ) maxPrime = 2 ; n >>= 1 ; for ( int i = 3 ; i <= Math . sqrt ( n ) ; i ++ ) { while ( n % i == 0 ) maxPrime = i ; n = n / i ; } if ( n > 2 ) maxPrime = n ; return maxPrime ; }
static boolean isPossibleTriangle ( int arr [ ] , int N ) { if ( N < 3 ) return false ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < N - 2 ; i ++ ) if ( arr [ i ] + arr [ i + 1 ] > arr [ i + 2 ] ) return true ; return false ; }
static int numOfIncSubseqOfSizeK ( int arr [ ] , int n , int k ) { int [ ] [ ] dp = new int [ k ] [ n ] ; for ( int i = 0 ; i < k ; i ++ ) { dp [ i ] = 0 ; } for ( int l = 1 ; l < k ; l ++ ) { for ( int i = 0 ; i < n ; i ++ ) { dp [ 0 ] [ i ] = 1 ; } } for ( int i = l ; i < n ; i ++ ) { dp [ i ] = 0 ; for ( int j = l - 1 ; j < i ; j ++ ) { if ( arr [ j ] < arr [ i ] ) { dp [ l ] [ i ] += dp [ l - 1 ] [ j ] ; } } } int sum = 0 ; for ( int i = 0 ; i < k - 1 ; i ++ ) { sum += dp [ k - 1 ] [ i ] ; } return sum ; }
static int solve ( int X [ ] , int Y [ ] , int l , int r , int k , int dp [ ] [ ] [ ] ) { if ( k == 0 ) return 0 ; if ( l < 0 || r < 0 ) return 1000000000 ; if ( dp [ l ] [ r ] [ k ] != - 1 ) return dp [ l ] [ r ] [ k ] ; int cost = ( ( X [ l ] - ' a ' ) ^ ( Y [ r ] - ' a ' ) ) ; dp [ l ] [ r ] [ k ] = Math . min ( cost , solve ( X , Y , l - 1 , r - 1 , k - 1 , dp ) ) ; return dp [ l ] [ r ] [ k ] ; }
static int remainderWith7 ( String num ) { int [ ] series = new int [ 6 ] ; int series_index = 0 ; int result = 0 ; for ( int i = ( num . length ( ) - 1 ) ; i >= 0 ; i -- ) { int digit = ( num . charAt ( i ) - 48 ) ; result += digit * series [ series_index ] ; series_index = ( series_index + 1 ) % 6 ; result %= 7 ; } if ( result < 0 ) result = ( result + 7 ) % 7 ; return result ; }
static boolean isSubSequence ( String str1 , String str2 , int m , int n ) { if ( m == 0 ) return true ; if ( n == 0 ) return false ; if ( str1 . charAt ( m - 1 ) == str2 . charAt ( n - 1 ) ) return isSubSequence ( str1 , str2 , m - 1 , n - 1 ) ; return isSubSequence ( str1 , str2 , m , n - 1 ) ; }
static int getRemainder ( int num , int divisor ) { return ( num - divisor * ( num / divisor ) ) ; }
static int minProductSubset ( int [ ] a , int n ) { if ( n == 1 ) return a [ 0 ] ; int max_neg = Integer . MIN_VALUE ; int min_pos = Integer . MIN_VALUE ; int count_neg = 0 , count_zero = 0 ; int prod = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) { count_zero ++ ; continue ; } if ( a [ i ] < 0 ) { count_neg ++ ; max_neg = Math . max ( max_neg , a [ i ] ) ; if ( a [ i ] > 0 ) min_pos = Math . min ( min_pos , a [ i ] ) ; prod = prod * a [ i ] ; } if ( count_zero == n || ( count_neg == 0 && count_zero > 0 ) ) return 0 ; if ( count_neg == 0 ) return min_pos ; if ( count_neg & 1 ) == 0 && count_neg != 0 ) prod = prod / max_neg ; return prod ; }
static int getSum ( int n ) { int sum = 0 ; while ( n != 0 ) { sum = sum + ( int ) n % 10 ; n = n / 10 ; } return sum ; }
static long findDigits ( int n ) { if ( n < 0 ) return 0 ; if ( n <= 1 ) return 1 ; double digits = 0 ; for ( int i = 2 ; i <= n ; i ++ ) digits += Math . log10 ( i ) ; return ( long ) Math . floor ( digits ) + 1 ; }
static void mergeTwoHalf ( int A [ ] , int n ) { Arrays . sort ( A ) ; Arrays . sort ( n ) ; }
static void fill0X ( int m , int n ) { int i , k , l ; int r = m , c = n ; int a [ ] [ ] = new int [ m ] [ n ] ; char x = ' X ' ; while ( k < m && l < n ) { for ( i = l ; i < n ; i ++ ) a [ k ] [ i ] = x ; l ++ ; } for ( i = k ; i < m ; i ++ ) { a [ i ] [ n - 1 ] = x ; } n -- ; if ( k < m ) { for ( i = n - 1 ; i >= l ; i -- ) { a [ m - 1 ] [ i ] = x ; } m -- ; } if ( l < n ) { for ( i = m - 1 ; i >= k ; i -- ) { a [ i ] [ l ] = x ; } l ++ ; } x = ' X ' if ( x == '0' ) { for ( i = 0 ; j < c ; j ++ ) System . out . print ( a [ i ] [ j ] + " ▁ " ) ; } System . out . println ( ) ; } }
static int minPerimeter ( int n ) { int l = Math . sqrt ( n ) ; double sq = l * l ; if ( sq == n ) return l * 4 ; else { int row = n / l ; int perimeter = 2 * ( l + row ) ; if ( n % l != 0 ) perimeter += 2 ; return perimeter ; } }
static void possibleOrNot ( double a1 , double a2 , double b1 , double b2 , double c1 , double c2 ) { double dis1 = ( pow ( b1 - a1 , 2 ) + pow ( b2 - a2 , 2 ) ) ; double dis2 = ( pow ( c1 - b1 , 2 ) + pow ( c2 - b2 , 2 ) ) ; if ( dis1 != dis2 ) System . out . println ( " No " ) ; else if ( b1 == ( ( a1 + c1 ) / 2.0 ) && b2 == ( ( a2 + c2 ) / 2.0 ) ) System . out . println ( " Yes " ) ; else { System . out . println ( " Yes " ) ; } }
static float slope ( float x1 , float y1 , float x2 , float y2 ) { return ( y2 - y1 ) / ( x2 - x1 ) ; }
static int CountSquares ( double a , double b ) { return ( Math . floor ( Math . sqrt ( b ) ) - Math . ceil ( Math . sqrt ( a ) ) + 1 ) ; }
static int countStrings ( int n , int k ) { int [ ] [ ] dp = new int [ n + 1 ] [ k + 1 ] ; dp [ 0 ] [ 0 ] = 1 ; dp [ 0 ] [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= k ; j ++ ) { dp [ i ] [ j ] [ 0 ] = ( dp [ i - 1 ] [ j ] [ 0 ] + dp [ i - 1 ] [ j ] [ 1 ] ) ; if ( j >= 1 ) dp [ i ] [ j ] [ 1 ] += dp [ i - 1 ] [ j - 1 ] [ 1 ] ; } } return dp [ n ] [ k ] [ 0 ] + dp [ n ] [ k ] [ 1 ] ; }
static void findSmallestRange ( int arr [ ] [ ] , int n , int k ) { int i , minval , maxval , minrange , minel , maxel , flag ; for ( i = 0 ; i <= k ; i ++ ) { ptr [ i ] = 0 ; minrange = 10 ** 9 ; } while ( 1 ) { minind = - 1 ; minval = 10 ** 9 ; maxval = - 10 ** 9 ; flag = 0 ; for ( i = 0 ; i <= k ; i ++ ) { if ( ptr [ i ] == n ) { flag = 1 ; break ; } if ( ptr [ i ] < n && arr [ i ] [ ptr [ i ] ] < minval ) { minind = i ; minval = arr [ i ] [ ptr [ i ] ] ; } if ( ptr [ i ] < n && arr [ i ] [ ptr [ i ] ] > maxval ) { maxval = arr [ i ] [ ptr [ i ] ] ; } } if ( flag ) break ; if ( ptr [ minind ] >= k ) { break ; } ptr [ minind ] ++ ; if ( ( maxval - minval ) < minrange ) { minel = minval ; maxel = maxval ; minrange = maxel - minel ; } } System . out . println ( " The ▁ smallest ▁ range ▁ is ▁ [ ▁ " + minel + " ] " ) ; }
static String lexicographicSubConcat ( String s ) { int n = s . length ( ) ; int sub_count = ( n * ( n + 1 ) ) / 2 ; int [ ] arr = new int [ sub_count ] ; int index = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 1 ; j <= n - i ; j ++ ) arr [ index ] = s . charAt ( i ) + j ; index ++ ; } Arrays . sort ( arr ) ; for ( int i = 0 ; i < sub_count ; i ++ ) res += arr [ i ] ; return res ; }
static int maxelement ( int arr [ ] [ ] ) { int no_of_rows = arr . length ; int no_of_column = arr [ 0 ] . length ; int max1 = 0 ; for ( int i = 0 ; i < no_of_rows ; i ++ ) { max1 = 0 ; for ( int j = 0 ; j < no_of_column ; j ++ ) { if ( arr [ i ] [ j ] > max1 ) max1 = arr [ i ] [ j ] ; } System . out . println ( max1 ) ; } return max1 ; }
static int countNegative ( int M [ ] [ ] , int n , int m ) { int count = 0 ; int i = 0 , j = m - 1 ; while ( j >= 0 && i < n ) { if ( M [ i ] [ j ] < 0 ) count += ( j + 1 ) ; else i ++ ; } return count ; }
static int findpos ( String n ) { int i = 0 , j = n . length ( ) ; int pos = 0 ; while ( i < j ) { if ( n . charAt ( i ) == '4' ) pos = pos * 2 + 1 ; if ( n . charAt ( i ) == '7' ) pos = pos * 2 + 2 ; i ++ ; } return pos ; }
static int yMod ( int y , int x ) { return ( y % pow ( 2 , x ) ) ; }
static int maxSumIS ( int arr [ ] , int n ) { int max = 0 ; int msis [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) msis [ i ] = arr [ i ] ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ i ] > arr [ j ] && msis [ i ] < msis [ j ] + arr [ i ] ) msis [ i ] = msis [ j ] + arr [ i ] ; } } for ( int i = 0 ; i < n ; i ++ ) if ( max < msis [ i ] ) max = msis [ i ] ; return max ; }
static int maxLength ( String s , int n ) { int invalidOpenBraces = 0 , invalidCloseBraces = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == ' ( ' ) ) invalidOpenBraces ++ ; else if ( invalidOpenBraces == 0 ) invalidCloseBraces ++ ; else invalidOpenBraces -- ; } return ( n - ( invalidOpenBraces + invalidCloseBraces ) ) ; }
static int lis ( int arr [ ] , int n ) { int [ ] mpis = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { mpis [ i ] = arr [ i ] ; } for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ i ] > arr [ j ] && mpis [ i ] < ( mpis [ j ] * arr [ i ] ) ) mpis [ i ] = mpis [ j ] * arr [ i ] ; } } return Math . max ( mpis ) ; }
static boolean findthepath ( char S [ ] , char v ) { result . set ( 0 , v ) ; for ( int i = 1 ; i < S . length ; i ++ ) { if ( adj [ v ] [ S [ i ] - ' A ' ] || adj [ S [ i ] - ' A ' ] [ v ] ) v = S [ i ] - ' A ' ; else if ( adj [ v ] [ S [ i ] - ' A ' + 5 ] || adj [ S [ i ] - ' A ' + 5 ] [ v ] ) v = ( char ) S [ i ] - ' A ' + 5 ] ; else return false ; } result . add ( v ) ; }
static boolean checkSorted ( int n , Queue < Integer > q ) { List < Integer > st = new ArrayList < Integer > ( ) ; int expected = 1 ; int fnt = null ; while ( ! q . isEmpty ( ) ) { fnt = q . peek ( ) ; q . remove ( ) ; if ( fnt == expected ) expected ++ ; else { if ( st . size ( ) == 0 ) st . add ( fnt ) ; else if ( st . size ( ) != 0 && st . peek ( ) < fnt ) return false ; else { st . add ( fnt ) ; } } while ( ! st . isEmpty ( ) && st . peek ( ) == expected ) st . pop ( ) ; expected ++ ; if ( expected - 1 == n && st . size ( ) == 0 ) return true ; return false ; }
static void generate ( LinkedList < Character > s ) { if ( s . size ( ) == 0 ) return ; if ( st . contains ( s ) ) { List < Character > t = new ArrayList < Character > ( ) ; t . add ( s . get ( i ) ) ; generate ( st , t ) ; } }
static void tower ( int n , int sourcePole , int destinationPole , int auxiliaryPole ) { if ( 0 == n ) return ; tower ( n - 1 , sourcePole , auxiliaryPole , destinationPole ) ; tower ( n - 1 , auxiliaryPole , destinationPole ) ; tower ( n - 1 , sourcePole , auxiliaryPole , sourcePole ) ; }
static int findMaximumPieces ( int n ) { return 1 + n * ( n + 1 ) / 2 ; }
static int minLexRotation ( String str ) { int n = str . length ( ) ; StringBuffer sb = new StringBuffer ( str ) ; sb . append ( str ) ; for ( int i = 0 ; i < arr . length ; i ++ ) { sb . append ( str . charAt ( i ) ) ; arr [ i ] = sb . substring ( i , n + i ) ; } Arrays . sort ( arr ) ; return arr [ 0 ] ; }
static int findMinInsertions ( String str , int l , int h ) { if ( l > h ) return Integer . MAX_VALUE ; if ( l == h ) return 0 ; if ( l == h - 1 ) return 0 if ( str . charAt ( l ) == str . charAt ( h ) ) else 1 ; if ( str . charAt ( l ) == str . charAt ( h ) ) return findMinInsertions ( str , l + 1 , h - 1 ) ; else return findMinInsertions ( str , l , h ) ; }
static int octalToDecimal ( int n ) { int num = n ; int dec_value = 0 ; int base = 1 ; int temp = num ; while ( temp > 0 ) { int last_digit = temp % 10 ; temp = temp / 10 ; dec_value += last_digit * base ; base = base * 8 ; } return dec_value ; }
static int getMissingNo ( int A [ ] ) { int n = A . length ; int total = ( n + 1 ) * ( n + 2 ) / 2 ; int sum_of_A = sum ( A ) ; return total - sum_of_A ; }
static void printSquares ( int n ) { int square = 0 ; int prev_x = 0 ; for ( int x = 0 ; x < n ; x ++ ) { square = ( square + x + prev_x ) ; System . out . print ( square + " ▁ " ) ; prev_x = x ; } }
static boolean isPossible ( int a [ ] , int b [ ] , int n , int k ) { Arrays . sort ( a ) ; Arrays . sort ( b ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] + b [ i ] < k ) return false ; } return true ; }
static void fitOrNotFit ( int R , int r , int x , int y , int rad ) { double val = Math . sqrt ( Math . pow ( x , 2 ) + Math . pow ( y , 2 ) ) ; if ( val + rad <= R && val - rad >= R - r ) System . out . println ( " Fits \n " ) ; else System . out . println ( " Doesn ' t ▁ Fit " ) ; }
static int findPosition ( int k , int n ) { int f1 = 0 , f2 = 1 ; int i = 2 ; while ( i != 0 ) { int f3 = f1 + f2 ; f1 = f2 ; f2 = f3 ; if ( f2 % k == 0 ) return n * i ; i ++ ; } return - 1 ; }
static void sequence ( int n ) { int [ ] f = new int [ n + 1 ] ; System . out . print ( f [ 1 ] + " ▁ " ) ; System . out . print ( f [ 2 ] + " ▁ " ) ; for ( int i = 3 ; i <= n ; i ++ ) { f . add ( f [ i - 1 ] ] + f [ i - f [ i - 1 ] ] ) ; System . out . print ( f [ i ] + " ▁ " ) ; } }
static int countManipulations ( String s1 , String s2 ) { int count = 0 ; int [ ] char_count = new int [ 26 ] ; for ( int i = 0 ; i < 26 ; i ++ ) char_count [ i ] = 0 ; for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) { char_count [ s1 . charAt ( i ) - ' a ' ] ++ ; } for ( int i = 0 ; i < s2 . length ( ) ; i ++ ) { char_count [ s2 . charAt ( i ) - ' a ' ] -- ; if ( char_count [ s2 . charAt ( i ) - ' a ' ] < 0 ) count ++ ; } return count ; }
static int count ( int n ) { int table [ ] = new int [ n + 1 ] ; table [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) table [ i ] += table [ i - 1 ] ; for ( int i = 3 ; i <= n ; i ++ ) table [ i ] += table [ i - 3 ] ; for ( int i = 5 ; i <= 10 ; i ++ ) table [ i ] += table [ i - 5 ] ; return table [ n ] ; }
static int maxSubsequenceSubstring ( char X [ ] , char Y [ ] , int n , int m ) { int dp [ ] [ ] = new int [ MAX ] [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) { dp [ i ] [ 0 ] = 0 ; } for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( X [ j - 1 ] == Y [ i - 1 ] ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = dp [ i ] [ j - 1 ] ; } } int ans = 0 ; for ( int i = 1 ; i <= m ; i ++ ) ans = Math . max ( ans , dp [ i ] [ n ] ) ; return ans ; }
static int findLongestRepeatingSubSeq ( String str ) { int n = str . length ( ) ; int [ ] [ ] dp = new int [ n ] [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( str . charAt ( i - 1 ) == str . charAt ( j - 1 ) && i != j ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = Math . max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ; } } return dp [ n ] [ n ] ; }
static boolean isCornerPresent ( String str , String corner ) { int n = str . length ( ) ; int cl = corner . length ( ) ; if ( n < cl ) return false ; return ( str . substring ( 0 , cl ) == corner ) && ( str . substring ( n - cl ) == corner ) ; }
static int getMedian ( int ar1 [ ] , int ar2 [ ] , int n ) { int i = 0 , j = 0 ; int m1 = - 1 , m2 = - 1 ; int count = 0 ; while ( count < n + 1 ) { if ( i == n ) { m1 = m2 ; m2 = ar2 [ 0 ] ; break ; } else if ( j == n ) { m1 = m2 ; m2 = ar1 [ 0 ] ; break ; } else if ( i == n ) { m1 = m2 ; m2 = ar2 [ 0 ] ; break ; } else if ( j == n ) { m1 = m2 ; m2 = ar1 [ 0 ] ; break ; } if ( ar1 [ i ] < ar2 [ j ] ) { m1 = m2 ; m2 = arr1 [ i ] ; i ++ ; } else { m1 = m2 ; m2 = arr2 [ j ++ ] ; } } return ( m1 + m2 ) / 2 ; }
static int countZeroes ( int mat [ ] [ ] ) { int N = mat . length ; int row = N - 1 , col = 0 ; int count = 0 ; while ( col < N ) { while ( mat [ row ] [ col ] ) { if ( row < 0 ) return count ; row -- ; col ++ ; count ++ ; } } return count ; }
static int jumpSearch ( int arr [ ] , int x , int n ) { int step = Math . sqrt ( n ) ; int prev ; for ( prev = 0 ; prev < n ; prev ++ ) { while ( arr [ int ( prev ) ] < x ) { prev ++ ; if ( prev == Math . sqrt ( n ) ) return - 1 ; if ( arr [ int ( prev ) ] == x ) return prev ; } if ( arr [ int ( prev ) ] == x ) return - 1 ; } return - 1 ; }
static int solution ( int a , int b , int n ) { int i ; for ( i = 0 ; i * a <= n ; i ++ ) { if ( ( n - ( i * a ) ) % b == 0 ) System . out . println ( " x ▁ = ▁ " + i + " , ▁ y ▁ = ▁ " + ( ( n - ( i * a ) ) / b ) ) ; return 0 ; } System . out . println ( " No ▁ solution " ) ; }
static String longDivision ( String number , int divisor ) { String ans = " " ; int idx = 0 ; int temp = ( number . charAt ( idx ) - '0' ) ; while ( temp < divisor ) { temp = ( temp * 10 + ( number . charAt ( idx + 1 ) ) - '0' ) ; idx ++ ; } while ( ( number . length ( ) ) > idx ) { ans += ( char ) ( Math . floor ( temp / divisor ) + '0' ) ; temp = ( ( temp % divisor ) * 10 + ( number . charAt ( idx ) ) - '0' ) ; idx ++ ; } ans += ( char ) ( Math . floor ( temp / divisor ) + '0' ) ; if ( ans . length ( ) == 0 ) return "0" ; return ans ; }
static void sort012 ( int a [ ] , int arr_size ) { int lo = 0 , hi = arr_size - 1 ; int mid = 0 ; while ( mid <= hi ) { if ( a [ mid ] == 0 ) { a [ lo ] = a [ mid ] , a [ lo ] ; mid = mid + 1 ; } else if ( a [ mid ] == 1 ) { mid = mid + 1 ; } else { a [ mid ] = a [ hi ] ; hi = hi - 1 ; } } }
static boolean canRepresentBST ( int pre [ ] ) { Stack < Integer > s = new Stack < Integer > ( ) ; int root = Integer . MIN_VALUE ; for ( int value = 0 ; value < root ; value ++ ) { if ( s . size ( ) > 0 && s . peek ( ) < value ) { root = s . peek ( ) ; s . pop ( ) ; } s . add ( value ) ; } return true ; }
static int find ( int [ ] arr ) { int n = arr . length ; int i = 0 , j = n - 1 ; int res = - 1 ; while ( i < n && j >= 0 ) { if ( arr [ i ] [ j ] == 0 ) { while ( j >= 0 && ( arr [ i ] [ j ] == 0 || i == j ) ) j -- ; if ( j == - 1 ) res = i ; break ; else { i ++ ; } } else { while ( i < n && ( arr [ i ] [ j ] == 1 || i == j ) ) { i ++ ; } if ( i == n ) res = j ; break ; } } if ( res == - 1 ) { return res ; } for ( int i = 0 ; i < n ; i ++ ) { if ( res != i && arr [ i ] [ res ] != 1 ) return - 1 ; } for ( int j = 0 ; j < j ; j ++ ) { if ( res != j && arr [ res ] [ j ] != 0 ) return - 1 ; } return res ; }
static void printArray ( int [ ] a , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( a [ i ] + " ▁ " ) ; System . out . println ( ) ; }
static void sortSquares ( int arr [ ] , int n ) { int K ; for ( K = 0 ; K < n ; K ++ ) { if ( arr [ K ] >= 0 ) break ; int i = K - 1 , j = K ; int ind = 0 ; Arrays . sort ( arr , 0 , n ) ; while ( i >= 0 && j < n ) { if ( arr [ i ] * arr [ i ] < arr [ j ] * arr [ j ] ) { temp [ ind ] = arr [ i ] * arr [ i ] ; i -- ; } else { temp [ ind ] = arr [ j ] * arr [ j ] ; j ++ ; } ind ++ ; } while ( i >= 0 ) { temp [ ind ] = arr [ i ] * arr [ i ] ; i -- ; ind ++ ; } while ( j < n ) { temp [ ind ] = arr [ j ] * arr [ j ] ; j ++ ; ind ++ ; } for ( i = 0 ; i < n ; i ++ ) { arr [ i ] = temp [ i ] ; } } for ( i = 0 ; i < n ; i ++ ) { arr [ i ] = arr [ i ] ; } }
static int find_maximum ( int a [ ] , int n , int k ) { Map < Integer , Integer > b = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int x = a [ i ] ; int d = Math . min ( 1 + i , n - i ) ; if ( ! b . containsKey ( x ) ) { b [ x ] = d ; } else { b [ x ] = Math . min ( d , b [ x ] ) ; } } int ans = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { int x = a [ i ] ; if ( x != ( k - x ) && ( k - x ) in b . keys ( ) ) ans = Math . min ( Math . max ( b [ x ] , b [ k - x ] ) , ans ) ; } return ans ; }
static String maxRepeating ( String str ) { int n = str . length ( ) ; int count = 0 ; String res = str . charAt ( 0 ) ; int cur_count = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( i < n - 1 && str . charAt ( i ) == str . charAt ( i + 1 ) ) cur_count ++ ; else { if ( cur_count > count ) { count = cur_count ; res = str . charAt ( i ) ; } cur_count = 1 ; } } return res ; }
static int solveQuery ( int start , int end , int arr [ ] ) { Map < Integer , Integer > frequency = new HashMap < Integer , Integer > ( ) ; for ( int i = start ; i <= end ; i ++ ) { if ( frequency . containsKey ( arr [ i ] ) ) { frequency . put ( arr [ i ] , frequency . get ( arr [ i ] ) + 1 ) ; } else { frequency . put ( arr [ i ] , 1 ) ; } } int count = 0 ; for ( int x = 0 ; x < frequency . size ( ) ; x ++ ) if ( frequency . get ( x ) == 1 ) count ++ ; return count ; }
public static int Circumference ( int a ) { return ( 4 * a ) ; }
public static int numberOfPaths ( int m , int n ) { int path = 1 ; for ( int i = n ; i <= ( m + n - 1 ) ; i ++ ) path *= i ; path /= ( i - n + 1 ) ; return path ; }
static void pointClip ( int XY [ ] [ ] , int n , int Xmin , int Ymin , int Xmax , int Ymax ) { System . out . println ( " Point ▁ inside ▁ the ▁ viewing ▁ pane : " ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( XY [ i ] [ 0 ] >= Xmin ) && ( XY [ i ] [ 0 ] <= Xmax ) ) { if ( ( XY [ i ] [ 1 ] >= Ymin ) && ( XY [ i ] [ 1 ] <= Ymax ) ) System . out . println ( " [ ▁ " + XY [ i ] [ 1 ] + " ] " ) ; } } System . out . println ( " \n \n Point ▁ outside ▁ the ▁ viewing ▁ pane : " ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( XY [ i ] [ 0 ] < Xmin ) || ( XY [ i ] [ 0 ] > Xmax ) ) System . out . println ( " [ ▁ " + XY [ i ] [ 1 ] + " ] " ) ; if ( ( XY [ i ] [ 1 ] < Ymin ) || ( XY [ i ] [ 1 ] > Ymax ) ) System . out . println ( " [ ▁ " + XY [ i ] [ 0 ] + " , ▁ " + XY [ i ] [ 1 ] + " ] " ) ; } }
static int pre_compute ( int a [ ] , int n , int index , int k ) { int [ ] [ ] dp = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > a [ 0 ] ) { dp [ 0 ] [ i ] = a [ i ] + a [ 0 ] ; } else { dp [ 0 ] [ i ] = a [ i ] ; } } for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( a [ j ] > a [ i ] && j > i ) { if ( dp [ i - 1 ] [ i ] + a [ j ] > dp [ i - 1 ] [ j ] ) { dp [ i ] [ j ] = dp [ i - 1 ] [ i ] + a [ j ] ; } else { dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; } } } return dp [ index ] [ k ] ; }
static void splitArr ( int arr [ ] , int n , int k ) { for ( int i = 0 ; i < k ; i ++ ) { int x = arr [ 0 ] ; for ( int j = 0 ; j < n - 1 ; j ++ ) arr [ j ] = arr [ j + 1 ] ; arr [ n - 1 ] = x ; } }
static int smallestSubWithSum ( int arr [ ] , int n , int x ) { int curr_sum = 0 ; int min_len = n + 1 ; int start = 0 , end = 0 ; while ( end < n ) { while ( curr_sum <= x && end < n ) { if ( curr_sum <= 0 && x > 0 ) { start = end ; curr_sum = 0 ; } curr_sum += arr [ end ] ; end ++ ; } while ( curr_sum > x && start < n ) { if ( end - start < min_len ) min_len = end - start ; curr_sum -= arr [ start ] ; start ++ ; } } return min_len ; }
static int winner ( int a [ ] , int n , int k ) { if ( k >= n - 1 ) return n ; int best = 0 ; int times = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > best ) best = a [ i ] ; if ( i == true ) times ++ ; else times ++ ; if ( times >= k ) return best ; } return best ; }
static boolean divisibleBy20 ( String num ) { int lastTwoDigits = num . length ( ) ; return ( lastTwoDigits % 5 == 0 && lastTwoDigits % 4 == 0 ) ; }
static int countSolutions ( int n ) { int x = 0 , res = 0 ; int yCount = 0 ; while ( yCount * yCount < n ) yCount ++ ; while ( yCount != 0 && ( x * x + ( yCount - 1 ) * ( yCount - 1 ) >= n ) ) yCount -- ; return res ; }
static void CountTriangles ( int A [ ] ) { int n = A . length ; int count = 0 ; quickSort ( A , 0 , n - 1 ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { int l = 0 , r = i - 1 ; while ( l < r ) { if ( A [ l ] + A [ r ] > A [ i ] ) count += r - l ; r -- ; else l ++ ; } } System . out . println ( " No ▁ of ▁ possible ▁ solutions : ▁ " + count ) ; }
static int snoob ( int x ) { int next = 0 ; if ( x ) { int rightOne = x & - ( x ) ; int nextHigherOneBit = x + int ( rightOne ) ; int rightOnesPattern = x ^ int ( nextHigherOneBit ) ; rightOnesPattern = ( int ) rightOnesPattern / int ( rightOne ) ) ; rightOnesPattern = ( int ) rightOnesPattern / int ( rightOne ) ; next = nextHigherOneBit | rightOnesPattern ; } return next ; }
static boolean isInorder ( int arr [ ] , int n ) { if ( n == 0 || n == 1 ) return true ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i - 1 ] > arr [ i ] ) return false ; } return true ; }
static int lis ( int arr [ ] ) { int n = arr . length ; int maximum = 1 ; _lis ( arr , 0 ) ; return maximum ; }
static int maxProduct ( int arr [ ] , int n ) { if ( n < 3 ) return - 1 ; int max_product = Integer . MIN_VALUE ; for ( int i = 0 ; i < n - 2 ; i ++ ) { for ( int j = i + 1 ; j < n - 1 ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) max_product = Math . max ( max_product , arr [ i ] * arr [ j ] * arr [ k ] ) ; } } return max_product ; }
static void countFreq ( int [ ] a , int n ) { HashMap < Integer , Integer > hm = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { hm . put ( a [ i ] , hm . get ( a [ i ] ) + 1 ) ; } int cumul = 0 ; HashSet < Integer > st = new HashSet < Integer > ( ) ; for ( int x = 0 ; x < hm . size ( ) ; x ++ ) { st . add ( ( int ) hm . get ( x ) ) ; cumul += x [ 1 ] ; System . out . println ( x [ 0 ] + " ▁ " + cumul ) ; } }
static int nCrModp ( int n , int r , int p ) { int [ ] C = new int [ r + 1 ] ; C [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = min ( i , r ) ; j >= 0 ; j -- ) C [ j ] = ( C [ j ] + C [ j - 1 ] ) % p ; } return C [ r ] ; }
public static void cocktailSort ( int [ ] a ) { int n = a . length ; boolean swapped = true ; int start = 0 , end = n - 1 ; while ( swapped == true ) break ; swapped = false ; for ( int i = start ; i <= end ; i ++ ) { if ( a [ i ] > a [ i + 1 ] ) { a [ i ] = a [ i + 1 ] ; a [ i + 1 ] = a [ i ] ; swapped = true ; } } if ( swapped == false ) break ; swapped = false ; end = end - 1 ; for ( int i = end - 1 ; i >= start ; i -- ) { if ( a [ i ] > a [ i + 1 ] ) { a [ i ] = a [ i + 1 ] ; a [ i + 1 ] = a [ i + 1 ] ; swapped = true ; } } start = start + 1 ; } }
static void solveWordWrap ( int arr [ ] , int n , int k ) { int [ ] dp = new int [ n ] ; int [ ] ans = new int [ n ] ; dp [ n - 1 ] = 0 ; ans [ n - 1 ] = n - 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { int currlen = - 1 ; dp [ i ] = Integer . MAX_VALUE ; for ( int j = i ; j < n ; j ++ ) { currlen += ( arr [ j ] + 1 ) ; if ( currlen > k ) break ; if ( j == n - 1 ) { cost = 0 ; } else { cost = ( ( k - currlen ) * ( k - currlen ) + dp [ j + 1 ] ) ; if ( cost < dp [ i ] ) { dp [ i ] = cost ; ans [ i ] = j ; } } } for ( int i = 0 ; i < n ; i ++ ) System . out . print ( i + " ▁ " ) ; i = ans [ i ] + 1 ; } }
static int binarySearch ( int arr [ ] , int l , int r , int x ) { while ( l <= r ) { int mid = l + ( r - l ) / 2 ; if ( arr [ mid ] == x ) return mid ; else if ( arr [ mid ] < x ) l = mid + 1 ; else r = mid - 1 ; } return - 1 ; }
static int minXOR ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int min_xor = Integer . MAX_VALUE ; int val = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { val = arr [ i ] ^ arr [ j ] ; min_xor = Math . min ( min_xor , val ) ; } } return min_xor ; }
static int sumofFactors ( int n ) { if ( n % 2 != 0 ) return 0 ; int res = 1 ; for ( int i = 2 ; i <= Math . sqrt ( n ) ; i ++ ) { int count = 0 ; int curr_sum = 1 ; int curr_term = 1 ; while ( n % i == 0 ) { count ++ ; n = n / i ; if ( i == 2 && count == 1 ) { curr_sum = 0 ; } curr_term = curr_term * i ; curr_sum = curr_sum + curr_term ; } res *= curr_sum ; } if ( n >= 2 ) res *= ( 1 + n ) ; return res ; }
static char first ( String str , int i ) { if ( str . charAt ( i ) == ' \0' ) return 0 ; if ( str . charAt ( i ) . isupper ( ) ) return str . charAt ( i ) ; return first ( str , i + 1 ) ; }
static int maxGameByWinner ( int N ) { int [ ] dp = new int [ N ] ; Arrays . fill ( dp , 0 ) ; dp [ 0 ] = 1 ; dp [ 1 ] = 2 ; for ( int i = 1 ; i <= N ; i ++ ) { while ( dp [ i ] <= N ) { i ++ ; dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] ; } return ( i - 1 ) ; }
static int equilibrium ( int arr [ ] ) { int total_sum = sum ( arr ) ; int leftsum = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { total_sum -= num ; if ( leftsum == total_sum ) return i ; leftsum += num ; } return - 1 ; }
static double procal ( int n ) { return ( 3.0 * n ) / ( 4.0 * ( n * n ) - 1 ) ; }
static int rearrange ( int arr [ ] , int n ) { int temp [ ] = new int [ n ] ; int small = 0 , large = n - 1 ; boolean flag = true ; for ( int i = 0 ; i < n ; i ++ ) { if ( flag is true ) { temp [ i ] = arr [ large ] ; large -- ; } else { temp [ i ] = arr [ small ] ; small ++ ; } flag = ( 1 - flag ) ; } for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = temp [ i ] ; } return arr ; }
static void greatest ( String s ) { int n = s . length ( ) ; int [ ] a = new int [ n ] ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = s . charAt ( i ) - '0' ; sum += a [ i ] ; } if ( a [ n - 1 ] % 2 ) { if ( a [ n - 2 ] % 2 != 0 || ( sum - a [ n - 1 ] ) % 3 != 0 ) System . out . print ( " - 1" ) ; else { System . out . print ( n ) ; } } int re = sum % 3 ; int dell = - 1 ; int flag = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( ( a [ i ] ) % 3 == re ) { if ( a [ i + 1 ] > a [ i ] ) { dell = i ; flag = 1 ; break ; } else dell = i ; } } if ( flag == 0 ) { if ( a [ n - 2 ] % 2 == 0 && re == a [ n - 1 ] % 3 ) dell = n - 1 ; } else { System . out . print ( dell + 1 ) ; } } }
static int isChangeable ( int notes [ ] , int n ) { int fiveCount = 0 , tenCount = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( notes [ i ] == 5 ) { fiveCount ++ ; } else if ( notes [ i ] == 10 ) { if ( fiveCount > 0 ) { fiveCount -- ; tenCount ++ ; } else { return 0 ; } } if ( fiveCount > 0 && tenCount > 0 ) { fiveCount -- ; tenCount -- ; } else if ( fiveCount >= 3 ) fiveCount -= 3 ; else return 0 ; } } return 1 ; }
static int LCSubStr ( char X [ ] , char Y [ ] , int m , int n ) { int LCSuff [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; int result = 0 ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 || j == 0 ) LCSuff [ i ] [ j ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) LCSuff [ i ] [ j ] = LCSuff [ i - 1 ] [ j - 1 ] + 1 ; result = Math . max ( result , LCSuff [ i ] [ j ] ) ; } else LCSuff [ i ] [ j ] = 0 ; } } return result ; }
static int maxSumWO3Consec ( int n ) { if ( sum [ n ] != - 1 ) return sum [ n ] ; if ( n == 0 ) sum [ n ] = 0 ; if ( n == 1 ) sum [ n ] = arr [ 0 ] ; if ( n == 2 ) sum [ n ] = arr [ 1 ] + arr [ 0 ] ; return sum [ n ] ; if ( n == 3 ) sum [ n ] = arr [ 2 ] + arr [ n - 1 ] + maxSumWO3Consec ( n - 3 ) ; return sum [ n ] ; }
static int findMinZero ( int p ) { int first = 1 , second = 1 , number = 2 ; int next = 1 ; while ( next ) { next = ( first + second ) % p ; first = second ; second = next ; number = number + 1 ; } return number ; }
static void reorder ( ) { for ( int i = 0 ; i < n ; i ++ ) { while ( index [ i ] != i ) { int oldTargetI = index [ index [ i ] ] ; int oldTargetE = arr [ index [ i ] ] ; arr [ index [ i ] ] = arr [ i ] ; index [ i ] = oldTargetI ; arr [ i ] = oldTargetE ; } } }
static int longestNull ( String S ) { Stack < Character > arr = new Stack < Character > ( ) ; arr . add ( new Character ( ' @ ' ) ) ; int maxlen = 0 ; for ( int i = 0 ; i < S . length ( ) ; i ++ ) { char ch = S . charAt ( i ) ; arr . add ( new Character ( ch ) ) ; for ( int i = 0 ; i < arr . size ( ) ; i ++ ) { char ch = arr . peek ( ) ; arr . remove ( ) ; while ( arr . size ( ) >= 3 && arr . peek ( ) == '1' && arr . peek ( ) == '0' && arr . peek ( ) == '0' && arr . peek ( ) == '0' && arr . pop ( ) == '0' ) { arr . pop ( ) ; arr . pop ( ) ; } } int tmp = arr . peek ( ) ; return maxlen ; }
static int calculateSum ( int n ) { if ( n <= 0 ) return 0 ; int fibo [ ] = new int [ n + 1 ] ; fibo [ 1 ] = 1 ; int sm = fibo [ 0 ] + fibo [ 1 ] ; for ( int i = 2 ; i <= n ; i ++ ) { fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ; sm = sm + fibo [ i ] ; } return sm ; }
static int shortestPath ( int graph [ ] [ ] , int u , int v , int k ) { int V = graph . length ; if ( k == 0 && u == v ) return 0 ; if ( k == 1 && graph [ u ] [ v ] != INF ) return graph [ u ] [ v ] ; if ( k <= 0 ) return INF ; int res = INF ; for ( int i = 0 ; i < V ; i ++ ) { if ( graph [ u ] [ i ] != INF && u != i && v != i ) { int rec_res = shortestPath ( graph , i , v , k - 1 ) ; if ( rec_res != INF ) res = Math . min ( res , graph [ u ] [ i ] + rec_res ) ; } } return res ; }
static int sumofsquare ( int n ) { int [ ] [ ] C = new int [ n + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { C [ i ] [ j ] = 0 ; } } for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= Math . min ( i , n ) ; j ++ ) { if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) ; } } int sum = 0 ; for ( int i = 0 ; i <= n ; i ++ ) sum = sum + ( C [ n ] [ i ] * C [ n ] [ i ] ) ; return sum ; }
static void constructArr ( int arr [ ] , int pair [ ] , int n ) { arr [ 0 ] = ( pair [ 0 ] + pair [ 1 ] - pair [ n - 1 ] ) / 2 ; for ( int i = 1 ; i < n ; i ++ ) arr [ i ] = pair [ i - 1 ] - arr [ 0 ] ; }
static int patternCount ( String str ) { char last = str . charAt ( 0 ) ; int counter = 0 ; int i = 1 ; while ( i < str . length ( ) ) { if ( str . charAt ( i ) == '0' && last == '1' ) { while ( str . charAt ( i ) == '0' ) i ++ ; if ( str . charAt ( i ) == '1' ) counter ++ ; } last = str . charAt ( i ) ; i ++ ; } return counter ; }
static int findFrequency ( int arr [ ] , int n , int left , int right , int element ) { int count = 0 ; for ( int i = left - 1 ; i < right ; i ++ ) if ( arr [ i ] == element ) count ++ ; return count ; }
static void parabola ( int a , int b , int c ) { System . out . println ( " Vertex : ▁ ( " + ( - b / ( 2 * a ) ) + " , ▁ " + ( ( 4 * a * c ) - ( b * b ) ) / ( 4 * a ) ) + " ) " ) ; System . out . println ( " Focus : ▁ ( " + ( - b / ( 2 * a ) ) + " , ▁ " + ( ( 4 * a * c ) - ( b * b ) + 1 ) / ( 4 * a ) ) + " ) " ) ; System . out . println ( " Directrix : ▁ y = ▁ " + c - ( ( b * b ) + 1 ) * 4 * a + " " ) ; }
static int minproduct ( int a [ ] , int b [ ] , int n , int k ) { int diff = 0 ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int pro = a [ i ] * b [ i ] ; res += pro ; if ( pro < 0 && b [ i ] < 0 ) temp = ( a [ i ] + 2 * k ) * b [ i ] ; else if ( pro < 0 && a [ i ] < 0 ) temp = ( a [ i ] - 2 * k ) * b [ i ] ; else if ( pro > 0 && a [ i ] > 0 ) temp = ( a [ i ] + 2 * k ) * b [ i ] ; d = Math . abs ( pro - temp ) ; if ( d > diff ) diff = d ; } return res - diff ; }
static void longestSubseqWithK ( String str , int k ) { int n = str . length ( ) ; int [ ] freq = new int [ MAX_CHARS ] ; for ( int i = 0 ; i < n ; i ++ ) freq [ str . charAt ( i ) - ' a ' ] ++ ; for ( int i = 0 ; i < n ; i ++ ) if ( freq [ str . charAt ( i ) - ' a ' ] >= k ) System . out . print ( str . charAt ( i ) ) ; }
static int pairsInSortedRotated ( int arr [ ] , int n , int x ) { for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > arr [ i + 1 ] ) break ; int l = ( i + 1 ) % n ; int r = i ; int cnt = 0 ; while ( l != r ) { if ( arr [ l ] + arr [ r ] == x ) cnt ++ ; if ( l == ( r - 1 + n ) % n ) return cnt ; l = ( l + 1 ) % n ; r = ( r - 1 + n ) % n ; } else if ( arr [ l ] + arr [ r ] < x ) l = ( l + 1 ) % n ; else r = ( n + r - 1 ) % n ; } return cnt ; }
static int middleOfThree ( int a , int b , int c ) { int x = a - b ; int y = b - c ; int z = a - c ; if ( x * y > 0 ) return b ; else if ( x * z > 0 ) return a ; else return b ; }
static int nextPowerOf2 ( int n ) { int count = 0 ; if ( n && ! ( n & ( n - 1 ) ) ) return n ; while ( n != 0 ) { n >>= 1 ; count ++ ; } return 1 << count ; }
static int maxSubArraySumRepeated ( int a [ ] , int n , int k ) { int max_so_far = Integer . MIN_VALUE ; int max_ending_here = 0 ; for ( int i = 0 ; i < n * k ; i ++ ) { max_ending_here = max_ending_here + a [ i % n ] ; if ( max_so_far < max_ending_here ) { max_so_far = max_ending_here ; } if ( max_ending_here < 0 ) max_ending_here = 0 ; } return max_so_far ; }
static String reverse ( String str ) { str = str . toLowerCase ( ) ; return str . slice ( 0 , - 1 ) ; }
static String nextWord ( String s ) { if ( s == " ▁ " ) return " a " ; int i ; for ( i = s . length ( ) - 1 ; i >= 0 ; i -- ) s . charAt ( i ) = ' z ' ; if ( i == - 1 ) s += ' a ' ; else s . replace ( s . charAt ( i ) , Character . toLowerCase ( s . charAt ( i ) + 1 ) , 1 ) ; } return s ; }
static int binomialCoeffSum ( int n ) { int [ ] [ ] C = new int [ n + 2 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) C [ i ] [ 0 ] = 1 ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= Math . min ( i , n ) ; j ++ ) { if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } int sum = 0 ; for ( int i = 0 ; i <= n ; i ++ ) sum += C [ n ] [ i ] ; return sum ; }
static boolean isEven ( int n ) { return ( n % 2 == 0 ) ; }
static int binarySearch ( int arr [ ] , int low , int high , int key ) { if ( high < low ) return - 1 ; int mid = ( low + high ) / 2 ; if ( key == arr [ mid ] ) return mid ; if ( key > arr [ int ( mid ) ] ) return binarySearch ( arr , ( mid + 1 ) , high , key ) ; return binarySearch ( arr , low , ( mid - 1 ) , key ) ; }
static void MAXMIN ( int arr [ ] [ ] , int n ) { int MIN = Integer . MAX_VALUE ; int MAX = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j <= n / 2 ; j ++ ) { if ( arr [ i ] [ j ] > arr [ i ] [ n - j - 1 ] ) { if ( MIN > arr [ i ] [ n - j - 1 ] ) min = arr [ i ] [ n - j - 1 ] ; if ( MAX < arr [ i ] [ j ] ) MAX = arr [ i ] [ j ] ; } else { if ( MIN > arr [ i ] [ j ] ) min = arr [ i ] [ j ] ; if ( MAX < arr [ i ] [ n - j - 1 ] ) max = arr [ i ] [ n - j - 1 ] ; } } } System . out . println ( " MAXimum ▁ = ▁ " + MAX + " , ▁ MINimum ▁ = ▁ " + MIN ) ; }
static boolean isPowerOfTwo ( int x ) { return ( x && ( x & ( x - 1 ) ) == 0 ) ; }
static int countPaths ( int n , int m ) { if ( n == 0 || m == 0 ) return 1 ; return countPaths ( n - 1 , m ) + countPaths ( n , m - 1 ) ; }
static boolean isRectangle ( int matrix [ ] [ ] ) { int rows = matrix . length ; if ( rows == 0 ) return false ; int columns = matrix [ 0 ] . length ; int table [ ] = new int [ rows ] [ columns - 1 ] ; for ( int i = 0 ; i < rows ; i ++ ) { for ( int j = 0 ; j < columns - 1 ; j ++ ) { for ( int k = j + 1 ; k < columns ; k ++ ) { if ( matrix [ i ] [ j ] == 1 && matrix [ i ] [ k ] == 1 ) { if ( j in table && k in table [ j ] ) return true ; if ( table [ k ] . contains ( j ) ) return true ; if ( j == table [ j ] ) return true ; if ( k == table [ k ] ) return true ; } } } return false ; }
static void decToBinary ( int n ) { int [ ] binaryNum = new int [ n ] ; int i = 0 ; while ( n > 0 ) { binaryNum [ i ] = n % 2 ; n = n / 2 ; i ++ ; } for ( int j = i - 1 ; j >= 0 ; j -- ) System . out . print ( binaryNum [ j ] ) ; }
static int countFriendsPairings ( int n ) { int [ ] dp = new int [ 100 ] ; if ( dp [ n ] != - 1 ) return dp [ n ] ; if ( n > 2 ) { dp [ n ] = countFriendsPairings ( n - 1 ) + ( n - 1 ) * countFriendsPairings ( n - 2 ) ; return dp [ n ] ; } else { dp [ n ] = n ; } }
static int maximumSumSubarray ( int arr [ ] , int n ) { int min_prefix_sum = 0 ; int res = Integer . MIN_VALUE ; int [ ] prefix_sum = new int [ n ] ; prefix_sum . add ( arr [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) prefix_sum . add ( arr [ i ] ) ; for ( int i = 1 ; i < n ; i ++ ) { prefix_sum . add ( prefix_sum . get ( i - 1 ) + arr [ i ] ) ; } for ( int i = 0 ; i < n ; i ++ ) res = Math . max ( res , prefix_sum . get ( i ) - min_prefix_sum ) ; min_prefix_sum = Math . min ( min_prefix_sum , prefix_sum . get ( i ) ) ; return res ; }
static int countOccurrences ( String s , int K ) { int n = s . length ( ) ; int c1 = 0 , c2 = 0 , C = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == ' a ' ) c1 ++ ; if ( s . charAt ( i ) == ' b ' ) c2 ++ ; C += c1 ; } return C * K + ( K * ( K - 1 ) / 2 ) * c1 * c2 ; }
static boolean checkDivisibility ( String num ) { int len = num . length ( ) ; if ( len == 1 && num . charAt ( 0 ) == '0' ) return true ; if ( len % 3 == 1 ) num = num + "00" ; length ++ ; else if ( len % 3 == 2 ) num = num + "0" ; length ++ ; int sum = 0 ; int p = 1 ; for ( int i = length - 1 ; i >= 0 ; i -- ) { group += ( num . charAt ( i ) - '0' ) ; i -- ; group += ( num . charAt ( i ) - '0' ) ; sum += group * p ; p *= ( - 1 ) ; } sum = Math . abs ( sum ) ; return ( sum % 13 == 0 ) ; }
static int countRect ( int n ) { int ans = 0 ; for ( int length = 1 ; length <= Math . sqrt ( n ) ; length ++ ) { int height = length ; while ( height * length <= n ) ans ++ ; height ++ ; } return ans ; }
static int countSetBits ( int n ) { int count = 0 ; while ( n ) { n &= ( n - 1 ) ; count ++ ; } return count ; }
static int lenOfLongSubarr ( int arr [ ] , int n ) { int sum = 0 ; int maxLen = 0 ; HashMap < Integer , Integer > um = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) sum += - 1 ; else sum ++ ; if ( sum == 1 ) maxLen = i + 1 ; else if ( um . containsKey ( sum ) ) { um . put ( sum , i ) ; } else if ( um . containsKey ( sum - 1 ) ) { if ( maxLen < ( i - um . get ( sum - 1 ) ) ) maxLen = i - um . get ( sum - 1 ) ; } } return maxLen ; }
int factorial ( int n ) { return ( n == 1 || n == 0 ) ? 1 : n * factorial ( n - 1 ) ; }
static int minJumps ( int arr [ ] , int l , int h ) { if ( h == l ) return 0 ; if ( arr [ l ] == 0 ) return Integer . MIN_VALUE ; int min = Integer . MAX_VALUE ; for ( int i = l + 1 ; i <= h ; i ++ ) { if ( i < l + arr [ l ] + 1 ) { int jumps = minJumps ( arr , i , h ) ; if ( jumps != Integer . MIN_VALUE && jumps + 1 < min ) min = jumps + 1 ; } } return min ; }
static int minTimeForWritingChars ( int N , int insrt , int remov , int cpy ) { if ( N == 0 ) return 0 ; if ( N == 1 ) return insrt ; int [ ] dp = new int [ N + 1 ] ; dp [ 0 ] = insrt ; dp [ 1 ] = dp [ N ] ; for ( int i = 1 ; i <= N ; i ++ ) { if ( i % 2 == 0 ) dp [ i ] = Math . min ( dp [ i - 1 ] + insrt , dp [ i / 2 ] + cpy ) ; else dp [ i ] = Math . min ( dp [ i - 1 ] + insrt , dp [ ( i + 1 ) / 2 ] + cpy + remov ) ; } return dp [ N ] ; }
static void carveCross ( String str ) { int n = str . length ( ) ; if ( n % 2 == 0 ) System . out . println ( " Not ▁ possible . ▁ Please ▁ enter ▁ " + " odd ▁ length ▁ string . \n " ) ; else { int arr [ ] [ ] = new boolean [ n ] [ n ] ; int m = n / 2 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) arr [ i ] [ j ] = ' X ' ; } } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) System . out . print ( arr [ i ] [ j ] + " ▁ " ) ; } System . out . println ( ) ; } }
public static int sumoflength ( int arr [ ] , int n ) { List < Integer > s = new ArrayList < Integer > ( ) ; int j = 0 ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { while ( j < n && ! s . contains ( arr [ j ] ) ) { s . add ( arr [ j ] ) ; j ++ ; } ans += ( ( j - i ) * ( j - i + 1 ) ) / 2 ; s . remove ( arr [ i ] ) ; } return ans ; }
static void findTriplets ( int arr [ ] , int n ) { boolean found = false ; HashSet < Integer > s = new HashSet < Integer > ( ) ; for ( int i = 0 ; i <= n - 2 ; i ++ ) { for ( int j = i + 1 ; j <= n ; j ++ ) { int x = ( arr [ i ] + arr [ j ] ) ; if ( ! s . contains ( arr [ j ] ) ) { System . out . println ( x + " ▁ " + arr [ i ] + " ▁ " + arr [ j ] ) ; found = true ; } else s . add ( arr [ j ] ) ; } } if ( found == false ) System . out . println ( " No ▁ Triplet ▁ Found " ) ; }
static int maxPrefix ( String s , String t ) { int count = 0 ; for ( int i = 0 ; i < t . length ( ) ; i ++ ) { if ( count == s . length ( ) ) break ; if ( t . charAt ( i ) == s . charAt ( count ) ) count ++ ; } return count ; }
static void segregateElements ( int arr [ ] , int n ) { int temp [ ] = new int [ n ] ; int j = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] >= 0 ) temp [ j ] = arr [ i ] ; j ++ ; } if ( j == n || j == 0 ) return ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < 0 ) temp [ j ] = arr [ i ] ; j ++ ; } for ( int k = 0 ; k < n ; k ++ ) arr [ k ] = temp [ k ] ; }
static void mergeIntervals ( int [ ] arr ) { Arrays . sort ( arr ) ; int s = - 10000 , max = - 100000 ; Vector < Integer > m = new Vector < > ( ) ; for ( int i = 0 ; i < arr . length ; i ++ ) { int a = arr [ i ] ; if ( a [ 0 ] > max ) { if ( i != 0 ) m . add ( [ s , max ] ) ; max = a [ 1 ] ; s = a [ 0 ] ; } else { if ( a [ 1 ] >= max ) { max = a [ 1 ] ; } } } if ( max != - 100000 && m . size ( ) > 0 ) System . out . print ( " The ▁ Merged ▁ Intervals ▁ are ▁ : \n " ) ; for ( int i = 0 ; i < m . size ( ) ; i ++ ) System . out . print ( m [ i ] + " ▁ " ) ; }
static float correlationCoefficient ( float X [ ] , float Y [ ] , int n ) { float sum_X = 0 ; int sum_Y = 0 ; int sum_XY = 0 ; int squareSum_X = 0 , squareSum_Y = 0 ; int i ; for ( i = 0 ; i < n ; i ++ ) { sum_X = sum_X + X [ i ] ; sum_Y = sum_Y + Y [ i ] ; sum_XY = sum_XY + X [ i ] * Y [ i ] ; squareSum_X = squareSum_X + X [ i ] * X [ i ] ; squareSum_Y = squareSum_Y + Y [ i ] * Y [ i ] ; } float corr = ( n * sum_XY - sum_X * sum_Y ) / ( n * squareSum_X - sum_X * sum_X ) * ( n * squareSum_Y - sum_Y * sum_Y ) ) ; return corr ; }
static int findArea ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int [ ] dimension = new int [ 2 ] ; int i = 0 , j = 0 ; while ( i < n - 1 && j < 2 ) { if ( arr [ i ] == arr [ i + 1 ] ) dimension [ j ] = arr [ i ] ; j ++ ; i ++ ; } return ( dimension [ 0 ] * dimension [ 1 ] ) ; }
static int minOps ( int arr [ ] , int n , int k ) { int max1 = Math . max ( arr ) ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( max1 - arr [ i ] ) % k != 0 ) return - 1 ; else res += ( max1 - arr [ i ] ) / k ; } return res ; }
public static int floorSqrt ( int x ) { if ( x == 0 || x == 1 ) return x ; int i = 1 , result = 1 ; while ( result <= x ) { i ++ ; result *= i ; } return i - 1 ; }
static boolean isdivisible7 ( String num ) { int n = num . length ( ) ; if ( n == 0 && num . charAt ( 0 ) == ' \n ' ) return 1 ; if ( n % 3 == 1 ) num = num + "00" ; n ++ ; else if ( n % 3 == 2 ) num = num + "0" ; n ++ ; int GSum = 0 ; int p = 1 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { group += ( num . charAt ( i ) - '0' ) ; i -- ; group += ( num . charAt ( i ) - '0' ) * 10 ; i -- ; group += ( num . charAt ( i ) - '0' ) * 100 ; GSum = GSum + group * p ; p *= ( - 1 ) ; } return ( GSum % 7 == 0 ) ; }
static void printMat ( int degseq [ ] , int n ) { int [ ] [ ] mat = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( degseq [ i ] > 0 && degseq [ j ] > 0 ) { degseq [ i ] -= 1 ; degseq [ j ] -= 1 ; mat [ i ] [ j ] = 1 ; } } } System . out . print ( " ▁ ▁ ▁ ▁ ▁ " ) ; for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( " ▁ ▁ ▁ ▁ ▁ " ) ; for ( int j = 0 ; j < n ; j ++ ) { System . out . print ( " ▁ ▁ ▁ ▁ ▁ ▁ " + mat [ i ] [ j ] ) ; } System . out . println ( ) ; } }
static int minTime ( int arr [ ] , int n , int m ) { int t = 0 ; while ( 1 ) { int items = 0 ; for ( int i = 0 ; i < n ; i ++ ) items += ( t / arr [ i ] ) ; if ( items >= m ) return t ; t ++ ; } }
static int MaximumDecimalValue ( int mat [ ] [ ] , int n ) { int [ ] [ ] dp = new int [ n ] [ n ] ; if ( mat [ 0 ] [ 0 ] == 1 ) { dp [ 0 ] [ 0 ] = 1 ; } else { dp [ 0 ] [ 0 ] = dp [ 0 ] [ 0 ] ; } for ( int i = 1 ; i < n ; i ++ ) { if ( mat [ 0 ] [ i ] == 1 ) { dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + 2 ** i ; } else { dp [ 0 ] [ i ] = dp [ i - 1 ] ; } } for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) { if ( mat [ i ] [ j ] == 1 ) { dp [ i ] [ j ] = Math . max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) + ( 2 ** ( i + j ) ) ; } else { dp [ i ] [ j ] = Math . max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ; } } } return dp [ n - 1 ] [ n - 1 ] ; }
static boolean isDivisible999 ( String num ) { int n = num . length ( ) ; if ( n == 0 || num . charAt ( 0 ) == '0' ) return true ; if ( ( n % 3 ) == 1 ) num = "00" + num ; if ( ( n % 3 ) == 2 ) num = "0" + num ; int gSum = 0 ; for ( int i = 0 ; i < n ; i += 3 ) { group += ( num . charAt ( i ) - 48 ) * 100 ; group += ( num . charAt ( i + 1 ) - 48 ) * 10 ; group += ( num . charAt ( i + 2 ) - 48 ) ; gSum += group ; } if ( gSum > 1000 ) num = "0" + num ; return ( gSum == 999 ) ; }
static int maxSumBitonicSubArr ( int arr [ ] , int n ) { int [ ] msis = new int [ n ] ; int [ ] msds = new int [ n ] ; int max_sum = 0 ; msis [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > arr [ i - 1 ] ) msis [ i ] = msis [ i - 1 ] + arr [ i ] ; else msis [ i ] = arr [ i ] ; } msds [ n - 1 ] = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] > arr [ i + 1 ] ) msds [ i ] = msds [ i + 1 ] + arr [ i ] ; else msds [ i ] = arr [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { if ( max_sum < ( msis [ i ] + msds [ i ] - arr [ i ] ) ) max_sum = ( msis [ i ] + msds [ i ] - arr [ i ] ) ; } return max_sum ; }
static int findMinNumber ( int n ) { int count = 0 ; int ans = 1 ; while ( n % 2 == 0 ) count ++ ; n /= 2 ; if ( count % 2 != 0 ) ans *= 2 ; for ( int i = 3 ; i <= Math . sqrt ( n ) ; i ++ ) { count = 0 ; while ( n % i == 0 ) count ++ ; n /= i ; if ( count % 2 != 0 ) ans *= i ; } if ( n > 2 ) ans *= n ; } return ans ; }
static int rangeGCD ( int n , int m ) { return n == m ? 1 : n ; }
static int assignValue ( int a , int b , int x ) { int arr [ ] = new int [ 2 ] ; arr [ x ] = a ; return arr [ x ] ; }
static boolean isTriangular ( int num ) { if ( num < 0 ) return false ; int sum = 0 ; int n = 1 ; while ( sum <= num ) { sum = sum + n ; if ( sum == num ) return true ; n ++ ; } return false ; }
static boolean checkPangram ( String s ) { boolean [ ] List = new boolean [ 26 ] ; for ( int i = 0 ; i < 26 ; i ++ ) List . add ( false ) ; for ( int c = 0 ; c < s . toLowerCase ( ) ; c ++ ) { if ( ! c . equals ( " ▁ " ) ) List . add ( ( int ) c - ' a ' ) ; } for ( boolean ch : List ) ch == false ) return false ; return true ; }
static int interpolationSearch ( int arr [ ] , int n , int x ) { int lo = 0 , hi = ( n - 1 ) ; while ( lo <= hi && x >= arr [ lo ] && x <= arr [ hi ] ) { if ( lo == hi ) if ( arr [ lo ] == x ) return lo ; return - 1 ; } int pos = lo + ( ( float ) hi - lo ) / ( arr [ hi ] - arr [ lo ] ) ) * ( x - arr [ lo ] ) ; return - 1 ; }
static void minSpacePreferLarge ( int w , int m , int n ) { int num_m = 0 , num_n = 0 , rem = w ; int p = 0 , q = 0 , r = 0 ; while ( w >= n ) { p = w / m ; r = w % m ; if ( r <= rem ) { num_m = p ; num_n = q ; rem = r ; } q ++ ; w -= n ; } System . out . println ( str ( num_m ) + " ▁ " + num_n + " ▁ " + rem ) ; }
static int findRepeating ( int arr [ ] , int n ) { int missingElement = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int element = arr [ Math . abs ( arr [ i ] ) ] ; if ( element < 0 ) { missingElement = arr [ i ] ; break ; } arr [ Math . abs ( arr [ i ] ) ] = - arr [ Math . abs ( arr [ i ] ) ] ; } return Math . abs ( missingElement ) ; }
static void kLargest ( int arr [ ] , int k ) { Arrays . sort ( arr ) ; for ( int i = 0 ; i < k ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; }
static int knapSack ( int W , int wt , int val [ ] , int n ) { int K [ ] [ ] = new int [ n + 1 ] [ W + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int w = 0 ; w <= W ; w ++ ) { if ( i == 0 || w == 0 ) K [ i ] [ w ] = 0 ; else if ( wt [ i - 1 ] <= w ) K [ i ] [ w ] = Math . max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] , K [ i - 1 ] [ w ] ) ; else K [ i ] [ w ] = K [ i - 1 ] [ w ] ; } } } return K [ n ] [ W ] ; }
static boolean isPowerOfFour ( int n ) { return ( n != 0 && ( ( n & ( n - 1 ) ) == 0 ) && ! ( n & 0xAAAAAAAA ) ) ; }
int factorial ( int n ) { return ( n == 1 || n == 0 ) ? 1 : n * factorial ( n - 1 ) ; }
static int findgroups ( int arr [ ] , int n ) { int c [ ] = new int [ 3 ] ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { c [ arr [ i ] % 3 ] ++ ; res += ( ( c [ 0 ] * ( c [ 0 ] - 1 ) ) >> 1 ) ; res += c [ 1 ] * c [ 2 ] ; res += ( c [ 0 ] * ( c [ 0 ] - 1 ) * ( c [ 0 ] - 2 ) ) / 6 ; res += ( c [ 1 ] * ( c [ 1 ] - 2 ) ) / 6 ; res += ( c [ 2 ] * ( c [ 2 ] - 1 ) * ( c [ 2 ] - 2 ) ) / 6 ) ; res += c [ 0 ] * c [ 1 ] * c [ 2 ] ; return res ; }
static int kthLargestSum ( int arr [ ] , int n , int k ) { int sum [ ] = new int [ n + 1 ] ; sum . add ( arr [ 0 ] ) ; for ( int i = 2 ; i <= n ; i ++ ) { sum . add ( arr [ i ] ) ; } Queue < Integer > Q = new LinkedList < > ( ) ; Q . add ( 0 ) ; Q . add ( arr [ 0 ] ) ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = i ; j <= n ; j ++ ) { int x = sum [ j ] - sum [ i - 1 ] ; if ( Q . size ( ) < k ) heapq . add ( Q , x ) ; else { if ( Q [ 0 ] < x ) heapq . remove ( Q ) ; heapq . add ( Q , x ) ; } } } return Q [ 0 ] ; }
static int findMaxValue ( int mat [ ] [ ] ) { int maxValue = Integer . MAX_VALUE ; int maxArr [ ] [ ] = new int [ N ] [ N - 1 ] ; int maxv = mat [ N - 1 ] [ N - 1 ] ; for ( int i = 0 ; i < N - 2 ; i ++ ) { for ( int j = N - 2 ; j >= 0 ; j -- ) { if ( mat [ N - 1 ] [ j ] > maxv ) { maxv = mat [ N - 1 ] [ j ] ; } maxArr [ N - 1 ] [ j ] = maxv ; } maxv = mat [ N - 1 ] [ N - 1 ] ; for ( int i = 0 ; i < N - 2 ; i ++ ) { if ( mat [ i ] [ N - 1 ] > maxv ) { maxv = mat [ i ] [ N - 1 ] ; } maxArr [ i ] [ N - 1 ] = maxv ; } } for ( int i = 0 ; i >= 0 ; i -- ) { for ( int j = N - 2 ; j >= 0 ; j -- ) { if ( maxArr [ i + 1 ] [ j + 1 ] - mat [ i ] [ j ] > maxValue ) { maxValue = ( maxArr [ i + 1 ] [ j + 1 ] - mat [ i ] [ j ] ) ; } maxArr [ i ] [ j ] = Math . max ( mat [ i ] [ j ] , Math . max ( maxArr [ i ] [ j + 1 ] , maxArr [ i + 1 ] [ j ] ) ) ; } } return maxValue ; }
static int kPrimeFactor ( int n , int k ) { while ( n % 2 == 0 ) { k = k - 1 ; n = n / 2 ; if ( k == 0 ) return 2 ; } int i = 3 ; while ( i <= Math . sqrt ( n ) ) { while ( n % i == 0 ) { if ( k == 1 ) return i ; k = k - 1 ; n = n / i ; } i = i + 2 ; } if ( n > 2 && k == 1 ) return n ; return - 1 ; }
static void printDistinct ( int arr [ ] , int n ) { Map < Integer , Integer > s = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! s . containsKey ( arr [ i ] ) ) { s . put ( arr [ i ] , arr [ i ] ) ; System . out . print ( arr [ i ] + " ▁ " ) ; } } }
static void decToBinary ( int n ) { for ( int i = 31 ; i >= 0 ; i -- ) { int k = n >> i ; if ( k & 1 ) System . out . print ( 1 + " " ) ; else System . out . print ( 0 + " " ) ; } }
static void SieveOfEratosthenes ( int n , boolean isPrime [ ] ) { isPrime [ 0 ] = isPrime [ 1 ] = false ; for ( int i = 2 ; i <= n ; i ++ ) isPrime [ i ] = true ; for ( int p = 2 ; p <= n ; p ++ ) { if ( p * p <= n && isPrime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i ++ ) isPrime [ i ] = false ; p ++ ; } } }
static int abFree ( String s ) { int b_count = 0 ; int res = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( ~ i ) == ' a ' ) res += b_count ; b_count = ( b_count * 2 ) ; else res ++ ; } return res ; }
static int countSubstrs ( String str , int i , int j , int n ) { if ( n == 1 ) return 1 ; if ( n <= 0 ) return 0 ; int res = countSubstrs ( str , i + 1 , j , n - 1 ) + countSubstrs ( str , i , j - 1 , n - 1 ) - countSubstrs ( str , i + 1 , j - 1 , n - 2 ) ; if ( str . charAt ( i ) == str . charAt ( j ) ) res ++ ; return res ; }
static int findFirstMissing ( int [ ] array , int start , int end ) { if ( start > end ) return end + 1 ; if ( start != array [ start ] ) return start ; int mid = ( start + end ) / 2 ; if ( array [ mid ] == mid ) return findFirstMissing ( array , mid + 1 , end ) ; return findFirstMissing ( array , start , mid ) ; }
int factorial ( int n ) { return ( n == 1 || n == 0 ) ? 1 : n * factorial ( n - 1 ) ; }
static int minRotation ( int input , int unlock_code ) { int rotation = 0 ; while ( input > 0 || unlock_code > 0 ) { int input_digit = input % 10 ; int code_digit = unlock_code % 10 ; rotation += Math . min ( Math . abs ( input_digit - code_digit ) , 10 - Math . abs ( input_digit - code_digit ) ) ; input = input / 10 ; unlock_code = unlock_code / 10 ; } return rotation ; }
static void findFibSubset ( int arr [ ] , int n ) { int m = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; int a = 0 , b = 1 ; int hash [ ] = new int [ m ] ; a = 0 ; b = 1 ; hash [ 0 ] = a ; hash [ 1 ] = b ; while ( b < m ) { int c = a + b ; a = b ; b = c ; hash . add ( b ) ; } for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] in hash ) System . out . print ( arr [ i ] + " ▁ " ) ; }
static boolean checkMarkov ( int m [ ] [ ] ) { int sm = 0 ; for ( int i = 0 ; i < m . length ; i ++ ) { for ( int j = 0 ; j < m [ i ] . length ; j ++ ) { sm = sm + m [ i ] [ j ] ; } if ( sm != 1 ) return false ; } return true ; }
static int insertSorted ( int arr [ ] , int n , int key , int capacity ) { if ( n >= capacity ) return n ; for ( int i = n - 1 ; i >= 0 && arr [ i ] > key ; i -- ) arr [ i + 1 ] = arr [ i ] ; arr [ i + 1 ] = key ; return ( n + 1 ) ; }
static void recursiveReverse ( String str , int i ) { int n = str . length ( ) ; if ( i == n / 2 ) { return ; } str . insert ( i , str . charAt ( n - i - 1 ) ) ; str . insert ( n - i - 1 , str . charAt ( i ) ) ; }
static boolean areConsecutive ( int arr [ ] , int n ) { if ( n < 1 ) return false ; int Min = Math . min ( arr ) ; int Max = Math . max ( arr ) ; if ( Max - Min + 1 == n ) { boolean [ ] visited = new boolean [ arr . length ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( visited [ arr [ i ] - Min ] != false ) return false ; visited [ arr [ i ] - Min ] = true ; } return true ; }
static int findMod ( int a , int b ) { if ( a < 0 ) a = - a ; if ( b < 0 ) b = - b ; int mod = a ; while ( mod >= b ) mod = mod - b ; if ( a < 0 ) return - mod ; return mod ; }
static int sumOfSubstrings ( String num ) { int n = num . length ( ) ; int sumofdigit [ ] = new int [ n ] ; int res = sumofdigit [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { int numi = num . charAt ( i ) ; sumofdigit . add ( ( i + 1 ) * numi + 10 * sumofdigit [ i - 1 ] ) ; res += sumofdigit [ i ] ; } return res ; }
static int findGreatest ( int arr [ ] , int n ) { Map < Integer , Integer > m = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int j ; for ( j = 0 ; j < i && arr [ j ] <= sqrt ( arr [ i ] ) ; j ++ ) { if ( arr [ i ] % arr [ j ] == 0 ) { int result = arr [ i ] / arr [ j ] ; if ( result != arr [ j ] && m . containsKey ( result ) ) return arr [ i ] ; else if ( result == arr [ j ] && ( result in m . keys ( ) ) && m [ result ] > 1 ) return arr [ i ] ; } } } return - 1 ; }
static int getMissingNo ( int a [ ] , int n ) { int i , total = 0 , j = 1 ; for ( i = 2 ; i <= n ; i ++ ) total += i ; total -= a [ i - 2 ] ; return total ; }
static int nextPowerOf2 ( int n ) { n -- ; n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; n ++ ; return n ; }
static void add ( int A [ ] [ ] , int B [ ] [ ] , int C [ ] [ ] ) { int i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < N ; j ++ ) C [ i ] [ j ] += A [ i ] [ j ] ; }
static int zigzag ( int n , int k ) { int [ ] [ ] dp = new int [ n + 1 ] [ k + 1 ] ; dp [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { dp [ i ] [ 0 ] = 0 ; } for ( int i = 1 ; i <= n ; i ++ ) { dp [ i ] [ 0 ] = 1 ; } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= k ; j ++ ) dp [ i ] [ j ] = ( dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ i - j ] ) ; } return dp [ n ] [ k ] ; }
static int eggDrop ( int n , int k ) { int [ ] [ ] eggFloor = new int [ k + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= k ; i ++ ) { eggFloor [ i ] [ 1 ] = 1 ; eggFloor [ i ] [ 0 ] = 0 ; } for ( int j = 1 ; j <= n ; j ++ ) { eggFloor [ 1 ] [ j ] = j ; } for ( int i = 2 ; i <= k ; i ++ ) { for ( int j = 2 ; j <= k ; j ++ ) { eggFloor [ i ] [ j ] = Integer . MAX_VALUE ; for ( int x = 1 ; x <= j ; x ++ ) { int res = 1 + Math . max ( eggFloor [ i - 1 ] [ x - 1 ] , eggFloor [ i ] [ j - x ] ) ; if ( res < eggFloor [ i ] [ j ] ) eggFloor [ i ] [ j ] = res ; } } } return eggFloor [ n ] [ k ] ; }
static String noAdjacentDup ( String s ) { int n = s . length ( ) ; for ( int i = 1 ; i < n ; i ++ ) { if ( s . charAt ( i ) == s . charAt ( i - 1 ) ) { s . insert ( i , " a " ) ; while ( i + 1 < n && s . charAt ( i ) == s . charAt ( i + 1 ) ) { s . insert ( i , 1 ) ; } i ++ ; } } return s ; }
static int maximumDifferenceSum ( int arr [ ] , int N ) { int [ ] [ ] dp = new int [ N ] [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { dp [ i ] [ 0 ] = dp [ i ] [ 1 ] = 0 ; } for ( int i = 0 ; i < N ; i ++ ) { dp [ i ] [ 1 ] = 0 ; } for ( int i = 0 ; i < N - 1 ; i ++ ) { dp [ i + 1 ] [ 0 ] = Math . max ( dp [ i ] [ 0 ] , dp [ i ] [ 1 ] + Math . abs ( 1 - arr [ i ] ) ) ; dp [ i + 1 ] [ 1 ] = Math . max ( dp [ i ] [ 0 ] + Math . abs ( arr [ i + 1 ] - 1 ) , dp [ i ] [ 1 ] + Math . abs ( arr [ i + 1 ] - arr [ i ] ) ) ; } return Math . max ( dp [ N - 1 ] [ 0 ] , dp [ N - 1 ] [ 1 ] ) ; }
static int minInsertionStepToSortArray ( int arr [ ] , int N ) { int lis [ ] = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) lis [ i ] = 1 ; for ( int i = 1 ; i < N ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ i ] >= arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; } } int max = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( max < lis [ i ] ) max = lis [ i ] ; return ( N - max ) ; }
static boolean isMultipleOf10 ( int n ) { return ( n % 15 == 0 ) ; }
static int exactPrimeFactorCount ( int n ) { int count = 0 ; if ( n % 2 == 0 ) count = count + 1 ; while ( n % 2 == 0 ) n = n / 2 ; while ( i <= Math . sqrt ( n ) ) { if ( n % i == 0 ) count = count + 1 ; while ( n % i == 0 ) n = n / i ; } i ++ ; if ( n > 2 ) count = count + 1 ; } return count ; }
static void query ( String s [ ] , int i , int j ) { int n = s . length ( ) ; i %= n ; j %= n ; if ( s . charAt ( i ) == s . charAt ( j ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; }
static int maxProduct ( int arr [ ] , int n ) { if ( n < 3 ) return - 1 ; Arrays . sort ( arr ) ; return Math . max ( arr [ 0 ] * arr [ 1 ] * arr [ n - 1 ] , arr [ n - 1 ] * arr [ n - 2 ] * arr [ n - 3 ] ) ; }
static int findMinAvgSubarray ( int arr [ ] , int n , int k ) { if ( n < k ) return 0 ; int res_index = 0 ; int curr_sum = 0 ; for ( int i = 0 ; i < k ; i ++ ) { curr_sum += arr [ i ] ; } int min_sum = curr_sum ; for ( int i = 0 ; i < n ; i ++ ) { curr_sum += arr [ i ] - arr [ i - k ] ; if ( curr_sum < min_sum ) { min_sum = curr_sum ; res_index = ( i - k + 1 ) ; } } System . out . println ( " Subarray ▁ between ▁ [ " + res_index + " , ▁ " + ( res_index + k - 1 ) + " ] ▁ has ▁ minimum ▁ average " ) ; return res_index ; }
static int countwalks ( int graph [ ] [ ] , int u , int v , int k ) { if ( k == 0 && u == v ) return 1 ; if ( k == 1 && graph [ u ] [ v ] ) return 1 ; if ( k <= 0 ) return 0 ; int count = 0 ; for ( int i = 0 ; i < V ; i ++ ) { if ( graph [ u ] [ i ] == 1 ) count += countwalks ( graph , i , v , k - 1 ) ; } return count ; }
static int countPairs ( int arr [ ] , int n ) { int result = 0 ; HashSet < Integer > Hash = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) Hash . add ( arr [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int product = arr [ i ] * arr [ j ] ; if ( hash . contains ( product ) ) result ++ ; } } return result ; }
static void print_sequence ( int n , int k ) { int b = n / ( k * ( k + 1 ) / 2 ) ; if ( b == 0 ) System . out . println ( " - 1" ) ; else { int r = 1 ; int x = 1 ; while ( x ** 2 <= n ) { if ( n % x != 0 ) continue ; if ( x <= b && x > r ) r = x ; else if ( n / x <= b && n / x > r ) r = n / x ; x = x + 1 ; } i = 1 ; while ( i < k ) System . out . print ( r * i + " ▁ " ) ; i ++ ; } int last_term = n - ( r * ( k * ( k - 1 ) / 2 ) ) ; System . out . println ( last_term ) ; }
static int nextPowerOf2 ( int n ) { n -- ; n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; n ++ ; return n ; }
static int findMaxValue ( int arr [ ] , int n ) { if ( n < 4 ) { System . out . println ( " The ▁ array ▁ should ▁ have ▁ atlest ▁ 4 ▁ elements " ) ; return MIN ; } int table1 [ ] = new int [ n + 1 ] , [ MIN ] * n ; int table2 [ ] = new int [ n - 2 ] ; int table3 [ ] = new int [ n - 3 ] ; int table4 [ ] = new int [ n - 4 ] ; for ( int i = n - 1 ; i >= 0 ; i -- ) { table1 [ i ] = Math . max ( table1 [ i + 1 ] , arr [ i ] ) ; } for ( int i = n - 2 ; i >= 0 ; i -- ) { table2 [ i ] = Math . max ( table2 [ i + 1 ] , table1 [ i + 1 ] - arr [ i ] ) ; } for ( int i = n - 4 ; i >= 0 ; i -- ) { table4 [ i ] = Math . max ( table4 [ i + 1 ] , table3 [ i + 1 ] + arr [ i ] ) ; } return table4 [ 0 ] ; }
static void printInSortedOrder ( int arr [ ] , int n ) { int [ ] index = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { index [ i ] = i ; } for ( int i = 0 ; i < n - 1 ; i ++ ) { int min = i ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ index [ min ] ] > arr [ index [ j ] ] ) min = j ; } if ( min != i ) index [ min ] = index [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ index [ i ] ] + " ▁ " ) ; }
static int findS ( int s ) { int _sum = 0 ; int n = 1 ; while ( _sum < s ) { _sum += n * n * n ; n ++ ; } n -- ; if ( _sum == s ) return n ; return - 1 ; }
static void printFun ( int test ) { if ( test < 1 ) return ; else System . out . print ( test + " ▁ " ) ; printFun ( test - 1 ) ; System . out . println ( test + " ▁ " ) ; }
static void shiftMatrixByK ( int mat [ ] [ ] , int k ) { if ( k > N ) System . out . println ( " shifting ▁ is ▁ not ▁ possible " ) ; return ; } int j = 0 ; while ( j < N ) { for ( int i = 0 ; i < k ; i ++ ) System . out . print ( mat [ j ] [ i ] + " ▁ " ) ; } System . out . println ( ) ; j = j + 1 ; } }
static void sortUsingHash ( int [ ] a , int n ) { int Max = Math . max ( a ) ; int Min = Math . min ( a ) ; int [ ] hashpos = new int [ Max + 1 ] ; int [ ] hashneg = new int [ Min + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] >= 0 ) hashpos [ a [ i ] ] ++ ; else hashneg [ Math . abs ( a [ i ] ) ] ++ ; } for ( int i = Min ; i < Max ; i ++ ) { if ( hashneg [ i ] != 0 ) for ( int j = 0 ; j != 0 ; j ++ ) System . out . print ( ( - 1 ) * i + " ▁ " ) ; } for ( int i = 0 ; i <= Max ; i ++ ) { if ( hashpos [ i ] != 0 ) for ( int j = 0 ; j != hashpos [ i ] ; j ++ ) System . out . print ( i + " ▁ " ) ; } } }
static void findPair ( int arr [ ] , int n ) { boolean found = false ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { for ( int k = 0 ; k < n ; k ++ ) { if ( arr [ i ] + arr [ j ] == arr [ k ] ) found = true ; } } } if ( found == false ) System . out . println ( " Not ▁ exist " ) ; }
static int findMaxGCD ( int arr [ ] , int n ) { int high = 0 ; for ( int i = 0 ; i < n ; i ++ ) { high = Math . max ( high , arr [ i ] ) ; } int [ ] count = new int [ high + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { count [ arr [ i ] ] ++ ; } int counter = 0 ; for ( int i = high ; i >= 0 ; i -- ) { for ( int j = i ; j <= high ; j += i ) if ( count [ j ] > 0 ) ++ counter ; if ( counter == 2 ) return i ; } return - 1 ; }
static boolean squareRootExists ( int n , int p ) { n = n % p ; for ( int x = 2 ; x <= p ; x ++ ) if ( ( x * x ) % p == n ) return true ; return false ; }
static int count ( int n , int x ) { int cnt = 0 ; for ( int i = 1 ; i <= n ; i ++ ) if ( x / i <= n && x % i == 0 ) cnt ++ ; return cnt ; }
static int maxSubArraySum ( int a [ ] , int size ) { int max_so_far = Integer . MIN_VALUE ; int max_ending_here = 0 ; int start = 0 , end = 0 , s = 0 ; for ( int i = 0 ; i < size ; i ++ ) { max_ending_here += a [ i ] ; if ( max_so_far < max_ending_here ) { max_so_far = max_ending_here ; start = s ; end = i ; } if ( max_ending_here < 0 ) { max_ending_here = 0 ; s = i + 1 ; } } return ( end - start + 1 ) ; }
static void smallestSubsegment ( int [ ] a , int n ) { HashMap < Integer , Integer > left = new HashMap < Integer , Integer > ( ) ; int count [ ] = new int [ 2 * n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { int x = a [ i ] ; if ( ! left . containsKey ( x ) ) { left [ x ] = i ; count [ x ] = 1 ; } else { count [ x ] ++ ; } if ( count [ x ] > mx ) { mx = count [ x ] ; mn = i - left [ x ] + 1 ; strindex = left [ x ] ; } else if ( count [ x ] == mx && i - left [ x ] + 1 < mn ) { mn = i - left [ x ] + 1 ; strindex = left [ x ] ; } } for ( int i = strindex ; i <= strindex + mn ; i ++ ) System . out . print ( a [ i ] + " ▁ " ) ; }
static void findRandomIndexOfMax ( int arr [ ] , int n ) { Map < Integer , Integer > myMap = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( myMap . containsKey ( arr [ i ] ) ) { myMap . put ( arr [ i ] , myMap . get ( arr [ i ] ) + 1 ) ; } else { myMap . put ( arr [ i ] , 1 ) ; } } int max_element = - 323567 ; int max_so_far = - 323567 ; int r = ( ( random . randrange ( 1 , max_so_far , 2 ) % max_so_far ) + 1 ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == max_element ) { count ++ ; } if ( count == r ) { System . out . println ( " Element ▁ with ▁ maximum ▁ frequency ▁ present ▁ at ▁ index ▁ " + i ) ; break ; } }
static int minRadius ( int k , int x [ ] , int y [ ] , int n ) { int dis [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) dis [ i ] = x [ i ] * x [ i ] + y [ i ] * y [ i ] ; Arrays . sort ( dis ) ; return dis [ k - 1 ] ; }
static double singleNumber ( int [ ] nums ) { return ( 3 * sum ( nums ) - sum ( nums ) ) / 2 ; }
static int countInRange ( int arr [ ] , int n , int x , int y ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] >= x && arr [ i ] <= y ) count ++ ; return count ; }
static void findSmallest ( int m , int s ) { if ( s == 0 ) { if ( m == 1 ) System . out . println ( " Smallest ▁ number ▁ is ▁ 0 " ) ; else System . out . println ( " Not ▁ possible " ) ; return ; } if ( s > 9 * m ) System . out . println ( " Not ▁ possible " ) ; return ; }
static boolean isPresent ( String s , String q ) { int freq [ ] = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) freq [ s . charAt ( i ) ] ++ ; for ( int i = 0 ; i < q . length ( ) ; i ++ ) freq [ q . charAt ( i ) ] -- ; if ( freq [ q . charAt ( i ) ] < 0 ) return false ; return true ; }
static void sortArray ( int arr [ ] , int n , int A , int B , int C ) { for ( int i = 0 ; i < n ; i ++ ) { int index = - ( Integer ) arr [ i ] * arr [ i ] + B * arr [ i ] + C ; int maximum = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { if ( maximum < arr [ i ] ) { index = i ; maximum = arr [ i ] ; } } int i = 0 , j = n - 1 ; int k ; for ( i = 0 ; i < index && j > index ; i ++ ) { if ( arr [ i ] < arr [ j ] ) { new_arr [ k ] = arr [ i ] ; k ++ ; i ++ ; } else { new_arr [ k ] = arr [ j ] ; k ++ ; j -- ; } } while ( i < index ) { new_arr [ k ] = arr [ i ] ; k ++ ; i ++ ; } while ( j > index ) { new_arr [ k ] = arr [ j ] ; k ++ ; j -- ; } new_arr [ n - 1 ] = maximum ; } for ( i = 0 ; i < n ; i ++ ) { arr [ i ] = new_arr [ i ] ; } }
static void printDistance ( int mat [ ] [ ] ) { int ans [ ] [ ] = new int [ N ] [ M ] ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < M ; j ++ ) ans [ i ] [ j ] = 999999999999 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { for ( int k = 0 ; k < N ; k ++ ) { for ( int l = 0 ; l < M ; l ++ ) { if ( mat [ k ] [ l ] == 1 ) ans [ i ] [ j ] = Math . min ( ans [ i ] [ j ] , Math . abs ( i - k ) + Math . abs ( j - l ) ) ; } } } for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) System . out . print ( ans [ i ] [ j ] + " ▁ " ) ; } System . out . println ( ) ; } }
static int findLastIndex ( String str , char x ) { int index = - 1 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) if ( str . charAt ( i ) == x ) index = i ; return index ; }
static void printAllAPTriplets ( int arr [ ] , int n ) { Vector < Integer > s = new Vector < > ( ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int diff = arr [ j ] - arr [ i ] ; if ( ( arr [ i ] - diff ) in arr ) System . out . print ( " { } ▁ { } ▁ " . format ( ( arr [ i ] - diff ) , arr [ i ] , arr [ j ] ) + " \n " ) ; } } s . add ( arr [ i ] ) ; }
static String simplify ( String str ) { int Len = str . length ( ) ; String res [ ] = new String [ Len ] ; int index = 0 ; int i = 0 ; Stack < Integer > s = new Stack < > ( ) ; s . push ( 0 ) ; while ( i < Len ) { if ( str . charAt ( i ) == ' + ' ) { if ( s . peek ( ) == 1 ) res [ index ] = ' - ' ; index ++ ; } else if ( s . peek ( ) == 0 ) res [ index ] = ' + ' ; index ++ ; } else if ( str . charAt ( i ) == ' - ' ) { if ( s . peek ( ) == 1 ) res [ index ] = ' + ' ; index ++ ; } else if ( str . charAt ( i ) == ' ( ' && i > 0 ) { if ( str . charAt ( i - 1 ) == ' - ' ) x = 0 ; else s . push ( x ) ; } else if ( str . charAt ( i - 1 ) == ' + ' ) s . push ( s . peek ( ) ) ; } else { res [ index ] = str . charAt ( i ) ; index ++ ; } i ++ ; } return res ; }
static double vol_of_dodecahedron ( int side ) { return ( ( 15 + ( 7 * ( Math . sqrt ( 5 ) ) ) / 4 ) * ( Math . pow ( side , 3 ) ) ) ; }
static int countTransformation ( int [ ] a , int [ ] b ) { int n = a . length ; int m = b . length ; if ( m == 0 ) return 1 ; int [ ] [ ] dp = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = i ; j <= n ; j ++ ) { if ( a [ j ] == b [ i ] ) { dp [ i ] [ j ] = 1 ; } else { dp [ i ] [ j ] = 0 ; } } else if ( a [ j ] == b [ i ] ) { dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + 1 ; } else { dp [ i ] [ j ] = dp [ i ] [ j - 1 ] ; } } } return dp [ m - 1 ] [ n - 1 ] ; }
static int sumAtKthLevel ( int tree [ ] , int k , int i , int level ) { if ( tree [ i [ 0 ] ] == ' ( ' ) return 0 ; if ( tree [ i [ 0 ] ] == ' ) ' return 0 ; int sum = 0 ; if ( level == k ) { sum = tree [ i [ 0 ] ] ; i [ 0 ] ++ ; leftsum = sumAtKthLevel ( tree , k , i , level + 1 ) ; i [ 0 ] ++ ; rightsum = sumAtKthLevel ( tree , k , i , level + 1 ) ; i [ 0 ] ++ ; } return sum + leftsum + rightsum ; }
static void printRepeating ( int [ ] arr , int size ) { int [ ] count = new int [ arr . length ] ; System . out . print ( " ▁ Repeating ▁ elements ▁ are ▁ " ) ; for ( int i = 0 ; i < size ; i ++ ) { if ( count [ arr [ i ] ] == 1 ) System . out . print ( arr [ i ] + " ▁ " ) ; else count [ arr [ i ] ] ++ ; } }
static int countPairsWithDiffK ( int arr [ ] , int n , int k ) { int count = 0 ; Arrays . sort ( arr ) ; int l = 0 , r = 0 ; while ( r < n ) { if ( arr [ r ] - arr [ l ] == k ) count ++ ; l ++ ; r ++ ; else if ( arr [ r ] - arr [ l ] > k ) l ++ ; else r ++ ; } return count ; }
static boolean isSubsetSum ( int set [ ] [ ] , int n , int sum ) { boolean [ ] [ ] subset = new boolean [ n + 1 ] [ sum + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { subset [ i ] [ 0 ] = true ; for ( int i = 0 ; i <= sum ; i ++ ) { subset [ 0 ] [ i ] = false ; } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= sum ; j ++ ) { if ( j < set [ i - 1 ] ) subset [ i ] [ j ] = subset [ i - 1 ] [ j ] ; if ( j >= set [ i - 1 ] ) subset [ i ] [ j ] = ( subset [ i - 1 ] [ j ] || subset [ i - 1 ] [ j - set [ i - 1 ] ] ) ; } } } return subset [ n ] [ sum ] ; }
void findMajority ( int [ ] arr , int size ) { int m [ ] = new int [ size ] ; for ( int i = 0 ; i < size ; i ++ ) { if ( m . containsKey ( arr [ i ] ) ) { m [ arr [ i ] ] ++ ; } else { m [ arr [ i ] ] = 1 ; } } int count = 0 ; for ( int key = 0 ; key < m . length ; key ++ ) { if ( m [ key ] > size / 2 ) { count ++ ; System . out . println ( " Majority ▁ found ▁ : - " + key ) ; break ; } } if ( count == 0 ) System . out . println ( " No ▁ Majority ▁ element " ) ; }
static int knapSack ( int W , int wt [ ] , int val [ ] , int n ) { if ( n == 0 || W == 0 ) return 0 ; if ( wt [ n - 1 ] > W ) return knapSack ( W , wt , val , n - 1 ) ; else return Math . max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 ] , wt , val , n - 1 ) , knapSack ( W , wt , val , n - 1 ) ) ; }
static void replaceOriginal ( String s , int n ) { char [ ] r = new char [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { r [ i ] = s . charAt ( n - 1 - i ) ; if ( s . charAt ( i ) != ' a ' && s . charAt ( i ) != ' e ' && s . charAt ( i ) != ' i ' && s . charAt ( i ) != ' o ' && s . charAt ( i ) != ' u ' ) System . out . print ( r [ i ] ) ; } System . out . println ( ) ; }
static void findPair ( int [ ] arr , int n ) { HashMap < Integer , Integer > hM = new HashMap < Integer , Integer > ( ) ; boolean found = false ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] + arr [ j ] == hM . get ( arr [ i ] + arr [ j ] ) ) { System . out . println ( arr [ i ] + " ▁ exist " ) ; } } if ( found == false ) System . out . println ( " Not ▁ exist " ) ; }
static int countNonEmptySubstr ( String str ) { int n = str . length ( ) ; return n * ( n + 1 ) / 2 ; }
static int countDigits ( int a , int b ) { int count = 0 ; int p = Math . abs ( a * b ) ; if ( p == 0 ) return 1 ; while ( p > 0 ) { count ++ ; p = p / 10 ; } return count ; }
static int maxProfit ( int price [ ] , int n ) { int [ ] profit = new int [ n ] ; int max_price = price [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( price [ i ] > max_price ) max_price = price [ i ] ; profit [ i ] = Math . max ( profit [ i + 1 ] , max_price - price [ i ] ) ; } int min_price = price [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( price [ i ] < min_price ) min_price = price [ i ] ; profit [ i ] = Math . max ( profit [ i - 1 ] , profit [ i ] + ( price [ i ] - min_price ) ) ; } int result = profit [ n - 1 ] ; return result ; }
static int countDer ( int n ) { int [ ] der = new int [ n + 1 ] ; der [ 0 ] = 1 ; der [ 1 ] = 0 ; der [ 2 ] = 1 ; for ( int i = 3 ; i <= n ; i ++ ) der [ i ] = ( i - 1 ) * ( der [ i - 1 ] + der [ i - 2 ] ) ; return der [ n ] ; }
static int findMaxPath ( int mat [ ] [ ] ) { int res = - 1 ; for ( int i = 0 ; i < M ; i ++ ) res = Math . max ( res , mat [ 0 ] [ i ] ) ; for ( int i = 1 ; i < N ; i ++ ) { int j ; for ( j = 0 ; j < M ; j ++ ) { if ( j > 0 && j < M - 1 ) res += Math . max ( mat [ i - 1 ] [ j ] , Math . max ( mat [ i - 1 ] [ j - 1 ] , mat [ i - 1 ] [ j + 1 ] ) ) ; else if ( j > 0 ) mat [ i ] [ j ] += Math . max ( mat [ i - 1 ] [ j ] , mat [ i - 1 ] [ j - 1 ] ) ; else if ( j < M - 1 ) res = Math . max ( mat [ i ] [ j ] , res ) ; } } return res ; }
static boolean checkIsAP ( int arr [ ] , int n ) { if ( n == 1 ) return true ; Arrays . sort ( arr ) ; int d = arr [ 1 ] - arr [ 0 ] ; for ( int i = 2 ; i < n ; i ++ ) { if ( arr [ i ] - arr [ i - 1 ] != d ) return false ; } return true ; }
static boolean check ( char str [ ] ) { int n = str . length ; int oddDigSum = 0 , evenDigSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) oddDigSum = oddDigSum + ( ( int ) ( str [ i ] ) ) ; else evenDigSum = evenDigSum + ( ( int ) ( str [ i ] ) ) ; } return ( ( oddDigSum - evenDigSum ) % 11 == 0 ) ; }
static void swap ( int xp [ ] , int yp [ ] ) { xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] ; yp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] ; xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] ; }
static double find_Area ( int r ) { return ( 2 * r * r ) ; }
static int isLucky ( int n ) { int [ ] ar = new int [ 10 ] ; while ( n > 0 ) { int digit = ( int ) Math . floor ( n % 10 ) ; if ( ar [ digit ] ) return 0 ; ar [ digit ] = 1 ; n = n / 10 ; } return 1 ; }
static void countWaysToJump ( int arr [ ] , int n ) { int [ ] count_jump = new int [ n ] ; for ( int i = 0 ; i < n - 2 ; ++ i ) { if ( arr [ i ] >= n - i - 1 ) count_jump [ i ] ++ ; int j ; for ( j = i + 1 ; j < n - 1 && j <= arr [ i ] + i ; ++ j ) { if ( count_jump [ j ] != - 1 ) count_jump [ i ] += count_jump [ j ] ; } if ( count_jump [ i ] == 0 ) count_jump [ i ] = - 1 ; } for ( int i = 0 ; i < n ; ++ i ) System . out . print ( count_jump [ i ] + " ▁ " ) ; }
static void zodiac_sign ( int day , int month ) { if ( month == ' december ' ) { System . out . println ( " Sagittarius " + ( day < 22 ) + " capricorn " ) ; } else if ( month == ' january ' ) { System . out . println ( " Capricorn " + ( day < 20 ) + " aquarius " ) ; } else if ( month == ' february ' ) { System . out . println ( " Aquarius " + ( day < 19 ) + " pisces " ; } else if ( month == ' march ' ) { System . out . println ( " Pisces " + ( day < 21 ) + " aries " ; } else if ( month == ' june ' ) { System . out . println ( " Gemini " + ( day < 21 ) + " cancer " ) ; } else if ( month == ' july ' ) { System . out . println ( " Leo " + ( day < 23 ) + " virgo " ) ; } else if ( month == ' october ' ) { System . out . println ( " Libra " + ( day < 23 ) + " scorpio " ; } else if ( month == ' november ' ) { System . out . println ( " Scorpio " + ( day < 22 ) + " sagittarius " ) ; } else { System . out . println ( astro_sign ) ; } }
static int countSol ( int coeff [ ] , int n , int rhs ) { int [ ] dp = new int [ rhs + 1 ] ; dp [ 0 ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = coeff [ i ] ; j <= rhs ; j ++ ) dp [ j ] += dp [ j - coeff [ i ] ] ; } return dp [ rhs ] ; }
static boolean isSymmetric ( int mat [ ] [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) return false ; return true ; }
static boolean isRectangle ( int m [ ] [ ] ) { int rows = m . length ; if ( rows == 0 ) return false ; int columns = m [ 0 ] . length ; for ( int y1 = 0 ; y1 < rows ; y1 ++ ) { for ( int x1 = 0 ; x1 < columns ; x1 ++ ) { if ( m [ y1 ] [ x1 ] == 1 ) { for ( int y2 = y1 + 1 ; y2 < rows ; y2 ++ ) { for ( int x2 = x1 + 1 ; x2 < columns ; x2 ++ ) { if ( m [ y1 ] [ x2 ] == 1 && m [ y2 ] [ x1 ] == 1 && m [ y2 ] [ x2 ] == 1 ) return true ; } } } } return false ; }
static boolean isDivBy9 ( int n ) { if ( n == 0 || n == 9 ) return true ; if ( n < 9 ) return false ; return isDivBy9 ( ( int ) ( n >> 3 ) - ( int ) ( n & 7 ) ) ; }
static int knapSack ( int W , int wt [ ] , int val [ ] , int n ) { if ( n == 0 || W == 0 ) return 0 ; if ( wt [ n - 1 ] > W ) return knapSack ( W , wt , val , n - 1 ) ; else return Math . max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 ] , wt , val , n - 1 ) , knapSack ( W , wt , val , n - 1 ) ) ; }
static void printRepeating ( int arr [ ] , int size ) { int xor = arr [ 0 ] ; int n = size - 2 ; int x = 0 , y = 0 ; for ( int i = 1 ; i < size ; i ++ ) xor ^= arr [ i ] ; for ( int i = 1 ; i < n + 1 ; i ++ ) xor ^= arr [ i ] ; int set_bit_no = xor & ~ ( xor - 1 ) ; for ( int i = 0 ; i < size ; i ++ ) { if ( arr [ i ] & set_bit_no ) x = x ^ arr [ i ] ; else y = y ^ arr [ i ] ; } for ( int i = 1 ; i < n + 1 ; i ++ ) { if ( i & set_bit_no ) x = x ^ i ; else y = y ^ i ; } } System . out . println ( " The ▁ two ▁ repeating " + " elements ▁ are ▁ " + y + x ) ; }
static int findSubsequenceCount ( int T [ ] , int S [ ] ) { int m = T . length , n = S . length ; if ( m > n ) return 0 ; int [ ] [ ] mat = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 1 ; i <= m ; i ++ ) { mat [ i ] [ 0 ] = 0 ; } for ( int j = 0 ; j <= n ; j ++ ) { mat [ 0 ] [ j ] = 1 ; } for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( T [ i - 1 ] != S [ j - 1 ] ) { mat [ i ] [ j ] = mat [ i ] [ j - 1 ] ; } else { mat [ i ] [ j ] = ( mat [ i ] [ j - 1 ] + mat [ i - 1 ] [ j - 1 ] ) ; } } } return mat [ m ] [ n ] ; }
static int breakSum ( int n ) { int [ ] dp = new int [ n + 1 ] ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) dp [ i ] = Math . max ( dp [ i / 2 ] + dp [ i / 3 ] + dp [ i / 4 ] , i ) ; return dp [ n ] ; }
static void decToHexa ( int n ) { char [ ] hexaDeciNum = new char [ 100 ] ; int i = 0 ; while ( n != 0 ) { int temp = 0 ; temp = n % 16 ; if ( temp < 10 ) hexaDeciNum [ i ] = ( char ) ( temp + 48 ) ; i ++ ; else { hexaDeciNum [ i ] = ( char ) ( temp + 55 ) ; i ++ ; } n = n / 16 ; } int j = i - 1 ; while ( j >= 0 ) System . out . print ( ( hexaDeciNum [ j ] ) ) ; j -- ; } }
static int gcd ( int a , int b ) { if ( a == b ) return a ; if ( b == 0 ) return b ; if ( a == 0 ) return a ; if ( b == 0 ) return a ; if ( ( ~ a & 1 ) == 1 ) { if ( ( b & 1 ) == 1 ) { return gcd ( a >> 1 , b ) ; } else { return gcd ( a >> 1 , b >> 1 ) << 1 ; } } if ( ( ~ b & 1 ) == 1 ) { return gcd ( a , b >> 1 ) ; } if ( ( ~ b & 1 ) == 1 ) { return gcd ( a , b >> 1 ) ; } if ( a > b ) return gcd ( ( a - b ) >> 1 , b ) ; return gcd ( ( b - a ) >> 1 , a ) ; }
static boolean oppositeSigns ( int x , int y ) { return ( ( x ^ y ) < 0 ) ; }
static boolean arraySortedOrNot ( int arr [ ] , int n ) { if ( n == 0 || n == 1 ) return true ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i - 1 ] > arr [ i ] ) return false ; return true ; }
static String strToBinary ( String s ) { List < Character > bin_conv = new ArrayList < Character > ( ) ; for ( char c : s ) { int ascii_val = ( int ) c ; bin_conv . add ( ascii_val ) ; } return ( " ▁ " . join ( bin_conv ) ) ; }
static void evaluate ( int n ) { if ( n == 1 || n == 2 ) System . out . println ( " No ▁ Pythagoras " + " ▁ Triplet ▁ exists " ) ; else if ( n % 2 == 0 ) { int var = n * n / 4 ; System . out . println ( " Pythagoras ▁ Triplets ▁ " + " ▁ exist ▁ i . e . ▁ " ) ; System . out . println ( n + " ▁ " + var - 1 + " ▁ " + int ( var + 1 ) ) ; } else if ( n % 2 != 0 ) { int var = n * n + 1 ; System . out . println ( " Pythagoras ▁ Triplets ▁ " + " exist ▁ i . e . ▁ " ) ; System . out . println ( n + " ▁ " + var / 2 - 1 + " ▁ " + var / 2 ) ; } }
static boolean isOverflow ( int a , int b ) { if ( a == 0 || b == 0 ) return false ; int result = a * b ; if ( result >= 9223372036854775807 || result <= - 9223372036854775808 ) result = 0 ; if ( a == ( result / b ) ) System . out . println ( result / b ) ; else return true ; }
static boolean findDuplicateparenthesis ( String str ) { Stack < Character > Stack = new Stack < Character > ( ) ; for ( char ch : str ) { if ( ch == ' ) ' ) { int top = Stack . peek ( ) ; int elementsInside = 0 ; while ( top != ' ( ' ) elementsInside ++ ; top = Stack . peek ( ) ; } if ( elementsInside < 1 ) { return true ; } else { Stack . push ( ch ) ; } } return false ; }
static int countRotations ( int n [ ] ) { int l = n . length ; if ( l == 1 ) { int oneDigit = ( int ) ( n [ 0 ] ) ; if ( oneDigit % 4 == 0 ) return 1 ; return 0 ; } int count = 0 ; for ( int i = 0 ; i < l - 1 ; i ++ ) { int twoDigit = ( int ) ( n [ i ] ) * 10 + ( int ) ( n [ i + 1 ] ) ; if ( twoDigit % 4 == 0 ) count = count + 1 ; } int twoDigit = ( int ) ( n [ l - 1 ] ) * 10 + ( int ) ( n [ 0 ] ) ; if ( twoDigit % 4 == 0 ) count = count + 1 ; return count ; }
static void findTriplets ( int x ) { Vector < Integer > fact = new Vector < > ( ) ; HashSet < Integer > factors = new HashSet < Integer > ( ) ; for ( int i = 2 ; i < sqrt ( x ) ; i ++ ) { if ( x % i == 0 ) fact . add ( i ) ; if ( x / i != i ) fact . add ( x / i ) ; factors . add ( i ) ; } boolean found = false ; for ( int i = 0 ; i < k ; i ++ ) { int a = fact . get ( i ) ; for ( int j = 0 ; j < k ; j ++ ) { int b = fact . get ( j ) ; if ( ( a != b ) && ( x % ( a * b ) == 0 ) && ( x / ( a * b ) != a ) && ( x / ( a * b ) != b ) && ( x / ( a * b ) != 1 ) ) System . out . println ( a , b , x / ( a * b ) ) ; found = true ; break ; } } if ( ! found ) System . out . println ( " - 1" ) ; }
static void findCombinations ( String str , int index , String out ) { if ( index == str . length ( ) ) System . out . println ( out ) ; for ( int i = index ; i < str . length ( ) ; i ++ ) findCombinations ( str , i + 1 , out + " ( " + str . charAt ( index ) + " ) " ) ; }
static int search ( int arr [ ] , int n , int x ) { int i ; for ( i = 0 ; i <= n - 1 ; i ++ ) if ( arr [ i ] == x ) return i ; return - 1 ; }
static void findMissing ( String a [ ] , String b [ ] , int n , int m ) { HashMap < Character , Integer > s = new HashMap < Character , Integer > ( ) ; for ( int i = 0 ; i < m ; i ++ ) s [ b [ i ] ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( ! s . containsKey ( a [ i ] ) ) { System . out . print ( a [ i ] + " ▁ " ) ; } }
static int countPairs ( String str ) { int result = 0 ; int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 1 ; j <= MAX_CHAR ; j ++ ) { if ( ( i + j ) < n ) { if ( ( Math . abs ( str . charAt ( i + j ) - str . charAt ( i ) ) == j ) ) result ++ ; } } } return result ; }
static int maxSum ( int stack1 [ ] , int stack2 [ ] , int stack3 [ ] , int n1 , int n2 , int n3 ) { int sum1 = 0 , sum2 = 0 , sum3 = 0 ; for ( int i = 0 ; i < n1 ; i ++ ) { sum1 += stack1 [ i ] ; } for ( int i = 0 ; i < n2 ; i ++ ) { sum2 += stack2 [ i ] ; } for ( int i = 0 ; i < n3 ; i ++ ) { sum3 += stack3 [ i ] ; } int top1 = 0 , top2 = 0 , top3 = 0 ; int ans = 0 ; while ( 1 ) { if ( top1 == n1 || top2 == n2 || top3 == n3 ) return 0 ; if ( sum1 == sum2 && sum2 == sum3 ) return sum1 ; if ( sum1 >= sum3 && sum1 >= sum3 ) { sum1 -= stack1 [ top1 ] ; top1 = top1 + 1 ; } else if ( sum2 >= sum3 && sum2 >= sum1 ) { sum2 -= stack2 [ top2 ] ; top2 = top2 + 1 ; } else if ( sum3 >= sum2 && sum3 >= sum1 ) { sum3 -= stack3 [ top3 ] ; top3 = top3 + 1 ; } } }
static int solve ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int a = 0 , b = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 != 0 ) a = a * 10 + arr [ i ] ; else b = b * 10 + arr [ i ] ; } return a + b ; }
static int firstFactorialDivisibleNumber ( int x ) { int i = 1 ; int fact = 1 ; for ( i = 1 ; i < x ; i ++ ) { fact = fact * i ; if ( fact % x == 0 ) break ; } return i ; }
static int countMinOperations ( int target [ ] , int n ) { int result = 0 ; while ( true ) { int zero_count = 0 ; int i = 0 ; while ( i < n ) { if ( ( target [ i ] & 1 ) > 0 ) break ; else if ( target [ i ] == 0 ) zero_count ++ ; i ++ ; if ( zero_count == n ) return result ; if ( i == n ) { for ( int j = 0 ; j < n ; j ++ ) target [ j ] = target [ j ] / 2 ; result ++ ; } for ( int j = i ; j < n ; j ++ ) { if ( target [ j ] & 1 ) target [ j ] -= 1 ; result ++ ; } } } return result ; }
static void sortit ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = i + 1 ; }
static boolean canMakeAllSame ( String str ) { int zeros = 0 , ones = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char ch = str . charAt ( i ) ; if ( ch == '0' ) zeros ++ ; else ones ++ ; } return ( zeros == 1 || ones == 1 ) ; }
static void minheapify ( int [ ] a , int index ) { int small = index ; int l = 2 * index + 1 ; int r = 2 * index + 2 ; if ( l < n && a [ l ] < a [ small ] ) small = l ; if ( r < n && a [ r ] < a [ small ] ) small = r ; if ( small != index ) { int temp = a [ small ] ; a [ small ] = temp ; minheapify ( a , small ) ; } }
static void KMP ( int m , int n , String str2 , String str1 ) { int pos = 0 , Len = 0 ; int p [ ] = new int [ m + 1 ] ; int k ; for ( int i = 2 ; i <= n ; i ++ ) { while ( k > 0 && str1 . charAt ( k ) != str1 . charAt ( i - 1 ) ) k ++ ; if ( str1 . charAt ( k ) == str1 . charAt ( i - 1 ) ) k ++ ; p [ i ] = k ; } int j ; for ( int i = 0 ; i < m ; i ++ ) { while ( j > 0 && j < n && str1 . charAt ( j ) != str2 . charAt ( i ) ) j ++ ; if ( j > Len ) Len = j ; pos = i - j + 1 ; } } System . out . println ( " Shift ▁ = ▁ " + pos ) ; System . out . println ( " Prefix ▁ = ▁ " + str1 . charAt ( : Len ) ) ; }
static void swapDiagonal ( int matrix [ ] [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { matrix [ i ] [ i ] , matrix [ i ] [ N - i - 1 ] = matrix [ i ] [ i ] ; } }
static void psuedoBinary ( int n ) { while ( n > 0 ) { int temp = n ; int m = 0 , p = 1 ; while ( temp > 0 ) { int rem = temp % 10 ; temp = temp / 10 ; if ( rem != 0 ) m += p ; p *= 10 ; } System . out . print ( m + " ▁ " ) ; n = n - m ; } }
static int findmin ( int p [ ] [ ] , int n ) { int a = 0 , b = 0 , c = 0 , d = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( p [ i ] [ 0 ] <= 0 ) a ++ ; else if ( p [ i ] [ 0 ] >= 0 ) b ++ ; if ( p [ i ] [ 1 ] >= 0 ) c ++ ; else if ( p [ i ] [ 1 ] <= 0 ) d ++ ; } return Math . min ( [ a , b , c , d ] ) ; }
static int minCoins ( int coins [ ] , int m , int V ) { int table [ ] = new int [ V + 1 ] ; table [ 0 ] = 0 ; for ( int i = 1 ; i <= V ; i ++ ) { table [ i ] = Integer . MAX_VALUE ; } for ( int i = 1 ; i <= V ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( coins [ j ] <= i ) { int sub_res = table [ i - coins [ j ] ] ; if ( sub_res != Integer . MAX_VALUE && sub_res + 1 < table [ i ] ) table [ i ] = sub_res + 1 ; } } } return table [ V ] ; }
static String maximumPalinUsingKChanges ( String str , int k ) { String palin = new String ( ) ; int l = 0 , r = str . length ( ) - 1 ; while ( l <= r ) { if ( str . charAt ( l ) != str . charAt ( r ) ) { palin [ l ] = palin [ r ] = Math . max ( str . charAt ( l ) , str . charAt ( r ) ) ; k -- ; } l ++ ; r -- ; } if ( k < 0 ) return " Not ▁ possible " ; } l = 0 ; r = str . length ( ) - 1 ; while ( l <= r ) { if ( l == r ) { if ( k > 0 ) { palin [ l ] = '9' ; } if ( palin [ l ] < '9' ) { if ( k >= 2 && palin [ l ] == str . charAt ( l ) && palin [ r ] == str . charAt ( r ) ) { k -- ; palin [ l ] = palin [ r ] = '9' ; } else if ( k >= 1 && ( palin [ l ] != str . charAt ( l ) || palin [ r ] != str . charAt ( r ) ) { k -- ; palin [ l ] = palin [ r ] = '9' ; } } l ++ ; r -- ; } return palin ; }
static int findMinRooms ( char [ ] slots , int n , int m ) { int [ ] counts = new int [ m ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) if ( slots [ i ] [ j ] == '1' ) counts [ j ] ++ ; } return Math . max ( counts , 0 ) ; }
static void printMaxSum ( int arr [ ] , int n ) { int dp [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] = arr [ i ] ; int maxi = 0 ; for ( int j = 1 ; j <= Math . pow ( i + 1 , 0.5 ) ; j ++ ) { if ( ( i + 1 ) % j == 0 && ( i + 1 ) != j ) { if ( dp [ j - 1 ] > maxi ) maxi = dp [ j - 1 ] ; if ( dp [ ( i + 1 ) / j - 1 ] > maxi && j != 1 ) maxi = dp [ ( i + 1 ) / j - 1 ] ; } } dp [ i ] += maxi ; } for ( int i = 0 ; i < n ; i ++ ) System . out . print ( dp [ i ] + " ▁ " ) ; }
static int maxAlternateSum ( int arr [ ] , int n ) { if ( n == 1 ) return arr [ 0 ] ; int dec [ ] = new int [ n + 1 ] ; int inc [ ] = new int [ n + 1 ] ; int flag ; for ( int i = 0 ; i <= n ; i ++ ) { dec [ i ] = 0 ; inc [ 0 ] = arr [ 0 ] ; flag = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ j ] > arr [ i ] ) { dec [ i ] = Math . max ( dec [ i ] , inc [ j ] + arr [ i ] ) ; flag = 1 ; } else if ( arr [ j ] < arr [ i ] && flag == 1 ) { inc [ i ] = Math . max ( inc [ i ] , dec [ j ] + arr [ i ] ) ; } } } int result = Integer . MAX_VALUE ; for ( int i = 0 ; i <= n ; i ++ ) { if ( result < inc [ i ] ) result = inc [ i ] ; if ( result < dec [ i ] ) result = dec [ i ] ; } } return result ; }
static void printRepeating ( int arr [ ] , int size ) { System . out . print ( " Repeating ▁ elements ▁ are ▁ " ) ; for ( int i = 0 ; i < size ; i ++ ) { for ( int j = i + 1 ; j < size ; j ++ ) if ( arr [ i ] == arr [ j ] ) System . out . print ( arr [ i ] + " ▁ " ) ; } }
static int minProduct ( int arr [ ] , int n , int k ) { heapify ( arr ) ; int count = 0 ; int ans = 1 ; while ( arr . size > 0 && count < k ) { int x = arr . peek ( ) ; if ( x != null ) ans *= x ; count ++ ; } return ans ; }
static int largest ( int arr [ ] , int n ) { int max = arr . length ; return max > n ? arr [ max ] : Integer . MIN_VALUE ; }
static void exponential ( int n , double x ) { double sum = 1.0 ; for ( int i = n ; i >= 0 ; i -- ) sum = 1 + x * sum / i ; System . out . println ( " e ^ x ▁ = " + sum ) ; }
static int firstElement ( int arr [ ] , int n , int k ) { int count_map [ ] = new int [ arr . length ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( count_map . containsKey ( arr [ i ] ) ) { count_map [ arr [ i ] ] ++ ; } else { count_map [ arr [ i ] ] = 1 ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( count_map . containsKey ( arr [ i ] ) ) { return arr [ i ] ; } i ++ ; } return - 1 ; }
static int maxProd ( int n ) { if ( n == 2 || n == 3 ) return ( n - 1 ) ; int res = 1 ; while ( n > 4 ) { n -= 3 ; res *= 3 ; } return ( n * res ) ; }
static int maxSum ( int grid [ ] [ ] , int n ) { int incl = Math . max ( grid [ 0 ] [ 0 ] , grid [ 1 ] [ 0 ] ) ; int excl = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int excl_new = Math . max ( excl , incl ) ; incl = excl + Math . max ( grid [ 0 ] [ i ] , grid [ 1 ] [ i ] ) ; excl = excl_new ; } return Math . max ( excl , incl ) ; }
static int countRotations ( int arr [ ] , int low , int high ) { if ( high < low ) return 0 ; if ( high == low ) return low ; int mid = ( low + high ) / 2 ; if ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) return ( mid + 1 ) ; if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) return mid ; if ( arr [ high ] > arr [ mid ] ) return countRotations ( arr , low , mid - 1 ) ; return countRotations ( arr , mid + 1 , high ) ; }
static int findSum ( int n ) { int ans = 0 ; int temp = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( temp < n ) { temp = i - 1 ; num = 1 ; while ( temp < n ) { if ( temp + i <= n ) ans += i * num ; else ans += ( n - temp ) * num ; } temp += i ; num ++ ; } } return ans ; }
static boolean checkCorrectOrNot ( String s ) { int count1 [ ] = new int [ MAX_CHAR ] , count2 [ ] = new int [ MAX_CHAR ] ; int n = s . length ( ) ; if ( n == 1 ) return true ; for ( int i = 0 , j = n - 1 ; i < j ; i ++ , j -- ) { count1 [ s . charAt ( i ) - ' a ' ] ++ ; count2 [ s . charAt ( j ) - ' a ' ] ++ ; } for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { if ( count1 [ i ] != count2 [ i ] ) return false ; } return true ; }
static int divSum ( int n ) { int result = 0 ; for ( int i = 2 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( i == ( n / i ) ) result += i ; else result = result + ( i + n / i ) ; } } return ( result + n + 1 ) ; }
static void rotateMatrix ( int mat [ ] [ ] ) { int i = N - 1 ; while ( i >= 0 ) { int j = N - 1 ; while ( j >= 0 ) { System . out . print ( mat [ i ] [ j ] + " ▁ " ) ; j = j - 1 ; } System . out . println ( ) ; i = i - 1 ; } }
static void printSpiral ( char [ ] [ ] mat , int r , int c ) { int a = 0 , b = 2 ; int low_row = 0 ; int low_column = 0 ; if ( 0 > a ) else a ; int high_row = r - 1 ; int high_column = c - 1 ; if ( ( a + 1 ) >= r ) else b + 1 ; while ( ( low_row > 0 - r && low_column > 0 - c ) ) { int i = low_column + 1 ; while ( i <= high_column && i < c && low_row >= 0 ) System . out . print ( mat [ low_row ] [ i ] + " ▁ " ) ; i ++ ; } low_row -- ; while ( ( low_row > 0 - r && low_column > 0 - c ) ) { int i = low_column + 1 ; while ( i <= high_row && i < r && high_column < c ) System . out . print ( mat [ i ] [ high_column ] + " ▁ " ) ; i ++ ; } high_column -- ; while ( i >= low_row && i >= 0 && high_row < r ) System . out . print ( mat [ high_row ] [ i ] + " ▁ " ) ; i -- ; } System . out . println ( ) ; }
static int countSeq ( int n ) { int nCr = 1 ; int res = 1 ; for ( int r = 1 ; r <= n ; r ++ ) nCr = ( nCr * ( n + 1 - r ) ) / r ; res += nCr * nCr ; return res ; }
public static double areaOctagon ( int side ) { return ( 2 * ( 1 + ( Math . sqrt ( 2 ) ) * side * side ) ) ; }
static int findLongestConseqSubseq ( int arr [ ] , int n ) { HashSet < Integer > S = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) S . add ( arr [ i ] ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( S . contains ( arr [ i ] ) ) { int j = arr [ i ] ; while ( S . contains ( j ) ) j ++ ; if ( ans < j - arr [ i ] ) ans = j - arr [ i ] ; } } return ans ; }
static void printSuperSeq ( String a , String b ) { int m = a . length ( ) ; int n = b . length ( ) ; int dp [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( ! i ) { dp [ i ] [ j ] = j ; } else if ( j == i ) { dp [ i ] [ j ] = i ; } else if ( a [ i - 1 ] == b [ j - 1 ] ) { dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; } else { dp [ i ] [ j ] = 1 + Math . min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) ; } } } int index = dp [ m ] [ n ] ; String res [ ] = " " ; int i = m , j = n ; while ( i > 0 && j > 0 ) { if ( a [ i - 1 ] == b [ j - 1 ] ) { res [ index - 1 ] = a [ i - 1 ] ; i -- ; j -- ; index -- ; } else if ( dp [ i - 1 ] [ j ] < dp [ i ] [ j - 1 ] ) { res [ index - 1 ] = b [ j - 1 ] ; j -- ; index -- ; } else { res [ index - 1 ] = a [ i - 1 ] ; i -- ; index -- ; } } while ( i > 0 ) { res [ index - 1 ] = a [ i - 1 ] ; i -- ; index -- ; } while ( j > 0 ) { res [ index - 1 ] = b [ j - 1 ] ; j -- ; index -- ; } while ( j > 0 ) { res [ index - 1 ] = b [ j - 1 ] ; j -- ; index -- ; } } res [ index - 1 ] = b [ j - 1 ] ; index -- ; } while ( i > 0 ) { res [ index - 1 ] = a [ i - 1 ] ; i -- ; index -- ; } while ( j > 0 ) { res [ index - 1 ] = b [ j - 1 ] ; j -- ; index -- ; } while ( j >
public static int numberOfPaths ( int p , int q ) { int [ ] dp = new int [ p ] ; dp [ 0 ] = 1 ; for ( int i = 1 ; i < p - 1 ; i ++ ) { for ( int j = 1 ; j < q ; j ++ ) dp [ j ] += dp [ j - 1 ] ; } return dp [ q - 1 ] ; }
static boolean isPowerOfFour ( int n ) { int count = 0 ; if ( n && ( ! ( n & ( n - 1 ) ) ) ) { while ( n > 1 ) { n >>= 1 ; count ++ ; if ( count % 2 == 0 ) return true ; else return false ; } } return false ; }
static int sumofoddFactors ( int n ) { int res = 1 ; while ( n % 2 == 0 ) { n = n / 2 ; } for ( int i = 3 ; i <= Math . sqrt ( n ) ; i ++ ) { int count = 0 ; int curr_sum = 1 ; int curr_term = 1 ; while ( n % i == 0 ) { count ++ ; n = n / i ; curr_term *= i ; curr_sum += curr_term ; } res *= curr_sum ; } if ( n >= 2 ) res *= ( 1 + n ) ; return res ; }
static int findElement ( int arr [ ] , int n ) { int leftMax [ ] = new int [ n ] ; leftMax [ 0 ] = Integer . MIN_VALUE ; for ( int i = 1 ; i < n ; i ++ ) leftMax [ i ] = Math . max ( leftMax [ i - 1 ] , arr [ i - 1 ] ) ; int rightMin = Integer . MIN_VALUE ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( leftMax [ i ] < arr [ i ] && rightMin > arr [ i ] ) return i ; rightMin = Math . min ( rightMin , arr [ i ] ) ; } return - 1 ; }
static int search ( int [ ] arr , int l , int h , int key ) { if ( l > h ) return - 1 ; int mid = ( l + h ) / 2 ; if ( arr [ mid ] == key ) return mid ; if ( arr [ l ] <= arr [ mid ] ) { if ( key >= arr [ l ] && key <= arr [ mid ] ) search ( arr , l , mid - 1 , key ) ; return search ( arr , mid + 1 , h , key ) ; } if ( key >= arr [ mid ] && key <= arr [ h ] ) search ( a , mid + 1 , h , key ) ; if ( key >= arr [ mid ] && key <= arr [ h ] ) search ( a , mid + 1 , h , key ) ; return search ( arr , l , mid - 1 , key ) ; } return search ( arr , l , mid - 1 , key ) ; }
static int exponentiation ( int bas , int exp ) { if ( exp == 0 ) return 1 ; if ( exp == 1 ) return bas % N ; int t = exponentiation ( bas , exp / 2 ) ; t = ( t * t ) % N ; if ( exp % 2 == 0 ) return t ; else return ( ( bas % N ) * t ) % N ; }
static void divisibilityCheck ( int arr [ ] , int n ) { HashMap < Integer , Integer > s = new HashMap < Integer , Integer > ( ) ; int max_ele = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { s . put ( arr [ i ] , 1 ) ; max_ele = Math . max ( max_ele , arr [ i ] ) ; } HashMap < Integer , Integer > res = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != 0 ) { for ( int j = arr [ i ] * 2 ; j <= max_ele ; j ++ ) { if ( s . containsKey ( j ) ) res . put ( j , 1 ) ; } } } for ( int x = 0 ; x < res . keys ( ) ; x ++ ) System . out . print ( x + " ▁ " ) ; }
static void printRepeating ( int arr [ ] , int size ) { System . out . print ( " ▁ The ▁ repeating ▁ elements ▁ are ▁ " ) ; for ( int i = 0 ; i < size ; i ++ ) { if ( arr [ Math . abs ( arr [ i ] ) ] > 0 ) arr [ Math . abs ( arr [ i ] ) ] = ( - 1 ) * arr [ Math . abs ( arr [ i ] ) ; else System . out . print ( arr [ i ] + " ▁ " ) ; } }
static int minPalPartion ( String str ) { int n = str . length ( ) ; int [ ] C = new int [ n ] [ n ] ; boolean [ ] [ ] P = new boolean [ n ] [ n ] ; int i , j , k , L ; for ( i = 0 ; i < n ; i ++ ) { P [ i ] [ i ] = true ; C [ i ] [ i ] = 0 ; } for ( L = 2 ; L <= n ; L ++ ) { for ( i = 0 ; i < n - L + 1 ; i ++ ) { j = i + L - 1 ; if ( L == 2 ) P [ i ] [ j ] = ( str . charAt ( i ) == str . charAt ( j ) ) ; else P [ i ] [ j ] = ( str . charAt ( i ) == str . charAt ( j ) ) && P [ i + 1 ] [ j - 1 ] ; if ( P [ i ] [ j ] == true ) C [ i ] [ j ] = 0 ; else { C [ i ] [ j ] = Integer . MAX_VALUE ; for ( k = i ; k <= j ; k ++ ) C [ i ] [ j ] = Math . min ( C [ i ] [ j ] , C [ i ] [ k ] + C [ k + 1 ] [ j ] + 1 ) ; } } } return C [ 0 ] [ n - 1 ] ; }
static long height ( int N ) { return ( long ) Math . ceil ( Math . log2 ( N + 1 ) ) - 1 ; }
static boolean checkCount ( int arr [ ] , int n , int k ) { Map < Integer , Integer > myMap = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) myMap . put ( arr [ i ] , myMap . get ( arr [ i ] ) + 1 ) ; for ( int key = 0 ; key < myMap . keySet ( ) ; key ++ ) { if ( myMap . get ( key ) > 2 * k ) return false ; } return true ; }
static char [ ] removeDuplicates ( char [ ] S ) { int n = S . length ; if ( n < 2 ) return S ; int j = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( S [ j ] != S [ i ] ) j ++ ; S [ j ] = S [ i ] ; } S = S [ : j ] ; return S ; }
static void thirdLargest ( int arr [ ] , int arr_size ) { if ( arr_size < 3 ) { System . out . println ( " ▁ Invalid ▁ Input ▁ " ) ; return ; } int first = arr [ 0 ] ; int second = - 1 , third = - 1 ; for ( int i = 1 ; i < arr_size ; i ++ ) { if ( arr [ i ] > first ) { third = second ; second = first ; first = arr [ i ] ; } else if ( arr [ i ] > second ) { third = second ; second = arr [ i ] ; } else if ( arr [ i ] > third ) { third = arr [ i ] ; } } System . out . println ( " The ▁ third ▁ Largest " + " element ▁ is ▁ " + third ) ; }
static int longOddEvenIncSeq ( int arr [ ] , int n ) { List < Integer > lioes = new ArrayList < Integer > ( ) ; int maxLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { lioes . add ( 1 ) ; } i ++ ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ i ] > arr [ j ] && ( arr [ i ] + arr [ j ] ) % 2 != 0 && lioes [ i ] < lioes [ j ] + 1 ) lioes [ i ] = lioes [ j ] + 1 ; } } for ( int i = 0 ; i < n ; i ++ ) if ( maxLen < lioes [ i ] ) maxLen = lioes [ i ] ; return maxLen ; }
static int addOne ( int x ) { return ( int ) ( ~ x ) ) ; }
static int getNumStrictMonotone ( int ln ) { int [ ] [ ] DP = new int [ ln ] [ DP_s ] ; for ( int i = 0 ; i < DP_s ; i ++ ) DP [ 0 ] [ i ] = i + 1 ; for ( int i = 1 ; i < ln ; i ++ ) { for ( int j = 1 ; j < DP_s ; j ++ ) DP [ i ] [ j ] = DP [ i - 1 ] [ j - 1 ] + DP [ i ] [ j - 1 ] ; } return DP [ ln - 1 ] [ DP_s - 1 ] ; }
static int binarySearch ( int arr [ ] , int l , int r , int x ) { if ( r >= l ) { int mid = ( l + ( r - l ) / 2 ) ; if ( arr [ mid ] == x ) return mid ; if ( mid > l && arr [ mid - 1 ] == x ) return ( mid - 1 ) ; if ( mid < r && arr [ mid + 1 ] == x ) return ( mid + 1 ) ; if ( arr [ mid ] > x ) return binarySearch ( arr , l , mid - 2 , x ) ; return binarySearch ( arr , mid + 2 , r , x ) ; } return - 1 ; }
static void bresenham ( int x1 , int y1 , int x2 , int y2 ) { int m_new = 2 * ( y2 - y1 ) ; int slope_error_new = m_new - ( x2 - x1 ) ; int y = y1 ; for ( int x = x1 ; x <= x2 ; x ++ ) { System . out . print ( " ( " + x + " , " + y + " ) \n " ) ; slope_error_new = slope_error_new + m_new ; if ( slope_error_new >= 0 ) y = y + 1 ; slope_error_new = slope_error_new - 2 * ( x2 - x1 ) ; } }
static int maxRevenue ( int m , int x [ ] , int revenue [ ] , int n , int t ) { int maxRev [ ] = new int [ m + 1 ] ; int nxtbb ; for ( int i = 1 ; i <= m ; i ++ ) { if ( nxtbb < n ) { if ( x [ nxtbb ] != i ) maxRev [ i ] = maxRev [ i - 1 ] ; else { if ( i <= t ) maxRev [ i ] = Math . max ( maxRev [ i - 1 ] , revenue [ nxtbb ] ) ; else maxRev [ i ] = Math . max ( maxRev [ i - t - 1 ] + revenue [ nxtbb ] , maxRev [ i - 1 ] ) ; } nxtbb ++ ; } else { maxRev [ i ] = maxRev [ i - 1 ] ; } } return maxRev [ m ] ; }
static void lineFromPoints ( int [ ] P , int [ ] Q ) { int a = Q [ 1 ] - P [ 1 ] ; int b = P [ 0 ] - Q [ 0 ] ; int c = a * ( P [ 0 ] ) + b * ( P [ 1 ] ) ; if ( b < 0 ) { System . out . println ( " The ▁ line ▁ passing ▁ through ▁ points ▁ P ▁ and ▁ Q ▁ is : " + a + " x ▁ " + b + " y ▁ = ▁ " + c + " \n " ) ; } else { System . out . println ( " The ▁ line ▁ passing ▁ through ▁ points ▁ P ▁ and ▁ Q ▁ is : " + a + " x ▁ + ▁ " + b + " y ▁ = ▁ " + c + " \n " ) ; } }
static int findMinX ( int num [ ] , int rem [ ] , int k ) { int x = 1 ; while ( true ) { int j ; for ( j = 0 ; j < k ; j ++ ) if ( x % num [ j ] != rem [ j ] ) break ; if ( j == k ) return x ; x ++ ; } }
boolean find3Numbers ( int A [ ] , int arr_size , int sum ) { for ( int i = 0 ; i < arr_size - 2 ; i ++ ) { for ( int j = i + 1 ; j < arr_size - 1 ; j ++ ) { for ( int k = j + 1 ; k < arr_size ; k ++ ) { if ( A [ i ] + A [ j ] + A [ k ] == sum ) { System . out . print ( " Triplet ▁ is ▁ " + A [ i ] + " , ▁ " + A [ j ] + " , ▁ " + A [ k ] ) ; return true ; } } } return false ; }
static void KMaxCombinations ( int A [ ] , int B [ ] , int N , int K ) { PriorityQueue < Integer > pq = new PriorityQueue < Integer > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { int a = A [ i ] + B [ j ] ; pq . add ( ( int ) a ) ; } } int count = 0 ; while ( count < K ) System . out . println ( pq . peek ( ) [ 1 ] ) ; count ++ ; }
public static double numberOfSticks ( int x ) { return ( 3 * x * ( x + 1 ) ) / 2 ; }
static int countSubstringWithEqualEnds ( String s ) { int result = 0 ; int n = s . length ( ) ; int [ ] count = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < n ; i ++ ) count [ s . charAt ( i ) - ' a ' ] ++ ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) result += count [ i ] * ( count [ i ] + 1 ) / 2 ; return result ; }
static boolean isDivisibleBy7 ( int num ) { if ( num < 0 ) return isDivisibleBy7 ( - num ) ; if ( num == 0 || num == 7 ) return true ; if ( num < 10 ) return false ; return isDivisibleBy7 ( num / 10 - 2 * ( num - num / 10 * 10 ) ) ; }
static int findRepeatingNumber ( int arr [ ] , int n ) { double sq = sqrt ( n ) ; int range__ = ( n / sq ) + 1 ; int [ ] count = new int [ range__ ] ; for ( int i = 0 ; i < range__ ; i ++ ) { count [ i ] = 0 ; } int selected_block = range__ - 1 ; for ( int i = 0 ; i < range__ - 1 ; i ++ ) { if ( count [ i ] > sq ) { selected_block = i ; break ; } } int m [ ] = new int [ n ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) { if ( ( ( selected_block * sq ) < arr [ i ] ) && ( arr [ i ] <= ( ( selected_block + 1 ) * sq ) ) ) m [ arr [ i ] ] ++ ; if ( m [ arr [ i ] ] > 1 ) return arr [ i ] ; } } return - 1 ; }
static int findSDSFunc ( int n ) { int [ ] DP = new int [ n + 1 ] ; DP [ 0 ] = 0 ; DP [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { if ( i % 2 == 0 ) DP [ i ] = DP [ i / 2 ] ; else DP [ i ] = DP [ ( i - 1 ) / 2 ] + DP [ ( i + 1 ) / 2 ] ; } return DP [ n ] ; }
static int recSearch ( int arr [ ] , int l , int r , int x ) { if ( r < l ) return - 1 ; if ( arr [ l ] == x ) return l ; if ( arr [ r ] == x ) return r ; return recSearch ( arr , l + 1 , r - 1 , x ) ; }
static boolean check ( String str ) { int n = str . length ( ) ; if ( n == 0 ) return false ; if ( n == 1 ) return ( ( str . charAt ( 0 ) - '0' ) % 4 == 0 ) ; int last = ( int ) ( str . charAt ( n - 1 ) ) ; int second_last = ( int ) ( str . charAt ( n - 2 ) ) ; return ( ( second_last * 10 + last ) % 4 == 0 ) ; }
static String to_upper ( String str ) { for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( ' a ' <= str . charAt ( i ) <= ' z ' ) str = str . charAt ( 0 ) + ( str . charAt ( i ) - ' a ' + ' A ' ) + str . charAt ( i + 1 ) ; } return str ; }
static int remAnagram ( String str1 , String str2 ) { int count1 [ ] = new int [ CHARS ] ; int count2 [ ] = new int [ CHARS ] ; int i ; for ( i = 0 ; i < str1 . length ( ) ; i ++ ) { count1 [ str1 . charAt ( i ) - ' a ' ] ++ ; i ++ ; } i = 0 ; while ( i < str2 . length ( ) ) { count2 [ str2 . charAt ( i ) - ' a ' ] ++ ; i ++ ; } int result = 0 ; for ( i = 0 ; i < 26 ; i ++ ) result += Math . abs ( count1 [ i ] - count2 [ i ] ) ; return result ; }
static void sortInWave ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i += 2 ) { if ( i > 0 && arr [ i ] < arr [ i - 1 ] ) arr [ i ] = arr [ i - 1 ] ; if ( i < n - 1 && arr [ i ] < arr [ i + 1 ] ) arr [ i ] = arr [ i + 1 ] ; arr [ i + 1 ] = arr [ i ] ; } }
static String getMinNumberForPattern ( String seq ) { int n = seq . length ( ) ; if ( n >= 9 ) return " - 1" ; int [ ] result = new int [ n + 1 ] ; int count = 1 ; for ( int i = 0 ; i <= n ; i ++ ) { if ( i == n || seq . charAt ( i ) == ' I ' ) { for ( int j = i - 1 ; j >= 0 && seq . charAt ( j ) == ' I ' ; j -- ) { result [ j + 1 ] = ( char ) ( count + 1 ) ; count ++ ; if ( j >= 0 && seq . charAt ( j ) == ' I ' ) break ; } } } return result ; }
static boolean isPossible ( String str , int n ) { int l = str . length ( ) ; if ( l >= n ) return true ; return false ; }
static void center ( int x1 , int x2 , int y1 , int y2 ) { System . out . print ( ( x1 + x2 ) / 2 + " , " ) ; System . out . println ( ( y1 + y2 ) / 2 + " \n " ) ; }
static void findMin ( int V ) { int [ ] deno = new int [ ] { 1 , 2 , 5 , 10 , 20 , 50 , 100 , 500 , 1000 } ; Vector < Integer > ans = new Vector < > ( ) ; int n = deno . length ; for ( int i = n - 1 ; i >= 0 ; i -- ) { while ( V >= deno . get ( i ) ) { V -= deno . get ( i ) ; ans . add ( deno . get ( i ) ) ; } } for ( int i = 0 ; i < ans . size ( ) ; i ++ ) System . out . print ( ans . get ( i ) + " ▁ " ) ; }
static int mulmod ( int a , int b , int mod ) { int res = 0 ; a = a % mod ; b = b % mod ; while ( b > 0 ) { if ( b % 2 == 1 ) res += a ; a = ( a * 2 ) % mod ; b /== 2 ; } return res % mod ; }
static String Dragon_Curve_Sequence ( int n ) { String s = "1" ; for ( int i = 2 ; i <= n ; i ++ ) { String temp = "1" ; int prev = '1' ; int zero = '0' , one = '1' ; for ( int j = 0 ; j < s . length ( ) ; j ++ ) { temp += s . charAt ( j ) ; if ( prev == '0' ) temp += one ; prev = one ; } else temp += zero ; } s = temp ; } return s ; }
static int minInitialPoints ( int [ ] [ ] points ) { int [ ] [ ] dp = new int [ R + 1 ] [ C + 1 ] ; int m , n ; for ( m = 0 ; m <= R ; m ++ ) { n = R ; } if ( points [ m - 1 ] [ n - 1 ] > 0 ) { dp [ m - 1 ] [ n - 1 ] = 1 ; } else { dp [ m - 1 ] [ n - 1 ] = Math . abs ( points [ m - 1 ] [ n - 1 ] ) + 1 ; } for ( int i = m - 2 ; i >= 0 ; i -- ) { dp [ i ] [ n - 1 ] = Math . max ( dp [ i + 1 ] [ n - 1 ] - points [ i ] [ n - 1 ] , 1 ) ; } for ( int i = m - 2 ; i >= 0 ; i -- ) { for ( int j = n - 2 ; j >= 0 ; j -- ) { int min_points_on_exit = Math . min ( dp [ i + 1 ] [ j ] , dp [ i ] [ j + 1 ] ) ; dp [ i ] [ j ] = Math . max ( min_points_on_exit - points [ i ] [ j ] , 1 ) ; } } return dp [ 0 ] [ 0 ] ; }
static int findRepeating ( int arr [ ] , int n ) { return sum ( arr ) - ( ( n - 1 ) * n ) / 2 ; }
static char getSecondMostFreq ( String str ) { int NO_OF_CHARS = 256 ; int [ ] count = new int [ NO_OF_CHARS ] ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { count [ str . charAt ( i ) ] ++ ; } int first = 0 , second = 0 ; for ( int i = 0 ; i < NO_OF_CHARS ; i ++ ) { if ( count [ i ] > count [ first ] ) { second = first ; first = i ; } else if ( count [ i ] > count [ second ] && count [ i ] != count [ first ] ) second = i ; } return ( char ) second ; }
static String findSum ( String str1 , String str2 ) { if ( str1 . length ( ) > str2 . length ( ) ) { String t = str1 ; str1 = str2 ; str2 = t ; } String str = " " ; int n1 = str1 . length ( ) ; int n2 = str2 . length ( ) ; String carry = 0 ; for ( int i = 0 ; i < n1 ; i ++ ) { int sum = ( ( str1 . charAt ( i ) - 48 ) + ( ( str2 . charAt ( i ) - 48 ) + carry ) ) ; str += ( sum % 10 + 48 ) ; carry = ( int ) ( sum / 10 ) ; } for ( int i = n1 ; i < n2 ; i ++ ) { int sum = ( ( str2 . charAt ( i ) - 48 ) + carry ) ; str += ( sum % 10 + 48 ) ; carry = ( int ) ( sum / 10 ) ; } if ( carry ) str += ( carry + 48 ) ; return str ; }
static void printNGE ( int arr [ ] ) { for ( int i = 0 ; i < arr . length ; i ++ ) { int next = - 1 ; for ( int j = i + 1 ; j < arr . length ; j ++ ) { if ( arr [ i ] < arr [ j ] ) next = arr [ j ] ; break ; } System . out . println ( arr [ i ] + " ▁ - - ▁ " + next ) ; } }
