static void printPairs ( int arr [ ] , int n ) { int [ ] v = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( Math . abs ( arr [ i ] ) == Math . abs ( arr [ j ] ) ) v . add ( Math . abs ( arr [ i ] ) ) ; } } Collections . sort ( v ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( - v [ i ] + " ▁ " ) ; }
static void findArea ( int a , int b , int c ) { if ( a < 0 || b < 0 || c < 0 || ( a + b <= c ) || ( a + c <= b ) || ( b + c <= a ) ) System . out . println ( " Not ▁ a ▁ valid ▁ trianglen " ) ; return ; } int s = ( a + b + c ) / 2 ; double area = ( s * ( s - a ) * ( s - b ) * ( s - c ) ) ** 0.5 ; System . out . println ( ' Area ▁ of ▁ a ▁ traingle ▁ is ▁ % f ' % area ) ; }
static boolean isMajority ( int [ ] a ) { int [ ] mp = new int [ a . length ] ; for ( int i = 0 ; i < a . length ; i ++ ) { if ( mp . containsKey ( i ) ) { mp . put ( i , 1 ) ; } else { mp . put ( i , 1 ) ; } } for ( int x = 0 ; x < mp . length ; x ++ ) { if ( mp . get ( x ) >= a . length / 2 ) return true ; } return false ; }
static void recaman ( int n ) { if ( n <= 0 ) return ; HashSet < Integer > s = new HashSet < Integer > ( ) ; System . out . print ( 0 + " , " ) ; int prev = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int curr = prev - i ; if ( curr < 0 || curr >= s ) curr = prev + i ; s . add ( curr ) ; System . out . print ( curr + " , " ) ; prev = curr ; } }
static int findLength ( String str ) { int n = str . length ( ) ; int maxlen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int length = j - i + 1 ; int leftsum = 0 , rightsum = 0 ; for ( int k = 0 ; k < length / 2 ; k ++ ) { leftsum += ( str . charAt ( i + k ) - '0' ) ; rightsum += ( str . charAt ( i + k + int ( length / 2 ) ) - '0' ) ; } if ( leftsum == rightsum && maxlen < length ) { maxlen = length ; } } } return maxlen ; }
static boolean prevPermutation ( String str ) { int n = str . length ( ) - 1 ; int i = n ; while ( i > 0 && str . charAt ( i - 1 ) <= str . charAt ( i ) ) i -- ; if ( i <= 0 ) return false ; int j = i - 1 ; while ( j + 1 <= n && str . charAt ( j + 1 ) <= str . charAt ( i - 1 ) ) j ++ ; str . append ( str . charAt ( i - 1 ) ) ; return true ; }
static String findSubString ( String str , String pat ) { int len1 = str . length ( ) ; int len2 = pat . length ( ) ; if ( len1 < len2 ) System . out . println ( " No ▁ such ▁ window ▁ exists " ) ; return null ; }
static void shuffle ( int card [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int r = i + ( random . nextInt ( 0 , 55 ) % ( 52 - i ) ) ; int tmp = card [ i ] ; card [ i ] = card [ r ] ; card [ r ] = tmp ; } }
static int removeConsecutiveSame ( String v ) { Stack < Character > st = new Stack < Character > ( ) ; for ( int i = 0 ; i < v . length ( ) ; i ++ ) { if ( st . size ( ) == 0 ) { st . add ( v [ i ] ) ; } else { Character str = st . peek ( ) ; if ( str == v [ i ] ) { st . pop ( ) ; } else { str . append ( v [ i ] ) ; } } return st . size ( ) ; }
public static void find ( int [ ] list1 , int [ ] list2 ) { List < Integer > res = new ArrayList < Integer > ( ) ; int max_possible_sum = Math . max ( list1 . length , list2 . length ) - 2 ; for ( int sum = 0 ; sum <= max_possible_sum ; sum ++ ) { for ( int i = 0 ; i <= sum ; i ++ ) { if ( i < list1 . length && ( sum - i ) < list2 . length && list1 . get ( i ) == list2 . get ( sum - i ) ) res . add ( list1 [ i ] ) ; } if ( res . length > 0 ) break ; for ( int i = 0 ; i < res . length ; i ++ ) System . out . print ( res [ i ] + " ▁ " ) ; }
static int getLevenstein ( int inpt [ ] ) { int revInput [ ] = inpt [ : : - 1 ] ; int n = inpt . length ; int dp [ ] [ ] = new int [ n + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { dp [ 0 ] [ i ] = i ; dp [ i ] [ 0 ] = i ; } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( inpt [ i - 1 ] == revInput [ j - 1 ] ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ; } else { dp [ i ] [ j ] = 1 + Math . min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) ; } } } int res = Integer . MAX_VALUE ; for ( int i = n ; i >= 0 ; i -- ) { res = Math . min ( res , dp [ i ] [ j ] ) ; if ( i < n ) res = Math . min ( res , dp [ i + 1 ] [ j ] ) ; if ( i > 0 ) res = Math . min ( res , dp [ i - 1 ] [ j ] ) ; i -- ; j ++ ; } } return res ; }
static void countDistinct ( int arr [ ] , int k , int n ) { int dist_count = 0 ; HashMap < Integer , Integer > myMap = new HashMap < > ( ) ; for ( int i = 0 ; i < k ; i ++ ) { if ( myMap . containsKey ( arr [ i ] ) ) dist_count ++ ; myMap . put ( arr [ i ] , myMap . get ( arr [ i ] ) + 1 ) ; } System . out . println ( dist_count ) ; for ( int i = k ; i < n ; i ++ ) { if ( myMap . containsKey ( arr [ i - k ] ) ) dist_count -- ; mp . put ( arr [ i - k ] , myMap . get ( arr [ i - k ] ) - 1 ) ; if ( myMap . containsKey ( arr [ i ] ) ) myMap . put ( arr [ i ] , myMap . get ( arr [ i ] ) + 1 ) ; System . out . println ( dist_count ) ; } }
static int lcs ( int dp [ ] [ ] , int n , int arr2 [ ] , int m , int k ) { if ( k < 0 ) return - ( 10 ** 7 ) ; if ( n < 0 || m < 0 ) return 0 ; int ans = dp [ n ] [ m ] [ k ] ; if ( ans != - 1 ) return ans ; ans = Math . max ( lcs ( dp , arr1 , n - 1 , arr2 , m , k ) , lcs ( dp , arr1 , n , arr2 , m - 1 , k ) ) ; if ( arr1 [ n - 1 ] == arr2 [ m - 1 ] ) ans = 1 + lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k ) ; ans = Math . max ( ans , lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k - 1 ) ) ; return ans ; }
static void printDivisors ( int n ) { List < Integer > list = new ArrayList < Integer > ( ) ; for ( int i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) System . out . print ( i + " ▁ " ) ; else list . add ( n / i ) ; } } for ( int i = list . size ( ) ; i > 0 ; i -- ) System . out . print ( i + " ▁ " ) ; }
static int largestSubset ( int a [ ] , int n ) { Arrays . sort ( a ) ; int dp [ ] = new int [ n ] ; dp [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { int mxm = 0 ; for ( int j = i + 1 ; j < n ; j ++ ) if ( a [ j ] % a [ i ] == 0 ) mxm = Math . max ( mxm , dp [ j ] ) ; } dp [ i ] = 1 + mxm ; return Math . max ( dp , 1 + mxm ) ; }
static String encodedChar ( String str , int k ) { String expand = " " ; int freq = 0 ; int i = 0 ; while ( i < str . length ( ) ) { String temp = " " ; freq = 0 ; while ( i < str . length ( ) && ( str . charAt ( i ) >= ' a ' && str . charAt ( i ) <= ' z ' ) ) { temp += str . charAt ( i ) ; i ++ ; } while ( i < str . length ( ) && ( str . charAt ( i ) >= '1' && str . charAt ( i ) <= '9' ) ) { freq = freq * 10 + ( str . charAt ( i ) - '0' ) ; i ++ ; } for ( int j = 1 ; j <= freq ; j ++ ) expand += temp ; if ( freq == 0 ) expand += temp ; } return expand [ k - 1 ] ; }
static int countNum ( int arr [ ] , int n ) { Map < Integer , Integer > s = new HashMap < Integer , Integer > ( ) ; int count = 0 , maxm = - 10 ** 9 , 10 ** 9 ; for ( int i = 0 ; i < n ; i ++ ) { s . put ( arr [ i ] , 1 ) ; if ( arr [ i ] < minm ) minm = arr [ i ] ; if ( arr [ i ] > maxm ) maxm = arr [ i ] ; } for ( int i = minm ; i <= maxm ; i ++ ) { if ( ! s . containsKey ( i ) ) count ++ ; } } return count ; }
static int countPairs ( int arr [ ] , int n ) { Map < Integer , Integer > myMap = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( myMap . containsKey ( arr [ i ] ) ) myMap . put ( arr [ i ] , myMap . get ( arr [ i ] ) + 1 ) ; else myMap . put ( arr [ i ] , 1 ) ; } int ans = 0 ; for ( int it = 0 ; it < n ; it ++ ) ans += ( count * ( count - 1 ) ) / 2 ; return ans ; }
static String decimalToBinary ( int num , int k_prec ) { String binary = " " ; int Integral = num ; int fractional = num - Integral ; while ( Integral > 0 ) { int rem = Integral % 2 ; binary += String . valueOf ( rem ) ; Integral /= 2 ; } binary += ' . ' ; while ( k_prec > 0 ) { fractional *= 2 ; int fract_bit = int . valueOf ( fractional ) ; if ( fract_bit == 1 ) fractional -= fract_bit ; else binary += '0' ; } k_prec -- ; } return binary ; }
static int evaluateBoolExpr ( String s ) { int n = s . length ( ) ; for ( int i = 0 ; i < n - 2 ; i += 2 ) { if ( s . charAt ( i + 1 ) == ' A ' ) { if ( s . charAt ( i + 2 ) == "0" || s . charAt ( i ) == "0" ) s . set ( i + 2 , "0" ) ; else s . set ( i + 2 , "1" ) ; } else { s . set ( i + 2 , "0" ) ; } } return ( s . charAt ( n - 1 ) - '0' ) ; }
static int minSwaps ( int arr [ ] [ ] ) { int n = arr . length ; Arrays . sort ( arr ) ; int [ ] arrpos = new int [ n ] ; boolean vis [ ] = new boolean [ n ] ; Arrays . sort ( arr ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( vis [ i ] || arrpos [ i ] [ 0 ] == i ) continue ; int cycle_size = 0 ; for ( int j = i ; j < arrpos [ j ] [ 0 ] ; cycle_size ++ ; if ( cycle_size > 0 ) ans += ( cycle_size - 1 ) ; } return ans ; }
static int minimumBox ( int arr [ ] , int n ) { Deque < Integer > q = new LinkedList < Integer > ( ) ; Arrays . sort ( arr ) ; q . add ( arr [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { int now = q . peek ( ) ; if ( arr [ i ] >= 2 * now ) q . pop ( ) ; q . add ( arr [ i ] ) ; } return q . size ( ) ; }
static void convertOpposite ( String str ) { int ln = str . length ( ) ; for ( int i = 0 ; i < ln ; i ++ ) { if ( str . charAt ( i ) >= ' a ' && str . charAt ( i ) <= ' z ' ) str . charAt ( i ) = ( char ) ( str . charAt ( i ) - 32 ) ; else if ( str . charAt ( i ) >= ' A ' && str . charAt ( i ) <= ' Z ' ) str . charAt ( i ) = ( char ) ( str . charAt ( i ) + 32 ) ; } }
static int findRepeating ( int arr [ ] , int n ) { HashMap < Integer , Integer > hM = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( hM . get ( arr [ i ] ) != null ) return arr [ i ] ; hM . put ( arr [ i ] , i ) ; } return - 1 ; }
static void transpose ( int A [ ] [ ] ) { int i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = i + 1 ; j < N ; j ++ ) A [ i ] [ j ] = A [ j ] [ i ] ; }
static void printSubsequences ( String str ) { int n = str . length ( ) ; int opsize = ( int ) Math . pow ( 2 , n - 1 ) ; for ( int counter = 0 ; counter < opsize ; counter ++ ) { for ( int j = 0 ; j < n ; j ++ ) { System . out . print ( str . charAt ( j ) ) ; if ( counter & ( 1 << j ) ) System . out . print ( " ▁ " ) ; } System . out . println ( ) ; } }
static void printRoman ( int number ) { int [ ] num = new int [ ] { 1 , 4 , 5 , 9 , 10 , 40 , 50 , 90 , 100 , 400 , 500 , 900 , 1000 } ; String [ ] sym = new String [ ] { " I " , " IV " , " X " , " XL " , " L " , " XC " , " C " , " CD " , " M" } ; for ( int i = 12 ; number > 0 ; i -- ) { int div = number / num [ i ] ; number %= num [ i ] ; while ( div ) System . out . print ( sym [ i ] ) ; div -- ; } i -- ; }
static Boolean findTriplet ( int a1 [ ] , int a2 [ ] , int a3 [ ] , int n1 , int n2 , int n3 , int sum ) { HashSet < Integer > s = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n1 ; i ++ ) { s . add ( a1 [ i ] ) ; } for ( int i = 0 ; i < n2 ; i ++ ) { for ( int j = 0 ; j < n3 ; j ++ ) { if ( sum - a2 [ i ] - a3 [ j ] in s ) return true ; } } return false ; }
static boolean check ( String s ) { if ( s . length ( ) >= 10 ) return true ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) { for ( int j = i + 1 ; j < s . length ( ) ; j ++ ) { for ( int k = j + 1 ; k < s . length ( ) ; k ++ ) { String s1 = s . substring ( 0 , i ) ; String s2 = s . substring ( i , j - i ) ; String s3 = s . substring ( j , k - j ) ; String s4 = s . substring ( k , s . length ( ) - k ) ; if ( s1 != s2 && s1 != s3 && s1 != s4 && s2 != s3 && s2 != s4 && s3 != s4 ) return true ; } } } return false ; }
static int bitonicGenerator ( int arr [ ] , int n ) { int i = 1 , j = n - 1 ; if ( j % 2 != 0 ) j = j - 1 ; while ( i < j ) { arr [ j ] = arr [ i ] ; arr [ i ] = arr [ j ] ; j = j - 2 ; } int arr_f [ ] = new int [ n + 1 ] ; int arr_s [ ] = new int [ n + 1 ] ; Arrays . sort ( arr_f , Collections . reverseOrder ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) { arr_s . add ( arr [ i ] ) ; i ++ ; } arr_f . sort ( ) ; arr_s . sort ( reverse = true ) ; for ( int i = arr_s [ 0 ] ; i < n ; i ++ ) { arr_f . add ( arr [ i ] ) ; i ++ ; } return arr_f ; }
static void splitString ( String str ) { String alpha = " " , num = " " , special = " " ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) == ' ' ) num = num + str . charAt ( i ) ; else if ( str . charAt ( i ) >= ' A ' && str . charAt ( i ) <= ' Z ' ) || ( str . charAt ( i ) >= ' a ' && str . charAt ( i ) <= ' z ' ) ) alpha += str . charAt ( i ) ; else special += str . charAt ( i ) ; } System . out . println ( alpha + num + special ) ; }
static void binaryMedian ( int m [ ] [ ] , int r , int d ) { int mi = m [ 0 ] [ 0 ] ; int mx = 0 ; for ( int i = 0 ; i < r ; i ++ ) { if ( m [ i ] [ 0 ] < mi ) mi = m [ i ] [ 0 ] ; if ( m [ i ] [ d - 1 ] > mx ) mx = m [ i ] [ d - 1 ] ; } int desired = ( r * d + 1 ) / 2 ; while ( mi < mx ) { int mid = mi + ( mx - mi ) / 2 ; int place [ ] = new int [ r ] [ 0 ] ; for ( int i = 0 ; i < r ; i ++ ) { int j = upper_bound ( m [ i ] , mid ) ; place [ 0 ] = place [ 0 ] + j ; if ( place [ 0 ] < desired ) mi = mid + 1 ; else mx = mid ; } } System . out . println ( " Median ▁ is ▁ " + mi ) ; return ; }
static void printDuplicates ( int [ ] arr ) { int dict [ ] = new int [ arr . length ] ; for ( int ele : arr ) { if ( dict . containsKey ( ele ) ) { dict [ ele ] ++ ; } else { dict [ ele ] = 1 ; } } for ( int item : dict ) { if ( dict . containsKey ( item ) ) System . out . print ( item + " ▁ " ) ; } System . out . println ( ) ; }
public static void stoogesort ( int arr [ ] , int l , int h ) { if ( l >= h ) return ; if ( arr [ l ] > arr [ h ] ) { int t = arr [ l ] ; arr [ l ] = arr [ h ] ; arr [ h ] = t ; } if ( h - l + 1 > 2 ) { int t = ( int ) ( ( h - l + 1 ) / 3 ) ; stoogesort ( arr , l , ( h - t ) ) ; stoogesort ( arr , l + t , ( h ) ) ; stoogesort ( arr , l , ( h - t ) ) ; } }
static void printEqualModNumbers ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int d = arr [ n - 1 ] - arr [ 0 ] ; int [ ] v = new int [ n ] ; for ( int i = 1 ; i * i <= d ; i ++ ) { if ( d % i == 0 ) v . add ( i ) ; if ( i != d / i ) v . add ( d / i ) ; } for ( int i = 0 ; i < n ; i ++ ) { int temp = arr [ 0 ] % v [ i ] ; int j ; for ( j = 1 ; j < n ; j ++ ) if ( arr [ j ] % v [ i ] != temp ) break ; if ( j == n ) System . out . print ( v [ i ] + " ▁ " ) ; } }
static void recursiveReverse ( String str ) { Stack < Character > stack = new Stack < Character > ( ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) stack . push ( str . charAt ( i ) ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) str . charAt ( i ) = stack . peek ( ) ; }
static void printRect ( int X , int Y , int n ) { int Xmax = Math . max ( X ) ; int Xmin = Math . min ( X ) ; int Ymax = Math . max ( Y ) ; int Ymin = Math . min ( Y ) ; System . out . println ( " { " + Xmin + " , ▁ " + Ymin + " } " ) ; System . out . println ( " { " + Xmin + " , ▁ " + Ymax + " } " ) ; System . out . println ( " { " + Xmin + " , ▁ " + Ymin + " } " ) ; System . out . println ( " { " + Xmax + " , ▁ " + Ymax + " } " ) ; System . out . println ( " { " + Xmax + " , ▁ " + Ymin + " } " ) ; }
public static void NFG ( int [ ] a , int n ) { if ( n <= 0 ) System . out . println ( " List ▁ empty " ) ; return ; } int stack [ ] = new int [ n ] ; int freq [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { freq [ a [ i ] ] = 0 ; } for ( int i = 0 ; i < n ; i ++ ) { if ( freq [ a [ stack [ top ] ] ] > freq [ a [ i ] ] ) top ++ ; stack [ top ] = i ; else { while ( top > - 1 && freq [ a [ stack [ top ] ] < freq [ a [ i ] ] ) res [ stack [ top ] ] = a [ i ] ; top -- ; stack [ top ] = i ; } } while ( top > - 1 ) res [ stack [ top ] ] = - 1 ; top -- ; } return res ; }
static void printEqualSumSets ( int arr [ ] , int n ) { int sum_array = sum ( arr ) ; if ( sum_array & 1 ) System . out . println ( " - 1" ) ; return ; } int k = sum_array >> 1 ; int dp [ ] [ ] = new boolean [ n + 1 ] [ k + 1 ] ; for ( int i = 0 ; i <= k ; i ++ ) { dp [ i ] [ 0 ] = false ; } for ( int i = 1 ; i <= n ; i ++ ) { for ( int currSum = 1 ; currSum <= k ; currSum ++ ) { dp [ i ] [ currSum ] = dp [ i - 1 ] [ currSum ] ; if ( arr [ i - 1 ] <= currSum ) { dp [ i ] [ currSum ] = ( dp [ i ] [ currSum ] || dp [ i - 1 ] [ currSum - arr [ i - 1 ] ] ) ; } } int set1 [ ] = new ArrayList < Integer > ( ) ; set2 [ 0 ] = arr [ i ] ; } System . out . println ( " Set ▁ 1 ▁ elements : \n " ) ; for ( int i = 0 ; i > 0 && currSum >= 0 ; i -- ) { if ( dp [ i - 1 ] [ currSum ] ) i -= 1 ; set2 . add ( arr [ i ] ) ; } else { System . out . println ( " Set ▁ 2 ▁ elements : \n " ) ; for ( int i = 0 ; i < set1 . length ; i ++ ) System . out . print ( set1 [ i ] + " ▁ " ) ; } System . out . println ( ) ; }
static void reverseStr ( String str ) { int n = str . length ( ) ; for ( int i = 0 , j = n - 1 ; i < j ; i ++ , j -- ) { str . charAt ( i ) = str . charAt ( j ) ; str . charAt ( j ) = str . charAt ( i ) ; } }
static void minimizeWithKSwaps ( int arr [ ] , int n , int k ) { for ( int i = 0 ; i < n - 1 && k > 0 ; ++ i ) { int pos = i ; for ( int j = i + 1 ; j < n ; ++ j ) { if ( j - i > k ) break ; if ( arr [ j ] < arr [ pos ] ) pos = j ; } for ( int j = pos ; j > i ; -- j ) SwapInts ( arr , j , j - 1 ) ; k -= pos - i ; } }
static int countSubarrays ( int arr [ ] , int n ) { int difference = 0 ; int ans = 0 ; int [ ] hash_positive = new int [ n + 1 ] ; int [ ] hash_negative = new int [ n + 1 ] ; hash_positive [ 0 ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] & 1 == 1 ) difference ++ ; else difference -- ; if ( difference < 0 ) ans += hash_negative [ - difference ] ; else ans += hash_positive [ difference ] ; hash_positive [ difference ] = hash_positive [ difference ] + 1 ; } return ans ; }
static Boolean findPairs ( int arr [ ] , int n ) { HashMap < Integer , Integer > Hash = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i <= n - 2 ; i ++ ) { for ( int j = i + 1 ; j <= n ; j ++ ) { int sum = arr [ i ] + arr [ j ] ; if ( Hash . containsKey ( sum ) ) { int prev = Hash . get ( sum ) ; System . out . print ( str ( prev ) + " ▁ and ▁ ( % d , ▁ % d ) " ) ; return true ; } else { Hash . put ( sum , arr [ i ] + arr [ j ] ) ; } } } return false ; }
static boolean check ( String s1 , String s2 ) { int n = s1 . length ( ) ; int m = s2 . length ( ) ; boolean [ ] [ ] dp = new boolean [ n + 1 ] [ m + 1 ] ; Arrays . fill ( dp , false ) ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= s2 . length ( ) ; j ++ ) { if ( dp [ i ] [ j ] ) { if ( ( j < s2 . length ( ) && ( s1 . charAt ( i ) . toUpperCase ( ) == s2 . charAt ( j ) ) ) dp [ i + 1 ] [ j + 1 ] = true ; if ( s1 . charAt ( i ) . isupper ( ) == false ) dp [ i + 1 ] [ j ] = true ; } } } return ( dp [ n ] [ m ] ) ; }
static boolean checkDuplicatesWithinK ( int arr [ ] , int n , int k ) { HashSet < Integer > myset = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( myset . contains ( arr [ i ] ) ) return true ; myset . add ( arr [ i ] ) ; if ( i >= k ) myset . remove ( arr [ i - k ] ) ; } return false ; }
static int minOperation ( int arr [ ] , int n ) { int Hash [ ] = new int [ arr . length ] ; for ( int i = 0 ; i < n ; i ++ ) Hash [ arr [ i ] ] ++ ; int max_count = 0 ; for ( int i = 0 ; i < Hash . length ; i ++ ) { if ( max_count < Hash [ i ] ) max_count = Hash [ i ] ; } return n - max_count ; }
static int findSum ( String str ) { String temp = " " ; int sum = 0 ; for ( char ch = 0 ; ch < str . length ( ) ; ch ++ ) { if ( ch . isdigit ( ) ) temp += ch ; else sum += ( int ) temp ; } return sum + ( int ) temp ; }
static int mostFrequent ( int arr [ ] , int n ) { int Hash = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( Hash . containsKey ( arr [ i ] ) ) Hash . put ( arr [ i ] , Hash . get ( arr [ i ] ) + 1 ) ; else Hash . put ( arr [ i ] , 1 ) ; } int max_count = 0 ; int res = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( max_count < Hash . get ( i ) ) res = i ; max_count = Hash . get ( i ) ; } return res ; }
static String firstLetterWord ( String str ) { String result = " " ; boolean v = true ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) == ' ▁ ' ) v = true ; else if ( str . charAt ( i ) != ' ▁ ' && v == true ) result += ( str . charAt ( i ) ) ; } return result ; }
static void decode ( String str ) { Vector < Integer > integerstack = new Vector < > ( ) ; Vector < Integer > stringstack = new Vector < > ( ) ; String temp = " " ; String result = " " ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { int count = 0 ; if ( str . charAt ( i ) >= '0' && str . charAt ( i ) <= '9' ) { while ( str . charAt ( i ) >= '0' && str . charAt ( i ) <= '9' ) { count = count * 10 + ( char ) ( str . charAt ( i ) - '0' ) ; i ++ ; } i -- ; integerstack . add ( count ) ; } else if ( str . charAt ( i ) == ' [ ' ) { temp = " " ; count = integerstack . peek ( ) ; if ( stringstack . size ( ) != 0 && stringstack . peek ( ) != ' [ ' ) { temp = stringstack . peek ( ) + temp ; stringstack . pop ( ) ; } for ( int j = 0 ; j < count ; j ++ ) { result = result + temp ; } result = " " ; } else if ( str . charAt ( i ) == ' [ ' ) { if ( str . charAt ( i - 1 ) >= '0' && str . charAt ( i - 1 ) <= '9' ) { stringstack . add ( str . charAt ( i ) ) ; integerstack . add ( 1 ) ; } else { stringstack . add ( str . charAt ( i ) ) ; } } while ( strstack . size ( ) != 0 ) { result = stringstack . peek ( ) ; } }
static int minSum ( int A [ ] ) { int min_val = Math . min ( A ) ; return min_val * ( A . length - 1 ) ; }
static int countWords ( String str , int n ) { Map < Character , Integer > m = new HashMap < Character , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) m . put ( str , i ) ; int res = 0 ; for ( int i = 0 ; i < m . size ( ) ; i ++ ) { if ( m . containsKey ( stri [ i ] ) ) res ++ ; } return res ; }
static void sortUsingHash ( int [ ] a , int n ) { int Max = Arrays . stream ( a ) . max ( ) . getAsInt ( ) ; int [ ] Hash = new int [ Max + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) Hash [ a [ i ] ] ++ ; for ( int i = 0 ; i <= Max ; i ++ ) { if ( Hash [ i ] != 0 ) { for ( int j = 0 ; j < Hash [ i ] ; j ++ ) System . out . print ( i + " ▁ " ) ; } } }
static boolean isDivisible ( String str , int k ) { int n = str . length ( ) ; int c = 0 ; for ( int i = 0 ; i < k ; i ++ ) if ( str . charAt ( n - i - 1 ) == '0' ) c ++ ; return ( c == k ) ; }
static int divisible ( String num ) { int n = num . length ( ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += num . charAt ( i ) ; if ( sum % 3 == 0 ) return 0 ; if ( n == 1 ) return - 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( sum % 3 == int ( num . charAt ( i ) ) % 3 ) return 1 ; if ( n == 2 ) return - 1 ; return 2 ; }
static void reverse ( String str ) { if ( str . length ( ) == 0 ) return ; String temp = str . charAt ( 0 ) ; reverse ( str . substring ( 1 ) ) ; System . out . print ( temp ) ; }
static boolean isDvisibleBy12 ( String num ) { if ( num . length ( ) >= 3 ) { int d1 = num . charAt ( num . length ( ) - 1 ) ; if ( d1 % 2 != 0 ) return false ; int d2 = num . charAt ( num . length ( ) - 2 ) ; int sum = 0 ; for ( int i = 0 ; i < num . length ( ) ; i ++ ) sum += num . charAt ( i ) ; return ( sum % 3 == 0 && ( d2 * 10 + d1 ) % 4 == 0 ) ; } else { int number = num . charAt ( 0 ) ; return ( number % 12 == 0 ) ; } }
static int xorZero ( String str ) { int one_count = 0 , zero_count = 0 ; int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( str . charAt ( i ) == '1' ) one_count ++ ; else zero_count ++ ; } if ( one_count % 2 == 0 ) return zero_count ; return one_count ; }
static double nthRoot ( double A , int N ) { int xPre = random . randint ( 1 , 101 ) % 10 ; double eps = 0.001 ; double delX = 2147483647 ; double xK = 0.0 ; while ( delX > eps ) { xK = ( N - 1.0 ) * xPre + A / pow ( xPre , N - 1 ) ) / N ; delX = Math . abs ( xK - xPre ) ; xPre = xK ; } return xK ; }
static String findLeft ( String str ) { int n = str . length ( ) - 1 ; while ( n > 0 ) { if ( str . charAt ( n ) == ' d ' ) str = str . charAt ( 0 : n ) + ' c ' + str . charAt ( n + 1 ) ; break ; if ( str . charAt ( n ) == ' b ' ) str = str . charAt ( 0 : n ) + ' a ' + str . charAt ( n + 1 ) ; break ; if ( str . charAt ( n ) == ' a ' ) str = str . charAt ( 0 : n ) + ' b ' + str . charAt ( n + 1 ) ; else if ( str . charAt ( n ) == ' c ' ) str = str . charAt ( 0 : n ) + ' d ' + str . charAt ( n + 1 ) ; } n -- ; } return str ; }
static void minRange ( int arr [ ] , int n , int k ) { int l = 0 , r = n ; for ( int i = 0 ; i < n ; i ++ ) { int [ ] s = new int [ k ] ; for ( int j = i ; j < n ; j ++ ) { s . add ( arr [ j ] ) ; if ( s . length == k ) { if ( ( j - i ) < ( r - l ) ) { r = j ; l = i ; } break ; } } if ( j == n ) break ; if ( l == 0 && r == n ) System . out . println ( " Invalid ▁ k " ) ; else System . out . println ( l + " ▁ r " ) ; }
static int findSum ( int A [ ] , int B [ ] , int n ) { int Hash [ ] = new int [ 2 * n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) Hash [ A [ i ] ] ++ ; Hash [ B [ i ] ] ++ ; int sum = 0 ; for ( int x = 0 ; x < Hash . length ; x ++ ) if ( Hash [ x ] == 1 ) sum += x ; return sum ; }
static void arrayEvenAndOdd ( int arr [ ] , int n ) { int i = - 1 , j = 0 ; while ( j != n ) { if ( arr [ j ] % 2 == 0 ) { i ++ ; arr [ i ] = arr [ j ] ; arr [ j ] = arr [ i ] ; } } for ( int i = 0 ; i < arr . length ; i ++ ) System . out . print ( str ( i ) + " ▁ " ) ; }
static boolean containsOdd ( int G [ ] [ ] , int src ) { int colorArr [ ] = new int [ V ] ; int q [ ] = new LinkedList < Integer > ( ) ; q . add ( src ) ; while ( ! q . isEmpty ( ) ) { int u = q . peek ( ) ; if ( G [ u ] [ u ] == 1 ) return true ; for ( int v = 0 ; v < V ; v ++ ) { if ( G [ u ] [ v ] && colorArr [ v ] == - 1 ) colorArr [ v ] = 1 - colorArr [ u ] ; q . add ( v ) ; } else if ( G [ u ] [ v ] && colorArr [ v ] == colorArr [ u ] ) return true ; } return false ; }
static int getMinSquares ( int n ) { if ( n <= 3 ) return n ; int res = n ; for ( int x = 1 ; x <= n ; x ++ ) { int temp = x * x ; if ( temp > n ) break ; else res = Math . min ( res , 1 + getMinSquares ( n - temp ) ) ; } return res ; }
static int selectRandom ( int x ) { int res = 0 ; int count = 0 ; while ( count < 1 ) { count ++ ; if ( count == 1 ) res = x ; else { int i = random . nextInt ( count ) ; if ( i == count - 1 ) res = x ; } } return res ; }
static int cost ( int a [ ] , int n ) { return ( ( n - 1 ) * min ( a ) ) ; }
public static int gnomeSort ( int arr [ ] , int n ) { int index = 0 ; while ( index < n ) { if ( index == 0 ) index ++ ; if ( arr [ index ] >= arr [ index - 1 ] ) index ++ ; else { arr [ index ] = arr [ index - 1 ] ; arr [ index - 1 ] = arr [ index ] ; index = index - 1 ; } } return arr ; }
static boolean sortedAfterSwap ( int A [ ] , int B [ ] , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( B [ i ] != i + 1 ) { A [ i ] = A [ i + 1 ] ; A [ i + 1 ] = A [ i ] ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( A [ i ] != i + 1 ) { return false ; } } return true ; }
static String moveSpaceInFront ( String s ) { int i = s . length ( ) - 1 ; for ( int j = i ; j >= 0 ; j -- ) if ( s . charAt ( j ) != ' ▁ ' ) s = s . substring ( i , j + 1 ) ; while ( i >= 0 ) s = s . substring ( : i ) + ' ▁ ' + s . charAt ( i + 1 ) ; i -- ; } return s ; }
static int countOfBinaryNumberLessThanN ( int N ) { LinkedList < Integer > q = new LinkedList < Integer > ( ) ; q . add ( 1 ) ; int cnt = 0 ; while ( q . size ( ) > 0 ) { int t = q . peek ( ) ; if ( t <= N ) { cnt ++ ; q . add ( t * 10 ) ; q . add ( t * 10 + 1 ) ; } } return cnt ; }
static void substringConversions ( String str , int k , int b ) { for ( int i = 0 ; i < str . length ( ) - k + 1 ; i ++ ) { String sub = str . substring ( i , k + i ) ; int sum = 0 ; int counter = 0 ; for ( int i = 0 ; i < sub . length ( ) - 1 ; i >= 0 ; i -- ) { sum = sum + ( ( sub . charAt ( i ) - '0' ) * pow ( b , counter ) ) ; counter ++ ; } System . out . print ( sum + " ▁ " ) ; } }
static String longestRepeatedSubSeq ( String str ) { int n = str . length ( ) ; int dp [ ] [ ] = new int [ n + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( str . charAt ( i - 1 ) == str . charAt ( j - 1 ) && i != j ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = Math . max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ; } } String res = " " ; int i = n , j = n ; while ( i > 0 && j > 0 ) { if ( dp [ i ] [ j ] == dp [ i - 1 ] [ j - 1 ] + 1 ) res += str . charAt ( i - 1 ) ; i -- ; j -- ; } else if ( dp [ i ] [ j ] == dp [ i - 1 ] [ j ] ) i -- ; else j -- ; } res = " " ; return res ; }
static void rearrange ( int [ ] a , int size ) { int positive = 0 , negative = 1 ; while ( true ) { while ( positive < size && a [ positive ] >= 0 ) ++ positive ; while ( negative < size && a [ negative ] <= 0 ) ++ negative ; if ( positive < size && negative < size ) { int temp = a [ positive ] ; a [ positive ] = a [ negative ] ; a [ negative ] = temp ; } else break ; } }
public static void bubbleSort ( int arr [ ] , int n ) { int copy [ ] = Arrays . copyOf ( arr , arr . length ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n - i - 1 ; j ++ ) { if ( arr [ j ] > arr [ j + 1 ] ) { copy [ j ] , arr [ j + 1 ] = copy [ j ] ; } } } }
static String reversingString ( String str , int start , int end ) { while ( start < end ) { str = ( str [ : start ] + ( char ) ( str [ start ] ) ^ ( char ) str [ end ] ) + str [ start + 1 : ] ) ; str = ( str [ : end ] + ( char ) ( str [ start ] ) ^ ( char ) str [ end ] ) + str [ end + 1 : ] ) ; str = ( str [ : start ] + ( char ) ( str [ start ] ) ^ ord ( str [ end ] ) ) + str [ start + 1 : ] ) ; start ++ ; end -- ; } return str ; }
static int minimalSteps ( String s , int n ) { int [ ] dp = new int [ n ] ; String s1 = " " , s2 = " " ; dp [ 0 ] = 1 ; s1 += s [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { s1 += s [ i ] ; s2 = s [ i + 1 : i + 1 + i + 1 ] ; dp [ i ] = Math . min ( dp [ i ] , dp [ i - 1 ] + 1 ) ; if ( s1 == s2 ) { dp [ i * 2 + 1 ] = Math . min ( dp [ i ] + 1 , dp [ i * 2 + 1 ] ) ; } } return dp [ n - 1 ] ; }
static int MinimumCost ( int cost [ ] , int n , int W ) { List < Integer > val = new ArrayList < Integer > ( ) ; List < Integer > wt = new ArrayList < Integer > ( ) ; int size = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( cost [ i ] != - 1 ) { val . add ( cost [ i ] ) ; wt . add ( i + 1 ) ; size ++ ; } } int min_cost [ ] [ ] = new int [ W + 1 ] [ n + 1 ] ; for ( int i = 0 ; i < W + 1 ; i ++ ) { min_cost [ 0 ] [ i ] = INF ; } for ( int i = 1 ; i < n + 1 ; i ++ ) { min_cost [ i ] [ 0 ] = 0 ; } for ( int i = 1 ; i < n + 1 ; i ++ ) { for ( int j = 1 ; j < W + 1 ; j ++ ) { if ( wt [ i - 1 ] > j ) min_cost [ i ] [ j ] = Math . min ( min_cost [ i - 1 ] [ j ] , min_cost [ i ] [ j - wt [ i - 1 ] ] + val [ i - 1 ] ) ; } } if ( min_cost [ n ] [ W ] == INF ) return - 1 ; else return min_cost [ n ] [ W ] ; }
static void bitonicGenerator ( int arr [ ] , int n ) { int [ ] evenArr = new int [ n ] ; int [ ] oddArr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( i % 2 ) == 0 ) ++ evenArr . add ( arr [ i ] ) ; else ++ oddArr . add ( arr [ i ] ) ; } Arrays . sort ( evenArr ) ; Arrays . sort ( oddArr ) ; int i = 0 ; for ( int j = 0 ; j < evenArr . length ; j ++ ) arr [ i ] = evenArr [ j ] ; i ++ ; for ( int j = 0 ; j < oddArr . length ; j ++ ) arr [ i ] = oddArr [ j ] ; i ++ ; } for ( int j = 0 ; j < evenArr . length ; j ++ ) arr [ i ] = evenArr [ j ] ; i ++ ; }
static void printFirstRepeating ( int arr [ ] , int n ) { int Min = - 1 ; Map < Integer , Integer > myset = new HashMap < Integer , Integer > ( ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( myset . containsKey ( arr [ i ] ) ) { Min = i ; } else { myset . put ( arr [ i ] , 1 ) ; } } if ( Min != - 1 ) System . out . println ( " The ▁ first ▁ repeating ▁ element ▁ is ▁ " + arr [ Min ] ) ; else System . out . println ( " There ▁ are ▁ no ▁ repeating ▁ elements " ) ; }
static int lps ( String str ) { int n = str . length ( ) ; int [ ] [ ] L = new int [ n ] [ n ] ; int i , j , k , L [ ] [ ] = new int [ n ] [ n ] ; for ( i = 0 ; i < n ; i ++ ) L [ i ] [ i ] = 1 ; for ( cl = 2 ; cl <= n ; cl ++ ) { for ( i = 0 ; i < n - cl + 1 ; i ++ ) { j = i + cl - 1 ; if ( str . charAt ( i ) == str . charAt ( j ) && cl == 2 ) L [ i ] [ j ] = 2 ; else if ( str . charAt ( i ) == str . charAt ( j ) ) L [ i ] [ j ] = L [ i + 1 ] [ j - 1 ] + 2 ; else L [ i ] [ j ] = Math . max ( L [ i ] [ j - 1 ] , L [ i + 1 ] [ j ] ) ; } } return L [ 0 ] [ n - 1 ] ; }
static String censor ( String text , String word ) { List < Character > word_list = text . split ( ) ; String stars = " * " ; int count = 0 ; int index = 0 ; for ( Character i = 0 ; i < word_list . size ( ) ; i ++ ) { if ( i == word ) word_list [ index ] = stars ; count ++ ; } result = ' ▁ ' . join ( word_list ) ; return result ; }
static boolean isRotated ( String str1 , String str2 ) { if ( str1 . length ( ) != str2 . length ( ) ) return false ; String clock_rot = " " , anticlock_rot = " " ; int l = str2 . length ( ) ; anticlock_rot = ( anticlock_rot + str2 . charAt ( l - 2 ) + str2 . charAt ( 0 : l - 2 ) ) ; clock_rot = clock_rot + str2 . charAt ( 2 : ] + str2 . charAt ( 0 : 2 ) ) ; return ( str1 == clock_rot || str1 == anticlock_rot ) ; }
static int findDiff ( int arr [ ] , int n ) { Map < Integer , Integer > myMap = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) myMap . put ( arr [ i ] , myMap . get ( arr [ i ] ) + 1 ) ; int max_count = 0 , min_count = n ; for ( int key = 0 ; key < myMap . keySet ( ) ; key ++ ) { max_count = Math . max ( max_count , values ) ; min_count = Math . min ( min_count , values ) ; } return max_count - min_count ; }
static int playGame ( int arr [ ] , int n ) { HashSet < Integer > s = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { s . add ( arr [ i ] ) ; } return 1 if ( s . size ( ) % 2 == 0 ) return 2 ; }
static int subset ( int arr [ ] , int n ) { Map < Integer , Integer > myMap = new HashMap < > ( ) ; for ( int i = 0 ; i < 10 ; i ++ ) myMap . put ( arr [ i ] , myMap . get ( arr [ i ] ) + 1 ) ; int res = 0 ; for ( int key = 0 ; key < myMap . size ( ) ; key ++ ) res = Math . max ( res , value ) ; return res ; }
boolean isProduct ( int arr [ ] , int n , int x ) { if ( n < 2 ) return false ; HashSet < Integer > s = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) { if ( x == 0 ) return true ; else continue ; } if ( x % arr [ i ] == 0 ) { if ( x / arr [ i ] == 0 ) { if ( s . contains ( arr [ i ] ) ) return true ; s . add ( arr [ i ] ) ; } } return false ; }
static int findRotations ( String str ) { String tmp = " " ; int n = str . length ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { String substring = tmp . substring ( i , n ) ; if ( str == substring ) return i ; } return n ; }
static int randomize ( int arr [ ] , int n ) { for ( int i = n - 1 ; i >= 0 ; i -- ) { int j = random . nextInt ( 0 , i + 1 ) ; arr [ i ] = arr [ j ] ; arr [ j ] = arr [ i ] ; } return arr ; }
static void translate ( char str [ ] ) { int l = str . length ; if ( l < 2 ) return ; int i = 0 , j = 0 ; while ( j < l - 1 ) { if ( str [ j ] == ' A ' && str [ j + 1 ] == ' B ' ) { j ++ ; continue ; } str [ i ] = str [ j ] ; i ++ ; j ++ ; } if ( j == l - 1 ) { str [ i ] = str [ j ] ; i ++ ; } str [ i ] = ' ▁ ' ; str [ l - 1 ] = ' ▁ ' ; } else { str [ i ] = ' ▁ ' ; str [ l - 1 ] = ' ▁ ' ; } }
static int numberofways ( int A [ ] , int B [ ] , int N , int M ) { int [ ] [ ] pos = new int [ MAX ] [ M ] ; for ( int i = 0 ; i < M ; i ++ ) { pos [ B [ i ] ] . add ( i + 1 ) ; } int dpl [ ] [ ] = new int [ N + 2 ] ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 1 ; j <= M ; j ++ ) { if ( A [ i - 1 ] == B [ j - 1 ] ) dpl [ i ] [ j ] = dpl [ i - 1 ] [ j - 1 ] + 1 ; else dpl [ i ] [ j ] = Math . max ( dpl [ i - 1 ] [ j ] , dpl [ i ] [ j - 1 ] ) ; } } int LCS = dpl [ N ] [ M ] ; int dpr [ ] [ ] = new int [ N + 1 ] [ M ] ; for ( int i = 0 ; i <= N ; i ++ ) { for ( int j = M ; j >= 0 ; j -- ) { if ( A [ i - 1 ] == B [ j - 1 ] ) dpr [ i ] [ j ] = dpr [ i + 1 ] [ j + 1 ] + 1 ; else dpr [ i ] [ j ] = Math . max ( dpr [ i + 1 ] [ j ] , dpr [ i ] [ j + 1 ] ) ; } } int ans = 0 ; for ( int i = 0 ; i <= N ; i ++ ) { for ( int j = 0 ; j <= MAX ; j ++ ) { if ( dpl [ i ] [ x - 1 ] + dpr [ i + 1 ] [ x + 1 ] == LCS ) ans ++ ; break ; } } return ans ; }
static void substringConversions ( String s , int k , int b ) { int l = s . length ( ) ; for ( int i = 0 ; i < l ; i ++ ) { if ( ( i + k ) < l + 1 ) { String sub = s . substring ( i , i + k ) ; int sum = 0 ; int counter = 0 ; for ( int i = 0 ; i < sub . length ( ) - 1 ; i >= 0 ; i -- ) { sum += ( ( sub . charAt ( i ) - '0' ) * pow ( b , counter ) ) ; counter ++ ; } System . out . print ( sum + " ▁ " ) ; } }
static int sumOfKsubArray ( int arr [ ] , int n , int k ) { int sum = 0 ; Stack < Integer > S = new Stack < > ( ) ; Stack < Integer > G = new Stack < > ( ) ; for ( int i = 0 ; i < k ; i ++ ) { while ( S . size ( ) > 0 && arr [ S . peek ( ) ] >= arr [ i ] ) S . pop ( ) ; while ( G . size ( ) > 0 && arr [ G . peek ( ) <= arr [ i ] ) G . pop ( ) ; S . push ( i ) ; } for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ S [ 0 ] ] + arr [ G [ 0 ] ] ; while ( S . size ( ) > 0 && S . peek ( ) <= i - k ) { S . pop ( ) ; } while ( G . size ( ) > 0 && G . peek ( ) <= arr [ i ] ) { G . pop ( ) ; } S . push ( i ) ; } sum += arr [ S [ 0 ] ] + arr [ G [ 0 ] ] ; return sum ; }
static String arrangeString ( String str ) { int [ ] char_count = new int [ MAX_CHAR ] ; int s = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) >= ' A ' && str . charAt ( i ) <= ' Z ' ) char_count [ str . charAt ( i ) - ' A ' ] ++ ; else s += str . charAt ( i ) - '0' ; } String res = " " ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { char ch = ( char ) ( " A " + i ) ; while ( char_count [ i ] ) res += ch ; char_count [ i ] -- ; } if ( s > 0 ) res += String . valueOf ( s ) ; return res ; }
static void waysToIncreaseLCSBy1 ( String str1 , String str2 ) { int m = str1 . length ( ) ; int n = str2 . length ( ) ; int [ ] [ ] position = new int [ M ] [ n + 1 ] ; for ( int i = 0 ; i < M ; i ++ ) { position [ i ] [ 0 ] = i ; } for ( int i = 1 ; i < n + 1 ; i ++ ) { for ( int j = 1 ; j < m + 2 ; j ++ ) { if ( str1 . charAt ( i - 1 ) == str2 . charAt ( j - 1 ) ) lcsl [ i ] [ j ] = 1 + lcsl [ i - 1 ] [ j - 1 ] ; else lcsl [ i ] [ j ] = Math . max ( lcsl [ i - 1 ] [ j ] , lcsl [ i ] [ j - 1 ] ) ; } } for ( int i = 1 ; i < m + 1 ; i ++ ) { for ( int j = 1 ; j < n + 1 ; j ++ ) { if ( str1 . charAt ( i - 1 ) == str2 . charAt ( j - 1 ) ) lcsr [ i ] [ j ] = 1 + lcsr [ i + 1 ] [ j + 1 ] ; else lcsr [ i ] [ j ] = Math . max ( lcsr [ i + 1 ] [ j ] , lcsr [ i ] [ j + 1 ] ) ; } } int ways = 0 ; i < m + 1 ; i ++ ) { for ( int C = 0 ; C <= 25 ; C ++ ) { for ( int j = 0 ; j < 8 ; j ++ ) { int p = position [ C ] [ j ] ; if ( lcsl [ i ] [ p - 1 ] == 0 ) p = lcsl [ i ] [ p - 1 ] ; if ( lcsr [ i ] [ j ] > lcsr [ i ] [ p ] ) { ways ++ ; } } } }
static int lis ( int arr [ ] ) { int n = arr . length ; int lis [ ] = new int [ n ] ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; } } int maximum = 0 ; for ( int i = 0 ; i < n ; i ++ ) maximum = Math . max ( maximum , lis [ i ] ) ; return maximum ; }
static void SternSequenceFunc ( int [ ] BrocotSequence , int n ) { for ( int i = 1 ; i < n ; i ++ ) { int considered_element = BrocotSequence [ i ] ; int precedent = BrocotSequence [ i - 1 ] ; BrocotSequence . add ( considered_element + precedent ) ; BrocotSequence . add ( considered_element ) ; } for ( int i = 0 ; i < 15 ; i ++ ) System . out . print ( BrocotSequence [ i ] + " ▁ " ) ; }
static void printBracketNumber ( String exp , int n ) { int left_bnum = 1 ; List < Integer > right_bnum = new ArrayList < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( exp . charAt ( i ) == ' ( ' ) { System . out . print ( left_bnum + " ▁ " ) ; right_bnum . add ( left_bnum ) ; left_bnum ++ ; } else if ( exp . charAt ( i ) == ' ( ' ) { System . out . print ( right_bnum . peek ( ) + " ▁ " ) ; right_bnum . pop ( ) ; } } }
static int returnMaxSum ( int A [ ] , int B [ ] , int n ) { int result = 0 ; int curr_sum = 0 ; int curr_begin = 0 ; HashSet < Integer > mp = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { while ( A [ i ] in mp ) { mp . remove ( A [ curr_begin ] ) ; curr_sum -= B [ curr_begin ] ; curr_begin ++ ; } mp . add ( A [ i ] ) ; curr_sum += B [ i ] ; result = Math . max ( result , curr_sum ) ; } return result ; }
static void rearrange ( int arr [ ] , int n ) { int i = - 1 ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] < 0 ) i ++ ; arr [ i ] = arr [ j ] , arr [ j ] ; } int pos = i + 1 , neg = 0 ; while ( pos < n && neg < pos && arr [ neg ] < 0 ) { arr [ neg ] , arr [ pos ] = arr [ pos ] , arr [ neg ] = arr [ neg ] ; pos ++ ; neg ++ ; } }
static int largestGCDSubsequence ( int arr [ ] , int n ) { int ans = 0 ; int maxele = Math . max ( arr , n ) ; for ( int i = 2 ; i <= maxele ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) if ( arr [ j ] % i == 0 ) count ++ ; ans = Math . max ( ans , count ) ; } return ans ; }
static boolean isNumber ( String s ) { for ( int i = 0 ; i < s . length ( ) ; i ++ ) if ( s . charAt ( i ) . isdigit ( ) != true ) return false ; return true ; }
static int countPairs ( int arr1 [ ] , int arr2 [ ] , int m , int n , int x ) { int count = 0 ; HashSet < Integer > us = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < m ; ++ i ) { us . add ( arr1 [ i ] ) ; } for ( int j = 0 ; j < n ; ++ j ) { if ( x - arr2 [ j ] in us ) count ++ ; } return count ; }
static int lis ( int arr [ ] ) { int n = arr . length ; int lis [ ] = new int [ n ] ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; } } int maximum = 0 ; for ( int i = 0 ; i < n ; i ++ ) maximum = Math . max ( maximum , lis [ i ] ) ; return maximum ; }
static String findSubString ( String str ) { int n = str . length ( ) ; int dist_count = str . length ( ) ; int count = 0 , start = 0 , start_index = - 1 , min_len = Integer . MAX_VALUE ; HashMap < Character , Integer > curr_count = new HashMap < Character , Integer > ( ) ; for ( int j = 0 ; j < n ; j ++ ) { curr_count . put ( str . charAt ( j ) , count ) ; if ( curr_count . containsKey ( str . charAt ( j ) ) ) { count ++ ; if ( curr_count . get ( str . charAt ( j ) ) > 1 ) { curr_count . put ( str . charAt ( start ) , curr_count . get ( str . charAt ( start ) ) - 1 ) ; } start ++ ; } int len_window = j - start + 1 ; if ( min_len > len_window ) min_len = len_window ; start_index = start ; } } return str . substring ( start_index , start_index + min_len ) ; }
static void printSubsequences ( char arr [ ] , int n ) { long opsize = ( long ) Math . pow ( 2 , n ) ; for ( int counter = 1 ; counter <= ( int ) ( opsize ) ; counter ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( counter & ( 1 << j ) ) System . out . print ( arr [ j ] + " ▁ " ) ; } System . out . println ( ) ; } }
static void bin ( int n ) { if ( n > 1 ) bin ( n >> 1 ) ; System . out . print ( n & 1 ) ; }
static int minimumSquare ( int a , int b ) { int result = 0 ; int rem = 0 ; if ( a < b ) { a , b = b , a ; } while ( b > 0 ) { result += ( int ) ( a / b ) ; rem = ( int ) ( a % b ) ; a = b ; b = rem ; } return result ; }
static void deleteElements ( int arr [ ] , int n , int k ) { Vector < Integer > st = new Vector < > ( ) ; st . add ( arr [ 0 ] ) ; int top = 0 , count = 0 ; for ( int i = 1 ; i < n ; i ++ ) { while ( ! st . isEmpty ( ) && count < k && st . peek ( ) < arr [ i ] ) { count ++ ; top -- ; } st . add ( arr [ i ] ) ; top ++ ; } for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( st . peek ( ) + " ▁ " ) ; } }
static String first ( String str ) { for ( int i = 0 ; i < str . length ( ) ; i ++ ) if ( str . charAt ( i ) . istitle ( ) ) return str . charAt ( i ) ; return 0 ; }
static boolean isPossible ( int n , int index , int modulo , int M , int arr [ ] , int dp [ ] [ ] ) { if ( index == n ) return true ; if ( modulo == 0 ) return 1 ; return 0 ; } if ( dp [ index ] [ modulo ] != - 1 ) return dp [ index ] [ modulo ] ; boolean placeAdd = isPossible ( n , index + 1 , modulo + arr [ index ] , M , arr , dp ) ; boolean placeMinus = isPossible ( n , index + 1 , modulo - arr [ index ] , M , arr , dp ) ; boolean res = ( placeAdd || placeMinus ) ; dp [ index ] [ modulo ] = res ; return res ; }
static void amendSentence ( String str ) { ArrayList < Character > array = new ArrayList < Character > ( ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) >= ' A ' && str . charAt ( i ) <= ' Z ' ) { array . add ( str . charAt ( i ) ) ; i ++ ; } else { System . out . print ( str . charAt ( i ) ) ; } } }
static int find ( int a [ ] , int b [ ] , int k , int n1 , int n2 ) { int set [ ] = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n2 ; i ++ ) set [ b [ i ] ] = true ; int missing = 0 ; for ( int i = 0 ; i < n1 ; i ++ ) { if ( ! set [ a [ i ] ] ) { missing ++ ; } if ( missing == k ) { return a [ i ] ; } } return - 1 ; }
static int countNumber ( int n ) { int result = 0 ; for ( int i = 1 ; i <= 9 ; i ++ ) { Vector < Integer > s = new Vector < > ( ) ; if ( i <= n ) s . add ( i ) ; result ++ ; } while ( ! s . isEmpty ( ) ) { int tp = s . peek ( ) ; s . pop ( ) ; for ( int j = 0 ; j < 10 ; j ++ ) { int x = tp * 10 + j ; if ( x <= n ) s . add ( x ) ; result ++ ; } } return result ; }
static char getMaxOccuringChar ( String str ) { int [ ] count = new int [ ASCII_SIZE ] ; int max = Integer . MIN_VALUE ; char c = ' ' ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { count [ ( int ) str . charAt ( i ) ] ++ ; } for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( max < count [ ( int ) i ] ) { max = count [ ( int ) i ] ; c = i ; } } return c ; }
static int getMinDiff ( int arr [ ] , int n , int k ) { if ( n == 1 ) return 0 ; Arrays . sort ( arr ) ; int ans = arr [ n - 1 ] - arr [ 0 ] ; int small = arr [ 0 ] + k ; int big = arr [ n - 1 ] - k ; if ( small > big ) { small , big = big , small ; } for ( int i = 1 ; i < n ; i ++ ) { int subtract = arr [ i ] - k ; int add = arr [ i ] + k ; if ( subtract >= small || add <= big ) continue ; if ( big - subtract <= add - small ) small = subtract ; else big = add ; } return Math . min ( ans , big - small ) ; }
static void printkthnode ( int adj [ ] [ ] , int wt , int n , int k ) { for ( int i = 0 ; i < n ; i ++ ) Arrays . sort ( adj [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( adj [ i ] . length >= k ) System . out . print ( adj [ i ] [ adj [ i ] . length - k ] [ 1 ] + " ▁ " ) ; else System . out . print ( - 1 + " ▁ " ) ; } }
static void commonCharacters ( String str [ ] , int n ) { boolean [ ] prim = new boolean [ MAX_CHAR ] ; boolean [ ] sec = new boolean [ MAX_CHAR ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < str . length ( ) ; j ++ ) { if ( prim [ str . charAt ( i ) . charAt ( j ) - ' a ' ] == false ) sec [ str . charAt ( i ) . charAt ( j ) - ' a ' ] = true ; } for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { if ( prim [ i ] ) { System . out . print ( " % c ▁ " + ( i + ' a ' ) ) ; } } } for ( int i = 0 ; i < 26 ; i ++ ) { if ( prim [ i ] ) { System . out . print ( " % c ▁ " + ( i + ' a ' ) ; } } }
static boolean canMakeStr2 ( char s1 [ ] , char s2 [ ] ) { int [ ] count = new int [ s1 . length ] ; for ( int i = 0 ; i < s1 . length ; i ++ ) { count [ s1 [ i ] ] ++ ; } for ( int i = 0 ; i < s2 . length ; i ++ ) { if ( count [ s2 [ i ] ] == 0 ) return false ; count [ s2 [ i ] ] -- ; } return true ; }
static int count ( int [ ] a , int [ ] b , int m , int n ) { if ( ( m == 0 && n == 0 ) || n == 0 ) return 1 ; if ( m == 0 ) return 0 ; if ( b [ m - 1 ] == b [ n - 1 ] ) return count ( a , b , m - 1 , n - 1 ) + count ( a , b , m - 1 , n ) ; else return count ( a , b , m - 1 , n ) ; }
static int numofArray ( int n , int m ) { int [ ] [ ] dp = new int [ MAX ] [ MAX ] ; int [ ] [ ] mu = new int [ MAX ] [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) { for ( int j = 0 ; j < MAX ; j ++ ) { dp [ i ] [ j ] = 0 ; mu [ i ] [ j ] = 0 ; } } for ( int i = 1 ; i < m + 1 ; i ++ ) { for ( int j = 2 * i ; j <= m + 1 ; j ++ ) { di [ j ] . add ( i ) ; mu [ i ] . add ( j ) ; } di [ i ] . add ( i ) ; } for ( int i = 1 ; i < n + 1 ; i ++ ) { for ( int j = 1 ; j <= m + 1 ; j ++ ) { dp [ i ] [ j ] = 0 ; for ( int x = di [ j ] ; x <= mu [ j ] ; x ++ ) { dp [ i ] [ j ] += dp [ i - 1 ] [ x ] ; } } } int ans = 0 ; for ( int i = 1 ; i < m + 1 ; i ++ ) ans += dp [ n ] [ i ] ; di [ i ] . clear ( ) ; mu [ i ] . clear ( ) ; } return ans ; }
static int findSubarraySum ( int arr [ ] , int n ) { int res = 0 ; Map < Integer , Integer > m = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int sum = 0 ; for ( int j = i ; j < n ; j ++ ) sum += arr [ j ] ; m . put ( sum , m . get ( sum ) + 1 ) ; } for ( int x = 0 ; x < n ; x ++ ) if ( m . containsKey ( x ) ) res += x ; return res ; }
static void findpath ( int graph [ ] [ ] ) { int n = graph . length ; int numofadj [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) numofadj . add ( graph [ i ] [ 0 ] ) ; int startpoint = 0 , numofodd = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( numofadj [ i ] % 2 == 1 ) { numofodd ++ ; startpoint = i ; } } Stack < Integer > stack = new Stack < > ( ) ; Stack < Integer > path = new Stack < > ( ) ; int cur = startpoint ; while ( stack != null || sum ( graph [ cur ] ) == 0 ) { path . add ( cur + 1 ) ; cur = stack . pop ( - 1 ) ; } else { for ( int i = 0 ; i < n ; i ++ ) { if ( graph [ cur ] [ i ] == 1 ) { stack . add ( cur ) ; graph [ cur ] [ i ] = 0 ; graph [ i ] [ cur ] = 0 ; cur = i ; break ; } } } for ( int ele : path ) System . out . print ( ele + " - > ▁ " ) ; System . out . print ( cur + 1 ) ; }
static int sumBetweenTwoKth ( int arr [ ] , int n , int k1 , int k2 ) { Arrays . sort ( arr ) ; int result = 0 ; for ( int i = k1 ; i <= k2 ; i ++ ) result += arr [ i ] ; return result ; }
static int calculate ( int [ ] a ) { int maximum = Arrays . stream ( a ) . max ( ) . getAsInt ( ) ; int [ ] frequency = new int [ maximum + 1 ] ; for ( int i = 0 ; i <= maximum ; i ++ ) frequency [ i ] ++ ; int answer = 0 ; for ( int i = 0 ; i <= frequency . length ; i ++ ) answer += i * ( i - 1 ) / 2 ; return answer ; }
static int sumNodes ( int l ) { long leafNodeCount = ( long ) Math . pow ( 2 , l - 1 ) ; int [ ] [ ] vec = new int [ l ] [ leafNodeCount + 1 ] ; for ( int i = 1 ; i <= leafNodeCount ; i ++ ) vec [ i ] [ 0 ] = i ; for ( int i = 1 ; i <= l - 2 ; i ++ ) { vec [ l - 1 ] . add ( i ) ; } for ( int i = l - 2 ; i >= 0 ; i -- ) { int k ; for ( k = 0 ; k < ( vec [ i + 1 ] ) . length - 1 ; k ++ ) vec [ i ] . add ( vec [ i + 1 ] [ k ] + vec [ i + 1 ] [ k + 1 ] ) ; } int sum = 0 ; for ( int i = 0 ; i <= l ; i ++ ) for ( int j = 0 ; j < vec [ i ] . length ; j ++ ) sum += vec [ i ] [ j ] ; return sum ; }
static String encrypt ( String text , int s ) { String result = " " ; for ( int i = 0 ; i < text . length ( ) ; i ++ ) { char char = text . charAt ( i ) ; if ( char . isupper ( ) ) result += ( ( char ) + s - 65 ) % 26 + 65 ; else result += ( ( char ) + s - 97 ) % 26 + 97 ; } return result ; }
static int gcd ( int a , int b ) { if ( a == 0 ) return b ; if ( b == 0 ) return a ; int k = 0 ; while ( ( ( a | b ) & 1 ) == 0 ) { a = a >> 1 ; b = b >> 1 ; k ++ ; } while ( ( a & 1 ) == 0 ) { a = a >> 1 ; b = b >> 1 ; k ++ ; } while ( ( b & 1 ) == 0 ) { b = b >> 1 ; } if ( a != 0 ) { while ( ( b & 1 ) == 0 ) { b = b >> 1 ; } if ( a > b ) { int temp = a ; a = b ; b = temp ; } b = ( b - a ) ; } return ( a << k ) ; }
static int calculateSum ( int arr [ ] , int n ) { if ( n == 0 ) return 0 ; int s = arr [ 0 ] ; int value = s ; int sum = value ; for ( int i = 1 ; i < n ; i += 2 ) { s = arr [ i ] ; value = s ; operation = arr [ i - 1 ] [ 0 ] ; if ( operation == ' + ' ) sum += value ; else sum -= value ; } return sum ; }
static String replace ( String s , char c1 , char c2 ) { int l = s . length ( ) ; for ( int i = 0 ; i < l ; i ++ ) { if ( s . charAt ( i ) == c1 ) s = s . substring ( 0 , i + c2 + s . charAt ( i + 1 ) ) ; else if ( s . charAt ( i ) == c2 ) s = s . substring ( 0 , i + c1 + s . charAt ( i + 1 ) ) ; } return s ; }
static String lexicographicSubConcat ( String s ) { int n = s . length ( ) ; int sub_count = ( n * ( n + 1 ) ) / 2 ; int [ ] arr = new int [ sub_count ] ; int index = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 1 ; j <= n - i ; j ++ ) arr [ index ] = s . charAt ( i ) + j ; index ++ ; } Arrays . sort ( arr ) ; for ( int i = 0 ; i < sub_count ; i ++ ) res += arr [ i ] ; return res ; }
static int findpos ( String n ) { int i = 0 , j = n . length ( ) ; int pos = 0 ; while ( i < j ) { if ( n . charAt ( i ) == '4' ) pos = pos * 2 + 1 ; if ( n . charAt ( i ) == '7' ) pos = pos * 2 + 2 ; i ++ ; } return pos ; }
static int lis ( int arr [ ] , int n ) { int [ ] mpis = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { mpis [ i ] = arr [ i ] ; } for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ i ] > arr [ j ] && mpis [ i ] < ( mpis [ j ] * arr [ i ] ) ) mpis [ i ] = mpis [ j ] * arr [ i ] ; } } return Math . max ( mpis ) ; }
static boolean checkSorted ( int n , Queue < Integer > q ) { List < Integer > st = new ArrayList < Integer > ( ) ; int expected = 1 ; int fnt = null ; while ( ! q . isEmpty ( ) ) { fnt = q . peek ( ) ; q . remove ( ) ; if ( fnt == expected ) expected ++ ; else { if ( st . size ( ) == 0 ) st . add ( fnt ) ; else if ( st . size ( ) != 0 && st . peek ( ) < fnt ) return false ; else { st . add ( fnt ) ; } } while ( ! st . isEmpty ( ) && st . peek ( ) == expected ) st . pop ( ) ; expected ++ ; if ( expected - 1 == n && st . size ( ) == 0 ) return true ; return false ; }
static void generate ( LinkedList < Character > s ) { if ( s . size ( ) == 0 ) return ; if ( st . contains ( s ) ) { List < Character > t = new ArrayList < Character > ( ) ; t . add ( s . get ( i ) ) ; generate ( st , t ) ; } }
static int minLexRotation ( String str ) { int n = str . length ( ) ; StringBuffer sb = new StringBuffer ( str ) ; sb . append ( str ) ; for ( int i = 0 ; i < arr . length ; i ++ ) { sb . append ( str . charAt ( i ) ) ; arr [ i ] = sb . substring ( i , n + i ) ; } Arrays . sort ( arr ) ; return arr [ 0 ] ; }
static boolean isPossible ( int a [ ] , int b [ ] , int n , int k ) { Arrays . sort ( a ) ; Arrays . sort ( b ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] + b [ i ] < k ) return false ; } return true ; }
static boolean isCornerPresent ( String str , String corner ) { int n = str . length ( ) ; int cl = corner . length ( ) ; if ( n < cl ) return false ; return ( str . substring ( 0 , cl ) == corner ) && ( str . substring ( n - cl ) == corner ) ; }
static String longDivision ( String number , int divisor ) { String ans = " " ; int idx = 0 ; int temp = ( number . charAt ( idx ) - '0' ) ; while ( temp < divisor ) { temp = ( temp * 10 + ( number . charAt ( idx + 1 ) ) - '0' ) ; idx ++ ; } while ( ( number . length ( ) ) > idx ) { ans += ( char ) ( Math . floor ( temp / divisor ) + '0' ) ; temp = ( ( temp % divisor ) * 10 + ( number . charAt ( idx ) ) - '0' ) ; idx ++ ; } ans += ( char ) ( Math . floor ( temp / divisor ) + '0' ) ; if ( ans . length ( ) == 0 ) return "0" ; return ans ; }
static void sort012 ( int a [ ] , int arr_size ) { int lo = 0 , hi = arr_size - 1 ; int mid = 0 ; while ( mid <= hi ) { if ( a [ mid ] == 0 ) { a [ lo ] = a [ mid ] , a [ lo ] ; mid = mid + 1 ; } else if ( a [ mid ] == 1 ) { mid = mid + 1 ; } else { a [ mid ] = a [ hi ] ; hi = hi - 1 ; } } }
static boolean canRepresentBST ( int pre [ ] ) { Stack < Integer > s = new Stack < Integer > ( ) ; int root = Integer . MIN_VALUE ; for ( int value = 0 ; value < root ; value ++ ) { if ( s . size ( ) > 0 && s . peek ( ) < value ) { root = s . peek ( ) ; s . pop ( ) ; } s . add ( value ) ; } return true ; }
static int solveQuery ( int start , int end , int arr [ ] ) { Map < Integer , Integer > frequency = new HashMap < Integer , Integer > ( ) ; for ( int i = start ; i <= end ; i ++ ) { if ( frequency . containsKey ( arr [ i ] ) ) { frequency . put ( arr [ i ] , frequency . get ( arr [ i ] ) + 1 ) ; } else { frequency . put ( arr [ i ] , 1 ) ; } } int count = 0 ; for ( int x = 0 ; x < frequency . size ( ) ; x ++ ) if ( frequency . get ( x ) == 1 ) count ++ ; return count ; }
static boolean divisibleBy20 ( String num ) { int lastTwoDigits = num . length ( ) ; return ( lastTwoDigits % 5 == 0 && lastTwoDigits % 4 == 0 ) ; }
static void CountTriangles ( int A [ ] ) { int n = A . length ; int count = 0 ; quickSort ( A , 0 , n - 1 ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { int l = 0 , r = i - 1 ; while ( l < r ) { if ( A [ l ] + A [ r ] > A [ i ] ) count += r - l ; r -- ; else l ++ ; } } System . out . println ( " No ▁ of ▁ possible ▁ solutions : ▁ " + count ) ; }
static void countFreq ( int [ ] a , int n ) { HashMap < Integer , Integer > hm = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { hm . put ( a [ i ] , hm . get ( a [ i ] ) + 1 ) ; } int cumul = 0 ; HashSet < Integer > st = new HashSet < Integer > ( ) ; for ( int x = 0 ; x < hm . size ( ) ; x ++ ) { st . add ( ( int ) hm . get ( x ) ) ; cumul += x [ 1 ] ; System . out . println ( x [ 0 ] + " ▁ " + cumul ) ; } }
public static void cocktailSort ( int [ ] a ) { int n = a . length ; boolean swapped = true ; int start = 0 , end = n - 1 ; while ( swapped == true ) break ; swapped = false ; for ( int i = start ; i <= end ; i ++ ) { if ( a [ i ] > a [ i + 1 ] ) { a [ i ] = a [ i + 1 ] ; a [ i + 1 ] = a [ i ] ; swapped = true ; } } if ( swapped == false ) break ; swapped = false ; end = end - 1 ; for ( int i = end - 1 ; i >= start ; i -- ) { if ( a [ i ] > a [ i + 1 ] ) { a [ i ] = a [ i + 1 ] ; a [ i + 1 ] = a [ i + 1 ] ; swapped = true ; } } start = start + 1 ; } }
static char first ( String str , int i ) { if ( str . charAt ( i ) == ' \0' ) return 0 ; if ( str . charAt ( i ) . isupper ( ) ) return str . charAt ( i ) ; return first ( str , i + 1 ) ; }
static int longestNull ( String S ) { Stack < Character > arr = new Stack < Character > ( ) ; arr . add ( new Character ( ' @ ' ) ) ; int maxlen = 0 ; for ( int i = 0 ; i < S . length ( ) ; i ++ ) { char ch = S . charAt ( i ) ; arr . add ( new Character ( ch ) ) ; for ( int i = 0 ; i < arr . size ( ) ; i ++ ) { char ch = arr . peek ( ) ; arr . remove ( ) ; while ( arr . size ( ) >= 3 && arr . peek ( ) == '1' && arr . peek ( ) == '0' && arr . peek ( ) == '0' && arr . peek ( ) == '0' && arr . pop ( ) == '0' ) { arr . pop ( ) ; arr . pop ( ) ; } } int tmp = arr . peek ( ) ; return maxlen ; }
static String reverse ( String str ) { str = str . toLowerCase ( ) ; return str . slice ( 0 , - 1 ) ; }
static String nextWord ( String s ) { if ( s == " ▁ " ) return " a " ; int i ; for ( i = s . length ( ) - 1 ; i >= 0 ; i -- ) s . charAt ( i ) = ' z ' ; if ( i == - 1 ) s += ' a ' ; else s . replace ( s . charAt ( i ) , Character . toLowerCase ( s . charAt ( i ) + 1 ) , 1 ) ; } return s ; }
static boolean isRectangle ( int matrix [ ] [ ] ) { int rows = matrix . length ; if ( rows == 0 ) return false ; int columns = matrix [ 0 ] . length ; int table [ ] = new int [ rows ] [ columns - 1 ] ; for ( int i = 0 ; i < rows ; i ++ ) { for ( int j = 0 ; j < columns - 1 ; j ++ ) { for ( int k = j + 1 ; k < columns ; k ++ ) { if ( matrix [ i ] [ j ] == 1 && matrix [ i ] [ k ] == 1 ) { if ( j in table && k in table [ j ] ) return true ; if ( table [ k ] . contains ( j ) ) return true ; if ( j == table [ j ] ) return true ; if ( k == table [ k ] ) return true ; } } } return false ; }
public static int sumoflength ( int arr [ ] , int n ) { List < Integer > s = new ArrayList < Integer > ( ) ; int j = 0 ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { while ( j < n && ! s . contains ( arr [ j ] ) ) { s . add ( arr [ j ] ) ; j ++ ; } ans += ( ( j - i ) * ( j - i + 1 ) ) / 2 ; s . remove ( arr [ i ] ) ; } return ans ; }
static void findTriplets ( int arr [ ] , int n ) { boolean found = false ; HashSet < Integer > s = new HashSet < Integer > ( ) ; for ( int i = 0 ; i <= n - 2 ; i ++ ) { for ( int j = i + 1 ; j <= n ; j ++ ) { int x = ( arr [ i ] + arr [ j ] ) ; if ( ! s . contains ( arr [ j ] ) ) { System . out . println ( x + " ▁ " + arr [ i ] + " ▁ " + arr [ j ] ) ; found = true ; } else s . add ( arr [ j ] ) ; } } if ( found == false ) System . out . println ( " No ▁ Triplet ▁ Found " ) ; }
static int maxPrefix ( String s , String t ) { int count = 0 ; for ( int i = 0 ; i < t . length ( ) ; i ++ ) { if ( count == s . length ( ) ) break ; if ( t . charAt ( i ) == s . charAt ( count ) ) count ++ ; } return count ; }
static void segregateElements ( int arr [ ] , int n ) { int temp [ ] = new int [ n ] ; int j = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] >= 0 ) temp [ j ] = arr [ i ] ; j ++ ; } if ( j == n || j == 0 ) return ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < 0 ) temp [ j ] = arr [ i ] ; j ++ ; } for ( int k = 0 ; k < n ; k ++ ) arr [ k ] = temp [ k ] ; }
static void mergeIntervals ( int [ ] arr ) { Arrays . sort ( arr ) ; int s = - 10000 , max = - 100000 ; Vector < Integer > m = new Vector < > ( ) ; for ( int i = 0 ; i < arr . length ; i ++ ) { int a = arr [ i ] ; if ( a [ 0 ] > max ) { if ( i != 0 ) m . add ( [ s , max ] ) ; max = a [ 1 ] ; s = a [ 0 ] ; } else { if ( a [ 1 ] >= max ) { max = a [ 1 ] ; } } } if ( max != - 100000 && m . size ( ) > 0 ) System . out . print ( " The ▁ Merged ▁ Intervals ▁ are ▁ : \n " ) ; for ( int i = 0 ; i < m . size ( ) ; i ++ ) System . out . print ( m [ i ] + " ▁ " ) ; }
static int findArea ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int [ ] dimension = new int [ 2 ] ; int i = 0 , j = 0 ; while ( i < n - 1 && j < 2 ) { if ( arr [ i ] == arr [ i + 1 ] ) dimension [ j ] = arr [ i ] ; j ++ ; i ++ ; } return ( dimension [ 0 ] * dimension [ 1 ] ) ; }
static int minOps ( int arr [ ] , int n , int k ) { int max1 = Math . max ( arr ) ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( max1 - arr [ i ] ) % k != 0 ) return - 1 ; else res += ( max1 - arr [ i ] ) / k ; } return res ; }
static boolean isdivisible7 ( String num ) { int n = num . length ( ) ; if ( n == 0 && num . charAt ( 0 ) == ' \n ' ) return 1 ; if ( n % 3 == 1 ) num = num + "00" ; n ++ ; else if ( n % 3 == 2 ) num = num + "0" ; n ++ ; int GSum = 0 ; int p = 1 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { group += ( num . charAt ( i ) - '0' ) ; i -- ; group += ( num . charAt ( i ) - '0' ) * 10 ; i -- ; group += ( num . charAt ( i ) - '0' ) * 100 ; GSum = GSum + group * p ; p *= ( - 1 ) ; } return ( GSum % 7 == 0 ) ; }
static boolean isDivisible999 ( String num ) { int n = num . length ( ) ; if ( n == 0 || num . charAt ( 0 ) == '0' ) return true ; if ( ( n % 3 ) == 1 ) num = "00" + num ; if ( ( n % 3 ) == 2 ) num = "0" + num ; int gSum = 0 ; for ( int i = 0 ; i < n ; i += 3 ) { group += ( num . charAt ( i ) - 48 ) * 100 ; group += ( num . charAt ( i + 1 ) - 48 ) * 10 ; group += ( num . charAt ( i + 2 ) - 48 ) ; gSum += group ; } if ( gSum > 1000 ) num = "0" + num ; return ( gSum == 999 ) ; }
static boolean checkPangram ( String s ) { boolean [ ] List = new boolean [ 26 ] ; for ( int i = 0 ; i < 26 ; i ++ ) List . add ( false ) ; for ( int c = 0 ; c < s . toLowerCase ( ) ; c ++ ) { if ( ! c . equals ( " ▁ " ) ) List . add ( ( int ) c - ' a ' ) ; } for ( boolean ch : List ) ch == false ) return false ; return true ; }
static void kLargest ( int arr [ ] , int k ) { Arrays . sort ( arr ) ; for ( int i = 0 ; i < k ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; }
static int kthLargestSum ( int arr [ ] , int n , int k ) { int sum [ ] = new int [ n + 1 ] ; sum . add ( arr [ 0 ] ) ; for ( int i = 2 ; i <= n ; i ++ ) { sum . add ( arr [ i ] ) ; } Queue < Integer > Q = new LinkedList < > ( ) ; Q . add ( 0 ) ; Q . add ( arr [ 0 ] ) ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = i ; j <= n ; j ++ ) { int x = sum [ j ] - sum [ i - 1 ] ; if ( Q . size ( ) < k ) heapq . add ( Q , x ) ; else { if ( Q [ 0 ] < x ) heapq . remove ( Q ) ; heapq . add ( Q , x ) ; } } } return Q [ 0 ] ; }
static void printDistinct ( int arr [ ] , int n ) { Map < Integer , Integer > s = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! s . containsKey ( arr [ i ] ) ) { s . put ( arr [ i ] , arr [ i ] ) ; System . out . print ( arr [ i ] + " ▁ " ) ; } } }
static int abFree ( String s ) { int b_count = 0 ; int res = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( ~ i ) == ' a ' ) res += b_count ; b_count = ( b_count * 2 ) ; else res ++ ; } return res ; }
static void findFibSubset ( int arr [ ] , int n ) { int m = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; int a = 0 , b = 1 ; int hash [ ] = new int [ m ] ; a = 0 ; b = 1 ; hash [ 0 ] = a ; hash [ 1 ] = b ; while ( b < m ) { int c = a + b ; a = b ; b = c ; hash . add ( b ) ; } for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] in hash ) System . out . print ( arr [ i ] + " ▁ " ) ; }
static void recursiveReverse ( String str , int i ) { int n = str . length ( ) ; if ( i == n / 2 ) { return ; } str . insert ( i , str . charAt ( n - i - 1 ) ) ; str . insert ( n - i - 1 , str . charAt ( i ) ) ; }
static String noAdjacentDup ( String s ) { int n = s . length ( ) ; for ( int i = 1 ; i < n ; i ++ ) { if ( s . charAt ( i ) == s . charAt ( i - 1 ) ) { s . insert ( i , " a " ) ; while ( i + 1 < n && s . charAt ( i ) == s . charAt ( i + 1 ) ) { s . insert ( i , 1 ) ; } i ++ ; } } return s ; }
static void query ( String s [ ] , int i , int j ) { int n = s . length ( ) ; i %= n ; j %= n ; if ( s . charAt ( i ) == s . charAt ( j ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; }
static int countPairs ( int arr [ ] , int n ) { int result = 0 ; HashSet < Integer > Hash = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) Hash . add ( arr [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int product = arr [ i ] * arr [ j ] ; if ( hash . contains ( product ) ) result ++ ; } } return result ; }
static void printInSortedOrder ( int arr [ ] , int n ) { int [ ] index = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { index [ i ] = i ; } for ( int i = 0 ; i < n - 1 ; i ++ ) { int min = i ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ index [ min ] ] > arr [ index [ j ] ] ) min = j ; } if ( min != i ) index [ min ] = index [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ index [ i ] ] + " ▁ " ) ; }
static void sortUsingHash ( int [ ] a , int n ) { int Max = Math . max ( a ) ; int Min = Math . min ( a ) ; int [ ] hashpos = new int [ Max + 1 ] ; int [ ] hashneg = new int [ Min + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] >= 0 ) hashpos [ a [ i ] ] ++ ; else hashneg [ Math . abs ( a [ i ] ) ] ++ ; } for ( int i = Min ; i < Max ; i ++ ) { if ( hashneg [ i ] != 0 ) for ( int j = 0 ; j != 0 ; j ++ ) System . out . print ( ( - 1 ) * i + " ▁ " ) ; } for ( int i = 0 ; i <= Max ; i ++ ) { if ( hashpos [ i ] != 0 ) for ( int j = 0 ; j != hashpos [ i ] ; j ++ ) System . out . print ( i + " ▁ " ) ; } } }
static void findRandomIndexOfMax ( int arr [ ] , int n ) { Map < Integer , Integer > myMap = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( myMap . containsKey ( arr [ i ] ) ) { myMap . put ( arr [ i ] , myMap . get ( arr [ i ] ) + 1 ) ; } else { myMap . put ( arr [ i ] , 1 ) ; } } int max_element = - 323567 ; int max_so_far = - 323567 ; int r = ( ( random . randrange ( 1 , max_so_far , 2 ) % max_so_far ) + 1 ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == max_element ) { count ++ ; } if ( count == r ) { System . out . println ( " Element ▁ with ▁ maximum ▁ frequency ▁ present ▁ at ▁ index ▁ " + i ) ; break ; } }
static double singleNumber ( int [ ] nums ) { return ( 3 * sum ( nums ) - sum ( nums ) ) / 2 ; }
static void printAllAPTriplets ( int arr [ ] , int n ) { Vector < Integer > s = new Vector < > ( ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int diff = arr [ j ] - arr [ i ] ; if ( ( arr [ i ] - diff ) in arr ) System . out . print ( " { } ▁ { } ▁ " . format ( ( arr [ i ] - diff ) , arr [ i ] , arr [ j ] ) + " \n " ) ; } } s . add ( arr [ i ] ) ; }
static String simplify ( String str ) { int Len = str . length ( ) ; String res [ ] = new String [ Len ] ; int index = 0 ; int i = 0 ; Stack < Integer > s = new Stack < > ( ) ; s . push ( 0 ) ; while ( i < Len ) { if ( str . charAt ( i ) == ' + ' ) { if ( s . peek ( ) == 1 ) res [ index ] = ' - ' ; index ++ ; } else if ( s . peek ( ) == 0 ) res [ index ] = ' + ' ; index ++ ; } else if ( str . charAt ( i ) == ' - ' ) { if ( s . peek ( ) == 1 ) res [ index ] = ' + ' ; index ++ ; } else if ( str . charAt ( i ) == ' ( ' && i > 0 ) { if ( str . charAt ( i - 1 ) == ' - ' ) x = 0 ; else s . push ( x ) ; } else if ( str . charAt ( i - 1 ) == ' + ' ) s . push ( s . peek ( ) ) ; } else { res [ index ] = str . charAt ( i ) ; index ++ ; } i ++ ; } return res ; }
static void findPair ( int [ ] arr , int n ) { HashMap < Integer , Integer > hM = new HashMap < Integer , Integer > ( ) ; boolean found = false ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] + arr [ j ] == hM . get ( arr [ i ] + arr [ j ] ) ) { System . out . println ( arr [ i ] + " ▁ exist " ) ; } } if ( found == false ) System . out . println ( " Not ▁ exist " ) ; }
static String strToBinary ( String s ) { List < Character > bin_conv = new ArrayList < Character > ( ) ; for ( char c : s ) { int ascii_val = ( int ) c ; bin_conv . add ( ascii_val ) ; } return ( " ▁ " . join ( bin_conv ) ) ; }
static boolean findDuplicateparenthesis ( String str ) { Stack < Character > Stack = new Stack < Character > ( ) ; for ( char ch : str ) { if ( ch == ' ) ' ) { int top = Stack . peek ( ) ; int elementsInside = 0 ; while ( top != ' ( ' ) elementsInside ++ ; top = Stack . peek ( ) ; } if ( elementsInside < 1 ) { return true ; } else { Stack . push ( ch ) ; } } return false ; }
static void findTriplets ( int x ) { Vector < Integer > fact = new Vector < > ( ) ; HashSet < Integer > factors = new HashSet < Integer > ( ) ; for ( int i = 2 ; i < sqrt ( x ) ; i ++ ) { if ( x % i == 0 ) fact . add ( i ) ; if ( x / i != i ) fact . add ( x / i ) ; factors . add ( i ) ; } boolean found = false ; for ( int i = 0 ; i < k ; i ++ ) { int a = fact . get ( i ) ; for ( int j = 0 ; j < k ; j ++ ) { int b = fact . get ( j ) ; if ( ( a != b ) && ( x % ( a * b ) == 0 ) && ( x / ( a * b ) != a ) && ( x / ( a * b ) != b ) && ( x / ( a * b ) != 1 ) ) System . out . println ( a , b , x / ( a * b ) ) ; found = true ; break ; } } if ( ! found ) System . out . println ( " - 1" ) ; }
static void findMissing ( String a [ ] , String b [ ] , int n , int m ) { HashMap < Character , Integer > s = new HashMap < Character , Integer > ( ) ; for ( int i = 0 ; i < m ; i ++ ) s [ b [ i ] ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( ! s . containsKey ( a [ i ] ) ) { System . out . print ( a [ i ] + " ▁ " ) ; } }
static void minheapify ( int [ ] a , int index ) { int small = index ; int l = 2 * index + 1 ; int r = 2 * index + 2 ; if ( l < n && a [ l ] < a [ small ] ) small = l ; if ( r < n && a [ r ] < a [ small ] ) small = r ; if ( small != index ) { int temp = a [ small ] ; a [ small ] = temp ; minheapify ( a , small ) ; } }
static void KMP ( int m , int n , String str2 , String str1 ) { int pos = 0 , Len = 0 ; int p [ ] = new int [ m + 1 ] ; int k ; for ( int i = 2 ; i <= n ; i ++ ) { while ( k > 0 && str1 . charAt ( k ) != str1 . charAt ( i - 1 ) ) k ++ ; if ( str1 . charAt ( k ) == str1 . charAt ( i - 1 ) ) k ++ ; p [ i ] = k ; } int j ; for ( int i = 0 ; i < m ; i ++ ) { while ( j > 0 && j < n && str1 . charAt ( j ) != str2 . charAt ( i ) ) j ++ ; if ( j > Len ) Len = j ; pos = i - j + 1 ; } } System . out . println ( " Shift ▁ = ▁ " + pos ) ; System . out . println ( " Prefix ▁ = ▁ " + str1 . charAt ( : Len ) ) ; }
static void swapDiagonal ( int matrix [ ] [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { matrix [ i ] [ i ] , matrix [ i ] [ N - i - 1 ] = matrix [ i ] [ i ] ; } }
static String maximumPalinUsingKChanges ( String str , int k ) { String palin = new String ( ) ; int l = 0 , r = str . length ( ) - 1 ; while ( l <= r ) { if ( str . charAt ( l ) != str . charAt ( r ) ) { palin [ l ] = palin [ r ] = Math . max ( str . charAt ( l ) , str . charAt ( r ) ) ; k -- ; } l ++ ; r -- ; } if ( k < 0 ) return " Not ▁ possible " ; } l = 0 ; r = str . length ( ) - 1 ; while ( l <= r ) { if ( l == r ) { if ( k > 0 ) { palin [ l ] = '9' ; } if ( palin [ l ] < '9' ) { if ( k >= 2 && palin [ l ] == str . charAt ( l ) && palin [ r ] == str . charAt ( r ) ) { k -- ; palin [ l ] = palin [ r ] = '9' ; } else if ( k >= 1 && ( palin [ l ] != str . charAt ( l ) || palin [ r ] != str . charAt ( r ) ) { k -- ; palin [ l ] = palin [ r ] = '9' ; } } l ++ ; r -- ; } return palin ; }
static int findMinRooms ( char [ ] slots , int n , int m ) { int [ ] counts = new int [ m ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) if ( slots [ i ] [ j ] == '1' ) counts [ j ] ++ ; } return Math . max ( counts , 0 ) ; }
static int minProduct ( int arr [ ] , int n , int k ) { heapify ( arr ) ; int count = 0 ; int ans = 1 ; while ( arr . size > 0 && count < k ) { int x = arr . peek ( ) ; if ( x != null ) ans *= x ; count ++ ; } return ans ; }
static int largest ( int arr [ ] , int n ) { int max = arr . length ; return max > n ? arr [ max ] : Integer . MIN_VALUE ; }
static int findLongestConseqSubseq ( int arr [ ] , int n ) { HashSet < Integer > S = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) S . add ( arr [ i ] ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( S . contains ( arr [ i ] ) ) { int j = arr [ i ] ; while ( S . contains ( j ) ) j ++ ; if ( ans < j - arr [ i ] ) ans = j - arr [ i ] ; } } return ans ; }
static void divisibilityCheck ( int arr [ ] , int n ) { HashMap < Integer , Integer > s = new HashMap < Integer , Integer > ( ) ; int max_ele = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { s . put ( arr [ i ] , 1 ) ; max_ele = Math . max ( max_ele , arr [ i ] ) ; } HashMap < Integer , Integer > res = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != 0 ) { for ( int j = arr [ i ] * 2 ; j <= max_ele ; j ++ ) { if ( s . containsKey ( j ) ) res . put ( j , 1 ) ; } } } for ( int x = 0 ; x < res . keys ( ) ; x ++ ) System . out . print ( x + " ▁ " ) ; }
static int minPalPartion ( String str ) { int n = str . length ( ) ; int [ ] C = new int [ n ] [ n ] ; boolean [ ] [ ] P = new boolean [ n ] [ n ] ; int i , j , k , L ; for ( i = 0 ; i < n ; i ++ ) { P [ i ] [ i ] = true ; C [ i ] [ i ] = 0 ; } for ( L = 2 ; L <= n ; L ++ ) { for ( i = 0 ; i < n - L + 1 ; i ++ ) { j = i + L - 1 ; if ( L == 2 ) P [ i ] [ j ] = ( str . charAt ( i ) == str . charAt ( j ) ) ; else P [ i ] [ j ] = ( str . charAt ( i ) == str . charAt ( j ) ) && P [ i + 1 ] [ j - 1 ] ; if ( P [ i ] [ j ] == true ) C [ i ] [ j ] = 0 ; else { C [ i ] [ j ] = Integer . MAX_VALUE ; for ( k = i ; k <= j ; k ++ ) C [ i ] [ j ] = Math . min ( C [ i ] [ j ] , C [ i ] [ k ] + C [ k + 1 ] [ j ] + 1 ) ; } } } return C [ 0 ] [ n - 1 ] ; }
static boolean checkCount ( int arr [ ] , int n , int k ) { Map < Integer , Integer > myMap = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) myMap . put ( arr [ i ] , myMap . get ( arr [ i ] ) + 1 ) ; for ( int key = 0 ; key < myMap . keySet ( ) ; key ++ ) { if ( myMap . get ( key ) > 2 * k ) return false ; } return true ; }
static char [ ] removeDuplicates ( char [ ] S ) { int n = S . length ; if ( n < 2 ) return S ; int j = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( S [ j ] != S [ i ] ) j ++ ; S [ j ] = S [ i ] ; } S = S [ : j ] ; return S ; }
static void KMaxCombinations ( int A [ ] , int B [ ] , int N , int K ) { PriorityQueue < Integer > pq = new PriorityQueue < Integer > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { int a = A [ i ] + B [ j ] ; pq . add ( ( int ) a ) ; } } int count = 0 ; while ( count < K ) System . out . println ( pq . peek ( ) [ 1 ] ) ; count ++ ; }
static String to_upper ( String str ) { for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( ' a ' <= str . charAt ( i ) <= ' z ' ) str = str . charAt ( 0 ) + ( str . charAt ( i ) - ' a ' + ' A ' ) + str . charAt ( i + 1 ) ; } return str ; }
static void sortInWave ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i += 2 ) { if ( i > 0 && arr [ i ] < arr [ i - 1 ] ) arr [ i ] = arr [ i - 1 ] ; if ( i < n - 1 && arr [ i ] < arr [ i + 1 ] ) arr [ i ] = arr [ i + 1 ] ; arr [ i + 1 ] = arr [ i ] ; } }
static String getMinNumberForPattern ( String seq ) { int n = seq . length ( ) ; if ( n >= 9 ) return " - 1" ; int [ ] result = new int [ n + 1 ] ; int count = 1 ; for ( int i = 0 ; i <= n ; i ++ ) { if ( i == n || seq . charAt ( i ) == ' I ' ) { for ( int j = i - 1 ; j >= 0 && seq . charAt ( j ) == ' I ' ; j -- ) { result [ j + 1 ] = ( char ) ( count + 1 ) ; count ++ ; if ( j >= 0 && seq . charAt ( j ) == ' I ' ) break ; } } } return result ; }
static void findMin ( int V ) { int [ ] deno = new int [ ] { 1 , 2 , 5 , 10 , 20 , 50 , 100 , 500 , 1000 } ; Vector < Integer > ans = new Vector < > ( ) ; int n = deno . length ; for ( int i = n - 1 ; i >= 0 ; i -- ) { while ( V >= deno . get ( i ) ) { V -= deno . get ( i ) ; ans . add ( deno . get ( i ) ) ; } } for ( int i = 0 ; i < ans . size ( ) ; i ++ ) System . out . print ( ans . get ( i ) + " ▁ " ) ; }
static int findRepeating ( int arr [ ] , int n ) { return sum ( arr ) - ( ( n - 1 ) * n ) / 2 ; }
static String findSum ( String str1 , String str2 ) { if ( str1 . length ( ) > str2 . length ( ) ) { String t = str1 ; str1 = str2 ; str2 = t ; } String str = " " ; int n1 = str1 . length ( ) ; int n2 = str2 . length ( ) ; String carry = 0 ; for ( int i = 0 ; i < n1 ; i ++ ) { int sum = ( ( str1 . charAt ( i ) - 48 ) + ( ( str2 . charAt ( i ) - 48 ) + carry ) ) ; str += ( sum % 10 + 48 ) ; carry = ( int ) ( sum / 10 ) ; } for ( int i = n1 ; i < n2 ; i ++ ) { int sum = ( ( str2 . charAt ( i ) - 48 ) + carry ) ; str += ( sum % 10 + 48 ) ; carry = ( int ) ( sum / 10 ) ; } if ( carry ) str += ( carry + 48 ) ; return str ; }
