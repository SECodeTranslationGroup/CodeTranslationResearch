def printPairs ( arr , n ) : NEW_LINE INDENT v = [ ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] == arr [ j ] ) : NEW_LINE INDENT v . append ( abs ( arr [ i ] ) ) NEW_LINE DEDENT DEDENT if ( len ( v ) == 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT v . sort ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( - v [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def findArea ( a , b , c ) : NEW_LINE INDENT if ( a < 0 or b < 0 or c < 0 or ( a + b <= c ) or a + c <= b or b + c <= a ) : NEW_LINE INDENT print ( " Not ▁ a ▁ valid ▁ triangle " ) NEW_LINE exit ( 0 ) NEW_LINE DEDENT s = ( a + b + c ) // 2 NEW_LINE if ( s * ( s - a ) * ( s - b ) * ( s - c ) ) NEW_LINE DEDENT return math . sqrt ( s * ( s - a ) * ( s - b ) * ( s - c ) ) NEW_LINE DEDENT
def isMajority ( a , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if mp . get ( a [ i ] ) : NEW_LINE INDENT mp [ a [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ a [ i ] ] = 1 NEW_LINE DEDENT DEDENT for x in mp : NEW_LINE INDENT if x . getValue ( ) >= n // 2 : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def nonDecNums ( n ) : NEW_LINE INDENT a = [ [ 0 for i in range ( n + 1 ) ] for j in range ( 10 ) ] NEW_LINE for i in range ( 0 , 9 ) : NEW_LINE INDENT a [ 0 ] [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT a [ i ] [ 9 ] = 1 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 8 ) : NEW_LINE INDENT a [ i ] [ j ] = a [ i - 1 ] [ j ] + a [ i ] [ j + 1 ] NEW_LINE DEDENT DEDENT return a [ n ] [ 0 ] NEW_LINE DEDENT
def firstFit ( blockSize , m , processSize , n ) : NEW_LINE INDENT allocation = [ - 1 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( blockSize [ j ] >= processSize [ i ] ) : NEW_LINE INDENT allocation [ i ] = j NEW_LINE blockSize [ j ] -= processSize [ i ] NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT print ( " \n Process ▁ No . \tProcess ▁ Size\tBlock ▁ no . " ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( " ▁ " , ( i + 1 ) , " \t\t " , processSize [ i ] ) NEW_LINE if ( allocation [ i ] != - 1 ) : NEW_LINE INDENT print ( allocation [ i ] + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ Allocated " ) NEW_LINE DEDENT DEDENT
def firstnonrepeating ( arr , n ) : NEW_LINE INDENT m = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if m . get ( arr [ i ] ) : NEW_LINE INDENT m [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT m [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if m [ arr [ i ] ] == 1 : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def distributingBalls ( k , n , str ) : NEW_LINE INDENT a = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( n ) : NEW_LINE INDENT a [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( 0 , MAX_CHAR ) : NEW_LINE INDENT if ( a [ i ] > k ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def count_of_ways ( n ) : NEW_LINE INDENT count = 0 NEW_LINE count = ( n + 1 ) * ( n + 2 ) / 2 NEW_LINE return count NEW_LINE DEDENT
def maxSum ( arr , n ) : NEW_LINE INDENT cum_sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT cum_sum += arr [ i ] NEW_LINE curr_val = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT curr_val += i * arr [ i ] NEW_LINE DEDENT res = curr_val NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT next_val = curr_val - ( cum_sum - arr [ i - 1 ] ) + arr [ i - 1 ] * ( n - 1 ) NEW_LINE curr_val = next_val NEW_LINE res = max ( res , next_val ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def calcAngle ( h , m ) : NEW_LINE INDENT if ( h < 0 or m < 0 or h > 12 or m > 60 ) : NEW_LINE INDENT print ( " Wrong ▁ input " ) NEW_LINE return - 1 NEW_LINE DEDENT if ( h == 12 ) : NEW_LINE INDENT h = 0 NEW_LINE DEDENT if ( m == 60 ) : NEW_LINE INDENT m = 0 NEW_LINE DEDENT hour_angle = ( int ) ( 0.5 * ( h * 60 + m ) ) NEW_LINE minute_angle = ( int ) ( 6 * m ) NEW_LINE angle = abs ( hour_angle - minute_angle ) NEW_LINE angle = min ( 360 - angle , angle ) NEW_LINE return angle NEW_LINE DEDENT
def smallest ( x , y , z ) : NEW_LINE INDENT if ( ( y // x ) != 1 ) : NEW_LINE INDENT return ( ( y // z ) != 1 ) : NEW_LINE INDENT return ( ( y // z ) != 1 ) : NEW_LINE DEDENT return ( ( x // z ) != 1 ) : NEW_LINE INDENT x = x - 1 NEW_LINE DEDENT
def findExtraCharcter ( strA , strB ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( len ( strA ) ) : NEW_LINE INDENT res ^= strA [ i ] NEW_LINE DEDENT for i in range ( len ( strB ) ) : NEW_LINE INDENT res ^= strB [ i ] NEW_LINE DEDENT return ( res ) NEW_LINE DEDENT
def recaman ( n ) : NEW_LINE INDENT if ( n <= 0 ) : return NEW_LINE DEDENT s = set ( ) NEW_LINE s . add ( 0 ) NEW_LINE prev = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT curr = prev - i NEW_LINE if ( curr < 0 or s . contains ( curr ) ) : NEW_LINE INDENT curr = prev + i NEW_LINE DEDENT s . add ( curr ) NEW_LINE print ( " % d , ▁ " , curr ) NEW_LINE prev = curr NEW_LINE DEDENT DEDENT
def findMinimumAngle ( arr , n ) : NEW_LINE INDENT l = 0 NEW_LINE sum = 0 NEW_LINE ans = 360 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE while ( sum >= 180 ) : NEW_LINE INDENT ans = min ( ans , 2 * abs ( 180 - sum ) ) NEW_LINE sum -= arr [ l ] NEW_LINE l += 1 NEW_LINE DEDENT ans = min ( ans , 2 * abs ( 180 - sum ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def countSubsequence ( s , n ) : NEW_LINE INDENT cntG = 0 NEW_LINE cntF = 0 NEW_LINE result = 0 NEW_LINE C = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT switch ( s [ i ] ) : NEW_LINE INDENT cntG += 1 NEW_LINE result += C NEW_LINE break NEW_LINE DEDENT case ' G ' : NEW_LINE INDENT cntG += 1 NEW_LINE result += C NEW_LINE DEDENT break NEW_LINE DEDENT case ' F ' : NEW_LINE INDENT cntF += 1 NEW_LINE C += cntG NEW_LINE break NEW_LINE DEDENT default : NEW_LINE INDENT continue NEW_LINE DEDENT DEDENT print ( result ) NEW_LINE DEDENT
def maxdiff ( arr , n ) : NEW_LINE INDENT freq = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ arr [ i ] ] = freq [ arr [ i ] ] + 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( freq [ arr [ i ] ] > freq [ arr [ j ] ] and arr [ i ] > arr [ j ] ) : NEW_LINE INDENT ans = max ( ans , freq [ arr [ i ] ] - freq [ arr [ j ] ] ) NEW_LINE DEDENT elif ( freq [ arr [ i ] ] < freq [ j ] ) and arr [ i ] < arr [ j ] ) : NEW_LINE INDENT ans = max ( ans , freq [ arr [ j ] ] - freq [ arr [ i ] ) ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def areEqual ( arr1 , arr2 , m ) : NEW_LINE INDENT n = len ( arr1 ) NEW_LINE m = len ( arr2 ) NEW_LINE if ( n != m ) : NEW_LINE INDENT return False NEW_LINE DEDENT arr1 . sort ( ) NEW_LINE arr2 . sort ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr1 [ i ] != arr2 [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def countFriendsPairings ( n ) : NEW_LINE INDENT a = 1 NEW_LINE b = 2 NEW_LINE c = 0 NEW_LINE if n <= 2 : NEW_LINE INDENT return n NEW_LINE DEDENT for i in range ( 3 , n + 1 ) : NEW_LINE INDENT c = b + ( i - 1 ) * a NEW_LINE a = b NEW_LINE b = c NEW_LINE DEDENT return c NEW_LINE DEDENT
def PowerOFPINnfactorial ( n , p ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT count = 0 NEW_LINE temp = i NEW_LINE while temp % p == 0 : NEW_LINE INDENT count += 1 NEW_LINE temp = temp / p NEW_LINE DEDENT ans += count NEW_LINE DEDENT return ans NEW_LINE DEDENT
def findLength ( str1 ) : NEW_LINE INDENT n = len ( str1 ) NEW_LINE maxlen = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT length = j - i + 1 NEW_LINE leftsum = 0 NEW_LINE rightsum = 0 NEW_LINE for k in range ( 0 , int ( length / 2 ) ) : NEW_LINE INDENT leftsum += ( str1 [ i + k ] - ord ( '0' ) ) NEW_LINE rightsum += ( str1 [ i + k + length // 2 ] - ord ( '0' ) ) NEW_LINE DEDENT if ( leftsum == rightsum and maxlen < length ) : NEW_LINE INDENT maxlen = length NEW_LINE DEDENT DEDENT DEDENT return maxlen NEW_LINE DEDENT
def search ( arr , n , x ) : NEW_LINE INDENT for i in arr : NEW_LINE INDENT if arr [ i ] == x : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def subArray ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT for k in range ( i , j + 1 ) : NEW_LINE INDENT print ( arr [ k ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
def isSubSeqDivisible ( Str ) : NEW_LINE INDENT n = len ( Str ) NEW_LINE dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( 10 ) ] NEW_LINE arr = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT arr [ i ] = ord ( Str [ i - 1 ] ) - ord ( '0' ) NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT dp [ i ] [ arr [ i ] % 8 ] = 1 NEW_LINE for j in range ( 8 ) : NEW_LINE INDENT if ( dp [ i - 1 ] [ j ] > dp [ i ] [ ( j * 10 + arr [ i ] ) % 8 ] ) : NEW_LINE INDENT dp [ i ] [ ( j * 10 + arr [ i ] ) % 8 ] = dp [ i - 1 ] [ j ] NEW_LINE DEDENT if ( dp [ i - 1 ] [ j ] > dp [ i ] [ j ] ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( dp [ i ] [ 0 ] == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def solve ( i , par , a , n , k , current_ans ) : NEW_LINE INDENT if par > k : NEW_LINE INDENT return NEW_LINE DEDENT if par == k and i == n - 1 : NEW_LINE INDENT ans = min ( ans , current_ans ) NEW_LINE return NEW_LINE DEDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT solve ( j , par + 1 , a , n , k , current_ans + ( a [ j ] - a [ i + 1 ] ) * ( a [ j ] - a [ i + 1 ] ) ) NEW_LINE DEDENT DEDENT
def squareRoot ( n ) : NEW_LINE INDENT x = n NEW_LINE y = 1 NEW_LINE e = 0.000001 NEW_LINE while ( x - y > e ) : NEW_LINE INDENT x = ( x + y ) // 2 NEW_LINE y = n / x NEW_LINE DEDENT return x NEW_LINE DEDENT
def CountPairs ( n ) : NEW_LINE INDENT k = n NEW_LINE imin = 1 NEW_LINE ans = 0 NEW_LINE while ( imin <= n ) : NEW_LINE INDENT imax = n // k NEW_LINE ans += k * ( imax - imin + 1 ) NEW_LINE imin = imax + 1 NEW_LINE k = n // imin NEW_LINE DEDENT return ans NEW_LINE DEDENT
def multiplyWith3Point5 ( x ) : NEW_LINE INDENT return ( x << 1 ) + x + ( x > > 1 ) NEW_LINE DEDENT
def prevPermutation ( str ) : NEW_LINE INDENT n = len ( str ) - 1 NEW_LINE i = n NEW_LINE while i > 0 and str [ i - 1 ] <= str [ i ] : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT if i <= 0 : NEW_LINE INDENT return False NEW_LINE DEDENT j = i - 1 NEW_LINE while ( j + 1 <= n and str [ j + 1 ] <= str [ i - 1 ] ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT swap ( str , i - 1 , j ) NEW_LINE string = list ( str ) NEW_LINE string . reverse ( ) NEW_LINE str . reverse ( ) NEW_LINE return True NEW_LINE DEDENT
def polygonArea ( X , Y , n ) : NEW_LINE INDENT area = 0.0 NEW_LINE j = n - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT area = area + ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) NEW_LINE j = i NEW_LINE DEDENT return abs ( area // 2.0 ) NEW_LINE DEDENT
def equilibrium ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT leftsum = 0 NEW_LINE for j in range ( i ) : NEW_LINE INDENT leftsum += arr [ j ] NEW_LINE DEDENT rightsum = 0 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT rightsum += arr [ j ] NEW_LINE DEDENT if ( leftsum == rightsum ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def chordCnt ( A ) : NEW_LINE INDENT n = 2 * A NEW_LINE dpArray = [ 0 for i in range ( n + 1 ) ] NEW_LINE dpArray [ 0 ] = 1 NEW_LINE dpArray [ 2 ] = 1 NEW_LINE for i in range ( 4 , n + 2 ) : NEW_LINE INDENT for j in range ( i - 1 , 2 ) : NEW_LINE INDENT dpArray [ i ] = ( dpArray [ j ] * dpArray [ i - 2 - j ] ) NEW_LINE DEDENT DEDENT return dpArray [ n ] NEW_LINE DEDENT
def compute ( a , b ) : NEW_LINE INDENT AM = ( a + b ) / 2 NEW_LINE GM = math . sqrt ( a * b ) NEW_LINE HM = ( GM * GM ) / AM NEW_LINE return HM NEW_LINE DEDENT
def findMajority ( arr , n ) : NEW_LINE INDENT maxCount = 0 NEW_LINE index = - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] == arr [ j ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( count > maxCount ) : NEW_LINE INDENT maxCount = count NEW_LINE index = i NEW_LINE DEDENT DEDENT if ( maxCount > n // 2 ) : NEW_LINE INDENT print ( arr [ index ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No ▁ Majority ▁ Element " ) NEW_LINE DEDENT DEDENT
def isPerfectSquare ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE i = 1 NEW_LINE while sum < n : NEW_LINE INDENT sum += i NEW_LINE if sum == n : NEW_LINE INDENT return True NEW_LINE DEDENT i += 2 NEW_LINE DEDENT return False NEW_LINE DEDENT
def findSubString ( str , pat ) : NEW_LINE INDENT len1 = len ( str ) NEW_LINE len2 = len ( pat ) NEW_LINE if ( len1 < len2 ) : NEW_LINE INDENT print ( " No ▁ such ▁ window ▁ exists " ) NEW_LINE return " " NEW_LINE DEDENT hash_pat = [ 0 ] * no_of_chars NEW_LINE hash_str = [ 0 ] * no_of_chars NEW_LINE for i in range ( len2 ) : NEW_LINE INDENT hash_pat [ pat [ i ] ] += 1 NEW_LINE DEDENT start = 0 NEW_LINE start_index = - 1 NEW_LINE min_len = 10 ** 9 NEW_LINE count = 0 NEW_LINE for j in range ( len1 ) : NEW_LINE INDENT hash_str [ ord ( str [ j ] ) ] += 1 NEW_LINE if ( hash_pat [ ord ( str [ start ] ) ] != 0 and hash_str [ ord ( str [ start ] ) ] <= hash_pat [ ord ( str [ start ] ) ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( count == len2 ) : NEW_LINE INDENT while ( hash_str [ ord ( str [ start ] ) ] > hash_pat [ ord ( str [ start ] ) ] or hash_pat [ ord ( str [ start ] ) ] == 0 ) : NEW_LINE INDENT if ( hash_str [ ord ( str [ start ] ) ] > hash_pat [ ord ( str [ start ] ) ] ) : NEW_LINE INDENT hash_str [ ord ( str [ start ] ) ] -= 1 NEW_LINE start += 1 NEW_LINE DEDENT DEDENT if ( start_index == - 1 ) : NEW_LINE INDENT print ( " No ▁ such ▁ window ▁ exists " ) NEW_LINE return " " NEW_LINE DEDENT DEDENT
def countDivisibleSubseq ( str , n ) : NEW_LINE INDENT lenn = len ( str ) NEW_LINE dp = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] NEW_LINE for i in range ( 1 , len ) : NEW_LINE INDENT dp [ i ] [ ( ord ( str [ i ] ) - ord ( '0' ) ) % n ] += 1 NEW_LINE for j in range ( n ) : NEW_LINE INDENT dp [ i ] [ j ] += dp [ i - 1 ] [ j ] NEW_LINE dp [ i ] [ ( j * 10 + ( ord ( str [ i ] ) - ord ( '0' ) ) % n ] += dp [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT return dp [ len - 1 ] [ 0 ] NEW_LINE DEDENT
def pairs ( arr , n , k ) : NEW_LINE INDENT smallest = + 2147483647 NEW_LINE count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( abs ( arr [ i ] + arr [ j ] - k ) < smallest ) : NEW_LINE INDENT smallest = abs ( arr [ i ] + arr [ j ] - k ) NEW_LINE count = 1 NEW_LINE DEDENT elif ( abs ( arr [ i ] + arr [ j ] - k ) == smallest ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( " Minimal ▁ Value ▁ = ▁ " , smallest ) NEW_LINE print ( " Total ▁ Pairs ▁ = " , count ) NEW_LINE DEDENT
def nearestSmallerEqFib ( n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT f1 = 0 NEW_LINE f2 = 1 NEW_LINE f3 = 1 NEW_LINE while ( f3 <= n ) : NEW_LINE INDENT f1 = f2 NEW_LINE f2 = f3 NEW_LINE f3 = f1 + f2 NEW_LINE DEDENT return f2 NEW_LINE DEDENT
def shuffle ( card , n ) : NEW_LINE INDENT rand = new Random ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT r = i + rand . nextInt ( 52 - i ) NEW_LINE card [ r ] , card [ i ] = card [ i ] , card [ r ] NEW_LINE DEDENT DEDENT
def maxLen ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE sum = 0 NEW_LINE max_len = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE if ( arr [ i ] == 0 and max_len == 0 ) : NEW_LINE INDENT max_len = 1 NEW_LINE DEDENT if ( sum == 0 ) : NEW_LINE INDENT max_len = i + 1 NEW_LINE DEDENT if ( sum in s ) : NEW_LINE INDENT max_len = max ( max_len , i - prev_i ) NEW_LINE DEDENT else : NEW_LINE INDENT s . add ( sum ) NEW_LINE DEDENT return max_len NEW_LINE DEDENT
def maxLength ( s , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( s [ i ] == ' ( ' and s [ i + 1 ] == ' ) ' ) : NEW_LINE INDENT dp [ i ] [ i + 1 ] = 2 NEW_LINE DEDENT DEDENT for l in range ( 2 , n ) : NEW_LINE INDENT for i in range ( l , n ) : NEW_LINE INDENT for j in range ( l , n ) : NEW_LINE INDENT if ( s [ i ] == ' ( ' and s [ j ] == ' ) ' ) : NEW_LINE INDENT dp [ i ] [ j ] = 2 + dp [ i + 1 ] [ j - 1 ] NEW_LINE DEDENT DEDENT for k in range ( i , j ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i ] [ k ] + dp [ k + 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ 0 ] [ n - 1 ] NEW_LINE DEDENT
def summingSeries ( n ) : NEW_LINE INDENT return math . pow ( n , 2 ) NEW_LINE DEDENT
def isSubsetSum ( arr , n , sum ) : NEW_LINE INDENT subset = [ [ False for x in range ( sum + 1 ) ] for y in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 0 , sum + 1 ) : NEW_LINE INDENT if ( j == 0 ) : NEW_LINE INDENT subset [ i % 2 ] [ j ] = True NEW_LINE DEDENT elif ( i == 0 ) : NEW_LINE INDENT subset [ i % 2 ] [ j ] = False NEW_LINE DEDENT elif ( arr [ i - 1 ] <= j ) : NEW_LINE INDENT subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j - arr [ i - 1 ] ] or subset [ ( i + 1 ) % 2 ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return subset [ n % 2 ] [ sum ] NEW_LINE DEDENT
def findExtra ( arr1 , arr2 , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr1 [ i ] != arr2 [ i ] ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return n NEW_LINE DEDENT
def numberOfPermWithKInversion ( N , K ) : NEW_LINE INDENT if N == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if K == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if memo [ N ] [ K ] != 0 : NEW_LINE INDENT return memo [ N ] [ K ] NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( K + 1 ) : NEW_LINE INDENT if i <= N - 1 : NEW_LINE INDENT sum += numberOfPermWithKInversion ( N - 1 , K - i ) NEW_LINE DEDENT DEDENT memo [ N ] [ K ] = sum NEW_LINE return sum NEW_LINE DEDENT
def removeConsecutiveSame ( v ) : NEW_LINE INDENT st = [ ] NEW_LINE for i in range ( len ( v ) ) : NEW_LINE INDENT if ( st . empty ( ) ) : NEW_LINE INDENT st . append ( v [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT st . pop ( ) NEW_LINE DEDENT else : NEW_LINE INDENT st . append ( v [ i ] ) NEW_LINE DEDENT DEDENT return len ( st ) NEW_LINE DEDENT
def find ( list1 , list2 ) : NEW_LINE INDENT res = [ ] NEW_LINE max_possible_sum = int ( max ( list1 ) + list2 . size ( ) - 2 ) NEW_LINE for sum in range ( max_possible_sum + 1 ) : NEW_LINE INDENT for i in range ( 0 , sum + 1 ) : NEW_LINE INDENT if ( i < list1 . size ( ) and ( sum - i ) < list2 . size ( ) and list1 [ i ] == list2 [ sum - i ] ) : NEW_LINE INDENT res . append ( list1 [ i ] ) NEW_LINE DEDENT DEDENT if ( res . size ( ) > 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT for i in range ( 0 , len ( res ) ) : NEW_LINE INDENT print ( res [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def firstnonrepeating ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT j = 0 NEW_LINE while j < n : NEW_LINE INDENT if ( i != j and arr [ i ] == arr [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if ( j == n ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def search ( arr , n , x ) : NEW_LINE INDENT for i in arr : NEW_LINE INDENT if arr [ i ] == x : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def middlesum ( mat , n ) : NEW_LINE INDENT row_sum = 0 NEW_LINE col_sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT row_sum += mat [ n // 2 ] [ i ] NEW_LINE DEDENT print ( " Sum ▁ of ▁ middle ▁ row ▁ = ▁ " , row_sum ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT col_sum += mat [ i ] [ n // 2 ] NEW_LINE DEDENT print ( " Sum ▁ of ▁ middle ▁ column ▁ = ▁ " , col_sum ) NEW_LINE DEDENT
def moduloMultiplication ( a , b , mod ) : NEW_LINE INDENT res = 0 NEW_LINE a %= mod NEW_LINE while ( b > 0 ) : NEW_LINE INDENT if ( ( b & 1 ) > 0 ) : NEW_LINE INDENT res = ( res + a ) % mod NEW_LINE DEDENT a = ( 2 * a ) % mod NEW_LINE b >>= 1 NEW_LINE DEDENT return res NEW_LINE DEDENT
def pythagoreanTriplets ( limit ) : NEW_LINE INDENT c = 0 NEW_LINE m = 2 NEW_LINE while ( c < limit ) : NEW_LINE INDENT n = 1 NEW_LINE while ( n < m ) : NEW_LINE INDENT a = m * m - n * n NEW_LINE b = 2 * m * n NEW_LINE c = m * m + n * n NEW_LINE if ( c > limit ) : NEW_LINE INDENT break NEW_LINE DEDENT print ( a , " ▁ " , b , " ▁ " , c ) NEW_LINE DEDENT m += 1 NEW_LINE DEDENT DEDENT
def findSum ( n ) : NEW_LINE INDENT return ( n * ( n + 1 ) * ( n + 2 ) * ( 3 * n + 1 ) / 24 ) NEW_LINE DEDENT
def fib ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n == 1 or n == 2 ) : NEW_LINE INDENT return ( f [ n ] = 1 ) NEW_LINE DEDENT if ( f [ n ] != 0 ) : NEW_LINE INDENT return f [ n ] NEW_LINE DEDENT k = ( n + 1 ) // 2 NEW_LINE if ( n & 1 ) == 1 else n // 2 NEW_LINE DEDENT f [ n ] = ( fib ( k ) * fib ( k ) + fib ( k - 1 ) * fib ( k - 1 ) ) NEW_LINE DEDENT return f [ n ] NEW_LINE DEDENT
def Largestpower ( n , p ) : NEW_LINE INDENT ans = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT n /= p NEW_LINE ans += n NEW_LINE DEDENT return ans NEW_LINE DEDENT
def isIdentity ( mat , N ) : NEW_LINE INDENT for row in range ( 0 , N ) : NEW_LINE INDENT for col in range ( 0 , N ) : NEW_LINE INDENT if ( row == col and mat [ row ] [ col ] != 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT elif ( row != col and mat [ row ] [ col ] != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT
def minCells ( mat , m , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n ) ] for j in range ( m ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT dp [ i ] [ j ] = sys . maxint NEW_LINE DEDENT dp [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( dp [ i ] [ j ] != Integer . MAX_VALUE and ( j + mat [ i ] [ j ] ) < n and ( dp [ i ] [ j ] + 1 ) < dp [ i ] [ j + mat [ i ] [ j ] ] ) : NEW_LINE INDENT dp [ i ] [ j + mat [ i ] [ j ] ] = dp [ i ] [ j ] + 1 NEW_LINE DEDENT if ( dp [ i ] [ j ] != Integer . MAX_VALUE and ( i + mat [ i ] [ j ] ) < m and ( dp [ i ] [ j ] + 1 ) < dp [ i + mat [ i ] [ j ] ] [ j ] ) : NEW_LINE INDENT dp [ i + mat [ i ] [ j ] ] [ j ] = dp [ i ] [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT if ( dp [ m - 1 ] [ n - 1 ] != Integer . MAX_VALUE ) : NEW_LINE INDENT return dp [ m - 1 ] [ n - 1 ] NEW_LINE DEDENT
def arrangeString ( string , x , y ) : NEW_LINE INDENT count_0 = 0 NEW_LINE count_1 = 0 NEW_LINE len = len ( string ) NEW_LINE for i in range ( len ) : NEW_LINE INDENT if ( string [ i ] == '0' ) : NEW_LINE INDENT count_0 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_1 += 1 NEW_LINE DEDENT DEDENT while ( count_0 > 0 or count_1 > 0 ) : NEW_LINE INDENT for j in range ( x and count_0 > 0 ) : NEW_LINE INDENT if ( count_0 > 0 ) : NEW_LINE INDENT print ( "0" ) NEW_LINE count_0 -= 1 NEW_LINE DEDENT DEDENT for j in range ( y and count_1 > 0 ) : NEW_LINE INDENT if ( count_1 > 0 ) : NEW_LINE INDENT print ( "1" ) NEW_LINE count_1 -= 1 NEW_LINE DEDENT DEDENT DEDENT
def getLevenstein ( input ) : NEW_LINE INDENT revInput = list ( input ) NEW_LINE revInput . reverse ( ) NEW_LINE n = len ( input ) NEW_LINE dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT dp [ 0 ] [ i ] = i NEW_LINE dp [ i ] [ 0 ] = i NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( input [ i - 1 ] == revInput [ j - 1 ] ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = 1 + min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT res = + 2147483647 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT res = min ( res , dp [ i ] [ j ] ) NEW_LINE if i < n : NEW_LINE INDENT res = min ( res , dp [ i + 1 ] [ j ] ) NEW_LINE DEDENT if i > 0 : NEW_LINE INDENT res = min ( res , dp [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def carAssembly ( a , t , e , x ) : NEW_LINE INDENT T1 = [ 0 ] * NUM_STATION NEW_LINE T2 = [ 0 ] * NUM_STATION NEW_LINE for i in range ( 1 , NUM_STATION ) : NEW_LINE INDENT T1 [ 0 ] = e [ 0 ] + a [ 0 ] [ 0 ] NEW_LINE T2 [ 0 ] = e [ 1 ] + a [ 1 ] [ 0 ] NEW_LINE for i in range ( 1 , NUM_STATION ) : NEW_LINE INDENT T1 [ i ] = min ( T1 [ i - 1 ] + a [ 0 ] [ i ] , T2 [ i - 1 ] + t [ 1 ] [ i ] + a [ 0 ] [ i ] ) NEW_LINE T2 [ i ] = min ( T2 [ i - 1 ] + a [ 1 ] [ i ] , T1 [ i - 1 ] + t [ 0 ] [ i ] + a [ 1 ] [ i ] ) NEW_LINE DEDENT DEDENT return min ( T1 [ NUM_STATION - 1 ] + x [ 0 ] , T2 [ NUM_STATION - 1 ] + x [ 1 ] ) NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT
def findTriplets ( arr , n ) : NEW_LINE INDENT found = 0 NEW_LINE arr . sort ( ) NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT l = i + 1 NEW_LINE r = n - 1 NEW_LINE x = arr [ i ] NEW_LINE while ( l < r ) : NEW_LINE INDENT if ( x + arr [ l ] + arr [ r ] == 0 ) : NEW_LINE INDENT print ( x , end = " ▁ " ) NEW_LINE print ( arr [ l ] , end = " ▁ " ) NEW_LINE print ( arr [ r ] , end = " ▁ " ) NEW_LINE l += 1 NEW_LINE r -= 1 NEW_LINE found = True NEW_LINE DEDENT elif ( x + arr [ l ] + arr [ r ] < 0 ) : NEW_LINE INDENT l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT DEDENT DEDENT if ( found == False ) : NEW_LINE INDENT print ( " ▁ No ▁ Triplet ▁ Found " ) NEW_LINE DEDENT DEDENT
def getOddOccurrence ( ar , ar_size ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 0 , ar_size ) : NEW_LINE INDENT res = res ^ ar [ i ] NEW_LINE DEDENT return res NEW_LINE DEDENT
def maxTasks ( high , low , n ) : NEW_LINE INDENT if ( n <= 0 ) : return 0 NEW_LINE DEDENT return max ( high [ n - 1 ] + maxTasks ( high , low , ( n - 2 ) ) , low [ n - 1 ] + maxTasks ( high , low , ( n - 1 ) ) ) NEW_LINE DEDENT
def printOtherSides ( n ) : NEW_LINE INDENT if ( n % 2 != 0 ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT else : NEW_LINE INDENT b = ( n * n - 1 ) / 2 NEW_LINE c = ( n * n + 1 ) / 2 NEW_LINE print ( " b ▁ = ▁ " , b , " , ▁ c ▁ = ▁ " , c ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( n == 2 ) : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT else : NEW_LINE INDENT b = ( n * n / 4 - 1 ) NEW_LINE c = n * n / 4 + 1 NEW_LINE print ( " b ▁ = ▁ " , b , " , ▁ c ▁ = ▁ " , c ) NEW_LINE DEDENT DEDENT DEDENT
def printUnsorted ( arr , n ) : NEW_LINE INDENT s = 0 NEW_LINE e = n - 1 NEW_LINE for s in range ( n - 1 ) : NEW_LINE INDENT if arr [ s ] > arr [ s + 1 ] : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if e == n - 1 : NEW_LINE INDENT print ( " The ▁ complete ▁ array ▁ is ▁ sorted " ) NEW_LINE return NEW_LINE DEDENT for e in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if arr [ e ] < arr [ e - 1 ] : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT max = arr [ s ] NEW_LINE min = arr [ s ] NEW_LINE for i in range ( s + 1 , e + 1 ) : NEW_LINE INDENT if arr [ i ] > min : NEW_LINE INDENT s = i NEW_LINE break NEW_LINE DEDENT DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if arr [ i ] < max : NEW_LINE INDENT e = i NEW_LINE break NEW_LINE DEDENT DEDENT print ( " The ▁ unsorted ▁ subarray ▁ which " , " ▁ makes ▁ the ▁ given ▁ array ▁ sorted ▁ lies " , " ▁ and " , " " , " " ) NEW_LINE DEDENT return NEW_LINE DEDENT
def circle ( x1 , y1 , x2 , y2 , r1 , r2 ) : NEW_LINE INDENT distSq = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) NEW_LINE radSumSq = ( r1 + r2 ) * ( r1 + r2 ) NEW_LINE if ( distSq == radSumSq ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( distSq > radSumSq ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT
def countDistinct ( arr , k ) : NEW_LINE INDENT s = set ( ) NEW_LINE dist_count = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT if hM . get ( arr [ i ] ) == None : NEW_LINE INDENT s . add ( arr [ i ] ) NEW_LINE dist_count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count = hM . get ( arr [ i ] ) NEW_LINE hM [ arr [ i ] ] += 1 NEW_LINE DEDENT DEDENT print ( dist_count ) NEW_LINE for i in range ( k , len ( arr ) ) : NEW_LINE INDENT if hM [ arr [ i - k ] ] == 1 : NEW_LINE INDENT s . add ( arr [ i - k ] ) NEW_LINE dist_count -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT count = hM [ arr [ i - k ] ] NEW_LINE hM [ arr [ i - k ] ] = count - 1 NEW_LINE DEDENT if hM [ arr [ i ] ] == None : NEW_LINE INDENT s . add ( arr [ i ] ) NEW_LINE dist_count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count = hM [ arr [ i ] ] NEW_LINE hM [ arr [ i ] ] = count + 1 NEW_LINE DEDENT print ( dist_count ) NEW_LINE DEDENT DEDENT
def findArea ( a ) : NEW_LINE INDENT area = ( math . sqrt ( 5 * ( 5 + 2 * ( math . sqrt ( 5 ) ) ) * a * a ) / 4 ) NEW_LINE return round ( area , 2 ) NEW_LINE DEDENT
def countRotationsDivBy8 ( n ) : NEW_LINE INDENT lenn = len ( n ) NEW_LINE count = 0 NEW_LINE if ( len == 1 ) : NEW_LINE INDENT oneDigit = n [ 0 ] - '0' NEW_LINE if ( oneDigit % 8 == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT if ( len == 2 ) : NEW_LINE INDENT first = ( n [ 0 ] - '0' ) * 10 + ( n [ 1 ] - '0' ) NEW_LINE second = ( n [ 1 ] - '0' ) * 10 + ( n [ 0 ] - '0' ) NEW_LINE if ( first % 8 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( second % 8 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def lcs ( dp , arr1 , n , arr2 , m , k ) : NEW_LINE INDENT if ( k < 0 ) : NEW_LINE INDENT return - 10000000 NEW_LINE DEDENT if ( n < 0 or m < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = dp [ n ] [ m ] [ k ] NEW_LINE if ( ans != - 1 ) : NEW_LINE INDENT return ans NEW_LINE DEDENT try : NEW_LINE INDENT ans = max ( lcs ( dp , arr1 , n - 1 , arr2 , m , k ) , lcs ( dp , arr1 , n , arr2 , m - 1 , k ) ) NEW_LINE if ( arr1 [ n - 1 ] == arr2 [ m - 1 ] ) : NEW_LINE INDENT ans = max ( ans , 1 + lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k ) ) NEW_LINE DEDENT ans = max ( ans , 1 + lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k - 1 ) ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def editDistDP ( str1 , str2 , m , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( m + 1 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT dp [ i ] [ j ] = j NEW_LINE DEDENT elif j == 0 : NEW_LINE INDENT dp [ i ] [ j ] = i NEW_LINE DEDENT elif str1 [ i - 1 ] == str2 [ j - 1 ] : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = 1 + min ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ m ] [ n ] NEW_LINE DEDENT
def countOps ( A , B , m , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , m ) : NEW_LINE INDENT A [ i ] [ j ] -= B [ i ] [ j ] NEW_LINE DEDENT DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( 1 , m ) : NEW_LINE INDENT if ( A [ i ] [ j ] - A [ i ] [ 0 ] - A [ 0 ] [ j ] + A [ 0 ] [ 0 ] != 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT result = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT result += abs ( A [ i ] [ 0 ] ) NEW_LINE DEDENT for j in range ( 0 , m ) : NEW_LINE INDENT result += abs ( A [ 0 ] [ j ] - A [ 0 ] [ 0 ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT
def longestAlternating ( arr , n ) : NEW_LINE INDENT count = [ 0 ] * n NEW_LINE count [ n - 1 ] = 1 NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] * arr [ i + 1 ] < 0 ) : NEW_LINE INDENT count [ i ] = count [ i + 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT count [ i ] = 1 NEW_LINE DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( count [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def printDivisors ( n ) : NEW_LINE INDENT v = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( 1 , int ( m . sqrt ( n ) + 1 ) ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( n // i == i ) : NEW_LINE INDENT print ( " % d ▁ " , i ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " % d ▁ " , i ) NEW_LINE v . append ( n // i ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( len ( v ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( " % d ▁ " , v [ i ] ) NEW_LINE DEDENT DEDENT
def isPower ( x , y ) : NEW_LINE INDENT if ( x == 1 ) : NEW_LINE INDENT return ( y == 1 ) NEW_LINE DEDENT pow = 1 NEW_LINE while ( pow < y ) : NEW_LINE INDENT pow = pow * x NEW_LINE DEDENT return ( pow == y ) NEW_LINE DEDENT
def maxSum ( arr , N , k ) : NEW_LINE INDENT MS = [ 0 ] * N NEW_LINE MS [ N - 1 ] = arr [ N - 1 ] NEW_LINE for i in range ( N - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( i + k + 1 >= N ) : NEW_LINE INDENT MS [ i ] = max ( arr [ i ] , MS [ i + 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT MS [ i ] = max ( arr [ i ] + MS [ i + k + 1 ] , MS [ i + 1 ] ) NEW_LINE DEDENT DEDENT return MS [ 0 ] NEW_LINE DEDENT
def printGrouped ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE count = [ 0 for i in range ( MAX_CHAR ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT count [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT while ( count [ ord ( str [ i ] ) - ord ( ' a ' ) ] != 0 ) : NEW_LINE INDENT print ( str [ i ] , end = " " ) NEW_LINE count [ ord ( str [ i ] ) - ord ( ' a ' ) ] -= 1 NEW_LINE DEDENT count [ ord ( str [ i ] ) - ord ( ' a ' ) ] = 0 NEW_LINE DEDENT DEDENT
def sortedCount ( mat , r , c ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 0 , r ) : NEW_LINE INDENT j = 0 NEW_LINE while j < c - 1 : NEW_LINE INDENT if ( mat [ i ] [ j + 1 ] <= mat [ i ] [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if ( j == c - 1 ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT for i in range ( 0 , r ) : NEW_LINE INDENT j = c - 1 NEW_LINE while ( j > 0 ) : NEW_LINE INDENT if ( mat [ i ] [ j - 1 ] <= mat [ i ] [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( c > 1 and j == 0 ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def countSub ( str1 ) : NEW_LINE INDENT last = [ - 1 ] * MAX_CHAR NEW_LINE dp = [ 0 for _ in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT dp [ i ] = 2 * dp [ i - 1 ] NEW_LINE if ( last [ ord ( str1 [ i - 1 ] ) ] != - 1 ) : NEW_LINE INDENT dp [ i ] = dp [ i ] - dp [ last [ ord ( str1 [ i - 1 ] ) ] NEW_LINE DEDENT last [ ord ( str1 [ i - 1 ] ) ] = ( i - 1 ) NEW_LINE DEDENT return dp [ n ] NEW_LINE DEDENT
def findLIS ( A , n ) : NEW_LINE INDENT hash = dict ( ) NEW_LINE LIS_size = 1 NEW_LINE LIS_index = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT hash [ A [ i ] ] = 1 NEW_LINE if ( LIS_size < hash [ A [ i ] ] ) : NEW_LINE INDENT LIS_size = hash [ A [ i ] ] NEW_LINE LIS_index = A [ i ] NEW_LINE DEDENT DEDENT print ( " LIS _ size ▁ = ▁ " , LIS_size ) NEW_LINE print ( " LIS ▁ = ▁ " , LIS_index ) NEW_LINE start = LIS_index - LIS_size + 1 NEW_LINE while ( start <= LIS_index ) : NEW_LINE INDENT print ( start , end = " ▁ " ) NEW_LINE start += 1 NEW_LINE DEDENT DEDENT print ( " LIS ▁ : ▁ " ) NEW_LINE LIS_index = LIS_index NEW_LINE DEDENT
def printMaxOfMin ( arr , n ) : NEW_LINE INDENT for k in range ( 1 , n + 1 ) : NEW_LINE INDENT maxOfMin = - float ( " inf " ) NEW_LINE for i in range ( 0 , n - k + 1 ) : NEW_LINE INDENT min = arr [ i ] NEW_LINE for j in range ( 1 , k + 1 ) : NEW_LINE INDENT if ( arr [ i + j ] < min ) : NEW_LINE INDENT min = arr [ i + j ] NEW_LINE DEDENT DEDENT if ( min > maxOfMin ) : NEW_LINE INDENT maxOfMin = min NEW_LINE DEDENT DEDENT print ( maxOfMin , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def maximumZeros ( arr , n , k ) : NEW_LINE INDENT subset = [ [ 0 for i in range ( k + 1 ) ] for j in range ( MAX5 + 5 ) ] NEW_LINE for p in range ( n ) : NEW_LINE INDENT pw2 = 0 NEW_LINE pw5 = 0 NEW_LINE while ( arr [ p ] % 2 == 0 ) : NEW_LINE INDENT pw2 += 1 NEW_LINE arr [ p ] /= 2 NEW_LINE DEDENT while ( arr [ p ] % 5 == 0 ) : NEW_LINE INDENT pw5 += 1 NEW_LINE arr [ p ] /= 5 NEW_LINE DEDENT for i in range ( k - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( MAX5 ) : NEW_LINE INDENT if ( subset [ i ] [ j ] != - 1 ) : NEW_LINE INDENT subset [ i + 1 ] [ j + pw5 ] = max ( subset [ i + 1 ] [ j + pw5 ] , subset [ i ] [ j ] + pw2 ) NEW_LINE DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( MAX5 ) : NEW_LINE INDENT ans = max ( ans , min ( i , subset [ k ] [ i ] ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def largestSubset ( a , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE dp = [ 0 for x in range ( n ) ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT mxm = 0 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if a [ j ] % a [ i ] == 0 : NEW_LINE INDENT mxm = max ( mxm , dp [ j ] ) NEW_LINE DEDENT DEDENT dp [ i ] = 1 + mxm NEW_LINE DEDENT return max ( dp ) . max ( ) NEW_LINE DEDENT
def encodedChar ( str , k ) : NEW_LINE INDENT expand = " " NEW_LINE temp = " " NEW_LINE freq = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT temp = " " NEW_LINE freq = 0 NEW_LINE while ( i < len ( str ) and str [ i ] >= ' a ' and str [ i ] <= ' z ' ) : NEW_LINE INDENT temp += str [ i ] NEW_LINE i += 1 NEW_LINE DEDENT while ( i < len ( str ) and str [ i ] >= '1' and str [ i ] <= '9' ) : NEW_LINE INDENT freq = freq * 10 + ord ( str [ i ] ) - ord ( '0' ) NEW_LINE i += 1 NEW_LINE DEDENT for j in range ( 1 , freq + 1 ) : NEW_LINE INDENT expand += temp NEW_LINE DEDENT DEDENT if ( freq == 0 ) : NEW_LINE INDENT expand += temp NEW_LINE DEDENT return expand [ k - 1 ] NEW_LINE DEDENT
def countNum ( arr , n ) : NEW_LINE INDENT s = Set ( ) NEW_LINE count = 0 NEW_LINE maxm = 10 ** 9 NEW_LINE minm = 10 ** 9 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . add ( arr [ i ] ) NEW_LINE if arr [ i ] < minm : NEW_LINE INDENT minm = arr [ i ] NEW_LINE DEDENT if arr [ i ] > maxm : NEW_LINE INDENT maxm = arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( minm , maxm + 1 ) : NEW_LINE INDENT if arr [ i ] not in s : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def countPairs ( arr , n ) : NEW_LINE INDENT hm = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if hm . get ( arr [ i ] ) : NEW_LINE INDENT hm [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT hm [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for it in hm : NEW_LINE INDENT count = it . getValue ( ) NEW_LINE ans += ( count * ( count - 1 ) ) // 2 NEW_LINE DEDENT return int ( ans ) NEW_LINE DEDENT
def maxDiff ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE arr . sort ( ) NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if arr [ i ] != arr [ i + 1 ] : NEW_LINE INDENT result += abs ( arr [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT if arr [ n - 2 ] != arr [ n - 1 ] : NEW_LINE INDENT result += abs ( arr [ n - 2 ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT
def middleOfThree ( a , b , c ) : NEW_LINE INDENT if ( ( a < b and b < c ) or ( c < b and b < a ) ) : NEW_LINE INDENT return b NEW_LINE DEDENT elif ( ( b < a and a < c ) or ( c < a and a < b ) ) : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return c NEW_LINE DEDENT DEDENT
def countarray ( n , k , x ) : NEW_LINE INDENT dp = [ 0 ] * 109 NEW_LINE dp [ 0 ] = 0 NEW_LINE dp [ 1 ] = 1 NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT dp [ i ] = ( k - 2 ) * dp [ i - 1 ] + ( k - 1 ) * dp [ i - 2 ] NEW_LINE DEDENT return ( x == 1 ? ( k - 1 ) * dp [ n - 2 ] : dp [ n - 1 ] ) NEW_LINE DEDENT
def nswp ( n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 2 * nswp ( n - 1 ) + nswp ( n - 2 ) NEW_LINE DEDENT
def fib ( n ) : NEW_LINE INDENT if lookup [ n ] == NIL : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT lookup [ n ] = n NEW_LINE DEDENT else : NEW_LINE INDENT lookup [ n ] = fib ( n - 1 ) + fib ( n - 2 ) NEW_LINE DEDENT DEDENT return lookup [ n ] NEW_LINE DEDENT
def countNums ( n , x , y ) : NEW_LINE INDENT arr = [ False for x in range ( n + 1 ) ] NEW_LINE if x <= n : NEW_LINE INDENT arr [ x ] = True NEW_LINE DEDENT if y <= n : NEW_LINE INDENT arr [ y ] = True NEW_LINE DEDENT result = 0 NEW_LINE for i in range ( min ( x , y ) + 1 ) : NEW_LINE INDENT if arr [ i ] == True : NEW_LINE INDENT arr [ i + x ] = True NEW_LINE DEDENT if i + y <= n : NEW_LINE INDENT arr [ i + y ] = True NEW_LINE DEDENT result += 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def countPS ( str1 ) : NEW_LINE INDENT N = len ( str1 ) NEW_LINE cps = [ [ 0 for i in range ( N + 1 ) ] for L in range ( N + 1 ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT cps [ i ] [ i ] = 1 NEW_LINE DEDENT for L in range ( 2 , N + 1 ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT k = L + i - 1 NEW_LINE if ( k < N ) : NEW_LINE INDENT if ( str1 [ i ] == str1 [ k ] ) : NEW_LINE INDENT cps [ i ] [ k ] = cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT cps [ i ] [ k ] = cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] - cps [ i + 1 ] [ k - 1 ] NEW_LINE DEDENT DEDENT DEDENT return cps [ 0 ] [ N - 1 ] NEW_LINE DEDENT
def decimalToBinary ( num , k_prec ) : NEW_LINE INDENT binary = " " NEW_LINE Integral = ( int ) num NEW_LINE fractional = num - Integral NEW_LINE while ( Integral > 0 ) : NEW_LINE INDENT rem = Integral % 2 NEW_LINE binary += ( chr ( rem + '0' ) ) NEW_LINE Integral /= 2 NEW_LINE DEDENT binary = reverse ( binary ) NEW_LINE binary = binary + ( ' . ' ) NEW_LINE while ( k_prec -- > 0 ) : NEW_LINE INDENT fractional = fractional * 2 NEW_LINE if ( fract_bit == 1 ) : NEW_LINE INDENT fractional -= fract_bit NEW_LINE binary += ( char ) ( 1 + '0' ) NEW_LINE DEDENT else : NEW_LINE INDENT binary += ( chr ( 0 + '0' ) NEW_LINE DEDENT DEDENT return binary NEW_LINE DEDENT
def countParenth ( symb , oper , n ) : NEW_LINE INDENT F = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] NEW_LINE T = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT F [ i ] [ i ] = ( symb [ i ] == ' F ' ) ? 1 : 0 NEW_LINE T [ i ] [ i ] = ( symb [ i ] == ' T ' ) ? 1 : 0 NEW_LINE DEDENT for gap in range ( 1 , n ) : NEW_LINE INDENT for i in range ( gap , n ) : NEW_LINE INDENT for j in range ( gap , n ) : NEW_LINE INDENT k = i + g NEW_LINE tik = T [ i ] [ k ] + F [ i ] [ k ] NEW_LINE tkj = T [ k + 1 ] [ j ] + F [ k + 1 ] [ j ] NEW_LINE if ( oper [ k ] == ' & ' ) : NEW_LINE INDENT T [ i ] [ j ] += T [ i ] [ k ] * T [ k + 1 ] [ j ] NEW_LINE F [ i ] [ j ] += ( tik * tkj - T [ i ] [ k ] * F [ k + 1 ] [ j ] ) NEW_LINE DEDENT if ( oper [ k ] == ' | ' ) : NEW_LINE INDENT F [ i ] [ j ] += F [ i ] [ k ] * F [ k + 1 ] [ j ] NEW_LINE T [ i ] [ j ] += T [ i ] [ k ] * F [ k + 1 ] [ j ] NEW_LINE T [ i ] [ j ] += ( tik * tkj - F [ i ] [ k ] * F [ k + 1 ] [ j ] ) NEW_LINE DEDENT if ( oper [ k ] == ' ^ ' ) : NEW_LINE INDENT T [ i ] [ j ] += F [ i ] [ k ] * T [ k + 1 ] [ j ] + T [ i ] [ k ] * F [ k + 1 ] [ j ] NEW_LINE F [ i ] [ j ] += T [ i ] [ k ] * F [ k + 1 ] [ j ] NEW_LINE DE
def countSetBits ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return ( n & 1 ) + countSetBits ( n > > 1 ) NEW_LINE DEDENT DEDENT
def longestCommonSum ( arr1 , arr2 , n ) : NEW_LINE INDENT maxLen = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum1 = 0 NEW_LINE sum2 = 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT sum1 += arr1 [ j ] NEW_LINE sum2 += arr2 [ j ] NEW_LINE if ( sum1 == sum2 ) : NEW_LINE INDENT maxLen = max ( maxLen , len ) NEW_LINE DEDENT DEDENT DEDENT return maxLen NEW_LINE DEDENT
def maxTripletSum ( arr , n ) : NEW_LINE INDENT sum = - 1000000 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in arr : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT if ( sum < arr [ i ] + arr [ j ] + arr [ k ] ) : NEW_LINE INDENT sum = arr [ i ] + arr [ j ] + arr [ k ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def evaluateBoolExpr ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT if ( i + 1 < n and i + 2 < n ) : NEW_LINE INDENT if ( s [ i ] == ' A ' ) : NEW_LINE INDENT if ( s [ i + 2 ] == '0' or s [ i ] == 0 ) : NEW_LINE INDENT s [ i + 2 ] = '0' NEW_LINE DEDENT else : NEW_LINE INDENT s [ i + 2 ] = '1' NEW_LINE DEDENT DEDENT elif ( ( i + 1 ) < n and s [ i + 1 ] == ' B ' ) : NEW_LINE INDENT if ( s [ i + 2 ] == '1' or s [ i ] == '1' ) : NEW_LINE INDENT s [ i + 2 ] = '1' NEW_LINE DEDENT else : NEW_LINE INDENT s [ i + 2 ] = '0' NEW_LINE DEDENT DEDENT i += 2 NEW_LINE DEDENT DEDENT return s [ n - 1 ] - '0' NEW_LINE DEDENT
def findNth ( n ) : NEW_LINE INDENT nthElement = 19 + ( n - 1 ) * 9 NEW_LINE outliersCount = ( int ) ( math . log10 ( nthElement ) - 1 ) NEW_LINE nthElement += 9 * outliersCount NEW_LINE return nthElement NEW_LINE DEDENT
def numofAP ( a , n ) : NEW_LINE INDENT minarr = + 2147483647 NEW_LINE maxarr = - 2147483648 NEW_LINE for i in range ( n ) : NEW_LINE INDENT minarr = min ( minarr , a [ i ] ) NEW_LINE maxarr = max ( maxarr , a [ i ] ) NEW_LINE DEDENT dp = [ 0 for i in range ( n ) ] NEW_LINE sum = [ 0 for i in range ( minarr - maxarr ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp [ i ] = 1 NEW_LINE if a [ i ] - d >= 1 and a [ i ] - d <= 1000000 : NEW_LINE INDENT dp [ i ] += sum [ a [ i ] - d ] NEW_LINE DEDENT ans += dp [ i ] - 1 NEW_LINE sum [ a [ i ] ] += dp [ i ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def countSol ( coeff , start , end , rhs ) : NEW_LINE INDENT if ( rhs == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT result = 0 NEW_LINE for i in range ( start , end + 1 ) : NEW_LINE INDENT if ( coeff [ i ] <= rhs ) : NEW_LINE INDENT result += countSol ( coeff , i , end , rhs - coeff [ i ] ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def minSwaps ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE arrpos = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT arrpos . append ( arr [ i ] , i ) NEW_LINE DEDENT arrpos . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( o1 . getKey ( ) > o2 . getKey ( ) ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT elif ( o1 . getKey ( ) == o2 . getKey ( ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT vis = [ False for i in range ( n ) : NEW_LINE INDENT if ( vis [ i ] or arrpos [ i ] . getValue ( ) == i ) : NEW_LINE INDENT continue NEW_LINE DEDENT cycle_size = 0 NEW_LINE j = i NEW_LINE while ( vis [ j ] == False ) : NEW_LINE INDENT vis [ j ] = True NEW_LINE j = arrpos [ j ] . getValue ( ) NEW_LINE cycle_size += 1 NEW_LINE DEDENT if ( cycle_size > 0 ) : NEW_LINE INDENT ans += ( cycle_size - 1 ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def spiralFill ( m , n , a ) : NEW_LINE INDENT val = 1 NEW_LINE k = 0 l = 0 NEW_LINE while ( k < m and l < n ) : NEW_LINE INDENT for i in range ( l , n ) : NEW_LINE INDENT a [ k ] [ i ] = val += NEW_LINE DEDENT k += 1 NEW_LINE for i in range ( k , m ) : NEW_LINE INDENT a [ i ] [ n - 1 ] = val += NEW_LINE DEDENT n -= 1 NEW_LINE if ( k < m ) : NEW_LINE INDENT for i in range ( n - 1 , l - 1 , - 1 ) : NEW_LINE INDENT a [ m - 1 ] [ i ] = val += NEW_LINE DEDENT m -= 1 NEW_LINE DEDENT if ( l < n ) : NEW_LINE INDENT for i in range ( m - 1 , k - 1 , - 1 ) : NEW_LINE INDENT a [ i ] [ l ] = val += NEW_LINE DEDENT l += 1 NEW_LINE DEDENT DEDENT DEDENT
def printClosest ( ar1 , ar2 , m , n , x ) : NEW_LINE INDENT diff = + 2147483647 NEW_LINE res_l = 0 NEW_LINE res_r = 0 NEW_LINE l = n - 1 NEW_LINE while ( l < m and r >= 0 ) : NEW_LINE INDENT if ( abs ( ar1 [ l ] + ar2 [ r ] - x ) < diff ) : NEW_LINE INDENT res_l = l NEW_LINE res_r = r NEW_LINE diff = abs ( ar1 [ l ] + ar2 [ r ] - x ) NEW_LINE DEDENT if ( ar1 [ l ] + ar2 [ r ] > x ) : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT l += 1 NEW_LINE DEDENT DEDENT print ( " The ▁ closest ▁ pair ▁ is [ " , ar1 [ res_l ] , " , ▁ " , ar2 [ res_r ] , " ] " ) NEW_LINE DEDENT
def minimumBox ( arr , n ) : NEW_LINE INDENT q = Queue ( ) NEW_LINE arr . sort ( ) NEW_LINE q . put ( arr [ 0 ] ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT now = q . element ( ) NEW_LINE if arr [ i ] >= 2 * now : NEW_LINE INDENT q . get ( ) NEW_LINE DEDENT q . put ( arr [ i ] ) NEW_LINE DEDENT return q . size ( ) NEW_LINE DEDENT
def findInteger ( arr , n ) : NEW_LINE INDENT hash = dict ( ) NEW_LINE maximum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] < 0 : NEW_LINE INDENT hash [ abs ( arr [ i ] ) ] = ( hash [ abs ( arr [ i ] ) ] == null ? 0 : hash [ abs ( arr [ i ] ) ] ) - 1 NEW_LINE DEDENT else : NEW_LINE INDENT hash [ abs ( arr [ i ] ) ] = ( hash [ abs ( arr [ i ] ) ] + 1 ) NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if hash [ arr [ i ] ] > 0 : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def convertOpposite ( str ) : NEW_LINE INDENT ln = len ( str ) NEW_LINE for i in range ( ln ) : NEW_LINE INDENT c = ord ( str [ i ] ) NEW_LINE if ( isUpperCase ( c ) ) : NEW_LINE INDENT str [ i , i + 1 ] = chr ( c . upper ( ) + " " ) NEW_LINE DEDENT else : NEW_LINE INDENT str [ i , i + 1 ] = chr ( lower ( c ) + " " ) NEW_LINE DEDENT DEDENT
def decimalToBinary ( N ) : NEW_LINE INDENT B_Number = 0 NEW_LINE cnt = 0 NEW_LINE while ( N != 0 ) : NEW_LINE INDENT rem = N % 2 NEW_LINE c = math . pow ( 10 , cnt ) NEW_LINE B_Number += rem * c NEW_LINE N /= 2 NEW_LINE cnt += 1 NEW_LINE DEDENT return B_Number NEW_LINE DEDENT
def findRepeating ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] in s : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT s . add ( arr [ i ] ) NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def transpose ( A ) : NEW_LINE INDENT for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT A [ i ] [ j ] , A [ j ] [ i ] = A [ j ] [ i ] , A [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT
def findConsecutive ( N ) : NEW_LINE INDENT start = 1 NEW_LINE end = ( N + 1 ) / 2 NEW_LINE while ( start < end ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( start , end + 1 ) : NEW_LINE INDENT sum = sum + i NEW_LINE if ( sum == N ) : NEW_LINE INDENT for j in range ( start , i + 1 ) : NEW_LINE INDENT print ( j , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT break NEW_LINE DEDENT if ( sum > N ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT sum = 0 NEW_LINE start += 1 NEW_LINE DEDENT DEDENT
def printSubsequences ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE opsize = ( int ) ( math . pow ( 2 , n - 1 ) ) NEW_LINE for counter in range ( 0 , opsize ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT print ( str [ j ] , end = " ▁ " ) NEW_LINE if ( ( counter & ( 1 << j ) ) > 0 ) : NEW_LINE INDENT print ( " ▁ " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT
def maxArea ( a , b , c , d ) : NEW_LINE INDENT semiperimeter = ( a + b + c + d ) / 2 NEW_LINE return math . sqrt ( ( semiperimeter - a ) * ( semiperimeter - b ) * ( semiperimeter - c ) * ( semiperimeter - d ) ) NEW_LINE DEDENT
def Right_most_setbit ( num ) : NEW_LINE INDENT pos = 1 NEW_LINE for i in range ( INT_SIZE ) : NEW_LINE INDENT if ( ( num & ( 1 << i ) ) == 0 ) : NEW_LINE INDENT pos += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return pos NEW_LINE DEDENT
def printRoman ( number ) : NEW_LINE INDENT c = [ 0 ] * 10001 NEW_LINE i = 0 NEW_LINE if ( number <= 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT while ( number != 0 ) : NEW_LINE INDENT if ( number >= 1000 ) : NEW_LINE INDENT i = digit ( ' M ' , number // 1000 , i , c ) NEW_LINE number = number % 1000 NEW_LINE DEDENT elif ( number >= 500 ) : NEW_LINE INDENT i = digit ( ' D ' , number // 500 , i , c ) NEW_LINE number = number % 500 NEW_LINE DEDENT else : NEW_LINE INDENT i = sub_digit ( ' C ' , ' M ' , i , c ) NEW_LINE number = number % 100 NEW_LINE DEDENT DEDENT elif ( number >= 100 ) : NEW_LINE INDENT if ( number < 400 ) : NEW_LINE INDENT i = digit ( ' C ' , number // 100 , i , c ) NEW_LINE number = number % 100 NEW_LINE DEDENT else : NEW_LINE INDENT i = sub_digit ( ' C ' , ' D ' , i , c ) NEW_LINE number = number % 100 NEW_LINE DEDENT DEDENT elif ( number >= 10 ) : NEW_LINE INDENT if ( number < 40 ) : NEW_LINE INDENT i = digit ( ' X ' , number // 10 , i , c ) NEW_LINE number = number % 10 NEW_LINE DEDENT else : NEW_LINE INDENT i = sub_digit ( ' X ' , ' L ' , i , c ) NEW_LINE number = number % 10 NEW_LINE DEDENT DEDENT elif ( number >= 1 ) : NEW_LINE INDENT if ( number < 4 ) : NEW_LINE INDENT i = digit ( ' I ' , number , i , c ) NEW_LINE number = 0 NEW_LINE DEDENT else : NEW_LINE INDENT i = sub_digit ( ' I ' , ' V ' , i , c ) NEW_LINE number = 0 NEW_LINE DEDENT DEDENT DEDENT
def isSubsetSum ( set , n , sum ) : NEW_LINE INDENT if ( sum == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n == 0 and sum != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( set [ n - 1 ] > sum ) : NEW_LINE INDENT return isSubsetSum ( set , n - 1 , sum ) NEW_LINE DEDENT return isSubsetSum ( set , n - 1 , sum ) or isSubsetSum ( set , n - 1 , sum - set [ n - 1 ] ) NEW_LINE DEDENT
def countDigits ( a , b ) : NEW_LINE INDENT if ( a == 0 or b == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return ( math . floor ( math . log10 ( abs ( a ) ) + math . log10 ( abs ( b ) ) ) + 1 NEW_LINE DEDENT
def countWays ( n ) : NEW_LINE INDENT table = [ 0 for i in range ( n + 1 ) ] NEW_LINE table [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( i , n + 1 ) : NEW_LINE INDENT table [ j ] = table [ j - i ] + table [ j - n ] NEW_LINE DEDENT DEDENT return table [ n ] NEW_LINE DEDENT
def twoWaySort ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] & 1 ) != 0 : NEW_LINE INDENT arr [ i ] = - 1 NEW_LINE DEDENT DEDENT arr . sort ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] & 1 ) != 0 : NEW_LINE INDENT arr [ i ] = - 1 NEW_LINE DEDENT DEDENT
def PowerOFPINnfactorial ( n , p ) : NEW_LINE INDENT ans = 0 NEW_LINE temp = p NEW_LINE while ( temp <= n ) : NEW_LINE INDENT ans += n / temp NEW_LINE temp = temp * p NEW_LINE DEDENT return ans NEW_LINE DEDENT
def findMaxValue ( N , mat ) : NEW_LINE INDENT maxValue = - float ( ' inf ' ) NEW_LINE for a in range ( 0 , N - 1 ) : NEW_LINE INDENT for b in range ( 0 , N - 1 ) : NEW_LINE INDENT for d in range ( a + 1 , N ) : NEW_LINE INDENT for e in range ( b + 1 , N ) : NEW_LINE INDENT if ( maxValue < ( mat [ d ] [ e ] - mat [ a ] [ b ] ) ) : NEW_LINE INDENT maxValue = mat [ d ] [ e ] - mat [ a ] [ b ] NEW_LINE DEDENT DEDENT DEDENT return maxValue NEW_LINE DEDENT
def findTriplet ( a1 , a2 , a3 , n1 , n2 , n3 , sum ) : NEW_LINE INDENT s = [ ] NEW_LINE for i in range ( n1 ) : NEW_LINE INDENT s . append ( a1 [ i ] ) NEW_LINE DEDENT for i in range ( n2 ) : NEW_LINE INDENT for j in range ( n3 ) : NEW_LINE INDENT if ( al . contains ( sum - a2 [ i ] - a3 [ j ] ) and al . indexOf ( sum - a2 [ i ] - a3 [ j ] ) != al [ len ( al ) - 1 ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT
def getOddOccurrence ( arr , arr_size ) : NEW_LINE INDENT i = 0 NEW_LINE for i in range ( 0 , arr_size ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( 0 , arr_size ) : NEW_LINE INDENT if ( arr [ i ] == arr [ j ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( count % 2 != 0 ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def factorize ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( not ( n % 2 > 0 ) ) : NEW_LINE INDENT n >>= 1 NEW_LINE count += 1 NEW_LINE DEDENT if ( count > 0 ) : NEW_LINE INDENT print ( "2" , " ▁ " , count ) NEW_LINE DEDENT for i in range ( 3 , int ( math . sqrt ( n ) + 2 ) ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n % i == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE n = n / i NEW_LINE DEDENT if ( count > 0 ) : NEW_LINE INDENT print ( i , " ▁ " , count ) NEW_LINE DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT print ( n , " ▁ " , "1" ) NEW_LINE DEDENT DEDENT
def findSmallestDifference ( A , B , m , n ) : NEW_LINE INDENT A . sort ( ) NEW_LINE B . sort ( ) NEW_LINE a = 0 b = 0 NEW_LINE result = + 2147483647 NEW_LINE while ( a < m and b < n ) : NEW_LINE INDENT if ( abs ( A [ a ] - B [ b ] ) < result ) : NEW_LINE INDENT result = abs ( A [ a ] - B [ b ] ) NEW_LINE DEDENT if ( A [ a ] < B [ b ] ) : NEW_LINE INDENT a += 1 NEW_LINE DEDENT else : NEW_LINE INDENT b += 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def check ( s ) : NEW_LINE INDENT if ( len ( s ) >= 10 ) : NEW_LINE INDENT return True NEW_LINE DEDENT for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT for j in range ( i + 1 , len ( s ) ) : NEW_LINE INDENT for k in range ( j + 1 , len ( s ) ) : NEW_LINE INDENT s1 = " " NEW_LINE s2 = " " NEW_LINE s3 = " " NEW_LINE s4 = " " NEW_LINE try : NEW_LINE INDENT s1 = s [ 0 : i ] NEW_LINE s2 = s [ i : j - i ] NEW_LINE s3 = s [ j : k - j ] NEW_LINE s4 = s [ k : len ( s ) - k ] NEW_LINE DEDENT except ( StringIndexOutOfBoundsException ) : NEW_LINE INDENT } NEW_LINE INDENT if ( strcheck ( s1 , s2 ) and strcheck ( s1 , s3 ) and strcheck ( s1 , s4 ) and strcheck ( s2 , s3 ) and strcheck ( s2 , s4 ) and strcheck ( s3 , s4 ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT
def isPath ( arr ) : NEW_LINE INDENT arr [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , 5 ) : NEW_LINE INDENT if arr [ 0 ] [ i ] != - 1 : NEW_LINE INDENT arr [ 0 ] [ i ] = arr [ 0 ] [ i - 1 ] NEW_LINE DEDENT for j in range ( 1 , 5 ) : NEW_LINE INDENT if arr [ j ] [ 0 ] != - 1 : NEW_LINE INDENT arr [ j ] [ 0 ] = arr [ j - 1 ] [ 0 ] NEW_LINE DEDENT DEDENT for i in range ( 1 , 5 ) : NEW_LINE INDENT for j in range ( 1 , 5 ) : NEW_LINE INDENT if arr [ i ] [ j ] != - 1 : NEW_LINE INDENT arr [ i ] [ j ] = max ( arr [ i ] [ j - 1 ] , arr [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return ( arr [ 5 - 1 ] [ 5 - 1 ] == 1 ) NEW_LINE DEDENT
def bitonicGenerator ( arr , n ) : NEW_LINE INDENT i = 1 NEW_LINE j = n - 1 NEW_LINE if ( j % 2 != 0 ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT while ( i < j ) : NEW_LINE INDENT arr = swap ( arr , i , j ) NEW_LINE i += 2 NEW_LINE j -= 2 NEW_LINE DEDENT arr . sort ( 0 , ( n + 1 ) / 2 ) NEW_LINE arr . sort ( ) NEW_LINE low = 0 NEW_LINE high = n - 1 NEW_LINE while ( low < high ) : NEW_LINE INDENT arr [ low ] , arr [ high ] = arr [ high ] , arr [ low ] NEW_LINE low += 1 NEW_LINE high -= 1 NEW_LINE DEDENT DEDENT
def solve ( dp , a , low , high , turn ) : NEW_LINE INDENT if low == high : NEW_LINE INDENT return a [ low ] * turn NEW_LINE DEDENT if dp [ low ] [ high ] != 0 : NEW_LINE INDENT return dp [ low ] [ high ] NEW_LINE DEDENT dp [ low ] [ high ] = max ( a [ low ] * turn + solve ( dp , a , low + 1 , high , turn + 1 ) , a [ high ] * turn + solve ( dp , a , low , high - 1 , turn + 1 ) ) NEW_LINE return dp [ low ] [ high ] NEW_LINE DEDENT
def direction ( R , C ) : NEW_LINE INDENT if ( R != C and R % 2 == 0 and C % 2 != 0 and R < C ) : NEW_LINE INDENT print ( " Left " ) NEW_LINE return NEW_LINE DEDENT if ( R != C and R % 2 != 0 and C % 2 != 0 and R > C ) : NEW_LINE INDENT print ( " Up " ) NEW_LINE return NEW_LINE DEDENT if ( R == C and R % 2 != 0 and C % 2 != 0 ) : NEW_LINE INDENT print ( " Right " ) NEW_LINE return NEW_LINE DEDENT if ( R == C and R % 2 != 0 and C % 2 != 0 and R < C ) : NEW_LINE INDENT print ( " Left " ) NEW_LINE return NEW_LINE DEDENT if ( R != C and R % 2 != 0 and C % 2 != 0 and R > C ) : NEW_LINE INDENT print ( " Down " ) NEW_LINE return NEW_LINE DEDENT if ( R != C and R % 2 == 0 and C % 2 == 0 and R < C ) : NEW_LINE INDENT print ( " Left " ) NEW_LINE return NEW_LINE DEDENT if ( R != C and R % 2 == 0 and C % 2 == 0 and R > C ) : NEW_LINE INDENT print ( " Up " ) NEW_LINE return NEW_LINE DEDENT if ( R != C and R % 2 == 0 and C % 2 != 0 and R > C ) : NEW_LINE INDENT print ( " Down " ) NEW_LINE return NEW_LINE DEDENT if ( R != C and R % 2 != 0 and C % 2 != 0 and R < C ) : NEW_LINE INDENT print ( " Right " ) NEW_LINE return NEW_LINE DEDENT DEDENT
def splitString ( str ) : NEW_LINE INDENT alpha = [ ] NEW_LINE num = [ ] NEW_LINE special = [ ] NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( isDigit ( str [ i ] ) ) : NEW_LINE INDENT num . append ( str [ i ] ) NEW_LINE DEDENT elif ( isAlphabetic ( str [ i ] ) ) : NEW_LINE INDENT alpha . append ( str [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT special . append ( str [ i ] ) NEW_LINE DEDENT DEDENT print ( alpha , num , special ) NEW_LINE DEDENT
def binaryMedian ( m , r , c ) : NEW_LINE INDENT max = - float ( ' inf ' ) NEW_LINE min = + float ( ' inf ' ) NEW_LINE for i in range ( r ) : NEW_LINE INDENT if ( m [ i ] [ 0 ] < min ) : NEW_LINE INDENT min = m [ i ] [ 0 ] NEW_LINE DEDENT if ( m [ i ] [ c - 1 ] > max ) : NEW_LINE INDENT max = m [ i ] [ c - 1 ] NEW_LINE DEDENT DEDENT desired = ( r * c + 1 ) // 2 NEW_LINE while ( min < max ) : NEW_LINE INDENT mid = min + ( max - min ) // 2 NEW_LINE if ( get < 0 ) : NEW_LINE INDENT get = abs ( get ) - 1 NEW_LINE DEDENT else : NEW_LINE INDENT while ( get < len ( m [ i ] ) and m [ i ] [ get ] == mid ) : NEW_LINE INDENT get += 1 NEW_LINE DEDENT place = place + get NEW_LINE DEDENT if ( place < desired ) : NEW_LINE INDENT min = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT max = mid NEW_LINE DEDENT DEDENT return min NEW_LINE DEDENT
def printDuplicates ( arr , n ) : NEW_LINE INDENT map = dict ( ) NEW_LINE count = 0 NEW_LINE dup = False NEW_LINE for i in range ( n ) : NEW_LINE INDENT if map . get ( arr [ i ] ) : NEW_LINE INDENT count = map [ arr [ i ] ] NEW_LINE map [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT map [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT for entry in map : NEW_LINE INDENT if entry . getValue ( ) > 1 : NEW_LINE INDENT print ( entry . getKey ( ) , end = " ▁ " ) NEW_LINE dup = True NEW_LINE DEDENT DEDENT if ( dup ) : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT DEDENT
def fib ( n ) : NEW_LINE INDENT a = 0 NEW_LINE b = 1 NEW_LINE c = a + b NEW_LINE if ( n >= 0 ) : NEW_LINE INDENT print ( a , end = " ▁ " ) NEW_LINE DEDENT if ( n >= 1 ) : NEW_LINE INDENT print ( b , end = " ▁ " ) NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT c = a + b NEW_LINE print ( c , end = " ▁ " ) NEW_LINE a = b NEW_LINE b = c NEW_LINE DEDENT DEDENT
def swapNibbles ( x ) : NEW_LINE INDENT return ( ( x & 0x0F ) << 4 | ( x & 0xF0 ) > > 4 ) NEW_LINE DEDENT
def countPS ( i , j ) : NEW_LINE INDENT if ( i >= n or j < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ i ] [ j ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ j ] NEW_LINE DEDENT if ( ( i - j == 1 ) or ( i - j == - 1 ) ) : NEW_LINE INDENT if ( str [ i ] == str [ j ] ) : NEW_LINE INDENT return dp [ i ] [ j ] = 3 NEW_LINE DEDENT else : NEW_LINE INDENT return dp [ i ] [ j ] = 2 NEW_LINE DEDENT DEDENT if ( i == j ) : NEW_LINE INDENT return dp [ 1 ] [ j ] = 1 NEW_LINE DEDENT elif ( str [ i ] == str [ j ] ) : NEW_LINE INDENT return dp [ i ] [ j ] = countPS ( i + 1 , j ) + countPS ( i , j - 1 ) + 1 NEW_LINE DEDENT else : NEW_LINE INDENT return dp [ i ] [ j ] = countPS ( i + 1 , j ) + countPS ( i , j - 1 ) - countPS ( i + 1 , j - 1 ) NEW_LINE DEDENT DEDENT
def divisorSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += ( n // i ) * i NEW_LINE DEDENT return sum NEW_LINE DEDENT
def addOne ( x ) : NEW_LINE INDENT m = 1 NEW_LINE while ( not ( x & m ) ) : NEW_LINE INDENT x = x ^ m NEW_LINE m <<= 1 NEW_LINE DEDENT x = x ^ m NEW_LINE return x NEW_LINE DEDENT
def check ( string ) : NEW_LINE INDENT n = len ( string ) NEW_LINE digitSum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT digitSum += ord ( string [ i ] ) - ord ( '0' ) ; NEW_LINE DEDENT return ( digitSum % 9 == 0 ) NEW_LINE DEDENT
def findMaxGCD ( arr , n ) : NEW_LINE INDENT high = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT high = max ( high , arr [ i ] ) NEW_LINE DEDENT divisors = [ 0 for i in range ( high + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( 1 , int ( m . sqrt ( arr [ i ] ) + 1 ) ) : NEW_LINE INDENT if arr [ i ] % j == 0 : NEW_LINE INDENT divisors [ j ] += 1 NEW_LINE if j != arr [ i ] / j : NEW_LINE INDENT divisors [ arr [ i ] / j ] += 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( high , - 1 , - 1 ) : NEW_LINE INDENT if divisors [ i ] > 1 ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT
def minRemove ( arr , n ) : NEW_LINE INDENT LIS = [ 0 ] * n NEW_LINE len = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT LIS [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and ( i - j ) <= ( arr [ i ] - arr [ j ] ) ) : NEW_LINE INDENT LIS [ i ] = max ( LIS [ i ] , LIS [ j ] + 1 ) NEW_LINE DEDENT DEDENT len = max ( len , LIS [ i ] ) NEW_LINE DEDENT return n - len NEW_LINE DEDENT
def computeLPSArray ( pat , M , lps ) : NEW_LINE INDENT len = 0 NEW_LINE i = 1 NEW_LINE while i < M : NEW_LINE INDENT if ( pat [ i ] == pat [ len ] ) : NEW_LINE INDENT len += 1 NEW_LINE lps [ i ] = len NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( len != 0 ) : NEW_LINE INDENT len = lps [ len - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT lps [ i ] = len NEW_LINE i += 1 NEW_LINE DEDENT DEDENT DEDENT
def numofsubset ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE count = 1 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( arr [ i ] + 1 != arr [ i + 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def stoogesort ( arr , l , h ) : NEW_LINE INDENT if l >= h : NEW_LINE INDENT return NEW_LINE DEDENT if arr [ l ] > arr [ h ] : NEW_LINE INDENT t = arr [ l ] NEW_LINE arr [ l ] = arr [ h ] NEW_LINE arr [ h ] = t NEW_LINE DEDENT if ( h - l + 1 > 2 ) : NEW_LINE INDENT t = ( h - l + 1 ) // 3 NEW_LINE stoogesort ( arr , l , h - t ) NEW_LINE stoogesort ( arr , l + t , h ) NEW_LINE stoogesort ( arr , l , h - t ) NEW_LINE DEDENT DEDENT
def solve ( n , t , s ) : NEW_LINE INDENT for i in range ( t ) : NEW_LINE INDENT for j in range ( n - 1 ) : NEW_LINE INDENT if ( s [ j ] == ' B ' and s [ j + 1 ] == ' G ' ) : NEW_LINE INDENT s [ j ] , s [ j + 1 ] = s [ j + 1 ] , s [ j ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT print ( s ) NEW_LINE DEDENT
def turnOffK ( n , k ) : NEW_LINE INDENT if ( k <= 0 ) : return n NEW_LINE DEDENT return ( n & ~ ( 1 << ( k - 1 ) ) ) NEW_LINE DEDENT
def printEqualModNumbers ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE d = arr [ n - 1 ] - arr [ 0 ] NEW_LINE v = [ 0 ] * ( n - 1 ) NEW_LINE for i in range ( 1 , d + 1 ) : NEW_LINE INDENT if ( d % i == 0 ) : NEW_LINE INDENT v . append ( i ) NEW_LINE if ( i != d // i ) : NEW_LINE INDENT v . append ( d // i ) NEW_LINE DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT temp = arr [ 0 ] % v [ i ] NEW_LINE j = 1 NEW_LINE while ( j < n ) : NEW_LINE INDENT if ( arr [ j ] % v [ i ] != temp ) : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if ( j == n ) : NEW_LINE INDENT print ( v [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
def findMaximum ( arr , low , high ) : NEW_LINE INDENT if low == high : NEW_LINE INDENT return arr [ low ] NEW_LINE DEDENT if ( high == low + 1 ) and arr [ low ] >= arr [ high ] ) : NEW_LINE INDENT return arr [ low ] NEW_LINE DEDENT if ( ( high == low + 1 ) and arr [ low ] < arr [ high ] ) : NEW_LINE INDENT return arr [ high ] NEW_LINE DEDENT mid = low + ( high - 1 ) // 2 NEW_LINE if arr [ mid ] > arr [ mid + 1 ] and arr [ mid ] > arr [ mid - 1 ] : NEW_LINE INDENT return arr [ mid ] NEW_LINE DEDENT if ( arr [ mid ] > arr [ mid + 1 ] and arr [ mid ] < arr [ mid - 1 ] ) : NEW_LINE INDENT return findMaximum ( arr , low , mid - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return findMaximum ( arr , mid + 1 , high ) NEW_LINE DEDENT DEDENT
def stringReduction ( Str ) : NEW_LINE INDENT n = len ( Str ) NEW_LINE count = [ 0 for i in range ( 3 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT count [ ord ( Str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT if ( count [ 0 ] == n or count [ 1 ] == n or count [ 2 ] == n ) : NEW_LINE INDENT return n NEW_LINE DEDENT if ( ( count [ 0 ] % 2 ) == ( count [ 1 ] % 2 ) and ( count [ 2 ] % 2 ) == ( count [ 2 ] % 2 ) ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT
def KnapSack ( val , wt , n , W ) : NEW_LINE INDENT dp = [ 0 for _ in range ( W + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( W ) : NEW_LINE INDENT dp [ j ] = max ( dp [ j ] , val [ i ] + dp [ j - wt [ i ] ] ) NEW_LINE DEDENT DEDENT return dp [ W ] NEW_LINE DEDENT
def findSum ( n ) : NEW_LINE INDENT multiTerms = n * ( n + 1 ) / 2 NEW_LINE sum = multiTerms NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT multiTerms = multiTerms - ( i - 1 ) NEW_LINE sum = sum + multiTerms * i NEW_LINE DEDENT return sum NEW_LINE DEDENT
def recursiveReverse ( str ) : NEW_LINE INDENT st = [ ] NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT st . append ( str [ i ] ) NEW_LINE DEDENT for i in range ( len ( st ) ) : NEW_LINE INDENT str [ i ] = st [ - 1 ] NEW_LINE st . pop ( ) NEW_LINE DEDENT return ' ' . join ( st ) NEW_LINE DEDENT
def subArraySum ( arr , n , Sum ) : NEW_LINE INDENT curr_sum = 0 NEW_LINE i = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT curr_sum = arr [ i ] NEW_LINE j = i + 1 NEW_LINE while ( j <= n ) : NEW_LINE INDENT if ( curr_sum == Sum ) : NEW_LINE INDENT p = j - 1 NEW_LINE print ( " Sum ▁ found ▁ between ▁ indexes ▁ " , i , " ▁ and " , p ) NEW_LINE return 1 NEW_LINE DEDENT if ( curr_sum > Sum or j == n ) : NEW_LINE INDENT break NEW_LINE DEDENT curr_sum = curr_sum + arr [ j ] NEW_LINE DEDENT DEDENT print ( " No ▁ subarray ▁ found " ) NEW_LINE return 0 NEW_LINE DEDENT
def getSingle ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 0 , INT_SIZE ) : NEW_LINE INDENT sum = 0 NEW_LINE x = ( 1 << i ) NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT if ( ( arr [ j ] & x ) == 0 ) : NEW_LINE INDENT sum += 1 NEW_LINE DEDENT DEDENT if ( ( sum % 3 ) == 0 ) : NEW_LINE INDENT result = result | x NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def getModulo ( n , d ) : NEW_LINE INDENT return ( n & ( d - 1 ) ) NEW_LINE DEDENT
def allCharactersSame ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( s [ i ] != s [ 0 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def maxDecimalValue ( mat , i , j , p ) : NEW_LINE INDENT if i >= N or j >= N : NEW_LINE INDENT return 0 NEW_LINE DEDENT result = max ( maxDecimalValue ( mat , i , j + 1 , p + 1 ) , maxDecimalValue ( mat , i + 1 , j , p + 1 ) ) NEW_LINE if ( mat [ i ] [ j ] == 1 ) : NEW_LINE INDENT return ( pow ( 2 , p ) + result ) NEW_LINE DEDENT else : NEW_LINE INDENT return result NEW_LINE DEDENT DEDENT
def countBT ( h ) : NEW_LINE INDENT dp = [ 0 for _ in range ( h + 1 ) ] NEW_LINE dp [ 0 ] = 1 NEW_LINE dp [ 1 ] = 1 NEW_LINE for i in range ( 2 , h + 1 ) : NEW_LINE INDENT dp [ i ] = ( dp [ i - 1 ] * ( ( 2 * dp [ i - 2 ] ) % MOD + dp [ i - 1 ] ) % MOD ) % MOD NEW_LINE DEDENT return dp [ h ] NEW_LINE DEDENT
def getInvCount ( arr , n ) : NEW_LINE INDENT inv_count = 0 NEW_LINE for i in arr : NEW_LINE INDENT for j in arr : NEW_LINE INDENT if i > j : NEW_LINE INDENT inv_count += 1 NEW_LINE DEDENT DEDENT DEDENT return inv_count NEW_LINE DEDENT
def printRect ( X , Y , n ) : NEW_LINE INDENT Xmax = max ( Arrays . asList ( X ) ) NEW_LINE Xmin = min ( Arrays . asList ( X ) ) NEW_LINE Ymax = max ( Arrays . asList ( Y ) ) NEW_LINE Ymin = min ( Arrays . asList ( Y ) ) NEW_LINE print ( " { " , Xmin , " , ▁ " , Ymin , " } " ) NEW_LINE print ( " { " , Xmax , " , ▁ " , Ymax ) NEW_LINE print ( " { " , Xmin , " , ▁ " , Ymin , " } " ) NEW_LINE print ( " { " , Xmax , " , ▁ " , Ymax , " } " ) NEW_LINE print ( " { " , Xmax , " , ▁ " , Ymin , " } " ) NEW_LINE DEDENT
def dealnnoy ( n , m ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( m + 1 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = 1 NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] + dp [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT return dp [ m ] [ n ] NEW_LINE DEDENT
def power ( x , y , p ) : NEW_LINE INDENT res = 1 NEW_LINE x = x % p NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( ( y & 1 ) == 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT y = int ( y > > 1 ) NEW_LINE x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT
def isValidISBN ( isbn ) : NEW_LINE INDENT n = len ( isbn ) NEW_LINE if ( n != 10 ) : NEW_LINE INDENT return False NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( 0 , 9 ) : NEW_LINE INDENT digit = ord ( isbn [ i ] ) - ord ( '0' ) ; NEW_LINE if ( 0 > digit or 9 < digit ) : NEW_LINE INDENT return False NEW_LINE DEDENT sum += ( digit * ( 10 - i ) ) NEW_LINE DEDENT last = isbn [ 9 ] NEW_LINE if ( last != ' X ' and ( last < '0' or last > '9' ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT sum += ( ( last == ' X ' ) ? 10 : ( last - ord ( '0' ) ) NEW_LINE DEDENT return ( sum % 11 == 0 ) NEW_LINE DEDENT
def NFG ( a , n , freq ) : NEW_LINE INDENT s = [ 0 ] * n NEW_LINE res = [ 0 ] * n NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( freq [ a [ s . queue ] ] > freq [ a [ i ] ] ) : NEW_LINE INDENT s . append ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT while ( freq [ a [ s . queue ] ] < freq [ a [ i ] ] and len ( s ) > 0 ) : NEW_LINE INDENT res [ s [ - 1 ] ] = a [ i ] NEW_LINE s . pop ( ) NEW_LINE DEDENT DEDENT while ( len ( s ) > 0 ) : NEW_LINE INDENT res [ s . queue ] = - 1 NEW_LINE s . pop ( ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( res [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def swapBits ( x , p1 , p2 , n ) : NEW_LINE INDENT set1 = ( x > > p1 ) & ( ( 1 << n ) - 1 ) NEW_LINE set2 = ( x > > p2 ) & ( ( 1 << n ) - 1 ) NEW_LINE xor = ( set1 ^ set2 ) NEW_LINE xor = ( xor << p1 ) | ( xor << p2 ) NEW_LINE result = x ^ xor NEW_LINE return result NEW_LINE DEDENT
def printEqualSumSets ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT if ( sum & 1 ) == 1 : NEW_LINE INDENT print ( " - 1 " ) NEW_LINE return NEW_LINE DEDENT k = sum > > 1 NEW_LINE dp = [ [ False for i in range ( n + 1 ) ] for j in range ( k + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for currSum in range ( 1 , k + 1 ) : NEW_LINE INDENT dp [ i ] [ currSum ] = dp [ i - 1 ] [ currSum ] NEW_LINE if ( arr [ i - 1 ] <= currSum ) : NEW_LINE INDENT dp [ i ] [ currSum ] = dp [ i ] [ currSum ] | dp [ i - 1 ] [ currSum - arr [ i - 1 ] ] NEW_LINE DEDENT DEDENT i = n NEW_LINE currSum = k NEW_LINE while ( i > 0 and currSum >= 0 ) : NEW_LINE INDENT if ( dp [ i - 1 ] [ currSum ] ) : NEW_LINE INDENT i -= 1 NEW_LINE currSum -= arr [ i ] NEW_LINE set2 . append ( arr [ i ] ) NEW_LINE DEDENT elif ( dp [ i - 1 ] [ currSum - arr [ i - 1 ] ] ) : NEW_LINE INDENT i -= 1 NEW_LINE currSum -= arr [ i ] NEW_LINE DEDENT DEDENT print ( " Set ▁ 1 ▁ elements : ▁ " ) NEW_LINE for i in range ( len ( set1 ) ) : NEW_LINE INDENT print ( set1 [ i ] , end = " ▁ " ) NEW_LINE DEDENT print ( " Set ▁ 2 ▁ elements : ▁ " ) NEW_LINE for i in range ( len ( set2 ) ) : NEW_LINE INDENT print ( set2 [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def power ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT return 2 * power ( n - 1 ) NEW_LINE DEDENT
def findElements ( arr , n ) : NEW_LINE INDENT first = - float ( ' inf ' ) NEW_LINE second = + float ( ' inf ' ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if arr [ i ] > first : NEW_LINE INDENT second = first NEW_LINE first = arr [ i ] NEW_LINE DEDENT elif arr [ i ] > second : NEW_LINE INDENT second = arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if arr [ i ] < second : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
def lastPosition ( n , m , k ) : NEW_LINE INDENT if ( m <= n - k + 1 ) : NEW_LINE INDENT return m + k - 1 NEW_LINE DEDENT m = m - ( n - k + 1 ) NEW_LINE return ( m % n == 0 ) ? n : ( m % n ) NEW_LINE DEDENT
def reverseStr ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE ch = str . toCharArray ( ) NEW_LINE j = n - 1 NEW_LINE for i in range ( j ) : NEW_LINE INDENT ch [ i ] , ch [ j ] = ch [ j ] , ch [ i ] NEW_LINE j -= 1 NEW_LINE DEDENT print ( ch ) NEW_LINE DEDENT
def findMaximum ( arr , low , high ) : NEW_LINE INDENT max = arr [ low ] NEW_LINE i = low NEW_LINE for i in range ( high + 1 ) : NEW_LINE INDENT if arr [ i ] > max : NEW_LINE INDENT max = arr [ i ] NEW_LINE DEDENT DEDENT return max NEW_LINE DEDENT
def longestPrefixSuffix ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE lps = [ 0 for i in range ( n ) ] NEW_LINE lps [ 0 ] = 0 NEW_LINE len = 0 NEW_LINE i = 1 NEW_LINE while i < n : NEW_LINE INDENT if ( s [ i ] == s [ len ] ) : NEW_LINE INDENT len += 1 NEW_LINE lps [ i ] = len NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( len != 0 ) : NEW_LINE INDENT len = lps [ len - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT lps [ i ] = 0 NEW_LINE i += 1 NEW_LINE DEDENT DEDENT res = lps [ n - 1 ] NEW_LINE return ( res > n // 2 ) ? n // 2 : res NEW_LINE DEDENT
def MaxTotalRectangleArea ( a , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE sum = 0 NEW_LINE flag = False NEW_LINE len = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( ( a [ i ] == a [ i + 1 ] or a [ i ] - a [ i + 1 ] == 1 ) and not flag ) : NEW_LINE INDENT flag = True NEW_LINE len = a [ i + 1 ] NEW_LINE i += 1 NEW_LINE DEDENT elif ( ( a [ i ] == a [ i + 1 ] or a [ i ] - a [ i + 1 ] == 1 ) and ( flag ) : NEW_LINE INDENT sum = sum + a [ i + 1 ] * len NEW_LINE flag = False NEW_LINE i += 1 NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def printFibonacciNumbers ( n ) : NEW_LINE INDENT f1 = 0 NEW_LINE f2 = 1 NEW_LINE if n < 1 : NEW_LINE INDENT return NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( f2 , end = " ▁ " ) NEW_LINE f1 = f2 NEW_LINE f2 = next NEW_LINE DEDENT DEDENT
def minimizeWithKSwaps ( arr , n , k ) : NEW_LINE INDENT global arr NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( k > 0 ) : NEW_LINE INDENT pos = i NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( j - i > k ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( arr [ j ] < arr [ pos ] ) : NEW_LINE INDENT pos = j NEW_LINE DEDENT DEDENT temp = arr [ j ] NEW_LINE arr [ j ] , arr [ j - 1 ] = arr [ j - 1 ] , arr [ j - 1 ] NEW_LINE arr [ j - 1 ] = arr [ j - 1 ] , arr [ j - 1 ] NEW_LINE j -= 1 NEW_LINE DEDENT k -= pos - i NEW_LINE DEDENT DEDENT
def isHeap ( arr , i , n ) : NEW_LINE INDENT if i > ( n - 2 ) // 2 : NEW_LINE INDENT return True NEW_LINE DEDENT if arr [ i ] >= arr [ 2 * i + 1 ] and arr [ i ] >= arr [ 2 * i + 2 ] and isHeap ( arr , 2 * i + 1 , n ) and isHeap ( arr , 2 * i + 2 , n ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def findLength ( string , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT l = i + 1 NEW_LINE r = i + 1 NEW_LINE lsum = 0 NEW_LINE rsum = 0 NEW_LINE while ( r < n and l >= 0 ) : NEW_LINE INDENT lsum += ord ( string [ l ] ) - ord ( '0' ) NEW_LINE rsum += ord ( string [ r ] ) - ord ( '0' ) NEW_LINE if ( lsum == rsum ) : NEW_LINE INDENT ans = max ( ans , r - l + 1 ) NEW_LINE DEDENT l -= 1 NEW_LINE r += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def countSubarrays ( arr , n ) : NEW_LINE INDENT difference = 0 NEW_LINE ans = 0 NEW_LINE hash_positive = [ 0 for x in range ( n + 1 ) ] NEW_LINE hash_negative = [ 0 for y in range ( n + 1 ) ] NEW_LINE hash_positive [ 0 ] = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] & 1 ) == 1 : NEW_LINE INDENT difference += 1 NEW_LINE DEDENT else : NEW_LINE INDENT difference -= 1 NEW_LINE DEDENT if ( difference < 0 ) : NEW_LINE INDENT ans += hash_negative [ - difference ] NEW_LINE hash_negative [ - difference ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += hash_positive [ difference ] NEW_LINE hash_positive [ difference ] += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def knapSack ( W , wt , val , n ) : NEW_LINE INDENT K = [ [ 0 for i in range ( W + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for w in range ( W + 1 ) : NEW_LINE INDENT if ( i == 0 or w == 0 ) : NEW_LINE INDENT K [ i ] [ w ] = 0 NEW_LINE DEDENT elif ( wt [ i - 1 ] <= w ) : NEW_LINE INDENT K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) NEW_LINE DEDENT else : NEW_LINE INDENT K [ i ] [ w ] = K [ i - 1 ] [ w ] NEW_LINE DEDENT DEDENT DEDENT return K [ n ] [ W ] NEW_LINE DEDENT
def multiply ( A , B , C ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT C [ i ] [ j ] = A [ i ] [ j ] - B [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT
def maxDP ( n ) : NEW_LINE INDENT res = [ 0 for i in range ( n + 1 ) ] NEW_LINE res [ 0 ] = 0 NEW_LINE res [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT res [ i ] = max ( i , ( res [ i // 2 ] + res [ i // 3 ] + res [ i // 4 ] + res [ i // 5 ] ) ) NEW_LINE DEDENT return res [ n ] NEW_LINE DEDENT
def findDiff ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE count = 0 NEW_LINE max_count = 0 min_count = n NEW_LINE for i in range ( ( n - 1 ) ) : NEW_LINE INDENT if ( arr [ i ] == arr [ i + 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE continue NEW_LINE DEDENT else : NEW_LINE INDENT max_count = max ( max_count , count ) NEW_LINE min_count = min ( min_count , count ) NEW_LINE count = 0 NEW_LINE DEDENT DEDENT return ( max_count - min_count ) NEW_LINE DEDENT
def countSink ( n , m , edgeFrom , edgeTo ) : NEW_LINE INDENT mark = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT mark [ edgeFrom [ i ] ] = 1 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( mark [ i ] == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def countNegative ( M , n , m ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , m ) : NEW_LINE INDENT if ( M [ i ] [ j ] < 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def middleOfThree ( a , b , c ) : NEW_LINE INDENT if a > b : NEW_LINE INDENT if b > c : NEW_LINE INDENT return b NEW_LINE DEDENT elif a > c : NEW_LINE INDENT return c NEW_LINE DEDENT else : NEW_LINE INDENT if b > c : NEW_LINE INDENT return a NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if a > c : NEW_LINE INDENT return a NEW_LINE DEDENT DEDENT
def countOfSubstringWithKOnes ( s , K ) : NEW_LINE INDENT N = len ( s ) NEW_LINE res = 0 NEW_LINE countOfOne = 0 NEW_LINE freq = [ 0 for i in range ( N + 1 ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT countOfOne += ord ( s [ i ] ) - ord ( '0' ) ; NEW_LINE if ( countOfOne >= K ) : NEW_LINE INDENT res += freq [ countOfOne - K ] NEW_LINE DEDENT freq [ countOfOne ] += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def findPairs ( arr , n ) : NEW_LINE INDENT map = dict ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT Sum = arr [ i ] + arr [ j ] NEW_LINE if ( Sum not in map ) : NEW_LINE INDENT map [ Sum ] = new pair ( i , j ) NEW_LINE DEDENT else : NEW_LINE INDENT map [ Sum ] = map [ Sum ] NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT Sum = arr [ i ] + arr [ j ] NEW_LINE DEDENT if ( Sum in map ) : NEW_LINE INDENT print ( " ( " , arr [ Sum ] , ' , ▁ ' , arr [ p . second ] , ' ) ▁ and ▁ ( " , arr [ i ] , ' , ▁ ' , arr [ j ] ) " ) NEW_LINE return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT
def search ( arr , key ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] == key ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def check ( s1 , s2 ) : NEW_LINE INDENT n = len ( s1 ) NEW_LINE m = len ( s2 ) NEW_LINE dp = [ [ False for i in range ( m + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( m + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = False NEW_LINE DEDENT DEDENT dp [ 0 ] [ 0 ] = True NEW_LINE for i in range ( len ( s1 ) ) : NEW_LINE INDENT for j in range ( len ( s2 ) ) : NEW_LINE INDENT if ( dp [ i ] [ j ] ) : NEW_LINE INDENT if ( j < len ( s2 ) and ( s1 [ i ] == s2 [ j ] ) ) : NEW_LINE INDENT dp [ i + 1 ] [ j + 1 ] = True NEW_LINE DEDENT if ( not isUpperCase ( s1 [ i ] ) ) : NEW_LINE INDENT dp [ i + 1 ] [ j ] = True NEW_LINE DEDENT DEDENT DEDENT return ( dp [ n ] [ m ] ) NEW_LINE DEDENT
def binaryToDecimal ( n ) : NEW_LINE INDENT num = n NEW_LINE dec_value = 0 NEW_LINE base = 1 NEW_LINE len = len ( num ) NEW_LINE while i >= 0 : NEW_LINE INDENT if ( num [ i ] == '1' ) : NEW_LINE INDENT dec_value += base NEW_LINE base = base * 2 NEW_LINE DEDENT i = i - 1 NEW_LINE DEDENT return dec_value NEW_LINE DEDENT
def countWays ( n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( 2 ) ] NEW_LINE dp [ 0 ] [ 1 ] = 1 NEW_LINE dp [ 1 ] [ 1 ] = 2 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + dp [ 1 ] [ i - 1 ] NEW_LINE dp [ 1 ] [ i ] = dp [ 0 ] [ i - 1 ] * 2 + dp [ 1 ] [ i - 1 ] NEW_LINE DEDENT return dp [ 0 ] [ n ] + dp [ 1 ] [ n ] NEW_LINE DEDENT
def compute ( str , n ) : NEW_LINE INDENT reverseAlphabet = " zyxwvutsrqponmlkjihgfedcba " NEW_LINE l = len ( str ) NEW_LINE answer = " " NEW_LINE for i in range ( n ) : NEW_LINE INDENT answer = answer + str [ i ] NEW_LINE DEDENT for i in range ( l ) : NEW_LINE INDENT answer = answer + reverseAlphabet [ ord ( str [ i ] ) - ord ( ' a ' ) ] NEW_LINE DEDENT return answer NEW_LINE DEDENT
def maxLenSub ( arr , n ) : NEW_LINE INDENT mls = [ 0 ] * n NEW_LINE max = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT mls [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( abs ( arr [ i ] - arr [ j ] ) <= 1 and mls [ i ] < mls [ j ] + 1 ) : NEW_LINE INDENT mls [ i ] = mls [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if max < mls [ i ] : NEW_LINE INDENT max = mls [ i ] NEW_LINE DEDENT DEDENT return max NEW_LINE DEDENT
def exponentiation ( base , exp ) : NEW_LINE INDENT t = 1L NEW_LINE while ( exp > 0 ) : NEW_LINE INDENT if ( exp % 2 != 0 ) : NEW_LINE INDENT t = ( t * base ) % N NEW_LINE DEDENT base = ( base * base ) % N NEW_LINE exp = long ( exp / 2 ) NEW_LINE DEDENT return t % N NEW_LINE DEDENT
def sequence ( n ) : NEW_LINE INDENT f = [ 0 ] * ( n + 1 ) NEW_LINE f [ 0 ] = 0 NEW_LINE f [ 1 ] = 1 NEW_LINE f [ 2 ] = 1 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT f [ i ] = f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ] NEW_LINE DEDENT return f [ n ] NEW_LINE DEDENT
def lbs ( arr , n ) : NEW_LINE INDENT lis = [ 0 ] * n NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and lis [ i ] < lis [ j ] + 1 ) : NEW_LINE INDENT lis [ i ] = lis [ j ] + 1 NEW_LINE DEDENT DEDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( n - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and lds [ i ] < lds [ j ] + 1 ) : NEW_LINE INDENT lds [ i ] = lds [ j ] + 1 NEW_LINE DEDENT DEDENT max = lis [ 0 ] + lds [ 0 ] - 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( lis [ i ] + lds [ i ] - 1 > max ) : NEW_LINE INDENT max = lis [ i ] + lds [ i ] - 1 NEW_LINE DEDENT DEDENT return max NEW_LINE DEDENT
def maximumSum ( a , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT sort ( a , i , n ) NEW_LINE DEDENT sum = a [ n - 1 ] [ M - 1 ] NEW_LINE prev = a [ n - 1 ] [ M - 1 ] NEW_LINE i = n - 2 NEW_LINE for j in range ( M - 1 , - 1 , - 1 ) : NEW_LINE INDENT if a [ i ] [ j ] < prev : NEW_LINE INDENT prev = a [ i ] [ j ] NEW_LINE sum += prev NEW_LINE break NEW_LINE DEDENT DEDENT if j == - 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def fib ( n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return n NEW_LINE DEDENT return fib ( n - 1 ) + fib ( n - 2 ) NEW_LINE DEDENT
def countPairs ( str ) : NEW_LINE INDENT result = 0 NEW_LINE n = len ( str ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( abs ( str [ i ] - str [ j ] ) == abs ( i - j ) ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
def flipsPossible ( a , n ) : NEW_LINE INDENT count_odd = 0 NEW_LINE count_even = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] & 1 ) == 1 : NEW_LINE INDENT count_odd += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_even += 1 NEW_LINE DEDENT DEDENT if ( count_odd % 2 == 1 and count_even % 2 == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT
def checkDuplicatesWithinK ( arr , k ) : NEW_LINE INDENT set = set ( ) NEW_LINE for i in range ( 0 , len ( arr ) ) : NEW_LINE INDENT if arr [ i ] in set : NEW_LINE INDENT return True NEW_LINE DEDENT set . add ( arr [ i ] ) NEW_LINE if i >= k : NEW_LINE INDENT set . remove ( arr [ i - k ] ) NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def diagonalsquare ( mat , row , column ) : NEW_LINE INDENT print ( " ▁ Diagonal ▁ one ▁ : ▁ " ) NEW_LINE for i in range ( row ) : NEW_LINE INDENT print ( mat [ i ] [ i ] * mat [ i ] [ i ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT
def maxArea ( mat ) : NEW_LINE INDENT hist = [ [ 0 for i in range ( C + 1 ) ] for j in range ( R ) ] NEW_LINE for i in range ( C ) : NEW_LINE INDENT hist [ 0 ] [ i ] = mat [ 0 ] [ i ] NEW_LINE for j in range ( 1 , R ) : NEW_LINE INDENT hist [ j ] [ i ] = ( mat [ j ] [ i ] == 0 ) : NEW_LINE INDENT hist [ j - 1 ] [ i ] + 1 NEW_LINE DEDENT DEDENT for i in range ( R ) : NEW_LINE INDENT count = [ 0 for j in range ( C ) : NEW_LINE INDENT count [ hist [ i ] [ j ] ] += 1 NEW_LINE DEDENT col_no = 0 NEW_LINE for j in range ( R ) : NEW_LINE INDENT if ( count [ j ] > 0 ) : NEW_LINE INDENT for k in range ( count [ j ] ) : NEW_LINE INDENT hist [ i ] [ col_no ] = j NEW_LINE col_no += 1 NEW_LINE DEDENT DEDENT DEDENT max_area = 0 NEW_LINE for i in range ( R ) : NEW_LINE INDENT for j in range ( C ) : NEW_LINE INDENT curr_area = ( j + 1 ) * hist [ i ] [ j ] NEW_LINE if ( curr_area > max_area ) : NEW_LINE INDENT max_area = curr_area NEW_LINE DEDENT DEDENT DEDENT return max_area NEW_LINE DEDENT
def longestSubseqWithDiffOne ( arr , n ) : NEW_LINE INDENT dp = [ 0 ] * n NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ i ] == arr [ j ] + 1 ) or ( arr [ i ] == arr [ j ] - 1 ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i ] , dp [ j ] + 1 ) NEW_LINE DEDENT DEDENT DEDENT result = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( result < dp [ i ] ) : NEW_LINE INDENT result = dp [ i ] NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def maxSquare ( b , m ) : NEW_LINE INDENT return ( b // m - 1 ) * ( b / m ) / 2 NEW_LINE DEDENT
def maxSumPairWithDifferenceLessThanK ( arr , N , K ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE dp = [ 0 for _ in range ( N ) ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] NEW_LINE if ( arr [ i ] - arr [ i - 1 ] < K ) : NEW_LINE INDENT if ( i >= 2 ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i ] , dp [ i - 2 ] + arr [ i ] + arr [ i - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] = max ( dp [ i ] , arr [ i ] + arr [ i - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ N - 1 ] NEW_LINE DEDENT
def minOperation ( arr , n ) : NEW_LINE INDENT hash = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if hash . get ( arr [ i ] ) : NEW_LINE INDENT hash [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT hash [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT max_count = 0 NEW_LINE s = set ( ) NEW_LINE for i in s : NEW_LINE INDENT if max_count < hash [ i ] : NEW_LINE INDENT max_count = hash [ i ] NEW_LINE DEDENT DEDENT return ( n - max_count ) NEW_LINE DEDENT
def kSmallestPair ( arr1 , n1 , arr2 , n2 , k ) : NEW_LINE INDENT if ( k > n1 * n2 ) : NEW_LINE INDENT print ( " k ▁ pairs ▁ don ' t ▁ exist " ) NEW_LINE return NEW_LINE DEDENT index2 = [ 0 ] * n1 NEW_LINE while ( k > 0 ) : NEW_LINE INDENT min_sum = sys . maxsize NEW_LINE min_index = 0 NEW_LINE for i1 in range ( n1 ) : NEW_LINE INDENT if ( index2 [ i1 ] < n2 and arr1 [ i1 ] + arr2 [ index2 [ i1 ] ] < min_sum ) : NEW_LINE INDENT min_index = i1 NEW_LINE min_sum = arr1 [ i1 ] + arr2 [ index2 [ i1 ] ] NEW_LINE DEDENT DEDENT print ( " ( " , arr1 [ min_index ] , ' , ▁ ' , arr2 [ index2 [ min_index ] ] , ' ) ▁ ' ) NEW_LINE index2 [ min_index ] += 1 NEW_LINE k -= 1 NEW_LINE DEDENT DEDENT
def spiralPrint ( m , n , a ) : NEW_LINE INDENT k = 0 l = 0 NEW_LINE while ( k < m and l < n ) : NEW_LINE INDENT for i in range ( l , n ) : NEW_LINE INDENT print ( a [ k ] [ i ] , end = " ▁ " ) NEW_LINE DEDENT k += 1 NEW_LINE for i in range ( k , m ) : NEW_LINE INDENT print ( a [ i ] [ n - 1 ] , end = " ▁ " ) NEW_LINE DEDENT n -= 1 NEW_LINE if ( k < m ) : NEW_LINE INDENT for i in range ( n - 1 , l - 1 , - 1 ) : NEW_LINE INDENT print ( a [ m - 1 ] [ i ] , end = " ▁ " ) NEW_LINE DEDENT m -= 1 NEW_LINE DEDENT if ( l < n ) : NEW_LINE INDENT for i in range ( m - 1 , k - 1 , - 1 ) : NEW_LINE INDENT print ( a [ i ] [ l ] , end = " ▁ " ) NEW_LINE DEDENT l += 1 NEW_LINE DEDENT DEDENT DEDENT
def findSum ( str ) : NEW_LINE INDENT temp = " " NEW_LINE sum = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( isDigit ( ch ) ) : NEW_LINE INDENT temp += chr ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT sum += int ( temp ) NEW_LINE temp = "0" NEW_LINE DEDENT DEDENT return sum + int ( temp ) NEW_LINE DEDENT
def pentagonalNum ( n ) : NEW_LINE INDENT return ( 3 * n * n - n ) / 2 NEW_LINE DEDENT
def countNonDecreasing ( n ) : NEW_LINE INDENT N = 10 NEW_LINE count = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT count *= ( N + i - 1 ) NEW_LINE count /= i NEW_LINE DEDENT return count NEW_LINE DEDENT
def mostFrequent ( arr , n ) : NEW_LINE INDENT hp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT key = arr [ i ] NEW_LINE if hp . get ( key ) : NEW_LINE INDENT freq = hp [ key ] NEW_LINE freq += 1 NEW_LINE hp [ key ] = freq NEW_LINE DEDENT else : NEW_LINE INDENT hp [ key ] = 1 NEW_LINE DEDENT DEDENT max_count = 0 NEW_LINE res = - 1 NEW_LINE for val in hp : NEW_LINE INDENT if max_count < val . getValue ( ) : NEW_LINE INDENT res = val . getKey ( ) NEW_LINE max_count = val . getValue ( ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def kth ( arr1 , arr2 , m , n , k ) : NEW_LINE INDENT sorted1 = [ 0 ] * ( m + n ) NEW_LINE i = 0 j = 0 NEW_LINE d = 0 NEW_LINE while ( i < m and j < n ) : NEW_LINE INDENT if ( arr1 [ i ] < arr2 [ j ] ) : NEW_LINE INDENT sorted1 [ d ] = arr1 [ i ] NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT sorted1 [ d ] = arr2 [ j ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT while ( i < m ) : NEW_LINE INDENT sorted1 [ d ] = arr1 [ i ] NEW_LINE i += 1 NEW_LINE DEDENT while ( j < n ) : NEW_LINE INDENT sorted1 [ d ] = arr2 [ j ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT return sorted1 [ k - 1 ] NEW_LINE DEDENT
def binomialCoeff ( n , k ) : NEW_LINE INDENT if ( k == 0 or k == n ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return binomialCoeff ( n - 1 , k - 1 ) + binomialCoeff ( n - 1 , k ) NEW_LINE DEDENT
def firstLetterWord ( str ) : NEW_LINE INDENT result = " " NEW_LINE v = True NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] == ' ▁ ' ) : NEW_LINE INDENT v = True NEW_LINE DEDENT elif ( str [ i ] != ' ▁ ' and v == True ) : NEW_LINE INDENT result += str [ i ] NEW_LINE v = False NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def assign ( a , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE ans = [ 0 ] * n NEW_LINE p = 0 NEW_LINE q = n - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( ( i + 1 ) % 2 == 0 ) : NEW_LINE INDENT ans [ i ] = a [ q -= 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT ans [ i ] = a [ p ] NEW_LINE DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( ans [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def printDistinct ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT j = 0 NEW_LINE while j < i : NEW_LINE INDENT if ( arr [ i ] == arr [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if ( i == j ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
def countSolutions ( n ) : NEW_LINE INDENT res = 0 NEW_LINE for x in range ( 0 , n ) : NEW_LINE INDENT for y in range ( 0 , x * x + y * y < n ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def relativeComplement ( arr1 , arr2 , n , m ) : NEW_LINE INDENT i , j = 0 , 0 NEW_LINE while i < n and j < m : NEW_LINE INDENT if arr1 [ i ] < arr2 [ j ] : NEW_LINE INDENT print ( arr1 [ i ] , end = " ▁ " ) NEW_LINE i += 1 NEW_LINE DEDENT elif arr1 [ i ] > arr2 [ j ] : NEW_LINE INDENT j += 1 NEW_LINE DEDENT elif arr1 [ i ] == arr2 [ j ] : NEW_LINE INDENT i += 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT while i < n : NEW_LINE INDENT print ( arr1 [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def findFourElements ( arr , n ) : NEW_LINE INDENT map = dict ( ) NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT map [ arr [ i ] + arr [ j ] ] = new Indexes ( i , j ) NEW_LINE DEDENT DEDENT d = - float ( ' inf ' ) NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT abs_diff = abs ( arr [ i ] - arr [ j ] ) NEW_LINE if ( indexes . getI ( ) != i and indexes . getI ( ) != j and indexes . getJ ( ) != i ) : NEW_LINE INDENT d = max ( d , max ( arr [ i ] , arr [ j ] ) ) NEW_LINE DEDENT DEDENT DEDENT return d NEW_LINE DEDENT
def findTrailingZeros ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 5 ) : NEW_LINE INDENT count += n // i NEW_LINE DEDENT return count NEW_LINE DEDENT
def isPrime ( p ) : NEW_LINE INDENT checkNumber = ( pow ( 2 , p ) - 1 ) NEW_LINE nextval = 4 % checkNumber NEW_LINE for i in range ( 1 , p - 1 ) : NEW_LINE INDENT nextval = ( nextval * nextval - 2 ) % checkNumber NEW_LINE DEDENT return ( nextval == 0 ) NEW_LINE DEDENT
def CountSubstring ( st , n ) : NEW_LINE INDENT ans = ( n * ( n + 1 ) ) / 2 NEW_LINE a_index = 0 NEW_LINE b_index = 0 NEW_LINE c_index = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( st [ i ] == ' a ' ) : NEW_LINE INDENT a_index = i + 1 NEW_LINE ans -= min ( b_index , c_index ) NEW_LINE DEDENT elif ( st [ i ] == ' b ' ) : NEW_LINE INDENT b_index = i + 1 NEW_LINE ans -= min ( a_index , c_index ) NEW_LINE DEDENT else : NEW_LINE INDENT c_index = i + 1 NEW_LINE ans -= min ( a_index , b_index ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def isPalindrome ( str ) : NEW_LINE INDENT l = 0 NEW_LINE h = len ( str ) - 1 NEW_LINE while ( h > l ) : NEW_LINE INDENT if ( str [ l ] != str [ h - 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT l += 1 NEW_LINE h -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT
def maxNumOfChocolates ( arr , n , k ) : NEW_LINE INDENT um = dict ( ) NEW_LINE sum = [ 0 ] * n NEW_LINE maxSum = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT sum [ i ] = sum [ i - 1 ] + arr [ i ] NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT curr_rem = sum [ i ] % k NEW_LINE if ( curr_rem == 0 ) : NEW_LINE INDENT if ( maxSum < sum [ i ] ) : NEW_LINE INDENT maxSum = sum [ i ] NEW_LINE DEDENT elif ( maxSum < sum [ i ] - sum [ curr_rem ] ) : NEW_LINE INDENT maxSum = sum [ i ] - sum [ curr_rem ] NEW_LINE DEDENT DEDENT return ( maxSum // k ) NEW_LINE DEDENT
def decode ( string ) : NEW_LINE INDENT integerstack = [ ] NEW_LINE stringstack = [ ] NEW_LINE result = " " NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT count = 0 NEW_LINE if ( ord ( string [ i ] ) == ord ( string [ i ] ) ) : NEW_LINE INDENT while ( ord ( string [ i ] ) in range ( 10 ) ) : NEW_LINE INDENT count = count * 10 + ord ( string [ i ] ) - ord ( '0' ) NEW_LINE i += 1 NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT elif ( string [ i ] == ' [ ' ) : NEW_LINE INDENT temp = " " NEW_LINE count = 0 NEW_LINE if ( not integerstack . empty ( ) ) : NEW_LINE INDENT count = integerstack . queue [ - 1 ] NEW_LINE stringstack . append ( string [ i ] ) NEW_LINE DEDENT for j in range ( count ) : NEW_LINE INDENT result = result + temp NEW_LINE for j in range ( len ( result ) ) : NEW_LINE INDENT stringstack [ j ] = result [ j ] NEW_LINE DEDENT result = " " NEW_LINE DEDENT elif ( stringstack . empty ( ) ) : NEW_LINE INDENT result = stringstack . queue [ - 1 ] NEW_LINE stringstack . append ( string [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT stringstack . append ( string [ i ] ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def minSum ( A , n ) : NEW_LINE INDENT min_val = min ( A ) NEW_LINE return ( min_val * ( n - 1 ) ) NEW_LINE DEDENT
def isPower ( x , y ) : NEW_LINE INDENT res1 = ( int ) math . log ( y ) / math . log ( x ) NEW_LINE res2 = math . log ( y ) / math . log ( x ) NEW_LINE return ( res1 == res2 ) NEW_LINE DEDENT
def countWords ( str , n ) : NEW_LINE INDENT m = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if m . get ( str [ i ] ) : NEW_LINE INDENT get = m [ str [ i ] ] NEW_LINE m [ str [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT m [ str [ i ] ] = 1 NEW_LINE DEDENT DEDENT res = 0 NEW_LINE for it in m : NEW_LINE INDENT if it . getValue ( ) == 2 : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def findLargestd ( S , n ) : NEW_LINE INDENT found = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT continue NEW_LINE DEDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT if ( i == k ) : NEW_LINE INDENT continue NEW_LINE DEDENT for l in range ( k + 1 , n ) : NEW_LINE INDENT if ( i == l ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( S [ i ] == S [ j ] + S [ k ] + S [ l ] ) : NEW_LINE INDENT found = True NEW_LINE return S [ i ] NEW_LINE DEDENT DEDENT DEDENT if ( found == False ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def minMaxValues ( arr , n , m ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n + m ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE arr [ i ] += 50 NEW_LINE DEDENT dp = [ [ False for x in range ( MAX + 1 ) ] for y in range ( MAX * MAX + 1 ) ] NEW_LINE for i in range ( n + m ) : NEW_LINE INDENT for k in range ( min ( n , i + 1 ) ) : NEW_LINE INDENT for j in range ( 0 , MAX * MAX + 1 ) : NEW_LINE INDENT if ( dp [ k - 1 ] [ j ] ) : NEW_LINE INDENT dp [ k ] [ j + arr [ i ] ] = True NEW_LINE DEDENT DEDENT DEDENT max_value = - 1 * INF NEW_LINE min_value = INF NEW_LINE for i in range ( MAX * MAX + 1 ) : NEW_LINE INDENT if ( dp [ n ] [ i ] ) : NEW_LINE INDENT temp = i - 50 * n NEW_LINE max_value = max ( max_value , temp * ( sum - temp ) ) NEW_LINE min_value = min ( min_value , temp * ( sum - temp ) ) NEW_LINE DEDENT DEDENT print ( " Maximum ▁ Value : ▁ " , ( int ) max_value , " \n " , " Minimum ▁ Value : ▁ " , ( int ) min_value , " \n " ) NEW_LINE DEDENT
def constructTree ( n , d , h ) : NEW_LINE INDENT if ( d == 1 ) : NEW_LINE INDENT if ( n == 2 and h == 1 ) : NEW_LINE INDENT print ( "1 ▁ 2" ) NEW_LINE return NEW_LINE DEDENT print ( " - 1" ) NEW_LINE return NEW_LINE DEDENT if ( d > 2 * h ) : NEW_LINE INDENT print ( " - 1" ) NEW_LINE return NEW_LINE DEDENT for i in range ( 1 , h + 1 ) : NEW_LINE INDENT print ( i , " ▁ " , ( i + 1 ) ) NEW_LINE DEDENT if ( d > h ) : NEW_LINE INDENT print ( "1" , " ▁ " , ( h + 2 ) ) NEW_LINE for i in range ( h + 2 , d + 1 ) : NEW_LINE INDENT print ( i , " ▁ " , ( i + 1 ) ) NEW_LINE DEDENT DEDENT for i in range ( d + 1 , n ) : NEW_LINE INDENT k = 1 NEW_LINE if ( d == h ) : NEW_LINE INDENT k = 2 NEW_LINE DEDENT print ( k , " ▁ " , ( i + 1 ) ) NEW_LINE DEDENT DEDENT
def rectCount ( n , m ) : NEW_LINE INDENT return ( m * n * ( n + 1 ) * ( m + 1 ) ) / 4 NEW_LINE DEDENT
def sortUsingHash ( a , n ) : NEW_LINE INDENT max = max ( a ) NEW_LINE hash = ( max + 1 ) * [ 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT hash [ a [ i ] ] += 1 NEW_LINE DEDENT for i in range ( max + 1 ) : NEW_LINE INDENT if ( hash [ i ] != 0 ) : NEW_LINE INDENT for j in range ( hash [ i ] ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
def subarrayDivisibleByK ( arr , n , k ) : NEW_LINE INDENT mp = [ 0 ] * 1000 NEW_LINE s = 0 NEW_LINE e = 0 NEW_LINE maxs = 0 NEW_LINE maxe = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT mod = arr [ i ] % k NEW_LINE while ( mp [ k - mod ] != 0 or ( mod == 0 and mp [ mod ] != 0 ) ) : NEW_LINE INDENT mp [ arr [ s ] % k ] -= 1 NEW_LINE s += 1 NEW_LINE DEDENT mp [ mod ] += 1 NEW_LINE if ( ( e - s ) > ( maxe - maxs ) ) : NEW_LINE INDENT maxe = e NEW_LINE maxs = s NEW_LINE DEDENT DEDENT print ( " The ▁ maximum ▁ size ▁ is " , ( maxe - maxs + 1 ) , " ▁ and ▁ the ▁ subarray ▁ is " , " as ▁ follows " ) NEW_LINE for i in range ( maxs , maxe + 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def isDivisible ( str , k ) : NEW_LINE INDENT n = len ( str ) NEW_LINE c = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT if ( str [ n - i - 1 ] == '0' ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT return ( c == k ) NEW_LINE DEDENT
def divisible ( num ) : NEW_LINE INDENT n = len ( num ) NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += int ( num [ i ] ) NEW_LINE DEDENT if ( sum % 3 == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( sum % 3 == ( num [ i ] - '0' ) % 3 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n == 2 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return 2 NEW_LINE DEDENT
def superSeq ( X , Y , m , n ) : NEW_LINE INDENT if m == 0 : NEW_LINE INDENT return n NEW_LINE DEDENT if n == 0 : NEW_LINE INDENT return m NEW_LINE DEDENT if x [ m - 1 ] == Y [ n - 1 ] : NEW_LINE INDENT return 1 + superSeq ( X , Y , m - 1 , n - 1 ) NEW_LINE DEDENT return 1 + min ( superSeq ( X , Y , m - 1 , n ) , superSeq ( X , Y , m , n - 1 ) ) NEW_LINE DEDENT
def swapUpperToLower ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT arr [ i ] [ j ] = arr [ j ] [ i ] NEW_LINE arr [ j ] [ i ] = arr [ j ] [ i ] NEW_LINE DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] [ j ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT
def kthgroupsum ( k ) : NEW_LINE INDENT cur = ( k * ( k - 1 ) ) + 1 NEW_LINE sum = 0 NEW_LINE while ( k -- > 0 ) : NEW_LINE INDENT sum += cur NEW_LINE cur += 2 NEW_LINE DEDENT return sum NEW_LINE DEDENT
def isMagicSquare ( mat ) : NEW_LINE INDENT sum = 0 NEW_LINE sum2 = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT sum = sum + mat [ i ] [ i ] NEW_LINE DEDENT for i in range ( 0 , N ) : NEW_LINE INDENT sum2 = sum2 + mat [ i ] [ N - 1 - i ] NEW_LINE DEDENT if ( sum != sum2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT rowSum = 0 NEW_LINE for j in range ( N ) : NEW_LINE INDENT rowSum += mat [ i ] [ j ] NEW_LINE DEDENT if ( rowSum != sum ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT colSum = 0 NEW_LINE for j in range ( N ) : NEW_LINE INDENT colSum += mat [ j ] [ i ] NEW_LINE DEDENT if ( sum != colSum ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def isScalarMatrix ( mat ) : NEW_LINE INDENT for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( 0 , N ) : NEW_LINE INDENT if ( ( i != j ) and ( mat [ i ] [ j ] != 0 ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT for i in range ( 0 , N - 1 ) : NEW_LINE INDENT if ( mat [ i ] [ i ] != mat [ i + 1 ] [ i + 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def longSubarrWthSumDivByK ( arr , n , k ) : NEW_LINE INDENT um = dict ( ) NEW_LINE mod_arr = [ 0 ] * n NEW_LINE max = 0 NEW_LINE curr_sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT curr_sum += arr [ i ] NEW_LINE mod_arr [ i ] = ( ( curr_sum % k ) + k ) % k NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( mod_arr [ i ] == 0 ) : NEW_LINE INDENT max = i + 1 NEW_LINE DEDENT elif ( um [ mod_arr [ i ] ] == False ) : NEW_LINE INDENT um [ mod_arr [ i ] ] = i NEW_LINE DEDENT elif ( max < ( i - um [ mod_arr [ i ] ] ) ) : NEW_LINE INDENT max = i - um [ mod_arr [ i ] ] NEW_LINE DEDENT DEDENT return max NEW_LINE DEDENT
def reverse ( str ) : NEW_LINE INDENT if ( str == null ) or ( len ( str ) <= 1 ) : NEW_LINE INDENT print ( str ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( str [ len ( str ) - 1 ] , end = " " ) NEW_LINE reverse ( str [ 0 : len ( str ) - 1 ] ) NEW_LINE DEDENT DEDENT
def arrangeBraces ( n , pos , k ) : NEW_LINE INDENT h = [ False for i in range ( k ) ] NEW_LINE dp = [ [ 0 for i in range ( k ) ] for j in range ( N ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 0 , 2 * n + 1 ) : NEW_LINE INDENT if ( h [ i ] == True ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT elif ( j != 0 ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] NEW_LINE DEDENT DEDENT DEDENT return dp [ 2 * n ] [ 0 ] NEW_LINE DEDENT
def isDvisibleBy12 ( num ) : NEW_LINE INDENT if ( len ( num ) >= 3 ) : NEW_LINE INDENT d1 = ord ( num [ len ( num ) - 1 ] ) NEW_LINE if ( d1 % 2 != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT d2 = ord ( num [ len ( num ) - 2 ] ) NEW_LINE sum = 0 NEW_LINE for i in range ( 0 , len ( num ) ) : NEW_LINE INDENT sum += num [ i ] NEW_LINE DEDENT return ( sum % 3 == 0 and ( d2 * 10 + d1 ) % 4 == 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT number = int ( num ) NEW_LINE return ( number % 12 == 0 ) NEW_LINE DEDENT
def maxDiff ( arr , n ) : NEW_LINE INDENT SubsetSum_1 = 0 NEW_LINE SubsetSum_2 = 0 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT isSingleOccurance = True NEW_LINE for j in range ( i + 1 , n - 1 ) : NEW_LINE INDENT if arr [ i ] == arr [ j ] : NEW_LINE INDENT isSingleOccurance = False NEW_LINE arr [ i ] = arr [ j ] = 0 NEW_LINE break NEW_LINE DEDENT DEDENT if ( isSingleOccurance ) : NEW_LINE INDENT if arr [ i ] > 0 : NEW_LINE INDENT SubsetSum_1 += arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT SubsetSum_2 += arr [ i ] NEW_LINE DEDENT DEDENT DEDENT return abs ( SubsetSum_1 - SubsetSum_2 ) NEW_LINE DEDENT
def lexsmallest ( a , n ) : NEW_LINE INDENT sort ( a ) NEW_LINE answer = " " NEW_LINE for i in range ( n ) : NEW_LINE INDENT answer += a [ i ] NEW_LINE DEDENT return answer NEW_LINE DEDENT
def maxCost ( mat , N ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( N ) ] for j in range ( N ) ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT for j in range ( 1 , i + 1 and j < N ) : NEW_LINE INDENT dp [ i ] [ j ] = mat [ i ] [ j ] + max ( dp [ i - 1 ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT result = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if result < dp [ N - 1 ] [ i ] : NEW_LINE INDENT result = dp [ N - 1 ] [ i ] NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def xorZero ( s ) : NEW_LINE INDENT one_count = 0 NEW_LINE zero_count = 0 NEW_LINE str = s . toCharArray ( ) NEW_LINE n = len ( str ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( str [ i ] == '1' ) : NEW_LINE INDENT one_count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT zero_count += 1 NEW_LINE DEDENT DEDENT if ( one_count % 2 == 0 ) : NEW_LINE INDENT return zero_count NEW_LINE DEDENT return one_count NEW_LINE DEDENT
def nthRoot ( A , N ) : NEW_LINE INDENT xPre = random ( ) % 10 NEW_LINE eps = 0.001 NEW_LINE delX = 2147483647 NEW_LINE xK = 0.0 NEW_LINE while ( delX > eps ) : NEW_LINE INDENT xK = ( ( N - 1.0 ) * xPre + ( double ) A / math . pow ( xPre , N - 1 ) ) / ( double ) N NEW_LINE delX = abs ( xK - xPre ) NEW_LINE xPre = xK NEW_LINE DEDENT return xK NEW_LINE DEDENT
def findLeft ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE while ( n > 0 ) : NEW_LINE INDENT n -= 1 NEW_LINE if ( str [ n ] == ' d ' ) : NEW_LINE INDENT str [ n ] = ' c ' NEW_LINE break NEW_LINE DEDENT if ( str [ n ] == ' b ' ) : NEW_LINE INDENT str [ n ] = ' a ' NEW_LINE break NEW_LINE DEDENT if ( str [ n ] == ' a ' ) : NEW_LINE INDENT str [ n ] = ' b ' NEW_LINE break NEW_LINE DEDENT if ( str [ n ] == ' c ' ) : NEW_LINE INDENT str [ n ] = ' d ' NEW_LINE DEDENT DEDENT return str NEW_LINE DEDENT
def subset ( ar , n ) : NEW_LINE INDENT res = 0 NEW_LINE ar . sort ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT count = 1 NEW_LINE while i < n - 1 : NEW_LINE INDENT if ( ar [ i ] == ar [ i + 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT res = max ( res , count ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def minRange ( arr , n , k ) : NEW_LINE INDENT l = 0 NEW_LINE r = n NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = Set ( ) NEW_LINE j = i NEW_LINE for j in range ( n ) : NEW_LINE INDENT s . add ( arr [ j ] ) NEW_LINE if ( s . size ( ) == k ) : NEW_LINE INDENT if ( ( j - i ) < ( r - l ) ) : NEW_LINE INDENT r = j NEW_LINE l = i NEW_LINE DEDENT break NEW_LINE DEDENT DEDENT if ( j == n ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( l == 0 and r == n ) : NEW_LINE INDENT print ( " Invalid ▁ k " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( l , " ▁ " , r ) NEW_LINE DEDENT DEDENT
def findSum ( A , B , n ) : NEW_LINE INDENT hash = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if hash . get ( A [ i ] ) : NEW_LINE INDENT hash [ A [ i ] ] = 1 + hash [ A [ i ] ] NEW_LINE DEDENT else : NEW_LINE INDENT hash [ A [ i ] ] = 1 NEW_LINE DEDENT if hash . get ( B [ i ] ) : NEW_LINE INDENT hash [ B [ i ] ] = 1 + hash [ B [ i ] ] NEW_LINE DEDENT else : NEW_LINE INDENT hash [ B [ i ] ] = 1 NEW_LINE DEDENT DEDENT sum = 0 NEW_LINE for entry in hash : NEW_LINE INDENT if sum == 0 : NEW_LINE INDENT sum += int ( ( entry . getValue ( ) ) . toString ( ) ) NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def printSubStr ( Str , low , high ) : NEW_LINE INDENT print ( Str [ low : high + 1 ] , end = " " ) NEW_LINE DEDENT
def evenSum ( n ) : NEW_LINE INDENT C = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( min ( i , n ) + 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT sum = 0 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT sum += C [ n ] [ i ] NEW_LINE DEDENT return sum NEW_LINE DEDENT
def getMinSquares ( n ) : NEW_LINE INDENT if n <= 3 : NEW_LINE INDENT return n NEW_LINE DEDENT dp = [ 0 for _ in range ( n + 1 ) ] NEW_LINE for i in range ( 4 , n + 1 ) : NEW_LINE INDENT dp [ i ] = i NEW_LINE for x in range ( 1 , ceil ( math . sqrt ( i ) ) + 1 ) : NEW_LINE INDENT temp = x * x NEW_LINE if temp > i : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] = min ( dp [ i ] , 1 + dp [ i - temp ] ) NEW_LINE DEDENT DEDENT res = dp [ n ] NEW_LINE return res NEW_LINE DEDENT
def arrayEvenAndOdd ( arr , n ) : NEW_LINE INDENT i = - 1 NEW_LINE j = 0 NEW_LINE while ( j != n ) : NEW_LINE INDENT if ( arr [ j ] % 2 == 0 ) : NEW_LINE INDENT i += 1 NEW_LINE arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT for k in range ( n ) : NEW_LINE INDENT print ( arr [ k ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def diagonalsquare ( mat , row , column ) : NEW_LINE INDENT print ( " Diagonal ▁ one ▁ : ▁ " ) NEW_LINE for i in range ( row ) : NEW_LINE INDENT for j in range ( column ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT print ( mat [ i ] [ j ] * mat [ i ] [ j ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT
def areSumSame ( a , n , m ) : NEW_LINE INDENT sum1 = 0 NEW_LINE sum2 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum1 = 0 NEW_LINE sum2 = 0 NEW_LINE for j in range ( m ) : NEW_LINE INDENT sum1 += a [ i ] [ j ] NEW_LINE sum2 += a [ j ] [ i ] NEW_LINE DEDENT if ( sum1 == sum2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def printClosest ( arr , n , x ) : NEW_LINE INDENT res_l = 0 NEW_LINE res_r = 0 NEW_LINE l = 0 NEW_LINE r = n - 1 NEW_LINE diff = 10 ** 9 NEW_LINE while ( r > l ) : NEW_LINE INDENT if ( abs ( arr [ l ] + arr [ r ] - x ) < diff ) : NEW_LINE INDENT res_l = l NEW_LINE res_r = r NEW_LINE diff = abs ( arr [ l ] + arr [ r ] - x ) NEW_LINE DEDENT if ( arr [ l ] + arr [ r ] > x ) : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT l += 1 NEW_LINE DEDENT DEDENT print ( " ▁ The ▁ closest ▁ pair ▁ is " , arr [ res_l ] , " and ▁ " , arr [ res_r ] ) NEW_LINE DEDENT
def countSubStr ( st , n ) : NEW_LINE INDENT m = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( st [ i ] == '1' ) : NEW_LINE INDENT m += 1 NEW_LINE DEDENT DEDENT return m * ( m - 1 ) / 2 NEW_LINE DEDENT
def countSubstringWithEqualEnds ( s ) : NEW_LINE INDENT result = 0 NEW_LINE n = len ( s ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT if ( s [ i ] == s [ j ] ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
def calcMaxValue ( str ) : NEW_LINE INDENT res = str [ 0 ] - '0' NEW_LINE for i in range ( 1 , len ( str ) ) : NEW_LINE INDENT if ( str [ i ] == '0' or str [ i ] == '1' or res < 2 ) : NEW_LINE INDENT res += ( ord ( str [ i ] ) - ord ( '0' ) ) NEW_LINE DEDENT else : NEW_LINE INDENT res = res * ( ord ( str [ i ] ) - ord ( '0' ) ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def bestFit ( blockSize , m , processSize , n ) : NEW_LINE INDENT allocation = [ - 1 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT bestIdx = - 1 NEW_LINE for j in range ( m ) : NEW_LINE INDENT if ( blockSize [ j ] >= processSize [ i ] ) : NEW_LINE INDENT if ( bestIdx == - 1 ) : NEW_LINE INDENT bestIdx = j NEW_LINE DEDENT elif ( blockSize [ bestIdx ] > blockSize [ j ] ) : NEW_LINE INDENT bestIdx = j NEW_LINE DEDENT DEDENT DEDENT if ( bestIdx != - 1 ) : NEW_LINE INDENT allocation [ i ] = bestIdx NEW_LINE blockSize [ bestIdx ] -= processSize [ i ] NEW_LINE DEDENT DEDENT print ( " \n Process ▁ No . \tProcess ▁ Size\tBlock ▁ no . " ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( " ▁ ▁ " , i + 1 , " \t\t " , processSize [ i ] , " \t\t " , allocation [ i ] + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ Allocated " ) NEW_LINE DEDENT DEDENT
def countFreq ( a , n ) : NEW_LINE INDENT hm = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT hm [ a [ i ] ] += 1 NEW_LINE DEDENT cumul = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT cumul += hm [ a [ i ] ] NEW_LINE if ( hm [ a [ i ] ] != 0 ) : NEW_LINE INDENT print ( a [ i ] , end = " - > " , cumul ) NEW_LINE DEDENT hm [ a [ i ] ] = 0 NEW_LINE DEDENT DEDENT
def isSubSeqDivisible ( arr , str1 ) : NEW_LINE INDENT l = len ( arr1 ) NEW_LINE for i in range ( 0 , l ) : NEW_LINE INDENT for j in range ( i , l ) : NEW_LINE INDENT for k in range ( j , l ) : NEW_LINE INDENT if ( arr [ i ] % 8 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT elif ( arr [ i ] * 10 + arr [ j ] ) % 8 == 0 and i != j ) : NEW_LINE INDENT return True NEW_LINE DEDENT elif ( ( arr [ i ] * 100 + arr [ j ] * 10 + arr [ k ] ) % 8 == 0 and i != j and j != k and i != k ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT
def getAbs ( n ) : NEW_LINE INDENT mask = n > > ( SIZE_INT * CHAR_BIT - 1 ) NEW_LINE return ( ( n + mask ) ^ mask ) NEW_LINE DEDENT
def countPairs ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT product = arr [ i ] * arr [ j ] NEW_LINE for k in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ k ] == product ) : NEW_LINE INDENT result += 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
def minCost ( a , n , k ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( k + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( k + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = inf NEW_LINE DEDENT dp [ 0 ] [ 0 ] = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , k + 1 ) : NEW_LINE INDENT for m in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ m ] [ j - 1 ] + ( a [ i - 1 ] - a [ m ] ) * ( a [ i - 1 ] - a [ m ] ) ) NEW_LINE DEDENT DEDENT return dp [ n ] [ k ] NEW_LINE DEDENT
def containsOdd ( G , src ) : NEW_LINE INDENT colorArr = [ - 1 for i in range ( V ) ] NEW_LINE for i in range ( V ) : NEW_LINE INDENT colorArr [ i ] = - 1 NEW_LINE DEDENT colorArr [ src ] = 1 NEW_LINE q = [ src ] NEW_LINE while ( not q . empty ( ) ) : NEW_LINE INDENT u = q . get ( ) NEW_LINE q . pop ( ) NEW_LINE if ( G [ u ] [ u ] == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT for v in range ( V ) : NEW_LINE INDENT if ( G [ u ] [ v ] == 1 and colorArr [ v ] == - 1 ) : NEW_LINE INDENT colorArr [ v ] = 1 - colorArr [ u ] NEW_LINE q . append ( v ) NEW_LINE DEDENT elif ( G [ u ] [ v ] == 1 and colorArr [ v ] == colorArr [ u ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT
def countSetBits ( n ) : NEW_LINE INDENT if ( n == 0 ) : return 0 NEW_LINE else : NEW_LINE INDENT return 1 + countSetBits ( n & ( n - 1 ) ) NEW_LINE DEDENT DEDENT
def isAnBn ( s ) : NEW_LINE INDENT l = len ( s ) NEW_LINE if ( l % 2 == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 0 NEW_LINE j = l - 1 NEW_LINE while ( i < j ) : NEW_LINE INDENT if ( s [ i ] != ' a ' or s [ j ] != ' b ' ) : NEW_LINE INDENT return False NEW_LINE DEDENT i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT
def getMinSquares ( n ) : NEW_LINE INDENT if ( n <= 3 ) : return n NEW_LINE DEDENT res = n NEW_LINE for x in range ( 1 , n + 1 ) : NEW_LINE INDENT temp = x * x NEW_LINE if ( temp > n ) : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT res = min ( res , 1 + getMinSquares ( n - temp ) ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def maxDistance ( arr , n ) : NEW_LINE INDENT map = dict ( ) NEW_LINE max_dist = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] not in map : NEW_LINE INDENT map [ arr [ i ] ] = i NEW_LINE DEDENT else : NEW_LINE INDENT max_dist = max ( max_dist , i - map [ arr [ i ] ] ) NEW_LINE DEDENT DEDENT return max_dist NEW_LINE DEDENT
def maxSumWO3Consec ( arr , n ) : NEW_LINE INDENT sum = [ 0 ] * n NEW_LINE if n >= 1 : NEW_LINE INDENT sum [ 0 ] = arr [ 0 ] NEW_LINE if n >= 2 : NEW_LINE INDENT sum [ 1 ] = arr [ 0 ] + arr [ 1 ] NEW_LINE DEDENT if n > 2 : NEW_LINE INDENT sum [ 2 ] = max ( sum [ 1 ] , max ( arr [ 1 ] + arr [ 2 ] , arr [ 0 ] + arr [ 2 ] ) ) NEW_LINE DEDENT for i in range ( 3 , n ) : NEW_LINE INDENT sum [ i ] = max ( max ( sum [ i - 1 ] , sum [ i - 2 ] + arr [ i ] ) , arr [ i ] + arr [ i - 1 ] + sum [ i - 3 ] ) NEW_LINE DEDENT return sum [ n - 1 ] NEW_LINE DEDENT
def checkEulerFourSquareIdentity ( a , b ) : NEW_LINE INDENT ab = a * b NEW_LINE flag = False NEW_LINE i = 0 NEW_LINE while ( i * i <= ab ) : NEW_LINE INDENT j = i NEW_LINE while ( i * i + j * j <= ab ) : NEW_LINE INDENT k = j NEW_LINE while ( i * i + j * j + k * k <= ab ) : NEW_LINE INDENT l = math . sqrt ( ab - ( i * i + j * j + k * k ) ) NEW_LINE if ( floor ( l ) == math . ceil ( l ) and l >= k ) : NEW_LINE INDENT flag = True NEW_LINE print ( " i ▁ = ▁ " , i , " \n " , j , " \n " , k , " \n " , l ) NEW_LINE print ( " Product ▁ of ▁ and ▁ b , " ▁ can ▁ be ▁ written ▁ as ▁ sum ▁ of ▁ squares " , " ▁ of ▁ i , ▁ j , ▁ k , ▁ l ▁ " , ab ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if ( flag == False ) : NEW_LINE INDENT print ( " Solution ▁ doesn't ▁ exist ! " ) NEW_LINE return - 1 NEW_LINE DEDENT DEDENT
def nobleInteger ( arr , n ) : NEW_LINE INDENT arr = sorted ( arr ) NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if arr [ i ] == arr [ i + 1 ] : NEW_LINE INDENT continue NEW_LINE DEDENT if arr [ i ] == n - i - 1 : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT if arr [ n - 1 ] == 0 : NEW_LINE INDENT return arr [ n - 1 ] NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def countIslands ( mat , m , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , m ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT if ( mat [ i ] [ j ] == ' X ' ) : NEW_LINE INDENT if ( ( i == 0 or mat [ i - 1 ] [ j ] == ' O ' ) and ( j == 0 or mat [ i ] [ j - 1 ] == ' O ' ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def selectRandom ( x ) : NEW_LINE INDENT count += 1 NEW_LINE if ( count == 1 ) : NEW_LINE INDENT res = x NEW_LINE DEDENT else : NEW_LINE INDENT r = Random ( ) NEW_LINE i = r . nextInt ( count ) NEW_LINE if ( i == count - 1 ) : NEW_LINE INDENT res = x NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def productArray ( arr , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT print ( "0" ) NEW_LINE return NEW_LINE DEDENT prod = [ 1 ] * n NEW_LINE for j in range ( n ) : NEW_LINE INDENT prod [ j ] = 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT prod [ i ] = temp NEW_LINE temp = 1 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT prod [ i ] = temp NEW_LINE temp *= arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( prod [ i ] , end = " ▁ " ) NEW_LINE DEDENT return NEW_LINE DEDENT
def sortedAfterSwap ( A , B , n ) : NEW_LINE INDENT for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( B [ i ] ) : NEW_LINE INDENT j = i NEW_LINE while ( B [ j ] ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT A [ i ] = i + 1 NEW_LINE i = j NEW_LINE DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( A [ i ] != i + 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def maxSubarrayXOR ( arr , n ) : NEW_LINE INDENT ans = - float ( ' inf ' ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT curr_xor = 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT curr_xor = curr_xor ^ arr [ j ] NEW_LINE ans = max ( ans , curr_xor ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def cost ( a , n ) : NEW_LINE INDENT min = a [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( a [ i ] < min ) : NEW_LINE INDENT min = a [ i ] NEW_LINE DEDENT DEDENT return ( n - 1 ) * min NEW_LINE DEDENT
def minRemovalsDP ( arr , n ) : NEW_LINE INDENT longest_start = - 1 NEW_LINE longest_end = 0 NEW_LINE for start in range ( 0 , n ) : NEW_LINE INDENT min = 10000000000 NEW_LINE max = 1000000000 NEW_LINE for end in range ( start , n ) : NEW_LINE INDENT val = arr [ end ] NEW_LINE if val < min : NEW_LINE INDENT min = val NEW_LINE DEDENT if val > max : NEW_LINE INDENT max = val NEW_LINE DEDENT if ( 2 * min <= max ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( end - start > longest_end - longest_start or longest_start == - 1 ) : NEW_LINE INDENT longest_start = start NEW_LINE longest_end = end NEW_LINE DEDENT DEDENT DEDENT if longest_start == - 1 : NEW_LINE INDENT return n NEW_LINE DEDENT return ( n - ( longest_end - longest_start + 1 ) ) NEW_LINE DEDENT
def getInvCount ( arr , n ) : NEW_LINE INDENT invcount = 0 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT small = 0 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] ) : NEW_LINE INDENT small += 1 NEW_LINE DEDENT DEDENT great = 0 NEW_LINE for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] < arr [ j ] ) : NEW_LINE INDENT great += 1 NEW_LINE DEDENT invcount += great * small NEW_LINE DEDENT DEDENT return invcount NEW_LINE DEDENT
def surface_area_octahedron ( side ) : NEW_LINE INDENT return ( 2 * ( math . sqrt ( 3 ) ) * ( side * side ) ) NEW_LINE DEDENT
def gnomeSort ( arr , n ) : NEW_LINE INDENT index = 0 NEW_LINE while ( index < n ) : NEW_LINE INDENT if ( index == 0 ) : NEW_LINE INDENT index += 1 NEW_LINE DEDENT if ( arr [ index ] >= arr [ index - 1 ] ) : NEW_LINE INDENT index += 1 NEW_LINE DEDENT else : NEW_LINE INDENT temp = 0 NEW_LINE arr [ index ] , arr [ index - 1 ] = arr [ index - 1 ] , arr [ index ] NEW_LINE index -= 1 NEW_LINE DEDENT DEDENT return NEW_LINE DEDENT
def find ( n , k ) : NEW_LINE INDENT if ( n + 1 >= k ) : NEW_LINE INDENT return ( k - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( 2 * n + 1 - k ) NEW_LINE DEDENT DEDENT
def countUnique ( mat , n , m ) : NEW_LINE INDENT rowsum = [ 0 ] * n NEW_LINE colsum = [ 0 ] * m NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( mat [ i ] [ j ] != 0 ) : NEW_LINE INDENT rowsum [ i ] += 1 NEW_LINE colsum [ j ] += 1 NEW_LINE DEDENT DEDENT uniquecount = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( mat [ i ] [ j ] != 0 and rowsum [ i ] == 1 and colsum [ j ] == 1 ) : NEW_LINE INDENT uniquecount += 1 NEW_LINE DEDENT DEDENT DEDENT return uniquecount NEW_LINE DEDENT
def generate ( ones , zeroes , str , len ) : NEW_LINE INDENT if ( len == len ( str ) ) : NEW_LINE INDENT print ( str , end = " ▁ " ) NEW_LINE return NEW_LINE DEDENT generate ( ones + 1 , zeroes , str + "1" , len ) NEW_LINE if ( ones > zeroes ) : NEW_LINE INDENT generate ( ones , zeroes + 1 , str + "0" , len ) NEW_LINE DEDENT DEDENT
def midPointCircleDraw ( x_centre , y_centre , r ) : NEW_LINE INDENT x = r NEW_LINE y = 0 NEW_LINE if r > 0 : NEW_LINE INDENT print ( " ( " , x + x_centre , " , ▁ " , ( - y + y_centre ) , " ) " ) NEW_LINE print ( " ( " , x + x_centre , " , ▁ " , ( x + y_centre ) , " ) " ) NEW_LINE if r > 0 : NEW_LINE INDENT print ( " ( " , x + x_centre , " , ▁ " , ( - y + y_centre ) , " ) " ) NEW_LINE DEDENT print ( " ( " , ( - y + x_centre ) , " , ▁ " , ( x + y_centre ) , " ) " ) NEW_LINE DEDENT P = 1 - r NEW_LINE while x > y : NEW_LINE INDENT y += 1 NEW_LINE if ( P <= 0 ) : NEW_LINE INDENT P = P + 2 * y + 1 NEW_LINE DEDENT else : NEW_LINE INDENT x -= 1 NEW_LINE P = P + 2 * y - 2 * x + 1 NEW_LINE DEDENT if x < y : NEW_LINE INDENT break NEW_LINE DEDENT print ( " ( " , x + x_centre , " , ▁ " , ( y + y_centre ) , " ) " ) NEW_LINE print ( " ( " , ( - x + x_centre ) , " , ▁ " , ( - y + y_centre ) , " ) " ) NEW_LINE print ( " ( " , y + x_centre , " , ▁ " , x + y_centre ) , " ) " ) NEW_LINE DEDENT print ( " , y + x_centre , " , ▁ " , " ) NEW_LINE DEDENT
def printFactorialNums ( n ) : NEW_LINE INDENT fact = 1 NEW_LINE x = 2 NEW_LINE while ( fact <= n ) : NEW_LINE INDENT print ( fact , end = " ▁ " ) NEW_LINE fact = fact * x NEW_LINE x += 1 NEW_LINE DEDENT DEDENT
def countFriendsPairings ( n ) : NEW_LINE INDENT dp = [ 0 for _ in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if i <= 2 : NEW_LINE INDENT dp [ i ] = i NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] NEW_LINE DEDENT DEDENT return dp [ n ] NEW_LINE DEDENT
def remainder ( str ) : NEW_LINE INDENT lenn = len ( str ) NEW_LINE num = 0 NEW_LINE rem = 0 NEW_LINE for i in range ( lenn ) : NEW_LINE INDENT num = rem * 10 + ( ord ( str [ i ] ) - ord ( '0' ) ) NEW_LINE rem = num % 11 NEW_LINE DEDENT return rem NEW_LINE DEDENT
def findNth ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for curr in range ( 1 , n + 1 ) : NEW_LINE INDENT sum = 0 NEW_LINE for x in range ( curr ) : NEW_LINE INDENT sum = sum + x % 10 NEW_LINE DEDENT if ( sum == 10 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( count == n ) : NEW_LINE INDENT return curr NEW_LINE DEDENT DEDENT
def sortedAfterSwap ( A , B , n ) : NEW_LINE INDENT t = 0 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( B [ i ] != 0 ) : NEW_LINE INDENT if ( A [ i ] != i + 1 ) : NEW_LINE INDENT t = A [ i ] NEW_LINE DEDENT A [ i ] = A [ i + 1 ] NEW_LINE A [ i + 1 ] = t NEW_LINE DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( A [ i ] != i + 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT
def maximumSum ( arr , n , k ) : NEW_LINE INDENT for i in range ( 1 , k + 1 ) : NEW_LINE INDENT min = + 2147483647 NEW_LINE index = - 1 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( arr [ j ] < min ) : NEW_LINE INDENT min = arr [ j ] NEW_LINE index = j NEW_LINE DEDENT DEDENT if ( min == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT arr [ index ] = - arr [ index ] NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT return sum NEW_LINE DEDENT
def printSquares ( n ) : NEW_LINE INDENT square = 0 NEW_LINE odd = 1 NEW_LINE for x in range ( n ) : NEW_LINE INDENT print ( square , end = " ▁ " ) NEW_LINE square = square + odd NEW_LINE odd = odd + 2 NEW_LINE DEDENT DEDENT
def checkReverse ( arr , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT i = 1 NEW_LINE while ( arr [ i - 1 ] < arr [ i ] and i < n ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT if ( i == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT j = i + 1 NEW_LINE while ( arr [ j ] < arr [ j - 1 ] ) : NEW_LINE INDENT if ( i > 1 and arr [ j ] < arr [ i - 2 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if ( j == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT k = j NEW_LINE if ( arr [ k ] < arr [ i - 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT while ( k > 1 and k < n ) : NEW_LINE INDENT if ( arr [ k ] < arr [ k - 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT k += 1 NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def vol_of_octahedron ( side ) : NEW_LINE INDENT return ( side * side * side ) * ( math . sqrt ( 2 ) / 3 ) ) NEW_LINE DEDENT
def numberOfPaths ( m , n ) : NEW_LINE INDENT if ( m == 1 or n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return numberOfPaths ( m - 1 , n ) + numberOfPaths ( m , n - 1 ) NEW_LINE DEDENT
def binarySearch ( arr , l , r , x ) : NEW_LINE INDENT if ( r >= l ) : NEW_LINE INDENT mid = l + ( r - l ) // 2 NEW_LINE if ( arr [ mid ] == x ) : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( arr [ mid ] > x ) : NEW_LINE INDENT return binarySearch ( arr , l , mid - 1 , x ) NEW_LINE DEDENT return binarySearch ( arr , mid + 1 , r , x ) NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def numberOfPaths ( m , n ) : NEW_LINE INDENT count = [ [ 0 for i in range ( n ) ] for j in range ( m ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT count [ i ] [ 0 ] = 1 NEW_LINE DEDENT for j in range ( n ) : NEW_LINE INDENT count [ 0 ] [ j ] = 1 NEW_LINE DEDENT for i in range ( 1 , m ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT count [ i ] [ j ] = count [ i - 1 ] [ j ] + count [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT return count [ m - 1 ] [ n - 1 ] NEW_LINE DEDENT
def answer ( n ) : NEW_LINE INDENT dp = [ [ 0 for j in range ( n + 1 ) ] for j in range ( 10 ) ] NEW_LINE if ( n == 1 ) : NEW_LINE INDENT return 10 NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT for j in range ( 0 , 9 ) : NEW_LINE INDENT if ( j == 0 ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] NEW_LINE DEDENT elif ( j == 9 ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] NEW_LINE DEDENT DEDENT DEDENT sum = 0 NEW_LINE for j in range ( 1 , 9 ) : NEW_LINE INDENT sum += dp [ n ] [ j ] NEW_LINE DEDENT return sum NEW_LINE DEDENT
def maxDifference ( arr , N , k ) : NEW_LINE INDENT S = 0 NEW_LINE S1 = 0 NEW_LINE max_difference = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT S += arr [ i ] NEW_LINE DEDENT temp = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT if arr [ i ] < arr [ j ] : NEW_LINE INDENT arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ] NEW_LINE arr [ j ] = arr [ i ] NEW_LINE arr [ i ] = arr [ j ] NEW_LINE arr [ j ] = arr [ j ] NEW_LINE DEDENT DEDENT DEDENT M = max ( k , N - k ) NEW_LINE for i in range ( M ) : NEW_LINE INDENT S1 += arr [ i ] NEW_LINE DEDENT max_difference = S1 - ( S - S1 ) NEW_LINE return max_difference NEW_LINE DEDENT
def maxSumSubarrayRemovingOneEle ( arr , n ) : NEW_LINE INDENT fw = [ 0 ] * n NEW_LINE bw = [ 0 ] * n NEW_LINE cur_max = arr [ 0 ] NEW_LINE max_so_far = arr [ 0 ] NEW_LINE fw [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT cur_max = max ( arr [ i ] , cur_max + arr [ i ] ) NEW_LINE max_so_far = max ( max_so_far , cur_max ) NEW_LINE bw [ i ] = cur_max NEW_LINE DEDENT cur_max = max_so_far = bw [ n - 1 ] = arr [ n - 1 ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT cur_max = max ( arr [ i ] , cur_max + arr [ i ] ) NEW_LINE max_so_far = max ( max_so_far , cur_max ) NEW_LINE bw [ i ] = cur_max NEW_LINE DEDENT fans = max_so_far NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT fans = max ( fans , fw [ i - 1 ] + bw [ i + 1 ] ) NEW_LINE DEDENT return fans NEW_LINE DEDENT
def moveSpaceInFront ( st ) : NEW_LINE INDENT i = len ( st ) - 1 NEW_LINE j = i NEW_LINE while ( j >= 0 ) : NEW_LINE INDENT if ( st [ j ] != ' ▁ ' ) : NEW_LINE INDENT st [ i - 1 ] = st [ j ] NEW_LINE DEDENT j -= 1 NEW_LINE DEDENT while ( i >= 0 ) : NEW_LINE INDENT st [ i - 1 ] = ' ▁ ' NEW_LINE DEDENT while ( i >= 0 ) : NEW_LINE INDENT st [ i ] = ' ▁ ' NEW_LINE DEDENT DEDENT
def recaman ( n ) : NEW_LINE INDENT arr = [ 0 for i in range ( n ) ] NEW_LINE arr [ 0 ] = 0 NEW_LINE arr [ 0 ] = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT curr = arr [ i - 1 ] - i NEW_LINE j = 0 NEW_LINE while ( j < i ) : NEW_LINE INDENT if ( ( arr [ j ] == curr ) or curr < 0 ) : NEW_LINE INDENT curr = arr [ i - 1 ] + i NEW_LINE break NEW_LINE DEDENT DEDENT arr [ i ] = curr NEW_LINE print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def findMaxPoints ( A ) : NEW_LINE INDENT P1S = [ [ 0 for i in range ( 10 ) ] for j in range ( 10 ) ] NEW_LINE P1E = [ [ 0 for i in range ( 10 ) ] for j in range ( M + 2 ) ] NEW_LINE P2S = [ [ 0 for i in range ( 10 ) ] for j in range ( 1 , M + 2 ) ] NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( 1 , M + 1 ) : NEW_LINE INDENT P1S [ i ] [ j ] = max ( P1S [ i - 1 ] [ j ] , P1S [ i ] [ j - 1 ] ) + A [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT DEDENT for i in range ( N , 1 , M + 1 ) : NEW_LINE INDENT for j in range ( 1 , M + 1 ) : NEW_LINE INDENT P1E [ i ] [ j ] = max ( P1E [ i + 1 ] [ j ] , P1E [ i ] [ j + 1 ] ) + A [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT DEDENT for i in range ( 2 , N + 1 ) : NEW_LINE INDENT for j in range ( 2 , M + 1 ) : NEW_LINE INDENT op1 = P1S [ i ] [ j - 1 ] + P1E [ i ] [ j + 1 ] + P2S [ i ] [ j ] + P2E [ i ] [ j + 1 ] NEW_LINE DEDENT op2 = P2E [ i ] [ j - 1 ] + P1E [ i ] [ j + 1 ] + P2E [ i - 1 ] [ j ] NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT for j in range ( 2 , M ) : NEW_LINE INDENT print ( op1 ) NEW_LINE DEDENT DEDENT
def KnapSack ( val , wt , n , W ) : NEW_LINE INDENT mat = [ [ 0 for i in range ( W + 1 ) ] for j in range ( W + 1 ) ] NEW_LINE i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT j = 0 NEW_LINE if ( i % 2 != 0 ) : NEW_LINE INDENT while ( ++ j <= W ) : NEW_LINE INDENT if ( wt [ i ] <= j ) : NEW_LINE INDENT mat [ 1 ] [ j ] = max ( val [ i ] + mat [ 0 ] [ j - wt [ i ] ] , mat [ 0 ] [ j ] ) NEW_LINE DEDENT else : NEW_LINE INDENT mat [ 1 ] [ j ] = mat [ 0 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT i += 1 NEW_LINE DEDENT return ( n % 2 != 0 ) ? mat [ 0 ] [ W ] : mat [ 1 ] [ W ] NEW_LINE DEDENT
def modInverse ( a , m ) : NEW_LINE INDENT a = a % m NEW_LINE for x in range ( 1 , m ) : NEW_LINE INDENT if ( ( a * x ) % m == 1 ) : NEW_LINE INDENT return x NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT
def lenghtOfLongestAP ( set , n ) : NEW_LINE INDENT if ( n <= 2 ) : return n NEW_LINE DEDENT L = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] NEW_LINE llap = 2 NEW_LINE for i in range ( n ) : NEW_LINE INDENT L [ i ] [ n - 1 ] = 2 NEW_LINE DEDENT for j in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT i = j - 1 NEW_LINE k = j + 1 NEW_LINE while ( i >= 0 and k <= n - 1 ) : NEW_LINE INDENT if ( set [ i ] + set [ k ] < 2 * set [ j ] ) : NEW_LINE INDENT k += 1 NEW_LINE DEDENT elif ( set [ i ] + set [ k ] > 2 * set [ j ] ) : NEW_LINE INDENT L [ i ] [ j ] = 2 NEW_LINE i -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] = L [ j ] [ k ] + 1 NEW_LINE llap = max ( llap , L [ i ] [ j ] ) NEW_LINE i -= 1 NEW_LINE k += 1 NEW_LINE DEDENT DEDENT while i >= 0 : NEW_LINE INDENT L [ i ] [ j ] = 2 NEW_LINE i -= 1 NEW_LINE DEDENT DEDENT return llap NEW_LINE DEDENT
def countOfBinaryNumberLessThanN ( N ) : NEW_LINE INDENT q = queue . Queue ( ) NEW_LINE q . put ( 1 ) NEW_LINE cnt = 0 NEW_LINE while ( not q . empty ( ) ) : NEW_LINE INDENT t = q [ 0 ] NEW_LINE q . get ( ) NEW_LINE if ( t <= N ) : NEW_LINE INDENT cnt += 1 NEW_LINE q . put ( t * 10 ) NEW_LINE q . put ( t * 10 + 1 ) NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT
def findIndex ( n ) : NEW_LINE INDENT if ( n <= 1 ) : return n NEW_LINE DEDENT a = 0 NEW_LINE b = 1 NEW_LINE c = 1 NEW_LINE res = 1 NEW_LINE while ( c < n ) : NEW_LINE INDENT c = a + b NEW_LINE res += 1 NEW_LINE a = b NEW_LINE b = c NEW_LINE DEDENT return res NEW_LINE DEDENT
def substringConversions ( str , k , b ) : NEW_LINE INDENT i = 0 NEW_LINE sum = 0 NEW_LINE counter = k - 1 NEW_LINE for i in range ( k ) : NEW_LINE INDENT Sum = ( int ) ( Sum + ( ( str [ i ] - ord ( '0' ) * pow ( b , counter ) ) ) NEW_LINE counter -= 1 NEW_LINE DEDENT print ( Sum , end = " ▁ " ) NEW_LINE prev = Sum NEW_LINE sum = 0 NEW_LINE counter = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT Sum = ( prev - ( ( ord ( str [ i - k ] ) - ord ( '0' ) * math . pow ( b , k - 1 ) ) ) NEW_LINE Sum = sum * b NEW_LINE Sum = sum + ord ( str [ i ] ) - ord ( '0' ) ) NEW_LINE print ( Sum , end = " ▁ " ) NEW_LINE prev = Sum NEW_LINE counter += 1 NEW_LINE DEDENT DEDENT
def maxSumPairWithDifferenceLessThanK ( arr , N , k ) : NEW_LINE INDENT maxSum = 0 NEW_LINE arr . sort ( ) NEW_LINE i = N - 1 NEW_LINE while i > 0 : NEW_LINE INDENT if ( arr [ i ] - arr [ i - 1 ] < k ) : NEW_LINE INDENT maxSum += arr [ i ] NEW_LINE maxSum += arr [ i - 1 ] NEW_LINE i -= 1 NEW_LINE DEDENT DEDENT return maxSum NEW_LINE DEDENT
def longestRepeatedSubSeq ( Str ) : NEW_LINE INDENT n = len ( Str ) NEW_LINE dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( Str [ i - 1 ] == Str [ j - 1 ] and i != j ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT res = " " NEW_LINE i = n NEW_LINE j = n NEW_LINE while i > 0 and j > 0 : NEW_LINE INDENT if ( dp [ i ] [ j ] == dp [ i - 1 ] [ j - 1 ] + 1 ) : NEW_LINE INDENT res = res + Str [ i - 1 ] NEW_LINE i -= 1 NEW_LINE j -= 1 NEW_LINE DEDENT elif ( dp [ i ] [ j ] == dp [ i - 1 ] [ j ] ) : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT DEDENT reverse = " " NEW_LINE for k in range ( len ( res ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT reverse = reverse + res [ k ] NEW_LINE DEDENT return reverse NEW_LINE DEDENT
def isHeap ( arr , n ) : NEW_LINE INDENT for i in range ( ( n - 2 ) // 2 + 1 ) : NEW_LINE INDENT if ( arr [ 2 * i + 1 ] > arr [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( 2 * i + 2 < n and arr [ 2 * i + 2 ] > arr [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def calculateEnergy ( mat , n ) : NEW_LINE INDENT tot_energy = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT q = mat [ i ] [ j ] / n NEW_LINE i_des = q NEW_LINE j_des = mat [ i ] [ j ] - ( n * q ) NEW_LINE tot_energy += abs ( i_des - i ) + abs ( j_des - j ) NEW_LINE DEDENT DEDENT return tot_energy NEW_LINE DEDENT
def rearrange ( a , size ) : NEW_LINE INDENT positive = 0 NEW_LINE negative = 1 NEW_LINE while ( positive < size and a [ positive ] >= 0 ) : NEW_LINE INDENT positive += 2 NEW_LINE DEDENT while ( negative < size and a [ negative ] <= 0 ) : NEW_LINE INDENT negative += 2 NEW_LINE DEDENT if ( positive < size and negative < size ) : NEW_LINE INDENT a [ positive ] , a [ negative ] = a [ negative ] , a [ positive ] NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT
def antiSpiralTraversal ( m , n , a ) : NEW_LINE INDENT k = 0 l = 0 NEW_LINE stk = [ ] NEW_LINE while ( k <= m and l <= n ) : NEW_LINE INDENT for i in range ( l , n + 1 ) : NEW_LINE INDENT stk . append ( a [ k ] [ i ] ) NEW_LINE k += 1 NEW_LINE DEDENT for i in range ( k , m + 1 ) : NEW_LINE INDENT stk . append ( a [ i ] [ n ] ) NEW_LINE n -= 1 NEW_LINE DEDENT if ( k <= m ) : NEW_LINE INDENT for i in range ( n , l - 1 , - 1 ) : NEW_LINE INDENT stk . append ( a [ m ] [ i ] ) NEW_LINE m -= 1 NEW_LINE DEDENT if ( l <= n ) : NEW_LINE INDENT for i in range ( m , k - 1 , - 1 ) : NEW_LINE INDENT stk . append ( a [ i ] [ l ] ) NEW_LINE l += 1 NEW_LINE DEDENT DEDENT while ( stk . empty ( ) ) : NEW_LINE INDENT print ( stk . queue [ 0 ] , end = " ▁ " ) NEW_LINE stk . pop ( ) NEW_LINE DEDENT DEDENT
def maxProduct ( arr , n ) : NEW_LINE INDENT if n < 2 : NEW_LINE INDENT print ( " No ▁ pairs ▁ exists " ) NEW_LINE return - 1 NEW_LINE DEDENT if n == 2 : NEW_LINE INDENT print ( arr [ 0 ] , arr [ 1 ] ) NEW_LINE return - 1 NEW_LINE DEDENT posa = - 1 NEW_LINE posb = - 1 NEW_LINE nega = - 1 NEW_LINE negb = - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if arr [ i ] > posa : NEW_LINE INDENT posb = posa NEW_LINE posa = arr [ i ] NEW_LINE DEDENT elif arr [ i ] < 0 and abs ( arr [ i ] ) > abs ( nega ) : NEW_LINE INDENT negb = nega NEW_LINE nega = arr [ i ] NEW_LINE DEDENT elif arr [ i ] < 0 and abs ( arr [ i ] ) > abs ( negb ) : NEW_LINE INDENT negb = arr [ i ] NEW_LINE DEDENT DEDENT if ( nega * negb > posa * posb ) : NEW_LINE INDENT print ( " Max ▁ product ▁ pair ▁ is { " , nega , " , ▁ " , negb , " } " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Max ▁ product ▁ pair ▁ is { " , posa , " , ▁ " , posb , " } " ) NEW_LINE DEDENT DEDENT
def findMaxVal ( arr , n , num , maxLimit ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( maxLimit + 1 ) ] for j in range ( n ) ] NEW_LINE for ind in range ( n ) : NEW_LINE INDENT for val in range ( maxLimit + 1 ) : NEW_LINE INDENT if ( num - arr [ ind ] == val or num + arr [ ind ] == val ) : NEW_LINE INDENT dp [ ind ] [ val ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ ind ] [ val ] = 0 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( val - arr [ ind ] >= 0 and val + arr [ ind ] <= maxLimit ) : NEW_LINE INDENT if ( dp [ ind - 1 ] [ val - arr [ ind ] ] == 1 or dp [ ind - 1 ] [ val + arr [ ind ] ] == 1 ) : NEW_LINE INDENT dp [ ind ] [ val ] = 1 NEW_LINE DEDENT DEDENT elif ( val + arr [ ind ] <= maxLimit ) : NEW_LINE INDENT dp [ ind ] [ val ] = dp [ ind - 1 ] [ val + arr [ ind ] ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ ind ] [ val ] = 0 NEW_LINE DEDENT DEDENT DEDENT for val in range ( maxLimit , - 1 , - 1 ) : NEW_LINE INDENT if ( dp [ n - 1 ] [ val ] == 1 ) : NEW_LINE INDENT return val NEW_LINE DEDENT DEDENT
def Resources ( process , need ) : NEW_LINE INDENT minResources = 0 NEW_LINE minResources = process * ( need - 1 ) + 1 NEW_LINE return minResources NEW_LINE DEDENT
def bubbleSort ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n - 1 ) : NEW_LINE INDENT for j in range ( 0 , n - i - 1 ) : NEW_LINE INDENT if ( arr [ j ] > arr [ j + 1 ] ) : NEW_LINE INDENT arr [ j ] , arr [ j + 1 ] = arr [ j + 1 ] , arr [ j ] NEW_LINE j + 1 ] NEW_LINE DEDENT DEDENT DEDENT
def superSeq ( x , y , m , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( m + 1 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT dp [ i ] [ j ] = j NEW_LINE DEDENT elif j == 0 : NEW_LINE INDENT dp [ i ] [ j ] = i NEW_LINE DEDENT elif x [ i - 1 ] == y [ j - 1 ] : NEW_LINE INDENT dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = 1 + min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ m ] [ n ] NEW_LINE DEDENT
def countIntegralSolutions ( n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n - i + 1 ) : NEW_LINE INDENT for k in range ( 0 , ( n - i - j ) + 1 ) : NEW_LINE INDENT if ( i + j + k == n ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
def minJumps ( arr , n ) : NEW_LINE INDENT jumps = [ 0 ] * n NEW_LINE jumps [ n - 1 ] = 0 NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if arr [ i ] == 0 : NEW_LINE INDENT jumps [ i ] = sys . maxsize NEW_LINE DEDENT elif arr [ i ] >= n - i - 1 : NEW_LINE INDENT jumps [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT min = sys . maxsize NEW_LINE for j in range ( i + 1 , n and j <= arr [ i ] + i ) : NEW_LINE INDENT if min > jumps [ j ] : NEW_LINE INDENT min = jumps [ j ] NEW_LINE DEDENT DEDENT if min != sys . maxsize : NEW_LINE INDENT jumps [ i ] = min + 1 NEW_LINE DEDENT else : NEW_LINE INDENT jumps [ i ] = min NEW_LINE DEDENT DEDENT return jumps [ 0 ] NEW_LINE DEDENT
def minAdjustmentCost ( A , n , M , target ) : NEW_LINE INDENT dp = [ [ 0 for j in range ( M + 1 ) ] for i in range ( n ) ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( M + 1 ) : NEW_LINE INDENT dp [ 0 ] [ j ] = abs ( j - A [ 0 ] ) NEW_LINE DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( M + 1 ) : NEW_LINE INDENT k = max ( j - target , 0 ) NEW_LINE for k in range ( min ( M , j + target ) + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ i - 1 ] [ k ] + abs ( A [ i ] - j ) ) NEW_LINE DEDENT DEDENT DEDENT res = sys . maxsize NEW_LINE for j in range ( M + 1 ) : NEW_LINE INDENT res = min ( res , dp [ n - 1 ] [ j ] ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def kthSmallest ( arr , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE return arr [ k - 1 ] NEW_LINE DEDENT
def minCost ( cost ) : NEW_LINE INDENT dist = [ None ] * N NEW_LINE for i in range ( N ) : NEW_LINE INDENT dist [ i ] = INF NEW_LINE DEDENT dist [ 0 ] = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT if ( dist [ j ] > dist [ i ] + cost [ i ] [ j ] ) : NEW_LINE INDENT dist [ j ] = dist [ i ] + cost [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return dist [ N - 1 ] NEW_LINE DEDENT
def reversingString ( str , start , end ) : NEW_LINE INDENT while ( start < end ) : NEW_LINE INDENT str [ start ] ^= str [ end ] NEW_LINE str [ end ] ^= str [ start ] NEW_LINE start += 1 NEW_LINE -- end NEW_LINE DEDENT return ' ' . join ( str ) NEW_LINE DEDENT
def minimalSteps ( s , n ) : NEW_LINE INDENT dp = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp [ i ] = sys . maxint NEW_LINE DEDENT s1 = " " NEW_LINE s2 = " " NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT s1 += s [ i ] NEW_LINE s2 = s [ i + 1 : i + 1 ] NEW_LINE DEDENT dp [ i ] = min ( dp [ i ] , dp [ i - 1 ] + 1 ) NEW_LINE if ( s1 == s2 ) : NEW_LINE INDENT dp [ i * 2 + 1 ] = min ( dp [ i ] + 1 , dp [ i * 2 + 1 ] ) NEW_LINE DEDENT DEDENT return dp [ n - 1 ] NEW_LINE DEDENT
def MinimumCost ( cost , n , W ) : NEW_LINE INDENT val = [ ] NEW_LINE wt = [ ] NEW_LINE size = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( cost [ i ] != - 1 ) : NEW_LINE INDENT val . append ( cost [ i ] ) NEW_LINE wt . append ( i + 1 ) NEW_LINE size += 1 NEW_LINE DEDENT DEDENT n = size NEW_LINE min_cost = [ [ 0 for i in range ( W + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , W + 1 ) : NEW_LINE INDENT if ( wt [ i - 1 ] > j ) : NEW_LINE INDENT min_cost [ i ] [ j ] = min_cost [ i - 1 ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT min_cost [ i ] [ j ] = min ( min_cost [ i - 1 ] [ j ] , min_cost [ i ] [ j - wt [ i - 1 ] + val [ i - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return ( min_cost [ n ] [ W ] == - 1 ) ? - 1 : min_cost [ n ] [ W ] NEW_LINE DEDENT
def bitonicGenerator ( arr , n ) : NEW_LINE INDENT evenArr = [ ] NEW_LINE oddArr = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i % 2 != 1 ) : NEW_LINE INDENT evenArr . append ( arr [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT oddArr . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( i % 2 != 1 ) : NEW_LINE INDENT evenArr . append ( arr [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT oddArr . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT i = 0 NEW_LINE for j in range ( len ( evenArr ) ) : NEW_LINE INDENT arr [ i ] = evenArr [ j ] NEW_LINE DEDENT for j in range ( len ( oddArr ) ) : NEW_LINE INDENT arr [ i ] = oddArr [ j ] NEW_LINE DEDENT DEDENT
def countDivisibles ( arr , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] % arr [ j ] == 0 or arr [ j ] % arr [ i ] == 0 ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT
def lis ( arr , n ) : NEW_LINE INDENT max_ref = 1 NEW_LINE _lis ( arr , n ) NEW_LINE return max_ref NEW_LINE DEDENT
def printFirstRepeating ( arr ) : NEW_LINE INDENT sett = set ( ) NEW_LINE min = - 1 NEW_LINE for i in range ( len ( arr ) - 1 ) : NEW_LINE INDENT if arr [ i ] in sett : NEW_LINE INDENT min = i NEW_LINE DEDENT else : NEW_LINE INDENT sett . add ( arr [ i ] ) NEW_LINE DEDENT DEDENT if min != - 1 : NEW_LINE INDENT print ( " The ▁ first ▁ repeating ▁ element ▁ is " , arr [ min ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " There ▁ are ▁ no ▁ repeating ▁ elements " ) NEW_LINE DEDENT DEDENT
def minCoins ( coins , m , V ) : NEW_LINE INDENT if ( V == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT res = 10 ** 9 NEW_LINE for i in range ( m ) : NEW_LINE INDENT if ( coins [ i ] <= V ) : NEW_LINE INDENT sub_res = minCoins ( coins , m , V - coins [ i ] ) NEW_LINE if ( sub_res != 10 ** 9 and sub_res + 1 < res ) : NEW_LINE INDENT res = sub_res + 1 NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT
def pairSum ( mat , n , sum ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT mat . sort ( ) NEW_LINE DEDENT for i in range ( 0 , n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT left = 0 NEW_LINE right = n - 1 NEW_LINE while ( left < n and right >= 0 ) : NEW_LINE INDENT if ( ( mat [ i ] [ left ] + mat [ j ] [ right ] ) == sum ) : NEW_LINE INDENT print ( " ( " , mat [ i ] [ left ] , ' , ▁ ' , mat [ j ] [ right ] , ' ) , ▁ ' ) NEW_LINE left += 1 NEW_LINE right -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( ( mat [ i ] [ left ] + mat [ j ] [ right ] ) < sum ) : NEW_LINE INDENT left += 1 NEW_LINE DEDENT else : NEW_LINE INDENT right -= 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT
def minimum_cost ( a , n ) : NEW_LINE INDENT mn = + 2147483647 NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT mn = min ( a [ i ] , mn ) NEW_LINE sum += a [ i ] NEW_LINE DEDENT return mn * ( sum - mn ) NEW_LINE DEDENT
def lps ( seq ) : NEW_LINE INDENT n = len ( seq ) NEW_LINE L = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT L [ i ] [ i ] = 1 NEW_LINE DEDENT for cl in range ( 2 , n + 1 ) : NEW_LINE INDENT for i in range ( n - cl + 1 ) : NEW_LINE INDENT j = i + cl - 1 NEW_LINE if ( seq [ i ] == seq [ j ] and cl == 2 ) : NEW_LINE INDENT L [ i ] [ j ] = 2 NEW_LINE DEDENT elif ( seq [ i ] == seq [ j ] ) : NEW_LINE INDENT L [ i ] [ j ] = L [ i + 1 ] [ j - 1 ] + 2 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] = max ( L [ i ] [ j - 1 ] , L [ i + 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return L [ 0 ] [ n - 1 ] NEW_LINE DEDENT
def censor ( text , word ) : NEW_LINE INDENT word_list = text . split ( " \\s + " ) NEW_LINE result = " " NEW_LINE stars = " " NEW_LINE for i in range ( len ( word ) ) : NEW_LINE INDENT stars += ' * ' NEW_LINE DEDENT index = 0 NEW_LINE for i in range ( len ( word_list ) ) : NEW_LINE INDENT if ( i == word ) : NEW_LINE INDENT word_list [ index ] = stars NEW_LINE index += 1 NEW_LINE DEDENT DEDENT for i in word_list : NEW_LINE INDENT result += i + ' ▁ ' NEW_LINE DEDENT return result NEW_LINE DEDENT
def isPowerOfFour ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT while ( n != 1 ) : NEW_LINE INDENT if ( n % 4 != 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT n = n // 4 NEW_LINE DEDENT return 1 NEW_LINE DEDENT
def getArea ( a ) : NEW_LINE INDENT area = ( float ) ( math . PI * a * a ) / 4 NEW_LINE return area NEW_LINE DEDENT
def distancesum ( x , y , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT sum += ( abs ( x [ i ] - x [ j ] ) + abs ( y [ i ] - y [ j ] ) ) NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def findMax ( arr , N ) : NEW_LINE INDENT row = 0 NEW_LINE i = 0 NEW_LINE j = N - 1 NEW_LINE for i in range ( N ) : NEW_LINE INDENT while ( j >= 0 and arr [ i ] [ j ] == 1 ) : NEW_LINE INDENT row = i NEW_LINE j -= 1 NEW_LINE DEDENT DEDENT print ( " Row ▁ number ▁ = ▁ " , row + 1 ) NEW_LINE print ( " , ▁ MaxCount ▁ = " , ( N - 1 - j ) ) NEW_LINE DEDENT
def lastNon0Digit ( n ) : NEW_LINE INDENT if ( n < 10 ) : NEW_LINE INDENT return dig [ n ] NEW_LINE DEDENT if ( ( ( n // 10 ) % 10 ) % 2 == 0 ) : NEW_LINE INDENT return ( 6 * lastNon0Digit ( n // 5 ) * dig [ n % 10 ] ) % 10 NEW_LINE DEDENT else : NEW_LINE INDENT return ( 4 * lastNon0Digit ( n // 5 ) * dig [ n % 10 ] ) % 10 NEW_LINE DEDENT DEDENT
def evenFibSum ( limit ) : NEW_LINE INDENT if ( limit < 2 ) : return 0 NEW_LINE DEDENT ef1 = 0 NEW_LINE ef2 = 2 NEW_LINE sum = ef1 + ef2 NEW_LINE while ( ef2 <= limit ) : NEW_LINE INDENT ef3 = 4 * ef2 + ef1 NEW_LINE if ( ef3 > limit ) : NEW_LINE INDENT break NEW_LINE DEDENT ef1 = ef2 NEW_LINE ef2 = ef3 NEW_LINE sum += ef2 NEW_LINE DEDENT return sum NEW_LINE DEDENT
def search ( arr , n , x ) : NEW_LINE INDENT i = 0 NEW_LINE while i < n : NEW_LINE INDENT if arr [ i ] == x : NEW_LINE INDENT return i NEW_LINE DEDENT i = i + abs ( arr [ i ] - x ) NEW_LINE DEDENT print ( " number ▁ is ▁ not " , " ▁ present ! " ) NEW_LINE return - 1 NEW_LINE DEDENT
def isRotated ( str1 , str2 ) : NEW_LINE INDENT if ( len ( str1 ) != len ( str2 ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT clock_rot = " " NEW_LINE anticlock_rot = " " NEW_LINE len = len ( str2 ) NEW_LINE anticlock_rot = anticlock_rot + str2 [ len - 2 : len ] + str2 [ 0 : len - 2 ] NEW_LINE clock_rot = clock_rot + str2 [ 2 : ] + str2 [ 0 : 2 ] NEW_LINE return ( str1 . equals ( clock_rot ) or str1 . equals ( anticlock_rot ) ) NEW_LINE DEDENT
def printHosoya ( n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] NEW_LINE dp [ 0 ] [ 0 ] = dp [ 1 ] [ 0 ] = 1 NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( i > j ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 2 ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 2 ] [ j - 2 ] NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 ) : NEW_LINE INDENT print ( dp [ i ] [ j ] , end = " ▁ " ) NEW_LINE DEDENT print ( " " ) NEW_LINE DEDENT DEDENT
def findSubArray ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE maxsize = - 1 NEW_LINE startindex = 0 NEW_LINE endindex = 0 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT sum = 0 NEW_LINE if ( arr [ i ] == 0 ) : NEW_LINE INDENT sum = - 1 NEW_LINE DEDENT else : NEW_LINE INDENT sum += 1 NEW_LINE DEDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ j ] == 0 ) : NEW_LINE INDENT sum += - 1 NEW_LINE DEDENT else : NEW_LINE INDENT sum += 1 NEW_LINE DEDENT if ( Sum == 0 and maxsize < j - i + 1 ) : NEW_LINE INDENT maxsize = j - i + 1 NEW_LINE startindex = i NEW_LINE DEDENT DEDENT DEDENT
def insertionSortRecursive ( arr , n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return NEW_LINE DEDENT insertionSortRecursive ( arr , n - 1 ) NEW_LINE last = arr [ n - 1 ] NEW_LINE j = n - 2 NEW_LINE while ( j >= 0 and arr [ j ] > last ) : NEW_LINE INDENT arr [ j + 1 ] = arr [ j ] NEW_LINE j -= 1 NEW_LINE DEDENT arr [ j + 1 ] = last NEW_LINE DEDENT last = arr [ n - 1 ] NEW_LINE j = n - 2 NEW_LINE while ( j >= 0 and arr [ j ] > last ) : NEW_LINE INDENT arr [ j + 1 ] = arr [ j ] NEW_LINE j -= 1 NEW_LINE DEDENT arr [ j + 1 ] = arr [ j ] NEW_LINE j -= 1 NEW_LINE DEDENT arr [ j + 1 ] = last NEW_LINE DEDENT
def findDiff ( arr , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if mp . get ( arr [ i ] ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT max_count = 0 NEW_LINE min_count = n NEW_LINE for x in mp : NEW_LINE INDENT max_count = max ( max_count , x . getValue ( ) ) NEW_LINE min_count = min ( min_count , x . getValue ( ) ) NEW_LINE DEDENT return ( max_count - min_count ) NEW_LINE DEDENT
def playGame ( arr ) : NEW_LINE INDENT set = Set ( ) NEW_LINE for i in arr : NEW_LINE INDENT set . add ( i ) NEW_LINE DEDENT return ( len ( set ) % 2 == 0 ) ? 1 : 2 NEW_LINE DEDENT
def subset ( arr , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] = mp [ arr [ i ] ] + 1 NEW_LINE DEDENT res = 0 NEW_LINE for entry in mp : NEW_LINE INDENT res = max ( res , entry . getValue ( ) ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def isProduct ( arr , n , x ) : NEW_LINE INDENT s = set ( ) NEW_LINE if n < 2 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if arr [ i ] == 0 : NEW_LINE INDENT if x == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT continue NEW_LINE DEDENT DEDENT if x % arr [ i ] == 0 : NEW_LINE INDENT s . add ( x // arr [ i ] ) NEW_LINE return True NEW_LINE DEDENT hset . add ( arr [ i ] ) NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def largestSumOfAverages ( A , K ) : NEW_LINE INDENT n = len ( A ) NEW_LINE pre_sum = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT pre_sum [ i + 1 ] = pre_sum [ i ] + A [ i ] NEW_LINE DEDENT dp = [ 0 for i in range ( n ) ] NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp [ i ] = ( pre_sum [ n ] - pre_sum [ i ] ) / ( n - i ) NEW_LINE DEDENT for k in range ( K - 1 ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i ] , ( pre_sum [ j ] - pre_sum [ i ] ) / ( j - i ) + dp [ j ] ) NEW_LINE DEDENT DEDENT return dp [ 0 ] NEW_LINE DEDENT
def getMinSteps ( n ) : NEW_LINE INDENT table = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT table [ i ] = n - i NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( not ( i % 2 > 0 ) ) : NEW_LINE INDENT table [ i // 2 ] = min ( table [ i ] + 1 , table [ i // 2 ] ) NEW_LINE DEDENT if ( not ( i % 3 > 0 ) ) : NEW_LINE INDENT table [ i // 3 ] = min ( table [ i ] + 1 , table [ i // 3 ] ) NEW_LINE DEDENT if ( i % 4 > 0 ) : NEW_LINE INDENT table [ i // 3 ] = min ( table [ i ] + 1 , table [ i // 3 ] ) NEW_LINE DEDENT DEDENT return table [ 1 ] NEW_LINE DEDENT
def nthTerm ( n ) : NEW_LINE INDENT return ( n * n ) + ( n * n * n ) NEW_LINE DEDENT
def findMaxAverage ( arr , n , k ) : NEW_LINE INDENT if ( k > n ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT sum = arr [ 0 ] NEW_LINE for i in range ( 1 , k ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT max_sum = sum NEW_LINE max_end = k - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = sum + arr [ i ] - arr [ i - k ] NEW_LINE if ( sum > max_sum ) : NEW_LINE INDENT max_sum = sum NEW_LINE max_end = i NEW_LINE DEDENT DEDENT return max_end - k + 1 NEW_LINE DEDENT
def eggDrop ( n , k ) : NEW_LINE INDENT if ( k == 1 or k == 0 ) : NEW_LINE INDENT return k NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return k NEW_LINE DEDENT min = + 1 NEW_LINE for x in range ( 1 , k + 1 ) : NEW_LINE INDENT res = max ( eggDrop ( n - 1 , x - 1 ) , eggDrop ( n , k - x ) ) NEW_LINE if ( res < min ) : NEW_LINE INDENT min = res NEW_LINE DEDENT DEDENT return min + 1 NEW_LINE DEDENT
def count ( s , c ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == c ) : NEW_LINE INDENT res = res + 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def findRotations ( str ) : NEW_LINE INDENT tmp = str + str NEW_LINE n = len ( str ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT substring = tmp [ i : ] NEW_LINE if ( str == substring ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return n NEW_LINE DEDENT
def randomize ( arr , n ) : NEW_LINE INDENT r = Random ( ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT j = r . nextInt ( i + 1 ) NEW_LINE arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ] NEW_LINE DEDENT print ( arr ) NEW_LINE DEDENT
def findLength ( string , n ) : NEW_LINE INDENT sum = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum [ i ] = ( sum [ i - 1 ] + string [ i - 1 ] - '0' ) NEW_LINE DEDENT ans = 0 NEW_LINE for len in range ( 2 , n + 1 ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT j = i + len - 1 NEW_LINE if ( sum [ i + len // 2 ] - sum [ i ] == sum [ i + len ] - sum [ i + len // 2 ] ) : NEW_LINE INDENT ans = max ( ans , len ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def translate ( st ) : NEW_LINE INDENT lenn = len ( st ) NEW_LINE if ( len < 2 ) : NEW_LINE INDENT return NEW_LINE DEDENT i = 0 NEW_LINE j = 0 NEW_LINE while ( j < len - 1 ) : NEW_LINE INDENT if ( st [ j ] == ' A ' and st [ j + 1 ] == ' B ' ) : NEW_LINE INDENT j = j + 2 NEW_LINE str [ i ] = ' C ' NEW_LINE continue NEW_LINE DEDENT st [ i ] = st [ j ] NEW_LINE DEDENT if ( j == len - 1 ) : NEW_LINE INDENT st [ i ] = st [ j ] NEW_LINE i += 1 NEW_LINE DEDENT st [ len - 1 ] = ' ▁ ' NEW_LINE st [ len - 1 ] = ' ▁ ' NEW_LINE DEDENT
def maximumNumberDistinctPrimeRange ( m , n ) : NEW_LINE INDENT factorCount = [ 0 for i in range ( n + 1 ) ] NEW_LINE prime = [ False for i in range ( n + 1 ) ] NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ i ] == True ) : NEW_LINE INDENT factorCount [ i ] = 1 NEW_LINE for j in range ( i * 2 , n + i ) : NEW_LINE INDENT factorCount [ j ] += 1 NEW_LINE prime [ j ] = False NEW_LINE DEDENT DEDENT DEDENT max = factorCount [ m ] NEW_LINE num = m NEW_LINE for i in range ( m , n + 1 ) : NEW_LINE INDENT if ( factorCount [ i ] > max ) : NEW_LINE INDENT max = factorCount [ i ] NEW_LINE num = i NEW_LINE DEDENT DEDENT return num NEW_LINE DEDENT
def catalan ( n ) : NEW_LINE INDENT res = 0 NEW_LINE if n <= 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT res += catalan ( i ) * catalan ( n - i - 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def sumOfSeries ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum = sum + ( 2 * i - 1 ) * ( 2 * i - 1 ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
def minRevolutions ( r , x1 , y1 , x2 , y2 ) : NEW_LINE INDENT d = ( math . sqrt ( ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ) NEW_LINE return math . ceil ( d / ( 2 * r ) ) NEW_LINE DEDENT
def printString ( str , ch , count ) : NEW_LINE INDENT occ = 0 NEW_LINE if ( count == 0 ) : NEW_LINE INDENT print ( str ) NEW_LINE return NEW_LINE DEDENT for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] == ch ) : NEW_LINE INDENT occ += 1 NEW_LINE DEDENT if ( occ == count ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( i < len ( str ) - 1 ) : NEW_LINE INDENT print ( str [ i + 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Empty ▁ string " ) NEW_LINE DEDENT DEDENT
def largestKSubmatrix ( a ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( Col ) ] for j in range ( Row ) ] NEW_LINE result = 0 NEW_LINE for i in range ( Row ) : NEW_LINE INDENT for j in range ( Col ) : NEW_LINE INDENT if ( i == 0 or j == 0 ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( a [ i ] [ j ] == a [ i - 1 ] [ j ] and a [ i ] [ j ] == a [ i ] [ j - 1 ] and a [ i ] [ j ] == a [ i - 1 ] [ j - 1 ] ) : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] > dp [ i ] [ j - 1 ] and dp [ i - 1 ] [ j ] > dp [ i - 1 ] [ j - 1 ] + 1 ) : NEW_LINE INDENT dp [ i ] [ j - 1 ] = dp [ i - 1 ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = 1 NEW_LINE DEDENT DEDENT result = result > dp [ i ] [ j ] ? result : dp [ i ] [ j ] NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def printPascal ( n ) : NEW_LINE INDENT arr = [ [ 0 for x in range ( n + 1 ) ] for y in range ( n + 1 ) ] NEW_LINE for line in range ( n ) : NEW_LINE INDENT for i in range ( line + 1 ) : NEW_LINE INDENT if ( line == i or i == 0 ) : NEW_LINE INDENT arr [ line ] [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ line ] [ i ] = arr [ line - 1 ] [ i - 1 ] + arr [ line - 1 ] [ i ] NEW_LINE DEDENT print ( arr [ line ] [ i ] ) NEW_LINE DEDENT DEDENT print ( " " ) NEW_LINE DEDENT
def answer_query ( a , n , l , r ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( l , r ) : NEW_LINE INDENT if ( a [ i ] == a [ i + 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def cassini ( n ) : NEW_LINE INDENT return ( n & 1 ) != 0 ? - 1 : 1 NEW_LINE DEDENT
def compute_average ( a , b ) : NEW_LINE INDENT return ( a + b ) // 2 NEW_LINE DEDENT
def waysToArrange ( N , K , k ) : NEW_LINE INDENT C = [ [ 0 for i in range ( N + 1 ) ] for j in range ( N + 1 ) ] NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT dp = [ K + 1 ] NEW_LINE count = 0 NEW_LINE for i in range ( K + 1 ) : NEW_LINE INDENT dp [ i + 1 ] = ( dp [ i ] * C [ count + k [ i ] - 1 ] [ k [ i ] - 1 ] ) NEW_LINE count += k [ i ] NEW_LINE DEDENT return dp [ K ] NEW_LINE DEDENT
def findDimen ( H , A ) : NEW_LINE INDENT if ( H * H < 4 * A ) : NEW_LINE INDENT print ( " Not ▁ Possible " ) NEW_LINE return - 1 NEW_LINE DEDENT apb = math . sqrt ( H * H + 4 * A ) NEW_LINE asb = math . sqrt ( H * H - 4 * A ) NEW_LINE print ( " P ▁ = ▁ " , round ( ( ( apb - asb ) // 2.0 ) * 100.0 ) / 100.0 ) NEW_LINE print ( " B ▁ = ▁ " , round ( ( ( apb + asb ) // 2.0 ) * 100.0 ) / 100.0 ) ) NEW_LINE DEDENT
def maxTripletSum ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE return arr [ n - 1 ] + arr [ n - 2 ] + arr [ n - 3 ] NEW_LINE DEDENT
def MaxDotProduct ( A , B , m , n ) : NEW_LINE INDENT dp = [ [ 0 for x in range ( n + 1 ) ] for y in range ( m + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , m + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( ( dp [ i - 1 ] [ j - 1 ] + ( A [ j - 1 ] * B [ i - 1 ] ) ) , dp [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT return dp [ n ] [ m ] NEW_LINE DEDENT
def findMinDiff ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE diff = + 2147483647 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( arr [ i + 1 ] - arr [ i ] < diff ) : NEW_LINE INDENT diff = arr [ i + 1 ] - arr [ i ] NEW_LINE DEDENT DEDENT return diff NEW_LINE DEDENT
def findLastIndex ( str , x ) : NEW_LINE INDENT for i in range ( len ( str ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( str [ i ] == x ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def maxLower ( str1 ) : NEW_LINE INDENT n = len ( str1 ) NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT if ( str1 [ i ] >= ' A ' and str1 [ i ] <= ' Z ' ) : NEW_LINE INDENT i += 1 NEW_LINE break NEW_LINE DEDENT DEDENT maxCount = 0 NEW_LINE count = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( str1 [ i ] >= ' A ' and str1 [ i ] <= ' Z ' ) : NEW_LINE INDENT currCount = 0 NEW_LINE for j in range ( MAX_CHAR ) : NEW_LINE INDENT if ( count [ j ] > 0 ) : NEW_LINE INDENT currCount += 1 NEW_LINE DEDENT DEDENT maxCount = max ( maxCount , currCount ) NEW_LINE Arrays . fill ( count , 0 ) NEW_LINE DEDENT if ( str1 [ i ] >= ' a ' and str1 [ i ] <= ' z ' ) : NEW_LINE INDENT count [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT DEDENT return maxCount NEW_LINE DEDENT
def findElements ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT if ( j > arr [ i ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( count >= 2 ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def evenlength ( n ) : NEW_LINE INDENT res = n NEW_LINE j = len ( n ) - 1 NEW_LINE while ( j >= 0 ) : NEW_LINE INDENT res = res + n [ j ] NEW_LINE j = j - 1 NEW_LINE DEDENT return res NEW_LINE DEDENT
def maxLen ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE sum = 0 NEW_LINE max_len = 0 NEW_LINE ending_index = - 1 NEW_LINE start_index = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr [ i ] = ( arr [ i ] == 0 ) ? - 1 : 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT Sum += arr [ i ] NEW_LINE if Sum == 0 : NEW_LINE INDENT max_len = i + 1 NEW_LINE ending_index = i NEW_LINE DEDENT if Sum in s : NEW_LINE INDENT max_len = i - s [ Sum + n ] NEW_LINE ending_index = i NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = ( arr [ i ] == - 1 ) ? 0 : 1 NEW_LINE DEDENT end = ending_index - max_len + 1 NEW_LINE print ( end , end , end , end = ending_index ) NEW_LINE return max_len NEW_LINE DEDENT
def possibleStrings ( n , r , b , g ) : NEW_LINE INDENT fact = [ 0 for i in range ( n + 1 ) ] NEW_LINE fact [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT fact [ i ] = fact [ i - 1 ] * i NEW_LINE DEDENT left = n - ( r + g + b ) NEW_LINE sum = 0 NEW_LINE for i in range ( 0 , left + 1 ) : NEW_LINE INDENT for j in range ( 0 , left - i + 1 ) : NEW_LINE INDENT k = left - ( i + j ) NEW_LINE sum = sum + fact [ n ] / ( fact [ i + r ] * fact [ j + b ] * fact [ k + g ] ) NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def numberofways ( A , B , N , M ) : NEW_LINE INDENT pos = [ [ 0 for i in range ( M ) ] for j in range ( MAX ) ] NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT pos [ B [ i ] ] . append ( i + 1 ) NEW_LINE DEDENT dpl = [ [ 0 for i in range ( N + 2 ) ] for j in range ( M + 2 ) ] NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( 1 , M + 1 ) : NEW_LINE INDENT if ( A [ i - 1 ] == B [ j - 1 ] ) : NEW_LINE INDENT dpl [ i ] [ j ] = dpl [ i - 1 ] [ j - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT dpl [ i ] [ j ] = max ( dpl [ i - 1 ] [ j ] , dpl [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT LCS = dpl [ N ] [ M ] NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT for j in range ( M + 1 ) : NEW_LINE INDENT if ( A [ i - 1 ] == B [ j - 1 ] ) : NEW_LINE INDENT dpr [ i ] [ j ] = dpr [ i + 1 ] [ j + 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT dpr [ i ] [ j ] = max ( dpr [ i + 1 ] [ j ] , dpr [ i ] [ j + 1 ] ) NEW_LINE DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT for x in pos [ j ] : NEW_LINE INDENT if ( dpl [ i ] [ x - 1 ] + dpr [ i + 1 ] [ x + 1 ] == LCS ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def circumference ( r ) : NEW_LINE INDENT PI = 3.1415 NEW_LINE cir = 2 * PI * r NEW_LINE return cir NEW_LINE DEDENT
def substringConversions ( str , k , b ) : NEW_LINE INDENT for i in range ( i + k ) : NEW_LINE INDENT sub = str [ i : i + k ] NEW_LINE sum = 0 NEW_LINE counter = 0 NEW_LINE for j in range ( len ( sub ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT sum = ( int ) ( sum + ( ( sub [ j ] - ord ( '0' ) * pow ( b , counter ) ) ) NEW_LINE counter = counter + 1 NEW_LINE DEDENT print ( sum , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def maxPathSum ( tri , m , n ) : NEW_LINE INDENT for i in range ( m - 1 , n - 1 , - 1 ) : NEW_LINE INDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( tri [ i + 1 ] [ j ] > tri [ i + 1 ] [ j + 1 ] ) : NEW_LINE INDENT tri [ i ] [ j ] += tri [ i + 1 ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT tri [ i ] [ j ] += tri [ i + 1 ] [ j + 1 ] NEW_LINE DEDENT DEDENT DEDENT return tri [ 0 ] [ 0 ] NEW_LINE DEDENT
def SumOfKsubArray ( arr , k ) : NEW_LINE INDENT s = [ ] NEW_LINE G = [ ] NEW_LINE for i in range ( k ) : NEW_LINE INDENT while ( not S . empty ( ) and arr [ S . peekLast ( ) ] >= arr [ i ] ) : NEW_LINE INDENT S . removeLast ( ) NEW_LINE DEDENT while ( not G . empty ( ) and arr [ G . peekLast ( ) ] <= arr [ i ] ) : NEW_LINE INDENT G . removeLast ( ) NEW_LINE DEDENT G . append ( i ) NEW_LINE S . removeLast ( ) NEW_LINE DEDENT for i in range ( len ( arr ) ) : NEW_LINE INDENT sum += arr [ S . peekFirst ( ) ] + arr [ G . peekFirst ( ) ] NEW_LINE while ( not S . empty ( ) and arr [ S . peekLast ( ) ] >= arr [ i ] ) : NEW_LINE INDENT S . removeLast ( ) NEW_LINE DEDENT while ( not G . empty ( ) and arr [ G . peekLast ( ) ] <= arr [ i ] ) : NEW_LINE INDENT G . removeLast ( ) NEW_LINE DEDENT G . addLast ( i ) NEW_LINE S . addLast ( i ) NEW_LINE DEDENT DEDENT sum += arr [ S . peekFirst ( ) ] + arr [ G . peekFirst ( ) ] NEW_LINE return sum NEW_LINE DEDENT
def fun ( n ) : NEW_LINE INDENT return n & ( n - 1 ) NEW_LINE DEDENT
def mirrorImage ( a , b , c , x1 , y1 ) : NEW_LINE INDENT temp = - 2 * ( a * x1 + b * y1 + c ) / ( a * a + b * b ) NEW_LINE x = temp * a + x1 NEW_LINE y = temp * b + y1 NEW_LINE return new pair ( x , y ) NEW_LINE DEDENT
def printDistinct ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT while ( i < n - 1 and arr [ i ] == arr [ i + 1 ] ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def printIntersection ( arr1 , arr2 , m , n ) : NEW_LINE INDENT i , j = 0 , 0 NEW_LINE while i < m and j < n : NEW_LINE INDENT if arr1 [ i ] < arr2 [ j ] : NEW_LINE INDENT i += 1 NEW_LINE DEDENT elif arr2 [ j ] < arr1 [ i ] : NEW_LINE INDENT j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( arr2 [ j ] , end = " ▁ " ) NEW_LINE j += 1 NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT DEDENT
def search ( arr , n , x , k ) : NEW_LINE INDENT i = 0 NEW_LINE while i < n : NEW_LINE INDENT if arr [ i ] == x : NEW_LINE INDENT return i NEW_LINE DEDENT i = i + max ( 1 , abs ( arr [ i ] - x ) / k ) NEW_LINE DEDENT print ( " number ▁ is ▁ " , " not ▁ present ! " ) NEW_LINE DEDENT
def arrangeString ( str ) : NEW_LINE INDENT global MAX_CHAR NEW_LINE char_count = [ 0 for i in range ( MAX_CHAR ) ] NEW_LINE sum = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( ord ( str [ i ] ) == ord ( ' A ' ) ) : NEW_LINE INDENT char_count [ ord ( str [ i ] ) - ord ( ' 0' ) ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT sum = sum + ( ord ( str [ i ] ) - ord ( '0' ) ) NEW_LINE DEDENT DEDENT res = " " NEW_LINE for i in range ( MAX_CHAR ) : NEW_LINE INDENT ch = ord ( ' A ' + i ) NEW_LINE while ( char_count [ i ] -- != 0 ) : NEW_LINE INDENT res = res + chr ( ord ( ' A ' ) + i ) NEW_LINE DEDENT if ( sum > 0 ) : NEW_LINE INDENT res = res + sum NEW_LINE DEDENT return res NEW_LINE DEDENT
def countStrings ( n ) : NEW_LINE INDENT a = [ 0 ] * n NEW_LINE b = [ 0 for i in range ( n ) ] NEW_LINE a [ 0 ] = b [ 0 ] = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT a [ i ] = a [ i - 1 ] + b [ i - 1 ] NEW_LINE b [ i ] = a [ i - 1 ] NEW_LINE DEDENT return a [ n - 1 ] + b [ n - 1 ] NEW_LINE DEDENT
def minSum ( arr , n ) : NEW_LINE INDENT dp = [ 0 ] * n NEW_LINE if n == 1 : NEW_LINE INDENT return arr [ 0 ] NEW_LINE DEDENT if n == 2 : NEW_LINE INDENT return min ( arr [ 0 ] , arr [ 1 ] ) NEW_LINE DEDENT if n == 3 : NEW_LINE INDENT return min ( arr [ 0 ] , arr [ 1 ] , arr [ 2 ] ) NEW_LINE DEDENT if n == 4 : NEW_LINE INDENT return min ( arr [ 0 ] , arr [ 1 ] ) , min ( arr [ 2 ] , arr [ 3 ] ) ) NEW_LINE DEDENT dp [ 0 ] = arr [ 0 ] NEW_LINE dp [ 1 ] = arr [ 1 ] NEW_LINE dp [ 2 ] = arr [ 2 ] NEW_LINE dp [ 3 ] = arr [ 3 ] NEW_LINE for i in range ( 4 , n ) : NEW_LINE INDENT dp [ i ] = arr [ i ] + min ( min ( dp [ i - 1 ] , dp [ i - 2 ] ) , min ( dp [ i - 3 ] , dp [ i - 4 ] ) ) NEW_LINE DEDENT return min ( min ( dp [ n - 1 ] , dp [ n - 2 ] ) , min ( dp [ n - 4 ] , dp [ n - 3 ] ) ) NEW_LINE DEDENT
def printSequence ( arr , input ) : NEW_LINE INDENT output = " " NEW_LINE n = len ( input ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( input [ i ] == ' ▁ ' ) : NEW_LINE INDENT output = output + "0" NEW_LINE DEDENT else : NEW_LINE INDENT position = ord ( input [ i ] ) - ord ( ' A ' ) ; NEW_LINE output = output + arr [ position ] NEW_LINE DEDENT DEDENT return output NEW_LINE DEDENT
def rotatematrix ( m , n , mat ) : NEW_LINE INDENT row = 0 col = 0 NEW_LINE while ( row < m and col < n ) : NEW_LINE INDENT if ( row + 1 == m or col + 1 == n ) : NEW_LINE INDENT break NEW_LINE DEDENT prev = mat [ row + 1 ] [ col ] NEW_LINE for i in range ( col , n ) : NEW_LINE INDENT curr = mat [ row ] [ i ] NEW_LINE mat [ row ] [ i ] = prev NEW_LINE prev = curr NEW_LINE DEDENT row += 1 NEW_LINE for i in range ( row , m ) : NEW_LINE INDENT curr = mat [ i ] [ n - 1 ] NEW_LINE mat [ i ] [ n - 1 ] = prev NEW_LINE prev = curr NEW_LINE DEDENT n -= 1 NEW_LINE if ( row < m ) : NEW_LINE INDENT for i in range ( n - 1 , col - 1 , - 1 ) : NEW_LINE INDENT curr = mat [ m - 1 ] [ i ] NEW_LINE mat [ m - 1 ] [ i ] = prev NEW_LINE prev = curr NEW_LINE DEDENT DEDENT m -= 1 NEW_LINE if ( col < n ) : NEW_LINE INDENT for i in range ( m - 1 , row - 1 , - 1 ) : NEW_LINE INDENT curr = mat [ i ] [ col ] NEW_LINE mat [ i ] [ col ] = prev NEW_LINE prev = curr NEW_LINE DEDENT DEDENT col += 1 NEW_LINE DEDENT for i in range ( R ) : NEW_LINE INDENT for j in range ( C ) : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def maxcoefficientvalue ( n ) : NEW_LINE INDENT C = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( min ( i , n ) + 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT maxvalue = 0 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT maxvalue = max ( maxvalue , C [ n ] [ i ] ) NEW_LINE DEDENT return maxvalue NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if a < b : NEW_LINE INDENT return gcd ( b , a ) NEW_LINE DEDENT if abs ( b ) < 0.001 : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return ( gcd ( b , a - math . floor ( a / b ) * b ) ) NEW_LINE DEDENT DEDENT
def sortByPattern ( str , pat ) : NEW_LINE INDENT count = [ 0 for i in range ( MAX_CHAR ) ] NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT count [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT index = 0 NEW_LINE for i in range ( len ( pat ) ) : NEW_LINE INDENT for j in range ( count [ ord ( pat [ i ] ) - ord ( ' a ' ) ] + 1 ) : NEW_LINE INDENT str [ index ] = pat [ i ] NEW_LINE DEDENT DEDENT DEDENT
def rearrange ( arr , n ) : NEW_LINE INDENT max_idx = n - 1 NEW_LINE min_idx = 0 NEW_LINE max_elem = arr [ n - 1 ] + 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT arr [ i ] = arr [ max_idx ] % max_elem NEW_LINE max_idx -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] += ( arr [ min_idx ] % max_elem ) * max_elem NEW_LINE min_idx += 1 NEW_LINE DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT arr [ i ] = arr [ i ] / max_elem NEW_LINE DEDENT DEDENT
def minJumps ( arr , n ) : NEW_LINE INDENT jumps = [ 0 for x in range ( n ) ] NEW_LINE if n == 0 or arr [ 0 ] == 0 : NEW_LINE INDENT return 10 ** 9 NEW_LINE DEDENT jumps [ 0 ] = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT jumps [ i ] = 10 ** 9 NEW_LINE for j in range ( i ) : NEW_LINE INDENT if i <= j + arr [ j ] and jumps [ j ] != 10 : NEW_LINE INDENT jumps [ i ] = min ( jumps [ i ] , jumps [ j ] + 1 ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT return jumps [ n - 1 ] NEW_LINE DEDENT
def find_prob ( N , P ) : NEW_LINE INDENT dp = [ 0 ] * ( N + 1 ) NEW_LINE dp [ 0 ] = 1 NEW_LINE dp [ 1 ] = 0 NEW_LINE dp [ 2 ] = P NEW_LINE dp [ 3 ] = 1 - P NEW_LINE for i in range ( 4 , N + 1 ) : NEW_LINE INDENT dp [ i ] = ( P ) * dp [ i - 2 ] + ( 1 - P ) * dp [ i - 3 ] NEW_LINE DEDENT return ( float ) ( dp [ N ] ) NEW_LINE DEDENT
def waysToIncreaseLCSBy1 ( str1 , str2 ) : NEW_LINE INDENT m = len ( str1 ) NEW_LINE n = len ( str2 ) NEW_LINE position = [ [ 0 for i in range ( M + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT position [ ord ( str2 [ i - 1 ] ) - ord ( ' a ' ) ] . append ( i ) NEW_LINE DEDENT lcsl = [ [ 0 for i in range ( m + 2 ) ] NEW_LINE lcsr = [ [ 0 for i in range ( n + 2 ) ] NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( str1 [ i - 1 ] == str2 [ j - 1 ] ) : NEW_LINE INDENT lcsl [ i ] [ j ] = 1 + lcsl [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT lcsl [ i ] [ j ] = max ( lcsl [ i - 1 ] [ j ] , lcsl [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if ( str1 [ i - 1 ] == str2 [ j - 1 ] ) : NEW_LINE INDENT lcsr [ i ] [ j ] = 1 + lcsr [ i + 1 ] [ j + 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT lcsr [ i ] [ j ] = max ( lcsr [ i + 1 ] [ j ] , lcsr [ i ] [ j + 1 ] ) NEW_LINE DEDENT DEDENT DEDENT ways = 0 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT for d in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( position [ d ] . size ( ) ) : NEW_LINE INDENT p = position [ d ] [ j ] NEW_LINE DEDENT DEDENT
def lis ( arr , n ) : NEW_LINE INDENT lis = [ 0 ] * n NEW_LINE max = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT lis [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and lis [ i ] < lis [ j ] + 1 ) : NEW_LINE INDENT lis [ i ] = lis [ j ] + 1 NEW_LINE DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( max < lis [ i ] ) : NEW_LINE INDENT max = lis [ i ] NEW_LINE DEDENT DEDENT return max NEW_LINE DEDENT
def SternSequenceFunc ( BrocotSequence , n ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT considered_element = BrocotSequence [ i ] NEW_LINE precedent = BrocotSequence [ i - 1 ] NEW_LINE BrocotSequence [ len ( BrocotSequence ) - 1 ] = considered_element NEW_LINE BrocotSequence [ len ( BrocotSequence ) ] = considered_element + precedent NEW_LINE BrocotSequence [ len ( BrocotSequence ) - 1 ] = considered_element NEW_LINE DEDENT for i in range ( 0 , 15 ) : NEW_LINE INDENT print ( BrocotSequence [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def printTreeEdges ( prufer , m ) : NEW_LINE INDENT vertices = m + 2 NEW_LINE vertex_set = [ 0 ] * ( vertices + 2 ) NEW_LINE for i in range ( vertices ) : NEW_LINE INDENT vertex_set [ i ] = 0 NEW_LINE DEDENT for i in range ( vertices - 2 ) : NEW_LINE INDENT for j in range ( vertices ) : NEW_LINE INDENT if ( vertex_set [ j ] == 0 ) : NEW_LINE INDENT vertex_set [ j ] = - 1 NEW_LINE print ( " ( " , ( j + 1 ) , " , ▁ " , prufer [ i ] , " ) ▁ " ) NEW_LINE vertex_set [ prufer [ i ] - 1 ] -= 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT j = 0 NEW_LINE for i in range ( vertices ) : NEW_LINE INDENT if ( vertex_set [ i ] == 0 and j == 0 ) : NEW_LINE INDENT print ( " ( " , i + 1 ) , " , ▁ " , prufer [ i ] , " ) ▁ " ) NEW_LINE j += 1 NEW_LINE DEDENT elif ( vertex_set [ i ] == 0 and j == 1 ) : NEW_LINE INDENT print ( ( i + 1 ) , " , ▁ " ) NEW_LINE j += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( ( i + 1 ) , " ) \n " ) NEW_LINE DEDENT DEDENT DEDENT
def countDecodingDP ( digits , n ) : NEW_LINE INDENT count = [ 0 for i in range ( n + 1 ) ] NEW_LINE count [ 0 ] = 1 NEW_LINE count [ 1 ] = 1 NEW_LINE if ( digits [ 0 ] == '0' ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT count [ i ] = 0 NEW_LINE if ( digits [ i - 1 ] > '0' ) : NEW_LINE INDENT count [ i ] = count [ i - 1 ] NEW_LINE DEDENT if ( digits [ i - 2 ] == '1' or ( digits [ i - 2 ] == '2' and digits [ i - 1 ] < '7' ) ) : NEW_LINE INDENT count [ i ] += count [ i - 2 ] NEW_LINE DEDENT DEDENT return count [ n ] NEW_LINE DEDENT
def countStrings ( n ) : NEW_LINE INDENT a = [ 0 ] * n NEW_LINE b = [ 0 for i in range ( n ) ] NEW_LINE a [ 0 ] = b [ 0 ] = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT a [ i ] = a [ i - 1 ] + b [ i - 1 ] NEW_LINE b [ i ] = a [ i - 1 ] NEW_LINE DEDENT from 2 ^ n return ( 1 << n ) - a [ n - 1 ] - b [ n - 1 ] NEW_LINE DEDENT
def maximumSegments ( n , a , b , c ) : NEW_LINE INDENT dp = [ - 1 for i in range ( n + 10 ) ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if dp [ i ] != - 1 : NEW_LINE INDENT if i + a <= n : NEW_LINE INDENT dp [ i + a ] = max ( dp [ i ] + 1 , dp [ i + a ] ) NEW_LINE DEDENT if i + b <= n : NEW_LINE INDENT dp [ i + b ] = max ( dp [ i ] + 1 , dp [ i + b ] ) NEW_LINE DEDENT if i + c <= n : NEW_LINE INDENT dp [ i + c ] = max ( dp [ i ] + 1 , dp [ i + c ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ n ] NEW_LINE DEDENT
def printBracketNumber ( exp , n ) : NEW_LINE INDENT left_bnum = 1 NEW_LINE right_bnum = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( exp [ i ] == ' ( ' ) : NEW_LINE INDENT print ( left_bnum , end = " ▁ " ) NEW_LINE right_bnum . append ( left_bnum ) NEW_LINE left_bnum += 1 NEW_LINE DEDENT elif ( exp [ i ] == ' ( ' ) : NEW_LINE INDENT print ( right_bnum [ 0 ] , end = " ▁ " ) NEW_LINE right_bnum . pop ( ) NEW_LINE DEDENT DEDENT DEDENT
def countWords ( str , len ) : NEW_LINE INDENT count = 1 NEW_LINE if ( len == 1 ) : NEW_LINE INDENT return count NEW_LINE DEDENT if ( str [ 0 ] == str [ 1 ] ) : NEW_LINE INDENT count = count * 1 NEW_LINE DEDENT else : NEW_LINE INDENT count = count * 2 NEW_LINE DEDENT for j in range ( 1 , len - 1 ) : NEW_LINE INDENT if ( str [ j ] == str [ j - 1 ] and str [ j ] == str [ j + 1 ] ) : NEW_LINE INDENT count *= 1 NEW_LINE DEDENT elif ( str [ j ] == str [ j - 1 ] or str [ j ] == str [ j + 1 ] or str [ j - 1 ] == str [ j + 1 ] ) : NEW_LINE INDENT count = count * 2 NEW_LINE DEDENT else : NEW_LINE INDENT count *= 3 NEW_LINE DEDENT DEDENT if ( str [ len - 1 ] == str [ len - 2 ] ) : NEW_LINE INDENT count = count * 1 NEW_LINE DEDENT else : NEW_LINE INDENT count = count * 2 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def largest ( arr , n ) : NEW_LINE INDENT max = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if arr [ i ] > max : NEW_LINE INDENT max = arr [ i ] NEW_LINE DEDENT DEDENT return max NEW_LINE DEDENT
def findMinDiff ( arr , n ) : NEW_LINE INDENT diff = + 2147483647 NEW_LINE for i in arr : NEW_LINE INDENT for j in arr : NEW_LINE INDENT if ( abs ( ( arr [ i ] - arr [ j ] ) ) < diff ) : NEW_LINE INDENT diff = abs ( ( arr [ i ] - arr [ j ] ) ) NEW_LINE DEDENT DEDENT DEDENT return diff NEW_LINE DEDENT
def maxSum ( arr , n ) : NEW_LINE INDENT res = - float ( ' inf ' ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT curr_sum = 0 NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT index = ( i + j ) % n NEW_LINE curr_sum += j * arr [ index ] NEW_LINE DEDENT res = max ( res , curr_sum ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def volumeOfEllipsoid ( r1 , r2 , r3 ) : NEW_LINE INDENT pi = 3.14 NEW_LINE return 1.33 * pi * r1 * r2 * r3 NEW_LINE DEDENT
def lcsOf3 ( X , Y , Z , m , n , o ) : NEW_LINE INDENT L = [ [ 0 for i in range ( 10 ) ] for j in range ( 10 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT for k in range ( o + 1 ) : NEW_LINE INDENT if ( i == 0 or j == 0 or k == 0 ) : NEW_LINE INDENT L [ i ] [ j ] [ k ] = 0 NEW_LINE DEDENT elif ( X [ i - 1 ] == Y [ j - 1 ] and X [ i - 1 ] == Z [ k - 1 ] ) : NEW_LINE INDENT L [ i ] [ j ] [ k ] = L [ i - 1 ] [ j - 1 ] [ k - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] [ k ] = max ( L [ i - 1 ] [ j ] [ k ] , L [ i ] [ j - 1 ] [ k ] ) , L [ i ] [ j ] [ k - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return L [ m ] [ n ] [ o ] NEW_LINE DEDENT
def countEndless ( input , n ) : NEW_LINE INDENT row = [ [ False for x in range ( n ) ] for y in range ( n ) ] NEW_LINE col = [ [ False for x in range ( n ) ] for y in range ( n ) ] NEW_LINE for j in range ( n ) : NEW_LINE INDENT isEndless = True NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( input [ i ] [ j ] == False ) : NEW_LINE INDENT isEndless = False NEW_LINE DEDENT col [ i ] [ j ] = isEndless NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT isEndless = True NEW_LINE for j in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( input [ i ] [ j ] == False ) : NEW_LINE INDENT isEndless = False NEW_LINE DEDENT row [ i ] [ j ] = isEndless NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT if ( row [ i ] [ j ] and col [ i ] [ j ] ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def NextFit ( blockSize , m , processSize , n ) : NEW_LINE INDENT allocation = [ - 1 ] * n NEW_LINE j = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT while ( j < m ) : NEW_LINE INDENT if ( blockSize [ j ] >= processSize [ i ] ) : NEW_LINE INDENT allocation [ i ] = j NEW_LINE blockSize [ j ] -= processSize [ i ] NEW_LINE break NEW_LINE DEDENT j = ( j + 1 ) % m NEW_LINE DEDENT DEDENT print ( " \n Process ▁ No . \tProcess ▁ Size\tBlock ▁ no . " ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( i + 1 , " \t\t " , processSize [ i ] , " \t\t " ) NEW_LINE if ( allocation [ i ] != - 1 ) : NEW_LINE INDENT print ( allocation [ i ] + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ Allocated " ) NEW_LINE DEDENT DEDENT
def lenOfLongestGP ( set , n ) : NEW_LINE INDENT if ( n < 2 ) : NEW_LINE INDENT return n NEW_LINE DEDENT if ( n == 2 ) : NEW_LINE INDENT return ( set [ 1 ] % set [ 0 ] == 0 ? 1 : 0 ) NEW_LINE DEDENT set . sort ( ) NEW_LINE L = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( set [ n - 1 ] % set [ i ] == 0 ) : NEW_LINE INDENT L [ i ] [ n - 1 ] = 2 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ n - 1 ] = 1 NEW_LINE DEDENT DEDENT for j in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT i = j - 1 NEW_LINE k = j + 1 NEW_LINE while ( i >= 0 and k <= n - 1 ) : NEW_LINE INDENT if ( set [ i ] * set [ k ] < set [ j ] * set [ j ] ) : NEW_LINE INDENT k += 1 NEW_LINE DEDENT elif ( set [ j ] % set [ i ] == 0 ) : NEW_LINE INDENT L [ i ] [ j ] = 2 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] = 1 NEW_LINE DEDENT -- i NEW_LINE DEDENT DEDENT return llgp NEW_LINE DEDENT
def checkValidity ( a , b , c ) : NEW_LINE INDENT if ( a + b <= c or a + c <= b or b + c <= a ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT
def isDDM ( m , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT sum += abs ( m [ i ] [ j ] ) NEW_LINE DEDENT sum -= abs ( m [ i ] [ i ] ) NEW_LINE if ( abs ( m [ i ] [ i ] ) < sum ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def transpose ( A , B ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT B [ i ] [ j ] = A [ j ] [ i ] NEW_LINE DEDENT DEDENT DEDENT
def returnMaxSum ( A , B , n ) : NEW_LINE INDENT mp = set ( ) NEW_LINE result = 0 NEW_LINE curr_sum = 0 NEW_LINE curr_begin = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT while ( A [ i ] in mp ) : NEW_LINE INDENT mp . remove ( A [ curr_begin ] ) NEW_LINE curr_sum -= B [ curr_begin ] NEW_LINE curr_begin += 1 NEW_LINE DEDENT mp . add ( A [ i ] ) NEW_LINE curr_sum += B [ i ] NEW_LINE result = max ( result , curr_sum ) NEW_LINE DEDENT return result NEW_LINE DEDENT
def sumEqualProduct ( a , n ) : NEW_LINE INDENT zero = 0 NEW_LINE two = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( a [ i ] == 0 ) : NEW_LINE INDENT zero += 1 NEW_LINE DEDENT if ( a [ i ] == 2 ) : NEW_LINE INDENT two += 1 NEW_LINE DEDENT DEDENT cnt = ( zero * ( zero - 1 ) ) / 2 + ( two * ( two - 1 ) ) / 2 NEW_LINE return cnt NEW_LINE DEDENT
def shortestDist ( graph ) : NEW_LINE INDENT dist = [ 0 ] * N NEW_LINE dist [ N - 1 ] = 0 NEW_LINE for i in range ( N - 2 , - 1 , - 1 ) : NEW_LINE INDENT dist [ i ] = INF NEW_LINE for j in range ( i , N ) : NEW_LINE INDENT if ( graph [ i ] [ j ] == INF ) : NEW_LINE INDENT continue NEW_LINE DEDENT dist [ i ] = min ( dist [ i ] , graph [ i ] [ j ] + dist [ j ] ) NEW_LINE DEDENT DEDENT return dist [ 0 ] NEW_LINE DEDENT
def calculateSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE sum = 1 << n NEW_LINE return ( sum - 1 ) NEW_LINE DEDENT
def isPrime ( n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return False NEW_LINE DEDENT if n <= 3 : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return True NEW_LINE DEDENT
def fib ( n ) : NEW_LINE INDENT a = 0 NEW_LINE b = 1 NEW_LINE if ( n >= 0 ) : NEW_LINE INDENT print ( a + " ▁ " ) NEW_LINE DEDENT if ( n >= 1 ) : NEW_LINE INDENT print ( b + " ▁ " ) NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT print ( a + b , end = " ▁ " ) NEW_LINE b = a + b NEW_LINE a = b - a NEW_LINE DEDENT DEDENT
def kthdigit ( a , b , k ) : NEW_LINE INDENT p = ( int ) ( math . pow ( a , b ) ) NEW_LINE count = 0 NEW_LINE while ( p > 0 and count < k ) : NEW_LINE INDENT rem = p % 10 NEW_LINE count += 1 NEW_LINE if ( count == k ) : NEW_LINE INDENT return rem NEW_LINE DEDENT p = p // 10 NEW_LINE DEDENT return 0 NEW_LINE DEDENT
def isEven ( n ) : NEW_LINE INDENT if ( ( n & 1 ) == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def printPath ( str ) : NEW_LINE INDENT i = 0 NEW_LINE curX = 0 NEW_LINE curY = 0 NEW_LINE while i < len ( str ) : NEW_LINE INDENT nextX = ord ( str [ i ] ) - ord ( ' A ' ) / 5 NEW_LINE nextY = ord ( str [ i ] ) - ord ( ' B ' + 1 ) % 5 NEW_LINE while ( curX > nextX ) : NEW_LINE INDENT print ( " Move ▁ Up " ) NEW_LINE curX -= 1 NEW_LINE DEDENT while ( curY > nextY ) : NEW_LINE INDENT print ( " Move ▁ Left " ) NEW_LINE curY -= 1 NEW_LINE DEDENT while ( curX < nextX ) : NEW_LINE INDENT print ( " Move ▁ Down " ) NEW_LINE curX += 1 NEW_LINE DEDENT while ( curY < nextY ) : NEW_LINE INDENT print ( " Move ▁ Right " ) NEW_LINE curY += 1 NEW_LINE DEDENT print ( " Press ▁ OK " ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT
def checkcircle ( r , R , r1 , x1 , y1 ) : NEW_LINE INDENT dis = ( int ) ( math . sqrt ( x1 * x1 + y1 * y1 ) ) NEW_LINE return ( dis - r1 >= R and dis + r1 <= r ) NEW_LINE DEDENT
def isMinHeap ( level ) : NEW_LINE INDENT n = len ( level ) - 1 NEW_LINE i = ( int ) ( ( n / 2 - 1 ) ) NEW_LINE while i >= 0 : NEW_LINE INDENT if ( level [ i ] > level [ 2 * i + 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( 2 * i + 2 < n ) : NEW_LINE INDENT if ( level [ i ] > level [ 2 * i + 2 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT
def thirdLargest ( arr , arr_size ) : NEW_LINE INDENT if arr_size < 3 : NEW_LINE INDENT print ( " ▁ Invalid ▁ Input ▁ " ) NEW_LINE return - 1 NEW_LINE DEDENT first = arr [ 0 ] NEW_LINE for i in range ( 1 , arr_size ) : NEW_LINE INDENT if arr [ i ] > first : NEW_LINE INDENT first = arr [ i ] NEW_LINE DEDENT DEDENT second = 10 ** 9 NEW_LINE for i in range ( 0 , arr_size ) : NEW_LINE INDENT if arr [ i ] > second and arr [ i ] < first : NEW_LINE INDENT second = arr [ i ] NEW_LINE DEDENT DEDENT third = - 1 NEW_LINE for i in range ( 0 , arr_size ) : NEW_LINE INDENT if arr [ i ] > third and arr [ i ] < second : NEW_LINE INDENT third = arr [ i ] NEW_LINE DEDENT print ( " The ▁ third ▁ Largest ▁ element ▁ is % d " , third ) NEW_LINE DEDENT
def maxHamming ( arr , n ) : NEW_LINE INDENT brr = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT brr [ i ] = arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT brr [ n + i ] = arr [ i ] NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT currHam = 0 NEW_LINE for j in range ( i , ( i + n ) ) : NEW_LINE INDENT if ( brr [ j ] != arr [ k ] ) : NEW_LINE INDENT currHam += 1 NEW_LINE DEDENT DEDENT if ( currHam == n ) : NEW_LINE INDENT return n NEW_LINE DEDENT maxHam = max ( maxHam , currHam ) NEW_LINE DEDENT return maxHam NEW_LINE DEDENT
def findSum ( N , K ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT ans += i % K NEW_LINE DEDENT return ans NEW_LINE DEDENT
def seriesSum ( n ) : NEW_LINE INDENT i = 1 NEW_LINE res = 0.0 NEW_LINE sign = True NEW_LINE while ( n > 0 ) : NEW_LINE INDENT n -= 1 NEW_LINE if ( sign ) : NEW_LINE INDENT sign = not sign NEW_LINE res = res + ( double ) ++ i / i NEW_LINE DEDENT else : NEW_LINE INDENT sign = sign NEW_LINE res = res - ( double ) ++ i / i NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def countSetBits ( n ) : NEW_LINE INDENT i = 0 NEW_LINE ans = 0 NEW_LINE while ( ( 1 << i ) <= n ) : NEW_LINE INDENT k = False NEW_LINE change = 1 << i NEW_LINE for j in range ( n + 1 ) : NEW_LINE INDENT if ( k == True ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += 0 NEW_LINE DEDENT if ( change == 1 ) : NEW_LINE INDENT k = not k NEW_LINE change = 1 << i NEW_LINE DEDENT else : NEW_LINE INDENT change -= 1 NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def getPairsCount ( n , arr , sum ) : NEW_LINE INDENT hm = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if hm . get ( arr [ i ] ) == 0 : NEW_LINE INDENT hm [ arr [ i ] ] = 0 NEW_LINE DEDENT hm [ arr [ i ] ] += 1 NEW_LINE DEDENT twice_count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if hm [ sum - arr [ i ] ] != None : NEW_LINE INDENT twice_count += hm [ sum - arr [ i ] ] NEW_LINE DEDENT if hm [ sum - arr [ i ] == arr [ i ] : NEW_LINE INDENT twice_count -= 1 NEW_LINE DEDENT DEDENT return twice_count // 2 NEW_LINE DEDENT
def isDiagonalMatrix ( mat ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if ( ( i != j ) and ( mat [ i ] [ j ] != 0 ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT
def printSorted ( a , b , c ) : NEW_LINE INDENT get_max = max ( a , max ( b , c ) ) NEW_LINE get_min = - max ( - a , max ( - b , - c ) ) NEW_LINE get_mid = ( a + b + c ) - ( get_max + get_min ) NEW_LINE print ( get_min , " ▁ " , get_mid , " ▁ " , get_max ) NEW_LINE DEDENT
def isDivisible ( n ) : NEW_LINE INDENT while ( n // 100 > 0 ) : NEW_LINE INDENT last_digit = n % 10 NEW_LINE n /= 10 NEW_LINE last_digit += 1 NEW_LINE DEDENT return ( n % 29 == 0 ) NEW_LINE DEDENT
def getSingle ( arr , n ) : NEW_LINE INDENT ones = 0 NEW_LINE twos = 0 NEW_LINE common_bit_mask = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT twos = twos | ( ones & arr [ i ] ) NEW_LINE ones = ones ^ arr [ i ] NEW_LINE common_bit_mask = ~ ( ones & twos ) NEW_LINE ones &= common_bit_mask NEW_LINE twos &= common_bit_mask NEW_LINE DEDENT return ones NEW_LINE DEDENT
def minSumPath ( A ) : NEW_LINE INDENT memo = [ 0 ] * A . length NEW_LINE n = len ( A ) - 1 NEW_LINE for i in range ( A [ n ] . length ) : NEW_LINE INDENT memo [ i ] = A [ n ] [ i ] NEW_LINE DEDENT for i in range ( - 2 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( A [ i ] . length ) : NEW_LINE INDENT memo [ j ] = A [ i ] [ j ] + min ( memo [ j ] , memo [ j + 1 ] ) NEW_LINE DEDENT DEDENT return memo [ 0 ] NEW_LINE DEDENT
def rearrange ( arr , n ) : NEW_LINE INDENT i = - 1 NEW_LINE temp = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if arr [ j ] < 0 : NEW_LINE INDENT i += 1 NEW_LINE arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ] NEW_LINE DEDENT DEDENT pos = i + 1 NEW_LINE neg = 0 NEW_LINE while pos < n and neg < pos and arr [ neg ] < 0 : NEW_LINE INDENT arr [ neg ] , arr [ pos ] = arr [ pos ] , arr [ neg ] NEW_LINE pos += 1 NEW_LINE neg += 2 NEW_LINE DEDENT DEDENT
def countNum ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE arr . sort ( ) NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if arr [ i ] != arr [ i + 1 ] and arr [ i ] != arr [ i + 1 ] - 1 : NEW_LINE INDENT count += arr [ i + 1 ] - arr [ i ] - 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def largestGCDSubsequence ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE maxele = max ( arr ) NEW_LINE for i in range ( 2 , maxele + 1 ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( arr [ j ] % i == 0 ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT ans = max ( ans , count ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def isNumber ( s ) : NEW_LINE INDENT for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT if ( isDigit ( s [ i ] ) == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def countPairs ( arr1 , arr2 , m , n , x ) : NEW_LINE INDENT us = Set ( ) NEW_LINE count = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT us . add ( arr1 [ i ] ) NEW_LINE DEDENT for j in range ( n ) : NEW_LINE INDENT if ( us [ x - arr2 [ j ] ] == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def countSquares ( a , b ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( a , b + 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT if ( j * j == i ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT
def minSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( n ) : NEW_LINE INDENT sum += ( n % 10 ) NEW_LINE n /= 10 NEW_LINE DEDENT if ( sum == 1 ) : NEW_LINE INDENT return 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT
def nonFibonacci ( n ) : NEW_LINE INDENT prevPrev = 1 NEW_LINE prev = 2 NEW_LINE curr = 3 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT prevPrev = prev NEW_LINE prev = curr NEW_LINE curr = prevPrev + prev NEW_LINE n = n - ( curr - prev - 1 ) NEW_LINE DEDENT n = n + ( curr - prev - 1 ) NEW_LINE return prev + n NEW_LINE DEDENT
def lis ( arr , n ) : NEW_LINE INDENT lis = [ 0 ] * n NEW_LINE max = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT lis [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and lis [ i ] < lis [ j ] + 1 ) : NEW_LINE INDENT lis [ i ] = lis [ j ] + 1 NEW_LINE DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( max < lis [ i ] ) : NEW_LINE INDENT max = lis [ i ] NEW_LINE DEDENT DEDENT return max NEW_LINE DEDENT
def leftRotate ( arr , n , k ) : NEW_LINE INDENT for i in range ( k , k + n ) : NEW_LINE INDENT print ( arr [ i % n ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def repeat ( s , n ) : NEW_LINE INDENT s1 = s NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT s += s1 NEW_LINE DEDENT return s NEW_LINE DEDENT
def findSubString ( str1 ) : NEW_LINE INDENT n = len ( str1 ) NEW_LINE dist_count = 0 NEW_LINE visited = [ 0 for i in range ( MAX_CHARS ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT visited [ ord ( str1 [ i ] ) ] = True NEW_LINE dist_count += 1 NEW_LINE DEDENT DEDENT start = 0 NEW_LINE start_index = - 1 NEW_LINE min_len = 10 NEW_LINE count = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT curr_count [ ord ( str1 [ j ] ) ] += 1 NEW_LINE if ( curr_count [ ord ( str1 [ j ] ) ] == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( count == dist_count ) : NEW_LINE INDENT while ( curr_count [ ord ( str1 [ start ] ) ] > 1 ) : NEW_LINE INDENT if ( curr_count [ ord ( str1 [ start ] ) ] > 1 ) : NEW_LINE INDENT curr_count [ ord ( str1 [ start ] ) ] -= 1 NEW_LINE start += 1 NEW_LINE DEDENT DEDENT if ( min_len > len_window ) : NEW_LINE INDENT min_len = len_window NEW_LINE start_index = start NEW_LINE DEDENT DEDENT return str1 [ start_index : NEW_LINE INDENT start_index + min_len ] NEW_LINE DEDENT
def findStep ( n ) : NEW_LINE INDENT if ( n == 1 or n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( n == 2 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT else : NEW_LINE INDENT return findStep ( n - 3 ) + findStep ( n - 2 ) + findStep ( n - 1 ) NEW_LINE DEDENT DEDENT
def printSubsequences ( arr , n ) : NEW_LINE INDENT opsize = ( int ) ( math . pow ( 2 , n ) ) NEW_LINE counter = 1 NEW_LINE for counter in range ( 1 , opsize ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT if ( BigInteger . valueOf ( counter ) . testBit ( j ) ) : NEW_LINE INDENT print ( arr [ j ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT
def minXOR ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE minXor = + 2147483647 NEW_LINE val = 0 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT val = arr [ i ] ^ arr [ i + 1 ] NEW_LINE minXor = min ( minXor , val ) NEW_LINE DEDENT return minXor NEW_LINE DEDENT
def luDecomposition ( mat , n ) : NEW_LINE INDENT lower = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] NEW_LINE upper = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for k in range ( i , n ) : NEW_LINE INDENT Sum = 0 NEW_LINE for j in range ( i ) : NEW_LINE INDENT Sum += ( lower [ i ] [ j ] * upper [ j ] [ k ] ) NEW_LINE DEDENT upper [ i ] [ k ] = mat [ i ] [ k ] - Sum NEW_LINE DEDENT DEDENT for k in range ( i , n ) : NEW_LINE INDENT if ( i == k ) : NEW_LINE INDENT lower [ i ] [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT Sum = 0 NEW_LINE for j in range ( i ) : NEW_LINE INDENT Sum += ( lower [ k ] [ j ] * upper [ j ] [ i ] ) NEW_LINE DEDENT lower [ k ] [ i ] = ( mat [ k ] [ i ] - Sum ) / upper [ i ] [ i ] NEW_LINE DEDENT DEDENT DEDENT print ( setw ( 2 ) , " ▁ ▁ ▁ Lower ▁ Triangular " , setw ( 10 ) , " Upper ▁ Triangular " ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT print ( setw ( 4 ) + lower [ i ] [ j ] , end = " \t " ) NEW_LINE DEDENT print ( " \n " ) NEW_LINE DEDENT DEDENT
def bin ( n ) : NEW_LINE INDENT if ( n > 1 ) : NEW_LINE INDENT bin ( n > > 1 ) NEW_LINE DEDENT print ( " % d " , n & 1 ) NEW_LINE DEDENT
def CountPS ( st , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] NEW_LINE P = [ [ False for x in range ( n ) ] for y in range ( n ) ] NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( st [ i ] == st [ i + 1 ] ) : NEW_LINE INDENT P [ i ] [ i + 1 ] = True NEW_LINE DEDENT dp [ i ] [ i + 1 ] = 1 NEW_LINE DEDENT DEDENT for gap in range ( 2 , n ) : NEW_LINE INDENT for i in range ( gap , n ) : NEW_LINE INDENT for j in range ( gap , n ) : NEW_LINE INDENT if ( st [ i ] == st [ j ] and P [ i + 1 ] [ j - 1 ] ) : NEW_LINE INDENT P [ i ] [ j ] = True NEW_LINE DEDENT if ( P [ i ] [ j ] == True ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] + 1 - dp [ i + 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] - dp [ i + 1 ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT return dp [ 0 ] [ n - 1 ] NEW_LINE DEDENT
def modularEquation ( a , b ) : NEW_LINE INDENT if a < b : NEW_LINE INDENT print ( " No ▁ solution ▁ possible ▁ " ) NEW_LINE return - 1 NEW_LINE DEDENT if a == b : NEW_LINE INDENT print ( " Infinite ▁ Solution ▁ possible ▁ " ) NEW_LINE return - 1 NEW_LINE DEDENT count = 0 NEW_LINE n = a - b NEW_LINE y = ( int ) math . sqrt ( a - b ) NEW_LINE for i in range ( 1 , y + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT if n // i > b : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if i > b : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( y * y == n and y > b ) : NEW_LINE INDENT count -= 1 NEW_LINE DEDENT print ( count ) NEW_LINE DEDENT
def minimumSquare ( a , b ) : NEW_LINE INDENT result = 0 NEW_LINE rem = 0 NEW_LINE if a < b : NEW_LINE INDENT swap ( a , b ) NEW_LINE DEDENT while ( b > 0 ) : NEW_LINE INDENT result += a // b NEW_LINE rem = a % b NEW_LINE a = b NEW_LINE b = rem NEW_LINE DEDENT return result NEW_LINE DEDENT
def maxSum ( mat , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return mat [ 0 ] [ 0 ] NEW_LINE DEDENT dp = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] NEW_LINE maxSum = - float ( ' inf ' ) NEW_LINE for j in range ( n ) : NEW_LINE INDENT max = INT_MIN NEW_LINE if ( ( j - 1 ) >= 0 ) and ( max < dp [ i + 1 ] [ j - 1 ] ) : NEW_LINE INDENT max = dp [ i + 1 ] [ j - 1 ] NEW_LINE DEDENT if ( ( j + 1 ) < n ) : NEW_LINE INDENT max = dp [ i + 1 ] [ j + 1 ] NEW_LINE DEDENT dp [ i ] [ j ] = mat [ i ] [ j ] + max NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( maxSum < dp [ 0 ] [ j ] ) : NEW_LINE INDENT maxSum = dp [ 0 ] [ j ] NEW_LINE DEDENT DEDENT return maxSum NEW_LINE DEDENT
def findMinSum ( a , b , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE b . sort ( ) NEW_LINE sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum = sum + abs ( a [ i ] - b [ i ] ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
def deleteElements ( arr , n , k ) : NEW_LINE INDENT s = [ ] NEW_LINE s . append ( arr [ 0 ] ) NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT while ( not s . empty ( ) and s . peek ( ) < arr [ i ] and count < k ) : NEW_LINE INDENT s . pop ( ) NEW_LINE count += 1 NEW_LINE DEDENT s . append ( arr [ i ] ) NEW_LINE DEDENT m = len ( s ) NEW_LINE v = [ 0 ] * m NEW_LINE while ( len ( s ) > 0 ) : NEW_LINE INDENT v [ -- m ] = s . peek ( ) NEW_LINE s . pop ( ) NEW_LINE DEDENT for x in v : NEW_LINE INDENT print ( x , end = " ▁ " ) NEW_LINE DEDENT DEDENT print ( " " ) NEW_LINE DEDENT
def first ( str ) : NEW_LINE INDENT for i in range ( len ( str ) ) : NEW_LINE INDENT if ( ' ' in str [ i ] ) : NEW_LINE INDENT return str [ i ] NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT
def minDist ( arr , n , x , y ) : NEW_LINE INDENT min_dist = + 2147483647 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( ( x == arr [ i ] and y == arr [ j ] or y == arr [ i ] and x == arr [ j ] ) and min_dist > abs ( i - j ) ) : NEW_LINE INDENT min_dist = abs ( i - j ) NEW_LINE DEDENT DEDENT DEDENT return min_dist NEW_LINE DEDENT
def arcLength ( diameter , angle ) : NEW_LINE INDENT pi = 22.0 / 7.0 NEW_LINE arc = 0 NEW_LINE if angle >= 360 : NEW_LINE INDENT print ( " Angle ▁ cannot " , " ▁ be ▁ formed " ) NEW_LINE return 0 NEW_LINE DEDENT else : NEW_LINE INDENT arc = ( pi * diameter ) * ( angle / 360.0 ) NEW_LINE return arc NEW_LINE DEDENT DEDENT
def findSymPairs ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT first = arr [ i ] [ 0 ] NEW_LINE sec = arr [ i ] [ 1 ] NEW_LINE val = hM [ sec ] NEW_LINE if ( val != null and val == first ) : NEW_LINE INDENT print ( " ( " , sec , " , ▁ " , first , " ) " ) NEW_LINE DEDENT else : NEW_LINE INDENT s . add ( sec ) NEW_LINE DEDENT DEDENT
def isValidString ( string ) : NEW_LINE INDENT freq = [ 0 ] * CHARS NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT freq [ ord ( string [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT i = 0 NEW_LINE count_freq1 = 0 NEW_LINE for i in range ( CHARS ) : NEW_LINE INDENT if freq [ i ] != 0 : NEW_LINE INDENT freq1 = freq [ i ] NEW_LINE count_freq1 = 1 NEW_LINE break NEW_LINE DEDENT DEDENT j = i + 1 NEW_LINE for j in range ( CHARS ) : NEW_LINE INDENT if freq [ j ] == freq1 : NEW_LINE INDENT count_freq1 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_freq2 = 1 NEW_LINE freq2 = freq [ j ] NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT for k in range ( j + 1 , CHARS ) : NEW_LINE INDENT if freq [ k ] != 0 : NEW_LINE INDENT if freq [ k ] == freq1 : NEW_LINE INDENT count_freq1 += 1 NEW_LINE DEDENT if freq [ k ] == freq2 : NEW_LINE INDENT count_freq2 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if ( count_freq1 > 1 and count_freq2 > 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def isPrime ( n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def findMaxAverage ( arr , n , k ) : NEW_LINE INDENT if ( k > n ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT csum = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT csum [ i ] = csum [ i - 1 ] + arr [ i ] NEW_LINE DEDENT max_sum = csum [ k - 1 ] NEW_LINE max_end = k - 1 NEW_LINE for i in range ( k , n ) : NEW_LINE INDENT curr_sum = csum [ i ] - csum [ i - k ] NEW_LINE if ( curr_sum > max_sum ) : NEW_LINE INDENT max_sum = curr_sum NEW_LINE max_end = i NEW_LINE DEDENT DEDENT return max_end - k + 1 NEW_LINE DEDENT
def maximizecube ( l , b , h ) : NEW_LINE INDENT side = gcd ( l , gcd ( b , h ) ) NEW_LINE num = l / side NEW_LINE num = ( num * b / side ) NEW_LINE num = ( num * h / side ) NEW_LINE print ( side , " ▁ " , num ) NEW_LINE DEDENT
def horner ( poly , n , x ) : NEW_LINE INDENT result = poly [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT result = result * x + poly [ i ] NEW_LINE DEDENT return result NEW_LINE DEDENT
def rotate ( arr , n ) : NEW_LINE INDENT x = arr [ n ] NEW_LINE i = n NEW_LINE while i > 0 : NEW_LINE INDENT arr [ i ] = arr [ i - 1 ] NEW_LINE i = i - 1 NEW_LINE DEDENT arr [ 0 ] = x NEW_LINE DEDENT
def bonacciseries ( n , m ) : NEW_LINE INDENT a = [ 0 ] * m NEW_LINE for i in range ( 0 , m ) : NEW_LINE INDENT a [ i ] = 0 NEW_LINE DEDENT a [ n - 1 ] = 1 NEW_LINE a [ n ] = 1 NEW_LINE for i in range ( n + 1 , m ) : NEW_LINE INDENT a [ i ] = 2 * a [ i - 1 ] - a [ i - n - 1 ] NEW_LINE DEDENT for i in range ( 0 , m ) : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def numberOfWays ( x ) : NEW_LINE INDENT dp = [ 0 for _ in range ( x + 1 ) ] NEW_LINE dp [ 0 ] = dp [ 1 ] = 1 NEW_LINE for i in range ( 2 , x + 1 ) : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] NEW_LINE DEDENT return dp [ x ] NEW_LINE DEDENT
def findoptimal ( N ) : NEW_LINE INDENT if ( N <= 6 ) : NEW_LINE INDENT return N NEW_LINE DEDENT screen = [ 0 ] * N NEW_LINE b = 0 NEW_LINE n = 1 NEW_LINE for n in range ( 1 , 6 + 1 ) : NEW_LINE INDENT screen [ n - 1 ] = n NEW_LINE DEDENT for n in range ( 7 , N + 1 ) : NEW_LINE INDENT screen [ n - 1 ] = max ( 2 * screen [ n - 4 ] , max ( 3 * screen [ n - 5 ] , 4 * screen [ n - 6 ] ) ) NEW_LINE DEDENT return screen [ N - 1 ] NEW_LINE DEDENT
def maxRowDiff ( mat , m , n ) : NEW_LINE INDENT rowSum = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT Sum = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT Sum += mat [ i ] [ j ] NEW_LINE DEDENT rowSum [ i ] = Sum NEW_LINE DEDENT max_diff = rowSum [ 1 ] - rowSum [ 0 ] NEW_LINE min_element = rowSum [ 0 ] NEW_LINE for i in range ( 1 , m ) : NEW_LINE INDENT if ( rowSum [ i ] - min_element > max_diff ) : NEW_LINE INDENT max_diff = rowSum [ i ] - min_element NEW_LINE DEDENT if ( rowSum [ i ] < min_element ) : NEW_LINE INDENT min_element = rowSum [ i ] NEW_LINE DEDENT DEDENT return max_diff NEW_LINE DEDENT
def isPossible ( n , index , modulo , M , arr , dp ) : NEW_LINE INDENT modulo = ( ( modulo % M ) + M ) % M NEW_LINE if ( index == n ) : NEW_LINE INDENT if ( modulo == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT if ( dp [ index ] [ modulo ] != - 1 ) : NEW_LINE INDENT return dp [ index ] [ modulo ] NEW_LINE DEDENT placeAdd = isPossible ( n , index + 1 , modulo + arr [ index ] , M , arr , dp ) NEW_LINE placeMinus = isPossible ( n , index + 1 , modulo - arr [ index ] , M , arr , dp ) NEW_LINE res = placeAdd NEW_LINE dp [ index ] [ modulo ] = res NEW_LINE return res NEW_LINE DEDENT
def fib ( n ) : NEW_LINE INDENT if ( n < 6 ) : NEW_LINE INDENT return f [ n ] NEW_LINE DEDENT t = 5 NEW_LINE fn = 5 NEW_LINE while ( t < n ) : NEW_LINE INDENT fn = round ( fn * PHI ) NEW_LINE t += 1 NEW_LINE DEDENT return fn NEW_LINE DEDENT
def minCost ( cost , m , n ) : NEW_LINE INDENT tc = [ [ 0 for i in range ( n + 1 ) ] for j in range ( m + 1 ) ] NEW_LINE tc [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT tc [ i ] [ 0 ] = tc [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ] NEW_LINE DEDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT tc [ 0 ] [ j ] = tc [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ] NEW_LINE DEDENT for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT tc [ i ] [ j ] = min ( tc [ i - 1 ] [ j - 1 ] , tc [ i - 1 ] [ j ] , tc [ i ] [ j - 1 ] ) + cost [ i ] [ j ] NEW_LINE DEDENT DEDENT return tc [ m ] [ n ] NEW_LINE DEDENT
def amendSentence ( sstr ) : NEW_LINE INDENT for i in range ( len ( sstr ) ) : NEW_LINE INDENT if ( str [ i ] >= ' A ' and str [ i ] <= ' Z ' ) : NEW_LINE INDENT str [ i ] = chr ( ord ( sstr [ i ] ) + 32 ) NEW_LINE if ( i != 0 ) : NEW_LINE INDENT print ( " ▁ " , end = " ▁ " ) NEW_LINE DEDENT print ( str [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( str [ i ] ) NEW_LINE DEDENT DEDENT DEDENT
def countWays ( N ) : NEW_LINE INDENT count = [ 0 for x in range ( N + 1 ) ] NEW_LINE count [ 0 ] = 1 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( 0 , len ( arr ) ) : NEW_LINE INDENT if ( i >= arr [ j ] ) : NEW_LINE INDENT count [ i ] += count [ i - arr [ j ] ] NEW_LINE DEDENT DEDENT return count [ N ] NEW_LINE DEDENT
def count_of_ways ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT for k in range ( n + 1 ) : NEW_LINE INDENT if ( i + j + k == n ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def sumOfSeries ( n ) : NEW_LINE INDENT return ( 0.666 ) * ( 1 - 1 / math . pow ( 10 , n ) ) NEW_LINE DEDENT
def findDivision ( str , a , b ) : NEW_LINE INDENT lenn = len ( str ) NEW_LINE lr = [ 0 for i in range ( lenn ) ] NEW_LINE for i in range ( 1 , lenn ) : NEW_LINE INDENT lr [ 0 ] = ( ( lr [ i - 1 ] * 10 ) % a + ( ( int ) str [ i ] - ( int ) '0' ) ) % a NEW_LINE DEDENT rl = [ len + 1 ] NEW_LINE for i in range ( len - 1 ) : NEW_LINE INDENT rl [ i ] = ( rl [ i + 1 ] + ( ( int ) str [ i ] - ( int ) '0' ) * power10 ) % b NEW_LINE power10 = 10 NEW_LINE for i in range ( len - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( lr [ i ] != 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( rl [ i + 1 ] == 0 ) : NEW_LINE INDENT print ( str [ k ] , end = " ▁ " ) NEW_LINE for k in range ( i + 1 , len ) : NEW_LINE INDENT print ( str [ k ] , end = " ▁ " ) NEW_LINE for k in range ( i + 1 , len ) : NEW_LINE INDENT print ( str [ k ] , end = " " ) NEW_LINE DEDENT DEDENT return NEW_LINE DEDENT
def countCommon ( mat , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( mat [ i ] [ i ] == mat [ i ] [ n - i - 1 ] ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def hexagonalNum ( n ) : NEW_LINE INDENT return n * ( 2 * n - 1 ) NEW_LINE DEDENT
def findGreatest ( arr , n ) : NEW_LINE INDENT result = - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in arr : NEW_LINE INDENT for k in arr : NEW_LINE INDENT if j * arr [ k ] == arr [ i ] : NEW_LINE INDENT result = max ( result , arr [ i ] ) NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
def squareRoot ( n , p ) : NEW_LINE INDENT n = n % p NEW_LINE for x in range ( 2 , p ) : NEW_LINE INDENT if ( ( x * x ) % p == n ) : NEW_LINE INDENT print ( " Square ▁ root ▁ is " , x ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( " Square ▁ root ▁ is " , n ) NEW_LINE DEDENT
def count ( a , b ) : NEW_LINE INDENT m = len ( a ) NEW_LINE n = len ( b ) NEW_LINE lookup = [ [ 0 for i in range ( n + 1 ) ] for j in range ( m + 1 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT lookup [ 0 ] [ i ] = 0 NEW_LINE DEDENT for i in range ( m + 1 ) : NEW_LINE INDENT lookup [ i ] [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( a [ i - 1 ] == b [ j - 1 ] ) : NEW_LINE INDENT lookup [ i ] [ j ] = lookup [ i - 1 ] [ j - 1 ] + lookup [ i - 1 ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT lookup [ i ] [ j ] = lookup [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return lookup [ m ] [ n ] NEW_LINE DEDENT
def find_extra_element_index ( arrA , arrB ) : NEW_LINE INDENT extra_element = sum ( arrA ) - sum ( arrB ) NEW_LINE return indexOf ( arrA , extra_element ) NEW_LINE DEDENT
def find ( a , b , k , n1 , n2 ) : NEW_LINE INDENT s = Set ( ) NEW_LINE for i in range ( n2 ) : NEW_LINE INDENT s . add ( b [ i ] ) NEW_LINE DEDENT missing = 0 NEW_LINE for i in range ( n1 ) : NEW_LINE INDENT if ( not s . contains ( a [ i ] ) ) : NEW_LINE INDENT missing += 1 NEW_LINE DEDENT if ( missing == k ) : NEW_LINE INDENT return a [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def sumNodes ( l ) : NEW_LINE INDENT leafNodeCount = math . pow ( 2 , l - 1 ) NEW_LINE sumLastLevel = 0 NEW_LINE sumLastLevel = ( leafNodeCount * ( leafNodeCount + 1 ) ) / 2 NEW_LINE sum = sumLastLevel * l NEW_LINE return sum NEW_LINE DEDENT
def leonardo ( n ) : NEW_LINE INDENT dp = [ 0 for _ in range ( n + 1 ) ] NEW_LINE dp [ 0 ] = dp [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] + 1 NEW_LINE DEDENT return dp [ n ] NEW_LINE DEDENT
def countNumber ( n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 1 , 9 + 1 ) : NEW_LINE INDENT s = [ ] NEW_LINE if i <= n : NEW_LINE INDENT s . append ( i ) NEW_LINE result += 1 NEW_LINE DEDENT while len ( s ) > 0 : NEW_LINE INDENT tp = s [ 0 ] NEW_LINE s . pop ( ) NEW_LINE for j in range ( tp % 10 , 9 + 1 ) : NEW_LINE INDENT x = tp * 10 + j NEW_LINE if x <= n : NEW_LINE INDENT s . append ( x ) NEW_LINE result += 1 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
def check ( degree , n ) : NEW_LINE INDENT deg_sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT deg_sum += degree [ i ] NEW_LINE DEDENT return ( 2 * ( n - 1 ) == deg_sum ) NEW_LINE DEDENT
def evenbinomialCoeffSum ( n ) : NEW_LINE INDENT return ( 1 << ( n - 1 ) ) NEW_LINE DEDENT
def findMin ( arr , low , high ) : NEW_LINE INDENT if ( high < low ) : NEW_LINE INDENT return arr [ 0 ] NEW_LINE DEDENT if ( high == low ) : NEW_LINE INDENT return arr [ low ] NEW_LINE DEDENT mid = low + ( high - low ) // 2 NEW_LINE if ( mid < high and arr [ mid + 1 ] < arr [ mid ] ) : NEW_LINE INDENT return arr [ mid + 1 ] NEW_LINE DEDENT if ( mid > low and arr [ mid ] < arr [ mid - 1 ] ) : NEW_LINE INDENT return arr [ mid ] NEW_LINE DEDENT if ( arr [ high ] > arr [ mid ] ) : NEW_LINE INDENT return findMin ( arr , low , mid - 1 ) NEW_LINE DEDENT return findMin ( arr , mid + 1 , high ) NEW_LINE DEDENT
def findS ( s ) : NEW_LINE INDENT sum = 0 NEW_LINE for n in range ( 1 , s ) : NEW_LINE INDENT sum += n * n NEW_LINE if ( sum == s ) : NEW_LINE INDENT return n NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def getMaxOccuringChar ( str ) : NEW_LINE INDENT count = [ 0 for i in range ( ASCII_SIZE ) ] NEW_LINE len = len ( str ) NEW_LINE for i in range ( len ) : NEW_LINE INDENT count [ ord ( str [ i ] ) ] += 1 NEW_LINE DEDENT max = - 1 NEW_LINE result = ' ▁ ' NEW_LINE for i in range ( len ) : NEW_LINE INDENT if ( max < count [ ord ( str [ i ] ) ] ) : NEW_LINE INDENT max = count [ ord ( str [ i ] ) ] NEW_LINE result = ord ( str [ i ] ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def countStr ( n ) : NEW_LINE INDENT return 1 + ( n * 2 ) + ( n * ( ( n * n ) - 1 ) / 2 ) NEW_LINE DEDENT
def printSumSimple ( mat , k ) : NEW_LINE INDENT global n NEW_LINE if k > n : NEW_LINE INDENT return NEW_LINE DEDENT for i in range ( n - k + 1 ) : NEW_LINE INDENT for j in range ( n - k + 1 ) : NEW_LINE INDENT sum = 0 NEW_LINE for p in range ( i , k + i ) : NEW_LINE INDENT for q in range ( j , k + j ) : NEW_LINE INDENT sum += mat [ p ] [ q ] NEW_LINE DEDENT print ( sum , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT
def findCount ( n , sum ) : NEW_LINE INDENT start = ( int ) ( pow ( 10 , n - 1 ) ) NEW_LINE end = ( int ) ( pow ( 10 , n ) - 1 ) NEW_LINE count = 0 NEW_LINE i = start NEW_LINE while ( i < end ) : NEW_LINE INDENT cur = 0 NEW_LINE temp = i NEW_LINE while ( temp != 0 ) : NEW_LINE INDENT cur += temp % 10 NEW_LINE temp = int ( temp / 10 ) NEW_LINE DEDENT if ( cur == sum ) : NEW_LINE INDENT count += 1 NEW_LINE i += 9 NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT
def countGroups ( position , previous_sum , length , num ) : NEW_LINE INDENT if position == length : NEW_LINE INDENT return 1 NEW_LINE DEDENT if dp [ position ] [ previous_sum ] != - 1 : NEW_LINE INDENT return dp [ position ] [ previous_sum ] NEW_LINE DEDENT dp [ position ] [ previous_sum ] = 0 NEW_LINE res = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( position , length ) : NEW_LINE INDENT sum += ord ( num [ i ] ) - ord ( '0' ) NEW_LINE if ( sum >= previous_sum ) : NEW_LINE INDENT res += countGroups ( i + 1 , sum , length , num ) NEW_LINE DEDENT DEDENT dp [ position ] [ previous_sum ] = res NEW_LINE return res NEW_LINE DEDENT
def intersection ( n ) : NEW_LINE INDENT return n * ( n - 1 ) NEW_LINE DEDENT
def findSum ( n ) : NEW_LINE INDENT n -= 1 NEW_LINE sum = 0 NEW_LINE sum += ( n * ( n + 1 ) ) / 2 NEW_LINE sum += ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 NEW_LINE return sum NEW_LINE DEDENT
def findRepeatingElement ( arr , low , high ) : NEW_LINE INDENT if low > high : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = low + ( high - low ) / 2 NEW_LINE if arr [ mid ] != mid + 1 : NEW_LINE INDENT if mid > 0 and arr [ mid ] == arr [ mid - 1 ] : NEW_LINE INDENT return mid NEW_LINE DEDENT return findRepeatingElement ( arr , low , mid - 1 ) NEW_LINE DEDENT
def smallest ( x , y , z ) : NEW_LINE INDENT c = 0 NEW_LINE while ( x != 0 and y != 0 and z != 0 ) : NEW_LINE INDENT x -= 1 NEW_LINE y -= 1 NEW_LINE z -= 1 NEW_LINE c += 1 NEW_LINE DEDENT return c NEW_LINE DEDENT
def maxAverageOfPath ( cost , N ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( N + 1 ) ] for j in range ( N + 1 ) ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT dp [ i ] [ 0 ] = cost [ 0 ] [ 0 ] NEW_LINE for j in range ( 1 , N ) : NEW_LINE INDENT dp [ 0 ] [ j ] = dp [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ] NEW_LINE DEDENT DEDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( 1 , N + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) + cost [ i ] [ j ] NEW_LINE DEDENT DEDENT return dp [ N - 1 ] [ N - 1 ] / ( 2 * N - 1 ) NEW_LINE DEDENT
def countPairsWithDiffK ( arr , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in arr : NEW_LINE INDENT for j in arr : NEW_LINE INDENT if ( arr [ i ] - arr [ j ] == k or arr [ j ] - arr [ i ] == k ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def longLenSub ( arr , n ) : NEW_LINE INDENT um = dict ( ) NEW_LINE longLen = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT len = 0 NEW_LINE if ( um [ arr [ i ] - 1 ] and len < um [ arr [ i ] - 1 ] ) : NEW_LINE INDENT len = um [ arr [ i ] - 1 ] NEW_LINE DEDENT if ( um [ arr [ i ] + 1 ] and len < um [ arr [ i ] + 1 ] ) : NEW_LINE INDENT len = um [ arr [ i ] + 1 ] NEW_LINE DEDENT um [ arr [ i ] ] = len + 1 NEW_LINE if ( longLen < um [ arr [ i ] ] ) : NEW_LINE INDENT longLen = um [ arr [ i ] ] NEW_LINE DEDENT DEDENT return longLen NEW_LINE DEDENT
def isPrime ( n , i ) : NEW_LINE INDENT if n <= 2 : NEW_LINE INDENT return True NEW_LINE DEDENT if n % i == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT if i * i > n : NEW_LINE INDENT return True NEW_LINE DEDENT return isPrime ( n , i + 1 ) NEW_LINE DEDENT
def computeLastDigit ( A , B ) : NEW_LINE INDENT variable = 1 NEW_LINE if A == B : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( B - A ) >= 5 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( A + 1 , B + 1 ) : NEW_LINE INDENT variable = ( int ) ( variable * ( i % 10 ) ) % 10 NEW_LINE DEDENT return variable % 10 NEW_LINE DEDENT
def minOperation ( arr ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( M - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] [ j ] == False ) : NEW_LINE INDENT ans += 1 NEW_LINE for k in range ( i + 1 , - 1 ) : NEW_LINE INDENT for h in range ( j + 1 ) : NEW_LINE INDENT if ( arr [ k ] [ h ] == True ) : NEW_LINE INDENT arr [ k ] [ h ] = False NEW_LINE DEDENT else : NEW_LINE INDENT arr [ k ] [ h ] = True NEW_LINE DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def nextPowerOf2 ( n ) : NEW_LINE INDENT p = 1 NEW_LINE if ( n > 0 and ( n & ( n - 1 ) ) == 0 ) : NEW_LINE INDENT return n NEW_LINE DEDENT while ( p < n ) : NEW_LINE INDENT p <<= 1 NEW_LINE DEDENT return p NEW_LINE DEDENT
def getMinDiff ( arr , n , k ) : NEW_LINE INDENT if ( n == 1 ) : return 0 NEW_LINE arr . sort ( ) NEW_LINE ans = arr [ n - 1 ] - arr [ 0 ] NEW_LINE small = arr [ 0 ] + k NEW_LINE big = arr [ n - 1 ] - k NEW_LINE temp = 0 NEW_LINE if ( small > big ) : NEW_LINE INDENT temp = small NEW_LINE small = big NEW_LINE big = temp NEW_LINE DEDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT subtract = arr [ i ] - k NEW_LINE add = arr [ i ] + k NEW_LINE if ( subtract >= small or add <= big ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( big - subtract <= add - small ) : NEW_LINE INDENT small = subtract NEW_LINE DEDENT else : NEW_LINE INDENT big = add NEW_LINE DEDENT DEDENT return min ( ans , big - small ) NEW_LINE DEDENT
def numberofways ( n , m ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n + 2 ) ] for j in range ( n + 2 ) ] NEW_LINE for k in range ( m ) : NEW_LINE INDENT for i in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ k ] = dp [ i ] [ k + 1 ] NEW_LINE if i - k >= 0 : NEW_LINE INDENT dp [ i ] [ k ] = ( dp [ i ] [ k ] + dp [ i - k ] [ k ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ n ] [ m ] NEW_LINE DEDENT
def check ( n ) : NEW_LINE INDENT return 1162261467 % n == 0 NEW_LINE DEDENT
def sequence ( n ) : NEW_LINE INDENT if ( n == 1 or n == 2 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return sequence ( sequence ( n - 1 ) ) + sequence ( n - sequence ( n - 1 ) ) NEW_LINE DEDENT
def generate_derangement ( N ) : NEW_LINE INDENT S = [ 0 ] * ( N + 1 ) NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT S [ i ] = i NEW_LINE DEDENT D = [ 0 ] * ( N + 1 ) NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( i == N ) : NEW_LINE INDENT D [ N ] = S [ N - 1 ] NEW_LINE D [ N - 1 ] = S [ N ] NEW_LINE DEDENT else : NEW_LINE INDENT D [ i ] = i + 1 NEW_LINE D [ i + 1 ] = i NEW_LINE DEDENT DEDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT print ( D [ i ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT
def countTriangle ( graph , isDirected ) : NEW_LINE INDENT count_Triangle = 0 NEW_LINE for i in range ( V ) : NEW_LINE INDENT for j in range ( V ) : NEW_LINE INDENT for k in range ( V ) : NEW_LINE INDENT if ( graph [ i ] [ j ] == 1 and graph [ j ] [ k ] == 1 and graph [ k ] [ i ] == 1 ) : NEW_LINE INDENT count_Triangle += 1 NEW_LINE DEDENT DEDENT DEDENT if ( isDirected == True ) : NEW_LINE INDENT count_Triangle /= 3 NEW_LINE DEDENT else : NEW_LINE INDENT count_Triangle /= 6 NEW_LINE DEDENT DEDENT return count_Triangle NEW_LINE DEDENT
def findHeight ( parent , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT p = i NEW_LINE current = 1 NEW_LINE while ( parent [ p ] != - 1 ) : NEW_LINE INDENT current += 1 NEW_LINE p = parent [ p ] NEW_LINE DEDENT res = max ( res , current ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def leonardo ( n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return ( leonardo ( n - 1 ) + leonardo ( n - 2 ) + 1 ) NEW_LINE DEDENT
def findLargestPlus ( mat ) : NEW_LINE INDENT left = [ [ 0 for i in range ( 10 ) ] for j in range ( 10 ) ] NEW_LINE right = [ [ 0 for i in range ( 10 ) ] for j in range ( 10 ) ] NEW_LINE top = [ [ 0 for i in range ( 10 ) ] for j in range ( 10 ) ] NEW_LINE bottom = [ [ 0 for i in range ( 10 ) ] for j in range ( 10 ) ] NEW_LINE if ( mat [ i ] [ j ] == 1 ) : NEW_LINE INDENT left [ i ] [ j ] = left [ i ] [ j - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT top [ j ] [ i ] = 0 NEW_LINE DEDENT if ( mat [ j ] [ i ] == 1 ) : NEW_LINE INDENT top [ j ] [ i ] = top [ j - 1 ] [ i ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT top [ j ] [ i ] = 0 NEW_LINE DEDENT j = N - 1 - j NEW_LINE if ( mat [ i ] [ j ] == 1 ) : NEW_LINE INDENT bottom [ j ] [ i ] = bottom [ j + 1 ] [ i ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT bottom [ j ] [ i ] = 0 NEW_LINE DEDENT if ( mat [ i ] [ j ] == 1 ) : NEW_LINE INDENT right [ i ] [ j ] = right [ i ] [ j + 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT right [ i ] [ j ] = 0 NEW_LINE DEDENT j = N - 1 - j NEW_LINE DEDENT DEDENT n = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if ( n > 0 ) : NEW_LINE INDENT return 4 * ( n - 1 ) + 1 NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT
def HalfDiagonalSums ( mat , n ) : NEW_LINE INDENT diag1_left = 0 NEW_LINE diag1_right = 0 NEW_LINE diag2_left = 0 NEW_LINE diag2_right = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( i < n // 2 ) : NEW_LINE INDENT diag1_left += mat [ i ] [ i ] NEW_LINE diag2_left += mat [ j ] [ i ] NEW_LINE DEDENT elif ( i > n // 2 ) : NEW_LINE INDENT diag1_right += mat [ i ] [ i ] NEW_LINE diag2_right += mat [ j ] [ i ] NEW_LINE DEDENT DEDENT return ( diag1_left == diag2_right and diag2_right == diag2_left and diag1_right == diag2_right and diag2_right == mat [ n // 2 ] [ n // 2 ] ) NEW_LINE DEDENT
def sumAtKthLevel ( tree , k ) : NEW_LINE INDENT level = - 1 NEW_LINE sum = 0 NEW_LINE n = len ( tree ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( tree [ i ] == ' ( ' ) : NEW_LINE INDENT level += 1 NEW_LINE DEDENT elif ( tree [ i ] == ' ( ' ) : NEW_LINE INDENT level -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( level == k ) : NEW_LINE INDENT sum += ( tree [ i ] - '0' ) NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def LeibnizHarmonicTriangle ( n ) : NEW_LINE INDENT C = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , min ( i , n + 1 ) ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT print ( "1 / " , i * C [ i - 1 ] [ j - 1 ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT
def countWays ( s ) : NEW_LINE INDENT count = [ 0 for i in range ( 26 ) ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT count [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT count [ ord ( s [ 0 ] ) - ord ( ' a ' ) ] = 1 NEW_LINE DEDENT ans = 1 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if ( count [ i ] != 0 ) : NEW_LINE INDENT ans = ans * count [ i ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def countWays ( n , m ) : NEW_LINE INDENT count = [ 0 for _ in range ( n + 1 ) ] NEW_LINE count [ 0 ] = 0 NEW_LINE i = 1 NEW_LINE while i <= n : NEW_LINE INDENT if ( i > m ) : NEW_LINE INDENT count [ i ] = ( count [ i - 1 ] + count [ i - m ] ) NEW_LINE DEDENT elif ( i < m ) : NEW_LINE INDENT count [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT count [ i ] = 2 NEW_LINE DEDENT DEDENT return count [ n ] NEW_LINE DEDENT
def printCommonElements ( mat ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for j in range ( N ) : NEW_LINE INDENT mp [ mat [ 0 ] [ j ] ] = 1 NEW_LINE DEDENT for i in range ( 1 , M ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if ( mp [ mat [ i ] [ j ] ] != null and mp [ mat [ i ] [ j ] ] == i ) : NEW_LINE INDENT mp [ mat [ i ] [ j ] ] = i + 1 NEW_LINE if ( i == M - 1 ) : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def floorSearch ( arr , n , x ) : NEW_LINE INDENT if x >= arr [ n - 1 ] : NEW_LINE INDENT return n - 1 NEW_LINE DEDENT if x < arr [ 0 ] : NEW_LINE INDENT return - 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if arr [ i ] > x : NEW_LINE INDENT return ( i - 1 ) NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def nextPowerOf2 ( n ) : NEW_LINE INDENT p = 1 NEW_LINE if ( n > 0 and ( n & ( n - 1 ) ) == 0 ) : NEW_LINE INDENT return n NEW_LINE DEDENT while ( p < n ) : NEW_LINE INDENT p <<= 1 NEW_LINE DEDENT return p NEW_LINE DEDENT
def printkthnode ( adj , wt , n , k ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT adj . sort ( ) NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( adj [ i ] . size ( ) >= k ) : NEW_LINE INDENT print ( adj [ i ] [ len ( adj [ i ] ) - k ] . second , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT DEDENT DEDENT
def longest ( a , n , k ) : NEW_LINE INDENT freq = [ 0 ] * 7 NEW_LINE start = 0 NEW_LINE end = 0 NEW_LINE now = 0 l = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ a [ i ] ] += 1 NEW_LINE if ( freq [ a [ i ] ] == 1 ) : NEW_LINE INDENT now += 1 NEW_LINE DEDENT while ( now > k ) : NEW_LINE INDENT freq [ a [ l ] ] -= 1 NEW_LINE if ( freq [ a [ l ] ] == 0 ) : NEW_LINE INDENT now -= 1 NEW_LINE l += 1 NEW_LINE DEDENT if ( i - l + 1 >= end - start + 1 ) : NEW_LINE INDENT end = i NEW_LINE start = l NEW_LINE DEDENT DEDENT for i in range ( start , end + 1 ) : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def minimumflip ( mat , n ) : NEW_LINE INDENT flip = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , i ) : NEW_LINE INDENT if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) : NEW_LINE INDENT flip += 1 NEW_LINE DEDENT DEDENT DEDENT return flip NEW_LINE DEDENT
def breakSum ( n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT return max ( ( breakSum ( n // 2 ) + breakSum ( n / 3 ) + breakSum ( n / 4 ) ) , n ) NEW_LINE DEDENT
def countPairs ( arr1 , arr2 , m , n , x ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , m ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT if ( ( arr1 [ i ] + arr2 [ j ] ) == x ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def alternateSubarray ( arr , n ) : NEW_LINE INDENT len = [ 0 ] * n NEW_LINE len [ n - 1 ] = 1 NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] ^ arr [ i + 1 ] == True ) : NEW_LINE INDENT len [ i ] = len [ i + 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT len [ i ] = 1 NEW_LINE DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( len [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def subsequence ( s , t , n , k ) : NEW_LINE INDENT last = 0 NEW_LINE cnt = 0 NEW_LINE new_last = 0 NEW_LINE size = 0 NEW_LINE for ch in range ( ' z ' , ' a ' ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( last , n ) : NEW_LINE INDENT if ( s [ i ] == ch ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT if ( cnt >= k ) : NEW_LINE INDENT for i in range ( last , n ) : NEW_LINE INDENT if ( s [ i ] == ch ) : NEW_LINE INDENT t [ size ] = ch NEW_LINE new_last = i NEW_LINE DEDENT DEDENT last = new_last NEW_LINE DEDENT DEDENT t [ size ] = ' \0 ' NEW_LINE DEDENT
def maxLen ( arr , n ) : NEW_LINE INDENT max_len = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT curr_sum = 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT curr_sum += arr [ j ] NEW_LINE if curr_sum == 0 : NEW_LINE INDENT max_len = max ( max_len , j - i + 1 ) NEW_LINE DEDENT DEDENT DEDENT return max_len NEW_LINE DEDENT
def findWays ( m , n , x ) : NEW_LINE INDENT table = [ [ 0 for x in range ( n + 1 ) ] for j in range ( x + 1 ) ] NEW_LINE for j in range ( 1 , m and j <= x ) : NEW_LINE INDENT table [ 1 ] [ j ] = 1 NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , x + 1 ) : NEW_LINE INDENT for k in range ( 1 , m + 1 ) : NEW_LINE INDENT table [ i ] [ j ] += table [ i - 1 ] [ j - k ] NEW_LINE DEDENT DEDENT DEDENT return table [ n ] [ x ] NEW_LINE DEDENT
def checkCorrectOrNot ( s ) : NEW_LINE INDENT count = [ 0 ] * MAX_CHAR NEW_LINE n = len ( s ) NEW_LINE if ( n == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT for i in range ( 0 , n - 1 , - 1 ) : NEW_LINE INDENT count [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE count [ ord ( s [ j ] ) - ord ( ' a ' ) ] -= 1 NEW_LINE DEDENT for i in range ( 0 , MAX_CHAR ) : NEW_LINE INDENT if ( count [ i ] != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def findNumberOfTriangles ( arr , n ) : NEW_LINE INDENT arr = sorted ( arr ) NEW_LINE count = 0 NEW_LINE for i in range ( 0 , n - 2 ) : NEW_LINE INDENT k = i + 2 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT while ( k < n and arr [ i ] + arr [ j ] > arr [ k ] ) : NEW_LINE INDENT k += 1 NEW_LINE DEDENT if ( k > j ) : NEW_LINE INDENT count += k - j - 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def countWays ( n ) : NEW_LINE INDENT A = [ 0 ] * ( n + 1 ) NEW_LINE B = [ 0 ] * ( n + 1 ) NEW_LINE A [ 0 ] = 1 NEW_LINE A [ 1 ] = 0 NEW_LINE B [ 0 ] = 0 NEW_LINE B [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT A [ i ] = A [ i - 2 ] + 2 * B [ i - 1 ] NEW_LINE B [ i ] = A [ i - 1 ] + B [ i - 2 ] NEW_LINE DEDENT return A [ n ] NEW_LINE DEDENT
def lcs ( X , Y , m , n ) : NEW_LINE INDENT if ( m == 0 or n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( X [ m - 1 ] == Y [ n - 1 ] ) : NEW_LINE INDENT return 1 + lcs ( X , Y , m - 1 , n - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return max ( lcs ( X , Y , m , n - 1 ) , lcs ( X , Y , m - 1 , n ) ) NEW_LINE DEDENT DEDENT
def minValue ( A , B , n ) : NEW_LINE INDENT A . sort ( ) NEW_LINE B . sort ( ) NEW_LINE result = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT result += ( A [ i ] * B [ n - i - 1 ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT
def isOneFlip ( str ) : NEW_LINE INDENT sum = 0 NEW_LINE n = len ( str ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += ord ( str [ i ] ) - ord ( '0' ) NEW_LINE DEDENT return ( sum == n - 1 or sum == 1 ) NEW_LINE DEDENT
def MatrixChainOrder ( p , i , j ) : NEW_LINE INDENT if i == j : NEW_LINE INDENT return 0 NEW_LINE DEDENT min = + 2147483647 NEW_LINE for k in range ( i , j ) : NEW_LINE INDENT count = ( MatrixChainOrder ( p , i , k ) + MatrixChainOrder ( p , k + 1 , j ) + p [ i - 1 ] * p [ k ] * p [ j ] ) NEW_LINE if count < min ) : NEW_LINE INDENT min = count NEW_LINE DEDENT DEDENT return min NEW_LINE DEDENT
def multiply ( x , y ) : NEW_LINE INDENT if ( y == 0 ) : return 0 NEW_LINE if ( y > 0 ) : NEW_LINE INDENT return ( x + multiply ( x , y - 1 ) ) NEW_LINE DEDENT if ( y < 0 ) : NEW_LINE INDENT return - multiply ( x , - y ) NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def countP ( n , k ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( k + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( 1 , k + 1 ) : NEW_LINE INDENT if ( j == 1 or i == j ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = j * dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT DEDENT return dp [ n ] [ k ] NEW_LINE DEDENT
def worstFit ( blockSize , m , processSize , n ) : NEW_LINE INDENT allocation = [ - 1 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT wstIdx = - 1 NEW_LINE for j in range ( m ) : NEW_LINE INDENT if ( blockSize [ j ] >= processSize [ i ] ) : NEW_LINE INDENT if ( wstIdx == - 1 ) : NEW_LINE INDENT wstIdx = j NEW_LINE DEDENT elif ( blockSize [ wstIdx ] < blockSize [ j ] ) : NEW_LINE INDENT wstIdx = j NEW_LINE DEDENT DEDENT DEDENT if ( wstIdx != - 1 ) : NEW_LINE INDENT allocation [ i ] = wstIdx NEW_LINE blockSize [ wstIdx ] -= processSize [ i ] NEW_LINE DEDENT DEDENT print ( " Process ▁ No . \tProcess ▁ Size\tBlock ▁ no . " ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( " ▁ ▁ " , i + 1 , " \t\t " , processSize [ i ] , " \t\t " , allocation [ i ] + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ Allocated " ) NEW_LINE DEDENT DEDENT
def maxvolume ( s ) : NEW_LINE INDENT length = s // 3 NEW_LINE s -= length NEW_LINE breadth = s // 2 NEW_LINE height = s - breadth NEW_LINE return length * breadth * height NEW_LINE DEDENT
def findLength ( string ) : NEW_LINE INDENT n = len ( string ) NEW_LINE maxlen = 0 NEW_LINE sum = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum [ i ] [ i ] = ord ( string [ i ] ) - ord ( '0' ) NEW_LINE DEDENT for len in range ( 2 , n + 1 ) : NEW_LINE INDENT for i in range ( n - len + 1 ) : NEW_LINE INDENT j = i + len - 1 NEW_LINE k = len // 2 NEW_LINE if ( len % 2 == 0 and sum [ i ] [ j - k ] == sum [ ( j - k + 1 ) ] [ j ] and len > maxlen ) : NEW_LINE INDENT maxlen = len NEW_LINE DEDENT DEDENT DEDENT return maxlen NEW_LINE DEDENT
def subArraySum ( arr , n , Sum ) : NEW_LINE INDENT curr_sum = arr [ 0 ] NEW_LINE start = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT while ( curr_sum > Sum and start < i - 1 ) : NEW_LINE INDENT curr_sum = curr_sum - arr [ start ] NEW_LINE start += 1 NEW_LINE DEDENT if ( curr_sum == Sum ) : NEW_LINE INDENT p = i - 1 NEW_LINE print ( " Sum ▁ found ▁ between ▁ indexes ▁ 0 ▁ and " , p ) NEW_LINE return 1 NEW_LINE DEDENT if ( i < n ) : NEW_LINE INDENT curr_sum = curr_sum + arr [ i ] NEW_LINE DEDENT DEDENT print ( " No ▁ subarray ▁ found " ) NEW_LINE return 0 NEW_LINE DEDENT
def commonCharacters ( str , n ) : NEW_LINE INDENT prim = [ False for x in range ( MAX_CHAR ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT sec = [ False for y in range ( MAX_CHAR ) ] NEW_LINE for j in range ( len ( str [ i ] ) ) : NEW_LINE INDENT if ( prim [ ord ( str [ i ] [ j ] ) - ord ( ' a ' ) ] == True ) : NEW_LINE INDENT sec [ ord ( str [ i ] [ j ] ) - ord ( ' a ' ) ] = True NEW_LINE DEDENT DEDENT for i in range ( 26 ) : NEW_LINE INDENT if ( prim [ i ] ) : NEW_LINE INDENT print ( chr ( i + 97 ) ) NEW_LINE print ( " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
def canMakeStr2 ( str1 , str2 ) : NEW_LINE INDENT count = [ 0 ] * MAX NEW_LINE for i in range ( len ( str1 ) ) : NEW_LINE INDENT count [ ord ( str1 [ i ] ) - 97 ] += 1 NEW_LINE DEDENT char [ ] str3 = str2 [ : ] NEW_LINE for i in range ( len ( str3 ) ) : NEW_LINE INDENT if ( count [ ord ( str3 [ i ] ) ] == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT count [ ord ( str4 [ i ] ) ] -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT
def generateSquare ( n ) : NEW_LINE INDENT magicSquare = [ [ 0 for x in range ( n + 1 ) ] for y in range ( n + 1 ) ] NEW_LINE i = n // 2 NEW_LINE j = n - 1 NEW_LINE for num in range ( 1 , n * n + 1 ) : NEW_LINE INDENT if ( i == - 1 and j == n ) : NEW_LINE INDENT j = n - 2 NEW_LINE i = 0 NEW_LINE DEDENT else : NEW_LINE INDENT if ( i < 0 ) : NEW_LINE INDENT i = n - 1 NEW_LINE DEDENT DEDENT if ( magicSquare [ i ] [ j ] != 0 ) : NEW_LINE INDENT j -= 2 NEW_LINE i += 1 NEW_LINE continue NEW_LINE DEDENT else : NEW_LINE INDENT magicSquare [ i ] [ j ] = num NEW_LINE j += 1 NEW_LINE i -= 1 NEW_LINE DEDENT DEDENT print ( " The ▁ Magic ▁ Square ▁ for ▁ " , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT print ( magicSquare [ i ] [ j ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT
def count ( a , b , m , n ) : NEW_LINE INDENT if ( ( m == 0 and n == 0 ) or n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( m == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( a [ m - 1 ] == b [ n - 1 ] ) : NEW_LINE INDENT return count ( a , b , m - 1 , n - 1 ) + count ( a , b , m - 1 , n ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( count ( a , b , m - 1 , n ) NEW_LINE DEDENT DEDENT
def numofArray ( n , m ) : NEW_LINE INDENT dp = [ [ 0 for j in range ( MAX ) ] for i in range ( MAX ) ] NEW_LINE mu = [ [ 0 for j in range ( MAX ) ] for i in range ( MAX ) ] NEW_LINE for i in range ( 0 , MAX ) : NEW_LINE INDENT di [ i ] = [ ] NEW_LINE mu [ i ] = [ ] NEW_LINE DEDENT for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 2 * i , m + i ) : NEW_LINE INDENT di [ j ] . append ( i ) NEW_LINE mu [ i ] . append ( j ) NEW_LINE DEDENT di [ i ] . append ( i ) NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , m + 1 ) : NEW_LINE INDENT dp [ 1 ] [ j ] = 1 NEW_LINE for x in di [ j ] : NEW_LINE INDENT dp [ i ] [ j ] += dp [ i - 1 ] [ x ] NEW_LINE DEDENT for x in mu [ j ] : NEW_LINE INDENT dp [ i ] [ j ] += dp [ i - 1 ] [ x ] NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT ans += dp [ n ] [ i ] NEW_LINE di [ i ] . clear ( ) NEW_LINE mu [ i ] . clear ( ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def countOnes ( arr , low , high ) : NEW_LINE INDENT if ( high >= low ) : NEW_LINE INDENT mid = low + ( high - low ) // 2 NEW_LINE if ( ( mid == high or arr [ mid + 1 ] == 0 ) and ( arr [ mid ] == 1 ) ) : NEW_LINE INDENT return mid + 1 NEW_LINE DEDENT if ( arr [ mid ] == 1 ) : NEW_LINE INDENT return countOnes ( arr , ( mid + 1 ) , high ) NEW_LINE DEDENT return countOnes ( arr , low , ( mid - 1 ) ) NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT
def ceilSearch ( arr , low , high , x ) : NEW_LINE INDENT if x <= arr [ low ] : NEW_LINE INDENT return low NEW_LINE DEDENT if x > arr [ high ] : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = low + ( high - low ) / 2 NEW_LINE if arr [ mid ] == x : NEW_LINE INDENT return mid NEW_LINE DEDENT elif arr [ mid ] < x : NEW_LINE INDENT if mid + 1 <= high and x <= arr [ mid + 1 ] : NEW_LINE INDENT return mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT return ceilSearch ( arr , mid + 1 , high , x ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if arr [ mid - 1 >= low and x > arr [ mid - 1 ] : NEW_LINE INDENT return mid NEW_LINE DEDENT DEDENT return ceilSearch ( arr , low , mid - 1 , x ) NEW_LINE DEDENT DEDENT
def decToBin ( n ) : NEW_LINE INDENT if ( n == 0 ) : return "0" NEW_LINE bin = " " NEW_LINE while ( n > 0 ) : NEW_LINE INDENT bin = ( ( n & 1 ) == 0 ? '0' : '1' ) + bin NEW_LINE n >>= 1 NEW_LINE DEDENT return bin NEW_LINE DEDENT
def printNos ( n ) : NEW_LINE INDENT if ( n > 0 ) : NEW_LINE INDENT printNos ( n - 1 ) NEW_LINE print ( n , end = " ▁ " ) NEW_LINE DEDENT return NEW_LINE DEDENT
def prefixSum2D ( a ) : NEW_LINE INDENT R = len ( a ) NEW_LINE C = len ( a [ 0 ] ) NEW_LINE psa = [ [ 0 for i in range ( C ) ] for j in range ( R ) ] NEW_LINE for i in range ( 1 , R ) : NEW_LINE INDENT for j in range ( 1 , C ) : NEW_LINE INDENT psa [ i ] [ j ] = psa [ i - 1 ] [ j ] + psa [ i ] [ j - 1 ] - psa [ i - 1 ] [ j - 1 ] + a [ i ] [ j ] NEW_LINE DEDENT DEDENT for i in range ( R ) : NEW_LINE INDENT for j in range ( 1 , C ) : NEW_LINE INDENT psa [ i ] [ j ] = psa [ i - 1 ] [ j ] + psa [ i ] [ j - 1 ] - psa [ i - 1 ] [ j - 1 ] + a [ i ] [ j ] NEW_LINE DEDENT DEDENT for i in range ( R ) : NEW_LINE INDENT for j in range ( C ) : NEW_LINE INDENT print ( psa [ i ] [ j ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT
def eulerian ( n , m ) : NEW_LINE INDENT if ( m >= n or n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( m == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return ( n - m ) * eulerian ( n - 1 , m - 1 ) + ( m + 1 ) * eulerian ( n - 1 , m ) NEW_LINE DEDENT
def findSubarraySum ( arr , n ) : NEW_LINE INDENT m = dict ( ) NEW_LINE res = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT Sum = 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT Sum += arr [ j ] NEW_LINE if m . get ( Sum ) : NEW_LINE INDENT m [ Sum ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT m [ Sum ] = 1 NEW_LINE DEDENT DEDENT DEDENT for x in m : NEW_LINE INDENT if x . getValue ( ) == 1 : NEW_LINE INDENT res += x . getKey ( ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def isMultipleOf3 ( n ) : NEW_LINE INDENT odd_count = 0 NEW_LINE even_count = 0 NEW_LINE if ( n < 0 ) : NEW_LINE INDENT n = - n NEW_LINE DEDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT while ( n != 0 ) : NEW_LINE INDENT if ( ( n & 1 ) != 0 ) : NEW_LINE INDENT odd_count += 1 NEW_LINE DEDENT if ( ( n & 2 ) != 0 ) : NEW_LINE INDENT even_count += 1 NEW_LINE DEDENT n = n > > 2 NEW_LINE DEDENT return isMultipleOf3 ( abs ( odd_count - even_count ) ) NEW_LINE DEDENT
def longestSubsequenceCommonSegment ( k , s1 , s2 ) : NEW_LINE INDENT n = len ( s1 ) NEW_LINE m = len ( s2 ) NEW_LINE lcs = [ [ 0 for i in range ( m + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE cnt = [ [ 0 for i in range ( n + 1 ) ] for j in range ( m + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , m + 1 ) : NEW_LINE INDENT lcs [ i ] [ j ] = max ( lcs [ i - 1 ] [ j ] , lcs [ i ] [ j - 1 ] ) NEW_LINE if ( s1 [ i - 1 ] == s2 [ j - 1 ] ) : NEW_LINE INDENT cnt [ i ] [ j ] = cnt [ i - 1 ] [ j - 1 ] + 1 NEW_LINE DEDENT if ( cnt [ i ] [ j ] >= k ) : NEW_LINE INDENT for a in range ( k , cnt [ i ] [ j ] + 1 ) : NEW_LINE INDENT lcs [ i ] [ j ] = max ( lcs [ i ] [ j ] , lcs [ i - a ] [ j - a ] + a ) NEW_LINE DEDENT DEDENT DEDENT return lcs [ n ] [ m ] NEW_LINE DEDENT
def areaSquare ( side ) : NEW_LINE INDENT area = side * side NEW_LINE return area NEW_LINE DEDENT
def findpath ( graph , n ) : NEW_LINE INDENT numofadj = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] NEW_LINE startPoint = 0 NEW_LINE numofodd = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( numofadj [ i ] % 2 == 1 ) : NEW_LINE INDENT numofodd += 1 NEW_LINE startPoint = i NEW_LINE DEDENT DEDENT if ( numofodd > 2 ) : NEW_LINE INDENT print ( " No ▁ Solution " ) NEW_LINE return NEW_LINE DEDENT stack = [ ] NEW_LINE path = [ ] NEW_LINE cur = startPoint NEW_LINE while ( len ( stack ) != 0 or accumulate ( graph [ cur ] , 0 ) == 0 ) : NEW_LINE INDENT path . append ( cur ) NEW_LINE cur = stack . pop ( ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( graph [ cur ] [ i ] == 1 ) : NEW_LINE INDENT stack . append ( cur ) NEW_LINE graph [ cur ] [ i ] = 0 NEW_LINE graph [ i ] [ cur ] = 0 NEW_LINE cur = i NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT for ele in path : NEW_LINE INDENT print ( ele ) NEW_LINE DEDENT
def lcsOf3 ( i , j , k ) : NEW_LINE INDENT if i == - 1 or j == - 1 or k == - 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if dp [ i ] [ j ] [ k ] != - 1 : NEW_LINE INDENT return dp [ i ] [ j ] [ k ] NEW_LINE DEDENT if X [ i ] == Y [ j ] and Y [ j ] == Z [ k ] : NEW_LINE INDENT return 1 + lcsOf3 ( i - 1 , j - 1 , k - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return dp [ i ] [ j ] [ k ] = max ( lcsOf3 ( i - 1 , j , k ) , lcsOf3 ( i , j - 1 , k ) ) , lcsOf3 ( i , j , k - 1 ) ) NEW_LINE DEDENT DEDENT
def findLarger ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE for i in range ( 0 , int ( n / 2 ) ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def spiralDiaSum ( n ) : NEW_LINE INDENT if ( n == 1 ) : return 1 NEW_LINE return ( 4 * n * n - 6 * n + 6 + spiralDiaSum ( n - 2 ) ) NEW_LINE DEDENT
def countOccurrences ( arr , n , x ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( x == arr [ i ] ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def sumBetweenTwoKth ( arr , k1 , k2 ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE result = 0 NEW_LINE for i in range ( k1 , k2 - 1 ) : NEW_LINE INDENT result += arr [ i ] NEW_LINE DEDENT return result NEW_LINE DEDENT
def calculate ( a , n ) : NEW_LINE INDENT maximum = max ( a ) NEW_LINE frequency = [ 0 for x in range ( n ) ] NEW_LINE for i in range ( 0 , maximum + 1 ) : NEW_LINE INDENT frequency [ a [ i ] ] += 1 NEW_LINE DEDENT answer = 0 NEW_LINE for i in range ( 0 , ( maximum ) + 1 ) : NEW_LINE INDENT answer = answer + frequency [ i ] * ( frequency [ i ] - 1 ) NEW_LINE DEDENT return answer // 2 NEW_LINE DEDENT
def doublefactorial ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( n - 2 ) : NEW_LINE INDENT if ( i == 0 or i == 1 ) : NEW_LINE INDENT return res NEW_LINE DEDENT else : NEW_LINE INDENT res = res * i NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def lcs ( X , Y , m , n ) : NEW_LINE INDENT if ( m == 0 or n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( X [ m - 1 ] == Y [ n - 1 ] ) : NEW_LINE INDENT return 1 + lcs ( X , Y , m - 1 , n - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return max ( lcs ( X , Y , m , n - 1 ) , lcs ( X , Y , m - 1 , n ) ) NEW_LINE DEDENT DEDENT
def maxProductSubset ( a , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return a [ 0 ] NEW_LINE DEDENT max_neg = - float ( ' inf ' ) NEW_LINE count_neg = 0 NEW_LINE count_zero = 0 NEW_LINE prod = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == 0 ) : NEW_LINE INDENT count_zero += 1 NEW_LINE continue NEW_LINE DEDENT if ( a [ i ] < 0 ) : NEW_LINE INDENT count_neg += 1 NEW_LINE max_neg = max ( max_neg , a [ i ] ) NEW_LINE DEDENT prod = prod * a [ i ] NEW_LINE DEDENT if ( count_zero == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( count_neg % 2 == 1 ) : NEW_LINE INDENT if ( count_neg == 1 and count_zero > 0 and count_zero + count_neg == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT prod = prod / max_neg NEW_LINE DEDENT return prod NEW_LINE DEDENT
def offeringNumber ( n , templeHeight ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT left = 0 NEW_LINE right = 0 NEW_LINE for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( templeHeight [ j ] < templeHeight [ j + 1 ] ) : NEW_LINE INDENT left += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( templeHeight [ j ] < templeHeight [ j - 1 ] ) : NEW_LINE INDENT right += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT sum += max ( right , left ) + 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT
def sumNodes ( l ) : NEW_LINE INDENT leafNodeCount = ( int ) ( math . pow ( 2 , l - 1 ) ) NEW_LINE vec = [ [ 0 for x in range ( leafNodeCount ) ] for y in range ( l + 1 ) ] NEW_LINE for i in range ( 1 , l + 1 ) : NEW_LINE INDENT vec . append ( [ 0 for x in range ( leafNodeCount ) ] NEW_LINE DEDENT for i in range ( 1 , leafNodeCount + 1 ) : NEW_LINE INDENT vec [ l - 1 ] . append ( i ) NEW_LINE DEDENT for i in range ( l - 2 , - 1 , - 1 ) : NEW_LINE INDENT k = 0 NEW_LINE while ( k < len ( vec [ i + 1 ] ) - 1 ) : NEW_LINE INDENT vec [ i ] [ k ] += vec [ i + 1 ] [ k + 1 ] NEW_LINE k += 2 NEW_LINE DEDENT DEDENT sum = 0 NEW_LINE for i in range ( l ) : NEW_LINE INDENT for j in range ( 0 , len ( vec [ i ] ) ) : NEW_LINE INDENT sum += vec [ i ] [ j ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def constructPalin ( str , len ) : NEW_LINE INDENT i , j = 0 , len - 1 NEW_LINE while i < j : NEW_LINE INDENT if ( str [ i ] == str [ j ] and str [ i ] != ' * ' ) : NEW_LINE INDENT continue NEW_LINE DEDENT elif ( str [ i ] == str [ j ] and str [ i ] == ' * ' ) : NEW_LINE INDENT str [ i ] = ' a ' NEW_LINE str [ j ] = ' a ' NEW_LINE continue NEW_LINE DEDENT elif ( str [ i ] == str [ j ] and str [ i ] == ' * ' ) : NEW_LINE INDENT str [ i ] = ' a ' NEW_LINE str [ j ] = ' a ' NEW_LINE continue NEW_LINE DEDENT elif ( str [ i ] == ' * ' ) : NEW_LINE INDENT str [ i ] = str [ j ] NEW_LINE continue NEW_LINE DEDENT elif ( str [ j ] == ' * ' ) : NEW_LINE INDENT str [ j ] = str [ i ] NEW_LINE continue NEW_LINE DEDENT elif ( str [ i ] == ' * ' ) : NEW_LINE INDENT str [ i ] = str [ i ] NEW_LINE continue NEW_LINE DEDENT elif ( str [ j ] == ' * ' ) : NEW_LINE INDENT str [ j ] = str [ i ] NEW_LINE continue NEW_LINE DEDENT DEDENT print ( " Not ▁ Possible " ) NEW_LINE return " " NEW_LINE DEDENT DEDENT
def countPairs ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in arr : NEW_LINE INDENT for j in arr : NEW_LINE INDENT if i == j : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def russianPeasant ( a , b ) : NEW_LINE INDENT res = 0 NEW_LINE while ( b > 0 ) : NEW_LINE INDENT if ( ( b & 1 ) != 0 ) : NEW_LINE INDENT res = res + a NEW_LINE DEDENT a = a << 1 NEW_LINE b = b > > 1 NEW_LINE DEDENT return res NEW_LINE DEDENT
def encrypt ( text , s ) : NEW_LINE INDENT result = [ ] NEW_LINE for i in range ( len ( text ) ) : NEW_LINE INDENT if ( isUpperCase ( text [ i ] ) ) : NEW_LINE INDENT ch = ( char ) ( ( ( int ) text [ i ] + s - 65 ) % 26 + 65 ) NEW_LINE result . append ( ch ) NEW_LINE DEDENT else : NEW_LINE INDENT ch = ( char ) ( ( ( int ) text [ i ] + s - 97 ) % 26 + 97 ) NEW_LINE result . append ( ch ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def distance ( lat1 , lat2 , lon1 , lon2 ) : NEW_LINE INDENT lon1 = toRadians ( lon1 ) NEW_LINE lon2 = toRadians ( lon2 ) NEW_LINE lat1 = toRadians ( lat1 ) NEW_LINE lat2 = toRadians ( lat2 ) NEW_LINE dlon = lon2 - lon1 NEW_LINE dlat = lat2 - lat1 NEW_LINE a = ( pow ( sin ( dlat / 2 ) , 2 ) + math . cos ( lat2 ) * math . pow ( math . sin ( dlon / 2 ) , 2 ) ) NEW_LINE c = 2 * math . asin ( math . sqrt ( a ) ) NEW_LINE r = 6371 NEW_LINE return ( c * r ) NEW_LINE DEDENT
def evenFib ( n ) : NEW_LINE INDENT if n < 1 : NEW_LINE INDENT return n NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT return 2 NEW_LINE DEDENT return ( ( 4 * evenFib ( n - 1 ) ) + evenFib ( n - 2 ) ) NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT return b NEW_LINE DEDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT k = 0 NEW_LINE while ( ( a | b ) & 1 ) == 0 : NEW_LINE INDENT a >>= 1 NEW_LINE b >>= 1 NEW_LINE DEDENT while ( ( a & 1 ) == 0 ) : NEW_LINE INDENT a >>= 1 NEW_LINE DEDENT while ( ( b & 1 ) == 0 ) : NEW_LINE INDENT b >>= 1 NEW_LINE DEDENT while ( a > b ) : NEW_LINE INDENT a = b NEW_LINE b = a - b NEW_LINE DEDENT b = ( b - a ) NEW_LINE DEDENT return a << k NEW_LINE DEDENT
def isPowerOfTwo ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT while n != 1 : NEW_LINE INDENT if n % 2 != 0 : NEW_LINE INDENT return False NEW_LINE DEDENT n = n // 2 NEW_LINE DEDENT return True NEW_LINE DEDENT
def findSum ( N ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( i , N + 1 ) : NEW_LINE INDENT sum = sum + i * j NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def binomialCoeffSum ( n ) : NEW_LINE INDENT return ( 1 << n ) + 1 NEW_LINE DEDENT
def calculateSum ( arr , n ) : NEW_LINE INDENT if ( n == 0 ) : return 0 NEW_LINE s = arr [ 0 ] NEW_LINE value = int ( arr [ 0 ] ) NEW_LINE sum = value NEW_LINE i = 2 NEW_LINE while ( i < n ) : NEW_LINE INDENT s = arr [ i ] NEW_LINE value = int ( arr [ i ] ) NEW_LINE operation = arr [ i - 1 ] [ 0 ] NEW_LINE if ( operation == ' + ' ) : NEW_LINE INDENT sum += value NEW_LINE DEDENT else : NEW_LINE INDENT sum -= value NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def checkPoint ( radius , x , y , percent , startAngle ) : NEW_LINE INDENT endAngle = 360 / percent + startAngle NEW_LINE polarradius = math . sqrt ( x * x + y * y ) NEW_LINE Angle = math . atan ( y / x ) NEW_LINE if ( Angle >= startAngle and Angle <= endAngle and polarradius < radius ) : NEW_LINE INDENT print ( " Point " , " ( " , x , " , " , y ) " , " ▁ exist ▁ in ▁ the ▁ circle ▁ sector " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Point " , " ( " , x , " , " , y ) " , " ▁ exist ▁ in ▁ the ▁ circle ▁ sector " ) NEW_LINE DEDENT DEDENT
def printknapSack ( W , wt , val , n ) : NEW_LINE INDENT K = [ [ 0 for i in range ( W + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for w in range ( W + 1 ) : NEW_LINE INDENT if ( i == 0 or w == 0 ) : NEW_LINE INDENT K [ i ] [ w ] = 0 NEW_LINE DEDENT elif ( wt [ i - 1 ] <= w ) : NEW_LINE INDENT K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) NEW_LINE DEDENT else : NEW_LINE INDENT K [ i ] [ w ] = K [ i - 1 ] [ w ] NEW_LINE DEDENT DEDENT DEDENT res = K [ n ] [ W ] NEW_LINE w = W NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT if ( res == K [ i - 1 ] [ w ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT print ( wt [ i - 1 ] , end = " ▁ " ) NEW_LINE res = res - val [ i - 1 ] NEW_LINE w = w - wt [ i - 1 ] NEW_LINE DEDENT DEDENT DEDENT
def getTotalNumberOfSequences ( m , n ) : NEW_LINE INDENT T = [ [ 0 for i in range ( n + 1 ) ] for j in range ( m + 1 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if ( i == 0 or j == 0 ) : NEW_LINE INDENT T [ i ] [ j ] = 0 NEW_LINE DEDENT elif ( i < j ) : NEW_LINE INDENT T [ i ] [ j ] = 0 NEW_LINE DEDENT elif ( j == 1 ) : NEW_LINE INDENT T [ i ] [ j ] = i NEW_LINE DEDENT else : NEW_LINE INDENT T [ i ] [ j ] = T [ i - 1 ] [ j ] + T [ i // 2 ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT return T [ m ] [ n ] NEW_LINE DEDENT
def findSum ( n ) : NEW_LINE INDENT arr = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT arr [ i ] [ j ] = abs ( i - j ) NEW_LINE DEDENT DEDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT sum += arr [ i ] [ j ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def replace ( s , c1 , c2 ) : NEW_LINE INDENT l = len ( s ) NEW_LINE arr = [ 0 ] * ( l + 1 ) NEW_LINE for i in range ( 0 , l ) : NEW_LINE INDENT if arr [ i ] == c1 : NEW_LINE INDENT arr [ i ] = c2 NEW_LINE DEDENT elif arr [ i ] == c2 : NEW_LINE INDENT arr [ i ] = c1 NEW_LINE DEDENT DEDENT return string ( arr ) NEW_LINE DEDENT
def discreteLogarithm ( a , b , m ) : NEW_LINE INDENT n = ( int ) ( math . sqrt ( m ) + 1 ) NEW_LINE an = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT an = ( an * a ) % m NEW_LINE DEDENT value = [ 0 ] * ( m + 1 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( value [ cur ] == 0 ) : NEW_LINE INDENT value [ cur ] = i NEW_LINE DEDENT cur = ( cur * an ) % m NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( value [ cur ] > 0 ) : NEW_LINE INDENT ans = value [ cur ] * n - i NEW_LINE if ( ans < m ) : NEW_LINE INDENT return ans NEW_LINE DEDENT cur = ( cur * a ) % m NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def maxPrimeFactors ( n ) : NEW_LINE INDENT maxPrime = - 1 NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT maxPrime = 2 NEW_LINE n >>= 1 NEW_LINE DEDENT for i in range ( 3 , int ( m . sqrt ( n ) + 2 ) ) : NEW_LINE INDENT while ( n % i == 0 ) : NEW_LINE INDENT maxPrime = i NEW_LINE n = n / i NEW_LINE DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT maxPrime = n NEW_LINE DEDENT return maxPrime NEW_LINE DEDENT
def isPossibleTriangle ( arr , N ) : NEW_LINE INDENT if N < 3 : NEW_LINE INDENT return False NEW_LINE DEDENT arr . sort ( ) NEW_LINE for i in range ( 0 , N - 2 ) : NEW_LINE INDENT if arr [ i ] + arr [ i + 1 ] > arr [ i + 2 ] : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def numOfIncSubseqOfSizeK ( arr , n , k ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( k ) ] for j in range ( n ) ] NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp [ 0 ] [ i ] = 1 NEW_LINE DEDENT for l in range ( 1 , k ) : NEW_LINE INDENT for i in range ( l , n ) : NEW_LINE INDENT dp [ l ] [ i ] = 0 NEW_LINE for j in range ( l - 1 , i ) : NEW_LINE INDENT if arr [ j ] < arr [ i ] : NEW_LINE INDENT dp [ l ] [ i ] += dp [ l - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT for i in range ( k - 1 , n ) : NEW_LINE INDENT sum += dp [ k - 1 ] [ i ] NEW_LINE DEDENT return sum NEW_LINE DEDENT
def solve ( X , Y , l , r , k , dp ) : NEW_LINE INDENT if ( k == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( l < 0 | r < 0 ) : NEW_LINE INDENT return ( int ) 1e9 NEW_LINE DEDENT if ( dp [ l ] [ r ] [ k ] != - 1 ) : NEW_LINE INDENT return dp [ l ] [ r ] [ k ] NEW_LINE DEDENT cost = ( X [ l ] - ord ( ' a ' ) ^ ( Y [ r ] - ord ( ' a ' ) ) NEW_LINE return dp [ l ] [ r ] [ k ] NEW_LINE DEDENT
def remainderWith7 ( num ) : NEW_LINE INDENT series = [ 1 , 3 , 2 , - 1 , - 3 , - 2 ] NEW_LINE series_index = 0 NEW_LINE result = 0 NEW_LINE for i in range ( len ( num ) - 1 ) : NEW_LINE INDENT digit = ord ( num [ i ] ) - ord ( '0' ) NEW_LINE result += digit * series [ series_index ] NEW_LINE series_index = ( series_index + 1 ) % 6 NEW_LINE result %= 7 NEW_LINE DEDENT if result < 0 : NEW_LINE INDENT result = ( result + 7 ) % 7 NEW_LINE DEDENT return result NEW_LINE DEDENT
def isSubSequence ( str1 , str2 , m , n ) : NEW_LINE INDENT if m == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT if n == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT if ( str1 [ m - 1 ] == str2 [ n - 1 ] ) : NEW_LINE INDENT return isSubSequence ( str1 , str2 , m - 1 , n - 1 ) NEW_LINE DEDENT return isSubSequence ( str1 , str2 , m , n - 1 ) NEW_LINE DEDENT
def getRemainder ( num , divisor ) : NEW_LINE INDENT return ( num - divisor * ( num / divisor ) ) NEW_LINE DEDENT
def minProductSubset ( a , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return a [ 0 ] NEW_LINE DEDENT negmax = - float ( ' inf ' ) NEW_LINE posmin = - float ( ' inf ' ) NEW_LINE count_neg = 0 NEW_LINE count_zero = 0 NEW_LINE product = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == 0 ) : NEW_LINE INDENT count_zero += 1 NEW_LINE continue NEW_LINE DEDENT if ( a [ i ] < 0 ) : NEW_LINE INDENT count_neg += 1 NEW_LINE negmax = max ( negmax , a [ i ] ) NEW_LINE DEDENT if ( a [ i ] > 0 and a [ i ] < posmin ) : NEW_LINE INDENT posmin = a [ i ] NEW_LINE DEDENT product = product * a [ i ] NEW_LINE DEDENT if ( count_zero == n or ( count_neg == 0 and count_zero > 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( count_neg % 2 == 0 and count_neg != 0 ) : NEW_LINE INDENT product = product / negmax NEW_LINE DEDENT return product NEW_LINE DEDENT
def getSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT sum = sum + int ( n % 10 ) NEW_LINE n = int ( n / 10 ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
def findDigits ( n ) : NEW_LINE INDENT if ( n < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n <= 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT digits = 0 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT digits += math . log10 ( i ) NEW_LINE DEDENT return math . floor ( digits ) + 1 NEW_LINE DEDENT
def mergeTwoHalf ( A , n ) : NEW_LINE INDENT A . sort ( ) NEW_LINE DEDENT
def fill0X ( m , n ) : NEW_LINE INDENT k = 0 l = 0 NEW_LINE r = m NEW_LINE c = n NEW_LINE a = [ [ 0 for i in range ( n ) ] for j in range ( m ) ] NEW_LINE x = ' X ' NEW_LINE while ( k < m and l < n ) : NEW_LINE INDENT for i in range ( l , n ) : NEW_LINE INDENT a [ k ] [ i ] = x NEW_LINE k += 1 NEW_LINE DEDENT for i in range ( k , m ) : NEW_LINE INDENT a [ i ] [ n - 1 ] = x NEW_LINE n -= 1 NEW_LINE DEDENT if ( k < m ) : NEW_LINE INDENT for i in range ( n - 1 , l - 1 , - 1 ) : NEW_LINE INDENT a [ m - 1 ] [ i ] = x NEW_LINE m -= 1 NEW_LINE DEDENT if ( l < n ) : NEW_LINE INDENT for i in range ( m - 1 , k - 1 , - 1 ) : NEW_LINE INDENT a [ i ] [ l ] = x NEW_LINE l += 1 NEW_LINE DEDENT x = ( x == '0' ) ? ' X ' : '0' NEW_LINE DEDENT DEDENT for i in range ( r ) : NEW_LINE INDENT for j in range ( c ) : NEW_LINE INDENT print ( a [ i ] [ j ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT
def minPerimeter ( n ) : NEW_LINE INDENT l = math . sqrt ( n ) NEW_LINE sq = l * l NEW_LINE if ( sq == n ) : NEW_LINE INDENT return l * 4 NEW_LINE DEDENT else : NEW_LINE INDENT row = n / l NEW_LINE perimeter = 2 * ( l + row ) NEW_LINE if ( n % l != 0 ) : NEW_LINE INDENT perimeter += 2 NEW_LINE DEDENT return perimeter NEW_LINE DEDENT
def possibleOrNot ( a1 , a2 , b1 , b2 , c1 , c2 ) : NEW_LINE INDENT dis1 = ( long ) math . pow ( b1 - a1 , 2 ) + ( long ) math . pow ( b2 - a2 , 2 ) NEW_LINE dis2 = ( long ) math . pow ( c1 - b1 , 2 ) + ( long ) math . pow ( c2 - b2 , 2 ) NEW_LINE if ( dis1 != dis2 ) : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT elif ( b1 == ( ( a1 + c1 ) // 2.0 ) and b2 == ( ( a2 + c2 ) // 2.0 ) ) : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT DEDENT
def slope ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT return ( y2 - y1 ) / ( x2 - x1 ) NEW_LINE DEDENT
def countSquares ( a , b ) : NEW_LINE INDENT return ( math . floor ( math . sqrt ( b ) ) - math . ceil ( math . sqrt ( a ) ) + 1 ) NEW_LINE DEDENT
def countStrings ( n , k ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( k + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE dp [ 1 ] [ 0 ] [ 0 ] = 1 NEW_LINE dp [ 1 ] [ 0 ] [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT for j in range ( 0 , k + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] [ 0 ] = dp [ i - 1 ] [ j ] [ 0 ] + dp [ i - 1 ] [ j ] [ 1 ] NEW_LINE if j - 1 >= 0 : NEW_LINE INDENT dp [ i ] [ j ] [ 1 ] += dp [ i - 1 ] [ j - 1 ] [ 1 ] NEW_LINE DEDENT DEDENT DEDENT return dp [ n ] [ k ] [ 0 ] + dp [ n ] [ k ] [ 1 ] NEW_LINE DEDENT
def findSmallestRange ( arr , n , k ) : NEW_LINE INDENT ptr = [ 0 ] * k NEW_LINE minrange = 10 ** 9 NEW_LINE while ( True ) : NEW_LINE INDENT minind = - 1 NEW_LINE minval = 10 ** 9 NEW_LINE maxval = 10 ** 9 NEW_LINE flag = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT if ( ptr [ i ] == n ) : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT if ( ptr [ i ] < n and arr [ i ] [ ptr [ i ] ] < minval ) : NEW_LINE INDENT minind = i NEW_LINE minval = arr [ i ] [ ptr [ i ] ] NEW_LINE DEDENT if ( ptr [ i ] < n and arr [ i ] [ ptr [ i ] ] > maxval ) : NEW_LINE INDENT maxval = arr [ i ] [ ptr [ i ] ] NEW_LINE DEDENT DEDENT if ( flag == 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT ptr [ minind ] += 1 NEW_LINE if ( ( maxval - minval ) < minrange ) : NEW_LINE INDENT minel = minval NEW_LINE maxel = maxval NEW_LINE minrange = maxel - minel NEW_LINE DEDENT DEDENT print ( " The ▁ smallest ▁ range ▁ is ▁ [ % d ▁ , ▁ % d ] " , minel , maxel ) NEW_LINE DEDENT
def lexicographicSubConcat ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE sub_count = int ( ( n + 1 ) / 2 ) NEW_LINE arr = [ " " ] * ( sub_count + 1 ) / 2 NEW_LINE index = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for len in range ( 1 , n - i + 1 ) : NEW_LINE INDENT arr [ index ] = s [ i : i + len ] NEW_LINE DEDENT DEDENT arr . sort ( ) NEW_LINE res = " " NEW_LINE for i in range ( 0 , sub_count ) : NEW_LINE INDENT res = res + arr [ i ] NEW_LINE DEDENT return res NEW_LINE DEDENT
def maxelement ( no_of_rows , arr ) : NEW_LINE INDENT i = 0 NEW_LINE max = 0 NEW_LINE result = [ 0 ] * no_of_rows NEW_LINE while i < no_of_rows : NEW_LINE INDENT for j in range ( 0 , len ( arr [ i ] ) ) : NEW_LINE INDENT if ( arr [ i ] [ j ] > max ) : NEW_LINE INDENT max = arr [ i ] [ j ] NEW_LINE DEDENT DEDENT result [ i ] = max NEW_LINE max = 0 NEW_LINE i += 1 NEW_LINE DEDENT printArray ( result ) NEW_LINE DEDENT
def countNegative ( M , n , m ) : NEW_LINE INDENT count = 0 NEW_LINE i = 0 NEW_LINE j = m - 1 NEW_LINE while ( j >= 0 and i < n ) : NEW_LINE INDENT if ( M [ i ] [ j ] < 0 ) : NEW_LINE INDENT count += j + 1 NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def findpos ( n ) : NEW_LINE INDENT k = 0 NEW_LINE pos = 0 NEW_LINE i = 0 NEW_LINE while ( k != len ( n ) ) : NEW_LINE INDENT switch ( n [ i ] ) : NEW_LINE INDENT case '4' : NEW_LINE INDENT pos = pos * 2 + 1 NEW_LINE break NEW_LINE DEDENT case '7' : NEW_LINE INDENT pos = pos * 2 + 2 NEW_LINE break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return pos NEW_LINE DEDENT
def yMod ( y , x ) : NEW_LINE INDENT if ( ( math . log ( y ) / math . log ( 2 ) ) < x ) : NEW_LINE INDENT return y NEW_LINE DEDENT if ( x > 63 ) : NEW_LINE INDENT return y NEW_LINE DEDENT return ( y % ( 1 << ( int ) x ) ) NEW_LINE DEDENT
def maxSumIS ( arr , n ) : NEW_LINE INDENT msis = [ 0 ] * n NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT msis [ i ] = arr [ i ] NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and msis [ i ] < msis [ j ] + arr [ i ] ) : NEW_LINE INDENT msis [ i ] = msis [ j ] + arr [ i ] NEW_LINE DEDENT DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( max < msis [ i ] ) : NEW_LINE INDENT max = msis [ i ] NEW_LINE DEDENT DEDENT return max NEW_LINE DEDENT
def maxLength ( s , n ) : NEW_LINE INDENT invalidOpenBraces = 0 NEW_LINE invalidCloseBraces = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == ' ( ' ) : NEW_LINE INDENT invalidOpenBraces += 1 NEW_LINE DEDENT elif ( invalidOpenBraces == 0 ) : NEW_LINE INDENT invalidCloseBraces += 1 NEW_LINE DEDENT else : NEW_LINE INDENT invalidOpenBraces -= 1 NEW_LINE DEDENT DEDENT DEDENT return ( n - ( invalidOpenBraces + invalidCloseBraces ) ) NEW_LINE DEDENT
def lis ( arr , n ) : NEW_LINE INDENT mpis = [ 0 ] * n NEW_LINE max = - float ( ' inf ' ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT mpis [ i ] = arr [ i ] NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and mpis [ i ] < ( mpis [ j ] * arr [ i ] ) ) : NEW_LINE INDENT mpis [ i ] = mpis [ j ] * arr [ i ] NEW_LINE DEDENT DEDENT for k in range ( len ( mpis ) ) : NEW_LINE INDENT if ( mpis [ k ] > max ) : NEW_LINE INDENT max = mpis [ k ] NEW_LINE DEDENT DEDENT DEDENT return max NEW_LINE DEDENT
def findthepath ( S , v ) : NEW_LINE INDENT result [ 0 ] = v + '0' NEW_LINE for i in range ( 1 , len ( S ) ) : NEW_LINE INDENT if ( adj [ v ] [ S [ i ] - ' A ' ] or adj [ S [ i ] - ' A ' ] [ v ] ) : NEW_LINE INDENT v = S [ i ] - ' A ' NEW_LINE DEDENT elif ( adj [ v ] [ S [ i ] - ' A ' + 5 ] or adj [ S [ i ] - ' A ' + 5 ] [ v ] ) : NEW_LINE INDENT v = S [ i ] - ' A ' + 5 NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT result [ i ] = v + '0' NEW_LINE DEDENT return True NEW_LINE DEDENT
def checkSorted ( q ) : NEW_LINE INDENT st = [ ] NEW_LINE expected = 1 NEW_LINE while ( len ( q ) != 0 ) : NEW_LINE INDENT fnt = q [ 0 ] NEW_LINE q . get ( ) NEW_LINE if ( fnt == expected ) : NEW_LINE INDENT expected += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( len ( st ) == 0 ) : NEW_LINE INDENT st . append ( fnt ) NEW_LINE DEDENT elif ( len ( st ) != 0 and st [ 0 ] < fnt ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT st . append ( fnt ) NEW_LINE DEDENT while len ( st ) != 0 and st [ - 1 ] == expected : NEW_LINE INDENT st . pop ( ) NEW_LINE expected += 1 NEW_LINE DEDENT DEDENT if ( expected - 1 == n and st . size ( ) == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def generate ( st , s ) : NEW_LINE INDENT if ( len ( s ) == 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( s not in st ) : NEW_LINE INDENT st . append ( s ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT t = s NEW_LINE t = t [ 0 : 0 + i ] + t [ i + 1 : ] NEW_LINE generate ( st , t ) NEW_LINE DEDENT DEDENT return NEW_LINE DEDENT
def tower ( n , sourcePole , destinationPole , auxiliaryPole ) : NEW_LINE INDENT if ( 0 == n ) : NEW_LINE INDENT return NEW_LINE DEDENT tower ( n - 1 , sourcePole , auxiliaryPole , destinationPole ) NEW_LINE print ( " Move ▁ the ▁ disk ▁ % d ▁ from ▁ % c ▁ to ▁ % c " , n , sourcePole , destinationPole ) NEW_LINE tower ( n - 1 , auxiliaryPole , destinationPole , sourcePole ) NEW_LINE DEDENT
def findMaximumPieces ( n ) : NEW_LINE INDENT return 1 + n * ( n + 1 ) / 2 NEW_LINE DEDENT
def minLexRotation ( string ) : NEW_LINE INDENT n = len ( string ) NEW_LINE arr = [ ' ' * ( n + 1 ) ] NEW_LINE concat = string + string NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr [ i ] = concat [ i : i + n ] NEW_LINE DEDENT arr . sort ( ) NEW_LINE return arr [ 0 ] NEW_LINE DEDENT
def findMinInsertions ( str , l , h ) : NEW_LINE INDENT if ( l > h ) : NEW_LINE INDENT return Integer . MAX_VALUE NEW_LINE DEDENT if ( l == h ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( l == h - 1 ) : NEW_LINE INDENT return ( str [ l ] == str [ h ] ) ? 0 : 1 NEW_LINE DEDENT return ( str [ l ] == str [ h ] ) ? findMinInsertions ( str , l + 1 , h - 1 ) : ( min ( findMinInsertions ( str , l , h - 1 ) , findMinInsertions ( str , l + 1 , h ) ) + 1 ) NEW_LINE DEDENT
def octalToDecimal ( n ) : NEW_LINE INDENT num = n NEW_LINE dec_value = 0 NEW_LINE base = 1 NEW_LINE temp = num NEW_LINE while ( temp ) : NEW_LINE INDENT last_digit = temp % 10 NEW_LINE temp = int ( temp / 10 ) NEW_LINE dec_value += last_digit * base NEW_LINE base = base * 8 NEW_LINE DEDENT return dec_value NEW_LINE DEDENT
def getMissingNo ( a , n ) : NEW_LINE INDENT total = ( n + 1 ) * ( n + 2 ) / 2 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT total -= ( a [ i ] * a [ i + 1 ] ) NEW_LINE DEDENT return total NEW_LINE DEDENT
def printSquares ( n ) : NEW_LINE INDENT square = 0 NEW_LINE prev_x = 0 NEW_LINE for x in range ( n ) : NEW_LINE INDENT square = ( square + x + prev_x ) NEW_LINE print ( square , end = " ▁ " ) NEW_LINE prev_x = x NEW_LINE DEDENT DEDENT
def isPossible ( a , b , n , k ) : NEW_LINE INDENT a . sort ( reverse = True ) NEW_LINE b . sort ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if a [ i ] + b [ i ] < k : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def fitOrNotFit ( R , r , x , y , rad ) : NEW_LINE INDENT val = ( math . sqrt ( x ** 2 ) + math . pow ( y ** 2 ) ) NEW_LINE if ( val + rad <= R and val - rad >= R - r ) : NEW_LINE INDENT print ( " Fits " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Doesn ' t ▁ Fit " ) NEW_LINE DEDENT DEDENT
def findPosition ( k , n ) : NEW_LINE INDENT f1 = 0 NEW_LINE f2 = 1 NEW_LINE f3 = f1 + f2 NEW_LINE i = 2 NEW_LINE while ( i != 0 ) : NEW_LINE INDENT f3 = f1 + f2 NEW_LINE f1 = f2 NEW_LINE f2 = f3 NEW_LINE if ( f2 % k == 0 ) : NEW_LINE INDENT return n * i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT
def sequence ( n ) : NEW_LINE INDENT f = [ 0 ] * ( n + 1 ) NEW_LINE f [ 0 ] = 0 NEW_LINE f [ 1 ] = 1 NEW_LINE f [ 2 ] = 1 NEW_LINE print ( f [ 1 ] , end = " ▁ " ) NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT f [ i ] = f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ] NEW_LINE print ( f [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def countManipulations ( s1 , s2 ) : NEW_LINE INDENT count = 0 NEW_LINE char_count = [ 0 ] * 26 NEW_LINE for i in range ( len ( s1 ) ) : NEW_LINE INDENT char_count [ ord ( s1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( len ( s2 ) ) : NEW_LINE INDENT if ( char_count [ ord ( s2 [ i ] ) - ord ( ' a ' ) ] -= 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def count ( n ) : NEW_LINE INDENT table = [ 0 for i in range ( n + 1 ) ] NEW_LINE table [ 0 ] = 1 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT table [ i ] = table [ i - 3 ] NEW_LINE DEDENT for i in range ( 5 , n + 1 ) : NEW_LINE INDENT table [ i ] += table [ i - 5 ] NEW_LINE DEDENT for i in range ( 10 , n + 1 ) : NEW_LINE INDENT table [ i ] += table [ i - 10 ] NEW_LINE DEDENT return table [ n ] NEW_LINE DEDENT
def maxSubsequenceSubstring ( x , y , n , m ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( m + 1 ) ] for j in range ( n + m ) ] NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( x [ j - 1 ] == y [ i - 1 ] ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT ans = max ( ans , dp [ i ] [ n ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def findLongestRepeatingSubSeq ( Str ) : NEW_LINE INDENT n = len ( Str ) NEW_LINE dp = [ [ 0 for x in range ( n + 1 ) ] for y in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( Str [ i - 1 ] == Str [ j - 1 ] and i != j ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ n ] [ n ] NEW_LINE DEDENT
def isCornerPresent ( str , corner ) : NEW_LINE INDENT n = len ( str ) NEW_LINE cl = len ( corner ) NEW_LINE if ( n < cl ) : NEW_LINE INDENT return False NEW_LINE DEDENT return ( str [ 0 : cl ] == corner and str [ n - cl : n ] . equals ( corner ) ) NEW_LINE DEDENT
def getMedian ( ar1 , ar2 , n ) : NEW_LINE INDENT i = 0 NEW_LINE j = 0 NEW_LINE count = 0 NEW_LINE while ( count <= n ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT m1 = m2 NEW_LINE m2 = ar2 [ 0 ] NEW_LINE break NEW_LINE DEDENT elif ( j == n ) : NEW_LINE INDENT m1 = m2 NEW_LINE m2 = ar1 [ 0 ] NEW_LINE break NEW_LINE DEDENT if ( ar1 [ i ] < ar2 [ j ] ) : NEW_LINE INDENT m1 = m2 NEW_LINE m2 = ar1 [ i ] NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT m1 = m2 NEW_LINE m2 = ar2 [ j ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT return ( m1 + m2 ) // 2 NEW_LINE DEDENT
def countZeroes ( mat ) : NEW_LINE INDENT N = len ( mat ) - 1 NEW_LINE col = 0 NEW_LINE count = 0 NEW_LINE while ( col < N ) : NEW_LINE INDENT while ( mat [ row ] [ col ] > 0 ) : NEW_LINE INDENT if ( -- row < 0 ) : NEW_LINE INDENT return count NEW_LINE DEDENT count += ( row + 1 ) NEW_LINE col += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def jumpSearch ( arr , x ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE step = ( int ) math . floor ( math . sqrt ( n ) ) NEW_LINE prev = 0 NEW_LINE while ( arr [ min ( step , n ) - 1 ] < x ) : NEW_LINE INDENT prev = step NEW_LINE step += ( int ) math . floor ( math . sqrt ( n ) ) NEW_LINE if ( prev >= n ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT while ( arr [ prev ] < x ) : NEW_LINE INDENT prev += 1 NEW_LINE if ( prev == min ( step , n ) ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT if ( arr [ prev ] == x ) : NEW_LINE INDENT return prev NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def solution ( a , b , n ) : NEW_LINE INDENT for i in range ( a , n + 1 ) : NEW_LINE INDENT if ( ( n - ( i * a ) ) % b == 0 ) : NEW_LINE INDENT print ( " x ▁ = ▁ " , i , " , ▁ y ▁ = ▁ " , ( n - ( i * a ) ) / b ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( " No ▁ solution " ) NEW_LINE DEDENT
def longDivision ( number , divisor ) : NEW_LINE INDENT ans = " " NEW_LINE idx = 0 NEW_LINE num = string . toCharArray ( ) NEW_LINE temp = num [ idx ] - '0' NEW_LINE while ( temp < divisor ) : NEW_LINE INDENT temp = temp * 10 + ( num [ idx ] - '0' ) NEW_LINE idx += 1 NEW_LINE while ( len ( num ) > idx ) : NEW_LINE INDENT ans += ( temp // divisor ) NEW_LINE temp = ( temp % divisor ) * 10 + num [ idx ] - '0' ) NEW_LINE DEDENT idx += 1 NEW_LINE while ( len ( num ) > idx ) : NEW_LINE INDENT ans = ans + ( temp // divisor ) NEW_LINE temp = ( temp % divisor ) * 10 + num [ idx ] - '0' NEW_LINE DEDENT if ( len ( ans ) == 0 ) : NEW_LINE INDENT return "0" NEW_LINE DEDENT return ans NEW_LINE DEDENT
def sort012 ( a , arr_size ) : NEW_LINE INDENT lo = 0 NEW_LINE hi = arr_size - 1 NEW_LINE mid = 0 NEW_LINE while ( mid <= hi ) : NEW_LINE INDENT switch ( a [ mid ] ) : NEW_LINE INDENT temp = a [ lo ] NEW_LINE a [ lo ] = a [ mid ] NEW_LINE a [ mid ] = temp NEW_LINE lo += 1 NEW_LINE mid += 1 NEW_LINE break NEW_LINE DEDENT case 0 : NEW_LINE INDENT temp = a [ lo ] NEW_LINE a [ lo ] = a [ mid ] NEW_LINE a [ mid ] = a [ hi ] NEW_LINE a [ hi ] = a [ hi ] NEW_LINE hi -= 1 NEW_LINE DEDENT DEDENT DEDENT
def canRepresentBST ( pre , n ) : NEW_LINE INDENT s = [ ] NEW_LINE root = - float ( ' inf ' ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( pre [ i ] < root ) : NEW_LINE INDENT return False NEW_LINE DEDENT while ( len ( s ) > 0 ) : NEW_LINE INDENT root = s [ - 1 ] NEW_LINE s . pop ( ) NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def find ( arr , i , j ) : NEW_LINE INDENT res = - 1 NEW_LINE while i < n and j >= 0 : NEW_LINE INDENT if arr [ i ] [ j ] == False : NEW_LINE INDENT while ( j >= 0 and arr [ i ] [ j ] == False or i == j ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT if ( j == - 1 ) : NEW_LINE INDENT res = i NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT if ( i == n ) : NEW_LINE INDENT res = j NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT DEDENT if ( res == - 1 ) : NEW_LINE INDENT return res NEW_LINE DEDENT for k in range ( n ) : NEW_LINE INDENT if ( res != k and arr [ k ] [ res ] != True ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT for l in range ( n ) : NEW_LINE INDENT if ( res != l and arr [ res ] [ l ] != False ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def printArray ( a , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT
def sortSquares ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE k = 0 NEW_LINE while k < n : NEW_LINE INDENT if arr [ k ] >= 0 : NEW_LINE INDENT break NEW_LINE DEDENT i = k - 1 NEW_LINE j = k NEW_LINE ind = 0 NEW_LINE temp = [ 0 ] * n NEW_LINE while i >= 0 and j < n : NEW_LINE INDENT if arr [ i ] * arr [ i ] < arr [ j ] * arr [ j ] : NEW_LINE INDENT temp [ ind ] = arr [ i ] * arr [ i ] NEW_LINE i -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT temp [ ind ] = arr [ j ] * arr [ j ] NEW_LINE j += 1 NEW_LINE DEDENT ind += 1 NEW_LINE DEDENT while i >= 0 : NEW_LINE INDENT temp [ ind ] = arr [ i ] * arr [ i ] NEW_LINE i -= 1 NEW_LINE DEDENT while j < n : NEW_LINE INDENT temp [ ind ] = arr [ j ] * arr [ j ] NEW_LINE j += 1 NEW_LINE DEDENT for x in range ( n ) : NEW_LINE INDENT arr [ x ] = arr [ x ] NEW_LINE DEDENT DEDENT
def find_maximum ( a , n , k ) : NEW_LINE INDENT b = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = a [ i ] NEW_LINE d = min ( 1 + i , n - i ) NEW_LINE if ( not b [ x ] ) : NEW_LINE INDENT b [ x ] = d NEW_LINE DEDENT else : NEW_LINE INDENT b [ x ] = min ( d , b [ x ] ) NEW_LINE DEDENT DEDENT ans = + 2147483647 NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = a [ i ] NEW_LINE if ( x != k - x and b [ k - x ] ) : NEW_LINE INDENT ans = min ( max ( b [ x ] , b [ k - x ] ) , ans ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def maxRepeating ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE count = 0 NEW_LINE res = str [ 0 ] NEW_LINE cur_count = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i < n - 1 and str [ i ] == str [ i + 1 ] ) : NEW_LINE INDENT cur_count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( cur_count > count ) : NEW_LINE INDENT count = cur_count NEW_LINE res = str [ i ] NEW_LINE DEDENT cur_count = 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def solveQuery ( start , end , arr ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( start , end + 1 ) : NEW_LINE INDENT mp [ arr [ i ] ] = mp [ arr [ i ] ] + 1 NEW_LINE DEDENT count = 0 NEW_LINE for entry in mp : NEW_LINE INDENT if entry . getKey ( ) == entry . getValue ( ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def Circumference ( a ) : NEW_LINE INDENT return 4 * a NEW_LINE DEDENT
def numberOfPaths ( m , n ) : NEW_LINE INDENT path = 1 NEW_LINE for i in range ( n , ( m + n - 1 ) ) : NEW_LINE INDENT path = path * i NEW_LINE path /= ( i - n + 1 ) NEW_LINE DEDENT return path NEW_LINE DEDENT
def pointClip ( XY , n , Xmin , Ymin , Xmax , Ymax ) : NEW_LINE INDENT print ( " Point ▁ inside ▁ the ▁ viewing ▁ pane : \n " ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( XY [ i ] [ 0 ] >= Xmin ) and ( XY [ i ] [ 0 ] <= Xmax ) ) : NEW_LINE INDENT if ( ( XY [ i ] [ 1 ] >= Ymin ) and ( XY [ i ] [ 1 ] <= Ymax ) ) : NEW_LINE INDENT print ( " [ % d , ▁ % d ] ▁ " , XY [ i ] [ 0 ] , XY [ i ] [ 1 ] ) NEW_LINE DEDENT DEDENT DEDENT print ( " \n Point ▁ outside ▁ the ▁ viewing ▁ pane : \n " ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( XY [ i ] [ 0 ] < Xmin ) or ( XY [ i ] [ 0 ] > Xmax ) ) : NEW_LINE INDENT print ( " [ % d , ▁ % d ] ▁ " , XY [ i ] [ 0 ] , XY [ i ] [ 1 ] ) NEW_LINE DEDENT DEDENT
def pre_compute ( a , n , index , k ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] > a [ 0 ] ) : NEW_LINE INDENT dp [ 0 ] [ i ] = a [ i ] + a [ 0 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ 0 ] [ i ] = a [ i ] NEW_LINE DEDENT DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( a [ j ] > a [ i ] and j > i ) : NEW_LINE INDENT if ( dp [ i - 1 ] [ i ] + a [ j ] > dp [ i - 1 ] [ j ] ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ i ] + a [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return dp [ index ] [ k ] NEW_LINE DEDENT
def splitArr ( arr , n , k ) : NEW_LINE INDENT for i in range ( k ) : NEW_LINE INDENT x = arr [ 0 ] NEW_LINE for j in range ( n - 1 ) : NEW_LINE INDENT arr [ j ] = arr [ j + 1 ] NEW_LINE DEDENT arr [ n - 1 ] = x NEW_LINE DEDENT DEDENT
def smallestSubWithSum ( arr , n , x ) : NEW_LINE INDENT curr_sum = 0 NEW_LINE min_len = n + 1 NEW_LINE start = 0 NEW_LINE end = 0 NEW_LINE while ( end < n ) : NEW_LINE INDENT while ( curr_sum <= x and end < n ) : NEW_LINE INDENT if ( curr_sum <= 0 and x > 0 ) : NEW_LINE INDENT start = end NEW_LINE curr_sum = 0 NEW_LINE DEDENT curr_sum += arr [ end ] NEW_LINE DEDENT while ( curr_sum > x and start < n ) : NEW_LINE INDENT if ( end - start < min_len ) : NEW_LINE INDENT min_len = end - start NEW_LINE DEDENT curr_sum -= arr [ start ] NEW_LINE DEDENT DEDENT return min_len NEW_LINE DEDENT
def winner ( a , n , k ) : NEW_LINE INDENT if ( k >= n - 1 ) : return n NEW_LINE DEDENT best = 0 NEW_LINE times = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] > best ) : NEW_LINE INDENT best = a [ i ] NEW_LINE if ( i == 1 ) : NEW_LINE INDENT times = 1 NEW_LINE DEDENT else : NEW_LINE INDENT times += 1 NEW_LINE DEDENT if ( times >= k ) : NEW_LINE INDENT return best NEW_LINE DEDENT DEDENT return best NEW_LINE DEDENT
def divisibleBy20 ( num ) : NEW_LINE INDENT lastTwoDigits = int ( num [ len ( num ) - 2 : ] ) NEW_LINE return ( ( lastTwoDigits % 5 == 0 ) and ( lastTwoDigits % 4 == 0 ) ) NEW_LINE DEDENT
def countSolutions ( n ) : NEW_LINE INDENT x = 0 NEW_LINE yCount = 0 NEW_LINE res = 0 NEW_LINE for yCount in range ( 0 , n ) : NEW_LINE INDENT while ( yCount != 0 ) : NEW_LINE INDENT res += yCount NEW_LINE x += 1 NEW_LINE while ( yCount != 0 and ( x * x + ( yCount - 1 ) * ( yCount - 1 ) >= n ) : NEW_LINE INDENT yCount -= 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def CountTriangles ( A ) : NEW_LINE INDENT n = len ( A ) NEW_LINE A . sort ( ) NEW_LINE count = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT l = 0 NEW_LINE r = i - 1 NEW_LINE while ( l < r ) : NEW_LINE INDENT if ( A [ l ] + A [ r ] > A [ i ] ) : NEW_LINE INDENT count += r - l NEW_LINE r -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT l += 1 NEW_LINE DEDENT DEDENT DEDENT print ( " No ▁ of ▁ possible ▁ solutions : ▁ " , count ) NEW_LINE DEDENT
def snoob ( x ) : NEW_LINE INDENT rightOne = x & - x NEW_LINE nextHigherOneBit = x + rightOne NEW_LINE rightOnesPattern = x ^ nextHigherOneBit NEW_LINE rightOnesPattern = x ^ nextHigherOneBit NEW_LINE rightOnesPattern = ( rightOnesPattern ) / rightOne NEW_LINE rightOnesPattern >>= 2 NEW_LINE next = nextHigherOneBit | rightOnesPattern NEW_LINE DEDENT return next NEW_LINE DEDENT
def isInorder ( arr , n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i - 1 ] > arr [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def lis ( arr , n ) : NEW_LINE INDENT max_ref = 1 NEW_LINE _lis ( arr , n ) NEW_LINE return max_ref NEW_LINE DEDENT
def maxProduct ( arr , n ) : NEW_LINE INDENT if ( n < 3 ) : return - 1 NEW_LINE DEDENT max_product = - float ( ' inf ' ) NEW_LINE for i in range ( 0 , n - 2 ) : NEW_LINE INDENT for j in range ( i + 1 , n - 1 ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT max_product = max ( max_product , arr [ i ] * arr [ j ] * arr [ k ] ) NEW_LINE DEDENT DEDENT return max_product NEW_LINE DEDENT
def countFreq ( a , n ) : NEW_LINE INDENT hm = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT hm [ a [ i ] ] = hm [ a [ i ] ] + 1 NEW_LINE DEDENT st = dict ( ) NEW_LINE for x in hm : NEW_LINE INDENT st [ x . getKey ( ) ] = x . getValue ( ) NEW_LINE DEDENT cumul = 0 NEW_LINE for x in st : NEW_LINE INDENT cumul += x . getValue ( ) NEW_LINE print ( x . getKey ( ) , " ▁ " , cumul ) NEW_LINE DEDENT DEDENT
def nCrModp ( n , r , p ) : NEW_LINE INDENT C = [ 0 for x in range ( r + 1 ) ] NEW_LINE C [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( min ( i , r ) ) : NEW_LINE INDENT C [ j ] = ( C [ j ] + C [ j - 1 ] ) % p NEW_LINE DEDENT DEDENT return C [ r ] NEW_LINE DEDENT
def cocktailSort ( a ) : NEW_LINE INDENT swapped = True NEW_LINE start = 0 NEW_LINE end = len ( a ) NEW_LINE while ( swapped == True ) : NEW_LINE INDENT swapped = False NEW_LINE for i in range ( start , end - 1 ) : NEW_LINE INDENT if ( a [ i ] > a [ i + 1 ] ) : NEW_LINE INDENT a [ i ] , a [ i + 1 ] = a [ i + 1 ] , a [ i ] NEW_LINE swapped = True NEW_LINE DEDENT DEDENT if ( swapped == False ) : NEW_LINE INDENT break NEW_LINE DEDENT swapped = False NEW_LINE end = end - 1 NEW_LINE for i in range ( end - 1 , start , - 1 ) : NEW_LINE INDENT if ( a [ i ] > a [ i + 1 ] ) : NEW_LINE INDENT a [ i ] , a [ i + 1 ] = a [ i + 1 ] , a [ i ] NEW_LINE swapped = True NEW_LINE DEDENT DEDENT start = start + 1 NEW_LINE DEDENT DEDENT
def solveWordWrap ( arr , n , k ) : NEW_LINE INDENT dp = [ 0 ] * n NEW_LINE ans = [ n - 1 ] * n NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT currlen = - 1 NEW_LINE dp [ i ] = sys . maxsize NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT currlen += ( arr [ j ] + 1 ) NEW_LINE if ( currlen > k ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( j == n - 1 ) : NEW_LINE INDENT cost = 0 NEW_LINE DEDENT else : NEW_LINE INDENT cost = ( k - currlen ) * ( k - currlen ) + dp [ j + 1 ] NEW_LINE if ( cost < dp [ i ] ) : NEW_LINE INDENT dp [ i ] = cost NEW_LINE ans [ i ] = j NEW_LINE DEDENT DEDENT DEDENT i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT print ( ( i + 1 ) , end = " ▁ " ) NEW_LINE i = ans [ i ] + 1 NEW_LINE DEDENT DEDENT
def binarySearch ( arr , x ) : NEW_LINE INDENT l = 0 NEW_LINE r = len ( arr ) - 1 NEW_LINE while ( l <= r ) : NEW_LINE INDENT m = l + ( r - l ) // 2 NEW_LINE if ( arr [ m ] == x ) : NEW_LINE INDENT return m NEW_LINE DEDENT if ( arr [ m ] < x ) : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT else : NEW_LINE INDENT r = m - 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def minXOR ( arr , n ) : NEW_LINE INDENT min_xor = + 2147483647 NEW_LINE for i in arr : NEW_LINE INDENT for j in arr : NEW_LINE INDENT min_xor = int ( min ( min_xor , arr [ i ] ^ arr [ j ] ) ) NEW_LINE DEDENT DEDENT return min_xor NEW_LINE DEDENT
def sumofFactors ( n ) : NEW_LINE INDENT if ( n % 2 != 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT res = 1 NEW_LINE for i in range ( 2 , int ( m . sqrt ( n ) + 1 ) ) : NEW_LINE INDENT count = 0 NEW_LINE curr_sum = 1 NEW_LINE curr_term = 1 NEW_LINE while ( n % i == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE n = n / i NEW_LINE if ( i == 2 and count == 1 ) : NEW_LINE INDENT curr_sum = 0 NEW_LINE curr_term = curr_term * i NEW_LINE curr_sum += curr_term NEW_LINE DEDENT res = res * curr_sum NEW_LINE DEDENT if ( n >= 2 ) : NEW_LINE INDENT res = res * ( 1 + n ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def first ( str , i ) : NEW_LINE INDENT if ( str [ i ] == ' \0' ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( str [ i ] == ' \0' ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( str [ i ] == ' \0' ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( len ( str ) > i + 1 ) : NEW_LINE INDENT return first ( str , i + 1 ) NEW_LINE DEDENT return first ( str , i + 1 ) NEW_LINE DEDENT
def maxGameByWinner ( N ) : NEW_LINE INDENT dp = [ 0 ] * N NEW_LINE dp [ 0 ] = 1 NEW_LINE dp [ 1 ] = 2 NEW_LINE i = 2 NEW_LINE while ( dp [ i ] <= N ) : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] NEW_LINE i += 1 NEW_LINE DEDENT return ( i - 2 ) NEW_LINE DEDENT
def equilibrium ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE leftsum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT sum -= arr [ i ] NEW_LINE if ( leftsum == sum ) : NEW_LINE INDENT return i NEW_LINE DEDENT leftsum += arr [ i ] NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def procal ( n ) : NEW_LINE INDENT return ( 3.0 * n ) / ( 4.0 * ( n * n ) - 1 ) NEW_LINE DEDENT
def rearrange ( arr , n ) : NEW_LINE INDENT temp = [ 0 ] * n NEW_LINE small = 0 NEW_LINE large = n - 1 NEW_LINE flag = True NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( flag ) : NEW_LINE INDENT temp [ i ] = arr [ large -= 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT temp [ i ] = arr [ small ] NEW_LINE DEDENT flag = not flag NEW_LINE DEDENT arr = arr . clone ( ) NEW_LINE DEDENT
def greatest ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE a = [ 0 ] * ( n + 1 ) NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT a [ i ] = ord ( s [ i ] ) - ord ( '0' ) NEW_LINE sum += a [ i ] NEW_LINE DEDENT if a [ n - 1 ] % 2 != 0 : NEW_LINE INDENT if ( sum - a [ n - 1 ] ) % 3 != 0 ) : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT re = sum % 3 NEW_LINE del = - 1 NEW_LINE flag = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( a [ i ] ) % 3 == re ) : NEW_LINE INDENT if ( a [ i + 1 ] > a [ i ] ) : NEW_LINE INDENT del = i NEW_LINE flag = 1 NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT del = i NEW_LINE DEDENT DEDENT if ( flag == 0 ) : NEW_LINE INDENT if ( a [ n - 2 ] % 2 == 0 and re == a [ n - 1 ] % 3 ) : NEW_LINE INDENT del = n - 1 NEW_LINE DEDENT DEDENT if ( del == - 1 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( del + 1 ) NEW_LINE DEDENT DEDENT
def isChangeable ( notes , n ) : NEW_LINE INDENT fiveCount = 0 NEW_LINE tenCount = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( notes [ i ] == 5 ) : NEW_LINE INDENT fiveCount += 1 NEW_LINE DEDENT elif ( notes [ i ] == 10 ) : NEW_LINE INDENT if ( fiveCount > 0 ) : NEW_LINE INDENT fiveCount -= 1 NEW_LINE tenCount += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( fiveCount > 0 and tenCount > 0 ) : NEW_LINE INDENT fiveCount -= 1 NEW_LINE tenCount -= 1 NEW_LINE DEDENT elif ( fiveCount >= 3 ) : NEW_LINE INDENT fiveCount -= 3 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT DEDENT return 1 NEW_LINE DEDENT
def LCSubStr ( X , Y , m , n ) : NEW_LINE INDENT LCStuff = [ [ 0 for i in range ( n + 1 ) ] for j in range ( m + 1 ) ] NEW_LINE result = 0 NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if ( i == 0 or j == 0 ) : NEW_LINE INDENT LCStuff [ i ] [ j ] = 0 NEW_LINE DEDENT elif ( X [ i - 1 ] == Y [ j - 1 ] ) : NEW_LINE INDENT LCStuff [ i ] [ j ] = LCStuff [ i - 1 ] [ j - 1 ] + 1 NEW_LINE result = max ( result , LCStuff [ i ] [ j ] ) NEW_LINE DEDENT else : NEW_LINE INDENT LCStuff [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
def maxSumWO3Consec ( n ) : NEW_LINE INDENT if sum [ n ] != - 1 : NEW_LINE INDENT return sum [ n ] NEW_LINE DEDENT if n == 0 : NEW_LINE INDENT return sum [ n ] = 0 NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT return sum [ n ] = arr [ 0 ] NEW_LINE if n == 2 : NEW_LINE INDENT return sum [ n ] = arr [ 1 ] + arr [ 0 ] NEW_LINE DEDENT return sum [ n ] = max ( maxSumWO3Consec ( n - 1 ) , maxSumWO3Consec ( n - 2 ) + arr [ n - 1 ] ) , arr [ n - 2 ] + arr [ n - 1 ] + maxSumWO3Consec ( n - 3 ) ) NEW_LINE DEDENT
def findMinZero ( p ) : NEW_LINE INDENT first = 1 NEW_LINE second = 1 NEW_LINE number = 2 NEW_LINE next = 1 NEW_LINE while ( next > 0 ) : NEW_LINE INDENT next = ( first + second ) % p NEW_LINE first = second NEW_LINE second = next NEW_LINE number += 1 NEW_LINE DEDENT return number NEW_LINE DEDENT
def reorder ( arr , index , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT while ( index [ i ] != i ) : NEW_LINE INDENT oldTargetI = index [ index [ i ] ] NEW_LINE oldTargetE = arr [ index [ i ] ] NEW_LINE arr [ index [ i ] ] = arr [ i ] NEW_LINE index [ i ] ] = index [ i ] NEW_LINE index [ i ] = oldTargetI NEW_LINE arr [ i ] = oldTargetE NEW_LINE DEDENT DEDENT DEDENT
def longestNull ( str1 ) : NEW_LINE INDENT arr = [ ] NEW_LINE maxlen = 0 NEW_LINE for i in range ( len ( str1 ) ) : NEW_LINE INDENT arr . append ( str1 [ i ] , - 1 ) NEW_LINE DEDENT while len ( arr ) >= 3 and arr [ arr . size ( ) - 3 ] . first == '1' and arr [ len ( arr1 ) - 2 ] . first == '0' and arr1 [ len ( arr1 ) - 1 ] . first == '0' and arr1 [ len ( arr1 ) - 1 ] . first == '0' : NEW_LINE INDENT arr . remove ( arr . size ( ) - 3 ) NEW_LINE arr . remove ( arr . size ( ) - 2 ) NEW_LINE arr . remove ( arr . size ( ) - 1 ) NEW_LINE DEDENT tmp = arr [ len ( arr1 ) - 1 ] . second NEW_LINE maxlen = max ( maxlen , i - tmp ) NEW_LINE DEDENT return maxlen NEW_LINE DEDENT
def calculateSum ( n ) : NEW_LINE INDENT if ( n <= 0 ) : return 0 NEW_LINE DEDENT fibo = [ 0 for i in range ( n + 1 ) ] NEW_LINE fibo [ 0 ] = 0 NEW_LINE fibo [ 1 ] = 1 NEW_LINE sum = fibo [ 0 ] + fibo [ 1 ] NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] NEW_LINE sum += fibo [ i ] NEW_LINE DEDENT return sum NEW_LINE DEDENT
def shortestPath ( graph , u , v , k ) : NEW_LINE INDENT if ( k == 0 and u == v ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( k == 1 and graph [ u ] [ v ] != INF ) : NEW_LINE INDENT return graph [ u ] [ v ] NEW_LINE DEDENT if ( k <= 0 ) : NEW_LINE INDENT return INF NEW_LINE DEDENT res = INF NEW_LINE for i in range ( V ) : NEW_LINE INDENT if ( graph [ u ] [ i ] != INF and u != i and v != i ) : NEW_LINE INDENT rec_res = shortestPath ( graph , i , v , k - 1 ) NEW_LINE if ( rec_res != INF ) : NEW_LINE INDENT res = min ( res , graph [ u ] [ i ] + rec_res ) NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT
def sumofsquare ( n ) : NEW_LINE INDENT C = [ [ 0 for x in range ( n + 1 ) ] for y in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( min ( i , n + 1 ) ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT sum = 0 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT sum += ( C [ n ] [ i ] * C [ n ] [ i ] ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
def constructArr ( arr , pair , n ) : NEW_LINE INDENT arr [ 0 ] = ( pair [ 0 ] + pair [ 1 ] - pair [ n - 1 ] ) // 2 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT arr [ i ] = ( pair [ i - 1 ] - arr [ 0 ] ) NEW_LINE DEDENT DEDENT
def patternCount ( str ) : NEW_LINE INDENT last = str [ 0 ] NEW_LINE i = 1 NEW_LINE while i < len ( str ) : NEW_LINE INDENT if ( str [ i ] == '0' and last == '1' ) : NEW_LINE INDENT while ( str [ i ] == '0' ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT if ( str [ i ] == '1' ) : NEW_LINE INDENT counter += 1 NEW_LINE DEDENT DEDENT last = str [ i ] NEW_LINE i += 1 NEW_LINE DEDENT return counter NEW_LINE DEDENT
def findFrequency ( arr , n , left , right , element ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( left - 1 , right ) : NEW_LINE INDENT if ( arr [ i ] == element ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def parabola ( a , b , c ) : NEW_LINE INDENT print ( " Vertex : ▁ ( " , ( - b / ( 2 * a ) ) , " , ▁ " , ( ( 4 * a * c ) - ( b * b ) ) / ( 4 * a ) ) ) NEW_LINE print ( " Focus : ▁ ( " , ( - b / ( 2 * a ) ) , " , ▁ " , ( ( ( 4 * a * c ) - ( b * b ) + 1 ) / ( 4 * a ) ) , " ) " ) NEW_LINE print ( " Directrix : ▁ ( " , " ▁ y = " , ( int ) ( c - ( ( b * b ) + 1 ) * 4 * a ) ) NEW_LINE DEDENT print ( " Directrix : " , " ▁ y = " , ( int ) ( c - ( ( b * b ) + 1 ) * 4 * a ) ) NEW_LINE DEDENT
def minproduct ( a , b , n , k ) : NEW_LINE INDENT diff = 0 NEW_LINE res = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT pro = a [ i ] * b [ i ] NEW_LINE res = res + pro NEW_LINE if pro < 0 and b [ i ] < 0 : NEW_LINE INDENT temp = ( a [ i ] + 2 * k ) * b [ i ] NEW_LINE DEDENT elif pro < 0 and a [ i ] < 0 : NEW_LINE INDENT temp = ( a [ i ] - 2 * k ) * b [ i ] NEW_LINE DEDENT elif pro > 0 and a [ i ] > 0 : NEW_LINE INDENT temp = ( a [ i ] - 2 * k ) * b [ i ] NEW_LINE DEDENT elif pro > 0 and a [ i ] < 0 : NEW_LINE INDENT temp = ( a [ i ] + 2 * k ) * b [ i ] NEW_LINE DEDENT elif pro > 0 and a [ i ] > 0 : NEW_LINE INDENT temp = ( a [ i ] - 2 * k ) * b [ i ] NEW_LINE DEDENT DEDENT return res - diff NEW_LINE DEDENT
def longestSubseqWithK ( str , k ) : NEW_LINE INDENT n = len ( str ) NEW_LINE freq = [ 0 for i in range ( MAX_CHARS ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] >= k ) : NEW_LINE INDENT print ( str [ i ] , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def pairsInSortedRotated ( arr , n , x ) : NEW_LINE INDENT i = 0 NEW_LINE while i < n - 1 : NEW_LINE INDENT if arr [ i ] > arr [ i + 1 ] : NEW_LINE INDENT break NEW_LINE DEDENT l = i NEW_LINE r = i NEW_LINE cnt = 0 NEW_LINE while ( l != r ) : NEW_LINE INDENT if ( arr [ l ] + arr [ r ] == x ) : NEW_LINE INDENT cnt += 1 NEW_LINE if ( l == ( r - 1 + n ) % n ) : NEW_LINE INDENT return cnt NEW_LINE DEDENT l = ( l + 1 ) % n NEW_LINE r = ( r - 1 + n ) % n NEW_LINE DEDENT elif arr [ l ] + arr [ r ] < x : NEW_LINE INDENT l = ( l + 1 ) % n NEW_LINE DEDENT else : NEW_LINE INDENT r = ( n + r - 1 ) % n NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT
def middleOfThree ( a , b , c ) : NEW_LINE INDENT x = a - b NEW_LINE y = b - c NEW_LINE z = a - c NEW_LINE if ( x * y > 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT elif ( x * z > 0 ) : NEW_LINE INDENT return c NEW_LINE DEDENT else : NEW_LINE INDENT return a NEW_LINE DEDENT DEDENT
def nextPowerOf2 ( n ) : NEW_LINE INDENT count = 0 NEW_LINE if ( n > 0 and ( n & ( n - 1 ) ) == 0 ) : NEW_LINE INDENT return n NEW_LINE DEDENT while ( n != 0 ) : NEW_LINE INDENT n >>= 1 NEW_LINE count += 1 NEW_LINE DEDENT return 1 << count NEW_LINE DEDENT
def maxSubArraySumRepeated ( a , n , k ) : NEW_LINE INDENT max_so_far = 0 NEW_LINE INT_MIN = - float ( ' inf ' ) NEW_LINE max_ending_here = 0 NEW_LINE for i in range ( n * k ) : NEW_LINE INDENT max_ending_here = max_ending_here + a [ i % n ] NEW_LINE if ( max_so_far < max_ending_here ) : NEW_LINE INDENT max_so_far = max_ending_here NEW_LINE DEDENT if ( max_ending_here < 0 ) : NEW_LINE INDENT max_ending_here = 0 NEW_LINE DEDENT DEDENT return max_so_far NEW_LINE DEDENT
def reverse ( st ) : NEW_LINE INDENT n = len ( st ) NEW_LINE for i in range ( 0 , int ( n / 2 ) ) : NEW_LINE INDENT swap ( st , i , n - i - 1 ) NEW_LINE DEDENT DEDENT
def nextWord ( str ) : NEW_LINE INDENT if ( str == " " ) : NEW_LINE INDENT return " a " NEW_LINE DEDENT i = len ( str ) - 1 NEW_LINE while ( i == - 1 ) : NEW_LINE INDENT str = str + ' a ' NEW_LINE i = i - 1 NEW_LINE DEDENT if ( i == - 1 ) : NEW_LINE INDENT str = str [ 0 : i ] + chr ( ord ( str [ i ] ) + 1 ) + str [ i + 1 ] NEW_LINE DEDENT return str NEW_LINE DEDENT
def binomialCoeffSum ( n ) : NEW_LINE INDENT C = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( min ( i , n ) + 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT sum = 0 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT sum += C [ n ] [ i ] NEW_LINE DEDENT return sum NEW_LINE DEDENT
def isEven ( n ) : NEW_LINE INDENT return ( n % 2 == 0 ) NEW_LINE DEDENT
def binarySearch ( arr , low , high , key ) : NEW_LINE INDENT if ( high < low ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = low + ( high - low ) / 2 NEW_LINE if ( key == arr [ mid ] ) : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( key > arr [ mid ] ) : NEW_LINE INDENT return binarySearch ( arr , ( mid + 1 ) , high , key ) NEW_LINE DEDENT return binarySearch ( arr , low , ( mid - 1 ) , key ) NEW_LINE DEDENT
def maxMin ( arr , n ) : NEW_LINE INDENT min = + 2147483647 NEW_LINE max = - 2147483648 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , int ( n / 2 ) + 1 ) : NEW_LINE INDENT if arr [ i ] [ j ] > arr [ i ] [ n - j - 1 ] : NEW_LINE INDENT if min > arr [ i ] [ n - j - 1 ] : NEW_LINE INDENT min = arr [ i ] [ n - j - 1 ] NEW_LINE DEDENT if max < arr [ i ] [ j ] : NEW_LINE INDENT max = arr [ i ] [ j ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if min > arr [ i ] [ j ] : NEW_LINE INDENT min = arr [ i ] [ j ] NEW_LINE DEDENT if max < arr [ i ] [ n - j - 1 ] : NEW_LINE INDENT max = arr [ i ] [ n - j - 1 ] NEW_LINE DEDENT DEDENT DEDENT print ( " Maximum ▁ = ▁ " , max , " , ▁ Minimum ▁ = ▁ " , min ) NEW_LINE DEDENT
def isPowerOfTwo ( x ) : NEW_LINE INDENT return x != 0 and ( ( x & ( x - 1 ) ) == 0 ) NEW_LINE DEDENT
def countPaths ( n , m ) : NEW_LINE INDENT if ( n == 0 or m == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return ( countPaths ( n - 1 , m ) + countPaths ( n , m - 1 ) ) NEW_LINE DEDENT
def isRectangle ( matrix ) : NEW_LINE INDENT rows = len ( matrix ) NEW_LINE if ( rows == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT columns = len ( matrix [ 0 ] ) NEW_LINE table = dict ( ) NEW_LINE for i in range ( rows ) : NEW_LINE INDENT for j in range ( columns - 1 ) : NEW_LINE INDENT for k in range ( columns ) : NEW_LINE INDENT if ( matrix [ i ] [ j ] == 1 and matrix [ i ] [ k ] == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( table [ k ] and table [ k ] . contains ( j ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( table [ j ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( table [ k ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( table [ j ] ) : NEW_LINE INDENT x = set ( ) NEW_LINE x . append ( k ) NEW_LINE table [ j ] . add ( j ) NEW_LINE DEDENT table [ k ] . append ( j ) NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT
def decToBinary ( n ) : NEW_LINE INDENT binaryNum = [ 0 ] * 32 NEW_LINE i = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT binaryNum [ i ] = n % 2 NEW_LINE n = int ( n / 2 ) NEW_LINE i += 1 NEW_LINE DEDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( binaryNum [ j ] , end = " " ) NEW_LINE DEDENT DEDENT
def countFriendsPairings ( n ) : NEW_LINE INDENT if dp [ n ] != - 1 : NEW_LINE INDENT return dp [ n ] NEW_LINE DEDENT if n > 2 : NEW_LINE INDENT return dp [ n ] = ( countFriendsPairings ( n - 1 ) + ( n - 1 ) * countFriendsPairings ( n - 2 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return dp [ n ] = n NEW_LINE DEDENT DEDENT
def maximumSumSubarray ( arr , n ) : NEW_LINE INDENT min_prefix_sum = 0 NEW_LINE res = - float ( ' inf ' ) NEW_LINE prefix_sum = [ 0 for x in range ( n ) ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT prefix_sum [ i ] = prefix_sum [ i - 1 ] + arr [ i ] NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT res = max ( res , prefix_sum [ i ] - min_prefix_sum ) NEW_LINE min_prefix_sum = min ( min_prefix_sum , prefix_sum [ i ] ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def countOccurrences ( s , K ) : NEW_LINE INDENT n = len ( s ) NEW_LINE C = 0 NEW_LINE c1 = 0 NEW_LINE c2 = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( s [ i ] == ' a ' ) : NEW_LINE INDENT c1 += 1 NEW_LINE DEDENT if ( s [ i ] == ' b ' ) : NEW_LINE INDENT c2 += 1 NEW_LINE DEDENT C += c1 NEW_LINE DEDENT DEDENT return C * K + ( K * ( K - 1 ) // 2 ) * c1 * c2 NEW_LINE DEDENT
def checkDivisibility ( num ) : NEW_LINE INDENT length = len ( num ) NEW_LINE if ( length == 1 and num [ 0 ] == '0' ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( length % 3 == 1 ) : NEW_LINE INDENT num += "00" NEW_LINE length += 2 NEW_LINE DEDENT elif ( length % 3 == 2 ) : NEW_LINE INDENT num += "0" NEW_LINE length += 1 NEW_LINE DEDENT sum = 0 NEW_LINE p = 1 NEW_LINE for i in range ( length - 1 , - 1 , - 1 ) : NEW_LINE INDENT group = 0 NEW_LINE group += ord ( num [ i ] ) - ord ( '0' ) NEW_LINE group += ord ( num [ i ] ) - ord ( '0' ) * 10 NEW_LINE group += ord ( num [ i ] ) - ord ( '0' ) * 100 NEW_LINE sum = sum + group * p NEW_LINE p = math . abs ( sum ) NEW_LINE return ( sum % 13 == 0 ) NEW_LINE DEDENT
def countRect ( n ) : NEW_LINE INDENT ans = 0 NEW_LINE for length in range ( 1 , int ( n / 2 ) + 1 ) : NEW_LINE INDENT for height in range ( length , int ( n / 2 ) + 1 ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def countSetBits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT n &= ( n - 1 ) NEW_LINE count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def lenOfLongSubarr ( arr , n ) : NEW_LINE INDENT um = dict ( ) NEW_LINE sum = 0 NEW_LINE maxLen = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] == 0 ? - 1 : 1 NEW_LINE if ( Sum == 1 ) : NEW_LINE INDENT maxLen = i + 1 NEW_LINE DEDENT elif ( Sum in um ) : NEW_LINE INDENT um [ Sum ] = i NEW_LINE DEDENT if ( Sum in um . values ( ) ) : NEW_LINE INDENT maxLen = max ( maxLen , i - um [ Sum - 1 ] ) NEW_LINE DEDENT DEDENT return maxLen NEW_LINE DEDENT
def factorial ( n ) : NEW_LINE INDENT res = 1 NEW_LINE i = 2 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT res = res * i NEW_LINE DEDENT return res NEW_LINE DEDENT
def minJumps ( arr , l , h ) : NEW_LINE INDENT if ( h == l ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( arr [ l ] == 0 ) : NEW_LINE INDENT return Integer . MAX_VALUE NEW_LINE DEDENT min = 10 ** 9 NEW_LINE for i in range ( l + 1 , h + 1 ) : NEW_LINE INDENT jumps = minJumps ( arr , i , h ) NEW_LINE if ( jumps != 10 ** 9 and jumps + 1 < min ) : NEW_LINE INDENT min = jumps + 1 NEW_LINE DEDENT DEDENT return min NEW_LINE DEDENT
def minTimeForWritingChars ( N , insert , remove , copy ) : NEW_LINE INDENT if N == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if N == 1 : NEW_LINE INDENT return insert NEW_LINE DEDENT dp = [ 0 for i in range ( N + 1 ) ] NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT dp [ i ] = min ( dp [ i - 1 ] + insert , dp [ i // 2 ] + copy ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] = min ( dp [ i - 1 ] + insert , dp [ ( i + 1 ) // 2 ] + copy + remove ) NEW_LINE DEDENT DEDENT return dp [ N ] NEW_LINE DEDENT
def carveCross ( str1 ) : NEW_LINE INDENT n = len ( str1 ) NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT print ( " Not ▁ possible . ▁ Please ▁ enter ▁ " , " odd ▁ length ▁ string . \n " ) NEW_LINE DEDENT else : NEW_LINE INDENT arr = [ [ ' X ' for i in range ( n ) ] for j in range ( n ) ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] [ m ] = str1 [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ m ] [ i ] = str1 [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT print ( arr [ i ] [ j ] , end = " ▁ " ) NEW_LINE DEDENT print ( " \n " ) NEW_LINE DEDENT DEDENT
def sumoflength ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE j = 0 NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT while ( j < n and arr [ i ] not in s ) : NEW_LINE INDENT s . add ( arr [ i ] ) NEW_LINE j += 1 NEW_LINE DEDENT ans += ( ( j - i ) * ( j - i + 1 ) ) / 2 NEW_LINE DEDENT s . remove ( arr [ i ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def findTriplets ( arr , n ) : NEW_LINE INDENT found = 0 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT s = set ( ) NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT x = - ( arr [ i ] + arr [ j ] ) NEW_LINE if ( s . contains ( x ) ) : NEW_LINE INDENT print ( " % d ▁ % d ▁ % d \n " , x , arr [ i ] , arr [ j ] ) NEW_LINE found = True NEW_LINE DEDENT else : NEW_LINE INDENT s . add ( arr [ j ] ) NEW_LINE DEDENT DEDENT DEDENT if ( found == False ) : NEW_LINE INDENT print ( " ▁ No ▁ Triplet ▁ Found " ) NEW_LINE DEDENT DEDENT
def maxPrefix ( s , t ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( t ) ) : NEW_LINE INDENT if ( count == len ( t ) ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( t [ i ] == s [ count ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def segregateElements ( arr , n ) : NEW_LINE INDENT temp = [ 0 ] * n NEW_LINE j = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if arr [ i ] >= 0 : NEW_LINE INDENT temp [ j ] = arr [ i ] NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if j == n or j == 0 : NEW_LINE INDENT return NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if arr [ i ] < 0 : NEW_LINE INDENT temp [ j ] = arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT arr [ i ] = temp [ i ] NEW_LINE DEDENT DEDENT
def mergeIntervals ( arr , i1 , i2 ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE index = 0 NEW_LINE for i in range ( 1 , len ( arr ) ) : NEW_LINE INDENT if arr [ index ] . end >= arr [ i ] . start : NEW_LINE INDENT arr [ index ] . end = max ( arr [ index ] . end , arr [ i ] . end ) NEW_LINE arr [ index ] . start = min ( arr [ index ] . start , arr [ i ] . start ) NEW_LINE DEDENT else : NEW_LINE INDENT arr [ index ] = arr [ i ] NEW_LINE index += 1 NEW_LINE DEDENT DEDENT print ( " The ▁ Merged ▁ Intervals ▁ are : ▁ " ) NEW_LINE for i in range ( index + 1 ) : NEW_LINE INDENT print ( " [ " , arr [ i ] . start , arr [ i ] . end , end = " " ) NEW_LINE DEDENT DEDENT
def correlationCoefficient ( X , Y , n ) : NEW_LINE INDENT sum_X = 0 NEW_LINE sum_Y = 0 NEW_LINE sum_XY = 0 NEW_LINE squareSum_X = 0 NEW_LINE squareSum_Y = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT Sum_X = Sum_X + X [ i ] NEW_LINE Sum_Y = Sum_Y + Y [ i ] NEW_LINE sum_XY = sum_XY + X [ i ] * X [ i ] NEW_LINE squareSum_X = squareSum_X + X [ i ] * X [ i ] NEW_LINE squareSum_Y = squareSum_Y + Y [ i ] * Y [ i ] NEW_LINE DEDENT corr = ( float ) ( n * sum_XY - Sum_X * sum_Y ) / ( float ) ( math . sqrt ( ( n * squareSum_X - Sum_X * sum_X ) * ( n * squareSum_Y - Sum_Y * sum_Y ) ) ) NEW_LINE return corr NEW_LINE DEDENT
def findArea ( arr , n ) : NEW_LINE INDENT arr . sort ( reverse = True ) NEW_LINE dimension = [ 0 , 0 ] NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( arr [ i ] == arr [ i + 1 ] ) : NEW_LINE INDENT dimension [ j ] = arr [ i ] NEW_LINE i += 1 NEW_LINE DEDENT DEDENT return ( dimension [ 0 ] * dimension [ 1 ] ) NEW_LINE DEDENT
def minOps ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE max = arr [ len ( arr ) - 1 ] NEW_LINE res = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( ( max - arr [ i ] ) % k != 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT res += ( max - arr [ i ] ) / k NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def floorSqrt ( x ) : NEW_LINE INDENT if ( x == 0 or x == 1 ) : NEW_LINE INDENT return x NEW_LINE DEDENT i = 1 NEW_LINE result = 1 NEW_LINE while ( result <= x ) : NEW_LINE INDENT i += 1 NEW_LINE result = i * i NEW_LINE DEDENT return i - 1 NEW_LINE DEDENT
def isDivisible7 ( num ) : NEW_LINE INDENT n = len ( num ) NEW_LINE if ( n == 0 and num [ 0 ] == '0' ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 3 == 1 ) : NEW_LINE INDENT num = "00" + num NEW_LINE DEDENT if ( n % 3 == 2 ) : NEW_LINE INDENT num = "0" + num NEW_LINE DEDENT n = len ( num ) NEW_LINE gSum = 0 NEW_LINE p = 1 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT group = 0 NEW_LINE group += ord ( num [ i ] ) - ord ( '0' ) NEW_LINE group += ord ( num [ i ] ) - ord ( '0' ) * 10 NEW_LINE group += ord ( num [ i ] ) - ord ( '0' ) * 100 NEW_LINE gSum = gSum + group * p NEW_LINE p = p * - 1 NEW_LINE DEDENT return ( gSum % 7 == 0 ) NEW_LINE DEDENT
def printMat ( degseq , n ) : NEW_LINE INDENT mat = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( degseq [ i ] > 0 and degseq [ j ] > 0 ) : NEW_LINE INDENT degseq [ i ] -= 1 NEW_LINE degseq [ j ] -= 1 NEW_LINE mat [ i ] [ j ] = 1 NEW_LINE mat [ j ] [ i ] = 1 NEW_LINE DEDENT DEDENT DEDENT print ( " \n " , setw ( 3 ) , " ▁ ▁ ▁ " ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( setw ( 4 ) , " ( " , i ) " ) NEW_LINE for j in range ( n ) : NEW_LINE INDENT print ( setw ( 5 ) , mat [ i ] [ j ] ) NEW_LINE DEDENT print ( " \n " ) NEW_LINE DEDENT DEDENT
def minTime ( arr , n , m ) : NEW_LINE INDENT t = 0 NEW_LINE while ( True ) : NEW_LINE INDENT items = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT items += ( t // arr [ i ] ) NEW_LINE DEDENT if ( items >= m ) : NEW_LINE INDENT return t NEW_LINE DEDENT t += 1 NEW_LINE DEDENT DEDENT
def MaximumDecimalValue ( mat , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] NEW_LINE if ( mat [ 0 ] [ 0 ] == 1 ) : NEW_LINE INDENT dp [ 0 ] [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( mat [ 0 ] [ i ] == 1 ) : NEW_LINE INDENT dp [ 0 ] [ i ] = ( int ) ( dp [ 0 ] [ i - 1 ] + pow ( 2 , i ) ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] NEW_LINE DEDENT DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT if ( mat [ i ] [ j ] == 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = ( int ) ( max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) + pow ( 2 , i + j ) ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ n - 1 ] [ n - 1 ] NEW_LINE DEDENT
def isDivisible999 ( num ) : NEW_LINE INDENT n = len ( num ) NEW_LINE if ( n == 0 and num [ 0 ] == '0' ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 3 == 1 ) : NEW_LINE INDENT num = "00" + num NEW_LINE DEDENT if ( n % 3 == 2 ) : NEW_LINE INDENT num = "0" + num NEW_LINE DEDENT gSum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT group = 0 NEW_LINE group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 100 NEW_LINE group += ord ( num [ i ] ) - ord ( '0' ) NEW_LINE gSum += group NEW_LINE DEDENT if ( gSum > 1000 ) : NEW_LINE INDENT num = str ( gSum ) NEW_LINE n = len ( num ) NEW_LINE gSum = isDivisible999 ( num ) ? 1 : 0 NEW_LINE DEDENT return ( gSum == 999 ) NEW_LINE DEDENT
def maxSumBitonicSubArr ( arr , n ) : NEW_LINE INDENT msis = [ 0 ] * n NEW_LINE msds = [ 0 ] * n NEW_LINE max_sum = - float ( ' inf ' ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if arr [ i ] > arr [ i - 1 ] : NEW_LINE INDENT msis [ i ] = msis [ i - 1 ] + arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT msis [ i ] = arr [ i ] NEW_LINE DEDENT msds [ n - 1 ] = arr [ n - 1 ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if arr [ i ] > arr [ i + 1 ] : NEW_LINE INDENT msds [ i ] = msds [ i + 1 ] + arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT msds [ i ] = arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if max_sum < ( msis [ i ] + msds [ i ] - arr [ i ] ) : NEW_LINE INDENT max_sum = msis [ i ] + msds [ i ] - arr [ i ] NEW_LINE DEDENT DEDENT return max_sum NEW_LINE DEDENT
def findMinNumber ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE n /= 2 NEW_LINE DEDENT if ( count % 2 == 1 ) : NEW_LINE INDENT ans = 2 NEW_LINE DEDENT for i in range ( 3 , int ( m . sqrt ( n ) + 2 ) ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n % i == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE n /= i NEW_LINE DEDENT if ( count % 2 == 1 ) : NEW_LINE INDENT ans = ans * i NEW_LINE DEDENT if ( n > 2 ) : NEW_LINE INDENT ans = ans * n NEW_LINE DEDENT return ans NEW_LINE DEDENT
def rangeGCD ( n , m ) : NEW_LINE INDENT return ( n == m ) ? n : 1 NEW_LINE DEDENT
def assignValue ( a , b , x ) : NEW_LINE INDENT arr = [ 0 , 0 , 1 , 2 , 3 ] NEW_LINE return ( arr [ x ] ) NEW_LINE DEDENT
def isTriangular ( num ) : NEW_LINE INDENT if ( num < 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT sum = 0 NEW_LINE for n in range ( 1 , num + 1 ) : NEW_LINE INDENT sum = sum + n NEW_LINE if ( sum == num ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def checkPangram ( str ) : NEW_LINE INDENT mark = [ False ] * 26 NEW_LINE index = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( ' A ' <= str [ i ] and str [ i ] <= ' Z ' ) : NEW_LINE INDENT index = ord ( str [ i ] ) - ord ( ' A ' ) NEW_LINE DEDENT elif ( ' a ' <= str [ i ] and str [ i ] <= ' z ' ) : NEW_LINE INDENT index = ord ( str [ i ] ) - ord ( ' a ' ) NEW_LINE DEDENT mark [ index ] = True NEW_LINE DEDENT for i in range ( 0 , 26 ) : NEW_LINE INDENT if ( mark [ i ] == False ) : NEW_LINE INDENT return ( False ) NEW_LINE DEDENT DEDENT return ( True ) NEW_LINE DEDENT
def interpolationSearch ( arr , x ) : NEW_LINE INDENT lo = 0 NEW_LINE hi = ( len ( arr ) - 1 ) NEW_LINE while ( lo <= hi and x >= arr [ lo ] and x <= arr [ hi ] ) : NEW_LINE INDENT if ( lo == hi ) : NEW_LINE INDENT if ( arr [ lo ] == x ) : NEW_LINE INDENT return lo NEW_LINE DEDENT return - 1 NEW_LINE DEDENT pos = lo + ( ( ( hi - lo ) / ( arr [ hi ] - arr [ lo ] ) ) * ( x - arr [ lo ] ) ) NEW_LINE if ( arr [ pos ] == x ) : NEW_LINE INDENT return pos NEW_LINE DEDENT if ( arr [ pos ] < x ) : NEW_LINE INDENT lo = pos + 1 NEW_LINE DEDENT else : NEW_LINE INDENT hi = pos - 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def minSpacePreferLarge ( wall , m , n ) : NEW_LINE INDENT num_m = 0 NEW_LINE num_n = 0 NEW_LINE min_empty = wall NEW_LINE p = 0 NEW_LINE q = 0 NEW_LINE rem = 0 NEW_LINE while ( wall >= n ) : NEW_LINE INDENT p = wall // m NEW_LINE rem = wall % m NEW_LINE if ( rem <= min_empty ) : NEW_LINE INDENT num_m = p NEW_LINE num_n = q NEW_LINE min_empty = rem NEW_LINE DEDENT q += 1 NEW_LINE wall = wall - n NEW_LINE DEDENT print ( num_m , " ▁ " , num_n , " ▁ " , min_empty ) NEW_LINE DEDENT
def findRepeating ( arr , n ) : NEW_LINE INDENT missingElement = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT element = arr [ abs ( arr [ i ] ) ] NEW_LINE if ( element < 0 ) : NEW_LINE INDENT missingElement = arr [ i ] NEW_LINE break NEW_LINE DEDENT arr [ abs ( arr [ i ] ) ] = - arr [ abs ( arr [ i ] ) ] NEW_LINE DEDENT return abs ( missingElement ) NEW_LINE DEDENT
def kLargest ( arr , k ) : NEW_LINE INDENT arr . sort ( reverse = True ) NEW_LINE for i in range ( k ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def knapSack ( W , wt , val , n ) : NEW_LINE INDENT K = [ [ 0 for i in range ( W + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for w in range ( W + 1 ) : NEW_LINE INDENT if ( i == 0 or w == 0 ) : NEW_LINE INDENT K [ i ] [ w ] = 0 NEW_LINE DEDENT elif ( wt [ i - 1 ] <= w ) : NEW_LINE INDENT K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) NEW_LINE DEDENT else : NEW_LINE INDENT K [ i ] [ w ] = K [ i - 1 ] [ w ] NEW_LINE DEDENT DEDENT DEDENT return K [ n ] [ W ] NEW_LINE DEDENT
def isPowerOfFour ( n ) : NEW_LINE INDENT return ( n != 0 and ( ( n & ( n - 1 ) ) == 0 ) and ( n & 0xAAAAAAAA ) == 0 ) NEW_LINE DEDENT
def factorial ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return n * factorial ( n - 1 ) NEW_LINE DEDENT
def findgroups ( arr , n ) : NEW_LINE INDENT c = [ 0 , 0 , 0 ] NEW_LINE res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT c [ arr [ i ] % 3 ] += 1 NEW_LINE DEDENT res += ( ( c [ 0 ] * ( c [ 0 ] - 1 ) ) > > 1 ) NEW_LINE res += c [ 1 ] * c [ 2 ] NEW_LINE res += ( ( c [ 0 ] * ( c [ 0 ] - 1 ) * ( c [ 0 ] - 2 ) ) / 6 NEW_LINE res += ( ( c [ 0 ] * ( c [ 0 ] - 1 ) * ( c [ 0 ] - 2 ) ) / 6 NEW_LINE res += ( ( c [ 1 ] * ( c [ 1 ] - 1 ) * ( c [ 1 ] - 2 ) ) / 6 NEW_LINE res += ( ( c [ 2 ] * ( c [ 2 ] - 1 ) * ( c [ 2 ] - 2 ) ) / 6 ) NEW_LINE res += ( ( c [ 0 ] * c [ 1 ] * c [ 2 ] - 1 ) * ( c [ 2 ] - 2 ) ) / 6 ) NEW_LINE res += c [ 0 ] * c [ 1 ] * c [ 2 ] NEW_LINE return res NEW_LINE DEDENT
def kthLargestSum ( arr , n , k ) : NEW_LINE INDENT sum = [ 0 for x in range ( n + 1 ) ] NEW_LINE sum [ 0 ] = 0 NEW_LINE sum [ 1 ] = arr [ 0 ] NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT sum [ i ] = sum [ i - 1 ] + arr [ i - 1 ] NEW_LINE DEDENT Q = Queue ( ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( i , n + 1 ) : NEW_LINE INDENT x = sum [ j ] - sum [ i - 1 ] NEW_LINE if Q . qsize ( ) < k : NEW_LINE INDENT Q . put ( x ) NEW_LINE DEDENT else : NEW_LINE INDENT if Q . queue [ 0 ] < x : NEW_LINE INDENT Q . get ( ) NEW_LINE Q . put ( x ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return Q . get ( ) NEW_LINE DEDENT
def findMaxValue ( N , mat ) : NEW_LINE INDENT maxValue = - float ( ' inf ' ) NEW_LINE maxArr = [ [ 0 for i in range ( N ) ] for j in range ( N ) ] NEW_LINE maxv = mat [ N - 1 ] [ N - 1 ] NEW_LINE for j in range ( N - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( mat [ N - 1 ] [ j ] > maxv ) : NEW_LINE INDENT maxv = mat [ N - 1 ] [ j ] NEW_LINE DEDENT maxArr [ N - 1 ] [ j ] = maxv NEW_LINE DEDENT maxv = mat [ N - 1 ] [ N - 1 ] NEW_LINE for i in range ( N - 2 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( N - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( maxArr [ i + 1 ] [ j + 1 ] - mat [ i ] [ j ] > maxValue ) : NEW_LINE INDENT maxValue = maxArr [ i + 1 ] [ j + 1 ] - mat [ i ] [ j ] NEW_LINE DEDENT maxArr [ i ] [ j ] = max ( mat [ i ] [ j ] , maxArr [ i + 1 ] [ j + 1 ] , maxArr [ i + 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return maxValue NEW_LINE DEDENT
def kPrimeFactor ( n , k ) : NEW_LINE INDENT while ( n % 2 == 0 ) : NEW_LINE INDENT k -= 1 NEW_LINE n = n / 2 NEW_LINE if ( k == 0 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT i = 3 NEW_LINE while ( i <= math . sqrt ( n ) + 2 ) : NEW_LINE INDENT while ( n % i == 0 ) : NEW_LINE INDENT if ( k == 1 ) : NEW_LINE INDENT return i NEW_LINE k -= 1 NEW_LINE n = n / i NEW_LINE DEDENT DEDENT if ( n > 2 and k == 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def printDistinct ( arr , n ) : NEW_LINE INDENT set = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] not in set : NEW_LINE INDENT set . add ( arr [ i ] ) NEW_LINE print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
def decToBinary ( n ) : NEW_LINE INDENT for i in range ( 31 ) : NEW_LINE INDENT k = n > > i NEW_LINE if ( ( k & 1 ) > 0 ) : NEW_LINE INDENT print ( "1" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "0" ) NEW_LINE DEDENT DEDENT
def SieveOfEratosthenes ( n , isPrime ) : NEW_LINE INDENT isPrime [ 0 ] = isPrime [ 1 ] = False NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT isPrime [ i ] = True NEW_LINE DEDENT for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( isPrime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , n + p ) : NEW_LINE INDENT isPrime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT
def abFree ( s ) : NEW_LINE INDENT b_count = 0 NEW_LINE res = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ len ( s ) - i - 1 ] == ' a ' ) : NEW_LINE INDENT res = ( res + b_count ) NEW_LINE b_count = ( b_count * 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT b_count += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def countSubstrs ( str , i , j , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT res = ( countSubstrs ( str , i + 1 , j , n - 1 ) + countSubstrs ( str , i , j - 1 , n - 1 ) - countSubstrs ( str , i + 1 , j - 1 , n - 2 ) ) NEW_LINE if ( str [ i ] == str [ j ] ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def findFirstMissing ( array , start , end ) : NEW_LINE INDENT if ( start > end ) : NEW_LINE INDENT return end + 1 NEW_LINE DEDENT if ( start != array [ start ] ) : NEW_LINE INDENT return start NEW_LINE DEDENT mid = ( start + end ) // 2 NEW_LINE if ( array [ mid ] == mid ) : NEW_LINE INDENT return findFirstMissing ( array , mid + 1 , end ) NEW_LINE DEDENT return findFirstMissing ( array , start , mid ) NEW_LINE DEDENT
def factorial ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return n * factorial ( n - 1 ) NEW_LINE DEDENT
def minRotation ( input , unlock_code ) : NEW_LINE INDENT rotation = 0 NEW_LINE while ( input > 0 or unlock_code > 0 ) : NEW_LINE INDENT input_digit = input % 10 NEW_LINE code_digit = unlock_code % 10 NEW_LINE rotation += min ( abs ( input_digit - code_digit ) , 10 - abs ( input_digit - code_digit ) ) NEW_LINE input /= 10 NEW_LINE unlock_code /= 10 NEW_LINE DEDENT return rotation NEW_LINE DEDENT
def findFibSubset ( x ) : NEW_LINE INDENT max = max ( x ) NEW_LINE fib = [ ] NEW_LINE result = [ ] NEW_LINE a = 0 NEW_LINE b = 1 NEW_LINE while ( b < max ) : NEW_LINE INDENT c = a + b NEW_LINE a = b NEW_LINE b = c NEW_LINE fib . append ( c ) NEW_LINE DEDENT for i in range ( len ( x ) ) : NEW_LINE INDENT if ( fib [ i ] in fib ) : NEW_LINE INDENT result . append ( x [ i ] ) NEW_LINE DEDENT DEDENT print ( result ) NEW_LINE DEDENT
def checkMarkov ( mat , n , m ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT sum = sum + mat [ i ] [ j ] NEW_LINE DEDENT if ( sum != 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def insertSorted ( arr , n , key , capacity ) : NEW_LINE INDENT if n >= capacity : NEW_LINE INDENT return n NEW_LINE DEDENT i = n - 1 NEW_LINE while ( i >= 0 and arr [ i ] > key ) : NEW_LINE INDENT arr [ i + 1 ] = arr [ i ] NEW_LINE i -= 1 NEW_LINE DEDENT arr [ i + 1 ] = key NEW_LINE return ( n + 1 ) NEW_LINE DEDENT
def recursiveReverse ( str , i ) : NEW_LINE INDENT n = len ( str ) NEW_LINE if ( i == n // 2 ) : NEW_LINE INDENT return NEW_LINE DEDENT swap ( str , i , n - i - 1 ) NEW_LINE recursiveReverse ( str , i + 1 ) NEW_LINE DEDENT
def areConsecutive ( arr , n ) : NEW_LINE INDENT if ( n < 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT min = getMin ( arr , n ) NEW_LINE max = getMax ( arr , n ) NEW_LINE if ( max - min + 1 == n ) : NEW_LINE INDENT visited = [ False ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( visited [ arr [ i ] - min ] != False ) : NEW_LINE INDENT return False NEW_LINE DEDENT visited [ arr [ i ] - min ] = True NEW_LINE DEDENT return True NEW_LINE DEDENT
def findMod ( a , b ) : NEW_LINE INDENT if a < 0 : NEW_LINE INDENT a = - a NEW_LINE DEDENT if b < 0 : NEW_LINE INDENT b = - b NEW_LINE DEDENT mod = a NEW_LINE while ( mod >= b ) : NEW_LINE INDENT mod = mod - b NEW_LINE DEDENT if a < 0 : NEW_LINE INDENT return - mod NEW_LINE DEDENT return mod NEW_LINE DEDENT
def sumOfSubstrings ( num ) : NEW_LINE INDENT n = len ( num ) NEW_LINE sumofdigit = [ 0 for i in range ( n ) ] NEW_LINE sumofdigit [ 0 ] = num [ 0 ] - '0' NEW_LINE res = sumofdigit [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT numi = ord ( num [ i ] ) - ord ( '0' ) NEW_LINE sumofdigit [ i ] = ( i + 1 ) * numi + 10 * sumofdigit [ i - 1 ] NEW_LINE res += sumofdigit [ i ] NEW_LINE DEDENT return res NEW_LINE DEDENT
def findGreatest ( arr , n ) : NEW_LINE INDENT m = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] in m : NEW_LINE INDENT m [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT m [ arr [ i ] ] = m [ arr [ i ] ] + 1 NEW_LINE DEDENT DEDENT arr . sort ( ) NEW_LINE for i in range ( n - 1 , 1 , - 1 ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if arr [ j ] <= math . sqrt ( arr [ i ] ) : NEW_LINE INDENT result = arr [ i ] // arr [ j ] NEW_LINE if result != arr [ j ] and m [ result ] == None or m [ result ] > 0 : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT elif result == arr [ j ] and m [ result ] > 1 : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT DEDENT return - 1 NEW_LINE DEDENT
def getMissingNo ( a , n ) : NEW_LINE INDENT total = 1 NEW_LINE for i in range ( 2 , ( n + 2 ) + 1 ) : NEW_LINE INDENT total += i NEW_LINE total -= a [ i - 2 ] NEW_LINE DEDENT return total NEW_LINE DEDENT
def nextPowerOf2 ( n ) : NEW_LINE INDENT n -= 1 NEW_LINE n |= n > > 1 NEW_LINE n |= n > > 2 NEW_LINE n |= n > > 4 NEW_LINE n |= n > > 8 NEW_LINE n |= n > > 16 NEW_LINE n += 1 NEW_LINE return n NEW_LINE DEDENT
def add ( A , B , C ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT C [ i ] [ j ] = A [ i ] [ j ] + B [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT
def zigzag ( n , k ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( k + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , min ( i , k ) + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ i - j ] NEW_LINE DEDENT DEDENT return dp [ n ] [ k ] NEW_LINE DEDENT
def eggDrop ( n , k ) : NEW_LINE INDENT eggFloor = [ [ 0 for i in range ( k + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT eggFloor [ i ] [ 1 ] = 1 NEW_LINE eggFloor [ i ] [ 0 ] = 0 NEW_LINE DEDENT for j in range ( 1 , k + 1 ) : NEW_LINE INDENT eggFloor [ 1 ] [ j ] = j NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT for j in range ( 2 , k + 1 ) : NEW_LINE INDENT eggFloor [ i ] [ j ] = sys . maxint NEW_LINE for x in range ( 1 , j + 1 ) : NEW_LINE INDENT res = 1 + max ( eggFloor [ i - 1 ] [ x - 1 ] , eggFloor [ i ] [ j - x ] ) NEW_LINE if res < eggFloor [ i ] [ j ] : NEW_LINE INDENT eggFloor [ i ] [ j ] = res NEW_LINE DEDENT DEDENT DEDENT return eggFloor [ n ] [ k ] NEW_LINE DEDENT
def noAdjacentDup ( s1 ) : NEW_LINE INDENT n = len ( s1 ) NEW_LINE s = s1 . toCharArray ( ) NEW_LINE i = 1 NEW_LINE while i < n : NEW_LINE INDENT if s [ i ] == s [ i - 1 ] : NEW_LINE INDENT s [ i ] = ' a ' NEW_LINE while s [ i ] == s [ i + 1 ] : NEW_LINE INDENT s [ i ] = ' b ' NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT return ( s1 ) NEW_LINE DEDENT
def maximumDifferenceSum ( arr , N ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( N ) ] for j in range ( N ) ] NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i ] [ 1 ] = 0 NEW_LINE DEDENT for i in range ( ( N - 1 ) ) : NEW_LINE INDENT dp [ i + 1 ] [ 0 ] = max ( dp [ i ] [ 0 ] , dp [ i ] [ 1 ] + abs ( 1 - arr [ i ] ) ) NEW_LINE dp [ i + 1 ] [ 1 ] = max ( dp [ i ] [ 0 ] + abs ( arr [ i + 1 ] - 1 ) , dp [ i ] [ 1 ] + abs ( arr [ i + 1 ] - arr [ i ] ) ) NEW_LINE DEDENT DEDENT return max ( dp [ N - 1 ] [ 0 ] , dp [ N - 1 ] [ 1 ] ) NEW_LINE DEDENT
def minInsertionStepToSortArray ( arr , N ) : NEW_LINE INDENT lis = [ 0 for i in range ( N ) ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ i ] >= arr [ j ] and lis [ i ] < lis [ j ] + 1 ) : NEW_LINE INDENT lis [ i ] = lis [ j ] + 1 NEW_LINE DEDENT DEDENT max = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( max < lis [ i ] ) : NEW_LINE INDENT max = lis [ i ] NEW_LINE DEDENT DEDENT return ( N - max ) NEW_LINE DEDENT
def isMultipleOf10 ( n ) : NEW_LINE INDENT if ( n % 15 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def exactPrimeFactorCount ( n ) : NEW_LINE INDENT count = 0 NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT n = n / 2 NEW_LINE DEDENT DEDENT for i in range ( 3 , int ( m . sqrt ( n ) + 2 ) ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE while ( n % i == 0 ) : NEW_LINE INDENT n = n / i NEW_LINE DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def query ( s , i , j ) : NEW_LINE INDENT n = len ( s ) NEW_LINE i %= n NEW_LINE j %= n NEW_LINE if ( s [ i ] == s [ j ] ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def maxProduct ( arr , n ) : NEW_LINE INDENT if ( n < 3 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT arr . sort ( ) NEW_LINE return max ( arr [ 0 ] * arr [ 1 ] * arr [ n - 1 ] , arr [ n - 1 ] * arr [ n - 2 ] * arr [ n - 3 ] ) NEW_LINE DEDENT
def findMinAvgSubarray ( n , k ) : NEW_LINE INDENT if ( n < k ) : NEW_LINE INDENT return NEW_LINE DEDENT res_index = 0 NEW_LINE curr_sum = 0 NEW_LINE for i in range ( k , n ) : NEW_LINE INDENT curr_sum += arr [ i ] NEW_LINE DEDENT min_sum = curr_sum NEW_LINE for i in range ( k , n ) : NEW_LINE INDENT curr_sum += arr [ i ] - arr [ i - k ] NEW_LINE if ( curr_sum < min_sum ) : NEW_LINE INDENT min_sum = curr_sum NEW_LINE res_index = ( i - k + 1 ) NEW_LINE DEDENT DEDENT print ( " Subarray ▁ between ▁ [ " , res_index , " , ▁ " , ( res_index + k - 1 ) , " ] ▁ has ▁ minimum ▁ average " ) NEW_LINE DEDENT
def countwalks ( graph , u , v , k ) : NEW_LINE INDENT if ( k == 0 and u == v ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( k == 1 and graph [ u ] [ v ] == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( k <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( V ) : NEW_LINE INDENT if ( graph [ u ] [ i ] == 1 ) : NEW_LINE INDENT count += countwalks ( graph , i , v , k - 1 ) NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def countPairs ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE Hash = Set ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT Hash . add ( arr [ i ] ) NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT product = arr [ i ] * arr [ j ] NEW_LINE if ( Hash . contains ( product ) ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
def print_sequence ( n , k ) : NEW_LINE INDENT b = n / ( k * ( k + 1 ) / 2 ) NEW_LINE if ( b == 0 ) : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT else : NEW_LINE INDENT r = 1 NEW_LINE for x in range ( 1 , n ) : NEW_LINE INDENT if ( n % x != 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( x <= b and x > r ) : NEW_LINE INDENT r = x NEW_LINE DEDENT if ( n // x <= b and n // x > r ) : NEW_LINE INDENT r = n / x NEW_LINE DEDENT DEDENT for i in range ( 1 , k ) : NEW_LINE INDENT print ( r * i , end = " ▁ " ) NEW_LINE DEDENT res = n - ( r * ( k - 1 ) // 2 ) NEW_LINE print ( res ) NEW_LINE DEDENT DEDENT
def nextPowerOf2 ( n ) : NEW_LINE INDENT n -= 1 NEW_LINE n |= n > > 1 NEW_LINE n |= n > > 2 NEW_LINE n |= n > > 4 NEW_LINE n |= n > > 8 NEW_LINE n |= n > > 16 NEW_LINE n += 1 NEW_LINE return n NEW_LINE DEDENT
def findMaxValue ( arr , n ) : NEW_LINE INDENT if ( n < 4 ) : NEW_LINE INDENT print ( " The ▁ array ▁ should ▁ have " , " ▁ atleast ▁ 4 ▁ elements " ) NEW_LINE DEDENT table1 = [ 0 ] * ( n + 1 ) NEW_LINE table2 = [ 0 ] * ( n + 1 ) NEW_LINE table3 = [ 0 ] * ( n - 2 ) NEW_LINE table4 = [ 0 ] * ( n - 4 ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT table1 [ i ] = max ( table1 [ i + 1 ] , arr [ i ] ) NEW_LINE DEDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT table2 [ i ] = max ( table2 [ i + 1 ] , table1 [ i + 1 ] - arr [ i ] ) NEW_LINE DEDENT for i in range ( n - 3 , - 1 , - 1 ) : NEW_LINE INDENT table3 [ i ] = max ( table3 [ i + 1 ] , table2 [ i + 1 ] + arr [ i ] ) NEW_LINE DEDENT for i in range ( n - 4 , - 1 , - 1 ) : NEW_LINE INDENT table4 [ i ] = max ( table4 [ i + 1 ] , table3 [ i + 1 ] - arr [ i ] ) NEW_LINE DEDENT return table4 [ 0 ] NEW_LINE DEDENT
def printInSortedOrder ( arr , n ) : NEW_LINE INDENT index = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT index [ i ] = i NEW_LINE DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT min = i NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ index [ min ] ] == arr [ index [ j ] ] ) : NEW_LINE INDENT min = j NEW_LINE DEDENT DEDENT if ( min != i ) : NEW_LINE INDENT temp = index [ min ] NEW_LINE index [ min ] = index [ i ] NEW_LINE index [ i ] = temp NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ index [ i ] ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def findS ( s ) : NEW_LINE INDENT sum = 0 NEW_LINE for n in range ( 1 , s ) : NEW_LINE INDENT sum += n * n * n NEW_LINE if ( sum == s ) : NEW_LINE INDENT return n NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def printFun ( test ) : NEW_LINE INDENT if ( test < 1 ) : NEW_LINE INDENT return NEW_LINE DEDENT else : NEW_LINE INDENT print ( " % d ▁ " , test ) NEW_LINE printFun ( test - 1 ) NEW_LINE print ( " % d ▁ " , test ) NEW_LINE return NEW_LINE DEDENT DEDENT
def shiftMatrixByK ( mat , k ) : NEW_LINE INDENT global N NEW_LINE if k > N : NEW_LINE INDENT print ( " Shifting ▁ is " , " ▁ not ▁ possible " ) NEW_LINE return NEW_LINE DEDENT j = 0 NEW_LINE while ( j < N ) : NEW_LINE INDENT for i in range ( k , N ) : NEW_LINE INDENT print ( mat [ j ] [ i ] , end = " ▁ " ) NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT print ( mat [ j ] [ i ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE j += 1 NEW_LINE DEDENT DEDENT
def sortUsingHash ( a , n ) : NEW_LINE INDENT max = max ( a ) NEW_LINE min = abs ( a ) NEW_LINE hashpos = [ 0 ] * ( max + 1 ) NEW_LINE hashneg = [ 0 ] * ( min + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] >= 0 ) : NEW_LINE INDENT hashpos [ a [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT hashneg [ abs ( a [ i ] ) ] += 1 NEW_LINE DEDENT DEDENT for i in range ( min , max + 1 ) : NEW_LINE INDENT if ( hashneg [ i ] > 0 ) : NEW_LINE INDENT for j in range ( 0 , hashneg [ i ] ) : NEW_LINE INDENT print ( ( - 1 ) * i , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( max + 1 ) : NEW_LINE INDENT if ( hashpos [ i ] > 0 ) : NEW_LINE INDENT for j in range ( hashpos [ i ] ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
def findPair ( arr , n ) : NEW_LINE INDENT found = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT for k in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] + arr [ j ] == arr [ k ] ) : NEW_LINE INDENT print ( arr [ i ] , arr [ j ] ) NEW_LINE found = True NEW_LINE DEDENT DEDENT DEDENT if ( found == False ) : NEW_LINE INDENT print ( " Not ▁ exist " ) NEW_LINE DEDENT DEDENT
def findMaxGCD ( arr , n ) : NEW_LINE INDENT high = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT high = max ( high , arr [ i ] ) NEW_LINE DEDENT count = [ 0 for i in range ( high + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT count [ arr [ i ] ] += 1 NEW_LINE DEDENT counter = 0 NEW_LINE for i in range ( high + 1 ) : NEW_LINE INDENT counter += 1 NEW_LINE DEDENT for i in range ( high + 1 ) : NEW_LINE INDENT j = i NEW_LINE while ( j <= high ) : NEW_LINE INDENT if ( count [ j ] > 0 ) : NEW_LINE INDENT counter += count [ j ] NEW_LINE DEDENT j += i NEW_LINE DEDENT if ( counter == 2 ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT
def squareRootExists ( n , p ) : NEW_LINE INDENT n = n % p NEW_LINE for x in range ( 2 , p ) : NEW_LINE INDENT if ( ( x * x ) % p == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def count ( n , x ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( x // i <= n and x % i == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def maxSubArraySum ( a , size ) : NEW_LINE INDENT max_so_far = - float ( ' inf ' ) NEW_LINE max_ending_here = 0 NEW_LINE start = 0 NEW_LINE end = 0 NEW_LINE s = 0 NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT max_ending_here += a [ i ] NEW_LINE if ( max_so_far < max_ending_here ) : NEW_LINE INDENT max_so_far = max_ending_here NEW_LINE start = s NEW_LINE end = i NEW_LINE DEDENT if ( max_ending_here < 0 ) : NEW_LINE INDENT max_ending_here = 0 NEW_LINE s = i + 1 NEW_LINE DEDENT DEDENT return ( end - start + 1 ) NEW_LINE DEDENT
def smallestSubsegment ( a , n ) : NEW_LINE INDENT left = dict ( ) NEW_LINE count = dict ( ) NEW_LINE mx = 0 NEW_LINE mn = - 1 NEW_LINE strindex = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = a [ i ] NEW_LINE if count [ x ] == None : NEW_LINE INDENT left [ x ] = i NEW_LINE count [ x ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT count [ x ] += 1 NEW_LINE DEDENT if ( count [ x ] > mx ) : NEW_LINE INDENT mx = count [ x ] NEW_LINE mn = i - left [ x ] + 1 NEW_LINE strindex = left [ x ] NEW_LINE DEDENT elif ( ( count [ x ] == mx ) and ( i - left [ x ] + 1 < mn ) ) : NEW_LINE INDENT mn = i - left [ x ] + 1 NEW_LINE strindex = left [ x ] NEW_LINE DEDENT DEDENT for i in range ( strindex , strindex + mn ) : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def findRandomIndexOfMax ( arr , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if mp . get ( arr [ i ] ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT max_element = 10 ** 9 NEW_LINE max_so_far = 10 ** 9 NEW_LINE for p in mp : NEW_LINE INDENT if p . getValue ( ) > max_so_far : NEW_LINE INDENT max_so_far = p . getValue ( ) NEW_LINE max_element = p . getKey ( ) NEW_LINE DEDENT DEDENT r = ( int ) ( ( random ( ) . nextInt ( max_so_far ) % max_so_far ) + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] == max_element : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( count == r ) : NEW_LINE INDENT print ( " Element ▁ with ▁ maximum ▁ frequency ▁ present ▁ " , " at ▁ index ▁ " , i ) NEW_LINE return NEW_LINE DEDENT DEDENT
def minRadius ( k , x , y , n ) : NEW_LINE INDENT dis = [ 0 ] * n NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT dis [ i ] = x [ i ] * x [ i ] + y [ i ] * y [ i ] NEW_LINE DEDENT dis . sort ( ) NEW_LINE return dis [ k - 1 ] NEW_LINE DEDENT
def singleNumber ( a , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . add ( i ) NEW_LINE DEDENT arr_sum = 0 NEW_LINE for i in range ( a ) : NEW_LINE INDENT arr_sum += i NEW_LINE DEDENT set_sum = 0 NEW_LINE for i in s : NEW_LINE INDENT set_sum += i NEW_LINE DEDENT return ( 3 * set_sum - arr_sum ) // 2 NEW_LINE DEDENT
def countInRange ( arr , n , x , y ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] >= x and arr [ i ] <= y ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def findSmallest ( m , s ) : NEW_LINE INDENT if ( s == 0 ) : NEW_LINE INDENT print ( m == 1 ? " Smallest ▁ number ▁ is ▁ 0 " : " Not ▁ possible " ) NEW_LINE return NEW_LINE DEDENT if ( s > 9 * m ) : NEW_LINE INDENT print ( " Not ▁ possible " ) NEW_LINE return NEW_LINE DEDENT res = [ 0 ] * m NEW_LINE s -= 1 NEW_LINE for i in range ( m - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( s > 9 ) : NEW_LINE INDENT res [ i ] = 9 NEW_LINE s -= 9 NEW_LINE DEDENT else : NEW_LINE INDENT res [ i ] = s NEW_LINE s = 0 NEW_LINE DEDENT DEDENT res [ 0 ] = s + 1 NEW_LINE print ( " Smallest ▁ number ▁ is " ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT print ( res [ i ] ) NEW_LINE DEDENT DEDENT
def isPresent ( s , q ) : NEW_LINE INDENT freq = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT freq [ ord ( s [ i ] ) - 97 ] += 1 NEW_LINE DEDENT for i in range ( len ( q ) ) : NEW_LINE INDENT freq [ ord ( q [ i ] ) ] -= 1 NEW_LINE if ( freq [ ord ( q [ i ] ) ] < 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def sortArray ( arr , n , A , B , C ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT arr [ i ] = A * arr [ i ] * arr [ i ] + B * arr [ i ] + C NEW_LINE DEDENT index = - 1 NEW_LINE maximum = - 999999 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( maximum < arr [ i ] ) : NEW_LINE INDENT index = i NEW_LINE maximum = arr [ i ] NEW_LINE DEDENT DEDENT i = 0 NEW_LINE j = n - 1 NEW_LINE new_arr = [ 0 ] * n NEW_LINE k = 0 NEW_LINE while ( i < index and j > index ) : NEW_LINE INDENT if ( arr [ i ] < arr [ j ] ) : NEW_LINE INDENT new_arr [ k ] = arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT new_arr [ k ] = arr [ j -= 1 NEW_LINE DEDENT DEDENT while ( i < index ) : NEW_LINE INDENT new_arr [ k ] = arr [ i ] NEW_LINE i += 1 NEW_LINE DEDENT while ( j > index ) : NEW_LINE INDENT new_arr [ k ] = arr [ j ] NEW_LINE j -= 1 NEW_LINE DEDENT new_arr [ n - 1 ] = maximum NEW_LINE for p in range ( 0 , n ) : NEW_LINE INDENT arr [ p ] = new_arr [ p ] NEW_LINE DEDENT DEDENT
def printDistance ( mat ) : NEW_LINE INDENT ans = [ [ 0 for i in range ( M ) ] for j in range ( N ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT ans [ i ] [ j ] = sys . maxint NEW_LINE DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT for k in range ( N ) : NEW_LINE INDENT for l in range ( M ) : NEW_LINE INDENT if ( mat [ k ] [ l ] == 1 ) : NEW_LINE INDENT ans [ i ] [ j ] = min ( ans [ i ] [ j ] , abs ( i - k ) + abs ( j - l ) ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT print ( ans [ i ] [ j ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT
def findLastIndex ( str , x ) : NEW_LINE INDENT index = - 1 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] == x ) : NEW_LINE INDENT index = i NEW_LINE DEDENT DEDENT return index NEW_LINE DEDENT
def printAllAPTriplets ( arr , n ) : NEW_LINE INDENT s = [ ] NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT diff = arr [ j ] - arr [ i ] NEW_LINE if ( exists ) : NEW_LINE INDENT print ( arr [ i ] - diff , ' ▁ ' , arr [ i ] , ' ▁ ' , arr [ j ] ) NEW_LINE DEDENT DEDENT s . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT
def simplify ( Str ) : NEW_LINE INDENT lenn = len ( Str ) NEW_LINE res = [ 0 ] * ( lenn ) NEW_LINE index = 0 NEW_LINE i = 0 NEW_LINE while i < len : NEW_LINE INDENT if ( Str [ i ] == ' + ' ) : NEW_LINE INDENT if ( s . queue [ 0 ] == 1 ) : NEW_LINE INDENT res [ index += 1 ] = ' - ' NEW_LINE DEDENT if ( s . queue [ 0 ] == 0 ) : NEW_LINE INDENT res [ index += 1 ] = ' + ' NEW_LINE DEDENT elif ( Str [ i ] == ' - ' ) : NEW_LINE INDENT if ( s . queue [ 0 ] == 1 ) : NEW_LINE INDENT res [ index += 1 ] = ' - ' NEW_LINE DEDENT elif ( str [ i ] == ' ( ' and i > 0 ) : NEW_LINE INDENT if ( Str [ i - 1 ] == ' - ' ) : NEW_LINE INDENT x = 0 NEW_LINE DEDENT s . append ( s . queue [ 0 ] ) NEW_LINE DEDENT elif ( Str [ i ] == ' + ' ) : NEW_LINE INDENT s . pop ( ) NEW_LINE DEDENT else : NEW_LINE INDENT res [ index ] = Str [ i ] NEW_LINE i += 1 NEW_LINE DEDENT DEDENT return new string ( res ) NEW_LINE DEDENT
def vol_of_dodecahedron ( side ) : NEW_LINE INDENT return ( ( ( 15 + ( 7 * ( math . sqrt ( 5 ) ) ) / 4 ) * ( math . pow ( side , 3 ) ) ) NEW_LINE DEDENT
def countTransformation ( a , b ) : NEW_LINE INDENT n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE if ( m == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT if ( a [ j ] == b [ i ] ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 NEW_LINE DEDENT elif ( a [ j ] == b [ i ] ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT elif ( a [ j ] == b [ i ] ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT return dp [ m - 1 ] [ n - 1 ] NEW_LINE DEDENT
def sumAtKthLevel ( tree , k , level ) : NEW_LINE INDENT i = i + 1 NEW_LINE if ( tree [ i ] == ' ( ' ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT sum = 0 NEW_LINE if ( level == k ) : NEW_LINE INDENT sum = tree [ i ] - '0' NEW_LINE DEDENT ++ i NEW_LINE DEDENT leftsum = sumAtKthLevel ( tree , k , level + 1 ) NEW_LINE i = i + 1 NEW_LINE rightsum = sumAtKthLevel ( tree , k , level + 1 ) NEW_LINE ++ i NEW_LINE return sum + leftsum + rightsum NEW_LINE DEDENT
def printRepeating ( arr , size ) : NEW_LINE INDENT count = [ 0 ] * size NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT if ( count [ arr [ i ] ] == 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT count [ arr [ i ] ] += 1 NEW_LINE DEDENT DEDENT DEDENT
def countPairsWithDiffK ( arr , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE arr . sort ( ) NEW_LINE l = 0 NEW_LINE r = 0 NEW_LINE while ( r < n ) : NEW_LINE INDENT if ( arr [ r ] - arr [ l ] == k ) : NEW_LINE INDENT count += 1 NEW_LINE l += 1 NEW_LINE r += 1 NEW_LINE DEDENT elif ( arr [ r ] - arr [ l ] > k ) : NEW_LINE INDENT l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT r += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def isSubsetSum ( set , n , Sum ) : NEW_LINE INDENT subset = [ [ False for i in range ( Sum + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT subset [ 0 ] [ i ] = True NEW_LINE DEDENT for i in range ( 1 , Sum + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT subset [ i ] [ j ] = subset [ i ] [ j - 1 ] NEW_LINE if i >= Set [ j - 1 ] : NEW_LINE INDENT subset [ i ] [ j ] = subset [ i ] [ j ] or subset [ i - set [ j - 1 ] ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT return subset [ sum ] [ n ] NEW_LINE DEDENT
def findMajority ( arr , n ) : NEW_LINE INDENT map = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if map . get ( arr [ i ] ) : NEW_LINE INDENT count = map [ arr [ i ] ] + 1 NEW_LINE if ( count > arr . length // 2 ) : NEW_LINE INDENT print ( " Majority ▁ found ▁ : - ▁ " , arr [ i ] ) NEW_LINE return NEW_LINE DEDENT else : NEW_LINE INDENT map [ arr [ i ] ] = count + 1 NEW_LINE DEDENT DEDENT print ( " ▁ No ▁ Majority ▁ element " ) NEW_LINE DEDENT
def knapSack ( W , wt , val , n ) : NEW_LINE INDENT if ( n == 0 or W == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( wt [ n - 1 ] > W ) : NEW_LINE INDENT return knapSack ( W , wt , val , n - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 ] , wt , val , n - 1 ) , knapSack ( W , wt , val , n - 1 ) ) NEW_LINE DEDENT DEDENT
def replaceOriginal ( s , n ) : NEW_LINE INDENT r = [ 0 ] * n NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT r [ i ] = s [ n - 1 - i ] NEW_LINE if ( s [ i ] != ' a ' and s [ i ] != ' e ' and s [ i ] != ' i ' and s [ i ] != ' o ' and s [ i ] != ' u ' ) : NEW_LINE INDENT print ( r [ i ] , end = " " ) NEW_LINE DEDENT DEDENT print ( " " ) NEW_LINE DEDENT
def findPair ( arr , n ) : NEW_LINE INDENT s = Set ( ) NEW_LINE for i in arr : NEW_LINE INDENT s . add ( i ) NEW_LINE DEDENT found = False NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT sum = arr [ i ] + arr [ j ] NEW_LINE if ( s . contains ( sum ) ) : NEW_LINE INDENT found = True NEW_LINE print ( arr [ i ] , arr [ j ] ) NEW_LINE DEDENT DEDENT DEDENT if ( found == False ) : NEW_LINE INDENT print ( " Not ▁ Exist ▁ " ) NEW_LINE DEDENT DEDENT
def countNonEmptySubstr ( string ) : NEW_LINE INDENT n = len ( string ) NEW_LINE return n * ( n + 1 ) / 2 NEW_LINE DEDENT
def countDigits ( a , b ) : NEW_LINE INDENT count = 0 NEW_LINE p = abs ( a * b ) NEW_LINE if ( p == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT while ( p > 0 ) : NEW_LINE INDENT count += 1 NEW_LINE p = int ( p / 10 ) NEW_LINE DEDENT return count NEW_LINE DEDENT
def maxProfit ( prices , n ) : NEW_LINE INDENT profit = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if prices [ i ] > max_price : NEW_LINE INDENT max_price = price [ i ] NEW_LINE DEDENT profit [ i ] = max ( profit [ i + 1 ] , max_price - prices [ i ] ) NEW_LINE DEDENT min_price = prices [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if prices [ i ] < min_price : NEW_LINE INDENT min_price = price [ i ] NEW_LINE DEDENT profit [ i ] = max ( profit [ i - 1 ] , profit [ i ] + ( prices [ i ] - min_price ) ) NEW_LINE DEDENT result = profit [ n - 1 ] NEW_LINE return result NEW_LINE DEDENT
def countDer ( n ) : NEW_LINE INDENT der = [ 0 ] * ( n + 1 ) NEW_LINE der [ 0 ] = 1 NEW_LINE der [ 1 ] = 0 NEW_LINE der [ 2 ] = 1 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT der [ i ] = ( i - 1 ) * ( der [ i - 1 ] + der [ i - 2 ] ) NEW_LINE DEDENT return der [ n ] NEW_LINE DEDENT
def findMaxPath ( mat ) : NEW_LINE INDENT res = - 1 NEW_LINE for i in range ( M ) : NEW_LINE INDENT res = max ( res , mat [ 0 ] [ i ] ) NEW_LINE DEDENT for i in range ( 1 , N ) : NEW_LINE INDENT res = - 1 NEW_LINE for j in range ( M ) : NEW_LINE INDENT if ( j > 0 and j < M - 1 ) : NEW_LINE INDENT mat [ i ] [ j ] += max ( mat [ i - 1 ] [ j - 1 ] , mat [ i - 1 ] [ j + 1 ] ) ) NEW_LINE DEDENT elif ( j > 0 and j < M - 1 ) : NEW_LINE INDENT mat [ i ] [ j ] += max ( mat [ i - 1 ] [ j ] , mat [ i - 1 ] [ j - 1 ] ) NEW_LINE DEDENT elif ( j < M - 1 ) : NEW_LINE INDENT mat [ i ] [ j ] += max ( mat [ i - 1 ] [ j ] , mat [ i - 1 ] [ j + 1 ] ) NEW_LINE DEDENT res = max ( mat [ i ] [ j ] , res ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def checkIsAP ( arr , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT arr . sort ( ) NEW_LINE d = arr [ 1 ] - arr [ 0 ] NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT if ( arr [ i ] - arr [ i - 1 ] != d ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def check ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE oddDigSum = 0 NEW_LINE evenDigSum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT oddDigSum += ord ( str [ i ] ) - ord ( '0' ) NEW_LINE DEDENT else : NEW_LINE INDENT evenDigSum += ord ( str [ i ] ) - ord ( '0' ) NEW_LINE DEDENT DEDENT return ( ( oddDigSum - evenDigSum ) % 11 == 0 ) NEW_LINE DEDENT
def swap ( xp , yp ) : NEW_LINE INDENT xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] NEW_LINE yp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] NEW_LINE xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] NEW_LINE yp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] NEW_LINE DEDENT xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] NEW_LINE DEDENT
def find_Area ( r ) : NEW_LINE INDENT return ( 2 * r * r ) NEW_LINE DEDENT
def isLucky ( n ) : NEW_LINE INDENT arr = [ False for i in range ( 10 ) ] NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT arr [ i ] = False NEW_LINE DEDENT while ( n > 0 ) : NEW_LINE INDENT digit = n % 10 NEW_LINE if ( arr [ digit ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT arr [ digit ] = True NEW_LINE n = int ( n / 10 ) NEW_LINE DEDENT return True NEW_LINE DEDENT
def countWaysToJump ( arr , n ) : NEW_LINE INDENT count_jump = [ 0 for x in range ( n ) ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] >= n - i - 1 ) : NEW_LINE INDENT count_jump [ i ] += 1 NEW_LINE DEDENT for j in range ( i + 1 , n - 1 ) : NEW_LINE INDENT if ( count_jump [ j ] != - 1 ) : NEW_LINE INDENT count_jump [ i ] += count_jump [ j ] NEW_LINE DEDENT DEDENT if ( count_jump [ i ] == 0 ) : NEW_LINE INDENT count_jump [ i ] = - 1 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( count_jump [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def zodiac_sign ( day , month ) : NEW_LINE INDENT astro_sign = " " NEW_LINE if ( month == " december " ) : NEW_LINE INDENT if ( day < 22 ) : NEW_LINE INDENT astro_sign = " Sagittarius " NEW_LINE DEDENT else : NEW_LINE INDENT astro_sign = " capricorn " NEW_LINE DEDENT elif ( month == " january " ) : NEW_LINE INDENT if ( day < 19 ) : NEW_LINE INDENT astro_sign = " Aquarius " NEW_LINE DEDENT else : NEW_LINE INDENT astro_sign = " pisces " NEW_LINE DEDENT elif ( month == " march " ) : NEW_LINE INDENT if ( day < 21 ) : NEW_LINE INDENT astro_sign = " Aries " NEW_LINE DEDENT else : NEW_LINE INDENT astro_sign = " aries " NEW_LINE DEDENT elif ( month == " may " ) : NEW_LINE INDENT if ( day < 21 ) : NEW_LINE INDENT astro_sign = " Taurus " NEW_LINE DEDENT else : NEW_LINE INDENT astro_sign = " gemini " NEW_LINE DEDENT elif ( month == " june " ) : NEW_LINE INDENT if ( day < 23 ) : NEW_LINE INDENT astro_sign = " Cancer " NEW_LINE DEDENT else : NEW_LINE INDENT astro_sign = " Leo " NEW_LINE DEDENT elif ( month == " september " ) : NEW_LINE INDENT if ( day < 23 ) : NEW_LINE INDENT astro_sign = " Virgo " NEW_LINE DEDENT else : NEW_LINE INDENT astro_sign = " libra " NEW_LINE DEDENT DEDENT if ( month == " november " ) : NEW_LINE INDENT if ( day < 22 ) : NEW_LINE INDENT astro_sign = " scorpio " NEW_LINE DEDENT else : NEW_LINE INDENT astro_sign = " scorpio " NEW_LINE DEDENT DEDENT if ( month == " november " ) : NEW_LINE INDENT astro_sign = " scorpio " NEW_LINE DEDENT DEDENT
def countSol ( coeff , n , rhs ) : NEW_LINE INDENT dp = [ 0 for _ in range ( rhs + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( coeff [ i ] , rhs + 1 ) : NEW_LINE INDENT dp [ j ] = dp [ j - coeff [ i ] ] NEW_LINE DEDENT DEDENT return dp [ rhs ] NEW_LINE DEDENT
def isSymmetric ( mat , N ) : NEW_LINE INDENT for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( 0 , N ) : NEW_LINE INDENT if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT
def isRectangle ( mat ) : NEW_LINE INDENT rows = len ( mat ) NEW_LINE if ( rows == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT columns = len ( mat [ 0 ] ) NEW_LINE for y1 in range ( rows ) : NEW_LINE INDENT for x1 in range ( columns ) : NEW_LINE INDENT if ( mat [ y1 ] [ x1 ] == 1 ) : NEW_LINE INDENT for y2 in range ( y1 + 1 , rows ) : NEW_LINE INDENT for x2 in range ( x1 + 1 , columns ) : NEW_LINE INDENT if ( mat [ y1 ] [ x2 ] == 1 and mat [ y2 ] [ x1 ] == 1 and mat [ y2 ] [ x2 ] == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT
def isDivBy9 ( n ) : NEW_LINE INDENT if ( n == 0 or n == 9 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n < 9 ) : NEW_LINE INDENT return False NEW_LINE DEDENT return isDivBy9 ( ( int ) ( n > > 3 ) - ( int ) ( n & 7 ) ) NEW_LINE DEDENT
def knapSack ( W , wt , val , n ) : NEW_LINE INDENT if ( n == 0 or W == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( wt [ n - 1 ] > W ) : NEW_LINE INDENT return knapSack ( W , wt , val , n - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 ] , wt , val , n - 1 ) , knapSack ( W , wt , val , n - 1 ) ) NEW_LINE DEDENT DEDENT
def printRepeating ( arr , size ) : NEW_LINE INDENT xor = arr [ 0 ] NEW_LINE set_bit_no = 0 NEW_LINE x = 0 NEW_LINE y = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT xor ^= arr [ i ] NEW_LINE DEDENT for i in range ( 1 , size + 1 ) : NEW_LINE INDENT xor ^= i NEW_LINE DEDENT set_bit_no = ( xor & ~ ( xor - 1 ) ) NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT a = arr [ i ] & set_bit_no NEW_LINE if a != 0 : NEW_LINE INDENT x = x ^ arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT y = y ^ arr [ i ] NEW_LINE DEDENT DEDENT print ( " The ▁ two ▁ reppeated ▁ elements ▁ are ▁ : " ) NEW_LINE print ( x ) NEW_LINE DEDENT
def findSubsequenceCount ( S , T ) : NEW_LINE INDENT m = len ( T ) NEW_LINE n = len ( S ) NEW_LINE if m > n : NEW_LINE INDENT return 0 NEW_LINE DEDENT mat = [ [ 0 for i in range ( n + 1 ) ] for j in range ( m + 1 ) ] NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if T [ i - 1 ] != S [ j - 1 ] : NEW_LINE INDENT mat [ i ] [ j ] = mat [ i ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT mat [ i ] [ j ] = mat [ i ] [ j - 1 ] + mat [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT return mat [ m ] [ n ] NEW_LINE DEDENT
def breakSum ( n ) : NEW_LINE INDENT dp = [ 0 for _ in range ( n + 1 ) ] NEW_LINE dp [ 0 ] = 0 NEW_LINE dp [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i // 2 ] + dp [ i // 3 ] + dp [ i // 4 ] , i ) NEW_LINE DEDENT return dp [ n ] NEW_LINE DEDENT
def decToHexa ( n ) : NEW_LINE INDENT hexaDeciNum = [ 0 ] * 100 NEW_LINE i = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT temp = 0 NEW_LINE temp = n % 16 NEW_LINE if ( temp < 10 ) : NEW_LINE INDENT hexaDeciNum [ i ] = chr ( temp + 48 ) NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT hexaDeciNum [ i ] = chr ( temp + 55 ) NEW_LINE i += 1 NEW_LINE DEDENT n = int ( n / 16 ) NEW_LINE DEDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( hexaDeciNum [ j ] , end = " " ) NEW_LINE DEDENT DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if a == b : NEW_LINE INDENT return a NEW_LINE DEDENT if b == 0 : NEW_LINE INDENT return b NEW_LINE DEDENT if ( ~ a & 1 ) == 1 : NEW_LINE INDENT if ( ( b & 1 ) == 1 ) : NEW_LINE INDENT return gcd ( a > > 1 , b ) NEW_LINE DEDENT else : NEW_LINE INDENT return gcd ( a > > 1 , b > > 1 ) << 1 NEW_LINE DEDENT if ( ( ~ b & 1 ) == 1 ) : NEW_LINE INDENT return gcd ( a , b > > 1 ) NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT return gcd ( ( a - b ) > > 1 , b ) NEW_LINE DEDENT return gcd ( ( b - a ) > > 1 , a ) NEW_LINE DEDENT
def oppositeSigns ( x , y ) : NEW_LINE INDENT return ( ( x ^ y ) < 0 ) NEW_LINE DEDENT
def arraySortedOrNot ( arr , n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i - 1 ] > arr [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def strToBinary ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT val = int ( s [ i ] ) NEW_LINE bin = " " NEW_LINE while ( val > 0 ) : NEW_LINE INDENT if ( val % 2 == 1 ) : NEW_LINE INDENT bin += '1' NEW_LINE DEDENT else : NEW_LINE INDENT bin += '0' NEW_LINE DEDENT val /= 2 NEW_LINE DEDENT bin = list ( bin ) NEW_LINE print ( bin , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def evaluate ( n ) : NEW_LINE INDENT if ( n == 1 or n == 2 ) : NEW_LINE INDENT print ( " No ▁ Pythagoras ▁ " , " Triplet ▁ exists " ) NEW_LINE DEDENT elif ( n % 2 == 0 ) : NEW_LINE INDENT var = 1 * n * n / 4 NEW_LINE print ( " Pythagoras ▁ Triplets ▁ " , " exist ▁ i . e . ▁ " ) NEW_LINE print ( n , end = " ▁ " ) NEW_LINE print ( var - 1 , end = " ▁ " ) NEW_LINE print ( var + 1 , end = " ▁ " ) NEW_LINE DEDENT DEDENT elif ( n % 2 != 0 ) : NEW_LINE INDENT var = 1 * n * n + 1 NEW_LINE print ( " Pythagoras ▁ Triplets ▁ " , " exist ▁ i . e . ▁ " ) NEW_LINE print ( n , end = " ▁ " ) NEW_LINE print ( var / 2 - 1 , end = " ▁ " ) NEW_LINE print ( var / 2 , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def isOverflow ( a , b ) : NEW_LINE INDENT if ( a == 0 or b == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT result = a * b NEW_LINE if ( a == result // b ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT
def findDuplicateparenthesis ( s ) : NEW_LINE INDENT Stack = [ ] NEW_LINE str = [ s ] NEW_LINE for ch in str : NEW_LINE INDENT if ( ch == ' ) ' : NEW_LINE INDENT top = Stack [ - 1 ] NEW_LINE Stack . pop ( ) NEW_LINE elementsInside = 0 NEW_LINE while ( top != ' ( ' ) : NEW_LINE INDENT elementsInside += 1 NEW_LINE top = Stack [ - 1 ] NEW_LINE Stack . pop ( ) NEW_LINE DEDENT if ( elementsInside < 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT Stack . append ( ch ) NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def countRotations ( n ) : NEW_LINE INDENT lenn = len ( n ) NEW_LINE if ( len == 1 ) : NEW_LINE INDENT oneDigit = n [ 0 ] - '0' NEW_LINE if ( oneDigit % 4 == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT twoDigit = 0 NEW_LINE for i in range ( 0 , ( len - 1 ) ) : NEW_LINE INDENT twoDigit = ( ord ( n [ i ] ) - ord ( '0' ) ) * 10 + ( ord ( n [ i + 1 ] ) - ord ( '0' ) ) NEW_LINE if ( twoDigit % 4 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT twoDigit = ( ord ( n [ len - 1 ] ) - ord ( '0' ) ) * 10 + ( n [ 0 ] - ord ( '0' ) ) NEW_LINE if ( twoDigit % 4 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def findTriplets ( x ) : NEW_LINE INDENT fact = [ 0 ] * ( 10 + 20 ) NEW_LINE factors = [ 0 ] * ( 10 + 20 ) NEW_LINE for i in range ( 2 , int ( m . sqrt ( x ) + 1 ) ) : NEW_LINE INDENT if ( x % i == 0 ) : NEW_LINE INDENT fact . append ( i ) NEW_LINE if ( x / i != i ) : NEW_LINE INDENT fact . append ( x / i ) NEW_LINE DEDENT factors . append ( i ) NEW_LINE DEDENT factors . append ( x / i ) NEW_LINE DEDENT DEDENT found = False NEW_LINE for i in range ( k ) : NEW_LINE INDENT a = fact [ i ] NEW_LINE for j in range ( k ) : NEW_LINE INDENT b = fact [ j ] NEW_LINE if ( ( a != b ) and ( x // ( a * b ) != a ) and ( x / ( a * b ) != b ) and ( x / ( a * b ) != 1 ) ) : NEW_LINE INDENT print ( a , " ▁ " , b , " ▁ " , x / ( a * b ) ) NEW_LINE found = True NEW_LINE break NEW_LINE DEDENT DEDENT if ( found ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( found ) : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT DEDENT
def findCombinations ( str , index , out ) : NEW_LINE INDENT if ( index == len ( str ) ) : NEW_LINE INDENT print ( out ) NEW_LINE DEDENT for i in range ( index , len ( str ) ) : NEW_LINE INDENT findCombinations ( str , i + 1 , out + " ( " , str [ index : i + 1 ] ) NEW_LINE DEDENT DEDENT
def search ( arr , n , x ) : NEW_LINE INDENT i = 0 NEW_LINE while i <= n - 1 : NEW_LINE INDENT if arr [ i ] == x : NEW_LINE INDENT return i NEW_LINE DEDENT i += abs ( arr [ i ] - x ) NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def findMissing ( a , b , n , m ) : NEW_LINE INDENT s = Set ( ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT s . add ( b [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] not in s ) : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
def countPairs ( str ) : NEW_LINE INDENT result = 0 NEW_LINE n = len ( str ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 1 , MAX_CHAR + 1 ) : NEW_LINE INDENT if ( ( abs ( str [ i + j ] - str [ i ] ) == j ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
def maxSum ( stack1 , stack2 , stack3 , n1 , n2 , n3 ) : NEW_LINE INDENT sum1 = 0 NEW_LINE sum2 = 0 NEW_LINE sum3 = 0 NEW_LINE for i in range ( n1 ) : NEW_LINE INDENT sum1 += stack1 [ i ] NEW_LINE DEDENT for i in range ( n2 ) : NEW_LINE INDENT sum2 += stack2 [ i ] NEW_LINE DEDENT for i in range ( n3 ) : NEW_LINE INDENT sum3 += stack3 [ i ] NEW_LINE DEDENT top1 = 0 NEW_LINE top2 = 0 NEW_LINE top3 = 0 NEW_LINE while ( True ) : NEW_LINE INDENT if ( sum1 == sum2 and sum2 == sum3 ) : NEW_LINE INDENT return sum1 NEW_LINE DEDENT if ( sum1 >= sum2 and sum1 >= sum3 ) : NEW_LINE INDENT sum1 -= stack1 [ top1 ] NEW_LINE DEDENT elif ( sum2 >= sum3 and sum2 >= sum1 ) : NEW_LINE INDENT sum2 -= stack2 [ top2 ] NEW_LINE DEDENT elif ( sum3 >= sum2 and sum3 >= sum1 ) : NEW_LINE INDENT sum3 -= stack3 [ top3 ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def solve ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE a = 0 NEW_LINE b = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( i % 2 != 0 ) : NEW_LINE INDENT a = a * 10 + arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT b = b * 10 + arr [ i ] NEW_LINE DEDENT DEDENT return a + b NEW_LINE DEDENT
def firstFactorialDivisibleNumber ( x ) : NEW_LINE INDENT i = 1 NEW_LINE fact = 1 NEW_LINE for i in range ( 1 , x ) : NEW_LINE INDENT fact = fact * i NEW_LINE if ( fact % x == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return i NEW_LINE DEDENT
def countMinOperations ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE while True : NEW_LINE INDENT zero_count = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT if arr [ i ] % 2 == 1 : NEW_LINE INDENT break NEW_LINE DEDENT elif arr [ i ] == 0 : NEW_LINE INDENT zero_count += 1 NEW_LINE DEDENT DEDENT if ( zero_count == n ) : NEW_LINE INDENT return result NEW_LINE DEDENT if ( i == n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT if arr [ j ] % 2 == 1 : NEW_LINE INDENT arr [ j ] = arr [ j ] // 2 NEW_LINE result += 1 NEW_LINE DEDENT DEDENT DEDENT
def sortit ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT arr [ i ] = i + 1 NEW_LINE DEDENT DEDENT
def canMakeAllSame ( str ) : NEW_LINE INDENT zeros = 0 NEW_LINE ones = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT ch = ord ( str [ i ] ) NEW_LINE if ( ch == '0' ) : NEW_LINE INDENT zeros += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ones += 1 NEW_LINE DEDENT DEDENT return ( zeros == 1 or ones == 1 ) NEW_LINE DEDENT
def minheapify ( a , index ) : NEW_LINE INDENT small = index NEW_LINE l = 2 * index + 1 NEW_LINE r = 2 * index + 2 NEW_LINE if ( l < n and a [ l ] < a [ small ] ) : NEW_LINE INDENT small = l NEW_LINE DEDENT if ( r < n and a [ r ] < a [ small ] ) : NEW_LINE INDENT small = r NEW_LINE DEDENT if ( small != index ) : NEW_LINE INDENT t = a [ small ] NEW_LINE a [ small ] = a [ index ] NEW_LINE a [ index ] = t NEW_LINE minheapify ( a , small ) NEW_LINE DEDENT DEDENT
def KMP ( m , n , str2 , str1 ) : NEW_LINE INDENT pos = 0 NEW_LINE len = 0 NEW_LINE p = [ 0 ] * m NEW_LINE k = 0 NEW_LINE ch1 = str1 . toCharArray ( ) NEW_LINE ch2 = str2 . toCharArray ( ) NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT while ( k > 0 and ch1 [ k ] != ch1 [ i - 1 ] ) : NEW_LINE INDENT k = p [ k ] NEW_LINE if ( ch1 [ k ] == ch1 [ i - 1 ] ) : NEW_LINE INDENT k = p [ k ] NEW_LINE DEDENT p [ i ] = k NEW_LINE DEDENT for j in range ( 0 , m + 1 ) : NEW_LINE INDENT while ( j > 0 and j < n and ch1 [ j ] != ch2 [ i ] ) : NEW_LINE INDENT j = p [ j ] NEW_LINE DEDENT if ( j < n and ch1 [ j ] == ch2 [ i ] ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT if ( j > len ) : NEW_LINE INDENT len = j NEW_LINE pos = i - j + 1 NEW_LINE DEDENT DEDENT print ( " Shift ▁ = ▁ " , pos ) NEW_LINE print ( " Prefix ▁ = ▁ " , str1 [ 0 : len ] ) NEW_LINE DEDENT
def swapDiagonal ( matrix ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT temp = matrix [ i ] [ i ] NEW_LINE matrix [ i ] [ i ] = matrix [ i ] [ N - i - 1 ] NEW_LINE matrix [ i ] [ N - i - 1 ] = temp NEW_LINE DEDENT DEDENT
def psuedoBinary ( n ) : NEW_LINE INDENT while ( n != 0 ) : NEW_LINE INDENT temp = n NEW_LINE m = 0 NEW_LINE p = 1 NEW_LINE while ( temp != 0 ) : NEW_LINE INDENT rem = temp % 10 NEW_LINE temp = int ( temp / 10 ) NEW_LINE if ( rem != 0 ) : NEW_LINE INDENT m += p NEW_LINE p = 10 NEW_LINE DEDENT DEDENT print ( m , end = " ▁ " ) NEW_LINE n = n - m NEW_LINE DEDENT print ( " ▁ " ) NEW_LINE DEDENT
def findmin ( p , n ) : NEW_LINE INDENT a = 0 NEW_LINE b = 0 NEW_LINE c = 0 NEW_LINE d = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( p [ i ] . x <= 0 ) : NEW_LINE INDENT a += 1 NEW_LINE DEDENT elif ( p [ i ] . x >= 0 ) : NEW_LINE INDENT b += 1 NEW_LINE DEDENT if ( p [ i ] . y <= 0 ) : NEW_LINE INDENT d += 1 NEW_LINE DEDENT DEDENT return min ( min ( a , b ) , min ( c , d ) ) NEW_LINE DEDENT
def minCoins ( coins , m , V ) : NEW_LINE INDENT table = [ 0 for i in range ( V + 1 ) ] NEW_LINE table [ 0 ] = 0 NEW_LINE for i in range ( 1 , V + 1 ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( coins [ j ] <= i ) : NEW_LINE INDENT sub_res = table [ i - coins [ j ] ] NEW_LINE if ( sub_res != Integer . MAX_VALUE and sub_res + 1 < table [ i ] ) : NEW_LINE INDENT table [ i ] = sub_res + 1 NEW_LINE DEDENT DEDENT DEDENT return table [ V ] NEW_LINE DEDENT
def maximumPalinUsingKChanges ( str , k ) : NEW_LINE INDENT palin = [ 0 ] * len ( str ) NEW_LINE ans = " " NEW_LINE l = 0 NEW_LINE r = len ( str ) - 1 NEW_LINE while ( l < r ) : NEW_LINE INDENT if ( str [ l ] != str [ r ] ) : NEW_LINE INDENT palin [ l ] = palin [ r ] = max ( str [ l ] , str [ r ] ) NEW_LINE k -= 1 NEW_LINE DEDENT l += 1 NEW_LINE r -= 1 NEW_LINE DEDENT if ( k < 0 ) : NEW_LINE INDENT return " Not ▁ possible " NEW_LINE DEDENT l = 0 NEW_LINE r = len ( str ) - 1 NEW_LINE while ( l <= r ) : NEW_LINE INDENT if ( k > 0 ) : NEW_LINE INDENT palin [ l ] = '9' NEW_LINE DEDENT DEDENT if ( palin [ l ] < '9' ) : NEW_LINE INDENT if ( k >= 2 and palin [ l ] == str [ l ] and palin [ r ] == str [ r ] ) : NEW_LINE INDENT k -= 2 NEW_LINE palin [ l ] = palin [ r ] = '9' NEW_LINE DEDENT elif ( k >= 1 and ( palin [ l ] != str [ l ] or palin [ r ] != str [ r ] ) : NEW_LINE INDENT k -= 1 NEW_LINE palin [ l ] = palin [ r ] = '9' NEW_LINE DEDENT DEDENT l += 1 NEW_LINE r -= 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def findMinRooms ( slots , n , m ) : NEW_LINE INDENT counts = [ 0 for i in range ( m ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( slots [ i ] [ j ] == '1' ) : NEW_LINE INDENT counts [ j ] += 1 NEW_LINE DEDENT DEDENT max = - 1 NEW_LINE for i in range ( m ) : NEW_LINE INDENT if ( max < counts [ i ] ) : NEW_LINE INDENT max = counts [ i ] NEW_LINE DEDENT DEDENT return max NEW_LINE DEDENT
def printMaxSum ( arr , n ) : NEW_LINE INDENT dp = [ 0 ] * n NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT dp [ i ] = arr [ i ] NEW_LINE maxi = 0 NEW_LINE for j in range ( 1 , int ( m . sqrt ( i + 1 ) + 1 ) ) : NEW_LINE INDENT if ( ( ( i + 1 ) % j == 0 ) and ( i + 1 ) != j ) : NEW_LINE INDENT if ( dp [ j - 1 ] > maxi ) : NEW_LINE INDENT maxi = dp [ j - 1 ] NEW_LINE DEDENT if ( dp [ ( i + 1 ) / j - 1 ] > maxi and j != 1 ) : NEW_LINE INDENT maxi = dp [ ( i + 1 ) / j - 1 ] NEW_LINE DEDENT DEDENT DEDENT dp [ i ] += maxi NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( dp [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def maxAlternateSum ( arr , n ) : NEW_LINE INDENT if ( n == 1 ) : return arr [ 0 ] NEW_LINE DEDENT inc = [ 0 for i in range ( n ) ] NEW_LINE dec = [ 0 for i in range ( n ) ] NEW_LINE inc [ 0 ] = arr [ 0 ] NEW_LINE flag = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if arr [ j ] > arr [ i ] : NEW_LINE INDENT dec [ i ] = max ( dec [ i ] , inc [ j ] + arr [ i ] ) NEW_LINE flag = 1 NEW_LINE DEDENT elif arr [ j ] < arr [ i ] and flag == 1 : NEW_LINE INDENT inc [ i ] = max ( inc [ i ] , dec [ j ] + arr [ i ] ) NEW_LINE DEDENT DEDENT DEDENT result = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if result < inc [ i ] : NEW_LINE INDENT result = inc [ i ] NEW_LINE DEDENT if result < dec [ i ] : NEW_LINE INDENT result = dec [ i ] NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def printRepeating ( arr , size ) : NEW_LINE INDENT print ( " Repeated ▁ Elements ▁ are ▁ : " ) NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT for j in range ( i + 1 , size ) : NEW_LINE INDENT if ( arr [ i ] == arr [ j ] ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
def minProduct ( arr , n , k ) : NEW_LINE INDENT pq = PriorityQueue ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT pq . put ( arr [ i ] ) NEW_LINE DEDENT count = 0 NEW_LINE ans = 1 NEW_LINE while ( not pq . empty ( ) and count < k ) : NEW_LINE INDENT ans = ans * pq . element ( ) NEW_LINE pq . get ( ) NEW_LINE count += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def largest ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE return arr [ n - 1 ] NEW_LINE DEDENT
def exponential ( n , x ) : NEW_LINE INDENT sum = 1 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT sum = sum + x * sum / i NEW_LINE DEDENT return sum NEW_LINE DEDENT
def firstElement ( arr , n , k ) : NEW_LINE INDENT count_map = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT a = 0 NEW_LINE if count_map [ arr [ i ] ] != None : NEW_LINE INDENT a = count_map [ arr [ i ] ] NEW_LINE DEDENT count_map [ arr [ i ] ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if count_map [ arr [ i ] ] == k : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def maxProd ( n ) : NEW_LINE INDENT if ( n == 2 or n == 3 ) : NEW_LINE INDENT return ( n - 1 ) NEW_LINE DEDENT res = 1 NEW_LINE while ( n > 4 ) : NEW_LINE INDENT n -= 3 NEW_LINE res = res * 3 NEW_LINE DEDENT return ( n * res ) NEW_LINE DEDENT
def maxSum ( grid , n ) : NEW_LINE INDENT incl = max ( grid [ 0 ] [ 0 ] , grid [ 1 ] [ 0 ] ) NEW_LINE excl = 0 NEW_LINE excl_new = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT excl_new = max ( excl , incl ) NEW_LINE incl = excl + max ( grid [ 0 ] [ i ] , grid [ 1 ] [ i ] ) NEW_LINE excl = excl_new NEW_LINE DEDENT return max ( excl , incl ) NEW_LINE DEDENT
def countRotations ( arr , low , high ) : NEW_LINE INDENT if ( high < low ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( high == low ) : NEW_LINE INDENT return low NEW_LINE DEDENT mid = low + ( high - low ) // 2 NEW_LINE if ( mid < high and arr [ mid + 1 ] < arr [ mid ] ) : NEW_LINE INDENT return ( mid + 1 ) NEW_LINE DEDENT if ( mid > low and arr [ mid ] < arr [ mid - 1 ] ) : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( arr [ high ] > arr [ mid ] ) : NEW_LINE INDENT return countRotations ( arr , low , mid - 1 ) NEW_LINE DEDENT return countRotations ( arr , mid + 1 , high ) NEW_LINE DEDENT
def findSum ( n ) : NEW_LINE INDENT ans = 0 NEW_LINE temp = 0 NEW_LINE num = 1 NEW_LINE while ( i <= n and temp < n ) : NEW_LINE INDENT temp = i - 1 NEW_LINE num = 1 NEW_LINE while ( temp < n ) : NEW_LINE INDENT if ( temp + i <= n ) : NEW_LINE INDENT ans += ( i * num ) NEW_LINE DEDENT else : NEW_LINE INDENT ans += ( ( n - temp ) * num ) NEW_LINE DEDENT temp += i NEW_LINE num += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def checkCorrectOrNot ( s ) : NEW_LINE INDENT count1 = [ 0 ] * MAX_CHAR NEW_LINE count2 = [ 0 ] * MAX_CHAR NEW_LINE n = len ( s ) NEW_LINE if ( n == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT for i in range ( 0 , n - 1 , - 1 ) : NEW_LINE INDENT count1 [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE count2 [ ord ( s [ j ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( 0 , MAX_CHAR ) : NEW_LINE INDENT if ( count1 [ i ] != count2 [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def divSum ( n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 2 , int ( m . sqrt ( n ) + 1 ) ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT result += i NEW_LINE DEDENT else : NEW_LINE INDENT result += ( i + n / i ) NEW_LINE DEDENT DEDENT DEDENT return ( result + n + 1 ) NEW_LINE DEDENT
def rotateMatrix ( mat ) : NEW_LINE INDENT for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT
def printSpiral ( mat , r , c ) : NEW_LINE INDENT a = 0 NEW_LINE b = 2 NEW_LINE low_row = 0 NEW_LINE low_column = 0 NEW_LINE if ( 0 > a ) : NEW_LINE INDENT a = 0 NEW_LINE DEDENT b = 2 NEW_LINE low_row = 0 NEW_LINE low_column = 0 NEW_LINE if ( 0 > b ) : NEW_LINE INDENT b = b - 1 NEW_LINE DEDENT while ( ( low_row > 0 - r and low_column > 0 - c ) : NEW_LINE INDENT for i in range ( low_column + 1 , high_column < c ) : NEW_LINE INDENT print ( mat [ low_row ] [ i ] , end = " ▁ " ) NEW_LINE low_row -= 1 NEW_LINE DEDENT for i in range ( low_row + 2 , high_row and i < r and high_column < c ) : NEW_LINE INDENT print ( mat [ i ] [ high_column ] , end = " ▁ " ) NEW_LINE high_column += 1 NEW_LINE DEDENT for i in range ( high_column - 2 , low_column >= 0 and high_row < r , - 1 ) : NEW_LINE INDENT print ( mat [ high_row ] [ i ] , end = " ▁ " ) NEW_LINE high_row += 1 NEW_LINE DEDENT for i in range ( high_row - 2 , low_row , - 1 ) : NEW_LINE INDENT print ( mat [ i ] [ low_column ] , end = " ▁ " ) NEW_LINE low_column -= 1 NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT
def countSeq ( n ) : NEW_LINE INDENT nCr = 1 NEW_LINE res = 1 NEW_LINE for r in range ( 1 , n + 1 ) : NEW_LINE INDENT nCr = ( nCr * ( n + 1 - r ) ) / r NEW_LINE res += nCr * nCr NEW_LINE DEDENT return res NEW_LINE DEDENT
def areaOctagon ( side ) : NEW_LINE INDENT return ( float ) ( 2 * ( 1 + math . sqrt ( 2 ) ) * side * side ) NEW_LINE DEDENT
def findLongestConseqSubseq ( arr , n ) : NEW_LINE INDENT s = Set ( ) NEW_LINE for ele in arr : NEW_LINE INDENT s . add ( ele ) NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] in s ) : NEW_LINE INDENT j = arr [ i ] NEW_LINE while ( j in s ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT ans = max ( ans , j - arr [ i ] ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def printSuperSeq ( a , b ) : NEW_LINE INDENT m = len ( a ) NEW_LINE n = len ( b ) NEW_LINE dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT dp [ i ] [ j ] = j NEW_LINE DEDENT elif j == 0 : NEW_LINE INDENT dp [ i ] [ j ] = i NEW_LINE DEDENT elif a [ i - 1 ] == b [ j - 1 ] : NEW_LINE INDENT dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = 1 + min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT res = " " NEW_LINE i = m NEW_LINE j = n NEW_LINE while i > 0 and j > 0 : NEW_LINE INDENT if a [ i - 1 ] == b [ j - 1 ] : NEW_LINE INDENT res = a [ i - 1 ] + res NEW_LINE i -= 1 NEW_LINE j -= 1 NEW_LINE DEDENT elif dp [ i - 1 ] [ j ] < dp [ i ] [ j - 1 ] : NEW_LINE INDENT res = b [ j - 1 ] + res NEW_LINE j -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT res = b [ j - 1 ] + res NEW_LINE j -= 1 NEW_LINE DEDENT DEDENT while i > 0 : NEW_LINE INDENT res = a [ i - 1 ] + res NEW_LINE i -= 1 NEW_LINE DEDENT while j > 0 : NEW_LINE INDENT res = b [ j - 1 ] + res NEW_LINE j -= 1 NEW_LINE DEDENT print ( res ) NEW_LINE DEDENT
def numberOfPaths ( m , n ) : NEW_LINE INDENT dp = [ 0 for _ in range ( n ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT dp [ j ] = 1 NEW_LINE DEDENT DEDENT return dp [ n - 1 ] NEW_LINE DEDENT
def isPowerOfFour ( n ) : NEW_LINE INDENT count = 0 NEW_LINE x = n & ( n - 1 ) NEW_LINE if ( n > 0 and x == 0 ) : NEW_LINE INDENT while ( n > 1 ) : NEW_LINE INDENT n >>= 1 NEW_LINE count += 1 NEW_LINE DEDENT return ( count % 2 == 0 ) ? 1 : 0 NEW_LINE DEDENT
def sumofoddFactors ( n ) : NEW_LINE INDENT res = 1 NEW_LINE while n % 2 == 0 : NEW_LINE INDENT n = n / 2 NEW_LINE DEDENT for i in range ( 3 , int ( m . sqrt ( n ) + 1 ) ) : NEW_LINE INDENT count = 0 NEW_LINE curr_sum = 1 NEW_LINE curr_term = 1 NEW_LINE while n % i == 0 : NEW_LINE INDENT count += 1 NEW_LINE n = n / i NEW_LINE curr_term = curr_term * i NEW_LINE curr_sum += curr_term NEW_LINE DEDENT res = res * curr_sum NEW_LINE DEDENT if n >= 2 : NEW_LINE INDENT res = res * ( 1 + n ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def findElement ( arr , n ) : NEW_LINE INDENT leftMax = [ 0 for x in range ( n ) ] NEW_LINE leftMax [ 0 ] = - float ( ' inf ' ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT leftMax [ i ] = max ( leftMax [ i - 1 ] , arr [ i - 1 ] ) NEW_LINE DEDENT rightMin = sys . maxsize NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( leftMax [ i ] < arr [ i ] and rightMin > arr [ i ] ) : NEW_LINE INDENT return i NEW_LINE DEDENT rightMin = min ( rightMin , arr [ i ] ) NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def search ( arr , l , h , key ) : NEW_LINE INDENT if ( l > h ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = ( l + h ) // 2 NEW_LINE if ( arr [ mid ] == key ) : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( arr [ l ] <= arr [ mid ] ) : NEW_LINE INDENT if ( key >= arr [ l ] and key <= arr [ mid ] ) : NEW_LINE INDENT return search ( arr , l , mid - 1 , key ) NEW_LINE DEDENT return search ( arr , mid + 1 , h , key ) NEW_LINE DEDENT if ( key >= arr [ mid ] and key <= arr [ h ] ) : NEW_LINE INDENT return search ( arr , mid + 1 , h , key ) NEW_LINE DEDENT return search ( arr , l , mid - 1 , key ) NEW_LINE DEDENT
def exponentiation ( base , exp ) : NEW_LINE INDENT if ( exp == 0 ) : return 1 NEW_LINE if ( exp == 1 ) : return base % N NEW_LINE t = exponentiation ( base , int ( exp / 2 ) ) NEW_LINE t = ( t * t ) % N NEW_LINE if ( exp % 2 == 0 ) : NEW_LINE INDENT return t NEW_LINE DEDENT else : NEW_LINE INDENT return ( ( base % N ) * t ) % N NEW_LINE DEDENT DEDENT
def divisibilityCheck ( arr , n ) : NEW_LINE INDENT s = [ ] NEW_LINE max_ele = - float ( " inf " ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . append ( arr [ i ] ) NEW_LINE max_ele = max ( max_ele , arr [ i ] ) NEW_LINE DEDENT res = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] != 0 : NEW_LINE INDENT for j in range ( arr [ i ] * 2 , max_ele + arr [ i ] ) : NEW_LINE INDENT if s . contains ( j ) : NEW_LINE INDENT res . append ( j ) NEW_LINE DEDENT DEDENT DEDENT list = sorted ( res ) NEW_LINE for temp in list : NEW_LINE INDENT print ( temp , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def printRepeating ( arr , size ) : NEW_LINE INDENT print ( " The ▁ repeating ▁ elements ▁ are ▁ : ▁ " ) NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT if ( arr [ abs ( arr [ i ] ) ] > 0 ) : NEW_LINE INDENT arr [ abs ( arr [ i ] ) ] = - arr [ abs ( arr [ i ] ) ] NEW_LINE DEDENT else : NEW_LINE INDENT print ( abs ( arr [ i ] ) , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def minPalPartion ( str1 ) : NEW_LINE INDENT n = len ( str1 ) NEW_LINE C = [ 0 ] * ( n + 1 ) NEW_LINE P = [ [ False for x in range ( n + 1 ) ] for y in range ( n + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT P [ i ] [ i ] = True NEW_LINE C [ i ] [ i ] = 0 NEW_LINE DEDENT for L in range ( 2 , n + 1 ) : NEW_LINE INDENT for i in range ( n - L + 1 ) : NEW_LINE INDENT j = i + L - 1 NEW_LINE if ( L == 2 ) : NEW_LINE INDENT P [ i ] [ j ] = ( str1 [ i ] == str1 [ j ] ) NEW_LINE DEDENT else : NEW_LINE INDENT P [ i ] [ j ] = ( ( str1 [ i ] == str1 [ j ] ) and P [ i + 1 ] [ j - 1 ] ) NEW_LINE DEDENT if ( P [ i ] [ j ] == True ) : NEW_LINE INDENT C [ i ] [ j ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = sys . maxsize NEW_LINE for k in range ( i , j - 1 ) : NEW_LINE INDENT C [ i ] [ j ] = min ( C [ i ] [ j ] , C [ i ] [ k ] + C [ k + 1 ] [ j ] + 1 ) NEW_LINE DEDENT DEDENT DEDENT return C [ 0 ] [ n - 1 ] NEW_LINE DEDENT
def height ( N ) : NEW_LINE INDENT return math . ceil ( log ( N + 1 ) / math . log ( 2 ) ) - 1 NEW_LINE DEDENT
def checkCount ( arr , n , k ) : NEW_LINE INDENT hash = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] not in hash : NEW_LINE INDENT hash [ arr [ i ] ] = 0 NEW_LINE DEDENT hash [ arr [ i ] ] = hash [ arr [ i ] ] + 1 NEW_LINE DEDENT for x in hash : NEW_LINE INDENT if arr [ i ] > 2 * k : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def removeDuplicates ( S ) : NEW_LINE INDENT n = len ( S ) NEW_LINE if ( n < 2 ) : NEW_LINE INDENT return NEW_LINE DEDENT j = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( S [ j ] != S [ i ] ) : NEW_LINE INDENT j += 1 NEW_LINE S [ j ] = S [ i ] NEW_LINE DEDENT DEDENT print ( S , 0 , j + 1 ) NEW_LINE DEDENT
def thirdLargest ( arr , arr_size ) : NEW_LINE INDENT if arr_size < 3 : NEW_LINE INDENT print ( " ▁ Invalid ▁ Input ▁ " ) NEW_LINE return - 1 NEW_LINE DEDENT first = arr [ 0 ] NEW_LINE second = - 1 NEW_LINE third = - 1 NEW_LINE for i in range ( 1 , arr_size ) : NEW_LINE INDENT if arr [ i ] > first : NEW_LINE INDENT third = second NEW_LINE second = first NEW_LINE first = arr [ i ] NEW_LINE DEDENT elif arr [ i ] > second : NEW_LINE INDENT third = second NEW_LINE second = arr [ i ] NEW_LINE DEDENT elif arr [ i ] > third : NEW_LINE INDENT third = arr [ i ] NEW_LINE DEDENT DEDENT print ( " The ▁ third ▁ Largest ▁ element ▁ is % d " , third ) NEW_LINE DEDENT
def longOddEvenIncSeq ( arr , n ) : NEW_LINE INDENT lioes = [ 0 ] * n NEW_LINE maxLen = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and ( arr [ i ] + arr [ j ] ) % 2 != 0 and lioes [ i ] < lioes [ j ] + 1 ) : NEW_LINE INDENT lioes [ i ] = lioes [ j ] + 1 NEW_LINE DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( maxLen < lioes [ i ] ) : NEW_LINE INDENT maxLen = lioes [ i ] NEW_LINE DEDENT DEDENT return maxLen NEW_LINE DEDENT
def addOne ( x ) : NEW_LINE INDENT return ( - x ) NEW_LINE DEDENT
def getNumStrictMonotone ( len ) : NEW_LINE INDENT DP = [ [ 0 for i in range ( DP_s ) ] for j in range ( DP_s ) ] NEW_LINE for i in range ( len ) : NEW_LINE INDENT for j in range ( 1 , DP_s ) : NEW_LINE INDENT DP [ i ] [ j ] = DP [ i - 1 ] [ j - 1 ] + DP [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT return DP [ len - 1 ] [ DP_s - 1 ] NEW_LINE DEDENT
def binarySearch ( arr , l , r , x ) : NEW_LINE INDENT if ( r >= l ) : NEW_LINE INDENT mid = l + ( r - l ) // 2 NEW_LINE if ( arr [ mid ] == x ) : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( mid > l and arr [ mid - 1 ] == x ) : NEW_LINE INDENT return ( mid - 1 ) NEW_LINE DEDENT if ( mid < r and arr [ mid + 1 ] == x ) : NEW_LINE INDENT return ( mid + 1 ) NEW_LINE DEDENT if ( arr [ mid ] > x ) : NEW_LINE INDENT return binarySearch ( arr , l , mid - 2 , x ) NEW_LINE DEDENT return binarySearch ( arr , mid + 2 , r , x ) NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def bresenham ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT m_new = 2 * ( y2 - y1 ) NEW_LINE slope_error_new = m_new - ( x2 - x1 ) NEW_LINE for x in range ( x1 , y1 + 1 ) : NEW_LINE INDENT print ( " ( " , x , " , y ) " ) NEW_LINE slope_error_new += m_new NEW_LINE if ( slope_error_new >= 0 ) : NEW_LINE INDENT y += 1 NEW_LINE slope_error_new -= 2 * ( x2 - x1 ) NEW_LINE DEDENT DEDENT DEDENT
def maxRevenue ( m , x , revenue , n , t ) : NEW_LINE INDENT maxRev = [ 0 ] * ( m + 1 ) NEW_LINE for i in range ( 0 , m + 1 ) : NEW_LINE INDENT maxRev [ i ] = 0 NEW_LINE DEDENT nxtbb = 0 NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT if ( nxtbb < n ) : NEW_LINE INDENT if ( x [ nxtbb ] != i ) : NEW_LINE INDENT maxRev [ i ] = maxRev [ i - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT maxRev [ i ] = max ( maxRev [ i - t - 1 ] + revenue [ nxtbb ] , maxRev [ i - 1 ] ) NEW_LINE nxtbb += 1 NEW_LINE DEDENT DEDENT DEDENT return maxRev [ m ] NEW_LINE DEDENT
def lineFromPoints ( P , Q ) : NEW_LINE INDENT a = Q . second - P . second NEW_LINE b = P . first - Q . first NEW_LINE c = a * ( P . first ) + b * ( P . second ) NEW_LINE if ( b < 0 ) : NEW_LINE INDENT print ( " The ▁ line ▁ passing ▁ through ▁ points ▁ P ▁ and ▁ Q ▁ is : ▁ " , a , " x ▁ " , b , " y ▁ = ▁ " , c ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " The ▁ line ▁ passing ▁ through ▁ points ▁ P ▁ and ▁ Q ▁ is : ▁ " , a , " x ▁ + ▁ " , b , " y ▁ = " , c ) NEW_LINE DEDENT DEDENT
def findMinX ( num , rem , k ) : NEW_LINE INDENT x = 1 NEW_LINE while ( True ) : NEW_LINE INDENT j = 0 NEW_LINE while ( j < k ) : NEW_LINE INDENT if ( x % num [ j ] != rem [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if ( j == k ) : NEW_LINE INDENT return x NEW_LINE DEDENT x += 1 NEW_LINE DEDENT DEDENT
def find3Numbers ( A , arr_size , sum ) : NEW_LINE INDENT for i in range ( 0 , arr_size - 2 ) : NEW_LINE INDENT for j in range ( i + 1 , arr_size - 1 ) : NEW_LINE INDENT for k in range ( j + 1 , arr_size ) : NEW_LINE INDENT if ( A [ i ] + A [ j ] + A [ k ] == sum ) : NEW_LINE INDENT print ( " Triplet ▁ is " , A [ i ] , ' , ▁ ' , A [ j ] , ' , ▁ ' , A [ k ] ) NEW_LINE return True NEW_LINE DEDENT DEDENT DEDENT DEDENT return False NEW_LINE DEDENT
def KMaxCombinations ( A , B , N , K ) : NEW_LINE INDENT pq = PriorityQueue ( reverse = True ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT pq . put ( A [ i ] + B [ j ] ) NEW_LINE DEDENT DEDENT count = 0 NEW_LINE while ( count < K ) : NEW_LINE INDENT print ( pq . get ( ) ) NEW_LINE pq . get ( ) NEW_LINE count += 1 NEW_LINE DEDENT DEDENT
def numberOfSticks ( x ) : NEW_LINE INDENT return ( 3 * x * ( x + 1 ) ) / 2 NEW_LINE DEDENT
def countSubstringWithEqualEnds ( s ) : NEW_LINE INDENT result = 0 NEW_LINE n = len ( s ) NEW_LINE count = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( 0 , MAX_CHAR ) : NEW_LINE INDENT count [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( 0 , MAX_CHAR ) : NEW_LINE INDENT result += ( count [ i ] * ( count [ i ] + 1 ) // 2 ) NEW_LINE DEDENT return result NEW_LINE DEDENT
def isDivisibleBy7 ( num ) : NEW_LINE INDENT if ( num < 0 ) : NEW_LINE INDENT return isDivisibleBy7 ( - num ) NEW_LINE DEDENT if ( num == 0 or num == 7 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( num < 10 ) : NEW_LINE INDENT return False NEW_LINE DEDENT return isDivisibleBy7 ( num // 10 - 2 * ( num - num // 10 * 10 ) ) NEW_LINE DEDENT
def findRepeatingNumber ( arr , n ) : NEW_LINE INDENT sq = math . sqrt ( n ) NEW_LINE range = ( n / sq ) + 1 NEW_LINE count = [ 0 for i in range ( range ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT count [ ( arr [ i ] - 1 ) / sq ] += 1 NEW_LINE DEDENT selected_block = range - 1 NEW_LINE for i in range ( range - 1 ) : NEW_LINE INDENT if ( count [ i ] > sq ) : NEW_LINE INDENT selected_block = i NEW_LINE break NEW_LINE DEDENT DEDENT m = dict ( ) NEW_LINE for i in range ( range - 1 ) : NEW_LINE INDENT if ( ( selected_block * sq ) < arr [ i ] ) and ( arr [ i ] <= ( ( selected_block + 1 ) * sq ) ) : NEW_LINE INDENT m [ arr [ i ] ] = 1 NEW_LINE if ( m [ arr [ i ] ] == 1 ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT DEDENT return - 1 NEW_LINE DEDENT
def findSDSFunc ( n ) : NEW_LINE INDENT DP = [ 0 ] * ( n + 1 ) NEW_LINE DP [ 0 ] = 0 NEW_LINE DP [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT DP [ i ] = DP [ i // 2 ] NEW_LINE DEDENT else : NEW_LINE INDENT DP [ i ] = DP [ ( i - 1 ) // 2 ] + DP [ ( i + 1 ) // 2 ] NEW_LINE DEDENT DEDENT return DP [ n ] NEW_LINE DEDENT
def recSearch ( arr , l , r , x ) : NEW_LINE INDENT if ( r < l ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( arr [ l ] == x ) : NEW_LINE INDENT return l NEW_LINE DEDENT if ( arr [ r ] == x ) : NEW_LINE INDENT return r NEW_LINE DEDENT return recSearch ( arr , l + 1 , r - 1 , x ) ; NEW_LINE DEDENT
def check ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE if n == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT return ( ( str [ 0 ] - '0' ) % 4 == 0 ) NEW_LINE DEDENT last = ord ( str [ n - 1 ] ) - ord ( '0' ) NEW_LINE second_last = ord ( str [ n - 2 ] ) - ord ( '0' ) NEW_LINE return ( ( second_last * 10 + last ) % 4 == 0 ) NEW_LINE DEDENT
def to_upper ( in ) : NEW_LINE INDENT for i in range ( 0 , len ( in ) ) : NEW_LINE INDENT if ( ' a ' <= in [ i ] and in [ i ] <= ' z ' ) : NEW_LINE INDENT in [ i ] = chr ( in [ i ] - ord ( ' a ' ) + ord ( ' A ' ) ) NEW_LINE DEDENT DEDENT return ' ' . join ( in ) NEW_LINE DEDENT
def remAnagram ( str1 , str2 ) : NEW_LINE INDENT count1 = [ 0 ] * 26 NEW_LINE count2 = [ 0 ] * 26 NEW_LINE for i in range ( len ( str1 ) ) : NEW_LINE INDENT count1 [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( len ( str2 ) ) : NEW_LINE INDENT count2 [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT result = 0 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT result += abs ( count1 [ i ] - count2 [ i ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT
def sortInWave ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n , 2 ) : NEW_LINE INDENT if ( i > 0 and arr [ i - 1 ] > arr [ i ] ) : NEW_LINE INDENT swap ( arr , i - 1 , i ) NEW_LINE DEDENT if ( i < n - 1 and arr [ i ] < arr [ i + 1 ] ) : NEW_LINE INDENT swap ( arr , i , i + 1 ) NEW_LINE DEDENT DEDENT DEDENT
def getMinNumberForPattern ( seq ) : NEW_LINE INDENT n = len ( seq ) NEW_LINE if ( n >= 9 ) : NEW_LINE INDENT return " - 1" NEW_LINE DEDENT result = [ 0 ] * ( n + 1 ) NEW_LINE count = 1 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT if ( i == n or seq [ i ] == ' I ' ) : NEW_LINE INDENT j = i - 1 NEW_LINE while ( j >= - 1 and seq [ j ] == ' I ' ) : NEW_LINE INDENT result [ j + 1 ] = chr ( ord ( '0' + count ++ ) ) NEW_LINE if ( j >= 0 and seq [ j ] == ' I ' ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT DEDENT return string ( result ) NEW_LINE DEDENT
def isPossible ( string , n ) : NEW_LINE INDENT len = len ( string ) NEW_LINE if ( len >= n ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def center ( x1 , x2 , y1 , y2 ) : NEW_LINE INDENT print ( "Center ▁ " , ( float ) ( x1 + x2 ) / 2 ) NEW_LINE DEDENT
def findMin ( V ) : NEW_LINE INDENT ans = [ ] NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT while ( V >= deno [ i ] ) : NEW_LINE INDENT V -= deno [ i ] NEW_LINE ans . append ( deno [ i ] ) NEW_LINE DEDENT DEDENT for i in range ( len ( ans ) ) : NEW_LINE INDENT print ( " ▁ " , ans [ i ] ) NEW_LINE DEDENT DEDENT
def mulmod ( a , b , mod ) : NEW_LINE INDENT res = 0 NEW_LINE a = a % mod NEW_LINE while ( b > 0 ) : NEW_LINE INDENT if ( b % 2 == 1 ) : NEW_LINE INDENT res = ( res + a ) % mod NEW_LINE DEDENT a = ( a * 2 ) % mod NEW_LINE b = int ( b / 2 ) NEW_LINE DEDENT return res % mod NEW_LINE DEDENT
def Dragon_Curve_Sequence ( n ) : NEW_LINE INDENT s = "1" NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT temp = "1" NEW_LINE prev = '1' NEW_LINE zero = '0' NEW_LINE one = '1' NEW_LINE for j in range ( len ( s ) ) : NEW_LINE INDENT temp += s [ j ] NEW_LINE if ( prev == '0' ) : NEW_LINE INDENT temp += one NEW_LINE prev = one NEW_LINE DEDENT else : NEW_LINE INDENT temp += zero NEW_LINE prev = zero NEW_LINE DEDENT DEDENT s = temp NEW_LINE DEDENT return s NEW_LINE DEDENT
def minInitialPoints ( points , R , C ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( C ) ] for j in range ( R ) ] NEW_LINE m = R NEW_LINE n = C NEW_LINE if ( points [ m - 1 ] [ n - 1 ] > 0 ) : NEW_LINE INDENT dp [ m - 1 ] [ n - 1 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ n - 1 ] = abs ( points [ m - 1 ] [ n - 1 ] ) + 1 NEW_LINE DEDENT for i in range ( m - 2 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT min_points_on_exit = min ( dp [ i + 1 ] [ j ] , dp [ i ] [ j + 1 ] ) NEW_LINE dp [ i ] [ j ] = max ( min_points_on_exit - points [ i ] [ j ] , 1 ) NEW_LINE DEDENT DEDENT return dp [ 0 ] [ 0 ] NEW_LINE DEDENT
def findRepeating ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT return sum - ( ( ( n - 1 ) * n ) // 2 ) NEW_LINE DEDENT
def getSecondMostFreq ( str1 ) : NEW_LINE INDENT count = [ 0 ] * NO_OF_CHARS NEW_LINE for i in range ( len ( str1 ) ) : NEW_LINE INDENT ( count [ ord ( str1 [ i ] ) - 97 ] ) += 1 NEW_LINE DEDENT first = 0 NEW_LINE second = 0 NEW_LINE for i in range ( NO_OF_CHARS ) : NEW_LINE INDENT if ( count [ i ] > count [ first ] ) : NEW_LINE INDENT second = first NEW_LINE first = i NEW_LINE DEDENT elif ( count [ i ] > count [ second ] and count [ i ] != count [ first ] ) : NEW_LINE INDENT second = i NEW_LINE DEDENT DEDENT return ( char ) second NEW_LINE DEDENT
def findSum ( str1 , str2 ) : NEW_LINE INDENT t = str1 NEW_LINE str1 = str2 NEW_LINE str2 = t NEW_LINE DEDENT str = " " NEW_LINE n1 = len ( str1 ) NEW_LINE n2 = len ( str2 ) NEW_LINE str1 = list ( str1 ) NEW_LINE str2 = list ( str2 ) NEW_LINE carry = 0 NEW_LINE for i in range ( n1 ) : NEW_LINE INDENT sum = ( ( int ) ( str1 [ i ] - ord ( '0' ) + ( int ) ( str2 [ i ] - ord ( '0' ) + carry ) NEW_LINE str += chr ( sum % 10 + '0' ) NEW_LINE carry = sum // 10 NEW_LINE DEDENT for i in range ( n1 , n2 ) : NEW_LINE INDENT sum = ( ( int ) ( str2 [ i ] ) - ord ( '0' ) + carry ) NEW_LINE str += chr ( sum % 10 + '0' ) NEW_LINE carry = sum // 10 NEW_LINE DEDENT if ( carry > 0 ) : NEW_LINE INDENT str = str + chr ( carry + '0' ) NEW_LINE DEDENT str = list ( str ) . reverse ( ) NEW_LINE return str NEW_LINE DEDENT
def printNGE ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT next = - 1 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] < arr [ j ] ) : NEW_LINE INDENT next = arr [ j ] NEW_LINE break NEW_LINE DEDENT DEDENT print ( arr [ i ] , " ▁ - - ▁ " , next ) NEW_LINE DEDENT DEDENT
