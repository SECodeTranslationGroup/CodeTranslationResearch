def printPairs ( arr , n ) : NEW_LINE INDENT v = [ ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( abs ( arr [ i ] ) == abs ( arr [ j ] ) ) : NEW_LINE INDENT v . append ( abs ( arr [ i ] ) ) NEW_LINE DEDENT DEDENT DEDENT if ( len ( v ) == 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT sort ( v ) NEW_LINE for i in range ( len ( v ) ) : NEW_LINE INDENT print ( - v [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def findArea ( a , b , c ) : NEW_LINE INDENT if ( a < 0 or b < 0 or c < 0 or ( a + b <= c ) or a + c <= b or b + c <= a ) : NEW_LINE INDENT print ( " Not ▁ a ▁ valid ▁ trianglen " ) NEW_LINE exit ( 0 ) NEW_LINE DEDENT s = ( a + b + c ) / 2 NEW_LINE return math . sqrt ( s * ( s - a ) * ( s - b ) * ( s - c ) ) NEW_LINE DEDENT
def isMajority ( a , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ a [ i ] ] = mp . get ( a [ i ] , 0 ) + 1 NEW_LINE DEDENT for x in mp : NEW_LINE INDENT if ( mp [ x ] >= n // 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def recaman ( n ) : NEW_LINE INDENT if ( n <= 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT s = set ( ) NEW_LINE prev = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT curr = prev - i NEW_LINE if curr < 0 or curr in s : NEW_LINE INDENT curr = prev + i NEW_LINE DEDENT s . add ( curr ) NEW_LINE print ( " % d , ▁ " , curr ) NEW_LINE prev = curr NEW_LINE DEDENT DEDENT
def findLength ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE maxlen = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n , 2 ) : NEW_LINE INDENT length = j - i + 1 NEW_LINE leftsum = 0 NEW_LINE rightsum = 0 NEW_LINE for k in range ( 0 , int ( length / 2 ) ) : NEW_LINE INDENT leftsum += ( ord ( str [ i + k ] ) - ord ( '0' ) ) NEW_LINE rightsum += ( ord ( str [ i + k + length // 2 ] ) - ord ( '0' ) ) NEW_LINE DEDENT if ( leftsum == rightsum and maxlen < length ) : NEW_LINE INDENT maxlen = length NEW_LINE DEDENT DEDENT DEDENT return maxlen NEW_LINE DEDENT
def prevPermutation ( str ) : NEW_LINE INDENT n = len ( str ) - 1 NEW_LINE i = n NEW_LINE while ( i > 0 and str [ i - 1 ] <= str [ i ] ) : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT if ( i <= 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT j = i - 1 NEW_LINE while ( j + 1 <= n and str [ j + 1 ] <= str [ i - 1 ] ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT str [ i - 1 ] , str [ j ] = str [ j ] , str [ i - 1 ] NEW_LINE str [ i - 1 ] = str [ i - 1 ] , str [ j ] NEW_LINE return True NEW_LINE DEDENT
def findSubString ( str , pat ) : NEW_LINE INDENT len1 = len ( str ) NEW_LINE len2 = len ( pat ) NEW_LINE if len1 < len2 : NEW_LINE INDENT print ( " No ▁ such ▁ window ▁ exists " ) NEW_LINE return " " NEW_LINE DEDENT hash_pat = [ 0 ] * ( len2 - 1 ) NEW_LINE hash_str = [ 0 ] * ( len1 ) NEW_LINE start_index = - 1 NEW_LINE min_len = sys . maxsize NEW_LINE count = 0 NEW_LINE for j in range ( len1 ) : NEW_LINE INDENT hash_str [ ord ( str [ j ] ) ] += 1 NEW_LINE DEDENT if ( hash_pat [ ord ( str [ j ] ) ] != 0 and hash_str [ ord ( str [ j ] ) ] <= hash_pat [ ord ( str [ j ] ) ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( count == len2 ) : NEW_LINE INDENT while ( hash_str [ ord ( str [ start ] ) ] > hash_pat [ ord ( str [ start ] ) ] or hash_pat [ ord ( str [ start ] ) ] == 0 ) : NEW_LINE INDENT if ( hash_str [ ord ( str [ start ] ) ] > hash_pat [ ord ( str [ start ] ) ] ) : NEW_LINE INDENT hash_str [ ord ( str [ start ] ) ] -= 1 NEW_LINE DEDENT start += 1 NEW_LINE DEDENT len_window = j - start + 1 NEW_LINE if ( min_len > len_window ) : NEW_LINE INDENT min_len = len_window NEW_LINE start_index = start NEW_LINE DEDENT DEDENT DEDENT if ( start_index == - 1 ) : NEW_LINE INDENT print ( " No ▁ such ▁ window ▁ exists " ) NEW_LINE return " " NEW_LINE DEDENT
def shuffle ( card , n ) : NEW_LINE INDENT srand ( time ( 0 ) ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT r = i + ( rand ( ) % ( 52 - i ) ) NEW_LINE card [ i ] , card [ r ] = card [ r ] , card [ i ] NEW_LINE DEDENT DEDENT
def removeConsecutiveSame ( v ) : NEW_LINE INDENT st = [ ] NEW_LINE for i in range ( len ( v ) ) : NEW_LINE INDENT if ( len ( st ) == 0 ) : NEW_LINE INDENT st . append ( v [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT st . pop ( ) NEW_LINE DEDENT else : NEW_LINE INDENT st . append ( v [ i ] ) NEW_LINE DEDENT DEDENT return len ( st ) NEW_LINE DEDENT
def find ( list1 , list2 ) : NEW_LINE INDENT res = [ ] NEW_LINE max_possible_sum = len ( list1 ) + len ( list2 ) - 2 NEW_LINE for sum in range ( max_possible_sum + 1 ) : NEW_LINE INDENT for i in range ( sum + 1 ) : NEW_LINE INDENT if ( i < len ( list1 ) and ( sum - i ) < len ( list2 ) and list1 [ i ] == list2 [ sum - i ] ) : NEW_LINE INDENT res . append ( list1 [ i ] ) NEW_LINE DEDENT DEDENT if ( len ( res ) > 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT for i in range ( 0 , len ( res ) ) : NEW_LINE INDENT print ( res [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT
def getLevenstein ( inp ) : NEW_LINE INDENT revInput = inp . read ( ) NEW_LINE n = len ( inp ) NEW_LINE dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT dp [ 0 ] [ i ] = i NEW_LINE dp [ i ] [ 0 ] = i NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( inp [ i - 1 ] == revInput [ j - 1 ] ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = 1 + min ( { dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] } ) NEW_LINE DEDENT DEDENT DEDENT res = float ( ' inf ' ) NEW_LINE for i in range ( n , - 1 , - 1 ) : NEW_LINE INDENT res = min ( res , dp [ i ] [ j ] ) NEW_LINE if ( i < n ) : NEW_LINE INDENT res = min ( res , dp [ i + 1 ] [ j ] ) NEW_LINE DEDENT if ( i > 0 ) : NEW_LINE INDENT res = min ( res , dp [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def countDistinct ( arr , k , n ) : NEW_LINE INDENT hm = dict ( ) NEW_LINE dist_count = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT if ( hm [ arr [ i ] ] == 0 ) : NEW_LINE INDENT dist_count += 1 NEW_LINE DEDENT hm [ arr [ i ] ] += 1 NEW_LINE DEDENT print ( dist_count ) NEW_LINE for i in range ( k , n ) : NEW_LINE INDENT if ( hm [ arr [ i - k ] ] == 1 ) : NEW_LINE INDENT dist_count -= 1 NEW_LINE DEDENT hm [ arr [ i - k ] ] -= 1 NEW_LINE if ( hm [ arr [ i ] ] == 0 ) : NEW_LINE INDENT dist_count += 1 NEW_LINE DEDENT hm [ arr [ i ] ] += 1 NEW_LINE print ( dist_count ) NEW_LINE DEDENT DEDENT
def lcs ( dp , arr1 , n , arr2 , m , k ) : NEW_LINE INDENT if ( k < 0 ) : NEW_LINE INDENT return - 1e7 NEW_LINE DEDENT if ( n < 0 or m < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = dp [ n ] [ m ] [ k ] NEW_LINE if ( ans != - 1 ) : NEW_LINE INDENT return ans NEW_LINE DEDENT ans = max ( lcs ( dp , arr1 , n - 1 , arr2 , m , k ) , lcs ( dp , arr1 , n , arr2 , m - 1 , k ) ) NEW_LINE if ( arr1 [ n - 1 ] == arr2 [ m - 1 ] ) : NEW_LINE INDENT ans = max ( ans , 1 + lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k ) ) NEW_LINE DEDENT ans = max ( ans , 1 + lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k - 1 ) ) NEW_LINE return ans NEW_LINE DEDENT
def printDivisors ( n ) : NEW_LINE INDENT v = [ ] NEW_LINE for i in range ( 1 , int ( m . sqrt ( n ) + 1 ) ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT if n / i == i : NEW_LINE INDENT print ( " % d ▁ " , i ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " % d ▁ " , i ) NEW_LINE v . append ( n / i ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( len ( v ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( v [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def largestSubset ( a , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE dp = [ 0 ] * ( n + 1 ) NEW_LINE dp [ n - 1 ] = 1 NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT mxm = 0 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( a [ j ] % a [ i ] == 0 ) : NEW_LINE INDENT mxm = max ( mxm , dp [ j ] ) NEW_LINE DEDENT DEDENT dp [ i ] = 1 + mxm NEW_LINE DEDENT return max ( dp , dp + n ) NEW_LINE DEDENT
def encodedChar ( str , k ) : NEW_LINE INDENT expand = " " NEW_LINE temp = " " NEW_LINE freq = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT temp = " " NEW_LINE freq = 0 NEW_LINE while ( i < len ( str ) and str [ i ] != ' \0' ) : NEW_LINE INDENT temp . append ( chr ( ord ( str [ i ] ) ) NEW_LINE i += 1 NEW_LINE DEDENT while ( str [ i ] >= '1' and str [ i ] <= '9' ) : NEW_LINE INDENT freq = freq * 10 + ord ( str [ i ] ) - ord ( '0' ) NEW_LINE i += 1 NEW_LINE DEDENT for j in range ( 1 , freq + 1 ) : NEW_LINE INDENT expand . append ( temp ) NEW_LINE DEDENT DEDENT if ( freq == 0 ) : NEW_LINE INDENT expand . append ( temp ) NEW_LINE DEDENT return expand [ k - 1 ] NEW_LINE DEDENT
def countNum ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE count = 0 NEW_LINE maxm = INT_MIN NEW_LINE minm = INT_MAX NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . add ( arr [ i ] ) NEW_LINE if arr [ i ] < minm : NEW_LINE INDENT minm = arr [ i ] NEW_LINE DEDENT if arr [ i ] > maxm : NEW_LINE INDENT maxm = arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( minm , maxm + 1 ) : NEW_LINE INDENT if arr [ i ] not in s : NEW_LINE INDENT s . add ( arr [ i ] ) NEW_LINE DEDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def countPairs ( arr , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] = mp . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT ans = 0 NEW_LINE for key , values in mp . items ( ) : NEW_LINE INDENT count = values NEW_LINE ans += ( count * ( count - 1 ) ) / 2 NEW_LINE DEDENT return int ( ans ) NEW_LINE DEDENT
def decimalToBinary ( num , k_prec ) : NEW_LINE INDENT binary = " " NEW_LINE Integral = num NEW_LINE fractional = num - Integral NEW_LINE while ( Integral ) : NEW_LINE INDENT rem = Integral % 2 NEW_LINE binary . append ( rem + '0' ) NEW_LINE Integral /= 2 NEW_LINE DEDENT binary . reverse ( ) NEW_LINE binary . append ( ' . ' ) NEW_LINE while ( k_prec -= 1 ) : NEW_LINE INDENT fractional *= 2 NEW_LINE fract_bit = fractional NEW_LINE if ( fract_bit == 1 ) : NEW_LINE INDENT fractional -= fract_bit NEW_LINE binary . append ( 1 + '0' ) NEW_LINE DEDENT else : NEW_LINE INDENT binary . append ( 0 + '0' ) NEW_LINE DEDENT DEDENT return binary NEW_LINE DEDENT
def evaluateBoolExpr ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE for i in range ( 0 , n , 2 ) : NEW_LINE INDENT if ( s [ i + 1 ] == ' A ' ) : NEW_LINE INDENT if ( s [ i + 2 ] == '0' or s [ i ] == '0' ) : NEW_LINE INDENT s [ i + 2 ] = '0' NEW_LINE DEDENT else : NEW_LINE INDENT s [ i + 2 ] = '1' NEW_LINE DEDENT DEDENT elif ( s [ i + 1 ] == ' B ' ) : NEW_LINE INDENT if ( s [ i + 2 ] == '1' or s [ i ] == '1' ) : NEW_LINE INDENT s [ i + 2 ] = '1' NEW_LINE DEDENT else : NEW_LINE INDENT s [ i + 2 ] = '0' NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( s [ i + 2 ] == s [ i ] ) : NEW_LINE INDENT s [ i + 2 ] = '0' NEW_LINE DEDENT else : NEW_LINE INDENT s [ i + 2 ] = '1' NEW_LINE DEDENT DEDENT DEDENT return s [ n - 1 ] - '0' NEW_LINE DEDENT
def minSwaps ( arr , n ) : NEW_LINE INDENT arrPos = [ None ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT arrPos [ i ] . first = arr [ i ] NEW_LINE arrPos [ i ] . second = i NEW_LINE DEDENT arrPos . sort ( ) NEW_LINE vis = [ False ] * ( n + 1 ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( vis [ i ] or arrPos [ i ] . second == i ) : NEW_LINE INDENT continue NEW_LINE DEDENT cycle_size = 0 NEW_LINE j = i NEW_LINE while ( vis [ j ] == 0 ) : NEW_LINE INDENT vis [ j ] = 1 NEW_LINE j = arrPos [ j ] . second NEW_LINE cycle_size += 1 NEW_LINE DEDENT if ( cycle_size > 0 ) : NEW_LINE INDENT ans += ( cycle_size - 1 ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def minimumBox ( arr , n ) : NEW_LINE INDENT q = Queue ( ) NEW_LINE arr . sort ( ) NEW_LINE q . put ( arr [ 0 ] ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT now = q . get ( ) NEW_LINE if arr [ i ] >= 2 * now : NEW_LINE INDENT q . get ( ) NEW_LINE DEDENT q . put ( arr [ i ] ) NEW_LINE DEDENT return len ( q ) NEW_LINE DEDENT
def convertOpposite ( str ) : NEW_LINE INDENT ln = len ( str ) NEW_LINE for i in range ( ln ) : NEW_LINE INDENT if ( str [ i ] >= ' a ' and str [ i ] <= ' z ' ) : NEW_LINE INDENT str [ i ] = str [ i ] - 32 NEW_LINE DEDENT elif ( str [ i ] >= ' A ' and str [ i ] <= ' Z ' ) : NEW_LINE INDENT str [ i ] = str [ i ] + 32 NEW_LINE DEDENT DEDENT DEDENT
def findRepeating ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] not in s : NEW_LINE INDENT s . add ( arr [ i ] ) NEW_LINE DEDENT DEDENT for i in s : NEW_LINE INDENT if arr [ i ] not in s : NEW_LINE INDENT s . add ( arr [ i ] ) NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def transpose ( A ) : NEW_LINE INDENT for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT t = A [ i ] [ j ] NEW_LINE A [ j ] [ i ] = t NEW_LINE DEDENT DEDENT DEDENT
def printSubsequences ( Str ) : NEW_LINE INDENT n = len ( Str ) NEW_LINE opsize = ( int ) ( math . pow ( 2 , n - 1 ) ) NEW_LINE for counter in range ( 0 , opsize ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT print ( Str [ j ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT
def printRoman ( number ) : NEW_LINE INDENT num = [ 1 , 4 , 5 , 9 , 10 , 40 , 50 , 90 , 100 , 400 , 500 , 900 , 1000 ] NEW_LINE sym = [ " I " , " IV " , " V " , " IX " , " X " , " XL " , " L " , " XC " , " C " , " CD " , " D " , " CM " , " M " ] NEW_LINE i = 12 NEW_LINE while ( number > 0 ) : NEW_LINE INDENT div = number // num [ i ] NEW_LINE number = number % num [ i ] NEW_LINE while ( div > 0 ) : NEW_LINE INDENT print ( sym [ i ] , end = " " ) NEW_LINE i -= 1 NEW_LINE DEDENT DEDENT
def findTriplet ( a1 , a2 , a3 , n1 , n2 , n3 , sum ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( 0 , n1 ) : NEW_LINE INDENT s . add ( a1 [ i ] ) NEW_LINE DEDENT for i in range ( 0 , n2 ) : NEW_LINE INDENT for j in range ( 0 , n3 ) : NEW_LINE INDENT if ( sum - a2 [ i ] - a3 [ j ] ) in s : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT
def check ( s ) : NEW_LINE INDENT if ( len ( s ) >= 10 ) : NEW_LINE INDENT return True NEW_LINE DEDENT for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT for j in range ( i + 1 , len ( s ) ) : NEW_LINE INDENT for k in range ( j + 1 , len ( s ) ) : NEW_LINE INDENT s1 = s [ 0 ] NEW_LINE s2 = s [ i , j - i ] NEW_LINE s3 = s [ j , k - j ] NEW_LINE s4 = s [ k , len ( s ) - k ] NEW_LINE if ( s1 != s2 and s1 != s3 and s1 != s4 and s2 != s3 and s2 != s4 and s3 != s4 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT DEDENT return False NEW_LINE DEDENT
def bitonicGenerator ( arr , n ) : NEW_LINE INDENT i = 1 NEW_LINE j = n - 1 NEW_LINE if ( j % 2 != 0 ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT while ( i < j ) : NEW_LINE INDENT arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ] NEW_LINE i += 2 NEW_LINE j -= 2 NEW_LINE DEDENT arr . sort ( ) NEW_LINE DEDENT
def splitString ( str ) : NEW_LINE INDENT alpha = " " NEW_LINE num = [ ] NEW_LINE special = [ ] NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( num . endswith ( str [ i ] ) ) : NEW_LINE INDENT num . append ( str [ i ] ) NEW_LINE DEDENT elif ( ( str [ i ] >= ' A ' and str [ i ] <= ' Z ' ) or ( str [ i ] >= ' a ' and str [ i ] <= ' z ' ) ) : NEW_LINE INDENT alpha . append ( str [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT special . append ( str [ i ] ) NEW_LINE DEDENT DEDENT print ( alpha ) NEW_LINE print ( num ) NEW_LINE print ( special ) NEW_LINE DEDENT
def binaryMedian ( m , r , c ) : NEW_LINE INDENT min = 2147483647 NEW_LINE max = 2147483647 NEW_LINE for i in range ( r ) : NEW_LINE INDENT if ( m [ i ] [ 0 ] < min ) : NEW_LINE INDENT min = m [ i ] [ 0 ] NEW_LINE DEDENT if ( m [ i ] [ c - 1 ] > max ) : NEW_LINE INDENT max = m [ i ] [ c - 1 ] NEW_LINE DEDENT desired = ( r * c + 1 ) / 2 NEW_LINE while ( min < max ) : NEW_LINE INDENT mid = min + ( max - min ) // 2 NEW_LINE place = 0 NEW_LINE for i in range ( r ) : NEW_LINE INDENT place += upper_bound ( m [ i ] , m [ i ] + c , mid ) - m [ i ] NEW_LINE DEDENT if ( place < desired ) : NEW_LINE INDENT min = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT max = mid NEW_LINE DEDENT DEDENT return min NEW_LINE DEDENT
def printDuplicates ( arr , n ) : NEW_LINE INDENT freq = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ arr [ i ] ] = freq . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT dup = False NEW_LINE for key , values in freq . items ( ) : NEW_LINE INDENT if values > 1 : NEW_LINE INDENT print ( key , end = " ▁ " ) NEW_LINE dup = True NEW_LINE DEDENT DEDENT if dup == False : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT DEDENT
def stoogesort ( arr , l , h ) : NEW_LINE INDENT if l >= h : NEW_LINE INDENT return NEW_LINE DEDENT if arr [ l ] > arr [ h ] : NEW_LINE INDENT arr [ l ] , arr [ h ] = arr [ h ] , arr [ l ] NEW_LINE DEDENT if h - l + 1 > 2 : NEW_LINE INDENT t = ( h - l + 1 ) // 3 NEW_LINE stoogesort ( arr , l , h - t ) NEW_LINE stoogesort ( arr , l + t , h ) NEW_LINE stoogesort ( arr , l , h - t ) NEW_LINE DEDENT DEDENT
def printEqualModNumbers ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE d = arr [ n - 1 ] - arr [ 0 ] NEW_LINE v = [ ] NEW_LINE for i in range ( 1 , d - 1 ) : NEW_LINE INDENT if ( d % i == 0 ) : NEW_LINE INDENT v . append ( i ) NEW_LINE if ( i != d // i ) : NEW_LINE INDENT v . append ( d // i ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( 0 , len ( v ) ) : NEW_LINE INDENT temp = arr [ 0 ] % v [ i ] NEW_LINE j = 1 NEW_LINE while ( j < n ) : NEW_LINE INDENT if ( arr [ j ] % v [ i ] != temp ) : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if ( j == n ) : NEW_LINE INDENT print ( v [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
def recursiveReverse ( str ) : NEW_LINE INDENT st = [ ] NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT st . append ( str [ i ] ) NEW_LINE DEDENT for i in range ( len ( str ) ) : NEW_LINE INDENT str [ i ] = st [ - 1 ] NEW_LINE st . pop ( ) NEW_LINE DEDENT DEDENT
def printRect ( X , Y , n ) : NEW_LINE INDENT Xmax = max ( X , X + n ) NEW_LINE Xmin = min ( X , X + n ) NEW_LINE Ymax = max ( Y , Y + n ) NEW_LINE Ymin = min ( Y , Y + n ) NEW_LINE print ( " { " , Xmin , " , ▁ " , Ymin , " } " , endl ) NEW_LINE print ( " { " , Xmin , " , ▁ " , Ymax , " } " , endl ) NEW_LINE print ( " { " , Xmax , " , ▁ " , Ymax , " } " , endl ) NEW_LINE print ( " { " , Xmax , " , ▁ " , Ymin , " } " , endl ) NEW_LINE DEDENT
def NFG ( a , n , freq ) : NEW_LINE INDENT s = [ ] NEW_LINE res = [ 0 ] * n NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if freq [ a [ s [ - 1 ] ] > freq [ a [ i ] ] : NEW_LINE INDENT s . append ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT while freq [ a [ s [ - 1 ] ] < freq [ a [ i ] ] and len ( s ) != 0 : NEW_LINE INDENT res [ s [ - 1 ] ] = a [ i ] NEW_LINE s . pop ( ) NEW_LINE DEDENT s . append ( i ) NEW_LINE DEDENT DEDENT while len ( s ) != 0 : NEW_LINE INDENT res [ s [ - 1 ] ] = - 1 NEW_LINE s . pop ( ) NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( res [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def printEqualSumSets ( arr , n ) : NEW_LINE INDENT Sum = sum ( arr ) NEW_LINE if Sum & 1 : NEW_LINE INDENT print ( " - 1" ) NEW_LINE return NEW_LINE DEDENT k = Sum >> 1 NEW_LINE dp = [ [ False for i in range ( k + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT dp [ 0 ] [ i ] = False NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for currSum in range ( 1 , k + 1 ) : NEW_LINE INDENT dp [ i ] [ currSum ] = dp [ i - 1 ] [ currSum ] NEW_LINE if arr [ i - 1 ] <= currSum : NEW_LINE INDENT dp [ i ] [ currSum ] = dp [ i ] [ currSum ] | dp [ i - 1 ] [ currSum - arr [ i - 1 ] ] NEW_LINE DEDENT DEDENT DEDENT i = n NEW_LINE currSum = k NEW_LINE while i > 0 and currSum >= 0 : NEW_LINE INDENT if dp [ i - 1 ] [ currSum ] : NEW_LINE INDENT i -= 1 NEW_LINE set2 . append ( arr [ i ] ) NEW_LINE DEDENT elif dp [ i - 1 ] [ currSum - arr [ i - 1 ] ] : NEW_LINE INDENT i -= 1 NEW_LINE currSum -= arr [ i ] NEW_LINE DEDENT set1 = list ( set1 ) NEW_LINE for i in range ( len ( set1 ) ) : NEW_LINE INDENT print ( set1 [ i ] , end = " ▁ " ) NEW_LINE DEDENT print ( " Set ▁ 2 ▁ elements : ▁ " ) NEW_LINE for i in range ( len ( set2 ) ) : NEW_LINE INDENT print ( set2 [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def reverseStr ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE i = 0 NEW_LINE j = n - 1 NEW_LINE while ( i < j ) : NEW_LINE INDENT str [ i ] , str [ j ] = str [ j ] , str [ i ] NEW_LINE i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT DEDENT
def minimizeWithKSwaps ( arr , n , k ) : NEW_LINE INDENT for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( k > 0 ) : NEW_LINE INDENT pos = i NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( j - i > k ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( arr [ j ] < arr [ pos ] ) : NEW_LINE INDENT pos = j NEW_LINE DEDENT DEDENT for j in range ( pos , i , - 1 ) : NEW_LINE INDENT t = arr [ j ] NEW_LINE arr [ j ] = arr [ j - 1 ] NEW_LINE arr [ j - 1 ] = t NEW_LINE DEDENT k = k - pos - i NEW_LINE DEDENT DEDENT DEDENT
def countSubarrays ( arr , n ) : NEW_LINE INDENT difference = 0 NEW_LINE ans = 0 NEW_LINE hash_positive = [ 0 ] * ( n + 1 ) NEW_LINE hash_negative = [ 0 ] * ( n + 1 ) NEW_LINE fill_n ( hash_positive , n + 1 , 0 ) NEW_LINE fill_n ( hash_negative , n + 1 , 0 ) NEW_LINE hash_positive [ 0 ] = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] & 1 == 1 ) : NEW_LINE INDENT difference += 1 NEW_LINE DEDENT else : NEW_LINE INDENT difference -= 1 NEW_LINE DEDENT if ( difference < 0 ) : NEW_LINE INDENT ans += hash_negative [ - difference ] NEW_LINE hash_negative [ - difference ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += hash_positive [ difference ] NEW_LINE hash_positive [ difference ] += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def findPairs ( arr , n ) : NEW_LINE INDENT Hash = dict ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT Sum = arr [ i ] + arr [ j ] NEW_LINE if ( Sum in Hash ) : NEW_LINE INDENT Hash [ Sum ] = make_pair ( i , j ) NEW_LINE DEDENT else : NEW_LINE INDENT pp = Hash [ Sum ] NEW_LINE print ( " ( " , arr [ pp [ 0 ] , " , ▁ " , arr [ pp [ 1 ] , " ) and ▁ ( " , arr [ i ] , " , ▁ " , arr [ j ] , " ) n " ) NEW_LINE return True NEW_LINE DEDENT DEDENT DEDENT print ( " No ▁ pairs ▁ found " ) NEW_LINE return False NEW_LINE DEDENT
def check ( s1 , s2 ) : NEW_LINE INDENT n = len ( s1 ) NEW_LINE m = len ( s2 ) NEW_LINE dp = [ [ False for i in range ( m + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( m + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = False NEW_LINE DEDENT DEDENT dp [ 0 ] [ 0 ] = True NEW_LINE for i in range ( len ( s1 ) ) : NEW_LINE INDENT for j in range ( len ( s2 ) ) : NEW_LINE INDENT if ( dp [ i ] [ j ] ) : NEW_LINE INDENT if ( j < len ( s2 ) and ( toupper ( s1 [ i ] ) == s2 [ j ] ) ) : NEW_LINE INDENT dp [ i + 1 ] [ j + 1 ] = True NEW_LINE DEDENT if ( not isupper ( s1 [ i ] ) ) : NEW_LINE INDENT dp [ i + 1 ] [ j ] = True NEW_LINE DEDENT DEDENT DEDENT DEDENT return ( dp [ n ] [ m ] ) NEW_LINE DEDENT
def checkDuplicatesWithinK ( arr , n , k ) : NEW_LINE INDENT myset = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] in myset : NEW_LINE INDENT return True NEW_LINE DEDENT myset . add ( arr [ i ] ) NEW_LINE if i >= k : NEW_LINE INDENT myset . remove ( arr [ i - k ] ) NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def minOperation ( arr , n ) : NEW_LINE INDENT Hash = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT Hash [ arr [ i ] ] = Hash . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT max_count = 0 NEW_LINE for i in Hash : NEW_LINE INDENT if ( max_count < i ) : NEW_LINE INDENT max_count = i NEW_LINE DEDENT DEDENT return ( n - max_count ) NEW_LINE DEDENT
def findSum ( str ) : NEW_LINE INDENT temp = " " NEW_LINE sum = 0 NEW_LINE for ch in str : NEW_LINE INDENT if ( isdigit ( ch ) ) : NEW_LINE INDENT temp += ch NEW_LINE DEDENT else : NEW_LINE INDENT sum += int ( temp ) NEW_LINE temp = " " NEW_LINE DEDENT DEDENT return sum + int ( temp ) NEW_LINE DEDENT
def mostFrequent ( arr , n ) : NEW_LINE INDENT Hash = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT Hash [ arr [ i ] ] = Hash . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT max_count = 0 NEW_LINE res = - 1 NEW_LINE for i in Hash : NEW_LINE INDENT if ( max_count < i ) : NEW_LINE INDENT res = i NEW_LINE max_count = i NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def firstLetterWord ( str ) : NEW_LINE INDENT result = " " NEW_LINE v = True NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] == ' ▁ ' ) : NEW_LINE INDENT v = True NEW_LINE DEDENT elif ( str [ i ] != ' ▁ ' and v == True ) : NEW_LINE INDENT result = result + list ( str [ i ] ) NEW_LINE v = False NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def decode ( str ) : NEW_LINE INDENT integerstack = [ ] NEW_LINE stringstack = [ ] NEW_LINE temp = " " NEW_LINE result = " " NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT count = 0 NEW_LINE if ( str [ i ] >= '0' and str [ i ] <= '9' ) : NEW_LINE INDENT while ( str [ i ] >= '0' and str [ i ] <= '9' ) : NEW_LINE INDENT count = count * 10 + ord ( str [ i ] ) - ord ( '0' ) NEW_LINE i += 1 NEW_LINE DEDENT integerstack . append ( count ) NEW_LINE DEDENT elif ( str [ i ] == ' [ ' ) : NEW_LINE INDENT temp = " " NEW_LINE count = 0 NEW_LINE if ( len ( stringstack ) != 0 and stringstack [ - 1 ] != ' [ ' ) : NEW_LINE INDENT temp = stringstack [ - 1 ] + temp NEW_LINE stringstack . pop ( ) NEW_LINE DEDENT for j in range ( count ) : NEW_LINE INDENT result = result + temp NEW_LINE DEDENT for j in range ( len ( result ) ) : NEW_LINE INDENT stringstack . append ( result [ j ] ) NEW_LINE DEDENT result = " " NEW_LINE DEDENT elif ( str [ i ] == ' [ ' ) : NEW_LINE INDENT if ( str [ i - 1 ] >= '0' and str [ i - 1 ] <= '9' ) : NEW_LINE INDENT stringstack . append ( str [ i ] ) NEW_LINE integerstack . append ( 1 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT stringstack . append ( str [ i ] ) NEW_LINE DEDENT DEDENT while ( len ( stringstack ) != 0 ) : NEW_LINE INDENT result = stringstack [ - 1 ] + result NEW_LINE stringstack . pop ( ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def minSum ( A , n ) : NEW_LINE INDENT min_val = min ( A ) NEW_LINE return ( min_val * ( n - 1 ) ) NEW_LINE DEDENT
def countWords ( str , n ) : NEW_LINE INDENT mp = defaultdict ( lambda : 0 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ str [ i ] ] += 1 NEW_LINE DEDENT res = 0 NEW_LINE for key , values in mp . items ( ) : NEW_LINE INDENT if values == 2 : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def sortUsingHash ( a , n ) : NEW_LINE INDENT max1 = max ( a ) NEW_LINE hash = [ 0 for i in range ( max1 + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT hash [ a [ i ] ] = hash [ a [ i ] ] + 1 NEW_LINE DEDENT for i in range ( max1 + 1 ) : NEW_LINE INDENT if ( hash [ i ] ) : NEW_LINE INDENT for j in range ( hash [ i ] ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def isDivisible ( str , k ) : NEW_LINE INDENT n = len ( str ) NEW_LINE c = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT if ( str [ n - i - 1 ] == '0' ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT return ( c == k ) NEW_LINE DEDENT
def divisible ( num ) : NEW_LINE INDENT n = len ( num ) NEW_LINE sum = int ( accumulate ( num ) , end ( num ) , 0 ) - '0' * 1 NEW_LINE if ( sum % 3 == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( sum % 3 == ( num [ i ] - '0' ) % 3 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT if ( n == 2 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return 2 NEW_LINE DEDENT
def reverse ( str ) : NEW_LINE INDENT if ( len ( str ) == 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT str = list ( str ) NEW_LINE print ( str [ 0 ] , end = " " ) NEW_LINE DEDENT
def isDvisibleBy12 ( num ) : NEW_LINE INDENT if ( len ( num ) >= 3 ) : NEW_LINE INDENT d1 = ord ( num [ len ( num ) - 1 ] ) NEW_LINE if ( d1 % 2 != 0 ) : NEW_LINE INDENT return ( 0 ) NEW_LINE DEDENT d2 = ord ( num [ len ( num ) - 2 ] ) NEW_LINE sum = 0 NEW_LINE for i in range ( len ( num ) ) : NEW_LINE INDENT sum += num [ i ] NEW_LINE DEDENT return ( sum % 3 == 0 and ( d2 * 10 + d1 ) % 4 == 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT number = ord ( num ) NEW_LINE return ( number % 12 == 0 ) NEW_LINE DEDENT DEDENT
def xorZero ( str ) : NEW_LINE INDENT one_count = 0 NEW_LINE zero_count = 0 NEW_LINE n = len ( str ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( str [ i ] == '1' ) : NEW_LINE INDENT one_count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT zero_count += 1 NEW_LINE DEDENT DEDENT if ( one_count % 2 == 0 ) : NEW_LINE INDENT return zero_count NEW_LINE DEDENT return one_count NEW_LINE DEDENT
def nthRoot ( A , N ) : NEW_LINE INDENT xPre = rand ( ) % 10 NEW_LINE eps = 1e - 3 NEW_LINE delX = sys . maxsize NEW_LINE xK = ( ( N - 1.0 ) * xPre + ( double ) A / pow ( xPre , N - 1 ) ) / ( double ) N NEW_LINE delX = abs ( xK - xPre ) NEW_LINE xPre = xK NEW_LINE DEDENT return xK NEW_LINE DEDENT
def findLeft ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE while ( n > 0 ) : NEW_LINE INDENT if ( str [ n ] == ' d ' ) : NEW_LINE INDENT str = list ( str ) NEW_LINE break NEW_LINE DEDENT if ( str [ n ] == ' b ' ) : NEW_LINE INDENT str = list ( str ) NEW_LINE break NEW_LINE DEDENT if ( str [ n ] == ' a ' ) : NEW_LINE INDENT str = list ( str ) NEW_LINE break NEW_LINE DEDENT if ( str [ n ] == ' b ' ) : NEW_LINE INDENT str = ' b ' NEW_LINE DEDENT elif ( str [ n ] == ' c ' ) : NEW_LINE INDENT str = ' d ' NEW_LINE DEDENT DEDENT return str NEW_LINE DEDENT
def minRange ( arr , n , k ) : NEW_LINE INDENT l = 0 NEW_LINE r = n NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = set ( ) NEW_LINE j = i NEW_LINE for j in range ( n ) : NEW_LINE INDENT s . add ( arr [ j ] ) NEW_LINE if ( len ( s ) == k ) : NEW_LINE INDENT if ( ( j - i ) < ( r - l ) ) : NEW_LINE INDENT r = j NEW_LINE l = i NEW_LINE DEDENT break NEW_LINE DEDENT DEDENT if ( j == n ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( l == 0 and r == n ) : NEW_LINE INDENT print ( " Invalid ▁ k " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( l , " ▁ " , r ) NEW_LINE DEDENT DEDENT
def findSum ( A , B , n ) : NEW_LINE INDENT Hash = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT Hash [ A [ i ] ] = Hash . get ( A [ i ] , 0 ) + 1 NEW_LINE Hash [ B [ i ] ] = Hash . get ( B [ i ] , 0 ) + 1 NEW_LINE DEDENT sum = 0 NEW_LINE for x in Hash : NEW_LINE INDENT if ( Hash [ x ] == 1 ) : NEW_LINE INDENT sum += x NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def arrayEvenAndOdd ( arr , n ) : NEW_LINE INDENT i = - 1 NEW_LINE j = 0 NEW_LINE while ( j != n ) : NEW_LINE INDENT if ( arr [ j ] % 2 == 0 ) : NEW_LINE INDENT i += 1 NEW_LINE arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ] NEW_LINE DEDENT j += 1 NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def containsOdd ( G , src ) : NEW_LINE INDENT colorArr = [ 0 ] * V NEW_LINE for i in range ( V ) : NEW_LINE INDENT colorArr [ i ] = - 1 NEW_LINE DEDENT colorArr [ src ] = 1 NEW_LINE q = queue . Queue ( ) NEW_LINE q . put ( src ) NEW_LINE while ( not q . empty ( ) ) : NEW_LINE INDENT u = q . get ( ) NEW_LINE if ( G [ u ] [ u ] == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT for v in range ( V ) : NEW_LINE INDENT if ( G [ u ] [ v ] and colorArr [ v ] == - 1 ) : NEW_LINE INDENT colorArr [ v ] = 1 - colorArr [ u ] NEW_LINE q . put ( v ) NEW_LINE DEDENT elif ( G [ u ] [ v ] and colorArr [ v ] == colorArr [ u ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT
def getMinSquares ( n ) : NEW_LINE INDENT if ( ( math . sqrt ( n ) - floor ( math . sqrt ( n ) ) == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return n NEW_LINE DEDENT res = n NEW_LINE for x in range ( 1 , n + 1 ) : NEW_LINE INDENT temp = x * x NEW_LINE if ( temp > n ) : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT res = min ( res , 1 + getMinSquares ( n - temp ) ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def selectRandom ( x ) : NEW_LINE INDENT res = x NEW_LINE count = 0 NEW_LINE if ( count == 1 ) : NEW_LINE INDENT res = x NEW_LINE DEDENT else : NEW_LINE INDENT i = rand ( ) % count NEW_LINE if ( i == count - 1 ) : NEW_LINE INDENT res = x NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def cost ( a , n ) : NEW_LINE INDENT return ( n - 1 ) * ( min_element ( a , a + n ) ) NEW_LINE DEDENT
def gnomeSort ( arr , n ) : NEW_LINE INDENT index = 0 NEW_LINE while ( index < n ) : NEW_LINE INDENT if ( index == 0 ) : NEW_LINE INDENT index += 1 NEW_LINE DEDENT if ( arr [ index ] >= arr [ index - 1 ] ) : NEW_LINE INDENT index += 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ index ] , arr [ index - 1 ] = arr [ index - 1 ] , arr [ index ] NEW_LINE index -= 1 NEW_LINE DEDENT DEDENT return NEW_LINE DEDENT
def sortedAfterSwap ( A , B , n ) : NEW_LINE INDENT for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( B [ i ] ) : NEW_LINE INDENT if ( A [ i ] != i + 1 ) : NEW_LINE INDENT t = A [ i ] NEW_LINE A [ i ] = t NEW_LINE DEDENT DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( A [ i ] != i + 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def moveSpaceInFront ( str ) : NEW_LINE INDENT i = len ( str ) NEW_LINE for j in range ( i , len ( str ) - 1 ) : NEW_LINE INDENT if ( str [ j ] != ' ▁ ' ) : NEW_LINE INDENT str [ i ] = str [ j ] NEW_LINE i -= 1 NEW_LINE DEDENT DEDENT while ( i >= 0 ) : NEW_LINE INDENT str [ i ] = ' ▁ ' NEW_LINE DEDENT DEDENT
def countOfBinaryNumberLessThanN ( N ) : NEW_LINE INDENT q = queue . Queue ( ) NEW_LINE q . put ( 1 ) NEW_LINE cnt = 0 NEW_LINE t = 0 NEW_LINE while ( not q . empty ( ) ) : NEW_LINE INDENT t = q . get ( ) NEW_LINE if ( t <= N ) : NEW_LINE INDENT cnt += 1 NEW_LINE q . put ( t * 10 ) NEW_LINE q . put ( t * 10 + 1 ) NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT
def substringConversions ( str , k , b ) : NEW_LINE INDENT i = 0 NEW_LINE sum = 0 NEW_LINE counter = k - 1 NEW_LINE for i in range ( k ) : NEW_LINE INDENT sum = sum + ( ( ord ( str [ i ] ) - ord ( '0' ) ) * pow ( b , counter ) ) NEW_LINE counter -= 1 NEW_LINE DEDENT print ( sum , end = " ▁ " ) NEW_LINE prev = sum NEW_LINE sum = 0 NEW_LINE counter = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT sum = prev - ( ( ord ( str [ i - k ] ) - ord ( '0' ) ) * pow ( b , k - 1 ) ) NEW_LINE sum = sum * b NEW_LINE sum = sum + ( ord ( str [ i ] ) - ord ( '0' ) ) NEW_LINE print ( sum , end = " ▁ " ) NEW_LINE prev = sum NEW_LINE counter += 1 NEW_LINE DEDENT DEDENT
def longestRepeatedSubSeq ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE dp = [ [ 0 for x in range ( n + 1 ) ] for y in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( str [ i - 1 ] == str [ j - 1 ] and i != j ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT res = " " NEW_LINE i = n NEW_LINE j = n NEW_LINE while ( i > 0 and j > 0 ) : NEW_LINE INDENT if ( dp [ i ] [ j ] == dp [ i - 1 ] [ j - 1 ] + 1 ) : NEW_LINE INDENT res = res + str [ i - 1 ] NEW_LINE i -= 1 NEW_LINE j -= 1 NEW_LINE DEDENT elif ( dp [ i ] [ j ] == dp [ i - 1 ] [ j ] ) : NEW_LINE INDENT i -= 1 NEW_LINE j -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def rearrange ( a , size ) : NEW_LINE INDENT positive = 0 NEW_LINE negative = 1 NEW_LINE while ( positive < size and a [ positive ] >= 0 ) : NEW_LINE INDENT positive += 2 NEW_LINE DEDENT while ( negative < size and a [ negative ] <= 0 ) : NEW_LINE INDENT negative += 2 NEW_LINE DEDENT if ( positive < size and negative < size ) : NEW_LINE INDENT a [ positive ] , a [ negative ] = a [ negative ] , a [ positive ] NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT
def bubbleSort ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE for i in arr : NEW_LINE INDENT for j in arr : NEW_LINE INDENT if arr [ j ] > arr [ j + 1 ] : NEW_LINE INDENT arr [ j ] , arr [ j + 1 ] = arr [ j + 1 ] , arr [ j ] NEW_LINE DEDENT DEDENT DEDENT
def reversingString ( str , start , end ) : NEW_LINE INDENT while ( start < end ) : NEW_LINE INDENT str [ start ] ^= str [ end ] NEW_LINE str [ end ] ^= str [ start ] NEW_LINE str [ start ] ^= str [ end ] NEW_LINE start += 1 NEW_LINE end -= 1 NEW_LINE DEDENT return str NEW_LINE DEDENT
def minimalSteps ( s , n ) : NEW_LINE INDENT dp = [ None ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp [ i ] = sys . maxsize NEW_LINE DEDENT s1 = " " NEW_LINE s2 = " " NEW_LINE dp [ 0 ] = 1 NEW_LINE s1 += s [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT s1 += s [ i ] NEW_LINE s2 = s . substr ( i + 1 , i + 1 ) NEW_LINE dp [ i ] = min ( dp [ i ] , dp [ i - 1 ] + 1 ) NEW_LINE if ( s1 == s2 ) : NEW_LINE INDENT dp [ i * 2 + 1 ] = min ( dp [ i ] + 1 , dp [ i * 2 + 1 ] ) NEW_LINE DEDENT DEDENT return dp [ n - 1 ] NEW_LINE DEDENT
def MinimumCost ( cost , n , W ) : NEW_LINE INDENT val = [ ] NEW_LINE wt = [ ] NEW_LINE size = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( cost [ i ] != - 1 ) : NEW_LINE INDENT val . append ( cost [ i ] ) NEW_LINE wt . append ( i + 1 ) NEW_LINE size += 1 NEW_LINE DEDENT DEDENT n = size NEW_LINE min_cost = [ [ INF for i in range ( W + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT min_cost [ 0 ] [ i ] = INF NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , W + 1 ) : NEW_LINE INDENT if ( wt [ i - 1 ] > j ) : NEW_LINE INDENT min_cost [ i ] [ j ] = min_cost [ i - 1 ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT min_cost [ i ] [ j ] = min ( min_cost [ i - 1 ] [ j ] , min_cost [ i ] [ j - wt [ i - 1 ] ] + val [ i - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return - 1 if ( min_cost [ n ] [ W ] == INF ) else min_cost [ n ] [ W ] NEW_LINE DEDENT
def bitonicGenerator ( arr , n ) : NEW_LINE INDENT evenArr = [ 0 ] * n NEW_LINE oddArr = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( not ( i % 2 ) ) : NEW_LINE INDENT evenArr . append ( arr [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT oddArr . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT evenArr . sort ( reverse = True ) NEW_LINE for j in range ( len ( evenArr ) ) : NEW_LINE INDENT arr [ i ] = evenArr [ j ] NEW_LINE DEDENT for j in range ( len ( oddArr ) ) : NEW_LINE INDENT arr [ i ] = oddArr [ j ] NEW_LINE DEDENT DEDENT
def printFirstRepeating ( arr , n ) : NEW_LINE INDENT min = - 1 NEW_LINE myset = set ( ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if arr [ i ] in myset : NEW_LINE INDENT min = i NEW_LINE DEDENT else : NEW_LINE INDENT myset . add ( arr [ i ] ) NEW_LINE DEDENT DEDENT if ( min != - 1 ) : NEW_LINE INDENT print ( " The ▁ first ▁ repeating ▁ element ▁ is " , arr [ min ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " There ▁ are ▁ no ▁ repeating ▁ elements " ) NEW_LINE DEDENT DEDENT
def lps ( str1 ) : NEW_LINE INDENT n = len ( str1 ) NEW_LINE L = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT L [ i ] [ i ] = 1 NEW_LINE DEDENT for cl in range ( 2 , n + 1 ) : NEW_LINE INDENT for i in range ( n - cl + 1 ) : NEW_LINE INDENT j = i + cl - 1 NEW_LINE if ( str1 [ i ] == str1 [ j ] and cl == 2 ) : NEW_LINE INDENT L [ i ] [ j ] = 2 NEW_LINE DEDENT elif ( str1 [ i ] == str1 [ j ] ) : NEW_LINE INDENT L [ i ] [ j ] = L [ i + 1 ] [ j - 1 ] + 2 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] = max ( L [ i ] [ j - 1 ] , L [ i + 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return L [ 0 ] [ n - 1 ] NEW_LINE DEDENT
def censor ( text , word ) : NEW_LINE INDENT word_list = [ ] NEW_LINE text = list ( text ) NEW_LINE result = " " NEW_LINE stars = " " NEW_LINE for i in range ( len ( word ) ) : NEW_LINE INDENT stars += ' * ' NEW_LINE DEDENT index = 0 NEW_LINE for i in range ( len ( word_list ) ) : NEW_LINE INDENT if ( i == word [ 0 ] ) : NEW_LINE INDENT word_list [ index ] = stars NEW_LINE DEDENT index += 1 NEW_LINE DEDENT for i in word_list : NEW_LINE INDENT if ( i == word ) : NEW_LINE INDENT word_list [ index ] = stars NEW_LINE DEDENT index += 1 NEW_LINE DEDENT for i in word_list : NEW_LINE INDENT result += i + ' ▁ ' NEW_LINE DEDENT return result NEW_LINE DEDENT
def isRotated ( str1 , str2 ) : NEW_LINE INDENT if ( len ( str1 ) != len ( str2 ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT clock_rot = " " NEW_LINE anticlock_rot = " " NEW_LINE l = len ( str2 ) NEW_LINE anticlock_rot = anticlock_rot + str2 [ l - 2 , 2 ] + str2 [ 0 , l - 2 ] NEW_LINE clock_rot = clock_rot + str2 [ 2 ] + str2 [ 0 , 2 ] NEW_LINE return ( str1 == str2 [ 0 ] or str1 == str2 [ 1 ] ) NEW_LINE DEDENT
def findDiff ( arr , n ) : NEW_LINE INDENT hm = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT hm [ arr [ i ] ] = hm . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT max_count = 0 NEW_LINE min_count = n NEW_LINE for x in hm : NEW_LINE INDENT max_count = max ( max_count , x ) NEW_LINE min_count = min ( min_count , x ) NEW_LINE DEDENT return ( max_count - min_count ) NEW_LINE DEDENT
def playGame ( arr , n ) : NEW_LINE INDENT Hash = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT Hash . add ( arr [ i ] ) NEW_LINE DEDENT return ( len ( Hash ) % 2 == 0 ? 1 : 2 ) NEW_LINE DEDENT
def subset ( arr , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] = mp . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT res = 0 NEW_LINE for x in mp : NEW_LINE INDENT res = max ( res , x ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def isProduct ( arr , n , x ) : NEW_LINE INDENT if ( n < 2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT s = set ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] == 0 ) : NEW_LINE INDENT if ( x == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT continue NEW_LINE DEDENT DEDENT if ( x % arr [ i ] == 0 ) : NEW_LINE INDENT if ( x // arr [ i ] ) in s : NEW_LINE INDENT return True NEW_LINE DEDENT s . add ( arr [ i ] ) NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def findRotations ( str ) : NEW_LINE INDENT tmp = str + str NEW_LINE n = len ( str ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT substring = tmp [ i : i + len ( str ) ] NEW_LINE if ( str == substring ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return n NEW_LINE DEDENT
def randomize ( arr , n ) : NEW_LINE INDENT srand ( time ( NULL ) ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT j = rand ( ) % ( i + 1 ) NEW_LINE arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ] NEW_LINE DEDENT DEDENT
def translate ( st ) : NEW_LINE INDENT l = len ( st ) NEW_LINE if ( l < 2 ) : NEW_LINE INDENT return NEW_LINE DEDENT i = 0 NEW_LINE j = 0 NEW_LINE while ( j < l - 1 ) : NEW_LINE INDENT if ( st [ j ] == ' A ' and st [ j + 1 ] == ' B ' ) : NEW_LINE INDENT j = j + 2 NEW_LINE str [ i ] = ' C ' NEW_LINE continue NEW_LINE DEDENT str [ i ] = st [ j ] NEW_LINE j += 1 NEW_LINE DEDENT if ( j == l - 1 ) : NEW_LINE INDENT st [ i ] = st [ j ] NEW_LINE DEDENT st [ i ] = ' ' NEW_LINE DEDENT
def numberofways ( A , B , N , M ) : NEW_LINE INDENT pos = [ ] NEW_LINE for i in range ( M ) : NEW_LINE INDENT pos [ B [ i ] ] . append ( i + 1 ) NEW_LINE DEDENT dpl = [ [ 0 for i in range ( M + 2 ) ] for j in range ( N + 2 ) ] NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( 1 , M + 1 ) : NEW_LINE INDENT if ( A [ i - 1 ] == B [ j - 1 ] ) : NEW_LINE INDENT dpl [ i ] [ j ] = dpl [ i - 1 ] [ j - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT dpl [ i ] [ j ] = max ( dpl [ i - 1 ] [ j ] , dpl [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT LCS = dpl [ N ] [ M ] NEW_LINE dpr = [ dpr [ N + 2 ] [ M + 2 ] NEW_LINE for i in range ( N , 1 , - 1 ) : NEW_LINE INDENT for j in range ( M , 1 , - 1 ) : NEW_LINE INDENT if ( A [ i - 1 ] == B [ j - 1 ] ) : NEW_LINE INDENT dpr [ i ] [ j ] = dpr [ i + 1 ] [ j + 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT dpr [ i ] [ j ] = max ( dpr [ i + 1 ] [ j ] , dpr [ i ] [ j + 1 ] ) NEW_LINE DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT for j in range ( MAX ) : NEW_LINE INDENT for x in pos : NEW_LINE INDENT for l in range ( MAX ) : NEW_LINE INDENT if ( dpl [ i ] [ x - 1 ] + dpr [ i + 1 ] [ x + 1 ] == LCS ) : NEW_LINE INDENT ans += 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def substringConversions ( str , k , b ) : NEW_LINE INDENT for i in range ( 0 , len ( str ) , k ) : NEW_LINE INDENT sub = str [ i : i + k ] NEW_LINE sum = 0 NEW_LINE counter = 0 NEW_LINE for i in range ( len ( sub ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT sum = sum + ( int ) ( ( sub [ i ] ) - ord ( '0' ) ) * pow ( b , counter ) ) NEW_LINE counter = counter + 1 NEW_LINE DEDENT print ( sum , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT
def SumOfKsubArray ( arr , n , k ) : NEW_LINE INDENT sum = 0 NEW_LINE s = deque ( k ) NEW_LINE G = deque ( k ) NEW_LINE i = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT while ( len ( S ) != 0 and arr [ S [ - 1 ] ] >= arr [ i ] ) : NEW_LINE INDENT S . popleft ( ) NEW_LINE DEDENT while ( len ( G ) != 0 and arr [ G [ - 1 ] ] <= arr [ i ] ) : NEW_LINE INDENT G . popleft ( ) NEW_LINE DEDENT G . append ( i ) NEW_LINE S . append ( i ) NEW_LINE DEDENT for i in range ( k , n ) : NEW_LINE INDENT sum += arr [ S [ - 1 ] ] + arr [ G [ - 1 ] ] NEW_LINE while ( len ( S ) != 0 and S [ - 1 ] <= i - k ) : NEW_LINE INDENT S . popleft ( ) NEW_LINE DEDENT while ( len ( G ) != 0 and arr [ G [ - 1 ] ] >= arr [ i ] ) : NEW_LINE INDENT G . popleft ( ) NEW_LINE DEDENT while ( len ( S ) != 0 and arr [ S [ - 1 ] ] <= arr [ i ] ) : NEW_LINE INDENT S . popleft ( ) NEW_LINE DEDENT while ( len ( G ) != 0 and arr [ G [ - 1 ] ] <= arr [ i ] ) : NEW_LINE INDENT G . popleft ( ) NEW_LINE DEDENT G . append ( i ) NEW_LINE S . append ( i ) NEW_LINE S . append ( i ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT sum += arr [ S [ - 1 ] + arr [ G [ - 1 ] NEW_LINE return sum NEW_LINE DEDENT
def arrangeString ( str ) : NEW_LINE INDENT char_count = [ 0 for i in range ( MAX_CHAR ) ] NEW_LINE sum = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] >= ' A ' and str [ i ] <= ' Z ' ) : NEW_LINE INDENT char_count [ ord ( str [ i ] ) - ord ( ' A ' ) ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT sum = sum + ( ord ( str [ i ] ) - ord ( '0' ) ) NEW_LINE DEDENT DEDENT res = " " NEW_LINE for i in range ( MAX_CHAR ) : NEW_LINE INDENT ch = chr ( ord ( ' A ' ) + i ) NEW_LINE while ( char_count [ i ] > 0 ) : NEW_LINE INDENT res = res + chr ( ord ( ' A ' ) + i ) NEW_LINE DEDENT if ( sum > 0 ) : NEW_LINE INDENT res = res + str ( sum ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def waysToIncreaseLCSBy1 ( str1 , str2 ) : NEW_LINE INDENT m = len ( str1 ) NEW_LINE n = len ( str2 ) NEW_LINE position = [ ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT position [ toInt ( str2 [ i - 1 ] ) ] . append ( i ) NEW_LINE DEDENT lcsl = [ [ 0 for i in range ( n + 2 ) ] for j in range ( m + 2 ) ] NEW_LINE lcsr = [ [ 0 for i in range ( m + 2 ) ] * ( n + 2 ) NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( str1 [ i - 1 ] == str2 [ j - 1 ] ) : NEW_LINE INDENT lcsl [ i ] [ j ] = 1 + lcsl [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT lcsl [ i ] [ j ] = max ( lcsl [ i - 1 ] [ j ] , lcsl [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( m , 1 , - 1 ) : NEW_LINE INDENT for j in range ( n , 1 , - 1 ) : NEW_LINE INDENT if ( str1 [ i - 1 ] == str2 [ j - 1 ] ) : NEW_LINE INDENT lcsr [ i ] [ j ] = 1 + lcsr [ i + 1 ] [ j + 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT lcsr [ i ] [ j ] = max ( lcsr [ i + 1 ] [ j ] , lcsr [ i ] [ j + 1 ] ) NEW_LINE DEDENT DEDENT DEDENT ways = 0 NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for c in range ( ' a ' , ' z ' ) : NEW_LINE INDENT for j in range ( position . keys ( ) ) : NEW_LINE INDENT p = position [ toInt ( c ) ] [ j ] NEW_LINE if ( lcsl [ i ] [ p - 1 ] + lcsr [ i + 1 ] [ p + 1 ] == lcsl [ m ] [ n ] ) :
def lis ( arr , n ) : NEW_LINE INDENT lis = [ 0 for i in range ( n ) ] NEW_LINE lis [ 0 ] = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT lis [ i ] = 1 NEW_LINE for j in range ( i ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and lis [ i ] < lis [ j ] + 1 ) : NEW_LINE INDENT lis [ i ] = lis [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT return max ( lis , lis + n ) NEW_LINE DEDENT
def SternSequenceFunc ( BrocotSequence , n ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT considered_element = BrocotSequence [ i ] NEW_LINE precedent = BrocotSequence [ i - 1 ] NEW_LINE BrocotSequence . append ( considered_element + precedent ) NEW_LINE BrocotSequence . append ( considered_element ) NEW_LINE DEDENT for i in range ( 0 , 15 ) : NEW_LINE INDENT print ( BrocotSequence [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def printBracketNumber ( exp , n ) : NEW_LINE INDENT left_bnum = 1 NEW_LINE right_bnum = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( exp [ i ] == ' ( ' ) : NEW_LINE INDENT print ( left_bnum , end = " ▁ " ) NEW_LINE right_bnum . append ( left_bnum ) NEW_LINE left_bnum += 1 NEW_LINE DEDENT elif ( exp [ i ] == ' ) ' ) : NEW_LINE INDENT print ( right_bnum [ - 1 ] , end = " ▁ " ) NEW_LINE right_bnum . pop ( ) NEW_LINE DEDENT DEDENT DEDENT
def returnMaxSum ( A , B , n ) : NEW_LINE INDENT mp = set ( ) NEW_LINE result = 0 NEW_LINE curr_sum = 0 NEW_LINE curr_begin = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT while ( A [ curr_begin ] in mp ) : NEW_LINE INDENT mp . remove ( A [ curr_begin ] ) NEW_LINE curr_sum -= B [ curr_begin ] NEW_LINE curr_begin += 1 NEW_LINE DEDENT mp . add ( A [ i ] ) NEW_LINE curr_sum += B [ i ] NEW_LINE result = max ( result , curr_sum ) NEW_LINE DEDENT return result NEW_LINE DEDENT
def rearrange ( arr , n ) : NEW_LINE INDENT i = - 1 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if arr [ j ] < 0 : NEW_LINE INDENT i += 1 NEW_LINE arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ] NEW_LINE DEDENT DEDENT pos = i + 1 NEW_LINE neg = 0 NEW_LINE while pos < n and neg < pos and arr [ neg ] < 0 : NEW_LINE INDENT arr [ neg ] , arr [ pos ] = arr [ pos ] , arr [ neg ] NEW_LINE pos += 1 NEW_LINE neg += 2 NEW_LINE DEDENT DEDENT
def largestGCDSubsequence ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE maxele = max ( arr ) NEW_LINE for i in range ( 2 , maxele + 1 ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if arr [ j ] % i == 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT ans = max ( ans , count ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def isNumber ( s ) : NEW_LINE INDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] . isdigit ( ) == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def countPairs ( arr1 , arr2 , m , n , x ) : NEW_LINE INDENT count = 0 NEW_LINE us = set ( ) NEW_LINE for i in range ( 0 , m ) : NEW_LINE INDENT us . add ( arr1 [ i ] ) NEW_LINE DEDENT for j in range ( 0 , n ) : NEW_LINE INDENT if ( ( x - arr2 [ j ] ) in us ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def lis ( arr , n ) : NEW_LINE INDENT lis = [ 0 for i in range ( n ) ] NEW_LINE lis [ 0 ] = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT lis [ i ] = 1 NEW_LINE for j in range ( i ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and lis [ i ] < lis [ j ] + 1 ) : NEW_LINE INDENT lis [ i ] = lis [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT return max ( lis , lis + n ) NEW_LINE DEDENT
def findSubString ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE dist_count = 0 NEW_LINE visited = [ False ] * MAX_CHARS NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( visited [ ord ( str [ i ] ) ] == False ) : NEW_LINE INDENT visited [ ord ( str [ i ] ) ] = True NEW_LINE dist_count += 1 NEW_LINE DEDENT DEDENT start = 0 NEW_LINE start_index = - 1 NEW_LINE min_len = sys . maxsize NEW_LINE count = 0 NEW_LINE curr_count = [ 0 ] * MAX_CHARS NEW_LINE for j in range ( n ) : NEW_LINE INDENT curr_count [ ord ( str [ j ] ) ] += 1 NEW_LINE if ( curr_count [ ord ( str [ j ] ) ] == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( count == dist_count ) : NEW_LINE INDENT while ( curr_count [ ord ( str [ start ] ) ] > 1 ) : NEW_LINE INDENT if ( curr_count [ ord ( str [ start ] ) ] > 1 ) : NEW_LINE INDENT curr_count [ ord ( str [ start ] ) ] -= 1 NEW_LINE start += 1 NEW_LINE DEDENT DEDENT len_window = j - start + 1 NEW_LINE if ( min_len > len_window ) : NEW_LINE INDENT min_len = len_window NEW_LINE start_index = start NEW_LINE DEDENT DEDENT DEDENT return str [ start_index : start_index + min_len ) NEW_LINE DEDENT
def printSubsequences ( arr , n ) : NEW_LINE INDENT opsize = ( int ) ( math . pow ( 2 , n ) ) NEW_LINE for counter in range ( 1 , opsize ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT if ( ( counter & ( 1 << j ) ) > 0 ) : NEW_LINE INDENT print ( arr [ j ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT
def bin ( n ) : NEW_LINE INDENT if n > 1 : NEW_LINE INDENT bin ( n >> 1 ) NEW_LINE DEDENT print ( n & 1 , end = " " ) NEW_LINE DEDENT
def minimumSquare ( a , b ) : NEW_LINE INDENT result = 0 NEW_LINE rem = 0 NEW_LINE if a < b : NEW_LINE INDENT a , b = a , b NEW_LINE DEDENT while b > 0 : NEW_LINE INDENT result += a // b NEW_LINE rem = a % b NEW_LINE a = b NEW_LINE b = rem NEW_LINE DEDENT return result NEW_LINE DEDENT
def deleteElements ( arr , n , k ) : NEW_LINE INDENT s = [ ] NEW_LINE s . append ( arr [ 0 ] ) NEW_LINE count = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT while ( len ( s ) > 0 and s [ - 1 ] < arr [ i ] and count < k ) : NEW_LINE INDENT s . pop ( ) NEW_LINE count += 1 NEW_LINE DEDENT s . append ( arr [ i ] ) NEW_LINE DEDENT m = len ( s ) NEW_LINE v = [ 0 ] * m NEW_LINE while ( len ( s ) != 0 ) : NEW_LINE INDENT v [ m ] = s [ - 1 ] NEW_LINE s . pop ( ) NEW_LINE DEDENT for x in v : NEW_LINE INDENT print ( x , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT
def first ( str ) : NEW_LINE INDENT for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] . isupper ( ) ) : NEW_LINE INDENT return str [ i ] NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT
def isPossible ( n , index , modulo , M , arr , dp ) : NEW_LINE INDENT modulo = ( ( modulo % M ) + M ) % M NEW_LINE if index == n : NEW_LINE INDENT if ( modulo == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT if dp [ index ] [ modulo ] != - 1 : NEW_LINE INDENT return dp [ index ] [ modulo ] NEW_LINE DEDENT placeAdd = isPossible ( n , index + 1 , modulo + arr [ index ] , M , arr , dp ) NEW_LINE placeMinus = isPossible ( n , index + 1 , modulo - arr [ index ] , M , arr , dp ) NEW_LINE res = placeAdd or placeMinus NEW_LINE dp [ index ] [ modulo ] = res NEW_LINE return res NEW_LINE DEDENT
def amendSentence ( string ) : NEW_LINE INDENT for i in range ( 0 , len ( string ) ) : NEW_LINE INDENT if string [ i ] >= ' A ' and string [ i ] <= ' Z ' : NEW_LINE INDENT string [ i ] = string [ i ] + 32 NEW_LINE if i != 0 : NEW_LINE INDENT print ( " ▁ " , end = " " ) NEW_LINE DEDENT print ( string [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( string [ i ] ) NEW_LINE DEDENT DEDENT DEDENT
def find ( a , b , k , n1 , n2 ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( n2 ) : NEW_LINE INDENT s . add ( b [ i ] ) NEW_LINE DEDENT missing = 0 NEW_LINE for i in range ( n1 ) : NEW_LINE INDENT if ( a [ i ] not in s ) : NEW_LINE INDENT missing += 1 NEW_LINE DEDENT if ( missing == k ) : NEW_LINE INDENT return a [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def countNumber ( n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 1 , 9 + 1 ) : NEW_LINE INDENT s = [ ] NEW_LINE if ( i <= n ) : NEW_LINE INDENT s . append ( i ) NEW_LINE result += 1 NEW_LINE DEDENT while ( len ( s ) != 0 ) : NEW_LINE INDENT tp = s [ - 1 ] NEW_LINE s . pop ( ) NEW_LINE for j in range ( tp % 10 , 9 + 1 ) : NEW_LINE INDENT x = tp * 10 + j NEW_LINE if ( x <= n ) : NEW_LINE INDENT s . append ( x ) NEW_LINE result += 1 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
def getMaxOccuringChar ( str ) : NEW_LINE INDENT count = [ 0 ] * ASCII_SIZE NEW_LINE l = len ( str ) NEW_LINE max = 0 NEW_LINE result = ' ' NEW_LINE for i in range ( l ) : NEW_LINE INDENT count [ ord ( str [ i ] ) ] = count [ ord ( str [ i ] ) ] + 1 NEW_LINE if ( max < count [ ord ( str [ i ] ) ] ) : NEW_LINE INDENT max = count [ ord ( str [ i ] ) ] NEW_LINE result = str [ i ] NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def getMinDiff ( arr , n , k ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT arr . sort ( ) NEW_LINE ans = arr [ n - 1 ] - arr [ 0 ] NEW_LINE small = arr [ 0 ] + k NEW_LINE big = arr [ n - 1 ] - k NEW_LINE if ( small > big ) : NEW_LINE INDENT small = big NEW_LINE DEDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT subtract = arr [ i ] - k NEW_LINE add = arr [ i ] + k NEW_LINE if ( subtract >= small or add <= big ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( big - subtract <= add - small ) : NEW_LINE INDENT small = subtract NEW_LINE DEDENT else : NEW_LINE INDENT big = add NEW_LINE DEDENT DEDENT return min ( ans , big - small ) NEW_LINE DEDENT
def printkthnode ( adj , wt , n , k ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( len ( adj ) >= k ) : NEW_LINE INDENT print ( adj [ i ] [ len ( adj ) - k ] , end = " - 1" ) NEW_LINE DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( len ( adj [ i ] ) >= k ) : NEW_LINE INDENT print ( adj [ i ] [ len ( adj [ i ] ) - k ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT DEDENT DEDENT
def commonCharacters ( Str , n ) : NEW_LINE INDENT prim = [ False for i in range ( MAX_CHAR ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT sec = [ False for i in range ( MAX_CHAR ) ] NEW_LINE for j in range ( len ( Str [ i ] ) ) : NEW_LINE INDENT if ( prim [ ord ( Str [ i ] [ j ] ) - ord ( ' a ' ) ] == 0 ) : NEW_LINE INDENT sec [ ord ( Str [ i ] [ j ] ) - ord ( ' a ' ) ] = True NEW_LINE DEDENT DEDENT DEDENT for i in range ( 26 ) : NEW_LINE INDENT if ( prim [ i ] ) : NEW_LINE INDENT print ( " % c ▁ " , i + ord ( ' a ' ) ) NEW_LINE DEDENT DEDENT DEDENT
def canMakeStr2 ( str1 , str2 ) : NEW_LINE INDENT count = [ 0 for i in range ( 0 , MAX ) ] NEW_LINE for i in range ( len ( str1 ) ) : NEW_LINE INDENT count [ ord ( str1 [ i ] ) ] = count [ ord ( str1 [ i ] ) ] + 1 NEW_LINE DEDENT for i in range ( len ( str2 ) ) : NEW_LINE INDENT if ( count [ ord ( str2 [ i ] ) ] == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT count [ ord ( str2 [ i ] ) ] -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT
def count ( a , b , m , n ) : NEW_LINE INDENT if ( ( m == 0 and n == 0 ) or n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( m == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( a [ m - 1 ] == b [ n - 1 ] ) : NEW_LINE INDENT return count ( a , b , m - 1 , n - 1 ) + count ( a , b , m - 1 , n ) NEW_LINE DEDENT else : NEW_LINE INDENT return count ( a , b , m - 1 , n ) NEW_LINE DEDENT DEDENT
def numofArray ( n , m ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( MAX ) ] for j in range ( MAX ) ] NEW_LINE mu = [ 0 for i in range ( MAX ) ] NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 2 * i , m + 1 ) : NEW_LINE INDENT di [ j ] . append ( i ) NEW_LINE mu [ i ] . append ( j ) NEW_LINE DEDENT di [ i ] . append ( i ) NEW_LINE DEDENT for i in range ( 1 , m + 1 ) : NEW_LINE INDENT dp [ 1 ] [ i ] = 1 NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , m + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = 0 NEW_LINE for x in di : NEW_LINE INDENT dp [ i ] [ j ] += dp [ i - 1 ] [ x ] NEW_LINE DEDENT for x in mu [ j ] : NEW_LINE INDENT dp [ i ] [ j ] += dp [ i - 1 ] [ x ] NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT ans += dp [ n ] [ i ] NEW_LINE di [ i ] . clear ( ) NEW_LINE mu [ i ] . clear ( ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def findSubarraySum ( arr , n ) : NEW_LINE INDENT res = 0 NEW_LINE mp = defaultdict ( lambda : 0 ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT Sum = 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT Sum += arr [ j ] NEW_LINE mp [ Sum ] += 1 NEW_LINE DEDENT DEDENT for x in mp : NEW_LINE INDENT if ( mp [ second ] == 1 ) : NEW_LINE INDENT res += x NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def findpath ( graph , n ) : NEW_LINE INDENT numofadj = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT numofadj . append ( accumulate ( graph [ i ] , graph [ i ] + 5 , 0 ) ) NEW_LINE DEDENT startpoint = 0 NEW_LINE numofodd = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if numofadj [ i ] % 2 == 1 : NEW_LINE INDENT numofodd += 1 NEW_LINE startpoint = i NEW_LINE DEDENT DEDENT if numofodd > 2 : NEW_LINE INDENT print ( " No ▁ Solution " ) NEW_LINE return NEW_LINE DEDENT stack = [ ] NEW_LINE path = [ ] NEW_LINE cur = startpoint NEW_LINE while ( len ( stack ) != 0 ) : NEW_LINE INDENT if ( accumulate ( graph [ cur ] , graph [ cur ] + 5 , 0 ) == 0 ) : NEW_LINE INDENT path . append ( cur ) NEW_LINE cur = stack [ - 1 ] NEW_LINE stack . pop ( ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( graph [ cur ] [ i ] == 1 ) : NEW_LINE INDENT stack . append ( cur ) NEW_LINE graph [ cur ] [ i ] = 0 NEW_LINE graph [ i ] [ cur ] = 0 NEW_LINE cur = i NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT for ele in path : NEW_LINE INDENT print ( ele , end = " ▁ - > ▁ " ) NEW_LINE DEDENT print ( cur ) NEW_LINE DEDENT
def sumBetweenTwoKth ( arr , n , k1 , k2 ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE return accumulate ( arr + k1 , arr + k2 - 1 , 0 ) NEW_LINE DEDENT
def calculate ( a , n ) : NEW_LINE INDENT maximum = max ( a , a + 5 ) NEW_LINE frequency = [ 0 ] * ( maximum + 1 ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT frequency [ a [ i ] ] = frequency [ a [ i ] ] + 1 NEW_LINE DEDENT answer = 0 NEW_LINE for i in range ( 0 , ( * maximum ) + 1 ) : NEW_LINE INDENT answer = answer + frequency [ i ] * ( frequency [ i ] - 1 ) NEW_LINE DEDENT return answer // 2 NEW_LINE DEDENT
def sumNodes ( l ) : NEW_LINE INDENT leafNodeCount = int ( math . pow ( 2 , l - 1 ) ) NEW_LINE vec = [ [ 0 for i in range ( leafNodeCount ) ] for j in range ( l ) ] NEW_LINE for i in range ( 1 , leafNodeCount + 1 ) : NEW_LINE INDENT vec [ l - 1 ] . append ( i ) NEW_LINE DEDENT for i in range ( l - 2 , - 1 , - 1 ) : NEW_LINE INDENT k = 0 NEW_LINE while ( k < len ( vec [ i + 1 ] ) - 1 ) : NEW_LINE INDENT vec [ i ] . append ( vec [ i + 1 ] [ k ] + vec [ i + 1 ] [ k + 1 ] ) NEW_LINE k += 2 NEW_LINE DEDENT DEDENT sum = 0 NEW_LINE for i in range ( l ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT sum += vec [ i ] [ j ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def encrypt ( text , s ) : NEW_LINE INDENT result = " " NEW_LINE for i in range ( 0 , len ( text ) ) : NEW_LINE INDENT if ( isupper ( text [ i ] ) ) : NEW_LINE INDENT result += chr ( int ( text [ i ] + s - 65 ) % 26 + 65 ) NEW_LINE DEDENT else : NEW_LINE INDENT result += chr ( int ( text [ i ] + s - 97 ) % 26 + 97 ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT return b NEW_LINE DEDENT if b == 0 : NEW_LINE INDENT return a NEW_LINE DEDENT k = 0 NEW_LINE while ( ( a | b ) and 1 ) == 0 : NEW_LINE INDENT k = k + 1 NEW_LINE DEDENT while ( ( a > 1 ) == 0 ) : NEW_LINE INDENT a >>= 1 NEW_LINE b >>= 1 NEW_LINE DEDENT while ( ( a > 1 ) == 0 ) : NEW_LINE INDENT a >>= 1 NEW_LINE DEDENT while ( b > 1 ) == 0 ) : NEW_LINE INDENT b >>= 1 NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT a = a >> 1 NEW_LINE DEDENT b = ( b - a ) NEW_LINE DEDENT while ( b != 0 ) : NEW_LINE INDENT return a << k NEW_LINE DEDENT
def calculateSum ( arr , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT s = arr [ 0 ] NEW_LINE value = int ( s ) NEW_LINE sum = value NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT s = arr [ i ] NEW_LINE value = int ( s ) NEW_LINE operation = arr [ i - 1 ] [ 0 ] NEW_LINE if ( operation == ' + ' ) : NEW_LINE INDENT sum += value NEW_LINE DEDENT else : NEW_LINE INDENT sum -= value NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def replace ( s , c1 , c2 ) : NEW_LINE INDENT l = len ( s ) NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( s [ i ] == c1 ) : NEW_LINE INDENT s [ i ] = c2 NEW_LINE DEDENT elif ( s [ i ] == c2 ) : NEW_LINE INDENT s [ i ] = c1 NEW_LINE DEDENT DEDENT return s NEW_LINE DEDENT
def lexicographicSubConcat ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE sub_count = int ( ( n + 1 ) / 2 ) NEW_LINE arr = [ None ] * ( sub_count + 1 ) NEW_LINE index = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for len in range ( 1 , n - i + 1 ) : NEW_LINE INDENT arr [ index ] = s [ i , len ] NEW_LINE index += 1 NEW_LINE DEDENT DEDENT arr . sort ( ) NEW_LINE res = " " NEW_LINE for i in range ( 0 , sub_count ) : NEW_LINE INDENT res += arr [ i ] NEW_LINE DEDENT return res NEW_LINE DEDENT
def findpos ( n ) : NEW_LINE INDENT i = 0 NEW_LINE pos = 0 NEW_LINE while i < len ( n ) : NEW_LINE INDENT switch n [ i ] : NEW_LINE INDENT case '4' : NEW_LINE INDENT pos = pos * 2 + 1 NEW_LINE break NEW_LINE DEDENT case '7' : NEW_LINE INDENT pos = pos * 2 + 2 NEW_LINE break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return pos NEW_LINE DEDENT
def lis ( arr , n ) : NEW_LINE INDENT mpis = [ 0 ] * n NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT mpis [ i ] = arr [ i ] NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( 0 , i ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and mpis [ i ] < ( mpis [ j ] * arr [ i ] ) ) : NEW_LINE INDENT mpis [ i ] = mpis [ j ] * arr [ i ] NEW_LINE DEDENT DEDENT DEDENT return max_element ( mpis , mpis + n ) NEW_LINE DEDENT
def checkSorted ( n , q ) : NEW_LINE INDENT st = [ ] NEW_LINE expected = 1 NEW_LINE while ( not q . empty ( ) ) : NEW_LINE INDENT fnt = q . get ( ) NEW_LINE if ( fnt == expected ) : NEW_LINE INDENT expected += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( len ( st ) == 0 ) : NEW_LINE INDENT st . append ( fnt ) NEW_LINE DEDENT elif ( len ( st ) != 0 and st [ - 1 ] < fnt ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT st . append ( fnt ) NEW_LINE DEDENT DEDENT while ( len ( st ) and st [ - 1 ] == expected ) : NEW_LINE INDENT st . pop ( ) NEW_LINE expected += 1 NEW_LINE DEDENT DEDENT if ( expected - 1 == n and len ( st ) == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def generate ( st , s ) : NEW_LINE INDENT if ( len ( s ) == 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( st . get ( s ) == None ) : NEW_LINE INDENT return NEW_LINE DEDENT st . add ( s ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT t = s NEW_LINE t . remove ( i , 1 ) NEW_LINE generate ( st , t ) NEW_LINE DEDENT DEDENT return NEW_LINE DEDENT
def minLexRotation ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE arr = [ None ] * n NEW_LINE concat = str + str NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT arr [ i ] = concat [ i : n ] NEW_LINE DEDENT arr . sort ( ) NEW_LINE return arr [ 0 ] NEW_LINE DEDENT
def isPossible ( a , b , n , k ) : NEW_LINE INDENT a . sort ( reverse = True ) NEW_LINE b . sort ( reverse = True ) NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if a [ i ] + b [ i ] < k : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def isCornerPresent ( str , corner ) : NEW_LINE INDENT n = len ( str ) NEW_LINE cl = len ( corner ) NEW_LINE if n < cl : NEW_LINE INDENT return False NEW_LINE DEDENT return ( str [ 0 : cl ] == corner and str [ n - cl : cl ] == corner ) NEW_LINE DEDENT
def longDivision ( number , divisor ) : NEW_LINE INDENT ans = " " NEW_LINE idx = 0 NEW_LINE temp = number [ idx ] - '0' NEW_LINE while ( temp < divisor ) : NEW_LINE INDENT temp = ( temp * 10 + ( number [ idx ] - '0' ) ) NEW_LINE DEDENT while ( len ( number ) > idx ) : NEW_LINE INDENT ans += ( temp // divisor ) + '0' NEW_LINE temp = ( temp % divisor ) * 10 + number [ idx ] - '0' NEW_LINE DEDENT if ( len ( ans ) == 0 ) : NEW_LINE INDENT return "0" NEW_LINE DEDENT return ans NEW_LINE DEDENT
def sort012 ( a , arr_size ) : NEW_LINE INDENT lo = 0 NEW_LINE hi = arr_size - 1 NEW_LINE mid = 0 NEW_LINE while ( mid <= hi ) : NEW_LINE INDENT switch a [ mid ] : NEW_LINE INDENT case 0 : NEW_LINE INDENT a [ lo ] , a [ mid ] = a [ mid ] , a [ hi ] NEW_LINE break NEW_LINE DEDENT case 1 : NEW_LINE INDENT mid += 1 NEW_LINE break NEW_LINE DEDENT case 2 : NEW_LINE INDENT a [ mid ] , a [ hi -= 1 ] = a [ hi ] , a [ mid ] NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT
def canRepresentBST ( pre , n ) : NEW_LINE INDENT s = [ ] NEW_LINE root = - sys . maxsize - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( pre [ i ] < root ) : NEW_LINE INDENT return False NEW_LINE DEDENT while ( len ( s ) > 0 and s [ - 1 ] < pre [ i ] ) : NEW_LINE INDENT root = s [ - 1 ] NEW_LINE s . pop ( ) NEW_LINE DEDENT s . append ( pre [ i ] ) NEW_LINE DEDENT return True NEW_LINE DEDENT
def solveQuery ( start , end , arr ) : NEW_LINE INDENT frequency = dict ( ) NEW_LINE for i in range ( start , end + 1 ) : NEW_LINE INDENT frequency [ arr [ i ] ] = frequency . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT count = 0 NEW_LINE for x in frequency : NEW_LINE INDENT if ( frequency [ x ] == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def divisibleBy20 ( num ) : NEW_LINE INDENT lastTwoDigits = int ( num [ : - 2 ] ) NEW_LINE lastTwoDigits = int ( num [ : - 1 ] ) NEW_LINE return ( ( lastTwoDigits % 5 == 0 ) and ( lastTwoDigits % 4 == 0 ) ) NEW_LINE DEDENT
def CountTriangles ( A ) : NEW_LINE INDENT n = len ( A ) NEW_LINE A . sort ( ) NEW_LINE count = 0 NEW_LINE for i in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT l = 0 NEW_LINE r = i - 1 NEW_LINE while ( l < r ) : NEW_LINE INDENT if ( A [ l ] + A [ r ] > A [ i ] ) : NEW_LINE INDENT count += r - l NEW_LINE r -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT l += 1 NEW_LINE DEDENT DEDENT print ( " No ▁ of ▁ possible ▁ solutions : ▁ " , count ) NEW_LINE DEDENT
def countFreq ( arr , n ) : NEW_LINE INDENT hm = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT hm [ arr [ i ] ] = hm . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT st = set ( ) NEW_LINE for x in hm : NEW_LINE INDENT st . add ( { x . first , x . second } ) NEW_LINE DEDENT cumul = 0 NEW_LINE for x in st : NEW_LINE INDENT cumul += x . second NEW_LINE print ( x . first , end = " ▁ " ) NEW_LINE print ( cumul ) NEW_LINE DEDENT DEDENT
def CocktailSort ( a ) : NEW_LINE INDENT swapped = True NEW_LINE start = 0 NEW_LINE end = n - 1 NEW_LINE while ( swapped ) : NEW_LINE INDENT swapped = False NEW_LINE for i in range ( start , end ) : NEW_LINE INDENT if ( a [ i ] > a [ i + 1 ] ) : NEW_LINE INDENT a [ i ] , a [ i + 1 ] = a [ i + 1 ] , a [ i ] NEW_LINE swapped = True NEW_LINE DEDENT DEDENT if ( not swapped ) : NEW_LINE INDENT break NEW_LINE DEDENT swapped = False NEW_LINE end = end - 1 NEW_LINE for i in range ( end - 1 , start , - 1 ) : NEW_LINE INDENT if ( a [ i ] > a [ i + 1 ] ) : NEW_LINE INDENT a [ i ] , a [ i + 1 ] = a [ i + 1 ] , a [ i ] NEW_LINE swapped = True NEW_LINE DEDENT DEDENT start += 1 NEW_LINE DEDENT DEDENT
def first ( str , i ) : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( str [ i ] . isupper ( ) ) : NEW_LINE INDENT return str [ i ] NEW_LINE DEDENT return first ( str , i + 1 ) ; NEW_LINE DEDENT
def longestNull ( str ) : NEW_LINE INDENT arr = [ ] NEW_LINE maxlen = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT arr . append ( ( ' @ ' , - 1 ) ) NEW_LINE maxlen = max ( maxlen , i ) NEW_LINE DEDENT for i in range ( len ( str ) ) : NEW_LINE INDENT arr . append ( ( str [ i ] , i ) ) NEW_LINE while ( len ( arr ) >= 3 and arr [ len ( arr ) - 3 ] . first == '1' and arr [ len ( arr ) - 2 ] . first == '0' and arr [ len ( arr ) - 1 ] . first == '0' ) ) : NEW_LINE INDENT arr . pop ( ) NEW_LINE arr . pop ( ) NEW_LINE DEDENT tmp = arr [ - 1 ] NEW_LINE maxlen = max ( maxlen , i - tmp ) NEW_LINE DEDENT return maxlen NEW_LINE DEDENT
def reverse ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE for i in range ( 0 , int ( n / 2 ) ) : NEW_LINE INDENT str [ i ] , str [ n - i - 1 ] = str [ n - i - 1 ] , str [ i ] NEW_LINE DEDENT DEDENT
def nextWord ( s ) : NEW_LINE INDENT if ( s == " " ) : NEW_LINE INDENT return " a " NEW_LINE DEDENT i = len ( s ) - 1 NEW_LINE while ( s [ i ] == ' z ' and i >= 0 ) : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT if ( i == - 1 ) : NEW_LINE INDENT s = s + ' a ' NEW_LINE DEDENT else : NEW_LINE INDENT s [ i ] = s [ i ] + 1 NEW_LINE DEDENT return s NEW_LINE DEDENT
def isRectangle ( matrix ) : NEW_LINE INDENT rows = len ( matrix ) NEW_LINE if ( rows == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT columns = len ( matrix [ 0 ] ) NEW_LINE table = dict ( ) NEW_LINE for i in range ( rows ) : NEW_LINE INDENT for j in range ( columns - 1 ) : NEW_LINE INDENT for k in range ( j + 1 , columns ) : NEW_LINE INDENT if ( matrix [ i ] [ j ] == 1 and matrix [ i ] [ k ] == 1 ) : NEW_LINE INDENT if ( table [ j ] . get ( k ) in table ) : NEW_LINE INDENT return True NEW_LINE DEDENT table [ j ] [ k ] = 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return False NEW_LINE DEDENT
def sumoflength ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE j = 0 NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT while ( j < n and arr [ i ] not in s ) : NEW_LINE INDENT s . add ( arr [ i ] ) NEW_LINE j += 1 NEW_LINE DEDENT ans += ( ( j - i ) * ( j - i + 1 ) ) / 2 NEW_LINE DEDENT s . remove ( arr [ i ] ) NEW_LINE DEDENT return int ( ans ) NEW_LINE DEDENT
def findTriplets ( arr , n ) : NEW_LINE INDENT found = False NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT s = set ( ) NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT x = - ( arr [ i ] + arr [ j ] ) NEW_LINE if ( x in s ) : NEW_LINE INDENT print ( " % d ▁ % d " , x , arr [ i ] , arr [ j ] ) NEW_LINE found = True NEW_LINE DEDENT else : NEW_LINE INDENT s . add ( arr [ j ] ) NEW_LINE DEDENT DEDENT DEDENT if ( found == False ) : NEW_LINE INDENT print ( " ▁ No ▁ Triplet ▁ Found " ) NEW_LINE DEDENT DEDENT
def maxPrefix ( s , t ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( t ) ) : NEW_LINE INDENT if ( count == len ( s ) ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( t [ i ] == s [ count ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def segregateElements ( arr , n ) : NEW_LINE INDENT temp = [ 0 ] * n NEW_LINE j = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if arr [ i ] >= 0 : NEW_LINE INDENT temp [ j ] = arr [ i ] NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if j == n or j == 0 : NEW_LINE INDENT return NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if arr [ i ] < 0 : NEW_LINE INDENT temp [ j ] = arr [ i ] NEW_LINE DEDENT j += 1 NEW_LINE DEDENT DEDENT arr = sorted ( temp ) NEW_LINE DEDENT
def mergeIntervals ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE index = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if arr [ index ] . e >= arr [ i ] . s : NEW_LINE INDENT arr [ index ] . e = max ( arr [ index ] . e , arr [ i ] . e ) NEW_LINE arr [ index ] . s = min ( arr [ index ] . s , arr [ i ] . s ) NEW_LINE DEDENT else : NEW_LINE INDENT arr [ index ] = arr [ i ] NEW_LINE index += 1 NEW_LINE DEDENT DEDENT print ( " The ▁ Merged ▁ Intervals ▁ are : ▁ " ) NEW_LINE for i in range ( index + 1 ) : NEW_LINE INDENT print ( " [ " , arr [ i ] . s , " , ▁ " , arr [ i ] . e , " ] " ) NEW_LINE DEDENT DEDENT
def findArea ( arr , n ) : NEW_LINE INDENT arr . sort ( reverse = True ) NEW_LINE dimension = [ 0 , 0 ] * 2 NEW_LINE j = 0 NEW_LINE i = 0 NEW_LINE while ( i < n - 1 and j < 2 ) : NEW_LINE INDENT if ( arr [ i ] == arr [ i + 1 ] ) : NEW_LINE INDENT dimension [ j ] = arr [ i ] NEW_LINE i += 1 NEW_LINE DEDENT DEDENT return ( dimension [ 0 ] * dimension [ 1 ] ) NEW_LINE DEDENT
def minOps ( arr , n , k ) : NEW_LINE INDENT max1 = max ( arr ) NEW_LINE res = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( ( max - arr [ i ] ) % k != 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT res += ( max - arr [ i ] ) / k NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def isdivisible7 ( num ) : NEW_LINE INDENT n = len ( num ) NEW_LINE gSum = 0 NEW_LINE if n == 0 and num [ 0 ] == ' \n ' : NEW_LINE INDENT return 1 NEW_LINE DEDENT if n % 3 == 1 : NEW_LINE INDENT num = list ( num ) NEW_LINE n += 2 NEW_LINE DEDENT elif n % 3 == 2 : NEW_LINE INDENT num = list ( num ) NEW_LINE n += 1 NEW_LINE DEDENT i = n - 1 NEW_LINE while i >= 0 : NEW_LINE INDENT group = 0 NEW_LINE group += ord ( num [ i ] ) - ord ( '0' ) NEW_LINE group += ord ( num [ i ] ) - ord ( '0' ) NEW_LINE group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 10 NEW_LINE group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 100 NEW_LINE gSum = gSum + group * p NEW_LINE p = ( - 1 ) NEW_LINE DEDENT return ( gSum % 7 == 0 ) NEW_LINE DEDENT
def isDivisible999 ( num ) : NEW_LINE INDENT n = len ( num ) NEW_LINE if ( n == 0 and num [ 0 ] == '0' ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 3 == 1 ) : NEW_LINE INDENT num = "00" + num NEW_LINE DEDENT if ( n % 3 == 2 ) : NEW_LINE INDENT num = "0" + num NEW_LINE DEDENT gSum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT group = 0 NEW_LINE group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 100 NEW_LINE group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 10 NEW_LINE group += ord ( num [ i ] ) - ord ( '0' ) ) NEW_LINE gSum += group NEW_LINE DEDENT if ( gSum > 1000 ) : NEW_LINE INDENT num = str ( gSum ) NEW_LINE n = len ( num ) NEW_LINE gSum = isDivisible999 ( num ) NEW_LINE DEDENT return ( gSum == 999 ) NEW_LINE DEDENT
def checkPangram ( st ) : NEW_LINE INDENT mark = [ False for i in range ( 26 ) ] NEW_LINE index = 0 NEW_LINE for i in range ( len ( st ) ) : NEW_LINE INDENT if ( ' A ' <= st [ i ] and st [ i ] <= ' Z ' ) : NEW_LINE INDENT index = ord ( st [ i ] ) - ord ( ' A ' ) NEW_LINE DEDENT elif ( ' a ' <= st [ i ] and st [ i ] <= ' z ' ) : NEW_LINE INDENT index = ord ( st [ i ] ) - ord ( ' a ' ) NEW_LINE DEDENT mark [ index ] = True NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT if ( mark [ i ] == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def kLargest ( arr , n , k ) : NEW_LINE INDENT arr . sort ( reverse = True ) NEW_LINE for i in range ( k ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def kthLargestSum ( arr , n , k ) : NEW_LINE INDENT sum = [ 0 ] * ( n + 1 ) NEW_LINE sum [ 0 ] = 0 NEW_LINE sum [ 1 ] = arr [ 0 ] NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT sum [ i ] = sum [ i - 1 ] + arr [ i - 1 ] NEW_LINE DEDENT Q = PriorityQueue ( ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( i , n + 1 ) : NEW_LINE INDENT x = sum [ j ] - sum [ i - 1 ] NEW_LINE if ( len ( Q ) < k ) : NEW_LINE INDENT Q . put ( x ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( Q [ - 1 ] < x ) : NEW_LINE INDENT Q . pop ( ) NEW_LINE Q . put ( x ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return Q . get ( ) NEW_LINE DEDENT
def printDistinct ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] not in s : NEW_LINE INDENT s . add ( arr [ i ] ) NEW_LINE print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
def abFree ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE char_array = list ( s ) NEW_LINE b_count = 0 NEW_LINE res = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( char_array [ n - i - 1 ] == ' a ' ) : NEW_LINE INDENT res = ( res + b_count ) NEW_LINE b_count = ( b_count * 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT b_count += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def findFibSubset ( arr , n ) : NEW_LINE INDENT max1 = max ( arr ) NEW_LINE a = 0 NEW_LINE b = 1 NEW_LINE hash = set ( ) NEW_LINE hash . add ( a ) NEW_LINE hash . add ( b ) NEW_LINE while ( b < max1 ) : NEW_LINE INDENT c = a + b NEW_LINE a = b NEW_LINE b = c NEW_LINE hash . add ( b ) NEW_LINE DEDENT while ( b < max1 ) : NEW_LINE INDENT c = a + b NEW_LINE a = b NEW_LINE b = c NEW_LINE hash . add ( b ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if arr [ i ] not in hash : NEW_LINE INDENT hash . add ( arr [ i ] ) NEW_LINE DEDENT DEDENT DEDENT
def recursiveReverse ( str , i ) : NEW_LINE INDENT n = len ( str ) NEW_LINE if i == n // 2 : NEW_LINE INDENT return NEW_LINE DEDENT str [ i ] , str [ n - i - 1 ] = str [ n - i - 1 ] , str [ i ] NEW_LINE recursiveReverse ( str , i + 1 ) NEW_LINE DEDENT
def noAdjacentDup ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( s [ i ] == s [ i - 1 ] ) : NEW_LINE INDENT s [ i ] = ' a ' NEW_LINE while ( s [ i ] == s [ i - 1 ] or ( i + 1 < n and s [ i ] == s [ i + 1 ] ) ) : NEW_LINE INDENT s [ i ] = ' ' NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT return s NEW_LINE DEDENT
def query ( s , i , j ) : NEW_LINE INDENT n = len ( s ) NEW_LINE i %= n NEW_LINE j %= n NEW_LINE if ( s [ i ] == s [ j ] ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def countPairs ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE Hash = set ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT Hash . add ( arr [ i ] ) NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT product = arr [ i ] * arr [ j ] NEW_LINE if ( Hash . get ( product ) ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
def printInSortedOrder ( arr , n ) : NEW_LINE INDENT index = [ 0 ] * n NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT index [ i ] = i NEW_LINE DEDENT for i in range ( 0 , n - 1 ) : NEW_LINE INDENT min = i NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ index [ min ] ] == arr [ index [ j ] ] ) > 0 : NEW_LINE INDENT min = j NEW_LINE DEDENT DEDENT if ( min != i ) : NEW_LINE INDENT temp = index [ min ] NEW_LINE index [ min ] = index [ i ] NEW_LINE index [ i ] = temp NEW_LINE DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ index [ i ] ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def sortUsingHash ( a , n ) : NEW_LINE INDENT max1 = max ( a ) NEW_LINE min1 = abs ( a [ n ] ) NEW_LINE hashpos = [ 0 ] * ( max1 + 1 ) NEW_LINE hashneg = [ 0 ] * ( min1 + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] >= 0 ) : NEW_LINE INDENT hashpos [ a [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT hashneg [ abs ( a [ i ] ) ] += 1 NEW_LINE DEDENT DEDENT for i in range ( min , max1 + 1 ) : NEW_LINE INDENT if ( hashneg [ i ] ) : NEW_LINE INDENT for j in range ( - 1 , hashneg [ i ] , 1 ) : NEW_LINE INDENT print ( ( - 1 ) * i , " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( max1 + 1 ) : NEW_LINE INDENT if ( hashpos [ i ] ) : NEW_LINE INDENT for j in range ( hashpos [ i ] ) : NEW_LINE INDENT print ( i , " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
def findRandomIndexOfMax ( arr , n ) : NEW_LINE INDENT freq = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ arr [ i ] ] = freq . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT max_element = - 1 NEW_LINE max_so_far = - 1 NEW_LINE for p in freq : NEW_LINE INDENT if ( p . second > max_so_far ) : NEW_LINE INDENT max_so_far = p . second NEW_LINE max_element = p . first NEW_LINE DEDENT DEDENT r = ( rand ( ) % max_so_far ) + 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == max_element ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( count == r ) : NEW_LINE INDENT print ( " Element ▁ with ▁ maximum ▁ frequency ▁ present ▁ " , i ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT
def singleNumber ( a , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE arr_sum = accumulate ( a , a + n , 0 ) NEW_LINE set_sum = accumulate ( s , s , 0 ) NEW_LINE return ( 3 * set_sum - arr_sum ) / 2 NEW_LINE DEDENT
def printAllAPTriplets ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT diff = arr [ j ] - arr [ i ] NEW_LINE if ( arr [ i ] - diff ) in s : NEW_LINE INDENT print ( arr [ i ] - diff , end = " ▁ " , arr [ j ] ) NEW_LINE DEDENT DEDENT DEDENT s . add ( arr [ i ] ) NEW_LINE DEDENT DEDENT
def simplify ( str ) : NEW_LINE INDENT l = len ( str ) NEW_LINE res = [ 0 ] * ( l ) NEW_LINE index = 0 NEW_LINE i = 0 NEW_LINE s = [ ] NEW_LINE while i < l : NEW_LINE INDENT if ( str [ i ] == ' + ' ) : NEW_LINE INDENT if ( s [ 0 ] == 1 ) : NEW_LINE INDENT res [ index ] = ' - ' NEW_LINE DEDENT if ( s [ 0 ] == 0 ) : NEW_LINE INDENT res [ index ] = ' + ' NEW_LINE DEDENT DEDENT elif ( str [ i ] == ' - ' ) : NEW_LINE INDENT if ( s [ 0 ] == 1 ) : NEW_LINE INDENT res [ index ] = ' - ' NEW_LINE DEDENT elif ( s [ 0 ] == 0 ) : NEW_LINE INDENT res [ index ] = ' - ' NEW_LINE DEDENT DEDENT elif ( str [ i ] == ' ( ' and i > 0 ) : NEW_LINE INDENT if ( str [ i - 1 ] == ' - ' ) : NEW_LINE INDENT x = 0 NEW_LINE DEDENT s . append ( x ) NEW_LINE DEDENT elif ( str [ i - 1 ] == ' + ' ) : NEW_LINE INDENT s . append ( s [ - 1 ] ) NEW_LINE DEDENT DEDENT elif ( str [ i ] == ' ) ' ) : NEW_LINE INDENT s . pop ( ) NEW_LINE DEDENT else : NEW_LINE INDENT res [ index ] = str [ i ] NEW_LINE i += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def findPair ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . add ( arr [ i ] ) NEW_LINE DEDENT found = False NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if arr [ i ] + arr [ j ] in s : NEW_LINE INDENT print ( arr [ i ] , arr [ j ] ) NEW_LINE found = True NEW_LINE DEDENT DEDENT DEDENT if found == False : NEW_LINE INDENT print ( " Not ▁ exist " ) NEW_LINE DEDENT DEDENT
def strToBinary ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT val = int ( s [ i ] ) NEW_LINE bin = " " NEW_LINE while ( val > 0 ) : NEW_LINE INDENT ( val % 2 ) : NEW_LINE INDENT bin . append ( '1' ) NEW_LINE DEDENT else : NEW_LINE INDENT bin . append ( '0' ) NEW_LINE val //= 2 NEW_LINE DEDENT DEDENT bin = ' ' . join ( bin ) NEW_LINE DEDENT
def findDuplicateparenthesis ( str ) : NEW_LINE INDENT Stack = [ ] NEW_LINE for ch in str : NEW_LINE INDENT if ( ch == ' ) ' ) : NEW_LINE INDENT top = Stack [ - 1 ] NEW_LINE Stack . pop ( ) NEW_LINE elementsInside = 0 NEW_LINE while ( top != ' ( ' ) : NEW_LINE INDENT elementsInside += 1 NEW_LINE top = Stack [ - 1 ] NEW_LINE Stack . pop ( ) NEW_LINE DEDENT if ( elementsInside < 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT Stack . append ( ch ) NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def findTriplets ( x ) : NEW_LINE INDENT fact = [ ] NEW_LINE factors = [ ] NEW_LINE for i in range ( 2 , int ( m . sqrt ( x ) + 1 ) ) : NEW_LINE INDENT if ( x % i == 0 ) : NEW_LINE INDENT fact . append ( i ) NEW_LINE if ( x / i != i ) : NEW_LINE INDENT fact . append ( x / i ) NEW_LINE DEDENT factors . append ( i ) NEW_LINE DEDENT factors . append ( x / i ) NEW_LINE DEDENT found = False NEW_LINE k = len ( fact ) NEW_LINE for i in range ( 0 , k ) : NEW_LINE INDENT a = fact [ i ] NEW_LINE for j in range ( 0 , k ) : NEW_LINE INDENT b = fact [ j ] NEW_LINE if ( ( a != b ) and ( x % ( a * b ) == 0 ) and ( x / ( a * b ) != a ) and ( x / ( a * b ) != b ) and ( x / ( a * b ) != 1 ) ) : NEW_LINE INDENT print ( a , " ▁ " , b , " ▁ " , ( x / ( a * b ) ) , found = True NEW_LINE break NEW_LINE DEDENT DEDENT if ( found ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( not found ) : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT DEDENT
def findMissing ( a , b , n , m ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT s . add ( b [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] not in s ) : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
def minheapify ( a , index ) : NEW_LINE INDENT small = index NEW_LINE l = 2 * index + 1 NEW_LINE r = 2 * index + 2 NEW_LINE if ( l < n and a [ l ] < a [ small ] ) : NEW_LINE INDENT small = l NEW_LINE DEDENT if ( r < n and a [ r ] < a [ small ] ) : NEW_LINE INDENT small = r NEW_LINE DEDENT if ( small != index ) : NEW_LINE INDENT a [ small ] , a [ index ] = a [ index ] , a [ small ] NEW_LINE minheapify ( a , small ) NEW_LINE DEDENT DEDENT
def KMP ( m , n , str2 , str1 ) : NEW_LINE INDENT pos = 0 NEW_LINE len = 0 NEW_LINE p = [ 0 ] * ( m + 1 ) NEW_LINE k = 0 NEW_LINE p [ 1 ] = 0 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT while ( k > 0 and str1 [ k ] != str1 [ i - 1 ] ) : NEW_LINE INDENT k = p [ k ] NEW_LINE DEDENT if ( str1 [ k ] == str1 [ i - 1 ] ) : NEW_LINE INDENT k = k + 1 NEW_LINE DEDENT p [ i ] = k NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT while ( j > 0 and str1 [ j ] != str2 [ i ] ) : NEW_LINE INDENT j = p [ j ] NEW_LINE DEDENT if ( str1 [ j ] == str2 [ i ] ) : NEW_LINE INDENT j = j + 1 NEW_LINE DEDENT if ( j > len ) : NEW_LINE INDENT len = j NEW_LINE pos = i - j + 1 NEW_LINE DEDENT DEDENT print ( " Shift ▁ = ▁ " , pos ) NEW_LINE print ( " Prefix ▁ = ▁ " , str1 ) NEW_LINE DEDENT
def swapDiagonal ( matrix ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT matrix [ i ] [ i ] , matrix [ i ] [ N - i - 1 ] = matrix [ i ] [ N - i - 1 ] , matrix [ i ] [ i ] NEW_LINE DEDENT DEDENT
def maximumPalinUsingKChanges ( str , k ) : NEW_LINE INDENT palin = str NEW_LINE l = 0 NEW_LINE r = len ( str ) - 1 NEW_LINE while ( l < r ) : NEW_LINE INDENT if ( str [ l ] != str [ r ] ) : NEW_LINE INDENT palin [ l ] = palin [ r ] = max ( str [ l ] , str [ r ] ) NEW_LINE k -= 1 NEW_LINE DEDENT l += 1 NEW_LINE r -= 1 NEW_LINE DEDENT if ( k < 0 ) : NEW_LINE INDENT return " Not ▁ possible " NEW_LINE DEDENT l = 0 NEW_LINE r = len ( str ) - 1 NEW_LINE while ( l <= r ) : NEW_LINE INDENT if ( k > 0 ) : NEW_LINE INDENT palin [ l ] = '9' NEW_LINE DEDENT DEDENT if ( palin [ l ] < '9' ) : NEW_LINE INDENT if ( k >= 2 and palin [ l ] == str [ l ] and palin [ r ] == str [ r ] ) : NEW_LINE INDENT k -= 2 NEW_LINE palin [ l ] = palin [ r ] = '9' NEW_LINE DEDENT elif ( k >= 1 and ( palin [ l ] != str [ l ] or palin [ r ] != str [ r ] ) : NEW_LINE INDENT k -= 1 NEW_LINE palin [ l ] = palin [ r ] = '9' NEW_LINE DEDENT DEDENT l += 1 NEW_LINE r -= 1 NEW_LINE DEDENT return palin NEW_LINE DEDENT
def findMinRooms ( slots , n , m ) : NEW_LINE INDENT counts = [ 0 for i in range ( m ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( slots [ i ] [ j ] == '1' ) : NEW_LINE INDENT counts [ j ] += 1 NEW_LINE DEDENT DEDENT DEDENT return max ( counts , counts + m ) NEW_LINE DEDENT
def minProduct ( arr , n , k ) : NEW_LINE INDENT pq = PriorityQueue ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT pq . put ( arr [ i ] ) NEW_LINE DEDENT count = 0 NEW_LINE ans = 1 NEW_LINE while ( len ( pq ) == 0 and count < k ) : NEW_LINE INDENT ans = ans * pq . get ( ) NEW_LINE count += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def largest ( arr , n ) : NEW_LINE INDENT return arr [ n ] NEW_LINE DEDENT
def findLongestConseqSubseq ( arr , n ) : NEW_LINE INDENT s = Set ( ) NEW_LINE for ele in arr : NEW_LINE INDENT s . add ( ele ) NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] - 1 ) not in s : NEW_LINE INDENT j = arr [ i ] NEW_LINE while ( j in s ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT ans = max ( ans , j - arr [ i ] ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def divisibilityCheck ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE max_ele = - sys . maxsize - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . add ( arr [ i ] ) NEW_LINE max_ele = max ( max_ele , arr [ i ] ) NEW_LINE DEDENT res = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] != 0 : NEW_LINE INDENT for j in range ( arr [ i ] * 2 , max_ele + arr [ i ] ) : NEW_LINE INDENT if ( s . get ( j ) in s ) : NEW_LINE INDENT res . add ( j ) NEW_LINE DEDENT DEDENT DEDENT DEDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT ans = [ ] NEW_LINE for key , values in mp . items ( ) : NEW_LINE INDENT if values >= 2 : NEW_LINE INDENT if values in res : NEW_LINE INDENT val = res . get ( key ) NEW_LINE while val in s : NEW_LINE INDENT ans . append ( key ) NEW_LINE DEDENT DEDENT if values in res : NEW_LINE INDENT val = res . get ( key ) NEW_LINE while val > 0 : NEW_LINE INDENT ans . append ( key ) NEW_LINE DEDENT DEDENT for key in ans : NEW_LINE INDENT print ( key , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def minPalPartion ( str1 ) : NEW_LINE INDENT n = len ( str1 ) NEW_LINE C = [ [ 0 for x in range ( n + 1 ) ] for y in range ( n + 1 ) ] NEW_LINE P = [ [ False for x in range ( n + 1 ) ] for y in range ( n + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT P [ i ] [ i ] = True NEW_LINE C [ i ] [ i ] = 0 NEW_LINE DEDENT for L in range ( 2 , n + 1 ) : NEW_LINE INDENT for i in range ( n - L + 1 ) : NEW_LINE INDENT j = i + L - 1 NEW_LINE if ( L == 2 ) : NEW_LINE INDENT P [ i ] [ j ] = ( str1 [ i ] == str1 [ j ] ) NEW_LINE DEDENT else : NEW_LINE INDENT P [ i ] [ j ] = ( ( str1 [ i ] == str1 [ j ] ) and P [ i + 1 ] [ j - 1 ] ) NEW_LINE DEDENT if ( P [ i ] [ j ] == True ) : NEW_LINE INDENT C [ i ] [ j ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = sys . maxsize NEW_LINE for k in range ( i , j - 1 ) : NEW_LINE INDENT C [ i ] [ j ] = min ( C [ i ] [ j ] , C [ i ] [ k ] + C [ k + 1 ] [ j ] + 1 ) NEW_LINE DEDENT DEDENT DEDENT return C [ 0 ] [ n - 1 ] NEW_LINE DEDENT
def checkCount ( arr , n , k ) : NEW_LINE INDENT Hash = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT Hash [ arr [ i ] ] = Hash . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT for x in Hash : NEW_LINE INDENT if ( Hash [ x ] > 2 * k ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def removeDuplicates ( S ) : NEW_LINE INDENT n = len ( S ) NEW_LINE if ( n < 2 ) : NEW_LINE INDENT return NEW_LINE DEDENT j = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( S [ j ] != S [ i ] ) : NEW_LINE INDENT j += 1 NEW_LINE S [ j ] = S [ i ] NEW_LINE DEDENT DEDENT j += 1 NEW_LINE S [ j ] = ' \0' NEW_LINE DEDENT DEDENT
def KMaxCombinations ( A , B , N , K ) : NEW_LINE INDENT pq = PriorityQueue ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT pq . put ( A [ i ] + B [ j ] ) NEW_LINE DEDENT DEDENT count = 0 NEW_LINE while ( count < K ) : NEW_LINE INDENT print ( pq . get ( ) , end = " " ) NEW_LINE pq . get ( ) NEW_LINE count += 1 NEW_LINE DEDENT DEDENT
def to_upper ( in ) : NEW_LINE INDENT for i in range ( len ( in ) ) : NEW_LINE INDENT if ( ord ( in [ i ] ) <= ord ( ' a ' ) and ord ( in [ i ] ) <= ord ( ' z ' ) ) : NEW_LINE INDENT in [ i ] = ord ( in [ i ] ) - ord ( ' a ' ) + ord ( ' A ' ) NEW_LINE DEDENT DEDENT return in NEW_LINE DEDENT
def sortInWave ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n , 2 ) : NEW_LINE INDENT if i > 0 and arr [ i - 1 ] > arr [ i ] : NEW_LINE INDENT arr [ i ] , arr [ i - 1 ] = arr [ i ] , arr [ i - 1 ] NEW_LINE DEDENT if i < n - 1 and arr [ i ] < arr [ i + 1 ] : NEW_LINE INDENT arr [ i ] , arr [ i + 1 ] = arr [ i + 1 ] , arr [ i ] NEW_LINE DEDENT DEDENT DEDENT
def getMinNumberForPattern ( seq ) : NEW_LINE INDENT n = len ( seq ) NEW_LINE if n >= 9 : NEW_LINE INDENT return " - 1" NEW_LINE DEDENT result = " " NEW_LINE count = 1 NEW_LINE for i in range ( n + 1 , ' ▁ ' ) : NEW_LINE INDENT if i == n or seq [ i ] == ' I ' : NEW_LINE INDENT j = i - 1 NEW_LINE while j >= - 1 : NEW_LINE INDENT result [ j + 1 ] = '0' + count NEW_LINE if j >= 0 and seq [ j ] == ' I ' : NEW_LINE INDENT break NEW_LINE DEDENT j -= 1 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
def findMin ( V ) : NEW_LINE INDENT ans = [ ] NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT while ( V >= deno [ i ] ) : NEW_LINE INDENT V -= deno [ i ] NEW_LINE ans . append ( deno [ i ] ) NEW_LINE DEDENT DEDENT for i in range ( len ( ans ) ) : NEW_LINE INDENT print ( ans [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def findRepeating ( arr , n ) : NEW_LINE INDENT return accumulate ( arr , arr + n , 0 ) - ( ( n - 1 ) * n // 2 ) NEW_LINE DEDENT
def findSum ( str1 , str2 ) : NEW_LINE INDENT if len ( str1 ) > len ( str2 ) : NEW_LINE INDENT temp = str1 NEW_LINE str1 = str2 NEW_LINE str2 = temp NEW_LINE DEDENT str3 = " " NEW_LINE n1 = len ( str1 ) NEW_LINE n2 = len ( str2 ) NEW_LINE reverse ( str1 ) NEW_LINE str3 = str3 . reverse ( ) NEW_LINE carry = 0 NEW_LINE for i in range ( 0 , n1 ) : NEW_LINE INDENT sum = ( ( ord ( str1 [ i ] ) - ord ( '0' ) ) + int ( ( ord ( str2 [ i ] ) - ord ( '0' ) ) ) + carry ) NEW_LINE str3 = str3 + str ( sum % 10 ) NEW_LINE carry = sum // 10 NEW_LINE DEDENT for i in range ( n1 , n2 ) : NEW_LINE INDENT sum = ( ( ord ( str2 [ i ] ) - ord ( '0' ) ) + carry ) NEW_LINE str3 = str3 + str ( sum % 10 ) NEW_LINE carry = sum // 10 NEW_LINE DEDENT if ( carry ) : NEW_LINE INDENT str3 + str ( carry + '0' ) NEW_LINE DEDENT str3 = str3 [ : : - 1 ] NEW_LINE return str3 NEW_LINE DEDENT
