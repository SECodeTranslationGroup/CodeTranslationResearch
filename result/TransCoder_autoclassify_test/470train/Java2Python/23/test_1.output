def printPairs ( arr , n ) : NEW_LINE INDENT v = [ ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] == arr [ j ] ) : NEW_LINE INDENT v . append ( abs ( arr [ i ] ) ) NEW_LINE DEDENT DEDENT DEDENT if ( len ( v ) == 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT v = sorted ( v ) NEW_LINE for i in range ( 0 , len ( v ) ) : NEW_LINE INDENT print ( - v [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def findArea ( a , b , c ) : NEW_LINE INDENT if ( a < 0 or b < 0 or c < 0 or ( a + b <= c ) or a + c <= b or b + c <= a ) : NEW_LINE INDENT print ( " Not ▁ a ▁ valid ▁ triangle " ) NEW_LINE exit ( 0 ) NEW_LINE DEDENT s = ( a + b + c ) / 2 NEW_LINE return math . sqrt ( s * ( s - a ) * ( s - b ) * ( s - c ) ) NEW_LINE DEDENT
def isMajority ( arr , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] in mp ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT for key , values in mp . items ( ) : NEW_LINE INDENT if values >= n // 2 : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def recaman ( n ) : NEW_LINE INDENT if ( n <= 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT s = set ( ) NEW_LINE s . add ( 0 ) NEW_LINE prev = 0 NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT curr = prev - i NEW_LINE if ( curr < 0 or curr in s ) : NEW_LINE INDENT curr = prev + i NEW_LINE DEDENT s . add ( curr ) NEW_LINE print ( " % d , ▁ " , curr ) NEW_LINE prev = curr NEW_LINE DEDENT DEDENT
def findLength ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE maxlen = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n , 2 ) : NEW_LINE INDENT length = j - i + 1 NEW_LINE leftsum = 0 NEW_LINE rightsum = 0 NEW_LINE for k in range ( 0 , int ( length / 2 ) ) : NEW_LINE INDENT leftsum += ( ord ( str [ i + k ] ) - ord ( '0' ) ) NEW_LINE rightsum += ( ord ( str [ i + k + length // 2 ] ) - ord ( '0' ) ) NEW_LINE DEDENT if ( leftsum == rightsum and maxlen < length ) : NEW_LINE INDENT maxlen = length NEW_LINE DEDENT DEDENT DEDENT return maxlen NEW_LINE DEDENT
def prevPermutation ( str ) : NEW_LINE INDENT n = len ( str ) - 1 NEW_LINE i = n NEW_LINE while ( i > 0 and str [ i - 1 ] <= str [ i ] ) : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT if ( i <= 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT j = i - 1 NEW_LINE while ( j + 1 <= n and str [ j + 1 ] <= str [ i - 1 ] ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT swap ( str , i - 1 , j ) NEW_LINE string = list ( str ) NEW_LINE string . reverse ( ) NEW_LINE str = list ( string ) NEW_LINE string . reverse ( ) NEW_LINE str = list ( string ) NEW_LINE return True NEW_LINE DEDENT
def findSubString ( str , pat ) : NEW_LINE INDENT len1 = len ( str ) NEW_LINE len2 = len ( pat ) NEW_LINE if len1 < len2 : NEW_LINE INDENT print ( " No ▁ such ▁ window ▁ exists " ) NEW_LINE return " " NEW_LINE DEDENT hash_pat = [ 0 for i in range ( no_of_chars ) ] NEW_LINE hash_str = [ 0 for i in range ( no_of_chars ) ] NEW_LINE for i in range ( len2 ) : NEW_LINE INDENT hash_pat [ pat [ i ] ] += 1 NEW_LINE DEDENT start = 0 NEW_LINE start_index = - 1 NEW_LINE min_len = sys . maxsize NEW_LINE count = 0 NEW_LINE for j in range ( len1 ) : NEW_LINE INDENT hash_str [ str [ j ] ] += 1 NEW_LINE if ( hash_pat [ str [ j ] ] != 0 and hash_str [ str [ j ] ] <= hash_pat [ str [ j ] ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( count == len2 ) : NEW_LINE INDENT while ( hash_str [ str [ start ] ] > hash_pat [ str [ start ] ] or hash_pat [ str [ start ] ] == 0 ) : NEW_LINE INDENT if ( hash_str [ str [ start ] ] > hash_pat [ str [ start ] ] ) : NEW_LINE INDENT hash_str [ str [ start ] ] -= 1 NEW_LINE start += 1 NEW_LINE DEDENT DEDENT if ( start_index == - 1 ) : NEW_LINE INDENT print ( " No ▁ such ▁ window ▁ exists " ) NEW_LINE return " " NEW_LINE DEDENT
def shuffle ( card , n ) : NEW_LINE INDENT rand = random . Random ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT r = i + rand . nextInt ( 52 - i ) NEW_LINE card [ r ] , card [ i ] = card [ i ] , card [ r ] NEW_LINE DEDENT DEDENT
def removeConsecutiveSame ( v ) : NEW_LINE INDENT st = [ ] NEW_LINE for i in range ( len ( v ) ) : NEW_LINE INDENT if ( len ( st ) == 0 ) : NEW_LINE INDENT st . append ( v [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT st . pop ( ) NEW_LINE DEDENT else : NEW_LINE INDENT st . append ( v [ i ] ) NEW_LINE DEDENT DEDENT return len ( st ) NEW_LINE DEDENT
def find ( list1 , list2 ) : NEW_LINE INDENT res = [ ] NEW_LINE max_possible_sum = len ( list1 ) + len ( list2 ) - 2 NEW_LINE for Sum in range ( max_possible_sum + 1 ) : NEW_LINE INDENT for i in range ( Sum + 1 ) : NEW_LINE INDENT if ( i < len ( list1 ) and ( Sum - i ) < len ( list2 ) and list1 [ i ] == list2 [ Sum - i ] ) : NEW_LINE INDENT res . append ( list1 [ i ] ) NEW_LINE DEDENT DEDENT if ( len ( res ) > 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT for i in range ( len ( res ) ) : NEW_LINE INDENT print ( res [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def getLevenstein ( input ) : NEW_LINE INDENT revInput = list ( revInput ) NEW_LINE n = len ( input ) NEW_LINE dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT dp [ 0 ] [ i ] = i NEW_LINE dp [ i ] [ 0 ] = i NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( input [ i - 1 ] == revInput [ j - 1 ] ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = 1 + min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT res = sys . maxsize NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT res = min ( res , dp [ i ] [ j ] ) NEW_LINE if ( i < n ) : NEW_LINE INDENT res = min ( res , dp [ i + 1 ] [ j ] ) NEW_LINE DEDENT if ( i > 0 ) : NEW_LINE INDENT res = min ( res , dp [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def countDistinct ( arr , k ) : NEW_LINE INDENT dict = { } NEW_LINE dist_count = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT if ( dict [ arr [ i ] ] == None ) : NEW_LINE INDENT dict [ arr [ i ] ] = 1 NEW_LINE dist_count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT dict [ arr [ i ] ] = dict [ arr [ i ] ] + 1 NEW_LINE DEDENT DEDENT print ( dist_count ) NEW_LINE for i in range ( k , len ( arr ) ) : NEW_LINE INDENT if ( dict [ arr [ i - k ] ] == 1 ) : NEW_LINE INDENT dict [ arr [ i - k ] ] = count - 1 NEW_LINE DEDENT else : NEW_LINE INDENT count = dict [ arr [ i - k ] ] NEW_LINE dict [ arr [ i - k ] ] = count + 1 NEW_LINE DEDENT DEDENT print ( dist_count ) NEW_LINE DEDENT DEDENT
def lcs ( dp , arr1 , n , arr2 , m , k ) : NEW_LINE INDENT if ( k < 0 ) : NEW_LINE INDENT return - 10000000 NEW_LINE DEDENT if ( n < 0 or m < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = dp [ n ] [ m ] [ k ] NEW_LINE if ( ans != - 1 ) : NEW_LINE INDENT return ans NEW_LINE DEDENT try : NEW_LINE INDENT ans = max ( lcs ( dp , arr1 , n - 1 , arr2 , m , k ) , lcs ( dp , arr1 , n , arr2 , m - 1 , k ) ) NEW_LINE if ( arr1 [ n - 1 ] == arr2 [ m - 1 ] ) : NEW_LINE INDENT ans = max ( ans , 1 + lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k ) ) NEW_LINE DEDENT ans = max ( ans , 1 + lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k - 1 ) ) NEW_LINE DEDENT ans = max ( ans , 1 + lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k - 1 ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def printDivisors ( n ) : NEW_LINE INDENT v = [ ] NEW_LINE for i in range ( 1 , int ( m . sqrt ( n ) + 1 ) ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT if n / i == i : NEW_LINE INDENT print ( " % d ▁ " , i ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " % d ▁ " , i ) NEW_LINE v . append ( n / i ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( len ( v ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( " % d ▁ " , v [ i ] ) NEW_LINE DEDENT DEDENT
def largestSubset ( a , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE dp = [ 0 for i in range ( n ) ] NEW_LINE dp [ n - 1 ] = 1 NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT mxm = 0 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( a [ j ] % a [ i ] == 0 ) : NEW_LINE INDENT mxm = max ( mxm , dp [ j ] ) NEW_LINE DEDENT DEDENT dp [ i ] = 1 + mxm NEW_LINE DEDENT return max ( dp ) NEW_LINE DEDENT
def encodedChar ( str , k ) : NEW_LINE INDENT expand = " " NEW_LINE temp = " " NEW_LINE freq = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT temp = " " NEW_LINE freq = 0 NEW_LINE while ( i < len ( str ) and str [ i ] >= ' a ' and str [ i ] <= ' z ' ) : NEW_LINE INDENT temp += str [ i ] NEW_LINE i += 1 NEW_LINE DEDENT while ( i < len ( str ) and str [ i ] >= ' 1' and str [ i ] <= '9' ) : NEW_LINE INDENT freq = freq * 10 + int ( str [ i ] ) - int ( '0' ) NEW_LINE i += 1 NEW_LINE DEDENT for j in range ( 1 , freq + 1 ) : NEW_LINE INDENT expand += temp NEW_LINE DEDENT DEDENT if ( freq == 0 ) : NEW_LINE INDENT expand += temp NEW_LINE DEDENT return expand [ k - 1 ] NEW_LINE DEDENT
def countNum ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE count = 0 NEW_LINE maxm = 10 ** 9 NEW_LINE minm = 10 ** 9 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . add ( arr [ i ] ) NEW_LINE if ( arr [ i ] < minm ) : NEW_LINE INDENT minm = arr [ i ] NEW_LINE DEDENT if ( arr [ i ] > maxm ) : NEW_LINE INDENT maxm = arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( minm , maxm + 1 ) : NEW_LINE INDENT if ( arr [ i ] not in s ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def countPairs ( arr , size ) : NEW_LINE INDENT hm = dict ( ) NEW_LINE for i in range ( size ) : NEW_LINE INDENT if ( arr [ i ] in hm ) : NEW_LINE INDENT hm [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT hm [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for it in hm : NEW_LINE INDENT count = it NEW_LINE DEDENT ans += ( count * ( count - 1 ) ) / 2 NEW_LINE DEDENT return int ( ans ) NEW_LINE DEDENT
def decimalToBinary ( num , k_prec ) : NEW_LINE INDENT binary = " " NEW_LINE Integral = int ( num ) NEW_LINE fractional = num - Integral NEW_LINE while ( Integral > 0 ) : NEW_LINE INDENT rem = Integral % 2 NEW_LINE binary += chr ( rem + '0' ) NEW_LINE Integral = Integral / 2 NEW_LINE DEDENT binary = reverse ( binary ) NEW_LINE binary += ( ' . ' ) NEW_LINE while ( k_prec -- > 0 ) : NEW_LINE INDENT fractional *= 2 NEW_LINE fract_bit = int ( fractional ) NEW_LINE if ( fract_bit == 1 ) : NEW_LINE INDENT fractional -= fract_bit NEW_LINE binary += chr ( 1 + '0' ) NEW_LINE DEDENT else : NEW_LINE INDENT binary += chr ( 0 + '0' ) NEW_LINE DEDENT DEDENT return binary NEW_LINE DEDENT
def evaluateBoolExpr ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE i = 0 NEW_LINE while i < n and i + 2 < n : NEW_LINE INDENT if ( i + 1 < n and i + 2 < n ) : NEW_LINE INDENT if ( s [ i + 1 ] == ' A ' ) : NEW_LINE INDENT if ( s [ i + 2 ] == '0' or s [ i ] == 0 ) : NEW_LINE INDENT s [ i + 2 ] = '0' NEW_LINE DEDENT else : NEW_LINE INDENT s [ i + 2 ] = '1' NEW_LINE DEDENT DEDENT elif ( ( i + 1 ) < n and s [ i + 1 ] == ' B ' ) : NEW_LINE INDENT if ( s [ i + 2 ] == '1' or s [ i ] == '1' ) : NEW_LINE INDENT s [ i + 2 ] = '1' NEW_LINE DEDENT else : NEW_LINE INDENT s [ i + 2 ] = '0' NEW_LINE DEDENT DEDENT i += 2 NEW_LINE DEDENT DEDENT return s [ n - 1 ] - '0' NEW_LINE DEDENT
def minSwaps ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE arrpos = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT arrpos . append ( ( arr [ i ] , i ) ) NEW_LINE DEDENT arrpos . sort ( ) NEW_LINE vis = [ False ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT vis . append ( False ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( o1 [ 0 ] > o2 [ 0 ] ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT elif ( o1 [ 0 ] == o2 [ 0 ] ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( vis [ i ] or arrpos [ i ] . getValue ( ) == i ) : NEW_LINE INDENT continue NEW_LINE DEDENT cycle_size = 0 NEW_LINE j = i NEW_LINE while ( j in arrpos ) : NEW_LINE INDENT vis [ j ] = True NEW_LINE j = arrpos [ j ] . getValue ( ) NEW_LINE cycle_size += 1 NEW_LINE DEDENT if ( cycle_size > 0 ) : NEW_LINE INDENT ans += ( cycle_size - 1 ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def minimumBox ( arr , n ) : NEW_LINE INDENT q = queue . Queue ( ) NEW_LINE arr . sort ( ) NEW_LINE q . put ( arr [ 0 ] ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT now = q . element ( ) NEW_LINE if ( arr [ i ] >= 2 * now ) : NEW_LINE INDENT q . get ( ) NEW_LINE DEDENT q . put ( arr [ i ] ) NEW_LINE DEDENT return len ( q ) NEW_LINE DEDENT
def convertOpposite ( str ) : NEW_LINE INDENT ln = len ( str ) NEW_LINE for i in range ( ln ) : NEW_LINE INDENT if ( str [ i ] . isupper ( ) ) : NEW_LINE INDENT str = str . replace ( i , i + 1 , ' ' ) NEW_LINE DEDENT else : NEW_LINE INDENT str = str . replace ( i , i + 1 , ' ' ) NEW_LINE DEDENT DEDENT DEDENT
def findRepeating ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] in s : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT s . add ( arr [ i ] ) NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def transpose ( A ) : NEW_LINE INDENT for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT A [ i ] [ j ] = A [ j ] [ i ] NEW_LINE A [ j ] [ i ] = temp NEW_LINE DEDENT DEDENT DEDENT
def printSubsequences ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE opsize = ( int ) ( math . pow ( 2 , n - 1 ) ) NEW_LINE for counter in range ( 0 , opsize ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT print ( str [ j ] , end = " ▁ " ) NEW_LINE if ( ( counter & ( 1 << j ) ) > 0 ) : NEW_LINE INDENT print ( " " , end = " ▁ " ) NEW_LINE DEDENT DEDENT print ( " " ) NEW_LINE DEDENT DEDENT
def printRoman ( number ) : NEW_LINE INDENT c = [ 0 for x in range ( 10001 ) ] NEW_LINE i = 0 NEW_LINE if number <= 0 : NEW_LINE INDENT print ( " Invalid ▁ number " ) NEW_LINE return NEW_LINE DEDENT while number != 0 : NEW_LINE INDENT if number >= 1000 : NEW_LINE INDENT i = digit ( ' M ' , number // 1000 , i , c ) NEW_LINE number = number % 1000 NEW_LINE DEDENT elif number >= 500 : NEW_LINE INDENT if number < 900 : NEW_LINE INDENT i = digit ( ' D ' , number // 500 , i , c ) NEW_LINE number = number % 500 NEW_LINE DEDENT else : NEW_LINE INDENT i = sub_digit ( ' C ' , ' M ' , i , c ) NEW_LINE number = number % 100 NEW_LINE DEDENT DEDENT elif number >= 100 : NEW_LINE INDENT if number < 400 : NEW_LINE INDENT i = digit ( ' C ' , number // 100 , i , c ) NEW_LINE number = number % 100 NEW_LINE DEDENT else : NEW_LINE INDENT i = sub_digit ( ' C ' , ' D ' , i , c ) NEW_LINE number = number % 100 NEW_LINE DEDENT DEDENT elif number >= 10 : NEW_LINE INDENT if number < 40 : NEW_LINE INDENT i = digit ( ' X ' , number // 10 , i , c ) NEW_LINE number = number % 10 NEW_LINE DEDENT else : NEW_LINE INDENT i = sub_digit ( ' X ' , ' C ' , i , c ) NEW_LINE number = number % 10 NEW_LINE DEDENT DEDENT elif number >= 5 : NEW_LINE INDENT if number < 9 : NEW_LINE INDENT i = digit ( ' V ' , number // 5 , i , c ) NEW_LINE number = number % 5 NEW_LINE DEDENT else : NEW_LINE INDENT i = sub_digit ( ' I ' , ' V ' , i , c ) NEW_LINE number = 0 NEW_LINE DEDENT DEDENT DEDENT print ( " Roman ▁ numeral
def findTriplet ( a1 , a2 , a3 , n1 , n2 , n3 , sum ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( n1 ) : NEW_LINE INDENT s . add ( a1 [ i ] ) NEW_LINE DEDENT al = set ( ) NEW_LINE for i in range ( n2 ) : NEW_LINE INDENT for j in range ( n3 ) : NEW_LINE INDENT if ( sum - a2 [ i ] - a3 [ j ] ) in al : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT
def check ( s ) : NEW_LINE INDENT if ( len ( s ) >= 10 ) : NEW_LINE INDENT return True NEW_LINE DEDENT for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT for j in range ( i + 1 , len ( s ) ) : NEW_LINE INDENT for k in range ( j + 1 , len ( s ) ) : NEW_LINE INDENT s1 = " " NEW_LINE s2 = " " NEW_LINE s3 = " " NEW_LINE s4 = " " NEW_LINE try : NEW_LINE INDENT s1 = s [ 0 : i ] NEW_LINE s2 = s [ i : j - i ] NEW_LINE s3 = s [ j : k - j ] NEW_LINE s4 = s [ k : len ( s ) - k ] NEW_LINE DEDENT except ( StringIndexOutOfBoundsException e ) : NEW_LINE INDENT DEDENT if ( strcheck ( s1 , s2 ) and strcheck ( s1 , s3 ) and strcheck ( s1 , s4 ) and strcheck ( s2 , s3 ) and strcheck ( s2 , s4 ) and strcheck ( s3 , s4 ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT
def bitonicGenerator ( arr , n ) : NEW_LINE INDENT i = 1 NEW_LINE j = n - 1 NEW_LINE if ( j % 2 ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT while ( i < j ) : NEW_LINE INDENT arr = swap ( arr , i , j ) NEW_LINE i += 2 NEW_LINE j -= 2 NEW_LINE DEDENT arr . sort ( 0 , ( n + 1 ) // 2 ) NEW_LINE arr . sort ( reverse = True ) NEW_LINE low = 0 NEW_LINE high = int ( ( n + 1 ) / 2 ) NEW_LINE while ( low < high ) : NEW_LINE INDENT arr [ low ] , arr [ high ] = arr [ high ] , arr [ low ] NEW_LINE low += 1 NEW_LINE high -= 1 NEW_LINE DEDENT DEDENT
def splitString ( str ) : NEW_LINE INDENT alpha = [ ] NEW_LINE num = [ ] NEW_LINE special = [ ] NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] . isdigit ( ) ) : NEW_LINE INDENT num . append ( str [ i ] ) NEW_LINE DEDENT elif ( str [ i ] . isAlphabetic ( ) ) : NEW_LINE INDENT alpha . append ( str [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT special . append ( str [ i ] ) NEW_LINE DEDENT DEDENT print ( alpha ) NEW_LINE print ( num ) NEW_LINE print ( special ) NEW_LINE DEDENT
def binaryMedian ( m , r , c ) : NEW_LINE INDENT max1 = max ( m ) NEW_LINE min1 = min ( m ) NEW_LINE for i in range ( r ) : NEW_LINE INDENT if ( m [ i ] [ 0 ] < min1 ) : NEW_LINE INDENT min1 = m [ i ] [ 0 ] NEW_LINE DEDENT if ( m [ i ] [ c - 1 ] > max1 ) : NEW_LINE INDENT max = m [ i ] [ c - 1 ] NEW_LINE DEDENT DEDENT desired = int ( ( r * c + 1 ) / 2 ) NEW_LINE while ( min < max ) : NEW_LINE INDENT mid = min + ( max - min ) // 2 NEW_LINE place = 0 NEW_LINE get = 0 NEW_LINE for i in range ( r ) : NEW_LINE INDENT get = m [ i ] [ get ] NEW_LINE if ( get < 0 ) : NEW_LINE INDENT get = abs ( get ) - 1 NEW_LINE DEDENT else : NEW_LINE INDENT while ( get < len ( m [ i ] ) and m [ i ] [ get ] == mid ) : NEW_LINE INDENT get += 1 NEW_LINE DEDENT DEDENT place = place + get NEW_LINE DEDENT if ( place < desired ) : NEW_LINE INDENT min = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT max = mid NEW_LINE DEDENT DEDENT return min NEW_LINE DEDENT
def printDuplicates ( arr , size ) : NEW_LINE INDENT map = dict ( ) NEW_LINE count = 0 NEW_LINE dup = False NEW_LINE for i in range ( size ) : NEW_LINE INDENT if ( arr [ i ] in map ) : NEW_LINE INDENT count = map [ arr [ i ] ] NEW_LINE map [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT map [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT for entry in map : NEW_LINE INDENT if ( entry [ Value ] > 1 ) : NEW_LINE INDENT print ( entry [ Key ] , end = " ▁ " ) NEW_LINE dup = True NEW_LINE DEDENT DEDENT if ( dup ) : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT DEDENT
def stoogesort ( arr , l , h ) : NEW_LINE INDENT if l >= h : NEW_LINE INDENT return NEW_LINE DEDENT if arr [ l ] > arr [ h ] : NEW_LINE INDENT t = arr [ l ] NEW_LINE arr [ l ] = arr [ h ] NEW_LINE arr [ h ] = t NEW_LINE DEDENT if h - l + 1 > 2 : NEW_LINE INDENT t = ( h - l + 1 ) / 3 NEW_LINE stoogesort ( arr , l , h - t ) NEW_LINE stoogesort ( arr , l + t , h ) NEW_LINE stoogesort ( arr , l , h - t ) NEW_LINE DEDENT DEDENT
def printEqualModNumbers ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE d = len ( arr ) - 1 NEW_LINE v = [ ] NEW_LINE i = 1 NEW_LINE while ( i * i <= d ) : NEW_LINE INDENT if ( d % i == 0 ) : NEW_LINE INDENT v . append ( i ) NEW_LINE if ( i != d // i ) : NEW_LINE INDENT v . append ( d / i ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT for i in range ( 0 , len ( v ) ) : NEW_LINE INDENT temp = arr [ 0 ] % v [ i ] NEW_LINE j = 1 NEW_LINE while ( j < n ) : NEW_LINE INDENT if ( arr [ j ] % v [ i ] != temp ) : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if ( j == n ) : NEW_LINE INDENT print ( v [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
def recursiveReverse ( str ) : NEW_LINE INDENT st = [ ] NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT st . append ( str [ i ] ) NEW_LINE DEDENT for i in range ( len ( str ) ) : NEW_LINE INDENT str [ i ] = st [ - 1 ] NEW_LINE st . pop ( ) NEW_LINE DEDENT return ' ' . join ( st ) NEW_LINE DEDENT
def printRect ( X , Y , n ) : NEW_LINE INDENT Xmax = max ( X ) NEW_LINE Xmin = min ( X ) NEW_LINE Ymax = max ( Y ) NEW_LINE Ymin = min ( Y ) NEW_LINE print ( " { " , Xmin , " , ▁ " , Ymin , " } " , end = " " ) NEW_LINE print ( " { " , Xmax , " , ▁ " , Ymax , " } " , end = " " ) NEW_LINE print ( " { " , Xmin , " , ▁ " , Ymin , " } " , end = " " ) NEW_LINE print ( " { " , Xmax , " , ▁ " , Ymax , " } " , end = " " ) NEW_LINE print ( " { " , Xmax , " , ▁ " , Ymin , " } " , end = " " ) NEW_LINE DEDENT
def NFG ( a , n , freq ) : NEW_LINE INDENT s = [ ] NEW_LINE s . append ( 0 ) NEW_LINE res = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT res [ i ] = 0 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( freq [ a [ s [ - 1 ] ] ] > freq [ a [ i ] ] ) : NEW_LINE INDENT s . append ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT while ( freq [ a [ s [ - 1 ] ] < freq [ a [ i ] ] and len ( s ) > 0 ) : NEW_LINE INDENT res [ s [ - 1 ] ] = a [ i ] NEW_LINE s . pop ( ) NEW_LINE DEDENT s . append ( i ) NEW_LINE DEDENT DEDENT while len ( s ) > 0 : NEW_LINE INDENT res [ s [ - 1 ] ] = - 1 NEW_LINE s . pop ( ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( res [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def printEqualSumSets ( arr , n ) : NEW_LINE INDENT Sum = sum ( arr ) NEW_LINE if ( Sum & 1 ) : NEW_LINE INDENT print ( " - 1" , end = " " ) NEW_LINE return NEW_LINE DEDENT k = Sum >> 1 NEW_LINE dp = [ [ False for i in range ( k + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = False NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for currSum in range ( 1 , k + 1 ) : NEW_LINE INDENT dp [ i ] [ currSum ] = dp [ i - 1 ] [ currSum ] NEW_LINE if ( arr [ i - 1 ] <= currSum ) : NEW_LINE INDENT dp [ i ] [ currSum ] = dp [ i ] [ currSum ] | dp [ i - 1 ] [ currSum - arr [ i - 1 ] ] NEW_LINE DEDENT DEDENT i = n NEW_LINE currSum = k NEW_LINE while ( i > 0 and currSum >= 0 ) : NEW_LINE INDENT if ( dp [ i - 1 ] [ currSum ] ) : NEW_LINE INDENT i -= 1 NEW_LINE set2 . append ( arr [ i ] ) NEW_LINE DEDENT elif ( dp [ i - 1 ] [ currSum - arr [ i - 1 ] ] ) : NEW_LINE INDENT i -= 1 NEW_LINE currSum -= arr [ i ] NEW_LINE DEDENT DEDENT print ( " Set ▁ 1 ▁ elements : ▁ " , end = " ▁ " ) NEW_LINE for i in range ( len ( set1 ) ) : NEW_LINE INDENT print ( set1 [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def reverseStr ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE ch = list ( str ) NEW_LINE i = 0 NEW_LINE j = n - 1 NEW_LINE while ( i < j ) : NEW_LINE INDENT ch [ i ] , ch [ j ] = ch [ j ] , ch [ i ] NEW_LINE i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT print ( ch ) NEW_LINE DEDENT
def minimizeWithKSwaps ( arr , n , k ) : NEW_LINE INDENT for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( k > 0 ) : NEW_LINE INDENT pos = i NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( j - i > k ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( arr [ j ] < arr [ pos ] ) : NEW_LINE INDENT pos = j NEW_LINE DEDENT DEDENT temp = arr [ j ] NEW_LINE arr [ j ] = arr [ j - 1 ] NEW_LINE arr [ j - 1 ] = temp NEW_LINE DEDENT k = k - pos - i NEW_LINE DEDENT DEDENT
def countSubarrays ( arr , n ) : NEW_LINE INDENT difference = 0 NEW_LINE ans = 0 NEW_LINE hash_positive = [ 0 ] * ( n + 1 ) NEW_LINE hash_negative = [ 0 ] * ( n + 1 ) NEW_LINE hash_positive [ 0 ] = 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] & 1 ) : NEW_LINE INDENT difference += 1 NEW_LINE DEDENT else : NEW_LINE INDENT difference -= 1 NEW_LINE DEDENT if ( difference < 0 ) : NEW_LINE INDENT ans += hash_negative [ - difference ] NEW_LINE hash_negative [ - difference ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += hash_positive [ difference ] NEW_LINE hash_positive [ difference ] += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def findPairs ( arr ) : NEW_LINE INDENT map = { } NEW_LINE n = len ( arr ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT sum = arr [ i ] + arr [ j ] NEW_LINE if sum not in map : NEW_LINE INDENT map [ sum ] = [ None , None ] NEW_LINE DEDENT else : NEW_LINE INDENT pair = map [ sum ] NEW_LINE print ( " ( " , arr [ p . first ] , " , ▁ " , arr [ p . second ] , " ) ▁ and ▁ ( " , arr [ i ] , " , ▁ " , arr [ j ] , " ) " , sep = " " ) NEW_LINE return True NEW_LINE DEDENT DEDENT DEDENT
def check ( s1 , s2 ) : NEW_LINE INDENT n = len ( s1 ) NEW_LINE m = len ( s2 ) NEW_LINE dp = [ [ False for i in range ( m + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( m + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = False NEW_LINE DEDENT DEDENT dp [ 0 ] [ 0 ] = True NEW_LINE for i in range ( len ( s1 ) ) : NEW_LINE INDENT for j in range ( len ( s2 ) ) : NEW_LINE INDENT if ( dp [ i ] [ j ] ) : NEW_LINE INDENT if ( j < len ( s1 ) and ( s2 [ j ] == s1 [ j ] ) ) : NEW_LINE INDENT dp [ i + 1 ] [ j + 1 ] = True NEW_LINE DEDENT if ( not ( s1 [ i ] ) ) : NEW_LINE INDENT dp [ i + 1 ] [ j ] = True NEW_LINE DEDENT DEDENT DEDENT DEDENT return ( dp [ n ] [ m ] ) NEW_LINE DEDENT
def checkDuplicatesWithinK ( arr , k ) : NEW_LINE INDENT set = set ( ) NEW_LINE for i in range ( k ) : NEW_LINE INDENT if ( arr [ i ] in set ) : NEW_LINE INDENT return True NEW_LINE DEDENT set . add ( arr [ i ] ) NEW_LINE if ( i >= k ) : NEW_LINE INDENT set . remove ( arr [ i - k ] ) NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def minOperation ( arr , n ) : NEW_LINE INDENT Hash = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT Hash [ arr [ i ] ] = Hash . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT max_count = 0 NEW_LINE for i in Hash : NEW_LINE INDENT if ( max_count < Hash [ i ] ) : NEW_LINE INDENT max_count = Hash [ i ] NEW_LINE DEDENT DEDENT return ( n - max_count ) NEW_LINE DEDENT
def findSum ( str ) : NEW_LINE INDENT temp = " " NEW_LINE sum = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] . isdigit ( ) ) : NEW_LINE INDENT temp += ch NEW_LINE DEDENT else : NEW_LINE INDENT sum += int ( temp ) NEW_LINE temp = "0" NEW_LINE DEDENT DEDENT return sum + int ( temp ) NEW_LINE DEDENT
def mostFrequent ( arr , n ) : NEW_LINE INDENT hp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT key = arr [ i ] NEW_LINE if ( hp . get ( key ) ) : NEW_LINE INDENT freq = hp [ key ] NEW_LINE freq += 1 NEW_LINE hp [ key ] = freq NEW_LINE DEDENT else : NEW_LINE INDENT hp [ key ] = 1 NEW_LINE DEDENT DEDENT max_count = 0 NEW_LINE res = - 1 NEW_LINE for val in hp : NEW_LINE INDENT if ( max_count < val ) : NEW_LINE INDENT res = val NEW_LINE max_count = val NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def firstLetterWord ( str ) : NEW_LINE INDENT result = " " NEW_LINE v = True NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] == ' ▁ ' ) : NEW_LINE INDENT v = True NEW_LINE DEDENT elif ( str [ i ] != ' ▁ ' and v == True ) : NEW_LINE INDENT result += ( str [ i ] ) NEW_LINE v = False NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def decode ( string ) : NEW_LINE INDENT integerstack = [ ] NEW_LINE stringstack = [ ] NEW_LINE temp = " " NEW_LINE result = " " NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT count = 0 NEW_LINE if ( string [ i ] == ' [ ' ) : NEW_LINE INDENT temp = " " NEW_LINE count = 0 NEW_LINE if ( integerstack [ 0 ] != ' [ ' ) : NEW_LINE INDENT count = integerstack [ 0 ] NEW_LINE integerstack . pop ( ) NEW_LINE DEDENT while ( len ( stringstack ) != 0 and stringstack [ 0 ] != ' [ ' ) : NEW_LINE INDENT temp = stringstack [ 0 ] + temp NEW_LINE stringstack . pop ( ) NEW_LINE DEDENT for j in range ( count ) : NEW_LINE INDENT result = result + temp NEW_LINE DEDENT for j in range ( len ( result ) ) : NEW_LINE INDENT stringstack . append ( result [ j ] ) NEW_LINE DEDENT result = " " NEW_LINE DEDENT elif ( stringstack [ 0 ] == ' [ ' ) : NEW_LINE INDENT if ( stringstack [ 0 ] == ' ' ) : NEW_LINE INDENT stringstack . append ( string [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT stringstack . append ( string [ i ] ) NEW_LINE DEDENT DEDENT while ( len ( stringstack ) != 0 ) : NEW_LINE INDENT result = stringstack [ 0 ] + result NEW_LINE stringstack . pop ( ) NEW_LINE DEDENT return result NEW_LINE DEDENT
def minSum ( A , n ) : NEW_LINE INDENT return ( min ( A ) * ( n - 1 ) ) NEW_LINE DEDENT
def countWords ( string , n ) : NEW_LINE INDENT mp = defaultdict ( lambda : 0 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ string [ i ] ] += 1 NEW_LINE DEDENT res = 0 NEW_LINE for key , values in mp . items ( ) : NEW_LINE INDENT if values == 2 : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def sortUsingHash ( a , n ) : NEW_LINE INDENT max = max ( a ) NEW_LINE hash = [ 0 for i in range ( max + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT hash [ a [ i ] ] += 1 NEW_LINE DEDENT for i in range ( max + 1 ) : NEW_LINE INDENT if ( hash [ i ] != 0 ) : NEW_LINE INDENT for j in range ( hash [ i ] ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
def isDivisible ( str , k ) : NEW_LINE INDENT n = len ( str ) NEW_LINE c = 0 NEW_LINE for i in range ( 0 , k ) : NEW_LINE INDENT if ( str [ n - i - 1 ] == '0' ) : NEW_LINE INDENT c = c + 1 NEW_LINE DEDENT DEDENT return ( c == k ) NEW_LINE DEDENT
def divisible ( num ) : NEW_LINE INDENT n = len ( num ) NEW_LINE sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum += int ( num [ i ] ) NEW_LINE DEDENT if ( sum % 3 == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( sum % 3 == ( ord ( num [ i ] ) - ord ( '0' ) ) % 3 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT if ( n == 2 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return 2 NEW_LINE DEDENT
def reverse ( str ) : NEW_LINE INDENT if ( str == None ) or ( len ( str ) <= 1 ) : NEW_LINE INDENT print ( str ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( str [ 0 : len ( str ) - 1 ] , end = " " ) NEW_LINE reverse ( str ) NEW_LINE DEDENT DEDENT
def isDvisibleBy12 ( num ) : NEW_LINE INDENT if ( len ( num ) >= 3 ) : NEW_LINE INDENT d1 = int ( num [ len ( num ) - 1 ] ) NEW_LINE if ( d1 % 2 != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT d2 = int ( num [ len ( num ) - 2 ] ) NEW_LINE sum = 0 NEW_LINE for i in range ( 0 , len ( num ) ) : NEW_LINE INDENT sum += num [ i ] NEW_LINE DEDENT return ( sum % 3 == 0 and ( d2 * 10 + d1 ) % 4 == 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT number = int ( num ) NEW_LINE return ( number % 12 == 0 ) NEW_LINE DEDENT DEDENT
def xorZero ( s ) : NEW_LINE INDENT one_count = 0 NEW_LINE zero_count = 0 NEW_LINE str = list ( s ) NEW_LINE n = len ( str ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( str [ i ] == '1' ) : NEW_LINE INDENT one_count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT zero_count += 1 NEW_LINE DEDENT DEDENT if ( one_count % 2 == 0 ) : NEW_LINE INDENT return zero_count NEW_LINE DEDENT return one_count NEW_LINE DEDENT
def nthRoot ( A , N ) : NEW_LINE INDENT xPre = int ( math . random ( ) % 10 ) NEW_LINE eps = 0.001 NEW_LINE delX = 2147483647 NEW_LINE xK = 0.0 NEW_LINE while ( delX > eps ) : NEW_LINE INDENT xK = ( ( N - 1.0 ) * xPre + ( double ) A / math . pow ( xPre , N - 1 ) ) / ( double ) N NEW_LINE delX = abs ( xK - xPre ) NEW_LINE xPre = xK NEW_LINE DEDENT return xK NEW_LINE DEDENT
def findLeft ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE while ( n > 0 ) : NEW_LINE INDENT if ( str [ n ] == ' d ' ) : NEW_LINE INDENT str [ n ] = ' c ' NEW_LINE break NEW_LINE DEDENT if ( str [ n ] == ' b ' ) : NEW_LINE INDENT str [ n ] = ' a ' NEW_LINE break NEW_LINE DEDENT if ( str [ n ] == ' a ' ) : NEW_LINE INDENT str [ n ] = ' b ' NEW_LINE break NEW_LINE DEDENT if ( str [ n ] == ' b ' ) : NEW_LINE INDENT str [ n ] = ' b ' NEW_LINE DEDENT elif ( str [ n ] == ' c ' ) : NEW_LINE INDENT str [ n ] = ' d ' NEW_LINE DEDENT DEDENT return str NEW_LINE DEDENT
def minRange ( arr , n , k ) : NEW_LINE INDENT l = 0 NEW_LINE r = n NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT s . add ( arr [ j ] ) NEW_LINE if ( len ( s ) == k ) : NEW_LINE INDENT if ( ( j - i ) < ( r - l ) ) : NEW_LINE INDENT r = j NEW_LINE l = i NEW_LINE DEDENT break NEW_LINE DEDENT DEDENT if ( j == n ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( l == 0 and r == n ) : NEW_LINE INDENT print ( " Invalid ▁ k " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( l , " ▁ " , r ) NEW_LINE DEDENT DEDENT
def findSum ( A , B , n ) : NEW_LINE INDENT hash = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( A [ i ] in hash ) : NEW_LINE INDENT hash [ A [ i ] ] = 1 + hash [ A [ i ] ] NEW_LINE DEDENT else : NEW_LINE INDENT hash [ A [ i ] ] = 1 NEW_LINE DEDENT if ( B [ i ] in hash ) : NEW_LINE INDENT hash [ B [ i ] ] = 1 NEW_LINE DEDENT DEDENT sum = 0 NEW_LINE for entry in hash : NEW_LINE INDENT if ( hash [ entry ] == 1 ) : NEW_LINE INDENT sum += int ( ( entry [ Key ] ) ) NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def arrayEvenAndOdd ( arr , n ) : NEW_LINE INDENT i = - 1 NEW_LINE j = 0 NEW_LINE while ( j != n ) : NEW_LINE INDENT if ( arr [ j ] % 2 == 0 ) : NEW_LINE INDENT i += 1 NEW_LINE arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ] NEW_LINE DEDENT j += 1 NEW_LINE DEDENT for k in range ( n ) : NEW_LINE INDENT print ( arr [ k ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def containsOdd ( G , src ) : NEW_LINE INDENT colorArr = [ 0 for i in range ( V ) ] NEW_LINE for i in range ( V ) : NEW_LINE INDENT colorArr [ i ] = - 1 NEW_LINE DEDENT colorArr [ src ] = 1 NEW_LINE q = [ ] NEW_LINE q . append ( src ) NEW_LINE while ( not q . empty ( ) ) : NEW_LINE INDENT u = q . pop ( ) NEW_LINE if ( G [ u ] [ u ] == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT for v in range ( V ) : NEW_LINE INDENT if ( G [ u ] [ v ] == 1 and colorArr [ v ] == - 1 ) : NEW_LINE INDENT colorArr [ v ] = 1 - colorArr [ u ] NEW_LINE q . append ( v ) NEW_LINE DEDENT elif ( G [ u ] [ v ] == 1 and colorArr [ v ] == colorArr [ u ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT
def getMinSquares ( n ) : NEW_LINE INDENT if ( n <= 3 ) : NEW_LINE INDENT return n NEW_LINE DEDENT res = n NEW_LINE for x in range ( 1 , n + 1 ) : NEW_LINE INDENT temp = x * x NEW_LINE if ( temp > n ) : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT res = min ( res , 1 + getMinSquares ( n - temp ) ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def selectRandom ( x ) : NEW_LINE INDENT count += 1 NEW_LINE if ( count == 1 ) : NEW_LINE INDENT res = x NEW_LINE DEDENT else : NEW_LINE INDENT r = random NEW_LINE i = r . nextInt ( count ) NEW_LINE if ( i == count - 1 ) : NEW_LINE INDENT res = x NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def cost ( a , n ) : NEW_LINE INDENT min = a [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( a [ i ] < min ) : NEW_LINE INDENT min = a [ i ] NEW_LINE DEDENT DEDENT return ( n - 1 ) * min NEW_LINE DEDENT
def gnomeSort ( arr , n ) : NEW_LINE INDENT index = 0 NEW_LINE while ( index < n ) : NEW_LINE INDENT if ( index == 0 ) : NEW_LINE INDENT index += 1 NEW_LINE DEDENT if ( arr [ index ] >= arr [ index - 1 ] ) : NEW_LINE INDENT index += 1 NEW_LINE DEDENT else : NEW_LINE INDENT temp = 0 NEW_LINE arr [ index ] , arr [ index - 1 ] = arr [ index - 1 ] , arr [ index ] NEW_LINE index -= 1 NEW_LINE DEDENT DEDENT return NEW_LINE DEDENT
def sortedAfterSwap ( A , B , n ) : NEW_LINE INDENT t = 0 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( B [ i ] != 0 ) : NEW_LINE INDENT if ( A [ i ] != i + 1 ) : NEW_LINE INDENT t = A [ i ] NEW_LINE DEDENT A [ i ] = A [ i + 1 ] NEW_LINE A [ i + 1 ] = t NEW_LINE DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( A [ i ] != i + 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT
def moveSpaceInFront ( st ) : NEW_LINE INDENT i = len ( st ) - 1 NEW_LINE for j in range ( i , - 1 , - 1 ) : NEW_LINE INDENT if ( st [ j ] != ' ▁ ' ) : NEW_LINE INDENT st [ i ] = st [ j ] NEW_LINE i -= 1 NEW_LINE DEDENT DEDENT while ( i >= 0 ) : NEW_LINE INDENT st [ i ] = ' ▁ ' NEW_LINE DEDENT DEDENT
def countOfBinaryNumberLessThanN ( N ) : NEW_LINE INDENT q = queue . Queue ( ) NEW_LINE q . put ( 1 ) NEW_LINE cnt = 0 NEW_LINE while ( not q . empty ( ) ) : NEW_LINE INDENT t = q . get ( ) NEW_LINE if ( t <= N ) : NEW_LINE INDENT cnt += 1 NEW_LINE q . put ( t * 10 ) NEW_LINE q . put ( t * 10 + 1 ) NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT
def substringConversions ( str , k , b ) : NEW_LINE INDENT sum = 0 NEW_LINE counter = k - 1 NEW_LINE for i in range ( 0 , k ) : NEW_LINE INDENT sum = sum + ( ( ord ( str [ i ] ) - ord ( '0' ) * math . pow ( b , counter ) ) ) NEW_LINE counter = counter - 1 NEW_LINE DEDENT print ( sum , end = " ▁ " ) NEW_LINE prev = sum NEW_LINE sum = 0 NEW_LINE counter = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT sum = ( prev - ( ( ord ( str [ i - k ] ) - ord ( '0' ) ) * math . pow ( b , k - 1 ) ) ) NEW_LINE sum = sum * b NEW_LINE sum = sum + ( ord ( str [ i ] ) - ord ( '0' ) ) NEW_LINE print ( sum , end = " ▁ " ) NEW_LINE prev = sum NEW_LINE counter += 1 NEW_LINE DEDENT DEDENT
def longestRepeatedSubSeq ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( str [ i - 1 ] == str [ j - 1 ] and i != j ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT res = " " NEW_LINE i = n NEW_LINE j = n NEW_LINE while ( i > 0 and j > 0 ) : NEW_LINE INDENT if ( dp [ i ] [ j ] == dp [ i - 1 ] [ j - 1 ] + 1 ) : NEW_LINE INDENT res = res + str [ i - 1 ] NEW_LINE i -= 1 NEW_LINE j -= 1 NEW_LINE DEDENT elif ( dp [ i ] [ j ] == dp [ i - 1 ] [ j ] ) : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT DEDENT reverse = " " NEW_LINE for k in range ( len ( res ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT reverse = reverse + res [ k ] NEW_LINE DEDENT return reverse NEW_LINE DEDENT
def rearrange ( a , size ) : NEW_LINE INDENT positive = 0 NEW_LINE negative = 1 NEW_LINE while ( True ) : NEW_LINE INDENT while ( positive < size and a [ positive ] >= 0 ) : NEW_LINE INDENT positive += 2 NEW_LINE DEDENT while ( negative < size and a [ negative ] <= 0 ) : NEW_LINE INDENT negative += 2 NEW_LINE DEDENT if ( positive < size and negative < size ) : NEW_LINE INDENT a [ positive ] , a [ negative ] = a [ negative ] , a [ positive ] NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT
def bubbleSort ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT for j in range ( 0 , n - i - 1 ) : NEW_LINE INDENT if arr [ j ] > arr [ j + 1 ] : NEW_LINE INDENT arr [ j ] , arr [ j + 1 ] = arr [ j + 1 ] , arr [ j ] NEW_LINE DEDENT DEDENT DEDENT
def reversingString ( str , start , end ) : NEW_LINE INDENT while ( start < end ) : NEW_LINE INDENT str [ start ] ^= str [ end ] NEW_LINE str [ end ] ^= str [ start ] NEW_LINE str [ start ] ^= str [ end ] NEW_LINE start += 1 NEW_LINE end -= 1 NEW_LINE DEDENT return ' ' . join ( str ) NEW_LINE DEDENT
def minimalSteps ( s , n ) : NEW_LINE INDENT dp = [ 0 for i in range ( n ) ] NEW_LINE s1 = " " NEW_LINE s2 = " " NEW_LINE dp [ 0 ] = 1 NEW_LINE s1 += s [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT s1 += s [ i ] NEW_LINE s2 = s [ i + 1 : i + 1 ] NEW_LINE dp [ i ] = min ( dp [ i ] , dp [ i - 1 ] + 1 ) NEW_LINE if ( s1 == s2 ) : NEW_LINE INDENT dp [ i * 2 + 1 ] = min ( dp [ i ] + 1 , dp [ i * 2 + 1 ] ) NEW_LINE DEDENT DEDENT return dp [ n - 1 ] NEW_LINE DEDENT
def MinimumCost ( cost , n , W ) : NEW_LINE INDENT val = [ ] NEW_LINE wt = [ ] NEW_LINE size = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( cost [ i ] != - 1 ) : NEW_LINE INDENT val . append ( cost [ i ] ) NEW_LINE wt . append ( i + 1 ) NEW_LINE size += 1 NEW_LINE DEDENT DEDENT n = size NEW_LINE min_cost = [ [ 0 for i in range ( W + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT min_cost [ i ] [ 0 ] = 0 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , W + 1 ) : NEW_LINE INDENT if ( wt [ i - 1 ] > j ) : NEW_LINE INDENT min_cost [ i ] [ j ] = min_cost [ i - 1 ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT min_cost [ i ] [ j ] = min ( min_cost [ i - 1 ] [ j ] , min_cost [ i ] [ j - wt [ i - 1 ] ] + val [ i - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return ( min_cost [ n ] [ W ] == - 1 ) NEW_LINE DEDENT
def bitonicGenerator ( arr , n ) : NEW_LINE INDENT evenArr = [ ] NEW_LINE oddArr = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if i % 2 != 1 : NEW_LINE INDENT evenArr . append ( arr [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT oddArr . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT sort ( evenArr ) NEW_LINE sort ( oddArr ) NEW_LINE i = 0 NEW_LINE for j in range ( len ( evenArr ) ) : NEW_LINE INDENT arr [ i ] = evenArr [ j ] NEW_LINE DEDENT for j in range ( len ( oddArr ) ) : NEW_LINE INDENT arr [ i ] = oddArr [ j ] NEW_LINE DEDENT DEDENT
def printFirstRepeating ( arr ) : NEW_LINE INDENT min = - 1 NEW_LINE for i in range ( len ( arr ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] in set ) : NEW_LINE INDENT min = i NEW_LINE DEDENT else : NEW_LINE INDENT set . add ( arr [ i ] ) NEW_LINE DEDENT DEDENT if ( min != - 1 ) : NEW_LINE INDENT print ( " The ▁ first ▁ repeating ▁ element ▁ is ▁ " , arr [ min ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " There ▁ are ▁ no ▁ repeating ▁ elements " ) NEW_LINE DEDENT DEDENT
def lps ( seq ) : NEW_LINE INDENT n = len ( seq ) NEW_LINE L = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT L [ i ] [ i ] = 1 NEW_LINE DEDENT for cl in range ( 2 , n + 1 ) : NEW_LINE INDENT for i in range ( n - cl + 1 ) : NEW_LINE INDENT j = i + cl - 1 NEW_LINE if ( seq [ i ] == seq [ j ] and cl == 2 ) : NEW_LINE INDENT L [ i ] [ j ] = 2 NEW_LINE DEDENT elif ( seq [ i ] == seq [ j ] ) : NEW_LINE INDENT L [ i ] [ j ] = L [ i + 1 ] [ j - 1 ] + 2 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] = max ( L [ i ] [ j - 1 ] , L [ i + 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return L [ 0 ] [ n - 1 ] NEW_LINE DEDENT
def censor ( text , word ) : NEW_LINE INDENT word_list = list ( text ) NEW_LINE result = " " NEW_LINE stars = " " NEW_LINE for i in range ( len ( word ) ) : NEW_LINE INDENT stars += ' * ' NEW_LINE DEDENT index = 0 NEW_LINE for i in range ( len ( word_list ) ) : NEW_LINE INDENT if ( i == word ) : NEW_LINE INDENT word_list [ index ] = stars NEW_LINE DEDENT index += 1 NEW_LINE DEDENT for i in word_list : NEW_LINE INDENT result += i + ' ▁ ' NEW_LINE DEDENT return result NEW_LINE DEDENT
def isRotated ( str1 , str2 ) : NEW_LINE INDENT if len ( str1 ) != len ( str2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT clock_rot = " " NEW_LINE anticlock_rot = " " NEW_LINE len = len ( str2 ) NEW_LINE anticlock_rot = anticlock_rot + str2 [ len - 2 : len ] + str2 [ 0 : len - 2 ] NEW_LINE clock_rot = clock_rot + str2 [ 2 : 2 ] + str2 [ 0 : 2 ] NEW_LINE return ( str1 == clock_rot or str1 == anticlock_rot ) NEW_LINE DEDENT
def findDiff ( arr , n ) : NEW_LINE INDENT mp = defaultdict ( lambda : 0 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] in mp ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT max_count = 0 NEW_LINE min_count = n NEW_LINE for x in mp : NEW_LINE INDENT max_count = max ( max_count , x [ 1 ] ) NEW_LINE min_count = min ( min_count , x [ 1 ] ) NEW_LINE DEDENT return ( max_count - min_count ) NEW_LINE DEDENT
def playGame ( arr ) : NEW_LINE INDENT set = set ( ) NEW_LINE for i in arr : NEW_LINE INDENT set . add ( i ) NEW_LINE DEDENT if ( len ( set ) % 2 == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 2 NEW_LINE DEDENT DEDENT
def subset ( arr , n ) : NEW_LINE INDENT mp = defaultdict ( lambda : 0 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] = mp [ arr [ i ] ] + 1 NEW_LINE DEDENT res = 0 NEW_LINE for entry in mp : NEW_LINE INDENT res = max ( res , entry [ 1 ] ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def isProduct ( arr , n , x ) : NEW_LINE INDENT set = set ( ) NEW_LINE if n < 2 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if arr [ i ] == 0 : NEW_LINE INDENT if x == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT continue NEW_LINE DEDENT DEDENT if x % arr [ i ] == 0 : NEW_LINE INDENT if set [ x // arr [ i ] ] in set : NEW_LINE INDENT return True NEW_LINE DEDENT hset . add ( arr [ i ] ) NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def findRotations ( str ) : NEW_LINE INDENT tmp = str + str NEW_LINE n = len ( str ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT substring = tmp [ i : ] NEW_LINE if ( str == substring ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return n NEW_LINE DEDENT
def randomize ( arr , n ) : NEW_LINE INDENT r = Random ( ) NEW_LINE i = n - 1 NEW_LINE while ( i > 0 ) : NEW_LINE INDENT j = r . nextInt ( i + 1 ) NEW_LINE arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ] NEW_LINE i -= 1 NEW_LINE DEDENT print ( arr ) NEW_LINE DEDENT
def translate ( st ) : NEW_LINE INDENT l = len ( st ) NEW_LINE if l < 2 : NEW_LINE INDENT return NEW_LINE DEDENT i = 0 NEW_LINE j = 0 NEW_LINE while ( j < l - 1 ) : NEW_LINE INDENT if ( st [ j ] == ' A ' and st [ j + 1 ] == ' B ' ) : NEW_LINE INDENT j = j + 2 NEW_LINE str [ i ] = ' C ' NEW_LINE continue NEW_LINE DEDENT str [ i ] = st [ j ] NEW_LINE j += 1 NEW_LINE DEDENT if ( j == l - 1 ) : NEW_LINE INDENT st [ i ] = st [ j ] NEW_LINE i += 1 NEW_LINE DEDENT st [ i ] = ' ▁ ' NEW_LINE st [ l - 1 ] = ' ▁ ' NEW_LINE st [ l - 1 ] = ' ▁ ' NEW_LINE DEDENT
def numberofways ( A , B , N , M ) : NEW_LINE INDENT pos = [ ] NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT pos [ i ] = [ ] NEW_LINE DEDENT for i in range ( M ) : NEW_LINE INDENT pos [ B [ i ] ] . append ( i + 1 ) NEW_LINE DEDENT dpl = [ [ 0 for i in range ( M + 2 ) ] for j in range ( 1 , N + 1 ) ] NEW_LINE for i in range ( 1 , M + 1 ) : NEW_LINE INDENT if ( A [ i - 1 ] == B [ j - 1 ] ) : NEW_LINE INDENT dpl [ i ] [ j ] = dpl [ i - 1 ] [ j - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT dpl [ i ] [ j ] = max ( dpl [ i - 1 ] [ j ] , dpl [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT LCS = dpl [ N ] [ M ] NEW_LINE dpr = [ [ 0 for i in range ( N + 1 ) ] NEW_LINE for j in range ( M ) : NEW_LINE INDENT if ( A [ i - 1 ] == B [ j - 1 ] ) : NEW_LINE INDENT dpr [ i ] [ j ] = dpr [ i + 1 ] [ j + 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT dpr [ i ] [ j ] = max ( dpr [ i + 1 ] [ j ] , dpr [ i ] [ j + 1 ] ) NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT for j in range ( MAX ) : NEW_LINE INDENT if ( dpl [ i ] [ x - 1 ] + dpr [ i + 1 ] [ x + 1 ] == LCS ) : NEW_LINE INDENT ans += 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def substringConversions ( str , k , b ) : NEW_LINE INDENT for i in range ( 0 , len ( str ) - 1 , - 1 ) : NEW_LINE INDENT sub = str [ i : i + k ] NEW_LINE sum = 0 NEW_LINE counter = 0 NEW_LINE for j in range ( len ( sub ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT sum = ( sum + ( ord ( sub [ j ] ) - ord ( '0' ) ) * pow ( b , counter ) ) NEW_LINE counter = counter + 1 NEW_LINE DEDENT print ( sum , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def SumOfKsubArray ( arr , k ) : NEW_LINE INDENT s = deque ( ) NEW_LINE G = deque ( ) NEW_LINE sum = 0 NEW_LINE S = deque ( ) NEW_LINE for i in range ( k ) : NEW_LINE INDENT while ( len ( S ) != 0 and arr [ S [ - 1 ] ] >= arr [ i ] ) : NEW_LINE INDENT S . popleft ( ) NEW_LINE DEDENT while ( len ( G ) != 0 and arr [ G [ - 1 ] ] <= arr [ i ] ) : NEW_LINE INDENT G . popleft ( ) NEW_LINE DEDENT G . append ( i ) NEW_LINE S . append ( i ) NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT sum += arr [ S [ - 1 ] ] + arr [ G [ - 1 ] ] NEW_LINE while ( len ( S ) != 0 and S [ - 1 ] <= i - k ) : NEW_LINE INDENT S . popleft ( ) NEW_LINE DEDENT while ( len ( S ) != 0 and arr [ S [ - 1 ] ] >= arr [ i ] ) : NEW_LINE INDENT S . popleft ( ) NEW_LINE DEDENT while ( len ( G ) != 0 and arr [ G [ - 1 ] ] <= arr [ i ] ) : NEW_LINE INDENT G . popleft ( ) NEW_LINE DEDENT G . append ( i ) NEW_LINE S . append ( i ) NEW_LINE DEDENT sum += arr [ S [ - 1 ] ] + arr [ G [ - 1 ] ] NEW_LINE return sum NEW_LINE DEDENT
def arrangeString ( str ) : NEW_LINE INDENT char_count = [ 0 ] * MAX_CHAR NEW_LINE sum = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] . isupper ( ) ) : NEW_LINE INDENT char_count [ ord ( str [ i ] ) - ord ( ' A ' ) ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT sum = sum + ( ord ( str [ i ] ) - ord ( '0' ) ) NEW_LINE DEDENT DEDENT res = " " NEW_LINE for i in range ( MAX_CHAR ) : NEW_LINE INDENT ch = ord ( ' A ' ) + i NEW_LINE while ( char_count [ i ] ) : NEW_LINE INDENT res = res + ch NEW_LINE DEDENT DEDENT if ( sum > 0 ) : NEW_LINE INDENT res = res + sum NEW_LINE DEDENT return res NEW_LINE DEDENT
def waysToIncreaseLCSBy1 ( str1 , str2 ) : NEW_LINE INDENT m = len ( str1 ) NEW_LINE n = len ( str2 ) NEW_LINE position = [ [ 0 for i in range ( M ) ] for j in range ( n + 2 ) ] NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT position [ i ] = [ 0 ] * ( M + 1 ) NEW_LINE DEDENT for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( str1 [ i - 1 ] == str2 [ j - 1 ] ) : NEW_LINE INDENT lcsl [ i ] [ j ] = 1 + lcsl [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT lcsl [ i ] [ j ] = max ( lcsl [ i - 1 ] [ j ] , lcsl [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT for i in range ( m , 1 , - 1 ) : NEW_LINE INDENT for j in range ( n , 1 , - 1 ) : NEW_LINE INDENT if ( str1 [ i - 1 ] == str2 [ j - 1 ] ) : NEW_LINE INDENT lcsr [ i ] [ j ] = 1 + lcsr [ i + 1 ] [ j + 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT lcsr [ i ] [ j ] = max ( lcsr [ i + 1 ] [ j ] , lcsr [ i ] [ j + 1 ] ) NEW_LINE DEDENT DEDENT DEDENT ways = 0 NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for d in range ( 26 ) : NEW_LINE INDENT for j in range ( len ( position [ d ] ) : NEW_LINE INDENT for j in range ( len ( position [ d ] ) : NEW_LINE INDENT p = position [ d ] [ j ] NEW_LINE DEDENT DEDENT DEDENT
def lis ( arr , n ) : NEW_LINE INDENT lis = [ 0 ] * n NEW_LINE max = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT lis [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and lis [ i ] < lis [ j ] + 1 ) : NEW_LINE INDENT lis [ i ] = lis [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( max < lis [ i ] ) : NEW_LINE INDENT max = lis [ i ] NEW_LINE DEDENT DEDENT return max NEW_LINE DEDENT
def SternSequenceFunc ( BrocotSequence , n ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT considered_element = BrocotSequence [ i ] NEW_LINE precedent = BrocotSequence [ i - 1 ] NEW_LINE BrocotSequence [ considered_element ] = considered_element + precedent NEW_LINE BrocotSequence [ considered_element ] = considered_element NEW_LINE DEDENT for i in range ( 15 ) : NEW_LINE INDENT print ( BrocotSequence [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def printBracketNumber ( exp , n ) : NEW_LINE INDENT left_bnum = 1 NEW_LINE right_bnum = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( exp [ i ] == ' ( ' ) : NEW_LINE INDENT print ( left_bnum , end = " ▁ " ) NEW_LINE right_bnum . append ( left_bnum ) NEW_LINE left_bnum += 1 NEW_LINE DEDENT elif ( exp [ i ] == ' ) ' ) : NEW_LINE INDENT print ( right_bnum [ - 1 ] , end = " ▁ " ) NEW_LINE right_bnum . pop ( ) NEW_LINE DEDENT DEDENT DEDENT
def returnMaxSum ( A , B , n ) : NEW_LINE INDENT mp = set ( ) NEW_LINE result = 0 NEW_LINE curr_sum = 0 NEW_LINE curr_begin = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT while ( A [ i ] in mp ) : NEW_LINE INDENT mp . remove ( A [ curr_begin ] ) NEW_LINE curr_sum -= B [ curr_begin ] NEW_LINE curr_begin += 1 NEW_LINE DEDENT mp . add ( A [ i ] ) NEW_LINE curr_sum += B [ i ] NEW_LINE result = max ( result , curr_sum ) NEW_LINE DEDENT return result NEW_LINE DEDENT
def rearrange ( arr , n ) : NEW_LINE INDENT i = - 1 NEW_LINE temp = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( arr [ j ] < 0 ) : NEW_LINE INDENT i += 1 NEW_LINE temp = arr [ i ] NEW_LINE arr [ i ] = arr [ j ] NEW_LINE arr [ j ] = temp NEW_LINE DEDENT DEDENT pos = i + 1 NEW_LINE neg = 0 NEW_LINE while ( pos < n and neg < pos and arr [ neg ] < 0 ) : NEW_LINE INDENT arr [ neg ] , arr [ pos ] = arr [ pos ] , arr [ neg ] NEW_LINE pos += 1 NEW_LINE neg += 2 NEW_LINE DEDENT DEDENT
def largestGCDSubsequence ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE maxele = max ( arr ) NEW_LINE for i in range ( 2 , maxele + 1 ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if arr [ j ] % i == 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT ans = max ( ans , count ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def isNumber ( s ) : NEW_LINE INDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] != '0' ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def countPairs ( arr1 , arr2 , m , n , x ) : NEW_LINE INDENT count = 0 NEW_LINE us = set ( ) NEW_LINE for i in range ( 0 , m ) : NEW_LINE INDENT us . add ( arr1 [ i ] ) NEW_LINE DEDENT for j in range ( 0 , n ) : NEW_LINE INDENT if ( x - arr2 [ j ] ) in us : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def lis ( arr , n ) : NEW_LINE INDENT lis = [ 0 ] * n NEW_LINE max = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT lis [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and lis [ i ] < lis [ j ] + 1 ) : NEW_LINE INDENT lis [ i ] = lis [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( max < lis [ i ] ) : NEW_LINE INDENT max = lis [ i ] NEW_LINE DEDENT DEDENT return max NEW_LINE DEDENT
def findSubString ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE dist_count = 0 NEW_LINE visited = [ 0 ] * MAX_CHARS NEW_LINE for i in range ( n ) : NEW_LINE INDENT visited [ ord ( str [ i ] ) ] = False NEW_LINE dist_count += 1 NEW_LINE DEDENT DEDENT start = 0 NEW_LINE start_index = - 1 NEW_LINE min_len = sys . maxsize NEW_LINE count = 0 NEW_LINE curr_count = [ 0 ] * MAX_CHARS NEW_LINE for j in range ( n ) : NEW_LINE INDENT curr_count [ ord ( str [ j ] ) ] += 1 NEW_LINE if curr_count [ ord ( str [ j ] ) ] == 1 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( count == dist_count ) : NEW_LINE INDENT while curr_count [ ord ( str [ start ] ) ] > 1 : NEW_LINE INDENT if curr_count [ ord ( str [ start ] ) ] > 1 : NEW_LINE INDENT curr_count [ ord ( str [ start ] ) ] -= 1 NEW_LINE start += 1 NEW_LINE DEDENT DEDENT len_window = j - start + 1 NEW_LINE if ( min_len > len_window ) : NEW_LINE INDENT min_len = len_window NEW_LINE start_index = start NEW_LINE DEDENT DEDENT DEDENT return str [ start_index : start_index + min_len ] NEW_LINE DEDENT
def printSubsequences ( arr , n ) : NEW_LINE INDENT opsize = ( int ) ( math . pow ( 2 , n ) ) NEW_LINE for counter in range ( 1 , opsize ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT if ( BigInteger . valueOf ( counter ) . testBit ( j ) ) : NEW_LINE INDENT print ( arr [ j ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT
def bin ( n ) : NEW_LINE INDENT if n > 1 : NEW_LINE INDENT bin ( n >> 1 ) NEW_LINE DEDENT print ( " % d " , n & 1 ) NEW_LINE DEDENT
def minimumSquare ( a , b ) : NEW_LINE INDENT result = 0 NEW_LINE rem = 0 NEW_LINE if a < b : NEW_LINE INDENT swap ( a , b ) NEW_LINE DEDENT while ( b > 0 ) : NEW_LINE INDENT result += a // b NEW_LINE rem = a % b NEW_LINE a = b NEW_LINE b = rem NEW_LINE DEDENT return result NEW_LINE DEDENT
def deleteElements ( arr , n , k ) : NEW_LINE INDENT s = [ ] NEW_LINE s . append ( arr [ 0 ] ) NEW_LINE count = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT while ( len ( s ) > 0 and s [ - 1 ] < arr [ i ] and count < k ) : NEW_LINE INDENT s . pop ( ) NEW_LINE count += 1 NEW_LINE DEDENT s . append ( arr [ i ] ) NEW_LINE DEDENT m = len ( s ) NEW_LINE v = [ 0 ] * m NEW_LINE while ( len ( s ) != 0 ) : NEW_LINE INDENT v [ m ] = s [ - 1 ] NEW_LINE s . pop ( ) NEW_LINE DEDENT for x in v : NEW_LINE INDENT print ( x , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT
def first ( str ) : NEW_LINE INDENT for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] . isupper ( ) ) : NEW_LINE INDENT return str [ i ] NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT
def isPossible ( n , index , modulo , M , arr , dp ) : NEW_LINE INDENT if index == n : NEW_LINE INDENT if ( modulo == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT if ( dp [ index ] [ modulo ] != - 1 ) : NEW_LINE INDENT return dp [ index ] [ modulo ] NEW_LINE DEDENT placeAdd = isPossible ( n , index + 1 , modulo + arr [ index ] , M , arr , dp ) NEW_LINE placeMinus = isPossible ( n , index + 1 , modulo - arr [ index ] , M , arr , dp ) NEW_LINE res = placeAdd NEW_LINE dp [ index ] [ modulo ] = res NEW_LINE return res NEW_LINE DEDENT
def amendSentence ( sstr ) : NEW_LINE INDENT for i in range ( len ( sstr ) ) : NEW_LINE INDENT if ( str [ i ] >= ' A ' and str [ i ] <= ' Z ' ) : NEW_LINE INDENT str [ i ] = chr ( str [ i ] + 32 ) NEW_LINE if ( i != 0 ) : NEW_LINE INDENT print ( " ▁ " , end = " " ) NEW_LINE DEDENT print ( str [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( str [ i ] ) NEW_LINE DEDENT DEDENT DEDENT
def find ( a , b , k , n1 , n2 ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( n2 ) : NEW_LINE INDENT s . add ( b [ i ] ) NEW_LINE DEDENT missing = 0 NEW_LINE for i in range ( n1 ) : NEW_LINE INDENT if ( a [ i ] not in s ) : NEW_LINE INDENT missing += 1 NEW_LINE DEDENT if ( missing == k ) : NEW_LINE INDENT return a [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def countNumber ( n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 1 , 9 ) : NEW_LINE INDENT s = [ ] NEW_LINE if ( i <= n ) : NEW_LINE INDENT s . append ( i ) NEW_LINE result += 1 NEW_LINE DEDENT while ( len ( s ) != 0 ) : NEW_LINE INDENT tp = s [ - 1 ] NEW_LINE s . pop ( ) NEW_LINE for j in range ( tp % 10 , 9 ) : NEW_LINE INDENT x = tp * 10 + j NEW_LINE if ( x <= n ) : NEW_LINE INDENT s . append ( x ) NEW_LINE result += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
def getMaxOccuringChar ( str ) : NEW_LINE INDENT count = [ 0 for i in range ( ASCII_SIZE ) ] NEW_LINE len = len ( str ) NEW_LINE for i in range ( len ) : NEW_LINE INDENT count [ ord ( str [ i ] ) ] += 1 NEW_LINE DEDENT max = - 1 NEW_LINE result = ' ▁ ' NEW_LINE for i in range ( len ) : NEW_LINE INDENT if ( max < count [ ord ( str [ i ] ) ] ) : NEW_LINE INDENT max = count [ ord ( str [ i ] ) ] NEW_LINE result = str [ i ] NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def getMinDiff ( arr , n , k ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT arr . sort ( ) NEW_LINE ans = arr [ n - 1 ] - arr [ 0 ] NEW_LINE small = arr [ 0 ] + k NEW_LINE big = arr [ n - 1 ] - k NEW_LINE temp = 0 NEW_LINE if ( small > big ) : NEW_LINE INDENT temp = small NEW_LINE small = big NEW_LINE big = temp NEW_LINE DEDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT subtract = arr [ i ] - k NEW_LINE add = arr [ i ] + k NEW_LINE if ( subtract >= small or add <= big ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( big - subtract <= add - small ) : NEW_LINE INDENT small = subtract NEW_LINE DEDENT else : NEW_LINE INDENT big = add NEW_LINE DEDENT DEDENT return min ( ans , big - small ) NEW_LINE DEDENT
def printkthnode ( adj , wt , n , k ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT adj . sort ( ) NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( adj [ i ] [ 0 ] >= k ) : NEW_LINE INDENT print ( adj [ i ] [ 0 ] , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT DEDENT DEDENT
def commonCharacters ( Str , n ) : NEW_LINE INDENT prim = [ False for i in range ( MAX_CHAR ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT prim . append ( True ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT sec = [ False for i in range ( MAX_CHAR ) ] NEW_LINE for j in range ( len ( Str [ i ] ) ) : NEW_LINE INDENT if ( prim [ ord ( Str [ i ] [ j ] ) - ord ( ' a ' ) ] ) : NEW_LINE INDENT sec [ ord ( Str [ i ] [ j ] ) - ord ( ' a ' ) ] = True NEW_LINE DEDENT DEDENT print ( " " , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def canMakeStr2 ( str1 , str2 ) : NEW_LINE INDENT count = [ 0 ] * MAX NEW_LINE for i in range ( len ( str1 ) ) : NEW_LINE INDENT count [ ord ( str1 [ i ] ) ] += 1 NEW_LINE DEDENT str4 = list ( str2 ) NEW_LINE for i in range ( len ( str4 ) ) : NEW_LINE INDENT if ( count [ ord ( str4 [ i ] ) ] == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT count [ ord ( str4 [ i ] ) ] -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT
def count ( a , b , m , n ) : NEW_LINE INDENT if ( ( m == 0 and n == 0 ) or n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( m == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( a [ m - 1 ] == b [ n - 1 ] ) : NEW_LINE INDENT return count ( a , b , m - 1 , n - 1 ) + count ( a , b , m - 1 , n ) NEW_LINE DEDENT else : NEW_LINE INDENT return count ( a , b , m - 1 , n ) NEW_LINE DEDENT DEDENT
def numofArray ( n , m ) : NEW_LINE INDENT dp = [ [ 0 for j in range ( MAX ) ] for i in range ( MAX ) ] NEW_LINE di = [ [ 0 for i in range ( MAX ) ] for j in range ( MAX ) ] NEW_LINE mu = [ [ 0 for i in range ( MAX ) ] for j in range ( MAX ) ] NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT di [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT for i in range ( 1 , m + 1 ) : NEW_LINE INDENT dp [ 1 ] [ i ] = 1 NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , m + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = 0 NEW_LINE for x in di [ j ] : NEW_LINE INDENT dp [ i ] [ j ] += dp [ i - 1 ] [ x ] NEW_LINE DEDENT for x in mu [ j ] : NEW_LINE INDENT dp [ i ] [ j ] += dp [ i - 1 ] [ x ] NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT ans += dp [ n ] [ i ] NEW_LINE di [ i ] . clear ( ) NEW_LINE mu [ i ] . clear ( ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def findSubarraySum ( arr , n ) : NEW_LINE INDENT mp = defaultdict ( lambda : 0 ) NEW_LINE res = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT Sum = 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT Sum += arr [ j ] NEW_LINE if ( Sum in mp ) : NEW_LINE INDENT mp [ Sum ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ Sum ] = 1 NEW_LINE DEDENT DEDENT DEDENT for x in mp : NEW_LINE INDENT if ( mp [ x ] == 1 ) : NEW_LINE INDENT res += x NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def findpath ( graph , n ) : NEW_LINE INDENT numofadj = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT numofadj . append ( accumulate ( graph [ i ] , 0 ) ) NEW_LINE DEDENT startPoint = 0 NEW_LINE numofodd = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( numofadj [ i ] % 2 == 1 ) : NEW_LINE INDENT numofodd += 1 NEW_LINE startPoint = i NEW_LINE DEDENT DEDENT if ( numofodd > 2 ) : NEW_LINE INDENT print ( " No ▁ Solution " ) NEW_LINE return NEW_LINE DEDENT stack = [ ] NEW_LINE path = [ ] NEW_LINE cur = startPoint NEW_LINE while ( len ( stack ) != 0 or accumulate ( graph [ cur ] , 0 ) == 0 ) : NEW_LINE INDENT path . append ( cur ) NEW_LINE cur = stack . pop ( ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( graph [ cur ] [ i ] == 1 ) : NEW_LINE INDENT stack . append ( cur ) NEW_LINE graph [ cur ] [ i ] = 0 NEW_LINE graph [ i ] [ cur ] = 0 NEW_LINE cur = i NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT for ele in path : NEW_LINE INDENT print ( ele , end = " ▁ - > ▁ " ) NEW_LINE DEDENT print ( cur ) NEW_LINE DEDENT
def sumBetweenTwoKth ( arr , k1 , k2 ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE result = 0 NEW_LINE for i in range ( k1 , k2 - 1 ) : NEW_LINE INDENT result += arr [ i ] NEW_LINE DEDENT return result NEW_LINE DEDENT
def calculate ( a , n ) : NEW_LINE INDENT maximum = max ( a ) NEW_LINE frequency = [ 0 ] * ( maximum + 1 ) NEW_LINE answer = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT frequency [ a [ i ] ] += 1 NEW_LINE DEDENT answer = 0 NEW_LINE for i in range ( 0 , ( maximum ) + 1 ) : NEW_LINE INDENT answer = answer + frequency [ i ] * ( frequency [ i ] - 1 ) NEW_LINE DEDENT return answer // 2 NEW_LINE DEDENT
def sumNodes ( l ) : NEW_LINE INDENT leafNodeCount = ( int ) ( math . pow ( 2 , l - 1 ) ) NEW_LINE vec = [ ] NEW_LINE for i in range ( 1 , l + 1 ) : NEW_LINE INDENT vec . append ( [ 0 ] * ( leafNodeCount + 1 ) ) NEW_LINE DEDENT for i in range ( 1 , leafNodeCount + 1 ) : NEW_LINE INDENT vec [ l - 1 ] . append ( i ) NEW_LINE DEDENT for i in range ( l - 2 , - 1 , - 1 ) : NEW_LINE INDENT k = 0 NEW_LINE while ( k < len ( vec [ i + 1 ] ) - 1 ) : NEW_LINE INDENT vec [ i ] . append ( vec [ i + 1 ] [ k ] + vec [ i + 1 ] [ k + 1 ] ) NEW_LINE k += 2 NEW_LINE DEDENT DEDENT sum = 0 NEW_LINE for i in range ( l ) : NEW_LINE INDENT for j in range ( len ( vec [ i ] ) ) : NEW_LINE INDENT sum += vec [ i ] [ j ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def encrypt ( text , s ) : NEW_LINE INDENT result = [ ] NEW_LINE for i in range ( len ( text ) ) : NEW_LINE INDENT if ( text [ i ] . isupper ( ) ) : NEW_LINE INDENT ch = ( char ) ( ( ( int ) text [ i ] + s - 65 ) % 26 + 65 ) NEW_LINE result . append ( ch ) NEW_LINE DEDENT else : NEW_LINE INDENT ch = ( char ) ( ( ( int ) text [ i ] + s - 97 ) % 26 + 97 ) NEW_LINE result . append ( ch ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT return b NEW_LINE DEDENT if b == 0 : NEW_LINE INDENT return a NEW_LINE DEDENT k = 0 NEW_LINE while ( ( a | b ) & 1 ) == 0 : NEW_LINE INDENT a >>= 1 NEW_LINE b >>= 1 NEW_LINE DEDENT while ( ( a & 1 ) == 0 ) : NEW_LINE INDENT a >>= 1 NEW_LINE DEDENT while ( ( b & 1 ) == 0 ) : NEW_LINE INDENT b >>= 1 NEW_LINE DEDENT while ( a & 1 ) : NEW_LINE INDENT b >>= 1 NEW_LINE DEDENT while ( b & 1 ) : NEW_LINE INDENT b >>= 1 NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT a = b NEW_LINE b = temp NEW_LINE DEDENT b = ( b - a ) NEW_LINE DEDENT return a << k NEW_LINE DEDENT
def calculateSum ( arr , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT s = arr [ 0 ] NEW_LINE value = int ( s ) NEW_LINE sum = value NEW_LINE i = 2 NEW_LINE while i < n : NEW_LINE INDENT s = arr [ i ] NEW_LINE value = int ( s ) NEW_LINE operation = arr [ i - 1 ] [ 0 ] NEW_LINE if ( operation == ' + ' ) : NEW_LINE INDENT sum += value NEW_LINE DEDENT else : NEW_LINE INDENT sum -= value NEW_LINE DEDENT i = i + 2 NEW_LINE DEDENT return sum NEW_LINE DEDENT
def replace ( s , c1 , c2 ) : NEW_LINE INDENT l = len ( s ) NEW_LINE arr = list ( s ) NEW_LINE for i in range ( l ) : NEW_LINE INDENT if arr [ i ] == c1 : NEW_LINE INDENT arr [ i ] = c2 NEW_LINE DEDENT elif arr [ i ] == c2 : NEW_LINE INDENT arr [ i ] = c1 NEW_LINE DEDENT DEDENT return ' ' . join ( arr ) NEW_LINE DEDENT
def lexicographicSubConcat ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE sub_count = int ( ( n + 1 ) / 2 ) NEW_LINE arr = [ " " ] * ( sub_count + 1 ) NEW_LINE index = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for l in range ( 1 , n - i + 1 ) : NEW_LINE INDENT arr [ index ] = s [ i : i + len ] NEW_LINE DEDENT DEDENT arr . sort ( ) NEW_LINE res = " " NEW_LINE for i in range ( 0 , sub_count ) : NEW_LINE INDENT res += arr [ i ] NEW_LINE DEDENT return res NEW_LINE DEDENT
def findpos ( n ) : NEW_LINE INDENT k = 0 NEW_LINE pos = 0 NEW_LINE i = 0 NEW_LINE while ( k != len ( n ) ) : NEW_LINE INDENT switch ( n [ i ] ) : NEW_LINE INDENT case '4' : NEW_LINE INDENT pos = pos * 2 + 1 NEW_LINE break NEW_LINE DEDENT case '7' : NEW_LINE INDENT pos = pos * 2 + 2 NEW_LINE break NEW_LINE DEDENT i += 1 NEW_LINE k += 1 NEW_LINE DEDENT return pos NEW_LINE DEDENT
def lis ( arr , n ) : NEW_LINE INDENT mpis = [ 0 ] * n NEW_LINE max = - sys . maxsize - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT mpis [ i ] = arr [ i ] NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and mpis [ i ] < ( mpis [ j ] * arr [ i ] ) ) : NEW_LINE INDENT mpis [ i ] = mpis [ j ] * arr [ i ] NEW_LINE DEDENT DEDENT DEDENT for k in range ( len ( mpis ) ) : NEW_LINE INDENT if ( mpis [ k ] > max ) : NEW_LINE INDENT max = mpis [ k ] NEW_LINE DEDENT DEDENT DEDENT return max NEW_LINE DEDENT
def checkSorted ( q ) : NEW_LINE INDENT st = [ ] NEW_LINE expected = 1 NEW_LINE while ( not q . empty ( ) ) : NEW_LINE INDENT fnt = q . get ( ) NEW_LINE if ( fnt == expected ) : NEW_LINE INDENT expected += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( len ( st ) == 0 ) : NEW_LINE INDENT st . append ( fnt ) NEW_LINE DEDENT elif ( len ( st ) != 0 and st [ 0 ] < fnt ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT st . append ( fnt ) NEW_LINE DEDENT DEDENT while ( len ( st ) != 0 and st [ 0 ] == expected ) : NEW_LINE INDENT st . pop ( ) NEW_LINE expected += 1 NEW_LINE DEDENT DEDENT if ( expected - 1 == n and len ( st ) == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def generate ( st , s ) : NEW_LINE INDENT if ( len ( s ) == 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( s [ 0 ] == " " ) : NEW_LINE INDENT return NEW_LINE DEDENT for i in range ( len ( s ) ) : NEW_LINE INDENT t = s NEW_LINE t = t [ 0 : i ] + t [ i + 1 : ] NEW_LINE generate ( st , t ) NEW_LINE DEDENT DEDENT return NEW_LINE DEDENT
def minLexRotation ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE arr = [ None ] * n NEW_LINE concat = str + str NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT arr [ i ] = concat [ i : i + n ] NEW_LINE DEDENT arr . sort ( ) NEW_LINE return arr [ 0 ] NEW_LINE DEDENT
def isPossible ( a , b , n , k ) : NEW_LINE INDENT a . sort ( reverse = True ) NEW_LINE b . sort ( reverse = True ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if a [ i ] + b [ i ] < k : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def isCornerPresent ( str , corner ) : NEW_LINE INDENT n = len ( str ) NEW_LINE cl = len ( corner ) NEW_LINE if n < cl : NEW_LINE INDENT return False NEW_LINE DEDENT return ( str [ 0 : cl ] == corner and str [ n - cl : n ] . equals ( corner ) ) NEW_LINE DEDENT
def longDivision ( number , divisor ) : NEW_LINE INDENT ans = " " NEW_LINE idx = 0 NEW_LINE num = list ( number ) NEW_LINE temp = num [ idx ] - ord ( '0' ) NEW_LINE while ( temp < divisor ) : NEW_LINE INDENT temp = ( temp * 10 + ( num [ idx ] - ord ( '0' ) ) NEW_LINE idx += 1 NEW_LINE while ( num . length > idx ) : NEW_LINE INDENT ans += ( temp / divisor ) NEW_LINE temp = ( temp % divisor ) * 10 + num [ idx ] - ord ( '0' ) ) NEW_LINE idx += 1 NEW_LINE DEDENT if ( len ( ans ) == 0 ) : NEW_LINE INDENT return "0" NEW_LINE DEDENT return ans NEW_LINE DEDENT
def sort012 ( a , arr_size ) : NEW_LINE INDENT lo = 0 NEW_LINE hi = arr_size - 1 NEW_LINE mid = 0 NEW_LINE temp = 0 NEW_LINE while ( mid <= hi ) : NEW_LINE INDENT switch ( a [ mid ] ) : NEW_LINE INDENT case 0 : NEW_LINE INDENT a [ lo ] , a [ mid ] = a [ mid ] , a [ lo ] NEW_LINE lo += 1 NEW_LINE mid += 1 NEW_LINE break NEW_LINE DEDENT case 1 : NEW_LINE INDENT mid += 1 NEW_LINE break NEW_LINE DEDENT case 2 : NEW_LINE INDENT a [ mid ] , a [ hi ] = a [ hi ] , a [ mid ] NEW_LINE hi -= 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT
def canRepresentBST ( pre , n ) : NEW_LINE INDENT s = [ ] NEW_LINE root = - sys . maxsize - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( pre [ i ] < root ) : NEW_LINE INDENT return False NEW_LINE DEDENT while ( len ( s ) and s [ - 1 ] < pre [ i ] ) : NEW_LINE INDENT root = s [ - 1 ] NEW_LINE s . pop ( ) NEW_LINE DEDENT s . append ( pre [ i ] ) NEW_LINE DEDENT return True NEW_LINE DEDENT
def solveQuery ( start , end , arr ) : NEW_LINE INDENT mp = defaultdict ( lambda : 0 ) NEW_LINE for i in range ( start , end + 1 ) : NEW_LINE INDENT mp [ arr [ i ] ] = mp [ arr [ i ] ] + 1 NEW_LINE DEDENT count = 0 NEW_LINE for entry in mp : NEW_LINE INDENT if ( arr [ i ] in mp ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def divisibleBy20 ( num ) : NEW_LINE INDENT lastTwoDigits = int ( num [ len ( num ) - 2 : ] ) NEW_LINE return ( ( lastTwoDigits % 5 == 0 ) and ( lastTwoDigits % 4 == 0 ) ) NEW_LINE DEDENT
def CountTriangles ( A ) : NEW_LINE INDENT n = len ( A ) NEW_LINE A . sort ( ) NEW_LINE count = 0 NEW_LINE for i in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT l = 0 NEW_LINE r = i - 1 NEW_LINE while ( l < r ) : NEW_LINE INDENT if ( A [ l ] + A [ r ] > A [ i ] ) : NEW_LINE INDENT count += r - l NEW_LINE r -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT l += 1 NEW_LINE DEDENT DEDENT DEDENT print ( " No ▁ of ▁ possible ▁ solutions : ▁ { 0 : d } " . format ( count ) ) NEW_LINE DEDENT
def countFreq ( arr , n ) : NEW_LINE INDENT hm = defaultdict ( lambda : 0 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT hm [ arr [ i ] ] = hm [ arr [ i ] ] + 1 NEW_LINE DEDENT st = defaultdict ( lambda : 0 ) NEW_LINE for key , values in hm . items ( ) : NEW_LINE INDENT st . add ( key , values ) NEW_LINE DEDENT cumul = 0 NEW_LINE for x in st : NEW_LINE INDENT cumul += x NEW_LINE print ( key , ' ▁ ' , cumul ) NEW_LINE DEDENT DEDENT
def cocktailSort ( a ) : NEW_LINE INDENT swapped = True NEW_LINE start = 0 NEW_LINE end = len ( a ) NEW_LINE while ( swapped == True ) : NEW_LINE INDENT swapped = False NEW_LINE for i in range ( start , end - 1 ) : NEW_LINE INDENT if ( a [ i ] > a [ i + 1 ] ) : NEW_LINE INDENT a [ i ] , a [ i + 1 ] = a [ i + 1 ] , a [ i ] NEW_LINE swapped = True NEW_LINE DEDENT DEDENT if ( swapped == False ) : NEW_LINE INDENT break NEW_LINE DEDENT swapped = False NEW_LINE end = end - 1 NEW_LINE for i in range ( end - 1 , start , - 1 ) : NEW_LINE INDENT if ( a [ i ] > a [ i + 1 ] ) : NEW_LINE INDENT a [ i ] , a [ i + 1 ] = a [ i + 1 ] , a [ i ] NEW_LINE swapped = True NEW_LINE DEDENT DEDENT start = start + 1 NEW_LINE DEDENT DEDENT
def first ( str , i ) : NEW_LINE INDENT if ( str [ i ] == ' \0' ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( str [ i ] . isupper ( ) ) : NEW_LINE INDENT return str [ i ] NEW_LINE DEDENT return first ( str , i + 1 ) ; NEW_LINE DEDENT
def longestNull ( str ) : NEW_LINE INDENT arr = [ ] NEW_LINE maxlen = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT arr . append ( ( ' @ ' , - 1 ) ) NEW_LINE maxlen = max ( maxlen , i ) NEW_LINE DEDENT for i in range ( len ( str ) ) : NEW_LINE INDENT arr . append ( ( str [ i ] , i ) ) NEW_LINE while ( len ( arr ) >= 3 and arr [ len ( arr ) - 3 ] . first == '1' and arr [ len ( arr ) - 2 ] . first == '0' and arr [ len ( arr ) - 1 ] . first == '0' ) : NEW_LINE INDENT arr = list ( arr ) NEW_LINE arr . remove ( arr [ len ( arr ) - 3 ] ) NEW_LINE arr . remove ( arr [ len ( arr ) - 2 ] ) NEW_LINE arr . remove ( arr [ len ( arr ) - 1 ] ) NEW_LINE DEDENT tmp = arr [ len ( arr ) - 1 ] . second NEW_LINE maxlen = max ( maxlen , i - tmp ) NEW_LINE DEDENT return maxlen NEW_LINE DEDENT
def reverse ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE for i in range ( 0 , int ( n / 2 ) ) : NEW_LINE INDENT swap ( str , i , n - i - 1 ) NEW_LINE DEDENT DEDENT
def nextWord ( str ) : NEW_LINE INDENT if ( str == " " ) : NEW_LINE INDENT return " a " NEW_LINE DEDENT i = len ( str ) - 1 NEW_LINE while ( str [ i ] == ' z ' and i >= 0 ) : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT if ( i == - 1 ) : NEW_LINE INDENT str = str + ' a ' NEW_LINE DEDENT else : NEW_LINE INDENT str = str . substring ( 0 , i ) + ( char ) ( ( ord ( str [ i ] ) + 1 ) + str [ i + 1 ] ) NEW_LINE DEDENT return str NEW_LINE DEDENT
def isRectangle ( matrix ) : NEW_LINE INDENT rows = len ( matrix ) NEW_LINE if ( rows == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT columns = len ( matrix [ 0 ] ) NEW_LINE table = dict ( ) NEW_LINE for i in range ( rows ) : NEW_LINE INDENT for j in range ( columns - 1 ) : NEW_LINE INDENT for k in range ( j + 1 , columns ) : NEW_LINE INDENT if ( matrix [ i ] [ j ] == 1 and matrix [ i ] [ k ] == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( table [ k ] and table [ k ] . contains ( j ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( not table [ j ] ) : NEW_LINE INDENT table [ j ] = [ k ] NEW_LINE DEDENT if ( not table [ k ] ) : NEW_LINE INDENT table [ k ] = [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT table [ j ] . append ( k ) NEW_LINE DEDENT if ( not table [ k ] ) : NEW_LINE INDENT table [ k ] = [ j ] NEW_LINE DEDENT DEDENT DEDENT DEDENT return False NEW_LINE DEDENT
def sumoflength ( arr , n ) : NEW_LINE INDENT s = [ ] NEW_LINE j = 0 NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT while ( j < n and arr [ j ] not in s ) : NEW_LINE INDENT s . append ( arr [ i ] ) NEW_LINE j += 1 NEW_LINE DEDENT ans += ( ( j - i ) * ( j - i + 1 ) ) / 2 NEW_LINE DEDENT s . remove ( arr [ i ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def findTriplets ( arr , n ) : NEW_LINE INDENT found = False NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT s = set ( ) NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT x = - ( arr [ i ] + arr [ j ] ) NEW_LINE if ( x in s ) : NEW_LINE INDENT print ( " % d ▁ % d ▁ " , arr [ i ] , arr [ j ] ) NEW_LINE found = True NEW_LINE DEDENT else : NEW_LINE INDENT s . add ( arr [ j ] ) NEW_LINE DEDENT DEDENT DEDENT if ( found == False ) : NEW_LINE INDENT print ( " ▁ No ▁ Triplet ▁ Found " ) NEW_LINE DEDENT DEDENT
def maxPrefix ( s , t ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( t ) ) : NEW_LINE INDENT if ( count == len ( s ) ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( t [ i ] == s [ count ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def segregateElements ( arr , n ) : NEW_LINE INDENT temp = [ 0 ] * n NEW_LINE j = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if arr [ i ] >= 0 : NEW_LINE INDENT temp [ j ] = arr [ i ] NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if j == n or j == 0 : NEW_LINE INDENT return NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if arr [ i ] < 0 : NEW_LINE INDENT temp [ j ] = arr [ i ] NEW_LINE DEDENT j += 1 NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT arr [ i ] = temp [ i ] NEW_LINE DEDENT DEDENT
def mergeIntervals ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE index = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if arr [ index ] . end >= arr [ i ] . start : NEW_LINE INDENT arr [ index ] . end = max ( arr [ index ] . end , arr [ i ] . end ) NEW_LINE arr [ index ] . start = min ( arr [ index ] . start , arr [ i ] . start ) NEW_LINE DEDENT else : NEW_LINE INDENT arr [ index ] = arr [ i ] NEW_LINE index += 1 NEW_LINE DEDENT DEDENT print ( " The ▁ Merged ▁ Intervals ▁ are : ▁ " ) NEW_LINE for i in range ( index + 1 ) : NEW_LINE INDENT print ( " [ " , arr [ i ] . start , " , " , arr [ i ] . end , " ] " , sep = " " ) NEW_LINE DEDENT DEDENT
def findArea ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE dimension = [ 0 , 0 ] NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE while ( i < n - 1 and j < 2 ) : NEW_LINE INDENT if ( arr [ i ] == arr [ i + 1 ] ) : NEW_LINE INDENT dimension [ j ] = arr [ i ] NEW_LINE j += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return ( dimension [ 0 ] * dimension [ 1 ] ) NEW_LINE DEDENT
def minOps ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE max = arr [ n - 1 ] NEW_LINE res = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( ( max - arr [ i ] ) % k != 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT res += ( max - arr [ i ] ) / k NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def isDivisible7 ( num ) : NEW_LINE INDENT n = len ( num ) NEW_LINE if n == 0 and num [ 0 ] == '0' : NEW_LINE INDENT return True NEW_LINE DEDENT if n % 3 == 1 : NEW_LINE INDENT num = "00" + num NEW_LINE DEDENT if n % 3 == 2 : NEW_LINE INDENT num = "0" + num NEW_LINE DEDENT n = len ( num ) NEW_LINE gSum = 0 NEW_LINE p = 1 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT group = 0 NEW_LINE group += ord ( num [ i ] ) - ord ( '0' ) NEW_LINE group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 10 NEW_LINE group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 100 NEW_LINE gSum = gSum + group * p NEW_LINE p = p * - 1 NEW_LINE DEDENT return ( gSum % 7 == 0 ) NEW_LINE DEDENT
def isDivisible999 ( num ) : NEW_LINE INDENT n = len ( num ) NEW_LINE if ( n == 0 and num [ 0 ] == '0' ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 3 == 1 ) : NEW_LINE INDENT num = "00" + num NEW_LINE DEDENT if ( n % 3 == 2 ) : NEW_LINE INDENT num = "0" + num NEW_LINE DEDENT gSum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT group = 0 NEW_LINE group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 100 NEW_LINE group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 10 NEW_LINE group += ord ( num [ i ] ) - ord ( '0' ) NEW_LINE gSum += group NEW_LINE DEDENT if ( gSum > 1000 ) : NEW_LINE INDENT num = str ( gSum ) NEW_LINE n = len ( num ) NEW_LINE gSum = isDivisible999 ( num ) ? 1 : 0 NEW_LINE DEDENT return ( gSum == 999 ) NEW_LINE DEDENT
def checkPangram ( string ) : NEW_LINE INDENT mark = [ False for i in range ( 26 ) ] NEW_LINE index = 0 NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT if ( ' A ' <= string [ i ] and string [ i ] <= ' Z ' ) : NEW_LINE INDENT index = ord ( string [ i ] ) - ord ( ' A ' ) NEW_LINE DEDENT elif ( ' a ' <= string [ i ] and string [ i ] <= ' z ' ) : NEW_LINE INDENT index = ord ( string [ i ] ) - ord ( ' a ' ) NEW_LINE DEDENT mark [ index ] = True NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT if ( mark [ i ] == False ) : NEW_LINE INDENT return ( False ) NEW_LINE DEDENT DEDENT return ( True ) NEW_LINE DEDENT
def kLargest ( arr , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE for i in range ( k ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def kthLargestSum ( arr , n , k ) : NEW_LINE INDENT sum = [ 0 ] * ( n + 1 ) NEW_LINE sum [ 0 ] = 0 NEW_LINE sum [ 1 ] = arr [ 0 ] NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT sum [ i ] = sum [ i - 1 ] + arr [ i - 1 ] NEW_LINE DEDENT Q = PriorityQueue ( ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( i , n + 1 ) : NEW_LINE INDENT x = sum [ j ] - sum [ i - 1 ] NEW_LINE if ( len ( Q ) < k ) : NEW_LINE INDENT Q . put ( x ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( Q [ 0 ] < x ) : NEW_LINE INDENT Q . get ( ) NEW_LINE Q . put ( x ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return Q . get ( ) NEW_LINE DEDENT
def printDistinct ( arr , n ) : NEW_LINE INDENT set = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] not in set : NEW_LINE INDENT set . add ( arr [ i ] ) NEW_LINE print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
def abFree ( s ) : NEW_LINE INDENT b_count = 0 NEW_LINE res = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ len ( s ) - i - 1 ] == ' a ' ) : NEW_LINE INDENT res = ( res + b_count ) NEW_LINE b_count = ( b_count * 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT b_count += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def findFibSubset ( x ) : NEW_LINE INDENT maxn = max ( x ) NEW_LINE fib = [ ] NEW_LINE result = [ ] NEW_LINE a = 0 NEW_LINE b = 1 NEW_LINE while ( b < maxn ) : NEW_LINE INDENT c = a + b NEW_LINE a = b NEW_LINE b = c NEW_LINE fib . append ( c ) NEW_LINE DEDENT for i in range ( len ( x ) ) : NEW_LINE INDENT if ( x [ i ] in fib ) : NEW_LINE INDENT result . append ( x [ i ] ) NEW_LINE DEDENT DEDENT print ( result ) NEW_LINE DEDENT
def recursiveReverse ( str , i ) : NEW_LINE INDENT n = len ( str ) NEW_LINE if i == n // 2 : NEW_LINE INDENT return NEW_LINE DEDENT swap ( str , i , n - i - 1 ) NEW_LINE recursiveReverse ( str , i + 1 ) NEW_LINE DEDENT
def noAdjacentDup ( s1 ) : NEW_LINE INDENT n = len ( s1 ) NEW_LINE s = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( s [ i ] == s [ i - 1 ] ) : NEW_LINE INDENT s [ i ] = ' a ' NEW_LINE while ( s [ i ] == s [ i - 1 ] or ( i + 1 < n and s [ i ] == s [ i + 1 ] ) ) : NEW_LINE INDENT s [ i ] = s [ i ] + 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT return ' ' . join ( s ) NEW_LINE DEDENT
def query ( s , i , j ) : NEW_LINE INDENT n = len ( s ) NEW_LINE i %= n NEW_LINE j %= n NEW_LINE if ( s [ i ] == s [ j ] ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def countPairs ( arr , n ) : NEW_LINE INDENT Hash = set ( ) NEW_LINE result = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT Hash . add ( arr [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT product = arr [ i ] * arr [ j ] NEW_LINE if ( Hash [ product ] ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
def printInSortedOrder ( arr , n ) : NEW_LINE INDENT index = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT index [ i ] = i NEW_LINE DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT min = i NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ index [ min ] ] . compareTo ( arr [ index [ j ] ] ) > 0 ) : NEW_LINE INDENT min = j NEW_LINE DEDENT DEDENT if ( min != i ) : NEW_LINE INDENT index [ min ] , index [ i ] = index [ i ] , index [ i ] NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ index [ i ] ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def sortUsingHash ( a , n ) : NEW_LINE INDENT max1 = max ( a ) NEW_LINE min1 = min ( a ) NEW_LINE hashpos = [ 0 ] * ( max + 1 ) NEW_LINE hashneg = [ 0 ] * ( min + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] >= 0 ) : NEW_LINE INDENT hashpos [ a [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT hashneg [ abs ( a [ i ] ) ] += 1 NEW_LINE DEDENT DEDENT for i in range ( min , max1 , - 1 ) : NEW_LINE INDENT if ( hashneg [ i ] > 0 ) : NEW_LINE INDENT for j in range ( hashneg [ i ] ) : NEW_LINE INDENT print ( ( - 1 ) * i , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( max1 , - 1 ) : NEW_LINE INDENT if ( hashpos [ i ] > 0 ) : NEW_LINE INDENT for j in range ( hashpos [ i ] ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
def findRandomIndexOfMax ( arr , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] = mp . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT max_element = - 1 NEW_LINE max_so_far = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( mp [ arr [ i ] ] > max_so_far ) : NEW_LINE INDENT max_so_far = p . getValue ( ) NEW_LINE max_element = p . getKey ( ) NEW_LINE DEDENT DEDENT r = ( int ) ( ( ( max_so_far ) % max_so_far ) + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == max_element ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( count == r ) : NEW_LINE INDENT print ( " Element ▁ with ▁ maximum ▁ frequency ▁ present ▁ " , " at ▁ index ▁ " , i ) , " \n " , sep = " " ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT
def singleNumber ( a , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in a : NEW_LINE INDENT s . add ( i ) NEW_LINE DEDENT arr_sum = 0 NEW_LINE for i in a : NEW_LINE INDENT arr_sum += i NEW_LINE DEDENT set_sum = 0 NEW_LINE for i in s : NEW_LINE INDENT set_sum += i NEW_LINE DEDENT return ( 3 * set_sum - arr_sum ) / 2 NEW_LINE DEDENT
def printAllAPTriplets ( arr , n ) : NEW_LINE INDENT s = [ ] NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT diff = arr [ j ] - arr [ i ] NEW_LINE exists = len ( s ) > 0 NEW_LINE if ( exists ) : NEW_LINE INDENT print ( arr [ i ] - diff , ' ' , arr [ i ] , ' ' , arr [ j ] ) NEW_LINE DEDENT DEDENT s . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT
def simplify ( str ) : NEW_LINE INDENT l = len ( str ) NEW_LINE res = [ 0 ] * l NEW_LINE index = 0 NEW_LINE i = 0 NEW_LINE s = [ 0 ] * l NEW_LINE while i < l : NEW_LINE INDENT if ( str [ i ] == ' + ' ) : NEW_LINE INDENT if ( s [ 0 ] == 1 ) : NEW_LINE INDENT res [ index ] = ' - ' NEW_LINE DEDENT if ( s [ 0 ] == 0 ) : NEW_LINE INDENT res [ index ] = ' + ' NEW_LINE DEDENT DEDENT elif ( str [ i ] == ' - ' ) : NEW_LINE INDENT if ( s [ 0 ] == 1 ) : NEW_LINE INDENT res [ index ] = ' - ' NEW_LINE DEDENT elif ( str [ i ] == ' ( ' and i > 0 ) : NEW_LINE INDENT if ( str [ i - 1 ] == ' - ' ) : NEW_LINE INDENT x = 0 NEW_LINE DEDENT else : NEW_LINE INDENT x = 1 NEW_LINE DEDENT s . append ( s [ 0 ] ) NEW_LINE DEDENT DEDENT elif ( str [ i ] == ' ) ' ) : NEW_LINE INDENT s . pop ( ) NEW_LINE DEDENT else : NEW_LINE INDENT res [ index ] = str [ i ] NEW_LINE i += 1 NEW_LINE DEDENT DEDENT return ' ' . join ( res ) NEW_LINE DEDENT
def findPair ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in arr : NEW_LINE INDENT s . add ( i ) NEW_LINE DEDENT found = False NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT sum = arr [ i ] + arr [ j ] NEW_LINE if ( sum in s ) : NEW_LINE INDENT found = True NEW_LINE print ( arr [ i ] , arr [ j ] ) NEW_LINE DEDENT DEDENT DEDENT if ( found == False ) : NEW_LINE INDENT print ( " Not ▁ Exist ▁ " ) NEW_LINE DEDENT DEDENT
def strToBinary ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT val = int ( s [ i ] ) NEW_LINE bin = " " NEW_LINE while ( val > 0 ) : NEW_LINE INDENT if ( val % 2 == 1 ) : NEW_LINE INDENT bin += '1' NEW_LINE DEDENT else : NEW_LINE INDENT bin += '0' NEW_LINE DEDENT val = int ( val / 2 ) NEW_LINE DEDENT bin = list ( bin ) NEW_LINE print ( bin , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT
def findDuplicateparenthesis ( s ) : NEW_LINE INDENT Stack = [ ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( ch == ' ) ' ) : NEW_LINE INDENT top = Stack [ - 1 ] NEW_LINE Stack . pop ( ) NEW_LINE elementsInside = 0 NEW_LINE while ( top != ' ( ' ) : NEW_LINE INDENT elementsInside += 1 NEW_LINE top = Stack [ - 1 ] NEW_LINE Stack . pop ( ) NEW_LINE DEDENT if ( elementsInside < 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT Stack . append ( ch ) NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def findTriplets ( x ) : NEW_LINE INDENT fact = [ ] NEW_LINE factors = [ ] NEW_LINE for i in range ( 2 , int ( m . sqrt ( x ) + 1 ) : NEW_LINE INDENT if ( x % i == 0 ) : NEW_LINE INDENT fact . append ( i ) NEW_LINE if ( x / i != i ) : NEW_LINE INDENT fact . append ( x / i ) NEW_LINE DEDENT factors . append ( i ) NEW_LINE DEDENT DEDENT found = False NEW_LINE k = len ( fact ) NEW_LINE for i in range ( 0 , k ) : NEW_LINE INDENT a = fact [ i ] NEW_LINE for j in range ( 0 , k ) : NEW_LINE INDENT b = fact [ j ] NEW_LINE if ( ( a != b ) and ( x % ( a * b ) == 0 ) and ( x / ( a * b ) != a ) and ( x / ( a * b ) != b ) and ( x / ( a * b ) != 1 ) : NEW_LINE INDENT print ( a , " ▁ " , b , " ▁ " , x / ( a * b ) ) NEW_LINE found = True NEW_LINE break NEW_LINE DEDENT DEDENT if ( found ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( not found ) : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT DEDENT
def findMissing ( a , b , n , m ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT s . add ( b [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] not in s ) : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
def minheapify ( a , index ) : NEW_LINE INDENT small = index NEW_LINE l = 2 * index + 1 NEW_LINE r = 2 * index + 2 NEW_LINE if ( l < n and a [ l ] < a [ small ] ) : NEW_LINE INDENT small = l NEW_LINE DEDENT if ( r < n and a [ r ] < a [ small ] ) : NEW_LINE INDENT small = r NEW_LINE DEDENT if ( small != index ) : NEW_LINE INDENT t = a [ small ] NEW_LINE a [ small ] = a [ index ] NEW_LINE a [ index ] = t NEW_LINE minheapify ( a , small ) NEW_LINE DEDENT DEDENT
def KMP ( m , n , str2 , str1 ) : NEW_LINE INDENT pos = 0 NEW_LINE len = 0 NEW_LINE p = [ 0 ] * ( m + 1 ) NEW_LINE k = 0 NEW_LINE ch1 = str1 . toCharArray ( ) NEW_LINE ch2 = str2 . toCharArray ( ) NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT while ( k > 0 and ch1 [ k ] != ch1 [ i - 1 ] ) : NEW_LINE INDENT k = p [ k ] NEW_LINE DEDENT if ( ch1 [ k ] == ch1 [ i - 1 ] ) : NEW_LINE INDENT k = p [ k ] NEW_LINE DEDENT p [ i ] = k NEW_LINE DEDENT for j in range ( 0 , m + 1 ) : NEW_LINE INDENT while ( j > 0 and j < n and ch1 [ j ] != ch2 [ i ] ) : NEW_LINE INDENT j = p [ j ] NEW_LINE DEDENT if ( j < n and ch1 [ j ] == ch2 [ i ] ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT if ( j > len ) : NEW_LINE INDENT len = j NEW_LINE pos = i - j + 1 NEW_LINE DEDENT DEDENT print ( " Shift ▁ = ▁ " , pos ) NEW_LINE print ( " Prefix ▁ = ▁ " , str1 [ 0 : l ] ) NEW_LINE DEDENT
def swapDiagonal ( matrix ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT temp = matrix [ i ] [ i ] NEW_LINE matrix [ i ] [ i ] = matrix [ i ] [ N - i - 1 ] NEW_LINE matrix [ i ] [ N - i - 1 ] = temp NEW_LINE DEDENT DEDENT
def maximumPalinUsingKChanges ( str , k ) : NEW_LINE INDENT palin = [ 0 for i in range ( 13 ) ] NEW_LINE ans = " " NEW_LINE l = 0 NEW_LINE r = len ( str ) - 1 NEW_LINE while ( l < r ) : NEW_LINE INDENT if ( str [ l ] != str [ r ] ) : NEW_LINE INDENT palin [ l ] = palin [ r ] = max ( str [ l ] , str [ r ] ) NEW_LINE k -= 1 NEW_LINE DEDENT l += 1 NEW_LINE r -= 1 NEW_LINE DEDENT if ( k < 0 ) : NEW_LINE INDENT return " Not ▁ possible " NEW_LINE DEDENT l = 0 NEW_LINE r = len ( str ) - 1 NEW_LINE while ( l <= r ) : NEW_LINE INDENT if ( k > 0 ) : NEW_LINE INDENT palin [ l ] = '9' NEW_LINE DEDENT DEDENT if ( palin [ l ] < '9' ) : NEW_LINE INDENT if ( k >= 2 and palin [ l ] == str [ l ] and palin [ r ] == str [ r ] ) : NEW_LINE INDENT k -= 2 NEW_LINE palin [ l ] = palin [ r ] = '9' NEW_LINE DEDENT elif ( k >= 1 and ( palin [ l ] != str [ l ] or palin [ r ] != str [ r ] ) : NEW_LINE INDENT k -= 1 NEW_LINE palin [ l ] = palin [ r ] = '9' NEW_LINE DEDENT DEDENT l += 1 NEW_LINE r -= 1 NEW_LINE DEDENT for i in range ( len ( palin ) ) : NEW_LINE INDENT ans += palin [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT
def findMinRooms ( slots , n , m ) : NEW_LINE INDENT counts = [ 0 ] * m NEW_LINE for i in range ( m ) : NEW_LINE INDENT counts [ i ] = 0 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( slots [ i ] [ j ] == '1' ) : NEW_LINE INDENT counts [ j ] += 1 NEW_LINE DEDENT DEDENT max = - 1 NEW_LINE for i in range ( m ) : NEW_LINE INDENT if ( max < counts [ i ] ) : NEW_LINE INDENT max = counts [ i ] NEW_LINE DEDENT DEDENT return max NEW_LINE DEDENT
def minProduct ( arr , n , k ) : NEW_LINE INDENT pq = PriorityQueue ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT pq . put ( arr [ i ] ) NEW_LINE DEDENT count = 0 NEW_LINE ans = 1 NEW_LINE while ( not pq . empty ( ) == False and count < k ) : NEW_LINE INDENT ans = ans * pq . get ( ) NEW_LINE count += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def largest ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE return arr [ n - 1 ] NEW_LINE DEDENT
def findLongestConseqSubseq ( arr , n ) : NEW_LINE INDENT s = Set ( ) NEW_LINE for ele in arr : s . add ( ele ) NEW_LINE DEDENT ans = 0 NEW_LINE for ele in s : NEW_LINE INDENT if ( arr [ i ] in s ) : NEW_LINE INDENT j = arr [ i ] NEW_LINE while ( j in s ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT ans = max ( ans , j - arr [ i ] ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def divisibilityCheck ( arr , n ) : NEW_LINE INDENT s = [ ] NEW_LINE max_ele = - sys . maxsize - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . append ( arr [ i ] ) NEW_LINE max_ele = max ( max_ele , arr [ i ] ) NEW_LINE DEDENT res = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] != 0 : NEW_LINE INDENT for j in range ( arr [ i ] * 2 , max_ele + arr [ i ] ) : NEW_LINE INDENT if ( s [ j ] == arr [ i ] ) : NEW_LINE INDENT res . add ( j ) NEW_LINE DEDENT DEDENT DEDENT DEDENT list = sorted ( res ) NEW_LINE for temp in res : NEW_LINE INDENT print ( temp , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT
def minPalPartion ( str1 ) : NEW_LINE INDENT n = len ( str1 ) NEW_LINE C = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] NEW_LINE P = [ [ False for x in range ( n ) ] for y in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT P [ i ] [ i ] = True NEW_LINE C [ i ] [ i ] = 0 NEW_LINE DEDENT for L in range ( 2 , n + 1 ) : NEW_LINE INDENT for i in range ( n - L + 1 ) : NEW_LINE INDENT j = i + L - 1 NEW_LINE if ( L == 2 ) : NEW_LINE INDENT P [ i ] [ j ] = ( str1 [ i ] == str1 [ j ] ) NEW_LINE DEDENT else : NEW_LINE INDENT P [ i ] [ j ] = ( ( str1 [ i ] == str1 [ j ] ) and P [ i + 1 ] [ j - 1 ] ) NEW_LINE DEDENT if ( P [ i ] [ j ] == True ) : NEW_LINE INDENT C [ i ] [ j ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = sys . maxsize NEW_LINE for k in range ( i , j - 1 ) : NEW_LINE INDENT C [ i ] [ j ] = min ( C [ i ] [ j ] , C [ i ] [ k ] + C [ k + 1 ] [ j ] + 1 ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return C [ 0 ] [ n - 1 ] NEW_LINE DEDENT
def checkCount ( arr , size , KthIndex ) : NEW_LINE INDENT Hash = dict ( ) NEW_LINE for i in range ( size ) : NEW_LINE INDENT Hash [ arr [ i ] ] = 0 NEW_LINE DEDENT Hash [ arr [ i ] ] = Hash . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT for x in Hash : NEW_LINE INDENT if ( ( int ) x [ 1 ] > 2 * k ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def removeDuplicates ( S ) : NEW_LINE INDENT n = len ( S ) NEW_LINE if ( n < 2 ) : NEW_LINE INDENT return NEW_LINE DEDENT j = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( S [ j ] != S [ i ] ) : NEW_LINE INDENT j += 1 NEW_LINE S [ j ] = S [ i ] NEW_LINE DEDENT DEDENT print ( S ) NEW_LINE DEDENT
def KMaxCombinations ( A , B , N , K ) : NEW_LINE INDENT pq = PriorityQueue ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT pq . put ( A [ i ] + B [ j ] ) NEW_LINE DEDENT DEDENT count = 0 NEW_LINE while ( count < K ) : NEW_LINE INDENT print ( pq . get ( ) ) NEW_LINE pq . get ( ) NEW_LINE count += 1 NEW_LINE DEDENT DEDENT
def to_upper ( in ) : NEW_LINE INDENT for i in range ( 0 , len ( in ) ) : NEW_LINE INDENT if ( ord ( in [ i ] ) <= ord ( ' a ' ) and ord ( in [ i ] ) <= ord ( ' z ' ) ) : NEW_LINE INDENT in [ i ] = chr ( in [ i ] ) - ord ( ' a ' ) + ord ( ' A ' ) ; NEW_LINE DEDENT DEDENT return str ( in ) NEW_LINE DEDENT
def sortInWave ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n , 2 ) : NEW_LINE INDENT if ( i > 0 and arr [ i - 1 ] > arr [ i ] ) : NEW_LINE INDENT arr [ i - 1 ] , arr [ i ] = arr [ i ] , arr [ i - 1 ] NEW_LINE DEDENT if ( i < n - 1 and arr [ i ] < arr [ i + 1 ] ) : NEW_LINE INDENT arr [ i ] = arr [ i + 1 ] NEW_LINE DEDENT DEDENT DEDENT
def getMinNumberForPattern ( seq ) : NEW_LINE INDENT n = len ( seq ) NEW_LINE if n >= 9 : NEW_LINE INDENT return " - 1" NEW_LINE DEDENT result = [ 0 ] * ( n + 1 ) NEW_LINE count = 1 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT if i == n or seq [ i ] == ' I ' : NEW_LINE INDENT j = i - 1 NEW_LINE while j >= - 1 : NEW_LINE INDENT result [ j + 1 ] = chr ( ord ( '0' ) + count ) NEW_LINE if j >= 0 and seq [ j ] == ' I ' : NEW_LINE INDENT break NEW_LINE DEDENT j -= 1 NEW_LINE DEDENT DEDENT DEDENT return ' ' . join ( result ) NEW_LINE DEDENT
def findMin ( V ) : NEW_LINE INDENT ans = [ ] NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT while ( V >= deno [ i ] ) : NEW_LINE INDENT V -= deno [ i ] NEW_LINE ans . append ( deno [ i ] ) NEW_LINE DEDENT DEDENT for i in range ( 0 , len ( ans ) ) : NEW_LINE INDENT print ( " ▁ " , ans [ i ] ) NEW_LINE DEDENT DEDENT
def findRepeating ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT return sum - ( ( ( n - 1 ) * n ) / 2 ) NEW_LINE DEDENT
def findSum ( str1 , str2 ) : NEW_LINE INDENT if len ( str1 ) > len ( str2 ) : NEW_LINE INDENT temp = str1 NEW_LINE str1 = str2 NEW_LINE str2 = temp NEW_LINE DEDENT str3 = " " NEW_LINE n1 = len ( str1 ) NEW_LINE n2 = len ( str2 ) NEW_LINE str2 = list ( str2 ) NEW_LINE str3 = str3 + str ( sum % 10 ) NEW_LINE carry = 0 NEW_LINE for i in range ( n1 ) : NEW_LINE INDENT sum = ( ( ord ( str1 [ i ] ) - ord ( '0' ) ) + int ( ( ord ( str2 [ i ] ) - ord ( '0' ) ) ) + carry ) NEW_LINE str3 = str3 + str ( sum % 10 ) NEW_LINE carry = sum // 10 NEW_LINE DEDENT for i in range ( n1 , n2 ) : NEW_LINE INDENT sum = ( ( ord ( str2 [ i ] ) - ord ( '0' ) ) + carry ) NEW_LINE str3 = str3 + str ( sum % 10 ) NEW_LINE carry = sum // 10 NEW_LINE DEDENT if ( carry ) : NEW_LINE INDENT str3 + str ( carry + '0' ) NEW_LINE DEDENT str3 = str3 [ : : - 1 ] NEW_LINE return str3 NEW_LINE DEDENT
