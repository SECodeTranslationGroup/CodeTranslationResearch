void printPairs ( int arr [ ] , int n ) { vector < int > v ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( abs ( arr [ i ] ) == abs ( arr [ j ] ) ) v . push_back ( abs ( arr [ i ] ) ) ; if ( v . size ( ) == 0 ) return ; sort ( v , v + n ) ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) cout << - v [ i ] << " ▁ " << v [ i ] << endl ; }
float findArea ( float a , float b , float c ) { if ( a < 0 || b < 0 || c < 0 || ( a + b <= c ) || a + c <= b || b + c <= a ) { cout << " Not ▁ a ▁ valid ▁ triangle " << endl ; return 0 ; } float s = ( a + b + c ) / 2 ; return sqrt ( s * ( s - a ) * ( s - b ) * ( s - c ) ) ; }
bool isMajority ( int a [ ] , int n ) { unordered_map < int , int > mp ; for ( int i = 0 ; i < n ; i ++ ) mp [ a [ i ] ] ++ ; for ( auto x : mp ) if ( x . second >= n / 2 ) return true ; return false ; }
int firstnonrepeating ( int arr [ ] , int n ) { unordered_map < int , int > m ; for ( int i = 0 ; i < n ; i ++ ) m [ arr [ i ] ] ++ ; for ( int i = 0 ; i < n ; i ++ ) if ( m [ arr [ i ] ] == 1 ) return arr [ i ] ; return - 1 ; }
void recaman ( int n ) { if ( n <= 0 ) return ; cout << " % d , ▁ " ; unordered_set < int > s ; s . insert ( 0 ) ; int prev = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int curr = prev - i ; if ( curr < 0 || s . find ( curr ) == s . end ( ) ) curr = prev + i ; s . insert ( curr ) ; cout << " % d , ▁ " , curr ) ; prev = curr ; } }
int maxdiff ( int arr [ ] , int n ) { unordered_map < int , int > freq ; for ( int i = 0 ; i < n ; i ++ ) freq [ arr [ i ] ] ++ ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( freq [ arr [ i ] ] > freq [ arr [ j ] ] && arr [ i ] > arr [ j ] ) ans = max ( ans , freq [ arr [ i ] ] - freq [ arr [ j ] ] ) ; else if ( freq [ arr [ i ] ] < freq [ arr [ j ] ] && arr [ i ] < arr [ j ] ) ans = max ( ans , freq [ arr [ j ] ] - freq [ arr [ i ] ] ) ; } } return ans ; }
int findLength ( string str ) { int n = str . length ( ) ; int maxlen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j += 2 ) { int length = j - i + 1 ; int leftsum = 0 , rightsum = 0 ; for ( int k = 0 ; k < length / 2 ; k ++ ) { leftsum += ( str [ i + k ] - '0' ) ; rightsum += ( str [ i + k + length / 2 ] - '0' ) ; } if ( leftsum == rightsum && maxlen < length ) maxlen = length ; } } return maxlen ; }
bool prevPermutation ( char str [ ] ) { int n = strlen ( str ) ; int i = n ; while ( i > 0 && str [ i - 1 ] <= str [ i ] ) { i -- ; } if ( i <= 0 ) return false ; int j = i - 1 ; while ( j + 1 <= n && str [ j + 1 ] <= str [ i - 1 ] ) { j ++ ; } swap ( str , i - 1 , j ) ; str = str . begin ( ) ; return true ; }
string findSubString ( string str , string pat ) { int len1 = str . length ( ) ; int len2 = pat . length ( ) ; if ( len1 < len2 ) { cout << " No ▁ such ▁ window ▁ exists \n " ; return " " ; } int hash_pat [ no_of_chars ] = { 0 } ; int hash_str [ no_of_chars ] = { 0 } ; for ( int i = 0 ; i < len2 ; i ++ ) hash_pat [ pat [ i ] ] ++ ; int start = 0 , start_index = - 1 , min_len = INT_MAX ; int count = 0 ; for ( int j = 0 ; j < len1 ; j ++ ) { hash_str [ str [ j ] ] ++ ; if ( hash_pat [ str [ j ] ] != 0 && hash_str [ str [ j ] ] <= hash_pat [ str [ j ] ] ) count ++ ; if ( count == len2 ) { while ( hash_str [ str [ start ] ] > hash_pat [ str [ start ] ] ) hash_str [ str [ start ] ] -- ; start ++ ; } int len_window = j - start + 1 ; if ( min_len > len_window ) { min_len = len_window ; start_index = start ; } } } if ( start_index == - 1 ) { cout << " No ▁ such ▁ window ▁ exists \n " ; return " " ; } return str . substr ( start_index , start_index + min_len ) ; }
void shuffle ( int card [ ] , int n ) { Random rand = new Random ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int r = i + rand . nextInt ( 52 - i ) ; int temp = card [ r ] ; card [ r ] = card [ i ] ; card [ i ] = temp ; } }
int maxLen ( int arr [ ] , int n ) { unordered_map < int , int > sumSet ; int sum = 0 ; int max_len = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( arr [ i ] == 0 && max_len == 0 ) max_len = 1 ; if ( sum == 0 ) max_len = i + 1 ; if ( sumSet . find ( sum ) != sumSet . end ( ) ) { max_len = max ( max_len , i - prev_i ) ; else sumSet . insert ( sum ) ; } return max_len ; }
int removeConsecutiveSame ( vector < string > v ) { stack < string > st ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) { if ( st . empty ( ) ) st . push ( v [ i ] ) ; else { string str = st . top ( ) ; if ( str . compare ( v [ i ] ) == 0 ) st . pop ( ) ; else st . push ( v [ i ] ) ; } } return st . size ( ) ; }
void find ( vector < string > list1 , vector < string > list2 ) { vector < string > res ; int max_possible_sum = list1 . size ( ) + list2 . size ( ) - 2 ; for ( int sum = 0 ; sum <= max_possible_sum ; sum ++ ) { for ( int i = 0 ; i <= sum ; i ++ ) if ( i < list1 . size ( ) && ( sum - i ) < list2 . size ( ) && list1 [ i ] == list2 [ sum - i ] ) res . push_back ( list1 [ i ] ) ; if ( res . size ( ) > 0 ) break ; } for ( int i = 0 ; i < res . size ( ) ; i ++ ) cout << res [ i ] << " ▁ " ; }
int getLevenstein ( string input ) { string revInput = input ; reverse ( revInput ) ; int n = input . length ( ) ; int dp [ n + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; ++ i ) { dp [ 0 ] [ i ] = i ; dp [ i ] [ 0 ] = i ; } for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j <= n ; ++ j ) { if ( input [ i - 1 ] == revInput [ j - 1 ] ) dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = 1 + min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) ; } } int res = INT_MAX ; for ( int i = n , j = 0 ; i >= 0 ; i -- , j ++ ) { res = min ( res , dp [ i ] [ j ] ) ; if ( i < n ) res = min ( res , dp [ i + 1 ] [ j ] ) ; if ( i > 0 ) res = min ( res , dp [ i - 1 ] [ j ] ) ; } return res ; }
void countDistinct ( int arr [ ] , int k ) { unordered_map < int , int > hM ; int dist_count = 0 ; for ( int i = 0 ; i < k ; i ++ ) { if ( hM . find ( arr [ i ] ) == hM . end ( ) ) { hM [ arr [ i ] ] = 1 ; dist_count ++ ; } else { int count = hM [ arr [ i ] ] ; hM [ arr [ i ] ] = count + 1 ; } } cout << dist_count ; for ( int i = k ; i < arr . length ; i ++ ) { if ( hM [ arr [ i - k ] ] == 1 ) { hM . erase ( arr [ i - k ] ) ; dist_count -- ; } else { int count = hM [ arr [ i - k ] ] ; hM [ arr [ i - k ] ] = count - 1 ; } if ( hM [ arr [ i ] ] == null ) { hM [ arr [ i ] ] = 1 ; dist_count ++ ; } else { int count = hM [ arr [ i ] ] ; hM [ arr [ i ] ] = count + 1 ; } cout << dist_count ; } }
int lcs ( int dp [ ] [ MAX ] [ k ] , int arr1 [ ] , int n , int arr2 [ ] , int m , int k ) { if ( k < 0 ) return - 10000000 ; if ( n < 0 || m < 0 ) return 0 ; int ans = dp [ n ] [ m ] [ k ] ; if ( ans != - 1 ) return ans ; try { ans = max ( lcs ( dp , arr1 , n - 1 , arr2 , m , k ) , lcs ( dp , arr1 , n , arr2 , m - 1 , k ) ) ; if ( arr1 [ n - 1 ] == arr2 [ m - 1 ] ) ans = max ( ans , 1 + lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k ) ) ; ans = max ( ans , 1 + lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k - 1 ) ) ; } catch ( Exception e ) { } return ans ; }
void printDivisors ( int n ) { vector < int > v ; for ( int i = 1 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) cout << " % d ▁ " , i ; else { cout << " % d ▁ " , i ; v . push_back ( n / i ) ; } } } for ( int i = v . size ( ) - 1 ; i >= 0 ; i -- ) cout << " % d ▁ " , v [ i ] ) ; }
void findLIS ( int A [ ] , int n ) { unordered_map < int , int > hash ; int LIS_size = 1 ; int LIS_index = 0 ; for ( int i = 1 ; i < n ; i ++ ) { hash [ A [ i ] ] = 1 ; if ( LIS_size < hash [ A [ i ] ] ) { LIS_size = hash [ A [ i ] ] ; LIS_index = A [ i ] ; } } cout << " LIS _ size ▁ = ▁ " << LIS_size << endl ; cout << " LIS ▁ : ▁ " << LIS_index << endl ; int start = LIS_index - LIS_size + 1 ; while ( start <= LIS_index ) { cout << start << " ▁ " ; start ++ ; } }
int largestSubset ( int a [ ] , int n ) { sort ( a , a + n ) ; int dp [ n ] ; dp [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { int mxm = 0 ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( a [ j ] % a [ i ] == 0 ) { mxm = max ( mxm , dp [ j ] ) ; } } dp [ i ] = 1 + mxm ; } return * max_element ( dp , a + n ) ; }
char encodedChar ( string str , int k ) { string expand = " " ; string temp = " " ; int freq = 0 ; for ( int i = 0 ; i < str . length ( ) ; ) { temp = " " ; freq = 0 ; while ( i < str . length ( ) && str [ i ] >= ' a ' && str [ i ] <= ' z ' ) { temp += str [ i ] ; i ++ ; } while ( i < str . length ( ) && str [ i ] >= ' 1' && str [ i ] <= '9' ) { freq = freq * 10 + str [ i ] - '0' ; i ++ ; } for ( int j = 1 ; j <= freq ; j ++ ) expand += temp ; } if ( freq == 0 ) expand += temp ; return expand [ k - 1 ] ; }
int countNum ( int arr [ ] , int n ) { unordered_set < int > s ; int count = 0 , maxm = INT_MIN , minm = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { s . insert ( arr [ i ] ) ; if ( arr [ i ] < minm ) minm = arr [ i ] ; if ( arr [ i ] > maxm ) maxm = arr [ i ] ; } for ( int i = minm ; i <= maxm ; i ++ ) if ( s . find ( i ) == s . end ( ) ) count ++ ; return count ; }
int countPairs ( int arr [ ] , int n ) { unordered_map < int , int > hm ; for ( int i = 0 ; i < n ; i ++ ) hm [ arr [ i ] ] ++ ; int ans = 0 ; for ( auto it = hm . begin ( ) ; it != hm . end ( ) ; it ++ ) { int count = it . second ; ans += ( count * ( count - 1 ) ) / 2 ; } return ans ; }
string decimalToBinary ( double num , int k_prec ) { string binary = " " ; int Integral = ( int ) num ; double fractional = num - Integral ; while ( Integral > 0 ) { int rem = Integral % 2 ; binary += ( ( char ) ( rem + '0' ) ) ; Integral /= 2 ; } binary = reverse ( binary , binary + ' . ' ) ; while ( k_prec -- > 0 ) { fractional *= 2 ; int fract_bit = ( int ) fractional ; if ( fract_bit == 1 ) { fractional -= fract_bit ; binary += ( char ) ( 1 + '0' ) ; } else { binary += ( char ) ( 0 + '0' ) ; } } return binary ; }
int evaluateBoolExpr ( bool s ) { int n = s . length ( ) ; for ( int i = 0 ; i < n ; i += 2 ) { if ( i + 1 < n && i + 2 < n ) { if ( s [ i + 1 ] == ' A ' ) { if ( s [ i + 2 ] == '0' || s [ i ] == 0 ) s [ i + 2 ] = '0' ; else s [ i + 2 ] = '1' ; } else if ( ( i + 1 ) < n && s [ i + 1 ] == ' B ' ) { if ( s [ i + 2 ] == '1' || s [ i ] == '1' ) s [ i + 2 ] = '1' ; else s [ i + 2 ] = '0' ; } else { if ( s [ i + 2 ] == s [ i ] ) s [ i + 2 ] = '0' ; else s [ i + 2 ] = '1' ; } } } return s [ n - 1 ] - '0' ; }
int minSwaps ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) arrpos . push_back ( arr [ i ] , i ) ; sort ( arrpos , arr + n , greater < int > ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > o2 . getKey ( ) ) return - 1 ; else if ( o1 . getKey ( ) . equals ( o2 . getKey ( ) ) ) return 0 ; else return 1 ; } } ) ; bool vis [ n ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { if ( vis [ i ] || arrpos [ i ] . getValue ( ) == i ) continue ; int cycle_size = 0 ; int j = i ; while ( ! vis [ j ] ) { vis [ j ] = true ; j = arrpos [ j ] . getValue ( ) ; cycle_size ++ ; } if ( cycle_size > 0 ) { ans += ( cycle_size - 1 ) ; } } return ans ; }
int minimumBox ( int arr [ ] , int n ) { queue < int > q ; sort ( arr , arr + n ) ; q . push ( arr [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { int now = q . front ( ) ; if ( arr [ i ] >= 2 * now ) q . pop ( ) ; q . push ( arr [ i ] ) ; } return q . size ( ) ; }
int findInteger ( int arr [ ] , int n ) { unordered_map < int , int > hash ; int minimum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < 0 ) hash [ abs ( arr [ i ] ) ] = ( hash [ abs ( arr [ i ] ) ] == null ? 0 : hash [ abs ( arr [ i ] ) ) - 1 ) ; else hash [ abs ( arr [ i ] ) ] ++ ; } for ( int i = 0 ; i < n ; i ++ ) if ( hash [ arr [ i ] ] > 0 ) return arr [ i ] ; return - 1 ; }
void convertOpposite ( string str ) { int ln = str . length ( ) ; for ( int i = 0 ; i < ln ; i ++ ) { if ( isupper ( str [ i ] ) ) str [ i ] = toupper ( str [ i ] ) ; else str [ i ] = tolower ( str [ i ] ) ; } }
int findRepeating ( int arr [ ] , int n ) { unordered_set < int > s ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . find ( arr [ i ] ) != s . end ( ) ) return arr [ i ] ; s . insert ( arr [ i ] ) ; } return - 1 ; }
void transpose ( int A [ ] [ N ] ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = i + 1 ; j < N ; j ++ ) swap ( A [ i ] [ j ] , A [ j ] [ i ] ) ; }
void printSubsequences ( string s ) { int n = str . length ( ) ; int opsize = pow ( 2 , n - 1 ) ; for ( int counter = 0 ; counter < opsize ; counter ++ ) { for ( int j = 0 ; j < n ; j ++ ) { cout << str [ j ] ; if ( counter & ( 1 << j ) ) cout << " ▁ " ; } cout << endl ; } }
void printRoman ( int number ) { char c [ 10001 ] ; int i = 0 ; if ( number <= 0 ) { c [ 0 ] = ' \0' ; return ; } while ( number != 0 ) { if ( number >= 1000 ) { i = digit ( ' M ' , number / 1000 , i , c ) ; number = number % 1000 ; } else if ( number >= 500 ) { if ( number < 900 ) { i = digit ( ' D ' , number / 500 , i , c ) ; number = number % 500 ; } else { i = sub_digit ( ' C ' , ' M ' , i , c ) ; number = number % 100 ; } } else if ( number >= 100 ) { if ( number < 400 ) { i = digit ( ' C ' , number / 100 , i , c ) ; number = number % 100 ; } else { i = sub_digit ( ' C ' , ' D ' , i , c ) ; number = number % 100 ; } } else if ( number >= 10 ) { if ( number < 40 ) { i = digit ( ' X ' , number / 10 , i , c ) ; number = number % 10 ; } else { i = sub_digit ( ' X ' , ' L ' , i , c ) ; number = number % 10 ; } } else if ( number >= 5 ) { if ( number < 9 ) { i = digit ( ' V ' , number / 5 , i , c ) ; number = number % 5 ; } else { i = sub_digit ( ' I ' , ' X ' , i , c ) ; number = 0 ; } } } cout << " Roman ▁ numeral ▁ number " ; }
bool findTriplet ( int a1 [ ] , int a2 [ ] , int a3 [ ] , int n1 , int n2 , int n3 , int sum ) { unordered_set < int > s ; for ( int i = 0 ; i < n1 ; i ++ ) s . insert ( a1 [ i ] ) ; vector < int > al ; for ( int i = 0 ; i < n2 ; i ++ ) { for ( int j = 0 ; j < n3 ; j ++ ) { if ( al . find ( sum - a2 [ i ] - a3 [ j ] ) != al . end ( ) ) return true ; } } return false ; }
bool check ( string s ) { if ( s . length ( ) >= 10 ) return true ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) { for ( int j = i + 1 ; j < s . length ( ) ; j ++ ) { for ( int k = j + 1 ; k < s . length ( ) ; k ++ ) { string s1 = " " , s2 = " " , s3 = " " , s4 = " " ; try { s1 = s . substr ( 0 , i ) ; s2 = s . substr ( i , j - i ) ; s3 = s . substr ( j , k - j ) ; s4 = s . substr ( k , s . length ( ) - k ) ; } catch ( StringIndexOutOfBoundsException e ) { } if ( strcheck ( s1 , s2 ) && strcheck ( s1 , s3 ) && strcheck ( s1 , s4 ) && strcheck ( s2 , s3 ) && strcheck ( s2 , s4 ) && strcheck ( s3 , s4 ) ) return true ; } } } return false ; }
void bitonicGenerator ( int arr [ ] , int n ) { int i = 1 ; int j = n - 1 ; if ( j % 2 ) j -- ; while ( i < j ) { arr = swap ( arr , i , j ) ; i += 2 ; j -= 2 ; } sort ( arr , 0 , ( n + 1 ) / 2 ) ; sort ( arr , ( n + 1 ) / 2 , n ) ; int low = ( n + 1 ) / 2 , high = n - 1 ; while ( low < high ) { swap ( arr [ low ] , arr [ high ] ) ; low ++ ; high -- ; } }
void splitString ( char str [ ] ) { char alpha [ MAX_CHAR ] = { 0 } , num = new char ( ) , special [ MAX_CHAR ] ; for ( int i = 0 ; i < strlen ( str ) ; i ++ ) { if ( isDigit ( str [ i ] ) ) num . push_back ( str [ i ] ) ; else if ( isAlphabetic ( str [ i ] ) ) alpha . push_back ( str [ i ] ) ; else special . push_back ( str [ i ] ) ; } cout << alpha << num << endl ; cout << special << endl ; }
int binaryMedian ( int m [ R ] [ C ] , int r , int c ) { int max = * max_element ( m , m + r ) ; int min = * min_element ( m , m + r ) ; if ( m [ i ] [ 0 ] < min ) min = m [ i ] [ 0 ] ; if ( m [ i ] [ c - 1 ] > max ) max = m [ i ] [ c - 1 ] ; } int desired = ( r * c + 1 ) / 2 ; while ( min < max ) { int mid = min + ( max - min ) / 2 ; int place = 0 ; int get = 0 ; for ( int i = 0 ; i < r ; ++ i ) { get = binarySearch ( m [ i ] , mid ) ; if ( get < 0 ) get = abs ( get ) - 1 ; else { while ( get < m [ i ] . length && m [ i ] [ get ] == mid ) get += 1 ; } place = place + get ; } if ( place < desired ) min = mid + 1 ; else max = mid ; } return min ; }
void printDuplicates ( int arr [ ] , int n ) { unordered_map < int , int > map ; int count = 0 ; bool dup = false ; for ( int i = 0 ; i < n ; i ++ ) { map [ arr [ i ] ] ++ ; } for ( auto entry : map ) { if ( entry . second > 1 ) { cout << entry . first << " ▁ " ; dup = true ; } } if ( ! dup ) { cout << " - 1" ; } }
void stoogesort ( int arr [ ] , int l , int h ) { if ( l >= h ) return ; if ( arr [ l ] > arr [ h ] ) { int t = arr [ l ] ; arr [ l ] = arr [ h ] ; arr [ h ] = t ; } if ( h - l + 1 > 2 ) { int t = ( h - l + 1 ) / 3 ; stoogesort ( arr , l , h - t ) ; stoogesort ( arr , l + t , h ) ; stoogesort ( arr , l , h - t ) ; } }
void printEqualModNumbers ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int d = arr [ n - 1 ] - arr [ 0 ] ; vector < int > v ; for ( int i = 1 ; i * i <= d ; i ++ ) { if ( d % i == 0 ) { v . push_back ( i ) ; if ( i != d / i ) v . push_back ( d / i ) ; } } for ( int i = 0 ; i < v . size ( ) ; i ++ ) { int temp = arr [ 0 ] % v [ i ] ; int j ; for ( j = 1 ; j < n ; j ++ ) if ( arr [ j ] % v [ i ] != temp ) break ; if ( j == n ) cout << v [ i ] << " ▁ " ; } }
string recursiveReverse ( char str [ ] ) { stack < char > st ; for ( int i = 0 ; str [ i ] != ' \0' ; i ++ ) st . push ( str [ i ] ) ; for ( int i = 0 ; i < str . length ; i ++ ) { str [ i ] = st . top ( ) ; st . pop ( ) ; } return str ; }
void printRect ( int X [ ] , int Y [ ] , int n ) { int Xmax = * max_element ( X , X + n ) ; int Xmin = * min_element ( Y , Y + n ) ; int Ymax = * max_element ( Y , Y + n ) ; int Ymin = * min_element ( Y , Y + n ) ; cout << " { " << Xmin << " , ▁ " << Ymin << " } " << endl ; }
void NFG ( int a [ ] , int n , int freq [ ] ) { stack < int > s ; s . push ( 0 ) ; int res [ n ] ; for ( int i = 0 ; i < n ; i ++ ) res [ i ] = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( freq [ a [ s . top ( ) ] ] > freq [ a [ i ] ] ) s . push ( i ) ; else { while ( freq [ a [ s . top ( ) ] ] < freq [ a [ i ] ] && s . empty ( ) > 0 ) { res [ s . top ( ) ] = a [ i ] ; s . pop ( ) ; } s . push ( i ) ; } } while ( s . empty ( ) > 0 ) { res [ s . top ( ) ] = - 1 ; s . pop ( ) ; } for ( int i = 0 ; i < n ; i ++ ) { cout << res [ i ] << " ▁ " ; } }
void printEqualSumSets ( int arr [ ] , int n ) { int i , currSum , sum = 0 ; for ( i = 0 ; i < arr . length ; i ++ ) sum += arr [ i ] ; if ( ( sum & 1 ) == 1 ) { cout << " - 1 " ; return ; } int k = sum >> 1 ; bool dp [ n + 1 ] [ k + 1 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; for ( i = 1 ; i <= k ; i ++ ) dp [ 0 ] [ i ] = false ; for ( i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = true ; for ( i = 1 ; i <= n ; i ++ ) { for ( currSum = 1 ; currSum <= k ; currSum ++ ) { dp [ i ] [ currSum ] = dp [ i - 1 ] [ currSum ] ; if ( arr [ i - 1 ] <= currSum ) dp [ i ] [ currSum ] = dp [ i ] [ currSum ] | dp [ i - 1 ] [ currSum - arr [ i - 1 ] ] ; } } list < int > set1 , set2 ; if ( ! dp [ n ] [ k ] ) { cout << " - 1 \n " ; return ; } i = n ; currSum = k ; while ( i > 0 && currSum >= 0 ) { if ( dp [ i - 1 ] [ currSum ] ) { i -- ; set2 . push_back ( arr [ i ] ) ; } else if ( dp [ i - 1 ] [ currSum - arr [ i - 1 ] ] ) { i -- ; currSum -= arr [ i ] ; set1 . push_back ( arr [ i ] ) ; } } cout << " Set ▁ 1 ▁ elements : ▁ \n Set ▁ 2 ▁ elements : ▁ " ; for ( i = 0 ; i < set1 . size ( ) ; i ++ ) cout << " Set ▁ elements : ▁ \n " ; for ( i = 0 ; i < set2 . size ( ) ; i ++ ) cout << " \n Set ▁ 1 ▁ elements : ▁ " ; for ( i = 0 ; i
void reverseStr ( string str ) { int n = str . length ( ) ; int j ; for ( int i = 0 , j = n - 1 ; i < j ; i ++ , j -- ) swap ( ch [ i ] , ch [ j ] ) ; cout << ch ; }
void minimizeWithKSwaps ( int arr [ ] , int n , int k ) { for ( int i = 0 ; i < n - 1 && k > 0 ; ++ i ) { int pos = i ; for ( int j = i + 1 ; j < n ; ++ j ) { if ( j - i > k ) break ; if ( arr [ j ] < arr [ pos ] ) pos = j ; } int temp ; for ( int j = pos ; j > i ; -- j ) swap ( arr [ j ] , arr [ j - 1 ] ) ; k -= pos - i ; } }
int countSubarrays ( int arr [ ] , int n ) { int difference = 0 ; int ans = 0 ; int hash_positive [ n + 1 ] ; int hash_negative [ n + 1 ] ; hash_positive [ 0 ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] & 1 ) { difference ++ ; } else { difference -- ; } if ( difference < 0 ) { ans += hash_negative [ - difference ] ; hash_negative [ - difference ] ++ ; } else { ans += hash_positive [ difference ] ; hash_positive [ difference ] ++ ; } } return ans ; }
bool findPairs ( int arr [ ] , int n ) { unordered_map < int , pair > map ; for ( int i = 0 ; i < n ; ++ i ) { for ( int j = i + 1 ; j < n ; ++ j ) { int sum = arr [ i ] + arr [ j ] ; if ( map . find ( sum ) == map . end ( ) ) map [ sum ] = new pair ( i , j ) ; else { pair p = map [ sum ] ; cout << " ( " << arr [ p . first ] << " , ▁ " << arr [ p . second ] << " ) ▁ and ▁ ( " << arr [ i ] << " , ▁ " << arr [ j ] << " ) " << endl ; return true ; } } } return false ; }
bool check ( string s1 , string s2 ) { int n = s1 . length ( ) ; int m = s2 . length ( ) ; bool dp [ n + 1 ] [ m + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= m ; j ++ ) dp [ i ] [ j ] = false ; } dp [ 0 ] [ 0 ] = true ; for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) { for ( int j = 0 ; j <= s2 . length ( ) ; j ++ ) { if ( dp [ i ] [ j ] ) { if ( j < s2 . length ( ) && ( toupper ( s1 [ i ] ) == s2 [ j ] ) ) dp [ i + 1 ] [ j + 1 ] = true ; if ( ! isupper ( s1 [ i ] ) ) dp [ i + 1 ] [ j ] = true ; } } } return ( dp [ n ] [ m ] ) ; }
bool checkDuplicatesWithinK ( int arr [ ] , int k ) { unordered_set < int > uset ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( uset . find ( arr [ i ] ) != uset . end ( ) ) return true ; uset . insert ( arr [ i ] ) ; if ( i >= k ) uset . erase ( arr [ i - k ] ) ; } return false ; }
int minOperation ( int arr [ ] , int n ) { unordered_map < int , int > hash ; for ( int i = 0 ; i < n ; i ++ ) hash [ arr [ i ] ] ++ ; int max_count = 0 ; for ( auto i : hash ) if ( max_count < hash [ i ] ) max_count = hash [ i ] ; return ( n - max_count ) ; }
int findSum ( string str ) { string temp = " " ; int sum = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( char . isDigit ( str [ i ] ) ) temp += ch ; else { sum += int . parseInt ( temp ) ; temp = "0" ; } } return sum + int . parseInt ( temp ) ; }
int mostFrequent ( int arr [ ] , int n ) { unordered_map < int , int > hp ; for ( int i = 0 ; i < n ; i ++ ) { int key = arr [ i ] ; if ( hp . find ( key ) != hp . end ( ) ) { int freq = hp [ key ] ; freq ++ ; hp [ key ] = freq ; } else hp [ key ] = 1 ; } int max_count = 0 , res ; for ( auto val : hp ) { if ( max_count < val . second ) { res = val . first ; max_count = val . second ; } } return res ; }
string firstLetterWord ( string str ) { string result = " " ; bool v = true ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] == ' ▁ ' ) { v = true ; } else if ( str [ i ] != ' ▁ ' && v == true ) { result += ( str [ i ] ) ; v = false ; } } return result ; }
int findFourElements ( int arr [ ] , int n ) { unordered_map < int , Indexes > map ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) map [ arr [ i ] + arr [ j ] ] . insert ( i , j ) ; } int d = INT_MIN ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int abs_diff = abs ( arr [ i ] - arr [ j ] ) ; if ( map . find ( abs_diff ) != map . end ( ) ) { Indexes indexes = map [ abs_diff ] ; if ( indexes . getI ( ) != i && indexes . getI ( ) != j && indexes . getJ ( ) != i && indexes . getJ ( ) != j ) { d = max ( d , max ( arr [ i ] , arr [ j ] ) ) ; } } } } return d ; }
int maxNumOfChocolates ( int arr [ ] , int n , int k ) { unordered_map < int , int > um ; int sum [ n ] ; int curr_rem ; int maxSum = 0 ; sum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) sum [ i ] = sum [ i - 1 ] + arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) { curr_rem = sum [ i ] % k ; if ( curr_rem == 0 ) { if ( maxSum < sum [ i ] ) maxSum = sum [ i ] ; } else if ( um . find ( curr_rem ) == um . end ( ) ) um [ curr_rem ] = i ; else if ( maxSum < ( sum [ i ] - sum [ um [ curr_rem ] ) ) maxSum = sum [ i ] - sum [ um [ curr_rem ] ] ; } return ( maxSum / k ) ; }
string decode ( string str ) { stack < int > integerstack , stringstack ; string temp = " " , result = " " ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { int count = 0 ; if ( isDigit ( str [ i ] ) ) { while ( isDigit ( str [ i ] ) ) { count = count * 10 + str [ i ] - '0' ; i ++ ; } i -- ; integerstack . push ( count ) ; } else if ( str [ i ] == ' ] ' ) { temp = " " ; count = 0 ; if ( ! integerstack . empty ( ) ) { count = integerstack . top ( ) ; integerstack . pop ( ) ; } while ( ! stringstack . empty ( ) && stringstack . top ( ) != ' [ ' ) { temp = stringstack . top ( ) + temp ; stringstack . pop ( ) ; } if ( ! stringstack . empty ( ) && stringstack . top ( ) == ' [ ' ) stringstack . pop ( ) ; for ( int j = 0 ; j < count ; j ++ ) result = result + temp ; for ( int j = 0 ; j < result . length ( ) ; j ++ ) stringstack . push ( result [ j ] ) ; result = " " ; } else if ( str [ i ] == ' [ ' ) { if ( isDigit ( str [ i - 1 ] ) ) stringstack . push ( str [ i ] ) ; else { stringstack . push ( str [ i ] ) ; integerstack . push ( 1 ) ; } } else stringstack . push ( str [ i ] ) ; } while ( ! stringstack . empty ( ) ) { result = stringstack . top ( ) + result ; stringstack . pop ( ) ; } return result ; }
int minSum ( int A [ ] , int n ) { return ( min_val * ( n - 1 ) ) ; }
int countWords ( char * str ) { unordered_map < char , int > m ; for ( int i = 0 ; i < n ; i ++ ) { m [ str [ i ] ] ++ ; } int res = 0 ; for ( auto it = m . begin ( ) ; it != m . end ( ) ; it ++ ) if ( it -> second == 2 ) res ++ ; return res ; }
void sortUsingHash ( int a [ ] , int n ) { int max = sort ( a , a + n ) ; int hash [ max + 1 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) hash [ a [ i ] ] += 1 ; for ( int i = 0 ; i <= max ; i ++ ) { if ( hash [ i ] ) { for ( int j = 0 ; j < hash [ i ] ; j ++ ) { cout << i << " ▁ " ; } } } }
bool isDivisible ( string str , int k ) { int n = str . length ( ) ; int c = 0 ; for ( int i = 0 ; i < k ; i ++ ) if ( str [ n - i - 1 ] == '0' ) c ++ ; return ( c == k ) ; }
int divisible ( string num ) { int n = num . length ( ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += ( int ) ( num [ i ] ) ; if ( sum % 3 == 0 ) return 0 ; if ( n == 1 ) return - 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( sum % 3 == ( num [ i ] - '0' ) % 3 ) return 1 ; if ( n == 2 ) return - 1 ; return 2 ; }
int longSubarrWthSumDivByK ( int arr [ ] , int n , int k ) { unordered_map < int , int > um , mod_arr [ n ] ; int max = 0 ; int curr_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { curr_sum += arr [ i ] ; mod_arr [ i ] = ( ( curr_sum % k ) + k ) % k ; } for ( int i = 0 ; i < n ; i ++ ) { if ( mod_arr [ i ] == 0 ) max = i + 1 ; else if ( um . find ( mod_arr [ i ] ) == um . end ( ) ) um [ mod_arr [ i ] ] = i ; else if ( max < ( i - um [ mod_arr [ i ] ] ) ) max = i - um [ mod_arr [ i ] ] ; } return max ; }
void reverse ( string str ) { if ( ( str == null ) || ( str . length ( ) <= 1 ) ) cout << str << endl ; else { cout << str [ 0 ] ; reverse ( str + 1 ) ; } }
bool isDvisibleBy12 ( string num ) { if ( num . size ( ) >= 3 ) { int d1 = ( int ) num [ num . size ( ) - 1 ] ; if ( d1 % 2 != 0 ) return false ; int d2 = ( int ) num [ num . size ( ) - 2 ] ; int sum = 0 ; for ( int i = 0 ; i < num . size ( ) ; i ++ ) sum += num [ i ] ; return ( sum % 3 == 0 && ( d2 * 10 + d1 ) % 4 == 0 ) ; } else { int number = num [ 0 ] ; return ( number % 12 == 0 ) ; } }
int xorZero ( string s ) { int one_count = 0 , zero_count = 0 ; char str [ ] ; int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) if ( str [ i ] == '1' ) one_count ++ ; else zero_count ++ ; if ( one_count % 2 == 0 ) return zero_count ; return one_count ; }
double nthRoot ( int A , int N ) { double xPre = random ( ) % 10 ; double eps = 0.001 ; double delX = INT_MAX ; double xK = 0.0 ; while ( delX > eps ) { xK = ( ( N - 1.0 ) * xPre + ( double ) A / pow ( xPre , N - 1 ) ) / ( double ) N ; delX = abs ( xK - xPre ) ; xPre = xK ; } return xK ; }
string findLeft ( string str ) { int n = str . length ( ) ; while ( n > 0 ) { n -- ; if ( str [ n ] == ' d ' ) { str [ n ] = ' c ' ; break ; } if ( str [ n ] == ' b ' ) { str [ n ] = ' a ' ; break ; } if ( str [ n ] == ' a ' ) { str [ n ] = ' b ' ; break ; } if ( str [ n ] == ' c ' ) str [ n ] = ' d ' ; } return str ; }
void minRange ( int arr [ ] , int n , int k ) { int l = 0 , r = n ; for ( int i = 0 ; i < n ; i ++ ) { unordered_set < int > s ; int j ; for ( j = i ; j < n ; j ++ ) { s . insert ( arr [ j ] ) ; if ( s . size ( ) == k ) { if ( ( j - i ) < ( r - l ) ) { r = j ; l = i ; } break ; } } if ( j == n ) break ; } if ( l == 0 && r == n ) cout << " Invalid ▁ k " ; else cout << l << " ▁ " << r ; }
int findSum ( int A [ ] , int B [ ] , int n ) { unordered_map < int , int > hash ; for ( int i = 0 ; i < n ; i ++ ) hash [ A [ i ] ] ++ ; int sum = 0 ; for ( auto it = hash . begin ( ) ; it != hash . end ( ) ; ++ it ) if ( it -> second == 1 ) sum += it -> first ; return sum ; }
void arrayEvenAndOdd ( int arr [ ] , int n ) { int i = - 1 , j = 0 ; while ( j != n ) { if ( arr [ j ] % 2 == 0 ) { i ++ ; int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; } j ++ ; } for ( int k = 0 ; k < n ; k ++ ) cout << arr [ k ] << " ▁ " ; }
bool containsOdd ( int G [ ] [ V ] , int src ) { int colorArr [ V ] = { 0 } ; for ( int i = 0 ; i < V ; ++ i ) colorArr [ i ] = - 1 ; colorArr [ src ] = 1 ; deque < int > q ; q . push ( src ) ; while ( ! q . empty ( ) ) { int u = q . front ( ) ; q . pop ( ) ; if ( G [ u ] [ u ] == 1 ) return true ; for ( int v = 0 ; v < V ; ++ v ) { if ( G [ u ] [ v ] == 1 && colorArr [ v ] == - 1 ) { colorArr [ v ] = 1 - colorArr [ u ] ; q . push ( v ) ; } else if ( G [ u ] [ v ] == 1 && colorArr [ v ] == colorArr [ u ] ) return true ; } } return false ; }
int getMinSquares ( int n ) { if ( n <= 3 ) return n ; int res = n ; for ( int x = 1 ; x <= n ; x ++ ) { int temp = x * x ; if ( temp > n ) break ; else res = min ( res , 1 + getMinSquares ( n - temp ) ) ; } return res ; }
int maxDistance ( int arr [ ] , int n ) { unordered_map < int , int > map ; int max_dist = 0 ; for ( int i = 0 ; i < n ; i ++ ) { map [ arr [ i ] ] = i ; } return max_dist ; }
int selectRandom ( int x ) { static int count = 1 ; int res ; if ( count == 1 ) res = x ; else { Random r = new Random ( ) ; int i = r . nextInt ( count ) ; if ( i == count - 1 ) res = x ; } return res ; }
int cost ( int a [ ] , int n ) { int min = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] < min ) min = a [ i ] ; } return ( n - 1 ) * min ; }
void gnomeSort ( int arr [ ] , int n ) { int index = 0 ; while ( index < n ) { if ( index == 0 ) index ++ ; if ( arr [ index ] >= arr [ index - 1 ] ) index ++ ; else { int temp = 0 ; swap ( arr [ index ] , arr [ index - 1 ] ) ; index -- ; } } return ; }
int sortedAfterSwap ( int A [ ] , int B [ ] , int n ) { int t = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( B [ i ] != 0 ) { if ( A [ i ] != i + 1 ) t = A [ i ] ; A [ i ] = A [ i + 1 ] ; A [ i + 1 ] = t ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( A [ i ] != i + 1 ) return 0 ; } return 1 ; }
void moveSpaceInFront ( char str [ ] ) { int i = strlen ( str ) - 1 ; for ( int j = i ; j >= 0 ; j -- ) if ( str [ j ] != ' ▁ ' ) str [ i -- ] = str [ j ] ; while ( i >= 0 ) str [ i -- ] = ' ▁ ' ; }
int countOfBinaryNumberLessThanN ( int N ) { queue < int > q ; q . push ( 1 ) ; int cnt = 0 ; int t ; while ( ! q . empty ( ) ) { t = q . front ( ) ; q . pop ( ) ; if ( t <= N ) { cnt ++ ; q . push ( t * 10 ) ; q . push ( t * 10 + 1 ) ; } } return cnt ; }
void substringConversions ( string str , int k , int b ) { int i = 0 , sum = 0 , counter = k - 1 ; for ( i = 0 ; i < k ; i ++ ) { sum = int ( sum + ( ( str [ i ] - '0' ) * pow ( b , counter ) ) ) ; counter -- ; } cout << sum << " ▁ " ; int prev = sum ; sum = 0 ; counter = 0 ; for ( ; i < str . length ( ) ; i ++ ) { sum = prev - ( ( str [ i - k ] - '0' ) * pow ( b , k - 1 ) ) ; sum = sum * b ; sum = sum + ( str [ i ] - '0' ) ; cout << sum << " ▁ " ; prev = sum ; counter ++ ; } }
string longestRepeatedSubSeq ( string str ) { int n = str . length ( ) ; int dp [ n + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= n ; j ++ ) dp [ i ] [ j ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= n ; j ++ ) if ( str [ i - 1 ] == str [ j - 1 ] && i != j ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ; string res = " " ; int i = n , j = n ; while ( i > 0 && j > 0 ) { if ( dp [ i ] [ j ] == dp [ i - 1 ] [ j - 1 ] + 1 ) { res = res + str [ i - 1 ] ; i -- , j -- ; } else if ( dp [ i ] [ j ] == dp [ i - 1 ] [ j ] ) i -- , else j -- ; } string reverse = " " ; for ( int k = res . length ( ) - 1 ; k >= 0 ; k -- ) reverse = reverse + res [ k ] ; return reverse ; }
void rearrange ( int a [ ] , int size ) { int positive = 0 , negative = 1 , temp ; while ( true ) { while ( positive < size && a [ positive ] >= 0 ) positive += 2 ; while ( negative < size && a [ negative ] <= 0 ) negative += 2 ; if ( positive < size && negative < size ) { swap ( a [ positive ] , a [ negative ] ) ; } else break ; } }
void bubbleSort ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = 0 ; j < n - i - 1 ; j ++ ) if ( arr [ j ] > arr [ j + 1 ] ) swap ( arr [ j ] , arr [ j + 1 ] ) ; }
string reversingString ( char str [ ] , int start , int end ) { while ( start < end ) { str [ start ] ^= str [ end ] ; str [ end ] ^= str [ start ] ; str [ start ] ^= str [ end ] ; ++ start ; -- end ; } return str ; }
int minimalSteps ( string s , int n ) { int dp [ n ] ; for ( int i = 0 ; i < n ; i ++ ) dp [ i ] = INT_MAX ; string s1 = " " , s2 = " " ; dp [ 0 ] = 1 ; s1 += s [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { s1 += s [ i ] ; s2 = s [ i + 1 ] ; dp [ i ] = min ( dp [ i ] , dp [ i - 1 ] + 1 ) ; if ( s1 == s2 ) dp [ i * 2 + 1 ] = min ( dp [ i ] + 1 , dp [ i * 2 + 1 ] ) ; } return dp [ n - 1 ] ; }
int MinimumCost ( int cost [ ] , int n , int W ) { vector < int > val ; vector < int > wt ; int size = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( cost [ i ] != - 1 ) { val . push_back ( cost [ i ] ) ; wt . push_back ( i + 1 ) ; size ++ ; } } n = size ; int min_cost [ n + 1 ] [ W + 1 ] ; for ( int i = 0 ; i <= W ; i ++ ) min_cost [ 0 ] [ i ] = INT_MAX ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= W ; j ++ ) { if ( wt [ i - 1 ] > j ) min_cost [ i ] [ j ] = min_cost [ i - 1 ] [ j ] ; else min_cost [ i ] [ j ] = min ( min_cost [ i - 1 ] [ j ] , min_cost [ i ] [ j - wt [ i - 1 ] ] + val [ i - 1 ] ) ; } } return ( min_cost [ n ] [ W ] == INT_MAX ) ? - 1 : min_cost [ n ] [ W ] ; }
void bitonicGenerator ( int arr [ ] , int n ) { vector < int > evenArr ; vector < int > oddArr ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 != 1 ) evenArr . push_back ( arr [ i ] ) ; else oddArr . push_back ( arr [ i ] ) ; } sort ( evenArr , evenArr + n , greater < int > ( ) ) ; sort ( oddArr , oddArr + n , greater < int > ( ) ) ; int i = 0 ; for ( int j = 0 ; j < evenArr . size ( ) ; j ++ ) { arr [ i ++ ] = evenArr [ j ] ; } for ( int j = 0 ; j < oddArr . size ( ) ; j ++ ) { arr [ i ++ ] = oddArr [ j ] ; } }
void printFirstRepeating ( int arr [ ] , int n ) { int min = - 1 ; unordered_set < int > uset ; for ( int i = n ; i >= 0 ; i -- ) { if ( uset . find ( arr [ i ] ) != uset . end ( ) ) min = i ; else uset . insert ( arr [ i ] ) ; } if ( min != - 1 ) cout << " The ▁ first ▁ repeating ▁ element ▁ is ▁ " << arr [ min ] << endl ; else cout << " There ▁ are ▁ no ▁ repeating ▁ elements " << endl ; }
int lps ( string & seq ) { int n = seq . length ( ) ; int i , j , cl ; int L [ n ] [ n ] ; for ( i = 0 ; i < n ; i ++ ) L [ i ] [ i ] = 1 ; for ( cl = 2 ; cl <= n ; cl ++ ) { for ( i = 0 ; i < n - cl + 1 ; i ++ ) { j = i + cl - 1 ; if ( seq [ i ] == seq [ j ] && cl == 2 ) L [ i ] [ j ] = 2 ; else if ( seq [ i ] == seq [ j ] ) L [ i ] [ j ] = L [ i + 1 ] [ j - 1 ] + 2 ; else L [ i ] [ j ] = max ( L [ i ] [ j - 1 ] , L [ i + 1 ] [ j ] ) ; } } return L [ 0 ] [ n - 1 ] ; }
string censor ( string text , string word ) { string word_list [ ] = { " " } ; string result = " " ; string stars = " " ; for ( int i = 0 ; i < word . length ( ) ; i ++ ) stars += ' * ' ; int index = 0 ; for ( string i : word_list ) { if ( i . compare ( word ) == 0 ) word_list [ index ] = stars ; index ++ ; } for ( string i : word_list ) result += i + ' ▁ ' ; return result ; }
bool isRotated ( string str1 , string str2 ) { if ( str1 . length ( ) != str2 . length ( ) ) return false ; string clock_rot = " " ; string anticlock_rot = " " ; int len = str2 . length ( ) ; anticlock_rot = anticlock_rot + str2 [ len - 2 , len ] + str2 [ 0 , len - 2 ] ; clock_rot = clock_rot + str2 [ 2 ] + str2 [ 0 , 2 ] ; return ( str1 . compare ( clock_rot ) || str1 . compare ( anticlock_rot ) ) ; }
int findDiff ( int arr [ ] , int n ) { unordered_map < int , int > mp ; for ( int i = 0 ; i < n ; i ++ ) mp [ arr [ i ] ] ++ ; int max_count = 0 , min_count = n ; for ( auto x : mp ) { max_count = max ( max_count , x . second ) ; min_count = min ( min_count , x . first ) ; } return ( max_count - min_count ) ; }
int playGame ( int arr [ ] , int n ) { unordered_set < int > uset ; for ( int i : arr ) uset . insert ( i ) ; return ( uset . size ( ) % 2 == 0 ) ? 1 : 2 ; }
int subset ( int arr [ ] , int n ) { unordered_map < int , int > mp ; for ( int i = 0 ; i < n ; i ++ ) mp [ arr [ i ] ] ++ ; int res = 0 ; for ( auto it = mp . begin ( ) ; it != mp . end ( ) ; ++ it ) res = max ( res , it -> second ) ; return res ; }
bool isProduct ( int arr [ ] , int n , int x ) { unordered_set < int > hset ; if ( n < 2 ) return false ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) { if ( x == 0 ) return true ; else continue ; } if ( x % arr [ i ] == 0 ) { if ( hset . find ( x / arr [ i ] ) != hset . end ( ) ) return true ; hset . insert ( arr [ i ] ) ; } } return false ; }
int findRotations ( string str ) { string tmp = str + str ; int n = str . length ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { string substring = tmp . substr ( i , str . length ( ) ) ; if ( str == substring ) return i ; } return n ; }
void randomize ( int arr [ ] , int n ) { Random r = new Random ( ) ; for ( int i = n - 1 ; i > 0 ; i -- ) { int j = r . nextInt ( i + 1 ) ; int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; } cout << arr << endl ; }
void translate ( char * str ) { int len = strlen ( str ) ; if ( len < 2 ) return ; int i = 0 ; int j = 0 ; while ( j < len - 1 ) { if ( str [ j ] == ' A ' && str [ j + 1 ] == ' B ' ) { j = j + 2 ; str [ i ++ ] = ' C ' ; continue ; } str [ i ++ ] = str [ j ++ ] ; } if ( j == len - 1 ) str [ i ++ ] = str [ j ] ; str [ i ] = ' ▁ ' ; str [ len - 1 ] = ' ▁ ' ; }
int maxLen ( int arr [ ] , int n ) { unordered_map < int , int > hM ; int sum = 0 ; int max_len = 0 ; int ending_index = - 1 ; int start_index = 0 ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = ( arr [ i ] == 0 ) ? - 1 : 1 ; } for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( sum == 0 ) { max_len = i + 1 ; ending_index = i ; } if ( hM . find ( sum + n ) != hM . end ( ) ) { if ( max_len < i - hM [ sum + n ] ) { max_len = i - hM [ sum + n ] ; ending_index = i ; } } else hM [ sum + n ] = i ; } for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = ( arr [ i ] == - 1 ) ? 0 : 1 ; } int end = ending_index - max_len + 1 ; cout << end << " ▁ to ▁ " << ending_index ; return max_len ; }
int numberofways ( char A , char B , int N , int M ) { vector < int > pos [ MAX ] ; for ( int i = 0 ; i < M ; i ++ ) pos [ B [ i ] ] . push_back ( i + 1 ) ; int LCS = dpl [ N ] [ M ] ; int dpr [ N + 2 ] [ M + 2 ] ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 1 ; j <= M ; j ++ ) { if ( A [ i - 1 ] == B [ j - 1 ] ) dpl [ i ] [ j ] = dpl [ i - 1 ] [ j - 1 ] + 1 ; else dpl [ i ] [ j ] = max ( dpl [ i - 1 ] [ j ] , dpl [ i ] [ j - 1 ] ) ; } } int ans = 0 ; for ( int i = 0 ; i <= N ; i ++ ) { for ( int j = 0 ; j < MAX ; j ++ ) { for ( int x : pos [ j ] ) { if ( dpl [ i ] [ x - 1 ] + dpr [ i + 1 ] [ x + 1 ] == LCS ) { ans ++ ; break ; } } } } return ans ; }
void substringConversions ( string str , int k , int b ) { for ( int i = 0 ; i + k <= str . length ( ) ; i ++ ) { string sub = str . substr ( i , i + k ) ; int sum = 0 , counter = 0 ; for ( int j = sub . length ( ) - 1 ; j >= 0 ; j -- ) { sum = sum + ( ( sub [ j ] - '0' ) * pow ( b , counter ) ) ; counter ++ ; } cout << sum << " ▁ " ; } }
int SumOfKsubArray ( int arr [ ] , int k ) { int sum = 0 ; deque < int > S , G ; int i = 0 ; for ( i = 0 ; i < k ; i ++ ) { while ( ! S . empty ( ) && arr [ S . front ( ) ] >= arr [ i ] ) S . pop ( ) ; while ( ! G . empty ( ) && arr [ G . front ( ) ] <= arr [ i ] ) G . pop ( ) ; S . push_back ( i ) ; } for ( ; i < arr . length ; i ++ ) { sum += arr [ S . front ( ) ] + arr [ G . front ( ) ] ; while ( ! S . empty ( ) && S . front ( ) <= i - k ) S . pop ( ) ; while ( ! G . empty ( ) && G . front ( ) <= arr [ i ] ) G . pop_front ( ) ; G . push_back ( i ) ; S . push_back ( i ) ; } sum += arr [ S . front ( ) ] + arr [ G . front ( ) ] ; return sum ; }
string arrangeString ( string str ) { int char_count [ MAX_CHAR ] = { 0 } ; int sum = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( isupper ( str [ i ] ) ) char_count [ str [ i ] - ' A ' ] ++ ; else sum = sum + ( str [ i ] - '0' ) ; } string res = " " ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { char ch = ( char ) ( ' A ' + i ) ; while ( char_count [ i ] -- != 0 ) res = res + ch ; } if ( sum > 0 ) res = res + sum ; return res ; }
int waysToIncreaseLCSBy1 ( string str1 , string str2 ) { int m = str1 . size ( ) , n = str2 . size ( ) ; vector < int > position [ M ] ; for ( int i = 1 ; i <= n ; i ++ ) position [ str2 [ i - 1 ] - ' a ' ] . push_back ( i ) ; int lcsl [ m + 2 ] [ n + 2 ] ; int lcsr [ m + 2 ] [ n + 2 ] ; for ( int i = 0 ; i <= m + 1 ; i ++ ) for ( int j = 0 ; j <= n + 1 ; j ++ ) lcsl [ i ] [ j ] = lcsr [ i ] [ j ] = 0 ; for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( str1 [ i - 1 ] == str2 [ j - 1 ] ) lcsl [ i ] [ j ] = 1 + lcsl [ i - 1 ] [ j - 1 ] ; else lcsl [ i ] [ j ] = max ( lcsl [ i - 1 ] [ j ] , lcsl [ i ] [ j - 1 ] ) ; } } for ( int i = m ; i >= 1 ; i -- ) { for ( int j = n ; j >= 1 ; j -- ) { if ( str1 [ i - 1 ] == str2 [ j - 1 ] ) lcsr [ i ] [ j ] = 1 + lcsr [ i + 1 ] [ j + 1 ] ; else lcsr [ i ] [ j ] = max ( lcsr [ i + 1 ] [ j ] , lcsr [ i ] [ j + 1 ] ) ; } } int ways = 0 ; for ( int i = 0 ; i <= m ; i ++ ) { for ( char d = 0 ; d < 26 ; d ++ ) { for ( int j = 0 ; j < position [ d ] . size ( ) ; j ++ ) { int p = position [ d ] [ j ] ; if ( p != position [ d ] . size ( ) ; j ++ ) { int p = position [ d ] [ j ] ; if ( p != 0 ) { int j = 0 ; j < position [ d ] . size ( ) ; j ++ ) { for ( char d = 0
int lis ( int arr [ ] , int n ) { int lis [ n ] ; int i , j , max = 0 ; for ( i = 0 ; i < n ; i ++ ) lis [ i ] = 1 ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; for ( i = 0 ; i < n ; i ++ ) if ( max < lis [ i ] ) max = lis [ i ] ; return max ; }
void SternSequenceFunc ( vector < int > BrocotSequence , int n ) { for ( int i = 1 ; BrocotSequence . size ( ) < n ; i ++ ) { int considered_element = BrocotSequence [ i ] ; int precedent = BrocotSequence [ i - 1 ] ; BrocotSequence . push_back ( considered_element + precedent ) ; BrocotSequence . push_back ( considered_element ) ; } for ( int i = 0 ; i < 15 ; ++ i ) cout << BrocotSequence [ i ] << " ▁ " ; }
void printBracketNumber ( string exp , int n ) { int left_bnum = 1 ; stack < int > right_bnum ; for ( int i = 0 ; i < n ; i ++ ) { if ( exp [ i ] == ' ( ' ) { cout << left_bnum << " ▁ " ; right_bnum . push ( left_bnum ) ; left_bnum ++ ; } else if ( exp [ i ] == ' ) ' ) { cout << right_bnum . top ( ) << " ▁ " ; right_bnum . pop ( ) ; } } }
int returnMaxSum ( int A [ ] , int B [ ] , int n ) { unordered_set < int > mp ; int result = 0 ; int curr_sum = 0 , curr_begin = 0 ; for ( int i = 0 ; i < n ; ++ i ) { while ( mp . find ( A [ curr_begin ] ) != mp . end ( ) ) { mp . erase ( A [ curr_begin ] ) ; curr_sum -= B [ curr_begin ] ; curr_begin ++ ; } mp . insert ( A [ i ] ) ; curr_sum += B [ i ] ; result = max ( result , curr_sum ) ; } return result ; }
int getPairsCount ( int n , int arr [ ] , int sum ) { unordered_map < int , int > hm ; for ( int i = 0 ; i < n ; i ++ ) hm [ arr [ i ] ] ++ ; int twice_count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( hm [ sum - arr [ i ] ] != 0 ) twice_count += hm [ sum - arr [ i ] ] ; if ( sum - arr [ i ] == arr [ i ] ) twice_count -- ; } return twice_count / 2 ; }
void rearrange ( int arr [ ] , int n ) { int i = - 1 , temp = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] < 0 ) { i ++ ; swap ( arr [ i ] , arr [ j ] ) ; } } int pos = i + 1 , neg = 0 ; while ( pos < n && neg < pos && arr [ neg ] < 0 ) { swap ( arr [ neg ] , arr [ pos ] ) ; pos ++ ; neg += 2 ; } }
int largestGCDSubsequence ( int arr [ ] , int n ) { int ans = 0 ; int maxele = * max_element ( arr , arr + n ) ; for ( int i = 2 ; i <= maxele ; ++ i ) { int count = 0 ; for ( int j = 0 ; j < n ; ++ j ) if ( arr [ j ] % i == 0 ) ++ count ; ans = max ( ans , count ) ; } return ans ; }
bool isNumber ( string s ) { for ( int i = 0 ; i < s . length ( ) ; i ++ ) if ( isdigit ( s [ i ] ) == false ) return false ; return true ; }
int countPairs ( int arr1 [ ] , int arr2 [ ] , int m , int n , int x ) { int count = 0 ; unordered_set < int > us ; for ( int i = 0 ; i < m ; i ++ ) us . insert ( arr1 [ i ] ) ; for ( int j = 0 ; j < n ; j ++ ) if ( us . find ( x - arr2 [ j ] ) != us . end ( ) ) count ++ ; return count ; }
int lis ( int arr [ ] , int n ) { int lis [ n ] ; int i , j , max = 0 ; for ( i = 0 ; i < n ; i ++ ) lis [ i ] = 1 ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; for ( i = 0 ; i < n ; i ++ ) if ( max < lis [ i ] ) max = lis [ i ] ; return max ; }
string findSubString ( string str ) { int n = str . length ( ) ; int dist_count = 0 ; bool * visited = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { if ( visited [ str [ i ] ] == false ) { visited [ str [ i ] ] = true ; dist_count ++ ; } } int start = 0 , start_index = - 1 ; int min_len = INT_MAX ; int count = 0 ; int curr_count [ MAX_CHARS ] ; for ( int j = 0 ; j < n ; j ++ ) { curr_count [ str [ j ] ] ++ ; if ( curr_count [ str [ j ] ] == 1 ) count ++ ; if ( count == dist_count ) { while ( curr_count [ str [ start ] ] > 1 ) { if ( curr_count [ str [ start ] ] > 1 ) curr_count [ str [ start ] ] -- ; start ++ ; } int len_window = j - start + 1 ; if ( min_len > len_window ) { min_len = len_window ; start_index = start ; } } } return str . substr ( start_index , start_index + min_len ) ; }
void printSubsequences ( int arr [ ] , int n ) { int opsize = pow ( 2 , n ) ; for ( int counter = 1 ; counter < opsize ; counter ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( counter . second & 1 ) cout << arr [ j ] << " ▁ " ; } cout << endl ; } }
void bin ( unsigned n ) { if ( n > 1 ) bin ( n >> 1 ) ; cout << " % d " , n & 1 ) ; }
int minimumSquare ( int a , int b ) { int result = 0 , rem = 0 ; if ( a < b ) swap ( a , b ) ; while ( b > 0 ) { result += a / b ; rem = a % b ; a = b ; b = rem ; } return result ; }
void deleteElements ( int arr [ ] , int n , int k ) { stack < int > s ; s . push ( arr [ 0 ] ) ; int count = 0 ; for ( int i = 1 ; i < n ; i ++ ) { while ( ! s . empty ( ) && s . top ( ) < arr [ i ] && count < k ) { s . pop ( ) ; count ++ ; } s . push ( arr [ i ] ) ; } int m = s . size ( ) ; int v [ m ] ; while ( ! s . empty ( ) ) { v [ -- m ] = s . top ( ) ; s . pop ( ) ; } for ( int x : v ) { cout << x << " ▁ " ; } ; cout << " \n " ; }
char first ( string str ) { for ( int i = 0 ; i < str . length ( ) ; i ++ ) if ( isupper ( str [ i ] ) ) return str [ i ] ; return 0 ; }
void findSymPairs ( int arr [ ] [ 2 ] , int n ) { unordered_map < int , int > hM ; for ( int i = 0 ; i < n ; i ++ ) { int first = arr [ i ] [ 0 ] ; int sec = arr [ i ] [ 1 ] ; int val = hM [ sec ] ; if ( val != null && val == first ) cout << " ( " << sec << " , ▁ " << first << " ) " << endl ; else hM [ sec ] = first ; } }
int isPossible ( int n , int index , int modulo , int M , int arr [ ] , int dp [ ] [ MAX ] ) { modulo = ( ( modulo % M ) + M ) % M ; if ( index == n ) { if ( modulo == 0 ) return 1 ; return 0 ; } if ( dp [ index ] [ modulo ] != - 1 ) return dp [ index ] [ modulo ] ; int placeAdd = isPossible ( n , index + 1 , modulo + arr [ index ] , M , arr , dp ) ; int placeMinus = isPossible ( n , index + 1 , modulo - arr [ index ] , M , arr , dp ) ; int res = placeAdd ; dp [ index ] [ modulo ] = res ; return res ; }
void amendSentence ( string sstr ) { for ( int i = 0 ; str [ i ] != ' \0' ; i ++ ) { if ( str [ i ] >= ' A ' && str [ i ] <= ' Z ' ) { str [ i ] = ( char ) ( str [ i ] + 32 ) ; if ( i != 0 ) cout << " ▁ " ; cout << str [ i ] ; } else cout << str [ i ] ; } }
int find ( int a [ ] , int b [ ] , int k , int n1 , int n2 ) { unordered_set < int > s ; for ( int i = 0 ; i < n2 ; i ++ ) s . insert ( b [ i ] ) ; int missing = 0 ; for ( int i = 0 ; i < n1 ; i ++ ) { if ( s . find ( a [ i ] ) == s . end ( ) ) missing ++ ; if ( missing == k ) return a [ i ] ; } return - 1 ; }
int countNumber ( int n ) { int result = 0 ; for ( int i = 1 ; i <= 9 ; i ++ ) { stack < int > s ; if ( i <= n ) { s . push ( i ) ; result ++ ; } while ( ! s . empty ( ) ) { int tp = s . top ( ) ; s . pop ( ) ; for ( int j = tp % 10 ; j <= 9 ; j ++ ) { int x = tp * 10 + j ; if ( x <= n ) { s . push ( x ) ; result ++ ; } } } } return result ; }
char getMaxOccuringChar ( string str ) { int count [ ASCII_SIZE ] = { 0 } ; int len = str . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) count [ str [ i ] ] ++ ; int max = - 1 ; char result = ' ▁ ' ; for ( int i = 0 ; i < len ; i ++ ) { if ( max < count [ str [ i ] ] ) { max = count [ str [ i ] ] ; result = str [ i ] ; } } return result ; }
int longLenSub ( int arr [ ] , int n ) { unordered_map < int , int > um ; int longLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int len = 0 ; if ( um . find ( arr [ i ] - 1 ) != um . end ( ) ) len = um [ arr [ i ] - 1 ] ; if ( um [ arr [ i ] + 1 ] != um . end ( ) ) len = um [ arr [ i ] + 1 ] ; um [ arr [ i ] ] = len + 1 ; if ( longLen < um [ arr [ i ] ] ) longLen = um [ arr [ i ] ] ; } return longLen ; }
int getMinDiff ( int arr [ ] , int n , int k ) { if ( n == 1 ) return 0 ; sort ( arr , arr + n ) ; int ans = arr [ n - 1 ] - arr [ 0 ] ; int small = arr [ 0 ] + k ; int big = arr [ n - 1 ] - k ; int temp = 0 ; if ( small > big ) { temp = small ; small = big ; big = temp ; } for ( int i = 1 ; i < n - 1 ; i ++ ) { int subtract = arr [ i ] - k ; int add = arr [ i ] + k ; if ( subtract >= small || add <= big ) continue ; if ( big - subtract <= add - small ) small = subtract ; else big = add ; } return min ( ans , big - small ) ; }
void printCommonElements ( int mat [ M ] [ N ] ) { unordered_map < int , int > mp ; for ( int j = 0 ; j < N ; j ++ ) mp [ mat [ 0 ] [ j ] ] = 1 ; for ( int i = 1 ; i < M ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( mp . find ( mat [ i ] [ j ] ) != mp . end ( ) ) { mp [ mat [ i ] [ j ] ] = i + 1 ; if ( i == M - 1 ) cout << mat [ i ] [ j ] << " ▁ " ; } } } }
void printkthnode ( vector < pair > adj [ ] , int wt [ ] , int n , int k ) { for ( int i = 0 ; i < n ; i ++ ) sort ( adj [ i ] , adj + n , greater < pair > ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( adj [ i ] . size ( ) >= k ) cout << adj [ i ] [ adj [ i ] . size ( ) - k ] . second << " ▁ " ; else cout << " - 1" ; } }
void commonCharacters ( char * str , int n ) { bool prim [ MAX_CHAR ] ; memset ( prim , false , sizeof ( prim ) ) ; for ( int i = 0 ; i < n ; i ++ ) { bool sec [ MAX_CHAR ] ; memset ( sec , false , sizeof ( sec ) ) ; for ( int j = 0 ; j < str [ i ] . length ( ) ; j ++ ) { if ( prim [ str [ i ] [ j ] - ' a ' ] ) sec [ str [ i ] [ j ] - ' a ' ] = true ; } cout << sec << 0 << " ▁ " ; } for ( int i = 0 ; i < 26 ; i ++ ) if ( prim [ i ] ) { cout << toChars ( i + 97 ) ; cout << " ▁ " ; } }
bool canMakeStr2 ( string str1 , string str2 ) { int count [ MAX ] ; char str3 [ MAX ] = { 0 } ; for ( int i = 0 ; i < str3 . length ; i ++ ) count [ str3 [ i ] ] ++ ; char str4 [ MAX ] = { 0 } ; for ( int i = 0 ; i < str4 . length ; i ++ ) { if ( count [ str4 [ i ] ] == 0 ) return false ; count [ str4 [ i ] ] -- ; } return true ; }
int count ( string a , string b , int m , int n ) { if ( ( m == 0 && n == 0 ) || n == 0 ) return 1 ; if ( m == 0 ) return 0 ; if ( a [ m - 1 ] == b [ n - 1 ] ) return count ( a , b , m - 1 , n - 1 ) + count ( a , b , m - 1 , n ) ; else return count ( a , b , m - 1 , n ) ; }
int numofArray ( int n , int m ) { int dp [ MAX ] [ MAX ] ; vector < int > di [ MAX ] ; vector < int > mu [ MAX ] ; memset ( dp , 0 , sizeof dp ) ; memset ( di , 0 , sizeof di ) ; memset ( mu , 0 , sizeof mu ) ; for ( int i = 0 ; i < MAX ; i ++ ) { di [ i ] = new vector < int > ( ) ; mu [ i ] = new vector < int > ( ) ; } for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 2 * i ; j <= m ; j += i ) { di [ j ] . push_back ( i ) ; mu [ i ] . push_back ( j ) ; } di [ i ] . push_back ( i ) ; } for ( int i = 1 ; i <= m ; i ++ ) dp [ 1 ] [ i ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { dp [ i ] [ j ] = 0 ; for ( Integer x : di [ j ] ) dp [ i ] [ j ] += dp [ i - 1 ] [ x ] ; for ( Integer x : mu [ j ] ) dp [ i ] [ j ] += dp [ i - 1 ] [ x ] ; } } int ans = 0 ; for ( int i = 1 ; i <= m ; i ++ ) { ans += dp [ n ] [ i ] ; di [ i ] . clear ( ) ; mu [ i ] . clear ( ) ; } return ans ; }
int findSubarraySum ( int arr [ ] , int n ) { int res = 0 ; unordered_map < int , int > m ; for ( int i = 0 ; i < n ; i ++ ) { int sum = 0 ; for ( int j = i ; j < n ; j ++ ) { sum += arr [ j ] ; if ( m . find ( sum ) != m . end ( ) ) { m [ sum ] ++ ; } else m [ sum ] = 1 ; } } for ( auto x : m ) if ( x . second == 1 ) res += x . first ; return res ; }
void findpath ( int graph [ ] [ MAX ] , int n ) { vector < int > numofadj ; for ( int i = 0 ; i < n ; i ++ ) numofadj . push_back ( accumulate ( graph [ i ] , 0 ) ) ; int startPoint = 0 , numofodd = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( numofadj . elementAt ( i ) % 2 == 1 ) { numofodd ++ ; startPoint = i ; } } if ( numofodd > 2 ) { cout << " No ▁ Solution " ; return ; } stack < int > stack ; vector < int > path ; int cur = startPoint ; while ( ! stack . empty ( ) || accumulate ( graph [ cur ] , 0 ) != 0 ) { if ( accumulate ( graph [ cur ] , 0 ) == 0 ) { path . push ( cur ) ; cur = stack . pop ( ) ; } else { for ( int i = 0 ; i < n ; i ++ ) { if ( graph [ cur ] [ i ] == 1 ) { stack . push_back ( cur ) ; graph [ cur ] [ i ] = 0 ; graph [ i ] [ cur ] = 0 ; cur = i ; break ; } } } for ( int ele : path ) cout << ele << " ▁ - > ▁ " ; cout << cur ; }
int sumBetweenTwoKth ( int arr [ ] , int k1 , int k2 ) { sort ( arr , arr + k1 ) ; int result = 0 ; for ( int i = k1 ; i < k2 - 1 ; i ++ ) result += arr [ i ] ; return result ; }
int calculate ( int a [ ] , int n ) { int maximum = * max_element ( a , a + n ) ; int frequency [ maximum + 1 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) frequency [ a [ i ] ] += 1 ; int answer = 0 ; for ( int i = 0 ; i < ( maximum ) + 1 ; i ++ ) { answer = answer + frequency [ i ] * ( frequency [ i ] - 1 ) ; } return answer / 2 ; }
int sumNodes ( int l ) { int leafNodeCount = pow ( 2 , l - 1 ) ; vector < int > vec ; for ( int i = 1 ; i <= l ; i ++ ) vec . push_back ( new vector < int > ( ) ) ; for ( int i = 1 ; i <= leafNodeCount ; i ++ ) vec [ l - 1 ] . push_back ( i ) ; for ( int i = l - 2 ; i >= 0 ; i -- ) { int k = 0 ; while ( k < vec [ i + 1 ] . size ( ) - 1 ) { vec [ i ] . push_back ( vec [ i + 1 ] [ k ] + vec [ i + 1 ] [ k + 1 ] ) ; k += 2 ; } } int sum = 0 ; for ( int i = 0 ; i < l ; i ++ ) { for ( int j = 0 ; j < vec [ i ] . size ( ) ; j ++ ) sum += vec [ i ] [ j ] ; } return sum ; }
string encrypt ( string text , int s ) { string result ; for ( int i = 0 ; i < text . length ( ) ; i ++ ) { if ( isupper ( text [ i ] ) ) { char ch = ( char ) ( ( ( int ) text [ i ] + s - 65 ) % 26 + 65 ) ; result . append ( ch ) ; } else { char ch = ( char ) ( ( ( int ) text [ i ] + s - 97 ) % 26 + 97 ) ; result . append ( ch ) ; } } return result ; }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; if ( b == 0 ) return a ; int k ; for ( k = 0 ; ( ( a | b ) & 1 ) == 0 ; ++ k ) { a >>= 1 ; b >>= 1 ; } while ( ( a & 1 ) == 0 ) a >>= 1 ; do { while ( ( b & 1 ) == 0 ) b >>= 1 ; if ( a > b ) swap ( a , b ) ; } b = ( b - a ) ; } while ( b != 0 ) ; return a << k ; }
int calculateSum ( string arr [ ] , int n ) { if ( n == 0 ) return 0 ; string s = arr [ 0 ] ; int value = parseInt ( s ) ; int sum = value ; for ( int i = 2 ; i < n ; i = i + 2 ) { s = arr [ i ] ; value = parseInt ( s ) ; int operation = arr [ i - 1 ] [ 0 ] ; if ( operation == ' + ' ) sum += value ; else sum -= value ; } return sum ; }
string replace ( string s , char c1 , char c2 ) { int l = s . length ( ) ; char arr [ l ] ; for ( int i = 0 ; i < l ; i ++ ) { if ( arr [ i ] == c1 ) arr [ i ] = c2 ; else if ( arr [ i ] == c2 ) arr [ i ] = c1 ; } return s ; }
string lexicographicSubConcat ( string s ) { int n = s . length ( ) ; int sub_count = n * ( n + 1 ) / 2 ; string arr [ sub_count ] ; int index = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int len = 1 ; len <= n - i ; len ++ ) { arr [ index ++ ] = s . substr ( i , i + len ) ; } sort ( arr , arr + sub_count ) ; string res = " " ; for ( int i = 0 ; i < sub_count ; i ++ ) res += arr [ i ] ; return res ; }
int findpos ( string n ) { int k = 0 , pos = 0 , i = 0 ; while ( k != n . length ( ) ) { switch ( n [ i ] ) { case '4' : pos = pos * 2 + 1 ; break ; case '7' : pos = pos * 2 + 2 ; break ; } i ++ ; k ++ ; } return pos ; }
long yMod ( long y , long x ) { if ( log2 ( y ) / log2 ( 2 ) ) < x ) return y ; if ( x > 63 ) return y ; return ( y % ( 1 << ( int ) x ) ) ; }
int lis ( int arr [ ] , int n ) { int mpis [ n ] ; int max = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) mpis [ i ] = arr [ i ] ; for ( int i = 1 ; i < n ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && mpis [ i ] < ( mpis [ j ] * arr [ i ] ) ) mpis [ i ] = mpis [ j ] * arr [ i ] ; for ( int k = 0 ; k < mpis . length ; k ++ ) if ( mpis [ k ] > max ) { max = mpis [ k ] ; } } return max ; }
bool checkSorted ( int n ) { stack < int > st ; int expected = 1 ; int fnt ; while ( ! q . empty ( ) ) { fnt = q . top ( ) ; q . pop ( ) ; if ( fnt == expected ) expected ++ ; else { if ( st . empty ( ) == 0 ) { st . push ( fnt ) ; } else if ( st . size ( ) != 0 && st . top ( ) < fnt ) { return false ; } else st . push ( fnt ) ; } while ( st . empty ( ) != 0 && st . top ( ) == expected ) { st . pop ( ) ; expected ++ ; } } if ( expected - 1 == n && st . size ( ) == 0 ) return true ; return false ; }
void generate ( set < string > st , string s ) { if ( s . length ( ) == 0 ) return ; if ( st . find ( s ) == st . end ( ) ) { st . insert ( s ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { string t = s ; t = t . substr ( 0 , i ) + t . substr ( i + 1 ) ; generate ( st , t ) ; } } return ; }
string minLexRotation ( string str ) { int n = str . length ( ) ; string arr [ n ] ; string concat = str + str ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = concat . substr ( i , i + n ) ; sort ( arr , arr + n ) ; return arr [ 0 ] ; }
bool isPossible ( int a [ ] , int b [ ] , int n , int k ) { sort ( a , a + n , greater < int > ( ) ) ; sort ( b , b + n , greater < int > ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) if ( a [ i ] + b [ i ] < k ) return false ; return true ; }
bool isCornerPresent ( string str , string corner ) { int n = str . length ( ) ; int cl = corner . length ( ) ; if ( n < cl ) return false ; return ( str [ 0 ] == corner && str [ n - cl ] . equals ( corner ) ) ; }
string longDivision ( string number , int divisor ) { string ans = " " ; int idx = 0 ; char num [ ] ; int temp = num [ idx ] - '0' ; while ( temp < divisor ) temp = temp * 10 + ( num [ ++ idx ] - '0' ) ; idx += 1 ; while ( num [ idx ] > idx ) { ans += ( temp / divisor ) ; temp = ( temp % divisor ) * 10 + num [ idx ++ ] - '0' ; } if ( ans . length ( ) == 0 ) return "0" ; return ans ; }
void sort012 ( int a [ ] , int arr_size ) { int lo = 0 ; int hi = arr_size - 1 ; int mid = 0 , temp = 0 ; while ( mid <= hi ) { switch ( a [ mid ] ) { case 0 : { swap ( a [ lo ] , a [ mid ] ) ; lo ++ ; mid ++ ; break ; } case 1 : mid ++ ; break ; case 2 : { swap ( a [ mid ] , a [ hi ] ) ; hi -- ; break ; } } }
bool canRepresentBST ( int pre [ ] , int n ) { stack < int > s ; int root = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { if ( pre [ i ] < root ) return false ; while ( ! s . empty ( ) && s . top ( ) < pre [ i ] ) { root = s . top ( ) ; s . pop ( ) ; } s . push ( pre [ i ] ) ; } return true ; }
int find_maximum ( int a [ ] , int n , int k ) { unordered_map < int , int > b ; for ( int i = 0 ; i < n ; i ++ ) { int x = a [ i ] ; int d = min ( 1 + i , n - i ) ; if ( b . find ( x ) == b . end ( ) ) b [ x ] = d ; else b [ x ] = min ( d , b [ x ] ) ; } int ans = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { int x = a [ i ] ; if ( x != k - x && b . find ( k - x ) != b . end ( ) ) ans = min ( max ( b [ x ] , b [ k - x ] ) , ans ) ; } return ans ; }
int solveQuery ( int start , int end , int arr [ ] , int n ) { unordered_map < int , int > mp ; for ( int i = start ; i <= end ; i ++ ) mp [ arr [ i ] ] ++ ; int count = 0 ; for ( auto entry : mp ) if ( entry . second == entry . first ) count ++ ; return count ; }
bool divisibleBy20 ( string num ) { int lastTwoDigits = parseInt ( num . substr ( num . length ( ) - 2 ) ) ; return ( ( lastTwoDigits % 5 == 0 ) && ( lastTwoDigits % 4 == 0 ) ) ; }
void CountTriangles ( int A [ ] , int n ) { sort ( A , A + n ) ; int count = 0 ; for ( int i = n - 1 ; i >= 1 ; i -- ) { int l = 0 , r = i - 1 ; while ( l < r ) { if ( A [ l ] + A [ r ] > A [ i ] ) { count += r - l ; r -- ; } else { l ++ ; } } } cout << " No ▁ of ▁ possible ▁ solutions : ▁ " << count << endl ; }
void countFreq ( int a [ ] , int n ) { unordered_map < int , int > hm ; for ( int i = 0 ; i < n ; i ++ ) hm [ a [ i ] ] ++ ; unordered_set < int > st ; for ( auto x : hm ) st . insert ( x . first ) ; int cumul = 0 ; for ( auto x : st ) { cumul += x . second ; cout << x . first << " ▁ " << cumul << endl ; } }
void cocktailSort ( int a [ ] , int n ) { bool swapped = true ; int start = 0 ; int end = n ; while ( swapped == true ) { swapped = false ; for ( int i = start ; i < end - 1 ; ++ i ) { if ( a [ i ] > a [ i + 1 ] ) { swap ( & a [ i ] , & a [ i + 1 ] ) ; swapped = true ; } } if ( swapped == false ) break ; swapped = false ; end = end - 1 ; for ( int i = end - 1 ; i >= start ; i -- ) { if ( a [ i ] > a [ i + 1 ] ) { swap ( & a [ i ] , & a [ i + 1 ] ) ; swapped = true ; } } start = start + 1 ; } }
char first ( string str , int i ) { if ( str [ i ] == ' \0' ) return 0 ; if ( isupper ( str [ i ] ) ) return str [ i ] ; return first ( str , i + 1 ) ; }
int longestNull ( string str ) { vector < Pair > arr ; arr . push_back ( ' @ ' , - 1 ) ; int maxlen = 0 ; for ( int i = 0 ; i < str . length ( ) ; ++ i ) { arr . push_back ( str [ i ] , i ) ; while ( arr . size ( ) >= 3 && arr [ arr . size ( ) - 3 ] . first == '1' && arr [ arr . size ( ) - 2 ] . first == '0' && arr [ arr . size ( ) - 1 ] . first == '0' ) { arr . pop_front ( ) ; arr . pop_front ( ) ; } int tmp = arr [ arr . size ( ) - 1 ] . second ; maxlen = max ( maxlen , i - tmp ) ; } return maxlen ; }
void reverse ( char str [ ] ) { int n = strlen ( str ) , i ; for ( i = 0 ; i < n / 2 ; i ++ ) swap ( str [ i ] , str [ n - i - 1 ] ) ; }
string nextWord ( string str ) { if ( str == " " ) return " a " ; int i = str . length ( ) - 1 ; while ( str [ i ] == ' z ' && i >= 0 ) i -- ; if ( i == - 1 ) str = str + ' a ' ; else str = str . substr ( 0 , i ) + ( char ) ( ( int ) ( str [ i ] ) + 1 ) + str [ i + 1 ] ; return str ; }
bool isRectangle ( int matrix [ ] [ 5 ] ) { int rows = matrix . size ( ) ; if ( rows == 0 ) return false ; int columns = matrix [ 0 ] . size ( ) ; unordered_map < int , int > table ; for ( int i = 0 ; i < rows ; i ++ ) { for ( int j = 0 ; j < columns - 1 ; j ++ ) { for ( int k = j + 1 ; k < columns ; k ++ ) { if ( table [ j ] . find ( k ) != table . end ( ) ) return true ; if ( table [ k ] . find ( j ) != table . end ( ) ) return true ; if ( table [ j ] . find ( k ) != table . end ( ) ) return true ; if ( table [ j ] . find ( k ) != table . end ( ) ) { set < int > x = new unordered_set < int > ( ) ; x . insert ( k ) ; table [ j ] . insert ( k ) ; } if ( ! table . find ( k ) ) { set < int > x = new unordered_set < int > ( ) ; x . insert ( j ) ; table [ k ] . insert ( j ) ; } } } } return false ; }
int lenOfLongSubarr ( int arr [ ] , int n ) { unordered_map < int , int > um ; int sum = 0 , maxLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] == 0 ? - 1 : 1 ; if ( sum == 1 ) maxLen = i + 1 ; else if ( um [ sum ] ) um [ sum ] = i ; if ( um [ sum - 1 ] ) { if ( maxLen < ( i - um [ sum - 1 ] ) ) maxLen = i - um [ sum - 1 ] ; } } return maxLen ; }
int sumoflength ( int arr [ ] , int n ) { unordered_set < int > s ; int j = 0 , ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { while ( j < n && s . find ( arr [ j ] ) == s . end ( ) ) { s . insert ( arr [ i ] ) ; j ++ ; } ans += ( ( j - i ) * ( j - i + 1 ) ) / 2 ; s . erase ( arr [ i ] ) ; } return ans ; }
void findTriplets ( int arr [ ] , int n ) { bool found = false ; for ( int i = 0 ; i < n - 1 ; i ++ ) { unordered_set < int > s ; for ( int j = i + 1 ; j < n ; j ++ ) { int x = - ( arr [ i ] + arr [ j ] ) ; if ( s . find ( x ) != s . end ( ) ) { printf ( " % d ▁ % d ▁ % d \n " , x , arr [ i ] , arr [ j ] ) ; found = true ; } else { s . insert ( arr [ j ] ) ; } } } if ( found == false ) { printf ( " ▁ No ▁ Triplet ▁ Found \n " ) ; } }
int maxPrefix ( char s [ ] , char t [ ] ) { int count = 0 ; for ( int i = 0 ; i < t . length ( ) ; i ++ ) { if ( count == t . length ( ) ) break ; if ( t [ i ] == s [ count ] ) count ++ ; } return count ; }
void segregateElements ( int arr [ ] , int n ) { int temp [ n ] ; int j = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] >= 0 ) temp [ j ++ ] = arr [ i ] ; if ( j == n || j == 0 ) return ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] < 0 ) temp [ j ++ ] = arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = temp [ i ] ; }
void mergeIntervals ( Interval arr [ ] , int n ) { sort ( arr , arr + n ) ; int index = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ index ] . end >= arr [ i ] . start ) { arr [ index ] . end = max ( arr [ index ] . end , arr [ i ] . end ) ; arr [ index ] . start = min ( arr [ index ] . start , arr [ i ] . start ) ; } else { arr [ index ] = arr [ i ] ; index ++ ; } } cout << " The ▁ Merged ▁ Intervals ▁ are : ▁ \n " ; for ( int i = 0 ; i <= index ; i ++ ) { cout << " [ " << arr [ i ] . start << " , " << arr [ i ] . end << " ] " ; } }
int findArea ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int dimension [ 2 ] = { 0 , 0 } ; for ( int i = 0 , j = 0 ; i < n - 1 && j < 2 ; i ++ ) if ( arr [ i ] == arr [ i + 1 ] ) dimension [ j ++ ] = arr [ i ++ ] ; return ( dimension [ 0 ] * dimension [ 1 ] ) ; }
int minOps ( int arr [ ] , int n , int k ) { sort ( arr , arr + n ) ; int max = arr [ arr . length - 1 ] ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( max - arr [ i ] ) % k != 0 ) return - 1 ; else res += ( max - arr [ i ] ) / k ; } return res ; }
bool isDivisible7 ( char num [ ] ) { int n = strlen ( num ) ; if ( n == 0 && num [ 0 ] == '0' ) return true ; if ( n % 3 == 1 ) num = "00" + num ; if ( n % 3 == 2 ) num = "0" + num ; n = num . length ( ) ; int gSum = 0 , p = 1 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { int group = 0 ; group += num [ i -- ] - '0' ; group += ( num [ i -- ] - '0' ) * 10 ; group += ( num [ i ] - '0' ) * 100 ; gSum = gSum + group * p ; p = p * - 1 ; } return ( gSum % 7 == 0 ) ; }
bool isDivisible999 ( char num [ ] ) { int n = strlen ( num ) ; if ( n == 0 && num [ 0 ] == '0' ) return true ; if ( n % 3 == 1 ) num = "00" + num ; if ( n % 3 == 2 ) num = "0" + num ; int gSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int group = 0 ; group += ( num [ i ++ ] - '0' ) * 100 ; group += ( num [ i ++ ] - '0' ) * 10 ; group += num [ i ] - '0' ; gSum += group ; } if ( gSum > 1000 ) { num = to_string ( gSum ) ; n = num . length ( ) ; gSum = isDivisible999 ( num ) ? 1 : 0 ; } return ( gSum == 999 ) ; }
bool checkPangram ( string str ) { bool mark [ 26 ] ; int index = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( ' A ' <= str [ i ] && str [ i ] <= ' Z ' ) index = str [ i ] - ' A ' ; else if ( ' a ' <= str [ i ] && str [ i ] <= ' z ' ) index = str [ i ] - ' a ' ; mark [ index ] = true ; } for ( int i = 0 ; i <= 25 ; i ++ ) if ( mark [ i ] == false ) return ( false ) ; return ( true ) ; }
void kLargest ( int arr [ ] , int k ) { sort ( arr , arr + k ) ; for ( int i = 0 ; i < k ; i ++ ) cout << arr [ i ] << " ▁ " ; }
int kthLargestSum ( int arr [ ] , int n , int k ) { int sum [ n + 1 ] ; sum [ 0 ] = 0 ; sum [ 1 ] = arr [ 0 ] ; for ( int i = 2 ; i <= n ; i ++ ) sum [ i ] = sum [ i - 1 ] + arr [ i - 1 ] ; priority_queue < int > Q ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = i ; j <= n ; j ++ ) { int x = sum [ j ] - sum [ i - 1 ] ; if ( Q . size ( ) < k ) Q . push ( x ) ; else { if ( Q . top ( ) < x ) { Q . pop ( ) ; Q . push ( x ) ; } } } } return Q . front ( ) ; }
void printDistinct ( int arr [ ] , int n ) { unordered_set < int > uset ; for ( int i = 0 ; i < n ; i ++ ) { if ( uset . count ( arr [ i ] ) == 0 ) { uset . insert ( arr [ i ] ) ; cout << arr [ i ] << " ▁ " ; } } }
int abFree ( char s [ ] ) { int b_count = 0 ; int res = 0 ; for ( int i = 0 ; i < strlen ( s ) ; i ++ ) { if ( s [ i ] == ' a ' ) { res = ( res + b_count ) ; b_count = ( b_count * 2 ) ; } else { b_count += 1 ; } } return res ; }
void findFibSubset ( int x [ ] , int n ) { int max = max ( x , x + n ) ; vector < int > fib ; vector < int > result ; int a = 0 ; int b = 1 ; while ( b < max ) { int c = a + b ; a = b ; b = c ; fib . push_back ( c ) ; } for ( int i = 0 ; i < n ; i ++ ) { if ( fib . find ( x [ i ] ) != fib . end ( ) ) { result . push_back ( x [ i ] ) ; } } cout << result ; }
void recursiveReverse ( char str [ ] , int i ) { int n = strlen ( str ) ; if ( i == n / 2 ) return ; swap ( str , i , n - i - 1 ) ; recursiveReverse ( str , i + 1 ) ; }
int findGreatest ( int arr [ ] , int n ) { unordered_map < int , int > m ; for ( int i = 0 ; i < n ; i ++ ) m [ arr [ i ] ] ++ ; sort ( arr , arr + n , greater < int > ( ) ) ; for ( int i = n - 1 ; i > 1 ; i -- ) { for ( int j = 0 ; j < i && arr [ j ] <= sqrt ( arr [ i ] ) ; j ++ ) { if ( arr [ i ] % arr [ j ] == 0 ) { int result = arr [ i ] / arr [ j ] ; if ( result != arr [ j ] && m [ result ] == null || m [ result ] > 0 ) return arr [ i ] ; } else if ( result == arr [ j ] && m [ result ] > 1 ) return arr [ i ] ; } } } return - 1 ; }
string noAdjacentDup ( string s1 ) { int n = s1 . length ( ) ; char s [ n ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( s [ i ] == s [ i - 1 ] ) { s [ i ] = ' a ' ; while ( s [ i ] == s [ i + 1 ] ) s [ i ] ++ ; i ++ ; } } return s ; }
void query ( char * s , int i , int j ) { int n = strlen ( s ) ; i %= n ; j %= n ; if ( s [ i ] == s [ j ] ) cout << " Yes " << endl ; else cout << " No " << endl ; }
int countPairs ( int arr [ ] , int n ) { int result = 0 ; unordered_set < int > Hash ; for ( int i = 0 ; i < n ; i ++ ) Hash . insert ( arr [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int product = arr [ i ] * arr [ j ] ; if ( Hash . find ( product ) != Hash . end ( ) ) { result ++ ; } } } return result ; }
void printInSortedOrder ( string arr [ ] , int n ) { int index [ n ] ; int i , j , min ; for ( i = 0 ; i < n ; i ++ ) { index [ i ] = i ; } for ( i = 0 ; i < n - 1 ; i ++ ) { min = i ; for ( j = i + 1 ; j < n ; j ++ ) { if ( arr [ index [ min ] ] . compare ( arr [ index [ j ] ] ) > 0 ) { min = j ; } } if ( min != i ) swap ( index [ min ] , index [ i ] ) ; } } for ( i = 0 ; i < n ; i ++ ) cout << arr [ index [ i ] ] << " ▁ " ; }
void sortUsingHash ( vector < int > & a , int n ) { int max = * max_element ( a , a + n ) ; int min = * min_element ( a , a + n ) ; int hashpos [ max + 1 ] ; int hashneg [ min + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] >= 0 ) hashpos [ a [ i ] ] += 1 ; else hashneg [ abs ( a [ i ] ) ] += 1 ; } for ( int i = min ; i > 0 ; i -- ) { if ( hashneg [ i ] > 0 ) { for ( int j = 0 ; j < hashneg [ i ] ; j ++ ) { cout << ( - 1 ) * i << " ▁ " ; } } } for ( int i = 0 ; i <= max ; i ++ ) { if ( hashpos [ i ] > 0 ) { for ( int j = 0 ; j < hashpos [ i ] ; j ++ ) { cout << i << " ▁ " ; } } }
void smallestSubsegment ( int a [ ] , int n ) { unordered_map < int , int > left , count ; int mx = 0 ; int mn = - 1 , strindex = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { int x = a [ i ] ; if ( count [ x ] == null ) { left [ x ] = i ; count [ x ] = 1 ; } else count [ x ] ++ ; if ( count [ x ] > mx ) { mx = count [ x ] ; mn = i - left [ x ] + 1 ; strindex = left [ x ] ; } else if ( count [ x ] == mx ) && ( i - left [ x ] + 1 < mn ) ) { mn = i - left [ x ] + 1 ; strindex = left [ x ] ; } } for ( int i = strindex ; i < strindex + mn ; i ++ ) cout << a [ i ] << " ▁ " ; }
void findRandomIndexOfMax ( int arr [ ] , int n ) { unordered_map < int , int > mp ; for ( int i = 0 ; i < n ; i ++ ) mp [ arr [ i ] ] ++ ; int max_element = INT_MIN ; int max_so_far = INT_MIN ; for ( auto p : mp ) if ( p . second > max_so_far ) { max_so_far = p . second ; max_element = p . first ; } } int r = ( random ( ) . nextInt ( max_so_far ) % max_so_far ) + 1 ; for ( int i = 0 , count = 0 ; i < n ; i ++ ) { if ( arr [ i ] == max_element ) count ++ ; if ( count == r ) { cout << " Element ▁ with ▁ maximum ▁ frequency ▁ present ▁ " << " at ▁ index ▁ " << i << " \n " ; break ; } } }
int singleNumber ( int a [ ] , int n ) { unordered_set < int > s ; for ( int i : a ) s . insert ( i ) ; int arr_sum = 0 ; for ( int i : a ) { arr_sum += i ; } int set_sum = 0 ; for ( int i : s ) { set_sum += i ; } return ( 3 * set_sum - arr_sum ) / 2 ; }
void printAllAPTriplets ( int arr [ ] , int n ) { vector < int > s ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int diff = arr [ j ] - arr [ i ] ; bool exists = s . find ( arr [ i ] - diff ) != s . end ( ) ; if ( exists ) cout << arr [ i ] - diff << " ▁ " << arr [ i ] << " ▁ " << arr [ j ] << endl ; } s . push_back ( arr [ i ] ) ; } }
string simplify ( string str ) { int len = str . length ( ) ; char res [ len ] ; int index = 0 , i = 0 ; stack < int > s ; s . push ( 0 ) ; while ( i < len ) { if ( str [ i ] == ' + ' ) { if ( s . top ( ) == 1 ) res [ index ++ ] = ' - ' ; if ( s . top ( ) == 0 ) res [ index ++ ] = ' + ' ; } else if ( str [ i ] == ' - ' ) { if ( s . top ( ) == 1 ) res [ index ++ ] = ' + ' ; else if ( s . top ( ) == 0 ) res [ index ++ ] = ' - ' ; } else if ( str [ i ] == ' ( ' && i > 0 ) { if ( str [ i - 1 ] == ' - ' ) { int x = ( s . top ( ) == 1 ) ? 0 : 1 ; s . push ( x ) ; } else if ( str [ i - 1 ] == ' + ' ) s . push ( s . top ( ) ) ; } else if ( str [ i ] == ' ) ' ) s . pop ( ) ; else res [ index ++ ] = str [ i ] ; i ++ ; } return res ; }
void findMajority ( int arr [ ] , int n ) { unordered_map < int , int > map ; for ( int i = 0 ; i < n ; i ++ ) { map [ arr [ i ] ] ++ ; if ( count > arr . length / 2 ) { cout << " Majority ▁ found ▁ : - ▁ " << arr [ i ] << endl ; return ; } else map [ arr [ i ] ] = 1 ; } cout << " ▁ No ▁ Majority ▁ element " << endl ; }
void findPair ( int arr [ ] , int n ) { unordered_set < int > s ; for ( int i : arr ) s . insert ( i ) ; bool found = false ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int sum = arr [ i ] + arr [ j ] ; if ( s . find ( sum ) != s . end ( ) ) { found = true ; cout << arr [ i ] << " ▁ " << arr [ j ] << endl ; } } } if ( found == false ) cout << " Not ▁ Exist ▁ " << endl ; }
void strToBinary ( string s ) { int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int val = int . valueOf ( s [ i ] ) ; string bin = " " ; while ( val > 0 ) { if ( val % 2 == 1 ) bin += '1' ; else bin += '0' ; val /= 2 ; } bin = reverse ( bin ) ; cout << bin << " ▁ " ; } }
bool findDuplicateparenthesis ( string s ) { stack < char > Stack ; for ( char ch : s ) { if ( ch == ' ) ' ) { char top = Stack . top ( ) ; Stack . pop ( ) ; int elementsInside = 0 ; while ( top != ' ( ' ) { elementsInside ++ ; top = Stack . top ( ) ; Stack . pop ( ) ; } if ( elementsInside < 1 ) return true ; } else { Stack . push ( ch ) ; } } return false ; }
void findTriplets ( int x ) { vector < int > fact ; unordered_set < int > factors ; for ( int i = 2 ; i <= sqrt ( x ) ; i ++ ) { if ( x % i == 0 ) { fact . push_back ( i ) ; if ( x / i != i ) fact . push_back ( x / i ) ; factors . push_back ( i ) ; factors . push_back ( x / i ) ; } } bool found = false ; int k = fact . size ( ) ; for ( int i = 0 ; i < k ; i ++ ) { int a = fact [ i ] ; for ( int j = 0 ; j < k ; j ++ ) { int b = fact [ j ] ; if ( ( a != b ) && ( x / ( a * b ) != a ) && ( x / ( a * b ) != b ) && ( x / ( a * b ) != 1 ) ) { cout << a << " ▁ " << b << " ▁ " << ( x / ( a * b ) ) ; found = true ; break ; } } if ( found ) break ; } if ( ! found ) cout << " - 1" ; }
void findMissing ( int a [ ] , int b [ ] , int n , int m ) { unordered_set < int > s ; for ( int i = 0 ; i < m ; i ++ ) s . insert ( b [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) if ( s . find ( a [ i ] ) == s . end ( ) ) cout << a [ i ] << " ▁ " ; }
void minheapify ( int a [ ] , int index ) { int small = index ; int l = 2 * index + 1 ; int r = 2 * index + 2 ; if ( l < n && a [ l ] < a [ small ] ) small = l ; if ( r < n && a [ r ] < a [ small ] ) small = r ; if ( small != index ) swap ( a [ small ] , a [ index ] ) ; minheapify ( a , small ) ; }
void KMP ( int m , int n , string str2 , string str1 ) { int pos = 0 , len = 0 ; int p [ m + 1 ] ; int k = 0 ; char ch1 [ str1 [ 0 ] , ch2 [ str2 [ 0 ] ] ; for ( int i = 2 ; i <= n ; i ++ ) { while ( k > 0 && ch1 [ k ] != ch1 [ i - 1 ] ) k = p [ k ] ; if ( ch1 [ k ] == ch1 [ i - 1 ] ) ++ k ; p [ i ] = k ; } for ( int j = 0 , i = 0 ; i < m ; i ++ ) { while ( j > 0 && j < n && ch1 [ j ] != ch2 [ i ] ) j = p [ j ] ; if ( j < n && ch1 [ j ] == ch2 [ i ] ) j ++ ; if ( j > len ) { len = j ; pos = i - j + 1 ; } } cout << " Shift ▁ = ▁ " << pos << endl ; cout << " Prefix ▁ = ▁ " << str1 [ 0 ] << len << endl ; }
void swapDiagonal ( int matrix [ ] [ N ] ) { for ( int i = 0 ; i < N ; i ++ ) swap ( matrix [ i ] [ i ] , matrix [ i ] [ N - i - 1 ] ) ; }
string maximumPalinUsingKChanges ( string str , int k ) { char palin [ str . size ( ) ] ; string ans = " " ; int l = 0 ; int r = str . size ( ) - 1 ; while ( l < r ) { if ( str [ l ] != str [ r ] ) { palin [ l ] = palin [ r ] = max ( str [ l ] , str [ r ] ) ; k -- ; } l ++ ; r -- ; } if ( k < 0 ) return " Not ▁ possible " ; } l = 0 ; r = str . size ( ) - 1 ; while ( l <= r ) { if ( l == r ) { if ( k > 0 ) { palin [ l ] = '9' ; } } if ( palin [ l ] < '9' ) { if ( k >= 2 && palin [ l ] == str [ l ] && palin [ r ] == str [ r ] ) { k -= 2 ; palin [ l ] = palin [ r ] = '9' ; } else if ( k >= 1 && ( palin [ l ] != str [ l ] || palin [ r ] != str [ r ] ) ) { k -- ; palin [ l ] = palin [ r ] = '9' ; } } l ++ ; r -- ; } for ( int i = 0 ; i < palin . size ( ) ; i ++ ) ans += palin [ i ] ; return ans ; }
int findMinRooms ( char * slots [ ] , int n , int m ) { int counts [ m ] = { 0 } ; for ( int i = 0 ; i < m ; i ++ ) counts [ i ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( slots [ i ] [ j ] == '1' ) counts [ j ] ++ ; int max = - 1 ; for ( int i = 0 ; i < m ; i ++ ) if ( max < counts [ i ] ) max = counts [ i ] ; return max ; }
int minProduct ( int arr [ ] , int n , int k ) { priority_queue < int > pq ; for ( int i = 0 ; i < n ; i ++ ) pq . push ( arr [ i ] ) ; int count = 0 , ans = 1 ; while ( ! pq . empty ( ) == false && count < k ) { ans = ans * pq . element ( ) ; pq . pop ( ) ; count ++ ; } return ans ; }
int largest ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; return arr [ n - 1 ] ; }
int firstElement ( int arr [ ] , int n , int k ) { unordered_map < int , int > count_map ; for ( int i = 0 ; i < n ; i ++ ) { int a = 0 ; if ( count_map [ arr [ i ] ] != count_map . end ( ) ) a = count_map [ arr [ i ] ] ; count_map [ arr [ i ] ] ++ ; } for ( int i = 0 ; i < n ; i ++ ) { if ( count_map [ arr [ i ] ] == k ) return arr [ i ] ; } } return - 1 ; }
int findLongestConseqSubseq ( int arr [ ] , int n ) { unordered_set < int > S ; for ( int i = 0 ; i < n ; i ++ ) S . insert ( arr [ i ] ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( S . find ( arr [ i ] ) != S . end ( ) ) { int j = arr [ i ] ; while ( S . find ( j ) != S . end ( ) ) j ++ ; ans = max ( ans , j - arr [ i ] ) ; } } return ans ; }
void divisibilityCheck ( int arr [ ] , int n ) { vector < int > s ; int max_ele = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { s . push_back ( arr [ i ] ) ; max_ele = max ( max_ele , arr [ i ] ) ; } unordered_set < int > res ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != 0 ) for ( int j = arr [ i ] * 2 ; j <= max_ele ; j += arr [ i ] ) { if ( s . find ( j ) != s . end ( ) ) res . push_back ( j ) ; } } vector < int > list ; reverse ( list , list + n ) ; cout << list . begin ( ) << " ▁ " ; }
int minPalPartion ( char * str ) { int n = strlen ( str ) ; int C [ n ] [ n ] ; bool P [ n ] [ n ] ; int i , j , k , L ; for ( i = 0 ; i < n ; i ++ ) { P [ i ] [ i ] = true ; C [ i ] [ i ] = 0 ; } for ( L = 2 ; L <= n ; L ++ ) { for ( i = 0 ; i < n - L + 1 ; i ++ ) { j = i + L - 1 ; if ( L == 2 ) P [ i ] [ j ] = ( str [ i ] == str [ j ] ) ; else P [ i ] [ j ] = ( str [ i ] == str [ j ] ) && P [ i + 1 ] [ j - 1 ] ; if ( P [ i ] [ j ] == true ) C [ i ] [ j ] = 0 ; else { C [ i ] [ j ] = INT_MAX ; for ( k = i ; k <= j - 1 ; k ++ ) C [ i ] [ j ] = min ( C [ i ] [ j ] , C [ i ] [ k ] + C [ k + 1 ] [ j ] + 1 ) ; } } } return C [ 0 ] [ n - 1 ] ; }
int height ( int N ) { return ceil ( log2 ( N + 1 ) / log ( 2 ) ) - 1 ; }
bool checkCount ( int arr [ ] , int n , int k ) { unordered_map < int , int > hash ; for ( int i = 0 ; i < n ; i ++ ) { hash [ arr [ i ] ] ++ ; } for ( auto x : hash ) if ( x . second > 2 * k ) return false ; return true ; }
void removeDuplicates ( char S [ ] ) { int n = strlen ( S ) ; if ( n < 2 ) return ; int j = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( S [ j ] != S [ i ] ) { j ++ ; S [ j ] = S [ i ] ; } } cout << S [ 0 ] << endl ; }
void KMaxCombinations ( int A [ ] , int B [ ] , int N , int K ) { priority_queue < int > pq ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) pq . push ( A [ i ] + B [ j ] ) ; int count = 0 ; while ( count < K ) { cout << pq . front ( ) ; pq . pop ( ) ; count ++ ; } }
int findRepeatingNumber ( int arr [ ] , int n ) { int sq = sqrt ( n ) ; int range = ( n / sq ) + 1 ; int count [ range ] = { 0 } ; for ( int i = 0 ; i <= n ; i ++ ) count [ arr [ i ] - 1 ] / sq ] ++ ; int selected_block = range - 1 ; for ( int i = 0 ; i < range - 1 ; i ++ ) { if ( count [ i ] > sq ) { selected_block = i ; break ; } } unordered_map < int , int > m ; for ( int i = 0 ; i <= n ; i ++ ) { if ( ( selected_block * sq ) < arr [ i ] ) && ( arr [ i ] <= ( ( selected_block + 1 ) * sq ) ) ) { m [ arr [ i ] ] = 1 ; if ( m [ arr [ i ] ] == 1 ) return arr [ i ] ; } } return - 1 ; }
string to_upper ( char in [ ] ) { for ( int i = 0 ; i < in . length ( ) ; i ++ ) if ( ' a ' <= in [ i ] & in [ i ] <= ' z ' ) { in [ i ] = ( char ) ( in [ i ] - ' a ' + ' A ' ) ; } } return in ; }
void sortInWave ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i += 2 ) { if ( i > 0 && arr [ i - 1 ] > arr [ i ] ) swap ( arr , i - 1 , i ) ; if ( i < n - 1 && arr [ i ] < arr [ i + 1 ] ) swap ( arr , i , i + 1 ) ; } }
string getMinNumberForPattern ( string seq ) { int n = seq . length ( ) ; if ( n >= 9 ) return " - 1" ; char result [ n + 1 ] ; int count = 1 ; for ( int i = 0 ; i <= n ; i ++ ) { if ( i == n || seq [ i ] == ' I ' ) { for ( int j = i - 1 ; j >= - 1 ; j -- ) { result [ j + 1 ] = ( char ) ( ( int ) '0' + count ++ ) ; if ( j >= 0 && seq [ j ] == ' I ' ) break ; } } } return result ; }
void findMin ( int V ) { vector < int > ans ; for ( int i = n - 1 ; i >= 0 ; i -- ) { while ( V >= deno [ i ] ) { V -= deno [ i ] ; ans . push_back ( deno [ i ] ) ; } } for ( int i = 0 ; i < ans . size ( ) ; i ++ ) { cout << " ▁ " << ans [ i ] << endl ; } }
int findRepeating ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; return sum - ( ( ( n - 1 ) * n ) / 2 ) ; }
string findSum ( string str1 , string str2 ) { if ( str1 . length ( ) > str2 . length ( ) ) swap ( str1 , str2 ) ; string str = " " ; int n1 = str1 . length ( ) , n2 = str2 . length ( ) ; str1 = reverse ( str1 . begin ( ) , str1 . end ( ) ) ; str2 = reverse ( str2 . begin ( ) , str2 . end ( ) ) ; int carry = 0 ; for ( int i = 0 ; i < n1 ; i ++ ) { int sum = ( ( str1 [ i ] - '0' ) + ( str2 [ i ] - '0' ) + carry ) ; str . push_back ( sum % 10 + '0' ) ; carry = sum / 10 ; } for ( int i = n1 ; i < n2 ; i ++ ) { int sum = ( ( str2 [ i ] - '0' ) + carry ) ; str . push_back ( sum % 10 + '0' ) ; carry = sum / 10 ; } if ( carry ) str . push_back ( carry + '0' ) ; str . pop_front ( ) ; return str ; }
