Src: 
void findWays ( int N ) { int [ ] dp = new int [ N + 1 ] ; dp [ 0 ] = 1 ; for ( int i = 1 ; i <= N ; i ++ ) { dp [ i ] = 0 ; for ( int j = 1 ; j <= 6 ; j ++ ) { if ( i - j >= 0 ) { dp [ i ] = dp [ i ] + dp [ i - j ] ; } } } System . out . print ( dp [ N ] ) ; }
Ref: 
def findWays ( N ) : NEW_LINE INDENT dp = [ 0 ] * ( N + 1 ) ; NEW_LINE dp [ 0 ] = 1 ; NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT dp [ i ] = 0 ; NEW_LINE for j in range ( 1 , 7 ) : NEW_LINE INDENT if ( i - j >= 0 ) : NEW_LINE INDENT dp [ i ] = dp [ i ] + dp [ i - j ] ; NEW_LINE DEDENT DEDENT DEDENT print ( dp [ N ] ) ; NEW_LINE DEDENT
Hyp: 
def findWays ( N ) : NEW_LINE INDENT dp = [ 0 for i in range ( N + 1 ) ] NEW_LINE dp [ 0 ] = 1 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT dp [ i ] = 0 NEW_LINE for j in range ( 1 , 6 + 1 ) : NEW_LINE INDENT if ( i - j >= 0 ) : NEW_LINE INDENT dp [ i ] = dp [ i ] + dp [ i - j ] NEW_LINE DEDENT DEDENT DEDENT print ( dp [ N ] ) NEW_LINE DEDENT

BLEU: 82.34
Edit Sim: 27


Src: 
int numberOfPairs ( int n ) { int count = 0 ; int i = 1 , j = n - 1 ; while ( i < j ) { if ( i + j == n ) { count ++ ; } i ++ ; j -- ; } return count ; }
Ref: 
def numberOfPairs ( n ) : NEW_LINE INDENT count = 0 NEW_LINE i = 1 NEW_LINE j = n - 1 NEW_LINE while ( i < j ) : NEW_LINE INDENT if ( i + j ) == n : NEW_LINE count += 1 NEW_LINE i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
Hyp: 
def numberOfPairs ( n ) : NEW_LINE INDENT count = 0 NEW_LINE i = 1 ; j = n - 1 NEW_LINE while ( i < j ) : NEW_LINE INDENT if ( i + j == n ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT

BLEU: 81.25
Edit Sim: 26


Src: 
int findkey ( int A , int B , int C ) { int ans = 0 ; int cur = 1 ; while ( A > 0 ) { int a = A % 10 ; int b = B % 10 ; int c = C % 10 ; A = A / 10 ; B = B / 10 ; C = C / 10 ; int m = Math . max ( a , Math . max ( c , b ) ) ; ans += cur * m ; cur = cur * 10 ; } return ans ; }
Ref: 
def findkey ( A , B , C ) : NEW_LINE INDENT ans = 0 NEW_LINE cur = 1 NEW_LINE while ( A > 0 ) : NEW_LINE INDENT a = A % 10 NEW_LINE b = B % 10 NEW_LINE c = C % 10 NEW_LINE A = A // 10 NEW_LINE B = B // 10 NEW_LINE C = C // 10 NEW_LINE m = max ( a , max ( c , b ) ) NEW_LINE ans += cur * m NEW_LINE cur = cur * 10 NEW_LINE DEDENT return ans NEW_LINE DEDENT
Hyp: 
def findkey ( A , B , C ) : NEW_LINE INDENT ans = 0 NEW_LINE cur = 1 NEW_LINE while ( A > 0 ) : NEW_LINE INDENT a = A % 10 NEW_LINE b = B % 10 NEW_LINE c = C % 10 NEW_LINE A = A // 10 NEW_LINE B = B // 10 NEW_LINE C = C // 10 NEW_LINE m = max ( a , max ( c , b ) ) NEW_LINE ans += cur * m NEW_LINE cur = cur * 10 NEW_LINE DEDENT return ans NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int count ( String a , String b , int m , int n ) { if ( ( m == 0 && n == 0 ) n == 0 ) return 1 ; if ( m == 0 ) return 0 ; if ( a . charAt ( m - 1 ) == b . charAt ( n - 1 ) ) return count ( a , b , m - 1 , n - 1 ) + count ( a , b , m - 1 , n ) ; else return count ( a , b , m - 1 , n ) ; }
Ref: 
def count ( a , b , m , n ) : NEW_LINE INDENT if ( ( m == 0 and n == 0 ) or n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( m == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( a [ m - 1 ] == b [ n - 1 ] ) : NEW_LINE INDENT return ( count ( a , b , m - 1 , n - 1 ) + count ( a , b , m - 1 , n ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return count ( a , b , m - 1 , n ) NEW_LINE DEDENT DEDENT
Hyp: 
def count ( a , b , m , n ) : NEW_LINE INDENT if ( not m and not n ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( not n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( a [ m - 1 ] == b [ n - 1 ] ) : NEW_LINE INDENT return count ( a , b , m - 1 , n - 1 ) + count ( a , b , m - 1 , n ) NEW_LINE DEDENT else : NEW_LINE INDENT return count ( a , b , m - 1 , n ) NEW_LINE DEDENT DEDENT

BLEU: 81.01
Edit Sim: 30


Src: 
void checkRightAngled ( int X1 , int Y1 , int X2 , int Y2 , int X3 , int Y3 ) { int A = ( int ) Math . pow ( ( X2 - X1 ) , 2 ) + ( int ) Math . pow ( ( Y2 - Y1 ) , 2 ) ; int B = ( int ) Math . pow ( ( X3 - X2 ) , 2 ) + ( int ) Math . pow ( ( Y3 - Y2 ) , 2 ) ; int C = ( int ) Math . pow ( ( X3 - X1 ) , 2 ) + ( int ) Math . pow ( ( Y3 - Y1 ) , 2 ) ; if ( ( A > 0 && B > 0 && C > 0 ) && ( A == ( B + C ) || B == ( A + C ) || C == ( A + B ) ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; }
Ref: 
def checkRightAngled ( X1 , Y1 , X2 , Y2 , X3 , Y3 ) : NEW_LINE INDENT A = ( int ( pow ( ( X2 - X1 ) , 2 ) ) + int ( pow ( ( Y2 - Y1 ) , 2 ) ) ) NEW_LINE B = ( int ( pow ( ( X3 - X2 ) , 2 ) ) + int ( pow ( ( Y3 - Y2 ) , 2 ) ) ) NEW_LINE C = ( int ( pow ( ( X3 - X1 ) , 2 ) ) + int ( pow ( ( Y3 - Y1 ) , 2 ) ) ) NEW_LINE if ( ( A > 0 and B > 0 and C > 0 ) and ( A == ( B + C ) or B == ( A + C ) or C == ( A + B ) ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
Hyp: 
def checkRightAngled ( X1 , Y1 , X2 , Y2 , X3 , Y3 ) : NEW_LINE INDENT A = ( pow ( X2 - X1 ) , 2 ) + ( pow ( Y2 - Y1 ) , 2 ) NEW_LINE B = ( pow ( X3 - X2 ) , 2 ) + ( pow ( Y3 - Y2 ) , 2 ) NEW_LINE C = ( pow ( X3 - X1 ) , 2 ) + ( pow ( ( Y3 - Y1 ) , 2 ) NEW_LINE if ( ( A > 0 and B > 0 and C > 0 ) and ( A == ( B + C ) or B == ( A + C ) or C == ( A + B ) ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT

BLEU: 78.07
Edit Sim: 58


Src: 
void find_winner ( String str , int n ) { String str1 = " " , str2 = " " ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { str1 += str . charAt ( i ) ; } else { str2 += str . charAt ( i ) ; } } char a [ ] = str1 . toCharArray ( ) ; Arrays . sort ( a ) ; char b [ ] = str2 . toCharArray ( ) ; Arrays . sort ( b ) ; str1 = new String ( a ) ; str2 = new String ( b ) ; if ( str1 . compareTo ( str2 ) < 0 ) System . out . print ( " A " ) ; else if ( str1 . compareTo ( str2 ) > 0 ) System . out . print ( " B " ) ; else System . out . print ( " Tie " ) ; }
Ref: 
def find_winner ( string , n ) : NEW_LINE INDENT string1 = " " ; string2 = " " ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT string1 += string [ i ] ; NEW_LINE DEDENT else : NEW_LINE INDENT string2 += string [ i ] ; NEW_LINE DEDENT DEDENT string1 = " " . join ( sorted ( string1 ) ) NEW_LINE string2 = " " . join ( sorted ( string2 ) ) NEW_LINE if ( string1 < string2 ) : NEW_LINE INDENT print ( " A " , end = " " ) ; NEW_LINE DEDENT elif ( string2 < string1 ) : NEW_LINE INDENT print ( " B " , end = " " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Tie " , end = " " ) ; NEW_LINE DEDENT DEDENT
Hyp: 
def find_winner ( str , n ) : NEW_LINE INDENT str1 = " " NEW_LINE str2 = " " NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT str1 += str [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT str2 += str [ i ] NEW_LINE DEDENT DEDENT a = list ( str1 ) NEW_LINE b = list ( b ) NEW_LINE if ( str1 . compareTo ( str2 ) < 0 ) : NEW_LINE INDENT print ( " A " ) NEW_LINE DEDENT elif ( str1 . compareTo ( str2 ) > 0 ) : NEW_LINE INDENT print ( " B " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Tie " ) NEW_LINE DEDENT DEDENT

BLEU: 45.99
Edit Sim: 179


Src: 
int findBitwiseORGivenXORAND ( int X , int Y ) { return X + Y ; }
Ref: 
def findBitwiseORGivenXORAND ( X , Y ) : NEW_LINE INDENT return X + Y NEW_LINE DEDENT
Hyp: 
def findBitwiseORGivenXORAND ( X , Y ) : NEW_LINE INDENT return X + Y NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
void findDirection ( int n , int m ) { if ( n > m ) { if ( m % 2 == 0 ) System . out . print ( "UpNEW_LINE"); else System . out . print ( "DownNEW_LINE"); } else { if ( n % 2 == 0 ) System . out . print ( "LeftNEW_LINE"); else System . out . print ( "RightNEW_LINE"); } }
Ref: 
def findDirection ( n , m ) : NEW_LINE INDENT if ( n > m ) : NEW_LINE INDENT if ( m % 2 == 0 ) : NEW_LINE INDENT print ( " Up " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Down " ) ; NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT print ( " Left " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Right " ) ; NEW_LINE DEDENT DEDENT DEDENT
Hyp: 
def findDirection ( n , m ) : NEW_LINE INDENT if ( n > m ) : NEW_LINE INDENT if ( m % 2 == 0 ) : NEW_LINE INDENT print ( "UpNEW_LINE" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "DownNEW_LINE" ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT print ( "LeftNEW_LINE" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "RightNEW_LINE DEDENT DEDENT

BLEU: 69.07
Edit Sim: 48


Src: 
int doMatch ( String A , String B ) { for ( int i = 0 ; i < A . length ( ) ; i ++ ) { if ( A . charAt ( i ) != ' * ' && B . charAt ( i ) != ' * ' ) { if ( A . charAt ( i ) != B . charAt ( i ) ) return 0 ; } } return 1 ; }
Ref: 
def doMatch ( A , B ) : NEW_LINE INDENT for i in range ( len ( A ) ) : NEW_LINE INDENT if A [ i ] != ' * ' and B [ i ] != ' * ' : NEW_LINE INDENT if A [ i ] != B [ i ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT
Hyp: 
def doMatch ( A , B ) : NEW_LINE INDENT for i in range ( len ( A ) ) : NEW_LINE INDENT if ( A [ i ] != ' * ' and B [ i ] != ' * ' ) : NEW_LINE INDENT if ( A [ i ] != B [ i ] ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT DEDENT return 1 NEW_LINE DEDENT A = " aba " NEW_LINE B = " aba " NEW_LINE if ( doMatch ( A , B ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT

BLEU: 48.25
Edit Sim: 186


Src: 
char first ( String str ) { for ( int i = 0 ; i < str . length ( ) ; i ++ ) if ( Character . isUpperCase ( str . charAt ( i ) ) ) return str . charAt ( i ) ; return 0 ; }
Ref: 
def first ( str ) : NEW_LINE INDENT for i in range ( 0 , len ( str ) ) : NEW_LINE INDENT if ( str [ i ] . istitle ( ) ) : NEW_LINE INDENT return str [ i ] NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT str = " geeksforGeeKS " NEW_LINE res = first ( str ) NEW_LINE if ( res == 0 ) : NEW_LINE INDENT print ( " No ▁ uppercase ▁ letter " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( res ) NEW_LINE DEDENT
Hyp: 
def first ( str ) : NEW_LINE INDENT for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] . isUpperCase ( ) ) : NEW_LINE INDENT return str [ i ] NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT

BLEU: 34.25
Edit Sim: 215


Src: 
float rectanglearea ( float a , float b ) { if ( a < 0 b < 0 ) return - 1 ; return 2 * a * b ; }
Ref: 
def rectanglearea ( a , b ) : NEW_LINE INDENT if a < 0 or b < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return 2 * a * b NEW_LINE DEDENT
Hyp: 
def rectanglearea ( a , b ) : NEW_LINE INDENT if ( a < 0 or b < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return 2 * a * b NEW_LINE DEDENT

BLEU: 85.43
Edit Sim: 4


Src: 
void calculateAngle ( int x1 , int y1 , int z1 , int x2 , int y2 , int z2 , int x3 , int y3 , int z3 ) { int ABx = x1 - x2 ; int ABy = y1 - y2 ; int ABz = z1 - z2 ; int BCx = x3 - x2 ; int BCy = y3 - y2 ; int BCz = z3 - z2 ; double dotProduct = ABx * BCx + ABy * BCy + ABz * BCz ; double magnitudeAB = ABx * ABx + ABy * ABy + ABz * ABz ; double magnitudeBC = BCx * BCx + BCy * BCy + BCz * BCz ; double angle = dotProduct ; angle /= Math . sqrt ( magnitudeAB * magnitudeBC ) ; angle = ( angle * 180 ) / 3.14 ; System . out . printf ( " % .4f " , Math . abs ( angle ) ) ; }
Ref: 
def calculateAngle ( x1 , y1 , z1 , x2 , y2 , z2 , x3 , y3 , z3 ) : NEW_LINE INDENT ABx = x1 - x2 ; NEW_LINE ABy = y1 - y2 ; NEW_LINE ABz = z1 - z2 ; NEW_LINE BCx = x3 - x2 ; NEW_LINE BCy = y3 - y2 ; NEW_LINE BCz = z3 - z2 ; NEW_LINE dotProduct = ( ABx * BCx + ABy * BCy + ABz * BCz ) ; NEW_LINE magnitudeAB = ( ABx * ABx + ABy * ABy + ABz * ABz ) ; NEW_LINE magnitudeBC = ( BCx * BCx + BCy * BCy + BCz * BCz ) ; NEW_LINE angle = dotProduct ; NEW_LINE angle /= math . sqrt ( magnitudeAB * magnitudeBC ) ; NEW_LINE angle = ( angle * 180 ) / 3.14 ; NEW_LINE print ( round ( abs ( angle ) , 4 ) ) NEW_LINE DEDENT
Hyp: 
def calculateAngle ( x1 , y1 , z1 , x2 , y2 , z2 , x3 , y3 , z3 ) : NEW_LINE INDENT ABx = x1 - x2 NEW_LINE ABy = y1 - y2 NEW_LINE ABz = z1 - z2 NEW_LINE BCx = x3 - x2 NEW_LINE BCy = y3 - y2 NEW_LINE BCz = z3 - z2 NEW_LINE dotProduct = ABx * BCx + ABy * BCy + ABz * ABz NEW_LINE dotProduct = ABx * BCx + ABy * ABy + ABz * ABz NEW_LINE magnitudeAB = ABx * ABx + ABy * ABy + ABz * ABz NEW_LINE magnitudeBC = BCx * BCx + BCy * BCy + BCz * BCz NEW_LINE angle = dotProduct NEW_LINE print ( " { 0 : . 4f } " . format ( angle ) ) NEW_LINE DEDENT

BLEU: 56.2
Edit Sim: 173


Src: 
void countPairs ( int arr [ ] , int N ) { int answer = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( arr [ i ] + arr [ j ] == i + j ) { answer ++ ; } } } System . out . println ( answer ) ; }
Ref: 
def countPairs ( arr , N ) : NEW_LINE INDENT answer = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT if arr [ i ] + arr [ j ] == i + j : NEW_LINE INDENT answer += 1 NEW_LINE DEDENT DEDENT DEDENT print ( answer ) NEW_LINE DEDENT
Hyp: 
def countPairs ( arr , N ) : NEW_LINE INDENT answer = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT if ( arr [ i ] + arr [ j ] == i + j ) : NEW_LINE INDENT answer += 1 NEW_LINE DEDENT DEDENT DEDENT print ( answer ) NEW_LINE DEDENT

BLEU: 87.9
Edit Sim: 8


Src: 
int permutationCoeff ( int n , int k ) { int [ ] fact = new int [ n + 1 ] ; fact [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) fact [ i ] = i * fact [ i - 1 ] ; return fact [ n ] / fact [ n - k ] ; }
Ref: 
def permutationCoeff ( n , k ) : NEW_LINE INDENT fact = [ 0 for i in range ( n + 1 ) ] NEW_LINE fact [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT fact [ i ] = i * fact [ i - 1 ] NEW_LINE DEDENT return int ( fact [ n ] / fact [ n - k ] ) NEW_LINE DEDENT
Hyp: 
def permutationCoeff ( n , k ) : NEW_LINE INDENT fact = [ 1 ] * ( n + 1 ) NEW_LINE fact [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT fact [ i ] = i * fact [ i - 1 ] NEW_LINE DEDENT return fact [ n ] // fact [ n - k ] NEW_LINE DEDENT

BLEU: 77.99
Edit Sim: 25


Src: 
int findSum ( String s ) { int sum = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { for ( int j = i + 1 ; j < s . length ( ) ; j ++ ) { if ( s . charAt ( i ) == s . charAt ( j ) ) { sum += ( j - i ) ; } } } return sum ; }
Ref: 
def findSum ( s ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT for j in range ( i + 1 , len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == s [ j ] ) : NEW_LINE INDENT sum += ( j - i ) NEW_LINE DEDENT DEDENT DEDENT return sum NEW_LINE DEDENT
Hyp: 
def findSum ( s ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT for j in range ( i + 1 , len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == s [ j ] ) : NEW_LINE INDENT sum += ( j - i ) NEW_LINE DEDENT DEDENT DEDENT return sum NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int findMinInsertions ( char str [ ] , int l , int h ) { if ( l > h ) return Integer . MAX_VALUE ; if ( l == h ) return 0 ; if ( l == h - 1 ) return ( str [ l ] == str [ h ] ) ? 0 : 1 ; return ( str [ l ] == str [ h ] ) ? findMinInsertions ( str , l + 1 , h - 1 ) : ( Integer . min ( findMinInsertions ( str , l , h - 1 ) , findMinInsertions ( str , l + 1 , h ) ) + 1 ) ; }
Ref: 
def findMinInsertions ( str , l , h ) : NEW_LINE INDENT if ( l > h ) : NEW_LINE INDENT return sys . maxsize NEW_LINE DEDENT if ( l == h ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( l == h - 1 ) : NEW_LINE INDENT return 0 if ( str [ l ] == str [ h ] ) else 1 NEW_LINE DEDENT if ( str [ l ] == str [ h ] ) : NEW_LINE INDENT return findMinInsertions ( str , l + 1 , h - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( min ( findMinInsertions ( str , l , h - 1 ) , findMinInsertions ( str , l + 1 , h ) ) + 1 ) NEW_LINE DEDENT DEDENT
Hyp: 
def findMinInsertions ( string , l , h ) : NEW_LINE INDENT if ( l > h ) : NEW_LINE INDENT return sys . maxsize NEW_LINE DEDENT if ( l == h ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( l == h - 1 ) : NEW_LINE INDENT return findMinInsertions ( string , l + 1 , h - 1 ) NEW_LINE DEDENT return findMinInsertions ( string , l , h - 1 ) NEW_LINE DEDENT

BLEU: 42.95
Edit Sim: 201


Src: 
int numberofterm ( int n , int number ) { int firstnum = ( int ) Math . pow ( 10 , n - 1 ) ; int lastnum = ( int ) Math . pow ( 10 , n ) ; int count = 0 ; for ( int i = firstnum ; i < lastnum ; i ++ ) if ( i % number == 0 ) count ++ ; return count ; }
Ref: 
def numberofterm ( n , number ) : NEW_LINE INDENT firstnum = math . pow ( 10 , n - 1 ) NEW_LINE lastnum = math . pow ( 10 , n ) NEW_LINE count = 0 NEW_LINE for i in range ( int ( firstnum ) , int ( lastnum ) ) : NEW_LINE INDENT if ( i % number == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
Hyp: 
def numberofterm ( n , number ) : NEW_LINE INDENT firstnum = pow ( 10 , n - 1 ) NEW_LINE lastnum = pow ( 10 , n ) NEW_LINE count = 0 NEW_LINE for i in range ( firstnum , lastnum ) : NEW_LINE INDENT if ( i % number == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT

BLEU: 77.7
Edit Sim: 30


Src: 
double octadiagonal ( double a ) { if ( a < 0 ) return - 1 ; return a * Math . sqrt ( 4 + ( 2 * Math . sqrt ( 2 ) ) ) ; }
Ref: 
def octadiagonal ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT return a * math . sqrt ( 4 + ( 2 * math . sqrt ( 2 ) ) ) NEW_LINE DEDENT
Hyp: 
def octadiagonal ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return a * math . sqrt ( 4 + ( 2 * math . sqrt ( 2 ) ) ) NEW_LINE DEDENT

BLEU: 94.28
Edit Sim: 2


Src: 
int submatrixXor ( int [ ] [ ] arr ) { int n = 3 ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { int top_left = ( i + 1 ) * ( j + 1 ) ; int bottom_right = ( n - i ) * ( n - j ) ; if ( ( top_left % 2 == 1 ) && ( bottom_right % 2 == 1 ) ) ans = ( ans ^ arr [ i ] [ j ] ) ; } } return ans ; }
Ref: 
def submatrixXor ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT top_left = ( i + 1 ) * ( j + 1 ) NEW_LINE bottom_right = ( n - i ) * ( n - j ) NEW_LINE if ( top_left % 2 == 1 and bottom_right % 2 == 1 ) : NEW_LINE INDENT ans = ( ans ^ arr [ i ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
Hyp: 
def submatrixXor ( arr ) : NEW_LINE INDENT n = 3 NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT top_left = ( i + 1 ) * ( j + 1 ) NEW_LINE bottom_right = ( n - i ) * ( n - j ) NEW_LINE if ( ( top_left % 2 == 1 ) and ( bottom_right % 2 == 1 ) ) : NEW_LINE INDENT ans = ( ans ^ arr [ i ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT

BLEU: 82.98
Edit Sim: 35


Src: 
double cyl ( double r , double h ) { if ( r < 0 && h < 0 ) return - 1 ; double R = ( 2 * r ) / 3 ; double H = ( 2 * h ) / 3 ; double V = 3.14 * Math . pow ( R , 2 ) * H ; return V ; }
Ref: 
def cyl ( r , h ) : NEW_LINE INDENT if ( r < 0 and h < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT R = ( 2 * r ) / 3 NEW_LINE H = ( 2 * h ) / 3 NEW_LINE V = 3.14 * math . pow ( R , 2 ) * H NEW_LINE return V NEW_LINE DEDENT
Hyp: 
def cyl ( r , h ) : NEW_LINE INDENT if ( r < 0 and h < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT R = ( 2 * r ) / 3 NEW_LINE H = ( 2 * h ) / 3 NEW_LINE V = 3.14 * pow ( R , 2 ) * H NEW_LINE return V NEW_LINE DEDENT

BLEU: 94.67
Edit Sim: 7


Src: 
int StepstoReachTarget ( int target ) { target = Math . abs ( target ) ; int n = ( int ) Math . ceil ( ( - 1.0 + ( int ) Math . sqrt ( 1 + 8.0 * target ) ) / 2 ) ; int sum = n * ( n + 1 ) / 2 ; if ( sum == target ) return n ; int d = sum - target ; if ( ( d & 1 ) == 0 ) return n ; else return n + ( ( n & 1 ) != 0 ? 2 : 1 ) ; }
Ref: 
def StepstoReachTarget ( target ) : NEW_LINE INDENT target = abs ( target ) NEW_LINE n = math . ceil ( ( - 1.0 + math . sqrt ( 1 + 8.0 * target ) ) / 2 ) NEW_LINE sum = n * ( n + 1 ) / 2 NEW_LINE if ( sum == target ) : NEW_LINE INDENT return n NEW_LINE DEDENT d = sum - target NEW_LINE if ( ( int ( d ) & 1 ) == 0 ) : NEW_LINE INDENT return n NEW_LINE DEDENT else : NEW_LINE INDENT if ( int ( d ) & 1 ) : NEW_LINE INDENT return n + 2 NEW_LINE DEDENT return n + 1 NEW_LINE DEDENT DEDENT
Hyp: 
def StepstoReachTarget ( target ) : NEW_LINE INDENT target = abs ( target ) NEW_LINE n = math . ceil ( ( - 1 + math . sqrt ( 1 + 8 * target ) ) / 2 ) NEW_LINE sum = n * ( n + 1 ) / 2 NEW_LINE if ( sum == target ) : NEW_LINE INDENT return n NEW_LINE DEDENT d = sum - target NEW_LINE if ( ( d & 1 ) == 0 ) : NEW_LINE INDENT return n NEW_LINE DEDENT else : NEW_LINE INDENT return n + ( ( n & 1 ) != 0 ? 2 : 1 ) NEW_LINE DEDENT DEDENT

BLEU: 76.57
Edit Sim: 75


Src: 
boolean can_empty ( int a , int b , int c ) { if ( ( a + b + c ) % 4 != 0 ) return false ; else { int m = Math . min ( a , Math . min ( b , c ) ) ; if ( m < ( ( a + b + c ) / 4 ) ) return false ; } return true ; }
Ref: 
def can_empty ( a , b , c ) : NEW_LINE INDENT if ( ( a + b + c ) % 4 != 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT else : NEW_LINE INDENT m = min ( a , min ( b , c ) ) ; NEW_LINE if ( m < ( a + b + c ) // 4 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT return True ; NEW_LINE DEDENT
Hyp: 
def can_empty ( a , b , c ) : NEW_LINE INDENT if ( ( a + b + c ) % 4 != 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT else : NEW_LINE INDENT m = min ( a , min ( b , c ) ) ; NEW_LINE if ( m < ( ( a + b + c ) // 4 ) ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT DEDENT return True ; NEW_LINE DEDENT a = 1 ; NEW_LINE b = 2 ; NEW_LINE c = 4 ; NEW_LINE if ( can_empty ( a , b , c ) ) : NEW_LINE INDENT print ( " YES " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) ; NEW_LINE DEDENT

BLEU: 55.31
Edit Sim: 208


Src: 
int cntRect ( int points [ ] [ ] , int N , int rectangle [ ] [ ] ) { HashSet < Integer > cntHor = new HashSet < > ( ) ; HashSet < Integer > cntVer = new HashSet < > ( ) ; cntHor . add ( 0 ) ; cntVer . add ( 0 ) ; cntHor . add ( rectangle [ 3 ] [ 0 ] ) ; cntVer . add ( rectangle [ 3 ] [ 1 ] ) ; for ( int i = 0 ; i < N ; i ++ ) { cntHor . add ( points [ i ] [ 0 ] ) ; cntVer . add ( points [ i ] [ 1 ] ) ; } return ( cntHor . size ( ) - 1 ) * ( cntVer . size ( ) - 1 ) ; }
Ref: 
def cntRect ( points , N , rectangle ) : NEW_LINE INDENT cntHor = set ( [ ] ) NEW_LINE cntVer = set ( [ ] ) NEW_LINE cntHor . add ( 0 ) NEW_LINE cntVer . add ( 0 ) NEW_LINE cntHor . add ( rectangle [ 3 ] [ 0 ] ) NEW_LINE cntVer . add ( rectangle [ 3 ] [ 1 ] ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT cntHor . add ( points [ i ] [ 0 ] ) NEW_LINE cntVer . add ( points [ i ] [ 1 ] ) NEW_LINE DEDENT return ( ( len ( cntHor ) - 1 ) * ( len ( cntVer ) - 1 ) ) NEW_LINE DEDENT
Hyp: 
def cntRect ( points , N , rectangle ) : NEW_LINE INDENT cntHor = set ( ) NEW_LINE cntVer = set ( ) NEW_LINE cntHor . add ( 0 ) NEW_LINE cntVer . add ( 0 ) NEW_LINE cntHor . add ( rectangle [ 3 ] [ 0 ] ) NEW_LINE cntVer . add ( rectangle [ 3 ] [ 1 ] ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT cntHor . add ( points [ i ] [ 0 ] ) NEW_LINE cntVer . add ( points [ i ] [ 1 ] ) NEW_LINE DEDENT return ( cntHor . size ( ) - 1 ) * ( cntVer . size ( ) - 1 ) NEW_LINE DEDENT

BLEU: 86.11
Edit Sim: 35


Src: 
int FirstRepeated ( String str ) { int checker = 0 ; for ( int i = 0 ; i < str . length ( ) ; ++ i ) { int val = ( str . charAt ( i ) - ' a ' ) ; if ( ( checker & ( 1 << val ) ) > 0 ) return i ; checker |= ( 1 << val ) ; } return - 1 ; }
Ref: 
def FirstRepeated ( string ) : NEW_LINE INDENT checker = 0 NEW_LINE pos = 0 NEW_LINE for i in string : NEW_LINE INDENT val = ord ( i ) - ord ( ' a ' ) ; NEW_LINE if ( ( checker & ( 1 << val ) ) > 0 ) : NEW_LINE INDENT return pos NEW_LINE DEDENT checker |= ( 1 << val ) NEW_LINE pos += 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT string = " abcfdeacf " NEW_LINE i = FirstRepeated ( string ) NEW_LINE if i != - 1 : NEW_LINE INDENT print " Char ▁ = ▁ " , string [ i ] , " ▁ and ▁ Index ▁ = ▁ " , i ; NEW_LINE DEDENT else : NEW_LINE INDENT print " No ▁ repeated ▁ Char " NEW_LINE DEDENT
Hyp: 
def FirstRepeated ( s ) : NEW_LINE INDENT checker = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT val = ord ( s [ i ] ) - ord ( ' a ' ) NEW_LINE if ( checker & ( 1 << val ) ) > 0 : NEW_LINE INDENT return i NEW_LINE DEDENT checker |= ( 1 << val ) NEW_LINE DEDENT return - 1 NEW_LINE DEDENT s = " aaabbccdaa " NEW_LINE if ( FirstRepeated ( s ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT

BLEU: 45.72
Edit Sim: 176


Src: 
void constructArray ( int N , int K , int X ) { int [ ] ans = new int [ K ] ; ans [ 0 ] = X ; for ( int i = 0 ; i < N ; ++ i ) { System . out . print ( ans [ i % K ] + " ▁ " ) ; } }
Ref: 
def constructArray ( N , K , X ) : NEW_LINE INDENT ans = [ ] NEW_LINE for i in range ( 0 , K ) : NEW_LINE INDENT ans . append ( 0 ) NEW_LINE DEDENT ans [ 0 ] = X NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT print ( ans [ i % K ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
Hyp: 
def constructArray ( N , K , X ) : NEW_LINE INDENT ans = [ 0 ] * K NEW_LINE ans [ 0 ] = X NEW_LINE for i in range ( N ) : NEW_LINE INDENT print ( ans [ i % K ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT

BLEU: 61.4
Edit Sim: 79


Src: 
int nthTerm ( int n ) { return 4 * ( int ) Math . pow ( n , 2 ) - 3 * n + 2 ; }
Ref: 
def nthTerm ( n ) : NEW_LINE INDENT return 4 * pow ( n , 2 ) - 3 * n + 2 NEW_LINE DEDENT
Hyp: 
def nthTerm ( n ) : NEW_LINE INDENT return 4 * pow ( n , 2 ) - 3 * n + 2 ; NEW_LINE DEDENT

BLEU: 90.96
Edit Sim: 2


Src: 
int minRadius ( int k , int [ ] x , int [ ] y , int n ) { int [ ] dis = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) dis [ i ] = x [ i ] * x [ i ] + y [ i ] * y [ i ] ; Arrays . sort ( dis ) ; return dis [ k - 1 ] ; }
Ref: 
def minRadius ( k , x , y , n ) : NEW_LINE INDENT dis = [ 0 ] * n NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT dis [ i ] = x [ i ] * x [ i ] + y [ i ] * y [ i ] NEW_LINE DEDENT dis . sort ( ) NEW_LINE return dis [ k - 1 ] NEW_LINE DEDENT
Hyp: 
def minRadius ( k , x , y , n ) : NEW_LINE INDENT dis = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT dis [ i ] = x [ i ] * x [ i ] + y [ i ] * y [ i ] NEW_LINE DEDENT dis . sort ( ) NEW_LINE return dis [ k - 1 ] NEW_LINE DEDENT

BLEU: 95.25
Edit Sim: 4


Src: 
void printRLE ( String s ) { for ( int i = 0 ; i < s . length ( ) ; i ++ ) { int count = 1 ; while ( i + 1 < s . length ( ) && s . charAt ( i ) == s . charAt ( i + 1 ) ) { i ++ ; count ++ ; } System . out . print ( s . charAt ( i ) + " " + count + " ▁ " ) ; } System . out . println ( ) ; }
Ref: 
def printRLE ( s ) : NEW_LINE INDENT i = 0 NEW_LINE while ( i < len ( s ) - 1 ) : NEW_LINE INDENT count = 1 NEW_LINE while s [ i ] == s [ i + 1 ] : NEW_LINE INDENT i += 1 NEW_LINE count += 1 NEW_LINE if i + 1 == len ( s ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( str ( s [ i ] ) + str ( count ) , end = " ▁ " ) NEW_LINE i += 1 NEW_LINE DEDENT print ( ) NEW_LINE DEDENT
Hyp: 
def printRLE ( s ) : NEW_LINE INDENT i = 0 NEW_LINE while i < len ( s ) : NEW_LINE INDENT count = 1 NEW_LINE while ( i + 1 < len ( s ) and s [ i ] == s [ i + 1 ] ) : NEW_LINE INDENT i += 1 NEW_LINE count += 1 NEW_LINE DEDENT print ( s [ i ] , count , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT

BLEU: 66.06
Edit Sim: 125


Src: 
int nthMagicNo ( int n ) { int pow = 1 , answer = 0 ; while ( n != 0 ) { pow = pow * 5 ; if ( ( int ) ( n & 1 ) == 1 ) answer += pow ; n >>= 1 ; } return answer ; }
Ref: 
def nthMagicNo ( n ) : NEW_LINE INDENT pow = 1 NEW_LINE answer = 0 NEW_LINE while ( n ) : NEW_LINE INDENT pow = pow * 5 NEW_LINE if ( n & 1 ) : NEW_LINE INDENT answer += pow NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT
Hyp: 
def nthMagicNo ( n ) : NEW_LINE INDENT pow = 1 NEW_LINE answer = 0 NEW_LINE while ( n ) : NEW_LINE INDENT pow = pow * 5 NEW_LINE if ( int ) ( n & 1 ) == 1 : NEW_LINE INDENT answer += pow NEW_LINE DEDENT n >>= 1 NEW_LINE DEDENT return answer NEW_LINE DEDENT

BLEU: 77.1
Edit Sim: 30


Src: 
int maxDiff ( int arr [ ] , int n ) { int diff = arr [ 1 ] - arr [ 0 ] ; int curr_sum = diff ; int max_sum = curr_sum ; for ( int i = 1 ; i < n - 1 ; i ++ ) { diff = arr [ i + 1 ] - arr [ i ] ; if ( curr_sum > 0 ) curr_sum += diff ; else curr_sum = diff ; if ( curr_sum > max_sum ) max_sum = curr_sum ; } return max_sum ; }
Ref: 
def maxDiff ( arr , n ) : NEW_LINE INDENT diff = arr [ 1 ] - arr [ 0 ] NEW_LINE curr_sum = diff NEW_LINE max_sum = curr_sum NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT diff = arr [ i + 1 ] - arr [ i ] NEW_LINE if ( curr_sum > 0 ) : NEW_LINE INDENT curr_sum += diff NEW_LINE DEDENT else : NEW_LINE INDENT curr_sum = diff NEW_LINE DEDENT if ( curr_sum > max_sum ) : NEW_LINE INDENT max_sum = curr_sum NEW_LINE DEDENT DEDENT return max_sum NEW_LINE DEDENT
Hyp: 
def maxDiff ( arr , n ) : NEW_LINE INDENT diff = arr [ 1 ] - arr [ 0 ] NEW_LINE curr_sum = diff NEW_LINE max_sum = curr_sum NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT diff = arr [ i + 1 ] - arr [ i ] NEW_LINE if ( curr_sum > 0 ) : NEW_LINE INDENT curr_sum += diff NEW_LINE DEDENT else : NEW_LINE INDENT curr_sum = diff NEW_LINE DEDENT if ( curr_sum > max_sum ) : NEW_LINE INDENT max_sum = curr_sum NEW_LINE DEDENT DEDENT return max_sum NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int findSubArray ( int arr [ ] , int n ) { int sum = 0 ; int maxsize = - 1 , startindex = 0 ; int endindex = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { sum = ( arr [ i ] == 0 ) ? - 1 : 1 ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ j ] == 0 ) sum += - 1 ; else sum += 1 ; if ( sum == 0 && maxsize < j - i + 1 ) { maxsize = j - i + 1 ; startindex = i ; } } } endindex = startindex + maxsize - 1 ; if ( maxsize == - 1 ) System . out . println ( " No ▁ such ▁ subarray " ) ; else System . out . println ( startindex + " ▁ to ▁ " + endindex ) ; return maxsize ; }
Ref: 
def findSubArray ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE maxsize = - 1 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT sum = - 1 if ( arr [ i ] == 0 ) else 1 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT sum = sum + ( - 1 ) if ( arr [ j ] == 0 ) else sum + 1 NEW_LINE if ( sum == 0 and maxsize < j - i + 1 ) : NEW_LINE INDENT maxsize = j - i + 1 NEW_LINE startindex = i NEW_LINE DEDENT DEDENT DEDENT if ( maxsize == - 1 ) : NEW_LINE INDENT print ( " No ▁ such ▁ subarray " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( startindex , " to " , startindex + maxsize - 1 ) ; NEW_LINE DEDENT return maxsize NEW_LINE DEDENT
Hyp: 
def findSubArray ( arr , n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE maxsize = - 1 ; NEW_LINE startindex = 0 ; NEW_LINE endindex = 0 ; NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ j ] == 0 ) : NEW_LINE INDENT sum += - 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT sum += 1 ; NEW_LINE DEDENT if ( sum == 0 and maxsize < j - i + 1 ) : NEW_LINE INDENT maxsize = j - i + 1 ; NEW_LINE startindex = i ; NEW_LINE DEDENT DEDENT DEDENT endindex = startindex + maxsize - 1 ; NEW_LINE if ( maxsize == - 1 ) : NEW_LINE INDENT print ( " No ▁ such ▁ subarray " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( startindex , " ▁ to ▁ " , endindex ) ; NEW_LINE DEDENT return maxsize ; NEW_LINE DEDENT

BLEU: 66.4
Edit Sim: 231


Src: 
int averageEven ( int n ) { if ( n % 2 != 0 ) { System . out . println ( " Invalid ▁ Input " ) ; return - 1 ; } return ( n + 2 ) / 2 ; }
Ref: 
def averageEven ( n ) : NEW_LINE INDENT if ( n % 2 != 0 ) : NEW_LINE INDENT print ( " Invalid ▁ Input " ) NEW_LINE return - 1 NEW_LINE DEDENT return ( n + 2 ) // 2 NEW_LINE DEDENT
Hyp: 
def averageEven ( n ) : NEW_LINE INDENT if n % 2 != 0 : NEW_LINE INDENT print ( " Invalid ▁ Input " ) NEW_LINE return - 1 NEW_LINE DEDENT return ( n + 2 ) // 2 NEW_LINE DEDENT

BLEU: 87.86
Edit Sim: 4


Src: 
void printRoots ( long a , long b , long c ) { System . out . println ( 1 + " , ▁ " + c / ( a * 1.0 ) ) ; }
Ref: 
def printRoots ( a , b , c ) : NEW_LINE INDENT print ( 1 , " , " , c / ( a * 1.0 ) ) NEW_LINE DEDENT
Hyp: 
def printRoots ( a , b , c ) : NEW_LINE INDENT print ( 1 , " , ▁ " , c // ( a * 1.0 ) ) NEW_LINE DEDENT

BLEU: 82.93
Edit Sim: 3


Src: 
int maxGCD ( int N ) { for ( int i = 2 ; i * i <= N ; i ++ ) { if ( N % i == 0 ) { return N / i ; } } return 1 ; }
Ref: 
def maxGCD ( N ) : NEW_LINE INDENT i = 2 NEW_LINE while ( i * i <= N ) : NEW_LINE INDENT if ( N % i == 0 ) : NEW_LINE INDENT return N // i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return 1 NEW_LINE DEDENT
Hyp: 
def maxGCD ( N ) : NEW_LINE INDENT i = 2 NEW_LINE while i * i <= N : NEW_LINE INDENT if ( N % i == 0 ) : NEW_LINE INDENT return N // i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return 1 NEW_LINE DEDENT

BLEU: 89.41
Edit Sim: 4


Src: 
void numbersWith3Divisors ( int n ) { boolean [ ] prime = new boolean [ n + 1 ] ; Arrays . fill ( prime , true ) ; prime [ 0 ] = prime [ 1 ] = false ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } System . out . println ( " Numbers ▁ with ▁ 3 ▁ divisors ▁ : ▁ " ) ; for ( int i = 0 ; i * i <= n ; i ++ ) if ( prime [ i ] ) System . out . print ( i * i + " ▁ " ) ; }
Ref: 
def numbersWith3Divisors ( n ) : NEW_LINE INDENT prime = [ True ] * ( n + 1 ) ; NEW_LINE prime [ 0 ] = prime [ 1 ] = False ; NEW_LINE p = 2 ; NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False ; NEW_LINE DEDENT DEDENT p += 1 ; NEW_LINE DEDENT print ( " Numbers ▁ with ▁ 3 ▁ divisors ▁ : " ) ; NEW_LINE i = 0 ; NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT print ( i * i , end = " ▁ " ) ; NEW_LINE DEDENT i += 1 ; NEW_LINE DEDENT DEDENT
Hyp: 
def numbersWith3Divisors ( n ) : NEW_LINE INDENT prime = [ 0 for i in range ( n + 1 ) ] NEW_LINE prime [ 0 ] = prime [ 1 ] = False NEW_LINE for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , n + p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT print ( " Numbers ▁ with ▁ 3 ▁ divisors ▁ : ▁ " ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT print ( ( i * i ) , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT

BLEU: 62.82
Edit Sim: 116


Src: 
void findEquation ( int x1 , int y1 , int z1 , int x2 , int y2 , int z2 , int d , int e , int f ) { double a = x2 - x1 ; double b = y2 - y1 ; double c = z2 - z1 ; int A = ( int ) ( b * f - c * e ) ; int B = ( int ) ( a * f - c * d ) ; int C = ( int ) ( a * e - b * d ) ; int D = - ( int ) ( A * d - B * e + C * f ) ; System . out . println ( A + " x ▁ + ▁ " + B + " y ▁ + ▁ " + C + " z ▁ + ▁ " + D + " = ▁ 0 ▁ " ) ; }
Ref: 
def findEquation ( x1 , y1 , z1 , x2 , y2 , z2 , d , e , f ) : NEW_LINE INDENT a = x2 - x1 NEW_LINE b = y2 - y1 NEW_LINE c = z2 - z1 NEW_LINE A = ( b * f - c * e ) NEW_LINE B = ( a * f - c * d ) NEW_LINE C = ( a * e - b * d ) NEW_LINE D = - ( A * d - B * e + C * f ) NEW_LINE print ( A , " x ▁ + ▁ " , B , " y ▁ + ▁ " , C , " z ▁ + ▁ " , D , " = ▁ 0" ) NEW_LINE DEDENT
Hyp: 
def findEquation ( x1 , y1 , z1 , x2 , y2 , z2 , d , e , f ) : NEW_LINE INDENT a = x2 - x1 NEW_LINE b = y2 - y1 NEW_LINE c = z2 - z1 NEW_LINE A = ( b * f - c * e ) NEW_LINE B = ( int ) ( a * f - c * d ) NEW_LINE C = ( int ) ( a * e - b * d ) NEW_LINE D = - ( A * d - B * e + C * f ) NEW_LINE print ( A , " x ▁ + ▁ " , B , " y ▁ + ▁ " , C , " z ▁ + ▁ " , D , " = ▁ 0 ▁ " ) NEW_LINE DEDENT

BLEU: 91.42
Edit Sim: 19


Src: 
int min_modulo ( int l , int r ) { if ( r - l >= MOD ) return 0 ; else { int ans = MOD - 1 ; for ( int i = l ; i <= r ; i ++ ) { for ( int j = i + 1 ; j <= r ; j ++ ) { ans = Math . min ( ans , ( i * j ) % MOD ) ; } } return ans ; } }
Ref: 
def min_modulo ( l , r ) : NEW_LINE INDENT if ( r - l >= MOD ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT else : NEW_LINE INDENT ans = MOD - 1 ; NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT for j in range ( i + 1 , r + 1 ) : NEW_LINE INDENT ans = min ( ans , ( i * j ) % MOD ) ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT DEDENT
Hyp: 
def min_modulo ( l , r ) : NEW_LINE INDENT if r - l >= MOD : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT else : NEW_LINE INDENT ans = MOD - 1 ; NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT for j in range ( i + 1 , r + 1 ) : NEW_LINE INDENT ans = min ( ans , ( i * j ) % MOD ) ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT

BLEU: 93.27
Edit Sim: 11


Src: 
int findTwoThreePrime ( int l , int r ) { if ( l == 1 ) l ++ ; int count = 0 ; for ( int i = l ; i <= r ; i ++ ) { int num = i ; while ( num % 2 == 0 ) num /= 2 ; while ( num % 3 == 0 ) num /= 3 ; if ( num == 1 ) count ++ ; } return count ; }
Ref: 
def findTwoThreePrime ( l , r ) : NEW_LINE INDENT if ( l == 1 ) : NEW_LINE INDENT l += 1 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT num = i NEW_LINE while ( num % 2 == 0 ) : NEW_LINE INDENT num //= 2 ; NEW_LINE DEDENT while ( num % 3 == 0 ) : NEW_LINE INDENT num //= 3 NEW_LINE DEDENT if ( num == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
Hyp: 
def findTwoThreePrime ( l , r ) : NEW_LINE INDENT if ( l == 1 ) : NEW_LINE INDENT l = 1 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT num = i NEW_LINE while ( num % 2 == 0 ) : NEW_LINE INDENT num //= 2 NEW_LINE DEDENT while ( num % 3 == 0 ) : NEW_LINE INDENT num //= 3 NEW_LINE DEDENT if ( num == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT

BLEU: 94.82
Edit Sim: 3


Src: 
int count_min_length ( String s ) { int [ ] hash = new int [ 26 ] ; int ans = Integer . MAX_VALUE ; for ( int i = 0 ; i < 26 ; i ++ ) hash [ i ] = - 1 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( hash [ s . charAt ( i ) - ' a ' ] == - 1 ) hash [ s . charAt ( i ) - ' a ' ] = i ; else { if ( hash [ s . charAt ( i ) - ' a ' ] == i - 1 || hash [ s . charAt ( i ) - ' a ' ] == i - 2 ) return 0 ; ans = Math . min ( ans , i - hash [ s . charAt ( i ) - ' a ' ] - 1 ) ; hash [ s . charAt ( i ) - ' a ' ] = i ; } } if ( ans == Integer . MAX_VALUE ) return - 1 ; return ans ; }
Ref: 
def count_min_length ( s ) : NEW_LINE INDENT hash = [ 0 ] * 26 ; NEW_LINE ans = sys . maxsize ; NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT hash [ i ] = - 1 ; NEW_LINE DEDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if ( hash [ ord ( s [ i ] ) - ord ( ' a ' ) ] == - 1 ) : NEW_LINE INDENT hash [ ord ( s [ i ] ) - ord ( ' a ' ) ] = i ; NEW_LINE DEDENT else : NEW_LINE INDENT if ( hash [ ord ( s [ i ] ) - ord ( ' a ' ) ] == i - 1 or hash [ ord ( s [ i ] ) - ord ( ' a ' ) ] == i - 2 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT ans = min ( ans , i - hash [ ord ( s [ i ] ) - ord ( ' a ' ) ] - 1 ) ; NEW_LINE hash [ ord ( s [ i ] ) - ord ( ' a ' ) ] = i ; NEW_LINE DEDENT DEDENT if ( ans == INT_MAX ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT
Hyp: 
def count_min_length ( s ) : NEW_LINE INDENT hash = [ 0 ] * 26 NEW_LINE ans = sys . maxsize NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT hash [ i ] = - 1 NEW_LINE DEDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if ( hash [ ord ( s [ i ] ) - ord ( ' a ' ) ] == - 1 ) : NEW_LINE INDENT hash [ ord ( s [ i ] ) - ord ( ' a ' ) ] = i NEW_LINE DEDENT else : NEW_LINE INDENT if ( hash [ ord ( s [ i ] ) - ord ( ' a ' ) ] == i - 1 or hash [ ord ( s [ i ] ) - ord ( ' a ' ) ] == i - 2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = min ( ans , i - ord ( s [ i ] ) - ord ( ' a ' ) - 1 ) NEW_LINE hash [ ord ( s [ i ] ) - ord ( ' a ' ) ] = i NEW_LINE DEDENT DEDENT if ( ans == - 1 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT

BLEU: 86.64
Edit Sim: 34


Src: 
int countMinSteps ( int arr [ ] , int target , int n ) { Arrays . sort ( arr ) ; int minimumSteps = 0 ; int i = 0 ; int j = n - 1 ; while ( i <= j ) { if ( arr [ i ] + arr [ j ] <= target ) { i += 1 ; j -= 1 ; } else { j -= 1 ; } minimumSteps += 1 ; } return minimumSteps ; }
Ref: 
def countMinSteps ( arr , target , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE minimumSteps = 0 NEW_LINE i , j = 0 , n - 1 NEW_LINE while i <= j : NEW_LINE INDENT if arr [ i ] + arr [ j ] <= target : NEW_LINE INDENT i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT minimumSteps += 1 NEW_LINE DEDENT return minimumSteps NEW_LINE DEDENT
Hyp: 
def countMinSteps ( arr , target , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE minimumSteps = 0 NEW_LINE DEDENT i = 0 NEW_LINE j = n - 1 NEW_LINE while ( i <= j ) : NEW_LINE INDENT if ( arr [ i ] + arr [ j ] <= target ) : NEW_LINE INDENT i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT minimumSteps += 1 NEW_LINE DEDENT DEDENT return minimumSteps NEW_LINE DEDENT

BLEU: 77.63
Edit Sim: 34


Src: 
double Avgdifference ( double arr [ ] , int N , int K ) { double sum = 0 ; for ( int i = 0 ; i < K ; i ++ ) sum += arr [ i ] ; double min = sum ; double max = sum ; for ( int i = K ; i <= N - K + 1 ; i ++ ) { sum += arr [ i ] - arr [ i - K ] ; if ( min > sum ) min = sum ; if ( max < sum ) max = sum ; } return ( max - min ) / K ; }
Ref: 
def Avgdifference ( arr , N , K ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( K ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT min = sum NEW_LINE max = sum NEW_LINE for i in range ( K , N - K + 2 , 1 ) : NEW_LINE INDENT sum += arr [ i ] - arr [ i - K ] NEW_LINE if ( min > sum ) : NEW_LINE INDENT min = sum NEW_LINE DEDENT if ( max < sum ) : NEW_LINE INDENT max = sum NEW_LINE DEDENT DEDENT return ( max - min ) / K NEW_LINE DEDENT
Hyp: 
def Avgdifference ( arr , N , K ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( K ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT min = sum NEW_LINE max = sum NEW_LINE for i in range ( K , N - K + 1 ) : NEW_LINE INDENT sum += arr [ i ] - arr [ i - K ] NEW_LINE if ( min > sum ) : NEW_LINE INDENT min = sum NEW_LINE DEDENT if ( max < sum ) : NEW_LINE INDENT max = sum NEW_LINE DEDENT DEDENT return ( max - min ) / K NEW_LINE DEDENT

BLEU: 96.87
Edit Sim: 4


Src: 
int find_greatest_divisor ( int l , int r ) { if ( l == r ) { return l ; } return 1 ; }
Ref: 
def find_greatest_divisor ( l , r ) : NEW_LINE INDENT if ( l == r ) : NEW_LINE INDENT return l ; NEW_LINE DEDENT return 1 ; NEW_LINE DEDENT
Hyp: 
def find_greatest_divisor ( l , r ) : NEW_LINE INDENT if ( l == r ) : NEW_LINE INDENT return l NEW_LINE DEDENT return 1 NEW_LINE DEDENT

BLEU: 82.62
Edit Sim: 4


Src: 
String areAllBitsSet ( int n ) { if ( n == 0 ) return " No " ; if ( ( ( n + 1 ) & n ) == 0 ) return " Yes " ; return " No " ; }
Ref: 
def areAllBitsSet ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return " No " NEW_LINE DEDENT if ( ( ( n + 1 ) & n ) == 0 ) : NEW_LINE INDENT return " Yes " NEW_LINE DEDENT return " No " NEW_LINE DEDENT
Hyp: 
def areAllBitsSet ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return " No " NEW_LINE DEDENT if ( ( n + 1 ) & n ) == 0 ) : NEW_LINE INDENT return " Yes " NEW_LINE DEDENT return " No " NEW_LINE DEDENT

BLEU: 97.55
Edit Sim: 2


Src: 
String noAdjacentDup ( String s1 ) { int n = s1 . length ( ) ; char [ ] s = s1 . toCharArray ( ) ; for ( int i = 1 ; i < n ; i ++ ) { if ( s [ i ] == s [ i - 1 ] ) { s [ i ] = ' a ' ; while ( s [ i ] == s [ i - 1 ] || ( i + 1 < n && s [ i ] == s [ i + 1 ] ) ) s [ i ] ++ ; i ++ ; } } return ( new String ( s ) ) ; }
Ref: 
def noAdjacentDup ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( s [ i ] == s [ i - 1 ] ) : NEW_LINE INDENT s [ i ] = " a " NEW_LINE while ( s [ i ] == s [ i - 1 ] or ( i + 1 < n and s [ i ] == s [ i + 1 ] ) ) : NEW_LINE INDENT s [ i ] += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT return s NEW_LINE DEDENT
Hyp: 
def noAdjacentDup ( s1 ) : NEW_LINE INDENT n = len ( s1 ) NEW_LINE s = list ( s1 ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( s [ i ] == s [ i - 1 ] ) : NEW_LINE INDENT s [ i ] = ' a ' NEW_LINE while ( s [ i ] == s [ i - 1 ] or ( i + 1 < n and s [ i ] == s [ i + 1 ] ) ) : NEW_LINE INDENT s [ i ] += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT return ( " " . join ( s ) ) NEW_LINE DEDENT

BLEU: 79.59
Edit Sim: 48


Src: 
int fib ( int n ) { if ( n <= 1 ) return n ; return fib ( n - 1 ) + fib ( n - 2 ) ; }
Ref: 
def fib ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT return fib ( n - 1 ) + fib ( n - 2 ) NEW_LINE DEDENT
Hyp: 
def fib ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT return fib ( n - 1 ) + fib ( n - 2 ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
void findDay ( int Y , int B ) { int lyear , rest , totaldays , day ; Y = ( Y - 1 ) - B ; lyear = Y / 4 ; rest = Y - lyear ; totaldays = ( rest * 365 ) + ( lyear * 366 ) + 1 ; day = ( totaldays % 7 ) ; if ( day == 0 ) System . out . println ( " Monday " ) ; else if ( day == 1 ) System . out . println ( " Tuesday " ) ; else if ( day == 2 ) System . out . println ( " Wednesday " ) ; else if ( day == 3 ) System . out . println ( " Thursday " ) ; else if ( day == 4 ) System . out . println ( " Friday " ) ; else if ( day == 5 ) System . out . println ( " Saturday " ) ; else if ( day == 6 ) System . out . println ( " Sunday " ) ; else System . out . println ( " INPUT ▁ YEAR ▁ IS ▁ WRONG ! " ) ; }
Ref: 
def findDay ( Y , B ) : NEW_LINE INDENT lyear , rest , totaldays , day = 0 , 0 , 0 , 0 ; NEW_LINE Y = ( Y - 1 ) - B ; NEW_LINE lyear = Y // 4 ; NEW_LINE rest = Y - lyear ; NEW_LINE totaldays = ( rest * 365 ) + ( lyear * 366 ) + 1 ; NEW_LINE day = ( totaldays % 7 ) ; NEW_LINE if ( day == 0 ) : NEW_LINE INDENT print ( " Monday " ) ; NEW_LINE DEDENT elif ( day == 1 ) : NEW_LINE INDENT print ( " Tuesday " ) ; NEW_LINE DEDENT elif ( day == 2 ) : NEW_LINE INDENT print ( " Wednesday " ) ; NEW_LINE DEDENT elif ( day == 3 ) : NEW_LINE INDENT print ( " Thursday " ) ; NEW_LINE DEDENT elif ( day == 4 ) : NEW_LINE INDENT print ( " Friday " ) ; NEW_LINE DEDENT elif ( day == 5 ) : NEW_LINE INDENT print ( " Saturday " ) ; NEW_LINE DEDENT elif ( day == 6 ) : NEW_LINE INDENT print ( " Sunday " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " INPUT ▁ YEAR ▁ IS ▁ WRONG ! " ) ; NEW_LINE DEDENT DEDENT
Hyp: 
def findDay ( Y , B ) : NEW_LINE INDENT Y = ( Y - 1 ) - B NEW_LINE lyear = Y // 4 NEW_LINE rest = Y - lyear NEW_LINE totaldays = ( rest * 365 ) + ( lyear * 366 ) + 1 NEW_LINE day = ( totaldays % 7 ) NEW_LINE if ( day == 0 ) : NEW_LINE INDENT print ( " Monday " ) NEW_LINE elif ( day == 1 ) : NEW_LINE INDENT print ( " Tuesday " ) NEW_LINE DEDENT elif ( day == 2 ) : NEW_LINE INDENT print ( " Wednesday " ) NEW_LINE DEDENT elif ( day == 3 ) : NEW_LINE INDENT print ( " Thursday " ) NEW_LINE DEDENT elif ( day == 4 ) : NEW_LINE INDENT print ( " Friday " ) NEW_LINE DEDENT elif ( day == 5 ) : NEW_LINE INDENT print ( " Saturday " ) NEW_LINE DEDENT elif ( day == 6 ) : NEW_LINE INDENT print ( " Sunday " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " INPUT ▁ YEAR ▁ IS ▁ WRONG ! " ) NEW_LINE DEDENT DEDENT

BLEU: 75.28
Edit Sim: 91


Src: 
int getInvCount ( int arr [ ] , int n ) { int invcount = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int small = 0 ; for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] > arr [ j ] ) small ++ ; int great = 0 ; for ( int j = i - 1 ; j >= 0 ; j -- ) if ( arr [ i ] < arr [ j ] ) great ++ ; invcount += great * small ; } return invcount ; }
Ref: 
def getInvCount ( arr , n ) : NEW_LINE INDENT invcount = 0 NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT small = 0 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] ) : NEW_LINE INDENT small += 1 NEW_LINE DEDENT DEDENT great = 0 ; NEW_LINE for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] < arr [ j ] ) : NEW_LINE INDENT great += 1 NEW_LINE DEDENT DEDENT invcount += great * small NEW_LINE DEDENT return invcount NEW_LINE DEDENT
Hyp: 
def getInvCount ( arr , n ) : NEW_LINE INDENT invcount = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT small = 0 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] ) : NEW_LINE INDENT small += 1 NEW_LINE DEDENT DEDENT great = 0 NEW_LINE for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] < arr [ j ] ) : NEW_LINE INDENT great += 1 NEW_LINE DEDENT DEDENT invcount += small * small NEW_LINE DEDENT return invcount NEW_LINE DEDENT

BLEU: 92.92
Edit Sim: 11


Src: 
int findMinDifference ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int diff1 = arr [ n - 1 ] - arr [ 1 ] ; int diff2 = arr [ n - 2 ] - arr [ 0 ] ; return Math . min ( diff1 , diff2 ) ; }
Ref: 
def findMinDifference ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE diff1 = arr [ n - 1 ] - arr [ 1 ] NEW_LINE diff2 = arr [ n - 2 ] - arr [ 0 ] NEW_LINE return min ( diff1 , diff2 ) NEW_LINE DEDENT
Hyp: 
def findMinDifference ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE diff1 = arr [ n - 1 ] - arr [ 1 ] NEW_LINE diff2 = arr [ n - 2 ] - arr [ 0 ] NEW_LINE return min ( diff1 , diff2 ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int maxPointOfIntersection ( int x , int y ) { int k = y * ( y - 1 ) / 2 ; k = k + x * ( 2 * y + x - 1 ) ; return k ; }
Ref: 
def maxPointOfIntersection ( x , y ) : NEW_LINE INDENT k = y * ( y - 1 ) // 2 NEW_LINE k = k + x * ( 2 * y + x - 1 ) NEW_LINE return k NEW_LINE DEDENT
Hyp: 
def maxPointOfIntersection ( x , y ) : NEW_LINE INDENT k = y * ( y - 1 ) / 2 NEW_LINE k = k + x * ( 2 * y + x - 1 ) NEW_LINE return k NEW_LINE DEDENT

BLEU: 93.86
Edit Sim: 1


Src: 
boolean isPossible ( int A [ ] , int B [ ] , int n , int m , int x , int y ) { if ( x > n y > m ) return false ; Arrays . sort ( A ) ; Arrays . sort ( B ) ; if ( A [ x - 1 ] < B [ m - y ] ) return true ; else return false ; }
Ref: 
def isPossible ( A , B , n , m , x , y ) : NEW_LINE INDENT if ( x > n or y > m ) : NEW_LINE INDENT return False NEW_LINE DEDENT A . sort ( ) NEW_LINE B . sort ( ) NEW_LINE if ( A [ x - 1 ] < B [ m - y ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT A = [ 1 , 1 , 1 , 1 , 1 ] NEW_LINE B = [ 2 , 2 ] NEW_LINE n = len ( A ) NEW_LINE m = len ( B ) NEW_LINE x = 3 NEW_LINE y = 1 NEW_LINE if ( isPossible ( A , B , n , m , x , y ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
Hyp: 
def isPossible ( A , B , n , m , x , y ) : NEW_LINE INDENT if ( x > n or y > m ) : NEW_LINE INDENT return False NEW_LINE DEDENT A . sort ( ) NEW_LINE B . sort ( ) NEW_LINE if ( A [ x - 1 ] < B [ m - y ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT A = [ 7 , 8 , 7 ] NEW_LINE B = [ 5 , 3 , 2 ] NEW_LINE x = 5 NEW_LINE y = m NEW_LINE if ( isPossible ( A , B , n , m , x , y ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT

BLEU: 80.05
Edit Sim: 60


Src: 
int subsetSum ( int arr [ ] , int n , int sum , int s , int count ) { if ( n == 0 ) { if ( sum == s ) { count ++ ; } return count ; } count = subsetSum ( arr , n - 1 , sum , s , count ) ; count = subsetSum ( arr , n - 1 , sum , s + arr [ n - 1 ] , count ) ; return count ; }
Ref: 
def subsetSum ( arr , n , i , sum , count ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT if ( sum == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT count = subsetSum ( arr , n , i + 1 , sum - arr [ i ] , count ) NEW_LINE count = subsetSum ( arr , n , i + 1 , sum , count ) NEW_LINE return count NEW_LINE DEDENT
Hyp: 
def subsetSum ( arr , n , sum , s , count ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT if ( sum == s ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT count = subsetSum ( arr , n - 1 , sum , s , count ) NEW_LINE count = subsetSum ( arr , n - 1 , sum , s + arr [ n - 1 ] , count ) NEW_LINE return count NEW_LINE DEDENT

BLEU: 71.89
Edit Sim: 45


Src: 
int nthTerm ( int N ) { int nth = 0 ; if ( N % 2 == 1 ) nth = ( N * N ) + 1 ; else nth = ( N * N ) - 1 ; return nth ; }
Ref: 
def nthTerm ( N ) : NEW_LINE INDENT nth = 0 ; NEW_LINE if ( N % 2 == 1 ) : NEW_LINE INDENT nth = ( N * N ) + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT nth = ( N * N ) - 1 ; NEW_LINE DEDENT return nth ; NEW_LINE DEDENT
Hyp: 
def nthTerm ( N ) : NEW_LINE INDENT nth = 0 NEW_LINE if ( N % 2 == 1 ) : NEW_LINE INDENT nth = ( N * N ) + 1 NEW_LINE DEDENT else : NEW_LINE INDENT nth = ( N * N ) - 1 NEW_LINE DEDENT return nth NEW_LINE DEDENT

BLEU: 82.07
Edit Sim: 8


Src: 
void swapThree ( ) { a = a ^ b ^ c ; b = a ^ b ^ c ; c = a ^ b ^ c ; a = a ^ b ^ c ; }
Ref: 
def swapThree ( a , b , c ) : NEW_LINE INDENT a [ 0 ] = a [ 0 ] ^ b [ 0 ] ^ c [ 0 ] NEW_LINE b [ 0 ] = a [ 0 ] ^ b [ 0 ] ^ c [ 0 ] NEW_LINE c [ 0 ] = a [ 0 ] ^ b [ 0 ] ^ c [ 0 ] NEW_LINE a [ 0 ] = a [ 0 ] ^ b [ 0 ] ^ c [ 0 ] NEW_LINE DEDENT
Hyp: 
def swapThree ( ) : NEW_LINE INDENT a = a ^ b ^ c NEW_LINE b = a ^ b ^ c NEW_LINE c = a ^ b ^ c NEW_LINE a = a ^ b ^ c NEW_LINE b = a ^ b ^ c NEW_LINE c = a ^ b ^ c NEW_LINE a = a ^ b ^ c NEW_LINE DEDENT

BLEU: 11.11
Edit Sim: 102


Src: 
void rearrange ( int A [ ] , int B [ ] , int N , int X ) { boolean flag = true ; Arrays . sort ( A ) ; Arrays . sort ( B ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( A [ i ] + B [ N - 1 - i ] > X ) { flag = false ; break ; } } if ( flag == true ) System . out . print ( " Yes " ) ; else System . out . print ( " No " ) ; }
Ref: 
def rearrange ( A , B , N , X ) : NEW_LINE INDENT flag = True NEW_LINE A = sorted ( A ) NEW_LINE B = sorted ( B ) [ : : - 1 ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( A [ i ] + B [ i ] > X ) : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
Hyp: 
def rearrange ( A , B , N , X ) : NEW_LINE INDENT flag = True NEW_LINE A = sorted ( A ) NEW_LINE B = sorted ( B ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( A [ i ] + B [ N - 1 - i ] > X ) : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag == True ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT

BLEU: 90.15
Edit Sim: 28


Src: 
int findMinDenomin ( int n ) { return ( ( int ) ( Math . log ( n ) / Math . log ( 2 ) ) + 1 ) ; }
Ref: 
def findMinDenomin ( n ) : NEW_LINE INDENT return log2 ( n ) + 1 NEW_LINE DEDENT
Hyp: 
def findMinDenomin ( n ) : NEW_LINE INDENT return ( int ) ( math . log2 ( n ) ) + 1 ) NEW_LINE DEDENT

BLEU: 50.73
Edit Sim: 21


Src: 
void fibonacci ( double n ) { double fib ; for ( double i = 0 ; i < n ; i ++ ) { fib = ( Math . pow ( ( 1 + Math . sqrt ( 5 ) ) , i ) - Math . pow ( ( 1 - Math . sqrt ( 5 ) ) , i ) ) / ( Math . pow ( 2 , i ) * Math . sqrt ( 5 ) ) ; System . out . print ( ( int ) fib + " ▁ " ) ; } }
Ref: 
def fibonacci ( n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT fib = ( ( pow ( ( 1 + math . sqrt ( 5 ) ) , i ) - pow ( ( 1 - math . sqrt ( 5 ) ) , i ) ) / ( pow ( 2 , i ) * math . sqrt ( 5 ) ) ) ; NEW_LINE print ( int ( fib ) , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT
Hyp: 
def fibonacci ( n ) : NEW_LINE INDENT fib = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT fib = ( ( 1 + sqrt ( 5 ) ) - ( 1 - sqrt ( 5 ) ) ) / ( pow ( 2 , i ) * pow ( 5 ) ) NEW_LINE print ( ( int ) fib , end = " ▁ " ) NEW_LINE DEDENT DEDENT

BLEU: 55.22
Edit Sim: 83


Src: 
int findFirstMissing ( int array [ ] , int start , int end ) { if ( start > end ) return end + 1 ; if ( start != array [ start ] ) return start ; int mid = ( start + end ) / 2 ; if ( array [ mid ] == mid ) return findFirstMissing ( array , mid + 1 , end ) ; return findFirstMissing ( array , start , mid ) ; }
Ref: 
def findFirstMissing ( array , start , end ) : NEW_LINE INDENT if ( start > end ) : NEW_LINE INDENT return end + 1 NEW_LINE DEDENT if ( start != array [ start ] ) : NEW_LINE INDENT return start ; NEW_LINE DEDENT mid = int ( ( start + end ) / 2 ) NEW_LINE if ( array [ mid ] == mid ) : NEW_LINE INDENT return findFirstMissing ( array , mid + 1 , end ) NEW_LINE DEDENT return findFirstMissing ( array , start , mid ) NEW_LINE DEDENT
Hyp: 
def findFirstMissing ( array , start , end ) : NEW_LINE INDENT if ( start > end ) : NEW_LINE INDENT return end + 1 NEW_LINE DEDENT if ( start != array [ start ] ) : NEW_LINE INDENT return start NEW_LINE DEDENT mid = ( start + end ) // 2 NEW_LINE if ( array [ mid ] == mid ) : NEW_LINE INDENT return findFirstMissing ( array , mid + 1 , end ) NEW_LINE DEDENT return findFirstMissing ( array , start , mid ) NEW_LINE DEDENT

BLEU: 88.71
Edit Sim: 11


Src: 
void minimumOperations ( String S , int N ) { int ans = 0 ; int cntOne = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( S . charAt ( i ) == '0' ) { ans += cntOne ; cntOne *= 2 ; } else cntOne ++ ; } System . out . println ( ans ) ; }
Ref: 
def minimumOperations ( S , N ) : NEW_LINE INDENT ans = 0 NEW_LINE cntOne = 0 NEW_LINE i = N - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT if ( S [ i ] == '0' ) : NEW_LINE INDENT ans += cntOne NEW_LINE cntOne *= 2 NEW_LINE DEDENT else : NEW_LINE INDENT cntOne += 1 NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
Hyp: 
def minimumOperations ( S , N ) : NEW_LINE INDENT ans = 0 NEW_LINE cntOne = 0 NEW_LINE for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( S [ i ] == '0' ) : NEW_LINE INDENT ans += cntOne NEW_LINE cntOne *= 2 NEW_LINE DEDENT else : NEW_LINE INDENT cntOne += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT

BLEU: 78.23
Edit Sim: 42


Src: 
int countSubsequences ( int arr [ ] ) { int odd = 0 ; int even = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( ( arr [ i ] & 1 ) != 0 ) odd ++ ; else even ++ ; } return ( ( 1 << odd ) - 1 ) * ( 1 << even ) ; }
Ref: 
def countSubsequences ( arr ) : NEW_LINE INDENT odd = 0 ; NEW_LINE even = 0 ; NEW_LINE for x in arr : NEW_LINE INDENT if ( x & 1 ) : NEW_LINE INDENT odd += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT even += 1 ; NEW_LINE DEDENT DEDENT return ( ( 1 << odd ) - 1 ) * ( 1 << even ) ; NEW_LINE DEDENT
Hyp: 
def countSubsequences ( arr ) : NEW_LINE INDENT odd = 0 ; NEW_LINE even = 0 ; NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT if ( arr [ i ] & 1 ) : NEW_LINE INDENT odd += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT even += 1 ; NEW_LINE DEDENT DEDENT return ( ( 1 << odd ) - 1 ) * ( 1 << even ) ; NEW_LINE DEDENT

BLEU: 80.1
Edit Sim: 28


Src: 
void sumOfSubarrayProd ( int arr [ ] , int n ) { int ans = 0 ; int res = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { int incr = arr [ i ] * ( 1 + res ) ; ans += incr ; res = incr ; } System . out . println ( ans ) ; }
Ref: 
def sumOfSubarrayProd ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE res = 0 NEW_LINE i = n - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT incr = arr [ i ] * ( 1 + res ) NEW_LINE ans += incr NEW_LINE res = incr NEW_LINE i -= 1 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
Hyp: 
def sumOfSubarrayProd ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE res = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT incr = arr [ i ] * ( 1 + res ) NEW_LINE ans += incr NEW_LINE res = incr NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT

BLEU: 76.34
Edit Sim: 43


Src: 
int minElements ( int arr [ ] , int n ) { int halfSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) halfSum = halfSum + arr [ i ] ; halfSum = halfSum / 2 ; Arrays . sort ( arr ) ; int res = 0 , curr_sum = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { curr_sum += arr [ i ] ; res ++ ; if ( curr_sum > halfSum ) return res ; } return res ; }
Ref: 
def minElements ( arr , n ) : NEW_LINE INDENT halfSum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT halfSum = halfSum + arr [ i ] NEW_LINE DEDENT halfSum = int ( halfSum / 2 ) NEW_LINE arr . sort ( reverse = True ) NEW_LINE res = 0 NEW_LINE curr_sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT curr_sum += arr [ i ] NEW_LINE res += 1 NEW_LINE if curr_sum > halfSum : NEW_LINE INDENT return res NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
Hyp: 
def minElements ( arr , n ) : NEW_LINE INDENT halfSum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT halfSum = halfSum + arr [ i ] ; NEW_LINE DEDENT halfSum = halfSum // 2 ; NEW_LINE arr . sort ( ) ; NEW_LINE res = 0 ; NEW_LINE curr_sum = 0 ; NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT curr_sum += arr [ i ] ; NEW_LINE res += 1 ; NEW_LINE if ( curr_sum > halfSum ) : NEW_LINE INDENT return res ; NEW_LINE DEDENT DEDENT return res ; NEW_LINE DEDENT

BLEU: 60.39
Edit Sim: 59


Src: 
void Count_numbers ( int L , int R ) { int count = ( R - L ) / 2 ; if ( R % 2 != 0 L % 2 != 0 ) count += 1 ; System . out . print ( count ) ; }
Ref: 
def Count_numbers ( L , R ) : NEW_LINE INDENT count = ( R - L ) // 2 NEW_LINE if ( R % 2 != 0 or L % 2 != 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT print ( count ) NEW_LINE DEDENT
Hyp: 
def Count_numbers ( L , R ) : NEW_LINE INDENT count = ( R - L ) // 2 NEW_LINE if ( R % 2 != 0 or L % 2 != 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT print ( count ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
void XOROfElements ( int arr [ ] , int n ) { int FirstHalfXOR = 0 ; int SecondHalfXOR = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i < n / 2 ) FirstHalfXOR ^= arr [ i ] ; else SecondHalfXOR ^= arr [ i ] ; } System . out . print ( FirstHalfXOR + " , " + SecondHalfXOR + "NEW_LINE"); }
Ref: 
def XOROfElements ( arr , n ) : NEW_LINE INDENT FirstHalfXOR = 0 ; NEW_LINE SecondHalfXOR = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i < n // 2 ) : NEW_LINE INDENT FirstHalfXOR ^= arr [ i ] ; NEW_LINE DEDENT else : NEW_LINE INDENT SecondHalfXOR ^= arr [ i ] ; NEW_LINE DEDENT DEDENT print ( FirstHalfXOR , " , " , SecondHalfXOR ) ; NEW_LINE DEDENT
Hyp: 
def XOROfElements ( arr , n ) : NEW_LINE INDENT FirstHalfXOR = 0 ; NEW_LINE SecondHalfXOR = 0 ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( i < int ( n / 2 ) ) : NEW_LINE INDENT FirstHalfXOR ^= arr [ i ] ; NEW_LINE DEDENT else : NEW_LINE INDENT SecondHalfXOR ^= arr [ i ] ; NEW_LINE DEDENT DEDENT print ( FirstHalfXOR , " , " , SecondHalfXOR ) ; NEW_LINE DEDENT

BLEU: 87.58
Edit Sim: 12


Src: 
String separateChar ( String str ) { int n = str . length ( ) , digitSum = 0 ; int alphabetSum = 0 , j = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str . charAt ( i ) >= '0' && str . charAt ( i ) <= '9' ) { digitSum += ( int ) ( str . charAt ( i ) - '0' ) ; } else { alphabetSum += str . charAt ( i ) - ' a ' + 1 ; alphabetSum %= 26 ; } } String sumStr = " " + ( digitSum ) ; char alphabetStr = ( char ) ( alphabetSum + ' a ' - 1 ) ; sumStr += alphabetStr ; return sumStr ; }
Ref: 
def separateChar ( str__ ) : NEW_LINE INDENT n = len ( str__ ) NEW_LINE digitSum = 0 NEW_LINE alphabetSum = 0 NEW_LINE j = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ord ( str__ [ i ] ) >= 48 and ord ( str__ [ i ] ) <= 56 ) : NEW_LINE INDENT digitSum += ord ( str__ [ i ] ) - ord ( '0' ) NEW_LINE DEDENT else : NEW_LINE INDENT alphabetSum += ord ( str__ [ i ] ) - ord ( ' a ' ) + 1 NEW_LINE alphabetSum %= 26 NEW_LINE DEDENT DEDENT sumStr = str ( digitSum ) NEW_LINE alphabetStr = chr ( alphabetSum + ord ( ' a ' ) - 1 ) NEW_LINE sumStr += alphabetStr NEW_LINE return sumStr NEW_LINE DEDENT
Hyp: 
def separateChar ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE digitSum = 0 NEW_LINE alphabetSum = 0 NEW_LINE j = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( str [ i ] >= '0' and str [ i ] <= '9' ) : NEW_LINE INDENT digitSum += int ( str [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT alphabetSum += ord ( str [ i ] ) - ord ( ' a ' ) + 1 NEW_LINE alphabetSum %= 26 NEW_LINE DEDENT DEDENT sumStr = " " + ( digitSum ) NEW_LINE alphabetStr = ( char ) ( alphabetSum + ' a ' - 1 ) NEW_LINE sumStr += alphabetStr NEW_LINE return sumStr NEW_LINE DEDENT

BLEU: 65.34
Edit Sim: 73


Src: 
float squarearea ( float r ) { if ( r < 0 ) return - 1 ; float a = 4 * ( float ) ( Math . pow ( r , 2 ) / 5 ) ; return a ; }
Ref: 
def squarearea ( r ) : NEW_LINE INDENT if ( r < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT a = 4 * ( pow ( r , 2 ) / 5 ) NEW_LINE return a NEW_LINE DEDENT
Hyp: 
def squarearea ( r ) : NEW_LINE INDENT if r < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT a = 4 * ( pow ( r , 2 ) / 5 ) NEW_LINE return a NEW_LINE DEDENT

BLEU: 87.24
Edit Sim: 4


Src: 
int getFirstElement ( int a [ ] , int N , int K , int M ) { K %= N ; int index ; if ( K >= M ) index = ( N - K ) + ( M - 1 ) ; else index = ( M - K - 1 ) ; int result = a [ index ] ; return result ; }
Ref: 
def getFirstElement ( a , N , K , M ) : NEW_LINE INDENT K %= N NEW_LINE if ( K >= M ) : NEW_LINE INDENT index = ( N - K ) + ( M - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT index = ( M - K - 1 ) NEW_LINE DEDENT result = a [ index ] NEW_LINE return result NEW_LINE DEDENT
Hyp: 
def getFirstElement ( a , N , K , M ) : NEW_LINE INDENT K %= N NEW_LINE index = 0 NEW_LINE if ( K >= M ) : NEW_LINE INDENT index = ( N - K ) + ( M - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT index = ( M - K - 1 ) NEW_LINE DEDENT result = a [ index ] NEW_LINE return result NEW_LINE DEDENT

BLEU: 93.33
Edit Sim: 19


Src: 
int maxCost ( int mat [ ] [ ] , int N ) { int dp [ ] [ ] = new int [ N ] [ N ] ; dp [ 0 ] [ 0 ] = mat [ 0 ] [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) dp [ i ] [ 0 ] = mat [ i ] [ 0 ] + dp [ i - 1 ] [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) for ( int j = 1 ; j < i + 1 && j < N ; j ++ ) dp [ i ] [ j ] = mat [ i ] [ j ] + Math . max ( dp [ i - 1 ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ; int result = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( result < dp [ N - 1 ] [ i ] ) result = dp [ N - 1 ] [ i ] ; return result ; }
Ref: 
def maxCost ( mat , N ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( N ) ] for j in range ( N ) ] NEW_LINE dp [ 0 ] [ 0 ] = mat [ 0 ] [ 0 ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT dp [ i ] [ 0 ] = mat [ i ] [ 0 ] + dp [ i - 1 ] [ 0 ] NEW_LINE DEDENT for i in range ( 1 , N ) : NEW_LINE INDENT for j in range ( 1 , min ( i + 1 , N ) ) : NEW_LINE INDENT dp [ i ] [ j ] = mat [ i ] [ j ] + max ( dp [ i - 1 ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT result = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( result < dp [ N - 1 ] [ i ] ) : NEW_LINE INDENT result = dp [ N - 1 ] [ i ] NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
Hyp: 
def maxCost ( mat , N ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( N + 1 ) ] for j in range ( 1 , N + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = mat [ 0 ] [ 0 ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT for j in range ( 1 , i + 1 and j < N ) : NEW_LINE INDENT dp [ i ] [ j ] = mat [ i ] [ j ] + max ( dp [ i - 1 ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT result = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( result < dp [ N - 1 ] [ i ] ) : NEW_LINE INDENT result = dp [ N - 1 ] [ i ] NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT

BLEU: 76.51
Edit Sim: 124


Src: 
void convertToDecimal ( int N ) { System . out . print ( " Decimal ▁ number ▁ of ▁ " + N + " ▁ is : ▁ " ) ; if ( N != 0 ) { int decimalNumber = 0 , i = 0 , remainder ; while ( N != 0 ) { remainder = N % 10 ; N /= 10 ; decimalNumber += remainder * Math . pow ( 3 , i ) ; ++ i ; } System . out . print ( decimalNumber + "NEW_LINE"); } else System . out . print ( "0" + "NEW_LINE"); }
Ref: 
def convertToDecimal ( N ) : NEW_LINE INDENT print ( " Decimal ▁ number ▁ of " , N , " is : " , end = " ▁ " ) ; NEW_LINE if ( N != 0 ) : NEW_LINE INDENT decimalNumber = 0 ; NEW_LINE i = 0 ; NEW_LINE remainder = 0 ; NEW_LINE while ( N != 0 ) : NEW_LINE INDENT remainder = N % 10 ; NEW_LINE N = N // 10 ; NEW_LINE decimalNumber += remainder * math . pow ( 3 , i ) ; NEW_LINE i += 1 ; NEW_LINE DEDENT print ( decimalNumber ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( "0" ) ; NEW_LINE DEDENT DEDENT
Hyp: 
def convertToDecimal ( N ) : NEW_LINE INDENT print ( " Decimal ▁ number ▁ of ▁ " , N , " ▁ is : ▁ " ) NEW_LINE if ( N != 0 ) : NEW_LINE INDENT decimalNumber = 0 NEW_LINE i = 0 NEW_LINE remainder = 0 NEW_LINE N //= 10 NEW_LINE decimalNumber += remainder * pow ( 3 , i ) NEW_LINE i += 1 NEW_LINE DEDENT print ( decimalNumber , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "0" ) NEW_LINE DEDENT DEDENT

BLEU: 51.93
Edit Sim: 121


Src: 
boolean isCheck ( String str ) { int len = str . length ( ) ; String lowerStr = " " , upperStr = " " ; char [ ] str1 = str . toCharArray ( ) ; for ( int i = 0 ; i < len ; i ++ ) { if ( ( int ) ( str1 [ i ] ) >= 65 && ( int ) str1 [ i ] <= 91 ) upperStr = upperStr + str1 [ i ] ; else lowerStr = lowerStr + str1 [ i ] ; } String transformStr = lowerStr . toUpperCase ( ) ; return ( transformStr . equals ( upperStr ) ) ; }
Ref: 
def isCheck ( str ) : NEW_LINE INDENT length = len ( str ) NEW_LINE lowerStr , upperStr = " " , " " NEW_LINE for i in range ( length ) : NEW_LINE INDENT if ( ord ( str [ i ] ) >= 65 and ord ( str [ i ] ) <= 91 ) : NEW_LINE INDENT upperStr = upperStr + str [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT lowerStr = lowerStr + str [ i ] NEW_LINE DEDENT DEDENT transformStr = lowerStr . upper ( ) NEW_LINE return transformStr == upperStr NEW_LINE DEDENT
Hyp: 
def isCheck ( str ) : NEW_LINE INDENT ln = len ( str ) NEW_LINE lowerStr = " " NEW_LINE upperStr = " " NEW_LINE for i in range ( 0 , ln ) : NEW_LINE INDENT if ( ord ( str1 [ i ] ) >= 65 and ord ( str1 [ i ] ) <= 91 ) : NEW_LINE INDENT upperStr = upperStr + str1 [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT lowerStr = lowerStr + str1 [ i ] NEW_LINE DEDENT DEDENT transformStr = lowerStr . upper ( ) NEW_LINE return ( transformStr == upperStr ) NEW_LINE DEDENT

BLEU: 73.17
Edit Sim: 38


Src: 
int maxValue ( int arr [ ] , int n , int moves ) { for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] > 0 ) { int distance = n - 1 - i ; if ( moves < distance ) break ; int can_take = moves / distance ; int take = Math . min ( arr [ i ] , can_take ) ; arr [ n - 1 ] += take ; moves -= take * distance ; } } return arr [ n - 1 ] ; }
Ref: 
def maxValue ( arr , n , moves ) : NEW_LINE INDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT distance = n - 1 - i NEW_LINE if ( moves < distance ) : NEW_LINE INDENT break NEW_LINE DEDENT can_take = moves // distance NEW_LINE take = min ( arr [ i ] , can_take ) NEW_LINE arr [ n - 1 ] += take NEW_LINE moves -= take * distance NEW_LINE DEDENT DEDENT return arr [ n - 1 ] NEW_LINE DEDENT
Hyp: 
def maxValue ( arr , n , moves ) : NEW_LINE INDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT distance = n - 1 - i NEW_LINE if ( moves < distance ) : NEW_LINE INDENT break NEW_LINE DEDENT can_take = moves // distance NEW_LINE take = min ( arr [ i ] , can_take ) NEW_LINE arr [ n - 1 ] += take NEW_LINE moves -= take * distance NEW_LINE DEDENT DEDENT return arr [ n - 1 ] NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
float cyl ( float a ) { if ( a < 0 ) return - 1 ; float r = ( 2 * a * ( float ) ( Math . sqrt ( 2 ) ) / 3 ) ; float h = ( 2 * a ) / 3 ; float V = ( 3.14f * ( float ) ( Math . pow ( r , 2 ) * h ) ) ; return V ; }
Ref: 
def cyl ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT r = ( 2 * a * mt . sqrt ( 2 ) ) / 3 NEW_LINE h = ( 2 * a ) / 3 NEW_LINE V = 3.14 * pow ( r , 2 ) * h NEW_LINE return V NEW_LINE DEDENT
Hyp: 
def cyl ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT r = ( 2 * a * math . sqrt ( 2 ) ) / 3 NEW_LINE h = ( 2 * a ) / 3 NEW_LINE V = ( 3.14 * math . pow ( r , 2 ) * h ) ) NEW_LINE return V NEW_LINE DEDENT

BLEU: 83.01
Edit Sim: 15


Src: 
void printArray ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int l = 0 , r = n - 1 , flag = 0 , i ; int k = 2 ; while ( l <= r ) { if ( flag == 0 ) { for ( i = l ; i < l + k && i <= r ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; flag = 1 ; l = i ; } { for ( i = r ; i > r - k && i >= l ; i -- ) System . out . print ( arr [ i ] + " ▁ " ) ; flag = 0 ; r = i ; } k ++ ; } }
Ref: 
def printArray ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE l = 0 NEW_LINE r = n - 1 NEW_LINE flag = 0 NEW_LINE k = 2 NEW_LINE while ( l <= r ) : NEW_LINE INDENT if ( flag == 0 ) : NEW_LINE INDENT i = l NEW_LINE while i < l + k and i <= r : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE i += 1 NEW_LINE DEDENT flag = 1 NEW_LINE l = i NEW_LINE i = r NEW_LINE while i > r - k and i >= l : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE i -= 1 NEW_LINE DEDENT flag = 0 NEW_LINE r = i NEW_LINE DEDENT k += 1 NEW_LINE DEDENT DEDENT
Hyp: 
def printArray ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE l = 0 NEW_LINE r = n - 1 NEW_LINE flag = 0 NEW_LINE while ( l <= r ) : NEW_LINE INDENT if ( flag == 0 ) : NEW_LINE INDENT for i in range ( l , l + k , r + 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE flag = 1 NEW_LINE l = i NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for i in range ( r , r - k , l + 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT flag = 0 NEW_LINE r = i NEW_LINE DEDENT k += 1 NEW_LINE DEDENT DEDENT

BLEU: 71.36
Edit Sim: 119


Src: 
> getArray ( int n ) { Vector < Long > ans = new Vector < Long > ( ) ; long p2 = 1 ; while ( n > 0 ) { if ( n % 2 == 1 ) ans . add ( p2 ) ; n >>= 1 ; p2 *= 2 ; } return ans ; }
Ref: 
def getArray ( n ) : NEW_LINE INDENT ans = [ ] ; NEW_LINE p2 = 1 ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT if ( n & 1 ) : NEW_LINE INDENT ans . append ( p2 ) ; NEW_LINE DEDENT n >>= 1 ; NEW_LINE p2 *= 2 ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT
Hyp: 
def getArray ( n ) : NEW_LINE INDENT ans = [ ] NEW_LINE p2 = 1 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT if ( n % 2 == 1 ) : NEW_LINE INDENT ans . append ( p2 ) NEW_LINE DEDENT n >>= 1 NEW_LINE p2 *= 2 NEW_LINE DEDENT return ans NEW_LINE DEDENT

BLEU: 70.46
Edit Sim: 18


Src: 
int numberOfSticks ( int x ) { return ( 3 * x * ( x + 1 ) ) / 2 ; }
Ref: 
def numberOfSticks ( x ) : NEW_LINE INDENT return ( 3 * x * ( x + 1 ) ) / 2 NEW_LINE DEDENT
Hyp: 
def numberOfSticks ( x ) : NEW_LINE INDENT return ( 3 * x * ( x + 1 ) ) // 2 NEW_LINE DEDENT

BLEU: 88.95
Edit Sim: 1


Src: 
double maxAverageOfPath ( int cost [ ] [ ] , int N ) { int dp [ ] [ ] = new int [ N + 1 ] [ N + 1 ] ; dp [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ] ; for ( int j = 1 ; j < N ; j ++ ) dp [ 0 ] [ j ] = dp [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ] ; for ( int i = 1 ; i < N ; i ++ ) for ( int j = 1 ; j < N ; j ++ ) dp [ i ] [ j ] = Math . max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) + cost [ i ] [ j ] ; return ( double ) dp [ N - 1 ] [ N - 1 ] / ( 2 * N - 1 ) ; }
Ref: 
def maxAverageOfPath ( cost , N ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( N + 1 ) ] for j in range ( N + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ] NEW_LINE DEDENT for j in range ( 1 , N ) : NEW_LINE INDENT dp [ 0 ] [ j ] = dp [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ] NEW_LINE DEDENT for i in range ( 1 , N ) : NEW_LINE INDENT for j in range ( 1 , N ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) + cost [ i ] [ j ] NEW_LINE DEDENT DEDENT return dp [ N - 1 ] [ N - 1 ] / ( 2 * N - 1 ) NEW_LINE DEDENT
Hyp: 
def maxAverageOfPath ( cost , N ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( N + 1 ) ] for j in range ( N + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ] NEW_LINE DEDENT for j in range ( 1 , N ) : NEW_LINE INDENT dp [ 0 ] [ j ] = ( dp [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ] ) NEW_LINE DEDENT for i in range ( 1 , N ) : NEW_LINE INDENT for j in range ( 1 , N ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) + cost [ i ] [ j ] NEW_LINE DEDENT DEDENT return dp [ N - 1 ] [ N - 1 ] / ( 2 * N - 1 ) NEW_LINE DEDENT

BLEU: 97.7
Edit Sim: 4


Src: 
void FindRank ( int arr [ ] , int length ) { System . out . print ( "1" + " ▁ " ) ; for ( int i = 1 ; i < arr . length ; i ++ ) { int rank = 1 ; for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ j ] > arr [ i ] ) rank ++ ; } System . out . print ( rank + " ▁ " ) ; } }
Ref: 
def FindRank ( arr , length ) : NEW_LINE INDENT print ( 1 , end = " ▁ " ) NEW_LINE for i in range ( 1 , length ) : NEW_LINE INDENT rank = 1 NEW_LINE for j in range ( 0 , i ) : NEW_LINE INDENT if ( arr [ j ] > arr [ i ] ) : NEW_LINE INDENT rank = rank + 1 NEW_LINE DEDENT DEDENT print ( rank , end = " ▁ " ) NEW_LINE DEDENT DEDENT
Hyp: 
def FindRank ( arr , length ) : NEW_LINE INDENT print ( "1" , end = " ▁ " ) NEW_LINE for i in range ( 1 , length + 1 ) : NEW_LINE INDENT rank = 1 NEW_LINE for j in range ( i ) : NEW_LINE INDENT if ( arr [ j ] > arr [ i ] ) : NEW_LINE INDENT rank += 1 NEW_LINE DEDENT DEDENT print ( rank , end = " ▁ " ) NEW_LINE DEDENT DEDENT

BLEU: 86.35
Edit Sim: 18


Src: 
void checkSolution ( int a , int b , int c ) { if ( b == 0 ) System . out . print ( " Yes " ) ; else System . out . print ( " No " ) ; }
Ref: 
def checkSolution ( a , b , c ) : NEW_LINE INDENT if b == 0 : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
Hyp: 
def checkSolution ( a , b , c ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT DEDENT

BLEU: 75.95
Edit Sim: 8


Src: 
int binomialCoeffSum ( int n ) { return ( 1 << n ) ; }
Ref: 
def binomialCoeffSum ( n ) : NEW_LINE INDENT return ( 1 << n ) ; NEW_LINE DEDENT
Hyp: 
def binomialCoeffSum ( n ) : NEW_LINE INDENT return ( 1 << n ) ; NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
void findMissing ( int a [ ] , int b [ ] , int n , int m ) { for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < m ; j ++ ) if ( a [ i ] == b [ j ] ) break ; if ( j == m ) System . out . print ( a [ i ] + " ▁ " ) ; } }
Ref: 
def findMissing ( a , b , n , m ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( a [ i ] == b [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( j == m - 1 ) : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
Hyp: 
def findMissing ( a , b , n , m ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT flag = 0 NEW_LINE for j in range ( m ) : NEW_LINE INDENT if ( a [ i ] == b [ j ] ) : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( j == m ) : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT

BLEU: 85.67
Edit Sim: 40


Src: 
float areaOfKite ( int d1 , int d2 ) { float area = ( d1 * d2 ) / 2 ; return area ; }
Ref: 
def areaOfKite ( d1 , d2 ) : NEW_LINE INDENT area = ( d1 * d2 ) / 2 ; NEW_LINE return area ; NEW_LINE DEDENT
Hyp: 
def areaOfKite ( d1 , d2 ) : NEW_LINE INDENT area = ( d1 * d2 ) / 2 NEW_LINE return area NEW_LINE DEDENT

BLEU: 80.47
Edit Sim: 4


Src: 
int minOR ( int [ ] arr , int n ) { if ( n == 1 ) return 0 ; int [ ] pre = new int [ n ] ; int [ ] suf = new int [ n ] ; pre [ 0 ] = arr [ 0 ] ; suf [ n - 1 ] = arr [ n - 1 ] ; for ( int i = 1 ; i < n ; i ++ ) pre [ i ] = ( pre [ i - 1 ] arr [ i ] ) ; for ( int i = n - 2 ; i >= 0 ; i -- ) suf [ i ] = ( suf [ i + 1 ] arr [ i ] ) ; int ans = Math . min ( pre [ n - 2 ] , suf [ 1 ] ) ; for ( int i = 1 ; i < n - 1 ; i ++ ) ans = Math . min ( ans , ( pre [ i - 1 ] suf [ i + 1 ] ) ) ; return ans ; }
Ref: 
def minOR ( arr , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT pre = [ 0 ] * n NEW_LINE suf = [ 0 ] * n NEW_LINE pre [ 0 ] = arr [ 0 ] NEW_LINE suf [ n - 1 ] = arr [ n - 1 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT pre [ i ] = ( pre [ i - 1 ] arr [ i ] ) NEW_LINE DEDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT suf [ i ] = ( suf [ i + 1 ] arr [ i ] ) NEW_LINE DEDENT ans = min ( pre [ n - 2 ] , suf [ 1 ] ) NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT ans = min ( ans , ( pre [ i - 1 ] suf [ i + 1 ] ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
Hyp: 
def minOR ( arr , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT pre = [ 0 ] * n NEW_LINE suf = [ 0 ] * n NEW_LINE pre [ 0 ] = arr [ 0 ] NEW_LINE suf [ n - 1 ] = arr [ n - 1 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT pre [ i ] = ( pre [ i - 1 ] arr [ i ] ) NEW_LINE DEDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT suf [ i ] = ( suf [ i + 1 ] arr [ i ] ) NEW_LINE DEDENT ans = min ( pre [ n - 2 ] , suf [ 1 ] ) NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT ans = min ( ans , ( pre [ i - 1 ] suf [ i + 1 ] ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int findCount ( int arr [ ] , int N , int K ) { Arrays . sort ( arr ) ; int result = 1 ; int cur_max = arr [ 0 ] ; int cur_min = arr [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) { cur_max = arr [ i ] ; if ( cur_max - cur_min > K ) { result ++ ; cur_max = arr [ i ] ; cur_min = arr [ i ] ; } } return result ; }
Ref: 
def findCount ( arr , N , K ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE result = 1 NEW_LINE cur_max = arr [ 0 ] NEW_LINE cur_min = arr [ 0 ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT cur_max = arr [ i ] NEW_LINE if ( cur_max - cur_min > K ) : NEW_LINE INDENT result += 1 NEW_LINE cur_max = arr [ i ] NEW_LINE cur_min = arr [ i ] NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
Hyp: 
def findCount ( arr , N , K ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE result = 1 NEW_LINE cur_max = arr [ 0 ] NEW_LINE cur_min = arr [ 0 ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT cur_max = arr [ i ] NEW_LINE if ( cur_max - cur_min > K ) : NEW_LINE INDENT result = result + 1 NEW_LINE cur_max = arr [ i ] NEW_LINE cur_min = arr [ i ] NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT

BLEU: 95.06
Edit Sim: 10


Src: 
void printSorted ( int [ ] arr , int start , int end ) { if ( start > end ) return ; printSorted ( arr , start * 2 + 1 , end ) ; System . out . print ( arr [ start ] + " ▁ " ) ; printSorted ( arr , start * 2 + 2 , end ) ; }
Ref: 
def printSorted ( arr , start , end ) : NEW_LINE INDENT if start > end : NEW_LINE INDENT return NEW_LINE DEDENT printSorted ( arr , start * 2 + 1 , end ) NEW_LINE print ( arr [ start ] , end = " ▁ " ) NEW_LINE printSorted ( arr , start * 2 + 2 , end ) NEW_LINE DEDENT
Hyp: 
def printSorted ( arr , start , end ) : NEW_LINE INDENT if ( start > end ) : NEW_LINE INDENT return NEW_LINE DEDENT printSorted ( arr , start * 2 + 1 , end ) NEW_LINE print ( arr [ start ] , end ) NEW_LINE DEDENT

BLEU: 65.52
Edit Sim: 63


Src: 
int checkpoint ( int h , int k , int x , int y , int a ) { int p = ( int ) Math . pow ( ( y - k ) , 2 ) - 4 * a * ( x - h ) ; return p ; }
Ref: 
def checkpoint ( h , k , x , y , a ) : NEW_LINE INDENT p = pow ( ( y - k ) , 2 ) - 4 * a * ( x - h ) NEW_LINE return p NEW_LINE DEDENT
Hyp: 
def checkpoint ( h , k , x , y , a ) : NEW_LINE INDENT p = pow ( ( y - k ) , 2 ) - 4 * a * ( x - h ) ; NEW_LINE return p ; NEW_LINE DEDENT

BLEU: 89.1
Edit Sim: 4


Src: 
Boolean isOverflow ( long a , long b ) { if ( a == 0 b == 0 ) return false ; long result = a * b ; if ( a == result / b ) return false ; else return true ; }
Ref: 
def isOverflow ( a , b ) : NEW_LINE INDENT if ( a == 0 or b == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT result = a * b NEW_LINE if ( result >= 9223372036854775807 or result <= - 9223372036854775808 ) : NEW_LINE INDENT result = 0 NEW_LINE DEDENT if ( a == ( result // b ) ) : NEW_LINE INDENT print ( result // b ) NEW_LINE return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT
Hyp: 
def isOverflow ( a , b ) : NEW_LINE INDENT if ( a == 0 or b == 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT result = a * b ; NEW_LINE if ( a == result // b ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT else : NEW_LINE INDENT return True ; NEW_LINE DEDENT DEDENT a = 1556 NEW_LINE b = 2 NEW_LINE if ( isOverflow ( a , b ) ) : NEW_LINE INDENT print ( " YES " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) ; NEW_LINE DEDENT

BLEU: 52.99
Edit Sim: 163


Src: 
int numberofways ( int n , int m ) { int dp [ ] [ ] = new int [ n + 2 ] [ n + 2 ] ; dp [ 0 ] [ n + 1 ] = 1 ; for ( int k = n ; k >= m ; k -- ) { for ( int i = 0 ; i <= n ; i ++ ) { dp [ i ] [ k ] = dp [ i ] [ k + 1 ] ; if ( i - k >= 0 ) dp [ i ] [ k ] = ( dp [ i ] [ k ] + dp [ i - k ] [ k ] ) ; } } return dp [ n ] [ m ] ; }
Ref: 
def numberofways ( n , m ) : NEW_LINE INDENT dp = np . zeros ( ( n + 2 , n + 2 ) ) NEW_LINE dp [ 0 ] [ n + 1 ] = 1 NEW_LINE for k in range ( n , m - 1 , - 1 ) : NEW_LINE INDENT for i in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ k ] = dp [ i ] [ k + 1 ] NEW_LINE if ( i - k >= 0 ) : NEW_LINE INDENT dp [ i ] [ k ] = ( dp [ i ] [ k ] + dp [ i - k ] [ k ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ n ] [ m ] NEW_LINE DEDENT
Hyp: 
def numberofways ( n , m ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n + 2 ) ] for i in range ( n + 2 ) ] NEW_LINE dp [ 0 ] [ n + 1 ] = 1 NEW_LINE for k in range ( n , m + 1 ) : NEW_LINE INDENT for i in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ k ] = dp [ i ] [ k + 1 ] NEW_LINE if ( i - k >= 0 ) : NEW_LINE INDENT dp [ i ] [ k ] = ( dp [ i ] [ k ] + dp [ i - k ] [ k ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ n ] [ m ] NEW_LINE DEDENT

BLEU: 84.91
Edit Sim: 44


Src: 
int count_numbers ( int k , int n , boolean flag ) { if ( n == 1 ) { if ( flag ) { return ( k - 1 ) ; } else { return 1 ; } } if ( flag ) return ( k - 1 ) * ( count_numbers ( k , n - 1 , false ) + count_numbers ( k , n - 1 , true ) ) ; else return count_numbers ( k , n - 1 , true ) ; }
Ref: 
def count_numbers ( k , n , flag ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT if ( flag ) : NEW_LINE INDENT return ( k - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT if ( flag ) : NEW_LINE INDENT return ( k - 1 ) * ( count_numbers ( k , n - 1 , 0 ) + count_numbers ( k , n - 1 , 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return count_numbers ( k , n - 1 , 1 ) NEW_LINE DEDENT DEDENT
Hyp: 
def count_numbers ( k , n , flag ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT if ( flag ) : NEW_LINE INDENT return ( k - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT if ( flag ) : NEW_LINE INDENT return ( k - 1 ) * ( count_numbers ( k , n - 1 , false ) + count_numbers ( k , n - 1 , true ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return count_numbers ( k , n - 1 , true ) NEW_LINE DEDENT DEDENT

BLEU: 92.51
Edit Sim: 13


Src: 
int countPairs ( int [ ] arr1 , int [ ] arr2 , int m , int n , int x ) { int count = 0 ; for ( int i = 0 ; i < m ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( ( arr1 [ i ] + arr2 [ j ] ) == x ) count ++ ; return count ; }
Ref: 
def countPairs ( arr1 , arr2 , m , n , x ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if arr1 [ i ] + arr2 [ j ] == x : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
Hyp: 
def countPairs ( arr1 , arr2 , m , n , x ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( ( arr1 [ i ] + arr2 [ j ] ) == x ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT

BLEU: 84.2
Edit Sim: 17


Src: 
int countOfBase ( int N ) { int count = 0 ; for ( int i = 2 ; i <= N ; ++ i ) { int highestPower = ( int ) ( Math . log ( N ) / Math . log ( i ) ) ; int firstDigit = N / ( int ) Math . pow ( i , highestPower ) ; if ( firstDigit == 1 ) { ++ count ; } } return count ; }
Ref: 
def countOfBase ( N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT highestPower = int ( math . log ( N ) / math . log ( i ) ) NEW_LINE firstDigit = int ( N / int ( math . pow ( i , highestPower ) ) ) NEW_LINE if ( firstDigit == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
Hyp: 
def countOfBase ( N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT highestPower = int ( math . log2 ( N ) / math . log ( i ) ) NEW_LINE firstDigit = N // pow ( i , highestPower ) NEW_LINE if ( firstDigit == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT

BLEU: 81.87
Edit Sim: 24


Src: 
void longestSubsequence ( int arr [ ] , int N ) { int count = 1 ; for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] != arr [ i - 1 ] ) { count ++ ; } } System . out . println ( count ) ; }
Ref: 
def longestSubsequence ( arr , N ) : NEW_LINE INDENT count = 1 NEW_LINE for i in range ( 1 , N , 1 ) : NEW_LINE INDENT if ( arr [ i ] != arr [ i - 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT
Hyp: 
def longestSubsequence ( arr , N ) : NEW_LINE INDENT count = 1 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT if ( arr [ i ] != arr [ i - 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT

BLEU: 93.71
Edit Sim: 4


Src: 
int countOddSum ( int ar [ ] , int n ) { int result = 0 ; for ( int i = 0 ; i <= n - 1 ; i ++ ) { int val = 0 ; for ( int j = i ; j <= n - 1 ; j ++ ) { val = val + ar [ j ] ; if ( val % 2 != 0 ) result ++ ; } } return ( result ) ; }
Ref: 
def countOddSum ( ar , n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT val = 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT val = val + ar [ j ] NEW_LINE if ( val % 2 != 0 ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT return ( result ) NEW_LINE DEDENT
Hyp: 
def countOddSum ( ar , n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT val = 0 NEW_LINE for j in range ( i , n - 1 ) : NEW_LINE INDENT val = val + ar [ j ] NEW_LINE if ( val % 2 != 0 ) : NEW_LINE INDENT result = result + 1 NEW_LINE DEDENT DEDENT DEDENT return ( result ) NEW_LINE DEDENT

BLEU: 85.17
Edit Sim: 18


Src: 
int turnOnK ( int n , int k ) { if ( k <= 0 ) return n ; return ( n | ( 1 << ( k - 1 ) ) ) ; }
Ref: 
def turnOnK ( n , k ) : NEW_LINE INDENT if ( k <= 0 ) : NEW_LINE INDENT return n NEW_LINE DEDENT return ( n | ( 1 << ( k - 1 ) ) ) NEW_LINE DEDENT
Hyp: 
def turnOnK ( n , k ) : NEW_LINE INDENT if ( k <= 0 ) : NEW_LINE INDENT return n NEW_LINE DEDENT return ( n | ( 1 << ( k - 1 ) ) ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int sumOfFactors ( int N ) { int ans = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { int first = i ; int last = ( N / i ) * i ; int factors = ( last - first ) / i + 1 ; int totalContribution = ( ( ( factors ) * ( factors + 1 ) ) / 2 ) * i ; ans += totalContribution ; } return ans ; }
Ref: 
def sumOfFactors ( N ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT first = i NEW_LINE last = ( N // i ) * i NEW_LINE factors = ( last - first ) // i + 1 NEW_LINE totalContribution = ( ( ( factors * ( factors + 1 ) ) // 2 ) * i ) NEW_LINE ans += totalContribution NEW_LINE DEDENT return ans NEW_LINE DEDENT
Hyp: 
def sumOfFactors ( N ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT first = i NEW_LINE last = ( N // i ) * i NEW_LINE factors = ( last - first ) // i + 1 NEW_LINE totalContribution = ( ( factors ) * ( factors + 1 ) ) // 2 NEW_LINE ans += totalContribution NEW_LINE DEDENT return ans NEW_LINE DEDENT

BLEU: 90.15
Edit Sim: 12


Src: 
boolean checkPandigital ( int b , String n ) { if ( n . length ( ) < b ) return false ; boolean hash [ ] = new boolean [ b ] ; Arrays . fill ( hash , false ) ; for ( int i = 0 ; i < n . length ( ) ; i ++ ) { if ( n . charAt ( i ) >= '0' && n . charAt ( i ) <= '9' ) hash [ n . charAt ( i ) - '0' ] = true ; else if ( n . charAt ( i ) - ' A ' <= b - 11 ) hash [ n . charAt ( i ) - ' A ' + 10 ] = true ; } for ( int i = 0 ; i < b ; i ++ ) if ( hash [ i ] == false ) return false ; return true ; }
Ref: 
def checkPandigital ( b , n ) : NEW_LINE INDENT if ( len ( n ) < b ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT hash = [ 0 ] * b ; NEW_LINE for i in range ( len ( n ) ) : NEW_LINE INDENT if ( n [ i ] >= '0' and n [ i ] <= '9' ) : NEW_LINE INDENT hash [ ord ( n [ i ] ) - ord ( '0' ) ] = 1 ; NEW_LINE DEDENT elif ( ord ( n [ i ] ) - ord ( ' A ' ) <= b - 11 ) : NEW_LINE INDENT hash [ ord ( n [ i ] ) - ord ( ' A ' ) + 10 ] = 1 ; NEW_LINE DEDENT DEDENT for i in range ( b ) : NEW_LINE INDENT if ( hash [ i ] == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT DEDENT return 1 ; NEW_LINE DEDENT b = 13 ; NEW_LINE n = "1298450376ABC " ; NEW_LINE if ( checkPandigital ( b , n ) ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT
Hyp: 
def checkPandigital ( b , n ) : NEW_LINE INDENT if ( len ( n ) < b ) : NEW_LINE INDENT return False NEW_LINE DEDENT hash = [ 0 ] * b NEW_LINE for i in range ( b ) : NEW_LINE INDENT if ( n [ i ] >= '0' and n [ i ] <= '9' ) : NEW_LINE INDENT hash [ n [ i ] - '0' ] = True NEW_LINE DEDENT elif ( n [ i ] - ' A ' <= b - 11 ) : NEW_LINE INDENT hash [ n [ i ] - ' A ' + 10 ] = True NEW_LINE DEDENT DEDENT for i in range ( 0 , b ) : NEW_LINE INDENT if ( hash [ i ] == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT

BLEU: 45.69
Edit Sim: 287


Src: 
boolean validQuadruple ( int arr [ ] , int n ) { if ( n >= MAX ) return true ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) for ( int k = j + 1 ; k < n ; k ++ ) for ( int l = k + 1 ; l < n ; l ++ ) { if ( ( arr [ i ] ^ arr [ j ] ^ arr [ k ] ^ arr [ l ] ) == 0 ) { return true ; } } return false ; }
Ref: 
def validQuadruple ( arr , n ) : NEW_LINE INDENT if ( n >= MAX ) : NEW_LINE INDENT return True NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT for l in range ( k + 1 , n ) : NEW_LINE INDENT if ( ( arr [ i ] ^ arr [ j ] ^ arr [ k ] ^ arr [ l ] ) == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return False NEW_LINE DEDENT arr = [ 1 , 0 , 2 , 3 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE if ( validQuadruple ( arr , n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
Hyp: 
def validQuadruple ( arr , n ) : NEW_LINE INDENT if ( n >= MAX ) : NEW_LINE INDENT return True NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n , 1 ) : NEW_LINE INDENT for k in range ( j + 1 , n , 1 ) : NEW_LINE INDENT for l in range ( k + 1 , n , 1 ) : NEW_LINE INDENT if ( ( arr [ i ] ^ arr [ j ] ^ arr [ k ] ^ arr [ l ] ) == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT

BLEU: 61.11
Edit Sim: 230


Src: 
void printCombination ( int n ) { System . out . print ( 1 + " ▁ " ) ; if ( ( n - 2 ) % 3 == 0 ) System . out . print ( 2 + " ▁ " + ( n - 3 ) ) ; else System . out . print ( 1 + " ▁ " + ( n - 2 ) ) ; }
Ref: 
def printCombination ( n ) : NEW_LINE INDENT print ( "1 ▁ " , end = " " ) ; NEW_LINE if ( ( n - 2 ) % 3 == 0 ) : NEW_LINE INDENT print ( "2" , n - 3 , end = " " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( "1" , ( n - 2 ) , end = " " ) ; NEW_LINE DEDENT DEDENT
Hyp: 
def printCombination ( n ) : NEW_LINE INDENT print ( 1 , end = " ▁ " ) NEW_LINE if ( ( n - 2 ) % 3 == 0 ) : NEW_LINE INDENT print ( 2 , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 1 , end = " ▁ " ) NEW_LINE DEDENT DEDENT

BLEU: 57.06
Edit Sim: 38


Src: 
int getPositionCount ( int a [ ] , int n ) { int count = 1 ; int min = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] <= min ) { min = a [ i ] ; count ++ ; } } return count ; }
Ref: 
def getPositionCount ( a , n ) : NEW_LINE INDENT count = 1 ; NEW_LINE min = a [ 0 ] ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( a [ i ] <= min ) : NEW_LINE INDENT min = a [ i ] ; NEW_LINE count += 1 ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT
Hyp: 
def getPositionCount ( a , n ) : NEW_LINE INDENT count = 1 NEW_LINE min = a [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( a [ i ] <= min ) : NEW_LINE INDENT min = a [ i ] NEW_LINE count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT

BLEU: 80.83
Edit Sim: 10


Src: 
int maxDifference ( int arr [ ] , int N , int k ) { int M , S = 0 , S1 = 0 , max_difference = 0 ; for ( int i = 0 ; i < N ; i ++ ) S += arr [ i ] ; int temp ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( arr [ i ] < arr [ j ] ) { temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; } } } M = Math . max ( k , N - k ) ; for ( int i = 0 ; i < M ; i ++ ) S1 += arr [ i ] ; max_difference = S1 - ( S - S1 ) ; return max_difference ; }
Ref: 
def maxDifference ( arr , N , k ) : NEW_LINE INDENT S = 0 NEW_LINE S1 = 0 NEW_LINE max_difference = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT S += arr [ i ] NEW_LINE DEDENT arr . sort ( reverse = True ) NEW_LINE M = max ( k , N - k ) NEW_LINE for i in range ( M ) : NEW_LINE INDENT S1 += arr [ i ] NEW_LINE DEDENT max_difference = S1 - ( S - S1 ) NEW_LINE return max_difference NEW_LINE DEDENT
Hyp: 
def maxDifference ( arr , N , k ) : NEW_LINE INDENT S = 0 NEW_LINE S1 = 0 NEW_LINE max_difference = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT S += arr [ i ] NEW_LINE DEDENT temp = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT if ( arr [ i ] < arr [ j ] ) : NEW_LINE INDENT temp = arr [ i ] NEW_LINE arr [ i ] = arr [ j ] NEW_LINE arr [ j ] = temp NEW_LINE DEDENT DEDENT DEDENT M = max ( k , N - k ) NEW_LINE for i in range ( M ) : NEW_LINE INDENT S1 += arr [ i ] NEW_LINE DEDENT max_difference = S1 - ( S - S1 ) NEW_LINE return max_difference NEW_LINE DEDENT

BLEU: 54.47
Edit Sim: 228


Src: 
int addOne ( int x ) { int m = 1 ; while ( ( int ) ( x & m ) >= 1 ) { x = x ^ m ; m <<= 1 ; } x = x ^ m ; return x ; }
Ref: 
def addOne ( x ) : NEW_LINE INDENT m = 1 ; NEW_LINE while ( x & m ) : NEW_LINE INDENT x = x ^ m NEW_LINE m <<= 1 NEW_LINE DEDENT x = x ^ m NEW_LINE return x NEW_LINE DEDENT
Hyp: 
def addOne ( x ) : NEW_LINE INDENT m = 1 NEW_LINE while ( ( x & m ) >= 1 ) : NEW_LINE INDENT x = x ^ m NEW_LINE m <<= 1 NEW_LINE DEDENT x = x ^ m NEW_LINE return x NEW_LINE DEDENT

BLEU: 84.21
Edit Sim: 11


Src: 
boolean findPair ( int a [ ] , int n , int z ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( i != j && a [ i ] + a [ j ] == z ) return true ; return false ; }
Ref: 
def findPair ( a , n , z ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( i != j and a [ i ] + a [ j ] == z ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT a = [ 1 , - 2 , 1 , 0 , 5 ] NEW_LINE z = 0 NEW_LINE n = len ( a ) NEW_LINE if ( findPair ( a , n , z ) ) : NEW_LINE INDENT print ( " True " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " False " ) NEW_LINE DEDENT
Hyp: 
def findPair ( a , n , z ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT if ( i != j and a [ i ] + a [ j ] == z ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT

BLEU: 39.64
Edit Sim: 225


Src: 
void findTriplets ( int arr [ ] , int n , int sum ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { HashSet < Integer > s = new HashSet < > ( ) ; for ( int j = i + 1 ; j < n ; j ++ ) { int x = sum - ( arr [ i ] + arr [ j ] ) ; if ( s . contains ( x ) ) System . out . printf ( "%d %d %dNEW_LINE", x, arr[i], arr[j]); else s . add ( arr [ j ] ) ; } } }
Ref: 
def findTriplets ( arr , n , Sum ) : NEW_LINE INDENT for i in range ( n - 1 ) : NEW_LINE INDENT s = dict ( ) NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT x = Sum - ( arr [ i ] + arr [ j ] ) NEW_LINE if x in s . keys ( ) : NEW_LINE INDENT print ( x , arr [ i ] , arr [ j ] ) NEW_LINE DEDENT else : NEW_LINE INDENT s [ arr [ j ] ] = 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT
Hyp: 
def findTriplets ( arr , n , sum ) : NEW_LINE INDENT for i in range ( n - 1 ) : NEW_LINE INDENT s = set ( ) NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT x = sum - ( arr [ i ] + arr [ j ] ) NEW_LINE if x in s : NEW_LINE INDENT print ( "%d %d %d " , x , arr [ i ] , arr [ j ] ) NEW_LINE DEDENT else : NEW_LINE INDENT s . add ( arr [ j ] ) NEW_LINE DEDENT DEDENT DEDENT

BLEU: 78.85
Edit Sim: 48


Src: 
boolean isOsiris ( int n ) { int a = n % 10 ; int b = ( n / 10 ) % 10 ; int c = n / 100 ; int digit_sum = a + b + c ; if ( n == ( 2 * ( digit_sum ) * 11 ) ) { return true ; } return false ; }
Ref: 
def isOsiris ( n ) : NEW_LINE INDENT a = n % 10 NEW_LINE b = ( n // 10 ) % 10 NEW_LINE c = n // 100 NEW_LINE digit_sum = a + b + c NEW_LINE if ( n == ( 2 * ( digit_sum ) * 11 ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
Hyp: 
def isOsiris ( n ) : NEW_LINE INDENT a = n % 10 NEW_LINE b = ( n / 10 ) % 10 NEW_LINE c = n / 100 NEW_LINE digit_sum = a + b + c NEW_LINE if ( n == ( 2 * ( digit_sum ) * 11 ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT

BLEU: 91.86
Edit Sim: 2


Src: 
void splitArr ( int arr [ ] , int n , int k ) { for ( int i = 0 ; i < k ; i ++ ) { int x = arr [ 0 ] ; for ( int j = 0 ; j < n - 1 ; ++ j ) arr [ j ] = arr [ j + 1 ] ; arr [ n - 1 ] = x ; } }
Ref: 
def splitArr ( arr , n , k ) : NEW_LINE INDENT for i in range ( 0 , k ) : NEW_LINE INDENT x = arr [ 0 ] NEW_LINE for j in range ( 0 , n - 1 ) : NEW_LINE INDENT arr [ j ] = arr [ j + 1 ] NEW_LINE DEDENT arr [ n - 1 ] = x NEW_LINE DEDENT DEDENT arr = [ 12 , 10 , 5 , 6 , 52 , 36 ] NEW_LINE n = len ( arr ) NEW_LINE position = 2 NEW_LINE splitArr ( arr , n , position ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT
Hyp: 
def splitArr ( arr , n , k ) : NEW_LINE INDENT for i in range ( k ) : NEW_LINE INDENT x = arr [ 0 ] NEW_LINE for j in range ( n - 1 ) : NEW_LINE INDENT arr [ j ] = arr [ j + 1 ] NEW_LINE DEDENT arr [ n - 1 ] = x NEW_LINE DEDENT DEDENT

BLEU: 33.97
Edit Sim: 234


Src: 
void findIntersection ( int intervals [ ] [ ] , int N ) { int l = intervals [ 0 ] [ 0 ] ; int r = intervals [ 0 ] [ 1 ] ; for ( int i = 1 ; i < N ; i ++ ) { if ( intervals [ i ] [ 0 ] > r intervals [ i ] [ 1 ] < l ) { System . out . println ( - 1 ) ; return ; } else { l = Math . max ( l , intervals [ i ] [ 0 ] ) ; r = Math . min ( r , intervals [ i ] [ 1 ] ) ; } } System . out . println ( " [ " + l + " , ▁ " + r + " ] " ) ; }
Ref: 
def findIntersection ( intervals , N ) : NEW_LINE INDENT l = intervals [ 0 ] [ 0 ] NEW_LINE r = intervals [ 0 ] [ 1 ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT if ( intervals [ i ] [ 0 ] > r or intervals [ i ] [ 1 ] < l ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT l = max ( l , intervals [ i ] [ 0 ] ) NEW_LINE r = min ( r , intervals [ i ] [ 1 ] ) NEW_LINE DEDENT DEDENT print ( " [ " , l , " , ▁ " , r , " ] " ) NEW_LINE DEDENT
Hyp: 
def findIntersection ( intervals , N ) : NEW_LINE INDENT l = intervals [ 0 ] [ 0 ] NEW_LINE r = intervals [ 0 ] [ 1 ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT if ( intervals [ i ] [ 0 ] > r or intervals [ i ] [ 1 ] < l ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE return NEW_LINE DEDENT else : NEW_LINE INDENT l = max ( l , intervals [ i ] [ 0 ] ) NEW_LINE r = min ( r , intervals [ i ] [ 1 ] ) NEW_LINE DEDENT DEDENT print ( " [ " , l , " , ▁ " , r , " ] " ) NEW_LINE DEDENT

BLEU: 97.92
Edit Sim: 16


Src: 
int longestSubstring ( String s ) { int cnt = 1 , maxi = 1 ; int n = s . length ( ) ; for ( int i = 1 ; i < n ; i ++ ) { if ( s . charAt ( i ) != s . charAt ( i - 1 ) ) cnt ++ ; else { maxi = Math . max ( cnt , maxi ) ; cnt = 1 ; } } maxi = Math . max ( cnt , maxi ) ; return maxi ; }
Ref: 
def longestSubstring ( s ) : NEW_LINE INDENT cnt = 1 ; NEW_LINE maxi = 1 ; NEW_LINE n = len ( s ) ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( s [ i ] != s [ i - 1 ] ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT maxi = max ( cnt , maxi ) ; NEW_LINE cnt = 1 ; NEW_LINE DEDENT DEDENT maxi = max ( cnt , maxi ) ; NEW_LINE return maxi ; NEW_LINE DEDENT
Hyp: 
def longestSubstring ( s ) : NEW_LINE INDENT cnt = 1 ; maxi = 1 ; NEW_LINE n = len ( s ) ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( s [ i ] != s [ i - 1 ] ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT maxi = max ( cnt , maxi ) ; NEW_LINE cnt = 1 ; NEW_LINE DEDENT DEDENT maxi = max ( cnt , maxi ) ; NEW_LINE return maxi ; NEW_LINE DEDENT

BLEU: 97.39
Edit Sim: 9


Src: 
int setKthBit ( int n , int k ) { return ( ( 1 << k ) n ) ; }
Ref: 
def setKthBit ( n , k ) : NEW_LINE INDENT return ( ( 1 << k ) n ) NEW_LINE DEDENT
Hyp: 
def setKthBit ( n , k ) : NEW_LINE INDENT return ( ( 1 << k ) n ) ; NEW_LINE DEDENT

BLEU: 89.22
Edit Sim: 2


Src: 
int countSubsequences ( int arr [ ] , int N ) { int odd = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( ( arr [ i ] & 1 ) % 2 == 1 ) odd ++ ; } return ( 1 << odd ) - 1 ; }
Ref: 
def countSubsequences ( arr ) : NEW_LINE INDENT odd = 0 NEW_LINE for x in arr : NEW_LINE INDENT if ( x & 1 ) : NEW_LINE INDENT odd = odd + 1 NEW_LINE DEDENT DEDENT return ( 1 << odd ) - 1 NEW_LINE DEDENT
Hyp: 
def countSubsequences ( arr , N ) : NEW_LINE INDENT odd = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] & 1 ) : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT DEDENT return ( 1 << odd ) - 1 NEW_LINE DEDENT

BLEU: 62.93
Edit Sim: 31


Src: 
void profitLoss ( int N , int M ) { if ( N == M ) System . out . print ( " No ▁ Profit ▁ nor ▁ Loss " ) ; else { float result = 0 ; result = ( float ) ( Math . abs ( N - M ) ) / M ; if ( N - M < 0 ) System . out . print ( " Loss ▁ = ▁ - " + result * 100 + " % " ) ; else System . out . print ( " Profit ▁ = ▁ " + result * 100 + " % " ) ; } }
Ref: 
def profitLoss ( N , M ) : NEW_LINE INDENT if ( N == M ) : NEW_LINE INDENT print ( " No ▁ Profit ▁ nor ▁ Loss " ) NEW_LINE DEDENT else : NEW_LINE INDENT result = 0.0 NEW_LINE result = float ( abs ( N - M ) ) / M NEW_LINE if ( N - M < 0 ) : NEW_LINE INDENT print ( " Loss ▁ = ▁ - " , ' { 0 : . 6 } ' . format ( result * 100 ) , " % " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Profit ▁ = ▁ " , ' { 0 : . 6 } ' . format ( result * 100 ) , " % " ) NEW_LINE DEDENT DEDENT DEDENT
Hyp: 
def profitLoss ( N , M ) : NEW_LINE INDENT if ( N == M ) : NEW_LINE INDENT print ( " No ▁ Profit ▁ nor ▁ Loss " ) NEW_LINE DEDENT else : NEW_LINE INDENT result = 0 NEW_LINE result = ( abs ( N - M ) ) / M NEW_LINE if ( N - M < 0 ) : NEW_LINE INDENT print ( " Loss ▁ = " , result * 100 , " % " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Profit ▁ = " , result * 100 , " % " ) NEW_LINE DEDENT DEDENT DEDENT

BLEU: 67.76
Edit Sim: 72


Src: 
int findNum ( int div [ ] , int rem [ ] , int N ) { int num = rem [ N - 1 ] ; for ( int i = N - 2 ; i >= 0 ; i -- ) { num = num * div [ i ] + rem [ i ] ; } return num ; }
Ref: 
def findNum ( div , rem , N ) : NEW_LINE INDENT num = rem [ N - 1 ] NEW_LINE i = N - 2 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT num = num * div [ i ] + rem [ i ] NEW_LINE i -= 1 NEW_LINE DEDENT return num NEW_LINE DEDENT
Hyp: 
def findNum ( div , rem , N ) : NEW_LINE INDENT num = rem [ N - 1 ] NEW_LINE i = N - 2 NEW_LINE while i >= 0 : NEW_LINE INDENT num = num * div [ i ] + rem [ i ] NEW_LINE DEDENT return num NEW_LINE DEDENT

BLEU: 82.63
Edit Sim: 20


Src: 
void anglequichord ( int z ) { System . out . println ( " The ▁ angle ▁ is ▁ " + z + " ▁ degrees " ) ; }
Ref: 
def anglequichord ( z ) : NEW_LINE INDENT print ( " The ▁ angle ▁ is ▁ " , z , " ▁ degrees " ) NEW_LINE DEDENT
Hyp: 
def anglequichord ( z ) : NEW_LINE INDENT print ( " The ▁ angle ▁ is " , z , " ▁ degrees " ) NEW_LINE DEDENT

BLEU: 90.62
Edit Sim: 2


Src: 
String check ( int k , int d0 , int d1 ) { int s = ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 + ( 8 * ( d0 + d1 ) ) % 10 + ( 6 * ( d0 + d1 ) ) % 10 ; int a = ( k - 3 ) % 4 ; int x = 0 ; switch ( a ) { case 0 : x = 0 ; break ; case 1 : x = ( 2 * ( d0 + d1 ) ) % 10 ; break ; case 2 : x = ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 ; break ; case 3 : x = ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 + ( 8 * ( d0 + d1 ) ) % 10 ; break ; } int sum = d0 + d1 + ( ( ( k - 3 ) / 4 ) * s + x ) ; if ( sum % 3 == 0 ) return " YES " ; return " NO " ; }
Ref: 
def check ( k , d0 , d1 ) : NEW_LINE INDENT s = ( ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 + ( 8 * ( d0 + d1 ) ) % 10 + ( 6 * ( d0 + d1 ) ) % 10 ) NEW_LINE a = ( k - 3 ) % 4 NEW_LINE if ( a == 0 ) : NEW_LINE INDENT x = 0 NEW_LINE DEDENT elif ( a == 1 ) : NEW_LINE INDENT x = ( 2 * ( d0 + d1 ) ) % 10 NEW_LINE DEDENT elif ( a == 2 ) : NEW_LINE INDENT x = ( ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 ) NEW_LINE DEDENT elif ( a == 3 ) : NEW_LINE INDENT x = ( ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 + ( 8 * ( d0 + d1 ) ) % 10 ) NEW_LINE DEDENT sum = d0 + d1 + ( ( k - 3 ) // 4 ) * s + x NEW_LINE if ( sum % 3 == 0 ) : NEW_LINE INDENT return " YES " NEW_LINE DEDENT else : NEW_LINE INDENT return " NO " NEW_LINE DEDENT DEDENT
Hyp: 
def check ( k , d0 , d1 ) : NEW_LINE INDENT s = ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 + ( 8 * ( d0 + d1 ) ) % 10 + ( 6 * ( d0 + d1 ) ) % 10 ; NEW_LINE a = ( k - 3 ) % 4 ; NEW_LINE x = 0 ; NEW_LINE switch ( a ) { NEW_LINE DEDENT case 0 : NEW_LINE INDENT x = 0 ; NEW_LINE break ; NEW_LINE DEDENT case 1 : NEW_LINE INDENT x = ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 + ( 8 * ( d0 + d1 ) ) % 10 ; NEW_LINE DEDENT DEDENT sum = d0 + d1 + ( ( ( k - 3 ) // 4 ) * s + x ) ; NEW_LINE if ( sum % 3 == 0 ) : NEW_LINE INDENT return " YES " ; NEW_LINE DEDENT return " NO " ; NEW_LINE DEDENT

BLEU: 60.07
Edit Sim: 220


Src: 
int sumOfDigit ( int n , int b ) { int unitDigit , sum = 0 ; while ( n > 0 ) { unitDigit = n % b ; sum += unitDigit ; n = n / b ; } return sum ; }
Ref: 
def sumOfDigit ( n , b ) : NEW_LINE INDENT unitDigit = 0 NEW_LINE sum = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT unitDigit = n % b NEW_LINE sum += unitDigit NEW_LINE n = n // b NEW_LINE DEDENT return sum NEW_LINE DEDENT
Hyp: 
def sumOfDigit ( n , b ) : NEW_LINE INDENT unitDigit , sum = 0 , 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT unitDigit = n % b NEW_LINE sum += unitDigit NEW_LINE n = n // b NEW_LINE DEDENT return sum NEW_LINE DEDENT

BLEU: 89.22
Edit Sim: 15


Src: 
double maxEdges ( double N ) { double edges = 0 ; edges = Math . floor ( ( N * N ) / 4 ) ; return edges ; }
Ref: 
def maxEdges ( N ) : NEW_LINE INDENT edges = 0 ; NEW_LINE edges = ( N * N ) // 4 ; NEW_LINE return edges ; NEW_LINE DEDENT
Hyp: 
def maxEdges ( N ) : NEW_LINE INDENT edges = 0 NEW_LINE edges = floor ( ( N * N ) / 4 ) NEW_LINE return edges NEW_LINE DEDENT

BLEU: 60.1
Edit Sim: 14


Src: 
int countNumbers ( int n ) { if ( n % 2 == 1 ) return 0 ; return ( 9 * ( int ) Math . pow ( 10 , n / 2 - 1 ) ) ; }
Ref: 
def countNumbers ( n ) : NEW_LINE INDENT if n % 2 == 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( 9 * pow ( 10 , n // 2 - 1 ) ) NEW_LINE DEDENT
Hyp: 
def countNumbers ( n ) : NEW_LINE INDENT if n % 2 == 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( 9 * pow ( 10 , n / 2 - 1 ) ) NEW_LINE DEDENT

BLEU: 93.18
Edit Sim: 1


Src: 
void factors ( int n , int i ) { if ( i <= n ) { if ( n % i == 0 ) { System . out . print ( i + " ▁ " ) ; } factors ( n , i + 1 ) ; } }
Ref: 
def factors ( n , i ) : NEW_LINE INDENT if ( i <= n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT print ( i , end = " ▁ " ) ; NEW_LINE DEDENT factors ( n , i + 1 ) ; NEW_LINE DEDENT DEDENT
Hyp: 
def factors ( n , i ) : NEW_LINE INDENT if ( i <= n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT factors ( n , i + 1 ) NEW_LINE DEDENT DEDENT

BLEU: 90.61
Edit Sim: 4


Src: 
boolean isDivisible ( int N ) { return ( N - 1 ) % 3 != 0 ; }
Ref: 
def isDivisible ( N ) : NEW_LINE INDENT return ( N - 1 ) % 3 != 0 NEW_LINE DEDENT
Hyp: 
def isDivisible ( N ) : NEW_LINE INDENT return ( N - 1 ) % 3 != 0 NEW_LINE DEDENT N = 65 NEW_LINE if ( isDivisible ( N ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT

BLEU: 36.4
Edit Sim: 149


Src: 
int eggDrop ( int n , int k ) { int dp [ ] [ ] = new int [ k + 1 ] [ n + 1 ] ; int x = 0 ; while ( dp [ x ] [ n ] < k ) { x ++ ; for ( int i = 1 ; i <= n ; i ++ ) dp [ x ] [ i ] = dp [ x - 1 ] [ i - 1 ] + dp [ x - 1 ] [ i ] + 1 ; } return x ; }
Ref: 
def eggDrop ( n , k ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( k + 1 ) ] NEW_LINE x = 0 ; NEW_LINE while ( dp [ x ] [ n ] < k ) : NEW_LINE INDENT x += 1 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT dp [ x ] [ i ] = dp [ x - 1 ] [ i - 1 ] + dp [ x - 1 ] [ i ] + 1 ; NEW_LINE DEDENT DEDENT return x ; NEW_LINE DEDENT
Hyp: 
def eggDrop ( n , k ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( k + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE x = 0 NEW_LINE while ( dp [ x ] [ n ] < k ) : NEW_LINE INDENT x += 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT dp [ x ] [ i ] = dp [ x - 1 ] [ i - 1 ] + dp [ x - 1 ] [ i ] + 1 NEW_LINE DEDENT DEDENT return x NEW_LINE DEDENT

BLEU: 91.33
Edit Sim: 10


Src: 
int countPairs ( int arr [ ] , int k ) { Arrays . sort ( arr ) ; int pair = 0 ; int index = 0 ; while ( index < arr . length - 1 ) { if ( arr [ index + 1 ] - arr [ index ] <= k ) { pair += 1 ; index += 2 ; } else { index += 1 ; } } return pair ; }
Ref: 
def countPairs ( arr , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE pair = 0 NEW_LINE index = 0 NEW_LINE while ( index < len ( arr ) - 1 ) : NEW_LINE INDENT if arr [ index + 1 ] - arr [ index ] <= k : NEW_LINE INDENT pair += 1 NEW_LINE index += 2 NEW_LINE DEDENT else : NEW_LINE INDENT index += 1 NEW_LINE DEDENT DEDENT return pair NEW_LINE DEDENT
Hyp: 
def countPairs ( arr , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE pair = 0 NEW_LINE index = 0 NEW_LINE while ( index < len ( arr ) - 1 ) : NEW_LINE INDENT if ( arr [ index + 1 ] - arr [ index ] <= k ) : NEW_LINE INDENT pair += 1 NEW_LINE index += 2 NEW_LINE DEDENT else : NEW_LINE INDENT index += 1 NEW_LINE DEDENT DEDENT return pair NEW_LINE DEDENT

BLEU: 93.62
Edit Sim: 4


Src: 
void overflow ( int H , int r , int h , int N , int R ) { double tank_cap = 3.14 * r * r * H ; double water_vol = 3.14 * r * r * h ; double balls_vol = N * ( 4 / 3 ) * 3.14 * R * R * R ; double vol = water_vol + balls_vol ; if ( vol > tank_cap ) { System . out . println ( " Overflow " ) ; } else { System . out . println ( " Not ▁ in ▁ overflow ▁ state " ) ; } }
Ref: 
def overflow ( H , r , h , N , R ) : NEW_LINE INDENT tank_cap = 3.14 * r * r * H NEW_LINE water_vol = 3.14 * r * r * h NEW_LINE balls_vol = N * ( 4 / 3 ) * 3.14 * R * R * R NEW_LINE vol = water_vol + balls_vol NEW_LINE if vol > tank_cap : NEW_LINE INDENT print ( " Overflow " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ in ▁ overflow ▁ state " ) NEW_LINE DEDENT DEDENT
Hyp: 
def overflow ( H , r , h , N , R ) : NEW_LINE INDENT tank_cap = 3.14 * r * r * H NEW_LINE water_vol = 3.14 * r * r * h NEW_LINE balls_vol = N * ( 4 / 3 ) * 3.14 * R * R * R NEW_LINE vol = water_vol + balls_vol NEW_LINE if ( vol > tank_cap ) : NEW_LINE INDENT print ( " Overflow " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ in ▁ overflow ▁ state " ) NEW_LINE DEDENT DEDENT

BLEU: 94.71
Edit Sim: 4


Src: 
void printClosest ( int arr [ ] , int n , int x ) { int res_l = 0 , res_r = 0 ; int l = 0 , r = n - 1 , diff = Integer . MAX_VALUE ; while ( r > l ) { if ( Math . abs ( arr [ l ] + arr [ r ] - x ) < diff ) { res_l = l ; res_r = r ; diff = Math . abs ( arr [ l ] + arr [ r ] - x ) ; } if ( arr [ l ] + arr [ r ] > x ) r -- ; else l ++ ; } System . out . println ( " ▁ The ▁ closest ▁ pair ▁ is ▁ " + arr [ res_l ] + " ▁ and ▁ " + arr [ res_r ] ) ; }
Ref: 
def printClosest ( arr , n , x ) : NEW_LINE INDENT res_l , res_r = 0 , 0 NEW_LINE l , r , diff = 0 , n - 1 , MAX_VAL NEW_LINE while r > l : NEW_LINE INDENT if abs ( arr [ l ] + arr [ r ] - x ) < diff : NEW_LINE INDENT res_l = l NEW_LINE res_r = r NEW_LINE diff = abs ( arr [ l ] + arr [ r ] - x ) NEW_LINE DEDENT if arr [ l ] + arr [ r ] > x : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT l += 1 NEW_LINE DEDENT DEDENT print ( ' The ▁ closest ▁ pair ▁ is ▁ { } ▁ and ▁ { } ' . format ( arr [ res_l ] , arr [ res_r ] ) ) NEW_LINE DEDENT
Hyp: 
def printClosest ( arr , n , x ) : NEW_LINE INDENT res_l = 0 NEW_LINE res_r = 0 NEW_LINE l = n - 1 NEW_LINE diff = 10 ** 20 NEW_LINE while ( r > l ) : NEW_LINE INDENT if ( abs ( arr [ l ] + arr [ r ] - x ) < diff ) : NEW_LINE INDENT res_l = l NEW_LINE res_r = r NEW_LINE diff = abs ( arr [ l ] + arr [ r ] - x ) NEW_LINE DEDENT if ( arr [ l ] + arr [ r ] > x ) : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT l += 1 NEW_LINE DEDENT DEDENT print ( " ▁ The ▁ closest ▁ pair ▁ is ▁ " , arr [ res_l ] , " ▁ and ▁ " , arr [ res_r ] ) NEW_LINE DEDENT

BLEU: 72.53
Edit Sim: 90


Src: 
boolean Check_is_possible ( int l , int r , int k ) { int count = 0 ; for ( int i = l ; i <= r ; i ++ ) { if ( i % k == 0 ) { count ++ ; } } return ( count > 1 ) ; }
Ref: 
def Check_is_possible ( l , r , k ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT if ( i % k == 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT return ( count > 1 ) ; NEW_LINE DEDENT l = 4 ; NEW_LINE r = 12 ; NEW_LINE k = 5 ; NEW_LINE if ( Check_is_possible ( l , r , k ) ) : NEW_LINE INDENT print ( " YES " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) ; NEW_LINE DEDENT
Hyp: 
def Check_is_possible ( l , r , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT if ( i % k == 0 ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT return ( count > 1 ) NEW_LINE DEDENT

BLEU: 34.49
Edit Sim: 214


Src: 
void findAngle ( double M1 , double M2 ) { double angle = Math . abs ( ( M2 - M1 ) / ( 1 + M1 * M2 ) ) ; double ret = Math . atan ( angle ) ; double val = ( ret * 180 ) / PI ; System . out . println ( val ) ; }
Ref: 
def findAngle ( M1 , M2 ) : NEW_LINE INDENT PI = 3.14159265 NEW_LINE angle = abs ( ( M2 - M1 ) / ( 1 + M1 * M2 ) ) NEW_LINE ret = atan ( angle ) NEW_LINE val = ( ret * 180 ) / PI NEW_LINE print ( round ( val , 4 ) ) NEW_LINE DEDENT
Hyp: 
def findAngle ( M1 , M2 ) : NEW_LINE INDENT angle = abs ( ( M2 - M1 ) / ( 1 + M1 * M2 ) ) NEW_LINE ret = math . atan ( angle ) NEW_LINE val = ( ret * 180 ) / PI NEW_LINE print ( val ) NEW_LINE DEDENT

BLEU: 75.93
Edit Sim: 46


Src: 
int find_maximum_value ( int a [ ] , int n ) { int sum = 0 ; int minimum = Integer . MAX_VALUE ; int pos = 0 , neg = 0 ; for ( int i = 0 ; i < n ; i ++ ) { minimum = Math . min ( minimum , Math . abs ( a [ i ] ) ) ; sum += Math . abs ( a [ i ] ) ; if ( a [ i ] >= 0 ) pos += 1 ; else neg += 1 ; } if ( pos > 0 && neg > 0 ) return sum ; return ( sum - 2 * minimum ) ; }
Ref: 
def find_maximum_value ( a , n ) : NEW_LINE INDENT sum = 0 NEW_LINE minimum = 10 ** 9 NEW_LINE pos = 0 NEW_LINE neg = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT minimum = min ( minimum , abs ( a [ i ] ) ) NEW_LINE sum += abs ( a [ i ] ) NEW_LINE if ( a [ i ] >= 0 ) : NEW_LINE INDENT pos += 1 NEW_LINE DEDENT else : NEW_LINE INDENT neg += 1 NEW_LINE DEDENT DEDENT if ( pos > 0 and neg > 0 ) : NEW_LINE INDENT return sum NEW_LINE DEDENT return ( sum - 2 * minimum ) NEW_LINE DEDENT
Hyp: 
def find_maximum_value ( a , n ) : NEW_LINE INDENT sum = 0 NEW_LINE minimum = sys . maxsize NEW_LINE pos = 0 ; neg = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT minimum = min ( minimum , abs ( a [ i ] ) ) NEW_LINE sum += abs ( a [ i ] ) NEW_LINE if ( a [ i ] >= 0 ) : NEW_LINE INDENT pos += 1 NEW_LINE DEDENT else : NEW_LINE INDENT neg += 1 NEW_LINE DEDENT DEDENT if ( pos > 0 and neg > 0 ) : NEW_LINE INDENT return sum NEW_LINE DEDENT return ( sum - 2 * minimum ) NEW_LINE DEDENT

BLEU: 93.95
Edit Sim: 20


Src: 
double find_probability ( double p , double q , double r , double s ) { double t = ( 1 - p / q ) * ( 1 - r / s ) ; double ans = ( p / q ) / ( 1 - t ) ; return ans ; }
Ref: 
def find_probability ( p , q , r , s ) : NEW_LINE INDENT t = ( 1 - p / q ) * ( 1 - r / s ) NEW_LINE ans = ( p / q ) / ( 1 - t ) ; NEW_LINE return round ( ans , 9 ) NEW_LINE DEDENT
Hyp: 
def find_probability ( p , q , r , s ) : NEW_LINE INDENT t = ( 1 - p / q ) * ( 1 - r / s ) NEW_LINE ans = ( p / q ) / ( 1 - t ) NEW_LINE return ans NEW_LINE DEDENT

BLEU: 83.14
Edit Sim: 16


Src: 
int totalFlips ( String A , String B , String C , int N ) { int count = 0 ; for ( int i = 0 ; i < N ; ++ i ) { if ( A . charAt ( i ) == B . charAt ( i ) && C . charAt ( i ) == '1' ) ++ count ; else if ( A . charAt ( i ) != B . charAt ( i ) && C . charAt ( i ) == '0' ) ++ count ; } return count ; }
Ref: 
def totalFlips ( A , B , C , N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if A [ i ] == B [ i ] and C [ i ] == '1' : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT elif A [ i ] != B [ i ] and C [ i ] == '0' : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
Hyp: 
def totalFlips ( A , B , C , N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( A [ i ] == B [ i ] and C [ i ] == '1' ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT elif ( A [ i ] != B [ i ] and C [ i ] == '0' ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT

BLEU: 82.17
Edit Sim: 26


Src: 
int getMinSteps ( int n , int jump ) { int quotient = n / jump ; int remainder = n % jump ; int steps = quotient + remainder ; return steps ; }
Ref: 
def getMinSteps ( n , jump ) : NEW_LINE INDENT quotient = int ( n / jump ) NEW_LINE remainder = n % jump NEW_LINE steps = quotient + remainder NEW_LINE return steps NEW_LINE DEDENT
Hyp: 
def getMinSteps ( n , jump ) : NEW_LINE INDENT quotient = n // jump NEW_LINE remainder = n % jump NEW_LINE steps = quotient + remainder NEW_LINE return steps NEW_LINE DEDENT

BLEU: 79.09
Edit Sim: 8


Src: 
int countIntegralSolutions ( int n ) { int result = 0 ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= n - i ; j ++ ) for ( int k = 0 ; k <= ( n - i - j ) ; k ++ ) if ( i + j + k == n ) result ++ ; return result ; }
Ref: 
def countIntegralSolutions ( n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT for k in range ( n + 1 ) : NEW_LINE INDENT if i + j + k == n : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
Hyp: 
def countIntegralSolutions ( n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( n - i + 1 ) : NEW_LINE INDENT for k in range ( 0 , ( n - i - j ) + 1 ) : NEW_LINE INDENT if ( i + j + k == n ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT

BLEU: 76.95
Edit Sim: 31


Src: 
int minSum ( int ar [ ] , int n ) { if ( n <= 4 ) return Arrays . stream ( ar ) . min ( ) . getAsInt ( ) ; int [ ] sum = new int [ n ] ; sum [ 0 ] = ar [ 0 ] ; sum [ 1 ] = ar [ 1 ] ; sum [ 2 ] = ar [ 2 ] ; sum [ 3 ] = ar [ 3 ] ; for ( int i = 4 ; i < n ; i ++ ) sum [ i ] = ar [ i ] + Arrays . stream ( Arrays . copyOfRange ( sum , i - 4 , i ) ) . min ( ) . getAsInt ( ) ; return Arrays . stream ( Arrays . copyOfRange ( sum , n - 4 , n ) ) . min ( ) . getAsInt ( ) ; }
Ref: 
def minSum ( ar , n ) : NEW_LINE INDENT if ( n <= 4 ) : NEW_LINE INDENT return min ( ar ) NEW_LINE DEDENT sum = [ 0 for i in range ( n ) ] NEW_LINE sum [ 0 ] = ar [ 0 ] NEW_LINE sum [ 1 ] = ar [ 1 ] NEW_LINE sum [ 2 ] = ar [ 2 ] NEW_LINE sum [ 3 ] = ar [ 3 ] NEW_LINE for i in range ( 4 , n ) : NEW_LINE INDENT sum [ i ] = ar [ i ] + min ( sum [ i - 4 : i ] ) NEW_LINE DEDENT return min ( sum [ n - 4 : n ] ) NEW_LINE DEDENT
Hyp: 
def minSum ( ar , n ) : NEW_LINE INDENT if ( n <= 4 ) : NEW_LINE INDENT return min ( ar ) ; NEW_LINE DEDENT sum = [ 0 ] * n ; NEW_LINE sum [ 0 ] = ar [ 0 ] ; NEW_LINE sum [ 1 ] = ar [ 1 ] ; NEW_LINE sum [ 2 ] = ar [ 2 ] ; NEW_LINE sum [ 3 ] = ar [ 3 ] ; NEW_LINE for i in range ( 4 , n ) : NEW_LINE INDENT sum [ i ] = ar [ i ] + stream ( sum , i - 4 , i ) ; NEW_LINE DEDENT return min ( sum ) ; NEW_LINE DEDENT

BLEU: 71.56
Edit Sim: 52


Src: 
int search ( int arr [ ] , int l , int h , int key ) { if ( l > h ) return - 1 ; int mid = ( l + h ) / 2 ; if ( arr [ mid ] == key ) return mid ; if ( arr [ l ] <= arr [ mid ] ) { if ( key >= arr [ l ] && key <= arr [ mid ] ) return search ( arr , l , mid - 1 , key ) ; return search ( arr , mid + 1 , h , key ) ; } if ( key >= arr [ mid ] && key <= arr [ h ] ) return search ( arr , mid + 1 , h , key ) ; return search ( arr , l , mid - 1 , key ) ; }
Ref: 
def search ( arr , l , h , key ) : NEW_LINE INDENT if l > h : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = ( l + h ) // 2 NEW_LINE if arr [ mid ] == key : NEW_LINE INDENT return mid NEW_LINE DEDENT if arr [ l ] <= arr [ mid ] : NEW_LINE INDENT if key >= arr [ l ] and key <= arr [ mid ] : NEW_LINE INDENT return search ( arr , l , mid - 1 , key ) NEW_LINE DEDENT return search ( arr , mid + 1 , h , key ) NEW_LINE DEDENT if key >= arr [ mid ] and key <= arr [ h ] : NEW_LINE INDENT return search ( a , mid + 1 , h , key ) NEW_LINE DEDENT return search ( arr , l , mid - 1 , key ) NEW_LINE DEDENT arr = [ 4 , 5 , 6 , 7 , 8 , 9 , 1 , 2 , 3 ] NEW_LINE key = 6 NEW_LINE i = search ( arr , 0 , len ( arr ) - 1 , key ) NEW_LINE if i != - 1 : NEW_LINE INDENT print ( " Index : ▁ % ▁ d " % i ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Key ▁ not ▁ found " ) NEW_LINE DEDENT
Hyp: 
def search ( arr , l , h , key ) : NEW_LINE INDENT if ( l > h ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = ( l + h ) // 2 NEW_LINE if arr [ mid ] == key : NEW_LINE INDENT return mid NEW_LINE DEDENT if arr [ l ] <= arr [ mid ] : NEW_LINE INDENT if ( key >= arr [ l ] and key <= arr [ mid ] ) : NEW_LINE INDENT return search ( arr , l , mid - 1 , key ) NEW_LINE DEDENT return search ( arr , mid + 1 , h , key ) NEW_LINE DEDENT if ( key >= arr [ mid ] and key <= arr [ h ] ) : NEW_LINE INDENT return search ( arr , mid + 1 , h , key ) NEW_LINE DEDENT return search ( arr , l , mid - 1 , key ) NEW_LINE DEDENT

BLEU: 56.63
Edit Sim: 291


Src: 
void FlipBits ( int n ) { for ( int bit = 0 ; bit < 32 ; bit ++ ) { if ( ( n >> bit ) % 2 > 0 ) { n = n ^ ( 1 << bit ) ; break ; } } System . out . print ( " The ▁ number ▁ after ▁ unsetting ▁ the " ) ; System . out . print ( " ▁ rightmost ▁ set ▁ bit ▁ " + n ) ; }
Ref: 
def FlipBits ( n ) : NEW_LINE INDENT for bit in range ( 32 ) : NEW_LINE INDENT if ( ( n >> bit ) & 1 ) : NEW_LINE INDENT n = n ^ ( 1 << bit ) NEW_LINE break NEW_LINE DEDENT DEDENT print ( " The ▁ number ▁ after ▁ unsetting ▁ the " , end = " ▁ " ) NEW_LINE print ( " rightmost ▁ set ▁ bit " , n ) NEW_LINE DEDENT
Hyp: 
def FlipBits ( n ) : NEW_LINE INDENT bit = 0 NEW_LINE while bit < 32 : NEW_LINE INDENT if ( ( n >> bit ) % 2 > 0 ) : NEW_LINE INDENT n = n ^ ( 1 << bit ) NEW_LINE break NEW_LINE DEDENT DEDENT print ( " The ▁ number ▁ after ▁ unsetting ▁ the " ) NEW_LINE print ( " ▁ rightmost ▁ set ▁ bit ▁ " , bit ) NEW_LINE DEDENT

BLEU: 70.86
Edit Sim: 52


Src: 
int getProduct ( int a [ ] , int n ) { int p = 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { p *= Math . abs ( a [ i ] - a [ j ] ) ; } } return p ; }
Ref: 
def getProduct ( a , n ) : NEW_LINE INDENT p = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT p *= abs ( a [ i ] - a [ j ] ) NEW_LINE DEDENT DEDENT return p NEW_LINE DEDENT
Hyp: 
def getProduct ( a , n ) : NEW_LINE INDENT p = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT p *= abs ( a [ i ] - a [ j ] ) NEW_LINE DEDENT DEDENT return p NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int findSum ( int n , int k ) { int val = ( k / ( n - 1 ) ) * n ; int rem = k % ( n - 1 ) ; if ( rem == 0 ) { val = val - 1 ; } else { val = val + rem ; } int sum = ( val * ( val + 1 ) ) / 2 ; int x = k / ( n - 1 ) ; int sum_of_multiples = ( x * ( x + 1 ) * n ) / 2 ; sum -= sum_of_multiples ; return sum ; }
Ref: 
def findSum ( n , k ) : NEW_LINE INDENT val = ( k // ( n - 1 ) ) * n ; NEW_LINE rem = k % ( n - 1 ) ; NEW_LINE if ( rem == 0 ) : NEW_LINE INDENT val = val - 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT val = val + rem ; NEW_LINE DEDENT sum = ( val * ( val + 1 ) ) // 2 ; NEW_LINE x = k // ( n - 1 ) ; NEW_LINE sum_of_multiples = ( x * ( x + 1 ) * n ) // 2 ; NEW_LINE sum -= sum_of_multiples ; NEW_LINE return sum ; NEW_LINE DEDENT
Hyp: 
def findSum ( n , k ) : NEW_LINE INDENT val = ( k // ( n - 1 ) ) * n NEW_LINE rem = k % ( n - 1 ) NEW_LINE if ( rem == 0 ) : NEW_LINE INDENT val = val - 1 NEW_LINE DEDENT else : NEW_LINE INDENT val = val + rem NEW_LINE DEDENT sum = ( val * ( val + 1 ) ) // 2 NEW_LINE x = k // ( n - 1 ) NEW_LINE sum_of_multiples = ( x * ( x + 1 ) * n ) // 2 NEW_LINE sum -= sum_of_multiples NEW_LINE return sum NEW_LINE DEDENT

BLEU: 80.31
Edit Sim: 18


Src: 
void reorder ( ) { for ( int i = 0 ; i < arr . length ; i ++ ) { while ( index [ i ] != i ) { int oldTargetI = index [ index [ i ] ] ; char oldTargetE = ( char ) arr [ index [ i ] ] ; arr [ index [ i ] ] = arr [ i ] ; index [ index [ i ] ] = index [ i ] ; index [ i ] = oldTargetI ; arr [ i ] = oldTargetE ; } } }
Ref: 
def reorder ( arr , index , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT while ( index [ i ] != i ) : NEW_LINE INDENT oldTargetI = index [ index [ i ] ] NEW_LINE oldTargetE = arr [ index [ i ] ] NEW_LINE arr [ index [ i ] ] = arr [ i ] NEW_LINE index [ index [ i ] ] = index [ i ] NEW_LINE index [ i ] = oldTargetI NEW_LINE arr [ i ] = oldTargetE NEW_LINE DEDENT DEDENT DEDENT arr = [ 50 , 40 , 70 , 60 , 90 ] NEW_LINE index = [ 3 , 0 , 4 , 1 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE reorder ( arr , index , n ) NEW_LINE print ( " Reordered ▁ array ▁ is : " ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT print ( " Modified Index array is : " ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( index [ i ] , end = " ▁ " ) NEW_LINE DEDENT
Hyp: 
def reorder ( ) : NEW_LINE INDENT for i in range ( len ( arr ) ) : NEW_LINE INDENT while ( index [ i ] != i ) : NEW_LINE INDENT oldTargetI = index [ index [ i ] ] NEW_LINE oldTargetE = arr [ index [ i ] ] NEW_LINE arr [ index [ i ] ] = arr [ i ] NEW_LINE index [ i ] ] = index [ i ] NEW_LINE index [ i ] = oldTargetI NEW_LINE arr [ i ] = oldTargetE NEW_LINE DEDENT DEDENT DEDENT

BLEU: 24.18
Edit Sim: 461


Src: 
void NthTerm ( int n ) { int numerator = ( ( int ) Math . pow ( n , 2 ) ) - 1 ; int denomeanator = 2 * n - 3 ; System . out . println ( numerator + " / " + denomeanator ) ; }
Ref: 
def Nthterm ( n ) : NEW_LINE INDENT numerator = n ** 2 - 1 NEW_LINE denomenator = 2 * n - 3 NEW_LINE print ( numerator , " / " , denomenator ) NEW_LINE DEDENT
Hyp: 
def NthTerm ( n ) : NEW_LINE INDENT numerator = ( pow ( n , 2 ) ) - 1 NEW_LINE denomeanator = 2 * n - 3 NEW_LINE print ( numerator , " / " , denomeanator ) NEW_LINE DEDENT

BLEU: 59.64
Edit Sim: 17


Src: 
long findDigits ( int n ) { if ( n < 0 ) return 0 ; if ( n <= 1 ) return 1 ; double x = ( n * Math . log10 ( n / M_E ) + Math . log10 ( 2 * M_PI * n ) / 2.0 ) ; return ( long ) Math . floor ( x ) + 1 ; }
Ref: 
def findDigits ( n ) : NEW_LINE INDENT if ( n < 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( n <= 1 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT x = ( ( n * math . log10 ( n / math . e ) + math . log10 ( 2 * math . pi * n ) / 2.0 ) ) ; NEW_LINE return math . floor ( x ) + 1 ; NEW_LINE DEDENT
Hyp: 
def findDigits ( n ) : NEW_LINE INDENT if ( n < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n <= 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT x = ( n * log10 ( n / M_E ) + log10 ( 2 * M_PI * n ) / 2.0 ) NEW_LINE return math . floor ( x ) + 1 NEW_LINE DEDENT

BLEU: 63.51
Edit Sim: 43


Src: 
int find ( int a [ ] , int b [ ] , int k , int n1 , int n2 ) { LinkedHashSet < Integer > s = new LinkedHashSet < > ( ) ; for ( int i = 0 ; i < n2 ; i ++ ) s . add ( b [ i ] ) ; int missing = 0 ; for ( int i = 0 ; i < n1 ; i ++ ) { if ( ! s . contains ( a [ i ] ) ) missing ++ ; if ( missing == k ) return a [ i ] ; } return - 1 ; }
Ref: 
def find ( a , b , k , n1 , n2 ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( n2 ) : NEW_LINE INDENT s . add ( b [ i ] ) NEW_LINE DEDENT missing = 0 NEW_LINE for i in range ( n1 ) : NEW_LINE INDENT if a [ i ] not in s : NEW_LINE INDENT missing += 1 NEW_LINE DEDENT if missing == k : NEW_LINE INDENT return a [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
Hyp: 
def find ( a , b , k , n1 , n2 ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( n2 ) : NEW_LINE INDENT s . add ( b [ i ] ) NEW_LINE DEDENT missing = 0 NEW_LINE for i in range ( n1 ) : NEW_LINE INDENT if i not in s : NEW_LINE INDENT missing += 1 NEW_LINE DEDENT if missing == k : NEW_LINE INDENT return a [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT

BLEU: 94.26
Edit Sim: 6


Src: 
int countDirectPath ( int N ) { return N + ( N * ( N - 3 ) ) / 2 ; }
Ref: 
def countDirectPath ( N ) : NEW_LINE INDENT return N + ( N * ( N - 3 ) ) // 2 NEW_LINE DEDENT
Hyp: 
def countDirectPath ( N ) : NEW_LINE INDENT return ( N + ( N * ( N - 3 ) ) // 2 ) NEW_LINE DEDENT

BLEU: 80.59
Edit Sim: 4


Src: 
int countSwaps ( int A [ ] , int n ) { Arrays . sort ( A ) ; int ind = 1 , res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { while ( ind < n && A [ ind ] == A [ i ] ) ind ++ ; if ( ind < n && A [ ind ] > A [ i ] ) { res ++ ; ind ++ ; } if ( ind >= n ) break ; } return res ; }
Ref: 
def countSwaps ( A , n ) : NEW_LINE INDENT A . sort ( ) NEW_LINE ind , res = 1 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT while ( ind < n and A [ ind ] == A [ i ] ) : NEW_LINE INDENT ind += 1 NEW_LINE DEDENT if ( ind < n and A [ ind ] > A [ i ] ) : NEW_LINE INDENT res += 1 NEW_LINE ind += 1 NEW_LINE DEDENT if ( ind >= n ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
Hyp: 
def countSwaps ( A , n ) : NEW_LINE INDENT A . sort ( ) NEW_LINE ind = 1 NEW_LINE res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT while ( ind < n and A [ ind ] == A [ i ] ) : NEW_LINE INDENT ind += 1 NEW_LINE DEDENT if ( ind < n and A [ ind ] > A [ i ] ) : NEW_LINE INDENT res += 1 NEW_LINE ind += 1 NEW_LINE DEDENT if ( ind >= n ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT

BLEU: 94.82
Edit Sim: 15


Src: 
long sumOfSumSeries ( int N ) { long sum = 0L ; for ( int i = 1 ; i <= N ; i ++ ) { sum = sum + ( i * ( i + 1 ) ) / 2 ; } return sum ; }
Ref: 
def sumOfSumSeries ( N ) : NEW_LINE INDENT _sum = 0 NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT _sum = _sum + ( i * ( i + 1 ) ) // 2 NEW_LINE DEDENT return _sum NEW_LINE DEDENT
Hyp: 
def sumOfSumSeries ( N ) : NEW_LINE INDENT sum = 0L NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT sum = sum + ( i * ( i + 1 ) ) // 2 NEW_LINE DEDENT return sum NEW_LINE DEDENT

BLEU: 68.21
Edit Sim: 9


Src: 
boolean isUnique ( int [ ] a , int n , int k ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += a [ i ] ; sum += n - 1 ; return ( sum == k ) ; }
Ref: 
def isUnique ( a , n , k ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT sum += a [ i ] NEW_LINE DEDENT sum += n - 1 NEW_LINE return ( sum == k ) NEW_LINE DEDENT
Hyp: 
def isUnique ( a , n , k ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += a [ i ] NEW_LINE DEDENT sum += n - 1 NEW_LINE return ( sum == k ) NEW_LINE DEDENT a = [ 2 , 3 , 4 , 5 , 2 ] NEW_LINE k = 5 NEW_LINE if ( isUnique ( a , n , k ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT

BLEU: 46.61
Edit Sim: 196


Src: 
int min_steps_required ( int n , int m , int r , int c ) { int i , j ; int corner_steps_req = Integer . MAX_VALUE ; i = 1 ; j = 1 ; corner_steps_req = Math . min ( corner_steps_req , Math . abs ( r - i ) + Math . abs ( j - c ) ) ; i = n ; j = 1 ; corner_steps_req = Math . min ( corner_steps_req , Math . abs ( r - i ) + Math . abs ( j - c ) ) ; i = 1 ; j = m ; corner_steps_req = Math . min ( corner_steps_req , Math . abs ( r - i ) + Math . abs ( j - c ) ) ; i = n ; j = m ; corner_steps_req = Math . min ( corner_steps_req , Math . abs ( r - i ) + Math . abs ( j - c ) ) ; int minimum_steps = Math . min ( 2 * ( n - 1 ) + m - 1 , 2 * ( m - 1 ) + n - 1 ) ; return minimum_steps + corner_steps_req ; }
Ref: 
def min_steps_required ( n , m , r , c ) : NEW_LINE INDENT i = 0 ; j = 0 ; NEW_LINE corner_steps_req = INT_MAX ; NEW_LINE i = 1 ; NEW_LINE j = 1 ; NEW_LINE corner_steps_req = min ( corner_steps_req , abs ( r - i ) + abs ( j - c ) ) ; NEW_LINE i = n ; NEW_LINE j = 1 ; NEW_LINE corner_steps_req = min ( corner_steps_req , abs ( r - i ) + abs ( j - c ) ) ; NEW_LINE i = 1 ; NEW_LINE j = m ; NEW_LINE corner_steps_req = min ( corner_steps_req , abs ( r - i ) + abs ( j - c ) ) ; NEW_LINE i = n ; NEW_LINE j = m ; NEW_LINE corner_steps_req = min ( corner_steps_req , abs ( r - i ) + abs ( j - c ) ) ; NEW_LINE minimum_steps = min ( 2 * ( n - 1 ) + m - 1 , 2 * ( m - 1 ) + n - 1 ) ; NEW_LINE return minimum_steps + corner_steps_req ; NEW_LINE DEDENT
Hyp: 
def min_steps_required ( n , m , r , c ) : NEW_LINE INDENT corner_steps_req = sys . maxsize NEW_LINE i = 1 NEW_LINE j = 1 NEW_LINE corner_steps_req = min ( corner_steps_req , abs ( r - i ) + abs ( j - c ) ) NEW_LINE i = n NEW_LINE j = 1 NEW_LINE corner_steps_req = min ( corner_steps_req , abs ( r - i ) + abs ( j - c ) ) NEW_LINE i = 1 NEW_LINE j = m NEW_LINE corner_steps_req = min ( corner_steps_req , abs ( r - i ) + abs ( j - c ) ) NEW_LINE i = n NEW_LINE j = m NEW_LINE corner_steps_req = min ( corner_steps_req , abs ( r - i ) + abs ( j - c ) ) NEW_LINE i = n NEW_LINE j = m NEW_LINE corner_steps_req = min ( corner_steps_req , abs ( r - i ) + abs ( j - c ) ) NEW_LINE minimum_steps = min ( 2 * ( n - 1 ) + m - 1 , 2 * ( m - 1 ) + n - 1 ) NEW_LINE return minimum_steps + corner_steps_req NEW_LINE DEDENT

BLEU: 72.6
Edit Sim: 139


Src: 
void convertBfromA ( int a , int b ) { int moves = 0 ; int x = Math . abs ( a - b ) ; for ( int i = 10 ; i > 0 ; i -- ) { moves += x / i ; x = x % i ; } System . out . print ( moves + " ▁ " ) ; }
Ref: 
def convertBfromA ( a , b ) : NEW_LINE INDENT moves = 0 NEW_LINE x = abs ( a - b ) NEW_LINE for i in range ( 10 , 0 , - 1 ) : NEW_LINE INDENT moves += x // i NEW_LINE x = x % i NEW_LINE DEDENT print ( moves , end = " ▁ " ) NEW_LINE DEDENT
Hyp: 
def convertBfromA ( a , b ) : NEW_LINE INDENT moves = 0 NEW_LINE x = abs ( a - b ) NEW_LINE i = 10 NEW_LINE moves += x // i NEW_LINE x = x % i NEW_LINE DEDENT print ( moves , end = " ▁ " ) NEW_LINE DEDENT

BLEU: 73.3
Edit Sim: 35


Src: 
float rod ( float h , float r ) { if ( h < 0 && r < 0 ) return - 1 ; float l = ( float ) ( Math . sqrt ( Math . pow ( h , 2 ) + 4 * Math . pow ( r , 2 ) ) ) ; return l ; }
Ref: 
def rod ( h , r ) : NEW_LINE INDENT if ( h < 0 and r < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT l = ( math . sqrt ( math . pow ( h , 2 ) + 4 * math . pow ( r , 2 ) ) ) NEW_LINE return float ( l ) NEW_LINE DEDENT
Hyp: 
def rod ( h , r ) : NEW_LINE INDENT if ( h < 0 and r < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT l = ( math . sqrt ( ( h ** 2 ) + 4 * ( r ** 2 ) ) ) NEW_LINE return l NEW_LINE DEDENT

BLEU: 69.49
Edit Sim: 36


Src: 
int findSum ( int [ ] arr , int n , int left , int right ) { int k = right - left ; int d = arr [ 1 ] - arr [ 0 ] ; int ans = arr [ left - 1 ] * ( k + 1 ) ; ans = ans + ( d * ( k * ( k + 1 ) ) ) / 2 ; return ans ; }
Ref: 
def findSum ( arr , n , left , right ) : NEW_LINE INDENT k = right - left ; NEW_LINE d = arr [ 1 ] - arr [ 0 ] ; NEW_LINE ans = arr [ left - 1 ] * ( k + 1 ) ; NEW_LINE ans = ans + ( d * ( k * ( k + 1 ) ) ) // 2 ; NEW_LINE return ans ; NEW_LINE DEDENT
Hyp: 
def findSum ( arr , n , left , right ) : NEW_LINE INDENT k = right - left NEW_LINE d = arr [ 1 ] - arr [ 0 ] NEW_LINE ans = arr [ left - 1 ] * ( k + 1 ) NEW_LINE ans = ans + ( d * ( k * ( k + 1 ) ) ) // 2 NEW_LINE return ans NEW_LINE DEDENT

BLEU: 83.2
Edit Sim: 10


Src: 
int countPairs ( int arr [ ] , int n ) { int ans = 0 ; HashMap < Integer , Integer > count = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( count . containsKey ( arr [ i ] ) ) { ans += count . get ( arr [ i ] ) ; count . put ( arr [ i ] , count . get ( arr [ i ] ) + 1 ) ; } else { count . put ( arr [ i ] , 1 ) ; } } return ans ; }
Ref: 
def countPairs ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE count = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] in count : NEW_LINE INDENT ans += count [ arr [ i ] ] NEW_LINE DEDENT if arr [ i ] in count : NEW_LINE INDENT count [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
Hyp: 
def countPairs ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE count = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] in count : NEW_LINE INDENT ans += count [ arr [ i ] ] NEW_LINE count [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT

BLEU: 85.48
Edit Sim: 47


Src: 
void MinimumValue ( int x , int y ) { if ( x > y ) { int temp = x ; x = y ; y = temp ; } int a = 1 ; int b = x - 1 ; int c = y - b ; System . out . print ( a + " ▁ " + b + " ▁ " + c ) ; }
Ref: 
def MinimumValue ( x , y ) : NEW_LINE INDENT if ( x > y ) : NEW_LINE INDENT x , y = y , x NEW_LINE DEDENT a = 1 NEW_LINE b = x - 1 NEW_LINE c = y - b NEW_LINE print ( a , b , c ) NEW_LINE DEDENT
Hyp: 
def MinimumValue ( x , y ) : NEW_LINE INDENT if ( x > y ) : NEW_LINE INDENT temp = x NEW_LINE x = y NEW_LINE y = temp NEW_LINE DEDENT a = 1 NEW_LINE b = x - 1 NEW_LINE c = y - b NEW_LINE print ( a , b , c ) NEW_LINE DEDENT

BLEU: 81.42
Edit Sim: 32


Src: 
int totalNumber ( int n ) { return 8 * ( int ) Math . pow ( 9 , n - 1 ) ; }
Ref: 
def totalNumber ( n ) : NEW_LINE INDENT return 8 * pow ( 9 , n - 1 ) ; NEW_LINE DEDENT
Hyp: 
def totalNumber ( n ) : NEW_LINE INDENT return 8 * pow ( 9 , n - 1 ) ; NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
double possiblePositions ( double n ) { double term1 = Math . pow ( n , 4 ) ; double term2 = Math . pow ( n , 3 ) ; double term3 = Math . pow ( n , 2 ) ; double term4 = n / 3 ; double ans = ( Math . ceil ( term1 / 2 ) ) - ( Math . ceil ( 5 * term2 ) / 3 ) + ( Math . ceil ( 3 * term3 ) / 2 ) - term4 ; return ( long ) ans ; }
Ref: 
def possiblePositions ( n ) : NEW_LINE INDENT term1 = pow ( n , 4 ) ; NEW_LINE term2 = pow ( n , 3 ) ; NEW_LINE term3 = pow ( n , 2 ) ; NEW_LINE term4 = n / 3 ; NEW_LINE ans = ( ( math . ceil ( term1 ) ) / 2 - ( math . ceil ( 5 * term2 ) ) / 3 + ( math . ceil ( 3 * term3 ) ) / 2 - term4 ) ; NEW_LINE return ans ; NEW_LINE DEDENT
Hyp: 
def possiblePositions ( n ) : NEW_LINE INDENT term1 = pow ( n , 4 ) NEW_LINE term2 = pow ( n , 3 ) NEW_LINE term3 = pow ( n , 2 ) NEW_LINE term4 = n // 3 NEW_LINE ans = ( math . ceil ( term1 / 2 ) ) - ( math . ceil ( 5 * term2 ) / 3 ) + ( math . ceil ( 3 * term3 ) / 2 ) - term4 ; NEW_LINE return ans ; NEW_LINE DEDENT

BLEU: 70.62
Edit Sim: 23


Src: 
int findNumber ( int N ) { return N & ( N + 1 ) ; }
Ref: 
def findNumber ( N ) : NEW_LINE INDENT return N & ( N + 1 ) NEW_LINE DEDENT
Hyp: 
def findNumber ( N ) : NEW_LINE INDENT return N & ( N + 1 ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
void search ( String pat , String txt ) { int M = pat . length ( ) ; int N = txt . length ( ) ; int i = 0 ; while ( i <= N - M ) { int j ; for ( j = 0 ; j < M ; j ++ ) if ( txt . charAt ( i + j ) != pat . charAt ( j ) ) break ; { System . out . println ( " Pattern ▁ found ▁ at ▁ index ▁ " + i ) ; i = i + M ; } else if ( j == 0 ) i = i + 1 ; else i = i + j ; } }
Ref: 
def search ( pat , txt ) : NEW_LINE INDENT M = len ( pat ) NEW_LINE N = len ( txt ) NEW_LINE i = 0 NEW_LINE while i <= N - M : NEW_LINE INDENT for j in xrange ( M ) : NEW_LINE INDENT if txt [ i + j ] != pat [ j ] : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE print " Pattern ▁ found ▁ at ▁ index ▁ " + str ( i ) NEW_LINE i = i + M NEW_LINE DEDENT elif j == 0 : NEW_LINE INDENT i = i + 1 NEW_LINE DEDENT else : NEW_LINE INDENT i = i + j NEW_LINE DEDENT DEDENT DEDENT
Hyp: 
def search ( pat , txt ) : NEW_LINE INDENT M = len ( pat ) NEW_LINE N = len ( txt ) NEW_LINE i = 0 NEW_LINE while ( i <= N - M ) : NEW_LINE INDENT j = 0 NEW_LINE while ( j < M ) : NEW_LINE INDENT if ( txt [ i + j ] != pat [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( " Pattern ▁ found ▁ at ▁ index ▁ " , i ) NEW_LINE i = i + M NEW_LINE DEDENT elif ( j == 0 ) : NEW_LINE INDENT i = i + 1 NEW_LINE DEDENT else : NEW_LINE INDENT i = i + j NEW_LINE DEDENT DEDENT DEDENT

BLEU: 75.36
Edit Sim: 55


Src: 
int maxItems ( int x , int y , int z ) { int type1 = x / COST ; x %= COST ; int type2 = y / COST ; y %= COST ; int type3 = z / COST ; z %= COST ; int type4 = Math . min ( x , Math . min ( y , z ) ) ; int maxItems = type1 + type2 + type3 + type4 ; return maxItems ; }
Ref: 
def maxItems ( x , y , z ) : NEW_LINE INDENT type1 = x // COST ; NEW_LINE x %= COST ; NEW_LINE type2 = y // COST ; NEW_LINE y %= COST ; NEW_LINE type3 = z // COST ; NEW_LINE z %= COST ; NEW_LINE type4 = min ( x , min ( y , z ) ) ; NEW_LINE maxItems = type1 + type2 + type3 + type4 ; NEW_LINE return maxItems ; NEW_LINE DEDENT
Hyp: 
def maxItems ( x , y , z ) : NEW_LINE INDENT type1 = x // COST NEW_LINE x %= COST NEW_LINE type2 = y // COST NEW_LINE y %= COST NEW_LINE type3 = z // COST NEW_LINE z %= COST NEW_LINE type4 = min ( x , min ( y , z ) ) NEW_LINE maxItems = type1 + type2 + type3 + type4 NEW_LINE return maxItems NEW_LINE DEDENT

BLEU: 69.84
Edit Sim: 18


Src: 
int countPairs ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] == arr [ j ] ) ans ++ ; return ans ; }
Ref: 
def countPairs ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] == arr [ j ] ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
Hyp: 
def countPairs ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] == arr [ j ] ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT

BLEU: 94.59
Edit Sim: 4


Src: 
int countNumbers ( int N ) { return ( int ) ( Math . pow ( 10 , N ) - Math . pow ( 8 , N ) ) / 2 ; }
Ref: 
def countNumbers ( N ) : NEW_LINE INDENT return ( pow ( 10 , N ) - pow ( 8 , N ) ) // 2 NEW_LINE DEDENT
Hyp: 
def countNumbers ( N ) : NEW_LINE INDENT return ( pow ( 10 , N ) - pow ( 8 , N ) ) // 2 NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int evenbinomialCoeffSum ( int n ) { return ( 1 << ( n - 1 ) ) ; }
Ref: 
def evenbinomialCoeffSum ( n ) : NEW_LINE INDENT return ( 1 << ( n - 1 ) ) NEW_LINE DEDENT
Hyp: 
def evenbinomialCoeffSum ( n ) : NEW_LINE INDENT return ( 1 << ( n - 1 ) ) ; NEW_LINE DEDENT

BLEU: 88.67
Edit Sim: 2


Src: 
void findPairs ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) arr [ i ] = Math . abs ( arr [ i ] ) ; Arrays . sort ( arr ) ; int left = 0 ; int ans = 0 ; for ( int right = 0 ; right < N ; right ++ ) { while ( 2 * arr [ left ] < arr [ right ] ) left ++ ; ans += ( right - left ) ; } System . out . print ( ans ) ; }
Ref: 
def findPairs ( arr , N ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT arr [ i ] = abs ( arr [ i ] ) NEW_LINE DEDENT arr . sort ( ) NEW_LINE left = 0 NEW_LINE ans = 0 NEW_LINE for right in range ( N ) : NEW_LINE INDENT while ( 2 * arr [ left ] < arr [ right ] ) : NEW_LINE INDENT left += 1 NEW_LINE DEDENT ans += ( right - left ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
Hyp: 
def findPairs ( arr , N ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT arr [ i ] = abs ( arr [ i ] ) NEW_LINE DEDENT arr . sort ( ) NEW_LINE left = 0 NEW_LINE ans = 0 NEW_LINE for right in range ( N ) : NEW_LINE INDENT while ( 2 * arr [ left ] < arr [ right ] ) : NEW_LINE INDENT left += 1 NEW_LINE DEDENT ans += ( right - left ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
void printKNumbers ( int N , int K ) { for ( int i = 0 ; i < K - 1 ; i ++ ) System . out . print ( 1 + " ▁ " ) ; System . out . print ( N - K + 1 ) ; }
Ref: 
def printKNumbers ( N , K ) : NEW_LINE INDENT for i in range ( K - 1 ) : NEW_LINE INDENT print ( 1 , end = ' ▁ ' ) NEW_LINE DEDENT print ( N - K + 1 ) NEW_LINE DEDENT
Hyp: 
def printKNumbers ( N , K ) : NEW_LINE INDENT for i in range ( K - 1 ) : NEW_LINE INDENT print ( 1 , end = " ▁ " ) NEW_LINE DEDENT print ( N - K + 1 ) NEW_LINE DEDENT

BLEU: 90.07
Edit Sim: 2


Src: 
int fnMod ( int n ) { if ( n % 5 == 1 ) return 4 ; else return 0 ; }
Ref: 
def fnMod ( n ) : NEW_LINE INDENT if ( n % 5 == 1 ) : NEW_LINE INDENT return 4 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT
Hyp: 
def fnMod ( n ) : NEW_LINE INDENT if ( n % 5 == 1 ) : NEW_LINE INDENT return 4 ; NEW_LINE DEDENT else : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT DEDENT

BLEU: 84.53
Edit Sim: 4


Src: 
boolean isValid ( String str , int n ) { if ( ! ( ( str . charAt ( 0 ) >= ' a ' && str . charAt ( 0 ) <= ' z ' ) || ( str . charAt ( 0 ) >= ' A ' && str . charAt ( 0 ) <= ' Z ' ) || str . charAt ( 0 ) == ' _ ' ) ) return false ; for ( int i = 1 ; i < str . length ( ) ; i ++ ) { if ( ! ( ( str . charAt ( i ) >= ' a ' && str . charAt ( i ) <= ' z ' ) || ( str . charAt ( i ) >= ' A ' && str . charAt ( i ) <= ' Z ' ) || ( str . charAt ( i ) >= '0' && str . charAt ( i ) <= '9' ) || str . charAt ( i ) == ' _ ' ) ) return false ; } return true ; }
Ref: 
def isValid ( str1 , n ) : NEW_LINE INDENT if ( ( ( ord ( str1 [ 0 ] ) >= ord ( ' a ' ) and ord ( str1 [ 0 ] ) <= ord ( ' z ' ) ) or ( ord ( str1 [ 0 ] ) >= ord ( ' A ' ) and ord ( str1 [ 0 ] ) <= ord ( ' Z ' ) ) or ord ( str1 [ 0 ] ) == ord ( ' _ ' ) ) == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 1 , len ( str1 ) ) : NEW_LINE INDENT if ( ( ( ord ( str1 [ i ] ) >= ord ( ' a ' ) and ord ( str1 [ i ] ) <= ord ( ' z ' ) ) or ( ord ( str1 [ i ] ) >= ord ( ' A ' ) and ord ( str1 [ i ] ) <= ord ( ' Z ' ) ) or ( ord ( str1 [ i ] ) >= ord ( '0' ) and ord ( str1 [ i ] ) <= ord ( '9' ) ) or ord ( str1 [ i ] ) == ord ( ' _ ' ) ) == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT str1 = " _ geeks123" NEW_LINE n = len ( str1 ) NEW_LINE if ( isValid ( str1 , n ) ) : NEW_LINE INDENT print ( " Valid " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Invalid " ) NEW_LINE DEDENT
Hyp: 
def isValid ( st , n ) : NEW_LINE INDENT if ( not ( st [ 0 ] >= ' a ' and st [ 0 ] <= ' z ' ) or ( st [ 0 ] >= ' A ' and st [ 0 ] <= ' Z ' ) or ( st [ 0 ] >= ' _ ' ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 1 , len ( st ) ) : NEW_LINE INDENT if ( not ( ( st [ i ] >= ' a ' and st [ i ] <= ' z ' ) or ( st [ i ] >= ' A ' and st [ i ] <= ' Z ' ) or ( st [ i ] >= '0' and st [ i ] <= '9' ) or str [ i ] == ' _ ' ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT

BLEU: 24.79
Edit Sim: 435


Src: 
int findLargestDivisor ( int n ) { for ( int i = 2 ; i < Math . sqrt ( n ) + 1 ; i ++ ) { while ( n % ( i * i ) == 0 ) { n = n / i ; } } return n ; }
Ref: 
def findLargestDivisor ( n ) : NEW_LINE INDENT for i in range ( 2 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT while ( n % ( i * i ) == 0 ) : NEW_LINE INDENT n = n // i NEW_LINE DEDENT DEDENT return n NEW_LINE DEDENT
Hyp: 
def findLargestDivisor ( n ) : NEW_LINE INDENT for i in range ( 2 , int ( math . sqrt ( n ) + 1 ) ) : NEW_LINE INDENT while ( n % ( i * i ) == 0 ) : NEW_LINE INDENT n = n // i NEW_LINE DEDENT DEDENT return n NEW_LINE DEDENT

BLEU: 96.31
Edit Sim: 3


Src: 
String get_maximum ( char [ ] s , int a [ ] ) { int n = s . length ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] - '0' < a [ s [ i ] - '0' ] ) { int j = i ; while ( j < n && ( s [ j ] - '0' <= a [ s [ j ] - '0' ] ) ) { s [ j ] = ( char ) ( '0' + a [ s [ j ] - '0' ] ) ; j ++ ; } return String . valueOf ( s ) ; } } return String . valueOf ( s ) ; }
Ref: 
def get_maximum ( s , a ) : NEW_LINE INDENT s = list ( s ) NEW_LINE n = len ( s ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ord ( s [ i ] ) - ord ( '0' ) < a [ ord ( s [ i ] ) - ord ( '0' ) ] ) : NEW_LINE INDENT j = i NEW_LINE while ( j < n and ( ord ( s [ j ] ) - ord ( '0' ) <= a [ ord ( s [ j ] ) - ord ( '0' ) ] ) ) : NEW_LINE INDENT s [ j ] = chr ( ord ( '0' ) + a [ ord ( s [ j ] ) - ord ( '0' ) ] ) NEW_LINE j += 1 NEW_LINE DEDENT return " " . join ( s ) ; NEW_LINE DEDENT DEDENT return s NEW_LINE DEDENT
Hyp: 
def get_maximum ( s , a ) : NEW_LINE INDENT n = len ( s ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] - '0' < a [ s [ i ] - '0' ] ) : NEW_LINE INDENT j = i NEW_LINE while ( j < n and ( s [ j ] - '0' <= a [ s [ j ] - '0' ] ) ) : NEW_LINE INDENT s [ j ] = ( char ) ( '0' + a [ s [ j ] - '0' ] ) NEW_LINE j += 1 NEW_LINE DEDENT return str ( s ) NEW_LINE DEDENT DEDENT

BLEU: 47.75
Edit Sim: 151


Src: 
String tidyNum ( String str1 , int len ) { char [ ] str = str1 . toCharArray ( ) ; for ( int i = len - 2 ; i >= 0 ; i -- ) { if ( str [ i ] > str [ i + 1 ] ) { str [ i ] -- ; for ( int j = i + 1 ; j < len ; j ++ ) str [ j ] = '9' ; } } return String . valueOf ( str ) ; }
Ref: 
def tidyNum ( str , len ) : NEW_LINE INDENT for i in range ( len - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( str [ i ] > str [ i + 1 ] ) : NEW_LINE INDENT str [ i ] -= 1 NEW_LINE for j in range ( i + 1 , len ) : NEW_LINE INDENT str [ j ] = 9 NEW_LINE DEDENT DEDENT DEDENT return str NEW_LINE DEDENT str = [ 1 , 1 , 3 , 3 , 3 , 4 , 4 , 5 , 5 , 3 , 8 ] NEW_LINE len = len ( str ) NEW_LINE num = tidyNum ( str , len ) NEW_LINE for i in range ( 0 , len ) : NEW_LINE INDENT print ( str [ i ] , end = " " ) NEW_LINE DEDENT
Hyp: 
def tidyNum ( str1 , l ) : NEW_LINE INDENT str = list ( str1 ) NEW_LINE for i in range ( l - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( str [ i ] > str [ i + 1 ] ) : NEW_LINE INDENT str [ i ] -= 1 NEW_LINE for j in range ( i + 1 , l ) : NEW_LINE INDENT str [ j ] = '9' NEW_LINE DEDENT DEDENT DEDENT return string ( str ) NEW_LINE DEDENT

BLEU: 40.38
Edit Sim: 245


Src: 
void solve ( String s , int k ) { int count = 0 , length = 0 , pos = 0 ; HashMap < Character , Integer > m = new HashMap < Character , Integer > ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( m . containsKey ( s . charAt ( i ) ) ) m . put ( s . charAt ( i ) , m . get ( s . charAt ( i ) ) + 1 ) ; else m . put ( s . charAt ( i ) , 1 ) ; length ++ ; if ( length > k ) { m . put ( s . charAt ( pos ) , m . get ( s . charAt ( pos ) ) - 1 ) ; pos ++ ; length -- ; } if ( length == k && m . get ( s . charAt ( i ) ) == length ) count ++ ; } System . out . println ( count ) ; }
Ref: 
def solve ( s , k ) : NEW_LINE INDENT count , length , pos = 0 , 0 , 0 NEW_LINE m = dict . fromkeys ( s , 0 ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT m [ s [ i ] ] += 1 NEW_LINE length += 1 NEW_LINE if length > k : NEW_LINE INDENT m [ s [ pos ] ] -= 1 NEW_LINE pos += 1 NEW_LINE length -= 1 NEW_LINE DEDENT if length == k and m [ s [ i ] ] == length : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT
Hyp: 
def solve ( s , k ) : NEW_LINE INDENT count = 0 NEW_LINE length = 0 NEW_LINE pos = 0 NEW_LINE m = { } NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] in m ) : NEW_LINE INDENT m [ s [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT m [ s [ i ] ] = 1 NEW_LINE DEDENT length += 1 NEW_LINE if ( length > k ) : NEW_LINE INDENT m [ s [ pos ] ] -= 1 NEW_LINE pos += 1 NEW_LINE length -= 1 NEW_LINE DEDENT if ( length == k and m [ s [ i ] ] == length ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT

BLEU: 63.67
Edit Sim: 144


Src: 
int findCost ( int [ ] A , int N ) { int totalCost = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( A [ i ] == 0 ) { A [ i ] = 1 ; totalCost += i ; } } return totalCost ; }
Ref: 
def findCost ( A , N ) : NEW_LINE INDENT totalCost = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( A [ i ] == 0 ) : NEW_LINE INDENT A [ i ] = 1 NEW_LINE totalCost += i NEW_LINE DEDENT DEDENT return totalCost NEW_LINE DEDENT
Hyp: 
def findCost ( A , N ) : NEW_LINE INDENT totalCost = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( A [ i ] == 0 ) : NEW_LINE INDENT A [ i ] = 1 NEW_LINE totalCost += i NEW_LINE DEDENT DEDENT return totalCost NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int countXorPair ( int arr [ ] , int n ) { int odd = 0 , even = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) even ++ ; else odd ++ ; } return odd * even ; }
Ref: 
def countXorPair ( arr , n ) : NEW_LINE INDENT odd = 0 NEW_LINE even = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] % 2 == 0 : NEW_LINE INDENT even += 1 NEW_LINE DEDENT else : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT DEDENT return odd * even NEW_LINE DEDENT
Hyp: 
def countXorPair ( arr , n ) : NEW_LINE INDENT odd = 0 ; even = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT even += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT odd += 1 ; NEW_LINE DEDENT DEDENT return odd * even ; NEW_LINE DEDENT

BLEU: 72.93
Edit Sim: 20


Src: 
int Nonagonal ( int n ) { return n * ( 7 * n - 5 ) / 2 ; }
Ref: 
def Nonagonal ( n ) : NEW_LINE INDENT return int ( n * ( 7 * n - 5 ) / 2 ) NEW_LINE DEDENT
Hyp: 
def Nonagonal ( n ) : NEW_LINE INDENT return n * ( 7 * n - 5 ) // 2 NEW_LINE DEDENT

BLEU: 67.74
Edit Sim: 9


Src: 
boolean check ( int a [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) if ( a [ i ] == 1 ) return true ; return false ; }
Ref: 
def check ( a , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
Hyp: 
def check ( a , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT

BLEU: 91.23
Edit Sim: 5


Src: 
int cntSubArrays ( int [ ] arr , int n , int k ) { int res = 0 ; int i = 0 ; while ( i < n ) { int j = i + 1 ; while ( j < n && arr [ j ] >= arr [ j - 1 ] ) j ++ ; res += Math . max ( j - i - k + 1 , 0 ) ; i = j ; } return res ; }
Ref: 
def cntSubArrays ( arr , n , k ) : NEW_LINE INDENT res = 0 ; NEW_LINE i = 0 ; NEW_LINE while ( i < n ) : NEW_LINE INDENT j = i + 1 ; NEW_LINE while ( j < n and arr [ j ] >= arr [ j - 1 ] ) : NEW_LINE INDENT j += 1 ; NEW_LINE DEDENT res += max ( j - i - k + 1 , 0 ) ; NEW_LINE i = j ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT
Hyp: 
def cntSubArrays ( arr , n , k ) : NEW_LINE INDENT res = 0 ; NEW_LINE i = 0 ; NEW_LINE while ( i < n ) : NEW_LINE INDENT j = i + 1 ; NEW_LINE while ( j < n and arr [ j ] >= arr [ j - 1 ] ) : NEW_LINE j += 1 ; NEW_LINE res += max ( j - i - k + 1 , 0 ) ; NEW_LINE i = j ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT

BLEU: 94.46
Edit Sim: 14


Src: 
void RightRotate ( int a [ ] , int n , int k ) { k = k % n ; for ( int i = 0 ; i < n ; i ++ ) { if ( i < k ) { System . out . print ( a [ n + i - k ] + " ▁ " ) ; } else { System . out . print ( a [ i - k ] + " ▁ " ) ; } } System . out . println ( ) ; }
Ref: 
def RightRotate ( a , n , k ) : NEW_LINE INDENT k = k % n ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( i < k ) : NEW_LINE INDENT print ( a [ n + i - k ] , end = " ▁ " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( a [ i - k ] , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT print ( " " ) ; NEW_LINE DEDENT
Hyp: 
def RightRotate ( a , n , k ) : NEW_LINE INDENT k = k % n NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i < k ) : NEW_LINE INDENT print ( a [ n + i - k ] , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( a [ i - k ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT

BLEU: 81.68
Edit Sim: 16


Src: 
float kPresentProbability ( int a [ ] , int n , int k ) { float count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( a [ i ] == k ) count ++ ; return count / n ; }
Ref: 
def kPresentProbability ( a , n , k ) : NEW_LINE INDENT count = a . count ( k ) NEW_LINE return round ( count / n , 2 ) NEW_LINE DEDENT
Hyp: 
def kPresentProbability ( a , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == k ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count / n NEW_LINE DEDENT

BLEU: 34.77
Edit Sim: 105


Src: 
boolean oppositeSigns ( int x , int y ) { return ( ( x ^ y ) < 0 ) ; }
Ref: 
def oppositeSigns ( x , y ) : NEW_LINE INDENT return ( ( x ^ y ) < 0 ) ; NEW_LINE DEDENT x = 100 NEW_LINE y = 1 NEW_LINE if ( oppositeSigns ( x , y ) == True ) : NEW_LINE INDENT print " Signs ▁ are ▁ opposite " NEW_LINE DEDENT else : NEW_LINE INDENT print " Signs ▁ are ▁ not ▁ opposite " NEW_LINE DEDENT
Hyp: 
def oppositeSigns ( x , y ) : NEW_LINE INDENT return ( ( x ^ y ) < 0 ) NEW_LINE DEDENT

BLEU: 10.12
Edit Sim: 218


Src: 
int numberOfCuts ( int M , int N ) { int result = 0 ; result = ( M - 1 ) * ( N - 1 ) ; return result ; }
Ref: 
def numberOfCuts ( M , N ) : NEW_LINE INDENT result = 0 NEW_LINE result = ( M - 1 ) * ( N - 1 ) NEW_LINE return result NEW_LINE DEDENT
Hyp: 
def numberOfCuts ( M , N ) : NEW_LINE INDENT result = 0 NEW_LINE result = ( M - 1 ) * ( N - 1 ) NEW_LINE return result NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
void minProduct ( int n ) { int ans = 1 ; for ( int i = 1 ; i <= ( n - 4 ) / 2 ; i ++ ) { ans = ( int ) ( 1L * ans * ( n - 2 ) ) % mod ; } ans = ( int ) ( 1L * ans * ( n - 2 ) * ( n - 1 ) ) % mod ; System . out . print ( ans + "NEW_LINE"); }
Ref: 
def minProduct ( n ) : NEW_LINE INDENT ans = 1 NEW_LINE for i in range ( 1 , ( n - 4 ) // 2 + 1 ) : NEW_LINE INDENT ans = ( ans * ( n - 2 ) ) % mod NEW_LINE DEDENT ans = ( ans * ( n - 2 ) * ( n - 1 ) ) % mod NEW_LINE print ( int ( ans ) ) NEW_LINE DEDENT
Hyp: 
def minProduct ( n ) : NEW_LINE INDENT ans = 1 NEW_LINE for i in range ( 1 , int ( ( n - 4 ) / 2 ) + 1 ) : NEW_LINE INDENT ans = ( int ) ( 1L * ans * ( n - 2 ) ) % mod NEW_LINE DEDENT ans = ( int ) ( 1L * ans * ( n - 2 ) * ( n - 1 ) ) % mod NEW_LINE print ( ans ) NEW_LINE DEDENT

BLEU: 74.75
Edit Sim: 43


Src: 
int countDistinct ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { while ( i < n - 1 && arr [ i ] == arr [ i + 1 ] ) { i ++ ; } res ++ ; } return res ; }
Ref: 
def countDistinct ( arr , n ) : NEW_LINE INDENT arr . sort ( ) ; NEW_LINE res = 0 ; NEW_LINE i = 0 ; NEW_LINE while ( i < n ) : NEW_LINE INDENT while ( i < n - 1 and arr [ i ] == arr [ i + 1 ] ) : NEW_LINE INDENT i += 1 ; NEW_LINE DEDENT res += 1 ; NEW_LINE i += 1 ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT
Hyp: 
def countDistinct ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT while ( i < n - 1 and arr [ i ] == arr [ i + 1 ] ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT res += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT

BLEU: 65.28
Edit Sim: 50


Src: 
int getHermiteNumber ( int n ) { if ( n == 0 ) return 1 ; else if ( n == 1 ) return 1 ; else return - 2 * ( n - 1 ) * getHermiteNumber ( n - 2 ) ; }
Ref: 
def getHermiteNumber ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return ( - 2 * ( n - 1 ) * getHermiteNumber ( n - 2 ) ) NEW_LINE DEDENT DEDENT
Hyp: 
def getHermiteNumber ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return - 2 * ( n - 1 ) * getHermiteNumber ( n - 2 ) NEW_LINE DEDENT DEDENT

BLEU: 71.14
Edit Sim: 15


Src: 
void last_digit ( int X , int Y ) { System . out . print ( X % Y ) ; }
Ref: 
def last_digit ( X , Y ) : NEW_LINE INDENT print ( X % Y ) ; NEW_LINE DEDENT
Hyp: 
def last_digit ( X , Y ) : NEW_LINE INDENT print ( X % Y ) NEW_LINE DEDENT

BLEU: 87.41
Edit Sim: 2


Src: 
String replace ( String s , char c1 , char c2 ) { int l = s . length ( ) ; char [ ] arr = s . toCharArray ( ) ; for ( int i = 0 ; i < l ; i ++ ) { if ( arr [ i ] == c1 ) arr [ i ] = c2 ; else if ( arr [ i ] == c2 ) arr [ i ] = c1 ; } return String . valueOf ( arr ) ; }
Ref: 
def replace ( s , c1 , c2 ) : NEW_LINE INDENT l = len ( s ) NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( s [ i ] == c1 ) : NEW_LINE INDENT s = s [ 0 : i ] + c2 + s [ i + 1 : ] NEW_LINE DEDENT elif ( s [ i ] == c2 ) : NEW_LINE INDENT s = s [ 0 : i ] + c1 + s [ i + 1 : ] NEW_LINE DEDENT DEDENT return s NEW_LINE DEDENT
Hyp: 
def replace ( s , c1 , c2 ) : NEW_LINE INDENT l = len ( s ) NEW_LINE arr = list ( s ) NEW_LINE for i in range ( 0 , l ) : NEW_LINE INDENT if ( arr [ i ] == c1 ) : NEW_LINE INDENT arr [ i ] = c2 NEW_LINE DEDENT elif ( arr [ i ] == c2 ) : NEW_LINE INDENT arr [ i ] = c1 NEW_LINE DEDENT DEDENT return string . valueOf ( arr ) NEW_LINE DEDENT

BLEU: 53.71
Edit Sim: 111


Src: 
int findS ( int s ) { int sum = 0 ; for ( int n = 1 ; sum < s ; n ++ ) { sum += n ; if ( sum == s ) return n ; } return - 1 ; }
Ref: 
def findS ( s ) : NEW_LINE INDENT _sum = 0 NEW_LINE n = 1 NEW_LINE while ( _sum < s ) : NEW_LINE INDENT _sum += n NEW_LINE n += 1 NEW_LINE DEDENT n -= 1 NEW_LINE if _sum == s : NEW_LINE INDENT return n NEW_LINE DEDENT return - 1 NEW_LINE DEDENT s = 15 NEW_LINE n = findS ( s ) NEW_LINE if n == - 1 : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT
Hyp: 
def findS ( s ) : NEW_LINE INDENT sum = 0 NEW_LINE for n in range ( 1 , s ) : NEW_LINE INDENT sum += n NEW_LINE if ( sum == s ) : NEW_LINE INDENT return n NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT

BLEU: 21.05
Edit Sim: 218


Src: 
int getMinSquares ( int n ) { if ( n <= 3 ) return n ; int dp [ ] = new int [ n + 1 ] ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; dp [ 2 ] = 2 ; dp [ 3 ] = 3 ; for ( int i = 4 ; i <= n ; i ++ ) { dp [ i ] = i ; for ( int x = 1 ; x <= Math . ceil ( Math . sqrt ( i ) ) ; x ++ ) { int temp = x * x ; if ( temp > i ) break ; else dp [ i ] = Math . min ( dp [ i ] , 1 + dp [ i - temp ] ) ; } } int res = dp [ n ] ; return res ; }
Ref: 
def getMinSquares ( n ) : NEW_LINE INDENT dp = [ 0 , 1 , 2 , 3 ] NEW_LINE for i in range ( 4 , n + 1 ) : NEW_LINE INDENT dp . append ( i ) NEW_LINE for x in range ( 1 , int ( ceil ( sqrt ( i ) ) ) + 1 ) : NEW_LINE INDENT temp = x * x ; NEW_LINE if temp > i : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] = min ( dp [ i ] , 1 + dp [ i - temp ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ n ] NEW_LINE DEDENT
Hyp: 
def getMinSquares ( n ) : NEW_LINE INDENT if ( n <= 3 ) : NEW_LINE INDENT return n NEW_LINE DEDENT dp = [ 0 for i in range ( n + 1 ) ] NEW_LINE dp [ 0 ] = 0 NEW_LINE dp [ 1 ] = 1 NEW_LINE dp [ 2 ] = 2 NEW_LINE dp [ 3 ] = 3 NEW_LINE for i in range ( 4 , n + 1 ) : NEW_LINE INDENT dp [ i ] = i NEW_LINE for x in range ( 1 , int ( math . ceil ( math . sqrt ( i ) ) + 1 ) : NEW_LINE INDENT temp = x * x NEW_LINE if ( temp > i ) : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] = min ( dp [ i ] , 1 + dp [ i - temp ] ) NEW_LINE DEDENT DEDENT DEDENT res = dp [ n ] NEW_LINE return res NEW_LINE DEDENT

BLEU: 53.28
Edit Sim: 217


Src: 
int Max_Sum ( int n ) { return ( n * ( n - 1 ) ) / 2 ; }
Ref: 
def Max_Sum ( n ) : NEW_LINE INDENT return ( n * ( n - 1 ) ) // 2 ; NEW_LINE DEDENT
Hyp: 
def Max_Sum ( n ) : NEW_LINE INDENT return ( n * ( n - 1 ) ) // 2 NEW_LINE DEDENT

BLEU: 89.72
Edit Sim: 2


Src: 
int minimumcntOperationReq ( int arr [ ] , int N ) { int cntOp = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) { cntOp ++ ; } } return ( cntOp + 1 ) / 2 ; }
Ref: 
def minimumcntOperationReq ( arr , N ) : NEW_LINE INDENT cntOp = 0 NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT if ( arr [ i ] == arr [ i + 1 ] ) : NEW_LINE INDENT cntOp += 1 NEW_LINE DEDENT DEDENT return ( cntOp + 1 ) // 2 NEW_LINE DEDENT
Hyp: 
def minimumcntOperationReq ( arr , N ) : NEW_LINE INDENT cntOp = 0 NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT if ( arr [ i ] == arr [ i + 1 ] ) : NEW_LINE INDENT cntOp += 1 NEW_LINE DEDENT DEDENT return ( cntOp + 1 ) // 2 NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
void findPoints ( int l1 , int r1 , int l2 , int r2 ) { int x = ( l1 != l2 ) ? Math . min ( l1 , l2 ) : - 1 ; int y = ( r1 != r2 ) ? Math . max ( r1 , r2 ) : - 1 ; System . out . println ( x + " ▁ " + y ) ; }
Ref: 
def findPoints ( l1 , r1 , l2 , r2 ) : NEW_LINE INDENT x = min ( l1 , l2 ) if ( l1 != l2 ) else - 1 NEW_LINE y = max ( r1 , r2 ) if ( r1 != r2 ) else - 1 NEW_LINE print ( x , y ) NEW_LINE DEDENT
Hyp: 
def findPoints ( l1 , r1 , l2 , r2 ) : NEW_LINE INDENT x = ( l1 != l2 ) ? min ( l1 , l2 ) : - 1 NEW_LINE y = ( r1 != r2 ) ? max ( r1 , r2 ) : - 1 NEW_LINE print ( x , " ▁ " , y ) NEW_LINE DEDENT

BLEU: 69.73
Edit Sim: 41


Src: 
int maxSumLCM ( int n ) { for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { max_sum += i ; if ( n / i != i ) max_sum += ( n / i ) ; } } return max_sum ; }
Ref: 
def maxSumLCM ( n ) : NEW_LINE INDENT max_sum = 0 NEW_LINE i = 1 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT max_sum = max_sum + i NEW_LINE if ( n // i != i ) : NEW_LINE INDENT max_sum = max_sum + ( n // i ) NEW_LINE DEDENT DEDENT i = i + 1 NEW_LINE DEDENT return max_sum NEW_LINE DEDENT
Hyp: 
def maxSumLCM ( n ) : NEW_LINE INDENT max_sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT max_sum += i NEW_LINE if ( n // i != i ) : NEW_LINE INDENT max_sum += ( n // i ) NEW_LINE DEDENT DEDENT DEDENT return max_sum NEW_LINE DEDENT

BLEU: 63.38
Edit Sim: 63


Src: 
int minDifference ( int x , int y , int k , int b [ ] [ ] , int c [ ] [ ] ) { if ( x >= n y >= m ) return INT_MAX ; if ( x == n - 1 && y == m - 1 ) { int diff = b [ x ] [ y ] - c [ x ] [ y ] ; return Math . min ( Math . abs ( k - diff ) , Math . abs ( k + diff ) ) ; } int ans = dp [ x ] [ y ] [ k ] ; if ( ans != - 1 ) return ans ; ans = INT_MAX ; int diff = b [ x ] [ y ] - c [ x ] [ y ] ; ans = Math . min ( ans , minDifference ( x + 1 , y , Math . abs ( k + diff ) , b , c ) ) ; ans = Math . min ( ans , minDifference ( x , y + 1 , Math . abs ( k + diff ) , b , c ) ) ; ans = Math . min ( ans , minDifference ( x + 1 , y , Math . abs ( k - diff ) , b , c ) ) ; ans = Math . min ( ans , minDifference ( x , y + 1 , Math . abs ( k - diff ) , b , c ) ) ; return ans ; }
Ref: 
def minDifference ( x , y , k , b , c ) : NEW_LINE INDENT if ( x >= n or y >= m ) : NEW_LINE INDENT return INT_MAX ; NEW_LINE DEDENT if ( x == n - 1 and y == m - 1 ) : NEW_LINE INDENT diff = b [ x ] [ y ] - c [ x ] [ y ] ; NEW_LINE return min ( abs ( k - diff ) , abs ( k + diff ) ) ; NEW_LINE DEDENT ans = dp [ x ] [ y ] [ k ] ; NEW_LINE if ( ans != - 1 ) : NEW_LINE INDENT return ans ; NEW_LINE DEDENT ans = INT_MAX ; NEW_LINE diff = b [ x ] [ y ] - c [ x ] [ y ] ; NEW_LINE ans = min ( ans , minDifference ( x + 1 , y , abs ( k + diff ) , b , c ) ) ; NEW_LINE ans = min ( ans , minDifference ( x , y + 1 , abs ( k + diff ) , b , c ) ) ; NEW_LINE ans = min ( ans , minDifference ( x + 1 , y , abs ( k - diff ) , b , c ) ) ; NEW_LINE ans = min ( ans , minDifference ( x , y + 1 , abs ( k - diff ) , b , c ) ) ; NEW_LINE return ans ; NEW_LINE DEDENT
Hyp: 
def minDifference ( x , y , k , b , c ) : NEW_LINE INDENT if ( x >= n or y >= m ) : NEW_LINE INDENT return INT_MAX NEW_LINE DEDENT if ( x == n - 1 and y == m - 1 ) : NEW_LINE INDENT diff = b [ x ] [ y ] - c [ x ] [ y ] NEW_LINE return min ( abs ( k - diff ) , abs ( k + diff ) ) NEW_LINE DEDENT ans = dp [ x ] [ y ] [ k ] NEW_LINE if ( ans != - 1 ) : NEW_LINE INDENT return ans NEW_LINE DEDENT ans = INT_MAX NEW_LINE diff = b [ x ] [ y ] - c [ x ] [ y ] NEW_LINE ans = min ( ans , minDifference ( x + 1 , y , abs ( k + diff ) , b , c ) ) NEW_LINE ans = min ( ans , minDifference ( x + 1 , y , abs ( k - diff ) , b , c ) ) NEW_LINE ans = min ( ans , minDifference ( x , y + 1 , abs ( k - diff ) , b , c ) ) NEW_LINE return ans NEW_LINE DEDENT

BLEU: 77.49
Edit Sim: 108


Src: 
int nswp ( int n ) { if ( n == 0 n == 1 ) return 1 ; return 2 * nswp ( n - 1 ) + nswp ( n - 2 ) ; }
Ref: 
def nswp ( n ) : NEW_LINE INDENT if n == 0 or n == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 2 * nswp ( n - 1 ) + nswp ( n - 2 ) NEW_LINE DEDENT
Hyp: 
def nswp ( n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 2 * nswp ( n - 1 ) + nswp ( n - 2 ) NEW_LINE DEDENT

BLEU: 87.91
Edit Sim: 4


Src: 
int getPairsCount ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = arr [ i ] - ( i % arr [ i ] ) ; j < n ; j += arr [ i ] ) { if ( i < j && Math . abs ( arr [ i ] - arr [ j ] ) >= Math . min ( arr [ i ] , arr [ j ] ) ) { count ++ ; } } } return count ; }
Ref: 
def getPairsCount ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( arr [ i ] - ( i % arr [ i ] ) , n , arr [ i ] ) : NEW_LINE INDENT if ( i < j and abs ( arr [ i ] - arr [ j ] ) >= min ( arr [ i ] , arr [ j ] ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
Hyp: 
def getPairsCount ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( arr [ i ] - ( i % arr [ i ] ) , n , arr [ i ] ) : NEW_LINE INDENT if ( i < j and abs ( arr [ i ] - arr [ j ] ) >= min ( arr [ i ] , arr [ j ] ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int zigzag ( int n , int k ) { int dp [ ] [ ] = new int [ n + 1 ] [ k + 1 ] ; dp [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= Math . min ( i , k ) ; j ++ ) dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ i - j ] ; } return dp [ n ] [ k ] ; }
Ref: 
def zigzag ( n , k ) : NEW_LINE INDENT dp = [ [ 0 for x in range ( k + 1 ) ] for y in range ( n + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = 0 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , k + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ i - j ] ) NEW_LINE DEDENT DEDENT return dp [ n ] [ k ] NEW_LINE DEDENT
Hyp: 
def zigzag ( n , k ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( k + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = 0 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , min ( i , k ) + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ i - j ] ) NEW_LINE DEDENT DEDENT return dp [ n ] [ k ] NEW_LINE DEDENT

BLEU: 91.81
Edit Sim: 14


Src: 
void printmaxSubseq ( int arr [ ] , int n ) { int i ; for ( i = 0 ; i < n ; i ++ ) { if ( i + 1 < n && arr [ i ] < arr [ i + 1 ] ) System . out . print ( arr [ i ] + " ▁ " ) ; else System . out . print ( arr [ i ] + "NEW_LINE"); } }
Ref: 
def printmaxSubseq ( arr , n ) : NEW_LINE INDENT for i in range ( n - 1 ) : NEW_LINE INDENT if ( arr [ i ] < arr [ i + 1 ] ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( arr [ i ] ) ; NEW_LINE DEDENT DEDENT print ( arr [ n - 1 ] ) ; NEW_LINE DEDENT
Hyp: 
def printmaxSubseq ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( i + 1 < n and arr [ i ] < arr [ i + 1 ] ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT

BLEU: 71.54
Edit Sim: 68


Src: 
void LowerHessenbergMatrix ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( j > i + 1 ) System . out . print ( '0' + " ▁ " ) ; else { System . out . printf ( " % .0f " , Math . random ( ) * 10 ) ; System . out . print ( " ▁ " ) ; } } System . out . println ( "NEW_LINE"); } }
Ref: 
def UpperHessenbergMatrix ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( j > i + 1 ) : NEW_LINE INDENT print ( '0' , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( random . randint ( 1 , 10 ) , end = " ▁ " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT
Hyp: 
def LowerHessenbergMatrix ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( j > i + 1 ) : NEW_LINE INDENT print ( '0' , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " % .0f " , random ( ) * 10 ) NEW_LINE DEDENT print ( " ▁ " ) NEW_LINE DEDENT DEDENT print ( " " ) NEW_LINE DEDENT DEDENT

BLEU: 78.62
Edit Sim: 42


Src: 
boolean check ( String s ) { int n = s . length ( ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( s . charAt ( i ) > s . charAt ( i + 1 ) ) return true ; } return false ; }
Ref: 
def check ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( s [ i ] > s [ i + 1 ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
Hyp: 
def check ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( s [ i ] > s [ i + 1 ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int minPossibleValue ( int N , int K , int X ) { for ( int i = 1 ; i <= N ; i ++ ) { if ( X <= K ) { X = X * 2 ; } else { X = X + K ; } } return X ; }
Ref: 
def minPossibleValue ( N , K , X ) : NEW_LINE INDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( X <= K ) : NEW_LINE INDENT X = X * 2 ; NEW_LINE DEDENT else : NEW_LINE INDENT X = X + K ; NEW_LINE DEDENT DEDENT return X ; NEW_LINE DEDENT
Hyp: 
def minPossibleValue ( N , K , X ) : NEW_LINE INDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( X <= K ) : NEW_LINE INDENT X = X * 2 NEW_LINE DEDENT else : NEW_LINE INDENT X = X + K NEW_LINE DEDENT DEDENT return X NEW_LINE DEDENT

BLEU: 87.69
Edit Sim: 6


Src: 
boolean ispalindrome ( String s ) { int l = s . length ( ) ; for ( int i = 0 , j = l - 1 ; i <= j ; i ++ , j -- ) { if ( s . charAt ( i ) != s . charAt ( j ) ) { return false ; } } return true ; }
Ref: 
def ispalindrome ( s ) : NEW_LINE INDENT l = len ( s ) NEW_LINE i = 0 NEW_LINE j = l - 1 NEW_LINE while i <= j : NEW_LINE INDENT if ( s [ i ] != s [ j ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT
Hyp: 
def ispalindrome ( s ) : NEW_LINE INDENT l = len ( s ) NEW_LINE for i in range ( l - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( s [ i ] != s [ j ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT

BLEU: 63.22
Edit Sim: 64


Src: 
int countSubArrays ( int arr [ ] , int n , int K ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { int bitwise_or = 0 ; for ( int k = i ; k <= j ; k ++ ) { bitwise_or = bitwise_or | arr [ k ] ; } if ( bitwise_or >= K ) count ++ ; } } return count ; }
Ref: 
def countSubArrays ( arr , n , K ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT bitwise_or = 0 NEW_LINE for k in range ( i , j + 1 ) : NEW_LINE INDENT bitwise_or = bitwise_or | arr [ k ] NEW_LINE DEDENT if ( bitwise_or >= K ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
Hyp: 
def countSubArrays ( arr , n , K ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT bitwise_or = 0 NEW_LINE for k in range ( i , j + 1 ) : NEW_LINE INDENT bitwise_or = bitwise_or | arr [ k ] NEW_LINE DEDENT if ( bitwise_or >= K ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT

BLEU: 97.08
Edit Sim: 2


Src: 
boolean checkIndices ( int Arr [ ] , int N ) { for ( int i = 0 ; i < N - 1 ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( Arr [ i ] != Arr [ j ] ) { if ( Arr [ Arr [ i ] - 1 ] == Arr [ Arr [ j ] - 1 ] ) return true ; } } } return false ; }
Ref: 
def checkIndices ( Arr , N ) : NEW_LINE INDENT for i in range ( N - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT if ( Arr [ i ] != Arr [ j ] ) : NEW_LINE INDENT if ( Arr [ Arr [ i ] - 1 ] == Arr [ Arr [ j ] - 1 ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT DEDENT return False NEW_LINE DEDENT
Hyp: 
def checkIndices ( Arr , N ) : NEW_LINE INDENT for i in range ( N - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT if ( Arr [ i ] != Arr [ j ] ) : NEW_LINE INDENT if ( Arr [ Arr [ i ] - 1 ] == Arr [ Arr [ j ] - 1 ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT DEDENT return False NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
void sumOfMedians ( int arr [ ] , int N , int K ) { int selectMedian = ( K + 1 ) / 2 ; int totalArrays = N / K ; int minSum = 0 ; int i = selectMedian - 1 ; while ( i < N && totalArrays != 0 ) { minSum = minSum + arr [ i ] ; i = i + selectMedian ; totalArrays -- ; } System . out . println ( minSum ) ; }
Ref: 
def sumOfMedians ( arr , N , K ) : NEW_LINE INDENT selectMedian = ( K + 1 ) // 2 NEW_LINE totalArrays = N // K NEW_LINE minSum = 0 NEW_LINE i = selectMedian - 1 NEW_LINE while ( i < N and totalArrays != 0 ) : NEW_LINE INDENT minSum = minSum + arr [ i ] NEW_LINE i = i + selectMedian NEW_LINE totalArrays -= 1 NEW_LINE DEDENT print ( minSum ) NEW_LINE DEDENT
Hyp: 
def sumOfMedians ( arr , N , K ) : NEW_LINE INDENT selectMedian = ( K + 1 ) // 2 NEW_LINE totalArrays = N // K NEW_LINE minSum = 0 NEW_LINE i = selectMedian - 1 NEW_LINE while i < N and totalArrays != 0 : NEW_LINE INDENT minSum = minSum + arr [ i ] NEW_LINE i = i + selectMedian NEW_LINE totalArrays -= 1 NEW_LINE DEDENT print ( minSum ) NEW_LINE DEDENT

BLEU: 93.36
Edit Sim: 4


Src: 
int difference ( int arr [ ] [ ] , int n ) { int d1 = 0 , d2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { d1 += arr [ i ] [ i ] ; d2 += arr [ i ] [ n - i - 1 ] ; } return Math . abs ( d1 - d2 ) ; }
Ref: 
def difference ( arr , n ) : NEW_LINE INDENT d1 = 0 NEW_LINE d2 = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT d1 = d1 + arr [ i ] [ i ] NEW_LINE d2 = d2 + arr [ i ] [ n - i - 1 ] NEW_LINE DEDENT return abs ( d1 - d2 ) NEW_LINE DEDENT
Hyp: 
def difference ( arr , n ) : NEW_LINE INDENT d1 = 0 NEW_LINE d2 = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT d1 += arr [ i ] [ i ] NEW_LINE d2 += arr [ i ] [ n - i - 1 ] NEW_LINE DEDENT return abs ( d1 - d2 ) ; NEW_LINE DEDENT

BLEU: 84.55
Edit Sim: 14


Src: 
void print_result ( int a [ ] , int n , int k , int m ) { Vector < Vector < Integer > > v = new Vector < Vector < Integer > > ( m ) ; for ( int i = 0 ; i < m ; i ++ ) v . add ( new Vector < Integer > ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) { int rem = a [ i ] % m ; v . get ( rem ) . add ( a [ i ] ) ; if ( v . get ( rem ) . size ( ) == k ) { for ( int j = 0 ; j < k ; j ++ ) System . out . print ( v . get ( rem ) . get ( j ) + " ▁ " ) ; return ; } } System . out . print ( " - 1" ) ; }
Ref: 
def print_result ( a , n , k , m ) : NEW_LINE INDENT v = [ [ ] for i in range ( m ) ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT rem = a [ i ] % m NEW_LINE v [ rem ] . append ( a [ i ] ) NEW_LINE if ( len ( v [ rem ] ) == k ) : NEW_LINE INDENT for j in range ( 0 , k ) : NEW_LINE INDENT print ( v [ rem ] [ j ] , end = " ▁ " ) NEW_LINE DEDENT return NEW_LINE DEDENT DEDENT print ( - 1 ) NEW_LINE DEDENT
Hyp: 
def print_result ( a , n , k , m ) : NEW_LINE INDENT v = [ ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT v . append ( list ( ) ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT rem = a [ i ] % m NEW_LINE v . append ( a [ i ] ) NEW_LINE if ( len ( v ) == k ) : NEW_LINE INDENT for j in range ( k ) : NEW_LINE INDENT print ( v [ rem ] [ j ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT print ( " - 1" ) NEW_LINE DEDENT

BLEU: 76.68
Edit Sim: 100


Src: 
int oddEquivalent ( String s , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == '1' ) count ++ ; } return count ; }
Ref: 
def oddEquivalent ( s , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
Hyp: 
def oddEquivalent ( s , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT

BLEU: 83.36
Edit Sim: 13


Src: 
int cost ( String str ) { int len = str . length ( ) ; int res = 0 ; for ( int i = 0 , j = len - 1 ; i < j ; i ++ , j -- ) if ( str . charAt ( i ) != str . charAt ( j ) ) res += Math . min ( str . charAt ( i ) , str . charAt ( j ) ) - ' a ' + 1 ; return res ; }
Ref: 
def cost ( st ) : NEW_LINE INDENT l = len ( st ) NEW_LINE res = 0 NEW_LINE j = l - 1 NEW_LINE i = 0 NEW_LINE while ( i < j ) : NEW_LINE INDENT if ( st [ i ] != st [ j ] ) : NEW_LINE INDENT res += ( min ( ord ( st [ i ] ) , ord ( st [ j ] ) ) - ord ( ' a ' ) + 1 ) NEW_LINE DEDENT i = i + 1 NEW_LINE j = j - 1 NEW_LINE DEDENT return res NEW_LINE DEDENT
Hyp: 
def cost ( str ) : NEW_LINE INDENT ln = len ( str ) NEW_LINE res = 0 NEW_LINE for i in range ( 0 , ln - 1 ) : NEW_LINE INDENT for j in range ( 0 , ln - 1 ) : NEW_LINE INDENT if ( str [ i ] != str [ j ] ) : NEW_LINE INDENT res += min ( str [ i ] , str [ j ] ) - ord ( ' a ' ) + 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT

BLEU: 42.46
Edit Sim: 115


Src: 
boolean isicositrigonal ( int N ) { float n = ( float ) ( 19 + Math . sqrt ( 168 * N + 361 ) ) / 42 ; return ( n - ( int ) n ) == 0 ; }
Ref: 
def isicositrigonal ( N ) : NEW_LINE INDENT n = ( 19 + math . sqrt ( 168 * N + 361 ) ) / 42 NEW_LINE return ( n - int ( n ) ) == 0 NEW_LINE DEDENT i = 23 NEW_LINE if ( isicositrigonal ( i ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
Hyp: 
def isicositrigonal ( N ) : NEW_LINE INDENT n = ( 19 + math . sqrt ( 168 * N + 361 ) ) / 42 NEW_LINE return ( n - int ( n ) ) == 0 NEW_LINE DEDENT i = 21 NEW_LINE if isicositrigonal ( i ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT

BLEU: 91.0
Edit Sim: 5


Src: 
void findXOR ( int mat [ ] [ ] [ ] , int N ) { int XOR = 0 ; for ( int i = 0 ; i < N ; i ++ ) { XOR ^= mat [ i ] [ i ] [ i ] ; XOR ^= mat [ i ] [ i ] [ N - i - 1 ] ; } System . out . println ( XOR ) ; }
Ref: 
def findXOR ( mat , N ) : NEW_LINE INDENT XOR = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT XOR ^= mat [ i ] [ i ] [ i ] NEW_LINE XOR ^= mat [ i ] [ i ] [ N - i - 1 ] NEW_LINE DEDENT print ( XOR ) NEW_LINE DEDENT
Hyp: 
def findXOR ( mat , N ) : NEW_LINE INDENT XOR = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT XOR ^= mat [ i ] [ i ] NEW_LINE XOR ^= mat [ i ] [ i ] [ N - i - 1 ] NEW_LINE DEDENT print ( XOR ) NEW_LINE DEDENT

BLEU: 94.96
Edit Sim: 6


Src: 
long multiplyFactors ( int n ) { long prod = 1 ; for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) prod = ( prod * i ) % M ; else { prod = ( prod * i ) % M ; prod = ( prod * n / i ) % M ; } } } return prod ; }
Ref: 
def multiplyFactors ( n ) : NEW_LINE INDENT prod = 1 NEW_LINE i = 1 NEW_LINE while i * i <= n : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( n / i == i ) : NEW_LINE INDENT prod = ( prod * i ) % M NEW_LINE DEDENT else : NEW_LINE INDENT prod = ( prod * i ) % M NEW_LINE prod = ( prod * n / i ) % M NEW_LINE DEDENT DEDENT i = i + 1 NEW_LINE DEDENT return prod NEW_LINE DEDENT
Hyp: 
def multiplyFactors ( n ) : NEW_LINE INDENT prod = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( n // i == i ) : NEW_LINE INDENT prod = ( prod * i ) % M NEW_LINE DEDENT else : NEW_LINE INDENT prod = ( prod * i ) % M NEW_LINE DEDENT else : NEW_LINE INDENT prod = ( prod * n / i ) % M NEW_LINE DEDENT DEDENT DEDENT return prod NEW_LINE DEDENT

BLEU: 77.82
Edit Sim: 73


Src: 
int interpolationSearch ( int arr [ ] , int lo , int hi , int x ) { int pos ; if ( lo <= hi && x >= arr [ lo ] && x <= arr [ hi ] ) { pos = lo + ( ( ( hi - lo ) / ( arr [ hi ] - arr [ lo ] ) ) * ( x - arr [ lo ] ) ) ; if ( arr [ pos ] == x ) return pos ; if ( arr [ pos ] < x ) return interpolationSearch ( arr , pos + 1 , hi , x ) ; if ( arr [ pos ] > x ) return interpolationSearch ( arr , lo , pos - 1 , x ) ; } return - 1 ; }
Ref: 
def interpolationSearch ( arr , lo , hi , x ) : NEW_LINE INDENT if ( lo <= hi and x >= arr [ lo ] and x <= arr [ hi ] ) : NEW_LINE INDENT pos = lo + ( ( hi - lo ) // ( arr [ hi ] - arr [ lo ] ) * ( x - arr [ lo ] ) ) NEW_LINE if arr [ pos ] == x : NEW_LINE INDENT return pos NEW_LINE DEDENT if arr [ pos ] < x : NEW_LINE INDENT return interpolationSearch ( arr , pos + 1 , hi , x ) NEW_LINE DEDENT if arr [ pos ] > x : NEW_LINE INDENT return interpolationSearch ( arr , lo , pos - 1 , x ) NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ 10 , 12 , 13 , 16 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 33 , 35 , 42 , 47 ] NEW_LINE n = len ( arr ) NEW_LINE x = 18 NEW_LINE index = interpolationSearch ( arr , 0 , n - 1 , x ) NEW_LINE if index != - 1 : NEW_LINE INDENT print ( " Element ▁ found ▁ at ▁ index " , index ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Element ▁ not ▁ found " ) NEW_LINE DEDENT
Hyp: 
def interpolationSearch ( arr , lo , hi , x ) : NEW_LINE INDENT pos = lo + ( ( ( hi - lo ) // ( arr [ hi ] - arr [ lo ] ) ) * ( x - arr [ lo ] ) ) NEW_LINE if arr [ pos ] == x : NEW_LINE INDENT return pos NEW_LINE DEDENT if arr [ pos ] < x : NEW_LINE INDENT return interpolationSearch ( arr , pos + 1 , hi , x ) NEW_LINE DEDENT if arr [ pos ] > x : NEW_LINE INDENT return interpolationSearch ( arr , lo , pos - 1 , x ) NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT

BLEU: 35.4
Edit Sim: 448


Src: 
int findNum ( int N , int K ) { int rem = ( N + K ) % K ; if ( rem == 0 ) return N ; else return N + K - rem ; }
Ref: 
def findNum ( N , K ) : NEW_LINE INDENT rem = ( N + K ) % K ; NEW_LINE if ( rem == 0 ) : NEW_LINE INDENT return N NEW_LINE DEDENT else : NEW_LINE INDENT return ( N + K - rem ) NEW_LINE DEDENT DEDENT
Hyp: 
def findNum ( N , K ) : NEW_LINE INDENT rem = ( N + K ) % K NEW_LINE if ( rem == 0 ) : NEW_LINE INDENT return N NEW_LINE DEDENT else : NEW_LINE INDENT return N + K - rem NEW_LINE DEDENT DEDENT

BLEU: 83.94
Edit Sim: 6


Src: 
String even_or_odd ( String N ) { int len = N . length ( ) ; if ( N . charAt ( len - 1 ) == '0' || N . charAt ( len - 1 ) == '2' || N . charAt ( len - 1 ) == '4' || N . charAt ( len - 1 ) == '6' ) return ( " Even " ) ; else return ( " Odd " ) ; }
Ref: 
def even_or_odd ( N ) : NEW_LINE INDENT l = len ( N ) ; NEW_LINE if ( N [ l - 1 ] == '0' or N [ l - 1 ] == '2' or N [ l - 1 ] == '4' or N [ l - 1 ] == '6' ) : NEW_LINE INDENT return ( " Even " ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( " Odd " ) NEW_LINE DEDENT DEDENT
Hyp: 
def even_or_odd ( N ) : NEW_LINE INDENT l = len ( N ) NEW_LINE if ( N [ l - 1 ] == '0' or N [ l - 1 ] == '2' or N [ l - 1 ] == '4' or N [ l - 1 ] == '6' ) : NEW_LINE INDENT return ( " Even " ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( " Odd " ) NEW_LINE DEDENT DEDENT

BLEU: 96.74
Edit Sim: 2


Src: 
int lastPosition ( int n , int m , int k ) { if ( m <= n - k + 1 ) return m + k - 1 ; m = m - ( n - k + 1 ) ; return ( m % n == 0 ) ? n : ( m % n ) ; }
Ref: 
def lastPosition ( n , m , k ) : NEW_LINE INDENT if ( m <= n - k + 1 ) : NEW_LINE return m + k - 1 NEW_LINE m = m - ( n - k + 1 ) NEW_LINE if ( m % n == 0 ) : NEW_LINE INDENT return n NEW_LINE DEDENT else : NEW_LINE INDENT return m % n NEW_LINE DEDENT DEDENT
Hyp: 
def lastPosition ( n , m , k ) : NEW_LINE INDENT if ( m <= n - k + 1 ) : NEW_LINE INDENT return m + k - 1 NEW_LINE DEDENT m = m - ( n - k + 1 ) NEW_LINE return ( m % n == 0 ) else ( m % n ) NEW_LINE DEDENT

BLEU: 72.92
Edit Sim: 95


Src: 
boolean isDivisible ( long n ) { while ( n / 100 > 0 ) { long d = n % 10 ; n /= 10 ; n -= d * 5 ; } return ( n % 17 == 0 ) ; }
Ref: 
def isDivisible ( n ) : NEW_LINE INDENT while ( n // 100 ) : NEW_LINE INDENT d = n % 10 NEW_LINE n //= 10 NEW_LINE n -= d * 5 NEW_LINE DEDENT return ( n % 17 == 0 ) NEW_LINE DEDENT
Hyp: 
def isDivisible ( n ) : NEW_LINE INDENT while ( n // 100 > 0 ) : NEW_LINE INDENT d = n % 10 NEW_LINE n //= 10 NEW_LINE n -= d * 5 NEW_LINE DEDENT return ( n % 17 == 0 ) NEW_LINE DEDENT n = 18 NEW_LINE if ( isDivisible ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT

BLEU: 52.76
Edit Sim: 153


Src: 
int largestNum ( int n ) { int num = 0 ; for ( int i = 0 ; i <= 32 ; i ++ ) { int x = ( 1 << i ) ; if ( ( x - 1 ) <= n ) num = ( 1 << i ) - 1 ; else break ; } return num ; }
Ref: 
def largestNum ( n ) : NEW_LINE INDENT num = 0 ; NEW_LINE for i in range ( 32 ) : NEW_LINE INDENT x = ( 1 << i ) ; NEW_LINE if ( ( x - 1 ) <= n ) : NEW_LINE INDENT num = ( 1 << i ) - 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT return num ; NEW_LINE DEDENT
Hyp: 
def largestNum ( n ) : NEW_LINE INDENT num = 0 NEW_LINE for i in range ( 32 ) : NEW_LINE INDENT x = ( 1 << i ) NEW_LINE if ( ( x - 1 ) <= n ) : NEW_LINE INDENT num = ( 1 << i ) - 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return num NEW_LINE DEDENT

BLEU: 81.96
Edit Sim: 10


Src: 
int maxSum ( int n ) { if ( n == 1 ) return 1 ; else return ( n * ( n - 1 ) / 2 ) - 1 + n / 2 ; }
Ref: 
def maxSum ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return int ( ( n * ( n - 1 ) / 2 ) - 1 + n / 2 ) NEW_LINE DEDENT DEDENT
Hyp: 
def maxSum ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return ( n * ( n - 1 ) / 2 ) - 1 + n / 2 NEW_LINE DEDENT DEDENT

BLEU: 87.26
Edit Sim: 8


Src: 
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
Ref: 
def gcd ( a , b ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT
Hyp: 
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT

BLEU: 84.53
Edit Sim: 4


Src: 
void printRepeating ( int arr [ ] , int size ) { int i , j ; System . out . println ( " Repeated ▁ Elements ▁ are ▁ : " ) ; for ( i = 0 ; i < size ; i ++ ) { for ( j = i + 1 ; j < size ; j ++ ) { if ( arr [ i ] == arr [ j ] ) System . out . print ( arr [ i ] + " ▁ " ) ; } } }
Ref: 
def printRepeating ( arr , size ) : NEW_LINE INDENT print ( " Repeating ▁ elements ▁ are ▁ " , end = ' ' ) NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT for j in range ( i + 1 , size ) : NEW_LINE INDENT if arr [ i ] == arr [ j ] : NEW_LINE INDENT print ( arr [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
Hyp: 
def printRepeating ( arr , size ) : NEW_LINE INDENT print ( " Repeated ▁ Elements ▁ are ▁ : " ) NEW_LINE for i in range ( size ) : NEW_LINE INDENT for j in range ( i + 1 , size ) : NEW_LINE INDENT if ( arr [ i ] == arr [ j ] ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT DEDENT

BLEU: 72.81
Edit Sim: 26


Src: 
int countXorPair ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) if ( ( arr [ i ] ^ arr [ j ] ) % 2 == 1 ) count ++ ; } return count ; }
Ref: 
def countXorPair ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( ( arr [ i ] ^ arr [ j ] ) % 2 == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
Hyp: 
def countXorPair ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( ( arr [ i ] ^ arr [ j ] ) % 2 == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
float maxVol ( float P , float A ) { float l = ( float ) ( P - Math . sqrt ( P * P - 24 * A ) ) / 12 ; float V = ( float ) ( l * ( A / 2.0 - l * ( P / 4.0 - l ) ) ) ; return V ; }
Ref: 
def maxVol ( P , A ) : NEW_LINE INDENT l = ( P - sqrt ( P * P - 24 * A ) ) / 12 NEW_LINE V = l * ( A / 2.0 - l * ( P / 4.0 - l ) ) NEW_LINE return V NEW_LINE DEDENT
Hyp: 
def maxVol ( P , A ) : NEW_LINE INDENT l = ( P - math . sqrt ( P * P - 24 * A ) ) / 12 NEW_LINE V = ( l * ( A / 2.0 - l * ( P / 4.0 - l ) ) ) NEW_LINE return V NEW_LINE DEDENT

BLEU: 86.94
Edit Sim: 11


Src: 
double sumOfSeries ( int n ) { return 0.0246 * ( Math . pow ( 10 , n ) - 1 - ( 9 * n ) ) ; }
Ref: 
def sumOfSeries ( n ) : NEW_LINE INDENT return 0.0246 * ( math . pow ( 10 , n ) - 1 - ( 9 * n ) ) NEW_LINE DEDENT
Hyp: 
def sumOfSeries ( n ) : NEW_LINE INDENT return 0.0246 * ( pow ( 10 , n ) - 1 - ( 9 * n ) ) NEW_LINE DEDENT

BLEU: 88.19
Edit Sim: 7


Src: 
void sub_segments ( String str , int n ) { int l = str . length ( ) ; for ( int x = 0 ; x < l ; x += n ) { String newlist = str . substring ( x , x + n ) ; List < Character > arr = new ArrayList < Character > ( ) ; for ( char y : newlist . toCharArray ( ) ) { if ( ! arr . contains ( y ) ) arr . add ( y ) ; } for ( char y : arr ) System . out . print ( y ) ; System . out . println ( ) ; } }
Ref: 
def sub_segments ( string , n ) : NEW_LINE INDENT l = len ( string ) NEW_LINE for x in range ( 0 , l , n ) : NEW_LINE INDENT newlist = string [ x : x + n ] NEW_LINE arr = [ ] NEW_LINE for y in newlist : NEW_LINE INDENT if y not in arr : NEW_LINE INDENT arr . append ( y ) NEW_LINE DEDENT DEDENT print ( ' ' . join ( arr ) ) NEW_LINE DEDENT DEDENT
Hyp: 
def sub_segments ( string , n ) : NEW_LINE INDENT l = len ( string ) NEW_LINE x = 0 NEW_LINE while x < l : NEW_LINE INDENT newlist = string [ x : x + n ] NEW_LINE arr = [ ] NEW_LINE for y in newlist : NEW_LINE INDENT if y not in arr : NEW_LINE INDENT arr . append ( y ) NEW_LINE DEDENT DEDENT print ( * arr ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT

BLEU: 75.66
Edit Sim: 53


Src: 
void equation_plane ( int x1 , int y1 , int z1 , int x2 , int y2 , int z2 , int x3 , int y3 , int z3 , int x , int y , int z ) { int a1 = x2 - x1 ; int b1 = y2 - y1 ; int c1 = z2 - z1 ; int a2 = x3 - x1 ; int b2 = y3 - y1 ; int c2 = z3 - z1 ; int a = b1 * c2 - b2 * c1 ; int b = a2 * c1 - a1 * c2 ; int c = a1 * b2 - b1 * a2 ; int d = ( - a * x1 - b * y1 - c * z1 ) ; if ( a * x + b * y + c * z + d == 0 ) System . out . println ( " Coplanar " ) ; else System . out . println ( " Not ▁ Coplanar " ) ; }
Ref: 
def equation_plane ( x1 , y1 , z1 , x2 , y2 , z2 , x3 , y3 , z3 , x , y , z ) : NEW_LINE INDENT a1 = x2 - x1 NEW_LINE b1 = y2 - y1 NEW_LINE c1 = z2 - z1 NEW_LINE a2 = x3 - x1 NEW_LINE b2 = y3 - y1 NEW_LINE c2 = z3 - z1 NEW_LINE a = b1 * c2 - b2 * c1 NEW_LINE b = a2 * c1 - a1 * c2 NEW_LINE c = a1 * b2 - b1 * a2 NEW_LINE d = ( - a * x1 - b * y1 - c * z1 ) NEW_LINE if ( a * x + b * y + c * z + d == 0 ) : NEW_LINE INDENT print ( " Coplanar " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ Coplanar " ) NEW_LINE DEDENT DEDENT
Hyp: 
def equation_plane ( x1 , y1 , z1 , x2 , y2 , z2 , x3 , y3 , z3 , x , y , z ) : NEW_LINE INDENT a1 = x2 - x1 NEW_LINE b1 = y2 - y1 NEW_LINE c1 = z2 - z1 NEW_LINE a2 = x3 - x1 NEW_LINE b2 = y3 - y1 NEW_LINE c2 = z3 - z1 NEW_LINE a = b1 * c2 - b2 * c1 NEW_LINE b = a1 * b2 - a1 * b2 NEW_LINE c = a1 * b2 - a1 * a2 NEW_LINE d = ( - a * x1 - b * y1 - c * z1 ) NEW_LINE if ( a * x + b * y + c * z + d == 0 ) : NEW_LINE INDENT print ( " Coplanar " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ Coplanar " ) NEW_LINE DEDENT DEDENT

BLEU: 94.04
Edit Sim: 5


Src: 
void printPairs ( int arr [ ] , int n ) { Vector < Integer > v = new Vector < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( Math . abs ( arr [ i ] ) == Math . abs ( arr [ j ] ) ) v . add ( Math . abs ( arr [ i ] ) ) ; if ( v . size ( ) == 0 ) return ; Collections . sort ( v ) ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) System . out . print ( - v . get ( i ) + " ▁ " + v . get ( i ) ) ; }
Ref: 
def printPairs ( arr , n ) : NEW_LINE INDENT v = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( abs ( arr [ i ] ) == abs ( arr [ j ] ) ) : NEW_LINE INDENT v . append ( abs ( arr [ i ] ) ) NEW_LINE DEDENT DEDENT DEDENT if ( len ( v ) == 0 ) : NEW_LINE INDENT return ; NEW_LINE DEDENT v . sort ( ) NEW_LINE for i in range ( len ( v ) ) : NEW_LINE INDENT print ( - v [ i ] , " " , v [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
Hyp: 
def printPairs ( arr , n ) : NEW_LINE INDENT v = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( abs ( arr [ i ] ) == abs ( arr [ j ] ) ) : NEW_LINE INDENT v . append ( abs ( arr [ i ] ) ) NEW_LINE DEDENT DEDENT if ( len ( v ) == 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT v = sorted ( v ) NEW_LINE for i in range ( len ( v ) ) : NEW_LINE INDENT print ( - v [ i ] , end = " ▁ " , v [ i ] ) NEW_LINE DEDENT DEDENT

BLEU: 90.09
Edit Sim: 31


Src: 
int sum_star_num ( int n ) { int summ = 2 * n * ( n + 1 ) * ( n - 1 ) + n ; return summ ; }
Ref: 
def sum_star_num ( n ) : NEW_LINE INDENT summ = 2 * n * ( n + 1 ) * ( n - 1 ) + n NEW_LINE return summ NEW_LINE DEDENT
Hyp: 
def sum_star_num ( n ) : NEW_LINE INDENT summ = 2 * n * ( n + 1 ) * ( n - 1 ) + n ; NEW_LINE return summ ; NEW_LINE DEDENT

BLEU: 85.39
Edit Sim: 4


Src: 
int countPairs ( int [ ] A , int [ ] B ) { int n = A . length ; int ans = 0 ; Arrays . sort ( A ) ; Arrays . sort ( B ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( A [ i ] > B [ ans ] ) { ans ++ ; } } return ans ; }
Ref: 
def countPairs ( A , B ) : NEW_LINE INDENT n = len ( A ) NEW_LINE A . sort ( ) NEW_LINE B . sort ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( A [ i ] > B [ ans ] ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
Hyp: 
def countPairs ( A , B ) : NEW_LINE INDENT n = len ( A ) NEW_LINE ans = 0 NEW_LINE A = sorted ( A ) NEW_LINE B = sorted ( B ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( A [ i ] > B [ ans ] ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT

BLEU: 82.76
Edit Sim: 28


Src: 
int countOddPair ( int A [ ] , int N ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( ( A [ i ] % 2 != 1 ) ) { count ++ ; } } int evenPairCount = count * ( count - 1 ) / 2 ; int totPairs = N * ( N - 1 ) / 2 ; return totPairs - evenPairCount ; }
Ref: 
def countOddPair ( A , N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT if ( A [ i ] % 2 != 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT evenPairCount = count * ( count - 1 ) / 2 NEW_LINE totPairs = N * ( N - 1 ) / 2 NEW_LINE return ( int ) ( totPairs - evenPairCount ) NEW_LINE DEDENT
Hyp: 
def countOddPair ( A , N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( A [ i ] % 2 != 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT evenPairCount = count * ( count - 1 ) // 2 NEW_LINE totPairs = N * ( N - 1 ) // 2 NEW_LINE return totPairs - evenPairCount NEW_LINE DEDENT

BLEU: 79.14
Edit Sim: 18


Src: 
float diagonal_length ( float a ) { float L ; L = a * ( float ) Math . sqrt ( 3 ) ; return L ; }
Ref: 
def diagonal_length ( a ) : NEW_LINE INDENT L = 0 NEW_LINE L = a * sqrt ( 3 ) NEW_LINE return L NEW_LINE DEDENT
Hyp: 
def diagonal_length ( a ) : NEW_LINE INDENT L = a * math . sqrt ( 3 ) NEW_LINE return L NEW_LINE DEDENT

BLEU: 75.73
Edit Sim: 15


Src: 
int divisorSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j * j <= i ; ++ j ) { if ( i % j == 0 ) { if ( i / j == j ) sum += j ; else sum += j + i / j ; } } } return sum ; }
Ref: 
def divisorSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT j = 1 NEW_LINE while j * j <= i : NEW_LINE INDENT if i % j == 0 : NEW_LINE INDENT if i / j == j : NEW_LINE INDENT sum += j NEW_LINE DEDENT else : NEW_LINE INDENT sum += j + i / j NEW_LINE DEDENT DEDENT j = j + 1 NEW_LINE DEDENT DEDENT return int ( sum ) NEW_LINE DEDENT
Hyp: 
def divisorSum ( n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( j * j <= i ) : NEW_LINE INDENT if ( i % j == 0 ) : NEW_LINE INDENT if ( i // j == j ) : NEW_LINE INDENT sum += j ; NEW_LINE DEDENT else : NEW_LINE INDENT sum += j + i // j ; NEW_LINE DEDENT DEDENT DEDENT DEDENT return sum ; NEW_LINE DEDENT

BLEU: 54.82
Edit Sim: 80


Src: 
String minInt ( String str ) { String s = " " ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) >= '5' ) { s += ( char ) ( ( '9' - str . charAt ( i ) ) + '0' ) ; } else { s += str . charAt ( i ) ; } } if ( str . charAt ( 0 ) == '0' ) s += '9' ; return s ; }
Ref: 
def minInt ( str1 ) : NEW_LINE INDENT for i in range ( len ( str1 ) ) : NEW_LINE INDENT if ( str1 [ i ] >= 5 ) : NEW_LINE INDENT str1 [ i ] = ( 9 - str1 [ i ] ) NEW_LINE DEDENT DEDENT if ( str1 [ 0 ] == 0 ) : NEW_LINE INDENT str1 [ 0 ] = 9 NEW_LINE DEDENT temp = " " NEW_LINE for i in str1 : NEW_LINE INDENT temp += str ( i ) NEW_LINE DEDENT return temp NEW_LINE DEDENT
Hyp: 
def minInt ( str ) : NEW_LINE INDENT s = " " NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( ord ( str [ i ] ) >= ord ( '5' ) ) : NEW_LINE INDENT s += chr ( ( '9' - ord ( str [ i ] ) ) + '0' ) NEW_LINE DEDENT else : NEW_LINE INDENT s += str [ i ] NEW_LINE DEDENT DEDENT if ( str [ 0 ] == '0' ) : NEW_LINE INDENT s += '9' NEW_LINE DEDENT return s NEW_LINE DEDENT

BLEU: 40.29
Edit Sim: 145


Src: 
void findbitwiseOR ( int [ ] a , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int curr_sub_array = a [ i ] ; res = res | curr_sub_array ; for ( int j = i ; j < n ; j ++ ) { curr_sub_array = curr_sub_array & a [ j ] ; res = res | curr_sub_array ; } } System . out . println ( res ) ; }
Ref: 
def findbitwiseOR ( a , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT curr_sub_array = a [ i ] NEW_LINE res = res | curr_sub_array NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT curr_sub_array = curr_sub_array & a [ j ] NEW_LINE res = res | curr_sub_array NEW_LINE DEDENT DEDENT print ( res ) NEW_LINE DEDENT
Hyp: 
def findbitwiseOR ( a , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT curr_sub_array = a [ i ] NEW_LINE res = res | curr_sub_array NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT curr_sub_array = curr_sub_array & a [ j ] NEW_LINE res = res | curr_sub_array NEW_LINE DEDENT DEDENT print ( res ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int min_moves ( int n ) { int ans = Integer . MAX_VALUE ; for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { ans = Math . min ( ans , i + n / i - 2 ) ; } } return ans ; }
Ref: 
def min_moves ( n ) : NEW_LINE INDENT ans = sys . maxsize ; NEW_LINE for i in range ( 1 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT ans = min ( ans , i + n // i - 2 ) ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT
Hyp: 
def min_moves ( n ) : NEW_LINE INDENT ans = sys . maxsize NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT ans = min ( ans , i + n // i - 2 ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT

BLEU: 76.26
Edit Sim: 23


Src: 
int get_unit_digit ( int N ) { if ( N == 0 N == 1 ) return 1 ; else if ( N == 2 ) return 3 ; else if ( N == 3 ) return 9 ; return 3 ; }
Ref: 
def get_unit_digit ( N ) : NEW_LINE INDENT if ( N == 0 or N == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( N == 2 ) : NEW_LINE INDENT return 3 NEW_LINE DEDENT elif ( N == 3 ) : NEW_LINE INDENT return 9 NEW_LINE DEDENT else : NEW_LINE INDENT return 3 NEW_LINE DEDENT DEDENT N = 1 NEW_LINE for N in range ( 11 ) : NEW_LINE INDENT print ( " For ▁ N ▁ = ▁ " , N , " : " , get_unit_digit ( N ) , sep = ' ▁ ' ) NEW_LINE DEDENT
Hyp: 
def get_unit_digit ( N ) : NEW_LINE INDENT if ( N == 0 or N == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( N == 2 ) : NEW_LINE INDENT return 3 NEW_LINE DEDENT elif ( N == 3 ) : NEW_LINE INDENT return 9 NEW_LINE DEDENT return 3 NEW_LINE DEDENT

BLEU: 39.87
Edit Sim: 178


Src: 
int unitnumber ( int x , int y ) { x = x % 10 ; if ( y != 0 ) y = y % 4 + 4 ; return ( ( ( int ) ( Math . pow ( x , y ) ) ) % 10 ) ; }
Ref: 
def unitnumber ( x , y ) : NEW_LINE INDENT x = x % 10 NEW_LINE if y != 0 : NEW_LINE INDENT y = y % 4 + 4 NEW_LINE DEDENT return ( ( ( int ) ( math . pow ( x , y ) ) ) % 10 ) NEW_LINE DEDENT
Hyp: 
def unitnumber ( x , y ) : NEW_LINE INDENT x = x % 10 NEW_LINE if ( y != 0 ) : NEW_LINE INDENT y = y % 4 + 4 NEW_LINE DEDENT return ( ( int ) ( pow ( x , y ) ) ) % 10 ) NEW_LINE DEDENT

BLEU: 85.46
Edit Sim: 13


Src: 
int minimumPossibleProduct ( int K ) { int res = 1 ; int range = ( 1 << K ) - 1 ; for ( int i = 0 ; i < K ; i ++ ) { res *= ( range - 1 ) ; } res *= range ; return res ; }
Ref: 
def minimumPossibleProduct ( K ) : NEW_LINE INDENT res = 1 NEW_LINE r = ( 1 << K ) - 1 NEW_LINE for i in range ( 0 , K ) : NEW_LINE INDENT res *= ( r - 1 ) NEW_LINE DEDENT res *= r NEW_LINE return res NEW_LINE DEDENT
Hyp: 
def minimumPossibleProduct ( K ) : NEW_LINE INDENT res = 1 NEW_LINE range = ( 1 << K ) - 1 NEW_LINE for i in range ( K ) : NEW_LINE INDENT res *= ( range - 1 ) NEW_LINE DEDENT res *= range NEW_LINE return res NEW_LINE DEDENT

BLEU: 77.41
Edit Sim: 16


Src: 
void decToBinary ( int n ) { int [ ] binaryNum = new int [ 32 ] ; int i = 0 ; while ( n > 0 ) { binaryNum [ i ] = n % 2 ; n = n / 2 ; i ++ ; } for ( int j = i - 1 ; j >= 0 ; j -- ) System . out . print ( binaryNum [ j ] ) ; }
Ref: 
def decToBinary ( n ) : NEW_LINE INDENT binaryNum = [ 0 ] * n ; NEW_LINE i = 0 ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT binaryNum [ i ] = n % 2 ; NEW_LINE n = int ( n / 2 ) ; NEW_LINE i += 1 ; NEW_LINE DEDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( binaryNum [ j ] , end = " " ) ; NEW_LINE DEDENT DEDENT
Hyp: 
def decToBinary ( n ) : NEW_LINE INDENT binaryNum = [ 0 ] * 32 NEW_LINE i = 0 NEW_LINE while ( n ) : NEW_LINE INDENT binaryNum [ i ] = n % 2 NEW_LINE n = n // 2 NEW_LINE i += 1 NEW_LINE DEDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( binaryNum [ j ] ) NEW_LINE DEDENT DEDENT

BLEU: 63.9
Edit Sim: 37


Src: 
int maxSelectionCount ( int a [ ] , int n ) { int res = 0 ; Arrays . sort ( a ) ; int select = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] >= select ) { res ++ ; select ++ ; } } return res ; }
Ref: 
def maxSelectionCount ( a , n ) : NEW_LINE INDENT res = 0 ; NEW_LINE a . sort ( ) ; NEW_LINE select = 1 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] >= select ) : NEW_LINE DEDENT DEDENT res += 1 ; NEW_LINE select += 1 ; NEW_LINE INDENT return res ; NEW_LINE DEDENT
Hyp: 
def maxSelectionCount ( a , n ) : NEW_LINE INDENT res = 0 NEW_LINE a . sort ( ) NEW_LINE select = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] >= select ) : NEW_LINE INDENT res += 1 NEW_LINE select += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT

BLEU: 70.68
Edit Sim: 28


Src: 
int minApples ( int M , int K , int N , int S , int W , int E ) { if ( M <= S * K ) return M ; else if ( M <= S * K + E + W ) return S * K + ( M - S * K ) * K ; else return - 1 ; }
Ref: 
def minApples ( ) : NEW_LINE INDENT if M <= S * K : NEW_LINE INDENT return M NEW_LINE DEDENT elif M <= S * K + E + W : NEW_LINE INDENT return S * K + ( M - S * K ) * K NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT
Hyp: 
def minApples ( M , K , N , S , W , E ) : NEW_LINE INDENT if ( M <= S * K ) : NEW_LINE INDENT return M NEW_LINE DEDENT elif ( M <= S * K + E + W ) : NEW_LINE INDENT return S * K + ( M - S * K ) * K NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT

BLEU: 68.79
Edit Sim: 30


Src: 
int count_rectangles ( int N , int M ) { int p_x = ( N * ( N - 1 ) ) / 2 ; int p_y = ( M * ( M - 1 ) ) / 2 ; return p_x * p_y ; }
Ref: 
def count_rectangles ( N , M ) : NEW_LINE INDENT p_x = ( N * ( N - 1 ) ) // 2 NEW_LINE p_y = ( M * ( M - 1 ) ) // 2 NEW_LINE return p_x * p_y NEW_LINE DEDENT
Hyp: 
def count_rectangles ( N , M ) : NEW_LINE INDENT p_x = ( N * ( N - 1 ) ) / 2 NEW_LINE p_y = ( M * ( M - 1 ) ) / 2 NEW_LINE return p_x * p_y NEW_LINE DEDENT

BLEU: 88.2
Edit Sim: 2


Src: 
boolean isDivisible ( int n ) { int d ; while ( ( n / 100 ) <= 0 ) { d = n % 10 ; n /= 10 ; n = Math . abs ( n - ( d * 7 ) ) ; } return ( n % 71 == 0 ) ; }
Ref: 
def isDivisible ( n ) : NEW_LINE INDENT while n // 100 : NEW_LINE INDENT d = n % 10 NEW_LINE n //= 10 NEW_LINE n = abs ( n - ( d * 7 ) ) NEW_LINE DEDENT return ( n % 71 == 0 ) NEW_LINE DEDENT
Hyp: 
def isDivisible ( n ) : NEW_LINE INDENT while ( n // 100 <= 0 ) : NEW_LINE INDENT d = n % 10 NEW_LINE n //= 10 NEW_LINE n = abs ( n - ( d * 7 ) ) NEW_LINE DEDENT return ( n % 71 == 0 ) NEW_LINE DEDENT n = 121 NEW_LINE if ( isDivisible ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT

BLEU: 52.46
Edit Sim: 159


Src: 
int sumofoddFactors ( int n ) { int res = 1 ; while ( n % 2 == 0 ) n = n / 2 ; for ( int i = 3 ; i <= Math . sqrt ( n ) ; i ++ ) { int count = 0 , curr_sum = 1 ; int curr_term = 1 ; while ( n % i == 0 ) { count ++ ; n = n / i ; curr_term *= i ; curr_sum += curr_term ; } res *= curr_sum ; } if ( n >= 2 ) res *= ( 1 + n ) ; return res ; }
Ref: 
def sumofoddFactors ( n ) : NEW_LINE INDENT res = 1 NEW_LINE while n % 2 == 0 : NEW_LINE INDENT n = n // 2 NEW_LINE DEDENT for i in range ( 3 , int ( math . sqrt ( n ) + 1 ) ) : NEW_LINE INDENT count = 0 NEW_LINE curr_sum = 1 NEW_LINE curr_term = 1 NEW_LINE while n % i == 0 : NEW_LINE INDENT count += 1 NEW_LINE n = n // i NEW_LINE curr_term *= i NEW_LINE curr_sum += curr_term NEW_LINE DEDENT res *= curr_sum NEW_LINE DEDENT if n >= 2 : NEW_LINE INDENT res *= ( 1 + n ) NEW_LINE DEDENT return res NEW_LINE DEDENT
Hyp: 
def sumofoddFactors ( n ) : NEW_LINE INDENT res = 1 ; NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT n = n // 2 ; NEW_LINE DEDENT for i in range ( 3 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT count = 0 ; NEW_LINE curr_sum = 1 ; NEW_LINE curr_term = 1 ; NEW_LINE while ( n % i == 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE n = n // i ; NEW_LINE curr_term *= i ; NEW_LINE curr_sum += curr_term ; NEW_LINE DEDENT res *= curr_sum ; NEW_LINE DEDENT if ( n >= 2 ) : NEW_LINE INDENT res *= ( 1 + n ) ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT

BLEU: 62.86
Edit Sim: 39


Src: 
double Area_of_Rhombus ( int a , int theta ) { double area = ( a * a ) * Math . sin ( ( RADIAN * theta ) ) ; return area ; }
Ref: 
def Area_of_Rhombus ( a , theta ) : NEW_LINE INDENT area = ( a ** 2 ) * math . sin ( math . radians ( theta ) ) NEW_LINE return area NEW_LINE DEDENT
Hyp: 
def Area_of_Rhombus ( a , theta ) : NEW_LINE INDENT area = ( a * a ) * math . sin ( ( RADIAN * theta ) ) NEW_LINE return area NEW_LINE DEDENT

BLEU: 73.1
Edit Sim: 16


Src: 
int maxWater ( int height [ ] , int n ) { int max = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int current = ( Math . min ( height [ i ] , height [ j ] ) * ( j - i - 1 ) ) ; max = Math . max ( max , current ) ; } } return max ; }
Ref: 
def maxWater ( height , n ) : NEW_LINE INDENT maximum = 0 ; NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT current = min ( height [ i ] , height [ j ] ) * ( j - i - 1 ) ; NEW_LINE maximum = max ( maximum , current ) ; NEW_LINE DEDENT DEDENT return maximum ; NEW_LINE DEDENT
Hyp: 
def maxWater ( height , n ) : NEW_LINE INDENT max = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT current = ( min ( height [ i ] , height [ j ] ) * ( j - i - 1 ) ) NEW_LINE max = max ( max , current ) NEW_LINE DEDENT DEDENT return max NEW_LINE DEDENT

BLEU: 76.27
Edit Sim: 25


Src: 
int highestPower ( int n ) { return ( int ) ( Math . log ( n ) / Math . log ( 2 ) ) ; }
Ref: 
def highestPower ( n ) : NEW_LINE INDENT return int ( ( math . log ( n ) // math . log ( 2 ) ) ) ; NEW_LINE DEDENT
Hyp: 
def highestPower ( n ) : NEW_LINE INDENT return math . log2 ( math . log2 ( n ) ) ; NEW_LINE DEDENT

BLEU: 48.16
Edit Sim: 20


Src: 
int minimumValue ( int arr [ ] , int n , int k ) { Arrays . sort ( arr ) ; int answer = 0 ; for ( int i = 0 ; i < k ; i ++ ) answer += arr [ i ] * arr [ i ] ; return answer * ( 2 * k - 2 ) ; }
Ref: 
def minimumValue ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) ; NEW_LINE answer = 0 ; NEW_LINE for i in range ( k ) : NEW_LINE INDENT answer += arr [ i ] * arr [ i ] ; NEW_LINE DEDENT return answer * ( 2 * k - 2 ) ; NEW_LINE DEDENT
Hyp: 
def minimumValue ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE answer = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT answer += arr [ i ] * arr [ i ] NEW_LINE DEDENT return answer * ( 2 * k - 2 ) NEW_LINE DEDENT

BLEU: 83.3
Edit Sim: 8


Src: 
boolean isEven ( int n ) { return ( ( n / 2 ) * 2 == n ) ; }
Ref: 
def isEven ( n ) : NEW_LINE INDENT return ( int ( n / 2 ) * 2 == n ) NEW_LINE DEDENT n = 101 NEW_LINE if ( isEven ( n ) != False ) : NEW_LINE INDENT print ( " Even " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Odd " ) NEW_LINE DEDENT
Hyp: 
def isEven ( n ) : NEW_LINE INDENT return ( int ( n / 2 ) * 2 == n ) NEW_LINE DEDENT

BLEU: 20.9
Edit Sim: 156


Src: 
int maxCandies ( int arr [ ] , int n ) { int prevBought = arr [ n - 1 ] ; int candies = prevBought ; for ( int i = n - 2 ; i >= 0 ; i -- ) { int x = Math . min ( prevBought - 1 , arr [ i ] ) ; if ( x >= 0 ) { candies += x ; prevBought = x ; } } return candies ; }
Ref: 
def maxCandies ( arr , n ) : NEW_LINE INDENT prevBought = arr [ n - 1 ] ; NEW_LINE candies = prevBought ; NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT x = min ( prevBought - 1 , arr [ i ] ) ; NEW_LINE if ( x >= 0 ) : NEW_LINE INDENT candies += x ; NEW_LINE prevBought = x ; NEW_LINE DEDENT DEDENT return candies ; NEW_LINE DEDENT
Hyp: 
def maxCandies ( arr , n ) : NEW_LINE INDENT prevBought = arr [ n - 1 ] NEW_LINE candies = prevBought NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT x = min ( prevBought - 1 , arr [ i ] ) NEW_LINE if ( x >= 0 ) : NEW_LINE INDENT candies += x NEW_LINE prevBought = x NEW_LINE DEDENT DEDENT return candies NEW_LINE DEDENT

BLEU: 81.66
Edit Sim: 12


Src: 
int longestUniqueSubsttr ( String str ) { int n = str . length ( ) ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { boolean [ ] visited = new boolean [ 256 ] ; for ( int j = i ; j < n ; j ++ ) { if ( visited [ str . charAt ( j ) ] == true ) break ; else { res = Math . max ( res , j - i + 1 ) ; visited [ str . charAt ( j ) ] = true ; } } visited [ str . charAt ( i ) ] = false ; } return res ; }
Ref: 
def longestUniqueSubsttr ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT visited = [ 0 ] * 256 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT if ( visited [ ord ( str [ j ] ) ] == True ) : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT res = max ( res , j - i + 1 ) NEW_LINE visited [ ord ( str [ j ] ) ] = True NEW_LINE DEDENT DEDENT visited [ ord ( str [ i ] ) ] = False NEW_LINE DEDENT return res NEW_LINE DEDENT
Hyp: 
def longestUniqueSubsttr ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT visited = [ False ] * 256 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT if str [ j ] in visited : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT res = max ( res , j - i + 1 ) NEW_LINE visited [ str [ j ] ] = True NEW_LINE DEDENT DEDENT visited [ str [ i ] ] = False NEW_LINE DEDENT return res NEW_LINE DEDENT

BLEU: 76.24
Edit Sim: 50


Src: 
int findMinDel ( int [ ] arr , int n ) { int min_num = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) min_num = Math . min ( arr [ i ] , min_num ) ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == min_num ) cnt ++ ; return n - cnt ; }
Ref: 
def findMinDel ( arr , n ) : NEW_LINE INDENT min_num = sys . maxsize ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT min_num = min ( arr [ i ] , min_num ) ; NEW_LINE DEDENT cnt = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == min_num ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT DEDENT return n - cnt ; NEW_LINE DEDENT
Hyp: 
def findMinDel ( arr , n ) : NEW_LINE INDENT min_num = sys . maxsize NEW_LINE for i in range ( n ) : NEW_LINE INDENT min_num = min ( arr [ i ] , min_num ) NEW_LINE DEDENT cnt = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == min_num ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return n - cnt NEW_LINE DEDENT

BLEU: 84.48
Edit Sim: 10


Src: 
float productOfGP ( float a , float r , int n ) { int an = ( int ) ( a * ( int ) ( Math . pow ( r , n - 1 ) ) ) ; return ( int ) Math . sqrt ( ( int ) Math . pow ( a * an , n ) ) ; }
Ref: 
def productOfGP ( a , r , n ) : NEW_LINE INDENT an = a * pow ( r , n - 1 ) ; NEW_LINE return ( math . sqrt ( pow ( a * an , n ) ) ) NEW_LINE DEDENT
Hyp: 
def productOfGP ( a , r , n ) : NEW_LINE INDENT an = ( a * ( math . pow ( r , n - 1 ) ) ) NEW_LINE return math . sqrt ( pow ( a * an , n ) ) NEW_LINE DEDENT

BLEU: 77.58
Edit Sim: 18


Src: 
String possibleToSort ( int arr [ ] , int n , String str ) { int max_element = - 1 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { max_element = Math . max ( max_element , arr [ i ] ) ; if ( str . charAt ( i ) == '0' ) { if ( max_element > i + 1 ) return " No " ; } } return " Yes " ; }
Ref: 
def possibleToSort ( arr , n , str ) : NEW_LINE INDENT max_element = - 1 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT max_element = max ( max_element , arr [ i ] ) NEW_LINE if ( str [ i ] == '0' ) : NEW_LINE INDENT if ( max_element > i + 1 ) : NEW_LINE INDENT return " No " NEW_LINE DEDENT DEDENT DEDENT return " Yes " NEW_LINE DEDENT
Hyp: 
def possibleToSort ( arr , n , str ) : NEW_LINE INDENT max_element = - 1 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT max_element = max ( max_element , arr [ i ] ) NEW_LINE if ( str [ i ] == '0' ) : NEW_LINE INDENT if ( max_element > i + 1 ) : NEW_LINE INDENT return " No " NEW_LINE DEDENT DEDENT return " Yes " NEW_LINE DEDENT

BLEU: 98.4
Edit Sim: 7


Src: 
int nearest ( int n ) { int prevSquare = ( int ) Math . sqrt ( n ) ; int nextSquare = prevSquare + 1 ; prevSquare = prevSquare * prevSquare ; nextSquare = nextSquare * nextSquare ; int ans = ( n - prevSquare ) < ( nextSquare - n ) ? ( prevSquare - n ) : ( nextSquare - n ) ; return ans ; }
Ref: 
def nearest ( n ) : NEW_LINE INDENT prevSquare = int ( sqrt ( n ) ) ; NEW_LINE nextSquare = prevSquare + 1 ; NEW_LINE prevSquare = prevSquare * prevSquare ; NEW_LINE nextSquare = nextSquare * nextSquare ; NEW_LINE ans = ( prevSquare - n ) if ( n - prevSquare ) < ( nextSquare - n ) else ( nextSquare - n ) ; NEW_LINE return ans ; NEW_LINE DEDENT
Hyp: 
def nearest ( n ) : NEW_LINE INDENT prevSquare = math . floor ( math . sqrt ( n ) ) NEW_LINE nextSquare = prevSquare + 1 NEW_LINE prevSquare = prevSquare * prevSquare NEW_LINE nextSquare = nextSquare * nextSquare NEW_LINE ans = ( n - prevSquare ) < ( nextSquare - n ) ? ( prevSquare - n ) : ( nextSquare - n ) NEW_LINE return ans NEW_LINE DEDENT

BLEU: 64.62
Edit Sim: 60


Src: 
int number_of_tower ( int house [ ] , int range , int n ) { Arrays . sort ( house ) ; int numOfTower = 0 ; int i = 0 ; while ( i < n ) { numOfTower ++ ; int loc = house [ i ] + range ; while ( i < n && house [ i ] <= loc ) i ++ ; -- i ; loc = house [ i ] + range ; while ( i < n && house [ i ] <= loc ) i ++ ; } return numOfTower ; }
Ref: 
def number_of_tower ( house , r , n ) : NEW_LINE INDENT house . sort ( ) NEW_LINE numOfTower = 0 NEW_LINE i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT numOfTower += 1 NEW_LINE loc = house [ i ] + r NEW_LINE while ( i < n and house [ i ] <= loc ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT i -= 1 NEW_LINE loc = house [ i ] + r NEW_LINE while ( i < n and house [ i ] <= loc ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT return numOfTower NEW_LINE DEDENT
Hyp: 
def number_of_tower ( house , range , n ) : NEW_LINE INDENT house . sort ( ) NEW_LINE numOfTower = 0 NEW_LINE i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT numOfTower += 1 NEW_LINE loc = house [ i ] + range NEW_LINE while ( i < n and house [ i ] <= loc ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT loc = house [ i ] + range NEW_LINE while ( i < n and house [ i ] <= loc ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT return numOfTower NEW_LINE DEDENT

BLEU: 86.96
Edit Sim: 32


Src: 
int solve ( int n ) { if ( n < 0 ) return 0 ; if ( n == 0 ) return 1 ; if ( dp [ n ] != - 1 ) return dp [ n ] ; return dp [ n ] = solve ( n - 1 ) + solve ( n - 3 ) + solve ( n - 5 ) ; }
Ref: 
def solve ( n , lookup = { } ) : NEW_LINE INDENT if n < 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if n not in lookup : NEW_LINE INDENT lookup [ n ] = ( solve ( n - 1 ) + solve ( n - 3 ) + solve ( n - 5 ) ) NEW_LINE DEDENT return lookup [ n ] NEW_LINE DEDENT
Hyp: 
def solve ( n ) : NEW_LINE INDENT if ( n < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( dp [ n ] != - 1 ) : NEW_LINE INDENT return dp [ n ] NEW_LINE DEDENT dp [ n ] = solve ( n - 1 ) + solve ( n - 3 ) + solve ( n - 5 ) NEW_LINE return dp [ n ] NEW_LINE DEDENT

BLEU: 56.9
Edit Sim: 86


Src: 
void sortArray ( int A [ ] , int N ) { int x = 0 , y = 0 , z = 0 ; if ( N % 4 == 0 N % 4 == 1 ) { for ( int i = 0 ; i < N / 2 ; i ++ ) { x = i ; if ( i % 2 == 0 ) { y = N - i - 2 ; z = N - i - 1 ; } A [ z ] = A [ y ] ; A [ y ] = A [ x ] ; A [ x ] = x + 1 ; } System . out . print ( " Sorted ▁ Array : ▁ " ) ; for ( int i = 0 ; i < N ; i ++ ) System . out . print ( A [ i ] + " ▁ " ) ; } else { System . out . print ( " - 1" ) ; } }
Ref: 
def sortArray ( A , N ) : NEW_LINE INDENT if ( N % 4 == 0 or N % 4 == 1 ) : NEW_LINE INDENT for i in range ( N // 2 ) : NEW_LINE INDENT x = i NEW_LINE if ( i % 2 == 0 ) : NEW_LINE INDENT y = N - i - 2 NEW_LINE z = N - i - 1 NEW_LINE DEDENT A [ z ] = A [ y ] NEW_LINE A [ y ] = A [ x ] NEW_LINE A [ x ] = x + 1 NEW_LINE DEDENT print ( " Sorted ▁ Array : ▁ " , end = " " ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT print ( A [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT DEDENT
Hyp: 
def sortArray ( A , N ) : NEW_LINE INDENT if ( N % 4 == 0 or N % 4 == 1 ) : NEW_LINE INDENT x = 0 NEW_LINE y = 0 NEW_LINE z = 0 NEW_LINE for i in range ( 0 , N // 2 , 1 ) : NEW_LINE INDENT x = i NEW_LINE if ( i % 2 == 0 ) : NEW_LINE INDENT y = N - i - 2 NEW_LINE z = N - i - 1 NEW_LINE DEDENT A [ z ] = A [ y ] NEW_LINE A [ y ] = A [ x ] NEW_LINE A [ x ] = x + 1 NEW_LINE DEDENT print ( " Sorted ▁ Array : ▁ " ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT print ( A [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT DEDENT

BLEU: 87.47
Edit Sim: 65


Src: 
int Icosihenagonal_num ( int n ) { return ( 19 * n * n - 17 * n ) / 2 ; }
Ref: 
def Icosihenagonal_num ( n ) : NEW_LINE INDENT return ( 19 * n * n - 17 * n ) / 2 NEW_LINE DEDENT
Hyp: 
def Icosihenagonal_num ( n ) : NEW_LINE INDENT return ( 19 * n * n - 17 * n ) // 2 NEW_LINE DEDENT

BLEU: 88.95
Edit Sim: 1


Src: 
void printSubsequences ( String s ) { char [ ] str = s . toCharArray ( ) ; int n = str . length ; int opsize = ( int ) ( Math . pow ( 2 , n - 1 ) ) ; for ( int counter = 0 ; counter < opsize ; counter ++ ) { for ( int j = 0 ; j < n ; j ++ ) { System . out . print ( str [ j ] ) ; if ( ( counter & ( 1 << j ) ) > 0 ) System . out . print ( " ▁ " ) ; } System . out . println ( ) ; } }
Ref: 
def printSubsequences ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE opsize = int ( pow ( 2 , n - 1 ) ) NEW_LINE for counter in range ( opsize ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT print ( str [ j ] , end = " " ) NEW_LINE if ( counter & ( 1 << j ) ) : NEW_LINE INDENT print ( " ▁ " , end = " " ) NEW_LINE DEDENT DEDENT print ( " " , ▁ end ▁ = ▁ " " ) NEW_LINE DEDENT DEDENT
Hyp: 
def printSubsequences ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE opsize = int ( pow ( 2 , n - 1 ) ) NEW_LINE for counter in range ( opsize ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT print ( s [ j ] , end = " ▁ " ) NEW_LINE if ( counter & ( 1 << j ) ) > 0 : NEW_LINE INDENT print ( " ▁ " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT

BLEU: 72.9
Edit Sim: 46


Src: 
double decdiagonal ( double a ) { if ( a < 0 ) return - 1 ; double d = 1.902 * a ; return d ; }
Ref: 
def decdiagonal ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT d = 1.902 * a NEW_LINE return d NEW_LINE DEDENT
Hyp: 
def decdiagonal ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT d = 1.902 * a NEW_LINE return d NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
long countTriplets ( int A , int B , int C ) { long ans = 0 ; for ( int i = 1 ; i <= A ; i ++ ) { for ( int j = 1 ; j <= B ; j ++ ) { for ( int k = 1 ; k <= C ; k ++ ) { if ( i * k > j * j ) ans ++ ; } } } return ans ; }
Ref: 
def countTriplets ( A , B , C ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , A + 1 ) : NEW_LINE INDENT for j in range ( 1 , B + 1 ) : NEW_LINE INDENT for k in range ( 1 , C + 1 ) : NEW_LINE INDENT if ( i * k > j * j ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
Hyp: 
def countTriplets ( A , B , C ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , A + 1 ) : NEW_LINE INDENT for j in range ( 1 , B + 1 ) : NEW_LINE INDENT for k in range ( 1 , C + 1 ) : NEW_LINE INDENT if ( i * k > j * j ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
double MinimumMail ( int n , int k , int x ) { double m = ( n - 1 ) + Math . ceil ( ( n - 1 ) * 1.0 / x ) * ( n - 1 ) + Math . ceil ( n * 1.0 / x ) * ( k - n ) ; return m ; }
Ref: 
def MinimumMail ( n , k , x ) : NEW_LINE INDENT m = ( ( n - 1 ) + int ( math . ceil ( ( n - 1 ) * 1.0 / x ) * ( n - 1 ) + math . ceil ( n * 1.0 / x ) * ( k - n ) ) ) ; NEW_LINE return m ; NEW_LINE DEDENT
Hyp: 
def MinimumMail ( n , k , x ) : NEW_LINE INDENT m = ( n - 1 ) + ceil ( ( n - 1 ) * 1.0 / x ) * ( n - 1 ) + ceil ( ( n * 1.0 / x ) * ( k - n ) ) NEW_LINE return m NEW_LINE DEDENT

BLEU: 74.94
Edit Sim: 30


Src: 
int countPaths ( int n ) { int zB = 1 ; int zADC = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int nzB = zADC * 3 ; int nzADC = ( zADC * 2 + zB ) ; zB = nzB ; zADC = nzADC ; } return zB ; }
Ref: 
def countPaths ( n ) : NEW_LINE INDENT zB = 1 NEW_LINE zADC = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT nzB = zADC * 3 NEW_LINE nzADC = ( zADC * 2 + zB ) NEW_LINE zB = nzB NEW_LINE zADC = nzADC NEW_LINE DEDENT return zB NEW_LINE DEDENT
Hyp: 
def countPaths ( n ) : NEW_LINE INDENT zB = 1 NEW_LINE zADC = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT nzB = zADC * 3 NEW_LINE nzADC = ( zADC * 2 + zB ) NEW_LINE zB = nzB NEW_LINE zADC = nzADC NEW_LINE DEDENT return zB NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
String find_number ( int N , int K ) { String r ; if ( N % 100 == 0 ) { N += 1 ; r = String . valueOf ( N ) ; } else { r = String . valueOf ( N ) ; } for ( int i = 1 ; i <= K ; i ++ ) r += "00" ; return r ; }
Ref: 
def find_number ( N , K ) : NEW_LINE INDENT r = " " NEW_LINE if ( N % 100 == 0 ) : NEW_LINE INDENT N += 1 ; NEW_LINE r = str ( N ) NEW_LINE DEDENT else : NEW_LINE INDENT r = str ( N ) NEW_LINE DEDENT for i in range ( 1 , K + 1 ) : NEW_LINE INDENT r += "00" NEW_LINE DEDENT return r NEW_LINE DEDENT
Hyp: 
def find_number ( N , K ) : NEW_LINE INDENT r = "0" ; NEW_LINE if ( N % 100 == 0 ) : NEW_LINE INDENT N += 1 NEW_LINE r = str ( N ) NEW_LINE DEDENT else : NEW_LINE INDENT r = str ( N ) NEW_LINE DEDENT for i in range ( 1 , K + 1 ) : NEW_LINE INDENT r += "00" NEW_LINE DEDENT return r NEW_LINE DEDENT

BLEU: 92.38
Edit Sim: 5


Src: 
void findNumbers ( int N ) { for ( int i = 1 ; i <= N / 2 ; i ++ ) { System . out . print ( i + " , ▁ " + - i + " , ▁ " ) ; } if ( N % 2 == 1 ) System . out . print ( 0 ) ; }
Ref: 
def findNumbers ( N ) : NEW_LINE INDENT for i in range ( 1 , N // 2 + 1 ) : NEW_LINE INDENT print ( i , end = ' , ▁ ' ) NEW_LINE print ( - i , end = ' , ▁ ' ) NEW_LINE DEDENT if N % 2 == 1 : NEW_LINE INDENT print ( 0 , end = ' ' ) NEW_LINE DEDENT DEDENT
Hyp: 
def findNumbers ( N ) : NEW_LINE INDENT i = 1 NEW_LINE while i <= N // 2 : NEW_LINE INDENT print ( i , " , ▁ " , - i , " , ▁ " ) NEW_LINE DEDENT if ( N % 2 == 1 ) : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT DEDENT

BLEU: 43.82
Edit Sim: 75


Src: 
int countMaxSetBits ( int left , int right ) { while ( ( left | ( left + 1 ) ) <= right ) left |= left + 1 ; return left ; }
Ref: 
def countMaxSetBits ( left , right ) : NEW_LINE INDENT while ( left | ( left + 1 ) ) <= right : NEW_LINE INDENT left |= left + 1 NEW_LINE DEDENT return left NEW_LINE DEDENT
Hyp: 
def countMaxSetBits ( left , right ) : NEW_LINE INDENT while ( ( left | ( left + 1 ) ) <= right ) : NEW_LINE INDENT left |= left + 1 NEW_LINE DEDENT return left NEW_LINE DEDENT

BLEU: 88.33
Edit Sim: 4


Src: 
int maximumSum ( int arr [ ] , int N ) { int Sum = 0 ; for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] > arr [ i - 1 ] ) Sum += ( arr [ i ] - arr [ i - 1 ] ) ; } return Sum ; }
Ref: 
def maximumSum ( arr , N ) : NEW_LINE INDENT Sum = 0 ; NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i - 1 ] ) : NEW_LINE INDENT Sum += ( arr [ i ] - arr [ i - 1 ] ) NEW_LINE DEDENT DEDENT return Sum ; NEW_LINE DEDENT
Hyp: 
def maximumSum ( arr , N ) : NEW_LINE INDENT Sum = 0 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i - 1 ] ) : NEW_LINE INDENT Sum += ( arr [ i ] - arr [ i - 1 ] ) NEW_LINE DEDENT DEDENT return Sum NEW_LINE DEDENT

BLEU: 92.74
Edit Sim: 4


Src: 
int findArrangement ( int N ) { if ( N < 3 ) return 0 ; return ( ( N ) * ( N - 1 ) * ( N - 2 ) ) / 3 ; }
Ref: 
def findArrangement ( N ) : NEW_LINE INDENT if ( N < 3 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT return ( ( N ) * ( N - 1 ) * ( N - 2 ) ) // 3 ; NEW_LINE DEDENT
Hyp: 
def findArrangement ( N ) : NEW_LINE INDENT if ( N < 3 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( ( N ) * ( N - 1 ) * ( N - 2 ) ) // 3 NEW_LINE DEDENT

BLEU: 89.05
Edit Sim: 4


Src: 
int minCount ( int n ) { int [ ] hasharr = { 10 , 3 , 6 , 9 , 2 , 5 , 8 , 1 , 4 , 7 } ; if ( n > 69 ) return hasharr [ n % 10 ] ; else { if ( n >= hasharr [ n % 10 ] * 7 ) return ( hasharr [ n % 10 ] ) ; else return - 1 ; } }
Ref: 
def minCount ( n ) : NEW_LINE INDENT hasharr = [ 10 , 3 , 6 , 9 , 2 , 5 , 8 , 1 , 4 , 7 ] NEW_LINE if ( n > 69 ) : NEW_LINE INDENT return hasharr [ n % 10 ] NEW_LINE DEDENT else : NEW_LINE INDENT if ( n >= hasharr [ n % 10 ] * 7 ) : NEW_LINE INDENT return hasharr [ n % 10 ] NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT DEDENT
Hyp: 
def minCount ( n ) : NEW_LINE INDENT hasharr = [ 10 , 3 , 6 , 9 , 2 , 5 , 8 , 1 , 4 , 7 ] NEW_LINE if ( n > 69 ) : NEW_LINE INDENT return hasharr [ n % 10 ] NEW_LINE DEDENT else : NEW_LINE INDENT if ( n >= hasharr [ n % 10 ] * 7 ) : NEW_LINE INDENT return ( hasharr [ n % 10 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT DEDENT

BLEU: 94.47
Edit Sim: 4


Src: 
int minParentheses ( String p ) { int bal = 0 ; int ans = 0 ; for ( int i = 0 ; i < p . length ( ) ; ++ i ) { bal += p . charAt ( i ) == ' ( ' ? 1 : - 1 ; if ( bal == - 1 ) { ans += 1 ; bal += 1 ; } } return bal + ans ; }
Ref: 
def minParentheses ( p ) : NEW_LINE INDENT bal = 0 NEW_LINE ans = 0 NEW_LINE for i in range ( 0 , len ( p ) ) : NEW_LINE INDENT if ( p [ i ] == ' ( ' ) : NEW_LINE INDENT bal += 1 NEW_LINE DEDENT else : NEW_LINE INDENT bal += - 1 NEW_LINE DEDENT if ( bal == - 1 ) : NEW_LINE INDENT ans += 1 NEW_LINE bal += 1 NEW_LINE DEDENT DEDENT return bal + ans NEW_LINE DEDENT
Hyp: 
def minParentheses ( p ) : NEW_LINE INDENT bal = 0 ; NEW_LINE ans = 0 ; NEW_LINE for i in range ( len ( p ) ) : NEW_LINE INDENT bal += int ( p [ i ] ) == ' ( ' ? 1 : - 1 ) ; NEW_LINE if ( bal == - 1 ) : NEW_LINE INDENT ans += 1 ; NEW_LINE bal += 1 ; NEW_LINE DEDENT DEDENT return bal + ans ; NEW_LINE DEDENT

BLEU: 61.25
Edit Sim: 99


Src: 
int subsetCount ( int arr [ ] , int n ) { return 1 << n ; }
Ref: 
def subsetCount ( arr , n ) : NEW_LINE INDENT return 1 << n NEW_LINE DEDENT
Hyp: 
def subsetCount ( arr , n ) : NEW_LINE INDENT return 1 << n NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int FindMinimumCost ( int ind , int a [ ] , int n , int k , int dp [ ] ) { if ( ind == ( n - 1 ) ) return 0 ; else if ( dp [ ind ] != - 1 ) return dp [ ind ] ; else { int ans = Integer . MAX_VALUE ; for ( int i = 1 ; i <= k ; i ++ ) { if ( ind + i < n ) ans = Math . min ( ans , Math . abs ( a [ ind + i ] - a [ ind ] ) + FindMinimumCost ( ind + i , a , n , k , dp ) ) ; else break ; } return dp [ ind ] = ans ; } }
Ref: 
def FindMinimumCost ( ind , a , n , k , dp ) : NEW_LINE INDENT if ( ind == ( n - 1 ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( dp [ ind ] != - 1 ) : NEW_LINE INDENT return dp [ ind ] NEW_LINE DEDENT else : NEW_LINE INDENT ans = sys . maxsize NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT if ( ind + i < n ) : NEW_LINE INDENT ans = min ( ans , abs ( a [ ind + i ] - a [ ind ] ) + FindMinimumCost ( ind + i , a , n , k , dp ) ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT dp [ ind ] = ans NEW_LINE return ans NEW_LINE DEDENT DEDENT
Hyp: 
def FindMinimumCost ( ind , a , n , k , dp ) : NEW_LINE INDENT if ( ind == ( n - 1 ) ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT elif ( dp [ ind ] != - 1 ) : NEW_LINE INDENT return dp [ ind ] ; NEW_LINE DEDENT else : NEW_LINE INDENT ans = 10 ** 9 NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT if ( ind + i < n ) : NEW_LINE INDENT ans = min ( ans , abs ( a [ ind + i ] - a [ ind ] ) + FindMinimumCost ( ind + i , a , n , k , dp ) ) ; NEW_LINE DEDENT else : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT return dp [ ind ] ; NEW_LINE DEDENT

BLEU: 86.73
Edit Sim: 57


Src: 
void meanOfRemainingElements ( int [ ] arr , int N , int K ) { Arrays . sort ( arr ) ; int kthPercent = ( N * K ) / 100 ; float sum = 0f ; for ( int i = 0 ; i < N ; i ++ ) if ( i >= kthPercent && i < ( N - kthPercent ) ) sum += arr [ i ] ; float mean = ( sum / ( N - 2 * kthPercent ) ) ; System . out . format ( " % .5f " , mean ) ; }
Ref: 
def meanOfRemainingElements ( arr , N , K ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE kthPercent = ( N * K ) / 100 NEW_LINE sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( i >= kthPercent and i < ( N - kthPercent ) ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT DEDENT mean = sum / ( N - 2 * kthPercent ) NEW_LINE print ( ' % .5f ' % mean ) NEW_LINE DEDENT
Hyp: 
def meanOfRemainingElements ( arr , N , K ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE kthPercent = ( N * K ) / 100 NEW_LINE sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( i >= kthPercent and i < ( N - kthPercent ) ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT DEDENT mean = ( sum / ( N - 2 * kthPercent ) ) NEW_LINE print ( " % .5f " , mean ) NEW_LINE DEDENT

BLEU: 89.04
Edit Sim: 7


Src: 
int nobleInteger ( int arr [ ] ) { Arrays . sort ( arr ) ; int n = arr . length ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) continue ; if ( arr [ i ] == n - i - 1 ) return arr [ i ] ; } if ( arr [ n - 1 ] == 0 ) return arr [ n - 1 ] ; return - 1 ; }
Ref: 
def nobleInteger ( arr ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE n = len ( arr ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if arr [ i ] == arr [ i + 1 ] : NEW_LINE INDENT continue NEW_LINE DEDENT if arr [ i ] == n - i - 1 : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT if arr [ n - 1 ] == 0 : NEW_LINE INDENT return arr [ n - 1 ] NEW_LINE DEDENT return - 1 NEW_LINE DEDENT arr = [ 10 , 3 , 20 , 40 , 2 ] NEW_LINE res = nobleInteger ( arr ) NEW_LINE if res != - 1 : NEW_LINE INDENT print ( " The ▁ noble ▁ integer ▁ is " , res ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No ▁ Noble ▁ Integer ▁ Found " ) NEW_LINE DEDENT
Hyp: 
def nobleInteger ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( arr [ i ] == arr [ i + 1 ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( arr [ i ] == n - i - 1 ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT if ( arr [ n - 1 ] == 0 ) : NEW_LINE INDENT return arr [ n - 1 ] NEW_LINE DEDENT return - 1 NEW_LINE DEDENT

BLEU: 44.53
Edit Sim: 294


Src: 
float noOfYears ( int t1 , int n1 , int t2 ) { float years = ( ( t2 - 1 ) * n1 / ( float ) ( t1 - 1 ) ) ; return years ; }
Ref: 
def noOfYears ( t1 , n1 , t2 ) : NEW_LINE INDENT years = ( t2 - 1 ) * n1 / ( t1 - 1 ) NEW_LINE return years NEW_LINE DEDENT
Hyp: 
def noOfYears ( t1 , n1 , t2 ) : NEW_LINE INDENT years = ( ( t2 - 1 ) * n1 / ( t1 - 1 ) ) ; NEW_LINE return years ; NEW_LINE DEDENT

BLEU: 78.18
Edit Sim: 8


Src: 
boolean isSubsetSum ( int set [ ] , int n , int sum ) { if ( sum == 0 ) return true ; if ( n == 0 ) return false ; if ( set [ n - 1 ] > sum ) return isSubsetSum ( set , n - 1 , sum ) ; return isSubsetSum ( set , n - 1 , sum ) || isSubsetSum ( set , n - 1 , sum - set [ n - 1 ] ) ; }
Ref: 
def isSubsetSum ( set , n , sum ) : NEW_LINE INDENT if ( sum == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( set [ n - 1 ] > sum ) : NEW_LINE INDENT return isSubsetSum ( set , n - 1 , sum ) NEW_LINE DEDENT return isSubsetSum ( set , n - 1 , sum ) or isSubsetSum ( set , n - 1 , sum - set [ n - 1 ] ) NEW_LINE DEDENT set = [ 3 , 34 , 4 , 12 , 5 , 2 ] NEW_LINE sum = 9 NEW_LINE n = len ( set ) NEW_LINE if ( isSubsetSum ( set , n , sum ) == True ) : NEW_LINE INDENT print ( " Found ▁ a ▁ subset ▁ with ▁ given ▁ sum " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No ▁ subset ▁ with ▁ given ▁ sum " ) NEW_LINE DEDENT
Hyp: 
def isSubsetSum ( set , n , sum ) : NEW_LINE INDENT if ( sum == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( set [ n - 1 ] > sum ) : NEW_LINE INDENT return isSubsetSum ( set , n - 1 , sum ) NEW_LINE DEDENT return isSubsetSum ( set , n - 1 , sum ) or isSubsetSum ( set , n - 1 , sum - set [ n - 1 ] ) NEW_LINE DEDENT

BLEU: 43.01
Edit Sim: 304


Src: 
int nthTerm ( int N ) { int nth = 0 , i ; for ( i = N ; i > 0 ; i -- ) { nth += Math . pow ( i , i ) ; } return nth ; }
Ref: 
def nthTerm ( N ) : NEW_LINE INDENT nth = 0 NEW_LINE for i in range ( N , 0 , - 1 ) : NEW_LINE INDENT nth += pow ( i , i ) NEW_LINE DEDENT return nth NEW_LINE DEDENT
Hyp: 
def nthTerm ( N ) : NEW_LINE INDENT nth = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT nth += pow ( i , i ) NEW_LINE DEDENT return nth NEW_LINE DEDENT

BLEU: 83.22
Edit Sim: 10


Src: 
void printChar ( String str , int n ) { int [ ] freq = new int [ SIZE ] ; for ( int i = 0 ; i < n ; i ++ ) freq [ str . charAt ( i ) - ' a ' ] ++ ; for ( int i = 0 ; i < n ; i ++ ) { if ( freq [ str . charAt ( i ) - ' a ' ] % 2 == 0 ) { System . out . print ( str . charAt ( i ) ) ; } } }
Ref: 
def printChar ( string , n ) : NEW_LINE INDENT freq = [ 0 ] * SIZE NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT freq [ ord ( string [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( freq [ ord ( string [ i ] ) - ord ( ' a ' ) ] % 2 == 0 ) : NEW_LINE INDENT print ( string [ i ] , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
Hyp: 
def printChar ( str , n ) : NEW_LINE INDENT freq = [ 0 ] * SIZE NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] = ( freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] ) + 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] % 2 == 0 ) : NEW_LINE INDENT print ( str [ i ] ) NEW_LINE DEDENT DEDENT DEDENT

BLEU: 67.87
Edit Sim: 78


Src: 
int countSub ( String str ) { int n = ( int ) str . length ( ) ; int ans = 0 ; int [ ] cnt = new int [ 26 ] ; int i = 0 , j = 0 ; while ( i < n ) { if ( j < n && ( cnt [ str . charAt ( j ) - ' a ' ] == 0 ) ) { cnt [ str . charAt ( j ) - ' a ' ] ++ ; ans += ( j - i + 1 ) ; j ++ ; } else { cnt [ str . charAt ( i ) - ' a ' ] -- ; i ++ ; } } return ans ; }
Ref: 
def countSub ( Str ) : NEW_LINE INDENT n = len ( Str ) NEW_LINE ans = 0 NEW_LINE cnt = 26 * [ 0 ] NEW_LINE i , j = 0 , 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( j < n and ( cnt [ ord ( Str [ j ] ) - ord ( ' a ' ) ] == 0 ) ) : NEW_LINE INDENT cnt [ ord ( Str [ j ] ) - ord ( ' a ' ) ] += 1 NEW_LINE ans += ( j - i + 1 ) NEW_LINE j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt [ ord ( Str [ i ] ) - ord ( ' a ' ) ] -= 1 NEW_LINE i += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
Hyp: 
def countSub ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE ans = 0 NEW_LINE cnt = [ 0 ] * 26 NEW_LINE i = 0 ; j = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( j < n and ( cnt [ ord ( str [ j ] ) - ord ( ' a ' ) ] == 0 ) ) : NEW_LINE INDENT cnt [ ord ( str [ j ] ) - ord ( ' a ' ) ] += 1 NEW_LINE ans += ( j - i + 1 ) NEW_LINE j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt [ ord ( str [ i ] ) - ord ( ' a ' ) ] -= 1 NEW_LINE i += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT

BLEU: 84.47
Edit Sim: 17


Src: 
int MinimumString ( int x ) { int b = 1 ; double left_lim = Math . sqrt ( x ) + 1.0 ; double right_lim = Math . sqrt ( x ) + 2.0 ; int r = 0 ; for ( int i = ( int ) left_lim ; i <= right_lim ; i ++ ) { if ( i > left_lim && i < right_lim ) { r = i ; break ; } } return b + r ; }
Ref: 
def MinimumString ( x ) : NEW_LINE INDENT b = 1 NEW_LINE left_lim = sqrt ( x ) + 1.0 NEW_LINE right_lim = sqrt ( x ) + 2.0 NEW_LINE for i in range ( int ( left_lim ) , int ( right_lim ) + 1 ) : NEW_LINE INDENT if ( i > left_lim and i < right_lim ) : NEW_LINE INDENT r = i NEW_LINE break NEW_LINE DEDENT DEDENT return b + r NEW_LINE DEDENT
Hyp: 
def MinimumString ( x ) : NEW_LINE INDENT b = 1 NEW_LINE left_lim = sqrt ( x ) + 1.0 NEW_LINE right_lim = sqrt ( x ) + 2.0 NEW_LINE r = 0 NEW_LINE for i in range ( left_lim , right_lim + 1 ) : NEW_LINE INDENT if ( i > left_lim and i < right_lim ) : NEW_LINE INDENT r = i NEW_LINE break NEW_LINE DEDENT DEDENT return b + r NEW_LINE DEDENT

BLEU: 86.43
Edit Sim: 31


Src: 
void findScoreSum ( int n ) { int total = 0 ; int prev_monday = 0 , curr_day = 0 ; for ( int day = 1 ; day <= n ; day ++ ) { if ( day % 7 == 1 ) { prev_monday ++ ; curr_day = prev_monday ; } total += curr_day ++ ; } System . out . println ( total ) ; }
Ref: 
def findScoreSum ( n ) : NEW_LINE INDENT total = 0 NEW_LINE prev_monday , curr_day = 0 , 0 NEW_LINE for day in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( day % 7 == 1 ) : NEW_LINE INDENT prev_monday += 1 NEW_LINE curr_day = prev_monday NEW_LINE DEDENT total += curr_day NEW_LINE curr_day += 1 NEW_LINE DEDENT print ( total ) NEW_LINE DEDENT
Hyp: 
def findScoreSum ( n ) : NEW_LINE INDENT total = 0 NEW_LINE prev_monday = 0 NEW_LINE curr_day = 0 NEW_LINE for day in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( day % 7 == 1 ) : NEW_LINE INDENT prev_monday += 1 NEW_LINE curr_day = prev_monday NEW_LINE DEDENT total += curr_day NEW_LINE DEDENT print ( total ) NEW_LINE DEDENT

BLEU: 86.13
Edit Sim: 39


Src: 
int reversDigits ( int num ) { if ( num > 0 ) { reversDigits ( num / 10 ) ; rev_num += ( num % 10 ) * base_pos ; base_pos *= 10 ; } return rev_num ; }
Ref: 
def reversDigits ( num ) : NEW_LINE INDENT global rev_num NEW_LINE global base_pos NEW_LINE if ( num > 0 ) : NEW_LINE INDENT reversDigits ( ( int ) ( num / 10 ) ) NEW_LINE rev_num += ( num % 10 ) * base_pos NEW_LINE base_pos *= 10 NEW_LINE DEDENT return rev_num NEW_LINE DEDENT
Hyp: 
def reversDigits ( num ) : NEW_LINE INDENT if ( num ) : NEW_LINE INDENT reversDigits ( num / 10 ) NEW_LINE rev_num += ( num % 10 ) * base_pos NEW_LINE base_pos *= 10 NEW_LINE DEDENT return rev_num NEW_LINE DEDENT

BLEU: 64.13
Edit Sim: 65


Src: 
void maximizeProduct ( int N ) { int MSB = ( int ) ( Math . log ( N ) / Math . log ( 2 ) ) ; int X = 1 << MSB ; int Y = N - ( 1 << MSB ) ; for ( int i = 0 ; i < MSB ; i ++ ) { if ( ( N & ( 1 << i ) ) == 0 ) { X += 1 << i ; Y += 1 << i ; } } System . out . println ( X + " ▁ " + Y ) ; }
Ref: 
def maximizeProduct ( N ) : NEW_LINE INDENT MSB = ( int ) ( math . log2 ( N ) ) NEW_LINE X = 1 << MSB NEW_LINE Y = N - ( 1 << MSB ) NEW_LINE for i in range ( MSB ) : NEW_LINE INDENT if ( not ( N & ( 1 << i ) ) ) : NEW_LINE INDENT X += 1 << i NEW_LINE Y += 1 << i NEW_LINE DEDENT DEDENT print ( X , Y ) NEW_LINE DEDENT
Hyp: 
def maximizeProduct ( N ) : NEW_LINE INDENT MSB = int ( log2 ( N ) ) NEW_LINE X = 1 << MSB NEW_LINE Y = N - ( 1 << MSB ) NEW_LINE for i in range ( MSB ) : NEW_LINE INDENT if ( ( N & ( 1 << i ) ) == 0 ) : NEW_LINE INDENT X += 1 << i NEW_LINE Y += 1 << i NEW_LINE DEDENT DEDENT print ( X , Y ) NEW_LINE DEDENT

BLEU: 86.9
Edit Sim: 20


Src: 
boolean isSumSquare ( int N ) { double n = ( 2 + Math . sqrt ( 8 * N - 4 ) ) / 2 ; return ( n - ( int ) n ) == 0 ; }
Ref: 
def isSumSquare ( N ) : NEW_LINE INDENT n = ( 2 + math . sqrt ( 8 * N - 4 ) ) / 2 NEW_LINE return ( n - int ( n ) ) == 0 NEW_LINE DEDENT
Hyp: 
def isSumSquare ( N ) : NEW_LINE INDENT n = ( 2 + math . sqrt ( 8 * N - 4 ) ) / 2 NEW_LINE return ( ( n - int ( n ) ) == 0 ) NEW_LINE DEDENT

BLEU: 90.16
Edit Sim: 4


Src: 
boolean isoctagonal ( int N ) { double n = ( 2 + Math . sqrt ( 12 * N + 4 ) ) / 6 ; return ( n - ( int ) n ) == 0 ; }
Ref: 
def isoctagonal ( N ) : NEW_LINE INDENT n = ( 2 + sqrt ( 12 * N + 4 ) ) / 6 ; NEW_LINE return ( n - int ( n ) ) == 0 ; NEW_LINE DEDENT
Hyp: 
def isoctagonal ( N ) : NEW_LINE INDENT n = ( 2 + math . sqrt ( 12 * N + 4 ) ) // 6 NEW_LINE return ( ( n - int ( n ) ) == 0 ) NEW_LINE DEDENT

BLEU: 73.03
Edit Sim: 13


Src: 
void SectorArea ( double radius , double angle ) { if ( angle >= 360 ) System . out . println ( " Angle ▁ not ▁ possible " ) ; else { double sector = ( ( 22 * radius * radius ) / 7 ) * ( angle / 360 ) ; System . out . println ( sector ) ; } }
Ref: 
def SectorArea ( radius , angle ) : NEW_LINE INDENT pi = 22 / 7 NEW_LINE if angle >= 360 : NEW_LINE INDENT print ( " Angle ▁ not ▁ possible " ) NEW_LINE return NEW_LINE DEDENT else : NEW_LINE INDENT sector = ( pi * radius ** 2 ) * ( angle / 360 ) NEW_LINE print ( sector ) NEW_LINE return NEW_LINE DEDENT DEDENT
Hyp: 
def SectorArea ( radius , angle ) : NEW_LINE INDENT if ( angle >= 360 ) : NEW_LINE INDENT print ( " Angle ▁ not ▁ possible " ) NEW_LINE DEDENT else : NEW_LINE INDENT sector = ( ( 22 * radius * radius ) / 7 ) * ( angle / 360 ) NEW_LINE print ( sector ) NEW_LINE DEDENT DEDENT

BLEU: 68.22
Edit Sim: 71


Src: 
int maxRepeating ( int arr [ ] , int n , int k ) { for ( int i = 0 ; i < n ; i ++ ) arr [ ( arr [ i ] % k ) ] += k ; int max = arr [ 0 ] , result = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > max ) { max = arr [ i ] ; result = i ; } } return result ; }
Ref: 
def maxRepeating ( arr , n , k ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT arr [ arr [ i ] % k ] += k NEW_LINE DEDENT max = arr [ 0 ] NEW_LINE result = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if arr [ i ] > max : NEW_LINE INDENT max = arr [ i ] NEW_LINE result = i NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
Hyp: 
def maxRepeating ( arr , n , k ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT arr [ ( arr [ i ] % k ) ] += k NEW_LINE DEDENT max = arr [ 0 ] NEW_LINE result = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] > max ) : NEW_LINE INDENT max = arr [ i ] NEW_LINE result = i NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT

BLEU: 86.68
Edit Sim: 12


Src: 
int maximumCandy ( int [ ] candies , int [ ] safety , int N , int M ) { int total = 0 ; int ans = Integer . MAX_VALUE ; boolean all_safe = true ; for ( int i = 0 ; i < N ; i ++ ) { if ( candies [ i ] + M > safety [ i ] ) { all_safe = false ; ans = Math . min ( ans , safety [ i ] ) ; } else { ans = Math . min ( ans , candies [ i ] + M ) ; } total += candies [ i ] ; } if ( all_safe ) return total ; else return ans ; }
Ref: 
def maximumCandy ( candies , safety , N , M ) : NEW_LINE INDENT total = 0 NEW_LINE ans = 10 ** 8 NEW_LINE all_safe = True NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( candies [ i ] + M > safety [ i ] ) : NEW_LINE INDENT all_safe = False NEW_LINE ans = min ( ans , safety [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = min ( ans , candies [ i ] + M ) NEW_LINE DEDENT total += candies [ i ] NEW_LINE DEDENT if ( all_safe ) : NEW_LINE INDENT return total NEW_LINE DEDENT else : NEW_LINE INDENT return ans NEW_LINE DEDENT DEDENT
Hyp: 
def maximumCandy ( candies , safety , N , M ) : NEW_LINE INDENT total = 0 NEW_LINE ans = sys . maxsize NEW_LINE all_safe = True NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( candies [ i ] + M > safety [ i ] ) : NEW_LINE INDENT all_safe = False NEW_LINE ans = min ( ans , safety [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = min ( ans , candies [ i ] + M ) NEW_LINE DEDENT total += candies [ i ] NEW_LINE DEDENT if ( all_safe ) : NEW_LINE INDENT return total NEW_LINE DEDENT else : NEW_LINE INDENT return ans NEW_LINE DEDENT DEDENT

BLEU: 96.19
Edit Sim: 12


Src: 
void scoreOfParentheses ( String s ) { Stack < Integer > stack = new Stack < > ( ) ; stack . push ( 0 ) ; for ( char c : s . toCharArray ( ) ) { if ( c == ' ( ' ) stack . push ( 0 ) ; else { int tmp = stack . pop ( ) ; int val = 0 ; if ( tmp > 0 ) val = tmp * 2 ; else val = 1 ; stack . push ( stack . pop ( ) + val ) ; } } System . out . println ( stack . peek ( ) ) ; }
Ref: 
def scoreOfParentheses ( s ) : NEW_LINE INDENT stack = [ ] NEW_LINE stack . append ( 0 ) NEW_LINE for c in s : NEW_LINE INDENT if ( c == ' ( ' ) : NEW_LINE INDENT stack . append ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT tmp = stack [ len ( stack ) - 1 ] NEW_LINE stack = stack [ : - 1 ] NEW_LINE val = 0 NEW_LINE if ( tmp > 0 ) : NEW_LINE INDENT val = tmp * 2 NEW_LINE DEDENT else : NEW_LINE INDENT val = 1 NEW_LINE DEDENT stack [ len ( stack ) - 1 ] += val NEW_LINE DEDENT DEDENT print ( stack [ len ( stack ) - 1 ] ) NEW_LINE DEDENT
Hyp: 
def scoreOfParentheses ( s ) : NEW_LINE INDENT stack = [ ] NEW_LINE stack . append ( 0 ) NEW_LINE for c in s : NEW_LINE INDENT if c == ' ( ' : NEW_LINE INDENT stack . append ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT tmp = stack . pop ( ) NEW_LINE val = 0 NEW_LINE if tmp > 0 : NEW_LINE INDENT val = tmp * 2 NEW_LINE DEDENT else : NEW_LINE INDENT val = 1 NEW_LINE DEDENT stack . append ( stack . pop ( ) + val ) NEW_LINE DEDENT DEDENT print ( stack . peek ( ) ) NEW_LINE DEDENT

BLEU: 61.68
Edit Sim: 87


Src: 
int countTriplets ( int a [ ] , int n , int x ) { int answer = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) { Vector < Integer > temp = new Vector < > ( ) ; temp . add ( a [ i ] ) ; temp . add ( a [ j ] ) ; temp . add ( a [ k ] ) ; Collections . sort ( temp ) ; if ( temp . get ( 0 ) < temp . get ( 1 ) && temp . get ( 1 ) < temp . get ( 2 ) && temp . get ( 0 ) * temp . get ( 1 ) * temp . get ( 2 ) <= x ) answer ++ ; } } } return answer ; }
Ref: 
def countTriplets ( a , n , x ) : NEW_LINE INDENT answer = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT temp = [ ] NEW_LINE temp . append ( a [ i ] ) NEW_LINE temp . append ( a [ j ] ) NEW_LINE temp . append ( a [ k ] ) NEW_LINE temp . sort ( ) NEW_LINE if ( temp [ 0 ] < temp [ 1 ] and temp [ 1 ] < temp [ 2 ] and temp [ 0 ] * temp [ 1 ] * temp [ 2 ] <= x ) : NEW_LINE INDENT answer += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return answer NEW_LINE DEDENT
Hyp: 
def countTriplets ( a , n , x ) : NEW_LINE INDENT answer = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n , 1 ) : NEW_LINE INDENT for k in range ( j + 1 , n , 1 ) : NEW_LINE INDENT temp = [ ] NEW_LINE temp . append ( a [ i ] ) NEW_LINE temp . append ( a [ j ] ) NEW_LINE temp . append ( a [ k ] ) NEW_LINE if ( temp [ 0 ] < temp [ 1 ] and temp [ 1 ] < temp [ 2 ] ) : NEW_LINE INDENT answer += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return answer NEW_LINE DEDENT

BLEU: 80.66
Edit Sim: 79


Src: 
int findNumber ( int n ) { int x = ( int ) Math . floor ( ( - 1 + Math . sqrt ( 1 + 8 * n - 8 ) ) / 2 ) ; int base = ( x * ( x + 1 ) ) / 2 + 1 ; return n - base + 1 ; }
Ref: 
def findNumber ( n ) : NEW_LINE INDENT x = int ( math . floor ( ( - 1 + math . sqrt ( 1 + 8 * n - 8 ) ) / 2 ) ) NEW_LINE base = ( x * ( x + 1 ) ) / 2 + 1 NEW_LINE return n - base + 1 NEW_LINE DEDENT
Hyp: 
def findNumber ( n ) : NEW_LINE INDENT x = math . floor ( ( - 1 + math . sqrt ( 1 + 8 * n - 8 ) ) / 2 ) ; NEW_LINE base = ( x * ( x + 1 ) ) // 2 + 1 ; NEW_LINE return n - base + 1 ; NEW_LINE DEDENT

BLEU: 81.06
Edit Sim: 12


Src: 
void minAND ( int [ ] arr , int n ) { int s = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { s = s & arr [ i ] ; } System . out . println ( s ) ; }
Ref: 
def minAND ( arr , n ) : NEW_LINE INDENT s = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT s = s & arr [ i ] NEW_LINE DEDENT print ( s ) NEW_LINE DEDENT
Hyp: 
def minAND ( arr , n ) : NEW_LINE INDENT s = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT s = s & arr [ i ] NEW_LINE DEDENT print ( s ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int numberOf2sinRange ( int n ) { String s = " " ; for ( int i = 0 ; i < n + 1 ; i ++ ) s += String . valueOf ( i ) ; int count = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == '2' ) { count ++ ; } } return count ; }
Ref: 
def numberOf2sinRange ( n ) : NEW_LINE INDENT s = " " NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT s += str ( i ) NEW_LINE DEDENT return ( list ( s ) . count ( '2' ) ) NEW_LINE DEDENT
Hyp: 
def numberOf2sinRange ( n ) : NEW_LINE INDENT s = " " NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT s += str ( i ) NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == '2' ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT

BLEU: 49.36
Edit Sim: 131


Src: 
int countDistinctCode ( String str ) { Set < String > codes = new HashSet < > ( ) ; for ( int i = 0 ; i < str . length ( ) - 1 ; i ++ ) codes . add ( str . substring ( i , i + 2 ) ) ; return codes . size ( ) ; }
Ref: 
def countDistinctCode ( string ) : NEW_LINE INDENT codes = set ( ) NEW_LINE for i in range ( 0 , len ( string ) - 1 ) : NEW_LINE INDENT codes . add ( string [ i : i + 2 ] ) NEW_LINE DEDENT return len ( codes ) NEW_LINE DEDENT
Hyp: 
def countDistinctCode ( str ) : NEW_LINE INDENT codes = set ( ) NEW_LINE for i in range ( len ( str ) - 1 ) : NEW_LINE INDENT codes . add ( str [ i : len ( str ) - 1 ] ) NEW_LINE DEDENT return len ( codes ) NEW_LINE DEDENT

BLEU: 68.61
Edit Sim: 25


Src: 
double get ( double L , double R ) { double x = 1.0 / L ; double y = 1.0 / ( R + 1.0 ) ; return ( x - y ) ; }
Ref: 
def get ( L , R ) : NEW_LINE INDENT x = 1.0 / L ; NEW_LINE y = 1.0 / ( R + 1.0 ) ; NEW_LINE return ( x - y ) ; NEW_LINE DEDENT
Hyp: 
def get ( L , R ) : NEW_LINE INDENT x = 1.0 / L NEW_LINE y = 1.0 / ( R + 1.0 ) NEW_LINE return ( x - y ) NEW_LINE DEDENT

BLEU: 79.18
Edit Sim: 6


Src: 
int findMinSum ( int mat [ ] [ ] , int N ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int res = 0 ; for ( int j = 0 ; j < N ; j ++ ) { if ( i != j ) { res |= mat [ i ] [ j ] ; } } sum += res ; } return sum ; }
Ref: 
def findMinSum ( mat , N ) : NEW_LINE INDENT sum1 = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT res = 0 NEW_LINE for j in range ( N ) : NEW_LINE INDENT if ( i != j ) : NEW_LINE INDENT res |= mat [ i ] [ j ] NEW_LINE DEDENT DEDENT sum1 += res NEW_LINE DEDENT return sum1 NEW_LINE DEDENT
Hyp: 
def findMinSum ( mat , N ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT res = 0 NEW_LINE for j in range ( N ) : NEW_LINE INDENT if ( i != j ) : NEW_LINE INDENT res |= mat [ i ] [ j ] NEW_LINE DEDENT DEDENT sum += res NEW_LINE DEDENT return sum NEW_LINE DEDENT

BLEU: 89.06
Edit Sim: 3


Src: 
int maxLength ( int arr [ ] , int n ) { int maxLen = 0 ; int i = 0 ; int j = i + 1 ; while ( j < n ) { if ( arr [ i ] != arr [ j ] ) { maxLen = Math . max ( maxLen , 2 ) ; int l = i - 1 ; int r = j + 1 ; while ( l >= 0 && r < n && arr [ l ] == arr [ i ] && arr [ r ] == arr [ j ] ) { l -- ; r ++ ; } maxLen = Math . max ( maxLen , 2 * ( r - j ) ) ; } i ++ ; j = i + 1 ; } return maxLen ; }
Ref: 
def maxLength ( arr , n ) : NEW_LINE INDENT maxLen = 0 NEW_LINE i = 0 NEW_LINE j = i + 1 NEW_LINE while ( j < n ) : NEW_LINE INDENT if ( arr [ i ] != arr [ j ] ) : NEW_LINE INDENT maxLen = max ( maxLen , 2 ) NEW_LINE l = i - 1 NEW_LINE r = j + 1 NEW_LINE while ( l >= 0 and r < n and arr [ l ] == arr [ i ] and arr [ r ] == arr [ j ] ) : NEW_LINE INDENT l -= 1 NEW_LINE r += 1 NEW_LINE DEDENT maxLen = max ( maxLen , 2 * ( r - j ) ) NEW_LINE DEDENT i += 1 NEW_LINE j = i + 1 NEW_LINE DEDENT return maxLen NEW_LINE DEDENT
Hyp: 
def maxLength ( arr , n ) : NEW_LINE INDENT maxLen = 0 ; NEW_LINE i = 0 ; j = i + 1 ; NEW_LINE while ( j < n ) : NEW_LINE INDENT if ( arr [ i ] != arr [ j ] ) : NEW_LINE INDENT maxLen = max ( maxLen , 2 ) ; NEW_LINE DEDENT l = i - 1 ; NEW_LINE r = j + 1 ; NEW_LINE while ( l >= 0 and r < n and arr [ l ] == arr [ i ] and arr [ r ] == arr [ j ] ) : NEW_LINE INDENT l -= 1 ; NEW_LINE r += 1 ; NEW_LINE DEDENT maxLen = max ( maxLen , 2 * ( r - j ) ) ; NEW_LINE DEDENT i += 1 ; NEW_LINE j = i + 1 ; NEW_LINE INDENT return maxLen ; NEW_LINE DEDENT

BLEU: 78.23
Edit Sim: 39


Src: 
int nthSHN ( int n , int dp [ ] ) { if ( n == 1 n == 2 ) return dp [ n ] = 1 ; if ( dp [ n ] != - 1 ) return dp [ n ] ; return dp [ n ] = ( ( 6 * n - 9 ) * nthSHN ( n - 1 , dp ) - ( n - 3 ) * nthSHN ( n - 2 , dp ) ) / n ; }
Ref: 
def nthSHN ( n , dp ) : NEW_LINE INDENT if ( n == 1 or n == 2 ) : NEW_LINE INDENT dp [ n ] = 1 NEW_LINE return dp [ n ] NEW_LINE DEDENT if ( dp [ n ] != - 1 ) : NEW_LINE INDENT return dp [ n ] NEW_LINE DEDENT dp [ n ] = ( ( 6 * n - 9 ) * nthSHN ( n - 1 , dp ) - ( n - 3 ) * nthSHN ( n - 2 , dp ) ) / n NEW_LINE return dp [ n ] NEW_LINE DEDENT
Hyp: 
def nthSHN ( n , dp ) : NEW_LINE INDENT if ( n == 1 or n == 2 ) : NEW_LINE INDENT dp [ n ] = 1 NEW_LINE return dp [ n ] NEW_LINE DEDENT if ( dp [ n ] != - 1 ) : NEW_LINE INDENT return dp [ n ] NEW_LINE DEDENT dp [ n ] = ( ( 6 * n - 9 ) * nthSHN ( n - 1 , dp ) - ( n - 3 ) * nthSHN ( n - 2 , dp ) ) // n NEW_LINE return dp [ n ] NEW_LINE DEDENT

BLEU: 97.59
Edit Sim: 1


Src: 
int missingK ( int [ ] a , int k , int n ) { int difference = 0 , ans = 0 , count = k ; boolean flag = false ; for ( int i = 0 ; i < n - 1 ; i ++ ) { difference = 0 ; if ( ( a [ i ] + 1 ) != a [ i + 1 ] ) { difference += ( a [ i + 1 ] - a [ i ] ) - 1 ; if ( difference >= count ) { ans = a [ i ] + count ; flag = true ; break ; } else count -= difference ; } } if ( flag ) return ans ; else return - 1 ; }
Ref: 
def missingK ( a , k , n ) : NEW_LINE INDENT difference = 0 NEW_LINE ans = 0 NEW_LINE count = k NEW_LINE flag = 0 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT difference = 0 NEW_LINE if ( ( a [ i ] + 1 ) != a [ i + 1 ] ) : NEW_LINE INDENT difference += ( a [ i + 1 ] - a [ i ] ) - 1 NEW_LINE if ( difference >= count ) : NEW_LINE INDENT ans = a [ i ] + count NEW_LINE flag = 1 NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT count -= difference NEW_LINE DEDENT DEDENT DEDENT if ( flag ) : NEW_LINE INDENT return ans NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT
Hyp: 
def missingK ( a , k , n ) : NEW_LINE INDENT difference = 0 NEW_LINE ans = 0 NEW_LINE count = k NEW_LINE flag = False NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT difference = 0 NEW_LINE if ( ( a [ i ] + 1 ) != a [ i + 1 ] ) : NEW_LINE INDENT difference += ( a [ i + 1 ] - a [ i ] ) - 1 NEW_LINE if ( difference >= count ) : NEW_LINE INDENT ans = a [ i ] + count NEW_LINE flag = True NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT count -= difference NEW_LINE DEDENT DEDENT if ( flag ) : NEW_LINE INDENT return ans NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT

BLEU: 93.04
Edit Sim: 20


Src: 
void sortarray ( int arr [ ] , int N ) { if ( N == 3 ) System . out . println ( " NO " ) ; else if ( N % 4 == 0 N % 4 == 1 ) { System . out . println ( " YES " ) ; System . out . println ( N / 2 ) ; int k = 1 , l ; for ( l = 0 ; l < ( N / 4 ) ; l ++ ) { System . out . println ( k + " ▁ " + ( k + 1 ) + " ▁ " + N ) ; System . out . println ( k + 1 + " ▁ " + N + " ▁ " + ( N - 1 ) ) ; k = k + 2 ; N = N - 2 ; } } else System . out . println ( " NO " ) ; }
Ref: 
def sortarray ( arr , N ) : NEW_LINE INDENT if ( N == 3 ) : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT elif ( N % 4 == 0 or N % 4 == 1 ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE print ( N // 2 ) NEW_LINE k = 1 NEW_LINE for l in range ( N // 4 ) : NEW_LINE INDENT print ( k , k + 1 , N ) NEW_LINE print ( k + 1 , N , N - 1 ) NEW_LINE k = k + 2 NEW_LINE N = N - 2 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
Hyp: 
def sortarray ( arr , N ) : NEW_LINE INDENT if ( N == 3 ) : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT elif ( N % 4 == 0 or N % 4 == 1 ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE print ( N // 2 ) NEW_LINE k = 1 NEW_LINE for l in range ( ( N // 4 ) ) : NEW_LINE INDENT print ( k , ( k + 1 ) , N ) NEW_LINE print ( k + 1 , " ▁ " , N , " ▁ " , ( N - 1 ) ) NEW_LINE k = k + 2 NEW_LINE N = N - 2 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT

BLEU: 84.29
Edit Sim: 28


Src: 
int calculate ( int X ) { int number_of_bits = 8 ; return ( ( 1 << number_of_bits ) - 1 ) ^ X ; }
Ref: 
def calculate ( X ) : NEW_LINE INDENT number_of_bits = 8 NEW_LINE return ( ( 1 << number_of_bits ) - 1 ) ^ X NEW_LINE DEDENT
Hyp: 
def calculate ( X ) : NEW_LINE INDENT number_of_bits = 8 NEW_LINE return ( ( 1 << number_of_bits ) - 1 ) ^ X NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int countKAverageSubarrays ( int arr [ ] , int n , int k ) { int res = 0 ; for ( int L = 0 ; L < n ; L ++ ) { int sum = 0 ; for ( int R = L ; R < n ; R ++ ) { sum += arr [ R ] ; int len = ( R - L + 1 ) ; if ( sum % len == 0 ) { int avg = sum / len ; if ( avg == k ) res ++ ; } } } return res ; }
Ref: 
def countKAverageSubarrays ( arr , n , k ) : NEW_LINE INDENT res = 0 NEW_LINE for L in range ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for R in range ( L , n , 1 ) : NEW_LINE INDENT sum += arr [ R ] NEW_LINE len1 = ( R - L + 1 ) NEW_LINE if ( sum % len1 == 0 ) : NEW_LINE INDENT avg = sum // len1 NEW_LINE if ( avg == k ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return res NEW_LINE DEDENT
Hyp: 
def countKAverageSubarrays ( arr , n , k ) : NEW_LINE INDENT res = 0 NEW_LINE for L in range ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for R in range ( L , n ) : NEW_LINE INDENT sum += arr [ R ] NEW_LINE len = ( R - L + 1 ) NEW_LINE if ( sum % len == 0 ) : NEW_LINE INDENT avg = sum // len NEW_LINE if ( avg == k ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return res NEW_LINE DEDENT

BLEU: 88.65
Edit Sim: 7


Src: 
int countPairs ( int N ) { int res = 0 ; for ( int q = 1 ; q * q <= N ; q ++ ) { int maxP = Math . min ( 2 * N - q , N / q ) ; if ( maxP < q ) continue ; int cnt = maxP - q + 1 ; res += ( cnt / 2 + ( cnt & 1 ) ) ; } return res ; }
Ref: 
def countPairs ( N ) : NEW_LINE INDENT res = 0 NEW_LINE for q in range ( 1 , int ( math . sqrt ( N ) ) + 1 ) : NEW_LINE INDENT maxP = min ( 2 * N - q , N // q ) NEW_LINE if ( maxP < q ) : NEW_LINE INDENT continue NEW_LINE DEDENT cnt = maxP - q + 1 NEW_LINE res += ( cnt // 2 + ( cnt & 1 ) ) NEW_LINE DEDENT return res NEW_LINE DEDENT
Hyp: 
def countPairs ( N ) : NEW_LINE INDENT res = 0 NEW_LINE for q in range ( 1 , N ) : NEW_LINE INDENT maxP = min ( 2 * N - q , N // q ) NEW_LINE if ( maxP < q ) : NEW_LINE INDENT continue NEW_LINE DEDENT cnt = maxP - q + 1 NEW_LINE res += ( cnt // 2 + ( cnt & 1 ) ) NEW_LINE DEDENT return res NEW_LINE DEDENT

BLEU: 85.65
Edit Sim: 28


Src: 
int ConcatenateArr ( int [ ] arr , int N ) { int ans = arr [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) { int l = ( int ) Math . floor ( Math . log10 ( arr [ i ] ) + 1 ) ; ans = ans * ( int ) Math . pow ( 10 , l ) ; ans += arr [ i ] ; } return ans ; }
Ref: 
def ConcatenateArr ( arr , N ) : NEW_LINE INDENT ans = arr [ 0 ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT l = math . floor ( math . log10 ( arr [ i ] ) + 1 ) NEW_LINE ans = ans * math . pow ( 10 , l ) NEW_LINE ans += arr [ i ] NEW_LINE DEDENT return int ( ans ) NEW_LINE DEDENT
Hyp: 
def ConcatenateArr ( arr , N ) : NEW_LINE INDENT ans = arr [ 0 ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT l = math . floor ( math . log10 ( arr [ i ] ) + 1 ) NEW_LINE ans = ans * math . pow ( 10 , l ) NEW_LINE ans += arr [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT

BLEU: 93.29
Edit Sim: 8


Src: 
int findSum ( int n ) { return ( int ) Math . pow ( n , 3 ) ; }
Ref: 
def findSum ( n ) : NEW_LINE INDENT return n ** 3 ; NEW_LINE DEDENT
Hyp: 
def findSum ( n ) : NEW_LINE INDENT return pow ( n , 3 ) ; NEW_LINE DEDENT

BLEU: 57.82
Edit Sim: 10


Src: 
int strScore ( String str [ ] , String s , int n ) { int score = 0 , index = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == s ) { for ( int j = 0 ; j < s . length ( ) ; j ++ ) score += s . charAt ( j ) - ' a ' + 1 ; index = i + 1 ; break ; } } score = score * index ; return score ; }
Ref: 
def strScore ( str , s , n ) : NEW_LINE INDENT score = 0 NEW_LINE index = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( str [ i ] == s ) : NEW_LINE INDENT for j in range ( len ( s ) ) : NEW_LINE INDENT score += ( ord ( s [ j ] ) - ord ( ' a ' ) + 1 ) NEW_LINE DEDENT index = i + 1 NEW_LINE break NEW_LINE DEDENT DEDENT score = score * index NEW_LINE return score NEW_LINE DEDENT
Hyp: 
def strScore ( s , n ) : NEW_LINE INDENT score = 0 ; NEW_LINE index = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( str [ i ] == s ) : NEW_LINE INDENT for j in range ( len ( s ) ) : NEW_LINE INDENT score += ord ( s [ j ] ) - ord ( ' a ' ) + 1 ; NEW_LINE DEDENT index = i + 1 ; NEW_LINE break ; NEW_LINE DEDENT DEDENT score = score * index ; NEW_LINE return score ; NEW_LINE DEDENT

BLEU: 79.2
Edit Sim: 21


Src: 
int sum ( int n ) { return n * ( n + 1 ) * ( n + 2 ) / 3 ; }
Ref: 
def Sum ( n ) : NEW_LINE INDENT return n * ( n + 1 ) * ( n + 2 ) // 3 NEW_LINE DEDENT
Hyp: 
def sum ( n ) : NEW_LINE INDENT return n * ( n + 1 ) * ( n + 2 ) // 3 NEW_LINE DEDENT

BLEU: 93.05
Edit Sim: 1


Src: 
int MinimumValue ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int minXor = Integer . MAX_VALUE ; int val = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { val = arr [ i ] ^ arr [ i + 1 ] ; minXor = Math . min ( minXor , val ) ; } return minXor ; }
Ref: 
def MinimumValue ( arr , n ) : NEW_LINE INDENT arr . sort ( ) ; NEW_LINE minXor = sys . maxsize ; NEW_LINE val = 0 ; NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT val = arr [ i ] ^ arr [ i + 1 ] ; NEW_LINE minXor = min ( minXor , val ) ; NEW_LINE DEDENT return minXor ; NEW_LINE DEDENT
Hyp: 
def MinimumValue ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE minXor = sys . maxsize NEW_LINE val = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT val = arr [ i ] ^ arr [ i + 1 ] NEW_LINE minXor = min ( minXor , val ) NEW_LINE DEDENT return minXor NEW_LINE DEDENT

BLEU: 73.82
Edit Sim: 16


Src: 
void find3largest ( int [ ] arr ) { Arrays . sort ( arr ) ; int n = arr . length ; int check = 0 , count = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( count < 4 ) { if ( check != arr [ n - i ] ) { System . out . print ( arr [ n - i ] + " ▁ " ) ; check = arr [ n - i ] ; count ++ ; } } else break ; } }
Ref: 
def find3largest ( arr , n ) : NEW_LINE INDENT arr = sorted ( arr ) NEW_LINE check = 0 NEW_LINE count = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( count < 4 ) : NEW_LINE INDENT if ( check != arr [ n - i ] ) : NEW_LINE INDENT print ( arr [ n - i ] , end = " ▁ " ) NEW_LINE check = arr [ n - i ] NEW_LINE count += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT
Hyp: 
def find3largest ( arr ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE n = len ( arr ) NEW_LINE check = 0 NEW_LINE count = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( count < 4 ) : NEW_LINE INDENT if ( check != arr [ n - i ] ) : NEW_LINE INDENT print ( arr [ n - i ] , end = " ▁ " ) NEW_LINE check = arr [ n - i ] NEW_LINE count += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT

BLEU: 89.97
Edit Sim: 25


Src: 
double length_rope ( double r ) { return ( ( 2 * PI * r ) + 6 * r ) ; }
Ref: 
def length_rope ( r ) : NEW_LINE INDENT return ( ( 2 * PI * r ) + 6 * r ) NEW_LINE DEDENT
Hyp: 
def length_rope ( r ) : NEW_LINE INDENT return ( ( 2 * PI * r ) + 6 * r ) ; NEW_LINE DEDENT

BLEU: 90.58
Edit Sim: 2


Src: 
double find_Variance ( int n ) { long numerator = n * n - 1 ; double ans = ( numerator * 1.0 ) / 12 ; return ans ; }
Ref: 
def find_Variance ( n ) : NEW_LINE INDENT numerator = n * n - 1 NEW_LINE ans = ( numerator * 1.0 ) / 12 NEW_LINE return ans NEW_LINE DEDENT
Hyp: 
def find_Variance ( n ) : NEW_LINE INDENT numerator = n * n - 1 NEW_LINE ans = ( numerator * 1.0 ) / 12 NEW_LINE return ans NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int answerQuery ( int a [ ] , int n , int l , int r ) { int count = 0 ; l = l - 1 ; for ( int i = l ; i < r ; i ++ ) { int element = a [ i ] ; int divisors = 0 ; for ( int j = l ; j < r ; j ++ ) { if ( a [ j ] % a [ i ] == 0 ) divisors ++ ; else break ; } if ( divisors == ( r - l ) ) count ++ ; } return count ; }
Ref: 
def answerQuery ( a , n , l , r ) : NEW_LINE INDENT count = 0 NEW_LINE l = l - 1 NEW_LINE for i in range ( l , r , 1 ) : NEW_LINE INDENT element = a [ i ] NEW_LINE divisors = 0 NEW_LINE for j in range ( l , r , 1 ) : NEW_LINE INDENT if ( a [ j ] % a [ i ] == 0 ) : NEW_LINE INDENT divisors += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( divisors == ( r - l ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
Hyp: 
def answerQuery ( a , n , l , r ) : NEW_LINE INDENT count = 0 NEW_LINE l = l - 1 NEW_LINE for i in range ( l , r ) : NEW_LINE INDENT element = a [ i ] NEW_LINE divisors = 0 NEW_LINE for j in range ( l , r ) : NEW_LINE INDENT if ( a [ j ] % a [ i ] == 0 ) : NEW_LINE INDENT divisors += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( divisors == ( r - l ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT

BLEU: 93.86
Edit Sim: 8


Src: 
int getTotalNumberOfSequences ( int m , int n ) { if ( m < n ) return 0 ; if ( n == 0 ) return 1 ; return getTotalNumberOfSequences ( m - 1 , n ) + getTotalNumberOfSequences ( m / 2 , n - 1 ) ; }
Ref: 
def getTotalNumberOfSequences ( m , n ) : NEW_LINE INDENT if m < n : NEW_LINE INDENT return 0 NEW_LINE DEDENT if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT res = ( getTotalNumberOfSequences ( m - 1 , n ) + getTotalNumberOfSequences ( m // 2 , n - 1 ) ) NEW_LINE return res NEW_LINE DEDENT
Hyp: 
def getTotalNumberOfSequences ( m , n ) : NEW_LINE INDENT if ( m < n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return getTotalNumberOfSequences ( m - 1 , n ) + getTotalNumberOfSequences ( m // 2 , n - 1 ) NEW_LINE DEDENT

BLEU: 73.81
Edit Sim: 35


Src: 
int longCommomAnagramSubseq ( String str1 , String str2 , int n1 , int n2 ) { int [ ] freq1 = new int [ SIZE ] ; int [ ] freq2 = new int [ SIZE ] ; for ( int i = 0 ; i < SIZE ; i ++ ) { freq1 [ i ] = 0 ; freq2 [ i ] = 0 ; } int len = 0 ; for ( int i = 0 ; i < n1 ; i ++ ) freq1 [ ( int ) str1 . charAt ( i ) - ( int ) ' a ' ] ++ ; for ( int i = 0 ; i < n2 ; i ++ ) freq2 [ ( int ) str2 . charAt ( i ) - ( int ) ' a ' ] ++ ; for ( int i = 0 ; i < SIZE ; i ++ ) len += Math . min ( freq1 [ i ] , freq2 [ i ] ) ; return len ; }
Ref: 
def longCommomAnagramSubseq ( str1 , str2 , n1 , n2 ) : NEW_LINE INDENT freq1 = [ 0 ] * SIZE NEW_LINE freq2 = [ 0 ] * SIZE NEW_LINE l = 0 NEW_LINE for i in range ( n1 ) : NEW_LINE INDENT freq1 [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( n2 ) : NEW_LINE INDENT freq2 [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( SIZE ) : NEW_LINE INDENT l += min ( freq1 [ i ] , freq2 [ i ] ) NEW_LINE DEDENT return l NEW_LINE DEDENT
Hyp: 
def longCommomAnagramSubseq ( str1 , str2 , n1 , n2 ) : NEW_LINE INDENT freq1 = [ 0 ] * SIZE NEW_LINE freq2 = [ 0 ] * SIZE NEW_LINE for i in range ( SIZE ) : NEW_LINE INDENT freq1 [ i ] = 0 NEW_LINE freq2 [ i ] = 0 NEW_LINE DEDENT len = 0 NEW_LINE for i in range ( n1 ) : NEW_LINE INDENT freq1 [ ( int ) ( str1 [ i ] - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( n2 ) : NEW_LINE INDENT freq2 [ ( int ) ( str2 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( SIZE ) : NEW_LINE INDENT len += min ( freq1 [ i ] , freq2 [ i ] ) NEW_LINE DEDENT return len NEW_LINE DEDENT

BLEU: 72.13
Edit Sim: 121


Src: 
int countTriplets ( int N ) { int ans = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 1 ; j <= N ; j ++ ) { if ( i * j > N ) break ; ans += N / ( i * j ) ; } } return ans ; }
Ref: 
def countTriplets ( N ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( i * j > N ) : NEW_LINE INDENT break NEW_LINE DEDENT ans += N // ( i * j ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
Hyp: 
def countTriplets ( N ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( i * j > N ) : NEW_LINE INDENT break NEW_LINE DEDENT ans += N // ( i * j ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
void minOperations ( String S ) { int count = 0 ; for ( int i = 1 ; i < S . length ( ) ; i ++ ) { if ( S . charAt ( i ) != S . charAt ( i - 1 ) ) { count += 1 ; } } System . out . print ( count ) ; }
Ref: 
def minOperations ( S ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( 1 , len ( S ) ) : NEW_LINE INDENT if ( S [ i ] != S [ i - 1 ] ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT print ( count ) ; NEW_LINE DEDENT
Hyp: 
def minOperations ( S ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , len ( S ) ) : NEW_LINE INDENT if ( S [ i ] != S [ i - 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT

BLEU: 87.26
Edit Sim: 6


Src: 
void triangleArea ( int a , int b ) { double ratio = ( double ) b / a ; System . out . println ( ratio ) ; }
Ref: 
def triangleArea ( a , b ) : NEW_LINE INDENT ratio = b / a NEW_LINE print ( ratio ) NEW_LINE DEDENT
Hyp: 
def triangleArea ( a , b ) : NEW_LINE INDENT ratio = b / a NEW_LINE print ( ratio ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
boolean isPower ( int N , int K ) { int res1 = ( int ) ( Math . log ( N ) / Math . log ( K ) ) ; double res2 = Math . log ( N ) / Math . log ( K ) ; return ( res1 == res2 ) ; }
Ref: 
def isPower ( n , k ) : NEW_LINE INDENT res1 = int ( log ( n ) / log ( k ) ) NEW_LINE res2 = log ( n ) / log ( k ) NEW_LINE return ( res1 == res2 ) NEW_LINE DEDENT
Hyp: 
def isPower ( N , K ) : NEW_LINE INDENT res1 = int ( log ( N ) / log ( K ) ) NEW_LINE res2 = log ( N ) / log ( K ) NEW_LINE return ( res1 == res2 ) NEW_LINE DEDENT N = 12 NEW_LINE K = 4 NEW_LINE if isPower ( N , K ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT

BLEU: 35.66
Edit Sim: 166


Src: 
int findPieces ( int n ) { return ( n * ( n + 1 ) ) / 2 + 1 ; }
Ref: 
def findPieces ( n ) : NEW_LINE INDENT return ( n * ( n + 1 ) ) // 2 + 1 NEW_LINE DEDENT
Hyp: 
def findPieces ( n ) : NEW_LINE INDENT return ( n * ( n + 1 ) ) // 2 + 1 NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int Minimum ( int N , int K ) { int sum = N * ( N + 1 ) / 2 ; if ( K > sum ) return - 1 ; if ( K <= N ) return 1 ; sum = 0 ; int count = 0 ; while ( N >= 1 && sum < K ) { count += 1 ; sum += N ; N -= 1 ; } return count ; }
Ref: 
def Minimum ( N , K ) : NEW_LINE INDENT sum = N * ( N + 1 ) // 2 NEW_LINE if ( K > sum ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( K <= N ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT sum = 0 NEW_LINE count = 0 NEW_LINE while ( N >= 1 and sum < K ) : NEW_LINE INDENT count += 1 NEW_LINE sum += N NEW_LINE N -= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
Hyp: 
def Minimum ( N , K ) : NEW_LINE INDENT sum = N * ( N + 1 ) / 2 NEW_LINE if ( K > sum ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( K <= N ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT sum = 0 NEW_LINE count = 0 NEW_LINE while ( N >= 1 and sum < K ) : NEW_LINE INDENT count += 1 NEW_LINE sum += N NEW_LINE N -= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT

BLEU: 97.08
Edit Sim: 1


Src: 
int countCompositions ( int n ) { return 1 << ( n - 1 ) ; }
Ref: 
def countCompositions ( n ) : NEW_LINE INDENT return ( 2 ** ( n - 1 ) ) NEW_LINE DEDENT
Hyp: 
def countCompositions ( n ) : NEW_LINE INDENT return 1 << ( n - 1 ) NEW_LINE DEDENT

BLEU: 66.01
Edit Sim: 7


Src: 
void bin ( long n ) { long i ; System . out . print ( "0" ) ; for ( i = 1 << 30 ; i > 0 ; i = i / 2 ) { if ( ( n & i ) != 0 ) { System . out . print ( "1" ) ; } else { System . out . print ( "0" ) ; } } }
Ref: 
def bin ( n ) : NEW_LINE INDENT i = 1 << 31 NEW_LINE while ( i > 0 ) : NEW_LINE INDENT if ( ( n & i ) != 0 ) : NEW_LINE INDENT print ( "1" , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "0" , end = " " ) NEW_LINE DEDENT i = i // 2 NEW_LINE DEDENT DEDENT
Hyp: 
def bin ( n ) : NEW_LINE INDENT print ( "0" ) NEW_LINE for i in range ( 1 << 30 , 20 , 1 ) : NEW_LINE INDENT if ( n & i ) : NEW_LINE INDENT print ( "1" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "0" ) NEW_LINE DEDENT DEDENT DEDENT

BLEU: 45.71
Edit Sim: 88


Src: 
int nthDigit ( int a , int n , int b ) { for ( int i = 1 ; i < n ; i ++ ) a = a / b ; return a % b ; }
Ref: 
def nthDigit ( a , n , b ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT a = a // b NEW_LINE DEDENT return a % b NEW_LINE DEDENT
Hyp: 
def nthDigit ( a , n , b ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT a = a // b NEW_LINE DEDENT return a % b NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int findSum ( int N ) { return ( 2 * N * ( N + 1 ) * ( 4 * N + 17 ) + 54 * N ) / 6 ; }
Ref: 
def findSum ( N ) : NEW_LINE INDENT return ( 2 * N * ( N + 1 ) * ( 4 * N + 17 ) + 54 * N ) / 6 NEW_LINE DEDENT
Hyp: 
def findSum ( N ) : NEW_LINE INDENT return ( 2 * N * ( N + 1 ) * ( 4 * N + 17 ) + 54 * N ) / 6 NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int first ( int a , int b , int c ) { a %= b ; for ( int i = 1 ; i <= b ; i ++ ) { a = a * 10 ; if ( a / b == c ) return i ; a %= b ; } return - 1 ; }
Ref: 
def first ( a , b , c ) : NEW_LINE INDENT a %= b NEW_LINE for i in range ( 1 , b + 1 ) : NEW_LINE INDENT a = a * 10 NEW_LINE if int ( a / b ) == c : NEW_LINE INDENT return i NEW_LINE DEDENT a %= b NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
Hyp: 
def first ( a , b , c ) : NEW_LINE INDENT a %= b NEW_LINE for i in range ( 1 , b + 1 ) : NEW_LINE INDENT a = a * 10 NEW_LINE if ( a // b == c ) : NEW_LINE INDENT return i NEW_LINE DEDENT a %= b NEW_LINE DEDENT return - 1 NEW_LINE DEDENT

BLEU: 87.51
Edit Sim: 9


Src: 
int findPairCount ( int N , int K ) { int count = 0 ; int rem [ ] = new int [ K ] ; rem [ 0 ] = N / K ; for ( int i = 1 ; i < K ; i ++ ) rem [ i ] = ( N - i ) / K + 1 ; if ( K % 2 == 0 ) { count += ( rem [ 0 ] * ( rem [ 0 ] - 1 ) ) / 2 ; for ( int i = 1 ; i < K / 2 ; i ++ ) count += rem [ i ] * rem [ K - i ] ; count += ( rem [ K / 2 ] * ( rem [ K / 2 ] - 1 ) ) / 2 ; } else { count += ( rem [ 0 ] * ( rem [ 0 ] - 1 ) ) / 2 ; for ( int i = 1 ; i <= K / 2 ; i ++ ) count += rem [ i ] * rem [ K - i ] ; } return count ; }
Ref: 
def findPairCount ( N , K ) : NEW_LINE INDENT count = 0 ; NEW_LINE rem = [ 0 ] * K ; NEW_LINE rem [ 0 ] = N // K ; NEW_LINE for i in range ( 1 , K ) : NEW_LINE INDENT rem [ i ] = ( N - i ) // K + 1 ; NEW_LINE DEDENT if ( K % 2 == 0 ) : NEW_LINE INDENT count += ( rem [ 0 ] * ( rem [ 0 ] - 1 ) ) // 2 ; NEW_LINE for i in range ( 1 , K // 2 ) : NEW_LINE INDENT count += rem [ i ] * rem [ K - i ] ; NEW_LINE DEDENT count += ( rem [ K // 2 ] * ( rem [ K // 2 ] - 1 ) ) // 2 ; NEW_LINE DEDENT else : NEW_LINE INDENT count += ( rem [ 0 ] * ( rem [ 0 ] - 1 ) ) // 2 ; NEW_LINE for i in rage ( 1 , K // 2 + 1 ) : NEW_LINE INDENT count += rem [ i ] * rem [ K - i ] ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT
Hyp: 
def findPairCount ( N , K ) : NEW_LINE INDENT count = 0 NEW_LINE rem = [ 0 ] * K NEW_LINE for i in range ( 1 , K ) : NEW_LINE INDENT rem [ i ] = ( N - i ) / K + 1 NEW_LINE DEDENT if ( K % 2 == 0 ) : NEW_LINE INDENT count += ( rem [ 0 ] * ( rem [ 0 ] - 1 ) ) // 2 NEW_LINE for i in range ( 1 , K // 2 ) : NEW_LINE INDENT count += ( rem [ i ] * rem [ K - i ] ) NEW_LINE DEDENT count += ( rem [ K // 2 ] * ( rem [ K // 2 ] - 1 ) ) // 2 NEW_LINE DEDENT else : NEW_LINE INDENT count += ( rem [ 0 ] * ( rem [ 0 ] - 1 ) ) // 2 NEW_LINE DEDENT for i in range ( 1 , K // 2 ) : NEW_LINE INDENT count += ( rem [ i ] * rem [ K - i ] ) NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT

BLEU: 78.54
Edit Sim: 63


Src: 
boolean check ( int arr [ ] , int n ) { int i , g ; g = 0 ; for ( i = 1 ; i < n ; i ++ ) { if ( arr [ i ] - arr [ i - 1 ] > 0 && g == 1 ) return false ; if ( arr [ i ] - arr [ i - 1 ] < 0 ) g = 1 ; } return true ; }
Ref: 
def check ( arr , n ) : NEW_LINE INDENT g = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] - arr [ i - 1 ] > 0 and g == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( arr [ i ] - arr [ i ] < 0 ) : NEW_LINE INDENT g = 1 NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT arr = [ 2 , 3 , 4 , 10 , 4 , 3 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE if ( check ( arr , n ) == True ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
Hyp: 
def check ( arr , n ) : NEW_LINE INDENT i , g = 0 , 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] - arr [ i - 1 ] > 0 and g == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( arr [ i ] - arr [ i - 1 ] < 0 ) : NEW_LINE INDENT g = 1 NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT arr = [ 2 , 3 , 4 , 5 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE if ( check ( arr , n ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT

BLEU: 86.57
Edit Sim: 33


Src: 
double calculateSum ( double n ) { return 2 * ( Math . pow ( n , 6 ) + 15 * Math . pow ( n , 4 ) + 15 * Math . pow ( n , 2 ) + 1 ) ; }
Ref: 
def calculateSum ( n ) : NEW_LINE INDENT a = int ( n ) NEW_LINE return ( 2 * ( pow ( n , 6 ) + 15 * pow ( n , 4 ) + 15 * pow ( n , 2 ) + 1 ) ) NEW_LINE DEDENT
Hyp: 
def calculateSum ( n ) : NEW_LINE INDENT return ( 2 * ( pow ( n , 6 ) + 15 * pow ( n , 4 ) + 15 * pow ( n , 2 ) + 1 ) ) NEW_LINE DEDENT

BLEU: 81.88
Edit Sim: 23


Src: 
int countDecreasing ( int A [ ] , int n ) { int len = 1 ; for ( int i = 0 ; i < n - 1 ; ++ i ) { if ( A [ i + 1 ] < A [ i ] ) len ++ ; else { cnt += ( ( ( len - 1 ) * len ) / 2 ) ; len = 1 ; } } if ( len > 1 ) cnt += ( ( ( len - 1 ) * len ) / 2 ) ; return cnt ; }
Ref: 
def countDecreasing ( A , n ) : NEW_LINE INDENT len = 1 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( A [ i + 1 ] < A [ i ] ) : NEW_LINE INDENT len += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt += ( ( ( len - 1 ) * len ) // 2 ) ; NEW_LINE len = 1 NEW_LINE DEDENT DEDENT if ( len > 1 ) : NEW_LINE INDENT cnt += ( ( ( len - 1 ) * len ) // 2 ) NEW_LINE DEDENT return cnt NEW_LINE DEDENT
Hyp: 
def countDecreasing ( A , n ) : NEW_LINE INDENT cnt = 0 NEW_LINE len = 1 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( A [ i + 1 ] < A [ i ] ) : NEW_LINE INDENT len += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt += ( ( len - 1 ) * len ) // 2 ) NEW_LINE DEDENT len = 1 NEW_LINE DEDENT if ( len > 1 ) : NEW_LINE INDENT cnt += ( ( len - 1 ) * len ) // 2 ) NEW_LINE DEDENT return cnt NEW_LINE DEDENT

BLEU: 91.34
Edit Sim: 37


Src: 
int findX ( int A , int B ) { int X = 0 ; for ( int bit = 0 ; bit < MAX ; bit ++ ) { int tempBit = 1 << bit ; int bitOfX = A & B & tempBit ; X += bitOfX ; } return X ; }
Ref: 
def findX ( A , B ) : NEW_LINE INDENT X = 0 ; NEW_LINE for bit in range ( MAX ) : NEW_LINE INDENT tempBit = 1 << bit ; NEW_LINE bitOfX = A & B & tempBit ; NEW_LINE X += bitOfX ; NEW_LINE DEDENT return X ; NEW_LINE DEDENT
Hyp: 
def findX ( A , B ) : NEW_LINE INDENT X = 0 NEW_LINE for bit in range ( 0 , MAX ) : NEW_LINE INDENT tempBit = 1 << bit NEW_LINE bitOfX = A & B & tempBit NEW_LINE X += bitOfX NEW_LINE DEDENT return X NEW_LINE DEDENT

BLEU: 71.77
Edit Sim: 14


Src: 
int countTriplets ( int [ ] arr , int n , int a , int b ) { int ans = 0 ; for ( int i = 0 ; i < n - 2 ; i ++ ) { for ( int j = i + 1 ; j < n - 1 ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) { if ( arr [ i ] + arr [ j ] + arr [ k ] >= a && arr [ i ] + arr [ j ] + arr [ k ] <= b ) { ans ++ ; } } } } return ans ; }
Ref: 
def countTriplets ( arr , n , a , b ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 0 , n - 2 ) : NEW_LINE INDENT for j in range ( i + 1 , n - 1 ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT if ( ( arr [ i ] + arr [ j ] + arr [ k ] >= a ) and ( arr [ i ] + arr [ j ] + arr [ k ] <= b ) ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
Hyp: 
def countTriplets ( arr , n , a , b ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n - 2 ) : NEW_LINE INDENT for j in range ( i + 1 , n - 1 ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] + arr [ j ] + arr [ k ] >= a and arr [ i ] + arr [ j ] + arr [ k ] <= b ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT

BLEU: 90.13
Edit Sim: 12


Src: 
void constructArr ( int arr [ ] , int pair [ ] , int n ) { arr [ 0 ] = ( pair [ 0 ] + pair [ 1 ] - pair [ n - 1 ] ) / 2 ; for ( int i = 1 ; i < n ; i ++ ) arr [ i ] = pair [ i - 1 ] - arr [ 0 ] ; }
Ref: 
def constructArr ( arr , pair , n ) : NEW_LINE INDENT arr [ 0 ] = ( pair [ 0 ] + pair [ 1 ] - pair [ n - 1 ] ) // 2 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT arr [ i ] = pair [ i - 1 ] - arr [ 0 ] NEW_LINE DEDENT DEDENT
Hyp: 
def constructArr ( arr , pair , n ) : NEW_LINE INDENT arr [ 0 ] = ( pair [ 0 ] + pair [ 1 ] - pair [ n - 1 ] ) // 2 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT arr [ i ] = ( pair [ i - 1 ] - arr [ 0 ] ) NEW_LINE DEDENT DEDENT

BLEU: 92.8
Edit Sim: 4


Src: 
boolean checking ( String s ) { int c = 0 ; int n = s . length ( ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( s . charAt ( i ) == '0' ) c ++ ; if ( c >= 6 && s . charAt ( i ) == '1' ) return true ; } return false ; }
Ref: 
def checking ( s ) : NEW_LINE INDENT c = 0 NEW_LINE n = len ( s ) NEW_LINE i = n - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if ( c >= 6 and s [ i ] == '1' ) : NEW_LINE INDENT return True NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT return False NEW_LINE DEDENT
Hyp: 
def checking ( s ) : NEW_LINE INDENT c = 0 NEW_LINE n = len ( s ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if ( c >= 6 and s [ i ] == '1' ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT

BLEU: 79.9
Edit Sim: 43


Src: 
int maxXOR ( int n , int k ) { int c = ( int ) ( Math . log ( n ) / Math . log ( 2 ) ) + 1 ; return ( ( 1 << c ) - 1 ) ; }
Ref: 
def maxXOR ( n , k ) : NEW_LINE INDENT c = int ( math . log ( n , 2 ) ) + 1 NEW_LINE return ( ( 1 << c ) - 1 ) NEW_LINE DEDENT
Hyp: 
def maxXOR ( n , k ) : NEW_LINE INDENT c = int ( math . log2 ( n ) ) + 1 NEW_LINE return ( ( 1 << c ) - 1 ) NEW_LINE DEDENT

BLEU: 84.26
Edit Sim: 5


Src: 
void findNumbers ( int N ) { int i = 1 ; while ( i <= N ) { System . out . print ( ( i * i * i ) + " ▁ " ) ; i ++ ; } }
Ref: 
def findNumbers ( N ) : NEW_LINE INDENT i = 1 NEW_LINE while ( i <= N ) : NEW_LINE INDENT print ( ( i * i * i ) , end = " ▁ " ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT
Hyp: 
def findNumbers ( N ) : NEW_LINE INDENT i = 1 NEW_LINE while ( i <= N ) : NEW_LINE INDENT print ( ( i * i * i ) , end = " ▁ " ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int maxLCM ( int n ) { return ( n * ( n - 1 ) ) ; }
Ref: 
def maxLCM ( n ) : NEW_LINE INDENT return ( n * ( n - 1 ) ) ; NEW_LINE DEDENT
Hyp: 
def maxLCM ( n ) : NEW_LINE INDENT return ( n * ( n - 1 ) ) ; NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
double SumofInverseDivisors ( int N , int Sum ) { double ans = ( double ) ( Sum ) * 1.0 / ( double ) ( N ) ; return ans ; }
Ref: 
def SumofInverseDivisors ( N , Sum ) : NEW_LINE INDENT ans = float ( Sum ) * 1.0 / float ( N ) ; NEW_LINE return round ( ans , 2 ) ; NEW_LINE DEDENT
Hyp: 
def SumofInverseDivisors ( N , Sum ) : NEW_LINE INDENT ans = Sum * 1.0 / ( N ) NEW_LINE return ans NEW_LINE DEDENT

BLEU: 41.89
Edit Sim: 34


Src: 
void atleastkDistinctChars ( String s , int k ) { int n = s . length ( ) ; Map < Character , Integer > mp = new HashMap < > ( ) ; int begin = 0 , end = 0 ; int ans = 0 ; while ( end < n ) { char c = s . charAt ( end ) ; mp . put ( c , mp . getOrDefault ( c , 0 ) + 1 ) ; end ++ ; while ( mp . size ( ) >= k ) { char pre = s . charAt ( begin ) ; mp . put ( pre , mp . getOrDefault ( pre , 0 ) - 1 ) ; if ( mp . get ( pre ) == 0 ) { mp . remove ( pre ) ; } ans += s . length ( ) - end + 1 ; begin ++ ; } } System . out . println ( ans ) ; }
Ref: 
def atleastkDistinctChars ( s , k ) : NEW_LINE INDENT n = len ( s ) NEW_LINE mp = defaultdict ( int ) NEW_LINE begin = 0 NEW_LINE end = 0 NEW_LINE ans = 0 NEW_LINE while ( end < n ) : NEW_LINE INDENT c = s [ end ] NEW_LINE mp += 1 NEW_LINE end += 1 NEW_LINE while ( len ( mp ) >= k ) : NEW_LINE INDENT pre = s [ begin ] NEW_LINE mp [ pre ] -= 1 NEW_LINE if ( mp [ pre ] == 0 ) : NEW_LINE INDENT del mp [ pre ] NEW_LINE DEDENT ans += len ( s ) - end + 1 NEW_LINE begin += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
Hyp: 
def atleastkDistinctChars ( s , k ) : NEW_LINE INDENT n = len ( s ) NEW_LINE mp = defaultdict ( int ) NEW_LINE begin = 0 NEW_LINE end = 0 NEW_LINE ans = 0 NEW_LINE while ( end < n ) : NEW_LINE INDENT c = s [ end ] NEW_LINE mp [ c ] += 1 NEW_LINE end += 1 NEW_LINE while ( mp [ size ( ) >= k ) : NEW_LINE INDENT pre = s [ begin ] NEW_LINE mp [ pre ] -= 1 NEW_LINE if ( mp [ pre ] == 0 ) : NEW_LINE INDENT mp [ pre ] -= 1 NEW_LINE DEDENT ans += len ( s ) - end + 1 NEW_LINE begin += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT

BLEU: 89.12
Edit Sim: 25


Src: 
int getMissingNo ( int a [ ] , int n ) { int total = 1 ; for ( int i = 2 ; i <= ( n + 1 ) ; i ++ ) { total += i ; total -= a [ i - 2 ] ; } return total ; }
Ref: 
def getMissingNo ( a , n ) : NEW_LINE INDENT i , total = 0 , 1 NEW_LINE for i in range ( 2 , n + 2 ) : NEW_LINE INDENT total += i NEW_LINE total -= a [ i - 2 ] NEW_LINE DEDENT return total NEW_LINE DEDENT
Hyp: 
def getMissingNo ( a , n ) : NEW_LINE INDENT total = 1 NEW_LINE for i in range ( 2 , ( n + 1 ) + 1 ) : NEW_LINE INDENT total += i NEW_LINE total -= a [ i - 2 ] NEW_LINE DEDENT return total NEW_LINE DEDENT

BLEU: 78.18
Edit Sim: 17


Src: 
int FindMaxS ( int X , int Y , int Z , int n , int [ ] A , int [ ] B , int [ ] C ) { if ( X < 0 Y < 0 Z < 0 ) return Integer . MIN_VALUE ; if ( n < 0 ) return 0 ; if ( dp [ n ] [ X ] [ Y ] [ Z ] != - 1 ) { return dp [ n ] [ X ] [ Y ] [ Z ] ; } int ch = A [ n ] + FindMaxS ( X - 1 , Y , Z , n - 1 , A , B , C ) ; int ca = B [ n ] + FindMaxS ( X , Y - 1 , Z , n - 1 , A , B , C ) ; int co = C [ n ] + FindMaxS ( X , Y , Z - 1 , n - 1 , A , B , C ) ; int no = FindMaxS ( X , Y , Z , n - 1 , A , B , C ) ; int maximum = Math . max ( ch , Math . max ( ca , Math . max ( co , no ) ) ) ; return dp [ n ] [ X ] [ Y ] [ Z ] = maximum ; }
Ref: 
def FindMaxS ( X , Y , Z , n , A , B , C ) : NEW_LINE INDENT if ( X < 0 or Y < 0 or Z < 0 ) : NEW_LINE INDENT return - sys . maxsize - 1 NEW_LINE DEDENT if ( n < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ n ] [ X ] [ Y ] [ Z ] != - 1 ) : NEW_LINE INDENT return dp [ n ] [ X ] [ Y ] [ Z ] NEW_LINE DEDENT ch = A [ n ] + FindMaxS ( X - 1 , Y , Z , n - 1 , A , B , C ) NEW_LINE ca = B [ n ] + FindMaxS ( X , Y - 1 , Z , n - 1 , A , B , C ) NEW_LINE co = C [ n ] + FindMaxS ( X , Y , Z - 1 , n - 1 , A , B , C ) NEW_LINE no = FindMaxS ( X , Y , Z , n - 1 , A , B , C ) NEW_LINE maximum = max ( ch , max ( ca , max ( co , no ) ) ) NEW_LINE dp [ n ] [ X ] [ Y ] [ Z ] = maximum NEW_LINE return dp [ n ] [ X ] [ Y ] [ Z ] NEW_LINE DEDENT
Hyp: 
def FindMaxS ( X , Y , Z , n , A , B , C ) : NEW_LINE INDENT if ( X < 0 Y < 0 Z < 0 ) : NEW_LINE INDENT return sys . maxsize NEW_LINE DEDENT if ( n < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ n ] [ X ] [ Y ] [ Z ] != - 1 ) : NEW_LINE INDENT return dp [ n ] [ X ] [ Y ] [ Z ] NEW_LINE DEDENT ch = A [ n ] + FindMaxS ( X - 1 , Y , Z , n - 1 , A , B , C ) NEW_LINE ca = B [ n ] + FindMaxS ( X , Y - 1 , Z , n - 1 , A , B , C ) NEW_LINE no = FindMaxS ( X , Y , Z , n - 1 , A , B , C ) NEW_LINE maximum = max ( ch , max ( ca , max ( co , no ) ) ) NEW_LINE return dp [ n ] [ X ] [ Y ] [ Z ] = maximum NEW_LINE DEDENT

BLEU: 76.75
Edit Sim: 133


Src: 
int maxOfSegmentMins ( int [ ] a , int n , int k ) { if ( k == 1 ) { Arrays . sort ( a ) ; return a [ 0 ] ; } if ( k == 2 ) return Math . max ( a [ 0 ] , a [ n - 1 ] ) ; return a [ n - 1 ] ; }
Ref: 
def maxOfSegmentMins ( a , n , k ) : NEW_LINE INDENT if k == 1 : NEW_LINE INDENT return min ( a ) NEW_LINE DEDENT if k == 2 : NEW_LINE INDENT return max ( a [ 0 ] , a [ n - 1 ] ) NEW_LINE DEDENT return max ( a ) NEW_LINE DEDENT
Hyp: 
def maxOfSegmentMins ( a , n , k ) : NEW_LINE INDENT if ( k == 1 ) : NEW_LINE INDENT a . sort ( ) NEW_LINE return a [ 0 ] NEW_LINE DEDENT if ( k == 2 ) : NEW_LINE INDENT return max ( a [ 0 ] , a [ n - 1 ] ) NEW_LINE DEDENT return a [ n - 1 ] NEW_LINE DEDENT

BLEU: 57.73
Edit Sim: 44


Src: 
boolean isDivisible ( int n ) { int d ; while ( ( n / 100 ) > 0 ) { d = n % 10 ; n /= 10 ; n = Math . abs ( n - ( d * 14 ) ) ; } return ( n % 47 == 0 ) ; }
Ref: 
def isDivisible ( n ) : NEW_LINE INDENT while n // 100 : NEW_LINE INDENT d = n % 10 NEW_LINE n //= 10 NEW_LINE n = abs ( n - ( d * 14 ) ) NEW_LINE DEDENT return ( n % 47 == 0 ) NEW_LINE DEDENT
Hyp: 
def isDivisible ( n ) : NEW_LINE INDENT while ( n // 100 ) > 0 : NEW_LINE INDENT d = n % 10 NEW_LINE n //= 10 NEW_LINE n = abs ( n - ( d * 14 ) ) NEW_LINE DEDENT return ( n % 47 == 0 ) NEW_LINE DEDENT n = 121 NEW_LINE if ( isDivisible ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT

BLEU: 52.46
Edit Sim: 158


Src: 
float find_angle ( int x , int y , int z ) { int volume = x * x * y ; float ans = 0 ; if ( z < volume / 2 ) { float d = ( float ) ( ( x * y * y ) / ( 2.0 * z ) ) ; ans = ( float ) Math . atan ( d ) ; } else { z = volume - z ; float d = ( 2 * z ) / ( float ) ( x * x * x ) ; ans = ( float ) Math . atan ( d ) ; } ans = ( float ) ( ( ans * 180 ) / 3.14159265 ) ; return ans ; }
Ref: 
def find_angle ( x , y , z ) : NEW_LINE INDENT volume = x * x * y ; NEW_LINE ans = 0 ; NEW_LINE if ( z < volume // 2 ) : NEW_LINE INDENT d = ( x * y * y ) / ( 2.0 * z ) ; NEW_LINE ans = atan ( d ) ; NEW_LINE DEDENT else : NEW_LINE INDENT z = volume - z ; NEW_LINE d = ( 2 * z ) / ( float ) ( x * x * x ) ; NEW_LINE ans = atan ( d ) ; NEW_LINE DEDENT ans = ( ans * 180 ) / 3.14159265 ; NEW_LINE return round ( ans , 4 ) ; NEW_LINE DEDENT
Hyp: 
def find_angle ( x , y , z ) : NEW_LINE INDENT volume = x * x * y NEW_LINE ans = 0 NEW_LINE if ( z < volume / 2 ) : NEW_LINE INDENT d = ( x * y * y ) / ( 2.0 * z ) NEW_LINE ans = math . atan ( d ) NEW_LINE DEDENT else : NEW_LINE INDENT z = volume - z NEW_LINE d = ( 2 * z ) / ( x * x * x ) NEW_LINE ans = math . atan ( d ) NEW_LINE DEDENT DEDENT ans = math . degrees ( ans * 180 ) / 3.14159265 ) NEW_LINE return ans NEW_LINE DEDENT

BLEU: 67.12
Edit Sim: 78


Src: 
int lenOfLongSubarr ( int arr [ ] , int n ) { HashMap < Integer , Integer > um = new HashMap < Integer , Integer > ( ) ; int sum = 0 , maxLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] == 0 ? - 1 : 1 ; if ( sum == 1 ) maxLen = i + 1 ; else if ( ! um . containsKey ( sum ) ) um . put ( sum , i ) ; if ( um . containsKey ( sum - 1 ) ) { if ( maxLen < ( i - um . get ( sum - 1 ) ) ) maxLen = i - um . get ( sum - 1 ) ; } } return maxLen ; }
Ref: 
def lenOfLongSubarr ( arr , n ) : NEW_LINE INDENT um = { i : 0 for i in range ( 10 ) } NEW_LINE sum = 0 NEW_LINE maxLen = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] == 0 : NEW_LINE INDENT sum += - 1 NEW_LINE DEDENT else : NEW_LINE INDENT sum += 1 NEW_LINE DEDENT if ( sum == 1 ) : NEW_LINE INDENT maxLen = i + 1 NEW_LINE DEDENT elif ( sum not in um ) : NEW_LINE INDENT um [ sum ] = i NEW_LINE DEDENT if ( ( sum - 1 ) in um ) : NEW_LINE INDENT if ( maxLen < ( i - um [ sum - 1 ] ) ) : NEW_LINE INDENT maxLen = i - um [ sum - 1 ] NEW_LINE DEDENT DEDENT DEDENT return maxLen NEW_LINE DEDENT
Hyp: 
def lenOfLongSubarr ( arr , n ) : NEW_LINE INDENT um = dict ( ) NEW_LINE sum = 0 NEW_LINE maxLen = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] == 0 ? - 1 : 1 NEW_LINE if ( sum == 1 ) : NEW_LINE INDENT maxLen = i + 1 NEW_LINE DEDENT elif ( um [ sum ] ) : NEW_LINE INDENT um [ sum ] = i NEW_LINE DEDENT if ( um [ sum - 1 ] ) : NEW_LINE INDENT if ( maxLen < ( i - um [ sum - 1 ] ) ) : NEW_LINE INDENT maxLen = i - um [ sum - 1 ] NEW_LINE DEDENT DEDENT DEDENT return maxLen NEW_LINE DEDENT

BLEU: 70.23
Edit Sim: 127


Src: 
int seiresSum ( int n , int [ ] a ) { return n * ( a [ 0 ] * a [ 0 ] - a [ 2 * n - 1 ] * a [ 2 * n - 1 ] ) / ( 2 * n - 1 ) ; }
Ref: 
def seiresSum ( n , a ) : NEW_LINE INDENT return ( n * ( a [ 0 ] * a [ 0 ] - a [ 2 * n - 1 ] * a [ 2 * n - 1 ] ) / ( 2 * n - 1 ) ) NEW_LINE DEDENT
Hyp: 
def seiresSum ( n , a ) : NEW_LINE INDENT return n * ( a [ 0 ] * a [ 0 ] - a [ 2 * n - 1 ] * a [ 2 * n - 1 ] ) / ( 2 * n - 1 ) NEW_LINE DEDENT

BLEU: 91.87
Edit Sim: 4


Src: 
void printGP ( int a , int r , int n ) { int curr_term ; for ( int i = 0 ; i < n ; i ++ ) { curr_term = a * ( int ) Math . pow ( r , i ) ; System . out . print ( curr_term + " ▁ " ) ; } }
Ref: 
def printGP ( a , r , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT curr_term = a * pow ( r , i ) NEW_LINE print ( curr_term , end = " ▁ " ) NEW_LINE DEDENT DEDENT
Hyp: 
def printGP ( a , r , n ) : NEW_LINE INDENT curr_term = a * pow ( r , i ) NEW_LINE print ( curr_term , end = " ▁ " ) NEW_LINE DEDENT DEDENT

BLEU: 71.65
Edit Sim: 43


Src: 
int findMinValue ( int arr [ ] , int n ) { long sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; return ( ( int ) ( sum / n ) + 1 ) ; }
Ref: 
def findMinValue ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT return ( sum // n ) + 1 NEW_LINE DEDENT
Hyp: 
def findMinValue ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT return ( int ) ( sum / n ) + 1 ) NEW_LINE DEDENT

BLEU: 81.53
Edit Sim: 11


Src: 
void findPoint ( int x1 , int y1 , int x2 , int y2 ) { System . out . println ( " ( " + ( int ) ( 2 * x2 - x1 ) + " , " + ( int ) ( 2 * y2 - y1 ) + " ▁ ) " ) ; }
Ref: 
def findPoint ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT print ( " ( " , 2 * x2 - x1 , " , " , 2 * y2 - y1 , " ) " ) ; NEW_LINE DEDENT
Hyp: 
def findPoint ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT print ( " ( " , ( 2 * x2 - x1 ) , " , " , ( 2 * y2 - y1 ) , " ▁ ) " , sep = " " ) NEW_LINE DEDENT

BLEU: 62.03
Edit Sim: 22


Src: 
int smallest ( int x , int y , int z ) { if ( ( y / x ) != 1 ) return ( ( y / z ) != 1 ) ? y : z ; return ( ( x / z ) != 1 ) ? x : z ; }
Ref: 
def smallest ( x , y , z ) : NEW_LINE INDENT if ( not ( y / x ) ) : NEW_LINE INDENT return y if ( not ( y / z ) ) else z NEW_LINE DEDENT return x if ( not ( x / z ) ) else z NEW_LINE DEDENT
Hyp: 
def smallest ( x , y , z ) : NEW_LINE INDENT if ( ( y // x ) != 1 ) : NEW_LINE INDENT return ( ( y // z ) != 1 ) else : NEW_LINE DEDENT return ( ( x // z ) != 1 ) ? x : z NEW_LINE DEDENT

BLEU: 43.7
Edit Sim: 41


Src: 
int countTriplets ( int A [ ] , int N ) { int ans = 0 ; HashMap < Integer , Integer > map = new HashMap < Integer , Integer > ( ) ; for ( int j = N - 2 ; j >= 1 ; j -- ) { if ( map . containsKey ( A [ j + 1 ] ) ) map . put ( A [ j + 1 ] , map . get ( A [ j + 1 ] ) + 1 ) ; else map . put ( A [ j + 1 ] , 1 ) ; for ( int i = 0 ; i < j ; i ++ ) { int target = A [ i ] * A [ j ] ; if ( map . containsKey ( target ) ) ans += map . get ( target ) ; } } return ans ; }
Ref: 
def countTriplets ( A , N ) : NEW_LINE INDENT ans = 0 NEW_LINE map = defaultdict ( lambda : 0 ) NEW_LINE for j in range ( N - 2 , 0 , - 1 ) : NEW_LINE INDENT map [ A [ j + 1 ] ] += 1 NEW_LINE for i in range ( j ) : NEW_LINE INDENT target = A [ i ] * A [ j ] NEW_LINE if ( target in map . keys ( ) ) : NEW_LINE INDENT ans += map [ target ] NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
Hyp: 
def countTriplets ( A , N ) : NEW_LINE INDENT ans = 0 NEW_LINE map = { } NEW_LINE for j in range ( N - 2 , - 1 , - 1 ) : NEW_LINE INDENT if A [ j + 1 ] in map : NEW_LINE INDENT map [ A [ j + 1 ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT map [ A [ j + 1 ] ] = 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT

BLEU: 52.59
Edit Sim: 132


Src: 
void UpperHessenbergMatrix ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( i > j + 1 ) { System . out . print ( 0 + " ▁ " ) ; } else { System . out . print ( ( int ) ( Math . random ( ) * 10 ) + " ▁ " ) ; } } System . out . println ( ) ; } }
Ref: 
def UpperHessenbergMatrix ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( i > j + 1 ) : NEW_LINE INDENT print ( '0' , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( random . randint ( 1 , 10 ) , end = " ▁ " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT
Hyp: 
def UpperHessenbergMatrix ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( i > j + 1 ) : NEW_LINE INDENT print ( 0 , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( int ( math . random ( ) * 10 ) , end = " ▁ " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT

BLEU: 87.44
Edit Sim: 16


Src: 
int CalculateMax ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int min_sum = arr [ 0 ] + arr [ 1 ] ; int max_sum = arr [ n - 1 ] + arr [ n - 2 ] ; return ( Math . abs ( max_sum - min_sum ) ) ; }
Ref: 
def CalculateMax ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE min_sum = arr [ 0 ] + arr [ 1 ] NEW_LINE max_sum = arr [ n - 1 ] + arr [ n - 2 ] NEW_LINE return abs ( max_sum - min_sum ) NEW_LINE DEDENT
Hyp: 
def CalculateMax ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE min_sum = arr [ 0 ] + arr [ 1 ] NEW_LINE max_sum = arr [ n - 1 ] + arr [ n - 2 ] NEW_LINE return ( abs ( max_sum - min_sum ) ) NEW_LINE DEDENT

BLEU: 92.05
Edit Sim: 4


Src: 
int gonNum360 ( int n ) { return ( 358 * n * n - 356 * n ) / 2 ; }
Ref: 
def gonNum360 ( n ) : NEW_LINE INDENT return ( 358 * n * n - 356 * n ) // 2 ; NEW_LINE DEDENT
Hyp: 
def gonNum360 ( n ) : NEW_LINE INDENT return ( 358 * n * n - 356 * n ) // 2 NEW_LINE DEDENT

BLEU: 90.59
Edit Sim: 2


Src: 
long divide ( long dividend , long divisor ) { long sign = ( ( dividend < 0 ) ^ ( divisor < 0 ) ) ? - 1 : 1 ; dividend = Math . abs ( dividend ) ; divisor = Math . abs ( divisor ) ; long quotient = 0 , temp = 0 ; for ( int i = 31 ; i >= 0 ; -- i ) { if ( temp + ( divisor << i ) <= dividend ) { temp += divisor << i ; quotient |= 1L << i ; } } if ( sign == - 1 ) quotient = - quotient ; return quotient ; }
Ref: 
def divide ( dividend , divisor ) : NEW_LINE INDENT sign = ( - 1 if ( ( dividend < 0 ) ^ ( divisor < 0 ) ) else 1 ) ; NEW_LINE dividend = abs ( dividend ) ; NEW_LINE divisor = abs ( divisor ) ; NEW_LINE quotient = 0 ; NEW_LINE temp = 0 ; NEW_LINE for i in range ( 31 , - 1 , - 1 ) : NEW_LINE INDENT if ( temp + ( divisor << i ) <= dividend ) : NEW_LINE INDENT temp += divisor << i ; NEW_LINE quotient |= 1 << i ; NEW_LINE DEDENT DEDENT if sign == - 1 : NEW_LINE quotient = - quotient ; NEW_LINE return quotient ; NEW_LINE DEDENT
Hyp: 
def divide ( dividend , divisor ) : NEW_LINE INDENT sign = ( ( dividend < 0 ) ^ ( divisor < 0 ) ) ? - 1 : 1 NEW_LINE quotient = 0 NEW_LINE temp = 0 NEW_LINE for i in range ( 31 ) : NEW_LINE INDENT if ( temp + ( divisor << i ) <= dividend ) : NEW_LINE INDENT temp += divisor << i NEW_LINE quotient |= 1L << i NEW_LINE DEDENT DEDENT if ( sign == - 1 ) : NEW_LINE INDENT quotient = - quotient NEW_LINE DEDENT return quotient NEW_LINE DEDENT

BLEU: 55.17
Edit Sim: 134


Src: 
int findMinLength ( int [ ] arr ) { int index = ( int ) arr . length - 1 ; while ( index > 0 && arr [ index ] >= arr [ index - 1 ] ) { index -- ; } return index ; }
Ref: 
def findMinLength ( arr ) : NEW_LINE INDENT index = len ( arr ) - 1 ; NEW_LINE while ( index > 0 and arr [ index ] >= arr [ index - 1 ] ) : NEW_LINE INDENT index -= 1 ; NEW_LINE DEDENT return index ; NEW_LINE DEDENT
Hyp: 
def findMinLength ( arr ) : NEW_LINE INDENT index = len ( arr ) - 1 NEW_LINE while ( index > 0 and arr [ index ] >= arr [ index - 1 ] ) : NEW_LINE INDENT index -= 1 NEW_LINE DEDENT return index NEW_LINE DEDENT

BLEU: 84.86
Edit Sim: 6


Src: 
void checkTriangle ( int x , int y , int z ) { if ( x == y && y == z ) System . out . println ( " Equilateral ▁ Triangle " ) ; else if ( x == y y == z z == x ) System . out . println ( " Isosceles ▁ Triangle " ) ; else System . out . println ( " Scalene ▁ Triangle " ) ; }
Ref: 
def checkTriangle ( x , y , z ) : NEW_LINE INDENT if x == y == z : NEW_LINE INDENT print ( " Equilateral ▁ Triangle " ) NEW_LINE DEDENT elif x == y or y == z or z == x : NEW_LINE INDENT print ( " Isosceles ▁ Triangle " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Scalene ▁ Triangle " ) NEW_LINE DEDENT DEDENT
Hyp: 
def checkTriangle ( x , y , z ) : NEW_LINE INDENT if ( x == y and y == z ) : NEW_LINE INDENT print ( " Equilateral ▁ Triangle " ) NEW_LINE DEDENT elif ( x == y or y == z ) : NEW_LINE INDENT print ( " Isosceles ▁ Triangle " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Scalene ▁ Triangle " ) NEW_LINE DEDENT DEDENT

BLEU: 81.95
Edit Sim: 21


Src: 
void printMultiples ( int N ) { for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) { System . out . print ( ( i * j ) + " ▁ " ) ; } System . out . println ( ) ; } }
Ref: 
def prMultiples ( N ) : NEW_LINE INDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT print ( ( i * j ) , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT
Hyp: 
def printMultiples ( N ) : NEW_LINE INDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT print ( ( i * j ) , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT

BLEU: 96.94
Edit Sim: 3


Src: 
boolean isSurd ( int n ) { for ( int i = 2 ; i * i <= n ; i ++ ) { int j = i ; while ( j < n ) j = j * i ; if ( j == n ) return false ; } return true ; }
Ref: 
def isSurd ( n ) : NEW_LINE INDENT i = 2 NEW_LINE for i in range ( 2 , ( i * i ) + 1 ) : NEW_LINE INDENT j = i NEW_LINE while ( j < n ) : NEW_LINE INDENT j = j * i NEW_LINE DEDENT if ( j == n ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
Hyp: 
def isSurd ( n ) : NEW_LINE INDENT i = 2 NEW_LINE while i * i <= n : NEW_LINE INDENT j = i NEW_LINE while ( j < n ) : NEW_LINE INDENT j = j * i NEW_LINE if ( j == n ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT n = 25 NEW_LINE if isSurd ( n ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT

BLEU: 58.01
Edit Sim: 167


Src: 
int countNonDecreasing ( int n ) { int dp [ ] [ ] = new int [ 10 ] [ n + 1 ] ; for ( int i = 0 ; i < 10 ; i ++ ) dp [ i ] [ 1 ] = 1 ; for ( int digit = 0 ; digit <= 9 ; digit ++ ) { for ( int len = 2 ; len <= n ; len ++ ) { for ( int x = 0 ; x <= digit ; x ++ ) dp [ digit ] [ len ] += dp [ x ] [ len - 1 ] ; } } int count = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) count += dp [ i ] [ n ] ; return count ; }
Ref: 
def countNonDecreasing ( n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n + 1 ) ] for i in range ( 10 ) ] NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT dp [ i ] [ 1 ] = 1 NEW_LINE DEDENT for digit in range ( 10 ) : NEW_LINE INDENT for len in range ( 2 , n + 1 ) : NEW_LINE INDENT for x in range ( digit + 1 ) : NEW_LINE INDENT dp [ digit ] [ len ] += dp [ x ] [ len - 1 ] NEW_LINE DEDENT DEDENT DEDENT count = 0 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT count += dp [ i ] [ n ] NEW_LINE DEDENT return count NEW_LINE DEDENT
Hyp: 
def countNonDecreasing ( n ) : NEW_LINE INDENT dp = [ [ 0 for x in range ( n + 1 ) ] for y in range ( 10 ) ] NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT dp [ i ] [ 1 ] = 1 NEW_LINE DEDENT for digit in range ( 9 , 2 ) : NEW_LINE INDENT for l in range ( 2 , n + 1 ) : NEW_LINE INDENT for x in range ( digit + 1 ) : NEW_LINE INDENT dp [ digit ] [ l ] += dp [ x ] [ l - 1 ] NEW_LINE DEDENT DEDENT DEDENT count = 0 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT count += dp [ i ] [ n ] NEW_LINE DEDENT return count NEW_LINE DEDENT

BLEU: 87.73
Edit Sim: 13


Src: 
int findMin ( int arr [ ] , int n ) { int ans = 1 ; for ( int i = 0 ; i < n ; i ++ ) { int j = i + 1 ; while ( j < n && arr [ j ] >= arr [ j - 1 ] ) j ++ ; ans = Math . max ( ans , j - i ) ; i = j - 1 ; } return n - ans ; }
Ref: 
def findMin ( arr , n ) : NEW_LINE INDENT ans = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT j = i + 1 NEW_LINE while ( j < n and arr [ j ] >= arr [ j - 1 ] ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT ans = max ( ans , j - i ) NEW_LINE i = j - 1 NEW_LINE DEDENT return n - ans NEW_LINE DEDENT
Hyp: 
def findMin ( arr , n ) : NEW_LINE INDENT ans = 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT j = i + 1 NEW_LINE while ( j < n and arr [ j ] >= arr [ j - 1 ] ) : NEW_LINE j += 1 NEW_LINE ans = max ( ans , j - i ) NEW_LINE i = j - 1 NEW_LINE DEDENT return n - ans NEW_LINE DEDENT

BLEU: 91.66
Edit Sim: 18


Src: 
void divide ( int n , int m ) { System . out . println ( " Remainder ▁ = ▁ " + ( ( n ) & ( m - 1 ) ) ) ; System . out . println ( " Quotient ▁ = ▁ " + ( n >> ( int ) ( Math . log ( m ) / Math . log ( 2 ) ) ) ) ; }
Ref: 
def divide ( n , m ) : NEW_LINE INDENT print ( " Remainder ▁ = ▁ " , ( ( n ) & ( m - 1 ) ) ) NEW_LINE print ( " Quotient ▁ = ▁ " , ( n >> ( int ) ( math . log2 ( m ) ) ) ) NEW_LINE DEDENT
Hyp: 
def divide ( n , m ) : NEW_LINE INDENT print ( " Remainder ▁ = " , ( ( n ) & ( m - 1 ) ) ) NEW_LINE DEDENT print ( " Quotient ▁ = " , ( n >> ( int ) ( math . log2 ( m ) ) ) ) NEW_LINE DEDENT

BLEU: 88.58
Edit Sim: 11


Src: 
int highestPowerof2 ( int n ) { int res = 0 ; for ( int i = n ; i >= 1 ; i -- ) { if ( ( i & ( i - 1 ) ) == 0 ) { res = i ; break ; } } return res ; }
Ref: 
def highestPowerof2 ( n ) : NEW_LINE INDENT res = 0 ; NEW_LINE for i in range ( n , 0 , - 1 ) : NEW_LINE INDENT if ( ( i & ( i - 1 ) ) == 0 ) : NEW_LINE INDENT res = i ; NEW_LINE break ; NEW_LINE DEDENT DEDENT return res ; NEW_LINE DEDENT
Hyp: 
def highestPowerof2 ( n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( n , 0 , - 1 ) : NEW_LINE INDENT if ( ( i & ( i - 1 ) ) == 0 ) : NEW_LINE INDENT res = i NEW_LINE break NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT

BLEU: 83.49
Edit Sim: 8


Src: 
String largestPalinSub ( String s ) { String res = " " ; char mx = s . charAt ( 0 ) ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) mx = ( char ) Math . max ( ( int ) mx , ( int ) s . charAt ( i ) ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) if ( s . charAt ( i ) == mx ) res += s . charAt ( i ) ; return res ; }
Ref: 
def largestPalinSub ( s ) : NEW_LINE INDENT res = " " NEW_LINE mx = s [ 0 ] NEW_LINE for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT mx = max ( mx , s [ i ] ) NEW_LINE DEDENT for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT if s [ i ] == mx : NEW_LINE INDENT res += s [ i ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
Hyp: 
def largestPalinSub ( s ) : NEW_LINE INDENT res = " " NEW_LINE mx = ord ( s [ 0 ] ) NEW_LINE for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT mx = max ( mx , ord ( s [ i ] ) ) NEW_LINE DEDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == mx ) : NEW_LINE INDENT res += s [ i ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT

BLEU: 80.33
Edit Sim: 24


Src: 
void printTwoOdd ( int arr [ ] , int size ) { int xor2 = arr [ 0 ] ; int set_bit_no ; int i ; int n = size - 2 ; int x = 0 , y = 0 ; for ( i = 1 ; i < size ; i ++ ) xor2 = xor2 ^ arr [ i ] ; set_bit_no = xor2 & ~ ( xor2 - 1 ) ; for ( i = 0 ; i < size ; i ++ ) { if ( ( arr [ i ] & set_bit_no ) > 0 ) x = x ^ arr [ i ] ; else y = y ^ arr [ i ] ; } System . out . println ( " The ▁ two ▁ ODD ▁ elements ▁ are ▁ " + x + " ▁ & ▁ " + y ) ; }
Ref: 
def printTwoOdd ( arr , size ) : NEW_LINE INDENT xor2 = arr [ 0 ] NEW_LINE set_bit_no = 0 NEW_LINE n = size - 2 NEW_LINE x , y = 0 , 0 NEW_LINE for i in range ( 1 , size ) : NEW_LINE INDENT xor2 = xor2 ^ arr [ i ] NEW_LINE DEDENT set_bit_no = xor2 & ~ ( xor2 - 1 ) NEW_LINE for i in range ( size ) : NEW_LINE INDENT if ( arr [ i ] & set_bit_no ) : NEW_LINE INDENT x = x ^ arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT y = y ^ arr [ i ] NEW_LINE DEDENT DEDENT print ( " The ▁ two ▁ ODD ▁ elements ▁ are " , x , " & " , y ) NEW_LINE DEDENT
Hyp: 
def printTwoOdd ( arr , size ) : NEW_LINE INDENT xor2 = arr [ 0 ] NEW_LINE set_bit_no = arr [ 1 ] NEW_LINE n = size - 2 NEW_LINE x = 0 NEW_LINE y = 0 NEW_LINE for i in range ( 1 , size ) : NEW_LINE INDENT xor2 = xor2 ^ arr [ i ] NEW_LINE DEDENT set_bit_no = xor2 & ~ ( xor2 - 1 ) NEW_LINE for i in range ( size ) : NEW_LINE INDENT if ( arr [ i ] & set_bit_no ) > 0 : NEW_LINE INDENT x = x ^ arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT y = y ^ arr [ i ] NEW_LINE DEDENT DEDENT print ( " The ▁ two ▁ ODD ▁ elements ▁ are ▁ " , x , " ▁ & ▁ " , y ) NEW_LINE DEDENT

BLEU: 86.32
Edit Sim: 31


Src: 
int sumOfParts ( int [ ] [ ] arr , int N ) { int sum_part1 = 0 , sum_part2 = 0 , sum_part3 = 0 , sum_part4 = 0 ; int totalsum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( i + j < N - 1 ) { if ( i < j && i != j && i + j > 0 ) sum_part1 += arr [ i ] [ j ] ; else if ( i != j ) sum_part2 += arr [ i ] [ j ] ; } else { if ( i > j && i + j != N - 1 ) sum_part3 += arr [ i ] [ j ] ; else { if ( i + j != N - 1 && i != j ) sum_part4 += arr [ i ] [ j ] ; } } } } totalsum = sum_part1 + sum_part2 + sum_part3 + sum_part4 ; return totalsum ; }
Ref: 
def sumOfParts ( arr , N ) : NEW_LINE INDENT sum_part1 , sum_part2 , sum_part3 , sum_part4 = 0 , 0 , 0 , 0 NEW_LINE totalsum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if i + j < N - 1 : NEW_LINE INDENT if ( i < j and i != j and i + j ) : NEW_LINE INDENT sum_part1 += arr [ i ] [ j ] NEW_LINE DEDENT elif i != j : NEW_LINE INDENT sum_part2 += arr [ i ] [ j ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if i > j and i + j != N - 1 : NEW_LINE INDENT sum_part3 += arr [ i ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT if i + j != N - 1 and i != j : NEW_LINE INDENT sum_part4 += arr [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return sum_part1 + sum_part2 + sum_part3 + sum_part4 NEW_LINE DEDENT
Hyp: 
def sumOfParts ( arr , N ) : NEW_LINE INDENT sum_part1 = 0 NEW_LINE sum_part2 = 0 NEW_LINE sum_part3 = 0 NEW_LINE sum_part4 = 0 NEW_LINE totalsum = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( 0 , N ) : NEW_LINE INDENT if ( i + j < N - 1 ) : NEW_LINE INDENT if ( i < j and i != j and i + j > 0 ) : NEW_LINE INDENT sum_part1 += arr [ i ] [ j ] NEW_LINE DEDENT elif ( i != j ) : NEW_LINE INDENT sum_part2 += arr [ i ] [ j ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( i > j and i + j != N - 1 ) : NEW_LINE INDENT sum_part3 += arr [ i ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT if ( i + j != N - 1 and i != j ) : NEW_LINE INDENT sum_part4 += arr [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT totalsum = sum_part1 + sum_part2 + sum_part3 + sum_part4 ; NEW_LINE return totalsum NEW_LINE DEDENT

BLEU: 74.53
Edit Sim: 116


Src: 
long countNonDecreasing ( int n ) { int N = 10 ; long count = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { count *= ( N + i - 1 ) ; count /= i ; } return count ; }
Ref: 
def countNonDecreasing ( n ) : NEW_LINE INDENT N = 10 NEW_LINE count = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT count = int ( count * ( N + i - 1 ) ) NEW_LINE count = int ( count / i ) NEW_LINE DEDENT return count NEW_LINE DEDENT
Hyp: 
def countNonDecreasing ( n ) : NEW_LINE INDENT N = 10 NEW_LINE count = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT count *= ( N + i - 1 ) NEW_LINE count //= i NEW_LINE DEDENT return count NEW_LINE DEDENT

BLEU: 70.23
Edit Sim: 34


Src: 
int dodecahedral_num ( int n ) { return n * ( 3 * n - 1 ) * ( 3 * n - 2 ) / 2 ; }
Ref: 
def dodecahedral_num ( n ) : NEW_LINE INDENT return n * ( 3 * n - 1 ) * ( 3 * n - 2 ) // 2 NEW_LINE DEDENT
Hyp: 
def dodecahedral_num ( n ) : NEW_LINE INDENT return n * ( 3 * n - 1 ) * ( 3 * n - 2 ) // 2 NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
void freq ( int ar [ ] [ ] , int m , int n ) { int even = 0 , odd = 0 ; for ( int i = 0 ; i < m ; ++ i ) { for ( int j = 0 ; j < n ; ++ j ) { if ( ( ar [ i ] [ j ] % 2 ) == 0 ) ++ even ; else ++ odd ; } } System . out . print ( " ▁ Frequency ▁ of ▁ odd ▁ number ▁ = " + odd + " NEW_LINE"); System . out . print ( " ▁ Frequency ▁ of ▁ even ▁ number ▁ = ▁ " + even + " NEW_LINE"); }
Ref: 
def freq ( ar , m , n ) : NEW_LINE INDENT even = 0 NEW_LINE odd = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( ( ar [ i ] [ j ] % 2 ) == 0 ) : NEW_LINE INDENT even += 1 NEW_LINE DEDENT else : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT DEDENT DEDENT print ( " ▁ Frequency ▁ of ▁ odd ▁ number ▁ = " , odd ) NEW_LINE print ( " ▁ Frequency ▁ of ▁ even ▁ number ▁ = " , even ) NEW_LINE DEDENT
Hyp: 
def freq ( ar , m , n ) : NEW_LINE INDENT even = 0 NEW_LINE odd = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( ( ar [ i ] [ j ] % 2 ) == 0 ) : NEW_LINE INDENT even += 1 NEW_LINE DEDENT else : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT DEDENT print ( " ▁ Frequency ▁ of ▁ odd ▁ number ▁ = " , odd , " " ) NEW_LINE print ( " ▁ Frequency ▁ of ▁ even ▁ number ▁ = " , even , " " ) NEW_LINE DEDENT

BLEU: 92.01
Edit Sim: 19


Src: 
boolean isDivisible ( String str , int k ) { int n = str . length ( ) ; int c = 0 ; for ( int i = 0 ; i < k ; i ++ ) if ( str . charAt ( n - i - 1 ) == '0' ) c ++ ; return ( c == k ) ; }
Ref: 
def isDivisible ( str , k ) : NEW_LINE INDENT n = len ( str ) NEW_LINE c = 0 NEW_LINE for i in range ( 0 , k ) : NEW_LINE INDENT if ( str [ n - i - 1 ] == '0' ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT return ( c == k ) NEW_LINE DEDENT str1 = "10101100" NEW_LINE k = 2 NEW_LINE if ( isDivisible ( str1 , k ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT str2 = "111010100" NEW_LINE k = 2 NEW_LINE if ( isDivisible ( str2 , k ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
Hyp: 
def isDivisible ( str , k ) : NEW_LINE INDENT n = len ( str ) NEW_LINE c = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT if ( str [ n - i - 1 ] == '0' ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT return ( c == k ) NEW_LINE DEDENT

BLEU: 25.41
Edit Sim: 369


Src: 
int avg_of_even_num ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += 2 * i ; return ( sum / n ) ; }
Ref: 
def avg_of_even_num ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum = sum + 2 * i NEW_LINE DEDENT return sum / n NEW_LINE DEDENT
Hyp: 
def avg_of_even_num ( n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += 2 * i ; NEW_LINE DEDENT return ( sum / n ) ; NEW_LINE DEDENT

BLEU: 68.0
Edit Sim: 17


Src: 
boolean uniqueCharacters ( String str ) { int checker = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { int bitAtIndex = str . charAt ( i ) - ' a ' ; if ( ( checker & ( 1 << bitAtIndex ) ) > 0 ) return false ; checker = checker | ( 1 << bitAtIndex ) ; } return true ; }
Ref: 
def uniqueCharacters ( str ) : NEW_LINE INDENT checker = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT bitAtIndex = ord ( str [ i ] ) - ord ( ' a ' ) NEW_LINE if ( ( bitAtIndex ) > 0 ) : NEW_LINE INDENT if ( ( checker & ( ( 1 << bitAtIndex ) ) ) > 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT checker = checker | ( 1 << bitAtIndex ) NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
Hyp: 
def uniqueCharacters ( s ) : NEW_LINE INDENT checker = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT bitAtIndex = ord ( s [ i ] ) - ord ( ' a ' ) NEW_LINE if ( checker & ( 1 << bitAtIndex ) ) > 0 : NEW_LINE INDENT return False NEW_LINE DEDENT checker = checker | ( 1 << bitAtIndex ) NEW_LINE DEDENT return True NEW_LINE DEDENT s = " aaabbccdaa " NEW_LINE if ( uniqueCharacters ( s ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT

BLEU: 61.07
Edit Sim: 184


Src: 
void printClosest ( int arr [ ] , int n , int x ) { int res_l = 0 , res_r = 0 ; int l = 0 , r = n - 1 , diff = Integer . MAX_VALUE ; while ( r > l ) { if ( Math . abs ( arr [ l ] + arr [ r ] - x ) < diff ) { res_l = l ; res_r = r ; diff = Math . abs ( arr [ l ] + arr [ r ] - x ) ; } if ( arr [ l ] + arr [ r ] > x ) r -- ; else l ++ ; } System . out . println ( " ▁ The ▁ closest ▁ pair ▁ is ▁ " + arr [ res_l ] + " ▁ and ▁ " + arr [ res_r ] ) ; }
Ref: 
def printClosest ( arr , n , x ) : NEW_LINE INDENT res_l , res_r = 0 , 0 NEW_LINE l , r , diff = 0 , n - 1 , MAX_VAL NEW_LINE while r > l : NEW_LINE INDENT if abs ( arr [ l ] + arr [ r ] - x ) < diff : NEW_LINE INDENT res_l = l NEW_LINE res_r = r NEW_LINE diff = abs ( arr [ l ] + arr [ r ] - x ) NEW_LINE DEDENT if arr [ l ] + arr [ r ] > x : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT l += 1 NEW_LINE DEDENT DEDENT print ( ' The ▁ closest ▁ pair ▁ is ▁ { } ▁ and ▁ { } ' . format ( arr [ res_l ] , arr [ res_r ] ) ) NEW_LINE DEDENT
Hyp: 
def printClosest ( arr , n , x ) : NEW_LINE INDENT res_l = 0 NEW_LINE res_r = 0 NEW_LINE l = n - 1 NEW_LINE diff = 10 ** 20 NEW_LINE while ( r > l ) : NEW_LINE INDENT if ( abs ( arr [ l ] + arr [ r ] - x ) < diff ) : NEW_LINE INDENT res_l = l NEW_LINE res_r = r NEW_LINE diff = abs ( arr [ l ] + arr [ r ] - x ) NEW_LINE DEDENT if ( arr [ l ] + arr [ r ] > x ) : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT l += 1 NEW_LINE DEDENT DEDENT print ( " ▁ The ▁ closest ▁ pair ▁ is ▁ " , arr [ res_l ] , " ▁ and ▁ " , arr [ res_r ] ) NEW_LINE DEDENT

BLEU: 72.53
Edit Sim: 90


Src: 
boolean checkCentrosymmetricted ( int n , int m [ ] [ ] ) { int mid_row ; if ( ( n & 1 ) > 0 ) mid_row = n / 2 + 1 ; else mid_row = n / 2 ; for ( int i = 0 ; i < mid_row ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( m [ i ] [ j ] != m [ n - i - 1 ] [ n - j - 1 ] ) return false ; } } return true ; }
Ref: 
def checkCentrosymmetricted ( n , m ) : NEW_LINE INDENT mid_row = 0 ; NEW_LINE if ( ( n & 1 ) > 0 ) : NEW_LINE INDENT mid_row = n / 2 + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT mid_row = n / 2 ; NEW_LINE DEDENT for i in range ( int ( mid_row ) ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( m [ i ] [ j ] != m [ n - i - 1 ] [ n - j - 1 ] ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT DEDENT return True ; NEW_LINE DEDENT n = 3 ; NEW_LINE m = [ [ 1 , 3 , 5 ] , [ 6 , 8 , 6 ] , [ 5 , 3 , 1 ] ] ; NEW_LINE if ( checkCentrosymmetricted ( n , m ) ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT
Hyp: 
def checkCentrosymmetricted ( n , m ) : NEW_LINE INDENT if ( n & 1 ) : NEW_LINE INDENT mid_row = n // 2 + 1 NEW_LINE DEDENT else : NEW_LINE INDENT mid_row = n // 2 NEW_LINE DEDENT for i in range ( mid_row ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( m [ i ] [ j ] != m [ n - i - 1 ] [ n - j - 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT

BLEU: 35.94
Edit Sim: 284


Src: 
boolean isDivBy2PowerM ( int n , int m ) { if ( ( n & ( ( 1 << m ) - 1 ) ) == 0 ) return true ; return false ; }
Ref: 
def isDivBy2PowerM ( n , m ) : NEW_LINE INDENT if ( n & ( ( 1 << m ) - 1 ) ) == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT n = 8 NEW_LINE m = 2 NEW_LINE if isDivBy2PowerM ( n , m ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
Hyp: 
def isDivBy2PowerM ( n , m ) : NEW_LINE INDENT if ( ( n & ( 1 << m ) - 1 ) ) == 0 : NEW_LINE INDENT return " Yes " NEW_LINE DEDENT return " No " NEW_LINE DEDENT

BLEU: 34.39
Edit Sim: 168


Src: 
int findSum ( int [ ] arr , int n , int k ) { int ans = arr [ n - k - 1 ] - arr [ 0 ] ; for ( int i = 1 ; i <= k ; i ++ ) { ans = Math . min ( arr [ n - 1 - ( k - i ) ] - arr [ i ] , ans ) ; } return ans ; }
Ref: 
def findSum ( arr , n , k ) : NEW_LINE INDENT ans = arr [ n - k - 1 ] - arr [ 0 ] ; NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT ans = min ( arr [ n - 1 - ( k - i ) ] - arr [ i ] , ans ) ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT
Hyp: 
def findSum ( arr , n , k ) : NEW_LINE INDENT ans = arr [ n - k - 1 ] - arr [ 0 ] NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT ans = min ( arr [ n - 1 - ( k - i ) ] - arr [ i ] , ans ) NEW_LINE DEDENT return ans NEW_LINE DEDENT

BLEU: 90.06
Edit Sim: 6


Src: 
int maximumDifferenceSum ( int arr [ ] , int N ) { int dp [ ] [ ] = new int [ N ] [ 2 ] ; for ( int i = 0 ; i < N ; i ++ ) dp [ i ] [ 0 ] = dp [ i ] [ 1 ] = 0 ; for ( int i = 0 ; i < ( N - 1 ) ; i ++ ) { dp [ i + 1 ] [ 0 ] = Math . max ( dp [ i ] [ 0 ] , dp [ i ] [ 1 ] + Math . abs ( 1 - arr [ i ] ) ) ; dp [ i + 1 ] [ 1 ] = Math . max ( dp [ i ] [ 0 ] + Math . abs ( arr [ i + 1 ] - 1 ) , dp [ i ] [ 1 ] + Math . abs ( arr [ i + 1 ] - arr [ i ] ) ) ; } return Math . max ( dp [ N - 1 ] [ 0 ] , dp [ N - 1 ] [ 1 ] ) ; }
Ref: 
def maximumDifferenceSum ( arr , N ) : NEW_LINE INDENT dp = [ [ 0 , 0 ] for i in range ( N ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i ] [ 1 ] = 0 NEW_LINE DEDENT for i in range ( N - 1 ) : NEW_LINE INDENT dp [ i + 1 ] [ 0 ] = max ( dp [ i ] [ 0 ] , dp [ i ] [ 1 ] + abs ( 1 - arr [ i ] ) ) NEW_LINE dp [ i + 1 ] [ 1 ] = max ( dp [ i ] [ 0 ] + abs ( arr [ i + 1 ] - 1 ) , dp [ i ] [ 1 ] + abs ( arr [ i + 1 ] - arr [ i ] ) ) NEW_LINE DEDENT return max ( dp [ N - 1 ] [ 0 ] , dp [ N - 1 ] [ 1 ] ) NEW_LINE DEDENT
Hyp: 
def maximumDifferenceSum ( arr , N ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( N + 2 ) ] for j in range ( N + 2 ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i ] [ 1 ] = 0 NEW_LINE DEDENT for i in range ( N - 1 ) : NEW_LINE INDENT dp [ i + 1 ] [ 0 ] = max ( dp [ i ] [ 0 ] , dp [ i ] [ 1 ] + abs ( 1 - arr [ i ] ) ) NEW_LINE dp [ i + 1 ] [ 1 ] = max ( dp [ i ] [ 0 ] + abs ( arr [ i + 1 ] - 1 ) , dp [ i ] [ 1 ] + abs ( arr [ i + 1 ] - arr [ i ] ) ) NEW_LINE DEDENT return max ( dp [ N - 1 ] [ 0 ] , dp [ N - 1 ] [ 1 ] ) NEW_LINE DEDENT

BLEU: 92.64
Edit Sim: 28


Src: 
void shuffleArray ( int a [ ] , int n ) { for ( int i = 0 , q = 1 , k = n ; i < n ; i ++ , k ++ , q ++ ) for ( int j = k ; j > i + q ; j -- ) { int temp = a [ j - 1 ] ; a [ j - 1 ] = a [ j ] ; a [ j ] = temp ; } }
Ref: 
def shuffleArray ( a , n ) : NEW_LINE INDENT i , q , k = 0 , 1 , n NEW_LINE while ( i < n ) : NEW_LINE INDENT j = k NEW_LINE while ( j > i + q ) : NEW_LINE INDENT a [ j - 1 ] , a [ j ] = a [ j ] , a [ j - 1 ] NEW_LINE j -= 1 NEW_LINE DEDENT i += 1 NEW_LINE k += 1 NEW_LINE q += 1 NEW_LINE DEDENT DEDENT a = [ 1 , 3 , 5 , 7 , 2 , 4 , 6 , 8 ] NEW_LINE n = len ( a ) NEW_LINE shuffleArray ( a , int ( n / 2 ) ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) NEW_LINE DEDENT
Hyp: 
def shuffleArray ( a , n ) : NEW_LINE INDENT for i in range ( 0 , n , 1 ) : NEW_LINE INDENT q = 1 NEW_LINE k = n NEW_LINE while i < n : NEW_LINE INDENT j = k NEW_LINE while ( j > i + q ) : NEW_LINE INDENT temp = a [ j - 1 ] NEW_LINE a [ j - 1 ] = a [ j ] NEW_LINE j = temp NEW_LINE DEDENT DEDENT DEDENT

BLEU: 28.66
Edit Sim: 285


Src: 
int findGreatest ( int [ ] arr , int n ) { int result = - 1 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n - 1 ; j ++ ) for ( int k = j + 1 ; k < n ; k ++ ) if ( arr [ j ] * arr [ k ] == arr [ i ] ) result = Math . max ( result , arr [ i ] ) ; return result ; }
Ref: 
def findGreatest ( arr , n ) : NEW_LINE INDENT result = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n - 1 ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT if ( arr [ j ] * arr [ k ] == arr [ i ] ) : NEW_LINE INDENT result = max ( result , arr [ i ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
Hyp: 
def findGreatest ( arr , n ) : NEW_LINE INDENT result = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n - 1 ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT if ( arr [ j ] * arr [ k ] == arr [ i ] ) : NEW_LINE INDENT result = max ( result , arr [ i ] ) NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT

BLEU: 98.9
Edit Sim: 7


Src: 
int dealnnoy ( int n , int m ) { if ( m == 0 n == 0 ) return 1 ; return dealnnoy ( m - 1 , n ) + dealnnoy ( m - 1 , n - 1 ) + dealnnoy ( m , n - 1 ) ; }
Ref: 
def dealnnoy ( n , m ) : NEW_LINE INDENT if ( m == 0 or n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return dealnnoy ( m - 1 , n ) + dealnnoy ( m - 1 , n - 1 ) + dealnnoy ( m , n - 1 ) NEW_LINE DEDENT
Hyp: 
def dealnnoy ( n , m ) : NEW_LINE INDENT if ( m == 0 or n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return dealnnoy ( m - 1 , n ) + dealnnoy ( m - 1 , n - 1 ) + dealnnoy ( m , n - 1 ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
long countStr ( int N ) { long dp [ ] [ ] = new long [ N + 1 ] [ 3 ] ; dp [ 1 ] [ 0 ] = 1 ; dp [ 1 ] [ 1 ] = 1 ; dp [ 1 ] [ 2 ] = 0 ; for ( int i = 2 ; i <= N ; i ++ ) { dp [ i ] [ 0 ] = ( dp [ i - 1 ] [ 0 ] + dp [ i - 1 ] [ 1 ] + dp [ i - 1 ] [ 2 ] ) % MOD ; dp [ i ] [ 1 ] = dp [ i - 1 ] [ 0 ] % MOD ; dp [ i ] [ 2 ] = dp [ i - 1 ] [ 1 ] % MOD ; } long ans = ( dp [ N ] [ 0 ] + dp [ N ] [ 1 ] + dp [ N ] [ 2 ] ) % MOD ; return ans ; }
Ref: 
def countStr ( N ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( 3 ) ] for i in range ( N + 1 ) ] NEW_LINE dp [ 1 ] [ 0 ] = 1 NEW_LINE dp [ 1 ] [ 1 ] = 1 NEW_LINE dp [ 1 ] [ 2 ] = 0 NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = ( dp [ i - 1 ] [ 0 ] + dp [ i - 1 ] [ 1 ] + dp [ i - 1 ] [ 2 ] ) % MOD NEW_LINE dp [ i ] [ 1 ] = dp [ i - 1 ] [ 0 ] % MOD NEW_LINE dp [ i ] [ 2 ] = dp [ i - 1 ] [ 1 ] % MOD NEW_LINE DEDENT ans = ( dp [ N ] [ 0 ] + dp [ N ] [ 1 ] + dp [ N ] [ 2 ] ) % MOD NEW_LINE return ans NEW_LINE DEDENT
Hyp: 
def countStr ( N ) : NEW_LINE INDENT dp = [ [ 0 ] * ( N + 1 ) for i in range ( 3 ) ] NEW_LINE dp [ 1 ] [ 0 ] = 1 NEW_LINE dp [ 1 ] [ 1 ] = 1 NEW_LINE dp [ 1 ] [ 2 ] = 0 NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = ( dp [ i - 1 ] [ 0 ] + dp [ i - 1 ] [ 1 ] + dp [ i - 1 ] [ 2 ] ) % MOD NEW_LINE dp [ i ] [ 1 ] = ( dp [ i - 1 ] [ 0 ] % MOD ) NEW_LINE dp [ i ] [ 2 ] = dp [ i - 1 ] [ 1 ] % MOD NEW_LINE DEDENT ans = ( dp [ N ] [ 0 ] + dp [ N ] [ 1 ] + dp [ N ] [ 2 ] ) % MOD NEW_LINE return ans NEW_LINE DEDENT

BLEU: 94.23
Edit Sim: 24


Src: 
void checksum ( int n ) { if ( n % 5 == 0 ) System . out . println ( ( n / 5 - 2 ) + " ▁ " + ( n / 5 - 1 ) + " ▁ " + ( n / 5 ) + " ▁ " + ( n / 5 + 1 ) + " ▁ " + ( n / 5 + 2 ) ) ; else System . out . println ( " - 1" ) ; }
Ref: 
def checksum ( n ) : NEW_LINE INDENT n = int ( n ) NEW_LINE if n % 5 == 0 : NEW_LINE INDENT print ( int ( n / 5 - 2 ) , " ▁ " , int ( n / 5 - 1 ) , " ▁ " , int ( n / 5 ) , " ▁ " , int ( n / 5 + 1 ) , " ▁ " , int ( n / 5 + 2 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT DEDENT
Hyp: 
def checksum ( n ) : NEW_LINE INDENT n = int ( n ) NEW_LINE if n % 5 == 0 : NEW_LINE INDENT print ( ( n // 5 - 2 ) , " ▁ " , ( n // 5 - 1 ) , " ▁ " , ( n // 5 ) , " ▁ " , ( n // 5 + 1 ) , " ▁ " , ( n // 5 + 2 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT DEDENT

BLEU: 75.3
Edit Sim: 25


Src: 
int solve ( int n , int m ) { int ans = n * ( m / 2 ) ; if ( m % 2 == 1 ) { ans += ( n + 1 ) / 2 ; } return ans ; }
Ref: 
def solve ( N , M ) : NEW_LINE INDENT ans = int ( ( N ) * int ( M / 2 ) ) NEW_LINE if ( M % 2 == 1 ) : NEW_LINE INDENT ans += int ( ( N + 1 ) / 2 ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
Hyp: 
def solve ( n , m ) : NEW_LINE INDENT ans = n * ( m / 2 ) ; NEW_LINE if ( m % 2 == 1 ) : NEW_LINE INDENT ans += ( n + 1 ) // 2 ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT

BLEU: 36.2
Edit Sim: 35


Src: 
int countAnomalies ( int arr [ ] , int n , int k ) { int cnt = 0 ; int i , sum = 0 ; for ( i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; for ( i = 0 ; i < n ; i ++ ) if ( Math . abs ( arr [ i ] - ( sum - arr [ i ] ) ) > k ) cnt ++ ; return cnt ; }
Ref: 
def countAnomalies ( arr , n , k ) : NEW_LINE INDENT cnt = 0 NEW_LINE i , Sum = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT Sum += arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( abs ( arr [ i ] - ( Sum - arr [ i ] ) ) > k ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT
Hyp: 
def countAnomalies ( arr , n , k ) : NEW_LINE INDENT cnt = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if abs ( arr [ i ] - ( sum - arr [ i ] ) ) > k : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT

BLEU: 79.51
Edit Sim: 15


Src: 
void decimalToBinary ( int n ) { if ( n == 0 ) { System . out . print ( "0" ) ; return ; } decimalToBinary ( n / 2 ) ; System . out . print ( n % 2 ) ; }
Ref: 
def decimalToBinary ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT print ( "0" , end = " " ) ; NEW_LINE return ; NEW_LINE DEDENT decimalToBinary ( n // 2 ) ; NEW_LINE print ( n % 2 , end = " " ) ; NEW_LINE DEDENT
Hyp: 
def decimalToBinary ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT print ( "0" ) NEW_LINE return NEW_LINE DEDENT decimalToBinary ( int ( n / 2 ) ) NEW_LINE print ( int ( n % 2 ) ) NEW_LINE DEDENT

BLEU: 51.73
Edit Sim: 36


Src: 
void main ( String [ ] args ) { String str = " geeksforgeeks " ; System . out . println ( removeDuplicatesFromString ( str ) ) ; } }
Ref: 
def removeDuplicatesFromString ( str2 ) : NEW_LINE INDENT counter = 0 ; NEW_LINE i = 0 ; NEW_LINE size = len ( str2 ) ; NEW_LINE str1 = list ( str2 ) ; NEW_LINE x = 0 ; NEW_LINE length = 0 ; NEW_LINE while ( i < size ) : NEW_LINE INDENT x = ord ( str1 [ i ] ) - 97 ; NEW_LINE if ( ( counter & ( 1 << x ) ) == 0 ) : NEW_LINE INDENT str1 [ length ] = chr ( 97 + x ) ; NEW_LINE counter = counter | ( 1 << x ) ; NEW_LINE length += 1 ; NEW_LINE DEDENT i += 1 ; NEW_LINE DEDENT str2 = ' ' . join ( str1 ) ; NEW_LINE return str2 [ 0 : length ] ; NEW_LINE DEDENT
Hyp: 
def removeDuplicatesFromString ( string ) : NEW_LINE INDENT table = [ 0 for i in range ( 256 ) ] NEW_LINE endIndex = 0 NEW_LINE string = list ( string ) NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT if ( table [ ord ( string [ i ] ) ] == 0 ) : NEW_LINE INDENT table [ ord ( string [ i ] ) ] = - 1 NEW_LINE string [ endIndex ] = string [ i ] NEW_LINE endIndex += 1 NEW_LINE DEDENT DEDENT ans = " " NEW_LINE for i in range ( endIndex ) : NEW_LINE ans += string [ i ] NEW_LINE return ans NEW_LINE DEDENT

BLEU: 14.97
Edit Sim: 277


Src: 
void digit_product_Sum ( int N ) { int a [ ] = new int [ N + 1 ] ; int product = 1 ; a [ 0 ] = 1 ; for ( int i = 1 ; i <= N ; i ++ ) { product = a [ i - 1 ] / 10 ; if ( product == 0 ) product = 1 ; else product = a [ i - 1 ] % 10 ; int val = a [ i - 1 ] / 10 ; if ( val == 0 ) val = a [ i - 1 ] ; a [ i ] = a [ i - 1 ] + ( val * product ) ; } for ( int i = 0 ; i < N ; i ++ ) System . out . print ( a [ i ] + " ▁ " ) ; }
Ref: 
def digit_product_Sum ( N ) : NEW_LINE INDENT a = [ 0 ] * ( N + 1 ) ; NEW_LINE product = 1 ; NEW_LINE a [ 0 ] = 1 ; NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT product = int ( a [ i - 1 ] / 10 ) ; NEW_LINE if ( product == 0 ) : NEW_LINE INDENT product = 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT product = a [ i - 1 ] % 10 ; NEW_LINE DEDENT val = int ( a [ i - 1 ] / 10 ) ; NEW_LINE if ( val == 0 ) : NEW_LINE INDENT val = a [ i - 1 ] ; NEW_LINE DEDENT a [ i ] = a [ i - 1 ] + ( val * product ) ; NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT
Hyp: 
def digit_product_Sum ( N ) : NEW_LINE INDENT a = [ 0 ] * ( N + 1 ) NEW_LINE product = 1 NEW_LINE a [ 0 ] = 1 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT product = a [ i - 1 ] // 10 NEW_LINE if ( product == 0 ) : NEW_LINE INDENT product = 1 NEW_LINE DEDENT else : NEW_LINE INDENT product = a [ i - 1 ] % 10 NEW_LINE DEDENT DEDENT val = a [ i - 1 ] // 10 NEW_LINE if ( val == 0 ) : NEW_LINE INDENT val = a [ i - 1 ] NEW_LINE DEDENT a [ i ] = a [ i - 1 ] + ( val * product ) NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT

BLEU: 77.68
Edit Sim: 42


Src: 
int findM ( int N ) { int M = 0 ; int MSB = ( int ) Math . log ( N ) ; for ( int i = 0 ; i < MSB ; i ++ ) { if ( ( N & ( 1 << i ) ) == 0 ) M += ( 1 << i ) ; } return M ; }
Ref: 
def findM ( N ) : NEW_LINE INDENT M = 0 ; NEW_LINE MSB = int ( math . log ( N ) ) ; NEW_LINE for i in range ( MSB ) : NEW_LINE INDENT if ( ( N & ( 1 << i ) ) == 0 ) : NEW_LINE INDENT M += ( 1 << i ) ; NEW_LINE DEDENT DEDENT return M ; NEW_LINE DEDENT
Hyp: 
def findM ( N ) : NEW_LINE INDENT M = 0 NEW_LINE MSB = int ( math . log2 ( N ) ) ; NEW_LINE for i in range ( MSB ) : NEW_LINE INDENT if ( ( N & ( 1 << i ) ) == 0 ) : NEW_LINE INDENT M += ( 1 << i ) NEW_LINE DEDENT DEDENT return M NEW_LINE DEDENT

BLEU: 85.38
Edit Sim: 7


Src: 
void printNGE ( int arr [ ] , int n ) { int next , i , j ; for ( i = 0 ; i < n ; i ++ ) { next = - 1 ; for ( j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] < arr [ j ] ) { next = arr [ j ] ; break ; } } System . out . println ( arr [ i ] + " ▁ - - ▁ " + next ) ; } }
Ref: 
def printNGE ( arr ) : NEW_LINE INDENT for i in range ( 0 , len ( arr ) , 1 ) : NEW_LINE INDENT next = - 1 NEW_LINE for j in range ( i + 1 , len ( arr ) , 1 ) : NEW_LINE INDENT if arr [ i ] < arr [ j ] : NEW_LINE INDENT next = arr [ j ] NEW_LINE break NEW_LINE DEDENT DEDENT print ( str ( arr [ i ] ) + " ▁ - - ▁ " + str ( next ) ) NEW_LINE DEDENT DEDENT
Hyp: 
def printNGE ( arr , n ) : NEW_LINE INDENT next = - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT next = arr [ i ] NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] < arr [ j ] ) : NEW_LINE INDENT next = arr [ j ] NEW_LINE break NEW_LINE DEDENT DEDENT print ( arr [ i ] , " ▁ - - " , next ) NEW_LINE DEDENT DEDENT

BLEU: 63.97
Edit Sim: 81


Src: 
int evenDecimalValue ( String str , int n ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { int decimalValue = 0 ; int powerOf2 = 1 ; for ( int k = i ; k <= j ; k ++ ) { decimalValue += ( ( str . charAt ( k ) - '0' ) * powerOf2 ) ; powerOf2 *= 2 ; } if ( decimalValue % 2 == 0 ) result ++ ; } } return result ; }
Ref: 
def evenDecimalValue ( str , n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT decimalValue = 0 ; NEW_LINE powerOf2 = 1 ; NEW_LINE for k in range ( i , j + 1 ) : NEW_LINE INDENT decimalValue += ( ( int ( str [ k ] ) - 0 ) * powerOf2 ) NEW_LINE powerOf2 *= 2 NEW_LINE DEDENT if ( decimalValue % 2 == 0 ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
Hyp: 
def evenDecimalValue ( str , n ) : NEW_LINE INDENT result = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT decimalValue = 0 ; NEW_LINE powerOf2 = 1 ; NEW_LINE for k in range ( i , j + 1 ) : NEW_LINE INDENT decimalValue += ( int ) ( str [ k ] ) * powerOf2 ) ; NEW_LINE powerOf2 *= 2 ; NEW_LINE DEDENT if ( decimalValue % 2 == 0 ) : NEW_LINE INDENT result += 1 ; NEW_LINE DEDENT DEDENT DEDENT return result ; NEW_LINE DEDENT

BLEU: 83.26
Edit Sim: 24


Src: 
boolean checkArray ( int n , int k , int arr [ ] ) { int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] & 1 ) != 0 ) cnt += 1 ; } if ( cnt >= k && cnt % 2 == k % 2 ) return true ; else return false ; }
Ref: 
def checkArray ( n , k , arr ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] & 1 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT if ( cnt >= k and cnt % 2 == k % 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
Hyp: 
def checkArray ( n , k , arr ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] & 1 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT if ( cnt >= k and cnt % 2 == k % 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
void idstrt ( double a1 , double b1 , double c1 , double a2 , double b2 , double c2 ) { if ( ( a1 / a2 == b1 / b2 ) && ( a1 / a2 == c1 / c2 ) && ( b1 / b2 == c1 / c2 ) ) System . out . println ( " The ▁ given ▁ straight " + " ▁ lines ▁ are ▁ identical " ) ; else System . out . println ( " The ▁ given ▁ straight " + " ▁ lines ▁ are ▁ not ▁ identical " ) ; }
Ref: 
def idstrt ( a1 , b1 , c1 , a2 , b2 , c2 ) : NEW_LINE INDENT if ( ( a1 // a2 == b1 // b2 ) and ( a1 // a2 == c1 // c2 ) and ( b1 // b2 == c1 // c2 ) ) : NEW_LINE INDENT print ( " The ▁ given ▁ straight ▁ lines " , " are ▁ identical " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " The ▁ given ▁ straight ▁ lines " , " are ▁ not ▁ identical " ) ; NEW_LINE DEDENT DEDENT
Hyp: 
def idstrt ( a1 , b1 , c1 , a2 , b2 , c2 ) : NEW_LINE INDENT if ( ( a1 / a2 == b1 / b2 ) and ( a1 / a2 == c1 / c2 ) and ( b1 / b2 == c1 / c2 ) ) : NEW_LINE INDENT print ( " The ▁ given ▁ straight " , " ▁ lines ▁ are ▁ identical " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " The ▁ given ▁ straight " , " ▁ lines ▁ are ▁ not ▁ identical " ) ; NEW_LINE DEDENT DEDENT

BLEU: 74.17
Edit Sim: 28


Src: 
int compute_average ( int a , int b ) { return ( a + b ) / 2 ; }
Ref: 
def compute_average ( a , b ) : NEW_LINE INDENT return floor ( ( a + b ) / 2 ) NEW_LINE DEDENT
Hyp: 
def compute_average ( a , b ) : NEW_LINE INDENT return ( a + b ) / 2 NEW_LINE DEDENT

BLEU: 72.85
Edit Sim: 10


Src: 
int cntSubXor ( int arr [ ] , int N ) { int prefixXor = 0 ; int [ ] Even = new int [ M ] ; int [ ] Odd = new int [ M ] ; int cntSub = 0 ; Odd [ 0 ] = 1 ; for ( int i = 0 ; i < N ; i ++ ) { prefixXor ^= arr [ i ] ; if ( i % 2 == 1 ) { cntSub += Odd [ prefixXor ] ; Odd [ prefixXor ] ++ ; } else { cntSub += Even [ prefixXor ] ; Even [ prefixXor ] ++ ; } } return cntSub ; }
Ref: 
def cntSubXor ( arr , N ) : NEW_LINE INDENT prefixXor = 0 ; NEW_LINE Even = [ 0 ] * M ; NEW_LINE Odd = [ 0 ] * M ; NEW_LINE cntSub = 0 ; NEW_LINE Odd [ 0 ] = 1 ; NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT prefixXor ^= arr [ i ] ; NEW_LINE if ( i % 2 == 1 ) : NEW_LINE INDENT cntSub += Odd [ prefixXor ] ; NEW_LINE Odd [ prefixXor ] += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT cntSub += Even [ prefixXor ] ; NEW_LINE Even [ prefixXor ] += 1 ; NEW_LINE DEDENT DEDENT return cntSub ; NEW_LINE DEDENT
Hyp: 
def cntSubXor ( arr , N ) : NEW_LINE INDENT prefixXor = 0 NEW_LINE Even = [ 0 ] * M NEW_LINE Odd = [ 0 ] * M NEW_LINE cntSub = 0 NEW_LINE Even [ 0 ] = 1 NEW_LINE for i in range ( N ) : NEW_LINE INDENT prefixXor ^= arr [ i ] NEW_LINE if ( i % 2 == 1 ) : NEW_LINE INDENT cntSub += Odd [ prefixXor ] NEW_LINE Odd [ prefixXor ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cntSub += Even [ prefixXor ] NEW_LINE Even [ prefixXor ] += 1 NEW_LINE DEDENT DEDENT return cntSub NEW_LINE DEDENT

BLEU: 71.58
Edit Sim: 30


Src: 
void maxSide ( int a [ ] , int n ) { int sideLength = 0 ; Arrays . sort ( a ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( a [ i ] > sideLength ) { sideLength ++ ; } else { break ; } } System . out . println ( sideLength ) ; }
Ref: 
def maxSide ( a , n ) : NEW_LINE INDENT sideLength = 0 NEW_LINE a . sort NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( a [ i ] > sideLength ) : NEW_LINE INDENT sideLength += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( sideLength ) NEW_LINE DEDENT
Hyp: 
def maxSide ( a , n ) : NEW_LINE INDENT sideLength = 0 NEW_LINE a . sort ( ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( a [ i ] > sideLength ) : NEW_LINE INDENT sideLength += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( sideLength ) NEW_LINE DEDENT

BLEU: 94.85
Edit Sim: 4


Src: 
void findPairs ( int arr [ ] , int n ) { int cntEven = 0 , cntOdd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) cntEven ++ ; else cntOdd ++ ; } int evenPairs = 0 ; evenPairs += ( ( cntEven * ( cntEven - 1 ) ) / 2 ) ; evenPairs += ( ( cntOdd * ( cntOdd - 1 ) ) / 2 ) ; int oddPairs = 0 ; oddPairs += ( cntEven * cntOdd ) ; System . out . println ( " Odd ▁ pairs ▁ = ▁ " + oddPairs ) ; System . out . println ( " Even ▁ pairs ▁ = ▁ " + evenPairs ) ; }
Ref: 
def findPairs ( arr , n ) : NEW_LINE INDENT cntEven = 0 ; cntOdd = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT cntEven += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT cntOdd += 1 ; NEW_LINE DEDENT DEDENT evenPairs = 0 ; NEW_LINE evenPairs += ( ( cntEven * ( cntEven - 1 ) ) // 2 ) ; NEW_LINE evenPairs += ( ( cntOdd * ( cntOdd - 1 ) ) // 2 ) ; NEW_LINE oddPairs = 0 ; NEW_LINE oddPairs += ( cntEven * cntOdd ) ; NEW_LINE print ( " Odd ▁ pairs ▁ = ▁ " , oddPairs ) ; NEW_LINE print ( " Even ▁ pairs ▁ = ▁ " , evenPairs ) ; NEW_LINE DEDENT
Hyp: 
def findPairs ( arr , n ) : NEW_LINE INDENT cntEven = 0 ; cntOdd = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT cntEven += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT cntOdd += 1 ; NEW_LINE DEDENT DEDENT evenPairs = 0 ; NEW_LINE evenPairs += ( ( cntEven * ( cntEven - 1 ) ) // 2 ) ; NEW_LINE evenPairs += ( ( cntOdd * ( cntOdd - 1 ) ) // 2 ) ; NEW_LINE oddPairs = 0 ; NEW_LINE oddPairs += ( cntEven * cntOdd ) ; NEW_LINE print ( " Odd ▁ pairs ▁ = " , oddPairs ) ; NEW_LINE print ( " Even ▁ pairs ▁ = " , evenPairs ) ; NEW_LINE DEDENT

BLEU: 96.49
Edit Sim: 4


Src: 
int countWays ( int n ) { int [ ] dp = new int [ n + 1 ] ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; dp [ 2 ] = 1 ; for ( int i = 3 ; i <= n ; i ++ ) { dp [ i ] = dp [ i - 1 ] + dp [ i - 3 ] + 1 ; } return dp [ n ] ; }
Ref: 
def countWays ( n ) : NEW_LINE INDENT dp = [ 0 for i in range ( n + 1 ) ] NEW_LINE dp [ 0 ] = 0 NEW_LINE dp [ 1 ] = 1 NEW_LINE dp [ 2 ] = 1 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] + dp [ i - 3 ] + 1 NEW_LINE DEDENT return dp [ n ] NEW_LINE DEDENT
Hyp: 
def countWays ( n ) : NEW_LINE INDENT dp = [ ] NEW_LINE dp . append ( 0 ) NEW_LINE dp . append ( 1 ) NEW_LINE dp . append ( 1 ) NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT dp . append ( dp [ i - 1 ] + dp [ i - 3 ] + 1 ) NEW_LINE DEDENT return ( dp [ n ] ) NEW_LINE DEDENT

BLEU: 53.88
Edit Sim: 71


Src: 
int printTriplets ( int arr [ ] , int n , int sum ) { for ( int i = 0 ; i < n - 2 ; i ++ ) { for ( int j = i + 1 ; j < n - 1 ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) if ( arr [ i ] + arr [ j ] + arr [ k ] < sum ) System . out . println ( arr [ i ] + " , ▁ " + arr [ j ] + " , ▁ " + arr [ k ] ) ; } } return 0 ; }
Ref: 
def printTriplets ( arr , n , sum ) : NEW_LINE INDENT for i in range ( 0 , n - 2 , 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n - 1 , 1 ) : NEW_LINE INDENT for k in range ( j + 1 , n , 1 ) : NEW_LINE INDENT if ( arr [ i ] + arr [ j ] + arr [ k ] < sum ) : NEW_LINE INDENT print ( arr [ i ] , " , " , arr [ j ] , " , " , arr [ k ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT
Hyp: 
def printTriplets ( arr , n , sum ) : NEW_LINE INDENT for i in range ( n - 2 ) : NEW_LINE INDENT for j in range ( i + 1 , n - 1 ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] + arr [ j ] + arr [ k ] < sum ) : NEW_LINE INDENT print ( arr [ i ] , " , ▁ " , arr [ j ] , k ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return 0 NEW_LINE DEDENT

BLEU: 77.88
Edit Sim: 52


Src: 
void print ( int p0 ) { int p1 , i = 0 , x , flag , k ; while ( true ) { flag = 1 ; x = ( int ) ( Math . pow ( 2 , i ) ) ; p1 = x * p0 - ( x - 1 ) ; for ( k = 2 ; k < p1 ; k ++ ) { if ( p1 % k == 0 ) { flag = 0 ; break ; } } if ( flag == 0 ) break ; System . out . print ( p1 + " ▁ " ) ; i ++ ; } }
Ref: 
def print_t ( p0 ) : NEW_LINE INDENT i = 0 ; NEW_LINE while ( True ) : NEW_LINE INDENT flag = 1 ; NEW_LINE x = pow ( 2 , i ) ; NEW_LINE p1 = x * p0 - ( x - 1 ) ; NEW_LINE for k in range ( 2 , p1 ) : NEW_LINE INDENT if ( p1 % k == 0 ) : NEW_LINE INDENT flag = 0 ; NEW_LINE break ; NEW_LINE DEDENT DEDENT if ( flag == 0 ) : NEW_LINE INDENT break ; NEW_LINE DEDENT print ( p1 , end = " ▁ " ) ; NEW_LINE i += 1 ; NEW_LINE DEDENT DEDENT
Hyp: 
def print ( p0 ) : NEW_LINE INDENT p1 = 0 NEW_LINE i = 0 NEW_LINE flag = 1 NEW_LINE x = pow ( 2 , i ) NEW_LINE while ( True ) : NEW_LINE INDENT flag = 1 NEW_LINE x = pow ( 2 , i ) NEW_LINE p1 = x * p0 - ( x - 1 ) NEW_LINE for k in range ( 2 , p1 ) : NEW_LINE INDENT if ( p1 % k == 0 ) : NEW_LINE INDENT flag = 0 NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT print ( p1 , end = " ▁ " ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT

BLEU: 71.48
Edit Sim: 78


Src: 
int evenNumSubstring ( String str ) { int len = str . length ( ) ; int count = 0 ; for ( int i = 0 ; i < len ; i ++ ) { int temp = str . charAt ( i ) - '0' ; if ( temp % 2 == 0 ) count += ( i + 1 ) ; } return count ; }
Ref: 
def evenNumSubstring ( str ) : NEW_LINE INDENT length = len ( str ) NEW_LINE count = 0 NEW_LINE for i in range ( 0 , length , 1 ) : NEW_LINE INDENT temp = ord ( str [ i ] ) - ord ( '0' ) NEW_LINE if ( temp % 2 == 0 ) : NEW_LINE INDENT count += ( i + 1 ) NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
Hyp: 
def evenNumSubstring ( str ) : NEW_LINE INDENT ln = len ( str ) NEW_LINE count = 0 NEW_LINE for i in range ( 0 , ln ) : NEW_LINE INDENT temp = ord ( str [ i ] ) - ord ( '0' ) NEW_LINE if ( temp % 2 == 0 ) : NEW_LINE INDENT count += ( i + 1 ) NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT

BLEU: 90.22
Edit Sim: 12


Src: 
int findLargestString ( String s , int i , int r ) { if ( i == s . length ( ) ) { if ( r == 0 ) return 0 ; else return INT_MIN ; } if ( v [ i ] [ r ] == 1 ) return dp [ i ] [ r ] ; v [ i ] [ r ] = 1 ; dp [ i ] [ r ] = Math . max ( 1 + findLargestString ( s , i + 1 , ( r * 2 + ( s . charAt ( i ) - '0' ) ) % 3 ) , findLargestString ( s , i + 1 , r ) ) ; return dp [ i ] [ r ] ; }
Ref: 
def findLargestString ( s , i , r ) : NEW_LINE INDENT if ( i == len ( s ) ) : NEW_LINE INDENT if ( r == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT else : NEW_LINE INDENT return INT_MIN ; NEW_LINE DEDENT DEDENT if ( v [ i ] [ r ] ) : NEW_LINE INDENT return dp [ i ] [ r ] ; NEW_LINE DEDENT v [ i ] [ r ] = 1 ; NEW_LINE dp [ i ] [ r ] = max ( 1 + findLargestString ( s , i + 1 , ( r * 2 + ( ord ( s [ i ] ) - ord ( '0' ) ) ) % 3 ) , findLargestString ( s , i + 1 , r ) ) ; NEW_LINE return dp [ i ] [ r ] ; NEW_LINE DEDENT
Hyp: 
def findLargestString ( s , i , r ) : NEW_LINE INDENT if ( i == len ( s ) ) : NEW_LINE INDENT if ( r == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT else : NEW_LINE INDENT return INT_MIN ; NEW_LINE DEDENT DEDENT if ( v [ i ] [ r ] ) : NEW_LINE INDENT return dp [ i ] [ r ] ; NEW_LINE DEDENT v [ i ] [ r ] = 1 ; NEW_LINE dp [ i ] [ r ] = max ( ( 1 + findLargestString ( s , i + 1 , ( r * 2 + ( ord ( s [ i ] ) - ord ( '0' ) ) ) % 3 ) , findLargestString ( s , i + 1 , r ) ) ; NEW_LINE return dp [ i ] [ r ] ; NEW_LINE DEDENT

BLEU: 98.84
Edit Sim: 2


Src: 
double surface_area_octahedron ( double side ) { return ( 2 * ( Math . sqrt ( 3 ) ) * ( side * side ) ) ; }
Ref: 
def surface_area_octahedron ( side ) : NEW_LINE INDENT return ( 2 * ( math . sqrt ( 3 ) ) * ( side * side ) ) NEW_LINE DEDENT
Hyp: 
def surface_area_octahedron ( side ) : NEW_LINE INDENT return ( 2 * ( math . sqrt ( 3 ) ) * ( side * side ) ) ; NEW_LINE DEDENT

BLEU: 92.21
Edit Sim: 2


Src: 
void main ( String [ ] args ) { int n = 8 ; int [ ] v = Findpermutation ( n ) ; for ( int i = 1 ; i <= n ; i ++ ) System . out . print ( v [ i ] + " ▁ " ) ; } }
Ref: 
def Findpermutation ( n ) : NEW_LINE INDENT a = [ 0 ] * ( n + 1 ) ; NEW_LINE a [ 1 ] = n ; NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT a [ i ] = i - 1 ; NEW_LINE DEDENT return a ; NEW_LINE DEDENT
Hyp: 
def Findpermutation ( n ) : NEW_LINE INDENT n = 8 NEW_LINE v = Findpermutation ( n ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( v [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT

BLEU: 36.82
Edit Sim: 74


Src: 
void sum_of_elements ( int [ ] arr , int n ) { int sumfirst = 0 , sumsecond = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i < n / 2 ) { sumfirst += arr [ i ] ; } else { sumsecond += arr [ i ] ; } } System . out . println ( " Sum ▁ of ▁ first ▁ half ▁ elements ▁ is ▁ " + sumfirst ) ; System . out . println ( " Sum ▁ of ▁ second ▁ half ▁ elements ▁ is ▁ " + sumsecond ) ; }
Ref: 
def sum_of_elements ( arr , n ) : NEW_LINE INDENT sumfirst = 0 ; NEW_LINE sumsecond = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i < n // 2 ) : NEW_LINE INDENT sumfirst += arr [ i ] ; NEW_LINE DEDENT else : NEW_LINE INDENT sumsecond += arr [ i ] ; NEW_LINE DEDENT DEDENT print ( " Sum ▁ of ▁ first ▁ half ▁ elements ▁ is " , sumfirst , end =   " " ) ; NEW_LINE print ( " Sum ▁ of ▁ second ▁ half ▁ elements ▁ is " , sumsecond , end =   " " ) ; NEW_LINE DEDENT
Hyp: 
def sum_of_elements ( arr , n ) : NEW_LINE INDENT sumfirst = 0 NEW_LINE sumsecond = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( i < n // 2 ) : NEW_LINE INDENT sumfirst += arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT sumsecond += arr [ i ] NEW_LINE DEDENT DEDENT print ( " Sum ▁ of ▁ first ▁ half ▁ elements ▁ is ▁ " , sumfirst ) NEW_LINE print ( " Sum ▁ of ▁ second ▁ half ▁ elements ▁ is ▁ " , sumsecond ) NEW_LINE DEDENT

BLEU: 72.22
Edit Sim: 48


Src: 
int findLastIndex ( String str , Character x ) { int index = - 1 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) if ( str . charAt ( i ) == x ) index = i ; return index ; }
Ref: 
def findLastIndex ( str , x ) : NEW_LINE INDENT index = - 1 NEW_LINE for i in range ( 0 , len ( str ) ) : NEW_LINE INDENT if str [ i ] == x : NEW_LINE INDENT index = i NEW_LINE DEDENT DEDENT return index NEW_LINE DEDENT str = " geeksforgeeks " NEW_LINE x = ' e ' NEW_LINE index = findLastIndex ( str , x ) NEW_LINE if index == - 1 : NEW_LINE INDENT print ( " Character ▁ not ▁ found " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' Last ▁ index ▁ is ' , index ) NEW_LINE DEDENT
Hyp: 
def findLastIndex ( str , x ) : NEW_LINE INDENT index = - 1 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] == x ) : NEW_LINE INDENT index = i NEW_LINE DEDENT DEDENT return index NEW_LINE DEDENT

BLEU: 27.11
Edit Sim: 270


Src: 
void printSorted ( int a , int b , int c ) { int get_max = Math . max ( a , Math . max ( b , c ) ) ; int get_min = - Math . max ( - a , Math . max ( - b , - c ) ) ; int get_mid = ( a + b + c ) - ( get_max + get_min ) ; System . out . print ( get_min + " ▁ " + get_mid + " ▁ " + get_max ) ; }
Ref: 
def printSorted ( a , b , c ) : NEW_LINE INDENT get_max = max ( a , max ( b , c ) ) NEW_LINE get_min = - max ( - a , max ( - b , - c ) ) NEW_LINE get_mid = ( a + b + c ) - ( get_max + get_min ) NEW_LINE print ( get_min , " ▁ " , get_mid , " ▁ " , get_max ) NEW_LINE DEDENT
Hyp: 
def printSorted ( a , b , c ) : NEW_LINE INDENT get_max = max ( a , max ( b , c ) ) NEW_LINE get_min = - max ( a , max ( b , - c ) ) NEW_LINE get_mid = ( a + b + c ) - ( get_max + get_min ) NEW_LINE print ( get_min , get_mid , " ▁ " , get_max ) NEW_LINE DEDENT

BLEU: 87.03
Edit Sim: 12


Src: 
int sumOfTheSeries ( int n ) { return ( n * ( n + 1 ) / 2 ) * ( 2 * n + 1 ) / 3 ; }
Ref: 
def sumOfTheSeries ( n ) : NEW_LINE INDENT return int ( ( n * ( n + 1 ) / 2 ) * ( 2 * n + 1 ) / 3 ) NEW_LINE DEDENT
Hyp: 
def sumOfTheSeries ( n ) : NEW_LINE INDENT return ( n * ( n + 1 ) / 2 ) * ( 2 * n + 1 ) / 3 NEW_LINE DEDENT

BLEU: 82.7
Edit Sim: 8


Src: 
void findSum ( int N ) { int sum = ( N ) * ( N + 1 ) / 2 ; int r = ( int ) ( Math . log ( N ) / Math . log ( 2 ) ) + 1 ; int expSum = ( int ) ( Math . pow ( 2 , r ) ) - 1 ; System . out . println ( sum - expSum ) ; }
Ref: 
def findSum ( N ) : NEW_LINE INDENT sum = ( N ) * ( N + 1 ) // 2 NEW_LINE r = log2 ( N ) + 1 NEW_LINE expSum = pow ( 2 , r ) - 1 NEW_LINE print ( int ( sum - expSum ) ) NEW_LINE DEDENT
Hyp: 
def findSum ( N ) : NEW_LINE INDENT sum = ( N ) * ( N + 1 ) / 2 NEW_LINE r = ( int ) ( math . log2 ( N ) ) + 1 NEW_LINE expSum = ( int ) ( math . pow ( 2 , r ) ) - 1 NEW_LINE print ( sum - expSum ) NEW_LINE DEDENT

BLEU: 65.0
Edit Sim: 47


Src: 
void findPairs ( int A , int B ) { for ( int i = 1 ; i <= B ; i ++ ) { int y = A ^ i ; if ( y > 0 && ( i y ) == B ) { System . out . println ( i + " ▁ " + y ) ; } } }
Ref: 
def findPairs ( A , B ) : NEW_LINE INDENT for i in range ( 1 , B + 1 ) : NEW_LINE INDENT y = A ^ i NEW_LINE if ( y > 0 and ( i y ) == B ) : NEW_LINE INDENT print ( i , " ▁ " , y ) NEW_LINE DEDENT DEDENT DEDENT
Hyp: 
def findPairs ( A , B ) : NEW_LINE INDENT for i in range ( 1 , B + 1 ) : NEW_LINE INDENT y = A ^ i NEW_LINE if ( y > 0 and ( i y ) == B ) : NEW_LINE INDENT print ( i , " ▁ " , y ) NEW_LINE DEDENT DEDENT DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
String check ( int [ ] arr , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] & 1 ) != 0 ) count ++ ; } if ( ( count & 1 ) != 0 ) return " Odd " ; else return " Even " ; }
Ref: 
def check ( arr , n ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] & 1 ) : NEW_LINE INDENT count = count + 1 ; NEW_LINE DEDENT DEDENT if ( count & 1 ) : NEW_LINE INDENT return " Odd " ; NEW_LINE DEDENT else : NEW_LINE INDENT return " Even " ; NEW_LINE DEDENT DEDENT
Hyp: 
def check ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] & 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( count & 1 ) : NEW_LINE INDENT return " Odd " NEW_LINE DEDENT else : NEW_LINE INDENT return " Even " NEW_LINE DEDENT DEDENT

BLEU: 80.65
Edit Sim: 17


Src: 
boolean check ( String [ ] v , int len ) { int n = v . length ; char [ ] tempArray ; for ( int i = 0 ; i < n ; i ++ ) { tempArray = v [ i ] . toCharArray ( ) ; Arrays . sort ( tempArray ) ; v [ i ] = new String ( tempArray ) ; } for ( int i = 0 ; i < len - 1 ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( v [ i ] . charAt ( j ) > v [ i + 1 ] . charAt ( j ) ) return false ; return true ; }
Ref: 
def check ( v , l ) : NEW_LINE INDENT n = len ( v ) NEW_LINE for i in v : NEW_LINE INDENT i = ' ' . join ( sorted ( i ) ) NEW_LINE DEDENT for i in range ( l - 1 ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( v [ i ] [ j ] > v [ i + 1 ] [ j ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT v = [ " ebcda " , " ihgfj " , " klmno " , " pqrst " , " yvwxu " ] NEW_LINE if check ( v , l ) : NEW_LINE INDENT print " Yes " NEW_LINE DEDENT else : NEW_LINE INDENT print " No " NEW_LINE DEDENT
Hyp: 
def check ( v , l ) : NEW_LINE INDENT n = len ( v ) NEW_LINE tempArray = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT tempArray . append ( v [ i ] ) NEW_LINE DEDENT v [ i ] = " " . join ( tempArray ) NEW_LINE DEDENT for i in range ( l - 1 ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( v [ i ] [ j ] > v [ i + 1 ] [ j ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT

BLEU: 57.14
Edit Sim: 270


Src: 
int findCnt ( int [ ] arr , int i , int curr , int n , int m ) { if ( i == n ) { if ( curr == 0 ) return 1 ; else return 0 ; } if ( v [ i ] [ curr ] ) return dp [ i ] [ curr ] ; v [ i ] [ curr ] = true ; return dp [ i ] [ curr ] = findCnt ( arr , i + 1 , curr , n , m ) + findCnt ( arr , i + 1 , ( curr + arr [ i ] ) % m , n , m ) ; }
Ref: 
def findCnt ( arr , i , curr , n , m ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT if ( curr == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if ( v [ i ] [ curr ] ) : NEW_LINE INDENT return dp [ i ] [ curr ] NEW_LINE DEDENT v [ i ] [ curr ] = 1 NEW_LINE dp [ i ] [ curr ] = findCnt ( arr , i + 1 , curr , n , m ) + findCnt ( arr , i + 1 , ( curr + arr [ i ] ) % m , n , m ) NEW_LINE return dp [ i ] [ curr ] NEW_LINE DEDENT
Hyp: 
def findCnt ( arr , i , curr , n , m ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT if ( curr == 0 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT DEDENT if ( v [ i ] [ curr ] ) : NEW_LINE INDENT return dp [ i ] [ curr ] ; NEW_LINE DEDENT v [ i ] [ curr ] = 1 ; NEW_LINE return dp [ i ] [ curr ] ; NEW_LINE DEDENT

BLEU: 55.77
Edit Sim: 136


Src: 
int findSum ( int n ) { if ( n % 2 == 0 ) return ( n / 2 ) * ( n + 1 ) ; else return ( ( n + 1 ) / 2 ) * n ; }
Ref: 
def findSum ( n ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT return ( n / 2 ) * ( n + 1 ) NEW_LINE DEDENT else : NEW_LINE return ( ( n + 1 ) / 2 ) * n NEW_LINE DEDENT
Hyp: 
def findSum ( n ) : NEW_LINE INDENT if n % 2 == 0 : NEW_LINE INDENT return ( n / 2 ) * ( n + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( ( n + 1 ) / 2 ) * n NEW_LINE DEDENT DEDENT

BLEU: 86.42
Edit Sim: 18


Src: 
boolean areEqual ( int arr1 [ ] , int arr2 [ ] ) { int n = arr1 . length ; int m = arr2 . length ; if ( n != m ) return false ; Arrays . sort ( arr1 ) ; Arrays . sort ( arr2 ) ; for ( int i = 0 ; i < n ; i ++ ) if ( arr1 [ i ] != arr2 [ i ] ) return false ; return true ; }
Ref: 
def areEqual ( arr1 , arr2 , n , m ) : NEW_LINE INDENT if ( n != m ) : NEW_LINE INDENT return False NEW_LINE DEDENT arr1 . sort ( ) NEW_LINE arr2 . sort ( ) NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( arr1 [ i ] != arr2 [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT arr1 = [ 3 , 5 , 2 , 5 , 2 ] NEW_LINE arr2 = [ 2 , 3 , 5 , 5 , 2 ] NEW_LINE n = len ( arr1 ) NEW_LINE m = len ( arr2 ) NEW_LINE if ( areEqual ( arr1 , arr2 , n , m ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
Hyp: 
def areEqual ( arr1 , arr2 ) : NEW_LINE INDENT n = len ( arr1 ) NEW_LINE m = len ( arr2 ) NEW_LINE if ( n != m ) : NEW_LINE INDENT return False NEW_LINE DEDENT arr1 = sorted ( arr1 ) NEW_LINE arr2 = sorted ( arr2 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr1 [ i ] != arr2 [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT

BLEU: 36.57
Edit Sim: 315


Src: 
void countSubsequences ( int [ ] A ) { int odd = 0 ; int even = 0 ; for ( int el : A ) { if ( el % 2 == 1 ) odd ++ ; else even ++ ; } if ( odd == 0 ) System . out . println ( 0 ) ; else System . out . println ( 1 << ( A . length - 1 ) ) ; }
Ref: 
def countSubsequences ( A ) : NEW_LINE INDENT odd = 0 NEW_LINE even = 0 NEW_LINE for el in A : NEW_LINE INDENT if ( el % 2 == 1 ) : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT else : NEW_LINE INDENT even += 1 NEW_LINE DEDENT DEDENT if ( odd == 0 ) : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 1 << len ( A ) - 1 ) NEW_LINE DEDENT DEDENT
Hyp: 
def countSubsequences ( A ) : NEW_LINE INDENT odd = 0 NEW_LINE even = 0 NEW_LINE for el in A : NEW_LINE INDENT if ( el % 2 == 1 ) : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT else : NEW_LINE INDENT even += 1 NEW_LINE DEDENT DEDENT if ( odd == 0 ) : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 1 << ( A . length - 1 ) ) NEW_LINE DEDENT DEDENT

BLEU: 92.3
Edit Sim: 12


Src: 
int findX ( int A , int B ) { int j = 0 , x = 0 ; while ( A != 0 B != 0 ) { if ( ( A % 2 == 1 ) && ( B % 2 == 1 ) ) { x += ( 1 << j ) ; } A >>= 1 ; B >>= 1 ; j += 1 ; } return x ; }
Ref: 
def findX ( A , B ) : NEW_LINE INDENT j = 0 NEW_LINE x = 0 NEW_LINE while ( A or B ) : NEW_LINE INDENT if ( ( A & 1 ) and ( B & 1 ) ) : NEW_LINE INDENT x += ( 1 << j ) NEW_LINE DEDENT A >>= 1 NEW_LINE B >>= 1 NEW_LINE j += 1 NEW_LINE DEDENT return x NEW_LINE DEDENT
Hyp: 
def findX ( A , B ) : NEW_LINE INDENT j = 0 NEW_LINE x = 0 NEW_LINE while ( A != 0 or B != 0 ) : NEW_LINE INDENT if ( A % 2 == 1 ) and ( B % 2 == 1 ) ) : NEW_LINE INDENT x += ( 1 << j ) NEW_LINE DEDENT A >>= 1 NEW_LINE B >>= 1 NEW_LINE j += 1 NEW_LINE DEDENT return x NEW_LINE DEDENT

BLEU: 78.41
Edit Sim: 22


Src: 
boolean isPowerofTwo ( int n ) { if ( n == 0 ) return false ; if ( ( n & ( ~ ( n - 1 ) ) ) == n ) return true ; return false ; }
Ref: 
def isPowerofTwo ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( ( n & ( ~ ( n - 1 ) ) ) == n ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT if ( isPowerofTwo ( 30 ) ) : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT if ( isPowerofTwo ( 128 ) ) : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT
Hyp: 
def isPowerofTwo ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( ( n & ( ~ ( n - 1 ) ) ) == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT

BLEU: 24.88
Edit Sim: 273


Src: 
String get_last_two_digit ( int N ) { if ( N % 4 == 0 ) return "01" ; else if ( N % 4 == 1 ) return "07" ; else if ( N % 4 == 2 ) return "49" ; return "43" ; }
Ref: 
def get_last_two_digit ( N ) : NEW_LINE INDENT if ( N % 4 == 0 ) : NEW_LINE INDENT return "01" ; NEW_LINE DEDENT elif ( N % 4 == 1 ) : NEW_LINE INDENT return "07" ; NEW_LINE DEDENT elif ( N % 4 == 2 ) : NEW_LINE INDENT return "49" ; NEW_LINE DEDENT return "43" ; NEW_LINE DEDENT
Hyp: 
def get_last_two_digit ( N ) : NEW_LINE INDENT if ( N % 4 == 0 ) : NEW_LINE INDENT return "01" NEW_LINE DEDENT elif ( N % 4 == 1 ) : NEW_LINE INDENT return "07" NEW_LINE DEDENT elif ( N % 4 == 2 ) : NEW_LINE INDENT return "49" NEW_LINE DEDENT return "43" NEW_LINE DEDENT

BLEU: 83.3
Edit Sim: 8


Src: 
int getPairsCount ( int [ ] arr , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = arr [ i ] - ( i % arr [ i ] ) ; j < n ; j += arr [ i ] ) { if ( i < j && ( arr [ i ] * arr [ j ] ) == Math . abs ( i - j ) ) { count ++ ; } } } return count ; }
Ref: 
def getPairsCount ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT s = arr [ i ] - ( i % arr [ i ] ) NEW_LINE for j in range ( s , n ) : NEW_LINE INDENT if ( i < j and ( arr [ i ] * arr [ j ] ) == abs ( i - j ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
Hyp: 
def getPairsCount ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( arr [ i ] - ( i % arr [ i ] ) , n , arr [ i ] ) : NEW_LINE INDENT if ( i < j and ( arr [ i ] * arr [ j ] ) == abs ( i - j ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT

BLEU: 85.65
Edit Sim: 43


Src: 
boolean isPossible ( int arr [ ] , int p , int n , int m ) { int sum = 0 ; for ( int i = 0 ; i < p ; i ++ ) sum += arr [ i ] ; if ( sum == ( n * m ) ) return true ; return false ; }
Ref: 
def isPossible ( arr , p , n , m ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( p ) : NEW_LINE INDENT sum += arr [ i ] ; NEW_LINE DEDENT if ( sum == ( n * m ) ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT
Hyp: 
def isPossible ( arr , p , n , m ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( p ) : NEW_LINE INDENT sum += arr [ i ] ; NEW_LINE DEDENT if ( sum == ( n * m ) ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int countOddSquares ( int n , int m ) { return ( int ) Math . pow ( m , 0.5 ) - ( int ) Math . pow ( n - 1 , 0.5 ) ; }
Ref: 
def countOddSquares ( n , m ) : NEW_LINE INDENT return ( int ( pow ( m , 0.5 ) ) - int ( pow ( n - 1 , 0.5 ) ) ) NEW_LINE DEDENT
Hyp: 
def countOddSquares ( n , m ) : NEW_LINE INDENT return pow ( m , 0.5 ) - pow ( n - 1 , 0.5 ) ; NEW_LINE DEDENT

BLEU: 61.46
Edit Sim: 19


Src: 
void findNumbers ( int n ) { int i = 1 ; while ( i <= n ) { System . out . print ( ( 3 * i * ( i - 1 ) + 1 ) + " ▁ " ) ; i ++ ; } }
Ref: 
def findNumbers ( n ) : NEW_LINE INDENT i = 1 NEW_LINE while ( i <= n ) : NEW_LINE INDENT print ( ( 3 * i * ( i - 1 ) + 1 ) , end = " ▁ " ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT
Hyp: 
def findNumbers ( n ) : NEW_LINE INDENT i = 1 NEW_LINE while ( i <= n ) : NEW_LINE INDENT print ( ( 3 * i * ( i - 1 ) + 1 ) , end = " ▁ " ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int nthTerm ( int n ) { int An = ( ( int ) Math . pow ( 1 , n ) + ( int ) Math . pow ( 2 , n ) ) * ( int ) Math . pow ( 3 , n ) ; return An ; }
Ref: 
def nthterm ( n ) : NEW_LINE INDENT An = ( 1 ** n + 2 ** n ) * ( 3 ** n ) NEW_LINE return An ; NEW_LINE DEDENT
Hyp: 
def nthTerm ( n ) : NEW_LINE INDENT An = ( pow ( 1 , n ) + pow ( 2 , n ) ) * pow ( 3 , n ) ; NEW_LINE return An ; NEW_LINE DEDENT

BLEU: 41.3
Edit Sim: 29


Src: 
int findMax ( int num ) { byte size_of_int = 4 ; int num_copy = num ; int j = size_of_int * 8 - 1 ; int i = 0 ; while ( i < j ) { int m = ( num_copy >> i ) & 1 ; int n = ( num_copy >> j ) & 1 ; if ( m > n ) { int x = ( 1 << i 1 << j ) ; num = num ^ x ; } i ++ ; j -- ; } return num ; }
Ref: 
def findMax ( num ) : NEW_LINE INDENT num_copy = num NEW_LINE j = 4 * 8 - 1 ; NEW_LINE i = 0 NEW_LINE while ( i < j ) : NEW_LINE INDENT m = ( num_copy >> i ) & 1 NEW_LINE n = ( num_copy >> j ) & 1 NEW_LINE if ( m > n ) : NEW_LINE INDENT x = ( 1 << i 1 << j ) NEW_LINE num = num ^ x NEW_LINE DEDENT i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT return num NEW_LINE DEDENT
Hyp: 
def findMax ( num ) : NEW_LINE INDENT size_of_int = 4 NEW_LINE num_copy = num NEW_LINE j = size_of_int * 8 - 1 NEW_LINE i = 0 NEW_LINE while ( i < j ) : NEW_LINE INDENT m = ( num_copy >> i ) & 1 NEW_LINE n = ( num_copy >> j ) & 1 NEW_LINE if ( m > n ) : NEW_LINE INDENT x = ( 1 << i 1 << j ) NEW_LINE num = num ^ x NEW_LINE DEDENT i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT return num NEW_LINE DEDENT

BLEU: 90.54
Edit Sim: 38


Src: 
int squaresum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += ( i * i ) ; return sum ; }
Ref: 
def squaresum ( n ) : NEW_LINE INDENT sm = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sm = sm + ( i * i ) NEW_LINE DEDENT return sm NEW_LINE DEDENT
Hyp: 
def squaresum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += ( i * i ) NEW_LINE DEDENT return int ( sum ) NEW_LINE DEDENT

BLEU: 72.23
Edit Sim: 16


Src: 
boolean checkDuplicatesWithinK ( int arr [ ] , int k ) { HashSet < Integer > set = new HashSet < > ( ) ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( set . contains ( arr [ i ] ) ) return true ; set . add ( arr [ i ] ) ; if ( i >= k ) set . remove ( arr [ i - k ] ) ; } return false ; }
Ref: 
def checkDuplicatesWithinK ( arr , n , k ) : NEW_LINE INDENT myset = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] in myset : NEW_LINE INDENT return True NEW_LINE DEDENT myset . append ( arr [ i ] ) NEW_LINE if ( i >= k ) : NEW_LINE INDENT myset . remove ( arr [ i - k ] ) NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
Hyp: 
def checkDuplicatesWithinK ( arr , k ) : NEW_LINE INDENT string = set ( ) ; NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT if arr [ i ] in string : NEW_LINE INDENT return True ; NEW_LINE DEDENT string . add ( arr [ i ] ) ; NEW_LINE if i >= k : NEW_LINE INDENT string . remove ( arr [ i - k ] ) ; NEW_LINE DEDENT DEDENT return False ; NEW_LINE DEDENT arr = [ 1 , 3 , 5 , 2 ] ; NEW_LINE k = len ( arr ) ; NEW_LINE if ( checkDuplicatesWithinK ( arr , k ) ) : NEW_LINE INDENT print ( " YES " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) ; NEW_LINE DEDENT

BLEU: 34.97
Edit Sim: 276


Src: 
boolean isSubSequence ( String str1 , String str2 , int m , int n ) { if ( m == 0 ) return true ; if ( n == 0 ) return false ; if ( str1 . charAt ( m - 1 ) == str2 . charAt ( n - 1 ) ) return isSubSequence ( str1 , str2 , m - 1 , n - 1 ) ; return isSubSequence ( str1 , str2 , m , n - 1 ) ; }
Ref: 
def isSubSequence ( string1 , string2 , m , n ) : NEW_LINE INDENT if m == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT if n == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT if string1 [ m - 1 ] == string2 [ n - 1 ] : NEW_LINE INDENT return isSubSequence ( string1 , string2 , m - 1 , n - 1 ) NEW_LINE DEDENT return isSubSequence ( string1 , string2 , m , n - 1 ) NEW_LINE DEDENT string1 = " gksrek " NEW_LINE string2 = " geeksforgeeks " NEW_LINE if isSubSequence ( string1 , string2 , len ( string1 ) , len ( string2 ) ) : NEW_LINE INDENT print " Yes " NEW_LINE DEDENT else : NEW_LINE INDENT print " No " NEW_LINE DEDENT
Hyp: 
def isSubSequence ( str1 , str2 , m , n ) : NEW_LINE INDENT if ( not m ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( not n ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( str1 [ m - 1 ] == str2 [ n - 1 ] ) : NEW_LINE INDENT return isSubSequence ( str1 , str2 , m - 1 , n - 1 ) NEW_LINE DEDENT return isSubSequence ( str1 , str2 , m - 1 , n - 1 ) NEW_LINE DEDENT

BLEU: 39.01
Edit Sim: 281


Src: 
boolean check ( int N , int D ) { int temp = ( N * ( N + 1 ) ) / 2 + D ; return ( temp % 2 == 0 ) ; }
Ref: 
def check ( N , D ) : NEW_LINE INDENT temp = N * ( N + 1 ) // 2 + D NEW_LINE return ( bool ( temp % 2 == 0 ) ) NEW_LINE DEDENT N = 5 NEW_LINE M = 7 NEW_LINE if check ( N , M ) : NEW_LINE INDENT print ( " yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " no " ) NEW_LINE DEDENT
Hyp: 
def check ( N , D ) : NEW_LINE INDENT temp = ( N * ( N + 1 ) ) // 2 + D NEW_LINE return ( temp % 2 == 0 ) NEW_LINE DEDENT N = 12 NEW_LINE if check ( N , D ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT

BLEU: 71.79
Edit Sim: 32


Src: 
int binaryToDecimal ( int n ) { int num = n ; int dec_value = 0 ; int base = 1 ; int temp = num ; while ( temp > 0 ) { int last_digit = temp % 10 ; temp = temp / 10 ; dec_value += last_digit * base ; base = base * 2 ; } return dec_value ; }
Ref: 
def binaryToDecimal ( n ) : NEW_LINE INDENT num = n ; NEW_LINE dec_value = 0 ; NEW_LINE base = 1 ; NEW_LINE temp = num ; NEW_LINE while ( temp ) : NEW_LINE INDENT last_digit = temp % 10 ; NEW_LINE temp = int ( temp / 10 ) ; NEW_LINE dec_value += last_digit * base ; NEW_LINE base = base * 2 ; NEW_LINE DEDENT return dec_value ; NEW_LINE DEDENT
Hyp: 
def binaryToDecimal ( n ) : NEW_LINE INDENT num = n NEW_LINE dec_value = 0 NEW_LINE base = 1 NEW_LINE temp = num NEW_LINE while ( temp > 0 ) : NEW_LINE INDENT last_digit = temp % 10 NEW_LINE temp = temp // 10 NEW_LINE dec_value += last_digit * base NEW_LINE base = base * 2 NEW_LINE DEDENT return dec_value NEW_LINE DEDENT

BLEU: 55.79
Edit Sim: 31


Src: 
int calcSafe ( int pos ) { int j = pos % 10 ; int i = pos / 10 ; int dis_11 = Math . min ( Math . abs ( 1 - i ) , Math . abs ( 1 - j ) ) ; int dis_18 = Math . min ( Math . abs ( 1 - i ) , Math . abs ( 8 - j ) ) ; int dis_81 = Math . min ( Math . abs ( 8 - i ) , Math . abs ( 1 - j ) ) ; int dis_88 = Math . min ( Math . abs ( 8 - i ) , Math . abs ( 8 - j ) ) ; int sum = dis_11 + dis_18 + dis_81 + dis_88 + 1 ; return ( 64 - sum ) ; }
Ref: 
def calcSafe ( pos ) : NEW_LINE INDENT j = pos % 10 NEW_LINE i = pos / 10 NEW_LINE dis_11 = min ( abs ( 1 - i ) , abs ( 1 - j ) ) NEW_LINE dis_18 = min ( abs ( 1 - i ) , abs ( 8 - j ) ) NEW_LINE dis_81 = min ( abs ( 8 - i ) , abs ( 1 - j ) ) NEW_LINE dis_88 = min ( abs ( 8 - i ) , abs ( 8 - j ) ) NEW_LINE sum = ( dis_11 + dis_18 + dis_81 + dis_88 + 1 ) NEW_LINE return ( 64 - sum ) NEW_LINE DEDENT
Hyp: 
def calcSafe ( pos ) : NEW_LINE INDENT j = pos % 10 NEW_LINE i = pos // 10 NEW_LINE dis_11 = min ( abs ( 1 - i ) , abs ( 1 - j ) ) NEW_LINE dis_18 = min ( abs ( 1 - i ) , abs ( 8 - j ) ) NEW_LINE dis_81 = min ( abs ( 8 - i ) , abs ( 1 - j ) ) NEW_LINE dis_88 = min ( abs ( 8 - i ) , abs ( 8 - j ) ) NEW_LINE sum = dis_11 + dis_18 + dis_81 + dis_88 + 1 ) NEW_LINE return ( 64 - sum ) NEW_LINE DEDENT

BLEU: 95.71
Edit Sim: 3


Src: 
boolean isPerfectSquare ( int n ) { for ( int sum = 0 , i = 1 ; sum < n ; i += 2 ) { sum += i ; if ( sum == n ) return true ; } return false ; }
Ref: 
def isPerfectSquare ( n ) : NEW_LINE INDENT i = 1 NEW_LINE the_sum = 0 NEW_LINE while the_sum < n : NEW_LINE INDENT the_sum += i NEW_LINE if the_sum == n : NEW_LINE INDENT return True NEW_LINE DEDENT i += 2 NEW_LINE DEDENT return False NEW_LINE DEDENT
Hyp: 
def isPerfectSquare ( n ) : NEW_LINE INDENT for sum in range ( 0 , n , 2 ) : NEW_LINE INDENT sum += i NEW_LINE if ( sum == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT n = 25 NEW_LINE if isPerfectSquare ( n ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT

BLEU: 28.57
Edit Sim: 164


Src: 
boolean is_distinct ( long n , long k ) { HashSet < Long > s = new HashSet < Long > ( ) ; for ( int i = 1 ; i <= k ; i ++ ) { long tmp = n % i ; if ( s . contains ( tmp ) ) { return false ; } s . add ( tmp ) ; } return true ; }
Ref: 
def is_distinct ( n , k ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT tmp = n % i NEW_LINE if ( tmp in s ) : NEW_LINE INDENT return False NEW_LINE DEDENT s . add ( tmp ) NEW_LINE DEDENT return True NEW_LINE DEDENT
Hyp: 
def is_distinct ( n , k ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT tmp = n % i NEW_LINE if ( tmp in s ) : NEW_LINE INDENT return False NEW_LINE DEDENT s . add ( tmp ) NEW_LINE DEDENT return True NEW_LINE DEDENT n = 1 NEW_LINE k = k + 1 NEW_LINE if ( is_distinct ( n , k ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT

BLEU: 59.02
Edit Sim: 171


Src: 
int pairORSum ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) ans += arr [ i ] | arr [ j ] ; return ans ; }
Ref: 
def pairORSum ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( ( i + 1 ) , n ) : NEW_LINE INDENT ans = ans + arr [ i ] | arr [ j ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
Hyp: 
def pairORSum ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT ans += arr [ i ] | arr [ j ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT

BLEU: 77.73
Edit Sim: 32


Src: 
int LISusingLCS ( Vector < Integer > seq ) { int n = seq . size ( ) ; int L [ ] [ ] = new int [ n + 1 ] [ n + 1 ] ; Vector < Integer > sortedseq = new Vector < Integer > ( seq ) ; Collections . sort ( sortedseq ) ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) L [ i ] [ j ] = 0 ; else if ( seq . get ( i - 1 ) == sortedseq . get ( j - 1 ) ) L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 1 ; else L [ i ] [ j ] = Math . max ( L [ i - 1 ] [ j ] , L [ i ] [ j - 1 ] ) ; } } return L [ n ] [ n ] ; }
Ref: 
def LISusingLCS ( seq ) : NEW_LINE INDENT n = len ( seq ) NEW_LINE L = [ [ 0 for i in range ( n + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE sortedseq = sorted ( seq ) NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if ( i == 0 or j == 0 ) : NEW_LINE INDENT L [ i ] [ j ] = 0 NEW_LINE DEDENT elif ( seq [ i - 1 ] == sortedseq [ j - 1 ] ) : NEW_LINE INDENT L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] = max ( L [ i - 1 ] [ j ] , L [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return L [ n ] [ n ] NEW_LINE DEDENT
Hyp: 
def LISusingLCS ( seq ) : NEW_LINE INDENT n = len ( seq ) NEW_LINE L = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE sortedseq = sorted ( seq ) NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if i == 0 or j == 0 : NEW_LINE INDENT L [ i ] [ j ] = 0 NEW_LINE DEDENT elif ( seq [ i - 1 ] == sortedseq [ j - 1 ] ) : NEW_LINE INDENT L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] = max ( L [ i - 1 ] [ j ] , L [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return L [ n ] [ n ] NEW_LINE DEDENT

BLEU: 95.93
Edit Sim: 5


Src: 
long getSum ( int n , int d ) { long sum = 0 ; while ( d <= n ) { sum += d ; d += 10 ; } return sum ; }
Ref: 
def getSum ( n , d ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( d <= n ) : NEW_LINE INDENT sum += d NEW_LINE d += 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT
Hyp: 
def getSum ( n , d ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( d <= n ) : NEW_LINE INDENT sum += d NEW_LINE d += 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
void compute ( int a [ ] , int N , int K ) { Map < Long , Long > eqVal = new HashMap < Long , Long > ( ) ; long maxX = 0 ; for ( int i = 0 ; i < N ; i ++ ) { long val = a [ i ] % K ; val = ( val == 0 ? 0 : K - val ) ; if ( val == 0 ) continue ; if ( eqVal . containsKey ( val ) ) { long numVal = eqVal . get ( val ) ; maxX = Math . max ( maxX , val + ( K * numVal ) ) ; eqVal . put ( val , eqVal . getOrDefault ( val , 0l ) + 1l ) ; } else { eqVal . put ( val , 1l ) ; maxX = Math . max ( maxX , val ) ; } } System . out . println ( maxX == 0 ? 0 : maxX + 1 ) ; }
Ref: 
def compute ( a , N , K ) : NEW_LINE INDENT eqVal = defaultdict ( int ) NEW_LINE maxX = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT val = a [ i ] % K NEW_LINE if ( val != 0 ) : NEW_LINE INDENT val = K - val NEW_LINE DEDENT if ( val == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( val in eqVal ) : NEW_LINE INDENT numVal = eqVal [ val ] NEW_LINE maxX = max ( maxX , val + ( K * numVal ) ) NEW_LINE eqVal [ val ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT eqVal [ val ] += 1 NEW_LINE maxX = max ( maxX , val ) NEW_LINE DEDENT DEDENT if maxX == 0 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( maxX + 1 ) NEW_LINE DEDENT DEDENT
Hyp: 
def compute ( a , N , K ) : NEW_LINE INDENT eqVal = dict ( ) NEW_LINE maxX = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT val = a [ i ] % K NEW_LINE val = ( val == 0 ? 0 : K - val ) NEW_LINE if ( val == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( eqVal [ val ] ) : NEW_LINE INDENT numVal = eqVal [ val ] NEW_LINE maxX = max ( maxX , val + ( K * numVal ) ) NEW_LINE eqVal [ val ] += 1l NEW_LINE DEDENT else : NEW_LINE INDENT eqVal [ val ] = 1l NEW_LINE maxX = max ( maxX , val ) NEW_LINE DEDENT DEDENT print ( maxX == 0 ? 0 : maxX + 1 ) NEW_LINE DEDENT

BLEU: 70.44
Edit Sim: 144


Src: 
double Perimeter ( double s , int n ) { double perimeter = 1 ; perimeter = n * s ; return perimeter ; }
Ref: 
def Perimeter ( s , n ) : NEW_LINE INDENT perimeter = 1 NEW_LINE perimeter = n * s NEW_LINE return perimeter NEW_LINE DEDENT
Hyp: 
def Perimeter ( s , n ) : NEW_LINE INDENT perimeter = 1 NEW_LINE perimeter = n * s NEW_LINE return perimeter NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
float Area ( float a , float b ) { if ( a < 0 && b < 0 ) return - 1 ; float h = ( float ) Math . sqrt ( ( ( Math . pow ( a , 2 ) + Math . pow ( b , 2 ) ) / ( Math . pow ( a , 2 ) * Math . pow ( b , 2 ) ) ) ) ; float A = ( float ) ( 0.70477 * Math . pow ( h , 2 ) ) ; return A ; }
Ref: 
def Area ( a , b ) : NEW_LINE INDENT if ( a < 0 and b < 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT h = math . sqrt ( ( ( pow ( a , 2 ) + pow ( b , 2 ) ) / ( pow ( a , 2 ) * pow ( b , 2 ) ) ) ) ; NEW_LINE A = 0.70477 * pow ( h , 2 ) ; NEW_LINE return A ; NEW_LINE DEDENT
Hyp: 
def Area ( a , b ) : NEW_LINE INDENT if ( a < 0 and b < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT h = math . sqrt ( ( ( a ** 2 ) + ( b ** 2 ) ) / ( a ** 2 ) ) ) NEW_LINE A = ( 0.70477 * math . pow ( h , 2 ) ) NEW_LINE return A NEW_LINE DEDENT

BLEU: 58.4
Edit Sim: 54


Src: 
int solve ( Vector < Integer > values , Vector < Integer > salary ) { int ret = 1 ; int amt = 0 ; Collections . sort ( values ) ; Collections . sort ( salary ) ; while ( salary . size ( ) > 0 ) { while ( values . size ( ) > 0 && values . get ( values . size ( ) - 1 ) >= salary . get ( salary . size ( ) - 1 ) ) { amt ++ ; values . remove ( values . size ( ) - 1 ) ; } if ( amt == 0 ) return 0 ; ret *= amt -- ; ret %= MOD ; salary . remove ( salary . size ( ) - 1 ) ; } return ret ; }
Ref: 
def solve ( values , salary ) : NEW_LINE INDENT ret = 1 NEW_LINE amt = 0 NEW_LINE values = sorted ( values ) NEW_LINE salary = sorted ( salary ) NEW_LINE while ( len ( salary ) > 0 ) : NEW_LINE INDENT while ( ( len ( values ) and values [ - 1 ] >= salary [ - 1 ] ) ) : NEW_LINE INDENT amt += 1 NEW_LINE del values [ - 1 ] NEW_LINE DEDENT if ( amt == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ret *= amt NEW_LINE amt -= 1 NEW_LINE ret %= MOD NEW_LINE del salary [ - 1 ] NEW_LINE DEDENT return ret NEW_LINE DEDENT
Hyp: 
def solve ( values , salary ) : NEW_LINE INDENT ret = 1 NEW_LINE amt = 0 NEW_LINE values . sort ( ) NEW_LINE salary . sort ( ) NEW_LINE while ( len ( salary ) > 0 ) : NEW_LINE INDENT while ( len ( values ) > 0 and values [ len ( values ) - 1 ] >= salary [ len ( salary ) - 1 ] ) : NEW_LINE INDENT amt += 1 NEW_LINE values . remove ( len ( values ) - 1 ) NEW_LINE DEDENT if ( amt == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ret *= amt -= 1 NEW_LINE ret %= MOD NEW_LINE salary . remove ( len ( salary ) - 1 ) NEW_LINE DEDENT return ret NEW_LINE DEDENT

BLEU: 63.8
Edit Sim: 114


Src: 
void Bubble_Sort ( int arr [ ] , int n ) { for ( int i = 1 ; i < n ; ++ i ) { for ( int j = 0 ; j <= ( n - i - 1 ) ; ++ j ) { if ( arr [ j ] > arr [ j + 1 ] ) { int temp = arr [ j ] ; arr [ j ] = arr [ j + 1 ] ; arr [ j + 1 ] = temp ; } } } }
Ref: 
def Bubble_Sort ( arr , n ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( 0 , n - i ) : NEW_LINE INDENT if ( arr [ j ] > arr [ j + 1 ] ) : NEW_LINE INDENT arr [ j ] , arr [ j + 1 ] = arr [ j + 1 ] , arr [ j ] NEW_LINE DEDENT DEDENT DEDENT return arr NEW_LINE DEDENT n = 5 NEW_LINE arr = [ 2 , 0 , 1 , 4 , 3 ] NEW_LINE arr = Bubble_Sort ( arr , n ) NEW_LINE print ( " The ▁ Sorted ▁ Array ▁ by ▁ using ▁ Bubble ▁ Sort ▁ is ▁ : ▁ " , end = ' ' ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT
Hyp: 
def Bubble_Sort ( arr , n ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( n - i - 1 ) : NEW_LINE INDENT if ( arr [ j ] > arr [ j + 1 ] ) : NEW_LINE INDENT temp = arr [ j ] NEW_LINE arr [ j ] = arr [ j + 1 ] NEW_LINE arr [ j + 1 ] = temp NEW_LINE DEDENT DEDENT DEDENT DEDENT

BLEU: 32.12
Edit Sim: 299


Src: 
void maxSubsequenceLen ( String s , int K ) { int N = s . length ( ) ; int start = 0 , end = 0 ; char S [ ] = s . toCharArray ( ) ; Arrays . sort ( S ) ; int ans = Integer . MIN_VALUE , sum = 0 ; for ( end = 0 ; end < N ; end ++ ) { sum = sum + ( S [ end ] - ' a ' ) ; while ( sum + K < ( S [ end ] - ' a ' ) * ( end - start + 1 ) ) { sum = sum - ( S [ start ] - ' a ' ) ; start ++ ; } ans = Math . max ( ans , end - start + 1 ) ; } System . out . println ( ans ) ; }
Ref: 
def maxSubsequenceLen ( S , K ) : NEW_LINE INDENT N = len ( S ) NEW_LINE start , end = 0 , 0 NEW_LINE S = sorted ( S ) NEW_LINE ans , sum = - 10 ** 9 , 0 NEW_LINE for end in range ( N ) : NEW_LINE INDENT sum = sum + ( ord ( S [ end ] ) - ord ( ' a ' ) ) NEW_LINE while ( sum + K < ( ord ( S [ end ] ) - ord ( ' a ' ) ) * ( end - start + 1 ) ) : NEW_LINE INDENT sum = sum - ( ord ( S [ start ] ) - ord ( ' a ' ) ) NEW_LINE start += 1 NEW_LINE DEDENT ans = max ( ans , end - start + 1 ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
Hyp: 
def maxSubsequenceLen ( s , K ) : NEW_LINE INDENT N = len ( s ) NEW_LINE start = 0 NEW_LINE end = 0 NEW_LINE S = sorted ( S ) NEW_LINE ans = sys . maxsize NEW_LINE sum = 0 NEW_LINE for end in range ( N ) : NEW_LINE INDENT sum = sum + ( S [ end ] - ' a ' ) NEW_LINE while ( sum + K < ( S [ start ] - ' a ' ) * ( end - start + 1 ) ) : NEW_LINE INDENT sum = sum - ( S [ start ] - ' a ' ) NEW_LINE start += 1 NEW_LINE DEDENT ans = max ( ans , end - start + 1 ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT

BLEU: 66.11
Edit Sim: 92


Src: 
int countSubSeq ( String str , int len ) { int ans = 0 ; int mul = 1 ; for ( int i = 0 ; i < len ; i ++ ) { if ( str . charAt ( i ) == '0' ) ans += mul ; mul *= 2 ; } return ans ; }
Ref: 
def countSubSeq ( strr , lenn ) : NEW_LINE INDENT ans = 0 NEW_LINE mul = 1 NEW_LINE for i in range ( lenn ) : NEW_LINE INDENT if ( strr [ i ] == '0' ) : NEW_LINE INDENT ans += mul NEW_LINE DEDENT mul *= 2 NEW_LINE DEDENT return ans NEW_LINE DEDENT
Hyp: 
def countSubSeq ( s , l ) : NEW_LINE INDENT ans = 0 ; NEW_LINE mul = 1 ; NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT ans += mul ; NEW_LINE DEDENT mul *= 2 ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT

BLEU: 60.86
Edit Sim: 22


Src: 
int findNumber ( int n , int m ) { int num = ( m - 1 ) * 9 + n ; return num ; }
Ref: 
def findNumber ( n , m ) : NEW_LINE INDENT num = ( m - 1 ) * 9 + n ; NEW_LINE return num ; NEW_LINE DEDENT
Hyp: 
def findNumber ( n , m ) : NEW_LINE INDENT num = ( m - 1 ) * 9 + n NEW_LINE return num NEW_LINE DEDENT

BLEU: 81.96
Edit Sim: 4


Src: 
int evenSum ( int n ) { int curr = 2 , sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { sum += curr ; curr += 2 ; } return sum ; }
Ref: 
def evensum ( n ) : NEW_LINE INDENT curr = 2 NEW_LINE sum = 0 NEW_LINE i = 1 NEW_LINE while i <= n : NEW_LINE INDENT sum += curr NEW_LINE curr += 2 NEW_LINE i = i + 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT
Hyp: 
def evenSum ( n ) : NEW_LINE INDENT curr = 2 NEW_LINE sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += curr NEW_LINE curr += 2 NEW_LINE DEDENT return sum NEW_LINE DEDENT

BLEU: 62.66
Edit Sim: 42


Src: 
int countPair ( int a , int b ) { String s = String . valueOf ( b ) ; int i ; for ( i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) != '9' ) break ; } int result ; if ( i == s . length ( ) ) result = a * s . length ( ) ; else result = a * ( s . length ( ) - 1 ) ; return result ; }
Ref: 
def countPair ( a , b ) : NEW_LINE INDENT s = str ( b ) NEW_LINE i = 0 NEW_LINE while i < ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] != '9' ) : NEW_LINE INDENT break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT result = 0 NEW_LINE if ( i == len ( s ) ) : NEW_LINE INDENT result = a * len ( s ) NEW_LINE DEDENT else : NEW_LINE INDENT result = a * ( len ( s ) - 1 ) NEW_LINE DEDENT return result NEW_LINE DEDENT
Hyp: 
def countPair ( a , b ) : NEW_LINE INDENT s = str ( b ) NEW_LINE i = 0 NEW_LINE while ( i < len ( s ) ) : NEW_LINE INDENT if ( s [ i ] != '9' ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT result = a * len ( s ) NEW_LINE DEDENT return result NEW_LINE DEDENT

BLEU: 50.15
Edit Sim: 149


Src: 
void IsEvenPath ( int Source [ ] , int Destination [ ] ) { int x_dif = Math . abs ( Source [ 0 ] - Destination [ 0 ] ) ; int y_dif = Math . abs ( Source [ 1 ] - Destination [ 1 ] ) ; int minsteps = x_dif + y_dif ; if ( minsteps % 2 == 0 ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; }
Ref: 
def IsEvenPath ( Source , Destination ) : NEW_LINE INDENT x_dif = abs ( Source [ 0 ] - Destination [ 0 ] ) NEW_LINE y_dif = abs ( Source [ 1 ] - Destination [ 1 ] ) NEW_LINE minsteps = x_dif + y_dif NEW_LINE if ( minsteps % 2 == 0 ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
Hyp: 
def IsEvenPath ( Source , Destination ) : NEW_LINE INDENT x_dif = abs ( Source [ 0 ] - Destination [ 0 ] ) ; NEW_LINE y_dif = abs ( Source [ 1 ] - Destination [ 1 ] ) ; NEW_LINE minsteps = x_dif + y_dif ; NEW_LINE if ( minsteps % 2 == 0 ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT DEDENT

BLEU: 84.46
Edit Sim: 10


Src: 
int maxAND ( int L , int R ) { if ( L == R ) return L ; else if ( ( R - L ) == 1 ) return ( R & L ) ; else { if ( ( ( R - 1 ) & R ) > ( ( R - 2 ) & ( R - 1 ) ) ) return ( ( R - 1 ) & R ) ; else return ( ( R - 2 ) & ( R - 1 ) ) ; } }
Ref: 
def maxAND ( L , R ) : NEW_LINE INDENT if ( L == R ) : NEW_LINE INDENT return L ; NEW_LINE DEDENT elif ( ( R - L ) == 1 ) : NEW_LINE INDENT return ( R & L ) ; NEW_LINE DEDENT else : NEW_LINE INDENT if ( ( ( R - 1 ) & R ) > ( ( R - 2 ) & ( R - 1 ) ) ) : NEW_LINE INDENT return ( ( R - 1 ) & R ) ; NEW_LINE DEDENT else : NEW_LINE INDENT return ( ( R - 2 ) & ( R - 1 ) ) ; NEW_LINE DEDENT DEDENT DEDENT
Hyp: 
def maxAND ( L , R ) : NEW_LINE INDENT if ( L == R ) : NEW_LINE INDENT return L NEW_LINE DEDENT elif ( ( R - L ) == 1 ) : NEW_LINE INDENT return ( R & L ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( ( R - 1 ) & R ) > ( ( R - 2 ) & ( R - 1 ) ) ) : NEW_LINE INDENT return ( ( R - 1 ) & R ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( ( R - 2 ) & ( R - 1 ) ) NEW_LINE DEDENT DEDENT

BLEU: 89.05
Edit Sim: 17


Src: 
int cntSubarr ( int arr [ ] , int N ) { int res = 0 ; int prefixXor = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { prefixXor = arr [ i ] ; for ( int j = i + 1 ; j < N ; j ++ ) { prefixXor ^= arr [ j ] ; if ( prefixXor == 0 && ( j - i + 1 ) % 2 == 0 ) { res ++ ; } } } return res ; }
Ref: 
def cntSubarr ( arr , N ) : NEW_LINE INDENT res = 0 NEW_LINE prefixXor = 0 NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT prefixXor = arr [ i ] NEW_LINE for j in range ( i + 1 , N ) : NEW_LINE INDENT prefixXor ^= arr [ j ] NEW_LINE if ( prefixXor == 0 and ( j - i + 1 ) % 2 == 0 ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT
Hyp: 
def cntSubarr ( arr , N ) : NEW_LINE INDENT res = 0 NEW_LINE prefixXor = 0 NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT prefixXor = arr [ i ] NEW_LINE for j in range ( i + 1 , N ) : NEW_LINE INDENT prefixXor ^= arr [ j ] NEW_LINE if ( prefixXor == 0 and ( j - i + 1 ) % 2 == 0 ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
void catalan ( int n ) { int cat_ = 1 ; System . out . print ( cat_ + " ▁ " ) ; for ( int i = 1 ; i < n ; i ++ ) { cat_ *= ( 4 * i - 2 ) ; cat_ /= ( i + 1 ) ; System . out . print ( cat_ + " ▁ " ) ; } }
Ref: 
def catalan ( n ) : NEW_LINE INDENT cat_ = 1 NEW_LINE print ( cat_ , " ▁ " , end = ' ' ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT cat_ *= ( 4 * i - 2 ) ; NEW_LINE cat_ //= ( i + 1 ) ; NEW_LINE print ( cat_ , " ▁ " , end = ' ' ) NEW_LINE DEDENT DEDENT
Hyp: 
def catalan ( n ) : NEW_LINE INDENT cat_ = 1 NEW_LINE print ( cat_ , end = " ▁ " ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT cat_ *= ( 4 * i - 2 ) NEW_LINE cat_ //= ( i + 1 ) NEW_LINE print ( cat_ , end = " ▁ " ) NEW_LINE DEDENT DEDENT

BLEU: 73.27
Edit Sim: 28


Src: 
int find_index ( int [ ] arr , int n , int K ) { for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == K ) return i ; else if ( arr [ i ] > K ) return i ; return n ; }
Ref: 
def find_index ( arr , n , K ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if arr [ i ] == K : NEW_LINE INDENT return i NEW_LINE DEDENT elif arr [ i ] > K : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return n NEW_LINE DEDENT
Hyp: 
def find_index ( arr , n , B ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT if arr [ i ] == K : NEW_LINE INDENT return i NEW_LINE DEDENT elif arr [ i ] > K : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return n NEW_LINE DEDENT

BLEU: 89.2
Edit Sim: 5


Src: 
double getSlope ( double m ) { return m ; }
Ref: 
def getSlope ( m ) : NEW_LINE INDENT return m ; NEW_LINE DEDENT
Hyp: 
def getSlope ( m ) : NEW_LINE INDENT return m * m ; NEW_LINE DEDENT

BLEU: 80.14
Edit Sim: 4


Src: 
void printMaxActivities ( int s [ ] , int f [ ] , int n ) { int i , j ; System . out . print ( " Following ▁ activities ▁ are ▁ selected ▁ : ▁ n " ) ; i = 0 ; System . out . print ( i + " ▁ " ) ; for ( j = 1 ; j < n ; j ++ ) { if ( s [ j ] >= f [ i ] ) { System . out . print ( j + " ▁ " ) ; i = j ; } } }
Ref: 
def printMaxActivities ( s , f ) : NEW_LINE INDENT n = len ( f ) NEW_LINE print " The ▁ following ▁ activities ▁ are ▁ selected " NEW_LINE i = 0 NEW_LINE print i , NEW_LINE for j in xrange ( n ) : NEW_LINE INDENT if s [ j ] >= f [ i ] : NEW_LINE INDENT print j , NEW_LINE i = j NEW_LINE DEDENT DEDENT DEDENT
Hyp: 
def printMaxActivities ( s , f , n ) : NEW_LINE INDENT print ( " Following ▁ activities ▁ are ▁ selected ▁ : ▁ n " ) NEW_LINE i = 0 NEW_LINE print ( i , end = " ▁ " ) NEW_LINE for j in range ( 1 , n ) : NEW_LINE INDENT if ( s [ j ] >= f [ i ] ) : NEW_LINE INDENT print ( j , end = " ▁ " ) NEW_LINE i = j NEW_LINE DEDENT DEDENT DEDENT

BLEU: 47.52
Edit Sim: 85


Src: 
int heptagonalNumber ( int n ) { return ( ( 5 * n * n ) - ( 3 * n ) ) / 2 ; }
Ref: 
def heptagonalNumber ( n ) : NEW_LINE INDENT return ( ( 5 * n * n ) - ( 3 * n ) ) // 2 NEW_LINE DEDENT
Hyp: 
def heptagonalNumber ( n ) : NEW_LINE INDENT return ( ( 5 * n * n ) - ( 3 * n ) ) // 2 NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int maxValue ( int n ) { return n ; }
Ref: 
def maxValue ( n ) : NEW_LINE INDENT return n ; NEW_LINE DEDENT
Hyp: 
def maxValue ( n ) : NEW_LINE INDENT return n + 1 NEW_LINE DEDENT

BLEU: 74.87
Edit Sim: 3


Src: 
float rainDayProbability ( int a [ ] , int n ) { float count = 0 , m ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 1 ) count ++ ; } m = count / n ; return m ; }
Ref: 
def rainDayProbability ( a , n ) : NEW_LINE INDENT count = a . count ( 1 ) NEW_LINE m = count / n NEW_LINE return m NEW_LINE DEDENT
Hyp: 
def rainDayProbability ( a , n ) : NEW_LINE INDENT count = 0 NEW_LINE m = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT m = count // n NEW_LINE return m NEW_LINE DEDENT

BLEU: 34.22
Edit Sim: 118


Src: 
int countDigits ( int n ) { double ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) ans += Math . log10 ( i ) ; ans = ans * n ; return 1 + ( int ) Math . floor ( ans ) ; }
Ref: 
def countDigits ( n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans += math . log10 ( i ) NEW_LINE DEDENT ans = ans * n NEW_LINE return 1 + math . floor ( ans ) NEW_LINE DEDENT
Hyp: 
def countDigits ( n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans += math . log10 ( i ) NEW_LINE DEDENT ans = ans * n NEW_LINE return 1 + math . floor ( ans ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int squareSum ( int n ) { return 2 * n * ( n + 1 ) * ( 2 * n + 1 ) / 3 ; }
Ref: 
def squareSum ( n ) : NEW_LINE INDENT return int ( 2 * n * ( n + 1 ) * ( 2 * n + 1 ) / 3 ) NEW_LINE DEDENT
Hyp: 
def squareSum ( n ) : NEW_LINE INDENT return 2 * n * ( n + 1 ) * ( 2 * n + 1 ) // 3 NEW_LINE DEDENT

BLEU: 76.05
Edit Sim: 9


Src: 
void SubMasks ( int N ) { for ( int S = N ; S > 0 ; S = ( S - 1 ) & N ) { System . out . print ( S + " ▁ " ) ; } }
Ref: 
def SubMasks ( N ) : NEW_LINE INDENT S = N NEW_LINE while S > 0 : NEW_LINE INDENT print ( S , end = ' ▁ ' ) NEW_LINE S = ( S - 1 ) & N NEW_LINE DEDENT DEDENT
Hyp: 
def SubMasks ( N ) : NEW_LINE INDENT for S in range ( N , 1 , - 1 ) : NEW_LINE INDENT print ( S , end = " ▁ " ) NEW_LINE DEDENT DEDENT

BLEU: 44.11
Edit Sim: 52


Src: 
int log_a_to_base_b ( int a , int b ) { return ( int ) ( Math . log ( a ) / Math . log ( b ) ) ; }
Ref: 
def log_a_to_base_b ( a , b ) : NEW_LINE INDENT return log ( a ) // log ( b ) ; NEW_LINE DEDENT
Hyp: 
def log_a_to_base_b ( a , b ) : NEW_LINE INDENT return int ( math . log ( a ) // math . log ( b ) ) ; NEW_LINE DEDENT

BLEU: 61.97
Edit Sim: 22


Src: 
int nonFibonacci ( int n ) { int prevPrev = 1 , prev = 2 , curr = 3 ; while ( n > 0 ) { prevPrev = prev ; prev = curr ; curr = prevPrev + prev ; n = n - ( curr - prev - 1 ) ; } n = n + ( curr - prev - 1 ) ; return prev + n ; }
Ref: 
def nonFibonacci ( n ) : NEW_LINE INDENT prevPrev = 1 NEW_LINE prev = 2 NEW_LINE curr = 3 NEW_LINE while n > 0 : NEW_LINE INDENT prevPrev = prev NEW_LINE prev = curr NEW_LINE curr = prevPrev + prev NEW_LINE n = n - ( curr - prev - 1 ) NEW_LINE DEDENT n = n + ( curr - prev - 1 ) NEW_LINE return prev + n NEW_LINE DEDENT
Hyp: 
def nonFibonacci ( n ) : NEW_LINE INDENT prevPrev = 1 NEW_LINE prev = 2 NEW_LINE curr = 3 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT prevPrev = prev NEW_LINE prev = curr NEW_LINE n = n - ( curr - prev - 1 ) NEW_LINE DEDENT n = n + ( curr - prev - 1 ) NEW_LINE return prev + n NEW_LINE DEDENT

BLEU: 86.07
Edit Sim: 36


Src: 
int arrayDivisionByTwo ( int arr [ ] , int n ) { int cnt = 0 ; int ans = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { cnt = 0 ; while ( arr [ i ] % 2 == 0 ) { arr [ i ] = arr [ i ] / 2 ; cnt ++ ; } ans = Math . min ( ans , cnt ) ; } return ans ; }
Ref: 
def arrayDivisionByTwo ( arr , n ) : NEW_LINE INDENT cnt = 0 NEW_LINE ans = sys . maxsize NEW_LINE for i in range ( n ) : NEW_LINE INDENT cnt = 0 NEW_LINE while ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT arr [ i ] = arr [ i ] // 2 NEW_LINE cnt += 1 NEW_LINE DEDENT ans = min ( ans , cnt ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
Hyp: 
def arrayDivisionByTwo ( arr , n ) : NEW_LINE INDENT cnt = 0 NEW_LINE ans = sys . maxsize NEW_LINE for i in range ( n ) : NEW_LINE INDENT cnt = 0 NEW_LINE while ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT arr [ i ] = arr [ i ] // 2 NEW_LINE cnt += 1 NEW_LINE DEDENT ans = min ( cnt , ans ) NEW_LINE DEDENT return ans NEW_LINE DEDENT

BLEU: 95.14
Edit Sim: 4


Src: 
int get_permutation ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { result += Math . abs ( arr [ i ] - ( i + 1 ) ) ; } return result ; }
Ref: 
def get_permutation ( arr , n ) : NEW_LINE INDENT arr = sorted ( arr ) NEW_LINE result = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT result += abs ( arr [ i ] - ( i + 1 ) ) NEW_LINE DEDENT return result NEW_LINE DEDENT
Hyp: 
def get_permutation ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE result = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT result += abs ( arr [ i ] - ( i + 1 ) ) NEW_LINE DEDENT return result NEW_LINE DEDENT

BLEU: 84.97
Edit Sim: 11


Src: 
int count9s ( String number ) { int count = 0 ; int n = number . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int sum = number . charAt ( i ) - '0' ; if ( number . charAt ( i ) == '9' ) count ++ ; for ( int j = i + 1 ; j < n ; j ++ ) { sum = ( sum + number . charAt ( j ) - '0' ) % 9 ; if ( sum == 0 ) count ++ ; } } return count ; }
Ref: 
def count9s ( number ) : NEW_LINE INDENT n = len ( number ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = ord ( number [ i ] ) - ord ( '0' ) NEW_LINE if ( number [ i ] == '9' ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT sum = ( sum + ord ( number [ j ] ) - ord ( '0' ) ) % 9 NEW_LINE if ( sum == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
Hyp: 
def count9s ( number ) : NEW_LINE INDENT count = 0 NEW_LINE n = len ( number ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = ord ( number [ i ] ) - ord ( '9' ) NEW_LINE if ( number [ i ] == '9' ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT sum = ( sum + number [ j ] ) % 9 NEW_LINE if ( sum == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT

BLEU: 87.05
Edit Sim: 42


Src: 
int findMaxK ( int N ) { int K = N ; for ( int i = N - 1 ; i >= 0 ; i -- ) { K &= i ; if ( K == 0 ) { return i ; } } return 0 ; }
Ref: 
def findMaxK ( N ) : NEW_LINE INDENT K = N NEW_LINE i = N - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT K &= i NEW_LINE if ( K == 0 ) : NEW_LINE INDENT return i NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT
Hyp: 
def findMaxK ( N ) : NEW_LINE INDENT K = N NEW_LINE for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT K &= i NEW_LINE if ( K == 0 ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT

BLEU: 69.24
Edit Sim: 42


Src: 
int distIntegers ( int L , int R ) { return 2 * R - 2 * L + 1 ; }
Ref: 
def distIntegers ( L , R ) : NEW_LINE INDENT return 2 * R - 2 * L + 1 NEW_LINE DEDENT
Hyp: 
def distIntegers ( L , R ) : NEW_LINE INDENT return 2 * R - 2 * L + 1 NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int longestPalSubstr ( String str ) { int n = str . length ( ) ; int maxLength = 1 , start = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { for ( int j = i ; j < str . length ( ) ; j ++ ) { int flag = 1 ; for ( int k = 0 ; k < ( j - i + 1 ) / 2 ; k ++ ) if ( str . charAt ( i + k ) != str . charAt ( j - k ) ) flag = 0 ; if ( flag != 0 && ( j - i + 1 ) > maxLength ) { start = i ; maxLength = j - i + 1 ; } } } return maxLength ; }
Ref: 
def longestPalSubstr ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE maxLength = 1 NEW_LINE start = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT for j in range ( i , len ( str ) , 1 ) : NEW_LINE INDENT flag = 1 NEW_LINE for k in range ( ( j - i + 1 ) // 2 ) : NEW_LINE INDENT if ( str [ i + k ] != str [ j - k ] ) : NEW_LINE INDENT flag = 0 NEW_LINE DEDENT DEDENT if ( flag != 0 and ( j - i + 1 ) > maxLength ) : NEW_LINE INDENT start = i NEW_LINE maxLength = j - i + 1 NEW_LINE DEDENT DEDENT DEDENT return maxLength NEW_LINE DEDENT
Hyp: 
def longestPalSubstr ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE maxLength = 1 NEW_LINE start = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i , len ( str ) ) : NEW_LINE INDENT flag = 1 NEW_LINE for k in range ( ( j - i + 1 ) // 2 , 1 ) : NEW_LINE INDENT if ( str [ i + k ] != str [ j - k ] ) : NEW_LINE INDENT flag = 0 NEW_LINE DEDENT DEDENT if ( flag != 0 and ( j - i + 1 ) > maxLength ) : NEW_LINE INDENT start = i NEW_LINE maxLength = j - i + 1 NEW_LINE DEDENT DEDENT DEDENT return maxLength NEW_LINE DEDENT

BLEU: 94.87
Edit Sim: 18


Src: 
void GenerateArray ( int N , int X ) { int prev_xor = X ; for ( int i = 1 ; i <= N ; i ++ ) { System . out . print ( i ^ prev_xor ) ; if ( i != N ) { System . out . print ( " ▁ " ) ; } prev_xor = i ; } }
Ref: 
def GenerateArray ( N , X ) : NEW_LINE INDENT prev_xor = X NEW_LINE for i in range ( 1 , N + 1 , 1 ) : NEW_LINE INDENT print ( i ^ prev_xor , end = " " ) NEW_LINE if ( i != N ) : NEW_LINE INDENT print ( " ▁ " , end = " " ) NEW_LINE DEDENT prev_xor = i NEW_LINE DEDENT DEDENT
Hyp: 
def GenerateArray ( N , X ) : NEW_LINE INDENT prev_xor = X NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT print ( i ^ prev_xor ) NEW_LINE if ( i != N ) : NEW_LINE INDENT print ( " ▁ " ) NEW_LINE DEDENT prev_xor = i NEW_LINE DEDENT DEDENT

BLEU: 76.89
Edit Sim: 28


Src: 
boolean findPair ( int arr [ ] , int n ) { int size = arr . length ; int i = 0 , j = 1 ; while ( i < size && j < size ) { if ( i != j && arr [ j ] - arr [ i ] == n ) { System . out . print ( " Pair ▁ Found : ▁ " + " ( ▁ " + arr [ i ] + " , ▁ " + arr [ j ] + " ▁ ) " ) ; return true ; } else if ( arr [ j ] - arr [ i ] < n ) j ++ ; else i ++ ; } System . out . print ( " No ▁ such ▁ pair " ) ; return false ; }
Ref: 
def findPair ( arr , n ) : NEW_LINE INDENT size = len ( arr ) NEW_LINE i , j = 0 , 1 NEW_LINE while i < size and j < size : NEW_LINE INDENT if i != j and arr [ j ] - arr [ i ] == n : NEW_LINE INDENT print " Pair ▁ found ▁ ( " , arr [ i ] , " , " , arr [ j ] , " ) " NEW_LINE return True NEW_LINE DEDENT elif arr [ j ] - arr [ i ] < n : NEW_LINE INDENT j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT print " No ▁ pair ▁ found " NEW_LINE return False NEW_LINE DEDENT
Hyp: 
def findPair ( arr , n ) : NEW_LINE INDENT size = len ( arr ) NEW_LINE i = 0 ; j = 1 NEW_LINE while ( i < size and j < size ) : NEW_LINE INDENT if ( i != j and arr [ j ] - arr [ i ] == n ) : NEW_LINE INDENT print ( " Pair ▁ Found : ▁ " , " ( ▁ " , arr [ i ] , " , ▁ " , arr [ j ] , " ▁ ) " , sep = " ▁ " ) NEW_LINE return True NEW_LINE DEDENT elif ( arr [ j ] - arr [ i ] < n ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT print ( " No ▁ such ▁ pair " ) NEW_LINE return False NEW_LINE DEDENT

BLEU: 64.63
Edit Sim: 63


Src: 
void largestSquare ( int matrix [ ] [ ] , int R , int C , int q_i [ ] , int q_j [ ] , int K , int Q ) { int countDP [ ] [ ] = new int [ R ] [ C ] ; for ( int i = 0 ; i < R ; i ++ ) for ( int j = 0 ; j < C ; j ++ ) countDP [ i ] [ j ] = 0 ; countDP [ 0 ] [ 0 ] = matrix [ 0 ] [ 0 ] ; for ( int i = 1 ; i < R ; i ++ ) countDP [ i ] [ 0 ] = countDP [ i - 1 ] [ 0 ] + matrix [ i ] [ 0 ] ; for ( int j = 1 ; j < C ; j ++ ) countDP [ 0 ] [ j ] = countDP [ 0 ] [ j - 1 ] + matrix [ 0 ] [ j ] ; for ( int i = 1 ; i < R ; i ++ ) for ( int j = 1 ; j < C ; j ++ ) countDP [ i ] [ j ] = matrix [ i ] [ j ] + countDP [ i - 1 ] [ j ] + countDP [ i ] [ j - 1 ] - countDP [ i - 1 ] [ j - 1 ] ; for ( int q = 0 ; q < Q ; q ++ ) { int i = q_i [ q ] ; int j = q_j [ q ] ; int min_dist = Math . min ( Math . min ( i , j ) , Math . min ( R - i - 1 , C - j - 1 ) ) ; int ans = - 1 , l = 0 , u = min_dist ; while ( l <= u ) { int mid = ( l + u ) / 2 ; int x1 = i - mid , x2 = i + mid ; int y1 = j - mid , y2 = j + mid ; int count = countDP [ x2 ] [ y2 ] ; if ( x1 > 0 ) count -= countDP [ x1 - 1 ] [ y2 ] ; if ( y1 > 0 ) count -= countDP [ x2 ] [ y1 - 1 ] ; if ( x1 > 0 && y1 > 0 ) count += countDP [ x1 - 1 ] [ y1 - 1 ] ; if ( count <= K ) { ans = 2 * mid + 1 ; l = mid + 1 ; } else u = mid - 1 ; } System . out . println ( ans ) ; } }
Ref: 
def largestSquare ( matrix , R , C , q_i , q_j , K , Q ) : NEW_LINE INDENT countDP = [ [ 0 for x in range ( C ) ] for x in range ( R ) ] NEW_LINE countDP [ 0 ] [ 0 ] = matrix [ 0 ] [ 0 ] NEW_LINE for i in range ( 1 , R ) : NEW_LINE INDENT countDP [ i ] [ 0 ] = ( countDP [ i - 1 ] [ 0 ] + matrix [ i ] [ 0 ] ) NEW_LINE DEDENT for j in range ( 1 , C ) : NEW_LINE INDENT countDP [ 0 ] [ j ] = ( countDP [ 0 ] [ j - 1 ] + matrix [ 0 ] [ j ] ) NEW_LINE DEDENT for i in range ( 1 , R ) : NEW_LINE INDENT for j in range ( 1 , C ) : NEW_LINE INDENT countDP [ i ] [ j ] = ( matrix [ i ] [ j ] + countDP [ i - 1 ] [ j ] + countDP [ i ] [ j - 1 ] - countDP [ i - 1 ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT for q in range ( 0 , Q ) : NEW_LINE INDENT i = q_i [ q ] NEW_LINE j = q_j [ q ] NEW_LINE min_dist = min ( i , j , R - i - 1 , C - j - 1 ) NEW_LINE ans = - 1 NEW_LINE l = 0 NEW_LINE u = min_dist NEW_LINE while ( l <= u ) : NEW_LINE INDENT mid = int ( ( l + u ) / 2 ) NEW_LINE x1 = i - mid NEW_LINE x2 = i + mid NEW_LINE y1 = j - mid NEW_LINE y2 = j + mid NEW_LINE count = countDP [ x2 ] [ y2 ] NEW_LINE if ( x1 > 0 ) : NEW_LINE INDENT count -= countDP [ x1 - 1 ] [ y2 ] NEW_LINE DEDENT if ( y1 > 0 ) : NEW_LINE INDENT count -= countDP [ x2 ] [ y1 - 1 ] NEW_LINE DEDENT if ( x1 > 0 and y1 > 0 ) : NEW_LINE INDENT count += countDP [ x1 - 1 ] [ y1 - 1 ] NEW_LINE DEDENT if ( count <= K ) : NEW_LINE INDENT ans = 2 * mid + 1 NEW_LINE l = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT u = mid - 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT DEDENT
Hyp: 
def largestSquare ( matrix , R , C , q_i , q_j , K , Q ) : NEW_LINE INDENT countDP = [ [ 0 for i in range ( C + 1 ) ] for j in range ( R + 1 ) ] NEW_LINE for i in range ( R ) : NEW_LINE INDENT countDP [ i ] [ j ] = 0 NEW_LINE DEDENT countDP [ 0 ] [ 0 ] = matrix [ 0 ] [ 0 ] NEW_LINE for i in range ( 1 , R + 1 ) : NEW_LINE INDENT for j in range ( 1 , C + j - 1 ) : NEW_LINE INDENT countDP [ i ] [ j ] = ( countDP [ i - 1 ] [ 0 ] + matrix [ i ] [ 0 ] ) NEW_LINE DEDENT for i in range ( 1 , R ) : NEW_LINE INDENT mid = ( l + u ) // 2 NEW_LINE x1 = i - mid NEW_LINE x2 = i + mid NEW_LINE y1 = j - mid NEW_LINE count = countDP [ x2 ] [ y2 ] NEW_LINE if ( x1 > 0 and y1 > 0 ) : NEW_LINE INDENT count -= countDP [ x1 - 1 ] [ y2 ] NEW_LINE DEDENT if ( x1 > 0 and y1 > 0 ) : NEW_LINE INDENT count += countDP [ x1 - 1 ] [ y1 - 1 ] NEW_LINE DEDENT DEDENT if ( count <= K ) : NEW_LINE INDENT ans = 2 * mid + 1 NEW_LINE DEDENT DEDENT if ( count <= K ) : NEW_LINE INDENT ans = 2 * mid + 1 NEW_LINE DEDENT DEDENT

BLEU: 48.4
Edit Sim: 651


Src: 
int calculate_sum ( int a , int N ) { int m = N / a ; int sum = m * ( m + 1 ) / 2 ; int ans = a * sum ; return ans ; }
Ref: 
def calculate_sum ( a , N ) : NEW_LINE INDENT m = N / a NEW_LINE sum = m * ( m + 1 ) / 2 NEW_LINE ans = a * sum NEW_LINE print ( " Sum ▁ of ▁ multiples ▁ of ▁ " , a , " ▁ up ▁ to ▁ " , N , " ▁ = ▁ " , ans ) NEW_LINE DEDENT
Hyp: 
def calculate_sum ( a , N ) : NEW_LINE INDENT m = N // a NEW_LINE sum = m * ( m + 1 ) // 2 NEW_LINE ans = a * sum NEW_LINE return ans NEW_LINE DEDENT

BLEU: 34.41
Edit Sim: 80


Src: 
void precompute ( ) { F [ 1 ] = 2 ; F [ 2 ] = 3 ; F [ 3 ] = 4 ; for ( int i = 4 ; i < N ; i ++ ) F [ i ] = ( F [ i - 1 ] + F [ i - 2 ] ) % MOD ; }
Ref: 
def precompute ( ) : NEW_LINE INDENT F [ 1 ] = 2 ; NEW_LINE F [ 2 ] = 3 ; NEW_LINE F [ 3 ] = 4 ; NEW_LINE for i in range ( 4 , N ) : NEW_LINE INDENT F [ i ] = ( F [ i - 1 ] + F [ i - 2 ] ) % MOD ; NEW_LINE DEDENT DEDENT
Hyp: 
def precompute ( ) : NEW_LINE INDENT F [ 1 ] = 2 NEW_LINE F [ 2 ] = 3 NEW_LINE F [ 3 ] = 4 NEW_LINE for i in range ( 4 , N ) : NEW_LINE INDENT F [ i ] = ( F [ i - 1 ] + F [ i - 2 ] ) % MOD NEW_LINE DEDENT DEDENT

BLEU: 84.91
Edit Sim: 8


Src: 
int findLUSlength ( String a , String b ) { if ( a . equals ( b ) == true ) return 0 ; return Math . max ( a . length ( ) , b . length ( ) ) ; }
Ref: 
def findLUSlength ( a , b ) : NEW_LINE INDENT if ( a == b ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return max ( len ( a ) , len ( b ) ) NEW_LINE DEDENT
Hyp: 
def findLUSlength ( a , b ) : NEW_LINE INDENT if ( a == b ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return max ( len ( a ) , len ( b ) ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int MinOfCubed ( int k ) { if ( k < 8 ) return k ; int res = k ; for ( int i = 1 ; i <= k ; i ++ ) { if ( ( i * i * i ) > k ) return res ; res = Math . min ( res , MinOfCubed ( k - ( i * i * i ) ) + 1 ) ; } return res ; }
Ref: 
def MinOfCubed ( k ) : NEW_LINE INDENT if ( k < 8 ) : NEW_LINE INDENT return k ; NEW_LINE DEDENT res = k ; NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT if ( ( i * i * i ) > k ) : NEW_LINE INDENT return res ; NEW_LINE DEDENT res = min ( res , MinOfCubed ( k - ( i * i * i ) ) + 1 ) ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT
Hyp: 
def MinOfCubed ( k ) : NEW_LINE INDENT if ( k < 8 ) : NEW_LINE INDENT return k NEW_LINE DEDENT res = k NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT if ( ( i * i * i ) > k ) : NEW_LINE INDENT return res NEW_LINE DEDENT res = min ( res , MinOfCubed ( k - ( i * i * i ) ) + 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT

BLEU: 85.91
Edit Sim: 10


Src: 
int smallestEven ( int n ) { if ( n == 1 ) return 0 ; return Math . pow ( 10 , n - 1 ) ; }
Ref: 
def smallestEven ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return pow ( 10 , n - 1 ) NEW_LINE DEDENT
Hyp: 
def smallestEven ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return pow ( 10 , n - 1 ) NEW_LINE DEDENT

BLEU: 91.85
Edit Sim: 1


Src: 
int countWays ( int index , int cnt , int dp [ ] [ ] , int n , int m , int k ) { if ( index == n ) { if ( cnt == k ) return 1 ; else return 0 ; } if ( dp [ index ] [ cnt ] != - 1 ) return dp [ index ] [ cnt ] ; int ans = 0 ; ans += countWays ( index + 1 , cnt , dp , n , m , k ) ; ans += ( m - 1 ) * countWays ( index + 1 , cnt + 1 , dp , n , m , k ) ; return dp [ index ] [ cnt ] = ans ; }
Ref: 
def countWays ( index , cnt , dp , n , m , k ) : NEW_LINE INDENT if ( index == n ) : NEW_LINE INDENT if ( cnt == k ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if ( dp [ index ] [ cnt ] != - 1 ) : NEW_LINE INDENT return dp [ index ] [ cnt ] NEW_LINE DEDENT ans = 0 NEW_LINE ans += countWays ( index + 1 , cnt , dp , n , m , k ) NEW_LINE ans += ( m - 1 ) * countWays ( index + 1 , cnt + 1 , dp , n , m , k ) NEW_LINE dp [ index ] [ cnt ] = ans NEW_LINE return dp [ index ] [ cnt ] NEW_LINE DEDENT
Hyp: 
def countWays ( index , cnt , dp , n , m , k ) : NEW_LINE INDENT if ( index == n ) : NEW_LINE INDENT if ( cnt == k ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT DEDENT if ( dp [ index ] [ cnt ] != - 1 ) : NEW_LINE INDENT return dp [ index ] [ cnt ] ; NEW_LINE DEDENT ans = 0 ; NEW_LINE ans += countWays ( index + 1 , cnt , dp , n , m , k ) ; NEW_LINE ans += ( m - 1 ) * countWays ( index + 1 , cnt + 1 , dp , n , m , k ) ; NEW_LINE return dp [ index ] [ cnt ] ; NEW_LINE DEDENT

BLEU: 85.77
Edit Sim: 47


Src: 
void getBuckets ( int [ ] arr , int N ) { int availableWater = N * ( N - 1 ) / 2 ; Arrays . sort ( arr ) ; int i = 0 , sum = 0 ; while ( sum <= availableWater ) { sum += arr [ i ] ; i ++ ; } System . out . println ( i - 1 ) ; }
Ref: 
def getBuckets ( arr , N ) : NEW_LINE INDENT availableWater = N * ( N - 1 ) // 2 NEW_LINE arr . sort ( ) NEW_LINE i , Sum = 0 , 0 NEW_LINE while ( Sum <= availableWater ) : NEW_LINE INDENT Sum += arr [ i ] NEW_LINE i += 1 NEW_LINE DEDENT print ( i - 1 , end = " " ) NEW_LINE DEDENT
Hyp: 
def getBuckets ( arr , N ) : NEW_LINE INDENT availableWater = N * ( N - 1 ) / 2 NEW_LINE arr . sort ( ) NEW_LINE i = 0 NEW_LINE sum = 0 NEW_LINE while ( sum <= availableWater ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE i += 1 NEW_LINE DEDENT print ( i - 1 ) NEW_LINE DEDENT

BLEU: 70.91
Edit Sim: 30


Src: 
void printDistSum ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; boolean [ ] [ ] dp = new boolean [ n + 1 ] [ sum + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = true ; for ( int i = 1 ; i <= n ; i ++ ) { dp [ i ] [ arr [ i - 1 ] ] = true ; for ( int j = 1 ; j <= sum ; j ++ ) { if ( dp [ i - 1 ] [ j ] == true ) { dp [ i ] [ j ] = true ; dp [ i ] [ j + arr [ i - 1 ] ] = true ; } } } for ( int j = 0 ; j <= sum ; j ++ ) if ( dp [ n ] [ j ] == true ) System . out . print ( j + " ▁ " ) ; }
Ref: 
def printDistSum ( arr , n ) : NEW_LINE INDENT Sum = sum ( arr ) NEW_LINE dp = [ [ False for i in range ( Sum + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = True NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT dp [ i ] [ arr [ i - 1 ] ] = True NEW_LINE for j in range ( 1 , Sum + 1 ) : NEW_LINE INDENT if ( dp [ i - 1 ] [ j ] == True ) : NEW_LINE INDENT dp [ i ] [ j ] = True NEW_LINE dp [ i ] [ j + arr [ i - 1 ] ] = True NEW_LINE DEDENT DEDENT DEDENT for j in range ( Sum + 1 ) : NEW_LINE INDENT if ( dp [ n ] [ j ] == True ) : NEW_LINE INDENT print ( j , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
Hyp: 
def printDistSum ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT dp = [ [ False for i in range ( sum + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = True NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT dp [ i ] [ arr [ i - 1 ] ] = True NEW_LINE DEDENT for j in range ( 1 , sum + 1 ) : NEW_LINE INDENT if ( dp [ i - 1 ] [ j ] == True ) : NEW_LINE INDENT dp [ i ] [ j ] = True NEW_LINE dp [ i ] [ j + arr [ i - 1 ] ] = True NEW_LINE DEDENT DEDENT DEDENT for j in range ( 0 , sum + 1 ) : NEW_LINE INDENT if ( dp [ n ] [ j ] == True ) : NEW_LINE INDENT print ( j , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT

BLEU: 83.8
Edit Sim: 80


Src: 
void solve ( int i , int par , int a [ ] , int n , int k , int current_ans ) { if ( par > k ) return ; if ( par == k && i == n - 1 ) { ans = Math . min ( ans , current_ans ) ; return ; } for ( int j = i + 1 ; j < n ; j ++ ) solve ( j , par + 1 , a , n , k , current_ans + ( a [ j ] - a [ i + 1 ] ) * ( a [ j ] - a [ i + 1 ] ) ) ; }
Ref: 
def solve ( i , par , a , n , k , current_ans ) : NEW_LINE INDENT if ( par > k ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT global ans NEW_LINE if ( par == k and i == n - 1 ) : NEW_LINE INDENT ans = min ( ans , current_ans ) NEW_LINE return 0 NEW_LINE DEDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT solve ( j , par + 1 , a , n , k , current_ans + ( a [ j ] - a [ i + 1 ] ) * ( a [ j ] - a [ i + 1 ] ) ) NEW_LINE DEDENT DEDENT
Hyp: 
def solve ( i , par , a , n , k , current_ans ) : NEW_LINE INDENT if ( par > k ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( par == k and i == n - 1 ) : NEW_LINE INDENT ans = min ( ans , current_ans ) NEW_LINE return NEW_LINE DEDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT solve ( j , par + 1 , a , n , k , current_ans + ( a [ j ] - a [ i + 1 ] ) * ( a [ j ] - a [ i + 1 ] ) ) NEW_LINE DEDENT DEDENT

BLEU: 92.33
Edit Sim: 24


Src: 
int max_xor ( int arr [ ] , int n ) { int maxXor = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { maxXor = Math . max ( maxXor , arr [ i ] ^ arr [ j ] ) ; } } return maxXor ; }
Ref: 
def max_xor ( arr , n ) : NEW_LINE INDENT maxXor = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT maxXor = max ( maxXor , \ arr [ i ] ^ arr [ j ] ) ; NEW_LINE DEDENT DEDENT return maxXor ; NEW_LINE DEDENT
Hyp: 
def max_xor ( arr , n ) : NEW_LINE INDENT maxXor = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT maxXor = max ( maxXor , arr [ i ] ^ arr [ j ] ) ; NEW_LINE DEDENT DEDENT return maxXor ; NEW_LINE DEDENT

BLEU: 96.08
Edit Sim: 2


Src: 
boolean isKAlternating ( String s , int k ) { if ( s . length ( ) < k ) return false ; int checker = 0 ; for ( int i = 0 ; i < k ; i ++ ) { int bitAtIndex = s . charAt ( i ) - ' a ' ; if ( ( checker & ( 1 << bitAtIndex ) ) > 0 ) { return false ; } checker = checker | ( 1 << bitAtIndex ) ; } for ( int i = k ; i < s . length ( ) ; i ++ ) if ( s . charAt ( i - k ) != s . charAt ( i ) ) return false ; return true ; }
Ref: 
def isKAlternating ( s , k ) : NEW_LINE INDENT if ( len ( s ) < k ) : NEW_LINE INDENT return False NEW_LINE DEDENT checker = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT bitAtIndex = ord ( s [ i ] ) - ord ( ' a ' ) NEW_LINE if ( ( checker & ( 1 << bitAtIndex ) ) > 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT checker = checker | ( 1 << bitAtIndex ) NEW_LINE DEDENT for i in range ( k , len ( s ) ) : NEW_LINE INDENT if ( s [ i - k ] != s [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
Hyp: 
def isKAlternating ( s , k ) : NEW_LINE INDENT if ( len ( s ) < k ) : NEW_LINE INDENT return False NEW_LINE DEDENT checker = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT bitAtIndex = ord ( s [ i ] ) - ord ( ' a ' ) NEW_LINE if ( checker & ( 1 << bitAtIndex ) ) > 0 : NEW_LINE INDENT return False NEW_LINE DEDENT checker = checker | ( 1 << bitAtIndex ) NEW_LINE DEDENT for i in range ( k , len ( s ) ) : NEW_LINE INDENT if ( s [ i - k ] != s [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT

BLEU: 96.69
Edit Sim: 4


Src: 
int minNumber ( int a [ ] , int n , int x ) { Arrays . sort ( a ) ; int k ; for ( k = 0 ; a [ ( n ) / 2 ] != x ; k ++ ) { a [ n ++ ] = x ; Arrays . sort ( a ) ; } return k ; }
Ref: 
def minNumber ( a , n , x ) : NEW_LINE INDENT a . sort ( reverse = False ) NEW_LINE k = 0 NEW_LINE while ( a [ int ( ( n - 1 ) / 2 ) ] != x ) : NEW_LINE INDENT a [ n - 1 ] = x NEW_LINE n += 1 NEW_LINE a . sort ( reverse = False ) NEW_LINE k += 1 NEW_LINE DEDENT return k NEW_LINE DEDENT
Hyp: 
def minNumber ( a , n , x ) : NEW_LINE INDENT a . sort ( ) NEW_LINE k = 0 NEW_LINE while ( a [ int ( ( n ) / 2 ) ] != x ) : NEW_LINE INDENT a [ n ] = x NEW_LINE n += 1 NEW_LINE DEDENT a . sort ( ) NEW_LINE k = k + 1 NEW_LINE DEDENT return k NEW_LINE DEDENT

BLEU: 73.52
Edit Sim: 51


Src: 
boolean isPossible ( int x , int y , int k ) { int minMoves = Math . abs ( x ) + Math . abs ( y ) ; if ( k >= minMoves && ( k - minMoves ) % 2 == 0 ) return true ; return false ; }
Ref: 
def isPossible ( x , y , k ) : NEW_LINE INDENT minMoves = abs ( x ) + abs ( y ) NEW_LINE if ( k >= minMoves and ( k - minMoves ) % 2 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT x = 5 NEW_LINE y = 8 NEW_LINE k = 20 NEW_LINE if ( isPossible ( x , y , k ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
Hyp: 
def isPossible ( x , y , k ) : NEW_LINE INDENT minMoves = abs ( x ) + abs ( y ) NEW_LINE if ( k >= minMoves and ( k - minMoves ) % 2 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT

BLEU: 40.58
Edit Sim: 186


Src: 
void triangleArea ( float a , float b ) { if ( a < 0 b < 0 ) { System . out . println ( - 1 ) ; return ; } float area = ( 3 * ( float ) Math . sqrt ( 3 ) * a * b ) / ( 4 ) ; System . out . println ( area ) ; }
Ref: 
def triangleArea ( a , b ) : NEW_LINE INDENT if ( a < 0 or b < 0 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE return NEW_LINE DEDENT area = ( 3 * sqrt ( 3 ) * a * b ) / ( 4 ) ; NEW_LINE print ( " { : . 5f } " . format ( area ) ) NEW_LINE DEDENT
Hyp: 
def triangleArea ( a , b ) : NEW_LINE INDENT if ( a < 0 or b < 0 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE return NEW_LINE DEDENT area = ( 3 * math . sqrt ( 3 ) * a * b ) / ( 4 ) ) NEW_LINE print ( area ) NEW_LINE DEDENT

BLEU: 76.24
Edit Sim: 36


Src: 
void printExpansion ( String str ) { String suff = " " ; for ( int i = str . length ( ) - 1 ; i >= 0 ; i -- ) { suff = suff + str . charAt ( i ) ; System . out . print ( suff ) ; } }
Ref: 
def printExpansion ( str ) : NEW_LINE INDENT suff = " " NEW_LINE for i in range ( len ( str ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT suff = suff + str [ i ] NEW_LINE print ( suff , end = " " ) NEW_LINE DEDENT DEDENT
Hyp: 
def printExpansion ( str ) : NEW_LINE INDENT suff = " " NEW_LINE for i in range ( len ( str ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT suff = suff + str [ i ] NEW_LINE print ( suff ) NEW_LINE DEDENT DEDENT

BLEU: 87.67
Edit Sim: 12


Src: 
void findPair ( int [ ] arr , int n ) { boolean found = false ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { for ( int k = 0 ; k < n ; k ++ ) { if ( arr [ i ] + arr [ j ] == arr [ k ] ) { System . out . println ( arr [ i ] + " ▁ " + arr [ j ] ) ; found = true ; } } } } if ( found == false ) System . out . println ( " Not ▁ exist " ) ; }
Ref: 
def findPair ( arr , n ) : NEW_LINE INDENT found = False NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT for k in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] + arr [ j ] == arr [ k ] ) : NEW_LINE INDENT print ( arr [ i ] , arr [ j ] ) NEW_LINE found = True NEW_LINE DEDENT DEDENT DEDENT DEDENT if ( found == False ) : NEW_LINE INDENT print ( " Not ▁ exist " ) NEW_LINE DEDENT DEDENT
Hyp: 
def findPair ( arr , n ) : NEW_LINE INDENT found = False NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT for k in range ( n ) : NEW_LINE INDENT if ( arr [ i ] + arr [ j ] == arr [ k ] ) : NEW_LINE INDENT print ( arr [ i ] , " ▁ " , arr [ j ] ) NEW_LINE found = True NEW_LINE DEDENT DEDENT DEDENT DEDENT if ( found == False ) : NEW_LINE INDENT print ( " Not ▁ exist " ) NEW_LINE DEDENT DEDENT

BLEU: 93.25
Edit Sim: 16


Src: 
boolean isTriplet ( int ar [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) { if ( Math . abs ( ar [ i ] - ar [ j ] ) == 1 || Math . abs ( ar [ j ] - ar [ k ] ) == 1 || Math . abs ( ar [ i ] - ar [ k ] ) == 1 ) { int x = ar [ i ] * ar [ i ] , y = ar [ j ] * ar [ j ] , z = ar [ k ] * ar [ k ] ; if ( x == y + z y == x + z z == x + y ) return true ; } } } } return false ; }
Ref: 
def isTriplet ( ar , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT if ( abs ( ar [ i ] - ar [ j ] ) == 1 or abs ( ar [ j ] - ar [ k ] ) == 1 or abs ( ar [ i ] - ar [ k ] ) == 1 ) : NEW_LINE INDENT x = ar [ i ] * ar [ i ] NEW_LINE y = ar [ j ] * ar [ j ] NEW_LINE z = ar [ k ] * ar [ k ] NEW_LINE if ( x == y + z or y == x + z or z == x + y ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return False NEW_LINE DEDENT
Hyp: 
def isTriplet ( ar , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n , 1 ) : NEW_LINE INDENT for k in range ( j + 1 , n , 1 ) : NEW_LINE INDENT if ( abs ( ar [ i ] - ar [ j ] ) == 1 or abs ( ar [ j ] - ar [ k ] ) == 1 or abs ( ar [ i ] - ar [ k ] ) == 1 ) : NEW_LINE INDENT x = ar [ i ] * ar [ i ] y = ar [ j ] * ar [ j ] NEW_LINE z = ar [ k ] * ar [ k ] NEW_LINE if ( x == y + z y == x + z z == x + y ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return False NEW_LINE DEDENT

BLEU: 93.13
Edit Sim: 23


Src: 
int center_octadecagon_num ( int n ) { return 9 * n * n - 9 * n + 1 ; }
Ref: 
def center_octadecagon_num ( n ) : NEW_LINE INDENT return ( 9 * n * n - 9 * n + 1 ) NEW_LINE DEDENT
Hyp: 
def center_octadecagon_num ( n ) : NEW_LINE INDENT return 9 * n * n - 9 * n + 1 NEW_LINE DEDENT

BLEU: 78.7
Edit Sim: 4


Src: 
String maxInt ( char str [ ] ) { for ( int i = 0 ; i < str . length ; i ++ ) { if ( str [ i ] < '5' ) { str [ i ] = ( char ) ( ( '9' - str [ i ] ) + '0' ) ; } } if ( str [ 0 ] == '0' ) str [ 0 ] = '9' ; String str2 = new String ( str ) ; return str2 ; }
Ref: 
def maxInt ( string ) : NEW_LINE INDENT string2 = " " NEW_LINE for i in range ( 0 , len ( string ) ) : NEW_LINE INDENT if ( string [ i ] < '5' ) : NEW_LINE INDENT string2 += str ( ( ord ( '9' ) - ord ( string [ i ] ) ) ) NEW_LINE DEDENT else : NEW_LINE INDENT string2 += str ( string [ i ] ) NEW_LINE DEDENT DEDENT if ( string2 [ 0 ] == '0' ) : NEW_LINE INDENT string2 [ 0 ] = '9' NEW_LINE DEDENT return string2 NEW_LINE DEDENT
Hyp: 
def maxInt ( str ) : NEW_LINE INDENT for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] < '5' ) : NEW_LINE INDENT str [ i ] = chr ( ( '9' - ord ( str [ i ] ) + '0' ) ; NEW_LINE DEDENT DEDENT if ( str [ 0 ] == '0' ) : NEW_LINE INDENT str [ 0 ] = '9' ; NEW_LINE DEDENT return str ; NEW_LINE DEDENT

BLEU: 42.3
Edit Sim: 139


Src: 
void Nonagonal ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) { System . out . print ( i * ( 7 * i - 5 ) / 2 ) ; System . out . print ( " ▁ " ) ; } }
Ref: 
def Nonagonal ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( int ( i * ( 7 * i - 5 ) / 2 ) , end = " ▁ " ) NEW_LINE DEDENT DEDENT
Hyp: 
def Nonagonal ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( ( i * ( 7 * i - 5 ) / 2 ) , end = " ▁ " ) NEW_LINE DEDENT DEDENT

BLEU: 94.65
Edit Sim: 4


Src: 
boolean check ( String str ) { int min = Integer . MAX_VALUE ; int max = Integer . MIN_VALUE ; int sum = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { int ascii = ( int ) str . charAt ( i ) ; if ( ascii < 96 ascii > 122 ) return false ; sum += ascii ; if ( min > ascii ) min = ascii ; if ( max < ascii ) max = ascii ; } min -= 1 ; int eSum = ( ( max * ( max + 1 ) ) / 2 ) - ( ( min * ( min + 1 ) ) / 2 ) ; return sum == eSum ; }
Ref: 
def check ( str ) : NEW_LINE INDENT min = sys . maxsize NEW_LINE max = - sys . maxsize - 1 NEW_LINE sum = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT ascii = str [ i ] NEW_LINE if ( ord ( ascii ) < 96 or ord ( ascii ) > 122 ) : NEW_LINE INDENT return False NEW_LINE DEDENT sum += ord ( ascii ) NEW_LINE if ( min > ord ( ascii ) ) : NEW_LINE INDENT min = ord ( ascii ) NEW_LINE DEDENT if ( max < ord ( ascii ) ) : NEW_LINE INDENT max = ord ( ascii ) NEW_LINE DEDENT DEDENT min -= 1 NEW_LINE eSum = ( ( ( max * ( max + 1 ) ) // 2 ) - ( ( min * ( min + 1 ) ) // 2 ) ) NEW_LINE return sum == eSum NEW_LINE DEDENT
Hyp: 
def check ( st ) : NEW_LINE INDENT min = INT_MAX ; NEW_LINE max = INT_MIN ; NEW_LINE sum = 0 ; NEW_LINE for i in range ( len ( st ) ) : NEW_LINE INDENT ascii = ord ( st [ i ] ) ; NEW_LINE if ( ascii < 96 or ascii > 122 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT sum += ascii ; NEW_LINE if ( min > ascii ) : NEW_LINE INDENT min = ascii ; NEW_LINE DEDENT if ( max < ascii ) : NEW_LINE INDENT max = ascii ; NEW_LINE DEDENT DEDENT min -= 1 ; NEW_LINE eSum = ( ( max * ( max + 1 ) ) // 2 ) - ( ( min * ( min + 1 ) ) // 2 ) ; NEW_LINE return sum == eSum ; NEW_LINE DEDENT st = " aba " ; NEW_LINE if ( check ( st ) ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT

BLEU: 51.15
Edit Sim: 264


Src: 
int posOfRightMostDiffBit ( int m , int n ) { return ( int ) Math . floor ( Math . log10 ( Math . pow ( m ^ n , 2 ) ) ) + 2 ; }
Ref: 
def posOfRightMostDiffBit ( m , n ) : NEW_LINE INDENT return floor ( log10 ( pow ( m ^ n , 2 ) ) ) + 2 NEW_LINE DEDENT
Hyp: 
def posOfRightMostDiffBit ( m , n ) : NEW_LINE INDENT return math . floor ( math . log10 ( pow ( m ^ n , 2 ) ) ) + 2 NEW_LINE DEDENT

BLEU: 78.73
Edit Sim: 14


Src: 
boolean pronic_check ( int n ) { int x = ( int ) ( Math . sqrt ( n ) ) ; if ( x * ( x + 1 ) == n ) return true ; else return false ; }
Ref: 
def pronic_check ( n ) : NEW_LINE INDENT x = ( int ) ( math . sqrt ( n ) ) NEW_LINE if ( x * ( x + 1 ) == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT n = 56 NEW_LINE if ( pronic_check ( n ) == True ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
Hyp: 
def pronic_check ( n ) : NEW_LINE INDENT x = int ( math . sqrt ( n ) ) ; NEW_LINE if ( x * ( x + 1 ) == n ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT else : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT

BLEU: 40.2
Edit Sim: 165


Src: 
int min_cost ( String S ) { int cost = 0 ; int F = 0 ; int B = 0 ; int count = 0 ; for ( char c : S . toCharArray ( ) ) if ( c == ' ▁ ' ) count ++ ; int n = S . length ( ) - count ; if ( n == 1 ) return cost ; for ( char in : S . toCharArray ( ) ) { if ( in != ' ▁ ' ) { if ( B != 0 ) { cost += Math . min ( n - F , F ) * B ; B = 0 ; } F += 1 ; } else { B += 1 ; } } return cost ; }
Ref: 
def min_cost ( S ) : NEW_LINE INDENT cost = 0 NEW_LINE F = 0 NEW_LINE B = 0 NEW_LINE n = len ( S ) - S . count ( ' ▁ ' ) NEW_LINE if n == 1 : NEW_LINE INDENT return cost NEW_LINE DEDENT for char in S : NEW_LINE INDENT if char != ' ▁ ' : NEW_LINE INDENT if B != 0 : NEW_LINE INDENT cost += min ( n - F , F ) * B NEW_LINE B = 0 NEW_LINE DEDENT F += 1 NEW_LINE DEDENT else : NEW_LINE INDENT B += 1 NEW_LINE DEDENT DEDENT return cost NEW_LINE DEDENT
Hyp: 
def min_cost ( S ) : NEW_LINE INDENT cost = 0 NEW_LINE F = 0 NEW_LINE B = 0 NEW_LINE count = 0 NEW_LINE for c in S : NEW_LINE INDENT if c == ' ▁ ' : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT n = len ( S ) - count NEW_LINE if ( n == 1 ) : NEW_LINE INDENT return cost NEW_LINE DEDENT for in in : NEW_LINE INDENT if in != ' ▁ ' : NEW_LINE INDENT if ( B != 0 ) : NEW_LINE INDENT cost += min ( n - F , F ) * B NEW_LINE B = 0 NEW_LINE DEDENT F += 1 NEW_LINE DEDENT else : NEW_LINE INDENT B += 1 NEW_LINE DEDENT DEDENT return cost NEW_LINE DEDENT

BLEU: 67.08
Edit Sim: 130


Src: 
int dealnnoy ( int n , int m ) { int dp [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) dp [ i ] [ 0 ] = 1 ; for ( int i = 0 ; i < m ; i ++ ) dp [ 0 ] [ i ] = 1 ; for ( int i = 1 ; i <= m ; i ++ ) for ( int j = 1 ; j <= n ; j ++ ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] + dp [ i ] [ j - 1 ] ; return dp [ m ] [ n ] ; }
Ref: 
def dealnnoy ( n , m ) : NEW_LINE INDENT dp = [ [ 0 for x in range ( n + 1 ) ] for x in range ( m + 1 ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT dp [ 0 ] [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , m + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] + dp [ i ] [ j - 1 ] ; NEW_LINE DEDENT DEDENT return dp [ m ] [ n ] NEW_LINE DEDENT
Hyp: 
def dealnnoy ( n , m ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( m + 1 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = 1 NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT dp [ 0 ] [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] + dp [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT return dp [ m ] [ n ] NEW_LINE DEDENT

BLEU: 92.22
Edit Sim: 21


Src: 
long removeElements ( long arr [ ] , int n ) { Arrays . sort ( arr ) ; arr = reverse ( arr ) ; long ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ans += arr [ i ] * Math . pow ( 2 , i ) ; } return ans ; }
Ref: 
def removeElements ( arr , n ) : NEW_LINE INDENT arr . sort ( reverse = True ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans += arr [ i ] * pow ( 2 , i ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
Hyp: 
def removeElements ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE arr . reverse ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans += arr [ i ] * pow ( 2 , i ) NEW_LINE DEDENT return ans NEW_LINE DEDENT

BLEU: 86.59
Edit Sim: 22


Src: 
boolean findNature ( int a , int b , int n ) { if ( n == 0 ) return ( a & 1 ) == 1 ? true : false ; if ( n == 1 ) return ( b & 1 ) == 1 ? true : false ; if ( ( a & 1 ) == 0 ) { if ( ( b & 1 ) == 0 ) return false ; else return ( n % 3 != 0 ) ; } else { if ( ( b & 1 ) == 0 ) return ( ( n - 1 ) % 3 != 0 ) ; else return ( ( n + 1 ) % 3 != 0 ) ; } }
Ref: 
def findNature ( a , b , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return ( a & 1 ) ; NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return ( b & 1 ) ; NEW_LINE DEDENT if ( ( a & 1 ) == 0 ) : NEW_LINE INDENT if ( ( b & 1 ) == 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT else : NEW_LINE INDENT return True if ( n % 3 != 0 ) else False ; NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( ( b & 1 ) == 0 ) : NEW_LINE INDENT return True if ( ( n - 1 ) % 3 != 0 ) else False ; NEW_LINE DEDENT else : NEW_LINE INDENT return True if ( ( n + 1 ) % 3 != 0 ) else False ; NEW_LINE DEDENT DEDENT DEDENT a = 2 ; NEW_LINE b = 4 ; NEW_LINE n = 3 ; NEW_LINE if ( findNature ( a , b , n ) == True ) : NEW_LINE INDENT print ( " Odd " , end = " ▁ " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Even " , end = " ▁ " ) ; NEW_LINE DEDENT
Hyp: 
def findNature ( a , b , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return ( a & 1 ) == 1 ? True : False NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return ( b & 1 ) == 1 ? True : False NEW_LINE DEDENT if ( a & 1 ) : NEW_LINE INDENT if ( b & 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return ( n % 3 != 0 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( b & 1 ) == 0 ) : NEW_LINE INDENT return ( ( n - 1 ) % 3 != 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( ( n + 1 ) % 3 != 0 ) NEW_LINE DEDENT DEDENT

BLEU: 46.26
Edit Sim: 363


Src: 
int count ( int arr [ ] , int low , int high , int x ) { if ( ( low > high ) || ( low == high && arr [ low ] != x ) ) return 0 ; if ( low == high && arr [ low ] == x ) return 1 ; return count ( arr , low , ( low + high ) / 2 , x ) + count ( arr , 1 + ( low + high ) / 2 , high , x ) ; }
Ref: 
def count ( arr , low , high , x ) : NEW_LINE INDENT if ( ( low > high ) or ( low == high and arr [ low ] != x ) ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( low == high and arr [ low ] == x ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT return count ( arr , low , ( low + high ) // 2 , x ) + count ( arr , 1 + ( low + high ) // 2 , high , x ) ; NEW_LINE DEDENT
Hyp: 
def count ( arr , low , high , x ) : NEW_LINE INDENT if ( ( low > high ) or ( low == high and arr [ low ] != x ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( low == high and arr [ low ] == x ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return count ( arr , low , ( low + high ) // 2 , x ) + count ( arr , 1 + ( low + high ) // 2 , high , x ) NEW_LINE DEDENT

BLEU: 92.82
Edit Sim: 6


Src: 
boolean isReachable ( long x1 , long y1 , long x2 , long y2 ) { while ( x2 > x1 && y2 > y1 ) { if ( x2 > y2 ) x2 %= y2 ; else y2 %= x2 ; } if ( x2 == x1 ) return ( y2 - y1 ) >= 0 && ( y2 - y1 ) % x1 == 0 ; else if ( y2 == y1 ) return ( x2 - x1 ) >= 0 && ( x2 - x1 ) % y1 == 0 ; else return false ; }
Ref: 
def isReachable ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT while ( x2 > x1 and y2 > y1 ) : NEW_LINE INDENT if ( x2 > y2 ) : NEW_LINE INDENT x2 %= y2 NEW_LINE DEDENT else : NEW_LINE INDENT y2 %= x2 NEW_LINE DEDENT DEDENT if ( x2 == x1 ) : NEW_LINE INDENT return ( y2 - y1 ) >= 0 and ( y2 - y1 ) % x1 == 0 NEW_LINE DEDENT elif ( y2 == y1 ) : NEW_LINE INDENT return ( x2 - x1 ) >= 0 and ( x2 - x1 ) % y1 == 0 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT source_x = 2 NEW_LINE source_y = 10 NEW_LINE dest_x = 26 NEW_LINE dest_y = 12 NEW_LINE if ( isReachable ( source_x , source_y , dest_x , dest_y ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
Hyp: 
def isReachable ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT while ( x2 > x1 and y2 > y1 ) : NEW_LINE INDENT if ( x2 > y2 ) : NEW_LINE INDENT x2 %= y2 NEW_LINE DEDENT else : NEW_LINE INDENT y2 %= x2 NEW_LINE DEDENT DEDENT if ( x2 == x1 ) : NEW_LINE INDENT return ( y2 - y1 ) >= 0 and ( y2 - y1 ) % x1 == 0 ) NEW_LINE DEDENT elif ( y2 == y1 ) : NEW_LINE INDENT return ( x2 - x1 ) >= 0 and ( x2 - x1 ) % y1 == 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT

BLEU: 62.7
Edit Sim: 257


Src: 
int IcositrigonalNum ( int n ) { return ( 21 * n * n - 19 * n ) / 2 ; }
Ref: 
def IcositrigonalNum ( n ) : NEW_LINE INDENT return ( 21 * n * n - 19 * n ) / 2 ; NEW_LINE DEDENT
Hyp: 
def IcositrigonalNum ( n ) : NEW_LINE INDENT return ( 21 * n * n - 19 * n ) // 2 NEW_LINE DEDENT

BLEU: 83.26
Edit Sim: 3


Src: 
int numofstring ( int n , int m ) { if ( n == 1 ) return m ; if ( n == 2 ) return m * ( m - 1 ) ; return m * ( m - 1 ) * ( int ) Math . pow ( m - 2 , n - 2 ) ; }
Ref: 
def numofstring ( n , m ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return m NEW_LINE DEDENT if n == 2 : NEW_LINE INDENT return m * ( m - 1 ) NEW_LINE DEDENT return m * ( m - 1 ) * pow ( m - 2 , n - 2 ) NEW_LINE DEDENT
Hyp: 
def numofstring ( n , m ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return m NEW_LINE DEDENT if ( n == 2 ) : NEW_LINE INDENT return m * ( m - 1 ) NEW_LINE DEDENT return m * ( m - 1 ) * pow ( m - 2 , n - 2 ) NEW_LINE DEDENT

BLEU: 83.53
Edit Sim: 8


Src: 
int countWays ( int n ) { int ans = 1 ; for ( int i = 0 ; i < n ; i ++ ) { ans *= 2 ; ans %= MOD ; } return ( ( ans - 1 + MOD ) % MOD ) ; }
Ref: 
def countWays ( n ) : NEW_LINE INDENT return ( ( ( 2 ** n ) - 1 ) % MOD ) NEW_LINE DEDENT
Hyp: 
def countWays ( n ) : NEW_LINE INDENT ans = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans *= 2 NEW_LINE ans %= MOD NEW_LINE DEDENT return ( ( ans - 1 + MOD ) % MOD ) NEW_LINE DEDENT

BLEU: 32.57
Edit Sim: 108


Src: 
boolean isDefeat ( String s1 , String s2 , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( ( s1 . charAt ( i ) == '0' && s2 . charAt ( i ) == '1' ) || ( s1 . charAt ( i ) == '1' && s2 . charAt ( i ) == '0' ) ) continue ; else if ( ( s1 . charAt ( i ) == '0' && s2 . charAt ( i ) == ' Z ' ) || ( s1 . charAt ( i ) == ' Z ' && s2 . charAt ( i ) == '0' ) ) continue ; else { return true ; } } return false ; }
Ref: 
def isDefeat ( s1 , s2 , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( ( s1 [ i ] == '0' and s2 [ i ] == '1' ) or ( s1 [ i ] == '1' and s2 [ i ] == '0' ) ) : NEW_LINE INDENT continue NEW_LINE DEDENT elif ( ( s1 [ i ] == '0' and s2 [ i ] == ' Z ' ) or ( s1 [ i ] == ' Z ' and s2 [ i ] == '0' ) ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT s1 = "01001101ZZ " NEW_LINE s2 = "10Z1001000" NEW_LINE n = 10 NEW_LINE if ( isDefeat ( s1 , s2 , n ) ) : NEW_LINE INDENT print ( " Defeat " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Victory " ) NEW_LINE DEDENT
Hyp: 
def isDefeat ( s1 , s2 , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( ( s1 [ i ] == '0' and s2 [ i ] == '1' ) or ( s1 [ i ] == '1' and s2 [ i ] == '0' ) ) : NEW_LINE INDENT continue NEW_LINE DEDENT elif ( ( s1 [ i ] == '0' and s2 [ i ] == '0' ) or ( s1 [ i ] == 'Z ' ) or ( s1 [ i ] == ' Z ' and s2 [ i ] == '0' ) ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT

BLEU: 67.43
Edit Sim: 241


Src: 
int minSum ( int n ) { int sum = 0 ; while ( n > 0 ) { sum += ( n % 10 ) ; n /= 10 ; } if ( sum == 1 ) return 10 ; return sum ; }
Ref: 
def minSum ( n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT sum += ( n % 10 ) ; NEW_LINE n //= 10 ; NEW_LINE DEDENT if ( sum == 1 ) : NEW_LINE INDENT return 10 ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT
Hyp: 
def minSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( n ) : NEW_LINE INDENT sum += ( n % 10 ) NEW_LINE n /= 10 NEW_LINE DEDENT if ( sum == 1 ) : NEW_LINE INDENT return 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT

BLEU: 67.07
Edit Sim: 15


Src: 
int findSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = i ; j <= n ; j ++ ) sum = sum + i * j ; return sum ; }
Ref: 
def findSum ( n ) : NEW_LINE INDENT sm = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( i , n + 1 ) : NEW_LINE INDENT sm = sm + i * j NEW_LINE DEDENT DEDENT return sm NEW_LINE DEDENT
Hyp: 
def findSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( i , n + 1 ) : NEW_LINE INDENT sum = sum + i * j NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT

BLEU: 82.78
Edit Sim: 4


Src: 
int findLength ( String s , int k ) { int ans = INT_MAX ; int l = 0 ; int r = 0 ; int cnt_zero = 0 , cnt_one = 0 ; while ( l < s . length ( ) && r <= s . length ( ) ) { if ( cnt_zero >= k && cnt_one >= 1 ) { ans = Math . min ( ans , r - l ) ; l ++ ; if ( s . charAt ( l - 1 ) == '0' ) cnt_zero -- ; else cnt_one -- ; } else { if ( r == s . length ( ) ) break ; if ( s . charAt ( r ) == '0' ) cnt_zero ++ ; else cnt_one ++ ; r ++ ; } } if ( ans == INT_MAX ) return - 1 ; return ans ; }
Ref: 
def findLength ( s , k ) : NEW_LINE INDENT ans = 10 ** 9 NEW_LINE l = 0 NEW_LINE r = 0 NEW_LINE cnt_zero = 0 NEW_LINE cnt_one = 0 NEW_LINE while ( l < len ( s ) and r <= len ( s ) ) : NEW_LINE INDENT if ( cnt_zero >= k and cnt_one >= 1 ) : NEW_LINE INDENT ans = min ( ans , r - l ) NEW_LINE l += 1 NEW_LINE if ( s [ l - 1 ] == '0' ) : NEW_LINE INDENT cnt_zero -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt_one -= 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( r == len ( s ) ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( s [ r ] == '0' ) : NEW_LINE INDENT cnt_zero += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt_one += 1 NEW_LINE DEDENT r += 1 NEW_LINE DEDENT DEDENT if ( ans == 10 ** 9 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
Hyp: 
def findLength ( s , k ) : NEW_LINE INDENT ans = INT_MAX ; NEW_LINE l = 0 ; NEW_LINE r = 0 ; NEW_LINE cnt_zero = 0 ; NEW_LINE cnt_one = 0 ; NEW_LINE while ( l < len ( s ) and r <= len ( s ) ) : NEW_LINE INDENT if ( cnt_zero >= k and cnt_one >= 1 ) : NEW_LINE INDENT ans = min ( ans , r - l ) ; NEW_LINE l += 1 ; NEW_LINE if ( s [ l - 1 ] == '0' ) : NEW_LINE INDENT cnt_zero -= 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT cnt_one -= 1 ; NEW_LINE DEDENT DEDENT if ( r == len ( s ) ) : NEW_LINE INDENT break ; NEW_LINE DEDENT if ( s [ r ] == '0' ) : NEW_LINE INDENT cnt_zero += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT cnt_one += 1 ; NEW_LINE DEDENT r += 1 ; NEW_LINE DEDENT DEDENT if ( ans == INT_MAX ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT

BLEU: 76.48
Edit Sim: 66


Src: 
int maxTripletSum ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; return arr [ n - 1 ] + arr [ n - 2 ] + arr [ n - 3 ] ; }
Ref: 
def maxTripletSum ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE return ( arr [ n - 1 ] + arr [ n - 2 ] + arr [ n - 3 ] ) NEW_LINE DEDENT
Hyp: 
def maxTripletSum ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE return arr [ n - 1 ] + arr [ n - 2 ] + arr [ n - 3 ] NEW_LINE DEDENT

BLEU: 87.94
Edit Sim: 4


Src: 
boolean IsRedundantBraces ( String A ) { int a = 0 , b = 0 ; for ( int i = 0 ; i < A . length ( ) ; i ++ ) { if ( A . charAt ( i ) == ' ( ' && A . charAt ( i + 2 ) == ' ) ' ) return true ; if ( A . charAt ( i ) == ' * ' || A . charAt ( i ) == ' + ' || A . charAt ( i ) == ' - ' || A . charAt ( i ) == ' / ' ) a ++ ; if ( A . charAt ( i ) == ' ( ' ) b ++ ; } if ( b > a ) return true ; return false ; }
Ref: 
def IsRedundantBraces ( A ) : NEW_LINE INDENT a , b = 0 , 0 ; NEW_LINE for i in range ( len ( A ) ) : NEW_LINE INDENT if ( A [ i ] == ' ( ' and A [ i + 2 ] == ' ) ' ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT if ( A [ i ] == ' * ' or A [ i ] == ' + ' or A [ i ] == ' - ' or A [ i ] == ' / ' ) : NEW_LINE INDENT a += 1 ; NEW_LINE DEDENT if ( A [ i ] == ' ( ' ) : NEW_LINE INDENT b += 1 ; NEW_LINE DEDENT DEDENT if ( b > a ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT
Hyp: 
def IsRedundantBraces ( A ) : NEW_LINE INDENT a = 0 NEW_LINE b = 0 NEW_LINE for i in range ( len ( A ) ) : NEW_LINE INDENT if ( A [ i ] == ' ( ' and A [ i + 2 ] == ' ) ' ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( A [ i ] == ' * ' or A [ i ] == ' + ' or A [ i ] == ' - ' or A [ i ] == ' / ' ) : NEW_LINE INDENT a += 1 NEW_LINE DEDENT if ( A [ i ] == ' ( ' ) : NEW_LINE INDENT b += 1 NEW_LINE DEDENT DEDENT if ( b > a ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT A = " aba " NEW_LINE if ( IsRedundantBraces ( A ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT

BLEU: 72.06
Edit Sim: 180


Src: 
int findoptimal ( int N ) { if ( N <= 6 ) return N ; int screen [ ] = new int [ N ] ; int b ; int n ; for ( n = 1 ; n <= 6 ; n ++ ) screen [ n - 1 ] = n ; for ( n = 7 ; n <= N ; n ++ ) { screen [ n - 1 ] = 0 ; for ( b = n - 3 ; b >= 1 ; b -- ) { int curr = ( n - b - 1 ) * screen [ b - 1 ] ; if ( curr > screen [ n - 1 ] ) screen [ n - 1 ] = curr ; } } return screen [ N - 1 ] ; }
Ref: 
def findoptimal ( N ) : NEW_LINE INDENT if ( N <= 6 ) : NEW_LINE INDENT return N NEW_LINE DEDENT screen = [ 0 ] * N NEW_LINE for n in range ( 1 , 7 ) : NEW_LINE INDENT screen [ n - 1 ] = n NEW_LINE DEDENT for n in range ( 7 , N + 1 ) : NEW_LINE INDENT screen [ n - 1 ] = 0 NEW_LINE for b in range ( n - 3 , 0 , - 1 ) : NEW_LINE INDENT curr = ( n - b - 1 ) * screen [ b - 1 ] NEW_LINE if ( curr > screen [ n - 1 ] ) : NEW_LINE INDENT screen [ n - 1 ] = curr NEW_LINE DEDENT DEDENT DEDENT return screen [ N - 1 ] NEW_LINE DEDENT
Hyp: 
def findoptimal ( N ) : NEW_LINE INDENT if ( N <= 6 ) : NEW_LINE INDENT return N NEW_LINE DEDENT screen = [ 0 ] * N NEW_LINE for n in range ( 1 , 6 + 1 ) : NEW_LINE INDENT screen [ n - 1 ] = n NEW_LINE DEDENT for n in range ( 7 , N + 1 ) : NEW_LINE INDENT screen [ n - 1 ] = 0 NEW_LINE for b in range ( n - 3 , - 1 , - 1 ) : NEW_LINE INDENT curr = ( n - b - 1 ) * screen [ b - 1 ] NEW_LINE if ( curr > screen [ n - 1 ] ) : NEW_LINE INDENT screen [ n - 1 ] = curr NEW_LINE DEDENT DEDENT DEDENT return screen [ N - 1 ] NEW_LINE DEDENT

BLEU: 94.48
Edit Sim: 8


Src: 
int fact ( int n ) { if ( n == 0 ) return 1 ; return n * fact ( n - 1 ) ; }
Ref: 
def fact ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return n * fact ( n - 1 ) NEW_LINE DEDENT
Hyp: 
def fact ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return n * fact ( n - 1 ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
void printChar ( String str , int n ) { int [ ] freq = new int [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) freq [ str . charAt ( i ) - ' a ' ] ++ ; for ( int i = 0 ; i < n ; i ++ ) { if ( freq [ str . charAt ( i ) - ' a ' ] % 2 == 1 ) { System . out . print ( str . charAt ( i ) ) ; } } }
Ref: 
def printChar ( str_ , n ) : NEW_LINE INDENT freq = [ 0 ] * 26 NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ ord ( str_ [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( freq [ ord ( str_ [ i ] ) - ord ( ' a ' ) ] ) % 2 == 1 : NEW_LINE INDENT print ( " { } " . format ( str_ [ i ] ) , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
Hyp: 
def printChar ( str , n ) : NEW_LINE INDENT freq = [ 0 ] * 26 ; NEW_LINE for x in str : NEW_LINE INDENT freq [ ord ( x ) - ord ( ' a ' ) ] = ( freq [ ord ( x ) - ord ( ' a ' ) ] ) + 1 ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( freq [ ord ( x ) - ord ( ' a ' ) ] % 2 == 1 ) : NEW_LINE INDENT print ( str [ i ] , end = " " ) ; NEW_LINE DEDENT DEDENT DEDENT

BLEU: 60.71
Edit Sim: 93


Src: 
void minCost ( String str , int a , int b ) { int openUnbalanced = 0 ; int closedUnbalanced = 0 ; int openCount = 0 ; int closedCount = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) == ' ( ' ) { openUnbalanced ++ ; openCount ++ ; } else { if ( openUnbalanced == 0 ) closedUnbalanced ++ ; else openUnbalanced -- ; closedCount ++ ; } } int result = a * ( Math . abs ( openCount - closedCount ) ) ; if ( closedCount > openCount ) closedUnbalanced -= ( closedCount - openCount ) ; if ( openCount > closedCount ) openUnbalanced -= ( openCount - closedCount ) ; result += Math . min ( a * ( openUnbalanced + closedUnbalanced ) , b * closedUnbalanced ) ; System . out . print ( result + "NEW_LINE"); }
Ref: 
def minCost ( str , a , b ) : NEW_LINE INDENT openUnbalanced = 0 ; NEW_LINE closedUnbalanced = 0 ; NEW_LINE openCount = 0 ; NEW_LINE closedCount = 0 ; NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] == ' ( ' ) : NEW_LINE INDENT openUnbalanced += 1 ; NEW_LINE openCount += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT if ( openUnbalanced == 0 ) : NEW_LINE INDENT closedUnbalanced += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT openUnbalanced -= 1 ; NEW_LINE DEDENT closedCount += 1 ; NEW_LINE DEDENT DEDENT result = a * ( abs ( openCount - closedCount ) ) ; NEW_LINE if ( closedCount > openCount ) : NEW_LINE INDENT closedUnbalanced -= ( closedCount - openCount ) ; NEW_LINE DEDENT if ( openCount > closedCount ) : NEW_LINE INDENT openUnbalanced -= ( openCount - closedCount ) ; NEW_LINE DEDENT result += min ( a * ( openUnbalanced + closedUnbalanced ) , b * closedUnbalanced ) ; NEW_LINE print ( result ) ; NEW_LINE DEDENT
Hyp: 
def minCost ( str , a , b ) : NEW_LINE INDENT openUnbalanced = 0 NEW_LINE closedUnbalanced = 0 NEW_LINE openCount = 0 NEW_LINE closedCount = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] == ' ( ' ) : NEW_LINE INDENT openUnbalanced += 1 NEW_LINE openCount += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( openUnbalanced == 0 ) : NEW_LINE INDENT closedUnbalanced += 1 NEW_LINE else : NEW_LINE INDENT openUnbalanced -= 1 NEW_LINE DEDENT closedCount += 1 NEW_LINE DEDENT DEDENT result = a * ( abs ( openCount - closedCount ) ) NEW_LINE if ( closedCount > openCount ) : NEW_LINE INDENT closedUnbalanced -= ( closedCount - openCount ) NEW_LINE DEDENT if ( openCount > closedCount ) : NEW_LINE INDENT openUnbalanced -= ( openCount - closedCount ) NEW_LINE DEDENT result += min ( a * ( openUnbalanced + closedUnbalanced ) , b * closedUnbalanced ) NEW_LINE DEDENT print ( result ) NEW_LINE DEDENT

BLEU: 79.04
Edit Sim: 42


Src: 
int minimal ( int a [ ] , int n ) { int lo = 0 , hi = n - 1 ; while ( lo < hi ) { int mid = ( lo + hi ) >> 1 ; if ( a [ mid ] < a [ mid + 1 ] ) { hi = mid ; } else { lo = mid + 1 ; } } return lo ; }
Ref: 
def minimal ( a , n ) : NEW_LINE INDENT lo , hi = 0 , n - 1 NEW_LINE while lo < hi : NEW_LINE INDENT mid = ( lo + hi ) // 2 NEW_LINE if a [ mid ] < a [ mid + 1 ] : NEW_LINE INDENT hi = mid NEW_LINE DEDENT else : NEW_LINE INDENT lo = mid + 1 NEW_LINE DEDENT return lo NEW_LINE return lo NEW_LINE DEDENT DEDENT
Hyp: 
def minimal ( a , n ) : NEW_LINE INDENT lo = 0 NEW_LINE hi = n - 1 NEW_LINE while ( lo < hi ) : NEW_LINE INDENT mid = ( lo + hi ) >> 1 NEW_LINE if ( a [ mid ] < a [ mid + 1 ] ) : NEW_LINE INDENT hi = mid NEW_LINE DEDENT else : NEW_LINE INDENT lo = mid + 1 NEW_LINE DEDENT DEDENT return lo NEW_LINE DEDENT

BLEU: 73.65
Edit Sim: 48


Src: 
int countSum ( int a [ ] , int n , int sum ) { int i , j , k , l ; int count = 0 ; for ( i = 0 ; i < n - 3 ; i ++ ) { for ( j = i + 1 ; j < n - 2 ; j ++ ) { for ( k = j + 1 ; k < n - 1 ; k ++ ) { for ( l = k + 1 ; l < n ; l ++ ) { if ( a [ i ] + a [ j ] + a [ k ] + a [ l ] == sum ) count ++ ; } } } } return count ; }
Ref: 
def countSum ( a , n , sum ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n - 3 ) : NEW_LINE INDENT for j in range ( i + 1 , n - 2 ) : NEW_LINE INDENT for k in range ( j + 1 , n - 1 ) : NEW_LINE INDENT for l in range ( k + 1 , n ) : NEW_LINE INDENT if ( a [ i ] + a [ j ] + a [ k ] + a [ l ] == sum ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
Hyp: 
def countSum ( a , n , sum ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n - 3 ) : NEW_LINE INDENT for j in range ( i + 1 , n - 2 , 1 ) : NEW_LINE INDENT for k in range ( j + 1 , n - 1 ) : NEW_LINE INDENT for l in range ( k + 1 , n ) : NEW_LINE INDENT if ( a [ i ] + a [ j ] + a [ k ] + a [ l ] == sum ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return count NEW_LINE DEDENT

BLEU: 96.93
Edit Sim: 11


Src: 
void count_unique ( HashSet < Integer > s , int n ) { if ( s . contains ( n ) ) return ; s . add ( n ) ; n += 1 ; while ( n % 10 == 0 ) { n = n / 10 ; } count_unique ( s , n ) ; }
Ref: 
def count_unique ( s , n ) : NEW_LINE INDENT if ( s . count ( n ) ) : NEW_LINE INDENT return ; NEW_LINE DEDENT s . append ( n ) ; NEW_LINE n += 1 ; NEW_LINE while ( n % 10 == 0 ) : NEW_LINE INDENT n = n // 10 ; NEW_LINE DEDENT count_unique ( s , n ) ; NEW_LINE DEDENT
Hyp: 
def count_unique ( s , n ) : NEW_LINE INDENT if n in s : NEW_LINE INDENT return NEW_LINE DEDENT s . add ( n ) NEW_LINE n += 1 NEW_LINE while n % 10 == 0 : NEW_LINE INDENT n = n // 10 NEW_LINE DEDENT count_unique ( s , n ) NEW_LINE DEDENT s = [ ] NEW_LINE n = sum ( s ) NEW_LINE if n in s : NEW_LINE INDENT print ( n , end = ' ▁ ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n , end = ' ▁ ' ) NEW_LINE DEDENT

BLEU: 37.39
Edit Sim: 205


Src: 
int totalCombination ( int L , int R ) { int count = 0 ; int K = R - L ; if ( K < L ) return 0 ; int ans = K - L ; count = ( ( ans + 1 ) * ( ans + 2 ) ) / 2 ; return count ; }
Ref: 
def totalCombination ( L , R ) : NEW_LINE INDENT count = 0 NEW_LINE K = R - L NEW_LINE if ( K < L ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = K - L NEW_LINE count = ( ( ans + 1 ) * ( ans + 2 ) ) // 2 NEW_LINE return count NEW_LINE DEDENT
Hyp: 
def totalCombination ( L , R ) : NEW_LINE INDENT count = 0 NEW_LINE K = R - L NEW_LINE if ( K < L ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = K - L NEW_LINE count = ( ( ans + 1 ) * ( ans + 2 ) ) // 2 NEW_LINE return count NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
long spellsCount ( String num ) { int n = num . length ( ) ; long result = 1 ; for ( int i = 0 ; i < n ; i ++ ) { int count = 1 ; while ( i < n - 1 && num . charAt ( i + 1 ) == num . charAt ( i ) ) { count ++ ; i ++ ; } result = result * ( long ) Math . pow ( 2 , count - 1 ) ; } return result ; }
Ref: 
def spellsCount ( num ) : NEW_LINE INDENT n = len ( num ) ; NEW_LINE result = 1 ; NEW_LINE i = 0 ; NEW_LINE while ( i < n ) : NEW_LINE INDENT count = 1 ; NEW_LINE while ( i < n - 1 and num [ i + 1 ] == num [ i ] ) : NEW_LINE INDENT count += 1 ; NEW_LINE i += 1 ; NEW_LINE DEDENT result = result * int ( pow ( 2 , count - 1 ) ) ; NEW_LINE i += 1 ; NEW_LINE DEDENT return result ; NEW_LINE DEDENT
Hyp: 
def spellsCount ( num ) : NEW_LINE INDENT n = len ( num ) NEW_LINE result = 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT count = 1 NEW_LINE while ( i < n - 1 and num [ i + 1 ] == num [ i ] ) : NEW_LINE INDENT count += 1 NEW_LINE i += 1 NEW_LINE DEDENT result = result * pow ( 2 , count - 1 ) NEW_LINE DEDENT return result NEW_LINE DEDENT

BLEU: 62.81
Edit Sim: 60


Src: 
long getSum ( int n ) { long sum = 0 ; int k = ( int ) Math . sqrt ( n ) ; for ( int i = 1 ; i <= k ; i ++ ) { sum += Math . floor ( n / i ) ; } sum *= 2 ; sum -= Math . pow ( k , 2 ) ; return sum ; }
Ref: 
def getSum ( n ) : NEW_LINE INDENT summ = 0 NEW_LINE k = ( n ) ** ( .5 ) NEW_LINE for i in range ( 1 , floor ( k ) + 1 ) : NEW_LINE INDENT summ += floor ( n / i ) NEW_LINE DEDENT summ *= 2 NEW_LINE summ -= pow ( floor ( k ) , 2 ) NEW_LINE return summ NEW_LINE DEDENT
Hyp: 
def getSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE k = int ( math . sqrt ( n ) ) NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT sum += math . floor ( n / i ) NEW_LINE DEDENT sum *= 2 NEW_LINE sum -= pow ( k , 2 ) NEW_LINE return sum NEW_LINE DEDENT

BLEU: 54.8
Edit Sim: 48


Src: 
void alternateSubarray ( boolean arr [ ] , int n ) { int len [ ] = new int [ n ] ; len [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; -- i ) { if ( arr [ i ] ^ arr [ i + 1 ] == true ) len [ i ] = len [ i + 1 ] + 1 ; else len [ i ] = 1 ; } for ( int i = 0 ; i < n ; ++ i ) System . out . print ( len [ i ] + " ▁ " ) ; }
Ref: 
def alternateSubarray ( arr , n ) : NEW_LINE INDENT len = [ ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT len . append ( 0 ) NEW_LINE DEDENT len [ n - 1 ] = 1 NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] ^ arr [ i + 1 ] == True ) : NEW_LINE INDENT len [ i ] = len [ i + 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT len [ i ] = 1 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( len [ i ] , " ▁ " , end = " " ) NEW_LINE DEDENT DEDENT
Hyp: 
def alternateSubarray ( arr , n ) : NEW_LINE INDENT len = [ None ] * n NEW_LINE len [ n - 1 ] = 1 NEW_LINE i = n - 2 NEW_LINE while i >= 0 : NEW_LINE INDENT if ( arr [ i ] ^ arr [ i + 1 ] == True ) : NEW_LINE INDENT len [ i ] = len [ i + 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT len [ i ] = 1 ; NEW_LINE DEDENT i = i - 1 NEW_LINE DEDENT i = 0 NEW_LINE while i < n : NEW_LINE INDENT print ( len [ i ] , end = " ▁ " ) NEW_LINE i = i + 1 NEW_LINE DEDENT DEDENT

BLEU: 62.56
Edit Sim: 156


Src: 
int findMinSwaps ( String s , int k ) { int ans = 0 ; int c_one = 0 , c_zero = 0 ; for ( int i = s . length ( ) - 1 ; i >= 0 ; i -- ) { if ( s . charAt ( i ) == '1' ) c_one ++ ; if ( s . charAt ( i ) == '0' ) { c_zero ++ ; ans += c_one ; } if ( c_zero == k ) break ; } if ( c_zero < k ) return - 1 ; return ans ; }
Ref: 
def findMinSwaps ( s , k ) : NEW_LINE INDENT ans = 0 ; NEW_LINE c_one = 0 ; c_zero = 0 ; NEW_LINE for i in range ( len ( s ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT c_one += 1 ; NEW_LINE DEDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT c_zero += 1 ; NEW_LINE ans += c_one ; NEW_LINE DEDENT if ( c_zero == k ) : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT if ( c_zero < k ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT
Hyp: 
def findMinSwaps ( s , k ) : NEW_LINE INDENT ans = 0 ; NEW_LINE c_one = 0 ; NEW_LINE c_zero = 0 ; NEW_LINE for i in range ( len ( s ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT c_one += 1 ; NEW_LINE DEDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT c_zero += 1 ; NEW_LINE ans += c_one ; NEW_LINE DEDENT if ( c_zero == k ) : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT if ( c_zero < k ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT

BLEU: 97.91
Edit Sim: 9


Src: 
void findPairs ( int arr1 [ ] , int arr2 [ ] , int n , int m , int x ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( arr1 [ i ] + arr2 [ j ] == x ) System . out . println ( arr1 [ i ] + " ▁ " + arr2 [ j ] ) ; }
Ref: 
def findPairs ( arr1 , arr2 , n , m , x ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , m ) : NEW_LINE INDENT if ( arr1 [ i ] + arr2 [ j ] == x ) : NEW_LINE INDENT print ( arr1 [ i ] , arr2 [ j ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
Hyp: 
def findPairs ( arr1 , arr2 , n , m , x ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( arr1 [ i ] + arr2 [ j ] == x ) : NEW_LINE INDENT print ( arr1 [ i ] , " ▁ " , arr2 [ j ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT

BLEU: 89.6
Edit Sim: 16


Src: 
int maxSum ( int [ ] [ ] mat , int n ) { if ( n == 1 ) return mat [ 0 ] [ 0 ] ; int dp [ ] [ ] = new int [ n ] [ n ] ; int maxSum = Integer . MIN_VALUE , max ; for ( int j = 0 ; j < n ; j ++ ) dp [ n - 1 ] [ j ] = mat [ n - 1 ] [ j ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < n ; j ++ ) { max = Integer . MIN_VALUE ; if ( ( ( j - 1 ) >= 0 ) && ( max < dp [ i + 1 ] [ j - 1 ] ) ) max = dp [ i + 1 ] [ j - 1 ] ; if ( ( ( j + 1 ) < n ) && ( max < dp [ i + 1 ] [ j + 1 ] ) ) max = dp [ i + 1 ] [ j + 1 ] ; dp [ i ] [ j ] = mat [ i ] [ j ] + max ; } } for ( int j = 0 ; j < n ; j ++ ) if ( maxSum < dp [ 0 ] [ j ] ) maxSum = dp [ 0 ] [ j ] ; return maxSum ; }
Ref: 
def maxSum ( mat , n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return mat [ 0 ] [ 0 ] NEW_LINE DEDENT dp = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] NEW_LINE maxSum = INT_MIN NEW_LINE for j in range ( n ) : NEW_LINE INDENT dp [ n - 1 ] [ j ] = mat [ n - 1 ] [ j ] NEW_LINE DEDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT maxi = INT_MIN NEW_LINE if ( ( ( ( j - 1 ) >= 0 ) and ( maxi < dp [ i + 1 ] [ j - 1 ] ) ) ) : NEW_LINE INDENT maxi = dp [ i + 1 ] [ j - 1 ] NEW_LINE DEDENT if ( ( ( ( j + 1 ) < n ) and ( maxi < dp [ i + 1 ] [ j + 1 ] ) ) ) : NEW_LINE INDENT maxi = dp [ i + 1 ] [ j + 1 ] NEW_LINE DEDENT dp [ i ] [ j ] = mat [ i ] [ j ] + maxi NEW_LINE DEDENT DEDENT for j in range ( n ) : NEW_LINE INDENT if ( maxSum < dp [ 0 ] [ j ] ) : NEW_LINE INDENT maxSum = dp [ 0 ] [ j ] NEW_LINE DEDENT DEDENT return maxSum NEW_LINE DEDENT
Hyp: 
def maxSum ( mat , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return mat [ 0 ] [ 0 ] NEW_LINE DEDENT dp = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] NEW_LINE maxSum = INT_MIN ; NEW_LINE for x in range ( n - 1 ) : NEW_LINE INDENT dp [ n - 1 ] [ j ] = mat [ n - 1 ] [ j ] NEW_LINE DEDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT max = INT_MIN ; NEW_LINE if ( ( j - 1 ) >= 0 ) and ( max < dp [ i + 1 ] [ j - 1 ] ) ) : NEW_LINE INDENT max = dp [ i + 1 ] [ j - 1 ] NEW_LINE DEDENT if ( ( j + 1 ) < n ) and ( max < dp [ i + 1 ] [ j + 1 ] ) ) : NEW_LINE INDENT max = dp [ i + 1 ] [ j + 1 ] NEW_LINE DEDENT dp [ i ] [ j ] = mat [ i ] [ j ] + max ; NEW_LINE DEDENT DEDENT for j in range ( n ) : NEW_LINE INDENT if ( maxSum < dp [ 0 ] [ j ] ) : NEW_LINE INDENT maxSum = dp [ 0 ] [ j ] NEW_LINE DEDENT DEDENT return maxSum ; NEW_LINE DEDENT

BLEU: 85.42
Edit Sim: 36


Src: 
int countDigit ( int n ) { int temp = n , count = 0 ; while ( temp != 0 ) { int d = temp % 10 ; temp /= 10 ; if ( d > 0 && n % d == 0 ) count ++ ; } return count ; }
Ref: 
def countDigit ( n ) : NEW_LINE INDENT temp = n NEW_LINE count = 0 NEW_LINE while temp != 0 : NEW_LINE INDENT d = temp % 10 NEW_LINE temp //= 10 NEW_LINE if d > 0 and n % d == 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
Hyp: 
def countDigit ( n ) : NEW_LINE INDENT temp = n NEW_LINE count = 0 NEW_LINE while ( temp != 0 ) : NEW_LINE INDENT d = temp % 10 NEW_LINE temp //= 10 NEW_LINE if ( d > 0 and n % d == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT

BLEU: 82.67
Edit Sim: 8


Src: 
int countDivisors ( int n , int k ) { int count = 0 , i ; for ( i = 1 ; i <= n ; i ++ ) { if ( n % i == 0 && i % k == 0 ) { count ++ ; } } return count ; }
Ref: 
def countDivisors ( n , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( n % i == 0 and i % k == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
Hyp: 
def countDivisors ( n , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( n % i == 0 and i % k == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int remainingArea ( int N , int M , int K ) { while ( K -- > 0 && N > 0 && M > 0 ) { if ( N > M ) N = N - M ; else M = M - N ; } if ( N > 0 && M > 0 ) return N * M ; else return 0 ; }
Ref: 
def remainingArea ( N , M , K ) : NEW_LINE INDENT while ( K > 0 and N > 0 and M > 0 ) : NEW_LINE INDENT if ( N > M ) : NEW_LINE INDENT N = N - M ; NEW_LINE DEDENT else : NEW_LINE INDENT M = M - N ; NEW_LINE DEDENT K = K - 1 ; NEW_LINE DEDENT if ( N > 0 and M > 0 ) : NEW_LINE INDENT return N * M ; NEW_LINE DEDENT else : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT DEDENT
Hyp: 
def remainingArea ( N , M , K ) : NEW_LINE INDENT while ( K > 0 and N > 0 and M > 0 ) : NEW_LINE INDENT if ( N > M ) : NEW_LINE INDENT N = N - M NEW_LINE DEDENT else : NEW_LINE INDENT M = M - N NEW_LINE DEDENT DEDENT if ( N > 0 and M > 0 ) : NEW_LINE INDENT return N * M NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT

BLEU: 80.06
Edit Sim: 29


Src: 
int lastDigit2PowerN ( int n ) { if ( n == 0 ) return 1 ; else if ( n % 4 == 1 ) return 2 ; else if ( n % 4 == 2 ) return 4 ; else if ( n % 4 == 3 ) return 8 ; else }
Ref: 
def lastDigit2PowerN ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif n % 4 == 1 : NEW_LINE INDENT return 2 NEW_LINE DEDENT elif n % 4 == 2 : NEW_LINE INDENT return 4 NEW_LINE DEDENT elif n % 4 == 3 : NEW_LINE INDENT return 8 NEW_LINE DEDENT else : NEW_LINE DEDENT for n in range ( 20 ) : NEW_LINE INDENT print ( lastDigit2PowerN ( n ) , end = " ▁ " ) NEW_LINE DEDENT
Hyp: 
def lastDigit2PowerN ( n ) : NEW_LINE INDENT if ( n == 0 ) : return 1 NEW_LINE elif ( n % 4 == 1 ) : return 2 NEW_LINE elif ( n % 4 == 2 ) : return 4 NEW_LINE elif ( n % 4 == 3 ) : return 8 NEW_LINE DEDENT else : NEW_LINE INDENT return 9 NEW_LINE DEDENT DEDENT

BLEU: 36.62
Edit Sim: 171


Src: 
void findLarger ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; for ( int i = n - 1 ; i >= n / 2 ; i -- ) System . out . print ( arr [ i ] + " ▁ " ) ; }
Ref: 
def findLarger ( arr , n ) : NEW_LINE INDENT x = sorted ( arr ) NEW_LINE for i in range ( n / 2 , n ) : NEW_LINE INDENT print ( x [ i ] ) , NEW_LINE DEDENT DEDENT
Hyp: 
def findLarger ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE for i in range ( n - 1 , n // 2 , - 1 ) : NEW_LINE INDENT print ( str ( arr [ i ] ) , end = " ▁ " ) NEW_LINE DEDENT DEDENT

BLEU: 49.73
Edit Sim: 45


Src: 
void shortestLength ( int n , int x [ ] , int y [ ] ) { int answer = 0 ; int i = 0 ; while ( n != 0 && i < x . length ) { if ( x [ i ] + y [ i ] > answer ) answer = x [ i ] + y [ i ] ; i ++ ; } System . out . println ( " Length ▁ - > ▁ " + answer ) ; System . out . println ( " Path ▁ - > ▁ " + " ( ▁ 1 , ▁ " + answer + " ▁ ) " + " and ▁ ( ▁ " + answer + " , ▁ 1 ▁ ) " ) ; }
Ref: 
def shortestLength ( n , x , y ) : NEW_LINE INDENT answer = 0 NEW_LINE i = 0 NEW_LINE while n > 0 : NEW_LINE INDENT if ( x [ i ] + y [ i ] > answer ) : NEW_LINE INDENT answer = x [ i ] + y [ i ] NEW_LINE DEDENT i += 1 NEW_LINE n -= 1 NEW_LINE DEDENT print ( " Length ▁ - > ▁ " + str ( answer ) ) NEW_LINE print ( " Path ▁ - > ▁ " + " ( ▁ 1 , ▁ " + str ( answer ) + " ▁ ) " + " and ▁ ( ▁ " + str ( answer ) + " , ▁ 1 ▁ ) " ) NEW_LINE DEDENT
Hyp: 
def shortestLength ( n , x , y ) : NEW_LINE INDENT answer = 0 NEW_LINE i = 0 NEW_LINE while ( n != 0 and i < len ( x ) ) : NEW_LINE INDENT if ( x [ i ] + y [ i ] > answer ) : NEW_LINE INDENT answer = x [ i ] + y [ i ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print ( " Length ▁ - > " , answer ) NEW_LINE print ( " Path ▁ - > " , " ( ▁ 1 , ▁ " , answer , " ▁ ) " , " and ▁ ( ▁ " , answer , " , ▁ 1 ▁ ) " ) NEW_LINE DEDENT

BLEU: 71.98
Edit Sim: 75


Src: 
void findScoreSum ( int n ) { int F = n / 7 ; int D = n % 7 ; int fullWeekScore = ( 49 + 7 * F ) * F / 2 ; int lastNonFullWeekScore = ( 2 * F + D + 1 ) * D / 2 ; System . out . println ( fullWeekScore + lastNonFullWeekScore ) ; }
Ref: 
def findScoreSum ( n ) : NEW_LINE INDENT F = n // 7 NEW_LINE D = n % 7 NEW_LINE fullWeekScore = ( 49 + 7 * F ) * F // 2 NEW_LINE lastNonFullWeekScore = ( 2 * F + D + 1 ) * D // 2 NEW_LINE print ( fullWeekScore + lastNonFullWeekScore ) NEW_LINE DEDENT
Hyp: 
def findScoreSum ( n ) : NEW_LINE INDENT F = n // 7 NEW_LINE D = n % 7 NEW_LINE fullWeekScore = ( 49 + 7 * F ) * F / 2 NEW_LINE lastNonFullWeekScore = ( 2 * F + D + 1 ) * D / 2 NEW_LINE print ( fullWeekScore + lastNonFullWeekScore ) NEW_LINE DEDENT

BLEU: 91.13
Edit Sim: 2


Src: 
String printDemlo ( String str ) { int len = str . length ( ) ; String res = " " ; for ( int i = 1 ; i <= len ; i ++ ) res += Integer . toString ( i ) ; for ( int i = len - 1 ; i >= 1 ; i -- ) res += Integer . toString ( i ) ; return res ; }
Ref: 
def printDemlo ( s ) : NEW_LINE INDENT l = len ( s ) NEW_LINE res = " " NEW_LINE for i in range ( 1 , l + 1 ) : NEW_LINE INDENT res = res + str ( i ) NEW_LINE DEDENT for i in range ( l - 1 , 0 , - 1 ) : NEW_LINE INDENT res = res + str ( i ) NEW_LINE DEDENT return res NEW_LINE DEDENT
Hyp: 
def printDemlo ( str ) : NEW_LINE INDENT ln = len ( str ) NEW_LINE res = " " NEW_LINE for i in range ( 1 , ln + 1 ) : NEW_LINE INDENT res += str [ i ] NEW_LINE DEDENT for i in range ( len - 1 , - 1 , - 1 ) : NEW_LINE INDENT res += str [ i ] NEW_LINE DEDENT return res NEW_LINE DEDENT

BLEU: 56.33
Edit Sim: 29


Src: 
int countGroups ( int position , int previous_sum , int length , char [ ] num ) { if ( position == length ) return 1 ; if ( dp [ position ] [ previous_sum ] != - 1 ) return dp [ position ] [ previous_sum ] ; dp [ position ] [ previous_sum ] = 0 ; int res = 0 ; int sum = 0 ; for ( int i = position ; i < length ; i ++ ) { sum += ( num [ i ] - '0' ) ; if ( sum >= previous_sum ) res += countGroups ( i + 1 , sum , length , num ) ; } dp [ position ] [ previous_sum ] = res ; return res ; }
Ref: 
def countGroups ( position , previous_sum , length , num ) : NEW_LINE INDENT if ( position == length ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( dp [ position ] [ previous_sum ] != - 1 ) : NEW_LINE INDENT return dp [ position ] [ previous_sum ] NEW_LINE DEDENT dp [ position ] [ previous_sum ] = 0 NEW_LINE res = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( position , length ) : NEW_LINE INDENT sum += ( ord ( num [ i ] ) - ord ( '0' ) ) NEW_LINE if ( sum >= previous_sum ) : NEW_LINE INDENT res += countGroups ( i + 1 , sum , length , num ) NEW_LINE DEDENT DEDENT dp [ position ] [ previous_sum ] = res NEW_LINE return res NEW_LINE DEDENT
Hyp: 
def countGroups ( position , previous_sum , length , num ) : NEW_LINE INDENT if ( position == length ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( dp [ position ] [ previous_sum ] != - 1 ) : NEW_LINE INDENT return dp [ position ] [ previous_sum ] NEW_LINE DEDENT dp [ position ] [ previous_sum ] = 0 NEW_LINE res = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( position , length ) : NEW_LINE INDENT sum += ( num [ i ] - ord ( '0' ) ) NEW_LINE if ( sum >= previous_sum ) : NEW_LINE INDENT res += countGroups ( i + 1 , sum , length , num ) NEW_LINE DEDENT dp [ position ] [ previous_sum ] = res NEW_LINE return res NEW_LINE DEDENT

BLEU: 94.91
Edit Sim: 15


Src: 
float sqroot ( float s ) { int pSq = 0 ; int N = 0 ; for ( int i = ( int ) ( s ) ; i > 0 ; i -- ) { for ( int j = 1 ; j < i ; j ++ ) { if ( j * j == i ) { pSq = i ; N = j ; break ; } } if ( pSq > 0 ) break ; } float d = s - pSq ; float P = d / ( 2.0f * N ) ; float A = N + P ; float sqrt_of_s = A - ( ( P * P ) / ( 2.0f * A ) ) ; return sqrt_of_s ; }
Ref: 
def sqroot ( s ) : NEW_LINE INDENT pSq = 0 ; NEW_LINE N = 0 ; NEW_LINE for i in range ( int ( s ) , 0 , - 1 ) : NEW_LINE INDENT for j in range ( 1 , i ) : NEW_LINE INDENT if ( j * j == i ) : NEW_LINE INDENT pSq = i ; NEW_LINE N = j ; NEW_LINE break ; NEW_LINE DEDENT DEDENT if ( pSq > 0 ) : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT DEDENT d = s - pSq ; NEW_LINE P = d / ( 2.0 * N ) ; NEW_LINE A = N + P ; NEW_LINE INDENT sqrt_of_s = A - ( ( P * P ) / ( 2.0 * A ) ) ; NEW_LINE return sqrt_of_s ; NEW_LINE DEDENT
Hyp: 
def sqroot ( s ) : NEW_LINE INDENT pSq = 0 NEW_LINE N = 0 NEW_LINE for i in range ( 0 , int ( s ) ) : NEW_LINE INDENT for j in range ( 1 , i ) : NEW_LINE INDENT if ( j * j == i ) : NEW_LINE INDENT pSq = i NEW_LINE N = j NEW_LINE break NEW_LINE DEDENT DEDENT if ( pSq > 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT d = s - pSq NEW_LINE P = d / ( 2.0f * N ) NEW_LINE A = N + P NEW_LINE sqrt_of_s = A - ( ( P * P ) / ( 2.0f * A ) ) NEW_LINE return sqrt_of_s NEW_LINE DEDENT

BLEU: 66.68
Edit Sim: 59


Src: 
void movesRequired ( int a , int b ) { int total_moves = a % b ; System . out . println ( total_moves ) ; }
Ref: 
def movesRequired ( a , b ) : NEW_LINE INDENT total_moves = a % b NEW_LINE print ( total_moves ) NEW_LINE DEDENT
Hyp: 
def movesRequired ( a , b ) : NEW_LINE INDENT total_moves = a % b NEW_LINE print ( total_moves ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int minimumflip ( int mat [ ] [ ] , int n ) { int flip = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) flip ++ ; return flip ; }
Ref: 
def minimumflip ( mat , n ) : NEW_LINE INDENT flip = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if mat [ i ] [ j ] != mat [ j ] [ i ] : NEW_LINE INDENT flip += 1 NEW_LINE DEDENT DEDENT DEDENT return flip NEW_LINE DEDENT
Hyp: 
def minimumflip ( mat , n ) : NEW_LINE INDENT flip = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) : NEW_LINE INDENT flip += 1 NEW_LINE DEDENT DEDENT DEDENT return flip NEW_LINE DEDENT

BLEU: 92.24
Edit Sim: 4


Src: 
int findgroups ( int arr [ ] , int n ) { int c [ ] = new int [ ] { 0 , 0 , 0 } ; int i ; int res = 0 ; for ( i = 0 ; i < n ; i ++ ) c [ arr [ i ] % 3 ] ++ ; res += ( ( c [ 0 ] * ( c [ 0 ] - 1 ) ) >> 1 ) ; res += c [ 1 ] * c [ 2 ] ; res += ( c [ 0 ] * ( c [ 0 ] - 1 ) * ( c [ 0 ] - 2 ) ) / 6 ; res += ( c [ 1 ] * ( c [ 1 ] - 1 ) * ( c [ 1 ] - 2 ) ) / 6 ; res += ( ( c [ 2 ] * ( c [ 2 ] - 1 ) * ( c [ 2 ] - 2 ) ) / 6 ) ; res += c [ 0 ] * c [ 1 ] * c [ 2 ] ; return res ; }
Ref: 
def findgroups ( arr , n ) : NEW_LINE INDENT c = [ 0 , 0 , 0 ] NEW_LINE res = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT c [ arr [ i ] % 3 ] += 1 NEW_LINE DEDENT res += ( ( c [ 0 ] * ( c [ 0 ] - 1 ) ) >> 1 ) NEW_LINE res += c [ 1 ] * c [ 2 ] NEW_LINE res += ( c [ 0 ] * ( c [ 0 ] - 1 ) * ( c [ 0 ] - 2 ) ) / 6 NEW_LINE res += ( c [ 1 ] * ( c [ 1 ] - 1 ) * ( c [ 1 ] - 2 ) ) / 6 NEW_LINE res += ( ( c [ 2 ] * ( c [ 2 ] - 1 ) * ( c [ 2 ] - 2 ) ) / 6 ) NEW_LINE res += c [ 0 ] * c [ 1 ] * c [ 2 ] NEW_LINE return res NEW_LINE DEDENT
Hyp: 
def findgroups ( arr , n ) : NEW_LINE INDENT c = [ 0 , 0 , 0 ] NEW_LINE res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT c [ arr [ i ] % 3 ] += 1 NEW_LINE DEDENT res += ( ( c [ 0 ] * ( c [ 0 ] - 1 ) ) >> 1 NEW_LINE res += c [ 1 ] * c [ 2 ] NEW_LINE res += ( ( c [ 0 ] * ( c [ 0 ] - 1 ) * ( c [ 0 ] - 2 ) ) // 6 NEW_LINE res += ( c [ 1 ] * ( c [ 1 ] - 2 ) ) // 6 NEW_LINE res += ( ( c [ 2 ] * ( c [ 2 ] - 1 ) * ( c [ 2 ] - 2 ) ) // 6 NEW_LINE res += ( ( c [ 0 ] * ( c [ 0 ] - 1 ) * ( c [ 1 ] - 2 ) ) // 6 NEW_LINE DEDENT res += ( ( c [ 0 ] * ( c [ 1 ] - 2 ) ) // 6 NEW_LINE res += ( c [ 2 ] * ( c [ 2 ] - 1 ) * ( c [ 2 ] - 2 ) ) // 6 NEW_LINE DEDENT res += c [ 0 ] * c [ 1 ] * c [ 2 ] NEW_LINE return res NEW_LINE DEDENT

BLEU: 67.63
Edit Sim: 201


Src: 
int countWays ( int n , int m ) { int count [ ] = new int [ n + 1 ] ; count [ 0 ] = 0 ; int i ; for ( i = 1 ; i <= n ; i ++ ) { if ( i > m ) count [ i ] = count [ i - 1 ] + count [ i - m ] ; else if ( i < m i == 1 ) count [ i ] = 1 ; else count [ i ] = 2 ; } return count [ n ] ; }
Ref: 
def countWays ( n , m ) : NEW_LINE INDENT count = [ ] NEW_LINE for i in range ( n + 2 ) : NEW_LINE INDENT count . append ( 0 ) NEW_LINE DEDENT count [ 0 ] = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( i > m ) : NEW_LINE INDENT count [ i ] = count [ i - 1 ] + count [ i - m ] NEW_LINE DEDENT elif ( i < m or i == 1 ) : NEW_LINE INDENT count [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT count [ i ] = 2 NEW_LINE DEDENT DEDENT return count [ n ] NEW_LINE DEDENT
Hyp: 
def countWays ( n , m ) : NEW_LINE INDENT count = [ 0 ] * ( n + 1 ) NEW_LINE count [ 0 ] = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( i > m ) : NEW_LINE INDENT count [ i ] = count [ i - 1 ] + count [ i - m ] NEW_LINE DEDENT elif ( i < m or i == 1 ) : NEW_LINE INDENT count [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT count [ i ] = 2 NEW_LINE DEDENT DEDENT return count [ n ] NEW_LINE DEDENT

BLEU: 82.91
Edit Sim: 70


Src: 
void findValues ( int a , int b ) { if ( ( a - b ) % 2 == 1 ) { System . out . println ( " - 1" ) ; return ; } System . out . println ( ( ( a - b ) / 2 ) + " ▁ " + ( ( a + b ) / 2 ) ) ; }
Ref: 
def findValues ( a , b ) : NEW_LINE INDENT if ( ( a - b ) % 2 == 1 ) : NEW_LINE INDENT print ( " - 1" ) ; NEW_LINE return ; NEW_LINE DEDENT print ( ( a - b ) // 2 , ( a + b ) // 2 ) ; NEW_LINE DEDENT
Hyp: 
def findValues ( a , b ) : NEW_LINE INDENT if ( ( a - b ) % 2 == 1 ) : NEW_LINE INDENT print ( " - 1" ) NEW_LINE return NEW_LINE DEDENT print ( ( ( a - b ) // 2 ) , " ▁ " , ( ( a + b ) // 2 ) ) NEW_LINE DEDENT

BLEU: 76.67
Edit Sim: 19


Src: 
int getMaxDifference ( int N ) { int M = - 1 ; int maxDiff = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int diff = ( N ^ i ) - ( N & i ) ; if ( diff >= maxDiff ) { maxDiff = diff ; M = i ; } } return M ; }
Ref: 
def getMaxDifference ( N ) : NEW_LINE INDENT M = - 1 ; NEW_LINE maxDiff = 0 ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT diff = ( N ^ i ) - ( N & i ) ; NEW_LINE if ( diff >= maxDiff ) : NEW_LINE INDENT maxDiff = diff ; NEW_LINE M = i ; NEW_LINE DEDENT DEDENT return M ; NEW_LINE DEDENT
Hyp: 
def getMaxDifference ( N ) : NEW_LINE INDENT M = - 1 NEW_LINE maxDiff = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT diff = ( N ^ i ) - ( N & i ) NEW_LINE if ( diff >= maxDiff ) : NEW_LINE INDENT maxDiff = diff NEW_LINE M = i NEW_LINE DEDENT DEDENT return M NEW_LINE DEDENT

BLEU: 77.78
Edit Sim: 12


Src: 
int countDigitOne ( int n ) { int countr = 0 ; for ( int i = 1 ; i <= n ; i *= 10 ) { int divider = i * 10 ; countr += ( n / divider ) * i + Math . min ( Math . max ( n % divider - i + 1 , 0 ) , i ) ; } return countr ; }
Ref: 
def countDigitOne ( n ) : NEW_LINE INDENT countr = 0 ; NEW_LINE i = 1 ; NEW_LINE while ( i <= n ) : NEW_LINE INDENT divider = i * 10 ; NEW_LINE countr += ( int ( n / divider ) * i + min ( max ( n % divider - i + 1 , 0 ) , i ) ) ; NEW_LINE i *= 10 ; NEW_LINE DEDENT return countr ; NEW_LINE DEDENT
Hyp: 
def countDigitOne ( n ) : NEW_LINE INDENT countr = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT divider = i * 10 NEW_LINE countr += int ( n / divider ) * i + int ( max ( n % divider - i + 1 , 0 ) , i ) NEW_LINE DEDENT return countr NEW_LINE DEDENT

BLEU: 58.28
Edit Sim: 57


Src: 
int countRotations ( int arr [ ] , int low , int high ) { if ( high < low ) return 0 ; if ( high == low ) return low ; int mid = low + ( high - low ) / 2 ; if ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) return ( mid + 1 ) ; if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) return mid ; if ( arr [ high ] > arr [ mid ] ) return countRotations ( arr , low , mid - 1 ) ; return countRotations ( arr , mid + 1 , high ) ; }
Ref: 
def countRotations ( arr , low , high ) : NEW_LINE INDENT if ( high < low ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( high == low ) : NEW_LINE INDENT return low NEW_LINE DEDENT mid = low + ( high - low ) / 2 ; NEW_LINE mid = int ( mid ) NEW_LINE if ( mid < high and arr [ mid + 1 ] < arr [ mid ] ) : NEW_LINE INDENT return ( mid + 1 ) NEW_LINE DEDENT if ( mid > low and arr [ mid ] < arr [ mid - 1 ] ) : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( arr [ high ] > arr [ mid ] ) : NEW_LINE INDENT return countRotations ( arr , low , mid - 1 ) ; NEW_LINE DEDENT return countRotations ( arr , mid + 1 , high ) NEW_LINE DEDENT
Hyp: 
def countRotations ( arr , low , high ) : NEW_LINE INDENT if ( high < low ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( high == low ) : NEW_LINE INDENT return low NEW_LINE DEDENT mid = low + ( high - low ) // 2 NEW_LINE if ( mid < high and arr [ mid + 1 ] < arr [ mid ] ) : NEW_LINE INDENT return ( mid + 1 ) NEW_LINE DEDENT if ( mid > low and arr [ mid ] < arr [ mid - 1 ] ) : NEW_LINE INDENT return mid NEW_LINE DEDENT if arr [ high ] > arr [ mid ] : NEW_LINE INDENT return countRotations ( arr , low , mid - 1 ) NEW_LINE DEDENT return countRotations ( arr , mid + 1 , high ) NEW_LINE DEDENT

BLEU: 87.64
Edit Sim: 36


Src: 
int addNDigits ( int a , int b , int n ) { int num = a ; for ( int i = 0 ; i <= 9 ; i ++ ) { int tmp = a * 10 + i ; if ( tmp % b == 0 ) { a = tmp ; break ; } } if ( num == a ) return - 1 ; for ( int j = 0 ; j < n - 1 ; j ++ ) a *= 10 ; return a ; }
Ref: 
def addNDigits ( a , b , n ) : NEW_LINE INDENT num = a NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT tmp = a * 10 + i NEW_LINE if ( tmp % b == 0 ) : NEW_LINE INDENT a = tmp NEW_LINE break NEW_LINE DEDENT DEDENT if ( num == a ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT for j in range ( n - 1 ) : NEW_LINE INDENT a *= 10 NEW_LINE DEDENT return a NEW_LINE DEDENT
Hyp: 
def addNDigits ( a , b , n ) : NEW_LINE INDENT num = a NEW_LINE for i in range ( 9 , 1 ) : NEW_LINE INDENT tmp = a * 10 + i NEW_LINE if ( tmp % b == 0 ) : NEW_LINE INDENT a = tmp NEW_LINE break NEW_LINE DEDENT DEDENT if ( num == a ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT for j in range ( n - 1 ) : NEW_LINE INDENT a *= 10 NEW_LINE DEDENT return a NEW_LINE DEDENT

BLEU: 94.95
Edit Sim: 5


Src: 
void maxMin ( int arr [ ] [ ] , int n ) { int min = + 2147483647 ; int max = - 2147483648 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j <= n / 2 ; j ++ ) { if ( arr [ i ] [ j ] > arr [ i ] [ n - j - 1 ] ) { if ( min > arr [ i ] [ n - j - 1 ] ) min = arr [ i ] [ n - j - 1 ] ; if ( max < arr [ i ] [ j ] ) max = arr [ i ] [ j ] ; } else { if ( min > arr [ i ] [ j ] ) min = arr [ i ] [ j ] ; if ( max < arr [ i ] [ n - j - 1 ] ) max = arr [ i ] [ n - j - 1 ] ; } } } System . out . print ( " Maximum ▁ = ▁ " + max + " , ▁ Minimum ▁ = ▁ " + min ) ; }
Ref: 
def MAXMIN ( arr , n ) : NEW_LINE INDENT MIN = 10 ** 9 NEW_LINE MAX = - 10 ** 9 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n // 2 + 1 ) : NEW_LINE INDENT if ( arr [ i ] [ j ] > arr [ i ] [ n - j - 1 ] ) : NEW_LINE INDENT if ( MIN > arr [ i ] [ n - j - 1 ] ) : NEW_LINE INDENT MIN = arr [ i ] [ n - j - 1 ] NEW_LINE DEDENT if ( MAX < arr [ i ] [ j ] ) : NEW_LINE INDENT MAX = arr [ i ] [ j ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( MIN > arr [ i ] [ j ] ) : NEW_LINE INDENT MIN = arr [ i ] [ j ] NEW_LINE DEDENT if ( MAX < arr [ i ] [ n - j - 1 ] ) : NEW_LINE INDENT MAX = arr [ i ] [ n - j - 1 ] NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( " MAXimum ▁ = " , MAX , " , ▁ MINimum ▁ = " , MIN ) NEW_LINE DEDENT
Hyp: 
def maxMin ( arr , n ) : NEW_LINE INDENT min = + 2147483647 NEW_LINE max = - 2147483648 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( int ( n / 2 ) ) : NEW_LINE INDENT if ( arr [ i ] [ j ] > arr [ i ] [ n - j - 1 ] ) : NEW_LINE INDENT if ( min > arr [ i ] [ n - j - 1 ] ) : NEW_LINE INDENT min = arr [ i ] [ n - j - 1 ] NEW_LINE DEDENT if ( max < arr [ i ] [ j ] ) : NEW_LINE INDENT max = arr [ i ] [ j ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( min > arr [ i ] [ j ] ) : NEW_LINE INDENT min = arr [ i ] [ j ] NEW_LINE DEDENT if ( max < arr [ i ] [ n - j - 1 ] ) : NEW_LINE INDENT max = arr [ i ] [ n - j - 1 ] NEW_LINE DEDENT DEDENT DEDENT print ( " Maximum ▁ = " , max , " , ▁ Minimum ▁ = " , min ) NEW_LINE DEDENT

BLEU: 76.69
Edit Sim: 80


Src: 
int Max_Sum ( int arr1 [ ] , int arr2 [ ] , int n ) { int [ ] [ ] dp = new int [ n ] [ 2 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( i == 0 ) { dp [ i ] [ 0 ] = arr1 [ i ] ; dp [ i ] [ 1 ] = arr2 [ i ] ; continue ; } dp [ i ] [ 0 ] = Math . max ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] + arr1 [ i ] ) ; dp [ i ] [ 1 ] = Math . max ( dp [ i - 1 ] [ 1 ] , dp [ i - 1 ] [ 0 ] + arr2 [ i ] ) ; } return Math . max ( dp [ n - 1 ] [ 0 ] , dp [ n - 1 ] [ 1 ] ) ; }
Ref: 
def Max_Sum ( arr1 , arr2 , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( 2 ) ] for j in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = arr1 [ i ] NEW_LINE dp [ i ] [ 1 ] = arr2 [ i ] NEW_LINE continue NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ 0 ] = max ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] + arr1 [ i ] ) NEW_LINE dp [ i ] [ 1 ] = max ( dp [ i - 1 ] [ 1 ] , dp [ i - 1 ] [ 0 ] + arr2 [ i ] ) NEW_LINE DEDENT DEDENT return max ( dp [ n - 1 ] [ 0 ] , dp [ n - 1 ] [ 1 ] ) NEW_LINE DEDENT
Hyp: 
def Max_Sum ( arr1 , arr2 , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( 2 ) ] for j in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = arr1 [ i ] NEW_LINE dp [ i ] [ 1 ] = arr2 [ i ] NEW_LINE continue NEW_LINE DEDENT dp [ i ] [ 0 ] = max ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] + arr1 [ i ] ) NEW_LINE dp [ i ] [ 1 ] = max ( dp [ i - 1 ] [ 1 ] , dp [ i - 1 ] [ 0 ] + arr2 [ i ] ) NEW_LINE DEDENT return max ( dp [ n - 1 ] [ 0 ] , dp [ n - 1 ] [ 1 ] ) NEW_LINE DEDENT

BLEU: 96.03
Edit Sim: 30


Src: 
int xorPairCount ( int arr [ ] , int n , int x ) { Map < Integer , Integer > m = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int curr_xor = x ^ arr [ i ] ; if ( m . containsKey ( curr_xor ) ) result += m . get ( curr_xor ) ; if ( m . containsKey ( arr [ i ] ) ) { m . put ( arr [ i ] , m . get ( arr [ i ] ) + 1 ) ; } else { m . put ( arr [ i ] , 1 ) ; } } return result ; }
Ref: 
def xorPairCount ( arr , n , x ) : NEW_LINE INDENT m = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT curr_xor = x ^ arr [ i ] NEW_LINE if ( curr_xor in m . keys ( ) ) : NEW_LINE INDENT result += m [ curr_xor ] NEW_LINE DEDENT if arr [ i ] in m . keys ( ) : NEW_LINE INDENT m [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT m [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
Hyp: 
def xorPairCount ( arr , n , x ) : NEW_LINE INDENT m = { } NEW_LINE result = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT curr_xor = x ^ arr [ i ] NEW_LINE if ( curr_xor in m ) : NEW_LINE INDENT result += m [ curr_xor ] NEW_LINE DEDENT if ( arr [ i ] in m ) : NEW_LINE INDENT m [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT m [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT

BLEU: 84.42
Edit Sim: 42


Src: 
float cube ( float h , float r ) { if ( h < 0 && r < 0 ) return - 1 ; float a = ( float ) Math . pow ( h , 3 ) ; return a ; }
Ref: 
def cube ( h , r ) : NEW_LINE INDENT if ( h < 0 and r < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT a = math . pow ( h , 3 ) NEW_LINE return a NEW_LINE DEDENT
Hyp: 
def cubeSide ( h , r ) : NEW_LINE INDENT if ( h < 0 and r < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT a = math . pow ( h , 3 ) NEW_LINE return a NEW_LINE DEDENT

BLEU: 95.85
Edit Sim: 4


Src: 
int maxOR ( int arr [ ] , int n ) { int max_value = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; int number_of_bits = ( int ) ( ( Math . log ( max_value ) ) ) + 2 ; int complement = ( ( 1 << number_of_bits ) - 1 ) ^ max_value ; int c = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != max_value ) { c = Math . max ( c , ( complement & arr [ i ] ) ) ; } } return ( max_value + c ) ; }
Ref: 
def maxOR ( arr , n ) : NEW_LINE INDENT max_value = max ( arr ) NEW_LINE number_of_bits = floor ( log2 ( max_value ) ) + 1 NEW_LINE complement = ( ( ( 1 << number_of_bits ) - 1 ) ^ max_value ) NEW_LINE c = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] != max_value ) : NEW_LINE INDENT c = max ( c , ( complement & arr [ i ] ) ) NEW_LINE DEDENT DEDENT return ( max_value + c ) NEW_LINE DEDENT
Hyp: 
def maxOR ( arr , n ) : NEW_LINE INDENT max_value = max ( arr ) NEW_LINE number_of_bits = int ( log2 ( max_value ) ) + 2 NEW_LINE complement = ( ( 1 << number_of_bits ) - 1 ) ^ max_value NEW_LINE c = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] != max_value ) : NEW_LINE INDENT c = max ( c , ( complement & arr [ i ] ) ) NEW_LINE DEDENT DEDENT return ( max_value + c ) NEW_LINE DEDENT

BLEU: 90.79
Edit Sim: 10


Src: 
double seriesSum ( int n ) { int i = 1 ; double res = 0.0 ; boolean sign = true ; while ( n > 0 ) { n -- ; if ( sign ) { sign = ! sign ; res = res + ( double ) ++ i / ++ i ; } else { sign = ! sign ; res = res - ( double ) ++ i / ++ i ; } } return res ; }
Ref: 
def seriesSum ( n ) : NEW_LINE INDENT i = 1 ; NEW_LINE res = 0.0 ; NEW_LINE sign = True ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT n = n - 1 ; NEW_LINE if ( sign ) : NEW_LINE INDENT sign = False ; NEW_LINE res = res + ( i + 1 ) / ( i + 2 ) ; NEW_LINE i = i + 2 ; NEW_LINE DEDENT else : NEW_LINE INDENT sign = True ; NEW_LINE res = res - ( i + 1 ) / ( i + 2 ) ; NEW_LINE i = i + 2 ; NEW_LINE DEDENT DEDENT return res ; NEW_LINE DEDENT
Hyp: 
def seriesSum ( n ) : NEW_LINE INDENT i = 1 NEW_LINE res = 0.0 NEW_LINE sign = True NEW_LINE while ( n > 0 ) : NEW_LINE INDENT n -= 1 NEW_LINE if ( sign ) : NEW_LINE INDENT sign = not sign NEW_LINE res = res + ( double ) i // i NEW_LINE DEDENT else : NEW_LINE INDENT sign = not sign NEW_LINE res = res - ( double ) ++ i / i NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT

BLEU: 43.86
Edit Sim: 100


Src: 
int MegagonNum ( int n ) { return ( 999998 * n * n - 999996 * n ) / 2 ; }
Ref: 
def MegagonNum ( n ) : NEW_LINE INDENT return ( 999998 * n * n - 999996 * n ) // 2 ; NEW_LINE DEDENT
Hyp: 
def MegagonNum ( n ) : NEW_LINE INDENT return ( 999998 * n * n - 999996 * n ) // 2 NEW_LINE DEDENT

BLEU: 90.59
Edit Sim: 2


Src: 
boolean permutation ( int [ ] arr , int n ) { Set < Integer > hash = new HashSet < Integer > ( ) ; int maxEle = 0 ; for ( int i = 0 ; i < n ; i ++ ) { hash . add ( arr [ i ] ) ; maxEle = Math . max ( maxEle , arr [ i ] ) ; } if ( maxEle != n ) return false ; if ( hash . size ( ) == n ) return true ; return false ; }
Ref: 
def permutation ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE maxEle = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . add ( arr [ i ] ) ; NEW_LINE maxEle = max ( maxEle , arr [ i ] ) ; NEW_LINE DEDENT if ( maxEle != n ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( len ( s ) == n ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT
Hyp: 
def permutation ( arr , n ) : NEW_LINE INDENT hash = set ( ) NEW_LINE maxEle = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT hash . add ( arr [ i ] ) NEW_LINE maxEle = max ( maxEle , arr [ i ] ) NEW_LINE DEDENT if ( maxEle != n ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( len ( hash ) == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT

BLEU: 77.34
Edit Sim: 19


Src: 
int minLettersNeeded ( int n ) { if ( n % 26 == 0 ) return ( n / 26 ) ; else return ( ( n / 26 ) + 1 ) ; }
Ref: 
def minLettersNeeded ( n ) : NEW_LINE INDENT if n % 26 == 0 : NEW_LINE INDENT return ( n // 26 ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( ( n // 26 ) + 1 ) NEW_LINE DEDENT DEDENT
Hyp: 
def minLettersNeeded ( n ) : NEW_LINE INDENT if n % 26 == 0 : NEW_LINE INDENT return ( n // 26 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT return ( ( n // 26 ) + 1 ) ; NEW_LINE DEDENT DEDENT

BLEU: 88.2
Edit Sim: 4


Src: 
void findSumOfGP ( double a , double r ) { if ( Math . abs ( r ) >= 1 ) { System . out . print ( " Infinite " ) ; return ; } double sum = a / ( 1 - r ) ; System . out . print ( sum ) ; }
Ref: 
def findSumOfGP ( a , r ) : NEW_LINE INDENT if ( abs ( r ) >= 1 ) : NEW_LINE INDENT print ( " Infinite " ) NEW_LINE return NEW_LINE DEDENT sum = a / ( 1 - r ) NEW_LINE print ( int ( sum ) ) NEW_LINE DEDENT
Hyp: 
def findSumOfGP ( a , r ) : NEW_LINE INDENT if r >= 1 : NEW_LINE INDENT print ( " Infinite " ) NEW_LINE return NEW_LINE DEDENT sum = a / ( 1 - r ) NEW_LINE print ( sum ) NEW_LINE DEDENT

BLEU: 72.64
Edit Sim: 20


Src: 
int shortestChainLen ( String start , String target , Set < String > D ) { if ( start == target ) return 0 ; if ( ! D . contains ( target ) ) return 0 ; int level = 0 , wordlength = start . length ( ) ; Queue < String > Q = new LinkedList < > ( ) ; Q . add ( start ) ; while ( ! Q . isEmpty ( ) ) { ++ level ; int sizeofQ = Q . size ( ) ; for ( int i = 0 ; i < sizeofQ ; ++ i ) { char [ ] word = Q . peek ( ) . toCharArray ( ) ; Q . remove ( ) ; for ( int pos = 0 ; pos < wordlength ; ++ pos ) { char orig_char = word [ pos ] ; for ( char c = ' a ' ; c <= ' z ' ; ++ c ) { word [ pos ] = c ; if ( String . valueOf ( word ) . equals ( target ) ) return level + 1 ; if ( ! D . contains ( String . valueOf ( word ) ) ) continue ; D . remove ( String . valueOf ( word ) ) ; Q . add ( String . valueOf ( word ) ) ; } word [ pos ] = orig_char ; } } } return 0 ; }
Ref: 
def shortestChainLen ( start , target , D ) : NEW_LINE INDENT if start == target : NEW_LINE return 0 NEW_LINE if target not in D : NEW_LINE INDENT return 0 NEW_LINE DEDENT level , wordlength = 0 , len ( start ) NEW_LINE Q = deque ( ) NEW_LINE Q . append ( start ) NEW_LINE while ( len ( Q ) > 0 ) : NEW_LINE INDENT level += 1 NEW_LINE sizeofQ = len ( Q ) NEW_LINE for i in range ( sizeofQ ) : NEW_LINE INDENT word = [ j for j in Q . popleft ( ) ] NEW_LINE for pos in range ( wordlength ) : NEW_LINE INDENT orig_char = word [ pos ] NEW_LINE for c in range ( ord ( ' a ' ) , ord ( ' z ' ) + 1 ) : NEW_LINE INDENT word [ pos ] = chr ( c ) NEW_LINE if ( " " . join ( word ) == target ) : NEW_LINE INDENT return level + 1 NEW_LINE DEDENT if ( " " . join ( word ) not in D ) : NEW_LINE INDENT continue NEW_LINE DEDENT del D [ " " . join ( word ) ] NEW_LINE Q . append ( " " . join ( word ) ) NEW_LINE DEDENT word [ pos ] = orig_char NEW_LINE DEDENT DEDENT DEDENT return 0 NEW_LINE DEDENT
Hyp: 
def shortestChainLen ( start , target , D ) : NEW_LINE INDENT if ( start == target ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT level = 0 NEW_LINE wordlength = len ( start ) NEW_LINE Q = [ start ] * wordlength NEW_LINE while ( len ( Q ) > 0 ) : NEW_LINE INDENT level += 1 NEW_LINE sizeofQ = len ( Q ) NEW_LINE for i in range ( sizeofQ ) : NEW_LINE INDENT word = Q . pop ( ) NEW_LINE for pos in range ( 0 , wordlength ) : NEW_LINE INDENT word [ pos ] = c NEW_LINE if ( target == word [ pos ] ) : NEW_LINE INDENT return level + 1 NEW_LINE DEDENT if ( D [ str ( word ) ] == target ) : NEW_LINE INDENT return level + 1 NEW_LINE DEDENT if ( D [ str ( word ) ] == target ) : NEW_LINE INDENT return level + 1 NEW_LINE DEDENT D [ str ( word ) ] = 1 NEW_LINE DEDENT Q . append ( word [ pos ] ) NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT

BLEU: 49.95
Edit Sim: 319


Src: 
int Cells ( int n , int x ) { int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) if ( x % i == 0 && x / i <= n ) ans ++ ; return ans ; }
Ref: 
def Cells ( n , x ) : NEW_LINE INDENT ans = 0 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( x % i == 0 and x / i <= n ) : NEW_LINE INDENT ans += 1 ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT
Hyp: 
def Cells ( n , x ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( x % i == 0 and x // i <= n ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT

BLEU: 82.48
Edit Sim: 7


Src: 
int sumOfSeries ( int n ) { return n * ( n + 1 ) * ( 6 * n * n * n + 9 * n * n + n - 1 ) / 30 ; }
Ref: 
def sumOfSeries ( n ) : NEW_LINE INDENT return n * ( n + 1 ) * ( 6 * n * n * n + 9 * n * n + n - 1 ) / 30 NEW_LINE DEDENT
Hyp: 
def sumOfSeries ( n ) : NEW_LINE INDENT return n * ( n + 1 ) * ( 6 * n * n * n + 9 * n * n + n - 1 ) / 30 NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int countNumberOfTriangles ( int n ) { return n * ( n - 1 ) * ( n - 2 ) / 6 ; }
Ref: 
def countNumberOfTriangles ( n ) : NEW_LINE INDENT return ( n * ( n - 1 ) * ( n - 2 ) // 6 ) NEW_LINE DEDENT
Hyp: 
def countNumberOfTriangles ( n ) : NEW_LINE INDENT return n * ( n - 1 ) * ( n - 2 ) // 6 NEW_LINE DEDENT

BLEU: 81.96
Edit Sim: 4


Src: 
int maxSumSubarray ( int [ ] arr ) { int i = 0 , j = 1 ; HashSet < Integer > set = new HashSet < Integer > ( ) ; set . add ( arr [ 0 ] ) ; int sum = arr [ 0 ] ; int maxsum = sum ; while ( i < arr . length - 1 && j < arr . length ) { if ( ! set . contains ( arr [ j ] ) ) { sum = sum + arr [ j ] ; maxsum = Math . max ( sum , maxsum ) ; set . add ( arr [ j ++ ] ) ; } else { sum -= arr [ i ] ; set . remove ( arr [ i ++ ] ) ; } } return maxsum ; }
Ref: 
def maxSumSubarray ( arr ) : NEW_LINE INDENT i = 0 NEW_LINE j = 1 NEW_LINE set = { } NEW_LINE set [ arr [ 0 ] ] = 1 NEW_LINE sum = arr [ 0 ] NEW_LINE maxsum = sum NEW_LINE while ( i < len ( arr ) - 1 and j < len ( arr ) ) : NEW_LINE INDENT if arr [ j ] not in set : NEW_LINE INDENT sum = sum + arr [ j ] NEW_LINE maxsum = max ( sum , maxsum ) NEW_LINE set [ arr [ j ] ] = 1 NEW_LINE j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT sum -= arr [ i ] NEW_LINE del set [ arr [ i ] ] NEW_LINE i += 1 NEW_LINE DEDENT DEDENT return maxsum NEW_LINE DEDENT
Hyp: 
def maxSumSubarray ( arr ) : NEW_LINE INDENT i = 0 ; j = 1 NEW_LINE set = set ( ) NEW_LINE sum = arr [ 0 ] NEW_LINE maxsum = sum NEW_LINE while ( i < len ( arr ) - 1 and j < len ( arr ) ) : NEW_LINE INDENT if arr [ j ] not in set : NEW_LINE INDENT sum = sum + arr [ j ] NEW_LINE maxsum = max ( sum , maxsum ) NEW_LINE set [ arr [ j ] ] = 1 NEW_LINE j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT sum -= arr [ i ] NEW_LINE set [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT return maxsum NEW_LINE DEDENT

BLEU: 84.93
Edit Sim: 53


Src: 
void print ( int p0 ) { int p1 , i = 0 , x , flag , k ; while ( true ) { flag = 1 ; x = ( int ) ( Math . pow ( 2 , i ) ) ; p1 = x * p0 + ( x - 1 ) ; for ( k = 2 ; k < p1 ; k ++ ) { if ( p1 % k == 0 ) { flag = 0 ; break ; } } if ( flag == 0 ) break ; System . out . print ( " ▁ " + p1 ) ; i ++ ; } }
Ref: 
def print_C ( p0 ) : NEW_LINE INDENT i = 0 ; NEW_LINE while ( True ) : NEW_LINE INDENT flag = 1 ; NEW_LINE x = pow ( 2 , i ) ; NEW_LINE p1 = x * p0 + ( x - 1 ) ; NEW_LINE for k in range ( 2 , p1 ) : NEW_LINE INDENT if ( p1 % k == 0 ) : NEW_LINE INDENT flag = 0 ; NEW_LINE break ; NEW_LINE DEDENT DEDENT if ( flag == 0 ) : NEW_LINE INDENT break ; NEW_LINE DEDENT print ( p1 , end = " ▁ " ) ; NEW_LINE i += 1 ; NEW_LINE DEDENT DEDENT
Hyp: 
def print ( p0 ) : NEW_LINE INDENT p1 = 0 NEW_LINE i = 0 NEW_LINE flag = 1 NEW_LINE x = pow ( 2 , i ) NEW_LINE while ( True ) : NEW_LINE INDENT flag = 1 NEW_LINE x = pow ( 2 , i ) NEW_LINE p1 = x * p0 + ( x - 1 ) NEW_LINE for k in range ( 2 , p1 ) : NEW_LINE INDENT if ( p1 % k == 0 ) : NEW_LINE INDENT flag = 0 NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT print ( " ▁ " , p1 ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT

BLEU: 67.65
Edit Sim: 90


Src: 
int count ( String s ) { int N , i , cnt = 0 , ans = 0 ; N = s . length ( ) ; for ( i = 0 ; i < N ; i ++ ) { if ( s . charAt ( i ) == ' R ' ) cnt ++ ; if ( s . charAt ( i ) == ' L ' ) ans += cnt ; } return ans ; }
Ref: 
def count ( s ) : NEW_LINE INDENT cnt , ans = 0 , 0 NEW_LINE N = len ( s ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( s [ i ] == ' R ' ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT if ( s [ i ] == ' L ' ) : NEW_LINE INDENT ans += cnt NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
Hyp: 
def count ( s ) : NEW_LINE INDENT N , cnt = 0 , 0 NEW_LINE ans = 0 , 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( s [ i ] == ' R ' ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT if ( s [ i ] == ' L ' ) : NEW_LINE INDENT ans += cnt NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT

BLEU: 86.53
Edit Sim: 14


Src: 
int countNums ( int l , int r ) { int cnt = 0 ; for ( int i = l ; i <= r ; i ++ ) { int lastDigit = ( i % 10 ) ; if ( ( lastDigit % 10 ) == 2 || ( lastDigit % 10 ) == 3 || ( lastDigit % 10 ) == 9 ) { cnt ++ ; } } return cnt ; }
Ref: 
def countNums ( l , r ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT lastDigit = ( i % 10 ) ; NEW_LINE if ( ( lastDigit % 10 ) == 2 or ( lastDigit % 10 ) == 3 or ( lastDigit % 10 ) == 9 ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT DEDENT return cnt ; NEW_LINE DEDENT
Hyp: 
def countNums ( l , r ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT lastDigit = ( i % 10 ) NEW_LINE if ( ( lastDigit % 10 ) == 2 or ( lastDigit % 10 ) == 3 or ( lastDigit % 10 ) == 9 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT

BLEU: 87.24
Edit Sim: 8


Src: 
void solve ( int A , int B ) { int count = 0 ; for ( int i = 0 ; i < 32 ; i ++ ) { if ( ( ( A >> i ) & 1 ) != ( ( B >> i ) & 1 ) ) { count ++ ; } } System . out . println ( " Number ▁ of ▁ different ▁ bits ▁ : ▁ " + count ) ; }
Ref: 
def solve ( A , B ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , 32 ) : NEW_LINE INDENT if ( ( ( A >> i ) & 1 ) != ( ( B >> i ) & 1 ) ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT print ( " Number ▁ of ▁ different ▁ bits ▁ : " , count ) NEW_LINE DEDENT
Hyp: 
def solve ( A , B ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 32 ) : NEW_LINE INDENT if ( ( A >> i ) & 1 ) != ( ( B >> i ) & 1 ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( " Number ▁ of ▁ different ▁ bits ▁ : " , count ) NEW_LINE DEDENT

BLEU: 87.62
Edit Sim: 15


Src: 
void minCost ( char arr [ ] [ ] , int A , int B ) { int n = arr . length ; int m = arr [ 0 ] . length ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( arr [ i ] [ j ] == ' * ' ) continue ; if ( j == m - 1 ) ans += A ; else { if ( arr [ i ] [ j + 1 ] == ' . ' ) { ans += Math . min ( 2 * A , B ) ; j ++ ; } else ans += A ; } } } System . out . println ( ans ) ; }
Ref: 
def minCost ( arr , A , B ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE m = len ( arr [ 0 ] ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT j = 0 NEW_LINE while j < m : NEW_LINE INDENT if ( arr [ i ] [ j ] == ' * ' ) : NEW_LINE INDENT j += 1 NEW_LINE continue NEW_LINE DEDENT if ( j == m - 1 ) : NEW_LINE INDENT ans += A NEW_LINE DEDENT else : NEW_LINE INDENT if ( arr [ i ] [ j + 1 ] == ' . ' ) : NEW_LINE INDENT ans += min ( 2 * A , B ) NEW_LINE j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += A NEW_LINE DEDENT DEDENT j += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
Hyp: 
def minCost ( arr , A , B ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE m = len ( arr [ 0 ] ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if arr [ i ] [ j ] == ' * ' : NEW_LINE INDENT continue NEW_LINE DEDENT if j == m - 1 : NEW_LINE INDENT ans += A NEW_LINE DEDENT else : NEW_LINE INDENT ans += A NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE DEDENT

BLEU: 50.38
Edit Sim: 200


Src: 
int maxPartition ( String s ) { int n = s . length ( ) , P = 0 ; String current = " " , previous = " " ; for ( int i = 0 ; i < n ; i ++ ) { current += s . charAt ( i ) ; if ( ! current . equals ( previous ) ) { previous = current ; current = " " ; P ++ ; } } return P ; }
Ref: 
def maxPartition ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE P = 0 NEW_LINE current = " " NEW_LINE previous = " " NEW_LINE for i in range ( n ) : NEW_LINE INDENT current += s [ i ] NEW_LINE if ( current != previous ) : NEW_LINE INDENT previous = current NEW_LINE current = " " NEW_LINE P += 1 NEW_LINE DEDENT DEDENT return P NEW_LINE DEDENT
Hyp: 
def maxPartition ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE P = 0 NEW_LINE current = " " NEW_LINE previous = " " NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT current += s [ i ] NEW_LINE if ( current != previous ) : NEW_LINE INDENT previous = current NEW_LINE current = " " NEW_LINE P += 1 NEW_LINE DEDENT DEDENT return P NEW_LINE DEDENT

BLEU: 95.33
Edit Sim: 4


Src: 
void findXandYwithminABSX_Y ( int N ) { if ( N % 2 == 1 ) { System . out . print ( ( N / 2 ) + " ▁ " + ( N / 2 + 1 ) ) ; } else { System . out . print ( ( N / 2 - 1 ) + " ▁ " + ( N / 2 + 1 ) ) ; } }
Ref: 
def findXandYwithminABSX_Y ( N ) : NEW_LINE INDENT if ( N % 2 == 1 ) : NEW_LINE INDENT print ( ( N // 2 ) , ( N // 2 + 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ( N // 2 - 1 ) , ( N // 2 + 1 ) ) NEW_LINE DEDENT DEDENT
Hyp: 
def findXandYwithminABSX_Y ( N ) : NEW_LINE INDENT if ( N % 2 == 1 ) : NEW_LINE INDENT print ( ( N / 2 ) , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ( N / 2 - 1 ) , end = " ▁ " ) NEW_LINE DEDENT DEDENT

BLEU: 63.48
Edit Sim: 22


Src: 
float polydiagonal ( float n , float a ) { if ( a < 0 && n < 0 ) { return - 1 ; } return ( float ) ( 2 * a * Math . sin ( ( ( ( n - 2 ) * 180 ) / ( 2 * n ) ) * 3.14159 / 180 ) ) ; }
Ref: 
def polydiagonal ( n , a ) : NEW_LINE INDENT if ( a < 0 and n < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return ( 2 * a * mt . sin ( ( ( ( n - 2 ) * 180 ) / ( 2 * n ) ) * 3.14159 / 180 ) ) NEW_LINE DEDENT
Hyp: 
def polydiagonal ( n , a ) : NEW_LINE INDENT if ( a < 0 and n < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return 2 * a * math . sin ( ( ( n - 2 ) * 180 ) / ( 2 * n ) ) * 3.14159 / 180 ) NEW_LINE DEDENT

BLEU: 87.29
Edit Sim: 8


Src: 
String findStr ( String S ) { StringBuilder sb = new StringBuilder ( S ) ; int n = sb . length ( ) ; for ( int i = 0 ; i < n / 2 ; ++ i ) { if ( sb . charAt ( i ) != ' a ' ) { sb . setCharAt ( i , ' a ' ) ; return sb . toString ( ) ; } } sb . setCharAt ( n - 1 , ' b ' ) ; return n < 2 ? " ▁ - 1 ▁ " : sb . toString ( ) ; }
Ref: 
def findStr ( S ) : NEW_LINE INDENT S = list ( S ) NEW_LINE n = len ( S ) NEW_LINE for i in range ( 0 , n // 2 ) : NEW_LINE if S [ i ] != ' a ' : NEW_LINE INDENT S [ i ] = ' a ' NEW_LINE return ( ' ' . join ( S ) ) NEW_LINE DEDENT S [ n - 1 ] = ' b ' NEW_LINE if n < 2 : NEW_LINE INDENT return ' - 1' NEW_LINE DEDENT else : NEW_LINE INDENT return ( ' ' . join ( S ) ) NEW_LINE DEDENT DEDENT
Hyp: 
def findStr ( S ) : NEW_LINE INDENT s = list ( S ) NEW_LINE n = len ( s ) NEW_LINE for i in range ( int ( n / 2 ) ) : NEW_LINE INDENT if ( s [ i ] != ' a ' ) : NEW_LINE INDENT s [ i ] = ' a ' NEW_LINE return s [ i ] NEW_LINE DEDENT DEDENT sb [ n - 1 ] = ' b ' NEW_LINE return s [ : : - 1 ] NEW_LINE DEDENT

BLEU: 45.19
Edit Sim: 143


Src: 
long nthKyneaNumber ( int n ) { return ( ( 1 << ( 2 * n ) ) + ( 1 << ( n + 1 ) ) - 1 ) ; }
Ref: 
def nthKyneaNumber ( n ) : NEW_LINE INDENT return ( ( 1 << ( 2 * n ) ) + ( 1 << ( n + 1 ) ) - 1 ) NEW_LINE DEDENT
Hyp: 
def nthKyneaNumber ( n ) : NEW_LINE INDENT return ( ( 1 << ( 2 * n ) ) + ( 1 << ( n + 1 ) ) - 1 ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
void rearrange ( int a [ ] , int size ) { int positive = 0 , negative = 1 , temp ; while ( true ) { while ( positive < size && a [ positive ] >= 0 ) positive += 2 ; while ( negative < size && a [ negative ] <= 0 ) negative += 2 ; if ( positive < size && negative < size ) { temp = a [ positive ] ; a [ positive ] = a [ negative ] ; a [ negative ] = temp ; } else break ; } }
Ref: 
def rearrange ( a , size ) : NEW_LINE INDENT positive = 0 NEW_LINE negative = 1 NEW_LINE while ( True ) : NEW_LINE INDENT while ( positive < size and a [ positive ] >= 0 ) : NEW_LINE INDENT positive = positive + 2 NEW_LINE DEDENT while ( negative < size and a [ negative ] <= 0 ) : NEW_LINE INDENT negative = negative + 2 NEW_LINE DEDENT if ( positive < size and negative < size ) : NEW_LINE INDENT temp = a [ positive ] NEW_LINE a [ positive ] = a [ negative ] NEW_LINE a [ negative ] = temp NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT arr = [ 1 , - 3 , 5 , 6 , - 3 , 6 , 7 , - 4 , 9 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE rearrange ( arr , n ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT
Hyp: 
def rearrange ( a , size ) : NEW_LINE INDENT positive = 0 ; negative = 1 NEW_LINE while ( True ) : NEW_LINE INDENT while ( positive < size and a [ positive ] >= 0 ) : NEW_LINE INDENT positive += 2 NEW_LINE DEDENT while ( negative < size and a [ negative ] <= 0 ) : NEW_LINE INDENT negative += 2 NEW_LINE DEDENT if ( positive < size and negative < size ) : NEW_LINE INDENT temp = a [ positive ] NEW_LINE a [ positive ] = a [ negative ] NEW_LINE a [ negative ] = temp NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT

BLEU: 49.62
Edit Sim: 245


Src: 
boolean arekAnagrams ( String str1 , String str2 , int k ) { int n = str1 . length ( ) ; if ( str2 . length ( ) != n ) return false ; int [ ] count1 = new int [ MAX_CHAR ] ; int [ ] count2 = new int [ MAX_CHAR ] ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) count1 [ str1 . charAt ( i ) - ' a ' ] ++ ; for ( int i = 0 ; i < n ; i ++ ) count2 [ str2 . charAt ( i ) - ' a ' ] ++ ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) if ( count1 [ i ] > count2 [ i ] ) count = count + Math . abs ( count1 [ i ] - count2 [ i ] ) ; return ( count <= k ) ; }
Ref: 
def arekAnagrams ( str1 , str2 , k ) : NEW_LINE INDENT n = len ( str1 ) NEW_LINE if ( len ( str2 ) != n ) : NEW_LINE INDENT return False NEW_LINE DEDENT count1 = [ 0 ] * MAX_CHAR NEW_LINE count2 = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( n ) : NEW_LINE INDENT count1 [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT count2 [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( MAX_CHAR ) : NEW_LINE INDENT if ( count1 [ i ] > count2 [ i ] ) : NEW_LINE INDENT count = count + abs ( count1 [ i ] - count2 [ i ] ) NEW_LINE DEDENT DEDENT return ( count <= k ) NEW_LINE DEDENT
Hyp: 
def arekAnagrams ( str1 , str2 , k ) : NEW_LINE INDENT n = len ( str1 ) NEW_LINE if ( len ( str2 ) != n ) : NEW_LINE INDENT return False NEW_LINE DEDENT count1 = [ 0 ] * MAX_CHAR NEW_LINE count2 = [ 0 ] * MAX_CHAR NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT count1 [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT count2 [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( MAX_CHAR ) : NEW_LINE INDENT if ( count1 [ i ] > count2 [ i ] ) : NEW_LINE INDENT count = count + abs ( count1 [ i ] - count2 [ i ] ) NEW_LINE DEDENT DEDENT return ( count <= k ) NEW_LINE DEDENT

BLEU: 98.2
Edit Sim: 38


Src: 
int xorZero ( String s ) { int one_count = 0 , zero_count = 0 ; char [ ] str = s . toCharArray ( ) ; int n = str . length ; for ( int i = 0 ; i < n ; i ++ ) if ( str [ i ] == '1' ) one_count ++ ; else zero_count ++ ; if ( one_count % 2 == 0 ) return zero_count ; return one_count ; }
Ref: 
def xorZero ( str ) : NEW_LINE INDENT one_count = 0 NEW_LINE zero_count = 0 NEW_LINE n = len ( str ) NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( str [ i ] == '1' ) : NEW_LINE INDENT one_count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT zero_count += 1 NEW_LINE DEDENT DEDENT if ( one_count % 2 == 0 ) : NEW_LINE INDENT return zero_count NEW_LINE DEDENT return one_count NEW_LINE DEDENT
Hyp: 
def xorZero ( s ) : NEW_LINE INDENT one_count = 0 NEW_LINE zero_count = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT one_count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT zero_count += 1 NEW_LINE DEDENT DEDENT if ( one_count % 2 == 0 ) : NEW_LINE INDENT return zero_count NEW_LINE DEDENT return one_count NEW_LINE DEDENT

BLEU: 77.14
Edit Sim: 35


Src: 
boolean isPrime ( int n , int i ) { if ( n <= 2 ) return ( n == 2 ) ? true : false ; if ( n % i == 0 ) return false ; if ( i * i > n ) return true ; return isPrime ( n , i + 1 ) ; }
Ref: 
def isPrime ( n , i = 2 ) : NEW_LINE INDENT if ( n <= 2 ) : NEW_LINE INDENT return True if ( n == 2 ) else False NEW_LINE DEDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( i * i > n ) : NEW_LINE INDENT return true NEW_LINE DEDENT return isPrime ( n , i + 1 ) NEW_LINE DEDENT n = 15 NEW_LINE if ( isPrime ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
Hyp: 
def isPrime ( n , i ) : NEW_LINE INDENT if ( n <= 2 ) : NEW_LINE INDENT return ( n == 2 ) NEW_LINE DEDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( i * i > n ) : NEW_LINE INDENT return True NEW_LINE DEDENT return isPrime ( n , i + 1 ) NEW_LINE DEDENT n = 65 NEW_LINE i = 4 NEW_LINE if ( isPrime ( n , i ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT

BLEU: 85.24
Edit Sim: 44


Src: 
void maxAverage ( int A [ ] , int N , int X , int Y ) { Arrays . sort ( A ) ; int sum = 0 ; double res = 0 ; int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += A [ i ] ; count ++ ; if ( count == X ) { if ( N - i - 1 < X ) { i ++ ; int cnt = 0 ; while ( i < N ) { cnt ++ ; sum += A [ i ] ; i ++ ; } X = X + cnt ; res += ( double ) sum / ( double ) ( X ) ; break ; } res += ( double ) sum / ( double ) ( X ) ; sum = 0 ; count = 0 ; } } System . out . println ( res ) ; }
Ref: 
def maxAverage ( A , N , X , Y ) : NEW_LINE INDENT A . sort ( ) NEW_LINE sum = 0 NEW_LINE res = 0 NEW_LINE count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum += A [ i ] NEW_LINE count += 1 NEW_LINE if ( count == X ) : NEW_LINE INDENT if ( N - i - 1 < X ) : NEW_LINE INDENT i += 1 NEW_LINE cnt = 0 NEW_LINE while ( i < N ) : NEW_LINE INDENT cnt += 1 NEW_LINE sum += A [ i ] NEW_LINE i += 1 NEW_LINE DEDENT X = X + cnt NEW_LINE res += sum / X NEW_LINE break NEW_LINE DEDENT res += sum / X NEW_LINE sum = 0 NEW_LINE count = 0 NEW_LINE DEDENT DEDENT print ( res ) NEW_LINE DEDENT
Hyp: 
def maxAverage ( A , N , X , Y ) : NEW_LINE INDENT A . sort ( ) NEW_LINE Sum , res = 0 , 0 NEW_LINE count = 0 , 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT Sum += A [ i ] NEW_LINE count += 1 NEW_LINE if ( count == X ) : NEW_LINE INDENT if ( N - i - 1 < X ) : NEW_LINE INDENT i += 1 NEW_LINE cnt = 0 NEW_LINE while ( i < N ) : NEW_LINE INDENT cnt += 1 NEW_LINE sum += A [ i ] NEW_LINE i += 1 NEW_LINE DEDENT X = X + cnt NEW_LINE res += sum / ( X ) NEW_LINE break NEW_LINE DEDENT res += sum / ( X ) NEW_LINE sum = 0 NEW_LINE count = 0 NEW_LINE DEDENT DEDENT print ( res ) NEW_LINE DEDENT

BLEU: 87.06
Edit Sim: 29


Src: 
void newvol ( double x ) { System . out . print ( " percentage ▁ increase ▁ in ▁ the " + " ▁ volume ▁ of ▁ the ▁ sphere ▁ is ▁ " + ( Math . pow ( x , 3 ) / 10000 + 3 * x + ( 3 * Math . pow ( x , 2 ) ) / 100 ) + " % " ) ; }
Ref: 
def newvol ( x ) : NEW_LINE INDENT print ( " percentage ▁ increase ▁ in ▁ the " , pow ( x , 3 ) / 10000 + 3 * x + ( 3 * pow ( x , 2 ) ) / 100 , " % " ) DEDENT
Hyp: 
def newvol ( x ) : NEW_LINE INDENT print ( " percentage ▁ increase ▁ in ▁ the " , " ▁ volume ▁ of ▁ the ▁ sphere ▁ is ▁ " , ( ( pow ( x , 3 ) / 10000 + 3 * x + ( 3 * pow ( x , 2 ) ) / 100 ) , " % " ) NEW_LINE DEDENT

BLEU: 68.04
Edit Sim: 57


Src: 
int nthTerm ( int n ) { return 3 * ( int ) Math . pow ( n , 2 ) - 4 * n + 2 ; }
Ref: 
def nthTerm ( n ) : NEW_LINE INDENT return 3 * pow ( n , 2 ) - 4 * n + 2 NEW_LINE DEDENT
Hyp: 
def nthTerm ( n ) : NEW_LINE INDENT return 3 * pow ( n , 2 ) - 4 * n + 2 NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int splitArray ( int arr [ ] , int N ) { Arrays . sort ( arr ) ; int result = Integer . MAX_VALUE ; for ( int i = 1 ; i < N ; i ++ ) { result = Math . min ( result , arr [ i ] - arr [ i - 1 ] ) ; } return result ; }
Ref: 
def splitArray ( arr , N ) : NEW_LINE INDENT arr = sorted ( arr ) NEW_LINE result = 10 ** 9 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT result = min ( result , arr [ i ] ^ arr [ i - 1 ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT
Hyp: 
def splitArray ( arr , N ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE result = sys . maxsize NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT result = min ( result , arr [ i ] - arr [ i - 1 ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT

BLEU: 78.65
Edit Sim: 20


Src: 
int smallestDivisor ( int n ) { if ( n % 2 == 0 ) return 2 ; for ( int i = 3 ; i * i <= n ; i += 2 ) { if ( n % i == 0 ) return i ; } return n ; }
Ref: 
def smallestDivisor ( n ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT return 2 ; NEW_LINE DEDENT i = 3 ; NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return i ; NEW_LINE DEDENT i += 2 ; NEW_LINE DEDENT return n ; NEW_LINE DEDENT
Hyp: 
def smallestDivisor ( n ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT for i in range ( 3 , n + 1 , 2 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return n NEW_LINE DEDENT

BLEU: 60.2
Edit Sim: 50


Src: 
int findMinDif ( int arr [ ] , int N ) { Arrays . sort ( arr ) ; return ( arr [ N - 1 ] - arr [ N - 2 ] ) ; }
Ref: 
def findMinDif ( arr , N ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE return ( arr [ N - 1 ] - arr [ N - 2 ] ) NEW_LINE DEDENT
Hyp: 
def findMinDif ( arr , N ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE return ( arr [ N - 1 ] - arr [ N - 2 ] ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int binomialCoeff ( int n , int k ) { if ( k > n ) return 0 ; int res = 1 ; if ( k > n - k ) k = n - k ; for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; }
Ref: 
def binomialCoeff ( n , k ) : NEW_LINE INDENT if ( k > n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT res = 1 NEW_LINE if ( k > n - k ) : NEW_LINE INDENT k = n - k NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT res *= ( n - i ) NEW_LINE res //= ( i + 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT
Hyp: 
def binomialCoeff ( n , k ) : NEW_LINE INDENT if ( k > n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT res = 1 NEW_LINE if ( k > n - k ) : NEW_LINE INDENT k = n - k NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT res *= ( n - i ) NEW_LINE res /= ( i + 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT

BLEU: 96.65
Edit Sim: 1


Src: 
void print_primes_till_N ( int N ) { int i , j , flag ; System . out . println ( " Prime ▁ numbers ▁ between ▁ 1 ▁ and ▁ " + N + " ▁ are : " ) ; for ( i = 1 ; i <= N ; i ++ ) { if ( i == 1 i == 0 ) continue ; flag = 1 ; for ( j = 2 ; j <= i / 2 ; ++ j ) { if ( i % j == 0 ) { flag = 0 ; break ; } } if ( flag == 1 ) System . out . print ( i + " ▁ " ) ; } }
Ref: 
def print_primes_till_N ( N ) : NEW_LINE INDENT i , j , flag = 0 , 0 , 0 ; NEW_LINE print ( " Prime ▁ numbers ▁ between ▁ 1 ▁ and ▁ " , N , " ▁ are : " ) ; NEW_LINE for i in range ( 1 , N + 1 , 1 ) : NEW_LINE INDENT if ( i == 1 or i == 0 ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT flag = 1 ; NEW_LINE for j in range ( 2 , ( ( i // 2 ) + 1 ) , 1 ) : NEW_LINE INDENT if ( i % j == 0 ) : NEW_LINE INDENT flag = 0 ; NEW_LINE break ; NEW_LINE DEDENT DEDENT if ( flag == 1 ) : NEW_LINE INDENT print ( i , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT DEDENT
Hyp: 
def print_prmimes_till_N ( N ) : NEW_LINE INDENT print ( " Prime ▁ numbers ▁ between ▁ 1 ▁ and ▁ " , N , " ▁ are : " ) NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( i == 1 or i == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT flag = 1 NEW_LINE for j in range ( 2 , i // 2 + 1 ) : NEW_LINE INDENT if ( i % j == 0 ) : NEW_LINE INDENT flag = 0 NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag == 1 ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT

BLEU: 69.55
Edit Sim: 65


Src: 
void segregate0and1 ( int arr [ ] , int size ) { int left = 0 , right = size - 1 ; while ( left < right ) { while ( arr [ left ] == 0 && left < right ) left ++ ; while ( arr [ right ] == 1 && left < right ) right -- ; if ( left < right ) { arr [ left ] = 0 ; arr [ right ] = 1 ; left ++ ; right -- ; } } }
Ref: 
def segregate0and1 ( arr , size ) : NEW_LINE INDENT left , right = 0 , size - 1 NEW_LINE while left < right : NEW_LINE INDENT while arr [ left ] == 0 and left < right : NEW_LINE INDENT left += 1 NEW_LINE DEDENT while arr [ right ] == 1 and left < right : NEW_LINE INDENT right -= 1 NEW_LINE DEDENT if left < right : NEW_LINE INDENT arr [ left ] = 0 NEW_LINE arr [ right ] = 1 NEW_LINE left += 1 NEW_LINE right -= 1 NEW_LINE DEDENT DEDENT return arr NEW_LINE DEDENT
Hyp: 
def segregate0and1 ( arr , size ) : NEW_LINE INDENT left = 0 NEW_LINE right = size - 1 NEW_LINE while ( left < right ) : NEW_LINE INDENT while ( arr [ left ] == 0 and left < right ) : NEW_LINE INDENT left += 1 NEW_LINE DEDENT while ( arr [ right ] == 1 and left < right ) : NEW_LINE INDENT right -= 1 NEW_LINE DEDENT if ( left < right ) : NEW_LINE INDENT arr [ left ] = 0 NEW_LINE arr [ right ] = 1 NEW_LINE left += 1 NEW_LINE right -= 1 NEW_LINE DEDENT DEDENT DEDENT

BLEU: 74.32
Edit Sim: 52


Src: 
int breakEvenPoint ( int exp1 , int S , int M ) { double earn = S - M ; double exp = exp1 ; double res = Math . ceil ( exp / earn ) ; int res1 = ( int ) res ; return res1 ; }
Ref: 
def breakEvenPoint ( exp , S , M ) : NEW_LINE INDENT earn = S - M NEW_LINE if res != 0 : NEW_LINE res = math . ceil ( exp / earn ) NEW_LINE else : NEW_LINE res = float ( ' inf ' ) NEW_LINE return res NEW_LINE DEDENT
Hyp: 
def breakEvenPoint ( exp1 , S , M ) : NEW_LINE INDENT earn = S - M NEW_LINE exp = exp1 NEW_LINE res = math . ceil ( exp // earn ) NEW_LINE res1 = int ( res ) NEW_LINE return res1 NEW_LINE DEDENT

BLEU: 49.26
Edit Sim: 42


Src: 
String removeOuterParentheses ( String S ) { String res = " " ; int count = 0 ; for ( int c = 0 ; c < S . length ( ) ; c ++ ) { if ( S . charAt ( c ) == ' ( ' && count ++ > 0 ) res += S . charAt ( c ) ; if ( S . charAt ( c ) == ' ) ' && count -- > 1 ) res += S . charAt ( c ) ; } return res ; }
Ref: 
def removeOuterParentheses ( S ) : NEW_LINE INDENT res = " " NEW_LINE count = 0 NEW_LINE for c in S : NEW_LINE INDENT if ( c == ' ( ' and count > 0 ) : NEW_LINE INDENT res += c NEW_LINE DEDENT if ( c == ' ( ' ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( c == ' ) ' and count > 1 ) : NEW_LINE INDENT res += c NEW_LINE DEDENT if ( c == ' ) ' ) : NEW_LINE count -= 1 NEW_LINE DEDENT return res NEW_LINE DEDENT
Hyp: 
def removeOuterParentheses ( S ) : NEW_LINE INDENT res = " " NEW_LINE count = 0 NEW_LINE for c in range ( len ( S ) ) : NEW_LINE INDENT if ( S [ c ] == ' ( ' and count += 1 ) : NEW_LINE INDENT res += S [ c ] NEW_LINE DEDENT if ( S [ c ] == ' ( ' and count -= 1 ) : NEW_LINE INDENT res += S [ c ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT

BLEU: 51.64
Edit Sim: 143


Src: 
boolean isDivisible ( int n ) { int d ; while ( ( n / 100 ) > 0 ) { d = n % 10 ; n /= 10 ; n = Math . abs ( n + ( d * 13 ) ) ; } return ( n % 43 == 0 ) ; }
Ref: 
def isDivisible ( n ) : NEW_LINE INDENT while n // 100 : NEW_LINE INDENT d = n % 10 NEW_LINE n //= 10 NEW_LINE n = abs ( n + ( d * 13 ) ) NEW_LINE DEDENT return ( n % 43 == 0 ) NEW_LINE DEDENT
Hyp: 
def isDivisible ( n ) : NEW_LINE INDENT while ( n // 100 ) > 0 : NEW_LINE INDENT d = n % 10 NEW_LINE n //= 10 NEW_LINE n = abs ( n + ( d * 13 ) ) NEW_LINE DEDENT return ( n % 43 == 0 ) NEW_LINE DEDENT n = 121 NEW_LINE if ( isDivisible ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT

BLEU: 52.46
Edit Sim: 158


Src: 
boolean areSetBitsIncreasing ( int n ) { int prev_count = Integer . MAX_VALUE ; while ( n > 0 ) { while ( n > 0 && n % 2 == 0 ) n = n / 2 ; int curr_count = 1 ; while ( n > 0 && n % 2 == 1 ) { n = n / 2 ; curr_count ++ ; } if ( curr_count >= prev_count ) return false ; prev_count = curr_count ; } return true ; }
Ref: 
def areSetBitsIncreasing ( n ) : NEW_LINE INDENT prev_count = sys . maxsize NEW_LINE while ( n > 0 ) : NEW_LINE INDENT while ( n > 0 and n % 2 == 0 ) : NEW_LINE INDENT n = int ( n / 2 ) NEW_LINE DEDENT curr_count = 1 NEW_LINE while ( n > 0 and n % 2 == 1 ) : NEW_LINE INDENT n = n / 2 NEW_LINE curr_count += 1 NEW_LINE DEDENT if ( curr_count >= prev_count ) : NEW_LINE INDENT return False NEW_LINE DEDENT prev_count = curr_count NEW_LINE DEDENT return True NEW_LINE DEDENT n = 10 NEW_LINE if ( areSetBitsIncreasing ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
Hyp: 
def areSetBitsIncreasing ( n ) : NEW_LINE INDENT prev_count = sys . maxsize NEW_LINE while ( n > 0 ) : NEW_LINE INDENT while ( n > 0 and n % 2 == 0 ) : NEW_LINE INDENT n = n // 2 NEW_LINE curr_count = 1 NEW_LINE while ( n > 0 and n % 2 == 1 ) : NEW_LINE INDENT n = n // 2 NEW_LINE curr_count += 1 NEW_LINE DEDENT if ( curr_count >= prev_count ) : NEW_LINE INDENT return False NEW_LINE DEDENT prev_count = curr_count NEW_LINE DEDENT return True NEW_LINE DEDENT n = 18 NEW_LINE if areSetBitsIncreasing ( n ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT

BLEU: 86.47
Edit Sim: 21


Src: 
long operation ( int arr [ ] , int N ) { int right = 0 ; int num = 0 ; long ans = 0 ; for ( int left = 0 ; left < N ; left ++ ) { while ( right < N && num + arr [ right ] == ( num ^ arr [ right ] ) ) { num += arr [ right ] ; right ++ ; } ans += right - left ; if ( left == right ) right ++ ; else num -= arr [ left ] ; } return ans ; }
Ref: 
def operation ( arr , N ) : NEW_LINE INDENT right = 0 ; ans = 0 ; NEW_LINE num = 0 ; NEW_LINE for left in range ( 0 , N ) : NEW_LINE INDENT while ( right < N and num + arr [ right ] == ( num ^ arr [ right ] ) ) : NEW_LINE INDENT num += arr [ right ] ; NEW_LINE right += 1 ; NEW_LINE DEDENT ans += right - left ; NEW_LINE if ( left == right ) : NEW_LINE INDENT right += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT num -= arr [ left ] ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT
Hyp: 
def operation ( arr , N ) : NEW_LINE INDENT right = 0 NEW_LINE num = 0 NEW_LINE ans = 0 NEW_LINE for left in range ( N ) : NEW_LINE INDENT while ( right < N and num + arr [ right ] == ( num ^ arr [ right ] ) ) : NEW_LINE INDENT num += arr [ right ] NEW_LINE right += 1 NEW_LINE DEDENT ans += right - left NEW_LINE if ( left == right ) : NEW_LINE INDENT right += 1 NEW_LINE DEDENT else : NEW_LINE INDENT num -= arr [ left ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT

BLEU: 76.72
Edit Sim: 34


Src: 
int exponentMod ( int A , int B , int C ) { if ( A == 0 ) return 0 ; if ( B == 0 ) return 1 ; long y ; if ( B % 2 == 0 ) { y = exponentMod ( A , B / 2 , C ) ; y = ( y * y ) % C ; } else { y = A % C ; y = ( y * exponentMod ( A , B - 1 , C ) % C ) % C ; } return ( int ) ( ( y + C ) % C ) ; }
Ref: 
def exponentMod ( A , B , C ) : NEW_LINE INDENT if ( A == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( B == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT y = 0 NEW_LINE if ( B % 2 == 0 ) : NEW_LINE INDENT y = exponentMod ( A , B / 2 , C ) NEW_LINE y = ( y * y ) % C NEW_LINE DEDENT else : NEW_LINE INDENT y = A % C NEW_LINE y = ( y * exponentMod ( A , B - 1 , C ) % C ) % C NEW_LINE DEDENT return ( ( y + C ) % C ) NEW_LINE DEDENT
Hyp: 
def exponentMod ( A , B , C ) : NEW_LINE INDENT if ( A == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( B == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT y = 0 NEW_LINE if ( B % 2 == 0 ) : NEW_LINE INDENT y = exponentMod ( A , B / 2 , C ) NEW_LINE y = ( y * y ) % C NEW_LINE DEDENT else : NEW_LINE INDENT y = A % C NEW_LINE y = ( y * exponentMod ( A , B - 1 , C ) % C ) % C NEW_LINE DEDENT return ( int ) ( ( y + C ) % C ) NEW_LINE DEDENT

BLEU: 96.96
Edit Sim: 8


Src: 
boolean isValidISBN ( String isbn ) { int n = isbn . length ( ) ; if ( n != 10 ) return false ; int sum = 0 ; for ( int i = 0 ; i < 9 ; i ++ ) { int digit = isbn . charAt ( i ) - '0' ; if ( 0 > digit 9 < digit ) return false ; sum += ( digit * ( 10 - i ) ) ; } char last = isbn . charAt ( 9 ) ; if ( last != ' X ' && ( last < '0' last > '9' ) ) return false ; sum += ( ( last == ' X ' ) ? 10 : ( last - '0' ) ) ; return ( sum % 11 == 0 ) ; }
Ref: 
def isValidISBN ( isbn ) : NEW_LINE INDENT if len ( isbn ) != 10 : NEW_LINE INDENT return False NEW_LINE DEDENT _sum = 0 NEW_LINE for i in range ( 9 ) : NEW_LINE INDENT if 0 <= int ( isbn [ i ] ) <= 9 : NEW_LINE INDENT _sum += int ( isbn [ i ] ) * ( 10 - i ) NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if ( isbn [ 9 ] != ' X ' and 0 <= int ( isbn [ 9 ] ) <= 9 ) : NEW_LINE INDENT return False NEW_LINE DEDENT _sum += 10 if isbn [ 9 ] == ' X ' else int ( isbn [ 9 ] ) NEW_LINE return ( _sum % 11 == 0 ) NEW_LINE DEDENT isbn = "007462542X " NEW_LINE if isValidISBN ( isbn ) : NEW_LINE INDENT print ( ' Valid ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Invalid " ) NEW_LINE DEDENT
Hyp: 
def isValidISBN ( isbn ) : NEW_LINE INDENT n = len ( isbn ) NEW_LINE if ( n != 10 ) : NEW_LINE INDENT return False NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( 9 ) : NEW_LINE INDENT digit = ord ( isbn [ i ] ) - ord ( '0' ) NEW_LINE if ( 0 > digit 9 < digit ) : NEW_LINE INDENT return False NEW_LINE DEDENT sum += ( digit * ( 10 - i ) ) NEW_LINE DEDENT last = isbn [ 9 ] NEW_LINE if ( last != ' X ' and ( last < '0' or last > '9' ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT sum += ( ( last == ' X ' ) else ( last - '0' ) ) NEW_LINE return ( sum % 11 == 0 ) NEW_LINE DEDENT

BLEU: 40.84
Edit Sim: 342


Src: 
int minimumflip ( int mat [ ] [ ] , int n ) { int transpose [ ] [ ] = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) transpose [ i ] [ j ] = mat [ j ] [ i ] ; int flip = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( transpose [ i ] [ j ] != mat [ i ] [ j ] ) flip ++ ; return flip / 2 ; }
Ref: 
def minimumflip ( mat , n ) : NEW_LINE INDENT transpose = [ [ 0 ] * n ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT transpose [ i ] [ j ] = mat [ j ] [ i ] NEW_LINE DEDENT DEDENT flip = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if transpose [ i ] [ j ] != mat [ i ] [ j ] : NEW_LINE INDENT flip += 1 NEW_LINE DEDENT DEDENT DEDENT return int ( flip / 2 ) NEW_LINE DEDENT
Hyp: 
def minimumflip ( mat , n ) : NEW_LINE INDENT transpose = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT transpose [ i ] [ j ] = mat [ j ] [ i ] NEW_LINE DEDENT flip = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( transpose [ i ] [ j ] != mat [ i ] [ j ] ) : NEW_LINE INDENT flip += 1 NEW_LINE DEDENT DEDENT DEDENT return flip // 2 NEW_LINE DEDENT

BLEU: 81.49
Edit Sim: 48


Src: 
int sumDivisibles ( int A , int B , int M ) { int sum = 0 ; for ( int i = A ; i <= B ; i ++ ) if ( i % M == 0 ) sum += i ; return sum ; }
Ref: 
def sumDivisibles ( A , B , M ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( A , B + 1 ) : NEW_LINE INDENT if ( i % M == 0 ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
Hyp: 
def sumDivisibles ( A , B , M ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( A , B + 1 ) : NEW_LINE INDENT if ( i % M == 0 ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
void sumOfTwoPerfectCubes ( int N ) { HashMap < Integer , Integer > cubes = new HashMap < > ( ) ; for ( int i = 1 ; i * i * i <= N ; i ++ ) cubes . put ( ( i * i * i ) , i ) ; Iterator < Map . Entry < Integer , Integer > > itr = cubes . entrySet ( ) . iterator ( ) ; while ( itr . hasNext ( ) ) { Map . Entry < Integer , Integer > entry = itr . next ( ) ; int firstNumber = entry . getKey ( ) ; int secondNumber = N - entry . getKey ( ) ; if ( cubes . containsKey ( secondNumber ) ) { System . out . println ( " True " ) ; return ; } } System . out . println ( " False " ) ; }
Ref: 
def sumOfTwoPerfectCubes ( N ) : NEW_LINE INDENT cubes = { } NEW_LINE i = 1 NEW_LINE while i * i * i <= N : NEW_LINE INDENT cubes [ i * i * i ] = i NEW_LINE i += 1 NEW_LINE DEDENT for itr in cubes : NEW_LINE INDENT firstNumber = itr NEW_LINE secondNumber = N - itr NEW_LINE if secondNumber in cubes : NEW_LINE INDENT print ( " True " , end = " " ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( " False " , end = " " ) NEW_LINE DEDENT
Hyp: 
def sumOfTwoPerfectCubes ( N ) : NEW_LINE INDENT cubes = dict ( ) NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT if i * i * i > N : NEW_LINE INDENT cubes [ ( i * i * i ) ] = i NEW_LINE DEDENT else : NEW_LINE INDENT cubes [ ( i * i * i ) ] = i NEW_LINE DEDENT DEDENT itr = cubes . iterator ( ) NEW_LINE while ( hasNext ( ) ) : NEW_LINE INDENT firstNumber = entry . getKey ( ) NEW_LINE secondNumber = N - entry . getKey ( ) NEW_LINE if ( cubes [ secondNumber ] ) : NEW_LINE INDENT print ( " True " ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( " False " ) NEW_LINE DEDENT

BLEU: 39.19
Edit Sim: 224


Src: 
float AvgofSquareN ( int n ) { float sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += ( i * i ) ; return sum / n ; }
Ref: 
def AvgofSquareN ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += ( i * i ) NEW_LINE DEDENT return sum / n NEW_LINE DEDENT
Hyp: 
def AvgofSquareN ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += ( i * i ) NEW_LINE DEDENT return sum / n NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
void minimumSteps ( int x , int y ) { int cnt = 0 ; while ( x != 0 && y != 0 ) { if ( x > y ) { cnt += x / y ; x %= y ; } else { cnt += y / x ; y %= x ; } } cnt -- ; if ( x > 1 y > 1 ) cnt = - 1 ; System . out . println ( cnt ) ; }
Ref: 
def minimumSteps ( x , y ) : NEW_LINE INDENT cnt = 0 NEW_LINE while ( x != 0 and y != 0 ) : NEW_LINE INDENT if ( x > y ) : NEW_LINE INDENT cnt += x / y NEW_LINE x %= y NEW_LINE DEDENT else : NEW_LINE INDENT cnt += y / x NEW_LINE y %= x NEW_LINE DEDENT DEDENT cnt -= 1 NEW_LINE if ( x > 1 or y > 1 ) : NEW_LINE INDENT cnt = - 1 NEW_LINE DEDENT print ( int ( cnt ) ) NEW_LINE DEDENT
Hyp: 
def minimumSteps ( x , y ) : NEW_LINE INDENT cnt = 0 NEW_LINE while ( x != 0 and y != 0 ) : NEW_LINE INDENT if ( x > y ) : NEW_LINE INDENT cnt += x // y NEW_LINE x %= y NEW_LINE DEDENT else : NEW_LINE INDENT cnt += y // x NEW_LINE y %= x NEW_LINE DEDENT DEDENT cnt -= 1 NEW_LINE if ( x > 1 or y > 1 ) : NEW_LINE INDENT cnt = - 1 NEW_LINE DEDENT print ( cnt ) NEW_LINE DEDENT

BLEU: 89.77
Edit Sim: 10


Src: 
int minimumcoins ( int arr [ ] , int N ) { int coins = 0 ; int j = 0 ; if ( arr [ 0 ] == 1 ) coins ++ ; for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] == 2 ) continue ; j = i ; while ( j < N && arr [ j ] == 1 ) { j ++ ; } int x = ( j - i ) ; coins += x / 3 ; i = j - 1 ; } return coins ; }
Ref: 
def minimumcoins ( arr , N ) : NEW_LINE INDENT coins = 0 NEW_LINE j = 0 NEW_LINE if ( arr [ 0 ] == 1 ) : NEW_LINE INDENT coins += 1 NEW_LINE DEDENT for i in range ( 1 , N ) : NEW_LINE INDENT if ( arr [ i ] == 2 ) : NEW_LINE INDENT continue NEW_LINE DEDENT j = i NEW_LINE while ( j < N and arr [ j ] == 1 ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT x = ( j - i ) NEW_LINE coins += x // 3 NEW_LINE i = j - 1 NEW_LINE DEDENT return coins NEW_LINE DEDENT
Hyp: 
def minimumcoins ( arr , N ) : NEW_LINE INDENT coins = 0 NEW_LINE j = 0 NEW_LINE if arr [ 0 ] == 1 : NEW_LINE INDENT coins += 1 NEW_LINE DEDENT for i in range ( 1 , N ) : NEW_LINE INDENT if arr [ i ] == 2 : NEW_LINE INDENT continue NEW_LINE DEDENT j = i NEW_LINE while j < N and arr [ j ] == 1 : NEW_LINE INDENT j += 1 NEW_LINE DEDENT x = ( j - i ) NEW_LINE coins += x // 3 NEW_LINE i = j - 1 NEW_LINE DEDENT return coins NEW_LINE DEDENT

BLEU: 86.16
Edit Sim: 12


Src: 
int countSetBits ( int n ) { n ++ ; int powerOf2 = 2 ; int cnt = n / 2 ; while ( powerOf2 <= n ) { int totalPairs = n / powerOf2 ; cnt += ( totalPairs / 2 ) * powerOf2 ; cnt += ( totalPairs % 2 == 1 ) ? ( n % powerOf2 ) : 0 ; powerOf2 <<= 1 ; } return cnt ; }
Ref: 
def countSetBits ( n ) : NEW_LINE INDENT n += 1 ; NEW_LINE powerOf2 = 2 ; NEW_LINE cnt = n // 2 ; NEW_LINE while ( powerOf2 <= n ) : NEW_LINE INDENT totalPairs = n // powerOf2 ; NEW_LINE cnt += ( totalPairs // 2 ) * powerOf2 ; NEW_LINE if ( totalPairs & 1 ) : NEW_LINE INDENT cnt += ( n % powerOf2 ) NEW_LINE DEDENT else : NEW_LINE INDENT cnt += 0 NEW_LINE DEDENT powerOf2 <<= 1 ; NEW_LINE DEDENT return cnt ; NEW_LINE DEDENT
Hyp: 
def countSetBits ( n ) : NEW_LINE INDENT n += 1 NEW_LINE powerOf2 = 2 NEW_LINE cnt = n // 2 NEW_LINE while ( powerOf2 <= n ) : NEW_LINE INDENT totalPairs = n // powerOf2 NEW_LINE cnt += ( totalPairs // 2 ) * powerOf2 NEW_LINE cnt += ( totalPairs % 2 == 1 ) ? ( n % powerOf2 ) : 0 NEW_LINE powerOf2 <<= 1 NEW_LINE DEDENT return cnt NEW_LINE DEDENT

BLEU: 55.01
Edit Sim: 96


Src: 
int getPeriod ( int n ) { int rem = 1 ; for ( int i = 1 ; i <= n + 1 ; i ++ ) rem = ( 10 * rem ) % n ; int d = rem ; int count = 0 ; do { rem = ( 10 * rem ) % n ; count ++ ; } while ( rem != d ) ; return count ; }
Ref: 
def getPeriod ( n ) : NEW_LINE INDENT rem = 1 NEW_LINE for i in range ( 1 , n + 2 ) : NEW_LINE INDENT rem = ( 10 * rem ) % n NEW_LINE DEDENT d = rem NEW_LINE count = 0 NEW_LINE rem = ( 10 * rem ) % n NEW_LINE count += 1 NEW_LINE while rem != d : NEW_LINE INDENT rem = ( 10 * rem ) % n NEW_LINE count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
Hyp: 
def getPeriod ( n ) : NEW_LINE INDENT rem = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT rem = ( 10 * rem ) % n NEW_LINE DEDENT d = rem NEW_LINE count = 0 NEW_LINE while ( rem != d ) : NEW_LINE INDENT rem = ( 10 * rem ) % n NEW_LINE count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT

BLEU: 76.05
Edit Sim: 57


Src: 
int spiralDiaSum ( int n ) { if ( n == 1 ) return 1 ; return ( 4 * n * n - 6 * n + 6 + spiralDiaSum ( n - 2 ) ) ; }
Ref: 
def spiralDiaSum ( n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT return ( 4 * n * n - 6 * n + 6 + spiralDiaSum ( n - 2 ) ) NEW_LINE DEDENT
Hyp: 
def spiralDiaSum ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return ( 4 * n * n - 6 * n + 6 + spiralDiaSum ( n - 2 ) ) NEW_LINE DEDENT

BLEU: 88.2
Edit Sim: 4


Src: 
int findMinMax ( int [ ] a ) { int min_val = 1000000000 ; for ( int i = 1 ; i < a . length ; ++ i ) { min_val = Math . min ( min_val , a [ i ] * a [ i - 1 ] ) ; } return min_val ; }
Ref: 
def findMinMax ( a ) : NEW_LINE INDENT min_val = 1000000000 NEW_LINE for i in range ( 1 , len ( a ) ) : NEW_LINE INDENT min_val = min ( min_val , a [ i ] * a [ i - 1 ] ) NEW_LINE DEDENT return min_val NEW_LINE DEDENT
Hyp: 
def findMinMax ( a ) : NEW_LINE INDENT min_val = 1000000000 ; NEW_LINE for i in range ( 1 , len ( a ) ) : NEW_LINE INDENT min_val = min ( min_val , a [ i ] * a [ i - 1 ] ) ; NEW_LINE DEDENT return min_val ; NEW_LINE DEDENT

BLEU: 86.12
Edit Sim: 6


Src: 
int distribution ( int arr [ ] , int n ) { Set < Integer > resources = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) resources . add ( arr [ i ] ) ; return Math . min ( resources . size ( ) , n / 2 ) ; }
Ref: 
def distribution ( arr , n ) : NEW_LINE INDENT resources = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT resources . add ( arr [ i ] ) ; NEW_LINE DEDENT return min ( len ( resources ) , n // 2 ) ; NEW_LINE DEDENT
Hyp: 
def distribution ( arr , n ) : NEW_LINE INDENT resources = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT resources . add ( arr [ i ] ) NEW_LINE DEDENT return min ( len ( resources ) , n // 2 ) NEW_LINE DEDENT

BLEU: 90.76
Edit Sim: 4


Src: 
void checkPascaltriangle ( int N ) { double x = ( Math . sqrt ( 8 * N + 1 ) - 1 ) / 2 ; if ( Math . ceil ( x ) - x == 0 ) System . out . print ( " Yes " ) ; else System . out . print ( " No " ) ; }
Ref: 
def checkPascaltriangle ( N ) : NEW_LINE INDENT x = ( math . sqrt ( 8 * N + 1 ) - 1 ) / 2 NEW_LINE if ( math . ceil ( x ) - x == 0 ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
Hyp: 
def checkPascaltriangle ( N ) : NEW_LINE INDENT x = ( math . sqrt ( 8 * N + 1 ) - 1 ) / 2 NEW_LINE if ( math . ceil ( x ) - x == 0 ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int nondecdigits ( int n ) { int x = 0 ; for ( x = n ; x >= 1 ; x -- ) { int no = x ; int prev_dig = 11 ; boolean flag = true ; while ( no != 0 ) { if ( prev_dig < no % 10 ) { flag = false ; break ; } prev_dig = no % 10 ; no /= 10 ; } if ( flag == true ) break ; } return x ; }
Ref: 
def nondecdigits ( n ) : NEW_LINE INDENT x = 0 NEW_LINE for x in range ( n , 0 , - 1 ) : NEW_LINE INDENT no = x NEW_LINE prev_dig = 11 NEW_LINE flag = True NEW_LINE while ( no != 0 ) : NEW_LINE INDENT if ( prev_dig < no % 10 ) : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT prev_dig = no % 10 NEW_LINE no //= 10 NEW_LINE DEDENT if ( flag == True ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return x NEW_LINE DEDENT
Hyp: 
def nondecdigits ( n ) : NEW_LINE INDENT x = 0 NEW_LINE while x >= 1 : NEW_LINE INDENT no = x NEW_LINE prev_dig = 11 NEW_LINE flag = True NEW_LINE while no != 0 : NEW_LINE INDENT if prev_dig < no % 10 : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT prev_dig = no % 10 NEW_LINE no /= 10 NEW_LINE DEDENT if flag == True : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return x NEW_LINE DEDENT

BLEU: 65.56
Edit Sim: 37


Src: 
double Nth_Term ( int n ) { return ( 2 * Math . pow ( n , 3 ) - 3 * Math . pow ( n , 2 ) + n + 6 ) / 6 ; }
Ref: 
def Nth_Term ( n ) : NEW_LINE INDENT return ( 2 * pow ( n , 3 ) - 3 * pow ( n , 2 ) + n + 6 ) // 6 NEW_LINE DEDENT
Hyp: 
def Nth_Term ( n ) : NEW_LINE INDENT return ( 2 * pow ( n , 3 ) - 3 * pow ( n , 2 ) + n + 6 ) // 6 NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
void solve ( int n ) { int upper_limit = ( int ) ( Math . ceil ( Math . pow ( n , 1.0 / 4 ) ) ) ; for ( int x = 0 ; x <= upper_limit ; x ++ ) { for ( int y = 0 ; y <= upper_limit ; y ++ ) { int num1 = x * x * x * x ; int num2 = y * y * y * y ; if ( num1 - num2 == n ) { System . out . print ( " x ▁ = ▁ " + x + " , ▁ y ▁ = ▁ " + y ) ; return ; } } } System . out . print ( - 1 ) ; }
Ref: 
def solve ( n ) : NEW_LINE INDENT upper_limit = ceil ( pow ( n , 1.0 / 4 ) ) ; NEW_LINE for x in range ( upper_limit + 1 ) : NEW_LINE INDENT for y in range ( upper_limit + 1 ) : NEW_LINE INDENT num1 = x * x * x * x ; NEW_LINE num2 = y * y * y * y ; NEW_LINE if ( num1 - num2 == n ) : NEW_LINE INDENT print ( " x ▁ = " , x , " , ▁ y ▁ = " , y ) ; NEW_LINE return ; NEW_LINE DEDENT DEDENT DEDENT print ( - 1 ) ; NEW_LINE DEDENT
Hyp: 
def solve ( n ) : NEW_LINE INDENT upper_limit = int ( math . ceil ( math . pow ( n , 1 / 4 ) ) ) NEW_LINE for x in range ( upper_limit + 1 ) : NEW_LINE INDENT for y in range ( upper_limit + 1 ) : NEW_LINE INDENT num1 = x * x * x * x NEW_LINE num2 = y * y * y NEW_LINE if ( num1 - num2 == n ) : NEW_LINE INDENT print ( " x ▁ = " , x , " , ▁ y ▁ = " , y ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT print ( - 1 ) NEW_LINE return NEW_LINE DEDENT

BLEU: 80.0
Edit Sim: 50


Src: 
boolean checkMarkov ( double m [ ] [ ] ) { for ( int i = 0 ; i < m . length ; i ++ ) { double sum = 0 ; for ( int j = 0 ; j < m [ i ] . length ; j ++ ) sum = sum + m [ i ] [ j ] ; if ( sum != 1 ) return false ; } return true ; }
Ref: 
def checkMarkov ( m ) : NEW_LINE INDENT for i in range ( 0 , len ( m ) ) : NEW_LINE INDENT sm = 0 NEW_LINE for j in range ( 0 , len ( m [ i ] ) ) : NEW_LINE INDENT sm = sm + m [ i ] [ j ] NEW_LINE DEDENT if ( sm != 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT m = [ [ 0 , 0 , 1 ] , [ 0.5 , 0 , 0.5 ] , [ 1 , 0 , 0 ] ] NEW_LINE if ( checkMarkov ( m ) ) : NEW_LINE INDENT print ( " ▁ yes ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " ▁ no ▁ " ) NEW_LINE DEDENT
Hyp: 
def checkMarkov ( m ) : NEW_LINE INDENT for i in range ( len ( m ) ) : NEW_LINE INDENT sum = 0 NEW_LINE for j in range ( len ( m ) ) : NEW_LINE INDENT sum = sum + m [ i ] [ j ] NEW_LINE DEDENT if ( sum != 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT

BLEU: 29.81
Edit Sim: 226


Src: 
int area_fun ( int side ) { int area = side * side ; return area ; }
Ref: 
def area_fun ( side ) : NEW_LINE INDENT area = side * side NEW_LINE return area NEW_LINE DEDENT
Hyp: 
def area_fun ( side ) : NEW_LINE INDENT area = side * side NEW_LINE return area NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
void generateSequence ( int n , int g ) { for ( int i = 1 ; i <= n ; i ++ ) System . out . print ( i * g + " ▁ " ) ; ; }
Ref: 
def generateSequence ( n , g ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( i * g , end = " ▁ " ) NEW_LINE DEDENT DEDENT
Hyp: 
def generateSequence ( n , g ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( ( i + 1 ) * g , end = " ▁ " ) NEW_LINE DEDENT DEDENT

BLEU: 85.68
Edit Sim: 8


Src: 
int countTriplets ( int n , int sum ) { int ans = 0 ; for ( int i = 0 ; i < n - 2 ; i ++ ) { for ( int j = i + 1 ; j < n - 1 ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) if ( arr [ i ] + arr [ j ] + arr [ k ] < sum ) ans ++ ; } } return ans ; }
Ref: 
def countTriplets ( arr , n , sum ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 0 , n - 2 ) : NEW_LINE INDENT for j in range ( i + 1 , n - 1 ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] + arr [ j ] + arr [ k ] < sum ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
Hyp: 
def countTriplets ( arr , n , sum ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n - 2 ) : NEW_LINE INDENT for j in range ( i + 1 , n - 1 ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] + arr [ j ] + arr [ k ] < sum ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT

BLEU: 95.13
Edit Sim: 11


Src: 
void length_of_chord ( double r , double x ) { System . out . println ( " The ▁ length ▁ of ▁ the ▁ chord " + " ▁ of ▁ the ▁ circle ▁ is ▁ " + 2 * r * Math . sin ( x * ( 3.14 / 180 ) ) ) ; }
Ref: 
def length_of_chord ( r , x ) : NEW_LINE INDENT print ( " The ▁ length ▁ of ▁ the ▁ chord " , " ▁ of ▁ the ▁ circle ▁ is ▁ " , 2 * r * mt . sin ( x * ( 3.14 / 180 ) ) ) NEW_LINE DEDENT
Hyp: 
def length_of_chord ( r , x ) : NEW_LINE INDENT print ( " The ▁ length ▁ of ▁ the ▁ chord " , " ▁ of ▁ the ▁ circle ▁ is ▁ " , 2 * r * math . sin ( x * ( 3.14 / 180 ) ) ) NEW_LINE DEDENT

BLEU: 95.34
Edit Sim: 2


Src: 
int maxSquare ( int b , int m ) { return ( b / m - 1 ) * ( b / m ) / 2 ; }
Ref: 
def maxSquare ( b , m ) : NEW_LINE INDENT return ( b / m - 1 ) * ( b / m ) / 2 NEW_LINE DEDENT
Hyp: 
def maxSquare ( b , m ) : NEW_LINE INDENT return ( b // m - 1 ) * ( b // m ) // 2 NEW_LINE DEDENT

BLEU: 72.15
Edit Sim: 3


Src: 
int remAnagram ( String str1 , String str2 ) { int count1 [ ] = new int [ 26 ] ; int count2 [ ] = new int [ 26 ] ; for ( int i = 0 ; i < str1 . length ( ) ; i ++ ) count1 [ str1 . charAt ( i ) - ' a ' ] ++ ; for ( int i = 0 ; i < str2 . length ( ) ; i ++ ) count2 [ str2 . charAt ( i ) - ' a ' ] ++ ; int result = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) result += Math . abs ( count1 [ i ] - count2 [ i ] ) ; return result ; }
Ref: 
def remAnagram ( str1 , str2 ) : NEW_LINE INDENT count1 = [ 0 ] * CHARS NEW_LINE count2 = [ 0 ] * CHARS NEW_LINE i = 0 NEW_LINE while i < len ( str1 ) : NEW_LINE INDENT count1 [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE i += 1 NEW_LINE DEDENT i = 0 NEW_LINE while i < len ( str2 ) : NEW_LINE INDENT count2 [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE i += 1 NEW_LINE DEDENT result = 0 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT result += abs ( count1 [ i ] - count2 [ i ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT
Hyp: 
def remAnagram ( str1 , str2 ) : NEW_LINE INDENT count1 = [ 0 ] * 26 ; NEW_LINE count2 = [ 0 ] * 26 ; NEW_LINE for i in str1 : NEW_LINE INDENT count1 [ ord ( i ) - ord ( ' a ' ) ] = ( count1 [ ord ( i ) - ord ( ' a ' ) ] ) + 1 ; NEW_LINE DEDENT for i in str2 : NEW_LINE INDENT count2 [ ord ( i ) - ord ( ' a ' ) ] += 1 ; NEW_LINE DEDENT result = 0 ; NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT result += abs ( count1 [ i ] - count2 [ i ] ) ; NEW_LINE DEDENT return result ; NEW_LINE DEDENT

BLEU: 59.98
Edit Sim: 130


Src: 
int minimumSizeArr ( int A , int B ) { int currXor = 0 ; int reminder = ( A - 1 ) % 4 ; if ( reminder == 0 ) currXor = A - 1 ; else if ( reminder == 1 ) currXor = 1 ; else if ( reminder == 2 ) currXor = A ; int minSize = A ; if ( currXor == B ) return minSize ; else if ( ( currXor ^ B ) == A ) return minSize + 2 ; else return minSize + 1 ; }
Ref: 
def minimumSizeArr ( A , B ) : NEW_LINE INDENT currXor = 0 NEW_LINE reminder = ( A - 1 ) % 4 NEW_LINE if ( reminder == 0 ) : NEW_LINE INDENT currXor = A - 1 NEW_LINE DEDENT elif ( reminder == 1 ) : NEW_LINE INDENT currXor = 1 NEW_LINE DEDENT elif ( reminder == 2 ) : NEW_LINE INDENT currXor = A NEW_LINE DEDENT minSize = A NEW_LINE if ( currXor == B ) : NEW_LINE INDENT return minSize NEW_LINE DEDENT elif ( currXor ^ B == A ) : NEW_LINE INDENT return minSize + 2 NEW_LINE DEDENT else : NEW_LINE INDENT return minSize + 1 NEW_LINE DEDENT DEDENT
Hyp: 
def minimumSizeArr ( A , B ) : NEW_LINE INDENT currXor = 0 NEW_LINE reminder = ( A - 1 ) % 4 NEW_LINE if ( reminder == 0 ) : NEW_LINE INDENT currXor = A - 1 NEW_LINE DEDENT elif ( reminder == 1 ) : NEW_LINE INDENT currXor = 1 NEW_LINE DEDENT elif ( reminder == 2 ) : NEW_LINE INDENT currXor = A NEW_LINE DEDENT minSize = A NEW_LINE if ( currXor == B ) : NEW_LINE INDENT return minSize NEW_LINE DEDENT elif ( ( currXor ^ B ) == A ) : NEW_LINE INDENT return minSize + 2 NEW_LINE DEDENT else : NEW_LINE INDENT return minSize + 1 NEW_LINE DEDENT DEDENT

BLEU: 96.26
Edit Sim: 4


Src: 
double minRevolutions ( double r , int x1 , int y1 , int x2 , int y2 ) { double d = Math . sqrt ( ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ) ; return Math . ceil ( d / ( 2 * r ) ) ; }
Ref: 
def minRevolutions ( r , x1 , y1 , x2 , y2 ) : NEW_LINE INDENT d = math . sqrt ( ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ) NEW_LINE return math . ceil ( d / ( 2 * r ) ) NEW_LINE DEDENT
Hyp: 
def minRevolutions ( r , x1 , y1 , x2 , y2 ) : NEW_LINE INDENT d = math . sqrt ( ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ) NEW_LINE return math . ceil ( d / ( 2 * r ) ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int numberOfPermWithKInversion ( int N , int K ) { if ( N == 0 ) return 0 ; if ( K == 0 ) return 1 ; if ( memo [ N ] [ K ] != 0 ) return memo [ N ] [ K ] ; int sum = 0 ; for ( int i = 0 ; i <= K ; i ++ ) { if ( i <= N - 1 ) sum += numberOfPermWithKInversion ( N - 1 , K - i ) ; } memo [ N ] [ K ] = sum ; return sum ; }
Ref: 
def numberOfPermWithKInversion ( N , K ) : NEW_LINE INDENT if ( N == 0 ) : return 0 NEW_LINE if ( K == 0 ) : return 1 NEW_LINE if ( memo [ N ] [ K ] != 0 ) : NEW_LINE INDENT return memo [ N ] [ K ] NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( K + 1 ) : NEW_LINE INDENT if ( i <= N - 1 ) : NEW_LINE INDENT sum += numberOfPermWithKInversion ( N - 1 , K - i ) NEW_LINE DEDENT DEDENT memo [ N ] [ K ] = sum NEW_LINE return sum NEW_LINE DEDENT
Hyp: 
def numberOfPermWithKInversion ( N , K ) : NEW_LINE INDENT if ( N == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( K == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( memo [ N ] [ K ] != 0 ) : NEW_LINE INDENT return memo [ N ] [ K ] NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( K + 1 ) : NEW_LINE INDENT if ( i <= N - 1 ) : NEW_LINE INDENT sum += numberOfPermWithKInversion ( N - 1 , K - i ) NEW_LINE DEDENT DEDENT memo [ N ] [ K ] = sum NEW_LINE return sum NEW_LINE DEDENT

BLEU: 89.58
Edit Sim: 46


Src: 
float circlearea ( float l , float b ) { if ( l < 0 b < 0 ) return - 1 ; if ( l < b ) return ( float ) ( 3.14 * Math . pow ( l / 2 , 2 ) ) ; else return ( float ) ( 3.14 * Math . pow ( b / 2 , 2 ) ) ; }
Ref: 
def circlearea ( l , b ) : NEW_LINE INDENT if ( l < 0 or b < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( l < b ) : NEW_LINE INDENT return 3.14 * pow ( l // 2 , 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT return 3.14 * pow ( b // 2 , 2 ) NEW_LINE DEDENT DEDENT
Hyp: 
def circlearea ( l , b ) : NEW_LINE INDENT if l < 0 or b < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if l < b : NEW_LINE INDENT return ( 3.14 * pow ( l / 2 , 2 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( 3.14 * pow ( b / 2 , 2 ) ) NEW_LINE DEDENT DEDENT

BLEU: 69.99
Edit Sim: 18


Src: 
int countP ( int n , int k ) { if ( n == 0 k == 0 k > n ) return 0 ; if ( k == 1 k == n ) return 1 ; return ( k * countP ( n - 1 , k ) + countP ( n - 1 , k - 1 ) ) ; }
Ref: 
def countP ( n , k ) : NEW_LINE INDENT if ( n == 0 or k == 0 or k > n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( k == 1 or k == n ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return ( k * countP ( n - 1 , k ) + countP ( n - 1 , k - 1 ) ) NEW_LINE DEDENT
Hyp: 
def countP ( n , k ) : NEW_LINE INDENT if ( n == 0 or k == 0 or k > n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( k == 1 or k == n ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return ( k * countP ( n - 1 , k ) + countP ( n - 1 , k - 1 ) ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int countSol ( int coeff [ ] , int start , int end , int rhs ) { if ( rhs == 0 ) return 1 ; int result = 0 ; for ( int i = start ; i <= end ; i ++ ) if ( coeff [ i ] <= rhs ) result += countSol ( coeff , i , end , rhs - coeff [ i ] ) ; return result ; }
Ref: 
def countSol ( coeff , start , end , rhs ) : NEW_LINE INDENT if ( rhs == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT result = 0 NEW_LINE for i in range ( start , end + 1 ) : NEW_LINE INDENT if ( coeff [ i ] <= rhs ) : NEW_LINE INDENT result += countSol ( coeff , i , end , rhs - coeff [ i ] ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
Hyp: 
def countSol ( coeff , start , end , rhs ) : NEW_LINE INDENT if ( rhs == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT result = 0 NEW_LINE for i in range ( start , end + 1 ) : NEW_LINE INDENT if ( coeff [ i ] <= rhs ) : NEW_LINE INDENT result += countSol ( coeff , i , end , rhs - coeff [ i ] ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int minCost ( int a [ ] , int n , int k ) { int dp [ ] [ ] = new int [ n + 1 ] [ k + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= k ; j ++ ) dp [ i ] [ j ] = inf ; dp [ 0 ] [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= k ; j ++ ) for ( int m = i - 1 ; m >= 0 ; m -- ) dp [ i ] [ j ] = Math . min ( dp [ i ] [ j ] , dp [ m ] [ j - 1 ] + ( a [ i - 1 ] - a [ m ] ) * ( a [ i - 1 ] - a [ m ] ) ) ; return dp [ n ] [ k ] ; }
Ref: 
def minCost ( a , n , k ) : NEW_LINE INDENT dp = [ [ inf for i in range ( k + 1 ) ] for j in range ( n + 1 ) ] ; NEW_LINE dp [ 0 ] [ 0 ] = 0 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , k + 1 ) : NEW_LINE INDENT for m in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ m ] [ j - 1 ] + ( a [ i - 1 ] - a [ m ] ) * ( a [ i - 1 ] - a [ m ] ) ) ; NEW_LINE DEDENT DEDENT DEDENT return dp [ n ] [ k ] ; NEW_LINE DEDENT
Hyp: 
def minCost ( a , n , k ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( k + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( k + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = inf NEW_LINE DEDENT DEDENT dp [ 0 ] [ 0 ] = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , k + 1 ) : NEW_LINE INDENT for m in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ m ] [ j - 1 ] + ( a [ i - 1 ] - a [ m ] ) * ( a [ i - 1 ] - a [ m ] ) ) NEW_LINE DEDENT DEDENT return dp [ n ] [ k ] NEW_LINE DEDENT

BLEU: 77.08
Edit Sim: 143


Src: 
int countXOR ( int n ) { int count0 = 0 , count1 = 0 ; while ( n != 0 ) { if ( n % 2 == 0 ) count0 ++ ; else count1 ++ ; n /= 2 ; } return ( count0 ^ count1 ) ; }
Ref: 
def countXOR ( n ) : NEW_LINE INDENT count0 , count1 = 0 , 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT count0 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count1 += 1 NEW_LINE DEDENT n //= 2 NEW_LINE DEDENT return ( count0 ^ count1 ) NEW_LINE DEDENT
Hyp: 
def countXOR ( n ) : NEW_LINE INDENT count0 = 0 NEW_LINE count1 = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT count0 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count1 += 1 NEW_LINE DEDENT n //= 2 NEW_LINE DEDENT return ( count0 ^ count1 ) NEW_LINE DEDENT

BLEU: 91.86
Edit Sim: 16


Src: 
void findTemperature ( int x , int y , int s ) { double Day1 , Day2 ; double diff = ( x - y ) * 6 ; Day2 = ( diff + s ) / 2 ; Day1 = s - Day2 ; System . out . println ( " Day1 ▁ : ▁ " + Day1 ) ; System . out . println ( " Day2 ▁ : ▁ " + Day2 ) ; }
Ref: 
def findTemperature ( x , y , s ) : NEW_LINE INDENT diff = ( x - y ) * 6 NEW_LINE Day2 = ( diff + s ) // 2 NEW_LINE Day1 = s - Day2 NEW_LINE print ( " Day1 ▁ : ▁ " , Day1 ) NEW_LINE print ( " Day2 ▁ : ▁ " , Day2 ) NEW_LINE DEDENT
Hyp: 
def findTemperature ( x , y , s ) : NEW_LINE INDENT Day1 = s - Day2 NEW_LINE Day2 = ( diff + s ) // 2 NEW_LINE Day1 = s - Day2 NEW_LINE print ( " Day1 ▁ : " , Day1 ) NEW_LINE print ( " Day2 ▁ : " , Day2 ) NEW_LINE DEDENT

BLEU: 75.24
Edit Sim: 18


Src: 
int Count ( int N , int K ) { if ( K == 0 ) return 0 ; int res = 0 ; int low = 1 , high = N ; while ( low <= high ) { int mid = ( low + high ) / 2 ; int sum = ( mid * mid + mid ) / 2 ; if ( sum <= K ) { res = Math . max ( res , mid ) ; low = mid + 1 ; } else { high = mid - 1 ; } } return res ; }
Ref: 
def Count ( N , K ) : NEW_LINE INDENT if ( K == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT res = 0 NEW_LINE low = 1 NEW_LINE high = N NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE sum = ( mid * mid + mid ) // 2 NEW_LINE if ( sum <= K ) : NEW_LINE INDENT res = max ( res , mid ) NEW_LINE low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
Hyp: 
def Count ( N , K ) : NEW_LINE INDENT if ( K == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT res = 0 ; NEW_LINE low = 1 NEW_LINE high = N NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE sum = ( mid * mid + mid ) // 2 NEW_LINE if ( sum <= K ) : NEW_LINE INDENT res = max ( res , mid ) NEW_LINE low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT DEDENT return res ; NEW_LINE DEDENT

BLEU: 93.31
Edit Sim: 6


Src: 
double ReuleauxArea ( float a ) { if ( a < 0 ) return - 1 ; double A = ( double ) 0.70477 * Math . pow ( a , 2 ) ; return A ; }
Ref: 
def ReuleauxArea ( a ) : NEW_LINE INDENT if a < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return 0.70477 * pow ( a , 2 ) NEW_LINE DEDENT
Hyp: 
def ReuleauxArea ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT A = 0.70477 * pow ( a , 2 ) NEW_LINE return A NEW_LINE DEDENT

BLEU: 66.29
Edit Sim: 28


Src: 
void sortBinaryArray ( int a [ ] , int n ) { int j = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] < 1 ) { j ++ ; int temp = a [ j ] ; a [ j ] = a [ i ] ; a [ i ] = temp ; } } }
Ref: 
def sortBinaryArray ( a , n ) : NEW_LINE INDENT j = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] < 1 : NEW_LINE INDENT j = j + 1 NEW_LINE a [ i ] , a [ j ] = a [ j ] , a [ i ] NEW_LINE DEDENT DEDENT DEDENT a = [ 1 , 0 , 0 , 1 , 0 , 1 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 1 , 1 , 0 , 1 , 0 , 0 ] NEW_LINE n = len ( a ) NEW_LINE sortBinaryArray ( a , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) NEW_LINE DEDENT
Hyp: 
def sortBinaryArray ( a , n ) : NEW_LINE INDENT j = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] < 1 ) : NEW_LINE INDENT j += 1 NEW_LINE temp = a [ j ] NEW_LINE a [ j ] = a [ i ] NEW_LINE a [ i ] = temp NEW_LINE DEDENT DEDENT DEDENT

BLEU: 23.49
Edit Sim: 246


Src: 
int numberOfWays ( int N , int X , int Y ) { int S1 = ( N - 1 ) * X + Y ; int S2 = ( N - 1 ) * Y + X ; return ( S2 - S1 + 1 ) ; }
Ref: 
def numberOfWays ( N , X , Y ) : NEW_LINE INDENT S1 = ( N - 1 ) * X + Y NEW_LINE S2 = ( N - 1 ) * Y + X NEW_LINE return ( S2 - S1 + 1 ) NEW_LINE DEDENT
Hyp: 
def numberOfWays ( N , X , Y ) : NEW_LINE INDENT S1 = ( N - 1 ) * X + Y NEW_LINE S2 = ( N - 1 ) * Y + X NEW_LINE return ( S2 - S1 + 1 ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int lastElement ( int a [ ] , int n ) { int steps = 1 ; Vector < Integer > [ ] v = new Vector [ N ] ; for ( int i = 0 ; i < N ; i ++ ) v [ i ] = new Vector < Integer > ( ) ; if ( n == 1 ) return a [ 0 ] ; for ( int i = 0 ; i < n ; i += 2 ) v [ steps ] . add ( a [ i ] a [ i + 1 ] ) ; while ( v [ steps ] . size ( ) > 1 ) { steps += 1 ; for ( int i = 0 ; i < v [ steps - 1 ] . size ( ) ; i += 2 ) { if ( steps % 2 == 1 ) v [ steps ] . add ( v [ steps - 1 ] . get ( i ) | v [ steps - 1 ] . get ( i + 1 ) ) ; v [ steps ] . add ( v [ steps - 1 ] . get ( i ) ^ v [ steps - 1 ] . get ( i + 1 ) ) ; } } return v [ steps ] . get ( 0 ) ; }
Ref: 
def lastElement ( a , n ) : NEW_LINE INDENT steps = 1 NEW_LINE v = [ [ ] for i in range ( n ) ] NEW_LINE if n == 1 : return a [ 0 ] NEW_LINE for i in range ( 0 , n , 2 ) : NEW_LINE INDENT v [ steps ] . append ( a [ i ] a [ i + 1 ] ) NEW_LINE DEDENT while len ( v [ steps ] ) > 1 : NEW_LINE INDENT steps += 1 NEW_LINE for i in range ( 0 , len ( v [ steps - 1 ] ) , 2 ) : NEW_LINE INDENT if steps & 1 : NEW_LINE INDENT v [ steps ] . append ( v [ steps - 1 ] [ i ] v [ steps - 1 ] [ i + 1 ] ) NEW_LINE v [ steps ] . append ( v [ steps - 1 ] [ i ] ^ v [ steps - 1 ] [ i + 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return v [ steps ] [ 0 ] NEW_LINE DEDENT
Hyp: 
def lastElement ( a , n ) : NEW_LINE INDENT steps = 1 NEW_LINE v = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT v [ i ] = list ( ) NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return a [ 0 ] NEW_LINE DEDENT for i in range ( n , 2 ) : NEW_LINE INDENT v [ steps ] . append ( a [ i ] a [ i + 1 ] ) NEW_LINE DEDENT while ( v [ steps ] [ len ( a ) > 1 ) : NEW_LINE INDENT steps += 1 NEW_LINE for i in range ( len ( v [ steps - 1 ] ) , 2 ) : NEW_LINE INDENT if ( steps % 2 == 1 ) : NEW_LINE INDENT v [ steps ] . append ( v [ steps - 1 ] [ i ] | v [ steps - 1 ] [ i + 1 ] ) NEW_LINE DEDENT v [ steps ] . append ( v [ steps - 1 ] [ i ] ^ v [ steps - 1 ] [ i + 1 ] ) NEW_LINE DEDENT DEDENT return v [ steps ] [ 0 ] NEW_LINE DEDENT

BLEU: 75.54
Edit Sim: 129


Src: 
boolean isPossible ( int A , int B ) { return ( A - B > 1 ) ; }
Ref: 
def isPossible ( A , B ) : NEW_LINE INDENT return ( A - B > 1 ) ; NEW_LINE DEDENT A = 10 ; B = 4 ; NEW_LINE if ( isPossible ( A , B ) ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT
Hyp: 
def isPossible ( A , B ) : NEW_LINE INDENT return ( A - B > 1 ) NEW_LINE DEDENT

BLEU: 10.33
Edit Sim: 168


Src: 
void addAP ( int A [ ] , int Q , int [ ] [ ] operations ) { for ( int j = 0 ; j < 2 ; ++ j ) { int L = operations [ j ] [ 0 ] , R = operations [ j ] [ 1 ] , a = operations [ j ] [ 2 ] , d = operations [ j ] [ 3 ] ; int curr = a ; for ( int i = L - 1 ; i < R ; i ++ ) { A [ i ] += curr ; curr += d ; } } for ( int i = 0 ; i < 4 ; ++ i ) System . out . print ( A [ i ] + " ▁ " ) ; }
Ref: 
def addAP ( A , Q , operations ) : NEW_LINE INDENT for L , R , a , d in operations : NEW_LINE INDENT curr = a NEW_LINE for i in range ( L - 1 , R ) : NEW_LINE INDENT A [ i ] += curr NEW_LINE curr += d NEW_LINE DEDENT DEDENT for i in A : NEW_LINE INDENT print ( i , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT
Hyp: 
def addAP ( A , Q , operations ) : NEW_LINE INDENT for j in range ( 2 ) : NEW_LINE INDENT L = operations [ j ] [ 0 ] NEW_LINE R = operations [ j ] [ 1 ] NEW_LINE a = operations [ j ] [ 2 ] NEW_LINE d = operations [ j ] [ 3 ] NEW_LINE curr = a NEW_LINE for i in range ( L - 1 , R ) : NEW_LINE INDENT A [ i ] += curr NEW_LINE curr += d NEW_LINE DEDENT DEDENT for i in range ( 4 ) : NEW_LINE INDENT print ( A [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT

BLEU: 46.75
Edit Sim: 162


Src: 
void countDigits ( String st , int n ) { if ( n > 0 ) { int cnt = 1 , i ; String st2 = " " ; for ( i = 1 ; i < st . length ( ) ; i ++ ) { if ( st . charAt ( i ) == st . charAt ( i - 1 ) ) cnt ++ ; else { st2 += ( ( char ) 0 + ( char ) cnt ) ; st2 += st . charAt ( i - 1 ) ; cnt = 1 ; } } st2 += ( ( char ) 0 + ( char ) cnt ) ; st2 += st . charAt ( i - 1 ) ; countDigits ( st2 , -- n ) ; } else System . out . print ( st ) ; }
Ref: 
def countDigits ( st , n ) : NEW_LINE INDENT if ( n > 0 ) : NEW_LINE INDENT cnt = 1 NEW_LINE i = 0 NEW_LINE st2 = " " NEW_LINE i = 1 NEW_LINE while ( i < len ( st ) ) : NEW_LINE INDENT if ( st [ i ] == st [ i - 1 ] ) : NEW_LINE INDENT cnt = cnt + 1 NEW_LINE DEDENT else : NEW_LINE INDENT st2 += chr ( 48 + cnt ) NEW_LINE st2 += st [ i - 1 ] NEW_LINE cnt = 1 NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT st2 += chr ( 48 + cnt ) NEW_LINE st2 += st [ i - 1 ] NEW_LINE countDigits ( st2 , n - 1 ) NEW_LINE n = n - 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( st ) NEW_LINE DEDENT DEDENT
Hyp: 
def countDigits ( st , n ) : NEW_LINE INDENT if ( n ) : NEW_LINE INDENT cnt = 1 ; NEW_LINE st2 = " " ; NEW_LINE for i in range ( 1 , len ( st ) ) : NEW_LINE INDENT if ( st [ i ] == st [ i - 1 ] ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT st2 += ( char ) 0 + cnt ) ; NEW_LINE st2 += st [ i - 1 ] ; NEW_LINE cnt = 1 ; NEW_LINE DEDENT DEDENT st2 += ( char ) 0 + cnt ) ; NEW_LINE st2 += st [ i - 1 ] ; NEW_LINE countDigits ( st2 , n ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( st ) ; NEW_LINE DEDENT DEDENT

BLEU: 60.53
Edit Sim: 111


Src: 
int Cycles ( int N ) { int fact = 1 , result = 0 ; result = N - 1 ; int i = result ; while ( i > 0 ) { fact = fact * i ; i -- ; } return fact / 2 ; }
Ref: 
def Cycles ( N ) : NEW_LINE INDENT fact = 1 NEW_LINE result = N - 1 NEW_LINE i = result NEW_LINE while ( i > 0 ) : NEW_LINE INDENT fact = fact * i NEW_LINE i -= 1 NEW_LINE DEDENT return fact // 2 NEW_LINE DEDENT
Hyp: 
def Cycles ( N ) : NEW_LINE INDENT fact = 1 NEW_LINE result = 0 NEW_LINE i = result NEW_LINE while ( i > 0 ) : NEW_LINE INDENT fact = fact * i NEW_LINE i -= 1 NEW_LINE DEDENT return fact // 2 NEW_LINE DEDENT

BLEU: 90.39
Edit Sim: 5


Src: 
void printNSE ( int arr [ ] , int n ) { int next , i , j ; for ( i = 0 ; i < n ; i ++ ) { next = - 1 ; for ( j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] > arr [ j ] ) { next = arr [ j ] ; break ; } } System . out . println ( arr [ i ] + " ▁ - - ▁ " + next ) ; } }
Ref: 
def printNSE ( arr ) : NEW_LINE INDENT for i in range ( 0 , len ( arr ) , 1 ) : NEW_LINE INDENT next = - 1 NEW_LINE for j in range ( i + 1 , len ( arr ) , 1 ) : NEW_LINE INDENT if arr [ i ] > arr [ j ] : NEW_LINE INDENT next = arr [ j ] NEW_LINE break NEW_LINE DEDENT DEDENT print ( str ( arr [ i ] ) + " ▁ - - ▁ " + str ( next ) ) NEW_LINE DEDENT DEDENT
Hyp: 
def printNSE ( arr , n ) : NEW_LINE INDENT next = - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT next = arr [ i ] NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] ) : NEW_LINE INDENT next = arr [ j ] NEW_LINE break NEW_LINE DEDENT DEDENT print ( arr [ i ] , " ▁ - - " , next ) NEW_LINE DEDENT DEDENT

BLEU: 63.97
Edit Sim: 81


Src: 
int patternCount ( String str ) { char last = str . charAt ( 0 ) ; int i = 1 , counter = 0 ; while ( i < str . length ( ) ) { if ( str . charAt ( i ) == '0' && last == '1' ) { while ( str . charAt ( i ) == '0' ) i ++ ; if ( str . charAt ( i ) == '1' ) counter ++ ; } last = str . charAt ( i ) ; i ++ ; } return counter ; }
Ref: 
def patternCount ( str ) : NEW_LINE INDENT last = str [ 0 ] NEW_LINE i = 1 ; counter = 0 NEW_LINE while ( i < len ( str ) ) : NEW_LINE INDENT if ( str [ i ] == '0' and last == '1' ) : NEW_LINE INDENT while ( str [ i ] == '0' ) : NEW_LINE INDENT i += 1 NEW_LINE if ( str [ i ] == '1' ) : NEW_LINE INDENT counter += 1 NEW_LINE DEDENT DEDENT DEDENT last = str [ i ] NEW_LINE i += 1 NEW_LINE DEDENT return counter NEW_LINE DEDENT
Hyp: 
def patternCount ( str ) : NEW_LINE INDENT last = str [ 0 ] NEW_LINE i = 1 NEW_LINE counter = 0 NEW_LINE while ( i < len ( str ) ) : NEW_LINE INDENT if ( str [ i ] == '0' and last == '1' ) : NEW_LINE INDENT while ( str [ i ] == '0' ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT if ( str [ i ] == '1' ) : NEW_LINE INDENT counter += 1 NEW_LINE DEDENT DEDENT last = str [ i ] NEW_LINE i += 1 NEW_LINE DEDENT return counter NEW_LINE DEDENT

BLEU: 95.0
Edit Sim: 22


Src: 
int min_operations ( int A [ ] , int n ) { if ( n == 0 ) return 0 ; int ans = A [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( A [ i ] > A [ i - 1 ] ) { ans += A [ i ] - A [ i - 1 ] ; } } return ans ; }
Ref: 
def min_operations ( A ) : NEW_LINE INDENT if len ( A ) == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = A [ 0 ] NEW_LINE for i in range ( 1 , len ( A ) ) : NEW_LINE INDENT if A [ i ] > A [ i - 1 ] : NEW_LINE INDENT ans += A [ i ] - A [ i - 1 ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
Hyp: 
def min_operations ( A , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = A [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( A [ i ] > A [ i - 1 ] ) : NEW_LINE INDENT ans += A [ i ] - A [ i - 1 ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT

BLEU: 79.46
Edit Sim: 25


Src: 
int OddLengthSum ( int [ ] arr ) { int sum = 0 ; int l = arr . length ; for ( int i = 0 ; i < l ; i ++ ) { sum += ( ( ( i + 1 ) * ( l - i ) + 1 ) / 2 ) * arr [ i ] ; } return sum ; }
Ref: 
def OddLengthSum ( arr ) : NEW_LINE INDENT Sum = 0 NEW_LINE l = len ( arr ) NEW_LINE for i in range ( l ) : NEW_LINE INDENT Sum += ( ( ( ( i + 1 ) * ( l - i ) + 1 ) // 2 ) * arr [ i ] ) NEW_LINE DEDENT return Sum NEW_LINE DEDENT
Hyp: 
def OddLengthSum ( arr ) : NEW_LINE INDENT sum = 0 ; NEW_LINE l = len ( arr ) ; NEW_LINE for i in range ( 0 , l ) : NEW_LINE INDENT sum += ( ( ( i + 1 ) * ( l - i ) + 1 ) // 2 ) * arr [ i ] ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT

BLEU: 70.35
Edit Sim: 16


Src: 
int equilibrium ( int arr [ ] , int n ) { int i , j ; int leftsum , rightsum ; for ( i = 0 ; i < n ; ++ i ) { leftsum = 0 ; rightsum = 0 ; for ( j = 0 ; j < i ; j ++ ) leftsum += arr [ j ] ; for ( j = i + 1 ; j < n ; j ++ ) rightsum += arr [ j ] ; if ( leftsum == rightsum ) return i ; } return - 1 ; }
Ref: 
def equilibrium ( arr ) : NEW_LINE INDENT leftsum = 0 NEW_LINE rightsum = 0 NEW_LINE n = len ( arr ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT leftsum = 0 NEW_LINE rightsum = 0 NEW_LINE for j in range ( i ) : NEW_LINE INDENT leftsum += arr [ j ] NEW_LINE DEDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT rightsum += arr [ j ] NEW_LINE DEDENT if leftsum == rightsum : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
Hyp: 
def equilibrium ( arr , n ) : NEW_LINE INDENT i , j = 0 , 0 , 0 NEW_LINE leftsum , rightsum = 0 , 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT leftsum = 0 NEW_LINE rightsum = 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT leftsum += arr [ j ] NEW_LINE DEDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT rightsum += arr [ j ] NEW_LINE DEDENT if ( leftsum == rightsum ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT

BLEU: 71.56
Edit Sim: 56


Src: 
int countWays ( int n ) { for ( int i = 1 ; i < n ; i ++ ) for ( int j = i ; j < n ; j ++ ) for ( int k = j ; k < n ; k ++ ) for ( int l = k ; l < n ; l ++ ) if ( i + j + k + l == n ) counter ++ ; return counter ; }
Ref: 
def countWays ( n ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT for k in range ( j , n ) : NEW_LINE INDENT for l in range ( k , n ) : NEW_LINE INDENT if ( i + j + k + l == n ) : NEW_LINE INDENT counter += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return counter NEW_LINE DEDENT
Hyp: 
def countWays ( n ) : NEW_LINE INDENT counter = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT for k in range ( j , n ) : NEW_LINE INDENT for l in range ( k , n ) : NEW_LINE INDENT if ( i + j + k + l == n ) : NEW_LINE INDENT counter += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return counter NEW_LINE DEDENT

BLEU: 93.61
Edit Sim: 28


Src: 
int findLength ( String str , int n ) { int current_sum = 0 ; int max_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { current_sum += ( str . charAt ( i ) == '0' ? 1 : - 1 ) ; if ( current_sum < 0 ) current_sum = 0 ; max_sum = Math . max ( current_sum , max_sum ) ; } return max_sum == 0 ? - 1 : max_sum ; }
Ref: 
def findLength ( string , n ) : NEW_LINE INDENT current_sum = 0 NEW_LINE max_sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT current_sum += ( 1 if string [ i ] == '0' else - 1 ) NEW_LINE if current_sum < 0 : NEW_LINE INDENT current_sum = 0 NEW_LINE DEDENT max_sum = max ( current_sum , max_sum ) NEW_LINE DEDENT return max_sum if max_sum else 0 NEW_LINE DEDENT
Hyp: 
def findLength ( string , n ) : NEW_LINE INDENT current_sum = 0 NEW_LINE max_sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT current_sum += ( string [ i ] == '0' ? 1 : - 1 ) NEW_LINE if ( current_sum < 0 ) : NEW_LINE INDENT current_sum = 0 NEW_LINE DEDENT max_sum = max ( current_sum , max_sum ) NEW_LINE DEDENT return - 1 NEW_LINE DEDENT

BLEU: 76.07
Edit Sim: 42


Src: 
void findMedian ( int Mean , int Mode ) { double Median = ( 2 * Mean + Mode ) / 3.0 ; System . out . print ( ( int ) Median ) ; }
Ref: 
def findMedian ( Mean , Mode ) : NEW_LINE INDENT Median = ( 2 * Mean + Mode ) // 3 NEW_LINE print ( Median ) NEW_LINE DEDENT
Hyp: 
def findMedian ( Mean , Mode ) : NEW_LINE INDENT Median = ( 2 * Mean + Mode ) / 3.0 NEW_LINE print ( Median ) NEW_LINE DEDENT

BLEU: 86.96
Edit Sim: 3


Src: 
double average ( int arr [ ] , int n , int k ) { double total = 0 ; if ( 2 * k >= n ) return 0 ; Arrays . sort ( arr ) ; int start = k , end = n - k - 1 ; for ( int i = start ; i <= end ; i ++ ) total += arr [ i ] ; return ( total / ( n - 2 * k ) ) ; }
Ref: 
def average ( arr , n , k ) : NEW_LINE INDENT total = 0 NEW_LINE if ( 2 * k >= n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT arr . sort ( ) NEW_LINE start , end = k , n - k - 1 NEW_LINE for i in range ( start , end + 1 ) : NEW_LINE INDENT total += arr [ i ] NEW_LINE DEDENT return ( total / ( n - 2 * k ) ) NEW_LINE DEDENT
Hyp: 
def average ( arr , n , k ) : NEW_LINE INDENT total = 0 NEW_LINE if ( 2 * k >= n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT arr . sort ( ) NEW_LINE start = k NEW_LINE end = n - k - 1 NEW_LINE for i in range ( start , end + 1 ) : NEW_LINE INDENT total += arr [ i ] NEW_LINE DEDENT return ( total / ( n - 2 * k ) ) NEW_LINE DEDENT

BLEU: 93.7
Edit Sim: 15


Src: 
int nswpn ( int n ) { int dp [ ] = new int [ n + 1 ] ; dp [ 0 ] = dp [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) dp [ i ] = 2 * dp [ i - 1 ] + dp [ i - 2 ] ; return dp [ n ] ; }
Ref: 
def nswp ( n ) : NEW_LINE INDENT dp = [ 1 for x in range ( n + 1 ) ] ; NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT dp [ i ] = ( 2 * dp [ i - 1 ] + dp [ i - 2 ] ) ; NEW_LINE DEDENT return dp [ n ] ; NEW_LINE DEDENT
Hyp: 
def nswpn ( n ) : NEW_LINE INDENT dp = [ ] NEW_LINE dp . append ( 1 ) NEW_LINE dp . append ( 1 ) NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT dp . append ( 2 * dp [ i - 1 ] + dp [ i - 2 ] ) NEW_LINE DEDENT return ( dp [ n ] ) NEW_LINE DEDENT

BLEU: 61.82
Edit Sim: 55


Src: 
void mirror_point ( int a , int b , int c , int d , int x1 , int y1 , int z1 ) { float k = ( - a * x1 - b * y1 - c * z1 - d ) / ( float ) ( a * a + b * b + c * c ) ; float x2 = a * k + x1 ; float y2 = b * k + y1 ; float z2 = c * k + z1 ; float x3 = 2 * x2 - x1 ; float y3 = 2 * y2 - y1 ; float z3 = 2 * z2 - z1 ; System . out . print ( " x3 ▁ = ▁ " + x3 + " ▁ " ) ; System . out . print ( " y3 ▁ = ▁ " + y3 + " ▁ " ) ; System . out . print ( " z3 ▁ = ▁ " + z3 + " ▁ " ) ; }
Ref: 
def mirror_point ( a , b , c , d , x1 , y1 , z1 ) : NEW_LINE INDENT k = ( - a * x1 - b * y1 - c * z1 - d ) / float ( ( a * a + b * b + c * c ) ) NEW_LINE x2 = a * k + x1 NEW_LINE y2 = b * k + y1 NEW_LINE z2 = c * k + z1 NEW_LINE x3 = 2 * x2 - x1 NEW_LINE y3 = 2 * y2 - y1 NEW_LINE z3 = 2 * z2 - z1 NEW_LINE print " x3 ▁ = " , x3 , NEW_LINE print " y3 ▁ = " , y3 , NEW_LINE print " z3 ▁ = " , z3 , NEW_LINE DEDENT
Hyp: 
def mirror_point ( a , b , c , d , x1 , y1 , z1 ) : NEW_LINE INDENT k = ( - a * x1 - b * y1 - c * z1 - d ) / ( - a * a + b * b + c * c ) NEW_LINE x2 = a * k + x1 NEW_LINE y2 = b * k + y1 NEW_LINE z2 = c * k + z1 NEW_LINE x3 = 2 * x2 - x1 NEW_LINE y3 = 2 * y2 - y1 NEW_LINE z3 = 2 * z2 - z1 NEW_LINE print ( " x3 ▁ = " , x3 , " ▁ " ) NEW_LINE print ( " y3 ▁ = " , y3 , " ▁ " ) NEW_LINE print ( " z3 ▁ = " , z3 , " ▁ " ) NEW_LINE DEDENT

BLEU: 81.6
Edit Sim: 39


Src: 
long nthKyneaNumber ( int n ) { n = ( 1 << n ) + 1 ; n = n * n ; n = n - 2 ; return n ; }
Ref: 
def nthKyneaNumber ( n ) : NEW_LINE INDENT n = ( 1 << n ) + 1 NEW_LINE n = n * n NEW_LINE n = n - 2 NEW_LINE return n NEW_LINE DEDENT
Hyp: 
def nthKyneaNumber ( n ) : NEW_LINE INDENT n = ( 1 << n ) + 1 NEW_LINE n = n * n NEW_LINE n = n - 2 NEW_LINE return n NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
void findTriangles ( int n ) { int num ; num = n * ( n - 4 ) ; System . out . println ( num ) ; }
Ref: 
def findTriangles ( n ) : NEW_LINE INDENT num = n * ( n - 4 ) NEW_LINE print ( num ) NEW_LINE DEDENT
Hyp: 
def findTriangles ( n ) : NEW_LINE INDENT num = n * ( n - 4 ) NEW_LINE print ( num ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
void getPairsCount ( int [ ] arr , int sum ) { int count = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) for ( int j = i + 1 ; j < arr . length ; j ++ ) if ( ( arr [ i ] + arr [ j ] ) == sum ) count ++ ; System . out . printf ( " Count ▁ of ▁ pairs ▁ is ▁ % d " , count ) ; }
Ref: 
def getPairsCount ( arr , n , sum ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if arr [ i ] + arr [ j ] == sum : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
Hyp: 
def getPairsCount ( arr , sum ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT for j in range ( i + 1 , len ( arr ) ) : NEW_LINE INDENT if ( ( arr [ i ] + arr [ j ] ) == sum ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( " Count ▁ of ▁ pairs ▁ is ▁ % d " , count ) NEW_LINE DEDENT

BLEU: 56.01
Edit Sim: 73


Src: 
void maximumValue ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { ans = Math . max ( ans , arr [ i ] + arr [ j ] + i - j ) ; } } System . out . println ( ans ) ; }
Ref: 
def maximumValue ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT ans = max ( ans , arr [ i ] + arr [ j ] + i - j ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
Hyp: 
def maximumValue ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT ans = max ( ans , arr [ i ] + arr [ j ] + i - j ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int calculateSum ( int n ) { if ( n <= 0 ) return 0 ; int fibo [ ] = new int [ n + 1 ] ; fibo [ 0 ] = 0 ; fibo [ 1 ] = 1 ; int sum = fibo [ 0 ] + fibo [ 1 ] ; for ( int i = 2 ; i <= n ; i ++ ) { fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ; sum += fibo [ i ] ; } return sum ; }
Ref: 
def calculateSum ( n ) : NEW_LINE INDENT if ( n <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT fibo = [ 0 ] * ( n + 1 ) NEW_LINE fibo [ 1 ] = 1 NEW_LINE sm = fibo [ 0 ] + fibo [ 1 ] NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] NEW_LINE sm = sm + fibo [ i ] NEW_LINE DEDENT return sm NEW_LINE DEDENT
Hyp: 
def calculateSum ( n ) : NEW_LINE INDENT if ( n <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT fibo = [ 0 ] * ( n + 1 ) NEW_LINE fibo [ 0 ] = 0 NEW_LINE fibo [ 1 ] = 1 NEW_LINE sum = fibo [ 0 ] + fibo [ 1 ] NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] NEW_LINE sum += fibo [ i ] NEW_LINE DEDENT return sum NEW_LINE DEDENT

BLEU: 85.4
Edit Sim: 32


Src: 
boolean pairInSortedRotated ( int arr [ ] , int n , int x ) { int i ; for ( i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] > arr [ i + 1 ] ) break ; int l = ( i + 1 ) % n ; int r = i ; while ( l != r ) { if ( arr [ l ] + arr [ r ] == x ) return true ; if ( arr [ l ] + arr [ r ] < x ) l = ( l + 1 ) % n ; else r = ( n + r - 1 ) % n ; } return false ; }
Ref: 
def pairInSortedRotated ( arr , n , x ) : NEW_LINE INDENT for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i + 1 ] ) : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT l = ( i + 1 ) % n NEW_LINE r = i NEW_LINE while ( l != r ) : NEW_LINE INDENT if ( arr [ l ] + arr [ r ] == x ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT if ( arr [ l ] + arr [ r ] < x ) : NEW_LINE INDENT l = ( l + 1 ) % n ; NEW_LINE DEDENT else : NEW_LINE INDENT r = ( n + r - 1 ) % n ; NEW_LINE DEDENT DEDENT return False ; NEW_LINE DEDENT arr = [ 11 , 15 , 6 , 8 , 9 , 10 ] NEW_LINE sum = 16 NEW_LINE n = len ( arr ) NEW_LINE if ( pairInSortedRotated ( arr , n , sum ) ) : NEW_LINE INDENT print ( " Array ▁ has ▁ two ▁ elements ▁ with ▁ sum ▁ 16" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Array ▁ doesn ' t ▁ have ▁ two ▁ elements ▁ with ▁ sum ▁ 16 ▁ " ) NEW_LINE DEDENT
Hyp: 
def pairInSortedRotated ( arr , n , x ) : NEW_LINE INDENT i = 0 NEW_LINE while i < n - 1 : NEW_LINE INDENT if arr [ i ] > arr [ i + 1 ] : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT l = ( i + 1 ) % n NEW_LINE r = i NEW_LINE while ( l != r ) : NEW_LINE INDENT if arr [ l ] + arr [ r ] == x : NEW_LINE INDENT return True NEW_LINE DEDENT if arr [ l ] + arr [ r ] < x : NEW_LINE INDENT l = ( l + 1 ) % n NEW_LINE DEDENT else : NEW_LINE INDENT r = ( n + r - 1 ) % n NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT

BLEU: 37.71
Edit Sim: 384


Src: 
int SmallestDiv ( int n ) { for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { return i ; } } return n ; }
Ref: 
def SmallestDiv ( n ) : NEW_LINE INDENT i = 2 NEW_LINE while i * i <= n : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return n NEW_LINE DEDENT
Hyp: 
def SmallestDiv ( n ) : NEW_LINE INDENT i = 2 NEW_LINE while i * i <= n : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return n NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
void rearrange ( int arr [ ] , int n ) { int max_idx = n - 1 , min_idx = 0 ; int max_elem = arr [ n - 1 ] + 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { arr [ i ] += ( arr [ max_idx ] % max_elem ) * max_elem ; max_idx -- ; } else { arr [ i ] += ( arr [ min_idx ] % max_elem ) * max_elem ; min_idx ++ ; } } for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = arr [ i ] / max_elem ; }
Ref: 
def rearrange ( arr , n ) : NEW_LINE INDENT max_idx = n - 1 NEW_LINE min_idx = 0 NEW_LINE max_elem = arr [ n - 1 ] + 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT arr [ i ] += ( arr [ max_idx ] % max_elem ) * max_elem NEW_LINE max_idx -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] += ( arr [ min_idx ] % max_elem ) * max_elem NEW_LINE min_idx += 1 NEW_LINE DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT arr [ i ] = arr [ i ] / max_elem NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Original ▁ Array " ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT rearrange ( arr , n ) NEW_LINE print ( " Modified Array " ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( int ( arr [ i ] ) , end = " ▁ " ) NEW_LINE DEDENT
Hyp: 
def rearrange ( arr , n ) : NEW_LINE INDENT max_idx = n - 1 NEW_LINE min_idx = 0 NEW_LINE max_elem = arr [ n - 1 ] + 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT arr [ i ] += ( arr [ max_idx ] % max_elem ) * max_elem NEW_LINE max_idx -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] += ( arr [ min_idx ] % max_elem ) * max_elem NEW_LINE min_idx += 1 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = arr [ i ] // max_elem NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = arr [ i ] // max_elem NEW_LINE DEDENT DEDENT

BLEU: 47.21
Edit Sim: 309


Src: 
void dupLastIndex ( int arr [ ] , int n ) { if ( arr == null n <= 0 ) return ; for ( int i = n - 1 ; i > 0 ; i -- ) { if ( arr [ i ] == arr [ i - 1 ] ) { System . out . println ( " Last ▁ index : " + i ) ; System . out . println ( " Last ▁ duplicate ▁ item : ▁ " + arr [ i ] ) ; return ; } } System . out . print ( " no ▁ duplicate ▁ found " ) ; }
Ref: 
def dupLastIndex ( arr , n ) : NEW_LINE INDENT if ( arr == None or n <= 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT for i in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] == arr [ i - 1 ] ) : NEW_LINE INDENT print ( " Last ▁ index : " , i ,   " Last " , ▁ " duplicate item : " , arr [ i ] ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( " no ▁ duplicate ▁ found " ) NEW_LINE DEDENT
Hyp: 
def dupLastIndex ( arr , n ) : NEW_LINE INDENT if ( arr == null or n <= 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] == arr [ i - 1 ] ) : NEW_LINE INDENT print ( " Last ▁ index : " , i ) NEW_LINE print ( " Last ▁ duplicate ▁ item : ▁ " , arr [ i ] ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( " no ▁ duplicate ▁ found " ) NEW_LINE DEDENT

BLEU: 83.56
Edit Sim: 31


Src: 
boolean isComposite ( int n ) { if ( n <= 1 ) System . out . println ( " False " ) ; if ( n <= 3 ) System . out . println ( " False " ) ; if ( n % 2 == 0 n % 3 == 0 ) return true ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return true ; return false ; }
Ref: 
def isComposite ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return False NEW_LINE DEDENT
Hyp: 
def isComposite ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT print ( " False " ) NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT print ( " False " ) NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT for i in range ( 5 , n + 6 ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT

BLEU: 75.41
Edit Sim: 63


Src: 
void angleequichord ( int z ) { System . out . println ( " The ▁ angle ▁ subtended ▁ at ▁ the ▁ center ▁ is ▁ " + z + " ▁ degrees " ) ; }
Ref: 
def angleequichord ( z ) : NEW_LINE INDENT print ( " The ▁ angle ▁ subtended ▁ at " , " the ▁ center ▁ is " , z , " degrees " ) ; NEW_LINE DEDENT
Hyp: 
def angleequichord ( z ) : NEW_LINE INDENT print ( " The ▁ angle ▁ subtended ▁ at ▁ the ▁ center ▁ is ▁ " , z , " ▁ degrees " ) NEW_LINE DEDENT

BLEU: 71.9
Edit Sim: 11


Src: 
boolean isAlphabaticOrder ( String s ) { int n = s . length ( ) ; for ( int i = 1 ; i < n ; i ++ ) { if ( s . charAt ( i ) < s . charAt ( i - 1 ) ) { return false ; } } return true ; }
Ref: 
def isAlphabaticOrder ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( s [ i ] < s [ i - 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
Hyp: 
def isAlphabaticOrder ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( s [ i ] < s [ i - 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT s = " aba " NEW_LINE if ( isAlphabaticOrder ( s ) ) : NEW_LINE INDENT print ( " aba " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " aba " ) NEW_LINE DEDENT

BLEU: 59.31
Edit Sim: 161


Src: 
int findOddPair ( int A [ ] , int N ) { int i , count = 0 ; for ( i = 0 ; i < N ; i ++ ) { if ( A [ i ] % 2 == 0 ) count ++ ; } return count * ( N - count ) ; }
Ref: 
def findOddPair ( A , N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT if ( A [ i ] % 2 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count * ( N - count ) NEW_LINE DEDENT
Hyp: 
def findOddPair ( A , N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( A [ i ] % 2 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count * ( N - count ) NEW_LINE DEDENT

BLEU: 93.6
Edit Sim: 4


Src: 
int magicOfSequence ( int N ) { return ( N * ( N + 1 ) / 2 ) + 2 * N ; }
Ref: 
def magicOfSequence ( N ) : NEW_LINE INDENT return ( N * ( N + 1 ) / 2 ) + 2 * N NEW_LINE DEDENT
Hyp: 
def magicOfSequence ( N ) : NEW_LINE INDENT return ( ( N * ( N + 1 ) / 2 ) + 2 * N ) ; NEW_LINE DEDENT

BLEU: 81.97
Edit Sim: 6


Src: 
double findSum ( long n ) { return Math . sqrt ( 3 ) * ( n * ( n + 1 ) / 2 ) ; }
Ref: 
def findSum ( n ) : NEW_LINE INDENT return math . sqrt ( 3 ) * ( n * ( n + 1 ) / 2 ) NEW_LINE DEDENT
Hyp: 
def findSum ( n ) : NEW_LINE INDENT return math . sqrt ( 3 ) * ( n * ( n + 1 ) / 2 ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int findMaxValue ( int N , int mat [ ] [ ] ) { int maxValue = Integer . MIN_VALUE ; for ( int a = 0 ; a < N - 1 ; a ++ ) for ( int b = 0 ; b < N - 1 ; b ++ ) for ( int d = a + 1 ; d < N ; d ++ ) for ( int e = b + 1 ; e < N ; e ++ ) if ( maxValue < ( mat [ d ] [ e ] - mat [ a ] [ b ] ) ) maxValue = mat [ d ] [ e ] - mat [ a ] [ b ] ; return maxValue ; }
Ref: 
def findMaxValue ( mat ) : NEW_LINE INDENT maxValue = 0 NEW_LINE for a in range ( N - 1 ) : NEW_LINE INDENT for b in range ( N - 1 ) : NEW_LINE INDENT for d in range ( a + 1 , N ) : NEW_LINE INDENT for e in range ( b + 1 , N ) : NEW_LINE INDENT if maxValue < int ( mat [ d ] [ e ] - mat [ a ] [ b ] ) : NEW_LINE INDENT maxValue = int ( mat [ d ] [ e ] - mat [ a ] [ b ] ) ; NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return maxValue ; NEW_LINE DEDENT
Hyp: 
def findMaxValue ( N , mat ) : NEW_LINE INDENT maxValue = INT_MIN ; NEW_LINE for a in range ( N - 1 ) : NEW_LINE INDENT for b in range ( N - 1 ) : NEW_LINE INDENT for d in range ( a + 1 , N ) : NEW_LINE INDENT for e in range ( b + 1 , N ) : NEW_LINE INDENT if ( maxValue < ( mat [ d ] [ e ] - mat [ a ] [ b ] ) ) : NEW_LINE INDENT maxValue = mat [ d ] [ e ] - mat [ a ] [ b ] NEW_LINE DEDENT DEDENT DEDENT DEDENT return maxValue NEW_LINE DEDENT

BLEU: 84.72
Edit Sim: 40


Src: 
String check ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { Map < Integer , Integer > hm = new HashMap < > ( ) ; int count = 0 ; for ( int j = i ; j < n ; j ++ ) { hm . put ( arr [ j ] , hm . getOrDefault ( arr [ j ] , 0 ) + 1 ) ; if ( hm . get ( arr [ j ] ) == 1 ) count ++ ; if ( hm . get ( arr [ j ] ) == 2 ) count -- ; if ( count == 0 ) return " No " ; } } return " Yes " ; }
Ref: 
def check ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT hm = { } NEW_LINE count = 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT hm [ arr [ j ] ] = hm . get ( arr [ j ] , 0 ) + 1 NEW_LINE if ( hm [ arr [ j ] ] == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( hm [ arr [ j ] ] == 2 ) : NEW_LINE INDENT count -= 1 NEW_LINE DEDENT if ( count == 0 ) : NEW_LINE INDENT return " No " NEW_LINE DEDENT DEDENT DEDENT return " Yes " NEW_LINE DEDENT
Hyp: 
def check ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT hm = dict ( ) NEW_LINE count = 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT hm [ arr [ j ] ] = ( hm [ arr [ j ] ] + 1 ) NEW_LINE if ( hm [ arr [ j ] ] == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( hm [ arr [ j ] ] == 2 ) : NEW_LINE INDENT count -= 1 NEW_LINE DEDENT if ( count == 0 ) : NEW_LINE INDENT return " No " NEW_LINE DEDENT DEDENT DEDENT return " Yes " NEW_LINE DEDENT

BLEU: 88.71
Edit Sim: 21


Src: 
int count_numbers ( int k , int n ) { int [ ] [ ] dp = new int [ n + 1 ] [ 2 ] ; dp [ 1 ] [ 0 ] = 0 ; dp [ 1 ] [ 1 ] = k - 1 ; for ( int i = 2 ; i <= n ; i ++ ) { dp [ i ] [ 0 ] = dp [ i - 1 ] [ 1 ] ; dp [ i ] [ 1 ] = ( dp [ i - 1 ] [ 0 ] + dp [ i - 1 ] [ 1 ] ) * ( k - 1 ) ; } return dp [ n ] [ 0 ] + dp [ n ] [ 1 ] ; }
Ref: 
def count_numbers ( k , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( 2 ) ] for i in range ( n + 1 ) ] NEW_LINE dp [ 1 ] [ 0 ] = 0 NEW_LINE dp [ 1 ] [ 1 ] = k - 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i - 1 ] [ 1 ] NEW_LINE dp [ i ] [ 1 ] = ( dp [ i - 1 ] [ 0 ] + dp [ i - 1 ] [ 1 ] ) * ( k - 1 ) NEW_LINE DEDENT return dp [ n ] [ 0 ] + dp [ n ] [ 1 ] NEW_LINE DEDENT
Hyp: 
def count_numbers ( k , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( k - 1 ) ] for j in range ( n + 1 ) ] NEW_LINE dp [ 1 ] [ 0 ] = 0 NEW_LINE dp [ 1 ] [ 1 ] = k - 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i - 1 ] [ 1 ] NEW_LINE dp [ i ] [ 1 ] = ( dp [ i - 1 ] [ 0 ] + dp [ i - 1 ] [ 1 ] ) * ( k - 1 ) NEW_LINE DEDENT return dp [ n ] [ 0 ] + dp [ n ] [ 1 ] NEW_LINE DEDENT

BLEU: 95.13
Edit Sim: 6


Src: 
int countNumbersWith4 ( int n ) { if ( n < 4 ) return 0 ; int d = ( int ) Math . log10 ( n ) ; int [ ] a = new int [ d + 2 ] ; a [ 0 ] = 0 ; a [ 1 ] = 1 ; for ( int i = 2 ; i <= d ; i ++ ) a [ i ] = a [ i - 1 ] * 9 + ( int ) Math . ceil ( Math . pow ( 10 , i - 1 ) ) ; int p = ( int ) Math . ceil ( Math . pow ( 10 , d ) ) ; int msd = n / p ; if ( msd == 4 ) return ( msd ) * a [ d ] + ( n % p ) + 1 ; if ( msd > 4 ) return ( msd - 1 ) * a [ d ] + p + countNumbersWith4 ( n % p ) ; return ( msd ) * a [ d ] + countNumbersWith4 ( n % p ) ; }
Ref: 
def countNumbersWith4 ( n ) : NEW_LINE INDENT if ( n < 4 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT d = int ( mt . log10 ( n ) ) NEW_LINE a = [ 1 for i in range ( d + 1 ) ] NEW_LINE a [ 0 ] = 0 NEW_LINE if len ( a ) > 1 : NEW_LINE INDENT a [ 1 ] = 1 NEW_LINE DEDENT for i in range ( 2 , d + 1 ) : NEW_LINE INDENT a [ i ] = a [ i - 1 ] * 9 + mt . ceil ( pow ( 10 , i - 1 ) ) NEW_LINE DEDENT p = mt . ceil ( pow ( 10 , d ) ) NEW_LINE msd = n // p NEW_LINE if ( msd == 4 ) : NEW_LINE INDENT return ( msd ) * a [ d ] + ( n % p ) + 1 NEW_LINE DEDENT if ( msd > 4 ) : NEW_LINE INDENT return ( ( msd - 1 ) * a [ d ] + p + countNumbersWith4 ( n % p ) ) NEW_LINE DEDENT return ( msd ) * a [ d ] + countNumbersWith4 ( n % p ) NEW_LINE DEDENT
Hyp: 
def countNumbersWith4 ( n ) : NEW_LINE INDENT if ( n < 4 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT d = ( int ) math . log10 ( n ) ; NEW_LINE a = [ 0 ] * ( d + 2 ) ; NEW_LINE a [ 0 ] = 0 ; NEW_LINE a [ 1 ] = 1 ; NEW_LINE for i in range ( 2 , d + 1 ) : NEW_LINE INDENT a [ i ] = a [ i - 1 ] * 9 + ( int ) math . ceil ( math . pow ( 10 , i - 1 ) ) ; NEW_LINE DEDENT p = ( int ) math . ceil ( math . pow ( 10 , d ) ) ; NEW_LINE msd = n // p ; NEW_LINE if ( msd == 4 ) : NEW_LINE INDENT return ( int ) ( msd ) * a [ d ] + ( n % p ) + 1 ) ; NEW_LINE DEDENT if ( msd > 4 ) : NEW_LINE INDENT return ( int ) ( msd - 1 ) * a [ d ] + p + countNumbersWith4 ( n % p ) ; NEW_LINE DEDENT return ( int ) ( msd ) * a [ d ] + countNumbersWith4 ( n % p ) ; NEW_LINE DEDENT

BLEU: 69.36
Edit Sim: 136


Src: 
boolean isPowerOfTwo ( int n ) { if ( n == 0 ) return false ; while ( n != 1 ) { if ( n % 2 != 0 ) return false ; n = n / 2 ; } return true ; }
Ref: 
def isPowerOfTwo ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT while ( n != 1 ) : NEW_LINE INDENT if ( n % 2 != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT n = n // 2 NEW_LINE DEDENT return True NEW_LINE DEDENT if ( isPowerOfTwo ( 31 ) ) : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT if ( isPowerOfTwo ( 64 ) ) : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT
Hyp: 
def isPowerOfTwo ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT while ( n != 1 ) : NEW_LINE INDENT if ( n % 2 != 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT n = n // 2 ; NEW_LINE DEDENT return True ; NEW_LINE DEDENT n = 18 ; NEW_LINE if ( isPowerOfTwo ( n ) ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT

BLEU: 53.93
Edit Sim: 142


Src: 
void lengperpbisect ( double r1 , double r2 ) { double z = 2 * Math . sqrt ( ( r1 * r1 ) - ( ( r1 - r2 ) * ( r1 - r2 ) / 4 ) ) ; System . out . println ( " The ▁ length ▁ of ▁ the ▁ " + " perpendicular ▁ bisector ▁ is ▁ " + z ) ; }
Ref: 
def lengperpbisect ( r1 , r2 ) : NEW_LINE INDENT z = 2 * ( ( ( r1 * r1 ) - ( ( r1 - r2 ) * ( r1 - r2 ) / 4 ) ) ** ( 1 / 2 ) ) ; NEW_LINE print ( " The ▁ length ▁ of ▁ the ▁ perpendicular ▁ bisector ▁ is ▁ " , z ) ; NEW_LINE DEDENT
Hyp: 
def lengperpbisect ( r1 , r2 ) : NEW_LINE INDENT z = 2 * math . sqrt ( ( r1 * r1 ) - ( ( r1 - r2 ) * ( r1 - r2 ) / 4 ) ) NEW_LINE print ( " The ▁ length ▁ of ▁ the ▁ perpendicular ▁ bisector ▁ is ▁ " , z ) NEW_LINE DEDENT

BLEU: 79.2
Edit Sim: 30


Src: 
int cntElements ( int arr [ ] , int n ) { int cnt = 0 ; for ( int i = 0 ; i < n - 2 ; i ++ ) { if ( arr [ i ] == ( arr [ i + 1 ] ^ arr [ i + 2 ] ) ) { cnt ++ ; } } return cnt ; }
Ref: 
def cntElements ( arr , n ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( n - 2 ) : NEW_LINE INDENT if ( arr [ i ] == ( arr [ i + 1 ] ^ arr [ i + 2 ] ) ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT
Hyp: 
def cntElements ( arr , n ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( n - 2 ) : NEW_LINE INDENT if ( arr [ i ] == ( arr [ i + 1 ] ^ arr [ i + 2 ] ) ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int maxcntPairsSumKRemoved ( int [ ] arr , int k ) { int cntPairs = 0 ; if ( arr . length <= 1 ) return cntPairs ; Arrays . sort ( arr ) ; int left = 0 ; int right = arr . length - 1 ; while ( left < right ) { int s = arr [ left ] + arr [ right ] ; if ( s == k ) { cntPairs += 1 ; left += 1 ; right -= 1 ; } else if ( s > k ) right -= 1 ; else left += 1 ; } return cntPairs ; }
Ref: 
def maxcntPairsSumKRemoved ( arr , k ) : NEW_LINE INDENT cntPairs = 0 NEW_LINE if not arr or len ( arr ) == 1 : NEW_LINE INDENT return cntPairs NEW_LINE DEDENT arr . sort ( ) NEW_LINE left = 0 NEW_LINE right = len ( arr ) - 1 NEW_LINE while left < right : NEW_LINE INDENT s = arr [ left ] + arr [ right ] NEW_LINE if s == k : NEW_LINE INDENT cntPairs += 1 NEW_LINE left += 1 NEW_LINE right -= 1 NEW_LINE DEDENT elif s > k : NEW_LINE INDENT right -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT left += 1 NEW_LINE DEDENT DEDENT return cntPairs NEW_LINE DEDENT
Hyp: 
def maxcntPairsSumKRemoved ( arr , k ) : NEW_LINE INDENT cntPairs = 0 NEW_LINE if ( len ( arr ) <= 1 ) : NEW_LINE INDENT return cntPairs NEW_LINE DEDENT arr . sort ( ) NEW_LINE left = 0 NEW_LINE right = len ( arr ) - 1 NEW_LINE while ( left < right ) : NEW_LINE INDENT s = arr [ left ] + arr [ right ] NEW_LINE if ( s == k ) : NEW_LINE INDENT cntPairs += 1 NEW_LINE left += 1 NEW_LINE right -= 1 NEW_LINE DEDENT elif ( s > k ) : NEW_LINE INDENT right -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT left += 1 NEW_LINE DEDENT DEDENT return cntPairs NEW_LINE DEDENT

BLEU: 81.34
Edit Sim: 25


Src: 
int lbs ( int arr [ ] , int n ) { int i , j ; int [ ] lis = new int [ n ] ; for ( i = 0 ; i < n ; i ++ ) lis [ i ] = 1 ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; int [ ] lds = new int [ n ] ; for ( i = 0 ; i < n ; i ++ ) lds [ i ] = 1 ; for ( i = n - 2 ; i >= 0 ; i -- ) for ( j = n - 1 ; j > i ; j -- ) if ( arr [ i ] > arr [ j ] && lds [ i ] < lds [ j ] + 1 ) lds [ i ] = lds [ j ] + 1 ; int max = lis [ 0 ] + lds [ 0 ] - 1 ; for ( i = 1 ; i < n ; i ++ ) if ( lis [ i ] + lds [ i ] - 1 > max ) max = lis [ i ] + lds [ i ] - 1 ; return max ; }
Ref: 
def lbs ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE lis = [ 1 for i in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( 0 , i ) : NEW_LINE INDENT if ( ( arr [ i ] > arr [ j ] ) and ( lis [ i ] < lis [ j ] + 1 ) ) : NEW_LINE INDENT lis [ i ] = lis [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT lds = [ 1 for i in range ( n + 1 ) ] NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and lds [ i ] < lds [ j ] + 1 ) : NEW_LINE INDENT lds [ i ] = lds [ j ] + 1 NEW_LINE DEDENT DEDENT maximum = lis [ 0 ] + lds [ 0 ] - 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT maximum = max ( ( lis [ i ] + lds [ i ] - 1 ) , maximum ) NEW_LINE DEDENT return maximum NEW_LINE DEDENT
Hyp: 
def lbs ( arr , n ) : NEW_LINE INDENT lis = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT lis [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and lis [ i ] < lis [ j ] + 1 ) : NEW_LINE INDENT lis [ i ] = lis [ j ] + 1 NEW_LINE DEDENT DEDENT lds = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and lds [ i ] < lds [ j ] + 1 ) : NEW_LINE INDENT lds [ i ] = lds [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT max = lis [ 0 ] + lds [ 0 ] - 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( lis [ i ] + lds [ i ] - 1 > max ) : NEW_LINE INDENT max = lis [ i ] + lds [ i ] - 1 NEW_LINE DEDENT DEDENT return max NEW_LINE DEDENT

BLEU: 65.76
Edit Sim: 228


Src: 
void TowerOfHanoi ( int N ) { for ( int x = 1 ; x <= Math . pow ( 2 , N ) - 1 ; x ++ ) { System . out . print ( " Move ▁ from ▁ Rod ▁ " + ( ( x & x - 1 ) % 3 + 1 ) + " ▁ to ▁ Rod ▁ " + ( ( ( x x - 1 ) + 1 ) % 3 + 1 ) + "NEW_LINE"); } }
Ref: 
def TowerOfHanoi ( N ) : NEW_LINE INDENT for x in range ( 1 , int ( math . pow ( 2 , N ) ) ) : NEW_LINE INDENT print ( " Move ▁ from ▁ Rod ▁ " , ( ( x & x - 1 ) % 3 + 1 ) , " ▁ to ▁ Rod ▁ " , ( ( ( x x - 1 ) + 1 ) % 3 + 1 ) ) NEW_LINE DEDENT DEDENT
Hyp: 
def TowerOfHanoi ( N ) : NEW_LINE INDENT for x in range ( 1 , pow ( 2 , N ) - 1 ) : NEW_LINE INDENT print ( " Move ▁ from ▁ Rod ▁ " , ( ( x & x - 1 ) % 3 + 1 ) , " ▁ to ▁ Rod ▁ " , ( ( ( x x - 1 ) + 1 ) % 3 + 1 ) , " " ) ; NEW_LINE DEDENT DEDENT

BLEU: 86.34
Edit Sim: 24


Src: 
void printAMeans ( int A , int B , int N ) { float d = ( float ) ( B - A ) / ( N + 1 ) ; for ( int i = 1 ; i <= N ; i ++ ) System . out . print ( ( A + i * d ) + " ▁ " ) ; }
Ref: 
def printAMeans ( A , B , N ) : NEW_LINE INDENT d = ( B - A ) / ( N + 1 ) NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT print ( int ( A + i * d ) , end = " ▁ " ) NEW_LINE DEDENT DEDENT
Hyp: 
def printAMeans ( A , B , N ) : NEW_LINE INDENT d = ( B - A ) / ( N + 1 ) NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT print ( ( A + i * d ) , end = " ▁ " ) NEW_LINE DEDENT DEDENT

BLEU: 95.74
Edit Sim: 4


Src: 
boolean checkArrInStack ( Stack < Integer > s , int arr [ ] , int n ) { HashMap < Integer , Integer > freq = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) if ( freq . containsKey ( arr [ i ] ) ) freq . put ( arr [ i ] , freq . get ( arr [ i ] ) + 1 ) ; else freq . put ( arr [ i ] , 1 ) ; while ( ! s . isEmpty ( ) ) { int poppedEle = s . peek ( ) ; s . pop ( ) ; if ( freq . containsKey ( poppedEle ) ) freq . put ( poppedEle , freq . get ( poppedEle ) - 1 ) ; } if ( freq . size ( ) == 0 ) return false ; return true ; }
Ref: 
def checkArrInStack ( s , arr ) : NEW_LINE INDENT freq = { } NEW_LINE for ele in arr : NEW_LINE INDENT freq [ ele ] = freq . get ( ele , 0 ) + 1 NEW_LINE DEDENT while s : NEW_LINE INDENT poppedEle = s . pop ( ) NEW_LINE if poppedEle in freq : NEW_LINE freq [ poppedEle ] -= 1 NEW_LINE if not freq [ poppedEle ] : NEW_LINE INDENT del freq [ poppedEle ] NEW_LINE DEDENT DEDENT if not freq : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
Hyp: 
def checkArrInStack ( s , arr , n ) : NEW_LINE INDENT freq = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] in freq : NEW_LINE INDENT freq [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT freq [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT while len ( s ) > 0 : NEW_LINE INDENT poppedEle = s . pop ( ) NEW_LINE s . pop ( ) NEW_LINE if poppedEle in freq : NEW_LINE INDENT freq [ poppedEle ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT freq [ poppedEle ] = 1 NEW_LINE DEDENT DEDENT if len ( freq ) == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT

BLEU: 40.75
Edit Sim: 210


Src: 
int noOfCards ( int n ) { return n * ( 3 * n + 1 ) / 2 ; }
Ref: 
def noOfCards ( n ) : NEW_LINE INDENT return n * ( 3 * n + 1 ) // 2 NEW_LINE DEDENT
Hyp: 
def noOfCards ( n ) : NEW_LINE INDENT return n * ( 3 * n + 1 ) // 2 NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
long multiplyByMersenne ( long N , long M ) { long x = ( int ) ( Math . log ( M + 1 ) / Math . log ( 2 ) ) ; return ( ( N << x ) - N ) ; }
Ref: 
def multiplyByMersenne ( N , M ) : NEW_LINE INDENT x = int ( math . log2 ( M + 1 ) ) NEW_LINE return ( ( N << x ) - N ) NEW_LINE DEDENT
Hyp: 
def multiplyByMersenne ( N , M ) : NEW_LINE INDENT x = int ( math . log2 ( M + 1 ) ) NEW_LINE return ( ( N << x ) - N ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
boolean isDivisible ( int n ) { int d ; while ( ( n / 100 ) > 0 ) { d = n % 10 ; n /= 10 ; n = Math . abs ( n - ( d * 3 ) ) ; } return ( n % 31 == 0 ) ; }
Ref: 
def isDivisible ( n ) : NEW_LINE INDENT while n // 100 : NEW_LINE INDENT d = n % 10 NEW_LINE n //= 10 NEW_LINE n = abs ( n - ( d * 3 ) ) NEW_LINE DEDENT return ( n % 31 == 0 ) NEW_LINE DEDENT
Hyp: 
def isDivisible ( n ) : NEW_LINE INDENT while ( n // 100 ) > 0 : NEW_LINE INDENT d = n % 10 NEW_LINE n //= 10 NEW_LINE n = abs ( n - ( d * 3 ) ) NEW_LINE DEDENT return ( n % 31 == 0 ) NEW_LINE DEDENT n = 121 NEW_LINE if ( isDivisible ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT

BLEU: 52.46
Edit Sim: 158


Src: 
long count ( int N , int K , int R ) { long sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( i % K == R ) sum += i ; } return sum ; }
Ref: 
def count ( N , K , R ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( i % K == R ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
Hyp: 
def count ( N , K , R ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( i % K == R ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
void distance ( float a1 , float b1 , float c1 , float d1 , float a2 , float b2 , float c2 , float d2 ) { float x1 , y1 , z1 , d ; if ( a1 / a2 == b1 / b2 && b1 / b2 == c1 / c2 ) { x1 = y1 = 0 ; z1 = - d1 / c1 ; d = Math . abs ( ( c2 * z1 + d2 ) ) / ( float ) ( Math . sqrt ( a2 * a2 + b2 * b2 + c2 * c2 ) ) ; System . out . println ( " Perpendicular ▁ distance ▁ is ▁ " + d ) ; } else System . out . println ( " Planes ▁ are ▁ not ▁ parallel " ) ; }
Ref: 
def distance ( a1 , b1 , c1 , d1 , a2 , b2 , c2 , d2 ) : NEW_LINE INDENT if ( a1 / a2 == b1 / b2 and b1 / b2 == c1 / c2 ) : NEW_LINE INDENT x1 = y1 = 0 NEW_LINE z1 = - d1 / c1 NEW_LINE d = abs ( ( c2 * z1 + d2 ) ) / ( math . sqrt ( a2 * a2 + b2 * b2 + c2 * c2 ) ) NEW_LINE print ( " Perpendicular ▁ distance ▁ is " ) , d NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Planes ▁ are ▁ not ▁ parallel " ) NEW_LINE DEDENT DEDENT
Hyp: 
def distance ( a1 , b1 , c1 , d1 , a2 , b2 , c2 , d2 ) : NEW_LINE INDENT if ( a1 / a2 == b1 / b2 and b1 / b2 == c1 / c2 ) : NEW_LINE INDENT x1 = y1 = 0 NEW_LINE z1 = - d1 / c1 NEW_LINE d = abs ( ( c2 * z1 + d2 ) ) / ( math . sqrt ( a2 * a2 + b2 * b2 + c2 * c2 ) ) NEW_LINE print ( " Perpendicular ▁ distance ▁ is ▁ " , d ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Planes ▁ are ▁ not ▁ parallel " ) NEW_LINE DEDENT DEDENT

BLEU: 95.63
Edit Sim: 4


Src: 
int AND ( int a [ ] , int n ) { int ans = a [ 0 ] ; for ( int i = 0 ; i < n ; ++ i ) ans &= a [ i ] ; return ans ; }
Ref: 
def AND ( a , n ) : NEW_LINE INDENT ans = a [ 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans &= a [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT
Hyp: 
def AND ( a , n ) : NEW_LINE INDENT ans = a [ 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans &= a [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
float findVolume ( float l , float b , float h ) { float volume = ( l * b * h ) / 2 ; return volume ; }
Ref: 
def findVolume ( l , b , h ) : NEW_LINE INDENT return ( ( l * b * h ) / 2 ) NEW_LINE DEDENT
Hyp: 
def findVolume ( l , b , h ) : NEW_LINE INDENT volume = ( l * b * h ) / 2 NEW_LINE return volume NEW_LINE DEDENT

BLEU: 71.77
Edit Sim: 28


Src: 
void countFreq ( int arr [ ] , int n ) { boolean [ ] visited = new boolean [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( visited [ i ] == true ) continue ; int count = 1 ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] == arr [ j ] ) { visited [ j ] = true ; count ++ ; } } System . out . println ( arr [ i ] + " ▁ " + count ) ; } }
Ref: 
def countFreq ( arr , n ) : NEW_LINE INDENT visited = [ False for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if visited [ i ] == True : NEW_LINE INDENT continue NEW_LINE DEDENT count = 1 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if arr [ i ] == arr [ j ] : NEW_LINE INDENT visited [ j ] = True NEW_LINE count += 1 NEW_LINE DEDENT DEDENT print ( arr [ i ] , count ) NEW_LINE DEDENT DEDENT
Hyp: 
def countFreq ( arr , n ) : NEW_LINE INDENT visited = [ False ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT if i in visited : NEW_LINE INDENT continue NEW_LINE DEDENT count = 1 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if arr [ i ] == arr [ j ] : NEW_LINE INDENT visited [ j ] = True NEW_LINE count += 1 NEW_LINE DEDENT DEDENT print ( arr [ i ] , count ) NEW_LINE DEDENT DEDENT

BLEU: 84.33
Edit Sim: 36


Src: 
void result ( long n , long k , long t ) { if ( t <= k ) System . out . println ( t ) ; else if ( t <= n ) System . out . println ( k ) ; else { long temp = t - n ; temp = k - temp ; System . out . println ( temp ) ; } }
Ref: 
def result ( n , k , t ) : NEW_LINE INDENT if ( t <= k ) : NEW_LINE INDENT print ( t ) NEW_LINE DEDENT elif ( t <= n ) : NEW_LINE INDENT print ( k ) NEW_LINE DEDENT else : NEW_LINE INDENT temp = t - n NEW_LINE temp = k - temp NEW_LINE print ( temp ) NEW_LINE DEDENT DEDENT
Hyp: 
def result ( n , k , t ) : NEW_LINE INDENT if ( t <= k ) : NEW_LINE INDENT print ( t ) NEW_LINE DEDENT elif ( t <= n ) : NEW_LINE INDENT print ( k ) NEW_LINE DEDENT else : NEW_LINE INDENT temp = t - n NEW_LINE temp = k - temp NEW_LINE print ( temp ) NEW_LINE DEDENT DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int countNumbers ( int l , int r ) { return ( ( r / 2 ) - ( l - 1 ) / 2 ) ; }
Ref: 
def countNumbers ( l , r ) : NEW_LINE INDENT return ( ( r // 2 ) - ( l - 1 ) // 2 ) NEW_LINE DEDENT
Hyp: 
def countNumbers ( l , r ) : NEW_LINE INDENT return ( ( r // 2 ) - ( l - 1 ) // 2 ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int solve ( int n , int k , int m ) { if ( n == 0 && k == 0 ) return 1 ; if ( n == 0 && k != 0 ) return 0 ; if ( n != 0 && k == 0 ) return 0 ; if ( n < 0 k < 0 ) return 0 ; if ( dp [ n ] [ k ] > 0 ) return dp [ n ] [ k ] ; int ans = 0 ; for ( int j = 1 ; j <= m ; j ++ ) { ans += solve ( n - j , k - 1 , m ) ; } return dp [ n ] [ k ] = ans ; }
Ref: 
def solve ( n , k , m ) : NEW_LINE INDENT if n == 0 and k == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if n == 0 and k != 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if n != 0 and k == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if n < 0 or k < 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if dp [ n ] [ k ] : NEW_LINE INDENT return dp [ n ] [ k ] NEW_LINE DEDENT ans = 0 NEW_LINE for j in range ( 1 , m + 1 ) : NEW_LINE INDENT ans = ans + solve ( n - j , k - 1 , m ) NEW_LINE DEDENT dp [ n ] [ k ] = ans NEW_LINE return dp [ n ] [ k ] NEW_LINE DEDENT
Hyp: 
def solve ( n , k , m ) : NEW_LINE INDENT if ( n == 0 and k == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n == 0 and k != 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n < 0 and k < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ n ] [ k ] > 0 ) : NEW_LINE INDENT return dp [ n ] [ k ] NEW_LINE DEDENT ans = 0 NEW_LINE for j in range ( 1 , m + 1 ) : NEW_LINE INDENT ans += solve ( n - j , k - 1 , m ) NEW_LINE DEDENT return dp [ n ] [ k ] NEW_LINE DEDENT

BLEU: 69.04
Edit Sim: 115


Src: 
int getMinCost ( int [ ] A , int [ ] B , int N ) { int mini = Integer . MAX_VALUE ; for ( int i = 0 ; i < N ; i ++ ) { mini = Math . min ( mini , Math . min ( A [ i ] , B [ i ] ) ) ; } return mini * ( 2 * N - 1 ) ; }
Ref: 
def getMinCost ( A , B , N ) : NEW_LINE INDENT mini = sys . maxsize NEW_LINE for i in range ( N ) : NEW_LINE INDENT mini = min ( mini , min ( A [ i ] , B [ i ] ) ) NEW_LINE DEDENT return mini * ( 2 * N - 1 ) NEW_LINE DEDENT
Hyp: 
def getMinCost ( A , B , N ) : NEW_LINE INDENT mini = 10 ** 20 NEW_LINE for i in range ( N ) : NEW_LINE INDENT mini = min ( mini , min ( A [ i ] , B [ i ] ) ) NEW_LINE DEDENT return mini * ( 2 * N - 1 ) NEW_LINE DEDENT

BLEU: 92.5
Edit Sim: 12


Src: 
int countPieces ( int N ) { return 2 * N ; }
Ref: 
def countPieces ( N ) : NEW_LINE INDENT return 2 * N NEW_LINE DEDENT
Hyp: 
def countPieces ( N ) : NEW_LINE INDENT return 2 * N ; NEW_LINE DEDENT

BLEU: 83.71
Edit Sim: 2


Src: 
int getMaximum ( int N , int M , int [ ] [ ] mat ) { int global_max = Integer . MIN_VALUE ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { int row_min = Integer . MAX_VALUE ; for ( int k = 0 ; k < M ; k ++ ) { int m = Math . max ( mat [ i ] [ k ] , mat [ j ] [ k ] ) ; row_min = Math . min ( row_min , m ) ; } global_max = Math . max ( global_max , row_min ) ; } } return global_max ; }
Ref: 
def getMaximum ( N , M , mat ) : NEW_LINE INDENT global_max = - 1 * ( sys . maxsize ) NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT row_min = sys . maxsize NEW_LINE for k in range ( 0 , M ) : NEW_LINE INDENT m = max ( mat [ i ] [ k ] , mat [ j ] [ k ] ) NEW_LINE row_min = min ( row_min , m ) NEW_LINE DEDENT global_max = max ( global_max , row_min ) NEW_LINE DEDENT DEDENT return global_max NEW_LINE DEDENT
Hyp: 
def getMaximum ( N , M , mat ) : NEW_LINE INDENT global_max = INT_MIN ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT row_min = INT_MAX ; NEW_LINE for k in range ( M ) : NEW_LINE INDENT m = max ( mat [ i ] [ k ] , mat [ j ] [ k ] ) NEW_LINE row_min = min ( row_min , m ) NEW_LINE DEDENT global_max = max ( global_max , row_min ) NEW_LINE DEDENT DEDENT return global_max NEW_LINE DEDENT

BLEU: 80.79
Edit Sim: 43


Src: 
int countEqual ( int n ) { return ( n + 1 ) / 2 ; }
Ref: 
def countEqual ( n ) : NEW_LINE INDENT return ( n + 1 ) // 2 NEW_LINE DEDENT
Hyp: 
def countEqual ( n ) : NEW_LINE INDENT return ( n + 1 ) // 2 NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int findRepeatingElement ( int arr [ ] , int low , int high ) { if ( low > high ) return - 1 ; int mid = ( low + high ) / 2 ; if ( arr [ mid ] != mid + 1 ) { if ( mid > 0 && arr [ mid ] == arr [ mid - 1 ] ) return mid ; return findRepeatingElement ( arr , low , mid - 1 ) ; } return findRepeatingElement ( arr , mid + 1 , high ) ; }
Ref: 
def findRepeatingElement ( arr , low , high ) : NEW_LINE INDENT if low > high : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = ( low + high ) / 2 NEW_LINE if ( arr [ mid ] != mid + 1 ) : NEW_LINE INDENT if ( mid > 0 and arr [ mid ] == arr [ mid - 1 ] ) : NEW_LINE INDENT return mid NEW_LINE DEDENT return findRepeatingElement ( arr , low , mid - 1 ) NEW_LINE DEDENT return findRepeatingElement ( arr , mid + 1 , high ) NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE index = findRepeatingElement ( arr , 0 , n - 1 ) NEW_LINE if ( index is not - 1 ) : NEW_LINE INDENT print arr [ index ] NEW_LINE DEDENT
Hyp: 
def findRepeatingElement ( arr , low , high ) : NEW_LINE INDENT if ( low > high ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = ( low + high ) // 2 NEW_LINE if ( arr [ mid ] != mid + 1 ) : NEW_LINE INDENT if ( mid > 0 and arr [ mid ] == arr [ mid - 1 ] ) : NEW_LINE INDENT return mid NEW_LINE DEDENT return findRepeatingElement ( arr , low , mid - 1 ) NEW_LINE DEDENT return findRepeatingElement ( arr , mid + 1 , high ) NEW_LINE DEDENT

BLEU: 56.12
Edit Sim: 207


Src: 
int swapBits ( int n , int p1 , int p2 ) { n ^= 1 << p1 ; n ^= 1 << p2 ; return n ; }
Ref: 
def swapBits ( n , p1 , p2 ) : NEW_LINE INDENT n ^= 1 << p1 NEW_LINE n ^= 1 << p2 NEW_LINE return n NEW_LINE DEDENT
Hyp: 
def swapBits ( n , p1 , p2 ) : NEW_LINE INDENT n ^= 1 << p1 NEW_LINE n ^= 1 << p2 NEW_LINE return n NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
boolean isRatioPossible ( int lowCost , int upCost , int lowQuant , int upQuant , int r ) { for ( int i = lowQuant ; i <= upQuant ; i ++ ) { int ans = i * r ; if ( lowCost <= ans && ans <= upCost ) return true ; } return false ; }
Ref: 
def isRatioPossible ( lowCost , upCost , lowQuant , upQuant , r ) : NEW_LINE INDENT for i in range ( lowQuant , upQuant + 1 ) : NEW_LINE INDENT ans = i * r NEW_LINE if ( lowCost <= ans and ans <= upCost ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT lowCost = 14 ; upCost = 30 NEW_LINE lowQuant = 5 ; upQuant = 12 ; r = 9 NEW_LINE if ( isRatioPossible ( lowCost , upCost , lowQuant , upQuant , r ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
Hyp: 
def isRatioPossible ( lowCost , upCost , lowQuant , upQuant , r ) : NEW_LINE INDENT for i in range ( lowQuant , upQuant + 1 ) : NEW_LINE INDENT ans = i * r NEW_LINE if ( lowCost <= ans and ans <= upCost ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT

BLEU: 36.79
Edit Sim: 258


Src: 
int findNthOccur ( String str , char ch , int N ) { int occur = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) == ch ) { occur += 1 ; } if ( occur == N ) return i ; } return - 1 ; }
Ref: 
def findNthOccur ( string , ch , N ) : NEW_LINE INDENT occur = 0 ; NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT if ( string [ i ] == ch ) : NEW_LINE INDENT occur += 1 ; NEW_LINE DEDENT if ( occur == N ) : NEW_LINE INDENT return i ; NEW_LINE DEDENT DEDENT return - 1 ; NEW_LINE DEDENT
Hyp: 
def findNthOccur ( string , ch , N ) : NEW_LINE INDENT occur = 0 NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT if ( string [ i ] == ch ) : NEW_LINE INDENT occur += 1 NEW_LINE DEDENT if ( occur == N ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT

BLEU: 85.32
Edit Sim: 8


Src: 
int centereddecagonalnum ( int n ) { return ( 5 * n * n + 5 * n + 1 ) ; }
Ref: 
def centereddecagonalnum ( n ) : NEW_LINE INDENT return ( 5 * n * n + 5 * n + 1 ) NEW_LINE DEDENT
Hyp: 
def centereddecagonalnum ( n ) : NEW_LINE INDENT return ( 5 * n * n + 5 * n + 1 ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
void printGolomb ( int n ) { int dp [ ] = new int [ n + 1 ] ; dp [ 1 ] = 1 ; System . out . print ( dp [ 1 ] + " ▁ " ) ; for ( int i = 2 ; i <= n ; i ++ ) { dp [ i ] = 1 + dp [ i - dp [ dp [ i - 1 ] ] ] ; System . out . print ( dp [ i ] + " ▁ " ) ; } }
Ref: 
def Golomb ( n ) : NEW_LINE INDENT dp = [ 0 ] * ( n + 1 ) NEW_LINE dp [ 1 ] = 1 NEW_LINE print ( dp [ 1 ] , end = " ▁ " ) NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT dp [ i ] = 1 + dp [ i - dp [ dp [ i - 1 ] ] ] NEW_LINE print ( dp [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
Hyp: 
def printGolomb ( n ) : NEW_LINE INDENT dp = [ ] NEW_LINE dp . append ( 1 ) NEW_LINE dp . append ( 1 ) NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT dp . append ( 1 + dp [ i - dp [ dp [ i - 1 ] ] ] ) NEW_LINE print ( dp [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT

BLEU: 61.83
Edit Sim: 60


Src: 
int checkValidity ( int a , int b , int c ) { if ( a + b <= c a + c <= b b + c <= a ) return 0 ; else return 1 ; }
Ref: 
def checkValidity ( a , b , c ) : NEW_LINE INDENT if ( a + b <= c ) or ( a + c <= b ) or ( b + c <= a ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT a = 7 NEW_LINE b = 10 NEW_LINE c = 5 NEW_LINE if checkValidity ( a , b , c ) : NEW_LINE INDENT print ( " Valid " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Invalid " ) NEW_LINE DEDENT
Hyp: 
def checkValidity ( a , b , c ) : NEW_LINE INDENT if ( a + b <= c or a + c <= b b + c <= a ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT else : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT DEDENT a = 1 NEW_LINE b = 2 NEW_LINE c = 3 NEW_LINE if ( checkValidity ( a , b , c ) ) : NEW_LINE INDENT print ( " YES " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) ; NEW_LINE DEDENT

BLEU: 66.1
Edit Sim: 44


Src: 
void bcdToHexaDecimal ( char [ ] s ) { int len = s . length , check = 0 ; int num = 0 , sum = 0 , mul = 1 ; Vector < Character > ans = new Vector < Character > ( ) ; for ( int i = len - 1 ; i >= 0 ; i -- ) { sum += ( s [ i ] - '0' ) * mul ; mul *= 2 ; check ++ ; if ( check == 4 i == 0 ) { if ( sum <= 9 ) ans . add ( ( char ) ( sum + '0' ) ) ; else ans . add ( ( char ) ( sum + 55 ) ) ; check = 0 ; sum = 0 ; mul = 1 ; } } len = ans . size ( ) ; for ( int i = len - 1 ; i >= 0 ; i -- ) System . out . print ( ans . get ( i ) ) ; }
Ref: 
def bcdToHexaDecimal ( s ) : NEW_LINE INDENT len1 = len ( s ) NEW_LINE check = 0 NEW_LINE num = 0 NEW_LINE sum = 0 NEW_LINE mul = 1 NEW_LINE ans = [ ] NEW_LINE i = len1 - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT sum += ( ord ( s [ i ] ) - ord ( '0' ) ) * mul NEW_LINE mul *= 2 NEW_LINE check += 1 NEW_LINE if ( check == 4 or i == 0 ) : NEW_LINE INDENT if ( sum <= 9 ) : NEW_LINE INDENT ans . append ( chr ( sum + ord ( '0' ) ) ) NEW_LINE DEDENT else : NEW_LINE INDENT ans . append ( chr ( sum + 55 ) ) ; NEW_LINE DEDENT check = 0 NEW_LINE sum = 0 NEW_LINE mul = 1 NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT len1 = len ( ans ) NEW_LINE i = len1 - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT print ( ans [ i ] , end = " " ) NEW_LINE i -= 1 NEW_LINE DEDENT DEDENT
Hyp: 
def bcdToHexaDecimal ( s ) : NEW_LINE INDENT ln = len ( s ) NEW_LINE check = 0 NEW_LINE num = 0 NEW_LINE sum = 0 NEW_LINE mul = 1 NEW_LINE ans = [ ] NEW_LINE for i in range ( len - 1 , - 1 , - 1 ) : NEW_LINE INDENT sum += ord ( s [ i ] ) * mul NEW_LINE mul *= 2 NEW_LINE check += 1 NEW_LINE if ( check == 4 i == 0 ) : NEW_LINE INDENT ans . append ( chr ( sum + '0' ) ) NEW_LINE DEDENT else : NEW_LINE INDENT ans . append ( chr ( sum + 55 ) ) NEW_LINE DEDENT check = 0 NEW_LINE sum = 0 NEW_LINE mul = 1 NEW_LINE DEDENT DEDENT len = len ( ans ) NEW_LINE for i in range ( 0 , ln ) : NEW_LINE INDENT print ( ans [ i ] ) NEW_LINE DEDENT

BLEU: 61.62
Edit Sim: 177


Src: 
int countCubes ( int a , int b ) { for ( int i = a ; i <= b ; i ++ ) for ( int j = 1 ; j * j * j <= i ; j ++ ) if ( j * j * j == i ) cnt ++ ; return cnt ; }
Ref: 
def countCubes ( a , b ) : NEW_LINE INDENT for i in range ( a , b + 1 ) : NEW_LINE INDENT for j in range ( i + 1 ) : NEW_LINE INDENT if j * j * j > i : NEW_LINE INDENT break NEW_LINE DEDENT if j * j * j == i : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT
Hyp: 
def countCubes ( a , b ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( a , b + 1 ) : NEW_LINE INDENT for j in range ( 1 , int ( sqrt ( i ) ) + 1 ) : NEW_LINE INDENT if ( j * j * j <= i ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT

BLEU: 68.6
Edit Sim: 73


Src: 
int LongestOddEvenSubarray ( int A [ ] , int N ) { int dp ; dp = 1 ; int ans = 1 ; for ( int i = 1 ; i < N ; i ++ ) { if ( ( A [ i ] % 2 == 0 && A [ i - 1 ] % 2 == 0 ) || ( A [ i ] % 2 != 0 && A [ i - 1 ] % 2 != 0 ) ) { dp = dp + 1 ; ans = Math . max ( ans , dp ) ; } else dp = 1 ; } return ans ; }
Ref: 
def LongestOddEvenSubarray ( A , N ) : NEW_LINE INDENT dp = 1 NEW_LINE ans = 1 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT if ( ( A [ i ] % 2 == 0 and A [ i - 1 ] % 2 == 0 ) or ( A [ i ] % 2 != 0 and A [ i - 1 ] % 2 != 0 ) ) : NEW_LINE INDENT dp = dp + 1 NEW_LINE ans = max ( ans , dp ) NEW_LINE DEDENT else : NEW_LINE INDENT dp = 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
Hyp: 
def LongestOddEvenSubarray ( A , N ) : NEW_LINE INDENT dp = 1 NEW_LINE ans = 1 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT if ( ( A [ i ] % 2 == 0 and A [ i - 1 ] % 2 == 0 ) or ( A [ i ] % 2 != 0 and A [ i - 1 ] % 2 != 0 ) ) : NEW_LINE INDENT dp = dp + 1 NEW_LINE ans = max ( ans , dp ) NEW_LINE DEDENT else : NEW_LINE INDENT dp = 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
long partitions ( int n ) { long p [ ] = new long [ n + 1 ] ; p [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; ++ i ) { int k = 1 ; while ( ( k * ( 3 * k - 1 ) ) / 2 <= i ) { p [ i ] += ( k % 2 != 0 ? 1 : - 1 ) * p [ i - ( k * ( 3 * k - 1 ) ) / 2 ] ; if ( k > 0 ) { k *= - 1 ; } else { k = 1 - k ; } } } return p [ n ] ; }
Ref: 
def partitions ( n ) : NEW_LINE INDENT p = [ 0 ] * ( n + 1 ) NEW_LINE p [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT k = 1 NEW_LINE while ( ( k * ( 3 * k - 1 ) ) / 2 <= i ) : NEW_LINE INDENT p [ i ] += ( ( 1 if k % 2 else - 1 ) * p [ i - ( k * ( 3 * k - 1 ) ) // 2 ] ) NEW_LINE if ( k > 0 ) : NEW_LINE INDENT k *= - 1 NEW_LINE DEDENT else : NEW_LINE INDENT k = 1 - k NEW_LINE DEDENT DEDENT DEDENT return p [ n ] NEW_LINE DEDENT
Hyp: 
def partitions ( n ) : NEW_LINE INDENT p = [ 0 ] * ( n + 1 ) NEW_LINE p [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT k = 1 NEW_LINE while ( ( k * ( 3 * k - 1 ) ) // 2 <= i ) : NEW_LINE INDENT p [ i ] += ( k % 2 != 0 ? 1 : - 1 ) * p [ i - ( k * ( 3 * k - 1 ) ) // 2 ] NEW_LINE if ( k > 0 ) : NEW_LINE INDENT k *= - 1 NEW_LINE DEDENT else : NEW_LINE INDENT k = 1 - k NEW_LINE DEDENT DEDENT DEDENT return p [ n ] NEW_LINE DEDENT

BLEU: 91.36
Edit Sim: 15


Src: 
int min_operation ( int a [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i > 0 ) ans += Math . abs ( a [ i ] - a [ i - 1 ] ) ; else ans += Math . abs ( a [ i ] ) ; } return ans ; }
Ref: 
def min_operation ( a , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i > 0 ) : NEW_LINE INDENT ans += abs ( a [ i ] - a [ i - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT ans += abs ( a [ i ] ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
Hyp: 
def min_operation ( a , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i > 0 ) : NEW_LINE INDENT ans += abs ( a [ i ] - a [ i - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT ans += abs ( a [ i ] ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
boolean isWoodall ( int x ) { if ( x % 2 == 0 ) return false ; if ( x == 1 ) return true ; int p = 0 ; while ( x % 2 == 0 ) { x = x / 2 ; p ++ ; if ( p == x ) return true ; } return false ; }
Ref: 
def isWoodall ( x ) : NEW_LINE INDENT if ( x % 2 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( x == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT p = 0 NEW_LINE while ( x % 2 == 0 ) : NEW_LINE INDENT x = x / 2 NEW_LINE p = p + 1 NEW_LINE if ( p == x ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT x = 383 NEW_LINE if ( isWoodall ( x ) ) : NEW_LINE INDENT print " Yes " NEW_LINE DEDENT else : NEW_LINE INDENT print " No " NEW_LINE DEDENT
Hyp: 
def isWoodall ( x ) : NEW_LINE INDENT if ( x % 2 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( x == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT p = 0 NEW_LINE while ( x % 2 == 0 ) : NEW_LINE INDENT x = int ( x / 2 ) NEW_LINE p += 1 NEW_LINE if ( p == x ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT

BLEU: 63.61
Edit Sim: 153


Src: 
void mindigits ( int n ) { if ( n % 9 == 0 ) { System . out . println ( n / 9 ) ; } else { System . out . println ( ( n / 9 ) + 1 ) ; } }
Ref: 
def mindigits ( n ) : NEW_LINE INDENT if ( n % 9 == 0 ) : NEW_LINE INDENT print ( n // 9 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( ( n // 9 ) + 1 ) ; NEW_LINE DEDENT DEDENT
Hyp: 
def mindigits ( n ) : NEW_LINE INDENT if n % 9 == 0 : NEW_LINE INDENT print ( int ( n / 9 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( int ( n / 9 ) + 1 ) NEW_LINE DEDENT DEDENT

BLEU: 61.52
Edit Sim: 18


Src: 
int find_longest_subarray ( int [ ] A , int N , int K ) { int MaxLen = 0 ; int Len = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( K % A [ i ] == 0 ) { Len ++ ; MaxLen = Math . max ( MaxLen , Len ) ; } else { Len = 0 ; } } return MaxLen ; }
Ref: 
def find_longest_subarray ( A , N , K ) : NEW_LINE INDENT MaxLen = 0 NEW_LINE Len = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( K % A [ i ] == 0 ) : NEW_LINE INDENT Len += 1 NEW_LINE MaxLen = max ( MaxLen , Len ) NEW_LINE DEDENT else : NEW_LINE INDENT Len = 0 NEW_LINE DEDENT DEDENT return MaxLen NEW_LINE DEDENT
Hyp: 
def find_longest_subarray ( A , N , K ) : NEW_LINE INDENT MaxLen = 0 NEW_LINE Len = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( K % A [ i ] == 0 ) : NEW_LINE INDENT Len += 1 NEW_LINE MaxLen = max ( MaxLen , Len ) NEW_LINE DEDENT else : NEW_LINE INDENT Len = 0 NEW_LINE DEDENT DEDENT return MaxLen NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int maxXOR ( int mat [ ] [ ] , int N ) { int r_xor , c_xor ; int max_xor = 0 ; for ( int i = 0 ; i < N ; i ++ ) { r_xor = 0 ; c_xor = 0 ; for ( int j = 0 ; j < N ; j ++ ) { r_xor = r_xor ^ mat [ i ] [ j ] ; c_xor = c_xor ^ mat [ j ] [ i ] ; } if ( max_xor < Math . max ( r_xor , c_xor ) ) max_xor = Math . max ( r_xor , c_xor ) ; } return max_xor ; }
Ref: 
def maxXOR ( mat , N ) : NEW_LINE INDENT max_xor = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT r_xor = 0 NEW_LINE c_xor = 0 NEW_LINE for j in range ( N ) : NEW_LINE INDENT r_xor = r_xor ^ mat [ i ] [ j ] NEW_LINE c_xor = c_xor ^ mat [ j ] [ i ] NEW_LINE DEDENT if ( max_xor < max ( r_xor , c_xor ) ) : NEW_LINE INDENT max_xor = max ( r_xor , c_xor ) NEW_LINE DEDENT DEDENT return max_xor NEW_LINE DEDENT
Hyp: 
def maxXOR ( mat , N ) : NEW_LINE INDENT r_xor = 0 NEW_LINE c_xor = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT r_xor = 0 NEW_LINE c_xor = 0 NEW_LINE for j in range ( N ) : NEW_LINE INDENT r_xor = r_xor ^ mat [ i ] [ j ] NEW_LINE c_xor = c_xor ^ mat [ j ] [ i ] NEW_LINE DEDENT if ( max_xor < max ( r_xor , c_xor ) ) : NEW_LINE INDENT max_xor = max ( r_xor , c_xor ) NEW_LINE DEDENT DEDENT return max_xor NEW_LINE DEDENT

BLEU: 93.45
Edit Sim: 19


Src: 
int numberOfSquares ( int base ) { base = ( base - 2 ) ; base = Math . floorDiv ( base , 2 ) ; return base * ( base + 1 ) / 2 ; }
Ref: 
def numberOfSquares ( base ) : NEW_LINE INDENT base = ( base - 2 ) NEW_LINE base = base // 2 NEW_LINE return base * ( base + 1 ) / 2 NEW_LINE DEDENT
Hyp: 
def numberOfSquares ( base ) : NEW_LINE INDENT base = ( base - 2 ) NEW_LINE base = math . floorDiv ( base , 2 ) NEW_LINE return base * ( base + 1 ) / 2 NEW_LINE DEDENT

BLEU: 76.28
Edit Sim: 22


Src: 
int find_and ( int arr [ ] ) { int ans = arr [ 0 ] ; for ( int i = 0 ; i < arr . length ; i ++ ) { ans = ( ans & arr [ i ] ) ; } return ans ; }
Ref: 
def find_and ( arr ) : NEW_LINE INDENT ans = arr [ 0 ] NEW_LINE for i in range ( 1 , len ( arr ) ) : NEW_LINE INDENT ans = ans & arr [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT
Hyp: 
def find_and ( arr , n ) : NEW_LINE INDENT ans = arr [ 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans = ( ans & arr [ i ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT

BLEU: 72.61
Edit Sim: 22


Src: 
int countIncreasing ( int n ) { int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ j ] > arr [ j - 1 ] ) cnt ++ ; else break ; } } return cnt ; }
Ref: 
def countIncreasing ( arr , n ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if arr [ j ] > arr [ j - 1 ] : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT
Hyp: 
def countIncreasing ( arr , n ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ j ] > arr [ j - 1 ] ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT

BLEU: 90.84
Edit Sim: 8


Src: 
boolean checkForSorting ( int arr [ ] , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] > arr [ i + 1 ] ) { if ( arr [ i ] - arr [ i + 1 ] == 1 ) { int temp = arr [ i ] ; arr [ i ] = arr [ i + 1 ] ; arr [ i + 1 ] = temp ; } else return false ; } } return true ; }
Ref: 
def checkForSorting ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i + 1 ] ) : NEW_LINE INDENT if ( arr [ i ] - arr [ i + 1 ] == 1 ) : NEW_LINE INDENT arr [ i ] , arr [ i + 1 ] = arr [ i + 1 ] , arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT arr = [ 1 , 0 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE if ( checkForSorting ( arr , n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
Hyp: 
def checkForSorting ( arr , n ) : NEW_LINE INDENT for i in range ( n - 1 ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i + 1 ] ) : NEW_LINE INDENT if ( arr [ i ] - arr [ i + 1 ] == 1 ) : NEW_LINE INDENT temp = arr [ i ] NEW_LINE arr [ i ] = arr [ i + 1 ] NEW_LINE arr [ i + 1 ] = temp NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT

BLEU: 54.14
Edit Sim: 234


Src: 
void solve ( int N ) { int ans = 0 ; while ( N != 0 ) { ans += N ; N /= 2 ; } System . out . println ( ans ) ; }
Ref: 
def solve ( N ) : NEW_LINE INDENT ans = 0 NEW_LINE while ( N != 0 ) : NEW_LINE INDENT ans += N NEW_LINE N //= 2 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
Hyp: 
def solve ( N ) : NEW_LINE INDENT ans = 0 NEW_LINE while ( N ) : NEW_LINE INDENT ans += N NEW_LINE N //= 2 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT

BLEU: 89.9
Edit Sim: 5


Src: 
void printSeries ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) { int num = i * ( i + 1 ) * ( i + 2 ) / 6 ; System . out . print ( num + " ▁ " ) ; } }
Ref: 
def printSeries ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT num = i * ( i + 1 ) * ( i + 2 ) // 6 NEW_LINE print ( num , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT
Hyp: 
def printSeries ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT num = i * ( i + 1 ) * ( i + 2 ) // 6 NEW_LINE print ( num , end = " ▁ " ) NEW_LINE DEDENT DEDENT

BLEU: 91.79
Edit Sim: 2


Src: 
double find ( double p ) { return Math . ceil ( Math . sqrt ( 2 * 365 * Math . log ( 1 / ( 1 - p ) ) ) ) ; }
Ref: 
def find ( p ) : NEW_LINE INDENT return math . ceil ( math . sqrt ( 2 * 365 * math . log ( 1 / ( 1 - p ) ) ) ) ; NEW_LINE DEDENT
Hyp: 
def find ( p ) : NEW_LINE INDENT return math . ceil ( math . sqrt ( 2 * 365 * math . log ( 1 / ( 1 - p ) ) ) ) NEW_LINE DEDENT

BLEU: 93.91
Edit Sim: 2


Src: 
int getResult ( int n ) { if ( ( n & 1 ) > 0 ) return 1 ; return - 1 ; }
Ref: 
def getResult ( n ) : NEW_LINE INDENT if n & 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
Hyp: 
def getResult ( n ) : NEW_LINE INDENT if ( n & 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT

BLEU: 79.38
Edit Sim: 4


Src: 
void check ( int n ) { if ( ( n & n - 1 ) != 0 ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; }
Ref: 
def check ( n ) : NEW_LINE INDENT if ( ( n & n - 1 ) != 0 ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
Hyp: 
def check ( n ) : NEW_LINE INDENT if ( n & n - 1 ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT

BLEU: 86.85
Edit Sim: 9


Src: 
int weightedMean ( int n ) { return ( 2 * n + 1 ) / 3 ; }
Ref: 
def weightedMean ( n ) : NEW_LINE INDENT return ( 2 * n + 1 ) / 3 NEW_LINE DEDENT
Hyp: 
def weightedMean ( n ) : NEW_LINE INDENT return ( 2 * n + 1 ) / 3 NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int minCostToMakeElementEqual ( int a [ ] , int n ) { int y ; if ( n % 2 == 1 ) y = a [ n / 2 ] ; else y = ( a [ n / 2 ] + a [ ( n - 2 ) / 2 ] ) / 2 ; int s = 0 ; for ( int i = 0 ; i < n ; i ++ ) s += Math . abs ( a [ i ] - y ) ; return s ; }
Ref: 
def minCostToMakeElementEqual ( a ) : NEW_LINE INDENT l = len ( a ) NEW_LINE if ( l % 2 == 1 ) : NEW_LINE INDENT y = a [ l // 2 ] NEW_LINE DEDENT else : NEW_LINE INDENT y = ( a [ l // 2 ] + a [ ( l - 2 ) // 2 ] ) // 2 NEW_LINE DEDENT s = 0 NEW_LINE for i in range ( l ) : NEW_LINE INDENT s += abs ( a [ i ] - y ) NEW_LINE DEDENT return s NEW_LINE DEDENT
Hyp: 
def minCostToMakeElementEqual ( a , n ) : NEW_LINE INDENT y = 0 NEW_LINE if n % 2 == 1 : NEW_LINE INDENT y = a [ n // 2 ] NEW_LINE DEDENT else : NEW_LINE INDENT y = ( a [ n // 2 ] + a [ ( n - 2 ) // 2 ] ) // 2 NEW_LINE DEDENT s = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s += abs ( a [ i ] - y ) NEW_LINE DEDENT return s NEW_LINE DEDENT

BLEU: 73.58
Edit Sim: 23


Src: 
int minimumAdditionOperation ( int N ) { int count = 0 ; while ( N > 0 ) { if ( N % 2 == 1 ) { count ++ ; } N = N >> 1 ; } return count ; }
Ref: 
def minimumAdditionOperation ( N ) : NEW_LINE INDENT count = 0 NEW_LINE while ( N ) : NEW_LINE INDENT if ( N & 1 == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT N = N >> 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
Hyp: 
def minimumAdditionOperation ( N ) : NEW_LINE INDENT count = 0 NEW_LINE while ( N > 0 ) : NEW_LINE INDENT if ( N % 2 == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT N = N >> 1 NEW_LINE DEDENT return count NEW_LINE DEDENT

BLEU: 84.99
Edit Sim: 6


Src: 
boolean isMember ( int a , int d , int x ) { if ( d == 0 ) return ( x == a ) ; return ( ( x - a ) % d == 0 && ( x - a ) / d >= 0 ) ; }
Ref: 
def isMember ( a , d , x ) : NEW_LINE INDENT if d == 0 : NEW_LINE INDENT return x == a NEW_LINE DEDENT return ( ( x - a ) % d == 0 and int ( ( x - a ) / d ) >= 0 ) NEW_LINE DEDENT a = 1 NEW_LINE x = 7 NEW_LINE d = 3 NEW_LINE if isMember ( a , d , x ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
Hyp: 
def isMember ( a , d , x ) : NEW_LINE INDENT if ( d == 0 ) : NEW_LINE INDENT return ( x == a ) NEW_LINE DEDENT if ( ( x - a ) % d == 0 and ( x - a ) // d >= 0 ) : NEW_LINE INDENT return ( ( x - a ) % d == 0 and ( x - a ) // d >= 0 ) NEW_LINE DEDENT DEDENT

BLEU: 42.66
Edit Sim: 156


Src: 
int nthTerm ( int n ) { return ( int ) Math . pow ( n , 2 ) + 2 * n + 2 ; }
Ref: 
def nthTerm ( n ) : NEW_LINE INDENT return pow ( n , 2 ) + 2 * n + 2 NEW_LINE DEDENT
Hyp: 
def nthTerm ( n ) : NEW_LINE INDENT return pow ( n , 2 ) + 2 * n + 2 NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int MatrixChainOrder ( int p [ ] , int i , int j ) { if ( i == j ) return 0 ; int min = Integer . MAX_VALUE ; for ( int k = i ; k < j ; k ++ ) { int count = MatrixChainOrder ( p , i , k ) + MatrixChainOrder ( p , k + 1 , j ) + p [ i - 1 ] * p [ k ] * p [ j ] ; if ( count < min ) min = count ; } return min ; }
Ref: 
def MatrixChainOrder ( p , i , j ) : NEW_LINE INDENT if i == j : NEW_LINE INDENT return 0 NEW_LINE DEDENT _min = sys . maxsize NEW_LINE for k in range ( i , j ) : NEW_LINE INDENT count = ( MatrixChainOrder ( p , i , k ) + MatrixChainOrder ( p , k + 1 , j ) + p [ i - 1 ] * p [ k ] * p [ j ] ) NEW_LINE if count < _min : NEW_LINE INDENT _min = count NEW_LINE DEDENT DEDENT return _min NEW_LINE DEDENT
Hyp: 
def MatrixChainOrder ( p , i , j ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT min = INT_MAX ; NEW_LINE for k in range ( i , j ) : NEW_LINE INDENT count = MatrixChainOrder ( p , i , k ) + MatrixChainOrder ( p , k + 1 , j ) + p [ i - 1 ] * p [ k ] * p [ j ] ; NEW_LINE if ( count < min ) : NEW_LINE INDENT min = count NEW_LINE DEDENT DEDENT return min NEW_LINE DEDENT

BLEU: 75.31
Edit Sim: 28


Src: 
int CountPairs ( int [ ] arr , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] % 2 == 0 arr [ j ] % 2 == 0 ) count ++ ; } } return count ; }
Ref: 
def CountPairs ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 or arr [ j ] % 2 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
Hyp: 
def CountPairs ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 or arr [ j ] % 2 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
void first_digit ( int x , int y ) { int length = ( int ) ( Math . log ( x ) / Math . log ( y ) + 1 ) ; int first_digit = ( int ) ( x / Math . pow ( y , length - 1 ) ) ; System . out . println ( first_digit ) ; }
Ref: 
def first_digit ( x , y ) : NEW_LINE INDENT length = int ( math . log ( x ) / math . log ( y ) + 1 ) NEW_LINE first_digit = x / math . pow ( y , length - 1 ) NEW_LINE print ( int ( first_digit ) ) NEW_LINE DEDENT
Hyp: 
def first_digit ( x , y ) : NEW_LINE INDENT length = int ( log ( x ) / log ( y ) + 1 ) NEW_LINE first_digit = int ( x / pow ( y , length - 1 ) ) NEW_LINE print ( first_digit ) NEW_LINE DEDENT

BLEU: 69.29
Edit Sim: 32


Src: 
void findMaxDifference ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int Leftsum = 0 ; int Totalsum = 0 ; int Min = Integer . MAX_VALUE , Max = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) Totalsum += arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) { int leftNumbers = i ; int rightNumbers = n - i - 1 ; Totalsum = Totalsum - arr [ i ] ; int sum = ( leftNumbers * arr [ i ] ) - Leftsum + Totalsum - ( rightNumbers * arr [ i ] ) ; Min = Math . min ( Min , sum ) ; Max = Math . max ( Max , sum ) ; Leftsum += arr [ i ] ; } System . out . print ( Max - Min ) ; }
Ref: 
def findMaxDifference ( arr , n ) : NEW_LINE INDENT arr = sorted ( arr ) NEW_LINE Leftsum = 0 NEW_LINE Totalsum = 0 NEW_LINE Min , Max = 10 ** 8 , - 10 ** 8 NEW_LINE for i in range ( n ) : NEW_LINE INDENT Totalsum += arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT leftNumbers = i NEW_LINE rightNumbers = n - i - 1 NEW_LINE Totalsum = Totalsum - arr [ i ] NEW_LINE sum = ( leftNumbers * arr [ i ] ) - Leftsum + Totalsum - ( rightNumbers * arr [ i ] ) NEW_LINE Min = min ( Min , sum ) NEW_LINE Max = max ( Max , sum ) NEW_LINE Leftsum += arr [ i ] NEW_LINE DEDENT print ( Max - Min ) NEW_LINE DEDENT
Hyp: 
def findMaxDifference ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE Leftsum = 0 NEW_LINE Totalsum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT Totalsum += arr [ i ] NEW_LINE DEDENT print ( Max - Min ) NEW_LINE DEDENT

BLEU: 13.41
Edit Sim: 385


Src: 
int maxsubStringLength ( char [ ] S , int N ) { int arr [ ] = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) if ( S [ i ] == ' a ' S [ i ] == ' e ' S [ i ] == ' i ' S [ i ] == ' o ' S [ i ] == ' u ' ) arr [ i ] = 1 ; else arr [ i ] = - 1 ; int maxLen = 0 ; int curr_sum = 0 ; HashMap < Integer , Integer > hash = new HashMap < > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { curr_sum += arr [ i ] ; if ( curr_sum == 0 ) maxLen = Math . max ( maxLen , i + 1 ) ; if ( hash . containsKey ( curr_sum ) ) maxLen = Math . max ( maxLen , i - hash . get ( curr_sum ) ) ; else hash . put ( curr_sum , i ) ; } return maxLen ; }
Ref: 
def maxsubstringLength ( S , N ) : NEW_LINE INDENT arr = [ 0 ] * N NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( S [ i ] == ' a ' or S [ i ] == ' e ' or S [ i ] == ' i ' or S [ i ] == ' o ' or S [ i ] == ' u ' ) : NEW_LINE INDENT arr [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = - 1 NEW_LINE DEDENT DEDENT maxLen = 0 NEW_LINE curr_sum = 0 NEW_LINE hash = { } NEW_LINE for i in range ( N ) : NEW_LINE INDENT curr_sum += arr [ i ] NEW_LINE if ( curr_sum == 0 ) : NEW_LINE INDENT maxLen = max ( maxLen , i + 1 ) NEW_LINE DEDENT if ( curr_sum in hash . keys ( ) ) : NEW_LINE INDENT maxLen = max ( maxLen , i - hash [ curr_sum ] ) NEW_LINE DEDENT else : NEW_LINE INDENT hash [ curr_sum ] = i NEW_LINE DEDENT DEDENT return maxLen NEW_LINE DEDENT
Hyp: 
def maxsubStringLength ( S , N ) : NEW_LINE INDENT arr = [ 0 ] * N NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( S [ i ] == ' a ' or S [ i ] == ' e ' or S [ i ] == ' i ' or S [ i ] == ' o ' or S [ i ] == ' u ' ) : NEW_LINE INDENT arr [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = - 1 NEW_LINE DEDENT DEDENT maxLen = 0 NEW_LINE curr_sum = 0 NEW_LINE hash = { } NEW_LINE for i in range ( N ) : NEW_LINE INDENT curr_sum += arr [ i ] NEW_LINE if ( curr_sum == 0 ) : NEW_LINE INDENT maxLen = max ( maxLen , i + 1 ) NEW_LINE DEDENT if ( hash [ curr_sum ] ) : NEW_LINE INDENT maxLen = max ( maxLen , i - hash [ curr_sum ] ) NEW_LINE DEDENT else : NEW_LINE INDENT hash [ curr_sum ] = i NEW_LINE DEDENT DEDENT return maxLen NEW_LINE DEDENT

BLEU: 94.99
Edit Sim: 22


Src: 
int minCost ( String A , String B ) { int n = A . length ( ) ; int i = 0 ; int maxlen = 0 ; while ( i < n ) { int length = 0 ; for ( int j = 0 ; j < n ; ++ j ) { if ( A . charAt ( i ) == B . charAt ( j ) ) { ++ i ; ++ length ; if ( i == n ) break ; } } maxlen = Math . max ( maxlen , length ) ; } return n - maxlen ; }
Ref: 
def minCost ( A , B ) : NEW_LINE INDENT n = len ( A ) ; NEW_LINE i = 0 ; NEW_LINE maxlen = 0 ; NEW_LINE while ( i < n ) : NEW_LINE INDENT length = 0 ; NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT if ( A [ i ] == B [ j ] ) : NEW_LINE INDENT i += 1 NEW_LINE length += 1 ; NEW_LINE if ( i == n ) : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT DEDENT maxlen = max ( maxlen , length ) ; NEW_LINE DEDENT return n - maxlen ; NEW_LINE DEDENT
Hyp: 
def minCost ( A , B ) : NEW_LINE INDENT n = len ( A ) NEW_LINE i = 0 NEW_LINE maxlen = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT length = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( A [ i ] == B [ j ] ) : NEW_LINE INDENT i += 1 NEW_LINE length += 1 NEW_LINE if ( i == n ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT maxlen = max ( maxlen , length ) NEW_LINE DEDENT return n - maxlen NEW_LINE DEDENT

BLEU: 76.77
Edit Sim: 27


Src: 
void printArr ( int n ) { if ( n % 4 == 0 ) { for ( int i = 1 ; i <= n / 2 ; i ++ ) System . out . print ( i * 2 + " ▁ " ) ; for ( int i = 1 ; i < n / 2 ; i ++ ) System . out . print ( i * 2 - 1 + " ▁ " ) ; System . out . println ( n + n / 2 - 1 ) ; } else System . out . print ( " - 1" ) ; }
Ref: 
def printArr ( n ) : NEW_LINE INDENT if ( n % 4 == 0 ) : NEW_LINE INDENT for i in range ( 1 , ( n / 2 ) + 1 ) : NEW_LINE INDENT print ( i * 2 , end = " ▁ " ) NEW_LINE DEDENT for i in range ( 1 , n / 2 ) : NEW_LINE INDENT print ( i * 2 - 1 , end = " ▁ " ) NEW_LINE DEDENT print ( n + n / 2 - 1 , end =   " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT DEDENT
Hyp: 
def printArr ( n ) : NEW_LINE INDENT n = int ( n ) NEW_LINE if n % 4 == 0 : NEW_LINE INDENT for i in range ( 1 , n // 2 + 1 ) : NEW_LINE INDENT print ( ( i * 2 ) , end = " ▁ " ) NEW_LINE DEDENT for i in range ( 1 , n // 2 + 1 ) : NEW_LINE INDENT print ( ( i * 2 - 1 ) , end = " ▁ " ) NEW_LINE DEDENT print ( n + n // 2 - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT DEDENT

BLEU: 71.99
Edit Sim: 57


Src: 
boolean onlyFirstAndLastAreSet ( int n ) { if ( n == 1 ) return true ; if ( n == 2 ) return false ; return ( ( ( n - 1 ) & ( n - 2 ) ) == 0 ) ; }
Ref: 
def onlyFirstAndLastAreSet ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n == 2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT return ( ( ( n - 1 ) & ( n - 2 ) ) == 0 ) NEW_LINE DEDENT n = 9 NEW_LINE if ( onlyFirstAndLastAreSet ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
Hyp: 
def onlyFirstAndLastAreSet ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n == 2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT return ( ( n - 1 ) & ( n - 2 ) ) == 0 ) NEW_LINE DEDENT

BLEU: 51.41
Edit Sim: 161


Src: 
void isConversionPossible ( String s1 , String s2 , int x ) { int diff = 0 , n ; n = s1 . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( s1 . charAt ( i ) == s2 . charAt ( i ) ) continue ; diff = ( ( int ) ( s2 . charAt ( i ) - s1 . charAt ( i ) ) + 26 ) % 26 ; if ( diff > x ) { System . out . println ( " NO " ) ; return ; } } System . out . println ( " YES " ) ; }
Ref: 
def isConversionPossible ( s1 , s2 , x ) : NEW_LINE INDENT n = len ( s1 ) NEW_LINE s1 = list ( s1 ) NEW_LINE s2 = list ( s2 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT diff = ord ( s2 [ i ] ) - ord ( s1 [ i ] ) NEW_LINE if diff == 0 : NEW_LINE INDENT continue NEW_LINE DEDENT if diff < 0 : NEW_LINE INDENT diff = diff + 26 NEW_LINE DEDENT if diff > x : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
Hyp: 
def isConversionPossible ( s1 , s2 , x ) : NEW_LINE INDENT diff = 0 NEW_LINE n = len ( s1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s1 [ i ] == s2 [ i ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT diff = ( int ) ( ord ( s2 [ i ] ) - ord ( s1 [ i ] ) + 26 ) % 26 NEW_LINE if ( diff > x ) : NEW_LINE INDENT print ( " NO " ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( " YES " ) NEW_LINE DEDENT

BLEU: 53.2
Edit Sim: 183


Src: 
int smallestIndex ( int [ ] a , int n ) { int right1 = 0 , right0 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 1 ) right1 = i ; else right0 = i ; } return Math . min ( right1 , right0 ) ; }
Ref: 
def smallestIndex ( a , n ) : NEW_LINE INDENT right1 = 0 NEW_LINE right0 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == 1 ) : NEW_LINE INDENT right1 = i NEW_LINE DEDENT else : NEW_LINE INDENT right0 = i NEW_LINE DEDENT DEDENT return min ( right1 , right0 ) NEW_LINE DEDENT
Hyp: 
def smallestIndex ( a , n ) : NEW_LINE INDENT right1 = 0 NEW_LINE right0 = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( a [ i ] == 1 ) : NEW_LINE INDENT right1 = i NEW_LINE DEDENT else : NEW_LINE INDENT right0 = i NEW_LINE DEDENT DEDENT return min ( right1 , right0 ) NEW_LINE DEDENT

BLEU: 94.61
Edit Sim: 4


Src: 
int countOpenDoors ( int N ) { int doorsOpen = ( int ) Math . sqrt ( N ) ; return doorsOpen ; }
Ref: 
def countOpenDoors ( N ) : NEW_LINE INDENT doorsOpen = int ( math . sqrt ( N ) ) NEW_LINE return doorsOpen NEW_LINE DEDENT
Hyp: 
def countOpenDoors ( N ) : NEW_LINE INDENT doorsOpen = int ( math . sqrt ( N ) ) ; NEW_LINE return doorsOpen ; NEW_LINE DEDENT

BLEU: 80.59
Edit Sim: 4


Src: 
void findMissing ( int arr1 [ ] , int arr2 [ ] , int M , int N ) { if ( M != N - 1 && N != M - 1 ) { System . out . println ( " Invalid ▁ Input " ) ; return ; } int res = 0 ; for ( int i = 0 ; i < M ; i ++ ) res = res ^ arr1 [ i ] ; for ( int i = 0 ; i < N ; i ++ ) res = res ^ arr2 [ i ] ; System . out . println ( " Missing ▁ element ▁ is ▁ " + res ) ; }
Ref: 
def findMissing ( arr1 , arr2 , M , N ) : NEW_LINE INDENT if ( M != N - 1 and N != M - 1 ) : NEW_LINE INDENT print ( " Invalid ▁ Input " ) NEW_LINE return NEW_LINE DEDENT res = 0 NEW_LINE for i in range ( 0 , M ) : NEW_LINE INDENT res = res ^ arr1 [ i ] ; NEW_LINE DEDENT for i in range ( 0 , N ) : NEW_LINE INDENT res = res ^ arr2 [ i ] NEW_LINE DEDENT print ( " Missing ▁ element ▁ is " , res ) NEW_LINE DEDENT
Hyp: 
def findMissing ( arr1 , arr2 , M , N ) : NEW_LINE INDENT if ( M != N - 1 and N != M - 1 ) : NEW_LINE INDENT print ( " Invalid ▁ Input " ) NEW_LINE return NEW_LINE DEDENT res = 0 NEW_LINE for i in range ( M ) : NEW_LINE INDENT res = res ^ arr1 [ i ] NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT res = res ^ arr2 [ i ] NEW_LINE DEDENT print ( " Missing ▁ element ▁ is ▁ " , res ) NEW_LINE DEDENT

BLEU: 89.37
Edit Sim: 12


Src: 
int countSetBitsRec ( int num ) { int nibble = 0 ; if ( 0 == num ) return num_to_bits [ 0 ] ; nibble = num & 0xf ; return num_to_bits [ nibble ] + countSetBitsRec ( num >> 4 ) ; }
Ref: 
def countSetBitsRec ( num ) : NEW_LINE INDENT nibble = 0 ; NEW_LINE if ( 0 == num ) : NEW_LINE INDENT return num_to_bits [ 0 ] ; NEW_LINE DEDENT nibble = num & 0xf ; NEW_LINE return num_to_bits [ nibble ] + countSetBitsRec ( num >> 4 ) ; NEW_LINE DEDENT
Hyp: 
def countSetBitsRec ( num ) : NEW_LINE INDENT nibble = 0 NEW_LINE if ( 0 == num ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT nibble = num & 0xf NEW_LINE return num_to_bits [ nibble ] + countSetBitsRec ( num >> 4 ) NEW_LINE DEDENT

BLEU: 72.32
Edit Sim: 24


Src: 
int Substring ( String s ) { int ans = 1 , temp = 1 ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == s . charAt ( i - 1 ) ) { ++ temp ; } else { ans = Math . max ( ans , temp ) ; temp = 1 ; } } ans = Math . max ( ans , temp ) ; return ans ; }
Ref: 
def Substring ( s ) : NEW_LINE INDENT ans , temp = 1 , 1 NEW_LINE for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == s [ i - 1 ] ) : NEW_LINE INDENT temp += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = max ( ans , temp ) NEW_LINE temp = 1 NEW_LINE DEDENT DEDENT ans = max ( ans , temp ) NEW_LINE return ans NEW_LINE DEDENT
Hyp: 
def Substring ( s ) : NEW_LINE INDENT ans = 1 ; temp = 1 ; NEW_LINE for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == s [ i - 1 ] ) : NEW_LINE INDENT temp += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT ans = max ( ans , temp ) ; NEW_LINE temp = 1 ; NEW_LINE DEDENT DEDENT ans = max ( ans , temp ) ; NEW_LINE return ans ; NEW_LINE DEDENT

BLEU: 78.39
Edit Sim: 18


Src: 
double numberOfTriangles ( int n ) { double ans = 2 * ( pow ( 3 , n ) ) - 1 ; return ans ; }
Ref: 
def numberOfTriangles ( n ) : NEW_LINE INDENT ans = 2 * ( pow ( 3 , n ) ) - 1 ; NEW_LINE return ans ; NEW_LINE DEDENT
Hyp: 
def numberOfTriangles ( n ) : NEW_LINE INDENT ans = 2 * ( pow ( 3 , n ) ) - 1 NEW_LINE return ans NEW_LINE DEDENT

BLEU: 82.62
Edit Sim: 4


Src: 
int countNum ( int n ) { if ( n == 1 ) return 1 ; int count = ( int ) Math . pow ( 2 , n - 2 ) ; return count ; }
Ref: 
def countNum ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT count = pow ( 2 , n - 2 ) NEW_LINE return count NEW_LINE DEDENT
Hyp: 
def countNum ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT count = pow ( 2 , n - 2 ) NEW_LINE return count NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
void solve ( int A , int B ) { double p = B / 2.0 ; double M = Math . ceil ( 4 * p ) ; int N = 1 ; int O = - 2 * A ; double Q = Math . ceil ( A * A + 4 * p * p ) ; System . out . println ( M + " ▁ " + N + " ▁ " + O + " ▁ " + Q ) ; }
Ref: 
def solve ( A , B ) : NEW_LINE INDENT p = B / 2 NEW_LINE M = int ( 4 * p ) NEW_LINE N = 1 NEW_LINE O = - 2 * A NEW_LINE Q = int ( A * A + 4 * p * p ) NEW_LINE return [ M , N , O , Q ] NEW_LINE DEDENT
Hyp: 
def solve ( A , B ) : NEW_LINE INDENT p = B / 2.0 NEW_LINE M = math . ceil ( 4 * p ) NEW_LINE N = 1 NEW_LINE O = - 2 * A NEW_LINE Q = ceil ( A * A + 4 * p * p ) NEW_LINE print ( M , N , " ▁ " , O , " ▁ " , Q ) NEW_LINE DEDENT

BLEU: 65.37
Edit Sim: 39


Src: 
int smallSumSubset ( List < Integer > data , int target , int maxVal ) { int sum = 0 ; for ( Integer i : data ) sum += i ; if ( target <= 0 ) return 0 ; else if ( sum < target ) return maxVal ; else if ( sum == target ) return data . size ( ) ; else if ( data . get ( 0 ) >= target ) return 1 ; else if ( data . get ( 0 ) < target ) { List < Integer > temp = new ArrayList < > ( ) ; for ( int i = 1 ; i < data . size ( ) ; i ++ ) temp . add ( data . get ( i ) ) ; return Math . min ( smallSumSubset ( temp , target , maxVal ) , 1 + smallSumSubset ( temp , target - data . get ( 0 ) , maxVal ) ) ; } return - 1 ; }
Ref: 
def smallSumSubset ( data , target , maxVal ) : NEW_LINE INDENT if target <= 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif sum ( data ) < target : NEW_LINE INDENT return maxVal NEW_LINE DEDENT elif sum ( data ) == target : NEW_LINE INDENT return len ( data ) NEW_LINE DEDENT elif data [ 0 ] >= target : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif data [ 0 ] < target : NEW_LINE INDENT return min ( smallSumSubset ( data [ 1 : ] ,   \ target , maxVal ) , 1 + smallSumSubset ( data [ 1 : ] ,   \ target - data [ 0 ] , maxVal ) ) NEW_LINE DEDENT DEDENT data = [ 3 , 1 , 7 , 1 , 2 ] NEW_LINE target = 11 NEW_LINE val = smallSumSubset ( data , target , len ( data ) + 1 ) NEW_LINE if val > len ( data ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( val ) NEW_LINE DEDENT
Hyp: 
def smallSumSubset ( data , target , maxVal ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in data : NEW_LINE INDENT sum += i NEW_LINE DEDENT if ( target <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( sum < target ) : NEW_LINE INDENT return maxVal NEW_LINE DEDENT elif ( sum == target ) : NEW_LINE INDENT return len ( data ) NEW_LINE DEDENT elif ( data [ 0 ] >= target ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( data [ 0 ] < target ) : NEW_LINE INDENT temp = [ ] NEW_LINE for i in range ( 1 , len ( data ) ) : NEW_LINE INDENT temp . append ( data [ i ] ) NEW_LINE DEDENT return min ( smallSumSubset ( temp , target , maxVal ) , 1 + smallSumSubset ( temp , target - data [ 0 ] , maxVal ) ) NEW_LINE DEDENT return - 1 NEW_LINE DEDENT

BLEU: 50.34
Edit Sim: 352


Src: 
void printFourSquares ( int a ) { for ( int i = 0 ; i * i <= a ; i ++ ) { for ( int j = i ; j * j <= a ; j ++ ) { for ( int k = j ; k * k <= a ; k ++ ) { for ( int l = k ; l * l <= a ; l ++ ) { if ( i * i + j * j + k * k + l * l == a ) { System . out . print ( a + " ▁ = ▁ " + i + " * " + i + " ▁ + ▁ " + j + " * " + j + " ▁ + ▁ " ) ; System . out . println ( k + " * " + k + " ▁ + ▁ " + l + " * " + l ) ; } } } } } }
Ref: 
def printFourSquares ( a ) : NEW_LINE INDENT i = 0 NEW_LINE while ( i * i <= a ) : NEW_LINE INDENT j = i NEW_LINE while ( j * j <= a ) : NEW_LINE INDENT k = j NEW_LINE while ( k * k <= a ) : NEW_LINE INDENT l = k NEW_LINE while ( l * l <= a ) : NEW_LINE INDENT if ( i * i + j * j + k * k + l * l == a ) : NEW_LINE INDENT print ( " { } ▁ = ▁ { } * { } ▁ + ▁ { } * { } ▁ + " . format ( a , i , i , j , j ) , end = " ▁ " ) NEW_LINE print ( " { } * { } ▁ + ▁ { } * { } " . format ( k , k , l , l ) , end = " " ) NEW_LINE DEDENT l = l + 1 NEW_LINE DEDENT k = k + 1 NEW_LINE DEDENT j = j + 1 NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT DEDENT
Hyp: 
def printFourSquares ( a ) : NEW_LINE INDENT i = 0 ; NEW_LINE while ( i * i <= a ) : NEW_LINE INDENT j = i NEW_LINE while ( j * j <= a ) : NEW_LINE INDENT k = j NEW_LINE while ( k * k <= a ) : NEW_LINE INDENT l = k NEW_LINE while ( l * l <= a ) : NEW_LINE INDENT if ( i * i + j * j + k * l == a ) : NEW_LINE INDENT print ( a , " = " , i , " * " , i , " ▁ + ▁ " , j , " * " , j , " ▁ + ▁ " ) NEW_LINE print ( k , " * " , k , l , " * " , l ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT

BLEU: 52.19
Edit Sim: 185


Src: 
float Cel_To_Fah ( float n ) { return ( ( n * 9.0f / 5.0f ) + 32.0f ) ; }
Ref: 
def Cel_To_Fah ( n ) : NEW_LINE INDENT return ( n * 1.8 ) + 32 NEW_LINE DEDENT
Hyp: 
def Cel_To_Fah ( n ) : NEW_LINE INDENT return ( ( n * 9.0f / 5.0f ) + 32.0f ) ; NEW_LINE DEDENT

BLEU: 52.27
Edit Sim: 19


Src: 
int centered_cube ( int n ) { return ( 2 * n + 1 ) * ( n * n + n + 1 ) ; }
Ref: 
def centered_cube ( n ) : NEW_LINE INDENT return ( 2 * n + 1 ) * ( n * n + n + 1 ) NEW_LINE DEDENT
Hyp: 
def centered_cube ( n ) : NEW_LINE INDENT return ( 2 * n + 1 ) * ( n * n + n + 1 ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
boolean check ( String s , int m ) { int l = s . length ( ) ; int c1 = 0 ; int c2 = 0 ; for ( int i = 0 ; i < l ; i ++ ) { if ( s . charAt ( i ) == '0' ) { c2 = 0 ; c1 ++ ; } else { c1 = 0 ; c2 ++ ; } if ( c1 == m c2 == m ) return true ; } return false ; }
Ref: 
def check ( s , m ) : NEW_LINE INDENT l = len ( s ) ; NEW_LINE c1 = 0 ; NEW_LINE c2 = 0 ; NEW_LINE for i in range ( 0 , l - 1 ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT c2 = 0 ; NEW_LINE c1 = c1 + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT c1 = 0 ; NEW_LINE c2 = c2 + 1 ; NEW_LINE DEDENT if ( c1 == m or c2 == m ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT DEDENT return False ; NEW_LINE DEDENT s = "001001" ; NEW_LINE m = 2 ; NEW_LINE if ( check ( s , m ) ) : NEW_LINE INDENT print ( " YES " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) ; NEW_LINE DEDENT
Hyp: 
def check ( s , m ) : NEW_LINE INDENT l = len ( s ) NEW_LINE c1 = 0 NEW_LINE c2 = 0 NEW_LINE for i in range ( 0 , l ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT c2 = 0 NEW_LINE c1 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT c1 = 0 NEW_LINE c2 += 1 NEW_LINE DEDENT if ( c1 == m or c2 == m ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT

BLEU: 42.3
Edit Sim: 210


Src: 
int getMinOps ( int [ ] arr ) { int ans = 0 ; for ( int i = 0 ; i < arr . length - 1 ; i ++ ) { ans += Math . max ( arr [ i ] - arr [ i + 1 ] , 0 ) ; } return ans ; }
Ref: 
def getMinOps ( arr ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( len ( arr ) - 1 ) : NEW_LINE INDENT ans += max ( arr [ i ] - arr [ i + 1 ] , 0 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
Hyp: 
def getMinOps ( arr ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( len ( arr ) - 1 ) : NEW_LINE INDENT ans += max ( arr [ i ] - arr [ i + 1 ] , 0 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
void CalPeri ( ) { int S = 5 , Perimeter ; Perimeter = 10 * S ; System . out . println ( " The ▁ Perimeter ▁ of ▁ Decagon ▁ is ▁ : ▁ " + Perimeter ) ; }
Ref: 
def CalPeri ( ) : NEW_LINE INDENT s = 5 NEW_LINE Perimeter = 10 * s NEW_LINE print ( " The ▁ Perimeter ▁ of ▁ Decagon ▁ is ▁ : ▁ " , Perimeter ) NEW_LINE DEDENT
Hyp: 
def CalPeri ( S ) : NEW_LINE INDENT S = 5 NEW_LINE Perimeter = 10 * S NEW_LINE print ( " The ▁ Perimeter ▁ of ▁ Decagon ▁ is ▁ : " , Perimeter ) NEW_LINE DEDENT

BLEU: 74.54
Edit Sim: 6


Src: 
boolean canMadeEqual ( int [ ] A , int [ ] B , int n ) { Arrays . sort ( A ) ; Arrays . sort ( B ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( A [ i ] != B [ i ] ) { return false ; } } return true ; }
Ref: 
def canMadeEqual ( A , B , n ) : NEW_LINE INDENT A . sort ( ) NEW_LINE B . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( A [ i ] != B [ i ] ) : NEW_LINE return False NEW_LINE DEDENT return True NEW_LINE DEDENT
Hyp: 
def canMadeEqual ( A , B , n ) : NEW_LINE INDENT A = sorted ( A ) NEW_LINE B = sorted ( B ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( A [ i ] != B [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT A = [ 7 , 5 , 3 , 2 ] NEW_LINE B = [ 5 , 4 , 8 , 7 ] NEW_LINE n = len ( A ) NEW_LINE if ( canMadeEqual ( A , B , n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT

BLEU: 35.63
Edit Sim: 251


Src: 
int binomialCoeff ( int n , int k ) { int [ ] [ ] C = new int [ n + 1 ] [ k + 1 ] ; int i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= Math . min ( i , k ) ; j ++ ) { if ( j == 0 j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } return C [ n ] [ k ] ; }
Ref: 
def binomialCoeff ( n , k ) : NEW_LINE INDENT C = [ [ 0 for j in range ( k + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( min ( i , k ) + 1 ) : NEW_LINE INDENT if j == 0 or j == i : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return C [ n ] [ k ] NEW_LINE DEDENT
Hyp: 
def binomialCoeff ( n , k ) : NEW_LINE INDENT C = [ [ 0 for i in range ( k + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT for j in range ( 0 , min ( i , k ) + 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return C [ n ] [ k ] NEW_LINE DEDENT

BLEU: 88.3
Edit Sim: 43


Src: 
long calculate ( long p , long q ) { long mod = 998244353 , expo ; expo = mod - 2 ; while ( expo != 0 ) { if ( ( expo & 1 ) == 1 ) { p = ( p * q ) % mod ; } q = ( q * q ) % mod ; expo >>= 1 ; } return p ; }
Ref: 
def calculate ( p , q ) : NEW_LINE INDENT mod = 998244353 NEW_LINE expo = 0 NEW_LINE expo = mod - 2 NEW_LINE while ( expo ) : NEW_LINE INDENT if ( expo & 1 ) : NEW_LINE INDENT p = ( p * q ) % mod NEW_LINE DEDENT q = ( q * q ) % mod NEW_LINE expo >>= 1 NEW_LINE DEDENT return p NEW_LINE DEDENT
Hyp: 
def calculate ( p , q ) : NEW_LINE INDENT mod = 998244353 NEW_LINE expo = mod - 2 NEW_LINE while ( expo != 0 ) : NEW_LINE INDENT if ( expo & 1 ) : NEW_LINE INDENT p = ( p * q ) % mod NEW_LINE DEDENT q = ( q * q ) % mod NEW_LINE expo >>= 1 NEW_LINE DEDENT return p NEW_LINE DEDENT

BLEU: 92.36
Edit Sim: 23


Src: 
int findNumberOfStrings ( int n ) { int DP [ ] [ ] = new int [ n + 1 ] [ 6 ] ; DP [ 1 ] [ 1 ] = 1 ; for ( int i = 1 ; i < n + 1 ; i ++ ) { for ( int j = 1 ; j < 6 ; j ++ ) { if ( i == 1 ) { DP [ i ] [ j ] = DP [ i ] [ j - 1 ] + 1 ; } else { DP [ i ] [ j ] = DP [ i ] [ j - 1 ] + DP [ i - 1 ] [ j ] ; } } } return DP [ n ] [ 5 ] ; }
Ref: 
def findNumberOfStrings ( n ) : NEW_LINE INDENT DP = [ [ 0 for i in range ( 6 ) ] for i in range ( n + 1 ) ] NEW_LINE DP [ 1 ] [ 1 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , 6 ) : NEW_LINE INDENT if ( i == 1 ) : NEW_LINE INDENT DP [ i ] [ j ] = DP [ i ] [ j - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT DP [ i ] [ j ] = DP [ i ] [ j - 1 ] + DP [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return DP [ n ] [ 5 ] NEW_LINE DEDENT
Hyp: 
def findNumberOfStrings ( n ) : NEW_LINE INDENT DP = [ [ 0 for i in range ( 6 ) ] for i in range ( n + 1 ) ] NEW_LINE DP [ 1 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , 6 ) : NEW_LINE INDENT if ( i == 1 ) : NEW_LINE INDENT DP [ i ] [ j ] = DP [ i ] [ j - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT DP [ i ] [ j ] = ( DP [ i ] [ j - 1 ] + DP [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return DP [ n ] [ 5 ] NEW_LINE DEDENT

BLEU: 94.76
Edit Sim: 5


Src: 
int numberOfGP ( int L [ ] , int N ) { if ( N <= 2 ) return 0 ; int count = 0 ; int res = 0 ; for ( int i = 2 ; i < N ; ++ i ) { if ( L [ i - 1 ] * L [ i - 1 ] == L [ i ] * L [ i - 2 ] ) { ++ count ; } else { count = 0 ; } res += count ; } return res ; }
Ref: 
def numberOfGP ( L , N ) : NEW_LINE INDENT if ( N <= 2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT count = 0 NEW_LINE res = 0 NEW_LINE for i in range ( 2 , N ) : NEW_LINE INDENT if ( L [ i - 1 ] * L [ i - 1 ] == L [ i ] * L [ i - 2 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count = 0 NEW_LINE DEDENT res += count NEW_LINE DEDENT return res NEW_LINE DEDENT
Hyp: 
def numberOfGP ( L , N ) : NEW_LINE INDENT if ( N <= 2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT count = 0 NEW_LINE res = 0 NEW_LINE for i in range ( 2 , N ) : NEW_LINE INDENT if ( L [ i - 1 ] * L [ i - 1 ] == L [ i ] * L [ i - 2 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count = 0 NEW_LINE DEDENT res += count NEW_LINE DEDENT return res NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int toggleBits ( int n1 , int n2 ) { return ( n1 ^ n2 ) ; }
Ref: 
def toggleBits ( n1 , n2 ) : NEW_LINE INDENT return ( n1 ^ n2 ) NEW_LINE DEDENT
Hyp: 
def toggleBits ( n1 , n2 ) : NEW_LINE INDENT return ( n1 ^ n2 ) ; NEW_LINE DEDENT

BLEU: 87.39
Edit Sim: 2


Src: 
int setBitNumber ( int n ) { int k = ( int ) ( Math . log ( n ) / Math . log ( 2 ) ) ; return 1 << k ; }
Ref: 
def setBitNumber ( n ) : NEW_LINE INDENT k = int ( math . log ( n , 2 ) ) NEW_LINE return 1 << k NEW_LINE DEDENT
Hyp: 
def setBitNumber ( n ) : NEW_LINE INDENT k = int ( log2 ( n ) ) NEW_LINE return 1 << k NEW_LINE DEDENT

BLEU: 70.39
Edit Sim: 12


Src: 
boolean isTwoAlter ( String s ) { for ( int i = 0 ; i < s . length ( ) - 2 ; i ++ ) { if ( s . charAt ( i ) != s . charAt ( i + 2 ) ) { return false ; } } if ( s . charAt ( 0 ) == s . charAt ( 1 ) ) return false ; return true ; }
Ref: 
def isTwoAlter ( s ) : NEW_LINE INDENT for i in range ( len ( s ) - 2 ) : NEW_LINE INDENT if ( s [ i ] != s [ i + 2 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if ( s [ 0 ] == s [ 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT
Hyp: 
def isTwoAlter ( s ) : NEW_LINE INDENT for i in range ( len ( s ) - 2 ) : NEW_LINE INDENT if ( s [ i ] != s [ i + 2 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if ( s [ 0 ] == s [ 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
char Colour_Combination ( String s ) { char temp = s . charAt ( 0 ) ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) { if ( temp != s . charAt ( i ) ) { if ( ( temp == ' B ' temp == ' G ' ) && ( s . charAt ( i ) == ' G ' || s . charAt ( i ) == ' B ' ) ) temp = ' Y ' ; else if ( ( temp == ' B ' temp == ' Y ' ) && ( s . charAt ( i ) == ' Y ' || s . charAt ( i ) == ' B ' ) ) temp = ' G ' ; else temp = ' B ' ; } } return temp ; }
Ref: 
def Colour_Combination ( s ) : NEW_LINE INDENT temp = s [ 0 ] NEW_LINE for i in range ( 1 , len ( s ) , 1 ) : NEW_LINE INDENT if ( temp != s [ i ] ) : NEW_LINE INDENT if ( ( temp == ' B ' or temp == ' G ' ) and ( s [ i ] == ' G ' or s [ i ] == ' B ' ) ) : NEW_LINE INDENT temp = ' Y ' NEW_LINE DEDENT elif ( ( temp == ' B ' or temp == ' Y ' ) and ( s [ i ] == ' Y ' or s [ i ] == ' B ' ) ) : NEW_LINE INDENT temp = ' G ' NEW_LINE DEDENT else : NEW_LINE INDENT temp = ' B ' NEW_LINE DEDENT DEDENT DEDENT return temp NEW_LINE DEDENT
Hyp: 
def Colour_Combination ( s ) : NEW_LINE INDENT temp = s [ 0 ] NEW_LINE for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT if ( temp != s [ i ] ) : NEW_LINE INDENT if ( temp == ' B ' or temp == ' G ' or s [ i ] == ' B ' ) : NEW_LINE INDENT temp = ' Y ' NEW_LINE DEDENT elif ( ( temp == ' B ' temp == ' Y ' ) and ( s [ i ] == ' Y ' or s [ i ] == ' B ' ) ) : NEW_LINE INDENT temp = ' G ' NEW_LINE DEDENT else : NEW_LINE INDENT temp = ' B ' NEW_LINE DEDENT DEDENT DEDENT return temp NEW_LINE DEDENT

BLEU: 86.48
Edit Sim: 36


Src: 
int countWays ( int n ) { int a = 1 , b = 2 , c = 4 ; int d = 0 ; if ( n == 0 n == 1 n == 2 ) return n ; if ( n == 3 ) return c ; for ( int i = 4 ; i <= n ; i ++ ) { d = c + b + a ; a = b ; b = c ; c = d ; } return d ; }
Ref: 
def countWays ( n ) : NEW_LINE INDENT a = 1 NEW_LINE b = 2 NEW_LINE c = 4 NEW_LINE if ( n == 0 or n == 1 or n == 2 ) : NEW_LINE INDENT return n NEW_LINE DEDENT if ( n == 3 ) : NEW_LINE INDENT return c NEW_LINE DEDENT for i in range ( 4 , n + 1 ) : NEW_LINE INDENT d = c + b + a NEW_LINE a = b NEW_LINE b = c NEW_LINE c = d NEW_LINE DEDENT return d NEW_LINE DEDENT
Hyp: 
def countWays ( n ) : NEW_LINE INDENT a = 1 NEW_LINE b = 2 NEW_LINE c = 4 NEW_LINE d = 0 NEW_LINE if ( n == 0 or n == 1 or n == 2 ) : NEW_LINE INDENT return n NEW_LINE DEDENT if ( n == 3 ) : NEW_LINE INDENT return c NEW_LINE DEDENT for i in range ( 4 , n + 1 ) : NEW_LINE INDENT d = c + b + a NEW_LINE a = b NEW_LINE b = c NEW_LINE c = d NEW_LINE DEDENT return d NEW_LINE DEDENT

BLEU: 95.06
Edit Sim: 15


Src: 
int MinimumOperations ( int [ ] A , int N , int K ) { int Count = 0 ; int i = 0 ; while ( i < N - 1 ) { i = i + K - 1 ; Count ++ ; } return Count ; }
Ref: 
def MinimumOperations ( A , N , K ) : NEW_LINE INDENT Count = 0 NEW_LINE i = 0 NEW_LINE while ( i < N - 1 ) : NEW_LINE INDENT i = i + K - 1 NEW_LINE Count += 1 NEW_LINE DEDENT return Count NEW_LINE DEDENT
Hyp: 
def MinimumOperations ( A , N , K ) : NEW_LINE INDENT Count = 0 NEW_LINE i = 0 NEW_LINE while i < N - 1 : NEW_LINE INDENT i = i + K - 1 NEW_LINE Count += 1 NEW_LINE DEDENT return Count NEW_LINE DEDENT

BLEU: 89.18
Edit Sim: 4


Src: 
boolean isIdentity ( int mat [ ] [ ] , int N ) { for ( int row = 0 ; row < N ; row ++ ) { for ( int col = 0 ; col < N ; col ++ ) { if ( row == col && mat [ row ] [ col ] != 1 ) return false ; else if ( row != col && mat [ row ] [ col ] != 0 ) return false ; } } return true ; }
Ref: 
def isIdentity ( mat , N ) : NEW_LINE INDENT for row in range ( N ) : NEW_LINE INDENT for col in range ( N ) : NEW_LINE INDENT if ( row == col and mat [ row ] [ col ] != 1 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT elif ( row != col and mat [ row ] [ col ] != 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT DEDENT return True ; NEW_LINE DEDENT N = 4 ; NEW_LINE mat = [ [ 1 , 0 , 0 , 0 ] , [ 0 , 1 , 0 , 0 ] , [ 0 , 0 , 1 , 0 ] , [ 0 , 0 , 0 , 1 ] ] ; NEW_LINE if ( isIdentity ( mat , N ) ) : NEW_LINE INDENT print ( " Yes ▁ " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No ▁ " ) ; NEW_LINE DEDENT
Hyp: 
def isIdentity ( mat , N ) : NEW_LINE INDENT for row in range ( N ) : NEW_LINE INDENT for col in range ( N ) : NEW_LINE INDENT if ( row == col and mat [ row ] [ col ] != 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT elif ( row != col and mat [ row ] [ col ] != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT mat = [ [ 1 , 3 , 5 ] , [ 3 , 2 , 4 ] ] NEW_LINE if ( isIdentity ( mat , 3 ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT

BLEU: 61.28
Edit Sim: 87


Src: 
void performQueries ( int n , int q , int k , int [ ] arr , int [ ] [ ] query ) { for ( int i = 1 ; i <= q ; i ++ ) { int count = 0 ; if ( query [ i - 1 ] [ 0 ] == 1 ) { for ( int j = query [ i - 1 ] [ 1 ] ; j <= query [ i - 1 ] [ 2 ] ; j ++ ) { if ( arr [ j ] == k ) count ++ ; } System . out . print ( count + "NEW_LINE"); } else { arr [ query [ i - 1 ] [ 1 ] ] = query [ i - 1 ] [ 2 ] ; } } }
Ref: 
def performQueries ( n , q , k , arr , query ) : NEW_LINE INDENT for i in range ( 1 , q + 1 , 1 ) : NEW_LINE count = 0 NEW_LINE if ( query [ i - 1 ] [ 0 ] == 1 ) : NEW_LINE DEDENT for j in range ( query [ i - 1 ] [ 1 ] , query [ i - 1 ] [ 2 ] + 1 , 1 ) : NEW_LINE INDENT if ( arr [ j ] == k ) : NEW_LINE DEDENT count += 1 NEW_LINE INDENT print ( count ) NEW_LINE else : NEW_LINE DEDENT arr [ query [ i - 1 ] [ 1 ] ] = query [ i - 1 ] [ 2 ] NEW_LINE if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 9 , 5 , 7 , 6 , 9 , 0 , 0 , 0 , 0 , 5 , 6 , 7 , 3 , 9 , 0 , 7 , 0 , 9 , 0 ] NEW_LINE Q = 5 NEW_LINE INDENT query = [ [ 1 , 5 , 14 ] , [ 2 , 6 , 1 ] , [ 1 , 0 , 8 ] , [ 2 , 13 , 0 ] , [ 1 , 6 , 18 ] ] NEW_LINE DEDENT N = len ( arr ) NEW_LINE DEDENT K = 0 NEW_LINE INDENT performQueries ( N , Q , K , arr , query ) NEW_LINE DEDENT
Hyp: 
def performQueries ( n , q , k , arr , query ) : NEW_LINE INDENT for i in range ( 1 , q + 1 ) : NEW_LINE INDENT count = 0 NEW_LINE if ( query [ i - 1 ] [ 0 ] == 1 ) : NEW_LINE INDENT for j in range ( query [ i - 1 ] [ 1 ] , query [ i - 1 ] [ 2 ] + 1 ) : NEW_LINE INDENT if ( arr [ j ] == k ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT print ( count ) NEW_LINE DEDENT

BLEU: 19.88
Edit Sim: 476


Src: 
int minSwaps ( int N , int M , int A [ ] [ ] , int B [ ] [ ] ) { int count01 = 0 ; int count10 = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { if ( A [ i ] [ j ] != B [ i ] [ j ] ) { if ( A [ i ] [ j ] == 1 ) count10 ++ ; else count01 ++ ; } } } if ( count01 == count10 ) return count01 ; else return - 1 ; }
Ref: 
def minSwaps ( N , M , A , B ) : NEW_LINE INDENT count01 = 0 NEW_LINE count10 = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( 0 , M ) : NEW_LINE INDENT if ( A [ i ] [ j ] != B [ i ] [ j ] ) : NEW_LINE INDENT if ( A [ i ] [ j ] == 1 ) : NEW_LINE INDENT count10 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count01 += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT if ( count01 == count10 ) : NEW_LINE INDENT return count01 NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT
Hyp: 
def minSwaps ( N , M , A , B ) : NEW_LINE INDENT count01 = 0 NEW_LINE count10 = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT if ( A [ i ] [ j ] != B [ i ] [ j ] ) : NEW_LINE INDENT if ( A [ i ] [ j ] == 1 ) : NEW_LINE INDENT count10 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count01 += 1 NEW_LINE DEDENT DEDENT DEDENT if ( count01 == count10 ) : NEW_LINE INDENT return count01 NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT

BLEU: 93.31
Edit Sim: 15


Src: 
int cntSquares ( int n ) { return n * ( n + 1 ) * ( 2 * n + 1 ) / 6 ; }
Ref: 
def cntSquares ( n ) : NEW_LINE INDENT return int ( n * ( n + 1 ) * ( 2 * n + 1 ) / 6 ) NEW_LINE DEDENT
Hyp: 
def cntSquares ( n ) : NEW_LINE INDENT return n * ( n + 1 ) * ( 2 * n + 1 ) // 6 NEW_LINE DEDENT

BLEU: 74.4
Edit Sim: 9


Src: 
int solution ( int A , int B , int C ) { int arr [ ] = new int [ 3 ] ; arr [ 0 ] = A ; arr [ 1 ] = B ; arr [ 2 ] = C ; Arrays . sort ( arr ) ; if ( arr [ 2 ] < arr [ 0 ] + arr [ 1 ] ) return ( ( arr [ 0 ] + arr [ 1 ] + arr [ 2 ] ) / 2 ) ; else return ( arr [ 0 ] + arr [ 1 ] ) ; }
Ref: 
def solution ( A , B , C ) : NEW_LINE INDENT arr = [ 0 ] * 3 NEW_LINE arr [ 0 ] = A NEW_LINE arr [ 1 ] = B NEW_LINE arr [ 2 ] = C NEW_LINE arr = sorted ( arr ) NEW_LINE if ( arr [ 2 ] < arr [ 0 ] + arr [ 1 ] ) : NEW_LINE INDENT return ( ( arr [ 0 ] + arr [ 1 ] + arr [ 2 ] ) // 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( arr [ 0 ] + arr [ 1 ] ) NEW_LINE DEDENT DEDENT
Hyp: 
def solution ( A , B , C ) : NEW_LINE INDENT arr = [ 0 for x in range ( 3 ) ] NEW_LINE arr [ 0 ] = A NEW_LINE arr [ 1 ] = B NEW_LINE arr [ 2 ] = C NEW_LINE arr . sort ( ) NEW_LINE if arr [ 2 ] < arr [ 0 ] + arr [ 1 ] : NEW_LINE INDENT return ( ( arr [ 0 ] + arr [ 1 ] + arr [ 2 ] ) // 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( arr [ 0 ] + arr [ 1 ] ) NEW_LINE DEDENT DEDENT

BLEU: 85.63
Edit Sim: 30


Src: 
void transpose ( int A [ ] [ ] , int B [ ] [ ] ) { int i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < M ; j ++ ) B [ i ] [ j ] = A [ j ] [ i ] ; }
Ref: 
def transpose ( A , B ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT B [ i ] [ j ] = A [ j ] [ i ] NEW_LINE DEDENT DEDENT DEDENT A = [ [ 1 , 1 , 1 , 1 ] , [ 2 , 2 , 2 , 2 ] , [ 3 , 3 , 3 , 3 ] ] NEW_LINE B = [ [ 0 for x in range ( M ) ] for y in range ( N ) ] NEW_LINE transpose ( A , B ) NEW_LINE print ( " Result ▁ matrix ▁ is " ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT print ( B [ i ] [ j ] , " ▁ " , end = ' ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT
Hyp: 
def transpose ( A , B ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT B [ i ] [ j ] = A [ j ] [ i ] NEW_LINE DEDENT DEDENT DEDENT

BLEU: 8.64
Edit Sim: 377


Src: 
void printFibonacciNumbers ( int n ) { int f1 = 0 , f2 = 1 , i ; if ( n < 1 ) return ; System . out . print ( f1 + " ▁ " ) ; for ( i = 1 ; i < n ; i ++ ) { System . out . print ( f2 + " ▁ " ) ; int next = f1 + f2 ; f1 = f2 ; f2 = next ; } }
Ref: 
def printFibonacciNumbers ( n ) : NEW_LINE INDENT f1 = 0 NEW_LINE f2 = 1 NEW_LINE if ( n < 1 ) : NEW_LINE INDENT return NEW_LINE DEDENT print ( f1 , end = " ▁ " ) NEW_LINE for x in range ( 1 , n ) : NEW_LINE INDENT print ( f2 , end = " ▁ " ) NEW_LINE next = f1 + f2 NEW_LINE f1 = f2 NEW_LINE f2 = next NEW_LINE DEDENT DEDENT
Hyp: 
def printFibonacciNumbers ( n ) : NEW_LINE INDENT f1 = 0 NEW_LINE f2 = 1 NEW_LINE if ( n < 1 ) : NEW_LINE INDENT return NEW_LINE DEDENT print ( f1 , end = " ▁ " ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT print ( f2 , end = " ▁ " ) NEW_LINE next = f1 + f2 NEW_LINE f1 = f2 NEW_LINE f2 = next NEW_LINE DEDENT DEDENT

BLEU: 96.74
Edit Sim: 1


Src: 
void findPosition ( int n ) { int i = 0 ; int pos = 0 ; while ( n > 0 ) { if ( n % 10 == 7 ) { pos = pos + ( int ) Math . pow ( 2 , i + 1 ) ; } else { pos = pos + ( int ) Math . pow ( 2 , i ) ; } i ++ ; n = n / 10 ; } System . out . print ( pos ) ; }
Ref: 
def findPosition ( n ) : NEW_LINE INDENT i = 0 NEW_LINE pos = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT if ( n % 10 == 7 ) : NEW_LINE INDENT pos = pos + pow ( 2 , i + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT pos = pos + pow ( 2 , i ) NEW_LINE DEDENT i += 1 NEW_LINE n = n // 10 NEW_LINE DEDENT print ( pos ) NEW_LINE DEDENT
Hyp: 
def findPosition ( n ) : NEW_LINE INDENT i = 0 NEW_LINE pos = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT if ( n % 10 == 7 ) : NEW_LINE INDENT pos = pos + pow ( 2 , i + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT pos = pos + pow ( 2 , i ) NEW_LINE DEDENT i += 1 NEW_LINE n = n // 10 NEW_LINE DEDENT print ( pos ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int Pentadecagonal_num ( int n ) { return ( 13 * n * n - 11 * n ) / 2 ; }
Ref: 
def Pentadecagonal_num ( n ) : NEW_LINE INDENT return ( 13 * n * n - 11 * n ) / 2 NEW_LINE DEDENT
Hyp: 
def Pentadecagonal_num ( n ) : NEW_LINE INDENT return ( 13 * n * n - 11 * n ) // 2 NEW_LINE DEDENT

BLEU: 88.95
Edit Sim: 1


Src: 
void maxNumTrailNine ( int n , int d ) { int res = n ; int cntDigits = ( int ) Math . log10 ( n ) + 1 ; int p10 = 10 ; for ( int i = 1 ; i <= cntDigits ; i ++ ) { if ( n % p10 >= d ) { break ; } else { res = n - n % p10 - 1 ; } p10 = p10 * 10 ; } System . out . println ( res ) ; }
Ref: 
def maxNumTrailNine ( n , d ) : NEW_LINE INDENT res = n NEW_LINE cntDigits = int ( log10 ( n ) + 1 ) NEW_LINE p10 = 10 NEW_LINE for i in range ( 1 , cntDigits + 1 ) : NEW_LINE INDENT if ( n % p10 >= d ) : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT res = n - n % p10 - 1 NEW_LINE DEDENT p10 = p10 * 10 NEW_LINE DEDENT print ( res ) NEW_LINE DEDENT
Hyp: 
def maxNumTrailNine ( n , d ) : NEW_LINE INDENT res = n NEW_LINE cntDigits = int ( math . log10 ( n ) + 1 ) NEW_LINE p10 = 10 NEW_LINE for i in range ( 1 , cntDigits + 1 ) : NEW_LINE INDENT if ( n % p10 >= d ) : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT res = n - n % p10 - 1 NEW_LINE DEDENT p10 = p10 * 10 NEW_LINE DEDENT print ( res ) NEW_LINE DEDENT

BLEU: 95.97
Edit Sim: 7


Src: 
int findS ( int s ) { int sum = 0 ; for ( int n = 1 ; sum < s ; n ++ ) { sum += n * n * n ; if ( sum == s ) return n ; } return - 1 ; }
Ref: 
def findS ( s ) : NEW_LINE INDENT _sum = 0 NEW_LINE n = 1 NEW_LINE while ( _sum < s ) : NEW_LINE INDENT _sum += n * n * n NEW_LINE n += 1 NEW_LINE DEDENT n -= 1 NEW_LINE if _sum == s : NEW_LINE INDENT return n NEW_LINE DEDENT return - 1 NEW_LINE DEDENT s = 9 NEW_LINE n = findS ( s ) NEW_LINE if n == - 1 : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT
Hyp: 
def findS ( s ) : NEW_LINE INDENT sum = 0 NEW_LINE for n in range ( 1 , s ) : NEW_LINE INDENT sum += n * n * n NEW_LINE if ( sum == s ) : NEW_LINE INDENT return n NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT

BLEU: 24.4
Edit Sim: 217


Src: 
void otherEndPoint ( int x1 , int y1 , int m1 , int m2 ) { float x2 = ( float ) ( 2 * m1 - x1 ) ; float y2 = ( float ) ( 2 * m2 - y1 ) ; System . out . println ( " x2 ▁ = ▁ " + x2 + " , ▁ " + " y2 ▁ = ▁ " + y2 ) ; }
Ref: 
def otherEndPoint ( x1 , y1 , m1 , m2 ) : NEW_LINE INDENT x2 = ( 2 * m1 - x1 ) NEW_LINE y2 = ( 2 * m2 - y1 ) NEW_LINE print ( " x2 ▁ = ▁ { } , ▁ y2 ▁ = ▁ { } " . format ( x2 , y2 ) ) NEW_LINE DEDENT
Hyp: 
def otherEndPoint ( x1 , y1 , m1 , m2 ) : NEW_LINE INDENT x2 = ( 2 * m1 - x1 ) NEW_LINE y2 = ( 2 * m2 - y1 ) NEW_LINE print ( " x2 ▁ = " , x2 , " , ▁ " , " y2 ▁ = " , y2 ) NEW_LINE DEDENT

BLEU: 72.94
Edit Sim: 26


Src: 
int maxSubarrayProduct ( int arr [ ] ) { int result = arr [ 0 ] ; int n = arr . length ; for ( int i = 0 ; i < n ; i ++ ) { int mul = arr [ i ] ; for ( int j = i + 1 ; j < n ; j ++ ) { result = Math . max ( result , mul ) ; mul *= arr [ j ] ; } result = Math . max ( result , mul ) ; } return result ; }
Ref: 
def maxSubarrayProduct ( arr , n ) : NEW_LINE INDENT result = arr [ 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT mul = arr [ i ] NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT result = max ( result , mul ) NEW_LINE mul *= arr [ j ] NEW_LINE DEDENT result = max ( result , mul ) NEW_LINE DEDENT return result NEW_LINE DEDENT
Hyp: 
def maxSubarrayProduct ( arr ) : NEW_LINE INDENT result = arr [ 0 ] NEW_LINE n = len ( arr ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mul = arr [ i ] NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT result = max ( result , mul ) NEW_LINE mul *= arr [ j ] NEW_LINE DEDENT result = max ( result , mul ) NEW_LINE DEDENT return result NEW_LINE DEDENT

BLEU: 89.14
Edit Sim: 29


Src: 
int no_of_digit ( int a , int b ) { return ( ( int ) ( b * Math . log10 ( a ) ) + 1 ) ; }
Ref: 
def no_of_digit ( a , b ) : NEW_LINE INDENT return ( ( int ) ( b * math . log10 ( a ) ) + 1 ) NEW_LINE DEDENT
Hyp: 
def no_of_digit ( a , b ) : NEW_LINE INDENT return ( int ) ( b * math . log10 ( a ) ) + 1 ) NEW_LINE DEDENT

BLEU: 93.91
Edit Sim: 2


Src: 
void myCopy ( char s1 [ ] , char s2 [ ] ) { int i = 0 ; for ( i = 0 ; i < s1 . length ; i ++ ) s2 [ i ] = s1 [ i ] ; }
Ref: 
def copy_str ( x , y ) : NEW_LINE INDENT if len ( y ) == 0 : NEW_LINE INDENT return x NEW_LINE DEDENT else : NEW_LINE INDENT c = copy_str ( x , ( y ) [ 1 : - 1 ] ) NEW_LINE return c NEW_LINE DEDENT DEDENT
Hyp: 
def myCopy ( s1 , s2 ) : NEW_LINE INDENT for i in s1 : NEW_LINE INDENT s2 [ i ] = s1 [ i ] NEW_LINE DEDENT DEDENT

BLEU: 10.34
Edit Sim: 115


Src: 
void constructXOR ( int A [ ] , int n ) { int XOR = 0 ; for ( int i = 0 ; i < n ; i ++ ) XOR ^= A [ i ] ; for ( int i = 0 ; i < n ; i ++ ) A [ i ] = XOR ^ A [ i ] ; }
Ref: 
def constructXOR ( A , n ) : NEW_LINE INDENT XOR = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT XOR ^= A [ i ] NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT A [ i ] = XOR ^ A [ i ] NEW_LINE DEDENT DEDENT A = [ 2 , 4 , 1 , 3 , 5 ] NEW_LINE n = len ( A ) NEW_LINE constructXOR ( A , n ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( A [ i ] , end = " ▁ " ) NEW_LINE DEDENT
Hyp: 
def constructXOR ( A , n ) : NEW_LINE INDENT XOR = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT XOR ^= A [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT A [ i ] = XOR ^ A [ i ] NEW_LINE DEDENT DEDENT

BLEU: 32.92
Edit Sim: 189


Src: 
int maxCountAB ( String s [ ] , int n ) { int A = 0 , B = 0 , BA = 0 , ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { String S = s [ i ] ; int L = S . length ( ) ; for ( int j = 0 ; j < L - 1 ; j ++ ) { if ( S . charAt ( j ) == ' A ' && S . charAt ( j + 1 ) == ' B ' ) { ans ++ ; } } if ( S . charAt ( 0 ) == ' B ' && S . charAt ( L - 1 ) == ' A ' ) BA ++ ; else if ( S . charAt ( 0 ) == ' B ' ) B ++ ; else if ( S . charAt ( L - 1 ) == ' A ' ) A ++ ; } if ( BA == 0 ) ans += Math . min ( B , A ) ; else if ( A + B == 0 ) ans += BA - 1 ; else ans += BA + Math . min ( B , A ) ; return ans ; }
Ref: 
def maxCountAB ( s , n ) : NEW_LINE INDENT A = 0 NEW_LINE B = 0 NEW_LINE BA = 0 NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT S = s [ i ] NEW_LINE L = len ( S ) NEW_LINE for j in range ( L - 1 ) : NEW_LINE INDENT if ( S [ j ] == ' A ' and S [ j + 1 ] == ' B ' ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT if ( S [ 0 ] == ' B ' and S [ L - 1 ] == ' A ' ) : NEW_LINE INDENT BA += 1 NEW_LINE DEDENT DEDENT elif ( S [ 0 ] == ' B ' ) : NEW_LINE INDENT B += 1 NEW_LINE DEDENT elif ( S [ L - 1 ] == ' A ' ) : NEW_LINE INDENT A += 1 NEW_LINE DEDENT if ( BA == 0 ) : NEW_LINE INDENT ans += min ( B , A ) NEW_LINE DEDENT elif ( A + B == 0 ) : NEW_LINE INDENT ans += BA - 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += BA + min ( B , A ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
Hyp: 
def maxCountAB ( s , n ) : NEW_LINE INDENT A = 0 NEW_LINE B = 0 NEW_LINE BA = 0 NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT S = s [ i ] NEW_LINE L = len ( S ) NEW_LINE for j in range ( L - 1 ) : NEW_LINE INDENT if ( S [ j ] == ' A ' and S [ j + 1 ] == ' B ' ) : NEW_LINE INDENT BA += 1 NEW_LINE DEDENT elif ( S [ 0 ] == ' B ' and S [ L - 1 ] == ' A ' ) : NEW_LINE INDENT A += 1 NEW_LINE DEDENT DEDENT if ( BA == 0 ) : NEW_LINE INDENT ans += min ( B , A ) NEW_LINE DEDENT elif ( A + B == 0 ) : NEW_LINE INDENT ans += BA - 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += BA + min ( B , A ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT

BLEU: 79.72
Edit Sim: 156


Src: 
boolean isCenteredheptagonal ( int N ) { double n = ( 7 + Math . sqrt ( 56 * N - 7 ) ) / 14 ; return ( n - ( int ) n ) == 0 ; }
Ref: 
def isCenteredheptagonal ( N ) : NEW_LINE INDENT n = ( 7 + math . sqrt ( 56 * N - 7 ) ) / 14 NEW_LINE return ( n - int ( n ) ) == 0 NEW_LINE DEDENT n = 8 NEW_LINE if ( isCenteredheptagonal ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
Hyp: 
def isCenteredheptagonal ( N ) : NEW_LINE INDENT n = ( 7 + math . sqrt ( 56 * N - 7 ) ) // 14 NEW_LINE return ( ( n - int ( n ) ) == 0 ) NEW_LINE DEDENT

BLEU: 40.19
Edit Sim: 158


Src: 
double area ( double a , double b , double c ) { double d = Math . abs ( ( c * c ) / ( 2 * a * b ) ) ; return d ; }
Ref: 
def area ( a , b , c ) : NEW_LINE INDENT d = abs ( ( c * c ) / ( 2 * a * b ) ) NEW_LINE return d NEW_LINE DEDENT
Hyp: 
def area ( a , b , c ) : NEW_LINE INDENT d = abs ( ( c * c ) / ( 2 * a * b ) ) NEW_LINE return d NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int gonNum257 ( int n ) { return ( 255 * n * n - 253 * n ) / 2 ; }
Ref: 
def gonNum257 ( n ) : NEW_LINE INDENT return ( 255 * n * n - 253 * n ) // 2 ; NEW_LINE DEDENT
Hyp: 
def gonNum257 ( n ) : NEW_LINE INDENT return ( 255 * n * n - 253 * n ) // 2 NEW_LINE DEDENT

BLEU: 90.59
Edit Sim: 2


Src: 
int number_of_digits ( int n ) { int i ; int res ; int sum = 0 ; for ( i = 4 , res = 1 ; ; i *= 4 , res ++ ) { sum += i ; if ( sum >= n ) break ; } return res ; }
Ref: 
def number_of_digits ( n ) : NEW_LINE INDENT i = 4 NEW_LINE res = 1 NEW_LINE sum = 0 NEW_LINE while ( True ) : NEW_LINE INDENT i *= 4 NEW_LINE res += 1 NEW_LINE sum += i NEW_LINE if ( sum >= n ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
Hyp: 
def number_of_digits ( n ) : NEW_LINE INDENT i = 4 NEW_LINE res = 1 NEW_LINE sum = 0 NEW_LINE for i in range ( 4 , 1 ) : NEW_LINE INDENT sum += i NEW_LINE if ( sum >= n ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT

BLEU: 76.04
Edit Sim: 46


Src: 
int next ( int [ ] arr , int target ) { int start = 0 , end = arr . length - 1 ; int ans = - 1 ; while ( start <= end ) { int mid = ( start + end ) / 2 ; if ( arr [ mid ] <= target ) { start = mid + 1 ; } else { ans = mid ; end = mid - 1 ; } } return ans ; }
Ref: 
def next ( arr , target ) : NEW_LINE INDENT start = 0 ; NEW_LINE end = len ( arr ) - 1 ; NEW_LINE ans = - 1 ; NEW_LINE while ( start <= end ) : NEW_LINE INDENT mid = ( start + end ) // 2 ; NEW_LINE if ( arr [ mid ] <= target ) : NEW_LINE INDENT start = mid + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT ans = mid ; NEW_LINE end = mid - 1 ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT
Hyp: 
def next ( arr , target ) : NEW_LINE INDENT start = 0 NEW_LINE end = len ( arr ) NEW_LINE ans = - 1 NEW_LINE while start <= end : NEW_LINE INDENT mid = ( start + end ) // 2 NEW_LINE if arr [ mid ] <= target : NEW_LINE INDENT start = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = mid NEW_LINE end = mid - 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT

BLEU: 64.17
Edit Sim: 28


Src: 
void minimumDiff ( int [ ] arr , int N ) { int res = arr [ 0 ] , sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) sum += arr [ i ] ; int min_diff = sum ; for ( int i = 0 ; i < N ; i ++ ) { if ( Math . abs ( sum - ( arr [ i ] * N ) ) < min_diff ) { min_diff = Math . abs ( sum - ( arr [ i ] * N ) ) ; res = arr [ i ] ; } } System . out . println ( res ) ; }
Ref: 
def minimumDiff ( arr , N ) : NEW_LINE INDENT res = arr [ 0 ] NEW_LINE sum1 = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum1 += arr [ i ] NEW_LINE DEDENT min_diff = sum1 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( abs ( sum1 - ( arr [ i ] * N ) ) < min_diff ) : NEW_LINE INDENT min_diff = abs ( sum1 - ( arr [ i ] * N ) ) NEW_LINE res = arr [ i ] NEW_LINE DEDENT DEDENT print ( res ) NEW_LINE DEDENT
Hyp: 
def minimumDiff ( arr , N ) : NEW_LINE INDENT res = arr [ 0 ] NEW_LINE sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT min_diff = sum NEW_LINE for i in range ( N ) : NEW_LINE INDENT if abs ( sum - ( arr [ i ] * N ) ) < min_diff : NEW_LINE INDENT min_diff = abs ( sum - ( arr [ i ] * N ) ) NEW_LINE res = arr [ i ] NEW_LINE DEDENT DEDENT print ( res ) NEW_LINE DEDENT

BLEU: 83.08
Edit Sim: 9


Src: 
boolean modularSum ( int arr [ ] , int n , int m ) { if ( n > m ) return true ; boolean DP [ ] = new boolean [ m ] ; Arrays . fill ( DP , false ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( DP [ 0 ] ) return true ; boolean temp [ ] = new boolean [ m ] ; Arrays . fill ( temp , false ) ; for ( int j = 0 ; j < m ; j ++ ) { if ( DP [ j ] == true ) { if ( DP [ ( j + arr [ i ] ) % m ] == false ) temp [ ( j + arr [ i ] ) % m ] = true ; } } for ( int j = 0 ; j < m ; j ++ ) if ( temp [ j ] ) DP [ j ] = true ; DP [ arr [ i ] % m ] = true ; } return DP [ 0 ] ; }
Ref: 
def modularSum ( arr , n , m ) : NEW_LINE INDENT if ( n > m ) : NEW_LINE INDENT return True NEW_LINE DEDENT DP = [ False for i in range ( m ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( DP [ 0 ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT temp = [ False for i in range ( m ) ] NEW_LINE for j in range ( m ) : NEW_LINE INDENT if ( DP [ j ] == True ) : NEW_LINE INDENT if ( DP [ ( j + arr [ i ] ) % m ] == False ) : NEW_LINE INDENT temp [ ( j + arr [ i ] ) % m ] = True NEW_LINE DEDENT DEDENT DEDENT for j in range ( m ) : NEW_LINE INDENT if ( temp [ j ] ) : NEW_LINE INDENT DP [ j ] = True NEW_LINE DEDENT DEDENT DP [ arr [ i ] % m ] = True NEW_LINE DEDENT return DP [ 0 ] NEW_LINE DEDENT
Hyp: 
def modularSum ( arr , n , m ) : NEW_LINE INDENT if ( n > m ) : NEW_LINE INDENT return True NEW_LINE DEDENT DP = [ 0 for i in range ( m ) ] NEW_LINE temp = [ 0 for i in range ( m ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( DP [ 0 ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT temp [ i ] % m ] = True NEW_LINE DEDENT DEDENT for j in range ( m ) : NEW_LINE INDENT if ( DP [ j ] == True ) : NEW_LINE INDENT if ( DP [ ( j + arr [ i ] ) % m ] == False ) : NEW_LINE INDENT temp [ ( j + arr [ i ] ) % m ] = True NEW_LINE DEDENT DEDENT DEDENT for j in range ( m ) : NEW_LINE INDENT if ( temp [ j ] ) : NEW_LINE INDENT DP [ j ] = True NEW_LINE DEDENT DP [ arr [ i ] % m ] = True NEW_LINE DEDENT DEDENT return DP [ 0 ] NEW_LINE DEDENT

BLEU: 89.43
Edit Sim: 90


Src: 
int minIndex ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( 2 * arr [ i ] == sum ) return ( i + 1 ) ; } return - 1 ; }
Ref: 
def minIndex ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( 2 * arr [ i ] == sum ) : NEW_LINE INDENT return ( i + 1 ) NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
Hyp: 
def minIndex ( arr , n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( 2 * arr [ i ] == sum ) : NEW_LINE INDENT return ( i + 1 ) ; NEW_LINE DEDENT DEDENT return - 1 ; NEW_LINE DEDENT

BLEU: 82.03
Edit Sim: 16


Src: 
int maxLen ( int arr [ ] ) { HashMap < Integer , Integer > hM = new HashMap < Integer , Integer > ( ) ; int sum = 0 ; int max_len = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { sum += arr [ i ] ; if ( arr [ i ] == 0 && max_len == 0 ) max_len = 1 ; if ( sum == 0 ) max_len = i + 1 ; Integer prev_i = hM . get ( sum ) ; if ( prev_i != null ) max_len = Math . max ( max_len , i - prev_i ) ; else hM . put ( sum , i ) ; } return max_len ; }
Ref: 
def maxLen ( arr ) : NEW_LINE INDENT hash_map = { } NEW_LINE curr_sum = 0 NEW_LINE max_len = 0 NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT curr_sum += arr [ i ] NEW_LINE if arr [ i ] is 0 and max_len is 0 : NEW_LINE INDENT max_len = 1 NEW_LINE DEDENT if curr_sum is 0 : NEW_LINE INDENT max_len = i + 1 NEW_LINE DEDENT if curr_sum in hash_map : NEW_LINE INDENT max_len = max ( max_len , i - hash_map [ curr_sum ] ) NEW_LINE DEDENT else : NEW_LINE INDENT hash_map [ curr_sum ] = i NEW_LINE DEDENT DEDENT return max_len NEW_LINE DEDENT
Hyp: 
def maxLen ( arr ) : NEW_LINE INDENT hM = dict ( ) NEW_LINE sum = 0 NEW_LINE max_len = 0 NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE if ( arr [ i ] == 0 and max_len == 0 ) : NEW_LINE INDENT max_len = 1 NEW_LINE DEDENT if ( sum == 0 ) : NEW_LINE INDENT max_len = i + 1 NEW_LINE DEDENT if ( sum == 0 ) : NEW_LINE INDENT max_len = i + 1 NEW_LINE DEDENT if ( sum == 0 ) : NEW_LINE INDENT max_len = i + 1 NEW_LINE DEDENT if ( prev_i != null ) : NEW_LINE INDENT max_len = max ( max_len , i - prev_i ) NEW_LINE DEDENT else : NEW_LINE INDENT hM [ sum ] = i NEW_LINE DEDENT DEDENT return max_len NEW_LINE DEDENT

BLEU: 51.3
Edit Sim: 201


Src: 
float getArea ( int a ) { float area = ( float ) ( Math . PI * a * a ) / 4 ; return area ; }
Ref: 
def getArea ( a ) : NEW_LINE INDENT area = ( math . pi * a * a ) / 4 NEW_LINE return area NEW_LINE DEDENT
Hyp: 
def getArea ( a ) : NEW_LINE INDENT area = ( math . PI * a * a ) / 4 NEW_LINE return area NEW_LINE DEDENT

BLEU: 89.85
Edit Sim: 2


Src: 
int multiplyWith4 ( int n ) { return ( n << 2 ) ; }
Ref: 
def multiplyWith4 ( n ) : NEW_LINE INDENT return ( n << 2 ) NEW_LINE DEDENT
Hyp: 
def multiplyWith4 ( n ) : NEW_LINE INDENT return ( n << 2 ) ; NEW_LINE DEDENT

BLEU: 85.79
Edit Sim: 2


Src: 
int subtractOne ( int x ) { int m = 1 ; while ( ! ( ( x & m ) > 0 ) ) { x = x ^ m ; m <<= 1 ; } x = x ^ m ; return x ; }
Ref: 
def subtractOne ( x ) : NEW_LINE INDENT m = 1 NEW_LINE while ( ( x & m ) == False ) : NEW_LINE INDENT x = x ^ m NEW_LINE m = m << 1 NEW_LINE DEDENT x = x ^ m NEW_LINE return x NEW_LINE DEDENT
Hyp: 
def subtractOne ( x ) : NEW_LINE INDENT m = 1 NEW_LINE while ( not ( x & m ) ) : NEW_LINE INDENT x = x ^ m NEW_LINE m <<= 1 NEW_LINE DEDENT x = x ^ m NEW_LINE return x NEW_LINE DEDENT

BLEU: 79.35
Edit Sim: 18


Src: 
int findSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += ( ( i * ( i + 1 ) * ( 2 * i + 1 ) ) / 6 ) ; return sum ; }
Ref: 
def findSum ( n ) : NEW_LINE INDENT summ = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT summ = ( summ + ( ( i * ( i + 1 ) * ( 2 * i + 1 ) ) / 6 ) ) NEW_LINE DEDENT return summ NEW_LINE DEDENT
Hyp: 
def findSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += ( ( i * ( i + 1 ) * ( 2 * i + 1 ) ) // 6 ) NEW_LINE DEDENT return int ( sum ) NEW_LINE DEDENT

BLEU: 74.01
Edit Sim: 23


Src: 
void printModulus ( int X , int Y ) { int d = Math . abs ( X - Y ) ; int i = 1 ; while ( i * i <= d ) { if ( d % i == 0 ) { System . out . print ( i + " ▁ " ) ; if ( d / i != i ) System . out . print ( d / i + " ▁ " ) ; } i ++ ; } }
Ref: 
def printModulus ( X , Y ) : NEW_LINE INDENT d = abs ( X - Y ) ; NEW_LINE i = 1 ; NEW_LINE while ( i * i <= d ) : NEW_LINE INDENT if ( d % i == 0 ) : NEW_LINE INDENT print ( i , end = " " ) ; NEW_LINE if ( d // i != i ) : NEW_LINE INDENT print ( d // i , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT i += 1 ; NEW_LINE DEDENT DEDENT
Hyp: 
def printModulus ( X , Y ) : NEW_LINE INDENT d = abs ( X - Y ) NEW_LINE i = 1 NEW_LINE while ( i * i <= d ) : NEW_LINE INDENT if ( d % i == 0 ) : NEW_LINE INDENT print i , NEW_LINE if ( d // i != i ) : NEW_LINE INDENT print ( d // i , NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT DEDENT

BLEU: 69.91
Edit Sim: 38


Src: 
boolean isUndulating ( String n ) { if ( n . length ( ) <= 2 ) return false ; for ( int i = 2 ; i < n . length ( ) ; i ++ ) if ( n . charAt ( i - 2 ) != n . charAt ( i ) ) return false ; return true ; }
Ref: 
def isUndulating ( n ) : NEW_LINE INDENT if ( len ( n ) <= 2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , len ( n ) ) : NEW_LINE INDENT if ( n [ i - 2 ] != n [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT n = "1212121" NEW_LINE if ( isUndulating ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
Hyp: 
def isUndulating ( n ) : NEW_LINE INDENT if ( len ( n ) <= 2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , len ( n ) ) : NEW_LINE INDENT if ( n [ i - 2 ] != n [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT n = " aba " NEW_LINE if ( isUndulating ( n ) ) : NEW_LINE INDENT print ( " aba " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " aba " ) NEW_LINE DEDENT

BLEU: 90.44
Edit Sim: 13


Src: 
int makeOdd ( int n ) { if ( n % 2 != 0 ) return 1 ; int i ; for ( i = 2 ; i <= n ; i ++ ) if ( ( n % i == 0 ) && ( ( n / i ) % 2 == 1 ) ) break ; return i ; }
Ref: 
def makeOdd ( n ) : NEW_LINE INDENT if n % 2 != 0 : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT if ( n % i == 0 and ( int ) ( n / i ) % 2 == 1 ) : NEW_LINE INDENT return i ; NEW_LINE DEDENT DEDENT DEDENT
Hyp: 
def makeOdd ( n ) : NEW_LINE INDENT if ( n % 2 != 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT i = 2 NEW_LINE while ( i <= n ) : NEW_LINE INDENT if ( ( n % i == 0 ) and ( ( n // i ) % 2 == 1 ) ) : NEW_LINE INDENT break NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT return i NEW_LINE DEDENT

BLEU: 49.76
Edit Sim: 79


Src: 
String findWinner ( int A [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) res ^= A [ i ] ; if ( res == 0 n % 2 == 0 ) return " Alice " ; else return " Bob " ; }
Ref: 
def findWinner ( A , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT res ^= A [ i ] NEW_LINE DEDENT if ( res == 0 or n % 2 == 0 ) : NEW_LINE INDENT return " Alice " NEW_LINE DEDENT else : NEW_LINE INDENT return " Bob " NEW_LINE DEDENT DEDENT
Hyp: 
def findWinner ( A , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT res ^= A [ i ] NEW_LINE DEDENT if ( res == 0 or n % 2 == 0 ) : NEW_LINE INDENT return " Alice " NEW_LINE DEDENT else : NEW_LINE INDENT return " Bob " NEW_LINE DEDENT DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int countTotalDistinct ( String str ) { int cnt = 0 ; HashSet < String > items = new HashSet < > ( ) ; for ( int i = 0 ; i < str . length ( ) ; ++ i ) { String temp = " " ; HashSet < Character > ans = new HashSet < > ( ) ; for ( int j = i ; j < str . length ( ) ; ++ j ) { temp = temp + str . charAt ( j ) ; ans . add ( str . charAt ( j ) ) ; if ( ! items . contains ( temp ) ) { items . add ( temp ) ; cnt += ans . size ( ) ; } } } return cnt ; }
Ref: 
def countTotalDistinct ( string ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE items = set ( ) ; NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT temp = " " ; NEW_LINE ans = set ( ) ; NEW_LINE for j in range ( i , len ( string ) ) : NEW_LINE INDENT temp = temp + string [ j ] ; NEW_LINE ans . add ( string [ j ] ) ; NEW_LINE if temp not in items : NEW_LINE INDENT items . add ( temp ) ; NEW_LINE cnt += len ( ans ) ; NEW_LINE DEDENT DEDENT DEDENT return cnt ; NEW_LINE DEDENT
Hyp: 
def countTotalDistinct ( str ) : NEW_LINE INDENT cnt = 0 NEW_LINE items = set ( ) NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT temp = " " NEW_LINE ans = set ( ) NEW_LINE for j in range ( i , len ( str ) ) : NEW_LINE INDENT temp = temp + str [ j ] NEW_LINE ans . add ( str [ j ] ) NEW_LINE if temp not in items : NEW_LINE INDENT items . add ( temp ) NEW_LINE cnt += 1 NEW_LINE DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT

BLEU: 63.86
Edit Sim: 44


Src: 
boolean canTakeDown ( int bishopX , int bishopY , int pawnX , int pawnY ) { if ( pawnX - bishopX == pawnY - bishopY ) return true ; else if ( - pawnX + bishopX == pawnY - bishopY ) return true ; else return false ; }
Ref: 
def canTakeDown ( bishopX , bishopY , pawnX , pawnY ) : NEW_LINE INDENT if ( pawnX - bishopX == pawnY - bishopY ) : NEW_LINE INDENT return True NEW_LINE DEDENT elif ( - pawnX + bishopX == pawnY - bishopY ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT bishopX = 5 NEW_LINE bishopY = 5 NEW_LINE pawnX = 1 NEW_LINE pawnY = 1 NEW_LINE if ( canTakeDown ( bishopX , bishopY , pawnX , pawnY ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
Hyp: 
def canTakeDown ( bishopX , bishopY , pawnX , pawnY ) : NEW_LINE INDENT if ( pawnX - bishopX == pawnY - bishopY ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT elif ( - pawnX + bishopX == pawnY - bishopY ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT else : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT

BLEU: 39.1
Edit Sim: 248


Src: 
int getMissingNo ( int a [ ] , int n ) { int n_elements_sum = n * ( n + 1 ) / 2 ; int sum = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) sum += a [ i ] ; return n_elements_sum - sum ; }
Ref: 
def getMissingNo ( a , n ) : NEW_LINE INDENT n_elements_sum = n * ( n + 1 ) // 2 NEW_LINE return n_elements_sum - sum ( a ) NEW_LINE DEDENT
Hyp: 
def getMissingNo ( a , n ) : NEW_LINE INDENT n_elements_sum = n * ( n + 1 ) / 2 NEW_LINE sum = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT sum += a [ i ] NEW_LINE DEDENT return n_elements_sum - sum NEW_LINE DEDENT

BLEU: 44.18
Edit Sim: 98


Src: 
void minXOR ( int Arr [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { if ( Arr [ i ] == 2 ) { System . out . print ( ( Arr [ i ] ^ 3 ) + " ▁ " ) ; } else { System . out . print ( ( Arr [ i ] ^ 2 ) + " ▁ " ) ; } } }
Ref: 
def minXOR ( Arr , N ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT if ( Arr [ i ] == 2 ) : NEW_LINE INDENT print ( Arr [ i ] ^ 3 , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( Arr [ i ] ^ 2 , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
Hyp: 
def minXOR ( Arr , N ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT if ( Arr [ i ] == 2 ) : NEW_LINE INDENT print ( ( Arr [ i ] ^ 3 ) , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ( Arr [ i ] ^ 2 ) , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT

BLEU: 88.51
Edit Sim: 8


Src: 
void minimumTriangleArea ( int a , int b ) { int area = a * b ; System . out . println ( area ) ; }
Ref: 
def minimumTriangleArea ( a , b ) : NEW_LINE INDENT area = a * b NEW_LINE print ( area ) NEW_LINE DEDENT
Hyp: 
def minimumTriangleArea ( a , b ) : NEW_LINE INDENT area = a * b NEW_LINE print ( area ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int countPairs ( String s ) { Set < Character > st = new HashSet < Character > ( ) ; st . add ( ' a ' ) ; st . add ( ' e ' ) ; st . add ( ' i ' ) ; st . add ( ' o ' ) ; st . add ( ' u ' ) ; int count = 0 ; int n = s . length ( ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( st . contains ( s . charAt ( i ) ) && ! st . contains ( s . charAt ( i + 1 ) ) ) count ++ ; } return count ; }
Ref: 
def countPairs ( s ) : NEW_LINE INDENT st = set ( ) ; NEW_LINE st . add ( ' a ' ) ; NEW_LINE st . add ( ' e ' ) ; NEW_LINE st . add ( ' i ' ) ; NEW_LINE st . add ( ' o ' ) ; NEW_LINE st . add ( ' u ' ) ; NEW_LINE count = 0 ; NEW_LINE n = len ( s ) ; NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( s [ i ] not in st and s [ i + 1 ] in st ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT
Hyp: 
def countPairs ( s ) : NEW_LINE INDENT st = set ( ) NEW_LINE st . add ( ' a ' ) NEW_LINE st . add ( ' e ' ) NEW_LINE st . add ( ' i ' ) NEW_LINE st . add ( ' o ' ) NEW_LINE st . add ( ' u ' ) NEW_LINE count = 0 NEW_LINE n = len ( s ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( s [ i ] in st and not s [ i + 1 ] in st ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT

BLEU: 75.77
Edit Sim: 28


Src: 
int lenOfLongestReqSubstr ( String s , int N ) { HashMap < Integer , Integer > ind = new HashMap < > ( ) ; int mask = 0 ; ind . put ( 0 , - 1 ) ; int ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int val = s . charAt ( i ) - '0' ; mask ^= ( 1 << val ) ; if ( ind . containsKey ( mask ) ) { ans = Math . max ( ans , i - ind . get ( mask ) ) ; } else ind . put ( mask , i ) ; } return ans ; }
Ref: 
def lenOfLongestReqSubstr ( s , N ) : NEW_LINE INDENT ind = { } NEW_LINE mask = 0 NEW_LINE ind [ 0 ] = - 1 NEW_LINE ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT val = ord ( s [ i ] ) - ord ( '0' ) NEW_LINE mask ^= ( 1 << val ) NEW_LINE if ( mask in ind ) : NEW_LINE INDENT ans = max ( ans , i - ind [ mask ] ) NEW_LINE DEDENT else : NEW_LINE INDENT ind [ mask ] = i NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
Hyp: 
def lenOfLongestReqSubstr ( s , N ) : NEW_LINE INDENT ind = dict ( ) NEW_LINE mask = 0 NEW_LINE ind [ 0 ] = - 1 NEW_LINE ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT val = ord ( s [ i ] ) - ord ( '0' ) NEW_LINE mask ^= ( 1 << val ) NEW_LINE if ( mask in ind ) : NEW_LINE INDENT ans = max ( ans , i - ind [ mask ] ) NEW_LINE DEDENT else : NEW_LINE INDENT ind [ mask ] = i NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT

BLEU: 95.72
Edit Sim: 7


Src: 
int sum ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } sum = sum * ( int ) Math . pow ( 2 , n - 1 ) ; return sum ; }
Ref: 
def sum ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in arr : NEW_LINE INDENT sum += i NEW_LINE DEDENT sum = sum * pow ( 2 , n - 1 ) NEW_LINE return sum NEW_LINE DEDENT
Hyp: 
def sum ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT sum = sum * pow ( 2 , n - 1 ) NEW_LINE return sum NEW_LINE DEDENT

BLEU: 77.93
Edit Sim: 18


Src: 
int minMoves ( int [ ] arr ) { int N = arr . length ; if ( N <= 2 ) return 0 ; int ans = Integer . MAX_VALUE ; for ( int i = - 1 ; i <= 1 ; i ++ ) { for ( int j = - 1 ; j <= 1 ; j ++ ) { int num1 = arr [ 0 ] + i ; int num2 = arr [ 1 ] + j ; int flag = 1 ; int moves = Math . abs ( i ) + Math . abs ( j ) ; for ( int idx = 2 ; idx < N ; idx ++ ) { int num = num1 + num2 ; if ( Math . abs ( arr [ idx ] - num ) > 1 ) flag = 0 ; else moves += Math . abs ( arr [ idx ] - num ) ; num1 = num2 ; num2 = num ; } if ( flag > 0 ) ans = Math . min ( ans , moves ) ; } } if ( ans == Integer . MAX_VALUE ) return - 1 ; return ans ; }
Ref: 
def minMoves ( arr ) : NEW_LINE INDENT N = len ( arr ) NEW_LINE if ( N <= 2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = sys . maxsize NEW_LINE for i in range ( - 1 , 2 ) : NEW_LINE INDENT for j in range ( - 1 , 2 ) : NEW_LINE INDENT num1 = arr [ 0 ] + i NEW_LINE num2 = arr [ 1 ] + j NEW_LINE flag = 1 NEW_LINE moves = abs ( i ) + abs ( j ) NEW_LINE for idx in range ( 2 , N ) : NEW_LINE INDENT num = num1 + num2 NEW_LINE if ( abs ( arr [ idx ] - num ) > 1 ) : NEW_LINE INDENT flag = 0 NEW_LINE DEDENT else : NEW_LINE INDENT moves += abs ( arr [ idx ] - num ) NEW_LINE DEDENT num1 = num2 NEW_LINE num2 = num NEW_LINE DEDENT if ( flag ) : NEW_LINE INDENT ans = min ( ans , moves ) NEW_LINE DEDENT DEDENT DEDENT if ( ans == sys . maxsize ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
Hyp: 
def minMoves ( arr ) : NEW_LINE INDENT N = len ( arr ) NEW_LINE if ( N <= 2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = sys . maxsize NEW_LINE for i in range ( - 1 , 1 ) : NEW_LINE INDENT for j in range ( - 1 , 1 ) : NEW_LINE INDENT num1 = arr [ 0 ] + i NEW_LINE num2 = arr [ 1 ] + j NEW_LINE flag = 1 NEW_LINE moves = abs ( i ) + abs ( j ) NEW_LINE for idx in range ( 2 , N ) : NEW_LINE INDENT num = num1 + num2 NEW_LINE if ( abs ( arr [ idx ] - num ) > 1 ) : NEW_LINE INDENT flag = 0 NEW_LINE DEDENT else : NEW_LINE INDENT moves += abs ( arr [ idx ] - num ) NEW_LINE DEDENT num1 = num2 NEW_LINE num2 = num NEW_LINE DEDENT if ( flag > 0 ) : NEW_LINE INDENT ans = min ( ans , moves ) NEW_LINE DEDENT DEDENT DEDENT if ( ans == sys . maxsize ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT

BLEU: 95.74
Edit Sim: 6


Src: 
String repeat ( String s , int n ) { String s1 = s ; for ( int i = 1 ; i < n ; i ++ ) s += s1 ; return s ; }
Ref: 
def repeat ( s , n ) : NEW_LINE INDENT s1 = s NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT s += s1 NEW_LINE DEDENT return s NEW_LINE DEDENT
Hyp: 
def repeat ( s , n ) : NEW_LINE INDENT s1 = s NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT s1 += s1 NEW_LINE DEDENT return s NEW_LINE DEDENT

BLEU: 92.58
Edit Sim: 1


Src: 
int getValueOfF ( int n ) { if ( n == 1 ) return 0 ; if ( n == 2 ) return 1 ; int cnt = 0 ; while ( n % 2 == 0 ) { cnt += 1 ; n /= 2 ; } return 2 * cnt ; }
Ref: 
def getValueOfF ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n == 2 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT cnt = 0 NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE n /= 2 NEW_LINE DEDENT return 2 * cnt NEW_LINE DEDENT
Hyp: 
def getValueOfF ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( n == 2 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT cnt = 0 ; NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE n //= 2 ; NEW_LINE DEDENT return 2 * cnt ; NEW_LINE DEDENT

BLEU: 75.87
Edit Sim: 13


Src: 
boolean isPrime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i < n ; i ++ ) if ( n % i == 0 ) return false ; return true ; }
Ref: 
def isPrime ( n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
Hyp: 
def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT DEDENT return 1 ; NEW_LINE DEDENT n = 65 NEW_LINE if ( isPrime ( n ) ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT

BLEU: 38.48
Edit Sim: 167


Src: 
int summation ( int n ) { return n << ( n - 1 ) ; }
Ref: 
def summation ( n ) : NEW_LINE INDENT return n << ( n - 1 ) ; NEW_LINE DEDENT
Hyp: 
def summation ( n ) : NEW_LINE INDENT return n << ( n - 1 ) NEW_LINE DEDENT

BLEU: 87.41
Edit Sim: 2


Src: 
void arrayEvenAndOdd ( int arr [ ] , int n ) { int i = - 1 , j = 0 ; while ( j != n ) { if ( arr [ j ] % 2 == 0 ) { i ++ ; int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; } j ++ ; } for ( int k = 0 ; k < n ; k ++ ) System . out . print ( arr [ k ] + " ▁ " ) ; }
Ref: 
def arrayEvenAndOdd ( arr , n ) : NEW_LINE INDENT i = - 1 NEW_LINE j = 0 NEW_LINE while ( j != n ) : NEW_LINE INDENT if ( arr [ j ] % 2 == 0 ) : NEW_LINE INDENT i = i + 1 NEW_LINE arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ] NEW_LINE DEDENT j = j + 1 NEW_LINE DEDENT for i in arr : NEW_LINE INDENT print ( str ( i ) + " ▁ " , end = ' ' ) NEW_LINE DEDENT DEDENT
Hyp: 
def arrayEvenAndOdd ( arr , n ) : NEW_LINE INDENT i = - 1 ; j = 0 ; NEW_LINE while ( j != n ) : NEW_LINE INDENT if ( arr [ j ] % 2 == 0 ) : NEW_LINE INDENT i += 1 NEW_LINE temp = arr [ i ] NEW_LINE arr [ i ] = arr [ j ] NEW_LINE arr [ j ] = temp NEW_LINE DEDENT j += 1 NEW_LINE DEDENT for k in range ( n ) : NEW_LINE INDENT print ( arr [ k ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT

BLEU: 64.41
Edit Sim: 80


Src: 
int findMinSum ( int arr [ ] , int n ) { int occ = n - 1 , sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] * ( int ) Math . pow ( 2 , occ ) ; occ -- ; } return sum ; }
Ref: 
def findMinSum ( arr , n ) : NEW_LINE INDENT occ = n - 1 NEW_LINE Sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT Sum += arr [ i ] * pow ( 2 , occ ) NEW_LINE occ -= 1 NEW_LINE DEDENT return Sum NEW_LINE DEDENT
Hyp: 
def findMinSum ( arr , n ) : NEW_LINE INDENT occ = n - 1 NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] * pow ( 2 , occ ) NEW_LINE occ -= 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT

BLEU: 85.85
Edit Sim: 3


Src: 
int countAnomalies ( int arr [ ] , int n , int k ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < n ; j ++ ) if ( i != j && Math . abs ( arr [ i ] - arr [ j ] ) <= k ) break ; if ( j == n ) res ++ ; } return res ; }
Ref: 
def countAnomalies ( arr , n , k ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT j = 0 NEW_LINE while j < n : NEW_LINE INDENT if i != j and abs ( arr [ i ] - arr [ j ] ) <= k : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if j == n : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
Hyp: 
def countAnomalies ( arr , n , k ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( i != j and abs ( arr [ i ] - arr [ j ] ) <= k ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( j == n ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT

BLEU: 71.38
Edit Sim: 47


Src: 
int evenSum ( int n ) { int C [ ] [ ] = new int [ n + 1 ] [ n + 1 ] ; int i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= Math . min ( i , n ) ; j ++ ) { if ( j == 0 j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } int sum = 0 ; for ( i = 0 ; i <= n ; i += 2 ) sum += C [ n ] [ i ] ; return sum ; }
Ref: 
def evenSum ( n ) : NEW_LINE INDENT C = [ [ 0 for x in range ( n + 1 ) ] for y in range ( n + 1 ) ] NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT for j in range ( 0 , min ( i , n + 1 ) ) : NEW_LINE INDENT if j == 0 or j == i : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT sum = 0 ; NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT if n % 2 == 0 : NEW_LINE INDENT sum = sum + C [ n ] [ i ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
Hyp: 
def evenSum ( n ) : NEW_LINE INDENT C = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT for j in range ( 0 , min ( i , n ) + 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT sum = 0 NEW_LINE for i in range ( 0 , n + 1 , 2 ) : NEW_LINE INDENT sum = sum + C [ n ] [ i ] NEW_LINE DEDENT return sum NEW_LINE DEDENT

BLEU: 83.47
Edit Sim: 52


Src: 
int recLen ( String str ) { if ( str . equals ( " " ) ) return 0 ; else return recLen ( str . substring ( 1 ) ) + 1 ; }
Ref: 
def string_length ( str ) : NEW_LINE INDENT if str == ' ' : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return 1 + string_length ( str [ 1 : ] ) NEW_LINE DEDENT DEDENT
Hyp: 
def recLen ( str ) : NEW_LINE INDENT if ( str == " " ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT else : NEW_LINE INDENT return recLen ( str [ 1 : ] ) + 1 ; NEW_LINE DEDENT DEDENT

BLEU: 55.1
Edit Sim: 38


Src: 
void sort ( char arr [ ] ) { int n = arr . length ; char output [ ] = new char [ n ] ; int count [ ] = new int [ 256 ] ; for ( int i = 0 ; i < 256 ; ++ i ) count [ i ] = 0 ; for ( int i = 0 ; i < n ; ++ i ) ++ count [ arr [ i ] ] ; for ( int i = 1 ; i <= 255 ; ++ i ) count [ i ] += count [ i - 1 ] ; for ( int i = n - 1 ; i >= 0 ; i -- ) { output [ count [ arr [ i ] ] - 1 ] = arr [ i ] ; -- count [ arr [ i ] ] ; } for ( int i = 0 ; i < n ; ++ i ) arr [ i ] = output [ i ] ; }
Ref: 
def countSort ( arr ) : NEW_LINE INDENT output = [ 0 for i in range ( len ( arr ) ) ] NEW_LINE count = [ 0 for i in range ( 256 ) ] NEW_LINE for i in arr : NEW_LINE INDENT count [ ord ( i ) ] += 1 NEW_LINE DEDENT for i in range ( 256 ) : NEW_LINE INDENT count [ i ] += count [ i - 1 ] NEW_LINE DEDENT for i in range ( len ( arr ) ) : NEW_LINE INDENT output [ count [ ord ( arr [ i ] ) ] - 1 ] = arr [ i ] NEW_LINE count [ ord ( arr [ i ] ) ] -= 1 NEW_LINE DEDENT ans = [ " " for _ in arr ] NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT ans [ i ] = output [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT
Hyp: 
def sort ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE output = [ 0 ] * n NEW_LINE count = [ 0 ] * 256 NEW_LINE for i in range ( 256 ) : NEW_LINE INDENT count [ i ] = 0 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT count [ arr [ i ] ] += 1 NEW_LINE DEDENT for i in range ( 1 , 255 ) : NEW_LINE INDENT count [ i ] += count [ i - 1 ] NEW_LINE DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT output [ count [ arr [ i ] ] -= 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = output [ i ] NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = arr [ i ] NEW_LINE DEDENT DEDENT

BLEU: 56.64
Edit Sim: 244


Src: 
int maxBottles ( int n , int e ) { int s = 0 , b = 0 ; int a = n ; while ( a != 0 ) { s = s + a ; a = ( a + b ) / e ; b = n - ( a * e ) ; n = a + b ; } return s ; }
Ref: 
def maxBottles ( n , e ) : NEW_LINE INDENT s = 0 NEW_LINE b = 0 NEW_LINE a = n NEW_LINE while ( a != 0 ) : NEW_LINE INDENT s = s + a NEW_LINE a = ( a + b ) // e NEW_LINE b = n - ( a * e ) NEW_LINE n = a + b NEW_LINE DEDENT return s NEW_LINE DEDENT
Hyp: 
def maxBottles ( n , e ) : NEW_LINE INDENT s = 0 NEW_LINE b = 0 NEW_LINE a = n NEW_LINE while ( a != 0 ) : NEW_LINE INDENT s = s + a NEW_LINE a = ( a + b ) // e NEW_LINE b = n - ( a * e ) NEW_LINE n = a + b NEW_LINE DEDENT return s NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
void printGMeans ( int A , int B , int N ) { float R = ( float ) Math . pow ( ( float ) ( B / A ) , 1.0 / ( float ) ( N + 1 ) ) ; for ( int i = 1 ; i <= N ; i ++ ) System . out . print ( A * Math . pow ( R , i ) + " ▁ " ) ; }
Ref: 
def printGMeans ( A , B , N ) : NEW_LINE INDENT R = ( math . pow ( ( B / A ) , 1.0 / ( N + 1 ) ) ) ; NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT print ( int ( A * math . pow ( R , i ) ) , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT
Hyp: 
def printGMeans ( A , B , N ) : NEW_LINE INDENT R = pow ( ( B / A ) , 1.0 / ( N + 1 ) ) NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT print ( A * pow ( R , i ) , end = " ▁ " ) NEW_LINE DEDENT DEDENT

BLEU: 74.02
Edit Sim: 30


Src: 
double vol_tetra ( int side ) { double volume = ( Math . pow ( side , 3 ) / ( 6 * Math . sqrt ( 2 ) ) ) ; return volume ; }
Ref: 
def vol_tetra ( side ) : NEW_LINE INDENT volume = ( side ** 3 / ( 6 * math . sqrt ( 2 ) ) ) NEW_LINE return round ( volume , 2 ) NEW_LINE DEDENT
Hyp: 
def vol_tetra ( side ) : NEW_LINE INDENT volume = ( pow ( side , 3 ) / ( 6 * math . sqrt ( 2 ) ) ) ; NEW_LINE return volume ; NEW_LINE DEDENT

BLEU: 66.29
Edit Sim: 25


Src: 
void removeDuplicate ( char str [ ] , int n ) { HashSet < Character > s = new LinkedHashSet < > ( n - 1 ) ; for ( char x : str ) s . add ( x ) ; for ( char x : s ) System . out . print ( x ) ; }
Ref: 
def removeDuplicate ( str , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in str : NEW_LINE INDENT s . add ( i ) NEW_LINE DEDENT st = " " NEW_LINE for i in s : NEW_LINE INDENT st = st + i NEW_LINE DEDENT return st NEW_LINE DEDENT
Hyp: 
def removeDuplicate ( str , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE for x in str : NEW_LINE INDENT s . add ( x ) NEW_LINE DEDENT print ( * s ) NEW_LINE DEDENT

BLEU: 45.74
Edit Sim: 78


Src: 
void querySum ( int arr [ ] , int N , int Q [ ] [ ] , int M ) { for ( int i = 0 ; i < M ; i ++ ) { int x = Q [ i ] [ 0 ] ; int y = Q [ i ] [ 1 ] ; int sum = 0 ; while ( x < N ) { sum += arr [ x ] ; x += y ; } System . out . print ( sum + " ▁ " ) ; } }
Ref: 
def querySum ( arr , N , Q , M ) : NEW_LINE INDENT for i in range ( M ) : NEW_LINE INDENT x = Q [ i ] [ 0 ] NEW_LINE y = Q [ i ] [ 1 ] NEW_LINE sum = 0 NEW_LINE while ( x < N ) : NEW_LINE INDENT sum += arr [ x ] NEW_LINE x += y NEW_LINE DEDENT print ( sum , end = " ▁ " ) NEW_LINE DEDENT DEDENT
Hyp: 
def querySum ( arr , N , Q , M ) : NEW_LINE INDENT for i in range ( M ) : NEW_LINE INDENT x = Q [ i ] [ 0 ] NEW_LINE y = Q [ i ] [ 1 ] NEW_LINE sum = 0 NEW_LINE while ( x < N ) : NEW_LINE INDENT sum += arr [ x ] NEW_LINE x += y NEW_LINE DEDENT print ( sum , end = " ▁ " ) NEW_LINE DEDENT DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int maximumSum ( int [ ] A , int N , int K , int D ) { int ans = 0 ; for ( int i = 0 ; i < ( 1 << N ) ; i ++ ) { int sum = 0 ; int c = 0 ; for ( int j = 0 ; j < N ; j ++ ) { if ( ( i >> j & 1 ) != 0 ) { sum += A [ j ] ; c ++ ; } } if ( sum % D == 0 && c <= K ) ans = Math . max ( ans , sum ) ; } return ans ; }
Ref: 
def maximumSum ( A , N , K , D ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( ( 1 << N ) ) : NEW_LINE INDENT sum = 0 NEW_LINE c = 0 NEW_LINE for j in range ( N ) : NEW_LINE INDENT if ( i >> j & 1 ) : NEW_LINE INDENT sum += A [ j ] NEW_LINE c += 1 NEW_LINE DEDENT DEDENT if ( sum % D == 0 and c <= K ) : NEW_LINE INDENT ans = max ( ans , sum ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
Hyp: 
def maximumSum ( A , N , K , D ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 << N ) : NEW_LINE INDENT sum = 0 NEW_LINE c = 0 NEW_LINE for j in range ( N ) : NEW_LINE INDENT if ( i >> j & 1 ) : NEW_LINE INDENT sum += A [ j ] NEW_LINE c += 1 NEW_LINE DEDENT DEDENT if ( sum % D == 0 and c <= K ) : NEW_LINE INDENT ans = max ( ans , sum ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT

BLEU: 96.58
Edit Sim: 4


Src: 
void find_set ( int n ) { if ( n <= 2 ) { System . out . println ( " - 1" ) ; return ; } int sum1 = ( n * ( n - 1 ) ) / 2 ; int sum2 = n ; System . out . println ( sum1 + " ▁ " + sum2 ) ; }
Ref: 
def find_set ( n ) : NEW_LINE INDENT if ( n <= 2 ) : NEW_LINE INDENT print ( " - 1" ) ; NEW_LINE return ; NEW_LINE DEDENT sum1 = ( n * ( n - 1 ) ) / 2 ; NEW_LINE sum2 = n ; NEW_LINE print ( sum1 , " ▁ " , sum2 ) ; NEW_LINE DEDENT
Hyp: 
def find_set ( n ) : NEW_LINE INDENT if ( n <= 2 ) : NEW_LINE INDENT print ( " - 1" ) NEW_LINE return NEW_LINE DEDENT sum1 = ( n * ( n - 1 ) ) // 2 NEW_LINE sum2 = n NEW_LINE print ( sum1 , " ▁ " , sum2 ) NEW_LINE DEDENT

BLEU: 76.74
Edit Sim: 11


Src: 
void maximumSumPermutation ( int [ ] arr ) { int N = arr . length ; Arrays . sort ( arr ) ; int temp = arr [ 0 ] ; arr [ 0 ] = arr [ N - 1 ] ; arr [ N - 1 ] = temp ; for ( int i : arr ) { System . out . print ( i + " ▁ " ) ; } }
Ref: 
def maximumSumPermutation ( arr ) : NEW_LINE INDENT N = len ( arr ) ; NEW_LINE arr . sort ( ) ; NEW_LINE temp = arr [ 0 ] ; NEW_LINE arr [ 0 ] = arr [ N - 1 ] ; NEW_LINE arr [ N - 1 ] = temp ; NEW_LINE for i in arr : NEW_LINE INDENT print ( i , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT
Hyp: 
def maximumSumPermutation ( arr ) : NEW_LINE INDENT N = len ( arr ) NEW_LINE arr . sort ( ) NEW_LINE temp = arr [ 0 ] NEW_LINE arr [ 0 ] = arr [ N - 1 ] NEW_LINE arr [ N - 1 ] = temp NEW_LINE for i in arr : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT

BLEU: 78.94
Edit Sim: 12


Src: 
int Race ( int B , int C ) { int result = 0 ; result = ( ( C * 100 ) / B ) ; return 100 - result ; }
Ref: 
def Race ( B , C ) : NEW_LINE INDENT result = 0 ; NEW_LINE result = ( ( C * 100 ) // B ) NEW_LINE return 100 - result NEW_LINE DEDENT
Hyp: 
def Race ( B , C ) : NEW_LINE INDENT result = 0 NEW_LINE result = ( ( C * 100 ) / B ) NEW_LINE return 100 - result NEW_LINE DEDENT

BLEU: 84.03
Edit Sim: 3


Src: 
int MaxProfit ( int treasure [ ] , int color [ ] , int n , int k , int col , int A , int B ) { return dp [ k ] [ col ] = 0 ; if ( dp [ k ] [ col ] != - 1 ) return dp [ k ] [ col ] ; int sum = 0 ; if ( col == color [ k ] ) sum += Math . max ( A * treasure [ k ] + MaxProfit ( treasure , color , n , k + 1 , color [ k ] , A , B ) , MaxProfit ( treasure , color , n , k + 1 , col , A , B ) ) ; else sum += Math . max ( B * treasure [ k ] + MaxProfit ( treasure , color , n , k + 1 , color [ k ] , A , B ) , MaxProfit ( treasure , color , n , k + 1 , col , A , B ) ) ; return dp [ k ] [ col ] = sum ; }
Ref: 
def MaxProfit ( treasure , color , n , k , col , A , B ) : NEW_LINE INDENT if ( k == n ) : NEW_LINE INDENT dp [ k ] [ col ] = 0 NEW_LINE return dp [ k ] [ col ] NEW_LINE DEDENT if ( dp [ k ] [ col ] != - 1 ) : NEW_LINE INDENT return dp [ k ] [ col ] NEW_LINE DEDENT summ = 0 NEW_LINE if ( col == color [ k ] ) : NEW_LINE INDENT summ += max ( A * treasure [ k ] + MaxProfit ( treasure , color , n , k + 1 , color [ k ] , A , B ) , MaxProfit ( treasure , color , n , k + 1 , col , A , B ) ) NEW_LINE DEDENT else : NEW_LINE INDENT summ += max ( B * treasure [ k ] + MaxProfit ( treasure , color , n , k + 1 , color [ k ] , A , B ) , MaxProfit ( treasure , color , n , k + 1 , col , A , B ) ) NEW_LINE DEDENT dp [ k ] [ col ] = summ NEW_LINE return dp [ k ] [ col ] NEW_LINE DEDENT
Hyp: 
def MaxProfit ( treasure , color , n , k , col , A , B ) : NEW_LINE INDENT dp [ k ] [ col ] = 0 NEW_LINE if col in dp : NEW_LINE INDENT return dp [ k ] [ col ] NEW_LINE DEDENT sum = 0 NEW_LINE if col == color [ k ] : NEW_LINE INDENT sum += max ( A * treasure [ k ] + MaxProfit ( treasure , color , n , k + 1 , color [ k ] , A , B ) , MaxProfit ( treasure , color , n , k + 1 , col , A , B ) ) NEW_LINE DEDENT else : NEW_LINE INDENT sum += max ( B * treasure [ k ] + MaxProfit ( treasure , color , n , k + 1 , color [ k ] , A , B ) , MaxProfit ( treasure , color , n , k + 1 , col , A , B ) ) NEW_LINE DEDENT DEDENT return dp [ k ] [ col ] NEW_LINE DEDENT

BLEU: 73.05
Edit Sim: 130


Src: 
int Minsteps ( int n , int m ) { int ans = 0 ; while ( m > n ) { if ( m % 2 != 0 ) { m ++ ; ans ++ ; } m /= 2 ; ans ++ ; } return ans + n - m ; }
Ref: 
def Minsteps ( n , m ) : NEW_LINE INDENT ans = 0 NEW_LINE while ( m > n ) : NEW_LINE INDENT if ( m & 1 ) : NEW_LINE INDENT m += 1 NEW_LINE ans += 1 NEW_LINE DEDENT m //= 2 NEW_LINE ans += 1 NEW_LINE DEDENT return ans + n - m NEW_LINE DEDENT
Hyp: 
def Minsteps ( n , m ) : NEW_LINE INDENT ans = 0 NEW_LINE while ( m > n ) : NEW_LINE INDENT if ( m % 2 != 0 ) : NEW_LINE INDENT m += 1 NEW_LINE ans += 1 NEW_LINE DEDENT m //= 2 NEW_LINE ans += 1 NEW_LINE DEDENT return ans + n - m NEW_LINE DEDENT

BLEU: 90.69
Edit Sim: 7


Src: 
int nextPowerOf2 ( int n ) { int p = 1 ; if ( n > 0 && ( n & ( n - 1 ) ) == 0 ) return n ; while ( p < n ) p <<= 1 ; return p ; }
Ref: 
def nextPowerOf2 ( n ) : NEW_LINE INDENT p = 1 NEW_LINE if ( n and not ( n & ( n - 1 ) ) ) : NEW_LINE INDENT return n NEW_LINE DEDENT while ( p < n ) : NEW_LINE INDENT p <<= 1 NEW_LINE DEDENT return p ; NEW_LINE DEDENT
Hyp: 
def nextPowerOf2 ( n ) : NEW_LINE INDENT p = 1 NEW_LINE if ( n and not ( n & ( n - 1 ) ) ) : NEW_LINE INDENT return n NEW_LINE DEDENT while ( p < n ) : NEW_LINE INDENT p <<= 1 NEW_LINE DEDENT return p NEW_LINE DEDENT

BLEU: 95.67
Edit Sim: 2


Src: 
void count_minimum ( String s ) { int n = s . length ( ) ; int ans = 0 ; int i = 0 ; while ( i < n ) { int j = i ; while ( j < n && s . charAt ( j ) == s . charAt ( i ) ) { j ++ ; } int diff = j - i ; ans += diff / 2 ; i = j ; } System . out . println ( ans ) ; }
Ref: 
def count_minimum ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE ans = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT j = i NEW_LINE while j < n and ( s [ j ] == s [ i ] ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT diff = j - i NEW_LINE ans += diff // 2 NEW_LINE i = j NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
Hyp: 
def count_minimum ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE ans = 0 NEW_LINE i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT j = i NEW_LINE while ( j < n and s [ j ] == s [ i ] ) : NEW_LINE j += 1 NEW_LINE DEDENT diff = j - i NEW_LINE ans += diff // 2 NEW_LINE i = j NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT

BLEU: 87.35
Edit Sim: 15


Src: 
long minimumMoves ( int a [ ] , int n ) { long operations = 0 ; Arrays . sort ( a ) ; for ( int i = 0 ; i < n ; i ++ ) operations += ( long ) Math . abs ( a [ i ] - ( i + 1 ) ) ; return operations ; }
Ref: 
def minimumMoves ( a , n ) : NEW_LINE INDENT operations = 0 NEW_LINE a . sort ( reverse = False ) NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT operations = operations + abs ( a [ i ] - ( i + 1 ) ) NEW_LINE DEDENT return operations NEW_LINE DEDENT
Hyp: 
def minimumMoves ( a , n ) : NEW_LINE INDENT operations = 0 NEW_LINE a . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT operations += abs ( a [ i ] - ( i + 1 ) ) NEW_LINE DEDENT return operations NEW_LINE DEDENT

BLEU: 73.03
Edit Sim: 38


Src: 
void pushZerosToEnd ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] != 0 ) arr [ count ++ ] = arr [ i ] ; while ( count < n ) arr [ count ++ ] = 0 ; }
Ref: 
def pushZerosToEnd ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] != 0 : NEW_LINE INDENT arr [ count ] = arr [ i ] NEW_LINE count += 1 NEW_LINE DEDENT DEDENT while count < n : NEW_LINE INDENT arr [ count ] = 0 NEW_LINE count += 1 NEW_LINE DEDENT DEDENT
Hyp: 
def pushZerosToEnd ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] != 0 ) : NEW_LINE INDENT arr [ count ] = arr [ i ] NEW_LINE DEDENT DEDENT while ( count < n ) : NEW_LINE INDENT arr [ count ] = 0 NEW_LINE DEDENT DEDENT

BLEU: 76.9
Edit Sim: 48


Src: 
int count ( String s , int k ) { int n = s . length ( ) ; int d = 0 , i ; int count = 0 ; for ( i = 0 ; i < n ; i ++ ) d += s . charAt ( i ) ; if ( d % k == 0 ) count += 1 ; for ( i = k ; i < n ; i ++ ) { int prev = s . charAt ( i - k ) ; d -= prev ; d += s . charAt ( i ) ; if ( d % k == 0 ) count += 1 ; } return count ; }
Ref: 
def count ( s , k ) : NEW_LINE INDENT n = len ( s ) NEW_LINE d , count = 0 , 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT d += ord ( s [ i ] ) NEW_LINE if ( d % k == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE for i in range ( k , n ) : NEW_LINE INDENT prev = ord ( s [ i - k ] ) NEW_LINE d -= prev NEW_LINE d += ord ( s [ i ] ) NEW_LINE if ( d % k == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE return count NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT
Hyp: 
def count ( s , k ) : NEW_LINE INDENT n = len ( s ) NEW_LINE d = 0 NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT d += s [ i ] NEW_LINE DEDENT if ( d % k == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT for i in range ( k , n ) : NEW_LINE INDENT prev = s [ i - k ] NEW_LINE d -= prev NEW_LINE d += s [ i ] NEW_LINE if ( d % k == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT

BLEU: 72.38
Edit Sim: 92


Src: 
void check_string_exist ( String S ) { int size = S . length ( ) ; boolean check = true ; for ( int i = 0 ; i < size ; i ++ ) { if ( S . charAt ( i ) != S . charAt ( ( i + 2 ) % size ) ) { check = false ; break ; } } if ( check ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; }
Ref: 
def check_string_exist ( S ) : NEW_LINE INDENT size = len ( S ) NEW_LINE check = True NEW_LINE for i in range ( size ) : NEW_LINE INDENT if S [ i ] != S [ ( i + 2 ) % size ] : NEW_LINE INDENT check = False NEW_LINE break NEW_LINE DEDENT DEDENT if check : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
Hyp: 
def check_string_exist ( S ) : NEW_LINE INDENT size = len ( S ) NEW_LINE check = True NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT if ( S [ i ] != S [ ( i + 2 ) % size ] ) : NEW_LINE INDENT check = False NEW_LINE break NEW_LINE DEDENT DEDENT if ( check ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT

BLEU: 85.17
Edit Sim: 12


Src: 
void PrintBothArrays ( int a [ ] , int n ) { Vector < Integer > v1 = new Vector < Integer > ( ) , v2 = new Vector < Integer > ( ) ; HashMap < Integer , Integer > mpp = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { mpp . put ( a [ i ] , ( mpp . get ( a [ i ] ) == null ? 0 : mpp . get ( a [ i ] ) ) + 1 ) ; if ( mpp . get ( a [ i ] ) == 1 ) v1 . add ( a [ i ] ) ; else if ( mpp . get ( a [ i ] ) == 2 ) v2 . add ( a [ i ] ) ; else { System . out . println ( " Not ▁ possible " ) ; return ; } } Collections . sort ( v1 ) ; System . out . println ( " Strictly ▁ increasing ▁ array ▁ is : " ) ; for ( int i = 0 ; i < v1 . size ( ) ; i ++ ) System . out . print ( v1 . get ( i ) + " ▁ " ) ; Collections . sort ( v2 ) ; Collections . reverse ( v2 ) ; System . out . println ( " Strictly decreasing array is : "); for ( int i = 0 ; i < v2 . size ( ) ; i ++ ) System . out . print ( v2 . get ( i ) + " ▁ " ) ; }
Ref: 
def PrintBothArrays ( a , n ) : NEW_LINE INDENT v1 , v2 = [ ] , [ ] ; NEW_LINE mpp = dict . fromkeys ( a , 0 ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT mpp [ a [ i ] ] += 1 ; NEW_LINE if ( mpp [ a [ i ] ] == 1 ) : NEW_LINE INDENT v1 . append ( a [ i ] ) ; NEW_LINE DEDENT elif ( mpp [ a [ i ] ] == 2 ) : NEW_LINE INDENT v2 . append ( a [ i ] ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ possible " ) ; NEW_LINE return ; NEW_LINE DEDENT DEDENT v1 . sort ( ) ; NEW_LINE print ( " Strictly ▁ increasing ▁ array ▁ is : " ) ; NEW_LINE for it in v1 : NEW_LINE INDENT print ( it , end = " ▁ " ) ; NEW_LINE DEDENT v2 . sort ( reverse = True ) ; NEW_LINE print ( " Strictly decreasing array is : " ) ; NEW_LINE for it in v2 : NEW_LINE INDENT print ( it , end = " ▁ " ) NEW_LINE DEDENT DEDENT
Hyp: 
def PrintBothArrays ( a , n ) : NEW_LINE INDENT v1 = list ( ) NEW_LINE v2 = list ( ) NEW_LINE mpp = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT mpp [ a [ i ] ] = ( mpp [ a [ i ] ] + 1 ) NEW_LINE if ( mpp [ a [ i ] ] == null ) : NEW_LINE INDENT v1 . append ( a [ i ] ) NEW_LINE DEDENT elif ( mpp [ a [ i ] ) == 1 : NEW_LINE INDENT v1 . append ( a [ i ] ) NEW_LINE DEDENT elif ( mpp [ a [ i ] ) == 2 : NEW_LINE INDENT v2 . append ( a [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Strictly ▁ increasing ▁ array ▁ is : " ) NEW_LINE for i in sorted ( v1 ) : NEW_LINE INDENT print ( v1 [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT

BLEU: 51.32
Edit Sim: 318


Src: 
void checkString ( String s , int k ) { int n = s . length ( ) ; if ( 2 * k + 1 > n ) { System . out . println ( " No " ) ; return ; } String a = s . substring ( 0 , k ) ; String b = s . substring ( n - k , n ) ; StringBuffer str = new StringBuffer ( b ) ; str . reverse ( ) ; b = str . toString ( ) ; if ( a . equals ( b ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; }
Ref: 
def checkString ( s , k ) : NEW_LINE INDENT n = len ( s ) NEW_LINE if ( 2 * k + 1 > n ) : NEW_LINE INDENT print ( " No " ) NEW_LINE return NEW_LINE DEDENT a = s [ 0 : k ] NEW_LINE b = s [ n - k : n ] NEW_LINE b = b [ : : - 1 ] NEW_LINE if ( a == b ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
Hyp: 
def checkString ( s , k ) : NEW_LINE INDENT n = len ( s ) NEW_LINE if ( 2 * k + 1 > n ) : NEW_LINE INDENT print ( " No " ) NEW_LINE return NEW_LINE DEDENT a = s [ 0 : k ] NEW_LINE b = s [ n - k : n ] NEW_LINE str = list ( b ) NEW_LINE if ( a == b ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT

BLEU: 89.88
Edit Sim: 12


Src: 
void findAllTriplets ( int arr [ ] , int n ) { for ( int i = 1 ; i < n - 1 ; i ++ ) { for ( int j = i - 1 , k = i + 1 ; j >= 0 && k < n ; ) { if ( arr [ j ] + arr [ k ] == 2 * arr [ i ] ) { System . out . println ( arr [ j ] + " ▁ " + arr [ i ] + " ▁ " + arr [ k ] ) ; k ++ ; j -- ; } else if ( arr [ j ] + arr [ k ] < 2 * arr [ i ] ) k ++ ; else j -- ; } } }
Ref: 
def printAllAPTriplets ( arr , n ) : NEW_LINE INDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT j = i - 1 NEW_LINE k = i + 1 NEW_LINE while ( j >= 0 and k < n ) : NEW_LINE INDENT if ( arr [ j ] + arr [ k ] == 2 * arr [ i ] ) : NEW_LINE INDENT print ( arr [ j ] , " " , arr [ i ] , " " , arr [ k ] ) NEW_LINE k += 1 NEW_LINE j -= 1 NEW_LINE DEDENT elif ( arr [ j ] + arr [ k ] < 2 * arr [ i ] ) : NEW_LINE INDENT k += 1 NEW_LINE DEDENT else : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT
Hyp: 
def findAllTriplets ( arr , n ) : NEW_LINE INDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT for j in range ( i - 1 , i + 1 ) : NEW_LINE INDENT k = i + 1 NEW_LINE while ( j >= 0 and k < n ) : NEW_LINE INDENT if ( arr [ j ] + arr [ k ] == 2 * arr [ i ] ) : NEW_LINE INDENT print ( arr [ j ] , i , arr [ k ] ) NEW_LINE k += 1 NEW_LINE j -= 1 NEW_LINE DEDENT elif ( arr [ j ] + arr [ k ] < 2 * arr [ i ] ) : NEW_LINE INDENT k += 1 NEW_LINE DEDENT else : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT DEDENT DEDENT

BLEU: 86.38
Edit Sim: 65


Src: 
boolean isFactorion ( int n ) { int fact [ ] = new int [ MAX ] ; fact [ 0 ] = 1 ; for ( int i = 1 ; i < MAX ; i ++ ) fact [ i ] = i * fact [ i - 1 ] ; int org = n ; int sum = 0 ; while ( n > 0 ) { int d = n % 10 ; sum += fact [ d ] ; n /= 10 ; } if ( sum == org ) return true ; return false ; }
Ref: 
def isFactorion ( n ) : NEW_LINE INDENT fact = [ 0 ] * MAX NEW_LINE fact [ 0 ] = 1 NEW_LINE for i in range ( 1 , MAX ) : NEW_LINE INDENT fact [ i ] = i * fact [ i - 1 ] NEW_LINE DEDENT org = n NEW_LINE sum = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT d = n % 10 NEW_LINE sum += fact [ d ] NEW_LINE n = n // 10 NEW_LINE DEDENT if ( sum == org ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT n = 40585 NEW_LINE if ( isFactorion ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
Hyp: 
def isFactorion ( n ) : NEW_LINE INDENT fact = [ 0 ] * MAX NEW_LINE fact [ 0 ] = 1 NEW_LINE for i in range ( 1 , MAX ) : NEW_LINE INDENT fact [ i ] = i * fact [ i - 1 ] NEW_LINE DEDENT org = n NEW_LINE sum = 0 NEW_LINE while ( n ) : NEW_LINE INDENT d = n % 10 NEW_LINE sum += fact [ d ] NEW_LINE n /= 10 NEW_LINE DEDENT if ( sum == org ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT n = 65 NEW_LINE if ( isFactorion ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT

BLEU: 92.28
Edit Sim: 13


Src: 
int countSetBits ( int L , int R ) { int count = 0 ; for ( int i = L ; i <= R ; i ++ ) { int n = i ; while ( n > 0 ) { count += ( n & 1 ) ; n = n >> 1 ; } } return count ; }
Ref: 
def countSetBits ( L , R ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( L , R + 1 ) : NEW_LINE INDENT n = i ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT count += ( n & 1 ) ; NEW_LINE n = n >> 1 ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT
Hyp: 
def countSetBits ( L , R ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( L , R + 1 ) : NEW_LINE INDENT n = i NEW_LINE while ( n > 0 ) : NEW_LINE INDENT count += ( n & 1 ) NEW_LINE n = n >> 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT

BLEU: 80.52
Edit Sim: 10


Src: 
int solve ( int idx , int diff , int N , int M , int K ) { if ( idx > N ) { if ( diff == K ) return 1 ; return 0 ; } if ( dp [ idx ] [ diff ] != - 1 ) return dp [ idx ] [ diff ] ; int ans = solve ( idx + 1 , diff , N , M , K ) ; ans += ( M - 1 ) * solve ( idx + 1 , diff + 1 , N , M , K ) ; return dp [ idx ] [ diff ] = ans % MOD ; }
Ref: 
def solve ( idx , diff , N , M , K ) : NEW_LINE INDENT if ( idx > N ) : NEW_LINE INDENT if ( diff == K ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT if ( dp [ idx ] [ diff ] != - 1 ) : NEW_LINE INDENT return dp [ idx ] ; NEW_LINE DEDENT ans = solve ( idx + 1 , diff , N , M , K ) ; NEW_LINE ans += ( M - 1 ) * solve ( idx + 1 , diff + 1 , N , M , K ) ; NEW_LINE dp [ idx ] [ diff ] = ans % MOD ; NEW_LINE return dp [ idx ] [ diff ] NEW_LINE DEDENT
Hyp: 
def solve ( idx , diff , N , M , K ) : NEW_LINE INDENT if ( idx > N ) : NEW_LINE INDENT if ( diff == K ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT DEDENT if ( dp [ idx ] [ diff ] != - 1 ) : NEW_LINE INDENT return dp [ idx ] [ diff ] NEW_LINE DEDENT ans = solve ( idx + 1 , diff , N , M , K ) NEW_LINE ans += ( M - 1 ) * solve ( idx + 1 , diff + 1 , N , M , K ) NEW_LINE return dp [ idx ] [ diff ] NEW_LINE DEDENT

BLEU: 85.77
Edit Sim: 62


Src: 
int findevenPair ( int A [ ] , int N ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( A [ i ] % 2 != 0 ) count ++ ; int oddCount = count * ( count - 1 ) / 2 ; return ( N * ( N - 1 ) / 2 ) - oddCount ; }
Ref: 
def findevenPair ( A , N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT if ( A [ i ] % 2 != 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT oddCount = count * ( count - 1 ) / 2 NEW_LINE return ( int ) ( ( N * ( N - 1 ) / 2 ) - oddCount ) NEW_LINE DEDENT
Hyp: 
def findevenPair ( A , N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( A [ i ] % 2 != 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT oddCount = count * ( count - 1 ) // 2 NEW_LINE return ( N * ( N - 1 ) // 2 ) - oddCount NEW_LINE DEDENT

BLEU: 79.59
Edit Sim: 18


Src: 
int binary_searched_find_x ( int k ) { int l = 0 ; int r = k ; int ans = 0 ; while ( l <= r ) { int mid = l + ( r - l ) / 2 ; if ( Math . pow ( ( ( mid * ( mid + 1 ) ) / 2 ) , 2 ) >= k ) { ans = mid ; r = mid - 1 ; } else { l = mid + 1 ; } } return ans ; }
Ref: 
def binary_searched_find_x ( k ) : NEW_LINE INDENT l = 0 NEW_LINE r = k NEW_LINE ans = 0 NEW_LINE while l <= r : NEW_LINE INDENT mid = l + ( r - l ) // 2 NEW_LINE if ( ( mid * ( mid + 1 ) ) // 2 ) ** 2 >= k : NEW_LINE INDENT ans = mid NEW_LINE r = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
Hyp: 
def binary_searched_find_x ( k ) : NEW_LINE INDENT l = 0 NEW_LINE r = k NEW_LINE ans = 0 NEW_LINE while ( l <= r ) : NEW_LINE INDENT mid = l + ( ( r - l ) // 2 ) NEW_LINE if ( pow ( ( mid * ( mid + 1 ) ) / 2 ) , 2 ) >= k ) : NEW_LINE INDENT ans = mid NEW_LINE r = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT

BLEU: 78.05
Edit Sim: 21


Src: 
int minDistance ( int n1 , int n2 ) { int bitCount1 = ( int ) Math . floor ( ( Math . log ( n1 ) / Math . log ( 2 ) ) ) + 1 ; int bitCount2 = ( int ) Math . floor ( ( Math . log ( n2 ) / Math . log ( 2 ) ) ) + 1 ; int bitDiff = Math . abs ( bitCount1 - bitCount2 ) ; int maxBitCount = Math . max ( bitCount1 , bitCount2 ) ; if ( bitCount1 > bitCount2 ) { n2 = n2 * ( int ) Math . pow ( 2 , bitDiff ) ; } else { n1 = n1 * ( int ) Math . pow ( 2 , bitDiff ) ; } int xorValue = n1 ^ n2 ; int bitCountXorValue ; if ( xorValue == 0 ) bitCountXorValue = 1 ; else { bitCountXorValue = ( int ) Math . floor ( ( Math . log ( xorValue ) / Math . log ( 2 ) ) ) + 1 ; } int disSimilarBitPosition = maxBitCount - bitCountXorValue ; int result = bitCount1 + bitCount2 - 2 * disSimilarBitPosition ; return result ; }
Ref: 
def minDistance ( n1 , n2 ) : NEW_LINE INDENT bitCount1 = int ( log2 ( n1 ) ) + 1 NEW_LINE bitCount2 = int ( log2 ( n2 ) ) + 1 NEW_LINE bitDiff = abs ( bitCount1 - bitCount2 ) NEW_LINE maxBitCount = max ( bitCount1 , bitCount2 ) NEW_LINE if ( bitCount1 > bitCount2 ) : NEW_LINE INDENT n2 = int ( n2 * pow ( 2 , bitDiff ) ) NEW_LINE DEDENT else : NEW_LINE INDENT n1 = int ( n1 * pow ( 2 , bitDiff ) ) NEW_LINE DEDENT xorValue = n1 ^ n2 NEW_LINE if xorValue == 0 : NEW_LINE INDENT bitCountXorValue = 1 NEW_LINE DEDENT else : NEW_LINE INDENT bitCountXorValue = int ( log2 ( xorValue ) ) + 1 NEW_LINE DEDENT disSimilarBitPosition = ( maxBitCount - bitCountXorValue ) NEW_LINE result = ( bitCount1 + bitCount2 - 2 * disSimilarBitPosition ) NEW_LINE return result NEW_LINE DEDENT
Hyp: 
def minDistance ( n1 , n2 ) : NEW_LINE INDENT bitCount1 = floor ( ( math . log2 ( n1 ) ) + 1 ) NEW_LINE bitCount2 = floor ( ( math . log2 ( n2 ) ) + 1 ) NEW_LINE bitDiff = abs ( bitCount1 - bitCount2 ) NEW_LINE maxBitCount = max ( bitCount1 , bitCount2 ) NEW_LINE if ( bitCount1 > bitCount2 ) : NEW_LINE INDENT n2 = n2 * ( 2 ** bitDiff ) NEW_LINE DEDENT else : NEW_LINE INDENT n1 = n1 * ( math . pow ( 2 , bitDiff ) ) NEW_LINE DEDENT xorValue = n1 ^ n2 NEW_LINE bitCountXorValue = 0 NEW_LINE if ( xorValue == 0 ) : NEW_LINE INDENT bitCountXorValue = 1 NEW_LINE DEDENT else : NEW_LINE INDENT bitCountXorValue = floor ( ( math . log2 ( xorValue ) / math . log ( 2 ) ) ) + 1 NEW_LINE DEDENT disSimilarBitPosition = maxBitCount - bitCountXorValue NEW_LINE result = bitCount1 + bitCount2 - 2 * disSimilarBitPosition NEW_LINE return result NEW_LINE DEDENT

BLEU: 65.52
Edit Sim: 132


Src: 
int countInRange ( int arr [ ] , int n , int x , int y ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] >= x && arr [ i ] <= y ) count ++ ; } return count ; }
Ref: 
def countInRange ( arr , n , x , y ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] >= x and arr [ i ] <= y ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
Hyp: 
def countInRange ( arr , n , x , y ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] >= x and arr [ i ] <= y ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT

BLEU: 95.59
Edit Sim: 2


Src: 
int answer_query ( int a [ ] , int n , int l , int r ) { int count = 0 ; for ( int i = l ; i < r ; i ++ ) if ( a [ i ] == a [ i + 1 ] ) count += 1 ; return count ; }
Ref: 
def answer_query ( a , n , l , r ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( l , r ) : NEW_LINE INDENT if ( a [ i ] == a [ i + 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
Hyp: 
def answer_query ( a , n , l , r ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( l , r ) : NEW_LINE INDENT if ( a [ i ] == a [ i + 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int countDistinct ( int arr [ ] , int n ) { int res = 1 ; for ( int i = 1 ; i < n ; i ++ ) { int j = 0 ; for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] == arr [ j ] ) break ; if ( i == j ) res ++ ; } return res ; }
Ref: 
def countDistinct ( arr , n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT j = 0 NEW_LINE for j in range ( i ) : NEW_LINE INDENT if ( arr [ i ] == arr [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( i == j + 1 ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
Hyp: 
def countDistinct ( arr , n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT j = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] == arr [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( i == j ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT

BLEU: 89.71
Edit Sim: 10


Src: 
int sumOfSeries ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= i ; j ++ ) sum = sum + i ; return sum ; }
Ref: 
def sumOfSeries ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum = sum + i * i NEW_LINE DEDENT return sum NEW_LINE DEDENT
Hyp: 
def sumOfSeries ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT sum = sum + i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT

BLEU: 68.21
Edit Sim: 57


Src: 
boolean checkOverlap ( int R , int Xc , int Yc , int X1 , int Y1 , int X2 , int Y2 ) { int Xn = Math . max ( X1 , Math . min ( Xc , X2 ) ) ; int Yn = Math . max ( Y1 , Math . min ( Yc , Y2 ) ) ; int Dx = Xn - Xc ; int Dy = Yn - Yc ; return ( Dx * Dx + Dy * Dy ) <= R * R ; }
Ref: 
def checkOverlap ( R , Xc , Yc , X1 , Y1 , X2 , Y2 ) : NEW_LINE INDENT Xn = max ( X1 , min ( Xc , X2 ) ) NEW_LINE Yn = max ( Y1 , min ( Yc , Y2 ) ) NEW_LINE Dx = Xn - Xc NEW_LINE Dy = Yn - Yc NEW_LINE return ( Dx ** 2 + Dy ** 2 ) <= R ** 2 NEW_LINE DEDENT if ( __name__ == " _ _ main _ _ " ) : NEW_LINE INDENT R = 1 NEW_LINE Xc , Yc = 0 , 0 NEW_LINE X1 , Y1 = 1 , - 1 NEW_LINE X2 , Y2 = 3 , 1 NEW_LINE print ( checkOverlap ( R , Xc , Yc , X1 , Y1 , X2 , Y2 ) ) NEW_LINE DEDENT
Hyp: 
def checkOverlap ( R , Xc , Yc , X1 , Y1 , X2 , Y2 ) : NEW_LINE INDENT Xn = max ( X1 , min ( Xc , X2 ) ) NEW_LINE Yn = max ( Y1 , min ( Yc , Y2 ) ) NEW_LINE Dx = Xn - Xc NEW_LINE Dy = Yn - Yc NEW_LINE return ( Dx * Dx + Dy * Dy ) <= R * R NEW_LINE DEDENT

BLEU: 36.96
Edit Sim: 228


Src: 
void getResult ( int n ) { int proOdd = 1 ; int proEven = 1 ; String num = String . valueOf ( n ) ; for ( int i = 0 ; i < num . length ( ) ; i ++ ) if ( i % 2 == 0 ) proOdd = proOdd * ( num . charAt ( i ) - '0' ) ; else proEven = proEven * ( num . charAt ( i ) - '0' ) ; if ( proOdd == proEven ) System . out . print ( " Yes " ) ; else System . out . print ( " No " ) ; }
Ref: 
def getResult ( n ) : NEW_LINE INDENT proOdd = 1 NEW_LINE proEven = 1 NEW_LINE num = str ( n ) NEW_LINE for i in range ( len ( num ) ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT proOdd = proOdd * int ( num [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT proEven = proEven * int ( num [ i ] ) NEW_LINE DEDENT DEDENT if ( proOdd == proEven ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
Hyp: 
def getResult ( n ) : NEW_LINE INDENT proOdd = 1 NEW_LINE proEven = 1 NEW_LINE num = str ( n ) NEW_LINE for i in range ( len ( num ) ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT proOdd = proOdd * ( ord ( num [ i ] ) - ord ( '0' ) ) NEW_LINE DEDENT else : NEW_LINE INDENT proEven = proEven * ( ord ( num [ i ] ) - ord ( '0' ) ) NEW_LINE DEDENT DEDENT if ( proOdd == proEven ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT

BLEU: 83.03
Edit Sim: 42


Src: 
int boost_hyperfactorial ( int num ) { int val = 1 ; for ( int i = 1 ; i <= num ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) { val *= i ; } } return val ; }
Ref: 
def boost_hyperfactorial ( num ) : NEW_LINE INDENT val = 1 ; NEW_LINE for i in range ( 1 , num + 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT val *= i ; NEW_LINE DEDENT DEDENT return val ; NEW_LINE DEDENT
Hyp: 
def boost_hyperfactorial ( num ) : NEW_LINE INDENT val = 1 NEW_LINE for i in range ( 1 , num + 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT val *= i NEW_LINE DEDENT DEDENT return val NEW_LINE DEDENT

BLEU: 85.75
Edit Sim: 6


Src: 
int countPaths ( int m , int n ) { if ( m == 1 n == 1 ) return 1 ; return countPaths ( m - 1 , n ) + countPaths ( m , n - 1 ) ; }
Ref: 
def countPaths ( m , n ) : NEW_LINE INDENT if m == 1 or n == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT return ( countPaths ( m - 1 , n ) + countPaths ( m , n - 1 ) ) NEW_LINE DEDENT
Hyp: 
def countPaths ( m , n ) : NEW_LINE INDENT if ( m == 1 or n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return countPaths ( m - 1 , n ) + countPaths ( m , n - 1 ) NEW_LINE DEDENT

BLEU: 84.55
Edit Sim: 8


Src: 
void Permutation ( int n , int k ) { int [ ] p = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) p [ i ] = i ; for ( int i = 1 ; i < n - k ; i ++ ) p [ i + 1 ] = i ; p [ 1 ] = n - k ; for ( int i = 1 ; i <= n ; i ++ ) System . out . print ( p [ i ] + " ▁ " ) ; }
Ref: 
def Permutation ( n , k ) : NEW_LINE INDENT p = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT p [ i ] = i NEW_LINE DEDENT for i in range ( 1 , n - k ) : NEW_LINE INDENT p [ i + 1 ] = i NEW_LINE DEDENT p [ 1 ] = n - k NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( p [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
Hyp: 
def Permutation ( n , k ) : NEW_LINE INDENT p = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT p [ i ] = i NEW_LINE DEDENT for i in range ( 1 , n - k + 1 ) : NEW_LINE INDENT p [ i + 1 ] = i NEW_LINE DEDENT p [ 1 ] = n - k NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( p [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT

BLEU: 91.45
Edit Sim: 19


Src: 
void countDecrements ( long arr [ ] [ ] ) { int n = arr . length ; int m = arr [ 0 ] . length ; int count_1 = 0 ; int count_2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( ( i + j ) % 2 == arr [ i ] [ j ] % 2 ) count_1 ++ ; if ( 1 - ( i + j ) % 2 == arr [ i ] [ j ] % 2 ) count_2 ++ ; } } System . out . println ( Math . min ( count_1 , count_2 ) ) ; }
Ref: 
def countDecrements ( arr ) : NEW_LINE INDENT count_1 = 0 NEW_LINE count_2 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( ( i + j ) % 2 == arr [ i ] [ j ] % 2 ) : NEW_LINE INDENT count_1 += 1 NEW_LINE DEDENT if ( 1 - ( i + j ) % 2 == arr [ i ] [ j ] % 2 ) : NEW_LINE INDENT count_2 += 1 NEW_LINE DEDENT DEDENT DEDENT print ( min ( count_1 , count_2 ) ) NEW_LINE DEDENT
Hyp: 
def countDecrements ( arr , n ) : NEW_LINE INDENT m = len ( arr [ 0 ] ) NEW_LINE count_1 = 0 NEW_LINE count_2 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( ( i + j ) % 2 == arr [ i ] [ j ] % 2 ) : NEW_LINE INDENT count_1 += 1 NEW_LINE DEDENT if ( 1 - ( i + j ) % 2 == arr [ i ] [ j ] % 2 ) : NEW_LINE INDENT count_2 += 1 NEW_LINE DEDENT DEDENT DEDENT print ( min ( count_1 , count_2 ) ) NEW_LINE DEDENT

BLEU: 87.3
Edit Sim: 35


Src: 
void findMax ( int arr [ ] [ ] ) { int row = 0 , i , j ; for ( i = 0 , j = N - 1 ; i < N ; i ++ ) { while ( j >= 0 && arr [ i ] [ j ] == 1 ) { row = i ; j -- ; } } System . out . print ( " Row ▁ number ▁ = ▁ " + ( row + 1 ) ) ; System . out . print ( " , ▁ MaxCount ▁ = ▁ " + ( N - 1 - j ) ) ; }
Ref: 
def findMax ( arr ) : NEW_LINE INDENT row = 0 NEW_LINE j = N - 1 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT while ( arr [ i ] [ j ] == 1 and j >= 0 ) : NEW_LINE INDENT row = i NEW_LINE j -= 1 NEW_LINE DEDENT DEDENT print ( " Row ▁ number ▁ = ▁ " , row + 1 , " , ▁ MaxCount ▁ = ▁ " , N - 1 - j ) NEW_LINE DEDENT
Hyp: 
def findMax ( arr ) : NEW_LINE INDENT row = 0 NEW_LINE j = N - 1 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT while ( j >= 0 and arr [ i ] [ j ] == 1 ) : NEW_LINE INDENT row = i NEW_LINE j -= 1 NEW_LINE DEDENT DEDENT print ( " Row ▁ number ▁ = " , ( row + 1 ) ) NEW_LINE print ( " , ▁ MaxCount ▁ = " , ( N - 1 - j ) ) NEW_LINE DEDENT

BLEU: 77.24
Edit Sim: 49


Src: 
int myXOR ( int x , int y ) { int res = 0 ; for ( int i = 31 ; i >= 0 ; i -- ) { int b1 = ( ( x & ( 1 << i ) ) == 0 ) ? 0 : 1 ; int b2 = ( ( y & ( 1 << i ) ) == 0 ) ? 0 : 1 ; int xoredBit = ( ( b1 & b2 ) != 0 ) ? 0 : ( b1 b2 ) ; res <<= 1 ; res |= xoredBit ; } return res ; }
Ref: 
def myXOR ( x , y ) : NEW_LINE INDENT for i in range ( 31 , - 1 , - 1 ) : NEW_LINE INDENT b1 = x & ( 1 << i ) NEW_LINE b2 = y & ( 1 << i ) NEW_LINE b1 = min ( b1 , 1 ) NEW_LINE b2 = min ( b2 , 1 ) NEW_LINE xoredBit = 0 NEW_LINE if ( b1 & b2 ) : NEW_LINE INDENT xoredBit = 0 NEW_LINE DEDENT else : NEW_LINE INDENT xoredBit = ( b1 b2 ) NEW_LINE DEDENT res <<= 1 ; NEW_LINE res |= xoredBit NEW_LINE DEDENT return res NEW_LINE DEDENT
Hyp: 
def myXOR ( x , y ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 31 , - 1 , - 1 ) : NEW_LINE INDENT b1 = ( x & ( 1 << i ) ) NEW_LINE b2 = ( y & ( 1 << i ) ) == 0 NEW_LINE xoredBit = ( b1 & b2 ) != 0 NEW_LINE res <<= 1 NEW_LINE res |= xoredBit NEW_LINE DEDENT return res NEW_LINE DEDENT

BLEU: 50.43
Edit Sim: 186


Src: 
void noOfArraysPossible ( int N , int M ) { int ans = 1 ; for ( int i = 0 ; i < N ; ++ i ) { ans = ans * ( M - i ) ; } System . out . print ( ans ) ; }
Ref: 
def noOfArraysPossible ( N , M ) : NEW_LINE INDENT ans = 1 NEW_LINE for i in range ( N ) : NEW_LINE INDENT ans = ans * ( M - i ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
Hyp: 
def noOfArraysPossible ( N , M ) : NEW_LINE INDENT ans = 1 NEW_LINE for i in range ( N ) : NEW_LINE INDENT ans = ans * ( M - i ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
String to_upper ( char [ ] in ) { for ( int i = 0 ; i < in . length ; i ++ ) if ( ' a ' <= in [ i ] && in [ i ] <= ' z ' ) in [ i ] &= ~ ( 1 << 5 ) ; return String . valueOf ( in ) ; }
Ref: 
def to_upper ( s ) : NEW_LINE INDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if ( ' a ' <= s [ i ] <= ' z ' ) : NEW_LINE INDENT s = s [ 0 : i ] + chr ( ord ( s [ i ] ) & ( ~ ( 1 << 5 ) ) ) + s [ i + 1 : ] ; NEW_LINE DEDENT DEDENT return s ; NEW_LINE DEDENT
Hyp: 
def to_upper ( in ) : NEW_LINE INDENT for i in range ( len ( in ) ) : NEW_LINE INDENT if ( ' a ' <= in [ i ] and in [ i ] <= ' z ' ) : NEW_LINE INDENT in [ i ] &= ~ ( 1 << 5 ) NEW_LINE DEDENT DEDENT return str ( in ) NEW_LINE DEDENT

BLEU: 47.09
Edit Sim: 83


Src: 
int minAbsDiff ( int N ) { if ( N % 4 == 0 N % 4 == 3 ) { return 0 ; } return 1 ; }
Ref: 
def minAbsDiff ( N ) : NEW_LINE INDENT if ( N % 4 == 0 or N % 4 == 3 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return 1 NEW_LINE DEDENT
Hyp: 
def minAbsDiff ( N ) : NEW_LINE INDENT if ( N % 4 == 0 or N % 4 == 3 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT return 1 NEW_LINE DEDENT

BLEU: 92.35
Edit Sim: 2


Src: 
int kthgroupsum ( int k ) { return k * k * k ; }
Ref: 
def kthgroupsum ( k ) : NEW_LINE INDENT return k * k * k NEW_LINE DEDENT
Hyp: 
def kthgroupsum ( k ) : NEW_LINE INDENT return k * k * k ; NEW_LINE DEDENT

BLEU: 85.79
Edit Sim: 2


Src: 
void main ( String [ ] args ) { int A = 6 ; double theta = 45 ; double [ ] ans = Length_Diagonals ( A , theta ) ; System . out . printf ( " % .2f " + " ▁ " + " % .2f " , ans [ 0 ] , ans [ 1 ] ) ; } }
Ref: 
def Length_Diagonals ( a , theta ) : NEW_LINE INDENT p = a * math . sqrt ( 2 + ( 2 * math . cos ( math . radians ( theta ) ) ) ) NEW_LINE q = a * math . sqrt ( 2 - ( 2 * math . cos ( math . radians ( theta ) ) ) ) NEW_LINE return [ p , q ] NEW_LINE DEDENT
Hyp: 
def Length_Diagonals ( A , theta ) : NEW_LINE INDENT A = 6 NEW_LINE theta = 45 NEW_LINE ans = Length_Diagonals ( A , theta ) NEW_LINE print ( " { 0 : . 2f } " . format ( ans [ 0 ] ) , ans [ 1 ] ) NEW_LINE DEDENT

BLEU: 12.73
Edit Sim: 122


Src: 
int maxSumWO3Consec ( int A [ ] , int N ) { if ( N == 1 ) return A [ 0 ] ; if ( N == 2 ) return A [ 0 ] + A [ 1 ] ; int third = A [ 0 ] ; int second = third + A [ 1 ] ; int first = Math . max ( second , A [ 1 ] + A [ 2 ] ) ; int sum = Math . max ( Math . max ( third , second ) , first ) ; for ( int i = 3 ; i < N ; i ++ ) { sum = Math . max ( Math . max ( first , second + A [ i ] ) , third + A [ i ] + A [ i - 1 ] ) ; third = second ; second = first ; first = sum ; } return sum ; }
Ref: 
def maxSumWO3Consec ( A , N ) : NEW_LINE INDENT if ( N == 1 ) : NEW_LINE INDENT return A [ 0 ] NEW_LINE DEDENT if ( N == 2 ) : NEW_LINE INDENT return A [ 0 ] + A [ 1 ] NEW_LINE DEDENT third = A [ 0 ] NEW_LINE second = third + A [ 1 ] NEW_LINE first = max ( second , A [ 1 ] + A [ 2 ] ) NEW_LINE sum = max ( max ( third , second ) , first ) NEW_LINE for i in range ( 3 , N , 1 ) : NEW_LINE INDENT sum = max ( max ( first , second + A [ i ] ) , third + A [ i ] + A [ i - 1 ] ) NEW_LINE third = second NEW_LINE second = first NEW_LINE first = sum NEW_LINE DEDENT return sum NEW_LINE DEDENT
Hyp: 
def maxSumWO3Consec ( A , N ) : NEW_LINE INDENT if ( N == 1 ) : NEW_LINE INDENT return A [ 0 ] NEW_LINE DEDENT if ( N == 2 ) : NEW_LINE INDENT return A [ 0 ] + A [ 1 ] NEW_LINE DEDENT third = A [ 0 ] NEW_LINE second = third + A [ 1 ] NEW_LINE first = max ( second , A [ 1 ] + A [ 2 ] ) NEW_LINE sum = max ( max ( third , second ) , first ) NEW_LINE for i in range ( 3 , N ) : NEW_LINE INDENT sum = max ( max ( first , second + A [ i ] ) , third + A [ i ] + A [ i - 1 ] ) NEW_LINE third = second NEW_LINE second = first NEW_LINE first = sum NEW_LINE DEDENT return sum NEW_LINE DEDENT

BLEU: 97.74
Edit Sim: 4


Src: 
int countPairsWithProdK ( int arr [ ] , int n , int k ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] * arr [ j ] == k ) count ++ ; } return count ; }
Ref: 
def countPairsWithProdK ( arr , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] * arr [ j ] == k ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
Hyp: 
def countPairsWithProdK ( arr , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] * arr [ j ] == k ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int nthTerm ( int n ) { return 3 * ( int ) Math . pow ( n , 2 ) + 2 * n - 5 ; }
Ref: 
def nthTerm ( n ) : NEW_LINE INDENT return 3 * pow ( n , 2 ) + 2 * n - 5 NEW_LINE DEDENT
Hyp: 
def nthTerm ( n ) : NEW_LINE INDENT return 3 * pow ( n , 2 ) + 2 * n - 5 NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int Maxlen ( int arr [ ] , int n ) { int ans = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) count = 0 ; else count ++ ; ans = Math . max ( ans , count ) ; } return ans ; }
Ref: 
def Maxlen ( a , n ) : NEW_LINE INDENT ans = 0 NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] % 2 == 0 : NEW_LINE INDENT count = 0 NEW_LINE DEDENT else : NEW_LINE INDENT count += 1 NEW_LINE DEDENT ans = max ( ans , count ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
Hyp: 
def Maxlen ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT count = 0 NEW_LINE DEDENT else : NEW_LINE INDENT count += 1 NEW_LINE DEDENT ans = max ( ans , count ) NEW_LINE DEDENT return ans NEW_LINE DEDENT

BLEU: 82.86
Edit Sim: 12


Src: 
void segregateElements ( int arr [ ] , int n ) { int temp [ ] = new int [ n ] ; int j = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] >= 0 ) temp [ j ++ ] = arr [ i ] ; if ( j == n j == 0 ) return ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] < 0 ) temp [ j ++ ] = arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = temp [ i ] ; }
Ref: 
def segregateElements ( arr , n ) : NEW_LINE INDENT temp = [ 0 for k in range ( n ) ] NEW_LINE j = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] >= 0 ) : NEW_LINE INDENT temp [ j ] = arr [ i ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT if ( j == n or j == 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] < 0 ) : NEW_LINE INDENT temp [ j ] = arr [ i ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT for k in range ( n ) : NEW_LINE INDENT arr [ k ] = temp [ k ] NEW_LINE DEDENT DEDENT arr = [ 1 , - 1 , - 3 , - 2 , 7 , 5 , 11 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE segregateElements ( arr , n ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT print arr [ i ] , NEW_LINE DEDENT
Hyp: 
def segregateElements ( arr , n ) : NEW_LINE INDENT temp = [ 0 ] * n NEW_LINE j = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] >= 0 ) : NEW_LINE INDENT temp [ j ] = arr [ i ] NEW_LINE DEDENT if ( j == n or j == 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] < 0 ) : NEW_LINE INDENT temp [ j ] = arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = temp [ i ] NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = temp [ i ] NEW_LINE DEDENT DEDENT

BLEU: 61.41
Edit Sim: 200


Src: 
boolean isPossible ( int l , int m , int x , int y ) { if ( l * m == x + y ) return true ; return false ; }
Ref: 
def isPossible ( l , m , x , y ) : NEW_LINE INDENT if ( l * m == x + y ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT
Hyp: 
def isPossible ( l , m , x , y ) : NEW_LINE INDENT if ( l * m == x + y ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT l = 3 ; m = 2 ; NEW_LINE x = 1 ; y = 5 ; NEW_LINE if ( isPossible ( l , m , x , y ) ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT

BLEU: 39.44
Edit Sim: 198


Src: 
int kthgroupsum ( int k ) { int cur = ( k * ( k - 1 ) ) + 1 ; int sum = 0 ; while ( k -- > 0 ) { sum += cur ; cur += 2 ; } return sum ; }
Ref: 
def kthgroupsum ( k ) : NEW_LINE INDENT cur = int ( ( k * ( k - 1 ) ) + 1 ) NEW_LINE sum = 0 NEW_LINE while k : NEW_LINE INDENT sum += cur NEW_LINE cur += 2 NEW_LINE k = k - 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT
Hyp: 
def kthgroupsum ( k ) : NEW_LINE INDENT cur = ( k * ( k - 1 ) ) + 1 NEW_LINE sum = 0 NEW_LINE while ( k ) : NEW_LINE INDENT sum += cur NEW_LINE cur += 2 NEW_LINE DEDENT return sum NEW_LINE DEDENT

BLEU: 71.21
Edit Sim: 31


Src: 
int minSteps ( int m , int n ) { if ( n == m ) return 0 ; if ( m > n ) return inf ; int min_cost = inf ; for ( int i = 2 ; i < m ; i += 2 ) { if ( m % i == 0 ) { min_cost = Math . min ( min_cost , m / i + minSteps ( m + i , n ) ) ; } } return min_cost ; }
Ref: 
def minSteps ( m , n ) : NEW_LINE INDENT if ( n == m ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( m > n ) : NEW_LINE INDENT return inf NEW_LINE DEDENT min_cost = inf NEW_LINE for i in range ( 2 , m , 2 ) : NEW_LINE INDENT if ( m % i == 0 ) : NEW_LINE INDENT min_cost = min ( min_cost , m / i + minSteps ( m + i , n ) ) NEW_LINE DEDENT DEDENT return min_cost NEW_LINE DEDENT
Hyp: 
def minSteps ( m , n ) : NEW_LINE INDENT if ( n == m ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( m > n ) : NEW_LINE INDENT return inf NEW_LINE DEDENT min_cost = inf NEW_LINE for i in range ( 2 , m , 2 ) : NEW_LINE INDENT if ( m % i == 0 ) : NEW_LINE INDENT min_cost = min ( min_cost , m // i + minSteps ( m + i , n ) ) NEW_LINE DEDENT DEDENT return min_cost NEW_LINE DEDENT

BLEU: 97.21
Edit Sim: 1


Src: 
int winner ( int a [ ] , int n , int k ) { if ( k >= n - 1 ) return n ; int best = 0 , times = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > best ) { best = a [ i ] ; if ( i == 1 ) times = 1 ; } else times += 1 ; if ( times >= k ) return best ; } return best ; }
Ref: 
def winner ( a , n , k ) : NEW_LINE INDENT if k >= n - 1 : NEW_LINE INDENT return n NEW_LINE DEDENT best = 0 NEW_LINE times = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] > best : NEW_LINE INDENT best = a [ i ] NEW_LINE if i == True : NEW_LINE INDENT times = 1 NEW_LINE DEDENT DEDENT else : NEW_LINE if times >= k : NEW_LINE INDENT return best NEW_LINE DEDENT DEDENT return best NEW_LINE DEDENT
Hyp: 
def winner ( a , n , k ) : NEW_LINE INDENT if ( k >= n - 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT best = 0 NEW_LINE times = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] > best ) : NEW_LINE INDENT best = a [ i ] NEW_LINE if ( i == 1 ) : NEW_LINE INDENT times = 1 NEW_LINE DEDENT else : NEW_LINE INDENT times += 1 NEW_LINE DEDENT if ( times >= k ) : NEW_LINE INDENT return best NEW_LINE DEDENT DEDENT return best NEW_LINE DEDENT

BLEU: 72.43
Edit Sim: 50


Src: 
int lastCoordinate ( int n , int a , int b ) { return ( ( n + 1 ) / 2 ) * a - ( n / 2 ) * b ; }
Ref: 
def lastCoordinate ( n , a , b ) : NEW_LINE INDENT return ( ( ( n + 1 ) // 2 ) * a - ( n // 2 ) * b ) NEW_LINE DEDENT
Hyp: 
def lastCoordinate ( n , a , b ) : NEW_LINE INDENT return ( ( n + 1 ) / 2 ) * a - ( n / 2 ) * b NEW_LINE DEDENT

BLEU: 74.98
Edit Sim: 6


Src: 
int Icositetragonal_num ( int n ) { return ( 22 * n * n - 20 * n ) / 2 ; }
Ref: 
def Icositetragonal_num ( n ) : NEW_LINE INDENT return ( 22 * n * n - 20 * n ) / 2 NEW_LINE DEDENT
Hyp: 
def Icositetragonal_num ( n ) : NEW_LINE INDENT return ( 22 * n * n - 20 * n ) // 2 NEW_LINE DEDENT

BLEU: 88.95
Edit Sim: 1


Src: 
int lcs ( String X , String Y ) { int m = X . length ( ) , n = Y . length ( ) ; int L [ ] [ ] = new int [ 2 ] [ n + 1 ] ; int bi = 0 ; for ( int i = 0 ; i <= m ; i ++ ) { bi = i & 1 ; for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) L [ bi ] [ j ] = 0 ; else if ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) ) L [ bi ] [ j ] = L [ 1 - bi ] [ j - 1 ] + 1 ; else L [ bi ] [ j ] = Math . max ( L [ 1 - bi ] [ j ] , L [ bi ] [ j - 1 ] ) ; } } return L [ bi ] [ n ] ; }
Ref: 
def lcs ( X , Y ) : NEW_LINE INDENT m = len ( X ) NEW_LINE n = len ( Y ) NEW_LINE L = [ [ 0 for i in range ( n + 1 ) ] for j in range ( 2 ) ] NEW_LINE bi = bool NEW_LINE for i in range ( m ) : NEW_LINE INDENT bi = i & 1 NEW_LINE for j in range ( n + 1 ) : NEW_LINE INDENT if ( i == 0 or j == 0 ) : NEW_LINE INDENT L [ bi ] [ j ] = 0 NEW_LINE DEDENT elif ( X [ i ] == Y [ j - 1 ] ) : NEW_LINE INDENT L [ bi ] [ j ] = L [ 1 - bi ] [ j - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT L [ bi ] [ j ] = max ( L [ 1 - bi ] [ j ] , L [ bi ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return L [ bi ] [ n ] NEW_LINE DEDENT
Hyp: 
def lcs ( X , Y ) : NEW_LINE INDENT m , n = len ( X ) , len ( Y ) NEW_LINE L = [ [ 0 for i in range ( n + 1 ) ] for j in range ( 2 ) ] NEW_LINE bi = 0 NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT bi = i & 1 NEW_LINE for j in range ( n + 1 ) : NEW_LINE INDENT if ( i == 0 or j == 0 ) : NEW_LINE INDENT L [ bi ] [ j ] = 0 NEW_LINE DEDENT elif ( X [ i - 1 ] == Y [ j - 1 ] ) : NEW_LINE INDENT L [ bi ] [ j ] = L [ 1 - bi ] [ j - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT L [ bi ] [ j ] = max ( L [ 1 - bi ] [ j ] , L [ bi ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return L [ bi ] [ n ] NEW_LINE DEDENT

BLEU: 92.52
Edit Sim: 28


Src: 
boolean isSpiltPossible ( int n , int a [ ] ) { int sum = 0 , c1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; if ( a [ i ] == 1 ) { c1 ++ ; } } if ( sum % 2 != 0 ) return false ; if ( ( sum / 2 ) % 2 == 0 ) return true ; if ( c1 > 0 ) return true ; else return false ; }
Ref: 
def isSpiltPossible ( n , a ) : NEW_LINE INDENT Sum = 0 NEW_LINE c1 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT Sum += a [ i ] NEW_LINE if ( a [ i ] == 1 ) : NEW_LINE INDENT c1 += 1 NEW_LINE DEDENT DEDENT if ( Sum % 2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( ( Sum // 2 ) % 2 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( c1 > 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT n = 3 NEW_LINE a = [ 1 , 1 , 2 ] NEW_LINE if ( isSpiltPossible ( n , a ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
Hyp: 
def isSpiltPossible ( n , a ) : NEW_LINE INDENT sum , c1 = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += a [ i ] NEW_LINE if ( a [ i ] == 1 ) : NEW_LINE INDENT c1 += 1 NEW_LINE DEDENT DEDENT if ( sum % 2 != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( ( sum // 2 ) % 2 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( c1 > 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT

BLEU: 56.56
Edit Sim: 206


Src: 
boolean checkcircle ( int r , int R , int r1 , int x1 , int y1 ) { int dis = ( int ) Math . sqrt ( x1 * x1 + y1 * y1 ) ; return ( dis - r1 >= R && dis + r1 <= r ) ; }
Ref: 
def checkcircle ( r , R , r1 , x1 , y1 ) : NEW_LINE INDENT dis = int ( math . sqrt ( x1 * x1 + y1 * y1 ) ) NEW_LINE return ( dis - r1 >= R and dis + r1 <= r ) NEW_LINE DEDENT r = 8 ; R = 4 ; r1 = 2 ; x1 = 6 ; y1 = 0 NEW_LINE if ( checkcircle ( r , R , r1 , x1 , y1 ) ) : NEW_LINE INDENT print ( " yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " no " ) NEW_LINE DEDENT
Hyp: 
def checkcircle ( r , R , r1 , x1 , y1 ) : NEW_LINE INDENT dis = math . sqrt ( x1 * x1 + y1 * y1 ) NEW_LINE return ( dis - r1 >= R and dis + r1 <= r ) NEW_LINE DEDENT

BLEU: 25.94
Edit Sim: 210


Src: 
boolean isCubeSum ( int n ) { for ( int i = 1 ; i * i * i <= n ; i ++ ) { if ( i * i * i + ( i + 1 ) * ( i + 1 ) * ( i + 1 ) == n ) return true ; } return false ; }
Ref: 
def isCubeSum ( n ) : NEW_LINE INDENT for i in range ( 1 , int ( pow ( n , 1 / 3 ) ) + 1 ) : NEW_LINE INDENT if ( i * i * i + ( i + 1 ) * ( i + 1 ) * ( i + 1 ) == n ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT DEDENT return False ; NEW_LINE DEDENT
Hyp: 
def isCubeSum ( n ) : NEW_LINE INDENT i = 1 NEW_LINE while i * i * i <= n : NEW_LINE INDENT if ( i * i * i + ( i + 1 ) * ( i + 1 ) * ( i + 1 ) == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return False NEW_LINE DEDENT n = 25 NEW_LINE if ( isCubeSum ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT

BLEU: 47.82
Edit Sim: 203


Src: 
int speedOfTrain ( float X , float Y ) { float Speed ; Speed = 1188 * ( ( X - Y ) / Y ) ; return ( int ) Speed ; }
Ref: 
def speedOfTrain ( X , Y ) : NEW_LINE INDENT Speed = 0 NEW_LINE Speed = 1188 * ( ( X - Y ) / Y ) NEW_LINE return Speed NEW_LINE DEDENT
Hyp: 
def speedOfTrain ( X , Y ) : NEW_LINE INDENT Speed = 1188 * ( ( X - Y ) / Y ) NEW_LINE return int ( Speed ) NEW_LINE DEDENT

BLEU: 79.8
Edit Sim: 27


Src: 
void halfsquare ( int n , int x , int y ) { int half = n / 2 ; if ( ( half == x half == x - 1 ) && ( half == y half == y - 1 ) ) System . out . println ( " NO " ) ; else System . out . println ( " YES " ) ; }
Ref: 
def halfsquare ( n , x , y ) : NEW_LINE INDENT half = n // 2 NEW_LINE if ( ( half == x or half == x - 1 ) and ( half == y or half == y - 1 ) ) : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT DEDENT
Hyp: 
def halfsquare ( n , x , y ) : NEW_LINE INDENT half = n // 2 NEW_LINE if ( ( half == x or half == x - 1 ) and ( half == y or half == y - 1 ) ) : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
void isEqualFactors ( int N ) { if ( ( N % 2 == 0 ) && ( N % 4 != 0 ) ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; }
Ref: 
def isEqualFactors ( N ) : NEW_LINE INDENT if ( ( N % 2 == 0 ) and ( N % 4 != 0 ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
Hyp: 
def isEqualFactors ( N ) : NEW_LINE INDENT if ( ( N % 2 == 0 ) and ( N % 4 != 0 ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int countSubStr ( String str , int n ) { int len = str . length ( ) ; return ( len - n + 1 ) ; }
Ref: 
def countSubStr ( string , n ) : NEW_LINE INDENT length = len ( string ) ; NEW_LINE return ( length - n + 1 ) ; NEW_LINE DEDENT
Hyp: 
def countSubStr ( string , n ) : NEW_LINE INDENT l = len ( string ) NEW_LINE return ( l - n + 1 ) NEW_LINE DEDENT

BLEU: 63.11
Edit Sim: 14


Src: 
int sumOfProd ( int arr [ ] , int N ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; } return sum * sum ; }
Ref: 
def sumOfProd ( arr , N ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT return sum * sum NEW_LINE DEDENT
Hyp: 
def sumOfProd ( arr , N ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT return sum * sum NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int pad ( int n ) { padv [ 0 ] = padv [ 1 ] = padv [ 2 ] = 1 ; for ( int i = 3 ; i <= n ; i ++ ) { padv [ i ] = padv [ i - 2 ] + padv [ i - 3 ] ; } return padv [ n - 1 ] ; }
Ref: 
def pad ( n ) : NEW_LINE INDENT pPrevPrev , pPrev , pCurr , pNext = 1 , 1 , 1 , 1 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT pNext = pPrevPrev + pPrev NEW_LINE pPrevPrev = pPrev NEW_LINE pPrev = pCurr NEW_LINE pCurr = pNext NEW_LINE DEDENT return pNext ; NEW_LINE DEDENT
Hyp: 
def pad ( n ) : NEW_LINE INDENT padv = [ 0 ] * n NEW_LINE padv [ 1 ] = padv [ 2 ] = 1 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT padv [ i ] = padv [ i - 2 ] + padv [ i - 3 ] NEW_LINE DEDENT return padv [ n - 1 ] NEW_LINE DEDENT

BLEU: 36.3
Edit Sim: 128


Src: 
void minCost ( int arr [ ] , int n ) { if ( n < 3 ) { System . out . println ( arr [ 0 ] ) ; return ; } int dp [ ] = new int [ n ] ; dp [ 0 ] = arr [ 0 ] ; dp [ 1 ] = dp [ 0 ] + arr [ 1 ] + arr [ 2 ] ; for ( int i = 2 ; i < n - 1 ; i ++ ) dp [ i ] = Math . min ( dp [ i - 2 ] + arr [ i ] , dp [ i - 1 ] + arr [ i ] + arr [ i + 1 ] ) ; dp [ n - 1 ] = Math . min ( dp [ n - 2 ] , dp [ n - 3 ] + arr [ n - 1 ] ) ; System . out . println ( dp [ n - 1 ] ) ; }
Ref: 
def minCost ( arr , n ) : NEW_LINE INDENT if ( n < 3 ) : NEW_LINE INDENT print ( arr [ 0 ] ) NEW_LINE return NEW_LINE DEDENT dp = [ 0 ] * n NEW_LINE dp [ 0 ] = arr [ 0 ] NEW_LINE dp [ 1 ] = dp [ 0 ] + arr [ 1 ] + arr [ 2 ] NEW_LINE for i in range ( 2 , n - 1 ) : NEW_LINE INDENT dp [ i ] = min ( dp [ i - 2 ] + arr [ i ] , dp [ i - 1 ] + arr [ i ] + arr [ i + 1 ] ) NEW_LINE DEDENT dp [ n - 1 ] = min ( dp [ n - 2 ] , dp [ n - 3 ] + arr [ n - 1 ] ) NEW_LINE print ( dp [ n - 1 ] ) NEW_LINE DEDENT
Hyp: 
def minCost ( arr , n ) : NEW_LINE INDENT if ( n < 3 ) : NEW_LINE INDENT print ( arr [ 0 ] ) NEW_LINE return NEW_LINE DEDENT dp = [ 0 ] * n NEW_LINE dp [ 0 ] = arr [ 0 ] NEW_LINE dp [ 1 ] = dp [ 0 ] + arr [ 1 ] + arr [ 2 ] NEW_LINE for i in range ( 2 , n - 1 ) : NEW_LINE INDENT dp [ i ] = min ( dp [ i - 2 ] + arr [ i ] , dp [ i - 1 ] + arr [ i ] + arr [ i + 1 ] ) NEW_LINE DEDENT dp [ n - 1 ] = min ( dp [ n - 2 ] , dp [ n - 3 ] + arr [ n - 1 ] ) NEW_LINE print ( dp [ n - 1 ] ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
void findRemainder ( int n ) { int l = n % 10 ; while ( n >= 10 ) n /= 10 ; int f = n ; int remainder = f % l ; System . out . println ( remainder ) ; }
Ref: 
def findRemainder ( n ) : NEW_LINE INDENT l = n % 10 NEW_LINE while ( n >= 10 ) : NEW_LINE INDENT n //= 10 NEW_LINE DEDENT f = n NEW_LINE remainder = f % l NEW_LINE print ( remainder ) NEW_LINE DEDENT
Hyp: 
def findRemainder ( n ) : NEW_LINE INDENT l = n % 10 NEW_LINE while n >= 10 : NEW_LINE INDENT n //= 10 NEW_LINE DEDENT f = n NEW_LINE remainder = f % l NEW_LINE print ( remainder ) NEW_LINE DEDENT

BLEU: 88.15
Edit Sim: 4


Src: 
int findPeak ( int arr [ ] , int n ) { if ( n == 1 ) return 0 ; if ( arr [ 0 ] >= arr [ 1 ] ) return 0 ; if ( arr [ n - 1 ] >= arr [ n - 2 ] ) return n - 1 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( arr [ i ] >= arr [ i - 1 ] && arr [ i ] >= arr [ i + 1 ] ) return i ; } return 0 ; }
Ref: 
def findPeak ( arr , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE return 0 NEW_LINE if ( arr [ 0 ] >= arr [ 1 ] ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( arr [ n - 1 ] >= arr [ n - 2 ] ) : NEW_LINE INDENT return n - 1 NEW_LINE DEDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if ( arr [ i ] >= arr [ i - 1 ] and arr [ i ] >= arr [ i + 1 ] ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT DEDENT
Hyp: 
def findPeak ( arr , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( arr [ 0 ] >= arr [ 1 ] ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( arr [ n - 1 ] >= arr [ n - 2 ] ) : NEW_LINE INDENT return n - 1 NEW_LINE DEDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if ( arr [ i ] >= arr [ i - 1 ] and arr [ i ] >= arr [ i + 1 ] ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT

BLEU: 92.57
Edit Sim: 32


Src: 
int minDiff ( int arr [ ] , int n , int k ) { int result = Integer . MAX_VALUE ; Arrays . sort ( arr ) ; for ( int i = 0 ; i <= n - k ; i ++ ) result = Math . min ( result , arr [ i + k - 1 ] - arr [ i ] ) ; return result ; }
Ref: 
def minDiff ( arr , n , k ) : NEW_LINE INDENT result = + 2147483647 NEW_LINE arr . sort ( ) NEW_LINE for i in range ( n - k + 1 ) : NEW_LINE INDENT result = int ( min ( result , arr [ i + k - 1 ] - arr [ i ] ) ) NEW_LINE DEDENT return result NEW_LINE DEDENT
Hyp: 
def minDiff ( arr , n , k ) : NEW_LINE INDENT result = sys . maxsize NEW_LINE arr . sort ( ) NEW_LINE for i in range ( n - k + 1 ) : NEW_LINE INDENT result = min ( result , arr [ i + k - 1 ] - arr [ i ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT

BLEU: 86.4
Edit Sim: 21


Src: 
int centeredoctagonalNumber ( int n ) { return 4 * n * ( n - 1 ) + 1 ; }
Ref: 
def cen_octagonalnum ( n ) : NEW_LINE INDENT return ( 4 * n * n - 4 * n + 1 ) NEW_LINE DEDENT
Hyp: 
def centeredoctagonalNumber ( n ) : NEW_LINE INDENT return 4 * n * ( n - 1 ) + 1 NEW_LINE DEDENT

BLEU: 46.35
Edit Sim: 18


Src: 
float maxDivision ( Integer arr [ ] , int n ) { Arrays . sort ( arr , Collections . reverseOrder ( ) ) ; float mxdiv = arr [ 1 ] ; for ( int i = 2 ; i < n ; ++ i ) mxdiv = mxdiv / arr [ i ] ; return arr [ 0 ] / mxdiv ; }
Ref: 
def maxDivision ( arr , n ) : NEW_LINE INDENT arr . sort ( reverse = True ) NEW_LINE mxdiv = arr [ 1 ] NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT mxdiv = mxdiv / arr [ i ] NEW_LINE DEDENT return arr [ 0 ] / mxdiv NEW_LINE DEDENT
Hyp: 
def maxDivision ( arr , n ) : NEW_LINE INDENT arr . sort ( reverse = True ) NEW_LINE mxdiv = arr [ 1 ] NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT mxdiv = mxdiv // arr [ i ] NEW_LINE DEDENT return arr [ 0 ] // mxdiv NEW_LINE DEDENT

BLEU: 90.97
Edit Sim: 2


Src: 
String getString ( int N ) { String ans = " " ; while ( N >= 26 ) { ans += ' z ' ; N -= 26 ; } ans += ( char ) ( N + ' a ' - 1 ) ; return ans ; }
Ref: 
def getString ( N ) : NEW_LINE INDENT ans = " " NEW_LINE while ( N >= 26 ) : NEW_LINE INDENT ans += ' z ' NEW_LINE N -= 26 NEW_LINE DEDENT ans += chr ( N + ord ( ' a ' ) - 1 ) NEW_LINE return ans NEW_LINE DEDENT
Hyp: 
def getString ( N ) : NEW_LINE INDENT ans = " " NEW_LINE while ( N >= 26 ) : NEW_LINE INDENT ans += ' z ' NEW_LINE N -= 26 NEW_LINE DEDENT ans += chr ( N + ' a ' - 1 ) NEW_LINE return ans NEW_LINE DEDENT

BLEU: 88.26
Edit Sim: 8


Src: 
boolean aredisjoint ( int set1 [ ] , int set2 [ ] ) { int i = 0 , j = 0 ; Arrays . sort ( set1 ) ; Arrays . sort ( set2 ) ; while ( i < set1 . length && j < set2 . length ) { if ( set1 [ i ] < set2 [ j ] ) i ++ ; else if ( set1 [ i ] > set2 [ j ] ) j ++ ; else return false ; } return true ; }
Ref: 
def areDisjoint ( set1 , set2 , m , n ) : NEW_LINE INDENT set1 . sort ( ) NEW_LINE set2 . sort ( ) NEW_LINE i = 0 ; j = 0 NEW_LINE while ( i < m and j < n ) : NEW_LINE INDENT if ( set1 [ i ] < set2 [ j ] ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT elif ( set2 [ j ] < set1 [ i ] ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
Hyp: 
def aredisjoint ( set1 , set2 ) : NEW_LINE INDENT i = 0 ; j = 0 ; NEW_LINE arr = sorted ( set1 ) NEW_LINE while ( i < len ( set1 ) and j < len ( set2 ) ) : NEW_LINE INDENT if ( set1 [ i ] < set2 [ j ] ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT elif ( set1 [ i ] > set2 [ j ] ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT

BLEU: 68.95
Edit Sim: 74


Src: 
int getCount ( int arr [ ] , int N ) { int count = 0 ; if ( N < 3 ) return 0 ; for ( int b = 0 ; b < N ; b ++ ) { for ( int a = 0 ; a < N ; a ++ ) { if ( a == b ) continue ; for ( int c = 0 ; c < N ; c ++ ) { if ( c == a c == b ) continue ; int d = arr [ b ] * arr [ b ] / 4 ; if ( arr [ a ] * arr <= d ) count ++ ; } } } return count ; }
Ref: 
def getcount ( arr , N ) : NEW_LINE INDENT count = 0 NEW_LINE if ( N < 3 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT for b in range ( 0 , N ) : NEW_LINE INDENT for a in range ( 0 , N ) : NEW_LINE INDENT if ( a == b ) : NEW_LINE INDENT continue NEW_LINE DEDENT for c in range ( 0 , N ) : NEW_LINE INDENT if ( c == a or c == b ) : NEW_LINE INDENT continue NEW_LINE DEDENT d = arr [ b ] * arr [ b ] // 4 NEW_LINE if ( arr [ a ] * arr ) <= d : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
Hyp: 
def getCount ( arr , N ) : NEW_LINE INDENT count = 0 NEW_LINE if ( N < 3 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT for b in range ( N ) : NEW_LINE INDENT for a in range ( N ) : NEW_LINE INDENT if ( a == b ) : NEW_LINE INDENT continue NEW_LINE DEDENT for c in range ( N ) : NEW_LINE INDENT if ( c == a or c == b ) : NEW_LINE INDENT continue NEW_LINE DEDENT d = arr [ b ] * arr [ b ] // 4 NEW_LINE if ( arr [ a ] * arr <= d ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return count NEW_LINE DEDENT

BLEU: 87.69
Edit Sim: 17


Src: 
void countOccurrences ( String S , String X , String Y ) { int count = 0 ; int N = S . length ( ) , A = X . length ( ) ; int B = Y . length ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( S . substring ( i , Math . min ( N , i + B ) ) . equals ( Y ) ) count ++ ; if ( S . substring ( i , Math . min ( N , i + A ) ) . equals ( X ) ) System . out . print ( count + " ▁ " ) ; } }
Ref: 
def countOccurrences ( S , X , Y ) : NEW_LINE INDENT count = 0 NEW_LINE N = len ( S ) NEW_LINE A = len ( X ) NEW_LINE B = len ( Y ) NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT if ( S [ i : i + B ] == Y ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( S [ i : i + A ] == X ) : NEW_LINE INDENT print ( count , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
Hyp: 
def countOccurrences ( S , X , Y ) : NEW_LINE INDENT count = 0 NEW_LINE N = len ( S ) NEW_LINE A = len ( X ) NEW_LINE B = len ( Y ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( S [ i : min ( N , i + B ) ] == Y ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT if ( S [ i : min ( N , i + A ) ] == X ) : NEW_LINE INDENT print ( count , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT

BLEU: 79.79
Edit Sim: 37


Src: 
int summation ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i % 2 == 1 ) sum += ( i * i ) ; else sum -= ( i * i ) ; } return sum ; }
Ref: 
def summation ( n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( i % 2 == 1 ) : NEW_LINE INDENT sum += ( i * i ) ; NEW_LINE DEDENT else : NEW_LINE INDENT sum -= ( i * i ) ; NEW_LINE DEDENT DEDENT return sum ; NEW_LINE DEDENT
Hyp: 
def summation ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( i % 2 == 1 ) : NEW_LINE INDENT sum += ( i * i ) NEW_LINE DEDENT else : NEW_LINE INDENT sum -= ( i * i ) NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT

BLEU: 85.09
Edit Sim: 8


Src: 
void minCost ( int costs [ ] [ ] , int N ) { if ( N == 0 ) return ; int dp [ ] [ ] = new int [ N ] [ 3 ] ; dp [ 0 ] [ 0 ] = costs [ 0 ] [ 0 ] ; dp [ 0 ] [ 1 ] = costs [ 0 ] [ 1 ] ; dp [ 0 ] [ 2 ] = costs [ 0 ] [ 2 ] ; for ( int i = 1 ; i < N ; i ++ ) { dp [ i ] [ 0 ] = Math . min ( dp [ i - 1 ] [ 1 ] , dp [ i - 1 ] [ 2 ] ) + costs [ i ] [ 0 ] ; dp [ i ] [ 1 ] = Math . min ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 2 ] ) + costs [ i ] [ 1 ] ; dp [ i ] [ 2 ] = Math . min ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] ) + costs [ i ] [ 2 ] ; } System . out . println ( Math . min ( dp [ N - 1 ] [ 0 ] , Math . min ( dp [ N - 1 ] [ 1 ] , dp [ N - 1 ] [ 2 ] ) ) ) ; }
Ref: 
def minCost ( costs , N ) : NEW_LINE INDENT if ( N == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT dp = [ [ 0 for i in range ( 3 ) ] for j in range ( 3 ) ] NEW_LINE dp [ 0 ] [ 0 ] = costs [ 0 ] [ 0 ] NEW_LINE dp [ 0 ] [ 1 ] = costs [ 0 ] [ 1 ] NEW_LINE dp [ 0 ] [ 2 ] = costs [ 0 ] [ 2 ] NEW_LINE for i in range ( 1 , N , 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = min ( dp [ i - 1 ] [ 1 ] , dp [ i - 1 ] [ 2 ] ) + costs [ i ] [ 0 ] NEW_LINE dp [ i ] [ 1 ] = min ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 2 ] ) + costs [ i ] [ 1 ] NEW_LINE dp [ i ] [ 2 ] = min ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] ) + costs [ i ] [ 2 ] NEW_LINE DEDENT print ( min ( dp [ N - 1 ] [ 0 ] , min ( dp [ N - 1 ] [ 1 ] , dp [ N - 1 ] [ 2 ] ) ) ) NEW_LINE DEDENT
Hyp: 
def minCost ( costs , N ) : NEW_LINE INDENT if ( N == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT dp = [ [ 0 for i in range ( 3 ) ] for j in range ( N ) ] NEW_LINE dp [ 0 ] [ 0 ] = costs [ 0 ] [ 0 ] NEW_LINE dp [ 0 ] [ 1 ] = costs [ 0 ] [ 1 ] NEW_LINE dp [ 0 ] [ 2 ] = costs [ 0 ] [ 2 ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT dp [ i ] [ 0 ] = min ( dp [ i - 1 ] [ 1 ] , dp [ i - 1 ] [ 2 ] ) + costs [ i ] [ 0 ] NEW_LINE dp [ i ] [ 1 ] = min ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 2 ] ) + costs [ i ] [ 1 ] NEW_LINE dp [ i ] [ 2 ] = min ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] ) + costs [ i ] [ 2 ] NEW_LINE DEDENT print ( min ( dp [ N - 1 ] [ 0 ] , min ( dp [ N - 1 ] [ 1 ] , dp [ N - 1 ] [ 2 ] ) ) ) NEW_LINE DEDENT

BLEU: 97.72
Edit Sim: 5


Src: 
int minvalue_y ( int x ) { int n = ( int ) Math . sqrt ( x ) ; if ( n * n == x ) return x + 1 ; return ( int ) Math . pow ( n + 1 , 2 ) ; }
Ref: 
def minvalue_y ( x ) : NEW_LINE INDENT n = int ( pow ( x , 1 / 2 ) ) NEW_LINE if ( n * n == x ) : NEW_LINE INDENT return x + 1 NEW_LINE DEDENT return ( pow ( n + 1 , 2 ) ) NEW_LINE DEDENT
Hyp: 
def minvalue_y ( x ) : NEW_LINE INDENT n = int ( math . sqrt ( x ) ) NEW_LINE if ( n * n == x ) : NEW_LINE INDENT return x + 1 NEW_LINE DEDENT return pow ( n + 1 , 2 ) NEW_LINE DEDENT

BLEU: 75.93
Edit Sim: 16


Src: 
boolean findTriplet ( int a1 [ ] , int a2 [ ] , int a3 [ ] , int n1 , int n2 , int n3 , int sum ) { for ( int i = 0 ; i < n1 ; i ++ ) for ( int j = 0 ; j < n2 ; j ++ ) for ( int k = 0 ; k < n3 ; k ++ ) if ( a1 [ i ] + a2 [ j ] + a3 [ k ] == sum ) return true ; return false ; }
Ref: 
def findTriplet ( a1 , a2 , a3 , n1 , n2 , n3 , sum ) : NEW_LINE INDENT for i in range ( 0 , n1 ) : NEW_LINE INDENT for j in range ( 0 , n2 ) : NEW_LINE INDENT for k in range ( 0 , n3 ) : NEW_LINE INDENT if ( a1 [ i ] + a2 [ j ] + a3 [ k ] == sum ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT DEDENT return False NEW_LINE DEDENT
Hyp: 
def findTriplet ( a1 , a2 , a3 , n1 , n2 , n3 , sum ) : NEW_LINE INDENT for i in range ( n1 ) : NEW_LINE INDENT for j in range ( n2 ) : NEW_LINE INDENT for k in range ( n3 ) : NEW_LINE INDENT if ( a1 [ i ] + a2 [ j ] + a3 [ k ] == sum ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT

BLEU: 86.61
Edit Sim: 19


Src: 
int cntSubSeq ( int arr [ ] , int n ) { int pos_count = 0 ; int neg_count = 0 ; int result ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 ) pos_count ++ ; if ( arr [ i ] < 0 ) neg_count ++ ; } result = ( int ) Math . pow ( 2 , pos_count ) ; if ( neg_count > 0 ) result *= Math . pow ( 2 , neg_count - 1 ) ; else result = 0 ; return result ; }
Ref: 
def cntSubSeq ( arr , n ) : NEW_LINE INDENT pos_count = 0 ; NEW_LINE neg_count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT pos_count += 1 NEW_LINE DEDENT if ( arr [ i ] < 0 ) : NEW_LINE INDENT neg_count += 1 NEW_LINE DEDENT DEDENT result = int ( math . pow ( 2 , pos_count ) ) NEW_LINE if ( neg_count > 0 ) : NEW_LINE INDENT result *= int ( math . pow ( 2 , neg_count - 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT result = 0 NEW_LINE DEDENT return result NEW_LINE DEDENT
Hyp: 
def cntSubSeq ( arr , n ) : NEW_LINE INDENT pos_count = 0 NEW_LINE neg_count = 0 NEW_LINE result = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT pos_count += 1 NEW_LINE DEDENT if ( arr [ i ] < 0 ) : NEW_LINE INDENT neg_count += 1 NEW_LINE DEDENT DEDENT result = int ( pow ( 2 , pos_count ) ) NEW_LINE if ( neg_count > 0 ) : NEW_LINE INDENT result *= pow ( 2 , neg_count - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT result = 0 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT

BLEU: 87.81
Edit Sim: 51


Src: 
int countStrings ( int n , int k ) { int dp [ ] [ ] [ ] = new int [ n + 1 ] [ k + 1 ] [ 2 ] ; dp [ 1 ] [ 0 ] [ 0 ] = 1 ; dp [ 1 ] [ 0 ] [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 0 ; j < i && j < k + 1 ; j ++ ) { dp [ i ] [ j ] [ 0 ] = dp [ i - 1 ] [ j ] [ 0 ] + dp [ i - 1 ] [ j ] [ 1 ] ; dp [ i ] [ j ] [ 1 ] = dp [ i - 1 ] [ j ] [ 0 ] ; if ( j - 1 >= 0 ) { dp [ i ] [ j ] [ 1 ] += dp [ i - 1 ] [ j - 1 ] [ 1 ] ; } } } return dp [ n ] [ k ] [ 0 ] + dp [ n ] [ k ] [ 1 ] ; }
Ref: 
def countStrings ( n , k ) : NEW_LINE INDENT dp = [ [ [ 0 , 0 ] for __ in range ( k + 1 ) ] for _ in range ( n + 1 ) ] NEW_LINE dp [ 1 ] [ 0 ] [ 0 ] = 1 NEW_LINE dp [ 1 ] [ 0 ] [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT for j in range ( k + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] [ 0 ] = ( dp [ i - 1 ] [ j ] [ 0 ] + dp [ i - 1 ] [ j ] [ 1 ] ) NEW_LINE dp [ i ] [ j ] [ 1 ] = dp [ i - 1 ] [ j ] [ 0 ] NEW_LINE if j >= 1 : NEW_LINE INDENT dp [ i ] [ j ] [ 1 ] += dp [ i - 1 ] [ j - 1 ] [ 1 ] NEW_LINE DEDENT DEDENT DEDENT return dp [ n ] [ k ] [ 0 ] + dp [ n ] [ k ] [ 1 ] NEW_LINE DEDENT
Hyp: 
def countStrings ( n , k ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( k + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE dp [ 1 ] [ 0 ] [ 0 ] = 1 NEW_LINE dp [ 1 ] [ 0 ] [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT for j in range ( i and j < k + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] [ 0 ] = dp [ i - 1 ] [ j ] [ 0 ] + dp [ i - 1 ] [ j ] [ 1 ] NEW_LINE dp [ i ] [ j ] [ 1 ] = dp [ i - 1 ] [ j ] [ 0 ] NEW_LINE if j - 1 >= 0 : NEW_LINE INDENT dp [ i ] [ j ] [ 1 ] += dp [ i - 1 ] [ j - 1 ] [ 1 ] NEW_LINE DEDENT DEDENT DEDENT return dp [ n ] [ k ] [ 0 ] + dp [ n ] [ k ] [ 1 ] NEW_LINE DEDENT

BLEU: 90.92
Edit Sim: 30


Src: 
void addASCII ( char [ ] S , char [ ] N ) { for ( int i = 0 ; i < S . length ; i ++ ) { int a = ( int ) ( N [ i ] ) - '0' ; int b = ( int ) ( S [ i ] ) + a ; if ( b > 122 ) b -= 26 ; S [ i ] = ( char ) ( b ) ; } System . out . print ( S ) ; }
Ref: 
def addASCII ( S , N ) : NEW_LINE INDENT for i in range ( len ( S ) ) : NEW_LINE INDENT a = ord ( N [ i ] ) - ord ( '0' ) NEW_LINE b = ord ( S [ i ] ) + a NEW_LINE if ( b > 122 ) : NEW_LINE INDENT b -= 26 NEW_LINE DEDENT S = S . replace ( S [ i ] , chr ( b ) ) NEW_LINE DEDENT print ( S ) NEW_LINE DEDENT
Hyp: 
def addASCII ( S , N ) : NEW_LINE INDENT for i in S : NEW_LINE INDENT a = ord ( N [ i ] ) - ord ( '0' ) NEW_LINE b = ord ( S [ i ] ) + a NEW_LINE if ( b > 122 ) : NEW_LINE INDENT b -= 26 NEW_LINE DEDENT S [ i ] = chr ( b ) NEW_LINE DEDENT print ( S ) NEW_LINE DEDENT

BLEU: 77.06
Edit Sim: 39


Src: 
double lengthOfLatusRectum ( double A , double B ) { double major = 2.0 * A ; double minor = 2.0 * B ; double latus_rectum = ( minor * minor ) / major ; return latus_rectum ; }
Ref: 
def lengthOfLatusRectum ( A , B ) : NEW_LINE INDENT major = 2.0 * A NEW_LINE minor = 2.0 * B NEW_LINE latus_rectum = ( minor * minor ) / major NEW_LINE return latus_rectum NEW_LINE DEDENT
Hyp: 
def lengthOfLatusRectum ( A , B ) : NEW_LINE INDENT major = 2.0 * A NEW_LINE minor = 2.0 * B NEW_LINE latus_rectum = ( minor * minor ) / major NEW_LINE return latus_rectum NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
long productAscii ( String str ) { long prod = 1 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { prod *= str . charAt ( i ) ; } return prod ; }
Ref: 
def productAscii ( str ) : NEW_LINE INDENT prod = 1 NEW_LINE for i in range ( 0 , len ( str ) ) : NEW_LINE INDENT prod = prod * ord ( str [ i ] ) NEW_LINE DEDENT return prod NEW_LINE DEDENT
Hyp: 
def productAscii ( str ) : NEW_LINE INDENT prod = 1 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT prod *= ord ( str [ i ] ) NEW_LINE DEDENT return prod NEW_LINE DEDENT

BLEU: 80.99
Edit Sim: 12


Src: 
int distinctSubString ( String P , String Q , int K , int N ) { HashSet < String > S = new HashSet < String > ( ) ; for ( int i = 0 ; i < N ; ++ i ) { int sum = 0 ; String s = " " ; for ( int j = i ; j < N ; ++ j ) { int pos = P . charAt ( j ) - ' a ' ; sum += Q . charAt ( pos ) - '0' ; s += P . charAt ( j ) ; if ( sum <= K ) { S . add ( s ) ; } else { break ; } } } return S . size ( ) ; }
Ref: 
def distinctSubstring ( P , Q , K , N ) : NEW_LINE INDENT S = set ( ) NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT sum = 0 ; NEW_LINE s = ' ' NEW_LINE for j in range ( i , N ) : NEW_LINE INDENT pos = ord ( P [ j ] ) - 97 NEW_LINE sum = sum + ord ( Q [ pos ] ) - 48 NEW_LINE s += P [ j ] NEW_LINE if ( sum <= K ) : NEW_LINE INDENT S . add ( s ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT return len ( S ) NEW_LINE DEDENT
Hyp: 
def distinctSubstring ( P , Q , K , N ) : NEW_LINE INDENT S = dict ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum = 0 NEW_LINE s = " " NEW_LINE for j in range ( i , N ) : NEW_LINE INDENT pos = ord ( P [ j ] ) - ord ( ' a ' ) NEW_LINE sum += Q [ pos ] - ord ( '0' ) NEW_LINE s += P [ j ] NEW_LINE if ( sum <= K ) : NEW_LINE INDENT S [ s ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT return len ( S ) NEW_LINE DEDENT

BLEU: 75.13
Edit Sim: 52


Src: 
void printAllAPTriplets ( int [ ] arr , int n ) { ArrayList < Integer > s = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int diff = arr [ j ] - arr [ i ] ; boolean exists = s . contains ( arr [ i ] - diff ) ; if ( exists ) System . out . println ( arr [ i ] - diff + " ▁ " + arr [ i ] + " ▁ " + arr [ j ] ) ; } s . add ( arr [ i ] ) ; } }
Ref: 
def printAllAPTriplets ( arr , n ) : NEW_LINE INDENT s = [ ] ; NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT diff = arr [ j ] - arr [ i ] ; NEW_LINE if ( ( arr [ i ] - diff ) in arr ) : NEW_LINE INDENT print ( " { } ▁ { } ▁ { } " . format ( ( arr [ i ] - diff ) , arr [ i ] , arr [ j ] ) , end =   " " ) ; NEW_LINE DEDENT DEDENT DEDENT s . append ( arr [ i ] ) ; NEW_LINE DEDENT
Hyp: 
def printAllAPTriplets ( arr , n ) : NEW_LINE INDENT s = [ ] NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT diff = arr [ j ] - arr [ i ] NEW_LINE exists = arr [ i ] - diff NEW_LINE if ( exists ) : NEW_LINE INDENT print ( arr [ i ] - diff , arr [ i ] , arr [ j ] ) NEW_LINE DEDENT DEDENT s . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT

BLEU: 63.58
Edit Sim: 98


Src: 
int maximizeExpression ( int a , int b ) { int result = a ; for ( int bit = MAX - 1 ; bit >= 0 ; bit -- ) { int bitOfD = 1 << bit ; int x = b & bitOfD ; if ( x == bitOfD ) { int y = result & bitOfD ; if ( y == 0 ) { result = result ^ bitOfD ; } } } return result ; }
Ref: 
def maximizeExpression ( a , b ) : NEW_LINE INDENT result = a NEW_LINE for bit in range ( MAX - 1 , - 1 , - 1 ) : NEW_LINE INDENT bitOfD = 1 << bit NEW_LINE x = b & bitOfD NEW_LINE if ( x == bitOfD ) : NEW_LINE INDENT y = result & bitOfD NEW_LINE if ( y == 0 ) : NEW_LINE INDENT result = result ^ bitOfD NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
Hyp: 
def maximizeExpression ( a , b ) : NEW_LINE INDENT result = a NEW_LINE for bit in range ( MAX - 1 , - 1 , - 1 ) : NEW_LINE INDENT bitOfD = 1 << bit NEW_LINE x = b & bitOfD NEW_LINE if ( x == bitOfD ) : NEW_LINE INDENT y = result & bitOfD NEW_LINE if ( y == 0 ) : NEW_LINE INDENT result = result ^ bitOfD NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int countIntersections ( int n ) { return n * ( n - 1 ) / 2 ; }
Ref: 
def countIntersections ( n ) : NEW_LINE INDENT return n * ( n - 1 ) // 2 NEW_LINE DEDENT
Hyp: 
def countIntersections ( n ) : NEW_LINE INDENT return n * ( n - 1 ) / 2 NEW_LINE DEDENT

BLEU: 86.56
Edit Sim: 1


Src: 
int closestMultiple ( int n , int x ) { if ( x > n ) return x ; n = n + x / 2 ; n = n - ( n % x ) ; return n ; }
Ref: 
def closestMultiple ( n , x ) : NEW_LINE INDENT if x > n : NEW_LINE INDENT return x ; NEW_LINE DEDENT z = ( int ) ( x / 2 ) ; NEW_LINE n = n + z ; NEW_LINE n = n - ( n % x ) ; NEW_LINE return n ; NEW_LINE DEDENT
Hyp: 
def closestMultiple ( n , x ) : NEW_LINE INDENT if ( x > n ) : NEW_LINE INDENT return x NEW_LINE DEDENT n = n + x // 2 NEW_LINE n = n - ( n % x ) NEW_LINE return n NEW_LINE DEDENT

BLEU: 50.27
Edit Sim: 44


Src: 
int numberOfPaths ( int m , int n ) { if ( m == 1 n == 1 ) return 1 ; return numberOfPaths ( m - 1 , n ) + numberOfPaths ( m , n - 1 ) ; }
Ref: 
def numberOfPaths ( m , n ) : NEW_LINE INDENT if ( m == 1 or n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return numberOfPaths ( m - 1 , n ) + numberOfPaths ( m , n - 1 ) NEW_LINE DEDENT
Hyp: 
def numberOfPaths ( m , n ) : NEW_LINE INDENT if ( m == 1 or n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return numberOfPaths ( m - 1 , n ) + numberOfPaths ( m , n - 1 ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int identity ( int num ) { int row , col ; for ( row = 0 ; row < num ; row ++ ) { for ( col = 0 ; col < num ; col ++ ) { if ( row == col ) System . out . print ( 1 + " ▁ " ) ; else System . out . print ( 0 + " ▁ " ) ; } System . out . println ( ) ; } return 0 ; }
Ref: 
def Identity ( size ) : NEW_LINE INDENT for row in range ( 0 , size ) : NEW_LINE INDENT for col in range ( 0 , size ) : NEW_LINE INDENT if ( row == col ) : NEW_LINE INDENT print ( "1 ▁ " , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "0 ▁ " , end = " ▁ " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT
Hyp: 
def identity ( num ) : NEW_LINE INDENT for row in range ( 0 , num ) : NEW_LINE INDENT for col in range ( 0 , num ) : NEW_LINE INDENT if ( row == col ) : NEW_LINE INDENT print ( 1 , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 , end = " ▁ " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT return 0 NEW_LINE DEDENT

BLEU: 76.6
Edit Sim: 41


Src: 
int count_special ( int n ) { int [ ] fib = new int [ n + 1 ] ; fib [ 0 ] = 1 ; fib [ 1 ] = 2 ; for ( int i = 2 ; i <= n ; i ++ ) { fib [ i ] = ( fib [ i - 1 ] % mod + fib [ i - 2 ] % mod ) % mod ; } return fib [ n ] ; }
Ref: 
def count_special ( n ) : NEW_LINE INDENT fib = [ 0 for i in range ( n + 1 ) ] NEW_LINE fib [ 0 ] = 1 NEW_LINE fib [ 1 ] = 2 NEW_LINE for i in range ( 2 , n + 1 , 1 ) : NEW_LINE INDENT fib [ i ] = ( fib [ i - 1 ] % mod + fib [ i - 2 ] % mod ) % mod NEW_LINE DEDENT return fib [ n ] NEW_LINE DEDENT
Hyp: 
def count_special ( n ) : NEW_LINE INDENT fib = [ 0 for i in range ( n + 2 ) ] NEW_LINE fib [ 0 ] = 1 NEW_LINE fib [ 1 ] = 2 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT fib [ i ] = ( fib [ i - 1 ] % mod + fib [ i - 2 ] % mod ) % mod NEW_LINE DEDENT return fib [ n ] NEW_LINE DEDENT

BLEU: 94.52
Edit Sim: 5


Src: 
int maxSelections ( int A [ ] , int n , int k ) { Arrays . sort ( A ) ; int sum = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + A [ i ] ; if ( sum > k ) { break ; } count ++ ; } return count ; }
Ref: 
def maxSelections ( A , n , k ) : NEW_LINE INDENT A . sort ( ) ; NEW_LINE sum = 0 ; NEW_LINE count = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = sum + A [ i ] ; NEW_LINE if ( sum > k ) : NEW_LINE break ; NEW_LINE count += 1 ; NEW_LINE return count ; NEW_LINE DEDENT DEDENT
Hyp: 
def maxSelections ( A , n , k ) : NEW_LINE INDENT A . sort ( ) NEW_LINE Sum , count = 0 , 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT Sum = sum + A [ i ] NEW_LINE if ( Sum > k ) : NEW_LINE INDENT break NEW_LINE DEDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT

BLEU: 55.41
Edit Sim: 62


Src: 
int arraySum ( int arr [ ] , int n ) { int x = ( n + 1 ) / 2 ; return ( arr [ 0 ] - 1 ) * n + x * x ; }
Ref: 
def arraySum ( arr , n ) : NEW_LINE INDENT x = ( n + 1 ) / 2 NEW_LINE return ( arr [ 0 ] - 1 ) * n + x * x NEW_LINE DEDENT
Hyp: 
def arraySum ( arr , n ) : NEW_LINE INDENT x = ( n + 1 ) / 2 NEW_LINE return ( arr [ 0 ] - 1 ) * n + x * x NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int mininsert ( int arr [ ] , int K , int N ) { int ans = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { int a = Math . min ( arr [ i ] , arr [ i + 1 ] ) ; int b = Math . max ( arr [ i ] , arr [ i + 1 ] ) ; while ( K * a < b ) { a *= K ; ans ++ ; } } return ans ; }
Ref: 
def mininsert ( arr , K , N ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT a = min ( arr [ i ] , arr [ i + 1 ] ) NEW_LINE b = max ( arr [ i ] , arr [ i + 1 ] ) NEW_LINE while ( K * a < b ) : NEW_LINE INDENT a *= K NEW_LINE ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
Hyp: 
def mininsert ( arr , K , N ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT a = min ( arr [ i ] , arr [ i + 1 ] ) NEW_LINE b = max ( arr [ i ] , arr [ i + 1 ] ) NEW_LINE while ( K * a < b ) : NEW_LINE INDENT a *= K NEW_LINE ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int sum ( int h ) { return ( int ) Math . pow ( 2 , h - 1 ) ; }
Ref: 
def summ ( h ) : NEW_LINE INDENT return pow ( 2 , h - 1 ) NEW_LINE DEDENT
Hyp: 
def sum ( h ) : NEW_LINE INDENT return pow ( 2 , h - 1 ) ; NEW_LINE DEDENT

BLEU: 78.78
Edit Sim: 3


Src: 
int countInscribed ( int R1 , int R2 ) { if ( R2 > R1 ) return 0 ; double angle ; double ratio ; int number_of_circles = 0 ; ratio = R2 / ( double ) ( R1 - R2 ) ; if ( R1 < 2 * R2 ) { number_of_circles = 1 ; } else { angle = Math . abs ( Math . asin ( ratio ) * 180 ) / 3.14159265 ; number_of_circles = ( int ) ( 360 / ( 2 * Math . floor ( angle ) ) ) ; } return number_of_circles ; }
Ref: 
def countInscribed ( R1 , R2 ) : NEW_LINE INDENT if ( R2 > R1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT angle = 0 NEW_LINE ratio = 0 NEW_LINE number_of_circles = 0 NEW_LINE ratio = R2 / ( R1 - R2 ) NEW_LINE if ( R1 < 2 * R2 ) : NEW_LINE INDENT number_of_circles = 1 NEW_LINE DEDENT else : NEW_LINE INDENT angle = ( abs ( math . asin ( ratio ) * 180 ) / 3.14159265 ) NEW_LINE number_of_circles = ( 360 / ( 2 * math . floor ( angle ) ) ) NEW_LINE DEDENT return number_of_circles NEW_LINE DEDENT
Hyp: 
def countInscribed ( R1 , R2 ) : NEW_LINE INDENT if ( R2 > R1 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT ratio = R2 / ( R1 - R2 ) ; NEW_LINE if ( R1 < 2 * R2 ) : NEW_LINE INDENT number_of_circles = 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT angle = ( abs ( ratio ) * 180 ) / 3.14159265 ; NEW_LINE number_of_circles = ( int ) ( 360 // ( 2 * math . floor ( angle ) ) ) ; NEW_LINE DEDENT return number_of_circles ; NEW_LINE DEDENT

BLEU: 70.04
Edit Sim: 103


Src: 
int MatrixChainOrder ( int p [ ] , int n ) { int m [ ] [ ] = new int [ n ] [ n ] ; int i , j , k , L , q ; for ( i = 1 ; i < n ; i ++ ) m [ i ] [ i ] = 0 ; for ( L = 2 ; L < n ; L ++ ) { for ( i = 1 ; i < n - L + 1 ; i ++ ) { j = i + L - 1 ; if ( j == n ) continue ; m [ i ] [ j ] = Integer . MAX_VALUE ; for ( k = i ; k <= j - 1 ; k ++ ) { q = m [ i ] [ k ] + m [ k + 1 ] [ j ] + p [ i - 1 ] * p [ k ] * p [ j ] ; if ( q < m [ i ] [ j ] ) m [ i ] [ j ] = q ; } } } return m [ 1 ] [ n - 1 ] ; }
Ref: 
def MatrixChainOrder ( p , n ) : NEW_LINE INDENT m = [ [ 0 for x in range ( n ) ] for x in range ( n ) ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT m [ i ] [ i ] = 0 NEW_LINE DEDENT for L in range ( 2 , n ) : NEW_LINE INDENT for i in range ( 1 , n - L + 1 ) : NEW_LINE INDENT j = i + L - 1 NEW_LINE m [ i ] [ j ] = sys . maxint NEW_LINE for k in range ( i , j ) : NEW_LINE INDENT q = m [ i ] [ k ] + m [ k + 1 ] [ j ] + p [ i - 1 ] * p [ k ] * p [ j ] NEW_LINE if q < m [ i ] [ j ] : NEW_LINE INDENT m [ i ] [ j ] = q NEW_LINE DEDENT DEDENT DEDENT DEDENT return m [ 1 ] [ n - 1 ] NEW_LINE DEDENT
Hyp: 
def MatrixChainOrder ( p , n ) : NEW_LINE INDENT m = [ [ 0 for i in range ( n + 2 ) ] for j in range ( n + 2 ) ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT m [ i ] [ i ] = 0 NEW_LINE DEDENT for L in range ( 2 , n + 1 ) : NEW_LINE INDENT for i in range ( 1 , n - L + 1 ) : NEW_LINE INDENT j = i + L - 1 NEW_LINE if ( j == n ) : NEW_LINE INDENT continue NEW_LINE DEDENT m [ i ] [ j ] = sys . maxsize NEW_LINE DEDENT for k in range ( i , j - 1 ) : NEW_LINE INDENT q = m [ i ] [ k ] + m [ k + 1 ] [ j ] + p [ i - 1 ] * p [ k ] * p [ j ] NEW_LINE if ( q < m [ i ] [ j ] ) : NEW_LINE INDENT m [ i ] [ j ] = q NEW_LINE DEDENT DEDENT DEDENT DEDENT return m [ 1 ] [ n - 1 ] NEW_LINE DEDENT

BLEU: 80.59
Edit Sim: 89


Src: 
int findKthGoodNo ( int n ) { int lastDig = n % 10 ; if ( lastDig >= 0 && lastDig <= 4 ) return n << 1 ; else return ( n << 1 ) + 1 ; }
Ref: 
def findKthGoodNo ( n ) : NEW_LINE INDENT lastDig = n % 10 NEW_LINE if ( lastDig >= 0 and lastDig <= 4 ) : NEW_LINE INDENT return n << 1 NEW_LINE DEDENT else : NEW_LINE INDENT return ( n << 1 ) + 1 NEW_LINE DEDENT DEDENT
Hyp: 
def findKthGoodNo ( n ) : NEW_LINE INDENT lastDig = n % 10 NEW_LINE if ( lastDig >= 0 and lastDig <= 4 ) : NEW_LINE INDENT return n << 1 NEW_LINE DEDENT else : NEW_LINE INDENT return ( n << 1 ) + 1 NEW_LINE DEDENT DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int numPrimeArrangements ( int n ) { boolean [ ] prime = new boolean [ n + 1 ] ; Arrays . fill ( prime , true ) ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int i = 2 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( prime [ i ] ) for ( int factor = 2 ; factor * i <= n ; factor ++ ) prime [ factor * i ] = false ; } int primeIndices = 0 ; for ( int i = 1 ; i <= n ; i ++ ) if ( prime [ i ] ) primeIndices ++ ; int mod = ( int ) ( 1e9 + 7 ) , res = 1 ; for ( int i = 1 ; i <= primeIndices ; i ++ ) res = ( int ) ( ( 1L * res * i ) % mod ) ; for ( int i = 1 ; i <= ( n - primeIndices ) ; i ++ ) res = ( int ) ( ( 1L * res * i ) % mod ) ; return res ; }
Ref: 
def numPrimeArrangements ( n ) : NEW_LINE INDENT prime = [ True for i in range ( n + 1 ) ] NEW_LINE prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for i in range ( 2 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if prime [ i ] : NEW_LINE INDENT factor = 2 NEW_LINE while factor * i <= n : NEW_LINE INDENT prime [ factor * i ] = False NEW_LINE factor += 1 NEW_LINE DEDENT DEDENT DEDENT primeIndices = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if prime [ i ] : NEW_LINE INDENT primeIndices += 1 NEW_LINE DEDENT DEDENT mod = 1000000007 NEW_LINE res = 1 NEW_LINE for i in range ( 1 , primeIndices + 1 ) : NEW_LINE INDENT res = ( res * i ) % mod NEW_LINE DEDENT for i in range ( 1 , n - primeIndices + 1 ) : NEW_LINE INDENT res = ( res * i ) % mod NEW_LINE DEDENT return res NEW_LINE DEDENT
Hyp: 
def numPrimeArrangements ( n ) : NEW_LINE INDENT prime = [ 0 for i in range ( n + 1 ) ] NEW_LINE prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for i in range ( 2 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT factor = 2 NEW_LINE while ( factor * i <= n ) : NEW_LINE INDENT prime [ factor * i ] = False NEW_LINE DEDENT DEDENT DEDENT primeIndices = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT primeIndices += 1 NEW_LINE DEDENT mod = ( 1e9 + 7 ) NEW_LINE res = 1 NEW_LINE for i in range ( 1 , primeIndices + 1 ) : NEW_LINE INDENT res = ( int ) ( ( 1L * res * i ) % mod ) NEW_LINE DEDENT for i in range ( 1 , n - primeIndices + 1 ) : NEW_LINE INDENT res = ( int ) ( ( 1L * res * i ) % mod ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT

BLEU: 76.72
Edit Sim: 103


Src: 
void printhexa ( int n ) { if ( n < 0 ) return ; int first = 0 ; int second = 0 ; int third = 0 ; int fourth = 0 ; int fifth = 0 ; int sixth = 1 ; int curr = 0 ; if ( n < 6 ) System . out . println ( first ) ; else if ( n == 6 ) System . out . println ( sixth ) ; else { for ( int i = 6 ; i < n ; i ++ ) { curr = first + second + third + fourth + fifth + sixth ; first = second ; second = third ; third = fourth ; fourth = fifth ; fifth = sixth ; sixth = curr ; } } System . out . println ( curr ) ; }
Ref: 
def printhexa ( n ) : NEW_LINE INDENT if ( n < 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT first = 0 NEW_LINE second = 0 NEW_LINE third = 0 NEW_LINE fourth = 0 NEW_LINE fifth = 0 NEW_LINE sixth = 1 NEW_LINE curr = 0 NEW_LINE if ( n < 6 ) : NEW_LINE INDENT print ( first ) NEW_LINE DEDENT elif ( n == 6 ) : NEW_LINE INDENT print ( sixth ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( 6 , n ) : NEW_LINE INDENT curr = first + second + third + fourth + fifth + sixth NEW_LINE first = second NEW_LINE second = third NEW_LINE third = fourth NEW_LINE fourth = fifth NEW_LINE fifth = sixth NEW_LINE sixth = curr NEW_LINE DEDENT DEDENT print ( curr ) NEW_LINE DEDENT
Hyp: 
def printhexa ( n ) : NEW_LINE INDENT if ( n < 0 ) : return 0 NEW_LINE first = 0 NEW_LINE second = 0 NEW_LINE third = 0 NEW_LINE fourth = 0 NEW_LINE fifth = 0 NEW_LINE sixth = 1 NEW_LINE curr = 0 NEW_LINE if ( n < 6 ) : NEW_LINE INDENT print ( first ) NEW_LINE DEDENT elif ( n == 6 ) : NEW_LINE INDENT print ( sixth ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( 6 , n ) : NEW_LINE INDENT curr = first + second + third + fourth + fifth + sixth NEW_LINE first = second NEW_LINE second = third NEW_LINE third = fourth NEW_LINE fourth = fifth NEW_LINE fifth = sixth NEW_LINE sixth = curr NEW_LINE DEDENT DEDENT print ( curr ) NEW_LINE DEDENT

BLEU: 95.67
Edit Sim: 25


Src: 
int count_elements ( int arr [ ] , int n ) { int count = 1 ; int max = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > max ) { count += 1 ; max = arr [ i ] ; } } return count ; }
Ref: 
def count_elements ( arr ) : NEW_LINE INDENT count = 1 NEW_LINE max = arr [ 0 ] NEW_LINE for i in range ( 1 , len ( arr ) ) : NEW_LINE INDENT if arr [ i ] > max : NEW_LINE INDENT count += 1 NEW_LINE max = arr [ i ] NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
Hyp: 
def count_elements ( arr , n ) : NEW_LINE INDENT count = 1 NEW_LINE max = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] > max ) : NEW_LINE INDENT count += 1 NEW_LINE max = arr [ i ] NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT

BLEU: 82.7
Edit Sim: 18


Src: 
void findMinLength ( int arr [ ] , int N ) { int front = 0 , back = N - 1 ; while ( front < back ) { int x = arr [ front ] ; if ( arr [ front ] != arr [ back ] ) break ; while ( arr [ front ] == x && front <= back ) front ++ ; while ( arr [ back ] == x && front <= back ) back -- ; } System . out . println ( back - front + 1 ) ; }
Ref: 
def findMinLength ( arr , N ) : NEW_LINE INDENT front = 0 NEW_LINE back = N - 1 NEW_LINE while ( front < back ) : NEW_LINE INDENT x = arr [ front ] NEW_LINE if arr [ front ] != arr [ back ] : NEW_LINE INDENT break NEW_LINE DEDENT while ( arr [ front ] == x and front <= back ) : NEW_LINE INDENT front += 1 NEW_LINE DEDENT while ( arr [ back ] == x and front <= back ) : NEW_LINE INDENT back -= 1 NEW_LINE DEDENT DEDENT print ( back - front + 1 ) NEW_LINE DEDENT
Hyp: 
def findMinLength ( arr , N ) : NEW_LINE INDENT front = 0 NEW_LINE back = N - 1 NEW_LINE while ( front < back ) : NEW_LINE INDENT x = arr [ front ] NEW_LINE if ( arr [ front ] != arr [ back ] ) : NEW_LINE INDENT break NEW_LINE DEDENT while ( arr [ front ] == x and front <= back ) : NEW_LINE INDENT front += 1 NEW_LINE DEDENT while ( arr [ back ] == x and front <= back ) : NEW_LINE INDENT back -= 1 NEW_LINE DEDENT DEDENT print ( back - front + 1 ) NEW_LINE DEDENT

BLEU: 95.26
Edit Sim: 4


Src: 
void findNumbers ( int N , int M ) { int m = M ; Map < Integer , Integer > remLen = new HashMap < > ( ) ; int len , remainder = 0 ; for ( len = 1 ; len <= N + 1 ; ++ len ) { remainder = M % N ; if ( ! remLen . containsKey ( remainder ) ) { remLen . put ( remainder , len ) ; } else { break ; } M = M * 10 + m ; M = M % N ; } int LenA = len ; int LenB = remLen . getOrDefault ( remainder , 0 ) ; for ( int i = 0 ; i < LenB ; ++ i ) System . out . print ( m ) ; System . out . print ( " ▁ " ) ; for ( int i = 0 ; i < LenA ; ++ i ) System . out . print ( m ) ; }
Ref: 
def findNumbers ( N , M ) : NEW_LINE INDENT m = M NEW_LINE remLen = { } NEW_LINE for len1 in range ( 1 , N + 1 , 1 ) : NEW_LINE INDENT remainder = M % N NEW_LINE if ( remLen . get ( remainder ) == None ) : NEW_LINE INDENT remLen [ remainder ] = len1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT M = M * 10 + m NEW_LINE M = M % N NEW_LINE DEDENT LenA = len1 NEW_LINE LenB = remLen [ remainder ] NEW_LINE for i in range ( LenB ) : NEW_LINE INDENT print ( m , end = " " ) NEW_LINE DEDENT print ( " ▁ " , end = " " ) NEW_LINE for i in range ( LenA ) : NEW_LINE INDENT print ( m , end = " " ) NEW_LINE DEDENT return NEW_LINE DEDENT
Hyp: 
def findNumbers ( N , M ) : NEW_LINE INDENT m = M NEW_LINE remLen = { } NEW_LINE length = 0 NEW_LINE remainder = 0 NEW_LINE for l in range ( 1 , N + 1 ) : NEW_LINE INDENT remainder = M % N NEW_LINE if ( remainder not in remLen ) : NEW_LINE INDENT remLen [ remainder ] = len NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT M = M * 10 + m NEW_LINE M = M % N NEW_LINE DEDENT LenA = len NEW_LINE LenB = remLen [ remainder ] NEW_LINE for i in range ( LenB ) : NEW_LINE INDENT print ( m , end = " ▁ " ) NEW_LINE DEDENT for i in range ( LenA ) : NEW_LINE INDENT print ( m , end = " ▁ " ) NEW_LINE DEDENT DEDENT

BLEU: 75.12
Edit Sim: 131


Src: 
int countWays ( int n ) { if ( n == 0 ) return 1 ; if ( n <= 2 ) return n ; int f0 = 1 , f1 = 1 , f2 = 2 ; int ans = 0 ; for ( int i = 3 ; i <= n ; i ++ ) { ans = f0 + f1 + f2 ; f0 = f1 ; f1 = f2 ; f2 = ans ; } return ans ; }
Ref: 
def countWays ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n <= 2 ) : NEW_LINE INDENT return n NEW_LINE DEDENT f0 = 1 NEW_LINE f1 = 1 NEW_LINE f2 = 2 NEW_LINE ans = 0 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT ans = f0 + f1 + f2 NEW_LINE f0 = f1 NEW_LINE f1 = f2 NEW_LINE f2 = ans NEW_LINE DEDENT return ans NEW_LINE DEDENT
Hyp: 
def countWays ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n <= 2 ) : NEW_LINE INDENT return n NEW_LINE DEDENT f0 = 1 NEW_LINE f1 = 1 NEW_LINE f2 = 2 NEW_LINE ans = 0 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT ans = f0 + f1 + f2 NEW_LINE f0 = f1 NEW_LINE f1 = f2 NEW_LINE f2 = ans NEW_LINE DEDENT return ans NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
void quadrant ( int x , int y ) { if ( x > 0 && y > 0 ) System . out . println ( " lies ▁ in ▁ First ▁ quadrant " ) ; else if ( x < 0 && y > 0 ) System . out . println ( " lies ▁ in ▁ Second ▁ quadrant " ) ; else if ( x < 0 && y < 0 ) System . out . println ( " lies ▁ in ▁ Third ▁ quadrant " ) ; else if ( x > 0 && y < 0 ) System . out . println ( " lies ▁ in ▁ Fourth ▁ quadrant " ) ; else if ( x == 0 && y > 0 ) System . out . println ( " lies ▁ at ▁ positive ▁ y ▁ axis " ) ; else if ( x == 0 && y < 0 ) System . out . println ( " lies ▁ at ▁ negative ▁ y ▁ axis " ) ; else if ( y == 0 && x < 0 ) System . out . println ( " lies ▁ at ▁ negative ▁ x ▁ axis " ) ; else if ( y == 0 && x > 0 ) System . out . println ( " lies ▁ at ▁ positive ▁ x ▁ axis " ) ; else System . out . println ( " lies ▁ at ▁ origin " ) ; }
Ref: 
def quadrant ( x , y ) : NEW_LINE INDENT if ( x > 0 and y > 0 ) : NEW_LINE INDENT print ( " lies ▁ in ▁ First ▁ quadrant " ) NEW_LINE DEDENT elif ( x < 0 and y > 0 ) : NEW_LINE INDENT print ( " lies ▁ in ▁ Second ▁ quadrant " ) NEW_LINE DEDENT elif ( x < 0 and y < 0 ) : NEW_LINE INDENT print ( " lies ▁ in ▁ Third ▁ quadrant " ) NEW_LINE DEDENT elif ( x > 0 and y < 0 ) : NEW_LINE INDENT print ( " lies ▁ in ▁ Fourth ▁ quadrant " ) NEW_LINE DEDENT elif ( x == 0 and y > 0 ) : NEW_LINE INDENT print ( " lies ▁ at ▁ positive ▁ y ▁ axis " ) NEW_LINE DEDENT elif ( x == 0 and y < 0 ) : NEW_LINE INDENT print ( " lies ▁ at ▁ negative ▁ y ▁ axis " ) NEW_LINE DEDENT elif ( y == 0 and x < 0 ) : NEW_LINE INDENT print ( " lies ▁ at ▁ negative ▁ x ▁ axis " ) NEW_LINE DEDENT elif ( y == 0 and x > 0 ) : NEW_LINE INDENT print ( " lies ▁ at ▁ positive ▁ x ▁ axis " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " lies ▁ at ▁ origin " ) NEW_LINE DEDENT DEDENT
Hyp: 
def quadrant ( x , y ) : NEW_LINE INDENT if ( x > 0 and y > 0 ) : NEW_LINE INDENT print ( " lies ▁ in ▁ First ▁ quadrant " ) NEW_LINE DEDENT elif ( x < 0 and y < 0 ) : NEW_LINE INDENT print ( " lies ▁ in ▁ Second ▁ quadrant " ) NEW_LINE DEDENT elif ( x > 0 and y > 0 ) : NEW_LINE INDENT print ( " lies ▁ in ▁ Third ▁ quadrant " ) NEW_LINE DEDENT elif ( x == 0 and y > 0 ) : NEW_LINE INDENT print ( " lies ▁ at ▁ positive ▁ y ▁ axis " ) NEW_LINE DEDENT elif ( x == 0 and y < 0 ) : NEW_LINE INDENT print ( " lies ▁ at ▁ negative ▁ x ▁ axis " ) NEW_LINE DEDENT elif ( y == 0 and x > 0 ) : NEW_LINE INDENT print ( " lies ▁ at ▁ positive ▁ x ▁ axis " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " lies ▁ at ▁ origin " ) NEW_LINE DEDENT DEDENT

BLEU: 75.04
Edit Sim: 212


Src: 
int calculateLeaps ( int n ) { if ( n == 0 n == 1 ) { return 1 ; } else { int leaps = 0 ; for ( int i = 0 ; i < n ; i ++ ) leaps += calculateLeaps ( i ) ; return leaps ; } }
Ref: 
def calculateLeaps ( n ) : NEW_LINE INDENT if n == 0 or n == 1 : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT leaps = 0 ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT leaps = leaps + calculateLeaps ( i ) ; NEW_LINE DEDENT return leaps ; NEW_LINE DEDENT DEDENT
Hyp: 
def calculateLeaps ( n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT leaps = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT leaps += calculateLeaps ( i ) NEW_LINE DEDENT return leaps NEW_LINE DEDENT DEDENT

BLEU: 63.47
Edit Sim: 25


Src: 
boolean findGreater ( int x , int y ) { if ( x > y ) { return false ; } else { return true ; } }
Ref: 
def findGreater ( x , y ) : NEW_LINE INDENT if ( x > y ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT else : NEW_LINE INDENT return True ; NEW_LINE DEDENT DEDENT x = 4 ; NEW_LINE y = 9 ; NEW_LINE if ( findGreater ( x , y ) ) : NEW_LINE INDENT print ( "1" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( "2" ) ; NEW_LINE DEDENT
Hyp: 
def findGreater ( x , y ) : NEW_LINE INDENT if ( x > y ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT else : NEW_LINE INDENT return True ; NEW_LINE DEDENT DEDENT

BLEU: 30.84
Edit Sim: 168


Src: 
void printSpiral ( int [ ] [ ] mat , int r , int c ) { int i , a = 0 , b = 2 ; int low_row = ( 0 > a ) ? 0 : a ; int low_column = ( 0 > b ) ? 0 : b - 1 ; int high_row = ( ( a + 1 ) >= r ) ? r - 1 : a + 1 ; int high_column = ( ( b + 1 ) >= c ) ? c - 1 : b + 1 ; while ( ( low_row > 0 - r && low_column > 0 - c ) ) { for ( i = low_column + 1 ; i <= high_column && i < c && low_row >= 0 ; ++ i ) System . out . print ( mat [ low_row ] [ i ] + " ▁ " ) ; low_row -= 1 ; for ( i = low_row + 2 ; i <= high_row && i < r && high_column < c ; ++ i ) System . out . print ( mat [ i ] [ high_column ] + " ▁ " ) ; high_column += 1 ; for ( i = high_column - 2 ; i >= low_column && i >= 0 && high_row < r ; -- i ) System . out . print ( mat [ high_row ] [ i ] + " ▁ " ) ; high_row += 1 ; for ( i = high_row - 2 ; i > low_row && i >= 0 && low_column >= 0 ; -- i ) System . out . print ( mat [ i ] [ low_column ] + " ▁ " ) ; low_column -= 1 ; } System . out . println ( ) ; }
Ref: 
def printSpiral ( mat , r , c ) : NEW_LINE INDENT a = 0 NEW_LINE b = 2 NEW_LINE low_row = 0 if ( 0 > a ) else a NEW_LINE low_column = 0 if ( 0 > b ) else b - 1 NEW_LINE high_row = r - 1 if ( ( a + 1 ) >= r ) else a + 1 NEW_LINE high_column = c - 1 if ( ( b + 1 ) >= c ) else b + 1 NEW_LINE while ( ( low_row > 0 - r and low_column > 0 - c ) ) : NEW_LINE INDENT i = low_column + 1 NEW_LINE while ( i <= high_column and i < c and low_row >= 0 ) : NEW_LINE INDENT print ( mat [ low_row ] [ i ] , end = " ▁ " ) NEW_LINE i += 1 NEW_LINE DEDENT low_row -= 1 NEW_LINE i = low_row + 2 NEW_LINE while ( i <= high_row and i < r and high_column < c ) : NEW_LINE INDENT print ( mat [ i ] [ high_column ] , end = " ▁ " ) NEW_LINE i += 1 NEW_LINE DEDENT high_column += 1 NEW_LINE i = high_column - 2 NEW_LINE while ( i >= low_column and i >= 0 and high_row < r ) : NEW_LINE INDENT print ( mat [ high_row ] [ i ] , end = " ▁ " ) NEW_LINE i -= 1 NEW_LINE DEDENT high_row += 1 NEW_LINE i = high_row - 2 NEW_LINE while ( i > low_row and i >= 0 and low_column >= 0 ) : NEW_LINE INDENT print ( mat [ i ] [ low_column ] , end = " ▁ " ) NEW_LINE i -= 1 NEW_LINE DEDENT low_column -= 1 NEW_LINE DEDENT print ( ) NEW_LINE DEDENT
Hyp: 
def printSpiral ( mat , r , c ) : NEW_LINE INDENT a = 0 NEW_LINE b = 2 NEW_LINE low_row = ( 0 > a ) ? 0 : a NEW_LINE low_column = ( 0 > b ) ? 0 : b - 1 NEW_LINE high_row = ( ( a + 1 ) >= r ) ? r - 1 : a + 1 NEW_LINE high_column = ( ( b + 1 ) >= c ) ? c - 1 : b + 1 NEW_LINE while ( ( low_row > 0 - r and low_column > 0 ) : NEW_LINE INDENT i = low_column + 1 NEW_LINE while ( i <= high_column and i < c and low_row >= 0 ) : NEW_LINE INDENT print ( mat [ low_row ] [ i ] , end = " ▁ " ) NEW_LINE high_column += 1 NEW_LINE DEDENT for i in range ( high_column - 2 , low_column and i >= 0 and high_row < r ) : NEW_LINE INDENT print ( mat [ high_row ] [ i ] , end = " ▁ " ) NEW_LINE high_row += 1 NEW_LINE DEDENT for i in range ( high_row - 2 , low_row and i >= 0 and low_column >= 0 ) : NEW_LINE INDENT print ( mat [ i ] [ low_column ] , end = " ▁ " ) NEW_LINE low_column -= 1 NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT

BLEU: 60.19
Edit Sim: 379


Src: 
> getLudic ( int n ) { List < Integer > ludics = new ArrayList < Integer > ( n ) ; for ( int i = 1 ; i <= n ; i ++ ) ludics . add ( i ) ; for ( int index = 1 ; index < ludics . size ( ) ; index ++ ) { int first_ludic = ludics . get ( index ) ; int remove_index = index + first_ludic ; while ( remove_index < ludics . size ( ) ) { ludics . remove ( remove_index ) ; remove_index = remove_index + first_ludic - 1 ; } } return ludics ; }
Ref: 
def getLudic ( n ) : NEW_LINE INDENT ludics = [ ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ludics . append ( i ) NEW_LINE DEDENT index = 1 NEW_LINE while ( index != len ( ludics ) ) : NEW_LINE INDENT first_ludic = ludics [ index ] NEW_LINE remove_index = index + first_ludic NEW_LINE while ( remove_index < len ( ludics ) ) : NEW_LINE INDENT ludics . remove ( ludics [ remove_index ] ) NEW_LINE remove_index = remove_index + first_ludic - 1 NEW_LINE DEDENT index += 1 NEW_LINE DEDENT return ludics NEW_LINE DEDENT
Hyp: 
def getLudic ( n ) : NEW_LINE INDENT ludics = [ ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ludics . append ( i ) NEW_LINE DEDENT for index in range ( 1 , len ( ludics ) ) : NEW_LINE INDENT first_ludic = ludics [ index ] NEW_LINE remove_index = index + first_ludic NEW_LINE while remove_index < len ( ludics ) : NEW_LINE INDENT ludics . remove ( remove_index ) NEW_LINE remove_index = remove_index + first_ludic - 1 NEW_LINE DEDENT DEDENT return ludics NEW_LINE DEDENT

BLEU: 76.56
Edit Sim: 62


Src: 
void printPascal ( int n ) { for ( int line = 1 ; line <= n ; line ++ ) { int C = 1 ; for ( int i = 1 ; i <= line ; i ++ ) { System . out . print ( C + " ▁ " ) ; C = C * ( line - i ) / i ; } System . out . println ( ) ; } }
Ref: 
def printPascal ( n ) : NEW_LINE INDENT for line in range ( 1 , n + 1 ) : NEW_LINE INDENT C = 1 ; NEW_LINE for i in range ( 1 , line + 1 ) : NEW_LINE INDENT print ( C , end = " ▁ " ) ; NEW_LINE C = int ( C * ( line - i ) / i ) ; NEW_LINE DEDENT print ( " " ) ; NEW_LINE DEDENT DEDENT
Hyp: 
def printPascal ( n ) : NEW_LINE INDENT for line in range ( 1 , n + 1 ) : NEW_LINE INDENT C = 1 NEW_LINE for i in range ( 1 , line + 1 ) : NEW_LINE INDENT print ( C , end = " ▁ " ) NEW_LINE C = C * ( line - i ) / i NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT

BLEU: 76.99
Edit Sim: 20


Src: 
int countNonIncreasing ( int arr [ ] , int n ) { int cnt = 0 ; int len = 1 ; for ( int i = 0 ; i < n - 1 ; ++ i ) { if ( arr [ i + 1 ] <= arr [ i ] ) len ++ ; else { cnt += ( ( ( len + 1 ) * len ) / 2 ) ; len = 1 ; } } if ( len > 1 ) cnt += ( ( ( len + 1 ) * len ) / 2 ) ; return cnt ; }
Ref: 
def countNonIncreasing ( arr , n ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE len = 1 ; NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( arr [ i + 1 ] <= arr [ i ] ) : NEW_LINE INDENT len += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT cnt += ( ( ( len + 1 ) * len ) / 2 ) ; NEW_LINE len = 1 ; NEW_LINE DEDENT DEDENT if ( len > 1 ) : NEW_LINE INDENT cnt += ( ( ( len + 1 ) * len ) / 2 ) ; NEW_LINE DEDENT return int ( cnt ) ; NEW_LINE DEDENT
Hyp: 
def countNonIncreasing ( arr , n ) : NEW_LINE INDENT cnt = 0 NEW_LINE len = 1 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( arr [ i + 1 ] <= arr [ i ] ) : NEW_LINE INDENT len += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt += ( ( len + 1 ) * len ) // 2 ) NEW_LINE DEDENT len = 1 NEW_LINE DEDENT if ( len > 1 ) : NEW_LINE INDENT cnt += ( ( len + 1 ) * len ) // 2 ) NEW_LINE DEDENT return cnt NEW_LINE DEDENT

BLEU: 70.56
Edit Sim: 46


Src: 
int number_of_ways ( int arr [ ] , int n , int k ) { if ( k == 1 ) return 1 ; int dp [ ] = new int [ k + 1 ] ; int i ; for ( i = 0 ; i < k + 1 ; i ++ ) dp [ i ] = - 1 ; for ( i = 0 ; i < n ; i ++ ) dp [ arr [ i ] ] = 0 ; dp [ 0 ] = 1 ; dp [ 1 ] = ( dp [ 1 ] == - 1 ) ? 1 : dp [ 1 ] ; for ( i = 2 ; i <= k ; ++ i ) { if ( dp [ i ] == 0 ) continue ; dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] ; dp [ i ] %= MOD ; } return dp [ k ] ; }
Ref: 
def number_of_ways ( arr , n , k ) : NEW_LINE INDENT if ( k == 1 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT dp = [ - 1 ] * ( k + 1 ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp [ arr [ i ] ] = 0 ; NEW_LINE DEDENT dp [ 0 ] = 1 ; NEW_LINE dp [ 1 ] = 1 if ( dp [ 1 ] == - 1 ) else dp [ 1 ] ; NEW_LINE for i in range ( 2 , k + 1 ) : NEW_LINE INDENT if ( dp [ i ] == 0 ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] ; NEW_LINE dp [ i ] %= MOD ; NEW_LINE DEDENT return dp [ k ] ; NEW_LINE DEDENT
Hyp: 
def number_of_ways ( arr , n , k ) : NEW_LINE INDENT if ( k == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT dp = [ 0 ] * ( k + 1 ) NEW_LINE for i in range ( k + 1 ) : NEW_LINE INDENT dp [ i ] = - 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT dp [ arr [ i ] ] = 0 NEW_LINE DEDENT dp [ 0 ] = 1 NEW_LINE dp [ 1 ] = ( dp [ 1 ] == - 1 ) ? 1 : dp [ 1 ] NEW_LINE for i in range ( 2 , k + 1 ) : NEW_LINE INDENT if ( dp [ i ] == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] NEW_LINE dp [ i ] %= MOD NEW_LINE DEDENT return dp [ k ] NEW_LINE DEDENT

BLEU: 74.98
Edit Sim: 100


Src: 
float trianglearea ( float l , float b ) { if ( l < 0 b < 0 ) return - 1 ; float area = ( l * b ) / 2 ; return area ; }
Ref: 
def trianglearea ( l , b ) : NEW_LINE INDENT if ( l < 0 or b < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT area = ( l * b ) / 2 NEW_LINE return area NEW_LINE DEDENT
Hyp: 
def trianglearea ( l , b ) : NEW_LINE INDENT if l < 0 or b < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT area = ( l * b ) / 2 NEW_LINE return area NEW_LINE DEDENT

BLEU: 87.56
Edit Sim: 4


Src: 
int pell ( int n ) { if ( n <= 2 ) return n ; int a = 1 ; int b = 2 ; int c ; for ( int i = 3 ; i <= n ; i ++ ) { c = 2 * b + a ; a = b ; b = c ; } return b ; }
Ref: 
def pell ( n ) : NEW_LINE INDENT if ( n <= 2 ) : NEW_LINE INDENT return n NEW_LINE DEDENT a = 1 NEW_LINE b = 2 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT c = 2 * b + a NEW_LINE a = b NEW_LINE b = c NEW_LINE DEDENT return b NEW_LINE DEDENT
Hyp: 
def pell ( n ) : NEW_LINE INDENT if ( n <= 2 ) : NEW_LINE INDENT return n NEW_LINE DEDENT a = 1 NEW_LINE b = 2 NEW_LINE c = 0 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT c = 2 * b + a NEW_LINE a = b NEW_LINE b = c NEW_LINE DEDENT return b NEW_LINE DEDENT

BLEU: 92.93
Edit Sim: 15


Src: 
int findMinimum ( int x , int y ) { int low = 0 , high = y ; while ( low <= high ) { int mid = ( low + high ) >> 1 ; if ( ( mid * 2 + ( y - mid ) ) >= x ) high = mid - 1 ; else low = mid + 1 ; } return low ; }
Ref: 
def findMinimum ( x , y ) : NEW_LINE INDENT low = 0 NEW_LINE high = y NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = ( low + high ) >> 1 NEW_LINE if ( ( mid * 2 + ( y - mid ) ) >= x ) : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT DEDENT return low NEW_LINE DEDENT
Hyp: 
def findMinimum ( x , y ) : NEW_LINE INDENT low = 0 NEW_LINE high = y NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = ( low + high ) >> 1 NEW_LINE if ( ( mid * 2 + ( y - mid ) ) >= x ) : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT DEDENT return low NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int nthTerm ( int N ) { int nth = 0 ; nth = ( N * N * ( N + 1 ) ) / 2 ; return nth ; }
Ref: 
def nthTerm ( N ) : NEW_LINE INDENT nth = 0 NEW_LINE nth = ( N * N * ( N + 1 ) ) // 2 NEW_LINE return nth NEW_LINE DEDENT
Hyp: 
def nthTerm ( N ) : NEW_LINE INDENT nth = 0 NEW_LINE nth = ( N * N * ( N + 1 ) ) // 2 NEW_LINE return nth NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int maximumChars ( String str ) { int n = str . length ( ) ; int res = - 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( str . charAt ( i ) == str . charAt ( j ) ) res = Math . max ( res , Math . abs ( j - i - 1 ) ) ; return res ; }
Ref: 
def maximumChars ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE res = - 1 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( str [ i ] == str [ j ] ) : NEW_LINE INDENT res = max ( res , abs ( j - i - 1 ) ) NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT
Hyp: 
def maximumChars ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE res = - 1 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( str [ i ] == str [ j ] ) : NEW_LINE INDENT res = max ( res , abs ( j - i - 1 ) ) NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT

BLEU: 95.87
Edit Sim: 4


Src: 
void findSum ( int a [ ] ) { int ans = 0 ; for ( int low = 0 ; low < a . length ; low ++ ) { for ( int high = low ; high < a . length ; high ++ ) { int count = 0 ; int maxNumber = 0 ; for ( int i = low ; i <= high ; i ++ ) { if ( a [ i ] == maxNumber ) count ++ ; else if ( a [ i ] > maxNumber ) { maxNumber = a [ i ] ; count = 1 ; } } ans += maxNumber * ( ( count % 2 == 0 ) ? 2 : 1 ) ; } } System . out . println ( ans ) ; }
Ref: 
def findSum ( a ) : NEW_LINE INDENT ans = 0 NEW_LINE for low in range ( 0 , len ( a ) ) : NEW_LINE INDENT for high in range ( low , len ( a ) ) : NEW_LINE count = 0 NEW_LINE maxNumber = 0 NEW_LINE for i in range ( low , high + 1 ) : NEW_LINE INDENT if ( a [ i ] == maxNumber ) : NEW_LINE count += 1 NEW_LINE elif ( a [ i ] > maxNumber ) : NEW_LINE maxNumber = a [ i ] NEW_LINE count = 1 NEW_LINE DEDENT if count % 2 : NEW_LINE INDENT ans += maxNumber NEW_LINE DEDENT else : NEW_LINE INDENT ans += maxNumber * 2 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
Hyp: 
def findSum ( a ) : NEW_LINE INDENT ans = 0 ; NEW_LINE for low in range ( len ( a ) ) : NEW_LINE INDENT for high in range ( low , len ( a ) ) : NEW_LINE INDENT count = 0 ; NEW_LINE maxNumber = 0 ; NEW_LINE for i in range ( low , high + 1 ) : NEW_LINE INDENT if ( a [ i ] == maxNumber ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT elif ( a [ i ] > maxNumber ) : NEW_LINE INDENT maxNumber = a [ i ] ; NEW_LINE count = 1 ; NEW_LINE DEDENT DEDENT ans += maxNumber * ( 2 if ( count % 2 == 0 ) else 1 ) ; NEW_LINE DEDENT DEDENT print ( ans ) ; NEW_LINE DEDENT

BLEU: 68.65
Edit Sim: 119


Src: 
int No_of_squares ( int N , int K ) { int no_of_squares = 0 ; no_of_squares = ( N - K + 1 ) * ( N - K + 1 ) ; return no_of_squares ; }
Ref: 
def No_of_squares ( N , K ) : NEW_LINE INDENT no_of_squares = 0 ; NEW_LINE no_of_squares = ( N - K + 1 ) * ( N - K + 1 ) ; NEW_LINE return no_of_squares ; NEW_LINE DEDENT
Hyp: 
def No_of_squares ( N , K ) : NEW_LINE INDENT no_of_squares = 0 NEW_LINE no_of_squares = ( N - K + 1 ) * ( N - K + 1 ) NEW_LINE return no_of_squares NEW_LINE DEDENT

BLEU: 80.32
Edit Sim: 6


Src: 
int minimumNumbers ( int n , int s ) { if ( ( s % n ) > 0 ) return s / n + 1 ; else return s / n ; }
Ref: 
def minimumNumbers ( n , s ) : NEW_LINE INDENT if ( s % n ) : NEW_LINE INDENT return s / n + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT return s / n ; NEW_LINE DEDENT DEDENT
Hyp: 
def minimumNumbers ( n , s ) : NEW_LINE INDENT if ( s % n ) : NEW_LINE INDENT return s // n + 1 NEW_LINE DEDENT else : NEW_LINE INDENT return s // n NEW_LINE DEDENT DEDENT

BLEU: 75.59
Edit Sim: 6


Src: 
int MatrixChainOrder ( int p [ ] , int n ) { int [ ] [ ] dp = new int [ n ] [ n ] ; for ( int i = 1 ; i < n ; i ++ ) dp [ i ] [ i ] = 0 ; for ( int L = 1 ; L < n - 1 ; L ++ ) for ( int i = 1 ; i < n - L ; i ++ ) dp [ i ] [ i + L ] = Math . min ( dp [ i + 1 ] [ i + L ] + p [ i - 1 ] * p [ i ] * p [ i + L ] , dp [ i ] [ i + L - 1 ] + p [ i - 1 ] * p [ i + L - 1 ] * p [ i + L ] ) ; return dp [ 1 ] [ n - 1 ] ; }
Ref: 
def MatrixChainOrder ( p , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT dp [ i ] [ i ] = 0 NEW_LINE DEDENT for L in range ( 1 , n - 1 ) : NEW_LINE INDENT for i in range ( n - L ) : NEW_LINE INDENT dp [ i ] [ i + L ] = min ( dp [ i + 1 ] [ i + L ] + p [ i - 1 ] * p [ i ] * p [ i + L ] , dp [ i ] [ i + L - 1 ] + p [ i - 1 ] * p [ i + L - 1 ] * p [ i + L ] ) NEW_LINE DEDENT DEDENT return dp [ 1 ] [ n - 1 ] NEW_LINE DEDENT
Hyp: 
def MatrixChainOrder ( p , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT dp [ i ] [ i ] = 0 NEW_LINE DEDENT for L in range ( 1 , n - 1 ) : NEW_LINE INDENT for i in range ( 1 , n - L ) : NEW_LINE INDENT dp [ i ] [ i + L ] = min ( dp [ i + 1 ] [ i + L ] + p [ i - 1 ] * p [ i ] * p [ i + L ] , dp [ i ] [ i + L - 1 ] + p [ i - 1 ] * p [ i + L - 1 ] * p [ i + L ] ) NEW_LINE DEDENT DEDENT return dp [ 1 ] [ n - 1 ] NEW_LINE DEDENT

BLEU: 92.71
Edit Sim: 13


Src: 
float productOfGP ( float a , float r , int n ) { float product = 1 ; for ( int i = 0 ; i < n ; i ++ ) { product = product * a ; a = a * r ; } return product ; }
Ref: 
def productOfGP ( a , r , n ) : NEW_LINE INDENT product = 1 ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT product = product * a ; NEW_LINE a = a * r ; NEW_LINE DEDENT return product ; NEW_LINE DEDENT
Hyp: 
def productOfGP ( a , r , n ) : NEW_LINE INDENT product = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT product = product * a NEW_LINE a = a * r NEW_LINE DEDENT return product NEW_LINE DEDENT

BLEU: 70.97
Edit Sim: 12


Src: 
int getMinCost ( int n , int m ) { int cost = ( n - 1 ) * m + ( m - 1 ) * n ; return cost ; }
Ref: 
def getMinCost ( n , m ) : NEW_LINE INDENT cost = ( n - 1 ) * m + ( m - 1 ) * n NEW_LINE return cost NEW_LINE DEDENT
Hyp: 
def getMinCost ( n , m ) : NEW_LINE INDENT cost = ( n - 1 ) * m + ( m - 1 ) * n NEW_LINE return cost NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int countBuildings ( int arr [ ] , int n ) { int count = 1 ; int curr_max = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > curr_max arr [ i ] == curr_max ) { count ++ ; curr_max = arr [ i ] ; } } return count ; }
Ref: 
def countBuildings ( arr , n ) : NEW_LINE INDENT count = 1 NEW_LINE curr_max = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] > curr_max or arr [ i ] == curr_max ) : NEW_LINE INDENT count += 1 NEW_LINE curr_max = arr [ i ] NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
Hyp: 
def countBuildings ( arr , n ) : NEW_LINE INDENT count = 1 NEW_LINE curr_max = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] > curr_max or arr [ i ] == curr_max ) : NEW_LINE INDENT count = count + 1 NEW_LINE curr_max = arr [ i ] NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT

BLEU: 93.58
Edit Sim: 9


Src: 
int Triplets ( int n ) { int ans = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = i ; j <= n ; ++ j ) { int x = i * i + j * j ; int y = ( int ) Math . sqrt ( x ) ; if ( y * y == x && y <= n ) ++ ans ; } } return ans ; }
Ref: 
def Triplets ( n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( i , n + 1 ) : NEW_LINE INDENT x = i * i + j * j NEW_LINE y = int ( math . sqrt ( x ) ) NEW_LINE if ( y * y == x and y <= n ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
Hyp: 
def Triplets ( n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( i , n + 1 ) : NEW_LINE INDENT x = i * i + j * j NEW_LINE y = int ( math . sqrt ( x ) ) NEW_LINE if ( y * y == x and y <= n ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
boolean istetradecagonal ( int N ) { double n = ( 10 + Math . sqrt ( 96 * N + 100 ) ) / 24 ; return ( n - ( int ) n ) == 0 ; }
Ref: 
def istetradecagonal ( N ) : NEW_LINE INDENT n = ( 10 + math . sqrt ( 96 * N + 100 ) ) / 24 NEW_LINE if ( n - int ( n ) ) == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT N = 11 NEW_LINE if ( istetradecagonal ( N ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
Hyp: 
def istetradecagonal ( N ) : NEW_LINE INDENT n = ( 10 + math . sqrt ( 96 * N + 100 ) ) // 24 NEW_LINE return ( ( n - int ( n ) ) == 0 ) NEW_LINE DEDENT

BLEU: 31.26
Edit Sim: 213


Src: 
String checkNumber ( int N ) { int temp = N ; while ( temp > 0 ) { if ( temp % 1000 == 144 ) temp /= 1000 ; else if ( temp % 100 == 14 ) temp /= 100 ; else if ( temp % 10 == 1 ) temp /= 10 ; else { return " NO " ; } } return " YES " ; }
Ref: 
def checkNumber ( N ) : NEW_LINE INDENT temp = N NEW_LINE while ( temp > 0 ) : NEW_LINE INDENT if ( temp % 1000 == 144 ) : NEW_LINE INDENT temp /= 1000 NEW_LINE DEDENT elif ( temp % 100 == 14 ) : NEW_LINE INDENT temp /= 100 NEW_LINE DEDENT elif ( temp % 10 == 1 ) : NEW_LINE INDENT temp /= 10 NEW_LINE DEDENT else : NEW_LINE INDENT return " YES " NEW_LINE DEDENT DEDENT return " NO " NEW_LINE DEDENT
Hyp: 
def checkNumber ( N ) : NEW_LINE INDENT temp = N NEW_LINE while ( temp > 0 ) : NEW_LINE INDENT if ( temp % 1000 == 144 ) : NEW_LINE INDENT temp //= 1000 NEW_LINE DEDENT elif ( temp % 100 == 14 ) : NEW_LINE INDENT temp //= 100 NEW_LINE DEDENT elif ( temp % 10 == 1 ) : NEW_LINE INDENT temp //= 10 NEW_LINE DEDENT else : NEW_LINE INDENT return " NO " NEW_LINE DEDENT DEDENT return " YES " NEW_LINE DEDENT

BLEU: 90.45
Edit Sim: 9


Src: 
void maxPairs ( int [ ] nums , int k ) { Arrays . sort ( nums ) ; int result = 0 ; int start = 0 , end = nums . length - 1 ; while ( start < end ) { if ( nums [ start ] + nums [ end ] > k ) end -- ; else if ( nums [ start ] + nums [ end ] < k ) start ++ ; else { start ++ ; end -- ; result ++ ; } } System . out . println ( result ) ; }
Ref: 
def maxPairs ( nums , k ) : NEW_LINE INDENT nums = sorted ( nums ) NEW_LINE result = 0 NEW_LINE start , end = 0 , len ( nums ) - 1 NEW_LINE while ( start < end ) : NEW_LINE INDENT if ( nums [ start ] + nums [ end ] > k ) : NEW_LINE INDENT end -= 1 NEW_LINE DEDENT elif ( nums [ start ] + nums [ end ] < k ) : NEW_LINE INDENT start += 1 NEW_LINE DEDENT else : NEW_LINE INDENT start += 1 NEW_LINE end -= 1 NEW_LINE result += 1 NEW_LINE DEDENT DEDENT print ( result ) NEW_LINE DEDENT
Hyp: 
def maxPairs ( nums , k ) : NEW_LINE INDENT nums . sort ( ) NEW_LINE result = 0 NEW_LINE start = 0 NEW_LINE end = len ( nums ) - 1 NEW_LINE while start < end : NEW_LINE INDENT if ( nums [ start ] + nums [ end ] > k ) : NEW_LINE INDENT end -= 1 NEW_LINE DEDENT elif ( nums [ start ] + nums [ end ] < k ) : NEW_LINE INDENT start += 1 NEW_LINE DEDENT else : NEW_LINE INDENT start += 1 NEW_LINE DEDENT DEDENT print ( result ) NEW_LINE DEDENT

BLEU: 78.69
Edit Sim: 66


Src: 
void findElements ( int arr [ ] , int n ) { int first = Integer . MIN_VALUE ; int second = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > first ) { second = first ; first = arr [ i ] ; } else if ( arr [ i ] > second ) second = arr [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] < second ) System . out . print ( arr [ i ] + " ▁ " ) ; }
Ref: 
def findElements ( arr , n ) : NEW_LINE INDENT first = - sys . maxsize NEW_LINE second = - sys . maxsize NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] > first ) : NEW_LINE INDENT second = first NEW_LINE first = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > second ) : NEW_LINE INDENT second = arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] < second ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
Hyp: 
def findElements ( arr , n ) : NEW_LINE INDENT first = - 2147483648 NEW_LINE second = - 2147483648 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] > first ) : NEW_LINE INDENT second = first NEW_LINE first = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > second ) : NEW_LINE INDENT second = arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] < second ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT

BLEU: 86.53
Edit Sim: 34


Src: 
void group_formed ( String S ) { int count = 1 ; for ( int i = 0 ; i < S . length ( ) - 1 ; i ++ ) { if ( S . charAt ( i ) != S . charAt ( i + 1 ) ) count += 1 ; } System . out . println ( count ) ; }
Ref: 
def group_formed ( S ) : NEW_LINE INDENT count = 1 NEW_LINE for i in range ( len ( S ) - 1 ) : NEW_LINE INDENT a = S [ i ] NEW_LINE b = S [ i + 1 ] NEW_LINE if ( a != b ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT
Hyp: 
def group_formed ( S ) : NEW_LINE INDENT count = 1 NEW_LINE for i in range ( len ( S ) - 1 ) : NEW_LINE INDENT if ( S [ i ] != S [ i + 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT

BLEU: 76.05
Edit Sim: 35


Src: 
int Series ( int n ) { int i ; int sums = 0 ; for ( i = 1 ; i <= n ; i ++ ) sums += ( i * i ) ; return sums ; }
Ref: 
def Series ( n ) : NEW_LINE INDENT sums = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sums += ( i * i ) ; NEW_LINE DEDENT return sums NEW_LINE DEDENT
Hyp: 
def Series ( n ) : NEW_LINE INDENT sums = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sums += ( i * i ) NEW_LINE DEDENT return sums NEW_LINE DEDENT

BLEU: 93.54
Edit Sim: 2


Src: 
int maxRightmostElement ( int N , int k , int p , int arr [ ] ) { int ans = arr [ N - 1 ] ; for ( int i = N - 2 ; i >= 0 ; i -- ) { int d = Math . min ( arr [ i ] / p , k / ( N - 1 - i ) ) ; k -= d * ( N - 1 - i ) ; ans += d * p ; } return ans ; }
Ref: 
def maxRightmostElement ( N , k , arr ) : NEW_LINE INDENT ans = arr [ N - 1 ] NEW_LINE i = N - 2 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT d = min ( arr [ i ] // 2 , k // ( N - 1 - i ) ) NEW_LINE k -= d * ( N - 1 - i ) NEW_LINE ans += d * 2 NEW_LINE i -= 1 NEW_LINE DEDENT print ( ans , end = " ▁ " ) NEW_LINE DEDENT
Hyp: 
def maxRightmostElement ( N , k , p , arr ) : NEW_LINE INDENT ans = arr [ N - 1 ] NEW_LINE for i in range ( N - 2 , - 1 , - 1 ) : NEW_LINE INDENT d = min ( arr [ i ] // p , k // ( N - 1 - i ) ) NEW_LINE k -= d * ( N - 1 - i ) NEW_LINE ans += d * p NEW_LINE DEDENT return ans NEW_LINE DEDENT

BLEU: 66.48
Edit Sim: 70


Src: 
boolean isPossible ( Integer a [ ] , int b [ ] , int n , int k ) { Arrays . sort ( a , Collections . reverseOrder ( ) ) ; Arrays . sort ( b ) ; for ( int i = 0 ; i < n ; i ++ ) if ( a [ i ] + b [ i ] < k ) return false ; return true ; }
Ref: 
def isPossible ( a , b , n , k ) : NEW_LINE INDENT a . sort ( reverse = True ) NEW_LINE b . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] + b [ i ] < k ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT a = [ 2 , 1 , 3 ] NEW_LINE b = [ 7 , 8 , 9 ] NEW_LINE k = 10 NEW_LINE n = len ( a ) NEW_LINE if ( isPossible ( a , b , n , k ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
Hyp: 
def isPossible ( a , b , n , k ) : NEW_LINE INDENT a . sort ( reverse = True ) NEW_LINE b . sort ( reverse = True ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] + b [ i ] < k ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT a = [ 2 , 3 , 4 , 5 ] NEW_LINE b = [ 5 , 4 , 8 , 7 ] NEW_LINE n = len ( a ) NEW_LINE k = 4 NEW_LINE if ( isPossible ( a , b , n , k ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT

BLEU: 81.0
Edit Sim: 50


Src: 
int countSolutions ( int n , int val ) { int total = 0 ; if ( n == 1 && val >= 0 ) return 1 ; for ( int i = 0 ; i <= val ; i ++ ) { total += countSolutions ( n - 1 , val - i ) ; } return total ; }
Ref: 
def countSolutions ( n , val ) : NEW_LINE INDENT total = 0 NEW_LINE if n == 1 and val >= 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT for i in range ( val + 1 ) : NEW_LINE INDENT total += countSolutions ( n - 1 , val - i ) NEW_LINE DEDENT return total NEW_LINE DEDENT
Hyp: 
def countSolutions ( n , val ) : NEW_LINE INDENT total = 0 NEW_LINE if ( n == 1 and val >= 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT for i in range ( val + 1 ) : NEW_LINE INDENT total += countSolutions ( n - 1 , val - i ) NEW_LINE DEDENT return total NEW_LINE DEDENT

BLEU: 91.58
Edit Sim: 4


Src: 
void isPossible ( int W , int B , int D ) { if ( W > B ) { int temp = W ; W = B ; B = temp ; } if ( B > W * ( D + 1 ) ) System . out . println ( " NO " ) ; else System . out . println ( " YES " ) ; }
Ref: 
def isPossible ( W , B , D ) : NEW_LINE INDENT if ( W > B ) : NEW_LINE INDENT temp = W NEW_LINE W = B NEW_LINE B = temp NEW_LINE DEDENT if ( B > W * ( D + 1 ) ) : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT DEDENT
Hyp: 
def isPossible ( W , B , D ) : NEW_LINE INDENT if ( W > B ) : NEW_LINE INDENT temp = W NEW_LINE W = B NEW_LINE B = temp NEW_LINE DEDENT if ( B > W * ( D + 1 ) ) : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int getCount ( String a , String b ) { if ( b . length ( ) % a . length ( ) != 0 ) return - 1 ; int count = b . length ( ) / a . length ( ) ; String str = " " ; for ( int i = 0 ; i < count ; i ++ ) { str = str + a ; } if ( str . equals ( b ) ) return count ; return - 1 ; }
Ref: 
def getCount ( a , b ) : NEW_LINE INDENT if ( len ( b ) % len ( a ) != 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT count = int ( len ( b ) / len ( a ) ) NEW_LINE a = a * count NEW_LINE if ( a == b ) : NEW_LINE INDENT return count NEW_LINE DEDENT return - 1 ; NEW_LINE DEDENT
Hyp: 
def getCount ( a , b ) : NEW_LINE INDENT if ( len ( b ) % len ( a ) != 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT count = len ( b ) // len ( a ) NEW_LINE str = " " NEW_LINE for i in range ( count ) : NEW_LINE INDENT str = str + a NEW_LINE DEDENT if ( str == b ) : NEW_LINE INDENT return count NEW_LINE DEDENT return - 1 NEW_LINE DEDENT

BLEU: 61.21
Edit Sim: 85


Src: 
void printPair ( int n ) { System . out . print ( 1 + " ▁ " + ( n - 1 ) ) ; }
Ref: 
def printPair ( n ) : NEW_LINE INDENT print ( "1" , end = " ▁ " ) NEW_LINE print ( n - 1 ) NEW_LINE DEDENT
Hyp: 
def printPair ( n ) : NEW_LINE INDENT print ( 1 , " ▁ " , ( n - 1 ) ) NEW_LINE DEDENT

BLEU: 58.33
Edit Sim: 26


Src: 
int lengthOfLastWord ( final String a ) { int len = 0 ; String x = a . trim ( ) ; for ( int i = 0 ; i < x . length ( ) ; i ++ ) { if ( x . charAt ( i ) == ' ▁ ' ) len = 0 ; else len ++ ; } return len ; }
Ref: 
def lengthOfLastWord ( a ) : NEW_LINE INDENT l = 0 NEW_LINE x = a . strip ( ) NEW_LINE for i in range ( len ( x ) ) : NEW_LINE INDENT if x [ i ] == " ▁ " : NEW_LINE INDENT l = 0 NEW_LINE DEDENT else : NEW_LINE INDENT l += 1 NEW_LINE DEDENT DEDENT return l NEW_LINE DEDENT
Hyp: 
def lengthOfLastWord ( a ) : NEW_LINE INDENT l = 0 NEW_LINE x = a NEW_LINE for i in range ( len ( x ) ) : NEW_LINE INDENT if ( x [ i ] == ' ▁ ' ) : NEW_LINE INDENT l = 0 NEW_LINE DEDENT else : NEW_LINE INDENT l += 1 NEW_LINE DEDENT DEDENT return l NEW_LINE DEDENT

BLEU: 82.61
Edit Sim: 18


Src: 
int checkpoint ( int h , int k , int x , int y , int a , int b ) { int p = ( ( int ) Math . pow ( ( x - h ) , 2 ) / ( int ) Math . pow ( a , 2 ) ) + ( ( int ) Math . pow ( ( y - k ) , 2 ) / ( int ) Math . pow ( b , 2 ) ) ; return p ; }
Ref: 
def checkpoint ( h , k , x , y , a , b ) : NEW_LINE INDENT p = ( ( math . pow ( ( x - h ) , 2 ) // math . pow ( a , 2 ) ) + ( math . pow ( ( y - k ) , 2 ) // math . pow ( b , 2 ) ) ) NEW_LINE return p NEW_LINE DEDENT
Hyp: 
def checkpoint ( h , k , x , y , a , b ) : NEW_LINE INDENT p = ( ( pow ( x - h ) , 2 ) / pow ( a , 2 ) ) + ( pow ( ( y - k ) , 2 ) / pow ( b , 2 ) ) ; NEW_LINE return p ; NEW_LINE DEDENT

BLEU: 69.85
Edit Sim: 35


Src: 
void findTangent ( int A , int x , int y ) { int dif = A - x * 2 ; if ( y == ( 2 * x - x * x ) ) { if ( dif < 0 ) System . out . println ( " y ▁ = ▁ " + dif + " x " + ( x * dif + y ) ) ; else if ( dif > 0 ) System . out . println ( " y ▁ = ▁ " + dif + " x + " + - x * dif + y ) ; else System . out . println ( " Not ▁ possible " ) ; } }
Ref: 
def findTangent ( A , x , y ) : NEW_LINE INDENT dif = A - x * 2 NEW_LINE if y == ( 2 * x - x * x ) : NEW_LINE INDENT if dif < 0 : NEW_LINE INDENT print ( " y ▁ = " , dif , " x " , ( x * dif ) + ( y ) ) NEW_LINE DEDENT elif dif > 0 : NEW_LINE INDENT print ( " y ▁ = " , dif , " x + " , - x * dif + y ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ Possible " ) NEW_LINE DEDENT DEDENT DEDENT
Hyp: 
def findTangent ( A , x , y ) : NEW_LINE INDENT dif = A - x * 2 NEW_LINE if ( y == ( 2 * x - x * x ) ) : NEW_LINE INDENT if ( dif < 0 ) : NEW_LINE INDENT print ( " y ▁ = " , dif , " x " , ( x * dif + y ) ) NEW_LINE DEDENT elif ( dif > 0 ) : NEW_LINE INDENT print ( " y ▁ = " , dif , " x + " , - x * dif + y ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ possible " ) NEW_LINE DEDENT DEDENT

BLEU: 83.97
Edit Sim: 24


Src: 
void product_subarrays ( int arr [ ] , int n ) { int product = 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { for ( int k = i ; k <= j ; k ++ ) product *= arr [ k ] ; } } System . out . print ( product + "NEW_LINE"); }
Ref: 
def product_subarrays ( arr , n ) : NEW_LINE INDENT product = 1 ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT for k in range ( i , j + 1 ) : NEW_LINE INDENT product *= arr [ k ] ; NEW_LINE DEDENT DEDENT DEDENT print ( product ,   " " ) ; NEW_LINE DEDENT
Hyp: 
def product_subarrays ( arr , n ) : NEW_LINE INDENT product = 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT for k in range ( i , j + 1 ) : NEW_LINE INDENT product *= arr [ k ] NEW_LINE DEDENT DEDENT DEDENT print ( product , end = " " ) NEW_LINE DEDENT

BLEU: 87.82
Edit Sim: 10


Src: 
int printNthElement ( int n ) { int arr [ ] = new int [ n + 1 ] ; arr [ 1 ] = 4 ; arr [ 2 ] = 7 ; for ( int i = 3 ; i <= n ; i ++ ) { if ( i % 2 != 0 ) arr [ i ] = arr [ i / 2 ] * 10 + 4 ; else arr [ i ] = arr [ ( i / 2 ) - 1 ] * 10 + 7 ; } return arr [ n ] ; }
Ref: 
def printNthElement ( n ) : NEW_LINE INDENT arr = [ 0 ] * ( n + 1 ) ; NEW_LINE arr [ 1 ] = 4 NEW_LINE arr [ 2 ] = 7 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT if ( i % 2 != 0 ) : NEW_LINE INDENT arr [ i ] = arr [ i // 2 ] * 10 + 4 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = arr [ ( i // 2 ) - 1 ] * 10 + 7 NEW_LINE DEDENT DEDENT return arr [ n ] NEW_LINE DEDENT
Hyp: 
def printNthElement ( n ) : NEW_LINE INDENT arr = [ 0 for i in range ( n + 1 ) ] NEW_LINE arr [ 0 ] = 4 NEW_LINE arr [ 1 ] = 4 NEW_LINE arr [ 2 ] = 7 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT if ( i % 2 != 0 ) : NEW_LINE INDENT arr [ i ] = arr [ i // 2 ] * 10 + 4 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = arr [ ( i // 2 ) - 1 ] * 10 + 7 NEW_LINE DEDENT DEDENT return arr [ n ] NEW_LINE DEDENT

BLEU: 87.92
Edit Sim: 37


Src: 
long cntEvenSumPairs ( long X , long Y ) { long cntXEvenNums = X / 2 ; long cntXOddNums = ( X + 1 ) / 2 ; long cntYEvenNums = Y / 2 ; long cntYOddNums = ( Y + 1 ) / 2 ; long cntPairs = ( cntXEvenNums * cntYEvenNums ) + ( cntXOddNums * cntYOddNums ) ; return cntPairs ; }
Ref: 
def cntEvenSumPairs ( X , Y ) : NEW_LINE INDENT cntXEvenNums = X / 2 NEW_LINE cntXOddNums = ( X + 1 ) / 2 NEW_LINE cntYEvenNums = Y / 2 NEW_LINE cntYOddNums = ( Y + 1 ) / 2 NEW_LINE cntPairs = ( ( cntXEvenNums * cntYEvenNums ) + ( cntXOddNums * cntYOddNums ) ) NEW_LINE return cntPairs NEW_LINE DEDENT
Hyp: 
def cntEvenSumPairs ( X , Y ) : NEW_LINE INDENT cntXEvenNums = X // 2 NEW_LINE cntXOddNums = ( X + 1 ) // 2 NEW_LINE cntYEvenNums = Y // 2 NEW_LINE cntYOddNums = ( Y + 1 ) // 2 NEW_LINE cntPairs = ( cntXEvenNums * cntYEvenNums ) + ( cntXOddNums * cntYOddNums ) NEW_LINE return cntPairs NEW_LINE DEDENT

BLEU: 77.14
Edit Sim: 8


Src: 
int countTriplets ( int arr [ ] , int n ) { int odd = 0 , even = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] & 1 ) != 0 ) odd ++ ; else even ++ ; } int c1 = odd * ( even * ( even - 1 ) ) / 2 ; int c2 = ( odd * ( odd - 1 ) * ( odd - 2 ) ) / 6 ; return c1 + c2 ; }
Ref: 
def countTriplets ( arr , n ) : NEW_LINE INDENT odd = 0 NEW_LINE even = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] & 1 ) : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT else : NEW_LINE INDENT even += 1 NEW_LINE DEDENT DEDENT c1 = odd * ( even * ( even - 1 ) ) // 2 NEW_LINE c2 = ( odd * ( odd - 1 ) * ( odd - 2 ) ) // 6 NEW_LINE return c1 + c2 NEW_LINE DEDENT
Hyp: 
def countTriplets ( arr , n ) : NEW_LINE INDENT odd = 0 ; even = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] & 1 ) : NEW_LINE INDENT odd += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT even += 1 ; NEW_LINE DEDENT DEDENT c1 = odd * ( even * ( even - 1 ) ) // 2 ; NEW_LINE c2 = ( odd * ( odd - 1 ) * ( odd - 2 ) ) // 6 ; NEW_LINE return c1 + c2 ; NEW_LINE DEDENT

BLEU: 82.75
Edit Sim: 20


Src: 
void print ( int n , int k ) { System . out . print ( k + " ▁ " ) ; for ( int i = 2 ; i <= n ; i ++ ) { int x = ( int ) ( Math . pow ( k , i ) - Math . pow ( k , i - 1 ) ) ; System . out . print ( x + " ▁ " ) ; } }
Ref: 
def printf ( n , k ) : NEW_LINE INDENT print ( int ( k ) , end = " ▁ " ) NEW_LINE for i in range ( 2 , n + 1 , 1 ) : NEW_LINE INDENT x = pow ( k , i ) - pow ( k , i - 1 ) NEW_LINE print ( int ( x ) , end = " ▁ " ) NEW_LINE DEDENT DEDENT
Hyp: 
def print ( n , k ) : NEW_LINE INDENT print ( k , end = " ▁ " ) NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT x = ( pow ( k , i ) - pow ( k , i - 1 ) ) NEW_LINE print ( x , end = " ▁ " ) NEW_LINE DEDENT DEDENT

BLEU: 76.91
Edit Sim: 25


Src: 
int averageValue ( String s ) { int sum_char = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { sum_char += ( int ) s . charAt ( i ) ; } return sum_char / s . length ( ) ; }
Ref: 
def averageValue ( s ) : NEW_LINE INDENT sum_char = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT sum_char += ord ( s [ i ] ) NEW_LINE DEDENT return sum_char // len ( s ) NEW_LINE DEDENT
Hyp: 
def averageValue ( s ) : NEW_LINE INDENT sum_char = 0 NEW_LINE for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT sum_char += int ( s [ i ] ) NEW_LINE DEDENT return int ( sum_char / len ( s ) ) NEW_LINE DEDENT

BLEU: 72.88
Edit Sim: 16


Src: 
int minJumps ( int arr [ ] , int N ) { int MAX = 1000000 ; int [ ] fib = new int [ 30 ] ; fib [ 0 ] = 0 ; fib [ 1 ] = 1 ; for ( int i = 2 ; i < 30 ; i ++ ) fib [ i ] = fib [ i - 1 ] + fib [ i - 2 ] ; int [ ] DP = new int [ N + 2 ] ; DP [ 0 ] = 0 ; for ( int i = 1 ; i <= N + 1 ; i ++ ) DP [ i ] = MAX ; for ( int i = 1 ; i <= N + 1 ; i ++ ) { for ( int j = 1 ; j < 30 ; j ++ ) { if ( ( i == N + 1 arr [ i - 1 ] == 1 ) && i - fib [ j ] >= 0 ) DP [ i ] = Math . min ( DP [ i ] , 1 + DP [ i - fib [ j ] ] ) ; } } if ( DP [ N + 1 ] != MAX ) return DP [ N + 1 ] ; else return - 1 ; }
Ref: 
def minJumps ( arr , N ) : NEW_LINE INDENT fib = [ 0 for i in range ( 30 ) ] NEW_LINE fib [ 0 ] = 0 NEW_LINE fib [ 1 ] = 1 NEW_LINE for i in range ( 2 , 30 ) : NEW_LINE INDENT fib [ i ] = fib [ i - 1 ] + fib [ i - 2 ] NEW_LINE DEDENT DP = [ 0 for i in range ( N + 2 ) ] NEW_LINE DP [ 0 ] = 0 NEW_LINE for i in range ( 1 , N + 2 ) : NEW_LINE INDENT DP [ i ] = MAX NEW_LINE DEDENT for i in range ( 1 , N + 2 ) : NEW_LINE INDENT for j in range ( 1 , 30 ) : NEW_LINE INDENT if ( ( arr [ i - 1 ] == 1 or i == N + 1 ) and i - fib [ j ] >= 0 ) : NEW_LINE INDENT DP [ i ] = min ( DP [ i ] , 1 + DP [ i - fib [ j ] ] ) NEW_LINE DEDENT DEDENT DEDENT if ( DP [ N + 1 ] != MAX ) : NEW_LINE INDENT return DP [ N + 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT
Hyp: 
def minJumps ( arr , N ) : NEW_LINE INDENT MAX = 1000000 NEW_LINE fib = [ 0 ] * 30 NEW_LINE fib [ 0 ] = 0 NEW_LINE fib [ 1 ] = 1 NEW_LINE for i in range ( 2 , 30 ) : NEW_LINE INDENT fib [ i ] = fib [ i - 1 ] + fib [ i - 2 ] NEW_LINE DEDENT DP = [ 0 ] * ( N + 2 ) NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT DP [ i ] = MAX NEW_LINE DEDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( 1 , 30 ) : NEW_LINE INDENT if ( ( i == N + 1 or arr [ i - 1 ] == 1 ) and i - fib [ j ] >= 0 ) : NEW_LINE INDENT DP [ i ] = min ( DP [ i ] , 1 + DP [ i - fib [ j ] ] ) NEW_LINE DEDENT DEDENT DEDENT if ( DP [ N + 1 ] != MAX ) : NEW_LINE INDENT return DP [ N + 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT

BLEU: 85.42
Edit Sim: 89


Src: 
int hammingDist ( String str1 , String str2 ) { int i = 0 , count = 0 ; while ( i < str1 . length ( ) ) { if ( str1 . charAt ( i ) != str2 . charAt ( i ) ) count ++ ; i ++ ; } return count ; }
Ref: 
def hammingDist ( str1 , str2 ) : NEW_LINE INDENT i = 0 NEW_LINE count = 0 NEW_LINE while ( i < len ( str1 ) ) : NEW_LINE INDENT if ( str1 [ i ] != str2 [ i ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
Hyp: 
def hammingDist ( str1 , str2 ) : NEW_LINE INDENT i = 0 NEW_LINE count = 0 NEW_LINE while ( i < len ( str1 ) ) : NEW_LINE INDENT if ( str1 [ i ] != str2 [ i ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
void maximumSum ( int a [ ] , int b [ ] , int k , int n ) { int i , j ; Arrays . sort ( a ) ; Arrays . sort ( b ) ; for ( i = 0 , j = n - 1 ; i < k ; i ++ , j -- ) { if ( a [ i ] < b [ j ] ) { int temp = a [ i ] ; a [ i ] = b [ j ] ; b [ j ] = temp ; } else break ; } int sum = 0 ; for ( i = 0 ; i < n ; i ++ ) sum += a [ i ] ; System . out . print ( sum + "NEW_LINE"); }
Ref: 
def maximumSum ( a , b , k , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE b . sort ( ) NEW_LINE i = 0 NEW_LINE j = n - 1 NEW_LINE while i < k : NEW_LINE INDENT if ( a [ i ] < b [ j ] ) : NEW_LINE INDENT a [ i ] , b [ j ] = b [ j ] , a [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += a [ i ] NEW_LINE DEDENT print ( sum ) NEW_LINE DEDENT
Hyp: 
def maximumSum ( a , b , k , n ) : NEW_LINE INDENT a . sort ( reverse = False ) NEW_LINE b . sort ( reverse = False ) NEW_LINE i = 0 ; j = n - 1 ; NEW_LINE while ( i < k ) : NEW_LINE INDENT if ( a [ i ] < b [ j ] ) : NEW_LINE INDENT temp = a [ i ] NEW_LINE a [ i ] = b [ j ] NEW_LINE b [ j ] = temp NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += a [ i ] NEW_LINE DEDENT print ( sum ) NEW_LINE DEDENT

BLEU: 74.72
Edit Sim: 108


Src: 
int getMinCost ( Integer arr [ ] , int n ) { int min_ele = Collections . min ( Arrays . asList ( arr ) ) ; return min_ele * ( n - 1 ) ; }
Ref: 
def getMinCost ( arr , n ) : NEW_LINE INDENT min_ele = min ( arr ) NEW_LINE return min_ele * ( n - 1 ) NEW_LINE DEDENT
Hyp: 
def getMinCost ( arr , n ) : NEW_LINE INDENT min_ele = min ( arr ) NEW_LINE return min_ele * ( n - 1 ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int icosikaioctagonalNum ( int n ) { return ( 26 * n * n - 24 * n ) / 2 ; }
Ref: 
def icosikaioctagonalNum ( n ) : NEW_LINE INDENT return ( 26 * n * n - 24 * n ) // 2 NEW_LINE DEDENT
Hyp: 
def icosikaioctagonalNum ( n ) : NEW_LINE INDENT return ( 26 * n * n - 24 * n ) // 2 NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int MinOperation ( int a [ ] , int n , int k ) { int result = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( a [ i ] != 1 && a [ i ] > k ) { result = result + Math . min ( a [ i ] % k , k - a [ i ] % k ) ; } else { result = result + k - a [ i ] ; } } return result ; }
Ref: 
def MinOperation ( a , n , k ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] != 1 and a [ i ] > k ) : NEW_LINE INDENT result = ( result + min ( a [ i ] % k , k - a [ i ] % k ) ) NEW_LINE DEDENT else : NEW_LINE INDENT result = result + k - a [ i ] NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
Hyp: 
def MinOperation ( a , n , k ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( a [ i ] != 1 and a [ i ] > k ) : NEW_LINE INDENT result = result + min ( a [ i ] % k , k - a [ i ] % k ) NEW_LINE DEDENT else : NEW_LINE INDENT result = result + k - a [ i ] NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT

BLEU: 93.61
Edit Sim: 8


Src: 
float sumOfAP ( float a , float d , float n ) { float sum = ( n / 2 ) * ( 2 * a + ( n - 1 ) * d ) ; return sum ; }
Ref: 
def sumOfAP ( a , d , n ) : NEW_LINE INDENT sum = ( n / 2 ) * ( 2 * a + ( n - 1 ) * d ) NEW_LINE return sum NEW_LINE DEDENT
Hyp: 
def sumOfAP ( a , d , n ) : NEW_LINE INDENT sum = ( n / 2 ) * ( 2 * a + ( n - 1 ) * d ) NEW_LINE return sum NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
String GeberateDefangIP ( String str ) { String defangIP = " " ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char c = str . charAt ( i ) ; if ( c == ' . ' ) { defangIP += " [ . ] " ; } else { defangIP += c ; } } return defangIP ; }
Ref: 
def GeberateDefangIP ( str ) : NEW_LINE INDENT defangIP = " " ; NEW_LINE for c in str : NEW_LINE INDENT if ( c == ' . ' ) : NEW_LINE INDENT defangIP += " [ . ] " NEW_LINE DEDENT else : NEW_LINE INDENT defangIP += c ; NEW_LINE DEDENT DEDENT return defangIP ; NEW_LINE DEDENT
Hyp: 
def GeberateDefangIP ( str ) : NEW_LINE INDENT defangIP = " " NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT c = str [ i ] NEW_LINE if ( c == ' . ' ) : NEW_LINE INDENT defangIP += " [ . ] " NEW_LINE DEDENT else : NEW_LINE INDENT defangIP += c NEW_LINE DEDENT DEDENT return defangIP NEW_LINE DEDENT

BLEU: 65.71
Edit Sim: 48


Src: 
int sumOfSeries ( int n ) { int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) ans += i * i * i * i ; return ans ; }
Ref: 
def sumOfSeries ( n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans = ans + i * i * i * i NEW_LINE DEDENT return ans NEW_LINE DEDENT
Hyp: 
def sumOfSeries ( n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans += i * i * i * i NEW_LINE DEDENT return ans NEW_LINE DEDENT

BLEU: 89.24
Edit Sim: 7


Src: 
int cntWays ( String str , int n ) { int x = n + 1 ; int ways = x * x * ( x * x - 1 ) / 12 ; return ways ; }
Ref: 
def cntWays ( string , n ) : NEW_LINE INDENT x = n + 1 ; NEW_LINE ways = x * x * ( x * x - 1 ) // 12 ; NEW_LINE return ways ; NEW_LINE DEDENT
Hyp: 
def cntWays ( string , n ) : NEW_LINE INDENT x = n + 1 NEW_LINE ways = x * x * ( x * x - 1 ) // 12 NEW_LINE return ways NEW_LINE DEDENT

BLEU: 80.32
Edit Sim: 6


Src: 
void ConstArrayAdjacentCoprime ( int N ) { for ( int i = 1 ; i <= N ; i ++ ) { System . out . print ( i + " ▁ " ) ; } }
Ref: 
def ConstArrayAdjacentCoprime ( N ) : NEW_LINE INDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT
Hyp: 
def ConstArrayAdjacentCoprime ( N ) : NEW_LINE INDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT print ( i , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT

BLEU: 87.41
Edit Sim: 2


Src: 
int pairs_count ( int arr [ ] , int n , int sum ) { int ans = 0 ; Arrays . sort ( arr ) ; int i = 0 , j = n - 1 ; while ( i < j ) { if ( arr [ i ] + arr [ j ] < sum ) i ++ ; else if ( arr [ i ] + arr [ j ] > sum ) j -- ; else { int x = arr [ i ] , xx = i ; while ( ( i < j ) && ( arr [ i ] == x ) ) i ++ ; int y = arr [ j ] , yy = j ; while ( ( j >= i ) && ( arr [ j ] == y ) ) j -- ; if ( x == y ) { int temp = i - xx + yy - j - 1 ; ans += ( temp * ( temp + 1 ) ) / 2 ; } else ans += ( i - xx ) * ( yy - j ) ; } } return ans ; }
Ref: 
def pairs_count ( arr , n , sum ) : NEW_LINE INDENT ans = 0 NEW_LINE arr = sorted ( arr ) NEW_LINE i , j = 0 , n - 1 NEW_LINE while ( i < j ) : NEW_LINE INDENT if ( arr [ i ] + arr [ j ] < sum ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT elif ( arr [ i ] + arr [ j ] > sum ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT x = arr [ i ] NEW_LINE xx = i NEW_LINE while ( i < j and arr [ i ] == x ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT y = arr [ j ] NEW_LINE yy = j NEW_LINE while ( j >= i and arr [ j ] == y ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT if ( x == y ) : NEW_LINE INDENT temp = i - xx + yy - j - 1 NEW_LINE ans += ( temp * ( temp + 1 ) ) // 2 NEW_LINE DEDENT else : NEW_LINE INDENT ans += ( i - xx ) * ( yy - j ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
Hyp: 
def pairs_count ( arr , n , sum ) : NEW_LINE INDENT ans = 0 NEW_LINE arr . sort ( ) NEW_LINE i = 0 ; j = n - 1 NEW_LINE while ( i < j ) : NEW_LINE INDENT if ( arr [ i ] + arr [ j ] < sum ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT elif ( arr [ i ] + arr [ j ] > sum ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT x = arr [ i ] NEW_LINE xx = i NEW_LINE while ( ( i < j ) and ( arr [ i ] == x ) ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT y = arr [ j ] NEW_LINE yy = j NEW_LINE while ( ( j >= i ) and ( arr [ j ] == y ) ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT if ( x == y ) : NEW_LINE INDENT temp = i - xx + yy - j - 1 NEW_LINE ans += ( temp * ( temp + 1 ) ) // 2 NEW_LINE DEDENT else : NEW_LINE INDENT ans += ( i - xx ) * ( yy - j ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT

BLEU: 88.79
Edit Sim: 28


Src: 
int minCells ( int mat [ ] [ ] , int m , int n ) { int dp [ ] [ ] = new int [ m ] [ n ] ; for ( int i = 0 ; i < m ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) dp [ i ] [ j ] = Integer . MAX_VALUE ; dp [ 0 ] [ 0 ] = 1 ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( dp [ i ] [ j ] != Integer . MAX_VALUE && ( j + mat [ i ] [ j ] ) < n && ( dp [ i ] [ j ] + 1 ) < dp [ i ] [ j + mat [ i ] [ j ] ] ) dp [ i ] [ j + mat [ i ] [ j ] ] = dp [ i ] [ j ] + 1 ; if ( dp [ i ] [ j ] != Integer . MAX_VALUE && ( i + mat [ i ] [ j ] ) < m && ( dp [ i ] [ j ] + 1 ) < dp [ i + mat [ i ] [ j ] ] [ j ] ) dp [ i + mat [ i ] [ j ] ] [ j ] = dp [ i ] [ j ] + 1 ; } } if ( dp [ m - 1 ] [ n - 1 ] != Integer . MAX_VALUE ) return dp [ m - 1 ] [ n - 1 ] ; return - 1 ; }
Ref: 
def minCells ( mat , m , n ) : NEW_LINE INDENT dp = [ [ MAX for i in range ( n ) ] for i in range ( m ) ] NEW_LINE dp [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( dp [ i ] [ j ] != MAX and ( j + mat [ i ] [ j ] ) < n and ( dp [ i ] [ j ] + 1 ) < dp [ i ] [ j + mat [ i ] [ j ] ] ) : NEW_LINE INDENT dp [ i ] [ j + mat [ i ] [ j ] ] = dp [ i ] [ j ] + 1 NEW_LINE DEDENT if ( dp [ i ] [ j ] != MAX and ( i + mat [ i ] [ j ] ) < m and ( dp [ i ] [ j ] + 1 ) < dp [ i + mat [ i ] [ j ] ] [ j ] ) : NEW_LINE INDENT dp [ i + mat [ i ] [ j ] ] [ j ] = dp [ i ] [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT if ( dp [ m - 1 ] [ n - 1 ] != MAX ) : NEW_LINE INDENT return dp [ m - 1 ] [ n - 1 ] NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
Hyp: 
def minCells ( mat , m , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n ) ] for i in range ( m ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT dp [ i ] [ j ] = sys . maxsize NEW_LINE DEDENT dp [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( dp [ i ] [ j ] != Integer . MAX_VALUE and ( j + mat [ i ] [ j ] ) < n and ( dp [ i ] [ j ] + 1 ) < dp [ i + mat [ i ] [ j ] ] ) : NEW_LINE INDENT dp [ i ] [ j + mat [ i ] [ j ] ] = dp [ i ] [ j ] + 1 NEW_LINE DEDENT DEDENT if ( dp [ i ] [ j ] != Integer . MAX_VALUE and ( i + mat [ i ] [ j ] ) < m and ( dp [ i ] [ j ] + 1 ) < dp [ i + mat [ i ] [ j ] ] [ j ] ) : NEW_LINE INDENT dp [ i + mat [ i ] [ j ] ] [ j ] = dp [ i ] [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT if ( dp [ m - 1 ] [ n - 1 ] != Integer . MAX_VALUE ) : NEW_LINE INDENT return dp [ m - 1 ] [ n - 1 ] NEW_LINE DEDENT return - 1 NEW_LINE DEDENT

BLEU: 83.5
Edit Sim: 188


Src: 
double find ( int N , int sum ) { if ( sum > 6 * N sum < N ) return 0 ; if ( N == 1 ) { if ( sum >= 1 && sum <= 6 ) return 1.0 / 6 ; else return 0 ; } double s = 0 ; for ( int i = 1 ; i <= 6 ; i ++ ) s = s + find ( N - 1 , sum - i ) / 6 ; return s ; }
Ref: 
def find ( N , sum ) : NEW_LINE INDENT if ( sum > 6 * N or sum < N ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( N == 1 ) : NEW_LINE INDENT if ( sum >= 1 and sum <= 6 ) : NEW_LINE INDENT return 1.0 / 6 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT s = 0 NEW_LINE for i in range ( 1 , 7 ) : NEW_LINE INDENT s = s + find ( N - 1 , sum - i ) / 6 NEW_LINE DEDENT return s NEW_LINE DEDENT
Hyp: 
def find ( N , sum ) : NEW_LINE INDENT if ( sum > 6 * N or sum < N ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( N == 1 ) : NEW_LINE INDENT if ( sum >= 1 and sum <= 6 ) : NEW_LINE INDENT return 1.0 / 6 ; NEW_LINE DEDENT else : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT DEDENT s = 0 ; NEW_LINE for i in range ( 1 , 7 ) : NEW_LINE INDENT s = s + find ( N - 1 , sum - i ) / 6 ; NEW_LINE DEDENT return s ; NEW_LINE DEDENT

BLEU: 86.26
Edit Sim: 12


Src: 
int minimumSteps ( int a , int b , int c ) { if ( a < 1 b < 1 ) return - 1 ; if ( a == 1 && b == 1 ) return c ; if ( a < b ) { a = a + b ; b = a - b ; a = a - b ; } return minimumSteps ( a - b , b , c + 1 ) ; }
Ref: 
def minimumSteps ( a , b , c ) : NEW_LINE INDENT if a < 1 or b < 1 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if a == 1 and b == 1 : NEW_LINE INDENT return c NEW_LINE DEDENT if a < b : NEW_LINE INDENT a , b = b , a NEW_LINE DEDENT return minimumSteps ( a - b , b , c + 1 ) NEW_LINE DEDENT
Hyp: 
def minimumSteps ( a , b , c ) : NEW_LINE INDENT if ( a < 1 or b < 1 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT if ( a == 1 and b == 1 ) : NEW_LINE INDENT return c ; NEW_LINE DEDENT if ( a < b ) : NEW_LINE INDENT a = a + b NEW_LINE b = a - b NEW_LINE a = a - b NEW_LINE DEDENT return minimumSteps ( a - b , b , c + 1 ) ; NEW_LINE DEDENT

BLEU: 56.56
Edit Sim: 54


Src: 
int canReplace ( int [ ] array ) { int i = 0 , count = 0 ; while ( i < array . length ) { if ( array [ i ] == 0 && ( i == 0 array [ i - 1 ] == 0 ) && ( i == array . length - 1 array [ i + 1 ] == 0 ) ) { array [ i ] = 1 ; count ++ ; } i ++ ; } return count ; }
Ref: 
def canReplace ( arr , n ) : NEW_LINE INDENT i = 0 NEW_LINE count = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( arr [ i ] == 0 and ( i == 0 or arr [ i - 1 ] == 0 ) and ( i == n - 1 or arr [ i + 1 ] == 0 ) ) : NEW_LINE INDENT arr [ i ] = 1 NEW_LINE count += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
Hyp: 
def canReplace ( array ) : NEW_LINE INDENT i = 0 NEW_LINE count = 0 NEW_LINE while i < len ( array ) : NEW_LINE INDENT if ( array [ i ] == 0 and ( i == 0 or array [ i - 1 ] == 0 ) and ( i == len ( array ) - 1 or array [ i + 1 ] == 0 ) ) : NEW_LINE INDENT array [ i ] = 1 NEW_LINE count += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT

BLEU: 74.1
Edit Sim: 36


Src: 
int clearBit ( int n , int k ) { return ( n & ( ~ ( 1 << ( k - 1 ) ) ) ) ; }
Ref: 
def clearBit ( n , k ) : NEW_LINE INDENT return ( n & ( ~ ( 1 << ( k - 1 ) ) ) ) NEW_LINE DEDENT
Hyp: 
def clearBit ( n , k ) : NEW_LINE INDENT return ( n & ( ~ ( 1 << ( k - 1 ) ) ) ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int countSubStr ( String str , int len ) { int ans = 0 ; for ( int i = 0 ; i < len ; i ++ ) { if ( str . charAt ( i ) == '0' ) ans += ( i + 1 ) ; } return ans ; }
Ref: 
def countSubStr ( strr , lenn ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( lenn ) : NEW_LINE INDENT if ( strr [ i ] == '0' ) : NEW_LINE INDENT ans += ( i + 1 ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
Hyp: 
def countSubStr ( string , length ) : NEW_LINE INDENT ans = 0 ; NEW_LINE for i in range ( length ) : NEW_LINE INDENT if ( string [ i ] == '0' ) : NEW_LINE INDENT ans += ( i + 1 ) ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT

BLEU: 66.95
Edit Sim: 18


Src: 
void print ( int a [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i != j ) System . out . println ( a [ i ] + " ▁ " + a [ j ] ) ; } } }
Ref: 
def printt ( a , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( i != j ) : NEW_LINE INDENT print ( a [ i ] , " " , a [ j ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
Hyp: 
def print ( a , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT if ( i != j ) : NEW_LINE INDENT print ( a [ i ] , " ▁ " , a [ j ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT

BLEU: 81.95
Edit Sim: 11


Src: 
void pattern ( String str , int len ) { for ( int i = 0 ; i < len ; i ++ ) { int j = len - 1 - i ; for ( int k = 0 ; k < len ; k ++ ) { if ( k == i k == j ) System . out . print ( str . charAt ( k ) ) ; else System . out . print ( " ▁ " ) ; } System . out . println ( " " ) ; } }
Ref: 
def pattern ( st , length ) : NEW_LINE INDENT for i in range ( length ) : NEW_LINE INDENT j = length - 1 - i NEW_LINE for k in range ( length ) : NEW_LINE INDENT if ( k == i or k == j ) : NEW_LINE INDENT print ( st [ k ] , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " ▁ " , end = " " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT
Hyp: 
def pattern ( str , l ) : NEW_LINE INDENT for i in range ( l ) : NEW_LINE INDENT j = l - 1 - i NEW_LINE for k in range ( l ) : NEW_LINE INDENT if ( k == i or k == j ) : NEW_LINE INDENT print ( str [ k ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " ▁ " ) NEW_LINE DEDENT DEDENT print ( " " ) NEW_LINE DEDENT DEDENT

BLEU: 69.42
Edit Sim: 50


Src: 
Boolean isUpperTriangularMatrix ( int mat [ ] [ ] ) { for ( int i = 1 ; i < N ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( mat [ i ] [ j ] != 0 ) return false ; return true ; }
Ref: 
def isuppertriangular ( M ) : NEW_LINE INDENT for i in range ( 1 , len ( M ) ) : NEW_LINE INDENT for j in range ( 0 , i ) : NEW_LINE INDENT if ( M [ i ] [ j ] != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT M = [ [ 1 , 3 , 5 , 3 ] , [ 0 , 4 , 6 , 2 ] , [ 0 , 0 , 2 , 5 ] , [ 0 , 0 , 0 , 6 ] ] NEW_LINE if isuppertriangular ( M ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
Hyp: 
def isUpperTriangularMatrix ( mat ) : NEW_LINE INDENT for i in range ( 1 , N ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( mat [ i ] [ j ] != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT mat = [ [ 1 , 3 , 5 ] , [ 3 , 2 , 4 ] , [ 5 , 1 , 4 ] ] NEW_LINE if ( isUpperTriangularMatrix ( mat ) ) : NEW_LINE INDENT print " Yes " NEW_LINE DEDENT else : NEW_LINE INDENT print " No " NEW_LINE DEDENT

BLEU: 54.59
Edit Sim: 90


Src: 
int sum ( int x , int y , int n ) { int sum1 = ( int ) ( ( Math . pow ( x , 2 ) * ( Math . pow ( x , 2 * n ) - 1 ) ) / ( Math . pow ( x , 2 ) - 1 ) ) ; int sum2 = ( int ) ( ( x * y * ( Math . pow ( x , n ) * Math . pow ( y , n ) - 1 ) ) / ( x * y - 1 ) ) ; return sum1 + sum2 ; }
Ref: 
def sum ( x , y , n ) : NEW_LINE INDENT sum1 = ( ( x ** 2 ) * ( x ** ( 2 * n ) - 1 ) ) // ( x ** 2 - 1 ) NEW_LINE sum2 = ( x * y * ( x ** n * y ** n - 1 ) ) // ( x * y - 1 ) NEW_LINE return ( sum1 + sum2 ) NEW_LINE DEDENT
Hyp: 
def sum ( x , y , n ) : NEW_LINE INDENT sum1 = ( pow ( x , 2 ) * ( pow ( x , 2 * n ) - 1 ) ) / ( pow ( x , 2 ) - 1 ) ) NEW_LINE sum2 = ( pow ( x * y * ( pow ( x , n ) * pow ( y , n ) - 1 ) ) / ( x * y - 1 ) ) NEW_LINE return sum1 + sum2 NEW_LINE DEDENT

BLEU: 50.6
Edit Sim: 58


Src: 
void printExpansion ( String str ) { for ( int i = str . length ( ) - 1 ; i >= 0 ; i -- ) { String subStr = str . substring ( i ) ; System . out . print ( subStr ) ; } }
Ref: 
def printExpansion ( str ) : NEW_LINE INDENT for i in range ( len ( str ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( i , len ( str ) ) : NEW_LINE INDENT print ( str [ j ] , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
Hyp: 
def printExpansion ( str ) : NEW_LINE INDENT i = len ( str ) - 1 ; NEW_LINE while i >= 0 : NEW_LINE INDENT subStr = str [ i : ] ; NEW_LINE print ( subStr ) ; NEW_LINE DEDENT i = i - 1 ; NEW_LINE DEDENT

BLEU: 26.78
Edit Sim: 105


Src: 
int Maxcost ( String s , int [ ] cost ) { ' ' ▁ Initialize ▁ the ▁ count ' '' int maxcost = 0 ; int i = 0 ; while ( i < s . length ( ) - 1 ) { if ( s . charAt ( i ) == s . charAt ( i + 1 ) ) { if ( cost [ i ] > cost [ i + 1 ] ) maxcost += cost [ i ] ; else { maxcost += cost [ i + 1 ] ; cost [ i + 1 ] = cost [ i ] ; } } i ++ ; } return maxcost ; }
Ref: 
def Maxcost ( s , cost ) : NEW_LINE INDENT count = 0 NEW_LINE maxcost = 0 NEW_LINE i = 0 NEW_LINE while i < len ( s ) - 1 : NEW_LINE INDENT if s [ i ] == s [ i + 1 ] : NEW_LINE INDENT if cost [ i ] > cost [ i + 1 ] : NEW_LINE INDENT maxcost += cost [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT maxcost += cost [ i + 1 ] NEW_LINE cost [ i + 1 ] = cost [ i ] NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT return maxcost NEW_LINE DEDENT
Hyp: 
def Maxcost ( s , cost ) : NEW_LINE INDENT ' ' ▁ Initialize ▁ the ▁ count ' ' NEW_LINE maxcost = 0 NEW_LINE i = 0 NEW_LINE while ( i < len ( s ) - 1 ) : NEW_LINE INDENT if ( s [ i ] == s [ i + 1 ] ) : NEW_LINE INDENT if ( cost [ i ] > cost [ i + 1 ] ) : NEW_LINE INDENT maxcost += cost [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT maxcost += cost [ i + 1 ] NEW_LINE cost [ i + 1 ] = cost [ i ] NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT return maxcost NEW_LINE DEDENT

BLEU: 77.84
Edit Sim: 39


Src: 
void replace_elements ( int arr [ ] , int n ) { int pos = 0 ; for ( int i = 0 ; i < n ; i ++ ) { arr [ pos ++ ] = arr [ i ] ; while ( pos > 1 && arr [ pos - 2 ] == arr [ pos - 1 ] ) { pos -- ; arr [ pos - 1 ] ++ ; } } for ( int i = 0 ; i < pos ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; }
Ref: 
def replace_elements ( arr , n ) : NEW_LINE INDENT pos = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT arr [ pos ] = arr [ i ] NEW_LINE pos = pos + 1 NEW_LINE while ( pos > 1 and arr [ pos - 2 ] == arr [ pos - 1 ] ) : NEW_LINE INDENT pos -= 1 NEW_LINE arr [ pos - 1 ] += 1 NEW_LINE DEDENT DEDENT for i in range ( 0 , pos ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
Hyp: 
def replace_elements ( arr , n ) : NEW_LINE INDENT pos = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr [ pos ] = arr [ i ] NEW_LINE while ( pos > 1 and arr [ pos - 2 ] == arr [ pos - 1 ] ) : NEW_LINE INDENT pos -= 1 NEW_LINE arr [ pos - 1 ] += 1 NEW_LINE DEDENT DEDENT for i in range ( pos ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT

BLEU: 86.75
Edit Sim: 31


Src: 
int itemType ( int n ) { int count = 0 ; for ( int day = 1 ; ; day ++ ) { for ( int type = day ; type > 0 ; type -- ) { count += type ; if ( count >= n ) return type ; } } }
Ref: 
def itemType ( n ) : NEW_LINE INDENT count = 0 NEW_LINE day = 1 NEW_LINE while ( True ) : NEW_LINE INDENT for type in range ( day , 0 , - 1 ) : NEW_LINE INDENT count += type NEW_LINE if ( count >= n ) : NEW_LINE INDENT return type NEW_LINE DEDENT DEDENT DEDENT DEDENT
Hyp: 
def itemType ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for day in range ( 1 , 31 ) : NEW_LINE INDENT for type in range ( day , 0 , - 1 ) : NEW_LINE INDENT count += type NEW_LINE if ( count >= n ) : NEW_LINE INDENT return type NEW_LINE DEDENT DEDENT DEDENT

BLEU: 84.6
Edit Sim: 31


Src: 
boolean CheckBinaryEquivalent ( int N ) { return ( N - 1 ) % 8 == 0 ; }
Ref: 
def CheckBinaryEquivalent ( N ) : NEW_LINE INDENT return ( N - 1 ) % 8 == 0 ; NEW_LINE DEDENT
Hyp: 
def CheckBinaryEquivalent ( N ) : NEW_LINE INDENT return ( N - 1 ) % 8 == 0 NEW_LINE DEDENT

BLEU: 88.69
Edit Sim: 2


Src: 
int counLastDigitK ( int low , int high , int k ) { int count = 0 ; for ( int i = low ; i <= high ; i ++ ) if ( i % 10 == k ) count ++ ; return count ; }
Ref: 
def counLastDigitK ( low , high , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( low , high + 1 ) : NEW_LINE INDENT if ( i % 10 == k ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
Hyp: 
def counLastDigitK ( low , high , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( low , high + 1 ) : NEW_LINE INDENT if ( i % 10 == k ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
double vol_of_dodecahedron ( int side ) { return ( ( ( 15 + ( 7 * ( Math . sqrt ( 5 ) ) ) ) / 4 ) * ( Math . pow ( side , 3 ) ) ) ; }
Ref: 
def vol_of_dodecahedron ( side ) : NEW_LINE INDENT return ( ( ( 15 + ( 7 * ( math . sqrt ( 5 ) ) ) ) / 4 ) * ( math . pow ( side , 3 ) ) ) NEW_LINE DEDENT
Hyp: 
def vol_of_dodecahedron ( side ) : NEW_LINE INDENT return ( ( 15 + ( 7 * ( math . sqrt ( 5 ) ) ) / 4 ) * ( math . pow ( side , 3 ) ) ) ; NEW_LINE DEDENT

BLEU: 91.84
Edit Sim: 6


Src: 
int findCount ( String str1 , String str2 ) { int len = str1 . length ( ) ; int len2 = str2 . length ( ) ; int ans = Integer . MAX_VALUE ; int [ ] hash1 = new int [ 26 ] ; int [ ] hash2 = new int [ 26 ] ; for ( int i = 0 ; i < len ; i ++ ) hash1 [ ( int ) ( str1 . charAt ( i ) - ' a ' ) ] ++ ; for ( int i = 0 ; i < len2 ; i ++ ) hash2 [ ( int ) ( str2 . charAt ( i ) - ' a ' ) ] ++ ; for ( int i = 0 ; i < 26 ; i ++ ) if ( hash2 [ i ] != 0 ) ans = Math . min ( ans , hash1 [ i ] / hash2 [ i ] ) ; return ans ; }
Ref: 
def findCount ( str1 , str2 ) : NEW_LINE INDENT len1 = len ( str1 ) NEW_LINE len2 = len ( str2 ) NEW_LINE ans = sys . maxsize NEW_LINE hash1 = [ 0 ] * 26 NEW_LINE hash2 = [ 0 ] * 26 NEW_LINE for i in range ( 0 , len1 ) : NEW_LINE INDENT hash1 [ ord ( str1 [ i ] ) - 97 ] = hash1 [ ord ( str1 [ i ] ) - 97 ] + 1 NEW_LINE DEDENT for i in range ( 0 , len2 ) : NEW_LINE INDENT hash2 [ ord ( str2 [ i ] ) - 97 ] = hash2 [ ord ( str2 [ i ] ) - 97 ] + 1 NEW_LINE DEDENT for i in range ( 0 , 26 ) : NEW_LINE INDENT if ( hash2 [ i ] != 0 ) : NEW_LINE INDENT ans = min ( ans , hash1 [ i ] // hash2 [ i ] ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
Hyp: 
def findCount ( str1 , str2 ) : NEW_LINE INDENT len1 , len2 = len ( str1 ) , len ( str2 ) NEW_LINE ans = sys . maxsize NEW_LINE hash1 = [ 0 ] * 26 NEW_LINE hash2 = [ 0 ] * 26 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT hash1 [ ord ( i ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( len2 ) : NEW_LINE INDENT hash2 [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT if ( hash2 [ i ] != 0 ) : NEW_LINE INDENT ans = min ( ans , hash1 [ i ] // hash2 [ i ] ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT

BLEU: 68.21
Edit Sim: 104


Src: 
int MinCost ( int days [ ] , int cost [ ] , int N ) { int size = days [ N - 1 ] + 1 ; int [ ] dp = new int [ size ] ; dp [ size - 1 ] = Math . min ( cost [ 0 ] , Math . min ( cost [ 1 ] , cost [ 2 ] ) ) ; int ptr = N - 2 ; for ( int i = size - 2 ; i > 0 ; i -- ) { if ( ptr >= 0 && days [ ptr ] == i ) { int val1 = dp [ i + 1 ] + cost [ 0 ] ; int val2 = cost [ 1 ] + ( ( i + 7 >= size ) ? 0 : dp [ i + 7 ] ) ; int val3 = cost [ 2 ] + ( ( i + 30 >= size ) ? 0 : dp [ i + 30 ] ) ; dp [ i ] = Math . min ( val1 , Math . min ( val2 , val3 ) ) ; ptr -- ; } else { dp [ i ] = dp [ i + 1 ] ; } } return dp [ 1 ] ; }
Ref: 
def MinCost ( days , cost , N ) : NEW_LINE INDENT size = days [ N - 1 ] + 1 NEW_LINE dp = [ 0 for i in range ( size ) ] NEW_LINE dp [ size - 1 ] = min ( cost [ 0 ] , min ( cost [ 1 ] , cost [ 2 ] ) ) NEW_LINE ptr = N - 2 NEW_LINE for i in range ( size - 2 , 0 , - 1 ) : NEW_LINE INDENT if ( ptr >= 0 and days [ ptr ] == i ) : NEW_LINE INDENT val1 = dp [ i + 1 ] + cost [ 0 ] NEW_LINE val2 = cost [ 1 ] + ( 0 if ( i + 7 >= size ) else dp [ i + 7 ] ) NEW_LINE val3 = cost [ 2 ] + ( 0 if ( i + 30 >= size ) else dp [ i + 30 ] ) NEW_LINE dp [ i ] = min ( val1 , min ( val2 , val3 ) ) NEW_LINE ptr -= 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] = dp [ i + 1 ] NEW_LINE DEDENT DEDENT return dp [ 1 ] NEW_LINE DEDENT
Hyp: 
def MinCost ( days , cost , N ) : NEW_LINE INDENT size = days [ N - 1 ] + 1 NEW_LINE dp = [ 0 ] * size NEW_LINE dp [ size - 1 ] = min ( cost [ 0 ] , min ( cost [ 1 ] , cost [ 2 ] ) ) NEW_LINE ptr = N - 2 NEW_LINE for i in range ( size - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( ptr >= 0 and days [ ptr ] == i ) : NEW_LINE INDENT val1 = dp [ i + 1 ] + cost [ 0 ] NEW_LINE val2 = cost [ 1 ] + ( ( i + 7 >= size ) else dp [ i + 7 ] ) NEW_LINE val3 = cost [ 2 ] + ( ( i + 30 >= size ) ? 0 : dp [ i + 30 ] ) NEW_LINE dp [ i ] = min ( val1 , min ( val2 , val3 ) ) NEW_LINE ptr -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] = dp [ i + 1 ] NEW_LINE DEDENT DEDENT return dp [ 1 ] NEW_LINE DEDENT

BLEU: 89.13
Edit Sim: 39


Src: 
int eulerian ( int n , int m ) { int [ ] [ ] dp = new int [ n + 1 ] [ m + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= m ; j ++ ) { if ( i > j ) { if ( j == 0 ) dp [ i ] [ j ] = 1 ; else dp [ i ] [ j ] = ( ( i - j ) * dp [ i - 1 ] [ j - 1 ] ) + ( ( j + 1 ) * dp [ i - 1 ] [ j ] ) ; } } } return dp [ n ] [ m ] ; }
Ref: 
def eulerian ( n , m ) : NEW_LINE INDENT dp = [ [ 0 for x in range ( m + 1 ) ] for y in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 0 , m + 1 ) : NEW_LINE INDENT if ( i > j ) : NEW_LINE INDENT if ( j == 0 ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = ( ( ( i - j ) * dp [ i - 1 ] [ j - 1 ] ) + ( ( j + 1 ) * dp [ i - 1 ] [ j ] ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return dp [ n ] [ m ] NEW_LINE DEDENT
Hyp: 
def eulerian ( n , m ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( m + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( m + 1 ) : NEW_LINE INDENT if ( i > j ) : NEW_LINE INDENT if ( j == 0 ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = ( ( i - j ) * dp [ i - 1 ] [ j - 1 ] ) + ( ( j + 1 ) * dp [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ n ] [ m ] NEW_LINE DEDENT

BLEU: 92.01
Edit Sim: 17


Src: 
int findEle ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == sum - arr [ i ] ) return arr [ i ] ; return - 1 ; }
Ref: 
def findEle ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if arr [ i ] == sum - arr [ i ] : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
Hyp: 
def findEle ( arr , n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == sum - arr [ i ] ) : NEW_LINE INDENT return arr [ i ] ; NEW_LINE DEDENT DEDENT return - 1 ; NEW_LINE DEDENT arr = [ 2 , 3 , 4 , 8 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE result = findEle ( arr , n ) NEW_LINE if ( result == - 1 ) : NEW_LINE INDENT print ( " Element ▁ is ▁ not ▁ present ▁ in ▁ array " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Element ▁ is ▁ present ▁ at ▁ index " , result ) NEW_LINE DEDENT

BLEU: 38.92
Edit Sim: 321


Src: 
void findDivisors ( int n ) { int [ ] div = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j * i <= n ; j ++ ) div [ i * j ] ++ ; } for ( int i = 1 ; i <= n ; i ++ ) System . out . print ( div [ i ] + " ▁ " ) ; }
Ref: 
def findDivisors ( n ) : NEW_LINE INDENT div = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if j * i <= n : NEW_LINE INDENT div [ i * j ] += 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( div [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
Hyp: 
def findDivisors ( n ) : NEW_LINE INDENT div = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT div [ i * j ] += 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( div [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT

BLEU: 81.67
Edit Sim: 54


Src: 
int nthTerm ( int n ) { int d = 2 ; int a1 = 0 ; int An = a1 + ( n - 1 ) * d ; return ( int ) Math . pow ( An , 3 ) ; }
Ref: 
def term ( n ) : NEW_LINE INDENT d = 2 NEW_LINE a1 = 0 NEW_LINE An = a1 + ( n - 1 ) * d NEW_LINE An = An ** 3 NEW_LINE return An ; NEW_LINE DEDENT
Hyp: 
def nthTerm ( n ) : NEW_LINE INDENT d = 2 NEW_LINE a1 = 0 NEW_LINE An = a1 + ( n - 1 ) * d NEW_LINE return pow ( An , 3 ) NEW_LINE DEDENT

BLEU: 70.86
Edit Sim: 30


Src: 
boolean isPath ( int arr [ ] [ ] ) { arr [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i < 5 ; i ++ ) if ( arr [ 0 ] [ i ] != - 1 ) arr [ 0 ] [ i ] = arr [ 0 ] [ i - 1 ] ; for ( int j = 1 ; j < 5 ; j ++ ) if ( arr [ j ] [ 0 ] != - 1 ) arr [ j ] [ 0 ] = arr [ j - 1 ] [ 0 ] ; for ( int i = 1 ; i < 5 ; i ++ ) for ( int j = 1 ; j < 5 ; j ++ ) if ( arr [ i ] [ j ] != - 1 ) arr [ i ] [ j ] = Math . max ( arr [ i ] [ j - 1 ] , arr [ i - 1 ] [ j ] ) ; return ( arr [ 5 - 1 ] [ 5 - 1 ] == 1 ) ; }
Ref: 
def isPath ( arr ) : NEW_LINE INDENT arr [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , row ) : NEW_LINE INDENT if ( arr [ i ] [ 0 ] != - 1 ) : NEW_LINE INDENT arr [ i ] [ 0 ] = arr [ i - 1 ] [ 0 ] NEW_LINE DEDENT DEDENT for j in range ( 1 , col ) : NEW_LINE INDENT if ( arr [ 0 ] [ j ] != - 1 ) : NEW_LINE INDENT arr [ 0 ] [ j ] = arr [ 0 ] [ j - 1 ] NEW_LINE DEDENT DEDENT for i in range ( 1 , row ) : NEW_LINE INDENT for j in range ( 1 , col ) : NEW_LINE INDENT if ( arr [ i ] [ j ] != - 1 ) : NEW_LINE INDENT arr [ i ] [ j ] = max ( arr [ i ] [ j - 1 ] , arr [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return ( arr [ row - 1 ] [ col - 1 ] == 1 ) NEW_LINE DEDENT arr = [ [ 0 , 0 , 0 , - 1 , 0 ] , [ - 1 , 0 , 0 , - 1 , - 1 ] , [ 0 , 0 , 0 , - 1 , 0 ] , [ - 1 , 0 , - 1 , 0 , - 1 ] , [ 0 , 0 , - 1 , 0 , 0 ] ] NEW_LINE if ( isPath ( arr ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
Hyp: 
def isPath ( arr ) : NEW_LINE INDENT arr [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , 5 ) : NEW_LINE INDENT if ( arr [ 0 ] [ i ] != - 1 ) : NEW_LINE INDENT arr [ 0 ] [ i ] = arr [ 0 ] [ i - 1 ] NEW_LINE DEDENT for j in range ( 1 , 5 ) : NEW_LINE INDENT if ( arr [ j ] [ 0 ] != - 1 ) : NEW_LINE INDENT arr [ j ] [ 0 ] = arr [ j - 1 ] [ 0 ] NEW_LINE DEDENT DEDENT for i in range ( 1 , 5 ) : NEW_LINE INDENT for j in range ( 1 , 5 ) : NEW_LINE INDENT if ( arr [ i ] [ j ] != - 1 ) : NEW_LINE INDENT arr [ i ] [ j ] = max ( arr [ i ] [ j - 1 ] , arr [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return ( arr [ 5 - 1 ] [ 5 - 1 ] == 1 ) NEW_LINE DEDENT

BLEU: 53.13
Edit Sim: 330


Src: 
int KnapSack ( int val [ ] , int wt [ ] , int n , int W ) { int [ ] dp = new int [ W + 1 ] ; Arrays . fill ( dp , 0 ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = W ; j >= wt [ i ] ; j -- ) dp [ j ] = Math . max ( dp [ j ] , val [ i ] + dp [ j - wt [ i ] ] ) ; return dp [ W ] ; }
Ref: 
def KnapSack ( val , wt , n , W ) : NEW_LINE INDENT dp = [ 0 ] * ( W + 1 ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( W , wt [ i ] , - 1 ) : NEW_LINE INDENT dp [ j ] = max ( dp [ j ] , val [ i ] + dp [ j - wt [ i ] ] ) ; NEW_LINE DEDENT DEDENT return dp [ W ] ; NEW_LINE DEDENT
Hyp: 
def KnapSack ( val , wt , n , W ) : NEW_LINE INDENT dp = [ 0 ] * ( W + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( W , wt [ i ] + 1 ) : NEW_LINE INDENT dp [ j ] = max ( dp [ j ] , val [ i ] + dp [ j - wt [ i ] ] ) NEW_LINE DEDENT DEDENT return dp [ W ] NEW_LINE DEDENT

BLEU: 88.27
Edit Sim: 9


Src: 
int minimumRectangleArea ( int A [ ] , int N ) { int ans ; Arrays . sort ( A ) ; ans = ( A [ N - 1 ] - A [ 0 ] ) * ( A [ 2 * N - 1 ] - A [ N ] ) ; for ( int i = 1 ; i < N ; i ++ ) ans = Math . min ( ans , ( A [ 2 * N - 1 ] - A [ 0 ] ) * ( A [ i + N - 1 ] - A [ i ] ) ) ; return ans ; }
Ref: 
def minimumRectangleArea ( A , N ) : NEW_LINE INDENT ans = 0 NEW_LINE A . sort ( ) NEW_LINE ans = ( A [ N - 1 ] - A [ 0 ] ) * ( A [ 2 * N - 1 ] - A [ N ] ) NEW_LINE for i in range ( 1 , N , 1 ) : NEW_LINE INDENT ans = min ( ans , ( A [ 2 * N - 1 ] - A [ 0 ] ) * ( A [ i + N - 1 ] - A [ i ] ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
Hyp: 
def minimumRectangleArea ( A , N ) : NEW_LINE INDENT A . sort ( ) NEW_LINE ans = ( A [ N - 1 ] - A [ 0 ] ) * ( A [ 2 * N - 1 ] - A [ N ] ) NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT ans = min ( ans , ( A [ 2 * N - 1 ] - A [ 0 ] ) * ( A [ i + N - 1 ] - A [ i ] ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT

BLEU: 91.61
Edit Sim: 21


Src: 
int kthSmallest ( int n , int k ) { return ( 2 * k ) ; }
Ref: 
def kthSmallest ( n , k ) : NEW_LINE INDENT return 2 * k NEW_LINE DEDENT
Hyp: 
def kthSmallest ( n , k ) : NEW_LINE INDENT return ( 2 * k ) ; NEW_LINE DEDENT

BLEU: 67.09
Edit Sim: 6


Src: 
int maxSubArraySumRepeated ( int a [ ] , int n , int k ) { int max_so_far = 0 ; int INT_MIN , max_ending_here = 0 ; for ( int i = 0 ; i < n * k ; i ++ ) { max_ending_here = max_ending_here + a [ i % n ] ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; if ( max_ending_here < 0 ) max_ending_here = 0 ; } return max_so_far ; }
Ref: 
def maxSubArraySumRepeated ( a , n , k ) : NEW_LINE INDENT max_so_far = - 2147483648 NEW_LINE max_ending_here = 0 NEW_LINE for i in range ( n * k ) : NEW_LINE INDENT max_ending_here = max_ending_here + a [ i % n ] NEW_LINE if ( max_so_far < max_ending_here ) : NEW_LINE INDENT max_so_far = max_ending_here NEW_LINE DEDENT if ( max_ending_here < 0 ) : NEW_LINE INDENT max_ending_here = 0 NEW_LINE DEDENT DEDENT return max_so_far NEW_LINE DEDENT
Hyp: 
def maxSubArraySumRepeated ( a , n , k ) : NEW_LINE INDENT max_so_far = 0 NEW_LINE INT_MIN = 0 NEW_LINE max_ending_here = 0 NEW_LINE for i in range ( n * k ) : NEW_LINE INDENT max_ending_here = max_ending_here + a [ i % n ] NEW_LINE if ( max_so_far < max_ending_here ) : NEW_LINE INDENT max_so_far = max_ending_here NEW_LINE DEDENT if ( max_ending_here < 0 ) : NEW_LINE INDENT max_ending_here = 0 NEW_LINE DEDENT DEDENT return max_so_far NEW_LINE DEDENT

BLEU: 91.79
Edit Sim: 21


Src: 
double hexagonside ( double a ) { if ( a < 0 ) return - 1 ; double x = ( 0.5176 * a ) ; return x ; }
Ref: 
def hexagonside ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT x = 0.5176 * a ; NEW_LINE return x ; NEW_LINE DEDENT
Hyp: 
def hexagonside ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT x = ( 0.5176 * a ) NEW_LINE return x NEW_LINE DEDENT

BLEU: 73.11
Edit Sim: 7


Src: 
double arcLength ( double diameter , double angle ) { double pi = 22.0 / 7.0 ; double arc ; if ( angle >= 360 ) { System . out . println ( " Angle ▁ cannot " + " ▁ be ▁ formed " ) ; return 0 ; } else { arc = ( pi * diameter ) * ( angle / 360.0 ) ; return arc ; } }
Ref: 
def arcLength ( diameter , angle ) : NEW_LINE INDENT if angle >= 360 : NEW_LINE INDENT print ( " Angle ▁ cannot ▁ be ▁ formed " ) NEW_LINE return 0 NEW_LINE DEDENT else : NEW_LINE INDENT arc = ( 3.142857142857143 * diameter ) * ( angle / 360.0 ) NEW_LINE return arc NEW_LINE DEDENT DEDENT
Hyp: 
def arcLength ( diameter , angle ) : NEW_LINE INDENT pi = 22.0 / 7.0 NEW_LINE arc = 0 NEW_LINE if ( angle >= 360 ) : NEW_LINE INDENT print ( " Angle ▁ cannot " , " ▁ be ▁ formed " ) NEW_LINE return 0 NEW_LINE DEDENT else : NEW_LINE INDENT arc = ( pi * diameter ) * ( angle / 360.0 ) NEW_LINE return arc NEW_LINE DEDENT DEDENT

BLEU: 67.69
Edit Sim: 69


Src: 
int maximumChars ( String str ) { int n = str . length ( ) ; int res = - 1 ; int [ ] firstInd = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) firstInd [ i ] = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { int first_ind = firstInd [ str . charAt ( i ) ] ; if ( first_ind == - 1 ) firstInd [ str . charAt ( i ) ] = i ; else res = Math . max ( res , Math . abs ( i - first_ind - 1 ) ) ; } return res ; }
Ref: 
def maximumChars ( str1 ) : NEW_LINE INDENT n = len ( str1 ) NEW_LINE res = - 1 NEW_LINE firstInd = [ - 1 for i in range ( MAX_CHAR ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT first_ind = firstInd [ ord ( str1 [ i ] ) ] NEW_LINE if ( first_ind == - 1 ) : NEW_LINE INDENT firstInd [ ord ( str1 [ i ] ) ] = i NEW_LINE DEDENT else : NEW_LINE INDENT res = max ( res , abs ( i - first_ind - 1 ) ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
Hyp: 
def maximumChars ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE res = - 1 NEW_LINE firstInd = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( MAX_CHAR ) : NEW_LINE INDENT firstInd [ i ] = - 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT first_ind = firstInd [ str [ i ] ] NEW_LINE if ( first_ind == - 1 ) : NEW_LINE INDENT firstInd [ str [ i ] ] = i NEW_LINE DEDENT else : NEW_LINE INDENT res = max ( res , abs ( i - first_ind - 1 ) ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT

BLEU: 72.02
Edit Sim: 86


Src: 
int nCycle ( int N ) { return ( N ) * ( N - 1 ) + 1 ; }
Ref: 
def nCycle ( N ) : NEW_LINE INDENT return ( N ) * ( N - 1 ) + 1 NEW_LINE DEDENT
Hyp: 
def nCycle ( N ) : NEW_LINE INDENT return ( N ) * ( N - 1 ) + 1 NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
void findMinXORSubarray ( int arr [ ] , int n , int k ) { if ( n < k ) return ; int res_index = 0 ; int curr_xor = 0 ; for ( int i = 0 ; i < k ; i ++ ) curr_xor ^= arr [ i ] ; int min_xor = curr_xor ; for ( int i = k ; i < n ; i ++ ) { curr_xor ^= ( arr [ i ] ^ arr [ i - k ] ) ; if ( curr_xor < min_xor ) { min_xor = curr_xor ; res_index = ( i - k + 1 ) ; } } System . out . println ( min_xor ) ; }
Ref: 
def findMinXORSubarray ( arr , n , k ) : NEW_LINE INDENT if ( n < k ) : NEW_LINE INDENT return ; NEW_LINE DEDENT res_index = 0 ; NEW_LINE curr_xor = 0 ; NEW_LINE for i in range ( k ) : NEW_LINE INDENT curr_xor ^= arr [ i ] ; NEW_LINE DEDENT min_xor = curr_xor ; NEW_LINE for i in range ( k , n ) : NEW_LINE INDENT curr_xor ^= ( arr [ i ] ^ arr [ i - k ] ) ; NEW_LINE if ( curr_xor < min_xor ) : NEW_LINE INDENT min_xor = curr_xor ; NEW_LINE res_index = ( i - k + 1 ) ; NEW_LINE DEDENT DEDENT print ( min_xor ) ; NEW_LINE DEDENT
Hyp: 
def findMinXORSubarray ( arr , n , k ) : NEW_LINE INDENT if ( n < k ) : return 0 NEW_LINE res_index = 0 NEW_LINE curr_xor = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT curr_xor ^= arr [ i ] NEW_LINE DEDENT min_xor = curr_xor NEW_LINE for i in range ( k , n ) : NEW_LINE INDENT curr_xor ^= ( arr [ i ] ^ arr [ i - k ] ) NEW_LINE if ( curr_xor < min_xor ) : NEW_LINE INDENT min_xor = curr_xor NEW_LINE res_index = ( i - k + 1 ) NEW_LINE DEDENT DEDENT print ( min_xor ) NEW_LINE DEDENT

BLEU: 77.09
Edit Sim: 40


Src: 
int minMergeCost ( int i , int j , int [ ] arr ) { if ( i == j ) return 0 ; if ( v [ i ] [ j ] ) return dp [ i ] [ j ] ; v [ i ] [ j ] = true ; int x = dp [ i ] [ j ] ; x = Integer . MAX_VALUE ; int tot = 0 ; for ( int k = i ; k <= j ; k ++ ) tot += arr [ k ] ; for ( int k = i + 1 ; k <= j ; k ++ ) { x = Math . min ( x , tot + minMergeCost ( i , k - 1 , arr ) + minMergeCost ( k , j , arr ) ) ; } return x ; }
Ref: 
def minMergeCost ( i , j , arr ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( v [ i ] [ j ] ) : NEW_LINE INDENT return dp [ i ] [ j ] ; NEW_LINE DEDENT v [ i ] [ j ] = True ; NEW_LINE x = dp [ i ] [ j ] ; NEW_LINE x = sys . maxsize ; NEW_LINE tot = 0 ; NEW_LINE for k in range ( i , j + 1 ) : NEW_LINE INDENT tot += arr [ k ] ; NEW_LINE DEDENT for k in range ( i + 1 , j + 1 ) : NEW_LINE INDENT x = min ( x , tot + minMergeCost ( i , k - 1 , arr ) + minMergeCost ( k , j , arr ) ) ; NEW_LINE DEDENT return x ; NEW_LINE DEDENT
Hyp: 
def minMergeCost ( i , j , arr ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( v [ i ] [ j ] ) : NEW_LINE INDENT return dp [ i ] [ j ] NEW_LINE DEDENT v [ i ] [ j ] = 1 NEW_LINE x = dp [ i ] [ j ] NEW_LINE x = Integer . MAX_VALUE NEW_LINE tot = 0 NEW_LINE for k in range ( i , j + 1 ) : NEW_LINE INDENT tot += arr [ k ] NEW_LINE DEDENT for k in range ( i + 1 , j + 1 ) : NEW_LINE INDENT x = min ( x , tot + minMergeCost ( i , k - 1 , arr ) + minMergeCost ( k , j , arr ) ) NEW_LINE DEDENT return x NEW_LINE DEDENT

BLEU: 83.17
Edit Sim: 36


Src: 
boolean isRefactorableNumber ( int n ) { int divCount = 0 ; for ( int i = 1 ; i <= Math . sqrt ( n ) ; ++ i ) { if ( n % i == 0 ) { if ( n / i == i ) ++ divCount ; else divCount += 2 ; } } return n % divCount == 0 ; }
Ref: 
def isRefactorableNumber ( n ) : NEW_LINE INDENT divCount = 0 NEW_LINE for i in range ( 1 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT if n / i == i : NEW_LINE INDENT divCount += 1 NEW_LINE divCount += 2 NEW_LINE DEDENT DEDENT DEDENT return n % divCount == 0 NEW_LINE DEDENT n = 8 NEW_LINE if isRefactorableNumber ( n ) : NEW_LINE INDENT print " yes " NEW_LINE DEDENT else : NEW_LINE INDENT print " no " NEW_LINE DEDENT n = 14 NEW_LINE if ( isRefactorableNumber ( n ) ) : NEW_LINE INDENT print " yes " NEW_LINE DEDENT else : NEW_LINE INDENT print " no " NEW_LINE DEDENT
Hyp: 
def isRefactorableNumber ( n ) : NEW_LINE INDENT divCount = 0 NEW_LINE for i in range ( 1 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( n // i == i ) : NEW_LINE INDENT divCount += 1 NEW_LINE DEDENT else : NEW_LINE INDENT divCount += 2 NEW_LINE DEDENT DEDENT return n % divCount == 0 NEW_LINE DEDENT n = 65 NEW_LINE if ( isRefactorableNumber ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT

BLEU: 65.21
Edit Sim: 173


Src: 
int repUnitValue ( int n ) { if ( n % 2 == 0 n % 5 == 0 ) return 0 ; int rem = 1 ; int power = 1 ; int k = 1 ; while ( rem % n != 0 ) { k ++ ; power = power * 10 % n ; rem = ( rem + power ) % n ; } return k ; }
Ref: 
def repUnitValue ( n ) : NEW_LINE INDENT if ( n % 2 == 0 or n % 5 == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT rem = 1 NEW_LINE power = 1 NEW_LINE k = 1 NEW_LINE while ( rem % n != 0 ) : NEW_LINE INDENT k += 1 NEW_LINE power = power * 10 % n NEW_LINE rem = ( rem + power ) % n NEW_LINE DEDENT return k NEW_LINE DEDENT
Hyp: 
def repUnitValue ( n ) : NEW_LINE INDENT if ( n % 2 == 0 or n % 5 == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT rem = 1 ; NEW_LINE power = 1 ; NEW_LINE k = 1 ; NEW_LINE while ( rem % n != 0 ) : NEW_LINE INDENT k += 1 ; NEW_LINE power = power * 10 % n ; NEW_LINE rem = ( rem + power ) % n ; NEW_LINE DEDENT return k ; NEW_LINE DEDENT

BLEU: 76.35
Edit Sim: 16


Src: 
int minCost ( int arr [ ] , int n ) { int count_even = 0 ; int count_odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) count_even ++ ; else count_odd ++ ; } return Math . min ( count_even , count_odd ) ; }
Ref: 
def minCost ( arr , n ) : NEW_LINE INDENT count_even = 0 NEW_LINE count_odd = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT count_even += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_odd += 1 NEW_LINE DEDENT DEDENT return min ( count_even , count_odd ) NEW_LINE DEDENT
Hyp: 
def minCost ( arr , n ) : NEW_LINE INDENT count_even = 0 NEW_LINE count_odd = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT count_even += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_odd += 1 NEW_LINE DEDENT DEDENT return min ( count_even , count_odd ) NEW_LINE DEDENT

BLEU: 94.77
Edit Sim: 4


Src: 
int countValues ( int n ) { int countV = 0 ; for ( int i = 0 ; i <= n ; i ++ ) if ( ( n + i ) == ( n ^ i ) ) countV ++ ; return countV ; }
Ref: 
def countValues ( n ) : NEW_LINE INDENT countV = 0 ; NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT if ( ( n + i ) == ( n ^ i ) ) : NEW_LINE INDENT countV += 1 ; NEW_LINE DEDENT DEDENT return countV ; NEW_LINE DEDENT
Hyp: 
def countValues ( n ) : NEW_LINE INDENT countV = 0 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT if ( ( n + i ) == ( n ^ i ) ) : NEW_LINE INDENT countV += 1 NEW_LINE DEDENT DEDENT return countV NEW_LINE DEDENT

BLEU: 86.03
Edit Sim: 6


Src: 
boolean Move ( int a , int x , int b ) { if ( ( ( ( b - a ) % x == 0 ) || ( ( b - a - 1 ) % x == 0 ) && a + 1 != b ) && b >= a ) return true ; return false ; }
Ref: 
def Move ( a , x , b ) : NEW_LINE INDENT if ( ( ( ( b - a ) % x == 0 ) or ( ( b - a - 1 ) % x == 0 ) and a + 1 != b ) and b >= a ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
Hyp: 
def Move ( a , x , b ) : NEW_LINE INDENT if ( ( ( b - a ) % x == 0 ) or ( ( b - a - 1 ) % x == 0 ) and a + 1 != b ) and b >= a ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT a = 1 NEW_LINE x = 30 NEW_LINE b = 30 NEW_LINE if ( Move ( a , x , b ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT

BLEU: 53.8
Edit Sim: 187


Src: 
int count ( int n ) { return ( int ) ( - 1 + Math . sqrt ( 1 + 8 * n ) ) / 2 ; }
Ref: 
def count ( n ) : NEW_LINE INDENT return ( - 1 + sqrt ( 1 + 8 * n ) ) // 2 ; NEW_LINE DEDENT
Hyp: 
def count ( n ) : NEW_LINE INDENT return ( - 1 + math . sqrt ( 1 + 8 * n ) ) / 2 NEW_LINE DEDENT

BLEU: 75.45
Edit Sim: 10


Src: 
boolean isRectangle ( int a , int b , int c , int d ) { if ( a == b && a == c && a == d && c == d && b == c && b == d ) return true ; else if ( a == b && c == d ) return true ; else if ( a == d && c == b ) return true ; else if ( a == c && d == b ) return true ; else return false ; }
Ref: 
def isRectangle ( a , b , c , d ) : NEW_LINE INDENT if ( a == b and d == c ) or ( a == c and b == d ) or ( a == d and b == c ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
Hyp: 
def isRectangle ( a , b , c , d ) : NEW_LINE INDENT if ( a == b and a == c and a == d and c == d and b == c and b == d ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT elif ( a == b and c == d ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT elif ( a == d and c == b ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT elif ( a == c and d == b ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT elif ( a == c and d == b ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT else : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT

BLEU: 36.51
Edit Sim: 302


Src: 
int solve ( int low , int high , int T ) { while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( ( mid * ( mid + 1 ) ) == T ) return mid ; if ( mid > 0 && ( mid * ( mid + 1 ) ) > T && ( mid * ( mid - 1 ) ) <= T ) return mid - 1 ; if ( ( mid * ( mid + 1 ) ) > T ) high = mid - 1 ; else low = mid + 1 ; } return - 1 ; }
Ref: 
def solve ( low , high , T ) : NEW_LINE INDENT while low <= high : NEW_LINE INDENT mid = int ( ( low + high ) / 2 ) NEW_LINE if ( mid * ( mid + 1 ) ) == T : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( mid > 0 and ( mid * ( mid + 1 ) ) > T and ( mid * ( mid - 1 ) ) <= T ) : NEW_LINE INDENT return mid - 1 NEW_LINE DEDENT if ( mid * ( mid + 1 ) ) > T : NEW_LINE INDENT high = mid - 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT T = 15 NEW_LINE ans = solve ( 1 , T , 2 * T ) NEW_LINE if ans != - 1 : NEW_LINE INDENT ans -= 1 NEW_LINE DEDENT
Hyp: 
def solve ( low , high , T ) : NEW_LINE INDENT while ( low <= high ) : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE if ( ( mid * ( mid + 1 ) ) == T ) : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( mid > 0 and ( mid * ( mid + 1 ) ) > T and ( mid * ( mid - 1 ) ) <= T ) : NEW_LINE INDENT return mid - 1 NEW_LINE DEDENT if ( ( mid * ( mid + 1 ) ) > T : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT

BLEU: 70.44
Edit Sim: 133


Src: 
int findCnt ( int [ ] arr , int i , int curr , int n , int m ) { if ( i == n ) { return ( curr == m ? 1 : 0 ) ; } if ( v1 [ i ] [ curr ] ) return dp1 [ i ] [ curr ] ; v1 [ i ] [ curr ] = true ; dp1 [ i ] [ curr ] = findCnt ( arr , i + 1 , curr , n , m ) + findCnt ( arr , i + 1 , ( curr & arr [ i ] ) , n , m ) ; return dp1 [ i ] [ curr ] ; }
Ref: 
def findCnt ( arr , i , curr , n , m ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT return ( curr == m ) ; NEW_LINE DEDENT if ( v1 [ i ] [ curr ] ) : NEW_LINE INDENT return dp1 [ i ] [ curr ] ; NEW_LINE DEDENT v1 [ i ] [ curr ] = 1 ; NEW_LINE dp1 [ i ] [ curr ] = findCnt ( arr , i + 1 , curr , n , m ) + findCnt ( arr , i + 1 , ( curr & arr [ i ] ) , n , m ) ; NEW_LINE return dp1 [ i ] [ curr ] ; NEW_LINE DEDENT
Hyp: 
def findCnt ( arr , i , curr , n , m ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT return ( curr == m ? 1 : 0 ) NEW_LINE DEDENT if ( v1 [ i ] [ curr ] ) : NEW_LINE INDENT return dp1 [ i ] [ curr ] NEW_LINE DEDENT v1 [ i ] [ curr ] = 1 NEW_LINE dp1 [ i ] [ curr ] = findCnt ( arr , i + 1 , curr , n , m ) + findCnt ( arr , i + 1 , ( curr & arr [ i ] ) , n , m ) NEW_LINE return dp1 [ i ] [ curr ] NEW_LINE DEDENT

BLEU: 89.49
Edit Sim: 16


Src: 
int countDistinctSums ( int N , int L , int R ) { int minSum = L * N ; int maxSum = R * N ; return maxSum - minSum + 1 ; }
Ref: 
def countDistinctSums ( N , L , R ) : NEW_LINE INDENT minSum = L * N NEW_LINE maxSum = R * N NEW_LINE return maxSum - minSum + 1 NEW_LINE DEDENT
Hyp: 
def countDistinctSums ( N , L , R ) : NEW_LINE INDENT minSum = L * N NEW_LINE maxSum = R * N NEW_LINE return maxSum - minSum + 1 NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
void countFreq ( int arr [ ] , int n , int limit ) { int [ ] count = new int [ limit + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) count [ arr [ i ] ] ++ ; for ( int i = 0 ; i <= limit ; i ++ ) if ( count [ i ] > 0 ) System . out . println ( i + " ▁ " + count [ i ] ) ; }
Ref: 
def countFreq ( arr , n , limit ) : NEW_LINE INDENT count = [ 0 for i in range ( limit + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT count [ arr [ i ] ] += 1 NEW_LINE DEDENT for i in range ( limit + 1 ) : NEW_LINE INDENT if ( count [ i ] > 0 ) : NEW_LINE INDENT print ( i , count [ i ] ) NEW_LINE DEDENT DEDENT DEDENT
Hyp: 
def countFreq ( arr , n , limit ) : NEW_LINE INDENT count = [ 0 ] * ( limit + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT count [ arr [ i ] ] += 1 NEW_LINE DEDENT for i in range ( limit + 1 ) : NEW_LINE INDENT if ( count [ i ] > 0 ) : NEW_LINE INDENT print ( i , " ▁ " , count [ i ] ) NEW_LINE DEDENT DEDENT

BLEU: 88.61
Edit Sim: 30


Src: 
int ksmallest ( int arr [ ] , int n , int k ) { Arrays . sort ( arr ) ; if ( k < arr [ 0 ] ) return k ; if ( k == arr [ 0 ] ) return arr [ 0 ] + 1 ; if ( k > arr [ n - 1 ] ) return k + n ; if ( arr [ 0 ] == 1 ) k -- ; else k -= ( arr [ 0 ] - 1 ) ; for ( int i = 1 ; i < n ; i ++ ) { int c = arr [ i ] - arr [ i - 1 ] - 1 ; if ( k <= c ) return arr [ i - 1 ] + k ; else k -= c ; } return arr [ n - 1 ] + k ; }
Ref: 
def ksmallest ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) ; NEW_LINE if ( k < arr [ 0 ] ) : NEW_LINE INDENT return k ; NEW_LINE DEDENT if ( k == arr [ 0 ] ) : NEW_LINE INDENT return arr [ 0 ] + 1 ; NEW_LINE DEDENT if ( k > arr [ n - 1 ] ) : NEW_LINE INDENT return k + n ; NEW_LINE DEDENT if ( arr [ 0 ] == 1 ) : NEW_LINE INDENT k -= 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT k -= ( arr [ 0 ] - 1 ) ; NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT c = arr [ i ] - arr [ i - 1 ] - 1 ; NEW_LINE if ( k <= c ) : NEW_LINE INDENT return arr [ i - 1 ] + k ; NEW_LINE DEDENT else : NEW_LINE INDENT k -= c ; NEW_LINE DEDENT DEDENT return arr [ n - 1 ] + k ; NEW_LINE DEDENT
Hyp: 
def ksmallest ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE if ( k < arr [ 0 ] ) : NEW_LINE INDENT return k NEW_LINE DEDENT if ( k == arr [ 0 ] ) : NEW_LINE INDENT return arr [ 0 ] + 1 NEW_LINE DEDENT if ( k > arr [ n - 1 ] ) : NEW_LINE INDENT return k + n NEW_LINE DEDENT if ( arr [ 0 ] == 1 ) : NEW_LINE INDENT k -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT k -= ( arr [ 0 ] - 1 ) NEW_LINE DEDENT DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT c = arr [ i ] - arr [ i - 1 ] - 1 NEW_LINE if ( k <= c ) : NEW_LINE INDENT return arr [ i - 1 ] + k NEW_LINE DEDENT else : NEW_LINE INDENT k -= c NEW_LINE DEDENT DEDENT return arr [ n - 1 ] + k NEW_LINE DEDENT

BLEU: 86.11
Edit Sim: 27


Src: 
void survival ( int S , int N , int M ) { if ( ( ( N * 6 ) < ( M * 7 ) && S > 6 ) M > N ) System . out . println ( " No " ) ; else { int days = ( M * S ) / N ; if ( ( ( M * S ) % N ) != 0 ) days ++ ; System . out . println ( " Yes ▁ " + days ) ; } }
Ref: 
def survival ( S , N , M ) : NEW_LINE INDENT if ( ( ( N * 6 ) < ( M * 7 ) and S > 6 ) or M > N ) : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT else : NEW_LINE INDENT days = ( M * S ) / N NEW_LINE if ( ( ( M * S ) % N ) != 0 ) : NEW_LINE INDENT days += 1 NEW_LINE DEDENT print ( " Yes ▁ " ) , NEW_LINE print ( days ) NEW_LINE DEDENT DEDENT
Hyp: 
def survival ( S , N , M ) : NEW_LINE INDENT if ( ( N * 6 ) < ( M * 7 ) and S > 6 ) : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT days = ( M * S ) // N ; NEW_LINE if ( ( ( M * S ) % N ) != 0 ) : NEW_LINE INDENT days += 1 ; NEW_LINE DEDENT print ( " Yes ▁ " , days ) ; NEW_LINE DEDENT DEDENT

BLEU: 78.37
Edit Sim: 41


Src: 
double sumOfTheSeries ( int n ) { double sum = 0.0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += 1.0 / ( i * ( i + 1 ) ) ; return sum ; }
Ref: 
def sumOfTheSeries ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += 1.0 / ( i * ( i + 1 ) ) ; NEW_LINE DEDENT return sum NEW_LINE DEDENT
Hyp: 
def sumOfTheSeries ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += 1.0 / ( i * ( i + 1 ) ) NEW_LINE DEDENT return sum NEW_LINE DEDENT

BLEU: 94.41
Edit Sim: 2


Src: 
int countSetBits ( int N ) { int count = 0 ; for ( int i = 0 ; i < 4 * 8 ; i ++ ) { if ( ( N & ( 1 << i ) ) != 0 ) count ++ ; } return count ; }
Ref: 
def countSetBits ( N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 4 * 8 ) : NEW_LINE INDENT if ( N & ( 1 << i ) ) : NEW_LINE count += 1 NEW_LINE return count NEW_LINE N = 15 NEW_LINE print ( countSetBits ( N ) ) NEW_LINE DEDENT DEDENT
Hyp: 
def countSetBits ( N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 4 * 8 ) : NEW_LINE INDENT if ( ( N & ( 1 << i ) ) != 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT

BLEU: 69.07
Edit Sim: 70


Src: 
boolean almostSort ( int A [ ] , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( A [ i ] > A [ i + 1 ] ) { int temp = A [ i ] ; A [ i ] = A [ i + 1 ] ; A [ i + 1 ] = temp ; i ++ ; } } for ( int i = 0 ; i < n - 1 ; i ++ ) if ( A [ i ] > A [ i + 1 ] ) return false ; return true ; }
Ref: 
def almostSort ( A , n ) : NEW_LINE INDENT i = 0 NEW_LINE while i < n - 1 : NEW_LINE INDENT if A [ i ] > A [ i + 1 ] : NEW_LINE INDENT A [ i ] , A [ i + 1 ] = A [ i + 1 ] , A [ i ] NEW_LINE i += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if A [ i ] > A [ i + 1 ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
Hyp: 
def almostSort ( A , n ) : NEW_LINE INDENT for i in range ( n - 1 ) : NEW_LINE INDENT if ( A [ i ] > A [ i + 1 ] ) : NEW_LINE INDENT temp = A [ i ] NEW_LINE A [ i ] = A [ i + 1 ] NEW_LINE A [ i + 1 ] = temp NEW_LINE i += 1 NEW_LINE DEDENT DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT if ( A [ i ] > A [ i + 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT A = [ 7 , 5 , 3 , 2 ] NEW_LINE n = len ( A ) NEW_LINE if ( almostSort ( A , n ) != 0 ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT

BLEU: 47.44
Edit Sim: 278


Src: 
int countSquares ( int n ) { return ( int ) ( Math . pow ( n , 2 ) - ( 2 * n ) + 2 ) ; }
Ref: 
def countSquares ( n ) : NEW_LINE INDENT return ( pow ( n , 2 ) - ( 2 * n ) + 2 ) ; NEW_LINE DEDENT
Hyp: 
def countSquares ( n ) : NEW_LINE INDENT return ( pow ( n , 2 ) - ( 2 * n ) + 2 ) ; NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
long getSum ( long n , int d ) { if ( n < d ) return 0 ; while ( n % 10 != d ) n -- ; long k = n / 10 ; return ( k + 1 ) * d + ( k * 10 + 10 * k * k ) / 2 ; }
Ref: 
def getSum ( n , d ) : NEW_LINE INDENT if ( n < d ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT while ( n % 10 != d ) : NEW_LINE INDENT n -= 1 NEW_LINE DEDENT k = n // 10 NEW_LINE return ( ( k + 1 ) * d + ( k * 10 + 10 * k * k ) // 2 ) NEW_LINE DEDENT
Hyp: 
def getSum ( n , d ) : NEW_LINE INDENT if ( n < d ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT while ( n % 10 != d ) : NEW_LINE INDENT n -= 1 NEW_LINE DEDENT k = n // 10 NEW_LINE return ( k + 1 ) * d + ( k * 10 + 10 * k * k ) // 2 NEW_LINE DEDENT

BLEU: 94.24
Edit Sim: 4


Src: 
int sum ( int k , int n ) { int sum = ( int ) ( Math . pow ( k , n + 1 ) - Math . pow ( k - 1 , n + 1 ) ) ; return sum ; }
Ref: 
def sum ( k , n ) : NEW_LINE INDENT sum = ( pow ( k , n + 1 ) - pow ( k - 1 , n + 1 ) ) ; NEW_LINE return sum ; NEW_LINE DEDENT
Hyp: 
def sum ( k , n ) : NEW_LINE INDENT sum = ( pow ( k , n + 1 ) - pow ( k - 1 , n + 1 ) ) ; NEW_LINE return sum ; NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
void pen_hex ( long n ) { long pn = 1 ; for ( long i = 1 ; i < n ; i ++ ) { pn = i * ( 3 * i - 1 ) / 2 ; if ( pn > n ) break ; double seqNum = ( 1 + Math . sqrt ( 8 * pn + 1 ) ) / 4 ; if ( seqNum == ( long ) seqNum ) System . out . print ( pn + " , ▁ " ) ; } }
Ref: 
def pen_hex ( n ) : NEW_LINE INDENT pn = 1 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT pn = ( int ) ( i * ( 3 * i - 1 ) / 2 ) NEW_LINE if ( pn > n ) : NEW_LINE INDENT break NEW_LINE DEDENT seqNum = ( 1 + math . sqrt ( 8 * pn + 1 ) ) / 4 NEW_LINE if ( seqNum == ( int ) ( seqNum ) ) : NEW_LINE INDENT print ( pn , end = " , ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
Hyp: 
def pen_hex ( n ) : NEW_LINE INDENT pn = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT pn = i * ( 3 * i - 1 ) / 2 NEW_LINE if ( pn > n ) : NEW_LINE INDENT break NEW_LINE DEDENT seqNum = ( 1 + math . sqrt ( 8 * pn + 1 ) ) // 4 NEW_LINE if ( seqNum == ( long ) seqNum ) : NEW_LINE INDENT print ( pn , end = " , ▁ " ) NEW_LINE DEDENT DEDENT DEDENT

BLEU: 81.21
Edit Sim: 21


Src: 
int countOfPairs ( int arr [ ] , int N , int X ) { int count = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( ( ( arr [ i ] ^ arr [ j ] ) & X ) == 0 ) count ++ ; } } return count ; }
Ref: 
def countOfPairs ( arr , N , X ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT if ( ( ( arr [ i ] ^ arr [ j ] ) & X ) == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
Hyp: 
def countOfPairs ( arr , N , X ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT if ( ( arr [ i ] ^ arr [ j ] ) & X ) == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT

BLEU: 98.34
Edit Sim: 2


Src: 
int calculate ( int n , int k , int m , int power ) { if ( n > m ) { if ( power == 0 ) return 0 ; else return power - 1 ; } else if ( n == m ) return power ; else return calculate ( n * k , k , m , power + 1 ) ; }
Ref: 
def calculate ( n , k , m , power ) : NEW_LINE INDENT if n > m : NEW_LINE INDENT if power == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return power - 1 NEW_LINE DEDENT DEDENT elif n == m : NEW_LINE INDENT return power NEW_LINE DEDENT else : NEW_LINE INDENT return calculate ( n * k , k , m , power + 1 ) NEW_LINE DEDENT DEDENT
Hyp: 
def calculate ( n , k , m , power ) : NEW_LINE INDENT if ( n > m ) : NEW_LINE INDENT if ( power == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT else : NEW_LINE INDENT return power - 1 ; NEW_LINE DEDENT DEDENT elif ( n == m ) : NEW_LINE INDENT return power ; NEW_LINE DEDENT else : NEW_LINE INDENT return calculate ( n * k , k , m , power + 1 ) ; NEW_LINE DEDENT DEDENT

BLEU: 69.27
Edit Sim: 20


Src: 
int noOfTriangles ( int n ) { int y = 4 * n ; return ( ( y * ( y - 2 ) * ( y - 1 ) ) - ( 4 * n * ( n - 2 ) * ( n - 1 ) ) ) / 6 ; }
Ref: 
def noOfTriangles ( n ) : NEW_LINE INDENT y = 4 * n NEW_LINE return ( ( y * ( y - 2 ) * ( y - 1 ) ) - ( 4 * n * ( n - 2 ) * ( n - 1 ) ) ) // 6 NEW_LINE DEDENT
Hyp: 
def noOfTriangles ( n ) : NEW_LINE INDENT y = 4 * n NEW_LINE return ( ( y * ( y - 2 ) * ( y - 1 ) ) - ( 4 * n * ( n - 2 ) * ( n - 1 ) ) ) // 6 NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int minimumProduct ( int [ ] arr , int n ) { Arrays . sort ( arr ) ; int product = 1 ; for ( int i = 0 ; i < n ; i += 2 ) { product *= ( arr [ i ] + arr [ i + 1 ] ) ; } return product ; }
Ref: 
def minimumProduct ( arr , n ) : NEW_LINE INDENT arr = sorted ( arr ) NEW_LINE product = 1 NEW_LINE for i in range ( 0 , n , 2 ) : NEW_LINE INDENT product *= ( arr [ i ] + arr [ i + 1 ] ) NEW_LINE DEDENT return product NEW_LINE DEDENT
Hyp: 
def minimumProduct ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE product = 1 NEW_LINE for i in range ( 0 , n , 2 ) : NEW_LINE INDENT product *= ( arr [ i ] + arr [ i + 1 ] ) NEW_LINE DEDENT return product NEW_LINE DEDENT

BLEU: 90.44
Edit Sim: 7


Src: 
int bitwiseOrTillN ( int n ) { if ( n < 2 ) return 0 ; int bitCount = ( int ) ( Math . log ( n ) / Math . log ( 2 ) ) + 1 ; return ( int ) Math . pow ( 2 , bitCount ) - 2 ; }
Ref: 
def bitwiseOrTillN ( n ) : NEW_LINE INDENT if ( n < 2 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT bitCount = int ( log2 ( n ) ) + 1 ; NEW_LINE return pow ( 2 , bitCount ) - 2 ; NEW_LINE DEDENT
Hyp: 
def bitwiseOrTillN ( n ) : NEW_LINE INDENT if ( n < 2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT bitCount = int ( math . log2 ( n ) ) + 1 NEW_LINE return int ( math . pow ( 2 , bitCount ) - 2 ) NEW_LINE DEDENT

BLEU: 71.3
Edit Sim: 25


Src: 
void checkperfectsquare ( int n ) { if ( Math . ceil ( ( double ) Math . sqrt ( n ) ) == Math . floor ( ( double ) Math . sqrt ( n ) ) ) { System . out . print ( " perfect ▁ square " ) ; } else { System . out . print ( " not ▁ a ▁ perfect ▁ square " ) ; } }
Ref: 
def checkperfectsquare ( x ) : NEW_LINE INDENT if ( math . ceil ( math . sqrt ( n ) ) == math . floor ( math . sqrt ( n ) ) ) : NEW_LINE INDENT print ( " perfect ▁ square " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " not ▁ a ▁ perfect ▁ square " ) NEW_LINE DEDENT DEDENT
Hyp: 
def checkperfectsquare ( n ) : NEW_LINE INDENT if ( math . ceil ( math . sqrt ( n ) ) == math . floor ( math . sqrt ( n ) ) ) : NEW_LINE INDENT print ( " perfect ▁ square " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " not ▁ a ▁ perfect ▁ square " ) NEW_LINE DEDENT DEDENT

BLEU: 96.14
Edit Sim: 1


Src: 
int pairAndSum ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) ans += arr [ i ] & arr [ j ] ; return ans ; }
Ref: 
def pairAndSum ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( ( i + 1 ) , n ) : NEW_LINE INDENT ans = ans + arr [ i ] & arr [ j ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
Hyp: 
def pairAndSum ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT ans += arr [ i ] & arr [ j ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT

BLEU: 77.73
Edit Sim: 32


Src: 
int solve ( int [ ] a ) { int n = a . length ; int [ ] dp = new int [ n + 1 ] ; int [ ] val = new int [ n + 1 ] ; for ( int i = n - 1 ; i >= 0 ; i -- ) { int sum = a [ i ] ; int j = i ; while ( j + 1 < n && sum < val [ j + 1 ] ) { j ++ ; sum += a [ j ] ; } dp [ i ] = ( j - i ) + dp [ j + 1 ] ; val [ i ] = sum ; } return dp [ 0 ] ; }
Ref: 
def solve ( a ) : NEW_LINE INDENT n = len ( a ) NEW_LINE dp = [ 0 ] * ( n + 1 ) NEW_LINE val = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT sum = a [ i ] NEW_LINE j = i NEW_LINE while ( j + 1 < n and sum < val [ j + 1 ] ) : NEW_LINE INDENT j += 1 NEW_LINE sum += a [ j ] NEW_LINE DEDENT dp [ i ] = ( j - i ) + dp [ j + 1 ] NEW_LINE val [ i ] = sum NEW_LINE DEDENT return dp [ 0 ] NEW_LINE DEDENT
Hyp: 
def solve ( a ) : NEW_LINE INDENT n = len ( a ) NEW_LINE dp = [ 0 for i in range ( n + 1 ) ] NEW_LINE val = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT sum = a [ i ] NEW_LINE j = i NEW_LINE while ( j + 1 < n and sum < val [ j + 1 ] ) : NEW_LINE j += 1 NEW_LINE sum += a [ j ] NEW_LINE DEDENT dp [ i ] = ( j - i ) + dp [ j + 1 ] NEW_LINE val [ i ] = sum NEW_LINE DEDENT return dp [ 0 ] NEW_LINE DEDENT

BLEU: 87.47
Edit Sim: 37


Src: 
int longestSubseqWithDiffOne ( int arr [ ] , int n ) { int dp [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) dp [ i ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( ( arr [ i ] == arr [ j ] + 1 ) || ( arr [ i ] == arr [ j ] - 1 ) ) dp [ i ] = Math . max ( dp [ i ] , dp [ j ] + 1 ) ; } } int result = 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( result < dp [ i ] ) result = dp [ i ] ; return result ; }
Ref: 
def longestSubseqWithDiffOne ( arr , n ) : NEW_LINE INDENT dp = [ 1 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( ( arr [ i ] == arr [ j ] + 1 ) or ( arr [ i ] == arr [ j ] - 1 ) ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i ] , dp [ j ] + 1 ) NEW_LINE DEDENT DEDENT DEDENT result = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( result < dp [ i ] ) : NEW_LINE INDENT result = dp [ i ] NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
Hyp: 
def longestSubseqWithDiffOne ( arr , n ) : NEW_LINE INDENT dp = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ i ] == arr [ j ] + 1 or arr [ i ] == arr [ j ] - 1 ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i ] , dp [ j ] + 1 ) NEW_LINE DEDENT DEDENT DEDENT result = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( result < dp [ i ] ) : NEW_LINE INDENT result = dp [ i ] NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT

BLEU: 83.34
Edit Sim: 64


Src: 
void longestSubSequence ( int [ ] [ ] A , int N ) { int [ ] dp = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { dp [ i ] = 1 ; for ( int j = 0 ; j < i ; j ++ ) { if ( A [ j ] [ 0 ] < A [ i ] [ 0 ] && A [ j ] [ 1 ] > A [ i ] [ 1 ] ) { dp [ i ] = Math . max ( dp [ i ] , dp [ j ] + 1 ) ; } } } System . out . println ( dp [ N - 1 ] ) ; }
Ref: 
def longestSubSequence ( A , N ) : NEW_LINE INDENT dp = [ 0 ] * N NEW_LINE for i in range ( N ) : NEW_LINE INDENT dp [ i ] = 1 NEW_LINE for j in range ( i ) : NEW_LINE INDENT if ( A [ j ] [ 0 ] < A [ i ] [ 0 ] and A [ j ] [ 1 ] > A [ i ] [ 1 ] ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i ] , dp [ j ] + 1 ) NEW_LINE DEDENT DEDENT DEDENT print ( dp [ N - 1 ] ) NEW_LINE DEDENT
Hyp: 
def longestSubSequence ( A , N ) : NEW_LINE INDENT dp = [ None ] * N NEW_LINE for i in range ( N ) : NEW_LINE INDENT dp [ i ] = 1 NEW_LINE for j in range ( i ) : NEW_LINE INDENT if ( A [ j ] [ 0 ] < A [ i ] [ 0 ] and A [ j ] [ 1 ] > A [ i ] [ 1 ] ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i ] , dp [ j ] + 1 ) NEW_LINE DEDENT DEDENT DEDENT print ( dp [ N - 1 ] ) NEW_LINE DEDENT

BLEU: 97.82
Edit Sim: 4


Src: 
int MinimumValue ( int a [ ] , int n ) { int answer = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { answer = Math . min ( answer , ( ( a [ i ] & a [ j ] ) ^ ( a [ i ] a [ j ] ) ) ) ; } } return answer ; }
Ref: 
def MinimumValue ( a , n ) : NEW_LINE INDENT answer = sys . maxsize NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n , 1 ) : NEW_LINE INDENT answer = min ( answer , ( ( a [ i ] & a [ j ] ) ^ ( a [ i ] a [ j ] ) ) ) NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT
Hyp: 
def MinimumValue ( a , n ) : NEW_LINE INDENT answer = sys . maxsize NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT answer = min ( answer , ( ( a [ i ] & a [ j ] ) ^ ( a [ i ] a [ j ] ) ) ) NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT

BLEU: 95.55
Edit Sim: 4


Src: 
void sumOfInfiniteAGP ( double a , double d , double r ) { double ans = a / ( 1 - r ) + ( d * r ) / ( 1 - r * r ) ; System . out . print ( ans ) ; }
Ref: 
def sumOfInfiniteAGP ( a , d , r ) : NEW_LINE INDENT ans = a / ( 1 - r ) + ( d * r ) / ( 1 - r * r ) ; NEW_LINE print ( round ( ans , 6 ) ) NEW_LINE DEDENT
Hyp: 
def sumOfInfiniteAGP ( a , d , r ) : NEW_LINE INDENT ans = a / ( 1 - r ) + ( d * r ) / ( 1 - r * r ) NEW_LINE print ( ans ) NEW_LINE DEDENT

BLEU: 79.0
Edit Sim: 16


Src: 
void checkHex ( String s ) { int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { char ch = s . charAt ( i ) ; if ( ( ch < '0' ch > '9' ) && ( ch < ' A ' ch > ' F ' ) ) { System . out . println ( " No " ) ; return ; } } System . out . println ( " Yes " ) ; }
Ref: 
def checkHex ( s ) : NEW_LINE INDENT for ch in s : NEW_LINE INDENT if ( ( ch < '0' or ch > '9' ) and ( ch < ' A ' or ch > ' F ' ) ) : NEW_LINE INDENT print ( " No " ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( " Yes " ) NEW_LINE DEDENT
Hyp: 
def checkHex ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT ch = s [ i ] NEW_LINE if ( ( ch < '0' ch > '9' ) and ( ch < ' A ' ch > ' F ' ) ) : NEW_LINE INDENT print ( " No " ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( " Yes " ) NEW_LINE DEDENT

BLEU: 64.2
Edit Sim: 68


Src: 
int smallestMaximum ( int N , int K ) { int sum = ( ( N + K - 1 ) / K ) * K ; if ( sum % N != 0 ) return ( sum / N ) + 1 ; else return sum / N ; }
Ref: 
def smallestMaximum ( N , K ) : NEW_LINE INDENT sum = ( ( N + K - 1 ) // K ) * K NEW_LINE if ( sum % N != 0 ) : NEW_LINE INDENT return ( sum // N ) + 1 NEW_LINE DEDENT else : NEW_LINE INDENT return sum // N NEW_LINE DEDENT DEDENT
Hyp: 
def smallestMaximum ( N , K ) : NEW_LINE INDENT sum = ( ( N + K - 1 ) / K ) * K NEW_LINE if ( sum % N ) : NEW_LINE INDENT return ( sum // N ) + 1 NEW_LINE DEDENT else : NEW_LINE INDENT return ( sum // N ) NEW_LINE DEDENT DEDENT

BLEU: 83.8
Edit Sim: 10


Src: 
> FractionSplit ( long n , long d ) { Vector < String > UnitFactions = new Vector < > ( ) ; while ( n > 0 ) { long x = ( d + n - 1 ) / n ; String s = "1 / " + String . valueOf ( x ) ; UnitFactions . add ( s ) ; n = n * x - d ; d = d * x ; } return UnitFactions ; }
Ref: 
def FractionSplit ( n , d ) : NEW_LINE INDENT UnitFactions = [ ] NEW_LINE while ( n > 0 ) : NEW_LINE INDENT x = ( d + n - 1 ) // n NEW_LINE s = "1 / " + str ( x ) NEW_LINE UnitFactions . append ( s ) ; NEW_LINE n = n * x - d ; NEW_LINE d = d * x NEW_LINE DEDENT return UnitFactions ; NEW_LINE DEDENT n = 13 ; NEW_LINE d = 18 ; NEW_LINE res = FractionSplit ( n , d ) ; NEW_LINE for s in res : NEW_LINE INDENT print ( s + " , ▁ " , end = " ▁ " ) ; NEW_LINE DEDENT
Hyp: 
def FractionSplit ( n , d ) : NEW_LINE INDENT UnitFactions = [ ] NEW_LINE while ( n > 0 ) : NEW_LINE INDENT x = ( d + n - 1 ) // n NEW_LINE s = "1 / " + str ( x ) NEW_LINE UnitFactions . append ( s ) NEW_LINE n = n * x - d NEW_LINE d = d * x NEW_LINE DEDENT return UnitFactions NEW_LINE DEDENT

BLEU: 48.69
Edit Sim: 168


Src: 
boolean sameLength ( int A , int B ) { while ( ( A > 0 ) && ( B > 0 ) ) { A = A / 10 ; B = B / 10 ; } if ( ( A == 0 ) && ( B == 0 ) ) return true ; return false ; }
Ref: 
def sameLength ( A , B ) : NEW_LINE INDENT while ( A > 0 and B > 0 ) : NEW_LINE INDENT A = A / 10 ; NEW_LINE B = B / 10 ; NEW_LINE DEDENT if ( A == 0 and B == 0 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT A = 21 ; B = 1 ; NEW_LINE if ( sameLength ( A , B ) ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT
Hyp: 
def sameLength ( A , B ) : NEW_LINE INDENT while ( A > 0 ) and ( B > 0 ) : NEW_LINE INDENT A = A // 10 NEW_LINE B = B // 10 NEW_LINE DEDENT if ( ( A == 0 ) and ( B == 0 ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT

BLEU: 34.91
Edit Sim: 188


Src: 
int calculateSquareSum ( int n ) { if ( n <= 0 ) return 0 ; int fibo [ ] = new int [ n + 1 ] ; fibo [ 0 ] = 0 ; fibo [ 1 ] = 1 ; int sum = ( fibo [ 0 ] * fibo [ 0 ] ) + ( fibo [ 1 ] * fibo [ 1 ] ) ; for ( int i = 2 ; i <= n ; i ++ ) { fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ; sum += ( fibo [ i ] * fibo [ i ] ) ; } return sum ; }
Ref: 
def calculateSquareSum ( n ) : NEW_LINE INDENT fibo = [ 0 ] * ( n + 1 ) ; NEW_LINE if ( n <= 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT fibo [ 0 ] = 0 ; NEW_LINE fibo [ 1 ] = 1 ; NEW_LINE sum = ( ( fibo [ 0 ] * fibo [ 0 ] ) + ( fibo [ 1 ] * fibo [ 1 ] ) ) ; NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT fibo [ i ] = ( fibo [ i - 1 ] + fibo [ i - 2 ] ) ; NEW_LINE sum += ( fibo [ i ] * fibo [ i ] ) ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT
Hyp: 
def calculateSquareSum ( n ) : NEW_LINE INDENT if ( n <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT fibo = [ 0 ] * ( n + 1 ) NEW_LINE fibo [ 0 ] = 0 NEW_LINE fibo [ 1 ] = 1 NEW_LINE sum = ( fibo [ 0 ] * fibo [ 0 ] ) + ( fibo [ 1 ] * fibo [ 1 ] ) NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] NEW_LINE sum += ( fibo [ i ] * fibo [ i ] ) NEW_LINE DEDENT return sum NEW_LINE DEDENT

BLEU: 78.2
Edit Sim: 78


Src: 
void maximum_pallindromic ( int arr [ ] ) { int res = 0 ; int c1 = 0 , c2 = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) { res += arr [ i ] / 3 ; arr [ i ] = arr [ i ] % 3 ; if ( arr [ i ] == 1 ) c1 ++ ; else if ( arr [ i ] == 2 ) c2 ++ ; } res += Math . min ( c1 , c2 ) ; int t = Math . min ( c1 , c2 ) ; c1 -= t ; c2 -= t ; res += 2 * ( c2 / 3 ) ; c2 %= 3 ; res += c2 / 2 ; System . out . print ( res ) ; }
Ref: 
def maximum_pallindromic ( arr ) : NEW_LINE INDENT res = 0 NEW_LINE c1 = 0 NEW_LINE c2 = 0 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT res += arr [ i ] // 3 NEW_LINE arr [ i ] = arr [ i ] % 3 NEW_LINE if ( arr [ i ] == 1 ) : NEW_LINE INDENT c1 += 1 NEW_LINE DEDENT elif ( arr [ i ] == 2 ) : NEW_LINE INDENT c2 += 1 NEW_LINE DEDENT DEDENT res += min ( c1 , c2 ) NEW_LINE t = min ( c1 , c2 ) NEW_LINE c1 -= t NEW_LINE c2 -= t NEW_LINE res += 2 * ( c2 // 3 ) NEW_LINE c2 %= 3 NEW_LINE res += c2 // 2 NEW_LINE print ( res ) NEW_LINE DEDENT
Hyp: 
def maximum_pallindromic ( arr ) : NEW_LINE INDENT res = 0 NEW_LINE c1 = 0 NEW_LINE c2 = 0 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT res += arr [ i ] // 3 NEW_LINE arr [ i ] = arr [ i ] % 3 NEW_LINE DEDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT c1 += 1 NEW_LINE DEDENT elif ( arr [ i ] == 2 ) : NEW_LINE INDENT c2 += 1 NEW_LINE DEDENT DEDENT res += min ( c1 , c2 ) NEW_LINE t = min ( c1 , c2 ) NEW_LINE c1 -= t NEW_LINE c2 -= t NEW_LINE res += 2 * ( c2 // 3 ) NEW_LINE c2 %= 3 NEW_LINE res += c2 // 2 NEW_LINE DEDENT print ( res ) NEW_LINE DEDENT

BLEU: 96.39
Edit Sim: 14


Src: 
boolean isEven ( String s1 ) { int l = s1 . length ( ) ; char [ ] s = s1 . toCharArray ( ) ; boolean dotSeen = false ; for ( int i = l - 1 ; i >= 0 ; i -- ) { if ( s [ i ] == '0' && dotSeen == false ) continue ; if ( s [ i ] == ' . ' ) { dotSeen = true ; continue ; } if ( ( s [ i ] - '0' ) % 2 == 0 ) return true ; return false ; } return false ; }
Ref: 
def isEven ( s ) : NEW_LINE INDENT l = len ( s ) NEW_LINE dotSeen = False NEW_LINE for i in range ( l - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( s [ i ] == '0' and dotSeen == False ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( s [ i ] == ' . ' ) : NEW_LINE INDENT dotSeen = True NEW_LINE continue NEW_LINE DEDENT if ( ( int ) ( s [ i ] ) % 2 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT DEDENT s = "100.70" NEW_LINE if ( isEven ( s ) ) : NEW_LINE INDENT print ( " Even " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Odd " ) NEW_LINE DEDENT
Hyp: 
def isEven ( s1 ) : NEW_LINE INDENT l = len ( s1 ) NEW_LINE s = s1 [ : l - 1 ] NEW_LINE dotSeen = False NEW_LINE for i in range ( l - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( s [ i ] == '0' and dotSeen == False ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( s [ i ] == ' . ' ) : NEW_LINE INDENT dotSeen = True NEW_LINE continue NEW_LINE DEDENT if ( ( ord ( s [ i ] ) - ord ( '0' ) % 2 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT

BLEU: 67.8
Edit Sim: 207


Src: 
int right_angled ( int n ) { int count = 0 ; for ( int z = 1 ; z <= n ; z ++ ) { for ( int y = 1 ; y <= z ; y ++ ) { for ( int x = 1 ; x <= y ; x ++ ) { if ( ( x * x ) + ( y * y ) == ( z * z ) ) { count ++ ; } } } } return count ; }
Ref: 
def right_angled ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for z in range ( 1 , n + 1 ) : NEW_LINE INDENT for y in range ( 1 , z + 1 ) : NEW_LINE INDENT for x in range ( 1 , y + 1 ) : NEW_LINE INDENT if ( ( x * x ) + ( y * y ) == ( z * z ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
Hyp: 
def right_angled ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for z in range ( 1 , n + 1 ) : NEW_LINE INDENT for y in range ( 1 , z + 1 ) : NEW_LINE INDENT for x in range ( 1 , y + 1 ) : NEW_LINE INDENT if ( ( x * x ) + ( y * y ) == ( z * z ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT

BLEU: 98.87
Edit Sim: 7


Src: 
boolean isSumOfPowersOfTwo ( int n ) { if ( n % 2 == 1 ) return false ; else return true ; }
Ref: 
def isSumOfPowersOfTwo ( n ) : NEW_LINE INDENT if n % 2 == 1 : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT n = 10 NEW_LINE if isSumOfPowersOfTwo ( n ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
Hyp: 
def isSumOfPowersOfTwo ( n ) : NEW_LINE INDENT return ( n % 2 == 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT

BLEU: 23.43
Edit Sim: 189


Src: 
String nambiarNumber ( String str , int i ) { if ( i >= str . length ( ) ) return " " ; int firstDigit = ( str . charAt ( i ) - '0' ) ; int digitParity = firstDigit % 2 ; int sumDigits = 0 ; while ( i < str . length ( ) ) { sumDigits += ( str . charAt ( i ) - '0' ) ; int sumParity = sumDigits % 2 ; if ( digitParity != sumParity ) { break ; } i ++ ; } return ( " " + sumDigits + nambiarNumber ( str , i + 1 ) ) ; }
Ref: 
def nambiarNumber ( Str , i ) : NEW_LINE INDENT if ( i >= len ( Str ) ) : NEW_LINE INDENT return " " NEW_LINE DEDENT firstDigit = ord ( Str [ i ] ) - ord ( '0' ) NEW_LINE digitParity = firstDigit % 2 NEW_LINE sumDigits = 0 NEW_LINE while ( i < len ( Str ) ) : NEW_LINE INDENT sumDigits += ( ord ( Str [ i ] ) - ord ( '0' ) ) NEW_LINE sumParity = sumDigits % 2 NEW_LINE if ( digitParity != sumParity ) : NEW_LINE INDENT break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return ( " " + str ( sumDigits ) + nambiarNumber ( Str , i + 1 ) ) NEW_LINE DEDENT
Hyp: 
def nambiarNumber ( str , i ) : NEW_LINE INDENT if ( i >= len ( str ) ) : NEW_LINE INDENT return " " NEW_LINE DEDENT firstDigit = ord ( str [ i ] ) - ord ( '0' ) NEW_LINE digitParity = firstDigit % 2 NEW_LINE sumDigits = 0 NEW_LINE while ( i < len ( str ) ) : NEW_LINE INDENT sumDigits += ord ( str [ i ] ) - ord ( '0' ) NEW_LINE sumParity = sumDigits % 2 NEW_LINE if ( digitParity != sumParity ) : NEW_LINE INDENT break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return ( " " + sumDigits + nambiarNumber ( str , i + 1 ) ) NEW_LINE DEDENT

BLEU: 80.17
Edit Sim: 18


Src: 
int sumofseries ( int n ) { return ( n * ( n + 1 ) * ( n + 2 ) * ( n + 3 ) / 4 ) ; }
Ref: 
def sumofseries ( n ) : NEW_LINE INDENT return int ( n * ( n + 1 ) * ( n + 2 ) * ( n + 3 ) / 4 ) NEW_LINE DEDENT
Hyp: 
def sumofseries ( n ) : NEW_LINE INDENT return ( n * ( n + 1 ) * ( n + 2 ) * ( n + 3 ) // 4 ) NEW_LINE DEDENT

BLEU: 85.0
Edit Sim: 5


Src: 
int difference ( int n ) { int S , res ; S = ( n * ( n + 1 ) ) / 2 ; res = S * ( S - 1 ) ; return res ; }
Ref: 
def difference ( n ) : NEW_LINE INDENT S = ( n * ( n + 1 ) ) // 2 ; NEW_LINE res = S * ( S - 1 ) ; NEW_LINE return res ; NEW_LINE DEDENT
Hyp: 
def difference ( n ) : NEW_LINE INDENT S = ( n * ( n + 1 ) ) / 2 NEW_LINE res = S * ( S - 1 ) NEW_LINE return res NEW_LINE DEDENT

BLEU: 75.61
Edit Sim: 7


Src: 
int colMaxDiff ( int mat [ ] [ ] ) { int max_diff = Integer . MIN_VALUE ; for ( int i = 0 ; i < N ; i ++ ) { int max_val = mat [ 0 ] [ i ] , min_val = mat [ 0 ] [ i ] ; for ( int j = 1 ; j < N ; j ++ ) { max_val = Math . max ( max_val , mat [ j ] [ i ] ) ; min_val = Math . min ( min_val , mat [ j ] [ i ] ) ; } max_diff = Math . max ( max_diff , max_val - min_val ) ; } return max_diff ; }
Ref: 
def colMaxDiff ( mat ) : NEW_LINE INDENT max_diff = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT max_val = mat [ 0 ] [ i ] NEW_LINE min_val = mat [ 0 ] [ i ] NEW_LINE for j in range ( 1 , N ) : NEW_LINE INDENT max_val = max ( max_val , mat [ j ] [ i ] ) NEW_LINE min_val = min ( min_val , mat [ j ] [ i ] ) NEW_LINE DEDENT max_diff = max ( max_diff , max_val - min_val ) NEW_LINE DEDENT return max_diff NEW_LINE DEDENT
Hyp: 
def colMaxDiff ( mat ) : NEW_LINE INDENT max_diff = INT_MIN ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT max_val = mat [ 0 ] [ i ] NEW_LINE min_val = mat [ 0 ] [ i ] NEW_LINE for j in range ( 1 , N ) : NEW_LINE INDENT max_val = max ( max_val , mat [ j ] [ i ] ) NEW_LINE min_val = min ( min_val , mat [ j ] [ i ] ) NEW_LINE DEDENT max_diff = max ( max_diff , max_val - min_val ) NEW_LINE DEDENT return max_diff NEW_LINE DEDENT

BLEU: 96.53
Edit Sim: 9


Src: 
int countSquares ( int n ) { int r = ( int ) Math . ceil ( Math . sqrt ( Math . pow ( 10 , n ) ) ) ; int l = ( int ) Math . ceil ( Math . sqrt ( Math . pow ( 10 , n - 1 ) ) ) ; return r - l ; }
Ref: 
def countSquares ( n ) : NEW_LINE INDENT r = math . ceil ( math . sqrt ( math . pow ( 10 , n ) ) ) ; NEW_LINE l = math . ceil ( math . sqrt ( math . pow ( 10 , n - 1 ) ) ) ; NEW_LINE return r - l ; NEW_LINE DEDENT
Hyp: 
def countSquares ( n ) : NEW_LINE INDENT r = math . ceil ( math . sqrt ( pow ( 10 , n ) ) ) NEW_LINE l = math . ceil ( math . sqrt ( pow ( 10 , n - 1 ) ) ) NEW_LINE return r - l NEW_LINE DEDENT

BLEU: 75.23
Edit Sim: 20


Src: 
double getMaxMedian ( int [ ] arr , int n , int k ) { int size = n + k ; Arrays . sort ( arr ) ; if ( size % 2 == 0 ) { double median = ( double ) ( arr [ ( size / 2 ) - 1 ] + arr [ size / 2 ] ) / 2 ; return median ; } double median1 = arr [ size / 2 ] ; return median1 ; }
Ref: 
def getMaxMedian ( arr , n , k ) : NEW_LINE INDENT size = n + k NEW_LINE arr . sort ( reverse = False ) NEW_LINE if ( size % 2 == 0 ) : NEW_LINE INDENT median = ( arr [ int ( size / 2 ) - 1 ] + arr [ int ( size / 2 ) ] ) / 2 NEW_LINE return median NEW_LINE DEDENT median = arr [ int ( size / 2 ) ] NEW_LINE return median NEW_LINE DEDENT
Hyp: 
def getMaxMedian ( arr , n , k ) : NEW_LINE INDENT size = n + k NEW_LINE arr . sort ( ) NEW_LINE if ( size % 2 == 0 ) : NEW_LINE INDENT median = ( arr [ ( size // 2 ) - 1 ] + arr [ size // 2 ] ) / 2 NEW_LINE return median NEW_LINE DEDENT median1 = arr [ size // 2 ] NEW_LINE return median1 NEW_LINE DEDENT

BLEU: 65.84
Edit Sim: 41


Src: 
void printOriginalMatrix ( int a [ ] , int b [ ] , int [ ] [ ] mat ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { if ( mat [ i ] [ j ] == 1 ) System . out . print ( Math . min ( a [ i ] , b [ j ] ) + " ▁ " ) ; else System . out . print ( "0" + " ▁ " ) ; } System . out . println ( ) ; } }
Ref: 
def printOriginalMatrix ( a , b , mat ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT if ( mat [ i ] [ j ] == 1 ) : NEW_LINE INDENT print ( min ( a [ i ] , b [ j ] ) , end = " ▁ " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT
Hyp: 
def printOriginalMatrix ( a , b , mat ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT if mat [ i ] [ j ] == 1 : NEW_LINE INDENT print ( min ( a [ i ] , b [ j ] ) , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "0" , end = " ▁ " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT

BLEU: 86.43
Edit Sim: 10


Src: 
boolean squareRootExists ( int n , int p ) { n = n % p ; for ( int x = 2 ; x < p ; x ++ ) if ( ( x * x ) % p == n ) return true ; return false ; }
Ref: 
def squareRootExists ( n , p ) : NEW_LINE INDENT n = n % p NEW_LINE for x in range ( 2 , p , 1 ) : NEW_LINE INDENT if ( ( x * x ) % p == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
Hyp: 
def squareRootExists ( n , p ) : NEW_LINE INDENT n = n % p NEW_LINE p = p NEW_LINE for x in range ( 2 , p ) : NEW_LINE INDENT if ( ( x * x ) % p == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT n = 12 NEW_LINE p = 4 NEW_LINE if ( squareRootExists ( n , p ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT

BLEU: 52.27
Edit Sim: 192


Src: 
int properDivisorSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j * j <= i ; ++ j ) { if ( i % j == 0 ) { if ( i / j == j ) sum += j ; else sum += j + i / j ; } } sum = sum - i ; } return sum ; }
Ref: 
def properDivisorSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT if j * j > i : NEW_LINE INDENT break NEW_LINE DEDENT if ( i % j == 0 ) : NEW_LINE INDENT if ( i // j == j ) : NEW_LINE INDENT sum += j NEW_LINE DEDENT else : NEW_LINE INDENT sum += j + i // j NEW_LINE DEDENT DEDENT DEDENT sum = sum - i NEW_LINE DEDENT return sum NEW_LINE DEDENT
Hyp: 
def properDivisorSum ( n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( i % j == 0 ) : NEW_LINE INDENT if ( i // j == j ) : NEW_LINE INDENT sum += j ; NEW_LINE DEDENT else : NEW_LINE INDENT sum += j + i // j ; NEW_LINE DEDENT DEDENT sum = sum - i ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT

BLEU: 74.65
Edit Sim: 75


Src: 
void equation_parabola ( float x1 , float y1 , float a , float b , float c ) { float t = a * a + b * b ; float a1 = t - ( a * a ) ; float b1 = t - ( b * b ) ; float c1 = ( - 2 * t * x1 ) - ( 2 * c * a ) ; float d1 = ( - 2 * t * y1 ) - ( 2 * c * b ) ; float e1 = - 2 * a * b ; float f1 = ( - c * c ) + ( t * x1 * x1 ) + ( t * y1 * y1 ) ; System . out . println ( " equation ▁ of ▁ parabola ▁ is ▁ " + a1 + " ▁ x ^ 2 ▁ + ▁ " + b1 + " ▁ y ^ 2 ▁ + ▁ " + c1 + " ▁ x ▁ + ▁ " + d1 + " ▁ y ▁ + ▁ " + e1 + " ▁ xy ▁ + ▁ " + f1 + " ▁ = ▁ 0 . " ) ; }
Ref: 
def equation_parabola ( x1 , y1 , a , b , c ) : NEW_LINE INDENT t = a * a + b * b NEW_LINE a1 = t - ( a * a ) NEW_LINE b1 = t - ( b * b ) ; NEW_LINE c1 = ( - 2 * t * x1 ) - ( 2 * c * a ) NEW_LINE d1 = ( - 2 * t * y1 ) - ( 2 * c * b ) NEW_LINE e1 = - 2 * a * b NEW_LINE f1 = ( - c * c ) + ( t * x1 * x1 ) + ( t * y1 * y1 ) NEW_LINE print ( " equation ▁ of ▁ parabola ▁ is " , a1 , " x ^ 2 ▁ + " , b1 , " y ^ 2 ▁ + " , c1 , " x ▁ + " , d1 , " y ▁ + ▁ " , e1 , " xy ▁ + " , f1 , " = ▁ 0 . " ) NEW_LINE DEDENT
Hyp: 
def equation_parabola ( x1 , y1 , a , b , c ) : NEW_LINE INDENT t = a * a + b * b NEW_LINE a1 = t - ( a * a ) NEW_LINE b1 = t - ( b * b ) NEW_LINE c1 = ( - 2 * t * x1 ) - ( 2 * c * a ) NEW_LINE d1 = ( - 2 * t * y1 ) - ( 2 * c * b ) NEW_LINE e1 = - 2 * a * b NEW_LINE f1 = ( - c * c ) + ( t * x1 * x1 ) + ( t * y1 * y1 ) NEW_LINE print ( " equation ▁ of ▁ parabola ▁ is ▁ " , a1 , " ▁ x ^ 2 ▁ + ▁ " , b1 , " ▁ y ^ 2 ▁ + ▁ " , c1 , " ▁ x ▁ + ▁ " , d1 , " ▁ y ▁ + ▁ " , e1 , " ▁ xy ▁ + ▁ " , f1 ) NEW_LINE DEDENT

BLEU: 84.91
Edit Sim: 36


Src: 
int seriesSum ( int n ) { return ( n * ( n + 1 ) * ( n + 2 ) ) / 6 ; }
Ref: 
def seriesSum ( n ) : NEW_LINE INDENT return int ( ( n * ( n + 1 ) * ( n + 2 ) ) / 6 ) NEW_LINE DEDENT
Hyp: 
def seriesSum ( n ) : NEW_LINE INDENT return ( n * ( n + 1 ) * ( n + 2 ) ) // 6 NEW_LINE DEDENT

BLEU: 74.4
Edit Sim: 9


Src: 
void generateNumbers ( int m ) { ArrayList < Integer > numbers = new ArrayList < > ( ) ; int k_max , x ; for ( int y = 0 ; y < 10 ; y ++ ) { k_max = ( int ) ( Math . pow ( 10 , m - 2 ) * ( 10 * y + 1 ) ) / ( int ) ( Math . pow ( 10 , m - 1 ) + y ) ; for ( int k = 1 ; k <= k_max ; k ++ ) { x = ( int ) ( y * ( Math . pow ( 10 , m - 1 ) - k ) ) / ( 10 * k - 1 ) ; if ( ( int ) ( y * ( Math . pow ( 10 , m - 1 ) - k ) ) % ( 10 * k - 1 ) == 0 ) numbers . add ( 10 * x + y ) ; } } Collections . sort ( numbers ) ; for ( int i = 0 ; i < numbers . size ( ) ; i ++ ) System . out . println ( numbers . get ( i ) ) ; }
Ref: 
def generateNumbers ( m ) : NEW_LINE INDENT numbers = [ ] NEW_LINE for y in range ( 1 , 10 ) : NEW_LINE INDENT k_max = ( ( 10 ** ( m - 2 ) * ( 10 * y + 1 ) ) // ( 10 ** ( m - 1 ) + y ) ) NEW_LINE for k in range ( 1 , k_max + 1 ) : NEW_LINE INDENT x = ( ( y * ( 10 ** ( m - 1 ) - k ) ) // ( 10 * k - 1 ) ) NEW_LINE if ( ( y * ( 10 ** ( m - 1 ) - k ) ) % ( 10 * k - 1 ) == 0 ) : NEW_LINE INDENT numbers . append ( 10 * x + y ) NEW_LINE DEDENT DEDENT DEDENT for n in sorted ( numbers ) : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT DEDENT
Hyp: 
def generateNumbers ( m ) : NEW_LINE INDENT numbers = [ ] NEW_LINE for y in range ( 10 ) : NEW_LINE INDENT k_max = 10 NEW_LINE x = 0 NEW_LINE for k in range ( 1 , k_max + 1 ) : NEW_LINE INDENT x = ( int ) ( y * ( pow ( 10 , m - 1 ) - k ) ) / ( 10 * k - 1 ) NEW_LINE if ( ( int ) ( y * ( pow ( 10 , m - 1 ) - k ) ) % ( 10 * k - 1 ) == 0 ) : NEW_LINE INDENT numbers . append ( 10 * x + y ) NEW_LINE DEDENT DEDENT DEDENT

BLEU: 56.98
Edit Sim: 178


Src: 
void printsubset ( int n , int k ) { int count = 0 , x = 0 ; ArrayList < Integer > vec = new ArrayList < > ( ) ; while ( n != 0 ) { x = n & 1 ; if ( x != 0 ) { vec . add ( ( int ) Math . pow ( k , count ) ) ; } n = n >> 1 ; count ++ ; } for ( int i = 0 ; i < vec . size ( ) ; i ++ ) System . out . print ( vec . get ( i ) + " ▁ " ) ; }
Ref: 
def printsubset ( n , k ) : NEW_LINE INDENT count = 0 NEW_LINE x = 0 NEW_LINE vec = [ ] NEW_LINE while ( n > 0 ) : NEW_LINE INDENT x = n & 1 NEW_LINE if ( x ) : NEW_LINE INDENT vec . append ( pow ( k , count ) ) NEW_LINE DEDENT n = n >> 1 NEW_LINE count += 1 NEW_LINE DEDENT for item in vec : NEW_LINE INDENT print ( item , end = " ▁ " ) NEW_LINE DEDENT DEDENT
Hyp: 
def printsubset ( n , k ) : NEW_LINE INDENT count = 0 NEW_LINE x = 0 NEW_LINE vec = [ ] NEW_LINE while ( n != 0 ) : NEW_LINE INDENT x = n & 1 NEW_LINE if ( x != 0 ) : NEW_LINE INDENT vec . append ( pow ( k , count ) ) NEW_LINE DEDENT n = n >> 1 NEW_LINE count += 1 NEW_LINE DEDENT for i in range ( len ( vec ) ) : NEW_LINE INDENT print ( vec [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT

BLEU: 78.14
Edit Sim: 34


Src: 
double sum ( int x , int n ) { double i , total = 1.0 , multi = x ; for ( i = 1 ; i <= n ; i ++ ) { total = total + multi / i ; multi = multi * x ; } return total ; }
Ref: 
def sum ( x , n ) : NEW_LINE INDENT total = 1.0 NEW_LINE multi = x NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT total = total + multi / i NEW_LINE multi = multi * x NEW_LINE DEDENT return total NEW_LINE DEDENT
Hyp: 
def sum ( x , n ) : NEW_LINE INDENT total = 1.0 NEW_LINE multi = x NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT total = total + multi / i NEW_LINE multi = multi * x NEW_LINE DEDENT return total NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
long oddNumSum ( int n ) { return ( n * ( 2 * n + 1 ) * ( 24 * n * n * n - 12 * n * n - 14 * n + 7 ) ) / 15 ; }
Ref: 
def oddNumSum ( n ) : NEW_LINE INDENT return ( n * ( 2 * n + 1 ) * ( 24 * n * n * n - 12 * n * n - 14 * n + 7 ) ) / 15 NEW_LINE DEDENT
Hyp: 
def oddNumSum ( n ) : NEW_LINE INDENT return ( n * ( 2 * n + 1 ) * ( 24 * n * n * n - 12 * n * n - 14 * n + 7 ) ) // 15 NEW_LINE DEDENT

BLEU: 94.41
Edit Sim: 1


Src: 
double Series ( double x , int n ) { double sum = 1 , term = 1 , fct = 1 ; double p = 1 , multi = 1 ; for ( int i = 1 ; i < n ; i ++ ) { fct = fct * multi * ( multi + 1 ) ; p = p * x * x ; term = ( - 1 ) * term ; multi += 2 ; sum = sum + ( term * p ) / fct ; } return sum ; }
Ref: 
def Series ( x , n ) : NEW_LINE INDENT sum = 1 NEW_LINE term = 1 NEW_LINE fct = 1 NEW_LINE p = 1 NEW_LINE multi = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT fct = fct * multi * ( multi + 1 ) NEW_LINE p = p * x * x NEW_LINE term = ( - 1 ) * term NEW_LINE multi += 2 NEW_LINE sum = sum + ( term * p ) / fct NEW_LINE DEDENT return sum NEW_LINE DEDENT
Hyp: 
def Series ( x , n ) : NEW_LINE INDENT sum1 = 1 ; term = 1 ; fct = 1 ; NEW_LINE p = 1 ; multi = 1 ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT fct = fct * multi * ( multi + 1 ) ; NEW_LINE p = p * x * x ; NEW_LINE term = ( - 1 ) * term ; NEW_LINE multi += 2 ; NEW_LINE sum1 = sum1 + ( term * p ) / fct ; NEW_LINE DEDENT return sum1 ; NEW_LINE DEDENT

BLEU: 64.2
Edit Sim: 44


Src: 
int TotalAndPair ( int arr [ ] , int N ) { int totalAND = ( 1 << 30 ) - 1 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { totalAND &= arr [ i ] & arr [ j ] ; } } return totalAND ; }
Ref: 
def TotalAndPair ( arr , N ) : NEW_LINE INDENT totalAND = ( 1 << 30 ) - 1 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT totalAND &= ( arr [ i ] & arr [ j ] ) NEW_LINE DEDENT DEDENT return totalAND NEW_LINE DEDENT
Hyp: 
def TotalAndPair ( arr , N ) : NEW_LINE INDENT totalAND = ( 1 << 30 ) - 1 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT totalAND &= arr [ i ] & arr [ j ] NEW_LINE DEDENT DEDENT return totalAND NEW_LINE DEDENT

BLEU: 89.5
Edit Sim: 8


Src: 
double cosXSertiesSum ( double x , int n ) { x = x * ( PI / 180.0 ) ; double res = 1 ; double sign = 1 , fact = 1 , pow = 1 ; for ( int i = 1 ; i < 5 ; i ++ ) { sign = sign * - 1 ; fact = fact * ( 2 * i - 1 ) * ( 2 * i ) ; pow = pow * x * x ; res = res + sign * pow / fact ; } return res ; }
Ref: 
def cosXSertiesSum ( x , n ) : NEW_LINE INDENT x = x * ( PI / 180.0 ) ; NEW_LINE res = 1 ; NEW_LINE sign = 1 ; NEW_LINE fact = 1 ; NEW_LINE pow = 1 ; NEW_LINE for i in range ( 1 , 5 ) : NEW_LINE INDENT sign = sign * ( - 1 ) ; NEW_LINE fact = fact * ( 2 * i - 1 ) * ( 2 * i ) ; NEW_LINE pow = pow * x * x ; NEW_LINE res = res + sign * pow / fact ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT
Hyp: 
def cosXSertiesSum ( x , n ) : NEW_LINE INDENT x = x * ( PI / 180.0 ) NEW_LINE res = 1 NEW_LINE sign = 1 NEW_LINE fact = 1 NEW_LINE pow = 1 NEW_LINE for i in range ( 1 , 5 ) : NEW_LINE INDENT sign = sign * - 1 NEW_LINE fact = fact * ( 2 * i - 1 ) * ( 2 * i ) NEW_LINE pow = pow * x * x NEW_LINE res = res + sign * pow / fact NEW_LINE DEDENT return res NEW_LINE DEDENT

BLEU: 72.52
Edit Sim: 24


Src: 
void moveSpaceInFront ( char str [ ] ) { int i = str . length - 1 ; for ( int j = i ; j >= 0 ; j -- ) if ( str [ j ] != ' ▁ ' ) str [ i -- ] = str [ j ] ; while ( i >= 0 ) str [ i -- ] = ' ▁ ' ; }
Ref: 
def moveSpaceInFront ( s ) : NEW_LINE INDENT i = len ( s ) - 1 ; NEW_LINE for j in range ( i , - 1 , - 1 ) : NEW_LINE INDENT if ( s [ j ] != ' ▁ ' ) : NEW_LINE INDENT s = s [ : i ] + s [ j ] + s [ i + 1 : ] NEW_LINE i -= 1 ; NEW_LINE DEDENT DEDENT while ( i >= 0 ) : NEW_LINE INDENT s = s [ : i ] + ' ▁ ' + s [ i + 1 : ] NEW_LINE i -= 1 NEW_LINE DEDENT return s ; NEW_LINE DEDENT
Hyp: 
def moveSpaceInFront ( str ) : NEW_LINE INDENT i = len ( str ) - 1 ; NEW_LINE for j in range ( i , - 1 , - 1 ) : NEW_LINE INDENT if ( str [ j ] != ' ▁ ' ) : NEW_LINE INDENT str [ i - 1 ] = str [ j ] ; NEW_LINE DEDENT DEDENT while ( i >= 0 ) : NEW_LINE INDENT str [ i - 1 ] = ' ▁ ' ; NEW_LINE DEDENT i -= 1 ; NEW_LINE DEDENT

BLEU: 52.07
Edit Sim: 90


Src: 
void printAllSubStrings ( String s , int n ) { for ( int i = 0 ; i < n ; i ++ ) { char [ ] temp = new char [ n - i + 1 ] ; int tempindex = 0 ; for ( int j = i ; j < n ; j ++ ) { temp [ tempindex ++ ] = s . charAt ( j ) ; temp [ tempindex ] = ' \0' ; System . out . println ( temp ) ; } } }
Ref: 
def printAllSubstrings ( s , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT temp = " " NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT temp += s [ j ] NEW_LINE print ( temp ) NEW_LINE DEDENT DEDENT DEDENT
Hyp: 
def printAllSubStrings ( s , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT temp = [ 0 ] * ( n - i + 1 ) ; NEW_LINE tempindex = 0 ; NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT temp [ tempindex ] = s [ j ] ; NEW_LINE temp [ tempindex ] = ' \0' ; NEW_LINE DEDENT print ( temp ) ; NEW_LINE DEDENT DEDENT

BLEU: 48.07
Edit Sim: 112


Src: 
boolean isDvisibleBy12 ( String num ) { if ( num . length ( ) >= 3 ) { int d1 = ( int ) num . charAt ( num . length ( ) - 1 ) ; if ( d1 % 2 != 0 ) return false ; int d2 = ( int ) num . charAt ( num . length ( ) - 2 ) ; int sum = 0 ; for ( int i = 0 ; i < num . length ( ) ; i ++ ) sum += num . charAt ( i ) ; return ( sum % 3 == 0 && ( d2 * 10 + d1 ) % 4 == 0 ) ; } else { int number = Integer . parseInt ( num ) ; return ( number % 12 == 0 ) ; } }
Ref: 
def isDvisibleBy12 ( num ) : NEW_LINE INDENT if ( len ( num ) >= 3 ) : NEW_LINE INDENT d1 = int ( num [ len ( num ) - 1 ] ) ; NEW_LINE if ( d1 % 2 != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT d2 = int ( num [ len ( num ) - 2 ] ) NEW_LINE sum = 0 NEW_LINE for i in range ( 0 , len ( num ) ) : NEW_LINE INDENT sum += int ( num [ i ] ) NEW_LINE DEDENT return ( sum % 3 == 0 and ( d2 * 10 + d1 ) % 4 == 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT number = int ( num ) NEW_LINE return ( number % 12 == 0 ) NEW_LINE DEDENT DEDENT num = "12244824607284961224" NEW_LINE if ( isDvisibleBy12 ( num ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
Hyp: 
def isDvisibleBy12 ( num ) : NEW_LINE INDENT if ( len ( num ) >= 3 ) : NEW_LINE INDENT d1 = int ( num [ len ( num ) - 1 ] ) NEW_LINE if ( d1 % 2 != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT d2 = int ( num [ len ( num ) - 2 ] ) NEW_LINE sum = 0 NEW_LINE for i in range ( len ( num ) ) : NEW_LINE INDENT sum += num [ i ] NEW_LINE DEDENT return ( sum % 3 == 0 and ( d2 * 10 + d1 ) % 4 == 0 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT number = int ( num ) NEW_LINE return ( number % 12 == 0 ) NEW_LINE DEDENT DEDENT

BLEU: 71.05
Edit Sim: 192


Src: 
int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
Ref: 
def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT a = 98 NEW_LINE b = 56 NEW_LINE if ( gcd ( a , b ) ) : NEW_LINE INDENT print ( ' GCD ▁ of ' , a , ' and ' , b , ' is ' , gcd ( a , b ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' not ▁ found ' ) NEW_LINE DEDENT
Hyp: 
def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT

BLEU: 15.68
Edit Sim: 218


Src: 
int maxAndXor ( int arr [ ] , int n ) { int ans = Integer . MAX_VALUE ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { ans = Math . min ( ans , arr [ i ] ^ arr [ i + 1 ] ) ; } return ans ; }
Ref: 
def maxAndXor ( arr , n ) : NEW_LINE INDENT ans = float ( ' inf ' ) NEW_LINE arr . sort ( ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT ans = min ( ans , arr [ i ] ^ arr [ i + 1 ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
Hyp: 
def maxAndXor ( arr , n ) : NEW_LINE INDENT ans = sys . maxsize NEW_LINE arr . sort ( ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT ans = min ( ans , arr [ i ] ^ arr [ i + 1 ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT

BLEU: 87.47
Edit Sim: 15


Src: 
int countObtuseAngles ( int a , int b , int k ) { int c1 = ( b - a ) - 1 ; int c2 = ( k - b ) + ( a - 1 ) ; if ( c1 == c2 ) return 0 ; return min ( c1 , c2 ) ; }
Ref: 
def countObtuseAngles ( a , b , k ) : NEW_LINE INDENT c1 = ( b - a ) - 1 NEW_LINE c2 = ( k - b ) + ( a - 1 ) NEW_LINE if ( c1 == c2 ) : NEW_LINE return 0 NEW_LINE return min ( c1 , c2 ) NEW_LINE DEDENT
Hyp: 
def countObtuseAngles ( a , b , k ) : NEW_LINE INDENT c1 = ( b - a ) - 1 NEW_LINE c2 = ( k - b ) + ( a - 1 ) NEW_LINE if ( c1 == c2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return min ( c1 , c2 ) NEW_LINE DEDENT

BLEU: 91.13
Edit Sim: 14


Src: 
int check ( int n , int m ) { if ( m % n == 0 ) { System . out . print ( " YES " ) ; } else { System . out . print ( " NO " ) ; } return 0 ; }
Ref: 
def check ( n , m ) : NEW_LINE INDENT if ( m % n == 0 ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
Hyp: 
def check ( n , m ) : NEW_LINE INDENT if ( m % n == 0 ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT

BLEU: 91.2
Edit Sim: 25


Src: 
int LongestSubarray ( int arr [ ] , int n , int k ) { int count = 1 ; int max_length = 1 ; int prev_mod = arr [ 0 ] % k ; for ( int i = 1 ; i < n ; i ++ ) { int curr_mod = arr [ i ] % k ; if ( curr_mod == prev_mod ) { count ++ ; } else { max_length = Math . max ( max_length , count ) ; count = 1 ; prev_mod = curr_mod ; } } return Math . max ( max_length , count ) ; }
Ref: 
def LongestSubarray ( arr , n , k ) : NEW_LINE INDENT count = 1 NEW_LINE max_lenght = 1 NEW_LINE prev_mod = arr [ 0 ] % k NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT curr_mod = arr [ i ] % k NEW_LINE if curr_mod == prev_mod : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT max_lenght = max ( max_lenght , count ) NEW_LINE count = 1 NEW_LINE prev_mod = curr_mod NEW_LINE DEDENT DEDENT return max ( max_lenght , count ) NEW_LINE DEDENT
Hyp: 
def LongestSubarray ( arr , n , k ) : NEW_LINE INDENT count = 1 NEW_LINE max_length = 1 NEW_LINE prev_mod = arr [ 0 ] % k NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT curr_mod = arr [ i ] % k NEW_LINE if ( curr_mod == prev_mod ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT else : NEW_LINE INDENT max_length = max ( max_length , count ) NEW_LINE count = 1 NEW_LINE prev_mod = curr_mod NEW_LINE DEDENT DEDENT return max ( max_length , count ) NEW_LINE DEDENT

BLEU: 79.48
Edit Sim: 21


Src: 
long calculate ( long a [ ] , int n ) { Arrays . sort ( a ) ; int i , j ; Vector < Long > s = new Vector < > ( ) ; for ( i = 0 , j = n - 1 ; i < j ; i ++ , j -- ) s . add ( ( a [ i ] + a [ j ] ) ) ; long mini = Collections . min ( s ) ; long maxi = Collections . max ( s ) ; return Math . abs ( maxi - mini ) ; }
Ref: 
def calculate ( a , n ) : NEW_LINE INDENT a . sort ( ) ; NEW_LINE s = [ ] ; NEW_LINE i = 0 ; NEW_LINE j = n - 1 ; NEW_LINE while ( i < j ) : NEW_LINE INDENT s . append ( ( a [ i ] + a [ j ] ) ) ; NEW_LINE i += 1 ; NEW_LINE j -= 1 ; NEW_LINE DEDENT mini = min ( s ) ; NEW_LINE maxi = max ( s ) ; NEW_LINE return abs ( maxi - mini ) ; NEW_LINE DEDENT
Hyp: 
def calculate ( a , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE s = [ ] NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT s . append ( ( a [ i ] + a [ j ] ) ) NEW_LINE DEDENT mini = min ( s ) NEW_LINE maxi = max ( s ) NEW_LINE return abs ( maxi - mini ) NEW_LINE DEDENT

BLEU: 57.14
Edit Sim: 84


Src: 
int coin ( int totalRupees , int X , int Y , int Z ) { float one = 0 , fifty = 0 , twentyfive = 0 , result = 0 , total = 0 ; one = X * 1 ; fifty = ( ( Y * 1 ) / 2 ) ; twentyfive = ( ( Z * 1 ) / 4 ) ; total = one + fifty + twentyfive ; result = ( ( totalRupees ) / total ) ; return ( int ) result ; }
Ref: 
def coin ( totalRupees , X , Y , Z ) : NEW_LINE INDENT one = X * 1 NEW_LINE fifty = ( ( Y * 1 ) / 2.0 ) NEW_LINE twentyfive = ( ( Z * 1 ) / 4.0 ) NEW_LINE total = one + fifty + twentyfive NEW_LINE result = ( ( totalRupees ) / total ) NEW_LINE return int ( result ) NEW_LINE DEDENT
Hyp: 
def coin ( totalRupees , X , Y , Z ) : NEW_LINE INDENT one = 0 NEW_LINE fifty = 0 NEW_LINE twentyfive = 0 NEW_LINE total = 0 NEW_LINE one = X * 1 NEW_LINE fifty = ( ( Y * 1 ) / 2 ) NEW_LINE twentyfive = ( ( Z * 1 ) / 4 ) NEW_LINE total = one + fifty + twentyfive NEW_LINE result = ( ( totalRupees ) // total NEW_LINE return int ( result ) NEW_LINE DEDENT

BLEU: 70.39
Edit Sim: 86


Src: 
int divCount ( int n ) { boolean hash [ ] = new boolean [ n + 1 ] ; Arrays . fill ( hash , true ) ; for ( int p = 2 ; p * p < n ; p ++ ) if ( hash [ p ] == true ) for ( int i = p * 2 ; i < n ; i += p ) hash [ i ] = false ; int total = 1 ; for ( int p = 2 ; p <= n ; p ++ ) { if ( hash [ p ] ) { int count = 0 ; if ( n % p == 0 ) { while ( n % p == 0 ) { n = n / p ; count ++ ; } total = total * ( count + 1 ) ; } } } return total ; }
Ref: 
def divCount ( n ) : NEW_LINE INDENT hh = [ 1 ] * ( n + 1 ) ; NEW_LINE p = 2 ; NEW_LINE while ( ( p * p ) < n ) : NEW_LINE INDENT if ( hh [ p ] == 1 ) : NEW_LINE INDENT for i in range ( ( p * 2 ) , n , p ) : NEW_LINE INDENT hh [ i ] = 0 ; NEW_LINE DEDENT DEDENT p += 1 ; NEW_LINE DEDENT total = 1 ; NEW_LINE for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( hh [ p ] == 1 ) : NEW_LINE INDENT count = 0 ; NEW_LINE if ( n % p == 0 ) : NEW_LINE INDENT while ( n % p == 0 ) : NEW_LINE INDENT n = int ( n / p ) ; NEW_LINE count += 1 ; NEW_LINE DEDENT total *= ( count + 1 ) ; NEW_LINE DEDENT DEDENT DEDENT return total ; NEW_LINE DEDENT
Hyp: 
def divCount ( n ) : NEW_LINE INDENT hash = [ 0 for i in range ( n + 2 ) ] NEW_LINE for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( hash [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , n + p ) : NEW_LINE INDENT hash [ i ] = False NEW_LINE DEDENT DEDENT total = 1 NEW_LINE for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( hash [ p ] == True ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n % p == 0 ) : NEW_LINE INDENT n = n // p NEW_LINE count += 1 NEW_LINE DEDENT total = total * ( count + 1 ) NEW_LINE DEDENT DEDENT return total NEW_LINE DEDENT

BLEU: 48.33
Edit Sim: 165


Src: 
int solve ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int a = 0 , b = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 != 0 ) a = a * 10 + arr [ i ] ; else b = b * 10 + arr [ i ] ; } return a + b ; }
Ref: 
def solve ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE a = 0 ; b = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i % 2 != 0 ) : NEW_LINE INDENT a = a * 10 + arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT b = b * 10 + arr [ i ] NEW_LINE DEDENT DEDENT return a + b NEW_LINE DEDENT
Hyp: 
def solve ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE a = 0 NEW_LINE b = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( i % 2 != 0 ) : NEW_LINE INDENT a = a * 10 + arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT b = b * 10 + arr [ i ] NEW_LINE DEDENT DEDENT return a + b NEW_LINE DEDENT

BLEU: 92.56
Edit Sim: 12


Src: 
void radius ( double n , double d ) { System . out . print ( " The ▁ side ▁ of ▁ each ▁ square ▁ is ▁ " + d / ( ( n - 1 ) * Math . sqrt ( 2 ) ) ) ; }
Ref: 
def radius ( n , d ) : NEW_LINE INDENT print ( " The ▁ side ▁ of ▁ each ▁ square ▁ is ▁ " , d / ( ( n - 1 ) * ( 2 ** ( 1 / 2 ) ) ) ) ; NEW_LINE DEDENT
Hyp: 
def radius ( n , d ) : NEW_LINE INDENT print ( " The ▁ side ▁ of ▁ each ▁ square ▁ is " , d / ( ( n - 1 ) * math . sqrt ( 2 ) ) ) NEW_LINE DEDENT

BLEU: 73.34
Edit Sim: 17


Src: 
String removeChars ( String s ) { String modifiedStr = " " ; modifiedStr += s . charAt ( 0 ) ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) { if ( Character . isUpperCase ( s . charAt ( i ) ) && Character . isLowerCase ( s . charAt ( i - 1 ) ) || Character . isLowerCase ( s . charAt ( i ) ) && Character . isUpperCase ( s . charAt ( i - 1 ) ) ) modifiedStr += s . charAt ( i ) ; } return modifiedStr ; }
Ref: 
def removeChars ( s ) : NEW_LINE INDENT modifiedStr = " " NEW_LINE modifiedStr += s [ 0 ] NEW_LINE for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT if ( s [ i ] . isupper ( ) and s [ i - 1 ] . islower ( ) or s [ i ] . islower ( ) and s [ i - 1 ] . isupper ( ) ) : NEW_LINE INDENT modifiedStr += s [ i ] NEW_LINE DEDENT DEDENT return modifiedStr NEW_LINE DEDENT
Hyp: 
def removeChars ( s ) : NEW_LINE INDENT modifiedStr = " " NEW_LINE modifiedStr += s [ 0 ] NEW_LINE for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT if ( isUpperCase ( s [ i ] ) and isLowerCase ( s [ i - 1 ] ) or isUpperCase ( s [ i ] ) and isUpperCase ( s [ i - 1 ] ) ) : NEW_LINE INDENT modifiedStr += s [ i ] NEW_LINE DEDENT DEDENT return modifiedStr NEW_LINE DEDENT

BLEU: 75.94
Edit Sim: 69


Src: 
void commonSubstring ( String s ) { int n = s . length ( ) ; int i = 0 ; int j = n - 1 ; String ans = " " ; while ( j >= 0 ) { if ( s . charAt ( i ) == s . charAt ( j ) ) { ans += s . charAt ( i ) ; i ++ ; j -- ; } else { break ; } } if ( ans . length ( ) == 0 ) System . out . println ( " False " ) ; else { System . out . println ( " True ▁ " ) ; System . out . println ( ans ) ; } }
Ref: 
def commonSubstring ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE i = 0 NEW_LINE j = n - 1 NEW_LINE ans = " " NEW_LINE while ( j >= 0 ) : NEW_LINE INDENT if ( s [ i ] == s [ j ] ) : NEW_LINE INDENT ans += s [ i ] NEW_LINE i = i + 1 NEW_LINE j = j - 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( len ( ans ) == 0 ) : NEW_LINE INDENT print ( " False " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " True " ) NEW_LINE print ( ans ) NEW_LINE DEDENT DEDENT
Hyp: 
def commonSubstring ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE i = 0 NEW_LINE j = n - 1 NEW_LINE ans = " " NEW_LINE while ( j >= 0 ) : NEW_LINE INDENT if ( s [ i ] == s [ j ] ) : NEW_LINE INDENT ans += s [ i ] NEW_LINE i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( len ( ans ) == 0 ) : NEW_LINE INDENT print ( " False " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " True ▁ " ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT

BLEU: 89.18
Edit Sim: 26


Src: 
int findMinimumCost ( int n , int x , int y ) { int dp [ ] = new int [ n + 1 ] ; dp [ 1 ] = x ; for ( int i = 2 ; i <= n ; i ++ ) { if ( ( i & 1 ) != 0 ) { dp [ i ] = Math . min ( dp [ i - 1 ] + x , dp [ ( i + 1 ) / 2 ] + y + x ) ; } else { dp [ i ] = Math . min ( dp [ i - 1 ] + x , dp [ i / 2 ] + y ) ; } } return dp [ n ] ; }
Ref: 
def findMinimumCost ( n , x , y ) : NEW_LINE INDENT dp = [ 0 for i in range ( n + 1 ) ] NEW_LINE dp [ 1 ] = x NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if i & 1 : NEW_LINE INDENT dp [ i ] = min ( dp [ i - 1 ] + x , dp [ ( i + 1 ) // 2 ] + y + x ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] = min ( dp [ i - 1 ] + x , dp [ i // 2 ] + y ) NEW_LINE DEDENT DEDENT return dp [ n ] NEW_LINE DEDENT
Hyp: 
def findMinimumCost ( n , x , y ) : NEW_LINE INDENT dp = [ 0 for i in range ( n + 1 ) ] NEW_LINE dp [ 1 ] = x NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( i & 1 ) : NEW_LINE INDENT dp [ i ] = min ( dp [ i - 1 ] + x , dp [ ( i + 1 ) // 2 ] + y + x ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] = min ( dp [ i - 1 ] + x , dp [ ( i + 1 ) // 2 ] + y ) NEW_LINE DEDENT DEDENT return dp [ n ] NEW_LINE DEDENT

BLEU: 91.44
Edit Sim: 12


Src: 
int minimiseMedian ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; return Math . abs ( arr [ n / 2 ] - arr [ ( n / 2 ) - 1 ] ) ; }
Ref: 
def minimiseMedian ( arr , n ) : NEW_LINE INDENT arr . sort ( ) ; NEW_LINE ans = abs ( arr [ n // 2 ] - arr [ ( n // 2 ) - 1 ] ) ; NEW_LINE return ans ; NEW_LINE DEDENT
Hyp: 
def minimiseMedian ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE return abs ( arr [ n // 2 ] - arr [ ( n // 2 ) - 1 ] ) NEW_LINE DEDENT

BLEU: 74.46
Edit Sim: 32


Src: 
void minAdjDifference ( int arr [ ] , int n ) { if ( n < 2 ) return ; int res = Math . abs ( arr [ 1 ] - arr [ 0 ] ) ; for ( int i = 2 ; i < n ; i ++ ) res = Math . min ( res , Math . abs ( arr [ i ] - arr [ i - 1 ] ) ) ; res = Math . min ( res , Math . abs ( arr [ n - 1 ] - arr [ 0 ] ) ) ; System . out . print ( " Min ▁ Difference ▁ = ▁ " + res ) ; }
Ref: 
def minAdjDifference ( arr , n ) : NEW_LINE INDENT if ( n < 2 ) : return NEW_LINE res = abs ( arr [ 1 ] - arr [ 0 ] ) NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT res = min ( res , abs ( arr [ i ] - arr [ i - 1 ] ) ) NEW_LINE DEDENT res = min ( res , abs ( arr [ n - 1 ] - arr [ 0 ] ) ) NEW_LINE print ( " Min ▁ Difference ▁ = ▁ " , res ) NEW_LINE DEDENT
Hyp: 
def minAdjDifference ( arr , n ) : NEW_LINE INDENT if ( n < 2 ) : return 0 NEW_LINE res = abs ( arr [ 1 ] - arr [ 0 ] ) NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT res = min ( res , abs ( arr [ i ] - arr [ i - 1 ] ) ) NEW_LINE DEDENT res = min ( res , abs ( arr [ n - 1 ] - arr [ 0 ] ) ) NEW_LINE print ( " Min ▁ Difference ▁ = " , res ) NEW_LINE DEDENT

BLEU: 96.16
Edit Sim: 4


Src: 
int superSeq ( String X , String Y , int m , int n ) { int [ ] [ ] dp = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 ) dp [ i ] [ j ] = j ; else if ( j == 0 ) dp [ i ] [ j ] = i ; else if ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = 1 + Math . min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) ; } } return dp [ m ] [ n ] ; }
Ref: 
def superSeq ( X , Y , m , n ) : NEW_LINE INDENT dp = [ [ 0 ] * ( n + 2 ) for i in range ( m + 2 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if ( not i ) : NEW_LINE INDENT dp [ i ] [ j ] = j NEW_LINE DEDENT elif ( not j ) : NEW_LINE INDENT dp [ i ] [ j ] = i NEW_LINE DEDENT elif ( X [ i - 1 ] == Y [ j - 1 ] ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = 1 + min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ m ] [ n ] NEW_LINE DEDENT
Hyp: 
def superSeq ( X , Y , m , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n + 1 ) ] for i in range ( m + 1 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT dp [ i ] [ j ] = j NEW_LINE DEDENT elif j == 0 : NEW_LINE INDENT dp [ i ] [ j ] = i NEW_LINE DEDENT elif X [ i - 1 ] == Y [ j - 1 ] : NEW_LINE INDENT dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = ( 1 + min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) ) NEW_LINE DEDENT DEDENT DEDENT return dp [ m ] [ n ] NEW_LINE DEDENT

BLEU: 85.51
Edit Sim: 39


Src: 
void printXYZ ( int n ) { if ( n == 1 ) System . out . println ( - 1 ) ; else { System . out . println ( " x ▁ is ▁ " + n ) ; System . out . println ( " y ▁ is ▁ " + ( n + 1 ) ) ; System . out . println ( " z ▁ is ▁ " + ( n * ( n + 1 ) ) ) ; } }
Ref: 
def printXYZ ( n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " x ▁ is ▁ " , n ) NEW_LINE print ( " y ▁ is ▁ " , n + 1 ) NEW_LINE print ( " z ▁ is ▁ " , n * ( n + 1 ) ) NEW_LINE DEDENT DEDENT
Hyp: 
def printXYZ ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT print ( " - 1" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " x ▁ is " , n ) ; NEW_LINE print ( " y ▁ is " , ( n + 1 ) ) ; NEW_LINE print ( " z ▁ is " , ( n * ( n + 1 ) ) ) ; NEW_LINE DEDENT DEDENT

BLEU: 60.87
Edit Sim: 27


Src: 
float findVolume ( float a ) { if ( a < 0 ) return - 1 ; float r = a / 2 ; float h = a ; float V = ( float ) ( 3.14 * Math . pow ( r , 2 ) * h ) ; return V ; }
Ref: 
def findVolume ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT r = a / 2 NEW_LINE h = a NEW_LINE V = 3.14 * pow ( r , 2 ) * h NEW_LINE return V NEW_LINE DEDENT
Hyp: 
def findVolume ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT r = a / 2 NEW_LINE h = a NEW_LINE V = ( 3.14 * pow ( r , 2 ) * h ) NEW_LINE return V NEW_LINE DEDENT

BLEU: 89.88
Edit Sim: 4


Src: 
boolean find3Numbers ( int A [ ] , int arr_size , int sum ) { int l , r ; for ( int i = 0 ; i < arr_size - 2 ; i ++ ) { for ( int j = i + 1 ; j < arr_size - 1 ; j ++ ) { for ( int k = j + 1 ; k < arr_size ; k ++ ) { if ( A [ i ] + A [ j ] + A [ k ] == sum ) { System . out . print ( " Triplet ▁ is ▁ " + A [ i ] + " , ▁ " + A [ j ] + " , ▁ " + A [ k ] ) ; return true ; } } } } return false ; }
Ref: 
def find3Numbers ( A , arr_size , sum ) : NEW_LINE INDENT for i in range ( 0 , arr_size - 2 ) : NEW_LINE INDENT for j in range ( i + 1 , arr_size - 1 ) : NEW_LINE INDENT for k in range ( j + 1 , arr_size ) : NEW_LINE INDENT if A [ i ] + A [ j ] + A [ k ] == sum : NEW_LINE INDENT print ( " Triplet ▁ is " , A [ i ] , " , ▁ " , A [ j ] , " , ▁ " , A [ k ] ) NEW_LINE return True NEW_LINE DEDENT DEDENT DEDENT DEDENT return False NEW_LINE DEDENT
Hyp: 
def find3Numbers ( A , arr_size , sum ) : NEW_LINE INDENT l = 0 NEW_LINE r = 0 NEW_LINE for i in range ( arr_size - 2 ) : NEW_LINE INDENT for j in range ( i + 1 , arr_size - 1 ) : NEW_LINE INDENT for k in range ( j + 1 , arr_size ) : NEW_LINE INDENT if ( A [ i ] + A [ j ] + A [ k ] == sum ) : NEW_LINE INDENT print ( " Triplet ▁ is ▁ " , A [ i ] , " , ▁ " , A [ j ] , A [ k ] ) NEW_LINE return True NEW_LINE DEDENT DEDENT DEDENT DEDENT return False NEW_LINE DEDENT

BLEU: 85.31
Edit Sim: 50


Src: 
int extraElement ( int A [ ] , int B [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) ans ^= A [ i ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) ans ^= B [ i ] ; return ans ; }
Ref: 
def extraElement ( A , B , n ) : NEW_LINE INDENT ans = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans ^= A [ i ] ; NEW_LINE DEDENT for i in range ( n + 1 ) : NEW_LINE INDENT ans ^= B [ i ] ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT
Hyp: 
def extraElement ( A , B , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE return ans NEW_LINE DEDENT

BLEU: 27.24
Edit Sim: 120


Src: 
void solution ( int a , int b , int n ) { for ( int i = 0 ; i * a <= n ; i ++ ) { if ( ( n - ( i * a ) ) % b == 0 ) { System . out . println ( " x ▁ = ▁ " + i + " , ▁ y ▁ = ▁ " + ( n - ( i * a ) ) / b ) ; return ; } } System . out . println ( " No ▁ solution " ) ; }
Ref: 
def solution ( a , b , n ) : NEW_LINE INDENT i = 0 NEW_LINE while i * a <= n : NEW_LINE INDENT if ( n - ( i * a ) ) % b == 0 : NEW_LINE INDENT print ( " x ▁ = ▁ " , i , " , ▁ y ▁ = ▁ " , int ( ( n - ( i * a ) ) / b ) ) NEW_LINE return 0 NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT print ( " No ▁ solution " ) NEW_LINE DEDENT
Hyp: 
def solution ( a , b , n ) : NEW_LINE INDENT i = 0 NEW_LINE while i * a <= n : NEW_LINE INDENT if ( ( n - ( i * a ) ) % b == 0 ) : NEW_LINE INDENT print ( " x ▁ = " , i , " , ▁ y ▁ = " , ( n - ( i * a ) ) // b ) NEW_LINE return NEW_LINE DEDENT i = 1 NEW_LINE DEDENT print ( " No ▁ solution " ) NEW_LINE DEDENT

BLEU: 79.66
Edit Sim: 23


Src: 
void firstSubsequence ( String s ) { Vector < String > allsubseq = new Vector < > ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { String k = " " ; for ( int j = 0 ; j < s . length ( ) ; j ++ ) { if ( i != j ) { k += s . charAt ( j ) ; } } allsubseq . add ( k ) ; } Collections . sort ( allsubseq ) ; System . out . print ( allsubseq . get ( 0 ) ) ; }
Ref: 
def firstSubsequence ( s ) : NEW_LINE INDENT allsubseq = [ ] NEW_LINE k = [ ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT k = [ i for i in s ] NEW_LINE del k [ i ] NEW_LINE allsubseq . append ( " " . join ( k ) ) NEW_LINE DEDENT allsubseq = sorted ( allsubseq ) NEW_LINE print ( allsubseq [ 0 ] ) NEW_LINE DEDENT
Hyp: 
def firstSubsequence ( s ) : NEW_LINE INDENT allsubseq = [ ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT k = " " NEW_LINE for j in range ( len ( s ) ) : NEW_LINE INDENT if ( i != j ) : NEW_LINE INDENT k += s [ j ] NEW_LINE DEDENT DEDENT allsubseq . append ( k ) NEW_LINE DEDENT print ( * allsubseq ) NEW_LINE DEDENT

BLEU: 50.9
Edit Sim: 125


Src: 
long answer ( long n ) { long m = 2 ; long ans = 1 ; long r = 1 ; while ( r < n ) { r = ( ( long ) Math . pow ( 2 , m ) - 1 ) * ( ( long ) Math . pow ( 2 , m - 1 ) ) ; if ( r < n ) ans = r ; m ++ ; } return ans ; }
Ref: 
def answer ( n ) : NEW_LINE INDENT m = 2 ; NEW_LINE ans = 1 ; NEW_LINE r = 1 ; NEW_LINE while r < n : NEW_LINE INDENT r = ( int ) ( ( pow ( 2 , m ) - 1 ) * ( pow ( 2 , m - 1 ) ) ) ; NEW_LINE if r < n : NEW_LINE INDENT ans = r ; NEW_LINE DEDENT m = m + 1 ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT
Hyp: 
def answer ( n ) : NEW_LINE INDENT m = 2 NEW_LINE ans = 1 NEW_LINE r = 1 NEW_LINE while ( r < n ) : NEW_LINE INDENT r = ( pow ( 2 , m ) - 1 ) * ( pow ( 2 , m - 1 ) ) NEW_LINE if ( r < n ) : NEW_LINE INDENT ans = r NEW_LINE DEDENT m += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT

BLEU: 60.62
Edit Sim: 39


Src: 
int countDivisors ( int n ) { int cnt = 0 ; for ( int i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) cnt ++ ; cnt = cnt + 2 ; } } return cnt ; }
Ref: 
def countDivisors ( n ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( 1 , ( int ) ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( n / i == i ) : NEW_LINE INDENT cnt = cnt + 1 NEW_LINE cnt = cnt + 2 NEW_LINE DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT
Hyp: 
def countDivisors ( n ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( 1 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( n // i == i ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT cnt = cnt + 2 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT

BLEU: 81.87
Edit Sim: 26


Src: 
void numberOfPermWithKInversion ( int N , int K ) { int [ ] [ ] dp = new int [ 2 ] [ K + 1 ] ; int mod = 1000000007 ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 0 ; j <= K ; j ++ ) { if ( i == 1 ) { dp [ i % 2 ] [ j ] = ( j == 0 ) ? 1 : 0 ; } else if ( j == 0 ) dp [ i % 2 ] [ j ] = 1 ; else { int maxm = Math . max ( j - ( i - 1 ) ) ; dp [ i % 2 ] [ j ] = ( dp [ i % 2 ] [ j - 1 ] % mod + ( dp [ 1 - i % 2 ] [ j ] - ( ( Math . max ( j - ( i - 1 ) , 0 ) == 0 ) ? 0 : dp [ 1 - i % 2 ] [ maxm , 0 ) - 1 ] ) + mod ) % mod ) % mod ; } } } System . out . println ( dp [ N % 2 ] [ K ] ) ; }
Ref: 
def numberOfPermWithKInversion ( N , K ) : NEW_LINE INDENT dp = [ [ 0 ] * ( K + 1 ) ] * 2 NEW_LINE mod = 1000000007 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( 0 , K + 1 ) : NEW_LINE INDENT if ( i == 1 ) : NEW_LINE INDENT dp [ i % 2 ] [ j ] = 1 if ( j == 0 ) else 0 NEW_LINE DEDENT elif ( j == 0 ) : NEW_LINE INDENT dp [ i % 2 ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT var = ( 0 if ( max ( j - ( i - 1 ) , 0 ) == 0 ) else dp [ 1 - i % 2 ] [ max ( j - ( i - 1 ) , 0 ) - 1 ] ) NEW_LINE dp [ i % 2 ] [ j ] = ( ( dp [ i % 2 ] [ j - 1 ] % mod + ( dp [ 1 - i % 2 ] [ j ] - ( var ) + mod ) % mod ) % mod ) NEW_LINE DEDENT DEDENT DEDENT print ( dp [ N % 2 ] [ K ] ) NEW_LINE DEDENT
Hyp: 
def numberOfPermWithKInversion ( N , K ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( K + 1 ) ] for i in range ( 3 ) ] NEW_LINE mod = 1000000007 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( K + 1 ) : NEW_LINE INDENT if ( i == 1 ) : NEW_LINE INDENT dp [ i % 2 ] [ j ] = 1 NEW_LINE DEDENT elif ( j == 0 ) : NEW_LINE INDENT dp [ i % 2 ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i % 2 ] [ j ] = ( ( dp [ i % 2 ] [ j - 1 ] % mod + ( dp [ 1 - i % 2 ] [ j - 1 ] % mod + ( dp [ 1 - i % 2 ] [ j ] - ( ( max ( j - ( i - 1 ) , 0 ) == 0 ) else dp [ 1 - i % 2 ] [ maxm , 0 ) - 1 ] ) + mod ) % mod ) NEW_LINE DEDENT DEDENT DEDENT print ( dp [ N % 2 ] [ K ] ) NEW_LINE DEDENT

BLEU: 81.76
Edit Sim: 165


Src: 
void countPairs ( int arr [ ] , int N ) { int countPowerof2 = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( Integer . bitCount ( arr [ i ] ) == 1 ) countPowerof2 ++ ; } int desiredPairs = ( countPowerof2 * ( countPowerof2 - 1 ) ) / 2 ; System . out . print ( desiredPairs + " ▁ " ) ; }
Ref: 
def countPairs ( arr , N ) : NEW_LINE INDENT countPowerof2 = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( bin ( arr [ i ] ) . count ( '1' ) == 1 ) : NEW_LINE INDENT countPowerof2 += 1 NEW_LINE DEDENT DEDENT desiredPairs = ( countPowerof2 * ( countPowerof2 - 1 ) ) // 2 NEW_LINE print ( desiredPairs ) NEW_LINE DEDENT
Hyp: 
def countPairs ( arr , N ) : NEW_LINE INDENT countPowerof2 = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] & 1 ) : NEW_LINE INDENT countPowerof2 += 1 NEW_LINE DEDENT DEDENT desiredPairs = ( countPowerof2 * ( countPowerof2 - 1 ) ) // 2 NEW_LINE print ( desiredPairs , end = " ▁ " ) NEW_LINE DEDENT

BLEU: 81.43
Edit Sim: 40


Src: 
int countgroup ( int a [ ] , int n ) { int xs = 0 ; for ( int i = 0 ; i < n ; i ++ ) xs = xs ^ a [ i ] ; if ( xs == 0 ) return ( 1 << ( n - 1 ) ) - 1 ; return 0 ; }
Ref: 
def countgroup ( a , n ) : NEW_LINE INDENT xs = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT xs = xs ^ a [ i ] NEW_LINE DEDENT if xs == 0 : NEW_LINE INDENT return ( 1 << ( n - 1 ) ) - 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT
Hyp: 
def countgroup ( a , n ) : NEW_LINE INDENT xs = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT xs = xs ^ a [ i ] NEW_LINE DEDENT if ( xs == 0 ) : NEW_LINE INDENT return ( 1 << ( n - 1 ) ) - 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT

BLEU: 91.58
Edit Sim: 4


Src: 
int TetracontaoctagonalNum ( int n ) { return ( 46 * n * n - 44 * n ) / 2 ; }
Ref: 
def TetracontaoctagonalNum ( n ) : NEW_LINE INDENT return ( 46 * n * n - 44 * n ) / 2 ; NEW_LINE DEDENT
Hyp: 
def TetracontaoctagonalNum ( n ) : NEW_LINE INDENT return ( 46 * n * n - 44 * n ) // 2 NEW_LINE DEDENT

BLEU: 83.26
Edit Sim: 3


Src: 
int nextPowerOf2 ( int n ) { n -- ; n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; n ++ ; return n ; }
Ref: 
def nextPowerOf2 ( n ) : NEW_LINE INDENT n -= 1 NEW_LINE n |= n >> 1 NEW_LINE n |= n >> 2 NEW_LINE n |= n >> 4 NEW_LINE n |= n >> 8 NEW_LINE n |= n >> 16 NEW_LINE n += 1 NEW_LINE return n NEW_LINE DEDENT
Hyp: 
def nextPowerOf2 ( n ) : NEW_LINE INDENT n -= 1 NEW_LINE n |= n >> 1 NEW_LINE n |= n >> 2 NEW_LINE n |= n >> 4 NEW_LINE n |= n >> 8 NEW_LINE n |= n >> 16 NEW_LINE n += 1 NEW_LINE return n NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int countSteps ( int x , int y ) { if ( x < y ) { return x + y + 2 * ( ( y - x ) / 2 ) ; } else { return x + y + 2 * ( ( ( x - y ) + 1 ) / 2 ) ; } }
Ref: 
def countSteps ( x , y ) : NEW_LINE INDENT if x < y : NEW_LINE INDENT return x + y + 2 * ( ( y - x ) // 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT return x + y + 2 * ( ( ( x - y ) + 1 ) // 2 ) NEW_LINE DEDENT DEDENT
Hyp: 
def countSteps ( x , y ) : NEW_LINE INDENT if ( x < y ) : NEW_LINE INDENT return x + y + 2 * ( ( y - x ) / 2 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT return x + y + 2 * ( ( ( x - y ) + 1 ) / 2 ) ; NEW_LINE DEDENT DEDENT

BLEU: 77.11
Edit Sim: 10


Src: 
void construct_Array ( int N , int K ) { for ( int i = 1 ; i <= N ; i ++ ) { System . out . print ( K * i + " ▁ " ) ; } }
Ref: 
def construct_Array ( N , K ) : NEW_LINE INDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT print ( K * i , end = " ▁ " ) NEW_LINE DEDENT DEDENT
Hyp: 
def construct_Array ( N , K ) : NEW_LINE INDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT print ( K * i , end = " ▁ " ) NEW_LINE DEDENT DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int bitwiseAndOdd ( int n ) { int result = 1 ; for ( int i = 3 ; i <= n ; i = i + 2 ) { result = ( result & i ) ; } return result ; }
Ref: 
def bitwiseAndOdd ( n ) : NEW_LINE INDENT result = 1 ; NEW_LINE for i in range ( 3 , n + 1 , 2 ) : NEW_LINE INDENT result = ( result & i ) ; NEW_LINE DEDENT return result ; NEW_LINE DEDENT
Hyp: 
def bitwiseAndOdd ( n ) : NEW_LINE INDENT result = 1 ; NEW_LINE for i in range ( 3 , n + 1 , 2 ) : NEW_LINE INDENT result = ( result & i ) ; NEW_LINE DEDENT return result ; NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int properDivisorSum ( int n ) { int sum = 0 ; int i ; for ( i = 1 ; i <= n ; ++ i ) sum += ( n / i ) * i ; return sum - n * ( n + 1 ) / 2 ; }
Ref: 
def properDivisorSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += ( n // i ) * i NEW_LINE DEDENT return sum - n * ( n + 1 ) // 2 NEW_LINE DEDENT
Hyp: 
def properDivisorSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += int ( n / i ) * i NEW_LINE DEDENT return int ( sum - n * ( n + 1 ) / 2 ) NEW_LINE DEDENT

BLEU: 76.94
Edit Sim: 14


Src: 
int minSteps ( int arr [ ] , int n , int k ) { int i , cnt = 0 ; int flag ; if ( k == 1 ) flag = 0 ; else flag = 1 ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == flag ) { cnt ++ ; flag = ( flag + 1 ) % 2 ; } } return cnt ; }
Ref: 
def minSteps ( arr , n , k ) : NEW_LINE INDENT cnt = 0 NEW_LINE if ( k == 1 ) : NEW_LINE INDENT flag = 0 NEW_LINE DEDENT else : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == flag ) : NEW_LINE INDENT cnt += 1 NEW_LINE flag = ( flag + 1 ) % 2 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT
Hyp: 
def minSteps ( arr , n , k ) : NEW_LINE INDENT cnt = 0 NEW_LINE flag = 0 NEW_LINE if ( k == 1 ) : NEW_LINE INDENT flag = 0 NEW_LINE DEDENT else : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == flag ) : NEW_LINE INDENT cnt += 1 NEW_LINE flag = ( flag + 1 ) % 2 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT

BLEU: 95.27
Edit Sim: 18


Src: 
int minPower ( int n , int x ) { if ( x == 1 ) return n ; int ans = 0 ; while ( n > 0 ) { ans += ( n % x ) ; n /= x ; } return ans ; }
Ref: 
def minPower ( n , x ) : NEW_LINE INDENT if ( x == 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT ans = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT ans += ( n % x ) NEW_LINE n //= x NEW_LINE DEDENT return ans NEW_LINE DEDENT
Hyp: 
def minPower ( n , x ) : NEW_LINE INDENT if ( x == 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT ans = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT ans += ( n % x ) NEW_LINE n /= x NEW_LINE DEDENT return ans NEW_LINE DEDENT

BLEU: 95.16
Edit Sim: 1


Src: 
int findNthEvenDigitNumber ( int n ) { int count = 0 ; for ( int i = 0 ; ; i ++ ) { int curr = i ; boolean isCurrEvenDigit = true ; while ( curr != 0 ) { if ( curr % 10 == 1 curr % 10 == 3 curr % 10 == 5 curr % 10 == 7 curr % 10 == 9 ) isCurrEvenDigit = false ; curr = curr / 10 ; } if ( isCurrEvenDigit == true ) count ++ ; if ( count == n ) return i ; } }
Ref: 
def findNthEvenDigitNumber ( n ) : NEW_LINE INDENT count = 0 ; NEW_LINE i = 0 ; NEW_LINE while ( True ) : NEW_LINE INDENT curr = i ; NEW_LINE isCurrEvenDigit = True ; NEW_LINE while ( curr != 0 ) : NEW_LINE INDENT if ( curr % 10 == 1 or curr % 10 == 3 or curr % 10 == 5 or curr % 10 == 7 or curr % 10 == 9 ) : NEW_LINE INDENT isCurrEvenDigit = False ; NEW_LINE DEDENT curr = curr // 10 ; NEW_LINE DEDENT if ( isCurrEvenDigit == True ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT if ( count == n ) : NEW_LINE INDENT return i ; NEW_LINE DEDENT i += 1 ; NEW_LINE DEDENT DEDENT
Hyp: 
def findNthEvenDigitNumber ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT curr = i NEW_LINE isCurrEvenDigit = True NEW_LINE while ( curr != 0 ) : NEW_LINE INDENT if ( curr % 10 == 1 or curr % 10 == 3 or curr % 10 == 5 or curr % 10 == 7 or curr % 10 == 9 ) : NEW_LINE INDENT isCurrEvenDigit = False NEW_LINE DEDENT curr = curr // 10 NEW_LINE DEDENT if ( isCurrEvenDigit == True ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( count == n ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT

BLEU: 74.95
Edit Sim: 63


Src: 
int possibleStrings ( int n , int r , int b , int g ) { int fact [ ] = new int [ n + 1 ] ; fact [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) fact [ i ] = fact [ i - 1 ] * i ; int left = n - ( r + g + b ) ; int sum = 0 ; for ( int i = 0 ; i <= left ; i ++ ) { for ( int j = 0 ; j <= left - i ; j ++ ) { int k = left - ( i + j ) ; sum = sum + fact [ n ] / ( fact [ i + r ] * fact [ j + b ] * fact [ k + g ] ) ; } } return sum ; }
Ref: 
def possibleStrings ( n , r , b , g ) : NEW_LINE INDENT fact = [ 0 for i in range ( n + 1 ) ] NEW_LINE fact [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 , 1 ) : NEW_LINE INDENT fact [ i ] = fact [ i - 1 ] * i NEW_LINE DEDENT left = n - ( r + g + b ) NEW_LINE sum = 0 NEW_LINE for i in range ( 0 , left + 1 , 1 ) : NEW_LINE INDENT for j in range ( 0 , left - i + 1 , 1 ) : NEW_LINE INDENT k = left - ( i + j ) NEW_LINE sum = ( sum + fact [ n ] / ( fact [ i + r ] * fact [ j + b ] * fact [ k + g ] ) ) NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
Hyp: 
def possibleStrings ( n , r , b , g ) : NEW_LINE INDENT fact = [ 0 ] * ( n + 1 ) NEW_LINE fact [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT fact [ i ] = fact [ i - 1 ] * i NEW_LINE DEDENT left = n - ( r + g + b ) NEW_LINE sum = 0 NEW_LINE for i in range ( left + 1 ) : NEW_LINE INDENT for j in range ( 0 , left - i + 1 ) : NEW_LINE INDENT k = left - ( i + j ) NEW_LINE sum = sum + fact [ n ] // ( fact [ i + r ] * fact [ j + b ] * fact [ k + g ] ) NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT

BLEU: 83.75
Edit Sim: 36


Src: 
int product ( int N ) { int ans = 1 ; int val = ( int ) Math . pow ( 2 , N - 1 ) ; for ( int i = 1 ; i <= N ; i ++ ) { ans *= ( int ) Math . pow ( i , val ) ; } return ans ; }
Ref: 
def product ( N ) : NEW_LINE INDENT ans = 1 ; NEW_LINE val = 2 ** ( N - 1 ) ; NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT ans *= ( i ** val ) ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT
Hyp: 
def product ( N ) : NEW_LINE INDENT ans = 1 NEW_LINE val = pow ( 2 , N - 1 ) NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT ans *= pow ( i , val ) NEW_LINE DEDENT return ans NEW_LINE DEDENT

BLEU: 65.13
Edit Sim: 21


Src: 
int countPairs ( String str ) { int result = 0 ; int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( Math . abs ( str . charAt ( i ) - str . charAt ( j ) ) == Math . abs ( i - j ) ) result ++ ; return result ; }
Ref: 
def countPairs ( str1 ) : NEW_LINE INDENT result = 0 ; NEW_LINE n = len ( str1 ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( abs ( ord ( str1 [ i ] ) - ord ( str1 [ j ] ) ) == abs ( i - j ) ) : NEW_LINE INDENT result += 1 ; NEW_LINE DEDENT DEDENT DEDENT return result ; NEW_LINE DEDENT
Hyp: 
def countPairs ( str ) : NEW_LINE INDENT result = 0 NEW_LINE n = len ( str ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( abs ( str [ i ] - str [ j ] ) == abs ( i - j ) ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT

BLEU: 66.81
Edit Sim: 30


Src: 
int power ( int n ) { if ( n == 1 ) return 2 ; return 2 * power ( n - 1 ) ; }
Ref: 
def power ( n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return 2 NEW_LINE DEDENT return 2 * power ( n - 1 ) NEW_LINE DEDENT
Hyp: 
def power ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT return 2 * power ( n - 1 ) NEW_LINE DEDENT

BLEU: 83.5
Edit Sim: 4


Src: 
int convert ( int m , int n ) { if ( m == n ) return 0 ; if ( m > n ) return m - n ; if ( m <= 0 && n > 0 ) return - 1 ; if ( n % 2 == 1 ) return 1 + convert ( m , n + 1 ) ; else return 1 + convert ( m , n / 2 ) ; }
Ref: 
def conver ( m , n ) : NEW_LINE INDENT if ( m == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( m > n ) : NEW_LINE INDENT return m - n NEW_LINE DEDENT if ( m <= 0 and n > 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( n % 2 == 1 ) : NEW_LINE INDENT return 1 + conver ( m , n + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return 1 + conver ( m , n / 2 ) NEW_LINE DEDENT DEDENT
Hyp: 
def convert ( m , n ) : NEW_LINE INDENT if ( m == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( m > n ) : NEW_LINE INDENT return m - n NEW_LINE DEDENT if ( m <= 0 and n > 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( n % 2 == 1 ) : NEW_LINE INDENT return 1 + convert ( m , n + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return 1 + convert ( m , n // 2 ) NEW_LINE DEDENT DEDENT

BLEU: 90.38
Edit Sim: 4


Src: 
int andSum ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < BITS ; i ++ ) { int countSetBits = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( arr [ j ] & ( 1 << i ) ) != 0 ) countSetBits ++ ; } int subset = ( 1 << countSetBits ) - 1 ; subset = ( subset * ( 1 << i ) ) ; ans += subset ; } return ans ; }
Ref: 
def andSum ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 0 , BITS ) : NEW_LINE INDENT countSetBits = 0 NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ j ] & ( 1 << i ) ) : NEW_LINE INDENT countSetBits = ( countSetBits + 1 ) NEW_LINE DEDENT DEDENT subset = ( ( 1 << countSetBits ) - 1 ) NEW_LINE subset = ( subset * ( 1 << i ) ) NEW_LINE ans = ans + subset NEW_LINE DEDENT return ans NEW_LINE DEDENT
Hyp: 
def andSum ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( BITS ) : NEW_LINE INDENT countSetBits = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( arr [ j ] & ( 1 << i ) ) != 0 : NEW_LINE INDENT countSetBits += 1 NEW_LINE DEDENT DEDENT subset = ( 1 << countSetBits ) - 1 NEW_LINE subset = ( subset * ( 1 << i ) ) NEW_LINE ans += subset NEW_LINE DEDENT return ans NEW_LINE DEDENT

BLEU: 75.44
Edit Sim: 44


Src: 
void solve ( int N ) { if ( N % 2 == 0 ) { System . out . print ( N / 2 + " ▁ " + N + "NEW_LINE"); } else { System . out . print ( ( N - 1 ) / 2 + " ▁ " + ( N - 1 ) + "NEW_LINE"); } }
Ref: 
def solve ( N ) : NEW_LINE INDENT if ( N % 2 == 0 ) : NEW_LINE INDENT print ( N // 2 , N ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ( N - 1 ) // 2 , ( N - 1 ) ) NEW_LINE DEDENT DEDENT
Hyp: 
def solve ( N ) : NEW_LINE INDENT if ( N % 2 == 0 ) : NEW_LINE INDENT print ( N / 2 , N ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ( N - 1 ) / 2 , " ▁ " , ( N - 1 ) ) NEW_LINE DEDENT DEDENT

BLEU: 82.61
Edit Sim: 10


Src: 
void octant ( float x , float y , float z ) { if ( x >= 0 && y >= 0 && z >= 0 ) System . out . println ( " Point ▁ lies ▁ in ▁ 1st ▁ octant " ) ; else if ( x < 0 && y >= 0 && z >= 0 ) System . out . println ( " Point ▁ lies ▁ in ▁ 2nd ▁ octant " ) ; else if ( x < 0 && y < 0 && z >= 0 ) System . out . println ( " Point ▁ lies ▁ in ▁ 3rd ▁ octant " ) ; else if ( x >= 0 && y < 0 && z >= 0 ) System . out . println ( " Point ▁ lies ▁ in ▁ 4th ▁ octant " ) ; else if ( x >= 0 && y >= 0 && z < 0 ) System . out . println ( " Point ▁ lies ▁ in ▁ 5th ▁ octant " ) ; else if ( x < 0 && y >= 0 && z < 0 ) System . out . println ( " Point ▁ lies ▁ in ▁ 6th ▁ octant " ) ; else if ( x < 0 && y < 0 && z < 0 ) System . out . println ( " Point ▁ lies ▁ in ▁ 7th ▁ octant " ) ; else if ( x >= 0 && y < 0 && z < 0 ) System . out . println ( " Point ▁ lies ▁ in ▁ 8th ▁ octant " ) ; }
Ref: 
def octant ( x , y , z ) : NEW_LINE INDENT if x >= 0 and y >= 0 and z >= 0 : NEW_LINE INDENT print " Point ▁ lies ▁ in ▁ 1st ▁ octant " NEW_LINE DEDENT elif x < 0 and y >= 0 and z >= 0 : NEW_LINE INDENT print " Point ▁ lies ▁ in ▁ 2nd ▁ octant " NEW_LINE DEDENT elif x < 0 and y < 0 and z >= 0 : NEW_LINE INDENT print " Point ▁ lies ▁ in ▁ 3rd ▁ octant " NEW_LINE DEDENT elif x >= 0 and y < 0 and z >= 0 : NEW_LINE INDENT print " Point ▁ lies ▁ in ▁ 4th ▁ octant " NEW_LINE DEDENT elif x >= 0 and y >= 0 and z < 0 : NEW_LINE INDENT print " Point ▁ lies ▁ in ▁ 5th ▁ octant " NEW_LINE DEDENT elif x < 0 and y >= 0 and z < 0 : NEW_LINE INDENT print " Point ▁ lies ▁ in ▁ 6th ▁ octant " NEW_LINE DEDENT elif x < 0 and y < 0 and z < 0 : NEW_LINE INDENT print " Point ▁ lies ▁ in ▁ 7th ▁ octant " NEW_LINE DEDENT elif x >= 0 and y < 0 and z < 0 : NEW_LINE INDENT print " Point ▁ lies ▁ in ▁ 8th ▁ octant " NEW_LINE DEDENT DEDENT
Hyp: 
def octant ( x , y , z ) : NEW_LINE INDENT if ( x >= 0 and y >= 0 and z >= 0 ) : NEW_LINE INDENT print ( " Point ▁ lies ▁ in ▁ 1st ▁ octant " ) NEW_LINE DEDENT elif ( x < 0 and y >= 0 and z >= 0 ) : NEW_LINE INDENT print ( " Point ▁ lies ▁ in ▁ 2nd ▁ octant " ) NEW_LINE DEDENT elif ( x < 0 and y < 0 and z < 0 ) : NEW_LINE INDENT print ( " Point ▁ lies ▁ in ▁ 5th ▁ octant " ) NEW_LINE DEDENT elif ( x < 0 and y < 0 and z < 0 ) : NEW_LINE INDENT print ( " Point ▁ lies ▁ in ▁ 6th ▁ octant " ) NEW_LINE DEDENT elif ( x >= 0 and y < 0 and z < 0 ) : NEW_LINE INDENT print ( " Point ▁ lies ▁ in ▁ 8th ▁ octant " ) NEW_LINE DEDENT DEDENT

BLEU: 48.45
Edit Sim: 362


Src: 
int calculateAreaSum ( int l , int b ) { int size = 1 ; int maxSize = Math . min ( l , b ) ; int totalArea = 0 ; for ( int i = 1 ; i <= maxSize ; i ++ ) { int totalSquares = ( l - size + 1 ) * ( b - size + 1 ) ; int area = totalSquares * size * size ; totalArea += area ; size ++ ; } return totalArea ; }
Ref: 
def calculateAreaSum ( l , b ) : NEW_LINE INDENT size = 1 NEW_LINE maxSize = min ( l , b ) NEW_LINE totalArea = 0 NEW_LINE for i in range ( 1 , maxSize + 1 ) : NEW_LINE INDENT totalSquares = ( ( l - size + 1 ) * ( b - size + 1 ) ) NEW_LINE area = ( totalSquares * size * size ) NEW_LINE totalArea += area NEW_LINE size += 1 NEW_LINE DEDENT return totalArea NEW_LINE DEDENT
Hyp: 
def calculateAreaSum ( l , b ) : NEW_LINE INDENT size = 1 NEW_LINE maxSize = min ( l , b ) NEW_LINE totalArea = 0 NEW_LINE for i in range ( 1 , maxSize + 1 ) : NEW_LINE INDENT totalSquares = ( l - size + 1 ) * ( b - size + 1 ) NEW_LINE area = totalSquares * size * size NEW_LINE totalArea += area NEW_LINE size += 1 NEW_LINE DEDENT return totalArea NEW_LINE DEDENT

BLEU: 89.55
Edit Sim: 8


Src: 
void printSpiral ( int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { int x ; x = Math . min ( Math . min ( i , j ) , Math . min ( n - 1 - i , n - 1 - j ) ) ; if ( i <= j ) System . out . print ( ( n - 2 * x ) * ( n - 2 * x ) - ( i - x ) - ( j - x ) + " TABSYMBOL " ) ; else System . out . print ( ( n - 2 * x - 2 ) * ( n - 2 * x - 2 ) + ( i - x ) + ( j - x ) + " TABSYMBOL " ) ; } System . out . println ( ) ; } }
Ref: 
def printSpiral ( n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT x = min ( min ( i , j ) , min ( n - 1 - i , n - 1 - j ) ) NEW_LINE if ( i <= j ) : NEW_LINE INDENT print ( ( n - 2 * x ) * ( n - 2 * x ) - ( i - x ) - ( j - x ) , end = " TABSYMBOL " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ( ( n - 2 * x - 2 ) * ( n - 2 * x - 2 ) + ( i - x ) + ( j - x ) ) , end = " TABSYMBOL " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT
Hyp: 
def printSpiral ( n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT x = min ( min ( i , j ) , min ( n - 1 - i , n - 1 - j ) ) NEW_LINE if ( i <= j ) : NEW_LINE INDENT print ( ( n - 2 * x ) * ( n - 2 * x ) - ( i - x ) - ( j - x ) , end = " TABSYMBOL " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ( n - 2 * x - 2 ) * ( n - 2 * x - 2 ) + ( i - x ) + ( j - x ) + " TABSYMBOL " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT

BLEU: 91.28
Edit Sim: 19


Src: 
String evenlength ( String n ) { String res = n ; for ( int j = n . length ( ) - 1 ; j >= 0 ; -- j ) res += n . charAt ( j ) ; return res ; }
Ref: 
def evenlength ( n ) : NEW_LINE INDENT res = n NEW_LINE for j in range ( len ( n ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT res += n [ j ] NEW_LINE DEDENT return res NEW_LINE DEDENT
Hyp: 
def evenlength ( n ) : NEW_LINE INDENT res = n NEW_LINE for j in range ( len ( n ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT res += str ( n [ j ] ) NEW_LINE DEDENT return res NEW_LINE DEDENT

BLEU: 87.11
Edit Sim: 8


Src: 
int DecakismyriagonNum ( int N ) { return ( 99998 * N * N - 99996 * N ) / 2 ; }
Ref: 
def DecakismyriagonNum ( N ) : NEW_LINE INDENT return ( 99998 * N * N - 99996 * N ) // 2 ; NEW_LINE DEDENT
Hyp: 
def DecakismyriagonNum ( N ) : NEW_LINE INDENT return ( 99998 * N * N - 99996 * N ) // 2 NEW_LINE DEDENT

BLEU: 90.59
Edit Sim: 2


Src: 
double area_of_circle ( int m , int n ) { int square_of_radius = ( m * n ) / 4 ; double area = ( 3.141 * square_of_radius ) ; return area ; }
Ref: 
def area_of_circle ( m , n ) : NEW_LINE INDENT square_of_radius = ( m * n ) / 4 NEW_LINE area = ( 3.141 * square_of_radius ) NEW_LINE return area NEW_LINE DEDENT
Hyp: 
def area_of_circle ( m , n ) : NEW_LINE INDENT square_of_radius = ( m * n ) / 4 NEW_LINE area = ( 3.141 * square_of_radius ) NEW_LINE return area NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
void isKthBitSet ( int n , int k ) { if ( ( n & ( 1 << ( k - 1 ) ) ) > 0 ) System . out . print ( " SET " ) ; else System . out . print ( " NOT ▁ SET " ) ; }
Ref: 
def isKthBitSet ( n , k ) : NEW_LINE INDENT if n & ( 1 << ( k - 1 ) ) : NEW_LINE INDENT print ( " SET " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NOT ▁ SET " ) NEW_LINE DEDENT DEDENT
Hyp: 
def isKthBitSet ( n , k ) : NEW_LINE INDENT if ( n & ( 1 << ( k - 1 ) ) ) : NEW_LINE INDENT print ( " SET " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NOT ▁ SET " ) NEW_LINE DEDENT DEDENT

BLEU: 92.3
Edit Sim: 4


Src: 
String reversingString ( char [ ] str , int start , int end ) { while ( start < end ) { str [ start ] ^= str [ end ] ; str [ end ] ^= str [ start ] ; str [ start ] ^= str [ end ] ; ++ start ; -- end ; } return String . valueOf ( str ) ; }
Ref: 
def reversingString ( str , start , end ) : NEW_LINE INDENT while ( start < end ) : NEW_LINE INDENT str = ( str [ : start ] + chr ( ord ( str [ start ] ) ^ ord ( str [ end ] ) ) + str [ start + 1 : ] ) ; NEW_LINE str = ( str [ : end ] + chr ( ord ( str [ start ] ) ^ ord ( str [ end ] ) ) + str [ end + 1 : ] ) ; NEW_LINE str = ( str [ : start ] + chr ( ord ( str [ start ] ) ^ ord ( str [ end ] ) ) + str [ start + 1 : ] ) ; NEW_LINE start += 1 ; NEW_LINE end -= 1 ; NEW_LINE DEDENT return str ; NEW_LINE DEDENT
Hyp: 
def reversingString ( str , start , end ) : NEW_LINE INDENT while start < end : NEW_LINE INDENT str [ start ] ^= str [ end ] NEW_LINE str [ end ] ^= str [ start ] NEW_LINE str [ start ] ^= str [ end ] NEW_LINE start += 1 NEW_LINE end -= 1 NEW_LINE DEDENT return str NEW_LINE DEDENT

BLEU: 14.55
Edit Sim: 235


Src: 
char FindKthChar ( String str , int K , int X ) { char ans = ' ▁ ' ; int sum = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { int digit = ( int ) str . charAt ( i ) - 48 ; int range = ( int ) Math . pow ( digit , X ) ; sum += range ; if ( K <= sum ) { ans = str . charAt ( i ) ; break ; } } return ans ; }
Ref: 
def FindKthChar ( Str , K , X ) : NEW_LINE INDENT ans = ' ▁ ' NEW_LINE Sum = 0 NEW_LINE for i in range ( len ( Str ) ) : NEW_LINE INDENT digit = ord ( Str [ i ] ) - 48 NEW_LINE Range = int ( math . pow ( digit , X ) ) NEW_LINE Sum += Range NEW_LINE if ( K <= Sum ) : NEW_LINE INDENT ans = Str [ i ] NEW_LINE break NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
Hyp: 
def FindKthChar ( str , K , X ) : NEW_LINE INDENT ans = ' ▁ ' NEW_LINE sum = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT digit = ord ( str [ i ] ) - 48 NEW_LINE range = pow ( digit , X ) NEW_LINE sum += range NEW_LINE if ( K <= sum ) : NEW_LINE INDENT ans = str [ i ] NEW_LINE break NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT

BLEU: 67.1
Edit Sim: 24


Src: 
int smallestNum ( int N ) { float x = ( float ) ( Math . pow ( 10 , ( N - 1 ) / 2.0 ) ) ; return ( int ) ( Math . ceil ( x ) ) ; }
Ref: 
def smallestNum ( N ) : NEW_LINE INDENT x = pow ( 10.0 , ( N - 1 ) / 2.0 ) ; NEW_LINE return math . ceil ( x ) ; NEW_LINE DEDENT
Hyp: 
def smallestNum ( N ) : NEW_LINE INDENT x = ( pow ( 10 , ( N - 1 ) / 2 ) ) ; NEW_LINE return math . ceil ( x ) ) ; NEW_LINE DEDENT

BLEU: 71.36
Edit Sim: 8


Src: 
int get_palindrome_time ( String str ) { int hh , mm ; hh = ( str . charAt ( 0 ) - 48 ) * 10 + ( str . charAt ( 1 ) - 48 ) ; mm = ( str . charAt ( 3 ) - 48 ) * 10 + ( str . charAt ( 4 ) - 48 ) ; int requiredTime = 0 ; while ( hh % 10 != mm / 10 hh / 10 != mm % 10 ) { ++ mm ; if ( mm == 60 ) { mm = 0 ; ++ hh ; } if ( hh == 24 ) hh = 0 ; ++ requiredTime ; } return requiredTime ; }
Ref: 
def get_palindrome_time ( str ) : NEW_LINE INDENT hh = ( ( ord ( str [ 0 ] ) - 48 ) * 10 + ( ord ( str [ 1 ] ) - 48 ) ) NEW_LINE mm = ( ( ord ( str [ 3 ] ) - 48 ) * 10 + ( ord ( str [ 4 ] ) - 48 ) ) NEW_LINE requiredTime = 0 NEW_LINE while ( hh % 10 != mm // 10 or hh // 10 != mm % 10 ) : NEW_LINE INDENT mm += 1 NEW_LINE if ( mm == 60 ) : NEW_LINE INDENT mm = 0 NEW_LINE hh += 1 NEW_LINE DEDENT if ( hh == 24 ) : NEW_LINE INDENT hh = 0 NEW_LINE DEDENT requiredTime += 1 ; NEW_LINE DEDENT return requiredTime NEW_LINE DEDENT
Hyp: 
def get_palindrome_time ( str ) : NEW_LINE INDENT hh = ( int ) ( str [ 0 ] - 48 ) * 10 + ( int ) ( str [ 1 ] - 48 ) ; NEW_LINE mm = ( int ) ( str [ 3 ] - 48 ) * 10 + ( int ) ( str [ 4 ] - 48 ) ; NEW_LINE requiredTime = 0 ; NEW_LINE while ( hh % 10 != mm // 10 or mm // 10 != mm % 10 ) : NEW_LINE INDENT mm = 0 ; NEW_LINE hh = ( int ) ( hh % 10 ) ; NEW_LINE if ( mm == 60 ) : NEW_LINE INDENT mm = 0 ; NEW_LINE hh += 1 ; NEW_LINE DEDENT if ( hh == 24 ) : NEW_LINE INDENT hh = 0 ; NEW_LINE DEDENT requiredTime = 0 ; NEW_LINE DEDENT return requiredTime ; NEW_LINE DEDENT

BLEU: 61.82
Edit Sim: 82


Src: 
int countElements ( int p [ ] , int n ) { int ans = 0 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( p [ i - 1 ] > p [ i ] && p [ i ] > p [ i + 1 ] ) ans ++ ; else if ( p [ i - 1 ] < p [ i ] && p [ i ] < p [ i + 1 ] ) ans ++ ; } return ans ; }
Ref: 
def countElements ( p , n ) : NEW_LINE INDENT ans = 0 ; NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if ( p [ i - 1 ] > p [ i ] and p [ i ] > p [ i + 1 ] ) : NEW_LINE INDENT ans += 1 ; NEW_LINE DEDENT elif ( p [ i - 1 ] < p [ i ] and p [ i ] < p [ i + 1 ] ) : NEW_LINE INDENT ans += 1 ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT
Hyp: 
def countElements ( p , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if ( p [ i - 1 ] > p [ i ] and p [ i ] > p [ i + 1 ] ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT elif ( p [ i - 1 ] < p [ i ] and p [ i ] < p [ i + 1 ] ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT

BLEU: 90.48
Edit Sim: 8


Src: 
int min_index ( int p [ ] , int n ) { int ans = 0 ; int mini = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { if ( p [ i ] <= mini ) mini = p [ i ] ; if ( mini == p [ i ] ) ans ++ ; } return ans ; }
Ref: 
def min_index ( p , n ) : NEW_LINE INDENT ans = 0 ; NEW_LINE mini = INT_MAX ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( p [ i ] <= mini ) : NEW_LINE INDENT mini = p [ i ] ; NEW_LINE DEDENT if ( mini == p [ i ] ) : NEW_LINE INDENT ans += 1 ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT
Hyp: 
def min_index ( p , n ) : NEW_LINE INDENT ans = 0 NEW_LINE mini = INT_MAX NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( p [ i ] <= mini ) : NEW_LINE INDENT mini = p [ i ] NEW_LINE DEDENT if ( mini == p [ i ] ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT

BLEU: 82.97
Edit Sim: 10


Src: 
int MaximumPath ( int [ ] [ ] grid ) { int N = grid . length ; int M = grid [ 0 ] . length ; int [ ] [ ] sum = new int [ N + 1 ] [ M + 1 ] ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 1 ; j <= M ; j ++ ) { sum [ i ] [ j ] = Math . max ( sum [ i - 1 ] [ j ] , sum [ i ] [ j - 1 ] ) + grid [ i - 1 ] [ j - 1 ] ; } } return sum [ N ] [ M ] ; }
Ref: 
def MaximumPath ( grid ) : NEW_LINE INDENT N = len ( grid ) NEW_LINE M = len ( grid [ 0 ] ) NEW_LINE sum = [ [ 0 for i in range ( M + 1 ) ] for i in range ( N + 1 ) ] NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( 1 , M + 1 ) : NEW_LINE INDENT sum [ i ] [ j ] = ( max ( sum [ i - 1 ] [ j ] , sum [ i ] [ j - 1 ] ) + grid [ i - 1 ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT return sum [ N ] [ M ] NEW_LINE DEDENT
Hyp: 
def MaximumPath ( grid ) : NEW_LINE INDENT N = len ( grid ) NEW_LINE M = len ( grid [ 0 ] ) NEW_LINE sum = [ [ 0 for i in range ( M + 1 ) ] for i in range ( N + 1 ) ] NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( 1 , M + 1 ) : NEW_LINE INDENT sum [ i ] [ j ] = max ( sum [ i - 1 ] [ j ] , sum [ i ] [ j - 1 ] ) + grid [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT DEDENT return sum [ N ] [ M ] NEW_LINE DEDENT

BLEU: 96.28
Edit Sim: 4


Src: 
int CountSubarray ( int arr [ ] , int n , int k ) { int temp = k , count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == temp ) { if ( temp == 1 ) { count ++ ; temp = k ; } else temp -- ; } else { temp = k ; if ( arr [ i ] == k ) i -- ; } } return count ; }
Ref: 
def CountSubarray ( arr , n , k ) : NEW_LINE INDENT temp = k NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == temp ) : NEW_LINE INDENT if ( temp == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE temp = k NEW_LINE DEDENT else : NEW_LINE INDENT temp -= 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT temp = k NEW_LINE if ( arr [ i ] == k ) : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
Hyp: 
def CountSubarray ( arr , n , k ) : NEW_LINE INDENT temp = k NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == temp ) : NEW_LINE INDENT if ( temp == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE temp = k NEW_LINE DEDENT else : NEW_LINE INDENT temp -= 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT temp = k NEW_LINE if ( arr [ i ] == k ) : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
void getOrgString ( String s ) { System . out . print ( s . charAt ( 0 ) ) ; int i = 1 ; while ( i < s . length ( ) ) { if ( s . charAt ( i ) >= ' A ' && s . charAt ( i ) <= ' Z ' ) System . out . print ( " ▁ " + Character . toLowerCase ( s . charAt ( i ) ) ) ; else System . out . print ( s . charAt ( i ) ) ; i ++ ; } }
Ref: 
def getOrgString ( s ) : NEW_LINE INDENT print ( s [ 0 ] , end = " " ) NEW_LINE i = 1 NEW_LINE while ( i < len ( s ) ) : NEW_LINE INDENT if ( ord ( s [ i ] ) >= ord ( ' A ' ) and ord ( s [ i ] ) <= ord ( ' Z ' ) ) : NEW_LINE INDENT print ( " ▁ " , s [ i ] . lower ( ) , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( s [ i ] , end = " " ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT
Hyp: 
def getOrgString ( s ) : NEW_LINE INDENT print ( s [ 0 ] , end = " ▁ " ) NEW_LINE i = 1 NEW_LINE while i < len ( s ) : NEW_LINE INDENT if ( ord ( s [ i ] ) >= ord ( ' A ' ) and ord ( s [ i ] ) <= ord ( ' Z ' ) ) : NEW_LINE INDENT print ( " ▁ " , ord ( s [ i ] ) , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( s [ i ] , end = " ▁ " ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT DEDENT

BLEU: 85.29
Edit Sim: 36


Src: 
void singleDigitSubarrayCount ( int arr [ ] , int N ) { int res = 0 ; int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] <= 9 ) { count ++ ; res += count ; } else { count = 0 ; } } System . out . print ( res ) ; }
Ref: 
def singleDigitSubarrayCount ( arr , N ) : NEW_LINE INDENT res = 0 NEW_LINE count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] <= 9 ) : NEW_LINE INDENT count += 1 NEW_LINE res += count NEW_LINE DEDENT else : NEW_LINE INDENT count = 0 NEW_LINE DEDENT DEDENT print ( res ) NEW_LINE DEDENT
Hyp: 
def singleDigitSubarrayCount ( arr , N ) : NEW_LINE INDENT res = 0 NEW_LINE count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] <= 9 ) : NEW_LINE INDENT count += 1 NEW_LINE res += count NEW_LINE DEDENT else : NEW_LINE INDENT count = 0 NEW_LINE DEDENT DEDENT print ( res ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
void rearrange ( int [ ] arr , int n ) { int temp [ ] = arr . clone ( ) ; int small = 0 , large = n - 1 ; boolean flag = true ; for ( int i = 0 ; i < n ; i ++ ) { if ( flag ) arr [ i ] = temp [ large -- ] ; else arr [ i ] = temp [ small ++ ] ; flag = ! flag ; } }
Ref: 
def rearrange ( arr , n ) : NEW_LINE INDENT temp = n * [ None ] NEW_LINE small , large = 0 , n - 1 NEW_LINE flag = True NEW_LINE for i in range ( n ) : NEW_LINE INDENT if flag is True : NEW_LINE INDENT temp [ i ] = arr [ large ] NEW_LINE large -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT temp [ i ] = arr [ small ] NEW_LINE small += 1 NEW_LINE DEDENT flag = bool ( 1 - flag ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = temp [ i ] NEW_LINE DEDENT return arr NEW_LINE DEDENT
Hyp: 
def rearrange ( arr , n ) : NEW_LINE INDENT temp = arr NEW_LINE small = 0 NEW_LINE large = n - 1 NEW_LINE flag = True NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( flag ) : NEW_LINE INDENT arr [ i ] = temp [ large -= 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = temp [ small ] NEW_LINE DEDENT flag = not flag NEW_LINE DEDENT DEDENT

BLEU: 44.87
Edit Sim: 200


Src: 
int maxPathSum ( int tri [ ] [ ] , int m , int n ) { for ( int i = m - 1 ; i >= 0 ; i -- ) { for ( int j = 0 ; j <= i ; j ++ ) { if ( tri [ i + 1 ] [ j ] > tri [ i + 1 ] [ j + 1 ] ) tri [ i ] [ j ] += tri [ i + 1 ] [ j ] ; else tri [ i ] [ j ] += tri [ i + 1 ] [ j + 1 ] ; } } return tri [ 0 ] [ 0 ] ; }
Ref: 
def maxPathSum ( tri , m , n ) : NEW_LINE INDENT for i in range ( m - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( i + 1 ) : NEW_LINE INDENT if ( tri [ i + 1 ] [ j ] > tri [ i + 1 ] [ j + 1 ] ) : NEW_LINE INDENT tri [ i ] [ j ] += tri [ i + 1 ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT tri [ i ] [ j ] += tri [ i + 1 ] [ j + 1 ] NEW_LINE DEDENT DEDENT DEDENT return tri [ 0 ] [ 0 ] NEW_LINE DEDENT
Hyp: 
def maxPathSum ( tri , m , n ) : NEW_LINE INDENT for i in range ( m - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( i + 1 ) : NEW_LINE INDENT if ( tri [ i + 1 ] [ j ] > tri [ i + 1 ] [ j + 1 ] ) : NEW_LINE INDENT tri [ i ] [ j ] += tri [ i + 1 ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT tri [ i ] [ j ] += tri [ i + 1 ] [ j + 1 ] NEW_LINE DEDENT DEDENT DEDENT return tri [ 0 ] [ 0 ] NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int lbs ( int arr [ ] , int n ) { int i , j ; int [ ] lis = new int [ n ] ; for ( i = 0 ; i < n ; i ++ ) lis [ i ] = 1 ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; int [ ] lds = new int [ n ] ; for ( i = 0 ; i < n ; i ++ ) lds [ i ] = 1 ; for ( i = n - 2 ; i >= 0 ; i -- ) for ( j = n - 1 ; j > i ; j -- ) if ( arr [ i ] > arr [ j ] && lds [ i ] < lds [ j ] + 1 ) lds [ i ] = lds [ j ] + 1 ; int max = lis [ 0 ] + lds [ 0 ] - 1 ; for ( i = 1 ; i < n ; i ++ ) if ( lis [ i ] + lds [ i ] - 1 > max ) max = lis [ i ] + lds [ i ] - 1 ; return max ; }
Ref: 
def lbs ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE lis = [ 1 for i in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( 0 , i ) : NEW_LINE INDENT if ( ( arr [ i ] > arr [ j ] ) and ( lis [ i ] < lis [ j ] + 1 ) ) : NEW_LINE INDENT lis [ i ] = lis [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT lds = [ 1 for i in range ( n + 1 ) ] NEW_LINE for i in reversed ( range ( n - 1 ) ) : NEW_LINE INDENT for j in reversed ( range ( i - 1 , n ) ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and lds [ i ] < lds [ j ] + 1 ) : NEW_LINE INDENT lds [ i ] = lds [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT maximum = lis [ 0 ] + lds [ 0 ] - 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT maximum = max ( ( lis [ i ] + lds [ i ] - 1 ) , maximum ) NEW_LINE DEDENT return maximum NEW_LINE DEDENT
Hyp: 
def lbs ( arr , n ) : NEW_LINE INDENT lis = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT lis [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and lis [ i ] < lis [ j ] + 1 ) : NEW_LINE INDENT lis [ i ] = lis [ j ] + 1 NEW_LINE DEDENT DEDENT lds = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and lds [ i ] < lds [ j ] + 1 ) : NEW_LINE INDENT lds [ i ] = lds [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT max = lis [ 0 ] + lds [ 0 ] - 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( lis [ i ] + lds [ i ] - 1 > max ) : NEW_LINE INDENT max = lis [ i ] + lds [ i ] - 1 NEW_LINE DEDENT DEDENT return max NEW_LINE DEDENT

BLEU: 71.82
Edit Sim: 213


Src: 
int SquareCube ( long N ) { int cnt = 0 , i = 1 ; while ( ( int ) ( Math . pow ( i , 6 ) ) <= N ) { ++ cnt ; ++ i ; } return cnt ; }
Ref: 
def SquareCube ( N ) : NEW_LINE INDENT cnt , i = 0 , 1 NEW_LINE while ( i ** 6 <= N ) : NEW_LINE INDENT cnt += 1 NEW_LINE i += 1 NEW_LINE DEDENT return cnt NEW_LINE DEDENT
Hyp: 
def SquareCube ( N ) : NEW_LINE INDENT cnt = 0 NEW_LINE i = 1 NEW_LINE while ( ( int ) ( pow ( i , 6 ) ) <= N ) : NEW_LINE INDENT cnt = cnt + 1 NEW_LINE i += 1 NEW_LINE DEDENT return cnt NEW_LINE DEDENT

BLEU: 55.41
Edit Sim: 40


Src: 
void maximumSum ( int [ ] arr , int N ) { int sum ; Arrays . sort ( arr ) ; sum = ( arr [ N - 1 ] - arr [ 0 ] ) + ( arr [ N - 2 ] - arr [ 0 ] ) + ( arr [ N - 1 ] - arr [ N - 2 ] ) ; System . out . println ( sum ) ; }
Ref: 
def maximumSum ( arr , N ) : NEW_LINE INDENT sum = 0 NEW_LINE arr . sort ( ) NEW_LINE sum = ( arr [ N - 1 ] - arr [ 0 ] ) + ( arr [ N - 2 ] - arr [ 0 ] ) + ( arr [ N - 1 ] - arr [ N - 2 ] ) ; NEW_LINE print ( sum ) NEW_LINE DEDENT
Hyp: 
def maximumSum ( arr , N ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE sum = ( arr [ N - 1 ] - arr [ 0 ] ) + ( arr [ N - 2 ] - arr [ 0 ] ) + ( arr [ N - 1 ] - arr [ N - 2 ] ) NEW_LINE print ( sum ) NEW_LINE DEDENT

BLEU: 88.67
Edit Sim: 19


Src: 
long SmallestPerfectSquare ( long N ) { long X = ( long ) 1e9 ; long ans ; for ( int i = 1 ; i < Math . sqrt ( N ) ; i ++ ) { if ( N % i == 0 ) { long a = i ; long b = N / i ; if ( ( b - a != 0 ) && ( ( b - a ) % 2 == 0 ) ) { X = Math . min ( X , ( b - a ) / 2 ) ; } } } if ( X != 1e9 ) ans = X * X ; else ans = - 1 ; return ans ; }
Ref: 
def SmallestPerfectSquare ( N ) : NEW_LINE INDENT X = 1e9 NEW_LINE for i in range ( 1 , int ( math . sqrt ( N ) ) + 1 ) : NEW_LINE INDENT if N % i == 0 : NEW_LINE INDENT a = i NEW_LINE b = N // i NEW_LINE if b - a != 0 and ( b - a ) % 2 == 0 : NEW_LINE INDENT X = min ( X , ( b - a ) // 2 ) NEW_LINE DEDENT DEDENT DEDENT return ( X * X if X != 1e9 else - 1 ) NEW_LINE DEDENT
Hyp: 
def SmallestPerfectSquare ( N ) : NEW_LINE INDENT X = 1e9 NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , int ( sqrt ( N ) ) + 1 ) : NEW_LINE INDENT if ( N % i == 0 ) : NEW_LINE INDENT a = i NEW_LINE b = N // i NEW_LINE if ( ( b - a != 0 ) and ( ( b - a ) % 2 == 0 ) ) : NEW_LINE INDENT X = min ( X , ( b - a ) // 2 ) NEW_LINE DEDENT DEDENT DEDENT if ( X != 1e9 ) : NEW_LINE INDENT ans = X * X NEW_LINE DEDENT else : NEW_LINE INDENT ans = - 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT

BLEU: 63.47
Edit Sim: 140


Src: 
double sum ( int x , int n ) { double i , total = 1.0 , multi = x ; System . out . print ( "1 ▁ " ) ; for ( i = 1 ; i < n ; i ++ ) { total = total + multi ; System . out . print ( multi ) ; System . out . print ( " ▁ " ) ; multi = multi * x ; } System . out . println ( ) ; return total ; }
Ref: 
def sum ( x , n ) : NEW_LINE INDENT total = 1.0 NEW_LINE multi = x NEW_LINE print ( 1 , end = " ▁ " ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT total = total + multi NEW_LINE print ( ' % .1f ' % multi , end = " ▁ " ) NEW_LINE multi = multi * x NEW_LINE DEDENT print ( ' ' ) NEW_LINE return total ; NEW_LINE DEDENT
Hyp: 
def sum ( x , n ) : NEW_LINE INDENT total = 1.0 NEW_LINE multi = x NEW_LINE print ( "1 ▁ " ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT total = total + multi NEW_LINE print ( multi ) NEW_LINE print ( " ▁ " ) NEW_LINE multi = multi * x NEW_LINE DEDENT print ( ) NEW_LINE return total NEW_LINE DEDENT

BLEU: 71.0
Edit Sim: 38


Src: 
boolean check ( int n ) { if ( n <= 0 ) return false ; return 1162261467 % n == 0 ; }
Ref: 
def check ( n ) : NEW_LINE INDENT return 1162261467 % n == 0 NEW_LINE DEDENT n = 9 NEW_LINE if ( check ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
Hyp: 
def check ( n ) : NEW_LINE INDENT if n <= 0 : NEW_LINE INDENT return False NEW_LINE DEDENT return 1162261467 % n == 0 NEW_LINE DEDENT

BLEU: 27.27
Edit Sim: 117


Src: 
boolean divisorsSame ( int n ) { return ( n - 2 ) % 4 == 0 ; }
Ref: 
def divisorsSame ( n ) : NEW_LINE INDENT return ( n - 2 ) % 4 == 0 ; NEW_LINE DEDENT N = 6 ; NEW_LINE if ( divisorsSame ( N ) ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT
Hyp: 
def divisorsSame ( n ) : NEW_LINE INDENT return ( n - 2 ) % 4 == 0 NEW_LINE DEDENT n = 65 NEW_LINE if ( divisorsSame ( n ) ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT

BLEU: 82.23
Edit Sim: 6


Src: 
float trapezoidarea ( float r ) { if ( r < 0 ) return - 1 ; float a = ( 3 * ( float ) Math . sqrt ( 3 ) * ( float ) Math . pow ( r , 2 ) ) / 4 ; return a ; }
Ref: 
def trapezoidarea ( r ) : NEW_LINE INDENT if r < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT a = ( 3 * sqrt ( 3 ) * pow ( r , 2 ) ) / 4 NEW_LINE return a NEW_LINE DEDENT
Hyp: 
def trapezoidarea ( r ) : NEW_LINE INDENT if r < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT a = ( 3 * math . sqrt ( 3 ) * math . pow ( r , 2 ) ) / 4 NEW_LINE return a NEW_LINE DEDENT

BLEU: 84.99
Edit Sim: 14


Src: 
int Valid ( int a , int b , int c ) { if ( a + b + c == 180 && a != 0 && b != 0 && c != 0 ) return 1 ; else return 0 ; }
Ref: 
def Valid ( a , b , c ) : NEW_LINE INDENT if ( ( a + b + c == 180 ) and a != 0 and b != 0 and c != 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
Hyp: 
def Valid ( a , b , c ) : NEW_LINE INDENT if ( a + b + c == 180 and a != 0 and b != 0 and c != 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT

BLEU: 81.38
Edit Sim: 13


Src: 
String maxValue ( char [ ] a , char [ ] b ) { Arrays . sort ( b ) ; int n = a . length ; int m = b . length ; int j = m - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( j < 0 ) break ; if ( b [ j ] > a [ i ] ) { a [ i ] = b [ j ] ; j -- ; } } return String . valueOf ( a ) ; }
Ref: 
def maxValue ( a , b ) : NEW_LINE INDENT b = sorted ( b ) NEW_LINE bi = [ i for i in b ] NEW_LINE ai = [ i for i in a ] NEW_LINE n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE j = m - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( j < 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( bi [ j ] > ai [ i ] ) : NEW_LINE INDENT ai [ i ] = bi [ j ] NEW_LINE j -= 1 NEW_LINE DEDENT DEDENT x = " " . join ( ai ) NEW_LINE return x NEW_LINE DEDENT
Hyp: 
def maxValue ( a , b ) : NEW_LINE INDENT b . sort ( ) NEW_LINE n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE j = m - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( j < 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( b [ j ] > a [ i ] ) : NEW_LINE INDENT a [ i ] = b [ j ] NEW_LINE j -= 1 NEW_LINE DEDENT DEDENT return string ( a ) NEW_LINE DEDENT

BLEU: 59.44
Edit Sim: 102


Src: 
int minimumCost ( int cost [ ] , int n ) { int dp [ ] = new int [ n ] ; if ( n == 1 ) return cost [ 0 ] ; dp [ 0 ] = cost [ 0 ] ; dp [ 1 ] = cost [ 1 ] ; for ( int i = 2 ; i < n ; i ++ ) { dp [ i ] = Math . min ( dp [ i - 1 ] , dp [ i - 2 ] ) + cost [ i ] ; } return Math . min ( dp [ n - 2 ] , dp [ n - 1 ] ) ; }
Ref: 
def minimumCost ( cost , n ) : NEW_LINE INDENT dp = [ None ] * n NEW_LINE if n == 1 : NEW_LINE INDENT return cost [ 0 ] NEW_LINE DEDENT dp [ 0 ] = cost [ 0 ] NEW_LINE dp [ 1 ] = cost [ 1 ] NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT dp [ i ] = min ( dp [ i - 1 ] , dp [ i - 2 ] ) + cost [ i ] NEW_LINE DEDENT return min ( dp [ n - 2 ] , dp [ n - 1 ] ) NEW_LINE DEDENT
Hyp: 
def minimumCost ( cost , n ) : NEW_LINE INDENT dp = [ 0 ] * n NEW_LINE if ( n == 1 ) : NEW_LINE INDENT return cost [ 0 ] NEW_LINE DEDENT dp [ 0 ] = cost [ 0 ] NEW_LINE dp [ 1 ] = cost [ 1 ] NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT dp [ i ] = min ( dp [ i - 1 ] , dp [ i - 2 ] ) + cost [ i ] NEW_LINE DEDENT return min ( dp [ n - 2 ] , dp [ n - 1 ] ) NEW_LINE DEDENT

BLEU: 93.25
Edit Sim: 8


Src: 
int findSubstringCount ( String str ) { int result = 0 ; int n = str . length ( ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( str . charAt ( i ) + 1 == str . charAt ( i + 1 ) ) { result ++ ; while ( str . charAt ( i ) + 1 == str . charAt ( i + 1 ) ) { i ++ ; } } } return result ; }
Ref: 
def findSubstringCount ( str ) : NEW_LINE INDENT result = 0 NEW_LINE n = len ( str ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( ord ( str [ i ] ) + 1 == ord ( str [ i + 1 ] ) ) : NEW_LINE INDENT result += 1 NEW_LINE while ( ord ( str [ i ] ) + 1 == ord ( str [ i + 1 ] ) ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
Hyp: 
def findSubstringCount ( str ) : NEW_LINE INDENT result = 0 NEW_LINE n = len ( str ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( str [ i ] + 1 == str [ i + 1 ] ) : NEW_LINE INDENT result += 1 NEW_LINE while ( str [ i ] + 1 == str [ i + 1 ] ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT

BLEU: 76.8
Edit Sim: 32


Src: 
int count ( int n ) { int [ ] dp = new int [ n + 1 ] ; dp [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i >= 1 && i <= 3 ) dp [ i ] = 1 ; else if ( i == 4 ) dp [ i ] = 2 ; else { dp [ i ] = dp [ i - 1 ] + dp [ i - 4 ] ; } } return dp [ n ] ; }
Ref: 
def count ( n ) : NEW_LINE INDENT dp = [ 0 for _ in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if i <= 3 : NEW_LINE INDENT dp [ i ] = 1 NEW_LINE DEDENT elif i == 4 : NEW_LINE INDENT dp [ i ] = 2 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] + dp [ i - 4 ] NEW_LINE DEDENT DEDENT return dp [ n ] NEW_LINE DEDENT
Hyp: 
def count ( n ) : NEW_LINE INDENT dp = [ 0 for i in range ( n + 1 ) ] NEW_LINE dp [ 0 ] = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( i >= 1 and i <= 3 ) : NEW_LINE INDENT dp [ i ] = 1 NEW_LINE DEDENT elif ( i == 4 ) : NEW_LINE INDENT dp [ i ] = 2 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] = ( dp [ i - 1 ] + dp [ i - 4 ] ) NEW_LINE DEDENT DEDENT return dp [ n ] NEW_LINE DEDENT

BLEU: 74.2
Edit Sim: 46


Src: 
int count ( int N ) { int a = 0 ; a = ( N * ( N + 1 ) ) / 2 ; return a ; }
Ref: 
def count ( N ) : NEW_LINE INDENT a = 0 ; NEW_LINE a = ( N * ( N + 1 ) ) / 2 ; NEW_LINE return int ( a ) ; NEW_LINE DEDENT
Hyp: 
def count ( N ) : NEW_LINE INDENT a = 0 NEW_LINE a = ( N * ( N + 1 ) ) // 2 NEW_LINE return a NEW_LINE DEDENT

BLEU: 62.67
Edit Sim: 15


Src: 
String isDivisible ( long n ) { long temp = n ; int sum = 0 ; while ( n != 0 ) { int k = ( int ) n % 10 ; sum += k ; n /= 10 ; } if ( temp % sum == 0 ) return " YES " ; return " NO " ; }
Ref: 
def isDivisible ( n ) : NEW_LINE INDENT temp = n NEW_LINE sum = 0 ; NEW_LINE while ( n ) : NEW_LINE INDENT k = n % 10 ; NEW_LINE sum += k ; NEW_LINE n /= 10 ; NEW_LINE DEDENT if ( temp % sum == 0 ) : NEW_LINE INDENT return " YES " ; NEW_LINE DEDENT return " NO " ; NEW_LINE DEDENT
Hyp: 
def isDivisible ( n ) : NEW_LINE INDENT temp = n NEW_LINE sum = 0 NEW_LINE while ( n ) : NEW_LINE INDENT k = int ( n % 10 ) NEW_LINE sum += k NEW_LINE n /= 10 NEW_LINE DEDENT if ( temp % sum == 0 ) : NEW_LINE INDENT return " YES " NEW_LINE DEDENT return " NO " NEW_LINE DEDENT

BLEU: 74.4
Edit Sim: 17


Src: 
int count ( int S [ ] , int m , int n ) { if ( n == 0 ) return 1 ; if ( n < 0 ) return 0 ; if ( m <= 0 && n >= 1 ) return 0 ; return count ( S , m - 1 , n ) + count ( S , m , n - S [ m - 1 ] ) ; }
Ref: 
def count ( S , m , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n < 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( m <= 0 and n >= 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return count ( S , m - 1 , n ) + count ( S , m , n - S [ m - 1 ] ) ; NEW_LINE DEDENT
Hyp: 
def count ( S , m , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( m <= 0 and n >= 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return count ( S , m - 1 , n ) + count ( S , m , n - S [ m - 1 ] ) NEW_LINE DEDENT

BLEU: 94.37
Edit Sim: 4


Src: 
void newvol ( double x ) { System . out . print ( " percentage ▁ increase ▁ " + " in ▁ the ▁ volume ▁ of ▁ the ▁ cube ▁ is ▁ " + ( Math . pow ( x , 3 ) / 10000 + 3 * x + ( 3 * Math . pow ( x , 2 ) ) / 100 ) ) ; System . out . print ( " % " ) ; }
Ref: 
def newvol ( x ) : NEW_LINE INDENT print ( " percentage ▁ increase " " in ▁ the ▁ volume ▁ of ▁ the ▁ cube ▁ is ▁ " , ( ( x ** ( 3 ) ) / 10000 + 3 * x + ( 3 * ( x ** ( 2 ) ) ) / 100 ) , " % " ) ; NEW_LINE DEDENT
Hyp: 
def newvol ( x ) : NEW_LINE INDENT print ( " percentage ▁ increase ▁ " , " in ▁ the ▁ volume ▁ of ▁ the ▁ cube ▁ is ▁ " , ( ( pow ( x , 3 ) / 10000 + 3 * x + ( 3 * pow ( x , 2 ) ) / 100 ) ) NEW_LINE DEDENT

BLEU: 69.9
Edit Sim: 30


Src: 
void countElement ( int A [ ] , int N , int B [ ] , int M , int K ) { int cnt = 0 ; for ( int i = 0 ; i < M ; i ++ ) { int currentElement = B [ i ] ; for ( int j = 0 ; j < N ; j ++ ) { int diff = Math . abs ( currentElement - A [ j ] ) ; if ( diff <= K ) { cnt ++ ; break ; } } } System . out . print ( cnt ) ; }
Ref: 
def countElement ( A , N , B , M , K ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( M ) : NEW_LINE INDENT currentElement = B [ i ] NEW_LINE for j in range ( N ) : NEW_LINE INDENT diff = abs ( currentElement - A [ j ] ) NEW_LINE if ( diff <= K ) : NEW_LINE INDENT cnt += 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT print ( cnt ) NEW_LINE DEDENT
Hyp: 
def countElement ( A , N , B , M , K ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( M ) : NEW_LINE INDENT currentElement = B [ i ] NEW_LINE for j in range ( N ) : NEW_LINE INDENT diff = abs ( currentElement - A [ j ] ) NEW_LINE if ( diff <= K ) : NEW_LINE INDENT cnt += 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT print ( cnt ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
void parallel ( int a [ ] [ ] ) { boolean x = true , y = true ; for ( int i = 0 ; i < a . length - 1 ; i ++ ) { if ( a [ i ] [ 0 ] != a [ i + 1 ] [ 0 ] ) x = false ; if ( a [ i ] [ 1 ] != a [ i + 1 ] [ 1 ] ) y = false ; } if ( x ) System . out . println ( " Parallel ▁ to ▁ Y ▁ Axis " ) ; else if ( y ) System . out . println ( " Parallel ▁ to ▁ X ▁ Axis " ) ; else System . out . println ( " Not ▁ parallel ▁ to ▁ X " + " ▁ and ▁ Y ▁ axis " ) ; }
Ref: 
def parallel ( n , a ) : NEW_LINE INDENT x = True ; NEW_LINE y = True ; NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( a [ i ] [ 0 ] != a [ i + 1 ] [ 0 ] ) : NEW_LINE INDENT x = False ; NEW_LINE DEDENT if ( a [ i ] [ 1 ] != a [ i + 1 ] [ 1 ] ) : NEW_LINE INDENT y = False ; NEW_LINE DEDENT DEDENT if ( x ) : NEW_LINE INDENT print ( " Parallel ▁ to ▁ Y ▁ Axis " ) ; NEW_LINE DEDENT elif ( y ) : NEW_LINE INDENT print ( " Parallel ▁ to ▁ X ▁ Axis " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ Parallel ▁ to ▁ X ▁ and ▁ Y ▁ Axis " ) ; NEW_LINE DEDENT DEDENT
Hyp: 
def parallel ( a ) : NEW_LINE INDENT x = True ; y = True ; NEW_LINE for i in range ( len ( a ) - 1 ) : NEW_LINE INDENT if ( a [ i ] [ 0 ] != a [ i + 1 ] [ 0 ] ) : NEW_LINE INDENT x = False ; NEW_LINE DEDENT if ( a [ i ] [ 1 ] != a [ i + 1 ] [ 1 ] ) : NEW_LINE INDENT y = False ; NEW_LINE DEDENT DEDENT if ( x ) : NEW_LINE INDENT print ( " Parallel ▁ to ▁ Y ▁ Axis " ) ; NEW_LINE DEDENT elif ( y ) : NEW_LINE INDENT print ( " Parallel ▁ to ▁ X ▁ Axis " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ parallel ▁ to ▁ Y ▁ Axis " ) ; NEW_LINE DEDENT DEDENT

BLEU: 90.08
Edit Sim: 32


Src: 
void multiplicativeCongruentialMethod ( int Xo , int m , int a , int [ ] randomNums , int noOfRandomNums ) { randomNums [ 0 ] = Xo ; for ( int i = 1 ; i < noOfRandomNums ; i ++ ) { randomNums [ i ] = ( randomNums [ i - 1 ] * a ) % m ; } }
Ref: 
def multiplicativeCongruentialMethod ( Xo , m , a , randomNums , noOfRandomNums ) : NEW_LINE INDENT randomNums [ 0 ] = Xo NEW_LINE for i in range ( 1 , noOfRandomNums ) : NEW_LINE INDENT randomNums [ i ] = ( randomNums [ i - 1 ] * a ) % m NEW_LINE DEDENT DEDENT
Hyp: 
def multiplicativeCongruentialMethod ( Xo , m , a , randomNums , noOfRandomNums ) : NEW_LINE INDENT randomNums [ 0 ] = Xo NEW_LINE for i in range ( 1 , noOfRandomNums ) : NEW_LINE INDENT randomNums [ i ] = ( randomNums [ i - 1 ] * a ) % m NEW_LINE DEDENT DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int count ( int arr [ ] , int N , int K ) { int count = 0 , ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == K ) { count = count + 1 ; } else { ans += ( count * ( count + 1 ) ) / 2 ; count = 0 ; } } ans = ans + ( count * ( count + 1 ) ) / 2 ; return ans ; }
Ref: 
def count ( arr , N , K ) : NEW_LINE INDENT count = 0 NEW_LINE ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] == K ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += ( count * ( count + 1 ) ) // 2 NEW_LINE count = 0 NEW_LINE DEDENT DEDENT ans = ans + ( count * ( count + 1 ) ) // 2 NEW_LINE return ans NEW_LINE DEDENT
Hyp: 
def count ( arr , N , K ) : NEW_LINE INDENT count = 0 NEW_LINE ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if arr [ i ] == K : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += ( count * ( count + 1 ) ) // 2 NEW_LINE count = 0 NEW_LINE DEDENT DEDENT ans = ans + ( count * ( count + 1 ) ) // 2 NEW_LINE return ans NEW_LINE DEDENT

BLEU: 94.52
Edit Sim: 4


Src: 
int equalXORandOR ( int n ) { int m = 0 ; int MSB = ( int ) Math . log ( n ) ; for ( int i = 0 ; i <= MSB ; i ++ ) { if ( ( n & ( 1 << i ) ) <= 0 ) { m += ( 1 << i ) ; } } return m ; }
Ref: 
def equalXORandOR ( n ) : NEW_LINE INDENT m = 0 NEW_LINE MSB = int ( log2 ( n ) ) NEW_LINE for i in range ( MSB + 1 ) : NEW_LINE INDENT if ( not ( n & ( 1 << i ) ) ) : NEW_LINE INDENT m += ( 1 << i ) NEW_LINE DEDENT DEDENT return m NEW_LINE DEDENT
Hyp: 
def equalXORandOR ( n ) : NEW_LINE INDENT m = 0 NEW_LINE MSB = int ( math . log2 ( n ) ) ; NEW_LINE for i in range ( MSB + 1 ) : NEW_LINE INDENT if ( n & ( 1 << i ) ) <= 0 : NEW_LINE INDENT m += ( 1 << i ) NEW_LINE DEDENT DEDENT return m NEW_LINE DEDENT

BLEU: 83.98
Edit Sim: 19


Src: 
void checkCollision ( int a , int b , int c , int x , int y , int radius ) { double dist = ( Math . abs ( a * x + b * y + c ) ) / Math . sqrt ( a * a + b * b ) ; if ( radius == dist ) System . out . println ( " Touch " ) ; else if ( radius > dist ) System . out . println ( " Intersect " ) ; else System . out . println ( " Outside " ) ; }
Ref: 
def checkCollision ( a , b , c , x , y , radius ) : NEW_LINE INDENT dist = ( ( abs ( a * x + b * y + c ) ) / math . sqrt ( a * a + b * b ) ) NEW_LINE if ( radius == dist ) : NEW_LINE INDENT print ( " Touch " ) NEW_LINE DEDENT elif ( radius > dist ) : NEW_LINE INDENT print ( " Intersect " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Outside " ) NEW_LINE DEDENT DEDENT
Hyp: 
def checkCollision ( a , b , c , x , y , radius ) : NEW_LINE INDENT dist = ( abs ( a * x + b * y + c ) ) / math . sqrt ( a * a + b * b ) ) NEW_LINE if ( radius == dist ) : NEW_LINE INDENT print ( " Touch " ) NEW_LINE DEDENT elif ( radius > dist ) : NEW_LINE INDENT print ( " Intersect " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Outside " ) NEW_LINE DEDENT DEDENT

BLEU: 98.17
Edit Sim: 2


Src: 
boolean check ( int a [ ] , int n ) { int ma = a [ 1 ] - a [ 0 ] ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( ( a [ i ] > a [ i - 1 ] && a [ i + 1 ] < a [ i ] ) || ( a [ i ] < a [ i - 1 ] && a [ i + 1 ] > a [ i ] ) ) ma = Math . max ( ma , Math . abs ( a [ i ] - a [ i + 1 ] ) ) ; else return false ; } System . out . print ( " Amplitude ▁ = ▁ " + ma ) ; System . out . println ( ) ; return true ; }
Ref: 
def check ( a , n ) : NEW_LINE INDENT ma = a [ 1 ] - a [ 0 ] NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if ( ( a [ i ] > a [ i - 1 ] and a [ i + 1 ] < a [ i ] ) or ( a [ i ] < a [ i - 1 ] and a [ i + 1 ] > a [ i ] ) ) : NEW_LINE INDENT ma = max ( ma , abs ( a [ i ] - a [ i + 1 ] ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT print ( " Amplitude ▁ = ▁ " , ma ) NEW_LINE return True NEW_LINE DEDENT
Hyp: 
def check ( a , n ) : NEW_LINE INDENT ma = a [ 1 ] - a [ 0 ] NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if ( ( a [ i ] > a [ i - 1 ] and a [ i + 1 ] < a [ i ] ) or ( a [ i ] < a [ i - 1 ] and a [ i + 1 ] > a [ i ] ) ) : NEW_LINE INDENT ma = max ( ma , abs ( a [ i ] - a [ i + 1 ] ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT print ( " Amplitude ▁ = " , ma ) NEW_LINE print ( ) NEW_LINE return True NEW_LINE DEDENT

BLEU: 95.98
Edit Sim: 21


Src: 
int MaximumSum ( int a [ ] , int b [ ] , int n ) { int [ ] [ ] dp = new int [ n ] [ 2 ] ; dp [ 0 ] [ 0 ] = a [ 0 ] ; dp [ 0 ] [ 1 ] = b [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { dp [ i ] [ 0 ] = Math . max ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] ) + a [ i ] ; dp [ i ] [ 1 ] = Math . max ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] ) ; if ( i - 2 >= 0 ) { dp [ i ] [ 1 ] = Math . max ( dp [ i ] [ 1 ] , Math . max ( dp [ i - 2 ] [ 0 ] , dp [ i - 2 ] [ 1 ] ) + b [ i ] ) ; } else { dp [ i ] [ 1 ] = Math . max ( dp [ i ] [ 1 ] , b [ i ] ) ; } } return Math . max ( dp [ n - 1 ] [ 0 ] , dp [ n - 1 ] [ 1 ] ) ; }
Ref: 
def MaximumSum ( a , b , n ) : NEW_LINE INDENT dp = [ [ - 1 for j in range ( 2 ) ] for i in range ( n ) ] NEW_LINE dp [ 0 ] [ 0 ] = a [ 0 ] NEW_LINE dp [ 0 ] [ 1 ] = b [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT dp [ i ] [ 0 ] = max ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] ) + a [ i ] NEW_LINE dp [ i ] [ 1 ] = max ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] ) NEW_LINE if ( i - 2 >= 0 ) : NEW_LINE INDENT dp [ i ] [ 1 ] = max ( dp [ i ] [ 1 ] , max ( dp [ i - 2 ] [ 0 ] , dp [ i - 2 ] [ 1 ] ) + b [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ 1 ] = max ( dp [ i ] [ 1 ] , b [ i ] ) NEW_LINE DEDENT DEDENT return max ( dp [ n - 1 ] [ 0 ] , dp [ n - 1 ] [ 1 ] ) NEW_LINE DEDENT
Hyp: 
def MaximumSum ( a , b , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( 2 ) ] for j in range ( n ) ] NEW_LINE dp [ 0 ] [ 0 ] = a [ 0 ] NEW_LINE dp [ 0 ] [ 1 ] = b [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT dp [ i ] [ 0 ] = max ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] ) + a [ i ] NEW_LINE dp [ i ] [ 1 ] = max ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] ) NEW_LINE if ( i - 2 >= 0 ) : NEW_LINE INDENT dp [ i ] [ 1 ] = max ( dp [ i ] [ 1 ] , max ( dp [ i - 2 ] [ 0 ] , dp [ i - 2 ] [ 1 ] ) + b [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ 1 ] = max ( dp [ i ] [ 1 ] , b [ i ] ) NEW_LINE DEDENT DEDENT return max ( dp [ n - 1 ] [ 0 ] , dp [ n - 1 ] [ 1 ] ) NEW_LINE DEDENT

BLEU: 98.32
Edit Sim: 5


Src: 
void checkTriangle ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 ) { int a = x1 * ( y2 - y3 ) + x2 * ( y3 - y1 ) + x3 * ( y1 - y2 ) ; if ( a == 0 ) System . out . println ( " No " ) ; else System . out . println ( " Yes " ) ; }
Ref: 
def checkTriangle ( x1 , y1 , x2 , y2 , x3 , y3 ) : NEW_LINE INDENT a = ( x1 * ( y2 - y3 ) + x2 * ( y3 - y1 ) + x3 * ( y1 - y2 ) ) NEW_LINE if a == 0 : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT DEDENT
Hyp: 
def checkTriangle ( x1 , y1 , x2 , y2 , x3 , y3 ) : NEW_LINE INDENT a = x1 * ( y2 - y3 ) + x2 * ( y3 - y1 ) + x3 * ( y1 - y2 ) NEW_LINE if ( a == 0 ) : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT DEDENT

BLEU: 78.35
Edit Sim: 12


Src: 
void AlternateRearrange ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 == 0 ) v1 . add ( arr [ i ] ) ; else v2 . add ( arr [ i ] ) ; int index = 0 , i = 0 , j = 0 ; boolean flag = false ; if ( arr [ 0 ] % 2 == 0 ) flag = true ; while ( index < n ) { if ( flag == true ) { arr [ index ] = ( int ) v1 . get ( i ) ; i += 1 ; index += 1 ; flag = ! flag ; } else { arr [ index ] = ( int ) v2 . get ( j ) ; j += 1 ; index += 1 ; flag = ! flag ; } } for ( i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; }
Ref: 
def AlternateRearrange ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT v1 . append ( arr [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT v2 . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT index = 0 NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE flag = False NEW_LINE if ( arr [ 0 ] % 2 == 0 ) : NEW_LINE INDENT flag = True NEW_LINE DEDENT while ( index < n ) : NEW_LINE INDENT if ( flag == True and i < len ( v1 ) ) : NEW_LINE INDENT arr [ index ] = v1 [ i ] NEW_LINE index += 1 NEW_LINE i += 1 NEW_LINE flag = ~ flag NEW_LINE DEDENT elif j < len ( v2 ) : NEW_LINE INDENT arr [ index ] = v2 [ j ] NEW_LINE index += 1 NEW_LINE j += 1 NEW_LINE flag = ~ flag NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
Hyp: 
def AlternateRearrange ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT v1 . add ( arr [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT v2 . add ( arr [ i ] ) NEW_LINE DEDENT DEDENT index = 0 NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE flag = 0 NEW_LINE if ( arr [ 0 ] % 2 == 0 ) : NEW_LINE INDENT flag = True NEW_LINE DEDENT while ( index < n ) : NEW_LINE INDENT if ( flag == True ) : NEW_LINE INDENT arr [ index ] = v1 [ i ] NEW_LINE i += 1 NEW_LINE index += 1 NEW_LINE flag = not flag NEW_LINE DEDENT else : NEW_LINE INDENT arr [ index ] = v2 [ j ] NEW_LINE j += 1 NEW_LINE index += 1 NEW_LINE flag = not flag NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT

BLEU: 84.28
Edit Sim: 72


Src: 
int minimumHammingDistance ( String S , int K ) { int n = S . length ( ) ; int [ ] pref = new int [ n ] ; pref [ 0 ] = S . charAt ( 0 ) - '0' ; for ( int i = 1 ; i < n ; i ++ ) pref [ i ] = pref [ i - 1 ] + ( S . charAt ( i ) - '0' ) ; int cnt = pref [ n - 1 ] ; int ans = cnt ; for ( int i = 0 ; i < n - K ; i ++ ) { int value = pref [ i + K - 1 ] - ( i - 1 >= 0 ? pref [ i - 1 ] : 0 ) ; ans = Math . min ( ans , cnt - value + ( K - value ) ) ; } return ans ; }
Ref: 
def minimumHammingDistance ( S , K ) : NEW_LINE INDENT n = len ( S ) NEW_LINE pref = [ 0 ] * n NEW_LINE pref [ 0 ] = ord ( S [ 0 ] ) - ord ( '0' ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT pref [ i ] = pref [ i - 1 ] + ( ord ( S [ i ] ) - ord ( '0' ) ) NEW_LINE DEDENT cnt = pref [ n - 1 ] NEW_LINE ans = cnt NEW_LINE for i in range ( n - K ) : NEW_LINE INDENT value = pref [ i + K - 1 ] - ( pref [ i - 1 ] if ( i - 1 ) >= 0 else 0 ) NEW_LINE ans = min ( ans , cnt - value + ( K - value ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
Hyp: 
def minimumHammingDistance ( S , K ) : NEW_LINE INDENT n = len ( S ) NEW_LINE pref = [ 0 ] * n NEW_LINE pref [ 0 ] = ord ( S [ 0 ] ) - ord ( '0' ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT pref [ i ] = pref [ i - 1 ] + ( S [ i ] ) - ord ( '0' ) NEW_LINE DEDENT cnt = pref [ n - 1 ] NEW_LINE ans = cnt NEW_LINE for i in range ( n - K ) : NEW_LINE INDENT value = pref [ i + K - 1 ] - ( i - 1 >= 0 ? pref [ i - 1 ] : 0 ) NEW_LINE ans = min ( ans , cnt - value + ( K - value ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT

BLEU: 91.41
Edit Sim: 31


Src: 
void printSeries ( int N ) { int ith_term = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { ith_term = ( 13 * i * ( i - 1 ) ) / 2 + 2 ; System . out . print ( ith_term + " , ▁ " ) ; } }
Ref: 
def printSeries ( N ) : NEW_LINE INDENT ith_term = 0 ; NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT ith_term = ( 13 * i * ( i - 1 ) ) / 2 + 2 ; NEW_LINE print ( int ( ith_term ) , " , ▁ " , end = " " ) ; NEW_LINE DEDENT DEDENT
Hyp: 
def printSeries ( N ) : NEW_LINE INDENT ith_term = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT ith_term = ( 13 * i * ( i - 1 ) ) // 2 + 2 NEW_LINE print ( ith_term , end = " , ▁ " ) NEW_LINE DEDENT DEDENT

BLEU: 69.23
Edit Sim: 26


Src: 
int minStartValue ( int [ ] nums ) { int minValue = 0 ; int sum = 0 ; for ( int n : nums ) { sum += n ; minValue = Math . min ( minValue , sum ) ; } int startValue = 1 - minValue ; return startValue ; }
Ref: 
def minStartValue ( nums ) : NEW_LINE INDENT minValue = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( len ( nums ) ) : NEW_LINE INDENT sum += nums [ i ] NEW_LINE minValue = min ( minValue , sum ) NEW_LINE DEDENT startValue = 1 - minValue NEW_LINE return startValue NEW_LINE DEDENT
Hyp: 
def minStartValue ( nums ) : NEW_LINE INDENT minValue = 0 NEW_LINE sum = 0 NEW_LINE for n in nums : NEW_LINE INDENT sum += n NEW_LINE minValue = min ( minValue , sum ) NEW_LINE DEDENT startValue = 1 - minValue NEW_LINE return startValue NEW_LINE DEDENT

BLEU: 70.69
Edit Sim: 28


Src: 
int calculateWays ( int arr1 [ ] , int arr2 [ ] , int N ) { int A = arr2 [ 0 ] , B = arr2 [ 1 ] ; int C = arr2 [ 2 ] , D = arr2 [ 3 ] ; int ans = 0 ; for ( int b = 0 ; b <= B && b * 5 <= ( N ) ; b ++ ) for ( int c = 0 ; c <= C && b * 5 + c * 10 <= ( N ) ; c ++ ) for ( int d = 0 ; d <= D && b * 5 + c * 10 + d * 20 <= ( N ) ; d ++ ) if ( ( b * 5 ) + ( c * 10 ) + ( d * 20 ) >= ( N - A ) ) ans ++ ; return ans ; }
Ref: 
def calculateWays ( arr1 , arr2 , N ) : NEW_LINE INDENT A = arr2 [ 0 ] NEW_LINE B = arr2 [ 1 ] NEW_LINE C = arr2 [ 2 ] NEW_LINE D = arr2 [ 3 ] NEW_LINE ans , b , c , d = 0 , 0 , 0 , 0 NEW_LINE while b <= B and b * 5 <= ( N ) : NEW_LINE INDENT c = 0 NEW_LINE while ( c <= C and b * 5 + c * 10 <= ( N ) ) : NEW_LINE INDENT d = 0 NEW_LINE while ( d <= D and b * 5 + c * 10 + d * 20 <= ( N ) ) : NEW_LINE INDENT if ( ( b * 5 ) + ( c * 10 ) + ( d * 20 ) >= ( N - A ) ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT d += 1 NEW_LINE DEDENT c += 1 NEW_LINE DEDENT b += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
Hyp: 
def calculateWays ( arr1 , arr2 , N ) : NEW_LINE INDENT A = arr2 [ 0 ] NEW_LINE B = arr2 [ 1 ] NEW_LINE C = arr2 [ 2 ] NEW_LINE D = arr2 [ 3 ] NEW_LINE ans = 0 NEW_LINE for b in range ( B + 1 ) : NEW_LINE INDENT for c in range ( C + 1 , N ) : NEW_LINE INDENT for d in range ( b * 5 + c * 10 + d * 20 <= ( N ) ) : NEW_LINE INDENT if ( ( b * 5 ) + ( c * 10 + d * 20 <= ( N ) ) : NEW_LINE INDENT if ( ( b * 5 ) + ( c * 10 ) + ( d * 20 ) >= ( N - A ) ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT

BLEU: 63.39
Edit Sim: 163


Src: 
int nthSquareCube ( int n ) { return n * n * n * n * n * n ; }
Ref: 
def nthSquareCube ( n ) : NEW_LINE INDENT return n * n * n * n * n * n NEW_LINE DEDENT
Hyp: 
def nthSquareCube ( n ) : NEW_LINE INDENT return n * n * n * n * n ; NEW_LINE DEDENT

BLEU: 84.55
Edit Sim: 3


Src: 
boolean is_linear ( String s ) { int tmp = 0 ; char first = s . charAt ( 0 ) ; for ( int pos = 0 ; pos < s . length ( ) ; pos += tmp ) { if ( s . charAt ( pos ) != first ) { return false ; } tmp ++ ; } return true ; }
Ref: 
def is_linear ( s ) : NEW_LINE INDENT tmp = 0 NEW_LINE first = s [ 0 ] NEW_LINE pos = 0 NEW_LINE while pos < len ( s ) : NEW_LINE INDENT if ( s [ pos ] != first ) : NEW_LINE INDENT return False NEW_LINE DEDENT tmp += 1 NEW_LINE pos += tmp NEW_LINE DEDENT return True NEW_LINE DEDENT
Hyp: 
def is_linear ( s ) : NEW_LINE INDENT tmp = 0 NEW_LINE first = s [ 0 ] NEW_LINE for pos in range ( 1 , len ( s ) ) : NEW_LINE INDENT if ( s [ pos ] != first ) : NEW_LINE INDENT return False NEW_LINE DEDENT tmp += 1 NEW_LINE DEDENT return True NEW_LINE DEDENT s = " aba " NEW_LINE if ( is_linear ( s ) ) : NEW_LINE INDENT print ( " aba " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " aba " ) NEW_LINE DEDENT

BLEU: 51.04
Edit Sim: 169


Src: 
int linearCheck ( int ar [ ] [ ] , int arr [ ] ) { for ( int i = 0 ; i < m ; i ++ ) { boolean matched = true ; for ( int j = 0 ; j < n ; j ++ ) { if ( ar [ i ] [ j ] != arr [ j ] ) { matched = false ; break ; } } if ( matched ) return i + 1 ; } return - 1 ; }
Ref: 
def linearCheck ( ar , arr ) : NEW_LINE INDENT for i in range ( m ) : NEW_LINE INDENT matched = True ; NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( ar [ i ] [ j ] != arr [ j ] ) : NEW_LINE INDENT matched = False ; NEW_LINE break ; NEW_LINE DEDENT DEDENT if ( matched ) : NEW_LINE INDENT return i + 1 ; NEW_LINE DEDENT DEDENT return - 1 ; NEW_LINE DEDENT
Hyp: 
def linearCheck ( ar , arr ) : NEW_LINE INDENT for i in range ( m ) : NEW_LINE INDENT matched = True NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( ar [ i ] [ j ] != arr [ j ] ) : NEW_LINE INDENT matched = False NEW_LINE break NEW_LINE DEDENT DEDENT if ( matched ) : NEW_LINE INDENT return i + 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT

BLEU: 85.2
Edit Sim: 10


Src: 
boolean canFormPalindrome ( String a ) { int bitvector = 0 , mask = 0 ; for ( int i = 0 ; i < a . length ( ) ; i ++ ) { int x = a . charAt ( i ) - ' a ' ; mask = 1 << x ; bitvector = bitvector ^ mask ; } return ( bitvector & ( bitvector - 1 ) ) == 0 ; }
Ref: 
def canFormPalindrome ( s ) : NEW_LINE INDENT bitvector = 0 NEW_LINE for str in s : NEW_LINE INDENT bitvector ^= 1 << ord ( str ) NEW_LINE DEDENT return bitvector == 0 or bitvector & ( bitvector - 1 ) == 0 NEW_LINE DEDENT if canFormPalindrome ( " geeksforgeeks " ) : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT
Hyp: 
def canFormPalindrome ( a ) : NEW_LINE INDENT bitvector = 0 NEW_LINE mask = 0 NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT x = ord ( a [ i ] ) - ord ( ' a ' ) NEW_LINE mask = 1 << x NEW_LINE bitvector = bitvector ^ mask NEW_LINE DEDENT return ( bitvector & ( bitvector - 1 ) ) == 0 NEW_LINE DEDENT a = " abujm ▁ gijkle ▁ m ▁ n ▁ o ▁ p ▁ pafqrstuvwxyzfap " NEW_LINE if ( canFormPalindrome ( a ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT

BLEU: 32.07
Edit Sim: 205


Src: 
void countOfPairs ( int x , int y ) { int count = 0 ; for ( int k = 1 ; k * k <= x ; ++ k ) { count += Math . max ( 0 , Math . min ( y , x / k - 1 ) - k ) ; } System . out . print ( count ) ; }
Ref: 
def countOfPairs ( x , y ) : NEW_LINE INDENT count = 0 NEW_LINE for k in range ( 1 , int ( sqrt ( x ) ) + 1 , 1 ) : NEW_LINE INDENT count += max ( 0 , min ( y , x / k - 1 ) - k ) NEW_LINE DEDENT print ( int ( count ) ) NEW_LINE DEDENT
Hyp: 
def countOfPairs ( x , y ) : NEW_LINE INDENT count = 0 NEW_LINE for k in range ( 1 , x ) : NEW_LINE INDENT count += max ( 0 , min ( y , x // k - 1 ) - k ) NEW_LINE DEDENT print ( count ) NEW_LINE DEDENT

BLEU: 68.84
Edit Sim: 34


Src: 
boolean pairExists ( int [ ] arr1 , int m , int [ ] arr2 , int n ) { Set < Integer > s = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( s . contains ( arr2 [ j ] - arr1 [ i ] ) ) return true ; } s . add ( arr1 [ i ] ) ; } return false ; }
Ref: 
def pairExists ( arr1 : List [ int ] , m : int , arr2 : List [ int ] , n : int ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( arr2 [ 2 ] - arr1 [ 2 ] ) not in s : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT s . add ( arr1 [ i ] ) NEW_LINE DEDENT return False NEW_LINE DEDENT
Hyp: 
def pairExists ( arr1 , m , arr2 , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if arr2 [ j ] - arr1 [ i ] in s : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT s . add ( arr1 [ i ] ) NEW_LINE DEDENT return False NEW_LINE DEDENT arr1 = [ 1 , 3 , 4 , 8 , 9 , 10 ] NEW_LINE n = len ( arr2 ) NEW_LINE if pairExists ( arr1 , m , arr2 , n ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT

BLEU: 48.06
Edit Sim: 267


Src: 
void checkDistribution ( int R , int B , int D ) { if ( Math . max ( R , B ) <= Math . min ( R , B ) * ( D + 1 ) ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } }
Ref: 
def checkDistribution ( R , B , D ) : NEW_LINE INDENT if ( max ( R , B ) <= min ( R , B ) * ( D + 1 ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
Hyp: 
def checkDistribution ( R , B , D ) : NEW_LINE INDENT if ( max ( R , B ) <= min ( R , B ) * ( D + 1 ) ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT DEDENT

BLEU: 91.44
Edit Sim: 4


Src: 
int maxMinDifference ( int arr [ ] , int n , int k ) { if ( k >= n - 1 ) return 0 ; Arrays . sort ( arr ) ; int ans = arr [ n - 1 ] - arr [ 0 ] ; for ( int i = k , j = n - 1 ; i >= 0 ; -- i , -- j ) { ans = Math . min ( arr [ j ] - arr [ i ] , ans ) ; } return ans ; }
Ref: 
def maxMinDifference ( arr , n , k ) : NEW_LINE INDENT if ( k >= n - 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT arr . sort ( ) NEW_LINE ans = arr [ n - 1 ] - arr [ 0 ] NEW_LINE i = k NEW_LINE j = n - 1 NEW_LINE while i >= 0 : NEW_LINE INDENT ans = min ( arr [ j ] - arr [ i ] , ans ) NEW_LINE i -= 1 NEW_LINE j -= 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
Hyp: 
def maxMinDifference ( arr , n , k ) : NEW_LINE INDENT if ( k >= n - 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT arr . sort ( ) NEW_LINE ans = arr [ n - 1 ] - arr [ 0 ] NEW_LINE for i in range ( k , n - 1 ) : NEW_LINE INDENT ans = min ( arr [ j ] - arr [ i ] , ans ) NEW_LINE DEDENT return ans NEW_LINE DEDENT

BLEU: 75.48
Edit Sim: 68


Src: 
void rangeSum ( int arr [ ] , int N , int L , int R ) { int sum = 0 ; for ( int i = L - 1 ; i < R ; i ++ ) { sum += arr [ i % N ] ; } System . out . println ( sum ) ; }
Ref: 
def rangeSum ( arr , N , L , R ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( L - 1 , R , 1 ) : NEW_LINE INDENT sum += arr [ i % N ] NEW_LINE DEDENT print ( sum ) NEW_LINE DEDENT
Hyp: 
def rangeSum ( arr , N , L , R ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( L - 1 , R + 1 ) : NEW_LINE INDENT sum += arr [ i % N ] NEW_LINE DEDENT print ( sum ) NEW_LINE DEDENT

BLEU: 94.87
Edit Sim: 1


Src: 
void smallerNumbers ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < N ; j ++ ) { if ( arr [ j ] < arr [ i ] ) { count ++ ; } } System . out . print ( count + " ▁ " ) ; } }
Ref: 
def smallerNumbers ( arr , N ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( N ) : NEW_LINE INDENT if ( arr [ j ] < arr [ i ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count , end = " ▁ " ) NEW_LINE DEDENT DEDENT
Hyp: 
def smallerNumbers ( arr , N ) : NEW_LINE INDENT for i in range ( 0 , N ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( 0 , N ) : NEW_LINE INDENT if ( arr [ j ] < arr [ i ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count , end = " ▁ " ) NEW_LINE DEDENT DEDENT

BLEU: 90.1
Edit Sim: 8


Src: 
boolean checkIfDivisible ( String str , long num ) { long powerOf2 = ( int ) ( Math . log ( num ) / Math . log ( 2 ) ) ; if ( str . length ( ) < powerOf2 ) return false ; if ( powerOf2 == 0 ) return true ; long i , number = 0 ; int len = str . length ( ) ; for ( i = len - powerOf2 ; i < len ; i ++ ) { number += ( str . charAt ( ( int ) i ) - '0' ) * Math . pow ( 10 , powerOf2 - 1 ) ; powerOf2 -- ; } if ( number % num != 0 ) return false ; else return true ; }
Ref: 
def checkIfDivisible ( string , num ) : NEW_LINE INDENT powerOf2 = int ( log2 ( num ) ) ; NEW_LINE if ( len ( string ) < powerOf2 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT if ( powerOf2 == 0 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT number = 0 ; NEW_LINE length = len ( string ) ; NEW_LINE for i in range ( length - powerOf2 , length ) : NEW_LINE INDENT number += ( ( ord ( string [ i ] ) - ord ( '0' ) ) * ( 10 ** ( powerOf2 - 1 ) ) ) ; NEW_LINE powerOf2 -= 1 ; NEW_LINE DEDENT if ( number % num ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT else : NEW_LINE INDENT return True ; NEW_LINE DEDENT DEDENT
Hyp: 
def checkIfDivisible ( str , num ) : NEW_LINE INDENT powerOf2 = int ( log2 ( num ) ) NEW_LINE if ( len ( str ) < powerOf2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( powerOf2 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT number = 0 NEW_LINE len1 = len ( str ) NEW_LINE for i in range ( len1 - powerOf2 , len1 ) : NEW_LINE INDENT number += ord ( str [ i ] ) - ord ( '0' ) * pow ( 10 , powerOf2 - 1 ) NEW_LINE powerOf2 -= 1 NEW_LINE DEDENT if ( number % num != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT

BLEU: 60.59
Edit Sim: 60


Src: 
void anglechordtang ( int z ) { System . out . print ( " The ▁ angle ▁ between ▁ tangent " + " ▁ and ▁ the ▁ chord ▁ is ▁ " + z + " ▁ degrees " ) ; }
Ref: 
def anglechordtang ( z ) : NEW_LINE INDENT print ( " The ▁ angle ▁ between ▁ tangent " , " and ▁ the ▁ chord ▁ is " , z , " degrees " ) ; NEW_LINE DEDENT
Hyp: 
def anglechordtang ( z ) : NEW_LINE INDENT print ( " The ▁ angle ▁ between ▁ tangent " , " ▁ and ▁ the ▁ chord ▁ is " , z , " ▁ degrees " ) NEW_LINE DEDENT

BLEU: 83.56
Edit Sim: 6


Src: 
int minimumSets ( String s , int y ) { int cnt = 0 ; int num = 0 ; int l = s . length ( ) ; boolean f = false ; for ( int i = 0 ; i < l ; i ++ ) { num = num * 10 + ( s . charAt ( i ) - '0' ) ; if ( num <= y ) f = true ; { if ( f ) cnt += 1 ; num = s . charAt ( i ) - '0' ; f = false ; if ( num <= y ) f = true ; else num = 0 ; } } if ( f == true ) cnt += 1 ; return cnt ; }
Ref: 
def minimumSets ( s , y ) : NEW_LINE INDENT cnt = 0 NEW_LINE num = 0 NEW_LINE l = len ( s ) NEW_LINE f = 0 NEW_LINE for i in range ( l ) : NEW_LINE INDENT num = num * 10 + ( ord ( s [ i ] ) - ord ( '0' ) ) NEW_LINE if ( num <= y ) : NEW_LINE INDENT f = 1 NEW_LINE if ( f ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT num = ord ( s [ i ] ) - ord ( '0' ) NEW_LINE f = 0 NEW_LINE if ( num <= y ) : NEW_LINE INDENT f = 1 NEW_LINE DEDENT else : NEW_LINE INDENT num = 0 NEW_LINE DEDENT DEDENT DEDENT if ( f ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT return cnt NEW_LINE DEDENT
Hyp: 
def minimumSets ( s , y ) : NEW_LINE INDENT cnt = 0 NEW_LINE num = 0 NEW_LINE l = len ( s ) NEW_LINE f = False NEW_LINE for i in range ( 0 , l ) : NEW_LINE INDENT num = num * 10 + ( ord ( s [ i ] ) - ord ( '0' ) ) NEW_LINE if ( num <= y ) : NEW_LINE INDENT f = True NEW_LINE DEDENT else : NEW_LINE INDENT num = 0 NEW_LINE DEDENT DEDENT if ( f == True ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT return cnt NEW_LINE DEDENT

BLEU: 59.47
Edit Sim: 180


Src: 
boolean checkRectangles ( int [ ] arr , int n ) { boolean ans = true ; Arrays . sort ( arr ) ; int area = arr [ 0 ] * arr [ 4 * n - 1 ] ; for ( int i = 0 ; i < 2 * n ; i = i + 2 ) { if ( arr [ i ] != arr [ i + 1 ] arr [ 4 * n - i - 1 ] != arr [ 4 * n - i - 2 ] arr [ i ] * arr [ 4 * n - i - 1 ] != area ) { ans = false ; break ; } } if ( ans ) return true ; return false ; }
Ref: 
def checkRectangles ( arr , n ) : NEW_LINE INDENT ans = True NEW_LINE arr . sort ( ) NEW_LINE area = arr [ 0 ] * arr [ 4 * n - 1 ] NEW_LINE for i in range ( 0 , 2 * n , 2 ) : NEW_LINE INDENT if ( arr [ i ] != arr [ i + 1 ] or arr [ 4 * n - i - 1 ] != arr [ 4 * n - i - 2 ] or arr [ i ] * arr [ 4 * n - i - 1 ] != area ) : NEW_LINE INDENT ans = False NEW_LINE break NEW_LINE DEDENT DEDENT if ( ans ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT arr = [ 1 , 8 , 2 , 1 , 2 , 4 , 4 , 8 ] NEW_LINE n = 2 NEW_LINE if ( checkRectangles ( arr , n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
Hyp: 
def checkRectangles ( arr , n ) : NEW_LINE INDENT ans = True NEW_LINE arr . sort ( ) NEW_LINE area = arr [ 0 ] * arr [ 4 * n - 1 ] NEW_LINE for i in range ( 2 * n ) : NEW_LINE INDENT if ( arr [ i ] != arr [ i + 1 ] or arr [ 4 * n - i - 1 ] != arr [ 4 * n - i - 2 ] ) : NEW_LINE INDENT ans = False NEW_LINE break NEW_LINE DEDENT DEDENT if ans : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT

BLEU: 44.72
Edit Sim: 264


Src: 
int countRabbits ( int Heads , int Legs ) { int count = 0 ; count = ( Legs ) - 2 * ( Heads ) ; count = count / 2 ; return count ; }
Ref: 
def countRabbits ( Heads , Legs ) : NEW_LINE INDENT count = 0 NEW_LINE count = ( Legs ) - 2 * ( Heads ) NEW_LINE count = count / 2 NEW_LINE return count NEW_LINE DEDENT
Hyp: 
def countRabbits ( Heads , Legs ) : NEW_LINE INDENT count = 0 NEW_LINE count = ( Legs ) - 2 * ( Heads ) NEW_LINE count = count // 2 NEW_LINE return count NEW_LINE DEDENT

BLEU: 92.79
Edit Sim: 1


Src: 
int get_last_two_digit ( long N ) { if ( N <= 10 ) { long ans = 0 , fac = 1 ; for ( int i = 1 ; i <= N ; i ++ ) { fac = fac * i ; ans += fac ; } return ( int ) ans % 100 ; } return 13 ; }
Ref: 
def get_last_two_digit ( N ) : NEW_LINE INDENT if N <= 10 : NEW_LINE INDENT ans = 0 NEW_LINE fac = 1 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT fac = fac * i NEW_LINE ans += fac NEW_LINE DEDENT ans = ans % 100 NEW_LINE return ans NEW_LINE DEDENT else : NEW_LINE INDENT return 13 NEW_LINE DEDENT DEDENT N = 1 NEW_LINE for N in range ( 1 , 11 ) : NEW_LINE INDENT print ( " For ▁ N ▁ = ▁ " , N , " : ▁ " , get_last_two_digit ( N ) , sep = ' ▁ ' ) NEW_LINE DEDENT
Hyp: 
def get_last_two_digit ( N ) : NEW_LINE INDENT if ( N <= 10 ) : NEW_LINE INDENT ans = 0 NEW_LINE fac = 1 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT fac = fac * i NEW_LINE ans += fac NEW_LINE DEDENT return int ( ans % 100 ) NEW_LINE DEDENT

BLEU: 33.01
Edit Sim: 234


Src: 
int maxBalancedStr ( String s ) { int open1 = 0 , close1 = 0 ; int open2 = 0 , close2 = 0 ; int open3 = 0 , close3 = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { switch ( s . charAt ( i ) ) { case ' ( ' : open1 ++ ; break ; case ' ) ' : close1 ++ ; break ; case ' { ' : open2 ++ ; break ; case ' } ' : close2 ++ ; break ; case ' [ ' : open3 ++ ; break ; case ' ] ' : close3 ++ ; break ; } } int maxLen = 2 * Math . min ( open1 , close1 ) + 2 * Math . min ( open2 , close2 ) + 2 * Math . min ( open3 , close3 ) ; return maxLen ; }
Ref: 
def maxBalancedStr ( s ) : NEW_LINE INDENT open1 = 0 NEW_LINE close1 = 0 NEW_LINE open2 = 0 NEW_LINE close2 = 0 NEW_LINE open3 = 0 NEW_LINE close3 = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == ' ( ' ) : open1 += 1 continue if s [ i ] == ' ) ' : NEW_LINE INDENT close1 += 1 NEW_LINE continue NEW_LINE DEDENT if s [ i ] == ' { ' : NEW_LINE INDENT open2 += 1 NEW_LINE continue NEW_LINE DEDENT if s [ i ] == ' } ' : NEW_LINE INDENT close2 += 1 NEW_LINE continue NEW_LINE DEDENT if s [ i ] == ' [ ' : NEW_LINE INDENT open3 += 1 NEW_LINE continue NEW_LINE DEDENT if s [ i ] == ' ] ' : NEW_LINE INDENT close3 += 1 NEW_LINE continue NEW_LINE DEDENT DEDENT maxLen = ( 2 * min ( open1 , close1 ) + 2 * min ( open2 , close2 ) + 2 * min ( open3 , close3 ) ) NEW_LINE return maxLen NEW_LINE DEDENT
Hyp: 
def maxBalancedStr ( s ) : NEW_LINE INDENT open1 = 0 NEW_LINE close1 = 0 NEW_LINE open2 = 0 NEW_LINE close2 = 0 NEW_LINE open3 = 0 , close3 = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT switch ( s [ i ] ) : NEW_LINE INDENT open1 += 1 NEW_LINE break NEW_LINE DEDENT case ' ( ' : NEW_LINE INDENT close1 += 1 NEW_LINE break NEW_LINE DEDENT case ' ) ' : NEW_LINE INDENT open2 += 1 NEW_LINE break NEW_LINE DEDENT case ' [ ' : NEW_LINE INDENT open3 += 1 NEW_LINE break NEW_LINE DEDENT DEDENT maxLen = 2 * min ( open1 , close1 ) + 2 * min ( open2 , close2 ) + 2 * min ( open3 , close3 ) NEW_LINE return maxLen NEW_LINE DEDENT

BLEU: 53.03
Edit Sim: 225


Src: 
float calculateArea ( float A , float B , float C , float D ) { float S = ( A + B + C + D ) / 2 ; float area = ( float ) Math . sqrt ( ( S - A ) * ( S - B ) * ( S - C ) * ( S - D ) ) ; return area ; }
Ref: 
def calculateArea ( A , B , C , D ) : NEW_LINE INDENT S = ( A + B + C + D ) // 2 NEW_LINE area = sqrt ( ( S - A ) * ( S - B ) * ( S - C ) * ( S - D ) ) NEW_LINE return area NEW_LINE DEDENT
Hyp: 
def calculateArea ( A , B , C , D ) : NEW_LINE INDENT S = ( A + B + C + D ) / 2 NEW_LINE area = math . sqrt ( ( S - A ) * ( S - B ) * ( S - C ) * ( S - D ) ) NEW_LINE return area NEW_LINE DEDENT

BLEU: 90.25
Edit Sim: 8


Src: 
int findNthNumber ( int A , int B , int N ) { int sum = 0 ; for ( int i = 2 ; i < N ; i ++ ) { sum = A + B ; A = B ; B = sum ; } return sum ; }
Ref: 
def findNthNumber ( A , B , N ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 2 , N ) : NEW_LINE INDENT sum = A + B NEW_LINE A = B NEW_LINE B = sum NEW_LINE DEDENT return sum NEW_LINE DEDENT
Hyp: 
def findNthNumber ( A , B , N ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 2 , N ) : NEW_LINE INDENT sum = A + B NEW_LINE A = B NEW_LINE B = sum NEW_LINE DEDENT return sum NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
void binToDecimal3 ( int n ) { int last_3 = ( ( n & 4 ) + ( n & 2 ) + ( n & 1 ) ) ; n = n >> 3 ; while ( n > 7 ) n = n >> 1 ; int first_3 = ( ( n & 4 ) + ( n & 2 ) + ( n & 1 ) ) ; System . out . println ( first_3 + " ▁ " + last_3 ) ; }
Ref: 
def binToDecimal3 ( n ) : NEW_LINE INDENT last_3 = ( ( n & 4 ) + ( n & 2 ) + ( n & 1 ) ) ; NEW_LINE n = n >> 3 NEW_LINE while ( n > 7 ) : NEW_LINE INDENT n = n >> 1 NEW_LINE DEDENT first_3 = ( ( n & 4 ) + ( n & 2 ) + ( n & 1 ) ) NEW_LINE print ( first_3 , last_3 ) NEW_LINE DEDENT
Hyp: 
def binToDecimal3 ( n ) : NEW_LINE INDENT last_3 = ( ( n & 4 ) + ( n & 2 ) + ( n & 1 ) ) NEW_LINE n = n >> 3 NEW_LINE while ( n > 7 ) : NEW_LINE INDENT n = n >> 1 NEW_LINE DEDENT first_3 = ( ( n & 4 ) + ( n & 2 ) + ( n & 1 ) ) NEW_LINE print ( first_3 , last_3 ) NEW_LINE DEDENT

BLEU: 96.94
Edit Sim: 2


Src: 
int floorDifference ( int A [ ] , int N , int X ) { int totalSum = 0 ; int perElementSum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { totalSum += A [ i ] ; perElementSum += A [ i ] / X ; } int totalFloorSum = totalSum / X ; return Math . abs ( totalFloorSum - perElementSum ) ; }
Ref: 
def floorDifference ( A , N , X ) : NEW_LINE INDENT totalSum = 0 NEW_LINE perElementSum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT totalSum += A [ i ] NEW_LINE perElementSum += A [ i ] // X NEW_LINE DEDENT totalFloorSum = totalSum // X NEW_LINE return abs ( totalFloorSum - perElementSum ) NEW_LINE DEDENT
Hyp: 
def floorDifference ( A , N , X ) : NEW_LINE INDENT totalSum = 0 NEW_LINE perElementSum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT totalSum += A [ i ] NEW_LINE perElementSum += A [ i ] // X NEW_LINE DEDENT totalFloorSum = totalSum // X NEW_LINE return abs ( totalFloorSum - perElementSum ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int minimumIncrease ( int a , int b , int c ) { int arr [ ] = { a , b , c } ; Arrays . sort ( arr ) ; if ( arr [ 0 ] + arr [ 1 ] >= arr [ 2 ] ) return 0 ; else return arr [ 2 ] - ( arr [ 0 ] + arr [ 1 ] ) ; }
Ref: 
def minimumIncrease ( a , b , c ) : NEW_LINE INDENT arr = [ a , b , c ] NEW_LINE arr . sort ( ) NEW_LINE if arr [ 0 ] + arr [ 1 ] >= arr [ 2 ] : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return arr [ 2 ] - ( arr [ 0 ] + arr [ 1 ] ) NEW_LINE DEDENT DEDENT
Hyp: 
def minimumIncrease ( a , b , c ) : NEW_LINE INDENT arr = [ a , b , c ] NEW_LINE arr . sort ( ) NEW_LINE if ( arr [ 0 ] + arr [ 1 ] >= arr [ 2 ] ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return arr [ 2 ] - ( arr [ 0 ] + arr [ 1 ] ) NEW_LINE DEDENT DEDENT

BLEU: 93.28
Edit Sim: 4


Src: 
void search ( String pat , String txt ) { int M = pat . length ( ) ; int N = txt . length ( ) ; int i = 0 ; while ( i <= N - M ) { int j ; for ( j = 0 ; j < M ; j ++ ) if ( txt . charAt ( i + j ) != pat . charAt ( j ) ) break ; if ( j == M ) { System . out . println ( " Pattern ▁ found ▁ at ▁ index ▁ " + i ) ; i = i + M ; } else if ( j == 0 ) i = i + 1 ; else i = i + j ; } }
Ref: 
def search ( pat , txt ) : NEW_LINE INDENT M = len ( pat ) NEW_LINE N = len ( txt ) NEW_LINE i = 0 NEW_LINE while i <= N - M : NEW_LINE INDENT for j in xrange ( M ) : NEW_LINE INDENT if txt [ i + j ] != pat [ j ] : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if j == M : NEW_LINE INDENT print " Pattern ▁ found ▁ at ▁ index ▁ " + str ( i ) NEW_LINE i = i + M NEW_LINE DEDENT elif j == 0 : NEW_LINE INDENT i = i + 1 NEW_LINE DEDENT else : NEW_LINE INDENT i = i + j NEW_LINE DEDENT DEDENT DEDENT
Hyp: 
def search ( pat , txt ) : NEW_LINE INDENT M = len ( pat ) NEW_LINE N = len ( txt ) NEW_LINE i = 0 NEW_LINE while ( i <= N - M ) : NEW_LINE INDENT j = 0 NEW_LINE while ( j < M ) : NEW_LINE INDENT if ( txt [ i + j ] != pat [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( j == M ) : NEW_LINE INDENT print ( " Pattern ▁ found ▁ at ▁ index ▁ " , i ) NEW_LINE i = i + M NEW_LINE DEDENT elif ( j == 0 ) : NEW_LINE INDENT i = i + 1 NEW_LINE DEDENT else : NEW_LINE INDENT i = i + j NEW_LINE DEDENT DEDENT DEDENT

BLEU: 73.38
Edit Sim: 62


Src: 
boolean checkEquall ( int arr [ ] , int N ) { int sumEven = 0 , sumOdd = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( i % 2 == 1 ) sumOdd += arr [ i ] ; else sumEven += arr [ i ] ; } if ( sumEven == sumOdd ) return true ; else return false ; }
Ref: 
def checkEquall ( arr , N ) : NEW_LINE INDENT sumEven , sumOdd = 0 , 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( i & 1 ) : NEW_LINE INDENT sumOdd += arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT sumEven += arr [ i ] NEW_LINE DEDENT DEDENT if ( sumEven == sumOdd ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
Hyp: 
def checkEquall ( arr , N ) : NEW_LINE INDENT sumEven = 0 NEW_LINE sumOdd = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( i % 2 == 1 ) : NEW_LINE INDENT sumOdd += arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT sumEven += arr [ i ] NEW_LINE DEDENT DEDENT if ( sumEven == sumOdd ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT

BLEU: 88.18
Edit Sim: 22


Src: 
void sortExceptUandL ( int a [ ] , int l , int u , int n ) { int b [ ] = new int [ n - ( u - l + 1 ) ] ; for ( int i = 0 ; i < l ; i ++ ) b [ i ] = a [ i ] ; for ( int i = u + 1 ; i < n ; i ++ ) b [ l + ( i - ( u + 1 ) ) ] = a [ i ] ; Arrays . sort ( b ) ; for ( int i = 0 ; i < l ; i ++ ) a [ i ] = b [ i ] ; for ( int i = u + 1 ; i < n ; i ++ ) a [ i ] = b [ l + ( i - ( u + 1 ) ) ] ; }
Ref: 
def sortExceptUandL ( a , l , u , n ) : NEW_LINE INDENT b = [ 0 ] * ( n - ( u - l + 1 ) ) NEW_LINE for i in range ( 0 , l ) : NEW_LINE INDENT b [ i ] = a [ i ] NEW_LINE DEDENT for i in range ( u + 1 , n ) : NEW_LINE INDENT b [ l + ( i - ( u + 1 ) ) ] = a [ i ] NEW_LINE DEDENT b . sort ( ) NEW_LINE for i in range ( 0 , l ) : NEW_LINE INDENT a [ i ] = b [ i ] NEW_LINE DEDENT for i in range ( u + 1 , n ) : NEW_LINE INDENT a [ i ] = b [ l + ( i - ( u + 1 ) ) ] NEW_LINE DEDENT DEDENT a = [ 5 , 4 , 3 , 12 , 14 , 9 ] NEW_LINE n = len ( a ) NEW_LINE l = 2 NEW_LINE u = 4 NEW_LINE sortExceptUandL ( a , l , u , n ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( " { } ▁ " . format ( a [ i ] ) , end = " " ) NEW_LINE DEDENT
Hyp: 
def sortExceptUandL ( a , l , u , n ) : NEW_LINE INDENT b = [ 0 ] * ( n - ( u - l + 1 ) ) NEW_LINE for i in range ( l ) : NEW_LINE INDENT b [ i ] = a [ i ] NEW_LINE DEDENT for i in range ( u + 1 , n ) : NEW_LINE INDENT b [ l + ( i - ( u + 1 ) ) ] = a [ i ] NEW_LINE DEDENT b = sorted ( b ) NEW_LINE for i in range ( l ) : NEW_LINE INDENT a [ i ] = b [ i ] NEW_LINE DEDENT for i in range ( u + 1 , n ) : NEW_LINE INDENT a [ i ] = b [ l + ( i - ( u + 1 ) ) ] NEW_LINE DEDENT DEDENT

BLEU: 55.92
Edit Sim: 262


Src: 
boolean checkPronic ( int x ) { for ( int i = 0 ; i <= ( int ) ( Math . sqrt ( x ) ) ; i ++ ) if ( x == i * ( i + 1 ) ) return true ; return false ; }
Ref: 
def checkPronic ( x ) : NEW_LINE INDENT i = 0 NEW_LINE while ( i <= ( int ) ( math . sqrt ( x ) ) ) : NEW_LINE INDENT if ( x == i * ( i + 1 ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT return False NEW_LINE DEDENT i = 0 NEW_LINE while ( i <= 200 ) : NEW_LINE INDENT if checkPronic ( i ) : NEW_LINE INDENT print i , NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT
Hyp: 
def checkPronic ( x ) : NEW_LINE INDENT for i in range ( int ( math . sqrt ( x ) ) + 1 ) : NEW_LINE INDENT if ( x == ( i * ( i + 1 ) ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT

BLEU: 35.34
Edit Sim: 195


Src: 
void solve ( int arr [ ] , int n , int X , int Y ) { int diff = Y - X ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != 1 ) { diff = diff % ( arr [ i ] - 1 ) ; } } if ( diff == 0 ) System . out . print ( " Yes " ) ; else System . out . print ( " No " ) ; }
Ref: 
def solve ( arr , n , X , Y ) : NEW_LINE INDENT diff = Y - X NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] != 1 ) : NEW_LINE INDENT diff = diff % ( arr [ i ] - 1 ) NEW_LINE DEDENT DEDENT if ( diff == 0 ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
Hyp: 
def solve ( arr , n , X , Y ) : NEW_LINE INDENT diff = Y - X NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] != 1 ) : NEW_LINE INDENT diff = diff % ( arr [ i ] - 1 ) NEW_LINE DEDENT DEDENT if ( diff == 0 ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
void check ( int n ) { HashSet < Integer > digits = new HashSet < Integer > ( ) ; int temp = n ; int sum = 0 ; int count = 0 ; while ( temp > 0 ) { sum += temp % 10 ; digits . add ( temp % 10 ) ; count ++ ; temp = temp / 10 ; } if ( sum % count == 0 && digits . contains ( sum / count ) ) System . out . print ( " Yes " + "NEW_LINE"); else System . out . print ( " No " + "NEW_LINE"); }
Ref: 
def check ( n ) : NEW_LINE INDENT digits = set ( ) NEW_LINE temp = n NEW_LINE Sum = 0 NEW_LINE count = 0 NEW_LINE while ( temp > 0 ) : NEW_LINE INDENT Sum += temp % 10 NEW_LINE digits . add ( temp % 10 ) NEW_LINE count += 1 NEW_LINE temp = temp // 10 NEW_LINE DEDENT if ( ( Sum % count == 0 ) and ( ( int ) ( Sum / count ) in digits ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
Hyp: 
def check ( n ) : NEW_LINE INDENT digits = set ( ) NEW_LINE temp = n NEW_LINE sum = 0 NEW_LINE count = 0 NEW_LINE while ( temp > 0 ) : NEW_LINE INDENT sum += temp % 10 NEW_LINE digits . add ( temp % 10 ) NEW_LINE count += 1 NEW_LINE temp = temp // 10 NEW_LINE DEDENT if ( sum % count == 0 and digits [ sum // count ] ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT

BLEU: 77.93
Edit Sim: 30


Src: 
int findS ( int s ) { int l = 1 , r = ( s / 2 ) + 1 ; while ( l <= r ) { int mid = ( l + r ) / 2 ; int sum = mid * ( mid + 1 ) / 2 ; if ( sum == s ) return mid ; else if ( sum > s ) r = mid - 1 ; else l = mid + 1 ; } return - 1 ; }
Ref: 
def findS ( s ) : NEW_LINE INDENT l = 1 NEW_LINE r = int ( s / 2 ) + 1 NEW_LINE while ( l <= r ) : NEW_LINE INDENT mid = int ( ( l + r ) / 2 ) NEW_LINE sum = int ( mid * ( mid + 1 ) / 2 ) NEW_LINE if ( sum == s ) : NEW_LINE INDENT return mid NEW_LINE DEDENT elif ( sum > s ) : NEW_LINE INDENT r = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT s = 15 NEW_LINE n = findS ( s ) NEW_LINE if ( n == - 1 ) : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT
Hyp: 
def findS ( s ) : NEW_LINE INDENT l = 1 NEW_LINE r = ( s // 2 ) + 1 NEW_LINE while ( l <= r ) : NEW_LINE INDENT mid = ( l + r ) // 2 NEW_LINE sum = mid * ( mid + 1 ) / 2 NEW_LINE if ( sum == s ) : NEW_LINE INDENT return mid NEW_LINE DEDENT elif ( sum > s ) : NEW_LINE INDENT r = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT

BLEU: 55.28
Edit Sim: 181


Src: 
void string ( int l , int x , int y ) { int p = 97 ; for ( int j = 0 ; j < l ; j ++ ) { char ans = ( char ) ( p + ( j % y ) ) ; System . out . print ( ans ) ; } }
Ref: 
def String ( l , x , y ) : NEW_LINE INDENT p = 97 NEW_LINE for j in range ( l ) : NEW_LINE INDENT ans = chr ( p + j % y ) NEW_LINE print ( ans , end = " " ) NEW_LINE DEDENT DEDENT
Hyp: 
def string ( l , x , y ) : NEW_LINE INDENT p = 97 NEW_LINE for j in range ( l ) : NEW_LINE INDENT ans = ( p + ( j % y ) ) NEW_LINE print ( ans ) NEW_LINE DEDENT DEDENT

BLEU: 72.09
Edit Sim: 21


Src: 
void prevGreater ( int arr [ ] , int n ) { Stack < Integer > s = new Stack < Integer > ( ) ; s . push ( arr [ 0 ] ) ; System . out . print ( " - 1 , ▁ " ) ; for ( int i = 1 ; i < n ; i ++ ) { while ( s . empty ( ) == false && s . peek ( ) < arr [ i ] ) s . pop ( ) ; if ( s . empty ( ) == true ) System . out . print ( " - 1 , ▁ " ) ; else System . out . print ( s . peek ( ) + " , ▁ " ) ; s . push ( arr [ i ] ) ; } }
Ref: 
def prevGreater ( arr , n ) : NEW_LINE INDENT s = list ( ) ; NEW_LINE s . append ( arr [ 0 ] ) NEW_LINE print ( " - 1 , ▁ " , end = " " ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT while ( len ( s ) > 0 and s [ - 1 ] < arr [ i ] ) : NEW_LINE INDENT s . pop ( ) NEW_LINE DEDENT if len ( s ) == 0 : NEW_LINE INDENT print ( " - 1 , ▁ " , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( s [ - 1 ] , " , ▁ " , end = " " ) NEW_LINE DEDENT s . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT
Hyp: 
def prevGreater ( arr , n ) : NEW_LINE INDENT s = [ ] NEW_LINE s . append ( arr [ 0 ] ) NEW_LINE print ( " - 1" , end = " , ▁ " ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT while len ( s ) > 0 and len ( s ) < arr [ i ] : NEW_LINE INDENT s . pop ( ) NEW_LINE DEDENT if ( s . empty ( ) == True ) : NEW_LINE INDENT print ( " - 1" , end = " , ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( s . peek ( ) , end = " , ▁ " ) NEW_LINE DEDENT DEDENT s . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT

BLEU: 70.75
Edit Sim: 78


Src: 
char bs ( char ar [ ] , int n , int ele ) { int start = 0 ; int end = n - 1 ; char ch = ' @ ' ; while ( start <= end ) { int mid = start + ( end - start ) / 2 ; if ( ar [ mid ] == ele ) end = mid - 1 ; else if ( ar [ mid ] < ele ) { ch = ar [ mid ] ; start = mid + 1 ; } else end = mid - 1 ; } return ch ; }
Ref: 
def bs ( a , n , ele ) : NEW_LINE INDENT start = 0 NEW_LINE end = n - 1 NEW_LINE ch = ' @ ' NEW_LINE while ( start <= end ) : NEW_LINE INDENT mid = start + ( end - start ) // 2 ; NEW_LINE if ( ar [ mid ] == ele ) : NEW_LINE INDENT end = mid - 1 NEW_LINE DEDENT elif ( ar [ mid ] < ele ) : NEW_LINE INDENT ch = ar [ mid ] NEW_LINE start = mid + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT end = mid - 1 ; NEW_LINE DEDENT DEDENT return ch NEW_LINE DEDENT
Hyp: 
def bs ( ar , n , ele ) : NEW_LINE INDENT start = 0 NEW_LINE end = n - 1 NEW_LINE ch = ' @ ' NEW_LINE while start <= end : NEW_LINE INDENT mid = start + ( ( end - start ) // 2 ) NEW_LINE if ar [ mid ] == ele : NEW_LINE INDENT end = mid - 1 NEW_LINE DEDENT elif ar [ mid ] < ele : NEW_LINE INDENT ch = ar [ mid ] NEW_LINE start = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT end = mid - 1 NEW_LINE DEDENT DEDENT return ch NEW_LINE DEDENT

BLEU: 76.93
Edit Sim: 20


Src: 
int findCountOfPairs ( int a , int b , int n ) { int ans = 0 ; for ( int i = 1 ; i <= a ; i ++ ) { ans += b / n ; ans += ( i % n + b % n ) >= n ? 1 : 0 ; } return ans ; }
Ref: 
def findCountOfPairs ( a , b , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , a + 1 ) : NEW_LINE INDENT ans += b // n NEW_LINE ans += 1 if ( i % n + b % n ) >= n else 0 NEW_LINE DEDENT return ans NEW_LINE DEDENT
Hyp: 
def findCountOfPairs ( a , b , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , a + 1 ) : NEW_LINE INDENT ans += b // n NEW_LINE ans += ( i % n + b % n ) >= n ? 1 : 0 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT

BLEU: 87.09
Edit Sim: 17


Src: 
float hexagonside ( float a ) { if ( a < 0 ) return - 1 ; float x = a / 3 ; return x ; }
Ref: 
def hexagonside ( a ) : NEW_LINE INDENT if a < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT x = a // 3 NEW_LINE return x NEW_LINE DEDENT
Hyp: 
def hexagonside ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT x = a / 3 NEW_LINE return x NEW_LINE DEDENT

BLEU: 74.89
Edit Sim: 5


Src: 
double nDigitPerfectSquares ( int n , int b ) { double largest = Math . pow ( Math . ceil ( Math . sqrt ( Math . pow ( b , n ) ) ) - 1 , 2 ) ; return largest ; }
Ref: 
def nDigitPerfectSquares ( n , b ) : NEW_LINE INDENT largest = pow ( math . ceil ( math . sqrt ( pow ( b , n ) ) ) - 1 , 2 ) NEW_LINE print ( largest ) NEW_LINE DEDENT
Hyp: 
def nDigitPerfectSquares ( n , b ) : NEW_LINE INDENT largest = pow ( math . ceil ( math . sqrt ( pow ( b , n ) ) ) - 1 , 2 ) ) NEW_LINE return largest NEW_LINE DEDENT

BLEU: 87.07
Edit Sim: 10


Src: 
int countRect ( int n ) { int ans = 0 ; for ( int length = 1 ; length <= Math . sqrt ( n ) ; ++ length ) for ( int height = length ; height * length <= n ; ++ height ) ans ++ ; return ans ; }
Ref: 
def countRect ( n ) : NEW_LINE INDENT ans = 0 NEW_LINE for length in range ( 1 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT height = length NEW_LINE while ( height * length <= n ) : NEW_LINE INDENT ans += 1 NEW_LINE height += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
Hyp: 
def countRect ( n ) : NEW_LINE INDENT ans = 0 NEW_LINE for length in range ( 1 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT for height in range ( length , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT

BLEU: 72.26
Edit Sim: 62


Src: 
int countSwaps ( int arr [ ] , int n ) { HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; int max_frequency = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . containsKey ( arr [ i ] ) ) { mp . put ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } else { mp . put ( arr [ i ] , 1 ) ; } max_frequency = Math . max ( max_frequency , mp . get ( arr [ i ] ) ) ; } return n - max_frequency ; }
Ref: 
def countSwaps ( A , n ) : NEW_LINE INDENT mp = { } NEW_LINE max_frequency = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if A [ i ] in mp : NEW_LINE INDENT mp [ A [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ A [ i ] ] = 1 NEW_LINE DEDENT max_frequency = max ( max_frequency , mp [ A [ i ] ] ) NEW_LINE DEDENT return n - max_frequency NEW_LINE DEDENT
Hyp: 
def countSwaps ( arr , n ) : NEW_LINE INDENT mp = defaultdict ( int ) NEW_LINE max_frequency = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] in mp : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ arr [ i ] ] = 1 NEW_LINE DEDENT max_frequency = max ( max_frequency , mp [ arr [ i ] ] ) NEW_LINE DEDENT return n - max_frequency NEW_LINE DEDENT

BLEU: 79.17
Edit Sim: 33


Src: 
int sum ( int m , int n ) { return 8 * m * n - 6 * m - 6 * n + 4 ; }
Ref: 
def summ ( m , n ) : NEW_LINE INDENT return 8 * m * n - 6 * m - 6 * n + 4 NEW_LINE DEDENT
Hyp: 
def sum ( m , n ) : NEW_LINE INDENT return 8 * m * n - 6 * m - 6 * n + 4 NEW_LINE DEDENT

BLEU: 93.56
Edit Sim: 1


Src: 
void printNumber ( int holes ) { if ( holes == 0 ) System . out . print ( "1" ) ; else if ( holes == 1 ) System . out . print ( "0" ) ; else { int rem = 0 , quo = 0 ; rem = holes % 2 ; quo = holes / 2 ; if ( rem == 1 ) System . out . print ( "4" ) ; for ( int i = 0 ; i < quo ; i ++ ) System . out . print ( "8" ) ; } }
Ref: 
def printNumber ( holes ) : NEW_LINE INDENT if ( holes == 0 ) : NEW_LINE INDENT print ( "1" ) NEW_LINE DEDENT elif ( holes == 1 ) : NEW_LINE INDENT print ( "0" , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT rem = 0 NEW_LINE quo = 0 NEW_LINE rem = holes % 2 NEW_LINE quo = holes // 2 NEW_LINE if ( rem == 1 ) : NEW_LINE INDENT print ( "4" , end = " " ) NEW_LINE DEDENT for i in range ( quo ) : NEW_LINE INDENT print ( "8" , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
Hyp: 
def printNumber ( holes ) : NEW_LINE INDENT if ( holes == 0 ) : NEW_LINE INDENT print ( "1" ) NEW_LINE DEDENT elif ( holes == 1 ) : NEW_LINE INDENT print ( "0" ) NEW_LINE DEDENT else : NEW_LINE INDENT rem = 0 NEW_LINE quo = 0 NEW_LINE rem = holes % 2 NEW_LINE quo = holes // 2 NEW_LINE if ( rem == 1 ) : NEW_LINE INDENT print ( "4" ) NEW_LINE DEDENT for i in range ( quo ) : NEW_LINE INDENT print ( "8" , end = " " ) NEW_LINE DEDENT DEDENT

BLEU: 86.71
Edit Sim: 31


Src: 
void reverseorder ( int n ) { boolean prime [ ] = new boolean [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) prime [ i ] = true ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } for ( int i = n ; i >= 2 ; i -- ) if ( prime [ i ] == true ) System . out . print ( i + " ▁ " ) ; }
Ref: 
def Reverseorder ( n ) : NEW_LINE INDENT prime = [ True ] * ( n + 1 ) ; NEW_LINE p = 2 ; NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( ( p * 2 ) , ( n + 1 ) , p ) : NEW_LINE INDENT prime [ i ] = False ; NEW_LINE DEDENT DEDENT p += 1 ; NEW_LINE DEDENT for p in range ( n , 1 , - 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT print ( p , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT DEDENT N = 25 ; NEW_LINE print ( " Prime ▁ number ▁ in ▁ reverse ▁ order " ) ; NEW_LINE if ( N == 1 ) : NEW_LINE INDENT print ( " No ▁ prime ▁ no ▁ exist ▁ in ▁ this ▁ range " ) ; NEW_LINE DEDENT
Hyp: 
def reverseorder ( n ) : NEW_LINE INDENT prime = [ False for i in range ( n + 2 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT prime [ i ] = True NEW_LINE DEDENT for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , n + p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT for i in range ( n , 2 , - 1 ) : NEW_LINE INDENT if ( prime [ i ] == True ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT

BLEU: 43.79
Edit Sim: 292


Src: 
void printSeriesSum ( int N ) { double sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( i % 2 == 1 ) { sum += ( double ) i / ( i + 1 ) ; } else { sum -= ( double ) i / ( i + 1 ) ; } } System . out . print ( sum + "NEW_LINE"); }
Ref: 
def printSeriesSum ( N ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( i & 1 ) : NEW_LINE INDENT sum += i / ( i + 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT sum -= i / ( i + 1 ) ; NEW_LINE DEDENT DEDENT print ( sum ) ; NEW_LINE DEDENT
Hyp: 
def printSeriesSum ( N ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( i % 2 == 1 ) : NEW_LINE INDENT sum += i / ( i + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT sum -= i / ( i + 1 ) NEW_LINE DEDENT DEDENT print ( sum ) NEW_LINE DEDENT

BLEU: 82.38
Edit Sim: 14


Src: 
int findOddPair ( int A [ ] , int N ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( ( A [ i ] % 2 == 1 ) ) count ++ ; return count * ( count - 1 ) / 2 ; }
Ref: 
def findOddPair ( A , N ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( 0 , N - 1 ) : NEW_LINE INDENT if ( ( A [ i ] % 2 == 1 ) ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT return count * ( count - 1 ) / 2 NEW_LINE DEDENT
Hyp: 
def findOddPair ( A , N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( A [ i ] % 2 == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count * ( count - 1 ) // 2 NEW_LINE DEDENT

BLEU: 69.36
Edit Sim: 24


Src: 
int sum ( int a , int b ) { int sum = 0 ; for ( int i = 1 ; i <= Math . min ( a , b ) ; i ++ ) if ( a % i == 0 && b % i == 0 ) sum += i ; return sum ; }
Ref: 
def sum ( a , b ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , min ( a , b ) ) : NEW_LINE INDENT if ( a % i == 0 and b % i == 0 ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
Hyp: 
def sum ( a , b ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , min ( a , b ) + 1 ) : NEW_LINE INDENT if ( a % i == 0 and b % i == 0 ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT

BLEU: 94.06
Edit Sim: 4


Src: 
int summation ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += ( i * i ) ; return sum ; }
Ref: 
def summation ( n ) : NEW_LINE INDENT return sum ( [ i ** 2 for i in range ( 1 , n + 1 ) ] ) NEW_LINE DEDENT
Hyp: 
def summation ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += ( i * i ) NEW_LINE DEDENT return sum NEW_LINE DEDENT

BLEU: 49.8
Edit Sim: 76


Src: 
int countPermutations ( int N ) { ArrayList < ArrayList < Integer > > adj = new ArrayList < ArrayList < Integer > > ( 105 ) ; for ( int i = 0 ; i < 105 ; i ++ ) adj . add ( new ArrayList < Integer > ( ) ) ; int indeg = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 1 ; j <= N ; j ++ ) { if ( i == j ) continue ; int sum = i + j ; if ( Math . ceil ( Math . sqrt ( sum ) ) == Math . floor ( Math . sqrt ( sum ) ) ) { adj . get ( i ) . add ( j ) ; } } if ( adj . get ( i ) . size ( ) == 1 ) indeg ++ ; } if ( indeg == 0 ) return N ; else if ( indeg <= 2 ) return 2 ; else return 0 ; }
Ref: 
def countPermutations ( N ) : NEW_LINE INDENT adj = [ [ ] for i in range ( 105 ) ] NEW_LINE indeg = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT continue NEW_LINE DEDENT sum = i + j NEW_LINE if ( ceil ( sqrt ( sum ) ) == floor ( sqrt ( sum ) ) ) : NEW_LINE INDENT adj [ i ] . append ( j ) NEW_LINE DEDENT DEDENT if ( len ( adj [ i ] ) == 1 ) : NEW_LINE INDENT indeg += 1 NEW_LINE DEDENT DEDENT if ( indeg == 0 ) : NEW_LINE INDENT return N NEW_LINE DEDENT elif ( indeg <= 2 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT
Hyp: 
def countPermutations ( N ) : NEW_LINE INDENT adj = [ ] NEW_LINE for i in range ( 105 ) : NEW_LINE INDENT adj . append ( [ ] ) NEW_LINE DEDENT indeg = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT continue NEW_LINE DEDENT sum = i + j NEW_LINE if ( ceil ( math . sqrt ( sum ) ) == floor ( math . sqrt ( sum ) ) ) : NEW_LINE INDENT adj [ i ] . append ( j ) NEW_LINE DEDENT DEDENT if ( indeg == 0 ) : NEW_LINE INDENT return N NEW_LINE DEDENT elif ( indeg <= 2 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT

BLEU: 83.82
Edit Sim: 149


Src: 
int multiplyBySevenByEight ( int n ) { return ( n - ( n >> 3 ) ) ; }
Ref: 
def multiplyBySevenByEight ( n ) : NEW_LINE INDENT return ( n - ( n >> 3 ) ) NEW_LINE DEDENT
Hyp: 
def multiplyBySevenByEight ( n ) : NEW_LINE INDENT return ( n - ( n >> 3 ) ) ; NEW_LINE DEDENT

BLEU: 88.67
Edit Sim: 2


Src: 
void printSubstrings ( int n ) { int s = ( int ) Math . log10 ( n ) ; int d = ( int ) ( Math . pow ( 10 , s ) + 0.5 ) ; int k = d ; while ( n > 0 ) { while ( d > 0 ) { System . out . println ( n / d ) ; d = d / 10 ; } n = n % k ; k = k / 10 ; d = k ; } }
Ref: 
def printSubstrings ( n ) : NEW_LINE INDENT s = int ( math . log10 ( n ) ) ; NEW_LINE d = ( math . pow ( 10 , s ) ) ; NEW_LINE k = d ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT while ( d > 0 ) : NEW_LINE INDENT print ( int ( n // d ) ) ; NEW_LINE d = int ( d / 10 ) ; NEW_LINE DEDENT n = int ( n % k ) ; NEW_LINE k = int ( k // 10 ) ; NEW_LINE d = k ; NEW_LINE DEDENT DEDENT
Hyp: 
def printSubstrings ( n ) : NEW_LINE INDENT s = int ( math . log10 ( n ) ) NEW_LINE d = ( int ) ( math . pow ( 10 , s ) + 0.5 ) NEW_LINE k = d NEW_LINE while ( n > 0 ) : NEW_LINE INDENT while ( d > 0 ) : NEW_LINE INDENT print ( n // d ) NEW_LINE d = d // 10 NEW_LINE DEDENT n = n % k NEW_LINE k = k // 10 NEW_LINE d = k NEW_LINE DEDENT DEDENT

BLEU: 61.13
Edit Sim: 61


Src: 
void minimumDifference ( int N ) { int sum1 = ( 1 << N ) , sum2 = 0 ; for ( int i = 1 ; i < N / 2 ; i ++ ) sum1 += ( 1 << i ) ; for ( int i = N / 2 ; i < N ; i ++ ) sum2 += ( 1 << i ) ; System . out . println ( sum1 - sum2 ) ; }
Ref: 
def minimumDifference ( N ) : NEW_LINE INDENT sum1 = ( 1 << N ) NEW_LINE sum2 = 0 NEW_LINE for i in range ( 1 , N // 2 ) : NEW_LINE INDENT sum1 += ( 1 << i ) NEW_LINE DEDENT for i in range ( N // 2 , N ) : NEW_LINE INDENT sum2 += ( 1 << i ) NEW_LINE DEDENT print ( sum1 - sum2 ) NEW_LINE DEDENT
Hyp: 
def minimumDifference ( N ) : NEW_LINE INDENT sum1 = ( 1 << N ) NEW_LINE sum2 = 0 NEW_LINE for i in range ( 1 , N // 2 ) : NEW_LINE INDENT sum1 += ( 1 << i ) NEW_LINE DEDENT for i in range ( N // 2 , N ) : NEW_LINE INDENT sum2 += ( 1 << i ) NEW_LINE DEDENT print ( sum1 - sum2 ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
void printbinomial ( int max ) { for ( int m = 0 ; m <= max ; m ++ ) { System . out . print ( m + " ▁ " ) ; int binom = 1 ; for ( int x = 0 ; x <= m ; x ++ ) { if ( m != 0 && x != 0 ) binom = binom * ( m - x + 1 ) / x ; System . out . print ( binom + " ▁ " ) ; } System . out . println ( ) ; } }
Ref: 
def printbinomial ( max ) : NEW_LINE INDENT for m in range ( max + 1 ) : NEW_LINE INDENT print ( ' % ▁ 2d ' % m , end = ' ▁ ' ) NEW_LINE binom = 1 NEW_LINE for x in range ( m + 1 ) : NEW_LINE INDENT if m != 0 and x != 0 : NEW_LINE INDENT binom = binom * ( m - x + 1 ) / x NEW_LINE DEDENT print ( ' % ▁ 4d ' % binom , end = ' ▁ ' ) NEW_LINE DEDENT print ( " " , end = ' ' ) NEW_LINE DEDENT DEDENT
Hyp: 
def printbinomial ( max ) : NEW_LINE INDENT for m in range ( 0 , max + 1 ) : NEW_LINE INDENT print ( m , end = " ▁ " ) NEW_LINE binom = 1 NEW_LINE for x in range ( m + 1 ) : NEW_LINE INDENT if ( m != 0 and x != 0 ) : NEW_LINE INDENT binom = binom * ( m - x + 1 ) / x NEW_LINE DEDENT print ( binom , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT

BLEU: 65.8
Edit Sim: 54


Src: 
int countSubArrayWithOddProduct ( int A [ ] , int N ) { int count = 0 ; int last = - 1 ; int K = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( A [ i ] % 2 == 0 ) { K = ( i - last - 1 ) ; count += ( K * ( K + 1 ) / 2 ) ; last = i ; } } K = ( N - last - 1 ) ; count += ( K * ( K + 1 ) / 2 ) ; return count ; }
Ref: 
def countSubArrayWithOddProduct ( A , N ) : NEW_LINE INDENT count = 0 NEW_LINE last = - 1 NEW_LINE K = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( A [ i ] % 2 == 0 ) : NEW_LINE INDENT K = ( i - last - 1 ) NEW_LINE count += ( K * ( K + 1 ) / 2 ) NEW_LINE last = i NEW_LINE DEDENT DEDENT K = ( N - last - 1 ) NEW_LINE count += ( K * ( K + 1 ) / 2 ) NEW_LINE return count NEW_LINE DEDENT
Hyp: 
def countSubArrayWithOddProduct ( A , N ) : NEW_LINE INDENT count = 0 NEW_LINE last = - 1 NEW_LINE K = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( A [ i ] % 2 == 0 ) : NEW_LINE INDENT K = ( i - last - 1 ) NEW_LINE count += ( K * ( K + 1 ) / 2 ) NEW_LINE last = i NEW_LINE DEDENT DEDENT K = ( N - last - 1 ) NEW_LINE count += ( K * ( K + 1 ) / 2 ) NEW_LINE return count NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
void series ( int A , int X , int n ) { int term = ( int ) Math . pow ( A , n ) ; System . out . print ( term + " ▁ " ) ; for ( int i = 1 ; i <= n ; i ++ ) { term = term * X * ( n - i + 1 ) / ( i * A ) ; System . out . print ( term + " ▁ " ) ; } }
Ref: 
def series ( A , X , n ) : NEW_LINE INDENT term = pow ( A , n ) NEW_LINE print ( term , end = " ▁ " ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT term = int ( term * X * ( n - i + 1 ) / ( i * A ) ) NEW_LINE print ( term , end = " ▁ " ) NEW_LINE DEDENT DEDENT
Hyp: 
def series ( A , X , n ) : NEW_LINE INDENT term = pow ( A , n ) NEW_LINE print ( term , end = " ▁ " ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT term = term * X * ( n - i + 1 ) / ( i * A ) NEW_LINE DEDENT print ( term , end = " ▁ " ) NEW_LINE DEDENT DEDENT

BLEU: 91.9
Edit Sim: 15


Src: 
boolean isPossible ( int elements [ ] , int sum ) { int dp [ ] = new int [ sum + 1 ] ; dp [ 0 ] = 1 ; for ( int i = 0 ; i < elements . length ; i ++ ) { for ( int j = sum ; j >= elements [ i ] ; j -- ) { if ( dp [ j - elements [ i ] ] == 1 ) dp [ j ] = 1 ; } } if ( dp [ sum ] == 1 ) return true ; return false ; }
Ref: 
def isPossible ( elements , target ) : NEW_LINE INDENT dp = [ False ] * ( target + 1 ) NEW_LINE dp [ 0 ] = True NEW_LINE for ele in elements : NEW_LINE INDENT for j in range ( target , ele - 1 , - 1 ) : NEW_LINE INDENT if dp [ j - ele ] : NEW_LINE INDENT dp [ j ] = True NEW_LINE DEDENT DEDENT DEDENT return dp [ target ] NEW_LINE DEDENT arr = [ 6 , 2 , 5 ] NEW_LINE target = 7 NEW_LINE if isPossible ( arr , target ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
Hyp: 
def isPossible ( elements , sum ) : NEW_LINE INDENT dp = [ 0 ] * ( sum + 1 ) NEW_LINE dp [ 0 ] = 1 NEW_LINE for i in range ( len ( elements ) ) : NEW_LINE INDENT for j in range ( sum , elements [ i ] , - 1 ) : NEW_LINE INDENT if ( dp [ j - elements [ i ] ] == 1 ) : NEW_LINE INDENT dp [ j ] = 1 NEW_LINE DEDENT DEDENT DEDENT if ( dp [ sum ] == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT

BLEU: 40.26
Edit Sim: 229


Src: 
int Count ( String s , int pos ) { int c = s . charAt ( pos - 1 ) ; int counter = 0 ; for ( int i = 0 ; i < pos - 1 ; i ++ ) { if ( s . charAt ( i ) == c ) counter = counter + 1 ; } return counter ; }
Ref: 
def Count ( s , pos ) : NEW_LINE INDENT c = s [ pos - 1 ] NEW_LINE counter = 0 NEW_LINE for i in range ( pos - 1 ) : NEW_LINE INDENT if s [ i ] == c : NEW_LINE INDENT counter = counter + 1 NEW_LINE DEDENT DEDENT return counter NEW_LINE DEDENT
Hyp: 
def Count ( s , pos ) : NEW_LINE INDENT c = s [ pos - 1 ] NEW_LINE counter = 0 NEW_LINE for i in range ( pos - 1 ) : NEW_LINE INDENT if ( s [ i ] == c ) : NEW_LINE INDENT counter = counter + 1 NEW_LINE DEDENT DEDENT return counter NEW_LINE DEDENT

BLEU: 91.29
Edit Sim: 4


Src: 
void lengchord ( int z ) { System . out . println ( " The ▁ length ▁ is ▁ " + z ) ; }
Ref: 
def lengchord ( z ) : NEW_LINE INDENT print ( " The ▁ length ▁ is ▁ " , end = " " ) ; NEW_LINE print ( z ) ; NEW_LINE DEDENT
Hyp: 
def lengchord ( z ) : NEW_LINE INDENT print ( " The ▁ length ▁ is " , z ) NEW_LINE DEDENT

BLEU: 49.17
Edit Sim: 35


Src: 
double Area ( int b1 , int b2 , int h ) { return ( ( b1 + b2 ) / 2 ) * h ; }
Ref: 
def Area ( b1 , b2 , h ) : NEW_LINE INDENT return ( ( b1 + b2 ) / 2 ) * h NEW_LINE DEDENT
Hyp: 
def Area ( b1 , b2 , h ) : NEW_LINE INDENT return ( ( b1 + b2 ) / 2 ) * h NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int countSubStr ( char str [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == '1' ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( str [ j ] == '1' ) res ++ ; } } } return res ; }
Ref: 
def countSubStr ( st , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( st [ i ] == '1' ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( st [ j ] == '1' ) : NEW_LINE INDENT res = res + 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return res NEW_LINE DEDENT
Hyp: 
def countSubStr ( Str1 , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( Str1 [ i ] == '1' ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( Str1 [ j ] == '1' ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT

BLEU: 78.1
Edit Sim: 27


Src: 
void solve ( int arr [ ] , int n ) { int countzeroes = 0 ; int countones = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) countzeroes ++ ; else countones ++ ; } if ( Math . abs ( countzeroes - countones ) == 1 ) System . out . print ( " Yes " ) ; else System . out . print ( " No " ) ; }
Ref: 
def solve ( arr , n ) : NEW_LINE INDENT countzeroes = 0 ; NEW_LINE countones = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == 0 ) : NEW_LINE INDENT countzeroes += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT countones += 1 ; NEW_LINE DEDENT DEDENT if ( abs ( countzeroes - countones ) == 1 ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT DEDENT
Hyp: 
def solve ( arr , n ) : NEW_LINE INDENT countzeroes = 0 NEW_LINE countones = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == 0 ) : NEW_LINE INDENT countzeroes += 1 NEW_LINE DEDENT else : NEW_LINE INDENT countones += 1 NEW_LINE DEDENT DEDENT if ( abs ( countzeroes - countones ) == 1 ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT

BLEU: 83.75
Edit Sim: 12


Src: 
void lengtang ( double r1 , double r2 , double d ) { System . out . println ( " The ▁ length ▁ of ▁ the ▁ direct " + " ▁ common ▁ tangent ▁ is ▁ " + ( Math . sqrt ( Math . pow ( d , 2 ) - Math . pow ( ( r1 - r2 ) , 2 ) ) ) ) ; }
Ref: 
def lengtang ( r1 , r2 , d ) : NEW_LINE INDENT print ( " The ▁ length ▁ of ▁ the ▁ direct ▁ common ▁ tangent ▁ is ▁ " , ( ( d ** 2 ) - ( ( r1 - r2 ) ** 2 ) ) ** ( 1 / 2 ) ) ; NEW_LINE DEDENT
Hyp: 
def lengtang ( r1 , r2 , d ) : NEW_LINE INDENT print ( " The ▁ length ▁ of ▁ the ▁ direct " , " ▁ common ▁ tangent ▁ is ▁ " , ( ( ( d ** 2 ) - ( ( r1 - r2 ) ** 2 ) ) ** 0.5 ) ) NEW_LINE DEDENT

BLEU: 84.56
Edit Sim: 17


Src: 
int countSubStr ( String str , int len , int k ) { int count = 0 ; for ( int i = 0 ; i < len ; i ++ ) { int n = 0 ; for ( int j = i ; j < len ; j ++ ) { n = n * 10 + ( str . charAt ( j ) - '0' ) ; if ( n % k == 0 ) count ++ ; } } return count ; }
Ref: 
def countSubStr ( str , l , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( l ) : NEW_LINE INDENT n = 0 NEW_LINE for j in range ( i , l , 1 ) : NEW_LINE INDENT n = n * 10 + ( ord ( str [ j ] ) - ord ( '0' ) ) NEW_LINE if ( n % k == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
Hyp: 
def countSubStr ( str , l , k ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( l ) : NEW_LINE INDENT n = 0 ; NEW_LINE for j in range ( i , l ) : NEW_LINE INDENT n = n * 10 + ( ord ( str [ j ] ) - ord ( '0' ) ) ; NEW_LINE if ( n % k == 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT DEDENT return count ; NEW_LINE DEDENT

BLEU: 84.23
Edit Sim: 14


Src: 
void check_position ( int a , int b , int c , int d , int x1 , int y1 , int z1 , int x2 , int y2 , int z2 ) { int value_1 = a * x1 + b * y1 + c * z1 + d ; int value_2 = a * x2 + b * y2 + c * z2 + d ; if ( ( value_1 > 0 && value_2 > 0 ) || ( value_1 < 0 && value_2 < 0 ) ) System . out . print ( " On ▁ same ▁ side " ) ; if ( ( value_1 > 0 && value_2 < 0 ) || ( value_1 < 0 && value_2 > 0 ) ) System . out . print ( " On ▁ different ▁ sides " ) ; if ( value_1 == 0 && value_2 == 0 ) System . out . print ( " Both ▁ on ▁ the ▁ plane " ) ; if ( value_1 == 0 && value_2 != 0 ) System . out . print ( " Point ▁ 1 ▁ on ▁ the ▁ plane " ) ; if ( value_1 != 0 && value_2 == 0 ) System . out . print ( " Point ▁ 2 ▁ on ▁ the ▁ plane " ) ; }
Ref: 
def check_position ( a , b , c , d , x1 , y1 , z1 , x2 , y2 , z2 ) : NEW_LINE INDENT value_1 = a * x1 + b * y1 + c * z1 + d NEW_LINE value_2 = a * x2 + b * y2 + c * z2 + d NEW_LINE if ( ( value_1 > 0 and value_2 > 0 ) or ( value_1 < 0 and value_2 < 0 ) ) : NEW_LINE INDENT print ( " On ▁ same ▁ side " ) NEW_LINE DEDENT if ( ( value_1 > 0 and value_2 < 0 ) or ( value_1 < 0 and value_2 > 0 ) ) : NEW_LINE INDENT print ( " On ▁ different ▁ sides " ) NEW_LINE DEDENT if ( value_1 == 0 and value_2 == 0 ) : NEW_LINE INDENT print ( " Both ▁ on ▁ the ▁ plane " ) NEW_LINE DEDENT if ( value_1 == 0 and value_2 != 0 ) : NEW_LINE INDENT print ( " Point ▁ 1 ▁ on ▁ the ▁ plane " ) NEW_LINE DEDENT if ( value_1 != 0 and value_2 == 0 ) : NEW_LINE INDENT print ( " Point ▁ 2 ▁ on ▁ the ▁ plane " ) NEW_LINE DEDENT DEDENT
Hyp: 
def check_position ( a , b , c , d , x1 , y1 , z1 , x2 , y2 , z2 ) : NEW_LINE INDENT value_1 = a * x1 + b * y1 + c * z1 + d NEW_LINE value_2 = a * x2 + b * y2 + c * z2 + d NEW_LINE if ( ( value_1 > 0 and value_2 > 0 ) or ( value_1 < 0 and value_2 < 0 ) ) : NEW_LINE INDENT print ( " On ▁ same ▁ side " ) NEW_LINE DEDENT if ( value_1 == 0 and value_2 == 0 ) : NEW_LINE INDENT print ( " Both ▁ on ▁ the ▁ plane " ) NEW_LINE DEDENT if ( value_1 != 0 and value_2 != 0 ) : NEW_LINE INDENT print ( " Point ▁ 1 ▁ on ▁ the ▁ plane " ) NEW_LINE DEDENT if ( value_1 != 0 and value_2 == 0 ) : NEW_LINE INDENT print ( " Point ▁ 2 ▁ on ▁ the ▁ plane " ) NEW_LINE DEDENT DEDENT

BLEU: 80.38
Edit Sim: 146


Src: 
int minDifferenceAmongMaxMin ( int arr [ ] , int N , int K ) { Arrays . sort ( arr ) ; int res = 2147483647 ; for ( int i = 0 ; i <= ( N - K ) ; i ++ ) { int curSeqDiff = arr [ i + K - 1 ] - arr [ i ] ; res = Math . min ( res , curSeqDiff ) ; } return res ; }
Ref: 
def minDifferenceAmongMaxMin ( arr , N , K ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE res = 2147483647 NEW_LINE for i in range ( ( N - K ) + 1 ) : NEW_LINE INDENT curSeqDiff = arr [ i + K - 1 ] - arr [ i ] NEW_LINE res = min ( res , curSeqDiff ) NEW_LINE DEDENT return res NEW_LINE DEDENT
Hyp: 
def minDifferenceAmongMaxMin ( arr , N , K ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE res = 2147483647 NEW_LINE for i in range ( N - K + 1 ) : NEW_LINE INDENT curSeqDiff = arr [ i + K - 1 ] - arr [ i ] NEW_LINE res = min ( res , curSeqDiff ) NEW_LINE DEDENT return res NEW_LINE DEDENT

BLEU: 93.59
Edit Sim: 4


Src: 
int countPairs ( int arr [ ] , int n ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int product = arr [ i ] * arr [ j ] ; for ( int k = 0 ; k < n ; k ++ ) { if ( arr [ k ] == product ) { result ++ ; break ; } } } } return result ; }
Ref: 
def countPairs ( arr , n ) : NEW_LINE INDENT result = 0 ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT product = arr [ i ] * arr [ j ] ; NEW_LINE for k in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ k ] == product ) : NEW_LINE INDENT result = result + 1 ; NEW_LINE break ; NEW_LINE DEDENT DEDENT DEDENT DEDENT return result ; NEW_LINE DEDENT
Hyp: 
def countPairs ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT product = arr [ i ] * arr [ j ] NEW_LINE for k in range ( n ) : NEW_LINE INDENT if ( arr [ k ] == product ) : NEW_LINE INDENT result += 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT

BLEU: 74.24
Edit Sim: 35


Src: 
void sumEvenNumbers ( int N , int K ) { int check = N - 2 * ( K - 1 ) ; if ( check > 0 && check % 2 == 0 ) { for ( int i = 0 ; i < K - 1 ; i ++ ) { System . out . print ( "2 ▁ " ) ; } System . out . println ( check ) ; } else { System . out . println ( " - 1" ) ; } }
Ref: 
def sumEvenNumbers ( N , K ) : NEW_LINE INDENT check = N - 2 * ( K - 1 ) NEW_LINE if ( check > 0 and check % 2 == 0 ) : NEW_LINE INDENT for i in range ( K - 1 ) : NEW_LINE INDENT print ( "2 ▁ " , end = " " ) NEW_LINE DEDENT print ( check ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT DEDENT
Hyp: 
def sumEvenNumbers ( N , K ) : NEW_LINE INDENT check = N - 2 * ( K - 1 ) NEW_LINE if ( check > 0 and check % 2 == 0 ) : NEW_LINE INDENT for i in range ( K - 1 ) : NEW_LINE INDENT print ( " 2 ▁ " , end = " ▁ " ) NEW_LINE DEDENT print ( check ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT DEDENT

BLEU: 92.65
Edit Sim: 3


Src: 
float findRadiusOfcircumcircle ( float l , float b ) { if ( l < 0 b < 0 ) return - 1 ; float radius = ( float ) Math . sqrt ( Math . pow ( l , 2 ) + Math . pow ( b , 2 ) ) / 2 ; return radius ; }
Ref: 
def findRadiusOfcircumcircle ( l , b ) : NEW_LINE INDENT if ( l < 0 or b < 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT radius = ( math . sqrt ( pow ( l , 2 ) + pow ( b , 2 ) ) / 2 ) ; NEW_LINE return radius ; NEW_LINE DEDENT
Hyp: 
def findRadiusOfcircumcircle ( l , b ) : NEW_LINE INDENT if l < 0 or b < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT radius = ( math . sqrt ( l ** 2 ) + math . pow ( b ** 2 ) ) / 2 NEW_LINE return radius NEW_LINE DEDENT

BLEU: 59.91
Edit Sim: 26


Src: 
void sameChar ( String S , int N ) { char temp [ ] = S . toCharArray ( ) ; Arrays . sort ( temp ) ; String s = new String ( temp ) ; int mid = s . charAt ( N / 2 ) ; int total_operations = 0 ; for ( int i = 0 ; i < N ; i ++ ) { total_operations += Math . abs ( ( ( s . charAt ( i ) - 0 ) - mid ) ) ; } System . out . print ( total_operations ) ; }
Ref: 
def sameChar ( S , N ) : NEW_LINE INDENT S = ' ' . join ( sorted ( S ) ) NEW_LINE mid = ord ( S [ N // 2 ] ) NEW_LINE total_operations = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT total_operations += abs ( ord ( S [ i ] ) - mid ) NEW_LINE DEDENT print ( total_operations ) NEW_LINE DEDENT
Hyp: 
def sameChar ( S , N ) : NEW_LINE INDENT temp = sorted ( S ) NEW_LINE temp . sort ( ) NEW_LINE s = " " . join ( temp ) NEW_LINE mid = ord ( s [ N // 2 ] ) NEW_LINE total_operations = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT total_operations += abs ( ( ord ( s [ i ] ) - 0 ) - mid ) ) NEW_LINE DEDENT print ( total_operations ) NEW_LINE DEDENT

BLEU: 64.62
Edit Sim: 72


Src: 
int alternatingSumOfFirst_N ( int N ) { int alternateSum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( i % 2 == 0 ) { alternateSum += - i ; } else { alternateSum += i ; } } return alternateSum ; }
Ref: 
def alternatingSumOfFirst_N ( N ) : NEW_LINE INDENT alternateSum = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT alternateSum += - i NEW_LINE DEDENT else : NEW_LINE INDENT alternateSum += i NEW_LINE DEDENT DEDENT return alternateSum NEW_LINE DEDENT
Hyp: 
def alternatingSumOfFirst_N ( N ) : NEW_LINE INDENT alternateSum = 0 ; NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT alternateSum += - i ; NEW_LINE DEDENT else : NEW_LINE INDENT alternateSum += i ; NEW_LINE DEDENT DEDENT return alternateSum ; NEW_LINE DEDENT

BLEU: 83.45
Edit Sim: 8


Src: 
int findNumber ( int N ) { int [ ] ans = { 1 , 2 , 4 , 8 , 7 , 5 } ; return ans [ N % 6 ] ; }
Ref: 
def findNumber ( N ) : NEW_LINE INDENT ans = [ 1 , 2 , 4 , 8 , 7 , 5 ] NEW_LINE return ans [ N % 6 ] NEW_LINE DEDENT
Hyp: 
def findNumber ( N ) : NEW_LINE INDENT ans = [ 1 , 2 , 4 , 8 , 7 , 5 ] NEW_LINE return ans [ N % 6 ] NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int minCost ( int [ ] cost , int n ) { int totalCost = 0 ; int boardingBus = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( cost [ boardingBus ] > cost [ i ] ) { totalCost += ( ( i - boardingBus ) * cost [ boardingBus ] ) ; boardingBus = i ; } } totalCost += ( ( n - boardingBus ) * cost [ boardingBus ] ) ; return totalCost ; }
Ref: 
def minCost ( cost , n ) : NEW_LINE INDENT totalCost = 0 NEW_LINE boardingBus = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( cost [ boardingBus ] > cost [ i ] ) : NEW_LINE INDENT totalCost += ( ( i - boardingBus ) * cost [ boardingBus ] ) NEW_LINE boardingBus = i NEW_LINE DEDENT DEDENT totalCost += ( ( n - boardingBus ) * cost [ boardingBus ] ) NEW_LINE return totalCost NEW_LINE DEDENT
Hyp: 
def minCost ( cost , n ) : NEW_LINE INDENT totalCost = 0 NEW_LINE boardingBus = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( cost [ boardingBus ] > cost [ i ] ) : NEW_LINE INDENT totalCost += ( ( i - boardingBus ) * cost [ boardingBus ] ) NEW_LINE boardingBus = i NEW_LINE DEDENT DEDENT totalCost += ( ( n - boardingBus ) * cost [ boardingBus ] ) NEW_LINE return totalCost NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int bridge_length ( int trainLength , int Speed , int Time ) { return ( ( Time * Speed ) - trainLength ) ; }
Ref: 
def bridge_length ( trainLength , Speed , Time ) : NEW_LINE INDENT return ( ( Time * Speed ) - trainLength ) NEW_LINE DEDENT
Hyp: 
def bridge_length ( trainLength , Speed , Time ) : NEW_LINE INDENT return ( ( Time * Speed ) - trainLength ) ; NEW_LINE DEDENT

BLEU: 90.58
Edit Sim: 2


Src: 
double squareRoot ( double n , double l ) { double x = n ; double root ; int count = 0 ; while ( true ) { count ++ ; root = 0.5 * ( x + ( n / x ) ) ; if ( Math . abs ( root - x ) < l ) break ; x = root ; } return root ; }
Ref: 
def squareRoot ( n , l ) : NEW_LINE INDENT x = n NEW_LINE count = 0 NEW_LINE while ( 1 ) : NEW_LINE INDENT count += 1 NEW_LINE root = 0.5 * ( x + ( n / x ) ) NEW_LINE if ( abs ( root - x ) < l ) : NEW_LINE INDENT break NEW_LINE DEDENT x = root NEW_LINE DEDENT return root NEW_LINE DEDENT
Hyp: 
def squareRoot ( n , l ) : NEW_LINE INDENT x = n NEW_LINE root = 0.5 * ( x + ( n / x ) ) NEW_LINE if ( abs ( root - x ) < l ) : NEW_LINE INDENT break NEW_LINE DEDENT x = root NEW_LINE DEDENT return root NEW_LINE DEDENT

BLEU: 74.65
Edit Sim: 69


Src: 
long NumberofWays ( int n ) { long x = ( 1l * ( n ) * ( n - 1 ) * ( n - 2 ) * ( n - 3 ) ) / ( 4 * 3 * 2 * 1 ) ; long y = ( 1l * ( n ) * ( n - 1 ) * ( n - 2 ) * ( n - 3 ) ) ; return ( 1l * x * y ) ; }
Ref: 
def NumbersofWays ( n ) : NEW_LINE INDENT x = ( n * ( n - 1 ) * ( n - 2 ) * ( n - 3 ) ) // ( 4 * 3 * 2 * 1 ) NEW_LINE y = n * ( n - 1 ) * ( n - 2 ) * ( n - 3 ) NEW_LINE return x * y NEW_LINE DEDENT
Hyp: 
def NumberofWays ( n ) : NEW_LINE INDENT x = ( 1l * ( n ) * ( n - 1 ) * ( n - 2 ) * ( n - 3 ) ) // ( 4 * 3 * 2 * 1 ) NEW_LINE y = ( 1l * ( n ) * ( n - 1 ) * ( n - 2 ) * ( n - 3 ) ) NEW_LINE return ( 1l * x * y ) NEW_LINE DEDENT

BLEU: 71.35
Edit Sim: 32


Src: 
int sumOfSeries ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= i ; j ++ ) sum += j ; return sum ; }
Ref: 
def sumOfSeries ( n ) : NEW_LINE INDENT return sum ( [ i * ( i + 1 ) / 2 for i in range ( 1 , n + 1 ) ] ) NEW_LINE DEDENT
Hyp: 
def sumOfSeries ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT sum += j NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT

BLEU: 41.63
Edit Sim: 107


Src: 
int summingSeries ( long n ) { return ( int ) Math . pow ( n , 2 ) ; }
Ref: 
def summingSeries ( n ) : NEW_LINE INDENT return math . pow ( n , 2 ) NEW_LINE DEDENT
Hyp: 
def summingSeries ( n ) : NEW_LINE INDENT return pow ( n , 2 ) ; NEW_LINE DEDENT

BLEU: 72.67
Edit Sim: 9


Src: 
int maxSubarrayXOR ( int arr [ ] , int n ) { int ans = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { int curr_xor = 0 ; for ( int j = i ; j < n ; j ++ ) { curr_xor = curr_xor ^ arr [ j ] ; ans = Math . max ( ans , curr_xor ) ; } } return ans ; }
Ref: 
def maxSubarrayXOR ( arr , n ) : NEW_LINE INDENT ans = - 2147483648 NEW_LINE for i in range ( n ) : NEW_LINE INDENT curr_xor = 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT curr_xor = curr_xor ^ arr [ j ] NEW_LINE ans = max ( ans , curr_xor ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
Hyp: 
def maxSubarrayXOR ( arr , n ) : NEW_LINE INDENT ans = sys . maxsize NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT curr_xor = 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT curr_xor = curr_xor ^ arr [ j ] NEW_LINE ans = max ( ans , curr_xor ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT

BLEU: 88.02
Edit Sim: 17


Src: 
int highestPowerof2 ( int n ) { int p = ( int ) ( Math . log ( n ) / Math . log ( 2 ) ) ; return ( int ) Math . pow ( 2 , p ) ; }
Ref: 
def highestPowerof2 ( n ) : NEW_LINE INDENT p = int ( math . log ( n , 2 ) ) ; NEW_LINE return int ( pow ( 2 , p ) ) ; NEW_LINE DEDENT
Hyp: 
def highestPowerof2 ( n ) : NEW_LINE INDENT p = int ( math . log2 ( n ) ) NEW_LINE return pow ( 2 , p ) NEW_LINE DEDENT

BLEU: 56.02
Edit Sim: 17


Src: 
int find_distance ( int n ) { return n * ( 3 * n + 7 ) ; }
Ref: 
def find_distance ( n ) : NEW_LINE INDENT return n * ( ( 3 * n ) + 7 ) NEW_LINE DEDENT
Hyp: 
def find_distance ( n ) : NEW_LINE INDENT return n * ( 3 * n + 7 ) NEW_LINE DEDENT

BLEU: 78.89
Edit Sim: 4


Src: 
float getPercentile ( int rank , int students ) { float result = ( float ) ( students - rank ) / students * 100 ; return result ; }
Ref: 
def getPercentile ( rank , students ) : NEW_LINE INDENT result = ( students - rank ) / students * 100 ; NEW_LINE return result ; NEW_LINE DEDENT
Hyp: 
def getPercentile ( rank , students ) : NEW_LINE INDENT result = ( students - rank ) / students * 100 NEW_LINE return result NEW_LINE DEDENT

BLEU: 81.96
Edit Sim: 4


Src: 
int otherNumber ( int A , int Lcm , int Hcf ) { return ( Lcm * Hcf ) / A ; }
Ref: 
def otherNumber ( a , Lcm , Hcf ) : NEW_LINE INDENT return ( Lcm * Hcf ) // A NEW_LINE DEDENT
Hyp: 
def otherNumber ( A , Lcm , Hcf ) : NEW_LINE INDENT return ( Lcm * Hcf ) // A NEW_LINE DEDENT

BLEU: 87.87
Edit Sim: 1


Src: 
int fib ( long n ) { int f0 = 0 ; int f1 = 1 ; if ( n == 0 ) return 0 ; if ( n == 1 ) return 1 ; else { int rem = ( int ) ( n % 60 ) ; if ( rem == 0 ) return 0 ; for ( int i = 2 ; i < rem + 3 ; i ++ ) { int f = ( f0 + f1 ) % 60 ; f0 = f1 ; f1 = f ; } int s = f1 - 1 ; return s ; } }
Ref: 
def fib ( n ) : NEW_LINE INDENT f0 = 0 NEW_LINE f1 = 1 NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT rem = n % 60 NEW_LINE if ( rem == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT for i in range ( 2 , rem + 3 ) : NEW_LINE INDENT f = ( f0 + f1 ) % 60 NEW_LINE f0 = f1 NEW_LINE f1 = f NEW_LINE DEDENT s = f1 - 1 NEW_LINE return ( s ) NEW_LINE DEDENT DEDENT
Hyp: 
def fib ( n ) : NEW_LINE INDENT f0 = 0 NEW_LINE f1 = 1 NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT rem = int ( n % 60 ) NEW_LINE if ( rem == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT for i in range ( 2 , rem + 3 ) : NEW_LINE INDENT f = ( f0 + f1 ) % 60 NEW_LINE f0 = f1 NEW_LINE f1 = f NEW_LINE DEDENT s = f1 - 1 NEW_LINE return s NEW_LINE DEDENT DEDENT

BLEU: 93.14
Edit Sim: 12


Src: 
boolean isEven ( int n ) { if ( ( n & 1 ) == 0 ) return true ; else return false ; } return true ; else return false ; }
Ref: 
def isEven ( n ) : NEW_LINE INDENT return ( not ( n & 1 ) ) NEW_LINE DEDENT
Hyp: 
def isEven ( n ) : NEW_LINE INDENT if ( n & 1 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT else : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT return True ; NEW_LINE DEDENT

BLEU: 33.96
Edit Sim: 120


Src: 
boolean asPowerSum ( int w , int m ) { while ( m > 0 ) { if ( ( m - 1 ) % w == 0 ) m = ( m - 1 ) / w ; else if ( ( m + 1 ) % w == 0 ) m = ( m + 1 ) / w ; else if ( m % w == 0 ) m = m / w ; else } return ( m == 0 ) ; }
Ref: 
def asPowerSum ( w , m ) : NEW_LINE INDENT while ( m > 0 ) : NEW_LINE INDENT if ( ( m - 1 ) % w == 0 ) : NEW_LINE INDENT m = ( m - 1 ) / w ; NEW_LINE DEDENT elif ( ( m + 1 ) % w == 0 ) : NEW_LINE INDENT m = ( m + 1 ) / w ; NEW_LINE DEDENT elif ( m % w == 0 ) : NEW_LINE INDENT m = m / w ; NEW_LINE DEDENT else : NEW_LINE DEDENT return ( m == 0 ) ; NEW_LINE DEDENT w = 3 ; NEW_LINE m = 7 ; NEW_LINE if ( asPowerSum ( w , m ) ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT
Hyp: 
def asPowerSum ( w , m ) : NEW_LINE INDENT while ( m > 0 ) : NEW_LINE INDENT if ( m - 1 ) % w == 0 ) : NEW_LINE INDENT m = ( m - 1 ) // w NEW_LINE DEDENT elif ( ( m + 1 ) % w == 0 ) : NEW_LINE INDENT m = ( m + 1 ) // w NEW_LINE DEDENT elif ( m % w == 0 ) : NEW_LINE INDENT m = m // w NEW_LINE DEDENT else : NEW_LINE INDENT return ( m == 0 ) NEW_LINE DEDENT DEDENT

BLEU: 53.26
Edit Sim: 182


Src: 
void numberOfGates ( String s ) { int N = s . length ( ) ; int ans = 0 ; for ( int i = 0 ; i < ( int ) s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == ' . ' || s . charAt ( i ) == ' + ' || s . charAt ( i ) == '1' ) { ans ++ ; } } System . out . println ( ans ) ; }
Ref: 
def numberOfGates ( s ) : NEW_LINE INDENT N = len ( s ) NEW_LINE ans = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == ' . ' or s [ i ] == ' + ' or s [ i ] == '1' ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans , end = " " ) NEW_LINE DEDENT
Hyp: 
def numberOfGates ( s ) : NEW_LINE INDENT N = len ( s ) NEW_LINE ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( s [ i ] == ' . ' or s [ i ] == ' + ' or s [ i ] == '1' ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT

BLEU: 84.18
Edit Sim: 21


Src: 
int MinimumX ( int a , int b , int c , int k ) { int x = Integer . MAX_VALUE ; if ( k <= c ) return 0 ; int h = k - c ; int l = 0 ; while ( l <= h ) { int m = ( l + h ) / 2 ; if ( ( a * m * m ) + ( b * m ) > ( k - c ) ) { x = Math . min ( x , m ) ; h = m - 1 ; } else if ( ( a * m * m ) + ( b * m ) < ( k - c ) ) l = m + 1 ; else return m ; } return x ; }
Ref: 
def MinimumX ( a , b , c , k ) : NEW_LINE INDENT x = 10 ** 9 NEW_LINE if ( k <= c ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT h = k - c NEW_LINE l = 0 NEW_LINE while ( l <= h ) : NEW_LINE INDENT m = ( l + h ) // 2 NEW_LINE if ( ( a * m * m ) + ( b * m ) > ( k - c ) ) : NEW_LINE INDENT x = min ( x , m ) NEW_LINE h = m - 1 NEW_LINE DEDENT elif ( ( a * m * m ) + ( b * m ) < ( k - c ) ) : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT else : NEW_LINE INDENT return m NEW_LINE DEDENT DEDENT return x NEW_LINE DEDENT
Hyp: 
def MinimumX ( a , b , c , k ) : NEW_LINE INDENT x = sys . maxsize NEW_LINE if ( k <= c ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT h = k - c NEW_LINE l = 0 NEW_LINE while ( l <= h ) : NEW_LINE INDENT m = ( l + h ) // 2 NEW_LINE if ( ( a * m * m ) + ( b * m ) > ( k - c ) ) : NEW_LINE INDENT x = min ( x , m ) NEW_LINE h = m - 1 NEW_LINE DEDENT elif ( ( a * m * m ) + ( b * m ) < ( k - c ) ) : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT else : NEW_LINE INDENT return m NEW_LINE DEDENT DEDENT return x NEW_LINE DEDENT

BLEU: 96.94
Edit Sim: 12


Src: 
void farthestCellDistance ( int N , int M , int R , int C ) { int d1 = N + M - R - C ; int d2 = R + C - 2 ; int d3 = N - R + C - 1 ; int d4 = M - C + R - 1 ; int maxDistance = Math . max ( d1 , Math . max ( d2 , Math . max ( d3 , d4 ) ) ) ; System . out . println ( maxDistance ) ; }
Ref: 
def farthestCellDistance ( N , M , R , C ) : NEW_LINE INDENT d1 = N + M - R - C ; NEW_LINE d2 = R + C - 2 ; NEW_LINE d3 = N - R + C - 1 ; NEW_LINE d4 = M - C + R - 1 ; NEW_LINE maxDistance = max ( d1 , max ( d2 , max ( d3 , d4 ) ) ) ; NEW_LINE print ( maxDistance ) ; NEW_LINE DEDENT
Hyp: 
def farthestCellDistance ( N , M , R , C ) : NEW_LINE INDENT d1 = N + M - R - C NEW_LINE d2 = R + C - 2 NEW_LINE d3 = N - R + C - 1 NEW_LINE d4 = M - C + R - 1 NEW_LINE maxDistance = max ( d1 , max ( d2 , max ( d3 , d4 ) ) ) NEW_LINE print ( maxDistance ) NEW_LINE DEDENT

BLEU: 81.43
Edit Sim: 12


Src: 
int xorOfSum ( int a [ ] , int n ) { int answer = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) answer ^= ( a [ i ] + a [ j ] ) ; } return answer ; }
Ref: 
def xorOfSum ( a , n ) : NEW_LINE INDENT answer = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT answer ^= ( a [ i ] + a [ j ] ) NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT
Hyp: 
def xorOfSum ( a , n ) : NEW_LINE INDENT answer = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT answer ^= ( a [ i ] + a [ j ] ) NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
void CountTriangles ( int [ ] A ) { int n = A . length ; Arrays . sort ( A ) ; int count = 0 ; for ( int i = n - 1 ; i >= 1 ; i -- ) { int l = 0 , r = i - 1 ; while ( l < r ) { if ( A [ l ] + A [ r ] > A [ i ] ) { count += r - l ; r -- ; } else { l ++ ; } } } System . out . print ( " No ▁ of ▁ possible ▁ solutions : ▁ " + count ) ; }
Ref: 
def CountTriangles ( A ) : NEW_LINE INDENT n = len ( A ) ; NEW_LINE A . sort ( ) ; NEW_LINE count = 0 ; NEW_LINE for i in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT l = 0 ; NEW_LINE r = i - 1 ; NEW_LINE while ( l < r ) : NEW_LINE INDENT if ( A [ l ] + A [ r ] > A [ i ] ) : NEW_LINE INDENT count += r - l ; NEW_LINE r -= 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT l += 1 ; NEW_LINE DEDENT DEDENT DEDENT print ( " No ▁ of ▁ possible ▁ solutions : ▁ " , count ) ; NEW_LINE DEDENT
Hyp: 
def CountTriangles ( A ) : NEW_LINE INDENT n = len ( A ) NEW_LINE A . sort ( ) NEW_LINE count = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT l = 0 NEW_LINE r = i - 1 NEW_LINE while ( l < r ) : NEW_LINE INDENT if ( A [ l ] + A [ r ] > A [ i ] ) : NEW_LINE INDENT count += r - l NEW_LINE r -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT l += 1 NEW_LINE DEDENT DEDENT print ( " No ▁ of ▁ possible ▁ solutions : ▁ " , count ) NEW_LINE DEDENT

BLEU: 79.17
Edit Sim: 28


Src: 
void printRotatedString ( String str ) { int n = str . length ( ) ; StringBuffer sb = new StringBuffer ( str ) ; sb . append ( str ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j != n ; j ++ ) System . out . print ( sb . charAt ( i + j ) ) ; System . out . println ( ) ; } }
Ref: 
def printRotatedString ( string ) : NEW_LINE INDENT n = len ( string ) NEW_LINE temp = string + string NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT print ( temp [ i + j ] , end = " " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT
Hyp: 
def printRotatedString ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE s = " " NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT print ( s [ i + j ] , end = " " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT

BLEU: 76.54
Edit Sim: 42


Src: 
int minimumSteps ( int n , int m , int a , int b ) { if ( n > m ) return MAXN ; if ( n == m ) return 0 ; return Math . min ( 1 + minimumSteps ( n * a , m , a , b ) , 1 + minimumSteps ( n * b , m , a , b ) ) ; }
Ref: 
def minimumSteps ( n , m , a , b ) : NEW_LINE INDENT if ( n > m ) : NEW_LINE INDENT return MAXN NEW_LINE DEDENT if ( n == m ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return min ( 1 + minimumSteps ( n * a , m , a , b ) , 1 + minimumSteps ( n * b , m , a , b ) ) NEW_LINE DEDENT
Hyp: 
def minimumSteps ( n , m , a , b ) : NEW_LINE INDENT if ( n > m ) : NEW_LINE INDENT return MAXN NEW_LINE DEDENT if ( n == m ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return min ( 1 + minimumSteps ( n * a , m , a , b ) , 1 + minimumSteps ( n * b , m , a , b ) ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
String sort ( String s ) { char [ ] c = new char [ s . length ( ) + 1 ] ; c = s . toCharArray ( ) ; Arrays . sort ( c ) ; int al_c = 0 , nu_c = 0 ; while ( c [ al_c ] < 97 ) al_c ++ ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) < 97 ) s = s . substring ( 0 , i ) + c [ nu_c ++ ] + s . substring ( i + 1 ) ; else s = s . substring ( 0 , i ) + c [ al_c ++ ] + s . substring ( i + 1 ) ; } return s ; }
Ref: 
def sort ( s ) : NEW_LINE INDENT c , s = list ( s ) , list ( s ) NEW_LINE c . sort ( ) NEW_LINE al_c = 0 NEW_LINE nu_c = 0 NEW_LINE while ord ( c [ al_c ] ) < 97 : NEW_LINE INDENT al_c += 1 NEW_LINE DEDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] < ' a ' : NEW_LINE INDENT s [ i ] = c [ nu_c ] NEW_LINE nu_c += 1 NEW_LINE DEDENT else : NEW_LINE INDENT s [ i ] = c [ al_c ] NEW_LINE al_c += 1 NEW_LINE DEDENT DEDENT return ' ' . join ( s ) NEW_LINE DEDENT
Hyp: 
def sort ( s ) : NEW_LINE INDENT c = [ 0 for i in range ( len ( s ) + 1 ) ] NEW_LINE c . sort ( ) NEW_LINE al_c = 0 NEW_LINE nu_c = 0 NEW_LINE while ( c [ al_c ] < 97 ) : NEW_LINE INDENT al_c += 1 NEW_LINE DEDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if ( ord ( s [ i ] ) < 97 ) : NEW_LINE INDENT s = s [ 0 : i ] + c [ nu_c ] + s [ i + 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT s = s [ 0 : i ] + c [ al_c ] + s [ i + 1 ] NEW_LINE DEDENT DEDENT return s NEW_LINE DEDENT

BLEU: 54.49
Edit Sim: 111


Src: 
int FlipBits ( int n ) { return n -= ( n & ( - n ) ) ; }
Ref: 
def FlipBits ( n ) : NEW_LINE INDENT n -= ( n & ( - n ) ) ; NEW_LINE return n ; NEW_LINE DEDENT
Hyp: 
def FlipBits ( n ) : NEW_LINE INDENT return n - ( n & ( - n ) ) NEW_LINE DEDENT

BLEU: 60.7
Edit Sim: 28


Src: 
void rearrange ( int arr [ ] , int n ) { int max_ele = arr [ n - 1 ] ; int min_ele = arr [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { arr [ i ] = max_ele ; max_ele -= 1 ; } else { arr [ i ] = min_ele ; min_ele += 1 ; } } }
Ref: 
def rearrange ( arr , n ) : NEW_LINE INDENT max_ele = arr [ n - 1 ] NEW_LINE min_ele = arr [ 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT arr [ i ] = max_ele NEW_LINE max_ele -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = min_ele NEW_LINE min_ele += 1 NEW_LINE DEDENT DEDENT DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Origianl ▁ Array " ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT rearrange ( arr , n ) NEW_LINE print ( " Modified Array " ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT
Hyp: 
def rearrange ( arr , n ) : NEW_LINE INDENT max_ele = arr [ n - 1 ] NEW_LINE min_ele = arr [ 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT arr [ i ] = max_ele NEW_LINE max_ele -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = min_ele NEW_LINE min_ele += 1 NEW_LINE DEDENT DEDENT DEDENT

BLEU: 25.59
Edit Sim: 369


Src: 
int minDiff ( int [ ] A , int K ) { Arrays . sort ( A ) ; int n = A . length ; if ( n <= K ) return 0 ; int mindiff = A [ n - 1 ] - A [ 0 ] ; if ( K == 0 ) return mindiff ; for ( int i = 0 , j = n - 1 - K ; j < n ; ) { mindiff = Math . min ( mindiff , A [ j ] - A [ i ] ) ; i ++ ; j ++ ; } return mindiff ; }
Ref: 
def minDiff ( A , K ) : NEW_LINE INDENT A . sort ( ) ; NEW_LINE n = len ( A ) ; NEW_LINE if ( n <= K ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT mindiff = A [ n - 1 ] - A [ 0 ] ; NEW_LINE if ( K == 0 ) : NEW_LINE INDENT return mindiff ; NEW_LINE DEDENT i = 0 ; NEW_LINE for j in range ( n - 1 - K , n ) : NEW_LINE INDENT mindiff = min ( mindiff , A [ j ] - A [ i ] ) ; NEW_LINE i += 1 ; NEW_LINE j += 1 ; NEW_LINE DEDENT return mindiff ; NEW_LINE DEDENT
Hyp: 
def minDiff ( A , K ) : NEW_LINE INDENT A . sort ( ) NEW_LINE n = len ( A ) NEW_LINE if ( n <= K ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT mindiff = A [ n - 1 ] - A [ 0 ] NEW_LINE if ( K == 0 ) : NEW_LINE INDENT return mindiff NEW_LINE DEDENT for i in range ( n - 1 - K , n ) : NEW_LINE INDENT mindiff = min ( mindiff , A [ j ] - A [ i ] ) NEW_LINE i += 1 NEW_LINE j += 1 NEW_LINE DEDENT return mindiff NEW_LINE DEDENT

BLEU: 74.32
Edit Sim: 36


Src: 
void sieve ( ) { int arr [ ] = new int [ N + 1 ] ; arr [ 0 ] = 1 ; arr [ 1 ] = 1 ; for ( int i = 2 ; i <= Math . sqrt ( N ) ; i ++ ) if ( arr [ i ] == 0 ) for ( int j = i * i ; j <= N ; j += i ) arr [ j ] = 1 ; long runningPrimeSum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( arr [ i ] == 0 ) runningPrimeSum += i ; dp [ i ] = runningPrimeSum ; } }
Ref: 
def sieve ( ) : NEW_LINE INDENT array = [ 0 ] * ( N + 1 ) NEW_LINE array [ 0 ] = 1 NEW_LINE array [ 1 ] = 1 NEW_LINE for i in range ( 2 , math . ceil ( math . sqrt ( N ) + 1 ) ) : NEW_LINE INDENT if array [ i ] == 0 : NEW_LINE INDENT for j in range ( i * i , N + 1 , i ) : NEW_LINE INDENT array [ j ] = 1 NEW_LINE DEDENT DEDENT DEDENT runningPrimeSum = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if array [ i ] == 0 : NEW_LINE INDENT runningPrimeSum += i NEW_LINE DEDENT dp [ i ] = runningPrimeSum NEW_LINE DEDENT DEDENT
Hyp: 
def sieve ( N ) : NEW_LINE INDENT arr = [ 0 for i in range ( N + 1 ) ] NEW_LINE arr [ 0 ] = 1 NEW_LINE arr [ 1 ] = 1 NEW_LINE for i in range ( 2 , int ( sqrt ( N ) ) + 1 ) : NEW_LINE INDENT if ( arr [ i ] == 0 ) : NEW_LINE INDENT for j in range ( i * i , N + 1 ) : NEW_LINE INDENT arr [ j ] = 1 NEW_LINE DEDENT DEDENT DEDENT runningPrimeSum = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( arr [ i ] == 0 ) : NEW_LINE INDENT runningPrimeSum += i NEW_LINE DEDENT dp [ i ] = runningPrimeSum NEW_LINE DEDENT DEDENT

BLEU: 71.4
Edit Sim: 61


Src: 
int count ( int n ) { return ( int ) Math . pow ( 2 , n - 1 ) ; }
Ref: 
def count ( n ) : NEW_LINE INDENT return pow ( 2 , n - 1 ) NEW_LINE DEDENT
Hyp: 
def count ( n ) : NEW_LINE INDENT return pow ( 2 , n - 1 ) ; NEW_LINE DEDENT

BLEU: 88.07
Edit Sim: 2


Src: 
void printTriplets ( int arr [ ] , int n , int sum ) { Arrays . sort ( arr ) ; for ( int i = 0 ; i < n - 2 ; i ++ ) { int j = i + 1 , k = n - 1 ; while ( j < k ) { if ( arr [ i ] + arr [ j ] + arr [ k ] >= sum ) k -- ; else { for ( int x = j + 1 ; x <= k ; x ++ ) System . out . println ( arr [ i ] + " , ▁ " + arr [ j ] + " , ▁ " + arr [ x ] ) ; j ++ ; } } } }
Ref: 
def printTriplets ( arr , n , sum ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE for i in range ( n - 2 ) : NEW_LINE INDENT ( j , k ) = ( i + 1 , n - 1 ) NEW_LINE while ( j < k ) : NEW_LINE INDENT if ( arr [ i ] + arr [ j ] + arr [ k ] >= sum ) : NEW_LINE INDENT k -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT for x in range ( j + 1 , k + 1 ) : NEW_LINE INDENT print ( str ( arr [ i ] ) + " , ▁ " + str ( arr [ j ] ) + " , ▁ " + str ( arr [ x ] ) ) NEW_LINE DEDENT j += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT
Hyp: 
def printTriplets ( arr , n , sum ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE for i in range ( n - 2 ) : NEW_LINE INDENT j = i + 1 NEW_LINE k = n - 1 NEW_LINE while ( j < k ) : NEW_LINE INDENT if ( arr [ i ] + arr [ j ] + arr [ k ] >= sum ) : NEW_LINE INDENT k -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT for x in range ( j + 1 , k + 1 ) : NEW_LINE INDENT print ( arr [ i ] , " , ▁ " , arr [ j ] , " , ▁ " , arr [ x ] ) NEW_LINE j += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT

BLEU: 75.41
Edit Sim: 52


Src: 
int ceilSearch ( int arr [ ] , int low , int high , int x ) { int mid ; if ( x <= arr [ low ] ) return low ; if ( x > arr [ high ] ) return - 1 ; mid = ( low + high ) / 2 ; if ( arr [ mid ] == x ) return mid ; else if ( arr [ mid ] < x ) { if ( mid + 1 <= high && x <= arr [ mid + 1 ] ) return mid + 1 ; else return ceilSearch ( arr , mid + 1 , high , x ) ; } else { if ( mid - 1 >= low && x > arr [ mid - 1 ] ) return mid ; else return ceilSearch ( arr , low , mid - 1 , x ) ; } }
Ref: 
def ceilSearch ( arr , low , high , x ) : NEW_LINE INDENT if x <= arr [ low ] : NEW_LINE INDENT return low NEW_LINE DEDENT if x > arr [ high ] : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = ( low + high ) / 2 ; NEW_LINE if arr [ mid ] == x : NEW_LINE INDENT return mid NEW_LINE DEDENT elif arr [ mid ] < x : NEW_LINE INDENT if mid + 1 <= high and x <= arr [ mid + 1 ] : NEW_LINE INDENT return mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT return ceilSearch ( arr , mid + 1 , high , x ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if mid - 1 >= low and x > arr [ mid - 1 ] : NEW_LINE INDENT return mid NEW_LINE DEDENT else : NEW_LINE INDENT return ceilSearch ( arr , low , mid - 1 , x ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 1 , 2 , 8 , 10 , 10 , 12 , 19 ] NEW_LINE n = len ( arr ) NEW_LINE x = 20 NEW_LINE index = ceilSearch ( arr , 0 , n - 1 , x ) ; NEW_LINE if index == - 1 : NEW_LINE INDENT print ( " Ceiling ▁ of ▁ % d ▁ doesn ' t ▁ exist ▁ in ▁ array ▁ " % x ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " ceiling ▁ of ▁ % d ▁ is ▁ % d " % ( x , arr [ index ] ) ) NEW_LINE DEDENT
Hyp: 
def ceilSearch ( arr , low , high , x ) : NEW_LINE INDENT if ( x <= arr [ low ] ) : NEW_LINE INDENT return low NEW_LINE DEDENT if ( x > arr [ high ] ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = ( low + high ) // 2 NEW_LINE if ( arr [ mid ] == x ) : NEW_LINE INDENT return mid NEW_LINE DEDENT elif ( arr [ mid ] < x ) : NEW_LINE INDENT if ( mid + 1 <= high and x <= arr [ mid + 1 ] ) : NEW_LINE INDENT return mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( mid - 1 >= low and x > arr [ mid - 1 ] ) : NEW_LINE INDENT return mid NEW_LINE DEDENT else : NEW_LINE INDENT return ceilSearch ( arr , low , mid - 1 , x ) NEW_LINE DEDENT DEDENT DEDENT

BLEU: 38.57
Edit Sim: 490


Src: 
void countSmaller ( String str ) { int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int cnt = 0 ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( str . charAt ( j ) < str . charAt ( i ) ) { cnt += 1 ; } } System . out . print ( cnt + " ▁ " ) ; } }
Ref: 
def countSmaller ( str ) : NEW_LINE INDENT n = len ( str ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( str [ j ] < str [ i ] ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT DEDENT print ( cnt , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT
Hyp: 
def countSmaller ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT cnt = 0 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( str [ j ] < str [ i ] ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT print ( cnt , end = " ▁ " ) NEW_LINE DEDENT DEDENT

BLEU: 87.22
Edit Sim: 8


Src: 
int splitArray ( int arr [ ] , int N ) { Arrays . sort ( arr ) ; int result = Integer . MAX_VALUE ; for ( int i = 1 ; i < N ; i ++ ) { result = Math . min ( result , arr [ i ] - arr [ i - 1 ] ) ; } return result ; }
Ref: 
def splitArray ( arr , N ) : NEW_LINE INDENT arr = sorted ( arr ) NEW_LINE result = 10 ** 9 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT result = min ( result , arr [ i ] - arr [ i - 1 ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT
Hyp: 
def splitArray ( arr , N ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE result = sys . maxsize NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT result = min ( result , arr [ i ] - arr [ i - 1 ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT

BLEU: 83.11
Edit Sim: 19


Src: 
int findMinX ( int num [ ] , int rem [ ] , int k ) { while ( true ) { int j ; for ( j = 0 ; j < k ; j ++ ) if ( x % num [ j ] != rem [ j ] ) break ; if ( j == k ) return x ; x ++ ; } }
Ref: 
def findMinX ( num , rem , k ) : NEW_LINE INDENT while ( True ) : NEW_LINE INDENT j = 0 ; NEW_LINE while ( j < k ) : NEW_LINE INDENT if ( x % num [ j ] != rem [ j ] ) : NEW_LINE INDENT break ; NEW_LINE DEDENT j += 1 ; NEW_LINE DEDENT if ( j == k ) : NEW_LINE INDENT return x ; NEW_LINE DEDENT x += 1 ; NEW_LINE DEDENT DEDENT
Hyp: 
def findMinX ( num , rem , k ) : NEW_LINE INDENT while ( True ) : NEW_LINE INDENT for j in range ( k ) : NEW_LINE INDENT if ( x % num [ j ] != rem [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( j == k ) : NEW_LINE INDENT return x NEW_LINE DEDENT x += 1 NEW_LINE DEDENT DEDENT

BLEU: 69.1
Edit Sim: 46


Src: 
int deleteElement ( int arr [ ] , int n , int x ) { int i ; for ( i = 0 ; i < n ; i ++ ) if ( arr [ i ] == x ) break ; if ( i < n ) { n = n - 1 ; for ( int j = i ; j < n ; j ++ ) arr [ j ] = arr [ j + 1 ] ; } return n ; }
Ref: 
def deleteElement ( arr , n , x ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == x ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( i < n ) : NEW_LINE INDENT n = n - 1 ; NEW_LINE for j in range ( i , n , 1 ) : NEW_LINE INDENT arr [ j ] = arr [ j + 1 ] NEW_LINE DEDENT DEDENT return n NEW_LINE DEDENT
Hyp: 
def deleteElement ( arr , n , x ) : NEW_LINE INDENT i = 0 NEW_LINE while i < n : NEW_LINE INDENT if arr [ i ] == x : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if i < n : NEW_LINE INDENT n = n - 1 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT arr [ j ] = arr [ j + 1 ] NEW_LINE DEDENT DEDENT return n NEW_LINE DEDENT

BLEU: 71.84
Edit Sim: 33


Src: 
int findLen ( int [ ] arr , int n , int m ) { Vector < Integer > filter = new Vector < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) if ( ( arr [ i ] & m ) == m ) filter . add ( arr [ i ] ) ; if ( filter . size ( ) == 0 ) return 0 ; int c_and = filter . get ( 0 ) ; for ( int i = 1 ; i < filter . size ( ) ; i ++ ) c_and &= filter . get ( i ) ; if ( c_and == m ) return filter . size ( ) ; return 0 ; }
Ref: 
def findLen ( arr , n , m ) : NEW_LINE INDENT filter = [ ] ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( arr [ i ] & m ) == m ) : NEW_LINE INDENT filter . append ( arr [ i ] ) ; NEW_LINE DEDENT DEDENT if ( len ( filter ) == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT c_and = filter [ 0 ] ; NEW_LINE for i in range ( 1 , len ( filter ) ) : NEW_LINE INDENT c_and &= filter [ i ] ; NEW_LINE DEDENT if ( c_and == m ) : NEW_LINE INDENT return len ( filter ) ; NEW_LINE DEDENT DEDENT
Hyp: 
def findLen ( arr , n , m ) : NEW_LINE INDENT filter = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] & m ) == m : NEW_LINE INDENT filter . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT if ( len ( filter ) == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT c_and = filter [ 0 ] NEW_LINE for i in range ( 1 , len ( filter ) ) : NEW_LINE INDENT c_and &= filter [ i ] NEW_LINE DEDENT if ( c_and == m ) : NEW_LINE INDENT return len ( filter ) NEW_LINE DEDENT return 0 NEW_LINE DEDENT

BLEU: 83.58
Edit Sim: 34


Src: 
int minRotation ( int input , int unlock_code ) { int rotation = 0 ; int input_digit , code_digit ; while ( input > 0 unlock_code > 0 ) { input_digit = input % 10 ; code_digit = unlock_code % 10 ; rotation += Math . min ( Math . abs ( input_digit - code_digit ) , 10 - Math . abs ( input_digit - code_digit ) ) ; input /= 10 ; unlock_code /= 10 ; } return rotation ; }
Ref: 
def minRotation ( input , unlock_code ) : NEW_LINE INDENT rotation = 0 ; NEW_LINE while ( input > 0 or unlock_code > 0 ) : NEW_LINE INDENT input_digit = input % 10 ; NEW_LINE code_digit = unlock_code % 10 ; NEW_LINE rotation += min ( abs ( input_digit - code_digit ) , 10 - abs ( input_digit - code_digit ) ) ; NEW_LINE input = int ( input / 10 ) ; NEW_LINE unlock_code = int ( unlock_code / 10 ) ; NEW_LINE DEDENT return rotation ; NEW_LINE DEDENT
Hyp: 
def minRotation ( input , unlock_code ) : NEW_LINE INDENT rotation = 0 NEW_LINE while ( input > 0 or unlock_code > 0 ) : NEW_LINE INDENT input_digit = input % 10 NEW_LINE code_digit = unlock_code % 10 NEW_LINE rotation += min ( abs ( input_digit - code_digit ) , 10 - abs ( input_digit - code_digit ) ) NEW_LINE input //= 10 NEW_LINE unlock_code //= 10 NEW_LINE DEDENT return rotation NEW_LINE DEDENT

BLEU: 64.07
Edit Sim: 54


Src: 
int findMinSum ( int num ) { int sum = 0 ; for ( int i = 2 ; i * i <= num ; i ++ ) { while ( num % i == 0 ) { sum += i ; num /= i ; } } sum += num ; return sum ; }
Ref: 
def findMinSum ( num ) : NEW_LINE INDENT sum = 0 NEW_LINE i = 2 NEW_LINE while ( i * i <= num ) : NEW_LINE INDENT while ( num % i == 0 ) : NEW_LINE INDENT sum += i NEW_LINE num /= i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT sum += num NEW_LINE return sum NEW_LINE DEDENT
Hyp: 
def findMinSum ( num ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 2 , num + 1 ) : NEW_LINE INDENT while ( num % i == 0 ) : NEW_LINE INDENT sum += i NEW_LINE num /= i NEW_LINE DEDENT DEDENT sum += num NEW_LINE return sum NEW_LINE DEDENT

BLEU: 71.13
Edit Sim: 41


Src: 
void countSubsequence ( String s , int n ) { int cntG = 0 , cntF = 0 , result = 0 , C = 0 ; for ( int i = 0 ; i < n ; i ++ ) { switch ( s . charAt ( i ) ) { case ' G ' : cntG ++ ; result += C ; break ; case ' F ' : cntF ++ ; C += cntG ; break ; default : continue ; } } System . out . println ( result ) ; }
Ref: 
def countSubsequence ( s , n ) : NEW_LINE INDENT cntG = 0 NEW_LINE cntF = 0 NEW_LINE result = 0 NEW_LINE C = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == ' G ' ) : NEW_LINE INDENT cntG += 1 NEW_LINE result += C NEW_LINE continue NEW_LINE DEDENT if ( s [ i ] == ' F ' ) : NEW_LINE INDENT cntF += 1 NEW_LINE C += cntG NEW_LINE continue NEW_LINE DEDENT else : NEW_LINE INDENT continue NEW_LINE DEDENT DEDENT print ( result ) NEW_LINE DEDENT
Hyp: 
def countSubsequence ( s , n ) : NEW_LINE INDENT cntG = 0 NEW_LINE cntF = 0 NEW_LINE result = 0 NEW_LINE C = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT switch ( s [ i ] ) : NEW_LINE INDENT cntG += 1 NEW_LINE result += C NEW_LINE break NEW_LINE DEDENT case ' F ' : NEW_LINE INDENT cntF += 1 NEW_LINE C += cntG NEW_LINE break NEW_LINE DEDENT default : NEW_LINE INDENT continue NEW_LINE DEDENT DEDENT print ( result ) NEW_LINE DEDENT

BLEU: 72.94
Edit Sim: 52


Src: 
long findNewString ( String s ) { long ans = 0 ; int [ ] freq = new int [ 26 ] ; int n = s . length ( ) ; Arrays . fill ( freq , 0 ) ; for ( int i = 0 ; i < ( int ) s . length ( ) ; ++ i ) { ans += freq [ s . charAt ( i ) - ' a ' ] ; freq [ s . charAt ( i ) - ' a ' ] ++ ; } return ans ; }
Ref: 
def findNewString ( s ) : NEW_LINE INDENT ans = 0 NEW_LINE freq = [ 0 ] * 26 NEW_LINE n = len ( s ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans += freq [ ord ( s [ i ] ) - ord ( ' a ' ) ] NEW_LINE freq [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
Hyp: 
def findNewString ( s ) : NEW_LINE INDENT ans = 0 ; NEW_LINE freq = [ 0 ] * 26 ; NEW_LINE n = len ( s ) ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT ans += freq [ ord ( s [ i ] ) - ord ( ' a ' ) ] ; NEW_LINE freq [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT

BLEU: 79.03
Edit Sim: 16


Src: 
int minimumValue ( int N , int K ) { return ( int ) Math . ceil ( ( double ) K / ( double ) N ) ; }
Ref: 
def minimumValue ( N , K ) : NEW_LINE INDENT return math . ceil ( K / N ) NEW_LINE DEDENT
Hyp: 
def minimumValue ( N , K ) : NEW_LINE INDENT return math . ceil ( K / N ) ; NEW_LINE DEDENT

BLEU: 89.22
Edit Sim: 2


Src: 
int linearSearch ( int arr [ ] , int n ) { int i ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == i ) return i ; } return - 1 ; }
Ref: 
def linearSearch ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if arr [ i ] is i : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
Hyp: 
def linearSearch ( arr , n ) : NEW_LINE INDENT i = 0 NEW_LINE while i < n : NEW_LINE INDENT if ( arr [ i ] == i ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ 2 , 3 , 4 , 10 , 40 ] NEW_LINE n = len ( arr ) NEW_LINE result = linearSearch ( arr , n ) NEW_LINE if ( result == - 1 ) : NEW_LINE INDENT print ( result , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Element ▁ is ▁ not ▁ present ▁ in ▁ array " ) NEW_LINE DEDENT

BLEU: 24.03
Edit Sim: 313


Src: 
void checkPoint ( int radius , int x , int y , float percent , float startAngle ) { float endAngle = 360 / percent + startAngle ; double polarradius = Math . sqrt ( x * x + y * y ) ; double Angle = Math . atan ( y / x ) ; if ( Angle >= startAngle && Angle <= endAngle && polarradius < radius ) System . out . print ( " Point " + " ( " + x + " , " + y + " ) " + " exist in the circle sectorNEW_LINE"); else System . out . print ( " Point " + " ( " + x + " , " + y + " ) " + " exist in the circle sectorNEW_LINE"); }
Ref: 
def checkPoint ( radius , x , y , percent , startAngle ) : NEW_LINE INDENT endAngle = 360 / percent + startAngle NEW_LINE polarradius = math . sqrt ( x * x + y * y ) NEW_LINE Angle = math . atan ( y / x ) NEW_LINE if ( Angle >= startAngle and Angle <= endAngle and polarradius < radius ) : NEW_LINE INDENT print ( " Point ▁ ( " , x , " , " , y , " ) ▁ " " exist ▁ in ▁ the ▁ circle ▁ sector " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Point ▁ ( " , x , " , " , y , " ) ▁ " " does ▁ not ▁ exist ▁ in ▁ the ▁ circle ▁ sector " ) NEW_LINE DEDENT DEDENT
Hyp: 
def checkPoint ( radius , x , y , percent , startAngle ) : NEW_LINE INDENT endAngle = 360 // percent + startAngle NEW_LINE polarradius = math . sqrt ( x * x + y * y ) NEW_LINE Angle = math . atan ( y / x ) NEW_LINE if ( Angle >= startAngle and Angle <= endAngle and polarradius < radius ) : NEW_LINE INDENT print ( " Point " , " ( " , x , " , y + " ) " , " exist in the circle sectorNEW_LINE DEDENT else : NEW_LINE INDENT print ( " Point " , " ( " , x , " , y , " ) " , " exist in the circle sectorNEW_LINE DEDENT DEDENT

BLEU: 68.22
Edit Sim: 55


Src: 
int cntKnightsAttackPawn ( int knights [ ] [ ] , int pawn [ ] , int M ) { int cntKnights = 0 ; for ( int i = 0 ; i < M ; i ++ ) { int X = Math . abs ( knights [ i ] [ 0 ] - pawn [ 0 ] ) ; int Y = Math . abs ( knights [ i ] [ 1 ] - pawn [ 1 ] ) ; if ( ( X == 1 && Y == 2 ) || ( X == 2 && Y == 1 ) ) { cntKnights ++ ; } } return cntKnights ; }
Ref: 
def cntKnightsAttackPawn ( knights , pawn , M ) : NEW_LINE INDENT cntKnights = 0 ; NEW_LINE for i in range ( M ) : NEW_LINE INDENT X = abs ( knights [ i ] [ 0 ] - pawn [ 0 ] ) ; NEW_LINE Y = abs ( knights [ i ] [ 1 ] - pawn [ 1 ] ) ; NEW_LINE if ( ( X == 1 and Y == 2 ) or ( X == 2 and Y == 1 ) ) : NEW_LINE INDENT cntKnights += 1 ; NEW_LINE DEDENT DEDENT return cntKnights ; NEW_LINE DEDENT
Hyp: 
def cntKnightsAttackPawn ( knights , pawn , M ) : NEW_LINE INDENT cntKnights = 0 NEW_LINE for i in range ( M ) : NEW_LINE INDENT X = abs ( knights [ i ] [ 0 ] - pawn [ 0 ] ) NEW_LINE Y = abs ( knights [ i ] [ 1 ] - pawn [ 1 ] ) NEW_LINE if ( ( X == 1 and Y == 2 ) or ( X == 2 and Y == 1 ) ) : NEW_LINE INDENT cntKnights += 1 NEW_LINE DEDENT DEDENT return cntKnights NEW_LINE DEDENT

BLEU: 87.62
Edit Sim: 10


Src: 
int placeValue ( int N , int num ) { int total = 1 , value = 0 , rem = 0 ; while ( true ) { rem = N % 10 ; N = N / 10 ; if ( rem == num ) { value = total * rem ; break ; } total = total * 10 ; } return value ; }
Ref: 
def placeValue ( N , num ) : NEW_LINE INDENT total = 1 NEW_LINE value = 0 NEW_LINE rem = 0 NEW_LINE while ( True ) : NEW_LINE INDENT rem = N % 10 NEW_LINE N = N // 10 NEW_LINE if ( rem == num ) : NEW_LINE INDENT value = total * rem NEW_LINE break NEW_LINE DEDENT total = total * 10 NEW_LINE DEDENT return value NEW_LINE DEDENT
Hyp: 
def placeValue ( N , num ) : NEW_LINE INDENT total = 1 NEW_LINE value = 0 NEW_LINE rem = 0 NEW_LINE while ( True ) : NEW_LINE INDENT rem = N % 10 NEW_LINE N = N // 10 NEW_LINE if ( rem == num ) : NEW_LINE INDENT value = total * rem NEW_LINE break NEW_LINE DEDENT total = total * 10 NEW_LINE DEDENT return value NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int printMaxAfterRemoval ( String s ) { boolean flag = false ; int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == '0' && flag == false ) { flag = true ; continue ; } else System . out . print ( s . charAt ( i ) ) ; } return 0 ; }
Ref: 
def printMaxAfterRemoval ( s ) : NEW_LINE INDENT flag = False NEW_LINE n = len ( s ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if s [ i ] == '0' and flag == False : NEW_LINE INDENT flag = True NEW_LINE continue NEW_LINE DEDENT else : NEW_LINE INDENT print ( s [ i ] , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
Hyp: 
def printMaxAfterRemoval ( s ) : NEW_LINE INDENT flag = 0 NEW_LINE n = len ( s ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( s [ i ] == '0' and flag == False ) : NEW_LINE INDENT flag = 1 NEW_LINE continue NEW_LINE DEDENT else : NEW_LINE INDENT print ( s [ i ] , end = ' ' ) NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT

BLEU: 76.91
Edit Sim: 33


Src: 
int sum ( int L , int R ) { int p = R / 6 ; int q = ( L - 1 ) / 6 ; int sumR = 3 * ( p * ( p + 1 ) ) ; int sumL = ( q * ( q + 1 ) ) * 3 ; return sumR - sumL ; }
Ref: 
def sumDivisible ( L , R ) : NEW_LINE INDENT p = int ( R / 6 ) NEW_LINE q = int ( ( L - 1 ) / 6 ) NEW_LINE sumR = 3 * ( p * ( p + 1 ) ) NEW_LINE sumL = ( q * ( q + 1 ) ) * 3 NEW_LINE return sumR - sumL NEW_LINE DEDENT
Hyp: 
def sum ( L , R ) : NEW_LINE INDENT p = R // 6 NEW_LINE q = ( L - 1 ) // 6 NEW_LINE sumR = 3 * ( p * ( p + 1 ) ) NEW_LINE sumL = ( q * ( q + 1 ) ) * 3 NEW_LINE return sumR - sumL NEW_LINE DEDENT

BLEU: 74.0
Edit Sim: 27


Src: 
double areaCircle ( double b ) { double area = ( double ) 3.1415926 * b * b ; return area ; }
Ref: 
def areaCircle ( b ) : NEW_LINE INDENT area = math . pi * b * b NEW_LINE return area NEW_LINE DEDENT
Hyp: 
def areaCircle ( b ) : NEW_LINE INDENT area = 3.1415926 * b * b ; NEW_LINE return area ; NEW_LINE DEDENT

BLEU: 63.5
Edit Sim: 13


Src: 
boolean isdecagonal ( int N ) { double n = ( 3 + Math . sqrt ( 16 * N + 9 ) ) / 8 ; return ( n - ( int ) n ) == 0 ; }
Ref: 
def isdecagonal ( N ) : NEW_LINE INDENT n = ( 3 + math . sqrt ( 16 * N + 9 ) ) / 8 NEW_LINE return ( n - int ( n ) ) == 0 NEW_LINE DEDENT
Hyp: 
def isdecagonal ( N ) : NEW_LINE INDENT n = ( 3 + math . sqrt ( 16 * N + 9 ) ) // 8 NEW_LINE return ( ( n - int ( n ) ) == 0 ) NEW_LINE DEDENT

BLEU: 83.87
Edit Sim: 5


Src: 
int oddLengthPalindrome ( int k ) { int palin = k ; k = k / 10 ; while ( k > 0 ) { int rev = k % 10 ; palin = ( palin * 10 ) + rev ; k = k / 10 ; } return palin ; }
Ref: 
def oddLengthPalindrome ( K ) : NEW_LINE INDENT palin = K NEW_LINE K = K // 10 NEW_LINE while ( K > 0 ) : NEW_LINE INDENT rev = K % 10 NEW_LINE palin = palin * 10 + rev NEW_LINE K = K // 10 NEW_LINE DEDENT return palin NEW_LINE DEDENT
Hyp: 
def oddLengthPalindrome ( k ) : NEW_LINE INDENT palin = k NEW_LINE k = k // 10 NEW_LINE while ( k > 0 ) : NEW_LINE INDENT rev = k % 10 NEW_LINE palin = ( palin * 10 ) + rev NEW_LINE k = k // 10 NEW_LINE DEDENT return palin NEW_LINE DEDENT

BLEU: 54.38
Edit Sim: 12


Src: 
int findValue ( int arr [ ] , int n , int k ) { for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == k ) k *= 2 ; return k ; }
Ref: 
def findValue ( arr , n , k ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == k ) : NEW_LINE INDENT k = k * 2 NEW_LINE DEDENT DEDENT return k NEW_LINE DEDENT
Hyp: 
def findValue ( arr , n , k ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == k ) : NEW_LINE INDENT k *= 2 NEW_LINE DEDENT DEDENT return k NEW_LINE DEDENT

BLEU: 89.96
Edit Sim: 5


Src: 
void countEvenSum ( int low , int high , int k ) { int even_count = high / 2 - ( low - 1 ) / 2 ; int odd_count = ( high + 1 ) / 2 - low / 2 ; long even_sum = 1 ; long odd_sum = 0 ; for ( int i = 0 ; i < k ; i ++ ) { long prev_even = even_sum ; long prev_odd = odd_sum ; even_sum = ( prev_even * even_count ) + ( prev_odd * odd_count ) ; odd_sum = ( prev_even * odd_count ) + ( prev_odd * even_count ) ; } System . out . println ( even_sum ) ; }
Ref: 
def countEvenSum ( low , high , k ) : NEW_LINE INDENT even_count = high / 2 - ( low - 1 ) / 2 NEW_LINE odd_count = ( high + 1 ) / 2 - low / 2 NEW_LINE even_sum = 1 NEW_LINE odd_sum = 0 NEW_LINE for i in range ( 0 , k ) : NEW_LINE INDENT prev_even = even_sum NEW_LINE prev_odd = odd_sum NEW_LINE even_sum = ( ( prev_even * even_count ) + ( prev_odd * odd_count ) ) NEW_LINE odd_sum = ( ( prev_even * odd_count ) + ( prev_odd * even_count ) ) NEW_LINE DEDENT print ( int ( even_sum ) ) NEW_LINE DEDENT
Hyp: 
def countEvenSum ( low , high , k ) : NEW_LINE INDENT even_count = high // 2 - ( low - 1 ) // 2 NEW_LINE odd_count = ( high + 1 ) // 2 - low // 2 NEW_LINE even_sum = 1 NEW_LINE odd_sum = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT prev_even = even_sum NEW_LINE prev_odd = odd_sum NEW_LINE even_sum = ( prev_even * even_count ) + ( prev_odd * odd_count ) NEW_LINE odd_sum = ( prev_even * odd_count ) + ( prev_odd * even_count ) NEW_LINE DEDENT print ( even_sum ) NEW_LINE DEDENT

BLEU: 76.18
Edit Sim: 24


Src: 
int clstNum ( int N ) { return ( N - 1 ) ; }
Ref: 
def clstNum ( N ) : NEW_LINE INDENT return ( N - 1 ) NEW_LINE DEDENT
Hyp: 
def clstNum ( N ) : NEW_LINE INDENT return ( N - 1 ) ; NEW_LINE DEDENT

BLEU: 85.79
Edit Sim: 2


Src: 
int countTriplets ( int [ ] A ) { int cnt = 0 ; HashMap < Integer , Integer > tuples = new HashMap < Integer , Integer > ( ) ; for ( int a : A ) for ( int b : A ) { if ( tuples . containsKey ( a & b ) ) tuples . put ( a & b , tuples . get ( a & b ) + 1 ) ; else tuples . put ( a & b , 1 ) ; } for ( int a : A ) for ( Map . Entry < Integer , Integer > t : tuples . entrySet ( ) ) if ( ( t . getKey ( ) & a ) == 0 ) cnt += t . getValue ( ) ; return cnt ; }
Ref: 
def countTriplets ( A ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE tuples = { } ; NEW_LINE for a in A : NEW_LINE INDENT for b in A : NEW_LINE INDENT if ( a & b ) in tuples : NEW_LINE INDENT tuples [ a & b ] += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT tuples [ a & b ] = 1 ; NEW_LINE DEDENT DEDENT DEDENT for a in A : NEW_LINE INDENT for t in tuples : NEW_LINE INDENT if ( ( t & a ) == 0 ) : NEW_LINE INDENT cnt += tuples [ t ] ; NEW_LINE DEDENT DEDENT DEDENT return cnt ; NEW_LINE DEDENT
Hyp: 
def countTriplets ( A ) : NEW_LINE INDENT cnt = 0 NEW_LINE tuples = { } NEW_LINE for a in A : NEW_LINE INDENT for b in A : NEW_LINE INDENT if a & b in tuples : NEW_LINE INDENT tuples [ a & b ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT tuples [ a & b ] = 1 NEW_LINE DEDENT DEDENT for a in A : NEW_LINE INDENT for t in tuples : NEW_LINE INDENT if ( t [ Key ] & a ) == 0 : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT

BLEU: 71.29
Edit Sim: 52


Src: 
int countPaths ( int n , int m ) { int dp [ ] [ ] = new int [ n + 1 ] [ m + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = 1 ; for ( int i = 0 ; i <= m ; i ++ ) dp [ 0 ] [ i ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= m ; j ++ ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] ; return dp [ n ] [ m ] ; }
Ref: 
def countPaths ( n , m ) : NEW_LINE INDENT if ( n == 0 or m == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return ( countPaths ( n - 1 , m ) + countPaths ( n , m - 1 ) ) NEW_LINE DEDENT
Hyp: 
def countPaths ( n , m ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( m + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = 1 NEW_LINE DEDENT for i in range ( m + 1 ) : NEW_LINE INDENT dp [ 0 ] [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , m + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT return dp [ n ] [ m ] NEW_LINE DEDENT

BLEU: 12.66
Edit Sim: 337


Src: 
int getMaxGold ( int gold [ ] [ ] , int m , int n ) { int goldTable [ ] [ ] = new int [ m ] [ n ] ; for ( int [ ] rows : goldTable ) Arrays . fill ( rows , 0 ) ; for ( int col = n - 1 ; col >= 0 ; col -- ) { for ( int row = 0 ; row < m ; row ++ ) { int right = ( col == n - 1 ) ? 0 : goldTable [ row ] [ col + 1 ] ; int right_up = ( row == 0 col == n - 1 ) ? 0 : goldTable [ row - 1 ] [ col + 1 ] ; int right_down = ( row == m - 1 col == n - 1 ) ? 0 : goldTable [ row + 1 ] [ col + 1 ] ; goldTable [ row ] [ col ] = gold [ row ] [ col ] + Math . max ( right , Math . max ( right_up , right_down ) ) ; } } int res = goldTable [ 0 ] [ 0 ] ; for ( int i = 1 ; i < m ; i ++ ) res = Math . max ( res , goldTable [ i ] [ 0 ] ) ; return res ; }
Ref: 
def getMaxGold ( gold , m , n ) : NEW_LINE INDENT goldTable = [ [ 0 for i in range ( n ) ] for j in range ( m ) ] NEW_LINE for col in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT for row in range ( m ) : NEW_LINE INDENT if ( col == n - 1 ) : NEW_LINE INDENT right = 0 NEW_LINE DEDENT else : NEW_LINE INDENT right = goldTable [ row ] [ col + 1 ] NEW_LINE DEDENT if ( row == 0 or col == n - 1 ) : NEW_LINE INDENT right_up = 0 NEW_LINE DEDENT else : NEW_LINE INDENT right_up = goldTable [ row - 1 ] [ col + 1 ] NEW_LINE DEDENT if ( row == m - 1 or col == n - 1 ) : NEW_LINE INDENT right_down = 0 NEW_LINE DEDENT else : NEW_LINE INDENT right_down = goldTable [ row + 1 ] [ col + 1 ] NEW_LINE DEDENT goldTable [ row ] [ col ] = gold [ row ] [ col ] + max ( right , right_up , right_down ) NEW_LINE DEDENT DEDENT res = goldTable [ 0 ] [ 0 ] NEW_LINE for i in range ( 1 , m ) : NEW_LINE INDENT res = max ( res , goldTable [ i ] [ 0 ] ) NEW_LINE DEDENT return res NEW_LINE DEDENT
Hyp: 
def getMaxGold ( gold , m , n ) : NEW_LINE INDENT goldTable = [ [ 0 for col in range ( n - 1 ) ] for row in range ( m ) ] NEW_LINE for row in range ( n ) : NEW_LINE INDENT rows . append ( gold [ row ] [ col + 1 ] ) NEW_LINE DEDENT for col in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT right = ( col == n - 1 ) ? 0 : goldTable [ row ] [ col + 1 ] NEW_LINE right_up = ( row == m - 1 or col == n - 1 ) ? 0 : goldTable [ row - 1 ] [ col + 1 ] NEW_LINE right_down = ( row == m - 1 or col == n - 1 ) ? 0 : goldTable [ row + 1 ] [ col + 1 ] NEW_LINE goldTable [ row ] [ col ] + max ( right , max ( right_up , right_down ) ) NEW_LINE DEDENT DEDENT res = goldTable [ 0 ] [ 0 ] NEW_LINE for i in range ( 1 , m ) : NEW_LINE INDENT res = max ( res , goldTable [ i ] [ 0 ] ) NEW_LINE DEDENT return res NEW_LINE DEDENT

BLEU: 69.95
Edit Sim: 337


Src: 
void removeAll ( int arr [ ] , int n ) { if ( arr [ 0 ] < arr [ n - 1 ] ) System . out . print ( " YES " ) ; else System . out . print ( " NO " ) ; }
Ref: 
def removeAll ( arr , n ) : NEW_LINE INDENT if arr [ 0 ] < arr [ n - 1 ] : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
Hyp: 
def removeAll ( arr , n ) : NEW_LINE INDENT if ( arr [ 0 ] < arr [ n - 1 ] ) : NEW_LINE INDENT print ( " YES " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) ; NEW_LINE DEDENT DEDENT

BLEU: 79.01
Edit Sim: 8


Src: 
int ceilSearch ( int arr [ ] , int low , int high , int x ) { int i ; if ( x <= arr [ low ] ) return low ; for ( i = low ; i < high ; i ++ ) { if ( arr [ i ] == x ) return i ; if ( arr [ i ] < x && arr [ i + 1 ] >= x ) return i + 1 ; } return - 1 ; }
Ref: 
def ceilSearch ( arr , low , high , x ) : NEW_LINE INDENT if x <= arr [ low ] : NEW_LINE INDENT return low NEW_LINE DEDENT i = low NEW_LINE for i in range ( high ) : NEW_LINE INDENT if arr [ i ] == x : NEW_LINE INDENT return i NEW_LINE DEDENT if arr [ i ] < x and arr [ i + 1 ] >= x : NEW_LINE INDENT return i + 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ 1 , 2 , 8 , 10 , 10 , 12 , 19 ] NEW_LINE n = len ( arr ) NEW_LINE x = 3 NEW_LINE index = ceilSearch ( arr , 0 , n - 1 , x ) ; NEW_LINE if index == - 1 : NEW_LINE INDENT print ( " Ceiling ▁ of ▁ % d ▁ doesn ' t ▁ exist ▁ in ▁ array ▁ " % x ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " ceiling ▁ of ▁ % d ▁ is ▁ % d " % ( x , arr [ index ] ) ) NEW_LINE DEDENT
Hyp: 
def ceilSearch ( arr , low , high , x ) : NEW_LINE INDENT if ( x <= arr [ low ] ) : NEW_LINE INDENT return low NEW_LINE DEDENT for i in range ( low , high + 1 ) : NEW_LINE INDENT if ( arr [ i ] == x ) : NEW_LINE INDENT return i NEW_LINE DEDENT if ( arr [ i ] < x and arr [ i + 1 ] >= x ) : NEW_LINE INDENT return i + 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT

BLEU: 25.49
Edit Sim: 411


Src: 
void minNum ( int n ) { if ( n < 3 ) System . out . println ( - 1 ) ; else System . out . println ( 210 * ( ( int ) ( Math . pow ( 10 , n - 1 ) / 210 ) + 1 ) ) ; }
Ref: 
def minNum ( n ) : NEW_LINE INDENT if n < 3 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 210 * ( 10 ** ( n - 1 ) // 210 + 1 ) ) NEW_LINE DEDENT DEDENT
Hyp: 
def minNum ( n ) : NEW_LINE INDENT if ( n < 3 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 210 * ( int ) ( pow ( 10 , n - 1 ) / 210 ) + 1 ) ) NEW_LINE DEDENT DEDENT

BLEU: 67.51
Edit Sim: 22


Src: 
void findSumOfAllSubsets ( int [ ] arr , int n , int k ) { int factorial_N = 1 , factorial_d = 1 , factorial_D = 1 ; for ( int i = 1 ; i <= n - 1 ; i ++ ) factorial_N *= i ; for ( int i = 1 ; i <= k - 1 ; i ++ ) factorial_d *= i ; for ( int i = 1 ; i <= n - k ; i ++ ) factorial_D *= i ; int freq = factorial_N / ( factorial_d * factorial_D ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; sum = sum * freq ; System . out . println ( " Sum ▁ of ▁ all ▁ subsets ▁ of ▁ size ▁ = ▁ " + k + " ▁ is ▁ = > ▁ " + sum ) ; }
Ref: 
def findSumOfAllSubsets ( arr , n , k ) : NEW_LINE INDENT factorial_N = 1 NEW_LINE factorial_d = 1 NEW_LINE factorial_D = 1 NEW_LINE for i in range ( 1 , n , 1 ) : NEW_LINE INDENT factorial_N *= i NEW_LINE DEDENT for i in range ( 1 , k , 1 ) : NEW_LINE INDENT factorial_d *= i NEW_LINE DEDENT for i in range ( 1 , n - k + 1 , 1 ) : NEW_LINE INDENT factorial_D *= i NEW_LINE DEDENT freq = factorial_N // ( factorial_d * factorial_D ) NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT sum = sum * freq NEW_LINE print ( " Sum ▁ of ▁ all ▁ subsets ▁ of ▁ size ▁ = ▁ " , k , " ▁ is ▁ = > " , sum ) NEW_LINE DEDENT
Hyp: 
def findSumOfAllSubsets ( arr , n , k ) : NEW_LINE INDENT factorial_N = 1 NEW_LINE factorial_d = 1 NEW_LINE factorial_D = 1 NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT factorial_N *= i NEW_LINE DEDENT for i in range ( 1 , k - 1 ) : NEW_LINE INDENT factorial_d *= i NEW_LINE DEDENT for i in range ( 1 , n - k + 1 ) : NEW_LINE INDENT factorial_D *= i NEW_LINE DEDENT freq = factorial_N // ( factorial_d * factorial_D ) NEW_LINE sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT sum = sum * freq NEW_LINE print ( " Sum ▁ of ▁ all ▁ subsets ▁ = " , k , " ▁ is ▁ = > ▁ " , sum ) NEW_LINE DEDENT

BLEU: 89.04
Edit Sim: 26


Src: 
void distinct ( String [ ] S , int M ) { int count = 0 ; for ( int i = 0 ; i < S . length ; i ++ ) { Set < Character > set = new HashSet < > ( ) ; for ( int j = 0 ; j < S [ i ] . length ( ) ; j ++ ) { if ( ! set . contains ( S [ i ] . charAt ( j ) ) ) set . add ( S [ i ] . charAt ( j ) ) ; } int c = set . size ( ) ; if ( c <= M ) count += 1 ; } System . out . println ( count ) ; }
Ref: 
def distinct ( S , M ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( S ) ) : NEW_LINE INDENT c = len ( set ( [ d for d in S [ i ] ] ) ) NEW_LINE if ( c <= M ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT
Hyp: 
def distinct ( S , M ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( S ) ) : NEW_LINE INDENT set = set ( ) NEW_LINE for j in range ( len ( S [ i ] ) ) : NEW_LINE INDENT if ( S [ i ] [ j ] not in set ) : NEW_LINE INDENT set . add ( S [ i ] [ j ] ) NEW_LINE DEDENT DEDENT c = len ( set ) NEW_LINE if ( c <= M ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT

BLEU: 52.19
Edit Sim: 158


Src: 
void findMaximumProfit ( int [ ] arr , int M , int N ) { PriorityQueue < Integer > max_heap = new PriorityQueue < > ( ( a , b ) -> b - a ) ; int maxProfit = 0 ; for ( int i = 0 ; i < N ; i ++ ) max_heap . add ( arr [ i ] ) ; while ( M > 0 ) { M -- ; int X = max_heap . poll ( ) ; maxProfit += X ; max_heap . add ( X - 1 ) ; } System . out . println ( maxProfit ) ; }
Ref: 
def findMaximumProfit ( arr , M , N ) : NEW_LINE INDENT max_heap = [ ] NEW_LINE maxProfit = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT max_heap . append ( arr [ i ] ) NEW_LINE DEDENT max_heap . sort ( ) NEW_LINE max_heap . reverse ( ) NEW_LINE while ( M > 0 ) : NEW_LINE INDENT M -= 1 NEW_LINE X = max_heap [ 0 ] NEW_LINE max_heap . pop ( 0 ) NEW_LINE maxProfit += X NEW_LINE max_heap . append ( X - 1 ) NEW_LINE max_heap . sort ( ) NEW_LINE max_heap . reverse ( ) NEW_LINE DEDENT print ( maxProfit ) NEW_LINE DEDENT
Hyp: 
def findMaximumProfit ( arr , M , N ) : NEW_LINE INDENT max_heap = PriorityQueue ( ) NEW_LINE maxProfit = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT max_heap . append ( arr [ i ] ) NEW_LINE DEDENT maxProfit += 0 NEW_LINE max_heap . append ( arr [ i ] ) NEW_LINE DEDENT print ( maxProfit ) NEW_LINE DEDENT

BLEU: 35.39
Edit Sim: 251


Src: 
int minimumCost ( int cost [ ] , int n ) { int dp1 = 0 , dp2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int dp0 = cost [ i ] + Math . min ( dp1 , dp2 ) ; dp2 = dp1 ; dp1 = dp0 ; } return Math . min ( dp1 , dp2 ) ; }
Ref: 
def minimumCost ( cost , n ) : NEW_LINE INDENT dp1 = 0 NEW_LINE dp2 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp0 = cost [ i ] + min ( dp1 , dp2 ) NEW_LINE dp2 = dp1 NEW_LINE dp1 = dp0 NEW_LINE DEDENT return min ( dp1 , dp2 ) NEW_LINE DEDENT
Hyp: 
def minimumCost ( cost , n ) : NEW_LINE INDENT dp1 = 0 NEW_LINE dp2 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp0 = cost [ i ] + min ( dp1 , dp2 ) NEW_LINE dp2 = dp1 NEW_LINE dp1 = dp0 NEW_LINE DEDENT return min ( dp1 , dp2 ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int nth_group ( int n ) { return n * ( 2 * ( int ) Math . pow ( n , 2 ) + 1 ) ; }
Ref: 
def nth_group ( n ) : NEW_LINE INDENT return n * ( 2 * pow ( n , 2 ) + 1 ) NEW_LINE DEDENT
Hyp: 
def nth_group ( n ) : NEW_LINE INDENT return n * ( 2 * pow ( n , 2 ) + 1 ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int evenbittogglenumber ( int n ) { int res = 0 , count = 0 ; for ( int temp = n ; temp > 0 ; temp >>= 1 ) { if ( count % 2 == 1 ) res |= ( 1 << count ) ; count ++ ; } return n ^ res ; }
Ref: 
def evenbittogglenumber ( n ) : NEW_LINE INDENT res = 0 NEW_LINE count = 0 NEW_LINE temp = n NEW_LINE while ( temp > 0 ) : NEW_LINE INDENT if ( count % 2 == 1 ) : NEW_LINE INDENT res = res | ( 1 << count ) NEW_LINE DEDENT count = count + 1 NEW_LINE temp >>= 1 NEW_LINE DEDENT return n ^ res NEW_LINE DEDENT
Hyp: 
def evenbittogglenumber ( n ) : NEW_LINE INDENT res = 0 NEW_LINE count = 0 NEW_LINE temp = n NEW_LINE while ( temp > 0 ) : NEW_LINE INDENT if ( count % 2 == 1 ) : NEW_LINE INDENT res |= ( 1 << count ) NEW_LINE DEDENT count += 1 NEW_LINE temp >>= 1 NEW_LINE DEDENT return n ^ res NEW_LINE DEDENT

BLEU: 86.42
Edit Sim: 16


Src: 
int numberOfWays ( int x ) { int dp [ ] = new int [ x + 1 ] ; dp [ 0 ] = dp [ 1 ] = 1 ; for ( int i = 2 ; i <= x ; i ++ ) dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; return dp [ x ] ; }
Ref: 
def numberOfWays ( x ) : NEW_LINE INDENT dp = [ ] NEW_LINE dp . append ( 1 ) NEW_LINE dp . append ( 1 ) NEW_LINE for i in range ( 2 , x + 1 ) : NEW_LINE INDENT dp . append ( dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ) NEW_LINE DEDENT return ( dp [ x ] ) NEW_LINE DEDENT
Hyp: 
def numberOfWays ( x ) : NEW_LINE INDENT dp = [ ] NEW_LINE dp . append ( 1 ) NEW_LINE dp . append ( 1 ) NEW_LINE for i in range ( 2 , x + 1 ) : NEW_LINE INDENT dp . append ( dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ) NEW_LINE DEDENT return ( dp [ x ] ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
long NthTerm ( long n ) { long x = ( 3 * n * n ) % 1000000009 ; return ( x - n + 1000000009 ) % 1000000009 ; }
Ref: 
def NthTerm ( N ) : NEW_LINE INDENT x = ( 3 * N * N ) % 1000000009 NEW_LINE return ( ( x - N + 1000000009 ) % 1000000009 ) NEW_LINE DEDENT
Hyp: 
def NthTerm ( n ) : NEW_LINE INDENT x = ( 3 * n * n ) % 1000000009 NEW_LINE return ( x - n + 1000000009 ) % 1000000009 NEW_LINE DEDENT

BLEU: 57.31
Edit Sim: 8


Src: 
double calculateSide ( double n , double r ) { double theta , theta_in_radians ; theta = 360 / n ; theta_in_radians = theta * 3.14 / 180 ; return 2 * r * Math . sin ( theta_in_radians / 2 ) ; }
Ref: 
def calculateSide ( n , r ) : NEW_LINE INDENT theta = 360 / n NEW_LINE theta_in_radians = theta * 3.14 / 180 NEW_LINE return 2 * r * sin ( theta_in_radians / 2 ) NEW_LINE DEDENT
Hyp: 
def calculateSide ( n , r ) : NEW_LINE INDENT theta = 360 / n NEW_LINE theta_in_radians = theta * 3.14 / 180 NEW_LINE return 2 * r * math . sin ( theta_in_radians / 2 ) NEW_LINE DEDENT

BLEU: 90.76
Edit Sim: 7


Src: 
void getElements ( int a , int arr [ ] , int n ) { int elements [ ] = new int [ n + 1 ] ; elements [ 0 ] = a ; for ( int i = 0 ; i < n ; i ++ ) { elements [ i + 1 ] = arr [ i ] ^ elements [ i ] ; } for ( int i = 0 ; i < n + 1 ; i ++ ) System . out . print ( elements [ i ] + " ▁ " ) ; }
Ref: 
def getElements ( a , arr , n ) : NEW_LINE INDENT elements = [ 1 for i in range ( n + 1 ) ] NEW_LINE elements [ 0 ] = a NEW_LINE for i in range ( n ) : NEW_LINE INDENT elements [ i + 1 ] = arr [ i ] ^ elements [ i ] NEW_LINE DEDENT for i in range ( n + 1 ) : NEW_LINE INDENT print ( elements [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
Hyp: 
def getElements ( a , arr , n ) : NEW_LINE INDENT elements = [ 0 ] * ( n + 1 ) NEW_LINE elements [ 0 ] = a NEW_LINE for i in range ( n ) : NEW_LINE INDENT elements [ i + 1 ] = arr [ i ] ^ elements [ i ] NEW_LINE DEDENT for i in range ( n + 1 ) : NEW_LINE INDENT print ( elements [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT

BLEU: 90.1
Edit Sim: 16


Src: 
int maxXOR ( int arr [ ] , int n ) { int xorArr = 0 ; for ( int i = 0 ; i < n ; i ++ ) xorArr ^= arr [ i ] ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) ans = Math . max ( ans , ( xorArr ^ arr [ i ] ) ) ; return ans ; }
Ref: 
def maxXOR ( arr , n ) : NEW_LINE INDENT xorArr = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT xorArr ^= arr [ i ] NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans = max ( ans , ( xorArr ^ arr [ i ] ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
Hyp: 
def maxXOR ( arr , n ) : NEW_LINE INDENT xorArr = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT xorArr ^= arr [ i ] ; NEW_LINE DEDENT ans = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans = max ( ans , ( xorArr ^ arr [ i ] ) ) ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT

BLEU: 82.4
Edit Sim: 10


Src: 
int findCountOfPairs ( int a , int b , int n ) { int ans = 0 ; ans += n * ( a / n ) * ( b / n ) ; ans += ( a / n ) * ( b % n ) ; ans += ( a % n ) * ( b / n ) ; ans += ( ( a % n ) + ( b % n ) ) / n ; return ans ; }
Ref: 
def findCountOfPairs ( a , b , n ) : NEW_LINE INDENT ans = 0 NEW_LINE ans += n * int ( a / n ) * int ( b / n ) NEW_LINE ans += int ( a / n ) * ( b % n ) NEW_LINE ans += ( a % n ) * int ( b / n ) NEW_LINE ans += int ( ( ( a % n ) + ( b % n ) ) / n ) ; NEW_LINE return ans NEW_LINE DEDENT
Hyp: 
def findCountOfPairs ( a , b , n ) : NEW_LINE INDENT ans = 0 NEW_LINE ans += n * ( a / n ) * ( b / n ) NEW_LINE ans += ( a / n ) * ( b % n ) NEW_LINE ans += ( a % n ) * ( b / n ) NEW_LINE ans += ( ( a % n ) + ( b % n ) ) // n NEW_LINE return ans NEW_LINE DEDENT

BLEU: 78.22
Edit Sim: 27


Src: 
int maximumSum ( int [ ] a , int [ ] b , int n , int index , int lastpicked ) { if ( index == n ) return 0 ; int option1 = 0 , option2 = 0 ; if ( lastpicked == - 1 a [ lastpicked ] != a [ index ] ) option1 = b [ index ] + maximumSum ( a , b , n , index + 1 , index ) ; option2 = maximumSum ( a , b , n , index + 1 , lastpicked ) ; return Math . max ( option1 , option2 ) ; }
Ref: 
def maximumSum ( a , b , n , index , lastpicked ) : NEW_LINE INDENT if ( index == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT option1 = 0 NEW_LINE option2 = 0 NEW_LINE if ( lastpicked == - 1 or a [ lastpicked ] != a [ index ] ) : NEW_LINE INDENT option1 = b [ index ] + maximumSum ( a , b , n , index + 1 , index ) NEW_LINE DEDENT option2 = maximumSum ( a , b , n , index + 1 , lastpicked ) NEW_LINE return max ( option1 , option2 ) NEW_LINE DEDENT
Hyp: 
def maximumSum ( a , b , n , index , lastpicked ) : NEW_LINE INDENT if ( index == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT option1 = 0 NEW_LINE option2 = 0 NEW_LINE if ( lastpicked == - 1 or a [ lastpicked ] != a [ index ] ) : NEW_LINE INDENT option1 = b [ index ] + maximumSum ( a , b , n , index + 1 , index ) NEW_LINE option2 = maximumSum ( a , b , n , index + 1 , lastpicked ) NEW_LINE return max ( option1 , option2 ) NEW_LINE DEDENT

BLEU: 97.61
Edit Sim: 7


Src: 
void findLine ( int distance , float degree ) { float x = ( float ) ( degree * 3.14159 / 180 ) ; if ( degree > 90 ) { System . out . print ( " Not ▁ Possible " ) ; return ; } float result_1 = ( float ) Math . sin ( x ) ; float result_2 = ( float ) Math . cos ( x ) ; System . out . print ( String . format ( " % .2f " , result_2 ) + " x ▁ + " + String . format ( " % .2f " , result_1 ) + " y ▁ = ▁ " + distance ) ; }
Ref: 
def findLine ( distance , degree ) : NEW_LINE INDENT x = degree * 3.14159 / 180 NEW_LINE if ( degree > 90 ) : NEW_LINE INDENT print ( " Not ▁ Possible " ) NEW_LINE return NEW_LINE DEDENT result_1 = math . sin ( x ) NEW_LINE result_2 = math . cos ( x ) NEW_LINE print ( ' % .2f ' % result_2 , " x ▁ + " , ' % .2f ' % result_1 , " y ▁ = ▁ " , distance , sep = " " ) NEW_LINE DEDENT
Hyp: 
def findLine ( distance , degree ) : NEW_LINE INDENT x = ( degree * 3.14159 / 180 ) NEW_LINE if ( degree > 90 ) : NEW_LINE INDENT print ( " Not ▁ Possible " ) NEW_LINE return NEW_LINE DEDENT result_1 = math . sin ( x ) NEW_LINE result_2 = math . cos ( x ) NEW_LINE print ( " % .2f " , result_2 ) , " x ▁ + " , format ( " % .2f " , result_1 ) , " y ▁ = " , distance ) NEW_LINE DEDENT

BLEU: 73.67
Edit Sim: 37


Src: 
int multiplyWith3Point5 ( int x ) { return ( x << 1 ) + x + ( x >> 1 ) ; }
Ref: 
def multiplyWith3Point5 ( x ) : NEW_LINE INDENT return ( x << 1 ) + x + ( x >> 1 ) NEW_LINE DEDENT
Hyp: 
def multiplyWith3Point5 ( x ) : NEW_LINE INDENT return ( x << 1 ) + x + ( x >> 1 ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
void sumOfSquaredDifferences ( int arr [ ] , int N ) { int ans = 0 ; int sumA = 0 , sumB = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sumA += ( arr [ i ] * arr [ i ] ) ; sumB += arr [ i ] ; } sumA = N * sumA ; sumB = ( sumB * sumB ) ; ans = sumA - sumB ; System . out . println ( ans ) ; }
Ref: 
def sumOfSquaredDifferences ( arr , N ) : NEW_LINE INDENT ans = 0 NEW_LINE sumA , sumB = 0 , 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sumA += ( arr [ i ] * arr [ i ] ) NEW_LINE sumB += arr [ i ] NEW_LINE DEDENT sumA = N * sumA NEW_LINE sumB = ( sumB * sumB ) NEW_LINE ans = sumA - sumB NEW_LINE print ( ans ) NEW_LINE DEDENT
Hyp: 
def sumOfSquaredDifferences ( arr , N ) : NEW_LINE INDENT ans = 0 ; NEW_LINE sumA = 0 ; NEW_LINE sumB = 0 ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT sumA += ( arr [ i ] * arr [ i ] ) ; NEW_LINE sumB += arr [ i ] ; NEW_LINE DEDENT sumA = N * sumA ; NEW_LINE sumB = ( sumB * sumB ) ; NEW_LINE ans = sumA - sumB ; NEW_LINE print ( ans ) ; NEW_LINE DEDENT

BLEU: 70.99
Edit Sim: 31


Src: 
String getWinner ( String str , int len ) { int total = 0 ; for ( int i = 0 ; i < len ; i ++ ) { if ( str . charAt ( i ) == ' S ' ) { total ++ ; } } if ( ( total % 2 ) == 1 ) return " First " ; return " Second " ; }
Ref: 
def getWinner ( string , length ) : NEW_LINE INDENT total = 0 ; NEW_LINE for i in range ( length ) : NEW_LINE INDENT if ( string [ i ] == ' S ' ) : NEW_LINE INDENT total += 1 ; NEW_LINE DEDENT DEDENT if ( ( total % 2 ) == 1 ) : NEW_LINE INDENT return " First " ; NEW_LINE DEDENT return " Second " ; NEW_LINE DEDENT
Hyp: 
def getWinner ( st , l ) : NEW_LINE INDENT total = 0 NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( st [ i ] == ' S ' ) : NEW_LINE INDENT total += 1 NEW_LINE DEDENT DEDENT if ( total % 2 ) == 1 : NEW_LINE INDENT return " First " NEW_LINE DEDENT return " Second " NEW_LINE DEDENT

BLEU: 66.05
Edit Sim: 30


Src: 
void precompute ( ) { int fact = 1 ; for ( int i = 1 ; i <= 18 ; i ++ ) { fact = fact * i ; m . put ( fact , i ) ; } }
Ref: 
def precompute ( ) : NEW_LINE INDENT fact = 1 ; NEW_LINE for i in range ( 1 , 19 ) : NEW_LINE INDENT fact = fact * i ; NEW_LINE m [ fact ] = i ; NEW_LINE DEDENT DEDENT
Hyp: 
def precompute ( ) : NEW_LINE INDENT fact = 1 NEW_LINE for i in range ( 1 , 18 ) : NEW_LINE INDENT fact = fact * i NEW_LINE m [ fact ] = i NEW_LINE DEDENT DEDENT

BLEU: 73.9
Edit Sim: 7


Src: 
void circle_equation ( double x1 , double y1 , double r ) { double a = - 2 * x1 ; double b = - 2 * y1 ; double c = ( r * r ) - ( x1 * x1 ) - ( y1 * y1 ) ; System . out . print ( " x ^ 2 ▁ + ▁ ( " + a + " ▁ x ) ▁ + ▁ " ) ; System . out . print ( " y ^ 2 ▁ + ▁ ( " + b + " ▁ y ) ▁ = ▁ " ) ; System . out . println ( c + " . " ) ; }
Ref: 
def circle_equation ( x1 , y1 , r ) : NEW_LINE INDENT a = - 2 * x1 ; NEW_LINE b = - 2 * y1 ; NEW_LINE c = ( r * r ) - ( x1 * x1 ) - ( y1 * y1 ) ; NEW_LINE print ( " x ^ 2 ▁ + ▁ ( " , a , " x ) ▁ + ▁ " , end = " " ) ; NEW_LINE print ( " y ^ 2 ▁ + ▁ ( " , b , " y ) ▁ = ▁ " , end = " " ) ; NEW_LINE print ( c , " . " ) ; NEW_LINE DEDENT
Hyp: 
def circle_equation ( x1 , y1 , r ) : NEW_LINE INDENT a = - 2 * x1 NEW_LINE b = - 2 * y1 NEW_LINE c = ( r * r ) - ( x1 * x1 ) - ( y1 * y1 ) NEW_LINE print ( " x ^ 2 ▁ + ▁ ( " , a , " ▁ x ) ▁ + ▁ " ) NEW_LINE print ( " y ^ 2 ▁ + ▁ ( " , b , " ▁ y ) ▁ = ▁ " ) NEW_LINE print ( c , end = " . " ) NEW_LINE DEDENT

BLEU: 74.83
Edit Sim: 46


Src: 
int Numberofways ( int n ) { int count = 0 ; for ( int a = 1 ; a < n ; a ++ ) { for ( int b = 0 ; b < n ; b ++ ) { int c = n - ( a + b ) ; if ( a + b > c && a + c > b && b + c > a ) { count ++ ; } } } return count ; }
Ref: 
def Numberofways ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for a in range ( 1 , n ) : NEW_LINE INDENT for b in range ( 1 , n ) : NEW_LINE INDENT c = n - ( a + b ) NEW_LINE if ( a < b + c and b < a + c and c < a + b ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count ; NEW_LINE DEDENT
Hyp: 
def Numberofways ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for a in range ( 1 , n ) : NEW_LINE INDENT for b in range ( n ) : NEW_LINE INDENT c = n - ( a + b ) NEW_LINE if ( a + b > c and a + c > b and b + c > a ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT

BLEU: 77.74
Edit Sim: 18


Src: 
void performQueries ( String str , int n , int queries [ ] [ ] , int q ) { int ptr = 0 ; for ( int i = 0 ; i < q ; i ++ ) { if ( queries [ i ] [ 0 ] == 1 ) { ptr = ( ptr + queries [ i ] [ 1 ] ) % n ; } else { int k = queries [ i ] [ 1 ] ; int index = ( ptr + k - 1 ) % n ; System . out . println ( str . charAt ( index ) ) ; } } }
Ref: 
def performQueries ( string , n , queries , q ) : NEW_LINE INDENT ptr = 0 ; NEW_LINE for i in range ( q ) : NEW_LINE INDENT if ( queries [ i ] [ 0 ] == 1 ) : NEW_LINE INDENT ptr = ( ptr + queries [ i ] [ 1 ] ) % n ; NEW_LINE DEDENT else : NEW_LINE INDENT k = queries [ i ] [ 1 ] ; NEW_LINE index = ( ptr + k - 1 ) % n ; NEW_LINE print ( string [ index ] ) ; NEW_LINE DEDENT DEDENT DEDENT
Hyp: 
def performQueries ( string , n , queries , q ) : NEW_LINE INDENT ptr = 0 NEW_LINE for i in range ( q ) : NEW_LINE INDENT if ( queries [ i ] [ 0 ] == 1 ) : NEW_LINE INDENT ptr = ( ptr + queries [ i ] [ 1 ] ) % n NEW_LINE DEDENT else : NEW_LINE INDENT k = queries [ i ] [ 1 ] NEW_LINE index = ( ptr + k - 1 ) % n NEW_LINE print ( string [ index ] ) NEW_LINE DEDENT DEDENT DEDENT

BLEU: 87.35
Edit Sim: 10


Src: 
int findSum ( int n ) { int multiTerms = n * ( n + 1 ) / 2 ; int sum = multiTerms ; for ( int i = 2 ; i <= n ; i ++ ) { multiTerms = multiTerms - ( i - 1 ) ; sum = sum + multiTerms * i ; } return sum ; }
Ref: 
def findSum ( n ) : NEW_LINE INDENT multiTerms = n * ( n + 1 ) // 2 NEW_LINE sm = multiTerms NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT multiTerms = multiTerms - ( i - 1 ) NEW_LINE sm = sm + multiTerms * i NEW_LINE DEDENT return sm NEW_LINE DEDENT
Hyp: 
def findSum ( n ) : NEW_LINE INDENT multiTerms = n * ( n + 1 ) / 2 NEW_LINE sum = multiTerms NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT multiTerms = multiTerms - ( i - 1 ) NEW_LINE sum = sum + multiTerms * i NEW_LINE DEDENT return sum NEW_LINE DEDENT

BLEU: 80.95
Edit Sim: 5


Src: 
void printTaxicab2 ( int N ) { int i = 1 , count = 0 ; while ( count < N ) { int int_count = 0 ; for ( int j = 1 ; j <= Math . pow ( i , 1.0 / 3 ) ; j ++ ) for ( int k = j + 1 ; k <= Math . pow ( i , 1.0 / 3 ) ; k ++ ) if ( j * j * j + k * k * k == i ) int_count ++ ; if ( int_count == 2 ) { count ++ ; System . out . println ( count + " ▁ " + i ) ; } i ++ ; } }
Ref: 
def printTaxicab2 ( N ) : NEW_LINE INDENT i , count = 1 , 0 NEW_LINE while ( count < N ) : NEW_LINE INDENT int_count = 0 NEW_LINE for j in range ( 1 , math . ceil ( pow ( i , 1.0 / 3 ) ) + 1 ) : NEW_LINE INDENT for k in range ( j + 1 , math . ceil ( pow ( i , 1.0 / 3 ) ) + 1 ) : NEW_LINE INDENT if ( j * j * j + k * k * k == i ) : NEW_LINE INDENT int_count += 1 NEW_LINE DEDENT DEDENT DEDENT if ( int_count == 2 ) : NEW_LINE INDENT count += 1 NEW_LINE print ( count , " ▁ " , i ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT
Hyp: 
def printTaxicab2 ( N ) : NEW_LINE INDENT i = 1 NEW_LINE count = 0 NEW_LINE while ( count < N ) : NEW_LINE INDENT int_count = 0 NEW_LINE for j in range ( 1 , pow ( i , 1.0 / 3 ) + 1 ) : NEW_LINE INDENT for k in range ( j + 1 , pow ( i , 1.0 / 3 ) + 1 ) : NEW_LINE INDENT if ( j * j * j + k * k * k == i ) : NEW_LINE INDENT int_count += 1 NEW_LINE DEDENT DEDENT if ( int_count == 2 ) : NEW_LINE INDENT count += 1 NEW_LINE print ( count , i ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT

BLEU: 80.81
Edit Sim: 63


Src: 
long getBoundarySum ( int a [ ] [ ] , int m , int n ) { long sum = 0 ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == 0 ) sum += a [ i ] [ j ] ; else if ( i == m - 1 ) sum += a [ i ] [ j ] ; else if ( j == 0 ) sum += a [ i ] [ j ] ; else if ( j == n - 1 ) sum += a [ i ] [ j ] ; } } return sum ; }
Ref: 
def printBoundary ( a , m , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT sum += a [ i ] [ j ] NEW_LINE DEDENT elif ( i == m - 1 ) : NEW_LINE INDENT sum += a [ i ] [ j ] NEW_LINE DEDENT elif ( j == 0 ) : NEW_LINE INDENT sum += a [ i ] [ j ] NEW_LINE DEDENT elif ( j == n - 1 ) : NEW_LINE INDENT sum += a [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return sum NEW_LINE DEDENT
Hyp: 
def getBoundarySum ( a , m , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT sum += a [ i ] [ j ] NEW_LINE DEDENT elif ( i == m - 1 ) : NEW_LINE INDENT sum += a [ i ] [ j ] NEW_LINE DEDENT elif ( j == 0 ) : NEW_LINE INDENT sum += a [ i ] [ j ] NEW_LINE DEDENT elif ( j == n - 1 ) : NEW_LINE INDENT sum += a [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return sum NEW_LINE DEDENT

BLEU: 98.6
Edit Sim: 7


Src: 
void printOtherSides ( int n ) { if ( n % 2 != 0 ) { if ( n == 1 ) System . out . println ( " - 1" ) ; else { int b = ( n * n - 1 ) / 2 ; int c = ( n * n + 1 ) / 2 ; System . out . println ( " b ▁ = ▁ " + b + " , ▁ c ▁ = ▁ " + c ) ; } } else { if ( n == 2 ) System . out . println ( " - 1" ) ; else { int b = n * n / 4 - 1 ; int c = n * n / 4 + 1 ; System . out . println ( " b ▁ = ▁ " + b + " , ▁ c ▁ = ▁ " + c ) ; } } }
Ref: 
def printOtherSides ( n ) : NEW_LINE INDENT if ( n & 1 ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT b = ( n * n - 1 ) // 2 NEW_LINE c = ( n * n + 1 ) // 2 NEW_LINE print ( " b ▁ = " , b , " , ▁ c ▁ = " , c ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( n == 2 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT b = n * n // 4 - 1 NEW_LINE c = n * n // 4 + 1 NEW_LINE print ( " b ▁ = " , b " , ▁ c ▁ = " , c ) NEW_LINE DEDENT DEDENT DEDENT
Hyp: 
def printOtherSides ( n ) : NEW_LINE INDENT n = int ( n ) NEW_LINE if n % 2 != 0 : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT else : NEW_LINE INDENT b = ( n * n - 1 ) // 2 NEW_LINE c = ( n * n + 1 ) // 2 NEW_LINE print ( " b ▁ = " , b , " , ▁ c ▁ = " , c ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if n == 2 : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT else : NEW_LINE INDENT b = ( n * n / 4 - 1 ) NEW_LINE c = ( n * n / 4 + 1 ) NEW_LINE DEDENT print ( " b ▁ = " , b , " , ▁ c ▁ = " , c ) NEW_LINE DEDENT DEDENT

BLEU: 71.79
Edit Sim: 68


Src: 
double solve ( int s ) { double area = ( 1.732 * Math . pow ( s , 2 ) ) / 8 ; return area ; }
Ref: 
def solve ( s ) : NEW_LINE INDENT area = ( 1.732 * s ** 2 ) / 8 NEW_LINE return area NEW_LINE DEDENT
Hyp: 
def solve ( s ) : NEW_LINE INDENT area = ( 1.732 * pow ( s , 2 ) ) / 8 NEW_LINE return area NEW_LINE DEDENT

BLEU: 73.72
Edit Sim: 10


Src: 
int minValue ( int n , int x , int y ) { float val = ( y * n ) / 100 ; if ( x >= val ) return 0 ; else return ( int ) ( Math . ceil ( val ) - x ) ; }
Ref: 
def minValue ( n , x , y ) : NEW_LINE INDENT val = ( y * n ) / 100 NEW_LINE if x >= val : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return math . ceil ( val ) - x NEW_LINE DEDENT DEDENT
Hyp: 
def minValue ( n , x , y ) : NEW_LINE INDENT val = ( y * n ) / 100 NEW_LINE if ( x >= val ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return int ( math . ceil ( val ) - x ) NEW_LINE DEDENT DEDENT

BLEU: 78.76
Edit Sim: 12


Src: 
int findMaxPairs ( int a [ ] , int b [ ] , int n , int k ) { Arrays . sort ( a ) ; Arrays . sort ( b ) ; int result = 0 ; for ( int i = 0 , j = 0 ; i < n && j < n ; ) { if ( Math . abs ( a [ i ] - b [ j ] ) <= k ) { result ++ ; i ++ ; j ++ ; } else if ( a [ i ] > b [ j ] ) j ++ ; else i ++ ; } return result ; }
Ref: 
def findMaxPairs ( a , b , n , k ) : NEW_LINE INDENT a . sort ( ) NEW_LINE b . sort ( ) NEW_LINE result = 0 NEW_LINE j = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if j < n : NEW_LINE INDENT if abs ( a [ i ] - b [ j ] ) <= k : NEW_LINE INDENT result += 1 NEW_LINE j += 1 NEW_LINE DEDENT elif a [ i ] > b [ j ] : NEW_LINE INDENT j += 1 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
Hyp: 
def findMaxPairs ( a , b , n , k ) : NEW_LINE INDENT a . sort ( reverse = False ) NEW_LINE b . sort ( reverse = False ) NEW_LINE result = 0 NEW_LINE for i in range ( n and j < n ) : NEW_LINE INDENT if ( abs ( a [ i ] - b [ j ] ) <= k ) : NEW_LINE INDENT result += 1 NEW_LINE i += 1 NEW_LINE j += 1 NEW_LINE DEDENT elif ( a [ i ] > b [ j ] ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT

BLEU: 70.69
Edit Sim: 127


Src: 
int smallestNum ( int n ) { int res = 1 ; for ( int i = 2 ; ; i *= 2 ) { int length = ( int ) ( Math . log10 ( i ) ) + 1 ; if ( length == n ) return ( int ) ( Math . log ( i ) / Math . log ( 2 ) ) ; } }
Ref: 
def smallestNum ( n ) : NEW_LINE INDENT res = 1 NEW_LINE i = 2 NEW_LINE while ( True ) : NEW_LINE INDENT length = int ( log10 ( i ) + 1 ) NEW_LINE if ( length == n ) : NEW_LINE INDENT return int ( log ( i ) // log ( 2 ) ) NEW_LINE DEDENT i *= 2 NEW_LINE DEDENT DEDENT
Hyp: 
def smallestNum ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 2 , 5 ) : NEW_LINE INDENT length = int ( math . log10 ( i ) ) + 1 NEW_LINE if ( length == n ) : NEW_LINE INDENT return int ( math . log ( i ) / math . log ( 2 ) ) NEW_LINE DEDENT DEDENT

BLEU: 63.18
Edit Sim: 62


Src: 
void checkArrays ( int arr1 [ ] , int arr2 [ ] , int N ) { int count = 0 ; boolean flag = true ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr1 [ i ] != arr2 [ i ] ) { if ( arr1 [ i ] == 0 ) count ++ ; else { count -- ; if ( count < 0 ) { flag = false ; break ; } } } } if ( ( flag && ( count == 0 ) ) == true ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; }
Ref: 
def checkArrays ( arr1 , arr2 , N ) : NEW_LINE INDENT count = 0 NEW_LINE flag = True NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr1 [ i ] != arr2 [ i ] ) : NEW_LINE INDENT if ( arr1 [ i ] == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count -= 1 NEW_LINE if ( count < 0 ) : NEW_LINE INDENT flag = 0 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT if ( flag and count == 0 ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
Hyp: 
def checkArrays ( arr1 , arr2 , N ) : NEW_LINE INDENT count = 0 NEW_LINE flag = True NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr1 [ i ] != arr2 [ i ] ) : NEW_LINE INDENT if ( arr1 [ i ] == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count -= 1 NEW_LINE if ( count < 0 ) : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT if ( flag and ( count == 0 ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT

BLEU: 94.39
Edit Sim: 16


Src: 
int minimumLength ( String s ) { int maxOcc = 0 , n = s . length ( ) ; int arr [ ] = new int [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) arr [ s . charAt ( i ) - ' a ' ] ++ ; for ( int i = 0 ; i < 26 ; i ++ ) if ( arr [ i ] > maxOcc ) maxOcc = arr [ i ] ; return ( n - maxOcc ) ; }
Ref: 
def minimumLength ( s ) : NEW_LINE INDENT maxOcc = 0 NEW_LINE n = len ( s ) NEW_LINE arr = [ 0 ] * 26 NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT if arr [ i ] > maxOcc : NEW_LINE INDENT maxOcc = arr [ i ] NEW_LINE DEDENT DEDENT return n - maxOcc NEW_LINE DEDENT
Hyp: 
def minimumLength ( s ) : NEW_LINE INDENT maxOcc = 0 NEW_LINE n = len ( s ) NEW_LINE arr = [ 0 ] * 26 NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr [ ord ( i ) - ord ( ' a ' ) ] = ( arr [ ord ( i ) - ord ( ' a ' ) ] ) + 1 NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT if arr [ i ] > maxOcc : NEW_LINE INDENT maxOcc = arr [ i ] NEW_LINE DEDENT DEDENT return ( n - maxOcc ) NEW_LINE DEDENT

BLEU: 76.04
Edit Sim: 42


Src: 
void checkCount ( int A [ ] , int Q [ ] [ ] , int q ) { for ( int i = 0 ; i < q ; i ++ ) { int L = Q [ i ] [ 0 ] ; int R = Q [ i ] [ 1 ] ; L -- ; R -- ; if ( ( A [ L ] < A [ L + 1 ] ) != ( A [ R - 1 ] < A [ R ] ) ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } } }
Ref: 
def checkCount ( A , Q , q ) : NEW_LINE INDENT for i in range ( q ) : NEW_LINE INDENT L = Q [ i ] [ 0 ] NEW_LINE R = Q [ i ] [ 1 ] NEW_LINE L -= 1 NEW_LINE R -= 1 NEW_LINE if ( ( A [ L ] < A [ L + 1 ] ) != ( A [ R - 1 ] < A [ R ] ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT DEDENT
Hyp: 
def checkCount ( A , Q , q ) : NEW_LINE INDENT for i in range ( q ) : NEW_LINE INDENT L = Q [ i ] [ 0 ] NEW_LINE R = Q [ i ] [ 1 ] NEW_LINE if ( ( A [ L ] < A [ L + 1 ] ) != ( A [ R - 1 ] < A [ R ] ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT DEDENT

BLEU: 91.36
Edit Sim: 32


Src: 
void checkFactors ( long N ) { long ev_count = 0 , od_count = 0 ; for ( long i = 1 ; i <= Math . sqrt ( N ) + 1 ; i ++ ) { if ( N % i == 0 ) { if ( i == N / i ) { if ( i % 2 == 0 ) ev_count += 1 ; else od_count += 1 ; } else { if ( i % 2 == 0 ) ev_count += 1 ; else od_count += 1 ; if ( ( N / i ) % 2 == 0 ) ev_count += 1 ; else od_count += 1 ; } } } if ( ev_count % 2 == 0 && od_count % 2 == 1 ) System . out . print ( " Yes " + "NEW_LINE"); else System . out . print ( " No " + "NEW_LINE"); }
Ref: 
def checkFactors ( N ) : NEW_LINE INDENT ev_count = 0 ; od_count = 0 ; NEW_LINE for i in range ( 1 , int ( pow ( N , 1 / 2 ) ) + 1 ) : NEW_LINE INDENT if ( N % i == 0 ) : NEW_LINE INDENT if ( i == N / i ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT ev_count += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT od_count += 1 ; NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT ev_count += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT od_count += 1 ; NEW_LINE DEDENT if ( ( N / i ) % 2 == 0 ) : NEW_LINE INDENT ev_count += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT od_count += 1 ; NEW_LINE DEDENT DEDENT DEDENT DEDENT if ( ev_count % 2 == 0 and od_count % 2 == 1 ) : NEW_LINE INDENT print ( " Yes " + " " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " + " " ) ; NEW_LINE DEDENT DEDENT
Hyp: 
def checkFactors ( N ) : NEW_LINE INDENT ev_count = 0 NEW_LINE od_count = 0 NEW_LINE for i in range ( 1 , int ( sqrt ( N ) + 1 ) ) : NEW_LINE INDENT if ( N % i == 0 ) : NEW_LINE INDENT if ( i == N // i ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT ev_count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT od_count += 1 NEW_LINE DEDENT if ( ( N // i ) % 2 == 0 ) : NEW_LINE INDENT ev_count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT od_count += 1 NEW_LINE DEDENT if ( ( N // i ) % 2 == 0 ) : NEW_LINE INDENT ev_count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ev_count += 1 NEW_LINE DEDENT DEDENT DEDENT if ( ev_count % 2 == 0 and od_count % 2 == 1 ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT

BLEU: 70.36
Edit Sim: 92


Src: 
int countToMake0lternate ( String s ) { int result = 0 ; for ( int i = 0 ; i < ( s . length ( ) - 1 ) ; i ++ ) if ( s . charAt ( i ) == s . charAt ( i + 1 ) ) return result ; }
Ref: 
def countToMake0lternate ( s ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( len ( s ) - 1 ) : NEW_LINE INDENT if ( s [ i ] == s [ i + 1 ] ) : NEW_LINE DEDENT return result NEW_LINE DEDENT
Hyp: 
def countToMake0lternate ( s ) : NEW_LINE INDENT result = 0 ; NEW_LINE for i in range ( len ( s ) - 1 ) : NEW_LINE INDENT if ( s [ i ] == s [ i + 1 ] ) : NEW_LINE INDENT result = result + 1 ; NEW_LINE DEDENT DEDENT return result ; NEW_LINE DEDENT

BLEU: 74.01
Edit Sim: 49


Src: 
int minCapacity ( int enter [ ] , int exit [ ] , int n ) { int minCap = 0 ; int currCap = 0 ; for ( int i = 0 ; i < n ; i ++ ) { currCap = currCap + enter [ i ] - exit [ i ] ; minCap = Math . max ( minCap , currCap ) ; } return minCap ; }
Ref: 
def minCapacity ( enter , exit , n ) : NEW_LINE INDENT minCap = 0 ; NEW_LINE currCap = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT currCap = currCap + enter [ i ] - exit [ i ] ; NEW_LINE minCap = max ( minCap , currCap ) ; NEW_LINE DEDENT return minCap ; NEW_LINE DEDENT
Hyp: 
def minCapacity ( enter , exit , n ) : NEW_LINE INDENT minCap = 0 ; NEW_LINE currCap = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT currCap = currCap + enter [ i ] - exit [ i ] ; NEW_LINE minCap = max ( minCap , currCap ) ; NEW_LINE DEDENT return minCap ; NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
void findAandB ( double N ) { if ( N == 1 ) { System . out . print ( " No " ) ; return ; } double a = N * N / ( N - 1 ) ; double b = a / N ; System . out . print ( " a ▁ = ▁ " + a + "NEW_LINE"); System . out . print ( " b ▁ = ▁ " + b + "NEW_LINE"); }
Ref: 
def findAandB ( N ) : NEW_LINE INDENT if ( N == 1 ) : NEW_LINE INDENT print ( " No " ) NEW_LINE return NEW_LINE DEDENT a = N * N / ( N - 1 ) NEW_LINE b = a / N NEW_LINE print ( " a ▁ = ▁ " , a ) NEW_LINE print ( " b ▁ = ▁ " , b ) NEW_LINE DEDENT
Hyp: 
def findAandB ( N ) : NEW_LINE INDENT if ( N == 1 ) : NEW_LINE INDENT print ( " No " ) NEW_LINE return NEW_LINE DEDENT a = N * N / ( N - 1 ) NEW_LINE b = a // N NEW_LINE print ( " a ▁ = " , ' { 0 : . 6 } ' . format ( a ) ) NEW_LINE print ( " b ▁ = " , ' { 0 : . 6 } ' . format ( b ) ) NEW_LINE DEDENT

BLEU: 63.49
Edit Sim: 61


Src: 
void findNthTerm ( int n ) { System . out . print ( n * ( 3 * n + 1 ) / 2 + "NEW_LINE"); }
Ref: 
def findNthTerm ( n ) : NEW_LINE INDENT print ( n * ( 3 * n + 1 ) // 2 , end = " ▁ " ) ; NEW_LINE DEDENT
Hyp: 
def findNthTerm ( n ) : NEW_LINE INDENT print ( n * ( 3 * n + 1 ) / 2 ) NEW_LINE DEDENT

BLEU: 62.3
Edit Sim: 17


Src: 
void check_euler_four_square_identity ( int a , int b , int ab ) { int s = 0 ; for ( int i = 0 ; i * i <= ab ; i ++ ) { s = i * i ; for ( int j = i ; j * j <= ab ; j ++ ) { s = j * j + i * i ; for ( int k = j ; k * k <= ab ; k ++ ) { s = k * k + j * j + i * i ; for ( int l = k ; l * l <= ab ; l ++ ) { s = l * l + k * k + j * j + i * i ; if ( s == ab ) { System . out . print ( " i ▁ = ▁ " + i + "NEW_LINE"); System . out . print ( " j ▁ = ▁ " + j + "NEW_LINE"); System . out . print ( " k ▁ = ▁ " + k + "NEW_LINE"); System . out . print ( " l ▁ = ▁ " + l + "NEW_LINE"); System . out . print ( " Product ▁ of ▁ " + a + " ▁ and ▁ " + b ) ; System . out . print ( " ▁ can ▁ be ▁ written " + " ▁ as ▁ sum ▁ of ▁ squares ▁ of ▁ i , ▁ " + "j, k, lNEW_LINE"); System . out . print ( ab + " ▁ = ▁ " ) ; System . out . print ( i + " * " + i + " ▁ + ▁ " ) ; System . out . print ( j + " * " + j + " ▁ + ▁ " ) ; System . out . print ( k + " * " + k + " ▁ + ▁ " ) ; System . out . print ( l + " * " + l + "NEW_LINE"); System . out . println ( ) ; } } } } } }
Ref: 
def check_euler_four_square_identity ( a , b , ab ) : NEW_LINE INDENT s = 0 ; NEW_LINE i = 0 ; NEW_LINE while ( i * i <= ab ) : NEW_LINE INDENT s = i * i ; NEW_LINE j = i ; NEW_LINE while ( j * j <= ab ) : NEW_LINE INDENT s = j * j + i * i ; NEW_LINE k = j ; NEW_LINE while ( k * k <= ab ) : NEW_LINE INDENT s = k * k + j * j + i * i ; NEW_LINE l = k ; NEW_LINE while ( l * l <= ab ) : NEW_LINE INDENT s = l * l + k * k + j * j + i * i ; NEW_LINE if ( s == ab ) : NEW_LINE INDENT print ( " i ▁ = " , i ) ; NEW_LINE print ( " j ▁ = " , j ) ; NEW_LINE print ( " k ▁ = " , k ) ; NEW_LINE print ( " l ▁ = " , l ) ; NEW_LINE print ( " Product ▁ of ▁ " , a , " and " , b , end = " " ) ; NEW_LINE print ( " ▁ can ▁ be ▁ written ▁ as ▁ sum ▁ of " , " squares ▁ of ▁ i , ▁ j , ▁ k , ▁ l " ) ; NEW_LINE print ( ab , " = ▁ " , end = " " ) ; NEW_LINE print ( i , " * " , i , " + ▁ " , end = " " ) ; NEW_LINE print ( j , " * " , j , " + ▁ " , end = " " ) ; NEW_LINE print ( k , " * " , k , " + ▁ " , end = " " ) ; NEW_LINE print ( l , " * " , l ) ; NEW_LINE print ( " " ) ; NEW_LINE DEDENT l += 1 ; NEW_LINE DEDENT k += 1 ; NEW_LINE DEDENT j += 1 ; NEW_LINE DEDENT i += 1 ; NEW_LINE DEDENT DEDENT
Hyp: 
def check_euler_four_square_identity ( a , b , ab ) : NEW_LINE INDENT s = 0 NEW_LINE for i in range ( 0 , ab + 1 ) : NEW_LINE INDENT s = i * i NEW_LINE for j in range ( i , ab + 1 ) : NEW_LINE INDENT s = j * j + i * i NEW_LINE for k in range ( j , ab + 1 ) : NEW_LINE INDENT s = k * k + j * j + i * i NEW_LINE for l in range ( k , l ) : NEW_LINE INDENT s = l * l + k * k + j * j + i * i NEW_LINE if ( s == ab ) : NEW_LINE INDENT print ( " i ▁ = " , i , " ▁ and ▁ " , b ) NEW_LINE print ( ab , " ▁ = " ) NEW_LINE print ( i , " * " , i , " ▁ + ▁ " , j , k , l ) NEW_LINE print ( l , " * " , l , " " ) NEW_LINE print ( ) NEW_LINE DEDENT DEDENT DEDENT

BLEU: 27.68
Edit Sim: 605


Src: 
boolean Check_is_possible ( int l , int r , int k ) { int div_count = ( r / k ) - ( l / k ) ; if ( l % k == 0 ) { div_count ++ ; } return ( div_count > 1 ) ; }
Ref: 
def Check_is_possible ( l , r , k ) : NEW_LINE INDENT div_count = ( r // k ) - ( l // k ) NEW_LINE if l % k == 0 : NEW_LINE INDENT div_count += 1 NEW_LINE DEDENT return div_count > 1 NEW_LINE DEDENT
Hyp: 
def Check_is_possible ( l , r , k ) : NEW_LINE INDENT div_count = ( r // k ) - ( l // k ) NEW_LINE if ( l % k == 0 ) : NEW_LINE INDENT div_count += 1 NEW_LINE DEDENT return ( div_count > 1 ) NEW_LINE DEDENT l = 12 NEW_LINE r = 18 NEW_LINE k = 4 NEW_LINE if ( Check_is_possible ( l , r , k ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT

BLEU: 41.26
Edit Sim: 202


Src: 
boolean prodSquare ( int n ) { for ( long i = 2 ; i * i <= n ; i ++ ) for ( long j = 2 ; j <= n ; j ++ ) if ( i * i * j * j == n ) return true ; return false ; }
Ref: 
def prodSquare ( n ) : NEW_LINE INDENT for i in range ( 2 , ( n ) + 1 ) : NEW_LINE INDENT if ( i * i < ( n + 1 ) ) : NEW_LINE INDENT for j in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( ( i * i * j * j ) == n ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT DEDENT DEDENT DEDENT return False ; NEW_LINE DEDENT
Hyp: 
def prodSquare ( n ) : NEW_LINE INDENT i = 2 NEW_LINE while i * i <= n : NEW_LINE INDENT j = 2 NEW_LINE while ( i * i * j <= n ) : NEW_LINE INDENT if ( i * i * j * j == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT j += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return False NEW_LINE DEDENT n = 25 NEW_LINE if ( prodSquare ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT

BLEU: 36.91
Edit Sim: 219


Src: 
int check ( int n , List < Integer > marks ) { Integer x = Collections . max ( marks ) ; int bonus = 100 - x ; int c = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( marks . get ( i ) + bonus >= 50 ) c += 1 ; } return c ; }
Ref: 
def check ( n , marks ) : NEW_LINE INDENT x = max ( marks ) NEW_LINE bonus = 100 - x NEW_LINE c = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( marks [ i ] + bonus >= 50 ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT return c NEW_LINE DEDENT
Hyp: 
def check ( n , marks ) : NEW_LINE INDENT x = max ( marks ) NEW_LINE bonus = 100 - x NEW_LINE c = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( marks [ i ] + bonus >= 50 ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT return c NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
boolean uniqueCharacters ( String str ) { for ( int i = 0 ; i < str . length ( ) ; i ++ ) for ( int j = i + 1 ; j < str . length ( ) ; j ++ ) if ( str . charAt ( i ) == str . charAt ( j ) ) return false ; return true ; }
Ref: 
def uniqueCharacters ( str ) : NEW_LINE INDENT for i in range ( len ( str ) ) : NEW_LINE INDENT for j in range ( i + 1 , len ( str ) ) : NEW_LINE INDENT if ( str [ i ] == str [ j ] ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT DEDENT return True ; NEW_LINE DEDENT str = " GeeksforGeeks " ; NEW_LINE if ( uniqueCharacters ( str ) ) : NEW_LINE INDENT print ( " The ▁ String ▁ " , str , " ▁ has ▁ all ▁ unique ▁ characters " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " The ▁ String ▁ " , str , " ▁ has ▁ duplicate ▁ characters " ) ; NEW_LINE DEDENT
Hyp: 
def uniqueCharacters ( str ) : NEW_LINE INDENT for i in range ( len ( str ) ) : NEW_LINE INDENT for j in range ( i + 1 , len ( str ) ) : NEW_LINE INDENT if ( str [ i ] == str [ j ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT

BLEU: 30.94
Edit Sim: 295


Src: 
String checkEvenPower ( int n ) { int low = 0 , high = n ; while ( low <= high ) { int mid = low + ( high - low ) / 2 ; int value = ( int ) Math . pow ( 2 , mid ) ; if ( value == n ) { if ( mid % 2 == 1 ) return " No " ; else return " Yes " ; } else if ( value < n ) low = mid + 1 ; else high = mid - 1 ; } return " No " ; }
Ref: 
def checkEvenPower ( n ) : NEW_LINE INDENT low , high = 0 , n NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = low + ( high - low ) / 2 NEW_LINE value = pow ( 2 , mid ) NEW_LINE if ( value == n ) : NEW_LINE INDENT if ( mid % 2 == 1 ) : NEW_LINE INDENT return " No " NEW_LINE DEDENT else : NEW_LINE INDENT return " Yes " NEW_LINE DEDENT DEDENT elif ( value < n ) : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT DEDENT return " No " NEW_LINE DEDENT
Hyp: 
def checkEvenPower ( n ) : NEW_LINE INDENT low = 0 NEW_LINE high = n NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = low + ( high - low ) // 2 NEW_LINE value = pow ( 2 , mid ) NEW_LINE if ( value == n ) : NEW_LINE INDENT if ( mid % 2 == 1 ) : NEW_LINE INDENT return " No " NEW_LINE DEDENT else : NEW_LINE INDENT return " Yes " NEW_LINE DEDENT DEDENT return " No " NEW_LINE DEDENT

BLEU: 67.53
Edit Sim: 145


Src: 
int getSingle ( int arr [ ] , int n ) { int ones = 0 , twos = 0 ; int common_bit_mask ; for ( int i = 0 ; i < n ; i ++ ) { twos = twos | ( ones & arr [ i ] ) ; ones = ones ^ arr [ i ] ; common_bit_mask = ~ ( ones & twos ) ; ones &= common_bit_mask ; twos &= common_bit_mask ; } return ones ; }
Ref: 
def getSingle ( arr , n ) : NEW_LINE INDENT ones = 0 NEW_LINE twos = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT twos = twos | ( ones & arr [ i ] ) NEW_LINE ones = ones ^ arr [ i ] NEW_LINE common_bit_mask = ~ ( ones & twos ) NEW_LINE ones &= common_bit_mask NEW_LINE twos &= common_bit_mask NEW_LINE DEDENT return ones NEW_LINE DEDENT
Hyp: 
def getSingle ( arr , n ) : NEW_LINE INDENT ones , twos = 0 , 0 NEW_LINE common_bit_mask = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT twos = twos | ( ones & arr [ i ] ) NEW_LINE ones = ones ^ arr [ i ] NEW_LINE common_bit_mask = ~ ( ones & twos ) NEW_LINE ones &= common_bit_mask NEW_LINE twos &= common_bit_mask NEW_LINE DEDENT return ones NEW_LINE DEDENT

BLEU: 86.93
Edit Sim: 28


Src: 
void printSubsets ( int n ) { for ( int i = n ; i > 0 ; i = ( i - 1 ) & n ) System . out . print ( i + " ▁ " ) ; System . out . print ( " ▁ 0 ▁ " ) ; }
Ref: 
def printSubsets ( n ) : NEW_LINE INDENT i = n NEW_LINE while ( i != 0 ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE i = ( i - 1 ) & n NEW_LINE DEDENT print ( "0" ) NEW_LINE DEDENT
Hyp: 
def printSubsets ( n ) : NEW_LINE INDENT i = n NEW_LINE while i > 0 : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT print ( " ▁ 0 ▁ " ) NEW_LINE DEDENT

BLEU: 58.64
Edit Sim: 39


Src: 
void findNthTerm ( int n ) { System . out . println ( n * n - n + 1 ) ; }
Ref: 
def findNthTerm ( n ) : NEW_LINE INDENT print ( n * n - n + 1 ) NEW_LINE DEDENT
Hyp: 
def findNthTerm ( n ) : NEW_LINE INDENT print ( n * n - n + 1 ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
void reorder ( ) { int temp [ ] = new int [ arr . length ] ; for ( int i = 0 ; i < arr . length ; i ++ ) temp [ index [ i ] ] = arr [ i ] ; for ( int i = 0 ; i < arr . length ; i ++ ) { arr [ i ] = temp [ i ] ; index [ i ] = i ; } }
Ref: 
def reorder ( arr , index , n ) : NEW_LINE INDENT temp = [ 0 ] * n ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT temp [ index [ i ] ] = arr [ i ] NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT arr [ i ] = temp [ i ] NEW_LINE index [ i ] = i NEW_LINE DEDENT DEDENT arr = [ 50 , 40 , 70 , 60 , 90 ] NEW_LINE index = [ 3 , 0 , 4 , 1 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE reorder ( arr , index , n ) NEW_LINE print ( " Reordered ▁ array ▁ is : " ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT print ( " Modified Index array is : " ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( index [ i ] , end = " ▁ " ) NEW_LINE DEDENT
Hyp: 
def reorder ( arr ) : NEW_LINE INDENT temp = [ 0 ] * len ( arr ) NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT temp [ index [ i ] ] = arr [ i ] NEW_LINE DEDENT for i in range ( len ( arr ) ) : NEW_LINE INDENT arr [ i ] = temp [ i ] NEW_LINE index [ i ] = i NEW_LINE DEDENT DEDENT

BLEU: 17.71
Edit Sim: 464


Src: 
boolean allBitsSetInTheGivenRange ( int n , int l , int r ) { int num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ; int new_num = n & num ; if ( new_num == 0 ) return true ; return false ; }
Ref: 
def allBitsSetInTheGivenRange ( n , l , r ) : NEW_LINE INDENT num = ( ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ) NEW_LINE new_num = n & num NEW_LINE if ( new_num == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return false NEW_LINE DEDENT n = 17 NEW_LINE l = 2 NEW_LINE r = 4 NEW_LINE if ( allBitsSetInTheGivenRange ( n , l , r ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
Hyp: 
def allBitsSetInTheGivenRange ( n , l , r ) : NEW_LINE INDENT num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) NEW_LINE new_num = n & num NEW_LINE if ( new_num == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT n = 65 NEW_LINE l = 4 NEW_LINE r = 5 NEW_LINE if ( allBitsSetInTheGivenRange ( n , l , r ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT

BLEU: 88.68
Edit Sim: 9


Src: 
int smallestSumSubarr ( int arr [ ] , int n ) { int min_ending_here = 2147483647 ; int min_so_far = 2147483647 ; for ( int i = 0 ; i < n ; i ++ ) { if ( min_ending_here > 0 ) min_ending_here = arr [ i ] ; else min_ending_here += arr [ i ] ; min_so_far = Math . min ( min_so_far , min_ending_here ) ; } return min_so_far ; }
Ref: 
def smallestSumSubarr ( arr , n ) : NEW_LINE INDENT min_ending_here = sys . maxsize NEW_LINE min_so_far = sys . maxsize NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( min_ending_here > 0 ) : NEW_LINE INDENT min_ending_here = arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT min_ending_here += arr [ i ] NEW_LINE DEDENT min_so_far = min ( min_so_far , min_ending_here ) NEW_LINE DEDENT return min_so_far NEW_LINE DEDENT
Hyp: 
def smallestSumSubarr ( arr , n ) : NEW_LINE INDENT min_ending_here = 2147483647 NEW_LINE min_so_far = 2147483647 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( min_ending_here > 0 ) : NEW_LINE INDENT min_ending_here = arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT min_ending_here += arr [ i ] NEW_LINE DEDENT min_so_far = min ( min_so_far , min_ending_here ) NEW_LINE DEDENT return min_so_far NEW_LINE DEDENT

BLEU: 85.69
Edit Sim: 30


Src: 
int clearBit ( int num , int i ) { int mask = ~ ( 1 << i ) ; return num & mask ; }
Ref: 
def clearBit ( num , i ) : NEW_LINE INDENT mask = ~ ( 1 << i ) NEW_LINE return num & mask NEW_LINE DEDENT
Hyp: 
def clearBit ( num , i ) : NEW_LINE INDENT mask = ~ ( 1 << i ) NEW_LINE return num & mask NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int totalSumDivisibleByNum ( int n , int number ) { int firstnum = ( int ) Math . pow ( 10 , n - 1 ) ; int lastnum = ( int ) Math . pow ( 10 , n ) ; int sum = 0 ; for ( int i = firstnum ; i < lastnum ; i ++ ) if ( i % number == 0 ) sum += i ; return sum ; }
Ref: 
def totalSumDivisibleByNum ( n , number ) : NEW_LINE INDENT firstnum = pow ( 10 , n - 1 ) NEW_LINE lastnum = pow ( 10 , n ) NEW_LINE sum = 0 NEW_LINE for i in range ( firstnum , lastnum ) : NEW_LINE INDENT if ( i % number == 0 ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
Hyp: 
def totalSumDivisibleByNum ( n , number ) : NEW_LINE INDENT firstnum = int ( pow ( 10 , n - 1 ) ) ; NEW_LINE lastnum = int ( pow ( 10 , n ) ) ; NEW_LINE sum = 0 ; NEW_LINE for i in range ( firstnum , lastnum ) : NEW_LINE INDENT if ( i % number == 0 ) : NEW_LINE INDENT sum += i ; NEW_LINE DEDENT DEDENT return sum ; NEW_LINE DEDENT

BLEU: 71.73
Edit Sim: 26


Src: 
int countX ( int a , int b ) { if ( b > a ) return 0 ; else if ( a == b ) return - 1 ; else { int x = a - b , ans = 0 ; for ( int i = 1 ; i * i <= x ; i ++ ) { if ( x % i == 0 ) { int d1 = i , d2 = b - 1 ; if ( i * i != x ) d2 = x / i ; if ( d1 > b ) ans ++ ; if ( d2 > b ) ans ++ ; } } return ans ; } }
Ref: 
def countX ( a , b ) : NEW_LINE INDENT if ( b > a ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( a == b ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT x = a - b NEW_LINE ans = 0 NEW_LINE i = 1 NEW_LINE while i * i <= x : NEW_LINE INDENT if ( x % i == 0 ) : NEW_LINE INDENT d1 = i NEW_LINE d2 = b - 1 NEW_LINE if ( i * i != x ) : NEW_LINE INDENT d2 = x // i NEW_LINE DEDENT if ( d1 > b ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT if ( d2 > b ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
Hyp: 
def countX ( a , b ) : NEW_LINE INDENT if ( b > a ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT elif ( a == b ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT x = a - b ; NEW_LINE ans = 0 ; NEW_LINE for i in range ( 1 , x + 1 ) : NEW_LINE INDENT if ( x % i == 0 ) : NEW_LINE INDENT d1 = i NEW_LINE d2 = b - 1 ; NEW_LINE if ( i * i != x ) : NEW_LINE INDENT d2 = x // i ; NEW_LINE DEDENT if ( d1 > b ) : NEW_LINE INDENT ans += 1 ; NEW_LINE DEDENT if ( d2 > b ) : NEW_LINE INDENT ans += 1 ; NEW_LINE DEDENT DEDENT DEDENT return ans ; NEW_LINE DEDENT

BLEU: 76.05
Edit Sim: 64


Src: 
long findWays ( int f , int d , int s ) { long mem [ ] [ ] = new long [ d + 1 ] [ s + 1 ] ; mem [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= d ; i ++ ) { for ( int j = i ; j <= s ; j ++ ) { mem [ i ] [ j ] = mem [ i ] [ j - 1 ] + mem [ i - 1 ] [ j - 1 ] ; if ( j - f - 1 >= 0 ) mem [ i ] [ j ] -= mem [ i - 1 ] [ j - f - 1 ] ; } } return mem [ d ] [ s ] ; }
Ref: 
def findWays ( f , d , s ) : NEW_LINE INDENT mem = [ [ 0 for i in range ( s + 1 ) ] for j in range ( d + 1 ) ] NEW_LINE mem [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , d + 1 ) : NEW_LINE INDENT for j in range ( 1 , s + 1 ) : NEW_LINE INDENT mem [ i ] [ j ] = mem [ i ] [ j - 1 ] + mem [ i - 1 ] [ j - 1 ] NEW_LINE if j - f - 1 >= 0 : NEW_LINE INDENT mem [ i ] [ j ] -= mem [ i - 1 ] [ j - f - 1 ] NEW_LINE DEDENT DEDENT DEDENT return mem [ d ] [ s ] NEW_LINE DEDENT
Hyp: 
def findWays ( f , d , s ) : NEW_LINE INDENT mem = [ [ 0 for i in range ( s + 1 ) ] for i in range ( d + 1 ) ] NEW_LINE mem [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , d + 1 ) : NEW_LINE INDENT for j in range ( i , s + 1 ) : NEW_LINE INDENT mem [ i ] [ j ] = mem [ i ] [ j - 1 ] + mem [ i - 1 ] [ j - 1 ] NEW_LINE if ( j - f - 1 >= 0 ) : NEW_LINE INDENT mem [ i ] [ j ] -= mem [ i - 1 ] [ j - f - 1 ] NEW_LINE DEDENT DEDENT DEDENT return mem [ d ] [ s ] NEW_LINE DEDENT

BLEU: 93.42
Edit Sim: 6


Src: 
long SubArraySum ( int arr [ ] , int n ) { long result = 0 , temp = 0 ; for ( int i = 0 ; i < n ; i ++ ) { temp = 0 ; for ( int j = i ; j < n ; j ++ ) { temp += arr [ j ] ; result += temp ; } } return result ; }
Ref: 
def SubArraySum ( arr , n ) : NEW_LINE INDENT temp , result = 0 , 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT temp = 0 ; NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT temp += arr [ j ] NEW_LINE result += temp NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
Hyp: 
def SubArraySum ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE temp = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT temp += arr [ i ] NEW_LINE result += temp NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT

BLEU: 58.89
Edit Sim: 59


Src: 
float squarearea ( float a , float b ) { if ( a < 0 b < 0 ) return - 1 ; float area = 4 * ( float ) ( ( Math . pow ( a , 2 ) + Math . pow ( b , 2 ) ) / ( Math . pow ( a , 2 ) * Math . pow ( b , 2 ) ) ) ; return area ; }
Ref: 
def squarearea ( a , b ) : NEW_LINE INDENT if ( a < 0 or b < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT area = 4 * ( ( ( pow ( a , 2 ) + pow ( b , 2 ) ) / ( pow ( a , 2 ) * pow ( b , 2 ) ) ) ) NEW_LINE return area NEW_LINE DEDENT
Hyp: 
def squarearea ( a , b ) : NEW_LINE INDENT if ( a < 0 or b < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT area = 4 * NEW_LINE ( ( ( a ** 2 ) + ( b ** 2 ) ) / ( ( a ** 2 ) * ( b ** 2 ) ) ) NEW_LINE return area NEW_LINE DEDENT

BLEU: 68.48
Edit Sim: 33


Src: 
int OddLengthSum ( int [ ] arr ) { int sum = 0 ; int l = arr . length ; for ( int i = 0 ; i < l ; i ++ ) { for ( int j = i ; j < l ; j += 2 ) { for ( int k = i ; k <= j ; k ++ ) { sum += arr [ k ] ; } } } return sum ; }
Ref: 
def OddLengthSum ( arr ) : NEW_LINE INDENT sum = 0 NEW_LINE l = len ( arr ) NEW_LINE for i in range ( l ) : NEW_LINE INDENT for j in range ( i , l , 2 ) : NEW_LINE INDENT for k in range ( i , j + 1 , 1 ) : NEW_LINE INDENT sum += arr [ k ] NEW_LINE DEDENT DEDENT DEDENT return sum NEW_LINE DEDENT
Hyp: 
def OddLengthSum ( arr ) : NEW_LINE INDENT sum = 0 ; NEW_LINE l = len ( arr ) NEW_LINE for i in range ( 0 , l ) : NEW_LINE INDENT for j in range ( i , l , 2 ) : NEW_LINE INDENT for k in range ( i , j + 1 ) : NEW_LINE INDENT sum += arr [ k ] ; NEW_LINE DEDENT DEDENT DEDENT return sum ; NEW_LINE DEDENT

BLEU: 84.69
Edit Sim: 14


Src: 
int countSubstrig ( String str1 , String str2 ) { int n1 = str1 . length ( ) ; int n2 = str2 . length ( ) ; if ( n1 == 0 n1 < n2 ) return 0 ; if ( str1 . substring ( 0 , n2 ) . equals ( str2 ) ) return countSubstrig ( str1 . substring ( n2 - 1 ) , str2 ) + 1 ; return countSubstrig ( str1 . substring ( n2 - 1 ) , str2 ) ; }
Ref: 
def countSubstrig ( str1 , str2 ) : NEW_LINE INDENT n1 = len ( str1 ) ; NEW_LINE n2 = len ( str2 ) ; NEW_LINE if ( n1 == 0 or n1 < n2 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( str1 [ 0 : n2 ] == str2 ) : NEW_LINE INDENT return countSubstrig ( str1 [ n2 - 1 : ] , str2 ) + 1 ; NEW_LINE DEDENT return countSubstrig ( str1 [ n2 - 1 : ] , str2 ) ; NEW_LINE DEDENT
Hyp: 
def countSubstrig ( str1 , str2 ) : NEW_LINE INDENT n1 = len ( str1 ) NEW_LINE n2 = len ( str2 ) NEW_LINE if ( n1 == 0 or n1 < n2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( str1 [ 0 : n2 ] == str2 ) : NEW_LINE INDENT return countSubstrig ( str1 [ n2 - 1 ] , str2 ) + 1 NEW_LINE DEDENT return countSubstrig ( str1 [ n2 - 1 ] , str2 ) NEW_LINE DEDENT

BLEU: 80.38
Edit Sim: 14


Src: 
void findArea ( double a , double b , double c ) { double area = 4 * 3.141592653 * Math . pow ( ( Math . pow ( a * b , 1.6 ) + Math . pow ( a * c , 1.6 ) + Math . pow ( b * c , 1.6 ) ) / 3 , 1 / 1.6 ) ; System . out . print ( String . format ( " % .2f " , area ) ) ; }
Ref: 
def findArea ( a , b , c ) : NEW_LINE INDENT area = ( 4 * 3.141592653 * pow ( ( pow ( a * b , 1.6 ) + pow ( a * c , 1.6 ) + pow ( b * c , 1.6 ) ) / 3 , 1 / 1.6 ) ) NEW_LINE print ( " { : . 2f } " . format ( round ( area , 2 ) ) ) NEW_LINE DEDENT
Hyp: 
def findArea ( a , b , c ) : NEW_LINE INDENT area = 4 * 3.141592653 * pow ( ( ( a * b , 1.6 ) + ( a * c , 1.6 ) + ( b * c , 1.6 ) ) / 3 , 1 / 1.6 ) NEW_LINE print ( " { 0 : . 2f } " . format ( area ) ) NEW_LINE DEDENT

BLEU: 73.16
Edit Sim: 32


Src: 
void lengtang ( double r1 , double r2 ) { System . out . println ( " The ▁ length ▁ of ▁ the ▁ " + " direct ▁ common ▁ tangent ▁ is ▁ " + ( 2 * Math . sqrt ( r1 * r2 ) ) ) ; }
Ref: 
def lengtang ( r1 , r2 ) : NEW_LINE INDENT print ( " The ▁ length ▁ of ▁ the ▁ direct " , " common ▁ tangent ▁ is " , 2 * ( r1 * r2 ) ** ( 1 / 2 ) ) ; NEW_LINE DEDENT
Hyp: 
def lengtang ( r1 , r2 ) : NEW_LINE INDENT print ( " The ▁ length ▁ of ▁ the ▁ " , " direct ▁ common ▁ tangent ▁ is ▁ " , ( 2 * math . sqrt ( r1 * r2 ) ) ) NEW_LINE DEDENT

BLEU: 64.86
Edit Sim: 30


Src: 
void printRectPattern ( int c1 , int c2 , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { System . out . print ( ( Math . max ( Math . abs ( c1 - i ) , Math . abs ( c2 - j ) ) ) + " ▁ " ) ; } System . out . println ( ) ; } }
Ref: 
def printRectPattern ( c1 , c2 , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT print ( max ( abs ( c1 - i ) , abs ( c2 - j ) ) , end = " ▁ " ) NEW_LINE DEDENT print ( " " ) NEW_LINE DEDENT DEDENT
Hyp: 
def printRectPattern ( c1 , c2 , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT print ( ( max ( abs ( c1 - i ) , abs ( c2 - j ) ) ) , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT

BLEU: 93.1
Edit Sim: 8


Src: 
void findNthTerm ( int N ) { int ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( i % 2 == 0 ) { ans = ans + 6 ; } else { ans = ans + 2 ; } } System . out . print ( ans + "NEW_LINE"); }
Ref: 
def findNthTerm ( N ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT ans = ans + 6 NEW_LINE DEDENT else : NEW_LINE INDENT ans = ans + 2 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
Hyp: 
def findNthTerm ( N ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT ans = ans + 6 NEW_LINE DEDENT else : NEW_LINE INDENT ans = ans + 2 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
double polite ( double n ) { n += 1 ; double base = 2 ; return n + ( Math . log ( ( n + ( Math . log ( n ) / Math . log ( base ) ) ) ) ) / Math . log ( base ) ; }
Ref: 
def Polite ( n ) : NEW_LINE INDENT n = n + 1 NEW_LINE return ( int ) ( n + ( math . log ( ( n + math . log ( n , 2 ) ) , 2 ) ) ) NEW_LINE DEDENT
Hyp: 
def polite ( n ) : NEW_LINE INDENT n += 1 NEW_LINE base = 2 NEW_LINE return n + ( log ( ( n + ( log ( n ) / log ( base ) ) ) ) / log ( base ) ) NEW_LINE DEDENT

BLEU: 38.8
Edit Sim: 58


Src: 
String check ( int [ ] a , int [ ] b , int Na , int Nb , int k , int m ) { if ( Na < k Nb < m ) return " No " ; Arrays . sort ( a ) ; Arrays . sort ( b ) ; if ( a [ k - 1 ] < b [ Nb - m ] ) { return " Yes " ; } return " No " ; }
Ref: 
def check ( a , b , Na , Nb , k , m ) : NEW_LINE INDENT if ( Na < k or Nb < m ) : NEW_LINE INDENT return " No " NEW_LINE DEDENT a . sort ( ) NEW_LINE a . sort ( ) NEW_LINE if ( a [ k - 1 ] < b [ Nb - m ] ) : NEW_LINE INDENT return " Yes " NEW_LINE DEDENT return " No " NEW_LINE DEDENT
Hyp: 
def check ( a , b , Na , Nb , k , m ) : NEW_LINE INDENT if ( Na < k Nb < m ) : NEW_LINE INDENT return " No " NEW_LINE DEDENT a . sort ( ) NEW_LINE b . sort ( ) NEW_LINE if ( a [ k - 1 ] < b [ Nb - m ] ) : NEW_LINE INDENT return " Yes " NEW_LINE DEDENT return " No " NEW_LINE DEDENT

BLEU: 93.63
Edit Sim: 4


Src: 
int countofPermutations ( int N ) { return ( int ) ( 3 * Math . pow ( 2 , N - 1 ) ) ; }
Ref: 
def countofPermutations ( N ) : NEW_LINE INDENT return int ( ( 3 * pow ( 2 , N - 1 ) ) ) ; NEW_LINE DEDENT
Hyp: 
def countofPermutations ( N ) : NEW_LINE INDENT return 3 * pow ( 2 , N - 1 ) ; NEW_LINE DEDENT

BLEU: 70.51
Edit Sim: 12


Src: 
void find_Solution ( double x , int n ) { double sum = x , e = 2 , o = 1 , p = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { p += 2 ; sum += ( double ) ( o / e ) * ( double ) ( Math . pow ( x , p ) / p ) ; o = o * ( o + 2 ) ; e = e * ( e + 2 ) ; } System . out . println ( sum ) ; }
Ref: 
def find_Solution ( x , n ) : NEW_LINE INDENT Sum = x NEW_LINE e = 2 NEW_LINE o = 1 NEW_LINE p = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT p += 2 NEW_LINE Sum += ( o / e ) * ( pow ( x , p ) / p ) NEW_LINE o = o * ( o + 2 ) NEW_LINE e = e * ( e + 2 ) NEW_LINE DEDENT print ( round ( Sum , 10 ) ) NEW_LINE DEDENT x = - 0.5 NEW_LINE if ( abs ( x ) >= 1 ) : NEW_LINE INDENT print ( " Invalid Input " ) NEW_LINE DEDENT
Hyp: 
def find_Solution ( x , n ) : NEW_LINE INDENT sum = x NEW_LINE e = 2 NEW_LINE o = 1 NEW_LINE p = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT p += 2 NEW_LINE sum += ( o / e ) * ( math . pow ( x , p ) / p ) NEW_LINE o = o * ( o + 2 ) NEW_LINE e = e * ( e + 2 ) NEW_LINE DEDENT print ( sum ) NEW_LINE DEDENT

BLEU: 64.04
Edit Sim: 128


Src: 
int countPairsWithDiffK ( int arr [ ] , int n , int k ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] - arr [ j ] == k arr [ j ] - arr [ i ] == k ) count ++ ; } return count ; }
Ref: 
def countPairsWithDiffK ( arr , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if arr [ i ] - arr [ j ] == k or arr [ j ] - arr [ i ] == k : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
Hyp: 
def countPairsWithDiffK ( arr , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] - arr [ j ] == k or arr [ j ] - arr [ i ] == k ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT

BLEU: 91.66
Edit Sim: 8


Src: 
int countLattice ( int r ) { if ( r <= 0 ) return 0 ; int result = 4 ; for ( int x = 1 ; x < r ; x ++ ) { int ySquare = r * r - x * x ; int y = ( int ) Math . sqrt ( ySquare ) ; if ( y * y == ySquare ) result += 4 ; } return result ; }
Ref: 
def countLattice ( r ) : NEW_LINE INDENT if ( r <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT result = 4 NEW_LINE for x in range ( 1 , r ) : NEW_LINE INDENT ySquare = r * r - x * x NEW_LINE y = int ( math . sqrt ( ySquare ) ) NEW_LINE if ( y * y == ySquare ) : NEW_LINE INDENT result += 4 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
Hyp: 
def countLattice ( r ) : NEW_LINE INDENT if ( r <= 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT result = 4 ; NEW_LINE for x in range ( 1 , r ) : NEW_LINE INDENT ySquare = r * r - x * x ; NEW_LINE y = int ( math . sqrt ( ySquare ) ) ; NEW_LINE if ( y * y == ySquare ) : NEW_LINE INDENT result += 4 ; NEW_LINE DEDENT DEDENT return result ; NEW_LINE DEDENT

BLEU: 82.29
Edit Sim: 12


Src: 
int countPairs ( int A [ ] , int n , int k ) { int ans = 0 ; Arrays . sort ( A ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int x = 0 ; while ( ( A [ i ] * Math . pow ( k , x ) ) <= A [ j ] ) { if ( ( A [ i ] * Math . pow ( k , x ) ) == A [ j ] ) { ans ++ ; break ; } x ++ ; } } } return ans ; }
Ref: 
def countPairs ( A , n , k ) : NEW_LINE INDENT ans = 0 NEW_LINE A . sort ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT x = 0 NEW_LINE while ( ( A [ i ] * math . pow ( k , x ) ) <= A [ j ] ) : NEW_LINE INDENT if ( ( A [ i ] * math . pow ( k , x ) ) == A [ j ] ) : NEW_LINE INDENT ans += 1 NEW_LINE break NEW_LINE DEDENT x += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
Hyp: 
def countPairs ( A , n , k ) : NEW_LINE INDENT ans = 0 NEW_LINE A . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT x = 0 NEW_LINE while ( ( A [ i ] * pow ( k , x ) ) <= A [ j ] ) : NEW_LINE INDENT if ( ( A [ i ] * pow ( k , x ) ) == A [ j ] ) : NEW_LINE INDENT ans += 1 NEW_LINE break NEW_LINE DEDENT x += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT

BLEU: 91.19
Edit Sim: 18


Src: 
int search ( int ar [ ] , int size ) { int a = 0 , b = size - 1 ; int mid = 0 ; while ( ( b - a ) > 1 ) { mid = ( a + b ) / 2 ; if ( ( ar [ a ] - a ) != ( ar [ mid ] - mid ) ) b = mid ; else if ( ( ar [ b ] - b ) != ( ar [ mid ] - mid ) ) a = mid ; } return ( ar [ a ] + 1 ) ; }
Ref: 
def search ( ar , size ) : NEW_LINE INDENT a = 0 NEW_LINE b = size - 1 NEW_LINE mid = 0 NEW_LINE while b > a + 1 : NEW_LINE INDENT mid = ( a + b ) // 2 NEW_LINE if ( ar [ a ] - a ) != ( ar [ mid ] - mid ) : NEW_LINE INDENT b = mid NEW_LINE DEDENT elif ( ar [ b ] - b ) != ( ar [ mid ] - mid ) : NEW_LINE INDENT a = mid NEW_LINE DEDENT DEDENT return ar [ a ] + 1 NEW_LINE DEDENT
Hyp: 
def search ( ar , size ) : NEW_LINE INDENT a = 0 NEW_LINE b = size - 1 NEW_LINE mid = 0 NEW_LINE while ( ( b - a ) > 1 ) : NEW_LINE INDENT mid = ( a + b ) // 2 NEW_LINE if ( ( ar [ a ] - a ) != ( ar [ mid ] - mid ) ) : NEW_LINE INDENT b = mid NEW_LINE DEDENT elif ( ( ar [ b ] - b ) != ( ar [ mid ] - mid ) ) : NEW_LINE INDENT a = mid NEW_LINE DEDENT DEDENT return ( ar [ a ] + 1 ) NEW_LINE DEDENT

BLEU: 81.1
Edit Sim: 22


Src: 
void main ( String [ ] args ) { int n = 5 , k = 42 ; char arr [ ] = lexo_small ( n , k ) ; System . out . print ( new String ( arr ) ) ; } }
Ref: 
def lexo_small ( n , k ) : NEW_LINE INDENT arr = " " ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr += ' a ' ; NEW_LINE DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT k -= i ; NEW_LINE if ( k >= 0 ) : NEW_LINE INDENT if ( k >= 26 ) : NEW_LINE INDENT arr = arr [ : i ] + ' z ' + arr [ i + 1 : ] ; NEW_LINE k -= 26 ; NEW_LINE DEDENT else : NEW_LINE INDENT c = ( k + 97 - 1 ) ; NEW_LINE arr = arr [ : i ] + chr ( c ) + arr [ i + 1 : ] ; NEW_LINE k -= ord ( arr [ i ] ) - ord ( ' a ' ) + 1 ; NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT break ; NEW_LINE DEDENT k += i ; NEW_LINE DEDENT return arr ; NEW_LINE DEDENT
Hyp: 
def lexo_small ( n , k ) : NEW_LINE INDENT def lexo_small ( n , k ) : NEW_LINE INDENT arr = lexo_small ( n , k ) NEW_LINE print ( str ( arr ) ) NEW_LINE DEDENT

BLEU: 1.11
Edit Sim: 498


Src: 
int sum ( int N ) { int S1 , S2 , S3 ; S1 = ( ( N / 2 ) ) * ( 2 * 2 + ( N / 2 - 1 ) * 2 ) / 2 ; S2 = ( ( N / 7 ) ) * ( 2 * 7 + ( N / 7 - 1 ) * 7 ) / 2 ; S3 = ( ( N / 14 ) ) * ( 2 * 14 + ( N / 14 - 1 ) * 14 ) / 2 ; return S1 + S2 - S3 ; }
Ref: 
def sum ( N ) : NEW_LINE INDENT S1 = ( ( N // 2 ) ) * ( 2 * 2 + ( N // 2 - 1 ) * 2 ) // 2 NEW_LINE S2 = ( ( N // 7 ) ) * ( 2 * 7 + ( N // 7 - 1 ) * 7 ) // 2 NEW_LINE S3 = ( ( N // 14 ) ) * ( 2 * 14 + ( N // 14 - 1 ) * 14 ) // 2 NEW_LINE return S1 + S2 - S3 NEW_LINE DEDENT
Hyp: 
def sum ( N ) : NEW_LINE INDENT S1 = ( ( N // 2 ) ) * ( 2 * 2 + ( N // 2 - 1 ) * 2 ) / 2 NEW_LINE S2 = ( ( N // 7 ) ) * ( 2 * 7 + ( N // 7 - 1 ) * 7 ) / 2 NEW_LINE S3 = ( ( N // 14 ) ) * ( 2 * 14 + ( N // 14 - 1 ) * 14 ) // 2 NEW_LINE return S1 + S2 - S3 NEW_LINE DEDENT

BLEU: 94.92
Edit Sim: 2


Src: 
void pendulumArrangement ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int op [ ] = new int [ n ] ; int mid = ( n - 1 ) / 2 ; int j = 1 , i = 1 ; op [ mid ] = arr [ 0 ] ; for ( i = 1 ; i <= mid ; i ++ ) { op [ mid + i ] = arr [ j ++ ] ; op [ mid - i ] = arr [ j ++ ] ; } if ( n % 2 == 0 ) op [ mid + i ] = arr [ j ] ; System . out . println ( " Pendulum ▁ arrangement : " ) ; for ( i = 0 ; i < n ; i ++ ) System . out . print ( op [ i ] + " ▁ " ) ; System . out . println ( ) ; }
Ref: 
def pendulumArrangement ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE op = [ 0 ] * n NEW_LINE mid = int ( ( n - 1 ) / 2 ) NEW_LINE j = 1 NEW_LINE i = 1 NEW_LINE op [ mid ] = arr [ 0 ] NEW_LINE for i in range ( 1 , mid + 1 ) : NEW_LINE INDENT op [ mid + i ] = arr [ j ] NEW_LINE j += 1 NEW_LINE op [ mid - i ] = arr [ j ] NEW_LINE j += 1 NEW_LINE DEDENT if ( int ( n % 2 ) == 0 ) : NEW_LINE INDENT op [ mid + i ] = arr [ j ] NEW_LINE DEDENT print ( " Pendulum ▁ arrangement : " ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( op [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
Hyp: 
def pendulumArrangement ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE op = [ 0 ] * n NEW_LINE mid = int ( ( n - 1 ) / 2 ) NEW_LINE j = 1 NEW_LINE i = 1 NEW_LINE op [ mid ] = arr [ 0 ] NEW_LINE for i in range ( 1 , mid + 1 ) : NEW_LINE INDENT op [ mid + i ] = arr [ j ] NEW_LINE j += 1 NEW_LINE op [ mid - i ] = arr [ j ] NEW_LINE j += 1 NEW_LINE DEDENT if ( int ( n % 2 ) == 0 ) : NEW_LINE INDENT op [ mid + i ] = arr [ j ] NEW_LINE DEDENT print ( " Pendulum ▁ arrangement : " ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( op [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int countNumbers ( int n ) { return n - n / 2 - n / 3 - n / 5 - n / 7 + n / 6 + n / 10 + n / 14 + n / 15 + n / 21 + n / 35 - n / 30 - n / 42 - n / 70 - n / 105 + n / 210 ; }
Ref: 
def countNumbers ( n ) : NEW_LINE INDENT return ( n - n // 2 - n // 3 - n // 5 - n // 7 + n // 6 + n // 10 + n // 14 + n // 15 + n // 21 + n // 35 - n // 30 - n // 42 - n // 70 - n // 105 + n // 210 ) NEW_LINE DEDENT
Hyp: 
def countNumbers ( n ) : NEW_LINE INDENT return n - n / 2 - n / 3 - n / 5 - n / 7 + n / 10 + n / 14 + n / 15 + n / 21 + n / 35 - n / 30 - n / 42 - n / 70 - n / 105 + n / 210 ; NEW_LINE DEDENT

BLEU: 32.35
Edit Sim: 26


Src: 
int maxProd ( int N ) { if ( N == 0 ) return 1 ; if ( N < 10 ) return N ; return Math . max ( maxProd ( N / 10 ) * ( N % 10 ) , maxProd ( N / 10 - 1 ) * 9 ) ; }
Ref: 
def maxProd ( N ) : NEW_LINE INDENT if ( N == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( N < 10 ) : NEW_LINE INDENT return N NEW_LINE DEDENT return max ( maxProd ( N // 10 ) * ( N % 10 ) , maxProd ( N // 10 - 1 ) * 9 ) NEW_LINE DEDENT
Hyp: 
def maxProd ( N ) : NEW_LINE INDENT if ( N == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( N < 10 ) : NEW_LINE INDENT return N NEW_LINE DEDENT return max ( maxProd ( N / 10 ) * ( N % 10 ) , maxProd ( N / 10 - 1 ) * 9 ) NEW_LINE DEDENT

BLEU: 91.86
Edit Sim: 2


Src: 
void findNumbers ( String s ) { int n = s . length ( ) ; int count = 1 ; int result = 0 ; int left = 0 ; int right = 1 ; while ( right < n ) { if ( s . charAt ( left ) == s . charAt ( right ) ) { count ++ ; } else { result += count * ( count + 1 ) / 2 ; left = right ; count = 1 ; } right ++ ; } result += count * ( count + 1 ) / 2 ; System . out . println ( result ) ; }
Ref: 
def findNumbers ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE count = 1 NEW_LINE result = 0 NEW_LINE left = 0 NEW_LINE right = 1 NEW_LINE while ( right < n ) : NEW_LINE INDENT if ( s [ left ] == s [ right ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT result += count * ( count + 1 ) // 2 NEW_LINE left = right NEW_LINE count = 1 NEW_LINE DEDENT right += 1 NEW_LINE DEDENT result += count * ( count + 1 ) // 2 NEW_LINE print ( result ) NEW_LINE DEDENT
Hyp: 
def findNumbers ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE count = 1 NEW_LINE result = 0 NEW_LINE left = 0 NEW_LINE right = 1 NEW_LINE while ( right < n ) : NEW_LINE INDENT if ( s [ left ] == s [ right ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT result += count * ( count + 1 ) // 2 NEW_LINE left = right NEW_LINE count = 1 NEW_LINE DEDENT right += 1 NEW_LINE DEDENT result += count * ( count + 1 ) // 2 NEW_LINE print ( result ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
void removeElements ( int [ ] arr , int n ) { int [ ] brr = new int [ n ] ; int l = 1 ; brr [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( brr [ l - 1 ] <= arr [ i ] ) { brr [ l ] = arr [ i ] ; l ++ ; } } for ( int i = 0 ; i < l ; i ++ ) System . out . print ( brr [ i ] + " ▁ " ) ; }
Ref: 
def removeElements ( arr , n ) : NEW_LINE INDENT brr = [ 0 ] * n ; l = 1 ; NEW_LINE brr [ 0 ] = arr [ 0 ] ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( brr [ l - 1 ] <= arr [ i ] ) : NEW_LINE INDENT brr [ l ] = arr [ i ] ; NEW_LINE l += 1 ; NEW_LINE DEDENT DEDENT for i in range ( l ) : NEW_LINE INDENT print ( brr [ i ] , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT
Hyp: 
def removeElements ( arr , n ) : NEW_LINE INDENT brr = [ 0 ] * n NEW_LINE l = 1 NEW_LINE brr [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( brr [ l - 1 ] <= arr [ i ] ) : NEW_LINE INDENT brr [ l ] = arr [ i ] NEW_LINE l += 1 NEW_LINE DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( brr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT

BLEU: 83.29
Edit Sim: 23


Src: 
int alternate ( int a , int b , int x ) { return x = a ^ b ^ x ; }
Ref: 
def alternate ( a , b , x ) : NEW_LINE INDENT x = a ^ b ^ x NEW_LINE print ( " After ▁ exchange " ) NEW_LINE print ( " x ▁ is " , x ) NEW_LINE DEDENT
Hyp: 
def alternate ( a , b , x ) : NEW_LINE INDENT x = a ^ b ^ x NEW_LINE DEDENT return x NEW_LINE DEDENT

BLEU: 43.9
Edit Sim: 57


Src: 
void printNum ( int L , int R ) { for ( int i = L ; i <= R ; i ++ ) { int temp = i ; int c = 10 ; int flag = 0 ; while ( temp > 0 ) { if ( temp % 10 >= c ) { flag = 1 ; break ; } c = temp % 10 ; temp /= 10 ; } if ( flag == 0 ) System . out . print ( i + " ▁ " ) ; } }
Ref: 
def printNum ( L , R ) : NEW_LINE INDENT for i in range ( L , R + 1 ) : NEW_LINE INDENT temp = i NEW_LINE c = 10 NEW_LINE flag = 0 NEW_LINE while ( temp > 0 ) : NEW_LINE INDENT if ( temp % 10 >= c ) : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT c = temp % 10 NEW_LINE temp //= 10 NEW_LINE DEDENT if ( flag == 0 ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
Hyp: 
def printNum ( L , R ) : NEW_LINE INDENT for i in range ( L , R + 1 ) : NEW_LINE INDENT temp = i NEW_LINE c = 10 NEW_LINE flag = 0 NEW_LINE while ( temp > 0 ) : NEW_LINE INDENT if temp % 10 >= c : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT c = temp % 10 NEW_LINE temp //= 10 NEW_LINE DEDENT if flag == 0 : NEW_LINE INDENT print i , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT

BLEU: 86.68
Edit Sim: 10


Src: 
int countSubstringWithEqualEnds ( String s ) { int result = 0 ; int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i ; j < n ; j ++ ) if ( s . charAt ( i ) == s . charAt ( j ) ) result ++ ; return result ; }
Ref: 
def countSubstringWithEqualEnds ( s ) : NEW_LINE INDENT result = 0 ; NEW_LINE n = len ( s ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT if ( s [ i ] == s [ j ] ) : NEW_LINE INDENT result = result + 1 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
Hyp: 
def countSubstringWithEqualEnds ( s ) : NEW_LINE INDENT result = 0 NEW_LINE n = len ( s ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT if ( s [ i ] == s [ j ] ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT

BLEU: 84.02
Edit Sim: 18


Src: 
void cntWaysConsArray ( int A [ ] , int N ) { int total = 1 ; int oddArray = 1 ; for ( int i = 0 ; i < N ; i ++ ) { total = total * 3 ; if ( A [ i ] % 2 == 0 ) { oddArray *= 2 ; } } System . out . println ( total - oddArray ) ; }
Ref: 
def cntWaysConsArray ( A , N ) : NEW_LINE INDENT total = 1 ; NEW_LINE oddArray = 1 ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT total = total * 3 ; NEW_LINE if ( A [ i ] % 2 == 0 ) : NEW_LINE INDENT oddArray *= 2 ; NEW_LINE DEDENT DEDENT print ( total - oddArray ) ; NEW_LINE DEDENT
Hyp: 
def cntWaysConsArray ( A , N ) : NEW_LINE INDENT total = 1 NEW_LINE oddArray = 1 NEW_LINE for i in range ( N ) : NEW_LINE INDENT total = total * 3 NEW_LINE if ( A [ i ] % 2 == 0 ) : NEW_LINE INDENT oddArray *= 2 NEW_LINE DEDENT DEDENT print ( total - oddArray ) NEW_LINE DEDENT

BLEU: 80.83
Edit Sim: 10


Src: 
int minElements ( int arr [ ] , int N , int K ) { int count = 0 ; long requiredNum = 1 ; int i = 0 ; while ( requiredNum <= K ) { if ( i < N && requiredNum >= arr [ i ] ) { requiredNum += arr [ i ] ; i ++ ; } else { count ++ ; requiredNum += requiredNum ; } } return count ; }
Ref: 
def minElements ( arr , N , K ) : NEW_LINE INDENT count = 0 NEW_LINE requiredNum = 1 NEW_LINE i = 0 NEW_LINE while ( requiredNum <= K ) : NEW_LINE INDENT if ( i < N and requiredNum >= arr [ i ] ) : NEW_LINE INDENT requiredNum += arr [ i ] NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count += 1 NEW_LINE requiredNum += requiredNum NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
Hyp: 
def minElements ( arr , N , K ) : NEW_LINE INDENT count = 0 NEW_LINE requiredNum = 1 NEW_LINE i = 0 NEW_LINE while ( requiredNum <= K ) : NEW_LINE INDENT if ( i < N and requiredNum >= arr [ i ] ) : NEW_LINE INDENT requiredNum += arr [ i ] NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count += 1 NEW_LINE requiredNum += requiredNum NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
boolean isLowerTriangularMatrix ( int mat [ ] [ ] ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = i + 1 ; j < N ; j ++ ) if ( mat [ i ] [ j ] != 0 ) return false ; return true ; }
Ref: 
def islowertriangular ( M ) : NEW_LINE INDENT for i in range ( 0 , len ( M ) ) : NEW_LINE INDENT for j in range ( i + 1 , len ( M ) ) : NEW_LINE INDENT if ( M [ i ] [ j ] != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT M = [ [ 1 , 0 , 0 , 0 ] , [ 1 , 4 , 0 , 0 ] , [ 4 , 6 , 2 , 0 ] , [ 0 , 4 , 7 , 6 ] ] NEW_LINE if islowertriangular ( M ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
Hyp: 
def isLowerTriangularMatrix ( mat ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT if ( mat [ i ] [ j ] != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT mat = [ [ 1 , 3 , 5 ] , [ 3 , 2 , 4 ] , [ 5 , 4 , 1 ] ] NEW_LINE if ( isLowerTriangularMatrix ( mat ) ) : NEW_LINE INDENT print " Yes " NEW_LINE DEDENT else : NEW_LINE INDENT print " No " NEW_LINE DEDENT

BLEU: 50.32
Edit Sim: 99


Src: 
int modFact ( int n , int m ) { int result = 1 ; for ( int i = 1 ; i <= m ; i ++ ) result = ( result * i ) % MOD ; return result ; }
Ref: 
def modFact ( n , m ) : NEW_LINE INDENT result = 1 NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT result = ( result * i ) % MOD NEW_LINE DEDENT return result NEW_LINE DEDENT
Hyp: 
def modFact ( n , m ) : NEW_LINE INDENT result = 1 NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT result = ( result * i ) % MOD NEW_LINE DEDENT return result NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
void findWinner ( int a [ ] , int n ) { int win = 0 ; if ( n % 2 == 0 ) win = 1 ; else win = 0 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( i % 2 == 1 ) { if ( win == 0 && a [ i ] > 1 ) win = 1 ; } else { if ( win == 1 && a [ i ] > 1 ) win = 0 ; } } if ( win == 0 ) System . out . print ( " A " ) ; else System . out . print ( " B " ) ; }
Ref: 
def findWinner ( a , n ) : NEW_LINE INDENT win = 0 NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT win = 1 NEW_LINE DEDENT else : NEW_LINE INDENT win = 0 NEW_LINE DEDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( i % 2 == 1 ) : NEW_LINE INDENT if ( win == 0 and a [ i ] > 1 ) : NEW_LINE INDENT win = 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( win == 1 and a [ i ] > 1 ) : NEW_LINE INDENT win = 0 NEW_LINE DEDENT DEDENT DEDENT if ( win == 0 ) : NEW_LINE INDENT print ( " A " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " B " ) NEW_LINE DEDENT DEDENT
Hyp: 
def findWinner ( a , n ) : NEW_LINE INDENT win = 0 NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT win = 1 NEW_LINE DEDENT else : NEW_LINE INDENT win = 0 NEW_LINE DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( i % 2 == 1 ) : NEW_LINE INDENT if ( win == 0 and a [ i ] > 1 ) : NEW_LINE INDENT win = 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( win == 1 and a [ i ] > 1 ) : NEW_LINE INDENT win = 0 NEW_LINE DEDENT DEDENT if ( win == 0 ) : NEW_LINE INDENT print ( " A " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " B " ) NEW_LINE DEDENT DEDENT

BLEU: 96.22
Edit Sim: 15


Src: 
int minOp ( int num ) { int rem ; int count = 0 ; while ( num > 0 ) { rem = num % 10 ; if ( ! ( rem == 3 rem == 8 ) ) count ++ ; num /= 10 ; } return count ; }
Ref: 
def minOp ( num ) : NEW_LINE INDENT count = 0 NEW_LINE while ( num ) : NEW_LINE INDENT rem = num % 10 NEW_LINE if ( not ( rem == 3 or rem == 8 ) ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT num = num // 10 NEW_LINE DEDENT return count NEW_LINE DEDENT
Hyp: 
def minOp ( num ) : NEW_LINE INDENT rem = num % 10 NEW_LINE count = 0 NEW_LINE while ( num > 0 ) : NEW_LINE INDENT rem = num % 10 NEW_LINE if ( not ( rem == 3 or rem == 8 ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT num /= 10 NEW_LINE DEDENT return count NEW_LINE DEDENT

BLEU: 74.92
Edit Sim: 44


Src: 
void possibleAcyclicGraph ( int N ) { System . out . print ( ( int ) Math . pow ( 2 , N - 1 ) ) ; return ; }
Ref: 
def possibleAcyclicGraph ( N ) : NEW_LINE INDENT print ( pow ( 2 , N - 1 ) ) NEW_LINE return NEW_LINE DEDENT
Hyp: 
def possibleAcyclicGraph ( N ) : NEW_LINE INDENT print ( 2 ** floor ( N - 1 ) ) NEW_LINE return NEW_LINE DEDENT

BLEU: 77.84
Edit Sim: 10


Src: 
void printCollatz ( int n ) { while ( n != 1 ) { System . out . print ( n + " ▁ " ) ; if ( ( n & 1 ) == 1 ) n = 3 * n + 1 ; else n = n / 2 ; } System . out . print ( n ) ; }
Ref: 
def printCollatz ( n ) : NEW_LINE INDENT while n != 1 : NEW_LINE INDENT print ( n , end = ' ▁ ' ) NEW_LINE if n & 1 : NEW_LINE INDENT n = 3 * n + 1 NEW_LINE DEDENT else : NEW_LINE INDENT n = n // 2 NEW_LINE DEDENT DEDENT print ( n ) NEW_LINE DEDENT
Hyp: 
def printCollatz ( n ) : NEW_LINE INDENT while ( n != 1 ) : NEW_LINE INDENT print ( n , end = " ▁ " ) NEW_LINE if ( n & 1 ) : NEW_LINE INDENT n = 3 * n + 1 NEW_LINE DEDENT else : NEW_LINE INDENT n = n // 2 NEW_LINE DEDENT DEDENT print ( n ) NEW_LINE DEDENT

BLEU: 76.77
Edit Sim: 10


Src: 
int NumberofTimes ( String str ) { int temporary_sum = 0 , count = 0 ; while ( str . length ( ) > 1 ) { temporary_sum = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) temporary_sum += ( str . charAt ( i ) - '0' ) ; str = temporary_sum + " " ; count ++ ; } return count ; }
Ref: 
def NumberofTimes ( s ) : NEW_LINE INDENT temporary_sum = 0 NEW_LINE count = 0 NEW_LINE while ( len ( s ) > 1 ) : NEW_LINE INDENT temporary_sum = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT temporary_sum += ( ord ( s [ i ] ) - ord ( '0' ) ) NEW_LINE DEDENT s = str ( temporary_sum ) NEW_LINE count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
Hyp: 
def NumberofTimes ( str ) : NEW_LINE INDENT temporary_sum = 0 ; count = 0 ; NEW_LINE while ( len ( str ) > 1 ) : NEW_LINE INDENT temporary_sum = 0 ; NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT temporary_sum += ord ( str [ i ] ) - ord ( '0' ) ; NEW_LINE DEDENT count += 1 ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT

BLEU: 57.82
Edit Sim: 62


Src: 
int find_consecutive_steps ( int arr [ ] , int len ) { int count = 0 ; int maximum = 0 ; for ( int index = 1 ; index < len ; index ++ ) { if ( arr [ index ] > arr [ index - 1 ] ) count ++ ; else { maximum = Math . max ( maximum , count ) ; count = 0 ; } } return Math . max ( maximum , count ) ; }
Ref: 
def find_consecutive_steps ( arr , len ) : NEW_LINE INDENT count = 0 ; maximum = 0 NEW_LINE for index in range ( 1 , len ) : NEW_LINE INDENT if ( arr [ index ] > arr [ index - 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT maximum = max ( maximum , count ) NEW_LINE count = 0 NEW_LINE DEDENT DEDENT return max ( maximum , count ) NEW_LINE DEDENT
Hyp: 
def find_consecutive_steps ( arr , l ) : NEW_LINE INDENT count = 0 NEW_LINE maximum = 0 NEW_LINE for index in range ( 1 , l ) : NEW_LINE INDENT if ( arr [ index ] > arr [ index - 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT maximum = max ( maximum , count ) NEW_LINE count = 0 NEW_LINE DEDENT DEDENT return max ( maximum , count ) NEW_LINE DEDENT

BLEU: 90.4
Edit Sim: 12


Src: 
int negProdSubArr ( int arr [ ] , int n ) { int positive = 1 , negative = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 ) arr [ i ] = 1 ; else arr [ i ] = - 1 ; if ( i > 0 ) arr [ i ] *= arr [ i - 1 ] ; if ( arr [ i ] == 1 ) positive ++ ; else negative ++ ; } return ( positive * negative ) ; }
Ref: 
def negProdSubArr ( arr , n ) : NEW_LINE INDENT positive = 1 NEW_LINE negative = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT arr [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = - 1 NEW_LINE DEDENT if ( i > 0 ) : NEW_LINE INDENT arr [ i ] *= arr [ i - 1 ] NEW_LINE DEDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT positive += 1 NEW_LINE DEDENT else : NEW_LINE INDENT negative += 1 NEW_LINE DEDENT DEDENT return ( positive * negative ) NEW_LINE DEDENT
Hyp: 
def negProdSubArr ( arr , n ) : NEW_LINE INDENT positive = 1 ; negative = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT arr [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = - 1 NEW_LINE DEDENT if ( i > 0 ) : NEW_LINE INDENT arr [ i ] *= arr [ i - 1 ] NEW_LINE DEDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT positive += 1 NEW_LINE DEDENT else : NEW_LINE INDENT negative += 1 NEW_LINE DEDENT DEDENT return ( positive * negative ) ; NEW_LINE DEDENT

BLEU: 93.87
Edit Sim: 12


Src: 
int maxProduct ( int arr [ ] , int n ) { if ( n < 3 ) { return - 1 ; } Arrays . sort ( arr ) ; return Math . max ( arr [ 0 ] * arr [ 1 ] * arr [ n - 1 ] , arr [ n - 1 ] * arr [ n - 2 ] * arr [ n - 3 ] ) ; }
Ref: 
def maxProduct ( arr , n ) : NEW_LINE INDENT if n < 3 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT arr . sort ( ) NEW_LINE return max ( arr [ 0 ] * arr [ 1 ] * arr [ n - 1 ] , arr [ n - 1 ] * arr [ n - 2 ] * arr [ n - 3 ] ) NEW_LINE DEDENT
Hyp: 
def maxProduct ( arr , n ) : NEW_LINE INDENT if ( n < 3 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT arr . sort ( ) NEW_LINE return max ( arr [ 0 ] * arr [ 1 ] * arr [ n - 1 ] , arr [ n - 1 ] * arr [ n - 2 ] * arr [ n - 3 ] ) NEW_LINE DEDENT

BLEU: 93.0
Edit Sim: 4


Src: 
int countSeq ( int n ) { int nCr = 1 , res = 1 ; for ( int r = 1 ; r <= n ; r ++ ) { nCr = ( nCr * ( n + 1 - r ) ) / r ; res += nCr * nCr ; } return res ; }
Ref: 
def countSeq ( n ) : NEW_LINE INDENT nCr = 1 NEW_LINE res = 1 NEW_LINE for r in range ( 1 , n + 1 ) : NEW_LINE INDENT nCr = ( nCr * ( n + 1 - r ) ) / r ; NEW_LINE res += nCr * nCr ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT
Hyp: 
def countSeq ( n ) : NEW_LINE INDENT nCr = 1 NEW_LINE res = 1 NEW_LINE for r in range ( 1 , n + 1 ) : NEW_LINE INDENT nCr = ( nCr * ( n + 1 - r ) ) // r NEW_LINE res += nCr * nCr NEW_LINE DEDENT return res NEW_LINE DEDENT

BLEU: 84.48
Edit Sim: 7


Src: 
String SmallestString ( String s , char c ) { for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) > c ) { String temp = s ; s = s . substring ( 0 , i ) ; s += c ; s += temp . substring ( i , temp . length ( ) ) ; return s ; } } s += c ; return s ; }
Ref: 
def SmallestString ( s , c ) : NEW_LINE INDENT i = 0 NEW_LINE while ( i < len ( s ) ) : NEW_LINE INDENT if s [ i ] > c : NEW_LINE INDENT s = s [ : i ] + c + s [ i : ] NEW_LINE return s NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT s = s + c NEW_LINE return s NEW_LINE DEDENT
Hyp: 
def SmallestString ( s , c ) : NEW_LINE INDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] > c ) : NEW_LINE INDENT temp = s NEW_LINE s = s [ : i ] NEW_LINE s += c NEW_LINE s += temp [ i : len ( temp ) ] NEW_LINE return s NEW_LINE DEDENT DEDENT s += c NEW_LINE return s NEW_LINE DEDENT

BLEU: 53.16
Edit Sim: 97


Src: 
int getSum ( int arr [ ] , int p ) { return arr . length ; }
Ref: 
def getSum ( arr , p ) : NEW_LINE INDENT return len ( arr ) NEW_LINE DEDENT
Hyp: 
def getSum ( arr , p ) : NEW_LINE INDENT return sum ( arr , p ) NEW_LINE DEDENT

BLEU: 67.09
Edit Sim: 7


Src: 
void countPairs ( int arr [ ] , int N , int K ) { Map < Integer , Integer > mp = new HashMap < > ( ) ; int cnt = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( mp . get ( K - arr [ i ] ) != null ) cnt += mp . get ( K - arr [ i ] ) ; mp . put ( arr [ i ] , mp . get ( arr [ i ] ) == null ? 1 : mp . get ( arr [ i ] ) + 1 ) ; } System . out . println ( cnt ) ; }
Ref: 
def countPairs ( arr , N , K ) : NEW_LINE INDENT mp = defaultdict ( int ) NEW_LINE cnt = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT cnt += mp [ K - arr [ i ] ] NEW_LINE mp [ arr [ i ] ] += 1 NEW_LINE DEDENT print ( cnt ) NEW_LINE DEDENT
Hyp: 
def countPairs ( arr , N , K ) : NEW_LINE INDENT mp = defaultdict ( lambda : 0 ) NEW_LINE cnt = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( K - arr [ i ] ) in mp : NEW_LINE INDENT cnt += mp [ K - arr [ i ] ] NEW_LINE DEDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT print ( cnt ) NEW_LINE DEDENT

BLEU: 73.13
Edit Sim: 62


Src: 
double Convert ( double degree ) { double pi = 3.14159265359 ; return ( degree * ( pi / 180 ) ) ; }
Ref: 
def Convert ( degree ) : NEW_LINE INDENT pi = 3.14159265359 ; NEW_LINE return ( degree * ( pi / 180 ) ) ; NEW_LINE DEDENT
Hyp: 
def Convert ( degree ) : NEW_LINE INDENT pi = 3.14159265359 NEW_LINE return ( degree * ( pi / 180 ) ) NEW_LINE DEDENT

BLEU: 80.47
Edit Sim: 4


Src: 
float squareArea ( float l , float b , float h ) { if ( l < 0 b < 0 h < 0 ) return - 1 ; float a = ( l * b ) / ( l + b ) ; return a * a ; }
Ref: 
def squareArea ( l , b , h ) : NEW_LINE INDENT if l < 0 or b < 0 or h < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT a = ( l * b ) / ( l + b ) NEW_LINE return a * a NEW_LINE DEDENT
Hyp: 
def squareArea ( l , b , h ) : NEW_LINE INDENT if l < 0 or b < 0 or h < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT a = ( l * b ) / ( l + b ) NEW_LINE return a * a NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int xorK ( int n , int k ) { int res = n ; for ( int i = 1 ; i < k ; i ++ ) res = ( res ^ n ) ; return n ; }
Ref: 
def xorK ( n , k ) : NEW_LINE INDENT res = n NEW_LINE for i in range ( 1 , k ) : NEW_LINE INDENT res = ( res ^ n ) NEW_LINE DEDENT return n NEW_LINE DEDENT
Hyp: 
def xorK ( n , k ) : NEW_LINE INDENT res = n NEW_LINE for i in range ( k ) : NEW_LINE INDENT res = ( res ^ n ) NEW_LINE DEDENT return n NEW_LINE DEDENT

BLEU: 90.7
Edit Sim: 4


Src: 
void printPairs ( int arr [ ] , int n ) { Set < Integer > pairs = new HashSet < Integer > ( ) ; boolean pair_exists = false ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] > 0 ) pairs . add ( arr [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < 0 ) if ( pairs . contains ( - arr [ i ] ) ) { System . out . println ( arr [ i ] + " , ▁ " + - arr [ i ] ) ; pair_exists = true ; } } if ( pair_exists == false ) System . out . println ( " No ▁ such ▁ pair ▁ exists " ) ; }
Ref: 
def printPairs ( arr , n ) : NEW_LINE INDENT pairs = set ( ) NEW_LINE pair_exists = False NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if arr [ i ] > 0 : NEW_LINE INDENT pairs . add ( arr [ i ] ) NEW_LINE DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if arr [ i ] < 0 : NEW_LINE INDENT if ( - arr [ i ] ) in pairs : NEW_LINE INDENT print ( " { } , ▁ { } " . format ( arr [ i ] , - arr [ i ] ) ) NEW_LINE pair_exists = True NEW_LINE DEDENT DEDENT DEDENT if pair_exists == False : NEW_LINE INDENT print ( " No ▁ such ▁ pair ▁ exists " ) NEW_LINE DEDENT DEDENT
Hyp: 
def printPairs ( arr , n ) : NEW_LINE INDENT pairs = set ( ) NEW_LINE pair_exists = False NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT pairs . add ( arr [ i ] ) NEW_LINE DEDENT pair_exists = True NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] < 0 ) : NEW_LINE INDENT if ( pairs [ - arr [ i ] in pairs ) : NEW_LINE INDENT print ( arr [ i ] , " , ▁ " , - arr [ i ] ) NEW_LINE pair_exists = True NEW_LINE DEDENT DEDENT DEDENT if ( pair_exists == False ) : NEW_LINE INDENT print ( " No ▁ such ▁ pair ▁ exists " ) NEW_LINE DEDENT DEDENT

BLEU: 74.07
Edit Sim: 89


Src: 
double findMedian ( int a [ ] , int n ) { Arrays . sort ( a ) ; if ( n % 2 != 0 ) return ( double ) a [ n / 2 ] ; return ( double ) ( a [ ( n - 1 ) / 2 ] + a [ n / 2 ] ) / 2.0 ; }
Ref: 
def findMedian ( a , n ) : NEW_LINE INDENT sorted ( a ) NEW_LINE if n % 2 != 0 : NEW_LINE INDENT return float ( a [ n // 2 ] ) NEW_LINE DEDENT return float ( ( a [ int ( ( n - 1 ) / 2 ) ] + a [ int ( n / 2 ) ] ) / 2.0 ) NEW_LINE DEDENT
Hyp: 
def findMedian ( a , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE if n % 2 != 0 : NEW_LINE INDENT return a [ n // 2 ] NEW_LINE DEDENT return ( a [ ( n - 1 ) // 2 ] + a [ n // 2 ] ) / 2.0 NEW_LINE DEDENT

BLEU: 53.14
Edit Sim: 45


Src: 
double find_area ( int r , int d ) { double R = d / PI ; R += Math . pow ( r , 2 ) ; R = Math . sqrt ( R ) ; double area = PI * Math . pow ( R , 2 ) ; return area ; }
Ref: 
def find_area ( r , d ) : NEW_LINE INDENT R = d / PI NEW_LINE R += pow ( r , 2 ) NEW_LINE R = sqrt ( R ) NEW_LINE area = PI * pow ( R , 2 ) NEW_LINE return area NEW_LINE DEDENT
Hyp: 
def find_area ( r , d ) : NEW_LINE INDENT R = d / PI NEW_LINE R += pow ( r , 2 ) NEW_LINE R = math . sqrt ( R ) NEW_LINE area = PI * pow ( R , 2 ) NEW_LINE return area NEW_LINE DEDENT

BLEU: 92.69
Edit Sim: 7


Src: 
double sum ( double a , double b , double c , double d , double x ) { double ans = ( x * ( a + b ) * ( c - d ) ) / ( ( a * d ) - ( b * c ) ) ; return ans ; }
Ref: 
def sum ( a , b , c , d , x ) : NEW_LINE INDENT ans = ( ( x * ( a + b ) * ( c - d ) ) / ( ( a * d ) - ( b * c ) ) ) ; NEW_LINE return ans ; NEW_LINE DEDENT
Hyp: 
def sum ( a , b , c , d , x ) : NEW_LINE INDENT ans = ( ( x * ( a + b ) * ( c - d ) ) / ( ( a * d ) - ( b * c ) ) ; NEW_LINE return ans NEW_LINE DEDENT

BLEU: 93.6
Edit Sim: 4


Src: 
void BalancedNumber ( String s ) { int Leftsum = 0 ; int Rightsum = 0 ; for ( int i = 0 ; i < s . length ( ) / 2 ; i ++ ) { Leftsum += ( int ) ( s . charAt ( i ) - '0' ) ; Rightsum += ( int ) ( s . charAt ( s . length ( ) - 1 - i ) - '0' ) ; } if ( Leftsum == Rightsum ) System . out . println ( " Balanced " ) ; else System . out . println ( " Not ▁ Balanced " ) ; }
Ref: 
def BalancedNumber ( s ) : NEW_LINE INDENT Leftsum = 0 NEW_LINE Rightsum = 0 NEW_LINE for i in range ( 0 , int ( len ( s ) / 2 ) ) : NEW_LINE INDENT Leftsum = Leftsum + int ( s [ i ] ) NEW_LINE Rightsum = ( Rightsum + int ( s [ len ( s ) - 1 - i ] ) ) NEW_LINE DEDENT if ( Leftsum == Rightsum ) : NEW_LINE INDENT print ( " Balanced " , end =   ' ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ Balanced " , end =   ' ' ) NEW_LINE DEDENT DEDENT
Hyp: 
def BalancedNumber ( s ) : NEW_LINE INDENT Leftsum = 0 NEW_LINE Rightsum = 0 NEW_LINE for i in range ( int ( len ( s ) / 2 ) ) : NEW_LINE INDENT Leftsum += int ( s [ i ] ) - ord ( '0' ) NEW_LINE Rightsum += int ( s [ len ( s ) - 1 - i ] ) - ord ( '0' ) NEW_LINE DEDENT if ( Leftsum == Rightsum ) : NEW_LINE INDENT print ( " Balanced " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ Balanced " ) NEW_LINE DEDENT DEDENT

BLEU: 73.83
Edit Sim: 78


Src: 
boolean isPossibleToZero ( int a [ ] , int n ) { int num = 0 ; for ( int i = 0 ; i < n ; i ++ ) num = num * 10 + a [ i ] ; return ( num % 11 == 0 ) ; }
Ref: 
def isPossibleToZero ( a , n ) : NEW_LINE INDENT num = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT num = num * 10 + a [ i ] ; NEW_LINE DEDENT return ( num % 11 == 0 ) ; NEW_LINE DEDENT arr = [ 0 , 1 , 1 , 0 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE if ( isPossibleToZero ( arr , n ) ) : NEW_LINE INDENT print ( " YES " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) ; NEW_LINE DEDENT
Hyp: 
def isPossibleToZero ( a , n ) : NEW_LINE INDENT num = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT num = num * 10 + a [ i ] NEW_LINE DEDENT return ( num % 11 == 0 ) NEW_LINE DEDENT

BLEU: 25.57
Edit Sim: 216


Src: 
int minOperations ( String s ) { int len = s . length ( ) ; int result = 0 ; for ( int i = 0 ; i < len / 2 ; i ++ ) { int D1 = Math . max ( s . charAt ( i ) , s . charAt ( len - 1 - i ) ) - Math . min ( s . charAt ( i ) , s . charAt ( len - 1 - i ) ) ; int D2 = 26 - D1 ; result += Math . min ( D1 , D2 ) ; } return result ; }
Ref: 
def minOperations ( s ) : NEW_LINE INDENT length = len ( s ) NEW_LINE result = 0 NEW_LINE for i in range ( length // 2 ) : NEW_LINE INDENT D1 = ( ord ( max ( s [ i ] , s [ length - 1 - i ] ) ) - ord ( min ( s [ i ] , s [ length - 1 - i ] ) ) ) NEW_LINE D2 = 26 - D1 NEW_LINE result += min ( D1 , D2 ) NEW_LINE DEDENT return result NEW_LINE DEDENT
Hyp: 
def minOperations ( s ) : NEW_LINE INDENT ln = len ( s ) NEW_LINE result = 0 NEW_LINE for i in range ( 0 , int ( len / 2 ) ) : NEW_LINE INDENT D1 = max ( s [ i ] , s [ len - 1 - i ] ) - min ( s [ i ] , s [ len - 1 - i ] ) NEW_LINE D2 = 26 - D1 NEW_LINE result += min ( D1 , D2 ) NEW_LINE DEDENT return result NEW_LINE DEDENT

BLEU: 74.85
Edit Sim: 44


Src: 
void minDistance ( int n , int k , int point [ ] [ ] ) { for ( int i = 0 ; i < k ; i ++ ) Arrays . sort ( point [ i ] ) ; for ( int i = 0 ; i < k ; i ++ ) System . out . print ( point [ i ] [ ( int ) Math . ceil ( ( double ) ( n / 2 ) - 1 ) ] + " ▁ " ) ; }
Ref: 
def minDistance ( n , k , point ) : NEW_LINE INDENT for i in range ( k ) : NEW_LINE INDENT point [ i ] . sort ( ) NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT print ( point [ i ] [ ( ( n + 1 ) // 2 ) - 1 ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
Hyp: 
def minDistance ( n , k , point ) : NEW_LINE INDENT for i in range ( k ) : NEW_LINE INDENT point [ i ] = sorted ( point [ i ] ) NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT print ( point [ i ] [ int ( math . ceil ( n / 2 ) - 1 ) ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT

BLEU: 75.32
Edit Sim: 32


Src: 
float circlearea ( float R ) { if ( R < 0 ) return - 1 ; float a = ( float ) ( ( 3.14 * R * R ) / 4 ) ; return a ; }
Ref: 
def circlearea ( R ) : NEW_LINE INDENT if ( R < 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT a = ( 3.14 * R * R ) / 4 ; NEW_LINE return a ; NEW_LINE DEDENT
Hyp: 
def circlearea ( R ) : NEW_LINE INDENT if ( R < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT a = ( 3.14 * R * R ) / 4 NEW_LINE return a NEW_LINE DEDENT

BLEU: 81.34
Edit Sim: 6


Src: 
int CountWays ( int n ) { int ans = ( n - 1 ) / 2 ; return ans ; }
Ref: 
def CountWays ( n ) : NEW_LINE INDENT ans = ( n - 1 ) // 2 NEW_LINE return ans NEW_LINE DEDENT
Hyp: 
def CountWays ( n ) : NEW_LINE INDENT ans = ( n - 1 ) // 2 NEW_LINE return ans NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int countTriplets ( int arr [ ] , int n , int m ) { int count = 0 ; Arrays . sort ( arr ) ; int end , start , mid ; for ( end = n - 1 ; end >= 2 ; end -- ) { start = 0 ; mid = end - 1 ; while ( start < mid ) { long prod = arr [ end ] * arr [ start ] * arr [ mid ] ; if ( prod > m ) mid -- ; else if ( prod < m ) start ++ ; else if ( prod == m ) { count ++ ; mid -- ; start ++ ; } } } return count ; }
Ref: 
def countTriplets ( arr , n , m ) : NEW_LINE INDENT count = 0 NEW_LINE arr . sort ( ) NEW_LINE for end in range ( n - 1 , 1 , - 1 ) : NEW_LINE INDENT start = 0 NEW_LINE mid = end - 1 NEW_LINE while ( start < mid ) : NEW_LINE INDENT prod = ( arr [ end ] * arr [ start ] * arr [ mid ] ) NEW_LINE if ( prod > m ) : NEW_LINE INDENT mid -= 1 NEW_LINE DEDENT elif ( prod < m ) : NEW_LINE INDENT start += 1 NEW_LINE DEDENT elif ( prod == m ) : NEW_LINE INDENT count += 1 NEW_LINE mid -= 1 NEW_LINE start += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
Hyp: 
def countTriplets ( arr , n , m ) : NEW_LINE INDENT count = 0 NEW_LINE arr . sort ( ) NEW_LINE end = n - 1 NEW_LINE start = 0 NEW_LINE mid = end - 1 NEW_LINE while start < mid : NEW_LINE INDENT prod = arr [ end ] * arr [ start ] * arr [ mid ] NEW_LINE if ( prod > m ) : NEW_LINE INDENT mid -= 1 NEW_LINE DEDENT elif ( prod < m ) : NEW_LINE INDENT start += 1 NEW_LINE DEDENT elif ( prod == m ) : NEW_LINE INDENT count += 1 NEW_LINE mid -= 1 NEW_LINE DEDENT start += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT

BLEU: 77.56
Edit Sim: 57


Src: 
int maxOperations ( int X , int Y ) { if ( X > Y ) return - 1 ; int diff = Y - X ; if ( diff == 1 ) return - 1 ; if ( diff % 2 == 0 ) return ( diff / 2 ) ; return ( 1 + ( ( diff - 3 ) / 2 ) ) ; }
Ref: 
def maxOperations ( X , Y ) : NEW_LINE INDENT if ( X > Y ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT diff = Y - X ; NEW_LINE if ( diff == 1 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT if ( diff % 2 == 0 ) : NEW_LINE INDENT return ( diff // 2 ) ; NEW_LINE DEDENT return ( 1 + ( ( diff - 3 ) // 2 ) ) ; NEW_LINE DEDENT
Hyp: 
def maxOperations ( X , Y ) : NEW_LINE INDENT if ( X > Y ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT diff = Y - X NEW_LINE if ( diff == 1 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( diff % 2 == 0 ) : NEW_LINE INDENT return ( diff // 2 ) NEW_LINE DEDENT return ( 1 + ( ( diff - 3 ) // 2 ) ) NEW_LINE DEDENT

BLEU: 84.87
Edit Sim: 10


Src: 
int countSortedArrays ( int start , int m , int size , int n ) { if ( size == m ) return 1 ; if ( start > n ) return 0 ; int notTaken = 0 , taken = 0 ; taken = countSortedArrays ( start , m , size + 1 , n ) ; notTaken = countSortedArrays ( start + 1 , m , size , n ) ; return taken + notTaken ; }
Ref: 
def countSortedArrays ( start , m , size , n ) : NEW_LINE INDENT if ( size == m ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( start > n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT notTaken , taken = 0 , 0 NEW_LINE taken = countSortedArrays ( start , m , size + 1 , n ) NEW_LINE notTaken = countSortedArrays ( start + 1 , m , size , n ) NEW_LINE return taken + notTaken NEW_LINE DEDENT
Hyp: 
def countSortedArrays ( start , m , size , n ) : NEW_LINE INDENT if ( size == m ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( start > n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT notTaken = 0 NEW_LINE taken = 0 NEW_LINE taken = countSortedArrays ( start , m , size + 1 , n ) NEW_LINE notTaken = countSortedArrays ( start + 1 , m , size , n ) NEW_LINE return taken + notTaken NEW_LINE DEDENT

BLEU: 93.93
Edit Sim: 16


Src: 
String canSplitArray ( int arr [ ] , int n , int k ) { for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] <= k ) { return " No " ; } } return " Yes " ; }
Ref: 
def canSplitArray ( arr , n , k ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] <= k ) : NEW_LINE INDENT return " No " NEW_LINE DEDENT DEDENT return " Yes " NEW_LINE DEDENT
Hyp: 
def canSplitArray ( arr , n , k ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if arr [ i ] <= k : NEW_LINE INDENT return " No " NEW_LINE DEDENT DEDENT return " Yes " NEW_LINE DEDENT

BLEU: 88.94
Edit Sim: 4


Src: 
int stepRequired ( int N ) { int cnt = 0 ; while ( N > 0 ) { N = N & ( N - 1 ) ; cnt ++ ; } return cnt ; }
Ref: 
def stepRequired ( N ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE while ( N > 0 ) : NEW_LINE INDENT N = N & ( N - 1 ) ; NEW_LINE cnt += 1 ; NEW_LINE DEDENT return cnt ; NEW_LINE DEDENT
Hyp: 
def stepRequired ( N ) : NEW_LINE INDENT cnt = 0 NEW_LINE while ( N ) : NEW_LINE INDENT N = N & ( N - 1 ) NEW_LINE cnt += 1 NEW_LINE DEDENT return cnt NEW_LINE DEDENT

BLEU: 67.36
Edit Sim: 12


Src: 
void findPair ( int x ) { int lim = 120 ; for ( int i = - lim ; i <= lim ; i ++ ) { for ( int j = - lim ; j <= lim ; j ++ ) { if ( Math . pow ( i , 5 ) - Math . pow ( j , 5 ) == x ) { System . out . print ( i + " ▁ " + j + "NEW_LINE"); return ; } } } System . out . print ( " - 1" ) ; }
Ref: 
def findPair ( x ) : NEW_LINE INDENT lim = 120 NEW_LINE for i in range ( - lim , lim + 1 ) : NEW_LINE INDENT for j in range ( - lim , lim + 1 ) : NEW_LINE INDENT if ( math . pow ( i , 5 ) - math . pow ( j , 5 ) == x ) : NEW_LINE INDENT print ( i , end = ' ▁ ' ) NEW_LINE print ( j , end =   ' ' ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT print ( " - 1" ) NEW_LINE DEDENT
Hyp: 
def findPair ( x ) : NEW_LINE INDENT lim = 120 NEW_LINE for i in range ( - lim , lim + 1 ) : NEW_LINE INDENT for j in range ( - lim , lim + 1 ) : NEW_LINE INDENT if ( pow ( i , 5 ) - pow ( j , 5 ) == x ) : NEW_LINE INDENT print ( i , " ▁ " , j , "NEW_LINE" ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT print ( " - 1" ) NEW_LINE DEDENT

BLEU: 76.83
Edit Sim: 47


Src: 
int totalCountDifference ( int n ) { if ( n == 1 ) return 1 ; return n + totalCountDifference ( n / 2 ) ; }
Ref: 
def totalCountDifference ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return n + totalCountDifference ( n // 2 ) NEW_LINE DEDENT
Hyp: 
def totalCountDifference ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return n + totalCountDifference ( n // 2 ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int countZeroes ( int mat [ ] [ ] ) { int row = N - 1 , col = 0 ; int count = 0 ; while ( col < N ) { while ( mat [ row ] [ col ] > 0 ) if ( -- row < 0 ) return count ; count += ( row + 1 ) ; col ++ ; } return count ; }
Ref: 
def countZeroes ( mat ) : NEW_LINE INDENT row = N - 1 ; NEW_LINE col = 0 ; NEW_LINE count = 0 ; NEW_LINE while ( col < N ) : NEW_LINE INDENT while ( mat [ row ] [ col ] ) : NEW_LINE INDENT if ( row < 0 ) : NEW_LINE INDENT return count ; NEW_LINE DEDENT row = row - 1 ; NEW_LINE DEDENT count = count + ( row + 1 ) ; NEW_LINE col = col + 1 ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT
Hyp: 
def countZeroes ( mat ) : NEW_LINE INDENT row = N - 1 NEW_LINE col = 0 NEW_LINE count = 0 NEW_LINE while ( col < N ) : NEW_LINE INDENT while ( mat [ row ] [ col ] > 0 ) : NEW_LINE INDENT if ( -- row < 0 ) : NEW_LINE INDENT return count NEW_LINE DEDENT count += ( row + 1 ) NEW_LINE col += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT

BLEU: 58.38
Edit Sim: 69


Src: 
void isPerfectSquare ( int x ) { int sr = ( int ) Math . sqrt ( x ) ; if ( sr * sr == x ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; }
Ref: 
def isPerfectSquare ( x ) : NEW_LINE INDENT sr = int ( sqrt ( x ) ) ; NEW_LINE if ( sr * sr == x ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT DEDENT
Hyp: 
def isPerfectSquare ( x ) : NEW_LINE INDENT sr = math . floor ( math . sqrt ( x ) ) NEW_LINE if ( sr * sr == x ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT

BLEU: 77.26
Edit Sim: 24


Src: 
int maxAbsDiff ( int arr [ ] , int n ) { int minEle = arr [ 0 ] ; int maxEle = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { minEle = Math . min ( minEle , arr [ i ] ) ; maxEle = Math . max ( maxEle , arr [ i ] ) ; } return ( maxEle - minEle ) ; }
Ref: 
def maxAbsDiff ( arr , n ) : NEW_LINE INDENT minEle = arr [ 0 ] NEW_LINE maxEle = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT minEle = min ( minEle , arr [ i ] ) NEW_LINE maxEle = max ( maxEle , arr [ i ] ) NEW_LINE DEDENT return ( maxEle - minEle ) NEW_LINE DEDENT
Hyp: 
def maxAbsDiff ( arr , n ) : NEW_LINE INDENT minEle = arr [ 0 ] NEW_LINE maxEle = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT minEle = min ( minEle , arr [ i ] ) NEW_LINE maxEle = max ( maxEle , arr [ i ] ) NEW_LINE DEDENT return ( maxEle - minEle ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int minLength ( String str , int N , String K , int M ) { Stack < Character > stackOfChar = new Stack < Character > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { stackOfChar . add ( str . charAt ( i ) ) ; if ( stackOfChar . size ( ) >= M ) { String l = " " ; for ( int j = M - 1 ; j >= 0 ; j -- ) { if ( K . charAt ( j ) != stackOfChar . peek ( ) ) { int f = 0 ; while ( f != l . length ( ) ) { stackOfChar . add ( l . charAt ( f ) ) ; f ++ ; } break ; } else { l = stackOfChar . peek ( ) + l ; stackOfChar . pop ( ) ; } } } } return stackOfChar . size ( ) ; }
Ref: 
def minLength ( Str , N , K , M ) : NEW_LINE INDENT stackOfChar = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT stackOfChar . append ( Str [ i ] ) NEW_LINE if ( len ( stackOfChar ) >= M ) : NEW_LINE INDENT l = " " NEW_LINE for j in range ( M - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( K [ j ] != stackOfChar [ - 1 ] ) : NEW_LINE INDENT f = 0 NEW_LINE while ( f != len ( l ) ) : NEW_LINE INDENT stackOfChar . append ( l [ f ] ) NEW_LINE f += 1 NEW_LINE DEDENT break NEW_LINE DEDENT else : NEW_LINE INDENT l = stackOfChar [ - 1 ] + l NEW_LINE stackOfChar . pop ( ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return len ( stackOfChar ) NEW_LINE DEDENT
Hyp: 
def minLength ( str , N , K , M ) : NEW_LINE INDENT stackOfChar = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT stackOfChar . append ( str [ i ] ) NEW_LINE if ( stackOfChar . size ( ) >= M ) : NEW_LINE INDENT l = " " NEW_LINE for j in range ( M - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( K [ j ] != stackOfChar . peek ( ) ) : NEW_LINE INDENT stackOfChar . append ( l [ f ] ) NEW_LINE f += 1 NEW_LINE DEDENT break NEW_LINE DEDENT else : NEW_LINE INDENT l = stackOfChar . peek ( ) + l NEW_LINE stackOfChar . pop ( ) NEW_LINE DEDENT DEDENT DEDENT return len ( stackOfChar ) NEW_LINE DEDENT

BLEU: 76.71
Edit Sim: 89


Src: 
void middlesum ( int mat [ ] [ ] , int n ) { int row_sum = 0 , col_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) row_sum += mat [ n / 2 ] [ i ] ; System . out . println ( " Sum ▁ of ▁ middle ▁ row ▁ = ▁ " + row_sum ) ; for ( int i = 0 ; i < n ; i ++ ) col_sum += mat [ i ] [ n / 2 ] ; System . out . println ( " Sum ▁ of ▁ middle ▁ column ▁ = ▁ " + col_sum ) ; }
Ref: 
def middlesum ( mat , n ) : NEW_LINE INDENT row_sum = 0 NEW_LINE col_sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT row_sum += mat [ n // 2 ] [ i ] NEW_LINE DEDENT print ( " Sum ▁ of ▁ middle ▁ row ▁ = ▁ " , row_sum ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT col_sum += mat [ i ] [ n // 2 ] NEW_LINE DEDENT print ( " Sum ▁ of ▁ middle ▁ column ▁ = ▁ " , col_sum ) NEW_LINE DEDENT
Hyp: 
def middlesum ( mat , n ) : NEW_LINE INDENT row_sum = 0 NEW_LINE col_sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT row_sum += mat [ n // 2 ] [ i ] NEW_LINE DEDENT print ( " Sum ▁ of ▁ middle ▁ row ▁ = " , row_sum ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT col_sum += mat [ i ] [ n // 2 ] NEW_LINE DEDENT print ( " Sum ▁ of ▁ middle ▁ column ▁ = " , col_sum ) NEW_LINE DEDENT

BLEU: 93.43
Edit Sim: 11


Src: 
int TotalWays ( int n , int s , int k ) { int [ ] dp = new int [ n ] ; dp [ s - 1 ] = 1 ; for ( int i = s ; i < n ; i ++ ) { int idx = Math . max ( s - 1 , i - k ) ; for ( int j = idx ; j < i ; j ++ ) { dp [ i ] += dp [ j ] ; } } return dp [ n - 1 ] ; }
Ref: 
def TotalWays ( n , s , k ) : NEW_LINE INDENT dp = [ 0 ] * n NEW_LINE dp [ s - 1 ] = 1 NEW_LINE for i in range ( s , n ) : NEW_LINE INDENT idx = max ( s - 1 , i - k ) NEW_LINE for j in range ( idx , i ) : NEW_LINE INDENT dp [ i ] += dp [ j ] NEW_LINE DEDENT DEDENT return dp [ n - 1 ] NEW_LINE DEDENT
Hyp: 
def TotalWays ( n , s , k ) : NEW_LINE INDENT dp = [ 0 ] * n NEW_LINE dp [ s - 1 ] = 1 NEW_LINE for i in range ( s , n ) : NEW_LINE INDENT idx = max ( s - 1 , i - k ) NEW_LINE for j in range ( idx , i ) : NEW_LINE INDENT dp [ i ] += dp [ j ] NEW_LINE DEDENT DEDENT return dp [ n - 1 ] NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
void reverse ( String str ) { if ( ( str == null ) || ( str . length ( ) <= 1 ) ) System . out . println ( str ) ; else { System . out . print ( str . charAt ( str . length ( ) - 1 ) ) ; reverse ( str . substring ( 0 , str . length ( ) - 1 ) ) ; } }
Ref: 
def reverse ( string ) : NEW_LINE INDENT if len ( string ) == 0 : NEW_LINE INDENT return NEW_LINE DEDENT temp = string [ 0 ] NEW_LINE reverse ( string [ 1 : ] ) NEW_LINE print ( temp , end = ' ' ) NEW_LINE DEDENT
Hyp: 
def reverse ( str ) : NEW_LINE INDENT if ( str == null ) or ( len ( str ) <= 1 ) : NEW_LINE INDENT print ( str [ : len ( str ) - 1 ] ) NEW_LINE reverse ( str [ : len ( str ) - 1 ] ) NEW_LINE DEDENT DEDENT

BLEU: 19.84
Edit Sim: 103


Src: 
int LucasSum ( int N ) { int sum = 0 ; int a = 2 , b = 1 , c ; sum += a ; while ( b <= N ) { sum += b ; c = a + b ; a = b ; b = c ; } return sum ; }
Ref: 
def LucasSum ( N ) : NEW_LINE INDENT Sum = 0 NEW_LINE a = 2 NEW_LINE b = 1 NEW_LINE c = 0 NEW_LINE Sum += a NEW_LINE while ( b <= N ) : NEW_LINE INDENT Sum += b NEW_LINE c = a + b NEW_LINE a = b NEW_LINE b = c NEW_LINE DEDENT return Sum NEW_LINE DEDENT
Hyp: 
def LucasSum ( N ) : NEW_LINE INDENT sum = 0 NEW_LINE a = 2 NEW_LINE b = 1 NEW_LINE c = a + b NEW_LINE a = b NEW_LINE b = c NEW_LINE DEDENT return sum NEW_LINE DEDENT

BLEU: 50.98
Edit Sim: 88


Src: 
float volumeOfEllipsoid ( float r1 , float r2 , float r3 ) { float pi = ( float ) 3.14 ; return ( float ) 1.33 * pi * r1 * r2 * r3 ; }
Ref: 
def volumeOfEllipsoid ( r1 , r2 , r3 ) : NEW_LINE INDENT return 1.33 * math . pi * r1 * r2 * r3 NEW_LINE DEDENT
Hyp: 
def volumeOfEllipsoid ( r1 , r2 , r3 ) : NEW_LINE INDENT pi = 3.14 NEW_LINE return 1.33 * pi * r1 * r2 * r3 NEW_LINE DEDENT

BLEU: 73.59
Edit Sim: 26


Src: 
int sumOfSeries ( int n ) { return ( n * ( 2 * n - 1 ) * ( 2 * n + 1 ) ) / 3 ; }
Ref: 
def sumOfSeries ( n ) : NEW_LINE INDENT return int ( ( n * ( 2 * n - 1 ) * ( 2 * n + 1 ) ) / 3 ) NEW_LINE DEDENT
Hyp: 
def sumOfSeries ( n ) : NEW_LINE INDENT return ( n * ( 2 * n - 1 ) * ( 2 * n + 1 ) ) / 3 NEW_LINE DEDENT

BLEU: 82.7
Edit Sim: 8


Src: 
int minIncr ( int [ ] arr , int n ) { int forEven = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 1 ) { if ( ( arr [ i ] % 2 ) == 0 ) forEven += 1 ; } else { if ( arr [ i ] % 2 == 1 ) forEven += 1 ; } } return Math . min ( forEven , n - forEven ) ; }
Ref: 
def minIncr ( arr ) : NEW_LINE INDENT forEven = 0 NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT if i % 2 : NEW_LINE INDENT if not arr [ i ] % 2 : NEW_LINE INDENT forEven += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if arr [ i ] % 2 : NEW_LINE INDENT forEven += 1 NEW_LINE DEDENT DEDENT DEDENT return min ( forEven , len ( arr ) - forEven ) NEW_LINE DEDENT
Hyp: 
def minIncr ( arr , n ) : NEW_LINE INDENT forEven = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i % 2 == 1 ) : NEW_LINE INDENT if ( ( arr [ i ] % 2 ) == 0 ) : NEW_LINE INDENT forEven += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( arr [ i ] % 2 == 1 ) : NEW_LINE INDENT forEven += 1 NEW_LINE DEDENT DEDENT return min ( forEven , n - forEven ) ; NEW_LINE DEDENT

BLEU: 63.11
Edit Sim: 63


Src: 
void EvenLIS ( int arr [ ] ) { int n = arr . length ; int lis [ ] = new int [ n ] ; Arrays . fill ( lis , 1 ) ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( Math . abs ( arr [ i ] ) > Math . abs ( arr [ j ] ) && Math . abs ( arr [ i ] ) % 2 == 0 && Math . abs ( arr [ j ] ) % 2 == 0 && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; } } int maxlen = 0 ; for ( int i = 0 ; i < n ; i ++ ) maxlen = Math . max ( maxlen , lis [ i ] ) ; System . out . println ( maxlen ) ; }
Ref: 
def EvenLIS ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE lis = [ 1 ] * n NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( 0 , i ) : NEW_LINE INDENT if abs ( arr [ i ] ) > abs ( arr [ j ] ) and abs ( arr [ i ] % 2 ) == 0 and abs ( arr [ j ] % 2 ) == 0 and lis [ i ] < lis [ j ] + 1 : NEW_LINE INDENT lis [ i ] = lis [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT maxlen = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT maxlen = max ( maxlen , lis [ i ] ) NEW_LINE DEDENT print ( maxlen ) NEW_LINE DEDENT
Hyp: 
def EvenLIS ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE lis = [ 0 ] * n NEW_LINE lis [ 0 ] = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( abs ( arr [ i ] ) > abs ( arr [ j ] ) and abs ( arr [ i ] ) % 2 == 0 and abs ( arr [ j ] ) % 2 == 0 and lis [ i ] < lis [ j ] + 1 ) : NEW_LINE INDENT lis [ i ] = lis [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT maxlen = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT maxlen = max ( maxlen , lis [ i ] ) NEW_LINE DEDENT print ( maxlen ) NEW_LINE DEDENT

BLEU: 84.83
Edit Sim: 38


Src: 
void countCountries ( int ans [ ] , int N ) { int total_countries = 0 , i = 0 ; boolean invalid = false ; while ( i < N ) { int curr_size = ans [ i ] ; int num = ans [ i ] ; while ( num > 0 ) { if ( ans [ i ] != curr_size ) { System . out . print ( "Invalid AnswerNEW_LINE" ); return ; } else num -- ; i ++ ; } total_countries ++ ; } System . out . print ( " There ▁ are ▁ " + total_countries + " distinct companies in the group.NEW_LINE" ); }
Ref: 
def countCountries ( ans , N ) : NEW_LINE INDENT total_countries = 0 NEW_LINE i = 0 NEW_LINE invalid = 0 NEW_LINE while ( i < N ) : NEW_LINE INDENT curr_size = ans [ i ] NEW_LINE num = ans [ i ] NEW_LINE while ( num > 0 ) : NEW_LINE INDENT if ( ans [ i ] != curr_size ) : NEW_LINE INDENT print ( " Invalid ▁ Answer " ) NEW_LINE return ; NEW_LINE DEDENT else : NEW_LINE INDENT num = num - 1 NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT total_countries = total_countries + 1 ; NEW_LINE DEDENT print ( " There ▁ are ▁ " , total_countries , " ▁ distinct ▁ companies ▁ in ▁ the ▁ group . " ) NEW_LINE DEDENT
Hyp: 
def countCountries ( ans , N ) : NEW_LINE INDENT total_countries = 0 NEW_LINE i = 0 NEW_LINE invalid = False NEW_LINE while ( i < N ) : NEW_LINE INDENT curr_size = ans [ i ] NEW_LINE num = ans [ i ] NEW_LINE while ( num > 0 ) : NEW_LINE INDENT if ( ans [ i ] != curr_size ) : NEW_LINE INDENT print ( " Invalid Answer" ) NEW_LINE return NEW_LINE DEDENT else : NEW_LINE INDENT num -= 1 NEW_LINE i += 1 NEW_LINE DEDENT total_countries += 1 NEW_LINE DEDENT print ( " There ▁ are ▁ " , total_countries , " distinct companies in the group. NEW_LINE" ) NEW_LINE DEDENT

BLEU: 69.61
Edit Sim: 69


Src: 
void printRect ( Integer X [ ] , Integer Y [ ] , int n ) { int Xmax = Collections . max ( Arrays . asList ( X ) ) ; int Xmin = Collections . min ( Arrays . asList ( X ) ) ; int Ymax = Collections . max ( Arrays . asList ( Y ) ) ; int Ymin = Collections . min ( Arrays . asList ( Y ) ) ; System . out . println ( " { " + Xmin + " , ▁ " + Ymin + " } " ) ; System . out . println ( " { " + Xmin + " , ▁ " + Ymax + " } " ) ; System . out . println ( " { " + Xmax + " , ▁ " + Ymax + " } " ) ; System . out . println ( " { " + Xmax + " , ▁ " + Ymin + " } " ) ; }
Ref: 
def printRect ( X , Y , n ) : NEW_LINE INDENT Xmax = max ( X ) NEW_LINE Xmin = min ( X ) NEW_LINE Ymax = max ( Y ) NEW_LINE Ymin = min ( Y ) NEW_LINE print ( " { " , Xmin , " , ▁ " , Ymin , " } " , sep = " " ) NEW_LINE print ( " { " , Xmin , " , ▁ " , Ymax , " } " , sep = " " ) NEW_LINE print ( " { " , Xmax , " , ▁ " , Ymax , " } " , sep = " " ) NEW_LINE print ( " { " , Xmax , " , ▁ " , Ymin , " } " , sep = " " ) NEW_LINE DEDENT
Hyp: 
def printRect ( X , Y , n ) : NEW_LINE INDENT Xmax = max ( X ) NEW_LINE Xmin = min ( X ) NEW_LINE Ymax = max ( Y ) NEW_LINE Ymin = min ( Y ) NEW_LINE print ( " { " , Xmin , " , ▁ " , Ymin , " } " ) NEW_LINE print ( " { " , Xmin , " , ▁ " , Ymax , " } " ) NEW_LINE print ( " { " , Xmax , " , ▁ " , Ymax , " } " ) NEW_LINE print ( " { " , Xmax , " , ▁ " , Ymin , " } " ) NEW_LINE DEDENT

BLEU: 82.6
Edit Sim: 48


Src: 
int makeOdd ( int n ) { if ( n % 2 != 0 ) return 1 ; int ans = 1 ; while ( n % 2 == 0 ) { n /= 2 ; ans *= 2 ; } return ans ; }
Ref: 
def makeOdd ( n ) : NEW_LINE INDENT if ( n % 2 != 0 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT resul = 1 ; NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT n = n / 2 ; NEW_LINE resul = resul * 2 ; NEW_LINE DEDENT return resul ; NEW_LINE DEDENT
Hyp: 
def makeOdd ( n ) : NEW_LINE INDENT if ( n % 2 != 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT ans = 1 NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT n //= 2 NEW_LINE ans *= 2 NEW_LINE DEDENT return ans NEW_LINE DEDENT

BLEU: 59.57
Edit Sim: 36


Src: 
float area ( float r ) { if ( r < 0 ) return - 1 ; float area = ( float ) ( 3.14 * Math . pow ( r / ( 2 * Math . sqrt ( 2 ) ) , 2 ) ) ; return area ; }
Ref: 
def area ( r ) : NEW_LINE INDENT if ( r < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT area = 3.14 * pow ( r / ( 2 * sqrt ( 2 ) ) , 2 ) ; NEW_LINE return area ; NEW_LINE DEDENT
Hyp: 
def area ( r ) : NEW_LINE INDENT if r < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT area = ( 3.14 * pow ( r / ( 2 * math . sqrt ( 2 ) ) , 2 ) ) NEW_LINE return area NEW_LINE DEDENT

BLEU: 72.23
Edit Sim: 16


Src: 
int findLCMPrime ( int a , int b ) { if ( a == b ) { return a ; } return a * b ; }
Ref: 
def findLCMPrime ( a , b ) : NEW_LINE INDENT if ( a == b ) : NEW_LINE INDENT return a ; NEW_LINE DEDENT return a * b ; NEW_LINE DEDENT
Hyp: 
def findLCMPrime ( a , b ) : NEW_LINE INDENT if ( a == b ) : NEW_LINE INDENT return a NEW_LINE DEDENT return a * b NEW_LINE DEDENT

BLEU: 83.81
Edit Sim: 4


Src: 
void printMatrix ( int n , int k ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == j ) System . out . print ( k + " ▁ " ) ; else System . out . print ( "0 ▁ " ) ; } System . out . print ( "NEW_LINE"); } }
Ref: 
def printMatrix ( n , k ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT print ( k , end = " ▁ " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( "0" , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT print ( ) ; NEW_LINE DEDENT DEDENT
Hyp: 
def printMatrix ( n , k ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT print ( k , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "0 ▁ " ) NEW_LINE DEDENT DEDENT DEDENT

BLEU: 75.15
Edit Sim: 43


Src: 
int CountPairs ( int [ ] arr , int n ) { int even = 0 , odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) even ++ ; else odd ++ ; } return ( even * ( even - 1 ) ) / 2 + ( even * odd ) ; }
Ref: 
def CountPairs ( arr , n ) : NEW_LINE INDENT even = 0 NEW_LINE odd = 0 NEW_LINE for i in range ( n ) : NEW_LINE if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT even += 1 NEW_LINE DEDENT else : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT return ( ( even * ( even - 1 ) ) // 2 + ( even * odd ) ) NEW_LINE DEDENT
Hyp: 
def CountPairs ( arr , n ) : NEW_LINE INDENT even = 0 ; odd = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT even += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT odd += 1 ; NEW_LINE DEDENT DEDENT return ( even * ( even - 1 ) ) // 2 + ( even * odd ) ; NEW_LINE DEDENT

BLEU: 78.14
Edit Sim: 31


Src: 
int minProd ( int X , int Y , int N ) { if ( X <= Y ) { if ( N < X ) return ( X - N ) * Y ; else { return Math . max ( Y - ( N - X + 1 ) , 1 ) ; } } if ( Y >= N ) return ( Y - N ) * X ; return Math . max ( X - ( N - Y + 1 ) , 1 ) ; }
Ref: 
def minProd ( X , Y , N ) : NEW_LINE INDENT if ( X <= Y ) : NEW_LINE INDENT if ( N < X ) : NEW_LINE INDENT return ( X - N ) * Y NEW_LINE DEDENT else : NEW_LINE INDENT return max ( Y - ( N - X + 1 ) , 1 ) NEW_LINE DEDENT DEDENT if ( Y >= N ) : NEW_LINE INDENT return ( Y - N ) * X NEW_LINE DEDENT return max ( X - ( N - Y + 1 ) , 1 ) NEW_LINE DEDENT
Hyp: 
def minProd ( X , Y , N ) : NEW_LINE INDENT if ( X <= Y ) : NEW_LINE INDENT if ( N < X ) : NEW_LINE INDENT return ( X - N ) * Y NEW_LINE DEDENT else : NEW_LINE INDENT return ( max ( Y - ( N - X + 1 ) , 1 ) ) NEW_LINE DEDENT DEDENT if ( Y >= N ) : NEW_LINE INDENT return ( Y - N ) * X NEW_LINE DEDENT return max ( X - ( N - Y + 1 ) , 1 ) NEW_LINE DEDENT DEDENT

BLEU: 94.73
Edit Sim: 11


Src: 
int countOnes ( int arr [ ] , int low , int high ) { if ( high >= low ) { int mid = low + ( high - low ) / 2 ; if ( ( mid == high arr [ mid + 1 ] == 0 ) && ( arr [ mid ] == 1 ) ) return mid + 1 ; if ( arr [ mid ] == 1 ) return countOnes ( arr , ( mid + 1 ) , high ) ; return countOnes ( arr , low , ( mid - 1 ) ) ; } return 0 ; }
Ref: 
def countOnes ( arr , low , high ) : NEW_LINE INDENT if high >= low : NEW_LINE INDENT mid = low + ( high - low ) // 2 NEW_LINE if ( ( mid == high or arr [ mid + 1 ] == 0 ) and ( arr [ mid ] == 1 ) ) : NEW_LINE INDENT return mid + 1 NEW_LINE DEDENT if arr [ mid ] == 1 : NEW_LINE INDENT return countOnes ( arr , ( mid + 1 ) , high ) NEW_LINE DEDENT return countOnes ( arr , low , mid - 1 ) NEW_LINE DEDENT return 0 NEW_LINE DEDENT
Hyp: 
def countOnes ( arr , low , high ) : NEW_LINE INDENT if high >= low : NEW_LINE INDENT mid = low + ( high - low ) // 2 NEW_LINE if ( ( mid == high or arr [ mid + 1 ] == 0 ) and ( arr [ mid ] == 1 ) ) : NEW_LINE INDENT return mid + 1 NEW_LINE DEDENT if arr [ mid ] == 1 : NEW_LINE INDENT return countOnes ( arr , ( mid + 1 ) , high ) NEW_LINE DEDENT return countOnes ( arr , low , mid - 1 ) NEW_LINE DEDENT return 0 NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
void countCharacterType ( String str ) { int vowels = 0 , consonant = 0 , specialChar = 0 , digit = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char ch = str . charAt ( i ) ; if ( ( ch >= ' a ' && ch <= ' z ' ) || ( ch >= ' A ' && ch <= ' Z ' ) ) { ch = Character . toLowerCase ( ch ) ; ; if ( ch == ' a ' ch == ' e ' ch == ' i ' ch == ' o ' ch == ' u ' ) vowels ++ ; else consonant ++ ; } else if ( ch >= '0' && ch <= '9' ) digit ++ ; else specialChar ++ ; } System . out . println ( " Vowels : ▁ " + vowels ) ; System . out . println ( " Consonant : ▁ " + consonant ) ; System . out . println ( " Digit : ▁ " + digit ) ; System . out . println ( " Special ▁ Character : ▁ " + specialChar ) ; }
Ref: 
def countCharacterType ( str ) : NEW_LINE INDENT vowels = 0 NEW_LINE consonant = 0 NEW_LINE specialChar = 0 NEW_LINE digit = 0 NEW_LINE for i in range ( 0 , len ( str ) ) : NEW_LINE INDENT ch = str [ i ] NEW_LINE if ( ( ch >= ' a ' and ch <= ' z ' ) or ( ch >= ' A ' and ch <= ' Z ' ) ) : NEW_LINE INDENT ch = ch . lower ( ) NEW_LINE if ( ch == ' a ' or ch == ' e ' or ch == ' i ' or ch == ' o ' or ch == ' u ' ) : NEW_LINE INDENT vowels += 1 NEW_LINE DEDENT else : NEW_LINE INDENT consonant += 1 NEW_LINE DEDENT DEDENT elif ( ch >= '0' and ch <= '9' ) : NEW_LINE INDENT digit += 1 NEW_LINE DEDENT else : NEW_LINE INDENT specialChar += 1 NEW_LINE DEDENT DEDENT print ( " Vowels : " , vowels ) NEW_LINE print ( " Consonant : " , consonant ) NEW_LINE print ( " Digit : " , digit ) NEW_LINE print ( " Special ▁ Character : " , specialChar ) NEW_LINE DEDENT
Hyp: 
def countCharacterType ( str ) : NEW_LINE INDENT vowels = 0 NEW_LINE consonant = 0 NEW_LINE specialChar = 0 NEW_LINE digit = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT ch = str [ i ] NEW_LINE if ( ch >= ' a ' and ch <= ' z ' ) or ( ch >= ' A ' and ch <= ' Z ' ) : NEW_LINE INDENT ch = chr ( ch ) NEW_LINE if ( ch == ' a ' or ch == ' e ' or ch == ' i ' or ch == ' o ' or ch == ' u ' ) : NEW_LINE INDENT vowels += 1 NEW_LINE DEDENT else : NEW_LINE INDENT consonant += 1 NEW_LINE DEDENT DEDENT print ( " Vowels : " , vowels ) NEW_LINE print ( " Consonant : " , consonant ) NEW_LINE print ( " Digit : " , digit ) NEW_LINE DEDENT

BLEU: 72.55
Edit Sim: 217


Src: 
double ReuleauxArea ( double r ) { if ( r < 0 ) return - 1 ; double A = 0.70477 * 2 * Math . pow ( r , 2 ) ; return A ; }
Ref: 
def ReuleauxArea ( r ) : NEW_LINE INDENT if ( r < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT A = 0.70477 * 2 * pow ( r , 2 ) NEW_LINE return A NEW_LINE DEDENT
Hyp: 
def ReuleauxArea ( r ) : NEW_LINE INDENT if r < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT A = 0.70477 * 2 * pow ( r , 2 ) NEW_LINE return A NEW_LINE DEDENT

BLEU: 86.55
Edit Sim: 4


Src: 
void lastTwoDigits ( double N ) { if ( N >= 10 ) { System . out . print ( "00" ) ; return ; } double fac = 1 ; for ( int i = 1 ; i <= N ; i ++ ) fac = ( fac * i ) % 100 ; System . out . print ( fac ) ; }
Ref: 
def lastTwoDigits ( N ) : NEW_LINE INDENT if ( N >= 10 ) : NEW_LINE INDENT print ( "00" , end = " " ) NEW_LINE return NEW_LINE DEDENT fac = 1 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT fac = ( fac * i ) % 100 NEW_LINE DEDENT print ( fac ) NEW_LINE DEDENT
Hyp: 
def lastTwoDigits ( N ) : NEW_LINE INDENT if ( N >= 10 ) : NEW_LINE INDENT print ( "00" ) NEW_LINE return NEW_LINE DEDENT fac = 1 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT fac = ( fac * i ) % 100 NEW_LINE DEDENT print ( fac ) NEW_LINE DEDENT

BLEU: 89.63
Edit Sim: 12


Src: 
int cntCells ( int n ) { int cells = ( int ) Math . pow ( n , 2 ) + ( int ) Math . pow ( n - 1 , 2 ) ; return cells ; }
Ref: 
def cntCells ( n ) : NEW_LINE INDENT cells = pow ( n , 2 ) + pow ( n - 1 , 2 ) ; NEW_LINE return cells ; NEW_LINE DEDENT
Hyp: 
def cntCells ( n ) : NEW_LINE INDENT cells = pow ( n , 2 ) + pow ( n - 1 , 2 ) ; NEW_LINE return cells ; NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int surfaceArea ( int b , int s ) { return 2 * b * s + ( int ) Math . pow ( b , 2 ) ; }
Ref: 
def surfaceArea ( b , s ) : NEW_LINE INDENT return 2 * b * s + pow ( b , 2 ) NEW_LINE DEDENT
Hyp: 
def surfaceArea ( b , s ) : NEW_LINE INDENT return 2 * b * s + pow ( b , 2 ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
void findNumberOfDigits ( long n , int base ) { int dig = ( int ) ( Math . floor ( Math . log ( n ) / Math . log ( base ) ) + 1 ) ; System . out . println ( " The ▁ Number ▁ of ▁ digits ▁ of ▁ Number ▁ " + n + " ▁ in ▁ base ▁ " + base + " ▁ is ▁ " + dig ) ; }
Ref: 
def findNumberOfDigits ( n , base ) : NEW_LINE INDENT dig = ( math . floor ( math . log ( n ) / math . log ( base ) ) + 1 ) NEW_LINE print ( " The ▁ Number ▁ of ▁ digits ▁ of " . format ( n , base , dig ) ) DEDENT
Hyp: 
def findNumberOfDigits ( n , base ) : NEW_LINE INDENT dig = int ( math . floor ( math . log ( n ) / math . log ( base ) ) + 1 ) NEW_LINE print ( " The ▁ Number ▁ of ▁ digits ▁ of ▁ Number ▁ " , n , " ▁ in ▁ base ▁ " , base , " ▁ is ▁ " , dig ) NEW_LINE DEDENT

BLEU: 65.06
Edit Sim: 55


Src: 
void findUniqueElements ( int arr [ ] , int N , int K ) { Set < Integer > s = new HashSet < > ( ) ; for ( int i = 0 ; i < N ; i ++ ) s . add ( arr [ i ] ) ; int arr_sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) arr_sum += arr [ i ] ; int set_sum = 0 ; Iterator it = s . iterator ( ) ; while ( it . hasNext ( ) ) { set_sum += ( int ) it . next ( ) ; } System . out . println ( ( K * set_sum - arr_sum ) / ( K - 1 ) ) ; }
Ref: 
def findUniqueElements ( arr , N , K ) : NEW_LINE INDENT s = set ( ) NEW_LINE for x in arr : NEW_LINE INDENT s . add ( x ) NEW_LINE DEDENT arr_sum = sum ( arr ) NEW_LINE set_sum = 0 NEW_LINE for x in s : NEW_LINE INDENT set_sum += x NEW_LINE DEDENT print ( ( K * set_sum - arr_sum ) // ( K - 1 ) ) NEW_LINE DEDENT
Hyp: 
def findUniqueElements ( arr , N , K ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT s . add ( arr [ i ] ) NEW_LINE DEDENT arr_sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT arr_sum += arr [ i ] NEW_LINE DEDENT set_sum = 0 NEW_LINE for it in s : NEW_LINE INDENT set_sum += ( int ) it . next ( ) NEW_LINE DEDENT print ( ( K * set_sum - arr_sum ) / ( K - 1 ) ) NEW_LINE DEDENT

BLEU: 52.78
Edit Sim: 111


Src: 
boolean checkPairs ( int l , int r ) { if ( ( l - r ) % 2 == 0 ) return false ; return true ; }
Ref: 
def checkPairs ( l , r ) : NEW_LINE INDENT if ( l - r ) % 2 == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT
Hyp: 
def checkPairs ( l , r ) : NEW_LINE INDENT if ( ( l - r ) % 2 == 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT return True ; NEW_LINE DEDENT l = 3 ; r = 4 ; NEW_LINE if ( checkPairs ( l , r ) ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT

BLEU: 32.28
Edit Sim: 173


Src: 
boolean possible ( int n ) { if ( n > 3 ) { int sum = ( n * ( n + 1 ) ) / 2 ; if ( sum % 3 == 0 ) { return true ; } } return false ; }
Ref: 
def possible ( n ) : NEW_LINE INDENT if ( n > 3 ) : NEW_LINE INDENT sum = ( n * ( n + 1 ) ) // 2 ; NEW_LINE if ( sum % 3 == 0 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT DEDENT return False ; NEW_LINE DEDENT
Hyp: 
def possible ( n ) : NEW_LINE INDENT if ( n > 3 ) : NEW_LINE INDENT sum = ( n * ( n + 1 ) ) / 2 NEW_LINE if ( sum % 3 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT

BLEU: 82.69
Edit Sim: 7


Src: 
int getMinNum ( int a , int b , int c ) { if ( c < a c > b ) { return c ; } int x = ( ( b / c ) * c ) + c ; return x ; }
Ref: 
def getMinNum ( a , b , c ) : NEW_LINE INDENT if ( c < a or c > b ) : NEW_LINE INDENT return c NEW_LINE DEDENT x = ( ( b // c ) * c ) + c NEW_LINE return x NEW_LINE DEDENT
Hyp: 
def getMinNum ( a , b , c ) : NEW_LINE INDENT if ( c < a or c > b ) : NEW_LINE INDENT return c NEW_LINE DEDENT x = ( ( b // c ) * c ) + c NEW_LINE return x NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int minSum ( int [ ] A , int n ) { int min_val = Arrays . stream ( A ) . min ( ) . getAsInt ( ) ; return ( min_val * ( n - 1 ) ) ; }
Ref: 
def minSum ( A ) : NEW_LINE INDENT min_val = min ( A ) ; NEW_LINE return min_val * ( len ( A ) - 1 ) NEW_LINE DEDENT
Hyp: 
def minSum ( A , n ) : NEW_LINE INDENT min_val = min ( A ) NEW_LINE return ( min_val * ( n - 1 ) ) NEW_LINE DEDENT

BLEU: 56.71
Edit Sim: 16


Src: 
int maxSum ( int arr [ ] , int n ) { if ( n < 2 ) return - 1 ; int ans = arr [ 0 ] + arr [ 1 ] ; for ( int i = 1 ; i + 1 < n ; i ++ ) ans = Math . min ( ans , ( arr [ i ] + arr [ i + 1 ] ) ) ; return ans ; }
Ref: 
def maxSum ( arr , n ) : NEW_LINE INDENT if ( n < 2 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT ans = arr [ 0 ] + arr [ 1 ] NEW_LINE for i in range ( 1 , n - 1 , 1 ) : NEW_LINE INDENT ans = min ( ans , ( arr [ i ] + arr [ i + 1 ] ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
Hyp: 
def maxSum ( arr , n ) : NEW_LINE INDENT if ( n < 2 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT ans = arr [ 0 ] + arr [ 1 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT ans = min ( ans , ( arr [ i ] + arr [ i + 1 ] ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT

BLEU: 92.77
Edit Sim: 8


Src: 
int minOperations ( String s , String t , int n ) { int ct0 = 0 , ct1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == t . charAt ( i ) ) continue ; if ( s . charAt ( i ) == '0' ) ct0 ++ ; else ct1 ++ ; } return Math . max ( ct0 , ct1 ) ; }
Ref: 
def minOperations ( s , t , n ) : NEW_LINE INDENT ct0 = 0 NEW_LINE ct1 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == t [ i ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT ct0 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ct1 += 1 NEW_LINE DEDENT DEDENT return max ( ct0 , ct1 ) NEW_LINE DEDENT
Hyp: 
def minOperations ( s , t , n ) : NEW_LINE INDENT ct0 = 0 ; NEW_LINE ct1 = 0 ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( s [ i ] == t [ i ] ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT ct0 += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT ct1 += 1 ; NEW_LINE DEDENT DEDENT return max ( ct0 , ct1 ) ; NEW_LINE DEDENT

BLEU: 79.51
Edit Sim: 16


Src: 
int calculateSum ( int n ) { if ( n % 2 == 1 ) return ( n + 1 ) / 2 ; return - n / 2 ; }
Ref: 
def solve_sum ( n ) : NEW_LINE INDENT if ( n % 2 == 1 ) : NEW_LINE INDENT return ( n + 1 ) / 2 NEW_LINE DEDENT return - n / 2 NEW_LINE DEDENT
Hyp: 
def calculateSum ( n ) : NEW_LINE INDENT if n % 2 == 1 : NEW_LINE INDENT return ( n + 1 ) // 2 NEW_LINE DEDENT return - n // 2 NEW_LINE DEDENT

BLEU: 64.75
Edit Sim: 15


Src: 
int countPairs ( int arr1 [ ] , int arr2 [ ] , int m , int n , int x ) { int count = 0 ; int l = 0 , r = n - 1 ; while ( l < m && r >= 0 ) { if ( ( arr1 [ l ] + arr2 [ r ] ) == x ) { l ++ ; r -- ; count ++ ; } else if ( ( arr1 [ l ] + arr2 [ r ] ) < x ) l ++ ; else r -- ; } return count ; }
Ref: 
def countPairs ( arr1 , arr2 , m , n , x ) : NEW_LINE INDENT count , l , r = 0 , 0 , n - 1 NEW_LINE while ( l < m and r >= 0 ) : NEW_LINE INDENT if ( ( arr1 [ l ] + arr2 [ r ] ) == x ) : NEW_LINE INDENT l += 1 NEW_LINE r -= 1 NEW_LINE count += 1 NEW_LINE DEDENT elif ( ( arr1 [ l ] + arr2 [ r ] ) < x ) : NEW_LINE INDENT l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
Hyp: 
def countPairs ( arr1 , arr2 , m , n , x ) : NEW_LINE INDENT count = 0 NEW_LINE l = 0 NEW_LINE r = n - 1 NEW_LINE while ( l < m and r >= 0 ) : NEW_LINE INDENT if ( arr1 [ l ] + arr2 [ r ] ) == x : NEW_LINE INDENT l += 1 NEW_LINE r -= 1 NEW_LINE count += 1 NEW_LINE DEDENT elif ( arr1 [ l ] + arr2 [ r ] ) < x ) : NEW_LINE INDENT l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT

BLEU: 86.66
Edit Sim: 27


Src: 
int countFriendsPairings ( int n ) { if ( dp [ n ] != - 1 ) return dp [ n ] ; if ( n > 2 ) return dp [ n ] = countFriendsPairings ( n - 1 ) + ( n - 1 ) * countFriendsPairings ( n - 2 ) ; else return dp [ n ] = n ; }
Ref: 
def countFriendsPairings ( n ) : NEW_LINE INDENT global dp NEW_LINE if ( dp [ n ] != - 1 ) : NEW_LINE INDENT return dp [ n ] NEW_LINE DEDENT if ( n > 2 ) : NEW_LINE INDENT dp [ n ] = ( countFriendsPairings ( n - 1 ) + ( n - 1 ) * countFriendsPairings ( n - 2 ) ) NEW_LINE return dp [ n ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ n ] = n NEW_LINE return dp [ n ] NEW_LINE DEDENT DEDENT
Hyp: 
def countFriendsPairings ( n ) : NEW_LINE INDENT if ( dp [ n ] != - 1 ) : NEW_LINE INDENT return dp [ n ] NEW_LINE DEDENT if ( n > 2 ) : NEW_LINE INDENT dp [ n ] = countFriendsPairings ( n - 1 ) + ( n - 1 ) * countFriendsPairings ( n - 2 ) NEW_LINE return dp [ n ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ n ] = n NEW_LINE DEDENT DEDENT

BLEU: 82.45
Edit Sim: 48


Src: 
int getCount ( int arr [ ] , int n , int num1 , int num2 ) { int i = 0 ; for ( i = 0 ; i < n ; i ++ ) if ( arr [ i ] == num1 ) break ; if ( i >= n - 1 ) return 0 ; int j ; for ( j = n - 1 ; j >= i + 1 ; j -- ) if ( arr [ j ] == num2 ) break ; if ( j == i ) return 0 ; return ( j - i - 1 ) ; }
Ref: 
def getCount ( arr , n , num1 , num2 ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] == num1 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( i >= n - 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT for j in range ( n - 1 , i + 1 , - 1 ) : NEW_LINE INDENT if ( arr [ j ] == num2 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( j == i ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( j - i - 1 ) NEW_LINE DEDENT
Hyp: 
def getCount ( arr , n , num1 , num2 ) : NEW_LINE INDENT i = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] == num1 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if i >= n - 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT j = n - 1 NEW_LINE while ( j >= i + 1 ) : NEW_LINE INDENT if arr [ j ] == num2 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if j == i : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( j - i - 1 ) NEW_LINE DEDENT

BLEU: 66.93
Edit Sim: 62


Src: 
int numberOfMen ( int D , int m , int d ) { int Men = ( m * ( D - d ) ) / d ; return Men ; }
Ref: 
def numberOfMen ( D , m , d ) : NEW_LINE INDENT Men = ( m * ( D - d ) ) / d ; NEW_LINE return int ( Men ) ; NEW_LINE DEDENT
Hyp: 
def numberOfMen ( D , m , d ) : NEW_LINE INDENT Men = ( m * ( D - d ) ) // d NEW_LINE return Men NEW_LINE DEDENT

BLEU: 69.67
Edit Sim: 13


Src: 
int calculateSum ( int n ) { return ( n * ( ( int ) Math . pow ( n , 2 ) + 3 * n + 5 ) ) / 3 ; }
Ref: 
def findSum ( n ) : NEW_LINE INDENT return ( n * ( pow ( n , 2 ) + 3 * n + 5 ) ) / 3 NEW_LINE DEDENT
Hyp: 
def solve_sum ( n ) : NEW_LINE INDENT return ( n * ( pow ( n , 2 ) + 3 * n + 5 ) ) / 3 NEW_LINE DEDENT

BLEU: 94.2
Edit Sim: 7


Src: 
boolean findParity ( int x ) { int y = x ^ ( x >> 1 ) ; y = y ^ ( y >> 2 ) ; y = y ^ ( y >> 4 ) ; y = y ^ ( y >> 8 ) ; y = y ^ ( y >> 16 ) ; if ( ( y & 1 ) > 0 ) return true ; return false ; }
Ref: 
def findParity ( x ) : NEW_LINE INDENT y = x ^ ( x >> 1 ) ; NEW_LINE y = y ^ ( y >> 2 ) ; NEW_LINE y = y ^ ( y >> 4 ) ; NEW_LINE y = y ^ ( y >> 8 ) ; NEW_LINE y = y ^ ( y >> 16 ) ; NEW_LINE if ( y & 1 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT return 0 ; NEW_LINE DEDENT if ( findParity ( 9 ) == 0 ) : NEW_LINE INDENT print ( " Even ▁ Parity " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Odd Parity " ) ; NEW_LINE DEDENT if ( findParity ( 13 ) == 0 ) : NEW_LINE INDENT print ( " Even ▁ Parity " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Odd ▁ Parity " ) ; NEW_LINE DEDENT
Hyp: 
def findParity ( x ) : NEW_LINE INDENT y = x ^ ( x >> 1 ) NEW_LINE y = y ^ ( y >> 2 ) NEW_LINE y = y ^ ( y >> 4 ) NEW_LINE y = y ^ ( y >> 8 ) NEW_LINE y = y ^ ( y >> 16 ) NEW_LINE if ( ( y & 1 ) > 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT x = 12 NEW_LINE if ( findParity ( x ) ) : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT

BLEU: 45.63
Edit Sim: 205


Src: 
String getMinNumberForPattern ( String seq ) { int n = seq . length ( ) ; if ( n >= 9 ) return " - 1" ; char result [ ] = new char [ n + 1 ] ; int count = 1 ; for ( int i = 0 ; i <= n ; i ++ ) { if ( i == n || seq . charAt ( i ) == ' I ' ) { for ( int j = i - 1 ; j >= - 1 ; j -- ) { result [ j + 1 ] = ( char ) ( ( int ) '0' + count ++ ) ; if ( j >= 0 && seq . charAt ( j ) == ' I ' ) break ; } } } return new String ( result ) ; }
Ref: 
def getMinNumberForPattern ( seq ) : NEW_LINE INDENT n = len ( seq ) NEW_LINE if ( n >= 9 ) : NEW_LINE INDENT return " - 1" NEW_LINE DEDENT result = [ None ] * ( n + 1 ) NEW_LINE count = 1 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT if ( i == n or seq [ i ] == ' I ' ) : NEW_LINE INDENT for j in range ( i - 1 , - 2 , - 1 ) : NEW_LINE INDENT result [ j + 1 ] = int ( '0' + str ( count ) ) NEW_LINE count += 1 NEW_LINE if ( j >= 0 and seq [ j ] == ' I ' ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
Hyp: 
def getMinNumberForPattern ( Strr ) : NEW_LINE INDENT n = len ( Strr ) NEW_LINE if ( n >= 9 ) : NEW_LINE INDENT return " - 1" NEW_LINE DEDENT result = [ 0 ] * ( n + 1 ) NEW_LINE count = 1 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT if ( i == n or Strr [ i ] == ' I ' ) : NEW_LINE INDENT j = i - 1 NEW_LINE while ( j >= 0 and Strr [ j ] == ' I ' ) : NEW_LINE INDENT result [ j + 1 ] = chr ( int ( '0' + count ) ) NEW_LINE DEDENT if ( j >= 0 and Strr [ j ] == ' I ' ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT return new string ( result ) NEW_LINE DEDENT

BLEU: 69.29
Edit Sim: 107


Src: 
double CountDigits ( int n ) { if ( n == 1 ) return 1 ; double sum = 0 ; for ( int i = 2 ; i <= n ; ++ i ) { sum += ( ( double ) Math . log ( i ) / ( double ) Math . log ( 10 ) ) ; } sum *= n ; return Math . ceil ( sum ) ; }
Ref: 
def CountDigits ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT sum += ma . log ( i , 10 ) NEW_LINE DEDENT sum *= n NEW_LINE return ma . ceil ( sum ) NEW_LINE DEDENT
Hyp: 
def CountDigits ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT sum += ( math . log ( i ) / math . log ( 10 ) ) NEW_LINE DEDENT sum *= n NEW_LINE return math . ceil ( sum ) NEW_LINE DEDENT

BLEU: 78.42
Edit Sim: 24


Src: 
long getFinalElement ( long n ) { long finalNum ; for ( finalNum = 2 ; finalNum * 2 <= n ; finalNum *= 2 ) ; return finalNum ; }
Ref: 
def getFinalElement ( n ) : NEW_LINE INDENT finalNum = 2 NEW_LINE while finalNum * 2 <= n : NEW_LINE INDENT finalNum *= 2 NEW_LINE DEDENT return finalNum NEW_LINE DEDENT
Hyp: 
def getFinalElement ( n ) : NEW_LINE INDENT finalNum = 2 NEW_LINE while ( finalNum * 2 <= n ) : NEW_LINE INDENT finalNum *= 2 NEW_LINE DEDENT return finalNum NEW_LINE DEDENT

BLEU: 83.5
Edit Sim: 4


Src: 
int pairs ( int n ) { int [ ] [ ] c = new int [ 10 ] [ 10 ] ; int tmp = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i >= tmp * 10 ) tmp *= 10 ; c [ i / tmp ] [ i % 10 ] ++ ; } int ans = 0 ; for ( int i = 1 ; i < 10 ; i ++ ) for ( int j = 1 ; j < 10 ; j ++ ) ans += c [ i ] [ j ] * c [ j ] [ i ] ; return ans ; }
Ref: 
def pairs ( n ) : NEW_LINE INDENT c = [ [ 0 for i in range ( 10 ) ] for i in range ( 10 ) ] NEW_LINE tmp = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( i >= tmp * 10 ) : NEW_LINE INDENT tmp *= 10 NEW_LINE DEDENT c [ i // tmp ] [ i % 10 ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 1 , 10 ) : NEW_LINE INDENT for j in range ( 1 , 10 ) : NEW_LINE INDENT ans += c [ i ] [ j ] * c [ j ] [ i ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
Hyp: 
def pairs ( n ) : NEW_LINE INDENT c = [ [ 0 for i in range ( 10 ) ] for j in range ( 10 ) ] NEW_LINE tmp = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( i >= tmp * 10 ) : NEW_LINE INDENT tmp *= 10 NEW_LINE DEDENT c [ i // tmp ] [ i % 10 ] += 1 NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 1 , 10 ) : NEW_LINE INDENT for j in range ( 1 , 10 ) : NEW_LINE INDENT ans += c [ i ] [ j ] * c [ j ] [ i ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT

BLEU: 96.74
Edit Sim: 8


Src: 
int pell ( int n ) { if ( n <= 2 ) return n ; return 2 * pell ( n - 1 ) + pell ( n - 2 ) ; }
Ref: 
def pell ( n ) : NEW_LINE INDENT if ( n <= 2 ) : NEW_LINE INDENT return n NEW_LINE DEDENT return ( 2 * pell ( n - 1 ) + pell ( n - 2 ) ) NEW_LINE DEDENT
Hyp: 
def pell ( n ) : NEW_LINE INDENT if ( n <= 2 ) : NEW_LINE INDENT return n NEW_LINE DEDENT return 2 * pell ( n - 1 ) + pell ( n - 2 ) NEW_LINE DEDENT

BLEU: 89.17
Edit Sim: 4


Src: 
void getmax ( int arr [ ] , int n , int x ) { int s = 0 ; for ( int i = 0 ; i < n ; i ++ ) { s = s + arr [ i ] ; } System . out . print ( Math . min ( s , x ) ) ; }
Ref: 
def getmax ( arr , n , x ) : NEW_LINE INDENT s = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = s + arr [ i ] NEW_LINE DEDENT print ( min ( s , x ) ) NEW_LINE DEDENT
Hyp: 
def getmax ( arr , n , x ) : NEW_LINE INDENT s = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = s + arr [ i ] NEW_LINE DEDENT print ( min ( s , x ) ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
boolean isPossible ( int a [ ] , int n ) { int cur = a [ 0 ] ; cur -- ; for ( int i = 1 ; i < n ; i ++ ) { int nxt = a [ i ] ; if ( nxt > cur ) nxt -- ; else if ( nxt < cur ) return false ; cur = nxt ; } return true ; }
Ref: 
def isPossible ( a , n ) : NEW_LINE INDENT cur = a [ 0 ] ; NEW_LINE cur -= 1 ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT nxt = a [ i ] ; NEW_LINE if ( nxt > cur ) : NEW_LINE INDENT nxt -= 1 ; NEW_LINE DEDENT elif ( nxt < cur ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT cur = nxt ; NEW_LINE DEDENT return True ; NEW_LINE DEDENT
Hyp: 
def isPossible ( a , n ) : NEW_LINE INDENT cur = a [ 0 ] NEW_LINE cur -= 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT nxt = a [ i ] ; NEW_LINE if ( nxt > cur ) : NEW_LINE INDENT nxt -= 1 NEW_LINE DEDENT elif ( nxt < cur ) : NEW_LINE INDENT return False NEW_LINE DEDENT cur = nxt NEW_LINE DEDENT return True NEW_LINE DEDENT a = [ 1 , 3 , 4 , 5 , 2 ] NEW_LINE n = len ( a ) NEW_LINE if ( isPossible ( a , n ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT

BLEU: 52.0
Edit Sim: 203


Src: 
int countNegative ( int M [ ] [ ] , int n , int m ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( M [ i ] [ j ] < 0 ) count += 1 ; else break ; } } return count ; }
Ref: 
def countNegative ( M , n , m ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if M [ i ] [ j ] < 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
Hyp: 
def countNegative ( M , n , m ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( M [ i ] [ j ] < 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT

BLEU: 92.58
Edit Sim: 4


Src: 
float cyl ( float R ) { if ( R < 0 ) return - 1 ; float V = ( float ) ( ( 2 * 3.14 * Math . pow ( R , 3 ) ) / ( 3 * Math . sqrt ( 3 ) ) ) ; return V ; }
Ref: 
def cyl ( R ) : NEW_LINE INDENT if ( R < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT V = ( ( 2 * 3.14 * math . pow ( R , 3 ) ) / ( 3 * math . sqrt ( 3 ) ) ) ; NEW_LINE return float ( V ) NEW_LINE DEDENT
Hyp: 
def cyl ( R ) : NEW_LINE INDENT if ( R < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT V = ( ( 2 * 3.14 * pow ( R , 3 ) ) / ( 3 * pow ( 3 , 2 ) ) ) NEW_LINE return V NEW_LINE DEDENT

BLEU: 71.62
Edit Sim: 30


Src: 
int largestNum ( int [ ] arr ) { Set < Integer > set = new HashSet < > ( ) ; int res = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { set . add ( arr [ i ] ) ; if ( set . contains ( - 1 * arr [ i ] ) ) { res = Math . max ( res , Math . abs ( arr [ i ] ) ) ; } } return res ; }
Ref: 
def largestNum ( arr , n ) : NEW_LINE INDENT st = set ( [ ] ) NEW_LINE res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT st . add ( arr [ i ] ) NEW_LINE if ( - 1 * arr [ i ] ) in st : NEW_LINE INDENT res = max ( res , abs ( arr [ i ] ) ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
Hyp: 
def largestNum ( arr ) : NEW_LINE INDENT set = set ( ) NEW_LINE res = 0 NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT set . add ( arr [ i ] ) NEW_LINE if ( set [ - 1 * arr [ i ] ] ) : NEW_LINE INDENT res = max ( res , abs ( arr [ i ] ) ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT

BLEU: 73.71
Edit Sim: 32


Src: 
int findSmallest ( int a [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < n ; j ++ ) if ( a [ j ] % a [ i ] >= 1 ) break ; if ( j == n ) return a [ i ] ; } return - 1 ; }
Ref: 
def findSmallest ( a , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT if ( ( a [ j ] % a [ i ] ) >= 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( j == n - 1 ) : NEW_LINE INDENT return a [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
Hyp: 
def findSmallest ( a , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( a [ j ] % a [ i ] >= 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( j == n ) : NEW_LINE INDENT return a [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT

BLEU: 80.9
Edit Sim: 16


Src: 
void maxPairs ( int [ ] nums , int k ) { Map < Integer , Integer > map = new HashMap < > ( ) ; int result = 0 ; for ( int i : nums ) { if ( map . containsKey ( i ) && map . get ( i ) > 0 ) { map . put ( i , map . get ( i ) - 1 ) ; result ++ ; } else { map . put ( k - i , map . getOrDefault ( k - i , 0 ) + 1 ) ; } } System . out . println ( result ) ; }
Ref: 
def maxPairs ( nums , k ) : NEW_LINE INDENT m = { } NEW_LINE result = 0 NEW_LINE for i in nums : NEW_LINE INDENT if ( ( i in m ) and m [ i ] > 0 ) : NEW_LINE INDENT m [ i ] = m [ i ] - 1 NEW_LINE result += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if k - i in m : NEW_LINE INDENT m [ k - i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT m [ k - i ] = 1 NEW_LINE DEDENT DEDENT DEDENT print ( result ) NEW_LINE DEDENT
Hyp: 
def maxPairs ( nums , k ) : NEW_LINE INDENT map = defaultdict ( int ) NEW_LINE result = 0 NEW_LINE for i in nums : NEW_LINE INDENT if ( i in map and map [ i ] > 0 ) : NEW_LINE INDENT map [ i ] = map [ i ] - 1 NEW_LINE result += 1 NEW_LINE DEDENT else : NEW_LINE INDENT map [ k - i ] = 0 + 1 NEW_LINE DEDENT DEDENT print ( result ) NEW_LINE DEDENT

BLEU: 54.95
Edit Sim: 123


Src: 
void countOccurrences ( int n , int x ) { int count = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( x % i == 0 ) { if ( x / i <= n ) count ++ ; } } System . out . print ( count ) ; }
Ref: 
def countOccurrences ( n , x ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( x % i == 0 ) : NEW_LINE INDENT if ( x // i <= n ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT print ( count ) NEW_LINE DEDENT
Hyp: 
def countOccurrences ( n , x ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( x % i == 0 ) : NEW_LINE INDENT if ( x // i <= n ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT print ( count ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
void printDivisors ( int n ) { Vector < Integer > v = new Vector < > ( ) ; for ( int i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) System . out . printf ( " % d ▁ " , i ) ; else { System . out . printf ( " % d ▁ " , i ) ; v . add ( n / i ) ; } } } for ( int i = v . size ( ) - 1 ; i >= 0 ; i -- ) System . out . printf ( " % d ▁ " , v . get ( i ) ) ; }
Ref: 
def printDivisors ( n ) : NEW_LINE INDENT list = [ ] NEW_LINE for i in range ( 1 , int ( math . sqrt ( n ) + 1 ) ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( n / i == i ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE list . append ( int ( n / i ) ) NEW_LINE DEDENT DEDENT DEDENT for i in list [ : : - 1 ] : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT
Hyp: 
def printDivisors ( n ) : NEW_LINE INDENT v = [ ] NEW_LINE for i in range ( 1 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( n // i == i ) : NEW_LINE INDENT print ( " % d ▁ " , i ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " % d ▁ " , i ) NEW_LINE DEDENT v . append ( n // i ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( len ( v ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( " % d ▁ " , v [ i ] ) NEW_LINE DEDENT DEDENT

BLEU: 58.81
Edit Sim: 77


Src: 
int nthTerm ( int n ) { return 5 * ( int ) Math . pow ( n , 2 ) - 5 * n ; }
Ref: 
def nthTerm ( n ) : NEW_LINE INDENT return 5 * pow ( n , 2 ) - 5 * n NEW_LINE DEDENT
Hyp: 
def nthTerm ( n ) : NEW_LINE INDENT return 5 * pow ( n , 2 ) - 5 * n ; NEW_LINE DEDENT

BLEU: 90.16
Edit Sim: 2


Src: 
int maximumSegments ( int n , int a , int b , int c ) { int dp [ ] = new int [ n + 10 ] ; Arrays . fill ( dp , - 1 ) ; dp [ 0 ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( dp [ i ] != - 1 ) { dp [ i + a ] = Math . max ( dp [ i ] + 1 , dp [ i + a ] ) ; dp [ i + b ] = Math . max ( dp [ i ] + 1 , dp [ i + b ] ) ; dp [ i + c ] = Math . max ( dp [ i ] + 1 , dp [ i + c ] ) ; } } return dp [ n ] ; }
Ref: 
def maximumSegments ( n , a , b , c ) : NEW_LINE INDENT dp = [ - 1 ] * ( n + 10 ) NEW_LINE dp [ 0 ] = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( dp [ i ] != - 1 ) : NEW_LINE INDENT dp [ i + a ] = max ( dp [ i ] + 1 , dp [ i + a ] ) NEW_LINE dp [ i + b ] = max ( dp [ i ] + 1 , dp [ i + b ] ) NEW_LINE dp [ i + c ] = max ( dp [ i ] + 1 , dp [ i + c ] ) NEW_LINE DEDENT DEDENT return dp [ n ] NEW_LINE DEDENT
Hyp: 
def maximumSegments ( n , a , b , c ) : NEW_LINE INDENT dp = [ 0 for i in range ( n + 10 ) ] NEW_LINE dp [ 0 ] = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( dp [ i ] != - 1 ) : NEW_LINE INDENT dp [ i + a ] = max ( dp [ i ] + 1 , dp [ i + a ] ) NEW_LINE dp [ i + b ] = max ( dp [ i ] + 1 , dp [ i + b ] ) NEW_LINE dp [ i + c ] = max ( dp [ i ] + 1 , dp [ i + c ] ) NEW_LINE DEDENT DEDENT return dp [ n ] NEW_LINE DEDENT

BLEU: 92.76
Edit Sim: 19


Src: 
void maxSumAfterKReverse ( Integer arr [ ] , int K , int N ) { int sum = Integer . MIN_VALUE ; if ( K % 2 != 0 ) Collections . reverse ( Arrays . asList ( arr ) ) ; int currsum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { currsum += arr [ i ] ; sum = Math . max ( sum , currsum ) ; } System . out . print ( sum ) ; }
Ref: 
def maxSumAfterKReverse ( arr , K , N ) : NEW_LINE INDENT sum = - sys . maxsize - 1 NEW_LINE if ( K & 1 ) : NEW_LINE INDENT arr . reverse ( ) NEW_LINE DEDENT currsum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT currsum += arr [ i ] NEW_LINE sum = max ( sum , currsum ) NEW_LINE DEDENT print ( sum ) NEW_LINE DEDENT
Hyp: 
def maxSumAfterKReverse ( arr , K , N ) : NEW_LINE INDENT sum = sys . maxsize NEW_LINE if ( K % 2 != 0 ) : NEW_LINE INDENT arr . reverse ( ) NEW_LINE DEDENT currsum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT currsum += arr [ i ] NEW_LINE sum = max ( sum , currsum ) NEW_LINE DEDENT print ( sum ) NEW_LINE DEDENT

BLEU: 86.87
Edit Sim: 13


Src: 
int TetracontadigonalNum ( int n ) { return ( 40 * n * n - 38 * n ) / 2 ; }
Ref: 
def TetracontadigonalNum ( n ) : NEW_LINE INDENT return int ( ( 40 * n * n - 38 * n ) / 2 ) NEW_LINE DEDENT
Hyp: 
def TetracontadigonalNum ( n ) : NEW_LINE INDENT return ( 40 * n * n - 38 * n ) // 2 NEW_LINE DEDENT

BLEU: 70.32
Edit Sim: 9


Src: 
int findSum ( int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += i * ( n - i ) ; return 2 * sum ; }
Ref: 
def findSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += i * ( n - i ) NEW_LINE DEDENT return 2 * sum NEW_LINE DEDENT
Hyp: 
def findSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += i * ( n - i ) NEW_LINE DEDENT return 2 * sum NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int findMaximumPieces ( int n ) { int x = n / 2 ; return ( ( x + 1 ) * ( n - x + 1 ) ) ; }
Ref: 
def findMaximumPieces ( n ) : NEW_LINE INDENT x = n // 2 NEW_LINE return ( ( x + 1 ) * ( n - x + 1 ) ) NEW_LINE DEDENT
Hyp: 
def findMaximumPieces ( n ) : NEW_LINE INDENT x = n // 2 NEW_LINE return ( ( x + 1 ) * ( n - x + 1 ) ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int maxSum ( int N ) { int ans = 0 ; for ( int u = 1 ; u <= N ; u ++ ) { for ( int v = 1 ; v <= N ; v ++ ) { if ( u == v ) continue ; int degreeU = 2 ; if ( u == 1 u == N ) degreeU = 1 ; int degreeV = 2 ; if ( v == 1 v == N ) degreeV = 1 ; ans += ( degreeU * degreeV ) ; } } return ans ; }
Ref: 
def maxSum ( N ) : NEW_LINE INDENT ans = 0 ; NEW_LINE for u in range ( 1 , N + 1 ) : NEW_LINE INDENT for v in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( u == v ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT degreeU = 2 ; NEW_LINE if ( u == 1 or u == N ) : NEW_LINE INDENT degreeU = 1 ; NEW_LINE DEDENT degreeV = 2 ; NEW_LINE if ( v == 1 or v == N ) : NEW_LINE INDENT degreeV = 1 ; NEW_LINE DEDENT ans += ( degreeU * degreeV ) ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT
Hyp: 
def maxSum ( N ) : NEW_LINE INDENT ans = 0 NEW_LINE for u in range ( 1 , N + 1 ) : NEW_LINE INDENT for v in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( u == v ) : NEW_LINE INDENT continue NEW_LINE DEDENT degreeU = 2 NEW_LINE if ( u == 1 or u == N ) : NEW_LINE INDENT degreeU = 1 NEW_LINE DEDENT degreeV = 2 NEW_LINE if ( v == 1 or v == N ) : NEW_LINE INDENT degreeV = 1 NEW_LINE DEDENT ans += ( degreeU * degreeV ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT

BLEU: 82.6
Edit Sim: 16


Src: 
int maxResult ( int n , int a , int b , int c ) { int maxVal = 0 ; for ( int i = 0 ; i <= n ; i += a ) for ( int j = 0 ; j <= n - i ; j += b ) { float z = ( float ) ( n - ( i + j ) ) / ( float ) c ; if ( Math . floor ( z ) == Math . ceil ( z ) ) { int x = i / a ; int y = j / b ; maxVal = Math . max ( maxVal , x + y + ( int ) z ) ; } } return maxVal ; }
Ref: 
def maxResult ( n , a , b , c ) : NEW_LINE INDENT maxVal = 0 NEW_LINE for i in range ( 0 , n + 1 , a ) : NEW_LINE INDENT for j in range ( 0 , n - i + 1 , b ) : NEW_LINE INDENT z = ( n - ( i + j ) ) / c NEW_LINE if ( floor ( z ) == ceil ( z ) ) : NEW_LINE INDENT x = i // a NEW_LINE y = j // b NEW_LINE maxVal = max ( maxVal , x + y + int ( z ) ) NEW_LINE DEDENT DEDENT DEDENT return maxVal NEW_LINE DEDENT
Hyp: 
def maxResult ( n , a , b , c ) : NEW_LINE INDENT maxVal = 0 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( n - i + 1 , n - 1 ) : NEW_LINE INDENT z = ( n - ( i + j ) ) / c NEW_LINE if ( math . floor ( z ) == math . ceil ( z ) ) : NEW_LINE INDENT x = i // a NEW_LINE y = j // b NEW_LINE maxVal = max ( maxVal , x + y + ( int ) z ) NEW_LINE DEDENT DEDENT DEDENT return maxVal NEW_LINE DEDENT

BLEU: 82.41
Edit Sim: 36


Src: 
boolean check ( int arr [ ] , int x , int n ) { long sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { double y = Math . sqrt ( arr [ i ] ) ; if ( Math . floor ( y ) == Math . ceil ( y ) ) { sum += arr [ i ] ; } } if ( sum % x == 0 ) return true ; else return false ; }
Ref: 
def check ( a , y ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT x = math . sqrt ( a [ i ] ) NEW_LINE if ( math . floor ( x ) == math . ceil ( x ) ) : NEW_LINE INDENT sum = sum + a [ i ] NEW_LINE DEDENT DEDENT if ( sum % y == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT a = [ 2 , 3 , 4 , 9 , 10 ] NEW_LINE x = 13 NEW_LINE if check ( a , x ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
Hyp: 
def check ( arr , x , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT y = math . sqrt ( arr [ i ] ) NEW_LINE if ( math . floor ( y ) == math . ceil ( y ) ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT DEDENT if ( sum % x == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT

BLEU: 41.44
Edit Sim: 208


Src: 
int minCost ( int cost [ ] [ ] ) { int dist [ ] = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) dist [ i ] = INF ; dist [ 0 ] = 0 ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = i + 1 ; j < N ; j ++ ) if ( dist [ j ] > dist [ i ] + cost [ i ] [ j ] ) dist [ j ] = dist [ i ] + cost [ i ] [ j ] ; return dist [ N - 1 ] ; }
Ref: 
def minCost ( cost ) : NEW_LINE INDENT dist = [ 0 for i in range ( N ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT dist [ i ] = INF NEW_LINE DEDENT dist [ 0 ] = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT if ( dist [ j ] > dist [ i ] + cost [ i ] [ j ] ) : NEW_LINE INDENT dist [ j ] = dist [ i ] + cost [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return dist [ N - 1 ] NEW_LINE DEDENT
Hyp: 
def minCost ( cost ) : NEW_LINE INDENT dist = [ INF ] * N NEW_LINE for i in range ( N ) : NEW_LINE INDENT dist [ i ] = INF NEW_LINE DEDENT dist [ 0 ] = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT if ( dist [ j ] > dist [ i ] + cost [ i ] [ j ] ) : NEW_LINE INDENT dist [ j ] = dist [ i ] + cost [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return dist [ N - 1 ] NEW_LINE DEDENT

BLEU: 91.75
Edit Sim: 20


Src: 
int Square ( int row , int column , int moves ) { int a = 0 , b = 0 , c = 0 , d = 0 , total = 0 ; a = row - moves ; b = row + moves ; c = column - moves ; d = column + moves ; if ( a < 1 ) a = 1 ; if ( c < 1 ) c = 1 ; if ( b > 8 ) b = 8 ; if ( d > 8 ) d = 8 ; total = ( b - a + 1 ) * ( d - c + 1 ) - 1 ; return total ; }
Ref: 
def Square ( row , column , moves ) : NEW_LINE INDENT a = 0 ; b = 0 ; c = 0 ; NEW_LINE d = 0 ; total = 0 ; NEW_LINE a = row - moves ; NEW_LINE b = row + moves ; NEW_LINE c = column - moves ; NEW_LINE d = column + moves ; NEW_LINE if ( a < 1 ) : NEW_LINE INDENT a = 1 ; NEW_LINE DEDENT if ( c < 1 ) : NEW_LINE INDENT c = 1 ; NEW_LINE DEDENT if ( b > 8 ) : NEW_LINE INDENT b = 8 ; NEW_LINE DEDENT if ( d > 8 ) : NEW_LINE INDENT d = 8 ; NEW_LINE DEDENT total = ( b - a + 1 ) * ( d - c + 1 ) - 1 ; NEW_LINE return total ; NEW_LINE DEDENT
Hyp: 
def Square ( row , column , moves ) : NEW_LINE INDENT a = 0 NEW_LINE b = 0 NEW_LINE c = 0 NEW_LINE d = 0 NEW_LINE total = 0 NEW_LINE a = row - moves NEW_LINE b = row + moves NEW_LINE c = column - moves NEW_LINE d = column + moves NEW_LINE if ( a < 1 ) : NEW_LINE INDENT a = 1 NEW_LINE DEDENT if ( c < 1 ) : NEW_LINE INDENT c = 1 NEW_LINE DEDENT if ( b > 8 ) : NEW_LINE INDENT b = 8 NEW_LINE DEDENT if ( d > 8 ) : NEW_LINE INDENT d = 8 NEW_LINE DEDENT total = ( b - a + 1 ) * ( d - c + 1 ) - 1 ) NEW_LINE return total NEW_LINE DEDENT

BLEU: 73.58
Edit Sim: 47


Src: 
int minPoints ( int n , int m ) { int ans = 0 ; if ( ( n % 2 != 0 ) && ( m % 2 != 0 ) ) { ans = ( ( n * m ) / 2 ) + 1 ; } else { ans = ( n * m ) / 2 ; } return ans ; }
Ref: 
def minPoints ( n , m ) : NEW_LINE INDENT ans = 0 NEW_LINE if ( ( n % 2 != 0 ) and ( m % 2 != 0 ) ) : NEW_LINE INDENT ans = ( ( n * m ) // 2 ) + 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = ( n * m ) // 2 NEW_LINE DEDENT return ans NEW_LINE DEDENT
Hyp: 
def minPoints ( n , m ) : NEW_LINE INDENT ans = 0 ; NEW_LINE if ( n % 2 != 0 ) and ( m % 2 != 0 ) ) : NEW_LINE INDENT ans = ( ( n * m ) // 2 ) + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT ans = ( n * m ) // 2 ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT

BLEU: 84.9
Edit Sim: 10


Src: 
void findLastElement ( int arr [ ] , int N ) { Arrays . sort ( arr ) ; int i = 0 ; for ( i = 1 ; i < N ; i ++ ) { if ( arr [ i ] - arr [ i - 1 ] != 0 && arr [ i ] - arr [ i - 1 ] != 2 ) { System . out . println ( " - 1" ) ; return ; } } System . out . println ( arr [ N - 1 ] ) ; }
Ref: 
def findLastElement ( arr , N ) : NEW_LINE INDENT arr . sort ( ) ; NEW_LINE i = 0 ; NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT if ( arr [ i ] - arr [ i - 1 ] != 0 \ and arr [ i ] - arr [ i - 1 ] != 2 ) : NEW_LINE INDENT print ( " - 1" ) ; NEW_LINE return ; NEW_LINE DEDENT DEDENT print ( arr [ N - 1 ] ) ; NEW_LINE DEDENT
Hyp: 
def findLastElement ( arr , N ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE i = 0 NEW_LINE while i < N : NEW_LINE INDENT if ( arr [ i ] - arr [ i - 1 ] != 0 and arr [ i ] - arr [ i - 1 ] != 2 ) : NEW_LINE INDENT print ( " - 1" ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( arr [ N - 1 ] ) NEW_LINE return NEW_LINE DEDENT

BLEU: 73.45
Edit Sim: 43


Src: 
boolean check ( char s [ ] ) { int l = s . length ; Arrays . sort ( s ) ; for ( int i = 1 ; i < l ; i ++ ) { if ( s [ i ] - s [ i - 1 ] != 1 ) return false ; } return true ; }
Ref: 
def check ( s ) : NEW_LINE INDENT l = len ( s ) NEW_LINE s = ' ' . join ( sorted ( s ) ) NEW_LINE for i in range ( 1 , l ) : NEW_LINE INDENT if ord ( s [ i ] ) - ord ( s [ i - 1 ] ) != 1 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
Hyp: 
def check ( s ) : NEW_LINE INDENT l = len ( s ) NEW_LINE s . sort ( ) NEW_LINE for i in range ( 1 , l ) : NEW_LINE INDENT if ( ord ( s [ i ] ) - ord ( s [ i - 1 ] ) != 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT

BLEU: 80.55
Edit Sim: 23


Src: 
int findNumber ( int N ) { int count = 0 ; while ( ( N & 1 ) == 1 ) { N = N >> 1 ; count ++ ; } return N << count ; }
Ref: 
def findNumber ( N ) : NEW_LINE INDENT count = 0 NEW_LINE while ( ( N & 1 ) == 1 ) : NEW_LINE INDENT N = N >> 1 NEW_LINE count += 1 NEW_LINE DEDENT return N << count NEW_LINE DEDENT
Hyp: 
def findNumber ( N ) : NEW_LINE INDENT count = 0 NEW_LINE while ( N & 1 ) : NEW_LINE INDENT N = N >> 1 NEW_LINE count += 1 NEW_LINE DEDENT return N << count NEW_LINE DEDENT

BLEU: 87.47
Edit Sim: 9


Src: 
void canSplit ( String S ) { int frequency [ ] = new int [ 26 ] ; int cnt_singles = 0 ; int k = 0 ; for ( int i = 0 ; i < S . length ( ) ; i ++ ) frequency [ S . charAt ( i ) - ' a ' ] ++ ; int odd = 0 , eve = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( frequency [ i ] != 0 ) { odd += ( frequency [ i ] & 1 ) ; eve += frequency [ i ] / 2 ; } } if ( eve >= odd ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; }
Ref: 
def canSplit ( S ) : NEW_LINE INDENT frequency = [ 0 ] * 26 NEW_LINE cnt_singles = 0 NEW_LINE k = 0 NEW_LINE for i in range ( len ( S ) ) : NEW_LINE INDENT frequency [ ord ( S [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT odd = 0 NEW_LINE eve = 0 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if ( frequency [ i ] ) : NEW_LINE INDENT odd += ( frequency [ i ] & 1 ) NEW_LINE eve += frequency [ i ] // 2 NEW_LINE DEDENT DEDENT if ( eve >= odd ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
Hyp: 
def canSplit ( S ) : NEW_LINE INDENT frequency = [ 0 ] * 26 NEW_LINE cnt_singles = 0 NEW_LINE k = 0 NEW_LINE for i in range ( len ( S ) ) : NEW_LINE INDENT frequency [ ord ( S [ i ] ) - ord ( ' a ' ) ] = ( frequency [ ord ( S [ i ] ) - ord ( ' a ' ) ] ) + 1 NEW_LINE DEDENT odd = 0 NEW_LINE eve = 0 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if ( frequency [ i ] != 0 ) : NEW_LINE INDENT odd += ( frequency [ i ] & 1 ) NEW_LINE eve += frequency [ i ] // 2 NEW_LINE DEDENT DEDENT if ( eve >= odd ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT

BLEU: 84.15
Edit Sim: 58


Src: 
void printSeriesSum ( int N ) { double sum = 0 ; int a = 1 ; int cnt = 0 ; boolean flag = true ; sum += a ; while ( cnt < N ) { int nextElement ; if ( flag == true ) { nextElement = a * 2 ; sum += nextElement ; flag = ! flag ; } else { nextElement = a * 3 / 2 ; sum += nextElement ; flag = ! flag ; } a = nextElement ; cnt ++ ; } System . out . println ( sum ) ; }
Ref: 
def printSeriesSum ( N ) : NEW_LINE INDENT sum = 0 ; NEW_LINE a = 1 ; NEW_LINE cnt = 0 ; NEW_LINE flag = True ; NEW_LINE sum += a ; NEW_LINE while ( cnt < N ) : NEW_LINE INDENT nextElement = None ; NEW_LINE if ( flag ) : NEW_LINE INDENT nextElement = a * 2 ; NEW_LINE sum += nextElement ; NEW_LINE flag = not flag ; NEW_LINE DEDENT else : NEW_LINE INDENT nextElement = a * ( 3 / 2 ) ; NEW_LINE sum += nextElement ; NEW_LINE flag = not flag ; NEW_LINE DEDENT a = nextElement ; NEW_LINE cnt += 1 NEW_LINE DEDENT print ( sum ) ; NEW_LINE DEDENT
Hyp: 
def printSeriesSum ( N ) : NEW_LINE INDENT sum = 0 NEW_LINE a = 1 NEW_LINE cnt = 0 NEW_LINE flag = True NEW_LINE sum += a NEW_LINE while ( cnt < N ) : NEW_LINE INDENT nextElement = a * 2 NEW_LINE sum += nextElement NEW_LINE flag = not flag NEW_LINE DEDENT else : NEW_LINE INDENT nextElement = a * 3 // 2 NEW_LINE sum += nextElement NEW_LINE flag = not flag NEW_LINE DEDENT a = nextElement NEW_LINE cnt += 1 NEW_LINE DEDENT print ( sum ) NEW_LINE DEDENT

BLEU: 54.49
Edit Sim: 91


Src: 
void Kmultiples ( int n , int k ) { int a = n ; for ( int i = 1 ; i <= k ; i ++ ) { System . out . print ( n + " ▁ * ▁ " + i + " ▁ = ▁ " + a + "NEW_LINE"); int j = 0 ; while ( n >= ( 1 << j ) ) { a += n & ( 1 << j ) ; j ++ ; } } }
Ref: 
def Kmultiples ( n , k ) : NEW_LINE INDENT a = n NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT print ( " { } ▁ * ▁ { } ▁ = ▁ { } " . format ( n , i , a ) ) NEW_LINE j = 0 NEW_LINE while ( n >= ( 1 << j ) ) : NEW_LINE INDENT a += n & ( 1 << j ) NEW_LINE j += 1 NEW_LINE DEDENT DEDENT DEDENT
Hyp: 
def Kmultiples ( n , k ) : NEW_LINE INDENT a = n NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT print ( n , " ▁ * ▁ " , i , " = ▁ " , a , " " ) NEW_LINE j = 0 NEW_LINE while ( n >= ( 1 << j ) ) : NEW_LINE INDENT a += n & ( 1 << j ) NEW_LINE j += 1 NEW_LINE DEDENT DEDENT DEDENT

BLEU: 78.38
Edit Sim: 26


Src: 
int countDigitOne ( int n ) { int countr = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { String str = String . valueOf ( i ) ; countr += str . split ( "1" , - 1 ) . length - 1 ; } return countr ; }
Ref: 
def countDigitOne ( n ) : NEW_LINE INDENT countr = 0 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT str1 = str ( i ) ; NEW_LINE countr += str1 . count ( "1" ) ; NEW_LINE DEDENT return countr ; NEW_LINE DEDENT
Hyp: 
def countDigitOne ( n ) : NEW_LINE INDENT countr = 0 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT str = str ( i ) ; NEW_LINE countr += int ( str . split ( "1" , - 1 ) [ 0 ] ) ; NEW_LINE DEDENT return countr ; NEW_LINE DEDENT

BLEU: 71.05
Edit Sim: 26


Src: 
boolean isFancy ( String num ) { Map < Character , Character > fp = new HashMap < Character , Character > ( ) ; fp . put ( '0' , '0' ) ; fp . put ( '1' , '1' ) ; fp . put ( '6' , '9' ) ; fp . put ( '8' , '8' ) ; fp . put ( '9' , '6' ) ; int n = num . length ( ) ; int l = 0 , r = n - 1 ; while ( l <= r ) { if ( ! fp . containsKey ( num . charAt ( l ) ) || fp . get ( num . charAt ( l ) ) != num . charAt ( r ) ) return false ; l ++ ; r -- ; } return true ; }
Ref: 
def isFancy ( num ) : NEW_LINE INDENT fp = { } NEW_LINE fp [ '0' ] = '0' NEW_LINE fp [ '1' ] = '1' NEW_LINE fp [ '6' ] = '9' NEW_LINE fp [ '8' ] = '8' NEW_LINE fp [ '9' ] = '6' NEW_LINE n = len ( num ) NEW_LINE l = 0 NEW_LINE r = n - 1 NEW_LINE while ( l <= r ) : NEW_LINE INDENT if ( num [ l ] not in fp or fp [ num [ l ] ] != num [ r ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT l += 1 NEW_LINE r -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT
Hyp: 
def isFancy ( num ) : NEW_LINE INDENT fp = dict ( ) NEW_LINE fp [ '0' ] = '0' NEW_LINE fp [ '1' ] = '1' NEW_LINE fp [ '6' ] = '9' NEW_LINE fp [ '8' ] = '8' NEW_LINE fp [ '9' ] = '6' NEW_LINE n = len ( num ) NEW_LINE l = 0 NEW_LINE r = n - 1 NEW_LINE while ( l <= r ) : NEW_LINE INDENT if ( num [ l ] not in fp . keys ( ) or fp [ num [ l ] ] != num [ r ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT l = l + 1 NEW_LINE r = r - 1 NEW_LINE DEDENT return True NEW_LINE DEDENT num = " aba " NEW_LINE if ( isFancy ( num ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT

BLEU: 65.85
Edit Sim: 182


Src: 
int numberOfWays ( int x ) { if ( x == 0 x == 1 ) return 1 ; else return numberOfWays ( x - 1 ) + ( x - 1 ) * numberOfWays ( x - 2 ) ; }
Ref: 
def numberOfWays ( x ) : NEW_LINE INDENT if x == 0 or x == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return ( numberOfWays ( x - 1 ) + ( x - 1 ) * numberOfWays ( x - 2 ) ) NEW_LINE DEDENT DEDENT
Hyp: 
def numberOfWays ( x ) : NEW_LINE INDENT if ( x == 0 or x == 1 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT return numberOfWays ( x - 1 ) + ( x - 1 ) * numberOfWays ( x - 2 ) ; NEW_LINE DEDENT DEDENT

BLEU: 78.25
Edit Sim: 9


Src: 
double lengthOfLatusRectum ( double A , double B ) { double major = 2.0 * A ; double minor = 2.0 * B ; double latus_rectum = ( minor * minor ) / major ; return latus_rectum ; }
Ref: 
def lengthOfLatusRectum ( A , B ) : NEW_LINE INDENT major = 2.0 * A NEW_LINE minor = 2.0 * B NEW_LINE latus_rectum = ( minor * minor ) / major NEW_LINE return latus_rectum NEW_LINE DEDENT
Hyp: 
def lengthOfLatusRectum ( A , B ) : NEW_LINE INDENT major = 2.0 * A NEW_LINE minor = 2.0 * B NEW_LINE latus_rectum = ( minor * minor ) / major NEW_LINE return latus_rectum NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
boolean isMagic ( int n ) { int sum = 0 ; while ( n > 0 sum > 9 ) { if ( n == 0 ) { n = sum ; sum = 0 ; } sum += n % 10 ; n /= 10 ; } return ( sum == 1 ) ; }
Ref: 
def isMagic ( n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE while ( n > 0 or sum > 9 ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT n = sum ; NEW_LINE sum = 0 ; NEW_LINE DEDENT sum = sum + n % 10 ; NEW_LINE n = int ( n / 10 ) ; NEW_LINE DEDENT return True if ( sum == 1 ) else False ; NEW_LINE DEDENT n = 1234 ; NEW_LINE if ( isMagic ( n ) ) : NEW_LINE INDENT print ( " Magic ▁ Number " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ a ▁ magic ▁ Number " ) ; NEW_LINE DEDENT
Hyp: 
def isMagic ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( n > 0 or sum > 9 ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT n = sum NEW_LINE sum = 0 NEW_LINE DEDENT sum += n % 10 NEW_LINE n /= 10 NEW_LINE DEDENT return ( sum == 1 ) NEW_LINE DEDENT n = 121 NEW_LINE if ( isMagic ( n ) ) : NEW_LINE INDENT print ( n , end = ' ▁ ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n , end = ' ▁ ' ) NEW_LINE print ( " is ▁ not ▁ magic " ) NEW_LINE DEDENT

BLEU: 56.73
Edit Sim: 115


Src: 
int gcd ( int a , int b ) { if ( a == b ) return a ; if ( a == 0 ) return b ; if ( b == 0 ) return a ; { return gcd ( a >> 1 , b ) ; return gcd ( a >> 1 , b >> 1 ) << 1 ; } if ( ( ~ b & 1 ) == 1 ) return gcd ( a , b >> 1 ) ; if ( a > b ) return gcd ( ( a - b ) >> 1 , b ) ; return gcd ( ( b - a ) >> 1 , a ) ; }
Ref: 
def gcd ( a , b ) : NEW_LINE INDENT if ( a == b ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( ( ~ a & 1 ) == 1 ) : NEW_LINE INDENT if ( ( b & 1 ) == 1 ) : NEW_LINE INDENT return gcd ( a >> 1 , b ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( gcd ( a >> 1 , b >> 1 ) << 1 ) NEW_LINE DEDENT DEDENT if ( ( ~ b & 1 ) == 1 ) : NEW_LINE INDENT return gcd ( a , b >> 1 ) NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT return gcd ( ( a - b ) >> 1 , b ) NEW_LINE DEDENT return gcd ( ( b - a ) >> 1 , a ) NEW_LINE DEDENT
Hyp: 
def gcd ( a , b ) : NEW_LINE INDENT if ( a == b ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return a NEW_LINE DEDENT DEDENT if ( ~ b & 1 ) == 1 : NEW_LINE INDENT return a NEW_LINE DEDENT return gcd ( a , b >> 1 ) NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT return gcd ( ( a - b ) >> 1 , b ) NEW_LINE DEDENT return gcd ( ( b - a ) >> 1 , a ) NEW_LINE DEDENT

BLEU: 62.74
Edit Sim: 156


Src: 
int powerOptimised ( int a , int n ) { int ans = 1 ; while ( n > 0 ) { int last_bit = ( n & 1 ) ; if ( last_bit > 0 ) { ans = ans * a ; } a = a * a ; n = n >> 1 ; } return ans ; }
Ref: 
def powerOptimised ( a , n ) : NEW_LINE INDENT ans = 1 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT last_bit = ( n & 1 ) NEW_LINE if ( last_bit ) : NEW_LINE INDENT ans = ans * a NEW_LINE DEDENT a = a * a NEW_LINE n = n >> 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
Hyp: 
def powerOptimised ( a , n ) : NEW_LINE INDENT ans = 1 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT last_bit = ( n & 1 ) NEW_LINE if ( last_bit > 0 ) : NEW_LINE INDENT ans = ans * a NEW_LINE DEDENT a = a * a NEW_LINE n = n >> 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT

BLEU: 94.44
Edit Sim: 4


Src: 
void numberOfDigits ( int N ) { int nod = ( int ) Math . floor ( Math . log10 ( N ) + 1 ) ; int toDecrease = ( int ) ( Math . pow ( 10 , nod ) - 1 ) / 9 ; System . out . print ( ( N + 1 ) * nod - toDecrease ) ; }
Ref: 
def numberOfDigits ( N ) : NEW_LINE INDENT nod = floor ( log10 ( N ) + 1 ) ; NEW_LINE toDecrease = ( pow ( 10 , nod ) - 1 ) // 9 NEW_LINE print ( ( N + 1 ) * nod - toDecrease ) NEW_LINE DEDENT
Hyp: 
def numberOfDigits ( N ) : NEW_LINE INDENT nod = int ( math . floor ( math . log10 ( N ) + 1 ) ) ; NEW_LINE toDecrease = ( int ) ( math . pow ( 10 , nod ) - 1 ) / 9 ; NEW_LINE print ( ( N + 1 ) * nod - toDecrease ) ; NEW_LINE DEDENT

BLEU: 61.99
Edit Sim: 42


Src: 
int Squares ( int n , int m , int a ) { return ( ( m + a - 1 ) / a ) * ( ( n + a - 1 ) / a ) ; }
Ref: 
def Squares ( n , m , a ) : NEW_LINE INDENT return ( ( ( m + a - 1 ) // a ) * ( ( n + a - 1 ) // a ) ) NEW_LINE DEDENT
Hyp: 
def Squares ( n , m , a ) : NEW_LINE INDENT return ( ( m + a - 1 ) // a ) * ( ( n + a - 1 ) // a ) NEW_LINE DEDENT

BLEU: 92.2
Edit Sim: 4


Src: 
int countTrailingZero ( int x ) { int lookup [ ] = { 32 , 0 , 1 , 26 , 2 , 23 , 27 , 0 , 3 , 16 , 24 , 30 , 28 , 11 , 0 , 13 , 4 , 7 , 17 , 0 , 25 , 22 , 31 , 15 , 29 , 10 , 12 , 6 , 0 , 21 , 14 , 9 , 5 , 20 , 8 , 19 , 18 } ; return lookup [ ( - x & x ) % 37 ] ; }
Ref: 
def countTrailingZero ( x ) : NEW_LINE INDENT lookup = [ 32 , 0 , 1 , 26 , 2 , 23 , 27 , 0 , 3 , 16 , 24 , 30 , 28 , 11 , 0 , 13 , 4 , 7 , 17 , 0 , 25 , 22 , 31 , 15 , 29 , 10 , 12 , 6 , 0 , 21 , 14 , 9 , 5 , 20 , 8 , 19 , 18 ] NEW_LINE return lookup [ ( - x & x ) % 37 ] NEW_LINE DEDENT
Hyp: 
def countTrailingZero ( x ) : NEW_LINE INDENT lookup = [ 0 , 0 , 1 , 26 , 2 , 23 , 27 , 0 , 3 , 16 , 24 , 30 , 28 , 11 , 0 , 13 , 4 , 7 , 17 , 0 , 25 , 22 , 31 , 15 , 29 , 10 , 12 , 6 , 0 , 21 , 14 , 9 , 5 , 20 , 8 , 19 , 18 ] NEW_LINE return lookup [ ( - x & x ) % 37 ] NEW_LINE DEDENT

BLEU: 97.47
Edit Sim: 2


Src: 
boolean printPairs ( int arr [ ] , int n , int k ) { boolean isPairFound = true ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i != j && arr [ i ] % arr [ j ] == k ) { System . out . print ( " ( " + arr [ i ] + " , ▁ " + arr [ j ] + " ) " + " ▁ " ) ; isPairFound = true ; } } } return isPairFound ; }
Ref: 
def printPairs ( arr , n , k ) : NEW_LINE INDENT isPairFound = True NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT if ( i != j and arr [ i ] % arr [ j ] == k ) : NEW_LINE INDENT print ( " ( " , arr [ i ] , " , ▁ " , arr [ j ] , " ) " , sep = " " , end = " ▁ " ) NEW_LINE isPairFound = True NEW_LINE DEDENT DEDENT DEDENT return isPairFound NEW_LINE DEDENT arr = [ 2 , 3 , 5 , 4 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE if ( printPairs ( arr , n , k ) == False ) : NEW_LINE INDENT print ( " No ▁ such ▁ pair ▁ exists " ) NEW_LINE DEDENT
Hyp: 
def printPairs ( arr , n , k ) : NEW_LINE INDENT isPairFound = True NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT if ( i != j and arr [ i ] % arr [ j ] == k ) : NEW_LINE INDENT print ( " ( " , arr [ i ] , " , ▁ " , arr [ j ] , " ) " , " ▁ " ) NEW_LINE isPairFound = True NEW_LINE DEDENT DEDENT DEDENT return isPairFound NEW_LINE DEDENT

BLEU: 53.64
Edit Sim: 212


Src: 
int extrema ( int a [ ] , int n ) { int count = 0 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( a [ i ] > a [ i - 1 ] && a [ i ] > a [ i + 1 ] ) count += 1 ; if ( a [ i ] < a [ i - 1 ] && a [ i ] < a [ i + 1 ] ) count += 1 ; } return count ; }
Ref: 
def extrema ( a , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT count += ( a [ i ] > a [ i - 1 ] and a [ i ] > a [ i + 1 ] ) ; NEW_LINE count += ( a [ i ] < a [ i - 1 ] and a [ i ] < a [ i + 1 ] ) ; NEW_LINE DEDENT return count NEW_LINE DEDENT
Hyp: 
def extrema ( a , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if ( a [ i ] > a [ i - 1 ] and a [ i ] > a [ i + 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( a [ i ] < a [ i - 1 ] and a [ i ] < a [ i + 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT

BLEU: 80.88
Edit Sim: 72


Src: 
int findSum ( int N , int k ) { int sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { sum += ( int ) Math . pow ( i , k ) ; } return sum ; }
Ref: 
def findSum ( N , k ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , N + 1 , 1 ) : NEW_LINE INDENT sum += pow ( i , k ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
Hyp: 
def findSum ( N , k ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT sum += pow ( i , k ) NEW_LINE DEDENT return sum NEW_LINE DEDENT

BLEU: 93.56
Edit Sim: 4


Src: 
void endPointOfDiameterofCircle ( int x1 , int y1 , int c1 , int c2 ) { System . out . print ( " x2 ▁ = ▁ " + ( 2 * c1 - x1 ) + " ▁ " ) ; System . out . print ( " y2 ▁ = ▁ " + ( 2 * c2 - y1 ) ) ; }
Ref: 
def endPointOfDiameterofCircle ( x1 , y1 , c1 , c2 ) : NEW_LINE INDENT print ( " x2 ▁ = " , ( 2 * c1 - x1 ) , end = " ▁ " ) NEW_LINE print ( " y2 ▁ = " , ( 2 * c2 - y1 ) ) NEW_LINE DEDENT
Hyp: 
def endPointOfDiameterofCircle ( x1 , y1 , c1 , c2 ) : NEW_LINE INDENT print ( " x2 ▁ = " , ( 2 * c1 - x1 ) , " ▁ " ) ; NEW_LINE print ( " y2 ▁ = " , ( 2 * c2 - y1 ) , " ▁ " ) ; NEW_LINE DEDENT

BLEU: 80.85
Edit Sim: 18


Src: 
double Convert ( double radian ) { double pi = 3.14159 ; return ( radian * ( 180 / pi ) ) ; }
Ref: 
def Convert ( radian ) : NEW_LINE INDENT pi = 3.14159 NEW_LINE degree = radian * ( 180 / pi ) NEW_LINE return degree NEW_LINE DEDENT
Hyp: 
def Convert ( radian ) : NEW_LINE INDENT pi = 3.14159 NEW_LINE return ( radian * ( 180 / pi ) ) NEW_LINE DEDENT

BLEU: 71.09
Edit Sim: 28


Src: 
void printpairs ( int arr [ ] , int sum ) { HashSet < Integer > s = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < arr . length ; ++ i ) { int temp = sum - arr [ i ] ; if ( s . contains ( temp ) ) { System . out . println ( " Pair ▁ with ▁ given ▁ sum ▁ " + sum + " ▁ is ▁ ( " + arr [ i ] + " , ▁ " + temp + " ) " ) ; } s . add ( arr [ i ] ) ; } }
Ref: 
def printPairs ( arr , arr_size , sum ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( 0 , arr_size ) : NEW_LINE INDENT temp = sum - arr [ i ] NEW_LINE if ( temp in s ) : NEW_LINE INDENT print " Pair ▁ with ▁ given ▁ sum ▁ " + str ( sum ) + NEW_LINE DEDENT DEDENT " ▁ is ▁ ( " + str ( arr [ i ] ) + " , ▁ " + str ( temp ) + " ) " NEW_LINE INDENT s . add ( arr [ i ] ) NEW_LINE DEDENT DEDENT
Hyp: 
def printpairs ( arr , sum ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT temp = sum - arr [ i ] NEW_LINE if temp in s : NEW_LINE INDENT print ( " Pair ▁ with ▁ given ▁ sum ▁ " , sum , " ▁ is ▁ ( " , arr [ i ] , " , ▁ " , temp , " ) " ) NEW_LINE DEDENT DEDENT s . add ( arr [ i ] ) NEW_LINE DEDENT

BLEU: 59.49
Edit Sim: 97


Src: 
void printPermutation ( int n , int k ) { for ( int i = 1 ; i <= n ; i ++ ) { int x = 2 * i - 1 ; int y = 2 * i ; if ( i <= k ) System . out . print ( y + " ▁ " + x + " ▁ " ) ; else System . out . print ( x + " ▁ " + y + " ▁ " ) ; } }
Ref: 
def printPermutation ( n , k ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT x = 2 * i - 1 ; NEW_LINE y = 2 * i ; NEW_LINE if ( i <= k ) : NEW_LINE INDENT print ( y , x , end = " ▁ " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( x , y , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT DEDENT
Hyp: 
def printPermutation ( n , k ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT x = 2 * i - 1 NEW_LINE y = 2 * i NEW_LINE if ( i <= k ) : NEW_LINE INDENT print ( y , x , " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( x , y , " ▁ " ) NEW_LINE DEDENT DEDENT

BLEU: 77.71
Edit Sim: 27


Src: 
void PrintReverseOrder ( int N ) { for ( int i = N ; i > 0 ; i -- ) System . out . print ( + i + " ▁ " ) ; }
Ref: 
def PrintReverseOrder ( N ) : NEW_LINE INDENT for i in range ( N , 0 , - 1 ) : NEW_LINE INDENT print ( i , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT
Hyp: 
def PrintReverseOrder ( N ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT

BLEU: 73.79
Edit Sim: 12


Src: 
String to_upper ( char [ ] in ) { for ( int i = 0 ; i < in . length ; i ++ ) { if ( ' a ' <= in [ i ] & in [ i ] <= ' z ' ) { in [ i ] = ( char ) ( in [ i ] - ' a ' + ' A ' ) ; } } return String . valueOf ( in ) ; }
Ref: 
def to_upper ( string ) : NEW_LINE INDENT for i in range ( len ( string ) ) : NEW_LINE INDENT if ( ' a ' <= string [ i ] <= ' z ' ) : NEW_LINE INDENT string = ( string [ 0 : i ] + chr ( ord ( string [ i ] ) - ord ( ' a ' ) + ord ( ' A ' ) ) + string [ i + 1 : ] ) NEW_LINE DEDENT DEDENT return string ; NEW_LINE DEDENT
Hyp: 
def to_upper ( in ) : NEW_LINE INDENT for i in range ( len ( in ) ) : NEW_LINE INDENT if ( ' a ' <= in [ i ] & in [ i ] <= ' z ' ) : NEW_LINE INDENT in [ i ] = chr ( ord ( in [ i ] ) - ord ( ' a ' ) + ord ( ' A ' ) ) NEW_LINE DEDENT DEDENT return str ( in ) NEW_LINE DEDENT

BLEU: 63.07
Edit Sim: 72


Src: 
int countWays ( int n ) { int count = 0 ; for ( int i = 1 ; i * i < n ; i ++ ) if ( n % i == 0 ) count ++ ; return count ; }
Ref: 
def countWays ( n ) : NEW_LINE INDENT count = 0 NEW_LINE i = 1 NEW_LINE while ( ( i * i ) < n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
Hyp: 
def countWays ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT

BLEU: 64.37
Edit Sim: 42


Src: 
void findMin ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; Arrays . sort ( arr ) ; int min = arr [ 0 ] ; int max = 0 ; for ( int i = n - 1 ; i >= 1 ; i -- ) { int num = arr [ i ] ; int total = num + min ; int j ; for ( j = 2 ; j <= num ; j ++ ) { if ( num % j == 0 ) { int d = j ; int now = ( num / d ) + ( min * d ) ; int reduce = total - now ; if ( reduce > max ) max = reduce ; } } } System . out . println ( sum - max ) ; }
Ref: 
def findMin ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum = sum + arr [ i ] NEW_LINE DEDENT arr . sort ( ) NEW_LINE min = arr [ 0 ] NEW_LINE max = 0 NEW_LINE for i in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT num = arr [ i ] NEW_LINE total = num + min NEW_LINE for j in range ( 2 , num + 1 ) : NEW_LINE INDENT if ( num % j == 0 ) : NEW_LINE INDENT d = j NEW_LINE now = ( num // d ) + ( min * d ) NEW_LINE reduce = total - now NEW_LINE if ( reduce > max ) : NEW_LINE INDENT max = reduce NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( sum - max ) NEW_LINE DEDENT
Hyp: 
def findMin ( arr , n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] ; NEW_LINE DEDENT arr . sort ( ) NEW_LINE min = arr [ 0 ] NEW_LINE max = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT num = arr [ i ] NEW_LINE total = num + min NEW_LINE j = 2 NEW_LINE while ( num % j == 0 ) : NEW_LINE INDENT d = j NEW_LINE now = ( num // d ) + ( min * d ) NEW_LINE reduce = total - now NEW_LINE if ( reduce > max ) : NEW_LINE INDENT max = reduce NEW_LINE DEDENT DEDENT DEDENT print ( sum - max ) NEW_LINE DEDENT

BLEU: 80.52
Edit Sim: 62


Src: 
void digitsNum ( int N ) { if ( N == 0 ) System . out . println ( "0" ) ; if ( N % 9 != 0 ) System . out . print ( ( N % 9 ) ) ; for ( int i = 1 ; i <= ( N / 9 ) ; ++ i ) System . out . print ( "9" ) ; for ( int i = 1 ; i <= N ; ++ i ) System . out . print ( "0" ) ; System . out . print ( " " ) ; }
Ref: 
def digitsNum ( N ) : NEW_LINE INDENT if ( N == 0 ) : NEW_LINE INDENT print ( "0" , end = " " ) NEW_LINE DEDENT if ( N % 9 != 0 ) : NEW_LINE INDENT print ( N % 9 , end = " " ) NEW_LINE DEDENT for i in range ( 1 , int ( N / 9 ) + 1 ) : NEW_LINE INDENT print ( "9" , end = " " ) NEW_LINE DEDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT print ( "0" , end = " " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT
Hyp: 
def digitsNum ( N ) : NEW_LINE INDENT if ( N == 0 ) : NEW_LINE INDENT print ( "0" ) NEW_LINE DEDENT if ( N % 9 != 0 ) : NEW_LINE INDENT print ( ( N % 9 ) ) NEW_LINE DEDENT for i in range ( 1 , ( N // 9 ) + 1 ) : NEW_LINE INDENT print ( "9" , end = " " ) NEW_LINE DEDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT print ( "0" , end = " " ) NEW_LINE DEDENT print ( " " ) NEW_LINE DEDENT

BLEU: 83.46
Edit Sim: 34


Src: 
int printKDistinct ( int arr [ ] , int n , int k ) { int dist_count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < n ; j ++ ) if ( i != j && arr [ j ] == arr [ i ] ) break ; if ( j == n ) dist_count ++ ; if ( dist_count == k ) return arr [ i ] ; } return - 1 ; }
Ref: 
def printKDistinct ( arr , n , k ) : NEW_LINE INDENT dist_count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT j = 0 NEW_LINE while j < n : NEW_LINE INDENT if ( i != j and arr [ j ] == arr [ i ] ) : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if ( j == n ) : NEW_LINE INDENT dist_count += 1 NEW_LINE DEDENT if ( dist_count == k ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
Hyp: 
def printKDistinct ( arr , n , k ) : NEW_LINE INDENT dist_count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( i != j and arr [ j ] == arr [ i ] ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( j == n ) : NEW_LINE INDENT dist_count += 1 NEW_LINE DEDENT if ( dist_count == k ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT

BLEU: 85.24
Edit Sim: 35


Src: 
int minNum ( int arr [ ] , int n ) { Boolean odd = false ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 != 0 ) odd = ! odd ; if ( odd ) return 1 ; return 2 ; }
Ref: 
def minNum ( arr , n ) : NEW_LINE INDENT odd = False NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 ) : NEW_LINE INDENT odd = not odd NEW_LINE DEDENT DEDENT if ( odd ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 2 NEW_LINE DEDENT
Hyp: 
def minNum ( arr , n ) : NEW_LINE INDENT odd = False NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] % 2 != 0 : NEW_LINE INDENT odd = not odd NEW_LINE DEDENT DEDENT if odd : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 2 NEW_LINE DEDENT

BLEU: 83.49
Edit Sim: 10


Src: 
int circle ( int x1 , int y1 , int x2 , int y2 , int r1 , int r2 ) { int distSq = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ; int radSumSq = ( r1 + r2 ) * ( r1 + r2 ) ; if ( distSq == radSumSq ) return 1 ; else if ( distSq > radSumSq ) return - 1 ; else return 0 ; }
Ref: 
def circle ( x1 , y1 , x2 , y2 , r1 , r2 ) : NEW_LINE INDENT distSq = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ; NEW_LINE radSumSq = ( r1 + r2 ) * ( r1 + r2 ) ; NEW_LINE if ( distSq == radSumSq ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( distSq > radSumSq ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT x1 = - 10 NEW_LINE y1 = 8 NEW_LINE x2 = 14 NEW_LINE y2 = - 24 NEW_LINE r1 = 30 NEW_LINE r2 = 10 NEW_LINE t = circle ( x1 , y1 , x2 , y2 , r1 , r2 ) NEW_LINE if ( t == 1 ) : NEW_LINE INDENT print ( " Circle ▁ touch ▁ to ▁ each ▁ other . " ) NEW_LINE DEDENT elif ( t < 0 ) : NEW_LINE INDENT print ( " Circle ▁ not ▁ touch ▁ to ▁ each ▁ other . " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Circle ▁ intersect ▁ to ▁ each ▁ other . " ) NEW_LINE DEDENT
Hyp: 
def circle ( x1 , y1 , x2 , y2 , r1 , r2 ) : NEW_LINE INDENT distSq = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) NEW_LINE radSumSq = ( r1 + r2 ) * ( r1 + r2 ) NEW_LINE if ( distSq == radSumSq ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( distSq > radSumSq ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT x1 , y1 = - 10 , 8 ; NEW_LINE x2 , y2 = 14 , - 24 ; NEW_LINE r1 , r2 = 30 , 10 ; NEW_LINE t = circle ( x1 , y1 , x2 , y2 , r1 , r2 ) ; NEW_LINE if ( t == 1 ) : NEW_LINE INDENT print ( " There ▁ are ▁ 3 ▁ common ▁ tangents ▁ between ▁ the ▁ circles . " ) NEW_LINE DEDENT elif ( t < 0 ) : NEW_LINE INDENT print ( " There ▁ are ▁ 4 ▁ common ▁ tangents ▁ between ▁ the ▁ circles . " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " There ▁ are ▁ 2 ▁ common ▁ tangents ▁ between ▁ the ▁ circles . " ) NEW_LINE DEDENT

BLEU: 69.69
Edit Sim: 177


Src: 
void radius ( int n , int d ) { System . out . print ( " The ▁ radius ▁ of ▁ each ▁ circle ▁ is ▁ " + d / ( 2 * n - 2 ) ) ; }
Ref: 
def radius ( n , d ) : NEW_LINE INDENT print ( " The ▁ radius ▁ of ▁ each ▁ circle ▁ is ▁ " , d / ( 2 * n - 2 ) ) ; NEW_LINE DEDENT
Hyp: 
def radius ( n , d ) : NEW_LINE INDENT print ( " The ▁ radius ▁ of ▁ each ▁ circle ▁ is " , d / ( 2 * n - 2 ) ) NEW_LINE DEDENT

BLEU: 87.62
Edit Sim: 4


Src: 
int nthTerm ( int N ) { int nth = 0 , first_term = 12 ; nth = ( int ) ( ( first_term * ( Math . pow ( 2 , N - 1 ) ) ) + 11 * ( ( Math . pow ( 2 , N - 1 ) ) - 1 ) ) ; return nth ; }
Ref: 
def nthTerm ( N ) : NEW_LINE INDENT nth = 0 ; first_term = 12 ; NEW_LINE nth = ( first_term * ( pow ( 2 , N - 1 ) ) ) + 11 * ( ( pow ( 2 , N - 1 ) ) - 1 ) ; NEW_LINE return nth ; NEW_LINE DEDENT
Hyp: 
def nthTerm ( N ) : NEW_LINE INDENT nth = 0 NEW_LINE first_term = 12 NEW_LINE nth = ( ( first_term * ( pow ( 2 , N - 1 ) ) ) + 11 * ( ( pow ( 2 , N - 1 ) ) - 1 ) ) NEW_LINE return nth NEW_LINE DEDENT

BLEU: 80.72
Edit Sim: 15


Src: 
void printBalancedExpression ( int a , int b , int c , int d ) { if ( ( ( a == d ) && ( a != 0 ) ) || ( ( a == 0 ) && ( c == 0 ) && ( d == 0 ) ) ) { for ( int i = 1 ; i <= a ; i ++ ) System . out . print ( " ( ( " ) ; for ( int i = 1 ; i <= c ; i ++ ) System . out . print ( " ) ( " ) ; for ( int i = 1 ; i <= d ; i ++ ) System . out . print ( " ) ) " ) ; for ( int i = 1 ; i <= b ; i ++ ) System . out . print ( " ( ) " ) ; } else System . out . print ( - 1 ) ; }
Ref: 
def printBalancedExpression ( a , b , c , d ) : NEW_LINE INDENT if ( ( a == d and a ) or ( a == 0 and c == 0 and d == 0 ) ) : NEW_LINE INDENT for i in range ( 1 , a + 1 ) : NEW_LINE INDENT print ( " ( ( " , end = " " ) NEW_LINE DEDENT for i in range ( 1 , c + 1 ) : NEW_LINE INDENT print ( " ) ( " , end = " " ) NEW_LINE DEDENT for i in range ( 1 , d + 1 ) : NEW_LINE INDENT print ( " ) ) " , end = " " ) NEW_LINE DEDENT for i in range ( 1 , b + 1 ) : NEW_LINE INDENT print ( " ( ) " , end = " " ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT DEDENT
Hyp: 
def printBalancedExpression ( a , b , c , d ) : NEW_LINE INDENT if ( ( a == d ) and ( a != 0 ) ) or ( ( a == 0 ) and ( c == 0 ) and ( d == 0 ) ) : NEW_LINE INDENT for i in range ( 1 , a + 1 ) : NEW_LINE INDENT print ( " ( " , end = " ) " ) NEW_LINE DEDENT for i in range ( 1 , c + 1 ) : NEW_LINE INDENT print ( " ) ( " , end = " ) " ) NEW_LINE DEDENT for i in range ( 1 , d + 1 ) : NEW_LINE INDENT print ( " ) ( " , end = " ) " ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT

BLEU: 71.69
Edit Sim: 115


Src: 
float area ( float a ) { if ( a < 0 ) return - 1 ; float area = ( float ) Math . pow ( ( a * Math . sqrt ( 3 ) ) / ( Math . sqrt ( 2 ) ) , 2 ) ; return area ; }
Ref: 
def area ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT area = pow ( ( a * sqrt ( 3 ) ) / ( sqrt ( 2 ) ) , 2 ) NEW_LINE return area NEW_LINE DEDENT
Hyp: 
def area ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT area = pow ( ( a * math . sqrt ( 3 ) ) / ( math . sqrt ( 2 ) ) , 2 ) NEW_LINE return area NEW_LINE DEDENT

BLEU: 86.45
Edit Sim: 14


Src: 
int pairCount ( int n , int m ) { int cnt = 0 , b , a ; for ( b = 0 ; b <= Math . sqrt ( m ) ; b ++ ) { a = m - b * b ; if ( a * a + b == n ) { cnt ++ ; } } return cnt ; }
Ref: 
def pairCount ( n , m ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE for b in range ( int ( pow ( m , 1 / 2 ) ) ) : NEW_LINE INDENT a = m - b * b ; NEW_LINE if ( a * a + b == n ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT DEDENT return cnt ; NEW_LINE DEDENT
Hyp: 
def pairCount ( n , m ) : NEW_LINE INDENT cnt = 0 NEW_LINE for b in range ( 0 , int ( math . sqrt ( m ) ) + 1 ) : NEW_LINE INDENT a = m - b * b NEW_LINE if ( a * a + b == n ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT

BLEU: 70.21
Edit Sim: 27


Src: 
double nthHarmonic ( int N ) { float harmonic = 1 ; for ( int i = 2 ; i <= N ; i ++ ) { harmonic += ( float ) 1 / i ; } return harmonic ; }
Ref: 
def nthHarmonic ( N ) : NEW_LINE INDENT harmonic = 1.00 NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT harmonic += 1 / i NEW_LINE DEDENT return harmonic NEW_LINE DEDENT
Hyp: 
def nthHarmonic ( N ) : NEW_LINE INDENT harmonic = 1 NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT harmonic += ( float ) 1 / i NEW_LINE DEDENT return harmonic NEW_LINE DEDENT

BLEU: 81.87
Edit Sim: 13


Src: 
void MinDiff ( int n ) { int val = ( int ) Math . pow ( 2 , n ) ; int sep = n / 2 ; int grp1 = 0 ; int grp2 = 0 ; grp1 = grp1 + val ; for ( int i = 1 ; i < sep ; i ++ ) grp1 = grp1 + ( int ) Math . pow ( 2 , i ) ; for ( int i = sep ; i < n ; i ++ ) grp2 = grp2 + ( int ) Math . pow ( 2 , i ) ; System . out . println ( Math . abs ( grp1 - grp2 ) ) ; }
Ref: 
def MinDiff ( n ) : NEW_LINE INDENT val = 2 ** n NEW_LINE sep = n // 2 NEW_LINE grp1 = 0 NEW_LINE grp2 = 0 NEW_LINE grp1 = grp1 + val NEW_LINE for i in range ( 1 , sep ) : NEW_LINE INDENT grp1 = grp1 + 2 ** i NEW_LINE DEDENT for i in range ( sep , n ) : NEW_LINE INDENT grp2 = grp2 + 2 ** i NEW_LINE DEDENT print ( abs ( grp1 - grp2 ) ) NEW_LINE DEDENT
Hyp: 
def MinDiff ( n ) : NEW_LINE INDENT val = pow ( 2 , n ) NEW_LINE sep = n // 2 NEW_LINE grp1 = 0 NEW_LINE grp2 = 0 NEW_LINE grp1 = grp1 + val NEW_LINE for i in range ( 1 , sep ) : NEW_LINE INDENT grp1 = grp1 + pow ( 2 , i ) NEW_LINE DEDENT for i in range ( sep , n ) : NEW_LINE INDENT grp2 = grp2 + pow ( 2 , i ) NEW_LINE DEDENT print ( abs ( grp1 - grp2 ) ) NEW_LINE DEDENT

BLEU: 77.71
Edit Sim: 30


Src: 
void printNumberWithDR ( int k , int d ) { if ( d == 0 && k != 1 ) System . out . print ( " - 1" ) ; else { System . out . print ( d ) ; k -- ; while ( k -- > 0 ) System . out . print ( "0" ) ; } }
Ref: 
def printNumberWithDR ( k , d ) : NEW_LINE INDENT if d == 0 and k != 1 : NEW_LINE INDENT print ( - 1 , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( d , end = " " ) NEW_LINE k -= 1 NEW_LINE while k : NEW_LINE INDENT print ( 0 , end = " " ) NEW_LINE k -= 1 NEW_LINE DEDENT DEDENT DEDENT
Hyp: 
def printNumberWithDR ( k , d ) : NEW_LINE INDENT if ( d == 0 and k != 1 ) : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( d ) NEW_LINE k -= 1 NEW_LINE while ( k > 0 ) : NEW_LINE INDENT print ( "0" ) NEW_LINE DEDENT DEDENT

BLEU: 52.57
Edit Sim: 70


Src: 
int findNthDigit ( int p , int q , int N ) { int res = 0 ; while ( N > 0 ) { N -- ; p *= 10 ; res = p / q ; p %= q ; } return res ; }
Ref: 
def findNthDigit ( p , q , N ) : NEW_LINE INDENT while ( N > 0 ) : NEW_LINE INDENT N -= 1 ; NEW_LINE p *= 10 ; NEW_LINE res = p // q ; NEW_LINE p %= q ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT
Hyp: 
def findNthDigit ( p , q , N ) : NEW_LINE INDENT res = 0 NEW_LINE while ( N > 0 ) : NEW_LINE INDENT N -= 1 NEW_LINE p *= 10 NEW_LINE res = p // q NEW_LINE p %= q NEW_LINE DEDENT return res NEW_LINE DEDENT

BLEU: 69.98
Edit Sim: 27


Src: 
int knapSack ( int [ ] nums , int S ) { int sum = 0 ; for ( int i : nums ) sum += i ; if ( sum < S || - sum > - S || ( S + sum ) % 2 == 1 ) return 0 ; int [ ] dp = new int [ ( S + sum ) / 2 + 1 ] ; dp [ 0 ] = 1 ; for ( int num : nums ) { for ( int i = dp . length - 1 ; i >= num ; i -- ) { dp [ i ] += dp [ i - num ] ; } } return dp [ dp . length - 1 ] ; }
Ref: 
def knapSack ( nums , S ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( len ( nums ) ) : NEW_LINE INDENT sum += nums [ i ] ; NEW_LINE DEDENT if ( sum < S or - sum > - S or ( S + sum ) % 2 == 1 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT dp = [ 0 ] * ( ( ( S + sum ) // 2 ) + 1 ) ; NEW_LINE dp [ 0 ] = 1 ; NEW_LINE for j in range ( len ( nums ) ) : NEW_LINE INDENT for i in range ( len ( dp ) - 1 , nums [ j ] - 1 , - 1 ) : NEW_LINE INDENT dp [ i ] += dp [ i - nums [ j ] ] ; NEW_LINE DEDENT DEDENT return dp [ len ( dp ) - 1 ] ; NEW_LINE DEDENT
Hyp: 
def knapSack ( nums , S ) : NEW_LINE INDENT sum = sum ( nums ) NEW_LINE if ( sum < S or - sum > - S or ( S + sum ) % 2 == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT dp = [ 0 ] * ( S + sum ) // 2 + 1 NEW_LINE dp [ 0 ] = 1 NEW_LINE for num in nums : NEW_LINE INDENT for i in range ( dp . length - 1 , num , - 1 ) : NEW_LINE INDENT dp [ i ] += dp [ i - num ] NEW_LINE DEDENT DEDENT return dp [ len ( dp ) - 1 ] NEW_LINE DEDENT

BLEU: 53.95
Edit Sim: 144


Src: 
int swapBits ( int x ) { int even_bits = x & 0xAAAAAAAA ; int odd_bits = x & 0x55555555 ; even_bits >>= 1 ; odd_bits <<= 1 ; return ( even_bits odd_bits ) ; }
Ref: 
def swapBits ( x ) : NEW_LINE INDENT even_bits = x & 0xAAAAAAAA NEW_LINE odd_bits = x & 0x55555555 NEW_LINE even_bits >>= 1 NEW_LINE odd_bits <<= 1 NEW_LINE return ( even_bits odd_bits ) NEW_LINE DEDENT
Hyp: 
def swapBits ( x ) : NEW_LINE INDENT even_bits = x & 0xAAAAAAAA NEW_LINE odd_bits = x & 0x55555555 NEW_LINE even_bits >>= 1 NEW_LINE odd_bits <<= 1 NEW_LINE return ( even_bits odd_bits ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int findMaxAverage ( int arr [ ] , int n , int k ) { if ( k > n ) return - 1 ; int sum = arr [ 0 ] ; for ( int i = 1 ; i < k ; i ++ ) sum += arr [ i ] ; int max_sum = sum , max_end = k - 1 ; for ( int i = k ; i < n ; i ++ ) { sum = sum + arr [ i ] - arr [ i - k ] ; if ( sum > max_sum ) { max_sum = sum ; max_end = i ; } } return max_end - k + 1 ; }
Ref: 
def findMaxAverage ( arr , n , k ) : NEW_LINE INDENT if ( k > n ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT sum = arr [ 0 ] NEW_LINE for i in range ( 1 , k ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT max_sum = sum NEW_LINE max_end = k - 1 NEW_LINE for i in range ( k , n ) : NEW_LINE INDENT sum = sum + arr [ i ] - arr [ i - k ] NEW_LINE if ( sum > max_sum ) : NEW_LINE INDENT max_sum = sum NEW_LINE max_end = i NEW_LINE DEDENT DEDENT return max_end - k + 1 NEW_LINE DEDENT
Hyp: 
def findMaxAverage ( arr , n , k ) : NEW_LINE INDENT if ( k > n ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT sum = arr [ 0 ] NEW_LINE for i in range ( 1 , k ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT max_sum = sum NEW_LINE max_end = k - 1 NEW_LINE for i in range ( k , n ) : NEW_LINE INDENT sum = sum + arr [ i ] - arr [ i - k ] NEW_LINE if ( sum > max_sum ) : NEW_LINE INDENT max_sum = sum NEW_LINE max_end = i NEW_LINE DEDENT DEDENT return max_end - k + 1 NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
boolean check ( String str ) { int n = str . length ( ) ; int oddDigSum = 0 , evenDigSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) oddDigSum += ( str . charAt ( i ) - '0' ) ; else evenDigSum += ( str . charAt ( i ) - '0' ) ; } return ( ( oddDigSum - evenDigSum ) % 11 == 0 ) ; }
Ref: 
def check ( st ) : NEW_LINE INDENT n = len ( st ) NEW_LINE oddDigSum = 0 NEW_LINE evenDigSum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT oddDigSum = oddDigSum + ( ( int ) ( st [ i ] ) ) NEW_LINE DEDENT else : NEW_LINE INDENT evenDigSum = evenDigSum + ( ( int ) ( st [ i ] ) ) NEW_LINE DEDENT DEDENT return ( ( oddDigSum - evenDigSum ) % 11 == 0 ) NEW_LINE DEDENT st = "76945" NEW_LINE if ( check ( st ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No ▁ " ) NEW_LINE DEDENT
Hyp: 
def check ( st ) : NEW_LINE INDENT n = len ( st ) NEW_LINE oddDigSum = 0 NEW_LINE evenDigSum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT oddDigSum += ( int ) ( st [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT evenDigSum += ( int ) ( st [ i ] ) NEW_LINE DEDENT DEDENT return ( ( oddDigSum - evenDigSum ) % 11 == 0 ) NEW_LINE DEDENT

BLEU: 57.77
Edit Sim: 185


Src: 
int numberSequence ( int n ) { int num = ( int ) ( Math . pow ( 4 , n ) - Math . pow ( 2 , n ) ) - 1 ; return num ; }
Ref: 
def numberSequence ( n ) : NEW_LINE INDENT num = pow ( 4 , n ) - pow ( 2 , n ) - 1 NEW_LINE return num NEW_LINE DEDENT
Hyp: 
def numberSequence ( n ) : NEW_LINE INDENT num = ( pow ( 4 , n ) - pow ( 2 , n ) ) - 1 NEW_LINE return num NEW_LINE DEDENT

BLEU: 86.02
Edit Sim: 4


Src: 
void findSolutions ( int N ) { int count = 0 ; for ( int i = 1 ; i <= Math . sqrt ( N ) ; i ++ ) { if ( N % i == 0 ) { if ( ( i + N / i ) % 2 == 0 ) { count ++ ; } } } System . out . print ( 4 * count ) ; }
Ref: 
def findSolutions ( N ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( 1 , int ( math . sqrt ( N ) ) + 1 ) : NEW_LINE INDENT if ( N % i == 0 ) : NEW_LINE INDENT if ( ( i + N // i ) % 2 == 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT DEDENT print ( 4 * count ) ; NEW_LINE DEDENT
Hyp: 
def findSolutions ( N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , int ( sqrt ( N ) ) + 1 ) : NEW_LINE INDENT if ( N % i == 0 ) : NEW_LINE INDENT if ( ( i + N // i ) % 2 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT print ( 4 * count ) NEW_LINE DEDENT

BLEU: 86.09
Edit Sim: 13


Src: 
void subtract ( int A [ ] [ ] , int B [ ] [ ] , int C [ ] [ ] ) { int i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < N ; j ++ ) C [ i ] [ j ] = A [ i ] [ j ] - B [ i ] [ j ] ; }
Ref: 
def subtract ( A , B , C ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT C [ i ] [ j ] = A [ i ] [ j ] - B [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT A = [ [ 1 , 1 , 1 , 1 ] , [ 2 , 2 , 2 , 2 ] , [ 3 , 3 , 3 , 3 ] , [ 4 , 4 , 4 , 4 ] ] NEW_LINE B = [ [ 1 , 1 , 1 , 1 ] , [ 2 , 2 , 2 , 2 ] , [ 3 , 3 , 3 , 3 ] , [ 4 , 4 , 4 , 4 ] ] NEW_LINE C = A [ : ] [ : ] NEW_LINE subtract ( A , B , C ) NEW_LINE print ( " Result ▁ matrix ▁ is " ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT print ( C [ i ] [ j ] , " ▁ " , end = ' ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT
Hyp: 
def subtract ( A , B , C ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT C [ i ] [ j ] = A [ i ] [ j ] - B [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT

BLEU: 6.21
Edit Sim: 457


Src: 
int maximumSum ( int [ ] a , int count , int index , int n , int [ ] [ ] dp ) { if ( index == n ) return 0 ; if ( dp [ index ] [ count ] != - 1 ) return dp [ index ] [ count ] ; int take_element = a [ index ] * count + maximumSum ( a , count + 1 , index + 1 , n , dp ) ; int dont_take = maximumSum ( a , count , index + 1 , n , dp ) ; return dp [ index ] [ count ] = Math . max ( take_element , dont_take ) ; }
Ref: 
def maximumSum ( a , count , index , n , dp ) : NEW_LINE INDENT if ( index == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ index ] [ count ] != - 1 ) : NEW_LINE INDENT return dp [ index ] [ count ] NEW_LINE DEDENT take_element = ( a [ index ] * count + maximumSum ( a , count + 1 , index + 1 , n , dp ) ) NEW_LINE dont_take = maximumSum ( a , count , index + 1 , n , dp ) NEW_LINE dp [ index ] [ count ] = max ( take_element , dont_take ) NEW_LINE return dp [ index ] [ count ] NEW_LINE DEDENT
Hyp: 
def maximumSum ( a , count , index , n , dp ) : NEW_LINE INDENT if ( index == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ index ] [ count ] != - 1 ) : NEW_LINE INDENT return dp [ index ] [ count ] NEW_LINE DEDENT take_element = a [ index ] * count + maximumSum ( a , count + 1 , index + 1 , n , dp ) NEW_LINE dont_take = maximumSum ( a , count , index + 1 , n , dp ) NEW_LINE return dp [ index ] [ count ] NEW_LINE DEDENT

BLEU: 83.41
Edit Sim: 71


Src: 
int calculateEvenSum ( int n ) { if ( n <= 0 ) return 0 ; int fibo [ ] = new int [ 2 * n + 1 ] ; fibo [ 0 ] = 0 ; fibo [ 1 ] = 1 ; int sum = 0 ; for ( int i = 2 ; i <= 2 * n ; i ++ ) { fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ; if ( i % 2 == 0 ) sum += fibo [ i ] ; } return sum ; }
Ref: 
def calculateEvenSum ( n ) : NEW_LINE INDENT if n <= 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT fibo = [ 0 ] * ( 2 * n + 1 ) NEW_LINE fibo [ 0 ] , fibo [ 1 ] = 0 , 1 NEW_LINE sum = 0 NEW_LINE for i in range ( 2 , 2 * n + 1 ) : NEW_LINE INDENT fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] NEW_LINE if i % 2 == 0 : NEW_LINE INDENT sum += fibo [ i ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
Hyp: 
def calculateEvenSum ( n ) : NEW_LINE INDENT if ( n <= 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT fibo = [ 0 ] * ( 2 * n + 1 ) ; NEW_LINE fibo [ 0 ] = 0 ; NEW_LINE fibo [ 1 ] = 1 ; NEW_LINE sum = 0 ; NEW_LINE for i in range ( 2 , 2 * n + 1 ) : NEW_LINE INDENT fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ; NEW_LINE if ( i % 2 == 0 ) : NEW_LINE INDENT sum += fibo [ i ] ; NEW_LINE DEDENT DEDENT return sum ; NEW_LINE DEDENT

BLEU: 71.78
Edit Sim: 38


Src: 
void countSubString ( String S , char C ) { int count = 0 ; int conCount = 0 ; for ( int i = 0 ; i < S . length ( ) ; i ++ ) { char ch = S . charAt ( i ) ; if ( ch == C ) conCount ++ ; else { count += ( conCount * ( conCount + 1 ) ) / 2 ; conCount = 0 ; } } count += ( conCount * ( conCount + 1 ) ) / 2 ; System . out . println ( count ) ; }
Ref: 
def countSubString ( S , C ) : NEW_LINE INDENT count = 0 NEW_LINE conCount = 0 NEW_LINE for ch in S : NEW_LINE INDENT if ( ch == C ) : NEW_LINE INDENT conCount += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count += ( ( conCount * ( conCount + 1 ) ) // 2 ) NEW_LINE conCount = 0 NEW_LINE DEDENT DEDENT count += ( ( conCount * ( conCount + 1 ) ) // 2 ) NEW_LINE print ( count ) NEW_LINE DEDENT
Hyp: 
def countSubString ( S , C ) : NEW_LINE INDENT count = 0 NEW_LINE conCount = 0 NEW_LINE for i in range ( len ( S ) ) : NEW_LINE INDENT ch = S [ i ] NEW_LINE if ( ch == C ) : NEW_LINE INDENT conCount += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count += ( conCount * ( conCount + 1 ) ) // 2 NEW_LINE conCount = 0 NEW_LINE DEDENT DEDENT count += ( conCount * ( conCount + 1 ) ) // 2 NEW_LINE print ( count ) NEW_LINE DEDENT

BLEU: 76.59
Edit Sim: 50


Src: 
void sortDiff ( Vector < Integer > arr , int n ) { Collections . sort ( arr ) ; Vector < Integer > out = new Vector < Integer > ( ) ; while ( n > 0 ) { out . add ( arr . get ( n / 2 ) ) ; arr . remove ( n / 2 ) ; n = n - 1 ; } for ( int i : out ) System . out . print ( i + " ▁ " ) ; }
Ref: 
def sortDiff ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE out = [ ] NEW_LINE while n : NEW_LINE INDENT out . append ( arr . pop ( n // 2 ) ) NEW_LINE n = n - 1 NEW_LINE DEDENT print ( * out ) NEW_LINE return out NEW_LINE DEDENT
Hyp: 
def sortDiff ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE out = [ ] NEW_LINE while ( n ) : NEW_LINE INDENT out . append ( arr [ n // 2 ] ) NEW_LINE arr . remove ( n // 2 ) NEW_LINE n = n - 1 NEW_LINE DEDENT print ( * out ) NEW_LINE DEDENT

BLEU: 73.78
Edit Sim: 57


Src: 
void alternateFib ( int n ) { if ( n < 0 ) return ; int f1 = 0 ; int f2 = 1 ; System . out . print ( f1 + " ▁ " ) ; for ( int i = 2 ; i <= n ; i ++ ) { int f3 = f2 + f1 ; if ( i % 2 == 0 ) System . out . print ( f3 + " ▁ " ) ; f1 = f2 ; f2 = f3 ; } }
Ref: 
def alternateFib ( n ) : NEW_LINE INDENT if ( n < 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT f1 = 0 ; NEW_LINE f2 = 1 ; NEW_LINE print ( f1 , end = " ▁ " ) ; NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT f3 = f2 + f1 ; NEW_LINE if ( i % 2 == 0 ) : NEW_LINE INDENT print ( f3 , end = " ▁ " ) ; NEW_LINE DEDENT f1 = f2 ; NEW_LINE f2 = f3 ; NEW_LINE DEDENT DEDENT
Hyp: 
def alternateFib ( n ) : NEW_LINE INDENT if ( n < 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT f1 = 0 NEW_LINE f2 = 1 NEW_LINE print ( f1 , end = " ▁ " ) NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT f3 = f2 + f1 NEW_LINE if ( i % 2 == 0 ) : NEW_LINE INDENT print ( f3 , end = " ▁ " ) NEW_LINE DEDENT f1 = f2 NEW_LINE f2 = f3 NEW_LINE DEDENT DEDENT

BLEU: 77.31
Edit Sim: 20


Src: 
int sumOfProductOfDigits ( int n1 , int n2 ) { int sum = 0 ; while ( n1 > 0 && n2 > 0 ) { sum += ( ( n1 % 10 ) * ( n2 % 10 ) ) ; n1 /= 10 ; n2 /= 10 ; } return sum ; }
Ref: 
def sumOfProductOfDigits ( n1 , n2 ) : NEW_LINE INDENT sum1 = 0 ; NEW_LINE while ( n1 > 0 and n2 > 0 ) : NEW_LINE INDENT sum1 += ( ( n1 % 10 ) * ( n2 % 10 ) ) ; NEW_LINE n1 = n1 // 10 ; NEW_LINE n2 = n2 // 10 ; NEW_LINE DEDENT return sum1 ; NEW_LINE DEDENT
Hyp: 
def sumOfProductOfDigits ( n1 , n2 ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( n1 > 0 and n2 > 0 ) : NEW_LINE INDENT sum += ( ( n1 % 10 ) * ( n2 % 10 ) ) NEW_LINE n1 /= 10 NEW_LINE n2 /= 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT

BLEU: 59.29
Edit Sim: 25


Src: 
int countValues ( int n ) { int unset_bits = 0 ; while ( n > 0 ) { if ( ( n & 1 ) == 0 ) unset_bits ++ ; n = n >> 1 ; } return 1 << unset_bits ; }
Ref: 
def countValues ( n ) : NEW_LINE INDENT unset_bits = 0 NEW_LINE while ( n ) : NEW_LINE INDENT if n & 1 == 0 : NEW_LINE INDENT unset_bits += 1 NEW_LINE DEDENT n = n >> 1 NEW_LINE DEDENT return 1 << unset_bits NEW_LINE DEDENT
Hyp: 
def countValues ( n ) : NEW_LINE INDENT unset_bits = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT if ( n & 1 ) : NEW_LINE INDENT unset_bits += 1 NEW_LINE DEDENT n = n >> 1 NEW_LINE DEDENT return 1 << unset_bits NEW_LINE DEDENT

BLEU: 82.03
Edit Sim: 10


Src: 
int getOccurence ( int n , int d ) { int result = 0 ; int itr = d ; while ( itr <= n ) { if ( itr % 10 == d ) result ++ ; if ( itr != 0 && itr / 10 == d ) { result ++ ; itr ++ ; } else if ( itr / 10 == d - 1 ) itr = itr + ( 10 - d ) ; else itr = itr + 10 ; } return result ; }
Ref: 
def getOccurence ( n , d ) : NEW_LINE INDENT result = 0 ; NEW_LINE itr = d ; NEW_LINE while ( itr <= n ) : NEW_LINE INDENT if ( itr % 10 == d ) : NEW_LINE INDENT result += 1 ; NEW_LINE DEDENT if ( itr != 0 and math . floor ( itr / 10 ) == d ) : NEW_LINE INDENT result += 1 ; NEW_LINE itr += 1 ; NEW_LINE DEDENT elif ( math . floor ( itr / 10 ) == d - 1 ) : NEW_LINE INDENT itr = itr + ( 10 - d ) ; NEW_LINE DEDENT else : NEW_LINE INDENT itr = itr + 10 ; NEW_LINE DEDENT DEDENT return result ; NEW_LINE DEDENT
Hyp: 
def getOccurence ( n , d ) : NEW_LINE INDENT result = 0 NEW_LINE itr = d NEW_LINE while ( itr <= n ) : NEW_LINE INDENT if ( itr % 10 == d ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT if ( itr != 0 and itr // 10 == d ) : NEW_LINE INDENT result += 1 NEW_LINE itr += 1 NEW_LINE DEDENT elif ( itr // 10 == d - 1 ) : NEW_LINE INDENT itr = itr + ( 10 - d ) NEW_LINE DEDENT else : NEW_LINE INDENT itr = itr + 10 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT

BLEU: 68.22
Edit Sim: 52


Src: 
boolean isPalindrome ( float num ) { String s = String . valueOf ( num ) ; int low = 0 ; int high = s . length ( ) - 1 ; while ( low < high ) { if ( s . charAt ( low ) != s . charAt ( high ) ) return false ; low ++ ; high -- ; } return true ; }
Ref: 
def isPalindrome ( num ) : NEW_LINE INDENT s = str ( num ) NEW_LINE low = 0 NEW_LINE high = len ( s ) - 1 NEW_LINE while ( low < high ) : NEW_LINE INDENT if ( s [ low ] != s [ high ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT low += 1 NEW_LINE high -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT n = 123.321 NEW_LINE if ( isPalindrome ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
Hyp: 
def isPalindrome ( num ) : NEW_LINE INDENT s = str ( num ) NEW_LINE low = 0 NEW_LINE high = len ( s ) - 1 ; NEW_LINE while ( low < high ) : NEW_LINE INDENT if ( s [ low ] != s [ high ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT low += 1 NEW_LINE high -= 1 ; NEW_LINE DEDENT return True NEW_LINE DEDENT num = 72 NEW_LINE if ( isPalindrome ( num ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT

BLEU: 88.58
Edit Sim: 14


Src: 
int countSolutions ( int n ) { int res = 0 ; for ( int x = 0 ; x * x < n ; x ++ ) for ( int y = 0 ; x * x + y * y < n ; y ++ ) res ++ ; return res ; }
Ref: 
def countSolutions ( n ) : NEW_LINE INDENT res = 0 NEW_LINE x = 0 NEW_LINE while ( x * x < n ) : NEW_LINE INDENT y = 0 NEW_LINE while ( x * x + y * y < n ) : NEW_LINE INDENT res = res + 1 NEW_LINE y = y + 1 NEW_LINE DEDENT x = x + 1 NEW_LINE DEDENT return res NEW_LINE DEDENT
Hyp: 
def countSolutions ( n ) : NEW_LINE INDENT res = 0 NEW_LINE for x in range ( n ) : NEW_LINE INDENT for y in range ( n ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT

BLEU: 30.39
Edit Sim: 99


Src: 
int XorSum ( int A [ ] , int B [ ] , int N , int M ) { int ans1 = 0 , ans2 = 0 ; for ( int i = 0 ; i < N ; i ++ ) ans1 = ans1 ^ A [ i ] ; for ( int i = 0 ; i < M ; i ++ ) ans2 = ans2 ^ B [ i ] ; return ( ans1 & ans2 ) ; }
Ref: 
def XorSum ( A , B , N , M ) : NEW_LINE INDENT ans1 = 0 NEW_LINE ans2 = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT ans1 = ans1 ^ A [ i ] NEW_LINE DEDENT for i in range ( M ) : NEW_LINE INDENT ans2 = ans2 ^ B [ i ] NEW_LINE DEDENT return ( ans1 & ans2 ) NEW_LINE DEDENT
Hyp: 
def XorSum ( A , B , N , M ) : NEW_LINE INDENT ans1 = 0 NEW_LINE ans2 = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT ans1 = ans1 ^ A [ i ] NEW_LINE DEDENT for i in range ( M ) : NEW_LINE INDENT ans2 = ans2 ^ B [ i ] NEW_LINE DEDENT return ( ans1 & ans2 ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int minNum ( int n , int k ) { int x = ( int ) ( Math . log ( n ) / Math . log ( k ) ) + 1 ; int mn = ( int ) ( Math . pow ( k , x ) - n ) ; return mn ; }
Ref: 
def minNum ( n , k ) : NEW_LINE INDENT x = int ( ( math . log ( n ) // math . log ( k ) ) ) + 1 NEW_LINE mn = pow ( k , x ) - n NEW_LINE return mn NEW_LINE DEDENT
Hyp: 
def minNum ( n , k ) : NEW_LINE INDENT x = ( int ) ( math . log2 ( n ) / math . log ( k ) ) + 1 NEW_LINE mn = ( int ) ( math . pow ( k , x ) - n ) NEW_LINE return mn NEW_LINE DEDENT

BLEU: 63.45
Edit Sim: 26


Src: 
int uncrossedLines ( int [ ] a , int [ ] b , int n , int m ) { int [ ] [ ] dp = new int [ n + 1 ] [ m + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= m ; j ++ ) { if ( i == 0 j == 0 ) dp [ i ] [ j ] = 0 ; else if ( a [ i - 1 ] == b [ j - 1 ] ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = Math . max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) ; } } return dp [ n ] [ m ] ; }
Ref: 
def uncrossedLines ( a , b , n , m ) : NEW_LINE INDENT dp = [ [ 0 for x in range ( m + 1 ) ] for y in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( m + 1 ) : NEW_LINE INDENT if ( i == 0 or j == 0 ) : NEW_LINE INDENT dp [ i ] [ j ] = 0 NEW_LINE DEDENT elif ( a [ i - 1 ] == b [ j - 1 ] ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ n ] [ m ] NEW_LINE DEDENT
Hyp: 
def uncrossedLines ( a , b , n , m ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( m + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( m + 1 ) : NEW_LINE INDENT if i == 0 or j == 0 : NEW_LINE INDENT dp [ i ] [ j ] = 0 NEW_LINE DEDENT elif a [ i - 1 ] == b [ j - 1 ] : NEW_LINE INDENT dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ n ] [ m ] NEW_LINE DEDENT

BLEU: 91.43
Edit Sim: 10


Src: 
int largestKSubmatrix ( int [ ] [ ] a ) { int [ ] [ ] dp = new int [ Row ] [ Col ] ; int result = 0 ; for ( int i = 0 ; i < Row ; i ++ ) { for ( int j = 0 ; j < Col ; j ++ ) { if ( i == 0 j == 0 ) dp [ i ] [ j ] = 1 ; else { if ( a [ i ] [ j ] == a [ i - 1 ] [ j ] && a [ i ] [ j ] == a [ i ] [ j - 1 ] && a [ i ] [ j ] == a [ i - 1 ] [ j - 1 ] ) { dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] > dp [ i ] [ j - 1 ] && dp [ i - 1 ] [ j ] > dp [ i - 1 ] [ j - 1 ] + 1 ) ? dp [ i - 1 ] [ j ] : ( dp [ i ] [ j - 1 ] > dp [ i - 1 ] [ j ] && dp [ i ] [ j - 1 ] > dp [ i - 1 ] [ j - 1 ] + 1 ) ? dp [ i ] [ j - 1 ] : dp [ i - 1 ] [ j - 1 ] + 1 ; } else dp [ i ] [ j ] = 1 ; } result = result > dp [ i ] [ j ] ? result : dp [ i ] [ j ] ; } } return result ; }
Ref: 
def largestKSubmatrix ( a ) : NEW_LINE INDENT dp = [ [ 0 for x in range ( Row ) ] for y in range ( Col ) ] NEW_LINE result = 0 NEW_LINE for i in range ( Row ) : NEW_LINE INDENT for j in range ( Col ) : NEW_LINE INDENT if ( i == 0 or j == 0 ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( a [ i ] [ j ] == a [ i - 1 ] [ j ] and a [ i ] [ j ] == a [ i ] [ j - 1 ] and a [ i ] [ j ] == a [ i - 1 ] [ j - 1 ] ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) , dp [ i - 1 ] [ j - 1 ] ) + 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = 1 NEW_LINE DEDENT DEDENT result = max ( result , dp [ i ] [ j ] ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
Hyp: 
def largestKSubmatrix ( a ) : NEW_LINE INDENT dp = [ [ 0 for col in range ( Row ) ] for row in range ( Col ) ] NEW_LINE result = 0 NEW_LINE for i in range ( Row ) : NEW_LINE INDENT for j in range ( Col ) : NEW_LINE INDENT if ( i == 0 or j == 0 ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( a [ i ] [ j ] == a [ i - 1 ] [ j ] and a [ i ] [ j ] == a [ i - 1 ] [ j - 1 ] ) : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] > dp [ i ] [ j - 1 ] and dp [ i - 1 ] [ j ] > dp [ i - 1 ] [ j - 1 ] + 1 ) ? dp [ i - 1 ] [ j ] : dp [ i - 1 ] [ j - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = 1 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT

BLEU: 82.66
Edit Sim: 143


Src: 
int CountSetBits ( int n ) { if ( n == 0 ) return 0 ; if ( ( n & 1 ) == 1 ) return 1 + CountSetBits ( n >> 1 ) ; else return CountSetBits ( n >> 1 ) ; }
Ref: 
def CountSetBits ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( ( n & 1 ) == 1 ) : NEW_LINE INDENT return 1 + CountSetBits ( n >> 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT return CountSetBits ( n >> 1 ) ; NEW_LINE DEDENT DEDENT
Hyp: 
def CountSetBits ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n & 1 ) : NEW_LINE INDENT return 1 + CountSetBits ( n >> 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return CountSetBits ( n >> 1 ) NEW_LINE DEDENT DEDENT

BLEU: 78.65
Edit Sim: 15


Src: 
int maxValue ( int n ) { if ( n == 1 ) return 0 ; return ( ( n * n / 2 ) - 1 ) ; }
Ref: 
def maxValue ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( ( n * n // 2 ) - 1 ) NEW_LINE DEDENT
Hyp: 
def maxValue ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return ( ( n * n / 2 ) - 1 ) NEW_LINE DEDENT

BLEU: 85.0
Edit Sim: 2


Src: 
int sumOfMinAbsDifferences ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int sum = 0 ; sum += Math . abs ( arr [ 0 ] - arr [ 1 ] ) ; sum += Math . abs ( arr [ n - 1 ] - arr [ n - 2 ] ) ; for ( int i = 1 ; i < n - 1 ; i ++ ) sum += Math . min ( Math . abs ( arr [ i ] - arr [ i - 1 ] ) , Math . abs ( arr [ i ] - arr [ i + 1 ] ) ) ; return sum ; }
Ref: 
def sumOfMinAbsDifferences ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE sum = 0 NEW_LINE sum += abs ( arr [ 0 ] - arr [ 1 ] ) ; NEW_LINE sum += abs ( arr [ n - 1 ] - arr [ n - 2 ] ) ; NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT sum += min ( abs ( arr [ i ] - arr [ i - 1 ] ) , abs ( arr [ i ] - arr [ i + 1 ] ) ) NEW_LINE DEDENT return sum ; NEW_LINE DEDENT
Hyp: 
def sumOfMinAbsDifferences ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE sum = 0 NEW_LINE sum += abs ( arr [ 0 ] - arr [ 1 ] ) NEW_LINE sum += abs ( arr [ n - 1 ] - arr [ n - 2 ] ) NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT sum += min ( abs ( arr [ i ] - arr [ i - 1 ] ) , abs ( arr [ i ] - arr [ i + 1 ] ) ) NEW_LINE DEDENT return sum NEW_LINE DEDENT

BLEU: 93.35
Edit Sim: 6


Src: 
int nCr ( int n , int r ) { int res = 1 ; if ( r > n - r ) r = n - r ; for ( int i = 0 ; i < r ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; }
Ref: 
def nCr ( n , r ) : NEW_LINE INDENT res = 1 NEW_LINE if ( r > n - r ) : NEW_LINE INDENT r = n - r NEW_LINE DEDENT for i in range ( r ) : NEW_LINE INDENT res *= ( n - i ) NEW_LINE res //= ( i + 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT
Hyp: 
def nCr ( n , r ) : NEW_LINE INDENT res = 1 NEW_LINE if ( r > n - r ) : NEW_LINE INDENT r = n - r NEW_LINE DEDENT for i in range ( r ) : NEW_LINE INDENT res *= ( n - i ) NEW_LINE res //= ( i + 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
boolean is_possible ( int x , int y ) { if ( x < 2 && y != 0 ) return false ; y = y - x + 1 ; if ( y % 2 == 0 && y >= 0 ) return true ; else return false ; }
Ref: 
def is_possible ( x , y ) : NEW_LINE INDENT if ( x < 2 and y != 0 ) : NEW_LINE INDENT return false NEW_LINE DEDENT y = y - x + 1 NEW_LINE if ( y % 2 == 0 and y >= 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
Hyp: 
def is_possible ( x , y ) : NEW_LINE INDENT if ( x < 2 and y != 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT y = y - x + 1 ; NEW_LINE if ( y % 2 == 0 and y >= 0 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT else : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT

BLEU: 83.04
Edit Sim: 11


Src: 
int changeTheArray ( int arr [ ] , int n ) { int minEle = Arrays . stream ( arr ) . min ( ) . getAsInt ( ) ; int maxEle = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; int minOperations = Integer . MAX_VALUE ; for ( int num = minEle ; num <= maxEle ; num ++ ) { int operations = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != num ) { operations += ( Math . abs ( num - arr [ i ] ) - 1 ) ; } } minOperations = Math . min ( minOperations , operations ) ; } return minOperations ; }
Ref: 
def changeTheArray ( arr , n ) : NEW_LINE INDENT minEle = min ( arr ) NEW_LINE maxEle = max ( arr ) NEW_LINE minOperations = sys . maxsize NEW_LINE for num in range ( minEle , maxEle + 1 ) : NEW_LINE INDENT operations = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] != num : NEW_LINE INDENT operations += ( abs ( num - arr [ i ] ) - 1 ) NEW_LINE DEDENT DEDENT minOperations = min ( minOperations , operations ) NEW_LINE DEDENT return minOperations NEW_LINE DEDENT
Hyp: 
def changeTheArray ( arr , n ) : NEW_LINE INDENT minEle = min ( arr ) ; NEW_LINE maxEle = max ( arr ) ; NEW_LINE minOperations = INT_MAX ; NEW_LINE for num in range ( minEle , maxEle + 1 ) : NEW_LINE INDENT operations = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] != num ) : NEW_LINE INDENT operations += ( abs ( num - arr [ i ] ) - 1 ) ; NEW_LINE DEDENT DEDENT minOperations = min ( minOperations , operations ) ; NEW_LINE DEDENT return minOperations ; NEW_LINE DEDENT

BLEU: 77.51
Edit Sim: 29


Src: 
void printAlter ( int [ ] arr , int N ) { for ( int currIndex = 0 ; currIndex < N ; currIndex ++ ) { if ( currIndex % 2 == 0 ) { System . out . print ( arr [ currIndex ] + " ▁ " ) ; } } }
Ref: 
def printAlter ( arr , N ) : NEW_LINE INDENT for currIndex in range ( 0 , N ) : NEW_LINE INDENT if ( currIndex % 2 == 0 ) : NEW_LINE INDENT print ( arr [ currIndex ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
Hyp: 
def printAlter ( arr , N ) : NEW_LINE INDENT for currIndex in range ( N ) : NEW_LINE INDENT if ( currIndex % 2 == 0 ) : NEW_LINE INDENT print ( str ( arr [ currIndex ] ) , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT

BLEU: 86.26
Edit Sim: 12


Src: 
int xor_operations ( int N , int arr [ ] , int M , int K ) { if ( M < 0 M >= N ) return - 1 ; if ( K < 0 K >= N - M ) return - 1 ; for ( int p = 0 ; p < M ; p ++ ) { Vector < Integer > temp = new Vector < Integer > ( ) ; for ( int i = 0 ; i < N - 1 ; i ++ ) { int value = arr [ i ] ^ arr [ i + 1 ] ; temp . add ( value ) ; arr [ i ] = temp . get ( i ) ; } } int ans = arr [ K ] ; return ans ; }
Ref: 
def xor_operations ( N , arr , M , K ) : NEW_LINE INDENT if M < 0 or M >= N : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if K < 0 or K >= N - M : NEW_LINE INDENT return - 1 NEW_LINE DEDENT for _ in range ( M ) : NEW_LINE INDENT temp = [ ] NEW_LINE for i in range ( len ( arr ) - 1 ) : NEW_LINE INDENT value = arr [ i ] ^ arr [ i + 1 ] NEW_LINE temp . append ( value ) NEW_LINE DEDENT arr = temp [ : ] NEW_LINE DEDENT ans = arr [ K ] NEW_LINE return ans NEW_LINE DEDENT
Hyp: 
def xor_operations ( N , arr , M , K ) : NEW_LINE INDENT if ( M < 0 or M >= N ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( K < 0 or K >= N - M ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT for p in range ( M ) : NEW_LINE INDENT temp = [ ] NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT value = arr [ i ] ^ arr [ i + 1 ] NEW_LINE temp . add ( value ) NEW_LINE arr [ i ] = temp [ i ] NEW_LINE DEDENT DEDENT ans = arr [ K ] NEW_LINE return ans NEW_LINE DEDENT

BLEU: 77.82
Edit Sim: 41


Src: 
int steps ( int N , int M ) { if ( N == 1 ) return 0 ; return M ; return 2 * M + ( N - 3 ) ; }
Ref: 
def steps ( N , M ) : NEW_LINE INDENT if ( N == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( N == 2 ) : NEW_LINE INDENT return M NEW_LINE DEDENT return 2 * M + ( N - 3 ) NEW_LINE DEDENT
Hyp: 
def steps ( N , M ) : NEW_LINE INDENT if ( N == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return M NEW_LINE 2 * M + ( N - 3 ) NEW_LINE DEDENT

BLEU: 68.87
Edit Sim: 48


Src: 
void encrypt ( char input [ ] ) { char evenPos = ' @ ' , oddPos = ' ! ' ; int repeat , ascii ; for ( int i = 0 ; i < input . length ; i ++ ) { ascii = input [ i ] ; repeat = ascii >= 97 ? ascii - 96 : ascii - 64 ; for ( int j = 0 ; j < repeat ; j ++ ) { if ( i % 2 == 0 ) System . out . printf ( " % c " , oddPos ) ; else System . out . printf ( " % c " , evenPos ) ; } } }
Ref: 
def encrypt ( input_arr ) : NEW_LINE INDENT evenPos = ' @ ' ; oddPos = ' ! ' ; NEW_LINE for i in range ( len ( input_arr ) ) : NEW_LINE INDENT ascii = ord ( input_arr [ i ] ) ; NEW_LINE repeat = ( ascii - 96 ) if ascii >= 97 else ( ascii - 64 ) ; NEW_LINE for j in range ( repeat ) : NEW_LINE DEDENT if ( i % 2 == 0 ) : NEW_LINE INDENT print ( oddPos , end = " " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( evenPos , end = " " ) ; NEW_LINE DEDENT DEDENT
Hyp: 
def encrypt ( input ) : NEW_LINE INDENT evenPos = ' @ ' ; oddPos = ' ! ' ; NEW_LINE for i in range ( len ( input ) ) : NEW_LINE INDENT ascii = input [ i ] ; NEW_LINE repeat = ascii - 97 ; NEW_LINE for j in range ( repeat ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT print ( " % c " , oddPos ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " % c " , evenPos ) ; NEW_LINE DEDENT DEDENT DEDENT

BLEU: 60.57
Edit Sim: 98


Src: 
boolean search ( int arr [ ] , int n , int x ) { int front = 0 , back = n - 1 ; while ( front <= back ) { if ( arr [ front ] == x arr [ back ] == x ) return true ; front ++ ; back -- ; } return false ; }
Ref: 
def search ( arr , n , x ) : NEW_LINE INDENT front = 0 ; back = n - 1 NEW_LINE while ( front <= back ) : NEW_LINE INDENT if ( arr [ front ] == x or arr [ back ] == x ) : NEW_LINE INDENT return True NEW_LINE DEDENT front += 1 NEW_LINE back -= 1 NEW_LINE DEDENT return False NEW_LINE DEDENT arr = [ 10 , 20 , 80 , 30 , 60 , 50 , 110 , 100 , 130 , 170 ] NEW_LINE x = 130 NEW_LINE n = len ( arr ) NEW_LINE if ( search ( arr , n , x ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
Hyp: 
def search ( arr , n , x ) : NEW_LINE INDENT front = 0 NEW_LINE back = n - 1 NEW_LINE while ( front <= back ) : NEW_LINE INDENT if ( arr [ front ] == x or arr [ back ] == x ) : NEW_LINE INDENT return True NEW_LINE DEDENT front = front + 1 NEW_LINE back = back - 1 NEW_LINE DEDENT return False NEW_LINE DEDENT arr = [ 2 , 3 , 4 , 8 , 7 ] NEW_LINE if ( search ( arr , n , x ) ) : NEW_LINE INDENT print ( " Element ▁ is ▁ not ▁ present ▁ in ▁ array " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Element ▁ is ▁ present ▁ in ▁ array " ) NEW_LINE DEDENT

BLEU: 67.5
Edit Sim: 170


Src: 
String isEvenOrOdd ( int L , int R ) { int oddCount = ( R - L ) / 2 ; if ( R % 2 == 1 L % 2 == 1 ) oddCount ++ ; if ( oddCount % 2 == 0 ) return " Even " ; else return " Odd " ; }
Ref: 
def isEvenOrOdd ( L , R ) : NEW_LINE INDENT oddCount = ( R - L ) / 2 NEW_LINE if ( R % 2 == 1 or L % 2 == 1 ) : NEW_LINE INDENT oddCount = oddCount + 1 NEW_LINE DEDENT if ( oddCount % 2 == 0 ) : NEW_LINE INDENT return " Even " NEW_LINE DEDENT else : NEW_LINE INDENT return " Odd " NEW_LINE DEDENT DEDENT
Hyp: 
def isEvenOrOdd ( L , R ) : NEW_LINE INDENT oddCount = ( R - L ) // 2 NEW_LINE if ( R % 2 == 1 or L % 2 == 1 ) : NEW_LINE INDENT oddCount = oddCount + 1 NEW_LINE DEDENT if ( oddCount % 2 == 0 ) : NEW_LINE INDENT return " Even " NEW_LINE DEDENT else : NEW_LINE INDENT return " Odd " NEW_LINE DEDENT DEDENT

BLEU: 96.46
Edit Sim: 1


Src: 
void countDigit ( int arr [ ] [ ] ) { for ( int i = 0 ; i < M ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { int X = arr [ i ] [ j ] ; int d = ( int ) ( Math . floor ( Math . log10 ( X ) * 1.0 ) + 1 ) ; System . out . print ( d + " ▁ " ) ; } System . out . println ( ) ; } }
Ref: 
def countDigit ( arr ) : NEW_LINE INDENT for i in range ( M ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT X = arr [ i ] [ j ] NEW_LINE d = floor ( log10 ( X ) * 1.0 ) + 1 NEW_LINE print ( d , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT
Hyp: 
def countDigit ( arr , row ) : NEW_LINE INDENT for i in range ( M ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT X = arr [ i ] [ j ] NEW_LINE d = ( int ) ( math . floor ( math . log10 ( X ) * 1.0 ) + 1 ) NEW_LINE print ( d , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT

BLEU: 78.93
Edit Sim: 32


Src: 
String canMake ( String s ) { int o = 0 , z = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) - '0' == 1 ) o ++ ; else z ++ ; } if ( o % 2 == 1 && z % 2 == 1 ) return " NO " ; else return " YES " ; }
Ref: 
def canMake ( s ) : NEW_LINE INDENT o = 0 ; z = 0 ; NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( ord ( s [ i ] ) - ord ( '0' ) == 1 ) : NEW_LINE INDENT o += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT z += 1 ; NEW_LINE DEDENT DEDENT if ( o % 2 == 1 and z % 2 == 1 ) : NEW_LINE INDENT return " NO " ; NEW_LINE DEDENT else : NEW_LINE INDENT return " YES " ; NEW_LINE DEDENT DEDENT
Hyp: 
def canMake ( s ) : NEW_LINE INDENT o = 0 NEW_LINE z = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( ord ( s [ i ] ) - ord ( '0' ) == 1 ) : NEW_LINE INDENT o += 1 NEW_LINE DEDENT else : NEW_LINE INDENT z += 1 NEW_LINE DEDENT DEDENT if ( o % 2 == 1 and z % 2 == 1 ) : NEW_LINE INDENT return " NO " NEW_LINE DEDENT else : NEW_LINE INDENT return " YES " NEW_LINE DEDENT DEDENT

BLEU: 84.94
Edit Sim: 18


Src: 
int xorPairSum ( int ar [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum ^ ar [ i ] ; return 2 * sum ; }
Ref: 
def xor_pair_sum ( ar , n ) : NEW_LINE INDENT total = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT total = total ^ ar [ i ] NEW_LINE DEDENT return 2 * total NEW_LINE DEDENT
Hyp: 
def xorPairSum ( ar , n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = sum ^ ar [ i ] ; NEW_LINE DEDENT return 2 * sum ; NEW_LINE DEDENT

BLEU: 59.16
Edit Sim: 28


Src: 
int getQuadrant ( int X , int Y , int R , int PX , int PY ) { if ( PX == X && PY == Y ) return 0 ; int val = ( int ) Math . pow ( ( PX - X ) , 2 ) + ( int ) Math . pow ( ( PY - Y ) , 2 ) ; if ( val > Math . pow ( R , 2 ) ) return - 1 ; if ( PX > X && PY >= Y ) return 1 ; if ( PX <= X && PY > Y ) return 2 ; if ( PX < X && PY <= Y ) return 3 ; if ( PX >= X && PY < Y ) return 4 ; return 0 ; }
Ref: 
def getQuadrant ( X , Y , R , PX , PY ) : NEW_LINE INDENT if ( PX == X and PY == Y ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT val = ( math . pow ( ( PX - X ) , 2 ) + math . pow ( ( PY - Y ) , 2 ) ) ; NEW_LINE if ( val > pow ( R , 2 ) ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT if ( PX > X and PY >= Y ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT if ( PX <= X and PY > Y ) : NEW_LINE INDENT return 2 ; NEW_LINE DEDENT if ( PX < X and PY <= Y ) : NEW_LINE INDENT return 3 ; NEW_LINE DEDENT if ( PX >= X and PY < Y ) : NEW_LINE INDENT return 4 ; NEW_LINE DEDENT DEDENT
Hyp: 
def getQuadrant ( X , Y , R , PX , PY ) : NEW_LINE INDENT if ( PX == X and PY == Y ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT val = ( pow ( PX - X ) , 2 ) + pow ( ( PY - Y ) , 2 ) ) NEW_LINE if ( val > pow ( R , 2 ) ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( PX > X and PY >= Y ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( PX <= X and PY > Y ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT if ( PX < X and PY <= Y ) : NEW_LINE INDENT return 3 NEW_LINE DEDENT if ( PX >= X and PY < Y ) : NEW_LINE INDENT return 4 NEW_LINE DEDENT return 0 NEW_LINE DEDENT

BLEU: 82.72
Edit Sim: 48


Src: 
int countSubStr ( char str [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == '1' ) m ++ ; } return m * ( m - 1 ) / 2 ; }
Ref: 
def countSubStr ( st , n ) : NEW_LINE INDENT m = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( st [ i ] == '1' ) : NEW_LINE INDENT m = m + 1 NEW_LINE DEDENT DEDENT return m * ( m - 1 ) // 2 NEW_LINE DEDENT
Hyp: 
def countSubStr ( Str1 , n ) : NEW_LINE INDENT m = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( Str1 [ i ] == '1' ) : NEW_LINE INDENT m += 1 NEW_LINE DEDENT DEDENT return m * ( m - 1 ) // 2 NEW_LINE DEDENT

BLEU: 76.64
Edit Sim: 15


Src: 
int getMinSquares ( int n ) { if ( n <= 3 ) return n ; int res = n ; for ( int x = 1 ; x <= n ; x ++ ) { int temp = x * x ; if ( temp > n ) break ; else res = Math . min ( res , 1 + getMinSquares ( n - temp ) ) ; } return res ; }
Ref: 
def getMinSquares ( n ) : NEW_LINE INDENT if n <= 3 : NEW_LINE INDENT return n ; NEW_LINE DEDENT res = n NEW_LINE for x in range ( 1 , n + 1 ) : NEW_LINE INDENT temp = x * x ; NEW_LINE if temp > n : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT res = min ( res , 1 + getMinSquares ( n - temp ) ) NEW_LINE DEDENT DEDENT return res ; NEW_LINE DEDENT
Hyp: 
def getMinSquares ( n ) : NEW_LINE INDENT if ( n <= 3 ) : NEW_LINE INDENT return n NEW_LINE DEDENT res = n NEW_LINE for x in range ( 1 , n + 1 ) : NEW_LINE INDENT temp = x * x NEW_LINE if ( temp > n ) : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT res = min ( res , 1 + getMinSquares ( n - temp ) ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT

BLEU: 82.43
Edit Sim: 14


Src: 
int sumofseries ( int n ) { int res = 0 ; for ( int i = 1 ; i <= n ; i ++ ) res += ( i ) * ( i + 1 ) * ( i + 2 ) ; return res ; }
Ref: 
def sumofseries ( n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT res += ( i ) * ( i + 1 ) * ( i + 2 ) NEW_LINE DEDENT return res NEW_LINE DEDENT
Hyp: 
def sumofseries ( n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT res += ( i ) * ( i + 1 ) * ( i + 2 ) NEW_LINE DEDENT return res NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
void findElements ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) if ( arr [ j ] > arr [ i ] ) count ++ ; if ( count >= 2 ) System . out . print ( arr [ i ] + " ▁ " ) ; } }
Ref: 
def findElements ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT if arr [ j ] > arr [ i ] : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT if count >= 2 : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
Hyp: 
def findElements ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ j ] > arr [ i ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( count >= 2 ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT

BLEU: 80.54
Edit Sim: 21


Src: 
int removals ( int arr [ ] , int n , int k ) { Arrays . sort ( arr ) ; int dp [ ] = new int [ n ] ; Arrays . fill ( dp , - 1 ) ; int ans = n - 1 ; dp [ 0 ] = 0 ; for ( int i = 1 ; i < n ; i ++ ) { dp [ i ] = i ; int j = dp [ i - 1 ] ; while ( j != i && arr [ i ] - arr [ j ] > k ) { j ++ ; } dp [ i ] = Integer . min ( dp [ i ] , j ) ; ans = Integer . min ( ans , ( n - ( i - j + 1 ) ) ) ; } return ans ; }
Ref: 
def removals ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE dp = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp [ i ] = - 1 NEW_LINE DEDENT ans = n - 1 NEW_LINE dp [ 0 ] = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT dp [ i ] = i NEW_LINE j = dp [ i - 1 ] NEW_LINE while ( j != i and arr [ i ] - arr [ j ] > k ) : NEW_LINE j += 1 NEW_LINE dp [ i ] = min ( dp [ i ] , j ) NEW_LINE ans = min ( ans , ( n - ( i - j + 1 ) ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
Hyp: 
def removals ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE dp = [ 0 ] * n NEW_LINE ans = n - 1 NEW_LINE dp [ 0 ] = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT dp [ i ] = i NEW_LINE j = dp [ i - 1 ] NEW_LINE while ( j != i and arr [ i ] - arr [ j ] > k ) : NEW_LINE j += 1 NEW_LINE DEDENT dp [ i ] = min ( dp [ i ] , j ) NEW_LINE ans = min ( ans , ( n - ( i - j + 1 ) ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT

BLEU: 79.66
Edit Sim: 95


Src: 
int evenSum ( int n ) { return ( n * ( n + 1 ) ) ; }
Ref: 
def evensum ( n ) : NEW_LINE INDENT return n * ( n + 1 ) NEW_LINE DEDENT
Hyp: 
def evenSum ( n ) : NEW_LINE INDENT return ( n * ( n + 1 ) ) ; NEW_LINE DEDENT

BLEU: 61.4
Edit Sim: 7


Src: 
double findAverage ( int N ) { double avg = ( ( 6 * N * N * N * N ) + ( 15 * N * N * N ) + ( 10 * N * N ) - 1 ) / 30.0 ; return avg ; }
Ref: 
def findAverage ( N ) : NEW_LINE INDENT avg = ( ( 6 * N * N * N * N ) + ( 15 * N * N * N ) + ( 10 * N * N ) - 1 ) / 30 NEW_LINE return avg NEW_LINE DEDENT
Hyp: 
def findAverage ( N ) : NEW_LINE INDENT avg = ( ( 6 * N * N * N * N ) + ( 15 * N * N ) + ( 10 * N * N ) - 1 ) / 30.0 NEW_LINE return avg NEW_LINE DEDENT

BLEU: 90.78
Edit Sim: 6


Src: 
int findMaximum ( int arr [ ] , int low , int high ) { if ( low == high ) return arr [ low ] ; if ( ( high == low + 1 ) && arr [ low ] >= arr [ high ] ) return arr [ low ] ; if ( ( high == low + 1 ) && arr [ low ] < arr [ high ] ) return arr [ high ] ; int mid = ( low + high ) / 2 ; if ( arr [ mid ] > arr [ mid + 1 ] && arr [ mid ] > arr [ mid - 1 ] ) return arr [ mid ] ; if ( arr [ mid ] > arr [ mid + 1 ] && arr [ mid ] < arr [ mid - 1 ] ) return findMaximum ( arr , low , mid - 1 ) ; else return findMaximum ( arr , mid + 1 , high ) ; }
Ref: 
def findMaximum ( arr , low , high ) : NEW_LINE INDENT if low == high : NEW_LINE INDENT return arr [ low ] NEW_LINE DEDENT if high == low + 1 and arr [ low ] >= arr [ high ] : NEW_LINE INDENT return arr [ low ] ; NEW_LINE DEDENT if high == low + 1 and arr [ low ] < arr [ high ] : NEW_LINE INDENT return arr [ high ] NEW_LINE DEDENT mid = ( low + high ) // 2 NEW_LINE if arr [ mid ] > arr [ mid + 1 ] and arr [ mid ] > arr [ mid - 1 ] : NEW_LINE INDENT return arr [ mid ] NEW_LINE DEDENT if arr [ mid ] > arr [ mid + 1 ] and arr [ mid ] < arr [ mid - 1 ] : NEW_LINE INDENT return findMaximum ( arr , low , mid - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return findMaximum ( arr , mid + 1 , high ) NEW_LINE DEDENT DEDENT
Hyp: 
def findMaximum ( arr , low , high ) : NEW_LINE INDENT if ( low == high ) : NEW_LINE INDENT return arr [ low ] NEW_LINE DEDENT if ( ( high == low + 1 ) and arr [ low ] >= arr [ high ] ) : NEW_LINE INDENT return arr [ low ] NEW_LINE DEDENT if ( ( high == low + 1 ) and arr [ low ] < arr [ high ] ) : NEW_LINE INDENT return arr [ high ] NEW_LINE DEDENT mid = ( low + high ) // 2 NEW_LINE if ( arr [ mid ] > arr [ mid + 1 ] and arr [ mid ] > arr [ mid - 1 ] ) : NEW_LINE INDENT return arr [ mid ] NEW_LINE DEDENT if ( arr [ mid ] > arr [ mid + 1 ] and arr [ mid ] < arr [ mid - 1 ] ) : NEW_LINE INDENT return findMaximum ( arr , low , mid - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return findMaximum ( arr , mid + 1 , high ) NEW_LINE DEDENT DEDENT

BLEU: 82.29
Edit Sim: 30


Src: 
int maxLevel ( int [ ] boxes , int n ) { Arrays . sort ( boxes ) ; int prev_width = boxes [ 0 ] ; int prev_count = 1 ; int curr_count = 0 ; int curr_width = 0 ; for ( int i = 1 ; i < n ; i ++ ) { curr_width += boxes [ i ] ; curr_count += 1 ; if ( curr_width > prev_width && curr_count > prev_count ) { prev_width = curr_width ; prev_count = curr_count ; curr_count = 0 ; curr_width = 0 ; ans ++ ; } } return ans ; }
Ref: 
def maxLevel ( boxes , n ) : NEW_LINE INDENT boxes . sort ( ) NEW_LINE prev_width = boxes [ 0 ] NEW_LINE prev_count = 1 NEW_LINE curr_count = 0 NEW_LINE curr_width = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT curr_width += boxes [ i ] NEW_LINE curr_count += 1 NEW_LINE if ( curr_width > prev_width and curr_count > prev_count ) : NEW_LINE INDENT prev_width = curr_width NEW_LINE prev_count = curr_count NEW_LINE curr_count = 0 NEW_LINE curr_width = 0 NEW_LINE ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
Hyp: 
def maxLevel ( boxes , n ) : NEW_LINE INDENT boxes . sort ( ) NEW_LINE prev_width = boxes [ 0 ] NEW_LINE prev_count = 1 NEW_LINE curr_count = 0 NEW_LINE curr_width = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT curr_width += boxes [ i ] NEW_LINE curr_count += 1 NEW_LINE if ( curr_width > prev_width and curr_count > prev_count ) : NEW_LINE INDENT prev_width = curr_width NEW_LINE prev_count = curr_count NEW_LINE curr_count = 0 NEW_LINE curr_width = 0 NEW_LINE ans = 0 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT

BLEU: 96.35
Edit Sim: 2


Src: 
int Division ( int a [ ] , int n ) { int maxi = Integer . MIN_VALUE , mini = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { maxi = Math . max ( a [ i ] , maxi ) ; mini = Math . min ( a [ i ] , mini ) ; } return maxi / mini ; }
Ref: 
def Division ( a , n ) : NEW_LINE INDENT maxi = - 10 ** 9 NEW_LINE mini = 10 ** 9 NEW_LINE for i in a : NEW_LINE INDENT maxi = max ( i , maxi ) NEW_LINE mini = min ( i , mini ) NEW_LINE DEDENT return maxi // mini NEW_LINE DEDENT
Hyp: 
def Division ( a , n ) : NEW_LINE INDENT maxi = - 2147483648 NEW_LINE mini = + 2147483647 NEW_LINE for i in range ( n ) : NEW_LINE INDENT maxi = max ( a [ i ] , maxi ) NEW_LINE mini = min ( a [ i ] , mini ) NEW_LINE DEDENT return maxi // mini NEW_LINE DEDENT

BLEU: 62.79
Edit Sim: 42


Src: 
int findLen ( int [ ] arr , int i , int curr , int n , int m ) { if ( i == n ) { if ( curr == 0 ) return 0 ; else return - 1 ; } if ( v [ i ] [ curr ] ) return dp [ i ] [ curr ] ; v [ i ] [ curr ] = true ; int l = findLen ( arr , i + 1 , curr , n , m ) ; int r = findLen ( arr , i + 1 , ( curr + arr [ i ] ) % m , n , m ) ; dp [ i ] [ curr ] = l ; if ( r != - 1 ) dp [ i ] [ curr ] = Math . max ( dp [ i ] [ curr ] , r + 1 ) ; return dp [ i ] [ curr ] ; }
Ref: 
def findLen ( arr , i , curr , n , m ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT if ( not curr ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT DEDENT if ( v [ i ] [ curr ] ) : NEW_LINE INDENT return dp [ i ] [ curr ] ; NEW_LINE DEDENT v [ i ] [ curr ] = 1 ; NEW_LINE l = findLen ( arr , i + 1 , curr , n , m ) ; NEW_LINE r = findLen ( arr , i + 1 , ( curr + arr [ i ] ) % m , n , m ) ; NEW_LINE dp [ i ] [ curr ] = l ; NEW_LINE if ( r != - 1 ) : NEW_LINE INDENT dp [ i ] [ curr ] = max ( dp [ i ] [ curr ] , r + 1 ) ; NEW_LINE DEDENT return dp [ i ] [ curr ] ; NEW_LINE DEDENT
Hyp: 
def findLen ( arr , i , curr , n , m ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT if ( curr == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT DEDENT if ( v [ i ] [ curr ] ) : NEW_LINE INDENT return dp [ i ] [ curr ] ; NEW_LINE DEDENT l = findLen ( arr , i + 1 , curr , n , m ) ; NEW_LINE r = findLen ( arr , i + 1 , ( curr + arr [ i ] ) % m , n , m ) ; NEW_LINE dp [ i ] [ curr ] = l ; NEW_LINE if ( r != - 1 ) : NEW_LINE INDENT dp [ i ] [ curr ] = max ( dp [ i ] [ curr ] , r + 1 ) ; NEW_LINE DEDENT return dp [ i ] [ curr ] ; NEW_LINE DEDENT

BLEU: 91.36
Edit Sim: 40


Src: 
void solve ( int n ) { int ans = 0 ; for ( int y = n + 1 ; y <= n * n + n ; y ++ ) { if ( ( n * n ) % ( y - n ) == 0 ) { ans += 1 ; } } System . out . print ( ans ) ; }
Ref: 
def solve ( n ) : NEW_LINE INDENT ans = 0 NEW_LINE y = n + 1 NEW_LINE while ( y <= n * n + n ) : NEW_LINE INDENT if ( ( n * n ) % ( y - n ) == 0 ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT y += 1 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
Hyp: 
def solve ( n ) : NEW_LINE INDENT ans = 0 NEW_LINE for y in range ( n + 1 , n * n + n + 1 ) : NEW_LINE INDENT if ( ( n * n ) % ( y - n ) == 0 ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT

BLEU: 74.47
Edit Sim: 42


Src: 
void minAtEachIndex ( int n , int arr [ ] ) { int dp1 [ ] = new int [ n ] ; int dp2 [ ] = new int [ n ] ; int i ; dp1 [ 0 ] = arr [ 0 ] ; for ( i = 1 ; i < n ; i ++ ) dp1 [ i ] = Math . min ( arr [ i ] , dp1 [ i - 1 ] + 1 ) ; dp2 [ n - 1 ] = arr [ n - 1 ] ; for ( i = n - 2 ; i >= 0 ; i -- ) dp2 [ i ] = Math . min ( arr [ i ] , dp2 [ i + 1 ] + 1 ) ; ArrayList < Integer > v = new ArrayList < Integer > ( ) ; for ( i = 0 ; i < n ; i ++ ) v . add ( Math . min ( dp1 [ i ] , dp2 [ i ] ) ) ; for ( int x : v ) System . out . print ( x + " ▁ " ) ; }
Ref: 
def minAtEachIndex ( n , arr ) : NEW_LINE INDENT dp1 = [ 0 ] * n NEW_LINE dp2 = [ 0 ] * n NEW_LINE i = 0 NEW_LINE dp1 [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT dp1 [ i ] = min ( arr [ i ] , dp1 [ i - 1 ] + 1 ) NEW_LINE DEDENT dp2 [ n - 1 ] = arr [ n - 1 ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT dp2 [ i ] = min ( arr [ i ] , dp2 [ i + 1 ] + 1 ) NEW_LINE DEDENT v = [ ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT v . append ( min ( dp1 [ i ] , dp2 [ i ] ) ) NEW_LINE DEDENT for x in v : NEW_LINE INDENT print ( x , end = " ▁ " ) NEW_LINE DEDENT DEDENT
Hyp: 
def minAtEachIndex ( n , arr ) : NEW_LINE INDENT dp1 = [ 0 ] * n NEW_LINE dp2 = [ 0 ] * n NEW_LINE dp1 [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT dp1 [ i ] = min ( arr [ i ] , dp1 [ i - 1 ] + 1 ) NEW_LINE dp2 [ n - 1 ] = arr [ n - 1 ] NEW_LINE i = n - 2 NEW_LINE while i >= 0 : NEW_LINE INDENT dp2 [ i ] = min ( arr [ i ] , dp2 [ i + 1 ] + 1 ) NEW_LINE DEDENT i = 0 NEW_LINE while i < n : NEW_LINE INDENT v . append ( min ( dp1 [ i ] , dp2 [ i ] ) ) NEW_LINE i = i + 1 NEW_LINE DEDENT print ( * v ) NEW_LINE DEDENT

BLEU: 71.8
Edit Sim: 109


Src: 
boolean findPattern ( int n ) { int prev = n % 2 ; n = n / 2 ; while ( n > 0 ) { int curr = n % 2 ; if ( curr == prev ) return false ; prev = curr ; n = n / 2 ; } return true ; }
Ref: 
def findPattern ( n ) : NEW_LINE INDENT prev = n % 2 NEW_LINE n = n // 2 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT curr = n % 2 NEW_LINE if ( curr == prev ) : NEW_LINE INDENT return False NEW_LINE DEDENT prev = curr NEW_LINE n = n // 2 NEW_LINE DEDENT return True NEW_LINE DEDENT
Hyp: 
def findPattern ( n ) : NEW_LINE INDENT prev = n % 2 NEW_LINE n = n // 2 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT curr = n % 2 NEW_LINE if ( curr == prev ) : NEW_LINE INDENT return False NEW_LINE DEDENT prev = curr NEW_LINE n = n // 2 NEW_LINE DEDENT return True NEW_LINE DEDENT n = 18 NEW_LINE if ( findPattern ( n ) ) : NEW_LINE INDENT print ( n , end = ' ▁ ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n , end = ' ▁ ' ) NEW_LINE DEDENT

BLEU: 59.8
Edit Sim: 166


Src: 
boolean canBeEqual ( int a , int b , int c , int k ) { int [ ] arr = new int [ 3 ] ; arr [ 0 ] = a ; arr [ 1 ] = b ; arr [ 2 ] = c ; Arrays . sort ( arr ) ; int diff = 2 * arr [ 2 ] - arr [ 1 ] - arr [ 0 ] ; k = k - diff ; if ( k < 0 k % 3 != 0 ) return false ; return true ; }
Ref: 
def canBeEqual ( a , b , c , k ) : NEW_LINE INDENT arr = [ 0 ] * 3 ; NEW_LINE arr [ 0 ] = a ; NEW_LINE arr [ 1 ] = b ; NEW_LINE arr [ 2 ] = c ; NEW_LINE arr . sort ( ) NEW_LINE diff = 2 * arr [ 2 ] - arr [ 1 ] - arr [ 0 ] ; NEW_LINE k = k - diff ; NEW_LINE if ( k < 0 or k % 3 != 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT return True ; NEW_LINE DEDENT
Hyp: 
def canBeEqual ( a , b , c , k ) : NEW_LINE INDENT arr = [ 0 for i in range ( 3 ) ] NEW_LINE arr [ 0 ] = a NEW_LINE arr [ 1 ] = b NEW_LINE arr [ 2 ] = c NEW_LINE arr . sort ( ) NEW_LINE diff = 2 * arr [ 2 ] - arr [ 1 ] - arr [ 0 ] NEW_LINE k = k - diff NEW_LINE if ( k < 0 or k % 3 != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT a = 1 NEW_LINE b = 2 NEW_LINE c = 2 NEW_LINE k = k - diff NEW_LINE if ( canBeEqual ( a , b , c , k ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT

BLEU: 52.47
Edit Sim: 240


Src: 
int countOfBinaryNumberLessThanN ( int N ) { Queue < Integer > q = new LinkedList < > ( ) ; q . add ( 1 ) ; int cnt = 0 ; int t ; while ( q . size ( ) > 0 ) { t = q . peek ( ) ; q . remove ( ) ; if ( t <= N ) { cnt ++ ; q . add ( t * 10 ) ; q . add ( t * 10 + 1 ) ; } } return cnt ; }
Ref: 
def countOfBinaryNumberLessThanN ( N ) : NEW_LINE INDENT q = deque ( ) NEW_LINE q . append ( 1 ) NEW_LINE cnt = 0 NEW_LINE while ( q ) : NEW_LINE INDENT t = q . popleft ( ) NEW_LINE if ( t <= N ) : NEW_LINE INDENT cnt = cnt + 1 NEW_LINE q . append ( t * 10 ) NEW_LINE q . append ( t * 10 + 1 ) NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT
Hyp: 
def countOfBinaryNumberLessThanN ( N ) : NEW_LINE INDENT q = [ 1 ] * 5 NEW_LINE cnt = 0 NEW_LINE while len ( q ) > 0 : NEW_LINE INDENT t = q . pop ( ) NEW_LINE q . append ( t * 10 ) NEW_LINE q . append ( t * 10 + 1 ) NEW_LINE DEDENT return cnt NEW_LINE DEDENT

BLEU: 55.94
Edit Sim: 105


Src: 
void secondary_polygon ( int Angle ) { int edges_primary = 360 / Angle ; if ( edges_primary >= 6 ) { int edges_max_secondary = edges_primary / 2 ; System . out . println ( edges_max_secondary + 3 ) ; } else System . out . println ( " Not ▁ Possible " ) ; }
Ref: 
def secondary_polygon ( Angle ) : NEW_LINE INDENT edges_primary = 360 // Angle NEW_LINE if edges_primary >= 6 : NEW_LINE INDENT edges_max_secondary = edges_primary // 2 NEW_LINE return edges_max_secondary + 3 NEW_LINE DEDENT else : NEW_LINE INDENT return " Not ▁ Possible " NEW_LINE DEDENT DEDENT
Hyp: 
def secondary_polygon ( Angle ) : NEW_LINE INDENT edges_primary = 360 // Angle NEW_LINE if ( edges_primary >= 6 ) : NEW_LINE INDENT edges_max_secondary = edges_primary // 2 NEW_LINE print ( edges_max_secondary + 3 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ Possible " ) NEW_LINE DEDENT DEDENT

BLEU: 65.23
Edit Sim: 20


Src: 
int nobleInteger ( int arr [ ] ) { int size = arr . length ; for ( int i = 0 ; i < size ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < size ; j ++ ) if ( arr [ i ] < arr [ j ] ) count ++ ; if ( count == arr [ i ] ) return arr [ i ] ; } return - 1 ; }
Ref: 
def nobleInteger ( arr , size ) : NEW_LINE INDENT for i in range ( 0 , size ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( 0 , size ) : NEW_LINE INDENT if ( arr [ i ] < arr [ j ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( count == arr [ i ] ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ 10 , 3 , 20 , 40 , 2 ] NEW_LINE size = len ( arr ) NEW_LINE res = nobleInteger ( arr , size ) NEW_LINE if ( res != - 1 ) : NEW_LINE INDENT print ( " The ▁ noble ▁ integer ▁ is ▁ " , res ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No ▁ Noble ▁ Integer ▁ Found " ) NEW_LINE DEDENT
Hyp: 
def nobleInteger ( arr ) : NEW_LINE INDENT size = len ( arr ) NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( 0 , size ) : NEW_LINE INDENT if ( arr [ i ] < arr [ j ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( count == arr [ i ] ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT

BLEU: 43.17
Edit Sim: 329


Src: 
int countPaths ( int n , int m ) { if ( n == 0 m == 0 ) return 1 ; return ( countPaths ( n - 1 , m ) + countPaths ( n , m - 1 ) ) ; }
Ref: 
def countPaths ( n , m ) : NEW_LINE INDENT if ( n == 0 or m == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return ( countPaths ( n - 1 , m ) + countPaths ( n , m - 1 ) ) NEW_LINE DEDENT
Hyp: 
def countPaths ( n , m ) : NEW_LINE INDENT if ( n == 0 or m == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return ( countPaths ( n - 1 , m ) + countPaths ( n , m - 1 ) ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
double areaOctagon ( double side ) { return ( float ) ( 2 * ( 1 + Math . sqrt ( 2 ) ) * side * side ) ; }
Ref: 
def areaOctagon ( side ) : NEW_LINE INDENT return ( 2 * ( 1 + ( math . sqrt ( 2 ) ) ) * side * side ) NEW_LINE DEDENT
Hyp: 
def areaOctagon ( side ) : NEW_LINE INDENT return ( 2 * ( 1 + math . sqrt ( 2 ) ) * side * side ) ; NEW_LINE DEDENT

BLEU: 82.94
Edit Sim: 6


Src: 
void pairs ( int arr [ ] , int n , int k ) { int smallest = Integer . MAX_VALUE ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) { if ( Math . abs ( arr [ i ] + arr [ j ] - k ) < smallest ) { smallest = Math . abs ( arr [ i ] + arr [ j ] - k ) ; count = 1 ; } else if ( Math . abs ( arr [ i ] + arr [ j ] - k ) == smallest ) count ++ ; } System . out . println ( " Minimal ▁ Value ▁ = ▁ " + smallest ) ; System . out . println ( " Total ▁ Pairs ▁ = ▁ " + count ) ; }
Ref: 
def pairs ( arr , n , k ) : NEW_LINE INDENT smallest = 999999999999 NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if abs ( arr [ i ] + arr [ j ] - k ) < smallest : NEW_LINE INDENT smallest = abs ( arr [ i ] + arr [ j ] - k ) NEW_LINE count = 1 NEW_LINE DEDENT elif abs ( arr [ i ] + arr [ j ] - k ) == smallest : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT print ( " Minimal ▁ Value ▁ = ▁ " , smallest ) NEW_LINE print ( " Total ▁ Pairs ▁ = ▁ " , count ) NEW_LINE DEDENT
Hyp: 
def pairs ( arr , n , k ) : NEW_LINE INDENT smallest = 10 ** 20 NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if abs ( arr [ i ] + arr [ j ] - k ) < smallest : NEW_LINE INDENT smallest = abs ( arr [ i ] + arr [ j ] - k ) NEW_LINE count = 1 NEW_LINE DEDENT elif abs ( arr [ i ] + arr [ j ] - k ) == smallest : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT print ( " Minimal ▁ Value ▁ = " , smallest ) NEW_LINE print ( " Total ▁ Pairs ▁ = " , count ) NEW_LINE DEDENT

BLEU: 94.65
Edit Sim: 16


Src: 
boolean isPossible ( int index , int sum ) { if ( index == n ) { if ( ( sum % M ) == 0 ) return true ; return false ; } boolean placeAdd = isPossible ( index + 1 , sum + arr [ index ] ) ; boolean placeMinus = isPossible ( index + 1 , sum - arr [ index ] ) ; if ( placeAdd placeMinus ) return true ; return false ; }
Ref: 
def isPossible ( index , sum ) : NEW_LINE INDENT if ( index == n ) : NEW_LINE INDENT if ( ( sum % M ) == 0 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT placeAdd = isPossible ( index + 1 , sum + arr [ index ] ) ; NEW_LINE placeMinus = isPossible ( index + 1 , sum - arr [ index ] ) ; NEW_LINE if ( placeAdd or placeMinus ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT
Hyp: 
def isPossible ( index , sum ) : NEW_LINE INDENT if ( index == n ) : NEW_LINE INDENT if ( sum % M ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT placeAdd = isPossible ( index + 1 , sum + arr [ index ] ) NEW_LINE placeMinus = isPossible ( index + 1 , sum - arr [ index ] ) NEW_LINE if ( placeAdd or placeMinus ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT

BLEU: 77.53
Edit Sim: 21


Src: 
int minOperations ( int arr [ ] , int n ) { int oddcount = 0 , evencount = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 1 ) oddcount ++ ; else evencount ++ ; } return Math . min ( oddcount , evencount ) ; }
Ref: 
def minOperations ( arr , n ) : NEW_LINE INDENT oddcount , evencount = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 1 ) : NEW_LINE INDENT oddcount += 1 NEW_LINE DEDENT else : NEW_LINE INDENT evencount += 1 NEW_LINE DEDENT DEDENT return min ( oddcount , evencount ) NEW_LINE DEDENT
Hyp: 
def minOperations ( arr , n ) : NEW_LINE INDENT oddcount = 0 NEW_LINE evencount = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 1 ) : NEW_LINE INDENT oddcount += 1 NEW_LINE DEDENT else : NEW_LINE INDENT evencount += 1 NEW_LINE DEDENT DEDENT return min ( oddcount , evencount ) NEW_LINE DEDENT

BLEU: 92.24
Edit Sim: 16


Src: 
double sumNodes ( int l ) { double leafNodeCount = Math . pow ( 2 , l - 1 ) ; double sumLastLevel = 0 ; sumLastLevel = ( leafNodeCount * ( leafNodeCount + 1 ) ) / 2 ; double sum = sumLastLevel * l ; return sum ; }
Ref: 
def sumNodes ( l ) : NEW_LINE INDENT leafNodeCount = math . pow ( 2 , l - 1 ) ; NEW_LINE sumLastLevel = 0 ; NEW_LINE sumLastLevel = ( ( leafNodeCount * ( leafNodeCount + 1 ) ) / 2 ) ; NEW_LINE sum = sumLastLevel * l ; NEW_LINE return int ( sum ) ; NEW_LINE DEDENT
Hyp: 
def sumNodes ( l ) : NEW_LINE INDENT leafNodeCount = pow ( 2 , l - 1 ) ; NEW_LINE sumLastLevel = 0 ; NEW_LINE sumLastLevel = ( leafNodeCount * ( leafNodeCount + 1 ) ) // 2 ; NEW_LINE sum = sumLastLevel * l ; NEW_LINE return sum ; NEW_LINE DEDENT

BLEU: 73.59
Edit Sim: 20


Src: 
void leftRotate ( int arr [ ] , int d , int n ) { int i , j ; if ( d == 0 d == n ) return ; i = d ; j = n - d ; while ( i != j ) { if ( i < j ) { swap ( arr , d - i , d + j - i , i ) ; j -= i ; } else { swap ( arr , d - i , d , j ) ; i -= j ; } } swap ( arr , d - i , d , i ) ; }
Ref: 
def leftRotate ( arr , d , n ) : NEW_LINE INDENT if ( d == 0 or d == n ) : NEW_LINE INDENT return ; NEW_LINE DEDENT i = d NEW_LINE j = n - d NEW_LINE while ( i != j ) : NEW_LINE INDENT if ( i < j ) : NEW_LINE INDENT swap ( arr , d - i , d + j - i , i ) NEW_LINE j -= i NEW_LINE DEDENT else : NEW_LINE INDENT swap ( arr , d - i , d , j ) NEW_LINE i -= j NEW_LINE DEDENT DEDENT swap ( arr , d - i , d , i ) NEW_LINE DEDENT
Hyp: 
def leftRotate ( arr , d , n ) : NEW_LINE INDENT if ( d == 0 or d == n ) : NEW_LINE INDENT return NEW_LINE DEDENT i = d NEW_LINE j = n - d NEW_LINE while ( i != j ) : NEW_LINE INDENT if ( i < j ) : NEW_LINE INDENT swap ( arr , d - i , d + j - i , i ) NEW_LINE j -= i NEW_LINE DEDENT else : NEW_LINE INDENT swap ( arr , d - i , d , j ) NEW_LINE i -= j NEW_LINE DEDENT DEDENT swap ( arr , d - i , d , i ) NEW_LINE DEDENT

BLEU: 97.82
Edit Sim: 2


Src: 
int maxGCD ( int N , int K ) { int minSum = ( K * ( K + 1 ) ) / 2 ; if ( N < minSum ) return - 1 ; int i = ( int ) Math . sqrt ( N ) ; int res = 1 ; while ( i >= 1 ) { if ( N % i == 0 ) { if ( i >= minSum ) res = Math . max ( res , N / i ) ; if ( N / i >= minSum ) res = Math . max ( res , i ) ; } i -- ; } return res ; }
Ref: 
def maxGCD ( N , K ) : NEW_LINE INDENT minSum = ( K * ( K + 1 ) ) / 2 NEW_LINE if ( N < minSum ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT i = ceil ( sqrt ( N ) ) NEW_LINE res = 1 NEW_LINE while ( i >= 1 ) : NEW_LINE INDENT if ( N % i == 0 ) : NEW_LINE INDENT if ( i >= minSum ) : NEW_LINE INDENT res = max ( res , N / i ) NEW_LINE DEDENT if ( N / i >= minSum ) : NEW_LINE INDENT res = max ( res , i ) NEW_LINE DEDENT DEDENT i -= 1 NEW_LINE DEDENT return res NEW_LINE DEDENT
Hyp: 
def maxGCD ( N , K ) : NEW_LINE INDENT minSum = ( K * ( K + 1 ) ) / 2 NEW_LINE if ( N < minSum ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT i = int ( math . sqrt ( N ) ) NEW_LINE res = 1 NEW_LINE while ( i >= 1 ) : NEW_LINE INDENT if ( N % i == 0 ) : NEW_LINE INDENT if ( i >= minSum ) : NEW_LINE INDENT res = max ( res , N // i ) NEW_LINE DEDENT if ( N // i >= minSum ) : NEW_LINE INDENT res = max ( res , i ) NEW_LINE DEDENT DEDENT i -= 1 NEW_LINE DEDENT return res NEW_LINE DEDENT

BLEU: 91.76
Edit Sim: 13


Src: 
void maxArea ( int [ ] point_x , int [ ] point_y , int n , int length , int width ) { Arrays . sort ( point_x ) ; Arrays . sort ( point_y ) ; int dx = point_x [ 0 ] ; int dy = point_y [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { dx = Math . max ( dx , point_x [ i ] - point_x [ i - 1 ] ) ; dy = Math . max ( dy , point_y [ i ] - point_y [ i - 1 ] ) ; } dx = Math . max ( dx , ( length + 1 ) - point_x [ n - 1 ] ) ; dy = Math . max ( dy , ( width + 1 ) - point_y [ n - 1 ] ) ; System . out . println ( ( dx - 1 ) * ( dy - 1 ) ) ; }
Ref: 
def maxArea ( point_x , point_y , n , length , width ) : NEW_LINE INDENT point_x . sort ( ) NEW_LINE point_y . sort ( ) NEW_LINE dx = point_x [ 0 ] NEW_LINE dy = point_y [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT dx = max ( dx , point_x [ i ] - point_x [ i - 1 ] ) NEW_LINE dy = max ( dy , point_y [ i ] - point_y [ i - 1 ] ) NEW_LINE DEDENT dx = max ( dx , ( length + 1 ) - point_x [ n - 1 ] ) NEW_LINE dy = max ( dy , ( width + 1 ) - point_y [ n - 1 ] ) NEW_LINE print ( ( dx - 1 ) * ( dy - 1 ) ) NEW_LINE DEDENT
Hyp: 
def maxArea ( point_x , point_y , n , length , width ) : NEW_LINE INDENT point_x . sort ( reverse = False ) NEW_LINE point_y . sort ( reverse = False ) NEW_LINE dx = point_x [ 0 ] NEW_LINE dy = point_y [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT dx = max ( dx , point_x [ i ] - point_x [ i - 1 ] ) NEW_LINE dy = max ( dy , point_y [ i ] - point_y [ i - 1 ] ) NEW_LINE DEDENT dx = max ( dx , ( length + 1 ) - point_x [ n - 1 ] ) NEW_LINE dy = max ( dy , ( width + 1 ) - point_y [ n - 1 ] ) NEW_LINE print ( ( dx - 1 ) * ( dy - 1 ) ) NEW_LINE DEDENT

BLEU: 94.15
Edit Sim: 32


Src: 
int ways ( int i , int arr [ ] , int n ) { if ( i == n - 1 ) return 1 ; int sum = 0 ; for ( int j = 1 ; j + i < n && j <= arr [ i ] ; j ++ ) { sum += ( ways ( i + j , arr , n ) ) % mod ; sum %= mod ; } return sum % mod ; }
Ref: 
def ways ( i , arr , n ) : NEW_LINE INDENT if ( i == n - 1 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT sum = 0 ; NEW_LINE for j in range ( 1 , arr [ i ] + 1 ) : NEW_LINE INDENT if ( i + j < n ) : NEW_LINE INDENT sum += ( ways ( i + j , arr , n ) ) % mod ; NEW_LINE sum %= mod ; NEW_LINE DEDENT DEDENT return int ( sum % mod ) ; NEW_LINE DEDENT
Hyp: 
def ways ( i , arr , n ) : NEW_LINE INDENT if ( i == n - 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT sum = 0 NEW_LINE for j in range ( 1 , n and j <= arr [ i ] ) : NEW_LINE INDENT sum += ( ways ( i + j , arr , n ) ) % mod NEW_LINE sum %= mod NEW_LINE DEDENT return sum % mod NEW_LINE DEDENT

BLEU: 62.61
Edit Sim: 65


Src: 
long countNumberOfStrings ( String s ) { int n = s . length ( ) - 1 ; long count = ( long ) ( Math . pow ( 2 , n ) ) ; return count ; }
Ref: 
def countNumberOfStrings ( s ) : NEW_LINE INDENT length = len ( s ) NEW_LINE n = length - 1 NEW_LINE count = 2 ** n NEW_LINE return count NEW_LINE DEDENT
Hyp: 
def countNumberOfStrings ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE count = pow ( 2 , n ) ; NEW_LINE return count NEW_LINE DEDENT

BLEU: 55.55
Edit Sim: 34


Src: 
long moduloMultiplication ( long a , long b , long mod ) { long res = 0 ; a %= mod ; while ( b > 0 ) { if ( ( b & 1 ) > 0 ) { res = ( res + a ) % mod ; } a = ( 2 * a ) % mod ; } return res ; }
Ref: 
def moduloMultiplication ( a , b , mod ) : NEW_LINE INDENT a = a % mod ; NEW_LINE while ( b ) : NEW_LINE INDENT if ( b & 1 ) : NEW_LINE INDENT res = ( res + a ) % mod ; NEW_LINE DEDENT a = ( 2 * a ) % mod ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT
Hyp: 
def moduloMultiplication ( a , b , mod ) : NEW_LINE INDENT res = 0 NEW_LINE a %= mod NEW_LINE while ( b > 0 ) : NEW_LINE INDENT if ( b & 1 ) : NEW_LINE INDENT res = ( res + a ) % mod NEW_LINE DEDENT a = ( 2 * a ) % mod NEW_LINE DEDENT return res NEW_LINE DEDENT

BLEU: 74.71
Edit Sim: 27


Src: 
long minSum ( int n , int num [ ] , int price [ ] ) { long dp [ ] = new long [ n ] ; Arrays . fill ( dp , Integer . MAX_VALUE ) ; long ans = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( num [ j ] > num [ i ] ) { dp [ j ] = ( long ) Math . min ( ( long ) dp [ j ] , ( long ) price [ i ] + ( long ) price [ j ] ) ; ans = Math . min ( ans , ( long ) dp [ i ] + ( long ) price [ j ] ) ; } } } return ans != Integer . MAX_VALUE ? ans : - 1 ; }
Ref: 
def minSum ( n , num , price ) : NEW_LINE INDENT dp = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp [ i ] = sys . maxsize NEW_LINE DEDENT ans = sys . maxsize NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( num [ j ] > num [ i ] ) : NEW_LINE INDENT dp [ j ] = min ( dp [ j ] , price [ i ] + price [ j ] ) NEW_LINE ans = min ( ans , dp [ i ] + price [ j ] ) NEW_LINE DEDENT DEDENT DEDENT if ans is not sys . maxsize : NEW_LINE INDENT return ans NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT
Hyp: 
def minSum ( n , num , price ) : NEW_LINE INDENT dp = [ 0 ] * n NEW_LINE dp . append ( 0 ) NEW_LINE ans = sys . maxsize NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( num [ j ] > num [ i ] ) : NEW_LINE INDENT dp [ j ] = min ( dp [ j ] , ( long ) price [ i ] + ( long ) price [ j ] ) NEW_LINE ans = min ( ans , dp [ i ] + ( long ) price [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT

BLEU: 63.78
Edit Sim: 210


Src: 
int lcsOf3 ( String X , String Y , String Z , int m , int n , int o ) { int [ ] [ ] [ ] L = new int [ m + 1 ] [ n + 1 ] [ o + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { for ( int k = 0 ; k <= o ; k ++ ) { if ( i == 0 j == 0 k == 0 ) L [ i ] [ j ] [ k ] = 0 ; else if ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) && X . charAt ( i - 1 ) == Z . charAt ( k - 1 ) ) L [ i ] [ j ] [ k ] = L [ i - 1 ] [ j - 1 ] [ k - 1 ] + 1 ; else L [ i ] [ j ] [ k ] = Math . max ( Math . max ( L [ i - 1 ] [ j ] [ k ] , L [ i ] [ j - 1 ] [ k ] ) , L [ i ] [ j ] [ k - 1 ] ) ; } } } return L [ m ] [ n ] [ o ] ; }
Ref: 
def lcsOf3 ( X , Y , Z , m , n , o ) : NEW_LINE INDENT L = [ [ [ 0 for i in range ( o + 1 ) ] for j in range ( n + 1 ) ] for k in range ( m + 1 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT for k in range ( o + 1 ) : NEW_LINE INDENT if ( i == 0 or j == 0 or k == 0 ) : NEW_LINE INDENT L [ i ] [ j ] [ k ] = 0 NEW_LINE DEDENT elif ( X [ i - 1 ] == Y [ j - 1 ] and X [ i - 1 ] == Z [ k - 1 ] ) : NEW_LINE INDENT L [ i ] [ j ] [ k ] = L [ i - 1 ] [ j - 1 ] [ k - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] [ k ] = max ( max ( L [ i - 1 ] [ j ] [ k ] , L [ i ] [ j - 1 ] [ k ] ) , L [ i ] [ j ] [ k - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return L [ m ] [ n ] [ o ] NEW_LINE DEDENT
Hyp: 
def lcsOf3 ( X , Y , Z , m , n , o ) : NEW_LINE INDENT L = [ [ 0 for x in range ( o + 1 ) ] for y in range ( m + 1 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT for k in range ( o + 1 ) : NEW_LINE INDENT if i == 0 or j == 0 or k == 0 : NEW_LINE INDENT L [ i ] [ j ] [ k ] = 0 NEW_LINE DEDENT elif X [ i - 1 ] == Y [ j - 1 ] and X [ i - 1 ] == Z [ k - 1 ] ) : NEW_LINE INDENT L [ i ] [ j ] [ k ] = L [ i - 1 ] [ j - 1 ] [ k - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] [ k ] = max ( max ( L [ i - 1 ] [ j ] [ k ] , L [ i ] [ j - 1 ] [ k ] ) , L [ i ] [ j ] [ k - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return L [ m ] [ n ] [ o ] NEW_LINE DEDENT

BLEU: 90.78
Edit Sim: 37


Src: 
boolean solve ( String s1 , String s2 ) { boolean flag1 = false , flag2 = false ; if ( s1 . length ( ) != s2 . length ( ) ) return false ; int l = s1 . length ( ) ; for ( int i = 0 ; i < l ; i ++ ) { if ( s1 . charAt ( i ) == '1' ) flag1 = true ; if ( s2 . charAt ( i ) == '1' ) flag2 = true ; if ( flag1 == true && flag2 == true ) return true ; } if ( ! flag1 && ! flag2 ) return true ; return false ; }
Ref: 
def solve ( s1 , s2 ) : NEW_LINE INDENT flag1 = 0 NEW_LINE flag2 = 0 NEW_LINE if ( len ( s1 ) != len ( s2 ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT l = len ( s1 ) NEW_LINE for i in range ( 0 , l ) : NEW_LINE INDENT if ( s1 [ i ] == '1' ) : NEW_LINE INDENT flag1 = 1 ; NEW_LINE DEDENT if ( s2 [ i ] == '1' ) : NEW_LINE INDENT flag2 = 1 NEW_LINE DEDENT if ( flag1 & flag2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( ! flag1 &   ! flag2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT s1 = "100101" NEW_LINE s2 = "100000" NEW_LINE if solve ( s1 , s2 ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
Hyp: 
def solve ( s1 , s2 ) : NEW_LINE INDENT flag1 = False NEW_LINE flag2 = False NEW_LINE if ( len ( s1 ) != len ( s2 ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT l = len ( s1 ) NEW_LINE for i in range ( 0 , l ) : NEW_LINE INDENT if ( s1 [ i ] == '1' ) : NEW_LINE INDENT flag1 = True NEW_LINE DEDENT if ( s2 [ i ] == '1' ) : NEW_LINE INDENT flag2 = True NEW_LINE DEDENT if ( flag1 == True and flag2 == True ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT if ( not flag1 and flag2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT

BLEU: 61.25
Edit Sim: 218


Src: 
int equilibrium ( int arr [ ] , int n ) { int sum = 0 ; int leftsum = 0 ; for ( int i = 0 ; i < n ; ++ i ) sum += arr [ i ] ; for ( int i = 0 ; i < n ; ++ i ) { sum -= arr [ i ] ; if ( leftsum == sum ) return i ; leftsum += arr [ i ] ; } return - 1 ; }
Ref: 
def equilibrium ( arr ) : NEW_LINE INDENT total_sum = sum ( arr ) NEW_LINE leftsum = 0 NEW_LINE for i , num in enumerate ( arr ) : NEW_LINE INDENT total_sum -= num NEW_LINE if leftsum == total_sum : NEW_LINE INDENT return i NEW_LINE DEDENT leftsum += num NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
Hyp: 
def equilibrium ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE leftsum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT sum -= arr [ i ] NEW_LINE if ( leftsum == sum ) : NEW_LINE INDENT return i NEW_LINE DEDENT leftsum += arr [ i ] NEW_LINE DEDENT return - 1 NEW_LINE DEDENT

BLEU: 36.73
Edit Sim: 123


Src: 
char nextGreatestAlphabet ( char alphabets [ ] , char K ) { int n = alphabets . length ; if ( K >= alphabets [ n - 1 ] ) return alphabets [ 0 ] ; int l = 0 , r = alphabets . length - 1 ; int ans = - 1 ; while ( l <= r ) { int mid = ( l + r ) / 2 ; if ( alphabets [ mid ] > K ) { r = mid - 1 ; ans = mid ; } else l = mid + 1 ; } return alphabets [ ans ] ; }
Ref: 
def nextGreatestAlphabet ( alphabets , K ) : NEW_LINE INDENT n = len ( alphabets ) NEW_LINE if ( K >= alphabets [ n - 1 ] ) : NEW_LINE return alphabets [ 0 ] NEW_LINE l = 0 NEW_LINE r = len ( alphabets ) - 1 NEW_LINE ans = - 1 NEW_LINE while ( l <= r ) : NEW_LINE INDENT mid = int ( ( l + r ) / 2 ) NEW_LINE if ( alphabets [ mid ] > K ) : NEW_LINE INDENT r = mid - 1 NEW_LINE ans = mid NEW_LINE DEDENT else : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT DEDENT if ( alphabets [ ans ] < K ) : NEW_LINE INDENT return alphabets [ 0 ] NEW_LINE DEDENT else : NEW_LINE INDENT return alphabets [ ans ] NEW_LINE DEDENT DEDENT
Hyp: 
def nextGreatestAlphabet ( alphabets , K ) : NEW_LINE INDENT n = len ( alphabets ) NEW_LINE if ( K >= alphabets [ n - 1 ] ) : NEW_LINE INDENT return alphabets [ 0 ] NEW_LINE DEDENT l = 0 NEW_LINE r = len ( alphabets ) - 1 NEW_LINE ans = - 1 NEW_LINE while ( l <= r ) : NEW_LINE INDENT mid = ( l + r ) // 2 NEW_LINE if ( alphabets [ mid ] > K ) : NEW_LINE INDENT r = mid - 1 NEW_LINE ans = mid NEW_LINE DEDENT else : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT DEDENT return alphabets [ ans ] NEW_LINE DEDENT

BLEU: 75.28
Edit Sim: 139


Src: 
void constructArray ( int A [ ] , int N , int K ) { int B [ ] = new int [ N ] ; int totalXOR = A [ 0 ] ^ K ; for ( int i = 0 ; i < N ; i ++ ) B [ i ] = totalXOR ^ A [ i ] ; for ( int i = 0 ; i < N ; i ++ ) { System . out . print ( B [ i ] + " ▁ " ) ; } }
Ref: 
def constructArray ( A , N , K ) : NEW_LINE INDENT B = [ 0 ] * N ; NEW_LINE totalXOR = A [ 0 ] ^ K ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT B [ i ] = totalXOR ^ A [ i ] ; NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT print ( B [ i ] , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT
Hyp: 
def constructArray ( A , N , K ) : NEW_LINE INDENT B = [ 0 ] * N NEW_LINE totalXOR = A [ 0 ] ^ K NEW_LINE for i in range ( N ) : NEW_LINE INDENT B [ i ] = totalXOR ^ A [ i ] NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT print ( B [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT

BLEU: 87.39
Edit Sim: 8


Src: 
boolean check ( String str ) { int n = str . length ( ) ; if ( ( str . charAt ( n - 1 ) - '0' ) % 2 != 0 ) return false ; int digitSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) digitSum += ( str . charAt ( i ) - '0' ) ; return ( digitSum % 3 == 0 ) ; }
Ref: 
def check ( st ) : NEW_LINE INDENT n = len ( st ) NEW_LINE if ( ( ( int ) ( st [ n - 1 ] ) % 2 ) != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT digitSum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT digitSum = digitSum + ( int ) ( st [ i ] ) NEW_LINE DEDENT return ( digitSum % 3 == 0 ) NEW_LINE DEDENT st = "1332" NEW_LINE if ( check ( st ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No ▁ " ) NEW_LINE DEDENT
Hyp: 
def check ( st ) : NEW_LINE INDENT n = len ( st ) NEW_LINE if ( int ( st [ n - 1 ] ) % 2 != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT digitSum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT digitSum += int ( st [ i ] ) NEW_LINE DEDENT return ( digitSum % 3 == 0 ) NEW_LINE DEDENT st = " aaabbccdaa " NEW_LINE if ( check ( st ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT

BLEU: 79.65
Edit Sim: 41


Src: 
int maxHeight ( int h1 , int h2 ) { return ( ( h1 * h2 ) - h1 - h2 ) ; }
Ref: 
def maxHeight ( h1 , h2 ) : NEW_LINE INDENT return ( ( h1 * h2 ) - h1 - h2 ) NEW_LINE DEDENT
Hyp: 
def maxHeight ( h1 , h2 ) : NEW_LINE INDENT return ( ( h1 * h2 ) - h1 - h2 ) ; NEW_LINE DEDENT

BLEU: 90.58
Edit Sim: 2


Src: 
void cal_IST ( int h , double r ) { double IST = ( h * r * 1.0 ) / 360 ; int int_IST = ( int ) IST ; int float_IST = ( int ) Math . ceil ( ( int ) ( ( IST - int_IST ) * 60 ) ) ; System . out . println ( int_IST + " : " + float_IST ) ; }
Ref: 
def cal_IST ( h , r ) : NEW_LINE INDENT IST = round ( ( h * r * 1.0 ) / 360 , 3 ) ; NEW_LINE int_IST = int ( IST ) ; NEW_LINE float_IST = ceil ( ( IST - int_IST ) * 60 ) ; NEW_LINE print ( int_IST , " : " , float_IST ) ; NEW_LINE DEDENT
Hyp: 
def cal_IST ( h , r ) : NEW_LINE INDENT IST = ( h * r * 1.0 ) / 360 NEW_LINE int_IST = int ( IST ) NEW_LINE float_IST = math . ceil ( ( IST - int_IST ) * 60 ) ) NEW_LINE print ( int_IST , " : " , float_IST ) NEW_LINE DEDENT

BLEU: 70.61
Edit Sim: 28


Src: 
double getSum ( int n ) { double sum = 0 ; if ( n == 1 ) { sum = 45.0 ; } else { sum = ( 99.0 / 2.0 ) * Math . pow ( 10 , n - 1 ) * Math . pow ( 10 , ( n - 1 ) / 2 ) ; } return sum ; }
Ref: 
def getSum ( n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE if ( n == 1 ) : NEW_LINE INDENT sum = 45.0 ; NEW_LINE DEDENT else : NEW_LINE INDENT sum = ( 99.0 / 2.0 ) * pow ( 10 , n - 1 ) * pow ( 10 , ( n - 1 ) / 2 ) ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT
Hyp: 
def getSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE if ( n == 1 ) : NEW_LINE INDENT sum = 45.0 NEW_LINE DEDENT else : NEW_LINE INDENT sum = ( 99.0 / 2.0 ) * pow ( 10 , n - 1 ) * pow ( 10 , ( n - 1 ) / 2 ) NEW_LINE DEDENT return sum NEW_LINE DEDENT

BLEU: 85.32
Edit Sim: 8


Src: 
int toggleKthBit ( int n , int k ) { return ( n ^ ( 1 << ( k - 1 ) ) ) ; }
Ref: 
def toggleKthBit ( n , k ) : NEW_LINE INDENT return ( n ^ ( 1 << ( k - 1 ) ) ) NEW_LINE DEDENT
Hyp: 
def toggleKthBit ( n , k ) : NEW_LINE INDENT return ( n ^ ( 1 << ( k - 1 ) ) ) ; NEW_LINE DEDENT

BLEU: 91.31
Edit Sim: 2


Src: 
int sumOfTheSeries ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int k = 1 ; for ( int j = 1 ; j <= i ; j ++ ) { sum += k ; k += 2 ; } } return sum ; }
Ref: 
def sumOfTheSeries ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT k = 1 NEW_LINE for j in range ( 1 , i + 1 ) : NEW_LINE INDENT sum += k NEW_LINE k += 2 NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
Hyp: 
def sumOfTheSeries ( n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT k = 1 ; NEW_LINE for j in range ( 1 , i + 1 ) : NEW_LINE INDENT sum += k ; NEW_LINE k += 2 ; NEW_LINE DEDENT DEDENT return sum ; NEW_LINE DEDENT

BLEU: 79.76
Edit Sim: 10


Src: 
double Conversion ( double centi ) { double pixels = ( 96 * centi ) / 2.54 ; System . out . println ( pixels ) ; return 0 ; }
Ref: 
def Conversion ( centi ) : NEW_LINE INDENT pixels = ( 96 * centi ) / 2.54 NEW_LINE print ( round ( pixels , 2 ) ) NEW_LINE DEDENT
Hyp: 
def Conversion ( centi ) : NEW_LINE INDENT pixels = ( 96 * centi ) / 2.54 NEW_LINE print ( pixels ) NEW_LINE return 0 NEW_LINE DEDENT

BLEU: 73.86
Edit Sim: 22


Src: 
void merge ( int m , int n ) { for ( int i = n - 1 ; i >= 0 ; i -- ) { int j , last = arr1 [ m - 1 ] ; for ( j = m - 2 ; j >= 0 && arr1 [ j ] > arr2 [ i ] ; j -- ) arr1 [ j + 1 ] = arr1 [ j ] ; if ( j != m - 2 last > arr2 [ i ] ) { arr1 [ j + 1 ] = arr2 [ i ] ; arr2 [ i ] = last ; } } }
Ref: 
def merge ( ar1 , ar2 , m , n ) : NEW_LINE INDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT last = ar1 [ m - 1 ] NEW_LINE j = m - 2 NEW_LINE while ( j >= 0 and ar1 [ j ] > ar2 [ i ] ) : NEW_LINE INDENT ar1 [ j + 1 ] = ar1 [ j ] NEW_LINE j -= 1 NEW_LINE DEDENT if ( j != m - 2 or last > ar2 [ i ] ) : NEW_LINE INDENT ar1 [ j + 1 ] = ar2 [ i ] NEW_LINE ar2 [ i ] = last NEW_LINE DEDENT DEDENT DEDENT ar1 = [ 1 , 5 , 9 , 10 , 15 , 20 ] NEW_LINE ar2 = [ 2 , 3 , 8 , 13 ] NEW_LINE m = len ( ar1 ) NEW_LINE n = len ( ar2 ) NEW_LINE merge ( ar1 , ar2 , m , n ) NEW_LINE print ( " After Merging First Array : " , ▁ end = " " ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT print ( ar1 [ i ] , " ▁ " , end = " " ) NEW_LINE DEDENT print ( " Second Array : " , ▁ end = " " ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( ar2 [ i ] , " ▁ " , end = " " ) NEW_LINE DEDENT
Hyp: 
def merge ( m , n ) : NEW_LINE INDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT last = arr1 [ m - 1 ] NEW_LINE for j in range ( m - 2 , - 1 , - 1 ) : NEW_LINE INDENT if j >= 0 and arr1 [ j ] > arr2 [ i ] : NEW_LINE INDENT arr1 [ j + 1 ] = arr1 [ j ] NEW_LINE j -= 1 NEW_LINE DEDENT DEDENT if j != m - 2 last > arr2 [ i ] : NEW_LINE INDENT arr1 [ j + 1 ] = arr2 [ i ] NEW_LINE arr2 [ i ] = last NEW_LINE DEDENT DEDENT DEDENT

BLEU: 21.47
Edit Sim: 527


Src: 
void smallestNumber ( int N ) { int L = ( int ) ( Math . pow ( 10 , N ) - 1 ) ; int S = ( int ) Math . pow ( 10 , N - 1 ) ; for ( int i = S ; i <= L ; i ++ ) { if ( i % N == 0 ) { System . out . print ( i ) ; return ; } } }
Ref: 
def smallestNumber ( N ) : NEW_LINE INDENT L = pow ( 10 , N ) - 1 ; NEW_LINE S = pow ( 10 , N - 1 ) ; NEW_LINE for i in range ( S , L ) : NEW_LINE INDENT if ( i % N == 0 ) : NEW_LINE INDENT print ( i ) ; NEW_LINE return ; NEW_LINE DEDENT DEDENT DEDENT
Hyp: 
def smallestNumber ( N ) : NEW_LINE INDENT L = int ( pow ( 10 , N ) - 1 ) NEW_LINE S = int ( pow ( 10 , N - 1 ) ) NEW_LINE for i in range ( S , L + 1 ) : NEW_LINE INDENT if ( i % N == 0 ) : NEW_LINE INDENT print ( i ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT

BLEU: 73.11
Edit Sim: 22


Src: 
void decode_String ( String str , int K ) { String ans = " " ; for ( int i = 0 ; i < str . length ( ) ; i += K ) ans += str . charAt ( i ) ; for ( int i = str . length ( ) - ( K - 1 ) ; i < str . length ( ) ; i ++ ) ans += str . charAt ( i ) ; System . out . println ( ans ) ; }
Ref: 
def decode_String ( st , K ) : NEW_LINE INDENT ans = " " NEW_LINE for i in range ( 0 , len ( st ) , K ) : NEW_LINE INDENT ans += st [ i ] NEW_LINE DEDENT for i in range ( len ( st ) - ( K - 1 ) , len ( st ) ) : NEW_LINE INDENT ans += st [ i ] NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
Hyp: 
def decode_String ( str , K ) : NEW_LINE INDENT ans = " " NEW_LINE for i in range ( 0 , K ) : NEW_LINE INDENT ans += str [ i ] NEW_LINE DEDENT for i in range ( int ( len ( ans ) - K - 1 ) , len ( ans ) ) : NEW_LINE INDENT ans += str [ i ] NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT

BLEU: 71.81
Edit Sim: 30


Src: 
boolean isRepunitNum ( int n , int b ) { int length = 0 ; int countOne = 0 ; while ( n != 0 ) { int r = n % b ; length ++ ; if ( r == 1 ) countOne ++ ; n = n / b ; } return countOne >= 3 && countOne == length ; }
Ref: 
def isRepunitNum ( n , b ) : NEW_LINE INDENT length = 0 ; NEW_LINE countOne = 0 ; NEW_LINE while ( n != 0 ) : NEW_LINE INDENT r = n % b ; NEW_LINE length += 1 ; NEW_LINE if ( r == 1 ) : NEW_LINE INDENT countOne += 1 ; NEW_LINE DEDENT n = n // b ; NEW_LINE DEDENT return countOne >= 3 and countOne == length ; NEW_LINE DEDENT
Hyp: 
def isRepunitNum ( n , b ) : NEW_LINE INDENT length = 0 NEW_LINE countOne = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT r = n % b NEW_LINE length += 1 NEW_LINE if ( r == 1 ) : NEW_LINE INDENT countOne += 1 NEW_LINE DEDENT n = n // b NEW_LINE DEDENT return countOne >= 3 and countOne == length NEW_LINE DEDENT n = n // b NEW_LINE if ( isRepunitNum ( n , b ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT

BLEU: 53.65
Edit Sim: 169


Src: 
int findSum ( int [ ] arr , int n , int k , int l , int r ) { if ( ( l ) + ( n - 1 - r ) == k ) return arr [ r ] - arr [ l ] ; if ( vis [ l ] [ r ] == 1 ) return dp [ l ] [ r ] ; vis [ l ] [ r ] = 1 ; dp [ l ] [ r ] = Math . min ( findSum ( arr , n , k , l , r - 1 ) , findSum ( arr , n , k , l + 1 , r ) ) ; return dp [ l ] [ r ] ; }
Ref: 
def findSum ( arr , n , k , l , r ) : NEW_LINE INDENT if ( ( l ) + ( n - 1 - r ) == k ) : NEW_LINE INDENT return arr [ r ] - arr [ l ] ; NEW_LINE DEDENT if ( vis [ l ] [ r ] ) : NEW_LINE INDENT return dp [ l ] [ r ] ; NEW_LINE DEDENT vis [ l ] [ r ] = 1 ; NEW_LINE dp [ l ] [ r ] = min ( findSum ( arr , n , k , l , r - 1 ) , findSum ( arr , n , k , l + 1 , r ) ) ; NEW_LINE return dp [ l ] [ r ] NEW_LINE DEDENT
Hyp: 
def findSum ( arr , n , k , l , r ) : NEW_LINE INDENT if ( ( l ) + ( n - 1 - r ) == k ) : NEW_LINE INDENT return arr [ r ] - arr [ l ] NEW_LINE DEDENT if ( vis [ l ] [ r ] ) : NEW_LINE INDENT return dp [ l ] [ r ] NEW_LINE DEDENT vis [ l ] [ r ] = 1 NEW_LINE dp [ l ] [ r ] = min ( findSum ( arr , n , k , l , r - 1 ) , findSum ( arr , n , k , l + 1 , r ) ) NEW_LINE return dp [ l ] [ r ] NEW_LINE DEDENT

BLEU: 92.44
Edit Sim: 8


Src: 
boolean isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) { return false ; } } return true ; }
Ref: 
def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return True NEW_LINE DEDENT n = 17 NEW_LINE if ( isPrime ( n ) and ( n % 16 == 1 ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
Hyp: 
def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 5 , n + 6 ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT n = 65 NEW_LINE if ( isPrime ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT

BLEU: 75.91
Edit Sim: 66


Src: 
int find_Numb_ways ( int n ) { int odd_indices = n / 2 ; int even_indices = ( n / 2 ) + ( n % 2 ) ; int arr_odd = ( int ) Math . pow ( 4 , odd_indices ) ; int arr_even = ( int ) Math . pow ( 5 , even_indices ) ; return arr_odd * arr_even ; }
Ref: 
def count ( N ) : NEW_LINE INDENT odd_indices = N // 2 NEW_LINE even_indices = N // 2 + N % 2 NEW_LINE arrange_odd = 4 ** odd_indices NEW_LINE arrange_even = 5 ** even_indices NEW_LINE return arrange_odd * arrange_even NEW_LINE DEDENT
Hyp: 
def find_Numb_ways ( n ) : NEW_LINE INDENT odd_indices = n // 2 NEW_LINE even_indices = ( n // 2 ) + ( n % 2 ) NEW_LINE arr_odd = pow ( 4 , odd_indices ) NEW_LINE arr_even = pow ( 5 , even_indices ) NEW_LINE return arr_odd * arr_even NEW_LINE DEDENT

BLEU: 23.52
Edit Sim: 61


Src: 
void findPrimeFactors ( ) { for ( int i = 2 ; i < N ; i ++ ) if ( primeFactors [ i ] == 0 ) for ( int j = i ; j < N ; j += i ) primeFactors [ j ] = primeFactors [ j / i ] + 1 ; for ( int i = 1 ; i < N ; i ++ ) primeFactors [ i ] += primeFactors [ i - 1 ] ; }
Ref: 
def findPrimeFactors ( ) : NEW_LINE INDENT for i in range ( 2 , N ) : NEW_LINE INDENT if ( primeFactors [ i ] == 0 ) : NEW_LINE INDENT for j in range ( i , N , i ) : NEW_LINE INDENT primeFactors [ j ] = primeFactors [ j // i ] + 1 ; NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , N ) : NEW_LINE INDENT primeFactors [ i ] += primeFactors [ i - 1 ] ; NEW_LINE DEDENT DEDENT
Hyp: 
def findPrimeFactors ( ) : NEW_LINE INDENT for i in range ( 2 , N ) : NEW_LINE INDENT if ( primeFactors [ i ] == 0 ) : NEW_LINE INDENT for j in range ( i , N , i ) : NEW_LINE INDENT primeFactors [ j ] = primeFactors [ j // i ] + 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , N ) : NEW_LINE INDENT primeFactors [ i ] += primeFactors [ i - 1 ] NEW_LINE DEDENT DEDENT

BLEU: 92.9
Edit Sim: 11


Src: 
int find_max ( int n , int k ) { int [ ] X = new int [ 32 ] ; int cnt = 0 ; for ( int i = 31 ; i >= 0 && cnt != k ; i -- ) { if ( ( n & ( 1 << i ) ) != 0 ) { X [ i ] = 1 ; cnt ++ ; } } String s = " " ; for ( int i = 31 ; i >= 0 ; i -- ) s += X [ i ] == 0 ? '0' : '1' ; return Integer . parseInt ( s , 2 ) ; }
Ref: 
def find_max ( n , k ) : NEW_LINE INDENT X = [ 0 ] * 32 NEW_LINE cnt = 0 NEW_LINE i = 31 NEW_LINE while ( i >= 0 and cnt != k ) : NEW_LINE INDENT if ( ( n & ( 1 << i ) ) != 0 ) : NEW_LINE INDENT X [ i ] = 1 NEW_LINE cnt += 1 NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT s = " " NEW_LINE for i in range ( 31 , - 1 , - 1 ) : NEW_LINE INDENT if X [ i ] == 0 : NEW_LINE INDENT s += '0' NEW_LINE DEDENT else : NEW_LINE INDENT s += '1' NEW_LINE DEDENT DEDENT return int ( s , 2 ) NEW_LINE DEDENT
Hyp: 
def find_max ( n , k ) : NEW_LINE INDENT X = [ 0 ] * 32 NEW_LINE cnt = 0 NEW_LINE for i in range ( 31 , - 1 , - 1 ) : NEW_LINE INDENT if ( n & ( 1 << i ) ) != 0 : NEW_LINE INDENT X [ i ] = 1 NEW_LINE cnt += 1 NEW_LINE DEDENT DEDENT s = " " NEW_LINE for i in range ( 31 , - 1 , - 1 ) : NEW_LINE INDENT s += X [ i ] if ( 0 ) else ( '1' ) NEW_LINE DEDENT return int ( s , 2 ) NEW_LINE DEDENT

BLEU: 66.9
Edit Sim: 129


Src: 
int findNumberOfStrings ( int n ) { return ( n + 1 ) * ( n + 2 ) * ( n + 3 ) * ( n + 4 ) / 24 ; }
Ref: 
def findNumberOfStrings ( n ) : NEW_LINE INDENT return int ( ( n + 1 ) * ( n + 2 ) * ( n + 3 ) * ( n + 4 ) / 24 ) NEW_LINE DEDENT
Hyp: 
def findNumberOfStrings ( n ) : NEW_LINE INDENT return ( n + 1 ) * ( n + 2 ) * ( n + 3 ) * ( n + 4 ) // 24 NEW_LINE DEDENT

BLEU: 79.91
Edit Sim: 9


Src: 
int firstDigit ( int x ) { while ( x >= 10 ) x = x / 10 ; return x ; }
Ref: 
def firstDigit ( x ) : NEW_LINE INDENT while ( x >= 10 ) : NEW_LINE INDENT x = x // 10 NEW_LINE DEDENT return x NEW_LINE DEDENT
Hyp: 
def firstDigit ( x ) : NEW_LINE INDENT while ( x >= 10 ) : NEW_LINE INDENT x = x // 10 NEW_LINE DEDENT return x NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
boolean checkrules ( String s ) { if ( s . length ( ) == 0 ) return true ; if ( s . charAt ( 0 ) != '1' ) return false ; if ( s . length ( ) > 2 ) { if ( s . charAt ( 1 ) == '0' && s . charAt ( 2 ) == '0' ) return checkrules ( s . substring ( 3 ) ) ; } return checkrules ( s . substring ( 1 ) ) ; }
Ref: 
def checkrules ( s ) : NEW_LINE INDENT if len ( s ) == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT if s [ 0 ] != '1' : NEW_LINE INDENT return False NEW_LINE DEDENT if len ( s ) > 2 : NEW_LINE INDENT if s [ 1 ] == '0' and s [ 2 ] == '0' : NEW_LINE INDENT return checkrules ( s [ 3 : ] ) NEW_LINE DEDENT DEDENT return checkrules ( s [ 1 : ] ) NEW_LINE DEDENT
Hyp: 
def checkrules ( s ) : NEW_LINE INDENT if ( len ( s ) == 0 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT if ( s [ 0 ] != '1' ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT if ( len ( s ) > 2 ) : NEW_LINE INDENT if ( s [ 1 ] == '0' and s [ 2 ] == '0' ) : NEW_LINE INDENT return checkrules ( s [ 3 : ] ) ; NEW_LINE DEDENT DEDENT return checkrules ( s [ 1 : ] ) ; NEW_LINE DEDENT

BLEU: 67.93
Edit Sim: 24


Src: 
int sum ( int A , int B , int R ) { int sum = 0 ; for ( int i = 1 ; i <= R ; i ++ ) { sum = sum + ( i * A ) ; A = A + B ; } return sum ; }
Ref: 
def Sum ( A , B , R ) : NEW_LINE INDENT ssum = 0 NEW_LINE for i in range ( 1 , R + 1 ) : NEW_LINE INDENT ssum = ssum + ( i * A ) NEW_LINE A = A + B NEW_LINE DEDENT return ssum NEW_LINE DEDENT
Hyp: 
def sum ( A , B , R ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , R + 1 ) : NEW_LINE INDENT sum = sum + ( i * A ) NEW_LINE A = A + B NEW_LINE DEDENT return sum NEW_LINE DEDENT

BLEU: 78.15
Edit Sim: 5


Src: 
boolean isPossible ( char [ ] str ) { Map < Character , Integer > freq = new HashMap < > ( ) ; int max_freq = 0 ; for ( int j = 0 ; j < ( str . length ) ; j ++ ) { if ( freq . containsKey ( str [ j ] ) ) { freq . put ( str [ j ] , freq . get ( str [ j ] ) + 1 ) ; if ( freq . get ( str [ j ] ) > max_freq ) max_freq = freq . get ( str [ j ] ) ; } else { freq . put ( str [ j ] , 1 ) ; if ( freq . get ( str [ j ] ) > max_freq ) max_freq = freq . get ( str [ j ] ) ; } } if ( max_freq <= ( str . length - max_freq + 1 ) ) return true ; return false ; }
Ref: 
def isPossible ( Str ) : NEW_LINE INDENT freq = dict ( ) NEW_LINE max_freq = 0 NEW_LINE for j in range ( len ( Str ) ) : NEW_LINE INDENT freq [ Str [ j ] ] = freq . get ( Str [ j ] , 0 ) + 1 NEW_LINE if ( freq [ Str [ j ] ] > max_freq ) : NEW_LINE INDENT max_freq = freq [ Str [ j ] ] NEW_LINE DEDENT DEDENT if ( max_freq <= ( len ( Str ) - max_freq + 1 ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT Str = " geeksforgeeks " NEW_LINE if ( isPossible ( Str ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
Hyp: 
def isPossible ( str ) : NEW_LINE INDENT freq = defaultdict ( int ) NEW_LINE max_freq = 0 NEW_LINE for j in range ( len ( str ) ) : NEW_LINE INDENT if str [ j ] in freq : NEW_LINE INDENT freq [ str [ j ] ] += 1 NEW_LINE if freq [ str [ j ] ] > max_freq : NEW_LINE INDENT max_freq = freq [ str [ j ] ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT freq [ str [ j ] ] = 1 NEW_LINE if freq [ str [ j ] ] > max_freq : NEW_LINE INDENT max_freq = freq [ str [ j ] ] NEW_LINE DEDENT DEDENT DEDENT if max_freq <= ( len ( str ) - max_freq + 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT

BLEU: 49.86
Edit Sim: 244


Src: 
int evenNumSubstring ( String str ) { int len = str . length ( ) ; int count = 0 ; for ( int i = 0 ; i < len ; i ++ ) { int temp = str . charAt ( i ) - '0' ; if ( temp % 2 == 0 ) count += ( i + 1 ) ; } return count ; }
Ref: 
def evenNumSubstring ( str ) : NEW_LINE INDENT length = len ( str ) NEW_LINE count = 0 NEW_LINE for i in range ( 0 , length , 1 ) : NEW_LINE INDENT temp = ord ( str [ i ] ) - ord ( '0' ) NEW_LINE if ( temp % 2 == 0 ) : NEW_LINE INDENT count += ( i + 1 ) NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
Hyp: 
def evenNumSubstring ( str ) : NEW_LINE INDENT ln = len ( str ) NEW_LINE count = 0 NEW_LINE for i in range ( 0 , ln ) : NEW_LINE INDENT temp = ord ( str [ i ] ) - ord ( '0' ) NEW_LINE if ( temp % 2 == 0 ) : NEW_LINE INDENT count += ( i + 1 ) NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT

BLEU: 90.22
Edit Sim: 12


Src: 
void countWays ( int n ) { if ( n <= 2 ) { System . out . print ( " - 1" ) ; } else { int ans = ( n - 1 ) * ( n - 2 ) / 2 ; System . out . print ( ans ) ; } }
Ref: 
def countWays ( N ) : NEW_LINE INDENT if ( N <= 2 ) : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = ( N - 1 ) * ( N - 2 ) / 2 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
Hyp: 
def countWays ( n ) : NEW_LINE INDENT if ( n <= 2 ) : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = ( n - 1 ) * ( n - 2 ) // 2 NEW_LINE print ( ans ) NEW_LINE DEDENT DEDENT

BLEU: 70.24
Edit Sim: 19


Src: 
int findPermutation ( Set < Integer > arr , int N ) { int pos = arr . size ( ) + 1 ; if ( pos > N ) return 1 ; int res = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( ! arr . contains ( i ) ) { if ( i % pos == 0 pos % i == 0 ) { arr . add ( i ) ; res += findPermutation ( arr , N ) ; arr . remove ( i ) ; } } } return res ; }
Ref: 
def findPermutation ( arr , N ) : NEW_LINE INDENT pos = len ( arr ) + 1 NEW_LINE if ( pos > N ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT res = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( i not in arr ) : NEW_LINE INDENT if ( i % pos == 0 or pos % i == 0 ) : NEW_LINE INDENT arr . add ( i ) NEW_LINE res += findPermutation ( arr , N ) NEW_LINE arr . remove ( i ) NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT
Hyp: 
def findPermutation ( arr , N ) : NEW_LINE INDENT pos = len ( arr ) NEW_LINE if ( pos > N ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT res = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( arr [ i ] == None ) : NEW_LINE INDENT if ( i % pos == 0 or pos % i == 0 ) : NEW_LINE INDENT arr . add ( i ) NEW_LINE res += findPermutation ( arr , N ) NEW_LINE DEDENT arr . remove ( i ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT

BLEU: 89.51
Edit Sim: 32


Src: 
int countEvenPairs ( int N , int M ) { int count = 0 ; int nEven = ( int ) Math . floor ( ( double ) N / 2 ) ; int nOdd = ( int ) Math . ceil ( ( double ) N / 2 ) ; int mEven = ( int ) Math . floor ( ( double ) M / 2 ) ; int mOdd = ( int ) Math . ceil ( ( double ) M / 2 ) ; count = nEven * mEven + nOdd * mOdd ; return count ; }
Ref: 
def countEvenPairs ( N , M ) : NEW_LINE INDENT count = 0 ; NEW_LINE nEven = int ( math . floor ( N / 2 ) ) ; NEW_LINE nOdd = int ( math . ceil ( N / 2 ) ) ; NEW_LINE mEven = int ( math . floor ( M / 2 ) ) ; NEW_LINE mOdd = int ( math . ceil ( M / 2 ) ) ; NEW_LINE count = nEven * mEven + nOdd * mOdd ; NEW_LINE return count ; NEW_LINE DEDENT
Hyp: 
def countEvenPairs ( N , M ) : NEW_LINE INDENT count = 0 NEW_LINE nEven = floor ( N / 2 ) NEW_LINE nOdd = ceil ( N / 2 ) NEW_LINE mEven = floor ( M / 2 ) NEW_LINE mOdd = ceil ( M / 2 ) NEW_LINE count = nEven * mEven + nOdd * mOdd NEW_LINE return count NEW_LINE DEDENT

BLEU: 46.87
Edit Sim: 74


Src: 
double pentdiagonal ( double a ) { if ( a < 0 ) return - 1 ; double d = 1.22 * a ; return d ; }
Ref: 
def pentdiagonal ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT d = 1.22 * a NEW_LINE return d NEW_LINE DEDENT
Hyp: 
def pentdiagonal ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT d = 1.22 * a NEW_LINE return d NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int productAtKthLevel ( String tree , int k , int level ) { if ( tree . charAt ( i ++ ) == ' ( ' ) { if ( tree . charAt ( i ) == ' ) ' ) return 1 ; int product = 1 ; if ( level == k ) product = tree . charAt ( i ) - '0' ; ++ i ; int leftproduct = productAtKthLevel ( tree , k , level + 1 ) ; ++ i ; int rightproduct = productAtKthLevel ( tree , k , level + 1 ) ; ++ i ; return product * leftproduct * rightproduct ; } return Integer . MIN_VALUE ; }
Ref: 
def productAtKthLevel ( tree , k , i , level ) : NEW_LINE INDENT if ( tree [ i [ 0 ] ] == ' ( ' ) : NEW_LINE INDENT i [ 0 ] += 1 NEW_LINE if ( tree [ i [ 0 ] ] == ' ) ' ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT product = 1 NEW_LINE if ( level == k ) : NEW_LINE INDENT product = int ( tree [ i [ 0 ] ] ) NEW_LINE DEDENT i [ 0 ] += 1 NEW_LINE leftproduct = productAtKthLevel ( tree , k , i , level + 1 ) NEW_LINE i [ 0 ] += 1 NEW_LINE rightproduct = productAtKthLevel ( tree , k , i , level + 1 ) NEW_LINE i [ 0 ] += 1 NEW_LINE return product * leftproduct * rightproduct NEW_LINE DEDENT DEDENT
Hyp: 
def productAtKthLevel ( tree , k , level ) : NEW_LINE INDENT i = 0 NEW_LINE if ( tree [ i ] == ' ( ' ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( level == k ) : NEW_LINE INDENT product = 1 NEW_LINE if ( level == k ) : NEW_LINE INDENT product = tree [ i ] - ord ( '0' ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT leftproduct = productAtKthLevel ( tree , k , level + 1 ) NEW_LINE i += 1 NEW_LINE rightproduct = productAtKthLevel ( tree , k , level + 1 ) NEW_LINE return product * leftproduct * rightproduct NEW_LINE DEDENT

BLEU: 54.49
Edit Sim: 154


Src: 
boolean isValid ( String str , int len ) { for ( int i = 1 ; i < len ; i ++ ) { if ( str . charAt ( i ) == str . charAt ( i - 1 ) ) return false ; } return true ; }
Ref: 
def isValid ( string , length ) : NEW_LINE INDENT for i in range ( 1 , length ) : NEW_LINE INDENT if string [ i ] == string [ i - 1 ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
Hyp: 
def isValid ( st , l ) : NEW_LINE INDENT for i in range ( 1 , l ) : NEW_LINE INDENT if ( st [ i ] == st [ i - 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT

BLEU: 66.27
Edit Sim: 26


Src: 
long minValue ( int A [ ] , int B [ ] , int n ) { Arrays . sort ( A ) ; Arrays . sort ( B ) ; long result = 0 ; for ( int i = 0 ; i < n ; i ++ ) result += ( A [ i ] * B [ n - i - 1 ] ) ; return result ; }
Ref: 
def minValue ( A , B , n ) : NEW_LINE INDENT A . sort ( ) NEW_LINE B . sort ( ) NEW_LINE result = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT result += ( A [ i ] * B [ n - i - 1 ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT
Hyp: 
def minValue ( A , B , n ) : NEW_LINE INDENT A . sort ( ) NEW_LINE B . sort ( ) NEW_LINE result = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT result += ( A [ i ] * B [ n - i - 1 ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
void printLeaders ( int arr [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) { int j ; for ( j = i + 1 ; j < size ; j ++ ) { if ( arr [ i ] <= arr [ j ] ) break ; } if ( j == size ) System . out . print ( arr [ i ] + " ▁ " ) ; } }
Ref: 
def printLeaders ( arr , size ) : NEW_LINE INDENT for i in range ( 0 , size ) : NEW_LINE INDENT for j in range ( i + 1 , size ) : NEW_LINE INDENT if arr [ i ] <= arr [ j ] : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if j == size - 1 : NEW_LINE INDENT print arr [ i ] , NEW_LINE DEDENT DEDENT DEDENT
Hyp: 
def printLeaders ( arr , size ) : NEW_LINE INDENT for i in range ( 0 , size ) : NEW_LINE INDENT j = i + 1 NEW_LINE while ( j < size ) : NEW_LINE INDENT if ( arr [ i ] <= arr [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( j == size ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT

BLEU: 62.43
Edit Sim: 47


Src: 
boolean isPower ( int n ) { for ( int x = 2 ; x <= ( int ) Math . sqrt ( n ) ; x ++ ) { float f = ( float ) Math . log ( n ) / ( float ) Math . log ( x ) ; if ( ( f - ( int ) f ) == 0.0 ) return true ; } return false ; }
Ref: 
def isPower ( n ) : NEW_LINE INDENT for x in range ( 2 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT f = math . log ( n ) / math . log ( x ) ; NEW_LINE if ( ( f - int ( f ) ) == 0.0 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT DEDENT return False ; NEW_LINE DEDENT for i in range ( 2 , 100 ) : NEW_LINE INDENT if ( isPower ( i ) ) : NEW_LINE INDENT print ( i , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT
Hyp: 
def isPower ( n ) : NEW_LINE INDENT for x in range ( 2 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT f = log ( n ) / log ( x ) NEW_LINE if ( ( f - int ( f ) ) == 0.0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT n = 1 NEW_LINE if isPower ( n ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT

BLEU: 61.58
Edit Sim: 95


Src: 
int count ( int n ) { return 3 * n * ( n - 1 ) + 1 ; }
Ref: 
def count ( n ) : NEW_LINE INDENT return 3 * n * ( n - 1 ) + 1 NEW_LINE DEDENT
Hyp: 
def count ( n ) : NEW_LINE INDENT return 3 * n * ( n - 1 ) + 1 NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
void find ( int N ) { int T , F , O ; F = ( int ) ( ( N - 4 ) / 5 ) ; if ( ( ( N - 5 * F ) % 2 ) == 0 ) { O = 2 ; } else { O = 1 ; } T = ( int ) Math . floor ( ( N - 5 * F - O ) / 2 ) ; System . out . println ( " Count ▁ of ▁ 5 ▁ valueds ▁ coins : ▁ " + F ) ; System . out . println ( " Count ▁ of ▁ 2 ▁ valueds ▁ coins : ▁ " + T ) ; System . out . println ( " Count ▁ of ▁ 1 ▁ valueds ▁ coins : ▁ " + O ) ; }
Ref: 
def find ( N ) : NEW_LINE INDENT F = int ( ( N - 4 ) / 5 ) NEW_LINE if ( ( N - 5 * F ) % 2 ) == 0 : NEW_LINE INDENT O = 2 NEW_LINE DEDENT else : NEW_LINE INDENT O = 1 NEW_LINE DEDENT T = ( N - 5 * F - O ) // 2 NEW_LINE print ( " Count ▁ of ▁ 5 ▁ valueds ▁ coins : ▁ " , F ) NEW_LINE print ( " Count ▁ of ▁ 2 ▁ valueds ▁ coins : ▁ " , T ) NEW_LINE print ( " Count ▁ of ▁ 1 ▁ valueds ▁ coins : ▁ " , O ) NEW_LINE DEDENT
Hyp: 
def find ( N ) : NEW_LINE INDENT T = 0 NEW_LINE F = ( int ) ( ( N - 4 ) / 5 ) NEW_LINE if ( ( N - 5 * F ) % 2 ) == 0 ) : NEW_LINE INDENT O = 2 NEW_LINE DEDENT else : NEW_LINE INDENT O = 1 NEW_LINE DEDENT T = ( int ) ( ( N - 5 * F - O ) / 2 ) NEW_LINE print ( " Count ▁ of ▁ 2 ▁ valueds ▁ coins : " , F ) NEW_LINE print ( " Count ▁ of ▁ 1 ▁ valueds ▁ coins : " , T ) NEW_LINE print ( " Count ▁ of ▁ 2 ▁ valueds ▁ coins : " , O ) NEW_LINE DEDENT

BLEU: 78.42
Edit Sim: 43


Src: 
double kthRoot ( double n , int k ) { return Math . pow ( k , ( 1.0 / k ) * ( Math . log ( n ) / Math . log ( k ) ) ) ; }
Ref: 
def kth_root ( n , k ) : NEW_LINE INDENT return ( pow ( k , ( ( 1.0 / k ) * ( math . log ( n ) / math . log ( k ) ) ) ) ) NEW_LINE DEDENT
Hyp: 
def kthRoot ( n , k ) : NEW_LINE INDENT return pow ( k , ( 1.0 / k ) * ( np . log ( n ) / np . log ( k ) ) ) NEW_LINE DEDENT

BLEU: 67.91
Edit Sim: 18


Src: 
int countDistinct ( int arr [ ] , int n ) { HashSet < Integer > hs = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { hs . add ( arr [ i ] ) ; } return hs . size ( ) ; }
Ref: 
def countDistinct ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] not in s ) : NEW_LINE INDENT s . add ( arr [ i ] ) NEW_LINE res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
Hyp: 
def countDistinct ( arr , n ) : NEW_LINE INDENT hs = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT hs . add ( arr [ i ] ) NEW_LINE DEDENT return len ( hs ) NEW_LINE DEDENT

BLEU: 46.79
Edit Sim: 95


Src: 
boolean ToCheckPowerofX ( int n , int x ) { while ( n > 0 ) { int rem = n % x ; if ( rem >= 2 ) { return false ; } n = n / x ; } return true ; }
Ref: 
def ToCheckPowerofX ( n , x ) : NEW_LINE INDENT while ( n > 0 ) : NEW_LINE INDENT rem = n % x NEW_LINE if ( rem >= 2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT n = n // x NEW_LINE DEDENT return True NEW_LINE DEDENT
Hyp: 
def ToCheckPowerofX ( n , x ) : NEW_LINE INDENT while ( n > 0 ) : NEW_LINE INDENT rem = n % x NEW_LINE if rem >= 2 : NEW_LINE INDENT return False NEW_LINE DEDENT n = n // x NEW_LINE DEDENT return True NEW_LINE DEDENT n = 18 NEW_LINE x = 4 NEW_LINE if ToCheckPowerofX ( n , x ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT

BLEU: 52.78
Edit Sim: 172


Src: 
boolean isPossibleToZero ( int a [ ] , int n ) { int even = 0 , odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( i & 1 ) == 0 ) odd += a [ i ] ; else even += a [ i ] ; } return ( odd == even ) ; }
Ref: 
def isPossibleToZero ( a , n ) : NEW_LINE INDENT even = 0 ; NEW_LINE odd = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i & 1 ) : NEW_LINE INDENT odd += a [ i ] ; NEW_LINE DEDENT else : NEW_LINE INDENT even += a [ i ] ; NEW_LINE DEDENT DEDENT return ( odd == even ) ; NEW_LINE DEDENT arr = [ 0 , 1 , 1 , 0 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE if ( isPossibleToZero ( arr , n ) ) : NEW_LINE INDENT print ( " YES " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) ; NEW_LINE DEDENT
Hyp: 
def isPossibleToZero ( a , n ) : NEW_LINE INDENT even = 0 ; odd = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i & 1 ) : NEW_LINE INDENT odd += a [ i ] ; NEW_LINE DEDENT else : NEW_LINE INDENT even += a [ i ] ; NEW_LINE DEDENT DEDENT return ( odd == even ) ; NEW_LINE DEDENT

BLEU: 43.95
Edit Sim: 219


Src: 
void gcdMax ( int [ ] a , int [ ] b , int n , int N ) { int [ ] cnt = new int [ N ] ; int [ ] first = new int [ N ] ; int [ ] second = new int [ N ] ; for ( int i = 0 ; i < n ; ++ i ) cnt [ a [ i ] ] = 1 ; for ( int i = 1 ; i < N ; ++ i ) for ( int j = i ; j < N ; j += i ) if ( cnt [ j ] > 0 ) first [ i ] = Math . max ( first [ i ] , j ) ; cnt = new int [ N ] ; for ( int i = 0 ; i < n ; ++ i ) cnt [ b [ i ] ] = 1 ; for ( int i = 1 ; i < N ; ++ i ) for ( int j = i ; j < N ; j += i ) if ( cnt [ j ] > 0 ) second [ i ] = Math . max ( second [ i ] , j ) ; int x ; for ( x = N - 1 ; x >= 0 ; x -- ) if ( first [ x ] > 0 && second [ x ] > 0 ) break ; System . out . println ( first [ x ] + " ▁ " + second [ x ] ) ; }
Ref: 
def gcdMax ( a , b , n , N ) : NEW_LINE INDENT cnt = [ 0 ] * N NEW_LINE first = [ 0 ] * N NEW_LINE second = [ 0 ] * N NEW_LINE for i in range ( n ) : NEW_LINE INDENT cnt [ a [ i ] ] = 1 NEW_LINE DEDENT for i in range ( 1 , N ) : NEW_LINE INDENT for j in range ( i , N , i ) : NEW_LINE INDENT if ( cnt [ j ] ) : NEW_LINE INDENT first [ i ] = max ( first [ i ] , j ) NEW_LINE DEDENT DEDENT DEDENT cnt = [ 0 ] * N NEW_LINE for i in range ( n ) : NEW_LINE INDENT cnt [ b [ i ] ] = 1 NEW_LINE DEDENT for i in range ( 1 , N ) : NEW_LINE INDENT for j in range ( i , N , i ) : NEW_LINE INDENT if ( cnt [ j ] > 0 ) : NEW_LINE INDENT second [ i ] = max ( second [ i ] , j ) NEW_LINE DEDENT DEDENT DEDENT i = N - 1 NEW_LINE while i >= 0 : NEW_LINE INDENT if ( first [ i ] > 0 and second [ i ] > 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT print ( str ( first [ i ] ) + " ▁ " + str ( second [ i ] ) ) NEW_LINE DEDENT
Hyp: 
def gcdMax ( a , b , n , N ) : NEW_LINE INDENT cnt = [ 0 ] * N NEW_LINE first = [ 0 ] * N NEW_LINE second = [ 0 ] * N NEW_LINE for i in range ( n ) : NEW_LINE INDENT cnt [ a [ i ] ] = 1 NEW_LINE DEDENT for i in range ( 1 , N ) : NEW_LINE INDENT for j in range ( i , N , i ) : NEW_LINE INDENT if ( cnt [ j ] > 0 ) : NEW_LINE INDENT first [ i ] = max ( first [ i ] , j ) NEW_LINE DEDENT DEDENT cnt = [ 0 ] * N NEW_LINE for i in range ( n ) : NEW_LINE INDENT cnt [ b [ i ] ] = 1 NEW_LINE DEDENT for i in range ( 1 , N ) : NEW_LINE INDENT for j in range ( i , N , i + 1 ) : NEW_LINE INDENT if ( cnt [ j ] > 0 ) : NEW_LINE INDENT second [ i ] = max ( second [ i ] , j ) NEW_LINE DEDENT DEDENT print ( first [ x ] , second [ x ] ) NEW_LINE DEDENT

BLEU: 75.17
Edit Sim: 206


Src: 
char getChar ( String str ) { int sum = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { sum += ( str . charAt ( i ) - ' a ' + 1 ) ; } if ( sum % 26 == 0 ) return ' z ' ; else { sum = sum % 26 ; return ( char ) ( ' a ' + sum - 1 ) ; } }
Ref: 
def getChar ( strr ) : NEW_LINE INDENT summ = 0 NEW_LINE for i in range ( len ( strr ) ) : NEW_LINE INDENT summ += ( ord ( strr [ i ] ) - ord ( ' a ' ) + 1 ) NEW_LINE DEDENT if ( summ % 26 == 0 ) : NEW_LINE INDENT return ord ( ' z ' ) NEW_LINE DEDENT else : NEW_LINE INDENT summ = summ % 26 NEW_LINE return chr ( ord ( ' a ' ) + summ - 1 ) NEW_LINE DEDENT DEDENT
Hyp: 
def getChar ( st ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( len ( st ) ) : NEW_LINE INDENT sum += ord ( st [ i ] ) - ord ( ' a ' ) + 1 ; NEW_LINE DEDENT if ( sum % 26 == 0 ) : NEW_LINE INDENT return ' z ' ; NEW_LINE DEDENT else : NEW_LINE INDENT sum = sum % 26 ; NEW_LINE return ( char ) ( ' a ' + sum - 1 ) ; NEW_LINE DEDENT DEDENT

BLEU: 52.43
Edit Sim: 38


Src: 
int seriesFunc ( int n ) { int sumSquare = ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; int sumNatural = ( n * ( n + 1 ) / 2 ) ; return ( sumSquare + sumNatural + 1 ) ; }
Ref: 
def seriesFunc ( n ) : NEW_LINE INDENT sumSquare = ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 NEW_LINE sumNatural = ( n * ( n + 1 ) / 2 ) NEW_LINE return ( sumSquare + sumNatural + 1 ) NEW_LINE DEDENT
Hyp: 
def seriesFunc ( n ) : NEW_LINE INDENT sumSquare = ( n * ( n + 1 ) * ( 2 * n + 1 ) ) // 6 NEW_LINE sumNatural = ( n * ( n + 1 ) // 2 ) NEW_LINE return ( sumSquare + sumNatural + 1 ) NEW_LINE DEDENT

BLEU: 90.46
Edit Sim: 2


Src: 
int findElement ( int arr [ ] , int n , int key ) { for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == key ) return i ; return - 1 ; }
Ref: 
def findElement ( arr , n , key ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == key ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ 12 , 34 , 10 , 6 , 40 ] NEW_LINE n = len ( arr ) NEW_LINE key = 40 NEW_LINE index = findElement ( arr , n , key ) NEW_LINE if index != - 1 : NEW_LINE INDENT print ( " element ▁ found ▁ at ▁ position : ▁ " + str ( index + 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " element ▁ not ▁ found " ) NEW_LINE DEDENT
Hyp: 
def findElement ( arr , n , key ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] == key ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ 2 , 3 , 4 , 10 , 40 ] NEW_LINE key = 10 NEW_LINE n = len ( arr ) NEW_LINE result = findElement ( arr , n , key ) NEW_LINE if ( result == - 1 ) : NEW_LINE INDENT print ( " Element ▁ is ▁ not ▁ present ▁ in ▁ array " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Element ▁ is ▁ present ▁ at ▁ index " , result ) NEW_LINE DEDENT

BLEU: 65.38
Edit Sim: 113


Src: 
int minValue ( int [ ] arr , int n ) { Arrays . sort ( arr ) ; int minimum = arr [ 0 ] ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + ( arr [ i ] - minimum ) ; } return sum ; }
Ref: 
def minValue ( arr , n ) : NEW_LINE INDENT minimum = min ( arr ) NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = sum + ( arr [ i ] - minimum ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
Hyp: 
def minValue ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE minimum = arr [ 0 ] NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = sum + ( arr [ i ] - minimum ) NEW_LINE DEDENT return sum NEW_LINE DEDENT

BLEU: 78.09
Edit Sim: 32


Src: 
int countPairs ( int X [ ] , int Y [ ] , int m , int n ) { int [ ] suffix = new int [ 1005 ] ; long total_pairs = 0 ; for ( int i = 0 ; i < n ; i ++ ) suffix [ Y [ i ] ] ++ ; for ( int i = ( int ) 1e3 ; i >= 3 ; i -- ) suffix [ i ] += suffix [ i + 1 ] ; for ( int i = 0 ; i < m ; i ++ ) { if ( X [ i ] == 0 ) continue ; else if ( X [ i ] == 1 ) { total_pairs += suffix [ 0 ] ; continue ; } else if ( X [ i ] == 2 ) total_pairs += suffix [ 5 ] ; else if ( X [ i ] == 3 ) total_pairs += suffix [ 2 ] + suffix [ 4 ] ; else total_pairs += suffix [ X [ i ] + 1 ] ; total_pairs += suffix [ 0 ] + suffix [ 1 ] ; } return ( int ) total_pairs ; }
Ref: 
def countPairs ( X , Y , m , n ) : NEW_LINE INDENT suffix = [ 0 ] * 1005 NEW_LINE total_pairs = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT suffix [ Y [ i ] ] += 1 NEW_LINE DEDENT for i in range ( int ( 1e3 ) , 2 , - 1 ) : NEW_LINE INDENT suffix [ i ] += suffix [ i + 1 ] NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT if ( X [ i ] == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT elif ( X [ i ] == 1 ) : NEW_LINE INDENT total_pairs += suffix [ 0 ] NEW_LINE continue NEW_LINE DEDENT elif ( X [ i ] == 2 ) : NEW_LINE INDENT total_pairs += suffix [ 5 ] NEW_LINE DEDENT elif ( X [ i ] == 3 ) : NEW_LINE INDENT total_pairs += ( suffix [ 2 ] + suffix [ 4 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT total_pairs += suffix [ X [ i ] + 1 ] NEW_LINE DEDENT total_pairs += suffix [ 0 ] + suffix [ 1 ] NEW_LINE DEDENT return total_pairs NEW_LINE DEDENT
Hyp: 
def countPairs ( X , Y , m , n ) : NEW_LINE INDENT suffix = [ 0 ] * 1005 NEW_LINE total_pairs = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT suffix [ Y [ i ] ] += 1 NEW_LINE DEDENT for i in range ( 1e3 , - 1 , - 1 ) : NEW_LINE INDENT suffix [ i ] += suffix [ i + 1 ] NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT if ( X [ i ] == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT elif ( X [ i ] == 1 ) : NEW_LINE INDENT total_pairs += suffix [ 0 ] NEW_LINE continue NEW_LINE DEDENT elif ( X [ i ] == 2 ) : NEW_LINE INDENT total_pairs += suffix [ 5 ] NEW_LINE DEDENT elif ( X [ i ] == 3 ) : NEW_LINE INDENT total_pairs += suffix [ 2 ] + suffix [ 4 ] NEW_LINE DEDENT else : NEW_LINE INDENT total_pairs += suffix [ X [ i ] + 1 ] NEW_LINE DEDENT DEDENT return total_pairs NEW_LINE DEDENT

BLEU: 88.23
Edit Sim: 65


Src: 
int printOddFactorNumber ( int n , int m ) { for ( int i = n ; i <= m ; i ++ ) { if ( ( i > 0 ) && ( ( i & ( i - 1 ) ) != 0 ) ) System . out . print ( i + " ▁ " ) ; } return 0 ; }
Ref: 
def printOddFactorNumber ( n , m ) : NEW_LINE INDENT for i in range ( n , m + 1 ) : NEW_LINE INDENT if ( ( i > 0 ) and ( ( i & ( i - 1 ) ) != 0 ) ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
Hyp: 
def printOddFactorNumber ( n , m ) : NEW_LINE INDENT for i in range ( n , m + 1 ) : NEW_LINE INDENT if ( ( i > 0 ) and ( ( i & ( i - 1 ) ) != 0 ) ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT

BLEU: 94.26
Edit Sim: 18


Src: 
void mirrorMatrix ( int mat1 [ ] [ ] , int mat2 [ ] [ ] , int N ) { int row = 0 ; int col = 0 ; boolean isMirrorImage = true ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = N - 1 ; j >= 0 ; j -- ) { if ( mat2 [ row ] [ col ] != mat1 [ i ] [ j ] ) { isMirrorImage = false ; } col ++ ; } col = 0 ; row ++ ; } if ( isMirrorImage ) System . out . print ( " Yes " ) ; else System . out . print ( " No " ) ; }
Ref: 
def mirrorMatrix ( mat1 , mat2 , N ) : NEW_LINE INDENT row = 0 NEW_LINE col = 0 NEW_LINE isMirrorImage = True NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( mat2 [ row ] [ col ] != mat1 [ i ] [ j ] ) : NEW_LINE INDENT isMirrorImage = False NEW_LINE DEDENT col += 1 NEW_LINE DEDENT col = 0 NEW_LINE row += 1 NEW_LINE DEDENT if ( isMirrorImage ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
Hyp: 
def mirrorMatrix ( mat1 , mat2 , N ) : NEW_LINE INDENT row = 0 NEW_LINE col = 0 NEW_LINE isMirrorImage = True NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( mat2 [ row ] [ col ] != mat1 [ i ] [ j ] ) : NEW_LINE INDENT isMirrorImage = False NEW_LINE DEDENT col += 1 NEW_LINE DEDENT row += 1 NEW_LINE DEDENT if ( isMirrorImage ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT

BLEU: 95.34
Edit Sim: 17


Src: 
boolean isRotation ( long x , long y ) { long x64 = x | ( x << 32 ) ; while ( x64 >= y ) { if ( x64 == y ) { return true ; } x64 >>= 1 ; } return false ; }
Ref: 
def isRotation ( x , y ) : NEW_LINE INDENT x64 = x | ( x << 32 ) NEW_LINE while ( x64 >= y ) : NEW_LINE INDENT if ( ( x64 ) == y ) : NEW_LINE INDENT return True NEW_LINE DEDENT x64 >>= 1 NEW_LINE DEDENT return False NEW_LINE DEDENT
Hyp: 
def isRotation ( x , y ) : NEW_LINE INDENT x64 = x | ( x << 32 ) NEW_LINE while ( x64 >= y ) : NEW_LINE INDENT if ( x64 == y ) : NEW_LINE INDENT return True NEW_LINE DEDENT x64 >>= 1 NEW_LINE DEDENT return False NEW_LINE DEDENT x = 18 NEW_LINE if ( isRotation ( x , y ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT

BLEU: 56.52
Edit Sim: 156


Src: 
double expectedSteps ( int x ) { if ( x == 0 ) return 0 ; if ( x <= 5 ) return 6 ; if ( v [ x ] == 1 ) return dp [ x ] ; v [ x ] = 1 ; dp [ x ] = 1 + ( expectedSteps ( x - 1 ) + expectedSteps ( x - 2 ) + expectedSteps ( x - 3 ) + expectedSteps ( x - 4 ) + expectedSteps ( x - 5 ) + expectedSteps ( x - 6 ) ) / 6 ; return dp [ x ] ; }
Ref: 
def expectedSteps ( x ) : NEW_LINE INDENT if ( x == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( x <= 5 ) : NEW_LINE INDENT return 6 NEW_LINE DEDENT if ( v [ x ] ) : NEW_LINE INDENT return dp [ x ] NEW_LINE DEDENT v [ x ] = 1 NEW_LINE dp [ x ] = 1 + ( expectedSteps ( x - 1 ) + expectedSteps ( x - 2 ) + expectedSteps ( x - 3 ) + expectedSteps ( x - 4 ) + expectedSteps ( x - 5 ) + expectedSteps ( x - 6 ) ) / 6 NEW_LINE return dp [ x ] NEW_LINE DEDENT
Hyp: 
def expectedSteps ( x ) : NEW_LINE INDENT if ( x == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( x <= 5 ) : NEW_LINE INDENT return 6 NEW_LINE DEDENT if ( v [ x ] == 1 ) : NEW_LINE INDENT return dp [ x ] NEW_LINE DEDENT v [ x ] = 1 NEW_LINE dp [ x ] = 1 + ( expectedSteps ( x - 1 ) + expectedSteps ( x - 2 ) + expectedSteps ( x - 3 ) + expectedSteps ( x - 4 ) + expectedSteps ( x - 5 ) + expectedSteps ( x - 6 ) ) // 6 NEW_LINE return dp [ x ] NEW_LINE DEDENT

BLEU: 94.94
Edit Sim: 6


Src: 
void printPattern ( String str , int len ) { for ( int i = 0 ; i < len ; i ++ ) { for ( int j = 0 ; j < len ; j ++ ) { if ( ( i == j ) || ( i + j == len - 1 ) ) System . out . print ( str . charAt ( j ) ) ; else System . out . print ( " ▁ " ) ; } System . out . println ( ) ; } }
Ref: 
def printPattern ( Str , Len ) : NEW_LINE INDENT for i in range ( Len ) : NEW_LINE INDENT for j in range ( Len ) : NEW_LINE INDENT if ( ( i == j ) or ( i + j == Len - 1 ) ) : NEW_LINE INDENT print ( Str [ j ] , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " ▁ " , end = " " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT
Hyp: 
def printPattern ( Str1 , len ) : NEW_LINE INDENT for i in range ( 0 , len ) : NEW_LINE INDENT for j in range ( 0 , len ) : NEW_LINE INDENT if ( i == j ) or ( i + j == len - 1 ) : NEW_LINE INDENT print ( Str1 [ j ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " ▁ " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT

BLEU: 65.19
Edit Sim: 42


Src: 
int inversegrayCode ( int n ) { int inv = 0 ; for ( ; n != 0 ; n = n >> 1 ) inv ^= n ; return inv ; }
Ref: 
def inversegrayCode ( n ) : NEW_LINE INDENT inv = 0 ; NEW_LINE while ( n ) : NEW_LINE INDENT inv = inv ^ n ; NEW_LINE n = n >> 1 ; NEW_LINE DEDENT return inv ; NEW_LINE DEDENT
Hyp: 
def inversegrayCode ( n ) : NEW_LINE INDENT inv = 0 NEW_LINE for n in range ( 256 ) : NEW_LINE INDENT inv ^= n NEW_LINE DEDENT return inv NEW_LINE DEDENT

BLEU: 42.78
Edit Sim: 48


Src: 
int maxPartitions ( int arr [ ] , int n ) { int ans = 0 , max_so_far = 0 ; for ( int i = 0 ; i < n ; ++ i ) { max_so_far = Math . max ( max_so_far , arr [ i ] ) ; if ( max_so_far == i ) ans ++ ; } return ans ; }
Ref: 
def maxPartitions ( arr , n ) : NEW_LINE INDENT ans = 0 ; max_so_far = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT max_so_far = max ( max_so_far , arr [ i ] ) NEW_LINE if ( max_so_far == i ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
Hyp: 
def maxPartitions ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE max_so_far = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT max_so_far = max ( max_so_far , arr [ i ] ) NEW_LINE if ( max_so_far == i ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT

BLEU: 89.9
Edit Sim: 12


Src: 
int minimumX ( int n , int k ) { int ans = Integer . MAX_VALUE ; for ( int rem = k - 1 ; rem > 0 ; rem -- ) { if ( n % rem == 0 ) ans = Math . min ( ans , rem + ( n / rem ) * k ) ; } return ans ; }
Ref: 
def minimumX ( n , k ) : NEW_LINE INDENT ans = 10 ** 18 NEW_LINE for i in range ( k - 1 , 0 , - 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT ans = min ( ans , i + ( n / i ) * k ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
Hyp: 
def minimumX ( n , k ) : NEW_LINE INDENT ans = sys . maxsize NEW_LINE rem = k - 1 NEW_LINE while ( rem > 0 ) : NEW_LINE INDENT if ( n % rem == 0 ) : NEW_LINE INDENT ans = min ( ans , rem + ( n // rem ) * k ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT

BLEU: 55.97
Edit Sim: 54


Src: 
int zigzag ( int n , int k ) { if ( n == 0 && k == 0 ) return 1 ; if ( k == 0 ) return 0 ; return zigzag ( n , k - 1 ) + zigzag ( n - 1 , n - k ) ; }
Ref: 
def zigzag ( n , k ) : NEW_LINE INDENT if ( n == 0 and k == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( k == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return zigzag ( n , k - 1 ) + zigzag ( n - 1 , n - k ) ; NEW_LINE DEDENT
Hyp: 
def zigzag ( n , k ) : NEW_LINE INDENT if ( n == 0 and k == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( k == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return zigzag ( n , k - 1 ) + zigzag ( n - 1 , n - k ) NEW_LINE DEDENT

BLEU: 96.37
Edit Sim: 2


Src: 
int highestPowerOf2 ( int n ) { return ( n & ( ~ ( n - 1 ) ) ) ; }
Ref: 
def highestPowerOf2 ( n ) : NEW_LINE INDENT return ( n & ( ~ ( n - 1 ) ) ) NEW_LINE DEDENT
Hyp: 
def highestPowerOf2 ( n ) : NEW_LINE INDENT return ( n & ( ~ ( n - 1 ) ) ) ; NEW_LINE DEDENT

BLEU: 90.16
Edit Sim: 2


Src: 
void equation_ellipse ( float x1 , float y1 , float a , float b , float c , float e ) { float t = a * a + b * b ; float a1 = t - e * ( a * a ) ; float b1 = t - e * ( b * b ) ; float c1 = ( - 2 * t * x1 ) - ( 2 * e * c * a ) ; float d1 = ( - 2 * t * y1 ) - ( 2 * e * c * b ) ; float e1 = - 2 * e * a * b ; float f1 = ( - e * c * c ) + ( t * x1 * x1 ) + ( t * y1 * y1 ) ; System . out . println ( " Equation ▁ of ▁ ellipse ▁ is ▁ " ) ; System . out . print ( a1 + " ▁ x ^ 2 ▁ + ▁ " + b1 + " ▁ y ^ 2 ▁ + ▁ " + c1 + " ▁ x ▁ + ▁ " + d1 + " ▁ y ▁ + ▁ " + e1 + " ▁ xy ▁ + ▁ " + f1 + " ▁ = ▁ 0" ) ; }
Ref: 
def equation_ellipse ( x1 , y1 , a , b , c , e ) : NEW_LINE INDENT t = a * a + b * b NEW_LINE a1 = t - e * ( a * a ) NEW_LINE b1 = t - e * ( b * b ) NEW_LINE c1 = ( - 2 * t * x1 ) - ( 2 * e * c * a ) NEW_LINE d1 = ( - 2 * t * y1 ) - ( 2 * e * c * b ) NEW_LINE e1 = - 2 * e * a * b NEW_LINE f1 = ( - e * c * c ) + ( t * x1 * x1 ) + ( t * y1 * y1 ) NEW_LINE print ( " Equation ▁ of ▁ ellipse ▁ is " , a1 , " x ^ 2 ▁ + " , b1 , " y ^ 2 ▁ + " , c1 , " x ▁ + " , d1 , " y ▁ + " , e1 , " xy ▁ + " , f1 , " = ▁ 0" ) NEW_LINE DEDENT
Hyp: 
def equation_ellipse ( x1 , y1 , a , b , c , e ) : NEW_LINE INDENT t = a * a + b * b NEW_LINE a1 = t - e * ( a * a ) NEW_LINE b1 = t - e * ( b * b ) NEW_LINE c1 = ( - 2 * t * x1 ) - ( 2 * e * c * a ) NEW_LINE d1 = ( - 2 * t * y1 ) - ( 2 * e * c * b ) NEW_LINE e1 = - 2 * e * a * b NEW_LINE f1 = ( - e * c * c ) + ( t * x1 * x1 ) + ( t * y1 * y1 ) NEW_LINE print ( a1 , " ▁ x ^ 2 ▁ + ▁ " , b1 , " ▁ y ^ 2 ▁ + ▁ " , c1 , " ▁ x ▁ + ▁ " , d1 , " ▁ y ▁ + ▁ " , e1 , " ▁ xy ▁ + ▁ " , f1 , " ▁ = ▁ 0" ) NEW_LINE DEDENT

BLEU: 85.34
Edit Sim: 56


Src: 
int countPairs ( int [ ] A , int n ) { int count = 0 , i , j ; for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { if ( ( A [ i ] % 2 == 0 && A [ j ] % 2 == 0 ) || ( A [ i ] % 2 != 0 && A [ j ] % 2 != 0 ) ) count ++ ; } } return count ; }
Ref: 
def countPairs ( A , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( ( A [ i ] % 2 == 0 and A [ j ] % 2 == 0 ) or ( A [ i ] % 2 != 0 and A [ j ] % 2 != 0 ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
Hyp: 
def countPairs ( A , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( ( A [ i ] % 2 == 0 and A [ j ] % 2 == 0 ) or ( A [ i ] % 2 != 0 and A [ j ] % 2 != 0 ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
double vectorMagnitude ( int x , int y , int z ) { int sum = x * x + y * y + z * z ; return Math . sqrt ( sum ) ; }
Ref: 
def vectorMagnitude ( x , y , z ) : NEW_LINE INDENT sum = x * x + y * y + z * z NEW_LINE return sqrt ( sum ) NEW_LINE DEDENT
Hyp: 
def vectorMagnitude ( x , y , z ) : NEW_LINE INDENT sum = x * x + y * y + z * z NEW_LINE return math . sqrt ( sum ) NEW_LINE DEDENT

BLEU: 89.67
Edit Sim: 7


Src: 
void printLastElement ( int arr [ ] , int N ) { boolean leftTurn = true ; int remainElements = N ; int step = 1 ; int head = 1 ; while ( remainElements > 1 ) { if ( leftTurn ) { head = head + step ; } else { if ( remainElements % 2 == 1 ) head = head + step ; } remainElements = remainElements / 2 ; step = step * 2 ; leftTurn = ! leftTurn ; } System . out . print ( arr [ head - 1 ] ) ; }
Ref: 
def printLastElement ( arr , N ) : NEW_LINE INDENT leftTurn = True NEW_LINE remainElements = N NEW_LINE step = 1 NEW_LINE head = 1 NEW_LINE while ( remainElements > 1 ) : NEW_LINE INDENT if ( leftTurn ) : NEW_LINE INDENT head = head + step NEW_LINE DEDENT else : NEW_LINE INDENT if ( remainElements % 2 == 1 ) : NEW_LINE INDENT head = head + step NEW_LINE DEDENT DEDENT remainElements = remainElements // 2 NEW_LINE step = step * 2 NEW_LINE leftTurn = not leftTurn NEW_LINE DEDENT print ( arr [ head - 1 ] ) NEW_LINE DEDENT
Hyp: 
def printLastElement ( arr , N ) : NEW_LINE INDENT leftTurn = True NEW_LINE remainElements = N NEW_LINE step = 1 NEW_LINE head = 1 NEW_LINE while ( remainElements > 1 ) : NEW_LINE INDENT if ( leftTurn ) : NEW_LINE INDENT head = head + step NEW_LINE DEDENT else : NEW_LINE INDENT if ( remainElements % 2 == 1 ) : NEW_LINE INDENT head = head + step NEW_LINE DEDENT remainElements = remainElements // 2 NEW_LINE step = step * 2 NEW_LINE leftTurn = not leftTurn NEW_LINE DEDENT print ( arr [ head - 1 ] ) NEW_LINE DEDENT

BLEU: 98.25
Edit Sim: 7


Src: 
calculate sum ( int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + ( 1 << i ) ; } return sum ; }
Ref: 
def calculateSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum = sum + ( 1 << i ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
Hyp: 
def sum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = sum + ( 1 << i ) NEW_LINE DEDENT return sum NEW_LINE DEDENT

BLEU: 86.08
Edit Sim: 14


Src: 
> Diagonals ( int a , int b , int c , int d ) { Vector < Float > ans = new Vector < Float > ( ) ; ans . add ( ( float ) Math . sqrt ( ( ( a * c ) + ( b * d ) ) * ( ( a * d ) + ( b * c ) ) / ( ( a * b ) + ( c * d ) ) ) ) ; ans . add ( ( float ) Math . sqrt ( ( ( a * c ) + ( b * d ) ) * ( ( a * b ) + ( c * d ) ) / ( ( a * d ) + ( b * c ) ) ) ) ; return ans ; }
Ref: 
def Diagonals ( a , b , c , d ) : NEW_LINE INDENT p = math . sqrt ( ( ( a * c ) + ( b * d ) ) * ( ( a * d ) + ( b * c ) ) / ( ( a * b ) + ( c * d ) ) ) NEW_LINE q = math . sqrt ( ( ( a * c ) + ( b * d ) ) * ( ( a * b ) + ( c * d ) ) / ( ( a * d ) + ( b * c ) ) ) NEW_LINE return [ p , q ] NEW_LINE DEDENT
Hyp: 
def Diagonals ( a , b , c , d ) : NEW_LINE INDENT ans = [ ] NEW_LINE ans . append ( math . sqrt ( ( ( a * c ) + ( b * d ) ) * ( ( a * d ) + ( b * c ) ) / ( ( a * b ) + ( c * d ) ) ) ) NEW_LINE ans . append ( math . sqrt ( ( ( a * c ) + ( b * d ) ) * ( ( a * b ) + ( c * d ) ) / ( ( a * d ) + ( b * c ) ) ) NEW_LINE return ans NEW_LINE DEDENT

BLEU: 85.36
Edit Sim: 55


Src: 
void countSubarrays ( int A [ ] , int N ) { int ans = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( A [ i ] != A [ i + 1 ] ) { ans ++ ; for ( int j = i - 1 , k = i + 2 ; j >= 0 && k < N && A [ j ] == A [ i ] && A [ k ] == A [ i + 1 ] ; j -- , k ++ ) { ans ++ ; } } } System . out . print ( ans + "NEW_LINE"); }
Ref: 
def countSubarrays ( A , N ) : NEW_LINE INDENT ans = 0 ; NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT if ( A [ i ] != A [ i + 1 ] ) : NEW_LINE INDENT ans += 1 ; NEW_LINE j = i - 1 ; k = i + 2 ; NEW_LINE while ( j >= 0 and k < N and A [ j ] == A [ i ] and A [ k ] == A [ i + 1 ] ) : NEW_LINE INDENT ans += 1 ; NEW_LINE j -= 1 ; NEW_LINE k += 1 ; NEW_LINE DEDENT DEDENT DEDENT print ( ans ) ; NEW_LINE DEDENT
Hyp: 
def countSubarrays ( A , N ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT if ( A [ i ] != A [ i + 1 ] ) : NEW_LINE INDENT ans += 1 NEW_LINE for j in range ( i - 1 , i + 2 ) : NEW_LINE INDENT if ( j >= 0 and k < N and A [ j ] == A [ i ] and A [ k ] == A [ i + 1 ] ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE DEDENT

BLEU: 73.85
Edit Sim: 72


Src: 
void printGroups ( int n ) { int x = 1 ; int y = n * n ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n / 2 ; j ++ ) { System . out . print ( " { ▁ " + x + " , ▁ " + y + " } ▁ " ) ; x ++ ; y -- ; } System . out . println ( ) ; } }
Ref: 
def printGroups ( n ) : NEW_LINE INDENT x = 1 NEW_LINE y = n * n NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n // 2 + 1 ) : NEW_LINE INDENT print ( " { " , x , " , " , y , " } " , end = " ▁ " ) NEW_LINE x += 1 NEW_LINE y -= 1 NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT
Hyp: 
def printGroups ( n ) : NEW_LINE INDENT x = 1 NEW_LINE y = n * n NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n // 2 + 1 ) : NEW_LINE INDENT print ( " { ▁ " , x , " , ▁ " , y , " } ▁ " ) NEW_LINE x += 1 NEW_LINE y -= 1 NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT

BLEU: 88.97
Edit Sim: 16


Src: 
int min_noOf_operation ( int arr [ ] , int n , int k ) { int noOfSubtraction ; int res = 0 ; for ( int i = 1 ; i < n ; i ++ ) { noOfSubtraction = 0 ; if ( arr [ i ] > arr [ i - 1 ] ) { noOfSubtraction = ( arr [ i ] - arr [ i - 1 ] ) / k ; if ( ( arr [ i ] - arr [ i - 1 ] ) % k != 0 ) noOfSubtraction ++ ; arr [ i ] = arr [ i ] - k * noOfSubtraction ; } res = res + noOfSubtraction ; } return res ; }
Ref: 
def min_noOf_operation ( arr , n , k ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT noOfSubtraction = 0 NEW_LINE if ( arr [ i ] > arr [ i - 1 ] ) : NEW_LINE INDENT noOfSubtraction = ( arr [ i ] - arr [ i - 1 ] ) / k ; NEW_LINE if ( ( arr [ i ] - arr [ i - 1 ] ) % k != 0 ) : NEW_LINE INDENT noOfSubtraction += 1 NEW_LINE DEDENT arr [ i ] = arr [ i ] - k * noOfSubtraction NEW_LINE DEDENT res = res + noOfSubtraction NEW_LINE DEDENT return int ( res ) NEW_LINE DEDENT
Hyp: 
def min_noOf_operation ( arr , n , k ) : NEW_LINE INDENT noOfSubtraction = 0 NEW_LINE res = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT noOfSubtraction = 0 NEW_LINE if ( arr [ i ] > arr [ i - 1 ] ) : NEW_LINE INDENT noOfSubtraction = ( arr [ i ] - arr [ i - 1 ] ) // k NEW_LINE if ( ( arr [ i ] - arr [ i - 1 ] ) % k != 0 ) : NEW_LINE INDENT noOfSubtraction += 1 NEW_LINE DEDENT arr [ i ] = arr [ i ] - k * noOfSubtraction NEW_LINE DEDENT res = res + noOfSubtraction NEW_LINE DEDENT return res NEW_LINE DEDENT

BLEU: 91.29
Edit Sim: 40


Src: 
int product ( int a [ ] , int n ) { int ans = 1 ; int val = ( int ) Math . pow ( 2 , n - 1 ) ; for ( int i = 0 ; i < n ; i ++ ) { ans *= ( int ) Math . pow ( a [ i ] , val ) ; } return ans ; }
Ref: 
def product ( a , n ) : NEW_LINE INDENT ans = 1 NEW_LINE val = pow ( 2 , n - 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans *= pow ( a [ i ] , val ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
Hyp: 
def product ( a , n ) : NEW_LINE INDENT ans = 1 NEW_LINE val = pow ( 2 , n - 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans *= pow ( a [ i ] , val ) NEW_LINE DEDENT return ans NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int getInvCount ( int n ) { int inv_count = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] > arr [ j ] ) inv_count ++ ; return inv_count ; }
Ref: 
def getInvCount ( arr , n ) : NEW_LINE INDENT inv_count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] ) : NEW_LINE INDENT inv_count += 1 NEW_LINE DEDENT DEDENT DEDENT return inv_count NEW_LINE DEDENT
Hyp: 
def getInvCount ( arr , n ) : NEW_LINE INDENT inv_count = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if arr [ i ] > arr [ j ] : NEW_LINE INDENT inv_count += 1 NEW_LINE DEDENT DEDENT DEDENT return inv_count NEW_LINE DEDENT

BLEU: 89.5
Edit Sim: 8


Src: 
int maxProduct ( int arr [ ] , int n ) { if ( n < 4 ) return - 1 ; Arrays . sort ( arr ) ; int x = arr [ n - 1 ] * arr [ n - 2 ] * arr [ n - 3 ] * arr [ n - 4 ] ; int y = arr [ 0 ] * arr [ 1 ] * arr [ 2 ] * arr [ 3 ] ; int z = arr [ 0 ] * arr [ 1 ] * arr [ n - 1 ] * arr [ n - 2 ] ; return Math . max ( x , Math . max ( y , z ) ) ; }
Ref: 
def maxProduct ( arr , n ) : NEW_LINE INDENT if ( n < 4 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT arr . sort ( ) NEW_LINE x = ( arr [ n - 1 ] * arr [ n - 2 ] * arr [ n - 3 ] * arr [ n - 4 ] ) NEW_LINE y = arr [ 0 ] * arr [ 1 ] * arr [ 2 ] * arr [ 3 ] NEW_LINE z = ( arr [ 0 ] * arr [ 1 ] * arr [ n - 1 ] * arr [ n - 2 ] ) NEW_LINE return max ( x , max ( y , z ) ) NEW_LINE DEDENT
Hyp: 
def maxProduct ( arr , n ) : NEW_LINE INDENT if ( n < 4 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT arr . sort ( ) NEW_LINE x = arr [ n - 1 ] * arr [ n - 2 ] * arr [ n - 3 ] * arr [ n - 4 ] NEW_LINE y = arr [ 0 ] * arr [ 1 ] * arr [ 2 ] * arr [ 3 ] NEW_LINE z = arr [ 0 ] * arr [ 1 ] * arr [ n - 1 ] * arr [ n - 2 ] NEW_LINE return max ( x , max ( y , z ) ) NEW_LINE DEDENT

BLEU: 91.89
Edit Sim: 8


Src: 
int heptacontagonNum ( int n ) { return ( 68 * n * n - 66 * n ) / 2 ; }
Ref: 
def heptacontagonNum ( n ) : NEW_LINE INDENT return ( 68 * n * n - 66 * n ) // 2 ; NEW_LINE DEDENT
Hyp: 
def heptacontagonNum ( n ) : NEW_LINE INDENT return ( 68 * n * n - 66 * n ) // 2 NEW_LINE DEDENT

BLEU: 90.59
Edit Sim: 2


Src: 
int minSum ( Integer arr [ ] , int n ) { int sum = 0 ; Arrays . sort ( arr , Collections . reverseOrder ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 4 < 2 ) sum = sum + arr [ i ] ; } return sum ; }
Ref: 
def minSum ( arr , n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE arr . sort ( reverse = True ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i % 4 < 2 ) : NEW_LINE INDENT sum += arr [ i ] ; NEW_LINE DEDENT DEDENT return sum ; NEW_LINE DEDENT
Hyp: 
def minSum ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE arr . sort ( reverse = True ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i % 4 < 2 ) : NEW_LINE INDENT sum = sum + arr [ i ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT

BLEU: 83.16
Edit Sim: 13


Src: 
int square ( int n ) { if ( n < 0 ) n = - n ; int res = n ; for ( int i = 1 ; i < n ; i ++ ) res += n ; return res ; }
Ref: 
def square ( n ) : NEW_LINE INDENT if ( n < 0 ) : NEW_LINE INDENT n = - n NEW_LINE DEDENT res = n NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT res += n NEW_LINE DEDENT return res NEW_LINE DEDENT for n in range ( 1 , 6 ) : NEW_LINE INDENT print ( " n ▁ = " , n , end = " , ▁ " ) NEW_LINE print ( " n ^ 2 ▁ = " , square ( n ) ) NEW_LINE DEDENT
Hyp: 
def square ( n ) : NEW_LINE INDENT if ( n < 0 ) : NEW_LINE INDENT n = - n NEW_LINE DEDENT res = n NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT res += n NEW_LINE DEDENT return res NEW_LINE DEDENT

BLEU: 37.56
Edit Sim: 147


Src: 
void modifiedBinaryPattern ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) { if ( j == 1 j == i ) System . out . print ( 1 ) ; else System . out . print ( 0 ) ; } System . out . println ( ) ; } }
Ref: 
def modifiedBinaryPattern ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 , 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 , 1 ) : NEW_LINE INDENT if ( j == 1 or j == i ) : NEW_LINE INDENT print ( 1 , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 , end = " " ) NEW_LINE DEDENT DEDENT print ( ' ' , end = " " ) NEW_LINE DEDENT DEDENT
Hyp: 
def modifiedBinaryPattern ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT if ( j == 1 or j == i ) : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT

BLEU: 68.14
Edit Sim: 48


Src: 
int countDyckPaths ( int n ) { int res = 1 ; for ( int i = 0 ; i < n ; ++ i ) { res *= ( 2 * n - i ) ; res /= ( i + 1 ) ; } return res / ( n + 1 ) ; }
Ref: 
def countDyckPaths ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT res *= ( 2 * n - i ) NEW_LINE res /= ( i + 1 ) NEW_LINE DEDENT return res / ( n + 1 ) NEW_LINE DEDENT
Hyp: 
def countDyckPaths ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT res *= ( 2 * n - i ) NEW_LINE res //= ( i + 1 ) NEW_LINE DEDENT return res // ( n + 1 ) NEW_LINE DEDENT

BLEU: 83.36
Edit Sim: 6


Src: 
int findTrailingZeros ( int n ) { int count = 0 ; for ( int i = 5 ; n / i >= 1 ; i *= 5 ) count += n / i ; return count ; }
Ref: 
def findTrailingZeros ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n >= 5 ) : NEW_LINE INDENT n //= 5 NEW_LINE count += n NEW_LINE DEDENT return count NEW_LINE DEDENT
Hyp: 
def findTrailingZeros ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 5 , n // i + 1 ) : NEW_LINE INDENT count += n // i NEW_LINE DEDENT return count NEW_LINE DEDENT

BLEU: 52.03
Edit Sim: 45


Src: 
boolean isLoeschian ( int n ) { for ( int x = 1 ; x <= Math . sqrt ( n ) ; x ++ ) { for ( int y = 1 ; y <= Math . sqrt ( n ) ; y ++ ) { if ( x * x + x * y + y * y == n ) return true ; } } return false ; }
Ref: 
def isLoeschian ( n ) : NEW_LINE INDENT for x in range ( 1 , ( int ) ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT for y in range ( 1 , ( int ) ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( x * x + x * y + y * y == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT N = 19 NEW_LINE if ( isLoeschian ( N ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
Hyp: 
def isLoeschian ( n ) : NEW_LINE INDENT for x in range ( 1 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT for y in range ( 1 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( x * x + x * y + y * y == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT n = 25 NEW_LINE if isLoeschian ( n ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT

BLEU: 79.41
Edit Sim: 30


Src: 
int findCount ( int m , int n ) { int num1 = 0 ; for ( int i = 0 ; i < m ; i ++ ) num1 = ( num1 * 10 ) + 9 ; int num2 = 0 ; for ( int i = 0 ; i < ( m - 1 ) ; i ++ ) num2 = ( num2 * 10 ) + 9 ; return ( ( num1 / n ) - ( num2 / n ) ) ; }
Ref: 
def findCount ( m , n ) : NEW_LINE INDENT num1 = 0 NEW_LINE for i in range ( 0 , m ) : NEW_LINE INDENT num1 = ( num1 * 10 ) + 9 NEW_LINE DEDENT num2 = 0 NEW_LINE for i in range ( 0 , ( m - 1 ) ) : NEW_LINE INDENT num2 = ( num2 * 10 ) + 9 NEW_LINE DEDENT return int ( ( num1 / n ) - ( num2 / n ) ) NEW_LINE DEDENT
Hyp: 
def findCount ( m , n ) : NEW_LINE INDENT num1 = 0 ; NEW_LINE for i in range ( m ) : NEW_LINE INDENT num1 = ( num1 * 10 ) + 9 ; NEW_LINE DEDENT num2 = 0 ; NEW_LINE for i in range ( ( m - 1 ) ) : NEW_LINE INDENT num2 = ( num2 * 10 ) + 9 ; NEW_LINE DEDENT return ( ( num1 // n ) - ( num2 // n ) ) ; NEW_LINE DEDENT

BLEU: 72.9
Edit Sim: 24


Src: 
void flipBitsOfAandB ( int A , int B ) { for ( int i = 0 ; i < 32 ; i ++ ) { if ( ( ( A & ( 1 << i ) ) & ( B & ( 1 << i ) ) ) != 0 ) { A = A ^ ( 1 << i ) ; B = B ^ ( 1 << i ) ; } } System . out . print ( A + " ▁ " + B ) ; }
Ref: 
def flipBitsOfAandB ( A , B ) : NEW_LINE INDENT for i in range ( 0 , 32 ) : NEW_LINE INDENT if ( ( A & ( 1 << i ) ) and ( B & ( 1 << i ) ) ) : NEW_LINE INDENT A = A ^ ( 1 << i ) NEW_LINE B = B ^ ( 1 << i ) NEW_LINE DEDENT DEDENT print ( A , B ) NEW_LINE DEDENT
Hyp: 
def flipBitsOfAandB ( A , B ) : NEW_LINE INDENT for i in range ( 32 ) : NEW_LINE INDENT if ( ( A & ( 1 << i ) ) & ( B & ( 1 << i ) ) != 0 ) : NEW_LINE INDENT A = A ^ ( 1 << i ) NEW_LINE B = B ^ ( 1 << i ) NEW_LINE DEDENT DEDENT print ( A , B ) NEW_LINE DEDENT

BLEU: 90.31
Edit Sim: 12


Src: 
int chiliagonNum ( int n ) { return ( 998 * n * n - 996 * n ) / 2 ; }
Ref: 
def chiliagonNum ( n ) : NEW_LINE INDENT return ( 998 * n * n - 996 * n ) // 2 ; NEW_LINE DEDENT
Hyp: 
def chiliagonNum ( n ) : NEW_LINE INDENT return ( 998 * n * n - 996 * n ) // 2 NEW_LINE DEDENT

BLEU: 90.59
Edit Sim: 2


Src: 
String lexNext ( String str , int n ) { char [ ] s = str . toCharArray ( ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( s [ i ] != ' z ' ) { s [ i ] ++ ; return String . valueOf ( s ) ; } s [ i ] = ' a ' ; } return null ; }
Ref: 
def lexNext ( s , n ) : NEW_LINE INDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if s [ i ] != ' z ' : NEW_LINE INDENT k = ord ( s [ i ] ) NEW_LINE s [ i ] = chr ( k + 1 ) NEW_LINE return ' ' . join ( s ) NEW_LINE DEDENT DEDENT s [ i ] = ' a ' NEW_LINE DEDENT
Hyp: 
def lexNext ( s , n ) : NEW_LINE INDENT t = " " NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( t != ' z ' ) : NEW_LINE INDENT t += 1 NEW_LINE return t NEW_LINE DEDENT s [ i ] = ' a ' NEW_LINE DEDENT return null NEW_LINE DEDENT

BLEU: 49.98
Edit Sim: 100


Src: 
void largestSquare ( int matrix [ ] [ ] , int R , int C , int q_i [ ] , int q_j [ ] , int K , int Q ) { for ( int q = 0 ; q < Q ; q ++ ) { int i = q_i [ q ] ; int j = q_j [ q ] ; int min_dist = Math . min ( Math . min ( i , j ) , Math . min ( R - i - 1 , C - j - 1 ) ) ; int ans = - 1 ; for ( int k = 0 ; k <= min_dist ; k ++ ) { int count = 0 ; for ( int row = i - k ; row <= i + k ; row ++ ) for ( int col = j - k ; col <= j + k ; col ++ ) count += matrix [ row ] [ col ] ; if ( count > K ) break ; ans = 2 * k + 1 ; } System . out . print ( ans + "NEW_LINE"); } }
Ref: 
def largestSquare ( matrix , R , C , q_i , q_j , K , Q ) : NEW_LINE INDENT for q in range ( Q ) : NEW_LINE INDENT i = q_i [ q ] NEW_LINE j = q_j [ q ] NEW_LINE min_dist = min ( min ( i , j ) , min ( R - i - 1 , C - j - 1 ) ) NEW_LINE ans = - 1 NEW_LINE for k in range ( min_dist + 1 ) : NEW_LINE INDENT count = 0 NEW_LINE for row in range ( i - k , i + k + 1 ) : NEW_LINE INDENT for col in range ( j - k , j + k + 1 ) : NEW_LINE INDENT count += matrix [ row ] [ col ] NEW_LINE DEDENT DEDENT if count > K : NEW_LINE INDENT break NEW_LINE DEDENT ans = 2 * k + 1 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT DEDENT
Hyp: 
def largestSquare ( matrix , R , C , q_i , q_j , K , Q ) : NEW_LINE INDENT for q in range ( Q ) : NEW_LINE INDENT i = q_i [ q ] NEW_LINE j = q_j [ q ] NEW_LINE min_dist = min ( min ( i , j ) , min ( R - i - 1 , C - j - 1 ) ) NEW_LINE ans = - 1 NEW_LINE for k in range ( min_dist ) : NEW_LINE INDENT count = 0 NEW_LINE for row in range ( i - k , i + k + 1 ) : NEW_LINE INDENT for col in range ( j - k , j + k ) : NEW_LINE INDENT count += matrix [ row ] [ col ] NEW_LINE DEDENT DEDENT if ( count > K ) : NEW_LINE INDENT break NEW_LINE DEDENT ans = 2 * k + 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT

BLEU: 93.26
Edit Sim: 26


Src: 
boolean checkSorted ( int n , int arr [ ] ) { int [ ] b = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) b [ i ] = arr [ i ] ; Arrays . sort ( b , 0 , n ) ; int ct = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] != b [ i ] ) ct ++ ; if ( ct == 0 ct == 2 ) return true ; else return false ; }
Ref: 
def checkSorted ( n , arr ) : NEW_LINE INDENT b = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT b . append ( arr [ i ] ) NEW_LINE DEDENT b . sort ( ) NEW_LINE ct = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] != b [ i ] : NEW_LINE INDENT ct += 1 NEW_LINE DEDENT DEDENT if ct == 0 or ct == 2 : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
Hyp: 
def checkSorted ( n , arr ) : NEW_LINE INDENT b = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT b [ i ] = arr [ i ] NEW_LINE DEDENT b . sort ( ) NEW_LINE ct = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] != b [ i ] ) : NEW_LINE INDENT ct += 1 NEW_LINE DEDENT DEDENT if ( ct == 0 or ct == 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT

BLEU: 80.55
Edit Sim: 24


Src: 
void ReplaceElements ( int [ ] arr , int n ) { if ( n <= 1 ) return ; int prev = arr [ 0 ] ; arr [ 0 ] = arr [ 0 ] ^ arr [ 1 ] ; for ( int i = 1 ; i < n - 1 ; i ++ ) { int curr = arr [ i ] ; arr [ i ] = prev ^ arr [ i + 1 ] ; prev = curr ; } arr [ n - 1 ] = prev ^ arr [ n - 1 ] ; }
Ref: 
def ReplaceElements ( arr , n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return NEW_LINE DEDENT prev = arr [ 0 ] NEW_LINE arr [ 0 ] = arr [ 0 ] ^ arr [ 1 ] NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT curr = arr [ i ] NEW_LINE arr [ i ] = prev ^ arr [ i + 1 ] NEW_LINE prev = curr NEW_LINE DEDENT arr [ n - 1 ] = prev ^ arr [ n - 1 ] NEW_LINE DEDENT arr = [ 2 , 3 , 4 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE ReplaceElements ( arr , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT
Hyp: 
def ReplaceElements ( arr , n ) : NEW_LINE INDENT if ( n <= 1 ) : return 0 NEW_LINE prev = arr [ 0 ] NEW_LINE arr [ 0 ] = arr [ 0 ] ^ arr [ 1 ] NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT curr = arr [ i ] NEW_LINE arr [ i ] = prev ^ arr [ i + 1 ] NEW_LINE prev = curr NEW_LINE DEDENT arr [ n - 1 ] = prev ^ arr [ n - 1 ] NEW_LINE DEDENT arr [ n - 1 ] = prev ^ arr [ n - 1 ] NEW_LINE DEDENT arr = [ 11 , 15 , 6 , 8 , 9 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Modified ▁ array ▁ is " ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT

BLEU: 73.96
Edit Sim: 118


Src: 
void no_of_moves ( int [ ] [ ] Matrix , int x , int y ) { int moves = 0 ; for ( int i = 0 ; i < M ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( Matrix [ i ] [ j ] != 0 ) { moves += Math . abs ( x - i ) ; moves += Math . abs ( y - j ) ; } } } System . out . println ( moves ) ; }
Ref: 
def no_of_moves ( Matrix , x , y ) : NEW_LINE INDENT moves = 0 NEW_LINE for i in range ( M ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if ( Matrix [ i ] [ j ] != 0 ) : NEW_LINE INDENT moves += abs ( x - i ) NEW_LINE moves += abs ( y - j ) NEW_LINE DEDENT DEDENT DEDENT print ( moves ) NEW_LINE DEDENT
Hyp: 
def no_of_moves ( Matrix , x , y ) : NEW_LINE INDENT moves = 0 NEW_LINE for i in range ( M ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if ( Matrix [ i ] [ j ] != 0 ) : NEW_LINE INDENT moves += abs ( x - i ) NEW_LINE moves += abs ( y - j ) NEW_LINE DEDENT DEDENT DEDENT print ( moves ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
String isPossible ( int arr [ ] , int n ) { int mini = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) mini = Math . min ( mini , arr [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == mini ) continue ; int Max = ( arr [ i ] + 1 ) / 2 - 1 ; if ( mini < 0 mini > Max ) return " No " ; } return " Yes " ; }
Ref: 
def isPossible ( arr , n ) : NEW_LINE INDENT mini = sys . maxsize NEW_LINE for i in range ( n ) : NEW_LINE INDENT mini = min ( mini , arr [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == mini ) : NEW_LINE INDENT continue NEW_LINE DEDENT Max = ( arr [ i ] + 1 ) // 2 - 1 NEW_LINE if ( mini < 0 or mini > Max ) : NEW_LINE INDENT return " No " NEW_LINE DEDENT DEDENT return " Yes " NEW_LINE DEDENT
Hyp: 
def isPossible ( arr , n ) : NEW_LINE INDENT mini = sys . maxsize NEW_LINE for i in range ( n ) : NEW_LINE INDENT mini = min ( mini , arr [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == mini ) : NEW_LINE INDENT continue NEW_LINE DEDENT Max = ( arr [ i ] + 1 ) // 2 - 1 NEW_LINE if ( mini < 0 or mini > Max ) : NEW_LINE INDENT return " No " NEW_LINE DEDENT DEDENT return " Yes " NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
void largestSquare ( int matrix [ ] [ ] , int R , int C , int q_i [ ] , int q_j [ ] , int K , int Q ) { int [ ] [ ] countDP = new int [ R ] [ C ] ; countDP [ 0 ] [ 0 ] = matrix [ 0 ] [ 0 ] ; for ( int i = 1 ; i < R ; i ++ ) countDP [ i ] [ 0 ] = countDP [ i - 1 ] [ 0 ] + matrix [ i ] [ 0 ] ; for ( int j = 1 ; j < C ; j ++ ) countDP [ 0 ] [ j ] = countDP [ 0 ] [ j - 1 ] + matrix [ 0 ] [ j ] ; for ( int i = 1 ; i < R ; i ++ ) for ( int j = 1 ; j < C ; j ++ ) countDP [ i ] [ j ] = matrix [ i ] [ j ] + countDP [ i - 1 ] [ j ] + countDP [ i ] [ j - 1 ] - countDP [ i - 1 ] [ j - 1 ] ; for ( int q = 0 ; q < Q ; q ++ ) { int i = q_i [ q ] ; int j = q_j [ q ] ; int min_dist = Math . min ( Math . min ( i , j ) , Math . min ( R - i - 1 , C - j - 1 ) ) ; int ans = - 1 ; for ( int k = 0 ; k <= min_dist ; k ++ ) { int x1 = i - k , x2 = i + k ; int y1 = j - k , y2 = j + k ; int count = countDP [ x2 ] [ y2 ] ; if ( x1 > 0 ) count -= countDP [ x1 - 1 ] [ y2 ] ; if ( y1 > 0 ) count -= countDP [ x2 ] [ y1 - 1 ] ; if ( x1 > 0 && y1 > 0 ) count += countDP [ x1 - 1 ] [ y1 - 1 ] ; if ( count > K ) break ; ans = 2 * k + 1 ; } System . out . print ( ans + "NEW_LINE"); } }
Ref: 
def largestSquare ( matrix , R , C , q_i , q_j , K , Q ) : NEW_LINE INDENT countDP = [ [ 0 for x in range ( C ) ] for x in range ( R ) ] NEW_LINE countDP [ 0 ] [ 0 ] = matrix [ 0 ] [ 0 ] NEW_LINE for i in range ( 1 , R ) : NEW_LINE INDENT countDP [ i ] [ 0 ] = ( countDP [ i - 1 ] [ 0 ] + matrix [ i ] [ 0 ] ) NEW_LINE DEDENT for j in range ( 1 , C ) : NEW_LINE INDENT countDP [ 0 ] [ j ] = ( countDP [ 0 ] [ j - 1 ] + matrix [ 0 ] [ j ] ) NEW_LINE DEDENT for i in range ( 1 , R ) : NEW_LINE INDENT for j in range ( 1 , C ) : NEW_LINE INDENT countDP [ i ] [ j ] = ( matrix [ i ] [ j ] + countDP [ i - 1 ] [ j ] + countDP [ i ] [ j - 1 ] - countDP [ i - 1 ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT for q in range ( 0 , Q ) : NEW_LINE INDENT i = q_i [ q ] NEW_LINE j = q_j [ q ] NEW_LINE min_dist = min ( i , j , R - i - 1 , C - j - 1 ) NEW_LINE ans = - 1 NEW_LINE for k in range ( 0 , min_dist + 1 ) : NEW_LINE INDENT x1 = i - k NEW_LINE x2 = i + k NEW_LINE y1 = j - k NEW_LINE y2 = j + k NEW_LINE count = countDP [ x2 ] [ y2 ] ; NEW_LINE if ( x1 > 0 ) : NEW_LINE INDENT count -= countDP [ x1 - 1 ] [ y2 ] NEW_LINE DEDENT if ( y1 > 0 ) : NEW_LINE INDENT count -= countDP [ x2 ] [ y1 - 1 ] NEW_LINE DEDENT if ( x1 > 0 and y1 > 0 ) : NEW_LINE INDENT count += countDP [ x1 - 1 ] [ y1 - 1 ] NEW_LINE DEDENT if ( count > K ) : NEW_LINE INDENT break NEW_LINE DEDENT ans = 2 * k + 1 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT DEDENT
Hyp: 
def largestSquare ( matrix , R , C , q_i , q_j , K , Q ) : NEW_LINE INDENT countDP = [ [ 0 for x in range ( C + 1 ) ] for y in range ( R + 1 ) ] NEW_LINE for i in range ( R ) : NEW_LINE INDENT countDP [ i ] [ 0 ] = matrix [ 0 ] [ 0 ] NEW_LINE DEDENT for j in range ( 1 , C + 1 ) : NEW_LINE INDENT countDP [ i ] [ j ] = countDP [ 0 ] [ j - 1 ] + matrix [ 0 ] [ j ] NEW_LINE DEDENT for i in range ( 1 , R + 1 ) : NEW_LINE INDENT for j in range ( 1 , C + 1 ) : NEW_LINE INDENT countDP [ i ] [ j ] = matrix [ i ] [ j ] + countDP [ i - 1 ] [ j - 1 ] - countDP [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT DEDENT for q in range ( Q ) : NEW_LINE INDENT x1 = q_i [ q ] NEW_LINE x2 = i + k NEW_LINE y1 = j + k NEW_LINE count = countDP [ x2 ] [ y2 ] NEW_LINE if ( x1 > 0 and y1 > 0 ) : NEW_LINE INDENT count -= countDP [ x1 - 1 ] [ y1 - 1 ] NEW_LINE DEDENT if ( count > K ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( ans , end = " " ) NEW_LINE DEDENT DEDENT

BLEU: 52.41
Edit Sim: 536


Src: 
void findWinner ( int X , int Y ) { int first = ( X ^ Y ) ; int second = ( X + Y ) ; if ( first == second ) { System . out . println ( " No " ) ; } else { System . out . println ( " Yes " ) ; } }
Ref: 
def findWinner ( X , Y ) : NEW_LINE INDENT first = ( X ^ Y ) NEW_LINE second = ( X + Y ) NEW_LINE if ( first == second ) : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT DEDENT
Hyp: 
def findWinner ( X , Y ) : NEW_LINE INDENT first = ( X ^ Y ) NEW_LINE second = ( X + Y ) NEW_LINE if ( first == second ) : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int FindIndexKthBit ( int n , int k ) { int cnt = 0 ; int ind = 0 ; while ( n > 0 ) { if ( ( n & 1 ) != 0 ) cnt ++ ; if ( cnt == k ) return ind ; ind ++ ; n = n >> 1 ; } return - 1 ; }
Ref: 
def FindIndexKthBit ( n , k ) : NEW_LINE INDENT cnt , ind = 0 , 0 NEW_LINE while n > 0 : NEW_LINE INDENT if n & 1 : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT if cnt == k : NEW_LINE INDENT return ind NEW_LINE DEDENT ind += 1 NEW_LINE n = n >> 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
Hyp: 
def FindIndexKthBit ( n , k ) : NEW_LINE INDENT cnt = 0 NEW_LINE ind = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT if ( n & 1 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT if ( cnt == k ) : NEW_LINE INDENT return ind NEW_LINE ind += 1 NEW_LINE n = n >> 1 NEW_LINE DEDENT return - 1 ; NEW_LINE DEDENT n = 18 NEW_LINE k = 4 NEW_LINE if ( FindIndexKthBit ( n , k ) ) : NEW_LINE INDENT print ( " Element ▁ is ▁ not ▁ present ▁ in ▁ array " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Element ▁ is ▁ present ▁ in ▁ array " ) NEW_LINE DEDENT

BLEU: 35.06
Edit Sim: 275


Src: 
int minDel ( String s1 , String s2 ) { int i = s1 . length ( ) ; int j = s2 . length ( ) ; while ( i > 0 && j > 0 ) { if ( s1 . charAt ( i - 1 ) != s2 . charAt ( j - 1 ) ) { break ; } i -- ; j -- ; } return i + j ; }
Ref: 
def minDel ( s1 , s2 ) : NEW_LINE INDENT i = len ( s1 ) NEW_LINE j = len ( s2 ) NEW_LINE while ( i > 0 and j > 0 ) : NEW_LINE INDENT if ( s1 [ i - 1 ] != s2 [ j - 1 ] ) : NEW_LINE INDENT break NEW_LINE DEDENT i -= 1 NEW_LINE j -= 1 NEW_LINE DEDENT return i + j NEW_LINE DEDENT
Hyp: 
def minDel ( s1 , s2 ) : NEW_LINE INDENT i = len ( s1 ) NEW_LINE j = len ( s2 ) NEW_LINE while ( i > 0 and j > 0 ) : NEW_LINE INDENT if ( s1 [ i - 1 ] != s2 [ j - 1 ] ) : NEW_LINE INDENT break NEW_LINE DEDENT i -= 1 NEW_LINE j -= 1 NEW_LINE DEDENT return i + j NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
float polyarea ( float n , float a ) { if ( a < 0 && n < 0 ) return - 1 ; float A = ( a * a * n ) / ( float ) ( 4 * Math . tan ( ( 180 / n ) * 3.14159 / 180 ) ) ; return A ; }
Ref: 
def polyarea ( n , a ) : NEW_LINE INDENT if ( a < 0 and n < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT A = ( a * a * n ) / ( 4 * tan ( ( 180 / n ) * 3.14159 / 180 ) ) NEW_LINE return A NEW_LINE DEDENT
Hyp: 
def polyarea ( n , a ) : NEW_LINE INDENT if ( a < 0 and n < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT A = ( a * a * n ) / ( 4 * tan ( ( 180 / n ) * 3.14159 / 180 ) ) NEW_LINE return A NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int printCountDP ( int dist ) { int [ ] ways = new int [ 3 ] ; int n = dist ; ways [ 0 ] = 1 ; ways [ 1 ] = 1 ; ways [ 2 ] = 2 ; for ( int i = 3 ; i <= n ; i ++ ) ways [ i % 3 ] = ways [ ( i - 1 ) % 3 ] + ways [ ( i - 2 ) % 3 ] + ways [ ( i - 3 ) % 3 ] ; return ways [ n % 3 ] ; }
Ref: 
def prCountDP ( dist ) : NEW_LINE INDENT ways = [ 0 ] * 3 NEW_LINE n = dist NEW_LINE ways [ 0 ] = 1 NEW_LINE ways [ 1 ] = 1 NEW_LINE ways [ 2 ] = 2 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT ways [ i % 3 ] = ways [ ( i - 1 ) % 3 ] + ways [ ( i - 2 ) % 3 ] + ways [ ( i - 3 ) % 3 ] NEW_LINE DEDENT return ways [ n % 3 ] NEW_LINE DEDENT
Hyp: 
def printCountDP ( dist ) : NEW_LINE INDENT ways = [ 0 for i in range ( 3 ) ] NEW_LINE n = dist NEW_LINE ways [ 0 ] = 1 NEW_LINE ways [ 1 ] = 1 NEW_LINE ways [ 2 ] = 2 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT ways [ i % 3 ] = ways [ ( i - 1 ) % 3 ] + ways [ ( i - 2 ) % 3 ] + ways [ ( i - 3 ) % 3 ] NEW_LINE DEDENT return ways [ n % 3 ] NEW_LINE DEDENT

BLEU: 90.14
Edit Sim: 22


Src: 
int longestGP ( int A [ ] , int N ) { if ( N < 2 ) return N ; int length = 1 , common_ratio = 1 ; int maxlength = 1 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( A [ i + 1 ] % A [ i ] == 0 ) { if ( A [ i + 1 ] / A [ i ] == common_ratio ) { length = length + 1 ; maxlength = Math . max ( maxlength , length ) ; } else { common_ratio = A [ i + 1 ] / A [ i ] ; length = 2 ; } } else { maxlength = Math . max ( maxlength , length ) ; length = 1 ; } } maxlength = Math . max ( maxlength , length ) ; return maxlength ; }
Ref: 
def longestGP ( A , N ) : NEW_LINE INDENT if ( N < 2 ) : NEW_LINE INDENT return N NEW_LINE DEDENT length = 1 NEW_LINE common_ratio = 1 NEW_LINE maxlength = 1 NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT if ( A [ i + 1 ] % A [ i ] == 0 ) : NEW_LINE INDENT if ( A [ i + 1 ] // A [ i ] == common_ratio ) : NEW_LINE INDENT length = length + 1 NEW_LINE maxlength = max ( maxlength , length ) NEW_LINE DEDENT else : NEW_LINE INDENT common_ratio = A [ i + 1 ] // A [ i ] NEW_LINE length = 2 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT maxlength = max ( maxlength , length ) NEW_LINE length = 1 NEW_LINE DEDENT DEDENT maxlength = max ( maxlength , length ) NEW_LINE return maxlength NEW_LINE DEDENT
Hyp: 
def longestGP ( A , N ) : NEW_LINE INDENT if ( N < 2 ) : NEW_LINE INDENT return N NEW_LINE DEDENT length = 1 NEW_LINE common_ratio = 1 NEW_LINE maxlength = 1 NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT if ( A [ i + 1 ] % A [ i ] == 0 ) : NEW_LINE INDENT if ( A [ i + 1 ] // A [ i ] == common_ratio ) : NEW_LINE INDENT length = length + 1 NEW_LINE maxlength = max ( maxlength , length ) NEW_LINE DEDENT else : NEW_LINE INDENT common_ratio = A [ i + 1 ] // A [ i ] NEW_LINE length = 2 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT maxlength = max ( maxlength , length ) NEW_LINE length = 1 NEW_LINE DEDENT DEDENT maxlength = max ( maxlength , length ) NEW_LINE return maxlength NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int max_min ( int a [ ] , int n ) { Arrays . sort ( a ) ; return Math . min ( a [ n - 2 ] - a [ 0 ] , a [ n - 1 ] - a [ 1 ] ) ; }
Ref: 
def max_min ( a , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE return min ( a [ n - 2 ] - a [ 0 ] , a [ n - 1 ] - a [ 1 ] ) NEW_LINE DEDENT
Hyp: 
def max_min ( a , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE return min ( a [ n - 2 ] - a [ 0 ] , a [ n - 1 ] - a [ 1 ] ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
void printCharWithFreq ( String str ) { int n = str . length ( ) ; int [ ] freq = new int [ SIZE ] ; for ( int i = 0 ; i < n ; i ++ ) freq [ str . charAt ( i ) - ' a ' ] ++ ; for ( int i = 0 ; i < n ; i ++ ) { if ( freq [ str . charAt ( i ) - ' a ' ] != 0 ) { System . out . print ( str . charAt ( i ) ) ; System . out . print ( freq [ str . charAt ( i ) - ' a ' ] + " ▁ " ) ; freq [ str . charAt ( i ) - ' a ' ] = 0 ; } } }
Ref: 
def prCharWithFreq ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE freq = np . zeros ( 26 , dtype = np . int ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] != 0 ) : NEW_LINE INDENT print ( str [ i ] , freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] , end = " ▁ " ) NEW_LINE freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] = 0 NEW_LINE DEDENT DEDENT DEDENT
Hyp: 
def printCharWithFreq ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE freq = [ 0 ] * SIZE NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] = 0 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] != 0 ) : NEW_LINE INDENT print ( str [ i ] , end = " ▁ " ) NEW_LINE freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] = 0 NEW_LINE DEDENT DEDENT DEDENT

BLEU: 70.56
Edit Sim: 90


Src: 
int getMinVal ( int p , int q ) { if ( q % p == 0 ) return p ; return - 1 ; }
Ref: 
def getMinVal ( p , q ) : NEW_LINE INDENT if q % p == 0 : NEW_LINE INDENT return p NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
Hyp: 
def getMinVal ( p , q ) : NEW_LINE INDENT if ( q % p == 0 ) : NEW_LINE INDENT return p ; NEW_LINE DEDENT return - 1 ; NEW_LINE DEDENT

BLEU: 67.04
Edit Sim: 8


Src: 
long sum ( int n ) { if ( n == 1 ) return 1 ; else return ( ( long ) Math . pow ( n , n ) + sum ( n - 1 ) ) ; }
Ref: 
def sum ( n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return pow ( n , n ) + sum ( n - 1 ) NEW_LINE DEDENT DEDENT
Hyp: 
def sum ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return ( pow ( n , n ) + sum ( n - 1 ) ) NEW_LINE DEDENT DEDENT

BLEU: 77.81
Edit Sim: 8


Src: 
double findDiagonal ( double s ) { return ( double ) Math . sqrt ( 2 ) * s ; }
Ref: 
def findDiagonal ( s ) : NEW_LINE INDENT return math . sqrt ( 2 ) * s NEW_LINE DEDENT
Hyp: 
def findDiagonal ( s ) : NEW_LINE INDENT return math . sqrt ( 2 ) * s NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int findCount ( int mat [ ] [ ] , int i , int j , int m ) { if ( i == 0 && j == 0 ) { if ( m == mat [ 0 ] [ 0 ] ) return 1 ; else return 0 ; } if ( m < 0 ) return 0 ; if ( i < 0 j < 0 ) return 0 ; if ( v [ i ] [ j ] [ m ] ) return dp [ i ] [ j ] [ m ] ; v [ i ] [ j ] [ m ] = true ; dp [ i ] [ j ] [ m ] = findCount ( mat , i - 1 , j , m - mat [ i ] [ j ] ) + findCount ( mat , i , j - 1 , m - mat [ i ] [ j ] ) ; return dp [ i ] [ j ] [ m ] ; }
Ref: 
def findCount ( mat , i , j , m ) : NEW_LINE INDENT if ( i == 0 and j == 0 ) : NEW_LINE INDENT if ( m == mat [ 0 ] [ 0 ] ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if ( m < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( i < 0 or j < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( v [ i ] [ j ] [ m ] > 0 ) : NEW_LINE INDENT return dp [ i ] [ j ] [ m ] NEW_LINE DEDENT v [ i ] [ j ] [ m ] = True NEW_LINE dp [ i ] [ j ] [ m ] = ( findCount ( mat , i - 1 , j , m - mat [ i ] [ j ] ) + findCount ( mat , i , j - 1 , m - mat [ i ] [ j ] ) ) NEW_LINE return dp [ i ] [ j ] [ m ] NEW_LINE DEDENT
Hyp: 
def findCount ( mat , i , j , m ) : NEW_LINE INDENT if ( i == 0 and j == 0 ) : NEW_LINE INDENT if ( m == mat [ 0 ] [ 0 ] ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT DEDENT if ( m < 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( v [ i ] [ j ] [ m ] ) : NEW_LINE INDENT return dp [ i ] [ j ] [ m ] ; NEW_LINE DEDENT v [ i ] [ j ] [ m ] = 1 ; NEW_LINE dp [ i ] [ j ] [ m ] = findCount ( mat , i - 1 , j , m - mat [ i ] [ j ] ) + findCount ( mat , i , j - 1 , m - mat [ i ] [ j ] ) ; NEW_LINE return dp [ i ] [ j ] [ m ] ; NEW_LINE DEDENT

BLEU: 81.67
Edit Sim: 83


Src: 
int maxLenSubStr ( String s ) { if ( s . length ( ) < 3 ) return s . length ( ) ; int temp = 2 ; int ans = 2 ; for ( int i = 2 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) != s . charAt ( i - 1 ) || s . charAt ( i ) != s . charAt ( i - 2 ) ) temp ++ ; else { ans = Math . max ( temp , ans ) ; temp = 2 ; } } ans = Math . max ( temp , ans ) ; return ans ; }
Ref: 
def maxLenSubStr ( s ) : NEW_LINE INDENT if ( len ( s ) < 3 ) : NEW_LINE INDENT return len ( s ) NEW_LINE DEDENT temp = 2 NEW_LINE ans = 2 NEW_LINE for i in range ( 2 , len ( s ) ) : NEW_LINE INDENT if ( s [ i ] != s [ i - 1 ] or s [ i ] != s [ i - 2 ] ) : NEW_LINE INDENT temp += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = max ( temp , ans ) NEW_LINE temp = 2 NEW_LINE DEDENT DEDENT ans = max ( temp , ans ) NEW_LINE return ans NEW_LINE DEDENT
Hyp: 
def maxLenSubStr ( s ) : NEW_LINE INDENT if ( len ( s ) < 3 ) : NEW_LINE INDENT return len ( s ) NEW_LINE DEDENT temp = 2 NEW_LINE ans = 2 NEW_LINE for i in range ( 2 , len ( s ) ) : NEW_LINE INDENT if ( s [ i ] != s [ i - 1 ] or s [ i ] != s [ i - 2 ] ) : NEW_LINE INDENT temp += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = max ( temp , ans ) NEW_LINE temp = 2 NEW_LINE DEDENT DEDENT ans = max ( temp , ans ) NEW_LINE return ans NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int KvisibleFromLeft ( int N , int K ) { if ( N == K ) return 1 ; if ( K == 1 ) { int ans = 1 ; for ( int i = 1 ; i < N ; i ++ ) ans *= i ; return ans ; } return KvisibleFromLeft ( N - 1 , K - 1 ) + ( N - 1 ) * KvisibleFromLeft ( N - 1 , K ) ; }
Ref: 
def KvisibleFromLeft ( N , K ) : NEW_LINE INDENT if ( N == K ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( K == 1 ) : NEW_LINE INDENT ans = 1 NEW_LINE for i in range ( 1 , N , 1 ) : NEW_LINE INDENT ans *= i NEW_LINE DEDENT return ans NEW_LINE DEDENT return KvisibleFromLeft ( N - 1 , K - 1 ) + ( N - 1 ) * KvisibleFromLeft ( N - 1 , K ) NEW_LINE DEDENT
Hyp: 
def KvisibleFromLeft ( N , K ) : NEW_LINE INDENT if ( N == K ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( K == 1 ) : NEW_LINE INDENT ans = 1 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT ans *= i NEW_LINE DEDENT return ans NEW_LINE DEDENT

BLEU: 57.47
Edit Sim: 107


Src: 
boolean checkConcurrent ( int a1 , int b1 , int c1 , int a2 , int b2 , int c2 , int a3 , int b3 , int c3 ) { return ( a3 * ( b1 * c2 - b2 * c1 ) + b3 * ( c1 * a2 - c2 * a1 ) + c3 * ( a1 * b2 - a2 * b1 ) == 0 ) ; }
Ref: 
def checkConcurrent ( a1 , b1 , c1 , a2 , b2 , c2 , a3 , b3 , c3 ) : NEW_LINE INDENT return ( a3 * ( b1 * c2 - b2 * c1 ) + b3 * ( c1 * a2 - c2 * a1 ) + c3 * ( a1 * b2 - a2 * b1 ) == 0 ) NEW_LINE DEDENT a1 = 2 NEW_LINE b1 = - 3 NEW_LINE c1 = 5 NEW_LINE a2 = 3 NEW_LINE b2 = 4 NEW_LINE c2 = - 7 NEW_LINE a3 = 9 NEW_LINE b3 = - 5 NEW_LINE c3 = 8 NEW_LINE if ( checkConcurrent ( a1 , b1 , c1 , a2 , b2 , c2 , a3 , b3 , c3 ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
Hyp: 
def checkConcurrent ( a1 , b1 , c1 , a2 , b2 , c2 , a3 , b3 , c3 ) : NEW_LINE INDENT return ( a3 * ( b1 * c2 - b2 * c1 ) + b3 * ( c1 * a2 - c2 * a1 ) + c3 * ( a1 * b2 - a2 * b1 ) == 0 ) NEW_LINE DEDENT a1 = 1 NEW_LINE b2 = 2 NEW_LINE c1 = 3 NEW_LINE if checkConcurrent ( a1 , b1 , c1 , a2 , b2 , c2 , a3 , b3 , c3 ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT

BLEU: 73.84
Edit Sim: 108


Src: 
String check ( int arr [ ] , int n ) { Map < Integer , Integer > hm = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { hm . put ( arr [ i ] , 1 ) ; for ( int j = i + 1 ; j < n ; j ++ ) { hm . put ( arr [ j ] , hm . getOrDefault ( arr [ j ] , 0 ) + 1 ) ; boolean flag = false ; for ( Integer k : hm . values ( ) ) { if ( k == 1 ) { flag = true ; break ; } } if ( ! flag ) return " No " ; } hm . clear ( ) ; } return " Yes " ; }
Ref: 
def check ( arr , n ) : NEW_LINE INDENT hm = defaultdict ( int ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT hm [ arr [ i ] ] += 1 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT hm [ arr [ j ] ] += 1 NEW_LINE flag = False NEW_LINE for k in hm . values ( ) : NEW_LINE INDENT if ( k == 1 ) : NEW_LINE INDENT flag = True NEW_LINE break NEW_LINE DEDENT DEDENT if ( not flag ) : NEW_LINE return " No " NEW_LINE DEDENT hm . clear ( ) NEW_LINE DEDENT return " Yes " NEW_LINE DEDENT
Hyp: 
def check ( arr , n ) : NEW_LINE INDENT hm = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT hm [ arr [ i ] ] = 1 NEW_LINE DEDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT hm [ arr [ j ] ] = hm [ getOrDefault ( arr [ j ] , 0 ) + 1 NEW_LINE flag = False NEW_LINE for k in hm : NEW_LINE INDENT if ( k == 1 ) : NEW_LINE INDENT flag = True NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag != 0 ) : NEW_LINE INDENT return " No " NEW_LINE DEDENT DEDENT return " Yes " NEW_LINE DEDENT

BLEU: 74.55
Edit Sim: 110


Src: 
int summation ( int n ) { int sum ; sum = ( int ) ( Math . pow ( 10 , n + 1 ) - 10 - ( 9 * n ) ) / 81 ; return sum ; }
Ref: 
def summation ( n ) : NEW_LINE INDENT return int ( ( pow ( 10 , n + 1 ) - 10 - ( 9 * n ) ) / 81 ) ; NEW_LINE DEDENT
Hyp: 
def summation ( n ) : NEW_LINE INDENT sum = ( pow ( 10 , n + 1 ) - 10 - ( 9 * n ) ) // 81 NEW_LINE return sum NEW_LINE DEDENT

BLEU: 72.44
Edit Sim: 29


Src: 
int nthTerm ( int n ) { return 2 * ( int ) Math . pow ( n , 2 ) + 4 * n - 2 ; }
Ref: 
def nthTerm ( n ) : NEW_LINE INDENT return 2 * pow ( n , 2 ) + 4 * n - 2 NEW_LINE DEDENT
Hyp: 
def nthTerm ( n ) : NEW_LINE INDENT return 2 * pow ( n , 2 ) + 4 * n - 2 ; NEW_LINE DEDENT

BLEU: 90.96
Edit Sim: 2


Src: 
float angle ( float R1 , float R2 , float D ) { float ans = ( R1 * R1 + R2 * R2 - D * D ) / ( 2 * R1 * R2 ) ; return ans ; }
Ref: 
def angle ( R1 , R2 , D ) : NEW_LINE INDENT ans = ( ( R1 * R1 + R2 * R2 - D * D ) / ( 2 * R1 * R2 ) ) NEW_LINE return ans NEW_LINE DEDENT
Hyp: 
def angle ( R1 , R2 , D ) : NEW_LINE INDENT ans = ( R1 * R1 + R2 * R2 - D * D ) / ( 2 * R1 * R2 ) NEW_LINE return ans NEW_LINE DEDENT

BLEU: 91.3
Edit Sim: 4


Src: 
int CountPairs ( int n ) { int k = n ; int imin = 1 ; int ans = 0 ; while ( imin <= n ) { int imax = n / k ; ans += k * ( imax - imin + 1 ) ; imin = imax + 1 ; k = n / imin ; } return ans ; }
Ref: 
def CountPairs ( n ) : NEW_LINE INDENT k = n NEW_LINE imin = 1 NEW_LINE ans = 0 NEW_LINE while ( imin <= n ) : NEW_LINE INDENT imax = n / k NEW_LINE ans += k * ( imax - imin + 1 ) NEW_LINE imin = imax + 1 NEW_LINE k = n / imin NEW_LINE DEDENT return ans NEW_LINE DEDENT
Hyp: 
def CountPairs ( n ) : NEW_LINE INDENT k = n NEW_LINE imin = 1 NEW_LINE ans = 0 NEW_LINE while ( imin <= n ) : NEW_LINE INDENT imax = n // k NEW_LINE ans += k * ( imax - imin + 1 ) NEW_LINE imin = imax + 1 NEW_LINE k = n // imin NEW_LINE DEDENT return ans NEW_LINE DEDENT

BLEU: 91.99
Edit Sim: 2


Src: 
int minimum_required_operations ( int arr [ ] , int n , int k ) { int answer = 0 ; long mod = 1000000007 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] + arr [ i + 1 ] > k ) { if ( arr [ i ] > k ) { answer += ( arr [ i ] - k ) ; arr [ i ] = k ; } answer += ( arr [ i ] + arr [ i + 1 ] ) - k ; arr [ i + 1 ] = ( k - arr [ i ] ) ; answer %= mod ; } } return answer ; }
Ref: 
def minimum_required_operations ( arr , n , k ) : NEW_LINE INDENT answer = 0 NEW_LINE mod = 10 ** 9 + 7 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if arr [ i ] + arr [ i + 1 ] > k : NEW_LINE INDENT if arr [ i ] > k : NEW_LINE INDENT answer += ( arr [ i ] - k ) NEW_LINE arr [ i ] = k NEW_LINE DEDENT answer += ( arr [ i ] + arr [ i + 1 ] ) - k NEW_LINE arr [ i + 1 ] = ( k - arr [ i ] ) NEW_LINE answer %= mod NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT
Hyp: 
def minimum_required_operations ( arr , n , k ) : NEW_LINE INDENT answer = 0 NEW_LINE mod = 1000000007 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( arr [ i ] + arr [ i + 1 ] > k ) : NEW_LINE INDENT if ( arr [ i ] > k ) : NEW_LINE INDENT answer += ( arr [ i ] - k ) NEW_LINE arr [ i ] = k NEW_LINE DEDENT answer += ( arr [ i ] + arr [ i + 1 ] ) - k NEW_LINE arr [ i + 1 ] = ( k - arr [ i ] ) NEW_LINE answer %= mod NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT

BLEU: 89.88
Edit Sim: 16


Src: 
int getTotalXorOfSubarrayXors ( int arr [ ] , int N ) { int res = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int freq = ( i + 1 ) * ( N - i ) ; if ( freq % 2 == 1 ) res = res ^ arr [ i ] ; } return res ; }
Ref: 
def getTotalXorOfSubarrayXors ( arr , N ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT freq = ( i + 1 ) * ( N - i ) NEW_LINE if ( freq % 2 == 1 ) : NEW_LINE INDENT res = res ^ arr [ i ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
Hyp: 
def getTotalXorOfSubarrayXors ( arr , N ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT freq = ( i + 1 ) * ( N - i ) NEW_LINE if ( freq % 2 == 1 ) : NEW_LINE INDENT res = res ^ arr [ i ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
String allBitsSetInTheGivenRange ( int n , int l , int r ) { int num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ; int new_num = n & num ; if ( num == new_num ) return " Yes " ; return " No " ; }
Ref: 
def allBitsSetInTheGivenRange ( n , l , r ) : NEW_LINE INDENT num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) NEW_LINE new_num = n & num NEW_LINE if ( num == new_num ) : NEW_LINE INDENT return " Yes " NEW_LINE DEDENT return " No " NEW_LINE DEDENT
Hyp: 
def allBitsSetInTheGivenRange ( n , l , r ) : NEW_LINE INDENT num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) NEW_LINE new_num = n & num NEW_LINE if ( num == new_num ) : NEW_LINE INDENT return " Yes " NEW_LINE DEDENT return " No " NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
void String_palindrome ( int N , int K ) { for ( int i = 0 ; i < K ; i ++ ) System . out . print ( " a " ) ; String s = " bcd " ; for ( int i = 0 ; i < N - K ; i ++ ) System . out . print ( s . charAt ( i % 3 ) ) ; }
Ref: 
def string_palindrome ( N , K ) : NEW_LINE INDENT for i in range ( K ) : NEW_LINE INDENT print ( " a " , end = " " ) NEW_LINE DEDENT s = " bcd " NEW_LINE for i in range ( N - K ) : NEW_LINE INDENT print ( s [ i % 3 ] , end = " " ) NEW_LINE DEDENT DEDENT
Hyp: 
def String_palindrome ( N , K ) : NEW_LINE INDENT for i in range ( K ) : NEW_LINE INDENT print ( " a " ) NEW_LINE DEDENT DEDENT

BLEU: 23.7
Edit Sim: 127


Src: 
int findMax ( int arr [ ] , int n ) { int res = 0 ; int i , j ; for ( i = 0 ; i < n ; i ++ ) { int count = 0 ; for ( j = 0 ; j < i ; j ++ ) { if ( arr [ j ] % arr [ i ] == 0 ) count += 1 ; } res = Math . max ( count , res ) ; } return res ; }
Ref: 
def findMax ( arr , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( 0 , i ) : NEW_LINE INDENT if arr [ j ] % arr [ i ] == 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT res = max ( count , res ) NEW_LINE DEDENT return res NEW_LINE DEDENT
Hyp: 
def findMax ( arr , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( 0 , i ) : NEW_LINE INDENT if arr [ j ] % arr [ i ] == 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT res = max ( count , res ) NEW_LINE DEDENT return res NEW_LINE DEDENT

BLEU: 96.7
Edit Sim: 1


Src: 
int repeatingElement ( int arr [ ] , int N ) { int M = 0 , sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; M = Math . max ( M , arr [ i ] ) ; } int sum1 = M * ( M + 1 ) / 2 ; int ans = ( sum - sum1 ) / ( N - M ) ; return ans ; }
Ref: 
def repeatingElement ( arr , N ) : NEW_LINE INDENT M = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE M = max ( M , arr [ i ] ) NEW_LINE DEDENT sum1 = M * ( M + 1 ) // 2 NEW_LINE ans = ( sum - sum1 ) // ( N - M ) NEW_LINE return ans NEW_LINE DEDENT
Hyp: 
def repeatingElement ( arr , N ) : NEW_LINE INDENT M = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE M = max ( M , arr [ i ] ) NEW_LINE DEDENT sum1 = M * ( M + 1 ) // 2 NEW_LINE ans = ( sum - sum1 ) / ( N - M ) NEW_LINE return ans NEW_LINE DEDENT

BLEU: 96.74
Edit Sim: 1


Src: 
int findLCM ( int a , int b ) { int lar = Math . max ( a , b ) ; int small = Math . min ( a , b ) ; for ( int i = lar ; ; i += lar ) { if ( i % small == 0 ) return i ; } }
Ref: 
def findLCM ( a , b ) : NEW_LINE INDENT lar = max ( a , b ) NEW_LINE small = min ( a , b ) NEW_LINE i = lar NEW_LINE while ( 1 ) : NEW_LINE INDENT if ( i % small == 0 ) : NEW_LINE INDENT return i NEW_LINE DEDENT i += lar NEW_LINE DEDENT DEDENT
Hyp: 
def findLCM ( a , b ) : NEW_LINE INDENT lar = max ( a , b ) NEW_LINE small = min ( a , b ) NEW_LINE for i in range ( lar , small + 1 ) : NEW_LINE INDENT if ( i % small == 0 ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT DEDENT

BLEU: 79.99
Edit Sim: 41


Src: 
double sum ( int n ) { double i , s = 0.0 ; for ( i = 1 ; i <= n ; i ++ ) s = s + 1 / i ; return s ; }
Ref: 
def sum ( n ) : NEW_LINE INDENT i = 1 NEW_LINE s = 0.0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT s = s + 1 / i ; NEW_LINE DEDENT return s ; NEW_LINE DEDENT
Hyp: 
def sum ( n ) : NEW_LINE INDENT s = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT s = s + 1 / i NEW_LINE DEDENT return s NEW_LINE DEDENT

BLEU: 70.45
Edit Sim: 21


Src: 
void checkType ( int arr [ ] , int n ) { if ( arr [ 0 ] <= arr [ 1 ] && arr [ n - 2 ] <= arr [ n - 1 ] ) System . out . println ( " Increasing " ) ; else if ( arr [ 0 ] >= arr [ 1 ] && arr [ n - 2 ] >= arr [ n - 1 ] ) System . out . println ( " Decreasing " ) ; else if ( arr [ 0 ] <= arr [ 1 ] && arr [ n - 2 ] >= arr [ n - 1 ] ) System . out . println ( " Increasing ▁ then ▁ decreasing " ) ; else System . out . println ( " Decreasing ▁ then ▁ increasing " ) ; }
Ref: 
def checkType ( arr , n ) : NEW_LINE INDENT if ( arr [ 0 ] <= arr [ 1 ] and arr [ n - 2 ] <= arr [ n - 1 ] ) : NEW_LINE INDENT print ( " Increasing " ) ; NEW_LINE DEDENT elif ( arr [ 0 ] >= arr [ 1 ] and arr [ n - 2 ] >= arr [ n - 1 ] ) : NEW_LINE INDENT print ( " Decreasing " ) ; NEW_LINE DEDENT elif ( arr [ 0 ] <= arr [ 1 ] and arr [ n - 2 ] >= arr [ n - 1 ] ) : NEW_LINE INDENT print ( " Increasing ▁ then ▁ decreasing " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Decreasing ▁ then ▁ increasing " ) ; NEW_LINE DEDENT DEDENT
Hyp: 
def checkType ( arr , n ) : NEW_LINE INDENT if ( arr [ 0 ] <= arr [ 1 ] and arr [ n - 2 ] <= arr [ n - 1 ] ) : NEW_LINE INDENT print ( " Increasing " ) NEW_LINE DEDENT elif ( arr [ 0 ] >= arr [ 1 ] and arr [ n - 2 ] >= arr [ n - 1 ] ) : NEW_LINE INDENT print ( " Decreasing " ) NEW_LINE DEDENT elif ( arr [ 0 ] <= arr [ 1 ] and arr [ n - 2 ] >= arr [ n - 1 ] ) : NEW_LINE INDENT print ( " Increasing ▁ then ▁ decreasing " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Decreasing ▁ then ▁ increasing " ) NEW_LINE DEDENT DEDENT

BLEU: 93.02
Edit Sim: 8


Src: 
int numberOfPairs ( int n ) { if ( n % 2 == 0 ) return n / 2 - 1 ; else return n / 2 ; }
Ref: 
def numberOfPairs ( n ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT return n // 2 - 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT return n // 2 ; NEW_LINE DEDENT DEDENT
Hyp: 
def numberOfPairs ( n ) : NEW_LINE INDENT if n % 2 == 0 : NEW_LINE INDENT return int ( n / 2 - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return int ( n / 2 ) NEW_LINE DEDENT DEDENT

BLEU: 55.44
Edit Sim: 18


Src: 
int solve ( int X , int Y ) { if ( X > Y ) { int temp = X ; X = Y ; Y = temp ; } if ( X == Y ) System . out . println ( 0 ) ; else if ( Y % X == 0 ) System . out . println ( 1 ) ; else System . out . println ( 2 ) ; return 0 ; }
Ref: 
def solve ( X , Y ) : NEW_LINE INDENT if ( X > Y ) : NEW_LINE INDENT temp = X NEW_LINE X = Y NEW_LINE Y = temp NEW_LINE DEDENT if ( X == Y ) : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT elif ( Y % X == 0 ) : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 2 ) NEW_LINE DEDENT DEDENT
Hyp: 
def solve ( X , Y ) : NEW_LINE INDENT if ( X > Y ) : NEW_LINE INDENT temp = X NEW_LINE X = Y NEW_LINE Y = temp NEW_LINE DEDENT if ( X == Y ) : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT elif ( Y % X == 0 ) : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 2 ) NEW_LINE DEDENT DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
boolean isPossible ( int A , int B , int N , int K , int L ) { int needa , needb ; if ( A % K == 0 ) needa = A / K ; else needa = A / K + 1 ; if ( B % L == 0 ) needb = B / L ; else needb = B / L + 1 ; int total = needa + needb ; if ( total > N ) return false ; else return true ; }
Ref: 
def isPossible ( A , B , N , K , L ) : NEW_LINE INDENT needa = 0 NEW_LINE needb = 0 NEW_LINE if ( A % K == 0 ) : NEW_LINE INDENT needa = A // K ; NEW_LINE DEDENT else : NEW_LINE INDENT needa = A // K + 1 NEW_LINE DEDENT if ( B % L == 0 ) : NEW_LINE INDENT needb = B // L NEW_LINE DEDENT else : NEW_LINE INDENT needb = B // L + 1 NEW_LINE DEDENT total = needa + needb NEW_LINE if ( total > N ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT
Hyp: 
def isPossible ( A , B , N , K , L ) : NEW_LINE INDENT needa = 0 NEW_LINE needb = 0 NEW_LINE if ( A % K == 0 ) : NEW_LINE INDENT needa = A // K NEW_LINE DEDENT else : NEW_LINE INDENT needa = A // K + 1 NEW_LINE DEDENT if ( B % L == 0 ) : NEW_LINE INDENT needb = B // L NEW_LINE DEDENT else : NEW_LINE INDENT needb = B // L + 1 NEW_LINE DEDENT total = needa + needb NEW_LINE if ( total > N ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT

BLEU: 97.8
Edit Sim: 2


Src: 
int countNumbers ( int n ) { int k = 0 ; int count = 0 ; while ( n > 0 ) { if ( ( n & 1 ) == 0 ) count += ( int ) ( Math . pow ( 2 , k ) ) ; k += 1 ; n >>= 1 ; } return count ; }
Ref: 
def countNumbers ( n ) : NEW_LINE INDENT k = 0 NEW_LINE count = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT if ( ( n & 1 ) == 0 ) : NEW_LINE INDENT count += pow ( 2 , k ) NEW_LINE DEDENT k += 1 NEW_LINE n >>= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
Hyp: 
def countNumbers ( n ) : NEW_LINE INDENT k = 0 NEW_LINE count = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT if ( n & 1 ) : NEW_LINE INDENT count += int ( pow ( 2 , k ) ) NEW_LINE DEDENT k += 1 NEW_LINE n >>= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT

BLEU: 87.6
Edit Sim: 17


Src: 
int printCountDP ( int dist ) { int [ ] count = new int [ dist + 1 ] ; count [ 0 ] = 1 ; if ( dist >= 1 ) count [ 1 ] = 1 ; if ( dist >= 2 ) count [ 2 ] = 2 ; for ( int i = 3 ; i <= dist ; i ++ ) count [ i ] = count [ i - 1 ] + count [ i - 2 ] + count [ i - 3 ] ; return count [ dist ] ; }
Ref: 
def printCountDP ( dist ) : NEW_LINE INDENT count = [ 0 ] * ( dist + 1 ) NEW_LINE count [ 0 ] = 1 NEW_LINE if dist >= 1 : NEW_LINE INDENT count [ 1 ] = 1 NEW_LINE DEDENT if dist >= 2 : NEW_LINE INDENT count [ 2 ] = 2 NEW_LINE DEDENT for i in range ( 3 , dist + 1 ) : NEW_LINE INDENT count [ i ] = ( count [ i - 1 ] + count [ i - 2 ] + count [ i - 3 ] ) NEW_LINE DEDENT return count [ dist ] ; NEW_LINE DEDENT
Hyp: 
def printCountDP ( dist ) : NEW_LINE INDENT count = [ 0 ] * ( dist + 1 ) NEW_LINE count [ 0 ] = 1 NEW_LINE if ( dist >= 1 ) : NEW_LINE INDENT count [ 1 ] = 1 NEW_LINE DEDENT if ( dist >= 2 ) : NEW_LINE INDENT count [ 2 ] = 2 NEW_LINE DEDENT for i in range ( 3 , dist + 1 ) : NEW_LINE INDENT count [ i ] = count [ i - 1 ] + count [ i - 2 ] + count [ i - 3 ] NEW_LINE DEDENT return count [ dist ] NEW_LINE DEDENT

BLEU: 86.91
Edit Sim: 14


Src: 
int usingBinarySearch ( int start , int end , int N , int S ) { if ( start >= end ) return start ; int mid = start + ( end - start ) / 2 ; int totalSum = ( N * ( N + 1 ) ) / 2 ; int midSum = ( mid * ( mid + 1 ) ) / 2 ; if ( ( totalSum - midSum ) <= S ) { return usingBinarySearch ( start , mid , N , S ) ; } return usingBinarySearch ( mid + 1 , end , N , S ) ; }
Ref: 
def usingBinarySearch ( start , end , N , S ) : NEW_LINE INDENT if ( start >= end ) : NEW_LINE INDENT return start ; NEW_LINE DEDENT mid = start + ( end - start ) // 2 ; NEW_LINE totalSum = ( N * ( N + 1 ) ) // 2 ; NEW_LINE midSum = ( mid * ( mid + 1 ) ) // 2 ; NEW_LINE if ( ( totalSum - midSum ) <= S ) : NEW_LINE INDENT return usingBinarySearch ( start , mid , N , S ) ; NEW_LINE DEDENT return usingBinarySearch ( mid + 1 , end , N , S ) ; NEW_LINE DEDENT
Hyp: 
def usingBinarySearch ( start , end , N , S ) : NEW_LINE INDENT if ( start >= end ) : NEW_LINE INDENT return start NEW_LINE DEDENT mid = start + ( end - start ) // 2 NEW_LINE totalSum = ( N * ( N + 1 ) ) // 2 NEW_LINE midSum = ( mid * ( mid + 1 ) ) // 2 NEW_LINE if ( ( totalSum - midSum ) <= S ) : NEW_LINE INDENT return usingBinarySearch ( start , mid , N , S ) NEW_LINE DEDENT return usingBinarySearch ( mid + 1 , end , N , S ) NEW_LINE DEDENT

BLEU: 86.65
Edit Sim: 12


Src: 
void countSubarrays ( int a [ ] , int n , int k ) { int ans = 0 ; ArrayList < Integer > pref = new ArrayList < > ( ) ; pref . add ( 0 ) ; for ( int i = 0 ; i < n ; i ++ ) pref . add ( ( a [ i ] + pref . get ( i ) ) % k ) ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = i ; j <= n ; j ++ ) { if ( ( pref . get ( j ) - pref . get ( i - 1 ) + k ) % k == j - i + 1 ) { ans ++ ; } } } System . out . println ( ans ) ; }
Ref: 
def countSubarrays ( a , n , k ) : NEW_LINE INDENT ans = 0 NEW_LINE pref = [ ] NEW_LINE pref . append ( 0 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT pref . append ( ( a [ i ] + pref [ i ] ) % k ) NEW_LINE DEDENT for i in range ( 1 , n + 1 , 1 ) : NEW_LINE INDENT for j in range ( i , n + 1 , 1 ) : NEW_LINE INDENT if ( ( pref [ j ] - pref [ i - 1 ] + k ) % k == j - i + 1 ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT print ( ans , end = ' ▁ ' ) NEW_LINE DEDENT
Hyp: 
def countSubarrays ( a , n , k ) : NEW_LINE INDENT ans = 0 NEW_LINE pref = [ 0 ] * k NEW_LINE for i in range ( n ) : NEW_LINE INDENT pref . append ( ( a [ i ] + pref [ i ] ) % k ) NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( i , n + 1 ) : NEW_LINE INDENT if ( ( pref [ j ] - pref [ i - 1 ] + k ) % k == j - i + 1 ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE DEDENT

BLEU: 83.44
Edit Sim: 49


Src: 
int countSegments ( int a [ ] , int n , int x ) { boolean flag = false ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > x ) { flag = true ; } else { if ( flag ) count += 1 ; flag = false ; } } if ( flag ) count += 1 ; return count ; }
Ref: 
def countSegments ( a , n , x ) : NEW_LINE INDENT flag = False NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] > x ) : NEW_LINE INDENT flag = True NEW_LINE DEDENT else : NEW_LINE INDENT if ( flag ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT flag = False NEW_LINE DEDENT DEDENT if ( flag ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
Hyp: 
def countSegments ( a , n , x ) : NEW_LINE INDENT flag = 0 NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] > x ) : NEW_LINE INDENT flag = True NEW_LINE DEDENT else : NEW_LINE INDENT if ( flag ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT flag = False NEW_LINE DEDENT DEDENT if ( flag ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT

BLEU: 97.01
Edit Sim: 5


Src: 
int minCost ( int coin [ ] , int n , int k ) { Arrays . sort ( coin ) ; int coins_needed = ( int ) Math . ceil ( 1.0 * n / ( k + 1 ) ) ; int ans = 0 ; for ( int i = 0 ; i <= coins_needed - 1 ; i ++ ) ans += coin [ i ] ; return ans ; }
Ref: 
def minCost ( coin , n , k ) : NEW_LINE INDENT coin . sort ( ) NEW_LINE coins_needed = math . ceil ( 1.0 * n // ( k + 1 ) ) ; NEW_LINE ans = 0 NEW_LINE for i in range ( coins_needed - 1 + 1 ) : NEW_LINE INDENT ans += coin [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT
Hyp: 
def minCost ( coin , n , k ) : NEW_LINE INDENT coin . sort ( ) NEW_LINE coins_needed = int ( math . ceil ( 1.0 * n / ( k + 1 ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( coins_needed - 1 ) : NEW_LINE INDENT ans += coin [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT

BLEU: 85.51
Edit Sim: 12


Src: 
int findMajority ( int arr [ ] , int n ) { return arr [ n / 2 ] ; }
Ref: 
def findMajority ( arr , n ) : NEW_LINE INDENT return arr [ int ( n / 2 ) ] NEW_LINE DEDENT
Hyp: 
def findMajority ( arr , n ) : NEW_LINE INDENT return arr [ int ( n / 2 ) ] NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
boolean checkExists ( int arr [ ] , int N , int M , int K ) { int count = 0 ; for ( int i = 0 ; i < N - M ; i ++ ) { if ( arr [ i ] == arr [ i + M ] ) count ++ ; else count = 0 ; if ( count == M * ( K - 1 ) ) return true ; } return false ; }
Ref: 
def checkExists ( arr , N , M , K ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( N - M ) : NEW_LINE INDENT if ( arr [ i ] == arr [ i + M ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count = 0 NEW_LINE DEDENT if ( count == M * ( K - 1 ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
Hyp: 
def checkExists ( arr , N , M , K ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( N - M ) : NEW_LINE INDENT if ( arr [ i ] == arr [ i + M ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count = 0 NEW_LINE DEDENT if ( count == M * ( K - 1 ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int calculate ( int ar [ ] , int size ) { int count = 0 ; for ( int i = 0 ; i < size ; i ++ ) if ( ar [ i ] % 2 == 0 && ar [ i ] != 0 && ar [ i ] != 2 ) count ++ ; return count ; }
Ref: 
def calculate ( array , size ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( size ) : NEW_LINE INDENT if ( array [ i ] % 2 == 0 and array [ i ] != 0 and array [ i ] != 2 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
Hyp: 
def calculate ( ar , size ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( size ) : NEW_LINE INDENT if ( ar [ i ] % 2 == 0 and ar [ i ] != 0 and ar [ i ] != 2 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT

BLEU: 83.26
Edit Sim: 12


Src: 
void canBeEmptied ( int A , int B ) { if ( Math . max ( A , B ) > 2 * Math . min ( A , B ) ) { System . out . println ( " No " ) ; return ; } if ( ( A + B ) % 3 == 0 ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; }
Ref: 
def canBeEmptied ( A , B ) : NEW_LINE INDENT if ( max ( A , B ) > 2 * min ( A , B ) ) : NEW_LINE INDENT print ( " No " ) NEW_LINE return NEW_LINE DEDENT if ( ( A + B ) % 3 == 0 ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
Hyp: 
def canBeEmptied ( A , B ) : NEW_LINE INDENT if ( max ( A , B ) > 2 * min ( A , B ) ) : NEW_LINE INDENT print ( " No " ) NEW_LINE return NEW_LINE DEDENT if ( ( A + B ) % 3 == 0 ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
void countNumEnds ( int A , int L , int R ) { int temp , count = 0 , digits ; int cycle ; digits = ( int ) ( Math . log10 ( A ) + 1 ) ; temp = ( int ) Math . pow ( 10 , digits ) ; cycle = temp ; while ( temp <= R ) { if ( temp >= L ) count ++ ; temp += cycle ; } System . out . print ( count ) ; }
Ref: 
def countNumEnds ( A , L , R ) : NEW_LINE INDENT count = 0 NEW_LINE digits = int ( log10 ( A ) + 1 ) NEW_LINE temp = int ( pow ( 10 , digits ) ) NEW_LINE cycle = temp NEW_LINE while ( temp <= R ) : NEW_LINE INDENT if ( temp >= L ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT temp += cycle NEW_LINE DEDENT print ( count ) NEW_LINE DEDENT
Hyp: 
def countNumEnds ( A , L , R ) : NEW_LINE INDENT count = 0 NEW_LINE digits = int ( math . log10 ( A ) + 1 ) NEW_LINE temp = 10 ** digits NEW_LINE cycle = temp NEW_LINE while ( temp <= R ) : NEW_LINE INDENT if ( temp >= L ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT temp += cycle NEW_LINE DEDENT print ( count ) NEW_LINE DEDENT

BLEU: 84.92
Edit Sim: 25


Src: 
int findIndex ( int n ) { if ( n <= 1 ) return n ; int a = 0 , b = 1 , c = 1 ; int res = 1 ; while ( c < n ) { c = a + b ; res ++ ; a = b ; b = c ; } return res ; }
Ref: 
def findIndex ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT a = 0 NEW_LINE b = 1 NEW_LINE c = 1 NEW_LINE res = 1 NEW_LINE while ( c < n ) : NEW_LINE INDENT c = a + b NEW_LINE res = res + 1 NEW_LINE a = b NEW_LINE b = c NEW_LINE DEDENT return res NEW_LINE DEDENT
Hyp: 
def findIndex ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT a = 0 NEW_LINE b = 1 NEW_LINE c = 1 NEW_LINE res = 1 NEW_LINE while ( c < n ) : NEW_LINE INDENT c = a + b NEW_LINE res += 1 NEW_LINE a = b NEW_LINE b = c NEW_LINE DEDENT return res NEW_LINE DEDENT

BLEU: 93.56
Edit Sim: 7


Src: 
int minCost ( int cost [ ] , int n ) { int dp [ ] = new int [ n + 1 ] ; dp [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int min_cost = Integer . MAX_VALUE ; for ( int j = 0 ; j < i ; j ++ ) if ( j < cost . length && cost [ j ] != - 1 ) { min_cost = Math . min ( min_cost , cost [ j ] + dp [ i - j - 1 ] ) ; } dp [ i ] = min_cost ; } return dp [ n ] ; }
Ref: 
def minCost ( cost , n ) : NEW_LINE INDENT dp = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT min_cost = sys . maxsize NEW_LINE for j in range ( i ) : NEW_LINE INDENT if j < len ( cost ) and cost [ j ] != - 1 : NEW_LINE INDENT min_cost = min ( min_cost , cost [ j ] + dp [ i - j - 1 ] ) NEW_LINE DEDENT DEDENT dp [ i ] = min_cost NEW_LINE DEDENT return dp [ n ] NEW_LINE DEDENT
Hyp: 
def minCost ( cost , n ) : NEW_LINE INDENT dp = [ 0 for i in range ( n + 1 ) ] NEW_LINE dp [ 0 ] = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT min_cost = 10 ** 9 NEW_LINE for j in range ( i ) : NEW_LINE INDENT if ( j < cost . length and cost [ j ] != - 1 ) : NEW_LINE INDENT min_cost = min ( min_cost , cost [ j ] + dp [ i - j - 1 ] ) NEW_LINE DEDENT DEDENT dp [ i ] = min_cost NEW_LINE DEDENT return dp [ n ] NEW_LINE DEDENT

BLEU: 82.47
Edit Sim: 49


Src: 
int findSum ( int n ) { return n * ( n + 1 ) / 2 ; }
Ref: 
def findSum ( n ) : NEW_LINE INDENT return n * ( n + 1 ) / 2 NEW_LINE DEDENT
Hyp: 
def findSum ( n ) : NEW_LINE INDENT return n * ( n + 1 ) / 2 NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
void divParts ( int N ) { if ( N % 2 == 0 ) System . out . println ( ( N / 2 ) - 1 ) ; else System . out . println ( ( N / 2 ) ) ; }
Ref: 
def divParts ( N ) : NEW_LINE INDENT if ( N % 2 == 0 ) : NEW_LINE INDENT print ( ( N / 2 ) - 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( N / 2 ) ; NEW_LINE DEDENT DEDENT
Hyp: 
def divParts ( N ) : NEW_LINE INDENT if ( N % 2 == 0 ) : NEW_LINE INDENT print ( int ( N / 2 ) - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( int ( N / 2 ) ) NEW_LINE DEDENT DEDENT

BLEU: 79.77
Edit Sim: 13


Src: 
int maxSheets ( int A , int B ) { int area = A * B ; int count = 1 ; while ( area % 2 == 0 ) { area /= 2 ; count *= 2 ; } return count ; }
Ref: 
def maxSheets ( A , B ) : NEW_LINE INDENT area = A * B NEW_LINE count = 1 NEW_LINE while ( area % 2 == 0 ) : NEW_LINE INDENT area //= 2 NEW_LINE count *= 2 NEW_LINE DEDENT return count NEW_LINE DEDENT
Hyp: 
def maxSheets ( A , B ) : NEW_LINE INDENT area = A * B NEW_LINE count = 1 NEW_LINE while ( area % 2 == 0 ) : NEW_LINE INDENT area //= 2 NEW_LINE count *= 2 NEW_LINE DEDENT return count NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int countDigit ( long n ) { if ( n / 10 == 0 ) return 1 ; return 1 + countDigit ( n / 10 ) ; }
Ref: 
def countDigit ( n ) : NEW_LINE INDENT if n / 10 == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 1 + countDigit ( n // 10 ) NEW_LINE DEDENT
Hyp: 
def countDigit ( n ) : NEW_LINE INDENT if ( n // 10 == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 1 + countDigit ( n // 10 ) NEW_LINE DEDENT

BLEU: 79.13
Edit Sim: 5


Src: 
int eulerian ( int n , int m ) { if ( m >= n n == 0 ) return 0 ; if ( m == 0 ) return 1 ; return ( n - m ) * eulerian ( n - 1 , m - 1 ) + ( m + 1 ) * eulerian ( n - 1 , m ) ; }
Ref: 
def eulerian ( n , m ) : NEW_LINE INDENT if ( m >= n or n == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( m == 0 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT return ( ( n - m ) * eulerian ( n - 1 , m - 1 ) + ( m + 1 ) * eulerian ( n - 1 , m ) ) NEW_LINE DEDENT
Hyp: 
def eulerian ( n , m ) : NEW_LINE INDENT if ( m >= n or n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( m == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return ( n - m ) * eulerian ( n - 1 , m - 1 ) + ( m + 1 ) * eulerian ( n - 1 , m ) NEW_LINE DEDENT

BLEU: 88.72
Edit Sim: 8


Src: 
int octacontagonNum ( int n ) { return ( 78 * n * n - 76 * n ) / 2 ; }
Ref: 
def octacontagonNum ( n ) : NEW_LINE INDENT return ( 78 * n * n - 76 * n ) // 2 NEW_LINE DEDENT
Hyp: 
def octacontagonNum ( n ) : NEW_LINE INDENT return ( 78 * n * n - 76 * n ) // 2 NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int findLen ( int [ ] arr , int i , int curr , int n , int m ) { if ( i == n ) { if ( curr == m ) return 0 ; else return - 1 ; } if ( v [ i ] [ curr ] ) return dp [ i ] [ curr ] ; v [ i ] [ curr ] = true ; int l = findLen ( arr , i + 1 , curr , n , m ) ; int r = findLen ( arr , i + 1 , curr arr [ i ] , n , m ) ; dp [ i ] [ curr ] = l ; if ( r != - 1 ) dp [ i ] [ curr ] = Math . max ( dp [ i ] [ curr ] , r + 1 ) ; return dp [ i ] [ curr ] ; }
Ref: 
def findLen ( arr , i , curr , n , m ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT if ( curr == m ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT DEDENT if ( v [ i ] [ curr ] ) : NEW_LINE INDENT return dp [ i ] [ curr ] ; NEW_LINE DEDENT v [ i ] [ curr ] = 1 ; NEW_LINE l = findLen ( arr , i + 1 , curr , n , m ) ; NEW_LINE r = findLen ( arr , i + 1 , curr arr [ i ] , n , m ) ; NEW_LINE dp [ i ] [ curr ] = l ; NEW_LINE if ( r != - 1 ) : NEW_LINE INDENT dp [ i ] [ curr ] = max ( dp [ i ] [ curr ] , r + 1 ) ; NEW_LINE DEDENT return dp [ i ] [ curr ] ; NEW_LINE DEDENT
Hyp: 
def findLen ( arr , i , curr , n , m ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT if ( curr == m ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT DEDENT if ( v [ i ] [ curr ] ) : NEW_LINE INDENT return dp [ i ] [ curr ] ; NEW_LINE DEDENT l = findLen ( arr , i + 1 , curr , n , m ) ; NEW_LINE r = findLen ( arr , i + 1 , curr arr [ i ] , n , m ) ; NEW_LINE dp [ i ] [ curr ] = l ; NEW_LINE if ( r != - 1 ) : NEW_LINE INDENT dp [ i ] [ curr ] = max ( dp [ i ] [ curr ] , r + 1 ) ; NEW_LINE DEDENT return dp [ i ] [ curr ] ; NEW_LINE DEDENT

BLEU: 92.94
Edit Sim: 32


Src: 
int maxSubsequences ( int arr [ ] , int n ) { HashMap < Integer , Integer > map = new HashMap < > ( ) ; int maxCount = 0 ; int count ; for ( int i = 0 ; i < n ; i ++ ) { if ( map . containsKey ( arr [ i ] ) ) { count = map . get ( arr [ i ] ) ; if ( count > 1 ) { map . put ( arr [ i ] , count - 1 ) ; } else map . remove ( arr [ i ] ) ; if ( arr [ i ] - 1 > 0 ) map . put ( arr [ i ] - 1 , map . getOrDefault ( arr [ i ] - 1 , 0 ) + 1 ) ; } else { maxCount ++ ; if ( arr [ i ] - 1 > 0 ) map . put ( arr [ i ] - 1 , map . getOrDefault ( arr [ i ] - 1 , 0 ) + 1 ) ; } } return maxCount ; }
Ref: 
def maxSubsequences ( arr , n ) : NEW_LINE INDENT m = defaultdict ( int ) NEW_LINE maxCount = 0 NEW_LINE count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if arr [ i ] in m . keys ( ) : NEW_LINE INDENT count = m [ arr [ i ] ] NEW_LINE if count > 1 : NEW_LINE INDENT m [ arr [ i ] ] = count - 1 NEW_LINE DEDENT else : NEW_LINE INDENT m . pop ( arr [ i ] ) NEW_LINE DEDENT if arr [ i ] - 1 > 0 : NEW_LINE INDENT m [ arr [ i ] - 1 ] += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT maxCount += 1 NEW_LINE DEDENT maxCount += 1 NEW_LINE INDENT if arr [ i ] - 1 > 0 : NEW_LINE INDENT m [ arr [ i ] - 1 ] += 1 NEW_LINE DEDENT DEDENT DEDENT return maxCount NEW_LINE DEDENT
Hyp: 
def maxSubsequences ( arr , n ) : NEW_LINE INDENT mp = { } NEW_LINE maxCount = 0 NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] in mp . keys ( ) : NEW_LINE INDENT count = mp [ arr [ i ] ] NEW_LINE if count > 1 : NEW_LINE INDENT mp [ arr [ i ] ] = count - 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ arr [ i ] ] = 0 NEW_LINE DEDENT DEDENT return maxCount NEW_LINE DEDENT

BLEU: 37.67
Edit Sim: 284


Src: 
int NumberOfSolutions ( int a , int b , int c , int d ) { int ans = 0 ; for ( int i = a ; i <= b ; i ++ ) if ( d >= Math . max ( c , i + 1 ) ) ans += d - Math . max ( c , i + 1 ) + 1 ; return ans ; }
Ref: 
def NumberOfSolutions ( a , b , c , d ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( a , b + 1 ) : NEW_LINE INDENT if d >= max ( c , i + 1 ) : NEW_LINE INDENT ans += d - max ( c , i + 1 ) + 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
Hyp: 
def NumberOfSolutions ( a , b , c , d ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( a , b + 1 ) : NEW_LINE INDENT if ( d >= max ( c , i + 1 ) ) : NEW_LINE INDENT ans += d - max ( c , i + 1 ) + 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT

BLEU: 93.7
Edit Sim: 4


Src: 
void MaximumSum ( int a [ ] , int b [ ] , int n ) { int sum1 = 0 , sum2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum1 |= a [ i ] ; sum2 |= b [ i ] ; } System . out . println ( sum1 + sum2 ) ; }
Ref: 
def MaximumSum ( a , b , n ) : NEW_LINE INDENT sum1 = 0 NEW_LINE sum2 = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum1 |= a [ i ] NEW_LINE sum2 |= b [ i ] NEW_LINE DEDENT print ( sum1 + sum2 ) NEW_LINE DEDENT
Hyp: 
def MaximumSum ( a , b , n ) : NEW_LINE INDENT sum1 = 0 NEW_LINE sum2 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum1 |= a [ i ] NEW_LINE sum2 |= b [ i ] NEW_LINE DEDENT print ( sum1 + sum2 ) NEW_LINE DEDENT

BLEU: 93.48
Edit Sim: 4


Src: 
long centered_heptagonal_num ( long n ) { return ( 7 * n * n - 7 * n + 2 ) / 2 ; }
Ref: 
def centered_heptagonal_num ( n ) : NEW_LINE INDENT return ( 7 * n * n - 7 * n + 2 ) // 2 NEW_LINE DEDENT
Hyp: 
def centered_heptagonal_num ( n ) : NEW_LINE INDENT return ( 7 * n * n - 7 * n + 2 ) // 2 NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int Nth_Term ( int n ) { return ( int ) ( 3 * Math . pow ( n , 2 ) - n + 2 ) / ( 2 ) ; }
Ref: 
def Nth_Term ( n ) : NEW_LINE INDENT return ( 3 * pow ( n , 2 ) - n + 2 ) // ( 2 ) NEW_LINE DEDENT
Hyp: 
def Nth_Term ( n ) : NEW_LINE INDENT return ( 3 * pow ( n , 2 ) - n + 2 ) // ( 2 ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int CountTriangles ( int n ) { int curr = 1 ; int Tri_count = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { Tri_count = ( curr * 3 ) + 2 ; curr = Tri_count ; } return Tri_count ; }
Ref: 
def countTriangles ( n ) : NEW_LINE INDENT curr = 1 NEW_LINE Tri_count = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT Tri_count = ( curr * 3 ) + 2 NEW_LINE curr = Tri_count NEW_LINE DEDENT return Tri_count NEW_LINE DEDENT
Hyp: 
def CountTriangles ( n ) : NEW_LINE INDENT curr = 1 NEW_LINE Tri_count = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT Tri_count = ( curr * 3 ) + 2 NEW_LINE curr = Tri_count NEW_LINE DEDENT return Tri_count NEW_LINE DEDENT

BLEU: 96.37
Edit Sim: 1


Src: 
int countPairs ( int n ) { int count = 0 ; for ( int x = 1 ; x < n ; x ++ ) { for ( int y = x + 1 ; y <= n ; y ++ ) { if ( ( y * x ) % ( y + x ) == 0 ) count ++ ; } } return count ; }
Ref: 
def countPairs ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for x in range ( 1 , n ) : NEW_LINE INDENT for y in range ( x + 1 , n + 1 ) : NEW_LINE INDENT if ( ( y * x ) % ( y + x ) == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
Hyp: 
def countPairs ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for x in range ( 1 , n ) : NEW_LINE INDENT for y in range ( x + 1 , n + 1 ) : NEW_LINE INDENT if ( ( y * x ) % ( y + x ) == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int No_of_cubes ( int N , int K ) { int No = 0 ; No = ( N - K + 1 ) ; No = ( int ) Math . pow ( No , 3 ) ; return No ; }
Ref: 
def No_of_cubes ( N , K ) : NEW_LINE INDENT No = 0 NEW_LINE No = ( N - K + 1 ) NEW_LINE No = pow ( No , 3 ) NEW_LINE return No NEW_LINE DEDENT
Hyp: 
def No_of_cubes ( N , K ) : NEW_LINE INDENT No = 0 NEW_LINE No = ( N - K + 1 ) NEW_LINE No = pow ( No , 3 ) NEW_LINE return No NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int sum_series ( int n ) { int nSquare = n * n ; return nSquare * ( nSquare - 1 ) / 4 ; }
Ref: 
def sum_series ( n ) : NEW_LINE INDENT nSquare = n * n NEW_LINE return int ( nSquare * ( nSquare - 1 ) / 4 ) NEW_LINE DEDENT
Hyp: 
def sum_series ( n ) : NEW_LINE INDENT nSquare = n * n NEW_LINE return nSquare * ( nSquare - 1 ) / 4 NEW_LINE DEDENT

BLEU: 78.87
Edit Sim: 8


Src: 
int pentacontagonNum ( int n ) { return ( 48 * n * n - 46 * n ) / 2 ; }
Ref: 
def pentacontagonNum ( n ) : NEW_LINE INDENT return ( 48 * n * n - 46 * n ) // 2 NEW_LINE DEDENT
Hyp: 
def pentacontagonNum ( n ) : NEW_LINE INDENT return ( 48 * n * n - 46 * n ) // 2 NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int nthTerm ( int n ) { return 6 * ( int ) Math . pow ( n , 2 ) - 4 * n - 2 ; }
Ref: 
def nthTerm ( n ) : NEW_LINE INDENT return int ( 6 * pow ( n , 2 ) - 4 * n - 2 ) NEW_LINE DEDENT
Hyp: 
def nthTerm ( n ) : NEW_LINE INDENT return 6 * pow ( n , 2 ) - 4 * n - 2 ; NEW_LINE DEDENT

BLEU: 78.29
Edit Sim: 7


Src: 
void makePolygon ( double a ) { double n = 360 / ( 180 - a ) ; if ( n == ( int ) n ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; }
Ref: 
def makePolygon ( a ) : NEW_LINE INDENT n = 360 / ( 180 - a ) NEW_LINE if n == int ( n ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
Hyp: 
def makePolygon ( a ) : NEW_LINE INDENT n = 360 // ( 180 - a ) NEW_LINE if ( n == int ( n ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT

BLEU: 86.26
Edit Sim: 5


Src: 
boolean isSubSeqDivisible ( String str ) { int i , j , k , l = str . length ( ) ; int arr [ ] = new int [ l ] ; for ( i = 0 ; i < l ; i ++ ) arr [ i ] = str . charAt ( i ) - '0' ; for ( i = 0 ; i < l ; i ++ ) { for ( j = i ; j < l ; j ++ ) { for ( k = j ; k < l ; k ++ ) { if ( arr [ i ] % 8 == 0 ) return true ; else if ( ( arr [ i ] * 10 + arr [ j ] ) % 8 == 0 && i != j ) return true ; else if ( ( arr [ i ] * 100 + arr [ j ] * 10 + arr [ k ] ) % 8 == 0 && i != j && j != k && i != k ) return true ; } } } return false ; }
Ref: 
def isSubSeqDivisible ( st ) : NEW_LINE INDENT l = len ( st ) NEW_LINE arr = [ int ( ch ) for ch in st ] NEW_LINE for i in range ( 0 , l ) : NEW_LINE INDENT for j in range ( i , l ) : NEW_LINE INDENT for k in range ( j , l ) : NEW_LINE INDENT if ( arr [ i ] % 8 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT elif ( ( arr [ i ] * 10 + arr [ j ] ) % 8 == 0 and i != j ) : NEW_LINE INDENT return True NEW_LINE DEDENT elif ( ( arr [ i ] * 100 + arr [ j ] * 10 + arr [ k ] ) % 8 == 0 and i != j and j != k and i != k ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT DEDENT return False NEW_LINE DEDENT st = "3144" NEW_LINE if ( isSubSeqDivisible ( st ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
Hyp: 
def isSubSeqDivisible ( str ) : NEW_LINE INDENT l = len ( str ) NEW_LINE arr = [ 0 ] * l NEW_LINE for i in range ( l ) : NEW_LINE INDENT arr [ i ] = ord ( str [ i ] ) - ord ( '0' ) NEW_LINE DEDENT for i in range ( l ) : NEW_LINE INDENT for j in range ( i , l ) : NEW_LINE INDENT for k in range ( j , l ) : NEW_LINE INDENT if ( arr [ i ] % 8 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT elif ( ( arr [ i ] * 10 + arr [ j ] ) % 8 == 0 and i != j ) : NEW_LINE INDENT return True NEW_LINE DEDENT elif ( ( arr [ i ] * 100 + arr [ j ] * 10 + arr [ k ] ) % 8 == 0 and i != j and j != k and i != k ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT DEDENT return False NEW_LINE DEDENT

BLEU: 76.23
Edit Sim: 258


Src: 
void lengtang ( double r1 , double r2 , double d ) { System . out . println ( " The ▁ length ▁ of ▁ the ▁ direct " + " ▁ common ▁ tangent ▁ is ▁ " + ( Math . sqrt ( Math . pow ( d , 2 ) - Math . pow ( ( r1 - r2 ) , 2 ) ) ) ) ; }
Ref: 
def lengtang ( r1 , r2 , d ) : NEW_LINE INDENT print ( " The ▁ length ▁ of ▁ the ▁ direct ▁ common ▁ tangent ▁ is " , ( ( ( d ** 2 ) - ( ( r1 - r2 ) ** 2 ) ) ** ( 1 / 2 ) ) ) ; NEW_LINE DEDENT
Hyp: 
def lengtang ( r1 , r2 , d ) : NEW_LINE INDENT print ( " The ▁ length ▁ of ▁ the ▁ direct " , " ▁ common ▁ tangent ▁ is ▁ " , ( ( ( d ** 2 ) - ( ( r1 - r2 ) ** 2 ) ) ** 0.5 ) ) NEW_LINE DEDENT

BLEU: 80.6
Edit Sim: 19


Src: 
int count_required_sequence ( int n , int arr [ ] ) { int total_required_subsequence = 0 ; int total_n_required_subsequence = 0 ; int [ ] [ ] dp = new int [ N ] [ 2 ] ; for ( int i = 0 ; i < n ; i ++ ) { int turn_required = 0 ; for ( int j = - 1 ; j <= 1 ; j ++ ) turn_required += dp [ arr [ i ] + j ] [ 0 ] ; int required_end_i = ( total_required_subsequence + turn_required ) ; int n_required_end_i = ( 1 + total_n_required_subsequence - turn_required ) ; total_required_subsequence += required_end_i ; total_n_required_subsequence += n_required_end_i ; dp [ arr [ i ] ] [ 1 ] += required_end_i ; dp [ arr [ i ] ] [ 0 ] += n_required_end_i ; } return total_required_subsequence ; }
Ref: 
def count_required_sequence ( n , arr ) : NEW_LINE INDENT total_required_subsequence = 0 ; NEW_LINE total_n_required_subsequence = 0 ; NEW_LINE dp = np . zeros ( ( N , 2 ) ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT turn_required = 0 ; NEW_LINE for j in range ( - 1 , 2 , 1 ) : NEW_LINE INDENT turn_required += dp [ arr [ i ] + j ] [ 0 ] ; NEW_LINE DEDENT required_end_i = ( total_required_subsequence + turn_required ) ; NEW_LINE n_required_end_i = ( 1 + total_n_required_subsequence - turn_required ) ; NEW_LINE total_required_subsequence += required_end_i ; NEW_LINE total_n_required_subsequence += n_required_end_i ; NEW_LINE dp [ arr [ i ] ] [ 1 ] += required_end_i ; NEW_LINE dp [ arr [ i ] ] [ 0 ] += n_required_end_i ; NEW_LINE DEDENT return total_required_subsequence ; NEW_LINE DEDENT
Hyp: 
def count_required_sequence ( n , arr ) : NEW_LINE INDENT total_required_subsequence = 0 NEW_LINE total_n_required_subsequence = 0 NEW_LINE dp = [ [ 0 for col in range ( 2 ) ] for row in range ( N ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT turn_required = 0 NEW_LINE for j in range ( - 1 , 1 ) : NEW_LINE INDENT turn_required += dp [ arr [ i ] + j ] [ 0 ] NEW_LINE DEDENT required_end_i = ( total_required_subsequence + turn_required ) NEW_LINE n_required_end_i = ( 1 + total_n_required_subsequence - turn_required ) NEW_LINE total_required_subsequence += required_end_i NEW_LINE total_n_required_subsequence += n_required_end_i NEW_LINE dp [ arr [ i ] ] [ 1 ] += required_end_i NEW_LINE total_n_required_subsequence += n_required_end_i NEW_LINE DEDENT return total_required_subsequence NEW_LINE DEDENT

BLEU: 64.11
Edit Sim: 93


Src: 
void printAP ( int a , int d , int n ) { int curr_term ; curr_term = a ; for ( int i = 1 ; i <= n ; i ++ ) { System . out . print ( curr_term + " ▁ " ) ; curr_term = curr_term + d ; } }
Ref: 
def printAP ( a , d , n ) : NEW_LINE INDENT curr_term NEW_LINE DEDENT curr_term = a NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE DEDENT print ( curr_term , end = ' ▁ ' ) NEW_LINE INDENT curr_term = curr_term + d NEW_LINE DEDENT
Hyp: 
def printAP ( a , d , n ) : NEW_LINE INDENT curr_term = a NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( curr_term , end = " ▁ " ) NEW_LINE curr_term = curr_term + d NEW_LINE DEDENT DEDENT

BLEU: 72.07
Edit Sim: 51


Src: 
int numberOfDays ( int a , int b , int n ) { int Days = b * ( n + a ) / ( a + b ) ; return Days ; }
Ref: 
def numberOfDays ( a , b , n ) : NEW_LINE INDENT Days = b * ( n + a ) // ( a + b ) NEW_LINE return Days NEW_LINE DEDENT
Hyp: 
def numberOfDays ( a , b , n ) : NEW_LINE INDENT Days = b * ( n + a ) // ( a + b ) NEW_LINE return Days NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int count ( int n ) { return n * ( 3 * n - 1 ) / 2 ; }
Ref: 
def count ( n ) : NEW_LINE INDENT return n * ( 3 * n - 1 ) // 2 ; NEW_LINE DEDENT
Hyp: 
def count ( n ) : NEW_LINE INDENT return n * ( 3 * n - 1 ) // 2 NEW_LINE DEDENT

BLEU: 89.72
Edit Sim: 2


Src: 
double calculateProbability ( int N ) { double probability = ( double ) N / ( N + 1 ) ; return probability ; }
Ref: 
def calculateProbability ( N ) : NEW_LINE INDENT probability = N / ( N + 1 ) NEW_LINE return probability NEW_LINE DEDENT
Hyp: 
def calculateProbability ( N ) : NEW_LINE INDENT probability = N / ( N + 1 ) NEW_LINE return probability NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
void findMinSum ( int A [ ] , int K ) { int n = A . length ; int minimum_sum = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { int min = Integer . MAX_VALUE ; for ( int j = i + K ; j < n ; j ++ ) min = Math . min ( min , A [ j ] ) ; if ( min == Integer . MAX_VALUE ) continue ; minimum_sum = Math . min ( minimum_sum , A [ i ] + min ) ; } System . out . println ( minimum_sum ) ; }
Ref: 
def findMinSum ( A , K ) : NEW_LINE INDENT n = len ( A ) ; NEW_LINE minimum_sum = sys . maxsize ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT minimum = sys . maxsize ; NEW_LINE for j in range ( i + K , n , 1 ) : NEW_LINE INDENT minimum = min ( minimum , A [ j ] ) ; NEW_LINE DEDENT if ( minimum == sys . maxsize ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT minimum_sum = min ( minimum_sum , A [ i ] + minimum ) ; NEW_LINE DEDENT print ( minimum_sum ) ; NEW_LINE DEDENT
Hyp: 
def findMinSum ( A , K ) : NEW_LINE INDENT n = len ( A ) NEW_LINE minimum_sum = INT_MAX ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT min = INT_MAX ; NEW_LINE for j in range ( i + K , n ) : NEW_LINE INDENT min = min ( min , A [ j ] ) NEW_LINE DEDENT if ( min == INT_MAX ) : NEW_LINE INDENT continue NEW_LINE DEDENT minimum_sum = min ( minimum_sum , A [ i ] + min ) NEW_LINE DEDENT print ( minimum_sum ) NEW_LINE DEDENT

BLEU: 62.15
Edit Sim: 73


Src: 
int numPairs ( int a [ ] , int n ) { int ans , i , index ; ans = 0 ; for ( i = 0 ; i < n ; i ++ ) a [ i ] = Math . abs ( a [ i ] ) ; Arrays . sort ( a ) ; for ( i = 0 ; i < n ; i ++ ) { index = 2 ; ans += index - i - 1 ; } return ans ; }
Ref: 
def numPairs ( a , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT a [ i ] = abs ( a [ i ] ) NEW_LINE DEDENT a . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT index = 0 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( 2 * a [ i ] >= a [ j - 1 ] and 2 * a [ i ] < a [ j ] ) : NEW_LINE INDENT index = j NEW_LINE DEDENT DEDENT if index == 0 : NEW_LINE INDENT index = n NEW_LINE DEDENT ans += index - i - 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
Hyp: 
def numPairs ( a , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT a [ i ] = abs ( a [ i ] ) NEW_LINE DEDENT a . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT index = 2 NEW_LINE ans += index - i - 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT

BLEU: 39.39
Edit Sim: 216


Src: 
boolean check ( String str ) { int n = str . length ( ) ; if ( n == 0 ) return false ; if ( n == 1 ) return ( ( str . charAt ( 0 ) - '0' ) % 8 == 0 ) ; if ( n == 2 ) return ( ( ( str . charAt ( n - 2 ) - '0' ) * 10 + ( str . charAt ( n - 1 ) - '0' ) ) % 8 == 0 ) ; int last = str . charAt ( n - 1 ) - '0' ; int second_last = str . charAt ( n - 2 ) - '0' ; int third_last = str . charAt ( n - 3 ) - '0' ; return ( ( third_last * 100 + second_last * 10 + last ) % 8 == 0 ) ; }
Ref: 
def check ( st ) : NEW_LINE INDENT n = len ( st ) NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return ( ( int ) ( st [ 0 ] ) % 8 == 0 ) NEW_LINE DEDENT if ( n == 2 ) : NEW_LINE INDENT return ( ( int ) ( st [ n - 2 ] ) * 10 + ( ( int ) ( str [ n - 1 ] ) % 8 == 0 ) ) NEW_LINE DEDENT last = ( int ) ( st [ n - 1 ] ) NEW_LINE second_last = ( int ) ( st [ n - 2 ] ) NEW_LINE third_last = ( int ) ( st [ n - 3 ] ) NEW_LINE return ( ( third_last * 100 + second_last * 10 + last ) % 8 == 0 ) NEW_LINE DEDENT st = "76952" NEW_LINE if ( check ( st ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No ▁ " ) NEW_LINE DEDENT
Hyp: 
def check ( st ) : NEW_LINE INDENT n = len ( st ) NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return ( ( int ) ( st [ 0 ] ) % 8 == 0 ) ) NEW_LINE DEDENT if ( n == 2 ) : NEW_LINE INDENT return ( ( int ) ( st [ n - 2 ] ) * 10 + ( ( int ) ( st [ n - 1 ] ) % 8 == 0 ) ) NEW_LINE DEDENT last = ( int ) ( st [ n - 1 ] ) NEW_LINE second_last = ( int ) ( st [ n - 2 ] ) NEW_LINE third_last = ( int ) ( st [ n - 3 ] ) NEW_LINE return ( ( third_last * 100 + second_last * 10 + last ) % 8 == 0 ) NEW_LINE DEDENT st = "769528" NEW_LINE if ( check ( st ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT

BLEU: 95.77
Edit Sim: 6


Src: 
void SubString ( String str , int n ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j <= n ; j ++ ) System . out . println ( str . substring ( i , j ) ) ; }
Ref: 
def subString ( s , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for len in range ( i + 1 , n + 1 ) : NEW_LINE INDENT print ( s [ i : len ] ) ; NEW_LINE DEDENT DEDENT DEDENT
Hyp: 
def SubString ( string , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n + 1 ) : NEW_LINE INDENT print ( string [ i : j ] ) NEW_LINE DEDENT DEDENT DEDENT

BLEU: 67.41
Edit Sim: 23


Src: 
long fourthPowerSum ( int n ) { return ( ( 6 * n * n * n * n * n ) + ( 15 * n * n * n * n ) + ( 10 * n * n * n ) - n ) / 30 ; }
Ref: 
def fourthPowerSum ( n ) : NEW_LINE INDENT return ( ( 6 * n * n * n * n * n ) + ( 15 * n * n * n * n ) + ( 10 * n * n * n ) - n ) / 30 NEW_LINE DEDENT
Hyp: 
def fourthPowerSum ( n ) : NEW_LINE INDENT return ( ( 6 * n * n * n * n * n ) + ( 15 * n * n * n ) + ( 10 * n * n * n ) - n ) // 30 NEW_LINE DEDENT

BLEU: 91.15
Edit Sim: 5


Src: 
String check ( int S , int prices [ ] , int type [ ] , int n ) { for ( int j = 0 ; j < n ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) { if ( ( type [ j ] == 0 && type [ k ] == 1 ) || ( type [ j ] == 1 && type [ k ] == 0 ) ) { if ( prices [ j ] + prices [ k ] <= S ) { return " Yes " ; } } } } return " No " ; }
Ref: 
def check ( S , prices , type1 , n ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT if ( ( type1 [ j ] == 0 and type1 [ k ] == 1 ) or ( type1 [ j ] == 1 and type1 [ k ] == 0 ) ) : NEW_LINE INDENT if ( prices [ j ] + prices [ k ] <= S ) : NEW_LINE INDENT return " Yes " ; NEW_LINE DEDENT DEDENT DEDENT DEDENT return " No " ; NEW_LINE DEDENT
Hyp: 
def check ( S , prices , type , n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT if ( ( type [ j ] == 0 and type [ k ] == 1 ) or ( type [ j ] == 1 and type [ k ] == 0 ) ) : NEW_LINE INDENT if ( prices [ j ] + prices [ k ] <= S ) : NEW_LINE INDENT return " Yes " NEW_LINE DEDENT DEDENT DEDENT DEDENT return " No " NEW_LINE DEDENT

BLEU: 80.71
Edit Sim: 13


Src: 
int findCntTriplet ( int N ) { int cntTriplet = 0 ; for ( int i = 1 ; i < N ; i ++ ) { if ( N % i != 0 ) { cntTriplet += N / i ; } else { cntTriplet += ( N / i ) - 1 ; } } return cntTriplet ; }
Ref: 
def findCntTriplet ( N ) : NEW_LINE INDENT cntTriplet = 0 ; NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT if ( N % i != 0 ) : NEW_LINE INDENT cntTriplet += N // i ; NEW_LINE DEDENT else : NEW_LINE INDENT cntTriplet += ( N // i ) - 1 ; NEW_LINE DEDENT DEDENT return cntTriplet ; NEW_LINE DEDENT
Hyp: 
def findCntTriplet ( N ) : NEW_LINE INDENT cntTriplet = 0 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT if ( N % i != 0 ) : NEW_LINE INDENT cntTriplet += N // i NEW_LINE DEDENT else : NEW_LINE INDENT cntTriplet += ( N // i ) - 1 NEW_LINE DEDENT DEDENT return cntTriplet NEW_LINE DEDENT

BLEU: 84.62
Edit Sim: 8


Src: 
boolean sumOfTwoCubes ( int n ) { int lo = 1 , hi = ( int ) Math . cbrt ( n ) ; while ( lo <= hi ) { int curr = ( lo * lo * lo + hi * hi * hi ) ; if ( curr == n ) return true ; if ( curr < n ) lo ++ ; else hi -- ; } return false ; }
Ref: 
def sumOfTwoCubes ( n ) : NEW_LINE INDENT lo = 1 NEW_LINE hi = round ( math . pow ( n , 1 / 3 ) ) NEW_LINE while ( lo <= hi ) : NEW_LINE INDENT curr = ( lo * lo * lo + hi * hi * hi ) NEW_LINE if ( curr == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( curr < n ) : NEW_LINE INDENT lo += 1 NEW_LINE DEDENT else : NEW_LINE INDENT hi -= 1 NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT N = 28 NEW_LINE if ( sumOfTwoCubes ( N ) ) : NEW_LINE INDENT print ( " True " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " False " ) NEW_LINE DEDENT
Hyp: 
def sumOfTwoCubes ( n ) : NEW_LINE INDENT lo = 1 NEW_LINE hi = int ( math . cbrt ( n ) ) NEW_LINE while ( lo <= hi ) : NEW_LINE INDENT curr = ( lo * lo * lo + hi * hi * hi ) NEW_LINE if ( curr == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( curr < n ) : NEW_LINE INDENT lo += 1 NEW_LINE DEDENT else : NEW_LINE INDENT hi -= 1 NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT n = 1 NEW_LINE if ( sumOfTwoCubes ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT

BLEU: 82.59
Edit Sim: 29


Src: 
void lengequichord ( int z ) { System . out . println ( " The ▁ distance ▁ between ▁ the ▁ " + " chord ▁ and ▁ the ▁ center ▁ is ▁ " + z ) ; }
Ref: 
def lengequichord ( z ) : NEW_LINE INDENT print ( " The ▁ distance ▁ between ▁ the " , " chord ▁ and ▁ the ▁ center ▁ is " , z ) NEW_LINE DEDENT
Hyp: 
def lgequichord ( z ) : NEW_LINE INDENT print ( " The ▁ distance ▁ between ▁ the ▁ " , " chord ▁ and ▁ the ▁ center ▁ is ▁ " , z ) NEW_LINE DEDENT

BLEU: 81.45
Edit Sim: 6


Src: 
long powerNumbers ( int n ) { HashSet < Long > v = new HashSet < Long > ( ) ; for ( long i = 2 ; i * i * i <= n ; i ++ ) { long j = i * i ; while ( j * i <= n ) { j *= i ; long s = ( long ) Math . sqrt ( j ) ; if ( s * s != j ) v . add ( j ) ; } } return v . size ( ) + ( long ) Math . sqrt ( n ) ; }
Ref: 
def powerNumbers ( n ) : NEW_LINE INDENT v = [ ] NEW_LINE for i in range ( 2 , int ( math . pow ( n , 1.0 / 3.0 ) ) + 1 ) : NEW_LINE INDENT j = i * i NEW_LINE while ( j * i <= n ) : NEW_LINE INDENT j = j * i NEW_LINE s = int ( math . sqrt ( j ) ) NEW_LINE if ( s * s != j ) : NEW_LINE INDENT v . append ( j ) NEW_LINE DEDENT DEDENT DEDENT v . sort ( ) NEW_LINE v = list ( dict . fromkeys ( v ) ) NEW_LINE return len ( v ) + int ( math . sqrt ( n ) ) NEW_LINE DEDENT
Hyp: 
def powerNumbers ( n ) : NEW_LINE INDENT v = dict ( ) NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT j = i * i NEW_LINE while ( j * i <= n ) : NEW_LINE INDENT j *= i NEW_LINE s = math . sqrt ( j ) NEW_LINE if ( s * s != j ) : NEW_LINE INDENT v [ j ] = 1 NEW_LINE DEDENT DEDENT DEDENT return len ( v ) NEW_LINE DEDENT

BLEU: 47.15
Edit Sim: 159


Src: 
int findWinner ( int N ) { return N & 1 ; }
Ref: 
def findWinner ( N ) : NEW_LINE INDENT return N & 1 NEW_LINE DEDENT
Hyp: 
def findWinner ( N ) : NEW_LINE INDENT return N & 1 NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int toggle ( int n ) { int temp = 1 ; while ( temp <= n ) { n = n ^ temp ; temp = temp << 1 ; } return n ; }
Ref: 
def toggle ( n ) : NEW_LINE INDENT temp = 1 NEW_LINE while ( temp <= n ) : NEW_LINE INDENT n = n ^ temp NEW_LINE temp = temp << 1 NEW_LINE DEDENT return n NEW_LINE DEDENT
Hyp: 
def toggle ( n ) : NEW_LINE INDENT temp = 1 NEW_LINE while ( temp <= n ) : NEW_LINE INDENT n = n ^ temp NEW_LINE temp = temp << 1 NEW_LINE DEDENT return n NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int getValue ( int n ) { int i = 0 , k = 1 ; while ( i < n ) { i = i + k ; k = k * 2 ; } return k / 2 ; }
Ref: 
def getValue ( n ) : NEW_LINE INDENT i = 0 ; NEW_LINE k = 1 ; NEW_LINE while ( i < n ) : NEW_LINE INDENT i = i + k ; NEW_LINE k = k * 2 ; NEW_LINE DEDENT return int ( k / 2 ) ; NEW_LINE DEDENT
Hyp: 
def getValue ( n ) : NEW_LINE INDENT i = 0 NEW_LINE k = 1 NEW_LINE while ( i < n ) : NEW_LINE INDENT i = i + k NEW_LINE k = k * 2 NEW_LINE DEDENT return k // 2 NEW_LINE DEDENT

BLEU: 63.3
Edit Sim: 19


Src: 
void thirdLargest ( int arr [ ] , int arr_size ) { if ( arr_size < 3 ) { System . out . printf ( " ▁ Invalid ▁ Input ▁ " ) ; return ; } int first = arr [ 0 ] ; for ( int i = 1 ; i < arr_size ; i ++ ) if ( arr [ i ] > first ) first = arr [ i ] ; int second = Integer . MIN_VALUE ; for ( int i = 0 ; i < arr_size ; i ++ ) if ( arr [ i ] > second && arr [ i ] < first ) second = arr [ i ] ; int third = Integer . MIN_VALUE ; for ( int i = 0 ; i < arr_size ; i ++ ) if ( arr [ i ] > third && arr [ i ] < second ) third = arr [ i ] ; System . out . printf ( " The ▁ third ▁ Largest ▁ " + "element is %dNEW_LINE", third); }
Ref: 
def thirdLargest ( arr , arr_size ) : NEW_LINE INDENT if ( arr_size < 3 ) : NEW_LINE INDENT print ( " ▁ Invalid ▁ Input ▁ " ) NEW_LINE return NEW_LINE DEDENT first = arr [ 0 ] NEW_LINE for i in range ( 1 , arr_size ) : NEW_LINE INDENT if ( arr [ i ] > first ) : NEW_LINE INDENT first = arr [ i ] NEW_LINE DEDENT DEDENT second = - sys . maxsize NEW_LINE for i in range ( 0 , arr_size ) : NEW_LINE INDENT if ( arr [ i ] > second and arr [ i ] < first ) : NEW_LINE INDENT second = arr [ i ] NEW_LINE DEDENT DEDENT third = - sys . maxsize NEW_LINE for i in range ( 0 , arr_size ) : NEW_LINE INDENT if ( arr [ i ] > third and arr [ i ] < second ) : NEW_LINE INDENT third = arr [ i ] NEW_LINE DEDENT DEDENT print ( " The ▁ Third ▁ Largest " , " element ▁ is " , third ) NEW_LINE DEDENT
Hyp: 
def thirdLargest ( arr , arr_size ) : NEW_LINE INDENT if ( arr_size < 3 ) : NEW_LINE INDENT print ( " ▁ Invalid ▁ Input ▁ " ) NEW_LINE return NEW_LINE DEDENT first = arr [ 0 ] NEW_LINE for i in range ( 1 , arr_size ) : NEW_LINE INDENT if ( arr [ i ] > first ) : NEW_LINE INDENT first = arr [ i ] NEW_LINE DEDENT second = Integer . MIN_VALUE NEW_LINE for i in range ( arr_size ) : NEW_LINE INDENT if ( arr [ i ] > second and arr [ i ] < first ) : NEW_LINE INDENT second = arr [ i ] NEW_LINE DEDENT third = Integer . MIN_VALUE NEW_LINE for i in range ( arr_size ) : NEW_LINE INDENT if ( arr [ i ] > third and arr [ i ] < second ) : NEW_LINE INDENT third = arr [ i ] NEW_LINE DEDENT DEDENT print ( " The ▁ third ▁ Largest ▁ " , " is %d" , third ) NEW_LINE DEDENT

BLEU: 83.73
Edit Sim: 68


Src: 
int nthTerm ( int N ) { int nth = 0 , first_term = 4 ; int pi = 1 , po = 1 ; int n = N ; while ( n > 1 ) { pi *= n - 1 ; n -- ; po *= 2 ; } nth = ( first_term * pi ) / po ; return nth ; }
Ref: 
def nthTerm ( N ) : NEW_LINE INDENT nth = 0 ; first_term = 4 ; NEW_LINE pi = 1 ; po = 1 ; NEW_LINE n = N ; NEW_LINE while ( n > 1 ) : NEW_LINE INDENT pi *= n - 1 ; NEW_LINE n -= 1 ; NEW_LINE po *= 2 ; NEW_LINE DEDENT nth = ( first_term * pi ) // po ; NEW_LINE return nth ; NEW_LINE DEDENT
Hyp: 
def nthTerm ( N ) : NEW_LINE INDENT nth = 0 NEW_LINE first_term = 4 NEW_LINE pi = 1 NEW_LINE po = 1 NEW_LINE n = N NEW_LINE while ( n > 1 ) : NEW_LINE INDENT pi *= n - 1 NEW_LINE n -= 1 NEW_LINE po *= 2 NEW_LINE DEDENT nth = ( first_term * pi ) // po NEW_LINE return nth NEW_LINE DEDENT

BLEU: 63.9
Edit Sim: 32


Src: 
int count ( int n ) { int table [ ] = new int [ n + 1 ] , i ; Arrays . fill ( table , 0 ) ; table [ 0 ] = 1 ; for ( i = 3 ; i <= n ; i ++ ) table [ i ] += table [ i - 3 ] ; for ( i = 5 ; i <= n ; i ++ ) table [ i ] += table [ i - 5 ] ; for ( i = 10 ; i <= n ; i ++ ) table [ i ] += table [ i - 10 ] ; return table [ n ] ; }
Ref: 
def count ( n ) : NEW_LINE INDENT table = [ 0 for i in range ( n + 1 ) ] NEW_LINE table [ 0 ] = 1 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT table [ i ] += table [ i - 3 ] NEW_LINE DEDENT for i in range ( 5 , n + 1 ) : NEW_LINE INDENT table [ i ] += table [ i - 5 ] NEW_LINE DEDENT for i in range ( 10 , n + 1 ) : NEW_LINE INDENT table [ i ] += table [ i - 10 ] NEW_LINE DEDENT return table [ n ] NEW_LINE DEDENT
Hyp: 
def count ( n ) : NEW_LINE INDENT table = [ 0 ] * ( n + 1 ) NEW_LINE table [ 0 ] = 1 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT table [ i ] += table [ i - 3 ] NEW_LINE DEDENT for i in range ( 5 , n + 1 ) : NEW_LINE INDENT table [ i ] += table [ i - 5 ] NEW_LINE DEDENT for i in range ( 10 , n + 1 ) : NEW_LINE INDENT table [ i ] += table [ i - 10 ] NEW_LINE DEDENT return table [ n ] NEW_LINE DEDENT

BLEU: 93.33
Edit Sim: 15


Src: 
int findRepeatFirstN2 ( String s ) { int p = - 1 , i , j ; for ( i = 0 ; i < s . length ( ) ; i ++ ) { for ( j = i + 1 ; j < s . length ( ) ; j ++ ) { if ( s . charAt ( i ) == s . charAt ( j ) ) { p = i ; break ; } } if ( p != - 1 ) break ; } return p ; }
Ref: 
def findRepeatFirstN2 ( s ) : NEW_LINE INDENT p = - 1 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT for j in range ( i + 1 , len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == s [ j ] ) : NEW_LINE INDENT p = i NEW_LINE break NEW_LINE DEDENT DEDENT if ( p != - 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return p NEW_LINE DEDENT
Hyp: 
def findRepeatFirstN2 ( s ) : NEW_LINE INDENT p = - 1 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT for j in range ( i + 1 , len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == s [ j ] ) : NEW_LINE INDENT p = i NEW_LINE break NEW_LINE DEDENT DEDENT if ( p != - 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return p NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int minimumStepReqArr ( int [ ] arr , int N ) { int cntStep = 0 ; N += 1 ; for ( int i = 31 ; i >= 0 ; i -- ) { if ( ( N & ( 1 << i ) ) != 0 ) { cntStep += 1 ; } } return cntStep ; }
Ref: 
def minimumStepReqArr ( arr , N ) : NEW_LINE INDENT cntStep = 0 NEW_LINE N += 1 NEW_LINE i = 31 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT if ( N & ( 1 << i ) ) : NEW_LINE INDENT cntStep += 1 NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT return cntStep NEW_LINE DEDENT
Hyp: 
def minimumStepReqArr ( arr , N ) : NEW_LINE INDENT cntStep = 0 NEW_LINE N += 1 NEW_LINE for i in range ( 31 , - 1 , - 1 ) : NEW_LINE INDENT if ( ( N & ( 1 << i ) ) != 0 ) : NEW_LINE INDENT cntStep += 1 NEW_LINE DEDENT DEDENT return cntStep NEW_LINE DEDENT

BLEU: 68.66
Edit Sim: 50


Src: 
int nextPerfectSquare ( int N ) { int nextN = ( int ) Math . floor ( Math . sqrt ( N ) ) + 1 ; return nextN * nextN ; }
Ref: 
def nextPerfectSquare ( N ) : NEW_LINE INDENT nextN = math . floor ( math . sqrt ( N ) ) + 1 NEW_LINE return nextN * nextN NEW_LINE DEDENT
Hyp: 
def nextPerfectSquare ( N ) : NEW_LINE INDENT nextN = math . floor ( math . sqrt ( N ) ) + 1 NEW_LINE return nextN * nextN NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int countSolutions ( int n ) { int x = 0 , yCount , res = 0 ; for ( yCount = 0 ; yCount * yCount < n ; yCount ++ ) ; while ( yCount != 0 ) { res += yCount ; x ++ ; while ( yCount != 0 && ( x * x + ( yCount - 1 ) * ( yCount - 1 ) >= n ) ) yCount -- ; } return res ; }
Ref: 
def countSolutions ( n ) : NEW_LINE INDENT x = 0 NEW_LINE res = 0 NEW_LINE yCount = 0 NEW_LINE while ( yCount * yCount < n ) : NEW_LINE INDENT yCount = yCount + 1 NEW_LINE DEDENT while ( yCount != 0 ) : NEW_LINE INDENT res = res + yCount NEW_LINE x = x + 1 NEW_LINE while ( yCount != 0 and ( x * x + ( yCount - 1 ) * ( yCount - 1 ) >= n ) ) : NEW_LINE INDENT yCount = yCount - 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
Hyp: 
def countSolutions ( n ) : NEW_LINE INDENT x = 0 ; yCount = 0 ; NEW_LINE res = 0 ; NEW_LINE for yCount in range ( n ) : NEW_LINE INDENT res += yCount ; NEW_LINE x += 1 ; NEW_LINE while ( yCount != 0 ) : NEW_LINE INDENT res += yCount ; NEW_LINE x += 1 ; NEW_LINE while ( x * x + ( yCount - 1 ) * ( yCount - 1 ) >= n ) : NEW_LINE INDENT yCount -= 1 ; NEW_LINE DEDENT DEDENT return res ; NEW_LINE DEDENT

BLEU: 55.63
Edit Sim: 108


Src: 
void isEqualFactors ( int N ) { int ev_count = 0 , od_count = 0 ; for ( int i = 1 ; i <= Math . sqrt ( N ) + 1 ; i ++ ) { if ( N % i == 0 ) { if ( i == N / i ) { if ( i % 2 == 0 ) ev_count += 1 ; else od_count += 1 ; } else { if ( i % 2 == 0 ) ev_count += 1 ; else od_count += 1 ; if ( ( N / i ) % 2 == 0 ) ev_count += 1 ; else od_count += 1 ; } } } if ( ev_count == od_count ) System . out . print ( " YES " + "NEW_LINE"); else System . out . print ( " NO " + "NEW_LINE"); }
Ref: 
def isEqualFactors ( N ) : NEW_LINE INDENT ev_count = 0 NEW_LINE od_count = 0 NEW_LINE for i in range ( 1 , ( int ) ( math . sqrt ( N ) ) + 2 ) : NEW_LINE INDENT if ( N % i == 0 ) : NEW_LINE INDENT if ( i == N // i ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT ev_count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT od_count += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT ev_count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT od_count += 1 NEW_LINE DEDENT if ( ( N // i ) % 2 == 0 ) : NEW_LINE INDENT ev_count += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT od_count += 1 ; NEW_LINE DEDENT DEDENT DEDENT DEDENT if ( ev_count == od_count ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
Hyp: 
def isEqualFactors ( N ) : NEW_LINE INDENT ev_count = 0 NEW_LINE od_count = 0 NEW_LINE for i in range ( 1 , int ( sqrt ( N ) + 1 ) ) : NEW_LINE INDENT if ( N % i == 0 ) : NEW_LINE INDENT if ( i == N // i ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT ev_count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT od_count += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT ev_count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ev_count += 1 NEW_LINE DEDENT if ( ( N // i ) % 2 == 0 ) : NEW_LINE INDENT ev_count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ev_count += 1 NEW_LINE DEDENT DEDENT DEDENT if ( ev_count == od_count ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT

BLEU: 88.03
Edit Sim: 29


Src: 
void lastDigit ( String a , String b ) { int lastDig = ( a . charAt ( a . length ( ) - 1 ) - '0' ) * ( b . charAt ( b . length ( ) - 1 ) - '0' ) ; System . out . println ( lastDig % 10 ) ; }
Ref: 
def lastDigit ( a , b ) : NEW_LINE INDENT lastDig = ( ( int ( a [ len ( a ) - 1 ] ) - int ( '0' ) ) * ( int ( b [ len ( b ) - 1 ] ) - int ( '0' ) ) ) NEW_LINE print ( lastDig % 10 ) NEW_LINE DEDENT
Hyp: 
def lastDigit ( a , b ) : NEW_LINE INDENT lastDig = ( ord ( a [ len ( a ) - 1 ] ) - ord ( b [ len ( b ) - 1 ] ) ) NEW_LINE print ( lastDig % 10 ) NEW_LINE DEDENT

BLEU: 65.35
Edit Sim: 42


Src: 
int nthEnneadecagonal ( int n ) { return ( 17 * n * n - 15 * n ) / 2 ; }
Ref: 
def nthEnneadecagonal ( n ) : NEW_LINE INDENT return ( 17 * n * n - 15 * n ) // 2 NEW_LINE DEDENT
Hyp: 
def nthEnneadecagonal ( n ) : NEW_LINE INDENT return ( 17 * n * n - 15 * n ) // 2 NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int countPaths ( int sum , int get , int m , int n , int dp [ ] [ ] ) { if ( sum < 0 ) return 0 ; if ( sum == 0 ) return get ; if ( dp [ sum ] [ get ] != - 1 ) return dp [ sum ] [ get ] ; int res = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i == m ) res += countPaths ( sum - i , 1 , m , n , dp ) ; res += countPaths ( sum - i , get , m , n , dp ) ; } dp [ sum ] [ get ] = res ; return dp [ sum ] [ get ] ; }
Ref: 
def countPaths ( Sum , get , m , n , dp ) : NEW_LINE INDENT if ( Sum < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( Sum == 0 ) : NEW_LINE INDENT return get NEW_LINE DEDENT if ( dp [ Sum ] [ get ] != - 1 ) : NEW_LINE INDENT return dp [ Sum ] [ get ] NEW_LINE DEDENT res = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( i == m ) : NEW_LINE INDENT res += countPaths ( Sum - i , 1 , m , n , dp ) NEW_LINE res += countPaths ( Sum - i , get , m , n , dp ) NEW_LINE DEDENT DEDENT dp [ Sum ] [ get ] = res NEW_LINE return dp [ Sum ] [ get ] NEW_LINE DEDENT n = 3 NEW_LINE m = 2 NEW_LINE x = 3 NEW_LINE dp = [ [ - 1 for i in range ( 2 ) ] for i in range ( Max + 1 ) ] NEW_LINE for i in range ( Max + 1 ) : NEW_LINE INDENT for j in range ( 2 ) : NEW_LINE INDENT dp [ i ] [ j ] = - 1 NEW_LINE DEDENT DEDENT
Hyp: 
def countPaths ( sum , get , m , n , dp ) : NEW_LINE INDENT if ( sum < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( sum == 0 ) : NEW_LINE INDENT return get NEW_LINE DEDENT if ( dp [ sum ] [ get ] != - 1 ) : NEW_LINE INDENT return dp [ sum ] [ get ] NEW_LINE DEDENT res = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( i == m ) : NEW_LINE INDENT res += countPaths ( sum - i , 1 , m , n , dp ) NEW_LINE DEDENT res += countPaths ( sum - i , get , m , n , dp ) NEW_LINE DEDENT dp [ sum ] [ get ] = res NEW_LINE return dp [ sum ] [ get ] NEW_LINE DEDENT

BLEU: 51.36
Edit Sim: 270


Src: 
int tetracontagonNum ( int n ) { return ( 38 * n * n - 36 * n ) / 2 ; }
Ref: 
def tetracontagonNum ( n ) : NEW_LINE INDENT return ( 38 * n * n - 36 * n ) // 2 NEW_LINE DEDENT
Hyp: 
def tetracontagonNum ( n ) : NEW_LINE INDENT return ( 38 * n * n - 36 * n ) // 2 NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
boolean ishendecagonal ( int N ) { double n = ( 7 + Math . sqrt ( 72 * N + 49 ) ) / 18 ; return ( n - ( int ) n ) == 0 ; }
Ref: 
def ishendecagonal ( N ) : NEW_LINE INDENT n = ( 7 + math . sqrt ( 72 * N + 49 ) ) // 18 ; NEW_LINE return ( n - int ( n ) ) == 0 ; NEW_LINE DEDENT N = 11 ; NEW_LINE if ( ishendecagonal ( N ) ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT
Hyp: 
def ishendecagonal ( N ) : NEW_LINE INDENT n = ( 7 + math . sqrt ( 72 * N + 49 ) ) // 18 NEW_LINE return ( ( n - int ( n ) ) == 0 ) NEW_LINE DEDENT

BLEU: 36.19
Edit Sim: 162


Src: 
int countBits ( int a , int b ) { int count = 0 ; while ( a > 0 b > 0 ) { int last_bit_a = a & 1 ; int last_bit_b = b & 1 ; if ( last_bit_a != last_bit_b ) count ++ ; a = a >> 1 ; b = b >> 1 ; } return count ; }
Ref: 
def countBits ( a , b ) : NEW_LINE INDENT count = 0 NEW_LINE while ( a or b ) : NEW_LINE INDENT last_bit_a = a & 1 NEW_LINE last_bit_b = b & 1 NEW_LINE if ( last_bit_a != last_bit_b ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT a = a >> 1 NEW_LINE b = b >> 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
Hyp: 
def countBits ( a , b ) : NEW_LINE INDENT count = 0 NEW_LINE while ( a > 0 or b > 0 ) : NEW_LINE INDENT last_bit_a = a & 1 NEW_LINE last_bit_b = b & 1 NEW_LINE if ( last_bit_a != last_bit_b ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT a = a >> 1 NEW_LINE b = b >> 1 NEW_LINE DEDENT return count NEW_LINE DEDENT

BLEU: 90.19
Edit Sim: 8


Src: 
int countOccurrences ( String str , String word ) { String a [ ] = str . split ( " ▁ " ) ; int count = 0 ; for ( int i = 0 ; i < a . length ; i ++ ) { if ( word . equals ( a [ i ] ) ) count ++ ; } return count ; }
Ref: 
def countOccurrences ( str , word ) : NEW_LINE INDENT a = str . split ( " ▁ " ) NEW_LINE count = 0 NEW_LINE for i in range ( 0 , len ( a ) ) : NEW_LINE INDENT if ( word == a [ i ] ) : NEW_LINE count = count + 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
Hyp: 
def countOccurrences ( string , word ) : NEW_LINE INDENT a = string . split ( " ▁ " ) NEW_LINE count = 0 NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT if ( word == a [ i ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT

BLEU: 75.63
Edit Sim: 25


Src: 
void charactersCount ( String str , int n ) { int count = 0 ; while ( n > 0 ) { char cur = str . charAt ( 0 ) ; int ind = 0 ; for ( int j = 1 ; j < n ; j ++ ) { if ( str . charAt ( j ) < cur ) { cur = str . charAt ( j ) ; ind = j ; } } str = str . substring ( 0 , ind ) + str . substring ( ind + 1 ) ; n -- ; count += ind + 1 ; } System . out . print ( count + "NEW_LINE"); }
Ref: 
def charactersCount ( str , n ) : NEW_LINE INDENT count = 0 ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT cur = str [ 0 ] ; NEW_LINE ind = 0 ; NEW_LINE for j in range ( 1 , n ) : NEW_LINE INDENT if ( str [ j ] < cur ) : NEW_LINE INDENT cur = str [ j ] ; NEW_LINE ind = j ; NEW_LINE DEDENT DEDENT str = str [ 0 : ind ] + str [ ind + 1 : ] ; NEW_LINE n -= 1 ; NEW_LINE count += ind + 1 ; NEW_LINE DEDENT print ( count ) ; NEW_LINE DEDENT
Hyp: 
def charactersCount ( str , n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT cur = str [ 0 ] NEW_LINE ind = 0 NEW_LINE for j in range ( 1 , n ) : NEW_LINE INDENT if ( str [ j ] < cur ) : NEW_LINE INDENT cur = str [ j ] NEW_LINE ind = j NEW_LINE DEDENT DEDENT str = str [ ind : ] + str [ ind + 1 : ] NEW_LINE n -= 1 NEW_LINE count += ind + 1 NEW_LINE DEDENT print ( count ) NEW_LINE DEDENT

BLEU: 75.77
Edit Sim: 24


Src: 
double area ( int R ) { double base = 1.732 * R ; double height = ( 1.5 ) * R ; double area = 0.5 * base * height ; return area ; }
Ref: 
def area ( R ) : NEW_LINE INDENT base = 1.732 * R NEW_LINE height = ( 3 / 2 ) * R NEW_LINE area = ( ( 1 / 2 ) * base * height ) NEW_LINE return area NEW_LINE DEDENT
Hyp: 
def area ( R ) : NEW_LINE INDENT base = 1.732 * R NEW_LINE height = ( 1.5 ) * R NEW_LINE area = 0.5 * base * height NEW_LINE return area NEW_LINE DEDENT

BLEU: 62.85
Edit Sim: 18


Src: 
int leastValue ( int P , int A , int N , int a [ ] ) { int ans = - 1 ; float tmp = Float . MAX_VALUE ; for ( int i = 0 ; i < N ; i ++ ) { float t = ( float ) ( P - a [ i ] * 0.006 ) ; if ( Math . abs ( t - A ) < tmp ) { tmp = Math . abs ( t - A ) ; ans = i ; } } return a [ ans ] ; }
Ref: 
def leastValue ( P , A , N , a ) : NEW_LINE INDENT ans = - 1 NEW_LINE tmp = float ( ' inf ' ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT t = P - a [ i ] * 0.006 NEW_LINE if abs ( t - A ) < tmp : NEW_LINE INDENT tmp = abs ( t - A ) NEW_LINE ans = i NEW_LINE DEDENT DEDENT return a [ ans ] NEW_LINE DEDENT
Hyp: 
def leastValue ( P , A , N , a ) : NEW_LINE INDENT ans = - 1 NEW_LINE tmp = 10 ** 20 NEW_LINE for i in range ( N ) : NEW_LINE INDENT t = ( P - a [ i ] * 0.006 ) NEW_LINE if ( abs ( t - A ) < tmp ) : NEW_LINE INDENT tmp = abs ( t - A ) NEW_LINE ans = i NEW_LINE DEDENT DEDENT return a [ ans ] NEW_LINE DEDENT

BLEU: 83.4
Edit Sim: 23


Src: 
int countNumbers ( int n ) { return ( n / 2520 ) ; }
Ref: 
def countNumbers ( n ) : NEW_LINE INDENT return n // 2520 NEW_LINE DEDENT
Hyp: 
def countNumbers ( n ) : NEW_LINE INDENT return ( n // 2520 ) ; NEW_LINE DEDENT

BLEU: 62.69
Edit Sim: 6


Src: 
int distinct ( int [ ] arr , int n ) { int count = 0 ; if ( n == 1 ) return 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( i == 0 ) { if ( arr [ i ] != arr [ i + 1 ] ) count += 1 ; } else { if ( arr [ i ] != arr [ i + 1 ] arr [ i ] != arr [ i - 1 ] ) count += 1 ; } } if ( arr [ n - 1 ] != arr [ n - 2 ] ) count += 1 ; return count ; }
Ref: 
def distinct ( arr ) : NEW_LINE INDENT count = 0 NEW_LINE if len ( arr ) == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT for i in range ( 0 , len ( arr ) - 1 ) : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT if ( arr [ i ] != arr [ i + 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT elif ( i > 0 & i < len ( arr ) - 1 ) : NEW_LINE INDENT if ( arr [ i ] != arr [ i + 1 ] or arr [ i ] != arr [ i - 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT if ( arr [ len ( arr ) - 1 ] != arr [ len ( arr ) - 2 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
Hyp: 
def distinct ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT if ( arr [ i ] != arr [ i + 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( arr [ i ] != arr [ i + 1 ] arr [ i ] != arr [ i - 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( arr [ n - 1 ] != arr [ n - 2 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT

BLEU: 71.08
Edit Sim: 92


Src: 
int countPairs ( String s1 , int n1 , String s2 , int n2 ) { int [ ] freq1 = new int [ 26 ] ; int [ ] freq2 = new int [ 26 ] ; Arrays . fill ( freq1 , 0 ) ; Arrays . fill ( freq2 , 0 ) ; int i , count = 0 ; for ( i = 0 ; i < n1 ; i ++ ) freq1 [ s1 . charAt ( i ) - ' a ' ] ++ ; for ( i = 0 ; i < n2 ; i ++ ) freq2 [ s2 . charAt ( i ) - ' a ' ] ++ ; for ( i = 0 ; i < 26 ; i ++ ) count += ( Math . min ( freq1 [ i ] , freq2 [ i ] ) ) ; return count ; }
Ref: 
def countPairs ( s1 , n1 , s2 , n2 ) : NEW_LINE INDENT freq1 = [ 0 ] * 26 ; NEW_LINE freq2 = [ 0 ] * 26 ; NEW_LINE count = 0 ; NEW_LINE for i in range ( n1 ) : NEW_LINE INDENT freq1 [ ord ( s1 [ i ] ) - ord ( ' a ' ) ] += 1 ; NEW_LINE DEDENT for i in range ( n2 ) : NEW_LINE INDENT freq2 [ ord ( s2 [ i ] ) - ord ( ' a ' ) ] += 1 ; NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT count += min ( freq1 [ i ] , freq2 [ i ] ) ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT
Hyp: 
def countPairs ( s1 , n1 , s2 , n2 ) : NEW_LINE INDENT freq1 = [ 0 ] * 26 NEW_LINE freq2 = [ 0 ] * 26 NEW_LINE count = 0 NEW_LINE for i in range ( n1 ) : NEW_LINE INDENT freq1 [ ord ( i ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( n2 ) : NEW_LINE INDENT freq2 [ ord ( s2 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT count += ( min ( freq1 [ i ] , freq2 [ i ] ) ) NEW_LINE DEDENT return count NEW_LINE DEDENT

BLEU: 81.31
Edit Sim: 22


Src: 
void canBeReduced ( int x , int y ) { int maxi = Math . max ( x , y ) ; int mini = Math . min ( x , y ) ; if ( ( ( x + y ) % 3 ) == 0 && maxi <= 2 * mini ) System . out . print ( " YES " + "NEW_LINE"); else System . out . print ( " NO " + "NEW_LINE"); }
Ref: 
def canBeReduced ( x , y ) : NEW_LINE INDENT maxi = max ( x , y ) NEW_LINE mini = min ( x , y ) NEW_LINE if ( ( ( x + y ) % 3 ) == 0 and maxi <= 2 * mini ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
Hyp: 
def canBeReduced ( x , y ) : NEW_LINE INDENT maxi = max ( x , y ) NEW_LINE mini = min ( x , y ) NEW_LINE if ( ( ( x + y ) % 3 ) == 0 and maxi <= 2 * mini ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
float slope ( float x1 , float y1 , float x2 , float y2 ) { if ( x1 == x2 ) return Integer . MAX_VALUE ; return ( y2 - y1 ) / ( x2 - x1 ) ; }
Ref: 
def slope ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT if x1 == x2 : NEW_LINE INDENT return ( sys . maxsize ) NEW_LINE DEDENT return ( ( y2 - y1 ) / ( x2 - x1 ) ) NEW_LINE DEDENT
Hyp: 
def slope ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT if ( x1 == x2 ) : NEW_LINE INDENT return sys . maxsize NEW_LINE DEDENT return ( y2 - y1 ) / ( x2 - x1 ) NEW_LINE DEDENT

BLEU: 73.15
Edit Sim: 12


Src: 
boolean arePermutation ( String str1 , String str2 ) { int n1 = str1 . length ( ) ; int n2 = str2 . length ( ) ; if ( n1 != n2 ) return false ; char ch1 [ ] = str1 . toCharArray ( ) ; char ch2 [ ] = str2 . toCharArray ( ) ; Arrays . sort ( ch1 ) ; Arrays . sort ( ch2 ) ; for ( int i = 0 ; i < n1 ; i ++ ) if ( ch1 [ i ] != ch2 [ i ] ) return false ; return true ; }
Ref: 
def arePermutation ( str1 , str2 ) : NEW_LINE INDENT n1 = len ( str1 ) NEW_LINE n2 = len ( str2 ) NEW_LINE if ( n1 != n2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT a = sorted ( str1 ) NEW_LINE str1 = " ▁ " . join ( a ) NEW_LINE b = sorted ( str2 ) NEW_LINE str2 = " ▁ " . join ( b ) NEW_LINE for i in range ( 0 , n1 , 1 ) : NEW_LINE INDENT if ( str1 [ i ] != str2 [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
Hyp: 
def arePermutation ( str1 , str2 ) : NEW_LINE INDENT n1 = len ( str1 ) NEW_LINE n2 = len ( str2 ) NEW_LINE if ( n1 != n2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT ch1 = list ( str1 ) NEW_LINE ch2 = list ( str2 ) NEW_LINE for i in range ( n1 ) : NEW_LINE INDENT if ( ch1 [ i ] != ch2 [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT

BLEU: 59.29
Edit Sim: 96


Src: 
int maxlength ( String s ) { int n = s . length ( ) , i , j ; int ans = 0 ; for ( i = 0 ; i <= n - 1 ; i ++ ) { if ( s . charAt ( i ) == '1' ) { int count = 1 ; for ( j = i + 1 ; j <= n - 1 && s . charAt ( j ) == '1' ; j ++ ) count ++ ; ans = Math . max ( ans , count ) ; } } return ans ; }
Ref: 
def maxlength ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE ans = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT count = 1 NEW_LINE j = i + 1 NEW_LINE while ( j <= n - 1 and s [ j ] == '1' ) : NEW_LINE INDENT count += 1 NEW_LINE j += 1 NEW_LINE DEDENT ans = max ( ans , count ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
Hyp: 
def maxlength ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE ans = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT count = 1 NEW_LINE for j in range ( i + 1 , n - 1 and s [ j ] == '1' ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT ans = max ( count , ans ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT

BLEU: 76.92
Edit Sim: 53


Src: 
int Solution ( int [ ] A ) { int ans = 2 ; int n = A . length ; if ( n <= 2 ) return n ; int [ ] llap = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) llap [ i ] = 2 ; Arrays . sort ( A ) ; for ( int j = n - 2 ; j >= 0 ; j -- ) { int i = j - 1 ; int k = j + 1 ; while ( i >= 0 && k < n ) { if ( A [ i ] + A [ k ] == 2 * A [ j ] ) { llap [ j ] = Math . max ( llap [ k ] + 1 , llap [ j ] ) ; ans = Math . max ( ans , llap [ j ] ) ; i -= 1 ; k += 1 ; } else if ( A [ i ] + A [ k ] < 2 * A [ j ] ) k += 1 ; else i -= 1 ; } } return ans ; }
Ref: 
def Solve ( self , A ) : NEW_LINE INDENT ans = 2 NEW_LINE n = len ( A ) NEW_LINE if n <= 2 : NEW_LINE INDENT return n NEW_LINE DEDENT llap = [ 2 ] * n NEW_LINE A . sort ( ) NEW_LINE for j in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT i = j - 1 NEW_LINE k = j + 1 NEW_LINE while ( i >= 0 and k < n ) : NEW_LINE INDENT if A [ i ] + A [ k ] == 2 * A [ j ] : NEW_LINE INDENT llap [ j ] = max ( llap [ k ] + 1 , llap [ j ] ) NEW_LINE ans = max ( ans , llap [ j ] ) NEW_LINE i -= 1 NEW_LINE k += 1 NEW_LINE DEDENT elif A [ i ] + A [ k ] < 2 * A [ j ] : NEW_LINE INDENT k += 1 NEW_LINE DEDENT else : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
Hyp: 
def Solution ( A ) : NEW_LINE INDENT ans = 2 ; NEW_LINE n = len ( A ) NEW_LINE llap = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT llap [ i ] = 2 NEW_LINE DEDENT A . sort ( ) NEW_LINE j = n - 2 NEW_LINE while ( j >= 0 and k < n ) : NEW_LINE INDENT if ( A [ i ] + A [ k ] == 2 * A [ j ] ) : NEW_LINE INDENT llap [ j ] = max ( llap [ k ] + 1 , llap [ j ] ) NEW_LINE ans = max ( ans , llap [ j ] ) NEW_LINE i -= 1 NEW_LINE k += 1 NEW_LINE DEDENT elif ( A [ i ] + A [ k ] < 2 * A [ j ] ) : NEW_LINE INDENT k += 1 NEW_LINE DEDENT else : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT

BLEU: 71.46
Edit Sim: 139


Src: 
int getPairsCount ( int a [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( ( a [ i ] * a [ j ] ) == Math . abs ( i - j ) ) count ++ ; } } return count ; }
Ref: 
def getPairsCount ( a , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( ( a [ i ] * a [ j ] ) == abs ( i - j ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
Hyp: 
def getPairsCount ( a , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( ( a [ i ] * a [ j ] ) == abs ( i - j ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int countChar ( String str ) { int n = str . length ( ) ; if ( n <= 2 ) return n ; int count = 2 ; for ( int i = 1 ; i < n - 1 ; i ++ ) if ( str . charAt ( i - 1 ) == str . charAt ( i + 1 ) ) count ++ ; return count ; }
Ref: 
def countChar ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE if ( n <= 2 ) : NEW_LINE INDENT return n NEW_LINE DEDENT count = 2 NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if ( str [ i - 1 ] == str [ i + 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
Hyp: 
def countChar ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE if ( n <= 2 ) : NEW_LINE INDENT return n NEW_LINE DEDENT count = 2 NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if ( str [ i - 1 ] == str [ i + 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int findK ( int A [ ] [ ] , int i , int j , int n , int m , int k ) { if ( n < 1 m < 1 ) return - 1 ; if ( k <= m ) return A [ i + 0 ] [ j + k - 1 ] ; if ( k <= ( m + n - 1 ) ) return A [ i + ( k - m ) ] [ j + m - 1 ] ; if ( k <= ( m + n - 1 + m - 1 ) ) return A [ i + n - 1 ] [ j + m - 1 - ( k - ( m + n - 1 ) ) ] ; if ( k <= ( m + n - 1 + m - 1 + n - 2 ) ) return A [ i + n - 1 - ( k - ( m + n - 1 + m - 1 ) ) ] [ j + 0 ] ; return findK ( A , i + 1 , j + 1 , n - 2 , m - 2 , k - ( 2 * n + 2 * m - 4 ) ) ; }
Ref: 
def findK ( A , n , m , k ) : NEW_LINE INDENT if ( n < 1 or m < 1 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( k <= m ) : NEW_LINE INDENT return A [ 0 ] [ k - 1 ] NEW_LINE DEDENT if ( k <= ( m + n - 1 ) ) : NEW_LINE INDENT return A [ ( k - m ) ] [ m - 1 ] NEW_LINE DEDENT if ( k <= ( m + n - 1 + m - 1 ) ) : NEW_LINE INDENT return A [ n - 1 ] [ m - 1 - ( k - ( m + n - 1 ) ) ] NEW_LINE DEDENT if ( k <= ( m + n - 1 + m - 1 + n - 2 ) ) : NEW_LINE INDENT return A [ n - 1 - ( k - ( m + n - 1 + m - 1 ) ) ] [ 0 ] NEW_LINE DEDENT A . pop ( 0 ) NEW_LINE [ j . pop ( 0 ) for j in A ] NEW_LINE return findK ( A , n - 2 , m - 2 , k - ( 2 * n + 2 * m - 4 ) ) NEW_LINE DEDENT
Hyp: 
def findK ( A , i , j , n , m , k ) : NEW_LINE INDENT if ( n < 1 or m < 1 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( k <= m ) : NEW_LINE INDENT return A [ i + 0 ] [ j + k - 1 ] NEW_LINE DEDENT if ( k <= ( m + n - 1 ) ) : NEW_LINE INDENT return A [ i + ( k - m ) ] [ j + m - 1 ] NEW_LINE DEDENT if ( k <= ( m + n - 1 + m - 1 ) ) : NEW_LINE INDENT return A [ i + n - 1 ] [ j + m - 1 - ( k - ( m + n - 1 ) ) ] NEW_LINE DEDENT if ( k <= ( m + n - 1 + m - 1 + n - 2 ) ) : NEW_LINE INDENT return A [ i + n - 1 - ( k - ( m + n - 1 + m - 1 ) ) ] [ j + 0 ] NEW_LINE DEDENT return findK ( A , i + 1 , j + 1 , n - 2 , m - 2 , k - ( 2 * n + 2 * m - 4 ) ) NEW_LINE DEDENT

BLEU: 81.94
Edit Sim: 104


Src: 
void predictTheWinner ( int K , int N ) { if ( N % ( K + 1 ) == 0 ) System . out . println ( " Bob " ) ; else System . out . println ( " Alice " ) ; }
Ref: 
def predictTheWinner ( K , N ) : NEW_LINE INDENT if ( N % ( K + 1 ) == 0 ) : NEW_LINE INDENT print ( " Bob " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Alice " ) NEW_LINE DEDENT DEDENT
Hyp: 
def predictTheWinner ( K , N ) : NEW_LINE INDENT if ( N % ( K + 1 ) == 0 ) : NEW_LINE INDENT print ( " Bob " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Alice " ) NEW_LINE DEDENT DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int countDigits ( int a , int b ) { int count = 0 ; int p = Math . abs ( a / b ) ; if ( p == 0 ) return 1 ; while ( p > 0 ) { count ++ ; p = p / 10 ; } return count ; }
Ref: 
def countDigits ( a , b ) : NEW_LINE INDENT count = 0 NEW_LINE p = abs ( a // b ) NEW_LINE if ( p == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT while ( p > 0 ) : NEW_LINE INDENT count = count + 1 NEW_LINE p = p // 10 NEW_LINE DEDENT return count NEW_LINE DEDENT
Hyp: 
def countDigits ( a , b ) : NEW_LINE INDENT count = 0 NEW_LINE p = abs ( a / b ) NEW_LINE if ( p == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT while ( p > 0 ) : NEW_LINE INDENT count = count + 1 NEW_LINE p = p // 10 NEW_LINE DEDENT return count NEW_LINE DEDENT

BLEU: 95.88
Edit Sim: 1


Src: 
int countSubStrings ( String s , int n ) { int count = 0 , sum = 0 ; HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; mp . put ( 0 , 1 ) ; for ( int i = 0 ; i < n ; ++ i ) { sum += ( s . charAt ( i ) - '0' ) ; count += mp . containsKey ( sum - ( i + 1 ) ) == true ? mp . get ( sum - ( i + 1 ) ) : 0 ; if ( ! mp . containsKey ( sum - ( i + 1 ) ) ) mp . put ( sum - ( i + 1 ) , 1 ) ; else mp . put ( sum - ( i + 1 ) , mp . get ( sum - ( i + 1 ) ) + 1 ) ; } return count ; }
Ref: 
def countSubstrings ( s , n ) : NEW_LINE INDENT count , sum = 0 , 0 NEW_LINE mp = defaultdict ( lambda : 0 ) NEW_LINE mp [ 0 ] += 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += ord ( s [ i ] ) - ord ( '0' ) NEW_LINE count += mp [ sum - ( i + 1 ) ] NEW_LINE mp [ sum - ( i + 1 ) ] += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
Hyp: 
def countSubStrings ( s , n ) : NEW_LINE INDENT count = 0 NEW_LINE sum = 0 NEW_LINE mp = { } NEW_LINE mp [ 0 ] += 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += ( ord ( s [ i ] ) - ord ( '0' ) ) NEW_LINE count += mp [ sum - ( i + 1 ) ] NEW_LINE DEDENT return count NEW_LINE DEDENT

BLEU: 65.28
Edit Sim: 76


Src: 
int minToggle ( int arr [ ] , int n ) { int zero [ ] = new int [ n + 1 ] ; zero [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { if ( arr [ i - 1 ] == 0 ) zero [ i ] = zero [ i - 1 ] + 1 ; else zero [ i ] = zero [ i - 1 ] ; } int ans = n ; for ( int i = 1 ; i <= n ; ++ i ) ans = Math . min ( ans , i - zero [ i ] + zero [ n ] - zero [ i ] ) ; return ans ; }
Ref: 
def minToggle ( arr , n ) : NEW_LINE INDENT zero = [ 0 for i in range ( n + 1 + 1 ) ] NEW_LINE zero [ 0 ] = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( arr [ i - 1 ] == 0 ) : NEW_LINE INDENT zero [ i ] = zero [ i - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT zero [ i ] = zero [ i - 1 ] NEW_LINE DEDENT DEDENT ans = n NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans = min ( ans , i - zero [ i ] + zero [ n ] - zero [ i ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
Hyp: 
def minToggle ( arr , n ) : NEW_LINE INDENT zero = [ 0 ] * ( n + 1 ) NEW_LINE zero [ 0 ] = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( arr [ i - 1 ] == 0 ) : NEW_LINE INDENT zero [ i ] = zero [ i - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT zero [ i ] = zero [ i - 1 ] NEW_LINE DEDENT DEDENT ans = n ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans = min ( ans , i - zero [ i ] + zero [ n ] - zero [ i ] ) ; NEW_LINE DEDENT return ans NEW_LINE DEDENT

BLEU: 90.87
Edit Sim: 23


Src: 
long findDigits ( int n , int b ) { if ( n < 0 ) return 0 ; if ( n <= 1 ) return 1 ; double M_PI = 3.141592 ; double M_E = 2.7182 ; double x = ( ( n * Math . log10 ( n / M_E ) + Math . log10 ( 2 * M_PI * n ) / 2.0 ) ) / ( Math . log10 ( b ) ) ; return ( long ) ( Math . floor ( x ) + 1 ) ; }
Ref: 
def findDigits ( n , b ) : NEW_LINE INDENT if ( n < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT M_PI = 3.141592 NEW_LINE M_E = 2.7182 NEW_LINE if ( n <= 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT x = ( ( n * log10 ( n / M_E ) + log10 ( 2 * M_PI * n ) / 2.0 ) ) / ( log10 ( b ) ) NEW_LINE return floor ( x ) + 1 NEW_LINE DEDENT
Hyp: 
def findDigits ( n , b ) : NEW_LINE INDENT if ( n < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n <= 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT M_PI = 3.141592 NEW_LINE M_E = 2.7182 NEW_LINE x = ( ( n * log10 ( n / M_E ) + log10 ( 2 * M_PI * n ) / 2.0 ) ) / ( log10 ( b ) ) NEW_LINE return math . floor ( x ) + 1 ) NEW_LINE DEDENT

BLEU: 89.61
Edit Sim: 73


Src: 
String unique ( String s ) { String str = new String ( ) ; int len = s . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { char c = s . charAt ( i ) ; if ( str . indexOf ( c ) < 0 ) { str += c ; } } return str ; }
Ref: 
def unique ( s ) : NEW_LINE INDENT st = " " NEW_LINE length = len ( s ) NEW_LINE for i in range ( length ) : NEW_LINE INDENT c = s [ i ] NEW_LINE if c not in st : NEW_LINE INDENT st += c NEW_LINE DEDENT DEDENT return st NEW_LINE DEDENT
Hyp: 
def unique ( s ) : NEW_LINE INDENT str = list ( s ) NEW_LINE len1 = len ( s ) NEW_LINE for i in range ( 0 , len1 ) : NEW_LINE INDENT c = s [ i ] NEW_LINE if c not in str : NEW_LINE INDENT str += c NEW_LINE DEDENT DEDENT return str NEW_LINE DEDENT

BLEU: 63.42
Edit Sim: 23


Src: 
void interchangeFirstLast ( int m [ ] [ ] ) { int rows = m . length ; for ( int i = 0 ; i < m [ 0 ] . length ; i ++ ) { int t = m [ 0 ] [ i ] ; m [ 0 ] [ i ] = m [ rows - 1 ] [ i ] ; m [ rows - 1 ] [ i ] = t ; } }
Ref: 
def interchangeFirstLast ( mat , n , m ) : NEW_LINE INDENT rows = n NEW_LINE for i in range ( n ) : NEW_LINE INDENT t = mat [ 0 ] [ i ] NEW_LINE mat [ 0 ] [ i ] = mat [ rows - 1 ] [ i ] NEW_LINE mat [ rows - 1 ] [ i ] = t NEW_LINE DEDENT DEDENT mat = [ [ 8 , 9 , 7 , 6 ] , [ 4 , 7 , 6 , 5 ] , [ 3 , 2 , 1 , 8 ] , [ 9 , 9 , 7 , 7 ] ] NEW_LINE n = 4 NEW_LINE m = 4 NEW_LINE interchangeFirstLast ( mat , n , m ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = " ▁ " ) NEW_LINE DEDENT print ( " " ) NEW_LINE DEDENT
Hyp: 
def interchangeFirstLast ( m , row ) : NEW_LINE INDENT rows = len ( m ) NEW_LINE for i in range ( row ) : NEW_LINE INDENT t = m [ 0 ] [ i ] NEW_LINE m [ 0 ] [ i ] = m [ rows - 1 ] [ i ] NEW_LINE m [ rows - 1 ] [ i ] = t NEW_LINE DEDENT DEDENT

BLEU: 15.57
Edit Sim: 363


Src: 
int evenbittogglenumber ( int n ) { int res = 0 , count = 0 ; for ( int temp = n ; temp > 0 ; temp >>= 1 ) { if ( count % 2 == 0 ) res |= ( 1 << count ) ; count ++ ; } return n ^ res ; }
Ref: 
def evenbittogglenumber ( n ) : NEW_LINE INDENT res = 0 ; count = 0 ; temp = n NEW_LINE while ( temp > 0 ) : NEW_LINE INDENT if ( count % 2 == 0 ) : NEW_LINE INDENT res = res | ( 1 << count ) NEW_LINE DEDENT count = count + 1 NEW_LINE temp >>= 1 NEW_LINE DEDENT return n ^ res NEW_LINE DEDENT
Hyp: 
def evenbittogglenumber ( n ) : NEW_LINE INDENT res = 0 NEW_LINE count = 0 NEW_LINE temp = n NEW_LINE while ( temp > 0 ) : NEW_LINE INDENT if ( count % 2 == 0 ) : NEW_LINE INDENT res |= ( 1 << count ) NEW_LINE DEDENT count += 1 NEW_LINE temp >>= 1 NEW_LINE DEDENT return n ^ res NEW_LINE DEDENT

BLEU: 78.72
Edit Sim: 32


Src: 
void maxRegions ( int n ) { int num ; num = n * ( n + 1 ) / 2 + 1 ; System . out . println ( num ) ; ; }
Ref: 
def maxRegions ( n ) : NEW_LINE INDENT num = n * ( n + 1 ) // 2 + 1 NEW_LINE print ( num ) NEW_LINE DEDENT
Hyp: 
def maxRegions ( n ) : NEW_LINE INDENT num = n * ( n + 1 ) / 2 + 1 NEW_LINE print ( num ) NEW_LINE DEDENT

BLEU: 90.62
Edit Sim: 1


Src: 
int maxSubStrings ( String s , int k ) { int maxSubStr = 0 , n = s . length ( ) ; for ( int c = 0 ; c < 26 ; c ++ ) { char ch = ( char ) ( ( int ) ' a ' + c ) ; int curr = 0 ; for ( int i = 0 ; i <= n - k ; i ++ ) { if ( s . charAt ( i ) != ch ) continue ; int cnt = 0 ; while ( i < n && s . charAt ( i ) == ch && cnt != k ) { i ++ ; cnt ++ ; } i -- ; if ( cnt == k ) curr ++ ; } maxSubStr = Math . max ( maxSubStr , curr ) ; } return maxSubStr ; }
Ref: 
def maxSubStrings ( s , k ) : NEW_LINE INDENT maxSubStr = 0 NEW_LINE n = len ( s ) NEW_LINE for c in range ( 27 ) : NEW_LINE INDENT ch = chr ( ord ( ' a ' ) + c ) NEW_LINE curr = 0 NEW_LINE for i in range ( n - k ) : NEW_LINE INDENT if ( s [ i ] != ch ) : NEW_LINE INDENT continue NEW_LINE DEDENT cnt = 0 NEW_LINE while ( i < n and s [ i ] == ch and cnt != k ) : NEW_LINE INDENT i += 1 NEW_LINE cnt += 1 NEW_LINE DEDENT i -= 1 NEW_LINE if ( cnt == k ) : NEW_LINE INDENT curr += 1 NEW_LINE DEDENT DEDENT maxSubStr = max ( maxSubStr , curr ) NEW_LINE DEDENT return maxSubStr NEW_LINE DEDENT
Hyp: 
def maxSubStrings ( s , k ) : NEW_LINE INDENT maxSubStr = 0 ; n = len ( s ) NEW_LINE for c in range ( 26 ) : NEW_LINE INDENT ch = chr ( ord ( ' a ' + c ) ) NEW_LINE curr = 0 NEW_LINE for i in range ( n - k + 1 ) : NEW_LINE INDENT if ( s [ i ] != ch ) : NEW_LINE INDENT continue NEW_LINE DEDENT cnt = 0 NEW_LINE while ( i < n and s [ i ] == ch and cnt != k ) : NEW_LINE INDENT i += 1 NEW_LINE cnt += 1 NEW_LINE DEDENT i -= 1 NEW_LINE if ( cnt == k ) : NEW_LINE INDENT curr += 1 NEW_LINE DEDENT DEDENT maxSubStr = max ( maxSubStr , curr ) NEW_LINE DEDENT return maxSubStr NEW_LINE DEDENT

BLEU: 91.87
Edit Sim: 16


Src: 
int findMaximumScore ( int [ ] a , int n ) { @ SuppressWarnings ( " unchecked " ) HashMap < Integer , Integer > freq = new HashMap ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( freq . containsKey ( a [ i ] ) ) { freq . put ( a [ i ] , freq . get ( a [ i ] ) + 1 ) ; } else { freq . put ( a [ i ] , 1 ) ; } } int [ ] dp = new int [ Arrays . stream ( a ) . max ( ) . getAsInt ( ) + 1 ] ; dp [ 0 ] = 0 ; dp [ 1 ] = freq . get ( 1 ) ; for ( int i = 2 ; i < dp . length ; i ++ ) dp [ i ] = Math . max ( dp [ i - 1 ] , dp [ i - 2 ] + freq . get ( i ) * i ) ; return dp [ dp . length - 1 ] ; }
Ref: 
def findMaximumScore ( a , n ) : NEW_LINE INDENT freq = defaultdict ( int ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ a [ i ] ] += 1 NEW_LINE DEDENT dp = [ 0 ] * ( max ( a ) + 1 ) NEW_LINE dp [ 0 ] = 0 NEW_LINE dp [ 1 ] = freq [ 1 ] NEW_LINE for i in range ( 2 , len ( dp ) ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i - 1 ] , dp [ i - 2 ] + freq [ i ] * i ) NEW_LINE DEDENT return dp [ - 1 ] NEW_LINE DEDENT
Hyp: 
def findMaximumScore ( a , n ) : NEW_LINE INDENT freq = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] in freq : NEW_LINE INDENT freq [ a [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT freq [ a [ i ] ] = 1 NEW_LINE DEDENT DEDENT dp = [ 0 ] * ( len ( a ) + 1 ) NEW_LINE dp [ 1 ] = freq [ 1 ] NEW_LINE for i in range ( 2 , len ( dp ) ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i - 1 ] , dp [ i - 2 ] + freq [ i ] * i ) NEW_LINE DEDENT return dp [ len ( dp ) - 1 ] NEW_LINE DEDENT

BLEU: 74.55
Edit Sim: 124


Src: 
int numberOfPaths ( int m , int n ) { int count [ ] [ ] = new int [ m ] [ n ] ; for ( int i = 0 ; i < m ; i ++ ) count [ i ] [ 0 ] = 1 ; for ( int j = 0 ; j < n ; j ++ ) count [ 0 ] [ j ] = 1 ; for ( int i = 1 ; i < m ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) count [ i ] [ j ] = count [ i - 1 ] [ j ] + count [ i ] [ j - 1 ] ; + count [ i - 1 ] [ j - 1 ] ; } return count [ m - 1 ] [ n - 1 ] ; }
Ref: 
def numberOfPaths ( m , n ) : NEW_LINE INDENT count = [ [ 0 for x in range ( n ) ] for y in range ( m ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT count [ i ] [ 0 ] = 1 ; NEW_LINE DEDENT for j in range ( n ) : NEW_LINE INDENT count [ 0 ] [ j ] = 1 ; NEW_LINE DEDENT for i in range ( 1 , m ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT count [ i ] [ j ] = count [ i - 1 ] [ j ] + count [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT return count [ m - 1 ] [ n - 1 ] NEW_LINE DEDENT
Hyp: 
def numberOfPaths ( m , n ) : NEW_LINE INDENT count = [ [ 0 for i in range ( n ) ] for i in range ( m ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT count [ i ] [ 0 ] = 1 NEW_LINE DEDENT for j in range ( n ) : NEW_LINE INDENT count [ 0 ] [ j ] = 1 NEW_LINE DEDENT for i in range ( 1 , m ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT count [ i ] [ j ] = ( count [ i - 1 ] [ j ] + count [ i ] [ j - 1 ] ) NEW_LINE DEDENT + count [ i - 1 ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT return count [ m - 1 ] [ n - 1 ] NEW_LINE DEDENT

BLEU: 82.19
Edit Sim: 56


Src: 
int findMinDiff ( int [ ] arr , int n ) { Arrays . sort ( arr ) ; int diff = Integer . MAX_VALUE ; for ( int i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i + 1 ] - arr [ i ] < diff ) diff = arr [ i + 1 ] - arr [ i ] ; return diff ; }
Ref: 
def findMinDiff ( arr , n ) : NEW_LINE INDENT arr = sorted ( arr ) NEW_LINE diff = 10 ** 20 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if arr [ i + 1 ] - arr [ i ] < diff : NEW_LINE INDENT diff = arr [ i + 1 ] - arr [ i ] NEW_LINE DEDENT DEDENT return diff NEW_LINE DEDENT
Hyp: 
def findMinDiff ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE diff = 10 ** 20 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( arr [ i + 1 ] - arr [ i ] < diff ) : NEW_LINE INDENT diff = arr [ i + 1 ] - arr [ i ] NEW_LINE DEDENT DEDENT return diff NEW_LINE DEDENT

BLEU: 87.33
Edit Sim: 11


Src: 
boolean checkFibinnary ( int n ) { int prev_last = 0 ; while ( n != 0 ) { if ( ( n & 1 ) != 0 && prev_last != 0 ) return false ; prev_last = n & 1 ; n >>= 1 ; } return true ; }
Ref: 
def checkFibinnary ( n ) : NEW_LINE INDENT prev_last = 0 NEW_LINE while ( n ) : NEW_LINE INDENT if ( ( n & 1 ) and prev_last ) : NEW_LINE INDENT return False NEW_LINE DEDENT prev_last = n & 1 NEW_LINE n >>= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT n = 10 NEW_LINE if ( checkFibinnary ( n ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
Hyp: 
def checkFibinnary ( n ) : NEW_LINE INDENT prev_last = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT if ( n & 1 ) != 0 and prev_last != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT prev_last = n & 1 NEW_LINE n >>= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT n = 18 NEW_LINE if checkFibinnary ( n ) : NEW_LINE INDENT print ( N , end = ' ▁ ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( N , end = ' ▁ ' ) NEW_LINE print ( N , end = ' ▁ ' ) NEW_LINE DEDENT

BLEU: 59.64
Edit Sim: 82


Src: 
boolean checkPointRange ( int arr [ ] [ ] , int X , int Y , int N ) { for ( int i = 0 ; i < N ; i ++ ) { double dist = Math . sqrt ( ( arr [ i ] [ 0 ] - X ) * ( arr [ i ] [ 0 ] - X ) + ( arr [ i ] [ 1 ] - Y ) * ( arr [ i ] [ 1 ] - Y ) ) ; if ( dist <= arr [ i ] [ 2 ] ) { return true ; } } return false ; }
Ref: 
def checkPointRange ( arr , X , Y , N ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT dist = sqrt ( ( arr [ i ] [ 0 ] - X ) * ( arr [ i ] [ 0 ] - X ) + ( arr [ i ] [ 1 ] - Y ) * ( arr [ i ] [ 1 ] - Y ) ) NEW_LINE if ( dist <= arr [ i ] [ 2 ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
Hyp: 
def checkPointRange ( arr , X , Y , N ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT dist = ( math . sqrt ( ( arr [ i ] [ 0 ] - X ) * ( arr [ i ] [ 0 ] - X ) + ( arr [ i ] [ 1 ] - Y ) * ( arr [ i ] [ 1 ] - Y ) ) NEW_LINE if ( dist <= arr [ i ] [ 2 ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT

BLEU: 95.63
Edit Sim: 9


Src: 
int minCost ( int A [ ] , int n ) { int cost = 0 ; Arrays . sort ( A ) ; int K = A [ n / 2 ] ; for ( int i = 0 ; i < n ; ++ i ) cost += Math . abs ( A [ i ] - K ) ; if ( n % 2 == 0 ) { int tempCost = 0 ; K = A [ ( n / 2 ) - 1 ] ; for ( int i = 0 ; i < n ; ++ i ) tempCost += Math . abs ( A [ i ] - K ) ; cost = Math . min ( cost , tempCost ) ; } return cost ; }
Ref: 
def minCost ( A , n ) : NEW_LINE INDENT cost = 0 NEW_LINE A . sort ( ) ; NEW_LINE K = A [ int ( n / 2 ) ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT cost = cost + abs ( A [ i ] - K ) NEW_LINE DEDENT if n % 2 == 0 : NEW_LINE INDENT tempCost = 0 NEW_LINE K = A [ int ( n / 2 ) - 1 ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT tempCost = tempCost + abs ( A [ i ] - K ) NEW_LINE DEDENT cost = min ( cost , tempCost ) NEW_LINE DEDENT return cost NEW_LINE DEDENT
Hyp: 
def minCost ( A , n ) : NEW_LINE INDENT cost = 0 NEW_LINE A . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT cost += abs ( A [ i ] - K ) NEW_LINE DEDENT if ( n % 2 == 0 ) : NEW_LINE INDENT tempCost = 0 NEW_LINE K = A [ ( n // 2 ) - 1 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT tempCost += abs ( A [ i ] - K ) NEW_LINE DEDENT cost = min ( cost , tempCost ) NEW_LINE DEDENT return cost NEW_LINE DEDENT

BLEU: 68.99
Edit Sim: 72


Src: 
int maxPrefix ( String s , String t ) { int count = 0 ; for ( int i = 0 ; i < t . length ( ) ; i ++ ) { if ( count == s . length ( ) ) break ; if ( t . charAt ( i ) == s . charAt ( count ) ) count ++ ; } return count ; }
Ref: 
def maxPrefix ( s , t ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , len ( t ) ) : NEW_LINE INDENT if ( count == len ( s ) ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( t [ i ] == s [ count ] ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
Hyp: 
def maxPrefix ( s , t ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( t ) ) : NEW_LINE INDENT if ( count == len ( s ) ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( t [ i ] == s [ count ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT

BLEU: 88.42
Edit Sim: 13


Src: 
int largestCoprime ( int N ) { if ( N == 6 ) return 1 ; else if ( N % 4 == 0 ) return ( N / 2 ) - 1 ; else if ( N % 2 == 0 ) return ( N / 2 ) - 2 ; else return ( ( N - 1 ) / 2 ) ; }
Ref: 
def largestCoprime ( N ) : NEW_LINE INDENT if N == 6 : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif N % 4 == 0 : NEW_LINE INDENT return N // 2 - 1 NEW_LINE DEDENT elif N % 2 == 0 : NEW_LINE INDENT return N // 2 - 2 NEW_LINE DEDENT else : NEW_LINE INDENT return ( N - 1 ) // 2 NEW_LINE DEDENT DEDENT
Hyp: 
def largestCoprime ( N ) : NEW_LINE INDENT if ( N == 6 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( N % 4 == 0 ) : NEW_LINE INDENT return ( N / 2 ) - 1 NEW_LINE DEDENT elif ( N % 2 == 0 ) : NEW_LINE INDENT return ( N / 2 ) - 2 NEW_LINE DEDENT else : NEW_LINE INDENT return ( ( N - 1 ) / 2 ) NEW_LINE DEDENT DEDENT

BLEU: 56.75
Edit Sim: 27


Src: 
void CountPair ( int L , int R ) { int x = ( R - L + 1 ) ; System . out . println ( x / 2 + "NEW_LINE"); }
Ref: 
def CountPair ( L , R ) : NEW_LINE INDENT x = ( R - L + 1 ) NEW_LINE print ( x // 2 ) NEW_LINE DEDENT
Hyp: 
def CountPair ( L , R ) : NEW_LINE INDENT x = ( R - L + 1 ) NEW_LINE print ( int ( x / 2 ) ) NEW_LINE DEDENT

BLEU: 78.05
Edit Sim: 9


Src: 
int geometricMean ( int n ) { return ( int ) Math . sqrt ( n ) ; }
Ref: 
def geometricMean ( n ) : NEW_LINE INDENT return int ( sqrt ( n ) ) ; NEW_LINE DEDENT
Hyp: 
def geometricMean ( n ) : NEW_LINE INDENT return math . sqrt ( n ) ; NEW_LINE DEDENT

BLEU: 69.78
Edit Sim: 6


Src: 
void productPuzzle ( int a [ ] , int n ) { double sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += Math . log10 ( a [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( ( int ) ( EPS + Math . pow ( 10.00 , sum - Math . log10 ( a [ i ] ) ) ) + " ▁ " ) ; }
Ref: 
def productPuzzle ( a , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += math . log10 ( a [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print int ( ( EPS + pow ( 10.00 , sum - math . log10 ( a [ i ] ) ) ) ) , NEW_LINE DEDENT return NEW_LINE DEDENT
Hyp: 
def productPuzzle ( a , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += log10 ( a [ i ] ) NEW_LINE DEDENT print ( ( EPS + pow ( 10.00 , sum - log10 ( a [ i ] ) ) ) , end = " ▁ " ) NEW_LINE DEDENT

BLEU: 65.44
Edit Sim: 79


Src: 
int findCount ( int arr [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( ( arr [ i ] % 2 == 0 ) && ( arr [ j ] % 2 == 1 ) ) { res ++ ; } return res ; }
Ref: 
def findCount ( arr , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( ( arr [ i ] % 2 == 0 ) and ( arr [ j ] % 2 == 1 ) ) : NEW_LINE INDENT res = res + 1 NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT
Hyp: 
def findCount ( arr , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( ( arr [ i ] % 2 == 0 ) and ( arr [ j ] % 2 == 1 ) ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT

BLEU: 90.01
Edit Sim: 11


Src: 
int maxTripletSum ( int arr [ ] , int n ) { int sum = - 1000000 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) for ( int k = j + 1 ; k < n ; k ++ ) if ( sum < arr [ i ] + arr [ j ] + arr [ k ] ) sum = arr [ i ] + arr [ j ] + arr [ k ] ; return sum ; }
Ref: 
def maxTripletSum ( arr , n ) : NEW_LINE INDENT sm = - 1000000 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT if ( sm < ( arr [ i ] + arr [ j ] + arr [ k ] ) ) : NEW_LINE INDENT sm = arr [ i ] + arr [ j ] + arr [ k ] NEW_LINE DEDENT DEDENT DEDENT DEDENT return sm NEW_LINE DEDENT
Hyp: 
def maxTripletSum ( arr , n ) : NEW_LINE INDENT sum = - 1000000 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n , 1 ) : NEW_LINE INDENT for k in range ( j + 1 , n , 1 ) : NEW_LINE INDENT if ( sum < arr [ i ] + arr [ j ] + arr [ k ] ) : NEW_LINE INDENT sum = arr [ i ] + arr [ j ] + arr [ k ] NEW_LINE DEDENT DEDENT DEDENT return sum NEW_LINE DEDENT

BLEU: 82.13
Edit Sim: 23


Src: 
int mod ( int a , int m ) { return ( a % m + m ) % m ; }
Ref: 
def mod ( a , m ) : NEW_LINE INDENT return ( a % m + m ) % m NEW_LINE DEDENT
Hyp: 
def mod ( a , m ) : NEW_LINE INDENT return ( a % m + m ) % m NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int numberOfMinutes ( int S , int S1 ) { int Min = 0 ; Min = ( int ) ( ( ( S - S1 ) / Math . floor ( S ) ) * 60 ) ; return Min ; }
Ref: 
def numberOfMinutes ( S , S1 ) : NEW_LINE INDENT Min = 0 ; NEW_LINE Min = ( ( S - S1 ) / math . floor ( S ) ) * 60 ; NEW_LINE return int ( Min ) ; NEW_LINE DEDENT
Hyp: 
def numberOfMinutes ( S , S1 ) : NEW_LINE INDENT Min = 0 NEW_LINE Min = ( int ) ( ( ( S - S1 ) / math . floor ( S ) ) * 60 ) NEW_LINE return Min NEW_LINE DEDENT

BLEU: 73.43
Edit Sim: 23


Src: 
int findSum ( int N , int K ) { int ans = 0 ; int y = N / K ; int x = N % K ; ans = ( K * ( K - 1 ) / 2 ) * y + ( x * ( x + 1 ) ) / 2 ; return ans ; }
Ref: 
def findSum ( N , K ) : NEW_LINE INDENT ans = 0 ; NEW_LINE y = N / K ; NEW_LINE x = N % K ; NEW_LINE ans = ( ( K * ( K - 1 ) / 2 ) * y + ( x * ( x + 1 ) ) / 2 ) ; NEW_LINE return int ( ans ) ; NEW_LINE DEDENT
Hyp: 
def findSum ( N , K ) : NEW_LINE INDENT ans = 0 NEW_LINE y = N // K NEW_LINE x = N % K NEW_LINE ans = ( K * ( K - 1 ) // 2 ) * y + ( x * ( x + 1 ) ) // 2 NEW_LINE return ans NEW_LINE DEDENT

BLEU: 61.59
Edit Sim: 25


Src: 
int NumberOfRectangles ( int n , int m ) { if ( n % 2 == 0 ) return ( n / 2 ) * m ; else if ( m % 2 == 0 ) return ( m / 2 ) * n ; return ( n * m - 1 ) / 2 ; }
Ref: 
def NumberOfRectangles ( n , m ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT return ( n / 2 ) * m NEW_LINE DEDENT elif ( m % 2 == 0 ) : NEW_LINE INDENT return ( m // 2 ) * n NEW_LINE DEDENT return ( n * m - 1 ) // 2 NEW_LINE DEDENT
Hyp: 
def NumberOfRectangles ( n , m ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT return ( n / 2 ) * m NEW_LINE DEDENT elif ( m % 2 == 0 ) : NEW_LINE INDENT return ( m / 2 ) * n NEW_LINE DEDENT return ( n * m - 1 ) // 2 NEW_LINE DEDENT

BLEU: 96.01
Edit Sim: 1


Src: 
int minTotalDistance ( int grid [ ] [ ] ) { if ( ROW == 0 COL == 0 ) return 0 ; Vector < Integer > vertical = new Vector < Integer > ( ) ; Vector < Integer > horizontal = new Vector < Integer > ( ) ; for ( int i = 0 ; i < ROW ; i ++ ) { for ( int j = 0 ; j < COL ; j ++ ) { if ( grid [ i ] [ j ] == 1 ) { vertical . add ( i ) ; horizontal . add ( j ) ; } } } Collections . sort ( vertical ) ; Collections . sort ( horizontal ) ; int size = vertical . size ( ) / 2 ; int x = vertical . get ( size ) ; int y = horizontal . get ( size ) ; int distance = 0 ; for ( int i = 0 ; i < ROW ; i ++ ) for ( int j = 0 ; j < COL ; j ++ ) if ( grid [ i ] [ j ] == 1 ) distance += Math . abs ( x - i ) + Math . abs ( y - j ) ; return distance ; }
Ref: 
def minTotalDistance ( grid : list ) : NEW_LINE INDENT if ROW == 0 or COL == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT vertical = [ ] NEW_LINE horizontal = [ ] NEW_LINE for i in range ( ROW ) : NEW_LINE INDENT for j in range ( COL ) : NEW_LINE INDENT if grid [ i ] [ j ] == 1 : NEW_LINE INDENT vertical . append ( i ) NEW_LINE horizontal . append ( j ) NEW_LINE DEDENT DEDENT DEDENT vertical . sort ( ) NEW_LINE horizontal . sort ( ) NEW_LINE size = len ( vertical ) // 2 NEW_LINE x = vertical [ size ] NEW_LINE y = horizontal [ size ] NEW_LINE distance = 0 NEW_LINE for i in range ( ROW ) : NEW_LINE INDENT for j in range ( COL ) : NEW_LINE INDENT if grid [ i ] [ j ] == 1 : NEW_LINE INDENT distance += abs ( x - i ) + abs ( y - j ) NEW_LINE DEDENT DEDENT DEDENT return distance NEW_LINE DEDENT
Hyp: 
def minTotalDistance ( grid ) : NEW_LINE INDENT if ( ROW == 0 or COL == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT vertical = [ ] NEW_LINE horizontal = [ ] NEW_LINE for i in range ( ROW ) : NEW_LINE INDENT for j in range ( COL ) : NEW_LINE INDENT if ( grid [ i ] [ j ] == 1 ) : NEW_LINE INDENT vertical . append ( i ) NEW_LINE horizontal . append ( j ) NEW_LINE DEDENT DEDENT vertical . sort ( ) NEW_LINE horizontal = [ 0 for i in range ( len ( vertical ) ) ] NEW_LINE distance = 0 NEW_LINE for i in range ( ROW ) : NEW_LINE INDENT for j in range ( COL ) : NEW_LINE INDENT if ( grid [ i ] [ j ] == 1 ) : NEW_LINE INDENT distance += abs ( x - i ) + abs ( y - j ) NEW_LINE DEDENT DEDENT DEDENT return distance NEW_LINE DEDENT

BLEU: 78.53
Edit Sim: 112


Src: 
int toggleLastMBits ( int n , int m ) { int num = ( 1 << m ) - 1 ; return ( n ^ num ) ; }
Ref: 
def toggleLastMBits ( n , m ) : NEW_LINE INDENT num = ( 1 << m ) - 1 NEW_LINE return ( n ^ num ) NEW_LINE DEDENT
Hyp: 
def toggleLastMBits ( n , m ) : NEW_LINE INDENT num = ( 1 << m ) - 1 NEW_LINE return ( n ^ num ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int GetMinSubarrayLength ( int a [ ] , int n ) { int ans = Math . max ( a [ 0 ] , a [ n - 1 ] ) ; int lo = 0 , hi = n - 1 ; while ( lo < n && a [ lo ] % ans == 0 ) lo ++ ; while ( hi > lo && a [ hi ] % ans == 0 ) hi -- ; return ( hi - lo + 1 ) ; }
Ref: 
def GetMinSubarrayLength ( a , n ) : NEW_LINE INDENT ans = max ( a [ 0 ] , a [ n - 1 ] ) NEW_LINE lo = 0 NEW_LINE hi = n - 1 NEW_LINE while ( lo < n and a [ lo ] % ans == 0 ) : NEW_LINE INDENT lo += 1 NEW_LINE DEDENT while ( hi > lo and a [ hi ] % ans == 0 ) : NEW_LINE INDENT hi -= 1 NEW_LINE DEDENT return ( hi - lo + 1 ) NEW_LINE DEDENT
Hyp: 
def GetMinSubarrayLength ( a , n ) : NEW_LINE INDENT ans = max ( a [ 0 ] , a [ n - 1 ] ) NEW_LINE lo = 0 NEW_LINE hi = n - 1 NEW_LINE while ( lo < n and a [ lo ] % ans == 0 ) : NEW_LINE INDENT lo += 1 NEW_LINE DEDENT while ( hi > lo and a [ hi ] % ans == 0 ) : NEW_LINE INDENT hi -= 1 NEW_LINE DEDENT return ( hi - lo + 1 ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int sumOfDivisors ( int N ) { return N ; }
Ref: 
def sumOfDivisors ( N ) : NEW_LINE INDENT return N NEW_LINE DEDENT
Hyp: 
def sumOfDivisors ( N ) : NEW_LINE INDENT return N * NEW_LINE DEDENT

BLEU: 80.91
Edit Sim: 2


Src: 
int smallestMultiple ( int n ) { if ( n == 1 ) return 5 ; return ( int ) ( Math . pow ( 10 , n - 1 ) ) ; }
Ref: 
def smallestMultiple ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 5 NEW_LINE DEDENT return pow ( 10 , n - 1 ) NEW_LINE DEDENT
Hyp: 
def smallestMultiple ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 5 NEW_LINE DEDENT return pow ( 10 , n - 1 ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int series ( int n ) { return ( 8 * n * n ) + 1 ; }
Ref: 
def series ( n ) : NEW_LINE INDENT print ( ( 8 * n ** 2 ) + 1 ) NEW_LINE DEDENT
Hyp: 
def series ( n ) : NEW_LINE INDENT return ( 8 * n * n ) + 1 NEW_LINE DEDENT

BLEU: 53.56
Edit Sim: 10


Src: 
int calculate_minimum_split ( int n , int a [ ] , int k ) { Integer [ ] p = new Integer [ n - 1 ] ; for ( int i = 1 ; i < n ; i ++ ) p [ i - 1 ] = a [ i ] - a [ i - 1 ] ; Arrays . sort ( p , new Comparator < Integer > ( ) { public int compare ( Integer a , Integer b ) { return b - a ; } } ) ; int min_sum = 0 ; for ( int i = 0 ; i < k - 1 ; i ++ ) min_sum += p [ i ] ; int res = a [ n - 1 ] - a [ 0 ] - min_sum ; return res ; }
Ref: 
def calculate_minimum_split ( a , k ) : NEW_LINE INDENT p = [ ] NEW_LINE n = len ( a ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT p . append ( a [ i ] - a [ i - 1 ] ) NEW_LINE DEDENT p . sort ( reverse = True ) NEW_LINE min_sum = sum ( p [ : k - 1 ] ) NEW_LINE res = a [ n - 1 ] - a [ 0 ] - min_sum NEW_LINE return res NEW_LINE DEDENT
Hyp: 
def calculate_minimum_split ( n , a , k ) : NEW_LINE INDENT p = [ 0 ] * ( k - 1 ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT p [ i - 1 ] = a [ i ] - a [ i - 1 ] NEW_LINE DEDENT p . sort ( ) NEW_LINE min_sum = 0 NEW_LINE for i in range ( k - 1 ) : NEW_LINE INDENT min_sum += p [ i ] NEW_LINE DEDENT res = a [ n - 1 ] - a [ 0 ] - min_sum NEW_LINE return res NEW_LINE DEDENT

BLEU: 60.35
Edit Sim: 105


Src: 
String areBookingsPossible ( int [ ] A , int [ ] B , int K ) { Arrays . sort ( A ) ; Arrays . sort ( B ) ; for ( int i = 0 ; i < A . length ; i ++ ) { if ( i + K < A . length && A [ i + K ] < B [ i ] ) { return " No " ; } } return " Yes " ; }
Ref: 
def areBookingsPossible ( A , B , K ) : NEW_LINE INDENT A . sort ( ) NEW_LINE B . sort ( ) NEW_LINE for i in range ( len ( A ) ) : NEW_LINE INDENT if i + K < len ( A ) and A [ i + K ] < B [ i ] : NEW_LINE INDENT return " No " NEW_LINE DEDENT DEDENT return " Yes " NEW_LINE DEDENT
Hyp: 
def areBookingsPossible ( A , B , K ) : NEW_LINE INDENT A . sort ( ) NEW_LINE B . sort ( ) NEW_LINE for i in range ( len ( A ) ) : NEW_LINE INDENT if ( i + K < len ( A ) and A [ i + K ] < B [ i ] ) : NEW_LINE INDENT return " No " NEW_LINE DEDENT DEDENT return " Yes " NEW_LINE DEDENT

BLEU: 93.28
Edit Sim: 4


Src: 
int findMaxAverage ( int [ ] arr , int n , int k ) { if ( k > n ) return - 1 ; int [ ] csum = new int [ n ] ; csum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) csum [ i ] = csum [ i - 1 ] + arr [ i ] ; int max_sum = csum [ k - 1 ] , max_end = k - 1 ; for ( int i = k ; i < n ; i ++ ) { int curr_sum = csum [ i ] - csum [ i - k ] ; if ( curr_sum > max_sum ) { max_sum = curr_sum ; max_end = i ; } } return max_end - k + 1 ; }
Ref: 
def findMaxAverage ( arr , n , k ) : NEW_LINE INDENT if k > n : NEW_LINE INDENT return - 1 NEW_LINE DEDENT csum = [ 0 ] * n NEW_LINE csum [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT csum [ i ] = csum [ i - 1 ] + arr [ i ] ; NEW_LINE DEDENT max_sum = csum [ k - 1 ] NEW_LINE max_end = k - 1 NEW_LINE for i in range ( k , n ) : NEW_LINE INDENT curr_sum = csum [ i ] - csum [ i - k ] NEW_LINE if curr_sum > max_sum : NEW_LINE INDENT max_sum = curr_sum NEW_LINE max_end = i NEW_LINE DEDENT DEDENT return max_end - k + 1 NEW_LINE DEDENT
Hyp: 
def findMaxAverage ( arr , n , k ) : NEW_LINE INDENT if ( k > n ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT csum = [ 0 ] * k NEW_LINE csum [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT csum [ i ] = csum [ i - 1 ] + arr [ i ] NEW_LINE DEDENT max_sum = csum [ k - 1 ] NEW_LINE max_end = k - 1 NEW_LINE for i in range ( k , n ) : NEW_LINE INDENT curr_sum = ( csum [ i ] - csum [ i - k ] ) NEW_LINE if ( curr_sum > max_sum ) : NEW_LINE INDENT max_sum = curr_sum NEW_LINE max_end = i NEW_LINE DEDENT DEDENT return max_end - k + 1 NEW_LINE DEDENT

BLEU: 86.84
Edit Sim: 15


Src: 
void towerOfHanoi ( int n , char from_rod , char to_rod , char aux_rod ) { if ( n == 1 ) { System . out . println ( " Move ▁ disk ▁ 1 ▁ from ▁ rod ▁ " + from_rod + " ▁ to ▁ rod ▁ " + to_rod ) ; return ; } towerOfHanoi ( n - 1 , from_rod , aux_rod , to_rod ) ; System . out . println ( " Move ▁ disk ▁ " + n + " ▁ from ▁ rod ▁ " + from_rod + " ▁ to ▁ rod ▁ " + to_rod ) ; towerOfHanoi ( n - 1 , aux_rod , to_rod , from_rod ) ; }
Ref: 
def TowerOfHanoi ( n , from_rod , to_rod , aux_rod ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT print ( " Move ▁ disk ▁ 1 ▁ from ▁ rod " , from_rod , " to ▁ rod " , to_rod ) NEW_LINE return NEW_LINE DEDENT TowerOfHanoi ( n - 1 , from_rod , aux_rod , to_rod ) NEW_LINE print ( " Move ▁ disk " , n , " from ▁ rod " , from_rod , " to ▁ rod " , to_rod ) NEW_LINE TowerOfHanoi ( n - 1 , aux_rod , to_rod , from_rod ) NEW_LINE DEDENT
Hyp: 
def towerOfHanoi ( n , from_rod , to_rod , aux_rod ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT print ( " Move ▁ disk ▁ 1 ▁ from ▁ rod ▁ " , from_rod , " ▁ to ▁ rod ▁ " , to_rod ) NEW_LINE return NEW_LINE DEDENT towerOfHanoi ( n - 1 , from_rod , aux_rod ) NEW_LINE print ( " Move ▁ disk ▁ " , n , " ▁ from ▁ rod ▁ " , from_rod , " ▁ to ▁ rod ▁ " , to_rod ) NEW_LINE DEDENT

BLEU: 63.64
Edit Sim: 89


Src: 
int Remainder ( String str , int R ) { int len = str . length ( ) ; int Num , Rem = 0 ; for ( int i = 0 ; i < len ; i ++ ) { Num = Rem * 10 + ( str . charAt ( i ) - '0' ) ; Rem = Num % R ; } return Rem ; }
Ref: 
def Remainder ( str , R ) : NEW_LINE INDENT l = len ( str ) NEW_LINE Rem = 0 NEW_LINE for i in range ( l ) : NEW_LINE INDENT Num = Rem * 10 + ( ord ( str [ i ] ) - ord ( '0' ) ) NEW_LINE Rem = Num % R NEW_LINE DEDENT return Rem NEW_LINE DEDENT
Hyp: 
def Remainder ( st , R ) : NEW_LINE INDENT ln = len ( st ) NEW_LINE Rem = 0 NEW_LINE for i in range ( 0 , ln ) : NEW_LINE INDENT Num = Rem * 10 + ( int ) ( st [ i ] ) NEW_LINE Rem = Num % R NEW_LINE DEDENT return Rem NEW_LINE DEDENT

BLEU: 65.46
Edit Sim: 30


Src: 
> calculate ( int [ ] arr ) { int n = arr . length ; List < Integer > ans = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < arr . length ; i ++ ) { int sum = 0 ; for ( int j = 0 ; j < arr . length ; j ++ ) { sum += Math . abs ( arr [ i ] - arr [ j ] ) ; } ans . add ( sum ) ; } return ans ; }
Ref: 
def calculate ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE ans = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for j in range ( len ( arr ) ) : NEW_LINE INDENT sum += abs ( arr [ i ] - arr [ j ] ) NEW_LINE DEDENT ans . append ( sum ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
Hyp: 
def calculate ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE ans = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT sum += abs ( arr [ i ] - arr [ j ] ) NEW_LINE DEDENT ans . append ( sum ) NEW_LINE DEDENT return ans NEW_LINE DEDENT

BLEU: 92.53
Edit Sim: 10


Src: 
boolean productOfSingelDgt ( int n ) { if ( n >= 0 && n <= 9 ) return true ; int [ ] prime = { 2 , 3 , 5 , 7 } ; for ( int i = 0 ; i < SIZE && n > 1 ; i ++ ) while ( n % prime [ i ] == 0 ) n = n / prime [ i ] ; return ( n == 1 ) ; }
Ref: 
def productOfSingelDgt ( n ) : NEW_LINE INDENT if n >= 0 and n <= 9 : NEW_LINE INDENT return True NEW_LINE DEDENT prime = [ 2 , 3 , 5 , 7 ] NEW_LINE i = 0 NEW_LINE while i < SIZE and n > 1 : NEW_LINE INDENT while n % prime [ i ] == 0 : NEW_LINE INDENT n = n / prime [ i ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return n == 1 NEW_LINE DEDENT n = 24 NEW_LINE if productOfSingelDgt ( n ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
Hyp: 
def productOfSingelDgt ( n ) : NEW_LINE INDENT if ( n >= 0 and n <= 9 ) : NEW_LINE INDENT return True NEW_LINE DEDENT prime = [ 2 , 3 , 5 , 7 ] NEW_LINE for i in range ( SIZE and n > 1 ) : NEW_LINE INDENT while ( n % prime [ i ] == 0 ) : NEW_LINE INDENT n = n // prime [ i ] NEW_LINE DEDENT DEDENT return ( n == 1 ) NEW_LINE DEDENT n = 12 NEW_LINE if ( productOfSingelDgt ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT

BLEU: 69.91
Edit Sim: 56


Src: 
void bitonicSequence ( int num , int lower , int upper ) { if ( num > ( upper - lower ) * 2 + 1 ) { System . out . println ( - 1 ) ; return ; } Deque < Integer > ans = new ArrayDeque < > ( ) ; for ( int i = 0 ; i < Math . min ( upper - lower + 1 , num - 1 ) ; i ++ ) ans . add ( upper - i ) ; for ( int i = 0 ; i < num - ans . size ( ) ; i ++ ) ans . addFirst ( upper - i - 1 ) ; System . out . println ( ans ) ; }
Ref: 
def bitonicSequence ( num , lower , upper ) : NEW_LINE INDENT if ( num > ( upper - lower ) * 2 + 1 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE return NEW_LINE DEDENT ans = deque ( ) NEW_LINE for i in range ( min ( upper - lower + 1 , num - 1 ) ) : NEW_LINE INDENT ans . append ( upper - i ) NEW_LINE DEDENT for i in range ( num - len ( ans ) ) : NEW_LINE INDENT ans . appendleft ( upper - i - 1 ) NEW_LINE DEDENT print ( list ( ans ) ) NEW_LINE DEDENT
Hyp: 
def bitonicSequence ( num , lower , upper ) : NEW_LINE INDENT if ( num > ( upper - lower ) * 2 + 1 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE return NEW_LINE DEDENT ans = [ ] NEW_LINE for i in range ( min ( upper - lower + 1 , num - 1 ) ) : NEW_LINE INDENT ans . append ( upper - i ) NEW_LINE DEDENT for i in range ( num - len ( ans ) ) : NEW_LINE INDENT ans . append ( upper - i - 1 ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT

BLEU: 89.44
Edit Sim: 21


Src: 
int findMaximumGcd ( int n ) { int max_gcd = 1 ; for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( i > max_gcd ) max_gcd = i ; if ( ( n / i != i ) && ( n / i != n ) && ( ( n / i ) > max_gcd ) ) max_gcd = n / i ; } } return max_gcd ; }
Ref: 
def findMaximumGcd ( n ) : NEW_LINE INDENT max_gcd = 1 NEW_LINE i = 1 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT if ( i > max_gcd ) : NEW_LINE INDENT max_gcd = i NEW_LINE DEDENT if ( ( n / i != i ) and ( n / i != n ) and ( ( n / i ) > max_gcd ) ) : NEW_LINE INDENT max_gcd = n / i NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT return ( int ( max_gcd ) ) NEW_LINE DEDENT
Hyp: 
def findMaximumGcd ( n ) : NEW_LINE INDENT max_gcd = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( i > max_gcd ) : NEW_LINE INDENT max_gcd = i NEW_LINE DEDENT if ( ( n // i != i ) and ( n // i != n ) and ( ( n // i ) > max_gcd ) ) : NEW_LINE INDENT max_gcd = n // i NEW_LINE DEDENT DEDENT DEDENT return max_gcd NEW_LINE DEDENT

BLEU: 63.42
Edit Sim: 58


Src: 
int findMax ( int n , int a [ ] , int b [ ] , int k [ ] , int m ) { int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < m ; i ++ ) { int lowerbound = a [ i ] ; int upperbound = b [ i ] ; for ( int j = lowerbound ; j <= upperbound ; j ++ ) arr [ j ] += k [ i ] ; } int res = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) res = Math . max ( res , arr [ i ] ) ; return res ; }
Ref: 
def findMax ( n , a , b , k , m ) : NEW_LINE INDENT arr = [ 0 ] * n NEW_LINE for i in range ( m ) : NEW_LINE INDENT lowerbound = a [ i ] NEW_LINE upperbound = b [ i ] NEW_LINE for j in range ( lowerbound , upperbound + 1 ) : NEW_LINE arr [ j ] += k [ i ] NEW_LINE res = - sys . maxsize - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT res = max ( res , arr [ i ] ) NEW_LINE return res NEW_LINE DEDENT DEDENT DEDENT
Hyp: 
def findMax ( n , a , b , k , m ) : NEW_LINE INDENT arr = [ 0 ] * n NEW_LINE for i in range ( m ) : NEW_LINE INDENT lowerbound = a [ i ] NEW_LINE upperbound = b [ i ] NEW_LINE for j in range ( lowerbound , upperbound + 1 ) : NEW_LINE INDENT arr [ j ] += k [ i ] NEW_LINE DEDENT DEDENT res = sys . maxsize NEW_LINE for i in range ( n ) : NEW_LINE INDENT res = max ( res , arr [ i ] ) NEW_LINE DEDENT return res NEW_LINE DEDENT

BLEU: 89.3
Edit Sim: 48


Src: 
double sum ( int n ) { double sum = 0 ; int fact = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { fact *= i ; sum += 1.0 / fact ; } return sum ; }
Ref: 
def sum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE fact = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT fact *= i NEW_LINE sum += 1.0 / fact NEW_LINE DEDENT print ( sum ) NEW_LINE DEDENT
Hyp: 
def sum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE fact = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT fact *= i NEW_LINE sum += 1.0 / fact NEW_LINE DEDENT return sum NEW_LINE DEDENT

BLEU: 89.1
Edit Sim: 8


Src: 
int countSubsets ( int a [ ] , int n ) { int answer = 0 ; for ( int i = 0 ; i < ( 1 << n ) ; i ++ ) { int bitwiseAND = - 1 ; int bitwiseOR = 0 ; int bitwiseXOR = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( i & ( 1 << j ) ) == 0 ) { if ( bitwiseAND == - 1 ) bitwiseAND = a [ j ] ; else bitwiseAND &= a [ j ] ; bitwiseOR |= a [ j ] ; bitwiseXOR ^= a [ j ] ; } } if ( bitwiseAND == bitwiseOR && bitwiseOR == bitwiseXOR ) answer = ( answer + 1 ) % mod ; } return answer ; }
Ref: 
def countSubsets ( a , n ) : NEW_LINE INDENT answer = 0 ; NEW_LINE for i in range ( 1 << n ) : NEW_LINE INDENT bitwiseAND = - 1 ; NEW_LINE bitwiseOR = 0 ; NEW_LINE bitwiseXOR = 0 ; NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( i & ( 1 << j ) ) : NEW_LINE INDENT if ( bitwiseAND == - 1 ) : NEW_LINE INDENT bitwiseAND = a [ j ] ; NEW_LINE DEDENT else : NEW_LINE INDENT bitwiseAND &= a [ j ] ; NEW_LINE DEDENT bitwiseOR |= a [ j ] ; NEW_LINE bitwiseXOR ^= a [ j ] ; NEW_LINE DEDENT DEDENT if ( bitwiseAND == bitwiseOR and bitwiseOR == bitwiseXOR ) : NEW_LINE INDENT answer = ( answer + 1 ) % mod ; NEW_LINE DEDENT DEDENT return answer ; NEW_LINE DEDENT
Hyp: 
def countSubsets ( a , n ) : NEW_LINE INDENT answer = 0 NEW_LINE for i in range ( 1 << n ) : NEW_LINE INDENT bitwiseAND = - 1 NEW_LINE bitwiseOR = 0 NEW_LINE bitwiseXOR = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( ( i & ( 1 << j ) ) == 0 ) : NEW_LINE INDENT if ( bitwiseAND == - 1 ) : NEW_LINE INDENT bitwiseAND = a [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT bitwiseAND &= a [ j ] NEW_LINE bitwiseOR |= a [ j ] NEW_LINE bitwiseXOR ^= a [ j ] NEW_LINE DEDENT DEDENT if ( bitwiseAND == bitwiseOR and bitwiseOR == bitwiseXOR ) : NEW_LINE INDENT answer = ( answer + 1 ) % mod NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT

BLEU: 80.25
Edit Sim: 36


Src: 
void RemoveHTMLTags ( String str ) { str = str . replaceAll ( " \\ < . * ? \\ > " , " " ) ; System . out . println ( str ) ; }
Ref: 
def RemoveHTMLTags ( strr ) : NEW_LINE INDENT print ( re . compile ( r ' < [ ^ > ] + > ' ) . sub ( ' ' , strr ) ) NEW_LINE DEDENT
Hyp: 
def RemoveHTMLTags ( str ) : NEW_LINE INDENT str = str . replace ( " \\ < . * ? \\ > " , " " ) NEW_LINE print ( str ) NEW_LINE DEDENT

BLEU: 18.34
Edit Sim: 46


Src: 
Node deleteAlt ( Node head ) { if ( head == null ) return ; Node node = head . next ; if ( node == null ) return ; head . next = node . next ; head . next = deleteAlt ( head . next ) ; }
Ref: 
def deleteAlt ( head ) : NEW_LINE INDENT if ( head == None ) : NEW_LINE INDENT return NEW_LINE DEDENT node = head . next NEW_LINE if ( node == None ) : NEW_LINE INDENT return NEW_LINE DEDENT head . next = node . next NEW_LINE deleteAlt ( head . next ) NEW_LINE DEDENT
Hyp: 
def deleteAlt ( head ) : NEW_LINE INDENT if ( head == null ) : NEW_LINE INDENT return NEW_LINE DEDENT node = head . next NEW_LINE if ( node == null ) : NEW_LINE INDENT return NEW_LINE DEDENT head . next = node . next NEW_LINE head . next = deleteAlt ( head . next ) NEW_LINE DEDENT return head NEW_LINE DEDENT

BLEU: 76.09
Edit Sim: 50


Src: 
int maximumCount ( int arr [ ] , int N ) { int odd = 0 ; int even = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 == 1 ) odd ++ ; else even ++ ; } if ( odd > 0 && even > 0 ) return N - 2 ; else return N - 1 ; }
Ref: 
def maximumCount ( arr , N ) : NEW_LINE INDENT odd = 0 NEW_LINE even = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] % 2 ) : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT else : NEW_LINE INDENT even += 1 NEW_LINE DEDENT DEDENT if ( odd and even ) : NEW_LINE INDENT return N - 2 NEW_LINE DEDENT else : NEW_LINE INDENT return N - 1 NEW_LINE DEDENT DEDENT
Hyp: 
def maximumCount ( arr , N ) : NEW_LINE INDENT odd = 0 NEW_LINE even = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 1 ) : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT else : NEW_LINE INDENT even += 1 NEW_LINE DEDENT DEDENT if ( odd > 0 and even > 0 ) : NEW_LINE INDENT return N - 2 NEW_LINE DEDENT else : NEW_LINE INDENT return N - 1 NEW_LINE DEDENT DEDENT

BLEU: 88.03
Edit Sim: 13


Src: 
int findMinZero ( int p ) { int first = 1 , second = 1 , number = 2 , next = 1 ; while ( next > 0 ) { next = ( first + second ) % p ; first = second ; second = next ; number ++ ; } return number ; }
Ref: 
def findMinZero ( p ) : NEW_LINE INDENT first = 1 NEW_LINE second = 1 NEW_LINE number = 2 NEW_LINE next = 1 NEW_LINE while ( next ) : NEW_LINE INDENT next = ( first + second ) % p NEW_LINE first = second NEW_LINE second = next NEW_LINE number = number + 1 NEW_LINE DEDENT return number NEW_LINE DEDENT
Hyp: 
def findMinZero ( p ) : NEW_LINE INDENT first = 1 NEW_LINE second = 1 NEW_LINE number = 2 NEW_LINE next = 1 NEW_LINE while ( next > 0 ) : NEW_LINE INDENT next = ( first + second ) % p NEW_LINE first = second NEW_LINE second = next NEW_LINE number += 1 NEW_LINE DEDENT return number NEW_LINE DEDENT

BLEU: 89.75
Edit Sim: 14


Src: 
void flipBitsOfAandB ( int A , int B ) { A = A ^ ( A & B ) ; B = B ^ ( A & B ) ; System . out . print ( A + " ▁ " + B ) ; }
Ref: 
def flipBitsOfAandB ( A , B ) : NEW_LINE INDENT A = A ^ ( A & B ) NEW_LINE B = B ^ ( A & B ) NEW_LINE print ( A , B ) NEW_LINE DEDENT
Hyp: 
def flipBitsOfAandB ( A , B ) : NEW_LINE INDENT A = A ^ ( A & B ) NEW_LINE B = B ^ ( A & B ) NEW_LINE print ( A , B ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int cntOnesArrWithGivenOp ( int arr [ ] , int N ) { int cntOnes = 0 ; cntOnes = ( int ) Math . sqrt ( N ) ; return cntOnes ; }
Ref: 
def cntOnesArrWithGivenOp ( arr , N ) : NEW_LINE INDENT cntOnes = 0 ; NEW_LINE cntOnes = int ( N ** ( 1 / 2 ) ) ; NEW_LINE return cntOnes ; NEW_LINE DEDENT
Hyp: 
def cntOnesArrWithGivenOp ( arr , N ) : NEW_LINE INDENT cntOnes = 0 NEW_LINE cntOnes = math . sqrt ( N ) NEW_LINE return cntOnes NEW_LINE DEDENT

BLEU: 47.93
Edit Sim: 21


Src: 
void findSides ( double A , double C , double c ) { double B = 180 - ( A + C ) ; A = A * ( 3.14159 / 180 ) ; C = C * ( 3.14159 / 180 ) ; B = B * ( 3.14159 / 180 ) ; double a = ( c / Math . sin ( C ) ) * Math . sin ( A ) ; double b = ( c / Math . sin ( C ) ) * Math . sin ( B ) ; System . out . println ( String . format ( " % .2f " , a ) ) ; System . out . println ( String . format ( " % .2f " , b ) ) ; }
Ref: 
def findSides ( A , C , c ) : NEW_LINE INDENT B = 180 - ( A + C ) NEW_LINE A = A * ( 3.14159 / 180 ) NEW_LINE C = C * ( 3.14159 / 180 ) NEW_LINE B = B * ( 3.14159 / 180 ) NEW_LINE a = ( c / math . sin ( C ) ) * math . sin ( A ) NEW_LINE b = ( c / math . sin ( C ) ) * math . sin ( B ) NEW_LINE print ( " { 0 : . 2f } " . format ( a ) ) NEW_LINE print ( " { 0 : . 2f } " . format ( b ) ) NEW_LINE DEDENT
Hyp: 
def findSides ( A , C , c ) : NEW_LINE INDENT B = 180 - ( A + C ) NEW_LINE A = A * ( 3.14159 / 180 ) NEW_LINE C = C * ( 3.14159 / 180 ) NEW_LINE B = B * ( 3.14159 / 180 ) NEW_LINE a = ( c / math . sin ( C ) ) * math . sin ( A ) NEW_LINE b = ( c / math . sin ( C ) ) * math . sin ( B ) NEW_LINE print ( " % .2f " , a ) NEW_LINE print ( " % .2f " , b ) ) NEW_LINE DEDENT

BLEU: 80.5
Edit Sim: 38


Src: 
float hexagonArea ( float d ) { return ( float ) ( ( 3 * Math . sqrt ( 3 ) * d * d ) / 8 ) ; }
Ref: 
def hexagonArea ( d ) : NEW_LINE INDENT return ( 3 * sqrt ( 3 ) * pow ( d , 2 ) ) / 8 NEW_LINE DEDENT
Hyp: 
def hexagonArea ( d ) : NEW_LINE INDENT return ( ( 3 * math . sqrt ( 3 ) * d * d ) / 8 ) NEW_LINE DEDENT

BLEU: 56.94
Edit Sim: 20


Src: 
int MinimumMoves ( int a [ ] , int n , int x ) { int ans = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] <= a [ i - 1 ] ) { int p = ( a [ i - 1 ] - a [ i ] ) / x + 1 ; ans += p ; a [ i ] += p * x ; } } return ans ; }
Ref: 
def MinimumMoves ( a , n , x ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if a [ i ] <= a [ i - 1 ] : NEW_LINE INDENT p = ( a [ i - 1 ] - a [ i ] ) // x + 1 NEW_LINE ans += p NEW_LINE a [ i ] += p * x NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
Hyp: 
def MinimumMoves ( a , n , x ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( a [ i ] <= a [ i - 1 ] ) : NEW_LINE INDENT p = ( a [ i - 1 ] - a [ i ] ) // x + 1 NEW_LINE ans += p NEW_LINE a [ i ] += p * x NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT

BLEU: 93.93
Edit Sim: 4


Src: 
int countCommon ( int mat [ ] [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( mat [ i ] [ i ] == mat [ i ] [ n - i - 1 ] ) res ++ ; return res ; }
Ref: 
def countCommon ( mat , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if mat [ i ] [ i ] == mat [ i ] [ n - i - 1 ] : NEW_LINE INDENT res = res + 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
Hyp: 
def countCommon ( mat , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( mat [ i ] [ i ] == mat [ i ] [ n - i - 1 ] ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT

BLEU: 86.86
Edit Sim: 11


Src: 
int Min_Replace ( int [ ] arr , int n , int k ) { Arrays . sort ( arr ) ; Integer [ ] freq = new Integer [ MAX ] ; Arrays . fill ( freq , 0 ) ; int p = 0 ; freq [ p ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] ) ++ freq [ p ] ; else ++ freq [ ++ p ] ; } Arrays . sort ( freq , Collections . reverseOrder ( ) ) ; int ans = 0 ; for ( int i = k ; i <= p ; i ++ ) ans += freq [ i ] ; return ans ; }
Ref: 
def Min_Replace ( arr , n , k ) : NEW_LINE INDENT arr . sort ( reverse = False ) NEW_LINE freq = [ 0 for i in range ( MAX ) ] NEW_LINE p = 0 NEW_LINE freq [ p ] = 1 NEW_LINE for i in range ( 1 , n , 1 ) : NEW_LINE INDENT if ( arr [ i ] == arr [ i - 1 ] ) : NEW_LINE INDENT freq [ p ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT p += 1 NEW_LINE freq [ p ] += 1 NEW_LINE DEDENT DEDENT freq . sort ( reverse = True ) NEW_LINE ans = 0 NEW_LINE for i in range ( k , p + 1 , 1 ) : NEW_LINE INDENT ans += freq [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT
Hyp: 
def Min_Replace ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE freq = [ 0 ] * MAX NEW_LINE freq [ 0 ] = 1 NEW_LINE p = 0 NEW_LINE freq [ p ] = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] == arr [ i - 1 ] ) : NEW_LINE INDENT freq [ p ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT freq [ p ] += 1 NEW_LINE DEDENT DEDENT freq [ p ] = 1 NEW_LINE for i in range ( k , p + 1 ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( k , p + 1 ) : NEW_LINE INDENT ans += freq [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT

BLEU: 78.6
Edit Sim: 109


Src: 
void divide ( int a , int b ) { for ( int i = 2 ; i <= Math . min ( a , b ) ; i ++ ) { while ( a % i == 0 && b % i == 0 ) { a = a / i ; b = b / i ; } } System . out . println ( " A ▁ = ▁ " + a + " , ▁ B ▁ = ▁ " + b ) ; }
Ref: 
def divide ( a , b ) : NEW_LINE INDENT for i in range ( 2 , min ( a , b ) + 1 ) : NEW_LINE INDENT while ( a % i == 0 and b % i == 0 ) : NEW_LINE INDENT a = a // i NEW_LINE b = b // i NEW_LINE DEDENT DEDENT print ( " A ▁ = " , a , " , ▁ B ▁ = " , b ) NEW_LINE DEDENT
Hyp: 
def divide ( a , b ) : NEW_LINE INDENT i = 2 NEW_LINE while i <= min ( a , b ) : NEW_LINE INDENT while ( a % i == 0 and b % i == 0 ) : NEW_LINE INDENT a = a // i NEW_LINE b = b // i NEW_LINE DEDENT DEDENT print ( " A ▁ = " , a , " , ▁ B ▁ = " , b ) NEW_LINE DEDENT

BLEU: 85.43
Edit Sim: 26


Src: 
void findSet ( int N , int K ) { ArrayList < Integer > a = new ArrayList < Integer > ( ) ; for ( int i = 1 ; i <= N ; i ++ ) { if ( i != K ) a . add ( i ) ; } int MaxDistinct = ( N - K ) + ( K / 2 ) ; Collections . reverse ( a ) ; for ( int i = 0 ; i < MaxDistinct ; i ++ ) System . out . print ( a . get ( i ) + " ▁ " ) ; }
Ref: 
def findSet ( N , K ) : NEW_LINE INDENT a = [ ] NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( i != K ) : NEW_LINE INDENT a . append ( i ) NEW_LINE DEDENT DEDENT MaxDistinct = ( N - K ) + ( K // 2 ) NEW_LINE a = a [ : : - 1 ] NEW_LINE for i in range ( MaxDistinct ) : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
Hyp: 
def findSet ( N , K ) : NEW_LINE INDENT a = [ ] NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if i != K : NEW_LINE INDENT a . append ( i ) NEW_LINE DEDENT DEDENT MaxDistinct = ( N - K ) + ( K // 2 ) NEW_LINE a . reverse ( ) NEW_LINE for i in range ( MaxDistinct ) : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT

BLEU: 85.18
Edit Sim: 16


Src: 
float AvgofSquareN ( int n ) { return ( float ) ( ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; }
Ref: 
def AvgofSquareN ( n ) : NEW_LINE INDENT return ( ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; NEW_LINE DEDENT
Hyp: 
def AvgofSquareN ( n ) : NEW_LINE INDENT return ( ( n + 1 ) * ( 2 * n + 1 ) ) / 6 NEW_LINE DEDENT

BLEU: 91.94
Edit Sim: 2


Src: 
int getRemainder ( int num , int divisor ) { while ( num >= divisor ) num -= divisor ; return num ; }
Ref: 
def getRemainder ( num , divisor ) : NEW_LINE INDENT while ( num >= divisor ) : NEW_LINE INDENT num -= divisor ; NEW_LINE DEDENT return num ; NEW_LINE DEDENT
Hyp: 
def getRemainder ( num , divisor ) : NEW_LINE INDENT while ( num >= divisor ) : NEW_LINE INDENT num -= divisor NEW_LINE DEDENT return num NEW_LINE DEDENT

BLEU: 83.24
Edit Sim: 4


Src: 
int findUnique ( int a [ ] , int n , int k ) { byte sizeof_int = 4 ; int INT_SIZE = 8 * sizeof_int ; int count [ ] = new int [ INT_SIZE ] ; for ( int i = 0 ; i < INT_SIZE ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( ( a [ j ] & ( 1 << i ) ) != 0 ) count [ i ] += 1 ; int res = 0 ; for ( int i = 0 ; i < INT_SIZE ; i ++ ) res += ( count [ i ] % k ) * ( 1 << i ) ; return res ; }
Ref: 
def findUnique ( a , n , k ) : NEW_LINE INDENT INT_SIZE = 8 * sys . getsizeof ( int ) NEW_LINE count = [ 0 ] * INT_SIZE NEW_LINE for i in range ( INT_SIZE ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( ( a [ j ] & ( 1 << i ) ) != 0 ) : NEW_LINE INDENT count [ i ] += 1 NEW_LINE DEDENT DEDENT DEDENT res = 0 NEW_LINE for i in range ( INT_SIZE ) : NEW_LINE INDENT res += ( count [ i ] % k ) * ( 1 << i ) NEW_LINE DEDENT return res NEW_LINE DEDENT
Hyp: 
def findUnique ( a , n , k ) : NEW_LINE INDENT sizeof_int = 4 NEW_LINE INT_SIZE = 8 * sizeof_int NEW_LINE count = [ 0 ] * INT_SIZE NEW_LINE for i in range ( INT_SIZE ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( a [ j ] & ( 1 << i ) ) != 0 : NEW_LINE INDENT count [ i ] += 1 NEW_LINE DEDENT DEDENT res = 0 NEW_LINE for i in range ( INT_SIZE ) : NEW_LINE INDENT res += ( count [ i ] % k ) * ( 1 << i ) NEW_LINE DEDENT return res NEW_LINE DEDENT

BLEU: 87.38
Edit Sim: 48


Src: 
String isDivisible ( int n ) { int temp = n ; while ( n > 0 ) { int k = n % 10 ; if ( temp % k == 0 ) { return " YES " ; } n /= 10 ; } return " NO " ; }
Ref: 
def isDivisible ( n ) : NEW_LINE INDENT temp = n NEW_LINE while ( n ) : NEW_LINE INDENT k = n % 10 NEW_LINE if ( temp % k == 0 ) : NEW_LINE INDENT return " YES " NEW_LINE DEDENT n /= 10 ; NEW_LINE DEDENT return " NO " NEW_LINE DEDENT
Hyp: 
def isDivisible ( n ) : NEW_LINE INDENT temp = n NEW_LINE while ( n > 0 ) : NEW_LINE INDENT k = n % 10 NEW_LINE if ( temp % k == 0 ) : NEW_LINE INDENT return " YES " NEW_LINE DEDENT n //= 10 NEW_LINE DEDENT return " NO " NEW_LINE DEDENT

BLEU: 87.37
Edit Sim: 7


Src: 
void printSquares ( int n ) { int square = 0 , odd = 1 ; for ( int x = 0 ; x < n ; x ++ ) { System . out . print ( square + " ▁ " ) ; square = square + odd ; odd = odd + 2 ; } }
Ref: 
def printSquares ( n ) : NEW_LINE INDENT square = 0 NEW_LINE odd = 1 NEW_LINE for x in range ( 0 , n ) : NEW_LINE INDENT print ( square , end = " ▁ " ) NEW_LINE DEDENT square = square + odd NEW_LINE odd = odd + 2 NEW_LINE DEDENT
Hyp: 
def printSquare ( n ) : NEW_LINE INDENT square = 0 NEW_LINE odd = 1 NEW_LINE for x in range ( n ) : NEW_LINE INDENT print ( square , end = " ▁ " ) NEW_LINE square = square + odd NEW_LINE odd = odd + 2 NEW_LINE DEDENT DEDENT

BLEU: 85.36
Edit Sim: 19


Src: 
long multiply ( long x , long n ) { return x << n ; }
Ref: 
def multiply ( x , n ) : NEW_LINE INDENT return x << n NEW_LINE DEDENT
Hyp: 
def multiply ( x , n ) : NEW_LINE INDENT return x << n NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int countWays ( int N ) { if ( N < 4 ) return 0 ; int ans = ( ( N - 1 ) * ( N - 2 ) ) / 2 ; int s = 0 ; for ( int i = 2 ; i <= N - 3 ; i ++ ) { for ( int j = 1 ; j < i ; j ++ ) { if ( N == 2 * i + j ) s ++ ; } } if ( N % 3 == 0 ) s = 3 * s + 1 ; else s = 3 * s ; return ans - s ; }
Ref: 
def countWays ( N ) : NEW_LINE INDENT if ( N < 4 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = ( ( N - 1 ) * ( N - 2 ) ) // 2 NEW_LINE s = 0 NEW_LINE for i in range ( 2 , N - 2 , 1 ) : NEW_LINE INDENT for j in range ( 1 , i , 1 ) : NEW_LINE INDENT if ( N == 2 * i + j ) : NEW_LINE INDENT s += 1 NEW_LINE DEDENT DEDENT DEDENT if ( N % 3 == 0 ) : NEW_LINE INDENT s = 3 * s + 1 NEW_LINE DEDENT else : NEW_LINE INDENT s = 3 * s NEW_LINE DEDENT return ans - s NEW_LINE DEDENT
Hyp: 
def countWays ( N ) : NEW_LINE INDENT if ( N < 4 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT ans = ( ( N - 1 ) * ( N - 2 ) ) // 2 ; NEW_LINE s = 0 ; NEW_LINE for i in range ( 2 , N - 3 ) : NEW_LINE INDENT for j in range ( 1 , i ) : NEW_LINE INDENT if ( N == 2 * i + j ) : NEW_LINE INDENT s += 1 ; NEW_LINE DEDENT DEDENT DEDENT if ( N % 3 == 0 ) : NEW_LINE INDENT s = 3 * s + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT s = 3 * s ; NEW_LINE DEDENT DEDENT return ans - s ; NEW_LINE DEDENT

BLEU: 82.53
Edit Sim: 30


Src: 
boolean hasAllcodes ( String s , int k ) { Set < String > us = new HashSet < String > ( ) ; for ( int i = 0 ; i + k <= s . length ( ) ; i ++ ) { us . add ( s . substring ( i , i + k ) ) ; } return ( us . size ( ) == ( 1 << k ) ) ; }
Ref: 
def hasAllcodes ( s , k ) : NEW_LINE INDENT us = set ( ) NEW_LINE for i in range ( len ( s ) + 1 ) : NEW_LINE INDENT us . add ( s [ i : k ] ) NEW_LINE DEDENT return len ( us ) == 1 << k NEW_LINE DEDENT s = "00110110" NEW_LINE k = 2 NEW_LINE if ( hasAllcodes ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
Hyp: 
def hasAllcodes ( s , k ) : NEW_LINE INDENT us = set ( ) NEW_LINE for i in range ( 0 , len ( s ) + k ) : NEW_LINE INDENT us . add ( s [ i : i + k ] ) NEW_LINE DEDENT return ( len ( us ) == ( 1 << k ) ) NEW_LINE DEDENT

BLEU: 48.05
Edit Sim: 174


Src: 
long multiplyByFifteen ( long n ) { long prod = ( n << 3 ) ; prod += ( n << 2 ) ; prod += ( n << 1 ) ; prod += n ; return prod ; }
Ref: 
def multiplyByFifteen ( n ) : NEW_LINE INDENT prod = ( n << 3 ) NEW_LINE prod += ( n << 2 ) NEW_LINE prod += ( n << 1 ) NEW_LINE prod += n NEW_LINE return prod NEW_LINE DEDENT
Hyp: 
def multiplyByFifteen ( n ) : NEW_LINE INDENT prod = ( n << 3 ) ; NEW_LINE prod += ( n << 2 ) ; NEW_LINE prod += ( n << 1 ) ; NEW_LINE prod += n ; NEW_LINE return prod ; NEW_LINE DEDENT

BLEU: 71.06
Edit Sim: 10


Src: 
void calcSum ( int arr [ ] , int n , int k ) { int sum = 0 ; for ( int i = 0 ; i < k ; i ++ ) sum += arr [ i ] ; System . out . print ( sum + " ▁ " ) ; for ( int i = k ; i < n ; i ++ ) { sum = ( sum - arr [ i - k ] ) + arr [ i ] ; System . out . print ( sum + " ▁ " ) ; } }
Ref: 
def calcSum ( arr , n , k ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT print ( sum , end = " ▁ " ) NEW_LINE for i in range ( k , n ) : NEW_LINE INDENT sum = ( sum - arr [ i - k ] ) + arr [ i ] NEW_LINE print ( sum , end = " ▁ " ) NEW_LINE DEDENT DEDENT
Hyp: 
def calcSum ( arr , n , k ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT print ( sum , end = " ▁ " ) NEW_LINE for i in range ( k , n ) : NEW_LINE INDENT sum = ( sum - arr [ i - k ] ) + arr [ i ] NEW_LINE DEDENT print ( sum , end = " ▁ " ) NEW_LINE DEDENT

BLEU: 97.39
Edit Sim: 14


Src: 
float weightedMean ( int X [ ] , int W [ ] , int n ) { int sum = 0 , numWeight = 0 ; for ( int i = 0 ; i < n ; i ++ ) { numWeight = numWeight + X [ i ] * W [ i ] ; sum = sum + W [ i ] ; } return ( float ) ( numWeight ) / sum ; }
Ref: 
def weightedMean ( X , W , n ) : NEW_LINE INDENT sum = 0 NEW_LINE numWeight = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT numWeight = numWeight + X [ i ] * W [ i ] NEW_LINE sum = sum + W [ i ] NEW_LINE i = i + 1 NEW_LINE DEDENT return ( float ) ( numWeight / sum ) NEW_LINE DEDENT X = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] NEW_LINE W = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] NEW_LINE n = len ( X ) NEW_LINE m = len ( W ) NEW_LINE if ( n == m ) : NEW_LINE INDENT print weightedMean ( X , W , n ) NEW_LINE DEDENT else : NEW_LINE INDENT print " - 1" NEW_LINE DEDENT
Hyp: 
def weightedMean ( X , W , n ) : NEW_LINE INDENT sum = 0 NEW_LINE numWeight = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT numWeight = numWeight + X [ i ] * W [ i ] NEW_LINE sum = sum + W [ i ] NEW_LINE DEDENT return ( float ) ( numWeight ) / sum NEW_LINE DEDENT

BLEU: 18.22
Edit Sim: 332


Src: 
void minimumIncreasingSubsequences ( int arr [ ] , int N ) { Arrays . sort ( arr ) ; int count = 0 ; int i = 0 ; while ( i < N ) { int x = arr [ i ] ; int freqX = 0 ; while ( i < N && arr [ i ] == x ) { freqX ++ ; i ++ ; } count = Math . max ( count , freqX ) ; } System . out . print ( count ) ; }
Ref: 
def minimumIncreasingSubsequences ( arr , N ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE count = 0 NEW_LINE i = 0 NEW_LINE while ( i < N ) : NEW_LINE INDENT x = arr [ i ] NEW_LINE freqX = 0 NEW_LINE while ( i < N and arr [ i ] == x ) : NEW_LINE INDENT freqX += 1 NEW_LINE i += 1 NEW_LINE DEDENT count = max ( count , freqX ) NEW_LINE DEDENT print ( count ) NEW_LINE DEDENT
Hyp: 
def minimumIncreasingSubsequences ( arr , N ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE count = 0 NEW_LINE i = 0 NEW_LINE while ( i < N ) : NEW_LINE INDENT x = arr [ i ] NEW_LINE freqX = 0 NEW_LINE while ( i < N and arr [ i ] == x ) : NEW_LINE INDENT freqX += 1 NEW_LINE i += 1 NEW_LINE DEDENT count = max ( count , freqX ) NEW_LINE DEDENT print ( count ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
void evenproduct ( int arr [ ] , int length ) { int total_subarray = length * ( length + 1 ) / 2 ; int total_odd = 0 ; int count_odd = 0 ; for ( int i = 0 ; i < arr . length ; ++ i ) { if ( arr [ i ] % 2 == 0 ) { count_odd = 0 ; } else { ++ count_odd ; total_odd += count_odd ; } } System . out . println ( total_subarray - total_odd ) ; }
Ref: 
def evenproduct ( arr , length ) : NEW_LINE INDENT total_subarray = length * ( length + 1 ) // 2 NEW_LINE total_odd = 0 NEW_LINE count_odd = 0 NEW_LINE for i in range ( length ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT count_odd = 0 NEW_LINE DEDENT else : NEW_LINE INDENT count_odd += 1 NEW_LINE total_odd += count_odd NEW_LINE DEDENT DEDENT print ( total_subarray - total_odd ) NEW_LINE DEDENT
Hyp: 
def evenproduct ( arr , length ) : NEW_LINE INDENT total_subarray = length * ( length + 1 ) / 2 NEW_LINE total_odd = 0 NEW_LINE count_odd = 0 NEW_LINE for i in range ( length ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT count_odd = 0 NEW_LINE DEDENT else : NEW_LINE INDENT count_odd = 1 NEW_LINE DEDENT total_odd += count_odd NEW_LINE DEDENT DEDENT print ( total_subarray - total_odd ) NEW_LINE DEDENT

BLEU: 90.97
Edit Sim: 9


Src: 
boolean isDivisibleBy5 ( String str ) { int n = str . length ( ) ; return ( ( ( str . charAt ( n - 1 ) - '0' ) == 0 ) || ( ( str . charAt ( n - 1 ) - '0' ) == 5 ) ) ; }
Ref: 
def isDivisibleBy5 ( st ) : NEW_LINE INDENT n = len ( st ) NEW_LINE return ( ( st [ n - 1 ] == '0' ) or ( st [ n - 1 ] == '5' ) ) NEW_LINE DEDENT st = "76955" NEW_LINE if isDivisibleBy5 ( st ) : NEW_LINE INDENT print " Yes " NEW_LINE DEDENT else : NEW_LINE INDENT print " No ▁ " NEW_LINE DEDENT
Hyp: 
def isDivisibleBy5 ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE return ( ( ord ( str [ n - 1 ] ) - ord ( '0' ) == 0 ) or ( ord ( str [ n - 1 ] ) - ord ( '0' ) == 5 ) ) NEW_LINE DEDENT

BLEU: 32.53
Edit Sim: 154


Src: 
double Area ( double l , double b , double h ) { if ( l < 0 b < 0 h < 0 ) return - 1 ; double x = ( l * b ) / ( l + b ) ; double A = 0.70477 * Math . pow ( x , 2 ) ; return A ; }
Ref: 
def Area ( l , b , h ) : NEW_LINE INDENT if ( l < 0 or b < 0 or h < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT x = ( l * b ) / ( l + b ) NEW_LINE A = 0.70477 * pow ( x , 2 ) NEW_LINE return A NEW_LINE DEDENT
Hyp: 
def Area ( l , b , h ) : NEW_LINE INDENT if l < 0 or b < 0 or h < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT x = ( l * b ) / ( l + b ) NEW_LINE A = 0.70477 * pow ( x , 2 ) NEW_LINE return A NEW_LINE DEDENT

BLEU: 91.83
Edit Sim: 4


Src: 
boolean isAlphabaticOrder ( String s ) { int n = s . length ( ) ; char c [ ] = new char [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { c [ i ] = s . charAt ( i ) ; } Arrays . sort ( c ) ; for ( int i = 0 ; i < n ; i ++ ) if ( c [ i ] != s . charAt ( i ) ) return false ; return true ; }
Ref: 
def isAlphabaticOrder ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE c = [ s [ i ] for i in range ( len ( s ) ) ] NEW_LINE c . sort ( reverse = False ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( c [ i ] != s [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
Hyp: 
def isAlphabaticOrder ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE c = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT c [ i ] = s [ i ] NEW_LINE DEDENT c . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( c [ i ] != s [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT

BLEU: 73.48
Edit Sim: 64


Src: 
long fourthPowerSum ( int n ) { long sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum = sum + ( i * i * i * i ) ; return sum ; }
Ref: 
def fourthPowerSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum = sum + ( i * i * i * i ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
Hyp: 
def fourthPowerSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum = sum + ( i * i * i * i ) NEW_LINE DEDENT return sum NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int subset ( int ar [ ] , int n ) { int res = 0 ; Arrays . sort ( ar ) ; for ( int i = 0 ; i < n ; i ++ ) { int count = 1 ; for ( ; i < n - 1 ; i ++ ) { if ( ar [ i ] == ar [ i + 1 ] ) count ++ ; else break ; } res = Math . max ( res , count ) ; } return res ; }
Ref: 
def subset ( ar , n ) : NEW_LINE INDENT res = 0 NEW_LINE ar . sort ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT count = 1 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ar [ i ] == ar [ i + 1 ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT res = max ( res , count ) NEW_LINE DEDENT return res NEW_LINE DEDENT
Hyp: 
def subset ( ar , n ) : NEW_LINE INDENT res = 0 NEW_LINE ar . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT count = 1 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( ar [ i ] == ar [ i + 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT res = max ( res , count ) NEW_LINE DEDENT return res NEW_LINE DEDENT

BLEU: 92.61
Edit Sim: 8


Src: 
double polygonArea ( double X [ ] , double Y [ ] , int n ) { double area = 0.0 ; int j = n - 1 ; for ( int i = 0 ; i < n ; i ++ ) { area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) ; j = i ; } return Math . abs ( area / 2.0 ) ; }
Ref: 
def polygonArea ( X , Y , n ) : NEW_LINE INDENT area = 0.0 NEW_LINE j = n - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT area = area + ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) NEW_LINE DEDENT return abs ( area // 2.0 ) NEW_LINE DEDENT
Hyp: 
def polygonArea ( X , Y , n ) : NEW_LINE INDENT area = 0.0 NEW_LINE j = n - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) NEW_LINE DEDENT return abs ( area / 2.0 ) NEW_LINE DEDENT

BLEU: 90.08
Edit Sim: 9


Src: 
float getSum ( int a , int n ) { float sum = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { sum += ( i / Math . pow ( a , i ) ) ; } return sum ; }
Ref: 
def getSum ( a , n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += ( i / math . pow ( a , i ) ) ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT
Hyp: 
def getSum ( a , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += ( i / pow ( a , i ) ) NEW_LINE DEDENT return sum NEW_LINE DEDENT

BLEU: 77.7
Edit Sim: 13


Src: 
void multiple ( int a , int b , int x ) { if ( b < 0 ) { if ( a == 1 && x == 1 ) System . out . println ( "1" ) ; else System . out . println ( "0" ) ; } int mul = ( int ) Math . pow ( a , b ) ; int ans = mul / x ; int ans1 = x * ans ; int ans2 = x * ( ans + 1 ) ; System . out . println ( ( ( mul - ans1 ) <= ( ans2 - mul ) ) ? ans1 : ans2 ) ; }
Ref: 
def multiple ( a , b , x ) : NEW_LINE INDENT if ( b < 0 ) : NEW_LINE INDENT if ( a == 1 and x == 1 ) : NEW_LINE INDENT print ( "1" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( "0" ) ; NEW_LINE DEDENT DEDENT mul = int ( pow ( a , b ) ) ; NEW_LINE ans = int ( mul / x ) ; NEW_LINE ans1 = x * ans ; NEW_LINE ans2 = x * ( ans + 1 ) ; NEW_LINE if ( ( mul - ans1 ) <= ( ans2 - mul ) ) : NEW_LINE INDENT print ( ans1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( ans2 ) ; NEW_LINE DEDENT DEDENT
Hyp: 
def multiple ( a , b , x ) : NEW_LINE INDENT if ( b < 0 ) : NEW_LINE INDENT if ( a == 1 and x == 1 ) : NEW_LINE INDENT print ( "1" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "0" ) NEW_LINE DEDENT DEDENT mul = math . pow ( a , b ) NEW_LINE ans = mul // x NEW_LINE ans1 = x * ans NEW_LINE ans2 = x * ( ans + 1 ) NEW_LINE print ( ( mul - ans1 ) <= ( ans2 - mul ) ) ? ans1 : ans2 ) NEW_LINE DEDENT

BLEU: 62.07
Edit Sim: 114


Src: 
int oddFib ( int n ) { n = ( 3 * n + 1 ) / 2 ; int a = - 1 , b = 1 , c = 0 , i ; for ( i = 1 ; i <= n ; i ++ ) { c = a + b ; a = b ; b = c ; } return c ; }
Ref: 
def oddFib ( n ) : NEW_LINE INDENT n = ( 3 * n + 1 ) // 2 NEW_LINE a = - 1 NEW_LINE b = 1 NEW_LINE c = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT c = a + b NEW_LINE a = b NEW_LINE b = c NEW_LINE DEDENT return c NEW_LINE DEDENT
Hyp: 
def oddFib ( n ) : NEW_LINE INDENT n = int ( ( 3 * n + 1 ) / 2 ) NEW_LINE a = - 1 NEW_LINE b = 1 NEW_LINE c = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT c = a + b NEW_LINE a = b NEW_LINE b = c NEW_LINE DEDENT return c NEW_LINE DEDENT

BLEU: 88.53
Edit Sim: 9


Src: 
void maximumTiles ( int n , int m ) { System . out . println ( ( m * n ) / 2 ) ; }
Ref: 
def maximumTiles ( n , m ) : NEW_LINE INDENT print ( int ( ( m * n ) / 2 ) ) ; NEW_LINE DEDENT
Hyp: 
def maximumTiles ( n , m ) : NEW_LINE INDENT print ( ( m * n ) // 2 ) NEW_LINE DEDENT

BLEU: 65.61
Edit Sim: 11


Src: 
int divisorGame ( int N , int A , int dp [ ] [ ] ) { if ( N == 1 N == 3 ) return 0 ; if ( N == 2 ) return 1 ; if ( dp [ N ] [ A ] != - 1 ) return dp [ N ] [ A ] ; int ans = ( A == 1 ) ? 0 : 1 ; for ( int i = 1 ; i * i <= N ; i ++ ) { if ( N % i == 0 ) { if ( A == 1 ) ans |= divisorGame ( N - i , 0 , dp ) ; else ans &= divisorGame ( N - i , 1 , dp ) ; } } return dp [ N ] [ A ] = ans ; }
Ref: 
def divisorGame ( N , A , dp ) : NEW_LINE INDENT if ( N == 1 or N == 3 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( N == 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( dp [ N ] [ A ] != - 1 ) : NEW_LINE INDENT return dp [ N ] [ A ] NEW_LINE DEDENT if ( A == 1 ) : NEW_LINE INDENT ans = 0 NEW_LINE DEDENT else : NEW_LINE INDENT ans = 1 NEW_LINE DEDENT for i in range ( 1 , int ( sqrt ( N ) ) + 1 , 1 ) : NEW_LINE INDENT if ( N % i == 0 ) : NEW_LINE INDENT if ( A ) : NEW_LINE INDENT ans |= divisorGame ( N - i , 0 , dp ) NEW_LINE DEDENT else : NEW_LINE INDENT ans &= divisorGame ( N - i , 1 , dp ) NEW_LINE DEDENT DEDENT DEDENT dp [ N ] [ A ] = ans NEW_LINE return dp [ N ] [ A ] NEW_LINE DEDENT
Hyp: 
def divisorGame ( N , A , dp ) : NEW_LINE INDENT if ( N == 1 or N == 3 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( N == 2 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( dp [ N ] [ A ] != - 1 ) : NEW_LINE INDENT return dp [ N ] [ A ] NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT if ( N % i == 0 ) : NEW_LINE INDENT if ( A == 1 ) : NEW_LINE INDENT ans |= divisorGame ( N - i , 0 , dp ) NEW_LINE DEDENT else : NEW_LINE INDENT ans &= divisorGame ( N - i , 1 , dp ) NEW_LINE DEDENT DEDENT return dp [ N ] [ A ] NEW_LINE DEDENT

BLEU: 71.55
Edit Sim: 162


Src: 
int findK ( int n , int k ) { ArrayList < Integer > a = new ArrayList < Integer > ( n ) ; for ( int i = 1 ; i < n ; i ++ ) if ( i % 2 == 1 ) a . add ( i ) ; for ( int i = 1 ; i < n ; i ++ ) if ( i % 2 == 0 ) a . add ( i ) ; return ( a . get ( k - 1 ) ) ; }
Ref: 
def findK ( n , k ) : NEW_LINE INDENT a = list ( ) NEW_LINE i = 1 NEW_LINE while i < n : NEW_LINE INDENT a . append ( i ) NEW_LINE i = i + 2 NEW_LINE DEDENT i = 2 NEW_LINE while i < n : NEW_LINE INDENT a . append ( i ) NEW_LINE i = i + 2 NEW_LINE DEDENT return ( a [ k - 1 ] ) NEW_LINE DEDENT
Hyp: 
def findK ( n , k ) : NEW_LINE INDENT a = [ ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( i % 2 == 1 ) : NEW_LINE INDENT a . append ( i ) NEW_LINE DEDENT DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT a . append ( i ) NEW_LINE DEDENT DEDENT return ( a [ k - 1 ] ) NEW_LINE DEDENT

BLEU: 47.08
Edit Sim: 116


Src: 
void splitString ( String str ) { StringBuffer alpha = new StringBuffer ( ) , num = new StringBuffer ( ) , special = new StringBuffer ( ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( Character . isDigit ( str . charAt ( i ) ) ) num . append ( str . charAt ( i ) ) ; else if ( Character . isAlphabetic ( str . charAt ( i ) ) ) alpha . append ( str . charAt ( i ) ) ; else special . append ( str . charAt ( i ) ) ; } System . out . println ( alpha ) ; System . out . println ( num ) ; System . out . println ( special ) ; }
Ref: 
def splitString ( str ) : NEW_LINE INDENT alpha = " " NEW_LINE num = " " NEW_LINE special = " " NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] . isdigit ( ) ) : NEW_LINE INDENT num = num + str [ i ] NEW_LINE DEDENT elif ( ( str [ i ] >= ' A ' and str [ i ] <= ' Z ' ) or ( str [ i ] >= ' a ' and str [ i ] <= ' z ' ) ) : NEW_LINE INDENT alpha += str [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT special += str [ i ] NEW_LINE DEDENT DEDENT print ( alpha ) NEW_LINE print ( num ) NEW_LINE print ( special ) NEW_LINE DEDENT
Hyp: 
def splitString ( str ) : NEW_LINE INDENT alpha = [ ] NEW_LINE num = [ ] NEW_LINE special = [ ] NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( Character . isDigit ( str [ i ] ) ) : NEW_LINE INDENT num . append ( str [ i ] ) NEW_LINE DEDENT elif ( Character . isAlphabetic ( str [ i ] ) ) : NEW_LINE INDENT alpha . append ( str [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT special . append ( str [ i ] ) NEW_LINE DEDENT DEDENT print ( alpha ) NEW_LINE print ( num ) NEW_LINE print ( special ) NEW_LINE DEDENT

BLEU: 54.02
Edit Sim: 133


Src: 
int sum_of_series ( int n ) { int result = 0 ; if ( n % 2 == 0 ) { result = - ( n * ( n + 1 ) ) / 2 ; } else { result = ( n * ( n + 1 ) ) / 2 ; } return result ; }
Ref: 
def sum_of_series ( n ) : NEW_LINE INDENT result = 0 NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT result = - ( n * ( n + 1 ) ) // 2 NEW_LINE DEDENT else : NEW_LINE INDENT result = ( n * ( n + 1 ) ) // 2 NEW_LINE DEDENT return result NEW_LINE DEDENT
Hyp: 
def sum_of_series ( n ) : NEW_LINE INDENT result = 0 NEW_LINE if n % 2 == 0 : NEW_LINE INDENT result = - ( n * ( n + 1 ) ) // 2 NEW_LINE DEDENT else : NEW_LINE INDENT result = ( n * ( n + 1 ) ) // 2 NEW_LINE DEDENT return result NEW_LINE DEDENT

BLEU: 91.7
Edit Sim: 4


Src: 
void midpoint ( int x1 , int x2 , int y1 , int y2 ) { System . out . print ( ( x1 + x2 ) / 2 + " ▁ , ▁ " + ( y1 + y2 ) / 2 ) ; }
Ref: 
def midpoint ( x1 , x2 , y1 , y2 ) : NEW_LINE INDENT print ( ( x1 + x2 ) // 2 , " ▁ , ▁ " , ( y1 + y2 ) // 2 ) NEW_LINE DEDENT
Hyp: 
def midpoint ( x1 , x2 , y1 , y2 ) : NEW_LINE INDENT print ( ( x1 + x2 ) // 2 , " ▁ , " , ( y1 + y2 ) // 2 ) NEW_LINE DEDENT

BLEU: 93.54
Edit Sim: 2


Src: 
boolean isSaintExuperyNum ( int n ) { for ( int i = 1 ; i <= n / 3 ; i ++ ) { for ( int j = i + 1 ; j <= n / 2 ; j ++ ) { int k = n / i / j ; if ( i * i + j * j == k * k ) { if ( i * j * k == n ) return true ; } } } return false ; }
Ref: 
def isSaintExuperyNum ( n ) : NEW_LINE INDENT for i in range ( 1 , ( n // 3 ) + 1 ) : NEW_LINE INDENT for j in range ( i + 1 , ( n // 2 ) + 1 ) : NEW_LINE INDENT k = n / i / j NEW_LINE if i * i + j * j == k * k : NEW_LINE INDENT if i * j * k == n : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT DEDENT return False NEW_LINE DEDENT N = 60 NEW_LINE if isSaintExuperyNum ( N ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
Hyp: 
def isSaintExuperyNum ( n ) : NEW_LINE INDENT for i in range ( 1 , n // 3 + 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n // 2 + 1 ) : NEW_LINE INDENT k = n // i // j NEW_LINE if ( i * i + j * j == k * k ) : NEW_LINE INDENT if ( i * j * k == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT

BLEU: 54.13
Edit Sim: 176


Src: 
int catalanDP ( int n ) { int catalan [ ] = new int [ n + 2 ] ; catalan [ 0 ] = 1 ; catalan [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { catalan [ i ] = 0 ; for ( int j = 0 ; j < i ; j ++ ) { catalan [ i ] += catalan [ j ] * catalan [ i - j - 1 ] ; } } return catalan [ n ] ; }
Ref: 
def catalan ( n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT catalan = [ 0 ] * ( n + 1 ) NEW_LINE catalan [ 0 ] = 1 NEW_LINE catalan [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT catalan [ i ] += catalan [ j ] * catalan [ i - j - 1 ] NEW_LINE DEDENT DEDENT return catalan [ n ] NEW_LINE DEDENT for i in range ( 10 ) : NEW_LINE INDENT print ( catalan ( i ) , end = " ▁ " ) NEW_LINE DEDENT
Hyp: 
def catalanDP ( n ) : NEW_LINE INDENT catalan = [ 0 for i in range ( n + 2 ) ] NEW_LINE catalan [ 0 ] = 1 NEW_LINE catalan [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT catalan [ i ] = 0 NEW_LINE for j in range ( i ) : NEW_LINE INDENT catalan [ i ] += catalan [ j ] * catalan [ i - j - 1 ] NEW_LINE DEDENT DEDENT return catalan [ n ] NEW_LINE DEDENT

BLEU: 58.69
Edit Sim: 198


Src: 
int findNature ( int a , int b , int n ) { int [ ] seq = new int [ 100 ] ; seq [ 0 ] = a ; seq [ 1 ] = b ; for ( int i = 2 ; i <= n ; i ++ ) seq [ i ] = seq [ i - 1 ] + seq [ i - 2 ] ; if ( ( seq [ n ] & 1 ) != 0 ) return 1 ; else return 0 ; }
Ref: 
def findNature ( a , b , n ) : NEW_LINE INDENT seq = [ 0 ] * MAX ; NEW_LINE seq [ 0 ] = a ; NEW_LINE seq [ 1 ] = b ; NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT seq [ i ] = seq [ i - 1 ] + seq [ i - 2 ] ; NEW_LINE DEDENT return ( seq [ n ] & 1 ) ; NEW_LINE DEDENT a = 2 ; NEW_LINE b = 4 ; NEW_LINE n = 3 ; NEW_LINE if ( findNature ( a , b , n ) ) : NEW_LINE INDENT print ( " Odd " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Even " ) ; NEW_LINE DEDENT
Hyp: 
def findNature ( a , b , n ) : NEW_LINE INDENT seq = [ 0 ] * 100 NEW_LINE seq [ 0 ] = a NEW_LINE seq [ 1 ] = b NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT seq [ i ] = seq [ i - 1 ] + seq [ i - 2 ] NEW_LINE DEDENT if ( seq [ n ] & 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT

BLEU: 51.67
Edit Sim: 156


Src: 
int largestArea ( int arr1 [ ] , int n , int arr2 [ ] , int m ) { int end = 0 , start = 0 , i = 0 , j = 0 ; Arrays . sort ( arr1 ) ; Arrays . sort ( arr1 ) ; while ( i < n && j < m ) { if ( arr1 [ i ] == arr2 [ j ] ) { if ( start == 0 ) start = arr1 [ i ] ; else end = arr1 [ i ] ; i ++ ; j ++ ; } else if ( arr1 [ i ] > arr2 [ j ] ) j ++ ; else i ++ ; } if ( end == 0 start == 0 ) return 0 ; else return ( end - start ) ; }
Ref: 
def largestArea ( arr1 , n , arr2 , m ) : NEW_LINE INDENT end = 0 NEW_LINE start = 0 NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE arr1 . sort ( reverse = False ) NEW_LINE arr2 . sort ( reverse = False ) NEW_LINE while ( i < n and j < m ) : NEW_LINE INDENT if ( arr1 [ i ] == arr2 [ j ] ) : NEW_LINE INDENT if ( start == 0 ) : NEW_LINE INDENT start = arr1 [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT end = arr1 [ i ] NEW_LINE DEDENT i += 1 NEW_LINE j += 1 NEW_LINE DEDENT elif ( arr1 [ i ] > arr2 [ j ] ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT if ( end == 0 or start == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return ( end - start ) NEW_LINE DEDENT DEDENT
Hyp: 
def largestArea ( arr1 , n , arr2 , m ) : NEW_LINE INDENT end = 0 NEW_LINE start = 0 NEW_LINE i = 0 ; j = 0 NEW_LINE arr1 . sort ( ) NEW_LINE while ( i < n and j < m ) : NEW_LINE INDENT if ( arr1 [ i ] == arr2 [ j ] ) : NEW_LINE INDENT if ( start == 0 ) : NEW_LINE INDENT start = arr1 [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT end = arr1 [ i ] NEW_LINE i += 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT if ( arr1 [ i ] > arr2 [ j ] ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT if ( end == 0 or start == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return ( end - start ) NEW_LINE DEDENT DEDENT

BLEU: 87.77
Edit Sim: 79


Src: 
int KthMinValAfterMconcatenate ( int [ ] A , int N , int M , int K ) { Arrays . sort ( A ) ; return ( A [ ( ( K - 1 ) / M ) ] ) ; }
Ref: 
def KthMinValAfterMconcatenate ( A , N , M , K ) : NEW_LINE INDENT V = [ ] NEW_LINE for i in range ( 0 , M ) : NEW_LINE INDENT for j in range ( 0 , N ) : NEW_LINE INDENT V . append ( A [ j ] ) NEW_LINE DEDENT DEDENT V . sort ( ) NEW_LINE return V [ K - 1 ] NEW_LINE DEDENT
Hyp: 
def KthMinValAfterMconcatenate ( A , N , M , K ) : NEW_LINE INDENT A . sort ( ) NEW_LINE return ( A [ ( ( K - 1 ) // M ) ] ) NEW_LINE DEDENT

BLEU: 26.86
Edit Sim: 150


Src: 
int subString ( String s , int n ) { Map < Integer , Integer > hash = new HashMap < > ( ) ; hash . put ( 0 , 1 ) ; int pre = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { pre ^= ( 1 << ( int ) ( s . charAt ( i ) - 97 ) ) ; count += hash . getOrDefault ( pre , 0 ) ; hash . put ( pre , hash . getOrDefault ( pre , 0 ) + 1 ) ; } return count ; }
Ref: 
def subString ( s , n ) : NEW_LINE INDENT hash = { 0 : 1 } NEW_LINE pre = 0 NEW_LINE count = 0 NEW_LINE for i in s : NEW_LINE INDENT pre ^= ( 1 << ord ( i ) - 97 ) NEW_LINE count += hash . get ( pre , 0 ) NEW_LINE hash [ pre ] = hash . get ( pre , 0 ) + 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
Hyp: 
def subString ( s , n ) : NEW_LINE INDENT hash = defaultdict ( int ) NEW_LINE hash [ 0 ] = 1 NEW_LINE pre = 0 NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT pre ^= ( 1 << ( int ) ( ord ( s [ i ] ) - 97 ) ) NEW_LINE count += hash [ pre ] NEW_LINE hash [ pre ] += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT

BLEU: 56.83
Edit Sim: 105


Src: 
int sum_of_4_squares ( int n ) { int i , odd = 0 , even = 0 ; for ( i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( i % 2 == 0 ) even += i ; else odd += i ; if ( ( n / i ) != i ) { if ( ( n / i ) % 2 == 0 ) even += ( n / i ) ; else odd += ( n / i ) ; } } } if ( n % 2 == 1 ) return 8 * ( odd + even ) ; else return 24 * ( odd ) ; }
Ref: 
def sum_of_4_squares ( n ) : NEW_LINE INDENT i , odd , even = 0 , 0 , 0 NEW_LINE for i in range ( 1 , int ( n ** ( .5 ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT even += i NEW_LINE DEDENT else : NEW_LINE INDENT odd += i NEW_LINE DEDENT if ( ( n // i ) != i ) : NEW_LINE INDENT if ( ( n // i ) % 2 == 0 ) : NEW_LINE INDENT even += ( n // i ) NEW_LINE DEDENT else : NEW_LINE INDENT odd += ( n // i ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if ( n % 2 == 1 ) : NEW_LINE INDENT return 8 * ( odd + even ) NEW_LINE DEDENT else : NEW_LINE INDENT return 24 * ( odd ) NEW_LINE DEDENT DEDENT
Hyp: 
def sum_of_4_squares ( n ) : NEW_LINE INDENT odd = 0 ; even = 0 ; NEW_LINE for i in range ( 1 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT even += i NEW_LINE DEDENT else : NEW_LINE INDENT odd += i NEW_LINE DEDENT if ( ( n / i ) != i ) : NEW_LINE INDENT if ( ( n / i ) % 2 == 0 ) : NEW_LINE INDENT even += ( n / i ) NEW_LINE DEDENT else : NEW_LINE INDENT odd += ( n / i ) NEW_LINE DEDENT DEDENT DEDENT if ( n % 2 == 1 ) : NEW_LINE INDENT return 8 * ( odd + even ) NEW_LINE DEDENT else : NEW_LINE INDENT return 24 * ( odd ) NEW_LINE DEDENT DEDENT

BLEU: 83.67
Edit Sim: 31


Src: 
int avg_of_odd_num ( int n ) { return n ; }
Ref: 
def avg_of_odd_num ( n ) : NEW_LINE INDENT return n NEW_LINE DEDENT
Hyp: 
def avg_of_odd_num ( n ) : NEW_LINE INDENT return n // 2 NEW_LINE DEDENT

BLEU: 74.87
Edit Sim: 5


Src: 
int swapBitsInPair ( int x ) { return ( ( x & 0b10101010 ) >> 1 ) | ( ( x & 0b01010101 ) << 1 ) ; }
Ref: 
def swapBitsInPair ( x ) : NEW_LINE INDENT return ( ( x & 0b10101010 ) >> 1 ) or ( ( x & 0b01010101 ) << 1 ) NEW_LINE DEDENT
Hyp: 
def swapBitsInPair ( x ) : NEW_LINE INDENT return ( ( x & 0b10101010 ) >> 1 ) | ( ( x & 0b01010101 ) << 1 ) NEW_LINE DEDENT

BLEU: 91.28
Edit Sim: 2


Src: 
int countTriplets ( int [ ] a , int n ) { ArrayList < Integer > s = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) s . add ( a [ i ] ) ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int xr = a [ i ] ^ a [ j ] ; if ( s . contains ( xr ) && xr != a [ i ] && xr != a [ j ] ) count ++ ; } } return count / 3 ; }
Ref: 
def countTriplets ( a , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . add ( a [ i ] ) NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n , 1 ) : NEW_LINE INDENT xr = a [ i ] ^ a [ j ] NEW_LINE if ( xr in s and xr != a [ i ] and xr != a [ j ] ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT DEDENT return int ( count / 3 ) NEW_LINE DEDENT
Hyp: 
def countTriplets ( a , n ) : NEW_LINE INDENT s = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . append ( a [ i ] ) NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT xr = a [ i ] ^ a [ j ] NEW_LINE if ( xr not in s ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count // 3 NEW_LINE DEDENT

BLEU: 67.97
Edit Sim: 60


Src: 
int findMaxValue ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int ans = arr [ n - 1 ] ; int maxPossible = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; -- i ) { if ( maxPossible > 0 ) { if ( arr [ i ] >= maxPossible ) { ans += ( maxPossible - 1 ) ; maxPossible = maxPossible - 1 ; } else { maxPossible = arr [ i ] ; ans += maxPossible ; } } } return ans ; }
Ref: 
def findMaxValue ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE ans = arr [ n - 1 ] NEW_LINE maxPossible = arr [ n - 1 ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( maxPossible > 0 ) : NEW_LINE INDENT if ( arr [ i ] >= maxPossible ) : NEW_LINE INDENT ans += ( maxPossible - 1 ) NEW_LINE maxPossible = maxPossible - 1 NEW_LINE DEDENT else : NEW_LINE INDENT maxPossible = arr [ i ] NEW_LINE ans += maxPossible NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
Hyp: 
def findMaxValue ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE ans = arr [ n - 1 ] NEW_LINE maxPossible = arr [ n - 1 ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( maxPossible > 0 ) : NEW_LINE INDENT if ( arr [ i ] >= maxPossible ) : NEW_LINE INDENT ans += ( maxPossible - 1 ) NEW_LINE maxPossible = maxPossible - 1 NEW_LINE DEDENT else : NEW_LINE INDENT maxPossible = arr [ i ] NEW_LINE ans += maxPossible NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int countDigits ( int a , int b ) { int count = 0 ; int p = Math . abs ( a * b ) ; if ( p == 0 ) return 1 ; while ( p > 0 ) { count ++ ; p = p / 10 ; } return count ; }
Ref: 
def countDigits ( a , b ) : NEW_LINE INDENT count = 0 NEW_LINE p = abs ( a * b ) NEW_LINE if ( p == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT while ( p > 0 ) : NEW_LINE INDENT count = count + 1 NEW_LINE p = p // 10 NEW_LINE DEDENT return count NEW_LINE DEDENT
Hyp: 
def countDigits ( a , b ) : NEW_LINE INDENT count = 0 NEW_LINE p = abs ( a * b ) NEW_LINE if ( p == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT while ( p > 0 ) : NEW_LINE INDENT count += 1 NEW_LINE p = p // 10 NEW_LINE DEDENT return count NEW_LINE DEDENT

BLEU: 92.6
Edit Sim: 9


Src: 
int OR ( int a [ ] , int n ) { int ans = a [ 0 ] ; int i ; for ( i = 1 ; i < n ; i ++ ) { ans |= a [ i ] ; } return ans ; }
Ref: 
def OR ( a , n ) : NEW_LINE INDENT ans = a [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT ans |= a [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT
Hyp: 
def OR ( a , n ) : NEW_LINE INDENT ans = a [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT ans |= a [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int sum ( int N , int X , int Y ) { int S1 , S2 , S3 ; S1 = ( ( N / X ) ) * ( 2 * X + ( N / X - 1 ) * X ) / 2 ; S2 = ( ( N / Y ) ) * ( 2 * Y + ( N / Y - 1 ) * Y ) / 2 ; S3 = ( ( N / ( X * Y ) ) ) * ( 2 * ( X * Y ) + ( N / ( X * Y ) - 1 ) * ( X * Y ) ) / 2 ; return S1 + S2 - S3 ; }
Ref: 
def sum ( N , X , Y ) : NEW_LINE INDENT S1 = floor ( floor ( N / X ) * floor ( 2 * X + floor ( N / X - 1 ) * X ) / 2 ) NEW_LINE S2 = floor ( floor ( N / Y ) ) * floor ( 2 * Y + floor ( N / Y - 1 ) * Y ) / 2 NEW_LINE S3 = floor ( floor ( N / ( X * Y ) ) ) * floor ( 2 * ( X * Y ) + floor ( N / ( X * Y ) - 1 ) * ( X * Y ) ) / 2 NEW_LINE return S1 + S2 - S3 NEW_LINE DEDENT
Hyp: 
def sum ( N , X , Y ) : NEW_LINE INDENT S1 = ( ( N // X ) ) * ( 2 * X + ( N // X - 1 ) * X ) / 2 NEW_LINE S2 = ( ( N // Y ) ) * ( 2 * Y + ( N // Y - 1 ) * Y ) / 2 NEW_LINE S3 = ( ( N // X * Y ) ) * ( 2 * ( X * Y ) + ( N // ( X * Y ) - 1 ) * ( X * Y ) ) // 2 NEW_LINE return S1 + S2 - S3 NEW_LINE DEDENT

BLEU: 61.57
Edit Sim: 84


Src: 
void countOddRotations ( int n ) { int odd_count = 0 , even_count = 0 ; do { int digit = n % 10 ; if ( digit % 2 == 1 ) odd_count ++ ; else even_count ++ ; n = n / 10 ; } while ( n != 0 ) ; System . out . println ( " Odd ▁ = ▁ " + odd_count ) ; System . out . println ( " Even ▁ = ▁ " + even_count ) ; }
Ref: 
def countOddRotations ( n ) : NEW_LINE INDENT odd_count = 0 ; even_count = 0 NEW_LINE while n != 0 : NEW_LINE INDENT digit = n % 10 NEW_LINE if digit % 2 == 0 : NEW_LINE INDENT odd_count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT even_count += 1 NEW_LINE DEDENT n = n // 10 NEW_LINE DEDENT print ( " Odd ▁ = " , odd_count ) NEW_LINE print ( " Even ▁ = " , even_count ) NEW_LINE DEDENT
Hyp: 
def countOddRotations ( n ) : NEW_LINE INDENT odd_count = 0 NEW_LINE even_count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT digit = n % 10 NEW_LINE if ( digit % 2 == 1 ) : NEW_LINE INDENT odd_count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT even_count += 1 NEW_LINE DEDENT n = n // 10 NEW_LINE DEDENT print ( " Odd ▁ = " , odd_count ) NEW_LINE print ( " Even ▁ = " , even_count ) NEW_LINE DEDENT

BLEU: 84.44
Edit Sim: 17


Src: 
void printTetra ( int n ) { int [ ] dp = new int [ n + 5 ] ; dp [ 0 ] = 0 ; dp [ 1 ] = dp [ 2 ] = 1 ; dp [ 3 ] = 2 ; for ( int i = 4 ; i <= n ; i ++ ) dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] + dp [ i - 3 ] + dp [ i - 4 ] ; System . out . print ( dp [ n ] ) ; }
Ref: 
def printTetra ( n ) : NEW_LINE INDENT dp = [ 0 ] * ( n + 5 ) ; NEW_LINE dp [ 0 ] = 0 ; NEW_LINE dp [ 1 ] = 1 ; NEW_LINE dp [ 2 ] = 1 ; NEW_LINE dp [ 3 ] = 2 ; NEW_LINE for i in range ( 4 , n + 1 ) : NEW_LINE INDENT dp [ i ] = ( dp [ i - 1 ] + dp [ i - 2 ] + dp [ i - 3 ] + dp [ i - 4 ] ) ; NEW_LINE DEDENT print ( dp [ n ] ) ; NEW_LINE DEDENT
Hyp: 
def printTetra ( n ) : NEW_LINE INDENT dp = [ 0 for i in range ( n + 5 ) ] NEW_LINE dp [ 0 ] = 0 NEW_LINE dp [ 1 ] = dp [ 2 ] = 1 NEW_LINE dp [ 3 ] = 2 NEW_LINE for i in range ( 4 , n + 1 ) : NEW_LINE INDENT dp [ i ] = ( dp [ i - 1 ] + dp [ i - 2 ] + dp [ i - 3 ] + dp [ i - 4 ] ) NEW_LINE DEDENT print ( dp [ n ] ) NEW_LINE DEDENT

BLEU: 79.59
Edit Sim: 37


Src: 
int minPushes ( int N , int K , int [ ] arr ) { int [ ] dp = new int [ 100000 ] ; for ( int i = 0 ; i < dp . length ; i ++ ) dp [ i ] = - 1 ; dp [ N ] = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { for ( int xx = 0 ; xx < 100000 ; xx ++ ) { int x = xx ; if ( dp [ x ] == - 1 ) continue ; int next = ( x + arr [ i ] ) % 100000 ; while ( dp [ next ] == - 1 dp [ next ] > dp [ x ] + 1 ) { dp [ next ] = dp [ x ] + 1 ; x = next ; next = ( next + arr [ i ] ) % 100000 ; } } } return dp [ K ] ; }
Ref: 
def minPushes ( N , K , arr ) : NEW_LINE INDENT dp = [ - 1 ] * 100000 NEW_LINE dp [ N ] = 0 NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT for xx in range ( 100000 ) : NEW_LINE INDENT x = xx NEW_LINE if ( dp [ x ] == - 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT next = ( x + arr [ i ] ) % 100000 NEW_LINE while ( dp [ next ] == - 1 or dp [ next ] > dp [ x ] + 1 ) : NEW_LINE INDENT dp [ next ] = dp [ x ] + 1 NEW_LINE x = next NEW_LINE next = ( next + arr [ i ] ) % 100000 NEW_LINE DEDENT DEDENT DEDENT return dp [ K ] NEW_LINE DEDENT
Hyp: 
def minPushes ( N , K , arr ) : NEW_LINE INDENT dp = [ - 1 for x in range ( 100000 ) ] NEW_LINE dp [ N ] = 0 NEW_LINE for i in range ( arr . length ) : NEW_LINE INDENT for xx in range ( 100000 ) : NEW_LINE INDENT x = xx NEW_LINE if ( dp [ x ] == - 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT next = ( x + arr [ i ] ) % 100000 NEW_LINE while ( dp [ next ] == - 1 or dp [ next ] > dp [ x ] + 1 ) : NEW_LINE INDENT dp [ next ] = dp [ x ] + 1 NEW_LINE x = next NEW_LINE next = ( next + arr [ i ] ) % 100000 NEW_LINE DEDENT DEDENT DEDENT return dp [ K ] NEW_LINE DEDENT

BLEU: 91.69
Edit Sim: 29


Src: 
int PositionRightmostSetbit ( int n ) { int position = 1 ; int m = 1 ; while ( ( n & m ) == 0 ) { m = m << 1 ; position ++ ; } return position ; }
Ref: 
def PositionRightmostSetbit ( n ) : NEW_LINE INDENT position = 1 NEW_LINE m = 1 NEW_LINE while ( not ( n & m ) ) : NEW_LINE INDENT m = m << 1 NEW_LINE position += 1 NEW_LINE DEDENT return position NEW_LINE DEDENT
Hyp: 
def PositionRightmostSetbit ( n ) : NEW_LINE INDENT position = 1 NEW_LINE m = 1 NEW_LINE while ( ( n & m ) == 0 ) : NEW_LINE INDENT m = m << 1 NEW_LINE position += 1 NEW_LINE DEDENT return position NEW_LINE DEDENT

BLEU: 88.2
Edit Sim: 9


Src: 
int distribution ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int count = 1 ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] > arr [ i - 1 ] ) count ++ ; return Math . min ( count , n / 2 ) ; }
Ref: 
def distribution ( arr , n ) : NEW_LINE INDENT arr . sort ( reverse = False ) NEW_LINE count = 1 NEW_LINE for i in range ( 1 , n , 1 ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i - 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return min ( count , n / 2 ) NEW_LINE DEDENT
Hyp: 
def distribution ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE count = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i - 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return min ( count , n // 2 ) NEW_LINE DEDENT

BLEU: 84.7
Edit Sim: 21


Src: 
boolean func ( int a [ ] , int k ) { for ( int i = 0 ; i < a . length ; i ++ ) if ( a [ i ] % k == 0 ) return true ; return false ; }
Ref: 
def func ( a , k , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( a [ i ] % k == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT a = [ 14 , 27 , 38 , 76 , 84 ] NEW_LINE k = 19 NEW_LINE res = func ( a , k , 5 ) NEW_LINE if ( res ) : NEW_LINE INDENT print ( " true " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " false " ) NEW_LINE DEDENT
Hyp: 
def func ( a , k ) : NEW_LINE INDENT for i in range ( len ( a ) ) : NEW_LINE INDENT if ( a [ i ] % k == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT

BLEU: 24.38
Edit Sim: 203


Src: 
void findDecimal ( double arr [ ] , int N ) { int bit , power = 0 , result = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { bit = Math . abs ( ( int ) Math . floor ( arr [ i ] ) - ( int ) Math . round ( arr [ i ] ) ) ; if ( bit != 0 ) result += Math . pow ( 2 , power ) ; power ++ ; } System . out . print ( result ) ; }
Ref: 
def findDecimal ( arr , N ) : NEW_LINE INDENT power = 0 ; NEW_LINE result = 0 ; NEW_LINE for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT bit = abs ( int ( arr [ i ] ) - round ( arr [ i ] ) ) ; NEW_LINE if ( bit ) : NEW_LINE INDENT result += pow ( 2 , power ) ; NEW_LINE DEDENT power += 1 ; NEW_LINE DEDENT print ( result ) ; NEW_LINE DEDENT
Hyp: 
def findDecimal ( arr , N ) : NEW_LINE INDENT power = 0 NEW_LINE result = 0 NEW_LINE for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT bit = abs ( arr [ i ] ) - abs ( arr [ i ] ) NEW_LINE if ( bit != 0 ) : NEW_LINE INDENT result += pow ( 2 , power ) NEW_LINE power += 1 NEW_LINE DEDENT DEDENT print ( result ) NEW_LINE DEDENT

BLEU: 71.59
Edit Sim: 44


Src: 
String fibWord ( int n ) { String Sn_1 = "0" ; String Sn = "01" ; String tmp ; for ( int i = 2 ; i <= n ; i ++ ) { tmp = Sn ; Sn += Sn_1 ; Sn_1 = tmp ; } return Sn ; }
Ref: 
def fibWord ( n ) : NEW_LINE INDENT Sn_1 = "0" NEW_LINE Sn = "01" NEW_LINE tmp = " " NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT tmp = Sn NEW_LINE Sn += Sn_1 NEW_LINE Sn_1 = tmp NEW_LINE DEDENT return Sn NEW_LINE DEDENT
Hyp: 
def fibWord ( n ) : NEW_LINE INDENT Sn_1 = "0" NEW_LINE Sn = "01" NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT tmp = Sn NEW_LINE Sn += Sn_1 NEW_LINE Sn_1 = tmp NEW_LINE DEDENT return Sn NEW_LINE DEDENT

BLEU: 88.4
Edit Sim: 19


Src: 
boolean isSuffix ( String s1 , String s2 ) { int n1 = s1 . length ( ) , n2 = s2 . length ( ) ; if ( n1 > n2 ) return false ; for ( int i = 0 ; i < n1 ; i ++ ) if ( s1 . charAt ( n1 - i - 1 ) != s2 . charAt ( n2 - i - 1 ) ) return false ; return true ; }
Ref: 
def isSuffix ( s1 , s2 ) : NEW_LINE INDENT n1 = len ( s1 ) NEW_LINE n2 = len ( s2 ) NEW_LINE if ( n1 > n2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( n1 ) : NEW_LINE INDENT if ( s1 [ n1 - i - 1 ] != s2 [ n2 - i - 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
Hyp: 
def isSuffix ( s1 , s2 ) : NEW_LINE INDENT n1 = len ( s1 ) NEW_LINE n2 = len ( s2 ) NEW_LINE if ( n1 > n2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( n1 ) : NEW_LINE INDENT if ( s1 [ n1 - i - 1 ] != s2 [ n2 - i - 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int sortExceptK ( int arr [ ] , int k , int n ) { int temp = arr [ k ] ; arr [ k ] = arr [ n - 1 ] ; arr [ n - 1 ] = temp ; Arrays . sort ( arr , 0 , n - 1 ) ; int last = arr [ n - 1 ] ; for ( int i = n - 1 ; i > k ; i -- ) arr [ i ] = arr [ i - 1 ] ; arr [ k ] = last ; return 0 ; }
Ref: 
def sortExcept ( arr , k , n ) : NEW_LINE INDENT arr [ k ] , arr [ - 1 ] = arr [ - 1 ] , arr [ k ] NEW_LINE arr = sorted ( arr , key = lambda i : ( i is arr [ - 1 ] , i ) ) NEW_LINE last = arr [ - 1 ] NEW_LINE i = n - 1 NEW_LINE while i > k : NEW_LINE INDENT arr [ i ] = arr [ i - 1 ] NEW_LINE i -= 1 NEW_LINE DEDENT arr [ k ] = last NEW_LINE return arr NEW_LINE DEDENT
Hyp: 
def sortExceptK ( arr , k , n ) : NEW_LINE INDENT temp = arr [ k ] NEW_LINE arr [ k ] = arr [ n - 1 ] NEW_LINE arr [ n - 1 ] = temp NEW_LINE arr . sort ( 0 , n - 1 ) NEW_LINE last = arr [ n - 1 ] NEW_LINE for i in range ( n - 1 , k , - 1 ) : NEW_LINE INDENT arr [ i ] = arr [ i - 1 ] NEW_LINE DEDENT arr [ k ] = last NEW_LINE return 0 NEW_LINE DEDENT

BLEU: 51.96
Edit Sim: 117


Src: 
int Centered_Triangular_num ( int n ) { return ( 3 * n * n + 3 * n + 2 ) / 2 ; }
Ref: 
def Centered_Triangular_num ( n ) : NEW_LINE INDENT return ( 3 * n * n + 3 * n + 2 ) // 2 NEW_LINE DEDENT
Hyp: 
def Centered_Triangular_num ( n ) : NEW_LINE INDENT return ( 3 * n * n + 3 * n + 2 ) // 2 NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int minDiff ( int n , int x , int A [ ] ) { int mn = A [ 0 ] , mx = A [ 0 ] ; for ( int i = 0 ; i < n ; ++ i ) { mn = Math . min ( mn , A [ i ] ) ; mx = Math . max ( mx , A [ i ] ) ; } return Math . max ( 0 , mx - mn - 2 * x ) ; }
Ref: 
def minDiff ( n , x , A ) : NEW_LINE INDENT mn = A [ 0 ] NEW_LINE mx = A [ 0 ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT mn = min ( mn , A [ i ] ) NEW_LINE mx = max ( mx , A [ i ] ) NEW_LINE DEDENT return max ( 0 , mx - mn - 2 * x ) NEW_LINE DEDENT
Hyp: 
def minDiff ( n , x , A ) : NEW_LINE INDENT mn = A [ 0 ] NEW_LINE mx = A [ 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT mn = min ( mn , A [ i ] ) NEW_LINE mx = max ( mx , A [ i ] ) NEW_LINE DEDENT return max ( 0 , mx - mn - 2 * x ) NEW_LINE DEDENT

BLEU: 95.43
Edit Sim: 4


Src: 
int numberOfTiles ( int n , int m ) { if ( n % 2 == 1 ) { return - 1 ; } return ( m * n ) / 2 ; }
Ref: 
def numberOfTiles ( N , M ) : NEW_LINE INDENT if ( N % 2 == 1 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return ( N * M ) // 2 NEW_LINE DEDENT
Hyp: 
def numberOfTiles ( n , m ) : NEW_LINE INDENT if n % 2 == 1 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return ( m * n ) // 2 NEW_LINE DEDENT

BLEU: 56.45
Edit Sim: 9


Src: 
int totalSumDivisibleByNum ( int digit , int number ) { int firstnum = ( int ) Math . pow ( 10 , digit - 1 ) ; int lastnum = ( int ) Math . pow ( 10 , digit ) ; firstnum = ( firstnum - firstnum % number ) + number ; lastnum = ( lastnum - lastnum % number ) ; int count = ( ( lastnum - firstnum ) / number + 1 ) ; return ( ( lastnum + firstnum ) * count ) / 2 ; }
Ref: 
def totalSumDivisibleByNum ( digit , number ) : NEW_LINE INDENT firstnum = pow ( 10 , digit - 1 ) NEW_LINE lastnum = pow ( 10 , digit ) NEW_LINE firstnum = ( firstnum - firstnum % number ) + number NEW_LINE lastnum = ( lastnum - lastnum % number ) NEW_LINE count = ( ( lastnum - firstnum ) / number + 1 ) NEW_LINE return int ( ( ( lastnum + firstnum ) * count ) / 2 ) NEW_LINE DEDENT
Hyp: 
def totalSumDivisibleByNum ( digit , number ) : NEW_LINE INDENT firstnum = pow ( 10 , digit - 1 ) NEW_LINE lastnum = pow ( 10 , digit ) NEW_LINE firstnum = ( firstnum - firstnum % number ) + number NEW_LINE lastnum = ( lastnum - lastnum % number ) NEW_LINE count = ( ( lastnum - firstnum ) // number + 1 ) NEW_LINE return ( ( lastnum + firstnum ) * count ) // 2 NEW_LINE DEDENT

BLEU: 87.68
Edit Sim: 10


Src: 
void findElements ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; for ( int i = 0 ; i < n - 2 ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; }
Ref: 
def findElements ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE for i in range ( 0 , n - 2 ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
Hyp: 
def findElements ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT print ( str ( arr [ i ] ) , end = " ▁ " ) NEW_LINE DEDENT DEDENT

BLEU: 79.97
Edit Sim: 13


Src: 
boolean adjacentSet ( int n ) { int x = ( n & ( n >> 1 ) ) ; if ( x > 0 ) return true ; else return false ; }
Ref: 
def adjacentSet ( n ) : NEW_LINE INDENT return ( n & ( n >> 1 ) ) NEW_LINE DEDENT
Hyp: 
def adjacentSet ( n ) : NEW_LINE INDENT x = ( n & ( n >> 1 ) ) NEW_LINE if ( x > 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT

BLEU: 41.68
Edit Sim: 117


Src: 
int Add ( int x , int y ) { while ( y != 0 ) { int carry = x & y ; x = x ^ y ; y = carry << 1 ; } return x ; }
Ref: 
def Add ( x , y ) : NEW_LINE INDENT while ( y != 0 ) : NEW_LINE INDENT carry = x & y NEW_LINE x = x ^ y NEW_LINE y = carry << 1 NEW_LINE DEDENT return x NEW_LINE DEDENT
Hyp: 
def Add ( x , y ) : NEW_LINE INDENT while ( y != 0 ) : NEW_LINE INDENT carry = x & y NEW_LINE x = x ^ y NEW_LINE y = carry << 1 NEW_LINE DEDENT return x NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
char ShortestPalindrome ( String s ) { int n = s . length ( ) ; char ans = s . charAt ( 0 ) ; for ( int i = 1 ; i < n ; i ++ ) { ans = ( char ) Math . min ( ans , s . charAt ( i ) ) ; } return ans ; }
Ref: 
def ShortestPalindrome ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE ans = s [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT ans = min ( ans , s [ i ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
Hyp: 
def ShortestPalindrome ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE ans = s [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT ans = min ( ans , s [ i ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
void permute ( String input ) { int n = input . length ( ) ; int max = 1 << n ; input = input . toLowerCase ( ) ; for ( int i = 0 ; i < max ; i ++ ) { char combination [ ] = input . toCharArray ( ) ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( ( i >> j ) & 1 ) == 1 ) combination [ j ] = ( char ) ( combination [ j ] - 32 ) ; } System . out . print ( combination ) ; System . out . print ( " ▁ " ) ; } }
Ref: 
def permute ( inp ) : NEW_LINE INDENT n = len ( inp ) NEW_LINE mx = 1 << n NEW_LINE inp = inp . lower ( ) NEW_LINE for i in range ( mx ) : NEW_LINE INDENT combination = [ k for k in inp ] NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( ( ( i >> j ) & 1 ) == 1 ) : NEW_LINE INDENT combination [ j ] = inp [ j ] . upper ( ) NEW_LINE DEDENT DEDENT temp = " " NEW_LINE for i in combination : NEW_LINE INDENT temp += i NEW_LINE DEDENT print temp , NEW_LINE DEDENT DEDENT
Hyp: 
def permute ( input ) : NEW_LINE INDENT n = len ( input ) NEW_LINE max = 1 << n NEW_LINE input = input . lower ( ) NEW_LINE for i in range ( max ) : NEW_LINE INDENT combination = [ ] NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( ( i >> j ) & 1 ) == 1 ) : NEW_LINE INDENT combination [ j ] = chr ( combination [ j ] - 32 ) NEW_LINE DEDENT DEDENT print ( combination ) NEW_LINE print ( " ▁ " ) NEW_LINE DEDENT DEDENT

BLEU: 56.11
Edit Sim: 116


Src: 
boolean isDiagonalMatrix ( int mat [ ] [ ] ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) if ( ( i != j ) && ( mat [ i ] [ j ] != 0 ) ) return false ; return true ; }
Ref: 
def isDiagonalMatrix ( mat ) : NEW_LINE INDENT for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( 0 , N ) : NEW_LINE INDENT if ( ( i != j ) and ( mat [ i ] [ j ] != 0 ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT mat = [ [ 4 , 0 , 0 , 0 ] , [ 0 , 7 , 0 , 0 ] , [ 0 , 0 , 5 , 0 ] , [ 0 , 0 , 0 , 1 ] ] NEW_LINE if ( isDiagonalMatrix ( mat ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
Hyp: 
def isDiagonalMatrix ( mat ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if ( ( i != j ) and ( mat [ i ] [ j ] != 0 ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT mat = [ [ 1 , 3 , 5 ] , [ 3 , 2 , 4 ] , [ 5 , 4 , 1 ] ] NEW_LINE if ( isDiagonalMatrix ( mat ) ) : NEW_LINE INDENT print " Yes " NEW_LINE DEDENT else : NEW_LINE INDENT print " No " NEW_LINE DEDENT

BLEU: 63.62
Edit Sim: 55


Src: 
int minNum ( int arr [ ] , int n ) { int odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 != 0 ) odd += 1 ; return ( ( odd % 2 ) != 0 ) ? 1 : 2 ; }
Ref: 
def minNum ( arr , n ) : NEW_LINE INDENT odd = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 ) : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT DEDENT if ( odd % 2 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 2 NEW_LINE DEDENT
Hyp: 
def minNum ( arr , n ) : NEW_LINE INDENT odd = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 != 0 ) : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT DEDENT return ( odd % 2 ) ? 1 : 2 NEW_LINE DEDENT

BLEU: 78.0
Edit Sim: 57


Src: 
long answer ( int n ) { int dp [ ] [ ] = new int [ n + 1 ] [ 10 ] ; if ( n == 1 ) return 10 ; for ( int j = 0 ; j <= 9 ; j ++ ) dp [ 1 ] [ j ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= 9 ; j ++ ) { if ( j == 0 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] ; else if ( j == 9 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] ; } } long sum = 0 ; for ( int j = 1 ; j <= 9 ; j ++ ) sum += dp [ n ] [ j ] ; return sum ; }
Ref: 
def answer ( n ) : NEW_LINE INDENT dp = [ [ 0 for x in range ( 10 ) ] for y in range ( n + 1 ) ] ; NEW_LINE if ( n == 1 ) : NEW_LINE INDENT return 10 ; NEW_LINE DEDENT for j in range ( 10 ) : NEW_LINE INDENT dp [ 1 ] [ j ] = 1 ; NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT for j in range ( 10 ) : NEW_LINE INDENT if ( j == 0 ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] ; NEW_LINE DEDENT elif ( j == 9 ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ; NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] ) ; NEW_LINE DEDENT DEDENT DEDENT sum = 0 ; NEW_LINE for j in range ( 1 , 10 ) : NEW_LINE INDENT sum = sum + dp [ n ] [ j ] ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT
Hyp: 
def answer ( n ) : NEW_LINE INDENT dp = [ [ 0 for j in range ( 9 + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE if ( n == 1 ) : NEW_LINE INDENT return 10 NEW_LINE DEDENT for j in range ( 9 + 1 ) : NEW_LINE INDENT dp [ 1 ] [ j ] = 1 NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT for j in range ( 0 , 9 + 1 ) : NEW_LINE INDENT if ( j == 0 ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] NEW_LINE DEDENT elif ( j == 9 ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] NEW_LINE DEDENT DEDENT DEDENT sum = 0 NEW_LINE for j in range ( 1 , 9 + 1 ) : NEW_LINE INDENT sum = sum + dp [ n ] [ j ] NEW_LINE DEDENT return sum NEW_LINE DEDENT

BLEU: 72.53
Edit Sim: 127


Src: 
int countAPs ( int S , int D ) { S = S * 2 ; int answer = 0 ; for ( int i = 1 ; i <= Math . sqrt ( S ) ; i ++ ) { if ( S % i == 0 ) { if ( ( ( S / i ) - D * i + D ) % 2 == 0 ) answer ++ ; if ( ( D * i - ( S / i ) + D ) % 2 == 0 ) answer ++ ; } } return answer ; }
Ref: 
def countAPs ( S , D ) : NEW_LINE INDENT S = S * 2 NEW_LINE answer = 0 NEW_LINE for i in range ( 1 , S ) : NEW_LINE INDENT if i * i > S : NEW_LINE INDENT break NEW_LINE DEDENT if ( S % i == 0 ) : NEW_LINE INDENT if ( ( ( S // i ) - D * i + D ) % 2 == 0 ) : NEW_LINE INDENT answer += 1 NEW_LINE DEDENT if ( ( D * i - ( S // i ) + D ) % 2 == 0 ) : NEW_LINE INDENT answer += 1 NEW_LINE DEDENT DEDENT DEDENT return answer NEW_LINE DEDENT
Hyp: 
def countAPs ( S , D ) : NEW_LINE INDENT S = S * 2 NEW_LINE answer = 0 NEW_LINE for i in range ( 1 , int ( sqrt ( S ) ) + 1 ) : NEW_LINE INDENT if ( S % i == 0 ) : NEW_LINE INDENT if ( ( ( S // i ) - D * i + D ) % 2 == 0 ) : NEW_LINE INDENT answer += 1 NEW_LINE DEDENT if ( ( D * i - ( S // i ) + D ) % 2 == 0 ) : NEW_LINE INDENT answer += 1 NEW_LINE DEDENT DEDENT DEDENT return answer NEW_LINE DEDENT

BLEU: 87.25
Edit Sim: 47


Src: 
void findNumbers ( int n , int b ) { double even = 0 , odd = 0 ; if ( b % 2 == 0 ) { even = Math . pow ( b , n ) - 2 ; odd = Math . pow ( b , n ) - 1 ; } else { even = Math . pow ( b , n ) - 1 ; odd = Math . pow ( b , n ) - 2 ; } System . out . println ( " Even ▁ Number ▁ = ▁ " + ( int ) even ) ; System . out . print ( " Odd ▁ Number ▁ = ▁ " + ( int ) odd ) ; }
Ref: 
def findNumbers ( n , b ) : NEW_LINE INDENT even = 0 ; NEW_LINE odd = 0 ; NEW_LINE if ( b % 2 == 0 ) : NEW_LINE INDENT even = pow ( b , n ) - 2 ; NEW_LINE odd = pow ( b , n ) - 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT even = pow ( b , n ) - 1 ; NEW_LINE odd = pow ( b , n ) - 2 ; NEW_LINE DEDENT print ( " Even ▁ Number ▁ = ▁ " , int ( even ) ) ; NEW_LINE print ( " Odd ▁ Number ▁ = ▁ " , int ( odd ) ) ; NEW_LINE DEDENT
Hyp: 
def findNumbers ( n , b ) : NEW_LINE INDENT even = 0 NEW_LINE odd = 0 NEW_LINE if b % 2 == 0 : NEW_LINE INDENT even = pow ( b , n ) - 2 NEW_LINE odd = pow ( b , n ) - 1 NEW_LINE DEDENT else : NEW_LINE INDENT even = pow ( b , n ) - 1 NEW_LINE odd = pow ( b , n ) - 2 NEW_LINE DEDENT print ( " Even ▁ Number ▁ = " , even ) NEW_LINE print ( " Odd ▁ Number ▁ = " , odd ) NEW_LINE DEDENT

BLEU: 67.21
Edit Sim: 40


Src: 
int countTriplets ( int N ) { int cnt = 0 ; for ( int A = 1 ; A <= N ; ++ A ) { for ( int B = 1 ; B <= N / A ; ++ B ) { cnt += N / ( A * B ) ; } } return cnt ; }
Ref: 
def countTriplets ( N ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE for A in range ( 1 , N + 1 ) : NEW_LINE INDENT for B in range ( 1 , N // A + 1 ) : NEW_LINE INDENT cnt += N // ( A * B ) ; NEW_LINE DEDENT DEDENT return cnt ; NEW_LINE DEDENT
Hyp: 
def countTriplets ( N ) : NEW_LINE INDENT cnt = 0 NEW_LINE for A in range ( 1 , N + 1 ) : NEW_LINE INDENT for B in range ( 1 , N // A + 1 ) : NEW_LINE INDENT cnt += N // ( A * B ) NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT

BLEU: 87.69
Edit Sim: 6


Src: 
int findAns ( int [ ] [ ] mat , int x , int y , int n , int m ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( mat [ i ] [ j ] == 1 ) { ans += Math . abs ( x - i ) + Math . abs ( y - j ) ; } } } return ans ; }
Ref: 
def findAns ( mat , x , y , n , m ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( mat [ i ] [ j ] == 1 ) : NEW_LINE INDENT ans += ( abs ( x - i ) + abs ( y - j ) ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
Hyp: 
def findAns ( mat , x , y , n , m ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( mat [ i ] [ j ] == 1 ) : NEW_LINE INDENT ans += abs ( x - i ) + abs ( y - j ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT

BLEU: 94.57
Edit Sim: 4


Src: 
int distinctRemainders ( int n ) { if ( n % 2 == 0 ) return ( n / 2 ) ; return ( 1 + ( n / 2 ) ) ; }
Ref: 
def distinctRemainders ( n ) : NEW_LINE INDENT if n % 2 == 0 : NEW_LINE INDENT return n // 2 NEW_LINE DEDENT return ( ( n // 2 ) + 1 ) NEW_LINE DEDENT
Hyp: 
def distinctRemainders ( n ) : NEW_LINE INDENT if n % 2 == 0 : NEW_LINE INDENT return ( n // 2 ) NEW_LINE DEDENT return ( 1 + ( n // 2 ) ) NEW_LINE DEDENT

BLEU: 72.0
Edit Sim: 12


Src: 
int phi ( int n ) { float result = n ; for ( int p = 2 ; p * p <= n ; ++ p ) { if ( n % p == 0 ) { while ( n % p == 0 ) n /= p ; result *= ( 1.0 - ( 1.0 / ( float ) p ) ) ; } } if ( n > 1 ) result *= ( 1.0 - ( 1.0 / ( float ) n ) ) ; return ( int ) result ; }
Ref: 
def phi ( n ) : NEW_LINE INDENT p = 2 NEW_LINE while p * p <= n : NEW_LINE INDENT if n % p == 0 : NEW_LINE INDENT while n % p == 0 : NEW_LINE INDENT n = n // p NEW_LINE DEDENT result = result * ( 1.0 - ( 1.0 / float ( p ) ) ) NEW_LINE DEDENT p = p + 1 NEW_LINE DEDENT if n > 1 : NEW_LINE INDENT result = result * ( 1.0 - ( 1.0 / float ( n ) ) ) NEW_LINE DEDENT return int ( result ) NEW_LINE DEDENT for n in range ( 1 , 11 ) : NEW_LINE INDENT print ( " phi ( " , n , " ) ▁ = ▁ " , phi ( n ) ) NEW_LINE DEDENT
Hyp: 
def phi ( n ) : NEW_LINE INDENT result = n NEW_LINE for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( n % p == 0 ) : NEW_LINE INDENT while ( n % p == 0 ) : NEW_LINE INDENT n //= p NEW_LINE DEDENT result *= ( 1.0 - ( 1.0 / p ) ) NEW_LINE DEDENT DEDENT if ( n > 1 ) : NEW_LINE INDENT result *= ( 1.0 - ( 1.0 / n ) ) NEW_LINE DEDENT return math . floor ( result ) NEW_LINE DEDENT

BLEU: 36.28
Edit Sim: 216


Src: 
int countIntervals ( int [ ] [ ] arr , int V , int N ) { int min = Integer . MAX_VALUE , max = Integer . MIN_VALUE ; int li , ri ; int [ ] freq = new int [ MAX_VAL ] ; for ( int i = 0 ; i < N ; i ++ ) { li = arr [ i ] [ 0 ] ; freq [ li ] = freq [ li ] + 1 ; ri = arr [ i ] [ 1 ] ; freq [ ri + 1 ] = freq [ ri + 1 ] - 1 ; if ( li < min ) min = li ; if ( ri > max ) max = ri ; } for ( int i = min ; i <= max ; i ++ ) freq [ i ] = freq [ i ] + freq [ i - 1 ] ; return freq [ V ] ; }
Ref: 
def countIntervals ( arr , V , N ) : NEW_LINE INDENT minimum = float ( " inf " ) NEW_LINE maximum = 0 NEW_LINE freq = [ 0 ] * ( MAX_VAL ) NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT li = arr [ i ] [ 0 ] NEW_LINE freq [ li ] = freq [ li ] + 1 NEW_LINE ri = arr [ i ] [ 1 ] NEW_LINE freq [ ri + 1 ] = freq [ ri + 1 ] - 1 NEW_LINE if li < minimum : NEW_LINE INDENT minimum = li NEW_LINE DEDENT if ri > maximum : NEW_LINE INDENT maximum = ri NEW_LINE DEDENT DEDENT for i in range ( minimum , maximum + 1 ) : NEW_LINE INDENT freq [ i ] = freq [ i ] + freq [ i - 1 ] NEW_LINE DEDENT return freq [ V ] NEW_LINE DEDENT
Hyp: 
def countIntervals ( arr , V , N ) : NEW_LINE INDENT min , max = INT_MAX , INT_MIN NEW_LINE freq = [ 0 ] * MAX_VAL NEW_LINE for i in range ( N ) : NEW_LINE INDENT li = arr [ i ] [ 0 ] NEW_LINE freq [ li ] = freq [ li ] + 1 NEW_LINE ri = arr [ i ] [ 1 ] NEW_LINE freq [ ri + 1 ] = freq [ ri + 1 ] - 1 NEW_LINE if ( li < min ) : NEW_LINE INDENT min = li NEW_LINE DEDENT if ( ri > max ) : NEW_LINE INDENT max = ri NEW_LINE DEDENT DEDENT for i in range ( min , max + 1 ) : NEW_LINE INDENT freq [ i ] = freq [ i ] + freq [ i - 1 ] NEW_LINE DEDENT return freq [ V ] NEW_LINE DEDENT

BLEU: 76.41
Edit Sim: 71


Src: 
int findSum ( String str ) { String temp = "0" ; int sum = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char ch = str . charAt ( i ) ; if ( Character . isDigit ( ch ) ) temp += ch ; else { sum += Integer . parseInt ( temp ) ; temp = "0" ; } } return sum + Integer . parseInt ( temp ) ; }
Ref: 
def findSum ( str1 ) : NEW_LINE INDENT temp = "0" NEW_LINE Sum = 0 NEW_LINE for ch in str1 : NEW_LINE INDENT if ( ch . isdigit ( ) ) : NEW_LINE INDENT temp += ch NEW_LINE DEDENT else : NEW_LINE INDENT Sum += int ( temp ) NEW_LINE temp = "0" NEW_LINE DEDENT DEDENT return Sum + int ( temp ) NEW_LINE DEDENT
Hyp: 
def findSum ( str ) : NEW_LINE INDENT temp = "0" NEW_LINE sum = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT ch = str [ i ] NEW_LINE if ( Character . isDigit ( ch ) ) : NEW_LINE INDENT temp += ch NEW_LINE DEDENT else : NEW_LINE INDENT sum += int ( temp ) NEW_LINE temp = "0" NEW_LINE DEDENT DEDENT return sum + int ( temp ) NEW_LINE DEDENT

BLEU: 55.47
Edit Sim: 60


Src: 
void kthpair ( int n , int k , int arr [ ] ) { int i , t = 0 ; Arrays . sort ( arr ) ; -- k ; for ( i = 0 ; i < n ; i += t ) { for ( t = 1 ; arr [ i ] == arr [ i + t ] ; ++ t ) ; if ( t * n > k ) break ; k = k - t * n ; } System . out . print ( arr [ i ] + " ▁ " + arr [ k / t ] ) ; }
Ref: 
def kthpair ( n , k , arr ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE k -= 1 NEW_LINE i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT t = 1 NEW_LINE while ( arr [ i ] == arr [ i + t ] ) : NEW_LINE INDENT t += 1 NEW_LINE DEDENT if ( t * n > k ) : NEW_LINE INDENT break NEW_LINE DEDENT k = k - t * n NEW_LINE i += t NEW_LINE DEDENT print ( arr [ i ] , " ▁ " , arr [ k // t ] ) NEW_LINE DEDENT
Hyp: 
def kthpair ( n , k , arr ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE -- k NEW_LINE for i in range ( n ) : NEW_LINE INDENT t = 0 NEW_LINE while ( 1 , arr [ i ] == arr [ i + t ] ) : NEW_LINE INDENT t += 1 NEW_LINE DEDENT if ( t * n > k ) : NEW_LINE INDENT break NEW_LINE DEDENT k = k - t * n NEW_LINE DEDENT print ( arr [ i ] , arr [ k // t ] ) NEW_LINE DEDENT

BLEU: 77.24
Edit Sim: 53


Src: 
void form_sieve ( ) { sieve_Prime [ 1 ] = 1 ; for ( int i = 2 ; i <= MAX ; i ++ ) { if ( sieve_Prime [ i ] == 0 ) { for ( int j = i * 2 ; j <= MAX ; j += i ) { if ( sieve_Prime [ j ] == 0 ) { sieve_Prime [ j ] = 1 ; sieve_count [ i ] ++ ; } } } } }
Ref: 
def form_sieve ( ) : NEW_LINE INDENT sieve_Prime [ 1 ] = 1 NEW_LINE for i in range ( 2 , MAX + 1 ) : NEW_LINE INDENT if sieve_Prime [ i ] == 0 : NEW_LINE INDENT for j in range ( i * 2 , MAX + 1 , i ) : NEW_LINE INDENT if sieve_Prime [ j ] == 0 : NEW_LINE INDENT sieve_Prime [ j ] = 1 NEW_LINE sieve_count [ i ] += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT
Hyp: 
def form_sieve ( ) : NEW_LINE INDENT sieve_Prime [ 1 ] = 1 NEW_LINE for i in range ( 2 , MAX + 1 ) : NEW_LINE INDENT if ( sieve_Prime [ i ] == 0 ) : NEW_LINE INDENT for j in range ( i * 2 , MAX + 1 ) : NEW_LINE INDENT if ( sieve_Prime [ j ] == 0 ) : NEW_LINE INDENT sieve_Prime [ j ] = 1 NEW_LINE sieve_count [ i ] += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT

BLEU: 86.2
Edit Sim: 19


Src: 
void printMinDiffPairs ( int arr [ ] , int n ) { if ( n <= 1 ) return ; Arrays . sort ( arr ) ; int minDiff = arr [ 1 ] - arr [ 0 ] ; for ( int i = 2 ; i < n ; i ++ ) minDiff = Math . min ( minDiff , arr [ i ] - arr [ i - 1 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { if ( ( arr [ i ] - arr [ i - 1 ] ) == minDiff ) { System . out . print ( " ( " + arr [ i - 1 ] + " , ▁ " + arr [ i ] + " ) , " ) ; } } }
Ref: 
def printMinDiffPairs ( arr , n ) : NEW_LINE INDENT if n <= 1 : return NEW_LINE arr . sort ( ) NEW_LINE minDiff = arr [ 1 ] - arr [ 0 ] NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT minDiff = min ( minDiff , arr [ i ] - arr [ i - 1 ] ) NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] - arr [ i - 1 ] ) == minDiff : NEW_LINE INDENT print ( " ( " + str ( arr [ i - 1 ] ) + " , ▁ " + str ( arr [ i ] ) + " ) , ▁ " , end = ' ' ) NEW_LINE DEDENT DEDENT DEDENT
Hyp: 
def printMinDiffPairs ( arr , n ) : NEW_LINE INDENT if ( n <= 1 ) : return arr . sort ( ) NEW_LINE minDiff = arr [ 1 ] - arr [ 0 ] NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT minDiff = min ( minDiff , arr [ i ] - arr [ i - 1 ] ) NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( ( arr [ i ] - arr [ i - 1 ] ) == minDiff ) : NEW_LINE INDENT print ( " ( " , arr [ i - 1 ] , " , ▁ " , arr [ i ] , " ) , " ) NEW_LINE DEDENT DEDENT DEDENT

BLEU: 78.27
Edit Sim: 51


Src: 
int lenghtOfLongestAP ( int A [ ] , int n ) { Map < Integer , Map < Integer , Integer > > dp = new HashMap < Integer , Map < Integer , Integer > > ( ) ; int res = 2 ; for ( int i = 0 ; i < n ; ++ i ) { for ( int j = i + 1 ; j < n ; ++ j ) { int d = A [ j ] - A [ i ] ; Map < Integer , Integer > temp ; if ( dp . containsKey ( d ) ) { temp = dp . get ( d ) ; if ( temp . containsKey ( i ) ) temp . put ( j , temp . get ( i ) + 1 ) ; else temp . put ( j , 2 ) ; } else { temp = new HashMap < Integer , Integer > ( ) ; temp . put ( j , 2 ) ; } dp . put ( d , temp ) ; res = Math . max ( res , temp . get ( j ) ) ; } } return res ; }
Ref: 
def lenghtOfLongestAP ( A , n ) : NEW_LINE INDENT dp = { } NEW_LINE res = 2 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT d = A [ j ] - A [ i ] NEW_LINE if d in dp : NEW_LINE INDENT if i in dp [ d ] : NEW_LINE INDENT dp [ d ] [ j ] = dp [ d ] [ i ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ d ] [ j ] = 2 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT dp [ d ] = { } NEW_LINE dp [ d ] [ j ] = 2 NEW_LINE DEDENT if d in dp : NEW_LINE INDENT if j in dp [ d ] : NEW_LINE INDENT res = max ( res , dp [ d ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return res NEW_LINE DEDENT
Hyp: 
def lenghtOfLongestAP ( A , n ) : NEW_LINE INDENT dp = defaultdict ( int ) NEW_LINE res = 2 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT d = A [ j ] - A [ i ] NEW_LINE temp = { } NEW_LINE if d in dp : NEW_LINE INDENT temp = dp [ d ] NEW_LINE if temp [ i ] : NEW_LINE INDENT temp [ j ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT temp [ j ] = 2 NEW_LINE DEDENT DEDENT dp [ d ] = temp NEW_LINE res = max ( res , temp [ j ] ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT

BLEU: 55.39
Edit Sim: 190


Src: 
int minTime ( int arr [ ] , int n ) { if ( n <= 0 ) return 0 ; int incl = arr [ 0 ] ; int excl = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int incl_new = arr [ i ] + Math . min ( excl , incl ) ; int excl_new = incl ; incl = incl_new ; excl = excl_new ; } return Math . min ( incl , excl ) ; }
Ref: 
def minTime ( arr , n ) : NEW_LINE INDENT if ( n <= 0 ) : return 0 NEW_LINE DEDENT incl = arr [ 0 ] NEW_LINE excl = 0 NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT incl_new = arr [ i ] + min ( excl , incl ) NEW_LINE excl_new = incl NEW_LINE incl = incl_new NEW_LINE excl = excl_new NEW_LINE DEDENT return min ( incl , excl ) NEW_LINE DEDENT
Hyp: 
def minTime ( arr , n ) : NEW_LINE INDENT if ( n <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT incl = arr [ 0 ] NEW_LINE excl = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT incl_new = arr [ i ] + min ( excl , incl ) NEW_LINE excl_new = incl NEW_LINE incl = incl_new NEW_LINE excl = excl_new NEW_LINE DEDENT return min ( incl , excl ) NEW_LINE DEDENT

BLEU: 94.37
Edit Sim: 23


Src: 
int findCount ( int arr [ ] , int n ) { int countOdd = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 == 1 ) countOdd ++ ; if ( countOdd % 2 == 0 ) return 1 ; else return 0 ; }
Ref: 
def findCount ( arr , n ) : NEW_LINE INDENT countOdd = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 1 ) : NEW_LINE INDENT countOdd += 1 ; NEW_LINE DEDENT DEDENT if ( countOdd % 2 == 0 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT DEDENT
Hyp: 
def findCount ( arr , n ) : NEW_LINE INDENT countOdd = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 1 ) : NEW_LINE INDENT countOdd += 1 NEW_LINE DEDENT DEDENT if ( countOdd % 2 == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT

BLEU: 85.56
Edit Sim: 8


Src: 
int power ( int x , int y ) { int res = 1 ; while ( y > 0 ) { if ( ( y & 1 ) != 0 ) res = res * x ; y = y >> 1 ; x = x * x ; } return res ; }
Ref: 
def power ( x , y ) : NEW_LINE INDENT res = 1 NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( ( y & 1 ) != 0 ) : NEW_LINE INDENT res = res * x NEW_LINE DEDENT DEDENT DEDENT y = y >> 1 NEW_LINE x = x * x NEW_LINE INDENT return res NEW_LINE DEDENT
Hyp: 
def power ( x , y ) : NEW_LINE INDENT res = 1 NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = res * x NEW_LINE DEDENT y = y >> 1 NEW_LINE x = x * x NEW_LINE DEDENT return res NEW_LINE DEDENT

BLEU: 82.18
Edit Sim: 25


Src: 
void findTriangle ( long S ) { long X1 = 0 , Y1 = 0 ; long X2 = MAX , Y2 = 1 ; long X3 = ( MAX - S % MAX ) % MAX ; long Y3 = ( S + X3 ) / MAX ; System . out . println ( " ( " + X1 + " , ▁ " + Y1 + " ) " ) ; System . out . println ( " ( " + X2 + " , ▁ " + Y2 + " ) " ) ; System . out . println ( " ( " + X3 + " , ▁ " + Y3 + " ) " ) ; }
Ref: 
def findTriangle ( S ) : NEW_LINE INDENT X1 = 0 ; Y1 = 0 ; NEW_LINE X2 = MAX ; Y2 = 1 ; NEW_LINE X3 = ( MAX - S % MAX ) % MAX ; NEW_LINE Y3 = ( S + X3 ) / MAX ; NEW_LINE print ( " ( " , X1 , " , " , Y1 , " ) " ) ; NEW_LINE print ( " ( " , X2 , " , " , Y2 , " ) " ) ; NEW_LINE print ( " ( " , X3 , " , " , Y3 , " ) " ) ; NEW_LINE DEDENT
Hyp: 
def findTriangle ( S ) : NEW_LINE INDENT X1 = 0 NEW_LINE Y1 = 0 NEW_LINE X2 = MAX NEW_LINE Y2 = 1 NEW_LINE X3 = ( MAX - S % MAX ) % MAX NEW_LINE Y3 = ( S + X3 ) // MAX NEW_LINE print ( " ( " , X1 , " , ▁ " , Y1 , " ) " ) NEW_LINE print ( " ( " , X2 , " , ▁ " , Y2 , " ) " ) NEW_LINE print ( " ( " , X3 , " , ▁ " , Y3 , " ) " ) NEW_LINE DEDENT

BLEU: 73.0
Edit Sim: 37


Src: 
boolean isScalarMatrix ( int mat [ ] [ ] ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) if ( ( i != j ) && ( mat [ i ] [ j ] != 0 ) ) return false ; for ( int i = 0 ; i < N - 1 ; i ++ ) if ( mat [ i ] [ i ] != mat [ i + 1 ] [ i + 1 ] ) return false ; return true ; }
Ref: 
def isScalarMatrix ( mat ) : NEW_LINE INDENT for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( 0 , N ) : NEW_LINE INDENT if ( ( i != j ) and ( mat [ i ] [ j ] != 0 ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT for i in range ( 0 , N - 1 ) : NEW_LINE INDENT if ( mat [ i ] [ i ] != mat [ i + 1 ] [ i + 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT mat = [ [ 2 , 0 , 0 , 0 ] , [ 0 , 2 , 0 , 0 ] , [ 0 , 0 , 2 , 0 ] , [ 0 , 0 , 0 , 2 ] ] NEW_LINE if ( isScalarMatrix ( mat ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
Hyp: 
def isScalarMatrix ( mat ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if ( ( i != j ) and ( mat [ i ] [ j ] != 0 ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT for i in range ( N - 1 ) : NEW_LINE INDENT if ( mat [ i ] [ i ] != mat [ i + 1 ] [ i + 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT mat = [ [ 1 , 3 , 5 ] , [ 3 , 2 , 4 ] ] NEW_LINE if ( isScalarMatrix ( mat ) ) : NEW_LINE INDENT print " Yes " NEW_LINE DEDENT else : NEW_LINE INDENT print " No " NEW_LINE DEDENT

BLEU: 67.08
Edit Sim: 80


Src: 
int countElements ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; float mean = ( float ) sum / n ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { float newMean = ( float ) ( sum - arr [ i ] ) / ( n - 1 ) ; if ( newMean == mean ) cnt ++ ; } return cnt ; }
Ref: 
def countElements ( arr , n ) : NEW_LINE INDENT Sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT Sum += arr [ i ] NEW_LINE DEDENT mean = Sum / n NEW_LINE cnt = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT newMean = ( Sum - arr [ i ] ) / ( n - 1 ) NEW_LINE if ( newMean == mean ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT
Hyp: 
def countElements ( arr , n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] ; NEW_LINE DEDENT mean = sum / n ; NEW_LINE cnt = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT newMean = ( sum - arr [ i ] ) / ( n - 1 ) ; NEW_LINE if ( newMean == mean ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT DEDENT return cnt ; NEW_LINE DEDENT

BLEU: 70.49
Edit Sim: 18


Src: 
int findArea ( Integer arr [ ] , int n ) { Arrays . sort ( arr , Collections . reverseOrder ( ) ) ; int [ ] dimension = { 0 , 0 } ; for ( int i = 0 , j = 0 ; i < n - 1 && j < 2 ; i ++ ) if ( arr [ i ] == arr [ i + 1 ] ) dimension [ j ++ ] = arr [ i ++ ] ; return ( dimension [ 0 ] * dimension [ 1 ] ) ; }
Ref: 
def findArea ( arr , n ) : NEW_LINE INDENT arr . sort ( reverse = True ) NEW_LINE dimension = [ 0 , 0 ] NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE while ( i < n - 1 and j < 2 ) : NEW_LINE INDENT if ( arr [ i ] == arr [ i + 1 ] ) : NEW_LINE INDENT dimension [ j ] = arr [ i ] NEW_LINE j += 1 NEW_LINE i += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return ( dimension [ 0 ] * dimension [ 1 ] ) NEW_LINE DEDENT
Hyp: 
def findArea ( arr , n ) : NEW_LINE INDENT arr . sort ( reverse = True ) NEW_LINE dimension = [ 0 , 0 ] NEW_LINE for i in range ( n - 1 and j < 2 ) : NEW_LINE INDENT if ( arr [ i ] == arr [ i + 1 ] ) : NEW_LINE INDENT dimension [ j ] = arr [ i ] NEW_LINE DEDENT DEDENT return ( dimension [ 0 ] * dimension [ 1 ] ) NEW_LINE DEDENT

BLEU: 72.56
Edit Sim: 83


Src: 
int countRotation ( int [ ] arr , int n ) { for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ i - 1 ] ) { return i ; } } return 0 ; }
Ref: 
def countRotation ( arr , n ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] < arr [ i - 1 ] ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT
Hyp: 
def countRotation ( arr , n ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] < arr [ i - 1 ] ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int minOperations ( String str , int n ) { int count = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( str . charAt ( i ) != str . charAt ( i + 1 ) ) count ++ ; } return ( count + 1 ) / 2 ; }
Ref: 
def minOperations ( str , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( str [ i ] != str [ i + 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return ( count + 1 ) // 2 NEW_LINE DEDENT
Hyp: 
def minOperations ( str , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( str [ i ] != str [ i + 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return ( count + 1 ) // 2 NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
double Circumradius ( int a , int b , int c , int d ) { double s = ( a + b + c + d ) / 2.0 ; double radius = Math . sqrt ( ( ( a * b ) + ( c * d ) ) * ( ( a * c ) + ( b * d ) ) * ( ( a * d ) + ( b * c ) ) / ( ( s - a ) * ( s - b ) * ( s - c ) * ( s - d ) ) ) ; return radius / 4 ; }
Ref: 
def Circumradius ( a , b , c , d ) : NEW_LINE INDENT s = ( a + b + c + d ) / 2 NEW_LINE radius = ( 1 / 4 ) * math . sqrt ( ( ( a * b ) + ( c * d ) ) * ( ( a * c ) + ( b * d ) ) * ( ( a * d ) + ( b * c ) ) / ( ( s - a ) * ( s - b ) * ( s - c ) * ( s - d ) ) ) NEW_LINE return radius NEW_LINE DEDENT
Hyp: 
def Circumradius ( a , b , c , d ) : NEW_LINE INDENT s = ( a + b + c + d ) / 2.0 NEW_LINE radius = math . sqrt ( ( ( a * b ) + ( c * d ) ) * ( ( a * c ) + ( b * d ) ) / ( ( s - a ) * ( s - b ) * ( s - c ) * ( s - d ) ) ) NEW_LINE return radius // 4 NEW_LINE DEDENT

BLEU: 76.28
Edit Sim: 47


Src: 
int countDivisibleSubseq ( String str , int n ) { int len = str . length ( ) ; int dp [ ] [ ] = new int [ len ] [ n ] ; dp [ 0 ] [ ( str . charAt ( 0 ) - '0' ) % n ] ++ ; for ( int i = 1 ; i < len ; i ++ ) { dp [ i ] [ ( str . charAt ( i ) - '0' ) % n ] ++ ; for ( int j = 0 ; j < n ; j ++ ) { dp [ i ] [ j ] += dp [ i - 1 ] [ j ] ; dp [ i ] [ ( j * 10 + ( str . charAt ( i ) - '0' ) ) % n ] += dp [ i - 1 ] [ j ] ; } } return dp [ len - 1 ] [ 0 ] ; }
Ref: 
def countDivisibleSubseq ( str , n ) : NEW_LINE INDENT l = len ( str ) NEW_LINE dp = [ [ 0 for x in range ( l ) ] for y in range ( n ) ] NEW_LINE dp [ 0 ] [ ( ord ( str [ 0 ] ) - ord ( '0' ) ) % n ] += 1 NEW_LINE for i in range ( 1 , l ) : NEW_LINE INDENT dp [ i ] [ ( ord ( str [ i ] ) - ord ( '0' ) ) % n ] += 1 NEW_LINE for j in range ( n ) : NEW_LINE INDENT dp [ i ] [ j ] += dp [ i - 1 ] [ j ] NEW_LINE dp [ i ] [ ( j * 10 + ( ord ( str [ i ] ) - ord ( '0' ) ) ) % n ] += dp [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT return dp [ l - 1 ] [ 0 ] NEW_LINE DEDENT
Hyp: 
def countDivisibleSubseq ( s , n ) : NEW_LINE INDENT l = len ( s ) NEW_LINE dp = [ [ 0 for x in range ( n ) ] for y in range ( l ) ] NEW_LINE for i in range ( 1 , l ) : NEW_LINE INDENT dp [ 0 ] [ ( ord ( s [ 0 ] ) - ord ( '0' ) % n ] += 1 NEW_LINE DEDENT for i in range ( 1 , l ) : NEW_LINE INDENT dp [ i ] [ ( ord ( s [ i ] ) - ord ( '0' ) % n ] += 1 NEW_LINE for j in range ( n ) : NEW_LINE INDENT dp [ i ] [ j ] += dp [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT return dp [ len - 1 ] [ 0 ] NEW_LINE DEDENT

BLEU: 67.67
Edit Sim: 163


Src: 
int myXOR ( int x , int y ) { return ( x y ) & ( ~ x ~ y ) ; }
Ref: 
def myXOR ( x , y ) : NEW_LINE INDENT return ( ( x y ) & ( ~ x ~ y ) ) NEW_LINE DEDENT
Hyp: 
def myXOR ( x , y ) : NEW_LINE INDENT return ( x y ) & ( ~ x ~ y ) NEW_LINE DEDENT

BLEU: 85.54
Edit Sim: 4


Src: 
int LCSubStr ( String s , String t , int n , int m ) { int dp [ ] [ ] = new int [ 2 ] [ m + 1 ] ; int res = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { if ( s . charAt ( i - 1 ) == t . charAt ( j - 1 ) ) { dp [ i % 2 ] [ j ] = dp [ ( i - 1 ) % 2 ] [ j - 1 ] + 1 ; if ( dp [ i % 2 ] [ j ] > res ) res = dp [ i % 2 ] [ j ] ; } else dp [ i % 2 ] [ j ] = 0 ; } } return res ; }
Ref: 
def LCSubStr ( s , t , n , m ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( m + 1 ) ] for j in range ( 2 ) ] NEW_LINE res = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , m + 1 ) : NEW_LINE INDENT if ( s [ i - 1 ] == t [ j - 1 ] ) : NEW_LINE INDENT dp [ i % 2 ] [ j ] = dp [ ( i - 1 ) % 2 ] [ j - 1 ] + 1 NEW_LINE if ( dp [ i % 2 ] [ j ] > res ) : NEW_LINE INDENT res = dp [ i % 2 ] [ j ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT dp [ i % 2 ] [ j ] = 0 NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT
Hyp: 
def LCSubStr ( s , t , n , m ) : NEW_LINE INDENT dp = [ [ 0 for x in range ( m + 1 ) ] for y in range ( 3 ) ] NEW_LINE res = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , m + 1 ) : NEW_LINE INDENT if ( s [ i - 1 ] == t [ j - 1 ] ) : NEW_LINE INDENT dp [ i % 2 ] [ j ] = dp [ ( i - 1 ) % 2 ] [ j - 1 ] + 1 ) NEW_LINE if ( dp [ i % 2 ] [ j ] > res ) : NEW_LINE INDENT res = dp [ i % 2 ] [ j ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT dp [ i % 2 ] [ j ] = 0 NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT

BLEU: 94.11
Edit Sim: 5


Src: 
int nthTerm ( int n ) { return 2 * ( int ) Math . pow ( n , 2 ) + n - 3 ; }
Ref: 
def nthTerm ( n ) : NEW_LINE INDENT return 2 * pow ( n , 2 ) + n - 3 NEW_LINE DEDENT
Hyp: 
def nthTerm ( n ) : NEW_LINE INDENT return 2 * pow ( n , 2 ) + n - 3 NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
void max_area ( int n , int m , int k ) { if ( k > ( n + m - 2 ) ) System . out . println ( " Not ▁ possible " ) ; else { int result ; if ( k < Math . max ( m , n ) - 1 ) { result = Math . max ( m * ( n / ( k + 1 ) ) , n * ( m / ( k + 1 ) ) ) ; } else { result = Math . max ( m / ( k - n + 2 ) , n / ( k - m + 2 ) ) ; } System . out . println ( result ) ; } }
Ref: 
def max_area ( n , m , k ) : NEW_LINE INDENT if ( k > ( n + m - 2 ) ) : NEW_LINE INDENT print ( " Not ▁ possible " ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( k < max ( m , n ) - 1 ) : NEW_LINE INDENT result = max ( m * ( n / ( k + 1 ) ) , n * ( m / ( k + 1 ) ) ) ; NEW_LINE DEDENT else : NEW_LINE INDENT result = max ( m / ( k - n + 2 ) , n / ( k - m + 2 ) ) ; NEW_LINE DEDENT print ( result ) NEW_LINE DEDENT DEDENT
Hyp: 
def max_area ( n , m , k ) : NEW_LINE INDENT if ( k > ( n + m - 2 ) ) : NEW_LINE INDENT print ( " Not ▁ possible " ) NEW_LINE DEDENT else : NEW_LINE INDENT result = 0 NEW_LINE if ( k < max ( m , n ) - 1 ) : NEW_LINE INDENT result = max ( m * ( n / ( k + 1 ) ) , n * ( m / ( k + 1 ) ) ) NEW_LINE DEDENT else : NEW_LINE INDENT result = max ( m // ( k - n + 2 ) , n // ( k - m + 2 ) ) NEW_LINE DEDENT print ( result ) NEW_LINE DEDENT

BLEU: 89.17
Edit Sim: 33


Src: 
int cntSplits ( String s ) { if ( s . charAt ( s . length ( ) - 1 ) == '1' ) return - 1 ; int ans = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) ans += ( s . charAt ( i ) == '0' ) ? 1 : 0 ; return ans ; }
Ref: 
def cntSplits ( s ) : NEW_LINE INDENT if ( s [ len ( s ) - 1 ] == '1' ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT ans = 0 ; NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT ans += ( s [ i ] == '0' ) ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT
Hyp: 
def cntSplits ( s ) : NEW_LINE INDENT if ( s [ len ( s ) - 1 ] == '1' ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT ans = 0 ; NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT ans += ( s [ i ] == '0' ) ? 1 : 0 ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT

BLEU: 92.16
Edit Sim: 8


Src: 
int solve ( int n , int m , int x , int y , int d ) { int top = Math . min ( d , x - 1 ) ; int down = Math . min ( d , n - x ) ; int left = Math . min ( d , y - 1 ) ; int right = Math . min ( d , m - y ) ; int quad1 = top * left ; int quad2 = left * down ; int quad3 = down * right ; int quad4 = right * top ; int totalsq = quad1 + quad2 + quad3 + quad4 ; int singleBlocks = top + down + left + right + 1 ; return totalsq + singleBlocks ; }
Ref: 
def solve ( n , m , x , y , d ) : NEW_LINE INDENT top = min ( d , x - 1 ) NEW_LINE down = min ( d , n - x ) NEW_LINE left = min ( d , y - 1 ) NEW_LINE right = min ( d , m - y ) NEW_LINE quad1 = top * left NEW_LINE quad2 = left * down NEW_LINE quad3 = down * right NEW_LINE quad4 = right * top NEW_LINE totalsq = ( quad1 + quad2 + quad3 + quad4 ) NEW_LINE singleBlocks = ( top + down + left + right + 1 ) NEW_LINE return totalsq + singleBlocks NEW_LINE DEDENT
Hyp: 
def solve ( n , m , x , y , d ) : NEW_LINE INDENT top = min ( d , x - 1 ) NEW_LINE down = min ( d , n - x ) NEW_LINE left = min ( d , y - 1 ) NEW_LINE right = min ( d , m - y ) NEW_LINE quad1 = top * left NEW_LINE quad2 = left * down NEW_LINE quad3 = down * right NEW_LINE quad4 = right * top NEW_LINE totalsq = quad1 + quad2 + quad3 + quad4 NEW_LINE totalsq = top + quad1 + quad2 + quad3 + quad4 NEW_LINE singleBlocks = top + down + left + right + 1 NEW_LINE return totalsq NEW_LINE DEDENT

BLEU: 84.18
Edit Sim: 75


Src: 
void countPairs ( int N , int [ ] arr ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( i == arr [ arr [ i ] - 1 ] - 1 ) { count ++ ; } } System . out . println ( count / 2 ) ; }
Ref: 
def countPairs ( N , arr ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( i == arr [ arr [ i ] - 1 ] - 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count // 2 ) NEW_LINE DEDENT
Hyp: 
def countPairs ( N , arr ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( i == arr [ arr [ i ] - 1 ] - 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT

BLEU: 93.71
Edit Sim: 5


Src: 
int maximumSum ( int arr [ ] , int N ) { int ans = 0 ; for ( int bit = 0 ; bit < 32 ; bit ++ ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( ( arr [ i ] & ( 1 << bit ) ) == 1 ) { sum += arr [ i ] ; } } ans = Math . max ( ans , sum ) ; } return ans ; }
Ref: 
def maximumSum ( arr , N ) : NEW_LINE INDENT ans = 0 NEW_LINE for bit in range ( 32 ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] & ( 1 << bit ) ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT DEDENT ans = max ( ans , sum ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
Hyp: 
def maximumSum ( arr , N ) : NEW_LINE INDENT ans = 0 NEW_LINE for bit in range ( 32 ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] & ( 1 << bit ) ) == 1 : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT DEDENT ans = max ( sum , ans ) NEW_LINE DEDENT return ans NEW_LINE DEDENT

BLEU: 90.6
Edit Sim: 11


Src: 
float sum ( float n ) { if ( n < 2 ) return 1 ; else return 1 / n + ( sum ( n - 1 ) ) ; }
Ref: 
def sum ( n ) : NEW_LINE INDENT if n < 2 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 1 / n + ( sum ( n - 1 ) ) NEW_LINE DEDENT DEDENT
Hyp: 
def sum ( n ) : NEW_LINE INDENT if ( n < 2 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 1 / n + ( sum ( n - 1 ) ) NEW_LINE DEDENT DEDENT

BLEU: 87.29
Edit Sim: 4


Src: 
int countIslands ( int mat [ ] [ ] , int m , int n ) { int count = 0 ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( mat [ i ] [ j ] == ' X ' ) { if ( ( i == 0 mat [ i - 1 ] [ j ] == ' O ' ) && ( j == 0 mat [ i ] [ j - 1 ] == ' O ' ) ) count ++ ; } } } return count ; }
Ref: 
def countIslands ( mat ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( 0 , M ) : NEW_LINE INDENT for j in range ( 0 , N ) : NEW_LINE INDENT if ( mat [ i ] [ j ] == ' X ' ) : NEW_LINE INDENT if ( ( i == 0 or mat [ i - 1 ] [ j ] == ' O ' ) and ( j == 0 or mat [ i ] [ j - 1 ] == ' O ' ) ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
Hyp: 
def countIslands ( mat , m , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( mat [ i ] [ j ] == ' X ' ) : NEW_LINE INDENT if ( ( i == 0 mat [ i - 1 ] [ j ] == ' O ' ) and ( j == 0 mat [ i ] [ j - 1 ] == ' O ' ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return count NEW_LINE DEDENT

BLEU: 79.93
Edit Sim: 35


Src: 
int sumPairs ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + ( arr [ i ] * ( 2 * n ) ) ; } return sum ; }
Ref: 
def sumPairs ( arr , n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = sum + ( arr [ i ] * ( 2 * n ) ) ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT
Hyp: 
def sumPairs ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum = sum + ( arr [ i ] * ( 2 * n ) ) NEW_LINE DEDENT return sum NEW_LINE DEDENT

BLEU: 81.26
Edit Sim: 10


Src: 
int findCnt ( int [ ] arr , int i , int required_sum , int n ) { if ( i == n ) { if ( required_sum == 0 ) return 1 ; else return 0 ; } if ( v [ i ] [ required_sum + base ] ) return dp [ i ] [ required_sum + base ] ; v [ i ] [ required_sum + base ] = true ; dp [ i ] [ required_sum + base ] = findCnt ( arr , i + 1 , required_sum , n ) + findCnt ( arr , i + 1 , required_sum - arr [ i ] , n ) ; return dp [ i ] [ required_sum + base ] ; }
Ref: 
def findCnt ( arr , i , required_sum , n ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT if ( required_sum == 0 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT DEDENT if ( v [ i ] [ required_sum + base ] ) : NEW_LINE INDENT return dp [ i ] [ required_sum + base ] ; NEW_LINE DEDENT v [ i ] [ required_sum + base ] = 1 ; NEW_LINE dp [ i ] [ required_sum + base ] = findCnt ( arr , i + 1 , required_sum , n ) + findCnt ( arr , i + 1 , required_sum - arr [ i ] , n ) ; NEW_LINE return dp [ i ] [ required_sum + base ] ; NEW_LINE DEDENT
Hyp: 
def findCnt ( arr , i , required_sum , n ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT if ( required_sum == 0 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT DEDENT if ( v [ i ] [ required_sum + base ] ) : NEW_LINE INDENT return dp [ i ] [ required_sum + base ] ; NEW_LINE DEDENT v [ i ] [ required_sum + base ] = 1 ; NEW_LINE dp [ i ] [ required_sum + base ] = findCnt ( arr , i + 1 , required_sum , n ) + findCnt ( arr , i + 1 , required_sum - arr [ i ] , n ) ; NEW_LINE return dp [ i ] [ required_sum + base ] ; NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int numberofpairs ( int [ ] arr , int N ) { int answer = 0 ; Arrays . sort ( arr ) ; int minDiff = 10000000 ; for ( int i = 0 ; i < N - 1 ; i ++ ) minDiff = Math . min ( minDiff , arr [ i + 1 ] - arr [ i ] ) ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( arr [ i + 1 ] - arr [ i ] == minDiff ) answer ++ ; } return answer ; }
Ref: 
def numberofpairs ( arr , N ) : NEW_LINE INDENT answer = 0 NEW_LINE arr . sort ( ) NEW_LINE minDiff = 10000000 NEW_LINE for i in range ( 0 , N - 1 ) : NEW_LINE INDENT minDiff = min ( minDiff , arr [ i + 1 ] - arr [ i ] ) NEW_LINE DEDENT for i in range ( 0 , N - 1 ) : NEW_LINE INDENT if arr [ i + 1 ] - arr [ i ] == minDiff : NEW_LINE INDENT answer += 1 NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT
Hyp: 
def numberofpairs ( arr , N ) : NEW_LINE INDENT answer = 0 NEW_LINE arr . sort ( ) NEW_LINE minDiff = 10000000 NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT minDiff = min ( minDiff , arr [ i + 1 ] - arr [ i ] ) NEW_LINE DEDENT for i in range ( N - 1 ) : NEW_LINE INDENT if ( arr [ i + 1 ] - arr [ i ] == minDiff ) : NEW_LINE INDENT answer += 1 NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT

BLEU: 89.66
Edit Sim: 12


Src: 
int getHeight ( int X ) { return ( 2 * X ) ; }
Ref: 
def getHeight ( X ) : NEW_LINE INDENT return ( 2 * X ) NEW_LINE DEDENT
Hyp: 
def getHeight ( X ) : NEW_LINE INDENT return ( 2 * X ) ; NEW_LINE DEDENT

BLEU: 85.79
Edit Sim: 2


Src: 
int maxSumIS ( int arr [ ] , int n ) { int i , j , max = 0 ; int msis [ ] = new int [ n ] ; for ( i = 0 ; i < n ; i ++ ) msis [ i ] = arr [ i ] ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && msis [ i ] < msis [ j ] + arr [ i ] ) msis [ i ] = msis [ j ] + arr [ i ] ; for ( i = 0 ; i < n ; i ++ ) if ( max < msis [ i ] ) max = msis [ i ] ; return max ; }
Ref: 
def maxSumIS ( arr , n ) : NEW_LINE INDENT max = 0 NEW_LINE msis = [ 0 for x in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT msis [ i ] = arr [ i ] NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and msis [ i ] < msis [ j ] + arr [ i ] ) : NEW_LINE INDENT msis [ i ] = msis [ j ] + arr [ i ] NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if max < msis [ i ] : NEW_LINE INDENT max = msis [ i ] NEW_LINE DEDENT DEDENT return max NEW_LINE DEDENT
Hyp: 
def maxSumIS ( arr , n ) : NEW_LINE INDENT max = 0 NEW_LINE msis = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT msis [ i ] = arr [ i ] NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and msis [ i ] < msis [ j ] + arr [ i ] ) : NEW_LINE INDENT msis [ i ] = msis [ j ] + arr [ i ] NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( max < msis [ i ] ) : NEW_LINE INDENT max = msis [ i ] NEW_LINE DEDENT DEDENT return max NEW_LINE DEDENT

BLEU: 92.27
Edit Sim: 23


Src: 
void testSomeNumbers ( int limit , int n ) { if ( n < 3 ) return ; for ( int a = 1 ; a <= limit ; a ++ ) for ( int b = a ; b <= limit ; b ++ ) { int pow_sum = ( int ) ( Math . pow ( a , n ) + Math . pow ( b , n ) ) ; double c = Math . pow ( pow_sum , 1.0 / n ) ; int c_pow = ( int ) Math . pow ( ( int ) c , n ) ; if ( c_pow == pow_sum ) { System . out . println ( " Count ▁ example ▁ found " ) ; return ; } } System . out . println ( " No ▁ counter ▁ example ▁ within ▁ given " + " ▁ range ▁ and ▁ data " ) ; }
Ref: 
def testSomeNumbers ( limit , n ) : NEW_LINE INDENT if ( n < 3 ) : NEW_LINE INDENT return NEW_LINE DEDENT for a in range ( 1 , limit + 1 ) : NEW_LINE INDENT for b in range ( a , limit + 1 ) : NEW_LINE INDENT pow_sum = pow ( a , n ) + pow ( b , n ) NEW_LINE c = pow ( pow_sum , 1.0 / n ) NEW_LINE c_pow = pow ( int ( c ) , n ) NEW_LINE if ( c_pow == pow_sum ) : NEW_LINE INDENT print ( " Count ▁ example ▁ found " ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT print ( " No ▁ counter ▁ example ▁ within ▁ given ▁ range ▁ and ▁ data " ) NEW_LINE DEDENT
Hyp: 
def testSomeNumbers ( limit , n ) : NEW_LINE INDENT if ( n < 3 ) : NEW_LINE INDENT return NEW_LINE DEDENT for a in range ( 1 , limit + 1 ) : NEW_LINE INDENT for b in range ( a , limit + 1 ) : NEW_LINE INDENT pow_sum = ( int ) ( math . pow ( a , n ) + math . pow ( b , n ) ) NEW_LINE c = ( pow ( pow_sum , 1.0 / n ) ) NEW_LINE if ( c_pow == pow_sum ) : NEW_LINE INDENT print ( " Count ▁ example ▁ found " ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT print ( " No ▁ counter ▁ example ▁ within ▁ given " , " ▁ range ▁ and ▁ data " ) NEW_LINE DEDENT

BLEU: 85.37
Edit Sim: 61


Src: 
int findCost ( Integer [ ] a , int n ) { Arrays . sort ( a , Collections . reverseOrder ( ) ) ; int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { int p = a [ j ] - j ; a [ j ] = 0 ; if ( p < 0 ) { p = 0 ; continue ; } count += p ; } return count ; }
Ref: 
def findCost ( a , n ) : NEW_LINE INDENT a . sort ( reverse = True ) NEW_LINE count = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT p = a [ j ] - j NEW_LINE a [ j ] = 0 NEW_LINE if ( p < 0 ) : NEW_LINE INDENT p = 0 NEW_LINE continue NEW_LINE DEDENT count += p NEW_LINE DEDENT return count NEW_LINE DEDENT
Hyp: 
def findCost ( a , n ) : NEW_LINE INDENT a . sort ( reverse = True ) NEW_LINE count = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT p = a [ j ] - j NEW_LINE a [ j ] = 0 NEW_LINE if ( p < 0 ) : NEW_LINE INDENT p = 0 NEW_LINE continue NEW_LINE DEDENT count += p NEW_LINE DEDENT return count NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int minMovesToSort ( int arr [ ] , int n ) { int moves = 0 ; int i , mn = arr [ n - 1 ] ; for ( i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] > mn ) moves += arr [ i ] - mn ; } return moves ; }
Ref: 
def minMovesToSort ( arr , n ) : NEW_LINE INDENT moves = 0 NEW_LINE mn = arr [ n - 1 ] NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] > mn ) : NEW_LINE INDENT moves += arr [ i ] - mn NEW_LINE DEDENT DEDENT return moves NEW_LINE DEDENT
Hyp: 
def minMovesToSort ( arr , n ) : NEW_LINE INDENT moves = 0 NEW_LINE mn = arr [ n - 1 ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] > mn ) : NEW_LINE INDENT moves += arr [ i ] - mn NEW_LINE DEDENT DEDENT return moves NEW_LINE DEDENT

BLEU: 96.25
Edit Sim: 1


Src: 
void Bubble_Sort ( int [ ] arr , int n ) { boolean flag ; for ( int i = 1 ; i < n ; ++ i ) { flag = false ; for ( int j = 0 ; j <= ( n - i - 1 ) ; ++ j ) { if ( arr [ j ] > arr [ j + 1 ] ) { int temp = arr [ j ] ; arr [ j ] = arr [ j + 1 ] ; arr [ j + 1 ] = temp ; flag = true ; } } if ( flag == false ) break ; } }
Ref: 
def Bubble_Sort ( arr , n ) : NEW_LINE INDENT flag = True NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT flag = False NEW_LINE for j in range ( n - i ) : NEW_LINE INDENT if ( arr [ j ] > arr [ j + 1 ] ) : NEW_LINE INDENT arr [ j ] , arr [ j + 1 ] = arr [ j + 1 ] , arr [ j ] NEW_LINE flag = True NEW_LINE DEDENT DEDENT if ( flag == False ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT n = 5 NEW_LINE arr = [ 2 , 0 , 1 , 4 , 3 ] NEW_LINE Bubble_Sort ( arr , n ) NEW_LINE print ( " The ▁ Sorted ▁ Array ▁ by ▁ using ▁ Bubble ▁ Sort ▁ is ▁ : ▁ " , end = ' ' ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT
Hyp: 
def Bubble_Sort ( arr , n ) : NEW_LINE INDENT flag = 0 ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT flag = 0 ; NEW_LINE for j in range ( ( n - i - 1 ) + 1 ) : NEW_LINE INDENT if ( arr [ j ] > arr [ j + 1 ] ) : NEW_LINE INDENT temp = arr [ j ] ; NEW_LINE arr [ j ] = arr [ j + 1 ] ; NEW_LINE arr [ j + 1 ] = temp ; NEW_LINE flag = 1 ; NEW_LINE DEDENT DEDENT if ( flag == False ) : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT DEDENT

BLEU: 41.89
Edit Sim: 327


Src: 
void primesInRange ( int n ) { int fact = 1 ; for ( int k = 2 ; k < n ; k ++ ) { fact = fact * ( k - 1 ) ; if ( ( fact + 1 ) % k == 0 ) System . out . println ( k ) ; } }
Ref: 
def primesInRange ( n ) : NEW_LINE INDENT fact = 1 NEW_LINE for k in range ( 2 , n ) : NEW_LINE INDENT fact = fact * ( k - 1 ) NEW_LINE if ( ( fact + 1 ) % k == 0 ) : NEW_LINE INDENT print k NEW_LINE DEDENT DEDENT DEDENT
Hyp: 
def primesInRange ( n ) : NEW_LINE INDENT fact = 1 NEW_LINE for k in range ( 2 , n ) : NEW_LINE INDENT fact = fact * ( k - 1 ) NEW_LINE if ( ( fact + 1 ) % k == 0 ) : NEW_LINE INDENT print ( k ) NEW_LINE DEDENT DEDENT DEDENT

BLEU: 92.38
Edit Sim: 4


Src: 
long product ( int [ ] arr ) { double occurrence = Math . pow ( 2 , arr . length - 1 ) ; double product = 1 ; for ( int i = 0 ; i < arr . length ; i ++ ) { product *= Math . pow ( arr [ i ] , occurrence ) ; } return ( long ) product ; }
Ref: 
def product ( arr ) : NEW_LINE INDENT occurrence = pow ( 2 , len ( arr ) - 1 ) ; NEW_LINE product = 1 ; NEW_LINE for i in range ( 0 , len ( arr ) ) : NEW_LINE INDENT product *= pow ( arr [ i ] , occurrence ) ; NEW_LINE DEDENT return product ; NEW_LINE DEDENT
Hyp: 
def product ( arr ) : NEW_LINE INDENT occurrence = pow ( 2 , len ( arr ) - 1 ) NEW_LINE product = 1 NEW_LINE for i in range ( 0 , len ( arr ) ) : NEW_LINE INDENT product *= pow ( arr [ i ] , occurrence ) NEW_LINE DEDENT return product NEW_LINE DEDENT

BLEU: 83.58
Edit Sim: 8


Src: 
int sumBitDifferences ( int arr [ ] , int n ) { for ( int i = 0 ; i < 32 ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) if ( ( arr [ j ] & ( 1 << i ) ) != 0 ) count ++ ; ans += ( count * ( n - count ) * 2 ) ; } return ans ; }
Ref: 
def sumBitDifferences ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , 32 ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT if ( ( arr [ j ] & ( 1 << i ) ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT ans += ( count * ( n - count ) * 2 ) ; NEW_LINE DEDENT return ans NEW_LINE DEDENT
Hyp: 
def sumBitDifferences ( arr , n ) : NEW_LINE INDENT ans = 0 ; NEW_LINE for i in range ( 32 ) : NEW_LINE INDENT count = 0 ; NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( arr [ j ] & ( 1 << i ) ) != 0 : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT ans += ( count * ( n - count ) * 2 ) ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT

BLEU: 75.12
Edit Sim: 39


Src: 
void minimumCost ( String a , String b ) { int fre1 [ ] = new int [ 256 ] ; int fre2 [ ] = new int [ 256 ] ; for ( char c : a . toCharArray ( ) ) fre1 [ ( int ) ( c ) ] ++ ; for ( char c : b . toCharArray ( ) ) fre2 [ ( int ) ( c ) ] ++ ; int mincost = 0 ; for ( int i = 0 ; i < 256 ; i ++ ) { mincost += Math . abs ( fre1 [ i ] - fre2 [ i ] ) ; } System . out . println ( mincost ) ; }
Ref: 
def minimumCost ( a , b ) : NEW_LINE INDENT fre1 = [ 0 ] * ( 256 ) NEW_LINE fre2 = [ 0 ] * ( 256 ) NEW_LINE for c in a : NEW_LINE INDENT fre1 [ ord ( c ) ] += 1 NEW_LINE DEDENT for c in b : NEW_LINE INDENT fre2 [ ord ( c ) ] += 1 NEW_LINE DEDENT mincost = 0 NEW_LINE for i in range ( 256 ) : NEW_LINE INDENT mincost += abs ( fre1 [ i ] - fre2 [ i ] ) NEW_LINE DEDENT print ( mincost ) NEW_LINE DEDENT
Hyp: 
def minimumCost ( a , b ) : NEW_LINE INDENT fre1 = [ 0 ] * 256 NEW_LINE fre2 = [ 0 ] * 256 NEW_LINE for c in a : NEW_LINE INDENT fre1 [ ord ( c ) ] += 1 NEW_LINE DEDENT for c in b : NEW_LINE INDENT fre2 [ ord ( c ) ] += 1 NEW_LINE DEDENT mincost = 0 NEW_LINE for i in range ( 256 ) : NEW_LINE INDENT mincost += abs ( fre1 [ i ] - fre2 [ i ] ) NEW_LINE DEDENT print ( mincost ) NEW_LINE DEDENT

BLEU: 91.49
Edit Sim: 8


Src: 
double Volume_of_cone ( double R ) { double V = ( double ) ( ( 1 / 3.0 ) * ( 3.14 ) * ( 2 * ( R * R ) ) * ( 4 * R ) ) ; return V ; }
Ref: 
def Volume_of_cone ( R ) : NEW_LINE INDENT V = ( 1 / 3 ) * ( 3.14 ) * ( 2 * ( R ** 2 ) ) * ( 4 * R ) NEW_LINE return V NEW_LINE DEDENT
Hyp: 
def Volume_of_cone ( R ) : NEW_LINE INDENT V = ( ( 1 / 3.0 ) * ( 3.14 ) * ( 2 * ( R * R ) ) * ( 4 * R ) ) NEW_LINE return V NEW_LINE DEDENT

BLEU: 76.18
Edit Sim: 8


Src: 
int findLen ( int arr [ ] , int n , int m ) { Vector < Integer > filter = new Vector < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) if ( ( arr [ i ] m ) == m ) filter . add ( arr [ i ] ) ; if ( filter . size ( ) == 0 ) return 0 ; int c_or = filter . get ( 0 ) ; for ( int i = 1 ; i < filter . size ( ) ; i ++ ) c_or |= filter . get ( i ) ; if ( c_or == m ) return filter . size ( ) ; return 0 ; }
Ref: 
def findLen ( arr , n , m ) : NEW_LINE INDENT filter = [ ] ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( arr [ i ] m ) == m ) : NEW_LINE INDENT filter . append ( arr [ i ] ) ; NEW_LINE DEDENT DEDENT if ( len ( filter ) == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT c_or = filter [ 0 ] ; NEW_LINE for i in range ( 1 , len ( filter ) ) : NEW_LINE INDENT c_or |= filter [ i ] ; NEW_LINE DEDENT if ( c_or == m ) : NEW_LINE INDENT return len ( filter ) ; NEW_LINE DEDENT DEDENT
Hyp: 
def findLen ( arr , n , m ) : NEW_LINE INDENT filter = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] m == m ) : NEW_LINE INDENT filter . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT if ( len ( filter ) == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT c_or = filter [ 0 ] NEW_LINE for i in range ( 1 , len ( filter ) ) : NEW_LINE INDENT c_or |= filter [ i ] NEW_LINE DEDENT if ( c_or == m ) : NEW_LINE INDENT return len ( filter ) NEW_LINE DEDENT return 0 NEW_LINE DEDENT

BLEU: 83.45
Edit Sim: 34


Src: 
void query ( String s , int i , int j ) { int n = s . length ( ) ; i %= n ; j %= n ; if ( s . charAt ( i ) == s . charAt ( j ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; }
Ref: 
def query ( s , i , j ) : NEW_LINE INDENT n = len ( s ) NEW_LINE i %= n NEW_LINE j %= n NEW_LINE print ( " Yes " ) if s [ i ] == s [ j ] else print ( " No " ) NEW_LINE DEDENT
Hyp: 
def query ( s , i , j ) : NEW_LINE INDENT n = len ( s ) NEW_LINE i %= n NEW_LINE j %= n NEW_LINE if ( s [ i ] == s [ j ] ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT

BLEU: 72.35
Edit Sim: 83


Src: 
int setBitNumber ( int n ) { n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; n = n + 1 ; return ( n >> 1 ) ; }
Ref: 
def setBitNumber ( n ) : NEW_LINE INDENT n |= n >> 1 NEW_LINE n |= n >> 2 NEW_LINE n |= n >> 4 NEW_LINE n |= n >> 8 NEW_LINE n |= n >> 16 NEW_LINE n = n + 1 NEW_LINE return ( n >> 1 ) NEW_LINE DEDENT
Hyp: 
def setBitNumber ( n ) : NEW_LINE INDENT n |= n >> 1 NEW_LINE n |= n >> 2 NEW_LINE n |= n >> 4 NEW_LINE n |= n >> 8 NEW_LINE n |= n >> 16 NEW_LINE n = n + 1 NEW_LINE return ( n >> 1 ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int lastNon0Digit ( int n ) { if ( n < 10 ) return dig [ n ] ; if ( ( ( n / 10 ) % 10 ) % 2 == 0 ) return ( 6 * lastNon0Digit ( n / 5 ) * dig [ n % 10 ] ) % 10 ; else return ( 4 * lastNon0Digit ( n / 5 ) * dig [ n % 10 ] ) % 10 ; }
Ref: 
def lastNon0Digit ( n ) : NEW_LINE INDENT if ( n < 10 ) : NEW_LINE INDENT return dig [ n ] NEW_LINE DEDENT if ( ( ( n // 10 ) % 10 ) % 2 == 0 ) : NEW_LINE INDENT return ( 6 * lastNon0Digit ( n // 5 ) * dig [ n % 10 ] ) % 10 NEW_LINE DEDENT else : NEW_LINE INDENT return ( 4 * lastNon0Digit ( n // 5 ) * dig [ n % 10 ] ) % 10 NEW_LINE DEDENT return 0 NEW_LINE DEDENT
Hyp: 
def lastNon0Digit ( n ) : NEW_LINE INDENT if n < 10 : NEW_LINE INDENT return dig [ n ] NEW_LINE DEDENT if ( ( n // 10 ) % 10 ) % 2 == 0 ) : NEW_LINE INDENT return ( 6 * lastNon0Digit ( n // 5 ) * dig [ n % 10 ] ) % 10 NEW_LINE DEDENT else : NEW_LINE INDENT return ( 4 * lastNon0Digit ( n // 5 ) * dig [ n % 10 ] ) % 10 NEW_LINE DEDENT DEDENT

BLEU: 89.16
Edit Sim: 24


Src: 
long computeXOR ( int n ) { int x = n & 3 ; switch ( x ) { case 0 : return n ; case 1 : return 1 ; case 2 : return n + 1 ; case 3 : return 0 ; } return 0 ; }
Ref: 
def computeXOR ( n ) : NEW_LINE INDENT switch = { 0 : n , 1 : 1 , 2 : n + 1 , 3 : 0 , } NEW_LINE return switch . get ( n & 3 , " " ) NEW_LINE DEDENT
Hyp: 
def computeXOR ( n ) : NEW_LINE INDENT x = n & 3 NEW_LINE switch ( x ) : NEW_LINE INDENT return n NEW_LINE DEDENT case 0 : NEW_LINE INDENT return n NEW_LINE DEDENT case 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT case 2 : NEW_LINE INDENT return n + 1 NEW_LINE DEDENT 3 : NEW_LINE INDENT return 0 NEW_LINE DEDENT

BLEU: 21.62
Edit Sim: 197


Src: 
void findMinMoves ( int a , int b ) { int ans = 0 ; if ( a == b || Math . abs ( a - b ) == 1 ) { ans = a + b ; } else { int k = Math . min ( a , b ) ; int j = Math . max ( a , b ) ; ans = 2 * k + 2 * ( j - k ) - 1 ; } System . out . print ( ans ) ; }
Ref: 
def findMinMoves ( a , b ) : NEW_LINE INDENT ans = 0 NEW_LINE if ( a == b or abs ( a - b ) == 1 ) : NEW_LINE INDENT ans = a + b NEW_LINE DEDENT else : NEW_LINE INDENT k = min ( a , b ) NEW_LINE j = max ( a , b ) NEW_LINE ans = 2 * k + 2 * ( j - k ) - 1 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
Hyp: 
def findMinMoves ( a , b ) : NEW_LINE INDENT ans = 0 NEW_LINE if ( a == b or abs ( a - b ) == 1 ) : NEW_LINE INDENT ans = a + b NEW_LINE DEDENT else : NEW_LINE INDENT k = min ( a , b ) NEW_LINE j = max ( a , b ) NEW_LINE ans = 2 * k + 2 * ( j - k ) - 1 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int countUnmarked ( int N ) { if ( N % 2 == 0 ) return N / 2 ; else return N / 2 + 1 ; }
Ref: 
def countUnmarked ( N ) : NEW_LINE INDENT if ( N % 2 == 0 ) : NEW_LINE INDENT return N / 2 ; NEW_LINE DEDENT else : NEW_LINE INDENT return N / 2 + 1 ; NEW_LINE DEDENT DEDENT
Hyp: 
def countUnmarked ( N ) : NEW_LINE INDENT if ( N % 2 == 0 ) : NEW_LINE INDENT return N // 2 ; NEW_LINE DEDENT else : NEW_LINE INDENT return N // 2 + 1 ; NEW_LINE DEDENT DEDENT

BLEU: 86.96
Edit Sim: 2


Src: 
float SellingPrice ( float CP , float PP ) { float P_decimal = 1 + ( PP / 100 ) ; float res = P_decimal * CP ; return res ; }
Ref: 
def SellingPrice ( CP , PP ) : NEW_LINE INDENT Pdecimal = 1 + ( PP / 100 ) NEW_LINE res = Pdecimal * CP NEW_LINE return res NEW_LINE DEDENT
Hyp: 
def SellingPrice ( CP , PP ) : NEW_LINE INDENT P_decimal = 1 + ( PP / 100 ) NEW_LINE res = P_decimal * CP NEW_LINE return res NEW_LINE DEDENT

BLEU: 82.32
Edit Sim: 2


Src: 
int rotateRec ( int n , int L [ ] , int B [ ] ) { int m = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { if ( Math . max ( L [ i ] , B [ i ] ) <= m ) m = Math . max ( L [ i ] , B [ i ] ) ; else if ( Math . min ( L [ i ] , B [ i ] ) <= m ) m = Math . min ( L [ i ] , B [ i ] ) ; else { return 0 ; } } return 1 ; }
Ref: 
def rotateRec ( n , L , B ) : NEW_LINE INDENT m = sys . maxsize ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( max ( L [ i ] , B [ i ] ) <= m ) : NEW_LINE INDENT m = max ( L [ i ] , B [ i ] ) ; NEW_LINE DEDENT elif ( min ( L [ i ] , B [ i ] ) <= m ) : NEW_LINE INDENT m = min ( L [ i ] , B [ i ] ) ; NEW_LINE DEDENT else : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT DEDENT return 1 ; NEW_LINE DEDENT n = 3 ; NEW_LINE L = [ 5 , 5 , 6 ] ; NEW_LINE B = [ 6 , 7 , 8 ] ; NEW_LINE if ( rotateRec ( n , L , B ) == 1 ) : NEW_LINE INDENT print ( " YES " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) ; NEW_LINE DEDENT
Hyp: 
def rotateRec ( n , L , B ) : NEW_LINE INDENT m = 10 ** 20 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( max ( L [ i ] , B [ i ] ) <= m ) : NEW_LINE INDENT m = max ( L [ i ] , B [ i ] ) NEW_LINE DEDENT elif ( min ( L [ i ] , B [ i ] ) <= m ) : NEW_LINE INDENT m = min ( L [ i ] , B [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT

BLEU: 48.83
Edit Sim: 245


Src: 
Fraction maxFraction ( Fraction first , Fraction sec ) { int a = first . num ; int b = first . den ; int c = sec . num ; int d = sec . den ; int Y = a * d - b * c ; return ( Y > 0 ) ? first : sec ; }
Ref: 
def maxFraction ( first , sec ) : NEW_LINE INDENT a = first [ 0 ] ; b = first [ 1 ] NEW_LINE c = sec [ 0 ] ; d = sec [ 1 ] NEW_LINE Y = a * d - b * c NEW_LINE return first if Y else sec NEW_LINE DEDENT
Hyp: 
def maxFraction ( first , sec ) : NEW_LINE INDENT a = first . num NEW_LINE b = first . den NEW_LINE c = sec . num NEW_LINE d = sec . den NEW_LINE Y = a * d - b * c NEW_LINE return first NEW_LINE DEDENT

BLEU: 52.71
Edit Sim: 46


Src: 
long findNthNumber ( long N ) { long result = 0 ; long p = 1 ; while ( N > 0 ) { result += ( p * ( N % 9 ) ) ; N = N / 9 ; p = p * 10 ; } return result ; }
Ref: 
def findNthNumber ( N ) : NEW_LINE INDENT result = 0 NEW_LINE p = 1 NEW_LINE while ( N > 0 ) : NEW_LINE INDENT result += ( p * ( N % 9 ) ) NEW_LINE N = N // 9 NEW_LINE p = p * 10 NEW_LINE DEDENT return result NEW_LINE DEDENT
Hyp: 
def findNthNumber ( N ) : NEW_LINE INDENT result = 0 NEW_LINE p = 1 NEW_LINE while ( N > 0 ) : NEW_LINE INDENT result += ( p * ( N % 9 ) ) NEW_LINE N = N // 9 NEW_LINE p = p * 10 NEW_LINE DEDENT return result NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int productAtKthLevel ( String tree , int k ) { int level = - 1 ; int product = 1 ; int n = tree . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( tree . charAt ( i ) == ' ( ' ) level ++ ; else if ( tree . charAt ( i ) == ' ) ' ) level -- ; else { if ( level == k ) product *= ( tree . charAt ( i ) - '0' ) ; } } return product ; }
Ref: 
def productAtKthLevel ( tree , k ) : NEW_LINE INDENT level = - 1 NEW_LINE product = 1 NEW_LINE n = len ( tree ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( tree [ i ] == ' ( ' ) : NEW_LINE INDENT level += 1 NEW_LINE DEDENT elif ( tree [ i ] == ' ) ' ) : NEW_LINE INDENT level -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( level == k ) : NEW_LINE INDENT product *= ( int ( tree [ i ] ) - int ( '0' ) ) NEW_LINE DEDENT DEDENT DEDENT return product NEW_LINE DEDENT
Hyp: 
def productAtKthLevel ( tree , k ) : NEW_LINE INDENT level = - 1 NEW_LINE product = 1 NEW_LINE n = len ( tree ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( tree [ i ] == ' ( ' ) : NEW_LINE INDENT level += 1 NEW_LINE DEDENT elif ( tree [ i ] == ' ( ' ) : NEW_LINE INDENT level -= 1 NEW_LINE DEDENT elif ( tree [ i ] == ' ) ' ) : NEW_LINE INDENT level -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( level == k ) : NEW_LINE INDENT product *= ( tree [ i ] - '0' ) NEW_LINE DEDENT DEDENT DEDENT return product NEW_LINE DEDENT

BLEU: 82.58
Edit Sim: 90


Src: 
int findMinMoves ( int [ ] arr , int N ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) sum += arr [ i ] ; if ( sum % N != 0 ) return - 1 ; int avg = sum / N ; int total = 0 ; int needCount = 0 ; for ( int i = 0 ; i < N ; i ++ ) { needCount += ( arr [ i ] - avg ) ; total = Math . max ( Math . max ( Math . abs ( needCount ) , arr [ i ] - avg ) , total ) ; } return total ; }
Ref: 
def findMinMoves ( arr , N ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT if ( sum % N != 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT avg = sum // N NEW_LINE total = 0 NEW_LINE needCount = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT needCount += ( arr [ i ] - avg ) NEW_LINE total = max ( max ( abs ( needCount ) , arr [ i ] - avg ) , total ) NEW_LINE DEDENT return total NEW_LINE DEDENT
Hyp: 
def findMinMoves ( arr , N ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT if ( sum % N ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT avg = sum / N NEW_LINE total = 0 NEW_LINE needCount = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT needCount += ( arr [ i ] - avg ) NEW_LINE total = max ( abs ( needCount ) , arr [ i ] - avg ) , total ) NEW_LINE DEDENT return total NEW_LINE DEDENT

BLEU: 92.36
Edit Sim: 12


Src: 
int countPairs ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( ( arr [ j ] % arr [ i ] == 0 ) && ( j + 1 ) % ( i + 1 ) == 0 && ( arr [ j ] / arr [ i ] == ( j + 1 ) / ( i + 1 ) ) ) { count ++ ; } } } return count ; }
Ref: 
def countPairs ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( ( arr [ j ] % arr [ i ] == 0 ) and ( j + 1 ) % ( i + 1 ) == 0 and ( arr [ j ] // arr [ i ] == ( j + 1 ) // ( i + 1 ) ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
Hyp: 
def countPairs ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( ( arr [ j ] % arr [ i ] == 0 ) and ( j + 1 ) % ( i + 1 ) == 0 and ( arr [ j ] // arr [ i ] == ( j + 1 ) // ( i + 1 ) ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
int possibleways ( int n ) { if ( n % 2 == 1 ) return 0 ; else if ( n % 4 == 0 ) return n / 4 - 1 ; else return n / 4 ; }
Ref: 
def possibleways ( n ) : NEW_LINE INDENT if ( n % 2 == 1 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT elif ( n % 4 == 0 ) : NEW_LINE INDENT return n // 4 - 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT return n // 4 ; NEW_LINE DEDENT DEDENT
Hyp: 
def possibleways ( n ) : NEW_LINE INDENT if ( n % 2 == 1 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT elif ( n % 4 == 0 ) : NEW_LINE INDENT return n // 4 - 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT return n // 4 ; NEW_LINE DEDENT DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
long minPerimeter ( int n ) { int l = ( int ) Math . sqrt ( n ) ; int sq = l * l ; if ( sq == n ) return l * 4 ; else { long row = n / l ; long perimeter = 2 * ( l + row ) ; if ( n % l != 0 ) perimeter += 2 ; return perimeter ; } }
Ref: 
def minPerimeter ( n ) : NEW_LINE INDENT l = math . sqrt ( n ) NEW_LINE sq = l * l NEW_LINE if ( sq == n ) : NEW_LINE INDENT return l * 4 NEW_LINE DEDENT else : NEW_LINE INDENT row = n / l NEW_LINE perimeter = 2 * ( l + row ) NEW_LINE if ( n % l != 0 ) : NEW_LINE INDENT perimeter += 2 NEW_LINE DEDENT return perimeter NEW_LINE DEDENT DEDENT
Hyp: 
def minPerimeter ( n ) : NEW_LINE INDENT l = int ( math . sqrt ( n ) ) NEW_LINE sq = l * l NEW_LINE if ( sq == n ) : NEW_LINE INDENT return l * 4 NEW_LINE DEDENT else : NEW_LINE INDENT row = n // l NEW_LINE perimeter = 2 * ( l + row ) NEW_LINE if ( n % l != 0 ) : NEW_LINE INDENT perimeter += 2 NEW_LINE DEDENT return perimeter NEW_LINE DEDENT DEDENT

BLEU: 90.36
Edit Sim: 9


Src: 
int countOrderedPairs ( int N ) { int count_pairs = 0 ; for ( int i = 1 ; i <= ( int ) Math . sqrt ( N - 1 ) ; ++ i ) { for ( int j = i ; j * i < N ; ++ j ) ++ count_pairs ; } count_pairs *= 2 ; count_pairs -= ( int ) ( Math . sqrt ( N - 1 ) ) ; return count_pairs ; }
Ref: 
def countOrderedPairs ( N ) : NEW_LINE INDENT count_pairs = 0 NEW_LINE p = int ( sqrt ( N - 1 ) ) + 1 NEW_LINE q = int ( sqrt ( N ) ) + 2 NEW_LINE for i in range ( 1 , p , 1 ) : NEW_LINE INDENT for j in range ( i , q , 1 ) : NEW_LINE INDENT count_pairs += 1 NEW_LINE DEDENT DEDENT count_pairs *= 2 NEW_LINE count_pairs -= int ( sqrt ( N - 1 ) ) NEW_LINE return count_pairs NEW_LINE DEDENT
Hyp: 
def countOrderedPairs ( N ) : NEW_LINE INDENT count_pairs = 0 NEW_LINE for i in range ( 1 , int ( math . sqrt ( N - 1 ) ) + 1 ) : NEW_LINE INDENT for j in range ( i , N ) : NEW_LINE INDENT count_pairs += 1 NEW_LINE DEDENT DEDENT count_pairs *= 2 NEW_LINE count_pairs -= int ( math . sqrt ( N - 1 ) ) NEW_LINE return count_pairs NEW_LINE DEDENT

BLEU: 67.96
Edit Sim: 85


Src: 
void printNumberOfPairs ( int N ) { HashSet < Integer > st = new HashSet < Integer > ( ) ; for ( int i = 2 ; i * i <= N ; i ++ ) { int x = i ; while ( x <= N ) { x *= i ; if ( x <= N ) { st . add ( x ) ; } } } System . out . println ( st . size ( ) ) ; }
Ref: 
def printNumberOfPairs ( N ) : NEW_LINE INDENT st = set ( ) NEW_LINE for i in range ( 2 , int ( sqrt ( N ) ) + 1 , 1 ) : NEW_LINE INDENT x = i NEW_LINE while ( x <= N ) : NEW_LINE INDENT x *= i NEW_LINE if ( x <= N ) : NEW_LINE INDENT st . add ( x ) NEW_LINE DEDENT DEDENT DEDENT print ( len ( st ) ) NEW_LINE DEDENT
Hyp: 
def printNumberOfPairs ( N ) : NEW_LINE INDENT st = dict ( ) NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT x = i NEW_LINE while ( x <= N ) : NEW_LINE INDENT x *= i NEW_LINE if ( x <= N ) : NEW_LINE INDENT st [ x ] = 1 NEW_LINE DEDENT DEDENT print ( len ( st ) ) NEW_LINE DEDENT

BLEU: 73.66
Edit Sim: 38


Src: 
int maxSum ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += ( arr [ i ] * i ) ; return sum ; }
Ref: 
def maxSum ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] * i NEW_LINE DEDENT return sum NEW_LINE DEDENT
Hyp: 
def maxSum ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += ( arr [ i ] * i ) NEW_LINE DEDENT return sum NEW_LINE DEDENT

BLEU: 88.73
Edit Sim: 4


Src: 
void countFreq ( String str ) { int [ ] count = new int [ limit + 1 ] ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) count [ str . charAt ( i ) ] ++ ; for ( int i = 0 ; i <= limit ; i ++ ) if ( count [ i ] > 0 ) System . out . println ( ( char ) i + " ▁ " + count [ i ] ) ; }
Ref: 
def countFreq ( Str ) : NEW_LINE INDENT count = [ 0 ] * ( limit + 1 ) NEW_LINE for i in range ( len ( Str ) ) : NEW_LINE INDENT count [ ord ( Str [ i ] ) ] += 1 NEW_LINE DEDENT for i in range ( limit + 1 ) : NEW_LINE if ( count [ i ] > 0 ) : NEW_LINE INDENT print ( chr ( i ) , count [ i ] ) NEW_LINE DEDENT DEDENT
Hyp: 
def countFreq ( str ) : NEW_LINE INDENT limit = 25 NEW_LINE count = [ 0 ] * ( limit + 1 ) NEW_LINE for x in str : NEW_LINE INDENT count [ ord ( x ) ] += 1 NEW_LINE DEDENT for i in range ( len ( str ) ) : NEW_LINE INDENT if ( count [ i ] > 0 ) : NEW_LINE INDENT print ( i , end = " ▁ " , count [ i ] ) NEW_LINE DEDENT DEDENT

BLEU: 66.78
Edit Sim: 77


Src: 
int countNumbers ( int l , int r ) { int count = 0 ; for ( int i = l ; i <= r ; i ++ ) { if ( ( i & 1 ) == 0 ) count += 1 ; } return count ; }
Ref: 
def countNumbers ( l , r ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT if ( ( i & 1 ) == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
Hyp: 
def countNumbers ( l , r ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT if ( i & 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT

BLEU: 88.74
Edit Sim: 9


Src: 
int seriesSum ( int n ) { return ( n * ( n + 1 ) * ( n + 2 ) ) / 6 ; }
Ref: 
def seriesSum ( n ) : NEW_LINE INDENT return int ( ( n * ( n + 1 ) * ( n + 2 ) ) / 6 ) NEW_LINE DEDENT
Hyp: 
def seriesSum ( n ) : NEW_LINE INDENT return ( n * ( n + 1 ) * ( n + 2 ) ) // 6 NEW_LINE DEDENT

BLEU: 74.4
Edit Sim: 9


Src: 
int multiply ( int n , int m ) { int ans = 0 , count = 0 ; while ( m > 0 ) { if ( m % 2 == 1 ) ans += n << count ; count ++ ; m /= 2 ; } return ans ; }
Ref: 
def multiply ( n , m ) : NEW_LINE INDENT ans = 0 NEW_LINE count = 0 NEW_LINE while ( m ) : NEW_LINE INDENT if ( m % 2 == 1 ) : NEW_LINE INDENT ans += n << count NEW_LINE DEDENT count += 1 NEW_LINE m = int ( m / 2 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
Hyp: 
def multiply ( n , m ) : NEW_LINE INDENT ans = 0 NEW_LINE count = 0 NEW_LINE while ( m > 0 ) : NEW_LINE INDENT if ( m % 2 == 1 ) : NEW_LINE INDENT ans += n << count NEW_LINE DEDENT count += 1 NEW_LINE m //= 2 NEW_LINE DEDENT return ans NEW_LINE DEDENT

BLEU: 83.61
Edit Sim: 17


Src: 
int xorPairCount ( int arr [ ] , int n , int x ) { HashSet < Integer > s = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . contains ( x ^ arr [ i ] ) && ( x ^ arr [ i ] ) == ( int ) s . toArray ( ) [ s . size ( ) - 1 ] ) { result ++ ; } s . add ( arr [ i ] ) ; } return result ; }
Ref: 
def xorPairCount ( arr , n , x ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( x ^ arr [ i ] in s ) : NEW_LINE INDENT result = result + 1 NEW_LINE DEDENT s . add ( arr [ i ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT
Hyp: 
def xorPairCount ( arr , n , x ) : NEW_LINE INDENT s = set ( ) NEW_LINE result = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if x ^ arr [ i ] in s : NEW_LINE INDENT result += 1 NEW_LINE DEDENT s . add ( arr [ i ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT

BLEU: 79.71
Edit Sim: 38


Src: 
double hexDiagonal ( float a ) { if ( a < 0 ) return - 1 ; double d = ( double ) 1.73 * a ; return d ; }
Ref: 
def hexDiagonal ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT d = 1.73 * a ; NEW_LINE return d ; NEW_LINE DEDENT
Hyp: 
def hexDiagonal ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT d = ( 1.73 * a ) NEW_LINE return d NEW_LINE DEDENT

BLEU: 73.11
Edit Sim: 7


Src: 
int countRectangles ( int radius ) { int rectangles = 0 ; int diameter = 2 * radius ; int diameterSquare = diameter * diameter ; for ( int a = 1 ; a < 2 * radius ; a ++ ) { for ( int b = 1 ; b < 2 * radius ; b ++ ) { int diagonalLengthSquare = ( a * a + b * b ) ; if ( diagonalLengthSquare <= diameterSquare ) { rectangles ++ ; } } } return rectangles ; }
Ref: 
def countRectangles ( radius ) : NEW_LINE INDENT rectangles = 0 NEW_LINE diameter = 2 * radius NEW_LINE diameterSquare = diameter * diameter NEW_LINE for a in range ( 1 , 2 * radius ) : NEW_LINE INDENT for b in range ( 1 , 2 * radius ) : NEW_LINE INDENT diagonalLengthSquare = ( a * a + b * b ) NEW_LINE if ( diagonalLengthSquare <= diameterSquare ) : NEW_LINE INDENT rectangles += 1 NEW_LINE DEDENT DEDENT DEDENT return rectangles NEW_LINE DEDENT
Hyp: 
def countRectangles ( radius ) : NEW_LINE INDENT rectangles = 0 NEW_LINE diameter = 2 * radius NEW_LINE diameterSquare = diameter * diameter NEW_LINE for a in range ( 1 , 2 * radius ) : NEW_LINE INDENT for b in range ( 1 , 2 * radius ) : NEW_LINE INDENT diagonalLengthSquare = ( a * a + b * b ) NEW_LINE if ( diagonalLengthSquare <= diameterSquare ) : NEW_LINE INDENT rectangles += 1 NEW_LINE DEDENT DEDENT DEDENT return rectangles NEW_LINE DEDENT

BLEU: 100.0
Edit Sim: 0


Src: 
String getCount ( int N ) { if ( N % 2 == 1 ) return "0" ; String result = "9" ; for ( int i = 1 ; i <= N / 2 - 1 ; i ++ ) result += "0" ; return result ; }
Ref: 
def getCount ( N ) : NEW_LINE INDENT if ( N % 2 == 1 ) : NEW_LINE INDENT return "0" NEW_LINE DEDENT result = "9" NEW_LINE for i in range ( 1 , N // 2 ) : NEW_LINE INDENT result = result + "0" NEW_LINE DEDENT return result NEW_LINE DEDENT
Hyp: 
def getCount ( N ) : NEW_LINE INDENT if ( N % 2 == 1 ) : NEW_LINE INDENT return "0" NEW_LINE DEDENT result = "9" NEW_LINE for i in range ( 1 , N // 2 - 1 ) : NEW_LINE INDENT result += "0" NEW_LINE DEDENT return result NEW_LINE DEDENT

BLEU: 88.13
Edit Sim: 14


Src: 
int findSum ( int n ) { n -- ; int sum = 0 ; sum += ( n * ( n + 1 ) ) / 2 ; sum += ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; return sum ; }
Ref: 
def findSum ( n ) : NEW_LINE INDENT n -= 1 NEW_LINE sum = 0 NEW_LINE sum += ( n * ( n + 1 ) ) / 2 NEW_LINE sum += ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 NEW_LINE return int ( sum ) NEW_LINE DEDENT
Hyp: 
def findSum ( n ) : NEW_LINE INDENT n -= 1 NEW_LINE sum = 0 NEW_LINE sum += ( n * ( n + 1 ) ) // 2 NEW_LINE sum += ( n * ( n + 1 ) * ( 2 * n + 1 ) ) // 6 NEW_LINE return sum NEW_LINE DEDENT

BLEU: 82.49
Edit Sim: 10


Src: 
void checkSolution ( int a , int b , int c ) { if ( ( ( b * b ) - ( 4 * a * c ) ) > 0 ) System . out . println ( "2 ▁ solutions " ) ; else if ( ( ( b * b ) - ( 4 * a * c ) ) == 0 ) System . out . println ( "1 ▁ solution " ) ; else System . out . println ( " No ▁ solutions " ) ; }
Ref: 
def checkSolution ( a , b , c ) : NEW_LINE INDENT if ( ( b * b ) - ( 4 * a * c ) ) > 0 : NEW_LINE INDENT print ( "2 ▁ solutions " ) NEW_LINE DEDENT elif ( ( b * b ) - ( 4 * a * c ) ) == 0 : NEW_LINE INDENT print ( "1 ▁ solution " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No ▁ solutions " ) NEW_LINE DEDENT DEDENT
Hyp: 
def checkSolution ( a , b , c ) : NEW_LINE INDENT if ( ( b * b ) - ( 4 * a * c ) ) > 0 : NEW_LINE INDENT print ( "2 ▁ solutions " ) NEW_LINE DEDENT elif ( ( b * b ) - ( 4 * a * c ) ) == 0 : NEW_LINE INDENT print ( "1 ▁ solution " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No ▁ solutions " ) NEW_LINE DEDENT DEDENT

BLEU: 100.0
Edit Sim: 0


