Src: 
function findWays ( N ) { let dp = new Array ( N + 1 ) ; dp [ 0 ] = 1 ; for ( let i = 1 ; i <= N ; i ++ ) { dp [ i ] = 0 ; for ( let j = 1 ; j <= 6 ; j ++ ) { if ( i - j >= 0 ) { dp [ i ] = dp [ i ] + dp [ i - j ] ; } } } document . write ( dp [ N ] ) ; }
Ref: 
void findWays ( int N ) { int dp [ N + 1 ] ; dp [ 0 ] = 1 ; for ( int i = 1 ; i <= N ; i ++ ) { dp [ i ] = 0 ; for ( int j = 1 ; j <= 6 ; j ++ ) { if ( i - j >= 0 ) { dp [ i ] = dp [ i ] + dp [ i - j ] ; } } } cout << dp [ N ] ; }
Hyp: 
void findWays ( int N ) { int dp [ N + 1 ] ; dp [ 0 ] = 1 ; for ( int i = 1 ; i <= N ; i ++ ) { dp [ i ] = 0 ; for ( int j = 1 ; j <= 6 ; j ++ ) { if ( i - j >= 0 ) { dp [ i ] = dp [ i ] + dp [ i - j ] ; } } } cout << dp [ N ] ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function numberOfPairs ( n ) { let count = 0 ; let i = 1 , j = n - 1 ; while ( i < j ) { if ( i + j == n ) { count ++ ; } i ++ ; j -- ; } return count ; }
Ref: 
int numberOfPairs ( int n ) { int count = 0 ; int i = 1 , j = n - 1 ; while ( i < j ) { if ( i + j == n ) { count ++ ; } i ++ ; j -- ; } return count ; }
Hyp: 
int numberOfPairs ( int n ) { int count = 0 ; int i = 1 , j = n - 1 ; while ( i < j ) { if ( i + j == n ) { count ++ ; } i ++ ; j -- ; } return count ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findkey ( A , B , C ) { let ans = 0 ; let cur = 1 ; while ( A > 0 ) { let a = A % 10 ; let b = B % 10 ; let c = C % 10 ; A = Math . floor ( A / 10 ) ; B = Math . floor ( B / 10 ) ; C = Math . floor ( C / 10 ) ; let m = Math . max ( a , Math . max ( c , b ) ) ; ans += cur * m ; cur = cur * 10 ; } return ans ; }
Ref: 
int findkey ( int A , int B , int C ) { int ans = 0 ; int cur = 1 ; while ( A > 0 ) { int a = A % 10 ; int b = B % 10 ; int c = C % 10 ; A = A / 10 ; B = B / 10 ; C = C / 10 ; int m = max ( a , max ( c , b ) ) ; ans += cur * m ; cur = cur * 10 ; } return ans ; }
Hyp: 
int findkey ( int A , int B , int C ) { int ans = 0 ; int cur = 1 ; while ( A > 0 ) { int a = A % 10 ; int b = B % 10 ; int c = C % 10 ; A = A / 10 ; B = B / 10 ; C = C / 10 ; int m = max ( a , max ( c , b ) ) ; ans += cur * m ; cur = cur * 10 ; } return ans ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function count ( a , b , m , n ) { if ( ( m == 0 && n == 0 ) n == 0 ) return 1 ; if ( m == 0 ) return 0 ; if ( a [ m - 1 ] == b [ n - 1 ] ) return count ( a , b , m - 1 , n - 1 ) + count ( a , b , m - 1 , n ) ; else return count ( a , b , m - 1 , n ) ; }
Ref: 
int count ( string a , string b , int m , int n ) { if ( ( m == 0 && n == 0 ) n == 0 ) return 1 ; if ( m == 0 ) return 0 ; if ( a [ m - 1 ] == b [ n - 1 ] ) return count ( a , b , m - 1 , n - 1 ) + count ( a , b , m - 1 , n ) ; else return count ( a , b , m - 1 , n ) ; }
Hyp: 
int count ( int a [ ] , int b [ ] , int m , int n ) { if ( ( m == 0 && n == 0 ) n == 0 ) return 1 ; if ( m == 0 ) return 0 ; if ( a [ m - 1 ] == b [ n - 1 ] ) return count ( a , b , m - 1 , n - 1 ) + count ( a , b , m - 1 , n ) ; else return count ( a , b , m - 1 , n ) ; }

BLEU: 90.88
Edit Sim: 14


Src: 
function checkRightAngled ( X1 , Y1 , X2 , Y2 , X3 , Y3 ) { var A = Math . pow ( X2 - X1 , 2 ) + Math . pow ( Y2 - Y1 , 2 ) ; var B = Math . pow ( X3 - X2 , 2 ) + Math . pow ( Y3 - Y2 , 2 ) ; var C = Math . pow ( X3 - X1 , 2 ) + Math . pow ( Y3 - Y1 , 2 ) ; if ( A > 0 && B > 0 && C > 0 && ( A === B + C B === A + C C === A + B ) ) document . write ( " " ) ; else document . write ( " " ) ; }
Ref: 
void checkRightAngled ( int X1 , int Y1 , int X2 , int Y2 , int X3 , int Y3 ) { int A = ( int ) pow ( ( X2 - X1 ) , 2 ) + ( int ) pow ( ( Y2 - Y1 ) , 2 ) ; int B = ( int ) pow ( ( X3 - X2 ) , 2 ) + ( int ) pow ( ( Y3 - Y2 ) , 2 ) ; int C = ( int ) pow ( ( X3 - X1 ) , 2 ) + ( int ) pow ( ( Y3 - Y1 ) , 2 ) ; if ( ( A > 0 and B > 0 and C > 0 ) and ( A == ( B + C ) or B == ( A + C ) or C == ( A + B ) ) ) cout << " Yes " ; else cout << " No " ; }
Hyp: 
void checkRightAngled ( int X1 , int Y1 , int X2 , int Y2 , int X3 , int Y3 ) { int A = pow ( X2 - X1 , 2 ) + pow ( Y2 - Y1 , 2 ) ; int B = pow ( X3 - X2 , 2 ) + pow ( Y3 - Y2 , 2 ) ; int C = pow ( X3 - X1 , 2 ) + pow ( Y3 - Y1 , 2 ) ; if ( A > 0 && B > 0 && C > 0 && ( A == B + C B == A + C C == A + B ) ) cout << " Yes " ; else cout << " No " ; }

BLEU: 50.85
Edit Sim: 103


Src: 
function find_winner ( str , n ) { var str1 = " " , str2 = " " ; for ( var i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { str1 += str [ i ] ; } else { str2 += str [ i ] ; } } str1 = str1 . split ( ' ' ) . sort ( ) ; str2 = str2 . split ( ' ' ) . sort ( ) ; if ( str1 < str2 ) document . write ( " " ) ; else if ( str2 < str1 ) document . write ( " " ) ; else document . write ( " " ) ; }
Ref: 
void find_winner ( string str , int n ) { string str1 = " " , str2 = " " ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { str1 += str [ i ] ; } else { str2 += str [ i ] ; } } sort ( str1 . begin ( ) , str1 . end ( ) ) ; sort ( str2 . begin ( ) , str2 . end ( ) ) ; if ( str1 < str2 ) cout << " A " ; else if ( str2 < str1 ) cout << " B " ; else cout << " Tie " ; }
Hyp: 
void find_winner ( string str , int n ) { string str1 = " " , str2 = " " ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { str1 += str [ i ] ; } else { str2 += str [ i ] ; } } sort ( str1 . begin ( ) , str1 . end ( ) ) ; sort ( str2 . begin ( ) , str2 . end ( ) ) ; if ( str1 < str2 ) cout << " Yes " ; else if ( str2 < str1 ) cout << " No " ; else cout << " Yes " ; }

BLEU: 94.01
Edit Sim: 8


Src: 
function findBitwiseORGivenXORAND ( X , Y ) { return X + Y ; }
Ref: 
int findBitwiseORGivenXORAND ( int X , int Y ) { return X + Y ; }
Hyp: 
int findBitwiseORGivenXORAND ( int X , int Y ) { return X + Y ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findDirection ( n , m ) { if ( n > m ) { if ( m % 2 == 0 ) document . write ( " " ) ; else document . write ( " " ) ; } else { if ( n % 2 == 0 ) document . write ( " " ) ; else document . write ( " " ) ; } }
Ref: 
void findDirection ( int n , int m ) { if ( n > m ) { if ( m % 2 == 0 ) printf ( " Up STRNEWLINE " ) ; else printf ( " Down STRNEWLINE " ) ; } else { if ( n % 2 == 0 ) printf ( " Left STRNEWLINE " ) ; else printf ( " Right STRNEWLINE " ) ; } }
Hyp: 
void findDirection ( int n , int m ) { if ( n > m ) { if ( m % 2 == 0 ) cout << " Right " ; else cout << " Left " ; } else { if ( n % 2 == 0 ) cout << " Left " ; else cout << " Right " ; } }

BLEU: 55.75
Edit Sim: 84


Src: 
function doMatch ( A , B ) { for ( i = 0 ; i < A . length ; i ++ ) { if ( A . charAt ( i ) != ' ' && B . charAt ( i ) != ' ' ) { if ( A . charAt ( i ) != B . charAt ( i ) ) return 0 ; } } return 1 ; }
Ref: 
bool doMatch ( string A , string B ) { for ( int i = 0 ; i < A . length ( ) ; i ++ ) if ( A [ i ] != ' * ' && B [ i ] != ' * ' ) if ( A [ i ] != B [ i ] ) return false ; return true ; }
Hyp: 
int doMatch ( string A , string B ) { for ( int i = 0 ; i < A . size ( ) ; i ++ ) { if ( A [ i ] != ' a ' && B [ i ] != ' e ' ) { if ( A [ i ] != ' z ' && B [ i ] != ' a ' ) { if ( A [ i ] != ' z ' ) { if ( A [ i ] != ' a ' ) return 0 ; } } } return 1 ; }

BLEU: 45.18
Edit Sim: 98


Src: 
function first ( str ) { for ( var i = 0 ; i < str . length ; i ++ ) if ( str [ i ] === str [ i ] . toUpperCase ( ) ) return str [ i ] ; return 0 ; } var str = " " ; var res = first ( str ) ; if ( res == 0 ) document . write ( " " ) ; else { document . write ( res ) ; document . write ( " " ) ; }
Ref: 
char first ( string str ) { for ( int i = 0 ; i < str . length ( ) ; i ++ ) if ( isupper ( str [ i ] ) ) return str [ i ] ; return 0 ; }
Hyp: 
char first ( string str ) { for ( int i = 0 ; i < str . length ( ) ; i ++ ) if ( str [ i ] == str [ i ] . toUpperCase ( ) ) return str [ i ] ; return 0 ; }

BLEU: 79.94
Edit Sim: 27


Src: 
function rectanglearea ( a , b ) { if ( a < 0 b < 0 ) return - 1 ; return 2 * a * b ; }
Ref: 
float rectanglearea ( float a , float b ) { if ( a < 0 b < 0 ) return -1 ; return 2 * a * b ; }
Hyp: 
float rectanglearea ( float a , float b ) { if ( a < 0 b < 0 ) return -1 ; return 2 * a * b ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function calculateAngle ( x1 , y1 , z1 , x2 , y2 , z2 , x3 , y3 , z3 ) { var ABx = x1 - x2 ; var ABy = y1 - y2 ; var ABz = z1 - z2 ; var BCx = x3 - x2 ; var BCy = y3 - y2 ; var BCz = z3 - z2 ; var dotProduct = ABx * BCx + ABy * BCy + ABz * BCz ; var magnitudeAB = ABx * ABx + ABy * ABy + ABz * ABz ; var magnitudeBC = BCx * BCx + BCy * BCy + BCz * BCz ; var angle = dotProduct ; angle /= Math . sqrt ( magnitudeAB * magnitudeBC ) ; angle = ( angle * 180 ) / PI ; document . write ( Math . abs ( angle ) . toFixed ( 4 ) ) ; }
Ref: 
void calculateAngle ( int x1 , int y1 , int z1 , int x2 , int y2 , int z2 , int x3 , int y3 , int z3 ) { int ABx = x1 - x2 ; int ABy = y1 - y2 ; int ABz = z1 - z2 ; int BCx = x3 - x2 ; int BCy = y3 - y2 ; int BCz = z3 - z2 ; double dotProduct = ABx * BCx + ABy * BCy + ABz * BCz ; double magnitudeAB = ABx * ABx + ABy * ABy + ABz * ABz ; double magnitudeBC = BCx * BCx + BCy * BCy + BCz * BCz ; double angle = dotProduct ; angle /= sqrt ( magnitudeAB * magnitudeBC ) ; angle = ( angle * 180 ) / PI ; cout << abs ( angle ) << endl ; }
Hyp: 
void calculateAngle ( int x1 , int y1 , int z1 , int x2 , int y2 , int z2 , int x3 , int y3 , int z3 ) { int ABx = x1 - x2 ; int ABy = y1 - y2 ; int ABz = z1 - z2 ; int BCx = x3 - x2 ; int BCy = y3 - y2 ; int BCz = z3 - z2 ; int dotProduct = ABx * BCx + ABy * BCy + ABz * BCz ; int magnitudeAB = ABx * ABx + ABy * ABy + ABz * ABz ; int magnitudeBC = BCx * BCx + BCy * BCy + BCz * BCz ; int angle = dotProduct ; angle /= sqrt ( magnitudeAB * magnitudeBC ) ; angle = ( angle * 180 ) / PI ; cout << abs ( angle ) ; }

BLEU: 91.16
Edit Sim: 32


Src: 
function countPairs ( arr , N ) { let answer = 0 ; for ( let i = 0 ; i < N ; i ++ ) { for ( let j = i + 1 ; j < N ; j ++ ) { if ( arr [ i ] + arr [ j ] == i + j ) { answer ++ ; } } } document . write ( answer ) ; }
Ref: 
void countPairs ( int arr [ ] , int N ) { int answer = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( arr [ i ] + arr [ j ] == i + j ) { answer ++ ; } } } cout << answer ; }
Hyp: 
int countPairs ( int arr [ ] , int N ) { int answer = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( arr [ i ] + arr [ j ] == i + j ) { answer ++ ; } } } cout << answer ; }

BLEU: 98.69
Edit Sim: 4


Src: 
function permutationCoeff ( n , k ) { let fact = new Array ( n + 1 ) ; fact [ 0 ] = 1 ; for ( let i = 1 ; i <= n ; i ++ ) fact [ i ] = i * fact [ i - 1 ] ; return parseInt ( fact [ n ] / fact [ n - k ] , 10 ) ; }
Ref: 
int permutationCoeff ( int n , int k ) { int fact [ n + 1 ] ; fact [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) fact [ i ] = i * fact [ i - 1 ] ; return fact [ n ] / fact [ n - k ] ; }
Hyp: 
int permutationCoeff ( int n , int k ) { int fact [ n + 1 ] ; fact [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) fact [ i ] = i * fact [ i - 1 ] ; return fact [ n ] / fact [ n - k ] ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findSum ( s ) { let sum = 0 ; for ( let i = 0 ; i < s . length ; i ++ ) { for ( let j = i + 1 ; j < s . length ; j ++ ) { if ( s [ i ] == s [ j ] ) { sum += ( j - i ) ; } } } return sum ; }
Ref: 
int findSum ( string s ) { int sum = 0 ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { for ( int j = i + 1 ; j < s . size ( ) ; j ++ ) { if ( s [ i ] == s [ j ] ) { sum += ( j - i ) ; } } } return sum ; }
Hyp: 
int findSum ( string s ) { int sum = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { for ( int j = i + 1 ; j < s . length ( ) ; j ++ ) { if ( s [ i ] == s [ j ] ) { sum += ( j - i ) ; } } } return sum ; }

BLEU: 93.62
Edit Sim: 12


Src: 
function findMinInsertions ( str , l , h ) { if ( l > h ) return Number . MAX_VALUE ; if ( l == h ) return 0 ; if ( l == h - 1 ) return ( str [ l ] == str [ h ] ) ? 0 : 1 ; return ( str [ l ] == str [ h ] ) ? findMinInsertions ( str , l + 1 , h - 1 ) : ( Math . min ( findMinInsertions ( str , l , h - 1 ) , findMinInsertions ( str , l + 1 , h ) ) + 1 ) }
Ref: 
int findMinInsertions ( char str [ ] , int l , int h ) { if ( l > h ) return INT_MAX ; if ( l == h ) return 0 ; if ( l == h - 1 ) return ( str [ l ] == str [ h ] ) ? 0 : 1 ; return ( str [ l ] == str [ h ] ) ? findMinInsertions ( str , l + 1 , h - 1 ) : ( min ( findMinInsertions ( str , l , h - 1 ) , findMinInsertions ( str , l + 1 , h ) ) + 1 ) ; }
Hyp: 
int findMinInsertions ( string str , int l , int h ) { if ( l > h ) return INT_MAX ; if ( l == h ) return 0 ; if ( l == h - 1 ) return ( str [ l ] == str [ h ] ) ? 0 : 1 ; return ( str [ l ] == str [ h ] ) ? findMinInsertions ( str , l + 1 , h - 1 ) : ( min ( findMinInsertions ( str , l , h - 1 ) , findMinInsertions ( str , l + 1 , h ) ) + 1 ) ; }

BLEU: 95.34
Edit Sim: 10


Src: 
function numberofterm ( n , number ) { let firstnum = Math . pow ( 10 , n - 1 ) ; let lastnum = Math . pow ( 10 , n ) ; let count = 0 ; for ( let i = firstnum ; i < lastnum ; i ++ ) if ( i % number == 0 ) count ++ ; return count ; }
Ref: 
int numberofterm ( int n , int number ) { int firstnum = pow ( 10 , n - 1 ) ; int lastnum = pow ( 10 , n ) ; int count = 0 ; for ( int i = firstnum ; i < lastnum ; i ++ ) if ( i % number == 0 ) count ++ ; return count ; }
Hyp: 
int numberofterm ( int n , int number ) { int firstnum = pow ( 10 , n - 1 ) ; int lastnum = pow ( 10 , n ) ; int count = 0 ; for ( int i = firstnum ; i < lastnum ; i ++ ) if ( i % number == 0 ) count ++ ; return count ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function octadiagonal ( a ) { if ( a < 0 ) return - 1 ; return a * Math . sqrt ( 4 + ( 2 * Math . sqrt ( 2 ) ) ) ; }
Ref: 
float octadiagonal ( float a ) { if ( a < 0 ) return -1 ; return a * sqrt ( 4 + ( 2 * sqrt ( 2 ) ) ) ; }
Hyp: 
float octadiagonal ( float a ) { if ( a < 0 ) return -1 ; return a * sqrt ( 4 + ( 2 * sqrt ( 2 ) ) ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function submatrixXor ( arr ) { let ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { let top_left = ( i + 1 ) * ( j + 1 ) ; let bottom_right = ( n - i ) * ( n - j ) ; if ( ( top_left % 2 == 1 ) && ( bottom_right % 2 == 1 ) ) ans = ( ans ^ arr [ i ] [ j ] ) ; } } return ans ; }
Ref: 
int submatrixXor ( int arr [ ] [ n ] ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { int top_left = ( i + 1 ) * ( j + 1 ) ; int bottom_right = ( n - i ) * ( n - j ) ; if ( ( top_left % 2 == 1 ) && ( bottom_right % 2 == 1 ) ) ans = ( ans ^ arr [ i ] [ j ] ) ; } } return ans ; }
Hyp: 
int submatrixXor ( int arr [ ] [ n ] ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { int top_left = ( i + 1 ) * ( j + 1 ) ; int bottom_right = ( n - i ) * ( n - j ) ; if ( ( top_left % 2 == 1 ) && ( bottom_right % 2 == 1 ) ) ans = ( ans ^ arr [ i ] [ j ] ) ; } } return ans ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function cyl ( r , h ) { if ( r < 0 && h < 0 ) return - 1 ; var R = ( 2 * r ) / 3 ; var H = ( 2 * h ) / 3 ; var V = 3.14 * Math . pow ( R , 2 ) * H ; return V ; }
Ref: 
float cyl ( float r , float h ) { if ( r < 0 && h < 0 ) return -1 ; float R = ( 2 * r ) / 3 ; float H = ( 2 * h ) / 3 ; float V = 3.14 * pow ( R , 2 ) * H ; return V ; }
Hyp: 
float cyl ( float r , float h ) { if ( r < 0 && h < 0 ) return -1 ; float R = ( 2 * r ) / 3 ; float H = ( 2 * h ) / 3 ; float V = 3.14 * pow ( R , 2 ) * H ; return V ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function StepstoReachTarget ( target ) { target = Math . abs ( target ) ; let n = Math . ceil ( ( - 1.0 + Math . sqrt ( 1 + 8.0 * target ) ) / 2 ) ; let sum = n * ( n + 1 ) / 2 ; if ( sum == target ) return n ; let d = sum - target ; if ( ( d & 1 ) == 0 ) return n ; else return n + ( ( n & 1 ) != 0 ? 2 : 1 ) ; }
Ref: 
int StepstoReachTarget ( int target ) { target = abs ( target ) ; int n = ceil ( ( -1.0 + sqrt ( 1 + 8.0 * target ) ) / 2 ) ; int sum = n * ( n + 1 ) / 2 ; if ( sum == target ) return n ; int d = sum - target ; if ( ( d & 1 ) == 0 ) return n ; else return n + ( ( n & 1 ) ? 2 : 1 ) ; }
Hyp: 
int StepstoReachTarget ( int target ) { target = abs ( target ) ; int n = ceil ( ( -1 + sqrt ( 1 + 8.0 * target ) ) / 2 ) ; int sum = n * ( n + 1 ) / 2 ; if ( sum == target ) return n ; int d = sum - target ; if ( ( d & 1 ) == 0 ) return n ; else return n + ( ( n & 1 ) != 0 ? 2 : 1 ) ; }

BLEU: 93.66
Edit Sim: 7


Src: 
function can_empty ( a , b , c ) { if ( ( a + b + c ) % 4 != 0 ) return false ; else { let m = Math . min ( a , Math . min ( b , c ) ) ; if ( m < Math . floor ( ( a + b + c ) / 4 ) ) return false ; } return true ; }
Ref: 
bool can_empty ( ll a , ll b , ll c ) { if ( ( a + b + c ) % 4 != 0 ) return false ; else { int m = min ( a , min ( b , c ) ) ; if ( m < ( ( a + b + c ) / 4 ) ) return false ; } return true ; }
Hyp: 
bool can_empty ( int a , int b , int c ) { if ( ( a + b + c ) % 4 != 0 ) return false ; else { int m = min ( a , min ( b , c ) ) ; if ( m < ( a + b + c ) / 4 ) return false ; } return true ; }

BLEU: 84.76
Edit Sim: 13


Src: 
function cntRect ( points , N , rectangle ) { var cntHor = new Set ( ) ; var cntVer = new Set ( ) ; cntHor . add ( 0 ) ; cntVer . add ( 0 ) ; cntHor . add ( rectangle [ 3 ] [ 0 ] ) ; cntVer . add ( rectangle [ 3 ] [ 1 ] ) ; for ( var i = 0 ; i < N ; i ++ ) { cntHor . add ( points [ i ] [ 0 ] ) ; cntVer . add ( points [ i ] [ 1 ] ) ; } return ( cntHor . size - 1 ) * ( cntVer . size - 1 ) ; }
Ref: 
int cntRect ( int points [ ] [ 2 ] , int N , int rectangle [ ] [ 2 ] ) { unordered_set < int > cntHor ; unordered_set < int > cntVer ; cntHor . insert ( 0 ) ; cntVer . insert ( 0 ) ; cntHor . insert ( rectangle [ 3 ] [ 0 ] ) ; cntVer . insert ( rectangle [ 3 ] [ 1 ] ) ; for ( int i = 0 ; i < N ; i ++ ) { cntHor . insert ( points [ i ] [ 0 ] ) ; cntVer . insert ( points [ i ] [ 1 ] ) ; } return ( cntHor . size ( ) - 1 ) * ( cntVer . size ( ) - 1 ) ; }
Hyp: 
int cntRect ( int points [ ] [ 2 ] , int N , int rectangle [ ] [ 3 ] ) { set < int > cntHor ; set < int > cntVer ; cntHor . insert ( 0 ) ; cntVer . insert ( 0 ) ; cntHor . insert ( rectangle [ 3 ] [ 0 ] ) ; cntVer . insert ( rectangle [ 3 ] [ 1 ] ) ; for ( int i = 0 ; i < N ; i ++ ) { cntHor . insert ( points [ i ] [ 0 ] ) ; cntVer . insert ( points [ i ] [ 1 ] ) ; } return ( cntHor . size ( ) - 1 ) * ( cntVer . size ( ) - 1 ) ; }

BLEU: 94.53
Edit Sim: 21


Src: 
function FirstRepeated ( str ) { let checker = 0 ; for ( let i = 0 ; i < str . length ; ++ i ) { let val = ( str [ i ] - ' ' ) ; if ( ( checker & ( 1 << val ) ) > 0 ) return i ; checker |= ( 1 << val ) ; } return - 1 ; }
Ref: 
int FirstRepeated ( string str ) { int checker = 0 ; for ( int i = 0 ; i < str . length ( ) ; ++ i ) { int val = ( str [ i ] - ' a ' ) ; if ( ( checker & ( 1 << val ) ) > 0 ) return i ; checker |= ( 1 << val ) ; } return -1 ; }
Hyp: 
int FirstRepeated ( string str ) { int checker = 0 ; for ( int i = 0 ; i < str . length ( ) ; ++ i ) { int val = ( str [ i ] - ' a ' ) ; if ( ( checker & ( 1 << val ) ) > 0 ) return i ; checker |= ( 1 << val ) ; } return -1 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function constructArray ( N , K , X ) { let ans = new Array ( K ) . fill ( 0 ) ; ans [ 0 ] = X ; for ( let i = 0 ; i < N ; ++ i ) { document . write ( ans [ i % K ] + " " ) ; } document . write ( " " ) ; }
Ref: 
void constructArray ( int N , int K , int X ) { vector < int > ans ( K , 0 ) ; ans [ 0 ] = X ; for ( int i = 0 ; i < N ; ++ i ) { cout << ans [ i % K ] << " ▁ " ; } cout << endl ; }
Hyp: 
void constructArray ( int N , int K , int X ) { int ans [ K ] ; ans [ 0 ] = X ; for ( int i = 0 ; i < N ; ++ i ) { cout << ans [ i % K ] << " ▁ " ; } cout << endl ; }

BLEU: 82.97
Edit Sim: 17


Src: 
function nthTerm ( n ) { return 4 * Math . pow ( n , 2 ) - 3 * n + 2 ; }
Ref: 
int nthTerm ( int n ) { return 4 * pow ( n , 2 ) - 3 * n + 2 ; }
Hyp: 
int nthTerm ( int n ) { return 4 * pow ( n , 2 ) - 3 * n + 2 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function minRadius ( k , x , y , n ) { let dis = Array . from ( { length : n } , ( _ , i ) => 0 ) ; for ( let i = 0 ; i < n ; i ++ ) dis [ i ] = x [ i ] * x [ i ] + y [ i ] * y [ i ] ; dis . sort ( ) ; return dis [ k - 1 ] ; }
Ref: 
int minRadius ( int k , int x [ ] , int y [ ] , int n ) { int dis [ n ] ; for ( int i = 0 ; i < n ; i ++ ) dis [ i ] = x [ i ] * x [ i ] + y [ i ] * y [ i ] ; sort ( dis , dis + n ) ; return dis [ k - 1 ] ; }
Hyp: 
int minRadius ( int k , int x [ ] , int y [ ] , int n ) { int dis [ n ] ; for ( int i = 0 ; i < n ; i ++ ) dis [ i ] = x [ i ] * x [ i ] + y [ i ] * y [ i ] ; sort ( dis . begin ( ) , dis . end ( ) ) ; return dis [ k - 1 ] ; }

BLEU: 87.79
Edit Sim: 19


Src: 
function printRLE ( s ) { for ( var i = 0 ; i < s . length ; i ++ ) { var count = 1 ; while ( i + 1 < s . length && s . charAt ( i ) == s . charAt ( i + 1 ) ) { i ++ ; count ++ ; } document . write ( s . charAt ( i ) + " " + count + " " ) ; } document . write ( " " ) ; }
Ref: 
void printRLE ( string s ) { for ( int i = 0 ; s [ i ] != ' \0' ; i ++ ) { int count = 1 ; while ( s [ i ] == s [ i + 1 ] ) { i ++ ; count ++ ; } cout << s [ i ] << count << " ▁ " ; } cout << endl ; }
Hyp: 
void printRLE ( string s ) { for ( int i = 0 ; i < s . length ( ) ; i ++ ) { int count = 1 ; while ( i + 1 < s . length ( ) && s [ i ] == s [ i + 1 ] ) { i ++ ; count ++ ; } cout << s [ i ] << " ▁ " << count << " ▁ " ; } cout << endl ; }

BLEU: 71.42
Edit Sim: 48


Src: 
function nthMagicNo ( n ) { let pow = 1 , answer = 0 ; while ( n != 0 ) { pow = pow * 5 ; if ( ( n & 1 ) == 1 ) answer += pow ; n >>= 1 ; } return answer ; }
Ref: 
int nthMagicNo ( int n ) { int pow = 1 , answer = 0 ; while ( n ) { pow = pow * 5 ; if ( n & 1 ) answer += pow ; } return answer ; }
Hyp: 
int nthMagicNo ( unsigned int n ) { unsigned int pow = 1 , answer = 0 ; while ( n ) { pow = pow * 5 ; if ( ( n & 1 ) == 1 ) answer += pow ; n >>= 1 ; } return answer ; }

BLEU: 70.6
Edit Sim: 37


Src: 
function maxDiff ( arr , n ) { let diff = arr [ 1 ] - arr [ 0 ] ; let curr_sum = diff ; let max_sum = curr_sum ; for ( let i = 1 ; i < n - 1 ; i ++ ) { diff = arr [ i + 1 ] - arr [ i ] ; if ( curr_sum > 0 ) curr_sum += diff ; else curr_sum = diff ; if ( curr_sum > max_sum ) max_sum = curr_sum ; } return max_sum ; }
Ref: 
int maxDiff ( int arr [ ] , int n ) { int diff = arr [ 1 ] - arr [ 0 ] ; int curr_sum = diff ; int max_sum = curr_sum ; for ( int i = 1 ; i < n - 1 ; i ++ ) { diff = arr [ i + 1 ] - arr [ i ] ; if ( curr_sum > 0 ) curr_sum += diff ; else curr_sum = diff ; if ( curr_sum > max_sum ) max_sum = curr_sum ; } return max_sum ; }
Hyp: 
int maxDiff ( int arr [ ] , int n ) { int diff = arr [ 1 ] - arr [ 0 ] ; int curr_sum = diff ; int max_sum = curr_sum ; for ( int i = 1 ; i < n - 1 ; i ++ ) { diff = arr [ i + 1 ] - arr [ i ] ; if ( curr_sum > 0 ) curr_sum += diff ; else curr_sum = diff ; if ( curr_sum > max_sum ) max_sum = curr_sum ; } return max_sum ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findSubArray ( arr , n ) { let sum = 0 ; let maxsize = - 1 , startindex = 0 ; let endindex = 0 ; for ( let i = 0 ; i < n - 1 ; i ++ ) { sum = ( arr [ i ] == 0 ) ? - 1 : 1 ; for ( let j = i + 1 ; j < n ; j ++ ) { if ( arr [ j ] == 0 ) sum += - 1 ; else sum += 1 ; if ( sum == 0 && maxsize < j - i + 1 ) { maxsize = j - i + 1 ; startindex = i ; } } } endindex = startindex + maxsize - 1 ; if ( maxsize == - 1 ) document . write ( " " ) ; else document . write ( startindex + " " + endindex ) ; return maxsize ; }
Ref: 
int findSubArray ( int arr [ ] , int n ) { int sum = 0 ; int maxsize = -1 , startindex ; for ( int i = 0 ; i < n - 1 ; i ++ ) { sum = ( arr [ i ] == 0 ) ? -1 : 1 ; for ( int j = i + 1 ; j < n ; j ++ ) { ( arr [ j ] == 0 ) ? ( sum += -1 ) : ( sum += 1 ) ; if ( sum == 0 && maxsize < j - i + 1 ) { maxsize = j - i + 1 ; startindex = i ; } } } if ( maxsize == -1 ) cout << " No ▁ such ▁ subarray " ; else cout << startindex << " ▁ to ▁ " << startindex + maxsize - 1 ; return maxsize ; }
Hyp: 
int findSubArray ( int arr [ ] , int n ) { int sum = 0 , maxsize = -1 , startindex = 0 , endindex = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { sum = ( arr [ i ] == 0 ) ? -1 : 1 ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ j ] == 0 ) sum += -1 ; else sum += 1 ; if ( sum == 0 && maxsize < j - i + 1 ) { maxsize = j - i + 1 ; startindex = i ; } } } endindex = startindex + maxsize - 1 ; if ( maxsize == -1 ) cout << " -1" ; else cout << startindex << " ▁ " << endindex ; return maxsize ; }

BLEU: 80.74
Edit Sim: 115


Src: 
function averageEven ( n ) { if ( n % 2 != 0 ) { document . write ( " " ) ; return - 1 ; } return ( n + 2 ) / 2 ; }
Ref: 
int averageEven ( int n ) { if ( n % 2 != 0 ) { cout << " Invalid ▁ Input " ; return -1 ; } return ( n + 2 ) / 2 ; }
Hyp: 
int averageEven ( int n ) { if ( n % 2 != 0 ) { cout << " Even " ; return -1 ; } return ( n + 2 ) / 2 ; }

BLEU: 87.78
Edit Sim: 13


Src: 
function printRoots ( a , b , c ) { document . write ( 1 + " " + c / ( a * 1.0 ) ) ; }
Ref: 
void printRoots ( long a , long b , long c ) { cout << 1 << " , ▁ " << c / ( a * 1.0 ) ; }
Hyp: 
void printRoots ( double a , double b , double c ) { cout << 1 << " / " << c / ( a * 1.0 ) << endl ; }

BLEU: 56.78
Edit Sim: 26


Src: 
function maxGCD ( N ) { for ( var i = 2 ; i * i <= N ; i ++ ) { if ( N % i == 0 ) { return N / i ; } } return 1 ; }
Ref: 
int maxGCD ( int N ) { for ( int i = 2 ; i * i <= N ; i ++ ) { if ( N % i == 0 ) { return N / i ; } } return 1 ; }
Hyp: 
int maxGCD ( int N ) { for ( int i = 2 ; i * i <= N ; i ++ ) { if ( N % i == 0 ) { return N / i ; } } return 1 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function numbersWith3Divisors ( n ) { let prime = new Array ( n + 1 ) ; prime . fill ( true ) ; prime [ 0 ] = prime [ 1 ] = 0 ; for ( let p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( let i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } document . write ( " " + " " ) ; for ( let i = 0 ; i * i <= n ; i ++ ) if ( prime [ i ] ) document . write ( i * i + " " ) ; }
Ref: 
void numbersWith3Divisors ( int n ) { bool prime [ n + 1 ] ; memset ( prime , true , sizeof ( prime ) ) ; prime [ 0 ] = prime [ 1 ] = 0 ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } cout << " Numbers ▁ with ▁ 3 ▁ divisors ▁ : STRNEWLINE " ; for ( int i = 0 ; i * i <= n ; i ++ ) if ( prime [ i ] ) cout << i * i << " ▁ " ; }
Hyp: 
void numbersWith3Divisors ( int n ) { bool prime [ n + 1 ] ; memset ( prime , true , sizeof ( prime ) ) ; prime [ 0 ] = prime [ 1 ] = 0 ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } cout << " Yes " << endl ; for ( int i = 0 ; i * i <= n ; i ++ ) if ( prime [ i ] ) cout << i * i << " ▁ " ; }

BLEU: 91.16
Edit Sim: 40


Src: 
function findEquation ( x1 , y1 , z1 , x2 , y2 , z2 , d , e , f ) { var a = x2 - x1 ; var b = y2 - y1 ; var c = z2 - z1 ; var A = parseInt ( ( b * f - c * e ) ) ; var B = parseInt ( ( a * f - c * d ) ) ; var C = parseInt ( ( a * e - b * d ) ) ; var D = - parseInt ( ( A * d - B * e + C * f ) ) ; document . write ( A + " " + B + " " + C + " " + D + " " ) ; }
Ref: 
void findEquation ( int x1 , int y1 , int z1 , int x2 , int y2 , int z2 , int d , int e , int f ) { double a = x2 - x1 ; double b = y2 - y1 ; double c = z2 - z1 ; int A = ( b * f - c * e ) ; int B = ( a * f - c * d ) ; int C = ( a * e - b * d ) ; int D = - ( A * d - B * e + C * f ) ; cout << A << " x ▁ + ▁ " << B << " y ▁ + ▁ " << C << " z ▁ + ▁ " << D << " = ▁ 0" ; }
Hyp: 
void findEquation ( int x1 , int y1 , int z1 , int x2 , int y2 , int z2 , int d , int e , int f ) { int a = x2 - x1 ; int b = y2 - y1 ; int c = z2 - z1 ; int A = ( b * f - c * e ) ; int B = ( a * f - c * d ) ; int C = ( a * e - b * d ) ; int D = - ( ( A * d - B * e + C * f ) ) ; cout << A << " ▁ " << B << " ▁ " << C << " ▁ " << D << " STRNEWLINE " ; }

BLEU: 81.2
Edit Sim: 51


Src: 
function min_modulo ( l , r ) { if ( r - l >= MOD ) return 0 ; else { let ans = MOD - 1 ; for ( let i = l ; i <= r ; i ++ ) { for ( let j = i + 1 ; j <= r ; j ++ ) { ans = Math . min ( ans , ( i * j ) % MOD ) ; } } return ans ; } }
Ref: 
int min_modulo ( int l , int r ) { if ( r - l >= MOD ) return 0 ; else { int ans = MOD - 1 ; for ( int i = l ; i <= r ; i ++ ) { for ( int j = i + 1 ; j <= r ; j ++ ) { ans = min ( ans , ( i * j ) % MOD ) ; } } return ans ; } }
Hyp: 
int min_modulo ( int l , int r ) { if ( r - l >= MOD ) return 0 ; else { int ans = MOD - 1 ; for ( int i = l ; i <= r ; i ++ ) { for ( int j = i + 1 ; j <= r ; j ++ ) { ans = min ( ans , ( i * j ) % MOD ) ; } } return ans ; } }

BLEU: 100.0
Edit Sim: 0


Src: 
function findTwoThreePrime ( l , r ) { if ( l == 1 ) l ++ ; let count = 0 ; for ( let i = l ; i <= r ; i ++ ) { let num = i ; while ( num % 2 == 0 ) num = parseInt ( num / 2 , 10 ) ; while ( num % 3 == 0 ) num = parseInt ( num / 3 , 10 ) ; if ( num == 1 ) count ++ ; } return count ; }
Ref: 
int findTwoThreePrime ( int l , int r ) { if ( l == 1 ) l ++ ; int count = 0 ; for ( int i = l ; i <= r ; i ++ ) { int num = i ; while ( num % 2 == 0 ) num /= 2 ; while ( num % 3 == 0 ) num /= 3 ; if ( num == 1 ) count ++ ; } return count ; }
Hyp: 
int findTwoThreePrime ( int l , int r ) { if ( l == 1 ) l ++ ; int count = 0 ; for ( int i = l ; i <= r ; i ++ ) { int num = i ; while ( num % 2 == 0 ) num = num / 2 ; while ( num % 3 == 0 ) num = num / 3 ; if ( num == 1 ) count ++ ; } return count ; }

BLEU: 89.4
Edit Sim: 14


Src: 
function count_min_length ( s ) { var hash = new Array ( 26 ) . fill ( 0 ) ; var ans = 2147483648 ; for ( var i = 0 ; i < 26 ; i ++ ) hash [ i ] = - 1 ; for ( var i = 0 ; i < s . length ; i ++ ) { if ( hash [ s [ i ] . charCodeAt ( 0 ) - " " . charCodeAt ( 0 ) ] == - 1 ) hash [ s [ i ] . charCodeAt ( 0 ) - " " . charCodeAt ( 0 ) ] = i ; else { if ( hash [ s [ i ] . charCodeAt ( 0 ) - " " . charCodeAt ( 0 ) ] == i - 1 || hash [ s [ i ] . charCodeAt ( 0 ) - " " . charCodeAt ( 0 ) ] == i - 2 ) return 0 ; ans = Math . min ( ans , i - hash [ s [ i ] . charCodeAt ( 0 ) - " " . charCodeAt ( 0 ) ] - 1 ) ; hash [ s [ i ] . charCodeAt ( 0 ) - " " . charCodeAt ( 0 ) ] = i ; } } if ( ans === 2147483648 ) return - 1 ; return ans ; }
Ref: 
int count_min_length ( string s ) { int hash [ 26 ] ; int ans = INT_MAX ; for ( int i = 0 ; i < 26 ; i ++ ) hash [ i ] = -1 ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { if ( hash [ s [ i ] - ' a ' ] == -1 ) hash [ s [ i ] - ' a ' ] = i ; else { if ( hash [ s [ i ] - ' a ' ] == i - 1 hash [ s [ i ] - ' a ' ] == i - 2 ) return 0 ; ans = min ( ans , i - hash [ s [ i ] - ' a ' ] - 1 ) ; hash [ s [ i ] - ' a ' ] = i ; } } if ( ans == INT_MAX ) return -1 ; return ans ; }
Hyp: 
int count_min_length ( string s ) { int hash [ 26 ] ; int ans = 2147483648 ; for ( int i = 0 ; i < 26 ; i ++ ) hash [ i ] = -1 ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { if ( hash [ s [ i ] - ' a ' ] == -1 ) hash [ s [ i ] - ' a ' ] = i ; else { if ( hash [ s [ i ] - ' a ' ] == i - 1 || hash [ s [ i ] - ' a ' ] == i - 2 ) return 0 ; ans = min ( ans , i - hash [ s [ i ] - ' a ' ] - 1 ) ; hash [ s [ i ] - ' a ' ] = i ; } } if ( ans == 2147483648 ) return -1 ; return ans ; }

BLEU: 95.77
Edit Sim: 23


Src: 
function countMinSteps ( arr , target , n ) { arr = arr . sort ( function ( a , b ) { return a - b ; } ) ; var minimumSteps = 0 ; var i = 0 , j = n - 1 ; while ( i <= j ) { if ( arr [ i ] + arr [ j ] <= target ) { i ++ ; j -- ; } else { j -- ; } minimumSteps ++ ; } return minimumSteps ; }
Ref: 
int countMinSteps ( int arr [ ] , int target , int n ) { sort ( arr , arr + n ) ; int minimumSteps = 0 ; int i = 0 , j = n - 1 ; while ( i <= j ) { if ( arr [ i ] + arr [ j ] <= target ) { i ++ ; j -- ; } else { j -- ; } minimumSteps ++ ; } return minimumSteps ; }
Hyp: 
int countMinSteps ( int arr [ ] , int target , int n ) { sort ( arr , arr + n ) ; int minimumSteps = 0 ; int i = 0 , j = n - 1 ; while ( i <= j ) { if ( arr [ i ] + arr [ j ] <= target ) { i ++ ; j -- ; } else { j -- ; } minimumSteps ++ ; } return minimumSteps ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function Avgdifference ( arr , N , K ) { let sum = 0 ; for ( let i = 0 ; i < K ; i ++ ) sum += arr [ i ] ; let min = sum ; let max = sum ; for ( let i = K ; i <= N - K + 1 ; i ++ ) { sum += arr [ i ] - arr [ i - K ] ; if ( min > sum ) min = sum ; if ( max < sum ) max = sum ; } return ( max - min ) / K ; }
Ref: 
double Avgdifference ( double arr [ ] , int N , int K ) { double sum = 0 ; for ( int i = 0 ; i < K ; i ++ ) sum += arr [ i ] ; double min = sum ; double max = sum ; for ( int i = K ; i <= N - K + 1 ; i ++ ) { sum += arr [ i ] - arr [ i - K ] ; if ( min > sum ) min = sum ; if ( max < sum ) max = sum ; } return ( max - min ) / K ; }
Hyp: 
float Avgdifference ( int arr [ ] , int N , int K ) { int sum = 0 ; for ( int i = 0 ; i < K ; i ++ ) sum += arr [ i ] ; int minn = sum ; int maxx = sum ; for ( int i = K ; i <= N - K + 1 ; i ++ ) { sum += arr [ i ] - arr [ i - K ] ; if ( min > sum ) minn = sum ; if ( max < sum ) max = sum ; } return ( max - min ) / K ; }

BLEU: 86.51
Edit Sim: 33


Src: 
function find_greatest_divisor ( l , r ) { if ( l == r ) return l ; return 1 ; }
Ref: 
int find_greatest_divisor ( int l , int r ) { if ( l == r ) return l ; return 1 ; }
Hyp: 
int find_greatest_divisor ( int l , int r ) { if ( l == r ) return l ; return 1 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function areAllBitsSet ( n ) { if ( n == 0 ) return " " ; if ( ( ( n + 1 ) & n ) == 0 ) return " " ; return " " ; }
Ref: 
string areAllBitsSet ( int n ) { if ( n == 0 ) return " No " ; if ( ( ( n + 1 ) & n ) == 0 ) return " Yes " ; return " No " ; }
Hyp: 
string areAllBitsSet ( int n ) { if ( n == 0 ) return " No " ; if ( ( ( n + 1 ) & n ) == 0 ) return " Yes " ; return " No " ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function noAdjacentDup ( s1 ) { let n = s1 . length ; let s = s1 . split ( ' ' ) ; for ( let i = 1 ; i < n ; i ++ ) { if ( s [ i ] == s [ i - 1 ] ) { s [ i ] = ' ' ; while ( s [ i ] == s [ i - 1 ] || ( i + 1 < n && s [ i ] == s [ i + 1 ] ) ) s [ i ] ++ ; i ++ ; } } return ( s ) ; }
Ref: 
string noAdjacentDup ( string s ) { int n = s . length ( ) ; for ( int i = 1 ; i < n ; i ++ ) { if ( s [ i ] == s [ i - 1 ] ) { s [ i ] = ' a ' ; while ( s [ i ] == s [ i - 1 ] || ( i + 1 < n && s [ i ] == s [ i + 1 ] ) ) s [ i ] ++ ; i ++ ; } } return s ; }
Hyp: 
string noAdjacentDup ( string s1 ) { int n = s1 . length ( ) ; string s ( s1 ) ; for ( int i = 1 ; i < n ; i ++ ) { if ( s [ i ] == s [ i - 1 ] ) { s [ i ] = '0' ; while ( s [ i ] == s [ i - 1 ] || ( i + 1 < n && s [ i ] == s [ i + 1 ] ) ) s [ i ] ++ ; i ++ ; } } return ( s ) ; }

BLEU: 84.27
Edit Sim: 27


Src: 
function fib ( n ) { if ( n <= 1 ) return n ; return fib ( n - 1 ) + fib ( n - 2 ) ; }
Ref: 
int fib ( int n ) { if ( n <= 1 ) return n ; return fib ( n - 1 ) + fib ( n - 2 ) ; }
Hyp: 
int fib ( int n ) { if ( n <= 1 ) return n ; return fib ( n - 1 ) + fib ( n - 2 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findDay ( Y , B ) { let lyear , rest , totaldays , day ; Y = ( Y - 1 ) - B ; lyear = Math . floor ( Y / 4 ) ; rest = Y - lyear ; totaldays = ( rest * 365 ) + ( lyear * 366 ) + 1 ; day = ( totaldays % 7 ) ; if ( day == 0 ) document . write ( " " ) ; else if ( day == 1 ) document . write ( " " ) ; else if ( day == 2 ) document . write ( " " ) ; else if ( day == 3 ) document . write ( " " ) ; else if ( day == 4 ) document . write ( " " ) ; else if ( day == 5 ) document . write ( " " ) ; else if ( day == 6 ) document . write ( " " ) ; else document . write ( " " ) ; }
Ref: 
void findDay ( int Y , int B ) { int lyear , rest , totaldays , day ; Y = ( Y - 1 ) - B ; lyear = Y / 4 ; rest = Y - lyear ; totaldays = ( rest * 365 ) + ( lyear * 366 ) + 1 ; day = ( totaldays % 7 ) ; if ( day == 0 ) printf ( " Monday " ) ; else if ( day == 1 ) printf ( " Tuesday " ) ; else if ( day == 2 ) printf ( " Wednesday " ) ; else if ( day == 3 ) printf ( " Thursday " ) ; else if ( day == 4 ) printf ( " Friday " ) ; else if ( day == 5 ) printf ( " Saturday " ) ; else if ( day == 6 ) printf ( " Sunday " ) ; else printf ( " INPUT ▁ YEAR ▁ IS ▁ WRONG ! " ) ; }
Hyp: 
void findDay ( int Y , int B ) { int lyear , rest , totaldays , day ; Y = ( Y - 1 ) - B ; lyear = Y / 4 ; rest = Y - lyear ; totaldays = ( rest * 365 ) + ( lyear * 366 ) + 1 ; day = ( totaldays % 7 ) ; if ( day == 0 ) cout << " Yes " ; else if ( day == 1 ) cout << " No " ; else if ( day == 2 ) cout << " Yes " ; else if ( day == 3 ) cout << " Yes " ; else if ( day == 4 ) cout << " No " ; else if ( day == 5 ) cout << " Yes " ; else if ( day == 6 ) cout << " Yes " ; else cout << " No " ; }

BLEU: 63.99
Edit Sim: 145


Src: 
function getInvCount ( arr , n ) { let invcount = 0 ; for ( let i = 0 ; i < n - 1 ; i ++ ) { let small = 0 ; for ( let j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] > arr [ j ] ) small ++ ; let great = 0 ; for ( let j = i - 1 ; j >= 0 ; j -- ) if ( arr [ i ] < arr [ j ] ) great ++ ; invcount += great * small ; } return invcount ; }
Ref: 
int getInvCount ( int arr [ ] , int n ) { int invcount = 0 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { int small = 0 ; for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] > arr [ j ] ) small ++ ; int great = 0 ; for ( int j = i - 1 ; j >= 0 ; j -- ) if ( arr [ i ] < arr [ j ] ) great ++ ; invcount += great * small ; } return invcount ; }
Hyp: 
int getInvCount ( int arr [ ] , int n ) { int invcount = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int small = 0 ; for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] > arr [ j ] ) small ++ ; int great = 0 ; for ( int j = i - 1 ; j >= 0 ; j -- ) if ( arr [ i ] < arr [ j ] ) great ++ ; invcount += great * small ; } return invcount ; }

BLEU: 97.84
Edit Sim: 1


Src: 
function findMinDifference ( arr , n ) { arr . sort ( ) ; let diff1 = arr [ n - 1 ] - arr [ 1 ] ; let diff2 = arr [ n - 2 ] - arr [ 0 ] ; return Math . min ( diff1 , diff2 ) ; }
Ref: 
int findMinDifference ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int diff1 = arr [ n - 1 ] - arr [ 1 ] ; int diff2 = arr [ n - 2 ] - arr [ 0 ] ; return min ( diff1 , diff2 ) ; }
Hyp: 
int findMinDifference ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int diff1 = arr [ n - 1 ] - arr [ 1 ] ; int diff2 = arr [ n - 2 ] - arr [ 0 ] ; return min ( diff1 , diff2 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function maxPointOfIntersection ( x , y ) { let k = y * ( y - 1 ) / 2 ; k = k + x * ( 2 * y + x - 1 ) ; return k ; }
Ref: 
int maxPointOfIntersection ( int x , int y ) { int k = y * ( y - 1 ) / 2 ; k = k + x * ( 2 * y + x - 1 ) ; return k ; }
Hyp: 
int maxPointOfIntersection ( int x , int y ) { int k = y * ( y - 1 ) / 2 ; k = k + x * ( 2 * y + x - 1 ) ; return k ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function isPossible ( A , B , n , m , x , y ) { if ( x > n y > m ) return false ; A . sort ( ) ; B . sort ( ) ; if ( A [ x - 1 ] < B [ m - y ] ) return true ; else return false ; }
Ref: 
bool isPossible ( int A [ ] , int B [ ] , int n , int m , int x , int y ) { if ( x > n y > m ) return false ; sort ( A , A + n ) ; sort ( B , B + m ) ; if ( A [ x - 1 ] < B [ m - y ] ) return true ; else return false ; }
Hyp: 
bool isPossible ( int A [ ] , int B [ ] , int n , int m , int x , int y ) { if ( x > n y > m ) return false ; sort ( A , A + n ) ; sort ( B , B + m ) ; if ( A [ x - 1 ] < B [ m - y ] ) return true ; else return false ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function subsetSum ( arr , n , i , sum , count ) { if ( i == n ) { if ( sum == 0 ) { count ++ ; } return count ; } count = subsetSum ( arr , n , i + 1 , sum - arr [ i ] , count ) ; count = subsetSum ( arr , n , i + 1 , sum , count ) ; return count ; }
Ref: 
int subsetSum ( int arr [ ] , int n , int i , int sum , int count ) { if ( i == n ) { if ( sum == 0 ) { count ++ ; } return count ; } count = subsetSum ( arr , n , i + 1 , sum - arr [ i ] , count ) ; count = subsetSum ( arr , n , i + 1 , sum , count ) ; return count ; }
Hyp: 
int subsetSum ( int arr [ ] , int n , int i , int sum , int count ) { if ( i == n ) { if ( sum == 0 ) { count ++ ; } return count ; } count = subsetSum ( arr , n , i + 1 , sum - arr [ i ] , count ) ; count = subsetSum ( arr , n , i + 1 , sum , count ) ; return count ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function nthTerm ( N ) { let nth = 0 ; if ( N % 2 == 1 ) nth = ( N * N ) + 1 ; else nth = ( N * N ) - 1 ; return nth ; }
Ref: 
int nthTerm ( int N ) { int nth = 0 ; if ( N % 2 == 1 ) nth = ( N * N ) + 1 ; else nth = ( N * N ) - 1 ; return nth ; }
Hyp: 
int nthTerm ( int N ) { int nth = 0 ; if ( N % 2 == 1 ) nth = ( N * N ) + 1 ; else nth = ( N * N ) - 1 ; return nth ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function swapThree ( ) { a = a ^ b ^ c ; b = a ^ b ^ c ; c = a ^ b ^ c ; a = a ^ b ^ c ; }
Ref: 
void swapThree ( int & a , int & b , int & c ) { a = a ^ b ^ c ; b = a ^ b ^ c ; c = a ^ b ^ c ; a = a ^ b ^ c ; }
Hyp: 
void swapThree ( int a , int b , int c ) { a = a ^ b ^ c ; b = a ^ b ^ c ; c = a ^ b ^ c ; a = a ^ b ^ c ; }

BLEU: 83.94
Edit Sim: 6


Src: 
function rearrange ( A , B , N , X ) { let flag = true ; A . sort ( ) ; B . sort ( ) ; for ( let i = 0 ; i < N ; i ++ ) { if ( A [ i ] + B [ N - 1 - i ] > X ) { flag = false ; break ; } } if ( flag == true ) document . write ( " " ) ; else document . write ( " " ) ; }
Ref: 
void rearrange ( int A [ ] , int B [ ] , int N , int X ) { bool flag = true ; sort ( A , A + N ) ; sort ( B , B + N , greater < int > ( ) ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( A [ i ] + B [ i ] > X ) { flag = false ; break ; } } if ( flag ) cout << " Yes " ; else cout << " No " ; }
Hyp: 
void rearrange ( int A [ ] , int B [ ] , int N , int X ) { bool flag = true ; sort ( A , A + N ) ; sort ( B , B + N - 1 ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( A [ i ] + B [ N - 1 - i ] > X ) { flag = false ; break ; } } if ( flag == true ) cout << " Yes " ; else cout << " No " ; }

BLEU: 88.17
Edit Sim: 36


Src: 
function findMinDenomin ( n ) { return ( Math . floor ( Math . log ( n ) / Math . log ( 2 ) ) + 1 ) ; }
Ref: 
int findMinDenomin ( int n ) { return log2 ( n ) + 1 ; }
Hyp: 
int findMinDenomin ( int n ) { return ( floor ( log2 ( n ) ) + 1 ) ; }

BLEU: 55.5
Edit Sim: 14


Src: 
function fibonacci ( n ) { var fib ; for ( i = 0 ; i < n ; i ++ ) { fib = ( Math . pow ( ( 1 + Math . sqrt ( 5 ) ) , i ) - Math . pow ( ( 1 - Math . sqrt ( 5 ) ) , i ) ) / ( Math . pow ( 2 , i ) * Math . sqrt ( 5 ) ) ; document . write ( parseInt ( fib ) + " " ) ; } }
Ref: 
void fibonacci ( int n ) { long long int fib ; for ( long long int i = 0 ; i < n ; i ++ ) { fib = ( pow ( ( 1 + sqrt ( 5 ) ) , i ) - pow ( ( 1 - sqrt ( 5 ) ) , i ) ) / ( pow ( 2 , i ) * sqrt ( 5 ) ) ; cout << fib << " ▁ " ; } }
Hyp: 
void fibonacci ( int n ) { double fib ; for ( int i = 0 ; i < n ; i ++ ) { fib = ( pow ( ( 1 + sqrt ( 5 ) ) , i ) - pow ( ( 1 - sqrt ( 5 ) ) , i ) ) / ( pow ( 2 , i ) * sqrt ( 5 ) ) ; cout << fib << " ▁ " ; } }

BLEU: 90.37
Edit Sim: 21


Src: 
function findFirstMissing ( array , start , end ) { if ( start > end ) return end + 1 ; if ( start != array [ start ] ) return start ; let mid = parseInt ( ( start + end ) / 2 , 10 ) ; if ( array [ mid ] == mid ) return findFirstMissing ( array , mid + 1 , end ) ; return findFirstMissing ( array , start , mid ) ; }
Ref: 
int findFirstMissing ( int array [ ] , int start , int end ) { if ( start > end ) return end + 1 ; if ( start != array [ start ] ) return start ; int mid = ( start + end ) / 2 ; if ( array [ mid ] == mid ) return findFirstMissing ( array , mid + 1 , end ) ; return findFirstMissing ( array , start , mid ) ; }
Hyp: 
int findFirstMissing ( int array [ ] , int start , int end ) { if ( start > end ) return end + 1 ; if ( start != array [ start ] ) return start ; int mid = ( start + end ) / 2 ; if ( array [ mid ] == mid ) return findFirstMissing ( array , mid + 1 , end ) ; return findFirstMissing ( array , start , mid ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function minimumOperations ( S , N ) { let ans = 0 ; let cntOne = 0 ; for ( let i = N - 1 ; i >= 0 ; i -- ) { if ( S [ i ] == ' ' ) { ans += cntOne ; cntOne *= 2 ; } else cntOne ++ ; } document . write ( ans ) ; }
Ref: 
void minimumOperations ( string S , int N ) { int ans = 0 ; int cntOne = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( S [ i ] == '0' ) { ans += cntOne ; cntOne *= 2 ; } else cntOne ++ ; } cout << ans ; }
Hyp: 
void minimumOperations ( string S , int N ) { int ans = 0 ; int cntOne = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( S [ i ] == '1' ) { ans += cntOne ; cntOne *= 2 ; } else cntOne ++ ; } cout << ans ; }

BLEU: 96.14
Edit Sim: 1


Src: 
function countSubsequences ( arr ) { let odd = 0 ; let even = 0 ; for ( let x of arr ) { if ( x & 1 ) odd ++ ; else even ++ ; } return ( ( 1 << odd ) - 1 ) * ( 1 << even ) ; }
Ref: 
int countSubsequences ( vector < int > arr ) { int odd = 0 ; int even = 0 ; for ( int x : arr ) { if ( x & 1 ) odd ++ ; else even ++ ; } return ( ( 1 << odd ) - 1 ) * ( 1 << even ) ; }
Hyp: 
int countSubsequences ( int arr [ ] , int n ) { int odd = 0 ; int even = 0 ; for ( int x : arr ) { if ( x & 1 ) odd ++ ; else even ++ ; } return ( ( 1 << odd ) - 1 ) * ( 1 << even ) ; }

BLEU: 86.88
Edit Sim: 15


Src: 
function sumOfSubarrayProd ( arr , n ) { let ans = 0 ; let res = 0 ; for ( let i = n - 1 ; i >= 0 ; i -- ) { let incr = arr [ i ] * ( 1 + res ) ; ans += incr ; res = incr ; } document . write ( ans ) ; }
Ref: 
void sumOfSubarrayProd ( int arr [ ] , int n ) { int ans = 0 ; int res = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { int incr = arr [ i ] * ( 1 + res ) ; ans += incr ; res = incr ; } cout << ( ans ) ; }
Hyp: 
int sumOfSubarrayProd ( int arr [ ] , int n ) { int ans = 0 ; int res = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { int incr = arr [ i ] * ( 1 + res ) ; ans += incr ; res = incr ; } cout << ans ; }

BLEU: 92.63
Edit Sim: 8


Src: 
function minElements ( arr , n ) { let halfSum = 0 ; for ( let i = 0 ; i < n ; i ++ ) halfSum = halfSum + arr [ i ] ; halfSum = parseInt ( halfSum / 2 , 10 ) ; arr . sort ( function ( a , b ) { return a - b } ) ; arr . reverse ( ) ; let res = 0 , curr_sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { curr_sum += arr [ i ] ; res ++ ; if ( curr_sum > halfSum ) return res ; } return res ; }
Ref: 
int minElements ( int arr [ ] , int n ) { int halfSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) halfSum = halfSum + arr [ i ] ; halfSum = halfSum / 2 ; sort ( arr , arr + n , greater < int > ( ) ) ; int res = 0 , curr_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { curr_sum += arr [ i ] ; res ++ ; if ( curr_sum > halfSum ) return res ; } return res ; }
Hyp: 
int minElements ( int arr [ ] , int n ) { int halfSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) halfSum = halfSum + arr [ i ] ; halfSum = halfSum / 2 ; sort ( arr , arr + n , greater < int > ( ) ) ; int res = 0 , curr_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { curr_sum += arr [ i ] ; res ++ ; if ( curr_sum > halfSum ) return res ; } return res ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function Count_numbers ( L , R ) { var count = ( R - L ) / 2 ; if ( R % 2 != 0 L % 2 != 0 ) count += 1 ; document . write ( count ) ; }
Ref: 
void Count_numbers ( int L , int R ) { int count = ( R - L ) / 2 ; if ( R % 2 != 0 L % 2 != 0 ) count += 1 ; cout << count << endl ; }
Hyp: 
void Count_numbers ( int L , int R ) { int count = ( R - L ) / 2 ; if ( R % 2 != 0 L % 2 != 0 ) count += 1 ; cout << count ; }

BLEU: 92.58
Edit Sim: 8


Src: 
function XOROfElements ( arr , n ) { var FirstHalfXOR = 0 ; var SecondHalfXOR = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( i < parseInt ( n / 2 ) ) FirstHalfXOR ^= arr [ i ] ; else SecondHalfXOR ^= arr [ i ] ; } document . write ( FirstHalfXOR + " " + SecondHalfXOR + " " ) ; }
Ref: 
void XOROfElements ( int arr [ ] , int n ) { int FirstHalfXOR = 0 ; int SecondHalfXOR = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i < n / 2 ) FirstHalfXOR ^= arr [ i ] ; else SecondHalfXOR ^= arr [ i ] ; } cout << FirstHalfXOR << " , " << SecondHalfXOR << endl ; }
Hyp: 
void XOROfElements ( int arr [ ] , int n ) { int FirstHalfXOR = 0 ; int SecondHalfXOR = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i < n / 2 ) FirstHalfXOR ^= arr [ i ] ; else SecondHalfXOR ^= arr [ i ] ; } cout << FirstHalfXOR << " ^ " << SecondHalfXOR << " STRNEWLINE " ; }

BLEU: 90.98
Edit Sim: 15


Src: 
function separateChar ( str ) { var n = str . length , digitSum = 0 ; var alphabetSum = 0 , j = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( str [ i ] >= ' ' && str [ i ] <= ' ' ) digitSum += ( str [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ) ; else { alphabetSum += ( str [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) + 1 ) ; alphabetSum %= 26 ; } } var sumStr = digitSum . toString ( ) ; var alphabetStr = String . fromCharCode ( alphabetSum + ' ' . charCodeAt ( 0 ) - 1 ) ; sumStr += alphabetStr ; return sumStr ; }
Ref: 
string separateChar ( string str ) { int n = str . size ( ) , digitSum = 0 ; int alphabetSum = 0 , j = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( isdigit ( str [ i ] ) ) digitSum += str [ i ] - '0' ; else { alphabetSum += str [ i ] - ' a ' + 1 ; alphabetSum %= 26 ; } } string sumStr = to_string ( digitSum ) ; char alphabetStr = char ( alphabetSum + ' a ' - 1 ) ; sumStr += alphabetStr ; return sumStr ; }
Hyp: 
string separateChar ( string str ) { int n = str . length ( ) , digitSum = 0 , alphabetSum = 0 , j = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] >= ' A ' && str [ i ] <= ' Z ' ) digitSum += ( str [ i ] - ' A ' ) ; else { alphabetSum += ( str [ i ] - ' A ' + 1 ) ; alphabetSum %= 26 ; } } string sumStr = digitSum . toString ( ) ; char alphabetStr = alphabetSum + ' ▁ ' - 1 ; sumStr += alphabetStr ; return sumStr ; }

BLEU: 63.51
Edit Sim: 78


Src: 
function squarearea ( r ) { if ( r < 0 ) return - 1 ; var a = 4 * ( Math . pow ( r , 2 ) / 5 ) ; return a ; }
Ref: 
float squarearea ( float r ) { if ( r < 0 ) return -1 ; float a = 4 * ( pow ( r , 2 ) / 5 ) ; return a ; }
Hyp: 
float squarearea ( float r ) { if ( r < 0 ) return -1 ; float a = 4 * pow ( r , 2 ) / 5 ; return a ; }

BLEU: 85.37
Edit Sim: 4


Src: 
function getFirstElement ( a , N , K , M ) { K %= N ; let index ; if ( K >= M ) index = ( N - K ) + ( M - 1 ) ; else index = ( M - K - 1 ) ; let result = a [ index ] ; return result ; }
Ref: 
int getFirstElement ( int a [ ] , int N , int K , int M ) { K %= N ; int index ; if ( K >= M ) index = ( N - K ) + ( M - 1 ) ; else index = ( M - K - 1 ) ; int result = a [ index ] ; return result ; }
Hyp: 
int getFirstElement ( int a [ ] , int N , int K , int M ) { K %= N ; if ( K >= M ) index = ( N - K ) + ( M - 1 ) ; else index = ( M - K - 1 ) ; int result = a [ index ] ; return result ; }

BLEU: 94.35
Edit Sim: 12


Src: 
function maxCost ( mat , N ) { let dp = new Array ( N ) ; for ( let i = 0 ; i < N ; i ++ ) { dp [ i ] = new Array ( N ) ; for ( let j = 0 ; j < N ; j ++ ) { dp [ i ] [ j ] = 0 ; } } dp [ 0 ] [ 0 ] = mat [ 0 ] [ 0 ] ; for ( let i = 1 ; i < N ; i ++ ) dp [ i ] [ 0 ] = mat [ i ] [ 0 ] + dp [ i - 1 ] [ 0 ] ; for ( let i = 1 ; i < N ; i ++ ) for ( let j = 1 ; j < i + 1 && j < N ; j ++ ) dp [ i ] [ j ] = mat [ i ] [ j ] + Math . max ( dp [ i - 1 ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ; let result = 0 ; for ( let i = 0 ; i < N ; i ++ ) if ( result < dp [ N - 1 ] [ i ] ) result = dp [ N - 1 ] [ i ] ; return result ; }
Ref: 
int maxCost ( int mat [ ] [ MAX ] , int N ) { int dp [ N ] [ N ] ; memset ( dp , 0 , sizeof ( dp ) ) ; dp [ 0 ] [ 0 ] = mat [ 0 ] [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) dp [ i ] [ 0 ] = mat [ i ] [ 0 ] + dp [ i - 1 ] [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) for ( int j = 1 ; j < i + 1 && j < N ; j ++ ) dp [ i ] [ j ] = mat [ i ] [ j ] + max ( dp [ i - 1 ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ; int result = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( result < dp [ N - 1 ] [ i ] ) result = dp [ N - 1 ] [ i ] ; return result ; }
Hyp: 
int maxCost ( int mat [ ] [ MAX ] , int N ) { int dp [ N + 1 ] [ MAX ] ; memset ( dp , 0 , sizeof ( dp ) ) ; dp [ 0 ] [ 0 ] = mat [ 0 ] [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) dp [ i ] [ 0 ] = mat [ i ] [ 0 ] + dp [ i - 1 ] [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) for ( int j = 1 ; j < i + 1 && j < N ; j ++ ) dp [ i ] [ j ] = mat [ i ] [ j ] + max ( dp [ i - 1 ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ; int result = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( result < dp [ N - 1 ] [ i ] ) result = dp [ N - 1 ] [ i ] ; return result ; }

BLEU: 97.35
Edit Sim: 7


Src: 
function convertToDecimal ( N ) { document . write ( " " + N + " " ) ; if ( N != 0 ) { let decimalNumber = 0 ; let i = 0 , remainder ; while ( N != 0 ) { remainder = N % 10 ; N = parseInt ( N / 10 , 10 ) ; decimalNumber += remainder * Math . pow ( 3 , i ) ; ++ i ; } document . write ( decimalNumber + " " ) ; } else document . write ( " " + " " ) ; }
Ref: 
void convertToDecimal ( int N ) { cout << " Decimal ▁ number ▁ of ▁ " << N << " ▁ is : ▁ " ; if ( N != 0 ) { int decimalNumber = 0 , i = 0 , remainder ; while ( N != 0 ) { remainder = N % 10 ; N /= 10 ; decimalNumber += remainder * pow ( 3 , i ) ; ++ i ; } cout << decimalNumber << endl ; } else cout << "0" << endl ; }
Hyp: 
void convertToDecimal ( int N ) { cout << " Converting to decimal : " << N << endl ; if ( N != 0 ) { int decimalNumber = 0 ; int i = 0 , remainder ; while ( N != 0 ) { remainder = N % 10 ; N = N / 10 ; decimalNumber += remainder * pow ( 3 , i ) ; ++ i ; } cout << decimalNumber << endl ; } else cout << " Converting to decimal : " << " No " ; }

BLEU: 73.28
Edit Sim: 74


Src: 
function isCheck ( str ) { var len = str . length ; var lowerStr = " " , upperStr = " " ; for ( var i = 0 ; i < len ; i ++ ) { if ( str [ i ] >= ' ' && str [ i ] < ' ' ) upperStr = upperStr + str [ i ] ; else lowerStr = lowerStr + str [ i ] ; } lowerStr = lowerStr . toUpperCase ( ) ; console . log ( lowerStr ) ; return lowerStr === upperStr ; }
Ref: 
bool isCheck ( string str ) { int len = str . length ( ) ; string lowerStr = " " , upperStr = " " ; for ( int i = 0 ; i < len ; i ++ ) { if ( str [ i ] >= 65 && str [ i ] <= 91 ) upperStr = upperStr + str [ i ] ; else lowerStr = lowerStr + str [ i ] ; } transform ( lowerStr . begin ( ) , lowerStr . end ( ) , lowerStr . begin ( ) , :: toupper ) ; return lowerStr == upperStr ; }
Hyp: 
bool isCheck ( string str ) { int len = str . length ( ) ; string lowerStr = " " , upperStr = " " ; for ( int i = 0 ; i < len ; i ++ ) { if ( str [ i ] >= ' A ' && str [ i ] < ' Z ' ) upperStr = upperStr + str [ i ] ; else lowerStr = lowerStr + str [ i ] ; } lowerStr = lowerStr . toUpperCase ( ) ; console . log ( lowerStr ) ; return lowerStr == upperStr ; }

BLEU: 74.73
Edit Sim: 66


Src: 
function maxValue ( arr , n , moves ) { for ( var i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] > 0 ) { var distance = n - 1 - i ; if ( moves < distance ) break ; var can_take = parseInt ( moves / distance ) ; var take = Math . min ( arr [ i ] , can_take ) ; arr [ n - 1 ] += take ; moves -= take * distance ; } } return arr [ n - 1 ] ; }
Ref: 
int maxValue ( int arr [ ] , int n , int moves ) { for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] > 0 ) { int distance = n - 1 - i ; if ( moves < distance ) break ; int can_take = moves / distance ; int take = min ( arr [ i ] , can_take ) ; arr [ n - 1 ] += take ; moves -= take * distance ; } } return arr [ n - 1 ] ; }
Hyp: 
int maxValue ( int arr [ ] , int n , int moves ) { for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] > 0 ) { int distance = n - 1 - i ; if ( moves < distance ) break ; int can_take = moves / distance ; int take = min ( arr [ i ] , can_take ) ; arr [ n - 1 ] += take ; moves -= take * distance ; } } return arr [ n - 1 ] ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function cyl ( a ) { if ( a < 0 ) return - 1 ; var r = ( 2 * a * ( Math . sqrt ( 2 ) ) / 3 ) ; var h = ( 2 * a ) / 3 ; var V = ( 3.14 * ( Math . pow ( r , 2 ) * h ) ) ; return V ; }
Ref: 
float cyl ( float a ) { if ( a < 0 ) return -1 ; float r = ( 2 * a * sqrt ( 2 ) ) / 3 ; float h = ( 2 * a ) / 3 ; float V = 3.14 * pow ( r , 2 ) * h ; return V ; }
Hyp: 
float cyl ( float a ) { if ( a < 0 ) return -1 ; float r = ( 2 * a * ( sqrt ( 2 ) ) / 3 ) ; float h = ( 2 * a ) / 3 ; float V = 3.14 * pow ( r , 2 ) * h ; return V ; }

BLEU: 91.86
Edit Sim: 4


Src: 
function printArray ( arr , n ) { arr . sort ( ) ; let l = 0 , r = n - 1 , flag = 0 , i ; let k = 2 ; while ( l <= r ) { if ( flag == 0 ) { for ( i = l ; i < l + k && i <= r ; i ++ ) document . write ( arr [ i ] + " " ) ; flag = 1 ; l = i ; } else { for ( i = r ; i > r - k && i >= l ; i -- ) document . write ( arr [ i ] + " " ) ; flag = 0 ; r = i ; } k ++ ; } }
Ref: 
void printArray ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int l = 0 , r = n - 1 , flag = 0 , i ; int k = 2 ; while ( l <= r ) { if ( flag == 0 ) { for ( i = l ; i < l + k && i <= r ; i ++ ) cout << arr [ i ] << " ▁ " ; flag = 1 ; l = i ; } { for ( i = r ; i > r - k && i >= l ; i -- ) cout << arr [ i ] << " ▁ " ; flag = 0 ; r = i ; } k ++ ; } }
Hyp: 
void printArray ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int l = 0 , r = n - 1 , flag = 0 , i ; int k = 2 ; while ( l <= r ) { if ( flag == 0 ) { for ( i = l ; i < l + k && i <= r ; i ++ ) cout << arr [ i ] << " ▁ " ; flag = 1 ; l = i ; } else { for ( i = r ; i > r - k && i >= l ; i -- ) cout << arr [ i ] << " ▁ " ; flag = 0 ; r = i ; } k ++ ; } }

BLEU: 98.22
Edit Sim: 5


Src: 
function getArray ( n ) { let ans = [ ] ; let p2 = 1 ; while ( n > 0 ) { if ( n & 1 ) ans . push ( p2 ) ; n >>= 1 ; p2 *= 2 ; } return ans ; }
Ref: 
> getArray ( int n ) { vector < long > ans ; long p2 = 1 ; while ( n > 0 ) { if ( n & 1 ) ans . push_back ( p2 ) ; n >>= 1 ; p2 *= 2 ; } return ans ; }
Hyp: 
int getArray ( int n ) { vector < int > ans ; int p2 = 1 ; while ( n > 0 ) { if ( n & 1 ) ans . push_back ( p2 ) ; n >>= 1 ; p2 *= 2 ; } return ans ; }

BLEU: 87.89
Edit Sim: 9


Src: 
function numberOfSticks ( x ) { return ( 3 * x * ( x + 1 ) ) / 2 ; }
Ref: 
int numberOfSticks ( int x ) { return ( 3 * x * ( x + 1 ) ) / 2 ; }
Hyp: 
int numberOfSticks ( int x ) { return ( 3 * x * ( x + 1 ) ) / 2 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function maxAverageOfPath ( cost , N ) { let dp = new Array ( N + 1 ) ; for ( let i = 0 ; i < N + 1 ; i ++ ) { dp [ i ] = new Array ( N + 1 ) ; for ( let j = 0 ; j < N + 1 ; j ++ ) { dp [ i ] [ j ] = 0 ; } } dp [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] ; for ( let i = 1 ; i < N ; i ++ ) dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ] ; for ( let j = 1 ; j < N ; j ++ ) dp [ 0 ] [ j ] = dp [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ] ; for ( let i = 1 ; i < N ; i ++ ) for ( let j = 1 ; j < N ; j ++ ) dp [ i ] [ j ] = Math . max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) + cost [ i ] [ j ] ; return dp [ N - 1 ] [ N - 1 ] / ( 2 * N - 1 ) ; }
Ref: 
double maxAverageOfPath ( int cost [ M ] [ M ] , int N ) { int dp [ N + 1 ] [ N + 1 ] ; dp [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ] ; for ( int j = 1 ; j < N ; j ++ ) dp [ 0 ] [ j ] = dp [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ] ; for ( int i = 1 ; i < N ; i ++ ) for ( int j = 1 ; j <= N ; j ++ ) dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) + cost [ i ] [ j ] ; return ( double ) dp [ N - 1 ] [ N - 1 ] / ( 2 * N - 1 ) ; }
Hyp: 
double maxAverageOfPath ( int cost [ ] [ N ] , int N ) { double dp [ N + 1 ] [ N + 1 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; dp [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ] ; for ( int j = 1 ; j < N ; j ++ ) dp [ 0 ] [ j ] = dp [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ] ; for ( int i = 1 ; i < N ; i ++ ) for ( int j = 1 ; j < N ; j ++ ) dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) + cost [ i ] [ j ] ; return dp [ N - 1 ] [ N - 1 ] / ( 2 * N - 1 ) ; }

BLEU: 90.02
Edit Sim: 57


Src: 
function FindRank ( arr , length ) { document . write ( " " + " " ) ; for ( i = 1 ; i < arr . length ; i ++ ) { var rank = 1 ; for ( j = 0 ; j < i ; j ++ ) { if ( arr [ j ] > arr [ i ] ) rank ++ ; } document . write ( rank + " " ) ; } }
Ref: 
void FindRank ( int arr [ ] , int length ) { cout << "1" << " ▁ " ; for ( int i = 1 ; i < length ; i ++ ) { int rank = 1 ; for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ j ] > arr [ i ] ) rank ++ ; } cout << rank << " ▁ " ; } }
Hyp: 
void FindRank ( int arr [ ] , int length ) { cout << " The ▁ rank ▁ of ▁ the ▁ longest ▁ chord " << endl ; for ( int i = 1 ; i < arr . length ( ) ; i ++ ) { int rank = 1 ; for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ j ] > arr [ i ] ) rank ++ ; } cout << rank << " ▁ " ; } }

BLEU: 77.06
Edit Sim: 54


Src: 
function checkSolution ( a , b , c ) { if ( b == 0 ) document . write ( " " ) ; else document . write ( " " ) ; }
Ref: 
void checkSolution ( int a , int b , int c ) { if ( b == 0 ) cout << " Yes " ; else cout << " No " ; }
Hyp: 
void checkSolution ( int a , int b , int c ) { if ( b == 0 ) cout << " Yes " ; else cout << " No " ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function binomialCoeffSum ( n ) { return ( 1 << n ) ; }
Ref: 
int binomialCoeffSum ( int n ) { return ( 1 << n ) ; }
Hyp: 
int binomialCoeffSum ( int n ) { return ( 1 << n ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findMissing ( a , b , n , m ) { for ( let i = 0 ; i < n ; i ++ ) { let j ; for ( j = 0 ; j < m ; j ++ ) if ( a [ i ] == b [ j ] ) break ; if ( j == m ) document . write ( a [ i ] + " " ) ; } }
Ref: 
void findMissing ( int a [ ] , int b [ ] , int n , int m ) { for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < m ; j ++ ) if ( a [ i ] == b [ j ] ) break ; if ( j == m ) cout << a [ i ] << " ▁ " ; } }
Hyp: 
void findMissing ( int a [ ] , int b [ ] , int n , int m ) { for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < m ; j ++ ) if ( a [ i ] == b [ j ] ) break ; if ( j == m ) cout << a [ i ] << " ▁ " ; } }

BLEU: 100.0
Edit Sim: 0


Src: 
function areaOfKite ( d1 , d2 ) { var area = ( d1 * d2 ) / 2 ; return area ; }
Ref: 
float areaOfKite ( int d1 , int d2 ) { float area = ( d1 * d2 ) / 2 ; return area ; }
Hyp: 
int areaOfKite ( int d1 , int d2 ) { int area = ( d1 * d2 ) / 2 ; return area ; }

BLEU: 85.31
Edit Sim: 8


Src: 
function minOR ( arr , n ) { if ( n == 1 ) return 0 ; var pre = Array ( n ) , suf = Array ( n ) ; pre [ 0 ] = arr [ 0 ] , suf [ n - 1 ] = arr [ n - 1 ] ; for ( var i = 1 ; i < n ; i ++ ) pre [ i ] = ( pre [ i - 1 ] arr [ i ] ) ; for ( var i = n - 2 ; i >= 0 ; i -- ) suf [ i ] = ( suf [ i + 1 ] arr [ i ] ) ; var ans = Math . min ( pre [ n - 2 ] , suf [ 1 ] ) ; for ( var i = 1 ; i < n - 1 ; i ++ ) ans = Math . min ( ans , ( pre [ i - 1 ] suf [ i + 1 ] ) ) ; return ans ; }
Ref: 
int minOR ( int * arr , int n ) { if ( n == 1 ) return 0 ; int pre [ n ] , suf [ n ] ; pre [ 0 ] = arr [ 0 ] , suf [ n - 1 ] = arr [ n - 1 ] ; for ( int i = 1 ; i < n ; i ++ ) pre [ i ] = ( pre [ i - 1 ] arr [ i ] ) ; for ( int i = n - 2 ; i >= 0 ; i -- ) suf [ i ] = ( suf [ i + 1 ] arr [ i ] ) ; int ans = min ( pre [ n - 2 ] , suf [ 1 ] ) ; for ( int i = 1 ; i < n - 1 ; i ++ ) ans = min ( ans , ( pre [ i - 1 ] suf [ i + 1 ] ) ) ; return ans ; }
Hyp: 
int minOR ( int arr [ ] , int n ) { if ( n == 1 ) return 0 ; int pre [ n ] , suf [ n ] ; pre [ 0 ] = arr [ 0 ] , suf [ n - 1 ] = arr [ n - 1 ] ; for ( int i = 1 ; i < n ; i ++ ) pre [ i ] = ( pre [ i - 1 ] arr [ i ] ) ; for ( int i = n - 2 ; i >= 0 ; i -- ) suf [ i ] = ( suf [ i + 1 ] arr [ i ] ) ; int ans = min ( pre [ n - 2 ] , suf [ 1 ] ) ; for ( int i = 1 ; i < n - 1 ; i ++ ) ans = min ( ans , ( pre [ i - 1 ] suf [ i + 1 ] ) ) ; return ans ; }

BLEU: 97.65
Edit Sim: 6


Src: 
function findCount ( arr , N , K ) { arr . sort ( ) ; let result = 1 ; let cur_max = arr [ 0 ] ; let cur_min = arr [ 0 ] ; for ( let i = 1 ; i < N ; i ++ ) { cur_max = arr [ i ] ; if ( cur_max - cur_min > K ) { result ++ ; cur_max = arr [ i ] ; cur_min = arr [ i ] ; } } return result ; }
Ref: 
int findCount ( int arr [ ] , int N , int K ) { sort ( arr , arr + N ) ; int result = 1 ; int cur_max = arr [ 0 ] ; int cur_min = arr [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) { cur_max = arr [ i ] ; if ( cur_max - cur_min > K ) { result ++ ; cur_max = arr [ i ] ; cur_min = arr [ i ] ; } } return result ; }
Hyp: 
int findCount ( int arr [ ] , int N , int K ) { sort ( arr , arr + N ) ; int result = 1 ; int cur_max = arr [ 0 ] ; int cur_min = arr [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) { cur_max = arr [ i ] ; if ( cur_max - cur_min > K ) { result ++ ; cur_max = arr [ i ] ; cur_min = arr [ i ] ; } } return result ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function printSorted ( arr , start , end ) { if ( start > end ) return ; printSorted ( arr , start * 2 + 1 , end ) ; document . write ( arr [ start ] + " " ) ; printSorted ( arr , start * 2 + 2 , end ) ; }
Ref: 
void printSorted ( int arr [ ] , int start , int end ) { if ( start > end ) return ; printSorted ( arr , start * 2 + 1 , end ) ; cout << arr [ start ] << " ▁ " ; printSorted ( arr , start * 2 + 2 , end ) ; }
Hyp: 
void printSorted ( int arr [ ] , int start , int end ) { if ( start > end ) return ; printSorted ( arr , start * 2 + 1 , end ) ; cout << arr [ start ] << " ▁ " ; printSorted ( arr , start * 2 + 2 , end ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function checkpoint ( h , k , x , y , a ) { var p = parseInt ( Math . pow ( ( y - k ) , 2 ) - 4 * a * ( x - h ) ) ; return p ; }
Ref: 
int checkpoint ( int h , int k , int x , int y , int a ) { int p = pow ( ( y - k ) , 2 ) - 4 * a * ( x - h ) ; return p ; }
Hyp: 
int checkpoint ( int h , int k , int x , int y , int a ) { int p = pow ( ( y - k ) , 2 ) - 4 * a * ( x - h ) ; return p ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function isOverflow ( a , b ) { if ( a == 0 b == 0 ) return false ; var result = a * b ; if ( result >= 9223372036854775807 result <= - 9223372036854775808 ) result = 0 if ( a == parseInt ( result / b ) ) return false ; else return true ; }
Ref: 
bool isOverflow ( long long a , long long b ) { if ( a == 0 b == 0 ) return false ; long long result = a * b ; if ( a == result / b ) return false ; else return true ; }
Hyp: 
bool isOverflow ( int a , int b ) { if ( a == 0 b == 0 ) return false ; int result = a * b ; if ( result >= 9223372036854775807 result <= - 9223372036854775808 ) result = 0 if ( a == result / b ) return false ; else return true ; }

BLEU: 63.89
Edit Sim: 100


Src: 
function numberofways ( n , m ) { let dp = new Array ( n + 2 ) ; for ( let i = 0 ; i < dp . length ; i ++ ) { dp [ i ] = new Array ( n + 2 ) ; for ( let j = 0 ; j < dp [ i ] . length ; j ++ ) { dp [ i ] [ j ] = 0 ; } } dp [ 0 ] [ n + 1 ] = 1 ; for ( let k = n ; k >= m ; k -- ) { for ( let i = 0 ; i <= n ; i ++ ) { dp [ i ] [ k ] = dp [ i ] [ k + 1 ] ; if ( i - k >= 0 ) dp [ i ] [ k ] = ( dp [ i ] [ k ] + dp [ i - k ] [ k ] ) ; } } return dp [ n ] [ m ] ; }
Ref: 
int numberofways ( int n , int m ) { int dp [ n + 2 ] [ n + 2 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; dp [ 0 ] [ n + 1 ] = 1 ; for ( int k = n ; k >= m ; k -- ) { for ( int i = 0 ; i <= n ; i ++ ) { dp [ i ] [ k ] = dp [ i ] [ k + 1 ] ; if ( i - k >= 0 ) dp [ i ] [ k ] = ( dp [ i ] [ k ] + dp [ i - k ] [ k ] ) ; } } return dp [ n ] [ m ] ; }
Hyp: 
int numberofways ( int n , int m ) { int dp [ n + 2 ] [ m + 1 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; dp [ 0 ] [ n + 1 ] = 1 ; for ( int k = n ; k >= m ; k -- ) { for ( int i = 0 ; i <= n ; i ++ ) { dp [ i ] [ k ] = dp [ i ] [ k + 1 ] ; if ( i - k >= 0 ) dp [ i ] [ k ] = ( dp [ i ] [ k ] + dp [ i - k ] [ k ] ) ; } } return dp [ n ] [ m ] ; }

BLEU: 97.0
Edit Sim: 2


Src: 
function count_numbers ( k , n , flag ) { if ( n == 1 ) { if ( flag ) { return ( k - 1 ) ; } else { return 1 ; } } if ( flag ) return ( k - 1 ) * ( count_numbers ( k , n - 1 , 0 ) + count_numbers ( k , n - 1 , 1 ) ) ; else return count_numbers ( k , n - 1 , 1 ) ; }
Ref: 
int count_numbers ( int k , int n , bool flag ) { if ( n == 1 ) { if ( flag ) { return ( k - 1 ) ; } else { return 1 ; } } if ( flag ) return ( k - 1 ) * ( count_numbers ( k , n - 1 , 0 ) + count_numbers ( k , n - 1 , 1 ) ) ; else return count_numbers ( k , n - 1 , 1 ) ; }
Hyp: 
int count_numbers ( int k , int n , int flag ) { if ( n == 1 ) { if ( flag ) { return ( k - 1 ) ; } else { return 1 ; } } if ( flag ) return ( k - 1 ) * ( count_numbers ( k , n - 1 , 0 ) + count_numbers ( k , n - 1 , 1 ) ) ; else return count_numbers ( k , n - 1 , 1 ) ; }

BLEU: 97.15
Edit Sim: 4


Src: 
function countPairs ( arr1 , arr2 , m , n , x ) { let count = 0 ; for ( let i = 0 ; i < m ; i ++ ) for ( let j = 0 ; j < n ; j ++ ) if ( ( arr1 [ i ] + arr2 [ j ] ) == x ) count ++ ; return count ; }
Ref: 
int countPairs ( int arr1 [ ] , int arr2 [ ] , int m , int n , int x ) { int count = 0 ; for ( int i = 0 ; i < m ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( ( arr1 [ i ] + arr2 [ j ] ) == x ) count ++ ; return count ; }
Hyp: 
int countPairs ( int arr1 [ ] , int arr2 [ ] , int m , int n , int x ) { int count = 0 ; for ( int i = 0 ; i < m ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( ( arr1 [ i ] + arr2 [ j ] ) == x ) count ++ ; return count ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countOfBase ( N ) { let count = 0 ; for ( let i = 2 ; i <= N ; ++ i ) { let highestPower = parseInt ( Math . log ( N ) / Math . log ( i ) ) ; let firstDigit = parseInt ( N / Math . pow ( i , highestPower ) ) ; if ( firstDigit == 1 ) { ++ count ; } } return count ; }
Ref: 
int countOfBase ( int N ) { int count = 0 ; for ( int i = 2 ; i <= N ; ++ i ) { int highestPower = ( int ) ( log ( N ) / log ( i ) ) ; int firstDigit = N / ( int ) pow ( i , highestPower ) ; if ( firstDigit == 1 ) { ++ count ; } } return count ; }
Hyp: 
int countOfBase ( int N ) { int count = 0 ; for ( int i = 2 ; i <= N ; ++ i ) { int highestPower = log2 ( N ) / log ( i ) ; int firstDigit = N / pow ( i , highestPower ) ; if ( firstDigit == 1 ) { ++ count ; } } return count ; }

BLEU: 82.47
Edit Sim: 21


Src: 
function longestSubsequence ( arr , N ) { let count = 1 ; for ( let i = 1 ; i < N ; i ++ ) { if ( arr [ i ] != arr [ i - 1 ] ) { count ++ ; } } document . write ( count ) ; }
Ref: 
void longestSubsequence ( int arr [ ] , int N ) { int count = 1 ; for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] != arr [ i - 1 ] ) { count ++ ; } } cout << count << endl ; }
Hyp: 
void longestSubsequence ( int arr [ ] , int N ) { int count = 1 ; for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] != arr [ i - 1 ] ) { count ++ ; } } cout << count ; }

BLEU: 94.38
Edit Sim: 8


Src: 
function countOddSum ( ar , n ) { let result = 0 ; for ( let i = 0 ; i <= n - 1 ; i ++ ) { let val = 0 ; for ( let j = i ; j <= n - 1 ; j ++ ) { val = val + ar [ j ] ; if ( val % 2 != 0 ) result ++ ; } } return ( result ) ; }
Ref: 
int countOddSum ( int ar [ ] , int n ) { int result = 0 ; for ( int i = 0 ; i <= n - 1 ; i ++ ) { int val = 0 ; for ( int j = i ; j <= n - 1 ; j ++ ) { val = val + ar [ j ] ; if ( val % 2 != 0 ) result ++ ; } } return ( result ) ; }
Hyp: 
int countOddSum ( int ar [ ] , int n ) { int result = 0 ; for ( int i = 0 ; i <= n - 1 ; i ++ ) { int val = 0 ; for ( int j = i ; j <= n - 1 ; j ++ ) { val = val + ar [ j ] ; if ( val % 2 != 0 ) result ++ ; } } return ( result ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function turnOnK ( n , k ) { if ( k <= 0 ) return n ; return ( n | ( 1 << ( k - 1 ) ) ) ; }
Ref: 
int turnOnK ( int n , int k ) { if ( k <= 0 ) return n ; return ( n | ( 1 << ( k - 1 ) ) ) ; }
Hyp: 
int turnOnK ( int n , int k ) { if ( k <= 0 ) return n ; return ( n | ( 1 << ( k - 1 ) ) ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function sumOfFactors ( N ) { var ans = 0 ; for ( i = 1 ; i <= N ; i ++ ) { var first = i ; var last = parseInt ( N / i ) * i ; var factors = parseInt ( ( last - first ) / i ) + 1 ; var totalContribution = parseInt ( ( ( factors ) * ( factors + 1 ) ) / 2 ) * i ; ans += totalContribution ; } return ans ; }
Ref: 
long sumOfFactors ( int N ) { long long ans = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { long long first = i ; long long last = ( N / i ) * i ; long long factors = ( last - first ) / i + 1 ; long long totalContribution = ( ( ( factors ) * ( factors + 1 ) ) / 2 ) * i ; ans += totalContribution ; } return ans ; }
Hyp: 
int sumOfFactors ( int N ) { int ans = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { int first = i ; int last = N / i * i ; int factors = ( last - first ) / i + 1 ; int totalContribution = ( ( factors ) * ( factors + 1 ) ) / 2 ; ans += totalContribution ; } return ans ; }

BLEU: 66.51
Edit Sim: 55


Src: 
function checkPandigital ( b , n ) { if ( n . length < b ) return 0 ; let hash = [ ] ; for ( let i = 0 ; i < b ; i ++ ) hash [ i ] = 0 ; for ( let i = 0 ; i < n . length ; i ++ ) { if ( n [ i ] >= ' ' && n [ i ] <= ' ' ) hash [ n [ i ] - ' ' ] = 1 ; else if ( n . charCodeAt ( i ) - ' ' . charCodeAt ( 0 ) <= b - 11 ) hash [ n . charCodeAt ( i ) - ' ' . charCodeAt ( 0 ) + 10 ] = 1 ; } for ( let i = 0 ; i < b ; i ++ ) if ( hash [ i ] == 0 ) return 0 ; return 1 ; }
Ref: 
bool checkPandigital ( int b , char n [ ] ) { if ( strlen ( n ) < b ) return false ; bool hash [ b ] ; memset ( hash , false , sizeof ( hash ) ) ; for ( int i = 0 ; i < strlen ( n ) ; i ++ ) { if ( n [ i ] >= '0' && n [ i ] <= '9' ) hash [ n [ i ] - '0' ] = true ; else if ( n [ i ] - ' A ' <= b - 11 ) hash [ n [ i ] - ' A ' + 10 ] = true ; } for ( int i = 0 ; i < b ; i ++ ) if ( hash [ i ] == false ) return false ; return true ; }
Hyp: 
int checkPandigital ( int b , string n ) { if ( n . length ( ) < b ) return 0 ; int hash [ b ] ; for ( int i = 0 ; i < b ; i ++ ) hash [ i ] = 0 ; for ( int i = 0 ; i < n . length ( ) ; i ++ ) { if ( n [ i ] >= ' A ' && n [ i ] <= ' Z ' ) hash [ n [ i ] - ' a ' ] = 1 ; else if ( n [ i ] - ' a ' <= b - 11 ) hash [ n [ i ] - ' a ' + 10 ] = 1 ; } for ( int i = 0 ; i < b ; i ++ ) if ( hash [ i ] == 0 ) return 0 ; return 1 ; }

BLEU: 58.02
Edit Sim: 103


Src: 
function validQuadruple ( arr , n ) { if ( n >= MAX ) return true ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = i + 1 ; j < n ; j ++ ) for ( let k = j + 1 ; k < n ; k ++ ) for ( let l = k + 1 ; l < n ; l ++ ) { if ( ( arr [ i ] ^ arr [ j ] ^ arr [ k ] ^ arr [ l ] ) == 0 ) { return true ; } } return false ; }
Ref: 
bool validQuadruple ( int arr [ ] , int n ) { if ( n >= MAX ) return true ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) for ( int k = j + 1 ; k < n ; k ++ ) for ( int l = k + 1 ; l < n ; l ++ ) { if ( ( arr [ i ] ^ arr [ j ] ^ arr [ k ] ^ arr [ l ] ) == 0 ) { return true ; } } return false ; }
Hyp: 
bool validQuadruple ( int arr [ ] , int n ) { if ( n >= MAX ) return true ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) for ( int k = j + 1 ; k < n ; k ++ ) for ( int l = k + 1 ; l < n ; l ++ ) { if ( ( arr [ i ] ^ arr [ j ] ^ arr [ k ] ^ arr [ l ] ) == 0 ) { return true ; } } return false ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function printCombination ( n ) { document . write ( 1 + " " ) ; if ( ( n - 2 ) % 3 == 0 ) document . write ( 2 + " " + ( n - 3 ) ) ; else document . write ( 1 + " " + ( n - 2 ) ) ; }
Ref: 
void printCombination ( int n ) { cout << 1 << " ▁ " ; if ( ( n - 2 ) % 3 == 0 ) cout << 2 << " ▁ " << n - 3 ; else cout << 1 << " ▁ " << n - 2 ; }
Hyp: 
void printCombination ( int n ) { cout << 1 << " ▁ " ; if ( ( n - 2 ) % 3 == 0 ) cout << 2 << " ▁ " << n - 3 ; else cout << 1 << " ▁ " << n - 2 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function getPositionCount ( a , n ) { var count = 1 ; var min = a [ 0 ] ; for ( var i = 1 ; i < n ; i ++ ) { if ( a [ i ] <= min ) { min = a [ i ] ; count ++ ; } } return count ; }
Ref: 
int getPositionCount ( int a [ ] , int n ) { int count = 1 ; int min = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] <= min ) { min = a [ i ] ; count ++ ; } } return count ; }
Hyp: 
int getPositionCount ( int a [ ] , int n ) { int count = 1 ; int min = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] <= min ) { min = a [ i ] ; count ++ ; } } return count ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function maxDifference ( arr , N , k ) { let M , S = 0 , S1 = 0 , max_difference = 0 ; for ( let i = 0 ; i < N ; i ++ ) S += arr [ i ] ; let temp ; for ( let i = 0 ; i < N ; i ++ ) { for ( let j = i + 1 ; j < N ; j ++ ) { if ( arr [ i ] < arr [ j ] ) { temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; } } } M = Math . max ( k , N - k ) ; for ( let i = 0 ; i < M ; i ++ ) S1 += arr [ i ] ; max_difference = S1 - ( S - S1 ) ; return max_difference ; }
Ref: 
int maxDifference ( int arr [ ] , int N , int k ) { int M , S = 0 , S1 = 0 , max_difference = 0 ; for ( int i = 0 ; i < N ; i ++ ) S += arr [ i ] ; sort ( arr , arr + N , greater < int > ( ) ) ; M = max ( k , N - k ) ; for ( int i = 0 ; i < M ; i ++ ) S1 += arr [ i ] ; max_difference = S1 - ( S - S1 ) ; return max_difference ; }
Hyp: 
int maxDifference ( int arr [ ] , int N , int k ) { int M , S = 0 , S1 = 0 , max_difference = 0 ; for ( int i = 0 ; i < N ; i ++ ) S += arr [ i ] ; int temp ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( arr [ i ] < arr [ j ] ) { temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; } } } M = max ( k , N - k ) ; for ( int i = 0 ; i < M ; i ++ ) S1 += arr [ i ] ; max_difference = S1 - ( S - S1 ) ; return max_difference ; }

BLEU: 57.02
Edit Sim: 153


Src: 
function addOne ( x ) { let m = 1 ; while ( x & m ) { x = x ^ m ; m <<= 1 ; } x = x ^ m ; return x ; }
Ref: 
int addOne ( int x ) { int m = 1 ; while ( x & m ) { x = x ^ m ; m <<= 1 ; } x = x ^ m ; return x ; }
Hyp: 
int addOne ( int x ) { int m = 1 ; while ( x & m ) { x = x ^ m ; m <<= 1 ; } x = x ^ m ; return x ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findPair ( a , n , z ) { for ( let i = 0 ; i < n ; i ++ ) for ( let j = 0 ; j < n ; j ++ ) if ( i != j && a [ i ] + a [ j ] == z ) return true ; return false ; }
Ref: 
bool findPair ( int a [ ] , int n , int z ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( i != j && a [ i ] + a [ j ] == z ) return true ; return false ; }
Hyp: 
bool findPair ( int a [ ] , int n , int z ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( i != j && a [ i ] + a [ j ] == z ) return true ; return false ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findTriplets ( arr , n , sum ) { for ( let i = 0 ; i < n - 1 ; i ++ ) { let s = new Set ( ) ; for ( let j = i + 1 ; j < n ; j ++ ) { let x = sum - ( arr [ i ] + arr [ j ] ) ; if ( s . has ( x ) ) document . write ( x + " " + arr [ i ] + " " + arr [ j ] + " " ) ; else s . add ( arr [ j ] ) ; } } }
Ref: 
void findTriplets ( int arr [ ] , int n , int sum ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { unordered_set < int > s ; for ( int j = i + 1 ; j < n ; j ++ ) { int x = sum - ( arr [ i ] + arr [ j ] ) ; if ( s . find ( x ) != s . end ( ) ) printf ( " % d ▁ % d ▁ % d STRNEWLINE " , x , arr [ i ] , arr [ j ] ) ; else s . insert ( arr [ j ] ) ; } } }
Hyp: 
void findTriplets ( int arr [ ] , int n , int sum ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { unordered_set < int > s ; for ( int j = i + 1 ; j < n ; j ++ ) { int x = sum - ( arr [ i ] + arr [ j ] ) ; if ( s . find ( x ) != s . end ( ) ) cout << x << " ^ " << arr [ i ] << " ^ " << arr [ j ] << " ▁ " ; else s . insert ( arr [ j ] ) ; } } }

BLEU: 83.01
Edit Sim: 44


Src: 
function isOsiris ( n ) { let a = n % 10 ; let b = parseInt ( ( n / 10 ) % 10 ) ; let c = parseInt ( n / 100 ) ; let digit_sum = a + b + c ; if ( n == ( 2 * ( digit_sum ) * 11 ) ) { return true ; } return false ; }
Ref: 
bool isOsiris ( int n ) { int a = n % 10 ; int b = ( n / 10 ) % 10 ; int c = n / 100 ; int digit_sum = a + b + c ; if ( n == ( 2 * ( digit_sum ) * 11 ) ) { return true ; } return false ; }
Hyp: 
bool isOsiris ( int n ) { int a = n % 10 ; int b = ( n / 10 ) % 10 ; int c = n / 100 ; int digit_sum = a + b + c ; if ( n == ( 2 * ( digit_sum ) * 11 ) ) { return true ; } return false ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function splitArr ( arr , n , k ) { for ( let i = 0 ; i < k ; i ++ ) { let x = arr [ 0 ] ; for ( let j = 0 ; j < n - 1 ; ++ j ) arr [ j ] = arr [ j + 1 ] ; arr [ n - 1 ] = x ; } }
Ref: 
void splitArr ( int arr [ ] , int n , int k ) { for ( int i = 0 ; i < k ; i ++ ) { int x = arr [ 0 ] ; for ( int j = 0 ; j < n - 1 ; ++ j ) arr [ j ] = arr [ j + 1 ] ; arr [ n - 1 ] = x ; } }
Hyp: 
void splitArr ( int arr [ ] , int n , int k ) { for ( int i = 0 ; i < k ; i ++ ) { int x = arr [ 0 ] ; for ( int j = 0 ; j < n - 1 ; ++ j ) arr [ j ] = arr [ j + 1 ] ; arr [ n - 1 ] = x ; } }

BLEU: 100.0
Edit Sim: 0


Src: 
function findIntersection ( intervals , N ) { let l = intervals [ 0 ] [ 0 ] ; let r = intervals [ 0 ] [ 1 ] ; for ( let i = 1 ; i < N ; i ++ ) { if ( intervals [ i ] [ 0 ] > r intervals [ i ] [ 1 ] < l ) { document . write ( - 1 + " " ) ; return ; } else { l = Math . max ( l , intervals [ i ] [ 0 ] ) ; r = Math . min ( r , intervals [ i ] [ 1 ] ) ; } } document . write ( " " + l + " " + r + " " + " " ) ; }
Ref: 
void findIntersection ( int intervals [ ] [ 2 ] , int N ) { int l = intervals [ 0 ] [ 0 ] ; int r = intervals [ 0 ] [ 1 ] ; for ( int i = 1 ; i < N ; i ++ ) { if ( intervals [ i ] [ 0 ] > r intervals [ i ] [ 1 ] < l ) { cout << -1 ; return ; } else { l = max ( l , intervals [ i ] [ 0 ] ) ; r = min ( r , intervals [ i ] [ 1 ] ) ; } } cout << " [ " << l << " , ▁ " << r << " ] " ; }
Hyp: 
void findIntersection ( int intervals [ ] [ 2 ] , int N ) { int l = intervals [ 0 ] [ 0 ] ; int r = intervals [ 0 ] [ 1 ] ; for ( int i = 1 ; i < N ; i ++ ) { if ( intervals [ i ] [ 0 ] > r intervals [ i ] [ 1 ] < l ) { cout << -1 ; return ; } else { l = max ( l , intervals [ i ] [ 0 ] ) ; r = min ( r , intervals [ i ] [ 1 ] ) ; } } cout << " The ▁ intersection ▁ is ▁ [ " << l << " , ▁ " << r << " ] ▁ STRNEWLINE " ; }

BLEU: 92.25
Edit Sim: 39


Src: 
function longestSubstring ( s ) { var cnt = 1 , maxi = 1 ; var n = s . length ; for ( i = 1 ; i < n ; i ++ ) { if ( s . charAt ( i ) != s . charAt ( i - 1 ) ) cnt ++ ; else { maxi = Math . max ( cnt , maxi ) ; cnt = 1 ; } } maxi = Math . max ( cnt , maxi ) ; return maxi ; }
Ref: 
int longestSubstring ( string s ) { int cnt = 1 ; int maxi = 1 ; int n = s . length ( ) ; for ( int i = 1 ; i < n ; i ++ ) { if ( s [ i ] != s [ i - 1 ] ) cnt ++ ; else { maxi = max ( cnt , maxi ) ; cnt = 1 ; } } maxi = max ( cnt , maxi ) ; return maxi ; }
Hyp: 
int longestSubstring ( string s ) { int cnt = 1 , maxi = 1 ; int n = s . length ( ) ; for ( int i = 1 ; i < n ; i ++ ) { if ( s [ i ] != s [ i - 1 ] ) cnt ++ ; else { maxi = max ( cnt , maxi ) ; cnt = 1 ; } } maxi = max ( cnt , maxi ) ; return maxi ; }

BLEU: 95.97
Edit Sim: 5


Src: 
function setKthBit ( n , k ) { return ( ( 1 << k ) n ) ; }
Ref: 
int setKthBit ( int n , int k ) { return ( ( 1 << k ) n ) ; }
Hyp: 
int setKthBit ( int n , int k ) { return ( ( 1 << k ) n ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countSubsequences ( arr ) { let odd = 0 ; for ( let x = 0 ; x < arr . length ; x ++ ) { if ( arr [ x ] & 1 ) odd ++ ; } return ( 1 << odd ) - 1 ; }
Ref: 
int countSubsequences ( vector < int > arr ) { int odd = 0 ; for ( int x : arr ) { if ( x & 1 ) odd ++ ; } return ( 1 << odd ) - 1 ; }
Hyp: 
int countSubsequences ( int arr [ ] , int arr_size ) { int odd = 0 ; for ( int x = 0 ; x < arr_size ; x ++ ) { if ( arr [ x ] & 1 ) odd ++ ; } return ( 1 << odd ) - 1 ; }

BLEU: 56.24
Edit Sim: 47


Src: 
function profitLoss ( N , M ) { if ( N == M ) document . write ( " " ) ; else { var result = 0.0 ; result = ( Math . abs ( N - M ) ) / M ; if ( N - M < 0 ) document . write ( " " + result . toFixed ( 6 ) * 100 + " " ) ; else document . write ( " " + result . toFixed ( 6 ) * 100 + " " ) ; } }
Ref: 
void profitLoss ( int N , int M ) { if ( N == M ) cout << " No ▁ Profit ▁ nor ▁ Loss " ; else { float result = 0.0 ; result = float ( abs ( N - M ) ) / M ; if ( N - M < 0 ) cout << " Loss ▁ = ▁ - " << result * 100 << " % " ; else cout << " Profit ▁ = ▁ " << result * 100 << " % " ; } }
Hyp: 
void profitLoss ( double N , double M ) { if ( N == M ) cout << " Yes " ; else { double result = 0.0 ; result = ( abs ( N - M ) ) / M ; if ( N - M < 0 ) cout << " Yes " << result << endl ; else cout << " No " << result << endl ; } }

BLEU: 50.45
Edit Sim: 91


Src: 
function findNum ( div , rem , N ) { var num = rem [ N - 1 ] ; for ( var i = N - 2 ; i >= 0 ; i -- ) { num = num * div [ i ] + rem [ i ] ; } return num ; }
Ref: 
int findNum ( int div [ ] , int rem [ ] , int N ) { int num = rem [ N - 1 ] ; for ( int i = N - 2 ; i >= 0 ; i -- ) { num = num * div [ i ] + rem [ i ] ; } return num ; }
Hyp: 
int findNum ( int div [ ] , int rem [ ] , int N ) { int num = rem [ N - 1 ] ; for ( int i = N - 2 ; i >= 0 ; i -- ) { num = num * div [ i ] + rem [ i ] ; } return num ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function anglequichord ( z ) { document . write ( " " + z + " " ) ; }
Ref: 
void anglequichord ( int z ) { cout << " The ▁ angle ▁ is ▁ " << z << " ▁ degrees " << endl ; }
Hyp: 
void anglequichord ( int z ) { cout << " The ▁ angle ▁ of ▁ the ▁ circle ▁ is ▁ " << z << " ▁ degrees " << endl ; }

BLEU: 79.69
Edit Sim: 20


Src: 
function check ( k , d0 , d1 ) { let s = ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 + ( 8 * ( d0 + d1 ) ) % 10 + ( 6 * ( d0 + d1 ) ) % 10 ; let a = ( k - 3 ) % 4 ; let x ; switch ( a ) { case 0 : x = 0 ; break ; case 1 : x = ( 2 * ( d0 + d1 ) ) % 10 ; break ; case 2 : x = ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 ; break ; case 3 : x = ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 + ( 8 * ( d0 + d1 ) ) % 10 ; break ; } let sum = d0 + d1 + parseInt ( ( k - 3 ) / 4 ) * s + x ; if ( sum % 3 == 0 ) return " " ; return " " ; }
Ref: 
string check ( long int k , int d0 , int d1 ) { long int s = ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 + ( 8 * ( d0 + d1 ) ) % 10 + ( 6 * ( d0 + d1 ) ) % 10 ; int a = ( k - 3 ) % 4 ; int x ; switch ( a ) { case 0 : x = 0 ; break ; case 1 : x = ( 2 * ( d0 + d1 ) ) % 10 ; break ; case 2 : x = ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 ; break ; case 3 : x = ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 + ( 8 * ( d0 + d1 ) ) % 10 ; break ; } long int sum = d0 + d1 + ( ( k - 3 ) / 4 ) * s + x ; if ( sum % 3 == 0 ) return " YES " ; return " NO " ; }
Hyp: 
string check ( int k , int d0 , int d1 ) { int s = ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 + ( 8 * ( d0 + d1 ) ) % 10 + ( 6 * ( d0 + d1 ) ) % 10 ; int a = ( k - 3 ) % 4 ; int x ; switch ( a ) { case 0 : x = 0 ; break ; case 1 : x = ( 2 * ( d0 + d1 ) ) % 10 ; break ; case 2 : x = ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 ; break ; case 3 : x = ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 + ( 8 * ( d0 + d1 ) ) % 10 ; break ; } int sum = d0 + d1 + ( k - 3 ) / 4 ) * s + x ; if ( sum % 3 == 0 ) return " Yes " ; return " No " ; }

BLEU: 93.7
Edit Sim: 20


Src: 
function sumOfDigit ( n , b ) { var unitDigit , sum = 0 ; while ( n > 0 ) { unitDigit = n % b ; sum += unitDigit ; n = parseInt ( n / b ) ; } return sum ; }
Ref: 
int sumOfDigit ( int n , int b ) { int unitDigit , sum = 0 ; while ( n > 0 ) { unitDigit = n % b ; sum += unitDigit ; n = n / b ; } return sum ; }
Hyp: 
int sumOfDigit ( int n , int b ) { int unitDigit , sum = 0 ; while ( n > 0 ) { unitDigit = n % b ; sum += unitDigit ; n = n / b ; } return sum ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function maxEdges ( N ) { var edges = 0 ; edges = Math . floor ( ( N * N ) / 4 ) ; return edges ; }
Ref: 
int maxEdges ( int N ) { int edges = 0 ; edges = floor ( ( N * N ) / 4 ) ; return edges ; }
Hyp: 
int maxEdges ( int N ) { int edges = 0 ; edges = ( N * N ) / 4 ; return edges ; }

BLEU: 77.81
Edit Sim: 10


Src: 
function countNumbers ( n ) { if ( n % 2 == 1 ) return 0 ; return ( 9 * Math . pow ( 10 , parseInt ( n / 2 ) - 1 ) ) ; }
Ref: 
int countNumbers ( int n ) { if ( n % 2 == 1 ) return 0 ; return ( 9 * pow ( 10 , n / 2 - 1 ) ) ; }
Hyp: 
int countNumbers ( int n ) { if ( n % 2 == 1 ) return 0 ; return ( 9 * pow ( 10 , n / 2 - 1 ) ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function factors ( n , i ) { if ( i <= n ) { if ( n % i == 0 ) { document . write ( i + " " ) ; } factors ( n , i + 1 ) ; } }
Ref: 
void factors ( int n , int i ) { if ( i <= n ) { if ( n % i == 0 ) { cout << i << " ▁ " ; } factors ( n , i + 1 ) ; } }
Hyp: 
void factors ( int n , int i ) { if ( i <= n ) { if ( n % i == 0 ) { cout << i << " ▁ " ; } factors ( n , i + 1 ) ; } }

BLEU: 100.0
Edit Sim: 0


Src: 
function isDivisible ( N ) { return ( N - 1 ) % 3 != 0 ; }
Ref: 
bool isDivisible ( int N ) { return ( N - 1 ) % 3 != 0 ; }
Hyp: 
bool isDivisible ( int N ) { return ( N - 1 ) % 3 != 0 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function eggDrop ( n , k ) { let dp = new Array ( ) ; for ( let i = 0 ; i < k + 1 ; i ++ ) { dp . push ( new Array ( n + 1 ) . fill ( 0 ) ) } let x = 0 ; while ( dp [ x ] [ n ] < k ) { x ++ ; for ( let i = 1 ; i <= n ; i ++ ) dp [ x ] [ i ] = dp [ x - 1 ] [ i - 1 ] + dp [ x - 1 ] [ i ] + 1 ; } return x ; }
Ref: 
int eggDrop ( int n , int k ) { vector < vector < int > > dp ( k + 1 , vector < int > ( n + 1 , 0 ) ) ; int x = 0 ; while ( dp [ x ] [ n ] < k ) { x ++ ; for ( int i = 1 ; i <= n ; i ++ ) dp [ x ] [ i ] = dp [ x - 1 ] [ i - 1 ] + dp [ x - 1 ] [ i ] + 1 ; } return x ; }
Hyp: 
int eggDrop ( int n , int k ) { vector < vector < int > > dp ( n + 1 , 0 ) ; for ( int i = 0 ; i < k + 1 ; i ++ ) dp . push_back ( new vector < int > ( n + 1 , 0 ) ) ; int x = 0 ; while ( dp [ x ] [ n ] < k ) { x ++ ; for ( int i = 1 ; i <= n ; i ++ ) dp [ x ] [ i ] = dp [ x - 1 ] [ i - 1 ] + dp [ x - 1 ] [ i ] + 1 ; } return x ; }

BLEU: 79.23
Edit Sim: 65


Src: 
function countPairs ( arr , k , n ) { arr . sort ( ( a , b ) => a - b ) ; let pair = 0 ; let index = 0 ; while ( index < n - 1 ) { if ( arr [ index + 1 ] - arr [ index ] <= k ) { pair += 1 ; index += 2 ; } else { index += 1 ; } } return pair ; }
Ref: 
int countPairs ( int arr [ ] , int k , int n ) { sort ( arr , arr + n ) ; int pair = 0 ; int index = 0 ; while ( index < n - 1 ) { if ( arr [ index + 1 ] - arr [ index ] <= k ) { pair += 1 ; index += 2 ; } else { index += 1 ; } } return pair ; }
Hyp: 
int countPairs ( int arr [ ] , int k , int n ) { sort ( arr , arr + n ) ; int pair = 0 ; int index = 0 ; while ( index < n - 1 ) { if ( arr [ index + 1 ] - arr [ index ] <= k ) { pair += 1 ; index += 2 ; } else { index += 1 ; } } return pair ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function overflow ( H , r , h , N , R ) { let tank_cap = 3.14 * r * r * H ; let water_vol = 3.14 * r * r * h ; let balls_vol = N * ( 4 / 3 ) * 3.14 * R * R * R ; let vol = water_vol + balls_vol ; if ( vol > tank_cap ) { document . write ( " " ) ; } else { document . write ( " " ) ; } }
Ref: 
void overflow ( int H , int r , int h , int N , int R ) { float tank_cap = 3.14 * r * r * H ; float water_vol = 3.14 * r * r * h ; float balls_vol = N * ( 4 / 3 ) * 3.14 * R * R * R ; float vol = water_vol + balls_vol ; if ( vol > tank_cap ) { cout << " Overflow " << endl ; } else { cout << " Not ▁ in ▁ overflow ▁ state " << endl ; } }
Hyp: 
void overflow ( double H , double r , double h , double N , double R ) { double tank_cap = 3.14 * r * r * H ; double water_vol = 3.14 * r * r * h ; double balls_vol = N * ( 4 / 3 ) * 3.14 * R * R * R ; double vol = water_vol + balls_vol ; if ( vol > tank_cap ) cout << " Odd " ; else cout << " No " ; }

BLEU: 53.1
Edit Sim: 110


Src: 
function printClosest ( arr , n , x ) { let res_l = 0 , res_r = 0 ; let l = 0 , r = n - 1 , diff = Number . MAX_VALUE ; while ( r > l ) { if ( Math . abs ( arr [ l ] + arr [ r ] - x ) < diff ) { res_l = l ; res_r = r ; diff = Math . abs ( arr [ l ] + arr [ r ] - x ) ; } if ( arr [ l ] + arr [ r ] > x ) r -- ; else l ++ ; } document . write ( " " + arr [ res_l ] + " " + arr [ res_r ] ) ; }
Ref: 
void printClosest ( int arr [ ] , int n , int x ) { int res_l , res_r ; int l = 0 , r = n - 1 , diff = INT_MAX ; while ( r > l ) { if ( abs ( arr [ l ] + arr [ r ] - x ) < diff ) { res_l = l ; res_r = r ; diff = abs ( arr [ l ] + arr [ r ] - x ) ; } if ( arr [ l ] + arr [ r ] > x ) r -- ; else l ++ ; } cout << " ▁ The ▁ closest ▁ pair ▁ is ▁ " << arr [ res_l ] << " ▁ and ▁ " << arr [ res_r ] ; }
Hyp: 
void printClosest ( int arr [ ] , int n , int x ) { int res_l = 0 , res_r = 0 ; int l = 0 , r = n - 1 , diff = INT_MAX ; while ( r > l ) { if ( abs ( arr [ l ] + arr [ r ] - x ) < diff ) { res_l = l ; res_r = r ; diff = abs ( arr [ l ] + arr [ r ] - x ) ; } if ( arr [ l ] + arr [ r ] > x ) r -- ; else l ++ ; } cout << " The ▁ closest ▁ pair ▁ is ▁ [ " << arr [ res_l ] << " , ▁ " << arr [ res_r ] ; }

BLEU: 90.66
Edit Sim: 17


Src: 
function Check_is_possible ( l , r , k ) { var count = 0 ; for ( i = l ; i <= r ; i ++ ) { if ( i % k == 0 ) { count ++ ; } } return ( count > 1 ) ; } var l = 4 , r = 12 ; var k = 5 ; if ( Check_is_possible ( l , r , k ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
Ref: 
bool Check_is_possible ( int l , int r , int k ) { int count = 0 ; for ( int i = l ; i <= r ; i ++ ) { if ( i % k == 0 ) count ++ ; } return ( count > 1 ) ; }
Hyp: 
bool Check_is_possible ( int l , int r , int k ) { int count = 0 ; for ( int i = l ; i <= r ; i ++ ) { if ( i % k == 0 ) { count ++ ; } } return ( count > 1 ) ; }

BLEU: 92.05
Edit Sim: 4


Src: 
function findAngle ( M1 , M2 ) { var angle = Math . abs ( ( M2 - M1 ) / ( 1 + M1 * M2 ) ) ; var ret = Math . atan ( angle ) ; var val = ( ret * 180 ) / PI ; document . write ( val . toFixed ( 4 ) ) ; }
Ref: 
void findAngle ( double M1 , double M2 ) { double angle = abs ( ( M2 - M1 ) / ( 1 + M1 * M2 ) ) ; double ret = atan ( angle ) ; double val = ( ret * 180 ) / PI ; cout << val ; }
Hyp: 
void findAngle ( int M1 , int M2 ) { float angle = abs ( ( M2 - M1 ) / ( 1 + M1 * M2 ) ) ; float ret = atan ( angle ) ; float val = ( ret * 180 ) / PI ; cout << val << endl ; }

BLEU: 70.93
Edit Sim: 38


Src: 
function find_maximum_value ( a , n ) { var sum = 0 ; var minimum = Number . MAX_VALUE ; var pos = 0 , neg = 0 ; for ( i = 0 ; i < n ; i ++ ) { minimum = Math . min ( minimum , Math . abs ( a [ i ] ) ) ; sum += Math . abs ( a [ i ] ) ; if ( a [ i ] >= 0 ) pos += 1 ; else neg += 1 ; } if ( pos > 0 && neg > 0 ) return sum ; return ( sum - 2 * minimum ) ; }
Ref: 
int find_maximum_value ( int a [ ] , int n ) { int sum = 0 ; int minimum = INT_MAX ; int pos = 0 , neg = 0 ; for ( int i = 0 ; i < n ; i ++ ) { minimum = min ( minimum , abs ( a [ i ] ) ) ; sum += abs ( a [ i ] ) ; if ( a [ i ] >= 0 ) pos += 1 ; else neg += 1 ; } if ( pos > 0 && neg > 0 ) return sum ; return ( sum - 2 * minimum ) ; }
Hyp: 
int find_maximum_value ( int a [ ] , int n ) { int sum = 0 ; int minimum = INT_MAX ; int pos = 0 , neg = 0 ; for ( int i = 0 ; i < n ; i ++ ) { minimum = min ( minimum , abs ( a [ i ] ) ) ; sum += abs ( a [ i ] ) ; if ( a [ i ] >= 0 ) pos += 1 ; else neg += 1 ; } if ( pos > 0 && neg > 0 ) return sum ; return ( sum - 2 * minimum ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function find_probability ( p , q , r , s ) { var t = ( 1 - p / q ) * ( 1 - r / s ) ; var ans = ( p / q ) / ( 1 - t ) ; return ans ; }
Ref: 
double find_probability ( double p , double q , double r , double s ) { double t = ( 1 - p / q ) * ( 1 - r / s ) ; double ans = ( p / q ) / ( 1 - t ) ; return ans ; }
Hyp: 
float find_probability ( float p , float q , float r , float s ) { float t = ( 1 - p / q ) * ( 1 - r / s ) ; float ans = ( p / q ) / ( 1 - t ) ; return ans ; }

BLEU: 70.95
Edit Sim: 42


Src: 
function totalFlips ( A , B , C , N ) { let count = 0 ; for ( let i = 0 ; i < N ; ++ i ) { if ( A [ i ] == B [ i ] && C [ i ] == ' ' ) ++ count ; else if ( A [ i ] != B [ i ] && C [ i ] == ' ' ) ++ count ; } return count ; }
Ref: 
int totalFlips ( char * A , char * B , char * C , int N ) { int count = 0 ; for ( int i = 0 ; i < N ; ++ i ) { if ( A [ i ] == B [ i ] && C [ i ] == '1' ) ++ count ; else if ( A [ i ] != B [ i ] && C [ i ] == '0' ) ++ count ; } return count ; }
Hyp: 
int totalFlips ( int A [ ] , int B [ ] , int C [ ] , int N ) { int count = 0 ; for ( int i = 0 ; i < N ; ++ i ) { if ( A [ i ] == B [ i ] && C [ i ] == '1' ) ++ count ; else if ( A [ i ] != B [ i ] && C [ i ] == '2' ) ++ count ; } return count ; }

BLEU: 81.51
Edit Sim: 22


Src: 
function getMinSteps ( n , jump ) { let quotient = Math . floor ( n / jump ) ; let remainder = n % jump ; let steps = quotient + remainder ; return steps ; }
Ref: 
int getMinSteps ( int n , int jump ) { int quotient = n / jump ; int remainder = n % jump ; int steps = quotient + remainder ; return steps ; }
Hyp: 
int getMinSteps ( int n , int jump ) { int quotient = n / jump ; int remainder = n % jump ; int steps = quotient + remainder ; return steps ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countIntegralSolutions ( n ) { let result = 0 ; for ( let i = 0 ; i <= n ; i ++ ) for ( let j = 0 ; j <= n - i ; j ++ ) for ( let k = 0 ; k <= ( n - i - j ) ; k ++ ) if ( i + j + k == n ) result ++ ; return result ; }
Ref: 
int countIntegralSolutions ( int n ) { int result = 0 ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= n - i ; j ++ ) for ( int k = 0 ; k <= ( n - i - j ) ; k ++ ) if ( i + j + k == n ) result ++ ; return result ; }
Hyp: 
int countIntegralSolutions ( int n ) { int result = 0 ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= n - i ; j ++ ) for ( int k = 0 ; k <= ( n - i - j ) ; k ++ ) if ( i + j + k == n ) result ++ ; return result ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function minSum ( ar , n ) { if ( n <= 4 ) return Math . min . apply ( Math , ar ) ; var i ; var sum = Array ( n ) . fill ( n ) ; sum [ 0 ] = ar [ 0 ] ; sum [ 1 ] = ar [ 1 ] ; sum [ 2 ] = ar [ 2 ] ; sum [ 3 ] = ar [ 3 ] ; for ( i = 4 ; i < n ; i ++ ) { var temp = [ ] ; var it ; for ( it = i - 4 ; it < i ; it ++ ) temp . push ( sum [ it ] ) ; sum [ i ] = ar [ i ] + Math . min . apply ( Math , temp ) ; } var temp1 = [ ] ; for ( i = n - 4 ; i < n ; i ++ ) temp1 . push ( sum [ i ] ) ; return Math . min . apply ( Math , temp1 ) ; }
Ref: 
int minSum ( int ar [ ] , int n ) { if ( n <= 4 ) return * min_element ( ar , ar + n ) ; int sum [ n ] ; sum [ 0 ] = ar [ 0 ] ; sum [ 1 ] = ar [ 1 ] ; sum [ 2 ] = ar [ 2 ] ; sum [ 3 ] = ar [ 3 ] ; for ( int i = 4 ; i < n ; i ++ ) sum [ i ] = ar [ i ] + ( * min_element ( sum + i - 4 , sum + i ) ) ; return * min_element ( sum + n - 4 , sum + n ) ; }
Hyp: 
int minSum ( int ar [ ] , int n ) { if ( n <= 4 ) return min . apply ( min , ar ) ; int i ; int sum [ n ] ; sum [ 0 ] = ar [ 0 ] ; sum [ 1 ] = ar [ 1 ] ; sum [ 2 ] = ar [ 2 ] ; sum [ 3 ] = ar [ 3 ] ; for ( i = 4 ; i < n ; i ++ ) { int temp [ n ] ; int it ; for ( it = i - 4 ; it < i ; it ++ ) temp . push_back ( sum [ it ] ) ; sum [ i ] = ar [ i ] + min . apply ( min , temp ) ; } int temp1 [ ] ; for ( i = n - 4 ; i < n ; i ++ ) temp1 . push_back ( sum [ i ] ) ; return min . apply ( min , temp1 ) ; }

BLEU: 50.87
Edit Sim: 216


Src: 
function search ( arr , l , h , key ) { if ( l > h ) return - 1 ; let mid = Math . floor ( ( l + h ) / 2 ) ; if ( arr [ mid ] == key ) return mid ; if ( arr [ l ] <= arr [ mid ] ) { if ( key >= arr [ l ] && key <= arr [ mid ] ) return search ( arr , l , mid - 1 , key ) ; return search ( arr , mid + 1 , h , key ) ; } if ( key >= arr [ mid ] && key <= arr [ h ] ) return search ( arr , mid + 1 , h , key ) ; return search ( arr , l , mid - 1 , key ) ; }
Ref: 
int search ( int arr [ ] , int l , int h , int key ) { if ( l > h ) return -1 ; int mid = ( l + h ) / 2 ; if ( arr [ mid ] == key ) return mid ; if ( arr [ l ] <= arr [ mid ] ) { if ( key >= arr [ l ] && key <= arr [ mid ] ) return search ( arr , l , mid - 1 , key ) ; return search ( arr , mid + 1 , h , key ) ; } if ( key >= arr [ mid ] && key <= arr [ h ] ) return search ( arr , mid + 1 , h , key ) ; return search ( arr , l , mid - 1 , key ) ; }
Hyp: 
int search ( int arr [ ] , int l , int h , int key ) { if ( l > h ) return -1 ; int mid = ( l + h ) / 2 ; if ( arr [ mid ] == key ) return mid ; if ( arr [ l ] <= arr [ mid ] ) { if ( key >= arr [ l ] && key <= arr [ mid ] ) return search ( arr , l , mid - 1 , key ) ; return search ( arr , mid + 1 , h , key ) ; } if ( key >= arr [ mid ] && key <= arr [ h ] ) return search ( arr , mid + 1 , h , key ) ; return search ( arr , l , mid - 1 , key ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function FlipBits ( n ) { for ( let bit = 0 ; bit < 32 ; bit ++ ) { if ( ( ( n >> bit ) & 1 ) > 0 ) { n = n ^ ( 1 << bit ) ; break ; } } document . write ( " " ) ; document . write ( " " + n ) ; }
Ref: 
void FlipBits ( int n ) { for ( int bit = 0 ; bit < 32 ; bit ++ ) { if ( ( n >> bit ) & 1 ) { n = n ^ ( 1ll << bit ) ; break ; } } cout << " The ▁ number ▁ after ▁ unsetting ▁ the " ; cout << " ▁ rightmost ▁ set ▁ bit ▁ " << n ; }
Hyp: 
void FlipBits ( unsigned int n ) { for ( int bit = 0 ; bit < 32 ; bit ++ ) { if ( ( ( n >> bit ) & 1 ) ) { n = n ^ ( 1 << bit ) ; break ; } } cout << " Right ▁ Flipping : " << n ; cout << " Left ▁ Flipping : " << endl ; }

BLEU: 66.31
Edit Sim: 69


Src: 
function getProduct ( a , n ) { var p = 1 ; for ( var i = 0 ; i < n ; i ++ ) { for ( var j = i + 1 ; j < n ; j ++ ) { p *= Math . abs ( a [ i ] - a [ j ] ) ; } } return p ; }
Ref: 
int getProduct ( int a [ ] , int n ) { int p = 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { p *= abs ( a [ i ] - a [ j ] ) ; } } return p ; }
Hyp: 
int getProduct ( int a [ ] , int n ) { int p = 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { p *= abs ( a [ i ] - a [ j ] ) ; } } return p ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findSum ( n , k ) { var val = parseInt ( k / ( n - 1 ) ) * n ; var rem = k % ( n - 1 ) ; if ( rem == 0 ) { val = val - 1 ; } else { val = val + rem ; } var sum = parseInt ( ( val * ( val + 1 ) ) / 2 ) ; var x = parseInt ( k / ( n - 1 ) ) ; var sum_of_multiples = parseInt ( ( x * ( x + 1 ) * n ) / 2 ) ; sum -= sum_of_multiples ; return sum ; }
Ref: 
int findSum ( int n , int k ) { int val = ( k / ( n - 1 ) ) * n ; int rem = k % ( n - 1 ) ; if ( rem == 0 ) { val = val - 1 ; } else { val = val + rem ; } int sum = ( val * ( val + 1 ) ) / 2 ; int x = k / ( n - 1 ) ; int sum_of_multiples = ( x * ( x + 1 ) * n ) / 2 ; sum -= sum_of_multiples ; return sum ; }
Hyp: 
int findSum ( int n , int k ) { int val = k / ( n - 1 ) * n ; int rem = k % ( n - 1 ) ; if ( rem == 0 ) { val = val - 1 ; } else { val = val + rem ; } int sum = ( val * ( val + 1 ) ) / 2 ; int x = k / ( n - 1 ) ; int sum_of_multiples = ( x * ( x + 1 ) * n ) / 2 ; sum -= sum_of_multiples ; return sum ; }

BLEU: 96.08
Edit Sim: 4


Src: 
function reorder ( arr , index , n ) { for ( let i = 0 ; i < n ; i ++ ) { while ( index [ i ] != i ) { let oldTargetI = index [ index [ i ] ] ; let oldTargetE = arr [ index [ i ] ] ; arr [ index [ i ] ] = arr [ i ] ; index [ index [ i ] ] = index [ i ] ; index [ i ] = oldTargetI ; arr [ i ] = oldTargetE ; } } }
Ref: 
void reorder ( int arr [ ] , int index [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { while ( index [ i ] != i ) { int oldTargetI = index [ index [ i ] ] ; char oldTargetE = arr [ index [ i ] ] ; arr [ index [ i ] ] = arr [ i ] ; index [ index [ i ] ] = index [ i ] ; index [ i ] = oldTargetI ; arr [ i ] = oldTargetE ; } } }
Hyp: 
void reorder ( int arr [ ] , int index [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { while ( index [ i ] != i ) { int oldTargetI = index [ index [ i ] ] ; int oldTargetE = arr [ index [ i ] ] ; arr [ index [ i ] ] = arr [ i ] ; index [ index [ i ] ] = index [ i ] ; index [ i ] = oldTargetI ; arr [ i ] = oldTargetE ; } } }

BLEU: 97.64
Edit Sim: 4


Src: 
function Nthterm ( n ) { let numerator = Math . pow ( n , 2 ) - 1 ; let denomenator = 2 * n - 3 ; document . write ( numerator + " " + denomenator ) ; }
Ref: 
void Nthterm ( int n ) { int numerator = pow ( n , 2 ) - 1 ; int denomenator = 2 * n - 3 ; cout << numerator << " / " << denomenator ; }
Hyp: 
void Nthterm ( int n ) { long numerator = pow ( n , 2 ) - 1 ; long denomenator = 2 * n - 3 ; cout << numerator << " ▁ " << denomenator ; }

BLEU: 79.71
Edit Sim: 7


Src: 
function findDigits ( n ) { if ( n < 0 ) return 0 ; if ( n <= 1 ) return 1 ; let x = ( ( n * Math . log10 ( n / Math . E ) + Math . log10 ( 2 * Math . PI * n ) / 2.0 ) ) ; return Math . floor ( x ) + 1 ; }
Ref: 
long findDigits ( int n ) { if ( n < 0 ) return 0 ; if ( n <= 1 ) return 1 ; double x = ( ( n * log10 ( n / M_E ) + log10 ( 2 * M_PI * n ) / 2.0 ) ) ; return floor ( x ) + 1 ; }
Hyp: 
int findDigits ( int n ) { if ( n < 0 ) return 0 ; if ( n <= 1 ) return 1 ; double x = ( ( n * log10 ( n / M ) + log10 ( 2 * PI * n ) / 2.0 ) ) ; return floor ( x ) + 1 ; }

BLEU: 89.93
Edit Sim: 7


Src: 
function find ( a , b , k , n1 , n2 ) { var s = new Set ( ) ; for ( var i = 0 ; i < n2 ; i ++ ) s . add ( b [ i ] ) ; var missing = 0 ; for ( var i = 0 ; i < n1 ; i ++ ) { if ( ! s . has ( a [ i ] ) ) missing ++ ; if ( missing == k ) return a [ i ] ; } return - 1 ; }
Ref: 
int find ( int a [ ] , int b [ ] , int k , int n1 , int n2 ) { unordered_set < int > s ; for ( int i = 0 ; i < n2 ; i ++ ) s . insert ( b [ i ] ) ; int missing = 0 ; for ( int i = 0 ; i < n1 ; i ++ ) { if ( s . find ( a [ i ] ) == s . end ( ) ) missing ++ ; if ( missing == k ) return a [ i ] ; } return -1 ; }
Hyp: 
int find ( int a [ ] , int b [ ] , int k , int n1 , int n2 ) { unordered_set < int > s ; for ( int i = 0 ; i < n2 ; i ++ ) s . insert ( b [ i ] ) ; int missing = 0 ; for ( int i = 0 ; i < n1 ; i ++ ) { if ( s . find ( a [ i ] ) == s . end ( ) ) missing ++ ; if ( missing == k ) return a [ i ] ; } return -1 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countDirectPath ( N ) { return N + Math . floor ( ( N * ( N - 3 ) ) / 2 ) ; }
Ref: 
int countDirectPath ( int N ) { return N + ( N * ( N - 3 ) ) / 2 ; }
Hyp: 
int countDirectPath ( int N ) { return N + floor ( ( N * ( N - 3 ) ) / 2 ) ; }

BLEU: 76.62
Edit Sim: 10


Src: 
function countSwaps ( A , n ) { A . sort ( ) ; let ind = 1 , res = 0 ; for ( let i = 0 ; i < n ; i ++ ) { while ( ind < n && A [ ind ] == A [ i ] ) ind ++ ; if ( ind < n && A [ ind ] > A [ i ] ) { res ++ ; ind ++ ; } if ( ind >= n ) break ; } return res ; }
Ref: 
int countSwaps ( int A [ ] , int n ) { sort ( A , A + n ) ; int ind = 1 , res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { while ( ind < n and A [ ind ] == A [ i ] ) ind ++ ; if ( ind < n and A [ ind ] > A [ i ] ) { res ++ ; ind ++ ; } if ( ind >= n ) break ; } return res ; }
Hyp: 
int countSwaps ( int A [ ] , int n ) { sort ( A , A + n ) ; int ind = 1 , res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { while ( ind < n && A [ ind ] == A [ i ] ) ind ++ ; if ( ind < n && A [ ind ] > A [ i ] ) { res ++ ; ind ++ ; } if ( ind >= n ) break ; } return res ; }

BLEU: 94.97
Edit Sim: 6


Src: 
function sumOfSumSeries ( N ) { let sum = 0 ; for ( let i = 1 ; i <= N ; i ++ ) { sum = sum + ( i * ( i + 1 ) ) / 2 ; } return sum ; }
Ref: 
long sumOfSumSeries ( int N ) { long sum = 0L ; for ( int i = 1 ; i <= N ; i ++ ) { sum = sum + ( i * ( i + 1 ) ) / 2 ; } return sum ; }
Hyp: 
int sumOfSumSeries ( int N ) { int sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { sum = sum + ( i * ( i + 1 ) ) / 2 ; } return sum ; }

BLEU: 87.69
Edit Sim: 7


Src: 
function isUnique ( a , n , k ) { var sum = 0 ; for ( i = 0 ; i < n ; i ++ ) sum += a [ i ] ; sum += n - 1 ; return ( sum == k ) ; }
Ref: 
bool isUnique ( int a [ ] , int n , int k ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += a [ i ] ; sum += n - 1 ; return ( sum == k ) ; }
Hyp: 
bool isUnique ( int a [ ] , int n , int k ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += a [ i ] ; sum += n - 1 ; return ( sum == k ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function min_steps_required ( n , m , r , c ) { var i , j ; var corner_steps_req = Number . MAX_VALUE ; i = 1 ; j = 1 ; corner_steps_req = Math . min ( corner_steps_req , Math . abs ( r - i ) + Math . abs ( j - c ) ) ; i = n ; j = 1 ; corner_steps_req = Math . min ( corner_steps_req , Math . abs ( r - i ) + Math . abs ( j - c ) ) ; i = 1 ; j = m ; corner_steps_req = Math . min ( corner_steps_req , Math . abs ( r - i ) + Math . abs ( j - c ) ) ; i = n ; j = m ; corner_steps_req = Math . min ( corner_steps_req , Math . abs ( r - i ) + Math . abs ( j - c ) ) ; var minimum_steps = Math . min ( 2 * ( n - 1 ) + m - 1 , 2 * ( m - 1 ) + n - 1 ) ; return minimum_steps + corner_steps_req ; }
Ref: 
int min_steps_required ( int n , int m , int r , int c ) { int i , j ; int corner_steps_req = INT_MAX ; i = 1 ; j = 1 ; corner_steps_req = min ( corner_steps_req , abs ( r - i ) + abs ( j - c ) ) ; i = n ; j = 1 ; corner_steps_req = min ( corner_steps_req , abs ( r - i ) + abs ( j - c ) ) ; i = 1 ; j = m ; corner_steps_req = min ( corner_steps_req , abs ( r - i ) + abs ( j - c ) ) ; i = n ; j = m ; corner_steps_req = min ( corner_steps_req , abs ( r - i ) + abs ( j - c ) ) ; int minimum_steps = min ( 2 * ( n - 1 ) + m - 1 , 2 * ( m - 1 ) + n - 1 ) ; return minimum_steps + corner_steps_req ; }
Hyp: 
int min_steps_required ( int n , int m , int r , int c ) { int i , j ; int corner_steps_req = INT_MAX ; i = 1 ; j = 1 ; corner_steps_req = min ( corner_steps_req , abs ( r - i ) + abs ( j - c ) ) ; i = n ; j = 1 ; corner_steps_req = min ( corner_steps_req , abs ( r - i ) + abs ( j - c ) ) ; i = 1 ; j = m ; corner_steps_req = min ( corner_steps_req , abs ( r - i ) + abs ( j - c ) ) ; i = n ; j = m ; corner_steps_req = min ( corner_steps_req , abs ( r - i ) + abs ( j - c ) ) ; i = n ; j = m ; corner_steps_req = min ( corner_steps_req , abs ( r - i ) + abs ( j - c ) ) ; i = n ; j = m ; corner_steps_req = min ( corner_steps_req , abs ( r - i ) + abs ( j - c ) ) ; int minimum_steps = min ( 2 * ( n - 1 ) + m - 1 , 2 * ( m - 1 ) + n - 1 ) ; return minimum_steps + corner_steps_req ; }

BLEU: 75.37
Edit Sim: 188


Src: 
function convertBfromA ( a , b ) { let moves = 0 ; let x = Math . abs ( a - b ) ; for ( let i = 10 ; i > 0 ; i -- ) { moves += Math . floor ( x / i ) ; x = x % i ; } document . write ( moves + " " ) ; }
Ref: 
void convertBfromA ( int a , int b ) { int moves = 0 ; int x = abs ( a - b ) ; for ( int i = 10 ; i > 0 ; i -- ) { moves += x / i ; x = x % i ; } cout << moves << " ▁ " ; }
Hyp: 
void convertBfromA ( int a , int b ) { int moves = 0 ; int x = abs ( a - b ) ; for ( int i = 10 ; i > 0 ; i -- ) { moves += x / i ; x = x % i ; } cout << moves << endl ; }

BLEU: 93.03
Edit Sim: 5


Src: 
function rod ( h , r ) { if ( h < 0 && r < 0 ) return - 1 ; var l = ( Math . sqrt ( Math . pow ( h , 2 ) + 4 * Math . pow ( r , 2 ) ) ) ; return l ; }
Ref: 
float rod ( float h , float r ) { if ( h < 0 && r < 0 ) return -1 ; float l = sqrt ( pow ( h , 2 ) + 4 * pow ( r , 2 ) ) ; return l ; }
Hyp: 
float rod ( float h , float r ) { if ( h < 0 && r < 0 ) return -1 ; float l = sqrt ( pow ( h , 2 ) + 4 * pow ( r , 2 ) ) ; return l ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findSum ( arr , n , left , right ) { let k = right - left ; let d = arr [ 1 ] - arr [ 0 ] ; let ans = arr [ left - 1 ] * ( k + 1 ) ; ans = ans + ( d * ( k * ( k + 1 ) ) ) / 2 ; return ans ; }
Ref: 
int findSum ( int * arr , int n , int left , int right ) { int k = right - left ; int d = arr [ 1 ] - arr [ 0 ] ; int ans = arr [ left - 1 ] * ( k + 1 ) ; ans = ans + ( d * ( k * ( k + 1 ) ) ) / 2 ; return ans ; }
Hyp: 
int findSum ( int arr [ ] , int n , int left , int right ) { int k = right - left ; int d = arr [ 1 ] - arr [ 0 ] ; int ans = arr [ left - 1 ] * ( k + 1 ) ; ans = ans + ( d * ( k * ( k + 1 ) ) ) / 2 ; return ans ; }

BLEU: 94.47
Edit Sim: 6


Src: 
function countPairs ( arr , n ) { let ans = 0 ; let count = new Map ( ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( count . has ( arr [ i ] ) ) { ans += count . get ( arr [ i ] ) ; count . set ( arr [ i ] , count . get ( arr [ i ] ) + 1 ) ; } else { count . set ( arr [ i ] , 1 ) ; } } return ans ; }
Ref: 
int countPairs ( int arr [ ] , int n ) { int ans = 0 ; unordered_map < int , int > count ; for ( int i = 0 ; i < n ; i ++ ) { if ( count [ arr [ i ] ] != 0 ) ans += count [ arr [ i ] ] ; count [ arr [ i ] ] ++ ; } return ans ; }
Hyp: 
int countPairs ( int arr [ ] , int n ) { int ans = 0 ; unordered_map < int , int > count ; for ( int i = 0 ; i < n ; i ++ ) { ans += count [ arr [ i ] ] ; count [ arr [ i ] ] ++ ; } return ans ; }

BLEU: 80.9
Edit Sim: 32


Src: 
function MinimumValue ( x , y ) { if ( x > y ) { var temp = x ; x = y ; y = temp ; } var a = 1 ; var b = x - 1 ; var c = y - b ; document . write ( a + " " + b + " " + c ) ; }
Ref: 
void MinimumValue ( int x , int y ) { if ( x > y ) swap ( x , y ) ; int a = 1 ; int b = x - 1 ; int c = y - b ; cout << a << " ▁ " << b << " ▁ " << c ; }
Hyp: 
void MinimumValue ( int x , int y ) { if ( x > y ) { int temp = x ; x = y ; y = temp ; } int a = 1 ; int b = x - 1 ; int c = y - b ; cout << a << " ▁ " << b << " ▁ " << c ; }

BLEU: 76.16
Edit Sim: 27


Src: 
function totalNumber ( n ) { return 8 * Math . pow ( 9 , n - 1 ) ; }
Ref: 
int totalNumber ( int n ) { return 8 * pow ( 9 , n - 1 ) ; }
Hyp: 
int totalNumber ( int n ) { return 8 * pow ( 9 , n - 1 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function possiblePositions ( n ) { let term1 = Math . pow ( n , 4 ) ; let term2 = Math . pow ( n , 3 ) ; let term3 = Math . pow ( n , 2 ) ; let term4 = n / 3 ; let ans = ( Math . ceil ( term1 / 2 ) ) - ( Math . ceil ( 5 * term2 ) / 3 ) + ( Math . ceil ( 3 * term3 ) / 2 ) - term4 ; return ans ; }
Ref: 
ll possiblePositions ( ll n ) { ll term1 = pow ( n , 4 ) ; ll term2 = pow ( n , 3 ) ; ll term3 = pow ( n , 2 ) ; ll term4 = n / 3 ; ll ans = ( ceil ) ( term1 ) / 2 - ( ceil ) ( 5 * term2 ) / 3 + ( ceil ) ( 3 * term3 ) / 2 - term4 ; return ans ; }
Hyp: 
int possiblePositions ( int n ) { double term1 = pow ( n , 4 ) ; double term2 = pow ( n , 3 ) ; double term3 = pow ( n , 2 ) ; double term4 = n / 3 ; int ans = ( ceil ( term1 / 2 ) ) - ( ceil ( 5 * term2 ) / 3 ) + ( ceil ( 3 * term3 ) / 2 ) - term4 ; return ans ; }

BLEU: 62.75
Edit Sim: 44


Src: 
function findNumber ( N ) { return N & ( N + 1 ) ; }
Ref: 
int findNumber ( int N ) { return N & ( N + 1 ) ; }
Hyp: 
int findNumber ( int N ) { return N & ( N + 1 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function search ( pat , txt ) { let M = pat . length ; let N = txt . length ; let i = 0 ; while ( i <= N - M ) { let j ; for ( j = 0 ; j < M ; j ++ ) if ( txt [ i + j ] != pat [ j ] ) break ; if ( j == M ) { document . write ( " " + i + " " ) ; i = i + M ; } else if ( j == 0 ) i = i + 1 ; else i = i + j ; } }
Ref: 
void search ( string pat , string txt ) { int M = pat . size ( ) ; int N = txt . size ( ) ; int i = 0 ; while ( i <= N - M ) { int j ; for ( j = 0 ; j < M ; j ++ ) if ( txt [ i + j ] != pat [ j ] ) break ; { cout << " Pattern ▁ found ▁ at ▁ index ▁ " << i << endl ; i = i + M ; } else if ( j == 0 ) i = i + 1 ; else i = i + j ; } }
Hyp: 
int search ( string pat , string txt ) { int M = pat . length ( ) ; int N = txt . length ( ) ; int i = 0 ; while ( i <= N - M ) { int j ; for ( j = 0 ; j < M ; j ++ ) if ( txt [ i + j ] != pat [ j ] ) break ; if ( j == M ) { cout << " Not ▁ Found " << i << " ▁ " ; i = i + M ; } else if ( j == 0 ) i = i + 1 ; else i = i + j ; } }

BLEU: 82.17
Edit Sim: 53


Src: 
function maxItems ( x , y , z ) { let type1 = parseInt ( x / COST ) ; x %= COST ; let type2 = parseInt ( y / COST ) ; y %= COST ; let type3 = parseInt ( z / COST ) ; z %= COST ; let type4 = Math . min ( x , Math . min ( y , z ) ) ; let maxItems = type1 + type2 + type3 + type4 ; return maxItems ; }
Ref: 
int maxItems ( int x , int y , int z ) { int type1 = x / COST ; x %= COST ; int type2 = y / COST ; y %= COST ; int type3 = z / COST ; z %= COST ; int type4 = min ( x , min ( y , z ) ) ; int maxItems = type1 + type2 + type3 + type4 ; return maxItems ; }
Hyp: 
int maxItems ( int x , int y , int z ) { int type1 = x / COST ; x %= COST ; int type2 = y / COST ; y %= COST ; int type3 = z / COST ; z %= COST ; int type4 = min ( x , min ( y , z ) ) ; int maxItems = type1 + type2 + type3 + type4 ; return maxItems ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countPairs ( arr , n ) { let ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] == arr [ j ] ) ans ++ ; return ans ; }
Ref: 
int countPairs ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] == arr [ j ] ) ans ++ ; return ans ; }
Hyp: 
int countPairs ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] == arr [ j ] ) ans ++ ; return ans ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countNumbers ( N ) { return parseInt ( ( Math . pow ( 10 , N ) - Math . pow ( 8 , N ) ) / 2 , 10 ) ; }
Ref: 
int countNumbers ( int N ) { return ( pow ( 10 , N ) - pow ( 8 , N ) ) / 2 ; }
Hyp: 
int countNumbers ( int N ) { return ( pow ( 10 , N ) - pow ( 8 , N ) ) / 2 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function evenbinomialCoeffSum ( n ) { return ( 1 << ( n - 1 ) ) ; }
Ref: 
int evenbinomialCoeffSum ( int n ) { return ( 1 << ( n - 1 ) ) ; }
Hyp: 
int evenbinomialCoeffSum ( int n ) { return ( 1 << ( n - 1 ) ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findPairs ( arr , N ) { for ( let i = 0 ; i < N ; i ++ ) arr [ i ] = Math . abs ( arr [ i ] ) ; arr . sort ( ( a , b ) => a - b ) ; let left = 0 ; let ans = 0 ; for ( let right = 0 ; right < N ; right ++ ) { while ( 2 * arr [ left ] < arr [ right ] ) left ++ ; ans += ( right - left ) ; } document . write ( ans ) ; }
Ref: 
void findPairs ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) arr [ i ] = abs ( arr [ i ] ) ; sort ( arr , arr + N ) ; int left = 0 ; int ans = 0 ; for ( int right = 0 ; right < N ; right ++ ) { while ( 2 * arr [ left ] < arr [ right ] ) left ++ ; ans += ( right - left ) ; } cout << ans ; }
Hyp: 
void findPairs ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) arr [ i ] = abs ( arr [ i ] ) ; sort ( arr , arr + N ) ; int left = 0 ; int ans = 0 ; for ( int right = 0 ; right < N ; right ++ ) { while ( 2 * arr [ left ] < arr [ right ] ) left ++ ; ans += ( right - left ) ; } cout << ans ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function printKNumbers ( N , K ) { for ( let i = 0 ; i < K - 1 ; i ++ ) document . write ( 1 + " " ) ; document . write ( N - K + 1 ) ; }
Ref: 
void printKNumbers ( int N , int K ) { for ( int i = 0 ; i < K - 1 ; i ++ ) cout << 1 << " ▁ " ; cout << ( N - K + 1 ) ; }
Hyp: 
void printKNumbers ( int N , int K ) { for ( int i = 0 ; i < K - 1 ; i ++ ) cout << 1 << " ▁ " ; cout << N - K + 1 ; }

BLEU: 89.05
Edit Sim: 4


Src: 
function fnMod ( n ) { if ( n % 5 == 1 ) return 4 ; else return 0 ; }
Ref: 
int fnMod ( int n ) { if ( n % 5 == 1 ) return 4 ; else return 0 ; }
Hyp: 
int fnMod ( int n ) { if ( n % 5 == 1 ) return 4 ; else return 0 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function isValid ( str , n ) { if ( ! ( ( str [ 0 ] >= ' ' && str [ 0 ] <= ' ' ) || ( str [ 0 ] >= ' ' && str [ 0 ] <= ' ' ) str [ 0 ] == ' ' ) ) return false ; for ( let i = 1 ; i < str . length ; i ++ ) { if ( ! ( ( str [ i ] >= ' ' && str [ i ] <= ' ' ) || ( str [ i ] >= ' ' && str [ i ] <= ' ' ) || ( str [ i ] >= ' ' && str [ i ] <= ' ' ) str [ i ] == ' ' ) ) return false ; } return true ; }
Ref: 
bool isValid ( string str , int n ) { if ( ! ( ( str [ 0 ] >= ' a ' && str [ 0 ] <= ' z ' ) || ( str [ 0 ] >= ' A ' && str [ 0 ] <= ' Z ' ) str [ 0 ] == ' _ ' ) ) return false ; for ( int i = 1 ; i < str . length ( ) ; i ++ ) { if ( ! ( ( str [ i ] >= ' a ' && str [ i ] <= ' z ' ) || ( str [ i ] >= ' A ' && str [ i ] <= ' Z ' ) || ( str [ i ] >= '0' && str [ i ] <= '9' ) str [ i ] == ' _ ' ) ) return false ; } return true ; }
Hyp: 
bool isValid ( string str , int n ) { if ( ! ( ( str [ 0 ] >= ' A ' && str [ 0 ] <= ' Z ' ) || ( str [ 0 ] >= ' a ' && str [ 0 ] <= ' z ' ) str [ 0 ] == ' . ' ) ) return false ; for ( int i = 1 ; str [ i ] != ' . ' ; i ++ ) { if ( ! ( ( str [ i ] >= ' A ' && str [ i ] <= ' Z ' ) || ( str [ i ] >= ' a ' && str [ i ] <= ' z ' ) str [ i ] == ' . ' ) ) return false ; } return true ; }

BLEU: 82.16
Edit Sim: 69


Src: 
function findLargestDivisor ( n ) { for ( let i = 2 ; i < Math . sqrt ( n ) + 1 ; i ++ ) { while ( n % ( i * i ) == 0 ) { n = n / i ; } } return n ; }
Ref: 
int findLargestDivisor ( int n ) { for ( int i = 2 ; i < sqrt ( n ) + 1 ; i ++ ) { while ( n % ( i * i ) == 0 ) { n = n / i ; } } return n ; }
Hyp: 
int findLargestDivisor ( int n ) { for ( int i = 2 ; i < sqrt ( n ) + 1 ; i ++ ) { while ( n % ( i * i ) == 0 ) { n = n / i ; } } return n ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function get_maximum ( s , a ) { let n = s . length ; for ( let i = 0 ; i < n ; i ++ ) { if ( s [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) < a [ s [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ] ) { let j = i ; while ( j < n && ( s [ j ] . charCodeAt ( ) - ' ' . charCodeAt ( ) <= a [ s [ j ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ] ) ) { s [ j ] = String . fromCharCode ( ' ' . charCodeAt ( ) + a [ s [ j ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ] ) ; j ++ ; } return s . join ( " " ) ; } } return s . join ( " " ) ; }
Ref: 
string get_maximum ( string s , int a [ ] ) { int n = s . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] - '0' < a [ s [ i ] - '0' ] ) { int j = i ; while ( j < n && ( s [ j ] - '0' <= a [ s [ j ] - '0' ] ) ) { s [ j ] = '0' + a [ s [ j ] - '0' ] ; j ++ ; } return s ; } } return s ; }
Hyp: 
void get_maximum ( string & s , int a [ ] ) { int n = s . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] - ' a ' < a [ s [ i ] - ' a ' ] ) { int j = i ; while ( j < n && ( s [ j ] - ' a ' <= a [ s [ j ] - ' a ' ] ) ) { s [ j ] = char ( ' a ' + a [ s [ j ] - ' a ' ] ) ; j ++ ; } return s . substr ( 0 , j ) ; } } return s . join ( " ▁ " ) ; }

BLEU: 64.74
Edit Sim: 70


Src: 
function tidyNum ( str1 , len ) { var str = str1 . split ( ' ' ) ; for ( i = len - 2 ; i >= 0 ; i -- ) { if ( str [ i ] > str [ i + 1 ] ) { str [ i ] -- ; for ( j = i + 1 ; j < len ; j ++ ) str [ j ] = ' ' ; } } return str . join ( " " ) ; }
Ref: 
int main ( ) { char str [ ] = "11333445538" ; int len = strlen ( str ) ; char * num = tidyNum ( str , len ) ; printf ( " % s STRNEWLINE " , num ) ; return 0 ; }
Hyp: 
string tidyNum ( string str1 , int len ) { string str [ ] ; for ( int i = len - 2 ; i >= 0 ; i -- ) { if ( str [ i ] > str [ i + 1 ] ) { str [ i ] -- ; for ( int j = i + 1 ; j < len ; j ++ ) str [ j ] = '0' ; } } return str ; }

BLEU: 6.32
Edit Sim: 149


Src: 
function solve ( s , k ) { var count = 0 , length = 0 , pos = 0 ; var m = new Map ( ) ; for ( var i = 0 ; i < s . length ; i ++ ) { if ( ! m . has ( s [ i ] ) ) { m . set ( s [ i ] , 0 ) ; } m . set ( s [ i ] , m . get ( s [ i ] ) + 1 ) ; length ++ ; if ( length > k ) { if ( ! m . has ( s [ pos ] ) ) { m . set ( s [ pos ] , 0 ) ; } m . set ( s [ pos ] , m [ s [ pos ] ] - 1 ) ; pos += 1 ; length -- ; } if ( length == k && m . get ( s [ i ] ) == length ) count ++ ; } document . write ( count ) ; }
Ref: 
void solve ( string s , int k ) { int count = 0 , length = 0 , pos = 0 ; map < char , int > m ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { m [ s [ i ] ] ++ ; length ++ ; if ( length > k ) { m [ s [ pos ++ ] ] -- ; length -- ; } if ( length == k && m [ s [ i ] ] == length ) count ++ ; } cout << count << endl ; }
Hyp: 
void solve ( string s , int k ) { int count = 0 , length = 0 , pos = 0 ; unordered_map < char , int > m ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { if ( m [ s [ i ] ] != 1 ) { m [ s [ i ] ] ++ ; length ++ ; if ( length > k ) { if ( m [ s [ pos ] ] != 1 ) { m [ s [ pos ] ] ++ ; } m [ s [ pos ] ] = m [ s [ pos ] ] - 1 ; pos += 1 ; length -- ; } if ( length == k && m [ s [ i ] ] == length ) count ++ ; } cout << count << endl ; }

BLEU: 63.05
Edit Sim: 125


Src: 
function findCost ( A , N ) { var totalCost = 0 ; var i ; for ( i = 0 ; i < N ; i ++ ) { if ( A [ i ] == 0 ) { A [ i ] = 1 ; totalCost += i ; } } return totalCost ; }
Ref: 
int findCost ( int A [ ] , int N ) { int totalCost = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( A [ i ] == 0 ) { A [ i ] = 1 ; totalCost += i ; } } return totalCost ; }
Hyp: 
int findCost ( int A [ ] , int N ) { int totalCost = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( A [ i ] == 0 ) { A [ i ] = 1 ; totalCost += i ; } } return totalCost ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countXorPair ( arr , n ) { let odd = 0 , even = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) even ++ ; else odd ++ ; } return odd * even ; }
Ref: 
int countXorPair ( int arr [ ] , int n ) { int odd = 0 , even = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) even ++ ; else odd ++ ; } return odd * even ; }
Hyp: 
int countXorPair ( int arr [ ] , int n ) { int odd = 0 , even = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) even ++ ; else odd ++ ; } return odd * even ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function Nonagonal ( n ) { return parseInt ( n * ( 7 * n - 5 ) / 2 ) ; }
Ref: 
int Nonagonal ( int n ) { return n * ( 7 * n - 5 ) / 2 ; }
Hyp: 
int Nonagonal ( int n ) { return n * ( 7 * n - 5 ) / 2 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function check ( a , n ) { for ( var i = 0 ; i < n ; i ++ ) if ( a [ i ] ) return true ; return false ; }
Ref: 
bool check ( int a [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) if ( a [ i ] ) return true ; return false ; }
Hyp: 
bool check ( int a [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) if ( a [ i ] ) return true ; return false ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function cntSubArrays ( arr , n , k ) { var res = 0 ; var i = 0 ; while ( i < n ) { var j = i + 1 ; while ( j < n && arr [ j ] >= arr [ j - 1 ] ) j ++ ; res += Math . max ( j - i - k + 1 , 0 ) ; i = j ; } return res ; }
Ref: 
int cntSubArrays ( int * arr , int n , int k ) { int res = 0 ; int i = 0 ; while ( i < n ) { int j = i + 1 ; while ( j < n and arr [ j ] > = arr [ j - 1 ] ) j ++ ; res += max ( j - i - k + 1 , 0 ) ; i = j ; } return res ; }
Hyp: 
int cntSubArrays ( int * arr , int n , int k ) { int res = 0 ; int i = 0 ; while ( i < n ) { int j = i + 1 ; while ( j < n and arr [ j ] > = arr [ j - 1 ] ) j ++ ; res += max ( j - i - k + 1 , 0 ) ; i = j ; } return res ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function RightRotate ( a , n , k ) { k = k % n ; for ( let i = 0 ; i < n ; i ++ ) { if ( i < k ) { document . write ( a [ n + i - k ] + " " ) ; } else { document . write ( ( a [ i - k ] ) + " " ) ; } } document . write ( " " ) ; }
Ref: 
void RightRotate ( int a [ ] , int n , int k ) { k = k % n ; for ( int i = 0 ; i < n ; i ++ ) { if ( i < k ) { cout << a [ n + i - k ] << " ▁ " ; } else { cout << ( a [ i - k ] ) << " ▁ " ; } } cout << " STRNEWLINE " ; }
Hyp: 
void RightRotate ( int a [ ] , int n , int k ) { k = k % n ; for ( int i = 0 ; i < n ; i ++ ) { if ( i < k ) { cout << a [ n + i - k ] << " ▁ " ; } else { cout << ( a [ i - k ] ) << " ▁ " ; } } cout << endl ; }

BLEU: 94.94
Edit Sim: 14


Src: 
function kPresentProbability ( a , n , k ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) if ( a [ i ] == k ) count += 1 ; return count / n ; }
Ref: 
float kPresentProbability ( int a [ ] , int n , int k ) { float count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( a [ i ] == k ) count ++ ; return count / n ; }
Hyp: 
float kPresentProbability ( int a [ ] , int n , int k ) { float count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( a [ i ] == k ) count += 1 ; return count / n ; }

BLEU: 93.26
Edit Sim: 3


Src: 
function oppositeSigns ( x , y ) { return ( ( x ^ y ) < 0 ) ; }
Ref: 
bool oppositeSigns ( int x , int y ) { return ( ( x ^ y ) < 0 ) ; }
Hyp: 
bool oppositeSigns ( int x , int y ) { return ( ( x ^ y ) < 0 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function numberOfCuts ( M , N ) { var result = 0 ; result = ( M - 1 ) * ( N - 1 ) ; return result ; }
Ref: 
int numberOfCuts ( int M , int N ) { int result = 0 ; result = ( M - 1 ) * ( N - 1 ) ; return result ; }
Hyp: 
int numberOfCuts ( int M , int N ) { int result = 0 ; result = ( M - 1 ) * ( N - 1 ) ; return result ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function minProduct ( n ) { let ans = 1 ; for ( let i = 1 ; i <= Math . floor ( ( n - 4 ) / 2 ) ; i ++ ) { ans = ( 1 * ans * ( n - 2 ) ) % mod ; } ans = ( 1 * ans * ( n - 2 ) * ( n - 1 ) ) % mod ; document . write ( ans + " " ) ; }
Ref: 
void minProduct ( int n ) { int ans = 1 ; for ( int i = 1 ; i <= ( n - 4 ) / 2 ; i ++ ) { ans = ( 1LL * ans * ( n - 2 ) ) % mod ; } ans = ( 1LL * ans * ( n - 2 ) * ( n - 1 ) ) % mod ; cout << ans << endl ; }
Hyp: 
int minProduct ( int n ) { int ans = 1 ; for ( int i = 1 ; i <= ( n - 4 ) / 2 ; i ++ ) { ans = ( 1 * ans * ( n - 2 ) ) % mod ; } ans = ( 1 * ans * ( n - 2 ) * ( n - 1 ) ) % mod ; cout << ans << endl ; }

BLEU: 92.27
Edit Sim: 8


Src: 
function countDistinct ( arr , n ) { arr . sort ( function ( a , b ) { return a - b ; } ) ; let res = 0 ; for ( let i = 0 ; i < n ; i ++ ) { while ( i < n - 1 && arr [ i ] == arr [ i + 1 ] ) { i ++ ; } res ++ ; } return res ; }
Ref: 
int countDistinct ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { while ( i < n - 1 && arr [ i ] == arr [ i + 1 ] ) i ++ ; res ++ ; } return res ; }
Hyp: 
int countDistinct ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { while ( i < n - 1 && arr [ i ] == arr [ i + 1 ] ) { i ++ ; } res ++ ; } return res ; }

BLEU: 93.1
Edit Sim: 4


Src: 
function getHermiteNumber ( n ) { if ( n == 0 ) return 1 ; else if ( n == 1 ) return 1 ; else return - 2 * ( n - 1 ) * getHermiteNumber ( n - 2 ) ; }
Ref: 
int getHermiteNumber ( int n ) { if ( n == 0 ) return 1 ; if ( n == 1 ) return 0 ; else return -2 * ( n - 1 ) * getHermiteNumber ( n - 2 ) ; }
Hyp: 
int getHermiteNumber ( int n ) { if ( n == 0 ) return 1 ; else if ( n == 1 ) return 1 ; else return - 2 * ( n - 1 ) * getHermiteNumber ( n - 2 ) ; }

BLEU: 80.29
Edit Sim: 7


Src: 
function last_digit ( X , Y ) { document . write ( X % Y ) ; }
Ref: 
void last_digit ( int X , int Y ) { cout << X % Y ; }
Hyp: 
void last_digit ( int X , int Y ) { cout << X % Y ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function replace ( s , c1 , c2 ) { let l = s . length ; let arr = s . split ( " " ) ; for ( let i = 0 ; i < l ; i ++ ) { if ( arr [ i ] == c1 ) arr [ i ] = c2 ; else if ( arr [ i ] == c2 ) arr [ i ] = c1 ; } return arr . join ( " " ) ; }
Ref: 
string replace ( string s , char c1 , char c2 ) { int l = s . length ( ) ; for ( int i = 0 ; i < l ; i ++ ) { if ( s [ i ] == c1 ) s [ i ] = c2 ; else if ( s [ i ] == c2 ) s [ i ] = c1 ; } return s ; }
Hyp: 
void replace ( string s , char c1 , char c2 ) { int l = s . length ( ) ; string arr [ l ] ; for ( int i = 0 ; i < l ; i ++ ) { if ( arr [ i ] == c1 ) arr [ i ] = c2 ; else if ( arr [ i ] == c2 ) arr [ i ] = c1 ; } return s ; }

BLEU: 77.82
Edit Sim: 36


Src: 
function findS ( s ) { var sum = 0 ; for ( n = 1 ; sum < s ; n ++ ) { sum += n ; if ( sum == s ) return n ; } return - 1 ; }
Ref: 
int findS ( int s ) { int sum = 0 ; for ( int n = 1 ; sum < s ; n ++ ) { sum += n ; if ( sum == s ) return n ; } return -1 ; }
Hyp: 
int findS ( int s ) { int sum = 0 ; for ( int n = 1 ; sum < s ; n ++ ) { sum += n ; if ( sum == s ) return n ; } return -1 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function getMinSquares ( n ) { if ( n <= 3 ) return n ; var dp = new Array ( n + 1 ) ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; dp [ 2 ] = 2 ; dp [ 3 ] = 3 ; for ( var i = 4 ; i <= n ; i ++ ) { dp [ i ] = i ; for ( var x = 1 ; x <= Math . ceil ( Math . sqrt ( i ) ) ; x ++ ) { var temp = x * x ; if ( temp > i ) break ; else dp [ i ] = Math . min ( dp [ i ] , 1 + dp [ i - temp ] ) ; } } var res = dp [ n ] ; return res ; }
Ref: 
int getMinSquares ( int n ) { if ( n <= 3 ) return n ; int * dp = new int [ n + 1 ] ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; dp [ 2 ] = 2 ; dp [ 3 ] = 3 ; for ( int i = 4 ; i <= n ; i ++ ) { dp [ i ] = i ; for ( int x = 1 ; x <= ceil ( sqrt ( i ) ) ; x ++ ) { int temp = x * x ; if ( temp > i ) break ; else dp [ i ] = min ( dp [ i ] , 1 + dp [ i - temp ] ) ; } } int res = dp [ n ] ; delete [ ] dp ; return res ; }
Hyp: 
int getMinSquares ( int n ) { if ( n <= 3 ) return n ; int dp [ n + 1 ] ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; dp [ 2 ] = 2 ; dp [ 3 ] = 3 ; for ( int i = 4 ; i <= n ; i ++ ) { dp [ i ] = i ; for ( int x = 1 ; x <= ceil ( sqrt ( i ) ) ; x ++ ) { int temp = x * x ; if ( temp > i ) break ; else dp [ i ] = min ( dp [ i ] , 1 + dp [ i - temp ] ) ; } } int res = dp [ n ] ; return res ; }

BLEU: 92.11
Edit Sim: 28


Src: 
function Max_Sum ( n ) { return parseInt ( ( n * ( n - 1 ) ) / 2 ) ; }
Ref: 
int Max_Sum ( int n ) { return ( n * ( n - 1 ) ) / 2 ; }
Hyp: 
int Max_Sum ( int n ) { return ( n * ( n - 1 ) ) / 2 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function minimumcntOperationReq ( arr , N ) { let cntOp = 0 ; for ( let i = 0 ; i < N - 1 ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) { cntOp ++ ; } } return ( cntOp + 1 ) / 2 ; }
Ref: 
int minimumcntOperationReq ( int arr [ ] , int N ) { int cntOp = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) { cntOp ++ ; } } return ( cntOp + 1 ) / 2 ; }
Hyp: 
int minimumcntOperationReq ( int arr [ ] , int N ) { int cntOp = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) { cntOp ++ ; } } return ( cntOp + 1 ) / 2 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findPoints ( l1 , r1 , l2 , r2 ) { var x = ( l1 != l2 ) ? Math . min ( l1 , l2 ) : - 1 ; var y = ( r1 != r2 ) ? Math . max ( r1 , r2 ) : - 1 ; document . write ( x + " " + y ) ; }
Ref: 
void findPoints ( int l1 , int r1 , int l2 , int r2 ) { int x = ( l1 != l2 ) ? min ( l1 , l2 ) : -1 ; int y = ( r1 != r2 ) ? max ( r1 , r2 ) : -1 ; cout << x << " ▁ " << y ; }
Hyp: 
void findPoints ( int l1 , int r1 , int l2 , int r2 ) { int x = ( l1 != l2 ) ? min ( l1 , l2 ) : -1 ; int y = ( r1 != r2 ) ? max ( r1 , r2 ) : -1 ; cout << x << " , ▁ " << y ; }

BLEU: 96.01
Edit Sim: 2


Src: 
function maxSumLCM ( n ) { for ( let i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { max_sum += i ; if ( n / i != i ) max_sum += ( n / i ) ; } } return max_sum ; }
Ref: 
int maxSumLCM ( int n ) { for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { max_sum += i ; if ( n / i != i ) max_sum += ( n / i ) ; } } return max_sum ; }
Hyp: 
int maxSumLCM ( int n ) { int max_sum = 0 ; for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { max_sum += i ; if ( n / i != i ) max_sum += ( n / i ) ; } } return max_sum ; }

BLEU: 89.71
Edit Sim: 18


Src: 
function minDifference ( x , y , k , b , c ) { if ( x >= n y >= m ) return INT_MAX ; if ( x == n - 1 && y == m - 1 ) { let diff = b [ x ] [ y ] - c [ x ] [ y ] ; return Math . min ( Math . abs ( k - diff ) , Math . abs ( k + diff ) ) ; } let ans = dp [ x ] [ y ] [ k ] ; if ( ans != - 1 ) return ans ; ans = INT_MAX ; let diff = b [ x ] [ y ] - c [ x ] [ y ] ; ans = Math . min ( ans , minDifference ( x + 1 , y , Math . abs ( k + diff ) , b , c ) ) ; ans = Math . min ( ans , minDifference ( x , y + 1 , Math . abs ( k + diff ) , b , c ) ) ; ans = Math . min ( ans , minDifference ( x + 1 , y , Math . abs ( k - diff ) , b , c ) ) ; ans = Math . min ( ans , minDifference ( x , y + 1 , Math . abs ( k - diff ) , b , c ) ) ; return ans ; } n = 2 ; m = 2 ; let b = [ [ 1 , 4 ] , [ 2 , 4 ] ] ; let c = [ [ 3 , 2 ] , [ 3 , 1 ] ] ; for ( let i = 0 ; i < MAXI ; i ++ ) { dp [ i ] = new Array ( MAXI ) ; for ( let j = 0 ; j < MAXI ; j ++ ) { dp [ i ] [ j ] = new Array ( MAXI * MAXI ) ; for ( let k = 0 ; k < MAXI * MAXI ; k ++ ) { dp [ i ] [ j ] [ k ] = - 1 ; } } }
Ref: 
int minDifference ( int x , int y , int k , vector < vector < int > > b , vector < vector < int > > c ) { if ( x >= n or y >= m ) return INT_MAX ; if ( x == n - 1 and y == m - 1 ) { int diff = b [ x ] [ y ] - c [ x ] [ y ] ; return min ( abs ( k - diff ) , abs ( k + diff ) ) ; } int & ans = dp [ x ] [ y ] [ k ] ; if ( ans != -1 ) return ans ; ans = INT_MAX ; int diff = b [ x ] [ y ] - c [ x ] [ y ] ; ans = min ( ans , minDifference ( x + 1 , y , abs ( k + diff ) , b , c ) ) ; ans = min ( ans , minDifference ( x , y + 1 , abs ( k + diff ) , b , c ) ) ; ans = min ( ans , minDifference ( x + 1 , y , abs ( k - diff ) , b , c ) ) ; ans = min ( ans , minDifference ( x , y + 1 , abs ( k - diff ) , b , c ) ) ; return ans ; }
Hyp: 
int minDifference ( int x , int y , int k , int b , int c ) { if ( x >= n y >= m ) return INT_MAX ; if ( x == n - 1 && y == m - 1 ) { int diff = b [ x ] [ y ] - c [ x ] [ y ] ; return min ( abs ( k - diff ) , abs ( k + diff ) ) ; } int ans = dp [ x ] [ y ] [ k ] ; if ( ans != -1 ) return ans ; ans = INT_MAX ; int diff = b [ x ] [ y ] - c [ x ] [ y ] ; ans = min ( ans , minDifference ( x + 1 , y , abs ( k + diff ) , b , c ) ) ; ans = min ( ans , minDifference ( x , y + 1 , abs ( k - diff ) , b , c ) ) ; ans = min ( ans , minDifference ( x , y + 1 , abs ( k - diff ) , b , c ) ) ; ans = min ( ans , minDifference ( x , y + 1 , abs ( k - diff ) , b , c ) ) ; return ans ; }

BLEU: 88.12
Edit Sim: 57


Src: 
function nswp ( n ) { if ( n == 0 n == 1 ) return 1 ; return 2 * nswp ( n - 1 ) + nswp ( n - 2 ) ; }
Ref: 
int nswp ( int n ) { if ( n == 0 n == 1 ) return 1 ; return 2 * nswp ( n - 1 ) + nswp ( n - 2 ) ; }
Hyp: 
int nswp ( int n ) { if ( n == 0 n == 1 ) return 1 ; return 2 * nswp ( n - 1 ) + nswp ( n - 2 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function getPairsCount ( arr , n ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = arr [ i ] - ( i % arr [ i ] ) ; j < n ; j += arr [ i ] ) { if ( i < j && Math . abs ( arr [ i ] - arr [ j ] ) >= Math . min ( arr [ i ] , arr [ j ] ) ) { count ++ ; } } } return count ; }
Ref: 
int getPairsCount ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = arr [ i ] - ( i % arr [ i ] ) ; j < n ; j += arr [ i ] ) { if ( i < j && abs ( arr [ i ] - arr [ j ] ) >= min ( arr [ i ] , arr [ j ] ) ) { count ++ ; } } } return count ; }
Hyp: 
int getPairsCount ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = arr [ i ] - ( i % arr [ i ] ) ; j < n ; j += arr [ i ] ) { if ( i < j && abs ( arr [ i ] - arr [ j ] ) >= min ( arr [ i ] , arr [ j ] ) ) { count ++ ; } } } return count ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function zigzag ( n , k ) { let dp = new Array ( n + 1 ) ; for ( var i = 0 ; i < dp . length ; i ++ ) { dp [ i ] = new Array ( 2 ) ; } dp [ 0 ] [ 0 ] = 1 ; for ( let i = 1 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { for ( let j = 1 ; j <= Math . min ( i , k ) ; j ++ ) dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ i - j ] ; } return dp [ n ] [ k ] ; }
Ref: 
int zigzag ( int n , int k ) { int dp [ n + 1 ] [ k + 1 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; dp [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ i - j ] ; return dp [ n ] [ k ] ; }
Hyp: 
int zigzag ( int n , int k ) { int dp [ n + 1 ] [ k + 1 ] ; dp [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= min ( i , k ) ; j ++ ) dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ i - j ] ; } return dp [ n ] [ k ] ; }

BLEU: 88.56
Edit Sim: 50


Src: 
function printmaxSubseq ( arr , n ) { let i ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ i + 1 ] ) document . write ( arr [ i ] + " " ) ; else document . write ( arr [ i ] + " " ) ; } }
Ref: 
void printmaxSubseq ( int arr [ ] , int n ) { int i ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ i + 1 ] ) cout << arr [ i ] << " ▁ " ; else cout << arr [ i ] << " STRNEWLINE " ; } }
Hyp: 
void printmaxSubseq ( int arr [ ] , int n ) { int i ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ i + 1 ] ) cout << arr [ i ] << " ▁ " ; else cout << arr [ i ] << " ▁ " ; } }

BLEU: 96.25
Edit Sim: 10


Src: 
function LowerHessenbergMatrix ( n ) { for ( var i = 1 ; i <= n ; i ++ ) { for ( var j = 1 ; j <= n ; j ++ ) { if ( j > i + 1 ) document . write ( ' ' + " " ) ; else document . write ( Math . floor ( Math . random ( ) * 10 ) + " " ) ; } document . write ( " " ) ; } }
Ref: 
void LowerHessenbergMatrix ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( j > i + 1 ) cout << '0' << " ▁ " ; else cout << rand ( ) % 10 << " ▁ " ; } cout << " STRNEWLINE " ; } }
Hyp: 
void LowerHessenbergMatrix ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( j > i + 1 ) cout << '0' << " ▁ " ; else cout << floor ( random ( ) * 10 ) << " ▁ " ; } cout << endl ; } }

BLEU: 85.23
Edit Sim: 27


Src: 
function check ( s ) { let n = s . length ; for ( let i = 0 ; i < n - 1 ; i ++ ) { if ( s [ i ] > s [ i + 1 ] ) return true ; } return false ; }
Ref: 
bool check ( string s ) { int n = s . size ( ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( s [ i ] > s [ i + 1 ] ) return true ; } return false ; }
Hyp: 
bool check ( string s ) { int n = s . length ( ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( s [ i ] > s [ i + 1 ] ) return true ; } return false ; }

BLEU: 95.34
Edit Sim: 6


Src: 
function minPossibleValue ( N , K , X ) { for ( let i = 1 ; i <= N ; i ++ ) { if ( X <= K ) { X = X * 2 ; } else { X = X + K ; } } return X ; }
Ref: 
int minPossibleValue ( int N , int K , int X ) { for ( int i = 1 ; i <= N ; i ++ ) { if ( X <= K ) { X = X * 2 ; } else { X = X + K ; } } return X ; }
Hyp: 
int minPossibleValue ( int N , int K , int X ) { for ( int i = 1 ; i <= N ; i ++ ) { if ( X <= K ) { X = X * 2 ; } else { X = X + K ; } } return X ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function ispalindrome ( s ) { let l = s . length ; let j ; for ( let i = 0 , j = l - 1 ; i <= j ; i ++ , j -- ) { if ( s [ i ] != s [ j ] ) return false ; } return true ; } let s = " " ; let cnt = 0 ; let flag = 0 ; while ( s . length > 0 ) { if ( ispalindrome ( s ) ) { flag = 1 ; break ; } else { cnt ++ ; s = s . substring ( 0 , s . length - 1 ) ; } }
Ref: 
bool ispalindrome ( string s ) { int l = s . length ( ) ; int j ; for ( int i = 0 , j = l - 1 ; i <= j ; i ++ , j -- ) { if ( s [ i ] != s [ j ] ) return false ; } return true ; }
Hyp: 
bool ispalindrome ( string s ) { int l = s . length ( ) ; int j ; for ( int i = 0 , j = l - 1 ; i <= j ; i ++ , j -- ) { if ( s [ i ] != s [ j ] ) return false ; } return true ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countSubArrays ( arr , n , K ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i ; j < n ; j ++ ) { let bitwise_or = 0 ; for ( let k = i ; k <= j ; k ++ ) { bitwise_or = bitwise_or | arr [ k ] ; } if ( bitwise_or >= K ) count ++ ; } } return count ; }
Ref: 
int countSubArrays ( const int * arr , int n , int K ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { int bitwise_or = 0 ; for ( int k = i ; k <= j ; k ++ ) { bitwise_or = bitwise_or | arr [ k ] ; } if ( bitwise_or >= K ) count ++ ; } } return count ; }
Hyp: 
int countSubArrays ( const int * arr , int n , int K ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { int bitwise_or = 0 ; for ( int k = i ; k <= j ; k ++ ) { bitwise_or = bitwise_or | arr [ k ] ; } if ( bitwise_or >= K ) count ++ ; } } return count ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function checkIndices ( Arr , N ) { for ( var i = 0 ; i < N - 1 ; i ++ ) { for ( var j = i + 1 ; j < N ; j ++ ) { if ( Arr [ i ] != Arr [ j ] ) { if ( Arr [ Arr [ i ] - 1 ] == Arr [ Arr [ j ] - 1 ] ) return true ; } } } return false ; }
Ref: 
bool checkIndices ( int Arr [ ] , int N ) { for ( int i = 0 ; i < N - 1 ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( Arr [ i ] != Arr [ j ] ) { if ( Arr [ Arr [ i ] - 1 ] == Arr [ Arr [ j ] - 1 ] ) return true ; } } } return false ; }
Hyp: 
bool checkIndices ( int Arr [ ] , int N ) { for ( int i = 0 ; i < N - 1 ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( Arr [ i ] != Arr [ j ] ) { if ( Arr [ Arr [ i ] - 1 ] == Arr [ Arr [ j ] - 1 ] ) return true ; } } } return false ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function sumOfMedians ( arr , N , K ) { let selectMedian = Math . floor ( ( K + 1 ) / 2 ) ; let totalArrays = Math . floor ( N / K ) ; let minSum = 0 ; let i = selectMedian - 1 ; while ( i < N && totalArrays != 0 ) { minSum = minSum + arr [ i ] ; i = i + selectMedian ; totalArrays -- ; } document . write ( minSum ) ; }
Ref: 
void sumOfMedians ( int arr [ ] , int N , int K ) { int selectMedian = ( K + 1 ) / 2 ; int totalArrays = N / K ; int minSum = 0 ; int i = selectMedian - 1 ; while ( i < N and totalArrays != 0 ) { minSum = minSum + arr [ i ] ; i = i + selectMedian ; totalArrays -- ; } cout << minSum ; }
Hyp: 
void sumOfMedians ( int arr [ ] , int N , int K ) { int selectMedian = ( K + 1 ) / 2 ; int totalArrays = N / K ; int minSum = 0 ; int i = selectMedian - 1 ; while ( i < N && totalArrays != 0 ) { minSum = minSum + arr [ i ] ; i = i + selectMedian ; totalArrays -- ; } cout << minSum ; }

BLEU: 96.82
Edit Sim: 3


Src: 
function difference ( arr , n ) { let d1 = 0 , d2 = 0 ; for ( let i = 0 ; i < n ; i ++ ) { d1 += arr [ i ] [ i ] ; d2 += arr [ i ] [ n - i - 1 ] ; } return Math . abs ( d1 - d2 ) ; }
Ref: 
int difference ( int arr [ ] [ MAX ] , int n ) { int d1 = 0 , d2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { d1 += arr [ i ] [ i ] ; d2 += arr [ i ] [ n - i - 1 ] ; } return abs ( d1 - d2 ) ; }
Hyp: 
int difference ( int arr [ ] [ MAX ] , int n ) { int d1 = 0 , d2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { d1 += arr [ i ] [ i ] ; d2 += arr [ i ] [ n - i - 1 ] ; } return abs ( d1 - d2 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function print_result ( a , n , k , m ) { var v = Array . from ( Array ( m ) , ( ) => Array ( ) ) ; for ( var i = 0 ; i < n ; i ++ ) { var rem = a [ i ] % m ; v [ rem ] . push ( a [ i ] ) ; if ( v [ rem ] . length == k ) { for ( var j = 0 ; j < k ; j ++ ) document . write ( v [ rem ] [ j ] + " " ) ; return ; } } document . write ( " " ) ; }
Ref: 
void print_result ( int a [ ] , int n , int k , int m ) { vector < int > v [ m ] ; for ( int i = 0 ; i < n ; i ++ ) { int rem = a [ i ] % m ; v [ rem ] . push_back ( a [ i ] ) ; if ( v [ rem ] . size ( ) == k ) { for ( int j = 0 ; j < k ; j ++ ) cout << v [ rem ] [ j ] << " ▁ " ; return ; } } cout << " - 1" ; }
Hyp: 
void print_result ( int a [ ] , int n , int k , int m ) { vector < int > v ( m , vector < int > ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) { int rem = a [ i ] % m ; v [ rem ] . push_back ( a [ i ] ) ; if ( v [ rem ] . size ( ) == k ) { for ( int j = 0 ; j < k ; j ++ ) cout << v [ rem ] [ j ] << " ▁ " ; return ; } } cout << endl ; }

BLEU: 88.94
Edit Sim: 29


Src: 
function oddEquivalent ( s , n ) { var count = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ' ' ) count ++ ; } return count ; }
Ref: 
int oddEquivalent ( string s , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == '1' ) count ++ ; } return count ; }
Hyp: 
int oddEquivalent ( string s , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == '0' ) count ++ ; } return count ; }

BLEU: 94.53
Edit Sim: 1


Src: 
function cost ( str ) { let len = str . length ; let res = 0 ; for ( let i = 0 , j = len - 1 ; i < j ; i ++ , j -- ) { if ( str [ i ] != str [ j ] ) { res += Math . min ( str [ i ] . charCodeAt ( ) , str [ j ] . charCodeAt ( ) ) - ' ' . charCodeAt ( ) + 1 ; } } return res ; }
Ref: 
int cost ( string str ) { int len = str . length ( ) ; int res = 0 ; for ( int i = 0 , j = len - 1 ; i < j ; i ++ , j -- ) if ( str [ i ] != str [ j ] ) res += min ( str [ i ] , str [ j ] ) - ' a ' + 1 ; return res ; }
Hyp: 
int cost ( string str ) { int len = str . length ( ) ; int res = 0 ; for ( int i = 0 , j = len - 1 ; i < j ; i ++ , j -- ) { if ( str [ i ] != str [ j ] ) { res += min ( str [ i ] , str [ j ] ) - ' a ' + 1 ; } } return res ; }

BLEU: 89.79
Edit Sim: 8


Src: 
function isicositrigonal ( N ) { var n = ( 19 + Math . sqrt ( 168 * N + 361 ) ) / 42 ; return ( n - parseInt ( n ) ) == 0 ; } var i = 23 ; if ( isicositrigonal ( i ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
Ref: 
bool isicositrigonal ( int N ) { float n = ( 19 + sqrt ( 168 * N + 361 ) ) / 42 ; return ( n - ( int ) n ) == 0 ; }
Hyp: 
bool isicositrigonal ( int N ) { float n = ( 19 + sqrt ( 168 * N + 361 ) ) / 42 ; return ( n - ( int ) n ) == 0 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findXOR ( mat , N ) { let XOR = 0 ; for ( let i = 0 ; i < N ; i ++ ) { XOR ^= mat [ i ] [ i ] [ i ] ; XOR ^= mat [ i ] [ i ] [ N - i - 1 ] ; } document . write ( XOR ) ; }
Ref: 
void findXOR ( vector < vector < vector < int > > > & mat , int N ) { int XOR = 0 ; for ( int i = 0 ; i < N ; i ++ ) { XOR ^= mat [ i ] [ i ] [ i ] ; XOR ^= mat [ i ] [ i ] [ N - i - 1 ] ; } cout << XOR << " STRNEWLINE " ; }
Hyp: 
void findXOR ( vector < vector < int > > & mat , int N ) { int XOR = 0 ; for ( int i = 0 ; i < N ; i ++ ) { XOR ^= mat [ i ] [ i ] [ i ] ; XOR ^= mat [ i ] [ i ] [ N - i - 1 ] ; } cout << XOR << " STRNEWLINE " ; }

BLEU: 95.86
Edit Sim: 11


Src: 
function multiplyFactors ( n ) { let M = 1000000007 ; let i ; prod = 1 ; for ( i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) prod = ( prod * i ) % M ; else { prod = ( prod * i ) % M ; prod = ( prod * n / i ) % M ; } } } return prod ; }
Ref: 
long multiplyFactors ( int n ) { long long prod = 1 ; for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) prod = ( prod * i ) % M ; else { prod = ( prod * i ) % M ; prod = ( prod * n / i ) % M ; } } } return prod ; }
Hyp: 
long multiplyFactors ( long long n ) { long long M = 1000000007 ; long long i ; long long prod = 1 ; for ( i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) prod = ( prod * i ) % M ; else { prod = ( prod * i ) % M ; prod = ( prod * n / i ) % M ; } } } return prod ; }

BLEU: 84.28
Edit Sim: 53


Src: 
function interpolationSearch ( arr , lo , hi , x ) { let pos ; if ( lo <= hi && x >= arr [ lo ] && x <= arr [ hi ] ) { pos = lo + Math . floor ( ( ( hi - lo ) / ( arr [ hi ] - arr [ lo ] ) ) * ( x - arr [ lo ] ) ) ; ; if ( arr [ pos ] == x ) { return pos ; } if ( arr [ pos ] < x ) { return interpolationSearch ( arr , pos + 1 , hi , x ) ; } if ( arr [ pos ] > x ) { return interpolationSearch ( arr , lo , pos - 1 , x ) ; } } return - 1 ; } let arr = [ 10 , 12 , 13 , 16 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 33 , 35 , 42 , 47 ] ; let n = arr . length ; let x = 18 let index = interpolationSearch ( arr , 0 , n - 1 , x ) ; if ( index != - 1 ) { document . write ( ` ${ index } ` ) } else { document . write ( " " ) ; }
Ref: 
int interpolationSearch ( int arr [ ] , int lo , int hi , int x ) { int pos ; if ( lo <= hi && x >= arr [ lo ] && x <= arr [ hi ] ) { pos = lo + ( ( ( double ) ( hi - lo ) / ( arr [ hi ] - arr [ lo ] ) ) * ( x - arr [ lo ] ) ) ; if ( arr [ pos ] == x ) return pos ; if ( arr [ pos ] < x ) return interpolationSearch ( arr , pos + 1 , hi , x ) ; if ( arr [ pos ] > x ) return interpolationSearch ( arr , lo , pos - 1 , x ) ; } return -1 ; }
Hyp: 
int interpolationSearch ( int arr [ ] , int lo , int hi , int x ) { int pos ; if ( lo <= hi && x >= arr [ lo ] && x <= arr [ hi ] ) { pos = lo + ( ( hi - lo ) / ( arr [ hi ] - arr [ lo ] ) ) ; if ( arr [ pos ] == x ) { return pos ; } if ( arr [ pos ] < x ) { return interpolationSearch ( arr , pos + 1 , hi , x ) ; } if ( arr [ pos ] > x ) { return interpolationSearch ( arr , lo , pos - 1 , x ) ; } } return -1 ; }

BLEU: 83.53
Edit Sim: 48


Src: 
function findNum ( N , K ) { var rem = ( N + K ) % K ; if ( rem == 0 ) return N ; else return N + K - rem ; }
Ref: 
int findNum ( int N , int K ) { int rem = ( N + K ) % K ; if ( rem == 0 ) return N ; else return N + K - rem ; }
Hyp: 
int findNum ( int N , int K ) { int rem = ( N + K ) % K ; if ( rem == 0 ) return N ; else return N + K - rem ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function even_or_odd ( N ) { var len = N . length ; if ( N [ len - 1 ] == ' ' N [ len - 1 ] == ' ' N [ len - 1 ] == ' ' N [ len - 1 ] == ' ' ) return ( " " ) ; else return ( " " ) ; }
Ref: 
string even_or_odd ( string N ) { int len = N . size ( ) ; if ( N [ len - 1 ] == '0' N [ len - 1 ] == '2' N [ len - 1 ] == '4' N [ len - 1 ] == '6' ) return ( " Even " ) ; else return ( " Odd " ) ; }
Hyp: 
string even_or_odd ( string N ) { int len = N . size ( ) ; if ( N [ len - 1 ] == '0' N [ len - 1 ] == '2' N [ len - 1 ] == '4' N [ len - 1 ] == '6' N [ len - 1 ] == '8' N [ len - 1 ] == ' A ' ) return ( " Even " ) ; else return ( " Odd " ) ; }

BLEU: 76.88
Edit Sim: 44


Src: 
function lastPosition ( n , m , k ) { if ( m <= n - k + 1 ) return m + k - 1 ; m = m - ( n - k + 1 ) ; return ( m % n == 0 ) ? n : ( m % n ) ; }
Ref: 
int lastPosition ( int n , int m , int k ) { if ( m <= n - k + 1 ) return m + k - 1 ; m = m - ( n - k + 1 ) ; return ( m % n == 0 ) ? n : ( m % n ) ; }
Hyp: 
int lastPosition ( int n , int m , int k ) { if ( m <= n - k + 1 ) return m + k - 1 ; m = m - ( n - k + 1 ) ; return ( m % n == 0 ) ? n : ( m % n ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function isDivisible ( n ) { while ( Math . floor ( n / 100 ) > 0 ) { let d = n % 10 ; n = Math . floor ( n / 10 ) ; n -= d * 5 ; } return ( n % 17 == 0 ) ; }
Ref: 
bool isDivisible ( long long int n ) { while ( n / 100 ) { int d = n % 10 ; n /= 10 ; n -= d * 5 ; } return ( n % 17 == 0 ) ; }
Hyp: 
bool isDivisible ( int n ) { while ( n / 100 > 0 ) { int d = n % 10 ; n /= 10 ; n -= d * 5 ; } return ( n % 17 == 0 ) ; }

BLEU: 88.2
Edit Sim: 14


Src: 
function largestNum ( n ) { let num = 0 ; for ( let i = 0 ; i <= 32 ; i ++ ) { let x = ( 1 << i ) ; if ( ( x - 1 ) <= n ) num = ( 1 << i ) - 1 ; else break ; } return num ; }
Ref: 
int largestNum ( int n ) { int num = 0 ; for ( int i = 0 ; i <= 32 ; i ++ ) { int x = ( 1 << i ) ; if ( ( x - 1 ) <= n ) num = ( 1 << i ) - 1 ; else break ; } return num ; }
Hyp: 
int largestNum ( int n ) { int num = 0 ; for ( int i = 0 ; i <= 32 ; i ++ ) { int x = ( 1 << i ) ; if ( ( x - 1 ) <= n ) num = ( 1 << i ) - 1 ; else break ; } return num ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function maxSum ( n ) { if ( n == 1 ) return 1 ; else return ( parseInt ( n * ( n - 1 ) / 2 , 10 ) - 1 + parseInt ( n / 2 , 10 ) ) ; }
Ref: 
int maxSum ( int n ) { if ( n == 1 ) return 1 ; else return ( n * ( n - 1 ) / 2 ) - 1 + n / 2 ; }
Hyp: 
int maxSum ( int n ) { if ( n == 1 ) return 1 ; else return ( n * ( n - 1 ) / 2 - 1 + n / 2 ) ; }

BLEU: 91.36
Edit Sim: 4


Src: 
function gcd ( a , b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
Ref: 
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
Hyp: 
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function printRepeating ( arr , size ) { var i , j ; document . write ( " " ) ; for ( i = 0 ; i < size ; i ++ ) { for ( j = i + 1 ; j < size ; j ++ ) { if ( arr [ i ] == arr [ j ] ) document . write ( arr [ i ] + " " ) ; } } }
Ref: 
void printRepeating ( int arr [ ] , int size ) { int i , j ; printf ( " ▁ Repeating ▁ elements ▁ are ▁ " ) ; for ( i = 0 ; i < size ; i ++ ) for ( j = i + 1 ; j < size ; j ++ ) if ( arr [ i ] == arr [ j ] ) cout << arr [ i ] << " ▁ " ; }
Hyp: 
void printRepeating ( int arr [ ] , int size ) { int i , j ; cout << " ▁ " ; for ( i = 0 ; i < size ; i ++ ) { for ( j = i + 1 ; j < size ; j ++ ) { if ( arr [ i ] == arr [ j ] ) cout << arr [ i ] << " ▁ " ; } } }

BLEU: 80.96
Edit Sim: 46


Src: 
function countXorPair ( arr , n ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i + 1 ; j < n ; j ++ ) if ( ( arr [ i ] ^ arr [ j ] ) % 2 == 1 ) count ++ ; } return count ; }
Ref: 
int countXorPair ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) if ( ( arr [ i ] ^ arr [ j ] ) % 2 == 1 ) count ++ ; } return count ; }
Hyp: 
int countXorPair ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) if ( ( arr [ i ] ^ arr [ j ] ) % 2 == 1 ) count ++ ; } return count ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function maxVol ( P , A ) { let l = ( P - Math . sqrt ( P * P - 24 * A ) ) / 12 ; let V = l * ( A / 2.0 - l * ( P / 4.0 - l ) ) ; return V ; }
Ref: 
float maxVol ( float P , float A ) { float l = ( P - sqrt ( P * P - 24 * A ) ) / 12 ; float V = l * ( A / 2.0 - l * ( P / 4.0 - l ) ) ; return V ; }
Hyp: 
double maxVol ( double P , double A ) { double l = ( P - sqrt ( P * P - 24 * A ) ) / 12 ; double V = l * ( A / 2.0 - l * ( P / 4.0 - l ) ) ; return V ; }

BLEU: 80.25
Edit Sim: 30


Src: 
function sumOfSeries ( n ) { return 0.0246 * ( Math . pow ( 10 , n ) - 1 - ( 9 * n ) ) ; }
Ref: 
float sumOfSeries ( int n ) { return 0.0246 * ( pow ( 10 , n ) - 1 - ( 9 * n ) ) ; }
Hyp: 
float sumOfSeries ( int n ) { return 0.0246 * ( pow ( 10 , n ) - 1 - ( 9 * n ) ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function sub_segments ( str , n ) { let l = str . length ; for ( let x = 0 ; x < l ; x += n ) { let newlist = str . substr ( x , n ) ; let arr = [ ] ; for ( let y of newlist ) { if ( ! arr . includes ( y ) ) arr . push ( y ) ; } for ( let y of arr ) document . write ( y ) ; document . write ( " " ) ; } }
Ref: 
void sub_segments ( string str , int n ) { int l = str . length ( ) ; for ( int x = 0 ; x < l ; x += n ) { string newlist = str . substr ( x , n ) ; list < char > arr ; list < char > :: iterator it ; for ( auto y : newlist ) { it = find ( arr . begin ( ) , arr . end ( ) , y ) ; if ( it == arr . end ( ) ) arr . push_back ( y ) ; } for ( auto y : arr ) cout << y ; cout << endl ; } }
Hyp: 
void sub_segments ( string str , int n ) { int l = str . length ( ) ; for ( int x = 0 ; x < l ; x += n ) { string newlist = str . substr ( x , n ) ; vector < int > arr ; for ( int y : newlist ) { if ( arr . find ( y ) == arr . end ( ) ) arr . insert ( y ) ; } for ( int y : arr ) cout << y ; cout << endl ; } }

BLEU: 65.04
Edit Sim: 90


Src: 
function equation_plane ( x1 , y1 , z1 , x2 , y2 , z2 , x3 , y3 , z3 , x , y , z ) { var a1 = x2 - x1 ; var b1 = y2 - y1 ; var c1 = z2 - z1 ; var a2 = x3 - x1 ; var b2 = y3 - y1 ; var c2 = z3 - z1 ; var a = b1 * c2 - b2 * c1 ; var b = a2 * c1 - a1 * c2 ; var c = a1 * b2 - b1 * a2 ; var d = ( - a * x1 - b * y1 - c * z1 ) ; if ( a * x + b * y + c * z + d == 0 ) document . write ( " " ) ; else document . write ( " " ) ; }
Ref: 
void equation_plane ( int x1 , int y1 , int z1 , int x2 , int y2 , int z2 , int x3 , int y3 , int z3 , int x , int y , int z ) { int a1 = x2 - x1 ; int b1 = y2 - y1 ; int c1 = z2 - z1 ; int a2 = x3 - x1 ; int b2 = y3 - y1 ; int c2 = z3 - z1 ; int a = b1 * c2 - b2 * c1 ; int b = a2 * c1 - a1 * c2 ; int c = a1 * b2 - b1 * a2 ; int d = ( - a * x1 - b * y1 - c * z1 ) ; if ( a * x + b * y + c * z + d == 0 ) cout << " Coplanar " << endl ; else cout << " Not ▁ Coplanar " << endl ; }
Hyp: 
void equation_plane ( int x1 , int y1 , int z1 , int x2 , int y2 , int z2 , int x3 , int y3 , int z3 , int x , int y , int z ) { int a1 = x2 - x1 ; int b1 = y2 - y1 ; int c1 = z2 - z1 ; int a2 = x3 - x1 ; int b2 = y3 - y1 ; int c2 = z3 - z1 ; int a = b1 * c2 - b2 * c1 ; int b = a2 * c1 - a1 * c2 ; int c = a1 * b2 - b1 * a2 ; int d = ( - a * x1 - b * y1 - c * z1 ) ; if ( a * x + b * y + c * z + d == 0 ) cout << " Yes " ; else cout << " No " ; }

BLEU: 92.74
Edit Sim: 36


Src: 
function printPairs ( arr , n ) { let v = [ ] ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = i + 1 ; j < n ; j ++ ) if ( Math . abs ( arr [ i ] ) == Math . abs ( arr [ j ] ) ) v . push ( Math . abs ( arr [ i ] ) ) ; if ( v . length == 0 ) return ; v . sort ( function ( a , b ) { return a - b ; } ) ; for ( let i = 0 ; i < v . length ; i ++ ) document . write ( - v [ i ] + " " + v [ i ] ) ; }
Ref: 
void printPairs ( int arr [ ] , int n ) { vector < int > v ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( abs ( arr [ i ] ) == abs ( arr [ j ] ) ) v . push_back ( abs ( arr [ i ] ) ) ; if ( v . size ( ) == 0 ) return ; sort ( v . begin ( ) , v . end ( ) ) ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) cout << - v [ i ] << " ▁ " << v [ i ] ; }
Hyp: 
void printPairs ( int arr [ ] , int n ) { vector < int > v ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( abs ( arr [ i ] ) == abs ( arr [ j ] ) ) v . push_back ( abs ( arr [ i ] ) ) ; if ( v . size ( ) == 0 ) return ; sort ( v . begin ( ) , v . end ( ) ) ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) cout << - v [ i ] << " , ▁ " << v [ i ] ; }

BLEU: 98.24
Edit Sim: 2


Src: 
function sum_star_num ( n ) { let summ = 2 * n * ( n + 1 ) * ( n - 1 ) + n ; return summ ; }
Ref: 
int sum_star_num ( int n ) { int summ = 2 * n * ( n + 1 ) * ( n - 1 ) + n ; return summ ; }
Hyp: 
int sum_star_num ( int n ) { int summ = 2 * n * ( n + 1 ) * ( n - 1 ) + n ; return summ ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countPairs ( A , B ) { let n = A . length ; let ans = 0 ; A . sort ( ) ; B . sort ( ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( A [ i ] > B [ ans ] ) { ans ++ ; } } return ans ; }
Ref: 
int countPairs ( vector < int > A , vector < int > B ) { int n = A . size ( ) ; sort ( A . begin ( ) , A . end ( ) ) ; sort ( B . begin ( ) , B . end ( ) ) ; int ans = 0 , i ; for ( int i = 0 ; i < n ; i ++ ) { if ( A [ i ] > B [ ans ] ) { ans ++ ; } } return ans ; }
Hyp: 
int countPairs ( int A [ ] , int B [ ] ) { int n = A . size ( ) ; int ans = 0 ; sort ( A , A + n ) ; sort ( B , B + n ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( A [ i ] > B [ ans ] ) { ans ++ ; } } return ans ; }

BLEU: 60.97
Edit Sim: 82


Src: 
function countOddPair ( A , N ) { let count = 0 ; for ( let i = 0 ; i < N ; i ++ ) if ( ! ( A [ i ] & 1 ) ) count ++ ; let evenPairCount = parseInt ( count * ( count - 1 ) / 2 ) ; let totPairs = parseInt ( N * ( N - 1 ) / 2 ) ; return totPairs - evenPairCount ; }
Ref: 
int countOddPair ( int A [ ] , int N ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( ! ( A [ i ] & 1 ) ) count ++ ; int evenPairCount = count * ( count - 1 ) / 2 ; int totPairs = N * ( N - 1 ) / 2 ; return totPairs - evenPairCount ; }
Hyp: 
int countOddPair ( int A [ ] , int N ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( A [ i ] & 1 ) count ++ ; int evenPairCount = count * ( count - 1 ) / 2 ; int totPairs = N * ( N - 1 ) / 2 ; return totPairs - evenPairCount ; }

BLEU: 94.09
Edit Sim: 6


Src: 
function diagonal_length ( a ) { let L ; L = a * Math . sqrt ( 3 ) ; return L ; }
Ref: 
float diagonal_length ( float a ) { float L ; L = a * sqrt ( 3 ) ; return L ; }
Hyp: 
long diagonal_length ( long long a ) { long long L ; L = a * sqrt ( 3 ) ; return L ; }

BLEU: 67.32
Edit Sim: 17


Src: 
function divisorSum ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; ++ i ) { for ( let j = 1 ; j * j <= i ; ++ j ) { if ( i % j == 0 ) { if ( i / j == j ) sum += j ; else sum += j + i / j ; } } } return sum ; }
Ref: 
int divisorSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j * j <= i ; ++ j ) { if ( i % j == 0 ) { if ( i / j == j ) sum += j ; else sum += j + i / j ; } } } return sum ; }
Hyp: 
int divisorSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j * j <= i ; ++ j ) { if ( i % j == 0 ) { if ( i / j == j ) sum += j ; else sum += j + i / j ; } } } return sum ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function minInt ( str ) { for ( let i = 0 ; i < str . length ; i ++ ) { if ( str [ i ] . charCodeAt ( ) >= ( ' ' ) . charCodeAt ( ) ) { str [ i ] = String . fromCharCode ( ( ( ' ' ) . charCodeAt ( ) - ( str [ i ] ) . charCodeAt ( ) ) + ( ' ' ) . charCodeAt ( ) ) ; } } if ( str [ 0 ] == ' ' ) str [ 0 ] = ' ' ; let s = str . join ( " " ) ; return s ; }
Ref: 
string minInt ( string str ) { for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] >= '5' ) { str [ i ] = ( '9' - str [ i ] ) + '0' ; } } if ( str [ 0 ] == '0' ) str [ 0 ] = '9' ; return str ; }
Hyp: 
string minInt ( string & str ) { for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] >= ( ' A ' ) . charCodeAt ( ) ) { str [ i ] = ( ( ' A ' ) - ( str [ i ] ) ) + ( ' Z ' ) ; } } if ( str [ 0 ] == '0' ) str [ 0 ] = '1' ; string s = str . substr ( 1 ) ; return s ; }

BLEU: 57.0
Edit Sim: 78


Src: 
function findbitwiseOR ( a , n ) { let res = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let curr_sub_array = a [ i ] ; res = res | curr_sub_array ; for ( let j = i ; j < n ; j ++ ) { curr_sub_array = curr_sub_array & a [ j ] ; res = res | curr_sub_array ; } } document . write ( res ) ; }
Ref: 
void findbitwiseOR ( int * a , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int curr_sub_array = a [ i ] ; res = res | curr_sub_array ; for ( int j = i ; j < n ; j ++ ) { curr_sub_array = curr_sub_array & a [ j ] ; res = res | curr_sub_array ; } } cout << res ; }
Hyp: 
void findbitwiseOR ( int * a , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int curr_sub_array = a [ i ] ; res = res | curr_sub_array ; for ( int j = i ; j < n ; j ++ ) { curr_sub_array = curr_sub_array & a [ j ] ; res = res | curr_sub_array ; } } cout << res ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function min_moves ( n ) { let ans = Number . MAX_VALUE ; for ( let i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { ans = Math . min ( ans , i + parseInt ( n / i , 10 ) - 2 ) ; } } return ans ; }
Ref: 
int min_moves ( int n ) { int ans = INT_MAX ; for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { ans = min ( ans , i + n / i - 2 ) ; } } return ans ; }
Hyp: 
int min_moves ( int n ) { int ans = INT_MAX ; for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { ans = min ( ans , i + n / i - 2 ) ; } } return ans ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function get_unit_digit ( N ) { if ( N == 0 N == 1 ) return 1 ; else if ( N == 2 ) return 3 ; else if ( N == 3 ) return 9 ; return 3 ; }
Ref: 
int get_unit_digit ( long long int N ) { if ( N == 0 N == 1 ) return 1 ; else if ( N == 2 ) return 3 ; else if ( N == 3 ) return 9 ; return 3 ; }
Hyp: 
int get_unit_digit ( int N ) { if ( N == 0 N == 1 ) return 1 ; else if ( N == 2 ) return 3 ; else if ( N == 3 ) return 9 ; return 3 ; }

BLEU: 91.98
Edit Sim: 10


Src: 
function unitnumber ( x , y ) { x = x % 10 ; if ( y != 0 ) y = y % 4 + 4 ; return ( ( parseInt ( Math . pow ( x , y ) ) ) % 10 ) ; }
Ref: 
int unitnumber ( int x , int y ) { x = x % 10 ; if ( y != 0 ) y = y % 4 + 4 ; return ( ( ( int ) ( pow ( x , y ) ) ) % 10 ) ; }
Hyp: 
int unitnumber ( int x , int y ) { x = x % 10 ; if ( y != 0 ) y = y % 4 + 4 ; return ( ( pow ( x , y ) ) % 10 ) ; }

BLEU: 87.38
Edit Sim: 12


Src: 
function minimumPossibleProduct ( K ) { let res = 1 ; let range = ( 1 << K ) - 1 ; for ( let i = 0 ; i < K ; i ++ ) { res *= ( range - 1 ) ; } res *= range ; return res ; }
Ref: 
int minimumPossibleProduct ( int K ) { int res = 1 ; int range = ( 1 << K ) - 1 ; for ( int i = 0 ; i < K ; i ++ ) { res *= ( range - 1 ) ; } res *= range ; return res ; }
Hyp: 
int minimumPossibleProduct ( int K ) { int res = 1 ; int range = ( 1 << K ) - 1 ; for ( int i = 0 ; i < K ; i ++ ) { res *= ( range - 1 ) ; } res *= range ; return res ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function decToBinary ( n ) { let binaryNum = new Array ( 32 ) ; let i = 0 ; while ( n > 0 ) { binaryNum [ i ] = n % 2 ; n = Math . floor ( n / 2 ) ; i ++ ; } for ( let j = i - 1 ; j >= 0 ; j -- ) document . write ( binaryNum [ j ] ) ; }
Ref: 
void decToBinary ( int n ) { int binaryNum [ 32 ] ; int i = 0 ; while ( n > 0 ) { binaryNum [ i ] = n % 2 ; n = n / 2 ; i ++ ; } for ( int j = i - 1 ; j >= 0 ; j -- ) cout << binaryNum [ j ] ; }
Hyp: 
void decToBinary ( int n ) { int binaryNum [ 32 ] ; int i = 0 ; while ( n > 0 ) { binaryNum [ i ] = n % 2 ; n = n / 2 ; i ++ ; } for ( int j = i - 1 ; j >= 0 ; j -- ) cout << binaryNum [ j ] ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function maxSelectionCount ( a , n ) { var res = 0 ; a . sort ( ) ; var select = 1 ; for ( var i = 0 ; i < n ; i ++ ) { if ( a [ i ] >= select ) { res ++ ; select ++ ; } } return res ; }
Ref: 
int maxSelectionCount ( int a [ ] , int n ) { int res = 0 ; sort ( a , a + n ) ; int select = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] >= select ) { res ++ ; select ++ ; } } return res ; }
Hyp: 
int maxSelectionCount ( int a [ ] , int n ) { int res = 0 ; sort ( a , a + n ) ; int select = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] >= select ) { res ++ ; select ++ ; } } return res ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function minApples ( ) { if ( M <= S * K ) return M ; else if ( M <= S * K + E + W ) return S * K + ( M - S * K ) * K ; else return - 1 ; }
Ref: 
int minApples ( int M , int K , int N , int S , int W , int E ) { if ( M <= S * K ) return M ; else if ( M <= S * K + E + W ) return S * K + ( M - S * K ) * K ; else return -1 ; }
Hyp: 
int minApples ( int M ) { if ( M <= S * K ) return M ; else if ( M <= S * K + E + W ) return S * K + ( M - S * K ) * K ; else return -1 ; }

BLEU: 72.25
Edit Sim: 40


Src: 
function count_rectangles ( N , M ) { let p_x = ( N * ( N - 1 ) ) / 2 ; let p_y = ( M * ( M - 1 ) ) / 2 ; return p_x * p_y ; }
Ref: 
int count_rectangles ( int N , int M ) { int p_x = ( N * ( N - 1 ) ) / 2 ; int p_y = ( M * ( M - 1 ) ) / 2 ; return p_x * p_y ; }
Hyp: 
ll count_rectangles ( ll N , ll M ) { ll p_x = ( N * ( N - 1 ) ) / 2 ; ll p_y = ( M * ( M - 1 ) ) / 2 ; return p_x * p_y ; }

BLEU: 76.19
Edit Sim: 15


Src: 
function isDivisible ( n ) { let d ; while ( Math . floor ( n / 100 ) <= 0 ) { d = n % 10 ; n = Math . floor ( n / 10 ) ; n = Math . abs ( n - ( d * 7 ) ) ; } return ( n % 71 == 0 ) ; }
Ref: 
bool isDivisible ( int n ) { int d ; while ( n / 100 ) { d = n % 10 ; n /= 10 ; n = abs ( n - ( d * 7 ) ) ; } return ( n % 71 == 0 ) ; }
Hyp: 
bool isDivisible ( int n ) { int d ; while ( n / 100 <= 0 ) { d = n % 10 ; n = n / 10 ; n = abs ( n - ( d * 7 ) ) ; } return ( n % 71 == 0 ) ; }

BLEU: 85.12
Edit Sim: 10


Src: 
function sumofoddFactors ( n ) { let res = 1 ; while ( n % 2 == 0 ) n = n / 2 ; for ( let i = 3 ; i <= Math . sqrt ( n ) ; i ++ ) { let count = 0 ; let curr_sum = 1 ; let curr_term = 1 ; while ( n % i == 0 ) { count ++ ; n = n / i ; curr_term *= i ; curr_sum += curr_term ; } res *= curr_sum ; } if ( n >= 2 ) res *= ( 1 + n ) ; return res ; }
Ref: 
int sumofoddFactors ( int n ) { int res = 1 ; while ( n % 2 == 0 ) n = n / 2 ; for ( int i = 3 ; i <= sqrt ( n ) ; i ++ ) { int count = 0 , curr_sum = 1 ; int curr_term = 1 ; while ( n % i == 0 ) { count ++ ; n = n / i ; curr_term *= i ; curr_sum += curr_term ; } res *= curr_sum ; } if ( n >= 2 ) res *= ( 1 + n ) ; return res ; }
Hyp: 
int sumofoddFactors ( int n ) { int res = 1 ; while ( n % 2 == 0 ) n = n / 2 ; for ( int i = 3 ; i <= sqrt ( n ) ; i ++ ) { int count = 0 ; int curr_sum = 1 ; int curr_term = 1 ; while ( n % i == 0 ) { count ++ ; n = n / i ; curr_term *= i ; curr_sum += curr_term ; } res *= curr_sum ; } if ( n >= 2 ) res *= ( 1 + n ) ; return res ; }

BLEU: 96.76
Edit Sim: 5


Src: 
function Area_of_Rhombus ( a , theta ) { var area = ( a ** 2 ) * Math . sin ( theta * Math . PI / 180 ) ; return area ; }
Ref: 
float Area_of_Rhombus ( int a , int theta ) { float area = ( a * a ) * sin ( ( RADIAN * theta ) ) ; return area ; }
Hyp: 
float Area_of_Rhombus ( float a , float theta ) { float area = ( a ** 2 ) * sin ( theta * PI / 180 ) ; return area ; }

BLEU: 51.51
Edit Sim: 26


Src: 
function maxWater ( height , n ) { let maximum = 0 ; for ( let i = 0 ; i < n - 1 ; i ++ ) { for ( let j = i + 1 ; j < n ; j ++ ) { let current = ( Math . min ( height [ i ] , height [ j ] ) * ( j - i - 1 ) ) ; maximum = Math . max ( maximum , current ) ; } } return maximum ; }
Ref: 
int maxWater ( int height [ ] , int n ) { int maximum = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int current = ( min ( height [ i ] , height [ j ] ) * ( j - i - 1 ) ) ; maximum = max ( maximum , current ) ; } } return maximum ; }
Hyp: 
int maxWater ( int height [ ] , int n ) { int maximum = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int current = ( min ( height [ i ] , height [ j ] ) * ( j - i - 1 ) ) ; maximum = max ( maximum , current ) ; } } return maximum ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function highestPower ( n ) { return parseInt ( Math . log ( n ) / Math . log ( 2 ) ) ; }
Ref: 
int highestPower ( int n ) { return log ( n ) / log ( 2 ) ; }
Hyp: 
int highestPower ( int n ) { return log2 ( n ) ; }

BLEU: 50.76
Edit Sim: 13


Src: 
function minimumValue ( arr , n , k ) { arr . sort ( ( a , b ) => a - b ) ; let answer = 0 ; for ( let i = 0 ; i < k ; i ++ ) answer += arr [ i ] * arr [ i ] ; return answer * ( 2 * k - 2 ) ; }
Ref: 
int minimumValue ( int arr [ ] , int n , int k ) { sort ( arr , arr + n ) ; int answer = 0 ; for ( int i = 0 ; i < k ; i ++ ) answer += arr [ i ] * arr [ i ] ; return answer * ( 2 * k - 2 ) ; }
Hyp: 
int minimumValue ( int arr [ ] , int n , int k ) { sort ( arr , arr + n ) ; int answer = 0 ; for ( int i = 0 ; i < k ; i ++ ) answer += arr [ i ] * arr [ i ] ; return answer * ( 2 * k - 2 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function isEven ( n ) { return ( parseInt ( n / 2 , 10 ) * 2 == n ) ; }
Ref: 
bool isEven ( int n ) { return ( ( n / 2 ) * 2 == n ) ; }
Hyp: 
bool isEven ( int n ) { return ( ( n / 2 ) * 2 == n ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function maxCandies ( arr , n ) { let prevBought = arr [ n - 1 ] ; let candies = prevBought ; for ( let i = n - 2 ; i >= 0 ; i -- ) { let x = Math . min ( prevBought - 1 , arr [ i ] ) ; if ( x >= 0 ) { candies += x ; prevBought = x ; } } return candies ; }
Ref: 
int maxCandies ( int arr [ ] , int n ) { int prevBought = arr [ n - 1 ] ; int candies = prevBought ; for ( int i = n - 2 ; i >= 0 ; i -- ) { int x = min ( prevBought - 1 , arr [ i ] ) ; if ( x >= 0 ) { candies += x ; prevBought = x ; } } return candies ; }
Hyp: 
int maxCandies ( int arr [ ] , int n ) { int prevBought = arr [ n - 1 ] ; int candies = prevBought ; for ( int i = n - 2 ; i >= 0 ; i -- ) { int x = min ( prevBought - 1 , arr [ i ] ) ; if ( x >= 0 ) { candies += x ; prevBought = x ; } } return candies ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function longestUniqueSubsttr ( str ) { var n = str . length ( ) ; var res = 0 ; for ( var i = 0 ; i < n ; i ++ ) { var visited = new [ 256 ] ; for ( var j = i ; j < n ; j ++ ) { if ( visited [ str . charAt ( j ) ] == true ) break ; else { res = Math . max ( res , j - i + 1 ) ; visited [ str . charAt ( j ) ] = true ; } } visited [ str . charAt ( i ) ] = false ; } return res ; }
Ref: 
int longestUniqueSubsttr ( string str ) { int n = str . size ( ) ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { vector < bool > visited ( 256 ) ; for ( int j = i ; j < n ; j ++ ) { if ( visited [ str [ j ] ] == true ) break ; else { res = max ( res , j - i + 1 ) ; visited [ str [ j ] ] = true ; } } visited [ str [ i ] ] = false ; } return res ; }
Hyp: 
int longestUniqueSubsttr ( string str ) { int n = str . length ( ) ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { bool visited [ 256 ] ; for ( int j = i ; j < n ; j ++ ) { if ( visited [ str [ j ] ] == true ) break ; else { res = max ( res , j - i + 1 ) ; visited [ str [ j ] ] = true ; } } visited [ str [ i ] ] = false ; } return res ; }

BLEU: 90.16
Edit Sim: 19


Src: 
function findMinDel ( arr , n ) { var min_num = 1000000000 ; for ( var i = 0 ; i < n ; i ++ ) min_num = Math . min ( arr [ i ] , min_num ) ; var cnt = 0 ; for ( var i = 0 ; i < n ; i ++ ) if ( arr [ i ] == min_num ) cnt ++ ; return n - cnt ; }
Ref: 
int findMinDel ( int * arr , int n ) { int min_num = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) min_num = min ( arr [ i ] , min_num ) ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == min_num ) cnt ++ ; return n - cnt ; }
Hyp: 
int findMinDel ( int arr [ ] , int n ) { int min_num = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) min_num = min ( arr [ i ] , min_num ) ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == min_num ) cnt ++ ; return n - cnt ; }

BLEU: 94.61
Edit Sim: 6


Src: 
function productOfGP ( a , r , n ) { let an = a * Math . pow ( r , n - 1 ) ; return Math . sqrt ( Math . pow ( a * an , n ) ) ; }
Ref: 
float productOfGP ( float a , float r , int n ) { int an = a * pow ( r , n - 1 ) ; return sqrt ( pow ( a * an , n ) ) ; }
Hyp: 
double productOfGP ( double a , double r , int n ) { double an = a * pow ( r , n - 1 ) ; return sqrt ( pow ( a * an , n ) ) ; }

BLEU: 79.73
Edit Sim: 24


Src: 
function possibleToSort ( arr , n , str ) { let max_element = - 1 ; for ( let i = 0 ; i < str . length ; i ++ ) { max_element = Math . max ( max_element , arr [ i ] ) ; if ( str [ i ] == ' ' ) { if ( max_element > i + 1 ) return " " ; } } return " " ; }
Ref: 
string possibleToSort ( int * arr , int n , string str ) { int max_element = -1 ; for ( long i = 0 ; i < str . size ( ) ; i ++ ) { max_element = max ( max_element , arr [ i ] ) ; if ( str [ i ] == '0' ) { if ( max_element > i + 1 ) return " No " ; } } return " Yes " ; }
Hyp: 
string possibleToSort ( int arr [ ] , int n , string str ) { int max_element = -1 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { max_element = max ( max_element , arr [ i ] ) ; if ( str [ i ] == ' ( ' ) { if ( max_element > i + 1 ) return " Not ▁ Found " ; } } return " Yes " ; }

BLEU: 78.23
Edit Sim: 27


Src: 
function nearest ( n ) { var prevSquare = parseInt ( Math . sqrt ( n ) ) ; var nextSquare = prevSquare + 1 ; prevSquare = prevSquare * prevSquare ; nextSquare = nextSquare * nextSquare ; if ( ( n - prevSquare ) < ( nextSquare - n ) ) { ans = parseInt ( ( prevSquare - n ) ) ; } else ans = parseInt ( ( nextSquare - n ) ) ; return ans ; }
Ref: 
int nearest ( int n ) { int prevSquare = sqrt ( n ) ; int nextSquare = prevSquare + 1 ; prevSquare = prevSquare * prevSquare ; nextSquare = nextSquare * nextSquare ; int ans = ( n - prevSquare ) < ( nextSquare - n ) ? ( prevSquare - n ) : ( nextSquare - n ) ; return ans ; }
Hyp: 
int nearest ( int n ) { int prevSquare = sqrt ( n ) ; int nextSquare = prevSquare + 1 ; prevSquare = prevSquare * prevSquare ; nextSquare = nextSquare * nextSquare ; if ( ( n - prevSquare ) < ( nextSquare - n ) ) { ans = ( prevSquare - n ) ; } else ans = ( nextSquare - n ) ; return ans ; }

BLEU: 79.44
Edit Sim: 30


Src: 
function number_of_tower ( house , range , n ) { house . sort ( function ( a , b ) { return a - b ; } ) ; let numOfTower = 0 ; let i = 0 ; while ( i < n ) { numOfTower ++ ; let loc = house [ i ] + range ; while ( i < n && house [ i ] <= loc ) i ++ ; -- i ; loc = house [ i ] + range ; while ( i < n && house [ i ] <= loc ) i ++ ; } return numOfTower ; }
Ref: 
int number_of_tower ( int house [ ] , int range , int n ) { sort ( house , house + n ) ; int numOfTower = 0 ; int i = 0 ; while ( i < n ) { numOfTower ++ ; int loc = house [ i ] + range ; while ( i < n && house [ i ] <= loc ) i ++ ; -- i ; loc = house [ i ] + range ; while ( i < n && house [ i ] <= loc ) i ++ ; } return numOfTower ; }
Hyp: 
int number_of_tower ( int house [ ] , int range , int n ) { sort ( house , house + n ) ; int numOfTower = 0 ; int i = 0 ; while ( i < n ) { numOfTower ++ ; int loc = house [ i ] + range ; while ( i < n && house [ i ] <= loc ) i ++ ; -- i ; loc = house [ i ] + range ; while ( i < n && house [ i ] <= loc ) i ++ ; } return numOfTower ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function solve ( n ) { if ( n < 0 ) return 0 ; if ( n == 0 ) return 1 ; if ( dp [ n ] != - 1 ) return dp [ n ] ; return dp [ n ] = solve ( n - 1 ) + solve ( n - 3 ) + solve ( n - 5 ) ; }
Ref: 
int solve ( int n ) { if ( n < 0 ) return 0 ; if ( n == 0 ) return 1 ; if ( dp [ n ] != -1 ) return dp [ n ] ; return dp [ n ] = solve ( n - 1 ) + solve ( n - 3 ) + solve ( n - 5 ) ; }
Hyp: 
int solve ( int n ) { if ( n < 0 ) return 0 ; if ( n == 0 ) return 1 ; if ( dp [ n ] != -1 ) return dp [ n ] ; return dp [ n ] = solve ( n - 1 ) + solve ( n - 3 ) + solve ( n - 5 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function sortArray ( A , N ) { let x = 0 , y = 0 , z = 0 ; if ( N % 4 == 0 N % 4 == 1 ) { for ( let i = 0 ; i < N / 2 ; i ++ ) { x = i ; if ( i % 2 == 0 ) { y = N - i - 2 ; z = N - i - 1 ; } A [ z ] = A [ y ] ; A [ y ] = A [ x ] ; A [ x ] = x + 1 ; } document . write ( " " ) ; for ( let i = 0 ; i < N ; i ++ ) document . write ( A [ i ] + " " ) ; } else { document . write ( " " ) ; } }
Ref: 
void sortArray ( int A [ ] , int N ) { int x , y , z ; if ( N % 4 == 0 N % 4 == 1 ) { for ( int i = 0 ; i < N / 2 ; i ++ ) { x = i ; if ( i % 2 == 0 ) { y = N - i - 2 ; z = N - i - 1 ; } A [ z ] = A [ y ] ; A [ y ] = A [ x ] ; A [ x ] = x + 1 ; } cout << " Sorted ▁ Array : ▁ " ; for ( int i = 0 ; i < N ; i ++ ) cout << A [ i ] << " ▁ " ; } else cout << " - 1" ; }
Hyp: 
void sortArray ( int A [ ] , int N ) { int x = 0 , y = 0 , z = 0 ; if ( N % 4 == 0 N % 4 == 1 ) { for ( int i = 0 ; i < N / 2 ; i ++ ) { x = i ; if ( i % 2 == 0 ) { y = N - i - 2 ; z = N - i - 1 ; } A [ z ] = A [ y ] ; A [ y ] = A [ x ] ; A [ x ] = x + 1 ; } cout << " ▁ " ; for ( int i = 0 ; i < N ; i ++ ) cout << A [ i ] << " ▁ " ; } else { cout << " - 1" ; } }

BLEU: 90.4
Edit Sim: 33


Src: 
function Icosihenagonal_num ( n ) { return ( 19 * n * n - 17 * n ) / 2 ; }
Ref: 
int Icosihenagonal_num ( int n ) { return ( 19 * n * n - 17 * n ) / 2 ; }
Hyp: 
int Icosihenagonal_num ( long int n ) { return ( 19 * n * n - 17 * n ) / 2 ; }

BLEU: 88.95
Edit Sim: 5


Src: 
function printSubsequences ( s ) { let str = s . split ( ' ' ) ; let n = str . length ; let opsize = Math . pow ( 2 , n - 1 ) ; for ( let counter = 0 ; counter < opsize ; counter ++ ) { for ( let j = 0 ; j < n ; j ++ ) { document . write ( str [ j ] ) ; if ( ( counter & ( 1 << j ) ) > 0 ) document . write ( " " ) ; } document . write ( " " ) ; } }
Ref: 
void printSubsequences ( string str ) { int n = str . length ( ) ; unsigned int opsize = pow ( 2 , n - 1 ) ; for ( int counter = 0 ; counter < opsize ; counter ++ ) { for ( int j = 0 ; j < n ; j ++ ) { cout << str [ j ] ; if ( counter & ( 1 << j ) ) cout << " ▁ " ; } cout << endl ; } }
Hyp: 
void printSubsequences ( string str ) { int n = str . length ( ) ; int opsize = pow ( 2 , n - 1 ) ; for ( int counter = 0 ; counter < opsize ; counter ++ ) { for ( int j = 0 ; j < n ; j ++ ) { cout << str [ j ] ; if ( counter & ( 1 << j ) ) cout << " ▁ " ; } cout << endl ; } }

BLEU: 97.15
Edit Sim: 9


Src: 
function decdiagonal ( a ) { if ( a < 0 ) return - 1 ; var d = 1.902 * a ; return d ; }
Ref: 
float decdiagonal ( float a ) { if ( a < 0 ) return -1 ; float d = 1.902 * a ; return d ; }
Hyp: 
float decdiagonal ( float a ) { if ( a < 0 ) return -1 ; float d = 1.902 * a ; return d ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countTriplets ( A , B , C ) { let ans = 0 ; for ( let i = 1 ; i <= A ; i ++ ) { for ( let j = 1 ; j <= B ; j ++ ) { for ( let k = 1 ; k <= C ; k ++ ) { if ( i * k > j * j ) ans ++ ; } } } return ans ; }
Ref: 
long countTriplets ( int A , int B , int C ) { long long ans = 0 ; for ( int i = 1 ; i <= A ; i ++ ) { for ( int j = 1 ; j <= B ; j ++ ) { for ( int k = 1 ; k <= C ; k ++ ) { if ( i * k > j * j ) ans ++ ; } } } return ans ; }
Hyp: 
int countTriplets ( int A , int B , int C ) { int ans = 0 ; for ( int i = 1 ; i <= A ; i ++ ) { for ( int j = 1 ; j <= B ; j ++ ) { for ( int k = 1 ; k <= C ; k ++ ) { if ( i * k > j * j ) ans ++ ; } } } return ans ; }

BLEU: 94.58
Edit Sim: 11


Src: 
function MinimumMail ( n , k , x ) { let m = ( n - 1 ) + Math . ceil ( ( n - 1 ) * 1.0 / x ) * ( n - 1 ) + Math . ceil ( n * 1.0 / x ) * ( k - n ) ; return m ; }
Ref: 
int MinimumMail ( int n , int k , int x ) { ll m = ( n - 1 ) + ( ll ) ceil ( ( n - 1 ) * 1.0 / x ) * ( n - 1 ) + ( ll ) ceil ( n * 1.0 / x ) * ( k - n ) ; return m ; }
Hyp: 
int MinimumMail ( int n , int k , int x ) { int m = ( n - 1 ) + ceil ( ( n - 1 ) * 1.0 / x ) * ( n - 1 ) + ceil ( n * 1.0 / x ) * ( k - n ) ; return m ; }

BLEU: 81.85
Edit Sim: 17


Src: 
function countPaths ( n ) { let zB = 1 ; let zADC = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { let nzB = zADC * 3 ; let nzADC = ( zADC * 2 + zB ) ; zB = nzB ; zADC = nzADC ; } return zB ; }
Ref: 
int countPaths ( int n ) { int zB = 1 ; int zADC = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int nzB = zADC * 3 ; int nzADC = ( zADC * 2 + zB ) ; zB = nzB ; zADC = nzADC ; } return zB ; }
Hyp: 
int countPaths ( int n ) { int zB = 1 ; int zADC = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int nzB = zADC * 3 ; int nzADC = ( zADC * 2 + zB ) ; zB = nzB ; zADC = nzADC ; } return zB ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function find_number ( N , K ) { var r ; if ( N % 100 == 0 ) { N += 1 ; r = N . toString ( ) ; } else { r = N . toString ( ) ; } for ( var i = 1 ; i <= K ; i ++ ) r += " " ; return r ; }
Ref: 
string find_number ( int N , int K ) { string r ; if ( N % 100 == 0 ) { N += 1 ; r = to_string ( N ) ; } else { r = to_string ( N ) ; } for ( int i = 1 ; i <= K ; i ++ ) r += "00" ; return r ; }
Hyp: 
string find_number ( int N , int K ) { string r ; if ( N % 100 == 0 ) { N += 1 ; r = to_string ( N ) ; } else { r = to_string ( N ) ; } for ( int i = 1 ; i <= K ; i ++ ) r += " ▁ " ; return r ; }

BLEU: 93.29
Edit Sim: 3


Src: 
function findNumbers ( N ) { for ( var i = 1 ; i <= N / 2 ; i ++ ) { document . write ( i + " " + - i + " " ) ; } if ( N % 2 == 1 ) document . write ( 0 ) ; }
Ref: 
void findNumbers ( int N ) { for ( int i = 1 ; i <= N / 2 ; i ++ ) { cout << i << " , ▁ " << - i << " , ▁ " ; } if ( N % 2 == 1 ) cout << 0 ; }
Hyp: 
void findNumbers ( int N ) { for ( int i = 1 ; i <= N / 2 ; i ++ ) { cout << i << " , ▁ " << - i << " , ▁ " ; } if ( N % 2 == 1 ) cout << 0 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countMaxSetBits ( left , right ) { while ( ( left | ( left + 1 ) ) <= right ) left |= left + 1 ; return left ; }
Ref: 
int countMaxSetBits ( int left , int right ) { while ( ( left | ( left + 1 ) ) <= right ) left |= left + 1 ; return left ; }
Hyp: 
int countMaxSetBits ( int left , int right ) { while ( ( left | ( left + 1 ) ) <= right ) left |= left + 1 ; return left ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function maximumSum ( arr , N ) { let Sum = 0 ; for ( let i = 1 ; i < N ; i ++ ) { if ( arr [ i ] > arr [ i - 1 ] ) Sum += ( arr [ i ] - arr [ i - 1 ] ) ; } return Sum ; }
Ref: 
int maximumSum ( int arr [ ] , int N ) { int Sum = 0 ; for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] > arr [ i - 1 ] ) Sum += ( arr [ i ] - arr [ i - 1 ] ) ; } return Sum ; }
Hyp: 
int maximumSum ( int arr [ ] , int N ) { int Sum = 0 ; for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] > arr [ i - 1 ] ) Sum += ( arr [ i ] - arr [ i - 1 ] ) ; } return Sum ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findArrangement ( N ) { if ( N < 3 ) return 0 ; return ( ( N ) * ( N - 1 ) * ( N - 2 ) ) / 3 ; }
Ref: 
int findArrangement ( int N ) { if ( N < 3 ) return 0 ; return ( ( N ) * ( N - 1 ) * ( N - 2 ) ) / 3 ; }
Hyp: 
int findArrangement ( int N ) { if ( N < 3 ) return 0 ; return ( ( N ) * ( N - 1 ) * ( N - 2 ) ) / 3 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function minCount ( n ) { let hasharr = [ 10 , 3 , 6 , 9 , 2 , 5 , 8 , 1 , 4 , 7 ] ; if ( n > 69 ) return hasharr [ n % 10 ] ; else { if ( n >= hasharr [ n % 10 ] * 7 ) return ( hasharr [ n % 10 ] ) ; else return - 1 ; } }
Ref: 
int minCount ( int n ) { int hasharr [ TEN ] = { 10 , 3 , 6 , 9 , 2 , 5 , 8 , 1 , 4 , 7 } ; if ( n > 69 ) return hasharr [ n % TEN ] ; else { if ( n >= hasharr [ n % TEN ] * 7 ) return ( hasharr [ n % TEN ] ) ; else return -1 ; } }
Hyp: 
int minCount ( int n ) { int hasharr [ 10 ] = { 3 , 6 , 9 , 2 , 5 , 8 , 1 , 4 , 7 } ; if ( n > 69 ) return hasharr [ n % 10 ] ; else { if ( n >= hasharr [ n % 10 ] * 7 ) return ( hasharr [ n % 10 ] ) ; else return -1 ; } }

BLEU: 82.86
Edit Sim: 17


Src: 
function minParentheses ( p ) { var bal = 0 ; var ans = 0 ; for ( var i = 0 ; i < p . length ; ++ i ) { bal += p [ i ] == ' ' ? 1 : - 1 ; if ( bal == - 1 ) { ans += 1 ; bal += 1 ; } } return bal + ans ; }
Ref: 
int minParentheses ( string p ) { int bal = 0 ; int ans = 0 ; for ( int i = 0 ; i < p . length ( ) ; ++ i ) { bal += p [ i ] == ' ( ' ? 1 : -1 ; if ( bal == -1 ) { ans += 1 ; bal += 1 ; } } return bal + ans ; }
Hyp: 
int minParentheses ( string p ) { int bal = 0 ; int ans = 0 ; for ( int i = 0 ; i < p . length ( ) ; ++ i ) { bal += p [ i ] == ' ( ' ? 1 : -1 ; if ( bal == -1 ) { ans += 1 ; bal += 1 ; } } return bal + ans ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function subsetCount ( arr , n ) { return 1 << n ; }
Ref: 
int subsetCount ( int arr [ ] , int n ) { return 1 << n ; }
Hyp: 
int subsetCount ( int arr [ ] , int n ) { return 1 << n ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function FindMinimumCost ( ind , a , n , k , dp ) { if ( ind == ( n - 1 ) ) return 0 ; else if ( dp [ ind ] != - 1 ) return dp [ ind ] ; else { var ans = Number . MAX_VALUE ; for ( var i = 1 ; i <= k ; i ++ ) { if ( ind + i < n ) ans = Math . min ( ans , Math . abs ( a [ ind + i ] - a [ ind ] ) + FindMinimumCost ( ind + i , a , n , k , dp ) ) ; else break ; } return dp [ ind ] = ans ; } }
Ref: 
int FindMinimumCost ( int ind , int a [ ] , int n , int k , int dp [ ] ) { if ( ind == ( n - 1 ) ) return 0 ; else if ( dp [ ind ] != -1 ) return dp [ ind ] ; else { int ans = INT_MAX ; for ( int i = 1 ; i <= k ; i ++ ) { if ( ind + i < n ) ans = min ( ans , abs ( a [ ind + i ] - a [ ind ] ) + FindMinimumCost ( ind + i , a , n , k , dp ) ) ; else break ; } return dp [ ind ] = ans ; } }
Hyp: 
int FindMinimumCost ( int ind , int a [ ] , int n , int k , int dp [ ] ) { if ( ind == ( n - 1 ) ) return 0 ; else if ( dp [ ind ] != -1 ) return dp [ ind ] ; else { int ans = INT_MAX ; for ( int i = 1 ; i <= k ; i ++ ) { if ( ind + i < n ) ans = min ( ans , abs ( a [ ind + i ] - a [ ind ] ) + FindMinimumCost ( ind + i , a , n , k , dp ) ) ; else break ; } return dp [ ind ] = ans ; } }

BLEU: 100.0
Edit Sim: 0


Src: 
function meanOfRemainingElements ( arr , N , K ) { arr . sort ( function ( a , b ) { return a - b } ) ; let kthPercent = Math . floor ( ( N * K ) / 100 ) ; let sum = 0 ; for ( let i = 0 ; i < N ; i ++ ) if ( i >= kthPercent && i < ( N - kthPercent ) ) sum += arr [ i ] ; let mean = sum / ( N - 2 * kthPercent ) ; document . write ( mean . toFixed ( 5 ) ) ; }
Ref: 
void meanOfRemainingElements ( int arr [ ] , int N , int K ) { sort ( arr , arr + N ) ; int kthPercent = ( N * K ) / 100 ; float sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( i >= kthPercent && i < ( N - kthPercent ) ) sum += arr [ i ] ; float mean = sum / ( N - 2 * kthPercent ) ; cout << fixed << setprecision ( 5 ) << mean << endl ; }
Hyp: 
void meanOfRemainingElements ( int arr [ ] , int N , int K ) { sort ( arr , arr + N ) ; int kthPercent = ( N * K ) / 100 ; int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( i >= kthPercent && i < ( N - kthPercent ) ) sum += arr [ i ] ; int mean = sum / ( N - 2 * kthPercent ) ; cout << mean << endl ; }

BLEU: 87.15
Edit Sim: 39


Src: 
function nobleInteger ( arr ) { arr . sort ( function ( a , b ) { return a - b ; } ) ; let n = arr . length ; for ( let i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) continue ; if ( arr [ i ] == n - i - 1 ) return arr [ i ] ; } if ( arr [ n - 1 ] == 0 ) return arr [ n - 1 ] ; return - 1 ; }
Ref: 
int nobleInteger ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) continue ; if ( arr [ i ] == n - i - 1 ) return arr [ i ] ; } if ( arr [ n - 1 ] == 0 ) return arr [ n - 1 ] ; return -1 ; }
Hyp: 
int nobleInteger ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int n = arr . size ( ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) continue ; if ( arr [ i ] == n - i - 1 ) return arr [ i ] ; } if ( arr [ n - 1 ] == 0 ) return arr [ n - 1 ] ; return -1 ; }

BLEU: 91.23
Edit Sim: 25


Src: 
function noOfYears ( t1 , n1 , t2 ) { var years = ( ( t2 - 1 ) * n1 / ( t1 - 1 ) ) ; return years ; }
Ref: 
float noOfYears ( int t1 , int n1 , int t2 ) { float years = ( ( t2 - 1 ) * n1 / ( float ) ( t1 - 1 ) ) ; return years ; }
Hyp: 
int noOfYears ( int t1 , int n1 , int t2 ) { int years = ( ( t2 - 1 ) * n1 / ( t1 - 1 ) ) ; return years ; }

BLEU: 80.64
Edit Sim: 18


Src: 
function isSubsetSum ( set , n , sum ) { if ( sum == 0 ) return true ; if ( n == 0 ) return false ; if ( set [ n - 1 ] > sum ) return isSubsetSum ( set , n - 1 , sum ) ; return isSubsetSum ( set , n - 1 , sum ) || isSubsetSum ( set , n - 1 , sum - set [ n - 1 ] ) ; }
Ref: 
bool isSubsetSum ( int set [ ] , int n , int sum ) { if ( sum == 0 ) return true ; if ( n == 0 ) return false ; if ( set [ n - 1 ] > sum ) return isSubsetSum ( set , n - 1 , sum ) ; return isSubsetSum ( set , n - 1 , sum ) || isSubsetSum ( set , n - 1 , sum - set [ n - 1 ] ) ; }
Hyp: 
bool isSubsetSum ( int set [ ] , int n , int sum ) { if ( sum == 0 ) return true ; if ( n == 0 ) return false ; if ( set [ n - 1 ] > sum ) return isSubsetSum ( set , n - 1 , sum ) ; return isSubsetSum ( set , n - 1 , sum ) || isSubsetSum ( set , n - 1 , sum - set [ n - 1 ] ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function nthTerm ( N ) { let nth = 0 , i ; for ( i = N ; i > 0 ; i -- ) { nth += Math . pow ( i , i ) ; } return nth ; }
Ref: 
int nthTerm ( int N ) { int nth = 0 , i ; for ( i = N ; i > 0 ; i -- ) { nth += pow ( i , i ) ; } return nth ; }
Hyp: 
int nthTerm ( int N ) { int nth = 0 , i ; for ( i = N ; i > 0 ; i -- ) { nth += pow ( i , i ) ; } return nth ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function printChar ( str , n ) { let freq = new Array ( SIZE ) ; for ( let i = 0 ; i < freq . length ; i ++ ) { freq [ i ] = 0 ; } for ( let i = 0 ; i < n ; i ++ ) { freq [ str . charCodeAt ( i ) - ' ' . charCodeAt ( 0 ) ] ++ ; } for ( let i = 0 ; i < n ; i ++ ) { if ( freq [ str . charCodeAt ( i ) - ' ' . charCodeAt ( 0 ) ] % 2 == 0 ) { document . write ( str [ i ] ) ; } } }
Ref: 
void printChar ( string str , int n ) { int freq [ SIZE ] ; memset ( freq , 0 , sizeof ( freq ) ) ; for ( int i = 0 ; i < n ; i ++ ) freq [ str [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < n ; i ++ ) { if ( freq [ str [ i ] - ' a ' ] % 2 == 0 ) { cout << str [ i ] ; } } }
Hyp: 
void printChar ( string str , int n ) { int freq [ SIZE ] ; for ( int i = 0 ; i < n ; i ++ ) { freq [ str [ i ] - ' a ' ] ++ ; } for ( int i = 0 ; i < n ; i ++ ) { if ( freq [ str [ i ] - ' a ' ] % 2 == 0 ) { cout << str [ i ] ; } } }

BLEU: 83.47
Edit Sim: 44


Src: 
function countSub ( str ) { var n = str . length ; var ans = 0 ; var cnt = Array ( 26 ) . fill ( 0 ) ; var i = 0 , j = 0 ; while ( i < n ) { if ( j < n && ( cnt [ str [ j ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] == 0 ) ) { cnt [ str [ j ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; ans += ( j - i + 1 ) ; j ++ ; } else { cnt [ str [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] -- ; i ++ ; } } return ans ; }
Ref: 
int countSub ( string str ) { int n = ( int ) str . size ( ) ; long long int ans = 0 ; int cnt [ 26 ] ; memset ( cnt , 0 , sizeof ( cnt ) ) ; int i = 0 , j = 0 ; while ( i < n ) { if ( j < n && ( cnt [ str [ j ] - ' a ' ] == 0 ) ) { cnt [ str [ j ] - ' a ' ] ++ ; ans += ( j - i + 1 ) ; j ++ ; } else { cnt [ str [ i ] - ' a ' ] -- ; i ++ ; } } return ans ; }
Hyp: 
int countSub ( string str ) { int n = str . length ( ) ; int ans = 0 ; int cnt [ 26 ] ; int i = 0 , j = 0 ; while ( i < n ) { if ( j < n && ( cnt [ str [ j ] - ' a ' ] == 0 ) ) { cnt [ str [ j ] - ' a ' ] ++ ; ans += ( j - i + 1 ) ; j ++ ; } else { cnt [ str [ i ] - ' a ' ] -- ; i ++ ; } } return ans ; }

BLEU: 82.13
Edit Sim: 62


Src: 
function MinimumString ( x ) { let b = 1 ; let left_lim = Math . sqrt ( x ) + 1.0 ; let right_lim = Math . sqrt ( x ) + 2.0 ; let r = 0 ; for ( let i = Math . floor ( left_lim ) ; i <= Math . floor ( right_lim ) ; i ++ ) { if ( i > left_lim && i < right_lim ) { r = i ; break ; } } return b + r ; }
Ref: 
int MinimumString ( int x ) { int b = 1 ; double left_lim = sqrt ( x ) + 1.0 ; double right_lim = sqrt ( x ) + 2.0 ; int r ; for ( int i = left_lim ; i <= right_lim ; i ++ ) { if ( i > left_lim and i < right_lim ) { r = i ; break ; } } return b + r ; }
Hyp: 
int MinimumString ( int x ) { int b = 1 ; long double left_lim = sqrt ( x ) + 1.0 ; long double right_lim = sqrt ( x ) + 2.0 ; long double r = 0 ; for ( int i = left_lim ; i <= right_lim ; i ++ ) { if ( i > left_lim && i < right_lim ) { r = i ; break ; } } return b + r ; }

BLEU: 82.38
Edit Sim: 27


Src: 
function findScoreSum ( n ) { let total = 0 ; let prev_monday = 0 , curr_day = 0 ; for ( let day = 1 ; day <= n ; day ++ ) { if ( day % 7 == 1 ) { prev_monday ++ ; curr_day = prev_monday ; } total += curr_day ++ ; } document . write ( total ) ; }
Ref: 
void findScoreSum ( int n ) { int total = 0 ; int prev_monday = 0 , curr_day = 0 ; for ( int day = 1 ; day <= n ; day ++ ) { if ( day % 7 == 1 ) { prev_monday ++ ; curr_day = prev_monday ; } total += curr_day ++ ; } cout << total ; }
Hyp: 
void findScoreSum ( int n ) { int total = 0 ; int prev_monday = 0 , curr_day = 0 ; for ( int day = 1 ; day <= n ; day ++ ) { if ( day % 7 == 1 ) { prev_monday ++ ; curr_day = prev_monday ; } total += curr_day ++ ; } cout << total ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function reversDigits ( num ) { if ( num > 0 ) { reversDigits ( Math . floor ( num / 10 ) ) ; rev_num += ( num % 10 ) * base_pos ; base_pos *= 10 ; } return rev_num ; }
Ref: 
int reversDigits ( int num ) { static int rev_num = 0 ; static int base_pos = 1 ; if ( num > 0 ) { reversDigits ( num / 10 ) ; rev_num += ( num % 10 ) * base_pos ; base_pos *= 10 ; } return rev_num ; }
Hyp: 
int reversDigits ( int num ) { if ( num ) { reversDigits ( num / 10 ) ; rev_num += ( num % 10 ) * base_pos ; base_pos *= 10 ; } return rev_num ; }

BLEU: 63.37
Edit Sim: 55


Src: 
function maximizeProduct ( N ) { let MSB = Math . log2 ( N ) ; let X = 1 << MSB ; let Y = N - ( 1 << MSB ) ; for ( let i = 0 ; i < MSB ; i ++ ) { if ( ! ( N & ( 1 << i ) ) ) { X += 1 << i ; Y += 1 << i ; } } document . write ( X + " " + Y ) ; }
Ref: 
void maximizeProduct ( int N ) { int MSB = ( int ) log2 ( N ) ; int X = 1 << MSB ; int Y = N - ( 1 << MSB ) ; for ( int i = 0 ; i < MSB ; i ++ ) { if ( ! ( N & ( 1 << i ) ) ) { X += 1 << i ; Y += 1 << i ; } } cout << X << " ▁ " << Y ; }
Hyp: 
void maximizeProduct ( int N ) { int MSB = log2 ( N ) ; int X = 1 << MSB ; int Y = N - ( 1 << MSB ) ; for ( int i = 0 ; i < MSB ; i ++ ) { if ( N & ( 1 << i ) ) { X += 1 << i ; Y += 1 << i ; } } cout << X << " ▁ " << Y ; }

BLEU: 90.25
Edit Sim: 14


Src: 
function isSumSquare ( N ) { var n = ( 2 + Math . sqrt ( 8 * N - 4 ) ) / 2 ; return ( n - parseInt ( n ) ) == 0 ; } var i = 13 ; if ( isSumSquare ( i ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
Ref: 
bool isSumSquare ( int N ) { float n = ( 2 + sqrt ( 8 * N - 4 ) ) / 2 ; return ( n - ( int ) n ) == 0 ; }
Hyp: 
bool isSumSquare ( int N ) { float n = ( 2 + sqrt ( 8 * N - 4 ) ) / 2 ; return ( n - ( int ) n ) == 0 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function isoctagonal ( N ) { var n = ( 2 + Math . sqrt ( 12 * N + 4 ) ) / 6 ; return ( n - parseInt ( n ) == 0 ) ; } var N = 8 ; if ( isoctagonal ( N ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
Ref: 
bool isoctagonal ( int N ) { float n = ( 2 + sqrt ( 12 * N + 4 ) ) / 6 ; return ( n - ( int ) n ) == 0 ; }
Hyp: 
bool isoctagonal ( int N ) { float n = ( 2 + sqrt ( 12 * N + 4 ) ) / 6 ; return ( n - ( int ) n ) == 0 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function SectorArea ( radius , angle ) { if ( angle >= 360 ) document . write ( " " ) ; else { let sector = ( ( 22 * radius * radius ) / 7 ) * ( angle / 360 ) ; document . write ( sector ) ; } }
Ref: 
void SectorArea ( double radius , double angle ) { if ( angle >= 360 ) cout << " Angle ▁ not ▁ possible " ; else { double sector = ( ( 22 * radius * radius ) / 7 ) * ( angle / 360 ) ; cout << sector ; } }
Hyp: 
void SectorArea ( int radius , int angle ) { if ( angle >= 360 ) cout << " NO " ; else { int sector = ( ( 22 * radius * radius ) / 7 ) * ( angle / 360 ) ; cout << sector ; } }

BLEU: 74.0
Edit Sim: 40


Src: 
function maxRepeating ( arr , n , k ) { for ( let i = 0 ; i < n ; i ++ ) arr [ arr [ i ] % k ] += k ; let max = arr [ 0 ] , result = 0 ; for ( let i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > max ) { max = arr [ i ] ; result = i ; } } return result ; }
Ref: 
int maxRepeating ( int * arr , int n , int k ) { for ( int i = 0 ; i < n ; i ++ ) arr [ arr [ i ] % k ] += k ; int max = arr [ 0 ] , result = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > max ) { max = arr [ i ] ; result = i ; } } return result ; }
Hyp: 
int maxRepeating ( int arr [ ] , int n , int k ) { for ( int i = 0 ; i < n ; i ++ ) arr [ arr [ i ] % k ] += k ; int max = arr [ 0 ] , result = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > max ) { max = arr [ i ] ; result = i ; } } return result ; }

BLEU: 95.47
Edit Sim: 6


Src: 
function maximumCandy ( candies , safety , N , M ) { let total = 0 ; let ans = Number . MAX_VALUE ; let all_safe = true ; for ( let i = 0 ; i < N ; i ++ ) { if ( candies [ i ] + M > safety [ i ] ) { all_safe = false ; ans = Math . min ( ans , safety [ i ] ) ; } else { ans = Math . min ( ans , candies [ i ] + M ) ; } total += candies [ i ] ; } if ( all_safe ) return total ; else return ans ; }
Ref: 
int maximumCandy ( int candies [ ] , int safety [ ] , int N , int M ) { int total = 0 ; int ans = INT_MAX ; bool all_safe = true ; for ( int i = 0 ; i < N ; i ++ ) { if ( candies [ i ] + M > safety [ i ] ) { all_safe = false ; ans = min ( ans , safety [ i ] ) ; } else { ans = min ( ans , candies [ i ] + M ) ; } total += candies [ i ] ; } if ( all_safe ) return total ; else return ans ; }
Hyp: 
int maximumCandy ( int candies [ ] , int safety [ ] , int N , int M ) { int total = 0 ; int ans = INT_MAX ; bool all_safe = true ; for ( int i = 0 ; i < N ; i ++ ) { if ( candies [ i ] + M > safety [ i ] ) { all_safe = false ; ans = min ( ans , safety [ i ] ) ; } else { ans = min ( ans , candies [ i ] + M ) ; } total += candies [ i ] ; } if ( all_safe ) return total ; else return ans ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function scoreOfParentheses ( s ) { var stack = [ ] ; stack . push ( 0 ) ; s . split ( ' ' ) . forEach ( c => { if ( c == ' ' ) stack . push ( 0 ) ; else { var tmp = stack [ stack . length - 1 ] ; stack . pop ( ) ; var val = 0 ; if ( tmp > 0 ) val = tmp * 2 ; else val = 1 ; stack [ stack . length - 1 ] += val ; } } ) ; document . write ( stack [ stack . length - 1 ] ) ; }
Ref: 
void scoreOfParentheses ( string s ) { stack < int > stack ; stack . push ( 0 ) ; for ( char c : s ) { if ( c == ' ( ' ) stack . push ( 0 ) ; else { int tmp = stack . top ( ) ; stack . pop ( ) ; int val = 0 ; if ( tmp > 0 ) val = tmp * 2 ; else val = 1 ; stack . top ( ) += val ; } } cout << stack . top ( ) ; }
Hyp: 
void scoreOfParentheses ( string s ) { stack < int > stack ; stack . push ( 0 ) ; for ( char c : s ) { if ( c == ' ( ' ) stack . push ( 0 ) ; else { int tmp = stack . top ( ) ; stack . pop ( ) ; int val = 0 ; if ( tmp > 0 ) val = tmp * 2 ; else val = 1 ; stack [ stack . size ( ) - 1 ] += val ; } } ) ; cout << stack [ stack . size ( ) - 1 ] ; }

BLEU: 80.67
Edit Sim: 40


Src: 
function countTriplets ( a , n , x ) { var answer = 0 ; for ( var i = 0 ; i < n ; i ++ ) { for ( var j = i + 1 ; j < n ; j ++ ) { for ( var k = j + 1 ; k < n ; k ++ ) { var temp = [ ] ; temp . push ( a [ i ] ) ; temp . push ( a [ j ] ) ; temp . push ( a [ k ] ) ; temp . sort ( ( a , b ) => a - b ) if ( temp [ 0 ] < temp [ 1 ] && temp [ 1 ] < temp [ 2 ] && temp [ 0 ] * temp [ 1 ] * temp [ 2 ] <= x ) answer ++ ; } } } return answer ; }
Ref: 
int countTriplets ( int a [ ] , int n , int x ) { int answer = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) { vector < int > temp ; temp . push_back ( a [ i ] ) ; temp . push_back ( a [ j ] ) ; temp . push_back ( a [ k ] ) ; sort ( temp . begin ( ) , temp . end ( ) ) ; if ( temp [ 0 ] < temp [ 1 ] && temp [ 1 ] < temp [ 2 ] && temp [ 0 ] * temp [ 1 ] * temp [ 2 ] <= x ) answer ++ ; } } } return answer ; }
Hyp: 
int countTriplets ( int a [ ] , int n , int x ) { int answer = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) { int temp [ ] ; temp . push_back ( a [ i ] ) ; temp . push_back ( a [ j ] ) ; temp . push_back ( a [ k ] ) ; sort ( temp , temp + n ) ; if ( temp [ 0 ] < temp [ 1 ] && temp [ 1 ] < temp [ 2 ] && temp [ 0 ] * temp [ 1 ] * temp [ 2 ] <= x ) answer ++ ; } } } return answer ; }

BLEU: 89.95
Edit Sim: 34


Src: 
function findNumber ( n ) { let x = Math . floor ( ( - 1 + Math . sqrt ( 1 + 8 * n - 8 ) ) / 2 ) ; let base = ( x * ( x + 1 ) ) / 2 + 1 ; return n - base + 1 ; }
Ref: 
int findNumber ( int n ) { int x = ( int ) floor ( ( -1 + sqrt ( 1 + 8 * n - 8 ) ) / 2 ) ; int base = ( x * ( x + 1 ) ) / 2 + 1 ; return n - base + 1 ; }
Hyp: 
int findNumber ( int n ) { int x = ( -1 + sqrt ( 1 + 8 * n - 8 ) ) / 2 ; int base = ( x * ( x + 1 ) ) / 2 + 1 ; return n - base + 1 ; }

BLEU: 85.07
Edit Sim: 18


Src: 
function minAND ( arr , n ) { let s = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { s = s & arr [ i ] ; } document . write ( ( s ) + " " ) ; }
Ref: 
void minAND ( int arr [ ] , int n ) { int s = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { s = s & arr [ i ] ; } cout << ( s ) << endl ; }
Hyp: 
void minAND ( int arr [ ] , int n ) { int s = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { s = s & arr [ i ] ; } cout << s << " ▁ " ; }

BLEU: 89.13
Edit Sim: 9


Src: 
function numberOf2sinRange ( n ) { var s = " " ; for ( var i = 0 ; i < n + 1 ; i ++ ) s += i . toString ( ) ; var count = 0 ; for ( var i = 0 ; i < s . length ; i ++ ) { if ( s . charAt ( i ) == ' ' ) { count ++ ; } } return count ; }
Ref: 
int numberOf2sinRange ( int n ) { string s = " " ; for ( int i = 0 ; i < n + 1 ; i ++ ) s += to_string ( i ) ; int count = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] == '2' ) { count ++ ; } } return count ; }
Hyp: 
int numberOf2sinRange ( int n ) { string s = " " ; for ( int i = 0 ; i < n + 1 ; i ++ ) s += to_string ( i ) ; int count = 0 ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { if ( s [ i ] == '2' ) { count ++ ; } } return count ; }

BLEU: 96.78
Edit Sim: 6


Src: 
function countDistinctCode ( str ) { var codes = new Set ( ) ; for ( var i = 0 ; i < str . length - 1 ; i ++ ) codes . add ( str . substr ( i , 2 ) ) ; return codes . size ; }
Ref: 
int countDistinctCode ( string str ) { set < string > codes ; for ( int i = 0 ; i < str . length ( ) - 1 ; i ++ ) codes . insert ( str . substr ( i , 2 ) ) ; return codes . size ( ) ; }
Hyp: 
int countDistinctCode ( string str ) { set < string > codes ; for ( int i = 0 ; i < str . length ( ) - 1 ; i ++ ) codes . insert ( str . substr ( i , 2 ) ) ; return codes . size ( ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function get ( L , R ) { let x = 1.0 / L ; let y = 1.0 / ( R + 1.0 ) ; return ( x - y ) ; }
Ref: 
double get ( double L , double R ) { double x = 1.0 / L ; double y = 1.0 / ( R + 1.0 ) ; return ( x - y ) ; }
Hyp: 
float get ( float L , float R ) { float x = 1.0 / L ; float y = 1.0 / ( R + 1.0 ) ; return ( x - y ) ; }

BLEU: 69.09
Edit Sim: 30


Src: 
function findMinSum ( mat , N ) { var sum = 0 ; for ( var i = 0 ; i < N ; i ++ ) { var res = 0 ; for ( var j = 0 ; j < N ; j ++ ) { if ( i != j ) { res |= mat [ i ] [ j ] ; } } sum += res ; } return sum ; }
Ref: 
int findMinSum ( vector < vector < int > > mat , int N ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int res = 0 ; for ( int j = 0 ; j < N ; j ++ ) { if ( i != j ) { res |= mat [ i ] [ j ] ; } } sum += res ; } return sum ; }
Hyp: 
int findMinSum ( int mat [ ] [ MAX ] , int N ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int res = 0 ; for ( int j = 0 ; j < N ; j ++ ) { if ( i != j ) { res |= mat [ i ] [ j ] ; } } sum += res ; } return sum ; }

BLEU: 89.16
Edit Sim: 22


Src: 
function maxLength ( arr , n ) { let maxLen = 0 ; let i = 0 ; let j = i + 1 ; while ( j < n ) { if ( arr [ i ] != arr [ j ] ) { maxLen = Math . max ( maxLen , 2 ) ; let l = i - 1 ; let r = j + 1 ; while ( l >= 0 && r < n && arr [ l ] == arr [ i ] && arr [ r ] == arr [ j ] ) { l -- ; r ++ ; } maxLen = Math . max ( maxLen , 2 * ( r - j ) ) ; } i ++ ; j = i + 1 ; } return maxLen ; }
Ref: 
int maxLength ( int arr [ ] , int n ) { int maxLen = 0 ; int i = 0 ; int j = i + 1 ; while ( j < n ) { if ( arr [ i ] != arr [ j ] ) { maxLen = max ( maxLen , 2 ) ; int l = i - 1 ; int r = j + 1 ; while ( l >= 0 && r < n && arr [ l ] == arr [ i ] && arr [ r ] == arr [ j ] ) { l -- ; r ++ ; } maxLen = max ( maxLen , 2 * ( r - j ) ) ; } i ++ ; j = i + 1 ; } return maxLen ; }
Hyp: 
int maxLength ( int arr [ ] , int n ) { int maxLen = 0 ; int i = 0 ; int j = i + 1 ; while ( j < n ) { if ( arr [ i ] != arr [ j ] ) { maxLen = max ( maxLen , 2 ) ; int l = i - 1 ; int r = j + 1 ; while ( l >= 0 && r < n && arr [ l ] == arr [ i ] && arr [ r ] == arr [ j ] ) { l -- ; r ++ ; } maxLen = max ( maxLen , 2 * ( r - j ) ) ; } i ++ ; j = i + 1 ; } return maxLen ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function nthSHN ( n , dp ) { if ( n == 1 n == 2 ) return dp [ n ] = 1 ; if ( dp [ n ] != - 1 ) return dp [ n ] ; return dp [ n ] = ( ( 6 * n - 9 ) * nthSHN ( n - 1 , dp ) - ( n - 3 ) * nthSHN ( n - 2 , dp ) ) / n ; }
Ref: 
int nthSHN ( int n , int dp [ ] ) { if ( n == 1 n == 2 ) return dp [ n ] = 1 ; if ( dp [ n ] != -1 ) return dp [ n ] ; return dp [ n ] = ( ( 6 * n - 9 ) * nthSHN ( n - 1 , dp ) - ( n - 3 ) * nthSHN ( n - 2 , dp ) ) / n ; }
Hyp: 
int nthSHN ( int n , int dp [ ] ) { if ( n == 1 n == 2 ) return dp [ n ] = 1 ; if ( dp [ n ] != -1 ) return dp [ n ] ; return dp [ n ] = ( ( 6 * n - 9 ) * nthSHN ( n - 1 , dp ) - ( n - 3 ) * nthSHN ( n - 2 , dp ) ) / n ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function missingK ( a , k , n ) { let difference = 0 , ans = 0 , count = k ; let flag = false ; for ( let i = 0 ; i < n - 1 ; i ++ ) { difference = 0 ; if ( ( a [ i ] + 1 ) != a [ i + 1 ] ) { difference += ( a [ i + 1 ] - a [ i ] ) - 1 ; if ( difference >= count ) { ans = a [ i ] + count ; flag = true ; break ; } else count -= difference ; } } if ( flag ) return ans ; else return - 1 ; }
Ref: 
int missingK ( int a [ ] , int k , int n ) { int difference = 0 , ans = 0 , count = k ; bool flag = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { difference = 0 ; if ( ( a [ i ] + 1 ) != a [ i + 1 ] ) { difference += ( a [ i + 1 ] - a [ i ] ) - 1 ; if ( difference >= count ) { ans = a [ i ] + count ; flag = 1 ; break ; } else count -= difference ; } } if ( flag ) return ans ; else return -1 ; }
Hyp: 
int missingK ( int a [ ] , int k , int n ) { int difference = 0 , ans = 0 , count = k ; bool flag = false ; for ( int i = 0 ; i < n - 1 ; i ++ ) { difference = 0 ; if ( ( a [ i ] + 1 ) != a [ i + 1 ] ) { difference += ( a [ i + 1 ] - a [ i ] ) - 1 ; if ( difference >= count ) { ans = a [ i ] + count ; flag = true ; break ; } else count -= difference ; } } if ( flag ) return ans ; else return -1 ; }

BLEU: 96.2
Edit Sim: 9


Src: 
function sortarray ( arr , N ) { if ( N == 3 ) document . write ( " " ) ; else if ( N % 4 == 0 N % 4 == 1 ) { document . write ( " " ) ; document . write ( Math . floor ( N / 2 ) + " " ) ; let k = 1 , l ; for ( l = 0 ; l < Math . floor ( N / 4 ) ; l ++ ) { document . write ( k + " " + ( k + 1 ) + " " + N + " " ) ; document . write ( k + 1 + " " + N + " " + ( N - 1 ) + " " ) ; k = k + 2 ; N = N - 2 ; } } else document . write ( " " ) ; }
Ref: 
void sortarray ( int arr [ ] , int N ) { if ( N == 3 ) cout << " NO " << endl ; else if ( N % 4 == 0 N % 4 == 1 ) { cout << " YES " << endl ; cout << ( N / 2 ) << endl ; int k = 1 ; for ( int l = 0 ; l < ( N / 4 ) ; l ++ ) { cout << k << " ▁ " << k + 1 << " ▁ " << N << endl ; cout << k + 1 << " ▁ " << N << " ▁ " << N - 1 << endl ; k = k + 2 ; N = N - 2 ; } } else cout << " NO " << endl ; }
Hyp: 
void sortarray ( int arr [ ] , int N ) { if ( N == 3 ) cout << " - 1" ; else if ( N % 4 == 0 N % 4 == 1 ) { cout << " - 1" ; cout << N / 2 << endl ; int k = 1 , l ; for ( l = 0 ; l < N / 4 ; l ++ ) { cout << k << " ▁ " << ( k + 1 ) << " ▁ " << N << endl ; cout << k + 1 << " ▁ " << N << endl ; k = k + 1 ; N = N - 1 ; } } else cout << " - 1" ; }

BLEU: 68.6
Edit Sim: 74


Src: 
function calculate ( X ) { let number_of_bits = 8 ; return ( ( 1 << number_of_bits ) - 1 ) ^ X ; }
Ref: 
int calculate ( int X ) { int number_of_bits = 8 ; return ( ( 1 << number_of_bits ) - 1 ) ^ X ; }
Hyp: 
int calculate ( int X ) { int number_of_bits = 8 ; return ( ( 1 << number_of_bits ) - 1 ) ^ X ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countKAverageSubarrays ( arr , n , k ) { let res = 0 ; for ( let L = 0 ; L < n ; L ++ ) { let sum = 0 ; for ( let R = L ; R < n ; R ++ ) { sum += arr [ R ] ; let len = R - L + 1 ; if ( sum % len == 0 ) { let avg = sum / len ; if ( avg == k ) res ++ ; } } } return res ; }
Ref: 
int countKAverageSubarrays ( int arr [ ] , int n , int k ) { int res = 0 ; for ( int L = 0 ; L < n ; L ++ ) { int sum = 0 ; for ( int R = L ; R < n ; R ++ ) { sum += arr [ R ] ; int len = ( R - L + 1 ) ; if ( sum % len == 0 ) { int avg = sum / len ; if ( avg == k ) res ++ ; } } } return res ; }
Hyp: 
int countKAverageSubarrays ( const int * arr , int n , int k ) { int res = 0 ; for ( int L = 0 ; L < n ; L ++ ) { int sum = 0 ; for ( int R = L ; R < n ; R ++ ) { sum += arr [ R ] ; int len = R - L + 1 ; if ( sum % len == 0 ) { int avg = sum / len ; if ( avg == k ) res ++ ; } } } return res ; }

BLEU: 90.29
Edit Sim: 14


Src: 
function countPairs ( N ) { let res = 0 ; for ( let q = 1 ; q * q <= N ; q ++ ) { let maxP = Math . min ( 2 * N - q , N / q ) ; if ( maxP < q ) continue ; let cnt = maxP - q + 1 ; res += Math . floor ( cnt / 2 + ( cnt & 1 ) ) ; } return res ; }
Ref: 
int countPairs ( int N ) { int res = 0 ; for ( int q = 1 ; q * q <= N ; q ++ ) { int maxP = min ( 2 * N - q , N / q ) ; if ( maxP < q ) continue ; int cnt = maxP - q + 1 ; res += ( cnt / 2 + ( cnt & 1 ) ) ; } return res ; }
Hyp: 
int countPairs ( int N ) { int res = 0 ; for ( int q = 1 ; q * q <= N ; q ++ ) { int maxP = min ( 2 * N - q , N / q ) ; if ( maxP < q ) continue ; int cnt = maxP - q + 1 ; res += ( cnt / 2 + ( cnt & 1 ) ) ; } return res ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function ConcatenateArr ( arr , N ) { let ans = arr [ 0 ] ; for ( let i = 1 ; i < N ; i ++ ) { let l = Math . floor ( Math . log10 ( arr [ i ] ) + 1 ) ; ans = ans * Math . pow ( 10 , l ) ; ans += arr [ i ] ; } return ans ; }
Ref: 
int ConcatenateArr ( int arr [ ] , int N ) { int ans = arr [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) { int l = floor ( log10 ( arr [ i ] ) + 1 ) ; ans = ans * pow ( 10 , l ) ; ans += arr [ i ] ; } return ans ; }
Hyp: 
int ConcatenateArr ( int arr [ ] , int N ) { int ans = arr [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) { int l = floor ( log10 ( arr [ i ] ) + 1 ) ; ans = ans * pow ( 10 , l ) ; ans += arr [ i ] ; } return ans ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findSum ( n ) { return Math . pow ( n , 3 ) ; }
Ref: 
int findSum ( int n ) { return pow ( n , 3 ) ; }
Hyp: 
int findSum ( int n ) { return pow ( n , 3 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function strScore ( str , s , n ) { var score = 0 , index = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( str [ i ] == s ) { for ( j = 0 ; j < s . length ; j ++ ) { score += s . charAt ( j ) . charCodeAt ( 0 ) - ( ' ' ) . charCodeAt ( 0 ) + 1 ; } index = i + 1 ; break ; } } score = score * index ; return score ; }
Ref: 
int strScore ( string str [ ] , string s , int n ) { int score = 0 , index ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == s ) { for ( int j = 0 ; j < s . length ( ) ; j ++ ) score += s [ j ] - ' a ' + 1 ; index = i + 1 ; break ; } } score = score * index ; return score ; }
Hyp: 
int strScore ( string str [ ] , string s , int n ) { int score = 0 , index = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == s ) { for ( int j = 0 ; j < s . length ( ) ; j ++ ) { score += s [ j ] - ' a ' + 1 ; } index = i + 1 ; break ; } } score = score * index ; return score ; }

BLEU: 91.53
Edit Sim: 8


Src: 
function sum ( n ) { return n * ( n + 1 ) * ( n + 2 ) / 3 ; }
Ref: 
int sum ( int n ) { return n * ( n + 1 ) * ( n + 2 ) / 3 ; }
Hyp: 
int sum ( int n ) { return n * ( n + 1 ) * ( n + 2 ) / 3 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function MinimumValue ( arr , n ) { arr . sort ( ) ; let minXor = Number . MAX_VALUE ; let val = 0 ; for ( let i = 0 ; i < n - 1 ; i ++ ) { val = arr [ i ] ^ arr [ i + 1 ] ; minXor = Math . min ( minXor , val ) ; } return minXor ; }
Ref: 
int MinimumValue ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int minXor = INT_MAX ; int val = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { val = arr [ i ] ^ arr [ i + 1 ] ; minXor = min ( minXor , val ) ; } return minXor ; }
Hyp: 
int MinimumValue ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int minXor = INT_MAX ; int val = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { val = arr [ i ] ^ arr [ i + 1 ] ; minXor = min ( minXor , val ) ; } return minXor ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function find3largest ( arr ) { arr . sort ( ( a , b ) => a - b ) ; let check = 0 , count = 1 ; for ( let i = 1 ; i <= arr . length ; i ++ ) { if ( count < 4 ) { if ( check != arr [ arr . length - i ] ) { document . write ( arr [ arr . length - i ] + " " ) ; check = arr [ arr . length - i ] ; count ++ ; } } else break ; } }
Ref: 
void find3largest ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int check = 0 , count = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( count < 4 ) { if ( check != arr [ n - i ] ) { cout << arr [ n - i ] << " ▁ " ; check = arr [ n - i ] ; count ++ ; } } else break ; } }
Hyp: 
void find3largest ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int check = 0 , count = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( count < 4 ) { if ( check != arr [ arr . length ( ) - i ] ) { cout << arr [ arr . length ( ) - i ] << " ▁ " ; check = arr [ arr . length ( ) - i ] ; count ++ ; } } else break ; } }

BLEU: 81.76
Edit Sim: 45


Src: 
function length_rope ( r ) { return ( ( 2 * PI * r ) + 6 * r ) ; }
Ref: 
float length_rope ( float r ) { return ( ( 2 * PI * r ) + 6 * r ) ; }
Hyp: 
int length_rope ( int r ) { return ( ( 2 * PI * r ) + 6 * r ) ; }

BLEU: 85.24
Edit Sim: 8


Src: 
function find_Variance ( n ) { var numerator = n * n - 1 var ans = ( numerator * 1.0 ) / 12 return ans }
Ref: 
double find_Variance ( int n ) { long long int numerator = n * n - 1 ; long double ans = ( numerator * 1.0 ) / 12 ; return ans ; }
Hyp: 
double find_Variance ( int n ) { double numerator = n * n - 1 ; double ans = ( numerator * 1.0 ) / 12 ; return ans ; }

BLEU: 78.29
Edit Sim: 16


Src: 
function answerQuery ( a , n , l , r ) { var count = 0 ; l = l - 1 ; for ( i = l ; i < r ; i ++ ) { var element = a [ i ] ; var divisors = 0 ; for ( j = l ; j < r ; j ++ ) { if ( a [ j ] % a [ i ] == 0 ) divisors ++ ; else break ; } if ( divisors == ( r - l ) ) count ++ ; } return count ; }
Ref: 
int answerQuery ( int a [ ] , int n , int l , int r ) { int count = 0 ; l = l - 1 ; for ( int i = l ; i < r ; i ++ ) { int element = a [ i ] ; int divisors = 0 ; for ( int j = l ; j < r ; j ++ ) { if ( a [ j ] % a [ i ] == 0 ) divisors ++ ; else break ; } if ( divisors == ( r - l ) ) count ++ ; } return count ; }
Hyp: 
int answerQuery ( int a [ ] , int n , int l , int r ) { int count = 0 ; l = l - 1 ; for ( int i = l ; i < r ; i ++ ) { int element = a [ i ] ; int divisors = 0 ; for ( int j = l ; j < r ; j ++ ) { if ( a [ j ] % a [ i ] == 0 ) divisors ++ ; else break ; } if ( divisors == ( r - l ) ) count ++ ; } return count ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function getTotalNumberOfSequences ( m , n ) { if ( m < n ) return 0 ; if ( n == 0 ) return 1 ; return getTotalNumberOfSequences ( m - 1 , n ) + getTotalNumberOfSequences ( m / 2 , n - 1 ) ; }
Ref: 
int getTotalNumberOfSequences ( int m , int n ) { if ( m < n ) return 0 ; if ( n == 0 ) return 1 ; return getTotalNumberOfSequences ( m - 1 , n ) + getTotalNumberOfSequences ( m / 2 , n - 1 ) ; }
Hyp: 
int getTotalNumberOfSequences ( int m , int n ) { if ( m < n ) return 0 ; if ( n == 0 ) return 1 ; return getTotalNumberOfSequences ( m - 1 , n ) + getTotalNumberOfSequences ( m / 2 , n - 1 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function longCommomAnagramSubseq ( str1 , str2 , n1 , n2 ) { let freq1 = new Array ( SIZE ) ; let freq2 = new Array ( SIZE ) ; for ( let i = 0 ; i < SIZE ; i ++ ) { freq1 [ i ] = 0 ; freq2 [ i ] = 0 ; } let len = 0 ; for ( let i = 0 ; i < n1 ; i ++ ) freq1 [ str1 [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; for ( let i = 0 ; i < n2 ; i ++ ) freq2 [ str2 [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; for ( let i = 0 ; i < SIZE ; i ++ ) len += Math . min ( freq1 [ i ] , freq2 [ i ] ) ; return len ; }
Ref: 
int longCommomAnagramSubseq ( char str1 [ ] , char str2 [ ] , int n1 , int n2 ) { int freq1 [ SIZE ] , freq2 [ SIZE ] ; memset ( freq1 , 0 , sizeof ( freq1 ) ) ; memset ( freq2 , 0 , sizeof ( freq2 ) ) ; int len = 0 ; for ( int i = 0 ; i < n1 ; i ++ ) freq1 [ str1 [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < n2 ; i ++ ) freq2 [ str2 [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < SIZE ; i ++ ) len += min ( freq1 [ i ] , freq2 [ i ] ) ; return len ; }
Hyp: 
int longCommomAnagramSubseq ( string str1 , string str2 , int n1 , int n2 ) { int freq1 [ SIZE ] , freq2 [ SIZE ] ; for ( int i = 0 ; i < SIZE ; i ++ ) freq1 [ i ] = 0 ; freq2 [ i ] = 0 ; int len = 0 ; for ( int i = 0 ; i < n1 ; i ++ ) freq1 [ str1 [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < n2 ; i ++ ) freq2 [ str2 [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < SIZE ; i ++ ) len += min ( freq1 [ i ] , freq2 [ i ] ) ; return len ; }

BLEU: 78.28
Edit Sim: 73


Src: 
function countTriplets ( N ) { let ans = 0 ; for ( let i = 1 ; i <= N ; i ++ ) { for ( let j = 1 ; j <= N ; j ++ ) { if ( i * j > N ) break ; ans += Math . floor ( N / ( i * j ) ) ; } } return ans ; }
Ref: 
int countTriplets ( int N ) { int ans = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 1 ; j <= N ; j ++ ) { if ( i * j > N ) break ; ans += N / ( i * j ) ; } } return ans ; }
Hyp: 
int countTriplets ( int N ) { int ans = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 1 ; j <= N ; j ++ ) { if ( i * j > N ) break ; ans += N / ( i * j ) ; } } return ans ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function minOperations ( S ) { var count = 0 ; for ( var i = 1 ; i < S . length ; i ++ ) { if ( S [ i ] !== S [ i - 1 ] ) { count += 1 ; } } document . write ( count ) ; }
Ref: 
int minOperations ( string & S ) { int count = 0 ; for ( int i = 1 ; i < S . length ( ) ; i ++ ) { if ( S [ i ] != S [ i - 1 ] ) { count += 1 ; } } cout << count ; }
Hyp: 
void minOperations ( string S ) { int count = 0 ; for ( int i = 1 ; i < S . size ( ) ; i ++ ) { if ( S [ i ] != S [ i - 1 ] ) { count += 1 ; } } cout << count ; }

BLEU: 89.39
Edit Sim: 12


Src: 
function triangleArea ( a , b ) { ratio = b / a document . write ( ratio ) }
Ref: 
void triangleArea ( int a , int b ) { double ratio = ( double ) b / a ; cout << ratio ; }
Hyp: 
void triangleArea ( int a , int b ) { ratio = b / a ; cout << ratio ; }

BLEU: 70.64
Edit Sim: 18


Src: 
function isPower ( N , K ) { var res1 = Math . floor ( Math . log ( N ) / Math . log ( K ) ) ; var res2 = Math . log ( N ) / Math . log ( K ) ; return ( res1 == res2 ) ; } var N = 8 ; var K = 2 ; if ( isPower ( N , K ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
Ref: 
bool isPower ( int N , int K ) { int res1 = log ( N ) / log ( K ) ; double res2 = log ( N ) / log ( K ) ; return ( res1 == res2 ) ; }
Hyp: 
bool isPower ( int N , int K ) { int res1 = floor ( log ( N ) / log ( K ) ) ; int res2 = log ( N ) / log ( K ) ; return ( res1 == res2 ) ; }

BLEU: 83.49
Edit Sim: 15


Src: 
function findPieces ( n ) { return ( n * ( n + 1 ) ) / 2 + 1 ; }
Ref: 
int findPieces ( int n ) { return ( n * ( n + 1 ) ) / 2 + 1 ; }
Hyp: 
int findPieces ( int n ) { return ( n * ( n + 1 ) ) / 2 + 1 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function Minimum ( N , K ) { let sum = N * ( N + 1 ) / 2 ; if ( K > sum ) return - 1 ; if ( K <= N ) return 1 ; sum = 0 ; let count = 0 ; while ( N >= 1 && sum < K ) { count += 1 ; sum += N ; N -= 1 ; } return count ; }
Ref: 
int Minimum ( int N , int K ) { int sum = N * ( N + 1 ) / 2 ; if ( K > sum ) return -1 ; if ( K <= N ) return 1 ; sum = 0 ; int count = 0 ; while ( N >= 1 && sum < K ) { count += 1 ; sum += N ; N -= 1 ; } return count ; }
Hyp: 
int Minimum ( int N , int K ) { int sum = N * ( N + 1 ) / 2 ; if ( K > sum ) return -1 ; if ( K <= N ) return 1 ; sum = 0 ; int count = 0 ; while ( N >= 1 && sum < K ) { count += 1 ; sum += N ; N -= 1 ; } return count ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countCompositions ( n ) { return 1 << ( n - 1 ) ; }
Ref: 
ull countCompositions ( ull n ) { return ( 1L ) << ( n - 1 ) ; }
Hyp: 
int countCompositions ( unsigned int n ) { return 1 << ( n - 1 ) ; }

BLEU: 55.9
Edit Sim: 19


Src: 
function bin ( n ) { let i ; document . write ( " " ) ; for ( i = 1 << 30 ; i > 0 ; i = Math . floor ( i / 2 ) ) { if ( ( n & i ) != 0 ) { document . write ( " " ) ; } else { document . write ( " " ) ; } } }
Ref: 
void bin ( long n ) { long i ; cout << "0" ; for ( i = 1 << 30 ; i > 0 ; i = i / 2 ) { if ( ( n & i ) != 0 ) { cout << "1" ; } else { cout << "0" ; } } }
Hyp: 
void bin ( int n ) { int i ; cout << "7" ; for ( i = 1 << 30 ; i > 0 ; i /= 2 ) { if ( ( n & i ) != 0 ) { cout << "1" ; } else { cout << "0" ; } } }

BLEU: 78.52
Edit Sim: 12


Src: 
function nthDigit ( a , n , b ) { for ( var i = 1 ; i < n ; i ++ ) a = parseInt ( a / b ) ; return a % b ; }
Ref: 
int nthDigit ( int a , int n , int b ) { for ( int i = 1 ; i < n ; i ++ ) a = a / b ; return a % b ; }
Hyp: 
int nthDigit ( int a , int n , int b ) { for ( int i = 1 ; i < n ; i ++ ) a = a / b ; return a % b ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findSum ( N ) { return ( 2 * N * ( N + 1 ) * ( 4 * N + 17 ) + 54 * N ) / 6 ; }
Ref: 
int findSum ( int N ) { return ( 2 * N * ( N + 1 ) * ( 4 * N + 17 ) + 54 * N ) / 6 ; }
Hyp: 
int findSum ( int N ) { return ( 2 * N * ( N + 1 ) * ( 4 * N + 17 ) + 54 * N ) / 6 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function first ( a , b , c ) { a %= b ; for ( let i = 1 ; i <= b ; i ++ ) { a = a * 10 ; if ( a / b == c ) return i ; a %= b ; } return - 1 ; }
Ref: 
int first ( int a , int b , int c ) { a %= b ; for ( int i = 1 ; i <= b ; i ++ ) { a = a * 10 ; if ( a / b == c ) return i ; a %= b ; } return -1 ; }
Hyp: 
int first ( int a , int b , int c ) { a %= b ; for ( int i = 1 ; i <= b ; i ++ ) { a = a * 10 ; if ( a / b == c ) return i ; a %= b ; } return -1 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findPairCount ( N , K ) { var count = 0 ; var rem = Array . from ( { length : K } , ( _ , i ) => 0 ) ; rem [ 0 ] = parseInt ( N / K ) ; for ( i = 1 ; i < K ; i ++ ) rem [ i ] = parseInt ( ( N - i ) / K + 1 ) ; if ( K % 2 == 0 ) { count += parseInt ( ( rem [ 0 ] * ( rem [ 0 ] - 1 ) ) / 2 ) ; for ( i = 1 ; i < K / 2 ; i ++ ) count += rem [ i ] * rem [ K - i ] ; count += ( rem [ K / 2 ] * ( rem [ K / 2 ] - 1 ) ) / 2 ; } else { count += ( rem [ 0 ] * ( rem [ 0 ] - 1 ) ) / 2 ; for ( i = 1 ; i <= K / 2 ; i ++ ) count += rem [ i ] * rem [ K - i ] ; } return count ; }
Ref: 
int findPairCount ( int N , int K ) { int count = 0 ; int rem [ K ] ; rem [ 0 ] = N / K ; for ( int i = 1 ; i < K ; i ++ ) rem [ i ] = ( N - i ) / K + 1 ; if ( K % 2 == 0 ) { count += ( rem [ 0 ] * ( rem [ 0 ] - 1 ) ) / 2 ; for ( int i = 1 ; i < K / 2 ; i ++ ) count += rem [ i ] * rem [ K - i ] ; count += ( rem [ K / 2 ] * ( rem [ K / 2 ] - 1 ) ) / 2 ; } else { count += ( rem [ 0 ] * ( rem [ 0 ] - 1 ) ) / 2 ; for ( int i = 1 ; i <= K / 2 ; i ++ ) count += rem [ i ] * rem [ K - i ] ; } return count ; }
Hyp: 
int findPairCount ( int N , int K ) { int count = 0 ; int rem [ K ] ; memset ( rem , 0 , sizeof rem ) ; rem [ 0 ] = N / K ; for ( int i = 1 ; i < K ; i ++ ) rem [ i ] = ( N - i ) / K + 1 ; if ( K % 2 == 0 ) { count += ( rem [ 0 ] * ( rem [ 0 ] - 1 ) ) / 2 ; for ( int i = 1 ; i < K / 2 ; i ++ ) count += rem [ i ] * rem [ K - i ] ; count += ( rem [ K / 2 ] * ( rem [ K / 2 ] - 1 ) ) / 2 ; } else { count += ( rem [ 0 ] * ( rem [ 0 ] - 1 ) ) / 2 ; for ( int i = 1 ; i <= K / 2 ; i ++ ) count += rem [ i ] * rem [ K - i ] ; } return count ; }

BLEU: 94.87
Edit Sim: 34


Src: 
function check ( arr , n ) { var i , g ; g = 0 ; for ( i = 1 ; i < n ; i ++ ) { if ( arr [ i ] - arr [ i - 1 ] > 0 && g == 1 ) return false ; if ( arr [ i ] - arr [ i - 1 ] < 0 ) g = 1 ; } return true ; }
Ref: 
bool check ( int arr [ ] , int n ) { int i , g ; g = 0 ; for ( i = 1 ; i < n ; i ++ ) { if ( arr [ i ] - arr [ i - 1 ] > 0 && g == 1 ) return false ; if ( arr [ i ] - arr [ i - 1 ] < 0 ) g = 1 ; } return true ; }
Hyp: 
bool check ( int arr [ ] , int n ) { int i , g ; g = 0 ; for ( i = 1 ; i < n ; i ++ ) { if ( arr [ i ] - arr [ i - 1 ] > 0 && g == 1 ) return false ; if ( arr [ i ] - arr [ i - 1 ] < 0 ) g = 1 ; } return true ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function calculateSum ( n ) { return 2 * ( Math . pow ( n , 6 ) + 15 * Math . pow ( n , 4 ) + 15 * Math . pow ( n , 2 ) + 1 ) ; }
Ref: 
float calculateSum ( float n ) { int a = int ( n ) ; return 2 * ( pow ( n , 6 ) + 15 * pow ( n , 4 ) + 15 * pow ( n , 2 ) + 1 ) ; }
Hyp: 
int calculateSum ( int n ) { return 2 * ( pow ( n , 6 ) + 15 * pow ( n , 4 ) + 15 * pow ( n , 2 ) + 1 ) ; }

BLEU: 72.69
Edit Sim: 27


Src: 
function countDecreasing ( A , n ) { var len = 1 ; for ( var i = 0 ; i < n - 1 ; ++ i ) { if ( A [ i + 1 ] < A [ i ] ) len ++ ; else { cnt += parseInt ( ( ( len - 1 ) * len ) / 2 ) ; len = 1 ; } } if ( len > 1 ) cnt += parseInt ( ( ( len - 1 ) * len ) / 2 ) ; return cnt ; }
Ref: 
int countDecreasing ( int A [ ] , int n ) { int len = 1 ; for ( int i = 0 ; i < n - 1 ; ++ i ) { if ( A [ i + 1 ] < A [ i ] ) len ++ ; else { cnt += ( ( ( len - 1 ) * len ) / 2 ) ; len = 1 ; } } if ( len > 1 ) cnt += ( ( ( len - 1 ) * len ) / 2 ) ; return cnt ; }
Hyp: 
int countDecreasing ( int A [ ] , int n ) { int len = 1 ; for ( int i = 0 ; i < n - 1 ; ++ i ) { if ( A [ i + 1 ] < A [ i ] ) len ++ ; else { cnt += ( ( len - 1 ) * len ) / 2 ; len = 1 ; } } if ( len > 1 ) cnt += ( ( len - 1 ) * len ) / 2 ; return cnt ; }

BLEU: 92.4
Edit Sim: 8


Src: 
function findX ( A , B ) { var X = 0 ; var MAX = 32 ; for ( var bit = 0 ; bit < MAX ; bit ++ ) { var tempBit = 1 << bit ; var bitOfX = A & B & tempBit ; X += bitOfX ; } return X ; }
Ref: 
int findX ( int A , int B ) { int X = 0 ; for ( int bit = 0 ; bit < MAX ; bit ++ ) { int tempBit = 1 << bit ; int bitOfX = A & B & tempBit ; X += bitOfX ; } return X ; }
Hyp: 
int findX ( int A , int B ) { int X = 0 ; int MAX = 32 ; for ( int bit = 0 ; bit < MAX ; bit ++ ) { int tempBit = 1 << bit ; int bitOfX = A & B & tempBit ; X += bitOfX ; } return X ; }

BLEU: 90.29
Edit Sim: 15


Src: 
function countTriplets ( arr , n , a , b ) { var ans = 0 ; for ( var i = 0 ; i < n - 2 ; i ++ ) { for ( var j = i + 1 ; j < n - 1 ; j ++ ) { for ( var k = j + 1 ; k < n ; k ++ ) if ( arr [ i ] + arr [ j ] + arr [ k ] >= a && arr [ i ] + arr [ j ] + arr [ k ] <= b ) ans ++ ; } } return ans ; }
Ref: 
int countTriplets ( int arr [ ] , int n , int a , int b ) { int ans = 0 ; for ( int i = 0 ; i < n - 2 ; i ++ ) { for ( int j = i + 1 ; j < n - 1 ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) if ( arr [ i ] + arr [ j ] + arr [ k ] >= a && arr [ i ] + arr [ j ] + arr [ k ] <= b ) ans ++ ; } } return ans ; }
Hyp: 
int countTriplets ( int arr [ ] , int n , int a , int b ) { int ans = 0 ; for ( int i = 0 ; i < n - 2 ; i ++ ) { for ( int j = i + 1 ; j < n - 1 ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) if ( arr [ i ] + arr [ j ] + arr [ k ] >= a && arr [ i ] + arr [ j ] + arr [ k ] <= b ) ans ++ ; } } return ans ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function constructArr ( arr , pair , n ) { arr [ 0 ] = Math . floor ( ( pair [ 0 ] + pair [ 1 ] - pair [ n - 1 ] ) / 2 ) ; for ( let i = 1 ; i < n ; i ++ ) arr [ i ] = pair [ i - 1 ] - arr [ 0 ] ; }
Ref: 
void constructArr ( int arr [ ] , int pair [ ] , int n ) { arr [ 0 ] = ( pair [ 0 ] + pair [ 1 ] - pair [ n - 1 ] ) / 2 ; for ( int i = 1 ; i < n ; i ++ ) arr [ i ] = pair [ i - 1 ] - arr [ 0 ] ; }
Hyp: 
void constructArr ( int arr [ ] , int pair [ ] , int n ) { arr [ 0 ] = ( pair [ 0 ] + pair [ 1 ] - pair [ n - 1 ] ) / 2 ; for ( int i = 1 ; i < n ; i ++ ) arr [ i ] = pair [ i - 1 ] - arr [ 0 ] ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function checking ( s ) { let c = 0 ; let n = s . length ; for ( let i = n - 1 ; i >= 0 ; i -- ) { if ( s [ i ] == ' ' ) c ++ ; if ( c >= 6 && s [ i ] == ' ' ) return true ; } return false ; }
Ref: 
bool checking ( string s ) { int c = 0 ; int n = s . length ( ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( s [ i ] == '0' ) c ++ ; if ( c >= 6 and s [ i ] == '1' ) return true ; } return false ; }
Hyp: 
bool checking ( string s ) { int c = 0 ; int n = s . length ( ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( s [ i ] == ' a ' ) c ++ ; if ( c >= 6 && s [ i ] == ' e ' ) return true ; } return false ; }

BLEU: 84.36
Edit Sim: 9


Src: 
function maxXOR ( n , k ) { let c = ( Math . log ( n ) / Math . log ( 2 ) ) + 1 ; return ( ( 1 << c ) - 1 ) ; }
Ref: 
int maxXOR ( int n , int k ) { int c = log2 ( n ) + 1 ; return ( ( 1 << c ) - 1 ) ; }
Hyp: 
int maxXOR ( int n , int k ) { int c = ( log2 ( n ) ) + 1 ; return ( ( 1 << c ) - 1 ) ; }

BLEU: 86.88
Edit Sim: 4


Src: 
function findNumbers ( N ) { let i = 1 ; while ( i <= N ) { document . write ( ( i * i * i ) + " " ) ; i ++ ; } }
Ref: 
void findNumbers ( int N ) { int i = 1 ; while ( i <= N ) { cout << ( i * i * i ) << " ▁ " ; i ++ ; } }
Hyp: 
void findNumbers ( int N ) { int i = 1 ; while ( i <= N ) { cout << i * i * i << " ▁ " ; i ++ ; } }

BLEU: 86.18
Edit Sim: 4


Src: 
function maxLCM ( n ) { return ( n * ( n - 1 ) ) ; }
Ref: 
int maxLCM ( int n ) { return ( n * ( n - 1 ) ) ; }
Hyp: 
int maxLCM ( int n ) { return ( n * ( n - 1 ) ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function SumofInverseDivisors ( N , Sum ) { let ans = ( Sum ) * 1.0 / ( N ) ; return ans ; }
Ref: 
double SumofInverseDivisors ( int N , int Sum ) { double ans = ( double ) ( Sum ) * 1.0 / ( double ) ( N ) ; return ans ; }
Hyp: 
double SumofInverseDivisors ( int N , int Sum ) { double ans = ( Sum ) * 1.0 / ( N ) ; return ans ; }

BLEU: 75.14
Edit Sim: 22


Src: 
function atleastkDistinctChars ( s , k ) { let n = s . length ; let mp = new Map ( ) ; let begin = 0 , end = 0 ; let ans = 0 ; while ( end < n ) { let c = s [ end ] ; if ( mp . has ( c ) ) mp . set ( c , mp . get ( c ) + 1 ) ; else mp . set ( c , 1 ) ; end ++ ; while ( mp . size >= k ) { let pre = s [ begin ] ; mp . set ( pre , mp . get ( pre ) - 1 ) ; if ( mp . get ( pre ) == 0 ) { mp . delete ( pre ) ; } ans += s . length - end + 1 ; begin ++ ; } } document . write ( ans ) ; }
Ref: 
void atleastkDistinctChars ( string s , int k ) { int n = s . size ( ) ; unordered_map < char , int > mp ; int begin = 0 , end = 0 ; int ans = 0 ; while ( end < n ) { char c = s [ end ] ; mp ++ ; end ++ ; while ( mp . size ( ) >= k ) { char pre = s [ begin ] ; mp [ pre ] -- ; if ( mp [ pre ] == 0 ) { mp . erase ( pre ) ; } ans += s . length ( ) - end + 1 ; begin ++ ; } } cout << ans ; }
Hyp: 
void atleastkDistinctChars ( string s , int k ) { int n = s . length ( ) ; unordered_map < char , int > mp ; int begin = 0 , end = 0 ; int ans = 0 ; while ( end < n ) { char c = s [ end ] ; mp [ c ] ++ ; else mp [ c ] = 1 ; end ++ ; while ( mp . find ( c ) != mp . end ( ) ) { char pre = s [ begin ] ; mp [ pre ] -- ; if ( mp [ pre ] == 0 ) { mp . delete ( pre ) ; } ans += s . length ( ) - end + 1 ; begin ++ ; } } cout << ans ; }

BLEU: 79.68
Edit Sim: 54


Src: 
function getMissingNo ( a ) { let n = a . length ; let i , total = 1 ; for ( i = 2 ; i <= ( n + 1 ) ; i ++ ) { total += i ; total -= a [ i - 2 ] ; } return total ; }
Ref: 
int getMissingNo ( int a [ ] , int n ) { int i , total = 1 ; for ( i = 2 ; i <= ( n + 1 ) ; i ++ ) { total += i ; total -= a [ i - 2 ] ; } return total ; }
Hyp: 
int getMissingNo ( int a [ ] ) { int n = sizeof ( a [ 0 ] ) ; int i , total = 1 ; for ( i = 2 ; i <= ( n + 1 ) ; i ++ ) { total += i ; total -= a [ i - 2 ] ; } return total ; }

BLEU: 79.78
Edit Sim: 23


Src: 
function FindMaxS ( X , Y , Z , n , A , B , C ) { if ( X < 0 Y < 0 Z < 0 ) return Number . MIN_VALUE ; if ( n < 0 ) return 0 ; if ( dp [ n ] [ X ] [ Y ] [ Z ] != - 1 ) { return dp [ n ] [ X ] [ Y ] [ Z ] ; } let ch = A [ n ] + FindMaxS ( X - 1 , Y , Z , n - 1 , A , B , C ) ; let ca = B [ n ] + FindMaxS ( X , Y - 1 , Z , n - 1 , A , B , C ) ; let co = C [ n ] + FindMaxS ( X , Y , Z - 1 , n - 1 , A , B , C ) ; let no = FindMaxS ( X , Y , Z , n - 1 , A , B , C ) ; let maximum = Math . max ( ch , Math . max ( ca , Math . max ( co , no ) ) ) ; dp [ n ] [ X ] [ Y ] [ Z ] = maximum ; return dp [ n ] [ X ] [ Y ] [ Z ] ; } let X = 1 ; let Y = 1 ; let Z = 1 ; let A = [ 10 , 0 , 5 ] ; let B = [ 5 , 10 , 0 ] ; let C = [ 0 , 5 , 10 ] ; let n = B . length ; for ( let i = 0 ; i < 50 ; i ++ ) { dp [ i ] = new Array ( 50 ) ; for ( let j = 0 ; j < 50 ; j ++ ) { dp [ i ] [ j ] = new Array ( 50 ) ; for ( let k = 0 ; k < 50 ; k ++ ) { dp [ i ] [ j ] [ k ] = new Array ( 50 ) ; for ( let l = 0 ; l < 50 ; l ++ ) { dp [ i ] [ j ] [ k ] [ l ] = - 1 ; } } } }
Ref: 
int FindMaxS ( int X , int Y , int Z , int n , vector < int > & A , vector < int > & B , vector < int > & C ) { if ( X < 0 or Y < 0 or Z < 0 ) return INT_MIN ; if ( n < 0 ) return 0 ; if ( dp [ n ] [ X ] [ Y ] [ Z ] != -1 ) { return dp [ n ] [ X ] [ Y ] [ Z ] ; } int ch = A [ n ] + FindMaxS ( X - 1 , Y , Z , n - 1 , A , B , C ) ; int ca = B [ n ] + FindMaxS ( X , Y - 1 , Z , n - 1 , A , B , C ) ; int co = C [ n ] + FindMaxS ( X , Y , Z - 1 , n - 1 , A , B , C ) ; int no = FindMaxS ( X , Y , Z , n - 1 , A , B , C ) ; int maximum = max ( ch , max ( ca , max ( co , no ) ) ) ; return dp [ n ] [ X ] [ Y ] [ Z ] = maximum ; }
Hyp: 
int FindMaxS ( int X , int Y , int Z , int n , int A [ ] [ Y ] [ Z ] , int B [ ] [ C ] ) { if ( X < 0 Y < 0 Z < 0 ) return INT_MIN ; if ( n < 0 ) return 0 ; if ( dp [ n ] [ X ] [ Y ] [ Z ] != -1 ) return dp [ n ] [ X ] [ Y ] [ Z ] ; int ch = A [ n ] + FindMaxS ( X - 1 , Y , Z , n - 1 , A , B , C ) ; int ca = B [ n ] + FindMaxS ( X , Y - 1 , Z , n - 1 , A , B , C ) ; int co = C [ n ] + FindMaxS ( X , Y , Z - 1 , n - 1 , A , B , C ) ; int no = FindMaxS ( X , Y , Z , n - 1 , A , B , C ) ; int maximum = max ( ch , max ( ca , max ( co , no ) ) ) ; dp [ n ] [ X ] [ Y ] [ Z ] = maximum ; return dp [ n ] [ X ] [ Y ] [ Z ] ; }

BLEU: 84.57
Edit Sim: 92


Src: 
function maxOfSegmentMins ( a , n , k ) { if ( k == 1 ) { a . sort ( ) ; return a [ 0 ] ; } if ( k == 2 ) return Math . max ( a [ 0 ] , a [ n - 1 ] ) ; return a [ n - 1 ] ; }
Ref: 
int maxOfSegmentMins ( int a [ ] , int n , int k ) { if ( k == 1 ) return * min_element ( a , a + n ) ; if ( k == 2 ) return max ( a [ 0 ] , a [ n - 1 ] ) ; return * max_element ( a , a + n ) ; }
Hyp: 
int maxOfSegmentMins ( int a [ ] , int n , int k ) { if ( k == 1 ) { sort ( a , a + n ) ; return a [ 0 ] ; } if ( k == 2 ) return max ( a [ 0 ] , a [ n - 1 ] ) ; return a [ n - 1 ] ; }

BLEU: 72.92
Edit Sim: 50


Src: 
function isDivisible ( n ) { let d ; while ( Math . floor ( n / 100 ) > 0 ) { d = n % 10 ; n = Math . floor ( n / 10 ) ; n = Math . abs ( n - ( d * 14 ) ) ; } return ( n % 47 == 0 ) ; }
Ref: 
bool isDivisible ( int n ) { int d ; while ( n / 100 ) { d = n % 10 ; n /= 10 ; n = abs ( n - ( d * 14 ) ) ; } return ( n % 47 == 0 ) ; }
Hyp: 
bool isDivisible ( int n ) { int d ; while ( n / 100 > 0 ) { d = n % 10 ; n = n / 10 ; n = abs ( n - ( d * 14 ) ) ; } return ( n % 47 == 0 ) ; }

BLEU: 85.12
Edit Sim: 9


Src: 
function find_angle ( x , y , z ) { var volume = x * x * y ; var ans = 0 ; if ( z < volume / 2 ) { var d = ( ( x * y * y ) / ( 2.0 * z ) ) ; ans = Math . atan ( d ) ; } else { z = volume - z ; var d = ( 2 * z ) / ( x * x * x ) ; ans = Math . atan ( d ) ; } ans = ( ( ans * 180 ) / 3.14159265 ) ; return ans ; }
Ref: 
float find_angle ( int x , int y , int z ) { int volume = x * x * y ; float ans = 0 ; if ( z < volume / 2 ) { float d = ( x * y * y ) / ( 2.0 * z ) ; ans = atan ( d ) ; } else { z = volume - z ; float d = ( 2 * z ) / ( float ) ( x * x * x ) ; ans = atan ( d ) ; } ans = ( ans * 180 ) / 3.14159265 ; return ans ; }
Hyp: 
double find_angle ( double x , double y , double z ) { double volume = x * x * y ; double ans = 0 ; if ( z < volume / 2 ) { double d = ( ( x * y * y ) / ( 2.0 * z ) ) ; ans = atan ( d ) ; } else { z = volume - z ; double d = ( 2 * z ) / ( x * x * x ) ; ans = atan ( d ) ; } ans = ( ( ans * 180 ) / 3.14159265 ) ; return ans ; }

BLEU: 76.04
Edit Sim: 66


Src: 
function lenOfLongSubarr ( arr , n ) { var um = new Map ( ) ; var sum = 0 , maxLen = 0 ; for ( var i = 0 ; i < n ; i ++ ) { sum += arr [ i ] == 0 ? - 1 : 1 ; if ( sum == 1 ) maxLen = i + 1 ; else if ( ! um . has ( sum ) ) um . set ( sum , i ) ; if ( um . has ( sum - 1 ) ) { if ( maxLen < ( i - um . get ( sum - 1 ) ) ) maxLen = i - um . get ( sum - 1 ) ; } } return maxLen ; }
Ref: 
int lenOfLongSubarr ( int arr [ ] , int n ) { unordered_map < int , int > um ; int sum = 0 , maxLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] == 0 ? -1 : 1 ; if ( sum == 1 ) maxLen = i + 1 ; else if ( um . find ( sum ) == um . end ( ) ) um [ sum ] = i ; if ( um . find ( sum - 1 ) != um . end ( ) ) { if ( maxLen < ( i - um [ sum - 1 ] ) ) maxLen = i - um [ sum - 1 ] ; } } return maxLen ; }
Hyp: 
int lenOfLongSubarr ( int arr [ ] , int n ) { unordered_map < int , int > um ; int sum = 0 , maxLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] == 0 ? -1 : 1 ; if ( sum == 1 ) maxLen = i + 1 ; else if ( um . find ( sum ) == um . end ( ) ) um [ sum ] = i ; if ( um . find ( sum - 1 ) != um . end ( ) ) maxLen = i - um [ sum - 1 ] ; } return maxLen ; }

BLEU: 86.57
Edit Sim: 43


Src: 
function seiresSum ( n , a ) { return n * ( a [ 0 ] * a [ 0 ] - a [ 2 * n - 1 ] * a [ 2 * n - 1 ] ) / ( 2 * n - 1 ) ; }
Ref: 
int seiresSum ( int n , int a [ ] ) { return n * ( a [ 0 ] * a [ 0 ] - a [ 2 * n - 1 ] * a [ 2 * n - 1 ] ) / ( 2 * n - 1 ) ; }
Hyp: 
int seiresSum ( int n , int a [ ] ) { return n * ( a [ 0 ] * a [ 0 ] - a [ 2 * n - 1 ] * a [ 2 * n - 1 ] ) / ( 2 * n - 1 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function printGP ( a , r , n ) { let curr_term ; for ( let i = 0 ; i < n ; i ++ ) { curr_term = a * Math . pow ( r , i ) ; document . write ( curr_term + " " ) ; } }
Ref: 
void printGP ( int a , int r , int n ) { int curr_term ; for ( int i = 0 ; i < n ; i ++ ) { curr_term = a * pow ( r , i ) ; cout << curr_term << " ▁ " ; } }
Hyp: 
void printGP ( int a , int r , int n ) { int curr_term ; for ( int i = 0 ; i < n ; i ++ ) { curr_term = a * pow ( r , i ) ; cout << curr_term << " ▁ " ; } }

BLEU: 100.0
Edit Sim: 0


Src: 
function findMinValue ( arr , n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; return ( parseInt ( sum / n ) + 1 ) ; }
Ref: 
int findMinValue ( int arr [ ] , int n ) { long sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; return ( ( sum / n ) + 1 ) ; }
Hyp: 
int findMinValue ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; return ( sum / n + 1 ) ; }

BLEU: 85.94
Edit Sim: 7


Src: 
function findPoint ( x1 , y1 , x2 , y2 ) { document . write ( " " + 2 * ( x2 - x1 ) + " " + 2 * ( y2 - y1 ) + " " ) ; }
Ref: 
void findPoint ( int x1 , int y1 , int x2 , int y2 ) { cout << " ( " << 2 * x2 - x1 << " , ▁ " << 2 * y2 - y1 << " ) " ; }
Hyp: 
void findPoint ( int x1 , int y1 , int x2 , int y2 ) { cout << " ( " << 2 * ( x2 - x1 ) << " , ▁ " << 2 * ( y2 - y1 ) << " ) " << endl ; }

BLEU: 72.11
Edit Sim: 16


Src: 
function smallest ( x , y , z ) { if ( ! ( y / x ) ) return ( ! ( y / z ) ) ? y : z ; return ( ! ( x / z ) ) ? x : z ; }
Ref: 
int smallest ( int x , int y , int z ) { if ( ! ( y / x ) ) return ( ! ( y / z ) ) ? y : z ; return ( ! ( x / z ) ) ? x : z ; }
Hyp: 
int smallest ( int x , int y , int z ) { if ( ! ( y / x ) ) return ( ! ( y / z ) ) ? y : z ; return ( ! ( x / z ) ) ? x : z ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countTriplets ( A , N ) { let ans = 0 ; let map = new Map ( ) ; for ( let j = N - 2 ; j >= 1 ; j -- ) { if ( map . has ( A [ j + 1 ] ) ) map . set ( A [ j + 1 ] , map . get ( A [ j + 1 ] ) + 1 ) ; else map . set ( A [ j + 1 ] , 1 ) ; for ( let i = 0 ; i < j ; i ++ ) { let target = A [ i ] * A [ j ] ; if ( map . has ( target ) ) ans += map . get ( target ) ; } } return ans ; }
Ref: 
int countTriplets ( int A [ ] , int N ) { int ans = 0 ; map < int , int > map ; for ( int j = N - 2 ; j >= 1 ; j -- ) { map [ A [ j + 1 ] ] ++ ; for ( int i = 0 ; i < j ; i ++ ) { int target = A [ i ] * A [ j ] ; if ( map . find ( target ) != map . end ( ) ) ans += map [ target ] ; } } return ans ; }
Hyp: 
int countTriplets ( int A [ ] , int N ) { int ans = 0 ; unordered_map < int , int > mp ; for ( int j = N - 2 ; j >= 1 ; j -- ) { map [ A [ j + 1 ] ] ++ ; else mp [ A [ j + 1 ] ] = 1 ; for ( int i = 0 ; i < j ; i ++ ) { int target = A [ i ] * A [ j ] ; if ( mp . find ( target ) != mp . end ( ) ) ans += mp [ target ] ; } } return ans ; }

BLEU: 78.15
Edit Sim: 44


Src: 
function UpperHessenbergMatrix ( n ) { for ( var i = 1 ; i <= n ; i ++ ) { for ( var j = 1 ; j <= n ; j ++ ) { if ( i > j + 1 ) document . write ( ' ' + " " ) ; else document . write ( Math . floor ( Math . random ( ) * 10 ) + " " ) ; } document . write ( " " ) ; } }
Ref: 
void UpperHessenbergMatrix ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( i > j + 1 ) cout << '0' << " ▁ " ; else cout << rand ( ) % 10 << " ▁ " ; } cout << " STRNEWLINE " ; } }
Hyp: 
void UpperHessenbergMatrix ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( i > j + 1 ) cout << '0' << " ▁ " ; else cout << floor ( random ( ) * 10 ) << " ▁ " ; } cout << " STRNEWLINE " ; } }

BLEU: 88.94
Edit Sim: 13


Src: 
function CalculateMax ( arr , n ) { arr . sort ( function ( a , b ) { return a - b } ) ; let min_sum = arr [ 0 ] + arr [ 1 ] ; let max_sum = arr [ n - 1 ] + arr [ n - 2 ] ; return ( Math . abs ( max_sum - min_sum ) ) ; }
Ref: 
ll CalculateMax ( ll arr [ ] , int n ) { sort ( arr , arr + n ) ; int min_sum = arr [ 0 ] + arr [ 1 ] ; int max_sum = arr [ n - 1 ] + arr [ n - 2 ] ; return abs ( max_sum - min_sum ) ; }
Hyp: 
int CalculateMax ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int min_sum = arr [ 0 ] + arr [ 1 ] ; int max_sum = arr [ n - 1 ] + arr [ n - 2 ] ; return abs ( max_sum - min_sum ) ; }

BLEU: 94.5
Edit Sim: 6


Src: 
function gonNum360 ( n ) { return ( 358 * n * n - 356 * n ) / 2 ; }
Ref: 
int gonNum360 ( int n ) { return ( 358 * n * n - 356 * n ) / 2 ; }
Hyp: 
int gonNum360 ( int n ) { return ( 358 * n * n - 356 * n ) / 2 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function divide ( dividend , divisor ) { var sign = ( ( dividend < 0 ) ? 1 : 0 ^ ( divisor < 0 ) ? 1 : 0 ) ? - 1 : 1 ; dividend = Math . abs ( dividend ) ; divisor = Math . abs ( divisor ) ; var quotient = 0 , temp = 0 ; while ( dividend >= divisor ) { dividend -= divisor ; ++ quotient ; } if ( sign == - 1 ) quotient = - quotient ; return quotient ; }
Ref: 
int divide ( long long dividend , long long divisor ) { int sign = ( ( dividend < 0 ) ^ ( divisor < 0 ) ) ? -1 : 1 ; dividend = abs ( dividend ) ; divisor = abs ( divisor ) ; long long quotient = 0 , temp = 0 ; for ( int i = 31 ; i >= 0 ; -- i ) { if ( temp + ( divisor << i ) <= dividend ) { temp += divisor << i ; quotient |= 1LL << i ; } } if ( sign == -1 ) quotient = - quotient ; return quotient ; }
Hyp: 
int divide ( int dividend , int divisor ) { int sign = ( ( dividend < 0 ) ? 1 : 0 ^ ( divisor < 0 ) ? 1 : 0 ) ? -1 : 1 ; dividend = abs ( dividend ) ; divisor = abs ( divisor ) ; int quotient = 0 , temp = 0 ; while ( dividend >= divisor ) { dividend -= divisor ; ++ quotient ; } if ( sign == -1 ) quotient = - quotient ; return quotient ; }

BLEU: 51.94
Edit Sim: 119


Src: 
function findMinLength ( arr ) { let index = parseInt ( arr . length ) - 1 ; while ( index > 0 && arr [ index ] >= arr [ index - 1 ] ) { index -- ; } return index ; }
Ref: 
int findMinLength ( vector < int > & arr ) { int index = ( int ) arr . size ( ) - 1 ; while ( index > 0 && arr [ index ] >= arr [ index - 1 ] ) { index -- ; } return index ; }
Hyp: 
int findMinLength ( int arr [ ] , int n ) { int index = n - 1 ; while ( index > 0 && arr [ index ] >= arr [ index - 1 ] ) { index -- ; } return index ; }

BLEU: 67.96
Edit Sim: 37


Src: 
function checkTriangle ( x , y , z ) { if ( x == y && y == z ) document . write ( " " ) ; else if ( x == y y == z z == x ) document . write ( " " ) ; else document . write ( " " ) ; }
Ref: 
void checkTriangle ( int x , int y , int z ) { if ( x == y && y == z ) cout << " Equilateral ▁ Triangle " ; else if ( x == y y == z z == x ) cout << " Isosceles ▁ Triangle " ; else cout << " Scalene ▁ Triangle " ; }
Hyp: 
void checkTriangle ( int x , int y , int z ) { if ( x == y && y == z ) cout << " Yes " ; else if ( x == y y == z z == x ) cout << " No " ; else cout << " Yes " ; }

BLEU: 77.38
Edit Sim: 57


Src: 
function printMultiples ( N ) { for ( let i = 1 ; i <= N ; i ++ ) { for ( let j = 1 ; j <= i ; j ++ ) { document . write ( ( i * j ) + " " ) ; } document . write ( " " ) ; } }
Ref: 
void printMultiples ( int N ) { for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) { cout << ( i * j ) << " ▁ " ; } cout << endl ; } }
Hyp: 
void printMultiples ( int N ) { for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) { cout << ( i * j ) << " ▁ " ; } cout << endl ; } }

BLEU: 100.0
Edit Sim: 0


Src: 
function isSurd ( n ) { for ( let i = 2 ; i * i <= n ; i ++ ) { let j = i ; while ( j < n ) j = j * i ; if ( j == n ) return false ; } return true ; }
Ref: 
bool isSurd ( int n ) { for ( int i = 2 ; i * i <= n ; i ++ ) { int j = i ; while ( j < n ) j = j * i ; if ( j == n ) return false ; } return true ; }
Hyp: 
bool isSurd ( int n ) { for ( int i = 2 ; i * i <= n ; i ++ ) { int j = i ; while ( j < n ) j = j * i ; if ( j == n ) return false ; } return true ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countNonDecreasing ( n ) { let dp = new Array ( 10 ) ; for ( let i = 0 ; i < 10 ; i ++ ) { dp [ i ] = new Array ( n + 1 ) ; } for ( let i = 0 ; i < 10 ; i ++ ) { for ( let j = 0 ; j < n + 1 ; j ++ ) { dp [ i ] [ j ] = 0 ; } } for ( let i = 0 ; i < 10 ; i ++ ) dp [ i ] [ 1 ] = 1 ; for ( let digit = 0 ; digit <= 9 ; digit ++ ) { for ( let len = 2 ; len <= n ; len ++ ) { for ( let x = 0 ; x <= digit ; x ++ ) dp [ digit ] [ len ] += dp [ x ] [ len - 1 ] ; } } let count = 0 ; for ( let i = 0 ; i < 10 ; i ++ ) count += dp [ i ] [ n ] ; return count ; }
Ref: 
int countNonDecreasing ( int n ) { long long int dp [ 10 ] [ n + 1 ] ; memset ( dp , 0 , sizeof dp ) ; for ( int i = 0 ; i < 10 ; i ++ ) dp [ i ] [ 1 ] = 1 ; for ( int digit = 0 ; digit <= 9 ; digit ++ ) { for ( int len = 2 ; len <= n ; len ++ ) { for ( int x = 0 ; x <= digit ; x ++ ) dp [ digit ] [ len ] += dp [ x ] [ len - 1 ] ; } } long long int count = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) count += dp [ i ] [ n ] ; return count ; }
Hyp: 
int countNonDecreasing ( int n ) { int dp [ 10 ] [ n + 1 ] ; for ( int i = 0 ; i < 10 ; i ++ ) dp [ i ] [ 1 ] = 1 ; for ( int digit = 0 ; digit <= 9 ; digit ++ ) { for ( int len = 2 ; len <= n ; len ++ ) { for ( int x = 0 ; x <= digit ; x ++ ) dp [ digit ] [ len ] += dp [ x ] [ len - 1 ] ; } } int count = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) count += dp [ i ] [ n ] ; return count ; }

BLEU: 87.93
Edit Sim: 52


Src: 
function findMin ( arr , n ) { let ans = 1 ; for ( let i = 0 ; i < n ; i ++ ) { let j = i + 1 ; while ( j < n && arr [ j ] >= arr [ j - 1 ] ) j ++ ; ans = Math . max ( ans , j - i ) ; i = j - 1 ; } return n - ans ; }
Ref: 
int findMin ( int * arr , int n ) { int ans = 1 ; for ( int i = 0 ; i < n ; i ++ ) { int j = i + 1 ; while ( j < n and arr [ j ] > = arr [ j - 1 ] ) j ++ ; ans = max ( ans , j - i ) ; i = j - 1 ; } return n - ans ; }
Hyp: 
int findMin ( int arr [ ] , int n ) { int ans = 1 ; for ( int i = 0 ; i < n ; i ++ ) { int j = i + 1 ; while ( j < n and arr [ j ] > = arr [ j - 1 ] ) j ++ ; ans = max ( ans , j - i ) ; i = j - 1 ; } return n - ans ; }

BLEU: 94.93
Edit Sim: 6


Src: 
function divide ( n , m ) { document . write ( " " + ( ( n ) & ( m - 1 ) ) + " " ) ; document . write ( " " + ( n >> ( Math . log ( m ) / Math . log ( 2 ) ) ) ) ; }
Ref: 
void divide ( int n , int m ) { cout << " Remainder ▁ = ▁ " << ( ( n ) & ( m - 1 ) ) ; cout << " Quotient = " }
Hyp: 
void divide ( unsigned int n , unsigned int m ) { cout << " ▁ " << ( ( n ) & ( m - 1 ) ) << " ▁ " ; cout << " ▁ " << ( n >> ( log2 ( m ) / log2 ( 2 ) ) ) ; }

BLEU: 44.04
Edit Sim: 83


Src: 
function highestPowerof2 ( n ) { let res = 0 ; for ( let i = n ; i >= 1 ; i -- ) { if ( ( i & ( i - 1 ) ) == 0 ) { res = i ; break ; } } return res ; }
Ref: 
int highestPowerof2 ( int n ) { int res = 0 ; for ( int i = n ; i >= 1 ; i -- ) { if ( ( i & ( i - 1 ) ) == 0 ) { res = i ; break ; } } return res ; }
Hyp: 
int highestPowerof2 ( int n ) { int res = 0 ; for ( int i = n ; i >= 1 ; i -- ) { if ( ( i & ( i - 1 ) ) == 0 ) { res = i ; break ; } } return res ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function largestPalinSub ( s ) { let res = " " ; let mx = s [ 0 ] ; for ( let i = 1 ; i < s . length ; i ++ ) mx = String . fromCharCode ( Math . max ( mx . charCodeAt ( ) , s [ i ] . charCodeAt ( ) ) ) ; for ( let i = 0 ; i < s . length ; i ++ ) if ( s [ i ] == mx ) res += s [ i ] ; return res ; }
Ref: 
string largestPalinSub ( string s ) { string res ; char mx = s [ 0 ] ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) mx = max ( mx , s [ i ] ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) if ( s [ i ] == mx ) res += s [ i ] ; return res ; }
Hyp: 
string largestPalinSub ( string s ) { string res = " " ; char mx = s [ 0 ] ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) mx = max ( mx , s [ i ] ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) if ( s [ i ] == mx ) res += s [ i ] ; return res ; }

BLEU: 94.89
Edit Sim: 6


Src: 
function printTwoOdd ( arr , size ) { let xor2 = arr [ 0 ] ; let set_bit_no ; let i ; int n = size - 2 ; let x = 0 , y = 0 ; for ( i = 1 ; i < size ; i ++ ) xor2 = xor2 ^ arr [ i ] ; set_bit_no = xor2 & ~ ( xor2 - 1 ) ; for ( i = 0 ; i < size ; i ++ ) { if ( ( arr [ i ] & set_bit_no ) > 0 ) x = x ^ arr [ i ] ; else y = y ^ arr [ i ] ; } document . write ( " " + x + " " + y + " " ) ; }
Ref: 
void printTwoOdd ( int arr [ ] , int size ) { int xor2 = arr [ 0 ] ; int set_bit_no ; int i ; int n = size - 2 ; int x = 0 , y = 0 ; for ( i = 1 ; i < size ; i ++ ) xor2 = xor2 ^ arr [ i ] ; set_bit_no = xor2 & ~ ( xor2 - 1 ) ; for ( i = 0 ; i < size ; i ++ ) { if ( arr [ i ] & set_bit_no ) x = x ^ arr [ i ] ; else y = y ^ arr [ i ] ; } cout << " The ▁ two ▁ ODD ▁ elements ▁ are ▁ " << x << " ▁ & ▁ " << y ; }
Hyp: 
void printTwoOdd ( int arr [ ] , int size ) { int xor2 = arr [ 0 ] ; int set_bit_no ; int i ; int n = size - 2 ; int x = 0 , y = 0 ; for ( i = 1 ; i < size ; i ++ ) xor2 = xor2 ^ arr [ i ] ; set_bit_no = xor2 & ~ ( xor2 - 1 ) ; for ( i = 0 ; i < size ; i ++ ) { if ( arr [ i ] & set_bit_no ) x = x ^ arr [ i ] ; else y = y ^ arr [ i ] ; } cout << " The ▁ odd ▁ pair ▁ is ▁ ( " << x << " , ▁ " << y << " ) " ; }

BLEU: 89.28
Edit Sim: 30


Src: 
function sumOfParts ( arr , N ) { var sum_part1 = 0 , sum_part2 = 0 , sum_part3 = 0 , sum_part4 = 0 ; var totalsum = 0 ; for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < N ; j ++ ) { if ( i + j < N - 1 ) { if ( i < j && i != j && i + j > 0 ) sum_part1 += arr [ i ] [ j ] ; else if ( i != j ) sum_part2 += arr [ i ] [ j ] ; } else { if ( i > j && i + j != N - 1 ) sum_part3 += arr [ i ] [ j ] ; else { if ( i + j != N - 1 && i != j ) sum_part4 += arr [ i ] [ j ] ; } } } } totalsum = sum_part1 + sum_part2 + sum_part3 + sum_part4 ; return totalsum ; }
Ref: 
int sumOfParts ( int * arr , int N ) { int sum_part1 = 0 , sum_part2 = 0 , sum_part3 = 0 , sum_part4 = 0 ; int totalsum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( i + j < N - 1 ) { if ( i < j and i != j and i + j ) sum_part1 += ( arr + i * N ) [ j ] ; else if ( i != j ) sum_part2 += ( arr + i * N ) [ j ] ; } else { if ( i > j and i + j != N - 1 ) sum_part3 += ( arr + i * N ) [ j ] ; else { if ( i + j != N - 1 and i != j ) sum_part4 += ( arr + i * N ) [ j ] ; } } } } totalsum = sum_part1 + sum_part2 + sum_part3 + sum_part4 ; return totalsum ; }
Hyp: 
int sumOfParts ( int arr [ ] [ MAX ] , int N ) { int sum_part1 = 0 , sum_part2 = 0 , sum_part3 = 0 , sum_part4 = 0 ; int totalsum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( i + j < N - 1 ) { if ( i < j && i != j && i + j > 0 ) sum_part1 += arr [ i ] [ j ] ; else if ( i != j ) sum_part2 += arr [ i ] [ j ] ; } else { if ( i > j && i + j != N - 1 ) sum_part3 += arr [ i ] [ j ] ; else { if ( i + j != N - 1 && i != j ) sum_part4 += arr [ i ] [ j ] ; } } } } totalsum = sum_part1 + sum_part2 + sum_part3 + sum_part4 ; return totalsum ; }

BLEU: 75.9
Edit Sim: 62


Src: 
function countNonDecreasing ( n ) { let N = 10 ; let count = 1 ; for ( let i = 1 ; i <= n ; i ++ ) { count *= ( N + i - 1 ) ; count = Math . floor ( count / i ) ; } return count ; }
Ref: 
int countNonDecreasing ( int n ) { int N = 10 ; long long count = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { count *= ( N + i - 1 ) ; count /= i ; } return count ; }
Hyp: 
int countNonDecreasing ( int n ) { int N = 10 ; int count = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { count *= ( N + i - 1 ) ; count = count / i ; } return count ; }

BLEU: 86.45
Edit Sim: 17


Src: 
function dodecahedral_num ( n ) { return n * ( 3 * n - 1 ) * ( 3 * n - 2 ) / 2 ; }
Ref: 
int dodecahedral_num ( int n ) { return n * ( 3 * n - 1 ) * ( 3 * n - 2 ) / 2 ; }
Hyp: 
int dodecahedral_num ( int n ) { return n * ( 3 * n - 1 ) * ( 3 * n - 2 ) / 2 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function freq ( ar , m , n ) { let even = 0 , odd = 0 ; for ( let i = 0 ; i < m ; ++ i ) { for ( let j = 0 ; j < n ; ++ j ) { if ( ( ar [ i ] [ j ] % 2 ) == 0 ) ++ even ; else ++ odd ; } } document . write ( " " + odd + " " ) ; document . write ( " " + even + " " ) ; }
Ref: 
void freq ( int ar [ ] [ MAX ] , int m , int n ) { int even = 0 , odd = 0 ; for ( int i = 0 ; i < m ; ++ i ) { for ( int j = 0 ; j < n ; ++ j ) { if ( ( ar [ i ] [ j ] % 2 ) == 0 ) ++ even ; else ++ odd ; } } printf ( " ▁ Frequency ▁ of ▁ odd ▁ number ▁ = ▁ % d ▁ STRNEWLINE " , odd ) ; printf ( " ▁ Frequency ▁ of ▁ even ▁ number ▁ = ▁ % d ▁ STRNEWLINE " , even ) ; }
Hyp: 
void freq ( int ar [ ] [ MAX ] , int m , int n ) { int even = 0 , odd = 0 ; for ( int i = 0 ; i < m ; ++ i ) { for ( int j = 0 ; j < n ; ++ j ) { if ( ( ar [ i ] [ j ] % 2 ) == 0 ) ++ even ; else ++ odd ; } } cout << " Even ▁ = ▁ " << odd << " STRNEWLINE " ; cout << " Odd ▁ = ▁ " << even << endl ; }

BLEU: 67.11
Edit Sim: 105


Src: 
function isDivisible ( str , k ) { let n = str . length ; let c = 0 ; for ( let i = 0 ; i < k ; i ++ ) if ( str [ n - i - 1 ] == ' ' ) c ++ ; return ( c == k ) ; }
Ref: 
bool isDivisible ( char str [ ] , int k ) { int n = strlen ( str ) ; int c = 0 ; for ( int i = 0 ; i < k ; i ++ ) if ( str [ n - i - 1 ] == '0' ) c ++ ; return ( c == k ) ; }
Hyp: 
bool isDivisible ( string str , int k ) { int n = str . length ( ) ; int c = 0 ; for ( int i = 0 ; i < k ; i ++ ) if ( str [ n - i - 1 ] == '0' ) c ++ ; return ( c == k ) ; }

BLEU: 84.92
Edit Sim: 19


Src: 
function avg_of_even_num ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) sum += 2 * i ; return sum / n ; }
Ref: 
int avg_of_even_num ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += 2 * i ; return sum / n ; }
Hyp: 
int avg_of_even_num ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += 2 * i ; return sum / n ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function uniqueCharacters ( str ) { let checker = 0 ; for ( let i = 0 ; i < str . length ; i ++ ) { let bitAtIndex = str [ i ] - ' ' ; if ( ( checker & ( 1 << bitAtIndex ) ) > 0 ) { return false ; } checker = checker | ( 1 << bitAtIndex ) ; } return true ; } let input = " " ; if ( uniqueCharacters ( input ) ) { document . write ( " " + input + " " ) ; } else { document . write ( " " + input + " " ) ; }
Ref: 
bool uniqueCharacters ( string str ) { int checker = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { int bitAtIndex = str [ i ] - ' a ' ; if ( ( checker & ( 1 << bitAtIndex ) ) > 0 ) { return false ; } checker = checker | ( 1 << bitAtIndex ) ; } return true ; }
Hyp: 
bool uniqueCharacters ( string str ) { int checker = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { int bitAtIndex = str [ i ] - ' a ' ; if ( ( checker & ( 1 << bitAtIndex ) ) > 0 ) { return false ; } checker = checker | ( 1 << bitAtIndex ) ; } return true ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function printClosest ( arr , n , x ) { let res_l = 0 , res_r = 0 ; let l = 0 , r = n - 1 , diff = Number . MAX_VALUE ; while ( r > l ) { if ( Math . abs ( arr [ l ] + arr [ r ] - x ) < diff ) { res_l = l ; res_r = r ; diff = Math . abs ( arr [ l ] + arr [ r ] - x ) ; } if ( arr [ l ] + arr [ r ] > x ) r -- ; else l ++ ; } document . write ( " " + arr [ res_l ] + " " + arr [ res_r ] ) ; }
Ref: 
void printClosest ( int arr [ ] , int n , int x ) { int res_l , res_r ; int l = 0 , r = n - 1 , diff = INT_MAX ; while ( r > l ) { if ( abs ( arr [ l ] + arr [ r ] - x ) < diff ) { res_l = l ; res_r = r ; diff = abs ( arr [ l ] + arr [ r ] - x ) ; } if ( arr [ l ] + arr [ r ] > x ) r -- ; else l ++ ; } cout << " ▁ The ▁ closest ▁ pair ▁ is ▁ " << arr [ res_l ] << " ▁ and ▁ " << arr [ res_r ] ; }
Hyp: 
void printClosest ( int arr [ ] , int n , int x ) { int res_l = 0 , res_r = 0 ; int l = 0 , r = n - 1 , diff = INT_MAX ; while ( r > l ) { if ( abs ( arr [ l ] + arr [ r ] - x ) < diff ) { res_l = l ; res_r = r ; diff = abs ( arr [ l ] + arr [ r ] - x ) ; } if ( arr [ l ] + arr [ r ] > x ) r -- ; else l ++ ; } cout << " The ▁ closest ▁ pair ▁ is ▁ [ " << arr [ res_l ] << " , ▁ " << arr [ res_r ] ; }

BLEU: 90.66
Edit Sim: 17


Src: 
function checkCentrosymmetricted ( n , m ) { let mid_row ; if ( n & 1 ) mid_row = Math . floor ( n / 2 ) + 1 ; else mid_row = n / 2 ; for ( let i = 0 ; i < mid_row ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { if ( m [ i ] [ j ] != m [ n - i - 1 ] [ n - j - 1 ] ) return false ; } } return true ; }
Ref: 
bool checkCentrosymmetricted ( int n , int m [ N ] [ N ] ) { int mid_row ; if ( n & 1 ) mid_row = n / 2 + 1 ; else mid_row = n / 2 ; for ( int i = 0 ; i < mid_row ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( m [ i ] [ j ] != m [ n - i - 1 ] [ n - j - 1 ] ) return false ; } } return true ; }
Hyp: 
bool checkCentrosymmetricted ( int n , int m [ ] [ MAX ] ) { int mid_row ; if ( n & 1 ) mid_row = n / 2 + 1 ; else mid_row = n / 2 ; for ( int i = 0 ; i < mid_row ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( m [ i ] [ j ] != m [ n - i - 1 ] [ n - j - 1 ] ) return false ; } } return true ; }

BLEU: 95.42
Edit Sim: 5


Src: 
function isDivBy2PowerM ( n , m ) { if ( ( n & ( ( 1 << m ) - 1 ) ) == 0 ) return true ; return false ; }
Ref: 
bool isDivBy2PowerM ( unsigned int n , unsigned int m ) { if ( ( n & ( ( 1 << m ) - 1 ) ) == 0 ) return true ; return false ; }
Hyp: 
bool isDivBy2PowerM ( int n , int m ) { if ( ( n & ( 1 << m ) - 1 ) ) return true ; return false ; }

BLEU: 68.95
Edit Sim: 27


Src: 
function findSum ( arr , n , k ) { var ans = arr [ n - k - 1 ] - arr [ 0 ] ; for ( var i = 1 ; i <= k ; i ++ ) { ans = Math . min ( arr [ n - 1 - ( k - i ) ] - arr [ i ] , ans ) ; } return ans ; }
Ref: 
int findSum ( int * arr , int n , int k ) { int ans = arr [ n - k - 1 ] - arr [ 0 ] ; for ( int i = 1 ; i <= k ; i ++ ) { ans = min ( arr [ n - 1 - ( k - i ) ] - arr [ i ] , ans ) ; } return ans ; }
Hyp: 
int findSum ( int arr [ ] , int n , int k ) { int ans = arr [ n - k - 1 ] - arr [ 0 ] ; for ( int i = 1 ; i <= k ; i ++ ) { ans = min ( arr [ n - 1 - ( k - i ) ] - arr [ i ] , ans ) ; } return ans ; }

BLEU: 94.39
Edit Sim: 6


Src: 
function maximumDifferenceSum ( arr , N ) { let dp = new Array ( N ) ; for ( let i = 0 ; i < N ; i ++ ) { dp [ i ] = new Array ( 2 ) ; for ( let j = 0 ; j < 2 ; j ++ ) { dp [ i ] [ j ] = 0 ; } } for ( let i = 0 ; i < N ; i ++ ) dp [ i ] [ 0 ] = dp [ i ] [ 1 ] = 0 ; for ( let i = 0 ; i < ( N - 1 ) ; i ++ ) { dp [ i + 1 ] [ 0 ] = Math . max ( dp [ i ] [ 0 ] , dp [ i ] [ 1 ] + Math . abs ( 1 - arr [ i ] ) ) ; dp [ i + 1 ] [ 1 ] = Math . max ( dp [ i ] [ 0 ] + Math . abs ( arr [ i + 1 ] - 1 ) , dp [ i ] [ 1 ] + Math . abs ( arr [ i + 1 ] - arr [ i ] ) ) ; } return Math . max ( dp [ N - 1 ] [ 0 ] , dp [ N - 1 ] [ 1 ] ) ; }
Ref: 
int maximumDifferenceSum ( int arr [ ] , int N ) { int dp [ N ] [ 2 ] ; for ( int i = 0 ; i < N ; i ++ ) dp [ i ] [ 0 ] = dp [ i ] [ 1 ] = 0 ; for ( int i = 0 ; i < ( N - 1 ) ; i ++ ) { dp [ i + 1 ] [ 0 ] = max ( dp [ i ] [ 0 ] , dp [ i ] [ 1 ] + abs ( 1 - arr [ i ] ) ) ; dp [ i + 1 ] [ 1 ] = max ( dp [ i ] [ 0 ] + abs ( arr [ i + 1 ] - 1 ) , dp [ i ] [ 1 ] + abs ( arr [ i + 1 ] - arr [ i ] ) ) ; } return max ( dp [ N - 1 ] [ 0 ] , dp [ N - 1 ] [ 1 ] ) ; }
Hyp: 
int maximumDifferenceSum ( int arr [ ] , int N ) { int dp [ N + 1 ] [ 2 ] ; for ( int i = 0 ; i < N ; i ++ ) dp [ i ] [ 0 ] = dp [ i ] [ 1 ] = 0 ; for ( int i = 0 ; i < ( N - 1 ) ; i ++ ) { dp [ i + 1 ] [ 0 ] = max ( dp [ i ] [ 0 ] , dp [ i ] [ 1 ] + abs ( 1 - arr [ i ] ) ) ; dp [ i + 1 ] [ 1 ] = max ( dp [ i ] [ 0 ] + abs ( arr [ i + 1 ] - 1 ) , dp [ i ] [ 1 ] + abs ( arr [ i + 1 ] - arr [ i ] ) ) ; } return max ( dp [ N - 1 ] [ 0 ] , dp [ N - 1 ] [ 1 ] ) ; }

BLEU: 98.2
Edit Sim: 4


Src: 
function shuffleArray ( a , n ) { for ( let i = 0 , q = 1 , k = n ; i < n ; i ++ , k ++ , q ++ ) for ( let j = k ; j > i + q ; j -- ) { let temp = a [ j - 1 ] ; a [ j - 1 ] = a [ j ] ; a [ j ] = temp ; } }
Ref: 
void shuffleArray ( int a [ ] , int n ) { for ( int i = 0 , q = 1 , k = n ; i < n ; i ++ , k ++ , q ++ ) for ( int j = k ; j > i + q ; j -- ) swap ( a [ j - 1 ] , a [ j ] ) ; }
Hyp: 
void shuffleArray ( int a [ ] , int n ) { for ( int i = 0 , q = 1 , k = n ; i < n ; i ++ , k ++ , q ++ ) for ( int j = k ; j > i + q ; j -- ) { int temp = a [ j - 1 ] ; a [ j - 1 ] = a [ j ] ; a [ j ] = temp ; } }

BLEU: 72.14
Edit Sim: 43


Src: 
function findGreatest ( arr , n ) { let result = - 1 ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = 0 ; j < n - 1 ; j ++ ) for ( let k = j + 1 ; k < n ; k ++ ) if ( arr [ j ] * arr [ k ] == arr [ i ] ) result = Math . max ( result , arr [ i ] ) ; return result ; }
Ref: 
int findGreatest ( int arr [ ] , int n ) { int result = -1 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n - 1 ; j ++ ) for ( int k = j + 1 ; k < n ; k ++ ) if ( arr [ j ] * arr [ k ] == arr [ i ] ) result = max ( result , arr [ i ] ) ; return result ; }
Hyp: 
int findGreatest ( int arr [ ] , int n ) { int result = -1 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n - 1 ; j ++ ) for ( int k = j + 1 ; k < n ; k ++ ) if ( arr [ j ] * arr [ k ] == arr [ i ] ) result = max ( result , arr [ i ] ) ; return result ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function dealnnoy ( n , m ) { if ( m == 0 n == 0 ) return 1 ; return dealnnoy ( m - 1 , n ) + dealnnoy ( m - 1 , n - 1 ) + dealnnoy ( m , n - 1 ) ; }
Ref: 
int dealnnoy ( int n , int m ) { if ( m == 0 n == 0 ) return 1 ; return dealnnoy ( m - 1 , n ) + dealnnoy ( m - 1 , n - 1 ) + dealnnoy ( m , n - 1 ) ; }
Hyp: 
int dealnnoy ( int n , int m ) { if ( m == 0 n == 0 ) return 1 ; return dealnnoy ( m - 1 , n ) + dealnnoy ( m - 1 , n - 1 ) + dealnnoy ( m , n - 1 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countStr ( N ) { var dp = Array . from ( Array ( N + 1 ) , ( ) => Array ( 3 ) . fill ( 0 ) ) ; dp [ 1 ] [ 0 ] = 1 ; dp [ 1 ] [ 1 ] = 1 ; dp [ 1 ] [ 2 ] = 0 ; for ( var i = 2 ; i <= N ; i ++ ) { dp [ i ] [ 0 ] = ( dp [ i - 1 ] [ 0 ] + dp [ i - 1 ] [ 1 ] + dp [ i - 1 ] [ 2 ] ) % MOD ; dp [ i ] [ 1 ] = dp [ i - 1 ] [ 0 ] % MOD ; dp [ i ] [ 2 ] = dp [ i - 1 ] [ 1 ] % MOD ; } var ans = ( dp [ N ] [ 0 ] + dp [ N ] [ 1 ] + dp [ N ] [ 2 ] ) % MOD ; return ans ; }
Ref: 
long countStr ( long N ) { long dp [ N + 1 ] [ 3 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; dp [ 1 ] [ 0 ] = 1 ; dp [ 1 ] [ 1 ] = 1 ; dp [ 1 ] [ 2 ] = 0 ; for ( int i = 2 ; i <= N ; i ++ ) { dp [ i ] [ 0 ] = ( dp [ i - 1 ] [ 0 ] + dp [ i - 1 ] [ 1 ] + dp [ i - 1 ] [ 2 ] ) % MOD ; dp [ i ] [ 1 ] = dp [ i - 1 ] [ 0 ] % MOD ; dp [ i ] [ 2 ] = dp [ i - 1 ] [ 1 ] % MOD ; } long ans = ( dp [ N ] [ 0 ] + dp [ N ] [ 1 ] + dp [ N ] [ 2 ] ) % MOD ; return ans ; }
Hyp: 
int countStr ( int N ) { vector < vector < int > > dp ( N + 1 , vector < int > ( 3 , 0 ) ) ; dp [ 1 ] [ 0 ] = 1 ; dp [ 1 ] [ 1 ] = 1 ; dp [ 1 ] [ 2 ] = 0 ; for ( int i = 2 ; i <= N ; i ++ ) { dp [ i ] [ 0 ] = ( dp [ i - 1 ] [ 0 ] + dp [ i - 1 ] [ 1 ] + dp [ i - 1 ] [ 2 ] ) % MOD ; dp [ i ] [ 1 ] = dp [ i - 1 ] [ 0 ] % MOD ; dp [ i ] [ 2 ] = dp [ i - 1 ] [ 1 ] % MOD ; } int ans = ( dp [ N ] [ 0 ] + dp [ N ] [ 1 ] + dp [ N ] [ 2 ] ) % MOD ; return ans ; }

BLEU: 87.12
Edit Sim: 55


Src: 
function checksum ( n ) { if ( n % 5 == 0 ) document . write ( ( n / 5 - 2 ) + " " + ( n / 5 - 1 ) + " " + ( n / 5 ) + " " + ( n / 5 + 1 ) + " " + ( n / 5 + 2 ) ) ; else document . write ( " " ) ; }
Ref: 
void checksum ( int n ) { if ( n % 5 == 0 ) cout << n / 5 - 2 << " ▁ " << n / 5 - 1 << " ▁ " << n / 5 << " ▁ " << n / 5 + 1 << " ▁ " << n / 5 + 2 ; else cout << " - 1" ; }
Hyp: 
void checksum ( int n ) { if ( n % 5 == 0 ) cout << ( n / 5 - 2 ) << " ▁ " << n / 5 - 1 << " ▁ " << n / 5 << " ▁ " << n / 5 + 1 << " ▁ " << n / 5 + 2 ; else cout << " - 1" ; }

BLEU: 92.8
Edit Sim: 4


Src: 
function solve ( N , M ) { var ans = ( N ) * parseInt ( ( M / 2 ) ) ; if ( M % 2 == 1 ) { ans += parseInt ( ( N + 1 ) / 2 ) ; } document . write ( ans ) ; }
Ref: 
void solve ( int N , int M ) { ll ans = ( N ) * ( M / 2 ) ; if ( M % 2 == 1 ) { ans += ( N + 1 ) / 2 ; } cout << ans << endl ; }
Hyp: 
void solve ( int N , int M ) { int ans = ( N ) * ( M / 2 ) ; if ( M % 2 == 1 ) { ans += ( N + 1 ) / 2 ; } cout << ans ; }

BLEU: 88.16
Edit Sim: 11


Src: 
function countAnomalies ( arr , n , k ) { var cnt = 0 ; var i , sum = 0 ; for ( i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; for ( i = 0 ; i < n ; i ++ ) if ( Math . abs ( arr [ i ] - ( sum - arr [ i ] ) ) > k ) cnt ++ ; return cnt ; }
Ref: 
int countAnomalies ( int arr [ ] , int n , int k ) { int cnt = 0 ; int i , sum = 0 ; for ( i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; for ( i = 0 ; i < n ; i ++ ) if ( abs ( arr [ i ] - ( sum - arr [ i ] ) ) > k ) cnt ++ ; return cnt ; }
Hyp: 
int countAnomalies ( int arr [ ] , int n , int k ) { int cnt = 0 ; int i , sum = 0 ; for ( i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; for ( i = 0 ; i < n ; i ++ ) if ( abs ( arr [ i ] - ( sum - arr [ i ] ) ) > k ) cnt ++ ; return cnt ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function decimalToBinary ( n ) { if ( n == 0 ) { document . write ( " " ) ; return ; } decimalToBinary ( parseInt ( n / 2 ) ) ; document . write ( n % 2 ) ; }
Ref: 
void decimalToBinary ( int n ) { if ( n == 0 ) { cout << "0" ; return ; } decimalToBinary ( n / 2 ) ; cout << n % 2 ; }
Hyp: 
void decimalToBinary ( int n ) { if ( n == 0 ) { cout << "0" ; return ; } decimalToBinary ( n / 2 ) ; cout << n % 2 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function removeDuplicatesFromString ( string ) { let counter = 0 ; let str = string . split ( " " ) ; let i = 0 ; let size = str . length ; let x ; let length = 0 ; while ( i < size ) { x = str [ i ] . charCodeAt ( 0 ) - 97 ; if ( ( counter & ( 1 << x ) ) == 0 ) { str [ length ] = String . fromCharCode ( ' ' . charCodeAt ( 0 ) + x ) ; counter = counter | ( 1 << x ) ; length ++ ; } i ++ ; } return str . join ( " " ) . slice ( 0 , length ) ; }
Ref: 
string removeDuplicatesFromString ( string str ) { int counter = 0 ; int i = 0 ; int size = str . size ( ) ; int x ; int length = 0 ; while ( i < size ) { x = str [ i ] - 97 ; if ( ( counter & ( 1 << x ) ) == 0 ) { str [ length ] = ' a ' + x ; counter = counter | ( 1 << x ) ; length ++ ; } i ++ ; } return str . substr ( 0 , length ) ; }
Hyp: 
string removeDuplicatesFromString ( string str ) { int counter = 0 ; int size = str . length ( ) ; int i = 0 ; int size = str . length ( ) ; int x ; int length = 0 ; while ( i < size ) { x = str [ i ] - 97 ; if ( ( counter & ( 1 << x ) ) == 0 ) { str [ length ] = char ( ' A ' + x ) ; counter = counter | ( 1 << x ) ; length ++ ; } i ++ ; } return str . substr ( 0 , length ) ; }

BLEU: 83.35
Edit Sim: 46


Src: 
function digit_product_Sum ( N ) { var a = [ ... Array ( N ) ] ; var product = 1 ; a [ 0 ] = 1 ; for ( var i = 1 ; i <= N ; i ++ ) { product = parseInt ( a [ i - 1 ] / 10 ) ; if ( product == 0 ) product = 1 ; else product = a [ i - 1 ] % 10 ; var val = parseInt ( a [ i - 1 ] / 10 ) ; if ( val == 0 ) val = a [ i - 1 ] ; a [ i ] = a [ i - 1 ] + val * product ; } for ( var i = 0 ; i < N ; i ++ ) document . write ( a [ i ] + " " ) ; }
Ref: 
void digit_product_Sum ( int N ) { int a [ N ] ; int product = 1 ; a [ 0 ] = 1 ; for ( int i = 1 ; i <= N ; i ++ ) { product = a [ i - 1 ] / 10 ; if ( product == 0 ) product = 1 ; else product = a [ i - 1 ] % 10 ; int val = a [ i - 1 ] / 10 ; if ( val == 0 ) val = a [ i - 1 ] ; a [ i ] = a [ i - 1 ] + ( val * product ) ; } for ( int i = 0 ; i < N ; i ++ ) cout << a [ i ] << " ▁ " ; }
Hyp: 
void digit_product_Sum ( int N ) { int a [ N ] ; int product = 1 ; a [ 0 ] = 1 ; for ( int i = 1 ; i <= N ; i ++ ) { product = a [ i - 1 ] / 10 ; if ( product == 0 ) product = 1 ; else product = a [ i - 1 ] % 10 ; int val = a [ i - 1 ] / 10 ; if ( val == 0 ) val = a [ i - 1 ] ; a [ i ] = a [ i - 1 ] + val * product ; } for ( int i = 0 ; i < N ; i ++ ) cout << a [ i ] << " ▁ " ; }

BLEU: 96.51
Edit Sim: 4


Src: 
function findM ( N ) { var M = 0 ; var MSB = parseInt ( Math . log ( N ) ) ; for ( i = 0 ; i < MSB ; i ++ ) { if ( ( N & ( 1 << i ) ) == 0 ) M += ( 1 << i ) ; } return M ; }
Ref: 
int findM ( int N ) { int M = 0 ; int MSB = ( int ) log2 ( N ) ; for ( int i = 0 ; i < MSB ; i ++ ) { if ( ! ( N & ( 1 << i ) ) ) M += ( 1 << i ) ; } return M ; }
Hyp: 
int findM ( int N ) { int M = 0 ; int MSB = log2 ( N ) ; for ( int i = 0 ; i < MSB ; i ++ ) { if ( ( N & ( 1 << i ) ) == 0 ) M += ( 1 << i ) ; } return M ; }

BLEU: 86.32
Edit Sim: 15


Src: 
function printNGE ( arr , n ) { var next , i , j ; for ( i = 0 ; i < n ; i ++ ) { next = - 1 ; for ( j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] < arr [ j ] ) { next = arr [ j ] ; break ; } } document . write ( arr [ i ] + " " + next ) ; document . write ( " " ) ; } }
Ref: 
void printNGE ( int arr [ ] , int n ) { int next , i , j ; for ( i = 0 ; i < n ; i ++ ) { next = -1 ; for ( j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] < arr [ j ] ) { next = arr [ j ] ; break ; } } cout << arr [ i ] << " ▁ - - ▁ " << next << endl ; } }
Hyp: 
void printNGE ( int arr [ ] , int n ) { int next , i , j ; for ( i = 0 ; i < n ; i ++ ) { next = -1 ; for ( j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] < arr [ j ] ) { next = arr [ j ] ; break ; } } cout << arr [ i ] << " , ▁ " << next ; cout << endl ; } }

BLEU: 93.72
Edit Sim: 12


Src: 
function evenDecimalValue ( str , n ) { var result = 0 ; for ( var i = 0 ; i < n ; i ++ ) { for ( var j = i ; j < n ; j ++ ) { var decimalValue = 0 ; var powerOf2 = 1 ; for ( var k = i ; k <= j ; k ++ ) { decimalValue += ( ( str [ k ] - ' ' ) * powerOf2 ) ; powerOf2 *= 2 ; } if ( decimalValue % 2 == 0 ) result ++ ; } } return result ; }
Ref: 
int evenDecimalValue ( string str , int n ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { int decimalValue = 0 ; int powerOf2 = 1 ; for ( int k = i ; k <= j ; k ++ ) { decimalValue += ( ( str [ k ] - '0' ) * powerOf2 ) ; powerOf2 *= 2 ; } if ( decimalValue % 2 == 0 ) result ++ ; } } return result ; }
Hyp: 
int evenDecimalValue ( string str , int n ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { int decimalValue = 0 ; int powerOf2 = 1 ; for ( int k = i ; k <= j ; k ++ ) { decimalValue += ( ( str [ k ] - '0' ) * powerOf2 ) ; powerOf2 *= 2 ; } if ( decimalValue % 2 == 0 ) result ++ ; } } return result ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function checkArray ( n , k , arr ) { var cnt = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] & 1 ) != 0 ) cnt += 1 ; } if ( cnt >= k && cnt % 2 == k % 2 ) return true ; else return false ; }
Ref: 
bool checkArray ( int n , int k , int arr [ ] ) { int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] & 1 ) cnt += 1 ; } if ( cnt >= k && cnt % 2 == k % 2 ) return true ; else return false ; }
Hyp: 
bool checkArray ( int n , int k , int arr [ ] ) { int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] & 1 ) cnt += 1 ; } if ( cnt >= k && cnt % 2 == k % 2 ) return true ; else return false ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function idstrt ( a1 , b1 , c1 , a2 , b2 , c2 ) { if ( ( a1 / a2 == b1 / b2 ) && ( a1 / a2 == c1 / c2 ) && ( b1 / b2 == c1 / c2 ) ) document . write ( " " + " " ) ; else document . write ( " " + " " ) ; }
Ref: 
void idstrt ( double a1 , double b1 , double c1 , double a2 , double b2 , double c2 ) { if ( ( a1 / a2 == b1 / b2 ) && ( a1 / a2 == c1 / c2 ) && ( b1 / b2 == c1 / c2 ) ) cout << " The ▁ given ▁ straight " << " ▁ lines ▁ are ▁ identical " << endl ; else cout << " The ▁ given ▁ straight " << " ▁ lines ▁ are ▁ not ▁ identical " << endl ; }
Hyp: 
void idstrt ( int a1 , int b1 , int c1 , int a2 , int b2 , int c2 ) { if ( ( a1 / a2 == b1 / b2 ) && ( a1 / a2 == c1 / c2 ) && ( b1 / b2 == c1 / c2 ) ) cout << " Yes " << endl ; else cout << " No " << endl ; }

BLEU: 49.38
Edit Sim: 149


Src: 
function compute_average ( a , b ) { return Math . floor ( ( a + b ) / 2 ) ; }
Ref: 
int compute_average ( int a , int b ) { return ( a + b ) / 2 ; }
Hyp: 
int compute_average ( int a , int b ) { return ( a + b ) / 2 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function cntSubXor ( arr , N ) { let prefixXor = 0 ; let Even = Array . from ( { length : M } , ( _ , i ) => 0 ) ; let Odd = Array . from ( { length : M } , ( _ , i ) => 0 ) ; let cntSub = 0 ; Odd [ 0 ] = 1 ; for ( let i = 0 ; i < N ; i ++ ) { prefixXor = Math . floor ( prefixXor ^ arr [ i ] ) ; if ( i % 2 == 1 ) { cntSub += Odd [ prefixXor ] ; Odd [ prefixXor ] ++ ; } else { cntSub += Even [ prefixXor ] ; Even [ prefixXor ] ++ ; } } return cntSub ; }
Ref: 
int cntSubXor ( int arr [ ] , int N ) { int prefixXor = 0 ; int Even [ M ] ; int Odd [ M ] ; int cntSub = 0 ; Odd [ 0 ] = 1 ; for ( int i = 0 ; i < N ; i ++ ) { prefixXor ^= arr [ i ] ; if ( i % 2 == 1 ) { cntSub += Odd [ prefixXor ] ; Odd [ prefixXor ] ++ ; } else { cntSub += Even [ prefixXor ] ; Even [ prefixXor ] ++ ; } } return cntSub ; }
Hyp: 
int cntSubXor ( int arr [ ] , int N ) { int prefixXor = 0 ; int Even [ M ] , Odd [ M ] ; int cntSub = 0 ; Even [ 0 ] = 1 ; for ( int i = 0 ; i < N ; i ++ ) { prefixXor = floor ( prefixXor ^ arr [ i ] ) ; if ( i % 2 == 1 ) { cntSub += Odd [ prefixXor ] ; Odd [ prefixXor ] ++ ; } else { cntSub += Even [ prefixXor ] ; Even [ prefixXor ] ++ ; } } return cntSub ; }

BLEU: 87.19
Edit Sim: 32


Src: 
function maxSide ( a , n ) { let sideLength = 0 ; a . sort ( ) ; for ( i = n - 1 ; i >= 0 ; i -- ) { if ( a [ i ] > sideLength ) { sideLength ++ ; } else { break ; } } document . write ( sideLength ) ; }
Ref: 
void maxSide ( int a [ ] , int n ) { int sideLength = 0 ; sort ( a , a + n ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( a [ i ] > sideLength ) { sideLength ++ ; } else { break ; } } cout << sideLength << endl ; }
Hyp: 
void maxSide ( int a [ ] , int n ) { int sideLength = 0 ; sort ( a , a + n ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( a [ i ] > sideLength ) { sideLength ++ ; } else { break ; } } cout << sideLength ; }

BLEU: 95.28
Edit Sim: 8


Src: 
function findPairs ( arr , n ) { let cntEven = 0 , cntOdd = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) cntEven ++ ; else cntOdd ++ ; } let evenPairs = 0 ; evenPairs += ( ( cntEven * ( cntEven - 1 ) ) / 2 ) ; evenPairs += ( ( cntOdd * ( cntOdd - 1 ) ) / 2 ) ; let oddPairs = 0 ; oddPairs += ( cntEven * cntOdd ) ; document . write ( " " + oddPairs + " " ) ; document . write ( " " + evenPairs ) ; }
Ref: 
void findPairs ( int arr [ ] , int n ) { int cntEven = 0 , cntOdd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) cntEven ++ ; else cntOdd ++ ; } int evenPairs = 0 ; evenPairs += ( ( cntEven * ( cntEven - 1 ) ) / 2 ) ; evenPairs += ( ( cntOdd * ( cntOdd - 1 ) ) / 2 ) ; int oddPairs = 0 ; oddPairs += ( cntEven * cntOdd ) ; cout << " Odd ▁ pairs ▁ = ▁ " << oddPairs << endl ; cout << " Even ▁ pairs ▁ = ▁ " << evenPairs ; }
Hyp: 
void findPairs ( int arr [ ] , int n ) { int cntEven = 0 , cntOdd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) cntEven ++ ; else cntOdd ++ ; } int evenPairs = 0 ; evenPairs += ( ( cntEven * ( cntEven - 1 ) ) / 2 ) ; evenPairs += ( ( cntOdd * ( cntOdd - 1 ) ) / 2 ) ; int oddPairs = 0 ; oddPairs += ( cntEven * cntOdd ) ; cout << " Even ▁ = ▁ " << oddPairs << " STRNEWLINE " ; cout << " Even ▁ = ▁ " << evenPairs ; }

BLEU: 92.64
Edit Sim: 33


Src: 
function countWays ( n ) { let dp = new Array ( n + 1 ) ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; dp [ 2 ] = 1 ; for ( let i = 3 ; i <= n ; i ++ ) { dp [ i ] = dp [ i - 1 ] + dp [ i - 3 ] + 1 ; } return dp [ n ] ; }
Ref: 
int countWays ( int n ) { int dp [ n + 1 ] ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; dp [ 2 ] = 1 ; for ( int i = 3 ; i <= n ; i ++ ) { dp [ i ] = dp [ i - 1 ] + dp [ i - 3 ] + 1 ; } return dp [ n ] ; }
Hyp: 
int countWays ( int n ) { int dp [ n + 1 ] ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; dp [ 2 ] = 1 ; for ( int i = 3 ; i <= n ; i ++ ) { dp [ i ] = dp [ i - 1 ] + dp [ i - 3 ] + 1 ; } return dp [ n ] ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function printTriplets ( arr , n , sum ) { for ( let i = 0 ; i < n - 2 ; i ++ ) { for ( let j = i + 1 ; j < n - 1 ; j ++ ) { for ( let k = j + 1 ; k < n ; k ++ ) if ( arr [ i ] + arr [ j ] + arr [ k ] < sum ) document . write ( arr [ i ] + " " + arr [ j ] + " " + arr [ k ] + " " ) ; } } }
Ref: 
int printTriplets ( int arr [ ] , int n , int sum ) { for ( int i = 0 ; i < n - 2 ; i ++ ) { for ( int j = i + 1 ; j < n - 1 ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) if ( arr [ i ] + arr [ j ] + arr [ k ] < sum ) cout << arr [ i ] << " , ▁ " << arr [ j ] << " , ▁ " << arr [ k ] << endl ; } } }
Hyp: 
void printTriplets ( int arr [ ] , int n , int sum ) { for ( int i = 0 ; i < n - 2 ; i ++ ) { for ( int j = i + 1 ; j < n - 1 ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) if ( arr [ i ] + arr [ j ] + arr [ k ] < sum ) cout << arr [ i ] << " ^ " << arr [ j ] << " ^ " << arr [ k ] << " ▁ " ; } } }

BLEU: 91.4
Edit Sim: 15


Src: 
function print ( p0 ) { var p1 , i = 0 , x , flag = 1 , k , m = 4 ; while ( flag ) { flag = 1 ; x = Math . pow ( 2 , i ) ; p1 = x * p0 - ( x - 1 ) ; for ( k = 2 ; k < p1 ; k ++ ) { if ( p1 % k == 0 ) { flag = 0 ; break ; } } if ( flag == 0 ) break ; document . write ( p1 + " " ) ; i ++ ; } }
Ref: 
void print ( int p0 ) { int p1 , i = 0 , x , flag , k ; while ( 1 ) { flag = 1 ; x = ( int ) ( pow ( 2 , i ) ) ; p1 = x * p0 - ( x - 1 ) ; for ( k = 2 ; k < p1 ; k ++ ) { if ( p1 % k == 0 ) { flag = 0 ; break ; } } if ( flag == 0 ) break ; printf ( " % d ▁ " , p1 ) ; i ++ ; } }
Hyp: 
void print ( int p0 ) { int p1 , i = 0 , x , flag = 1 , k , m = 4 ; while ( flag ) { flag = 1 ; x = pow ( 2 , i ) ; p1 = x * p0 - ( x - 1 ) ; for ( k = 2 ; k < p1 ; k ++ ) { if ( p1 % k == 0 ) { flag = 0 ; break ; } } if ( flag == 0 ) break ; cout << p1 << " ▁ " ; i ++ ; } }

BLEU: 79.23
Edit Sim: 46


Src: 
function evenNumSubstring ( str ) { let len = str . length ; let count = 0 ; for ( let i = 0 ; i < len ; i ++ ) { let temp = str [ i ] - ' ' ; if ( temp % 2 == 0 ) count += ( i + 1 ) ; } return count ; }
Ref: 
int evenNumSubstring ( char str [ ] ) { int len = strlen ( str ) ; int count = 0 ; for ( int i = 0 ; i < len ; i ++ ) { int temp = str [ i ] - '0' ; if ( temp % 2 == 0 ) count += ( i + 1 ) ; } return count ; }
Hyp: 
int evenNumSubstring ( string str ) { int len = str . length ( ) ; int count = 0 ; for ( int i = 0 ; i < len ; i ++ ) { int temp = str [ i ] - '0' ; if ( temp % 2 == 0 ) count += ( i + 1 ) ; } return count ; }

BLEU: 86.43
Edit Sim: 19


Src: 
function findLargestString ( s , i , r ) { if ( i == s . length ) { if ( r == 0 ) return 0 ; else return - 1000000000 ; } if ( v [ i ] [ r ] ) return dp [ i ] [ r ] ; v [ i ] [ r ] = 1 ; dp [ i ] [ r ] = Math . max ( 1 + findLargestString ( s , i + 1 , ( r * 2 + ( s [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ) ) % 3 ) , findLargestString ( s , i + 1 , r ) ) ; return dp [ i ] [ r ] ; }
Ref: 
int findLargestString ( string & s , int i , int r ) { if ( i == s . size ( ) ) { if ( r == 0 ) return 0 ; else return INT_MIN ; } if ( v [ i ] [ r ] ) return dp [ i ] [ r ] ; v [ i ] [ r ] = 1 ; dp [ i ] [ r ] = max ( 1 + findLargestString ( s , i + 1 , ( r * 2 + ( s [ i ] - '0' ) ) % 3 ) , findLargestString ( s , i + 1 , r ) ) ; return dp [ i ] [ r ] ; }
Hyp: 
int findLargestString ( string & s , int i , int r ) { if ( i == s . size ( ) ) { if ( r == 0 ) return 0 ; else return -1000000 ; } if ( v [ i ] [ r ] ) return dp [ i ] [ r ] ; v [ i ] [ r ] = 1 ; dp [ i ] [ r ] = max ( 1 + findLargestString ( s , i + 1 , ( r * 2 + ( s [ i ] - '0' ) ) ) % 3 ) , findLargestString ( s , i + 1 , r ) ) ; return dp [ i ] [ r ] ; }

BLEU: 97.06
Edit Sim: 10


Src: 
function surface_area_octahedron ( side ) { return ( 2 * ( Math . sqrt ( 3 ) ) * ( side * side ) ) ; }
Ref: 
double surface_area_octahedron ( double side ) { return ( 2 * ( sqrt ( 3 ) ) * ( side * side ) ) ; }
Hyp: 
double surface_area_octahedron ( int side ) { return ( 2 * ( sqrt ( 3 ) ) * ( side * side ) ) ; }

BLEU: 89.85
Edit Sim: 6


Src: 
function Findpermutation ( n ) { let a = new Array ( n + 1 ) ; a [ 1 ] = n ; for ( let i = 2 ; i <= n ; i ++ ) a [ i ] = i - 1 ; return a ; }
Ref: 
> Findpermutation ( int n ) { vector < int > a ( n + 1 ) ; a [ 1 ] = n ; for ( int i = 2 ; i <= n ; i ++ ) a [ i ] = i - 1 ; return a ; }
Hyp: 
int Findpermutation ( int n ) { int a [ n + 1 ] ; a [ 1 ] = n ; for ( int i = 2 ; i <= n ; i ++ ) a [ i ] = i - 1 ; return a ; }

BLEU: 79.15
Edit Sim: 16


Src: 
function sum_of_elements ( arr , n ) { var sumfirst = 0 , sumsecond = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( i < parseInt ( n / 2 ) ) { sumfirst += arr [ i ] ; } else { sumsecond += arr [ i ] ; } } document . write ( " " + sumfirst + " " ) ; document . write ( " " + sumsecond + " " ) ; }
Ref: 
void sum_of_elements ( int arr [ ] , int n ) { int sumfirst = 0 , sumsecond = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i < n / 2 ) sumfirst += arr [ i ] ; else sumsecond += arr [ i ] ; } cout << " Sum ▁ of ▁ first ▁ half ▁ elements ▁ is ▁ " << sumfirst << endl ; cout << " Sum ▁ of ▁ second ▁ half ▁ elements ▁ is ▁ " << sumsecond << endl ; }
Hyp: 
void sum_of_elements ( int arr [ ] , int n ) { int sumfirst = 0 , sumsecond = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i < n / 2 ) { sumfirst += arr [ i ] ; } else { sumsecond += arr [ i ] ; } } cout << " Sum ▁ of ▁ the ▁ given ▁ array ▁ is ▁ " << sumfirst << " , ▁ " << sumsecond << endl ; }

BLEU: 72.42
Edit Sim: 81


Src: 
function findLastIndex ( str , x ) { let index = - 1 ; for ( let i = 0 ; i < str . length ; i ++ ) if ( str [ i ] == x ) index = i ; return index ; }
Ref: 
int findLastIndex ( string & str , char x ) { int index = -1 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) if ( str [ i ] == x ) index = i ; return index ; }
Hyp: 
int findLastIndex ( string str , char x ) { int index = -1 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) if ( str [ i ] == x ) index = i ; return index ; }

BLEU: 94.97
Edit Sim: 2


Src: 
function printSorted ( a , b , c ) { let get_max = Math . max ( a , Math . max ( b , c ) ) ; let get_min = - Math . max ( - a , Math . max ( - b , - c ) ) ; let get_mid = ( a + b + c ) - ( get_max + get_min ) ; document . write ( get_min + " " + get_mid + " " + get_max ) ; }
Ref: 
void printSorted ( int a , int b , int c ) { int get_max = max ( a , max ( b , c ) ) ; int get_min = - max ( - a , max ( - b , - c ) ) ; int get_mid = ( a + b + c ) - ( get_max + get_min ) ; cout << get_min << " ▁ " << get_mid << " ▁ " << get_max ; }
Hyp: 
void printSorted ( int a , int b , int c ) { int get_max = max ( a , max ( b , c ) ) ; int get_min = - max ( - a , max ( - b , - c ) ) ; int get_mid = ( a + b + c ) - ( get_max + get_min ) ; cout << get_min << " ▁ " << get_mid << " ▁ " << get_max ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function sumOfTheSeries ( n ) { return ( n * ( n + 1 ) / 2 ) * ( 2 * n + 1 ) / 3 ; }
Ref: 
int sumOfTheSeries ( int n ) { return ( n * ( n + 1 ) / 2 ) * ( 2 * n + 1 ) / 3 ; }
Hyp: 
int sumOfTheSeries ( int n ) { return ( n * ( n + 1 ) / 2 ) * ( 2 * n + 1 ) / 3 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findSum ( N ) { var sum = ( N ) * ( N + 1 ) / 2 ; var r = ( Math . log ( N ) / Math . log ( 2 ) ) + 1 ; var expSum = ( Math . pow ( 2 , r ) ) - 1 ; document . write ( sum - expSum ) ; }
Ref: 
void findSum ( int N ) { int sum = ( N ) * ( N + 1 ) / 2 ; int r = log2 ( N ) + 1 ; int expSum = pow ( 2 , r ) - 1 ; cout << sum - expSum << endl ; }
Hyp: 
void findSum ( int N ) { int sum = ( N ) * ( N + 1 ) / 2 ; int r = ( log2 ( N ) ) + 1 ; int expSum = ( pow ( 2 , r ) ) - 1 ; cout << sum - expSum ; }

BLEU: 81.45
Edit Sim: 16


Src: 
function findPairs ( A , B ) { for ( let i = 1 ; i <= B ; i ++ ) { let y = A ^ i ; if ( y > 0 && ( i y ) == B ) { document . write ( i + " " + y + " " ) ; } } }
Ref: 
void findPairs ( int A , int B ) { for ( int i = 1 ; i <= B ; i ++ ) { int y = A ^ i ; if ( y > 0 and ( i y ) == B ) { cout << i << " ▁ " << y << endl ; } } }
Hyp: 
void findPairs ( int A , int B ) { for ( int i = 1 ; i <= B ; i ++ ) { int y = A ^ i ; if ( y > 0 && ( i y ) == B ) { cout << i << " , ▁ " << y ; } } }

BLEU: 87.31
Edit Sim: 13


Src: 
function check ( arr , n ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] & 1 ) count ++ ; } if ( count & 1 ) return " " ; else return " " ; }
Ref: 
string check ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] & 1 ) count ++ ; } if ( count & 1 ) return " Odd " ; else return " Even " ; }
Hyp: 
string check ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] & 1 ) count ++ ; } if ( count & 1 ) return " Yes " ; else return " No " ; }

BLEU: 91.86
Edit Sim: 7


Src: 
function check ( v , len ) { let n = v . length ; let tempArray ; for ( let i = 0 ; i < n ; i ++ ) { tempArray = v [ i ] . split ( " " ) ; ( tempArray ) . sort ( ) ; v [ i ] = ( tempArray ) . join ( " " ) ; } for ( let i = 0 ; i < len - 1 ; i ++ ) for ( let j = 0 ; j < n ; j ++ ) if ( v [ i ] [ j ] > v [ i + 1 ] [ j ] ) return false ; return true ; }
Ref: 
bool check ( vector < string > v , int len ) { int n = v . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) sort ( v [ i ] . begin ( ) , v [ i ] . end ( ) ) ; for ( int i = 0 ; i < len - 1 ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( v [ i ] [ j ] > v [ i + 1 ] [ j ] ) return false ; return true ; }
Hyp: 
bool check ( string v [ ] , int len ) { int n = v . length ( ) ; string tempArray ; for ( int i = 0 ; i < n ; i ++ ) { tempArray = v [ i ] ; sort ( tempArray , v + n ) ; v [ i ] = tempArray . begin ( ) ; } for ( int i = 0 ; i < len - 1 ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( v [ i ] [ j ] > v [ i + 1 ] [ j ] ) return false ; return true ; }

BLEU: 73.32
Edit Sim: 91


Src: 
function findCnt ( arr , i , curr , n , m ) { if ( i == n ) { if ( curr == 0 ) return 1 ; else return 0 ; } if ( v [ i ] [ curr ] ) return dp [ i ] [ curr ] ; v [ i ] [ curr ] = 1 ; dp [ i ] [ curr ] = findCnt ( arr , i + 1 , curr , n , m ) + findCnt ( arr , i + 1 , ( curr + arr [ i ] ) % m , n , m ) ; return dp [ i ] [ curr ] ; }
Ref: 
int findCnt ( int * arr , int i , int curr , int n , int m ) { if ( i == n ) { if ( curr == 0 ) return 1 ; else return 0 ; } if ( v [ i ] [ curr ] ) return dp [ i ] [ curr ] ; v [ i ] [ curr ] = 1 ; return dp [ i ] [ curr ] = findCnt ( arr , i + 1 , curr , n , m ) + findCnt ( arr , i + 1 , ( curr + arr [ i ] ) % m , n , m ) ; }
Hyp: 
int findCnt ( int * arr , int i , int curr , int n , int m ) { if ( i == n ) { if ( curr == 0 ) return 1 ; else return 0 ; } if ( v [ i ] [ curr ] ) return dp [ i ] [ curr ] ; v [ i ] [ curr ] = 1 ; dp [ i ] [ curr ] = findCnt ( arr , i + 1 , curr , n , m ) + findCnt ( arr , i + 1 , ( curr + arr [ i ] ) % m , n , m ) ; return dp [ i ] [ curr ] ; }

BLEU: 92.67
Edit Sim: 34


Src: 
function findSum ( n ) { if ( n % 2 == 0 ) return ( n / 2 ) * ( n + 1 ) else return ( ( n + 1 ) / 2 ) * n }
Ref: 
int findSum ( int n ) { if ( n % 2 == 0 ) return ( n / 2 ) * ( n + 1 ) ; else return ( ( n + 1 ) / 2 ) * n ; }
Hyp: 
int findSum ( int n ) { if ( n % 2 == 0 ) return ( n / 2 ) * ( n + 1 ) ; else return ( ( n + 1 ) / 2 ) * n ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function areEqual ( arr1 , arr2 ) { let n = arr1 . length ; let m = arr2 . length ; if ( n != m ) return false ; arr1 . sort ( ) ; arr2 . sort ( ) ; for ( let i = 0 ; i < n ; i ++ ) if ( arr1 [ i ] != arr2 [ i ] ) return false ; return true ; }
Ref: 
bool areEqual ( int arr1 [ ] , int arr2 [ ] , int n , int m ) { if ( n != m ) return false ; sort ( arr1 , arr1 + n ) ; sort ( arr2 , arr2 + m ) ; for ( int i = 0 ; i < n ; i ++ ) if ( arr1 [ i ] != arr2 [ i ] ) return false ; return true ; }
Hyp: 
bool areEqual ( int arr1 [ ] , int arr2 [ ] ) { int n = arr1 . size ( ) , m = arr2 . size ( ) ; if ( n != m ) return false ; sort ( arr1 , arr1 + n ) ; sort ( arr2 , arr2 + m ) ; for ( int i = 0 ; i < n ; i ++ ) if ( arr1 [ i ] != arr2 [ i ] ) return false ; return true ; }

BLEU: 79.41
Edit Sim: 37


Src: 
function countSubsequences ( A ) { var odd = 0 ; var even = 0 ; for ( var e1 = 0 ; e1 < A . length ; e1 ++ ) { if ( A [ e1 ] % 2 == 1 ) odd ++ ; else even ++ ; } if ( odd == 0 ) document . write ( 0 ) ; else document . write ( ( 1 << ( A . length - 1 ) ) ) ; }
Ref: 
void countSubsequences ( vector < int > A ) { int odd = 0 ; int even = 0 ; for ( int el : A ) { if ( el % 2 == 1 ) odd ++ ; else even ++ ; } if ( odd == 0 ) cout << ( 0 ) ; else cout << ( 1 << ( A . size ( ) - 1 ) ) ; }
Hyp: 
void countSubsequences ( vector < int > & A ) { int odd = 0 ; int even = 0 ; for ( int e1 = 0 ; e1 < A . size ( ) ; e1 ++ ) { if ( A [ e1 ] % 2 == 1 ) odd ++ ; else even ++ ; } if ( odd == 0 ) cout << 0 ; else cout << ( 1 << ( A . size ( ) - 1 ) ) ; }

BLEU: 70.93
Edit Sim: 43


Src: 
function findX ( A , B ) { let j = 0 , x = 0 ; while ( A != 0 B != 0 ) { if ( ( A % 2 == 1 ) && ( B % 2 == 1 ) ) { x += ( 1 << j ) ; } A >>= 1 ; B >>= 1 ; j += 1 ; } return x ; }
Ref: 
int findX ( int A , int B ) { int j = 0 , x = 0 ; while ( A B ) { if ( ( A & 1 ) && ( B & 1 ) ) { x += ( 1 << j ) ; } A >>= 1 ; B >>= 1 ; j += 1 ; } return x ; }
Hyp: 
int findX ( int A , int B ) { int j = 0 , x = 0 ; while ( A != 0 B != 0 ) { if ( ( A % 2 == 1 ) && ( B % 2 == 1 ) ) { x += ( 1 << j ) ; } A >>= 1 ; B >>= 1 ; j += 1 ; } return x ; }

BLEU: 78.99
Edit Sim: 22


Src: 
function isPowerofTwo ( n ) { if ( n == 0 ) return false ; if ( ( n & ( ~ ( n - 1 ) ) ) == n ) return true ; return false ; }
Ref: 
bool isPowerofTwo ( long long n ) { if ( n == 0 ) return 0 ; if ( ( n & ( ~ ( n - 1 ) ) ) == n ) return 1 ; return 0 ; }
Hyp: 
bool isPowerofTwo ( unsigned int n ) { if ( n == 0 ) return false ; if ( ( n & ( ~ ( n - 1 ) ) ) == n ) return true ; return false ; }

BLEU: 73.1
Edit Sim: 24


Src: 
function get_last_two_digit ( N ) { if ( N % 4 == 0 ) return " " ; else if ( N % 4 == 1 ) return " " ; else if ( N % 4 == 2 ) return " " ; return " " ; }
Ref: 
string get_last_two_digit ( int N ) { if ( N % 4 == 0 ) return "01" ; else if ( N % 4 == 1 ) return "07" ; else if ( N % 4 == 2 ) return "49" ; return "43" ; }
Hyp: 
string get_last_two_digit ( int N ) { if ( N % 4 == 0 ) return " A " ; else if ( N % 4 == 1 ) return " B " ; else if ( N % 4 == 2 ) return " C " ; return " NO " ; }

BLEU: 66.67
Edit Sim: 13


Src: 
function getPairsCount ( arr , n ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = arr [ i ] - ( i % arr [ i ] ) ; j < n ; j += arr [ i ] ) { if ( i < j && arr [ i ] * arr [ j ] == Math . abs ( i - j ) ) { count ++ ; } } } return count ; }
Ref: 
int getPairsCount ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = arr [ i ] - ( i % arr [ i ] ) ; j < n ; j += arr [ i ] ) { if ( i < j && ( arr [ i ] * arr [ j ] ) == abs ( i - j ) ) { count ++ ; } } } return count ; }
Hyp: 
int getPairsCount ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = arr [ i ] - ( i % arr [ i ] ) ; j < n ; j += arr [ i ] ) { if ( i < j && arr [ i ] * arr [ j ] == abs ( i - j ) ) { count ++ ; } } } return count ; }

BLEU: 94.86
Edit Sim: 4


Src: 
function isPossible ( arr , p , n , m ) { var sum = 0 ; for ( var i = 0 ; i < p ; i ++ ) sum += arr [ i ] ; if ( sum == ( n * m ) ) return true ; return false ; }
Ref: 
bool isPossible ( int arr [ ] , int p , int n , int m ) { int sum = 0 ; for ( int i = 0 ; i < p ; i ++ ) sum += arr [ i ] ; if ( sum == ( n * m ) ) return true ; return false ; }
Hyp: 
bool isPossible ( int arr [ ] , int p , int n , int m ) { int sum = 0 ; for ( int i = 0 ; i < p ; i ++ ) sum += arr [ i ] ; if ( sum == ( n * m ) ) return true ; return false ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countOddSquares ( n , m ) { return Math . pow ( m , 0.5 ) - Math . pow ( n - 1 , 0.5 ) ; }
Ref: 
int countOddSquares ( int n , int m ) { return ( int ) pow ( m , 0.5 ) - ( int ) pow ( n - 1 , 0.5 ) ; }
Hyp: 
int countOddSquares ( int n , int m ) { return pow ( m , 0.5 ) - pow ( n - 1 , 0.5 ) ; }

BLEU: 71.28
Edit Sim: 16


Src: 
function findNumbers ( n ) { let i = 1 ; while ( i <= n ) { document . write ( ( 3 * i * ( i - 1 ) + 1 ) + " " ) ; i ++ ; } }
Ref: 
void findNumbers ( int n ) { int i = 1 ; while ( i <= n ) { cout << ( 3 * i * ( i - 1 ) + 1 ) << " ▁ " ; i ++ ; } }
Hyp: 
void findNumbers ( int n ) { int i = 1 ; while ( i <= n ) { cout << 3 * i * ( i - 1 ) + 1 ; i ++ ; } }

BLEU: 78.22
Edit Sim: 13


Src: 
function nthterm ( n ) { let An = ( Math . pow ( 1 , n ) + Math . pow ( 2 , n ) ) * Math . pow ( 3 , n ) ; return An ; }
Ref: 
long nthterm ( int n ) { int An = ( pow ( 1 , n ) + pow ( 2 , n ) ) * pow ( 3 , n ) ; return An ; }
Hyp: 
int nthterm ( int n ) { int An = ( pow ( 1 , n ) + pow ( 2 , n ) ) * pow ( 3 , n ) ; return An ; }

BLEU: 97.26
Edit Sim: 3


Src: 
function findMax ( num ) { let num_copy = num ; let j = 4 * 8 - 1 ; let i = 0 ; while ( i < j ) { let m = ( num_copy >> i ) & 1 ; let n = ( num_copy >> j ) & 1 ; if ( m > n ) { let x = ( 1 << i 1 << j ) ; num = num ^ x ; } i ++ ; j -- ; } return num ; }
Ref: 
ull findMax ( ull num ) { ull num_copy = num ; int j = sizeof ( unsigned long long int ) * 8 - 1 ; int i = 0 ; while ( i < j ) { int m = ( num_copy >> i ) & 1 ; int n = ( num_copy >> j ) & 1 ; if ( m > n ) { int x = ( 1 << i 1 << j ) ; num = num ^ x ; } i ++ ; j -- ; } return num ; }
Hyp: 
int findMax ( int num ) { int num_copy = num ; int j = 4 * 8 - 1 ; int i = 0 ; while ( i < j ) { int m = ( num_copy >> i ) & 1 ; int n = ( num_copy >> j ) & 1 ; if ( m > n ) { int x = ( 1 << i 1 << j ) ; num = num ^ x ; } i ++ ; j -- ; } return num ; }

BLEU: 85.38
Edit Sim: 42


Src: 
function squaresum ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) sum += ( i * i ) ; return sum ; }
Ref: 
int squaresum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += ( i * i ) ; return sum ; }
Hyp: 
int squaresum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += ( i * i ) ; return sum ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function checkDuplicatesWithinK ( arr , n , k ) { let myset = [ ] ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr . includes ( arr [ i ] ) ) { return true ; } myset . add ( arr [ i ] ) ; if ( i >= k ) { index = array . indexOf ( arr [ i - k ] ) ; array . splice ( index , 1 ) ; } } return false ; } let arr = [ 10 , 5 , 3 , 4 , 3 , 5 , 6 ] ; let n = arr . length ; if ( checkDuplicatesWithinK ( arr , n , 3 ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
Ref: 
bool checkDuplicatesWithinK ( int arr [ ] , int n , int k ) { unordered_set < int > myset ; for ( int i = 0 ; i < n ; i ++ ) { if ( myset . find ( arr [ i ] ) != myset . end ( ) ) return true ; myset . insert ( arr [ i ] ) ; if ( i >= k ) myset . erase ( arr [ i - k ] ) ; } return false ; }
Hyp: 
bool checkDuplicatesWithinK ( int arr [ ] , int n , int k ) { unordered_set < int > myset ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr . find ( arr [ i ] ) != myset . end ( ) ) { return true ; } myset . insert ( arr [ i ] ) ; if ( i >= k ) { int index = arr . find ( arr [ i - k ] ) ; array . erase ( index , 1 ) ; } } return false ; }

BLEU: 75.25
Edit Sim: 61


Src: 
function isSubSequence ( str1 , str2 , m , n ) { if ( m == 0 ) return true ; if ( n == 0 ) return false ; if ( str1 [ m - 1 ] == str2 [ n - 1 ] ) return isSubSequence ( str1 , str2 , m - 1 , n - 1 ) ; return isSubSequence ( str1 , str2 , m , n - 1 ) ; }
Ref: 
bool isSubSequence ( char str1 [ ] , char str2 [ ] , int m , int n ) { if ( m == 0 ) return true ; if ( n == 0 ) return false ; if ( str1 [ m - 1 ] == str2 [ n - 1 ] ) return isSubSequence ( str1 , str2 , m - 1 , n - 1 ) ; return isSubSequence ( str1 , str2 , m , n - 1 ) ; }
Hyp: 
bool isSubSequence ( string str1 , string str2 , int m , int n ) { if ( ! m ) return true ; if ( ! n ) return false ; if ( str1 [ m - 1 ] == str2 [ n - 1 ] ) return isSubSequence ( str1 , str2 , m - 1 , n - 1 ) ; return isSubSequence ( str1 , str2 , m , n - 1 ) ; }

BLEU: 77.89
Edit Sim: 29


Src: 
function check ( N , D ) { let temp = ( N * ( N + 1 ) ) / 2 + D ; return ( temp % 2 == 0 ) ; }
Ref: 
bool check ( int N , int D ) { int temp = ( N * ( N + 1 ) ) / 2 + D ; return ( temp % 2 == 0 ) ; }
Hyp: 
bool check ( int N , int D ) { int temp = ( N * ( N + 1 ) ) / 2 + D ; return ( temp % 2 == 0 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function binaryToDecimal ( n ) { let num = n ; let dec_value = 0 ; let base = 1 ; let temp = num ; while ( temp ) { let last_digit = temp % 10 ; temp = Math . floor ( temp / 10 ) ; dec_value += last_digit * base ; base = base * 2 ; } return dec_value ; }
Ref: 
int binaryToDecimal ( int n ) { int num = n ; int dec_value = 0 ; int base = 1 ; int temp = num ; while ( temp ) { int last_digit = temp % 10 ; temp = temp / 10 ; dec_value += last_digit * base ; base = base * 2 ; } return dec_value ; }
Hyp: 
int binaryToDecimal ( int n ) { int num = n ; int dec_value = 0 ; int base = 1 ; int temp = num ; while ( temp ) { int last_digit = temp % 10 ; temp /= 10 ; dec_value += last_digit * base ; base = base * 2 ; } return dec_value ; }

BLEU: 92.6
Edit Sim: 8


Src: 
function calcSafe ( pos ) { let j = pos % 10 ; let i = Math . floor ( pos / 10 ) ; let dis_11 = Math . min ( Math . abs ( 1 - i ) , Math . abs ( 1 - j ) ) ; let dis_18 = Math . min ( Math . abs ( 1 - i ) , Math . abs ( 8 - j ) ) ; let dis_81 = Math . min ( Math . abs ( 8 - i ) , Math . abs ( 1 - j ) ) ; let dis_88 = Math . min ( Math . abs ( 8 - i ) , Math . abs ( 8 - j ) ) ; let sum = dis_11 + dis_18 + dis_81 + dis_88 + 1 ; return ( 64 - sum ) ; }
Ref: 
int calcSafe ( int pos ) { int j = pos % 10 ; int i = pos / 10 ; int dis_11 = min ( abs ( 1 - i ) , abs ( 1 - j ) ) ; int dis_18 = min ( abs ( 1 - i ) , abs ( 8 - j ) ) ; int dis_81 = min ( abs ( 8 - i ) , abs ( 1 - j ) ) ; int dis_88 = min ( abs ( 8 - i ) , abs ( 8 - j ) ) ; int sum = dis_11 + dis_18 + dis_81 + dis_88 + 1 ; return ( 64 - sum ) ; }
Hyp: 
int calcSafe ( int pos ) { int j = pos % 10 ; int i = pos / 10 ; int dis_11 = min ( abs ( 1 - i ) , abs ( 1 - j ) ) ; int dis_18 = min ( abs ( 1 - i ) , abs ( 8 - j ) ) ; int dis_81 = min ( abs ( 8 - i ) , abs ( 1 - j ) ) ; int dis_88 = min ( abs ( 8 - i ) , abs ( 8 - j ) ) ; int sum = dis_11 + dis_18 + dis_81 + dis_88 + 1 ; return ( 64 - sum ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function isPerfectSquare ( n ) { for ( let sum = 0 , i = 1 ; sum < n ; i += 2 ) { sum += i ; if ( sum == n ) return true ; } return false ; }
Ref: 
bool isPerfectSquare ( int n ) { for ( int sum = 0 , i = 1 ; sum < n ; i += 2 ) { sum += i ; if ( sum == n ) return true ; } return false ; }
Hyp: 
bool isPerfectSquare ( int n ) { for ( int sum = 0 , i = 1 ; sum < n ; i += 2 ) { sum += i ; if ( sum == n ) return true ; } return false ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function is_distinct ( n , k ) { let s = new Set ( ) ; for ( let i = 1 ; i <= k ; i ++ ) { let tmp = n % i ; if ( s . has ( tmp ) ) { return false ; } s . add ( tmp ) ; } return true ; }
Ref: 
bool is_distinct ( long long n , long long k ) { unordered_set < long long > s ; for ( int i = 1 ; i <= k ; i ++ ) { long long tmp = n % i ; if ( s . find ( tmp ) != s . end ( ) ) { return false ; } s . insert ( tmp ) ; } return true ; }
Hyp: 
bool is_distinct ( int n , int k ) { unordered_set < int > s ; for ( int i = 1 ; i <= k ; i ++ ) { int tmp = n % i ; if ( s . find ( tmp ) != s . end ( ) ) { return false ; } s . insert ( tmp ) ; } return true ; }

BLEU: 80.89
Edit Sim: 32


Src: 
function pairORSum ( arr , n ) { for ( var i = 0 ; i < n ; i ++ ) for ( var j = i + 1 ; j < n ; j ++ ) ans += arr [ i ] | arr [ j ] ; return ans ; }
Ref: 
int pairORSum ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) ans += arr [ i ] | arr [ j ] ; return ans ; }
Hyp: 
int pairORSum ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) ans += arr [ i ] | arr [ j ] ; return ans ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function LISusingLCS ( seq ) { let n = seq . length ; let L = new Array ( n + 1 ) ; for ( let i = 0 ; i < ( n + 1 ) ; i ++ ) { L [ i ] = new Array ( n + 1 ) ; for ( let j = 0 ; j < ( n + 1 ) ; j ++ ) { L [ i ] [ j ] = 0 ; } } let sortedseq = [ ... seq ] ; sortedseq . sort ( function ( a , b ) { return a - b ; } ) ; for ( let i = 0 ; i <= n ; i ++ ) { for ( let j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) L [ i ] [ j ] = 0 ; else if ( seq [ i - 1 ] == sortedseq [ j - 1 ] ) L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 1 ; else L [ i ] [ j ] = Math . max ( L [ i - 1 ] [ j ] , L [ i ] [ j - 1 ] ) ; } } return L [ n ] [ n ] ; }
Ref: 
int LISusingLCS ( vector < int > & seq ) { int n = seq . size ( ) ; vector < vector < int > > L ( n + 1 , vector < int > ( n + 1 ) ) ; vector < int > sortedseq ( seq ) ; sort ( sortedseq . begin ( ) , sortedseq . end ( ) ) ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) L [ i ] [ j ] = 0 ; else if ( seq [ i - 1 ] == sortedseq [ j - 1 ] ) L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 1 ; else L [ i ] [ j ] = max ( L [ i - 1 ] [ j ] , L [ i ] [ j - 1 ] ) ; } } return L [ n ] [ n ] ; }
Hyp: 
int LISusingLCS ( string seq ) { int n = seq . length ( ) ; int L [ n + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) L [ i ] [ j ] = 0 ; else if ( seq [ i - 1 ] == sortedseq [ j - 1 ] ) L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 1 ; else L [ i ] [ j ] = max ( L [ i - 1 ] [ j ] , L [ i ] [ j - 1 ] ) ; } } return L [ n ] [ n ] ; }

BLEU: 71.06
Edit Sim: 150


Src: 
function getSum ( n , d ) { let sum = 0 ; while ( d <= n ) { sum += d ; d += 10 ; } return sum ; }
Ref: 
ll getSum ( int n , int d ) { ll sum = 0 ; while ( d <= n ) { sum += d ; d += 10 ; } return sum ; }
Hyp: 
int digSum ( int n , int d ) { int sum = 0 ; while ( d <= n ) { sum += d ; d += 10 ; } return sum ; }

BLEU: 86.76
Edit Sim: 9


Src: 
function compute ( a , N , K ) { let eqVal = new Map ( ) ; let maxX = 0 ; for ( let i = 0 ; i < N ; i ++ ) { let val = a [ i ] % K ; val = ( val == 0 ? 0 : K - val ) ; if ( val == 0 ) continue ; if ( eqVal . has ( val ) ) { let numVal = eqVal . get ( val ) ; maxX = Math . max ( maxX , val + ( K * numVal ) ) ; eqVal . set ( val , eqVal . get ( val ) + 1 ) ; } else { eqVal . set ( val , 1 ) ; maxX = Math . max ( maxX , val ) ; } } document . write ( maxX == 0 ? 0 : maxX + 1 ) ; }
Ref: 
void compute ( int a [ ] , int N , int K ) { map < long , long > eqVal ; long maxX = 0 ; for ( int i = 0 ; i < N ; i ++ ) { long val = a [ i ] % K ; val = ( val == 0 ? 0 : K - val ) ; if ( val == 0 ) continue ; if ( eqVal . find ( val ) != eqVal . end ( ) ) { long numVal = eqVal [ val ] ; maxX = max ( maxX , val + ( K * numVal ) ) ; eqVal [ val ] ++ ; } else { eqVal [ val ] ++ ; maxX = max ( maxX , val ) ; } } cout << ( maxX == 0 ? 0 : maxX + 1 ) << endl ; }
Hyp: 
void compute ( int a [ ] , int N , int K ) { unordered_map < int , int > eqVal ; int maxX = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int val = a [ i ] % K ; val = ( val == 0 ? 0 : K - val ) ; if ( val == 0 ) continue ; if ( eqVal . find ( val ) != eqVal . end ( ) ) { int numVal = eqVal [ val ] ; maxX = max ( maxX , val + ( K * numVal ) ) ; eqVal [ val ] ++ ; } else { eqVal [ val ] = 1 ; maxX = max ( maxX , val ) ; } } cout << maxX == 0 ? 0 : maxX + 1 ; }

BLEU: 85.25
Edit Sim: 40


Src: 
function Perimeter ( s , n ) { var perimeter = 1 ; perimeter = n * s ; return perimeter ; }
Ref: 
float Perimeter ( float s , int n ) { float perimeter = 1 ; perimeter = n * s ; return perimeter ; }
Hyp: 
int Perimeter ( int s , int n ) { int perimeter = 1 ; perimeter = n * s ; return perimeter ; }

BLEU: 75.62
Edit Sim: 12


Src: 
function Area ( a , b ) { if ( a < 0 && b < 0 ) return - 1 ; let h = Math . sqrt ( ( ( Math . pow ( a , 2 ) + Math . pow ( b , 2 ) ) / ( Math . pow ( a , 2 ) * Math . pow ( b , 2 ) ) ) ) ; let A = 0.70477 * Math . pow ( h , 2 ) ; return A ; }
Ref: 
float Area ( float a , float b ) { if ( a < 0 && b < 0 ) return -1 ; float h = sqrt ( ( ( pow ( a , 2 ) + pow ( b , 2 ) ) / ( pow ( a , 2 ) * pow ( b , 2 ) ) ) ) ; float A = 0.70477 * pow ( h , 2 ) ; return A ; }
Hyp: 
float Area ( float a , float b ) { if ( a < 0 && b < 0 ) return -1 ; float h = sqrt ( ( ( pow ( a , 2 ) + pow ( b , 2 ) ) / ( pow ( a , 2 ) * pow ( b , 2 ) ) ) ; float A = 0.70477 * pow ( h , 2 ) ; return A ; }

BLEU: 98.73
Edit Sim: 2


Src: 
function solve ( values , salary ) { var ret = 1 ; var amt = 0 ; values . sort ( ( a , b ) => a - b ) ; salary . sort ( ( a , b ) => a - b ) ; while ( salary . length ) { while ( values . length && values [ values . length - 1 ] >= salary [ salary . length - 1 ] ) { amt ++ ; values . pop ( ) ; } if ( amt == 0 ) return 0 ; ret *= amt -- ; ret %= MOD ; salary . pop ( ) ; } return ret ; }
Ref: 
int solve ( vector < int > & values , vector < int > & salary ) { long long ret = 1 ; int amt = 0 ; sort ( values . begin ( ) , values . end ( ) ) ; sort ( salary . begin ( ) , salary . end ( ) ) ; while ( salary . size ( ) ) { while ( values . size ( ) && values . back ( ) >= salary . back ( ) ) { amt ++ ; values . pop_back ( ) ; } if ( amt == 0 ) return 0 ; ret *= amt -- ; ret %= MOD ; salary . pop_back ( ) ; } return ret ; }
Hyp: 
int solve ( stack < int > & values , stack < int > & salary ) { int ret = 1 ; int amt = 0 ; sort ( values . begin ( ) , values . end ( ) ) ; sort ( salary . begin ( ) , salary . end ( ) ) ; while ( salary . size ( ) ) { while ( values . size ( ) && values [ values . size ( ) - 1 ] >= salary [ salary . size ( ) - 1 ] ) { amt ++ ; values . pop ( ) ; } if ( amt == 0 ) return 0 ; ret *= amt -- ; ret %= MOD ; salary . pop ( ) ; } return ret ; }

BLEU: 77.05
Edit Sim: 68


Src: 
function Bubble_Sort ( arr , n ) { for ( var i = 1 ; i < n ; ++ i ) { for ( var j = 0 ; j <= ( n - i - 1 ) ; ++ j ) { if ( arr [ j ] > arr [ j + 1 ] ) { var temm = arr [ j ] ; arr [ j ] = arr [ j + 1 ] ; arr [ j + 1 ] = temm ; } } } } var n = 5 ; var arr = [ 2 , 0 , 1 , 4 , 3 ] ; Bubble_Sort ( arr , n ) ; document . write ( " " ) ; for ( var i = 0 ; i < n ; i ++ ) { document . write ( arr [ i ] + " " ) ; }
Ref: 
void Bubble_Sort ( int arr [ ] , int n ) { for ( int i = 1 ; i < n ; ++ i ) { for ( int j = 0 ; j <= ( n - i - 1 ) ; ++ j ) { if ( arr [ j ] > arr [ j + 1 ] ) swap ( arr [ j ] , arr [ j + 1 ] ) ; } } }
Hyp: 
void Bubble_Sort ( int arr [ ] , int n ) { for ( int i = 1 ; i < n ; ++ i ) { for ( int j = 0 ; j <= ( n - i - 1 ) ; ++ j ) { if ( arr [ j ] > arr [ j + 1 ] ) { int temm = arr [ j ] ; arr [ j ] = arr [ j + 1 ] ; arr [ j + 1 ] = temm ; } } } }

BLEU: 74.2
Edit Sim: 47


Src: 
function maxSubsequenceLen ( s , K ) { var N = s . length ; var start = 0 , end = 0 ; var S = s . split ( ' ' ) ; S . sort ( ) ; var ans = Number . MIN_VALUE , sum = 0 ; for ( end = 0 ; end < N ; end ++ ) { sum = sum + ( S [ end ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ) ; while ( sum + K < ( S [ end ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ) * ( end - start + 1 ) ) { sum = sum - ( S [ start ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ) ; start ++ ; } ans = Math . max ( ans , end - start + 1 ) ; } document . write ( ans ) ; }
Ref: 
void maxSubsequenceLen ( string S , int K ) { int N = S . length ( ) ; int start = 0 , end = 0 ; sort ( S . begin ( ) , S . end ( ) ) ; int ans = INT_MIN , sum = 0 ; for ( end = 0 ; end < N ; end ++ ) { sum = sum + ( S [ end ] - ' a ' ) ; while ( sum + K < ( S [ end ] - ' a ' ) * ( end - start + 1 ) ) { sum = sum - ( S [ start ] - ' a ' ) ; start ++ ; } ans = max ( ans , end - start + 1 ) ; } cout << ans ; }
Hyp: 
int maxSubsequenceLen ( string s , int K ) { int N = s . length ( ) ; int start = 0 , end = 0 ; sort ( S . begin ( ) , S . end ( ) ) ; int ans = INT_MIN , sum = 0 ; for ( end = 0 ; end < N ; end ++ ) { sum = sum + ( S [ end ] - ' a ' ) ; while ( sum + K < ( S [ end ] - ' a ' ) * ( end - start + 1 ) ) { sum = sum - ( S [ start ] - ' a ' ) ; start ++ ; } ans = max ( ans , end - start + 1 ) ; } cout << ans ; }

BLEU: 95.82
Edit Sim: 6


Src: 
function countSubSeq ( str , len ) { var ans = 0 ; var mul = 1 ; for ( var i = 0 ; i < len ; i ++ ) { if ( str [ i ] == ' ' ) ans += mul ; mul *= 2 ; } return ans ; }
Ref: 
int countSubSeq ( string str , int len ) { int ans = 0 ; int mul = 1 ; for ( int i = 0 ; i < len ; i ++ ) { if ( str [ i ] == '0' ) ans += mul ; mul *= 2 ; } return ans ; }
Hyp: 
int countSubSeq ( string str , int len ) { int ans = 0 ; int mul = 1 ; for ( int i = 0 ; i < len ; i ++ ) { if ( str [ i ] == ' ( ' ) ans += mul ; mul *= 2 ; } return ans ; }

BLEU: 92.25
Edit Sim: 3


Src: 
function findNumber ( n , m ) { var num = ( m - 1 ) * 9 + n ; return num ; }
Ref: 
int findNumber ( int n , int m ) { int num = ( m - 1 ) * 9 + n ; return num ; }
Hyp: 
int findNumber ( int n , int m ) { int num = ( m - 1 ) * 9 + n ; return num ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function evenSum ( n ) { let curr = 2 , sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { sum += curr ; curr += 2 ; } return sum ; }
Ref: 
int evenSum ( int n ) { int curr = 2 , sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { sum += curr ; curr += 2 ; } return sum ; }
Hyp: 
int evenSum ( int n ) { int curr = 2 , sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { sum += curr ; curr += 2 ; } return sum ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countPair ( a , b ) { var s = ( b . toString ( ) ) ; var i ; for ( i = 0 ; i < s . length ; i ++ ) { if ( s [ i ] != ' ' ) break ; } var result ; if ( i == s . length ) result = a * s . length ; else result = a * ( s . length - 1 ) ; return result ; }
Ref: 
int countPair ( int a , int b ) { string s = to_string ( b ) ; int i ; for ( i = 0 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] != '9' ) break ; } int result ; if ( i == s . length ( ) ) result = a * s . length ( ) ; else result = a * ( s . length ( ) - 1 ) ; return result ; }
Hyp: 
int countPair ( int a , int b ) { string s = to_string ( b ) ; int i ; for ( i = 0 ; i < s . size ( ) ; i ++ ) { if ( s [ i ] != '1' ) break ; } int result ; if ( i == s . size ( ) ) result = a * ( s . size ( ) - 1 ) ; return result ; }

BLEU: 76.49
Edit Sim: 53


Src: 
function IsEvenPath ( Source , Destination ) { let x_dif = Math . abs ( Source [ 0 ] - Destination [ 0 ] ) ; let y_dif = Math . abs ( Source [ 1 ] - Destination [ 1 ] ) ; let minsteps = x_dif + y_dif ; if ( minsteps % 2 == 0 ) document . write ( " " ) ; else document . write ( " " ) ; }
Ref: 
void IsEvenPath ( int Source [ ] , int Destination [ ] ) { int x_dif = abs ( Source [ 0 ] - Destination [ 0 ] ) ; int y_dif = abs ( Source [ 1 ] - Destination [ 1 ] ) ; int minsteps = x_dif + y_dif ; if ( minsteps % 2 == 0 ) cout << " Yes " ; else cout << " No " ; }
Hyp: 
void IsEvenPath ( int Source [ ] , int Destination [ ] ) { int x_dif = abs ( Source [ 0 ] - Destination [ 0 ] ) ; int y_dif = abs ( Source [ 1 ] - Destination [ 1 ] ) ; int minsteps = x_dif + y_dif ; if ( minsteps % 2 == 0 ) cout << " Even " ; else cout << " Odd " ; }

BLEU: 93.19
Edit Sim: 6


Src: 
function maxAND ( L , R ) { if ( L == R ) return L ; else if ( ( R - L ) == 1 ) return ( R & L ) ; else { if ( ( ( R - 1 ) & R ) > ( ( R - 2 ) & ( R - 1 ) ) ) return ( ( R - 1 ) & R ) ; else return ( ( R - 2 ) & ( R - 1 ) ) ; } }
Ref: 
int maxAND ( int L , int R ) { if ( L == R ) return L ; else if ( ( R - L ) == 1 ) return ( R & L ) ; else { if ( ( ( R - 1 ) & R ) > ( ( R - 2 ) & ( R - 1 ) ) ) return ( ( R - 1 ) & R ) ; else return ( ( R - 2 ) & ( R - 1 ) ) ; } }
Hyp: 
int maxAND ( int L , int R ) { if ( L == R ) return L ; else if ( ( R - L ) == 1 ) return ( R & L ) ; else { if ( ( ( R - 1 ) & R ) > ( ( R - 2 ) & ( R - 1 ) ) ) return ( ( R - 1 ) & R ) ; else return ( ( R - 2 ) & ( R - 1 ) ) ; } }

BLEU: 100.0
Edit Sim: 0


Src: 
function cntSubarr ( arr , N ) { var res = 0 ; var prefixXor = 0 ; var i , j ; for ( i = 0 ; i < N - 1 ; i ++ ) { prefixXor = arr [ i ] ; for ( j = i + 1 ; j < N ; j ++ ) { prefixXor ^= arr [ j ] ; if ( prefixXor == 0 && ( j - i + 1 ) % 2 == 0 ) { res ++ ; } } } return res ; }
Ref: 
int cntSubarr ( int arr [ ] , int N ) { int res = 0 ; int prefixXor = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { prefixXor = arr [ i ] ; for ( int j = i + 1 ; j < N ; j ++ ) { prefixXor ^= arr [ j ] ; if ( prefixXor == 0 && ( j - i + 1 ) % 2 == 0 ) { res ++ ; } } } return res ; }
Hyp: 
int cntSubarr ( int arr [ ] , int N ) { int res = 0 ; int prefixXor = 0 ; int i , j ; for ( i = 0 ; i < N - 1 ; i ++ ) { prefixXor = arr [ i ] ; for ( j = i + 1 ; j < N ; j ++ ) { prefixXor ^= arr [ j ] ; if ( prefixXor == 0 && ( j - i + 1 ) % 2 == 0 ) { res ++ ; } } } return res ; }

BLEU: 91.77
Edit Sim: 19


Src: 
function catalan ( n ) { let cat_ = 1 ; document . write ( cat_ + " " ) ; for ( let i = 1 ; i < n ; i ++ ) { cat_ *= ( 4 * i - 2 ) ; cat_ /= ( i + 1 ) ; document . write ( cat_ + " " ) ; } }
Ref: 
void catalan ( int n ) { cpp_int cat_ = 1 ; cout << cat_ << " ▁ " ; for ( cpp_int i = 1 ; i < n ; i ++ ) { cat_ *= ( 4 * i - 2 ) ; cat_ /= ( i + 1 ) ; cout << cat_ << " ▁ " ; } }
Hyp: 
void catalan ( int n ) { int cat_ = 1 ; cout << cat_ << " ▁ " ; for ( int i = 1 ; i < n ; i ++ ) { cat_ *= ( 4 * i - 2 ) ; cat_ /= ( i + 1 ) ; cout << cat_ << " ▁ " ; } }

BLEU: 91.86
Edit Sim: 8


Src: 
function find_index ( arr , n , K ) { for ( let i = 0 ; i < n ; i ++ ) if ( arr [ i ] == K ) return i ; else if ( arr [ i ] > K ) return i ; return n ; }
Ref: 
int find_index ( int arr [ ] , int n , int K ) { for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == K ) return i ; else if ( arr [ i ] > K ) return i ; return n ; }
Hyp: 
int find_index ( int arr [ ] , int n , int K ) { for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == K ) return i ; else if ( arr [ i ] > K ) return i ; return n ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function getSlope ( m ) { return m ; }
Ref: 
double getSlope ( double m ) { return m ; }
Hyp: 
double getSlope ( double m ) { return m ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function printMaxActivities ( s , f , n ) { let i , j ; document . write ( " " ) ; i = 0 ; document . write ( i + " " ) ; for ( j = 1 ; j < n ; j ++ ) { if ( s [ j ] >= f [ i ] ) { document . write ( j + " " ) ; i = j ; } } }
Ref: 
void printMaxActivities ( int s [ ] , int f [ ] , int n ) { int i , j ; cout << " Following ▁ activities ▁ are ▁ selected ▁ " << endl ; i = 0 ; cout << " ▁ " << i ; for ( j = 1 ; j < n ; j ++ ) { if ( s [ j ] >= f [ i ] ) { cout << " ▁ " << j ; i = j ; } } }
Hyp: 
void printMaxActivities ( int s [ ] , int f [ ] , int n ) { int i , j ; cout << " Maximum ▁Activities ▁ = ▁ " ; i = 0 ; cout << i << " ▁ " ; for ( j = 1 ; j < n ; j ++ ) { if ( s [ j ] >= f [ i ] ) { cout << j << " ▁ " ; i = j ; } } }

BLEU: 78.88
Edit Sim: 45


Src: 
function heptagonalNumber ( n ) { return parseInt ( ( ( 5 * n * n ) - ( 3 * n ) ) / 2 ) ; }
Ref: 
int heptagonalNumber ( int n ) { return ( ( 5 * n * n ) - ( 3 * n ) ) / 2 ; }
Hyp: 
int heptagonalNumber ( int n ) { return ( ( 5 * n * n ) - ( 3 * n ) ) / 2 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function maxValue ( n ) { return n ; }
Ref: 
int maxValue ( int n ) { return n ; }
Hyp: 
int maxValue ( int n ) { return ( n ) ; }

BLEU: 65.92
Edit Sim: 4


Src: 
function rainDayProbability ( a , n ) { let count = 0 , m ; for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 1 ) count ++ ; } m = count / n ; return m ; }
Ref: 
float rainDayProbability ( int a [ ] , int n ) { float count = 0 , m ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 1 ) count ++ ; } m = count / n ; return m ; }
Hyp: 
double rainDayProbability ( int a [ ] , int n ) { int count = 0 , m ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 1 ) count ++ ; } m = count / n ; return m ; }

BLEU: 93.74
Edit Sim: 10


Src: 
function countDigits ( n ) { let ans = 0 ; for ( let i = 1 ; i <= n ; i ++ ) ans += Math . log10 ( i ) ; ans = ans * n ; return 1 + Math . floor ( ans ) ; }
Ref: 
int countDigits ( int n ) { double ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) ans += log10 ( i ) ; ans = ans * n ; return 1 + floor ( ans ) ; }
Hyp: 
int countDigits ( int n ) { long int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) ans += log10 ( i ) ; ans = ans * n ; return 1 + ans ; }

BLEU: 83.9
Edit Sim: 17


Src: 
function squareSum ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) sum += ( 2 * i ) * ( 2 * i ) ; return sum ; }
Ref: 
int squareSum ( int n ) { return 2 * n * ( n + 1 ) * ( 2 * n + 1 ) / 3 ; }
Hyp: 
int squareSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += ( 2 * i ) * ( 2 * i ) ; return sum ; }

BLEU: 26.64
Edit Sim: 60


Src: 
function SubMasks ( N ) { for ( let S = N ; S > 0 ; S = ( S - 1 ) & N ) { document . write ( S + " " ) ; } }
Ref: 
void SubMasks ( int N ) { for ( int S = N ; S ; S = ( S - 1 ) & N ) { cout << S << " ▁ " ; } }
Hyp: 
void SubMasks ( int N ) { for ( int S = N ; S > 0 ; S = ( S - 1 ) & N ) { cout << S << " ▁ " ; } }

BLEU: 90.76
Edit Sim: 4


Src: 
function log_a_to_base_b ( a , b ) { return parseInt ( Math . log ( a ) / Math . log ( b ) ) ; }
Ref: 
int log_a_to_base_b ( int a , int b ) { return log ( a ) / log ( b ) ; }
Hyp: 
int log_a_to_base_b ( int a , int b ) { return log ( a ) / log ( b ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function nonFibonacci ( n ) { let prevPrev = 1 , prev = 2 , curr = 3 ; while ( n > 0 ) { prevPrev = prev ; prev = curr ; curr = prevPrev + prev ; n = n - ( curr - prev - 1 ) ; } n = n + ( curr - prev - 1 ) ; return prev + n ; }
Ref: 
int nonFibonacci ( int n ) { int prevPrev = 1 , prev = 2 , curr = 3 ; while ( n > 0 ) { prevPrev = prev ; prev = curr ; curr = prevPrev + prev ; n = n - ( curr - prev - 1 ) ; } n = n + ( curr - prev - 1 ) ; return prev + n ; }
Hyp: 
int nonFibonacci ( int n ) { int prevPrev = 1 , prev = 2 , curr = 3 ; while ( n > 0 ) { prevPrev = prev ; prev = curr ; curr = prevPrev + prev ; n = n - ( curr - prev - 1 ) ; } n = n + ( curr - prev - 1 ) ; return prev + n ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function arrayDivisionByTwo ( arr , n ) { let cnt = 0 ; let ans = Number . MAX_VALUE ; for ( let i = 0 ; i < n ; i ++ ) { cnt = 0 ; while ( arr [ i ] % 2 == 0 ) { arr [ i ] = Math . floor ( arr [ i ] / 2 ) ; cnt ++ ; } ans = Math . min ( ans , cnt ) ; } return ans ; }
Ref: 
int arrayDivisionByTwo ( int arr [ ] , int n ) { int cnt = 0 ; int ans = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { cnt = 0 ; while ( arr [ i ] % 2 == 0 ) { arr [ i ] = arr [ i ] / 2 ; cnt ++ ; } ans = min ( ans , cnt ) ; } return ans ; }
Hyp: 
int arrayDivisionByTwo ( int arr [ ] , int n ) { int cnt = 0 ; int ans = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { cnt = 0 ; while ( arr [ i ] % 2 == 0 ) { arr [ i ] = arr [ i ] / 2 ; cnt ++ ; } ans = min ( ans , cnt ) ; } return ans ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function get_permutation ( arr , n ) { arr . sort ( ) ; var result = 0 ; for ( i = 0 ; i < n ; i ++ ) { result += Math . abs ( arr [ i ] - ( i + 1 ) ) ; } return result ; }
Ref: 
int get_permutation ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { result += abs ( arr [ i ] - ( i + 1 ) ) ; } return result ; }
Hyp: 
int get_permutation ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { result += abs ( arr [ i ] - ( i + 1 ) ) ; } return result ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function count9s ( number ) { let count = 0 ; let n = ( number . length ) ; for ( let i = 0 ; i < n ; i ++ ) { let sum = number [ i ] - ' ' ; if ( number [ i ] == ' ' ) { count ++ ; } for ( let j = i + 1 ; j < n ; j ++ ) { sum = ( sum + number [ j ] - ' ' ) % 9 ; if ( sum == 0 ) { count ++ ; } } } return count ; }
Ref: 
int count9s ( char number [ ] ) { int n = strlen ( number ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( number [ i ] == '9' ) count ++ ; for ( int j = i + 1 ; j < n ; j ++ ) { sum = ( sum + number [ j ] - '0' ) % 9 ; if ( sum == 0 ) count ++ ; } } return count ; }
Hyp: 
int count9s ( string number ) { int count = 0 , n = ( int ) number . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int sum = number [ i ] - '0' ; if ( number [ i ] == '0' ) { count ++ ; } for ( int j = i + 1 ; j < n ; j ++ ) { sum = ( sum + number [ j ] - '0' ) % 9 ; if ( sum == 0 ) { count ++ ; } } } return count ; }

BLEU: 65.29
Edit Sim: 78


Src: 
function findMaxK ( N ) { let K = N ; for ( let i = N - 1 ; i >= 0 ; i -- ) { K &= i ; if ( K == 0 ) { return i ; } } return 0 ; }
Ref: 
int findMaxK ( int N ) { int K = N ; for ( int i = N - 1 ; i >= 0 ; i -- ) { K &= i ; if ( K == 0 ) { return i ; } } return 0 ; }
Hyp: 
int findMaxK ( int N ) { int K = N ; for ( int i = N - 1 ; i >= 0 ; i -- ) { K &= i ; if ( K == 0 ) { return i ; } } return 0 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function distIntegers ( L , R ) { return 2 * R - 2 * L + 1 ; }
Ref: 
int distIntegers ( int L , int R ) { return 2 * R - 2 * L + 1 ; }
Hyp: 
int distIntegers ( int L , int R ) { return 2 * R - 2 * L + 1 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function longestPalSubstr ( str ) { var n = str . length ; var maxLength = 1 , start = 0 ; for ( var i = 0 ; i < str . length ; i ++ ) { for ( var j = i ; j < str . length ; j ++ ) { var flag = 1 ; for ( var k = 0 ; k < ( j - i + 1 ) / 2 ; k ++ ) if ( str [ i + k ] != str [ j - k ] ) flag = 0 ; if ( flag && ( j - i + 1 ) > maxLength ) { start = i ; maxLength = j - i + 1 ; } } } return maxLength ; }
Ref: 
int longestPalSubstr ( string str ) { int n = str . size ( ) ; int maxLength = 1 , start = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { for ( int j = i ; j < str . length ( ) ; j ++ ) { int flag = 1 ; for ( int k = 0 ; k < ( j - i + 1 ) / 2 ; k ++ ) if ( str [ i + k ] != str [ j - k ] ) flag = 0 ; if ( flag && ( j - i + 1 ) > maxLength ) { start = i ; maxLength = j - i + 1 ; } } } return maxLength ; }
Hyp: 
int longestPalSubstr ( string str ) { int n = str . length ( ) ; int maxLength = 1 , start = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < str . length ( ) ; j ++ ) { int flag = 1 ; for ( int k = 0 ; k < ( j - i + 1 ) / 2 ; k ++ ) if ( str [ i + k ] != str [ j - k ] ) flag = 0 ; if ( flag && ( j - i + 1 ) > maxLength ) { start = i ; maxLength = j - i + 1 ; } } } return maxLength ; }

BLEU: 95.25
Edit Sim: 21


Src: 
function GenerateArray ( N , X ) { let prev_xor = X ; for ( let i = 1 ; i <= N ; i ++ ) { document . write ( ( i ^ prev_xor ) ) ; if ( i != N ) { document . write ( " " ) ; } prev_xor = i ; } }
Ref: 
void GenerateArray ( int N , int X ) { int prev_xor = X ; for ( int i = 1 ; i <= N ; i ++ ) { cout << ( i ^ prev_xor ) ; if ( i != N ) { cout << " ▁ " ; } prev_xor = i ; } }
Hyp: 
void GenerateArray ( int N , int X ) { int prev_xor = X ; for ( int i = 1 ; i <= N ; i ++ ) { cout << ( i ^ prev_xor ) ; if ( i != N ) { cout << " Impossible " ; } prev_xor = i ; } }

BLEU: 95.59
Edit Sim: 10


Src: 
function findPair ( arr , size , n ) { let i = 0 ; let j = 1 ; while ( i < size && j < size ) { if ( i != j && arr [ j ] - arr [ i ] == n ) { document . write ( " " + arr [ i ] + " " + arr [ j ] + " " ) ; return true ; } else if ( arr [ j ] - arr [ i ] < n ) j ++ ; else i ++ ; } document . write ( " " ) ; return false ; }
Ref: 
bool findPair ( int arr [ ] , int size , int n ) { int i = 0 ; int j = 1 ; while ( i < size && j < size ) { if ( i != j && arr [ j ] - arr [ i ] == n ) { cout << " Pair ▁ Found : ▁ ( " << arr [ i ] << " , ▁ " << arr [ j ] << " ) " ; return true ; } else if ( arr [ j ] - arr [ i ] < n ) j ++ ; else i ++ ; } cout << " No ▁ such ▁ pair " ; return false ; }
Hyp: 
bool findPair ( int arr [ ] , int size , int n ) { int i = 0 ; int j = 1 ; while ( i < size && j < size ) { if ( i != j && arr [ j ] - arr [ i ] == n ) { cout << " ( " << arr [ i ] << " , ▁ " << arr [ j ] << " ) " << endl ; return true ; } else if ( arr [ j ] - arr [ i ] < n ) j ++ ; else i ++ ; } cout << " ( " ) ; return false ; }

BLEU: 87.68
Edit Sim: 41


Src: 
function largestSquare ( matrix , R , C , q_i , q_j , K , Q ) { let countDP = new Array ( R ) ; for ( let i = 0 ; i < R ; i ++ ) { countDP [ i ] = new Array ( C ) ; for ( let j = 0 ; j < C ; j ++ ) countDP [ i ] [ j ] = 0 ; } countDP [ 0 ] [ 0 ] = matrix [ 0 ] [ 0 ] ; for ( let i = 1 ; i < R ; i ++ ) countDP [ i ] [ 0 ] = countDP [ i - 1 ] [ 0 ] + matrix [ i ] [ 0 ] ; for ( let j = 1 ; j < C ; j ++ ) countDP [ 0 ] [ j ] = countDP [ 0 ] [ j - 1 ] + matrix [ 0 ] [ j ] ; for ( let i = 1 ; i < R ; i ++ ) for ( let j = 1 ; j < C ; j ++ ) countDP [ i ] [ j ] = matrix [ i ] [ j ] + countDP [ i - 1 ] [ j ] + countDP [ i ] [ j - 1 ] - countDP [ i - 1 ] [ j - 1 ] ; for ( let q = 0 ; q < Q ; q ++ ) { let i = q_i [ q ] ; let j = q_j [ q ] ; let min_dist = Math . min ( Math . min ( i , j ) , Math . min ( R - i - 1 , C - j - 1 ) ) ; let ans = - 1 , l = 0 , u = min_dist ; while ( l <= u ) { let mid = Math . floor ( ( l + u ) / 2 ) ; let x1 = i - mid , x2 = i + mid ; let y1 = j - mid , y2 = j + mid ; let count = countDP [ x2 ] [ y2 ] ; if ( x1 > 0 ) count -= countDP [ x1 - 1 ] [ y2 ] ; if ( y1 > 0 ) count -= countDP [ x2 ] [ y1 - 1 ] ; if ( x1 > 0 && y1 > 0 ) count += countDP [ x1 - 1 ] [ y1 - 1 ] ; if ( count <= K ) { ans = 2 * mid + 1 ; l = mid + 1 ; } else u = mid - 1 ; } document . write ( ans + " " ) ; } }
Ref: 
void largestSquare ( int matrix [ ] [ MAX ] , int R , int C , int q_i [ ] , int q_j [ ] , int K , int Q ) { int countDP [ R ] [ C ] ; memset ( countDP , 0 , sizeof ( countDP ) ) ; countDP [ 0 ] [ 0 ] = matrix [ 0 ] [ 0 ] ; for ( int i = 1 ; i < R ; i ++ ) countDP [ i ] [ 0 ] = countDP [ i - 1 ] [ 0 ] + matrix [ i ] [ 0 ] ; for ( int j = 1 ; j < C ; j ++ ) countDP [ 0 ] [ j ] = countDP [ 0 ] [ j - 1 ] + matrix [ 0 ] [ j ] ; for ( int i = 1 ; i < R ; i ++ ) for ( int j = 1 ; j < C ; j ++ ) countDP [ i ] [ j ] = matrix [ i ] [ j ] + countDP [ i - 1 ] [ j ] + countDP [ i ] [ j - 1 ] - countDP [ i - 1 ] [ j - 1 ] ; for ( int q = 0 ; q < Q ; q ++ ) { int i = q_i [ q ] ; int j = q_j [ q ] ; int min_dist = min ( min ( i , j ) , min ( R - i - 1 , C - j - 1 ) ) ; int ans = -1 , l = 0 , u = min_dist ; while ( l <= u ) { int mid = ( l + u ) / 2 ; int x1 = i - mid , x2 = i + mid ; int y1 = j - mid , y2 = j + mid ; int count = countDP [ x2 ] [ y2 ] ; if ( x1 > 0 ) count -= countDP [ x1 - 1 ] [ y2 ] ; if ( y1 > 0 ) count -= countDP [ x2 ] [ y1 - 1 ] ; if ( x1 > 0 && y1 > 0 ) count += countDP [ x1 - 1 ] [ y1 - 1 ] ; if ( count <= K ) { ans = 2 * mid + 1 ; l = mid + 1 ; } else u = mid - 1 ; } cout << ans << " STRNEWLINE " ; } }
Hyp: 
void largestSquare ( int matrix [ ] [ R ] , int C , int q_i [ ] , int q_j [ ] , int K , int Q ) { int countDP [ R ] [ C ] ; memset ( countDP , 0 , sizeof ( countDP ) ) ; for ( int i = 0 ; i < R ; i ++ ) countDP [ i ] [ 0 ] = matrix [ 0 ] [ 0 ] ; for ( int j = 1 ; j < C ; j ++ ) countDP [ i ] [ j ] = countDP [ 0 ] [ j - 1 ] + matrix [ 0 ] [ j ] ; for ( int i = 1 ; i < R ; i ++ ) for ( int j = 1 ; j < C ; j ++ ) countDP [ i ] [ j ] = matrix [ i ] [ j ] + countDP [ i - 1 ] [ j ] + countDP [ i ] [ j - 1 ] - countDP [ i - 1 ] [ j - 1 ] ; for ( int q = 0 ; q < Q ; q ++ ) { int mid = ( l + u ) / 2 ; int x1 = i - mid , x2 = i + mid ; int y1 = j - mid , y2 = j + mid ; int count = countDP [ x2 ] [ y2 ] ; if ( x1 > 0 ) count -= countDP [ x1 - 1 ] [ y2 ] ; if ( y1 > 0 ) count -= countDP [ x2 ] [ y1 - 1 ] ; if ( x1 > 0 && y1 > 0 ) count += countDP [ x1 - 1 ] [ y1 - 1 ] ; if ( count <= K ) { ans = 2 * mid + 1 ; l = 2 * mid + 1 ; } ; } }

BLEU: 71.38
Edit Sim: 301


Src: 
function calculate_sum ( a , N ) { m = N / a ; sum = m * ( m + 1 ) / 2 ; ans = a * sum ; return ans ; }
Ref: 
int calculate_sum ( int a , int N ) { int m = N / a ; int sum = m * ( m + 1 ) / 2 ; int ans = a * sum ; return ans ; }
Hyp: 
int calculate_sum ( int a , int N ) { int m , sum , ans ; m = N / a ; sum = m * ( m + 1 ) / 2 ; ans = a * sum ; return ans ; }

BLEU: 77.55
Edit Sim: 22


Src: 
function precompute ( ) { F [ 1 ] = 2 ; F [ 2 ] = 3 ; F [ 3 ] = 4 ; for ( var i = 4 ; i < N ; i ++ ) F [ i ] = ( F [ i - 1 ] + F [ i - 2 ] ) % MOD ; }
Ref: 
void precompute ( ) { F [ 1 ] = 2 ; F [ 2 ] = 3 ; F [ 3 ] = 4 ; for ( int i = 4 ; i < N ; i ++ ) F [ i ] = ( F [ i - 1 ] + F [ i - 2 ] ) % MOD ; }
Hyp: 
void precompute ( ) { F [ 1 ] = 2 ; F [ 2 ] = 3 ; F [ 3 ] = 4 ; for ( int i = 4 ; i < N ; i ++ ) F [ i ] = ( F [ i - 1 ] + F [ i - 2 ] ) % MOD ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findLUSlength ( a , b ) { if ( a === b ) return 0 ; return Math . max ( a . length , b . length ) ; }
Ref: 
int findLUSlength ( string a , string b ) { if ( ! a . compare ( b ) ) return 0 ; return max ( a . length ( ) , b . length ( ) ) ; }
Hyp: 
int findLUSlength ( string a , string b ) { if ( a == b ) return 0 ; return max ( a . length ( ) , b . length ( ) ) ; }

BLEU: 79.71
Edit Sim: 15


Src: 
function MinOfCubed ( k ) { if ( k < 8 ) return k ; let res = k ; for ( let i = 1 ; i <= k ; i ++ ) { if ( ( i * i * i ) > k ) return res ; res = Math . min ( res , MinOfCubed ( k - ( i * i * i ) ) + 1 ) ; } return res ; }
Ref: 
int MinOfCubed ( int k ) { if ( k < 8 ) return k ; int res = k ; for ( int i = 1 ; i <= k ; i ++ ) { if ( ( i * i * i ) > k ) return res ; res = min ( res , MinOfCubed ( k - ( i * i * i ) ) + 1 ) ; } return res ; }
Hyp: 
int MinOfCubed ( int k ) { if ( k < 8 ) return k ; int res = k ; for ( int i = 1 ; i <= k ; i ++ ) { if ( ( i * i * i ) > k ) return res ; res = min ( res , MinOfCubed ( k - ( i * i * i ) ) + 1 ) ; } return res ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function smallestEven ( n ) { if ( n == 1 ) return 0 ; return Math . pow ( 10 , n - 1 ) ; }
Ref: 
int smallestEven ( int n ) { if ( n == 1 ) return 0 ; return pow ( 10 , n - 1 ) ; }
Hyp: 
int smallestEven ( int n ) { if ( n == 1 ) return 0 ; return pow ( 10 , n - 1 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countWays ( index , cnt , dp , n , m , k ) { if ( index == n ) { if ( cnt == k ) return 1 ; else return 0 ; } if ( dp [ index ] [ cnt ] != - 1 ) return dp [ index ] [ cnt ] ; let ans = 0 ; ans += countWays ( index + 1 , cnt , dp , n , m , k ) ; ans += ( m - 1 ) * countWays ( index + 1 , cnt + 1 , dp , n , m , k ) ; return dp [ index ] [ cnt ] = ans ; } let n = 3 , m = 3 , k = 2 ; let dp = new Array ( n + 1 ) ; for ( let i = 0 ; i < n + 1 ; i ++ ) { dp [ i ] = new Array ( max ) ; for ( let j = 0 ; j < max ; j ++ ) dp [ i ] [ j ] = - 1 ; }
Ref: 
int countWays ( int index , int cnt , int dp [ ] [ max ] , int n , int m , int k ) { if ( index == n ) { if ( cnt == k ) return 1 ; else return 0 ; } if ( dp [ index ] [ cnt ] != -1 ) return dp [ index ] [ cnt ] ; int ans = 0 ; ans += countWays ( index + 1 , cnt , dp , n , m , k ) ; ans += ( m - 1 ) * countWays ( index + 1 , cnt + 1 , dp , n , m , k ) ; return dp [ index ] [ cnt ] = ans ; }
Hyp: 
int countWays ( int index , int cnt , int dp [ ] [ max ] , int n , int m , int k ) { if ( index == n ) { if ( cnt == k ) return 1 ; else return 0 ; } if ( dp [ index ] [ cnt ] != -1 ) return dp [ index ] [ cnt ] ; int ans = 0 ; ans += countWays ( index + 1 , cnt , dp , n , m , k ) ; ans += ( m - 1 ) * countWays ( index + 1 , cnt + 1 , dp , n , m , k ) ; return dp [ index ] [ cnt ] = ans ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function getBuckets ( arr , N ) { let availableWater = N * ( N - 1 ) / 2 ; arr . sort ( function ( a , b ) { return a - b } ) ; let i = 0 , sum = 0 ; while ( sum <= availableWater ) { sum += arr [ i ] ; i ++ ; } document . write ( i - 1 ) ; }
Ref: 
int getBuckets ( int arr [ ] , int N ) { int availableWater = N * ( N - 1 ) / 2 ; sort ( arr , arr + N ) ; int i = 0 , sum = 0 ; while ( sum <= availableWater ) { sum += arr [ i ] ; i ++ ; } cout << i - 1 ; }
Hyp: 
void getBuckets ( int arr [ ] , int N ) { int availableWater = N * ( N - 1 ) / 2 ; sort ( arr , arr + N ) ; int i = 0 , sum = 0 ; while ( sum <= availableWater ) { sum += arr [ i ] ; i ++ ; } cout << i - 1 ; }

BLEU: 98.52
Edit Sim: 4


Src: 
function printDistSum ( arr , n ) { var sum = 0 ; for ( var i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; var dp = Array . from ( Array ( n + 1 ) , ( ) => Array ( sum + 1 ) . fill ( 0 ) ) ; for ( var i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = true ; for ( var i = 1 ; i <= n ; i ++ ) { dp [ i ] [ arr [ i - 1 ] ] = true ; for ( var j = 1 ; j <= sum ; j ++ ) { if ( dp [ i - 1 ] [ j ] == true ) { dp [ i ] [ j ] = true ; dp [ i ] [ j + arr [ i - 1 ] ] = true ; } } } for ( var j = 0 ; j <= sum ; j ++ ) if ( dp [ n ] [ j ] == true ) document . write ( j + " " ) ; }
Ref: 
void printDistSum ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; bool dp [ n + 1 ] [ sum + 1 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; for ( int i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = true ; for ( int i = 1 ; i <= n ; i ++ ) { dp [ i ] [ arr [ i - 1 ] ] = true ; for ( int j = 1 ; j <= sum ; j ++ ) { if ( dp [ i - 1 ] [ j ] == true ) { dp [ i ] [ j ] = true ; dp [ i ] [ j + arr [ i - 1 ] ] = true ; } } } for ( int j = 0 ; j <= sum ; j ++ ) if ( dp [ n ] [ j ] == true ) cout << j << " ▁ " ; }
Hyp: 
void printDistSum ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; bool dp [ n + 1 ] [ sum + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = true ; for ( int i = 1 ; i <= n ; i ++ ) { dp [ i ] [ arr [ i - 1 ] ] = true ; for ( int j = 1 ; j <= sum ; j ++ ) { if ( dp [ i - 1 ] [ j ] == true ) { dp [ i ] [ j ] = true ; dp [ i ] [ j + arr [ i - 1 ] ] = true ; } } } for ( int j = 0 ; j <= sum ; j ++ ) if ( dp [ n ] [ j ] == true ) cout << j << " ▁ " ; }

BLEU: 93.82
Edit Sim: 36


Src: 
function solve ( i , par , a , n , k , current_ans ) { if ( par > k ) return ; if ( par == k && i == n - 1 ) { ans = Math . min ( ans , current_ans ) ; return ; } for ( let j = i + 1 ; j < n ; j ++ ) solve ( j , par + 1 , a , n , k , current_ans + ( a [ j ] - a [ i + 1 ] ) * ( a [ j ] - a [ i + 1 ] ) ) ; }
Ref: 
void solve ( int i , int par , int a [ ] , int n , int k , int current_ans ) { if ( par > k ) return ; if ( par == k && i == n - 1 ) { ans = min ( ans , current_ans ) ; return ; } for ( int j = i + 1 ; j < n ; j ++ ) solve ( j , par + 1 , a , n , k , current_ans + ( a [ j ] - a [ i + 1 ] ) * ( a [ j ] - a [ i + 1 ] ) ) ; }
Hyp: 
void solve ( int i , int par , int a [ ] , int n , int k , int current_ans ) { if ( par > k ) return ; if ( par == k && i == n - 1 ) { ans = min ( ans , current_ans ) ; return ; } for ( int j = i + 1 ; j < n ; j ++ ) solve ( j , par + 1 , a , n , k , current_ans + ( a [ j ] - a [ i + 1 ] ) * ( a [ j ] - a [ i + 1 ] ) ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function max_xor ( arr , n ) { let maxXor = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i + 1 ; j < n ; j ++ ) { maxXor = Math . max ( maxXor , arr [ i ] ^ arr [ j ] ) ; } } return maxXor ; }
Ref: 
int max_xor ( int arr [ ] , int n ) { int maxXor = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { maxXor = max ( maxXor , arr [ i ] ^ arr [ j ] ) ; } } return maxXor ; }
Hyp: 
int max_xor ( int arr [ ] , int n ) { int maxXor = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { maxXor = max ( maxXor , arr [ i ] ^ arr [ j ] ) ; } } return maxXor ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function isKAlternating ( s , k ) { if ( s . length < k ) return false ; var checker = 0 ; for ( var i = 0 ; i < k ; i ++ ) { var bitAtIndex = s [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ; if ( ( checker & ( 1 << bitAtIndex ) ) > 0 ) { return false ; } checker = checker | ( 1 << bitAtIndex ) ; } for ( var i = k ; i < s . length ; i ++ ) if ( s [ i - k ] != s [ i ] ) return false ; return true ; }
Ref: 
bool isKAlternating ( string s , int k ) { if ( s . length ( ) < k ) return false ; int checker = 0 ; for ( int i = 0 ; i < k ; i ++ ) { int bitAtIndex = s [ i ] - ' a ' ; if ( ( checker & ( 1 << bitAtIndex ) ) > 0 ) { return false ; } checker = checker | ( 1 << bitAtIndex ) ; } for ( int i = k ; i < s . length ( ) ; i ++ ) if ( s [ i - k ] != s [ i ] ) return false ; return true ; }
Hyp: 
bool isKAlternating ( string s , int k ) { if ( s . length ( ) < k ) return false ; int checker = 0 ; for ( int i = 0 ; i < k ; i ++ ) { int bitAtIndex = s [ i ] - ' a ' ; if ( ( checker & ( 1 << bitAtIndex ) ) > 0 ) { return false ; } checker = checker | ( 1 << bitAtIndex ) ; } for ( int i = k ; i < s . length ( ) ; i ++ ) if ( s [ i - k ] != s [ i ] ) return false ; return true ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function minNumber ( a , n , x ) { a . sort ( ) ; let k ; for ( k = 0 ; a [ parseInt ( ( n - 1 ) / 2 , 10 ) ] != x ; k ++ ) { a [ n ++ ] = x ; a . sort ( ) ; } return k ; }
Ref: 
int minNumber ( int a [ ] , int n , int x ) { sort ( a , a + n ) ; int k ; for ( k = 0 ; a [ ( n - 1 ) / 2 ] != x ; k ++ ) { a [ n ++ ] = x ; sort ( a , a + n ) ; } return k ; }
Hyp: 
int minNumber ( int a [ ] , int n , int x ) { sort ( a , a + n ) ; int k ; for ( k = 0 ; a [ ( n - 1 ) / 2 ] != x ; k ++ ) { a [ n ++ ] = x ; a . sort ( ) ; } return k ; }

BLEU: 89.34
Edit Sim: 13


Src: 
function isPossible ( x , y , k ) { var minMoves = Math . abs ( x ) + Math . abs ( y ) ; if ( k >= minMoves && ( k - minMoves ) % 2 == 0 ) return true ; return false ; }
Ref: 
bool isPossible ( int x , int y , int k ) { int minMoves = abs ( x ) + abs ( y ) ; if ( k >= minMoves && ( k - minMoves ) % 2 == 0 ) return true ; return false ; }
Hyp: 
bool isPossible ( int x , int y , int k ) { int minMoves = abs ( x ) + abs ( y ) ; if ( k >= minMoves && ( k - minMoves ) % 2 == 0 ) return true ; return false ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function triangleArea ( a , b ) { if ( a < 0 b < 0 ) { document . write ( - 1 ) ; return ; } var area = ( 3 * Math . sqrt ( 3 ) * a * b ) / ( 4 ) ; document . write ( area . toFixed ( 5 ) ) ; }
Ref: 
void triangleArea ( float a , float b ) { if ( a < 0 b < 0 ) { cout << -1 ; return ; } float area = ( 3 * sqrt ( 3 ) * a * b ) / ( 4 ) ; cout << area ; }
Hyp: 
void triangleArea ( float a , float b ) { if ( a < 0 b < 0 ) { cout << -1 ; return ; } float area = ( 3 * sqrt ( 3 ) * a * b ) / ( 4 ) ; cout << area ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function printExpansion ( str ) { var suff = " " ; for ( var i = str . length - 1 ; i >= 0 ; i -- ) { suff = suff + str [ i ] ; document . write ( suff ) ; } }
Ref: 
void printExpansion ( string str ) { string suff = " " ; for ( int i = str . length ( ) - 1 ; i >= 0 ; i -- ) { suff = suff + str [ i ] ; cout << suff ; } }
Hyp: 
void printExpansion ( string str ) { string suff = " " ; for ( int i = str . length ( ) - 1 ; i >= 0 ; i -- ) { suff = suff + str [ i ] ; cout << suff ; } }

BLEU: 100.0
Edit Sim: 0


Src: 
function findPair ( arr , n ) { let found = false ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i + 1 ; j < n ; j ++ ) { for ( let k = 0 ; k < n ; k ++ ) { if ( arr [ i ] + arr [ j ] == arr [ k ] ) { document . write ( arr [ i ] + " " + arr [ j ] + " " ) ; found = true ; } } } } if ( found == false ) document . write ( " " ) ; }
Ref: 
void findPair ( int arr [ ] , int n ) { bool found = false ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { for ( int k = 0 ; k < n ; k ++ ) { if ( arr [ i ] + arr [ j ] == arr [ k ] ) { cout << arr [ i ] << " ▁ " << arr [ j ] << endl ; found = true ; } } } } if ( found == false ) cout << " Not ▁ exist " << endl ; }
Hyp: 
void findPair ( int arr [ ] , int n ) { bool found = false ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { for ( int k = 0 ; k < n ; k ++ ) { if ( arr [ i ] + arr [ j ] == arr [ k ] ) { cout << arr [ i ] << " , ▁ " << arr [ j ] << " , ▁ " ; found = true ; } } } } if ( found == false ) cout << " No " ; }

BLEU: 91.29
Edit Sim: 26


Src: 
function isTriplet ( ar , n ) { for ( var i = 0 ; i < n ; i ++ ) { for ( var j = i + 1 ; j < n ; j ++ ) { for ( var k = j + 1 ; k < n ; k ++ ) { if ( Math . abs ( ar [ i ] - ar [ j ] ) == 1 || Math . abs ( ar [ j ] - ar [ k ] ) == 1 || Math . abs ( ar [ i ] - ar [ k ] ) == 1 ) { var x = ar [ i ] * ar [ i ] , y = ar [ j ] * ar [ j ] , z = ar [ k ] * ar [ k ] ; if ( x == y + z y == x + z z == x + y ) return true ; } } } } return false ; }
Ref: 
bool isTriplet ( int ar [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) { if ( abs ( ar [ i ] - ar [ j ] ) == 1 || abs ( ar [ j ] - ar [ k ] ) == 1 || abs ( ar [ i ] - ar [ k ] ) == 1 ) { int x = ar [ i ] * ar [ i ] , y = ar [ j ] * ar [ j ] , z = ar [ k ] * ar [ k ] ; if ( x == y + z y == x + z z == x + y ) return true ; } } } } return false ; }
Hyp: 
bool isTriplet ( int ar [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) { if ( abs ( ar [ i ] - ar [ j ] ) == 1 || abs ( ar [ j ] - ar [ k ] ) == 1 || abs ( ar [ i ] - ar [ k ] ) == 1 ) { int x = ar [ i ] * ar [ i ] , y = ar [ j ] * ar [ j ] , z = ar [ k ] * ar [ k ] ; if ( x == y + z y == x + z z == x + y ) return true ; } } } } return false ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function center_octadecagon_num ( n ) { return 9 * n * n - 9 * n + 1 ; }
Ref: 
int center_octadecagon_num ( long int n ) { return 9 * n * n - 9 * n + 1 ; }
Hyp: 
int center_octadecagon_num ( long int n ) { return 9 * n * n - 9 * n + 1 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function maxInt ( str ) { var str2 = " " ; for ( var i = 0 ; i < str . length ; i ++ ) { if ( str [ i ] < ' ' ) { var l = ( ' ' . charCodeAt ( 0 ) - str [ i ] . charCodeAt ( 0 ) ) + ' ' . charCodeAt ( 0 ) ; str2 = str2 . concat ( String . fromCharCode ( l ) ) ; } } if ( str2 [ 0 ] == ' ' ) str2 [ 0 ] = ' ' ; return str2 ; }
Ref: 
string maxInt ( string str ) { for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] < '5' ) { str [ i ] = ( '9' - str [ i ] ) + '0' ; } } if ( str [ 0 ] == '0' ) str [ 0 ] = '9' ; return str ; }
Hyp: 
string maxInt ( string str ) { string str2 = " " ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] < ' A ' ) { int l = ( ' A ' - str [ i ] ) + ' Z ' ; str2 . push_back ( str [ i ] ) ; } } if ( str2 [ 0 ] == '0' ) str2 [ 0 ] = '1' ; return str2 ; }

BLEU: 55.46
Edit Sim: 72


Src: 
function Nonagonal ( n ) { for ( let i = 1 ; i <= n ; i ++ ) { document . write ( parseInt ( i * ( 7 * i - 5 ) / 2 ) + " " ) ; } }
Ref: 
int Nonagonal ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) { cout << i * ( 7 * i - 5 ) / 2 ; cout << " ▁ " ; } }
Hyp: 
void Nonagonal ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) { cout << i * ( 7 * i - 5 ) / 2 << endl ; } }

BLEU: 80.57
Edit Sim: 16


Src: 
function check ( str ) { var min = Number . MAX_VALUE ; var max = Number . MIN_VALUE ; var sum = 0 ; for ( i = 0 ; i < str . length ; i ++ ) { var ascii = parseInt ( str . charCodeAt ( i ) ) ; if ( ascii < 96 ascii > 122 ) return false ; sum += ascii ; if ( min > ascii ) min = ascii ; if ( max < ascii ) max = ascii ; } min -= 1 ; var eSum = parseInt ( ( max * ( max + 1 ) ) / 2 ) - ( ( min * ( min + 1 ) ) / 2 ) ; return sum == eSum ; }
Ref: 
bool check ( string str ) { int min = INT_MAX ; int max = - INT_MAX ; int sum = 0 ; for ( int i = 0 ; i < str . size ( ) ; i ++ ) { int ascii = str [ i ] ; if ( ascii < 96 ascii > 122 ) return false ; sum += ascii ; if ( min > ascii ) min = ascii ; if ( max < ascii ) max = ascii ; } min -= 1 ; int eSum = ( ( max * ( max + 1 ) ) / 2 ) - ( ( min * ( min + 1 ) ) / 2 ) ; return sum == eSum ; }
Hyp: 
bool check ( string str ) { int min = INT_MAX ; int max = INT_MIN ; int sum = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { int ascii = ( int ) str [ i ] ; if ( ascii < 96 ascii > 122 ) return false ; sum += ascii ; if ( min > ascii ) min = ascii ; if ( max < ascii ) max = ascii ; } min -= 1 ; int eSum = ( max * ( max + 1 ) ) / 2 - ( ( min * ( min + 1 ) ) / 2 ) ; return sum == eSum ; }

BLEU: 91.01
Edit Sim: 22


Src: 
function posOfRightMostDiffBit ( m , n ) { return parseInt ( Math . floor ( Math . log10 ( Math . pow ( m ^ n , 2 ) ) ) , 10 ) + 2 ; }
Ref: 
int posOfRightMostDiffBit ( int m , int n ) { return ffs ( m ^ n ) ; }
Hyp: 
int posOfRightMostDiffBit ( int m , int n ) { return floor ( log10 ( pow ( m ^ n , 2 ) ) ) + 2 ; }

BLEU: 47.75
Edit Sim: 30


Src: 
function pronic_check ( n ) { var x = parseInt ( Math . sqrt ( n ) ) ; if ( x * ( x + 1 ) == n ) return true ; else return false ; }
Ref: 
bool pronic_check ( int n ) { int x = ( int ) ( sqrt ( n ) ) ; if ( x * ( x + 1 ) == n ) return true ; else return false ; }
Hyp: 
bool pronic_check ( int n ) { int x = sqrt ( n ) ; if ( x * ( x + 1 ) == n ) return true ; else return false ; }

BLEU: 80.71
Edit Sim: 12


Src: 
function min_cost ( S ) { let cost = 0 ; let F = 0 ; let B = 0 ; let count = 0 ; for ( let i in S ) if ( S [ i ] == ' ' ) count ++ ; let n = S . length - count ; if ( n == 1 ) return cost ; for ( let i in S ) { if ( S [ i ] != ' ' ) { if ( B != 0 ) { cost += Math . min ( n - F , F ) * B ; B = 0 ; } F += 1 ; } else { B += 1 ; } } return cost ; }
Ref: 
int min_cost ( string S ) { int cost = 0 ; int F = 0 ; int B = 0 ; int count = 0 ; for ( char c : S ) if ( c == ' ▁ ' ) count ++ ; int n = S . size ( ) - count ; if ( n == 1 ) return cost ; for ( char in : S ) { if ( in != ' ▁ ' ) { if ( B != 0 ) { cost += min ( n - F , F ) * B ; B = 0 ; } F += 1 ; } else { B += 1 ; } } return cost ; }
Hyp: 
int min_cost ( string S ) { int cost = 0 ; int F = 0 ; int B = 0 ; int count = 0 ; for ( char x : S ) if ( x == '0' ) count ++ ; int n = S . length ( ) - count ; if ( n == 1 ) return cost ; for ( char x : S ) { if ( S [ i ] != '0' ) { if ( B != 0 ) { cost += min ( n - F , F ) * B ; B = 0 ; } F += 1 ; } else { B += 1 ; } } return cost ; }

BLEU: 83.6
Edit Sim: 22


Src: 
function dealnnoy ( n , m ) { var dp = Array . from ( Array ( m + 1 ) , ( ) => Array ( n + 1 ) ) ; for ( var i = 0 ; i <= m ; i ++ ) dp [ i ] [ 0 ] = 1 ; for ( var i = 0 ; i <= m ; i ++ ) dp [ 0 ] [ i ] = 1 ; for ( var i = 1 ; i <= m ; i ++ ) for ( var j = 1 ; j <= n ; j ++ ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] + dp [ i ] [ j - 1 ] ; return dp [ m ] [ n ] ; }
Ref: 
int dealnnoy ( int n , int m ) { int dp [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) dp [ i ] [ 0 ] = 1 ; for ( int i = 0 ; i <= m ; i ++ ) dp [ 0 ] [ i ] = 1 ; for ( int i = 1 ; i <= m ; i ++ ) for ( int j = 1 ; j <= n ; j ++ ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] + dp [ i ] [ j - 1 ] ; return dp [ m ] [ n ] ; }
Hyp: 
int dealnnoy ( int n , int m ) { int dp [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) dp [ i ] [ 0 ] = 1 ; for ( int i = 0 ; i <= m ; i ++ ) dp [ 0 ] [ i ] = 1 ; for ( int i = 1 ; i <= m ; i ++ ) for ( int j = 1 ; j <= n ; j ++ ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] + dp [ i ] [ j - 1 ] ; return dp [ m ] [ n ] ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function removeElements ( arr , n ) { arr . sort ( ( a , b ) => b - a ) ; var ans = 0 ; for ( var i = 0 ; i < n ; i ++ ) { ans += arr [ i ] * Math . pow ( 2 , i ) ; } return ans ; }
Ref: 
int removeElements ( ll arr [ ] , int n ) { sort ( arr , arr + n , greater < int > ( ) ) ; ll ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ans += arr [ i ] * pow ( 2 , i ) ; } return ans ; }
Hyp: 
int removeElements ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ans += arr [ i ] * pow ( 2 , i ) ; } return ans ; }

BLEU: 79.75
Edit Sim: 26


Src: 
function findNature ( a , b , n ) { if ( n == 0 ) return ( a & 1 ) == 1 ? true : false ; if ( n == 1 ) return ( b & 1 ) == 1 ? true : false ; if ( ( a & 1 ) == 0 ) { if ( ( b & 1 ) == 0 ) return false ; else return ( n % 3 != 0 ) ; } else { if ( ( b & 1 ) == 0 ) return ( ( n - 1 ) % 3 != 0 ) ; else return ( ( n + 1 ) % 3 != 0 ) ; } }
Ref: 
bool findNature ( int a , int b , int n ) { if ( n == 0 ) return ( a & 1 ) ; if ( n == 1 ) return ( b & 1 ) ; if ( ! ( a & 1 ) ) { if ( ! ( b & 1 ) ) return false ; else return ( n % 3 != 0 ) ; } else { if ( ! ( b & 1 ) ) return ( ( n - 1 ) % 3 != 0 ) ; else return ( ( n + 1 ) % 3 != 0 ) ; } }
Hyp: 
bool findNature ( int a , int b , int n ) { if ( n == 0 ) return ( a & 1 ) == 1 ? true : false ; if ( n == 1 ) return ( b & 1 ) == 1 ? true : false ; if ( ( a & 1 ) == 0 ) { if ( ( b & 1 ) == 0 ) return false ; else return ( n % 3 != 0 ) ; } else { if ( ( b & 1 ) == 0 ) return ( ( n - 1 ) % 3 != 0 ) ; else return ( ( n + 1 ) % 3 != 0 ) ; } }

BLEU: 75.87
Edit Sim: 61


Src: 
function count ( arr , low , high , x ) { if ( ( low > high ) || ( low == high && arr [ low ] != x ) ) return 0 ; if ( low == high && arr [ low ] == x ) return 1 ; return count ( arr , low , Math . floor ( ( low + high ) / 2 ) , x ) + count ( arr , 1 + Math . floor ( ( low + high ) / 2 ) , high , x ) ; }
Ref: 
int count ( int arr [ ] , int low , int high , int x ) { if ( ( low > high ) || ( low == high && arr [ low ] != x ) ) return 0 ; if ( low == high && arr [ low ] == x ) return 1 ; return count ( arr , low , ( low + high ) / 2 , x ) + count ( arr , 1 + ( low + high ) / 2 , high , x ) ; }
Hyp: 
int count ( int arr [ ] , int low , int high , int x ) { if ( ( low > high ) || ( low == high && arr [ low ] != x ) ) return 0 ; if ( low == high && arr [ low ] == x ) return 1 ; return count ( arr , low , floor ( ( low + high ) / 2 ) , x ) + count ( arr , 1 + floor ( ( low + high ) / 2 ) , high , x ) ; }

BLEU: 88.01
Edit Sim: 20


Src: 
function isReachable ( x1 , y1 , x2 , y2 ) { while ( x2 > x1 && y2 > y1 ) { if ( x2 > y2 ) x2 %= y2 ; else y2 %= x2 ; } if ( x2 == x1 ) return ( y2 - y1 ) >= 0 && ( y2 - y1 ) % x1 == 0 ; else if ( y2 == y1 ) return ( x2 - x1 ) >= 0 && ( x2 - x1 ) % y1 == 0 ; else return false ; }
Ref: 
bool isReachable ( long long x1 , long long y1 , long long x2 , long long y2 ) { while ( x2 > x1 && y2 > y1 ) { if ( x2 > y2 ) x2 %= y2 ; else y2 %= x2 ; } if ( x2 == x1 ) return ( y2 - y1 ) >= 0 && ( y2 - y1 ) % x1 == 0 ; else if ( y2 == y1 ) return ( x2 - x1 ) >= 0 && ( x2 - x1 ) % y1 == 0 ; else return 0 ; }
Hyp: 
bool isReachable ( int x1 , int y1 , int x2 , int y2 ) { while ( x2 > x1 && y2 > y1 ) { if ( x2 > y2 ) x2 %= y2 ; else y2 %= x2 ; } if ( x2 == x1 ) return ( y2 - y1 ) >= 0 && ( y2 - y1 ) % x1 == 0 ; else if ( y2 == y1 ) return ( x2 - x1 ) >= 0 && ( x2 - x1 ) % y1 == 0 ; else return false ; }

BLEU: 84.67
Edit Sim: 37


Src: 
function Icositrigonal_num ( n ) { return ( 21 * n * n - 19 * n ) / 2 ; }
Ref: 
int Icositrigonal_num ( int n ) { return ( 21 * n * n - 19 * n ) / 2 ; }
Hyp: 
int Icositrigonal_num ( long int n ) { return ( 21 * n * n - 19 * n ) / 2 ; }

BLEU: 88.95
Edit Sim: 5


Src: 
function numofstring ( n , m ) { if ( n == 1 ) return m ; if ( n == 2 ) return m * ( m - 1 ) ; return m * ( m - 1 ) * Math . pow ( m - 2 , n - 2 ) ; }
Ref: 
int numofstring ( int n , int m ) { if ( n == 1 ) return m ; if ( n == 2 ) return m * ( m - 1 ) ; return m * ( m - 1 ) * pow ( m - 2 , n - 2 ) ; }
Hyp: 
int numofstring ( int n , int m ) { if ( n == 1 ) return m ; if ( n == 2 ) return m * ( m - 1 ) ; return m * ( m - 1 ) * pow ( m - 2 , n - 2 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countWays ( n ) { var ans = 1 ; for ( i = 0 ; i < n ; i ++ ) { ans *= 2 ; ans %= MOD ; } return ( ( ans - 1 + MOD ) % MOD ) ; }
Ref: 
int countWays ( int n ) { int ans = 1 ; for ( int i = 0 ; i < n ; i ++ ) { ans *= 2 ; ans %= MOD ; } return ( ( ans - 1 + MOD ) % MOD ) ; }
Hyp: 
int countWays ( int n ) { int ans = 1 ; for ( int i = 0 ; i < n ; i ++ ) { ans *= 2 ; ans %= MOD ; } return ( ( ans - 1 + mod ) % MOD ) ; }

BLEU: 94.87
Edit Sim: 3


Src: 
function isDefeat ( s1 , s2 , n ) { for ( let i = 0 ; i < n ; i ++ ) { if ( ( s1 [ i ] == ' ' && s2 [ i ] == ' ' ) || ( s1 [ i ] == ' ' && s2 [ i ] == ' ' ) ) continue ; else if ( ( s1 [ i ] == ' ' && s2 [ i ] == ' ' ) || ( s1 [ i ] == ' ' && s2 [ i ] == ' ' ) ) continue ; else { return true ; } } return false ; }
Ref: 
bool isDefeat ( string s1 , string s2 , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( ( s1 [ i ] == '0' && s2 [ i ] == '1' ) || ( s1 [ i ] == '1' && s2 [ i ] == '0' ) ) continue ; else if ( ( s1 [ i ] == '0' && s2 [ i ] == ' Z ' ) || ( s1 [ i ] == ' Z ' && s2 [ i ] == '0' ) ) continue ; else { return true ; } } return false ; }
Hyp: 
bool isDefeat ( string s1 , string s2 , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( ( s1 [ i ] == '0' && s2 [ i ] == '1' ) || ( s1 [ i ] == '2' && s2 [ i ] == '3' ) ) continue ; else if ( ( s1 [ i ] == '4' && s2 [ i ] == '5' ) || ( s1 [ i ] == '6' && s2 [ i ] == '7' ) ) continue ; else if ( ( s1 [ i ] == '9' && s2 [ i ] == '9' ) || ( s1 [ i ] == '10' && s2 [ i ] == '9' ) ) continue ; else { return true ; } } return false ; }

BLEU: 64.77
Edit Sim: 109


Src: 
function minSum ( n ) { var sum = 0 ; while ( n > 0 ) { sum += ( n % 10 ) ; n = parseInt ( n / 10 ) ; } if ( sum == 1 ) return 10 ; return sum ; }
Ref: 
int minSum ( int n ) { int sum = 0 ; while ( n > 0 ) { sum += ( n % 10 ) ; n /= 10 ; } if ( sum == 1 ) return 10 ; return sum ; }
Hyp: 
int minSum ( int n ) { int sum = 0 ; while ( n > 0 ) { sum += ( n % 10 ) ; n = n / 10 ; } if ( sum == 1 ) return 10 ; return sum ; }

BLEU: 90.22
Edit Sim: 5


Src: 
function findSum ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) for ( let j = i ; j <= n ; j ++ ) sum = sum + i * j ; return sum ; }
Ref: 
int findSum ( int n ) { long long int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = i ; j <= n ; j ++ ) sum = sum + i * j ; return sum ; }
Hyp: 
int findSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = i ; j <= n ; j ++ ) sum = sum + i * j ; return sum ; }

BLEU: 93.35
Edit Sim: 10


Src: 
function findLength ( s , k ) { var ans = 1000000000 ; var l = 0 ; var r = 0 ; var cnt_zero = 0 , cnt_one = 0 ; while ( l < s . length && r <= s . length ) { if ( cnt_zero >= k && cnt_one >= 1 ) { ans = Math . min ( ans , r - l ) ; l ++ ; if ( s [ l - 1 ] == ' ' ) cnt_zero -- ; else cnt_one -- ; } else { if ( r == s . length ) break ; if ( s [ r ] == ' ' ) cnt_zero ++ ; else cnt_one ++ ; r ++ ; } } if ( ans == 1000000000 ) return - 1 ; return ans ; }
Ref: 
int findLength ( string s , int k ) { int ans = INT_MAX ; int l = 0 ; int r = 0 ; int cnt_zero = 0 , cnt_one = 0 ; while ( l < s . size ( ) and r <= s . size ( ) ) { if ( cnt_zero >= k and cnt_one >= 1 ) { ans = min ( ans , r - l ) ; l ++ ; if ( s [ l - 1 ] == '0' ) cnt_zero -- ; else cnt_one -- ; } else { if ( r == s . size ( ) ) break ; if ( s [ r ] == '0' ) cnt_zero ++ ; else cnt_one ++ ; r ++ ; } } if ( ans == INT_MAX ) return -1 ; return ans ; }
Hyp: 
int findLength ( string s , int k ) { int ans = INT_MAX ; int l = 0 ; int r = 0 ; int cnt_zero = 0 , cnt_one = 0 ; while ( l < s . size ( ) && r <= s . size ( ) ) { if ( cnt_zero >= k && cnt_one >= 1 ) { ans = min ( ans , r - l ) ; l ++ ; if ( s [ l - 1 ] == '0' ) cnt_zero -- ; else cnt_one -- ; } else { if ( r == s . size ( ) ) break ; if ( s [ r ] == '0' ) cnt_zero ++ ; else cnt_one ++ ; r ++ ; } } if ( ans == INT_MAX ) return -1 ; return ans ; }

BLEU: 96.51
Edit Sim: 6


Src: 
function maxTripletSum ( arr , n ) { arr . sort ( ) ; return arr [ n - 1 ] + arr [ n - 2 ] + arr [ n - 3 ] ; }
Ref: 
int maxTripletSum ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; return arr [ n - 1 ] + arr [ n - 2 ] + arr [ n - 3 ] ; }
Hyp: 
int maxTripletSum ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; return arr [ n - 1 ] + arr [ n - 2 ] + arr [ n - 3 ] ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function IsRedundantBraces ( A ) { let a = 0 , b = 0 ; for ( let i = 0 ; i < A . length ; i ++ ) { if ( A [ i ] == ' ' && A [ i + 2 ] == ' ' ) return true ; if ( A [ i ] == ' ' A [ i ] == ' ' A [ i ] == ' ' A [ i ] == ' ' ) a ++ ; if ( A [ i ] == ' ' ) b ++ ; } if ( b > a ) return true ; return false ; } let A = " " ; if ( IsRedundantBraces ( A ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
Ref: 
bool IsRedundantBraces ( string A ) { int a = 0 , b = 0 ; for ( int i = 0 ; i < A . size ( ) ; i ++ ) { if ( A [ i ] == ' ( ' && A [ i + 2 ] == ' ) ' ) return 1 ; if ( A [ i ] == ' * ' A [ i ] == ' + ' A [ i ] == ' - ' A [ i ] == ' / ' ) a ++ ; if ( A [ i ] == ' ( ' ) b ++ ; } if ( b > a ) return 1 ; return 0 ; }
Hyp: 
bool IsRedundantBraces ( string A ) { int a = 0 , b = 0 ; for ( int i = 0 ; i < A . size ( ) ; i ++ ) { if ( A [ i ] == '0' && A [ i + 2 ] == '1' ) return true ; if ( A [ i ] == '2' A [ i ] == '4' A [ i ] == '5' A [ i ] == '6' A [ i ] == '7' ) a ++ ; if ( A [ i ] == '9' ) b ++ ; } if ( b > a ) return true ; return false ; }

BLEU: 68.81
Edit Sim: 45


Src: 
function findoptimal ( N ) { if ( N <= 6 ) return N ; let screen = new Array ( N ) ; for ( let i = 0 ; i < N ; i ++ ) { screen [ i ] = 0 ; } let b ; let n ; for ( n = 1 ; n <= 6 ; n ++ ) screen [ n - 1 ] = n ; for ( n = 7 ; n <= N ; n ++ ) { screen [ n - 1 ] = 0 ; for ( b = n - 3 ; b >= 1 ; b -- ) { let curr = ( n - b - 1 ) * screen [ b - 1 ] ; if ( curr > screen [ n - 1 ] ) screen [ n - 1 ] = curr ; } } return screen [ N - 1 ] ; }
Ref: 
int findoptimal ( int N ) { if ( N <= 6 ) return N ; int screen [ N ] ; int b ; int n ; for ( n = 1 ; n <= 6 ; n ++ ) screen [ n - 1 ] = n ; for ( n = 7 ; n <= N ; n ++ ) { screen [ n - 1 ] = 0 ; for ( b = n - 3 ; b >= 1 ; b -- ) { int curr = ( n - b - 1 ) * screen [ b - 1 ] ; if ( curr > screen [ n - 1 ] ) screen [ n - 1 ] = curr ; } } return screen [ N - 1 ] ; }
Hyp: 
int findoptimal ( int N ) { if ( N <= 6 ) return N ; int screen [ N ] ; memset ( screen , 0 , sizeof ( screen ) ) ; int b ; int n ; for ( n = 1 ; n <= 6 ; n ++ ) screen [ n - 1 ] = n ; for ( n = 7 ; n <= N ; n ++ ) { screen [ n - 1 ] = 0 ; for ( b = n - 3 ; b >= 1 ; b -- ) { int curr = ( n - b - 1 ) * screen [ b - 1 ] ; if ( curr > screen [ n - 1 ] ) screen [ n - 1 ] = curr ; } } return screen [ N - 1 ] ; }

BLEU: 91.47
Edit Sim: 44


Src: 
function fact ( n ) { if ( n == 0 ) return 1 ; return n * fact ( n - 1 ) ; }
Ref: 
int fact ( unsigned int n ) { if ( n == 0 ) return 1 ; return n * fact ( n - 1 ) ; }
Hyp: 
int fact ( int n ) { if ( n == 0 ) return 1 ; return n * fact ( n - 1 ) ; }

BLEU: 90.62
Edit Sim: 9


Src: 
function printChar ( str , n ) { let freq = [ ] ; for ( let i = 0 ; i < SIZE ; i ++ ) { freq . push ( 0 ) ; } for ( let i = 0 ; i < n ; i ++ ) freq [ str . charCodeAt ( i ) - 97 ] ++ ; for ( let i = 0 ; i < n ; i ++ ) { if ( freq [ str . charCodeAt ( i ) - 97 ] % 2 == 1 ) { document . write ( str [ i ] ) ; } } }
Ref: 
void printChar ( string str , int n ) { int freq [ SIZE ] ; memset ( freq , 0 , sizeof ( freq ) ) ; for ( int i = 0 ; i < n ; i ++ ) freq [ str [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < n ; i ++ ) { if ( freq [ str [ i ] - ' a ' ] % 2 == 1 ) { cout << str [ i ] ; } } }
Hyp: 
void printChar ( string str , int n ) { vector < int > freq ( SIZE , 0 ) ; for ( int i = 0 ; i < n ; i ++ ) freq [ str [ i ] - 97 ] ++ ; for ( int i = 0 ; i < n ; i ++ ) { if ( freq [ str [ i ] - 97 ] % 2 == 1 ) { cout << str [ i ] ; } } }

BLEU: 74.09
Edit Sim: 51


Src: 
function minCost ( str , a , b ) { let openUnbalanced = 0 ; let closedUnbalanced = 0 ; let openCount = 0 ; let closedCount = 0 ; for ( let i = 0 ; i < str . length ; i ++ ) { if ( str [ i ] == ' ' ) { openUnbalanced ++ ; openCount ++ ; } else { if ( openUnbalanced == 0 ) closedUnbalanced ++ ; else openUnbalanced -- ; closedCount ++ ; } } let result = a * ( Math . abs ( openCount - closedCount ) ) ; if ( closedCount > openCount ) closedUnbalanced -= ( closedCount - openCount ) ; if ( openCount > closedCount ) openUnbalanced -= ( openCount - closedCount ) ; result += Math . min ( a * ( openUnbalanced + closedUnbalanced ) , b * closedUnbalanced ) ; document . write ( result + " " ) ; }
Ref: 
void minCost ( string str , int a , int b ) { int openUnbalanced = 0 ; int closedUnbalanced = 0 ; int openCount = 0 ; int closedCount = 0 ; for ( int i = 0 ; str [ i ] != ' \0' ; i ++ ) { if ( str [ i ] == ' ( ' ) { openUnbalanced ++ ; openCount ++ ; } else { if ( openUnbalanced == 0 ) closedUnbalanced ++ ; else openUnbalanced -- ; closedCount ++ ; } } int result = a * ( abs ( openCount - closedCount ) ) ; if ( closedCount > openCount ) closedUnbalanced -= ( closedCount - openCount ) ; if ( openCount > closedCount ) openUnbalanced -= ( openCount - closedCount ) ; result += min ( a * ( openUnbalanced + closedUnbalanced ) , b * closedUnbalanced ) ; cout << result << endl ; }
Hyp: 
void minCost ( string str , int a , int b ) { int openUnbalanced = 0 ; int closedUnbalanced = 0 ; int openCount = 0 ; int closedCount = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] == ' ( ' ) { openUnbalanced ++ ; openCount ++ ; } else { if ( openUnbalanced == 0 ) closedUnbalanced ++ ; else openUnbalanced -- ; closedCount ++ ; } } int result = a * ( abs ( openCount - closedCount ) ) ; if ( closedCount > openCount ) closedUnbalanced -= ( closedCount - openCount ) ; if ( openCount > closedCount ) openUnbalanced -= ( openCount - closedCount ) ; result += min ( a * ( openUnbalanced + closedUnbalanced ) , b * closedUnbalanced ) ; cout << result << " STRNEWLINE " ; }

BLEU: 92.24
Edit Sim: 29


Src: 
function minimal ( a , n ) { let lo = 0 , hi = n - 1 ; while ( lo < hi ) { let mid = ( lo + hi ) >> 1 ; if ( a [ mid ] < a [ mid + 1 ] ) { hi = mid ; } else { lo = mid + 1 ; } } return lo ; }
Ref: 
int minimal ( int a [ ] , int n ) { int lo = 0 , hi = n - 1 ; while ( lo < hi ) { int mid = ( lo + hi ) >> 1 ; if ( a [ mid ] < a [ mid + 1 ] ) { hi = mid ; } else { lo = mid + 1 ; } } return lo ; }
Hyp: 
int minimal ( int a [ ] , int n ) { int lo = 0 , hi = n - 1 ; while ( lo < hi ) { int mid = ( lo + hi ) >> 1 ; if ( a [ mid ] < a [ mid + 1 ] ) { hi = mid ; } else { lo = mid + 1 ; } } return lo ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countSum ( a , n , sum ) { let i , j , k , l ; let count = 0 ; for ( i = 0 ; i < n - 3 ; i ++ ) { for ( j = i + 1 ; j < n - 2 ; j ++ ) { for ( k = j + 1 ; k < n - 1 ; k ++ ) { for ( l = k + 1 ; l < n ; l ++ ) { if ( a [ i ] + a [ j ] + a [ k ] + a [ l ] == sum ) count ++ ; } } } } return count ; }
Ref: 
int countSum ( int a [ ] , int n , int sum ) { int i , j , k , l ; int count = 0 ; for ( i = 0 ; i < n - 3 ; i ++ ) { for ( j = i + 1 ; j < n - 2 ; j ++ ) { for ( k = j + 1 ; k < n - 1 ; k ++ ) { for ( l = k + 1 ; l < n ; l ++ ) { if ( a [ i ] + a [ j ] + a [ k ] + a [ l ] == sum ) count ++ ; } } } } return count ; }
Hyp: 
int countSum ( int a [ ] , int n , int sum ) { int i , j , k , l ; int count = 0 ; for ( i = 0 ; i < n - 3 ; i ++ ) { for ( j = i + 1 ; j < n - 2 ; j ++ ) { for ( k = j + 1 ; k < n - 1 ; k ++ ) { for ( l = k + 1 ; l < n ; l ++ ) { if ( a [ i ] + a [ j ] + a [ k ] + a [ l ] == sum ) count ++ ; } } } } return count ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function count_unique ( s , n ) { if ( s . has ( n ) ) return ; s . add ( n ) ; n += 1 ; while ( n % 10 == 0 ) { n = Math . floor ( n / 10 ) ; } count_unique ( s , n ) ; }
Ref: 
void count_unique ( unordered_set < int > & s , int n ) { if ( s . count ( n ) ) return ; s . insert ( n ) ; n += 1 ; while ( n % 10 == 0 ) { n = n / 10 ; } count_unique ( s , n ) ; }
Hyp: 
void count_unique ( set < int > & s , int n ) { if ( s . find ( n ) != s . end ( ) ) return ; s . insert ( n ) ; n += 1 ; while ( n % 10 == 0 ) { n = n / 10 ; } count_unique ( s , n ) ; }

BLEU: 81.83
Edit Sim: 29


Src: 
function totalCombination ( L , R ) { let count = 0 ; let K = R - L ; if ( K < L ) return 0 ; let ans = K - L ; count = ( ( ans + 1 ) * ( ans + 2 ) ) / 2 ; return count ; }
Ref: 
int totalCombination ( int L , int R ) { int count = 0 ; int K = R - L ; if ( K < L ) return 0 ; int ans = K - L ; count = ( ( ans + 1 ) * ( ans + 2 ) ) / 2 ; return count ; }
Hyp: 
int totalCombination ( int L , int R ) { int count = 0 ; int K = R - L ; if ( K < L ) return 0 ; int ans = K - L ; count = ( ( ans + 1 ) * ( ans + 2 ) ) / 2 ; return count ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function spellsCount ( num ) { let n = num . length ; let result = 1 ; for ( let i = 0 ; i < n ; i ++ ) { let count = 1 ; while ( i < n - 1 && num [ i + 1 ] == num [ i ] ) { count ++ ; i ++ ; } result = result * Math . pow ( 2 , count - 1 ) ; } return result ; }
Ref: 
ll spellsCount ( string num ) { int n = num . length ( ) ; ll result = 1 ; for ( int i = 0 ; i < n ; i ++ ) { int count = 1 ; while ( i < n - 1 && num [ i + 1 ] == num [ i ] ) { count ++ ; i ++ ; } result = result * pow ( 2 , count - 1 ) ; } return result ; }
Hyp: 
int spellsCount ( string num ) { int n = num . length ( ) ; int result = 1 ; for ( int i = 0 ; i < n ; i ++ ) { int count = 1 ; while ( i < n - 1 && num [ i + 1 ] == num [ i ] ) { count ++ ; i ++ ; } result = result * pow ( 2 , count - 1 ) ; } return result ; }

BLEU: 95.93
Edit Sim: 6


Src: 
function getSum ( n ) { let sum = 0 ; let k = parseInt ( Math . sqrt ( n ) ) ; for ( let i = 1 ; i <= k ; i ++ ) { sum += Math . floor ( n / i ) ; } sum *= 2 ; sum -= Math . pow ( k , 2 ) ; return sum ; }
Ref: 
int getSum ( int n ) { long long int sum = 0 ; int k = sqrt ( n ) ; for ( int i = 1 ; i <= k ; i ++ ) { sum += floor ( n / i ) ; } sum *= 2 ; sum -= pow ( k , 2 ) ; return sum ; }
Hyp: 
int digSum ( int n ) { int sum = 0 ; int k = sqrt ( n ) ; for ( int i = 1 ; i <= k ; i ++ ) { sum += n / i ; } sum *= 2 ; sum -= pow ( k , 2 ) ; return sum ; }

BLEU: 81.73
Edit Sim: 23


Src: 
function alternateSubarray ( arr , n ) { let len = new Array ( n ) ; len [ n - 1 ] = 1 ; for ( let i = n - 2 ; i >= 0 ; -- i ) { if ( arr [ i ] ^ arr [ i + 1 ] == 1 ) len [ i ] = len [ i + 1 ] + 1 ; else len [ i ] = 1 ; } for ( let i = 0 ; i < n ; ++ i ) document . write ( len [ i ] + " " ) ; }
Ref: 
void alternateSubarray ( bool arr [ ] , int n ) { int len [ n ] ; len [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; -- i ) { if ( arr [ i ] ^ arr [ i + 1 ] == 1 ) len [ i ] = len [ i + 1 ] + 1 ; else len [ i ] = 1 ; } for ( int i = 0 ; i < n ; ++ i ) cout << len [ i ] << " ▁ " ; }
Hyp: 
void alternateSubarray ( int arr [ ] , int n ) { int len [ n ] ; len [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; -- i ) { if ( arr [ i ] ^ arr [ i + 1 ] == 1 ) len [ i ] = len [ i + 1 ] + 1 ; else len [ i ] = 1 ; } for ( int i = 0 ; i < n ; ++ i ) cout << len [ i ] << " ▁ " ; }

BLEU: 97.68
Edit Sim: 4


Src: 
function findMinSwaps ( s , k ) { var ans = 0 ; var c_one = 0 , c_zero = 0 ; for ( var i = s . length - 1 ; i >= 0 ; i -- ) { if ( s [ i ] == ' ' ) c_one ++ ; if ( s [ i ] == ' ' ) c_zero ++ , ans += c_one ; if ( c_zero == k ) break ; } if ( c_zero < k ) return - 1 ; return ans ; }
Ref: 
int findMinSwaps ( string s , int k ) { int ans = 0 ; int c_one = 0 , c_zero = 0 ; for ( int i = s . size ( ) - 1 ; i >= 0 ; i -- ) { if ( s [ i ] == '1' ) c_one ++ ; if ( s [ i ] == '0' ) c_zero ++ , ans += c_one ; if ( c_zero == k ) break ; } if ( c_zero < k ) return -1 ; return ans ; }
Hyp: 
int findMinSwaps ( string s , int k ) { int ans = 0 ; int c_one = 0 , c_zero = 0 ; for ( int i = s . size ( ) - 1 ; i >= 0 ; i -- ) { if ( s [ i ] == '1' ) c_one ++ ; if ( s [ i ] == '2' ) c_zero ++ , ans += c_one ; if ( c_zero == k ) break ; } if ( c_zero < k ) return -1 ; return ans ; }

BLEU: 97.33
Edit Sim: 1


Src: 
function findPairs ( arr1 , arr2 , n , m , x ) { for ( let i = 0 ; i < n ; i ++ ) for ( let j = 0 ; j < m ; j ++ ) if ( arr1 [ i ] + arr2 [ j ] == x ) document . write ( arr1 [ i ] + " " + arr2 [ j ] + " " ) ; }
Ref: 
void findPairs ( int arr1 [ ] , int arr2 [ ] , int n , int m , int x ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( arr1 [ i ] + arr2 [ j ] == x ) cout << arr1 [ i ] << " ▁ " << arr2 [ j ] << endl ; }
Hyp: 
int findPairs ( int arr1 [ ] , int arr2 [ ] , int n , int m , int x ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( arr1 [ i ] + arr2 [ j ] == x ) cout << arr1 [ i ] << " , ▁ " << arr2 [ j ] << " ] ▁ " ; }

BLEU: 89.94
Edit Sim: 13


Src: 
function maxSum ( mat , n ) { if ( n == 1 ) return mat [ 0 ] [ 0 ] ; let dp = new Array ( n ) ; for ( var i = 0 ; i < dp . length ; i ++ ) { dp [ i ] = new Array ( 2 ) ; } let maxSum = Number . MIN_VALUE , max ; for ( let j = 0 ; j < n ; j ++ ) dp [ n - 1 ] [ j ] = mat [ n - 1 ] [ j ] ; for ( let i = n - 2 ; i >= 0 ; i -- ) { for ( let j = 0 ; j < n ; j ++ ) { max = Number . MIN_VALUE ; if ( ( ( j - 1 ) >= 0 ) && ( max < dp [ i + 1 ] [ j - 1 ] ) ) max = dp [ i + 1 ] [ j - 1 ] ; if ( ( ( j + 1 ) < n ) && ( max < dp [ i + 1 ] [ j + 1 ] ) ) max = dp [ i + 1 ] [ j + 1 ] ; dp [ i ] [ j ] = mat [ i ] [ j ] + max ; } } for ( let j = 0 ; j < n ; j ++ ) if ( maxSum < dp [ 0 ] [ j ] ) maxSum = dp [ 0 ] [ j ] ; return maxSum ; }
Ref: 
int maxSum ( int mat [ SIZE ] [ SIZE ] , int n ) { if ( n == 1 ) return mat [ 0 ] [ 0 ] ; int dp [ n ] [ n ] ; int maxSum = INT_MIN , max ; for ( int j = 0 ; j < n ; j ++ ) dp [ n - 1 ] [ j ] = mat [ n - 1 ] [ j ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < n ; j ++ ) { max = INT_MIN ; if ( ( ( j - 1 ) >= 0 ) && ( max < dp [ i + 1 ] [ j - 1 ] ) ) max = dp [ i + 1 ] [ j - 1 ] ; if ( ( ( j + 1 ) < n ) && ( max < dp [ i + 1 ] [ j + 1 ] ) ) max = dp [ i + 1 ] [ j + 1 ] ; dp [ i ] [ j ] = mat [ i ] [ j ] + max ; } } for ( int j = 0 ; j < n ; j ++ ) if ( maxSum < dp [ 0 ] [ j ] ) maxSum = dp [ 0 ] [ j ] ; return maxSum ; }
Hyp: 
int maxSum ( int mat [ ] [ 3 ] , int n ) { if ( n == 1 ) return mat [ 0 ] [ 0 ] ; int dp [ n ] [ 3 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; int maxSum = INT_MIN , max ; for ( int j = 0 ; j < n ; j ++ ) dp [ n - 1 ] [ j ] = mat [ n - 1 ] [ j ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < n ; j ++ ) { max = INT_MIN ; if ( ( ( j - 1 ) >= 0 ) && ( max < dp [ i + 1 ] [ j - 1 ] ) ) max = dp [ i + 1 ] [ j - 1 ] ; if ( ( ( j + 1 ) < n ) && ( max < dp [ i + 1 ] [ j + 1 ] ) ) max = dp [ i + 1 ] [ j + 1 ] ; dp [ i ] [ j ] = mat [ i ] [ j ] + max ; } } for ( int j = 0 ; j < n ; j ++ ) if ( maxSum < dp [ 0 ] [ j ] ) maxSum = dp [ 0 ] [ j ] ; return maxSum ; }

BLEU: 93.08
Edit Sim: 46


Src: 
function countDigit ( n ) { var temp = n , count = 0 ; while ( temp != 0 ) { var d = temp % 10 ; temp /= 10 ; if ( d > 0 && n % d == 0 ) count ++ ; } return count ; }
Ref: 
int countDigit ( int n ) { int temp = n , count = 0 ; while ( temp != 0 ) { int d = temp % 10 ; temp /= 10 ; if ( d > 0 && n % d == 0 ) count ++ ; } return count ; }
Hyp: 
int countDigit ( int n ) { int temp = n , count = 0 ; while ( temp != 0 ) { int d = temp % 10 ; temp /= 10 ; if ( d > 0 && n % d == 0 ) count ++ ; } return count ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countDivisors ( n , k ) { var count = 0 , i ; for ( i = 1 ; i <= n ; i ++ ) { if ( n % i == 0 && i % k == 0 ) { count ++ ; } } return count ; }
Ref: 
int countDivisors ( int n , int k ) { int count = 0 , i ; for ( i = 1 ; i <= n ; i ++ ) { if ( n % i == 0 && i % k == 0 ) { count ++ ; } } return count ; }
Hyp: 
int countDivisors ( int n , int k ) { int count = 0 , i ; for ( i = 1 ; i <= n ; i ++ ) { if ( n % i == 0 && i % k == 0 ) { count ++ ; } } return count ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function remainingArea ( N , M , K ) { while ( K -- && N && M ) { if ( N > M ) N = N - M ; else M = M - N ; } if ( N > 0 && M > 0 ) return N * M ; else return 0 ; }
Ref: 
int remainingArea ( int N , int M , int K ) { while ( K -- && N && M ) { if ( N > M ) N = N - M ; else M = M - N ; } if ( N > 0 && M > 0 ) return N * M ; else return 0 ; }
Hyp: 
int remainingArea ( int N , int M , int K ) { while ( K -- && N && M ) { if ( N > M ) N = N - M ; else M = M - N ; } if ( N > 0 && M > 0 ) return N * M ; else return 0 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function lastDigit2PowerN ( n ) { if ( n == 0 ) return 1 ; else if ( n % 4 == 1 ) return 2 ; else if ( n % 4 == 2 ) return 4 ; else if ( n % 4 == 3 ) return 8 ; else }
Ref: 
int lastDigit2PowerN ( int n ) { if ( n == 0 ) return 1 ; else if ( n % 4 == 1 ) return 2 ; else if ( n % 4 == 2 ) return 4 ; else if ( n % 4 == 3 ) return 8 ; else }
Hyp: 
int lastDigit2PowerN ( unsigned int n ) { if ( n == 0 ) return 1 ; else if ( n % 4 == 1 ) return 2 ; else if ( n % 4 == 2 ) return 4 ; else if ( n % 4 == 3 ) return 8 ; else return 0 ; }

BLEU: 89.03
Edit Sim: 20


Src: 
function findLarger ( arr , n ) { arr . sort ( ) ; for ( let i = n - 1 ; i >= n / 2 ; i -- ) document . write ( arr [ i ] + " " ) ; }
Ref: 
void findLarger ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; for ( int i = n - 1 ; i >= n / 2 ; i -- ) cout << arr [ i ] << " ▁ " ; }
Hyp: 
void findLarger ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; for ( int i = n - 1 ; i >= n / 2 ; i -- ) cout << arr [ i ] << " ▁ " ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function shortestLength ( n , x , y ) { let answer = 0 ; let i = 0 ; while ( n != 0 && i < x . length ) { if ( x [ i ] + y [ i ] > answer ) answer = x [ i ] + y [ i ] ; i ++ ; } document . write ( " " + answer + " " ) ; document . write ( " " + " " + answer + " " + " " + answer + " " ) ; }
Ref: 
void shortestLength ( int n , int x [ ] , int y [ ] ) { int answer = 0 ; int i = 0 ; while ( n -- ) { if ( x [ i ] + y [ i ] > answer ) answer = x [ i ] + y [ i ] ; i ++ ; } cout << " Length ▁ - > ▁ " << answer << endl ; cout << " Path ▁ - > ▁ " << " ( ▁ 1 , ▁ " << answer << " ▁ ) " << " and ▁ ( ▁ " << answer << " , ▁ 1 ▁ ) " ; }
Hyp: 
void shortestLength ( int n , int x [ ] , int y [ ] ) { int answer = 0 ; int i = 0 ; while ( n != 0 && i < x . size ( ) ) { if ( x [ i ] + y [ i ] > answer ) answer = x [ i ] + y [ i ] ; i ++ ; } cout << " The ▁ shortest ▁ length ▁ of ▁ the ▁ longest ▁ pair ▁ is ▁ " << answer << endl ; cout << " The ▁ shortest ▁ is ▁ " << answer << endl ; }

BLEU: 65.13
Edit Sim: 114


Src: 
function findScoreSum ( n ) { let F = n / 7 ; let D = n % 7 ; let fullWeekScore = ( 49 + 7 * F ) * F / 2 ; let lastNonFullWeekScore = ( 2 * F + D + 1 ) * D / 2 ; document . write ( Math . floor ( fullWeekScore + lastNonFullWeekScore ) ) ; }
Ref: 
void findScoreSum ( int n ) { int F = n / 7 ; int D = n % 7 ; int fullWeekScore = ( 49 + 7 * F ) * F / 2 ; int lastNonFullWeekScore = ( 2 * F + D + 1 ) * D / 2 ; cout << fullWeekScore + lastNonFullWeekScore ; }
Hyp: 
void findScoreSum ( int n ) { int F = n / 7 ; int D = n % 7 ; int fullWeekScore = ( 49 + 7 * F ) * F / 2 ; int lastNonFullWeekScore = ( 2 * F + D + 1 ) * D / 2 ; cout << floor ( fullWeekScore + lastNonFullWeekScore ) ; }

BLEU: 90.69
Edit Sim: 10


Src: 
function printDemlo ( str ) { let len = str . length ; let res = " " ; for ( let i = 1 ; i <= len ; i ++ ) res += i . toString ( ) ; for ( let i = len - 1 ; i >= 1 ; i -- ) res += i . toString ( ) ; return res ; }
Ref: 
string printDemlo ( string str ) { int len = str . length ( ) ; string res = " " ; for ( int i = 1 ; i <= len ; i ++ ) res += char ( i + '0' ) ; for ( int i = len - 1 ; i >= 1 ; i -- ) res += char ( i + '0' ) ; return res ; }
Hyp: 
string printDemlo ( string str ) { int len = str . length ( ) ; string res = " " ; for ( int i = 1 ; i <= len ; i ++ ) res += to_string ( i ) ; for ( int i = len - 1 ; i >= 1 ; i -- ) res += to_string ( i ) ; return res ; }

BLEU: 84.0
Edit Sim: 24


Src: 
function countGroups ( position , previous_sum , length , num ) { if ( position == length ) return 1 ; if ( dp [ position ] [ previous_sum ] != - 1 ) return dp [ position ] [ previous_sum ] ; dp [ position ] [ previous_sum ] = 0 ; let res = 0 ; let sum = 0 ; for ( let i = position ; i < length ; i ++ ) { sum += ( num [ i ] - ' ' ) ; if ( sum >= previous_sum ) res += countGroups ( i + 1 , sum , length , num ) ; } dp [ position ] [ previous_sum ] = res ; return res ; } let num = " " . split ( " " ) ; let len = num . length ; for ( let i = 0 ; i < dp . length ; i ++ ) { dp [ i ] = new Array ( 9 * MAX + 1 ) for ( let j = 0 ; j < 9 * MAX + 1 ; j ++ ) { dp [ i ] [ j ] = - 1 ; } }
Ref: 
int countGroups ( int position , int previous_sum , int length , char * num ) { if ( position == length ) return 1 ; if ( dp [ position ] [ previous_sum ] != -1 ) return dp [ position ] [ previous_sum ] ; dp [ position ] [ previous_sum ] = 0 ; int res = 0 ; int sum = 0 ; for ( int i = position ; i < length ; i ++ ) { sum += ( num [ i ] - '0' ) ; if ( sum >= previous_sum ) res += countGroups ( i + 1 , sum , length , num ) ; } dp [ position ] [ previous_sum ] = res ; return res ; }
Hyp: 
int countGroups ( int position , int previous_sum , int length , string num [ ] ) { if ( position == length ) return 1 ; if ( dp [ position ] [ previous_sum ] != -1 ) return dp [ position ] [ previous_sum ] ; dp [ position ] [ previous_sum ] = 0 ; int res = 0 ; int sum = 0 ; for ( int i = position ; i < length ; i ++ ) { sum += ( num [ i ] - '0' ) ; if ( sum >= previous_sum ) res += countGroups ( i + 1 , sum , length , num ) ; } dp [ position ] [ previous_sum ] = res ; return res ; }

BLEU: 95.93
Edit Sim: 10


Src: 
function sqroot ( s ) { var pSq = 0 ; var N = 0 ; for ( i = parseInt ( s ) ; i > 0 ; i -- ) { for ( j = 1 ; j < i ; j ++ ) { if ( j * j == i ) { pSq = i ; N = j ; break ; } } if ( pSq > 0 ) break ; } var d = s - pSq ; var P = ( d / ( 2.0 * N ) ) ; var A = N + P ; var sqrt_of_s = A - ( ( P * P ) / ( 2.0 * A ) ) ; return sqrt_of_s ; }
Ref: 
float sqroot ( float s ) { int pSq = 0 ; int N = 0 ; for ( int i = static_cast < int > ( s ) ; i > 0 ; i -- ) { for ( int j = 1 ; j < i ; j ++ ) { if ( j * j == i ) { pSq = i ; N = j ; break ; } } if ( pSq > 0 ) break ; } float d = s - pSq ; float P = d / ( 2.0 * N ) ; float A = N + P ; float sqrt_of_s = A - ( ( P * P ) / ( 2.0 * A ) ) ; return sqrt_of_s ; }
Hyp: 
double sqroot ( string s ) { int pSq = 0 ; int N = 0 ; for ( int i = s ; i > 0 ; i -- ) { for ( int j = 1 ; j < i ; j ++ ) { if ( j * j == i ) { pSq = i ; N = j ; break ; } } if ( pSq > 0 ) break ; } double d = s - pSq ; double P = ( d / ( 2.0 * N ) ) ; double A = N + P ; double sqrt_of_s = A - ( ( P * P ) / ( 2.0 * A ) ) ; return sqrt_of_s ; }

BLEU: 82.2
Edit Sim: 64


Src: 
function movesRequired ( a , b ) { let total_moves = a % b ; document . write ( total_moves ) ; }
Ref: 
void movesRequired ( int a , int b ) { int total_moves = a % b ; cout << total_moves << " STRNEWLINE " ; }
Hyp: 
void movesRequired ( int a , int b ) { int total_moves = a % b ; cout << total_moves ; }

BLEU: 78.29
Edit Sim: 18


Src: 
function minimumflip ( mat , n ) { let flip = 0 ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = 0 ; j < i ; j ++ ) if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) flip ++ ; return flip ; }
Ref: 
int minimumflip ( int mat [ ] [ N ] , int n ) { int flip = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) flip ++ ; return flip ; }
Hyp: 
int minimumflip ( int mat [ ] [ MAX ] , int n ) { int flip = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) flip ++ ; return flip ; }

BLEU: 96.51
Edit Sim: 3


Src: 
function findgroups ( arr , n ) { let c = [ 0 , 0 , 0 ] ; let i ; let res = 0 ; for ( i = 0 ; i < n ; i ++ ) c [ arr [ i ] % 3 ] ++ ; res += ( ( c [ 0 ] * ( c [ 0 ] - 1 ) ) >> 1 ) ; res += c [ 1 ] * c [ 2 ] ; res += ( c [ 0 ] * ( c [ 0 ] - 1 ) * Math . floor ( ( c [ 0 ] - 2 ) ) / 6 ) ; res += ( c [ 1 ] * ( c [ 1 ] - 1 ) * Math . floor ( ( c [ 1 ] - 2 ) ) / 6 ) ; res += ( Math . floor ( c [ 2 ] * ( c [ 2 ] - 1 ) * ( c [ 2 ] - 2 ) ) / 6 ) ; res += c [ 0 ] * c [ 1 ] * c [ 2 ] ; return res ; }
Ref: 
int findgroups ( int arr [ ] , int n ) { int c [ 3 ] = { 0 } , i ; int res = 0 ; for ( i = 0 ; i < n ; i ++ ) c [ arr [ i ] % 3 ] ++ ; res += ( ( c [ 0 ] * ( c [ 0 ] - 1 ) ) >> 1 ) ; res += c [ 1 ] * c [ 2 ] ; res += ( c [ 0 ] * ( c [ 0 ] - 1 ) * ( c [ 0 ] - 2 ) ) / 6 ; res += ( c [ 1 ] * ( c [ 1 ] - 1 ) * ( c [ 1 ] - 2 ) ) / 6 ; res += ( ( c [ 2 ] * ( c [ 2 ] - 1 ) * ( c [ 2 ] - 2 ) ) / 6 ) ; res += c [ 0 ] * c [ 1 ] * c [ 2 ] ; return res ; }
Hyp: 
int findgroups ( int arr [ ] , int n ) { int c [ 3 ] = { 0 } ; int i ; int res = 0 ; for ( i = 0 ; i < n ; i ++ ) c [ arr [ i ] % 3 ] ++ ; res += ( ( c [ 0 ] * ( c [ 0 ] - 1 ) ) >> 1 ) ; res += c [ 1 ] * c [ 2 ] ; res += ( c [ 0 ] * ( c [ 0 ] - 1 ) * floor ( ( c [ 0 ] - 2 ) ) / 6 ) ; res += ( c [ 1 ] * ( c [ 1 ] - 1 ) * floor ( ( c [ 1 ] - 2 ) ) / 6 ) ; res += ( c [ 2 ] * ( c [ 2 ] - 1 ) * ( c [ 2 ] - 2 ) ) / 6 ) ; res += c [ 0 ] * c [ 1 ] * c [ 2 ] ; return res ; }

BLEU: 92.4
Edit Sim: 27


Src: 
function countWays ( n , m ) { let count = new Array ( n + 1 ) ; count [ 0 ] = 0 ; let i ; for ( i = 1 ; i <= n ; i ++ ) { if ( i > m ) count [ i ] = count [ i - 1 ] + count [ i - m ] ; else if ( i < m i == 1 ) count [ i ] = 1 ; else count [ i ] = 2 ; } return count [ n ] ; }
Ref: 
int countWays ( int n , int m ) { int count [ n + 1 ] ; count [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i > m ) count [ i ] = count [ i - 1 ] + count [ i - m ] ; else if ( i < m i == 1 ) count [ i ] = 1 ; else count [ i ] = 2 ; } return count [ n ] ; }
Hyp: 
int countWays ( int n , int m ) { int count [ n + 1 ] ; count [ 0 ] = 0 ; int i ; for ( i = 1 ; i <= n ; i ++ ) { if ( i > m ) count [ i ] = count [ i - 1 ] + count [ i - m ] ; else if ( i < m i == 1 ) count [ i ] = 1 ; else count [ i ] = 2 ; } return count [ n ] ; }

BLEU: 95.17
Edit Sim: 11


Src: 
function findValues ( a , b ) { if ( ( a - b ) % 2 == 1 ) { document . write ( " " ) ; return ; } document . write ( ( a - b ) / 2 + " " + ( a + b ) / 2 ) ; }
Ref: 
void findValues ( int a , int b ) { if ( ( a - b ) % 2 == 1 ) { cout << " - 1" ; return ; } cout << ( a - b ) / 2 << " ▁ " << ( a + b ) / 2 ; }
Hyp: 
void findValues ( int a , int b ) { if ( ( a - b ) % 2 == 1 ) { cout << " No " ; return ; } cout << ( a - b ) / 2 << " , ▁ " << ( a + b ) / 2 ; }

BLEU: 89.0
Edit Sim: 5


Src: 
function getMaxDifference ( N ) { var M = - 1 ; var maxDiff = 0 ; for ( i = 0 ; i < N ; i ++ ) { var diff = ( N ^ i ) - ( N & i ) ; if ( diff >= maxDiff ) { maxDiff = diff ; M = i ; } } return M ; }
Ref: 
int getMaxDifference ( int N ) { int M = -1 ; int maxDiff = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int diff = ( N ^ i ) - ( N & i ) ; if ( diff >= maxDiff ) { maxDiff = diff ; M = i ; } } return M ; }
Hyp: 
int getMaxDifference ( int N ) { int M = -1 ; int maxDiff = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int diff = ( N ^ i ) - ( N & i ) ; if ( diff >= maxDiff ) { maxDiff = diff ; M = i ; } } return M ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countDigitOne ( n ) { var countr = 0 ; for ( var i = 1 ; i <= n ; i *= 10 ) { var divider = i * 10 ; countr += parseInt ( n / divider ) * i + Math . min ( Math . max ( n % divider - i + 1 , 0 ) , i ) ; } return countr ; }
Ref: 
int countDigitOne ( int n ) { int countr = 0 ; for ( int i = 1 ; i <= n ; i *= 10 ) { int divider = i * 10 ; countr += ( n / divider ) * i + min ( max ( n % divider - i + 1 , 0 ) , i ) ; } return countr ; }
Hyp: 
int countDigitOne ( int n ) { int countr = 0 ; for ( int i = 1 ; i <= n ; i *= 10 ) { int divider = i * 10 ; countr += n / divider * i + min ( max ( n % divider - i + 1 , 0 ) , i ) ; } return countr ; }

BLEU: 92.45
Edit Sim: 4


Src: 
function countRotations ( arr , low , high ) { if ( high < low ) return 0 ; if ( high == low ) return low ; let mid = Math . floor ( low + ( high - low ) / 2 ) ; if ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) return ( mid + 1 ) ; if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) return mid ; if ( arr [ high ] > arr [ mid ] ) return countRotations ( arr , low , mid - 1 ) ; return countRotations ( arr , mid + 1 , high ) ; }
Ref: 
int countRotations ( int arr [ ] , int low , int high ) { if ( high < low ) return 0 ; if ( high == low ) return low ; int mid = low + ( high - low ) / 2 ; if ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) return ( mid + 1 ) ; if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) return mid ; if ( arr [ high ] > arr [ mid ] ) return countRotations ( arr , low , mid - 1 ) ; return countRotations ( arr , mid + 1 , high ) ; }
Hyp: 
int countRotations ( int arr [ ] , int low , int high ) { if ( high < low ) return 0 ; if ( high == low ) return low ; int mid = low + ( high - low ) / 2 ; if ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) return ( mid + 1 ) ; if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) return mid ; if ( arr [ high ] > arr [ mid ] ) return countRotations ( arr , low , mid - 1 ) ; return countRotations ( arr , mid + 1 , high ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function addNDigits ( a , b , n ) { let num = a ; for ( let i = 0 ; i <= 9 ; i ++ ) { let tmp = a * 10 + i ; if ( tmp % b == 0 ) { a = tmp ; break ; } } if ( num == a ) return - 1 ; for ( let j = 0 ; j < n - 1 ; j ++ ) a *= 10 ; return a ; }
Ref: 
int addNDigits ( int a , int b , int n ) { int num = a ; for ( int i = 0 ; i <= 9 ; i ++ ) { int tmp = a * 10 + i ; if ( tmp % b == 0 ) { a = tmp ; break ; } } if ( num == a ) return -1 ; for ( int j = 0 ; j < n - 1 ; j ++ ) a *= 10 ; return a ; }
Hyp: 
int addNDigits ( int a , int b , int n ) { int num = a ; for ( int i = 0 ; i <= 9 ; i ++ ) { int tmp = a * 10 + i ; if ( tmp % b == 0 ) { a = tmp ; break ; } } if ( num == a ) return -1 ; for ( int j = 0 ; j < n - 1 ; j ++ ) a *= 10 ; return a ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function maxMin ( arr , n ) { let min = + 2147483647 ; let max = - 2147483648 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j <= n / 2 ; j ++ ) { if ( arr [ i ] [ j ] > arr [ i ] [ n - j - 1 ] ) { if ( min > arr [ i ] [ n - j - 1 ] ) min = arr [ i ] [ n - j - 1 ] ; if ( max < arr [ i ] [ j ] ) max = arr [ i ] [ j ] ; } else { if ( min > arr [ i ] [ j ] ) min = arr [ i ] [ j ] ; if ( max < arr [ i ] [ n - j - 1 ] ) max = arr [ i ] [ n - j - 1 ] ; } } } document . write ( " " + max + " " + min ) ; }
Ref: 
void maxMin ( int arr [ ] [ MAX ] , int n ) { int min = INT_MAX ; int max = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j <= n / 2 ; j ++ ) { if ( arr [ i ] [ j ] > arr [ i ] [ n - j - 1 ] ) { if ( min > arr [ i ] [ n - j - 1 ] ) min = arr [ i ] [ n - j - 1 ] ; if ( max < arr [ i ] [ j ] ) max = arr [ i ] [ j ] ; } else { if ( min > arr [ i ] [ j ] ) min = arr [ i ] [ j ] ; if ( max < arr [ i ] [ n - j - 1 ] ) max = arr [ i ] [ n - j - 1 ] ; } } } cout << " Maximum ▁ = ▁ " << max << " , ▁ Minimum ▁ = ▁ " << min ; }
Hyp: 
void maxMin ( int arr [ ] [ MAX ] , int n ) { int min = + 2147483647 ; int max = - 2147483648 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j <= n / 2 ; j ++ ) { if ( arr [ i ] [ j ] > arr [ i ] [ n - j - 1 ] ) { if ( min > arr [ i ] [ n - j - 1 ] ) min = arr [ i ] [ n - j - 1 ] ; if ( max < arr [ i ] [ j ] ) max = arr [ i ] [ j ] ; } else { if ( min > arr [ i ] [ j ] ) min = arr [ i ] [ j ] ; if ( max < arr [ i ] [ n - j - 1 ] ) max = arr [ i ] [ n - j - 1 ] ; } } } cout << " Maximum ▁ Minimum ▁ Number ▁ is ▁ " << max << " ▁ minimum ▁ " << min ; }

BLEU: 92.76
Edit Sim: 52


Src: 
function Max_Sum ( arr1 , arr2 , n ) { let dp = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { dp [ i ] = new Array ( 2 ) ; for ( let j = 0 ; j < 2 ; j ++ ) { dp [ i ] [ j ] = 0 ; } } for ( let i = 0 ; i < n ; i ++ ) { if ( i == 0 ) { dp [ i ] [ 0 ] = arr1 [ i ] ; dp [ i ] [ 1 ] = arr2 [ i ] ; continue ; } dp [ i ] [ 0 ] = Math . max ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] + arr1 [ i ] ) ; dp [ i ] [ 1 ] = Math . max ( dp [ i - 1 ] [ 1 ] , dp [ i - 1 ] [ 0 ] + arr2 [ i ] ) ; } return Math . max ( dp [ n - 1 ] [ 0 ] , dp [ n - 1 ] [ 1 ] ) ; }
Ref: 
int Max_Sum ( int arr1 [ ] , int arr2 [ ] , int n ) { int dp [ n ] [ 2 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( i == 0 ) { dp [ i ] [ 0 ] = arr1 [ i ] ; dp [ i ] [ 1 ] = arr2 [ i ] ; continue ; } dp [ i ] [ 0 ] = max ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] + arr1 [ i ] ) ; dp [ i ] [ 1 ] = max ( dp [ i - 1 ] [ 1 ] , dp [ i - 1 ] [ 0 ] + arr2 [ i ] ) ; } return max ( dp [ n - 1 ] [ 0 ] , dp [ n - 1 ] [ 1 ] ) ; }
Hyp: 
int Max_Sum ( int arr1 [ ] , int arr2 [ ] , int n ) { int dp [ n ] [ 2 ] ; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] [ 0 ] = arr1 [ i ] ; dp [ i ] [ 1 ] = arr2 [ i ] ; continue ; } dp [ i ] [ 0 ] = max ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] + arr1 [ i ] ) ; dp [ i ] [ 1 ] = max ( dp [ i - 1 ] [ 1 ] , dp [ i - 1 ] [ 0 ] + arr2 [ i ] ) ; } return max ( dp [ n - 1 ] [ 0 ] , dp [ n - 1 ] [ 1 ] ) ; }

BLEU: 95.77
Edit Sim: 16


Src: 
function xorPairCount ( arr , n , x ) { let m = new Map ( ) ; for ( let i = 0 ; i < n ; i ++ ) { let curr_xor = x ^ arr [ i ] ; if ( m . has ( curr_xor ) ) result += m . get ( curr_xor ) ; if ( m . has ( arr [ i ] ) ) { m . set ( arr [ i ] , m . get ( arr [ i ] ) + 1 ) ; } else { m . set ( arr [ i ] , 1 ) ; } } return result ; }
Ref: 
int xorPairCount ( int arr [ ] , int n , int x ) { unordered_map < int , int > m ; for ( int i = 0 ; i < n ; i ++ ) { int curr_xor = x ^ arr [ i ] ; if ( m . find ( curr_xor ) != m . end ( ) ) result += m [ curr_xor ] ; m [ arr [ i ] ] ++ ; } return result ; }
Hyp: 
int xorPairCount ( int arr [ ] , int n , int x ) { unordered_map < int , int > m ; for ( int i = 0 ; i < n ; i ++ ) { int curr_xor = x ^ arr [ i ] ; if ( m . find ( curr_xor ) != m . end ( ) ) result += m [ curr_xor ] ; if ( m . find ( arr [ i ] ) != m . end ( ) ) m [ arr [ i ] ] ++ ; } return result ; }

BLEU: 80.76
Edit Sim: 45


Src: 
function cube ( h , r ) { if ( h < 0 && r < 0 ) return - 1 ; var a = Math . pow ( h , 3 ) ; return a ; }
Ref: 
float cube ( float h , float r ) { if ( h < 0 && r < 0 ) return -1 ; float a = pow ( h , 3 ) ; return a ; }
Hyp: 
float cubeSide ( float h , float r ) { if ( h < 0 && r < 0 ) return -1 ; float a = pow ( h , 3 ) ; return a ; }

BLEU: 95.16
Edit Sim: 4


Src: 
function maxOR ( arr , n ) { var max_value = Math . max . apply ( Math , arr ) ; var number_of_bits = parseInt ( ( ( Math . log ( max_value ) ) ) ) + 2 ; var complement = ( ( 1 << number_of_bits ) - 1 ) ^ max_value ; var c = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != max_value ) { c = Math . max ( c , ( complement & arr [ i ] ) ) ; } } return ( max_value + c ) ; }
Ref: 
int maxOR ( int arr [ ] , int n ) { int max_value = * max_element ( arr , arr + n ) ; int number_of_bits = floor ( log2 ( max_value ) ) + 1 ; int complement = ( ( 1 << number_of_bits ) - 1 ) ^ max_value ; int c = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != max_value ) { c = max ( c , ( complement & arr [ i ] ) ) ; } } return ( max_value + c ) ; }
Hyp: 
int maxOR ( int arr [ ] , int n ) { int max_value = * max_element ( arr , arr + n ) ; int number_of_bits = log2 ( max_value ) ; int complement = ( ( 1 << number_of_bits ) - 1 ) ^ max_value ; int c = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != max_value ) { c = max ( c , ( complement & arr [ i ] ) ) ; } } return ( max_value + c ) ; }

BLEU: 92.5
Edit Sim: 14


Src: 
function seriesSum ( n ) { let i = 1 ; let res = 0.0 ; let sign = true ; while ( n > 0 ) { n -- ; if ( sign ) { sign = ! sign ; res = res + ++ i / ++ i ; } else { sign = ! sign ; res = res - ++ i / ++ i ; } } return res ; }
Ref: 
double seriesSum ( int n ) { int i = 1 ; double res = 0.0 ; bool sign = true ; while ( n > 0 ) { n -- ; if ( sign ) { sign = ! sign ; res = res + ( double ) ++ i / ++ i ; } else { sign = ! sign ; res = res - ( double ) ++ i / ++ i ; } } return res ; }
Hyp: 
double seriesSum ( int n ) { int i = 1 ; double res = 0.0 ; bool sign = true ; while ( n > 0 ) { n -- ; if ( sign ) { sign = ! sign ; res = res + ++ i / ++ i ; } else { sign = ! sign ; res = res - ++ i / ++ i ; } } return res ; }

BLEU: 88.65
Edit Sim: 22


Src: 
function MegagonNum ( n ) { return ( 999998 * n * n - 999996 * n ) / 2 ; }
Ref: 
int MegagonNum ( int n ) { return ( 999998 * n * n - 999996 * n ) / 2 ; }
Hyp: 
int MegagonNum ( int n ) { return ( 999998 * n * n - 999996 * n ) / 2 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function permutation ( arr , n ) { let hash = new Set ( ) ; let maxEle = 0 ; for ( let i = 0 ; i < n ; i ++ ) { hash . add ( arr [ i ] ) ; maxEle = Math . max ( maxEle , arr [ i ] ) ; } if ( maxEle != n ) return false ; if ( hash . length == n ) return true ; return false ; }
Ref: 
bool permutation ( int arr [ ] , int n ) { set < int > hash ; int maxEle = 0 ; for ( int i = 0 ; i < n ; i ++ ) { hash . insert ( arr [ i ] ) ; maxEle = max ( maxEle , arr [ i ] ) ; } if ( maxEle != n ) return false ; if ( hash . size ( ) == n ) return true ; return false ; }
Hyp: 
bool permutation ( int arr [ ] , int n ) { unordered_set < int > hash ; int maxEle = 0 ; for ( int i = 0 ; i < n ; i ++ ) { hash . insert ( arr [ i ] ) ; maxEle = max ( maxEle , arr [ i ] ) ; } if ( maxEle != n ) return false ; if ( hash . size ( ) == n ) return true ; return false ; }

BLEU: 97.08
Edit Sim: 10


Src: 
function minLettersNeeded ( n ) { if ( n % 26 == 0 ) return parseInt ( n / 26 ) ; else return ( parseInt ( n / 26 ) + 1 ) ; }
Ref: 
int minLettersNeeded ( int n ) { if ( n % 26 == 0 ) return ( n / 26 ) ; else return ( ( n / 26 ) + 1 ) ; }
Hyp: 
int minLettersNeeded ( int n ) { if ( n % 26 == 0 ) return n / 26 ; else return ( n / 26 + 1 ) ; }

BLEU: 72.91
Edit Sim: 8


Src: 
function findSumOfGP ( a , r ) { if ( Math . abs ( r ) >= 1 ) { document . write ( " " ) ; return ; } let sum = a / ( 1 - r ) ; document . write ( sum ) ; }
Ref: 
void findSumOfGP ( double a , double r ) { if ( abs ( r ) >= 1 ) { cout << " Infinite " ; return ; } double sum = a / ( 1 - r ) ; cout << sum ; }
Hyp: 
void findSumOfGP ( float a , float r ) { if ( abs ( r ) >= 1 ) { cout << " NO " ; return ; } float sum = a / ( 1 - r ) ; cout << sum ; }

BLEU: 77.22
Edit Sim: 26


Src: 
function shortestChainLen ( start , target , D ) { if ( start == target ) return 0 ; if ( ! D . has ( target ) ) return 0 ; let level = 0 , wordlength = start . length ; let Q = [ ] ; Q . push ( start ) ; while ( Q . length != 0 ) { ++ level ; let sizeofQ = Q . length ; for ( let i = 0 ; i < sizeofQ ; ++ i ) { let word = Q [ 0 ] . split ( " " ) ; Q . shift ( ) ; for ( let pos = 0 ; pos < wordlength ; ++ pos ) { let orig_char = word [ pos ] ; for ( let c = ' ' . charCodeAt ( 0 ) ; c <= ' ' . charCodeAt ( 0 ) ; ++ c ) { word [ pos ] = String . fromCharCode ( c ) ; if ( word . join ( " " ) == target ) return level + 1 ; if ( ! D . has ( word . join ( " " ) ) ) continue ; D . delete ( word . join ( " " ) ) ; Q . push ( word . join ( " " ) ) ; } word [ pos ] = orig_char ; } } } return 0 ; }
Ref: 
int shortestChainLen ( string start , string target , set < string > & D ) { if ( start == target ) return 0 ; if ( D . find ( target ) == D . end ( ) ) return 0 ; int level = 0 , wordlength = start . size ( ) ; queue < string > Q ; Q . push ( start ) ; while ( ! Q . empty ( ) ) { ++ level ; int sizeofQ = Q . size ( ) ; for ( int i = 0 ; i < sizeofQ ; ++ i ) { string word = Q . front ( ) ; Q . pop ( ) ; for ( int pos = 0 ; pos < wordlength ; ++ pos ) { char orig_char = word [ pos ] ; for ( char c = ' a ' ; c <= ' z ' ; ++ c ) { word [ pos ] = c ; if ( word == target ) return level + 1 ; if ( D . find ( word ) == D . end ( ) ) continue ; D . erase ( word ) ; Q . push ( word ) ; } word [ pos ] = orig_char ; } } } return 0 ; }
Hyp: 
int shortestChainLen ( string start , string target , map < string , int > & D ) { if ( start == target ) return 0 ; if ( ! D . find ( target ) != D . end ( ) ) return 0 ; int level = 0 , wordlength = start . length ( ) ; queue < string > Q ; Q . push_back ( start ) ; while ( Q . size ( ) != 0 ) { ++ level ; int sizeofQ = Q . size ( ) ; for ( int pos = 0 ; pos < wordlength ; ++ pos ) { char orig_char = word [ pos ] ; for ( int c = ' A ' ; c <= ' Z ' ; ++ c ) { word [ pos ] = char ( c ) ; if ( word . join ( " ▁ " ) == target ) return level + 1 ; if ( D . find ( word . join ( " ▁ " ) == D . end ( ) ) continue ; D [ word . join ( " ▁ " ) ] = orig_char ; } word [ pos ] = orig_char ; } } } return 0 ; }

BLEU: 69.27
Edit Sim: 194


Src: 
function Cells ( n , x ) { let ans = 0 ; for ( let i = 1 ; i <= n ; i ++ ) if ( x % i == 0 && parseInt ( x / i ) <= n ) ans ++ ; return ans ; }
Ref: 
int Cells ( int n , int x ) { int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) if ( x % i == 0 && x / i <= n ) ans ++ ; return ans ; }
Hyp: 
int Cells ( int n , int x ) { int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) if ( x % i == 0 && x / i <= n ) ans ++ ; return ans ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function sumOfSeries ( n ) { return n * ( n + 1 ) * ( 6 * n * n * n + 9 * n * n + n - 1 ) / 30 ; }
Ref: 
int sumOfSeries ( int n ) { return n * ( n + 1 ) * ( 6 * n * n * n + 9 * n * n + n - 1 ) / 30 ; }
Hyp: 
int sumOfSeries ( int n ) { return n * ( n + 1 ) * ( 6 * n * n * n + 9 * n * n + n - 1 ) / 30 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countNumberOfTriangles ( n ) { return n * ( n - 1 ) * ( n - 2 ) / 6 ; }
Ref: 
int countNumberOfTriangles ( int n ) { return n * ( n - 1 ) * ( n - 2 ) / 6 ; }
Hyp: 
ll countNumberOfTriangles ( ll n ) { return n * ( n - 1 ) * ( n - 2 ) / 6 ; }

BLEU: 86.48
Edit Sim: 6


Src: 
function maxSumSubarray ( arr , n ) { var i = 0 , j = 1 ; var set = new Set ( ) ; set . add ( arr [ 0 ] ) ; var sum = arr [ 0 ] ; var maxsum = sum ; while ( i < n - 1 && j < n ) { var is_in = set . has ( arr [ j ] ) ; if ( ! is_in ) { sum = sum + arr [ j ] ; maxsum = Math . max ( sum , maxsum ) ; set . add ( arr [ j ++ ] ) ; } else { sum -= arr [ i ] ; set . delete ( arr [ i ++ ] ) ; } } return maxsum ; }
Ref: 
int maxSumSubarray ( int arr [ ] , int n ) { int i = 0 , j = 1 ; set < int > set ; set . insert ( arr [ 0 ] ) ; int sum = arr [ 0 ] ; int maxsum = sum ; while ( i < n - 1 && j < n ) { const bool is_in = set . find ( arr [ j ] ) != set . end ( ) ; if ( ! is_in ) { sum = sum + arr [ j ] ; maxsum = max ( sum , maxsum ) ; set . insert ( arr [ j ++ ] ) ; } else { sum -= arr [ i ] ; set . erase ( arr [ i ++ ] ) ; } } return maxsum ; }
Hyp: 
int maxSumSubarray ( int arr [ ] , int n ) { int i = 0 , j = 1 ; unordered_set < int > set ; set . insert ( arr [ 0 ] ) ; int sum = arr [ 0 ] ; int maxsum = sum ; while ( i < n - 1 && j < n ) { bool is_in = set . find ( arr [ j ] ) != set . end ( ) ; if ( is_in ) { sum = sum + arr [ j ] ; maxsum = max ( sum , maxsum ) ; set . insert ( arr [ j ++ ] ) ; } else { sum -= arr [ i ] ; set . delete ( arr [ i ++ ] ) ; } } return maxsum ; }

BLEU: 93.0
Edit Sim: 22


Src: 
function print_C ( p0 ) { let p1 = 0 ; let i = 0 ; let x ; let flag ; let k ; while ( 1 ) { flag = 1 ; x = Math . pow ( 2 , i ) ; p1 = x * p0 + ( x - 1 ) ; for ( let k = 2 ; k < p1 ; k ++ ) { if ( p1 % k == 0 ) { flag = 0 ; break ; } } if ( flag == 0 ) break ; document . write ( p1 + " " ) ; i ++ ; } }
Ref: 
void print ( int p0 ) { int p1 , i = 0 , x , flag , k ; while ( 1 ) { flag = 1 ; x = ( int ) ( pow ( 2 , i ) ) ; p1 = x * p0 + ( x - 1 ) ; for ( k = 2 ; k < p1 ; k ++ ) { if ( p1 % k == 0 ) { flag = 0 ; break ; } } if ( flag == 0 ) break ; printf ( " % d ▁ " , p1 ) ; i ++ ; } }
Hyp: 
void print_C ( int p0 ) { int p1 = 0 ; int i = 0 ; int x ; int flag ; int k ; while ( 1 ) { flag = 1 ; x = pow ( 2 , i ) ; p1 = x * p0 + ( x - 1 ) ; for ( int k = 2 ; k < p1 ; k ++ ) { if ( p1 % k == 0 ) { flag = 0 ; break ; } } if ( flag == 0 ) break ; cout << p1 << " ▁ " ; i ++ ; } }

BLEU: 73.14
Edit Sim: 60


Src: 
function count ( s ) { let N , i , cnt = 0 , ans = 0 ; N = s . length ; for ( i = 0 ; i < N ; i ++ ) { if ( s [ i ] == ' ' ) cnt ++ ; if ( s [ i ] == ' ' ) ans += cnt ; } return ans ; }
Ref: 
int count ( string s ) { int N , i , cnt = 0 , ans = 0 ; N = s . length ( ) ; for ( i = 0 ; i < N ; i ++ ) { if ( s [ i ] == ' R ' ) cnt ++ ; if ( s [ i ] == ' L ' ) ans += cnt ; } return ans ; }
Hyp: 
int count ( string s ) { int N , i , cnt = 0 , ans = 0 ; N = s . length ( ) ; for ( i = 0 ; i < N ; i ++ ) { if ( s [ i ] == '1' ) cnt ++ ; if ( s [ i ] == '2' ) ans += cnt ; } return ans ; }

BLEU: 87.88
Edit Sim: 6


Src: 
function countNums ( l , r ) { let cnt = 0 ; for ( let i = l ; i <= r ; i ++ ) { let lastDigit = ( i % 10 ) ; if ( ( lastDigit % 10 ) == 2 || ( lastDigit % 10 ) == 3 || ( lastDigit % 10 ) == 9 ) { cnt ++ ; } } return cnt ; }
Ref: 
int countNums ( int l , int r ) { int cnt = 0 ; for ( int i = l ; i <= r ; i ++ ) { int lastDigit = ( i % 10 ) ; if ( ( lastDigit % 10 ) == 2 || ( lastDigit % 10 ) == 3 || ( lastDigit % 10 ) == 9 ) { cnt ++ ; } } return cnt ; }
Hyp: 
int countNums ( int l , int r ) { int cnt = 0 ; for ( int i = l ; i <= r ; i ++ ) { int lastDigit = ( i % 10 ) ; if ( ( lastDigit % 10 ) == 2 || ( lastDigit % 10 ) == 3 || ( lastDigit % 10 ) == 9 ) { cnt ++ ; } } return cnt ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function solve ( A , B ) { var count = 0 ; for ( i = 0 ; i < 32 ; i ++ ) { if ( ( ( A >> i ) & 1 ) != ( ( B >> i ) & 1 ) ) { count ++ ; } } document . write ( " " + count ) ; }
Ref: 
void solve ( int A , int B ) { int count = 0 ; for ( int i = 0 ; i < 32 ; i ++ ) { if ( ( ( A >> i ) & 1 ) != ( ( B >> i ) & 1 ) ) { count ++ ; } } cout << " Number ▁ of ▁ different ▁ bits ▁ : ▁ " << count << endl ; }
Hyp: 
void solve ( int A , int B ) { int count = 0 ; for ( int i = 0 ; i < 32 ; i ++ ) { if ( ( ( A >> i ) & 1 ) != ( ( B >> i ) & 1 ) ) { count ++ ; } } cout << " Yes " << count ; }

BLEU: 79.99
Edit Sim: 42


Src: 
function minCost ( arr , A , B ) { let n = arr . length ; let m = arr [ 0 ] . length ; let ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < m ; j ++ ) { if ( arr [ i ] [ j ] == ' ' ) continue ; if ( j == m - 1 ) ans += A ; else { if ( arr [ i ] [ j + 1 ] == ' ' ) { ans += Math . min ( 2 * A , B ) ; j ++ ; } else ans += A ; } } } document . write ( ans ) ; }
Ref: 
void minCost ( vector < vector < char > > arr , int A , int B ) { int n = arr . size ( ) ; int m = arr [ 0 ] . size ( ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( arr [ i ] [ j ] == ' * ' ) continue ; if ( j == m - 1 ) ans += A ; else { if ( arr [ i ] [ j + 1 ] == ' . ' ) { ans += min ( 2 * A , B ) ; j ++ ; } else ans += A ; } } } cout << ans ; }
Hyp: 
int minCost ( string arr [ ] , int A , int B ) { int n = arr . size ( ) ; int m = arr [ 0 ] . size ( ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( arr [ i ] [ j ] == '0' ) continue ; if ( j == m - 1 ) ans += A ; else { if ( arr [ i ] [ j + 1 ] == '1' ) { ans += min ( 2 * A , B ) ; j ++ ; } else ans += A ; } } } cout << ans ; }

BLEU: 87.13
Edit Sim: 33


Src: 
function maxPartition ( s ) { var n = s . length , P = 0 ; var current = " " , previous = " " ; for ( var i = 0 ; i < n ; i ++ ) { current += s [ i ] ; if ( current != previous ) { previous = current ; current = " " ; P ++ ; } } return P ; }
Ref: 
int maxPartition ( string s ) { int n = s . length ( ) , P = 0 ; string current = " " , previous = " " ; for ( int i = 0 ; i < n ; i ++ ) { current += s [ i ] ; if ( current != previous ) { previous = current ; current . clear ( ) ; P ++ ; } } return P ; }
Hyp: 
int maxPartition ( string s ) { int n = s . length ( ) , P = 0 ; string current = " " , previous = " " ; for ( int i = 0 ; i < n ; i ++ ) { current += s [ i ] ; if ( current != previous ) { previous = current ; current = " " ; P ++ ; } } return P ; }

BLEU: 92.96
Edit Sim: 9


Src: 
function findXandYwithminABSX_Y ( N ) { if ( N % 2 == 1 ) { document . write ( ( N / 2 ) + " " + ( N / 2 + 1 ) ) ; } else { document . write ( ( N / 2 - 1 ) + " " + ( N / 2 + 1 ) ) ; } }
Ref: 
void findXandYwithminABSX_Y ( int N ) { if ( N % 2 == 1 ) { cout << ( N / 2 ) << " ▁ " << ( N / 2 + 1 ) ; } else { cout << ( N / 2 - 1 ) << " ▁ " << ( N / 2 + 1 ) ; } }
Hyp: 
void findXandYwithminABSX_Y ( int N ) { if ( N % 2 == 1 ) { cout << ( N / 2 ) << " ▁ " << N / 2 + 1 ; } else { cout << ( N / 2 - 1 ) << " ▁ " << N / 2 + 1 ; } }

BLEU: 83.4
Edit Sim: 8


Src: 
function polydiagonal ( n , a ) { if ( a < 0 && n < 0 ) { return - 1 ; } return ( 2 * a * Math . sin ( ( ( ( n - 2 ) * 180 ) / ( 2 * n ) ) * 3.14159 / 180 ) ) ; }
Ref: 
float polydiagonal ( float n , float a ) { if ( a < 0 && n < 0 ) return -1 ; return 2 * a * sin ( ( ( ( n - 2 ) * 180 ) / ( 2 * n ) ) * 3.14159 / 180 ) ; }
Hyp: 
float polydiagonal ( float n , float a ) { if ( a < 0 && n < 0 ) { return -1 ; } return 2 * a * sin ( ( ( n - 2 ) * 180 ) / ( 2 * n ) ) * 3.14159 / 180 ) ; }

BLEU: 90.64
Edit Sim: 6


Src: 
function findStr ( S ) { var n = S . length ; for ( var i = 0 ; i < n / 2 ; ++ i ) { if ( S [ i ] != ' ' ) { S [ i ] = ' ' ; return S . join ( " " ) ; ; } } S [ n - 1 ] = ' ' ; return n < 2 ? " " : S . join ( " " ) ; ; }
Ref: 
string findStr ( string S ) { int n = S . size ( ) ; for ( int i = 0 ; i < n / 2 ; ++ i ) { if ( S [ i ] != ' a ' ) { S [ i ] = ' a ' ; return S ; } } S [ n - 1 ] = ' b ' ; return n < 2 ? " ▁ - 1 ▁ " : S ; }
Hyp: 
string findStr ( string & S ) { int n = S . length ( ) ; for ( int i = 0 ; i < n / 2 ; ++ i ) { if ( S [ i ] != '0' ) { S [ i ] = '1' ; return S . join ( "0" ) ; ; } } S [ n - 1 ] = '0' ; return n < 2 ? " " : S . join ( "1" ) ; }

BLEU: 66.98
Edit Sim: 48


Src: 
function nthKyneaNumber ( n ) { return ( ( 1 << ( 2 * n ) ) + ( 1 << ( n + 1 ) ) - 1 ) ; }
Ref: 
long nthKyneaNumber ( int n ) { return ( ( 1 << ( 2 * n ) ) + ( 1 << ( n + 1 ) ) - 1 ) ; }
Hyp: 
int nthKyneaNumber ( int n ) { return ( ( 1 << ( 2 * n ) ) + ( 1 << ( n + 1 ) ) - 1 ) ; }

BLEU: 96.92
Edit Sim: 3


Src: 
function rearrange ( a , size ) { let positive = 0 ; let negative = 1 ; let temp ; while ( true ) { while ( positive < size && a [ positive ] >= 0 ) positive += 2 ; while ( negative < size && a [ negative ] <= 0 ) negative += 2 ; if ( positive < size && negative < size ) { temp = a [ positive ] ; a [ positive ] = a [ negative ] ; a [ negative ] = temp ; } else break ; } }
Ref: 
void rearrange ( int a [ ] , int size ) { int positive = 0 , negative = 1 ; while ( true ) { while ( positive < size && a [ positive ] >= 0 ) positive += 2 ; while ( negative < size && a [ negative ] <= 0 ) negative += 2 ; if ( positive < size && negative < size ) swap ( a [ positive ] , a [ negative ] ) ; else break ; } }
Hyp: 
void rearrange ( int a [ ] , int size ) { int positive = 0 ; int negative = 1 ; int temp ; while ( true ) { while ( positive < size && a [ positive ] >= 0 ) positive += 2 ; while ( negative < size && a [ negative ] <= 0 ) negative += 2 ; if ( positive < size && negative < size ) { temp = a [ positive ] ; a [ positive ] = a [ negative ] ; a [ negative ] = temp ; } else break ; } }

BLEU: 71.49
Edit Sim: 64


Src: 
function arekAnagrams ( str1 , str2 , k ) { let n = str1 . length ; if ( str2 . length != n ) return false ; let count1 = new Array ( MAX_CHAR ) ; let count2 = new Array ( MAX_CHAR ) ; let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) count1 [ str1 [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; for ( let i = 0 ; i < n ; i ++ ) count2 [ str2 [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; for ( let i = 0 ; i < MAX_CHAR ; i ++ ) if ( count1 [ i ] > count2 [ i ] ) count = count + Math . abs ( count1 [ i ] - count2 [ i ] ) ; return ( count <= k ) ; }
Ref: 
bool arekAnagrams ( string str1 , string str2 , int k ) { int n = str1 . length ( ) ; if ( str2 . length ( ) != n ) return false ; int count1 [ MAX_CHAR ] = { 0 } ; int count2 [ MAX_CHAR ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) count1 [ str1 [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < n ; i ++ ) count2 [ str2 [ i ] - ' a ' ] ++ ; int count = 0 ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) if ( count1 [ i ] > count2 [ i ] ) count = count + abs ( count1 [ i ] - count2 [ i ] ) ; return ( count <= k ) ; }
Hyp: 
bool arekAnagrams ( string str1 , string str2 , int k ) { int n = str1 . length ( ) ; if ( str2 . length ( ) != n ) return false ; int count1 [ MAX_CHAR ] , count2 [ MAX_CHAR ] ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) count1 [ str1 [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < n ; i ++ ) count2 [ str2 [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) if ( count1 [ i ] > count2 [ i ] ) count = count + abs ( count1 [ i ] - count2 [ i ] ) ; return ( count <= k ) ; }

BLEU: 91.48
Edit Sim: 41


Src: 
function xorZero ( s ) { let one_count = 0 , zero_count = 0 ; let n = s . length ; for ( let i = 0 ; i < n ; i ++ ) if ( s [ i ] == ' ' ) one_count ++ ; else zero_count ++ ; if ( one_count % 2 == 0 ) return zero_count ; return one_count ; }
Ref: 
int xorZero ( string str ) { int one_count = 0 , zero_count = 0 ; int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) if ( str [ i ] == '1' ) one_count ++ ; else zero_count ++ ; if ( one_count % 2 == 0 ) return zero_count ; return one_count ; }
Hyp: 
int xorZero ( string s ) { int one_count = 0 , zero_count = 0 ; int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) if ( s [ i ] == '0' ) one_count ++ ; else zero_count ++ ; if ( one_count % 2 == 0 ) return zero_count ; return one_count ; }

BLEU: 85.24
Edit Sim: 7


Src: 
function isPrime ( n , i ) { if ( n <= 2 ) return ( n == 2 ) ? true : false ; if ( n % i == 0 ) return false ; if ( i * i > n ) return true ; return isPrime ( n , i + 1 ) ; }
Ref: 
bool isPrime ( int n , int i = 2 ) { if ( n <= 2 ) return ( n == 2 ) ? true : false ; if ( n % i == 0 ) return false ; if ( i * i > n ) return true ; return isPrime ( n , i + 1 ) ; }
Hyp: 
bool isPrime ( int n , int i ) { if ( n <= 2 ) return ( n == 2 ) ? true : false ; if ( n % i == 0 ) return false ; if ( i * i > n ) return true ; return isPrime ( n , i + 1 ) ; }

BLEU: 94.23
Edit Sim: 4


Src: 
function maxAverage ( A , N , X , Y ) { A . sort ( function ( a , b ) { return a - b ; } ) let sum = 0 ; let res = 0 ; let count = 0 ; for ( let i = 0 ; i < N ; i ++ ) { sum += A [ i ] ; count ++ ; if ( count == X ) { if ( N - i - 1 < X ) { i ++ ; let cnt = 0 ; while ( i < N ) { cnt ++ ; sum += A [ i ] ; i ++ ; } X = X + cnt ; res += sum / X ; break ; } res += sum / X ; sum = 0 ; count = 0 ; } } document . write ( res . toPrecision ( 3 ) ) }
Ref: 
void maxAverage ( int A [ ] , int N , int X , int Y ) { sort ( A , A + N ) ; int sum = 0 ; double res = 0 ; int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += A [ i ] ; count ++ ; if ( count == X ) { if ( N - i - 1 < X ) { i ++ ; int cnt = 0 ; while ( i < N ) { cnt ++ ; sum += A [ i ] ; i ++ ; } X = X + cnt ; res += ( double ) sum / double ( X ) ; break ; } res += ( double ) sum / double ( X ) ; sum = 0 ; count = 0 ; } } cout << fixed << setprecision ( 2 ) << res << " STRNEWLINE " ; }
Hyp: 
void maxAverage ( int A [ ] , int N , int X , int Y ) { sort ( A , A + N ) ; int sum = 0 ; int res = 0 ; int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += A [ i ] ; count ++ ; if ( count == X ) { if ( N - i - 1 < X ) { i ++ ; int cnt = 0 ; while ( i < N ) { cnt ++ ; sum += A [ i ] ; i ++ ; } X = X + cnt ; res += sum / X ; break ; } res += sum / X ; sum = 0 ; count = 0 ; } } cout << res ; }

BLEU: 79.2
Edit Sim: 99


Src: 
function newvol ( x ) { document . write ( " " + " " + ( Math . pow ( x , 3 ) / 10000 + 3 * x + ( 3 * Math . pow ( x , 2 ) ) / 100 ) + " " ) ; }
Ref: 
void newvol ( double x ) { cout << " percentage ▁ increase ▁ in ▁ the " << " ▁ volume ▁ of ▁ the ▁ sphere ▁ is ▁ " << pow ( x , 3 ) / 10000 + 3 * x + ( 3 * pow ( x , 2 ) ) / 100 << " % " << endl ; }
Hyp: 
void newvol ( double x ) { cout << " percentage ▁ increase ▁ " << " in ▁ the ▁ volume ▁ of ▁ the ▁ cylinder ▁ is ▁ " << pow ( x , 3 ) / 10000 + 3 * x + ( 3 * pow ( x , 2 ) ) / 100 << endl ; }

BLEU: 81.37
Edit Sim: 29


Src: 
function nthTerm ( n ) { return 3 * Math . pow ( n , 2 ) - 4 * n + 2 ; }
Ref: 
int nthTerm ( int n ) { return 3 * pow ( n , 2 ) - 4 * n + 2 ; }
Hyp: 
int nthTerm ( int n ) { return 3 * pow ( n , 2 ) - 4 * n + 2 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function splitArray ( arr , N ) { arr . sort ( ) ; let result = Number . MAX_VALUE ; for ( let i = 1 ; i < N ; i ++ ) { result = Math . min ( result , arr [ i ] - arr [ i - 1 ] ) ; } return result ; }
Ref: 
int splitArray ( int arr [ ] , int N ) { sort ( arr , arr + N ) ; int result = INT_MAX ; for ( int i = 1 ; i < N ; i ++ ) { result = min ( result , arr [ i ] - arr [ i - 1 ] ) ; } return result ; }
Hyp: 
int splitArray ( int arr [ ] , int N ) { sort ( arr , arr + N ) ; int result = INT_MAX ; for ( int i = 1 ; i < N ; i ++ ) { result = min ( result , arr [ i ] - arr [ i - 1 ] ) ; } return result ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function smallestDivisor ( n ) { if ( n % 2 == 0 ) return 2 ; for ( var i = 3 ; i * i <= n ; i += 2 ) { if ( n % i == 0 ) return i ; } return n ; }
Ref: 
int smallestDivisor ( int n ) { if ( n % 2 == 0 ) return 2 ; for ( int i = 3 ; i * i <= n ; i += 2 ) { if ( n % i == 0 ) return i ; } return n ; }
Hyp: 
int smallestDivisor ( int n ) { if ( n % 2 == 0 ) return 2 ; for ( int i = 3 ; i * i <= n ; i += 2 ) { if ( n % i == 0 ) return i ; } return n ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findMinDif ( arr , N ) { arr . sort ( ( a , b ) => a - b ) ; return ( arr [ N - 1 ] - arr [ N - 2 ] ) ; }
Ref: 
int findMinDif ( int arr [ ] , int N ) { sort ( arr , arr + N ) ; return ( arr [ N - 1 ] - arr [ N - 2 ] ) ; }
Hyp: 
int findMinDif ( int arr [ ] , int N ) { sort ( arr , arr + N ) ; return ( arr [ N - 1 ] - arr [ N - 2 ] ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function binomialCoeff ( n , k ) { if ( k > n ) return 0 ; var res = 1 ; if ( k > n - k ) k = n - k ; for ( var i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; }
Ref: 
int binomialCoeff ( int n , int k ) { if ( k > n ) return 0 ; int res = 1 ; if ( k > n - k ) k = n - k ; for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; }
Hyp: 
int binomialCoeff ( int n , int k ) { if ( k > n ) return 0 ; int res = 1 ; if ( k > n - k ) k = n - k ; for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function print_primes_till_N ( N ) { let i , j , flag ; document . write ( " " + N + " " ) ; for ( i = 1 ; i <= N ; i ++ ) { if ( i == 1 i == 0 ) continue ; flag = 1 ; for ( j = 2 ; j <= i / 2 ; ++ j ) { if ( i % j == 0 ) { flag = 0 ; break ; } } if ( flag == 1 ) document . write ( i + " " ) ; } }
Ref: 
void print_primes_till_N ( int N ) { int i , j , flag ; cout << " Prime numbers between 1 and " << N < < " ▁ are : STRNEWLINE " ; for ( i = 1 ; i <= N ; i ++ ) { if ( i == 1 i == 0 ) continue ; flag = 1 ; for ( j = 2 ; j <= i / 2 ; ++ j ) { if ( i % j == 0 ) { flag = 0 ; break ; } } if ( flag == 1 ) cout << i << " ▁ " ; } }
Hyp: 
void print_primes_till_N ( int N ) { int i , j , flag ; cout << " ( " << N << " ) " ; for ( i = 1 ; i <= N ; i ++ ) { if ( i == 1 i == 0 ) continue ; flag = 1 ; for ( j = 2 ; j <= i / 2 ; ++ j ) { if ( i % j == 0 ) { flag = 0 ; break ; } } if ( flag == 1 ) cout << i << " ▁ " ; } }

BLEU: 86.5
Edit Sim: 46


Src: 
function segregate0and1 ( arr , size ) { let left = 0 , right = size - 1 ; while ( left < right ) { while ( arr [ left ] == 0 && left < right ) left ++ ; while ( arr [ right ] == 1 && left < right ) right -- ; if ( left < right ) { arr [ left ] = 0 ; arr [ right ] = 1 ; left ++ ; right -- ; } } }
Ref: 
void segregate0and1 ( int arr [ ] , int size ) { int left = 0 , right = size - 1 ; while ( left < right ) { while ( arr [ left ] == 0 && left < right ) left ++ ; while ( arr [ right ] == 1 && left < right ) right -- ; if ( left < right ) { arr [ left ] = 0 ; arr [ right ] = 1 ; left ++ ; right -- ; } } }
Hyp: 
void segregate0and1 ( int arr [ ] , int size ) { int left = 0 , right = size - 1 ; while ( left < right ) { while ( arr [ left ] == 0 && left < right ) left ++ ; while ( arr [ right ] == 1 && left < right ) right -- ; if ( left < right ) { arr [ left ] = 0 ; arr [ right ] = 1 ; left ++ ; right -- ; } } }

BLEU: 100.0
Edit Sim: 0


Src: 
function breakEvenPoint ( exp , S , M ) { var earn = S - M ; var res = Math . ceil ( exp / earn ) ; return res ; }
Ref: 
int breakEvenPoint ( int exp , int S , int M ) { float earn = S - M ; int res = ceil ( exp / earn ) ; return res ; }
Hyp: 
int breakEvenPoint ( int exp , int S , int M ) { int earn = S - M ; int res = ceil ( exp / earn ) ; return res ; }

BLEU: 92.35
Edit Sim: 4


Src: 
function removeOuterParentheses ( S ) { let res = " " ; let count = 0 ; for ( let c = 0 ; c < S . length ; c ++ ) { if ( S . charAt ( c ) == ' ' && count ++ > 0 ) res += S . charAt ( c ) ; if ( S . charAt ( c ) == ' ' && count -- > 1 ) res += S . charAt ( c ) ; } return res ; }
Ref: 
string removeOuterParentheses ( string S ) { string res ; int count = 0 ; for ( char c : S ) { if ( c == ' ( ' && count ++ > 0 ) res += c ; if ( c == ' ) ' && count -- > 1 ) res += c ; } return res ; }
Hyp: 
string removeOuterParentheses ( string S ) { string res = " " ; int count = 0 ; for ( int c = 0 ; c < S . size ( ) ; c ++ ) { if ( S [ c ] == ' ( ' && count ++ > 0 ) res += S [ c ] ; if ( S [ c ] == ' ( ' && count -- > 1 ) res += S [ c ] ; } return res ; }

BLEU: 48.73
Edit Sim: 60


Src: 
function isDivisible ( n ) { let d ; while ( parseInt ( n / 100 ) > 0 ) { d = n % 10 ; n = parseInt ( n / 10 ) n = Math . abs ( n + ( d * 13 ) ) ; } return ( n % 43 == 0 ) ; }
Ref: 
bool isDivisible ( int n ) { int d ; while ( n / 100 ) { d = n % 10 ; n /= 10 ; n = abs ( n + ( d * 13 ) ) ; } return ( n % 43 == 0 ) ; }
Hyp: 
bool isDivisible ( int n ) { int d ; while ( n / 100 > 0 ) { d = n % 10 ; n = n / 10 ; n = abs ( n + ( d * 13 ) ) ; } return ( n % 43 == 0 ) ; }

BLEU: 85.12
Edit Sim: 9


Src: 
function areSetBitsIncreasing ( n ) { var prev_count = Number . MAX_VALUE ; while ( n > 0 ) { while ( n > 0 && n % 2 == 0 ) n = parseInt ( n / 2 ) ; var curr_count = 1 ; while ( n > 0 && n % 2 == 1 ) { n = n / 2 ; curr_count ++ ; } if ( curr_count >= prev_count ) return false ; prev_count = curr_count ; } return true ; }
Ref: 
bool areSetBitsIncreasing ( int n ) { int prev_count = INT_MAX ; while ( n > 0 ) { while ( n > 0 && n % 2 == 0 ) n = n / 2 ; int curr_count = 1 ; while ( n > 0 && n % 2 == 1 ) { n = n / 2 ; curr_count ++ ; } if ( curr_count >= prev_count ) return false ; prev_count = curr_count ; } return true ; }
Hyp: 
bool areSetBitsIncreasing ( int n ) { int prev_count = INT_MAX ; while ( n > 0 ) { while ( n > 0 && n % 2 == 0 ) n = n / 2 ; int curr_count = 1 ; while ( n > 0 && n % 2 == 1 ) { n = n / 2 ; curr_count ++ ; } if ( curr_count >= prev_count ) return false ; prev_count = curr_count ; } return true ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function operation ( arr , N ) { let right = 0 , ans = 0 , num = 0 ; for ( let left = 0 ; left < N ; left ++ ) { while ( right < N && num + arr [ right ] == ( num ^ arr [ right ] ) ) { num += arr [ right ] ; right ++ ; } ans += right - left ; if ( left == right ) right ++ ; else num -= arr [ left ] ; } return ans ; }
Ref: 
ll operation ( int arr [ ] , int N ) { ll right = 0 , ans = 0 , num = 0 ; for ( ll left = 0 ; left < N ; left ++ ) { while ( right < N && num + arr [ right ] == ( num ^ arr [ right ] ) ) { num += arr [ right ] ; right ++ ; } ans += right - left ; if ( left == right ) right ++ ; else num -= arr [ left ] ; } return ans ; }
Hyp: 
int operation ( int arr [ ] , int N ) { int right = 0 , ans = 0 , num = 0 ; for ( int left = 0 ; left < N ; left ++ ) { while ( right < N && num + arr [ right ] == ( num ^ arr [ right ] ) ) { num += arr [ right ] ; right ++ ; } ans += right - left ; if ( left == right ) right ++ ; else num -= arr [ left ] ; } return ans ; }

BLEU: 94.04
Edit Sim: 9


Src: 
function exponentMod ( A , B , C ) { if ( A == 0 ) return 0 ; if ( B == 0 ) return 1 ; var y ; if ( B % 2 == 0 ) { y = exponentMod ( A , B / 2 , C ) ; y = ( y * y ) % C ; } else { y = A % C ; y = ( y * exponentMod ( A , B - 1 , C ) % C ) % C ; } return parseInt ( ( ( y + C ) % C ) ) ; }
Ref: 
int exponentMod ( int A , int B , int C ) { if ( A == 0 ) return 0 ; if ( B == 0 ) return 1 ; long y ; if ( B % 2 == 0 ) { y = exponentMod ( A , B / 2 , C ) ; y = ( y * y ) % C ; } else { y = A % C ; y = ( y * exponentMod ( A , B - 1 , C ) % C ) % C ; } return ( int ) ( ( y + C ) % C ) ; }
Hyp: 
int exponentMod ( int A , int B , int C ) { if ( A == 0 ) return 0 ; if ( B == 0 ) return 1 ; int y ; if ( B % 2 == 0 ) { y = exponentMod ( A , B / 2 , C ) ; y = ( y * y ) % C ; } else { y = A % C ; y = ( y * exponentMod ( A , B - 1 , C ) % C ) % C ; } return ( ( y + C ) % C ) ; }

BLEU: 94.55
Edit Sim: 11


Src: 
function isValidISBN ( isbn ) { let n = isbn . length ; if ( n != 10 ) return false ; let sum = 0 ; for ( let i = 0 ; i < 9 ; i ++ ) { let digit = isbn [ i ] - ' ' ; if ( 0 > digit 9 < digit ) return false ; sum += ( digit * ( 10 - i ) ) ; } let last = isbn [ 9 ] ; if ( last != ' ' && ( last < ' ' last > ' ' ) ) return false ; sum += ( ( last == ' ' ) ? 10 : ( last - ' ' ) ) ; return ( sum % 11 == 0 ) ; }
Ref: 
bool isValidISBN ( string & isbn ) { int n = isbn . length ( ) ; if ( n != 10 ) return false ; int sum = 0 ; for ( int i = 0 ; i < 9 ; i ++ ) { int digit = isbn [ i ] - '0' ; if ( 0 > digit 9 < digit ) return false ; sum += ( digit * ( 10 - i ) ) ; } char last = isbn [ 9 ] ; if ( last != ' X ' && ( last < '0' last > '9' ) ) return false ; sum += ( ( last == ' X ' ) ? 10 : ( last - '0' ) ) ; return ( sum % 11 == 0 ) ; }
Hyp: 
bool isValidISBN ( string isbn ) { int n = isbn . length ( ) ; if ( n != 10 ) return false ; int sum = 0 ; for ( int i = 0 ; i < 9 ; i ++ ) { int digit = isbn [ i ] - '0' ; if ( 0 > digit 9 < digit ) return false ; sum += ( digit * ( 10 - i ) ) ; } char last = isbn [ 9 ] ; if ( last != '0' && ( last < '0' last > '0' ) ) return false ; sum += ( ( last == '1' ) ? 10 : ( last - '0' ) ) ; return ( sum % 11 == 0 ) ; }

BLEU: 89.76
Edit Sim: 9


Src: 
function minimumflip ( mat , n ) { let transpose = new Array ( n ) ; for ( var i = 0 ; i < transpose . length ; i ++ ) { transpose [ i ] = new Array ( 2 ) ; } for ( let i = 0 ; i < n ; i ++ ) for ( let j = 0 ; j < n ; j ++ ) transpose [ i ] [ j ] = mat [ j ] [ i ] ; let flip = 0 ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = 0 ; j < n ; j ++ ) if ( transpose [ i ] [ j ] != mat [ i ] [ j ] ) flip ++ ; return flip / 2 ; }
Ref: 
int minimumflip ( int mat [ ] [ N ] , int n ) { int transpose [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) transpose [ i ] [ j ] = mat [ j ] [ i ] ; int flip = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( transpose [ i ] [ j ] != mat [ i ] [ j ] ) flip ++ ; return flip / 2 ; }
Hyp: 
int minimumflip ( int mat [ ] [ MAX ] , int n ) { int transpose [ n ] [ MAX ] ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) transpose [ i ] [ j ] = mat [ j ] [ i ] ; int flip = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( transpose [ i ] [ j ] != mat [ i ] [ j ] ) flip ++ ; return flip / 2 ; }

BLEU: 96.05
Edit Sim: 6


Src: 
function sumDivisibles ( A , B , M ) { var sum = 0 ; for ( var i = A ; i <= B ; i ++ ) if ( i % M == 0 ) sum += i ; return sum ; }
Ref: 
int sumDivisibles ( int A , int B , int M ) { int sum = 0 ; for ( int i = A ; i <= B ; i ++ ) if ( i % M == 0 ) sum += i ; return sum ; }
Hyp: 
int sumDivisibles ( int A , int B , int M ) { int sum = 0 ; for ( int i = A ; i <= B ; i ++ ) if ( i % M == 0 ) sum += i ; return sum ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function sumOfTwoPerfectCubes ( N ) { var cubes = new Map ( ) ; for ( var i = 1 ; i * i * i <= N ; i ++ ) cubes . set ( i * i * i , i ) ; var ans = false ; cubes . forEach ( ( value , key ) => { var firstNumber = key ; var secondNumber = N - value ; if ( cubes . has ( secondNumber ) ) { document . write ( " " ) ; ans = true ; return ; } } ) ; if ( ans ) { return ; } document . write ( " " ) ; }
Ref: 
void sumOfTwoPerfectCubes ( int N ) { map < int , int > cubes ; for ( int i = 1 ; i * i * i <= N ; i ++ ) cubes [ i * i * i ] = i ; map < int , int > :: iterator itr ; for ( itr = cubes . begin ( ) ; itr != cubes . end ( ) ; itr ++ ) { int firstNumber = itr -> first ; int secondNumber = N - itr -> first ; if ( cubes . find ( secondNumber ) != cubes . end ( ) ) { cout << " True " ; return ; } } cout << " False " ; }
Hyp: 
void sumOfTwoPerfectCubes ( int N ) { unordered_map < int , int > cubes ; for ( int i = 1 ; i * i * i <= N ; i ++ ) cubes [ i * i * i ] = i ; bool ans = false ; cubes . clear ( ) ; for ( int key = 0 ; key < N ; key ++ ) { int firstNumber = key ; int secondNumber = N - value ; if ( cubes . find ( secondNumber ) != cubes . end ( ) ) { cout << " Yes " ; ans = true ; return ; } } ) ; if ( ans ) return ; } cout << " No " ; }

BLEU: 63.15
Edit Sim: 149


Src: 
function AvgofSquareN ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) sum += ( i * i ) ; return sum / n ; }
Ref: 
float AvgofSquareN ( int n ) { float sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += ( i * i ) ; return sum / n ; }
Hyp: 
double AvgofSquareN ( int n ) { double sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += ( i * i ) ; return sum / n ; }

BLEU: 91.0
Edit Sim: 12


Src: 
function minimumSteps ( x , y ) { var cnt = 0 ; while ( x != 0 && y != 0 ) { if ( x > y ) { cnt += x / y ; x %= y ; } else { cnt += y / x ; y %= x ; } } cnt -- ; if ( x > 1 y > 1 ) cnt = - 1 ; document . write ( cnt ) ; }
Ref: 
int minimumSteps ( int x , int y ) { int cnt = 0 ; while ( x != 0 && y != 0 ) { if ( x > y ) { cnt += x / y ; x %= y ; } else { cnt += y / x ; y %= x ; } } cnt -- ; if ( x > 1 y > 1 ) cnt = -1 ; cout << cnt ; }
Hyp: 
void minimumSteps ( int x , int y ) { int cnt = 0 ; while ( x != 0 && y != 0 ) { if ( x > y ) { cnt += x / y ; x %= y ; } else { cnt += y / x ; y %= x ; } } cnt -- ; if ( x > 1 y > 1 ) cnt = -1 ; cout << cnt ; }

BLEU: 98.73
Edit Sim: 4


Src: 
function minimumcoins ( arr , N ) { let coins = 0 ; let j = 0 ; if ( arr [ 0 ] == 1 ) coins ++ ; for ( let i = 1 ; i < N ; i ++ ) { if ( arr [ i ] == 2 ) continue ; j = i ; while ( j < N && arr [ j ] == 1 ) { j ++ ; } let x = ( j - i ) ; coins += Math . floor ( x / 3 ) ; i = j - 1 ; } return coins ; }
Ref: 
int minimumcoins ( int arr [ ] , int N ) { int coins = 0 ; int j = 0 ; if ( arr [ 0 ] == 1 ) coins ++ ; for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] == 2 ) continue ; j = i ; while ( j < N && arr [ j ] == 1 ) { j ++ ; } int x = ( j - i ) ; coins += x / 3 ; i = j - 1 ; } return coins ; }
Hyp: 
int minimumcoins ( int arr [ ] , int N ) { int coins = 0 ; int j = 0 ; if ( arr [ 0 ] == 1 ) coins ++ ; for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] == 2 ) continue ; j = i ; while ( j < N && arr [ j ] == 1 ) { j ++ ; } int x = ( j - i ) ; coins += x / 3 ; i = j - 1 ; } return coins ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countSetBits ( n ) { n ++ ; var powerOf2 = 2 ; var cnt = n / 2 ; while ( powerOf2 <= n ) { var totalPairs = n / powerOf2 ; cnt += ( totalPairs / 2 ) * powerOf2 ; cnt += ( totalPairs % 2 == 1 ) ? ( n % powerOf2 ) : 0 ; powerOf2 <<= 1 ; } return cnt ; }
Ref: 
int countSetBits ( int n ) { n ++ ; int powerOf2 = 2 ; int cnt = n / 2 ; while ( powerOf2 <= n ) { int totalPairs = n / powerOf2 ; cnt += ( totalPairs / 2 ) * powerOf2 ; cnt += ( totalPairs & 1 ) ? ( n % powerOf2 ) : 0 ; powerOf2 <<= 1 ; } return cnt ; }
Hyp: 
int countSetBits ( int n ) { n ++ ; int powerOf2 = 2 ; int cnt = n / 2 ; while ( powerOf2 <= n ) { int totalPairs = n / powerOf2 ; cnt += ( totalPairs / 2 ) * powerOf2 ; cnt += ( totalPairs % 2 == 1 ) ? ( n % powerOf2 ) : 0 ; powerOf2 <<= 1 ; } return cnt ; }

BLEU: 93.75
Edit Sim: 6


Src: 
function getPeriod ( n ) { let rem = 1 ; for ( let i = 1 ; i <= n + 1 ; i ++ ) rem = ( 10 * rem ) % n ; let d = rem ; let count = 0 ; do { rem = ( 10 * rem ) % n ; count ++ ; } while ( rem != d ) ; return count ; }
Ref: 
int getPeriod ( int n ) { int rem = 1 ; for ( int i = 1 ; i <= n + 1 ; i ++ ) rem = ( 10 * rem ) % n ; int d = rem ; int count = 0 ; do { rem = ( 10 * rem ) % n ; count ++ ; } while ( rem != d ) ; return count ; }
Hyp: 
int getPeriod ( int n ) { int rem = 1 ; for ( int i = 1 ; i <= n + 1 ; i ++ ) rem = ( 10 * rem ) % n ; int d = rem ; int count = 0 ; do { rem = ( 10 * rem ) % n ; count ++ ; } while ( rem != d ) ; return count ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function spiralDiaSum ( n ) { if ( n == 1 ) return 1 ; return ( 4 * n * n - 6 * n + 6 + spiralDiaSum ( n - 2 ) ) ; }
Ref: 
int spiralDiaSum ( int n ) { if ( n == 1 ) return 1 ; return ( 4 * n * n - 6 * n + 6 + spiralDiaSum ( n - 2 ) ) ; }
Hyp: 
int spiralDiaSum ( int n ) { if ( n == 1 ) return 1 ; return ( 4 * n * n - 6 * n + 6 + spiralDiaSum ( n - 2 ) ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findMinMax ( a ) { let min_val = 1000000000 ; for ( let i = 1 ; i < a . length ; ++ i ) { min_val = Math . min ( min_val , a [ i ] * a [ i - 1 ] ) ; } return min_val ; }
Ref: 
int findMinMax ( vector < int > & a ) { int min_val = 1000000000 ; for ( int i = 1 ; i < a . size ( ) ; ++ i ) { min_val = min ( min_val , a [ i ] * a [ i - 1 ] ) ; } return min_val ; }
Hyp: 
int findMinMax ( int a [ ] , int n ) { int min_val = INT_MAX ; for ( int i = 1 ; i < n ; ++ i ) { min_val = min ( min_val , a [ i ] * a [ i - 1 ] ) ; } return min_val ; }

BLEU: 72.07
Edit Sim: 35


Src: 
function distribution ( arr , n ) { let resources = new Set ( ) ; for ( let i = 0 ; i < n ; i ++ ) resources . add ( arr [ i ] ) ; return Math . min ( resources . size , parseInt ( n / 2 , 10 ) ) ; }
Ref: 
int distribution ( int arr [ ] , int n ) { set < int , greater < int > > resources ; for ( int i = 0 ; i < n ; i ++ ) resources . insert ( arr [ i ] ) ; int m = resources . size ( ) ; return min ( m , n / 2 ) ; }
Hyp: 
int distribution ( int arr [ ] , int n ) { unordered_set < int > resources ; for ( int i = 0 ; i < n ; i ++ ) resources . insert ( arr [ i ] ) ; return min ( resources . size ( ) , n / 2 ) ; }

BLEU: 73.79
Edit Sim: 43


Src: 
function checkPascaltriangle ( N ) { var x = ( Math . sqrt ( 8 * N + 1 ) - 1 ) / 2 ; if ( Math . ceil ( x ) - x == 0 ) document . write ( " " ) ; else document . write ( " " ) ; }
Ref: 
void checkPascaltriangle ( int N ) { double x = ( sqrt ( 8 * N + 1 ) - 1 ) / 2 ; if ( ceil ( x ) - x == 0 ) cout << " Yes " ; else cout << " No " ; }
Hyp: 
void checkPascaltriangle ( int N ) { float x = ( sqrt ( 8 * N + 1 ) - 1 ) / 2 ; if ( ceil ( x ) - x == 0 ) cout << " No " ; else cout << " Yes " ; }

BLEU: 93.77
Edit Sim: 12


Src: 
function nondecdigits ( n ) { let x = 0 ; for ( x = n ; x >= 1 ; x -- ) { let no = x ; let prev_dig = 11 ; let flag = true ; while ( no != 0 ) { if ( prev_dig < no % 10 ) { flag = false ; break ; } prev_dig = no % 10 ; no = Math . floor ( no / 10 ) ; } if ( flag == true ) break ; } return x ; }
Ref: 
long nondecdigits ( long long n ) { long long int x = 0 ; for ( x = n ; x >= 1 ; x -- ) { int no = x ; int prev_dig = 11 ; bool flag = true ; while ( no != 0 ) { if ( prev_dig < no % 10 ) { flag = false ; break ; } prev_dig = no % 10 ; no /= 10 ; } if ( flag == true ) break ; } return x ; }
Hyp: 
int nondecdigits ( int n ) { int x = n ; for ( x = n ; x >= 1 ; x -- ) { int no = x ; int prev_dig = 11 ; bool flag = true ; while ( no != 0 ) { if ( prev_dig < no % 10 ) { flag = false ; break ; } prev_dig = no % 10 ; no /= 10 ; } if ( flag == true ) break ; } return x ; }

BLEU: 88.53
Edit Sim: 22


Src: 
function Nth_Term ( n ) { return ( 2 * Math . pow ( n , 3 ) - 3 * Math . pow ( n , 2 ) + n + 6 ) / 6 ; }
Ref: 
int Nth_Term ( int n ) { return ( 2 * pow ( n , 3 ) - 3 * pow ( n , 2 ) + n + 6 ) / 6 ; }
Hyp: 
int Nth_Term ( int n ) { return ( 2 * pow ( n , 3 ) - 3 * pow ( n , 2 ) + n + 6 ) / 6 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function solve ( n ) { let upper_limit = Math . ceil ( Math . pow ( n , 1.0 / 4 ) ) ; for ( let x = 0 ; x <= upper_limit ; x ++ ) { for ( let y = 0 ; y <= upper_limit ; y ++ ) { let num1 = x * x * x * x ; let num2 = y * y * y * y ; if ( num1 - num2 == n ) { document . write ( " " + x + " " + y ) ; return ; } } } document . write ( - 1 ) ; }
Ref: 
void solve ( int n ) { int upper_limit = ceil ( pow ( n , 1.0 / 4 ) ) ; for ( int x = 0 ; x <= upper_limit ; x ++ ) { for ( int y = 0 ; y <= upper_limit ; y ++ ) { int num1 = x * x * x * x ; int num2 = y * y * y * y ; if ( num1 - num2 == n ) { cout << " x ▁ = ▁ " << x << " , ▁ y ▁ = ▁ " << y ; return ; } } } cout << -1 << endl ; }
Hyp: 
void solve ( int n ) { int upper_limit = ceil ( pow ( n , 1.0 / 4 ) ) ; for ( int x = 0 ; x <= upper_limit ; x ++ ) { for ( int y = 0 ; y <= upper_limit ; y ++ ) { int num1 = x * x * x * x ; int num2 = y * y * y * y ; if ( num1 - num2 == n ) { cout << " Yes " << x << " No " << y ; return ; } } } cout << -1 ; }

BLEU: 85.66
Edit Sim: 26


Src: 
function checkMarkov ( m ) { for ( let i = 0 ; i < n ; i ++ ) { let sum = 0 ; for ( let j = 0 ; j < n ; j ++ ) sum = sum + m [ i ] [ j ] ; if ( sum != 1 ) return false ; } return true ; }
Ref: 
bool checkMarkov ( double m [ ] [ n ] ) { for ( int i = 0 ; i < n ; i ++ ) { double sum = 0 ; for ( int j = 0 ; j < n ; j ++ ) sum = sum + m [ i ] [ j ] ; if ( sum != 1 ) return false ; } return true ; }
Hyp: 
bool checkMarkov ( int m [ ] [ n ] ) { for ( int i = 0 ; i < n ; i ++ ) { int sum = 0 ; for ( int j = 0 ; j < n ; j ++ ) sum = sum + m [ i ] [ j ] ; if ( sum != 1 ) return false ; } return true ; }

BLEU: 92.9
Edit Sim: 12


Src: 
function area_fun ( side ) { let area = side * side ; return area ; }
Ref: 
int area_fun ( int side ) { int area = side * side ; return area ; }
Hyp: 
int area_fun ( int side ) { int area = side * side ; return area ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function generateSequence ( n , g ) { for ( var i = 1 ; i <= n ; i ++ ) { document . write ( i * g + " " ) ; } }
Ref: 
void generateSequence ( int n , int g ) { for ( int i = 1 ; i <= n ; i ++ ) cout << i * g << " ▁ " ; }
Hyp: 
void generateSequence ( int n , int g ) { for ( int i = 1 ; i <= n ; i ++ ) { cout << i * g << " ▁ " ; } }

BLEU: 90.25
Edit Sim: 4


Src: 
function countTriplets ( n , sum ) { let ans = 0 ; for ( let i = 0 ; i < n - 2 ; i ++ ) { for ( let j = i + 1 ; j < n - 1 ; j ++ ) { for ( let k = j + 1 ; k < n ; k ++ ) if ( arr [ i ] + arr [ j ] + arr [ k ] < sum ) ans ++ ; } } return ans ; }
Ref: 
int countTriplets ( int arr [ ] , int n , int sum ) { int ans = 0 ; for ( int i = 0 ; i < n - 2 ; i ++ ) { for ( int j = i + 1 ; j < n - 1 ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) if ( arr [ i ] + arr [ j ] + arr [ k ] < sum ) ans ++ ; } } return ans ; }
Hyp: 
int countTriplets ( int arr [ ] , int n , int sum ) { int ans = 0 ; for ( int i = 0 ; i < n - 2 ; i ++ ) { for ( int j = i + 1 ; j < n - 1 ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) if ( arr [ i ] + arr [ j ] + arr [ k ] < sum ) ans ++ ; } } return ans ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function length_of_chord ( r , x ) { document . write ( " " + " " + 2 * r * Math . sin ( x * ( 3.14 / 180 ) ) + " " ) ; }
Ref: 
void length_of_chord ( double r , double x ) { cout << " The ▁ length ▁ of ▁ the ▁ chord " << " ▁ of ▁ the ▁ circle ▁ is ▁ " << 2 * r * sin ( x * ( 3.14 / 180 ) ) << endl ; }
Hyp: 
void length_of_chord ( int r , int x ) { cout << " The ▁ length ▁ of ▁ the ▁ circle ▁ is ▁ " << 2 * r * sin ( x * ( 3.14 / 180 ) ) << " ▁ degrees " ; }

BLEU: 71.9
Edit Sim: 50


Src: 
function maxSquare ( b , m ) { return ( b / m - 1 ) * ( b / m ) / 2 ; a }
Ref: 
int maxSquare ( int b , int m ) { return ( b / m - 1 ) * ( b / m ) / 2 ; }
Hyp: 
int maxSquare ( int b , int m ) { return ( b / m - 1 ) * ( b / m ) / 2 ; a }

BLEU: 93.79
Edit Sim: 2


Src: 
function remAnagram ( str1 , str2 ) { var count1 = Array . from ( { length : 26 } , ( _ , i ) => 0 ) ; var count2 = Array . from ( { length : 26 } , ( _ , i ) => 0 ) ; for ( i = 0 ; i < str1 . length ; i ++ ) count1 [ str1 . charAt ( i ) . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; for ( i = 0 ; i < str2 . length ; i ++ ) count2 [ str2 . charAt ( i ) . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; var result = 0 ; for ( i = 0 ; i < 26 ; i ++ ) result += Math . abs ( count1 [ i ] - count2 [ i ] ) ; return result ; }
Ref: 
int remAnagram ( string str1 , string str2 ) { int count1 [ CHARS ] = { 0 } , count2 [ CHARS ] = { 0 } ; for ( int i = 0 ; str1 [ i ] != ' \0' ; i ++ ) count1 [ str1 [ i ] - ' a ' ] ++ ; for ( int i = 0 ; str2 [ i ] != ' \0' ; i ++ ) count2 [ str2 [ i ] - ' a ' ] ++ ; int result = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) result += abs ( count1 [ i ] - count2 [ i ] ) ; return result ; }
Hyp: 
int remAnagram ( string str1 , string str2 ) { int count1 [ 26 ] = { 0 } ; int count2 [ 26 ] = { 0 } ; for ( int i = 0 ; i < str1 . size ( ) ; i ++ ) count1 [ str1 [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < str2 . size ( ) ; i ++ ) count2 [ str2 [ i ] - ' a ' ] ++ ; int result = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) result += abs ( count1 [ i ] - count2 [ i ] ) ; return result ; }

BLEU: 81.06
Edit Sim: 45


Src: 
function minimumSizeArr ( A , B ) { let currXor = 0 ; let reminder = ( A - 1 ) % 4 ; if ( reminder == 0 ) currXor = A - 1 ; else if ( reminder == 1 ) currXor = 1 ; else if ( reminder == 2 ) currXor = A ; let minSize = A ; if ( currXor == B ) return minSize ; else if ( currXor ^ ( B == A ) ) return minSize + 2 ; else return minSize + 1 ; }
Ref: 
int minimumSizeArr ( int A , int B ) { int currXor = 0 ; int reminder = ( A - 1 ) % 4 ; if ( reminder == 0 ) currXor = A - 1 ; else if ( reminder == 1 ) currXor = 1 ; else if ( reminder == 2 ) currXor = A ; int minSize = A ; if ( currXor == B ) return minSize ; else if ( currXor ^ B == A ) return minSize + 2 ; else return minSize + 1 ; }
Hyp: 
int minimumSizeArr ( int A , int B ) { int currXor = 0 ; int reminder = ( A - 1 ) % 4 ; if ( reminder == 0 ) currXor = A - 1 ; else if ( reminder == 1 ) currXor = 1 ; else if ( reminder == 2 ) currXor = A ; int minSize = A ; if ( currXor == B ) return minSize ; else if ( currXor ^ ( B == A ) ) return minSize + 2 ; else return minSize + 1 ; }

BLEU: 95.55
Edit Sim: 4


Src: 
function minRevolutions ( r , x1 , y1 , x2 , y2 ) { let d = Math . sqrt ( ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ) ; return Math . ceil ( d / ( 2 * r ) ) ; }
Ref: 
int minRevolutions ( double r , int x1 , int y1 , int x2 , int y2 ) { double d = sqrt ( ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ) ; return ceil ( d / ( 2 * r ) ) ; }
Hyp: 
int minRevolutions ( int r , int x1 , int y1 , int x2 , int y2 ) { double d = sqrt ( ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ) ; return ceil ( d / ( 2 * r ) ) ; }

BLEU: 95.88
Edit Sim: 6


Src: 
function numberOfPermWithKInversion ( N , K ) { if ( N == 0 ) return 0 ; if ( K == 0 ) return 1 ; if ( memo [ N ] [ K ] != 0 ) return memo [ N ] [ K ] ; let sum = 0 ; for ( let i = 0 ; i <= K ; i ++ ) { if ( i <= N - 1 ) sum += numberOfPermWithKInversion ( N - 1 , K - i ) ; } memo [ N ] [ K ] = sum ; return sum ; }
Ref: 
int numberOfPermWithKInversion ( int N , int K ) { if ( N == 0 ) return 0 ; if ( K == 0 ) return 1 ; if ( memo [ N ] [ K ] != 0 ) return memo [ N ] [ K ] ; int sum = 0 ; for ( int i = 0 ; i <= K ; i ++ ) { if ( i <= N - 1 ) sum += numberOfPermWithKInversion ( N - 1 , K - i ) ; } memo [ N ] [ K ] = sum ; return sum ; }
Hyp: 
int numberOfPermWithKInversion ( int N , int K ) { if ( N == 0 ) return 0 ; if ( K == 0 ) return 1 ; if ( memo [ N ] [ K ] != 0 ) return memo [ N ] [ K ] ; int sum = 0 ; for ( int i = 0 ; i <= K ; i ++ ) { if ( i <= N - 1 ) sum += numberOfPermWithKInversion ( N - 1 , K - i ) ; } memo [ N ] [ K ] = sum ; return sum ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function circlearea ( l , b ) { if ( l < 0 b < 0 ) return - 1 ; if ( l < b ) return ( 3.14 * Math . pow ( l / 2 , 2 ) ) ; else return ( 3.14 * Math . pow ( b / 2 , 2 ) ) ; }
Ref: 
float circlearea ( float l , float b ) { if ( l < 0 b < 0 ) return -1 ; if ( l < b ) return 3.14 * pow ( l / 2 , 2 ) ; else return 3.14 * pow ( b / 2 , 2 ) ; }
Hyp: 
float circlearea ( float l , float b ) { if ( l < 0 b < 0 ) return -1 ; if ( l < b ) return ( 3.14 * pow ( l / 2 , 2 ) ) ; else return ( 3.14 * pow ( b / 2 , 2 ) ) ; }

BLEU: 84.79
Edit Sim: 8


Src: 
function countP ( n , k ) { if ( n == 0 k == 0 k > n ) return 0 ; if ( k == 1 k == n ) return 1 ; return ( k * countP ( n - 1 , k ) + countP ( n - 1 , k - 1 ) ) ; }
Ref: 
int countP ( int n , int k ) { if ( n == 0 k == 0 k > n ) return 0 ; if ( k == 1 k == n ) return 1 ; return k * countP ( n - 1 , k ) + countP ( n - 1 , k - 1 ) ; }
Hyp: 
int countP ( int n , int k ) { if ( n == 0 k == 0 k > n ) return 0 ; if ( k == 1 k == n ) return 1 ; return ( k * countP ( n - 1 , k ) + countP ( n - 1 , k - 1 ) ) ; }

BLEU: 93.09
Edit Sim: 4


Src: 
function countSol ( coeff , start , end , rhs ) { if ( rhs == 0 ) return 1 ; let result = 0 ; for ( let i = start ; i <= end ; i ++ ) if ( coeff [ i ] <= rhs ) result += countSol ( coeff , i , end , rhs - coeff [ i ] ) ; return result ; }
Ref: 
int countSol ( int coeff [ ] , int start , int end , int rhs ) { if ( rhs == 0 ) return 1 ; int result = 0 ; for ( int i = start ; i <= end ; i ++ ) if ( coeff [ i ] <= rhs ) result += countSol ( coeff , i , end , rhs - coeff [ i ] ) ; return result ; }
Hyp: 
int countSol ( int coeff [ ] , int start , int end , int rhs ) { if ( rhs == 0 ) return 1 ; int result = 0 ; for ( int i = start ; i <= end ; i ++ ) if ( coeff [ i ] <= rhs ) result += countSol ( coeff , i , end , rhs - coeff [ i ] ) ; return result ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function minCost ( a , n , k ) { let dp = new Array ( n + 1 ) ; for ( let i = 0 ; i <= n ; i ++ ) { dp [ i ] = new Array ( k + 1 ) ; for ( let j = 0 ; j <= k ; j ++ ) dp [ i ] [ j ] = inf ; } dp [ 0 ] [ 0 ] = 0 ; for ( let i = 1 ; i <= n ; i ++ ) for ( let j = 1 ; j <= k ; j ++ ) for ( let m = i - 1 ; m >= 0 ; m -- ) dp [ i ] [ j ] = Math . min ( dp [ i ] [ j ] , dp [ m ] [ j - 1 ] + ( a [ i - 1 ] - a [ m ] ) * ( a [ i - 1 ] - a [ m ] ) ) ; return dp [ n ] [ k ] ; }
Ref: 
int minCost ( int a [ ] , int n , int k ) { int dp [ n + 1 ] [ k + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= k ; j ++ ) dp [ i ] [ j ] = inf ; dp [ 0 ] [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= k ; j ++ ) for ( int m = i - 1 ; m >= 0 ; m -- ) dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ m ] [ j - 1 ] + ( a [ i - 1 ] - a [ m ] ) * ( a [ i - 1 ] - a [ m ] ) ) ; return dp [ n ] [ k ] ; }
Hyp: 
int minCost ( int a [ ] , int n , int k ) { int dp [ n + 1 ] [ k + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= k ; j ++ ) dp [ i ] [ j ] = inf ; dp [ 0 ] [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= k ; j ++ ) for ( int m = i - 1 ; m >= 0 ; m -- ) dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ m ] [ j - 1 ] + ( a [ i - 1 ] - a [ m ] ) * ( a [ i - 1 ] - a [ m ] ) ) ; return dp [ n ] [ k ] ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countXOR ( n ) { let count0 = 0 , count1 = 0 ; while ( n != 0 ) { if ( n % 2 == 0 ) count0 ++ ; else count1 ++ ; n = Math . floor ( n / 2 ) ; } return ( count0 ^ count1 ) ; }
Ref: 
int countXOR ( int n ) { int count0 = 0 , count1 = 0 ; while ( n ) { ( n % 2 == 0 ) ? count0 ++ : count1 ++ ; n /= 2 ; } return ( count0 ^ count1 ) ; }
Hyp: 
int countXOR ( int n ) { int count0 = 0 , count1 = 0 ; while ( n != 0 ) { if ( n % 2 == 0 ) count0 ++ ; else count1 ++ ; n = n / 2 ; } return ( count0 ^ count1 ) ; }

BLEU: 70.52
Edit Sim: 21


Src: 
function findTemperature ( x , y , s ) { let Day1 , Day2 ; let diff = ( x - y ) * 6 ; Day2 = ( diff + s ) / 2 ; Day1 = s - Day2 ; document . write ( " " + Day1 + " " ) ; document . write ( " " + Day2 + " " ) ; }
Ref: 
void findTemperature ( int x , int y , int s ) { double Day1 , Day2 ; double diff = ( x - y ) * 6 ; Day2 = ( diff + s ) / 2 ; Day1 = s - Day2 ; cout << " Day1 ▁ : ▁ " << Day1 << endl ; cout << " Day2 ▁ : ▁ " << Day2 << endl ; }
Hyp: 
void findTemperature ( int x , int y , int s ) { int Day1 , Day2 ; int diff = ( x - y ) * 6 ; Day2 = ( diff + s ) / 2 ; Day1 = s - Day2 ; cout << " Day 1 ▁ = ▁ " << Day1 << endl ; cout << " Day 2 ▁ = ▁ " << Day2 << endl ; }

BLEU: 78.46
Edit Sim: 16


Src: 
function Count ( N , K ) { if ( K == 0 ) return 0 ; var res = 0 ; var low = 2 , high = N ; while ( low <= high ) { var mid = ( low + high ) / 2 ; var sum = ( mid * mid + mid ) / 2 ; if ( sum <= K ) { res = Math . max ( res , mid ) ; low = mid + 1 ; } else { high = mid - 1 ; } } return res ; }
Ref: 
int Count ( int N , int K ) { if ( K == 0 ) return 0 ; int res = 0 ; int low = 1 , high = N ; while ( low <= high ) { int mid = ( low + high ) / 2 ; int sum = ( mid * mid + mid ) / 2 ; if ( sum <= K ) { res = max ( res , mid ) ; low = mid + 1 ; } else { high = mid - 1 ; } } return res ; }
Hyp: 
int Count ( int N , int K ) { if ( K == 0 ) return 0 ; int res = 0 ; int low = 2 , high = N ; while ( low <= high ) { int mid = ( low + high ) / 2 ; int sum = ( mid * mid + mid ) / 2 ; if ( sum <= K ) { res = max ( res , mid ) ; low = mid + 1 ; } else { high = mid - 1 ; } } return res ; }

BLEU: 97.49
Edit Sim: 1


Src: 
function ReuleauxArea ( a ) { if ( a < 0 ) return - 1 ; var A = 0.70477 * Math . pow ( a , 2 ) ; return A ; }
Ref: 
float ReuleauxArea ( float a ) { if ( a < 0 ) return -1 ; float A = 0.70477 * pow ( a , 2 ) ; return A ; }
Hyp: 
float ReuleauxArea ( float a ) { if ( a < 0 ) return -1 ; float A = 0.70477 * pow ( a , 2 ) ; return A ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function sortBinaryArray ( a , n ) { let j = - 1 ; for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] < 1 ) { j ++ ; let temp = a [ j ] ; a [ j ] = a [ i ] ; a [ i ] = temp ; } } }
Ref: 
void sortBinaryArray ( int a [ ] , int n ) { int j = -1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] < 1 ) { j ++ ; swap ( a [ i ] , a [ j ] ) ; } } }
Hyp: 
void sortBinaryArray ( int a [ ] , int n ) { int j = -1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] < 1 ) { j ++ ; int temp = a [ j ] ; a [ j ] = a [ i ] ; a [ i ] = temp ; } } }

BLEU: 71.47
Edit Sim: 36


Src: 
function numberOfWays ( N , X , Y ) { let S1 = ( N - 1 ) * X + Y ; let S2 = ( N - 1 ) * Y + X ; return ( S2 - S1 + 1 ) ; }
Ref: 
int numberOfWays ( int N , int X , int Y ) { int S1 = ( N - 1 ) * X + Y ; int S2 = ( N - 1 ) * Y + X ; return ( S2 - S1 + 1 ) ; }
Hyp: 
int numberOfWays ( int N , int X , int Y ) { int S1 = ( N - 1 ) * X + Y ; int S2 = ( N - 1 ) * Y + X ; return ( S2 - S1 + 1 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function lastElement ( a , n ) { var steps = 1 ; var v = Array . from ( Array ( N ) , ( ) => Array ( 0 ) ) ; if ( n == 1 ) return a [ 0 ] ; for ( var i = 0 ; i < n ; i += 2 ) v [ steps ] . push ( a [ i ] a [ i + 1 ] ) ; while ( v [ steps ] . length > 1 ) { steps += 1 ; for ( var i = 0 ; i < v [ steps - 1 ] . length ; i += 2 ) { if ( steps & 1 ) v [ steps ] . push ( v [ steps - 1 ] [ i ] v [ steps - 1 ] [ i + 1 ] ) ; v [ steps ] . push ( v [ steps - 1 ] [ i ] ^ v [ steps - 1 ] [ i + 1 ] ) ; } } return v [ steps ] [ 0 ] ; }
Ref: 
int lastElement ( int a [ ] , int n ) { int steps = 1 ; vector < int > v [ N ] ; if ( n == 1 ) return a [ 0 ] ; for ( int i = 0 ; i < n ; i += 2 ) v [ steps ] . push_back ( a [ i ] a [ i + 1 ] ) ; while ( v [ steps ] . size ( ) > 1 ) { steps += 1 ; for ( int i = 0 ; i < v [ steps - 1 ] . size ( ) ; i += 2 ) { if ( steps & 1 ) v [ steps ] . push_back ( v [ steps - 1 ] [ i ] v [ steps - 1 ] [ i + 1 ] ) ; v [ steps ] . push_back ( v [ steps - 1 ] [ i ] ^ v [ steps - 1 ] [ i + 1 ] ) ; } } return v [ steps ] [ 0 ] ; }
Hyp: 
int lastElement ( int a [ ] , int n ) { int steps = 1 ; vector < vector < int > > v ( N , vector < int > ( 2 , 0 ) ) ; if ( n == 1 ) return a [ 0 ] ; for ( int i = 0 ; i < n ; i += 2 ) v [ steps ] . push_back ( a [ i ] a [ i + 1 ] ) ; while ( v [ steps ] . size ( ) > 1 ) { steps += 1 ; for ( int i = 0 ; i < v [ steps - 1 ] . size ( ) ; i += 2 ) { if ( steps & 1 ) v [ steps ] . push_back ( v [ steps - 1 ] [ i ] v [ steps - 1 ] [ i + 1 ] ) ; v [ steps ] . push_back ( v [ steps - 1 ] [ i ] ^ v [ steps - 1 ] [ i + 1 ] ) ; } } return v [ steps ] [ 0 ] ; }

BLEU: 91.18
Edit Sim: 40


Src: 
function isPossible ( A , B ) { return ( A - B > 1 ) ; }
Ref: 
bool isPossible ( int A , int B ) { return ( A - B > 1 ) ; }
Hyp: 
bool isPossible ( int A , int B ) { return ( A - B > 1 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function addAP ( A , Q , operations ) { for ( let Q of operations ) { let L = Q [ 0 ] , R = Q [ 1 ] , a = Q [ 2 ] , d = Q [ 3 ] curr = a for ( let i = L - 1 ; i < R ; i ++ ) { A [ i ] += curr curr += d } } for ( let i of A ) { document . write ( i + " " ) } }
Ref: 
void addAP ( int A [ ] , int Q , int operations [ 2 ] [ 4 ] ) { for ( int j = 0 ; j < 2 ; ++ j ) { int L = operations [ j ] [ 0 ] , R = operations [ j ] [ 1 ] , a = operations [ j ] [ 2 ] , d = operations [ j ] [ 3 ] ; int curr = a ; for ( int i = L - 1 ; i < R ; i ++ ) { A [ i ] += curr ; curr += d ; } } for ( int i = 0 ; i < 4 ; ++ i ) cout << A [ i ] << " ▁ " ; }
Hyp: 
void addAP ( int A [ ] , int Q [ ] , int operations [ ] ) { for ( int Q [ ] : operations ) { int L = Q [ 0 ] , R = Q [ 1 ] , a = Q [ 2 ] , d = Q [ 3 ] , curr = a for ( int i = L - 1 ; i < R ; i ++ ) { A [ i ] += curr curr += d } } for ( int i : A ) cout << i << " ▁ " ; }

BLEU: 48.55
Edit Sim: 126


Src: 
function countDigits ( st , n ) { if ( n > 0 ) { let cnt = 1 , i ; let st2 = " " ; for ( i = 1 ; i < st . length ; i ++ ) { if ( st [ i ] == st [ i - 1 ] ) cnt ++ ; else { st2 += String . fromCharCode ( ' ' . charCodeAt ( ) + cnt ) ; st2 += st [ i - 1 ] ; cnt = 1 ; } } st2 += String . fromCharCode ( ' ' . charCodeAt ( ) + cnt ) ; st2 += st [ i - 1 ] ; countDigits ( st2 , -- n ) ; } else document . write ( st ) ; }
Ref: 
void countDigits ( string st , int n ) { if ( n > 0 ) { int cnt = 1 , i ; string st2 = " " ; for ( i = 1 ; i < st . length ( ) ; i ++ ) { if ( st [ i ] == st [ i - 1 ] ) cnt ++ ; else { st2 += ( '0' + cnt ) ; st2 += st [ i - 1 ] ; cnt = 1 ; } } st2 += ( '0' + cnt ) ; st2 += st [ i - 1 ] ; countDigits ( st2 , -- n ) ; } else cout << st ; }
Hyp: 
void countDigits ( string st , int n ) { if ( n > 0 ) { int cnt = 1 , i ; string st2 = " " ; for ( i = 1 ; i < st . size ( ) ; i ++ ) { if ( st [ i ] == st [ i - 1 ] ) cnt ++ ; else { st2 += char ( '0' + cnt ) ; st2 += st [ i - 1 ] ; cnt = 1 ; } } st2 += char ( '0' + cnt ) ; st2 += st [ i - 1 ] ; countDigits ( st2 , -- n ) ; } else cout << st ; }

BLEU: 93.86
Edit Sim: 16


Src: 
function Cycles ( N ) { var fact = 1 , result = 0 ; result = N - 1 ; var i = result ; while ( i > 0 ) { fact = fact * i ; i -- ; } return fact / 2 ; }
Ref: 
int Cycles ( int N ) { int fact = 1 , result = 0 ; result = N - 1 ; int i = result ; while ( i > 0 ) { fact = fact * i ; i -- ; } return fact / 2 ; }
Hyp: 
int Cycles ( int N ) { int fact = 1 , result = 0 ; result = N - 1 ; int i = result ; while ( i > 0 ) { fact = fact * i ; i -- ; } return fact / 2 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function printNSE ( arr , n ) { var next , i , j ; for ( i = 0 ; i < n ; i ++ ) { next = - 1 ; for ( j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] > arr [ j ] ) { next = arr [ j ] ; break ; } } document . write ( arr [ i ] + " " + next + " " ) ; } }
Ref: 
void printNSE ( int arr [ ] , int n ) { int next , i , j ; for ( i = 0 ; i < n ; i ++ ) { next = -1 ; for ( j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] > arr [ j ] ) { next = arr [ j ] ; break ; } } cout << arr [ i ] << " ▁ - - ▁ " << next << endl ; } }
Hyp: 
void printNSE ( int arr [ ] , int n ) { int next , i , j ; for ( i = 0 ; i < n ; i ++ ) { next = -1 ; for ( j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] > arr [ j ] ) { next = arr [ j ] ; break ; } } cout << arr [ i ] << " , ▁ " << next << " ▁ " ; } }

BLEU: 93.45
Edit Sim: 10


Src: 
function patternCount ( str ) { var last = str . charAt ( 0 ) ; var i = 1 , counter = 0 ; while ( i < str . length ) { if ( str . charAt ( i ) == ' ' && last == ' ' ) { while ( str . charAt ( i ) == ' ' ) i ++ ; if ( str . charAt ( i ) == ' ' ) counter ++ ; } last = str . charAt ( i ) ; i ++ ; } return counter ; }
Ref: 
int patternCount ( string str ) { char last = str [ 0 ] ; int i = 1 , counter = 0 ; while ( i < str . size ( ) ) { if ( str [ i ] == '0' && last == '1' ) { while ( str [ i ] == '0' ) i ++ ; if ( str [ i ] == '1' ) counter ++ ; } last = str [ i ] ; i ++ ; } return counter ; }
Hyp: 
int patternCount ( string str ) { char last = str [ 0 ] ; int i = 1 , counter = 0 ; while ( i < str . size ( ) ) { if ( str [ i ] == ' ( ' && last == ' ( ' ) { while ( str [ i ] == ' ( ' ) i ++ ; if ( str [ i ] == ' ( ' ) counter ++ ; } last = str [ i ] ; i ++ ; } return counter ; }

BLEU: 81.15
Edit Sim: 12


Src: 
function min_operations ( A ) { if ( A . length == 0 ) return 0 ; let ans = A [ 0 ] ; for ( let i = 1 ; i < A . length ; i ++ ) { ans += Math . max ( A [ i ] - A [ i - 1 ] , 0 ) ; } return ans ; }
Ref: 
int min_operations ( vector < int > & A ) { if ( A . size ( ) == 0 ) return 0 ; int ans = A [ 0 ] ; for ( int i = 1 ; i < A . size ( ) ; i ++ ) { ans += max ( A [ i ] - A [ i - 1 ] , 0 ) ; } return ans ; }
Hyp: 
int min_operations ( int A [ ] , int n ) { if ( n == 0 ) return 0 ; int ans = A [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { ans += max ( A [ i ] - A [ i - 1 ] , 0 ) ; } return ans ; }

BLEU: 72.53
Edit Sim: 36


Src: 
function OddLengthSum ( arr ) { let sum = 0 ; let l = arr . length ; for ( let i = 0 ; i < l ; i ++ ) { sum += Math . floor ( ( ( i + 1 ) * ( l - i ) + 1 ) / 2 ) * arr [ i ] ; } return sum ; }
Ref: 
int OddLengthSum ( vector < int > & arr ) { int sum = 0 ; int l = arr . size ( ) ; for ( int i = 0 ; i < l ; i ++ ) { sum += ( ( ( i + 1 ) * ( l - i ) + 1 ) / 2 ) * arr [ i ] ; } return sum ; }
Hyp: 
int OddLengthSum ( int arr [ ] , int n ) { int sum = 0 ; int l = n ; for ( int i = 0 ; i < l ; i ++ ) { sum += ( ( ( i + 1 ) * ( l - i ) + 1 ) / 2 ) * arr [ i ] ; } return sum ; }

BLEU: 80.88
Edit Sim: 30


Src: 
function equilibrium ( arr , n ) { var i , j ; var leftsum , rightsum ; for ( i = 0 ; i < n ; ++ i ) { leftsum = 0 ; rightsum = 0 ; for ( let j = 0 ; j < i ; j ++ ) leftsum += arr [ j ] ; for ( let j = i + 1 ; j < n ; j ++ ) rightsum += arr [ j ] ; if ( leftsum == rightsum ) return i ; } return - 1 ; }
Ref: 
int equilibrium ( int arr [ ] , int n ) { int i , j ; int leftsum , rightsum ; for ( i = 0 ; i < n ; ++ i ) { leftsum = 0 ; rightsum = 0 ; for ( j = 0 ; j < i ; j ++ ) leftsum += arr [ j ] ; for ( j = i + 1 ; j < n ; j ++ ) rightsum += arr [ j ] ; if ( leftsum == rightsum ) return i ; } return -1 ; }
Hyp: 
int equilibrium ( int arr [ ] , int n ) { int i , j ; int leftsum , rightsum ; for ( i = 0 ; i < n ; ++ i ) { leftsum = 0 ; rightsum = 0 ; for ( j = 0 ; j < i ; j ++ ) leftsum += arr [ j ] ; for ( int j = i + 1 ; j < n ; j ++ ) rightsum += arr [ j ] ; if ( leftsum == rightsum ) return i ; } return -1 ; }

BLEU: 97.49
Edit Sim: 4


Src: 
function countWays ( n ) { for ( let i = 1 ; i < n ; i ++ ) for ( let j = i ; j < n ; j ++ ) for ( let k = j ; k < n ; k ++ ) for ( let l = k ; l < n ; l ++ ) if ( i + j + k + l == n ) counter ++ ; return counter ; }
Ref: 
int countWays ( int n ) { for ( int i = 1 ; i < n ; i ++ ) for ( int j = i ; j < n ; j ++ ) for ( int k = j ; k < n ; k ++ ) for ( int l = k ; l < n ; l ++ ) if ( i + j + k + l == n ) counter ++ ; return counter ; }
Hyp: 
int countWays ( int n ) { for ( int i = 1 ; i < n ; i ++ ) for ( int j = i ; j < n ; j ++ ) for ( int k = j ; k < n ; k ++ ) for ( int l = k ; l < n ; l ++ ) if ( i + j + k + l == n ) counter ++ ; return counter ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findLength ( str , n ) { let current_sum = 0 ; let max_sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { current_sum += ( str [ i ] == ' ' ? 1 : - 1 ) ; if ( current_sum < 0 ) { current_sum = 0 ; } max_sum = Math . max ( current_sum , max_sum ) ; } return max_sum == 0 ? - 1 : max_sum ; }
Ref: 
int findLength ( string str , int n ) { int current_sum = 0 ; int max_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { current_sum += ( str [ i ] == '0' ? 1 : -1 ) ; if ( current_sum < 0 ) current_sum = 0 ; max_sum = max ( current_sum , max_sum ) ; } return max_sum == 0 ? -1 : max_sum ; }
Hyp: 
int findLength ( string str , int n ) { int current_sum = 0 ; int max_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { current_sum += ( str [ i ] == ' ( ' ? 1 : -1 ) ; if ( current_sum < 0 ) { current_sum = 0 ; } max_sum = max ( current_sum , max_sum ) ; } return max_sum == 0 ? -1 : max_sum ; }

BLEU: 88.47
Edit Sim: 7


Src: 
function findMedian ( Mean , Mode ) { var Median = ( 2 * Mean + Mode ) / 3.0 ; document . write ( Median ) ; }
Ref: 
void findMedian ( int Mean , int Mode ) { double Median = ( 2 * Mean + Mode ) / 3.0 ; cout << Median ; }
Hyp: 
void findMedian ( double Mean , double Mode ) { double Median = ( 2 * Mean + Mode ) / 3.0 ; cout << Median ; }

BLEU: 82.07
Edit Sim: 12


Src: 
function average ( arr , n , k ) { var total = 0 ; if ( 2 * k >= n ) return 0 ; arr . sort ( ) ; var start = k , end = n - k - 1 ; for ( i = start ; i <= end ; i ++ ) total += arr [ i ] ; return ( total / ( n - 2 * k ) ) ; }
Ref: 
double average ( int arr [ ] , int n , int k ) { double total = 0 ; if ( 2 * k >= n ) return 0 ; sort ( arr , arr + n ) ; int start = k , end = n - k - 1 ; for ( int i = start ; i <= end ; i ++ ) total += arr [ i ] ; return ( total / ( n - 2 * k ) ) ; }
Hyp: 
float average ( int arr [ ] , int n , int k ) { float total = 0 ; if ( 2 * k >= n ) return 0 ; sort ( arr , arr + n ) ; int start = k , end = n - k - 1 ; for ( int i = start ; i <= end ; i ++ ) total += arr [ i ] ; return total / ( n - 2 * k ) ; }

BLEU: 91.01
Edit Sim: 16


Src: 
function nswp ( n ) { let dp = new Array ( n + 1 ) ; dp [ 0 ] = dp [ 1 ] = 1 ; for ( let i = 2 ; i <= n ; i ++ ) dp [ i ] = 2 * dp [ i - 1 ] + dp [ i - 2 ] ; return dp [ n ] ; }
Ref: 
int nswp ( int n ) { int dp [ n + 1 ] ; dp [ 0 ] = dp [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) dp [ i ] = 2 * dp [ i - 1 ] + dp [ i - 2 ] ; return dp [ n ] ; }
Hyp: 
int nswp ( int n ) { int dp [ n + 1 ] ; dp [ 0 ] = dp [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) dp [ i ] = 2 * dp [ i - 1 ] + dp [ i - 2 ] ; return dp [ n ] ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function mirror_point ( a , b , c , d , x1 , y1 , z1 ) { var k = parseFloat ( ( - a * x1 - b * y1 - c * z1 - d ) / parseFloat ( a * a + b * b + c * c ) ) ; var x2 = parseFloat ( a * k + x1 ) ; var y2 = parseFloat ( b * k + y1 ) ; var z2 = parseFloat ( c * k + z1 ) ; var x3 = parseFloat ( 2 * x2 - x1 ) . toFixed ( 1 ) ; var y3 = parseFloat ( 2 * y2 - y1 ) . toFixed ( 1 ) ; var z3 = parseFloat ( 2 * z2 - z1 ) . toFixed ( 1 ) ; document . write ( " " + x3 ) ; document . write ( " " + y3 ) ; document . write ( " " + z3 ) ; }
Ref: 
void mirror_point ( float a , float b , float c , float d , float x1 , float y1 , float z1 ) { float k = ( - a * x1 - b * y1 - c * z1 - d ) / ( float ) ( a * a + b * b + c * c ) ; float x2 = a * k + x1 ; float y2 = b * k + y1 ; float z2 = c * k + z1 ; float x3 = 2 * x2 - x1 ; float y3 = 2 * y2 - y1 ; float z3 = 2 * z2 - z1 ; std :: cout << std :: fixed ; std :: cout << std :: setprecision ( 1 ) ; cout << " ▁ x3 ▁ = ▁ " << x3 ; cout << " ▁ y3 ▁ = ▁ " << y3 ; cout << " ▁ z3 ▁ = ▁ " << z3 ; }
Hyp: 
void mirror_point ( int a , int b , int c , int d , int x1 , int y1 , int z1 ) { int k = ( - a * x1 - b * y1 - c * z1 - d ) / ( a * a + b * b + c * c ) ; int x2 = parseFloat ( a * k + x1 ) ; int y2 = parseFloat ( b * k + y1 ) ; int z2 = parseFloat ( c * k + z1 ) ; int x3 = ( 2 * x2 - x1 ) . toFixed ( 1 ) ; int y3 = ( 2 * y2 - y1 ) . toFixed ( 1 ) ; int z3 = ( 2 * z2 - z1 ) . toFixed ( 1 ) ; cout << " x3 ▁ = ▁ " << x3 ; cout << " y3 ▁ = ▁ " << y3 ; cout << " z3 ▁ = ▁ " << z3 ; }

BLEU: 53.7
Edit Sim: 186


Src: 
function nthKyneaNumber ( n ) { n = ( 1 << n ) + 1 ; n = n * n ; n = n - 2 ; return n ; }
Ref: 
long nthKyneaNumber ( int n ) { n = ( 1 << n ) + 1 ; n = n * n ; n = n - 2 ; return n ; }
Hyp: 
int nthKyneaNumber ( int n ) { n = ( 1 << n ) + 1 ; n = n * n ; n = n - 2 ; return n ; }

BLEU: 96.92
Edit Sim: 3


Src: 
function findTriangles ( n ) { var num ; num = n * ( n - 4 ) ; document . write ( num ) ; }
Ref: 
void findTriangles ( int n ) { int num ; num = n * ( n - 4 ) ; cout << num ; }
Hyp: 
void findTriangles ( int n ) { int num ; num = n * ( n - 4 ) ; cout << num ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function getPairsCount ( arr , n , sum ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] + arr [ j ] == sum ) count ++ ; return count ; }
Ref: 
int getPairsCount ( int arr [ ] , int n , int sum ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] + arr [ j ] == sum ) count ++ ; return count ; }
Hyp: 
int getPairsCount ( int arr [ ] , int n , int sum ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] + arr [ j ] == sum ) count ++ ; return count ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function maximumValue ( arr , n ) { var ans = 0 ; for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { ans = Math . max ( ans , arr [ i ] + arr [ j ] + i - j ) ; } } document . write ( ans ) ; }
Ref: 
void maximumValue ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { ans = max ( ans , arr [ i ] + arr [ j ] + i - j ) ; } } cout << ans ; }
Hyp: 
void maximumValue ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { ans = max ( ans , arr [ i ] + arr [ j ] + i - j ) ; } } cout << ans ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function calculateSum ( n ) { let fibo = [ ] ; if ( n <= 0 ) return 0 ; fibo [ 0 ] = 0 ; fibo [ 1 ] = 1 ; let sum = fibo [ 0 ] + fibo [ 1 ] ; for ( let i = 2 ; i <= n ; i ++ ) { fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ; sum += fibo [ i ] ; } return sum ; } let n = 4 ; document . write ( ` ${ calculateSum ( n ) }
Ref: 
int calculateSum ( int n ) { if ( n <= 0 ) return 0 ; int fibo [ n + 1 ] ; fibo [ 0 ] = 0 , fibo [ 1 ] = 1 ; int sum = fibo [ 0 ] + fibo [ 1 ] ; for ( int i = 2 ; i <= n ; i ++ ) { fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ; sum += fibo [ i ] ; } return sum ; }
Hyp: 
int calculateSum ( int n ) { int fibo [ 4 ] ; if ( n <= 0 ) return 0 ; fibo [ 0 ] = 0 ; fibo [ 1 ] = 1 ; int sum = fibo [ 0 ] + fibo [ 1 ] ; for ( int i = 2 ; i <= n ; i ++ ) { fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ; sum += fibo [ i ] ; } return sum ; }

BLEU: 88.9
Edit Sim: 33


Src: 
function pairInSortedRotated ( arr , n , x ) { let i ; for ( i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] > arr [ i + 1 ] ) break ; let l = ( i + 1 ) % n ; let r = i ; while ( l != r ) { if ( arr [ l ] + arr [ r ] == x ) return true ; if ( arr [ l ] + arr [ r ] < x ) l = ( l + 1 ) % n ; else r = ( n + r - 1 ) % n ; } return false ; }
Ref: 
bool pairInSortedRotated ( int arr [ ] , int n , int x ) { int i ; for ( i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] > arr [ i + 1 ] ) break ; int l = ( i + 1 ) % n ; int r = i ; while ( l != r ) { if ( arr [ l ] + arr [ r ] == x ) return true ; if ( arr [ l ] + arr [ r ] < x ) l = ( l + 1 ) % n ; else r = ( n + r - 1 ) % n ; } return false ; }
Hyp: 
bool pairInSortedRotated ( int arr [ ] , int n , int x ) { int i ; for ( i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] > arr [ i + 1 ] ) break ; int l = ( i + 1 ) % n ; int r = i ; while ( l != r ) { if ( arr [ l ] + arr [ r ] == x ) return true ; if ( arr [ l ] + arr [ r ] < x ) l = ( l + 1 ) % n ; else r = ( n + r - 1 ) % n ; } return false ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function SmallestDiv ( n ) { for ( let i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { return i ; } } return n ; }
Ref: 
int SmallestDiv ( int n ) { for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { return i ; } } return n ; }
Hyp: 
int SmallestDiv ( int n ) { for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { return i ; } } return n ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function rearrange ( arr , n ) { let max_idx = n - 1 , min_idx = 0 ; let max_elem = arr [ n - 1 ] + 1 ; for ( let i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { arr [ i ] += ( arr [ max_idx ] % max_elem ) * max_elem ; max_idx -- ; } else { arr [ i ] += ( arr [ min_idx ] % max_elem ) * max_elem ; min_idx ++ ; } } for ( let i = 0 ; i < n ; i ++ ) arr [ i ] = Math . floor ( arr [ i ] / max_elem ) ; }
Ref: 
void rearrange ( int arr [ ] , int n ) { int max_idx = n - 1 , min_idx = 0 ; int max_elem = arr [ n - 1 ] + 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { arr [ i ] += ( arr [ max_idx ] % max_elem ) * max_elem ; max_idx -- ; } else { arr [ i ] += ( arr [ min_idx ] % max_elem ) * max_elem ; min_idx ++ ; } } for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = arr [ i ] / max_elem ; }
Hyp: 
void rearrange ( int arr [ ] , int n ) { int max_idx = n - 1 , min_idx = 0 ; int max_elem = arr [ n - 1 ] + 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { arr [ i ] += ( arr [ max_idx ] % max_elem ) * max_elem ; max_idx -- ; } else { arr [ i ] += ( arr [ min_idx ] % max_elem ) * max_elem ; min_idx ++ ; } } for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = arr [ i ] / max_elem ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function dupLastIndex ( arr , n ) { if ( arr == null n <= 0 ) return ; for ( let i = n - 1 ; i > 0 ; i -- ) { if ( arr [ i ] == arr [ i - 1 ] ) { document . write ( " " + i + " " ) ; document . write ( " " + arr [ i ] + " " ) ; return ; } } document . write ( " " ) ; }
Ref: 
void dupLastIndex ( int arr [ ] , int n ) { if ( arr == NULL n <= 0 ) return ; for ( int i = n - 1 ; i > 0 ; i -- ) { if ( arr [ i ] == arr [ i - 1 ] ) { printf ( " Last ▁ index : ▁ % d STRNEWLINE Last ▁ " " duplicate ▁ item : ▁ % d STRNEWLINE " , i , arr [ i ] ) ; return ; } } printf ( " no ▁ duplicate ▁ found " ) ; }
Hyp: 
void dupLastIndex ( int arr [ ] , int n ) { if ( arr == NULL n <= 0 ) return ; for ( int i = n - 1 ; i > 0 ; i -- ) { if ( arr [ i ] == arr [ i - 1 ] ) { cout << " ▁ " << i << " ▁ " ; cout << " ▁ " << arr [ i ] << " ▁ " ; return ; } } cout << " - 1" ; }

BLEU: 61.21
Edit Sim: 109


Src: 
function isComposite ( n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return false ; if ( n % 2 == 0 n % 3 == 0 ) return true ; for ( let i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return true ; return false ; }
Ref: 
bool isComposite ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return false ; if ( n % 2 == 0 n % 3 == 0 ) return true ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return true ; return false ; }
Hyp: 
bool isComposite ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return false ; if ( n % 2 == 0 n % 3 == 0 ) return true ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return true ; return false ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function angleequichord ( z ) { document . write ( " " + z + " " + " " ) ; }
Ref: 
void angleequichord ( int z ) { cout << " The ▁ angle ▁ subtended ▁ at ▁ the ▁ center ▁ is ▁ " << z << " ▁ degrees " << endl ; }
Hyp: 
void angleequichord ( int z ) { cout << " The ▁ angle ▁ of ▁ the ▁ circle ▁ is ▁ " << z << " ▁ degrees " << endl ; }

BLEU: 79.7
Edit Sim: 19


Src: 
function isAlphabaticOrder ( s ) { let n = s . length ; for ( let i = 1 ; i < n ; i ++ ) { if ( s [ i ] < s [ i - 1 ] ) return false ; } return true ; }
Ref: 
bool isAlphabaticOrder ( string s ) { int n = s . length ( ) ; for ( int i = 1 ; i < n ; i ++ ) { if ( s [ i ] < s [ i - 1 ] ) return false ; } return true ; }
Hyp: 
bool isAlphabaticOrder ( string s ) { int n = s . length ( ) ; for ( int i = 1 ; i < n ; i ++ ) { if ( s [ i ] < s [ i - 1 ] ) return false ; } return true ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findOddPair ( A , N ) { let i , count = 0 ; for ( i = 0 ; i < N ; i ++ ) { if ( A [ i ] % 2 == 0 ) count ++ ; } return count * ( N - count ) ; }
Ref: 
int findOddPair ( int A [ ] , int N ) { int i , count = 0 ; for ( i = 0 ; i < N ; i ++ ) { if ( A [ i ] % 2 == 0 ) count ++ ; } return count * ( N - count ) ; }
Hyp: 
int findOddPair ( int A [ ] , int N ) { int i , count = 0 ; for ( i = 0 ; i < N ; i ++ ) { if ( A [ i ] % 2 == 0 ) count ++ ; } return count * ( N - count ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function magicOfSequence ( N ) { return ( N * ( N + 1 ) / 2 ) + 2 * N ; }
Ref: 
int magicOfSequence ( int N ) { return ( N * ( N + 1 ) / 2 ) + 2 * N ; }
Hyp: 
int magicOfSequence ( int N ) { return ( N * ( N + 1 ) / 2 ) + 2 * N ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findSum ( n ) { return Math . sqrt ( 3 ) * ( n * ( n + 1 ) / 2 ) ; }
Ref: 
double findSum ( ll n ) { return sqrt ( 3 ) * ( n * ( n + 1 ) / 2 ) ; }
Hyp: 
double findSum ( int n ) { return sqrt ( 3 ) * ( n * ( n + 1 ) / 2 ) ; }

BLEU: 89.85
Edit Sim: 3


Src: 
function findMaxValue ( N , mat ) { let maxValue = Number . MIN_VALUE ; for ( let a = 0 ; a < N - 1 ; a ++ ) for ( let b = 0 ; b < N - 1 ; b ++ ) for ( let d = a + 1 ; d < N ; d ++ ) for ( let e = b + 1 ; e < N ; e ++ ) if ( maxValue < ( mat [ d ] [ e ] - mat [ a ] [ b ] ) ) maxValue = mat [ d ] [ e ] - mat [ a ] [ b ] ; return maxValue ; }
Ref: 
int findMaxValue ( int mat [ ] [ N ] ) { int maxValue = INT_MIN ; for ( int a = 0 ; a < N - 1 ; a ++ ) for ( int b = 0 ; b < N - 1 ; b ++ ) for ( int d = a + 1 ; d < N ; d ++ ) for ( int e = b + 1 ; e < N ; e ++ ) if ( maxValue < ( mat [ d ] [ e ] - mat [ a ] [ b ] ) ) maxValue = mat [ d ] [ e ] - mat [ a ] [ b ] ; return maxValue ; }
Hyp: 
int findMaxValue ( int N , int mat [ ] [ MAX ] ) { int maxValue = INT_MIN ; for ( int a = 0 ; a < N - 1 ; a ++ ) for ( int b = 0 ; b < N - 1 ; b ++ ) for ( int d = a + 1 ; d < N ; d ++ ) for ( int e = b + 1 ; e < N ; e ++ ) if ( maxValue < ( mat [ d ] [ e ] - mat [ a ] [ b ] ) ) maxValue = mat [ d ] [ e ] - mat [ a ] [ b ] ; return maxValue ; }

BLEU: 95.26
Edit Sim: 11


Src: 
function check ( arr , n ) { for ( var i = 0 ; i < n ; i ++ ) { var hm = new Map ( ) ; var count = 0 ; for ( var j = i ; j < n ; j ++ ) { if ( hm . has ( arr [ j ] ) ) hm . set ( arr [ j ] , hm . get ( arr [ j ] ) + 1 ) else hm . set ( arr [ j ] , 1 ) if ( hm . get ( arr [ j ] ) == 1 ) count ++ ; if ( hm . get ( arr [ j ] ) == 2 ) count -- ; if ( count == 0 ) return " " ; } } return " " ; }
Ref: 
string check ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { map < int , int > hm ; int count = 0 ; for ( int j = i ; j < n ; j ++ ) { hm [ arr [ j ] ] ++ ; if ( hm [ arr [ j ] ] == 1 ) count ++ ; if ( hm [ arr [ j ] ] == 2 ) count -- ; if ( count == 0 ) return " No " ; } } return " Yes " ; }
Hyp: 
string check ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { unordered_map < int , int > hm ; int count = 0 ; for ( int j = i ; j < n ; j ++ ) { if ( hm . find ( arr [ j ] ) != hm . end ( ) ) hm [ arr [ j ] ] ++ ; if ( hm [ arr [ j ] ] == 1 ) count ++ ; if ( hm [ arr [ j ] ] == 2 ) count -- ; if ( count == 0 ) return " Yes " ; } } return " No " ; }

BLEU: 82.7
Edit Sim: 63


Src: 
function count_numbers ( k , n ) { let dp = new Array ( n + 1 ) ; for ( let i = 0 ; i < n + 1 ; i ++ ) dp [ i ] = new Array ( 2 ) ; dp [ 1 ] [ 0 ] = 0 ; dp [ 1 ] [ 1 ] = k - 1 ; for ( let i = 2 ; i <= n ; i ++ ) { dp [ i ] [ 0 ] = dp [ i - 1 ] [ 1 ] ; dp [ i ] [ 1 ] = ( dp [ i - 1 ] [ 0 ] + dp [ i - 1 ] [ 1 ] ) * ( k - 1 ) ; } return dp [ n ] [ 0 ] + dp [ n ] [ 1 ] ; }
Ref: 
int count_numbers ( int k , int n ) { int dp [ n + 1 ] [ 2 ] ; dp [ 1 ] [ 0 ] = 0 ; dp [ 1 ] [ 1 ] = k - 1 ; for ( int i = 2 ; i <= n ; i ++ ) { dp [ i ] [ 0 ] = dp [ i - 1 ] [ 1 ] ; dp [ i ] [ 1 ] = ( dp [ i - 1 ] [ 0 ] + dp [ i - 1 ] [ 1 ] ) * ( k - 1 ) ; } return dp [ n ] [ 0 ] + dp [ n ] [ 1 ] ; }
Hyp: 
long count_numbers ( int k , int n ) { long dp [ n + 1 ] [ 2 ] ; dp [ 1 ] [ 0 ] = 0 , dp [ 1 ] [ 1 ] = k - 1 ; for ( int i = 2 ; i <= n ; i ++ ) { dp [ i ] [ 0 ] = dp [ i - 1 ] [ 1 ] ; dp [ i ] [ 1 ] = ( dp [ i - 1 ] [ 0 ] + dp [ i - 1 ] [ 1 ] ) * ( k - 1 ) ; } return dp [ n ] [ 0 ] + dp [ n ] [ 1 ] ; }

BLEU: 95.37
Edit Sim: 7


Src: 
function countNumbersWith4 ( n ) { if ( n < 4 ) return 0 ; let d = Math . floor ( Math . log10 ( n ) ) ; let a = new Array ( d + 2 ) ; for ( let i = 0 ; i < d + 2 ; i ++ ) { a [ i ] = 0 ; } a [ 0 ] = 0 ; a [ 1 ] = 1 ; for ( let i = 2 ; i <= d ; i ++ ) a [ i ] = a [ i - 1 ] * 9 + Math . floor ( Math . ceil ( Math . pow ( 10 , i - 1 ) ) ) ; let p = Math . floor ( Math . ceil ( Math . pow ( 10 , d ) ) ) ; let msd = Math . floor ( n / p ) ; if ( msd == 4 ) return ( msd ) * a [ d ] + ( n % p ) + 1 ; if ( msd > 4 ) return ( msd - 1 ) * a [ d ] + p + countNumbersWith4 ( n % p ) ; return ( msd ) * a [ d ] + countNumbersWith4 ( n % p ) ; }
Ref: 
int countNumbersWith4 ( int n ) { if ( n < 4 ) return 0 ; int d = log10 ( n ) ; int * a = new int [ d + 1 ] ; a [ 0 ] = 0 , a [ 1 ] = 1 ; for ( int i = 2 ; i <= d ; i ++ ) a [ i ] = a [ i - 1 ] * 9 + ceil ( pow ( 10 , i - 1 ) ) ; int p = ceil ( pow ( 10 , d ) ) ; int msd = n / p ; if ( msd == 4 ) return ( msd ) * a [ d ] + ( n % p ) + 1 ; if ( msd > 4 ) return ( msd - 1 ) * a [ d ] + p + countNumbersWith4 ( n % p ) ; return ( msd ) * a [ d ] + countNumbersWith4 ( n % p ) ; }
Hyp: 
int countNumbersWith4 ( int n ) { if ( n < 4 ) return 0 ; int d = log10 ( n ) ; int * a = new int [ d + 2 ] ; for ( int i = 0 ; i < d + 2 ; i ++ ) a [ i ] = 0 ; a [ 1 ] = 1 ; for ( int i = 2 ; i <= d ; i ++ ) a [ i ] = a [ i - 1 ] * 9 + floor ( ceil ( pow ( 10 , i - 1 ) ) ) ; int p = floor ( ceil ( pow ( 10 , d ) ) ; int msd = floor ( n / p ) ; if ( msd == 4 ) return ( msd ) * a [ d ] + ( n % p ) + 1 ; if ( msd > 4 ) return ( msd - 1 ) * a [ d ] + p + countNumbersWith4 ( n % p ) ; return ( msd ) * a [ d ] + countNumbersWith4 ( n % p ) ; }

BLEU: 81.08
Edit Sim: 68


Src: 
function isPowerOfTwo ( n ) { if ( n == 0 ) return 0 ; while ( n != 1 ) { if ( n % 2 != 0 ) return 0 ; n = n / 2 ; } return 1 ; }
Ref: 
bool isPowerOfTwo ( int n ) { if ( n == 0 ) return 0 ; while ( n != 1 ) { if ( n % 2 != 0 ) return 0 ; n = n / 2 ; } return 1 ; }
Hyp: 
int isPowerOfTwo ( int n ) { if ( n == 0 ) return 0 ; while ( n != 1 ) { if ( n % 2 != 0 ) return 0 ; n = n / 2 ; } return 1 ; }

BLEU: 97.75
Edit Sim: 4


Src: 
function lengperpbisect ( r1 , r2 ) { var z = 2 * Math . sqrt ( ( r1 * r1 ) - ( ( r1 - r2 ) * ( r1 - r2 ) / 4 ) ) ; document . write ( " " + " " + z . toFixed ( 5 ) ) ; }
Ref: 
void lengperpbisect ( double r1 , double r2 ) { double z = 2 * sqrt ( ( r1 * r1 ) - ( ( r1 - r2 ) * ( r1 - r2 ) / 4 ) ) ; cout << " The ▁ length ▁ of ▁ the ▁ " << " perpendicular ▁ bisector ▁ is ▁ " << z << endl ; }
Hyp: 
void lengperpbisect ( int r1 , int r2 ) { double z = 2 * sqrt ( ( r1 * r1 ) - ( ( r1 - r2 ) * ( r1 - r2 ) / 4 ) ) ; cout << " Yes STRNEWLINE " << " No STRNEWLINE " ; }

BLEU: 58.38
Edit Sim: 78


Src: 
function cntElements ( arr , n ) { let cnt = 0 ; for ( let i = 0 ; i < n - 2 ; i ++ ) { if ( arr [ i ] == ( arr [ i + 1 ] ^ arr [ i + 2 ] ) ) { cnt ++ ; } } return cnt ; }
Ref: 
int cntElements ( int arr [ ] , int n ) { int cnt = 0 ; for ( int i = 0 ; i < n - 2 ; i ++ ) { if ( arr [ i ] == ( arr [ i + 1 ] ^ arr [ i + 2 ] ) ) { cnt ++ ; } } return cnt ; }
Hyp: 
int cntElements ( int arr [ ] , int n ) { int cnt = 0 ; for ( int i = 0 ; i < n - 2 ; i ++ ) { if ( arr [ i ] == ( arr [ i + 1 ] ^ arr [ i + 2 ] ) ) { cnt ++ ; } } return cnt ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function maxcntPairsSumKRemoved ( arr , k ) { var cntPairs = 0 ; if ( arr . length <= 1 ) return cntPairs ; arr . sort ( ) ; var left = 0 ; var right = arr . length - 1 ; while ( left < right ) { var s = arr [ left ] + arr [ right ] ; if ( s == k ) { cntPairs += 1 ; left += 1 ; right -= 1 ; } else if ( s > k ) right -= 1 ; else left += 1 ; } return cntPairs ; }
Ref: 
int maxcntPairsSumKRemoved ( vector < int > arr , int k ) { int cntPairs = 0 ; if ( arr . size ( ) <= 1 ) return cntPairs ; sort ( arr . begin ( ) , arr . end ( ) ) ; int left = 0 ; int right = arr . size ( ) - 1 ; while ( left < right ) { int s = arr [ left ] + arr [ right ] ; if ( s == k ) { cntPairs += 1 ; left += 1 ; right -= 1 ; } else if ( s > k ) right -= 1 ; else left += 1 ; } return cntPairs ; }
Hyp: 
int maxcntPairsSumKRemoved ( int arr [ ] , int k ) { int cntPairs = 0 ; if ( arr . size ( ) <= 1 ) return cntPairs ; sort ( arr , arr + 1 ) ; int left = 0 ; int right = arr . size ( ) - 1 ; while ( left < right ) { int s = arr [ left ] + arr [ right ] ; if ( s == k ) { cntPairs += 1 ; left += 1 ; right -= 1 ; } else if ( s > k ) right -= 1 ; else left += 1 ; } return cntPairs ; }

BLEU: 86.31
Edit Sim: 34


Src: 
function lbs ( arr , n ) { let i , j ; let lis = new Array ( n ) for ( i = 0 ; i < n ; i ++ ) lis [ i ] = 1 ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; let lds = new Array ( n ) ; for ( i = 0 ; i < n ; i ++ ) lds [ i ] = 1 ; for ( i = n - 2 ; i >= 0 ; i -- ) for ( j = n - 1 ; j > i ; j -- ) if ( arr [ i ] > arr [ j ] && lds [ i ] < lds [ j ] + 1 ) lds [ i ] = lds [ j ] + 1 ; let max = lis [ 0 ] + lds [ 0 ] - 1 ; for ( i = 1 ; i < n ; i ++ ) if ( lis [ i ] + lds [ i ] - 1 > max ) max = lis [ i ] + lds [ i ] - 1 ; return max ; }
Ref: 
int lbs ( int arr [ ] , int n ) { int i , j ; int * lis = new int [ n ] ; for ( i = 0 ; i < n ; i ++ ) lis [ i ] = 1 ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; int * lds = new int [ n ] ; for ( i = 0 ; i < n ; i ++ ) lds [ i ] = 1 ; for ( i = n - 2 ; i >= 0 ; i -- ) for ( j = n - 1 ; j > i ; j -- ) if ( arr [ i ] > arr [ j ] && lds [ i ] < lds [ j ] + 1 ) lds [ i ] = lds [ j ] + 1 ; int max = lis [ 0 ] + lds [ 0 ] - 1 ; for ( i = 1 ; i < n ; i ++ ) if ( lis [ i ] + lds [ i ] - 1 > max ) max = lis [ i ] + lds [ i ] - 1 ; return max ; }
Hyp: 
int lbs ( int arr [ ] , int n ) { int i , j ; int lis [ n ] ; for ( i = 0 ; i < n ; i ++ ) lis [ i ] = 1 ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; int lds [ n ] ; for ( i = 0 ; i < n ; i ++ ) lds [ i ] = 1 ; for ( i = n - 2 ; i >= 0 ; i -- ) for ( j = n - 1 ; j > i ; j -- ) if ( arr [ i ] > arr [ j ] && lds [ i ] < lds [ j ] + 1 ) lds [ i ] = lds [ j ] + 1 ; int max = lis [ 0 ] + lds [ 0 ] - 1 ; for ( i = 1 ; i < n ; i ++ ) if ( lis [ i ] + lds [ i ] - 1 > max ) max = lis [ i ] + lds [ i ] - 1 ; return max ; }

BLEU: 95.26
Edit Sim: 24


Src: 
function TowerOfHanoi ( N ) { for ( let x = 1 ; x <= Math . pow ( 2 , N ) - 1 ; x ++ ) { document . write ( " " + ( ( x & x - 1 ) % 3 + 1 ) + " " + ( ( ( x x - 1 ) + 1 ) % 3 + 1 ) + " " ) ; } }
Ref: 
void TowerOfHanoi ( int N ) { for ( int x = 1 ; x <= pow ( 2 , N ) - 1 ; x ++ ) { cout << " Move ▁ from ▁ Rod ▁ " << ( ( x & x - 1 ) % 3 + 1 ) << " ▁ to ▁ Rod ▁ " << ( ( ( x x - 1 ) + 1 ) % 3 + 1 ) << endl ; } }
Hyp: 
void TowerOfHanoi ( int N ) { for ( long long int x = 1 ; x <= pow ( 2 , N ) - 1 ; x ++ ) { cout << " ( " << ( ( x & x - 1 ) % 3 + 1 ) << " , ▁ " << ( ( x x - 1 ) + 1 ) % 3 + 1 ) << endl ; } }

BLEU: 80.7
Edit Sim: 41


Src: 
function printAMeans ( A , B , N ) { let d = ( B - A ) / ( N + 1 ) ; for ( let i = 1 ; i <= N ; i ++ ) document . write ( ( A + i * d ) + " " ) ; }
Ref: 
void printAMeans ( int A , int B , int N ) { float d = ( float ) ( B - A ) / ( N + 1 ) ; for ( int i = 1 ; i <= N ; i ++ ) cout << ( A + i * d ) << " ▁ " ; }
Hyp: 
void printAMeans ( int A , int B , int N ) { int d = ( B - A ) / ( N + 1 ) ; for ( int i = 1 ; i <= N ; i ++ ) cout << ( A + i * d ) << " ▁ " ; }

BLEU: 89.29
Edit Sim: 14


Src: 
function checkArrInStack ( s , arr , n ) { var freq = new Map ( ) ; for ( var i = 0 ; i < n ; i ++ ) { if ( freq . has ( arr [ i ] ) ) freq . set ( arr [ i ] , freq . get ( arr [ i ] ) + 1 ) else freq . set ( arr [ i ] , 1 ) } while ( s . length != 0 ) { var poppedEle = s [ s . length - 1 ] ; s . pop ( ) ; if ( freq . has ( poppedEle ) ) freq . set ( poppedEle , freq . get ( poppedEle ) - 1 ) ; } if ( freq . size == 0 ) return 0 ; return 1 ; }
Ref: 
bool checkArrInStack ( stack < int > s , int arr [ ] , int n ) { map < int , int > freq ; for ( int i = 0 ; i < n ; i ++ ) freq [ arr [ i ] ] ++ ; while ( ! s . empty ( ) ) { int poppedEle = s . top ( ) ; s . pop ( ) ; if ( freq [ poppedEle ] ) freq [ poppedEle ] -= 1 ; } if ( freq . size ( ) == 0 ) return 0 ; return 1 ; }
Hyp: 
int checkArrInStack ( stack < int > & s , int arr [ ] , int n ) { unordered_map < int , int > freq ; for ( int i = 0 ; i < n ; i ++ ) { freq [ arr [ i ] ] ++ ; else freq [ arr [ i ] ] = 1 ; } while ( s . top ( ) != 0 ) { int poppedEle = s . top ( ) ; s . pop ( ) ; if ( freq . find ( poppedEle ) != freq . end ( ) ) freq [ poppedEle ] -- ; } if ( freq . size ( ) == 0 ) return 0 ; return 1 ; }

BLEU: 66.84
Edit Sim: 91


Src: 
function noOfCards ( n ) { return parseInt ( n * ( 3 * n + 1 ) / 2 ) ; }
Ref: 
int noOfCards ( int n ) { return n * ( 3 * n + 1 ) / 2 ; }
Hyp: 
int noOfCards ( int n ) { return n * ( 3 * n + 1 ) / 2 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function multiplyByMersenne ( N , M ) { let x = ( Math . log ( M + 1 ) / Math . log ( 2 ) ) ; return ( ( N << x ) - N ) ; }
Ref: 
long multiplyByMersenne ( long N , long M ) { long x = log2 ( M + 1 ) ; return ( ( N << x ) - N ) ; }
Hyp: 
int multiplyByMersenne ( int N , int M ) { int x = ( log2 ( M + 1 ) / log2 ( 2 ) ) ; return ( ( N << x ) - N ) ; }

BLEU: 54.1
Edit Sim: 29


Src: 
function isDivisible ( n ) { let d ; while ( Math . floor ( n / 100 ) > 0 ) { d = n % 10 ; n = Math . floor ( n / 10 ) ; n = Math . abs ( n - ( d * 3 ) ) ; } return ( n % 31 == 0 ) ; }
Ref: 
bool isDivisible ( int n ) { int d ; while ( n / 100 ) { d = n % 10 ; n /= 10 ; n = abs ( n - ( d * 3 ) ) ; } return ( n % 31 == 0 ) ; }
Hyp: 
bool isDivisible ( int n ) { int d ; while ( n / 100 > 0 ) { d = n % 10 ; n = n / 10 ; n = abs ( n - ( d * 3 ) ) ; } return ( n % 31 == 0 ) ; }

BLEU: 85.12
Edit Sim: 9


Src: 
function count ( N , K , R ) { var sum = 0 ; for ( i = 1 ; i <= N ; i ++ ) { if ( i % K == R ) sum += i ; } return sum ; }
Ref: 
int count ( int N , int K , int R ) { long long int sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( i % K == R ) sum += i ; } return sum ; }
Hyp: 
int count ( int N , int K , int R ) { int sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( i % K == R ) sum += i ; } return sum ; }

BLEU: 93.09
Edit Sim: 10


Src: 
function distance ( a1 , b1 , c1 , d1 , a2 , b2 , c2 , d2 ) { let x1 , y1 , z1 , d ; if ( a1 / a2 == b1 / b2 && b1 / b2 == c1 / c2 ) { x1 = y1 = 0 ; z1 = - d1 / c1 ; d = Math . abs ( ( c2 * z1 + d2 ) ) / ( Math . sqrt ( a2 * a2 + b2 * b2 + c2 * c2 ) ) ; document . write ( " " + d ) ; } else document . write ( " " ) ; }
Ref: 
void distance ( float a1 , float b1 , float c1 , float d1 , float a2 , float b2 , float c2 , float d2 ) { float x1 , y1 , z1 , d ; if ( a1 / a2 == b1 / b2 && b1 / b2 == c1 / c2 ) { x1 = y1 = 0 ; z1 = - d1 / c1 ; d = fabs ( ( c2 * z1 + d2 ) ) / ( sqrt ( a2 * a2 + b2 * b2 + c2 * c2 ) ) ; cout << " Perpendicular ▁ distance ▁ is ▁ " << d << endl ; } else cout << " Planes ▁ are ▁ not ▁ parallel " ; return ; }
Hyp: 
void distance ( float a1 , float b1 , float c1 , float d1 , float a2 , float b2 , float c2 , float d2 ) { float x1 , y1 , z1 , d ; if ( a1 / a2 == b1 / b2 && b1 / b2 == c1 / c2 ) { x1 = y1 = 0 ; z1 = - d1 / c1 ; d = abs ( ( c2 * z1 + d2 ) ) / ( sqrt ( a2 * a2 + b2 * b2 + c2 * c2 ) ) ; cout << " Angle ▁ is ▁ " << d ; } else cout << " Angle ▁ is ▁ not ▁ present ! " ; }

BLEU: 84.83
Edit Sim: 52


Src: 
function AND ( a , n ) { let ans = a [ 0 ] ; for ( let i = 0 ; i < n ; ++ i ) ans &= a [ i ] ; return ans ; }
Ref: 
int AND ( int a [ ] , int n ) { int ans = a [ 0 ] ; for ( int i = 0 ; i < n ; ++ i ) ans &= a [ i ] ; return ans ; }
Hyp: 
int AND ( int a [ ] , int n ) { int ans = a [ 0 ] ; for ( int i = 0 ; i < n ; ++ i ) ans &= a [ i ] ; return ans ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findVolume ( l , b , h ) { let volume = ( l * b * h ) / 2 ; return volume ; }
Ref: 
float findVolume ( float l , float b , float h ) { float volume = ( l * b * h ) / 2 ; return volume ; }
Hyp: 
double findVolume ( int l , int b , int h ) { double volume = ( l * b * h ) / 2 ; return volume ; }

BLEU: 63.44
Edit Sim: 24


Src: 
function countFreq ( arr , n ) { let visited = new Array ( n ) ; visited . fill ( false ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( visited [ i ] == true ) continue ; let count = 1 ; for ( let j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] == arr [ j ] ) { visited [ j ] = true ; count ++ ; } } document . write ( arr [ i ] + " " + count + " " ) ; } }
Ref: 
void countFreq ( int arr [ ] , int n ) { vector < int > visited ( n , false ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( visited [ i ] == true ) continue ; int count = 1 ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] == arr [ j ] ) { visited [ j ] = true ; count ++ ; } } cout << arr [ i ] << " ▁ " << count << endl ; } }
Hyp: 
void countFreq ( int arr [ ] , int n ) { bool visited [ n ] ; memset ( visited , false , sizeof ( visited ) ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( visited [ i ] == true ) continue ; int count = 1 ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] == arr [ j ] ) { visited [ j ] = true ; count ++ ; } } cout << arr [ i ] << " ▁ " << count << " ▁ " ; } }

BLEU: 83.02
Edit Sim: 49


Src: 
function result ( n , k , t ) { if ( t <= k ) document . write ( t ) ; else if ( t <= n ) document . write ( k ) ; else { let temp = t - n ; temp = k - temp ; document . write ( temp ) ; } }
Ref: 
void result ( long long n , long long k , long long t ) { if ( t <= k ) cout << t ; else if ( t <= n ) cout << k ; else { long long temp = t - n ; temp = k - temp ; cout << temp ; } }
Hyp: 
void result ( int n , int k , int t ) { if ( t <= k ) cout << t ; else if ( t <= n ) cout << k ; else { int temp = t - n ; temp = k - temp ; cout << temp ; } }

BLEU: 76.33
Edit Sim: 32


Src: 
function countNumbers ( l , r ) { return ( parseInt ( r / 2 ) - parseInt ( ( l - 1 ) / 2 ) ) ; }
Ref: 
int countNumbers ( int l , int r ) { return ( ( r / 2 ) - ( l - 1 ) / 2 ) ; }
Hyp: 
int countNumbers ( int l , int r ) { return ( ( r / 2 ) - ( l - 1 ) / 2 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function solve ( n , k , m ) { if ( n == 0 && k == 0 ) return 1 ; if ( n == 0 && k != 0 ) return 0 ; if ( n != 0 && k == 0 ) { return 0 ; } if ( n < 0 k < 0 ) return 0 ; if ( dp [ n ] [ k ] > 0 ) return dp [ n ] [ k ] ; var ans = 0 ; for ( var j = 1 ; j <= m ; j ++ ) { ans += solve ( n - j , k - 1 , m ) ; } return dp [ n ] [ k ] = ans ; }
Ref: 
int solve ( int n , int k , int m ) { if ( n == 0 && k == 0 ) return 1 ; if ( n == 0 && k != 0 ) return 0 ; if ( n != 0 && k == 0 ) return 0 ; if ( n < 0 k < 0 ) return 0 ; if ( dp [ n ] [ k ] ) return dp [ n ] [ k ] ; int ans = 0 ; for ( int j = 1 ; j <= m ; j ++ ) { ans += solve ( n - j , k - 1 , m ) ; } return dp [ n ] [ k ] = ans ; }
Hyp: 
int solve ( int n , int k , int m ) { if ( n == 0 && k == 0 ) return 1 ; if ( n == 0 && k != 0 ) return 0 ; if ( n != 0 && k == 0 ) return 0 ; if ( n < 0 k < 0 ) return 0 ; if ( dp [ n ] [ k ] > 0 ) return dp [ n ] [ k ] ; int ans = 0 ; for ( int j = 1 ; j <= m ; j ++ ) { ans += solve ( n - j , k - 1 , m ) ; } return dp [ n ] [ k ] = ans ; }

BLEU: 97.35
Edit Sim: 4


Src: 
function getMinCost ( A , B , N ) { let mini = Number . MAX_VALUE ; for ( let i = 0 ; i < N ; i ++ ) { mini = Math . min ( mini , Math . min ( A [ i ] , B [ i ] ) ) ; } return mini * ( 2 * N - 1 ) ; }
Ref: 
int getMinCost ( vector < int > A , vector < int > B , int N ) { int mini = INT_MAX ; for ( int i = 0 ; i < N ; i ++ ) { mini = min ( mini , min ( A [ i ] , B [ i ] ) ) ; } return mini * ( 2 * N - 1 ) ; }
Hyp: 
int getMinCost ( int A [ ] , int B [ ] , int N ) { int mini = INT_MAX ; for ( int i = 0 ; i < N ; i ++ ) { mini = min ( mini , min ( A [ i ] , B [ i ] ) ) ; } return mini * ( 2 * N - 1 ) ; }

BLEU: 84.07
Edit Sim: 23


Src: 
function countPieces ( N ) { return 2 * N ; }
Ref: 
int countPieces ( int N ) { return 2 * N ; }
Hyp: 
int countPieces ( int N ) { return 2 * N ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function getMaximum ( N , M , mat ) { let global_max = Number . MIN_VALUE ; for ( let i = 0 ; i < N ; i ++ ) { for ( let j = i + 1 ; j < N ; j ++ ) { let row_min = Number . MAX_VALUE ; for ( let k = 0 ; k < M ; k ++ ) { let m = Math . max ( mat [ i ] [ k ] , mat [ j ] [ k ] ) ; row_min = Math . min ( row_min , m ) ; } global_max = Math . max ( global_max , row_min ) ; } } return global_max ; }
Ref: 
int getMaximum ( int N , int M , vector < vector < int > > mat ) { int global_max = INT_MIN ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { int row_min = INT_MAX ; for ( int k = 0 ; k < M ; k ++ ) { int m = max ( mat [ i ] [ k ] , mat [ j ] [ k ] ) ; row_min = min ( row_min , m ) ; } global_max = max ( global_max , row_min ) ; } } return global_max ; }
Hyp: 
int getMaximum ( int N , int M , int mat [ ] [ M ] ) { int global_max = INT_MIN ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { int row_min = INT_MAX ; for ( int k = 0 ; k < M ; k ++ ) { int m = max ( mat [ i ] [ k ] , mat [ j ] [ k ] ) ; row_min = min ( row_min , m ) ; } global_max = max ( global_max , row_min ) ; } } return global_max ; }

BLEU: 92.63
Edit Sim: 21


Src: 
function countEqual ( n ) { return parseInt ( ( n + 1 ) / 2 ) ; }
Ref: 
int countEqual ( int n ) { return ( n + 1 ) / 2 ; }
Hyp: 
int countEqual ( int n ) { return ( n + 1 ) / 2 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findRepeatingElement ( arr , low , high ) { if ( low > high ) return - 1 ; var mid = parseInt ( ( low + high ) / 2 ) ; if ( arr [ mid ] != mid + 1 ) { if ( mid > 0 && arr [ mid ] == arr [ mid - 1 ] ) return mid ; return findRepeatingElement ( arr , low , mid - 1 ) ; } return findRepeatingElement ( arr , mid + 1 , high ) ; }
Ref: 
int findRepeatingElement ( int arr [ ] , int low , int high ) { if ( low > high ) return -1 ; int mid = low + ( high - low ) / 2 ; if ( arr [ mid ] != mid + 1 ) { if ( mid > 0 && arr [ mid ] == arr [ mid - 1 ] ) return mid ; return findRepeatingElement ( arr , low , mid - 1 ) ; } return findRepeatingElement ( arr , mid + 1 , high ) ; }
Hyp: 
int findRepeatingElement ( int arr [ ] , int low , int high ) { if ( low > high ) return -1 ; int mid = ( low + high ) / 2 ; if ( arr [ mid ] != mid + 1 ) { if ( mid > 0 && arr [ mid ] == arr [ mid - 1 ] ) return mid ; return findRepeatingElement ( arr , low , mid - 1 ) ; } return findRepeatingElement ( arr , mid + 1 , high ) ; }

BLEU: 93.37
Edit Sim: 10


Src: 
function swapBits ( n , p1 , p2 ) { n ^= 1 << p1 ; n ^= 1 << p2 ; return n ; }
Ref: 
int swapBits ( int n , int p1 , int p2 ) { n ^= 1 << p1 ; n ^= 1 << p2 ; return n ; }
Hyp: 
int swapBits ( int n , int p1 , int p2 ) { n ^= 1 << p1 ; n ^= 1 << p2 ; return n ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function isRatioPossible ( lowCost , upCost , lowQuant , upQuant , r ) { for ( let i = lowQuant ; i <= upQuant ; i ++ ) { let ans = i * r ; if ( lowCost <= ans && ans <= upCost ) return true ; } return false ; }
Ref: 
bool isRatioPossible ( int lowCost , int upCost , int lowQuant , int upQuant , int r ) { for ( int i = lowQuant ; i <= upQuant ; i ++ ) { int ans = i * r ; if ( lowCost <= ans && ans <= upCost ) return true ; } return false ; }
Hyp: 
bool isRatioPossible ( int lowCost , int upCost , int lowQuant , int upQuant , int r ) { for ( int i = lowQuant ; i <= upQuant ; i ++ ) { int ans = i * r ; if ( lowCost <= ans && ans <= upCost ) return true ; } return false ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findNthOccur ( str , ch , N ) { var occur = 0 ; for ( var i = 0 ; i < str . length ; i ++ ) { if ( str [ i ] == ch ) { occur += 1 ; } if ( occur == N ) return i ; } return - 1 ; }
Ref: 
int findNthOccur ( string str , char ch , int N ) { int occur = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] == ch ) { occur += 1 ; } if ( occur == N ) return i ; } return -1 ; }
Hyp: 
int findNthOccur ( string str , char ch , int N ) { int occur = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] == ch ) { occur += 1 ; } if ( occur == N ) return i ; } return -1 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function centereddecagonalnum ( n ) { return ( 5 * n * n + 5 * n + 1 ) ; }
Ref: 
int centereddecagonalnum ( int n ) { return ( 5 * n * n + 5 * n + 1 ) ; }
Hyp: 
int centereddecagonalnum ( long int n ) { return ( 5 * n * n + 5 * n + 1 ) ; }

BLEU: 88.95
Edit Sim: 5


Src: 
function printGolomb ( n ) { let dp = Array ( n + 1 ) . fill ( 0 ) ; dp [ 1 ] = 1 ; document . write ( dp [ 1 ] + " " ) ; for ( i = 2 ; i <= n ; i ++ ) { dp [ i ] = 1 + dp [ i - dp [ dp [ i - 1 ] ] ] ; document . write ( dp [ i ] + " " ) ; } }
Ref: 
void printGolomb ( int n ) { int dp [ n + 1 ] ; dp [ 1 ] = 1 ; cout << dp [ 1 ] << " ▁ " ; for ( int i = 2 ; i <= n ; i ++ ) { dp [ i ] = 1 + dp [ i - dp [ dp [ i - 1 ] ] ] ; cout << dp [ i ] << " ▁ " ; } }
Hyp: 
void printGolomb ( int n ) { int dp [ n + 1 ] ; dp [ 1 ] = 1 ; cout << dp [ 1 ] << " ▁ " ; for ( int i = 2 ; i <= n ; i ++ ) { dp [ i ] = 1 + dp [ i - dp [ dp [ i - 1 ] ] ] ; cout << dp [ i ] << " ▁ " ; } }

BLEU: 100.0
Edit Sim: 0


Src: 
function checkValidity ( a , b , c ) { if ( a + b <= c a + c <= b b + c <= a ) return false ; else return true ; }
Ref: 
bool checkValidity ( int a , int b , int c ) { if ( a + b <= c a + c <= b b + c <= a ) return false ; else return true ; }
Hyp: 
bool checkValidity ( int a , int b , int c ) { if ( a + b <= c a + c <= b b + c <= a ) return false ; else return true ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function bToHexaDecimal ( s ) { let len = s . length , check = 0 ; let num = 0 , sum = 0 , mul = 1 ; let ans = new Array ( ) ; for ( let i = len - 1 ; i >= 0 ; i -- ) { sum += ( s [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ) * mul ; mul *= 2 ; check ++ ; if ( check == 4 i == 0 ) { if ( sum <= 9 ) ans . push ( String . fromCharCode ( sum + ' ' . charCodeAt ( 0 ) ) ) ; else ans . push ( String . fromCharCode ( sum + 55 ) ) ; check = 0 ; sum = 0 ; mul = 1 ; } } len = ans . length ; for ( let i = len - 1 ; i >= 0 ; i -- ) document . write ( ans [ i ] ) ; }
Ref: 
void bToHexaDecimal ( string s ) { int len = s . length ( ) , check = 0 ; int num = 0 , sum = 0 , mul = 1 ; vector < char > ans ; for ( int i = len - 1 ; i >= 0 ; i -- ) { sum += ( s [ i ] - '0' ) * mul ; mul *= 2 ; check ++ ; if ( check == 4 i == 0 ) { if ( sum <= 9 ) ans . push_back ( sum + '0' ) ; else ans . push_back ( sum + 55 ) ; check = 0 ; sum = 0 ; mul = 1 ; } } len = ans . size ( ) ; for ( int i = len - 1 ; i >= 0 ; i -- ) cout << ans [ i ] ; }
Hyp: 
void bToHexaDecimal ( string s ) { int len = s . length ( ) , check = 0 , num = 0 , sum = 0 , mul = 1 ; vector < char > ans ; for ( int i = len - 1 ; i >= 0 ; i -- ) { sum += ( s [ i ] - '0' ) * mul ; mul *= 2 ; check ++ ; if ( check == 4 i == 0 ) { if ( sum <= 9 ) ans . push_back ( sum + '0' ) ; else ans . push_back ( sum + 55 ) ; check = 0 ; sum = 0 ; mul = 1 ; } } len = ans . size ( ) ; for ( int i = len - 1 ; i >= 0 ; i -- ) cout << ans [ i ] ; }

BLEU: 97.76
Edit Sim: 5


Src: 
function countCubes ( a , b ) { for ( let i = a ; i <= b ; i ++ ) for ( let j = 1 ; j * j * j <= i ; j ++ ) if ( j * j * j == i ) cnt ++ ; return cnt ; }
Ref: 
int countCubes ( int a , int b ) { for ( int i = a ; i <= b ; i ++ ) for ( int j = 1 ; j * j * j <= i ; j ++ ) if ( j * j * j == i ) cnt ++ ; return cnt ; }
Hyp: 
int countCubes ( int a , int b ) { int cnt = 0 ; for ( int i = a ; i <= b ; i ++ ) for ( int j = 1 ; j * j * j <= i ; j ++ ) if ( j * j * j == i ) cnt ++ ; return cnt ; }

BLEU: 89.71
Edit Sim: 14


Src: 
function LongestOddEvenSubarray ( A , N ) { let dp ; dp = 1 ; let ans = 1 ; for ( let i = 1 ; i < N ; i ++ ) { if ( ( A [ i ] % 2 == 0 && A [ i - 1 ] % 2 == 0 ) || ( A [ i ] % 2 != 0 && A [ i - 1 ] % 2 != 0 ) ) { dp = dp + 1 ; ans = Math . max ( ans , dp ) ; } else dp = 1 ; } return ans ; }
Ref: 
int LongestOddEvenSubarray ( int A [ ] , int N ) { int dp ; dp = 1 ; int ans = 1 ; for ( int i = 1 ; i < N ; i ++ ) { if ( ( A [ i ] % 2 == 0 && A [ i - 1 ] % 2 == 0 ) || ( A [ i ] % 2 != 0 && A [ i - 1 ] % 2 != 0 ) ) { dp = dp + 1 ; ans = max ( ans , dp ) ; } else dp = 1 ; } return ans ; }
Hyp: 
int LongestOddEvenSubarray ( int A [ ] , int N ) { int dp ; dp = 1 ; int ans = 1 ; for ( int i = 1 ; i < N ; i ++ ) { if ( ( A [ i ] % 2 == 0 && A [ i - 1 ] % 2 == 0 ) || ( A [ i ] % 2 != 0 && A [ i - 1 ] % 2 != 0 ) ) { dp = dp + 1 ; ans = max ( ans , dp ) ; } else dp = 1 ; } return ans ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function partitions ( n ) { var p = Array ( n + 1 ) . fill ( 0 ) ; p [ 0 ] = 1 ; for ( i = 1 ; i <= n ; ++ i ) { var k = 1 ; while ( ( k * ( 3 * k - 1 ) ) / 2 <= i ) { p [ i ] += ( k % 2 != 0 ? 1 : - 1 ) * p [ i - ( k * ( 3 * k - 1 ) ) / 2 ] ; if ( k > 0 ) { k *= - 1 ; } else { k = 1 - k ; } } } return p [ n ] ; }
Ref: 
long partitions ( int n ) { vector < long long > p ( n + 1 , 0 ) ; p [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; ++ i ) { int k = 1 ; while ( ( k * ( 3 * k - 1 ) ) / 2 <= i ) { p [ i ] += ( k % 2 ? 1 : -1 ) * p [ i - ( k * ( 3 * k - 1 ) ) / 2 ] ; if ( k > 0 ) k *= -1 ; else k = 1 - k ; } } return p [ n ] ; }
Hyp: 
int partitions ( int n ) { int p [ n + 1 ] ; p [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; ++ i ) { int k = 1 ; while ( ( k * ( 3 * k - 1 ) ) / 2 <= i ) { p [ i ] += ( k % 2 != 0 ? 1 : -1 ) * p [ i - ( k * ( 3 * k - 1 ) ) / 2 ] ; if ( k > 0 ) { k *= -1 ; } else { k = 1 - k ; } } } return p [ n ] ; }

BLEU: 84.74
Edit Sim: 41


Src: 
function min_operation ( a , n ) { var ans = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( i > 0 ) ans += Math . abs ( a [ i ] - a [ i - 1 ] ) ; else ans += Math . abs ( a [ i ] ) ; } return ans ; }
Ref: 
int min_operation ( int a [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i > 0 ) ans += abs ( a [ i ] - a [ i - 1 ] ) ; else ans += abs ( a [ i ] ) ; } return ans ; }
Hyp: 
int min_operation ( int a [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i > 0 ) ans += abs ( a [ i ] - a [ i - 1 ] ) ; else ans += abs ( a [ i ] ) ; } return ans ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function isWoodall ( x ) { if ( x % 2 == 0 ) return false ; if ( x == 1 ) return true ; x ++ ; let p = 0 ; while ( x % 2 == 0 ) { x = x / 2 ; p ++ ; if ( p == x ) return true ; } return false ; }
Ref: 
bool isWoodall ( int x ) { if ( x % 2 == 0 ) return false ; if ( x == 1 ) return true ; int p = 0 ; while ( x % 2 == 0 ) { x = x / 2 ; p ++ ; if ( p == x ) return true ; } return false ; }
Hyp: 
bool isWoodall ( int x ) { if ( x % 2 == 0 ) return false ; if ( x == 1 ) return true ; x ++ ; int p = 0 ; while ( x % 2 == 0 ) { x = x / 2 ; p ++ ; if ( p == x ) return true ; } return false ; }

BLEU: 94.33
Edit Sim: 7


Src: 
function mindigits ( n ) { if ( n % 9 == 0 ) { document . write ( Math . floor ( n / 9 ) + " " ) ; } else { document . write ( Math . floor ( n / 9 ) + 1 + " " ) ; } }
Ref: 
void mindigits ( int n ) { if ( n % 9 == 0 ) { cout << n / 9 << endl ; } else { cout << ( n / 9 ) + 1 << endl ; } }
Hyp: 
void mindigits ( int n ) { if ( n % 9 == 0 ) { cout << n / 9 << " ▁ " ; } else { cout << n / 9 + 1 << " ▁ " ; } }

BLEU: 70.56
Edit Sim: 14


Src: 
function find_longest_subarray ( A , N , K ) { let MaxLen = 0 ; let Len = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( K % A [ i ] == 0 ) { Len ++ ; MaxLen = Math . max ( MaxLen , Len ) ; } else { Len = 0 ; } } return MaxLen ; }
Ref: 
int find_longest_subarray ( int A [ ] , int N , int K ) { int MaxLen = 0 ; int Len = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( K % A [ i ] == 0 ) { Len ++ ; MaxLen = max ( MaxLen , Len ) ; } else { Len = 0 ; } } return MaxLen ; }
Hyp: 
int find_longest_subarray ( int A [ ] , int N , int K ) { int MaxLen = 0 ; int Len = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( K % A [ i ] == 0 ) { Len ++ ; MaxLen = max ( MaxLen , Len ) ; } else { Len = 0 ; } } return MaxLen ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function maxXOR ( mat , N ) { let r_xor , c_xor ; let max_xor = 0 ; for ( let i = 0 ; i < N ; i ++ ) { r_xor = 0 , c_xor = 0 ; for ( let j = 0 ; j < N ; j ++ ) { r_xor = r_xor ^ mat [ i ] [ j ] ; c_xor = c_xor ^ mat [ j ] [ i ] ; } if ( max_xor < Math . max ( r_xor , c_xor ) ) max_xor = Math . max ( r_xor , c_xor ) ; } return max_xor ; }
Ref: 
int maxXOR ( int mat [ ] [ MAX ] , int N ) { int r_xor , c_xor ; int max_xor = 0 ; for ( int i = 0 ; i < N ; i ++ ) { r_xor = 0 , c_xor = 0 ; for ( int j = 0 ; j < N ; j ++ ) { r_xor = r_xor ^ mat [ i ] [ j ] ; c_xor = c_xor ^ mat [ j ] [ i ] ; } if ( max_xor < max ( r_xor , c_xor ) ) max_xor = max ( r_xor , c_xor ) ; } return max_xor ; }
Hyp: 
int maxXOR ( int mat [ ] [ MAX ] , int N ) { int r_xor , c_xor ; int max_xor = 0 ; for ( int i = 0 ; i < N ; i ++ ) { r_xor = 0 , c_xor = 0 ; for ( int j = 0 ; j < N ; j ++ ) { r_xor = r_xor ^ mat [ i ] [ j ] ; c_xor = c_xor ^ mat [ j ] [ i ] ; } if ( max_xor < max ( r_xor , c_xor ) ) max_xor = max ( r_xor , c_xor ) ; } return max_xor ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function numberOfSquares ( base ) { base = ( base - 2 ) ; base = Math . floor ( base / 2 ) ; return base * ( base + 1 ) / 2 ; }
Ref: 
int numberOfSquares ( int base ) { base = ( base - 2 ) ; base = floor ( base / 2 ) ; return base * ( base + 1 ) / 2 ; }
Hyp: 
int numberOfSquares ( int base ) { base = ( base - 2 ) ; base = ( base / 2 ) ; return base * ( base + 1 ) / 2 ; }

BLEU: 92.79
Edit Sim: 6


Src: 
function find_and ( arr ) { let ans = arr [ 0 ] ; for ( let i = 0 ; i < arr . length ; i ++ ) { ans = ( ans & arr [ i ] ) ; } return ans ; }
Ref: 
int find_and ( int arr [ ] , int len ) { int ans = arr [ 0 ] ; for ( int i = 0 ; i < len ; i ++ ) { ans = ( ans & arr [ i ] ) ; } return ans ; }
Hyp: 
int find_and ( int arr [ ] , int n ) { int ans = arr [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { ans = ( ans & arr [ i ] ) ; } return ans ; }

BLEU: 89.88
Edit Sim: 4


Src: 
function countIncreasing ( arr , n ) { let cnt = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i + 1 ; j < n ; j ++ ) { if ( arr [ j ] > arr [ j - 1 ] ) cnt ++ ; else break ; } } return cnt ; }
Ref: 
int countIncreasing ( int arr [ ] , int n ) { int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ j ] > arr [ j - 1 ] ) cnt ++ ; else break ; } } return cnt ; }
Hyp: 
int countIncreasing ( int arr [ ] , int n ) { int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ j ] > arr [ j - 1 ] ) cnt ++ ; else break ; } } return cnt ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function checkForSorting ( arr , n ) { let temp = 0 ; for ( let i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] > arr [ i + 1 ] ) { if ( arr [ i ] - arr [ i + 1 ] == 1 ) { temp = arr [ i ] ; arr [ i ] = arr [ i + 1 ] ; arr [ i + 1 ] = temp ; } else return false ; } } return true ; }
Ref: 
bool checkForSorting ( int arr [ ] , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] > arr [ i + 1 ] ) { if ( arr [ i ] - arr [ i + 1 ] == 1 ) swap ( arr [ i ] , arr [ i + 1 ] ) ; else return false ; } } return true ; }
Hyp: 
bool checkForSorting ( int arr [ ] , int n ) { int temp = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] > arr [ i + 1 ] ) { if ( arr [ i ] - arr [ i + 1 ] == 1 ) { temp = arr [ i ] ; arr [ i ] = arr [ i + 1 ] ; arr [ i + 1 ] = temp ; } else return false ; } } return true ; }

BLEU: 70.35
Edit Sim: 58


Src: 
function solve ( N ) { let ans = 0 ; while ( N != 0 ) { ans += N ; N = parseInt ( N / 2 , 10 ) ; } document . write ( ans ) ; }
Ref: 
void solve ( ll N ) { ll ans = 0 ; while ( N != 0 ) { ans += N ; N /= 2 ; } cout << ans << endl ; }
Hyp: 
int solve ( int N ) { int ans = 0 ; while ( N != 0 ) { ans += N ; N /= 2 ; } cout << ans ; }

BLEU: 73.07
Edit Sim: 18


Src: 
function printSeries ( n ) { let i ; for ( i = 1 ; i <= n ; i ++ ) { let num = i * ( i + 1 ) * ( ( i + 2 ) / 6 ) ; document . write ( num + " " ) ; } }
Ref: 
void printSeries ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) { int num = i * ( i + 1 ) * ( i + 2 ) / 6 ; cout << num << " ▁ " ; } }
Hyp: 
void printSeries ( int n ) { int i ; for ( i = 1 ; i <= n ; i ++ ) { int num = i * ( i + 1 ) * ( ( i + 2 ) / 6 ) ; cout << num << " ▁ " ; } }

BLEU: 81.99
Edit Sim: 15


Src: 
function find ( p ) { return Math . ceil ( Math . sqrt ( 2 * 365 * Math . log ( 1 / ( 1 - p ) ) ) ) ; }
Ref: 
int find ( double p ) { return ceil ( sqrt ( 2 * 365 * log ( 1 / ( 1 - p ) ) ) ) ; }
Hyp: 
int find ( int p ) { return ceil ( sqrt ( 2 * 365 * log ( 1 / ( 1 - p ) ) ) ) ; }

BLEU: 91.28
Edit Sim: 6


Src: 
function getResult ( n ) { if ( ( n & 1 ) > 0 ) return 1 ; return - 1 ; }
Ref: 
int getResult ( int n ) { if ( n & 1 ) return 1 ; return -1 ; }
Hyp: 
int getResult ( int n ) { if ( n & 1 ) return 1 ; return -1 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function check ( n ) { if ( ( n & n - 1 ) != 0 ) document . write ( " " ) ; else document . write ( " " ) ; }
Ref: 
void check ( int n ) { if ( ( n & n - 1 ) != 0 ) cout << " YES " << endl ; else cout << " NO " << endl ; }
Hyp: 
void check ( int n ) { if ( ( n & n - 1 ) != 0 ) cout << " Yes " ; else cout << " No " ; }

BLEU: 70.88
Edit Sim: 19


Src: 
function weightedMean ( n ) { return parseInt ( ( 2 * n + 1 ) / 3 , 10 ) ; }
Ref: 
int weightedMean ( int n ) { return ( 2 * n + 1 ) / 3 ; }
Hyp: 
int weightedMean ( int n ) { return ( 2 * n + 1 ) / 3 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function minCostToMakeElementEqual ( a , n ) { let y ; if ( n % 2 == 1 ) y = a [ Math . trunc ( n / 2 ) ] ; else y = Math . trunc ( ( a [ n / 2 ] + a [ ( n - 2 ) / 2 ] ) / 2 ) ; let s = 0 ; for ( let i = 0 ; i < n ; i ++ ) s += Math . abs ( a [ i ] - y ) ; return s ; }
Ref: 
int minCostToMakeElementEqual ( int a [ ] , int n ) { int y ; if ( n % 2 == 1 ) y = a [ n / 2 ] ; else y = ( a [ n / 2 ] + a [ ( n - 2 ) / 2 ] ) / 2 ; int s = 0 ; for ( int i = 0 ; i < n ; i ++ ) s += abs ( a [ i ] - y ) ; return s ; }
Hyp: 
int minCostToMakeElementEqual ( int a [ ] , int n ) { int y ; if ( n % 2 == 1 ) y = a [ n / 2 ] ; else y = ( a [ n / 2 ] + a [ ( n - 2 ) / 2 ] ) / 2 ; int s = 0 ; for ( int i = 0 ; i < n ; i ++ ) s += abs ( a [ i ] - y ) ; return s ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function minimumAdditionOperation ( N ) { let count = 0 ; while ( N ) { if ( N & ( 1 == 1 ) ) { count ++ ; } N = N >> 1 ; } return count ; }
Ref: 
int minimumAdditionOperation ( unsigned long long int N ) { int count = 0 ; while ( N ) { if ( N & 1 == 1 ) { count ++ ; } N = N >> 1 ; } return count ; }
Hyp: 
int minimumAdditionOperation ( unsigned int N ) { unsigned int count = 0 ; while ( N ) { if ( N & ( 1 == 1 ) ) { count ++ ; } N = N >> 1 ; } return count ; }

BLEU: 80.61
Edit Sim: 20


Src: 
function isMember ( a , d , x ) { if ( d == 0 ) return ( x == a ) ; return ( ( x - a ) % d == 0 && ( x - a ) / d >= 0 ) ; }
Ref: 
bool isMember ( int a , int d , int x ) { if ( d == 0 ) return ( x == a ) ; return ( ( x - a ) % d == 0 && ( x - a ) / d >= 0 ) ; }
Hyp: 
bool isMember ( int a , int d , int x ) { if ( d == 0 ) return ( x == a ) ; return ( ( x - a ) % d == 0 && ( x - a ) / d >= 0 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function nthTerm ( n ) { return Math . pow ( n , 2 ) + 2 * n + 2 ; }
Ref: 
int nthTerm ( int n ) { return pow ( n , 2 ) + 2 * n + 2 ; }
Hyp: 
int nthTerm ( int n ) { return pow ( n , 2 ) + 2 * n + 2 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function MatrixChainOrder ( p , i , j ) { if ( i == j ) return 0 ; var min = Number . MAX_VALUE ; var k = 0 ; for ( k = i ; k < j ; k ++ ) { var count = MatrixChainOrder ( p , i , k ) + MatrixChainOrder ( p , k + 1 , j ) + p [ i - 1 ] * p [ k ] * p [ j ] ; if ( count < min ) min = count ; } return min ; }
Ref: 
int MatrixChainOrder ( int p [ ] , int i , int j ) { if ( i == j ) return 0 ; int k ; int min = INT_MAX ; int count ; for ( k = i ; k < j ; k ++ ) { count = MatrixChainOrder ( p , i , k ) + MatrixChainOrder ( p , k + 1 , j ) + p [ i - 1 ] * p [ k ] * p [ j ] ; if ( count < min ) min = count ; } return min ; }
Hyp: 
int MatrixChainOrder ( int * p , int i , int j ) { if ( i == j ) return 0 ; int min = INT_MAX ; int k = 0 ; for ( k = i ; k < j ; k ++ ) { int count = MatrixChainOrder ( p , i , k ) + MatrixChainOrder ( p , k + 1 , j ) + p [ i - 1 ] * p [ k ] * p [ j ] ; if ( count < min ) min = count ; } return min ; }

BLEU: 89.82
Edit Sim: 21


Src: 
function CountPairs ( arr , n ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] % 2 == 0 arr [ j ] % 2 == 0 ) count ++ ; } } return count ; }
Ref: 
int CountPairs ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] % 2 == 0 arr [ j ] % 2 == 0 ) count ++ ; } } return count ; }
Hyp: 
int CountPairs ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] % 2 == 0 arr [ j ] % 2 == 0 ) count ++ ; } } return count ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function first_digit ( x , y ) { var length = parseInt ( Math . log ( x ) / Math . log ( y ) ) + 1 ; var first_digit = parseInt ( x / Math . pow ( y , length - 1 ) ) ; document . write ( first_digit ) ; }
Ref: 
void first_digit ( int x , int y ) { int length = log ( x ) / log ( y ) + 1 ; int first_digit = x / pow ( y , length - 1 ) ; cout << first_digit ; }
Hyp: 
void first_digit ( int x , int y ) { int length = log2 ( x ) + log2 ( y ) + 1 ; int first_digit = x / pow ( y , length - 1 ) ; cout << first_digit ; }

BLEU: 85.89
Edit Sim: 3


Src: 
function findMaxDifference ( arr , n ) { arr . sort ( ) ; let Leftsum = 0 ; let Totalsum = 0 ; let Min = Number . MAX_VALUE , Max = Number . MIN_VALUE ; for ( let i = 0 ; i < n ; i ++ ) Totalsum += arr [ i ] ; for ( let i = 0 ; i < n ; i ++ ) { let leftNumbers = i ; let rightNumbers = n - i - 1 ; Totalsum = Totalsum - arr [ i ] ; let sum = ( leftNumbers * arr [ i ] ) - Leftsum + Totalsum - ( rightNumbers * arr [ i ] ) ; Min = Math . min ( Min , sum ) ; Max = Math . max ( Max , sum ) ; Leftsum += arr [ i ] ; } document . write ( Max - Min ) ; }
Ref: 
void findMaxDifference ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int Leftsum = 0 ; int Totalsum = 0 ; int Min = INT_MAX , Max = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) Totalsum += arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) { int leftNumbers = i ; int rightNumbers = n - i - 1 ; Totalsum = Totalsum - arr [ i ] ; int sum = ( leftNumbers * arr [ i ] ) - Leftsum + Totalsum - ( rightNumbers * arr [ i ] ) ; Min = min ( Min , sum ) ; Max = max ( Max , sum ) ; Leftsum += arr [ i ] ; } cout << Max - Min ; }
Hyp: 
void findMaxDifference ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int Leftsum = 0 ; int Totalsum = 0 ; int Min = INT_MAX , Max = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) Totalsum += arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) { int leftNumbers = i ; int rightNumbers = n - i - 1 ; Totalsum = Totalsum - arr [ i ] ; int sum = ( leftNumbers * arr [ i ] ) - Leftsum + Totalsum - ( rightNumbers * arr [ i ] ) ; Min = min ( Min , sum ) ; Max = max ( Max , sum ) ; Leftsum += arr [ i ] ; } cout << Max - Min ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function maxsubStringLength ( S , N ) { let arr = Array . from ( { length : N } , ( _ , i ) => 0 ) ; for ( let i = 0 ; i < N ; i ++ ) if ( S [ i ] == ' ' S [ i ] == ' ' S [ i ] == ' ' S [ i ] == ' ' S [ i ] == ' ' ) arr [ i ] = 1 ; else arr [ i ] = - 1 ; let maxLen = 0 ; let curr_sum = 0 ; let hash = new Map ( ) ; for ( let i = 0 ; i < N ; i ++ ) { curr_sum += arr [ i ] ; if ( curr_sum == 0 ) maxLen = Math . max ( maxLen , i + 1 ) ; if ( hash . has ( curr_sum ) ) maxLen = Math . max ( maxLen , i - hash . get ( curr_sum ) ) ; else hash . set ( curr_sum , i ) ; } return maxLen ; }
Ref: 
int maxsubstringLength ( string S , int N ) { int arr [ N ] ; for ( int i = 0 ; i < N ; i ++ ) if ( S [ i ] == ' a ' S [ i ] == ' e ' S [ i ] == ' i ' S [ i ] == ' o ' S [ i ] == ' u ' ) arr [ i ] = 1 ; else arr [ i ] = -1 ; int maxLen = 0 ; int curr_sum = 0 ; unordered_map < int , int > hash ; for ( int i = 0 ; i < N ; i ++ ) { curr_sum += arr [ i ] ; if ( curr_sum == 0 ) maxLen = max ( maxLen , i + 1 ) ; if ( hash . find ( curr_sum ) != hash . end ( ) ) maxLen = max ( maxLen , i - hash [ curr_sum ] ) ; else hash [ curr_sum ] = i ; } return maxLen ; }
Hyp: 
int maxsubStringLength ( string S , int N ) { int arr [ N ] ; for ( int i = 0 ; i < N ; i ++ ) if ( S [ i ] == ' A ' S [ i ] == ' C ' S [ i ] == ' D ' S [ i ] == ' E ' ) arr [ i ] = 1 ; else arr [ i ] = -1 ; int maxLen = 0 ; int curr_sum = 0 ; unordered_map < int , int > hash ; for ( int i = 0 ; i < N ; i ++ ) { curr_sum += arr [ i ] ; if ( curr_sum == 0 ) maxLen = max ( maxLen , i + 1 ) ; if ( hash . find ( curr_sum ) != hash . end ( ) ) maxLen = max ( maxLen , i - hash [ curr_sum ] ) ; else hash [ curr_sum ] = i ; } return maxLen ; }

BLEU: 89.28
Edit Sim: 22


Src: 
function minCost ( A , B ) { var n = A . length ; var i = 0 ; var maxlen = 0 ; while ( i < n ) { var length = 0 ; for ( var j = 0 ; j < n ; ++ j ) { if ( A [ i ] == B [ j ] ) { ++ i ; ++ length ; if ( i == n ) break ; } } maxlen = Math . max ( maxlen , length ) ; } return n - maxlen ; }
Ref: 
int minCost ( string A , string B ) { int n = A . size ( ) ; int i = 0 ; int maxlen = 0 ; while ( i < n ) { int length = 0 ; for ( int j = 0 ; j < n ; ++ j ) { if ( A [ i ] == B [ j ] ) { ++ i ; ++ length ; if ( i == n ) break ; } } maxlen = max ( maxlen , length ) ; } return n - maxlen ; }
Hyp: 
int minCost ( int A [ ] , int B [ ] ) { int n = A . length ( ) ; int i = 0 ; int maxlen = 0 ; while ( i < n ) { int length = 0 ; for ( int j = 0 ; j < n ; ++ j ) { if ( A [ i ] == B [ j ] ) { ++ i ; ++ length ; if ( i == n ) break ; } } maxlen = max ( maxlen , length ) ; } return n - maxlen ; }

BLEU: 88.18
Edit Sim: 20


Src: 
function printArr ( n ) { if ( n % 4 == 0 ) { for ( var i = 1 ; i <= n / 2 ; i ++ ) document . write ( i * 2 + ' ' ) ; for ( var i = 1 ; i < n / 2 ; i ++ ) document . write ( i * 2 - 1 + ' ' ) ; document . write ( n + n / 2 - 1 + ' ' ) ; } else document . write ( " " ) ; }
Ref: 
bool printArr ( int n ) { if ( n % 4 == 0 ) { for ( int i = 1 ; i <= n / 2 ; i ++ ) cout << i * 2 << ' ▁ ' ; for ( int i = 1 ; i < n / 2 ; i ++ ) cout << i * 2 - 1 << ' ▁ ' ; cout << n + n / 2 - 1 << ' ' ; } else cout << " - 1" ; }
Hyp: 
void printArr ( int n ) { if ( n % 4 == 0 ) { for ( int i = 1 ; i <= n / 2 ; i ++ ) cout << i * 2 << ' ▁ ' ; for ( int i = 1 ; i < n / 2 ; i ++ ) cout << i * 2 - 1 << ' ▁ ' ; cout << n + n / 2 - 1 << ' ▁ ' ; } else cout << " - 1" ; }

BLEU: 96.19
Edit Sim: 5


Src: 
function onlyFirstAndLastAreSet ( n ) { if ( n == 1 ) return true ; if ( n == 2 ) return false ; return ( ( ( n - 1 ) & ( n - 2 ) ) == 0 ) ; }
Ref: 
bool onlyFirstAndLastAreSet ( unsigned int n ) { if ( n == 1 ) return true ; if ( n == 2 ) return false ; return ( ( ( n - 1 ) & ( n - 2 ) ) == 0 ) ; }
Hyp: 
bool onlyFirstAndLastAreSet ( int n ) { if ( n == 1 ) return true ; if ( n == 2 ) return false ; return ( ( ( n - 1 ) & ( n - 2 ) ) == 0 ) ; }

BLEU: 94.41
Edit Sim: 9


Src: 
function isConversionPossible ( s1 , s2 , x ) { let diff = 0 , n ; n = s1 . length ; for ( let i = 0 ; i < n ; i ++ ) { if ( s1 [ i ] == s2 [ i ] ) continue ; diff = ( ( s2 [ i ] . charCodeAt ( 0 ) - s1 [ i ] . charCodeAt ( 0 ) ) + 26 ) % 26 ; if ( diff > x ) { document . write ( " " ) ; return ; } } document . write ( " " ) ; }
Ref: 
void isConversionPossible ( string s1 , string s2 , int x ) { int diff , n ; n = s1 . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( s1 [ i ] == s2 [ i ] ) continue ; diff = ( int ( s2 [ i ] - s1 [ i ] ) + 26 ) % 26 ; if ( diff > x ) { cout << " NO " << endl ; return ; } } cout << " YES " << endl ; }
Hyp: 
void isConversionPossible ( string s1 , string s2 , int x ) { int diff = 0 , n ; n = s1 . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( s1 [ i ] == s2 [ i ] ) continue ; diff = ( ( int ) ( s2 [ i ] - s1 [ i ] ) + 26 ) % 26 ; if ( diff > x ) { cout << " NO " ; return ; } } cout << " YES " ; }

BLEU: 87.44
Edit Sim: 30


Src: 
function smallestIndex ( a , n ) { let right1 = 0 , right0 = 0 ; let i ; for ( i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 1 ) right1 = i ; else right0 = i ; } return Math . min ( right1 , right0 ) ; }
Ref: 
int smallestIndex ( int a [ ] , int n ) { int right1 = 0 , right0 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 1 ) right1 = i ; else right0 = i ; } return min ( right1 , right0 ) ; }
Hyp: 
int smallestIndex ( int a [ ] , int n ) { int right1 = 0 , right0 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 1 ) right1 = i ; else right0 = i ; } return min ( right1 , right0 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countOpenDoors ( N ) { let doorsOpen = parseInt ( Math . sqrt ( N ) ) ; return doorsOpen ; }
Ref: 
int countOpenDoors ( int N ) { int doorsOpen = sqrt ( N ) ; return doorsOpen ; }
Hyp: 
int countOpenDoors ( int N ) { int doorsOpen = sqrt ( N ) ; return doorsOpen ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findMissing ( arr1 , arr2 , M , N ) { if ( M != N - 1 && N != M - 1 ) { document . write ( " " ) ; return ; } let res = 0 ; for ( let i = 0 ; i < M ; i ++ ) res = res ^ arr1 [ i ] ; for ( let i = 0 ; i < N ; i ++ ) res = res ^ arr2 [ i ] ; document . write ( " " + res ) ; }
Ref: 
void findMissing ( int arr1 [ ] , int arr2 [ ] , int M , int N ) { if ( M != N - 1 && N != M - 1 ) { cout << " Invalid ▁ Input " ; return ; } int res = 0 ; for ( int i = 0 ; i < M ; i ++ ) res = res ^ arr1 [ i ] ; for ( int i = 0 ; i < N ; i ++ ) res = res ^ arr2 [ i ] ; cout << " Missing ▁ element ▁ is ▁ " << res ; }
Hyp: 
void findMissing ( int arr1 [ ] , int arr2 [ ] , int M , int N ) { if ( M != N - 1 && N != M - 1 ) { cout << " No " ; return ; } int res = 0 ; for ( int i = 0 ; i < M ; i ++ ) res = res ^ arr1 [ i ] ; for ( int i = 0 ; i < N ; i ++ ) res = res ^ arr2 [ i ] ; cout << " Yes " << res ; }

BLEU: 88.93
Edit Sim: 37


Src: 
function countSetBitsRec ( num ) { var nibble = 0 ; if ( 0 == num ) return num_to_bits [ 0 ] ; nibble = num & 0xf ; return num_to_bits [ nibble ] + countSetBitsRec ( num >> 4 ) ; }
Ref: 
int countSetBitsRec ( unsigned int num ) { int nibble = 0 ; if ( 0 == num ) return num_to_bits [ 0 ] ; nibble = num & 0xf ; return num_to_bits [ nibble ] + countSetBitsRec ( num >> 4 ) ; }
Hyp: 
int countSetBitsRec ( int num ) { int nibble = 0 ; if ( 0 == num ) return num_to_bits [ 0 ] ; nibble = num & 0xf ; return num_to_bits [ nibble ] + countSetBitsRec ( num >> 4 ) ; }

BLEU: 94.28
Edit Sim: 9


Src: 
function Substring ( s ) { var ans = 1 , temp = 1 ; for ( var i = 1 ; i < s . length ; i ++ ) { if ( s [ i ] == s [ i - 1 ] ) { ++ temp ; } else { ans = Math . max ( ans , temp ) ; temp = 1 ; } } ans = Math . max ( ans , temp ) ; return ans ; }
Ref: 
int Substring ( string s ) { int ans = 1 , temp = 1 ; for ( int i = 1 ; i < s . size ( ) ; i ++ ) { if ( s [ i ] == s [ i - 1 ] ) { ++ temp ; } else { ans = max ( ans , temp ) ; temp = 1 ; } } ans = max ( ans , temp ) ; return ans ; }
Hyp: 
int Substring ( string s ) { int ans = 1 , temp = 1 ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] == s [ i - 1 ] ) { ++ temp ; } else { ans = max ( ans , temp ) ; temp = 1 ; } } ans = max ( ans , temp ) ; return ans ; }

BLEU: 96.98
Edit Sim: 6


Src: 
function numberOfTriangles ( n ) { var ans = 2 * ( Math . pow ( 3 , n ) ) - 1 ; return ans ; }
Ref: 
int numberOfTriangles ( int n ) { int ans = 2 * ( pow ( 3 , n ) ) - 1 ; return ans ; }
Hyp: 
int numberOfTriangles ( int n ) { int ans = 2 * ( pow ( 3 , n ) ) - 1 ; return ans ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countNum ( n ) { if ( n == 1 ) return 1 ; let count = Math . pow ( 2 , n - 2 ) ; return count ; }
Ref: 
int countNum ( int n ) { if ( n == 1 ) return 1 ; int count = pow ( 2 , n - 2 ) ; return count ; }
Hyp: 
int countNum ( int n ) { if ( n == 1 ) return 1 ; int count = pow ( 2 , n - 2 ) ; return count ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function solve ( A , B ) { let p = B / 2.0 ; let M = Math . ceil ( 4 * p ) ; let N = 1 ; let O = - 2 * A ; let Q = Math . ceil ( A * A + 4 * p * p ) ; document . write ( M + " " + N + " " + O + " " + Q ) ; }
Ref: 
void solve ( int A , int B ) { double p = B / 2.0 ; int M = ceil ( 4 * p ) ; int N = 1 ; int O = - 2 * A ; int Q = ceil ( A * A + 4 * p * p ) ; cout << M << " ▁ " << N << " ▁ " << O << " ▁ " << Q ; }
Hyp: 
void solve ( int A , int B ) { float p = B / 2.0 ; float M = ceil ( 4 * p ) ; int N = 1 ; int O = -2 * A ; float Q = ceil ( A * A + 4 * p * p ) ; cout << M << " ▁ " << N << " ▁ " << O << " ▁ " << Q ; }

BLEU: 85.7
Edit Sim: 15


Src: 
function smallSumSubset ( data , target , maxVal ) { let sum = 0 ; for ( let i = 0 ; i < data . length ; i ++ ) sum += data [ i ] ; if ( target <= 0 ) return 0 ; else if ( sum < target ) return maxVal ; else if ( sum == target ) return data . length ; else if ( data [ 0 ] >= target ) return 1 ; else if ( data [ 0 ] < target ) { let temp = [ ] ; for ( let i = 1 ; i < data . length ; i ++ ) temp . push ( data [ i ] ) ; return Math . min ( smallSumSubset ( temp , target , maxVal ) , 1 + smallSumSubset ( temp , target - data [ 0 ] , maxVal ) ) ; } }
Ref: 
int smallSumSubset ( vector < int > data , int target , int maxVal ) { int sum = 0 ; for ( int i : data ) sum += i ; if ( target <= 0 ) return 0 ; else if ( sum < target ) return maxVal ; else if ( sum == target ) return data . size ( ) ; else if ( data [ 0 ] >= target ) return 1 ; else if ( data [ 0 ] < target ) { vector < int > temp ; for ( int i = 1 ; i < data . size ( ) ; i ++ ) temp . push_back ( data [ i ] ) ; return min ( smallSumSubset ( temp , target , maxVal ) , 1 + smallSumSubset ( temp , target - data [ 0 ] , maxVal ) ) ; } }
Hyp: 
int smallSumSubset ( vector < int > & data , int target , int maxVal ) { int sum = 0 ; for ( int i = 0 ; i < data . size ( ) ; i ++ ) sum += data [ i ] ; if ( target <= 0 ) return 0 ; else if ( sum < target ) return maxVal ; else if ( sum == target ) return data . size ( ) ; else if ( data [ 0 ] >= target ) return 1 ; else if ( data [ 0 ] < target ) { vector < int > temp ; for ( int i = 1 ; i < data . size ( ) ; i ++ ) temp . push_back ( data [ i ] ) ; return min ( smallSumSubset ( temp , target , maxVal ) , 1 + smallSumSubset ( temp , target - data [ 0 ] , maxVal ) ) ; } }

BLEU: 86.89
Edit Sim: 38


Src: 
function printFourSquares ( a ) { for ( let i = 0 ; i * i <= a ; i ++ ) { for ( let j = i ; j * j <= a ; j ++ ) { for ( let k = j ; k * k <= a ; k ++ ) { for ( let l = k ; l * l <= a ; l ++ ) { if ( i * i + j * j + k * k + l * l == a ) { document . write ( a + " " + i + " " + i + " " + j + " " + j + " " ) ; document . write ( k + " " + k + " " + l + " " + l + " " ) ; } } } } } }
Ref: 
void printFourSquares ( int a ) { for ( int i = 0 ; i * i <= a ; i ++ ) { for ( int j = i ; j * j <= a ; j ++ ) { for ( int k = j ; k * k <= a ; k ++ ) { for ( int l = k ; l * l <= a ; l ++ ) { if ( i * i + j * j + k * k + l * l == a ) { cout << a << " ▁ = ▁ " << i << " * " << i << " ▁ + ▁ " << j << " * " << j << " ▁ + ▁ " ; cout << k << " * " << k << " ▁ + ▁ " << l << " * " << l << " STRNEWLINE " ; } } } } } }
Hyp: 
void printFourSquares ( int a ) { for ( int i = 0 ; i * i <= a ; i ++ ) { for ( int j = i ; j * j <= a ; j ++ ) { for ( int k = j ; k * k <= a ; k ++ ) { for ( int l = k ; l * l <= a ; l ++ ) { if ( i * i + j * j + k * k + l * l == a ) { cout << a << " ▁ " << i << " ^ 2 ▁ + ▁ " << j << " ^ 2" << k << " ^ 2" << l << " ^ 2" << endl ; } } } } } } }

BLEU: 72.18
Edit Sim: 82


Src: 
function Cel_To_Fah ( n ) { return ( ( n * 9.0 / 5.0 ) + 32.0 ) ; }
Ref: 
float Cel_To_Fah ( float n ) { return ( ( n * 9.0 / 5.0 ) + 32.0 ) ; }
Hyp: 
double Cel_To_Fah ( double n ) { return ( ( n * 9.0 / 5.0 ) + 32.0 ) ; }

BLEU: 83.76
Edit Sim: 12


Src: 
function centered_cube ( n ) { return ( 2 * n + 1 ) * ( n * n + n + 1 ) ; }
Ref: 
int centered_cube ( int n ) { return ( 2 * n + 1 ) * ( n * n + n + 1 ) ; }
Hyp: 
int centered_cube ( int n ) { return ( 2 * n + 1 ) * ( n * n + n + 1 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function check ( s , m ) { let l = s . length ; let c1 = 0 ; let c2 = 0 ; for ( let i = 0 ; i < l ; i ++ ) { if ( s [ i ] == ' ' ) { c2 = 0 ; c1 ++ ; } else { c1 = 0 ; c2 ++ ; } if ( c1 == m c2 == m ) return true ; } return false ; }
Ref: 
bool check ( string s , int m ) { int l = s . length ( ) ; int c1 = 0 ; int c2 = 0 ; for ( int i = 0 ; i < l ; i ++ ) { if ( s [ i ] == '0' ) { c2 = 0 ; c1 ++ ; } else { c1 = 0 ; c2 ++ ; } if ( c1 == m c2 == m ) return true ; } return false ; }
Hyp: 
bool check ( string s , int m ) { int l = s . length ( ) ; int c1 = 0 ; int c2 = 0 ; for ( int i = 0 ; i < l ; i ++ ) { if ( s [ i ] == '0' ) { c2 = 0 ; c1 ++ ; } else { c1 = 0 ; c2 ++ ; } if ( c1 == m c2 == m ) return true ; } return false ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function getMinOps ( arr ) { let ans = 0 ; for ( let i = 0 ; i < arr . length - 1 ; i ++ ) { ans += Math . max ( arr [ i ] - arr [ i + 1 ] , 0 ) ; } return ans ; }
Ref: 
int getMinOps ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { ans += max ( arr [ i ] - arr [ i + 1 ] , 0 ) ; } return ans ; }
Hyp: 
int getMinOps ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { ans += max ( arr [ i ] - arr [ i + 1 ] , 0 ) ; } return ans ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function CalPeri ( ) { var S = 5 , Perimeter ; Perimeter = 10 * S ; document . write ( " " + Perimeter ) ; }
Ref: 
void CalPeri ( ) { int s = 5 , Perimeter ; Perimeter = 10 * s ; cout << " The ▁ Perimeter ▁ of ▁ Decagon ▁ is ▁ : ▁ " << Perimeter ; }
Hyp: 
void CalPeri ( int S ) { int Perimeter = 10 * S ; Perimeter = 10 * Perimeter ; cout << " The ▁ perimeter ▁ of ▁ the ▁ circle ▁ is ▁ " << Perimeter ; }

BLEU: 46.54
Edit Sim: 43


Src: 
function canMadeEqual ( A , B , n ) { A . sort ( ) ; B . sort ( ) ; for ( var i = 0 ; i < n ; i ++ ) if ( A [ i ] != B [ i ] ) return false ; return true ; }
Ref: 
bool canMadeEqual ( int A [ ] , int B [ ] , int n ) { sort ( A , A + n ) ; sort ( B , B + n ) ; for ( int i = 0 ; i < n ; i ++ ) if ( A [ i ] != B [ i ] ) return false ; return true ; }
Hyp: 
bool canMadeEqual ( int A [ ] , int B [ ] , int n ) { sort ( A , A + n ) ; sort ( B , B + n ) ; for ( int i = 0 ; i < n ; i ++ ) if ( A [ i ] != B [ i ] ) return false ; return true ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function binomialCoeff ( n , k ) { var C = Array . from ( Array ( n + 1 ) , ( ) => Array ( k + 1 ) ) ; var i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= Math . min ( i , k ) ; j ++ ) { if ( j == 0 j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } return C [ n ] [ k ] ; }
Ref: 
int binomialCoeff ( int n , int k ) { int C [ n + 1 ] [ k + 1 ] ; int i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= min ( i , k ) ; j ++ ) { if ( j == 0 j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } return C [ n ] [ k ] ; }
Hyp: 
int binomialCoeff ( int n , int k ) { int C [ n + 1 ] [ k + 1 ] ; int i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= min ( i , k ) ; j ++ ) { if ( j == 0 j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } return C [ n ] [ k ] ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function calculate ( P , Q ) { let mod = 998244353 , expo ; expo = mod - 2 ; p = 748683265 ; while ( expo != 0 ) { if ( ( expo & 1 ) == 1 ) { P = ( P * Q ) % mod ; } Q = ( Q * Q ) % mod ; expo >>= 1 ; } return p ; }
Ref: 
long calculate ( long long p , long long q ) { long long mod = 998244353 , expo ; expo = mod - 2 ; while ( expo ) { if ( expo & 1 ) { p = ( p * q ) % mod ; } q = ( q * q ) % mod ; expo >>= 1 ; } return p ; }
Hyp: 
int calculate ( long long int P , long long int Q ) { int mod = 998244353 , expo ; expo = mod - 2 ; p = 748683265 ; while ( expo != 0 ) { if ( ( expo & 1 ) == 1 ) { P = ( P * Q ) % mod ; } Q = ( Q * Q ) % mod ; expo >>= 1 ; } return p ; }

BLEU: 51.89
Edit Sim: 55


Src: 
function findNumberOfStrings ( n ) { let DP = new Array ( n + 1 ) ; for ( var i = 0 ; i < DP . length ; i ++ ) { DP [ i ] = new Array ( 2 ) ; } for ( var i = 0 ; i < DP . length ; i ++ ) { for ( var j = 0 ; j < DP . length ; j ++ ) { DP [ i ] [ j ] = 0 ; } } DP [ 1 ] [ 1 ] = 1 ; for ( let i = 1 ; i < n + 1 ; i ++ ) { for ( let j = 1 ; j < 6 ; j ++ ) { if ( i == 1 ) { DP [ i ] [ j ] = DP [ i ] [ j - 1 ] + 1 ; } else { DP [ i ] [ j ] = DP [ i ] [ j - 1 ] + DP [ i - 1 ] [ j ] ; } } } return DP [ n ] [ 5 ] ; }
Ref: 
int findNumberOfStrings ( int n ) { vector < vector < int > > DP ( n + 1 , vector < int > ( 6 ) ) ; DP [ 1 ] [ 1 ] = 1 ; for ( int i = 1 ; i < n + 1 ; i ++ ) { for ( int j = 1 ; j < 6 ; j ++ ) { if ( i == 1 ) { DP [ i ] [ j ] = DP [ i ] [ j - 1 ] + 1 ; } else { DP [ i ] [ j ] = DP [ i ] [ j - 1 ] + DP [ i - 1 ] [ j ] ; } } } return DP [ n ] [ 5 ] ; }
Hyp: 
int findNumberOfStrings ( int n ) { int DP [ n + 1 ] [ 6 ] ; memset ( DP , 0 , sizeof DP ) ; for ( int i = 0 ; i < DP . size ( ) ; i ++ ) { for ( int j = 0 ; j < DP . size ( ) ; j ++ ) { DP [ i ] [ j ] = 0 ; } } DP [ 1 ] [ 1 ] = 1 ; for ( int i = 1 ; i < n + 1 ; i ++ ) { for ( int j = 1 ; j < 6 ; j ++ ) { if ( i == 1 ) { DP [ i ] [ j ] = DP [ i ] [ j - 1 ] + 1 ; } else { DP [ i ] [ j ] = DP [ i ] [ j - 1 ] + DP [ i - 1 ] [ j ] ; } } return DP [ n ] [ 5 ] ; }

BLEU: 64.22
Edit Sim: 137


Src: 
function numberOfGP ( L , N ) { if ( N <= 2 ) return 0 ; let count = 0 ; let res = 0 ; for ( let i = 2 ; i < N ; ++ i ) { if ( L [ i - 1 ] * L [ i - 1 ] == L [ i ] * L [ i - 2 ] ) { ++ count ; } else { count = 0 ; } res += count ; } return res ; }
Ref: 
int numberOfGP ( int L [ ] , int N ) { if ( N <= 2 ) return 0 ; int count = 0 ; int res = 0 ; for ( int i = 2 ; i < N ; ++ i ) { if ( L [ i - 1 ] * L [ i - 1 ] == L [ i ] * L [ i - 2 ] ) { ++ count ; } else { count = 0 ; } res += count ; } return res ; }
Hyp: 
int numberOfGP ( int L [ ] , int N ) { if ( N <= 2 ) return 0 ; int count = 0 ; int res = 0 ; for ( int i = 2 ; i < N ; ++ i ) { if ( L [ i - 1 ] * L [ i - 1 ] == L [ i ] * L [ i - 2 ] ) { ++ count ; } else { count = 0 ; } res += count ; } return res ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function toggleBits ( n1 , n2 ) { return ( n1 ^ n2 ) ; }
Ref: 
int toggleBits ( int n1 , int n2 ) { return n1 ^ n2 ; }
Hyp: 
int toggleBits ( int n1 , int n2 ) { return ( n1 ^ n2 ) ; }

BLEU: 70.94
Edit Sim: 4


Src: 
function setBitNumber ( n ) { let k = parseInt ( Math . log ( n ) / Math . log ( 2 ) , 10 ) ; return 1 << k ; }
Ref: 
int setBitNumber ( int n ) { int k = ( int ) ( log2 ( n ) ) ; return 1 << k ; }
Hyp: 
int setBitNumber ( int n ) { int k = log2 ( n ) ; return 1 << k ; }

BLEU: 69.26
Edit Sim: 12


Src: 
function isTwoAlter ( s ) { for ( let i = 0 ; i < s . length - 2 ; i ++ ) { if ( s [ i ] != s [ i + 2 ] ) { return false ; } } if ( s [ 0 ] == s [ 1 ] ) return false ; return true ; }
Ref: 
bool isTwoAlter ( string s ) { for ( int i = 0 ; i < s . length ( ) - 2 ; i ++ ) { if ( s [ i ] != s [ i + 2 ] ) { return false ; } } if ( s [ 0 ] == s [ 1 ] ) return false ; return true ; }
Hyp: 
bool isTwoAlter ( string s ) { for ( int i = 0 ; i < s . length ( ) - 2 ; i ++ ) { if ( s [ i ] != s [ i + 2 ] ) { return false ; } } if ( s [ 0 ] == s [ 1 ] ) return false ; return true ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function Colour_Combination ( s ) { let temp = s [ 0 ] ; for ( let i = 1 ; i < s . length ; i ++ ) { if ( temp != s [ i ] ) { if ( ( temp == ' ' temp == ' ' ) && ( s [ i ] == ' ' s [ i ] == ' ' ) ) temp = ' ' ; else if ( ( temp == ' ' temp == ' ' ) && ( s [ i ] == ' ' s [ i ] == ' ' ) ) temp = ' ' ; else temp = ' ' ; } } return temp ; }
Ref: 
char Colour_Combination ( string s ) { char temp = s [ 0 ] ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) { if ( temp != s [ i ] ) { if ( ( temp == ' B ' temp == ' G ' ) && ( s [ i ] == ' G ' s [ i ] == ' B ' ) ) temp = ' Y ' ; else if ( ( temp == ' B ' temp == ' Y ' ) && ( s [ i ] == ' Y ' s [ i ] == ' B ' ) ) temp = ' G ' ; else temp = ' B ' ; } } return temp ; }
Hyp: 
char Colour_Combination ( string s ) { char temp = s [ 0 ] ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) { if ( temp != s [ i ] ) { if ( ( temp == '2' temp == '3' ) && ( s [ i ] == '5' s [ i ] == '6' ) ) temp = '7' ; else if ( ( temp == '3' temp == '5' ) && ( s [ i ] == '6' s [ i ] == '7' s [ i ] == '9' ) ) temp = '9' ; else temp = '10' ; } } return temp ; }

BLEU: 63.22
Edit Sim: 44


Src: 
function countWays ( n ) { var a = 1 , b = 2 , c = 4 ; var d = 0 ; if ( n == 0 n == 1 n == 2 ) return n ; if ( n == 3 ) return c ; for ( var i = 4 ; i <= n ; i ++ ) { d = c + b + a ; a = b ; b = c ; c = d ; } return d ; }
Ref: 
int countWays ( int n ) { int a = 1 , b = 2 , c = 4 ; int d = 0 ; if ( n == 0 n == 1 n == 2 ) return n ; if ( n == 3 ) return c ; for ( int i = 4 ; i <= n ; i ++ ) { d = c + b + a ; a = b ; b = c ; c = d ; } return d ; }
Hyp: 
int countWays ( int n ) { int a = 1 , b = 2 , c = 4 ; int d = 0 ; if ( n == 0 n == 1 n == 2 ) return n ; if ( n == 3 ) return c ; for ( int i = 4 ; i <= n ; i ++ ) { d = c + b + a ; a = b ; b = c ; c = d ; } return d ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function MinimumOperations ( A , N , K ) { let Count = 0 ; let i = 0 ; while ( i < N - 1 ) { i = i + K - 1 ; Count ++ ; } return Count ; }
Ref: 
int MinimumOperations ( int A [ ] , int N , int K ) { int Count = 0 ; int i = 0 ; while ( i < N - 1 ) { i = i + K - 1 ; Count ++ ; } return Count ; }
Hyp: 
int MinimumOperations ( int A [ ] , int N , int K ) { int Count = 0 ; int i = 0 ; while ( i < N - 1 ) { i = i + K - 1 ; Count ++ ; } return Count ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function isIdentity ( mat , N ) { for ( let row = 0 ; row < N ; row ++ ) { for ( let col = 0 ; col < N ; col ++ ) { if ( row == col && mat [ row ] [ col ] != 1 ) return false ; else if ( row != col && mat [ row ] [ col ] != 0 ) return false ; } } return true ; }
Ref: 
bool isIdentity ( int mat [ ] [ MAX ] , int N ) { for ( int row = 0 ; row < N ; row ++ ) { for ( int col = 0 ; col < N ; col ++ ) { if ( row == col && mat [ row ] [ col ] != 1 ) return false ; else if ( row != col && mat [ row ] [ col ] != 0 ) return false ; } } return true ; }
Hyp: 
bool isIdentity ( int mat [ ] [ MAX ] , int N ) { for ( int row = 0 ; row < N ; row ++ ) { for ( int col = 0 ; col < N ; col ++ ) { if ( row == col && mat [ row ] [ col ] != 1 ) return false ; else if ( row != col && mat [ row ] [ col ] != 0 ) return false ; } } return true ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function performQueries ( n , q , k , arr , query ) { = for ( let i = 1 ; i <= q ; i ++ ) { let count = 0 ; if ( query [ i - 1 ] [ 0 ] == 1 ) { for ( let j = query [ i - 1 ] [ 1 ] ; j <= query [ i - 1 ] [ 2 ] ; j ++ ) { if ( arr [ j ] == k ) count ++ ; } document . write ( count + " " ) ; } else { arr [ query [ i - 1 ] [ 1 ] ] = query [ i - 1 ] [ 2 ] ; } } }
Ref: 
void performQueries ( int n , int q , int k , vector < int > & arr , vector < vector < int > > & query ) { for ( int i = 1 ; i <= q ; i ++ ) { int count = 0 ; if ( query [ i - 1 ] [ 0 ] == 1 ) { for ( int j = query [ i - 1 ] [ 1 ] ; j <= query [ i - 1 ] [ 2 ] ; j ++ ) { if ( arr [ j ] == k ) count ++ ; } cout << count << endl ; } else { = arr [ query [ i - 1 ] [ 1 ] ] = query [ i - 1 ] [ 2 ] ; } } }
Hyp: 
void performQueries ( int n , int q , int k , int arr [ ] , int query [ ] [ 3 ] ) { for ( int i = 1 ; i <= q ; i ++ ) { int count = 0 ; if ( query [ i - 1 ] [ 0 ] == 1 ) { for ( int j = query [ i - 1 ] [ 1 ] ; j <= query [ i - 1 ] [ 2 ] ; j ++ ) { if ( arr [ j ] == k ) count ++ ; } cout << count << " ▁ " ; } else { arr [ query [ i - 1 ] [ 1 ] ] = query [ i - 1 ] [ 2 ] ; } } }

BLEU: 85.17
Edit Sim: 46


Src: 
function minSwaps ( N , M , A , B ) { let count01 = 0 ; let count10 = 0 ; for ( let i = 0 ; i < N ; i ++ ) { for ( let j = 0 ; j < M ; j ++ ) { if ( A [ i ] [ j ] != B [ i ] [ j ] ) { if ( A [ i ] [ j ] == 1 ) count10 ++ ; else count01 ++ ; } } } if ( count01 == count10 ) return count01 ; else return - 1 ; }
Ref: 
int minSwaps ( int N , int M , vector < vector < int > > & A , vector < vector < int > > & B ) { int count01 = 0 ; int count10 = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { if ( A [ i ] [ j ] != B [ i ] [ j ] ) { if ( A [ i ] [ j ] == 1 ) count10 ++ ; else count01 ++ ; } } } if ( count01 == count10 ) return count01 ; else return -1 ; }
Hyp: 
int minSwaps ( int N , int M , int A [ ] [ MAX ] , int B [ ] [ MAX ] ) { int count01 = 0 ; int count10 = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { if ( A [ i ] [ j ] != B [ i ] [ j ] ) { if ( A [ i ] [ j ] == 1 ) count10 ++ ; else count01 ++ ; } } } if ( count01 == count10 ) return count01 ; else return -1 ; }

BLEU: 84.44
Edit Sim: 44


Src: 
function cntSquares ( n ) { return n * ( n + 1 ) * ( 2 * n + 1 ) / 6 ; }
Ref: 
int cnt_squares ( int n ) { return n * ( n + 1 ) * ( 2 * n + 1 ) / 6 ; }
Hyp: 
int cntSquares ( int n ) { return n * ( n + 1 ) * ( 2 * n + 1 ) / 6 ; }

BLEU: 93.32
Edit Sim: 2


Src: 
function solution ( A , B , C ) { let arr = Array . from ( { length : 3 } , ( _ , i ) => 0 ) ; arr [ 0 ] = A ; arr [ 1 ] = B ; arr [ 2 ] = C ; arr . sort ( ) ; if ( arr [ 2 ] < arr [ 0 ] + arr [ 1 ] ) return ( ( arr [ 0 ] + arr [ 1 ] + arr [ 2 ] ) / 2 ) ; else return ( arr [ 0 ] + arr [ 1 ] ) ; }
Ref: 
int solution ( int A , int B , int C ) { int arr [ 3 ] ; arr [ 0 ] = A , arr [ 1 ] = B , arr [ 2 ] = C ; sort ( arr , arr + 3 ) ; if ( arr [ 2 ] < arr [ 0 ] + arr [ 1 ] ) return ( ( arr [ 0 ] + arr [ 1 ] + arr [ 2 ] ) / 2 ) ; else return ( arr [ 0 ] + arr [ 1 ] ) ; }
Hyp: 
int solution ( int A , int B , int C ) { int arr [ 3 ] ; arr [ 0 ] = A ; arr [ 1 ] = B ; arr [ 2 ] = C ; sort ( arr , arr + 3 ) ; if ( arr [ 2 ] < arr [ 0 ] + arr [ 1 ] ) return ( ( arr [ 0 ] + arr [ 1 ] + arr [ 2 ] ) / 2 ) ; else return ( arr [ 0 ] + arr [ 1 ] ) ; }

BLEU: 95.07
Edit Sim: 2


Src: 
function transpose ( A , B ) { var i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < M ; j ++ ) B [ i ] [ j ] = A [ j ] [ i ] ; } var A = [ [ 1 , 1 , 1 , 1 ] , [ 2 , 2 , 2 , 2 ] , [ 3 , 3 , 3 , 3 ] ] ; var B = Array ( N ) ; for ( i = 0 ; i < N ; i ++ ) B [ i ] = Array ( M ) . fill ( 0 ) ; transpose ( A , B ) ; document . write ( " " ) ; for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < M ; j ++ ) document . write ( B [ i ] [ j ] + " " ) ; document . write ( " " ) ; }
Ref: 
void transpose ( int A [ ] [ N ] , int B [ ] [ M ] ) { int i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < M ; j ++ ) B [ i ] [ j ] = A [ j ] [ i ] ; }
Hyp: 
void transpose ( int A [ ] [ M ] , int B [ N ] [ M ] ) { int i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < M ; j ++ ) B [ i ] [ j ] = A [ j ] [ i ] ; }

BLEU: 94.4
Edit Sim: 3


Src: 
function printFibonacciNumbers ( n ) { let f1 = 0 , f2 = 1 , i ; if ( n < 1 ) return ; document . write ( f1 + " " ) ; for ( i = 1 ; i < n ; i ++ ) { document . write ( f2 + " " ) ; let next = f1 + f2 ; f1 = f2 ; f2 = next ; } }
Ref: 
void printFibonacciNumbers ( int n ) { int f1 = 0 , f2 = 1 , i ; if ( n < 1 ) return ; cout << f1 << " ▁ " ; for ( i = 1 ; i < n ; i ++ ) { cout << f2 << " ▁ " ; int next = f1 + f2 ; f1 = f2 ; f2 = next ; } }
Hyp: 
void printFibonacciNumbers ( int n ) { int f1 = 0 , f2 = 1 , i ; if ( n < 1 ) return ; cout << f1 << " ▁ " ; for ( i = 1 ; i < n ; i ++ ) { cout << f2 << " ▁ " ; int next = f1 + f2 ; f1 = f2 ; f2 = next ; } }

BLEU: 100.0
Edit Sim: 0


Src: 
function findPosition ( n ) { var i = 0 ; var pos = 0 ; while ( n > 0 ) { if ( n % 10 == 7 ) { pos = pos + parseInt ( Math . pow ( 2 , i + 1 ) ) ; } else { pos = pos + parseInt ( Math . pow ( 2 , i ) ) ; } i ++ ; n = parseInt ( n / 10 ) ; } document . write ( pos ) ; }
Ref: 
void findPosition ( int n ) { int i = 0 ; int pos = 0 ; while ( n > 0 ) { if ( n % 10 == 7 ) { pos = pos + pow ( 2 , i + 1 ) ; } else { pos = pos + pow ( 2 , i ) ; } i ++ ; n = n / 10 ; } cout << pos ; }
Hyp: 
void findPosition ( int n ) { int i = 0 ; int pos = 0 ; while ( n > 0 ) { if ( n % 10 == 7 ) { pos = pos + pow ( 2 , i + 1 ) ; } else { pos = pos + pow ( 2 , i ) ; } i ++ ; n = n / 10 ; } cout << pos ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function Pentadecagonal_num ( n ) { return ( 13 * n * n - 11 * n ) / 2 ; }
Ref: 
int Pentadecagonal_num ( int n ) { return ( 13 * n * n - 11 * n ) / 2 ; }
Hyp: 
int Pentadecagonal_num ( long int n ) { return ( 13 * n * n - 11 * n ) / 2 ; }

BLEU: 88.95
Edit Sim: 5


Src: 
function maxNumTrailNine ( n , d ) { let res = n ; let cntDigits = parseInt ( Math . log ( n ) / Math . log ( 10 ) ) + 1 ; let p10 = 10 ; for ( let i = 1 ; i <= cntDigits ; i ++ ) { if ( n % p10 >= d ) { break ; } else { res = n - n % p10 - 1 ; } p10 = p10 * 10 ; } document . write ( res ) ; }
Ref: 
void maxNumTrailNine ( int n , int d ) { int res = n ; int cntDigits = log10 ( n ) + 1 ; int p10 = 10 ; for ( int i = 1 ; i <= cntDigits ; i ++ ) { if ( n % p10 >= d ) { break ; } else { res = n - n % p10 - 1 ; } p10 = p10 * 10 ; } cout << res ; }
Hyp: 
void maxNumTrailNine ( int n , int d ) { int res = n ; int cntDigits = log10 ( n ) + 1 ; int p10 = 10 ; for ( int i = 1 ; i <= cntDigits ; i ++ ) { if ( n % p10 >= d ) { break ; } else { res = n - n % p10 - 1 ; } p10 = p10 * 10 ; } cout << res ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findS ( s ) { let sum = 0 ; for ( let n = 1 ; sum < s ; n ++ ) { sum += n * n * n ; if ( sum == s ) return n ; } return - 1 ; }
Ref: 
int findS ( int s ) { int sum = 0 ; for ( int n = 1 ; sum < s ; n ++ ) { sum += n * n * n ; if ( sum == s ) return n ; } return -1 ; }
Hyp: 
int findS ( int s ) { int sum = 0 ; for ( int n = 1 ; sum < s ; n ++ ) { sum += n * n * n ; if ( sum == s ) return n ; } return -1 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function otherEndPoint ( x1 , y1 , m1 , m2 ) { let x2 = 2 * m1 - x1 ; let y2 = 2 * m2 - y1 ; document . write ( " " + x2 + " " + " " + y2 ) ; }
Ref: 
void otherEndPoint ( int x1 , int y1 , int m1 , int m2 ) { float x2 = ( float ) ( 2 * m1 - x1 ) ; float y2 = ( float ) ( 2 * m2 - y1 ) ; cout << " x2 ▁ = ▁ " << x2 << " , ▁ " << " y2 ▁ = ▁ " << y2 ; }
Hyp: 
void otherEndPoint ( int x1 , int y1 , int m1 , int m2 ) { int x2 = 2 * m1 - x1 ; int y2 = 2 * m2 - y1 ; cout << " x2 ▁ = ▁ " << x2 << " , ▁ y2 ▁ = ▁ " << y2 << endl ; }

BLEU: 61.6
Edit Sim: 51


Src: 
function maxSubarrayProduct ( arr , n ) { let result = arr [ 0 ] ; for ( let i = 0 ; i < n ; i ++ ) { let mul = arr [ i ] ; for ( let j = i + 1 ; j < n ; j ++ ) { result = Math . max ( result , mul ) ; mul *= arr [ j ] ; } result = Math . max ( result , mul ) ; } return result ; }
Ref: 
int maxSubarrayProduct ( int arr [ ] , int n ) { int result = arr [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { int mul = arr [ i ] ; for ( int j = i + 1 ; j < n ; j ++ ) { result = max ( result , mul ) ; mul *= arr [ j ] ; } result = max ( result , mul ) ; } return result ; }
Hyp: 
int maxSubarrayProduct ( int arr [ ] , int n ) { int result = arr [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { int mul = arr [ i ] ; for ( int j = i + 1 ; j < n ; j ++ ) { result = max ( result , mul ) ; mul *= arr [ j ] ; } result = max ( result , mul ) ; } return result ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function no_of_digit ( a , b ) { return ( Math . round ( ( b * Math . log10 ( a ) ) + 1 ) ) ; }
Ref: 
int no_of_digit ( int a , int b ) { return ( ( int ) ( b * log10 ( a ) ) + 1 ) ; }
Hyp: 
int no_of_digit ( int a , int b ) { return ( round ( ( b * log10 ( a ) ) + 1 ) ) ; }

BLEU: 82.54
Edit Sim: 7


Src: 
function myCopy ( s1 , s2 ) { let i = 0 ; for ( i = 0 ; i < s1 . length ; i ++ ) s2 [ i ] = s1 [ i ] ; }
Ref: 
void myCopy ( char s1 [ ] , char s2 [ ] ) { int i = 0 ; for ( i = 0 ; s1 [ i ] != ' \0' ; i ++ ) s2 [ i ] = s1 [ i ] ; s2 [ i ] = ' \0' ; }
Hyp: 
void myCopy ( string s1 , string s2 ) { int i = 0 ; for ( i = 0 ; i < s1 . length ( ) ; i ++ ) s2 [ i ] = s1 [ i ] ; }

BLEU: 49.35
Edit Sim: 52


Src: 
function constructXOR ( A , n ) { let XOR = 0 ; for ( let i = 0 ; i < n ; i ++ ) XOR ^= A [ i ] ; for ( let i = 0 ; i < n ; i ++ ) A [ i ] = XOR ^ A [ i ] ; }
Ref: 
void constructXOR ( int A [ ] , int n ) { int XOR = 0 ; for ( int i = 0 ; i < n ; i ++ ) XOR ^= A [ i ] ; for ( int i = 0 ; i < n ; i ++ ) A [ i ] = XOR ^ A [ i ] ; }
Hyp: 
void constructXOR ( int A [ ] , int n ) { int XOR = 0 ; for ( int i = 0 ; i < n ; i ++ ) XOR ^= A [ i ] ; for ( int i = 0 ; i < n ; i ++ ) A [ i ] = XOR ^ A [ i ] ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function maxCountAB ( s , n ) { var A = 0 , B = 0 , BA = 0 , ans = 0 ; for ( var i = 0 ; i < n ; i ++ ) { var S = s [ i ] ; var L = S . length ; for ( var j = 0 ; j < L - 1 ; j ++ ) { if ( S [ j ] == ' ' && S [ j + 1 ] == ' ' ) { ans ++ ; } } if ( S [ 0 ] == ' ' && S [ L - 1 ] == ' ' ) BA ++ ; else if ( S [ 0 ] == ' ' ) B ++ ; else if ( S [ L - 1 ] == ' ' ) A ++ ; } if ( BA == 0 ) ans += Math . min ( B , A ) ; else if ( A + B == 0 ) ans += BA - 1 ; else ans += BA + Math . min ( B , A ) ; return ans ; }
Ref: 
int maxCountAB ( string s [ ] , int n ) { int A = 0 , B = 0 , BA = 0 , ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { string S = s [ i ] ; int L = S . size ( ) ; for ( int j = 0 ; j < L - 1 ; j ++ ) { if ( S . at ( j ) == ' A ' && S . at ( j + 1 ) == ' B ' ) { ans ++ ; } } if ( S . at ( 0 ) == ' B ' && S . at ( L - 1 ) == ' A ' ) BA ++ ; else if ( S . at ( 0 ) == ' B ' ) B ++ ; else if ( S . at ( L - 1 ) == ' A ' ) A ++ ; } if ( BA == 0 ) ans += min ( B , A ) ; else if ( A + B == 0 ) ans += BA - 1 ; else ans += BA + min ( B , A ) ; return ans ; }
Hyp: 
int maxCountAB ( string s , int n ) { int A = 0 , B = 0 , BA = 0 , ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { string S = s [ i ] ; int L = S . size ( ) ; for ( int j = 0 ; j < L - 1 ; j ++ ) { if ( S [ j ] == ' a ' && S [ j + 1 ] == ' b ' ) BA ++ ; else if ( S [ 0 ] == ' a ' ) B ++ ; else if ( S [ L - 1 ] == ' b ' ) A ++ ; } if ( BA == 0 ) ans += min ( B , A ) ; else if ( A + B == 0 ) ans += BA - 1 ; else ans += BA + min ( B , A ) ; return ans ; }

BLEU: 66.35
Edit Sim: 109


Src: 
function isCenteredheptagonal ( N ) { let n = ( 7 + Math . sqrt ( 56 * N - 7 ) ) / 14 ; return ( n - parseInt ( n ) ) == 0 ; } let n = 8 ; if ( isCenteredheptagonal ( n ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
Ref: 
bool isCenteredheptagonal ( int N ) { float n = ( 7 + sqrt ( 56 * N - 7 ) ) / 14 ; return ( n - ( int ) n ) == 0 ; }
Hyp: 
bool isCenteredheptagonal ( int N ) { float n = ( 7 + sqrt ( 56 * N - 7 ) ) / 14 ; return ( n - ( int ) n ) == 0 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function area ( a , b , c ) { var d = Math . abs ( ( c * c ) / ( 2 * a * b ) ) ; return d ; }
Ref: 
double area ( double a , double b , double c ) { double d = fabs ( ( c * c ) / ( 2 * a * b ) ) ; return d ; }
Hyp: 
float area ( float a , float b , float c ) { float d = abs ( ( c * c ) / ( 2 * a * b ) ) ; return d ; }

BLEU: 64.12
Edit Sim: 31


Src: 
function gonNum257 ( n ) { return ( 255 * n * n - 253 * n ) / 2 ; }
Ref: 
int gonNum257 ( int n ) { return ( 255 * n * n - 253 * n ) / 2 ; }
Hyp: 
int gonNum257 ( int n ) { return ( 255 * n * n - 253 * n ) / 2 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function number_of_digits ( n ) { let i , res , sum = 0 ; for ( i = 4 , res = 1 ; ; i *= 4 , res ++ ) { sum += i ; if ( sum >= n ) break ; } return res ; }
Ref: 
int number_of_digits ( int n ) { int i , res , sum = 0 ; for ( i = 4 , res = 1 ; ; i *= 4 , res ++ ) { sum += i ; if ( sum >= n ) break ; } return res ; }
Hyp: 
int number_of_digits ( int n ) { int i , res , sum = 0 ; for ( i = 4 , res = 1 ; ; i *= 4 , res ++ ) { sum += i ; if ( sum >= n ) break ; } return res ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function next ( arr , target ) { let start = 0 , end = arr . length - 1 ; let ans = - 1 ; while ( start <= end ) { let mid = parseInt ( ( start + end ) / 2 , 10 ) ; if ( arr [ mid ] <= target ) { start = mid + 1 ; } else { ans = mid ; end = mid - 1 ; } } return ans ; }
Ref: 
int next ( int arr [ ] , int target , int end ) { int start = 0 ; int ans = -1 ; while ( start <= end ) { int mid = ( start + end ) / 2 ; if ( arr [ mid ] <= target ) start = mid + 1 ; else { ans = mid ; end = mid - 1 ; } } return ans ; }
Hyp: 
int next ( int arr [ ] , int target ) { int start = 0 , end = arr . length ( ) - 1 ; int ans = -1 ; while ( start <= end ) { int mid = ( start + end ) / 2 ; if ( arr [ mid ] <= target ) { start = mid + 1 ; } else { ans = mid ; end = mid - 1 ; } } return ans ; }

BLEU: 78.95
Edit Sim: 35


Src: 
function minimumDiff ( arr , N ) { let res = arr [ 0 ] , sum = 0 ; for ( let i = 0 ; i < N ; i ++ ) sum += arr [ i ] ; let min_diff = sum ; for ( let i = 0 ; i < N ; i ++ ) { if ( Math . abs ( sum - ( arr [ i ] * N ) ) < min_diff ) { min_diff = Math . abs ( sum - ( arr [ i ] * N ) ) ; res = arr [ i ] ; } } document . write ( res ) ; }
Ref: 
int minimumDiff ( int arr [ ] , int N ) { int res = arr [ 0 ] , sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) sum += arr [ i ] ; int min_diff = sum ; for ( int i = 0 ; i < N ; i ++ ) { if ( abs ( sum - ( arr [ i ] * N ) ) < min_diff ) { min_diff = abs ( sum - ( arr [ i ] * N ) ) ; res = arr [ i ] ; } } cout << res ; }
Hyp: 
void minimumDiff ( int arr [ ] , int N ) { int res = arr [ 0 ] , sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) sum += arr [ i ] ; int min_diff = sum ; for ( int i = 0 ; i < N ; i ++ ) { if ( abs ( sum - ( arr [ i ] * N ) ) < min_diff ) { min_diff = abs ( sum - ( arr [ i ] * N ) ) ; res = arr [ i ] ; } } cout << res ; }

BLEU: 99.12
Edit Sim: 4


Src: 
function modularSum ( arr , n , m ) { if ( n > m ) return true ; let DP = new Array ( m ) ; for ( let l = 0 ; l < m ; l ++ ) DP [ l ] = false ; for ( let i = 0 ; i < n ; i ++ ) { if ( DP [ 0 ] ) return true ; let temp = new Array ( m ) ; for ( let l = 0 ; l < m ; l ++ ) temp [ l ] = false ; for ( let j = 0 ; j < m ; j ++ ) { if ( DP [ j ] == true ) { if ( DP [ ( j + arr [ i ] ) % m ] == false ) temp [ ( j + arr [ i ] ) % m ] = true ; } } for ( let j = 0 ; j < m ; j ++ ) if ( temp [ j ] ) DP [ j ] = true ; DP [ arr [ i ] % m ] = true ; } return DP [ 0 ] ; }
Ref: 
bool modularSum ( int arr [ ] , int n , int m ) { if ( n > m ) return true ; bool DP [ m ] ; memset ( DP , false , m ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( DP [ 0 ] ) return true ; bool temp [ m ] ; memset ( temp , false , m ) ; for ( int j = 0 ; j < m ; j ++ ) { if ( DP [ j ] == true ) { if ( DP [ ( j + arr [ i ] ) % m ] == false ) temp [ ( j + arr [ i ] ) % m ] = true ; } } for ( int j = 0 ; j < m ; j ++ ) if ( temp [ j ] ) DP [ j ] = true ; DP [ arr [ i ] % m ] = true ; } return DP [ 0 ] ; }
Hyp: 
bool modularSum ( int arr [ ] , int n , int m ) { if ( n > m ) return true ; bool DP [ m ] ; for ( int l = 0 ; l < m ; l ++ ) DP [ l ] = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( DP [ 0 ] ) return true ; bool temp [ m ] ; for ( int j = 0 ; j < m ; j ++ ) { if ( DP [ j ] == true ) { if ( DP [ ( j + arr [ i ] ) % m ] == false ) temp [ ( j + arr [ i ] ) % m ] = true ; } } for ( int j = 0 ; j < m ; j ++ ) if ( temp [ j ] ) DP [ j ] = true ; DP [ arr [ i ] % m ] = true ; } return DP [ 0 ] ; }

BLEU: 89.07
Edit Sim: 70


Src: 
function minIndex ( arr , n ) { var sum = 0 ; for ( i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; for ( i = 0 ; i < n ; i ++ ) { if ( 2 * arr [ i ] == sum ) return ( i + 1 ) ; } return - 1 ; }
Ref: 
int minIndex ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( 2 * arr [ i ] == sum ) return ( i + 1 ) ; } return -1 ; }
Hyp: 
int minIndex ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( 2 * arr [ i ] == sum ) return ( i + 1 ) ; } return -1 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function maxLen ( arr ) { let hM = new Map ( ) ; let sum = 0 ; let max_len = 0 ; for ( let i = 0 ; i < arr . length ; i ++ ) { sum += arr [ i ] ; if ( arr [ i ] == 0 && max_len == 0 ) max_len = 1 ; if ( sum == 0 ) max_len = i + 1 ; let prev_i = hM . get ( sum ) ; if ( prev_i != null ) max_len = Math . max ( max_len , i - prev_i ) ; else hM . set ( sum , i ) ; } return max_len ; }
Ref: 
int maxLen ( int arr [ ] , int n ) { unordered_map < int , int > presum ; int sum = 0 ; int max_len = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( arr [ i ] == 0 && max_len == 0 ) max_len = 1 ; if ( sum == 0 ) max_len = i + 1 ; if ( presum . find ( sum ) != presum . end ( ) ) { max_len = max ( max_len , i - presum [ sum ] ) ; } else { presum [ sum ] = i ; } } return max_len ; }
Hyp: 
int maxLen ( int arr [ ] , int n ) { unordered_map < int , int > hM ; int sum = 0 ; int max_len = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( arr [ i ] == 0 && max_len == 0 ) max_len = 1 ; if ( sum == 0 ) max_len = i + 1 ; int prev_i = hM [ sum ] ; if ( prev_i != null ) max_len = max ( max_len , i - prev_i ) ; else hM [ sum ] = i ; } return max_len ; }

BLEU: 76.61
Edit Sim: 61


Src: 
function getArea ( a ) { var area = ( Math . PI * a * a ) / 4 ; return area ; }
Ref: 
float getArea ( int a ) { float area = ( M_PI * a * a ) / 4.0 ; return area ; }
Hyp: 
double getArea ( double a ) { double area = ( PI * a * a ) / 4 ; return area ; }

BLEU: 49.34
Edit Sim: 22


Src: 
function multiplyWith4 ( n ) { return ( n << 2 ) ; }
Ref: 
int multiplyWith4 ( int n ) { return ( n << 2 ) ; }
Hyp: 
int multiplyWith4 ( int n ) { return ( n << 2 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function subtractOne ( x ) { let m = 1 ; while ( ! ( x & m ) ) { x = x ^ m ; m <<= 1 ; } x = x ^ m ; return x ; }
Ref: 
int subtractOne ( int x ) { int m = 1 ; while ( ! ( x & m ) ) { x = x ^ m ; m <<= 1 ; } x = x ^ m ; return x ; }
Hyp: 
int subtractOne ( int x ) { int m = 1 ; while ( ! ( x & m ) ) { x = x ^ m ; m <<= 1 ; } x = x ^ m ; return x ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findSum ( n ) { return ( n * ( n + 1 ) * ( n + 1 ) * ( n + 2 ) ) / 12 ; }
Ref: 
int findSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += ( ( i * ( i + 1 ) * ( 2 * i + 1 ) ) / 6 ) ; return sum ; }
Hyp: 
int findSum ( int n ) { return ( n * ( n + 1 ) * ( n + 1 ) * ( n + 2 ) ) / 12 ; }

BLEU: 22.74
Edit Sim: 69


Src: 
function printModulus ( X , Y ) { var d = Math . abs ( X - Y ) ; var i = 1 ; while ( i * i <= d ) { if ( d % i == 0 ) { document . write ( i + " " ) ; if ( d / i != i ) document . write ( parseInt ( d / i ) + " " ) ; } i ++ ; } }
Ref: 
void printModulus ( int X , int Y ) { int d = abs ( X - Y ) ; int i = 1 ; while ( i * i <= d ) { if ( d % i == 0 ) { cout << i << " ▁ " ; if ( d / i != i ) cout << d / i << " ▁ " ; } i ++ ; } }
Hyp: 
void printModulus ( int X , int Y ) { int d = abs ( X - Y ) ; int i = 1 ; while ( i * i <= d ) { if ( d % i == 0 ) { cout << i << " ▁ " ; if ( d / i != i ) cout << d / i << " ▁ " ; } i ++ ; } }

BLEU: 100.0
Edit Sim: 0


Src: 
function isUndulating ( n ) { if ( n . length <= 2 ) return false ; for ( let i = 2 ; i < n . length ; i ++ ) if ( n [ i - 2 ] != n [ i ] ) return false ; return true ; }
Ref: 
bool isUndulating ( string n ) { if ( n . length ( ) <= 2 ) return false ; for ( int i = 2 ; i < n . length ( ) ; i ++ ) if ( n [ i - 2 ] != n [ i ] ) false ; return true ; }
Hyp: 
bool isUndulating ( int n [ ] ) { if ( n . length ( ) <= 2 ) return false ; for ( int i = 2 ; i < n . length ( ) ; i ++ ) if ( n [ i - 2 ] != n [ i ] ) return false ; return true ; }

BLEU: 86.99
Edit Sim: 14


Src: 
function makeOdd ( n ) { if ( n % 2 != 0 ) return 1 ; var i ; for ( i = 2 ; i <= n ; i ++ ) if ( ( n % i == 0 ) && ( ( n / i ) % 2 == 1 ) ) break ; return i ; }
Ref: 
int makeOdd ( int n ) { if ( n % 2 != 0 ) return 1 ; for ( int i = 2 ; i <= n ; i ++ ) if ( ( n % i == 0 ) && ( ( n / i ) % 2 == 1 ) ) return i ; }
Hyp: 
int makeOdd ( int n ) { if ( n % 2 != 0 ) return 1 ; int i ; for ( i = 2 ; i <= n ; i ++ ) if ( ( n % i == 0 ) && ( ( n / i ) % 2 == 1 ) ) break ; return i ; }

BLEU: 86.27
Edit Sim: 19


Src: 
function findWinner ( A , n ) { let res = 0 ; for ( let i = 0 ; i < n ; i ++ ) res ^= A [ i ] ; if ( res == 0 n % 2 == 0 ) return " " ; else return " " ; }
Ref: 
string findWinner ( int A [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) res ^= A [ i ] ; if ( res == 0 n % 2 == 0 ) return " Alice " ; else return " Bob " ; }
Hyp: 
string findWinner ( int A [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) res ^= A [ i ] ; if ( res == 0 n % 2 == 0 ) return " A " ; else return " B " ; }

BLEU: 91.58
Edit Sim: 6


Src: 
function countTotalDistinct ( str ) { let cnt = 0 ; let items = new Set ( ) ; for ( let i = 0 ; i < str . length ; ++ i ) { let temp = " " ; let ans = new Set ( ) ; for ( let j = i ; j < str . length ; ++ j ) { temp = temp + str [ j ] ; ans . add ( str [ j ] ) ; if ( ! items . has ( temp ) ) { items . add ( temp ) ; cnt += ans . size ; } } } return cnt ; }
Ref: 
int countTotalDistinct ( string str ) { int cnt = 0 ; set < string > items ; for ( int i = 0 ; i < str . length ( ) ; ++ i ) { string temp = " " ; set < char > ans ; for ( int j = i ; j < str . length ( ) ; ++ j ) { temp = temp + str [ j ] ; ans . insert ( str [ j ] ) ; if ( items . find ( temp ) == items . end ( ) ) { items . insert ( temp ) ; cnt += ans . size ( ) ; } } } return cnt ; }
Hyp: 
int countTotalDistinct ( string str ) { int cnt = 0 ; unordered_set < string > items ; for ( int i = 0 ; i < str . length ( ) ; ++ i ) { string temp = " " ; unordered_set < string > ans ; for ( int j = i ; j < str . length ( ) ; ++ j ) { temp = temp + str [ j ] ; ans . insert ( str [ j ] ) ; if ( ! items . find ( temp ) ) { items . insert ( temp ) ; cnt += ans . size ( ) ; } } } return cnt ; }

BLEU: 87.78
Edit Sim: 47


Src: 
function canTakeDown ( bishopX , bishopY , pawnX , pawnY ) { if ( pawnX - bishopX == pawnY - bishopY ) return true ; else if ( - pawnX + bishopX == pawnY - bishopY ) return true ; else return false ; }
Ref: 
bool canTakeDown ( int bishopX , int bishopY , int pawnX , int pawnY ) { if ( pawnX - bishopX == pawnY - bishopY ) return true ; else if ( - pawnX + bishopX == pawnY - bishopY ) return true ; else return false ; }
Hyp: 
bool canTakeDown ( int bishopX , int bishopY , int pawnX , int pawnY ) { if ( pawnX - bishopX == pawnY - bishopY ) return true ; else if ( - pawnX + bishopX == pawnY - bishopY ) return true ; else return false ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function getMissingNo ( a , n ) { let n_elements_sum = Math . floor ( n * ( n + 1 ) / 2 ) ; let sum = 0 ; for ( let i = 0 ; i < n - 1 ; i ++ ) sum += a [ i ] ; return n_elements_sum - sum ; }
Ref: 
int getMissingNo ( int a [ ] , int n ) { int n_elements_sum = n * ( n + 1 ) / 2 ; int sum = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) sum += a [ i ] ; return n_elements_sum - sum ; }
Hyp: 
int getMissingNo ( int a [ ] , int n ) { int n_elements_sum = n * ( n + 1 ) / 2 ; int sum = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) sum += a [ i ] ; return n_elements_sum - sum ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function minXOR ( Arr , N ) { for ( let i = 0 ; i < N ; i ++ ) { if ( Arr [ i ] == 2 ) { document . write ( ( Arr [ i ] ^ 3 ) + " " ) ; } else { document . write ( ( Arr [ i ] ^ 2 ) + " " ) ; } } }
Ref: 
void minXOR ( vector < int > & Arr , int N ) { for ( int i = 0 ; i < N ; i ++ ) { if ( Arr [ i ] == 2 ) { cout << ( Arr [ i ] ^ 3 ) << " ▁ " ; } else { cout << ( Arr [ i ] ^ 2 ) << " ▁ " ; } } }
Hyp: 
void minXOR ( int Arr [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { if ( Arr [ i ] == 2 ) { cout << ( Arr [ i ] ^ 3 ) << " ▁ " ; } else { cout << ( Arr [ i ] ^ 2 ) << " ▁ " ; } } }

BLEU: 90.51
Edit Sim: 15


Src: 
function minimumTriangleArea ( a , b ) { var area = a * b console . log ( area ) }
Ref: 
void minimumTriangleArea ( int a , int b ) { int area = a * b ; cout << area ; }
Hyp: 
void minimumTriangleArea ( int a , int b ) { int area = a * b ; cout << area ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countPairs ( s ) { let st = new Set ( ) ; st . add ( ' ' ) ; st . add ( ' ' ) ; st . add ( ' ' ) ; st . add ( ' ' ) ; st . add ( ' ' ) ; let count = 0 ; let n = s . length ; for ( let i = 0 ; i < n - 1 ; i ++ ) { if ( st . has ( s [ i ] ) && ! st . has ( s [ i + 1 ] ) ) count ++ ; } return count ; }
Ref: 
int countPairs ( string s ) { set < char > st ; st . insert ( ' a ' ) ; st . insert ( ' e ' ) ; st . insert ( ' i ' ) ; st . insert ( ' o ' ) ; st . insert ( ' u ' ) ; int count = 0 ; int n = s . size ( ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( st . find ( s [ i ] ) == st . end ( ) && st . find ( s [ i + 1 ] ) != st . end ( ) ) count ++ ; } return count ; }
Hyp: 
int countPairs ( string s ) { unordered_set < char > st ; st . insert ( ' a ' ) ; st . insert ( ' e ' ) ; st . insert ( ' i ' ) ; st . insert ( ' o ' ) ; st . insert ( ' u ' ) ; st . insert ( ' v ' ) ; st . insert ( ' w ' ) ; st . insert ( ' y ' ) ; st . insert ( ' z ' ) ; int count = 0 ; int n = s . length ( ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( st . find ( s [ i ] ) != st . end ( ) && ! st . find ( s [ i + 1 ] ) ) count ++ ; } return count ; }

BLEU: 73.42
Edit Sim: 131


Src: 
function lenOfLongestReqSubstr ( s , N ) { var ind = new Map ( ) ; var mask = 0 ; ind [ 0 ] = - 1 ; var ans = 0 ; for ( var i = 0 ; i < N ; i ++ ) { var val = s [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ; mask ^= ( 1 << val ) ; if ( ind . has ( mask ) ) { ans = Math . max ( ans , i - ind . get ( mask ) ) ; } else ind . set ( mask , i ) ; } return ans ; }
Ref: 
int lenOfLongestReqSubstr ( string s , int N ) { unordered_map < int , int > ind ; int mask = 0 ; ind [ 0 ] = -1 ; int ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int val = s [ i ] - '0' ; mask ^= ( 1 << val ) ; if ( ind . find ( mask ) != ind . end ( ) ) { ans = max ( ans , i - ind [ mask ] ) ; } else ind [ mask ] = i ; } return ans ; }
Hyp: 
int lenOfLongestReqSubstr ( string s , int N ) { unordered_map < int , int > ind ; int mask = 0 ; ind [ 0 ] = -1 ; int ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int val = s [ i ] - ' a ' ; mask ^= ( 1 << val ) ; if ( ind . find ( mask ) != ind . end ( ) ) { ans = max ( ans , i - ind [ mask ] ) ; } else ind [ mask ] = i ; } return ans ; }

BLEU: 96.02
Edit Sim: 3


Src: 
function sum ( arr , n ) { var sum = 0 ; for ( i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } sum = sum * parseInt ( Math . pow ( 2 , n - 1 ) ) ; return sum ; }
Ref: 
int sum ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } sum = sum * pow ( 2 , n - 1 ) ; return sum ; }
Hyp: 
int sum ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } sum = sum * pow ( 2 , n - 1 ) ; return sum ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function minMoves ( arr ) { let N = arr . length ; if ( N <= 2 ) return 0 ; let ans = Number . MAX_VALUE ; for ( let i = - 1 ; i <= 1 ; i ++ ) { for ( let j = - 1 ; j <= 1 ; j ++ ) { let num1 = arr [ 0 ] + i ; let num2 = arr [ 1 ] + j ; let flag = 1 ; let moves = Math . abs ( i ) + Math . abs ( j ) ; for ( let idx = 2 ; idx < N ; idx ++ ) { let num = num1 + num2 ; if ( Math . abs ( arr [ idx ] - num ) > 1 ) flag = 0 ; else moves += Math . abs ( arr [ idx ] - num ) ; num1 = num2 ; num2 = num ; } if ( flag > 0 ) ans = Math . min ( ans , moves ) ; } } if ( ans == Number . MAX_VALUE ) return - 1 ; return ans ; }
Ref: 
int minMoves ( vector < int > arr ) { int N = arr . size ( ) ; if ( N <= 2 ) return 0 ; int ans = INT_MAX ; for ( int i = -1 ; i <= 1 ; i ++ ) { for ( int j = -1 ; j <= 1 ; j ++ ) { int num1 = arr [ 0 ] + i ; int num2 = arr [ 1 ] + j ; int flag = 1 ; int moves = abs ( i ) + abs ( j ) ; for ( int idx = 2 ; idx < N ; idx ++ ) { int num = num1 + num2 ; if ( abs ( arr [ idx ] - num ) > 1 ) flag = 0 ; else moves += abs ( arr [ idx ] - num ) ; num1 = num2 ; num2 = num ; } if ( flag ) ans = min ( ans , moves ) ; } } if ( ans == INT_MAX ) return -1 ; return ans ; }
Hyp: 
int minMoves ( int arr [ ] , int N ) { if ( N <= 2 ) return 0 ; int ans = INT_MAX ; for ( int i = -1 ; i <= 1 ; i ++ ) { for ( int j = -1 ; j <= 1 ; j ++ ) { int num1 = arr [ 0 ] + i ; int num2 = arr [ 1 ] + j ; int flag = 1 ; int moves = abs ( i ) + abs ( j ) ; for ( int idx = 2 ; idx < N ; idx ++ ) { int num = num1 + num2 ; if ( abs ( arr [ idx ] - num ) > 1 ) flag = 0 ; else moves += abs ( arr [ idx ] - num ) ; num1 = num2 ; num2 = num ; } if ( flag > 0 ) ans = min ( ans , moves ) ; } } if ( ans == INT_MAX ) return -1 ; return ans ; }

BLEU: 91.13
Edit Sim: 35


Src: 
function repeat ( s , n ) { let s1 = s ; for ( let i = 1 ; i < n ; i ++ ) return s ; }
Ref: 
string repeat ( string s , int n ) { string s1 = s ; for ( int i = 1 ; i < n ; i ++ ) return s ; }
Hyp: 
string repeat ( string s , int n ) { string s1 = s ; for ( int i = 1 ; i < n ; i ++ ) return s1 ; }

BLEU: 92.95
Edit Sim: 1


Src: 
function getValueOfF ( n ) { if ( n == 1 ) return 0 ; if ( n == 2 ) return 1 ; let cnt = 0 ; while ( n % 2 == 0 ) { cnt += 1 ; n = parseInt ( n / 2 , 10 ) ; } return 2 * cnt ; }
Ref: 
int getValueOfF ( int n ) { if ( n == 1 ) return 0 ; if ( n == 2 ) return 1 ; int cnt = 0 ; while ( n % 2 == 0 ) { cnt += 1 ; n /= 2 ; } return 2 * cnt ; }
Hyp: 
int getValueOfF ( int n ) { if ( n == 1 ) return 0 ; if ( n == 2 ) return 1 ; int cnt = 0 ; while ( n % 2 == 0 ) { cnt += 1 ; n = n / 2 ; } return 2 * cnt ; }

BLEU: 91.82
Edit Sim: 5


Src: 
function isPrime ( n ) { if ( n <= 1 ) return false ; for ( let i = 2 ; i < n ; i ++ ) if ( n % i == 0 ) return false ; return true ; }
Ref: 
bool isPrime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i < n ; i ++ ) if ( n % i == 0 ) return false ; return true ; }
Hyp: 
bool isPrime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i < n ; i ++ ) if ( n % i == 0 ) return false ; return true ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function summation ( n ) { return n << ( n - 1 ) ; }
Ref: 
int summation ( int n ) { return n << ( n - 1 ) ; }
Hyp: 
int summation ( int n ) { return n << ( n - 1 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function arrayEvenAndOdd ( arr , n ) { let i = - 1 , j = 0 ; let t ; while ( j != n ) { if ( arr [ j ] % 2 == 0 ) { i ++ ; let temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; } j ++ ; } for ( let i = 0 ; i < n ; i ++ ) document . write ( arr [ i ] + " " ) ; }
Ref: 
void arrayEvenAndOdd ( int arr [ ] , int n ) { int i = -1 , j = 0 ; int t ; while ( j != n ) { if ( arr [ j ] % 2 == 0 ) { i ++ ; swap ( arr [ i ] , arr [ j ] ) ; } j ++ ; } for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; }
Hyp: 
void arrayEvenAndOdd ( int arr [ ] , int n ) { int i = -1 , j = 0 ; int t ; while ( j != n ) { if ( arr [ j ] % 2 == 0 ) { i ++ ; int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; } j ++ ; } for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; }

BLEU: 79.69
Edit Sim: 39


Src: 
function findMinSum ( arr , n ) { var occ = n - 1 , sum = 0 ; for ( var i = 0 ; i < n ; i ++ ) { sum += arr [ i ] * Math . pow ( 2 , occ ) ; occ -- ; } return sum ; }
Ref: 
int findMinSum ( int arr [ ] , int n ) { int occ = n - 1 , sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] * pow ( 2 , occ ) ; occ -- ; } return sum ; }
Hyp: 
int findMinSum ( int arr [ ] , int n ) { int occ = n - 1 , sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] * pow ( 2 , occ ) ; occ -- ; } return sum ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countAnomalies ( arr , n , k ) { let res = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let j ; for ( j = 0 ; j < n ; j ++ ) if ( i != j && Math . abs ( arr [ i ] - arr [ j ] ) <= k ) break ; if ( j == n ) res ++ ; } return res ; }
Ref: 
int countAnomalies ( int arr [ ] , int n , int k ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < n ; j ++ ) if ( i != j && abs ( arr [ i ] - arr [ j ] ) <= k ) break ; if ( j == n ) res ++ ; } return res ; }
Hyp: 
int countAnomalies ( int arr [ ] , int n , int k ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < n ; j ++ ) if ( i != j && abs ( arr [ i ] - arr [ j ] ) <= k ) break ; if ( j == n ) res ++ ; } return res ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function evenSum ( n ) { var C = Array . from ( Array ( n + 1 ) , ( ) => Array ( n + 1 ) . fill ( 0 ) ) ; var i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= Math . min ( i , n ) ; j ++ ) { if ( j == 0 j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } var sum = 0 ; for ( var i = 0 ; i <= n ; i += 2 ) sum += C [ n ] [ i ] ; return sum ; }
Ref: 
int evenSum ( int n ) { int C [ n + 1 ] [ n + 1 ] ; int i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= min ( i , n ) ; j ++ ) { if ( j == 0 j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } int sum = 0 ; for ( int i = 0 ; i <= n ; i += 2 ) sum += C [ n ] [ i ] ; return sum ; }
Hyp: 
int evenSum ( int n ) { int C [ n + 1 ] [ n + 1 ] ; int i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= min ( i , n ) ; j ++ ) { if ( j == 0 j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } int sum = 0 ; for ( int i = 0 ; i <= n ; i += 2 ) sum += C [ n ] [ i ] ; return sum ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function recLen ( str ) { if ( str == " " ) return 0 ; else return recLen ( str . substring ( 1 ) ) + 1 ; }
Ref: 
int recLen ( char * str ) { if ( * str == ' \0' ) return 0 ; else return 1 + recLen ( str + 1 ) ; }
Hyp: 
int recLen ( string str ) { if ( str == "0" ) return 0 ; else return recLen ( str . substr ( 1 ) ) + 1 ; }

BLEU: 42.47
Edit Sim: 32


Src: 
function sort ( arr ) { var n = arr . length ; var output = Array . from ( { length : n } , ( _ , i ) => 0 ) ; var count = Array . from ( { length : 256 } , ( _ , i ) => 0 ) ; for ( var i = 0 ; i < n ; ++ i ) ++ count [ arr [ i ] . charCodeAt ( 0 ) ] ; for ( var i = 1 ; i <= 255 ; ++ i ) count [ i ] += count [ i - 1 ] ; for ( var i = n - 1 ; i >= 0 ; i -- ) { output [ count [ arr [ i ] . charCodeAt ( 0 ) ] - 1 ] = arr [ i ] ; -- count [ arr [ i ] . charCodeAt ( 0 ) ] ; } for ( var i = 0 ; i < n ; ++ i ) arr [ i ] = output [ i ] ; return arr ; }
Ref: 
void countSort ( char arr [ ] ) { char output [ strlen ( arr ) ] ; int count [ RANGE + 1 ] , i ; memset ( count , 0 , sizeof ( count ) ) ; for ( i = 0 ; arr [ i ] ; ++ i ) ++ count [ arr [ i ] ] ; for ( i = 1 ; i <= RANGE ; ++ i ) count [ i ] += count [ i - 1 ] ; for ( i = 0 ; arr [ i ] ; ++ i ) { output [ count [ arr [ i ] ] - 1 ] = arr [ i ] ; -- count [ arr [ i ] ] ; } for ( i = 0 ; arr [ i ] ; ++ i ) arr [ i ] = output [ i ] ; }
Hyp: 
int sort ( char arr [ ] , int n ) { int n = arr . length ( ) ; int output [ n ] ; int count [ 256 ] ; for ( int i = 0 ; i < n ; ++ i ) ++ count [ arr [ i ] ] ; for ( int i = 1 ; i <= 255 ; ++ i ) count [ i ] += count [ i - 1 ] ; for ( int i = n - 1 ; i >= 0 ; i -- ) { output [ count [ arr [ i ] ] - 1 ] = arr [ i ] ; -- count [ arr [ i ] ] ; } for ( int i = 0 ; i < n ; ++ i ) arr [ i ] = output [ i ] ; return arr ; }

BLEU: 62.77
Edit Sim: 141


Src: 
function maxBottles ( n , e ) { var s = 0 , b = 0 ; var a = n ; while ( a != 0 ) { s = s + a ; a = ( a + b ) / e ; b = n - ( a * e ) ; n = a + b ; } return s ; }
Ref: 
int maxBottles ( int n , int e ) { int s = 0 , b = 0 ; int a = n ; while ( a != 0 ) { s = s + a ; a = ( a + b ) / e ; b = n - ( a * e ) ; n = a + b ; } return s ; }
Hyp: 
int maxBottles ( int n , int e ) { int s = 0 , b = 0 ; int a = n ; while ( a != 0 ) { s = s + a ; a = ( a + b ) / e ; b = n - ( a * e ) ; n = a + b ; } return s ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function printGMeans ( A , B , N ) { let R = Math . pow ( ( B / A ) , 1.0 / ( N + 1 ) ) ; for ( let i = 1 ; i <= N ; i ++ ) document . write ( A * Math . pow ( R , i ) + " " ) ; }
Ref: 
void printGMeans ( int A , int B , int N ) { float R = ( float ) pow ( float ( B / A ) , 1.0 / ( float ) ( N + 1 ) ) ; for ( int i = 1 ; i <= N ; i ++ ) cout << A * pow ( R , i ) << " ▁ " ; }
Hyp: 
void printGMeans ( double A , double B , int N ) { double R = pow ( ( B / A ) , 1.0 / ( N + 1 ) ) ; for ( int i = 1 ; i <= N ; i ++ ) cout << A * pow ( R , i ) << " ▁ " ; }

BLEU: 73.88
Edit Sim: 44


Src: 
function vol_tetra ( side ) { let volume = ( Math . pow ( side , 3 ) / ( 6 * Math . sqrt ( 2 ) ) ) ; return volume ; }
Ref: 
double vol_tetra ( int side ) { double volume = ( pow ( side , 3 ) / ( 6 * sqrt ( 2 ) ) ) ; return volume ; }
Hyp: 
double vol_tetra ( int side ) { double volume = ( pow ( side , 3 ) / ( 6 * sqrt ( 2 ) ) ) ; return volume ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function removeDuplicate ( str , n ) { var s = new Set ( ) ; for ( var i = 0 ; i < n ; i ++ ) s . add ( str [ i ] ) ; for ( const v of s ) { document . write ( v ) ; } }
Ref: 
> s ( str , str + n - 1 ) ; int i = 0 ; for ( auto x : s ) str [ i ++ ] = x ; str [ i ] = ' \0' ; return str ; }
Hyp: 
void removeDuplicate ( string str , int n ) { unordered_set < char > s ; for ( int i = 0 ; i < n ; i ++ ) s . insert ( str [ i ] ) ; for ( auto x : s ) { cout << x ; } }

BLEU: 31.04
Edit Sim: 98


Src: 
function querySum ( arr , N , Q , M ) { for ( let i = 0 ; i < M ; i ++ ) { let x = Q [ i ] [ 0 ] ; let y = Q [ i ] [ 1 ] ; let sum = 0 ; while ( x < N ) { sum += arr [ x ] ; x += y ; } document . write ( sum + " " ) ; } }
Ref: 
void querySum ( int arr [ ] , int N , int Q [ ] [ 2 ] , int M ) { for ( int i = 0 ; i < M ; i ++ ) { int x = Q [ i ] [ 0 ] ; int y = Q [ i ] [ 1 ] ; int sum = 0 ; while ( x < N ) { sum += arr [ x ] ; x += y ; } cout << sum << " ▁ " ; } }
Hyp: 
void querySum ( int arr [ ] , int N , int Q [ ] [ 2 ] , int M ) { for ( int i = 0 ; i < M ; i ++ ) { int x = Q [ i ] [ 0 ] ; int y = Q [ i ] [ 1 ] ; int sum = 0 ; while ( x < N ) { sum += arr [ x ] ; x += y ; } cout << sum << " ▁ " ; } }

BLEU: 100.0
Edit Sim: 0


Src: 
function maximumSum ( A , N , K , D ) { let ans = 0 ; for ( let i = 0 ; i < ( 1 << N ) ; i ++ ) { let sum = 0 ; let c = 0 ; for ( let j = 0 ; j < N ; j ++ ) { if ( i >> j & 1 ) { sum += A [ j ] ; c ++ ; } } if ( sum % D == 0 && c <= K ) ans = Math . max ( ans , sum ) ; } return ans ; }
Ref: 
int maximumSum ( vector < int > A , int N , int K , int D ) { int ans = 0 ; for ( int i = 0 ; i < ( 1 << N ) ; i ++ ) { int sum = 0 ; int c = 0 ; for ( int j = 0 ; j < N ; j ++ ) { if ( i >> j & 1 ) { sum += A [ j ] ; c ++ ; } } if ( sum % D == 0 && c <= K ) ans = max ( ans , sum ) ; } return ans ; }
Hyp: 
int maximumSum ( int A [ ] , int N , int K , int D ) { int ans = 0 ; for ( int i = 0 ; i < ( 1 << N ) ; i ++ ) { int sum = 0 ; int c = 0 ; for ( int j = 0 ; j < N ; j ++ ) { if ( i >> j & 1 ) { sum += A [ j ] ; c ++ ; } } if ( sum % D == 0 && c <= K ) ans = max ( ans , sum ) ; } return ans ; }

BLEU: 94.73
Edit Sim: 12


Src: 
function find_set ( n ) { if ( n <= 2 ) { document . write ( " " ) ; return ; } let sum1 = parseInt ( ( n * ( n - 1 ) ) / 2 , 10 ) ; let sum2 = n ; document . write ( sum1 + " " + sum2 + " " ) ; }
Ref: 
void find_set ( int n ) { if ( n <= 2 ) { cout << " - 1" ; return ; } int sum1 = ( n * ( n - 1 ) ) / 2 ; int sum2 = n ; cout << sum1 << " ▁ " << sum2 ; }
Hyp: 
void find_set ( int n ) { if ( n <= 2 ) { cout << " NO " ; return ; } int sum1 = ( n * ( n - 1 ) ) / 2 ; int sum2 = n ; cout << sum1 << " ^ 2 ▁ + ▁ " << sum2 << " ^ 2" ; }

BLEU: 76.55
Edit Sim: 21


Src: 
function maximumSumPermutation ( arr ) { var N = arr . length ; arr . sort ( ( a , b ) => a - b ) ; var temp = arr [ 0 ] ; arr [ 0 ] = arr [ N - 1 ] ; arr [ N - 1 ] = temp ; document . write ( arr ) ; }
Ref: 
void maximumSumPermutation ( vector < int > & arr ) { int N = arr . size ( ) ; sort ( arr . begin ( ) , arr . end ( ) ) ; swap ( arr [ 0 ] , arr [ N - 1 ] ) ; for ( int i : arr ) { cout << i << " ▁ " ; } }
Hyp: 
void maximumSumPermutation ( int arr [ ] , int N ) { sort ( arr , arr + N ) ; int temp = arr [ 0 ] ; arr [ 0 ] = arr [ N - 1 ] ; arr [ N - 1 ] = temp ; cout << arr ; }

BLEU: 20.18
Edit Sim: 88


Src: 
function Race ( B , C ) { var result = 0 ; result = ( ( C * 100 ) / B ) ; return 100 - result ; }
Ref: 
int Race ( int B , int C ) { int result = 0 ; result = ( ( C * 100 ) / B ) ; return 100 - result ; }
Hyp: 
int Race ( int B , int C ) { int result = 0 ; result = ( ( C * 100 ) / B ) ; return 100 - result ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function MaxProfit ( treasure , color , n , k , col , A , B ) { return dp [ k ] [ col ] = 0 ; if ( dp [ k ] [ col ] != - 1 ) return dp [ k ] [ col ] ; let sum = 0 ; if ( col == color [ k ] ) sum += Math . max ( A * treasure [ k ] + MaxProfit ( treasure , color , n , k + 1 , color [ k ] , A , B ) , MaxProfit ( treasure , color , n , k + 1 , col , A , B ) ) ; else sum += Math . max ( B * treasure [ k ] + MaxProfit ( treasure , color , n , k + 1 , color [ k ] , A , B ) , MaxProfit ( treasure , color , n , k + 1 , col , A , B ) ) ; return dp [ k ] [ col ] = sum ; }
Ref: 
int MaxProfit ( int treasure [ ] , int color [ ] , int n , int k , int col , int A , int B ) { return dp [ k ] [ col ] = 0 ; if ( dp [ k ] [ col ] != -1 ) return dp [ k ] [ col ] ; int sum = 0 ; sum += max ( A * treasure [ k ] + MaxProfit ( treasure , color , n , k + 1 , color [ k ] , A , B ) , MaxProfit ( treasure , color , n , k + 1 , col , A , B ) ) ; else sum += max ( B * treasure [ k ] + MaxProfit ( treasure , color , n , k + 1 , color [ k ] , A , B ) , MaxProfit ( treasure , color , n , k + 1 , col , A , B ) ) ; return dp [ k ] [ col ] = sum ; }
Hyp: 
int MaxProfit ( int * treasure , int color [ ] , int n , int k , int col , int A , int B ) { if ( dp [ k ] [ col ] != -1 ) return dp [ k ] [ col ] ; int sum = 0 ; if ( col == color [ k ] ) sum += max ( A * treasure [ k ] + MaxProfit ( treasure , color , n , k + 1 , color [ k ] , A , B ) , MaxProfit ( treasure , color , n , k + 1 , col , A , B ) ) ; else sum += max ( B * treasure [ k ] + MaxProfit ( treasure , color , n , k + 1 , color [ k ] , A , B ) , MaxProfit ( treasure , color , n , k + 1 , col , A , B ) ) ; return dp [ k ] [ col ] = sum ; }

BLEU: 91.68
Edit Sim: 53


Src: 
function Minsteps ( n , m ) { let ans = 0 ; while ( m > n ) { if ( m & 1 ) { m ++ ; ans ++ ; } m = Math . floor ( m / 2 ) ; ans ++ ; } return ans + n - m ; }
Ref: 
int Minsteps ( int n , int m ) { int ans = 0 ; while ( m > n ) { if ( m & 1 ) { m ++ ; ans ++ ; } m /= 2 ; ans ++ ; } return ans + n - m ; }
Hyp: 
int Minsteps ( int n , int m ) { int ans = 0 ; while ( m > n ) { if ( m & 1 ) { m ++ ; ans ++ ; } m = m / 2 ; ans ++ ; } return ans + n - m ; }

BLEU: 91.51
Edit Sim: 5


Src: 
function nextPowerOf2 ( n ) { p = 1 ; if ( n && ! ( n & ( n - 1 ) ) ) return n ; while ( p < n ) p <<= 1 ; return p ; }
Ref: 
int nextPowerOf2 ( unsigned int n ) { unsigned int p = 1 ; if ( n && ! ( n & ( n - 1 ) ) ) return n ; while ( p < n ) p <<= 1 ; return p ; }
Hyp: 
int nextPowerOf2 ( unsigned int n ) { unsigned int p = 1 ; if ( n && ! ( n & ( n - 1 ) ) ) return n ; while ( p < n ) p <<= 1 ; return p ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function count_minimum ( s ) { var n = s . length ; var ans = 0 ; var i = 0 ; while ( i < n ) { var j = i ; while ( s [ j ] === s [ i ] && j < n ) { j ++ ; } var diff = j - i ; ans += parseInt ( diff / 2 ) ; i = j ; } document . write ( ans + " " ) ; }
Ref: 
void count_minimum ( string s ) { int n = s . length ( ) ; int ans = 0 ; int i = 0 ; while ( i < n ) { int j = i ; while ( s [ j ] == s [ i ] && j < n ) { j ++ ; } int diff = j - i ; ans += diff / 2 ; i = j ; } cout << ans << endl ; }
Hyp: 
int count_minimum ( string s ) { int n = s . length ( ) ; int ans = 0 ; int i = 0 ; while ( i < n ) { int j = i ; while ( s [ j ] == s [ i ] && j < n ) { j ++ ; } int diff = j - i ; ans += diff / 2 ; i = j ; } cout << ans << endl ; }

BLEU: 98.8
Edit Sim: 4


Src: 
function minimumMoves ( a , n ) { let operations = 0 ; a . sort ( ) ; for ( let i = 0 ; i < n ; i ++ ) operations += Math . abs ( a [ i ] - ( i + 1 ) ) ; return operations ; }
Ref: 
long minimumMoves ( int a [ ] , int n ) { long long operations = 0 ; sort ( a , a + n ) ; for ( int i = 0 ; i < n ; i ++ ) operations += abs ( a [ i ] - ( i + 1 ) ) ; return operations ; }
Hyp: 
int minimumMoves ( int a [ ] , int n ) { int operations = 0 ; sort ( a , a + n ) ; for ( int i = 0 ; i < n ; i ++ ) operations += abs ( a [ i ] - ( i + 1 ) ) ; return operations ; }

BLEU: 92.5
Edit Sim: 11


Src: 
function pushZerosToEnd ( arr , n ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) if ( arr [ i ] != 0 ) arr [ count ++ ] = arr [ i ] ; while ( count < n ) arr [ count ++ ] = 0 ; }
Ref: 
void pushZerosToEnd ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] != 0 ) arr [ count ++ ] = arr [ i ] ; while ( count < n ) arr [ count ++ ] = 0 ; }
Hyp: 
void pushZerosToEnd ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] != 0 ) arr [ count ++ ] = arr [ i ] ; while ( count < n ) arr [ count ++ ] = 0 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function count ( s , k ) { var n = s . length ; var d = 0 , i ; var count = 0 ; for ( i = 0 ; i < n ; i ++ ) d += s [ i ] . charCodeAt ( 0 ) ; if ( d % k === 0 ) { count += 1 ; } for ( i = k ; i < n ; i ++ ) { var prev = s [ i - k ] ; d -= prev . charCodeAt ( 0 ) ; d += s [ i ] . charCodeAt ( 0 ) ; if ( d % k === 0 ) count += 1 ; } return count ; }
Ref: 
int count ( string s , int k ) { int n = s . length ( ) ; int d = 0 , i ; int count = 0 ; for ( i = 0 ; i < n ; i ++ ) d += s [ i ] ; if ( d % k == 0 ) count += 1 ; for ( i = k ; i < n ; i ++ ) { int prev = s [ i - k ] ; d -= prev ; d += s [ i ] ; if ( d % k == 0 ) count += 1 ; } return count ; }
Hyp: 
int count ( string s , int k ) { int n = s . length ( ) ; int d = 0 , i ; int count = 0 ; for ( i = 0 ; i < n ; i ++ ) d += s [ i ] ; if ( d % k == 0 ) { count += 1 ; } for ( i = k ; i < n ; i ++ ) { char prev = s [ i - k ] ; d -= prev ; d += s [ i ] ; if ( d % k == 0 ) count += 1 ; } return count ; }

BLEU: 93.49
Edit Sim: 8


Src: 
function check_string_exist ( S ) { var size = S . length ; var check = true ; for ( var i = 0 ; i < size ; i ++ ) { if ( S [ i ] != S [ ( i + 2 ) % size ] ) { check = false ; break ; } } if ( check ) document . write ( " " ) ; else document . write ( " " ) ; }
Ref: 
void check_string_exist ( string S ) { int size = S . length ( ) ; bool check = true ; for ( int i = 0 ; i < size ; i ++ ) { if ( S [ i ] != S [ ( i + 2 ) % size ] ) { check = false ; break ; } } if ( check ) cout << " Yes " << endl ; else cout << " No " << endl ; }
Hyp: 
void check_string_exist ( string S ) { int size = S . size ( ) ; bool check = true ; for ( int i = 0 ; i < size ; i ++ ) { if ( S [ i ] != S [ ( i + 2 ) % size ] ) { check = false ; break ; } } if ( check ) cout << " Yes " ; else cout << " No " ; }

BLEU: 88.85
Edit Sim: 22


Src: 
function PrletBothArrays ( a , n ) { let v1 = [ ] , v2 = [ ] ; let mpp = new Map ( ) ; for ( let i = 0 ; i < n ; i ++ ) { mpp . set ( a [ i ] , ( mpp . get ( a [ i ] ) == null ? 0 : mpp . get ( a [ i ] ) ) + 1 ) ; if ( mpp . get ( a [ i ] ) == 1 ) v1 . push ( a [ i ] ) ; else if ( mpp . get ( a [ i ] ) == 2 ) v2 . push ( a [ i ] ) ; else { document . write ( " " ) ; return ; } } v1 . sort ( ) ; document . write ( " " + " " ) ; for ( let i = 0 ; i < v1 . length ; i ++ ) document . write ( v1 [ i ] + " " ) ; v2 . sort ( ) ; v2 . reverse ( ) ; document . write ( " " + " " + " " ) ; for ( let i = 0 ; i < v2 . length ; i ++ ) document . write ( v2 [ i ] + " " ) ; }
Ref: 
void PrintBothArrays ( int a [ ] , int n ) { vector < int > v1 , v2 ; unordered_map < int , int > mpp ; for ( int i = 0 ; i < n ; i ++ ) { mpp [ a [ i ] ] ++ ; if ( mpp [ a [ i ] ] == 1 ) v1 . push_back ( a [ i ] ) ; else if ( mpp [ a [ i ] ] == 2 ) v2 . push_back ( a [ i ] ) ; else { cout << " Not ▁ possible " ; return ; } } sort ( v1 . begin ( ) , v1 . end ( ) ) ; cout << " Strictly ▁ increasing ▁ array ▁ is : STRNEWLINE " ; for ( auto it : v1 ) cout << it << " ▁ " ; sort ( v2 . begin ( ) , v2 . end ( ) , greater < int > ( ) ) ; cout << " Strictly decreasing array is : " for ( auto it : v2 ) cout << it << " ▁ " ; }
Hyp: 
void PrletBothArrays ( int a [ ] , int n ) { vector < int > v1 , v2 ; unordered_map < int , int > mpp ; for ( int i = 0 ; i < n ; i ++ ) { mpp [ a [ i ] ] ++ ; if ( mpp [ a [ i ] ] == 1 ) v1 . push_back ( a [ i ] ) ; else if ( mpp [ a [ i ] ] ) == 2 ) v2 . push_back ( a [ i ] ) ; else { cout << " No " << endl ; return ; } } sort ( v1 . begin ( ) , v1 . end ( ) ) ; cout << " Yes " << endl ; for ( int i = 0 ; i < v1 . size ( ) ; i ++ ) cout << v1 [ i ] << " ▁ " ; v2 . sort ( ) ; v2 . reverse ( ) ; cout << " No " << endl ; }

BLEU: 67.14
Edit Sim: 178


Src: 
function checkString ( s , k ) { let n = s . length ; if ( 2 * k + 1 > n ) { document . write ( " " ) ; return ; } let a = s . substr ( 0 , k ) ; let b = s . substr ( n - k , k ) ; b . split ( " " ) . reverse ( ) . join ( " " ) if ( a == b ) document . write ( " " ) ; else document . write ( " " ) ; }
Ref: 
void checkString ( string s , int k ) { int n = s . size ( ) ; if ( 2 * k + 1 > n ) { cout << " No " ; return ; } string a = s . substr ( 0 , k ) ; string b = s . substr ( n - k , k ) ; reverse ( b . begin ( ) , b . end ( ) ) ; if ( a == b ) cout << " Yes " ; else cout << " No " ; }
Hyp: 
void checkString ( string s , int k ) { int n = s . length ( ) ; if ( 2 * k + 1 > n ) { cout << " No " ; return ; } string a = s . substr ( 0 , k ) ; string b = s . substr ( n - k , k ) ; if ( a == b ) cout << " Yes " ; else cout << " No " ; }

BLEU: 81.06
Edit Sim: 48


Src: 
function printAllAPTriplets ( arr , n ) { for ( let i = 1 ; i < n - 1 ; i ++ ) { for ( let j = i - 1 , k = i + 1 ; j >= 0 && k < n ; ) { if ( arr [ j ] + arr [ k ] == 2 * arr [ i ] ) { document . write ( arr [ j ] + " " + arr [ i ] + " " + arr [ k ] + " " ) ; k ++ ; j -- ; } else if ( arr [ j ] + arr [ k ] < 2 * arr [ i ] ) k ++ ; else j -- ; } } }
Ref: 
void printAllAPTriplets ( int arr [ ] , int n ) { for ( int i = 1 ; i < n - 1 ; i ++ ) { for ( int j = i - 1 , k = i + 1 ; j >= 0 && k < n ; ) { if ( arr [ j ] + arr [ k ] == 2 * arr [ i ] ) { cout << arr [ j ] << " ▁ " << arr [ i ] << " ▁ " << arr [ k ] << endl ; k ++ ; j -- ; } else if ( arr [ j ] + arr [ k ] < 2 * arr [ i ] ) k ++ ; else j -- ; } } }
Hyp: 
void printAllAPTriplets ( int arr [ ] , int n ) { for ( int i = 1 ; i < n - 1 ; i ++ ) { for ( int j = i - 1 , k = i + 1 ; j >= 0 && k < n ; ) { if ( arr [ j ] + arr [ k ] == 2 * arr [ i ] ) { cout << arr [ j ] << " * " << arr [ i ] << " * " << arr [ k ] << " ▁ " ; k ++ ; j -- ; } else if ( arr [ j ] + arr [ k ] < 2 * arr [ i ] ) k ++ ; else j -- ; } } }

BLEU: 94.4
Edit Sim: 7


Src: 
function isFactorion ( n ) { let fact = new Array ( MAX ) ; fact [ 0 ] = 1 ; for ( let i = 1 ; i < MAX ; i ++ ) fact [ i ] = i * fact [ i - 1 ] ; let org = n ; let sum = 0 ; while ( n > 0 ) { let d = n % 10 ; sum += fact [ d ] ; n = parseInt ( n / 10 ) ; } if ( sum == org ) return true ; return false ; }
Ref: 
bool isFactorion ( int n ) { int fact [ MAX ] ; fact [ 0 ] = 1 ; for ( int i = 1 ; i < MAX ; i ++ ) fact [ i ] = i * fact [ i - 1 ] ; int org = n ; int sum = 0 ; while ( n > 0 ) { int d = n % 10 ; sum += fact [ d ] ; n /= 10 ; } if ( sum == org ) return true ; return false ; }
Hyp: 
bool isFactorion ( int n ) { int fact [ MAX ] ; fact [ 0 ] = 1 ; for ( int i = 1 ; i < MAX ; i ++ ) fact [ i ] = i * fact [ i - 1 ] ; int org = n ; int sum = 0 ; while ( n > 0 ) { int d = n % 10 ; sum += fact [ d ] ; n = n / 10 ; } if ( sum == org ) return true ; return false ; }

BLEU: 95.41
Edit Sim: 5


Src: 
function countSetBits ( L , R ) { let count = 0 ; for ( let i = L ; i <= R ; i ++ ) { let n = i ; while ( n > 0 ) { count += ( n & 1 ) ; n = n >> 1 ; } } return count ; }
Ref: 
int countSetBits ( int L , int R ) { int count = 0 ; for ( int i = L ; i <= R ; i ++ ) { int n = i ; while ( n > 0 ) { count += ( n & 1 ) ; n = n >> 1 ; } } return count ; }
Hyp: 
int countSetBits ( int L , int R ) { int count = 0 ; for ( int i = L ; i <= R ; i ++ ) { int n = i ; while ( n > 0 ) { count += ( n & 1 ) ; n = n >> 1 ; } } return count ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function solve ( idx , diff , N , M , K ) { if ( idx > N ) { if ( diff == K ) return 1 ; return 0 ; } if ( dp [ idx ] [ diff ] != - 1 ) return dp [ idx ] [ diff ] ; let ans = solve ( idx + 1 , diff , N , M , K ) ; ans += ( M - 1 ) * solve ( idx + 1 , diff + 1 , N , M , K ) ; dp [ idx ] [ diff ] = ans % MOD ; return dp [ idx ] [ diff ] ; }
Ref: 
int solve ( int idx , int diff , int N , int M , int K ) { if ( idx > N ) { if ( diff == K ) return 1 ; return 0 ; } if ( dp [ idx ] [ diff ] != -1 ) return dp [ idx ] [ diff ] ; int ans = solve ( idx + 1 , diff , N , M , K ) ; ans += ( M - 1 ) * solve ( idx + 1 , diff + 1 , N , M , K ) ; return dp [ idx ] [ diff ] = ans % MOD ; }
Hyp: 
int solve ( int idx , int diff , int N , int M , int K ) { if ( idx > N ) { if ( diff == K ) return 1 ; return 0 ; } if ( dp [ idx ] [ diff ] != -1 ) return dp [ idx ] [ diff ] ; int ans = solve ( idx + 1 , diff , N , M , K ) ; ans += ( M - 1 ) * solve ( idx + 1 , diff + 1 , N , M , K ) ; dp [ idx ] [ diff ] = ans % MOD ; return dp [ idx ] [ diff ] ; }

BLEU: 92.55
Edit Sim: 36


Src: 
function findevenPair ( A , N ) { let count = 0 ; for ( let i = 0 ; i < N ; i ++ ) if ( A [ i ] % 2 != 0 ) count ++ ; let oddCount = parseInt ( ( count * ( count - 1 ) ) / 2 ) ; return parseInt ( ( N * ( N - 1 ) ) / 2 ) - oddCount ; }
Ref: 
int findevenPair ( int A [ ] , int N ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( A [ i ] % 2 != 0 ) count ++ ; int oddCount = count * ( count - 1 ) / 2 ; return ( N * ( N - 1 ) / 2 ) - oddCount ; }
Hyp: 
int findevenPair ( int A [ ] , int N ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( A [ i ] % 2 != 0 ) count ++ ; int oddCount = ( count * ( count - 1 ) ) / 2 ; return ( N * ( N - 1 ) ) / 2 - oddCount ; }

BLEU: 90.14
Edit Sim: 7


Src: 
function binary_searched_find_x ( k ) { var l = 0 ; var r = k ; var ans = 0 ; while ( l <= r ) { var mid = parseInt ( l + ( r - l ) / 2 ) ; if ( Math . pow ( ( ( mid * ( mid + 1 ) ) / 2 ) , 2 ) >= k ) { ans = mid ; r = mid - 1 ; } else { l = mid + 1 ; } } return ans ; }
Ref: 
int binary_searched_find_x ( int k ) { int l = 0 ; int r = k ; int ans = 0 ; while ( l <= r ) { int mid = l + ( r - l ) / 2 ; if ( pow ( ( ( mid * ( mid + 1 ) ) / 2 ) , 2 ) >= k ) { ans = mid ; r = mid - 1 ; } else { l = mid + 1 ; } } return ans ; }
Hyp: 
int binary_searched_find_x ( int k ) { int l = 0 ; int r = k ; int ans = 0 ; while ( l <= r ) { int mid = l + ( r - l ) / 2 ; if ( pow ( ( ( mid * ( mid + 1 ) ) / 2 ) , 2 ) >= k ) { ans = mid ; r = mid - 1 ; } else { l = mid + 1 ; } } return ans ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function minDistance ( n1 , n2 ) { var bitCount1 = Math . floor ( Math . log2 ( n1 ) ) + 1 ; var bitCount2 = Math . floor ( Math . log2 ( n2 ) ) + 1 ; var bitDiff = Math . abs ( bitCount1 - bitCount2 ) ; var maxBitCount = Math . max ( bitCount1 , bitCount2 ) ; if ( bitCount1 > bitCount2 ) { n2 = n2 * Math . pow ( 2 , bitDiff ) ; } else { n1 = n1 * Math . pow ( 2 , bitDiff ) ; } var xorValue = n1 ^ n2 ; var bitCountXorValue ; if ( xorValue == 0 ) bitCountXorValue = 1 ; else { bitCountXorValue = Math . floor ( Math . log2 ( xorValue ) ) + 1 ; } var disSimilarBitPosition = maxBitCount - bitCountXorValue ; var result = bitCount1 + bitCount2 - 2 * disSimilarBitPosition ; return result ; }
Ref: 
int minDistance ( int n1 , int n2 ) { int bitCount1 = floor ( log2 ( n1 ) ) + 1 ; int bitCount2 = floor ( log2 ( n2 ) ) + 1 ; int bitDiff = abs ( bitCount1 - bitCount2 ) ; int maxBitCount = max ( bitCount1 , bitCount2 ) ; if ( bitCount1 > bitCount2 ) { n2 = n2 * pow ( 2 , bitDiff ) ; } else { n1 = n1 * pow ( 2 , bitDiff ) ; } int xorValue = n1 ^ n2 ; int bitCountXorValue ; if ( xorValue == 0 ) bitCountXorValue = 1 ; else { bitCountXorValue = floor ( log2 ( xorValue ) ) + 1 ; } int disSimilarBitPosition = maxBitCount - bitCountXorValue ; int result = bitCount1 + bitCount2 - 2 * disSimilarBitPosition ; return result ; }
Hyp: 
int minDistance ( int n1 , int n2 ) { int bitCount1 = floor ( log2 ( n1 ) ) + 1 ; int bitCount2 = floor ( log2 ( n2 ) ) + 1 ; int bitDiff = abs ( bitCount1 - bitCount2 ) ; int maxBitCount = max ( bitCount1 , bitCount2 ) ; if ( bitCount1 > bitCount2 ) { n2 = n2 * pow ( 2 , bitDiff ) ; } else { n1 = n1 * pow ( 2 , bitDiff ) ; } int xorValue = n1 ^ n2 ; int bitCountXorValue ; if ( xorValue == 0 ) bitCountXorValue = 1 ; else { bitCountXorValue = floor ( log2 ( xorValue ) ) + 1 ; } int disSimilarBitPosition = maxBitCount - bitCountXorValue ; return result ; }

BLEU: 91.65
Edit Sim: 65


Src: 
function countInRange ( arr , n , x , y ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] >= x && arr [ i ] <= y ) count ++ ; } return count ; }
Ref: 
int countInRange ( int arr [ ] , int n , int x , int y ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] >= x && arr [ i ] <= y ) count ++ ; } return count ; }
Hyp: 
int countInRange ( int arr [ ] , int n , int x , int y ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] >= x && arr [ i ] <= y ) count ++ ; } return count ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function answer_query ( a , n , l , r ) { var count = 0 ; for ( var i = l ; i < r ; i ++ ) if ( a [ i ] == a [ i + 1 ] ) count += 1 ; return count ; }
Ref: 
int answer_query ( int a [ ] , int n , int l , int r ) { int count = 0 ; for ( int i = l ; i < r ; i ++ ) if ( a [ i ] == a [ i + 1 ] ) count += 1 ; return count ; }
Hyp: 
int answer_query ( int a [ ] , int n , int l , int r ) { int count = 0 ; for ( int i = l ; i < r ; i ++ ) if ( a [ i ] == a [ i + 1 ] ) count += 1 ; return count ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countDistinct ( arr , n ) { let res = 1 ; for ( let i = 1 ; i < n ; i ++ ) { let j = 0 ; for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] === arr [ j ] ) break ; if ( i === j ) res ++ ; } return res ; }
Ref: 
int countDistinct ( int arr [ ] , int n ) { int res = 1 ; for ( int i = 1 ; i < n ; i ++ ) { int j = 0 ; for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] == arr [ j ] ) break ; if ( i == j ) res ++ ; } return res ; }
Hyp: 
int countDistinct ( int arr [ ] , int n ) { int res = 1 ; for ( int i = 1 ; i < n ; i ++ ) { int j = 0 ; for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] == arr [ j ] ) break ; if ( i == j ) res ++ ; } return res ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function sumOfSeries ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) for ( let j = 1 ; j <= i ; j ++ ) sum = sum + i ; return sum ; }
Ref: 
int sumOfSeries ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= i ; j ++ ) sum = sum + i ; return sum ; }
Hyp: 
int sumOfSeries ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= i ; j ++ ) sum = sum + i ; return sum ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function checkOverlap ( R , Xc , Yc , X1 , Y1 , X2 , Y2 ) { let Xn = Math . max ( X1 , Math . min ( Xc , X2 ) ) ; let Yn = Math . max ( Y1 , Math . min ( Yc , Y2 ) ) ; let Dx = Xn - Xc ; let Dy = Yn - Yc ; return ( Dx * Dx + Dy * Dy ) <= R * R ; } let R = 1 ; let Xc = 0 , Yc = 0 ; let X1 = 1 , Y1 = - 1 ; let X2 = 3 , Y2 = 1 ; if ( checkOverlap ( R , Xc , Yc , X1 , Y1 , X2 , Y2 ) ) { document . write ( " " + " " ) ; } else { document . write ( " " ) ; }
Ref: 
bool checkOverlap ( int R , int Xc , int Yc , int X1 , int Y1 , int X2 , int Y2 ) { int Xn = max ( X1 , min ( Xc , X2 ) ) ; int Yn = max ( Y1 , min ( Yc , Y2 ) ) ; int Dx = Xn - Xc ; int Dy = Yn - Yc ; return ( Dx * Dx + Dy * Dy ) <= R * R ; }
Hyp: 
bool checkOverlap ( int R , int Xc , int Yc , int X1 , int Y1 , int X2 , int Y2 ) { int Xn = max ( X1 , min ( Xc , X2 ) ) ; int Yn = max ( Y1 , min ( Yc , Y2 ) ) ; int Dx = Xn - Xc ; int Dy = Yn - Yc ; return ( Dx * Dx + Dy * Dy ) <= R * R ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function getResult ( n ) { let proOdd = 1 ; let proEven = 1 ; let num = n . toString ( ) ; for ( let i = 0 ; i < num . length ; i ++ ) if ( i % 2 == 0 ) proOdd = proOdd * ( num [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ) ; else proEven = proEven * ( num [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ) ; if ( proOdd == proEven ) document . write ( " " ) ; else document . write ( " " ) ; }
Ref: 
void getResult ( int n ) { int proOdd = 1 ; int proEven = 1 ; string num = to_string ( n ) ; for ( int i = 0 ; i < num . size ( ) ; i ++ ) if ( i % 2 == 0 ) proOdd = proOdd * ( num [ i ] - '0' ) ; else proEven = proEven * ( num [ i ] - '0' ) ; if ( proOdd == proEven ) cout << " Yes " ; else cout << " No " ; }
Hyp: 
void getResult ( int n ) { int proOdd = 1 ; int proEven = 1 ; string num = to_string ( n ) ; for ( int i = 0 ; i < num . length ( ) ; i ++ ) if ( i % 2 == 0 ) proOdd = proOdd * ( num [ i ] - '0' ) ; else proEven = proEven * ( num [ i ] - '0' ) ; if ( proOdd == proEven ) cout << " Yes " ; else cout << " No " ; }

BLEU: 97.42
Edit Sim: 6


Src: 
function boost_hyperfactorial ( num ) { var val = 1 ; for ( var i = 1 ; i <= num ; i ++ ) { for ( var j = 1 ; j <= i ; j ++ ) { val *= i ; } } return val ; }
Ref: 
int1024_t boost_hyperfactorial ( int num ) { int1024_t val = 1 ; for ( int i = 1 ; i <= num ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) { val *= i ; } } return val ; }
Hyp: 
int boost_hyperfactorial ( int num ) { int val = 1 ; for ( int i = 1 ; i <= num ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) { val *= i ; } } return val ; }

BLEU: 93.12
Edit Sim: 12


Src: 
function countPaths ( m , n ) { if ( m == 1 n == 1 ) return 1 ; return countPaths ( m - 1 , n ) + countPaths ( m , n - 1 ) ; }
Ref: 
int countPaths ( int m , int n ) { if ( m == 1 n == 1 ) return 1 ; return countPaths ( m - 1 , n ) + countPaths ( m , n - 1 ) ; }
Hyp: 
int countPaths ( int m , int n ) { if ( m == 1 n == 1 ) return 1 ; return countPaths ( m - 1 , n ) + countPaths ( m , n - 1 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function Permutation ( n , k ) { let p = new Array ( n + 1 ) ; for ( let i = 1 ; i <= n ; i ++ ) p [ i ] = i ; for ( let i = 1 ; i < n - k ; i ++ ) p [ i + 1 ] = i ; p [ 1 ] = n - k ; for ( let i = 1 ; i <= n ; i ++ ) document . write ( p [ i ] + " " ) ; }
Ref: 
void Permutation ( int n , int k ) { int p [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) p [ i ] = i ; for ( int i = 1 ; i < n - k ; i ++ ) p [ i + 1 ] = i ; p [ 1 ] = n - k ; for ( int i = 1 ; i <= n ; i ++ ) cout << p [ i ] << " ▁ " ; }
Hyp: 
void Permutation ( int n , int k ) { int p [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) p [ i ] = i ; for ( int i = 1 ; i < n - k ; i ++ ) p [ i + 1 ] = i ; p [ 1 ] = n - k ; for ( int i = 1 ; i <= n ; i ++ ) cout << p [ i ] << " ▁ " ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countDecrements ( arr ) { let count_1 = 0 ; let count_2 = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < m ; j ++ ) { if ( ( i + j ) % 2 == arr [ i ] [ j ] % 2 ) count_1 ++ ; if ( 1 - ( i + j ) % 2 == arr [ i ] [ j ] % 2 ) count_2 ++ ; } } document . write ( Math . min ( count_1 , count_2 ) ) ; }
Ref: 
void countDecrements ( long long arr [ ] [ m ] ) { int count_1 = 0 ; int count_2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( ( i + j ) % 2 == arr [ i ] [ j ] % 2 ) count_1 ++ ; if ( 1 - ( i + j ) % 2 == arr [ i ] [ j ] % 2 ) count_2 ++ ; } } cout << min ( count_1 , count_2 ) ; }
Hyp: 
void countDecrements ( int arr [ ] [ MAX ] , int n ) { int count_1 = 0 ; int count_2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( ( i + j ) % 2 == arr [ i ] [ j ] % 2 ) count_1 ++ ; if ( 1 - ( i + j ) % 2 == arr [ i ] [ j ] % 2 ) count_2 ++ ; } } cout << min ( count_1 , count_2 ) ; }

BLEU: 92.31
Edit Sim: 19


Src: 
function findMax ( arr ) { var row = 0 , i , j ; for ( i = 0 , j = N - 1 ; i < N ; i ++ ) { while ( arr [ i ] [ j ] == 1 && j >= 0 ) { row = i ; j -- ; } } document . write ( " " + ( row + 1 ) ) ; document . write ( " " + ( N - 1 - j ) ) ; }
Ref: 
void findMax ( int arr [ ] [ N ] ) { int row = 0 , i , j ; for ( i = 0 , j = N - 1 ; i < N ; i ++ ) { while ( arr [ i ] [ j ] == 1 && j >= 0 ) { row = i ; j -- ; } } cout << " Row ▁ number ▁ = ▁ " << row + 1 ; cout << " , ▁ MaxCount ▁ = ▁ " << N - 1 - j ; }
Hyp: 
void findMax ( int arr [ N ] [ N ] ) { int row = 0 , i , j ; for ( i = 0 , j = N - 1 ; i < N ; i ++ ) { while ( arr [ i ] [ j ] == 1 && j >= 0 ) { row = i ; j -- ; } } cout << " ▁ max ▁ = ▁ " << row + 1 ; cout << " ▁ min ▁ = ▁ " << N - 1 - j << endl ; }

BLEU: 87.62
Edit Sim: 28


Src: 
function myXOR ( x , y ) { for ( let i = 31 ; i >= 0 ; i -- ) { let b1 = ( ( x & ( 1 << i ) ) == 0 ) ? 0 : 1 ; let b2 = ( ( y & ( 1 << i ) ) == 0 ) ? 0 : 1 ; let xoredBit = ( b1 & b2 ) ? 0 : ( b1 b2 ) ; res <<= 1 ; res |= xoredBit ; } return res ; }
Ref: 
int myXOR ( int x , int y ) { for ( int i = 31 ; i >= 0 ; i -- ) { bool b1 = x & ( 1 << i ) ; bool b2 = y & ( 1 << i ) ; bool xoredBit = ( b1 & b2 ) ? 0 : ( b1 b2 ) ; res <<= 1 ; res |= xoredBit ; } return res ; }
Hyp: 
int myXOR ( int x , int y ) { int res = 0 ; for ( int i = 31 ; i >= 0 ; i -- ) { int b1 = ( ( x & ( 1 << i ) ) == 0 ) ? 0 : 1 ; int b2 = ( ( y & ( 1 << i ) ) == 0 ) ? 0 : 1 ; int xoredBit = ( b1 & b2 ) ? 0 : ( b1 b2 ) ; res <<= 1 ; res |= xoredBit ; } return res ; }

BLEU: 61.71
Edit Sim: 68


Src: 
function noOfArraysPossible ( N , M ) { var ans = 1 ; for ( i = 0 ; i < N ; ++ i ) { ans = ans * ( M - i ) ; } document . write ( ans ) ; }
Ref: 
void noOfArraysPossible ( ll N , ll M ) { ll ans = 1 ; for ( ll i = 0 ; i < N ; ++ i ) { ans = ans * ( M - i ) ; } cout << ans ; }
Hyp: 
int noOfArraysPossible ( int N , int M ) { int ans = 1 ; for ( int i = 0 ; i < N ; ++ i ) { ans = ans * ( M - i ) ; } cout << ans ; }

BLEU: 76.19
Edit Sim: 16


Src: 
function to_upper ( In ) { let n = In . length ; for ( let i = 0 ; i < In . length ; i ++ ) if ( ' ' <= In [ i ] && In [ i ] <= ' ' ) In [ i ] = String . fromCharCode ( In [ i ] . charCodeAt ( 0 ) & ( ~ ( 1 << 5 ) ) ) ; return ( In ) . join ( " " ) ; }
Ref: 
string to_upper ( string & in ) { for ( int i = 0 ; i < in . length ( ) ; i ++ ) if ( ' a ' <= in [ i ] <= ' z ' ) in [ i ] &= ~ ( 1 << 5 ) ; return in ; }
Hyp: 
string to_upper ( string & In ) { int n = In . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) if ( ' A ' <= In [ i ] && In [ i ] <= ' Z ' ) In [ i ] = to_upper ( In [ i ] ) ; return In ; }

BLEU: 42.18
Edit Sim: 64


Src: 
function minAbsDiff ( N ) { if ( N % 4 == 0 N % 4 == 3 ) { return 0 ; } return 1 ; }
Ref: 
int minAbsDiff ( int N ) { if ( N % 4 == 0 N % 4 == 3 ) { return 0 ; } return 1 ; }
Hyp: 
int minAbsDiff ( int N ) { if ( N % 4 == 0 N % 4 == 3 ) { return 0 ; } return 1 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function kthgroupsum ( k ) { return k * k * k ; }
Ref: 
int kthgroupsum ( int k ) { return k * k * k ; }
Hyp: 
int kthgroupsum ( int k ) { return k * k * k ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function Length_Diagonals ( a , theta ) { let p = a * Math . sqrt ( 2 + ( 2 * Math . cos ( theta * ( Math . PI / 180 ) ) ) ) ; let q = a * Math . sqrt ( 2 - ( 2 * Math . cos ( theta * ( Math . PI / 180 ) ) ) ) ; return [ p , q ] ; }
Ref: 
double Length_Diagonals ( int a , double theta ) { double p = a * sqrt ( 2 + ( 2 * cos ( theta * ( 3.141 / 180 ) ) ) ) ; double q = a * sqrt ( 2 - ( 2 * cos ( theta * ( 3.141 / 180 ) ) ) ) ; cout << fixed << setprecision ( 2 ) << p << " ▁ " << q ; }
Hyp: 
float Length_Diagonals ( int a , double theta ) { float p = a * sqrt ( 2 + ( 2 * cos ( theta * ( PI / 180 ) ) ) ) ; float q = a * sqrt ( 2 - ( 2 * cos ( theta * ( PI / 180 ) ) ) ) ; return [ p , q ] ; }

BLEU: 63.0
Edit Sim: 72


Src: 
function maxSumWO3Consec ( A , N ) { if ( N == 1 ) return A [ 0 ] ; if ( N == 2 ) return A [ 0 ] + A [ 1 ] ; let third = A [ 0 ] ; let second = third + A [ 1 ] ; let first = Math . max ( second , A [ 1 ] + A [ 2 ] ) ; let sum = Math . max ( Math . max ( third , second ) , first ) ; for ( let i = 3 ; i < N ; i ++ ) { sum = Math . max ( Math . max ( first , second + A [ i ] ) , third + A [ i ] + A [ i - 1 ] ) ; third = second ; second = first ; first = sum ; } return sum ; }
Ref: 
int maxSumWO3Consec ( int A [ ] , int N ) { if ( N == 1 ) return A [ 0 ] ; if ( N == 2 ) return A [ 0 ] + A [ 1 ] ; int third = A [ 0 ] ; int second = third + A [ 1 ] ; int first = max ( second , A [ 1 ] + A [ 2 ] ) ; int sum = max ( max ( third , second ) , first ) ; for ( int i = 3 ; i < N ; i ++ ) { sum = max ( max ( first , second + A [ i ] ) , third + A [ i ] + A [ i - 1 ] ) ; third = second ; second = first ; first = sum ; } return sum ; }
Hyp: 
int maxSumWO3Consec ( int A [ ] , int N ) { if ( N == 1 ) return A [ 0 ] ; if ( N == 2 ) return A [ 0 ] + A [ 1 ] ; int third = A [ 0 ] ; int second = third + A [ 1 ] ; int first = max ( second , A [ 1 ] + A [ 2 ] ) ; int sum = max ( max ( third , second ) , first ) ; for ( int i = 3 ; i < N ; i ++ ) { sum = max ( max ( first , second + A [ i ] ) , third + A [ i ] + A [ i - 1 ] ) ; third = second ; second = first ; first = sum ; } return sum ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countPairsWithProdK ( arr , n , k ) { var count = 0 ; for ( var i = 0 ; i < n ; i ++ ) { for ( var j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] * arr [ j ] == k ) count ++ ; } return count ; }
Ref: 
int countPairsWithProdK ( int arr [ ] , int n , int k ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] * arr [ j ] == k ) count ++ ; } return count ; }
Hyp: 
int countPairsWithProdK ( int arr [ ] , int n , int k ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] * arr [ j ] == k ) count ++ ; } return count ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function nthTerm ( n ) { return 3 * Math . pow ( n , 2 ) + 2 * n - 5 ; }
Ref: 
int nthTerm ( int n ) { return 3 * pow ( n , 2 ) + 2 * n - 5 ; }
Hyp: 
int nthTerm ( int n ) { return 3 * pow ( n , 2 ) + 2 * n - 5 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function Maxlen ( arr , n ) { let ans = 0 ; let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) count = 0 ; else count ++ ; ans = Math . max ( ans , count ) ; } return ans ; }
Ref: 
int Maxlen ( int arr [ ] , int n ) { int ans = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) count = 0 ; else count ++ ; ans = max ( ans , count ) ; } return ans ; }
Hyp: 
int Maxlen ( int arr [ ] , int n ) { int ans = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) count = 0 ; else count ++ ; ans = max ( ans , count ) ; } return ans ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function segregateElements ( arr , n ) { let temp = new Array ( n ) ; let j = 0 ; for ( let i = 0 ; i < n ; i ++ ) if ( arr [ i ] >= 0 ) temp [ j ++ ] = arr [ i ] ; if ( j == n j == 0 ) return ; for ( let i = 0 ; i < n ; i ++ ) if ( arr [ i ] < 0 ) temp [ j ++ ] = arr [ i ] ; for ( let i = 0 ; i < n ; i ++ ) arr [ i ] = temp [ i ] ; }
Ref: 
void segregateElements ( int arr [ ] , int n ) { int temp [ n ] ; int j = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] >= 0 ) temp [ j ++ ] = arr [ i ] ; if ( j == n j == 0 ) return ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] < 0 ) temp [ j ++ ] = arr [ i ] ; memcpy ( arr , temp , sizeof ( temp ) ) ; }
Hyp: 
void segregateElements ( int arr [ ] , int n ) { int temp [ n ] ; int j = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] >= 0 ) temp [ j ++ ] = arr [ i ] ; if ( j == n j == 0 ) return ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] < 0 ) temp [ j ++ ] = arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = temp [ i ] ; }

BLEU: 81.58
Edit Sim: 41


Src: 
function isPossible ( l , m , x , y ) { if ( l * m == x + y ) return true ; return false ; }
Ref: 
bool isPossible ( int l , int m , int x , int y ) { if ( l * m == x + y ) return true ; return false ; }
Hyp: 
int isPossible ( int l , int m , int x , int y ) { if ( l * m == x + y ) return true ; return false ; }

BLEU: 96.92
Edit Sim: 4


Src: 
function kthgroupsum ( k ) { let cur = ( k * ( k - 1 ) ) + 1 ; let sum = 0 ; while ( k -- ) { sum += cur ; cur += 2 ; } return sum ; }
Ref: 
int kthgroupsum ( int k ) { int cur = ( k * ( k - 1 ) ) + 1 ; int sum = 0 ; while ( k -- ) { sum += cur ; cur += 2 ; } return sum ; }
Hyp: 
int kthgroupsum ( int k ) { int cur = ( k * ( k - 1 ) ) + 1 ; int sum = 0 ; while ( k -- ) { sum += cur ; cur += 2 ; } return sum ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function minSteps ( m , n ) { if ( n == m ) return 0 ; if ( m > n ) return inf ; let min_cost = inf ; for ( let i = 2 ; i < m ; i += 2 ) { if ( m % i == 0 ) { min_cost = Math . min ( min_cost , m / i + minSteps ( m + i , n ) ) ; } } return min_cost ; }
Ref: 
int minSteps ( int m , int n ) { if ( n == m ) return 0 ; if ( m > n ) return inf ; int min_cost = inf ; for ( int i = 2 ; i < m ; i += 2 ) { if ( m % i == 0 ) { min_cost = min ( min_cost , m / i + minSteps ( m + i , n ) ) ; } } return min_cost ; }
Hyp: 
int minSteps ( int m , int n ) { if ( n == m ) return 0 ; if ( m > n ) return inf ; int min_cost = inf ; for ( int i = 2 ; i < m ; i += 2 ) { if ( m % i == 0 ) { min_cost = min ( min_cost , m / i + minSteps ( m + i , n ) ) ; } } return min_cost ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function winner ( a , n , k ) { if ( k >= n - 1 ) return n ; let best = 0 , times = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] > best ) { best = a [ i ] ; if ( i ) times = 1 ; } else times += 1 ; if ( times >= k ) return best ; } return best ; }
Ref: 
int winner ( int a [ ] , int n , int k ) { if ( k >= n - 1 ) return n ; int best = 0 , times = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > best ) { best = a [ i ] ; if ( i ) } else if ( times >= k ) return best ; } return best ; }
Hyp: 
int winner ( int a [ ] , int n , int k ) { if ( k >= n - 1 ) return n ; int best = 0 , times = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > best ) { best = a [ i ] ; if ( i ) times = 1 ; } else times += 1 ; if ( times >= k ) return best ; } return best ; }

BLEU: 88.57
Edit Sim: 25


Src: 
function lastCoordinate ( n , a , b ) { return ( parseInt ( n + 1 ) / 2 ) * a - parseInt ( n / 2 ) * b ; }
Ref: 
int lastCoordinate ( int n , int a , int b ) { return ( ( n + 1 ) / 2 ) * a - ( n / 2 ) * b ; }
Hyp: 
int lastCoordinate ( int n , int a , int b ) { return ( ( n + 1 ) / 2 ) * a - ( n / 2 ) * b ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function Icositetragonal_num ( n ) { return ( 22 * n * n - 20 * n ) / 2 ; }
Ref: 
int Icositetragonal_num ( int n ) { return ( 22 * n * n - 20 * n ) / 2 ; }
Hyp: 
int Icositetragonal_num ( long int n ) { return ( 22 * n * n - 20 * n ) / 2 ; }

BLEU: 88.95
Edit Sim: 5


Src: 
function lcs ( X , Y ) { let m = X . length , n = Y . length ; let L = new Array ( 2 ) ; for ( let i = 0 ; i < 2 ; i ++ ) { L [ i ] = new Array ( n + 1 ) ; for ( let j = 0 ; j < n + 1 ; j ++ ) { L [ i ] [ j ] = 0 ; } } let bi = 0 ; for ( let i = 0 ; i <= m ; i ++ ) { bi = i & 1 ; for ( let j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) L [ bi ] [ j ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) L [ bi ] [ j ] = L [ 1 - bi ] [ j - 1 ] + 1 ; else L [ bi ] [ j ] = Math . max ( L [ 1 - bi ] [ j ] , L [ bi ] [ j - 1 ] ) ; } } return L [ bi ] [ n ] ; }
Ref: 
int lcs ( string & X , string & Y ) { int m = X . length ( ) , n = Y . length ( ) ; int L [ 2 ] [ n + 1 ] ; bool bi ; for ( int i = 0 ; i <= m ; i ++ ) { bi = i & 1 ; for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) L [ bi ] [ j ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) L [ bi ] [ j ] = L [ 1 - bi ] [ j - 1 ] + 1 ; else L [ bi ] [ j ] = max ( L [ 1 - bi ] [ j ] , L [ bi ] [ j - 1 ] ) ; } } return L [ bi ] [ n ] ; }
Hyp: 
int lcs ( int X [ ] , int Y [ ] ) { int m = X . length ( ) , n = Y . length ( ) ; int L [ 2 ] [ n + 1 ] ; memset ( L , 0 , sizeof ( L ) ) ; int bi = 0 ; for ( int i = 0 ; i <= m ; i ++ ) { bi = i & 1 ; for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) L [ bi ] [ j ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) L [ bi ] [ j ] = L [ 1 - bi ] [ j - 1 ] + 1 ; else L [ bi ] [ j ] = max ( L [ 1 - bi ] [ j ] , L [ bi ] [ j - 1 ] ) ; } } return L [ bi ] [ n ] ; }

BLEU: 86.23
Edit Sim: 55


Src: 
function isSpiltPossible ( n , a ) { let sum = 0 , c1 = 0 ; for ( let i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; if ( a [ i ] == 1 ) { c1 ++ ; } } if ( sum % 2 != 0 ) return false ; if ( ( sum / 2 ) % 2 == 0 ) return true ; if ( c1 > 0 ) return true ; else return false ; }
Ref: 
bool isSpiltPossible ( int n , int a [ ] ) { int sum = 0 , c1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; if ( a [ i ] == 1 ) { c1 ++ ; } } if ( sum % 2 ) return false ; if ( ( sum / 2 ) % 2 == 0 ) return true ; if ( c1 > 0 ) return true ; else return false ; }
Hyp: 
bool isSpiltPossible ( int n , int a [ ] ) { int sum = 0 , c1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; if ( a [ i ] == 1 ) { c1 ++ ; } } if ( sum % 2 != 0 ) return false ; if ( ( sum / 2 ) % 2 == 0 ) return true ; if ( c1 > 0 ) return true ; else return false ; }

BLEU: 96.39
Edit Sim: 5


Src: 
function checkcircle ( r , R , r1 , x1 , y1 ) { let dis = Math . sqrt ( x1 * x1 + y1 * y1 ) ; return ( dis - r1 >= R && dis + r1 <= r ) ; }
Ref: 
bool checkcircle ( int r , int R , int r1 , int x1 , int y1 ) { int dis = sqrt ( x1 * x1 + y1 * y1 ) ; return ( dis - r1 >= R && dis + r1 <= r ) ; }
Hyp: 
bool checkcircle ( int r , int R , int r1 , int x1 , int y1 ) { double dis = sqrt ( x1 * x1 + y1 * y1 ) ; return ( dis - r1 >= R && dis + r1 <= r ) ; }

BLEU: 94.76
Edit Sim: 6


Src: 
function isCubeSum ( n ) { for ( var i = 1 ; i * i * i <= n ; i ++ ) { if ( i * i * i + ( i + 1 ) * ( i + 1 ) * ( i + 1 ) == n ) return true ; } return false ; }
Ref: 
bool isCubeSum ( int n ) { for ( int i = 1 ; i * i * i <= n ; i ++ ) { if ( i * i * i + ( i + 1 ) * ( i + 1 ) * ( i + 1 ) == n ) return true ; } return false ; }
Hyp: 
bool isCubeSum ( int n ) { for ( int i = 1 ; i * i * i <= n ; i ++ ) { if ( i * i * i + ( i + 1 ) * ( i + 1 ) * ( i + 1 ) == n ) return true ; } return false ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function speedOfTrain ( X , Y ) { var Speed ; Speed = 1188 * ( ( X - Y ) / Y ) ; return Speed ; }
Ref: 
float speedOfTrain ( float X , float Y ) { float Speed = 0 ; Speed = 1188 * ( ( X - Y ) / Y ) ; return Speed ; }
Hyp: 
double speedOfTrain ( int X , int Y ) { double Speed ; Speed = 1188 * ( ( X - Y ) / Y ) ; return Speed ; }

BLEU: 65.69
Edit Sim: 24


Src: 
function halfsquare ( n , x , y ) { let half = n / 2 ; if ( ( half == x half == x - 1 ) && ( half == y half == y - 1 ) ) document . write ( " " ) ; else document . write ( " " ) ; }
Ref: 
void halfsquare ( int n , int x , int y ) { int half = n / 2 ; if ( ( half == x half == x - 1 ) && ( half == y half == y - 1 ) ) cout << " NO " << endl ; else cout << " YES " << endl ; }
Hyp: 
void halfsquare ( int n , int x , int y ) { int half = n / 2 ; if ( ( half == x half == x - 1 ) && ( half == y half == y - 1 ) ) cout << " Quadrant " ; else cout << " Quadrant " ; }

BLEU: 82.99
Edit Sim: 24


Src: 
function isEqualFactors ( N ) { if ( ( N % 2 == 0 ) && ( N % 4 != 0 ) ) document . write ( " " ) ; else document . write ( " " ) ; }
Ref: 
void isEqualFactors ( lli N ) { if ( ( N % 2 == 0 ) and ( N % 4 != 0 ) ) cout << " YES " << endl ; else cout << " NO " << endl ; }
Hyp: 
void isEqualFactors ( int N ) { if ( ( N % 2 == 0 ) && ( N % 4 != 0 ) ) cout << " YES " ; else cout << " NO " ; }

BLEU: 71.06
Edit Sim: 22


Src: 
function countSubStr ( str , n ) { var len = str . length ; return len - n + 1 ; }
Ref: 
int countSubStr ( string str , int n ) { int len = str . length ( ) ; return ( len - n + 1 ) ; }
Hyp: 
int countSubStr ( string str , int n ) { int len = str . length ( ) ; return len - n + 1 ; }

BLEU: 82.62
Edit Sim: 4


Src: 
function sumOfProd ( arr , N ) { let sum = 0 ; for ( let i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; } return sum * sum ; }
Ref: 
int sumOfProd ( int arr [ ] , int N ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; } return sum * sum ; }
Hyp: 
int sumOfProd ( int arr [ ] , int N ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; } return sum * sum ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function pad ( n ) { let pPrevPrev = 1 ; let pPrev = 1 ; let pCurr = 1 ; let pNext = 1 ; for ( let i = 3 ; i <= n ; i ++ ) { pNext = pPrevPrev + pPrev ; pPrevPrev = pPrev ; pPrev = pCurr ; pCurr = pNext ; } return pNext ; }
Ref: 
int pad ( int n ) { int pPrevPrev = 1 , pPrev = 1 , pCurr = 1 , pNext = 1 ; for ( int i = 3 ; i <= n ; i ++ ) { pNext = pPrevPrev + pPrev ; pPrevPrev = pPrev ; pPrev = pCurr ; pCurr = pNext ; } return pNext ; }
Hyp: 
int pad ( int n ) { int pPrevPrev = 1 ; int pPrev = 1 ; int pCurr = 1 ; int pNext = 1 ; for ( int i = 3 ; i <= n ; i ++ ) { pNext = pPrevPrev + pPrev ; pPrevPrev = pPrev ; pPrev = pCurr ; pCurr = pNext ; } return pNext ; }

BLEU: 83.45
Edit Sim: 15


Src: 
function minCost ( arr , n ) { if ( n < 3 ) { document . write ( arr [ 0 ] ) ; return ; } let dp = [ ] ; dp [ 0 ] = arr [ 0 ] ; dp [ 1 ] = dp [ 0 ] + arr [ 1 ] + arr [ 2 ] ; for ( let i = 2 ; i < n - 1 ; i ++ ) dp [ i ] = Math . min ( dp [ i - 2 ] + arr [ i ] , dp [ i - 1 ] + arr [ i ] + arr [ i + 1 ] ) ; dp [ n - 1 ] = Math . min ( dp [ n - 2 ] , dp [ n - 3 ] + arr [ n - 1 ] ) ; document . write ( dp [ n - 1 ] ) ; }
Ref: 
void minCost ( int arr [ ] , int n ) { if ( n < 3 ) { cout << arr [ 0 ] ; return ; } int * dp = new int [ n ] ; dp [ 0 ] = arr [ 0 ] ; dp [ 1 ] = dp [ 0 ] + arr [ 1 ] + arr [ 2 ] ; for ( int i = 2 ; i < n - 1 ; i ++ ) dp [ i ] = min ( dp [ i - 2 ] + arr [ i ] , dp [ i - 1 ] + arr [ i ] + arr [ i + 1 ] ) ; dp [ n - 1 ] = min ( dp [ n - 2 ] , dp [ n - 3 ] + arr [ n - 1 ] ) ; cout << dp [ n - 1 ] ; }
Hyp: 
void minCost ( int arr [ ] , int n ) { if ( n < 3 ) { cout << arr [ 0 ] ; return ; } int dp [ 3 ] ; dp [ 0 ] = arr [ 0 ] ; dp [ 1 ] = dp [ 0 ] + arr [ 1 ] + arr [ 2 ] ; for ( int i = 2 ; i < n - 1 ; i ++ ) dp [ i ] = min ( dp [ i - 2 ] + arr [ i ] , dp [ i - 1 ] + arr [ i ] + arr [ i + 1 ] ) ; dp [ n - 1 ] = min ( dp [ n - 2 ] , dp [ n - 3 ] + arr [ n - 1 ] ) ; cout << dp [ n - 1 ] ; }

BLEU: 95.1
Edit Sim: 13


Src: 
function findRemainder ( n ) { let l = n % 10 ; while ( n >= 10 ) n /= 10 ; let f = n ; let remainder = f % l ; document . write ( Math . floor ( remainder ) ) ; }
Ref: 
void findRemainder ( int n ) { int l = n % 10 ; while ( n >= 10 ) n /= 10 ; int f = n ; int remainder = f % l ; cout << remainder << endl ; }
Hyp: 
void findRemainder ( int n ) { int l = n % 10 ; while ( n >= 10 ) n /= 10 ; int f = n ; int remainder = f % l ; cout << remainder << endl ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findPeak ( arr , n ) { if ( n == 1 ) return 0 ; if ( arr [ 0 ] >= arr [ 1 ] ) return 0 ; if ( arr [ n - 1 ] >= arr [ n - 2 ] ) return n - 1 ; for ( var i = 1 ; i < n - 1 ; i ++ ) { if ( arr [ i ] >= arr [ i - 1 ] && arr [ i ] >= arr [ i + 1 ] ) return i ; } }
Ref: 
int findPeak ( int arr [ ] , int n ) { if ( n == 1 ) return 0 ; if ( arr [ 0 ] >= arr [ 1 ] ) return 0 ; if ( arr [ n - 1 ] >= arr [ n - 2 ] ) return n - 1 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( arr [ i ] >= arr [ i - 1 ] && arr [ i ] >= arr [ i + 1 ] ) return i ; } }
Hyp: 
int findPeak ( int arr [ ] , int n ) { if ( n == 1 ) return 0 ; if ( arr [ 0 ] >= arr [ 1 ] ) return 0 ; if ( arr [ n - 1 ] >= arr [ n - 2 ] ) return n - 1 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( arr [ i ] >= arr [ i - 1 ] && arr [ i ] >= arr [ i + 1 ] ) return i ; } }

BLEU: 100.0
Edit Sim: 0


Src: 
function minDiff ( arr , n , k ) { var result = Number . MAX_VALUE ; arr . sort ( ( a , b ) => a - b ) ; for ( i = 0 ; i <= n - k ; i ++ ) result = Math . min ( result , arr [ i + k - 1 ] - arr [ i ] ) ; return result ; }
Ref: 
int minDiff ( int arr [ ] , int n , int k ) { int result = INT_MAX ; sort ( arr , arr + n ) ; for ( int i = 0 ; i <= n - k ; i ++ ) result = min ( result , arr [ i + k - 1 ] - arr [ i ] ) ; return result ; }
Hyp: 
int minDiff ( int arr [ ] , int n , int k ) { int result = INT_MAX ; sort ( arr , arr + n ) ; for ( int i = 0 ; i <= n - k ; i ++ ) result = min ( result , arr [ i + k - 1 ] - arr [ i ] ) ; return result ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function centeredoctagonalNumber ( n ) { return 4 * n * ( n - 1 ) + 1 ; }
Ref: 
int cen_octagonalnum ( long int n ) { return ( 4 * n * n - 4 * n + 1 ) ; }
Hyp: 
int centeredoctagonalNumber ( int n ) { return 4 * n * ( n - 1 ) + 1 ; }

BLEU: 36.89
Edit Sim: 22


Src: 
function maxDivision ( arr , n ) { arr . sort ( ( a , b ) => b - a ) ; let mxdiv = arr [ 1 ] ; for ( let i = 2 ; i < n ; ++ i ) mxdiv = mxdiv / arr [ i ] ; return arr [ 0 ] / mxdiv ; }
Ref: 
float maxDivision ( int arr [ ] , int n ) { sort ( arr , arr + n , greater < int > ( ) ) ; float mxdiv = arr [ 1 ] ; for ( int i = 2 ; i < n ; ++ i ) mxdiv = mxdiv / arr [ i ] ; return arr [ 0 ] / mxdiv ; }
Hyp: 
int maxDivision ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int mxdiv = arr [ 1 ] ; for ( int i = 2 ; i < n ; ++ i ) mxdiv = mxdiv / arr [ i ] ; return arr [ 0 ] / mxdiv ; }

BLEU: 82.39
Edit Sim: 30


Src: 
function getString ( N ) { let ans = " " while ( N >= 26 ) { ans += ' ' N -= 26 } ans += String . fromCharCode ( N + ' ' . charCodeAt ( 0 ) - 1 ) return ans }
Ref: 
string getString ( int N ) { string ans = " " ; while ( N >= 26 ) { ans += ' z ' ; N -= 26 ; } ans += char ( N + ' a ' - 1 ) ; return ans ; }
Hyp: 
string getString ( int N ) { string ans = " " ; while ( N >= 26 ) { ans += ' A ' N -= 26 } ans += ' Z ' - 1 ; return ans ; }

BLEU: 63.23
Edit Sim: 19


Src: 
function aredisjoint ( set1 , set2 ) { let i = 0 , j = 0 ; set1 . sort ( function ( a , b ) { return a - b } ) ; set2 . sort ( function ( a , b ) { return a - b } ) ; while ( i < set1 . length && j < set2 . length ) { if ( set1 [ i ] < set2 [ j ] ) i ++ ; else if ( set1 [ i ] > set2 [ j ] ) j ++ ; else return false ; } return true ; }
Ref: 
bool areDisjoint ( int set1 [ ] , int set2 [ ] , int m , int n ) { sort ( set1 , set1 + m ) ; sort ( set2 , set2 + n ) ; int i = 0 , j = 0 ; while ( i < m && j < n ) { if ( set1 [ i ] < set2 [ j ] ) i ++ ; else if ( set2 [ j ] < set1 [ i ] ) j ++ ; else return false ; } return true ; }
Hyp: 
bool aredisjoint ( int set1 [ ] , int set2 [ ] ) { int i = 0 , j = 0 ; sort ( set1 , set1 + 1 ) ; sort ( set2 , set2 + 1 ) ; while ( i < set1 . size ( ) && j < set2 . size ( ) ) { if ( set1 [ i ] < set2 [ j ] ) i ++ ; else if ( set1 [ i ] > set2 [ j ] ) j ++ ; else return false ; } return true ; }

BLEU: 69.72
Edit Sim: 56


Src: 
function getCount ( arr , N ) { var count = 0 ; if ( N < 3 ) return 0 ; for ( var b = 0 ; b < N ; b ++ ) { for ( var a = 0 ; a < N ; a ++ ) { if ( a == b ) continue ; for ( var c = 0 ; c < N ; c ++ ) { if ( c == a c == b ) continue ; var d = arr [ b ] * arr [ b ] / 4 ; if ( arr [ a ] * arr <= d ) count ++ ; } } } return count ; }
Ref: 
int getCount ( int arr [ ] , int N ) { int count = 0 ; if ( N < 3 ) return 0 ; for ( int b = 0 ; b < N ; b ++ ) { for ( int a = 0 ; a < N ; a ++ ) { if ( a == b ) continue ; for ( int c = 0 ; c < N ; c ++ ) { if ( c == a c == b ) continue ; int d = arr [ b ] * arr [ b ] / 4 ; if ( arr [ a ] * arr <= d ) count ++ ; } } } return count ; }
Hyp: 
int getCount ( int arr [ ] , int N ) { int count = 0 ; if ( N < 3 ) return 0 ; for ( int b = 0 ; b < N ; b ++ ) { for ( int a = 0 ; a < N ; a ++ ) { if ( a == b ) continue ; for ( int c = 0 ; c < N ; c ++ ) { if ( c == a c == b ) continue ; int d = arr [ b ] * arr [ b ] / 4 ; if ( arr [ a ] * arr <= d ) count ++ ; } } } return count ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countOccurrences ( S , X , Y ) { let count = 0 ; let N = S . length , A = X . length ; let B = Y . length ; for ( let i = 0 ; i < N ; i ++ ) { if ( S . substr ( i , B ) == Y ) count ++ ; if ( S . substr ( i , A ) == X ) document . write ( count , " " ) ; } }
Ref: 
void countOccurrences ( string S , string X , string Y ) { int count = 0 ; int N = S . length ( ) , A = X . length ( ) ; int B = Y . length ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( S . substr ( i , B ) == Y ) count ++ ; if ( S . substr ( i , A ) == X ) cout << count << " ▁ " ; } }
Hyp: 
void countOccurrences ( string S , string X , string Y ) { int count = 0 , N = S . size ( ) , A = X . size ( ) , B = Y . size ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( S . substr ( i , B ) == Y ) count ++ ; if ( S . substr ( i , A ) == X ) cout << count << " ▁ " ; } }

BLEU: 85.13
Edit Sim: 28


Src: 
function summation ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { if ( i % 2 == 1 ) sum += ( i * i ) ; else sum -= ( i * i ) ; } return sum ; }
Ref: 
int summation ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i % 2 == 1 ) sum += ( i * i ) ; else sum -= ( i * i ) ; } return sum ; }
Hyp: 
int summation ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i % 2 == 1 ) sum += ( i * i ) ; else sum -= ( i * i ) ; } return sum ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function minCost ( costs , N ) { if ( N == 0 ) return 0 ; let dp = new Array ( N ) ; for ( let i = 0 ; i < N ; i ++ ) { dp [ i ] = new Array ( 3 ) ; for ( let j = 0 ; j < 3 ; j ++ ) { dp [ i ] [ j ] = 0 ; } } dp [ 0 ] [ 0 ] = costs [ 0 ] [ 0 ] ; dp [ 0 ] [ 1 ] = costs [ 0 ] [ 1 ] ; dp [ 0 ] [ 2 ] = costs [ 0 ] [ 2 ] ; for ( let i = 1 ; i < N ; i ++ ) { dp [ i ] [ 0 ] = Math . min ( dp [ i - 1 ] [ 1 ] , dp [ i - 1 ] [ 2 ] ) + costs [ i ] [ 0 ] ; dp [ i ] [ 1 ] = Math . min ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 2 ] ) + costs [ i ] [ 1 ] ; dp [ i ] [ 2 ] = Math . min ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] ) + costs [ i ] [ 2 ] ; } document . write ( Math . min ( dp [ N - 1 ] [ 0 ] , Math . min ( dp [ N - 1 ] [ 1 ] , dp [ N - 1 ] [ 2 ] ) ) ) ; }
Ref: 
int minCost ( vector < vector < int > > & costs , int N ) { if ( N == 0 ) return 0 ; vector < vector < int > > dp ( N , vector < int > ( 3 , 0 ) ) ; dp [ 0 ] [ 0 ] = costs [ 0 ] [ 0 ] ; dp [ 0 ] [ 1 ] = costs [ 0 ] [ 1 ] ; dp [ 0 ] [ 2 ] = costs [ 0 ] [ 2 ] ; for ( int i = 1 ; i < N ; i ++ ) { dp [ i ] [ 0 ] = min ( dp [ i - 1 ] [ 1 ] , dp [ i - 1 ] [ 2 ] ) + costs [ i ] [ 0 ] ; dp [ i ] [ 1 ] = min ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 2 ] ) + costs [ i ] [ 1 ] ; dp [ i ] [ 2 ] = min ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] ) + costs [ i ] [ 2 ] ; } cout << min ( dp [ N - 1 ] [ 0 ] , min ( dp [ N - 1 ] [ 1 ] , dp [ N - 1 ] [ 2 ] ) ) ; }
Hyp: 
int minCost ( int costs [ ] [ 3 ] , int N ) { if ( N == 0 ) return 0 ; int dp [ N + 1 ] [ 3 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; dp [ 0 ] [ 0 ] = costs [ 0 ] [ 0 ] ; dp [ 0 ] [ 1 ] = costs [ 0 ] [ 1 ] ; dp [ 0 ] [ 2 ] = costs [ 0 ] [ 2 ] ; for ( int i = 1 ; i < N ; i ++ ) { dp [ i ] [ 0 ] = min ( dp [ i - 1 ] [ 1 ] , dp [ i - 1 ] [ 2 ] ) + costs [ i ] [ 0 ] ; dp [ i ] [ 1 ] = min ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 2 ] ) + costs [ i ] [ 1 ] ; dp [ i ] [ 2 ] = min ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] ) + costs [ i ] [ 2 ] ; } cout << min ( dp [ N - 1 ] [ 0 ] , min ( dp [ N - 1 ] [ 1 ] , dp [ N - 1 ] [ 2 ] ) ) ; }

BLEU: 89.49
Edit Sim: 67


Src: 
function minvalue_y ( x ) { let n = Math . floor ( Math . sqrt ( x ) ) ; if ( n * n == x ) return x + 1 ; return Math . floor ( Math . pow ( n + 1 , 2 ) ) ; }
Ref: 
int minvalue_y ( int x ) { int n = sqrt ( x ) ; if ( n * n == x ) return x + 1 ; return pow ( n + 1 , 2 ) ; }
Hyp: 
int minvalue_y ( int x ) { int n = sqrt ( x ) ; if ( n * n == x ) return x + 1 ; return pow ( n + 1 , 2 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findTriplet ( a1 , a2 , a3 , n1 , n2 , n3 , sum ) { for ( var i = 0 ; i < n1 ; i ++ ) for ( var j = 0 ; j < n2 ; j ++ ) for ( var k = 0 ; k < n3 ; k ++ ) if ( a1 [ i ] + a2 [ j ] + a3 [ k ] == sum ) return true ; return false ; }
Ref: 
bool findTriplet ( int a1 [ ] , int a2 [ ] , int a3 [ ] , int n1 , int n2 , int n3 , int sum ) { for ( int i = 0 ; i < n1 ; i ++ ) for ( int j = 0 ; j < n2 ; j ++ ) for ( int k = 0 ; k < n3 ; k ++ ) if ( a1 [ i ] + a2 [ j ] + a3 [ k ] == sum ) return true ; return false ; }
Hyp: 
bool findTriplet ( int a1 [ ] , int a2 [ ] , int a3 [ ] , int n1 , int n2 , int n3 , int sum ) { for ( int i = 0 ; i < n1 ; i ++ ) for ( int j = 0 ; j < n2 ; j ++ ) for ( int k = 0 ; k < n3 ; k ++ ) if ( a1 [ i ] + a2 [ j ] + a3 [ k ] == sum ) return true ; return false ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function cntSubSeq ( arr , n ) { var pos_count = 0 ; var neg_count = 0 ; var result ; for ( var i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 ) pos_count ++ ; if ( arr [ i ] < 0 ) neg_count ++ ; } result = Math . pow ( 2 , pos_count ) ; if ( neg_count > 0 ) result *= Math . pow ( 2 , neg_count - 1 ) ; else result = 0 ; return result ; }
Ref: 
int cntSubSeq ( int arr [ ] , int n ) { int pos_count = 0 ; int neg_count = 0 ; int result ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 ) pos_count ++ ; if ( arr [ i ] < 0 ) neg_count ++ ; } result = pow ( 2 , pos_count ) ; if ( neg_count > 0 ) result *= pow ( 2 , neg_count - 1 ) ; else result = 0 ; return result ; }
Hyp: 
int cntSubSeq ( int arr [ ] , int n ) { int pos_count = 0 ; int neg_count = 0 ; int result ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 ) pos_count ++ ; if ( arr [ i ] < 0 ) neg_count ++ ; } result = pow ( 2 , pos_count ) ; if ( neg_count > 0 ) result *= pow ( 2 , neg_count - 1 ) ; else result = 0 ; return result ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countStrings ( n , k ) { let dp = new Array ( n + 1 ) ; for ( let i = 0 ; i < n + 1 ; i ++ ) { dp [ i ] = new Array ( k + 1 ) ; for ( let j = 0 ; j < k + 1 ; j ++ ) { dp [ i ] [ j ] = new Array ( 2 ) ; for ( let l = 0 ; l < 2 ; l ++ ) { dp [ i ] [ j ] [ l ] = 0 ; } } } dp [ 1 ] [ 0 ] [ 0 ] = 1 ; dp [ 1 ] [ 0 ] [ 1 ] = 1 ; for ( let i = 2 ; i <= n ; i ++ ) { for ( let j = 0 ; j < i && j < k + 1 ; j ++ ) { dp [ i ] [ j ] [ 0 ] = dp [ i - 1 ] [ j ] [ 0 ] + dp [ i - 1 ] [ j ] [ 1 ] ; dp [ i ] [ j ] [ 1 ] = dp [ i - 1 ] [ j ] [ 0 ] ; if ( j - 1 >= 0 ) { dp [ i ] [ j ] [ 1 ] += dp [ i - 1 ] [ j - 1 ] [ 1 ] ; } } } return dp [ n ] [ k ] [ 0 ] + dp [ n ] [ k ] [ 1 ] ; }
Ref: 
int countStrings ( int n , int k ) { int dp [ n + 1 ] [ k + 1 ] [ 2 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; dp [ 1 ] [ 0 ] [ 0 ] = 1 ; dp [ 1 ] [ 0 ] [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= k ; j ++ ) { dp [ i ] [ j ] [ 0 ] = dp [ i - 1 ] [ j ] [ 0 ] + dp [ i - 1 ] [ j ] [ 1 ] ; dp [ i ] [ j ] [ 1 ] = dp [ i - 1 ] [ j ] [ 0 ] ; if ( j - 1 >= 0 ) dp [ i ] [ j ] [ 1 ] += dp [ i - 1 ] [ j - 1 ] [ 1 ] ; } } return dp [ n ] [ k ] [ 0 ] + dp [ n ] [ k ] [ 1 ] ; }
Hyp: 
long countStrings ( int n , int k ) { long dp [ n + 1 ] [ k + 1 ] [ 2 ] ; dp [ 0 ] [ 0 ] = 1 ; dp [ 1 ] [ 0 ] [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 0 ; j < i && j < k + 1 ; j ++ ) { dp [ i ] [ j ] [ 0 ] = dp [ i - 1 ] [ j ] [ 0 ] + dp [ i - 1 ] [ j ] [ 1 ] ; dp [ i ] [ j ] [ 1 ] = dp [ i - 1 ] [ j ] [ 0 ] ; if ( j - 1 >= 0 ) { dp [ i ] [ j ] [ 1 ] += dp [ i - 1 ] [ j - 1 ] [ 1 ] ; } } } return dp [ n ] [ k ] [ 0 ] + dp [ n ] [ k ] [ 1 ] ; }

BLEU: 88.36
Edit Sim: 65


Src: 
function addASCII ( S , N ) { var newStr = new Array ( S . length ) ; for ( var i = 0 ; i < S . length ; i ++ ) { var a = N [ i ] . charCodeAt ( 0 ) - " " . charCodeAt ( 0 ) ; var b = S [ i ] . charCodeAt ( 0 ) + a ; if ( b > 122 ) b -= 26 ; newStr [ i ] = String . fromCharCode ( b ) ; } document . write ( newStr . join ( " " ) ) ; }
Ref: 
void addASCII ( string S , string N ) { for ( int i = 0 ; i < S . size ( ) ; i ++ ) { int a = int ( N [ i ] ) - '0' ; int b = int ( S [ i ] ) + a ; if ( b > 122 ) b -= 26 ; S [ i ] = char ( b ) ; } cout << S ; }
Hyp: 
void addASCII ( string S , string N ) { string newStr [ S . length ( ) ] ; for ( int i = 0 ; i < S . length ( ) ; i ++ ) { int a = N [ i ] - ' a ' ; int b = S [ i ] + a ; if ( b > 122 ) b -= 26 ; newStr [ i ] = char ( b ) ; } cout << newStr ; }

BLEU: 66.72
Edit Sim: 69


Src: 
function lengthOfLatusRectum ( A , B ) { var major = 2.0 * A ; var minor = 2.0 * B ; var latus_rectum = ( minor * minor ) / major ; return latus_rectum ; }
Ref: 
double lengthOfLatusRectum ( double A , double B ) { double major = 2.0 * A ; double minor = 2.0 * B ; double latus_rectum = ( minor * minor ) / major ; return latus_rectum ; }
Hyp: 
double lengthOfLatusRectum ( int A , int B ) { double major = 2.0 * A ; double minor = 2.0 * B ; double latus_rectum = ( minor * minor ) / major ; return latus_rectum ; }

BLEU: 87.35
Edit Sim: 12


Src: 
function productAscii ( str ) { var prod = 1 ; for ( i = 0 ; i < str . length ; i ++ ) { prod *= str . charAt ( i ) . charCodeAt ( 0 ) ; } return prod ; }
Ref: 
long productAscii ( string str ) { long long prod = 1 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { prod *= ( int ) str [ i ] ; } return prod ; }
Hyp: 
int productAscii ( string str ) { int prod = 1 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { prod *= str [ i ] ; } return prod ; }

BLEU: 80.57
Edit Sim: 19


Src: 
function distinctSubString ( P , Q , K , N ) { let S = new Set ( ) ; for ( let i = 0 ; i < N ; ++ i ) { let sum = 0 ; let s = " " ; for ( let j = i ; j < N ; ++ j ) { let pos = P [ j ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ; sum += Q [ pos ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ; s += P [ j ] ; if ( sum <= K ) { S . add ( s ) ; } else { break ; } } } return S . size ; }
Ref: 
int distinctSubstring ( string & P , string & Q , int K , int N ) { unordered_set < string > S ; for ( int i = 0 ; i < N ; ++ i ) { int sum = 0 ; string s ; for ( int j = i ; j < N ; ++ j ) { int pos = P [ j ] - ' a ' ; sum += Q [ pos ] - '0' ; s += P [ j ] ; if ( sum <= K ) { S . insert ( s ) ; } else { break ; } } } return S . size ( ) ; }
Hyp: 
int distinctSubstring ( string & P , string & Q , int K , int N ) { unordered_set < string > S ; for ( int i = 0 ; i < N ; ++ i ) { int sum = 0 ; string s ; for ( int j = i ; j < N ; ++ j ) { int pos = P [ j ] - ' a ' ; sum += Q [ pos ] - ' a ' ; s += P [ j ] ; if ( sum <= K ) { S . insert ( s ) ; } else { break ; } } } return S . size ( ) ; }

BLEU: 96.28
Edit Sim: 3


Src: 
function printAllAPTriplets ( arr , n ) { const s = new Set ( ) for ( let i = 0 ; i < n - 1 ; i ++ ) { for ( let j = i + 1 ; j < n ; j ++ ) { let diff = arr [ j ] - arr [ i ] ; if ( s . has ( arr [ i ] - diff ) ) document . write ( arr [ i ] - diff + " " + arr [ i ] + " " + arr [ j ] + " " ) ; } s . add ( arr [ i ] ) ; } }
Ref: 
void printAllAPTriplets ( int arr [ ] , int n ) { unordered_set < int > s ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int diff = arr [ j ] - arr [ i ] ; if ( s . find ( arr [ i ] - diff ) != s . end ( ) ) cout << arr [ i ] - diff << " ▁ " << arr [ i ] << " ▁ " << arr [ j ] << endl ; } s . insert ( arr [ i ] ) ; } }
Hyp: 
void printAllAPTriplets ( int arr [ ] , int n ) { unordered_set < int > s ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int diff = arr [ j ] - arr [ i ] ; if ( s . find ( arr [ i ] - diff ) != s . end ( ) ) cout << arr [ i ] - diff << " ▁ " << arr [ i ] << " ▁ " << arr [ j ] << " ▁ " ; } s . insert ( arr [ i ] ) ; } }

BLEU: 96.49
Edit Sim: 5


Src: 
function maximizeExpression ( a , b ) { let result = a ; for ( let bit = MAX - 1 ; bit >= 0 ; bit -- ) { let bitOfD = 1 << bit ; let x = b & bitOfD ; if ( x == bitOfD ) { let y = result & bitOfD ; if ( y == 0 ) { result = result ^ bitOfD ; } } } return result ; }
Ref: 
int maximizeExpression ( int a , int b ) { int result = a ; for ( int bit = MAX - 1 ; bit >= 0 ; bit -- ) { int bitOfD = 1 << bit ; int x = b & bitOfD ; if ( x == bitOfD ) { int y = result & bitOfD ; if ( y == 0 ) { result = result ^ bitOfD ; } } } return result ; }
Hyp: 
int maximizeExpression ( int a , int b ) { int result = a ; for ( int bit = MAX - 1 ; bit >= 0 ; bit -- ) { int bitOfD = 1 << bit ; int x = b & bitOfD ; if ( x == bitOfD ) { int y = result & bitOfD ; if ( y == 0 ) { result = result ^ bitOfD ; } } } return result ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countIntersections ( n ) { return n * ( n - 1 ) / 2 ; }
Ref: 
int countIntersections ( int n ) { return n * ( n - 1 ) / 2 ; }
Hyp: 
ll countIntersections ( ll n ) { return n * ( n - 1 ) / 2 ; }

BLEU: 81.94
Edit Sim: 6


Src: 
function closestMultiple ( n , x ) { if ( x > n ) return x ; n = n + parseInt ( x / 2 , 10 ) ; n = n - ( n % x ) ; return n ; }
Ref: 
int closestMultiple ( int n , int x ) { if ( x > n ) return x ; n = n + x / 2 ; n = n - ( n % x ) ; return n ; }
Hyp: 
int closestMultiple ( int n , int x ) { if ( x > n ) return x ; n = n + x / 2 ; n = n - ( n % x ) ; return n ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function numberOfPaths ( m , n ) { if ( m == 1 n == 1 ) return 1 ; return numberOfPaths ( m - 1 , n ) + numberOfPaths ( m , n - 1 ) ; }
Ref: 
int numberOfPaths ( int m , int n ) { if ( m == 1 n == 1 ) return 1 ; return numberOfPaths ( m - 1 , n ) + numberOfPaths ( m , n - 1 ) ; }
Hyp: 
int numberOfPaths ( int m , int n ) { if ( m == 1 n == 1 ) return 1 ; return numberOfPaths ( m - 1 , n ) + numberOfPaths ( m , n - 1 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function Identity ( num ) { var row ; var col ; for ( row = 0 ; row < num ; row ++ ) { for ( col = 0 ; col < num ; col ++ ) { if ( row == col ) document . write ( 1 + " " ) ; else document . write ( 0 + " " ) ; } document . write ( " " + " " ) ; } return 0 ; }
Ref: 
int Identity ( int num ) { int row , col ; for ( row = 0 ; row < num ; row ++ ) { for ( col = 0 ; col < num ; col ++ ) { if ( row == col ) cout << 1 << " ▁ " ; else cout << 0 << " ▁ " ; } cout << endl ; } return 0 ; }
Hyp: 
int Identity ( int num ) { int row ; int col ; for ( row = 0 ; row < num ; row ++ ) { for ( col = 0 ; col < num ; col ++ ) { if ( row == col ) cout << 1 << " ▁ " ; else cout << 0 << " ▁ " ; } cout << " STRNEWLINE " << endl ; } return 0 ; }

BLEU: 89.28
Edit Sim: 23


Src: 
function count_special ( n ) { var fib = [ ... Array ( n + 1 ) ] ; fib [ 0 ] = 1 ; fib [ 1 ] = 2 ; for ( var i = 2 ; i <= n ; i ++ ) { fib [ i ] = ( ( fib [ i - 1 ] % mod ) + ( fib [ i - 2 ] % mod ) ) % mod ; } return fib [ n ] ; }
Ref: 
long count_special ( long n ) { long fib [ n + 1 ] ; fib [ 0 ] = 1 ; fib [ 1 ] = 2 ; for ( int i = 2 ; i <= n ; i ++ ) { fib [ i ] = ( fib [ i - 1 ] % mod + fib [ i - 2 ] % mod ) % mod ; } return fib [ n ] ; }
Hyp: 
int count_special ( int n ) { int fib [ n + 1 ] ; fib [ 0 ] = 1 ; fib [ 1 ] = 2 ; for ( int i = 2 ; i <= n ; i ++ ) { fib [ i ] = ( ( fib [ i - 1 ] % mod ) + ( fib [ i - 2 ] % mod ) ) % mod ; } return fib [ n ] ; }

BLEU: 83.32
Edit Sim: 17


Src: 
function maxSelections ( A , n , k ) { A . sort ( ) ; let sum = 0 ; let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { sum = sum + A [ i ] ; if ( sum > k ) { break ; } count ++ ; } return count ; }
Ref: 
int maxSelections ( int A [ ] , int n , int k ) { sort ( A , A + n ) ; int sum = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + A [ i ] ; if ( sum > k ) { break ; } count ++ ; } return count ; }
Hyp: 
int maxSelections ( int A [ ] , int n , int k ) { sort ( A , A + n ) ; int sum = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + A [ i ] ; if ( sum > k ) { break ; } count ++ ; } return count ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function arraySum ( arr , n ) { let x = ( n + 1 ) / 2 ; return ( arr [ 0 ] - 1 ) * n + x * x ; }
Ref: 
int arraySum ( int arr [ ] , int n ) { int x = ( n + 1 ) / 2 ; return ( arr [ 0 ] - 1 ) * n + x * x ; }
Hyp: 
int arraySum ( int arr [ ] , int n ) { int x = ( n + 1 ) / 2 ; return ( arr [ 0 ] - 1 ) * n + x * x ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function mininsert ( arr , K , N ) { var ans = 0 ; for ( i = 0 ; i < N - 1 ; i ++ ) { var a = Math . min ( arr [ i ] , arr [ i + 1 ] ) ; var b = Math . max ( arr [ i ] , arr [ i + 1 ] ) ; while ( K * a < b ) { a *= K ; ans ++ ; } } return ans ; }
Ref: 
int mininsert ( int arr [ ] , int K , int N ) { int ans = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { int a = min ( arr [ i ] , arr [ i + 1 ] ) ; int b = max ( arr [ i ] , arr [ i + 1 ] ) ; while ( K * a < b ) { a *= K ; ans ++ ; } } return ans ; }
Hyp: 
int mininsert ( int arr [ ] , int K , int N ) { int ans = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { int a = min ( arr [ i ] , arr [ i + 1 ] ) ; int b = max ( arr [ i ] , arr [ i + 1 ] ) ; while ( K * a < b ) { a *= K ; ans ++ ; } } return ans ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function sum ( h ) { return Math . pow ( 2 , h - 1 ) ; }
Ref: 
int sum ( int h ) { return pow ( 2 , h - 1 ) ; }
Hyp: 
int sum ( int h ) { return pow ( 2 , h - 1 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countInscribed ( R1 , R2 ) { if ( R2 > R1 ) return 0 ; let angle ; let ratio ; let number_of_circles = 0 ; ratio = R2 / ( R1 - R2 ) ; if ( R1 < 2 * R2 ) { number_of_circles = 1 ; } else { angle = Math . abs ( Math . asin ( ratio ) * 180 ) / 3.14159265 ; number_of_circles = 360 / ( 2 * Math . floor ( angle ) ) ; } return number_of_circles ; }
Ref: 
int countInscribed ( int R1 , int R2 ) { if ( R2 > R1 ) return 0 ; double angle ; double ratio ; int number_of_circles = 0 ; ratio = R2 / ( double ) ( R1 - R2 ) ; if ( R1 < 2 * R2 ) { number_of_circles = 1 ; } else { angle = abs ( asin ( ratio ) * 180 ) / 3.14159265 ; number_of_circles = 360 / ( 2 * floor ( angle ) ) ; } return number_of_circles ; }
Hyp: 
int countInscribed ( int R1 , int R2 ) { if ( R2 > R1 ) return 0 ; int angle ; int ratio ; int number_of_circles ; ratio = R2 / ( R1 - R2 ) ; if ( R1 < 2 * R2 ) { number_of_circles = 1 ; } else { angle = abs ( asin ( ratio ) * 180 ) / 3.14159265 ; number_of_circles = 360 / ( 2 * floor ( angle ) ) ; } return number_of_circles ; }

BLEU: 86.46
Edit Sim: 27


Src: 
function MatrixChainOrder ( p , n ) { var m = Array ( n ) . fill ( 0 ) . map ( x => Array ( n ) . fill ( 0 ) ) ; var i , j , k , L , q ; for ( i = 1 ; i < n ; i ++ ) m [ i ] [ i ] = 0 ; for ( L = 2 ; L < n ; L ++ ) { for ( i = 1 ; i < n - L + 1 ; i ++ ) { j = i + L - 1 ; if ( j == n ) continue ; m [ i ] [ j ] = Number . MAX_VALUE ; for ( k = i ; k <= j - 1 ; k ++ ) { q = m [ i ] [ k ] + m [ k + 1 ] [ j ] + p [ i - 1 ] * p [ k ] * p [ j ] ; if ( q < m [ i ] [ j ] ) m [ i ] [ j ] = q ; } } } return m [ 1 ] [ n - 1 ] ; }
Ref: 
int MatrixChainOrder ( int p [ ] , int n ) { int m [ n ] [ n ] ; int i , j , k , L , q ; for ( i = 1 ; i < n ; i ++ ) m [ i ] [ i ] = 0 ; for ( L = 2 ; L < n ; L ++ ) { for ( i = 1 ; i < n - L + 1 ; i ++ ) { j = i + L - 1 ; m [ i ] [ j ] = INT_MAX ; for ( k = i ; k <= j - 1 ; k ++ ) { q = m [ i ] [ k ] + m [ k + 1 ] [ j ] + p [ i - 1 ] * p [ k ] * p [ j ] ; if ( q < m [ i ] [ j ] ) m [ i ] [ j ] = q ; } } } return m [ 1 ] [ n - 1 ] ; }
Hyp: 
int MatrixChainOrder ( int p [ ] , int n ) { int m [ n ] [ n ] ; int i , j , k , L , q ; for ( i = 1 ; i < n ; i ++ ) m [ i ] [ i ] = 0 ; for ( L = 2 ; L < n ; L ++ ) { for ( i = 1 ; i < n - L + 1 ; i ++ ) { j = i + L - 1 ; if ( j == n ) continue ; m [ i ] [ j ] = INT_MAX ; for ( k = i ; k <= j - 1 ; k ++ ) { q = m [ i ] [ k ] + m [ k + 1 ] [ j ] + p [ i - 1 ] * p [ k ] * p [ j ] ; if ( q < m [ i ] [ j ] ) m [ i ] [ j ] = q ; } } } return m [ 1 ] [ n - 1 ] ; }

BLEU: 95.68
Edit Sim: 25


Src: 
function findKthGoodNo ( n ) { let lastDig = n % 10 ; if ( lastDig >= 0 && lastDig <= 4 ) return n << 1 ; else return ( n << 1 ) + 1 ; }
Ref: 
int findKthGoodNo ( long long int n ) { int lastDig = n % 10 ; if ( lastDig >= 0 && lastDig <= 4 ) return n << 1 ; else return ( n << 1 ) + 1 ; }
Hyp: 
int findKthGoodNo ( int n ) { int lastDig = n % 10 ; if ( lastDig >= 0 && lastDig <= 4 ) return n << 1 ; else return ( n << 1 ) + 1 ; }

BLEU: 91.39
Edit Sim: 10


Src: 
function numPrimeArrangements ( n ) { var prime = Array . from ( { length : n + 1 } , ( _ , i ) => true ) ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( var i = 2 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( prime [ i ] ) for ( factor = 2 ; factor * i <= n ; factor ++ ) prime [ factor * i ] = false ; } var primeIndices = 0 ; for ( var i = 1 ; i <= n ; i ++ ) if ( prime [ i ] ) primeIndices ++ ; var mod = parseInt ( ( 1e9 + 7 ) ) , res = 1 ; for ( var i = 1 ; i <= primeIndices ; i ++ ) res = ( ( 1 * res * i ) % mod ) ; for ( var i = 1 ; i <= ( n - primeIndices ) ; i ++ ) res = ( ( 1 * res * i ) % mod ) ; return res ; }
Ref: 
int numPrimeArrangements ( int n ) { vector < bool > prime ( n + 1 , true ) ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int i = 2 ; i <= sqrt ( n ) ; i ++ ) { if ( prime [ i ] ) for ( int factor = 2 ; factor * i <= n ; factor ++ ) prime [ factor * i ] = false ; } int primeIndices = 0 ; for ( int i = 1 ; i <= n ; i ++ ) if ( prime [ i ] ) primeIndices ++ ; int mod = 1e9 + 7 , res = 1 ; for ( int i = 1 ; i <= primeIndices ; i ++ ) res = ( 1LL * res * i ) % mod ; for ( int i = 1 ; i <= ( n - primeIndices ) ; i ++ ) res = ( 1LL * res * i ) % mod ; return res ; }
Hyp: 
int numPrimeArrangements ( int n ) { bool prime [ n + 1 ] ; memset ( prime , false , sizeof ( prime ) ) ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int i = 2 ; i <= sqrt ( n ) ; i ++ ) { if ( prime [ i ] ) for ( int factor = 2 ; factor * i <= n ; factor ++ ) prime [ factor * i ] = false ; } int primeIndices = 0 ; for ( int i = 1 ; i <= n ; i ++ ) if ( prime [ i ] ) primeIndices ++ ; int mod = 1e9 + 7 ; int res = 1 ; for ( int i = 1 ; i <= primeIndices ; i ++ ) res = ( ( 1 * res * i ) % mod ) ; for ( int i = 1 ; i <= ( n - primeIndices ) ; i ++ ) res = ( ( 1 * res * i ) % mod ) ; return res ; }

BLEU: 83.41
Edit Sim: 61


Src: 
function printhexa ( n ) { if ( n < 0 ) return ; let first = 0 ; let second = 0 ; let third = 0 ; let fourth = 0 ; let fifth = 0 ; let sixth = 1 ; let curr = 0 ; if ( n < 6 ) document . write ( first ) ; else if ( n == 6 ) document . write ( sixth ) ; else { for ( let i = 6 ; i < n ; i ++ ) { curr = first + second + third + fourth + fifth + sixth ; first = second ; second = third ; third = fourth ; fourth = fifth ; fifth = sixth ; sixth = curr ; } } document . write ( curr ) ; }
Ref: 
void printhexa ( int n ) { if ( n < 0 ) return ; int first = 0 ; int second = 0 ; int third = 0 ; int fourth = 0 ; int fifth = 0 ; int sixth = 1 ; int curr = 0 ; if ( n < 6 ) cout << first << endl ; else if ( n == 6 ) cout << sixth << endl ; else { for ( int i = 6 ; i < n ; i ++ ) { curr = first + second + third + fourth + fifth + sixth ; first = second ; second = third ; third = fourth ; fourth = fifth ; fifth = sixth ; sixth = curr ; } } cout << curr << endl ; }
Hyp: 
void printthexa ( int n ) { if ( n < 0 ) return ; int first = 0 ; int second = 0 ; int third = 0 ; int fourth = 0 ; int fifth = 0 ; int sixth = 1 ; int curr = 0 ; if ( n < 6 ) cout << first ; else if ( n == 6 ) cout << sixth ; else { for ( int i = 6 ; i < n ; i ++ ) { curr = first + second + third + fourth + fifth + sixth ; first = second ; second = third ; third = fourth ; fourth = fifth ; fifth = sixth ; sixth = curr ; } } cout << curr ; }

BLEU: 91.21
Edit Sim: 25


Src: 
function count_elements ( arr , n ) { let count = 1 ; let max = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > max ) { count += 1 ; max = arr [ i ] ; } } return count ; }
Ref: 
int count_elements ( int arr [ ] , int n ) { int count = 1 ; int max = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > max ) { count += 1 ; max = arr [ i ] ; } } return count ; }
Hyp: 
int count_elements ( int arr [ ] , int n ) { int count = 1 ; int max = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > max ) { count += 1 ; max = arr [ i ] ; } } return count ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findMinLength ( arr , N ) { let front = 0 , back = N - 1 ; while ( front < back ) { let x = arr [ front ] ; if ( arr [ front ] != arr [ back ] ) break ; while ( arr [ front ] == x && front <= back ) front ++ ; while ( arr [ back ] == x && front <= back ) back -- ; } document . write ( back - front + 1 ) ; document . write ( " " ) ; }
Ref: 
void findMinLength ( int arr [ ] , int N ) { int front = 0 , back = N - 1 ; while ( front < back ) { int x = arr [ front ] ; if ( arr [ front ] != arr [ back ] ) break ; while ( arr [ front ] == x && front <= back ) front ++ ; while ( arr [ back ] == x && front <= back ) back -- ; } cout << back - front + 1 << endl ; }
Hyp: 
void findMinLength ( int arr [ ] , int N ) { int front = 0 , back = N - 1 ; while ( front < back ) { int x = arr [ front ] ; if ( arr [ front ] != arr [ back ] ) break ; while ( arr [ front ] == x && front <= back ) front ++ ; while ( arr [ back ] == x && front <= back ) back -- ; } cout << back - front + 1 ; cout << " STRNEWLINE " ; }

BLEU: 92.94
Edit Sim: 21


Src: 
function findNumbers ( N , M ) { let m = M ; let remLen = new Map ( ) ; let len , remainder = 0 ; for ( len = 1 ; len <= N + 1 ; ++ len ) { remainder = M % N ; if ( ! remLen . has ( remainder ) ) { remLen . set ( remainder , len ) ; } else { break ; } M = M * 10 + m ; M = M % N ; } let LenA = len ; let LenB = remLen . get ( remainder ) ; for ( let i = 0 ; i < LenB ; ++ i ) document . write ( m ) ; document . write ( " " ) ; for ( let i = 0 ; i < LenA ; ++ i ) document . write ( m ) ; }
Ref: 
void findNumbers ( int N , int M ) { int m = M ; map < int , int > remLen ; int len , remainder ; for ( len = 1 ; len <= N + 1 ; ++ len ) { remainder = M % N ; if ( remLen . find ( remainder ) == remLen . end ( ) ) remLen [ remainder ] = len ; else break ; M = M * 10 + m ; M = M % N ; } int LenA = len ; int LenB = remLen [ remainder ] ; for ( int i = 0 ; i < LenB ; ++ i ) cout << m ; cout << " ▁ " ; for ( int i = 0 ; i < LenA ; ++ i ) cout << m ; return ; }
Hyp: 
void findNumbers ( int N , int M ) { int m = M ; unordered_map < int , int > remLen ; int len , remainder = 0 ; for ( len = 1 ; len <= N + 1 ; ++ len ) { remainder = M % N ; if ( remLen . find ( remainder ) == remLen . end ( ) ) { remLen [ remainder ] = len ; } else { break ; } M = M * 10 + m ; M = M % N ; } int LenA = len ; int LenB = remLen [ remainder ] ; for ( int i = 0 ; i < LenB ; ++ i ) cout << m ; cout << " ▁ " ; for ( int i = 0 ; i < LenA ; ++ i ) cout << m ; }

BLEU: 89.65
Edit Sim: 31


Src: 
function countWays ( n ) { if ( n == 0 ) return 1 ; if ( n <= 2 ) return n ; let f0 = 1 , f1 = 1 , f2 = 2 ; let ans = 0 ; for ( let i = 3 ; i <= n ; i ++ ) { ans = f0 + f1 + f2 ; f0 = f1 ; f1 = f2 ; f2 = ans ; } return ans ; }
Ref: 
int countWays ( int n ) { if ( n == 0 ) return 1 ; if ( n <= 2 ) return n ; int f0 = 1 , f1 = 1 , f2 = 2 , ans ; for ( int i = 3 ; i <= n ; i ++ ) { ans = f0 + f1 + f2 ; f0 = f1 ; f1 = f2 ; f2 = ans ; } return ans ; }
Hyp: 
int countWays ( int n ) { if ( n == 0 ) return 1 ; if ( n <= 2 ) return n ; int f0 = 1 , f1 = 1 , f2 = 2 ; int ans = 0 ; for ( int i = 3 ; i <= n ; i ++ ) { ans = f0 + f1 + f2 ; f0 = f1 ; f1 = f2 ; f2 = ans ; } return ans ; }

BLEU: 92.38
Edit Sim: 9


Src: 
function quadrant ( x , y ) { if ( x > 0 && y > 0 ) document . write ( " " ) ; else if ( x < 0 && y > 0 ) document . write ( " " ) ; else if ( x < 0 && y < 0 ) document . write ( " " ) ; else if ( x > 0 && y < 0 ) document . write ( " " ) ; else if ( x == 0 && y > 0 ) document . write ( " " ) ; else if ( x == 0 && y < 0 ) document . write ( " " ) ; else if ( y == 0 && x < 0 ) document . write ( " " ) ; else if ( y == 0 && x > 0 ) document . write ( " " ) ; else document . write ( " " ) ; }
Ref: 
void quadrant ( int x , int y ) { if ( x > 0 and y > 0 ) cout << " lies ▁ in ▁ First ▁ quadrant " ; else if ( x < 0 and y > 0 ) cout << " lies ▁ in ▁ Second ▁ quadrant " ; else if ( x < 0 and y < 0 ) cout << " lies ▁ in ▁ Third ▁ quadrant " ; else if ( x > 0 and y < 0 ) cout << " lies ▁ in ▁ Fourth ▁ quadrant " ; else if ( x == 0 and y > 0 ) cout << " lies ▁ at ▁ positive ▁ y ▁ axis " ; else if ( x == 0 and y < 0 ) cout << " lies ▁ at ▁ negative ▁ y ▁ axis " ; else if ( y == 0 and x < 0 ) cout << " lies ▁ at ▁ negative ▁ x ▁ axis " ; else if ( y == 0 and x > 0 ) cout << " lies ▁ at ▁ positive ▁ x ▁ axis " ; else cout << " lies ▁ at ▁ origin " ; }
Hyp: 
void quadrant ( int x , int y ) { if ( x > 0 and y > 0 ) cout << " Quadrant ▁ 1" ; else if ( x < 0 and y > 0 ) cout << " Quadrant ▁ 2" ; else if ( x < 0 and y < 0 ) cout << " Quadrant ▁ 3" ; else if ( x > 0 and y < 0 ) cout << " Quadrant ▁ 4" ; else if ( x == 0 and y > 0 ) cout << " Lies ▁ on ▁ positive " << " ▁ Imaginary ▁ axis " ; else if ( x == 0 and y < 0 ) cout << " Lies ▁ on ▁ negative " << " ▁ Imaginary ▁ axis " ; else if ( y == 0 and x < 0 ) cout << " Lies ▁ on ▁ negative " << " ▁ X - axis " ; else if ( y == 0 and x > 0 ) cout << " Lies ▁ on ▁ positive " << " ▁ X - axis " ; else cout << " Lies ▁ on ▁ the ▁ Origin " ; }

BLEU: 65.0
Edit Sim: 167


Src: 
function calculateLeaps ( n ) { if ( n == 0 n == 1 ) { return 1 ; } else { let leaps = 0 ; for ( let i = 0 ; i < n ; i ++ ) leaps += calculateLeaps ( i ) ; return leaps ; } }
Ref: 
int calculateLeaps ( int n ) { if ( n == 0 n == 1 ) { return 1 ; } else { int leaps = 0 ; for ( int i = 0 ; i < n ; i ++ ) leaps += calculateLeaps ( i ) ; return leaps ; } }
Hyp: 
int calculateLeaps ( int n ) { if ( n == 0 n == 1 ) { return 1 ; } else { int leaps = 0 ; for ( int i = 0 ; i < n ; i ++ ) leaps += calculateLeaps ( i ) ; return leaps ; } }

BLEU: 100.0
Edit Sim: 0


Src: 
function findGreater ( x , y ) { if ( x > y ) { return false ; } else { return true ; } }
Ref: 
bool findGreater ( int x , int y ) { if ( x > y ) { return false ; } else { return true ; } }
Hyp: 
bool findGreater ( int x , int y ) { if ( x > y ) { return false ; } else { return true ; } }

BLEU: 100.0
Edit Sim: 0


Src: 
function printSpiral ( mat , r , c ) { let i , a = 0 , b = 2 ; let low_row = ( 0 > a ) ? 0 : a ; let low_column = ( 0 > b ) ? 0 : b - 1 ; let high_row = ( ( a + 1 ) >= r ) ? r - 1 : a + 1 ; let high_column = ( ( b + 1 ) >= c ) ? c - 1 : b + 1 ; while ( ( low_row > 0 - r && low_column > 0 - c ) ) { for ( i = low_column + 1 ; i <= high_column && i < c && low_row >= 0 ; ++ i ) document . write ( mat [ low_row ] [ i ] + " " ) ; low_row -= 1 ; for ( i = low_row + 2 ; i <= high_row && i < r && high_column < c ; ++ i ) document . write ( mat [ i ] [ high_column ] + " " ) ; high_column += 1 ; for ( i = high_column - 2 ; i >= low_column && i >= 0 && high_row < r ; -- i ) document . write ( mat [ high_row ] [ i ] + " " ) ; high_row += 1 ; for ( i = high_row - 2 ; i > low_row && i >= 0 && low_column >= 0 ; -- i ) document . write ( mat [ i ] [ low_column ] + " " ) ; low_column -= 1 ; } document . write ( " " ) ; }
Ref: 
void printSpiral ( int mat [ ] [ MAX ] , int r , int c ) { int i , a = 0 , b = 2 ; int low_row = ( 0 > a ) ? 0 : a ; int low_column = ( 0 > b ) ? 0 : b - 1 ; int high_row = ( ( a + 1 ) >= r ) ? r - 1 : a + 1 ; int high_column = ( ( b + 1 ) >= c ) ? c - 1 : b + 1 ; while ( ( low_row > 0 - r && low_column > 0 - c ) ) { for ( i = low_column + 1 ; i <= high_column && i < c && low_row >= 0 ; ++ i ) cout << mat [ low_row ] [ i ] << " ▁ " ; low_row -= 1 ; for ( i = low_row + 2 ; i <= high_row && i < r && high_column < c ; ++ i ) cout << mat [ i ] [ high_column ] << " ▁ " ; high_column += 1 ; for ( i = high_column - 2 ; i >= low_column && i >= 0 && high_row < r ; -- i ) cout << mat [ high_row ] [ i ] << " ▁ " ; high_row += 1 ; for ( i = high_row - 2 ; i > low_row && i >= 0 && low_column >= 0 ; -- i ) cout << mat [ i ] [ low_column ] << " ▁ " ; low_column -= 1 ; } cout << endl ; }
Hyp: 
void printSpiral ( int mat [ 4 ] [ 4 ] , int r , int c ) { int i , a = 0 , b = 2 ; int low_row = ( 0 > a ) ? 0 : a ; int low_column = ( 0 > b ) ? 0 : b - 1 ; int high_row = ( ( a + 1 ) >= r ) ? r - 1 : a + 1 ; int high_column = ( ( b + 1 ) >= c ) ? c - 1 : b + 1 ; while ( ( low_row > 0 - r && low_column > 0 - c ) ) { for ( i = low_column + 1 ; i <= high_column && i < c && low_row >= 0 ; ++ i ) cout << mat [ low_row ] [ i ] << " ▁ " ; low_row -= 1 ; for ( i = low_row + 2 ; i <= high_row && i < r && high_column < c ; ++ i ) cout << mat [ i ] [ high_column ] << " ▁ " ; high_column += 1 ; for ( i = high_column - 2 ; i >= low_column && i >= 0 && high_row < r ; -- i ) cout << mat [ high_row ] [ i ] << " ▁ " ; low_column -= 1 ; } cout << " STRNEWLINE " ; }

BLEU: 83.0
Edit Sim: 144


Src: 
function getLudic ( n ) { let ludics = [ ] ; for ( let i = 1 ; i <= n ; i ++ ) ludics . push ( i ) ; for ( let index = 1 ; index < ludics . length ; index ++ ) { let first_ludic = ludics [ index ] ; let remove_index = index + first_ludic ; while ( remove_index < ludics . length ) { ludics . splice ( remove_index , 1 ) ; remove_index = remove_index + first_ludic - 1 ; } } return ludics ; }
Ref: 
> getLudic ( int n ) { vector < int > ludics ; for ( int i = 1 ; i <= n ; i ++ ) ludics . push_back ( i ) ; for ( int index = 1 ; index < ludics . size ( ) ; index ++ ) { int first_ludic = ludics [ index ] ; int remove_index = index + first_ludic ; while ( remove_index < ludics . size ( ) ) { auto it = ludics . begin ( ) ; it = it + remove_index ; ludics . erase ( it ) ; remove_index = remove_index + first_ludic - 1 ; } } return ludics ; }
Hyp: 
int getLudic ( int n ) { vector < int > ludics ; for ( int i = 1 ; i <= n ; i ++ ) ludics . push_back ( i ) ; for ( int index = 1 ; index < ludics . size ( ) ; index ++ ) { int first_ludic = ludics [ index ] ; int remove_index = index + first_ludic ; while ( remove_index < ludics . size ( ) ) { ludics . erase ( remove_index , 1 ) ; remove_index = remove_index + first_ludic - 1 ; } } return ludics ; }

BLEU: 82.12
Edit Sim: 52


Src: 
function printPascal ( n ) { for ( line = 1 ; line <= n ; line ++ ) { var C = 1 ; for ( i = 1 ; i <= line ; i ++ ) { document . write ( C + " " ) ; C = C * ( line - i ) / i ; } document . write ( " " ) ; } }
Ref: 
void printPascal ( int n ) { for ( int line = 1 ; line <= n ; line ++ ) { int C = 1 ; for ( int i = 1 ; i <= line ; i ++ ) { cout << C << " ▁ " ; C = C * ( line - i ) / i ; } cout << " STRNEWLINE " ; } }
Hyp: 
void printPascal ( int n ) { for ( int line = 1 ; line <= n ; line ++ ) { int C = 1 ; for ( int i = 1 ; i <= line ; i ++ ) { cout << C << " ▁ " ; C = C * ( line - i ) / i ; } cout << endl ; } }

BLEU: 93.56
Edit Sim: 14


Src: 
function countNonIncreasing ( arr , n ) { var cnt = 0 ; var len = 1 ; for ( var i = 0 ; i < n - 1 ; ++ i ) { if ( arr [ i + 1 ] <= arr [ i ] ) len ++ ; else { cnt += parseInt ( ( ( len + 1 ) * len ) / 2 ) ; len = 1 ; } } if ( len > 1 ) cnt += parseInt ( ( ( len + 1 ) * len ) / 2 ) ; return cnt ; }
Ref: 
int countNonIncreasing ( int arr [ ] , int n ) { int cnt = 0 ; int len = 1 ; for ( int i = 0 ; i < n - 1 ; ++ i ) { if ( arr [ i + 1 ] <= arr [ i ] ) len ++ ; else { cnt += ( ( ( len + 1 ) * len ) / 2 ) ; len = 1 ; } } if ( len > 1 ) cnt += ( ( ( len + 1 ) * len ) / 2 ) ; return cnt ; }
Hyp: 
int countNonIncreasing ( int arr [ ] , int n ) { int cnt = 0 ; int len = 1 ; for ( int i = 0 ; i < n - 1 ; ++ i ) { if ( arr [ i + 1 ] <= arr [ i ] ) len ++ ; else { cnt += ( ( len + 1 ) * len ) / 2 ; len = 1 ; } } if ( len > 1 ) cnt += ( ( len + 1 ) * len ) / 2 ; return cnt ; }

BLEU: 92.76
Edit Sim: 8


Src: 
function number_of_ways ( arr , n , k ) { if ( k == 1 ) return 1 ; let dp = new Array ( k + 1 ) ; let i ; for ( i = 0 ; i < k + 1 ; i ++ ) dp [ i ] = - 1 ; for ( i = 0 ; i < n ; i ++ ) dp [ arr [ i ] ] = 0 ; dp [ 0 ] = 1 ; dp [ 1 ] = ( dp [ 1 ] == - 1 ) ? 1 : dp [ 1 ] ; for ( i = 2 ; i <= k ; ++ i ) { if ( dp [ i ] == 0 ) continue ; dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] ; dp [ i ] %= MOD ; } return dp [ k ] ; }
Ref: 
int number_of_ways ( int arr [ ] , int n , int k ) { if ( k == 1 ) return 1 ; int dp [ k + 1 ] ; memset ( dp , -1 , sizeof dp ) ; for ( int i = 0 ; i < n ; i ++ ) dp [ arr [ i ] ] = 0 ; dp [ 0 ] = 1 ; dp [ 1 ] = ( dp [ 1 ] == -1 ) ? 1 : dp [ 1 ] ; for ( int i = 2 ; i <= k ; ++ i ) { if ( dp [ i ] == 0 ) continue ; dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] ; dp [ i ] %= MOD ; } return dp [ k ] ; }
Hyp: 
int number_of_ways ( int arr [ ] , int n , int k ) { if ( k == 1 ) return 1 ; int dp [ k + 1 ] ; int i ; for ( i = 0 ; i < k + 1 ; i ++ ) dp [ i ] = -1 ; for ( i = 0 ; i < n ; i ++ ) dp [ arr [ i ] ] = 0 ; dp [ 0 ] = 1 ; dp [ 1 ] = ( dp [ 1 ] == -1 ) ? 1 : dp [ 1 ] ; for ( i = 2 ; i <= k ; ++ i ) { if ( dp [ i ] == 0 ) continue ; dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] ; dp [ i ] %= MOD ; } return dp [ k ] ; }

BLEU: 83.7
Edit Sim: 50


Src: 
function trianglearea ( l , b ) { if ( l < 0 b < 0 ) return - 1 ; let area = ( l * b ) / 2 ; return area ; }
Ref: 
float trianglearea ( float l , float b ) { if ( l < 0 b < 0 ) return -1 ; float area = ( l * b ) / 2 ; return area ; }
Hyp: 
float trianglearea ( float l , float b ) { if ( l < 0 b < 0 ) return -1 ; float area = ( l * b ) / 2 ; return area ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function pell ( n ) { if ( n <= 2 ) return n ; let a = 1 ; let b = 2 ; let c ; for ( let i = 3 ; i <= n ; i ++ ) { c = 2 * b + a ; a = b ; b = c ; } return b ; }
Ref: 
int pell ( int n ) { if ( n <= 2 ) return n ; int a = 1 ; int b = 2 ; int c , i ; for ( i = 3 ; i <= n ; i ++ ) { c = 2 * b + a ; a = b ; b = c ; } return b ; }
Hyp: 
int pell ( int n ) { if ( n <= 2 ) return n ; int a = 1 ; int b = 2 ; int c ; for ( int i = 3 ; i <= n ; i ++ ) { c = 2 * b + a ; a = b ; b = c ; } return b ; }

BLEU: 92.24
Edit Sim: 8


Src: 
function findMinimum ( x , y ) { let low = 0 , high = y ; while ( low <= high ) { let mid = ( low + high ) >> 1 ; if ( ( mid * 2 + ( y - mid ) ) >= x ) high = mid - 1 ; else low = mid + 1 ; } return low ; }
Ref: 
int findMinimum ( int x , int y ) { int low = 0 , high = y ; while ( low <= high ) { int mid = ( low + high ) >> 1 ; if ( ( mid * 2 + ( y - mid ) ) >= x ) high = mid - 1 ; else low = mid + 1 ; } return low ; }
Hyp: 
int findMinimum ( int x , int y ) { int low = 0 , high = y ; while ( low <= high ) { int mid = ( low + high ) >> 1 ; if ( ( mid * 2 + ( y - mid ) ) >= x ) high = mid - 1 ; else low = mid + 1 ; } return low ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function nthTerm ( N ) { let nth = 0 ; nth = parseInt ( ( N * N * ( N + 1 ) ) / 2 ) ; return nth ; }
Ref: 
int nthTerm ( int N ) { int nth = 0 ; nth = ( N * N * ( N + 1 ) ) / 2 ; return nth ; }
Hyp: 
int nthTerm ( int N ) { int nth = 0 ; nth = ( N * N * ( N + 1 ) ) / 2 ; return nth ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function maximumChars ( str ) { let n = str . length ; let res = - 1 ; for ( let i = 0 ; i < n - 1 ; i ++ ) for ( let j = i + 1 ; j < n ; j ++ ) if ( str [ i ] == str [ j ] ) res = Math . max ( res , Math . abs ( j - i - 1 ) ) ; return res ; }
Ref: 
int maximumChars ( string & str ) { int n = str . length ( ) ; int res = -1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( str [ i ] == str [ j ] ) res = max ( res , abs ( j - i - 1 ) ) ; return res ; }
Hyp: 
int maximumChars ( string str ) { int n = str . length ( ) ; int res = -1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( str [ i ] == str [ j ] ) res = max ( res , abs ( j - i - 1 ) ) ; return res ; }

BLEU: 97.05
Edit Sim: 2


Src: 
function findSum ( a ) { var ans = 0 ; for ( var low = 0 ; low < a . length ; low ++ ) { for ( var high = low ; high < a . length ; high ++ ) { var count = 0 ; var maxNumber = 0 ; for ( var i = low ; i <= high ; i ++ ) { if ( a [ i ] === maxNumber ) count ++ ; else if ( a [ i ] > maxNumber ) { maxNumber = a [ i ] ; count = 1 ; } } ans += maxNumber * ( count % 2 === 0 ? 2 : 1 ) ; } } document . write ( ans ) ; }
Ref: 
void findSum ( vector < int > a ) { int ans = 0 ; for ( int low = 0 ; low < a . size ( ) ; low ++ ) { for ( int high = low ; high < a . size ( ) ; high ++ ) { int count = 0 ; int maxNumber = 0 ; for ( int i = low ; i <= high ; i ++ ) { if ( a [ i ] == maxNumber ) count ++ ; else if ( a [ i ] > maxNumber ) { maxNumber = a [ i ] ; count = 1 ; } } ans += maxNumber * ( ( count % 2 == 0 ) ? 2 : 1 ) ; } } cout << ( ans ) ; }
Hyp: 
void findSum ( int a [ ] , int n ) { int ans = 0 ; for ( int low = 0 ; low < n ; low ++ ) { for ( int high = low ; high < n ; high ++ ) { int count = 0 ; int maxNumber = 0 ; for ( int i = low ; i <= high ; i ++ ) { if ( a [ i ] == maxNumber ) count ++ ; else if ( a [ i ] > maxNumber ) { maxNumber = a [ i ] ; count = 1 ; } } ans += maxNumber * ( count % 2 == 0 ? 2 : 1 ) ; } } cout << ans ; }

BLEU: 80.2
Edit Sim: 45


Src: 
function No_of_squares ( N , K ) { let no_of_squares = 0 ; no_of_squares = ( N - K + 1 ) * ( N - K + 1 ) ; return no_of_squares ; }
Ref: 
int No_of_squares ( int N , int K ) { int no_of_squares = 0 ; no_of_squares = ( N - K + 1 ) * ( N - K + 1 ) ; return no_of_squares ; }
Hyp: 
int No_of_squares ( int N , int K ) { int no_of_squares = 0 ; no_of_squares = ( N - K + 1 ) * ( N - K + 1 ) ; return no_of_squares ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function minimumNumbers ( n , s ) { if ( s % n ) return parseInt ( s / n ) + 1 ; else return parseInt ( s / n ) ; }
Ref: 
int minimumNumbers ( int n , int s ) { if ( s % n ) return s / n + 1 ; else return s / n ; }
Hyp: 
int minimumNumbers ( int n , int s ) { if ( s % n ) return s / n + 1 ; else return s / n ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function MatrixChainOrder ( p , n ) { var dp = Array . from ( Array ( n ) , ( ) => Array ( n ) ) ; for ( var i = 1 ; i < n ; i ++ ) dp [ i ] [ i ] = 0 ; for ( var L = 1 ; L < n - 1 ; L ++ ) for ( var i = 1 ; i < n - L ; i ++ ) dp [ i ] [ i + L ] = Math . min ( dp [ i + 1 ] [ i + L ] + p [ i - 1 ] * p [ i ] * p [ i + L ] , dp [ i ] [ i + L - 1 ] + p [ i - 1 ] * p [ i + L - 1 ] * p [ i + L ] ) ; return dp [ 1 ] [ n - 1 ] ; }
Ref: 
int MatrixChainOrder ( int p [ ] , int n ) { int dp [ n ] [ n ] ; for ( int i = 1 ; i < n ; i ++ ) dp [ i ] [ i ] = 0 ; for ( int L = 1 ; L < n - 1 ; L ++ ) for ( int i = 1 ; i < n - L ; i ++ ) dp [ i ] [ i + L ] = min ( dp [ i + 1 ] [ i + L ] + p [ i - 1 ] * p [ i ] * p [ i + L ] , dp [ i ] [ i + L - 1 ] + p [ i - 1 ] * p [ i + L - 1 ] * p [ i + L ] ) ; return dp [ 1 ] [ n - 1 ] ; }
Hyp: 
int MatrixChainOrder ( int p [ ] , int n ) { int dp [ n ] [ n ] ; memset ( dp , 0 , sizeof ( dp ) ) ; for ( int i = 1 ; i < n ; i ++ ) dp [ i ] [ i ] = 0 ; for ( int L = 1 ; L < n - 1 ; L ++ ) for ( int i = 1 ; i < n - L ; i ++ ) dp [ i ] [ i + L ] = min ( dp [ i + 1 ] [ i + L ] + p [ i - 1 ] * p [ i ] * p [ i + L ] , dp [ i ] [ i + L - 1 ] + p [ i - 1 ] * p [ i + L - 1 ] * p [ i + L ] ) ; return dp [ 1 ] [ n - 1 ] ; }

BLEU: 92.89
Edit Sim: 36


Src: 
function productOfGP ( a , r , n ) { let product = 1 ; for ( let i = 0 ; i < n ; i ++ ) { product = product * a ; a = a * r ; } return product ; }
Ref: 
float productOfGP ( float a , float r , int n ) { float product = 1 ; for ( int i = 0 ; i < n ; i ++ ) { product = product * a ; a = a * r ; } return product ; }
Hyp: 
float productOfGP ( float a , float r , int n ) { float product = 1 ; for ( int i = 0 ; i < n ; i ++ ) { product = product * a ; a = a * r ; } return product ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function getMinCost ( n , m ) { let cost = ( n - 1 ) * m + ( m - 1 ) * n ; return cost ; }
Ref: 
int getMinCost ( int n , int m ) { int cost = ( n - 1 ) * m + ( m - 1 ) * n ; return cost ; }
Hyp: 
int getMinCost ( int n , int m ) { int cost = ( n - 1 ) * m + ( m - 1 ) * n ; return cost ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countBuildings ( arr , n ) { let count = 1 ; let curr_max = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > curr_max arr [ i ] == curr_max ) { count ++ ; curr_max = arr [ i ] ; } } return count ; }
Ref: 
int countBuildings ( int arr [ ] , int n ) { int count = 1 ; int curr_max = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > curr_max arr [ i ] == curr_max ) { count ++ ; curr_max = arr [ i ] ; } } return count ; }
Hyp: 
int countBuildings ( int arr [ ] , int n ) { int count = 1 ; int curr_max = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > curr_max arr [ i ] == curr_max ) { count ++ ; curr_max = arr [ i ] ; } } return count ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function Triplets ( n ) { var ans = 0 ; for ( let i = 1 ; i <= n ; ++ i ) { for ( let j = i ; j <= n ; ++ j ) { var x = i * i + j * j ; var y = parseInt ( Math . sqrt ( x ) ) ; if ( y * y == x && y <= n ) ++ ans ; } } return ans ; }
Ref: 
int Triplets ( int n ) { int ans = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = i ; j <= n ; ++ j ) { int x = i * i + j * j ; int y = sqrt ( x ) ; if ( y * y == x && y <= n ) ++ ans ; } } return ans ; }
Hyp: 
int Triplets ( int n ) { int ans = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = i ; j <= n ; ++ j ) { int x = i * i + j * j ; int y = sqrt ( x ) ; if ( y * y == x && y <= n ) ++ ans ; } } return ans ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function istetradecagonal ( N ) { n = ( 10 + Math . sqrt ( 96 * N + 100 ) ) / 24 ; return ( n - parseInt ( n ) ) == 0 ; } N = 11 ; if ( istetradecagonal ( N ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
Ref: 
bool istetradecagonal ( int N ) { float n = ( 10 + sqrt ( 96 * N + 100 ) ) / 24 ; return ( n - ( int ) n ) == 0 ; }
Hyp: 
bool istetradecagonal ( int N ) { float n = ( 10 + sqrt ( 96 * N + 100 ) ) / 24 ; return ( n - ( int ) n ) == 0 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function checkNumber ( N ) { let temp = N ; while ( temp > 0 ) { if ( temp % 1000 == 144 ) temp = parseInt ( temp / 1000 , 10 ) ; else if ( temp % 100 == 14 ) temp = parseInt ( temp / 100 , 10 ) ; else if ( temp % 10 == 1 ) temp = parseInt ( temp / 10 , 10 ) ; else { return " " ; } } return " " ; }
Ref: 
string checkNumber ( int N ) { int temp = N ; while ( temp > 0 ) { if ( temp % 1000 == 144 ) temp /= 1000 ; else if ( temp % 100 == 14 ) temp /= 100 ; else if ( temp % 10 == 1 ) temp /= 10 ; else { return " NO " ; } } return " YES " ; }
Hyp: 
string checkNumber ( int N ) { int temp = N ; while ( temp > 0 ) { if ( temp % 1000 == 144 ) temp = temp / 1000 ; else if ( temp % 100 == 14 ) temp = temp / 100 ; else if ( temp % 10 == 1 ) temp = temp / 10 ; else { return " No " ; } } return " Yes " ; }

BLEU: 75.64
Edit Sim: 27


Src: 
function maxPairs ( nums , k ) { nums . sort ( ) ; let result = 0 ; let start = 0 , end = nums . length - 1 ; while ( start < end ) { if ( nums [ start ] + nums [ end ] > k ) end -- ; else if ( nums [ start ] + nums [ end ] < k ) start ++ ; else { start ++ ; end -- ; result ++ ; } } document . write ( result ) ; }
Ref: 
void maxPairs ( int nums [ ] , int n , int k ) { sort ( nums , nums + n ) ; int result = 0 ; int start = 0 , end = n - 1 ; while ( start < end ) { if ( nums [ start ] + nums [ end ] > k ) end -- ; else if ( nums [ start ] + nums [ end ] < k ) start ++ ; else { start ++ ; end -- ; result ++ ; } } cout << result << endl ; ; }
Hyp: 
void maxPairs ( int nums [ ] , int k ) { sort ( nums , nums + k ) ; int result = 0 ; int start = 0 , end = nums . size ( ) - 1 ; while ( start < end ) { if ( nums [ start ] + nums [ end ] > k ) end -- ; else if ( nums [ start ] + nums [ end ] < k ) start ++ ; else { start ++ ; end -- ; result ++ ; } } cout << result << endl ; }

BLEU: 90.4
Edit Sim: 25


Src: 
function findElements ( arr , n ) { let first = Number . MIN_VALUE ; let second = Number . MAX_VALUE ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > first ) { second = first ; first = arr [ i ] ; } else if ( arr [ i ] > second ) second = arr [ i ] ; } for ( let i = 0 ; i < n ; i ++ ) if ( arr [ i ] < second ) document . write ( arr [ i ] + " " ) ; }
Ref: 
void findElements ( int arr [ ] , int n ) { int first = INT_MIN , second = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > first ) { second = first ; first = arr [ i ] ; } else if ( arr [ i ] > second ) second = arr [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] < second ) cout << arr [ i ] << " ▁ " ; }
Hyp: 
void findElements ( int arr [ ] , int n ) { int first = INT_MIN ; int second = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > first ) { second = first ; first = arr [ i ] ; } else if ( arr [ i ] > second ) second = arr [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] < second ) cout << arr [ i ] << " ▁ " ; }

BLEU: 95.26
Edit Sim: 7


Src: 
function group_formed ( S ) { let count = 1 ; for ( let i = 0 ; i < S . length - 1 ; i ++ ) { if ( S [ i ] != S [ i + 1 ] ) count += 1 ; } document . write ( count ) ; }
Ref: 
void group_formed ( string S ) { int count = 1 ; for ( int i = 0 ; i < S . size ( ) - 1 ; i ++ ) { if ( S [ i ] != S [ i + 1 ] ) count += 1 ; } cout << ( count ) ; }
Hyp: 
void group_formed ( string S ) { int count = 1 ; for ( int i = 0 ; i < S . length ( ) - 1 ; i ++ ) { if ( S [ i ] != S [ i + 1 ] ) count += 1 ; } cout << count ; }

BLEU: 88.69
Edit Sim: 10


Src: 
function Series ( n ) { let i ; let sums = 0 ; for ( i = 1 ; i <= n ; i ++ ) sums += ( i * i ) ; return sums ; }
Ref: 
int Series ( int n ) { int i ; int sums = 0 ; for ( i = 1 ; i <= n ; i ++ ) sums += ( i * i ) ; return sums ; }
Hyp: 
int Series ( int n ) { int i ; int sums = 0 ; for ( i = 1 ; i <= n ; i ++ ) sums += ( i * i ) ; return sums ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function maxRightmostElement ( N , k , p , arr ) { var ans = arr [ N - 1 ] ; for ( var i = N - 2 ; i >= 0 ; i -- ) { var d = Math . min ( arr [ i ] / p , k / ( N - 1 - i ) ) ; k -= d * ( N - 1 - i ) ; ans += d * p ; } return ans ; }
Ref: 
void maxRightmostElement ( int N , int k , int arr [ ] ) { int ans = arr [ N - 1 ] ; for ( int i = N - 2 ; i >= 0 ; i -- ) { int d = min ( arr [ i ] / 2 , k / ( N - 1 - i ) ) ; k -= d * ( N - 1 - i ) ; ans += d * 2 ; } cout << ans << endl ; }
Hyp: 
int maxRightmostElement ( int N , int k , int p , int arr [ ] ) { int ans = arr [ N - 1 ] ; for ( int i = N - 2 ; i >= 0 ; i -- ) { int d = min ( arr [ i ] / p , k / ( N - 1 - i ) ) ; k -= d * ( N - 1 - i ) ; ans += d * p ; } return ans ; }

BLEU: 86.61
Edit Sim: 28


Src: 
function isPossible ( a , b , n , k ) { a . sort ( function ( a , b ) { return a - b } ) ; b . reverse ( ) ; for ( let i = 0 ; i < n ; i ++ ) if ( a [ i ] + b [ i ] < k ) return false ; return true ; }
Ref: 
bool isPossible ( int a [ ] , int b [ ] , int n , int k ) { sort ( a , a + n ) ; sort ( b , b + n , greater < int > ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) if ( a [ i ] + b [ i ] < k ) return false ; return true ; }
Hyp: 
bool isPossible ( int a [ ] , int b [ ] , int n , int k ) { sort ( a , a + n ) ; sort ( b , b + n , greater < int > ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) if ( a [ i ] + b [ i ] < k ) return false ; return true ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countSolutions ( n , val ) { let total = 0 ; if ( n == 1 && val >= 0 ) return 1 ; for ( let i = 0 ; i <= val ; i ++ ) { total += countSolutions ( n - 1 , val - i ) ; } return total ; }
Ref: 
int countSolutions ( int n , int val ) { int total = 0 ; if ( n == 1 && val >= 0 ) return 1 ; for ( int i = 0 ; i <= val ; i ++ ) { total += countSolutions ( n - 1 , val - i ) ; } return total ; }
Hyp: 
int countSolutions ( int n , int val ) { int total = 0 ; if ( n == 1 && val >= 0 ) return 1 ; for ( int i = 0 ; i <= val ; i ++ ) { total += countSolutions ( n - 1 , val - i ) ; } return total ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function isPossible ( W , B , D ) { if ( W > B ) { let temp = W ; W = B ; B = temp ; } if ( B > W * ( D + 1 ) ) document . write ( " " ) ; else document . write ( " " ) ; }
Ref: 
void isPossible ( int W , int B , int D ) { if ( W > B ) swap ( W , B ) ; if ( B > W * ( D + 1 ) ) cout << " NO " << endl ; else cout << " YES " << endl ; }
Hyp: 
void isPossible ( int W , int B , int D ) { if ( W > B ) { int temp = W ; W = B ; B = temp ; } if ( B > W * ( D + 1 ) ) cout << " NO " ; else cout << " YES " ; }

BLEU: 68.37
Edit Sim: 43


Src: 
function getCount ( a , b ) { if ( b . length % a . length != 0 ) return - 1 ; var count = parseInt ( b . length / a . length ) ; var str = " " ; for ( i = 0 ; i < count ; i ++ ) { str = str + a ; } if ( str == ( b ) ) return count ; return - 1 ; }
Ref: 
int getCount ( string a , string b ) { if ( b . length ( ) % a . length ( ) != 0 ) return -1 ; int count = b . length ( ) / a . length ( ) ; string str = " " ; for ( int i = 0 ; i < count ; i ++ ) { str = str + a ; } if ( str == b ) return count ; return -1 ; }
Hyp: 
int getCount ( string a , string b ) { if ( b . length ( ) % a . length ( ) != 0 ) return -1 ; int count = b . length ( ) / a . length ( ) ; string str = " " ; for ( int i = 0 ; i < count ; i ++ ) { str = str + a ; } if ( str == ( b ) ) return count ; return -1 ; }

BLEU: 95.33
Edit Sim: 4


Src: 
function printPair ( n ) { document . write ( 1 + " " + ( n - 1 ) ) ; }
Ref: 
void printPair ( int n ) { cout << 1 << " ▁ " << n - 1 ; }
Hyp: 
void printPair ( int n ) { cout << 1 << " , ▁ " << n - 1 ; }

BLEU: 87.25
Edit Sim: 2


Src: 
function lengthOfLastWord ( a ) { let len = 0 ; x = a . trim ( ) ; for ( let i = 0 ; i < x . length ; i ++ ) { if ( x [ i ] == ' ' ) { len = 0 ; } else { len ++ ; } } return len ; }
Ref: 
int lengthOfLastWord ( string a ) { int len = 0 ; string str ( a ) ; boost :: trim_right ( str ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . at ( i ) == ' ▁ ' ) len = 0 ; else len ++ ; } return len ; }
Hyp: 
int lengthOfLastWord ( string x ) { int len = 0 ; x = to_string ( x ) ; for ( int i = 0 ; i < x . length ( ) ; i ++ ) { if ( x [ i ] == '0' ) { len = 0 ; } else { len ++ ; } } return len ; }

BLEU: 52.16
Edit Sim: 57


Src: 
function checkpoint ( h , k , x , y , a , b ) { var p = ( parseInt ( Math . pow ( ( x - h ) , 2 ) ) / parseInt ( Math . pow ( a , 2 ) ) ) + ( parseInt ( Math . pow ( ( y - k ) , 2 ) ) / parseInt ( Math . pow ( b , 2 ) ) ) ; return p ; }
Ref: 
int checkpoint ( int h , int k , int x , int y , int a , int b ) { int p = ( pow ( ( x - h ) , 2 ) / pow ( a , 2 ) ) + ( pow ( ( y - k ) , 2 ) / pow ( b , 2 ) ) ; return p ; }
Hyp: 
int checkpoint ( int h , int k , int x , int y , int a , int b ) { int p = ( pow ( ( x - h ) , 2 ) ) / pow ( a , 2 ) ) + ( pow ( ( y - k ) , 2 ) ) / pow ( b , 2 ) ) ; return p ; }

BLEU: 94.97
Edit Sim: 4


Src: 
function findTangent ( A , x , y ) { var dif = A - x * 2 ; if ( y == ( 2 * x - x * x ) ) { if ( dif < 0 ) document . write ( " " + dif + " " + ( x * dif + y ) + " " ) ; else if ( dif > 0 ) document . write ( " " + dif + " " + - x * dif + y + " " ) ; else document . write ( " " + " " ) ; } }
Ref: 
void findTangent ( int A , int x , int y ) { int dif = A - x * 2 ; if ( y == ( 2 * x - x * x ) ) { if ( dif < 0 ) cout << " y ▁ = ▁ " << dif << " x " << ( x * dif ) + ( y ) ; else if ( dif > 0 ) cout << " y ▁ = ▁ " << dif << " x + " << - x * dif + y ; else cout << " Not ▁ possible " ; } }
Hyp: 
void findTangent ( int A , int x , int y ) { int dif = A - x * 2 ; if ( y == ( 2 * x - x * x ) ) { if ( dif < 0 ) cout << " Tangent ▁ is ▁ " << ( x * dif + y ) << " ▁ " ; else if ( dif > 0 ) cout << " Tangent ▁ is ▁ " << dif << " ▁ " << - x * dif + y << " ▁ " ; else cout << " Tangent ▁ is ▁ " << dif << " STRNEWLINE " ; } }

BLEU: 71.63
Edit Sim: 83


Src: 
function product_subarrays ( arr , n ) { let product = 1 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i ; j < n ; j ++ ) { for ( let k = i ; k <= j ; k ++ ) product *= arr [ k ] ; } } document . write ( product + " " ) ; }
Ref: 
void product_subarrays ( int arr [ ] , int n ) { int product = 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { for ( int k = i ; k <= j ; k ++ ) product *= arr [ k ] ; } } cout << product << " STRNEWLINE " ; }
Hyp: 
void product_subarrays ( int arr [ ] , int n ) { int product = 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { for ( int k = i ; k <= j ; k ++ ) product *= arr [ k ] ; } } cout << product << " ▁ " ; }

BLEU: 96.78
Edit Sim: 10


Src: 
function printNthElement ( n ) { var arr = Array ( n + 1 ) . fill ( 0 ) ; arr [ 1 ] = 4 ; arr [ 2 ] = 7 ; for ( var i = 3 ; i <= n ; i ++ ) { if ( i % 2 != 0 ) arr [ i ] = arr [ i / 2 ] * 10 + 4 ; else arr [ i ] = arr [ ( i / 2 ) - 1 ] * 10 + 7 ; } return arr [ n ] ; }
Ref: 
int printNthElement ( int n ) { int arr [ n + 1 ] ; arr [ 1 ] = 4 ; arr [ 2 ] = 7 ; for ( int i = 3 ; i <= n ; i ++ ) { if ( i % 2 != 0 ) arr [ i ] = arr [ i / 2 ] * 10 + 4 ; else arr [ i ] = arr [ ( i / 2 ) - 1 ] * 10 + 7 ; } return arr [ n ] ; }
Hyp: 
int printNthElement ( int n ) { int arr [ n + 1 ] ; arr [ 1 ] = 4 ; arr [ 2 ] = 7 ; for ( int i = 3 ; i <= n ; i ++ ) { if ( i % 2 != 0 ) arr [ i ] = arr [ i / 2 ] * 10 + 4 ; else arr [ i ] = arr [ ( i / 2 ) - 1 ] * 10 + 7 ; } return arr [ n ] ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function cntEvenSumPairs ( X , Y ) { var cntXEvenNums = parseInt ( X / 2 ) ; var cntXOddNums = parseInt ( ( X + 1 ) / 2 ) ; var cntYEvenNums = parseInt ( Y / 2 ) ; var cntYOddNums = parseInt ( ( Y + 1 ) / 2 ) ; var cntPairs = ( cntXEvenNums * cntYEvenNums ) + ( cntXOddNums * cntYOddNums ) ; return cntPairs ; }
Ref: 
long cntEvenSumPairs ( long long X , long long Y ) { long long cntXEvenNums = X / 2 ; long long cntXOddNums = ( X + 1 ) / 2 ; long long cntYEvenNums = Y / 2 ; long long cntYOddNums = ( Y + 1 ) / 2 ; long long cntPairs = ( cntXEvenNums * 1LL * cntYEvenNums ) + ( cntXOddNums * 1LL * cntYOddNums ) ; return cntPairs ; }
Hyp: 
int cntEvenSumPairs ( int X , int Y ) { int cntXEvenNums = X / 2 ; int cntXOddNums = ( X + 1 ) / 2 ; int cntYEvenNums = Y / 2 ; int cntYOddNums = ( Y + 1 ) / 2 ; int cntPairs = ( cntXEvenNums * cntYEvenNums ) + ( cntXOddNums * cntYOddNums ) ; return cntPairs ; }

BLEU: 57.47
Edit Sim: 71


Src: 
function countTriplets ( arr , n ) { let odd = 0 , even = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] & 1 ) odd ++ ; else even ++ ; } let c1 = Math . floor ( odd * ( even * ( even - 1 ) ) / 2 ) ; let c2 = Math . floor ( ( odd * ( odd - 1 ) * ( odd - 2 ) ) / 6 ) ; return c1 + c2 ; }
Ref: 
int countTriplets ( int arr [ ] , int n ) { int odd = 0 , even = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] & 1 ) odd ++ ; else even ++ ; } int c1 = odd * ( even * ( even - 1 ) ) / 2 ; int c2 = ( odd * ( odd - 1 ) * ( odd - 2 ) ) / 6 ; return c1 + c2 ; }
Hyp: 
int countTriplets ( int arr [ ] , int n ) { int odd = 0 , even = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] & 1 ) odd ++ ; else even ++ ; } int c1 = ( odd * ( even * ( even - 1 ) ) / 2 ) ; int c2 = ( odd * ( odd - 1 ) * ( odd - 2 ) ) / 6 ; return c1 + c2 ; }

BLEU: 94.87
Edit Sim: 4


Src: 
function print ( n , k ) { document . write ( k + " " ) ; for ( var i = 2 ; i <= n ; i ++ ) { var x = Math . pow ( k , i ) - Math . pow ( k , i - 1 ) ; document . write ( x + " " ) ; } }
Ref: 
void print ( ll n , ll k ) { cout << k << " ▁ " ; for ( int i = 2 ; i <= n ; i ++ ) { ll x = pow ( k , i ) - pow ( k , i - 1 ) ; cout << x << " ▁ " ; } }
Hyp: 
void print ( int n , int k ) { cout << k << endl ; for ( int i = 2 ; i <= n ; i ++ ) { int x = pow ( k , i ) - pow ( k , i - 1 ) ; cout << x << endl ; } }

BLEU: 72.73
Edit Sim: 19


Src: 
function averageValue ( s ) { let sum_char = 0 ; for ( let i = 0 ; i < s . length ; i ++ ) { sum_char += ( s [ i ] ) . charCodeAt ( 0 ) ; } return Math . floor ( sum_char / s . length ) ; }
Ref: 
int averageValue ( string s ) { int sum_char = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { sum_char += ( int ) s [ i ] ; } return sum_char / s . length ( ) ; }
Hyp: 
int averageValue ( string s ) { int sum_char = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { sum_char += ( s [ i ] ) ; } return floor ( sum_char / s . length ( ) ) ; }

BLEU: 82.53
Edit Sim: 18


Src: 
function minJumps ( arr , N ) { let fib = new Array ( 30 ) ; fib [ 0 ] = 0 ; fib [ 1 ] = 1 ; for ( let i = 2 ; i < 30 ; i ++ ) fib [ i ] = fib [ i - 1 ] + fib [ i - 2 ] ; let DP = new Array ( N + 2 ) ; DP [ 0 ] = 0 ; for ( let i = 1 ; i <= N + 1 ; i ++ ) DP [ i ] = MAX ; for ( let i = 1 ; i <= N + 1 ; i ++ ) { for ( let j = 1 ; j < 30 ; j ++ ) { if ( ( arr [ i - 1 ] == 1 i == N + 1 ) && i - fib [ j ] >= 0 ) DP [ i ] = Math . min ( DP [ i ] , 1 + DP [ i - fib [ j ] ] ) ; } } if ( DP [ N + 1 ] != MAX ) return DP [ N + 1 ] ; else return - 1 ; }
Ref: 
int minJumps ( int arr [ ] , int N ) { int fib [ 30 ] ; fib [ 0 ] = 0 ; fib [ 1 ] = 1 ; for ( int i = 2 ; i < 30 ; i ++ ) fib [ i ] = fib [ i - 1 ] + fib [ i - 2 ] ; int DP [ N + 2 ] ; DP [ 0 ] = 0 ; for ( int i = 1 ; i <= N + 1 ; i ++ ) DP [ i ] = MAX ; for ( int i = 1 ; i <= N + 1 ; i ++ ) { for ( int j = 1 ; j < 30 ; j ++ ) { if ( ( arr [ i - 1 ] == 1 i == N + 1 ) && i - fib [ j ] >= 0 ) DP [ i ] = min ( DP [ i ] , 1 + DP [ i - fib [ j ] ] ) ; } } if ( DP [ N + 1 ] != MAX ) return DP [ N + 1 ] ; else return -1 ; }
Hyp: 
int minJumps ( int arr [ ] , int N ) { int fib [ 30 ] ; fib [ 0 ] = 0 ; fib [ 1 ] = 1 ; for ( int i = 2 ; i < 30 ; i ++ ) fib [ i ] = fib [ i - 1 ] + fib [ i - 2 ] ; int DP [ N + 2 ] ; DP [ 0 ] = 0 ; for ( int i = 1 ; i <= N + 1 ; i ++ ) DP [ i ] = MAX ; for ( int i = 1 ; i <= N + 1 ; i ++ ) { for ( int j = 1 ; j < 30 ; j ++ ) { if ( arr [ i - 1 ] == 1 i == N + 1 ) && i - fib [ j ] >= 0 ) DP [ i ] = min ( DP [ i ] , 1 + DP [ i - fib [ j ] ] ) ; } } if ( DP [ N + 1 ] != MAX ) return DP [ N + 1 ] ; else return -1 ; }

BLEU: 99.17
Edit Sim: 2


Src: 
function hammingDist ( str1 , str2 ) { let i = 0 , count = 0 ; while ( i < str1 . length ) { if ( str1 [ i ] != str2 [ i ] ) count ++ ; i ++ ; } return count ; }
Ref: 
int hammingDist ( char * str1 , char * str2 ) { int i = 0 , count = 0 ; while ( str1 [ i ] != ' \0' ) { if ( str1 [ i ] != str2 [ i ] ) count ++ ; i ++ ; } return count ; }
Hyp: 
int hammingDist ( string str1 , string str2 ) { int i = 0 , count = 0 ; while ( i < str1 . size ( ) ) { if ( str1 [ i ] != str2 [ i ] ) count ++ ; i ++ ; } return count ; }

BLEU: 72.39
Edit Sim: 27


Src: 
function maximumSum ( a , b , k , n ) { let i , j ; a . sort ( ) ; b . sort ( ) ; for ( i = 0 , j = n - 1 ; i < k ; i ++ , j -- ) { if ( a [ i ] < b [ j ] ) { let temp = a [ i ] ; a [ i ] = b [ j ] ; b [ j ] = temp ; } else break ; } let sum = 0 ; for ( i = 0 ; i < n ; i ++ ) sum += a [ i ] ; document . write ( sum ) ; }
Ref: 
void maximumSum ( int a [ ] , int b [ ] , int k , int n ) { int i , j ; sort ( a , a + n ) ; sort ( b , b + n ) ; for ( i = 0 , j = n - 1 ; i < k ; i ++ , j -- ) { if ( a [ i ] < b [ j ] ) swap ( a [ i ] , b [ j ] ) ; else break ; } int sum = 0 ; for ( i = 0 ; i < n ; i ++ ) sum += a [ i ] ; cout << sum << endl ; }
Hyp: 
void maximumSum ( int a [ ] , int b [ ] , int k , int n ) { int i , j ; sort ( a , a + n ) ; sort ( b , b + n ) ; for ( i = 0 , j = n - 1 ; i < k ; i ++ , j -- ) { if ( a [ i ] < b [ j ] ) { int temp = a [ i ] ; a [ i ] = b [ j ] ; b [ j ] = temp ; } else break ; } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += a [ i ] ; cout << sum ; }

BLEU: 80.5
Edit Sim: 51


Src: 
function getMinCost ( arr , n ) { let min_ele = Number . MAX_VALUE ; for ( let i = 0 ; i < n ; i ++ ) { min_ele = Math . min ( min_ele , arr [ i ] ) ; } return min_ele * ( n - 1 ) ; }
Ref: 
int getMinCost ( int arr [ ] , int n ) { int min_ele = * min_element ( arr , arr + n ) ; return min_ele * ( n - 1 ) ; }
Hyp: 
int getMinCost ( int arr [ ] , int n ) { int min_ele = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { min_ele = min ( min_ele , arr [ i ] ) ; } return min_ele * ( n - 1 ) ; }

BLEU: 45.14
Edit Sim: 62


Src: 
function icosikaioctagonalNum ( n ) { return ( 26 * n * n - 24 * n ) / 2 ; }
Ref: 
int icosikaioctagonalNum ( int n ) { return ( 26 * n * n - 24 * n ) / 2 ; }
Hyp: 
int icosikaioctagonalNum ( int n ) { return ( 26 * n * n - 24 * n ) / 2 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function MinOperation ( a , n , k ) { let result = 0 ; for ( let i = 0 ; i < n ; ++ i ) { if ( a [ i ] != 1 && a [ i ] > k ) { result = result + Math . min ( a [ i ] % k , k - a [ i ] % k ) ; } else { result = result + k - a [ i ] ; } } return result ; }
Ref: 
int MinOperation ( int a [ ] , int n , int k ) { int result = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( a [ i ] != 1 && a [ i ] > k ) { result = result + min ( a [ i ] % k , k - a [ i ] % k ) ; } else { result = result + k - a [ i ] ; } } return result ; }
Hyp: 
int MinOperation ( int a [ ] , int n , int k ) { int result = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( a [ i ] != 1 && a [ i ] > k ) { result = result + min ( a [ i ] % k , k - a [ i ] % k ) ; } else { result = result + k - a [ i ] ; } } return result ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function sumOfAP ( a , d , n ) { let sum = ( n / 2 ) * ( 2 * a + ( n - 1 ) * d ) ; return sum ; }
Ref: 
float sumOfAP ( float a , float d , float n ) { float sum = ( n / 2 ) * ( 2 * a + ( n - 1 ) * d ) ; return sum ; }
Hyp: 
int sumOfAP ( int a , int d , int n ) { int sum = ( n / 2 ) * ( 2 * a + ( n - 1 ) * d ) ; return sum ; }

BLEU: 73.16
Edit Sim: 20


Src: 
function GeberateDefangIP ( str ) { var defangIP = " " ; str . split ( ' ' ) . forEach ( function ( letter ) { ( letter == ' ' ) ? defangIP += " " : defangIP += letter ; } ) return defangIP ; }
Ref: 
string GeberateDefangIP ( string str ) { string defangIP = " " ; for ( char c : str ) ( c == ' . ' ) ? defangIP += " [ . ] " : defangIP += c ; return defangIP ; }
Hyp: 
string GeberateDefangIP ( string str ) { string defangIP = " " ; while ( str . find ( ' ▁ ' ) != -1 ) defangIP += " ▁ " ; return defangIP ; }

BLEU: 42.77
Edit Sim: 46


Src: 
function sumOfSeries ( n ) { let ans = 0 ; for ( let i = 1 ; i <= n ; i ++ ) ans += i * i * i * i ; return ans ; }
Ref: 
int sumOfSeries ( int n ) { int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) ans += i * i * i * i ; return ans ; }
Hyp: 
int sumOfSeries ( int n ) { int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) ans += i * i * i * i ; return ans ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function cntWays ( str , n ) { var x = n + 1 ; var ways = x * x * ( x * x - 1 ) / 12 ; return ways ; }
Ref: 
int cntWays ( string str , int n ) { int x = n + 1 ; int ways = x * x * ( x * x - 1 ) / 12 ; return ways ; }
Hyp: 
int cntWays ( string str , int n ) { int x = n + 1 ; int ways = x * x * ( x * x - 1 ) / 12 ; return ways ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function ConstArrayAdjacentCoprime ( N ) { for ( let i = 1 ; i <= N ; i ++ ) { document . write ( i + " " ) ; } }
Ref: 
void ConstArrayAdjacentCoprime ( int N ) { for ( int i = 1 ; i <= N ; i ++ ) { cout << i << " ▁ " ; } }
Hyp: 
void ConstArrayAdjacentCoprime ( int N ) { for ( int i = 1 ; i <= N ; i ++ ) { cout << i << " ▁ " ; } }

BLEU: 100.0
Edit Sim: 0


Src: 
function pairs_count ( arr , n , sum ) { let ans = 0 ; arr . sort ( ) ; let i = 0 , j = n - 1 ; while ( i < j ) { if ( arr [ i ] + arr [ j ] < sum ) i ++ ; else if ( arr [ i ] + arr [ j ] > sum ) j -- ; else { let x = arr [ i ] , xx = i ; while ( i < j && arr [ i ] == x ) i ++ ; let y = arr [ j ] , yy = j ; while ( j >= i && arr [ j ] == y ) j -- ; if ( x == y ) { let temp = i - xx + yy - j - 1 ; ans += ( temp * ( temp + 1 ) ) / 2 ; } else ans += ( i - xx ) * ( yy - j ) ; } } return ans ; }
Ref: 
int pairs_count ( int arr [ ] , int n , int sum ) { int ans = 0 ; sort ( arr , arr + n ) ; int i = 0 , j = n - 1 ; while ( i < j ) { if ( arr [ i ] + arr [ j ] < sum ) i ++ ; else if ( arr [ i ] + arr [ j ] > sum ) j -- ; else { int x = arr [ i ] , xx = i ; while ( i < j and arr [ i ] == x ) i ++ ; int y = arr [ j ] , yy = j ; while ( j >= i and arr [ j ] == y ) j -- ; if ( x == y ) { int temp = i - xx + yy - j - 1 ; ans += ( temp * ( temp + 1 ) ) / 2 ; } else ans += ( i - xx ) * ( yy - j ) ; } } return ans ; }
Hyp: 
int pairs_count ( int arr [ ] , int n , int sum ) { int ans = 0 ; sort ( arr , arr + n ) ; int i = 0 , j = n - 1 ; while ( i < j ) { if ( arr [ i ] + arr [ j ] < sum ) i ++ ; else if ( arr [ i ] + arr [ j ] > sum ) j -- ; else { int x = arr [ i ] , xx = i ; while ( i < j && arr [ i ] == x ) i ++ ; int y = arr [ j ] , yy = j ; while ( j >= i && arr [ j ] == y ) j -- ; if ( x == y ) { int temp = i - xx + yy - j - 1 ; ans += ( temp * ( temp + 1 ) ) / 2 ; } else ans += ( i - xx ) * ( yy - j ) ; } } return ans ; }

BLEU: 97.43
Edit Sim: 6


Src: 
function minCells ( mat , m , n ) { let dp = new Array ( m ) ; for ( var i = 0 ; i < dp . length ; i ++ ) { dp [ i ] = new Array ( 2 ) ; } for ( let i = 0 ; i < m ; i ++ ) for ( let j = 0 ; j < n ; j ++ ) dp [ i ] [ j ] = Number . MAX_VALUE ; dp [ 0 ] [ 0 ] = 1 ; for ( let i = 0 ; i < m ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { if ( dp [ i ] [ j ] != Number . MAX_VALUE && ( j + mat [ i ] [ j ] ) < n && ( dp [ i ] [ j ] + 1 ) < dp [ i ] [ j + mat [ i ] [ j ] ] ) dp [ i ] [ j + mat [ i ] [ j ] ] = dp [ i ] [ j ] + 1 ; if ( dp [ i ] [ j ] != Number . MAX_VALUE && ( i + mat [ i ] [ j ] ) < m && ( dp [ i ] [ j ] + 1 ) < dp [ i + mat [ i ] [ j ] ] [ j ] ) dp [ i + mat [ i ] [ j ] ] [ j ] = dp [ i ] [ j ] + 1 ; } } if ( dp [ m - 1 ] [ n - 1 ] != Number . MAX_VALUE ) return dp [ m - 1 ] [ n - 1 ] ; return - 1 ; }
Ref: 
int minCells ( int mat [ SIZE ] [ SIZE ] , int m , int n ) { int dp [ m ] [ n ] ; for ( int i = 0 ; i < m ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) dp [ i ] [ j ] = INT_MAX ; dp [ 0 ] [ 0 ] = 1 ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( dp [ i ] [ j ] != INT_MAX && ( j + mat [ i ] [ j ] ) < n && ( dp [ i ] [ j ] + 1 ) < dp [ i ] [ j + mat [ i ] [ j ] ] ) dp [ i ] [ j + mat [ i ] [ j ] ] = dp [ i ] [ j ] + 1 ; if ( dp [ i ] [ j ] != INT_MAX && ( i + mat [ i ] [ j ] ) < m && ( dp [ i ] [ j ] + 1 ) < dp [ i + mat [ i ] [ j ] ] [ j ] ) dp [ i + mat [ i ] [ j ] ] [ j ] = dp [ i ] [ j ] + 1 ; } } if ( dp [ m - 1 ] [ n - 1 ] != INT_MAX ) return dp [ m - 1 ] [ n - 1 ] ; return -1 ; }
Hyp: 
int minCells ( int mat [ ] [ 3 ] , int m , int n ) { int dp [ m ] [ 3 ] ; for ( int i = 0 ; i < m ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) dp [ i ] [ j ] = INT_MAX ; dp [ 0 ] [ 0 ] = 1 ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( dp [ i ] [ j ] != INT_MAX && ( j + mat [ i ] [ j ] ) < n && ( dp [ i ] [ j ] + 1 ) < dp [ i ] [ j + mat [ i ] [ j ] ] ) dp [ i ] [ j + mat [ i ] [ j ] ] = dp [ i ] [ j ] + 1 ; if ( dp [ i ] [ j ] != INT_MAX && ( i + mat [ i ] [ j ] ) < m && ( dp [ i ] [ j ] + 1 ) < dp [ i + mat [ i ] [ j ] ] [ j ] ) dp [ i + mat [ i ] [ j ] ] [ j ] = dp [ i ] [ j ] + 1 ; } } if ( dp [ m - 1 ] [ n - 1 ] != INT_MAX ) return dp [ m - 1 ] [ n - 1 ] ; return -1 ; }

BLEU: 97.58
Edit Sim: 10


Src: 
function find ( N , sum ) { if ( sum > 6 * N sum < N ) return 0 ; if ( N == 1 ) { if ( sum >= 1 && sum <= 6 ) return 1.0 / 6 ; else return 0 ; } let s = 0 ; for ( let i = 1 ; i <= 6 ; i ++ ) s = s + find ( N - 1 , sum - i ) / 6 ; return s ; }
Ref: 
double find ( int N , int sum ) { if ( sum > 6 * N sum < N ) return 0 ; if ( N == 1 ) { if ( sum >= 1 && sum <= 6 ) return 1.0 / 6 ; else return 0 ; } long double s = 0 ; for ( int i = 1 ; i <= 6 ; i ++ ) s = s + find ( N - 1 , sum - i ) / 6 ; return s ; }
Hyp: 
float find ( int N , int sum ) { if ( sum > 6 * N sum < N ) return 0 ; if ( N == 1 ) { if ( sum >= 1 && sum <= 6 ) return 1.0 / 6 ; else return 0 ; } float s = 0 ; for ( int i = 1 ; i <= 6 ; i ++ ) s = s + find ( N - 1 , sum - i ) / 6 ; return s ; }

BLEU: 95.06
Edit Sim: 16


Src: 
function minimumSteps ( a , b , c ) { if ( a < 1 b < 1 ) return - 1 ; if ( a == 1 && b == 1 ) return c ; if ( a < b ) { a = a + b ; b = a - b ; a = a - b ; } return minimumSteps ( a - b , b , c + 1 ) ; }
Ref: 
int minimumSteps ( int a , int b , int c ) { if ( a < 1 b < 1 ) return -1 ; if ( a == 1 && b == 1 ) return c ; if ( a < b ) { a = a + b ; b = a - b ; a = a - b ; } return minimumSteps ( a - b , b , c + 1 ) ; }
Hyp: 
int minimumSteps ( int a , int b , int c ) { if ( a < 1 b < 1 ) return -1 ; if ( a == 1 && b == 1 ) return c ; if ( a < b ) { a = a + b ; b = a - b ; a = a - b ; } return minimumSteps ( a - b , b , c + 1 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function canReplace ( array , n ) { var i = 0 , count = 0 ; while ( i < n ) { if ( array [ i ] == 0 && ( i == 0 array [ i - 1 ] == 0 ) && ( i == n - 1 array [ i + 1 ] == 0 ) ) { array [ i ] = 1 ; count ++ ; } i ++ ; } return count ; }
Ref: 
int canReplace ( int array [ ] , int n ) { int i = 0 , count = 0 ; while ( i < n ) { if ( array [ i ] == 0 && ( i == 0 array [ i - 1 ] == 0 ) && ( i == n - 1 array [ i + 1 ] == 0 ) ) { array [ i ] = 1 ; count ++ ; } i ++ ; } return count ; }
Hyp: 
int canReplace ( int array [ ] , int n ) { int i = 0 , count = 0 ; while ( i < n ) { if ( array [ i ] == 0 && ( i == 0 array [ i - 1 ] == 0 ) && ( i == n - 1 array [ i + 1 ] == 0 ) ) { array [ i ] = 1 ; count ++ ; } i ++ ; } return count ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function clearBit ( n , k ) { return ( n & ( ~ ( 1 << ( k - 1 ) ) ) ) ; }
Ref: 
int clearBit ( int n , int k ) { return ( n & ( ~ ( 1 << ( k - 1 ) ) ) ) ; }
Hyp: 
int clearBit ( unsigned int n , unsigned int k ) { return ( n & ( ~ ( 1 << ( k - 1 ) ) ) ) ; }

BLEU: 82.93
Edit Sim: 18


Src: 
function countSubStr ( str , len ) { var ans = 0 ; for ( var i = 0 ; i < len ; i ++ ) { if ( str [ i ] == ' ' ) ans += ( i + 1 ) ; } return ans ; }
Ref: 
int countSubStr ( string str , int len ) { int ans = 0 ; for ( int i = 0 ; i < len ; i ++ ) { if ( str [ i ] == '0' ) ans += ( i + 1 ) ; } return ans ; }
Hyp: 
int countSubStr ( string str , int len ) { int ans = 0 ; for ( int i = 0 ; i < len ; i ++ ) { if ( str [ i ] == '1' ) ans += ( i + 1 ) ; } return ans ; }

BLEU: 95.07
Edit Sim: 1


Src: 
function print ( a , n ) { for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { if ( i != j ) document . write ( a [ i ] + " " + a [ j ] + " " ) ; } } }
Ref: 
int print ( int a [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i != j ) cout << a [ i ] << " ▁ " << a [ j ] << " STRNEWLINE " ; } } }
Hyp: 
void print ( int a [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i != j ) cout << a [ i ] << " , ▁ " << a [ j ] << " , ▁ " ; } } }

BLEU: 90.24
Edit Sim: 16


Src: 
function pattern ( str , len ) { for ( var i = 0 ; i < len ; i ++ ) { var j = len - 1 - i ; for ( var k = 0 ; k < len ; k ++ ) { if ( k == i k == j ) document . write ( str . charAt ( k ) ) ; else document . write ( " " ) ; } document . write ( ' ' ) ; } }
Ref: 
void pattern ( string str , int len ) { for ( int i = 0 ; i < len ; i ++ ) { int j = len - 1 - i ; for ( int k = 0 ; k < len ; k ++ ) { if ( k == i k == j ) cout << str [ k ] ; else cout << " ▁ " ; } cout << endl ; } }
Hyp: 
void pattern ( string str , int len ) { for ( int i = 0 ; i < len ; i ++ ) { int j = len - 1 - i ; for ( int k = 0 ; k < len ; k ++ ) { if ( k == i k == j ) cout << str [ k ] ; else cout << '0' ; } cout << '1' ; } }

BLEU: 90.98
Edit Sim: 9


Src: 
function isUpperTriangularMatrix ( mat ) { for ( let i = 1 ; i < N ; i ++ ) for ( let j = 0 ; j < i ; j ++ ) if ( mat [ i ] [ j ] != 0 ) return false ; return true ; }
Ref: 
bool isUpperTriangularMatrix ( int mat [ N ] [ N ] ) { for ( int i = 1 ; i < N ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( mat [ i ] [ j ] != 0 ) return false ; return true ; }
Hyp: 
bool isUpperTriangularMatrix ( int mat [ N ] [ N ] ) { for ( int i = 1 ; i < N ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( mat [ i ] [ j ] != 0 ) return false ; return true ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function sum ( x , y , n ) { sum1 = ( Math . pow ( x , 2 ) * ( Math . pow ( x , 2 * n ) - 1 ) ) / ( Math . pow ( x , 2 ) - 1 ) ; sum2 = ( x * y * ( Math . pow ( x , n ) * Math . pow ( y , n ) - 1 ) ) / ( x * y - 1 ) ; return sum1 + sum2 ; }
Ref: 
int sum ( int x , int y , int n ) { int sum1 = ( pow ( x , 2 ) * ( pow ( x , 2 * n ) - 1 ) ) / ( pow ( x , 2 ) - 1 ) ; int sum2 = ( x * y * ( pow ( x , n ) * pow ( y , n ) - 1 ) ) / ( x * y - 1 ) ; return sum1 + sum2 ; }
Hyp: 
int sum ( int x , int y , int n ) { sum1 = ( pow ( x , 2 ) * ( pow ( x , 2 * n ) - 1 ) ) / ( pow ( x , 2 ) - 1 ) ; sum2 = ( x * y * ( pow ( x , n ) * pow ( y , n ) - 1 ) ) / ( x * y - 1 ) ; return sum1 + sum2 ; }

BLEU: 94.33
Edit Sim: 8


Src: 
function printExpansion ( str ) { var size = 0 ; for ( var i = str . length - 1 ; i >= 0 ; i -- ) { var subStr = str . substring ( i , i + ++ size ) ; document . write ( subStr ) ; } }
Ref: 
void printExpansion ( string str ) { int size = 0 ; for ( int i = str . length ( ) - 1 ; i >= 0 ; i -- ) { string subStr = str . substr ( i , ++ size ) ; cout << subStr ; } }
Hyp: 
void printExpansion ( string str ) { int size = 0 ; for ( int i = str . length ( ) - 1 ; i >= 0 ; i -- ) { string subStr = str . substr ( i , size ) ; cout << subStr ; } }

BLEU: 95.07
Edit Sim: 3


Src: 
function Maxcost ( s , cost ) { let maxcost = 0 ; let i = 0 ; while ( i < s . length - 1 ) { if ( s [ i ] == s [ i + 1 ] ) { if ( cost [ i ] > cost [ i + 1 ] ) maxcost += cost [ i ] ; else { maxcost += cost [ i + 1 ] ; cost [ i + 1 ] = cost [ i ] ; } } i ++ ; } return maxcost ; }
Ref: 
int Maxcost ( string s , int cost [ ] ) { int count = 0 ; int maxcost = 0 , i = 0 ; while ( i < s . size ( ) - 1 ) { if ( s [ i ] == s [ i + 1 ] ) { if ( cost [ i ] > cost [ i + 1 ] ) maxcost += cost [ i ] ; else { maxcost += cost [ i + 1 ] ; cost [ i + 1 ] = cost [ i ] ; } } i += 1 ; } return maxcost ; }
Hyp: 
int Maxcost ( string s , int cost [ ] ) { int maxcost = 0 ; int i = 0 ; while ( i < s . length ( ) - 1 ) { if ( s [ i ] == s [ i + 1 ] ) { if ( cost [ i ] > cost [ i + 1 ] ) maxcost += cost [ i ] ; else { maxcost += cost [ i + 1 ] ; cost [ i + 1 ] = cost [ i ] ; } } i ++ ; } return maxcost ; }

BLEU: 88.25
Edit Sim: 28


Src: 
function replace_elements ( arr , n ) { let pos = 0 ; for ( let i = 0 ; i < n ; i ++ ) { arr [ pos ++ ] = arr [ i ] ; while ( pos > 1 && arr [ pos - 2 ] == arr [ pos - 1 ] ) { pos -- ; arr [ pos - 1 ] ++ ; } } for ( let i = 0 ; i < pos ; i ++ ) document . write ( arr [ i ] + " " ) ; }
Ref: 
void replace_elements ( int arr [ ] , int n ) { int pos = 0 ; for ( int i = 0 ; i < n ; i ++ ) { arr [ pos ++ ] = arr [ i ] ; while ( pos > 1 && arr [ pos - 2 ] == arr [ pos - 1 ] ) { pos -- ; arr [ pos - 1 ] ++ ; } } for ( int i = 0 ; i < pos ; i ++ ) cout << arr [ i ] << " ▁ " ; }
Hyp: 
void replace_elements ( int arr [ ] , int n ) { int pos = 0 ; for ( int i = 0 ; i < n ; i ++ ) { arr [ pos ++ ] = arr [ i ] ; while ( pos > 1 && arr [ pos - 2 ] == arr [ pos - 1 ] ) { pos -- ; arr [ pos - 1 ] ++ ; } } for ( int i = 0 ; i < pos ; i ++ ) cout << arr [ i ] << " ▁ " ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function itemType ( n ) { let count = 0 ; for ( let day = 1 ; ; day ++ ) { for ( let type = day ; type > 0 ; type -- ) { count += type ; if ( count >= n ) return type ; } } }
Ref: 
int itemType ( int n ) { int count = 0 ; for ( int day = 1 ; ; day ++ ) { for ( int type = day ; type > 0 ; type -- ) { count += type ; if ( count >= n ) return type ; } } }
Hyp: 
int itemType ( int n ) { int count = 0 ; for ( int day = 1 ; ; day ++ ) { for ( int type = day ; type > 0 ; type -- ) { count += type ; if ( count >= n ) return type ; } } }

BLEU: 100.0
Edit Sim: 0


Src: 
function CheckBinaryEquivalent ( N ) { return ( N - 1 ) % 8 == 0 ; }
Ref: 
bool CheckBinaryEquivalent ( int N ) { return ( N - 1 ) % 8 == 0 ; }
Hyp: 
bool CheckBinaryEquivalent ( int N ) { return ( N - 1 ) % 8 == 0 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function counLastDigitK ( low , high , k ) { let count = 0 ; for ( let i = low ; i <= high ; i ++ ) if ( i % 10 == k ) count ++ ; return count ; }
Ref: 
int counLastDigitK ( int low , int high , int k ) { int count = 0 ; for ( int i = low ; i <= high ; i ++ ) if ( i % 10 == k ) count ++ ; return count ; }
Hyp: 
int countLastDigitK ( int low , int high , int k ) { int count = 0 ; for ( int i = low ; i <= high ; i ++ ) if ( i % 10 == k ) count ++ ; return count ; }

BLEU: 96.21
Edit Sim: 1


Src: 
function vol_of_dodecahedron ( side ) { return ( ( ( 15 + ( 7 * ( Math . sqrt ( 5 ) ) ) ) / 4 ) * ( Math . pow ( side , 3 ) ) ) ; }
Ref: 
double vol_of_dodecahedron ( int side ) { return ( ( ( 15 + ( 7 * ( sqrt ( 5 ) ) ) ) / 4 ) * ( pow ( side , 3 ) ) ) ; }
Hyp: 
double vol_of_dodecahedron ( int side ) { return ( ( ( 15 + ( 7 * ( sqrt ( 5 ) ) ) ) / 4 ) * pow ( side , 3 ) ) ; }

BLEU: 89.98
Edit Sim: 4


Src: 
function findCount ( str1 , str2 ) { var len = str1 . length ; var len2 = str2 . length ; var ans = 21474836473 ; var hash1 = new Array ( 26 ) . fill ( 0 ) ; var hash2 = new Array ( 26 ) . fill ( 0 ) ; for ( var i = 0 ; i < len ; i ++ ) hash1 [ str1 [ i ] . charCodeAt ( 0 ) - " " . charCodeAt ( 0 ) ] ++ ; for ( var i = 0 ; i < len2 ; i ++ ) hash2 [ str2 [ i ] . charCodeAt ( 0 ) - " " . charCodeAt ( 0 ) ] ++ ; for ( var i = 0 ; i < 26 ; i ++ ) if ( hash2 [ i ] ) ans = Math . min ( ans , hash1 [ i ] / hash2 [ i ] ) ; return ans ; }
Ref: 
int findCount ( string str1 , string str2 ) { int len = str1 . size ( ) ; int len2 = str2 . size ( ) ; int ans = INT_MAX ; int hash1 [ 26 ] = { 0 } , hash2 [ 26 ] = { 0 } ; for ( int i = 0 ; i < len ; i ++ ) hash1 [ str1 [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < len2 ; i ++ ) hash2 [ str2 [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < 26 ; i ++ ) if ( hash2 [ i ] ) ans = min ( ans , hash1 [ i ] / hash2 [ i ] ) ; return ans ; }
Hyp: 
int findCount ( string str1 , string str2 ) { int len = str1 . length ( ) ; int len2 = str2 . length ( ) ; int ans = 21474836473 ; int hash1 [ 26 ] = { 0 } ; int hash2 [ 26 ] = { 0 } ; for ( int i = 0 ; i < len ; i ++ ) hash1 [ str1 [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < len2 ; i ++ ) hash2 [ str2 [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < 26 ; i ++ ) if ( hash2 [ i ] ) ans = min ( ans , hash1 [ i ] / hash2 [ i ] ) ; return ans ; }

BLEU: 92.52
Edit Sim: 28


Src: 
function MinCost ( days , cost , N ) { let size = days [ N - 1 ] + 1 ; let dp = new Array ( size ) ; dp [ size - 1 ] = Math . min ( cost [ 0 ] , Math . min ( cost [ 1 ] , cost [ 2 ] ) ) ; let ptr = N - 2 ; for ( let i = size - 2 ; i > 0 ; i -- ) { if ( ptr >= 0 && days [ ptr ] == i ) { let val1 = dp [ i + 1 ] + cost [ 0 ] ; let val2 = cost [ 1 ] + ( ( i + 7 >= size ) ? 0 : dp [ i + 7 ] ) ; let val3 = cost [ 2 ] + ( ( i + 30 >= size ) ? 0 : dp [ i + 30 ] ) ; dp [ i ] = Math . min ( val1 , Math . min ( val2 , val3 ) ) ; ptr -- ; } else { dp [ i ] = dp [ i + 1 ] ; } } return dp [ 1 ] ; }
Ref: 
int MinCost ( int days [ ] , int cost [ ] , int N ) { int size = days [ N - 1 ] + 1 ; int dp [ size ] ; dp [ size - 1 ] = min ( cost [ 0 ] , min ( cost [ 1 ] , cost [ 2 ] ) ) ; int ptr = N - 2 ; for ( int i = size - 2 ; i > 0 ; i -- ) { if ( ptr >= 0 && days [ ptr ] == i ) { int val1 = dp [ i + 1 ] + cost [ 0 ] ; int val2 = cost [ 1 ] + ( ( i + 7 >= size ) ? 0 : dp [ i + 7 ] ) ; int val3 = cost [ 2 ] + ( ( i + 30 >= size ) ? 0 : dp [ i + 30 ] ) ; dp [ i ] = min ( val1 , min ( val2 , val3 ) ) ; ptr -- ; } else { dp [ i ] = dp [ i + 1 ] ; } } return dp [ 1 ] ; }
Hyp: 
int MinCost ( int days [ N - 1 ] , int cost [ ] , int N ) { int size = days [ N - 1 ] + 1 ; int dp [ size ] ; dp [ size - 1 ] = min ( cost [ 0 ] , min ( cost [ 1 ] , cost [ 2 ] ) ) ; int ptr = N - 2 ; for ( int i = size - 2 ; i > 0 ; i -- ) { if ( ptr >= 0 && days [ ptr ] == i ) { int val1 = dp [ i + 1 ] + cost [ 0 ] ; int val2 = cost [ 1 ] + ( ( i + 7 >= size ) ? 0 : dp [ i + 7 ] ) ; int val3 = cost [ 2 ] + ( ( i + 30 >= size ) ? 0 : dp [ i + 30 ] ) ; dp [ i ] = min ( val1 , min ( val2 , val3 ) ) ; ptr -- ; } else { dp [ i ] = dp [ i + 1 ] ; } } return dp [ 1 ] ; }

BLEU: 97.92
Edit Sim: 6


Src: 
function eulerian ( n , m ) { var dp = Array . from ( Array ( n + 1 ) , ( ) => Array ( m + 1 ) . fill ( 0 ) ) ; for ( var i = 1 ; i <= n ; i ++ ) { for ( var j = 0 ; j <= m ; j ++ ) { if ( i > j ) { if ( j == 0 ) dp [ i ] [ j ] = 1 ; else dp [ i ] [ j ] = ( ( i - j ) * dp [ i - 1 ] [ j - 1 ] ) + ( ( j + 1 ) * dp [ i - 1 ] [ j ] ) ; } } } return dp [ n ] [ m ] ; }
Ref: 
int eulerian ( int n , int m ) { int dp [ n + 1 ] [ m + 1 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= m ; j ++ ) { if ( i > j ) { if ( j == 0 ) dp [ i ] [ j ] = 1 ; else dp [ i ] [ j ] = ( ( i - j ) * dp [ i - 1 ] [ j - 1 ] ) + ( ( j + 1 ) * dp [ i - 1 ] [ j ] ) ; } } } return dp [ n ] [ m ] ; }
Hyp: 
int eulerian ( int n , int m ) { int dp [ n + 1 ] [ m + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= m ; j ++ ) { if ( i > j ) { if ( j == 0 ) dp [ i ] [ j ] = 1 ; else dp [ i ] [ j ] = ( ( i - j ) * dp [ i - 1 ] [ j - 1 ] ) + ( ( j + 1 ) * dp [ i - 1 ] [ j ] ) ; } } } return dp [ n ] [ m ] ; }

BLEU: 91.04
Edit Sim: 36


Src: 
function findEle ( arr , n ) { var sum = 0 ; for ( var i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; for ( var i = 0 ; i < n ; i ++ ) if ( arr [ i ] == sum - arr [ i ] ) return arr [ i ] ; return - 1 ; }
Ref: 
int findEle ( int arr [ ] , int n ) { ll sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == sum - arr [ i ] ) return arr [ i ] ; return -1 ; }
Hyp: 
int findEle ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == sum - arr [ i ] ) return arr [ i ] ; return -1 ; }

BLEU: 96.65
Edit Sim: 3


Src: 
function findDivisors ( n ) { let div = new Array ( n + 1 ) . fill ( 0 ) ; for ( let i = 1 ; i <= n ; i ++ ) { for ( let j = 1 ; j * i <= n ; j ++ ) div [ i * j ] ++ ; } for ( let i = 1 ; i <= n ; i ++ ) document . write ( div [ i ] + " " ) ; }
Ref: 
void findDivisors ( int n ) { int div [ n + 1 ] ; memset ( div , 0 , sizeof div ) ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j * i <= n ; j ++ ) div [ i * j ] ++ ; } for ( int i = 1 ; i <= n ; i ++ ) cout << div [ i ] << " ▁ " ; }
Hyp: 
void findDivisors ( int n ) { int div [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j * i <= n ; j ++ ) div [ i * j ] ++ ; } for ( int i = 1 ; i <= n ; i ++ ) cout << div [ i ] << " ▁ " ; }

BLEU: 87.55
Edit Sim: 34


Src: 
function term ( n ) { let d = 2 ; let a1 = 0 ; An = a1 + ( n - 1 ) * d ; return Math . pow ( An , 3 ) ; }
Ref: 
long term ( int n ) { int d = 2 ; int a1 = 0 ; int An = a1 + ( n - 1 ) * d ; An = pow ( An , 3 ) ; return An ; }
Hyp: 
double term ( int n ) { int d = 2 ; int a1 = 0 ; int An = a1 + ( n - 1 ) * d ; return pow ( An , 3 ) ; }

BLEU: 81.75
Edit Sim: 23


Src: 
function isPath ( arr ) { arr [ 0 ] [ 0 ] = 1 ; for ( var i = 1 ; i < 5 ; i ++ ) if ( arr [ i ] [ 0 ] != - 1 ) arr [ i ] [ 0 ] = arr [ i - 1 ] [ 0 ] ; for ( var j = 1 ; j < 5 ; j ++ ) if ( arr [ 0 ] [ j ] != - 1 ) arr [ 0 ] [ j ] = arr [ 0 ] [ j - 1 ] ; for ( var i = 1 ; i < 5 ; i ++ ) for ( var j = 1 ; j < 5 ; j ++ ) if ( arr [ i ] [ j ] != - 1 ) arr [ i ] [ j ] = Math . max ( arr [ i ] [ j - 1 ] , arr [ i - 1 ] [ j ] ) ; return ( arr [ 5 - 1 ] [ 5 - 1 ] == 1 ) ; }
Ref: 
bool isPath ( int arr [ row ] [ col ] ) { arr [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i < row ; i ++ ) if ( arr [ i ] [ 0 ] != -1 ) arr [ i ] [ 0 ] = arr [ i - 1 ] [ 0 ] ; for ( int j = 1 ; j < col ; j ++ ) if ( arr [ 0 ] [ j ] != -1 ) arr [ 0 ] [ j ] = arr [ 0 ] [ j - 1 ] ; for ( int i = 1 ; i < row ; i ++ ) for ( int j = 1 ; j < col ; j ++ ) if ( arr [ i ] [ j ] != -1 ) arr [ i ] [ j ] = max ( arr [ i ] [ j - 1 ] , arr [ i - 1 ] [ j ] ) ; return ( arr [ row - 1 ] [ col - 1 ] == 1 ) ; }
Hyp: 
bool isPath ( int arr [ ] [ 5 ] ) { arr [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i < 5 ; i ++ ) if ( arr [ i ] [ 0 ] != -1 ) arr [ i ] [ 0 ] = arr [ i - 1 ] [ 0 ] ; for ( int j = 1 ; j < 5 ; j ++ ) if ( arr [ 0 ] [ j ] != -1 ) arr [ 0 ] [ j ] = arr [ 0 ] [ j - 1 ] ; for ( int i = 1 ; i < 5 ; i ++ ) for ( int j = 1 ; j < 5 ; j ++ ) if ( arr [ i ] [ j ] != -1 ) arr [ i ] [ j ] = max ( arr [ i ] [ j - 1 ] , arr [ i - 1 ] [ j ] ) ; return ( arr [ 5 - 1 ] [ 5 - 1 ] == 1 ) ; }

BLEU: 89.97
Edit Sim: 25


Src: 
function KnapSack ( val , wt , n , W ) { let dp = new Array ( W + 1 ) ; for ( let i = 0 ; i < W + 1 ; i ++ ) { dp [ i ] = 0 ; } for ( let i = 0 ; i < n ; i ++ ) for ( let j = W ; j >= wt [ i ] ; j -- ) dp [ j ] = Math . max ( dp [ j ] , val [ i ] + dp [ j - wt [ i ] ] ) ; return dp [ W ] ; }
Ref: 
int KnapSack ( int val [ ] , int wt [ ] , int n , int W ) { int dp [ W + 1 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = W ; j >= wt [ i ] ; j -- ) dp [ j ] = max ( dp [ j ] , val [ i ] + dp [ j - wt [ i ] ] ) ; return dp [ W ] ; }
Hyp: 
int KnapSack ( int val [ ] , int wt [ ] , int n , int W ) { int dp [ W + 1 ] ; for ( int i = 0 ; i < W + 1 ; i ++ ) dp [ i ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = W ; j >= wt [ i ] ; j -- ) dp [ j ] = max ( dp [ j ] , val [ i ] + dp [ j - wt [ i ] ] ) ; return dp [ W ] ; }

BLEU: 80.63
Edit Sim: 36


Src: 
function minimumRectangleArea ( A , N ) { let ans ; A . sort ( ) ; ans = ( A [ N - 1 ] - A [ 0 ] ) * ( A [ 2 * N - 1 ] - A [ N ] ) ; for ( let i = 1 ; i < N ; i ++ ) ans = Math . min ( ans , ( A [ 2 * N - 1 ] - A [ 0 ] ) * ( A [ i + N - 1 ] - A [ i ] ) ) ; return ans ; }
Ref: 
int minimumRectangleArea ( int A [ ] , int N ) { int ans ; sort ( A , A + 2 * N ) ; ans = ( A [ N - 1 ] - A [ 0 ] ) * ( A [ 2 * N - 1 ] - A [ N ] ) ; for ( int i = 1 ; i < N ; i ++ ) ans = min ( ans , ( A [ 2 * N - 1 ] - A [ 0 ] ) * ( A [ i + N - 1 ] - A [ i ] ) ) ; return ans ; }
Hyp: 
int minimumRectangleArea ( int A [ ] , int N ) { int ans ; sort ( A , A + N ) ; ans = ( A [ N - 1 ] - A [ 0 ] ) * ( A [ 2 * N - 1 ] - A [ N ] ) ; for ( int i = 1 ; i < N ; i ++ ) ans = min ( ans , ( A [ 2 * N - 1 ] - A [ 0 ] ) * ( A [ i + N - 1 ] - A [ i ] ) ) ; return ans ; }

BLEU: 96.92
Edit Sim: 4


Src: 
function kthSmallest ( n , k ) { return ( 2 * k ) ; }
Ref: 
int kthSmallest ( int n , int k ) { return ( 2 * k ) ; }
Hyp: 
int kthSmallest ( int n , int k ) { return ( 2 * k ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function maxSubArraySumRepeated ( a , n , k ) { let max_so_far = 0 ; let INT_MIN , max_ending_here = 0 ; for ( let i = 0 ; i < n * k ; i ++ ) { max_ending_here = max_ending_here + a [ i % n ] ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; if ( max_ending_here < 0 ) max_ending_here = 0 ; } return max_so_far ; }
Ref: 
int maxSubArraySumRepeated ( int a [ ] , int n , int k ) { int max_so_far = INT_MIN , max_ending_here = 0 ; for ( int i = 0 ; i < n * k ; i ++ ) { max_ending_here = max_ending_here + a [ i % n ] ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; if ( max_ending_here < 0 ) max_ending_here = 0 ; } return max_so_far ; }
Hyp: 
int maxSubArraySumRepeated ( int a [ ] , int n , int k ) { int max_so_far = 0 ; int INT_MIN , max_ending_here = 0 ; for ( int i = 0 ; i < n * k ; i ++ ) { max_ending_here = max_ending_here + a [ i % n ] ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; if ( max_ending_here < 0 ) max_ending_here = 0 ; } return max_so_far ; }

BLEU: 94.31
Edit Sim: 8


Src: 
function hexagonside ( a ) { if ( a < 0 ) return - 1 ; let x = 0.5176 * a ; return x ; }
Ref: 
float hexagonside ( float a ) { if ( a < 0 ) return -1 ; float x = 0.5176 * a ; return x ; }
Hyp: 
float hexagonside ( float a ) { if ( a < 0 ) return -1 ; float x = 0.5176 * a ; return x ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function arcLength ( diameter , angle ) { let pi = 22.0 / 7.0 ; let arc ; if ( angle >= 360 ) { document . write ( " " + " " ) ; return 0 ; } else { arc = ( pi * diameter ) * ( angle / 360.0 ) ; return arc ; } }
Ref: 
double arcLength ( double diameter , double angle ) { double pi = 22.0 / 7.0 ; double arc ; if ( angle >= 360 ) { cout << " Angle ▁ cannot " , " ▁ be ▁ formed " ; return 0 ; } else { arc = ( pi * diameter ) * ( angle / 360.0 ) ; return arc ; } }
Hyp: 
double arcLength ( double diameter , double angle ) { double pi = 22.0 / 7.0 ; double arc ; if ( angle >= 360 ) { cout << " Angle ▁ is ▁ " << endl ; return 0 ; } else { arc = ( pi * diameter ) * ( angle / 360.0 ) ; return arc ; } }

BLEU: 84.74
Edit Sim: 22


Src: 
function maximumChars ( str ) { let n = str . length ; let res = - 1 ; let firstInd = new Array ( MAX_CHAR ) ; for ( let i = 0 ; i < MAX_CHAR ; i ++ ) firstInd [ i ] = - 1 ; for ( let i = 0 ; i < n ; i ++ ) { let first_ind = firstInd [ str [ i ] . charCodeAt ( 0 ) ] ; if ( first_ind == - 1 ) firstInd [ str [ i ] . charCodeAt ( 0 ) ] = i ; else res = Math . max ( res , Math . abs ( i - first_ind - 1 ) ) ; } return res ; }
Ref: 
int maximumChars ( string & str ) { int n = str . length ( ) ; int res = -1 ; int firstInd [ MAX_CHAR ] ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) firstInd [ i ] = -1 ; for ( int i = 0 ; i < n ; i ++ ) { int first_ind = firstInd [ str [ i ] ] ; if ( first_ind == -1 ) firstInd [ str [ i ] ] = i ; else res = max ( res , abs ( i - first_ind - 1 ) ) ; } return res ; }
Hyp: 
int maximumChars ( string str ) { int n = str . length ( ) ; int res = -1 ; int firstInd [ MAX_CHAR ] ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) firstInd [ i ] = -1 ; for ( int i = 0 ; i < n ; i ++ ) { int first_ind = firstInd [ str [ i ] ] ; if ( first_ind == -1 ) firstInd [ str [ i ] ] = i ; else res = max ( res , abs ( i - first_ind - 1 ) ) ; } return res ; }

BLEU: 97.76
Edit Sim: 2


Src: 
function nCycle ( N ) { return ( N ) * ( N - 1 ) + 1 ; }
Ref: 
int nCycle ( int N ) { return ( N ) * ( N - 1 ) + 1 ; }
Hyp: 
int nCycle ( int N ) { return ( N ) * ( N - 1 ) + 1 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findMinXORSubarray ( arr , n , k ) { if ( n < k ) return ; let res_index = 0 ; let curr_xor = 0 ; for ( let i = 0 ; i < k ; i ++ ) curr_xor ^= arr [ i ] ; let min_xor = curr_xor ; for ( let i = k ; i < n ; i ++ ) { curr_xor ^= ( arr [ i ] ^ arr [ i - k ] ) ; if ( curr_xor < min_xor ) { min_xor = curr_xor ; res_index = ( i - k + 1 ) ; } } document . write ( min_xor ) ; }
Ref: 
void findMinXORSubarray ( int arr [ ] , int n , int k ) { if ( n < k ) return ; int res_index = 0 ; int curr_xor = 0 ; for ( int i = 0 ; i < k ; i ++ ) curr_xor ^= arr [ i ] ; int min_xor = curr_xor ; for ( int i = k ; i < n ; i ++ ) { curr_xor ^= ( arr [ i ] ^ arr [ i - k ] ) ; if ( curr_xor < min_xor ) { min_xor = curr_xor ; res_index = ( i - k + 1 ) ; } } cout << min_xor << " STRNEWLINE " ; }
Hyp: 
void findMinXORSubarray ( int arr [ ] , int n , int k ) { if ( n < k ) return ; int res_index = 0 ; int curr_xor = 0 ; for ( int i = 0 ; i < k ; i ++ ) curr_xor ^= arr [ i ] ; int min_xor = curr_xor ; for ( int i = k ; i < n ; i ++ ) { curr_xor ^= ( arr [ i ] ^ arr [ i - k ] ) ; if ( curr_xor < min_xor ) { min_xor = curr_xor ; res_index = ( i - k + 1 ) ; } } cout << min_xor ; }

BLEU: 95.63
Edit Sim: 18


Src: 
function minMergeCost ( i , j , arr ) { if ( i == j ) return 0 ; if ( v [ i ] [ j ] ) return dp [ i ] [ j ] ; v [ i ] [ j ] = 1 ; var x = dp [ i ] [ j ] ; x = 1000000000 ; var tot = 0 ; for ( var k = i ; k <= j ; k ++ ) tot += arr [ k ] ; for ( var k = i + 1 ; k <= j ; k ++ ) { x = Math . min ( x , tot + minMergeCost ( i , k - 1 , arr ) + minMergeCost ( k , j , arr ) ) ; } return x ; }
Ref: 
int minMergeCost ( int i , int j , int * arr ) { if ( i == j ) return 0 ; if ( v [ i ] [ j ] ) return dp [ i ] [ j ] ; v [ i ] [ j ] = 1 ; int & x = dp [ i ] [ j ] ; x = INT_MAX ; int tot = 0 ; for ( int k = i ; k <= j ; k ++ ) tot += arr [ k ] ; for ( int k = i + 1 ; k <= j ; k ++ ) { x = min ( x , tot + minMergeCost ( i , k - 1 , arr ) + minMergeCost ( k , j , arr ) ) ; } return x ; }
Hyp: 
int minMergeCost ( int i , int j , int arr [ ] ) { if ( i == j ) return 0 ; if ( v [ i ] [ j ] ) return dp [ i ] [ j ] ; v [ i ] [ j ] = 1 ; int x = dp [ i ] [ j ] ; x = INT_MAX ; int tot = 0 ; for ( int k = i ; k <= j ; k ++ ) tot += arr [ k ] ; for ( int k = i + 1 ; k <= j ; k ++ ) { x = min ( x , tot + minMergeCost ( i , k - 1 , arr ) + minMergeCost ( k , j , arr ) ) ; } return x ; }

BLEU: 95.99
Edit Sim: 8


Src: 
function isRefactorableNumber ( n ) { let divCount = 0 ; for ( let i = 1 ; i <= Math . sqrt ( n ) ; ++ i ) { if ( n % i == 0 ) { if ( n / i == i ) ++ divCount ; else divCount += 2 ; } } return n % divCount == 0 ; }
Ref: 
bool isRefactorableNumber ( int n ) { int divCount = 0 ; for ( int i = 1 ; i <= sqrt ( n ) ; ++ i ) { if ( n % i == 0 ) { if ( n / i == i ) ++ divCount ; else divCount += 2 ; } } return n % divCount == 0 ; }
Hyp: 
bool isRefactorableNumber ( int n ) { int divCount = 0 ; for ( int i = 1 ; i <= sqrt ( n ) ; ++ i ) { if ( n % i == 0 ) { if ( n / i == i ) ++ divCount ; else divCount += 2 ; } } return n % divCount == 0 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function repUnitValue ( n ) { if ( n % 2 == 0 n % 5 == 0 ) return 0 ; let rem = 1 ; let power = 1 ; let k = 1 ; while ( rem % n != 0 ) { k ++ ; power = power * 10 % n ; rem = ( rem + power ) % n ; } return k ; }
Ref: 
int repUnitValue ( int n ) { if ( n % 2 == 0 n % 5 == 0 ) return 0 ; int rem = 1 ; int power = 1 ; int k = 1 ; while ( rem % n != 0 ) { k ++ ; power = power * 10 % n ; rem = ( rem + power ) % n ; } return k ; }
Hyp: 
int repUnitValue ( int n ) { if ( n % 2 == 0 n % 5 == 0 ) return 0 ; int rem = 1 ; int power = 1 ; int k = 1 ; while ( rem % n != 0 ) { k ++ ; power = power * 10 % n ; rem = ( rem + power ) % n ; } return k ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function minCost ( arr , n ) { var count_even = 0 ; var count_odd = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) count_even ++ ; else count_odd ++ ; } return Math . min ( count_even , count_odd ) ; }
Ref: 
int minCost ( int arr [ ] , int n ) { int count_even = 0 ; int count_odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) count_even ++ ; else count_odd ++ ; } return min ( count_even , count_odd ) ; }
Hyp: 
int minCost ( int arr [ ] , int n ) { int count_even = 0 , count_odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) count_even ++ ; else count_odd ++ ; } return min ( count_even , count_odd ) ; }

BLEU: 94.52
Edit Sim: 5


Src: 
function countValues ( n ) { let countV = 0 ; for ( let i = 0 ; i <= n ; i ++ ) if ( ( n + i ) == ( n ^ i ) ) countV ++ ; return countV ; }
Ref: 
int countValues ( int n ) { int countV = 0 ; for ( int i = 0 ; i <= n ; i ++ ) if ( ( n + i ) == ( n ^ i ) ) countV ++ ; return countV ; }
Hyp: 
int countValues ( int n ) { int countV = 0 ; for ( int i = 0 ; i <= n ; i ++ ) if ( ( n + i ) == ( n ^ i ) ) countV ++ ; return countV ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function Move ( a , x , b ) { if ( ( ( ( b - a ) % x == 0 ) || ( ( b - a - 1 ) % x == 0 ) && a + 1 != b ) && b >= a ) return true ; return false ; }
Ref: 
bool Move ( int a , int x , int b ) { if ( ( ( ( b - a ) % x == 0 ) || ( ( b - a - 1 ) % x == 0 ) && a + 1 != b ) && b >= a ) return true ; return false ; }
Hyp: 
bool Move ( int a , int x , int b ) { if ( ( ( ( b - a ) % x == 0 ) || ( ( b - a - 1 ) % x == 0 ) && a + 1 != b ) && b >= a ) return true ; return false ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function count ( n ) { return parseInt ( ( - 1 + Math . sqrt ( 1 + 8 * n ) ) / 2 ) ; }
Ref: 
int count ( int n ) { return int ( ( -1 + sqrt ( 1 + 8 * n ) ) / 2 ) ; }
Hyp: 
int count ( int n ) { return ( -1 + sqrt ( 1 + 8 * n ) ) / 2 ; }

BLEU: 77.18
Edit Sim: 8


Src: 
function isRectangle ( a , b , c , d ) { if ( a == b && a == c && a == d && c == d && b == c && b == d ) return true ; else if ( a == b && c == d ) return true ; else if ( a == d && c == b ) return true ; else if ( a == c && d == b ) return true ; else return false ; }
Ref: 
bool isRectangle ( int a , int b , int c , int d ) { if ( a == b == c == d ) return true ; else if ( a == b && c == d ) return true ; else if ( a == d && c == b ) return true ; else if ( a == c && d == b ) return true ; else return false ; }
Hyp: 
bool isRectangle ( int a , int b , int c , int d ) { if ( a == b && a == c && a == d && c == d && b == c && b == d ) return true ; else if ( a == b && c == d ) return true ; else if ( a == d && c == b ) return true ; else if ( a == c && d == b ) return true ; else if ( a == c && d == b ) return true ; else return false ; }

BLEU: 69.85
Edit Sim: 83


Src: 
function solve ( low , high , T ) { while ( low <= high ) { let mid = Math . floor ( ( low + high ) / 2 ) ; if ( ( mid * ( mid + 1 ) ) == T ) return mid ; if ( mid > 0 && ( mid * ( mid + 1 ) ) > T && ( mid * ( mid - 1 ) ) <= T ) return mid - 1 ; if ( ( mid * ( mid + 1 ) ) > T ) high = mid - 1 ; else low = mid + 1 ; } return - 1 ; }
Ref: 
int solve ( int low , int high , int T ) { while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( ( mid * ( mid + 1 ) ) == T ) return mid ; if ( mid > 0 && ( mid * ( mid + 1 ) ) > T && ( mid * ( mid - 1 ) ) <= T ) return mid - 1 ; if ( ( mid * ( mid + 1 ) ) > T ) high = mid - 1 ; else low = mid + 1 ; } return -1 ; }
Hyp: 
int solve ( int low , int high , int T ) { while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( ( mid * ( mid + 1 ) ) == T ) return mid ; if ( mid > 0 && ( mid * ( mid + 1 ) ) > T && ( mid * ( mid - 1 ) ) <= T ) return mid - 1 ; if ( ( mid * ( mid + 1 ) ) > T ) high = mid - 1 ; else low = mid + 1 ; } return -1 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findCnt ( arr , i , curr , n , m ) { if ( i == n ) { return ( curr == m ) ; } if ( v1 [ i ] [ curr ] ) return dp1 [ i ] [ curr ] ; v1 [ i ] [ curr ] = 1 ; dp1 [ i ] [ curr ] = findCnt ( arr , i + 1 , curr , n , m ) + findCnt ( arr , i + 1 , ( curr & arr [ i ] ) , n , m ) ; return dp1 [ i ] [ curr ] ; }
Ref: 
int findCnt ( int * arr , int i , int curr , int n , int m ) { if ( i == n ) { return ( curr == m ) ; } if ( v1 [ i ] [ curr ] ) return dp1 [ i ] [ curr ] ; v1 [ i ] [ curr ] = 1 ; dp1 [ i ] [ curr ] = findCnt ( arr , i + 1 , curr , n , m ) + findCnt ( arr , i + 1 , ( curr & arr [ i ] ) , n , m ) ; return dp1 [ i ] [ curr ] ; }
Hyp: 
int findCnt ( int * arr , int i , int curr , int n , int m ) { if ( i == n ) { return ( curr == m ) ; } if ( v1 [ i ] [ curr ] ) return dp1 [ i ] [ curr ] ; v1 [ i ] [ curr ] = 1 ; dp1 [ i ] [ curr ] = findCnt ( arr , i + 1 , curr , n , m ) + findCnt ( arr , i + 1 , ( curr & arr [ i ] ) , n , m ) ; return dp1 [ i ] [ curr ] ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countDistinctSums ( N , L , R ) { let minSum = L * N ; let maxSum = R * N ; return maxSum - minSum + 1 ; }
Ref: 
int countDistinctSums ( int N , int L , int R ) { int minSum = L * N ; int maxSum = R * N ; return maxSum - minSum + 1 ; }
Hyp: 
int countDistinctSums ( int N , int L , int R ) { int minSum = L * N ; int maxSum = R * N ; return maxSum - minSum + 1 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countFreq ( arr , n , limit ) { let count = new Array ( limit + 1 ) ; count . fill ( 0 ) ; for ( let i = 0 ; i < n ; i ++ ) count [ arr [ i ] ] ++ ; for ( let i = 0 ; i <= limit ; i ++ ) if ( count [ i ] > 0 ) document . write ( i + " " + count [ i ] + " " ) ; }
Ref: 
void countFreq ( int arr [ ] , int n , int limit ) { vector < int > count ( limit + 1 , 0 ) ; for ( int i = 0 ; i < n ; i ++ ) count [ arr [ i ] ] ++ ; for ( int i = 0 ; i <= limit ; i ++ ) if ( count [ i ] > 0 ) cout << i << " ▁ " << count [ i ] << endl ; }
Hyp: 
void countFreq ( int arr [ ] , int n , int limit ) { int count [ limit + 1 ] ; memset ( count , 0 , sizeof ( count ) ) ; for ( int i = 0 ; i < n ; i ++ ) count [ arr [ i ] ] ++ ; for ( int i = 0 ; i <= limit ; i ++ ) if ( count [ i ] ) cout << i << " ▁ " << count [ i ] << " ▁ " ; }

BLEU: 76.6
Edit Sim: 54


Src: 
function ksmallest ( arr , n , k ) { arr . sort ( function ( a , b ) { return a - b } ) ; if ( k < arr [ 0 ] ) return k ; if ( k == arr [ 0 ] ) return arr [ 0 ] + 1 ; if ( k > arr [ n - 1 ] ) return k + n ; if ( arr [ 0 ] == 1 ) k -- ; else k -= ( arr [ 0 ] - 1 ) ; for ( let i = 1 ; i < n ; i ++ ) { let c = arr [ i ] - arr [ i - 1 ] - 1 ; if ( k <= c ) return arr [ i - 1 ] + k ; else k -= c ; } return arr [ n - 1 ] + k ; }
Ref: 
int ksmallest ( int arr [ ] , int n , int k ) { sort ( arr , arr + n ) ; if ( k < arr [ 0 ] ) return k ; if ( k == arr [ 0 ] ) return arr [ 0 ] + 1 ; if ( k > arr [ n - 1 ] ) return k + n ; if ( arr [ 0 ] == 1 ) k -- ; else k -= ( arr [ 0 ] - 1 ) ; for ( int i = 1 ; i < n ; i ++ ) { int c = arr [ i ] - arr [ i - 1 ] - 1 ; if ( k <= c ) return arr [ i - 1 ] + k ; else k -= c ; } return arr [ n - 1 ] + k ; }
Hyp: 
int ksmallest ( int arr [ ] , int n , int k ) { sort ( arr , arr + n ) ; if ( k < arr [ 0 ] ) return k ; if ( k == arr [ 0 ] ) return arr [ 0 ] + 1 ; if ( k > arr [ n - 1 ] ) return k + n ; if ( arr [ 0 ] == 1 ) k -- ; else k -= ( arr [ 0 ] - 1 ) ; for ( int i = 1 ; i < n ; i ++ ) { int c = arr [ i ] - arr [ i - 1 ] - 1 ; if ( k <= c ) return arr [ i - 1 ] + k ; else k -= c ; } return arr [ n - 1 ] + k ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function survival ( S , N , M ) { if ( ( ( N * 6 ) < ( M * 7 ) && S > 6 ) M > N ) document . write ( " " ) ; else { let days = ( M * S ) / N ; if ( ( ( M * S ) % N ) != 0 ) days ++ ; document . write ( " " + Math . round ( days ) ) ; } }
Ref: 
void survival ( int S , int N , int M ) { if ( ( ( N * 6 ) < ( M * 7 ) && S > 6 ) M > N ) cout << " No STRNEWLINE " ; else { int days = ( M * S ) / N ; if ( ( ( M * S ) % N ) != 0 ) days ++ ; cout << " Yes ▁ " << days << endl ; } }
Hyp: 
void survival ( int S , int N , int M ) { if ( ( N * 6 ) < ( M * 7 ) && S > 6 ) M > N ) cout << " NO " ; else { int days = ( M * S ) / N ; if ( ( ( M * S ) % N ) != 0 ) days ++ ; cout << " A " << round ( days ) ; } }

BLEU: 85.75
Edit Sim: 32


Src: 
function sumOfTheSeries ( n ) { let sum = 0.0 ; for ( let i = 1 ; i <= n ; i ++ ) sum += 1.0 / ( i * ( i + 1 ) ) ; return sum ; }
Ref: 
double sumOfTheSeries ( int n ) { double sum = 0.0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += 1.0 / ( i * ( i + 1 ) ) ; return sum ; }
Hyp: 
double sumOfTheSeries ( int n ) { double sum = 0.0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += 1.0 / ( i * ( i + 1 ) ) ; return sum ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countSetBits ( N ) { var count = 0 ; for ( i = 0 ; i < 4 * 8 ; i ++ ) { if ( ( N & ( 1 << i ) ) != 0 ) count ++ ; } return count ; }
Ref: 
int countSetBits ( int N ) { int count = 0 ; for ( int i = 0 ; i < sizeof ( int ) * 8 ; i ++ ) { if ( N & ( 1 << i ) ) count ++ ; } return count ; }
Hyp: 
int countSetBits ( int N ) { int count = 0 ; for ( int i = 0 ; i < 4 * 8 ; i ++ ) { if ( ( N & ( 1 << i ) ) != 0 ) count ++ ; } return count ; }

BLEU: 84.71
Edit Sim: 23


Src: 
function almostSort ( A , n ) { for ( let i = 0 ; i < n - 1 ; i ++ ) { if ( A [ i ] > A [ i + 1 ] ) { let temp = A [ i ] ; A [ i ] = A [ i + 1 ] ; A [ i + 1 ] = temp ; i ++ ; } } for ( let i = 0 ; i < n - 1 ; i ++ ) if ( A [ i ] > A [ i + 1 ] ) return false ; return true ; }
Ref: 
bool almostSort ( int A [ ] , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( A [ i ] > A [ i + 1 ] ) { swap ( A [ i ] , A [ i + 1 ] ) ; i ++ ; } } for ( int i = 0 ; i < n - 1 ; i ++ ) if ( A [ i ] > A [ i + 1 ] ) return false ; return true ; }
Hyp: 
bool almostSort ( int A [ ] , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( A [ i ] > A [ i + 1 ] ) { int temp = A [ i ] ; A [ i ] = A [ i + 1 ] ; A [ i + 1 ] = temp ; i ++ ; } } for ( int i = 0 ; i < n - 1 ; i ++ ) if ( A [ i ] > A [ i + 1 ] ) return false ; return true ; }

BLEU: 80.26
Edit Sim: 39


Src: 
function countSquares ( n ) { return ( Math . pow ( n , 2 ) - ( 2 * n ) + 2 ) ; }
Ref: 
int countSquares ( int n ) { return ( pow ( n , 2 ) - ( 2 * n ) + 2 ) ; }
Hyp: 
int countSquares ( int n ) { return ( pow ( n , 2 ) - ( 2 * n ) + 2 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function getSum ( n , d ) { if ( n < d ) return 0 ; while ( n % 10 != d ) n -- ; k = parseInt ( n / 10 ) ; return ( k + 1 ) * d + ( k * 10 + 10 * k * k ) / 2 ; }
Ref: 
ll getSum ( ll n , int d ) { if ( n < d ) return 0 ; while ( n % 10 != d ) n -- ; ll k = n / 10 ; return ( k + 1 ) * d + ( k * 10 + 10 * k * k ) / 2 ; }
Hyp: 
int digSum ( int n , int d ) { if ( n < d ) return 0 ; while ( n % 10 != d ) n -- ; int k = n / 10 ; return ( k + 1 ) * d + ( k * 10 + 10 * k * k ) / 2 ; }

BLEU: 89.58
Edit Sim: 12


Src: 
function sum ( k , n ) { let sum = 0 ; for ( let i = 0 ; i <= n ; i ++ ) { let p = 1 ; for ( let j = 0 ; j < n - i ; j ++ ) { p = p * k ; } for ( let j = 0 ; j < i ; j ++ ) { p = p * ( k - 1 ) ; } sum = sum + p ; } return sum ; }
Ref: 
int sum ( int k , int n ) { int sum = pow ( k , n + 1 ) - pow ( k - 1 , n + 1 ) ; return sum ; }
Hyp: 
int sum ( int k , int n ) { int sum = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { int p = 1 ; for ( int j = 0 ; j < n - i ; j ++ ) { p = p * k ; } for ( int j = 0 ; j < i ; j ++ ) { p = p * ( k - 1 ) ; } sum = sum + p ; } return sum ; }

BLEU: 20.56
Edit Sim: 147


Src: 
function pen_hex ( n ) { var pn = 1 ; for ( i = 1 ; i < n ; i ++ ) { pn = parseInt ( i * ( 3 * i - 1 ) / 2 ) ; if ( pn > n ) break ; var seqNum = ( 1 + Math . sqrt ( 8 * pn + 1 ) ) / 4 ; if ( seqNum == parseInt ( seqNum ) ) document . write ( pn + " " ) ; } }
Ref: 
void pen_hex ( long long n ) { long long pn = 1 ; for ( long long int i = 1 ; ; i ++ ) { pn = i * ( 3 * i - 1 ) / 2 ; if ( pn > n ) break ; long double seqNum = ( 1 + sqrt ( 8 * pn + 1 ) ) / 4 ; if ( seqNum == long ( seqNum ) ) cout << pn << " , ▁ " ; } }
Hyp: 
void pen_hex ( int n ) { int pn = 1 ; for ( int i = 1 ; i < n ; i ++ ) { pn = i * ( 3 * i - 1 ) / 2 ; if ( pn > n ) break ; int seqNum = ( 1 + sqrt ( 8 * pn + 1 ) ) / 4 ; if ( seqNum == ( int ) seqNum ) cout << pn << " ▁ " ; } }

BLEU: 73.68
Edit Sim: 49


Src: 
function countOfPairs ( arr , N , X ) { let count = 0 ; for ( let i = 0 ; i < N - 1 ; i ++ ) { for ( let j = i + 1 ; j < N ; j ++ ) { if ( ( ( arr [ i ] ^ arr [ j ] ) & X ) == 0 ) count ++ ; } } return count ; }
Ref: 
int countOfPairs ( int arr [ ] , int N , int X ) { int count = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( ( ( arr [ i ] ^ arr [ j ] ) & X ) == 0 ) count ++ ; } } return count ; }
Hyp: 
int countOfPairs ( int arr [ ] , int N , int X ) { int count = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( ( arr [ i ] ^ arr [ j ] ) & X ) count ++ ; } } return count ; }

BLEU: 93.82
Edit Sim: 9


Src: 
function calculate ( n , k , m , power ) { if ( n > m ) { if ( power == 0 ) return 0 ; else return power - 1 ; } else if ( n == m ) return power ; else return calculate ( n * k , k , m , power + 1 ) ; }
Ref: 
int calculate ( ll int n , ll int k , ll int m , ll int power ) { if ( n > m ) { if ( power == 0 ) return 0 ; else return power - 1 ; } else if ( n == m ) return power ; else return calculate ( n * k , k , m , power + 1 ) ; }
Hyp: 
int calculate ( int n , int k , int m , int power ) { if ( n > m ) { if ( power == 0 ) return 0 ; else return power - 1 ; } else if ( n == m ) return power ; else return calculate ( n * k , k , m , power + 1 ) ; }

BLEU: 85.35
Edit Sim: 12


Src: 
function noOfTriangles ( n ) { var y = 4 * n ; return ( ( y * ( y - 2 ) * ( y - 1 ) ) - ( 4 * n * ( n - 2 ) * ( n - 1 ) ) ) / 6 ; }
Ref: 
int noOfTriangles ( int n ) { int y = 4 * n ; return ( ( y * ( y - 2 ) * ( y - 1 ) ) - ( 4 * n * ( n - 2 ) * ( n - 1 ) ) ) / 6 ; }
Hyp: 
int noOfTriangles ( int n ) { int y = 4 * n ; return ( ( y * ( y - 2 ) * ( y - 1 ) ) - ( 4 * n * ( n - 2 ) * ( n - 1 ) ) ) / 6 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function minimumProduct ( arr , n ) { arr . sort ( ) ; let product = 1 ; for ( let i = 0 ; i < n ; i += 2 ) { product *= ( arr [ i ] + arr [ i + 1 ] ) ; } return product ; }
Ref: 
int minimumProduct ( int * arr , int n ) { sort ( arr , arr + n ) ; int product = 1 ; for ( int i = 0 ; i < n ; i += 2 ) { product *= ( arr [ i ] + arr [ i + 1 ] ) ; } return product ; }
Hyp: 
int minimumProduct ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int product = 1 ; for ( int i = 0 ; i < n ; i += 2 ) { product *= ( arr [ i ] + arr [ i + 1 ] ) ; } return product ; }

BLEU: 93.12
Edit Sim: 6


Src: 
function bitwiseOrTillN ( n ) { if ( n < 2 ) return 0 ; var bitCount = parseInt ( Math . log2 ( n ) + 1 ) ; return Math . pow ( 2 , bitCount ) - 2 ; }
Ref: 
int bitwiseOrTillN ( int n ) { if ( n < 2 ) return 0 ; int bitCount = log2 ( n ) + 1 ; return pow ( 2 , bitCount ) - 2 ; }
Hyp: 
int bitwiseOrTillN ( int n ) { if ( n < 2 ) return 0 ; int bitCount = log2 ( n ) + 1 ; return pow ( 2 , bitCount ) - 2 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function checkperfectsquare ( n ) { if ( Math . ceil ( Math . sqrt ( n ) ) == Math . floor ( Math . sqrt ( n ) ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; } }
Ref: 
void checkperfectsquare ( int n ) { if ( ceil ( ( double ) sqrt ( n ) ) == floor ( ( double ) sqrt ( n ) ) ) { cout << " perfect ▁ square " ; } else { cout << " not ▁ a ▁ perfect ▁ square " ; } }
Hyp: 
void checkperfectsquare ( int n ) { if ( ceil ( sqrt ( n ) ) == floor ( sqrt ( n ) ) ) { cout << " YES " ; } else { cout << " NO " ; } }

BLEU: 57.86
Edit Sim: 64


Src: 
function pairAndSum ( arr , n ) { for ( let i = 0 ; i < n ; i ++ ) for ( let j = i + 1 ; j < n ; j ++ ) ans += arr [ i ] & arr [ j ] ; return ans ; }
Ref: 
int pairAndSum ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) ans += arr [ i ] & arr [ j ] ; return ans ; }
Hyp: 
int pairAndSum ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) ans += arr [ i ] & arr [ j ] ; return ans ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function solve ( a ) { let n = a . length ; let dp = new Array ( n + 1 ) . fill ( 0 ) ; let val = new Array ( n + 1 ) . fill ( 0 ) ; for ( let i = n - 1 ; i >= 0 ; i -- ) { let sum = a [ i ] ; let j = i ; while ( j + 1 < n && sum < val [ j + 1 ] ) { j ++ ; sum += a [ j ] ; } dp [ i ] = ( j - i ) + dp [ j + 1 ] ; val [ i ] = sum ; } return dp [ 0 ] ; }
Ref: 
int solve ( vector < int > & a ) { int n = a . size ( ) ; vector < int > dp ( n + 1 , 0 ) , val ( n + 1 , 0 ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { long long sum = a [ i ] ; int j = i ; while ( j + 1 < n and sum < val [ j + 1 ] ) { j ++ ; sum += a [ j ] ; } dp [ i ] = ( j - i ) + dp [ j + 1 ] ; val [ i ] = sum ; } return dp [ 0 ] ; }
Hyp: 
int solve ( int a [ ] , int n ) { int n = a . length ( ) ; int dp [ n + 1 ] , val [ n + 1 ] ; for ( int i = n - 1 ; i >= 0 ; i -- ) { int sum = a [ i ] ; int j = i ; while ( j + 1 < n && sum < val [ j + 1 ] ) { j ++ ; sum += a [ j ] ; } dp [ i ] = ( j - i ) + dp [ j + 1 ] ; val [ i ] = sum ; } return dp [ 0 ] ; }

BLEU: 74.52
Edit Sim: 53


Src: 
function longestSubseqWithDiffOne ( arr , n ) { let dp = [ ] ; for ( let i = 0 ; i < n ; i ++ ) dp [ i ] = 1 ; for ( let i = 1 ; i < n ; i ++ ) { for ( let j = 0 ; j < i ; j ++ ) { if ( ( arr [ i ] == arr [ j ] + 1 ) || ( arr [ i ] == arr [ j ] - 1 ) ) dp [ i ] = Math . max ( dp [ i ] , dp [ j ] + 1 ) ; } } let result = 1 ; for ( let i = 0 ; i < n ; i ++ ) if ( result < dp [ i ] ) result = dp [ i ] ; return result ; }
Ref: 
int longestSubseqWithDiffOne ( int arr [ ] , int n ) { int dp [ n ] ; for ( int i = 0 ; i < n ; i ++ ) dp [ i ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( ( arr [ i ] == arr [ j ] + 1 ) || ( arr [ i ] == arr [ j ] - 1 ) ) dp [ i ] = max ( dp [ i ] , dp [ j ] + 1 ) ; } } int result = 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( result < dp [ i ] ) result = dp [ i ] ; return result ; }
Hyp: 
int longestSubseqWithDiffOne ( int arr [ ] , int n ) { int dp [ n ] ; for ( int i = 0 ; i < n ; i ++ ) dp [ i ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( ( arr [ i ] == arr [ j ] + 1 ) || ( arr [ i ] == arr [ j ] - 1 ) ) dp [ i ] = max ( dp [ i ] , dp [ j ] + 1 ) ; } } int result = 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( result < dp [ i ] ) result = dp [ i ] ; return result ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function longestSubSequence ( A , N ) { let dp = new Array ( N ) ; for ( let i = 0 ; i < N ; i ++ ) { dp [ i ] = 1 ; for ( let j = 0 ; j < i ; j ++ ) { if ( A [ j ] [ 0 ] < A [ i ] [ 0 ] && A [ j ] [ 1 ] > A [ i ] [ 1 ] ) { dp [ i ] = Math . max ( dp [ i ] , dp [ j ] + 1 ) ; } } } document . write ( dp [ N - 1 ] + " " ) ; }
Ref: 
void longestSubSequence ( pair < int , int > A [ ] , int N ) { int dp [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { dp [ i ] = 1 ; for ( int j = 0 ; j < i ; j ++ ) { if ( A [ j ] . first < A [ i ] . first && A [ j ] . second > A [ i ] . second ) { dp [ i ] = max ( dp [ i ] , dp [ j ] + 1 ) ; } } } cout << dp [ N - 1 ] << endl ; }
Hyp: 
void longestSubSequence ( int A [ ] [ 2 ] , int N ) { int dp [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { dp [ i ] = 1 ; for ( int j = 0 ; j < i ; j ++ ) { if ( A [ j ] [ 0 ] < A [ i ] [ 0 ] && A [ j ] [ 1 ] > A [ i ] [ 1 ] ) { dp [ i ] = max ( dp [ i ] , dp [ j ] + 1 ) ; } } } cout << dp [ N - 1 ] << " ▁ " ; }

BLEU: 77.91
Edit Sim: 45


Src: 
function MinimumValue ( a , n ) { let answer = Number . MAX_SAFE_INTEGER ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i + 1 ; j < n ; j ++ ) { answer = Math . min ( answer , ( ( a [ i ] & a [ j ] ) ^ ( a [ i ] a [ j ] ) ) ) ; } } return answer ; }
Ref: 
int MinimumValue ( int a [ ] , int n ) { int answer = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { answer = min ( answer , ( ( a [ i ] & a [ j ] ) ^ ( a [ i ] a [ j ] ) ) ) ; } } return answer ; }
Hyp: 
int MinimumValue ( int a [ ] , int n ) { int answer = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { answer = min ( answer , ( ( a [ i ] & a [ j ] ) ^ ( a [ i ] a [ j ] ) ) ) ; } } return answer ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function sumOfInfiniteAGP ( a , d , r ) { let ans = a / ( 1 - r ) + ( d * r ) / ( 1 - r * r ) ; document . write ( ans ) }
Ref: 
void sumOfInfiniteAGP ( double a , double d , double r ) { double ans = a / ( 1 - r ) + ( d * r ) / ( 1 - r * r ) ; cout << ans ; }
Hyp: 
void sumOfInfiniteAGP ( double a , double d , double r ) { double ans = a / ( 1 - r ) + ( d * r ) / ( 1 - r * r ) ; cout << ans ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function checkHex ( s ) { let n = s . length ; for ( let i = 0 ; i < n ; i ++ ) { let ch = s [ i ] ; if ( ( ch < ' ' ch > ' ' ) && ( ch < ' ' ch > ' ' ) ) { document . write ( " " ) ; return ; } } document . write ( " " ) ; }
Ref: 
void checkHex ( string s ) { int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { char ch = s [ i ] ; if ( ( ch < '0' ch > '9' ) && ( ch < ' A ' ch > ' F ' ) ) { cout << " No " << endl ; return ; } } cout << " Yes " << endl ; }
Hyp: 
void checkHex ( string s ) { int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { char ch = s [ i ] ; if ( ( ch < ' A ' ch > ' Z ' ) && ( ch < ' a ' ch > ' z ' ) ) { cout << " No " ; return ; } } cout << " Yes " ; }

BLEU: 83.13
Edit Sim: 24


Src: 
function smallestMaximum ( N , K ) { let sum = Math . floor ( ( N + K - 1 ) / K ) * K ; if ( sum % N != 0 ) return Math . floor ( sum / N ) + 1 ; else return Math . floor ( sum / N ) ; }
Ref: 
int smallestMaximum ( int N , int K ) { int sum = ( ( N + K - 1 ) / K ) * K ; if ( sum % N != 0 ) return ( sum / N ) + 1 ; else return sum / N ; }
Hyp: 
int smallestMaximum ( int N , int K ) { int sum = ( N + K - 1 ) / K ; if ( sum % N != 0 ) return sum / N + 1 ; else return sum / N ; }

BLEU: 78.07
Edit Sim: 12


Src: 
function FractionSplit ( n , d ) { let UnitFactions = [ ] ; while ( n > 0 ) { let x = Math . floor ( ( d + n - 1 ) / n ) ; let s = " " + String ( x ) ; UnitFactions . push ( s ) ; n = n * x - d ; d = d * x ; } return UnitFactions ; }
Ref: 
> FractionSplit ( long long n , long long d ) { vector < string > UnitFactions ; while ( n > 0 ) { long long x = ( d + n - 1 ) / n ; string s = "1 / " + to_string ( x ) ; UnitFactions . push_back ( s ) ; n = n * x - d ; d = d * x ; } return UnitFactions ; }
Hyp: 
string FractionSplit ( int n , int d ) { string [ ] UnitFactions ; while ( n > 0 ) { int x = ( d + n - 1 ) / n ; string s = " ▁ " << x ; UnitFactions . push_back ( s ) ; n = n * x - d ; d = d * x ; } return UnitFactions ; }

BLEU: 66.1
Edit Sim: 59


Src: 
function sameLength ( A , B ) { while ( A > 0 && B > 0 ) { A = parseInt ( A / 10 ) ; B = parseInt ( B / 10 ) ; } if ( A == 0 && B == 0 ) return true ; return false ; }
Ref: 
bool sameLength ( int A , int B ) { while ( A > 0 && B > 0 ) { A = A / 10 ; B = B / 10 ; } if ( A == 0 && B == 0 ) return true ; return false ; }
Hyp: 
bool sameLength ( int A , int B ) { while ( A > 0 && B > 0 ) { A /= 10 ; B /= 10 ; } if ( A == 0 && B == 0 ) return true ; return false ; }

BLEU: 81.72
Edit Sim: 10


Src: 
function calculateSquareSum ( n ) { if ( n <= 0 ) return 0 ; var fibo = Array ( n + 1 ) . fill ( 0 ) ; fibo [ 0 ] = 0 ; fibo [ 1 ] = 1 ; var sum = ( fibo [ 0 ] * fibo [ 0 ] ) + ( fibo [ 1 ] * fibo [ 1 ] ) ; for ( i = 2 ; i <= n ; i ++ ) { fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ; sum += ( fibo [ i ] * fibo [ i ] ) ; } return sum ; }
Ref: 
int calculateSquareSum ( int n ) { if ( n <= 0 ) return 0 ; int fibo [ n + 1 ] ; fibo [ 0 ] = 0 , fibo [ 1 ] = 1 ; int sum = ( fibo [ 0 ] * fibo [ 0 ] ) + ( fibo [ 1 ] * fibo [ 1 ] ) ; for ( int i = 2 ; i <= n ; i ++ ) { fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ; sum += ( fibo [ i ] * fibo [ i ] ) ; } return sum ; }
Hyp: 
int calculateSquareSum ( int n ) { if ( n <= 0 ) return 0 ; int fibo [ n + 1 ] ; fibo [ 0 ] = 0 ; fibo [ 1 ] = 1 ; int sum = ( fibo [ 0 ] * fibo [ 0 ] ) + ( fibo [ 1 ] * fibo [ 1 ] ) ; for ( int i = 2 ; i <= n ; i ++ ) { fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ; sum += ( fibo [ i ] * fibo [ i ] ) ; } return sum ; }

BLEU: 97.86
Edit Sim: 1


Src: 
function maximum_pallindromic ( arr ) { var res = 0 ; var c1 = 0 , c2 = 0 ; for ( var i = 0 ; i < 26 ; i ++ ) { res += parseInt ( arr [ i ] / 3 ) ; arr [ i ] = ( arr [ i ] % 3 ) ; if ( arr [ i ] == 1 ) c1 ++ ; else if ( arr [ i ] == 2 ) c2 ++ ; } res += Math . min ( c1 , c2 ) ; var t = Math . min ( c1 , c2 ) ; c1 -= t ; c2 -= t ; res += 2 * parseInt ( c2 / 3 ) ; c2 %= 3 ; res += parseInt ( c2 / 2 ) ; document . write ( res ) ; }
Ref: 
void maximum_pallindromic ( int arr [ ] ) { int res = 0 ; int c1 = 0 , c2 = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) { res += arr [ i ] / 3 ; arr [ i ] = arr [ i ] % 3 ; if ( arr [ i ] == 1 ) c1 ++ ; else if ( arr [ i ] == 2 ) c2 ++ ; } res += min ( c1 , c2 ) ; int t = min ( c1 , c2 ) ; c1 -= t ; c2 -= t ; res += 2 * ( c2 / 3 ) ; c2 %= 3 ; res += c2 / 2 ; cout << res ; }
Hyp: 
void maximum_pallindromic ( int arr [ ] , int n ) { int res = 0 ; int c1 = 0 , c2 = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) { res += arr [ i ] / 3 ; arr [ i ] = ( arr [ i ] % 3 ) ; if ( arr [ i ] == 1 ) c1 ++ ; else if ( arr [ i ] == 2 ) c2 ++ ; } res += min ( c1 , c2 ) ; int t = min ( c1 , c2 ) ; c1 -= t ; c2 -= t ; res += 2 * c2 / 3 ; c2 %= 3 ; res += c2 / 2 ; cout << res ; }

BLEU: 91.95
Edit Sim: 16


Src: 
function isEven ( s ) { let l = s . length ; let dotSeen = false ; for ( let i = l - 1 ; i >= 0 ; i -- ) { if ( s [ i ] == ' ' && dotSeen == false ) continue ; if ( s [ i ] == ' ' ) { dotSeen = true ; continue ; } if ( ( s [ i ] - ' ' ) % 2 == 0 ) return true ; return false ; } }
Ref: 
bool isEven ( string s ) { int l = s . length ( ) ; bool dotSeen = false ; for ( int i = l - 1 ; i >= 0 ; i -- ) { if ( s [ i ] == '0' && dotSeen == false ) continue ; if ( s [ i ] == ' . ' ) { dotSeen = true ; continue ; } if ( ( s [ i ] - '0' ) % 2 == 0 ) return true ; return false ; } }
Hyp: 
bool isEven ( string s ) { int l = s . length ( ) ; bool dotSeen = false ; for ( int i = l - 1 ; i >= 0 ; i -- ) { if ( s [ i ] == '0' && dotSeen == false ) continue ; if ( s [ i ] == '1' ) { dotSeen = true ; continue ; } if ( ( s [ i ] - '0' ) % 2 == 0 ) return true ; return false ; } }

BLEU: 95.2
Edit Sim: 3


Src: 
function right_angled ( n ) { var count = 0 ; for ( z = 1 ; z <= n ; z ++ ) { for ( y = 1 ; y <= z ; y ++ ) { for ( x = 1 ; x <= y ; x ++ ) { if ( ( x * x ) + ( y * y ) == ( z * z ) ) { count ++ ; } } } } return count ; }
Ref: 
int right_angled ( int n ) { int count = 0 ; for ( int z = 1 ; z <= n ; z ++ ) { for ( int y = 1 ; y <= z ; y ++ ) { for ( int x = 1 ; x <= y ; x ++ ) { if ( ( x * x ) + ( y * y ) == ( z * z ) ) { count ++ ; } } } } return count ; }
Hyp: 
int right_angled ( int n ) { int count = 0 ; for ( int z = 1 ; z <= n ; z ++ ) { for ( int y = 1 ; y <= z ; y ++ ) { for ( int x = 1 ; x <= y ; x ++ ) { if ( ( x * x ) + ( y * y ) == ( z * z ) ) { count ++ ; } } } } return count ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function isSumOfPowersOfTwo ( n ) { if ( n % 2 == 1 ) return false ; else return true ; }
Ref: 
bool isSumOfPowersOfTwo ( int n ) { if ( n % 2 == 1 ) return false ; else return true ; }
Hyp: 
bool isSumOfPowersOfTwo ( int n ) { if ( n % 2 == 1 ) return false ; else return true ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function nambiarNumber ( str , i ) { if ( i >= str . length ) return " " ; let firstDigit = ( str [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ) ; let digitParity = firstDigit % 2 ; let sumDigits = 0 ; while ( i < str . length ) { sumDigits += ( str [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ) ; let sumParity = sumDigits % 2 ; if ( digitParity != sumParity ) { break ; } i ++ ; } return ( " " + sumDigits + nambiarNumber ( str , i + 1 ) ) ; }
Ref: 
string numbiarNumber ( string str , int i ) { if ( i > str . length ( ) ) return " " ; int firstDigit = str [ i ] - '0' ; int digitParity = firstDigit % 2 ; int sumDigits = 0 ; while ( i < str . length ( ) ) { sumDigits += ( str [ i ] - '0' ) ; int sumParity = sumDigits % 2 ; if ( digitParity != sumParity ) break ; i ++ ; } return ( to_string ( sumDigits ) + numbiarNumber ( str , i + 1 ) ) ; }
Hyp: 
string nambiarNumber ( string str , int i ) { if ( i >= str . length ( ) ) return " " ; int firstDigit = ( str [ i ] - '0' ) ; int digitParity = firstDigit % 2 ; int sumDigits = 0 ; while ( i < str . length ( ) ) { sumDigits += ( str [ i ] - '0' ) ; int sumParity = sumDigits % 2 ; if ( digitParity != sumParity ) { break ; } i ++ ; } return " " + sumDigits + nambiarNumber ( str , i + 1 ) ; }

BLEU: 79.51
Edit Sim: 26


Src: 
function sumofseries ( n ) { return ( n * ( n + 1 ) * ( n + 2 ) * ( n + 3 ) / 4 ) ; }
Ref: 
int sumofseries ( int n ) { return ( n * ( n + 1 ) * ( n + 2 ) * ( n + 3 ) / 4 ) ; }
Hyp: 
int sumofseries ( int n ) { return ( n * ( n + 1 ) * ( n + 2 ) * ( n + 3 ) / 4 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function difference ( n ) { let S , res ; S = Math . floor ( ( n * ( n + 1 ) ) / 2 ) ; res = S * ( S - 1 ) ; return res ; }
Ref: 
int difference ( int n ) { int S , res ; S = ( n * ( n + 1 ) ) / 2 ; res = S * ( S - 1 ) ; return res ; }
Hyp: 
int difference ( int n ) { int S , res ; S = ( n * ( n + 1 ) ) / 2 ; res = S * ( S - 1 ) ; return res ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function colMaxDiff ( mat ) { let max_diff = Number . MIN_VALUE ; for ( let i = 0 ; i < N ; i ++ ) { let max_val = mat [ 0 ] [ i ] , min_val = mat [ 0 ] [ i ] ; for ( let j = 1 ; j < N ; j ++ ) { max_val = Math . max ( max_val , mat [ j ] [ i ] ) ; min_val = Math . min ( min_val , mat [ j ] [ i ] ) ; } max_diff = Math . max ( max_diff , max_val - min_val ) ; } return max_diff ; }
Ref: 
int colMaxDiff ( int mat [ N ] [ N ] ) { int max_diff = INT_MIN ; for ( int i = 0 ; i < N ; i ++ ) { int max_val = mat [ 0 ] [ i ] , min_val = mat [ 0 ] [ i ] ; for ( int j = 1 ; j < N ; j ++ ) { max_val = max ( max_val , mat [ j ] [ i ] ) ; min_val = min ( min_val , mat [ j ] [ i ] ) ; } max_diff = max ( max_diff , max_val - min_val ) ; } return max_diff ; }
Hyp: 
int colMaxDiff ( int mat [ N ] [ M ] ) { int max_diff = INT_MIN ; for ( int i = 0 ; i < N ; i ++ ) { int max_val = mat [ 0 ] [ i ] , min_val = mat [ 0 ] [ i ] ; for ( int j = 1 ; j < N ; j ++ ) { max_val = max ( max_val , mat [ j ] [ i ] ) ; min_val = min ( min_val , mat [ j ] [ i ] ) ; } max_diff = max ( max_diff , max_val - min_val ) ; } return max_diff ; }

BLEU: 97.82
Edit Sim: 1


Src: 
function countSquares ( n ) { let r = Math . ceil ( Math . sqrt ( Math . pow ( 10 , n ) ) ) ; let l = Math . ceil ( Math . sqrt ( Math . pow ( 10 , n - 1 ) ) ) ; return r - l ; }
Ref: 
int countSquares ( int n ) { int r = ceil ( sqrt ( pow ( 10 , n ) ) ) ; int l = ceil ( sqrt ( pow ( 10 , n - 1 ) ) ) ; return r - l ; }
Hyp: 
int countSquares ( int n ) { int r = ceil ( sqrt ( pow ( 10 , n ) ) ) ; int l = ceil ( sqrt ( pow ( 10 , n - 1 ) ) ) ; return r - l ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function getMaxMedian ( arr , n , k ) { let size = n + k ; arr . sort ( ( a , b ) => a - b ) ; if ( size % 2 == 0 ) { let median = ( arr [ Math . floor ( size / 2 ) - 1 ] + arr [ Math . floor ( size / 2 ) ] ) / 2 ; return median ; } let median = arr [ Math . floor ( size / 2 ) ] ; return median ; }
Ref: 
float getMaxMedian ( int arr [ ] , int n , int k ) { int size = n + k ; sort ( arr , arr + n ) ; if ( size % 2 == 0 ) { float median = ( float ) ( arr [ ( size / 2 ) - 1 ] + arr [ size / 2 ] ) / 2 ; return median ; } float median = arr [ size / 2 ] ; return median ; }
Hyp: 
int getMaxMedian ( int arr [ ] , int n , int k ) { int size = n + k ; sort ( arr , arr + size ) ; if ( size % 2 == 0 ) { int median = ( arr [ size / 2 - 1 ] + arr [ size / 2 ] ) / 2 ; return median ; } int median = arr [ size / 2 ] ; return median ; }

BLEU: 79.23
Edit Sim: 30


Src: 
function printOriginalMatrix ( a , b , mat ) { for ( let i = 0 ; i < N ; i ++ ) { for ( let j = 0 ; j < M ; j ++ ) { if ( mat [ i ] [ j ] == 1 ) document . write ( Math . min ( a [ i ] , b [ j ] ) + " " ) ; else document . write ( " " + " " ) ; } document . write ( " " ) ; } }
Ref: 
void printOriginalMatrix ( int a [ ] , int b [ ] , int mat [ N ] [ M ] ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { if ( mat [ i ] [ j ] == 1 ) cout << min ( a [ i ] , b [ j ] ) << " ▁ " ; else cout << 0 << " ▁ " ; } cout << endl ; } }
Hyp: 
void printOriginalMatrix ( int a [ ] , int b [ ] , int mat [ N ] [ M ] ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { if ( mat [ i ] [ j ] == 1 ) cout << min ( a [ i ] , b [ j ] ) << " ▁ " ; else cout << " - 1" << " ▁ " ; } cout << " STRNEWLINE " ; } }

BLEU: 91.25
Edit Sim: 20


Src: 
function squareRootExists ( n , p ) { n = n % p ; for ( let x = 2 ; x < p ; x ++ ) if ( ( x * x ) % p == n ) return true ; return false ; }
Ref: 
bool squareRootExists ( int n , int p ) { n = n % p ; for ( int x = 2 ; x < p ; x ++ ) if ( ( x * x ) % p == n ) return true ; return false ; }
Hyp: 
bool squareRootExists ( int n , int p ) { n = n % p ; for ( int x = 2 ; x < p ; x ++ ) if ( ( x * x ) % p == n ) return true ; return false ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function properDivisorSum ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; ++ i ) { for ( let j = 1 ; j * j <= i ; ++ j ) { if ( i % j == 0 ) { if ( i / j == j ) sum += j ; else sum += j + i / j ; } } sum = sum - i ; } return sum ; }
Ref: 
int properDivisorSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j * j <= i ; ++ j ) { if ( i % j == 0 ) { if ( i / j == j ) sum += j ; else sum += j + i / j ; } } sum = sum - i ; } return sum ; }
Hyp: 
int properDivisorSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j * j <= i ; ++ j ) { if ( i % j == 0 ) { if ( i / j == j ) sum += j ; else sum += j + i / j ; } } sum = sum - i ; } return sum ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function equation_parabola ( x1 , y1 , a , b , c ) { var t = a * a + b * b ; var a1 = t - ( a * a ) ; var b1 = t - ( b * b ) ; var c1 = ( - 2 * t * x1 ) - ( 2 * c * a ) ; var d1 = ( - 2 * t * y1 ) - ( 2 * c * b ) ; var e1 = - 2 * a * b ; var f1 = ( - c * c ) + ( t * x1 * x1 ) + ( t * y1 * y1 ) ; document . write ( " " + a1 + " " + b1 + " " + c1 + " " + d1 + " " + e1 + " " + f1 + " " ) ; }
Ref: 
void equation_parabola ( float x1 , float y1 , float a , float b , float c ) { float t = a * a + b * b ; float a1 = t - ( a * a ) ; float b1 = t - ( b * b ) ; float c1 = ( -2 * t * x1 ) - ( 2 * c * a ) ; float d1 = ( -2 * t * y1 ) - ( 2 * c * b ) ; float e1 = -2 * a * b ; float f1 = ( - c * c ) + ( t * x1 * x1 ) + ( t * y1 * y1 ) ; std :: cout << std :: fixed ; std :: cout << std :: setprecision ( 1 ) ; cout << " equation ▁ of ▁ parabola ▁ is ▁ " << a1 << " ▁ x ^ 2 ▁ + ▁ " << b1 << " ▁ y ^ 2 ▁ + ▁ " << c1 << " ▁ x ▁ + ▁ " << d1 << " ▁ y ▁ + ▁ " << e1 << " ▁ xy ▁ + ▁ " << f1 << " ▁ = ▁ 0 . " ; }
Hyp: 
void equation_parabola ( int x1 , int y1 , int a , int b , int c ) { int t = a * a + b * b ; int a1 = t - ( a * a ) ; int b1 = t - ( b * b ) ; int c1 = ( - 2 * t * x1 ) - ( 2 * c * a ) ; int d1 = ( - 2 * t * y1 ) - ( 2 * c * b ) ; int e1 = - 2 * a * b ; int f1 = ( - c * c ) + ( t * x1 * x1 ) + ( t * y1 * y1 ) ; cout << " a ▁ = ▁ " << a1 << " , ▁ b ▁ = ▁ " << b1 << " , ▁ c ▁ d ▁ = ▁ " << c1 << " , ▁ e1 = -2 * a * b ; int f1 = ( - c * c ) + ( t * x1 * x1 ) + ( t * y1 * y1 ) ; cout << " a ▁ = ▁ " << a1 << " , ▁ b ▁ = ▁ " << b1 << " , ▁ c ▁ d ▁ " << d1 << " , ▁ e1 << " , f1 << " STRNEWLINE " }

BLEU: 49.13
Edit Sim: 209


Src: 
function seriesSum ( n ) { return ( n * ( n + 1 ) * ( n + 2 ) ) / 6 ; }
Ref: 
int seriesSum ( int n ) { return ( n * ( n + 1 ) * ( n + 2 ) ) / 6 ; }
Hyp: 
int seriesSum ( int n ) { return ( n * ( n + 1 ) * ( n + 2 ) ) / 6 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function generateNumbers ( m ) { let numbers = [ ] ; let k_max , x ; for ( let y = 0 ; y < 10 ; y ++ ) { k_max = Math . floor ( ( Math . pow ( 10 , m - 2 ) * ( 10 * y + 1 ) ) / Math . floor ( Math . pow ( 10 , m - 1 ) + y ) ) ; for ( let k = 1 ; k <= k_max ; k ++ ) { x = Math . floor ( ( y * ( Math . pow ( 10 , m - 1 ) - k ) ) / ( 10 * k - 1 ) ) ; if ( Math . floor ( ( y * ( Math . pow ( 10 , m - 1 ) - k ) ) % ( 10 * k - 1 ) ) == 0 ) numbers . push ( 10 * x + y ) ; } } numbers . sort ( function ( a , b ) { return a - b ; } ) ; for ( let i = 0 ; i < numbers . length ; i ++ ) document . write ( numbers [ i ] + " " ) ; }
Ref: 
void generateNumbers ( int m ) { vector < int > numbers ; int k_max , x ; for ( int y = 0 ; y < 10 ; y ++ ) { k_max = ( int ) ( pow ( 10 , m - 2 ) * ( 10 * y + 1 ) ) / ( int ) ( pow ( 10 , m - 1 ) + y ) ; for ( int k = 1 ; k <= k_max ; k ++ ) { x = ( int ) ( y * ( pow ( 10 , m - 1 ) - k ) ) / ( 10 * k - 1 ) ; if ( ( int ) ( y * ( pow ( 10 , m - 1 ) - k ) ) % ( 10 * k - 1 ) == 0 ) numbers . push_back ( 10 * x + y ) ; } } sort ( numbers . begin ( ) , numbers . end ( ) ) ; for ( int i = 0 ; i < numbers . size ( ) ; i ++ ) cout << ( numbers [ i ] ) << endl ; }
Hyp: 
void generateNumbers ( int m ) { vector < int > numbers ; int k_max , x ; for ( int y = 0 ; y < 10 ; y ++ ) { k_max = floor ( ( pow ( 10 , m - 2 ) * ( 10 * y + 1 ) ) / floor ( pow ( 10 , m - 1 ) + y ) ) ; for ( int k = 1 ; k <= k_max ; k ++ ) { x = floor ( ( y * ( pow ( 10 , m - 1 ) - k ) ) / ( 10 * k - 1 ) ; if ( ( y * ( pow ( 10 , m - 1 ) - k ) ) % ( 10 * k - 1 ) ) == 0 ) numbers . push_back ( 10 * x + y ) ; } } sort ( numbers . begin ( ) , numbers . end ( ) ) ; for ( int i = 0 ; i < numbers . size ( ) ; i ++ ) cout << numbers [ i ] << " ▁ " ; }

BLEU: 88.15
Edit Sim: 40


Src: 
function printsubset ( n , k ) { let count = 0 , x = 0 ; let vec = [ ] ; while ( n != 0 ) { x = n & 1 ; if ( x != 0 ) { vec . push ( Math . pow ( k , count ) ) ; } n = n >> 1 ; count ++ ; } for ( let i = 0 ; i < vec . length ; i ++ ) document . write ( vec [ i ] + " " ) ; }
Ref: 
void printsubset ( int n , int k ) { int count = 0 , x = 0 ; vector < int > vec ; while ( n ) { x = n & 1 ; if ( x ) { vec . push_back ( pow ( k , count ) ) ; } n = n >> 1 ; count ++ ; } for ( int i = 0 ; i < vec . size ( ) ; i ++ ) cout << vec [ i ] << " ▁ " ; }
Hyp: 
void printsubset ( int n , int k ) { int count = 0 , x = 0 ; vector < int > vec ; while ( n != 0 ) { x = n & 1 ; if ( x != 0 ) vec . push_back ( pow ( k , count ) ) ; } n = n >> 1 ; count ++ ; } for ( int i = 0 ; i < vec . size ( ) ; i ++ ) cout << vec [ i ] << " ▁ " ; }

BLEU: 91.9
Edit Sim: 10


Src: 
function sum ( x , n ) { let total = 1.0 ; let multi = x ; for ( let i = 1 ; i <= n ; i ++ ) { total = total + multi / i ; multi = multi * x ; } return total ; }
Ref: 
double sum ( int x , int n ) { double i , total = 1.0 , multi = x ; for ( i = 1 ; i <= n ; i ++ ) { total = total + multi / i ; multi = multi * x ; } return total ; }
Hyp: 
double sum ( double x , int n ) { double total = 1.0 ; double multi = x ; for ( int i = 1 ; i <= n ; i ++ ) { total = total + multi / i ; multi = multi * x ; } return total ; }

BLEU: 81.48
Edit Sim: 22


Src: 
function oddNumSum ( n ) { return ( n * ( 2 * n + 1 ) * ( 24 * n * n * n - 12 * n * n - 14 * n + 7 ) ) / 15 ; }
Ref: 
int oddNumSum ( int n ) { return ( n * ( 2 * n + 1 ) * ( 24 * n * n * n - 12 * n * n - 14 * n + 7 ) ) / 15 ; }
Hyp: 
int oddNumSum ( int n ) { return ( n * ( 2 * n + 1 ) * ( 24 * n * n * n - 12 * n * n - 14 * n + 7 ) ) / 15 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function Series ( x , n ) { var sum = 1 , term = 1 , fct = 1 ; var p = 1 , multi = 1 ; for ( let i = 1 ; i < n ; i ++ ) { fct = fct * multi * ( multi + 1 ) ; p = p * x * x ; term = ( - 1 ) * term ; multi += 2 ; sum = sum + ( term * p ) / fct ; } return sum ; }
Ref: 
double Series ( double x , int n ) { double sum = 1 , term = 1 , fct = 1 , p = 1 , multi = 1 ; for ( int i = 1 ; i < n ; i ++ ) { fct = fct * multi * ( multi + 1 ) ; p = p * x * x ; term = ( -1 ) * term ; multi += 2 ; sum = sum + ( term * p ) / fct ; } return sum ; }
Hyp: 
int Series ( int x [ ] , int n ) { int sum = 1 , term = 1 , fct = 1 ; int p = 1 , multi = 1 ; for ( int i = 1 ; i < n ; i ++ ) { fct = fct * multi * ( multi + 1 ) ; p = p * x * x ; term = ( -1 ) * term ; multi += 2 ; sum = sum + ( term * p ) / fct ; } return sum ; }

BLEU: 87.58
Edit Sim: 25


Src: 
function TotalAndPair ( arr , N ) { let totalAND = ( 1 << 30 ) - 1 ; for ( let i = 0 ; i < N ; i ++ ) { for ( let j = i + 1 ; j < N ; j ++ ) { totalAND &= arr [ i ] & arr [ j ] ; } } return totalAND ; }
Ref: 
int TotalAndPair ( int arr [ ] , int N ) { int totalAND = ( 1 << 30 ) - 1 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { totalAND &= arr [ i ] & arr [ j ] ; } } return totalAND ; }
Hyp: 
int TotalAndPair ( int arr [ ] , int N ) { int totalAND = ( 1 << 30 ) - 1 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { totalAND &= arr [ i ] & arr [ j ] ; } } return totalAND ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function cosXSertiesSum ( x , n ) { x = x * ( PI / 180.0 ) ; let res = 1 ; let sign = 1 , fact = 1 , pow = 1 , i ; for ( i = 1 ; i < 5 ; i ++ ) { sign = sign * - 1 ; fact = fact * ( 2 * i - 1 ) * ( 2 * i ) ; pow = pow * x * x ; res = res + sign * pow / fact ; } return res ; }
Ref: 
double cosXSertiesSum ( double x , int n ) { x = x * ( PI / 180.0 ) ; double res = 1 ; double sign = 1 , fact = 1 , pow = 1 ; for ( int i = 1 ; i < 5 ; i ++ ) { sign = sign * -1 ; fact = fact * ( 2 * i - 1 ) * ( 2 * i ) ; pow = pow * x * x ; res = res + sign * pow / fact ; } return res ; }
Hyp: 
double cosXSertiesSum ( double x , int n ) { x = x * ( PI / 180.0 ) ; double res = 1 ; int sign = 1 , fact = 1 , pow = 1 , i ; for ( i = 1 ; i < 5 ; i ++ ) { sign = sign * -1 ; fact = fact * ( 2 * i - 1 ) * ( 2 * i ) ; pow = pow * x * x ; res = res + sign * pow / fact ; } return res ; }

BLEU: 92.67
Edit Sim: 14


Src: 
function moveSpaceInFront ( str ) { var i = str . length - 1 ; for ( var j = i ; j >= 0 ; j -- ) if ( str [ j ] !== " " ) str [ i -- ] = str [ j ] ; while ( i >= 0 ) str [ i -- ] = " " ; }
Ref: 
void moveSpaceInFront ( char str [ ] ) { int i = strlen ( str ) ; for ( int j = i ; j >= 0 ; j -- ) if ( str [ j ] != ' ▁ ' ) str [ i -- ] = str [ j ] ; while ( i >= 0 ) str [ i -- ] = ' ▁ ' ; }
Hyp: 
void moveSpaceInFront ( string & str ) { int i = str . length ( ) - 1 ; for ( int j = i ; j >= 0 ; j -- ) if ( str [ j ] != ' ▁ ' ) str [ i -- ] = str [ j ] ; while ( i >= 0 ) str [ i -- ] = ' ' ; }

BLEU: 80.78
Edit Sim: 23


Src: 
function printAllSubStrings ( s , n ) { for ( let i = 0 ; i < n ; i ++ ) { let temp = new Array ( n - i + 1 ) ; let tempindex = 0 ; for ( let j = i ; j < n ; j ++ ) { temp [ tempindex ++ ] = s [ j ] ; temp [ tempindex ] = ' \0 ' ; document . write ( temp . join ( " " ) + " " ) ; } } }
Ref: 
void printAllSubstrings ( string s , int n ) { for ( int i = 0 ; i < n ; i ++ ) { char temp [ n - i + 1 ] ; int tempindex = 0 ; for ( int j = i ; j < n ; j ++ ) { temp [ tempindex ++ ] = s [ j ] ; temp [ tempindex ] = ' \0' ; printf ( " % s STRNEWLINE " , temp ) ; } } }
Hyp: 
void printAllSubStrings ( string s , int n ) { for ( int i = 0 ; i < n ; i ++ ) { string temp [ n - i + 1 ] ; int tempindex = 0 ; for ( int j = i ; j < n ; j ++ ) { temp [ tempindex ++ ] = s [ j ] ; temp [ tempindex ] = ' \0' ; cout << temp [ tempindex ] << " ▁ " ; } } }

BLEU: 82.68
Edit Sim: 37


Src: 
function isDvisibleBy12 ( num ) { if ( num . length >= 3 ) { let d1 = num [ num . length - 1 ] . charCodeAt ( ) ; if ( d1 % 2 != 0 ) return false ; let d2 = num [ num . length - 2 ] . charCodeAt ( ) ; let sum = 0 ; for ( let i = 0 ; i < num . length ; i ++ ) sum += num [ i ] . charCodeAt ( ) ; return ( ( sum % 3 == 0 ) && ( d2 * 10 + d1 ) % 4 == 0 ) ; } else { let number = parseInt ( num , 10 ) ; document . write ( number ) ; return ( number % 12 == 0 ) ; } }
Ref: 
bool isDvisibleBy12 ( string num ) { if ( num . length ( ) >= 3 ) { int d1 = ( int ) num [ num . length ( ) - 1 ] ; if ( d1 % 2 != 0 ) return ( 0 ) ; int d2 = ( int ) num [ num . length ( ) - 2 ] ; int sum = 0 ; for ( int i = 0 ; i < num . length ( ) ; i ++ ) sum += num [ i ] ; return ( sum % 3 == 0 && ( d2 * 10 + d1 ) % 4 == 0 ) ; } else { int number = stoi ( num ) ; return ( number % 12 == 0 ) ; } }
Hyp: 
bool isDvisibleBy12 ( string num ) { if ( num . length ( ) >= 3 ) { int d1 = num [ num . length ( ) - 1 ] ; if ( d1 % 2 != 0 ) return false ; int d2 = num [ num . length ( ) - 2 ] ; int sum = 0 ; for ( int i = 0 ; i < num . length ( ) ; i ++ ) sum += num [ i ] ; return ( ( sum % 3 == 0 ) && ( ( d2 * 10 + d1 ) % 4 == 0 ) ; } else { int number = num ; cout << number << 12 ; return ( number % 12 == 0 ) ; } }

BLEU: 84.82
Edit Sim: 46


Src: 
function gcd ( a , b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
Ref: 
int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
Hyp: 
int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function maxAndXor ( arr , n ) { let ans = Number . MAX_VALUE ; arr . sort ( ) ; for ( let i = 0 ; i < n - 1 ; i ++ ) { ans = Math . min ( ans , arr [ i ] ^ arr [ i + 1 ] ) ; } return ans ; }
Ref: 
int maxAndXor ( int arr [ ] , int n ) { int ans = INT_MAX ; sort ( arr , arr + n ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { ans = min ( ans , arr [ i ] ^ arr [ i + 1 ] ) ; } return ans ; }
Hyp: 
int maxAndXor ( int arr [ ] , int n ) { int ans = INT_MAX ; sort ( arr , arr + n ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { ans = min ( ans , arr [ i ] ^ arr [ i + 1 ] ) ; } return ans ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countObtuseAngles ( a , b , k ) { var c1 = ( b - a ) - 1 ; var c2 = ( k - b ) + ( a - 1 ) ; if ( c1 == c2 ) return 0 ; return Math . min ( c1 , c2 ) ; }
Ref: 
int countObtuseAngles ( int a , int b , int k ) { int c1 = ( b - a ) - 1 ; int c2 = ( k - b ) + ( a - 1 ) ; if ( c1 == c2 ) return 0 ; return min ( c1 , c2 ) ; }
Hyp: 
int countObtuseAngles ( int a , int b , int k ) { int c1 = ( b - a ) - 1 ; int c2 = ( k - b ) + ( a - 1 ) ; if ( c1 == c2 ) return 0 ; return min ( c1 , c2 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function check ( n , m ) { if ( m % n == 0 ) { document . write ( " " ) ; } else { document . write ( " " ) ; } return 0 ; }
Ref: 
int check ( int n , int m ) { if ( m % n == 0 ) { cout << " YES " ; } else { cout << " NO " ; } return 0 ; }
Hyp: 
int check ( int n , int m ) { if ( m % n == 0 ) { cout << " Yes " ; } else { cout << " No " ; } return 0 ; }

BLEU: 86.61
Edit Sim: 3


Src: 
function LongestSubarray ( arr , n , k ) { let count = 1 ; let max_length = 1 ; let prev_mod = arr [ 0 ] % k ; for ( let i = 1 ; i < n ; i ++ ) { let curr_mod = arr [ i ] % k ; if ( curr_mod == prev_mod ) { count ++ ; } else { max_length = Math . max ( max_length , count ) ; count = 1 ; prev_mod = curr_mod ; } } return Math . max ( max_length , count ) ; }
Ref: 
int LongestSubarray ( int arr [ ] , int n , int k ) { int count = 1 ; int max_length = 1 ; int prev_mod = arr [ 0 ] % k ; for ( int i = 1 ; i < n ; i ++ ) { int curr_mod = arr [ i ] % k ; if ( curr_mod == prev_mod ) { count ++ ; } else { max_length = max ( max_length , count ) ; count = 1 ; prev_mod = curr_mod ; } } return max ( max_length , count ) ; }
Hyp: 
int LongestSubarray ( int arr [ ] , int n , int k ) { int count = 1 ; int max_length = 1 ; int prev_mod = arr [ 0 ] % k ; for ( int i = 1 ; i < n ; i ++ ) { int curr_mod = arr [ i ] % k ; if ( curr_mod == prev_mod ) { count ++ ; } else { max_length = max ( max_length , count ) ; count = 1 ; prev_mod = curr_mod ; } } return max ( max_length , count ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function calculate ( a , n ) { a . sort ( ) ; let i , j ; let s = [ ] ; for ( i = 0 , j = n - 1 ; i < j ; i ++ , j -- ) s . push ( ( a [ i ] + a [ j ] ) ) ; let mini = Math . min ( ... s ) ; let maxi = Math . max ( ... s ) ; return Math . abs ( maxi - mini ) ; }
Ref: 
ll calculate ( ll a [ ] , ll n ) { sort ( a , a + n ) ; vector < ll > s ; for ( int i = 0 , j = n - 1 ; i < j ; i ++ , j -- ) s . push_back ( a [ i ] + a [ j ] ) ; ll mini = * min_element ( s . begin ( ) , s . end ( ) ) ; ll maxi = * max_element ( s . begin ( ) , s . end ( ) ) ; return abs ( maxi - mini ) ; }
Hyp: 
int calculate ( int a [ ] , int n ) { sort ( a , a + n ) ; int i , j ; vector < int > s ; for ( i = 0 , j = n - 1 ; i < j ; i ++ , j -- ) s . push_back ( ( a [ i ] + a [ j ] ) ) ; int mini = min ( ... s ) ; int maxi = max ( ... s ) ; return abs ( maxi - mini ) ; }

BLEU: 57.88
Edit Sim: 105


Src: 
function coin ( totalRupees , X , Y , Z ) { var one = 0 , fifty = 0 , twentyfive = 0 , result = 0 , total = 0 ; one = X * 1 ; fifty = ( ( Y * 1 ) / 2.0 ) ; twentyfive = ( ( Z * 1 ) / 4.0 ) ; total = one + fifty + twentyfive ; result = ( ( totalRupees ) / total ) ; return result ; }
Ref: 
int coin ( int totalRupees , int X , int Y , int Z ) { float one = 0 , fifty = 0 , twentyfive = 0 , result = 0 , total = 0 ; one = X * 1 ; fifty = ( ( Y * 1 ) / 2.0 ) ; twentyfive = ( ( Z * 1 ) / 4.0 ) ; total = one + fifty + twentyfive ; result = ( ( totalRupees ) / total ) ; return result ; }
Hyp: 
double coin ( double totalRupees , int X , int Y , int Z ) { double one = 0 , fifty = 0 , twentyfive = 0 , result = 0 , total = 0 ; one = X * 1 ; fifty = ( ( Y * 1 ) / 2.0 ) ; twentyfive = ( ( Z * 1 ) / 4.0 ) ; total = one + fifty + twentyfive ; result = ( ( totalRupees ) / total ) ; return result ; }

BLEU: 93.45
Edit Sim: 18


Src: 
function divCount ( n ) { var hash = Array ( n + 1 ) . fill ( true ) ; for ( var p = 2 ; p * p < n ; p ++ ) if ( hash [ p ] == true ) for ( var i = p * 2 ; i < n ; i += p ) hash [ i ] = false ; var total = 1 ; for ( var p = 2 ; p <= n ; p ++ ) { if ( hash [ p ] ) { var count = 0 ; if ( n % p == 0 ) { while ( n % p == 0 ) { n = parseInt ( n / p ) ; count ++ ; } total = total * ( count + 1 ) ; } } } return total ; }
Ref: 
int divCount ( int n ) { bool hash [ n + 1 ] ; memset ( hash , true , sizeof ( hash ) ) ; for ( int p = 2 ; p * p < n ; p ++ ) if ( hash [ p ] == true ) for ( int i = p * 2 ; i < n ; i += p ) hash [ i ] = false ; int total = 1 ; for ( int p = 2 ; p <= n ; p ++ ) { if ( hash [ p ] ) { int count = 0 ; if ( n % p == 0 ) { while ( n % p == 0 ) { n = n / p ; count ++ ; } total = total * ( count + 1 ) ; } } } return total ; }
Hyp: 
int divCount ( int n ) { bool hash [ n + 1 ] ; for ( int p = 2 ; p * p < n ; p ++ ) if ( hash [ p ] == true ) for ( int i = p * 2 ; i < n ; i += p ) hash [ i ] = false ; int total = 1 ; for ( int p = 2 ; p <= n ; p ++ ) { if ( hash [ p ] ) { int count = 0 ; if ( n % p == 0 ) { while ( n % p == 0 ) { n = n / p ; count ++ ; } total = total * ( count + 1 ) ; } } } return total ; }

BLEU: 91.4
Edit Sim: 43


Src: 
function solve ( arr , n ) { arr . sort ( ) ; let a = 0 , b = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( i % 2 != 0 ) a = a * 10 + arr [ i ] ; else b = b * 10 + arr [ i ] ; } return a + b ; }
Ref: 
int solve ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int a = 0 , b = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i & 1 ) a = a * 10 + arr [ i ] ; else b = b * 10 + arr [ i ] ; } return a + b ; }
Hyp: 
int solve ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int a = 0 , b = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 != 0 ) a = a * 10 + arr [ i ] ; else b = b * 10 + arr [ i ] ; } return a + b ; }

BLEU: 93.3
Edit Sim: 7


Src: 
function radius ( n , d ) { document . write ( " " + ( d / ( ( n - 1 ) * Math . sqrt ( 2 ) ) ) . toFixed ( 5 ) ) ; }
Ref: 
void radius ( double n , double d ) { cout << " The ▁ side ▁ of ▁ each ▁ square ▁ is ▁ " << d / ( ( n - 1 ) * sqrt ( 2 ) ) << endl ; }
Hyp: 
void radius ( int n , int d ) { cout << " The ▁ radius ▁ of ▁ the ▁ circle ▁ is ▁ " << d / ( ( n - 1 ) * sqrt ( 2 ) ) << endl ; }

BLEU: 73.12
Edit Sim: 26


Src: 
function removeChars ( s ) { let modifiedStr = " " ; modifiedStr += s [ 0 ] ; for ( let i = 1 ; i < s . length ; i ++ ) { if ( s [ i ] == ( s [ i ] ) . toUpperCase ( ) && ( s [ i - 1 ] ) == ( s [ i - 1 ] ) . toLowerCase ( ) || s [ i ] == s [ i ] . toLowerCase ( ) && ( s [ i - 1 ] ) == ( s [ i - 1 ] ) . toUpperCase ( ) ) modifiedStr += s [ i ] ; } return modifiedStr ; }
Ref: 
string removeChars ( string s ) { string modifiedStr = " " ; modifiedStr += s [ 0 ] ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) { if ( isupper ( s [ i ] ) && islower ( s [ i - 1 ] ) || islower ( s [ i ] ) && isupper ( s [ i - 1 ] ) ) modifiedStr += s [ i ] ; } return modifiedStr ; }
Hyp: 
string removeChars ( string s ) { string modifiedStr = " " ; modifiedStr += s [ 0 ] ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] == ( s [ i ] ) . toUpperCase ( ) && ( s [ i - 1 ] ) == ( s [ i - 1 ] ) . toLowerCase ( ) || s [ i ] == s [ i ] . toLowerCase ( ) && ( s [ i - 1 ] ) == ( s [ i - 1 ] ) . toUpperCase ( ) ) modifiedStr += s [ i ] ; } return modifiedStr ; }

BLEU: 59.53
Edit Sim: 121


Src: 
function commonSubstring ( s ) { let n = s . length ; let i = 0 ; let j = n - 1 ; let ans = " " ; while ( j >= 0 ) { if ( s [ i ] == s [ j ] ) { ans += s [ i ] ; i ++ ; j -- ; } else { break ; } } if ( ans . length == 0 ) document . write ( " " ) ; else { document . write ( " " + " " + ans ) ; } }
Ref: 
void commonSubstring ( string s ) { int n = s . size ( ) ; int i = 0 ; int j = n - 1 ; string ans = " " ; while ( j >= 0 ) { if ( s [ i ] == s [ j ] ) { ans += s [ i ] ; i ++ ; j -- ; } else { break ; } } if ( ans . size ( ) == 0 ) cout << " False " ; else { cout << " True ▁ STRNEWLINE " << ans ; } }
Hyp: 
void commonSubstring ( string s ) { int n = s . length ( ) ; int i = 0 ; int j = n - 1 ; string ans = " " ; while ( j >= 0 ) { if ( s [ i ] == s [ j ] ) { ans += s [ i ] ; i ++ ; j -- ; } else { break ; } } if ( ans . size ( ) == 0 ) cout << " No " ; else { cout << " Yes " << " No " << ans ; } }

BLEU: 89.0
Edit Sim: 25


Src: 
function findMinimumCost ( n , x , y ) { let dp = new Array ( n + 1 ) ; dp [ 1 ] = x ; for ( let i = 2 ; i <= n ; i ++ ) { if ( ( i & 1 ) != 0 ) { dp [ i ] = Math . min ( dp [ i - 1 ] + x , dp [ parseInt ( ( i + 1 ) / 2 , 10 ) ] + y + x ) ; } else { dp [ i ] = Math . min ( dp [ i - 1 ] + x , dp [ parseInt ( i / 2 , 10 ) ] + y ) ; } } return dp [ n ] ; }
Ref: 
int findMinimumCost ( int n , int x , int y ) { int * dp = new int [ n + 1 ] ; dp [ 1 ] = x ; for ( int i = 2 ; i <= n ; i ++ ) { if ( i & 1 ) { dp [ i ] = min ( dp [ i - 1 ] + x , dp [ ( i + 1 ) / 2 ] + y + x ) ; } else { dp [ i ] = min ( dp [ i - 1 ] + x , dp [ i / 2 ] + y ) ; } } return dp [ n ] ; }
Hyp: 
int findMinimumCost ( int n , int x , int y ) { int dp [ n + 1 ] ; dp [ 1 ] = x ; for ( int i = 2 ; i <= n ; i ++ ) { if ( ( i & 1 ) != 0 ) { dp [ i ] = min ( dp [ i - 1 ] + x , dp [ ( i + 1 ) / 2 ] + y + x ) ; } else { dp [ i ] = min ( dp [ i - 1 ] + x , dp [ i / 2 ] + y ) ; } } return dp [ n ] ; }

BLEU: 93.67
Edit Sim: 21


Src: 
function minimiseMedian ( arr , n ) { arr . sort ( ( a , b ) => a - b ) ; return Math . abs ( arr [ n / 2 ] - arr [ ( n / 2 ) - 1 ] ) ; }
Ref: 
int minimiseMedian ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; return abs ( arr [ n / 2 ] - arr [ ( n / 2 ) - 1 ] ) ; }
Hyp: 
int minimiseMedian ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; return abs ( arr [ n / 2 ] - arr [ ( n / 2 ) - 1 ] ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function minAdjDifference ( arr , n ) { if ( n < 2 ) return ; let res = Math . abs ( arr [ 1 ] - arr [ 0 ] ) ; for ( let i = 2 ; i < n ; i ++ ) res = Math . min ( res , Math . abs ( arr [ i ] - arr [ i - 1 ] ) ) ; res = Math . min ( res , Math . abs ( arr [ n - 1 ] - arr [ 0 ] ) ) ; document . write ( " " + res ) ; }
Ref: 
void minAdjDifference ( int arr [ ] , int n ) { if ( n < 2 ) return ; int res = abs ( arr [ 1 ] - arr [ 0 ] ) ; for ( int i = 2 ; i < n ; i ++ ) res = min ( res , abs ( arr [ i ] - arr [ i - 1 ] ) ) ; res = min ( res , abs ( arr [ n - 1 ] - arr [ 0 ] ) ) ; cout << " Min ▁ Difference ▁ = ▁ " << res ; }
Hyp: 
void minAdjDifference ( int arr [ ] , int n ) { if ( n < 2 ) return ; int res = abs ( arr [ 1 ] - arr [ 0 ] ) ; for ( int i = 2 ; i < n ; i ++ ) res = min ( res , abs ( arr [ i ] - arr [ i - 1 ] ) ) ; res = min ( res , abs ( arr [ n - 1 ] - arr [ 0 ] ) ) ; cout << " The ▁ minimum ▁ is ▁ " << res ; }

BLEU: 94.38
Edit Sim: 14


Src: 
function superSeq ( X , Y , m , n ) { var dp = Array ( m + 1 ) . fill ( 0 ) . map ( x => Array ( n + 1 ) . fill ( 0 ) ) ; for ( var i = 0 ; i <= m ; i ++ ) { for ( var j = 0 ; j <= n ; j ++ ) { if ( i == 0 ) dp [ i ] [ j ] = j ; else if ( j == 0 ) dp [ i ] [ j ] = i ; else if ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = 1 + Math . min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) ; } } return dp [ m ] [ n ] ; }
Ref: 
int superSeq ( char * X , char * Y , int m , int n ) { int dp [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( ! i ) dp [ i ] [ j ] = j ; else if ( ! j ) dp [ i ] [ j ] = i ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = 1 + min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) ; } } return dp [ m ] [ n ] ; }
Hyp: 
int superSeq ( string X , string Y , int m , int n ) { vector < vector < int > > dp ( m + 1 , vector < int > ( n + 1 , 0 ) ) ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 ) dp [ i ] [ j ] = j ; else if ( j == 0 ) dp [ i ] [ j ] = i ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = 1 + min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) ; } } return dp [ m ] [ n ] ; }

BLEU: 80.7
Edit Sim: 69


Src: 
function printXYZ ( n ) { if ( n == 1 ) document . write ( - 1 ) ; else document . write ( " " + n + " " + ( n + 1 ) + " " + n * ( n + 1 ) ) ; }
Ref: 
void printXYZ ( int n ) { if ( n == 1 ) cout << -1 ; else cout << " x ▁ is ▁ " << n << " STRNEWLINE y ▁ is ▁ " << n + 1 << " STRNEWLINE z ▁ is ▁ " << n * ( n + 1 ) ; }
Hyp: 
void printXYZ ( int n ) { if ( n == 1 ) cout << -1 ; else cout << " ( " << n << " ) " << n * ( n + 1 ) << " ) " << n * ( n + 1 ) << endl ; }

BLEU: 60.84
Edit Sim: 56


Src: 
function findVolume ( a ) { if ( a < 0 ) return - 1 ; var r = a / 2 ; var h = a ; var V = ( 3.14 * Math . pow ( r , 2 ) * h ) ; return V ; }
Ref: 
float findVolume ( float a ) { if ( a < 0 ) return -1 ; float r = a / 2 ; float h = a ; float V = 3.14 * pow ( r , 2 ) * h ; return V ; }
Hyp: 
float findVolume ( float a ) { if ( a < 0 ) return -1 ; float r = a / 2 ; float h = a ; float V = 3.14 * pow ( r , 2 ) * h ; return V ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function find3Numbers ( A , arr_size , sum ) { let l , r ; for ( let i = 0 ; i < arr_size - 2 ; i ++ ) { for ( let j = i + 1 ; j < arr_size - 1 ; j ++ ) { for ( let k = j + 1 ; k < arr_size ; k ++ ) { if ( A [ i ] + A [ j ] + A [ k ] == sum ) { document . write ( " " + A [ i ] + " " + A [ j ] + " " + A [ k ] ) ; return true ; } } } } return false ; }
Ref: 
bool find3Numbers ( int A [ ] , int arr_size , int sum ) { int l , r ; for ( int i = 0 ; i < arr_size - 2 ; i ++ ) { for ( int j = i + 1 ; j < arr_size - 1 ; j ++ ) { for ( int k = j + 1 ; k < arr_size ; k ++ ) { if ( A [ i ] + A [ j ] + A [ k ] == sum ) { cout << " Triplet ▁ is ▁ " << A [ i ] << " , ▁ " << A [ j ] << " , ▁ " << A [ k ] ; return true ; } } } } return false ; }
Hyp: 
bool find3Numbers ( int A [ ] , int arr_size , int sum ) { int l , r ; for ( int i = 0 ; i < arr_size - 2 ; i ++ ) { for ( int j = i + 1 ; j < arr_size - 1 ; j ++ ) { for ( int k = j + 1 ; k < arr_size ; k ++ ) { if ( A [ i ] + A [ j ] + A [ k ] == sum ) { cout << " Yes " << A [ i ] << " , ▁ " << A [ j ] << " , ▁ " << A [ k ] ; return true ; } } } } return false ; }

BLEU: 95.97
Edit Sim: 12


Src: 
function extraElement ( A , B , n ) { let ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) ans ^= A [ i ] ; for ( let i = 0 ; i < n + 1 ; i ++ ) ans ^= B [ i ] ; return ans ; }
Ref: 
int extraElement ( int A [ ] , int B [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) ans ^= A [ i ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) ans ^= B [ i ] ; return ans ; }
Hyp: 
int extraElement ( int A [ ] , int B [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) ans ^= A [ i ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) ans ^= B [ i ] ; return ans ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function solution ( a , b , n ) { for ( let i = 0 ; i * a <= n ; i ++ ) { if ( ( n - ( i * a ) ) % b == 0 ) { document . write ( " " + i + " " + ( n - ( i * a ) ) / b ) ; return ; } } document . write ( " " ) ; }
Ref: 
void solution ( int a , int b , int n ) { for ( int i = 0 ; i * a <= n ; i ++ ) { if ( ( n - ( i * a ) ) % b == 0 ) { cout << " x ▁ = ▁ " << i << " , ▁ y ▁ = ▁ " << ( n - ( i * a ) ) / b ; return ; } } cout << " No ▁ solution " ; }
Hyp: 
void solution ( int a , int b , int n ) { for ( int i = 0 ; i * a <= n ; i ++ ) { if ( ( n - ( i * a ) ) % b == 0 ) { cout << " ( " << i << " , ▁ " << ( n - ( i * a ) ) / b << endl ; return ; } } cout << " ( " ; }

BLEU: 81.82
Edit Sim: 36


Src: 
function firstSubsequence ( s ) { let allsubseq = [ ] ; for ( let i = 0 ; i < s . length ; i ++ ) { let k = " " ; for ( let j = 0 ; j < s . length ; j ++ ) { if ( i != j ) { k += s [ j ] ; } } allsubseq . push ( k ) ; } ( allsubseq ) . sort ( ) ; document . write ( allsubseq [ 0 ] ) ; }
Ref: 
void firstSubsequence ( string s ) { vector < string > allsubseq ; string k ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { k = s ; k . erase ( i , 1 ) ; allsubseq . push_back ( k ) ; } sort ( allsubseq . begin ( ) , allsubseq . end ( ) ) ; cout << allsubseq [ 0 ] ; }
Hyp: 
void firstSubsequence ( string s ) { vector < string > allsubseq ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { string k ; for ( int j = 0 ; j < s . length ( ) ; j ++ ) { if ( i != j ) { k += s [ j ] ; } } allsubseq . push_back ( k ) ; } sort ( allsubseq . begin ( ) , allsubseq . end ( ) ) ; cout << allsubseq [ 0 ] ; }

BLEU: 65.09
Edit Sim: 72


Src: 
function answer ( n ) { let m = 2 ; let ans = 1 ; let r = 1 ; while ( r < n ) { r = ( Math . pow ( 2 , m ) - 1 ) * ( Math . pow ( 2 , m - 1 ) ) ; if ( r < n ) ans = r ; m ++ ; } return ans ; }
Ref: 
long answer ( long long n ) { long m = 2 ; long long ans = 1 ; long long r = 1 ; while ( r < n ) { r = ( int ) ( pow ( 2 , m ) - 1 ) * ( pow ( 2 , m - 1 ) ) ; if ( r < n ) ans = r ; m ++ ; } return ans ; }
Hyp: 
int answer ( int n ) { int m = 2 ; int ans = 1 ; int r = 1 ; while ( r < n ) { r = ( pow ( 2 , m ) - 1 ) * ( pow ( 2 , m - 1 ) ) ; if ( r < n ) ans = r ; m ++ ; } return ans ; }

BLEU: 77.1
Edit Sim: 38


Src: 
function countDivisors ( n ) { let cnt = 0 ; for ( let i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) cnt ++ ; cnt = cnt + 2 ; } } return cnt ; }
Ref: 
int countDivisors ( int n ) { int cnt = 0 ; for ( int i = 1 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) cnt ++ ; cnt = cnt + 2 ; } } return cnt ; }
Hyp: 
int countDivisors ( int n ) { int cnt = 0 ; for ( int i = 1 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) cnt ++ ; cnt = cnt + 2 ; } } return cnt ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function numberOfPermWithKInversion ( N , K ) { let dp = new Array ( 2 ) ; for ( var i = 0 ; i < dp . length ; i ++ ) { dp [ i ] = new Array ( 2 ) ; } let mod = 1000000007 ; for ( let i = 1 ; i <= N ; i ++ ) { for ( let j = 0 ; j <= K ; j ++ ) { if ( i == 1 ) { dp [ i % 2 ] [ j ] = ( j == 0 ) ? 1 : 0 ; } else if ( j == 0 ) dp [ i % 2 ] [ j ] = 1 ; else dp [ i % 2 ] [ j ] = ( dp [ i % 2 ] [ j - 1 ] % mod + ( dp [ 1 - i % 2 ] [ j ] - ( ( Math . max ( j - ( i - 1 ) , 0 ) == 0 ) ? 0 : dp [ 1 - i % 2 ] [ Math . max ( j - ( i - 1 ) , 0 ) - 1 ] ) + mod ) % mod ) % mod ; } } document . write ( dp [ N % 2 ] [ K ] ) ; }
Ref: 
int numberOfPermWithKInversion ( int N , int K ) { int dp [ 2 ] [ K + 1 ] ; int mod = 1000000007 ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 0 ; j <= K ; j ++ ) { if ( i == 1 ) dp [ i % 2 ] [ j ] = ( j == 0 ) ; else if ( j == 0 ) dp [ i % 2 ] [ j ] = 1 ; else dp [ i % 2 ] [ j ] = ( dp [ i % 2 ] [ j - 1 ] % mod + ( dp [ 1 - i % 2 ] [ j ] - ( ( max ( j - ( i - 1 ) , 0 ) == 0 ) ? 0 : dp [ 1 - i % 2 ] [ max ( j - ( i - 1 ) , 0 ) - 1 ] ) + mod ) % mod ) % mod ; ; } } cout << dp [ N % 2 ] [ K ] ; }
Hyp: 
int numberOfPermWithKInversion ( int N , int K ) { int dp [ 2 ] [ K + 1 ] ; memset ( dp , 0 , sizeof dp ) ; int mod = 1000000007 ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 0 ; j <= K ; j ++ ) { if ( i == 1 ) { dp [ i % 2 ] [ j ] = ( j == 0 ) ? 1 : 0 ; } else if ( j == 0 ) dp [ i % 2 ] [ j ] = 1 ; else dp [ i % 2 ] [ j ] = ( dp [ i % 2 ] [ j - 1 ] % mod + ( dp [ 1 - i % 2 ] [ j ] - ( ( max ( j - ( i - 1 ) , 0 ) == 0 ) ? 0 : dp [ 1 - i % 2 ] [ max ( j - ( i - 1 ) , 0 ) - 1 ] ) + mod ) % mod ; } } cout << dp [ N % 2 ] [ K ] ; }

BLEU: 90.53
Edit Sim: 54


Src: 
function countPairs ( arr , N ) { let countPowerof2 = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( Number ( arr [ i ] . toString ( 2 ) . split ( " " ) . sort ( ) . join ( " " ) ) . toString ( ) . length == 1 ) countPowerof2 ++ ; } let desiredPairs = ( countPowerof2 * ( countPowerof2 - 1 ) ) / 2 ; document . write ( desiredPairs + " " ) ; }
Ref: 
int countPairs ( int arr [ ] , int N ) { int countPowerof2 = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( __builtin_popcount ( arr [ i ] ) == 1 ) countPowerof2 ++ ; } int desiredPairs = ( countPowerof2 * ( countPowerof2 - 1 ) ) / 2 ; cout << desiredPairs << ' ▁ ' ; }
Hyp: 
void countPairs ( int arr [ ] , int N ) { int countPowerof2 = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( to_string ( arr [ i ] ) . sort ( ) . join ( " ▁ " ) . size ( ) == 1 ) countPowerof2 ++ ; } int desiredPairs = ( countPowerof2 * ( countPowerof2 - 1 ) ) / 2 ; cout << desiredPairs << " ▁ " ; }

BLEU: 72.97
Edit Sim: 54


Src: 
function countgroup ( a , n ) { var xs = 0 ; for ( var i = 0 ; i < n ; i ++ ) xs = xs ^ a [ i ] ; if ( xs == 0 ) return ( 1 << ( n - 1 ) ) - 1 ; }
Ref: 
int countgroup ( int a [ ] , int n ) { int xs = 0 ; for ( int i = 0 ; i < n ; i ++ ) xs = xs ^ a [ i ] ; if ( xs == 0 ) return ( 1 << ( n - 1 ) ) - 1 ; return 0 ; }
Hyp: 
int countgroup ( int a [ ] , int n ) { int xs = 0 ; for ( int i = 0 ; i < n ; i ++ ) xs = xs ^ a [ i ] ; if ( xs == 0 ) return ( 1 << ( n - 1 ) ) - 1 ; }

BLEU: 94.31
Edit Sim: 11


Src: 
function TetracontaoctagonalNum ( n ) { return ( 46 * n * n - 44 * n ) / 2 ; }
Ref: 
int TetracontaoctagonalNum ( int n ) { return ( 46 * n * n - 44 * n ) / 2 ; }
Hyp: 
int TetracontaoctagonalNum ( int n ) { return ( 46 * n * n - 44 * n ) / 2 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function nextPowerOf2 ( n ) { n -= 1 n |= n >> 1 n |= n >> 2 n |= n >> 4 n |= n >> 8 n |= n >> 16 n += 1 return n }
Ref: 
int nextPowerOf2 ( unsigned int n ) { n -- ; n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; n ++ ; return n ; }
Hyp: 
int nextPowerOf2 ( int n ) { n -= 1 n |= n >> 1 n |= n >> 2 n |= n >> 4 n |= n >> 8 n |= n >> 16 n += 1 }

BLEU: 46.26
Edit Sim: 34


Src: 
function countSteps ( x , y ) { if ( x < y ) { return x + y + 2 * parseInt ( ( y - x ) / 2 ) ; } else { return x + y + 2 * parseInt ( ( ( x - y ) + 1 ) / 2 ) ; } }
Ref: 
int countSteps ( int x , int y ) { if ( x < y ) { return x + y + 2 * ( ( y - x ) / 2 ) ; } else { return x + y + 2 * ( ( ( x - y ) + 1 ) / 2 ) ; } }
Hyp: 
int countSteps ( int x , int y ) { if ( x < y ) { return x + y + 2 * ( ( y - x ) / 2 ) ; } else { return x + y + 2 * ( ( ( x - y ) + 1 ) / 2 ) ; } }

BLEU: 100.0
Edit Sim: 0


Src: 
function construct_Array ( N , K ) { for ( let i = 1 ; i <= N ; i ++ ) { document . write ( K * i + " " ) ; } }
Ref: 
void construct_Array ( int N , int K ) { for ( int i = 1 ; i <= N ; i ++ ) { cout << K * i << " ▁ " ; } }
Hyp: 
void construct_Array ( int N , int K ) { for ( int i = 1 ; i <= N ; i ++ ) { cout << K * i << " ▁ " ; } }

BLEU: 100.0
Edit Sim: 0


Src: 
function bitwiseAndOdd ( n ) { var result = 1 ; for ( var i = 3 ; i <= n ; i = i + 2 ) { result = ( result & i ) ; } return result ; }
Ref: 
int bitwiseAndOdd ( int n ) { int result = 1 ; for ( int i = 3 ; i <= n ; i = i + 2 ) { result = ( result & i ) ; } return result ; }
Hyp: 
int bitwiseAndOdd ( int n ) { int result = 1 ; for ( int i = 3 ; i <= n ; i = i + 2 ) { result = ( result & i ) ; } return result ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function properDivisorSum ( n ) { var sum = 0 ; for ( var i = 1 ; i <= n ; ++ i ) sum += parseInt ( n / i ) * i ; return sum - n * ( ( n + 1 ) / 2 ) ; }
Ref: 
int properDivisorSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; ++ i ) sum += ( n / i ) * i ; return sum - n * ( n + 1 ) / 2 ; }
Hyp: 
int properDivisorSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; ++ i ) sum += n / i * i ; return sum - n * ( ( n + 1 ) / 2 ) ; }

BLEU: 86.16
Edit Sim: 8


Src: 
function minSteps ( arr , n , k ) { let i , cnt = 0 ; let flag ; if ( k == 1 ) flag = 0 ; else flag = 1 ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == flag ) { cnt ++ ; flag = ( flag + 1 ) % 2 ; } } return cnt ; }
Ref: 
int minSteps ( int arr [ ] , int n , int k ) { int i , cnt = 0 ; int flag ; if ( k == 1 ) flag = 0 ; else flag = 1 ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == flag ) { cnt ++ ; flag = ( flag + 1 ) % 2 ; } } return cnt ; }
Hyp: 
int minSteps ( int arr [ ] , int n , int k ) { int i , cnt = 0 ; int flag ; if ( k == 1 ) flag = 0 ; else flag = 1 ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == flag ) { cnt ++ ; flag = ( flag + 1 ) % 2 ; } } return cnt ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function minPower ( n , x ) { if ( x == 1 ) return n ; let ans = 0 ; while ( n > 0 ) { ans += ( n % x ) ; n = Math . floor ( n / x ) ; } return ans ; }
Ref: 
int minPower ( int n , int x ) { if ( x == 1 ) return n ; int ans = 0 ; while ( n > 0 ) { ans += ( n % x ) ; n /= x ; } return ans ; }
Hyp: 
int minPower ( int n , int x ) { if ( x == 1 ) return n ; int ans = 0 ; while ( n > 0 ) { ans += ( n % x ) ; n = n / x ; } return ans ; }

BLEU: 90.82
Edit Sim: 5


Src: 
function findNthEvenDigitNumber ( n ) { let count = 0 ; for ( let i = 0 ; ; i ++ ) { let curr = i ; let isCurrEvenDigit = true ; while ( curr != 0 ) { if ( curr % 10 == 1 curr % 10 == 3 curr % 10 == 5 curr % 10 == 7 curr % 10 == 9 ) isCurrEvenDigit = false ; curr = Math . floor ( curr / 10 ) ; } if ( isCurrEvenDigit === true ) count ++ ; if ( count === n ) return i ; } }
Ref: 
int findNthEvenDigitNumber ( int n ) { int count = 0 ; for ( int i = 0 ; ; i ++ ) { int curr = i ; bool isCurrEvenDigit = true ; while ( curr != 0 ) { if ( curr % 10 == 1 curr % 10 == 3 curr % 10 == 5 curr % 10 == 7 curr % 10 == 9 ) isCurrEvenDigit = false ; curr = curr / 10 ; } if ( isCurrEvenDigit == true ) count ++ ; if ( count == n ) return i ; } }
Hyp: 
int findNthEvenDigitNumber ( int n ) { int count = 0 ; for ( int i = 0 ; ; i ++ ) { int curr = i ; bool isCurrEvenDigit = true ; while ( curr != 0 ) { if ( curr % 10 == 1 curr % 10 == 3 curr % 10 == 5 curr % 10 == 7 curr % 10 == 9 ) isCurrEvenDigit = false ; curr /= 10 ; } if ( isCurrEvenDigit == true ) count ++ ; if ( count == n ) return i ; } }

BLEU: 95.45
Edit Sim: 8


Src: 
function possibleStrings ( n , r , b , g ) { let fact = new Array ( n + 1 ) ; fact [ 0 ] = 1 ; for ( let i = 1 ; i <= n ; i ++ ) fact [ i ] = fact [ i - 1 ] * i ; let left = n - ( r + g + b ) ; let sum = 0 ; for ( let i = 0 ; i <= left ; i ++ ) { for ( let j = 0 ; j <= left - i ; j ++ ) { let k = left - ( i + j ) ; sum = sum + fact [ n ] / ( fact [ i + r ] * fact [ j + b ] * fact [ k + g ] ) ; } } return sum ; }
Ref: 
int possibleStrings ( int n , int r , int b , int g ) { int fact [ n + 1 ] ; fact [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) fact [ i ] = fact [ i - 1 ] * i ; int left = n - ( r + g + b ) ; int sum = 0 ; for ( int i = 0 ; i <= left ; i ++ ) { for ( int j = 0 ; j <= left - i ; j ++ ) { int k = left - ( i + j ) ; sum = sum + fact [ n ] / ( fact [ i + r ] * fact [ j + b ] * fact [ k + g ] ) ; } } return sum ; }
Hyp: 
int possibleStrings ( int n , int r , int b , int g ) { int fact [ n + 1 ] ; fact [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) fact [ i ] = fact [ i - 1 ] * i ; int left = n - ( r + g + b ) ; int sum = 0 ; for ( int i = 0 ; i <= left ; i ++ ) { for ( int j = 0 ; j <= left - i ; j ++ ) { int k = left - ( i + j ) ; sum = sum + fact [ n ] / ( fact [ i + r ] * fact [ j + b ] * fact [ k + g ] ) ; } } return sum ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function product ( N ) { let ans = 1 ; let val = Math . pow ( 2 , N - 1 ) ; for ( let i = 1 ; i <= N ; i ++ ) { ans *= Math . pow ( i , val ) ; } return ans ; }
Ref: 
int product ( int N ) { int ans = 1 ; int val = pow ( 2 , N - 1 ) ; for ( int i = 1 ; i <= N ; i ++ ) { ans *= pow ( i , val ) ; } return ans ; }
Hyp: 
long product ( long long N ) { long long ans = 1 ; long long val = pow ( 2 , N - 1 ) ; for ( int i = 1 ; i <= N ; i ++ ) { ans *= pow ( i , val ) ; } return ans ; }

BLEU: 79.4
Edit Sim: 27


Src: 
function countPairs ( str ) { let result = 0 ; let n = str . length ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = i + 1 ; j < n ; j ++ ) if ( Math . abs ( str [ i ] . charCodeAt ( ) - str [ j ] . charCodeAt ( ) ) == Math . abs ( i - j ) ) result ++ ; return result ; }
Ref: 
int countPairs ( string str ) { int result = 0 ; int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( abs ( str [ i ] - str [ j ] ) == abs ( i - j ) ) result ++ ; return result ; }
Hyp: 
int countPairs ( string str ) { int result = 0 ; int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( abs ( str [ i ] - str [ j ] ) == abs ( i - j ) ) result ++ ; return result ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function power ( n ) { if ( n == 1 ) return 2 ; return 2 * power ( n - 1 ) ; }
Ref: 
int power ( int n ) { if ( n == 1 ) return 2 ; return 2 * power ( n - 1 ) ; }
Hyp: 
int power ( int n ) { if ( n == 1 ) return 2 ; return 2 * power ( n - 1 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function convert ( m , n ) { if ( m == n ) return 0 ; if ( m > n ) return m - n ; if ( m <= 0 && n > 0 ) return - 1 ; if ( n % 2 == 1 ) return 1 + convert ( m , n + 1 ) ; else return 1 + convert ( m , n / 2 ) ; }
Ref: 
int convert ( int m , int n ) { if ( m == n ) return 0 ; if ( m > n ) return m - n ; if ( m <= 0 && n > 0 ) return -1 ; if ( n % 2 == 1 ) return 1 + convert ( m , n + 1 ) ; else return 1 + convert ( m , n / 2 ) ; }
Hyp: 
int convert ( int m , int n ) { if ( m == n ) return 0 ; if ( m > n ) return m - n ; if ( m <= 0 && n > 0 ) return -1 ; if ( n % 2 == 1 ) return 1 + convert ( m , n + 1 ) ; else return 1 + convert ( m , n / 2 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function andSum ( arr , n ) { var ans = 0 ; for ( i = 0 ; i < BITS ; i ++ ) { var countSetBits = 0 ; for ( j = 0 ; j < n ; j ++ ) { if ( ( arr [ j ] & ( 1 << i ) ) != 0 ) countSetBits ++ ; } var subset = ( 1 << countSetBits ) - 1 ; subset = ( subset * ( 1 << i ) ) ; ans += subset ; } return ans ; }
Ref: 
int andSum ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < BITS ; i ++ ) { int countSetBits = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] & ( 1 << i ) ) countSetBits ++ ; } int subset = ( 1 << countSetBits ) - 1 ; subset = ( subset * ( 1 << i ) ) ; ans += subset ; } return ans ; }
Hyp: 
int andSum ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < BITS ; i ++ ) { int countSetBits = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] & ( 1 << i ) ) countSetBits ++ ; } int subset = ( 1 << countSetBits ) - 1 ; subset = ( subset * ( 1 << i ) ) ; ans += subset ; } return ans ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function solve ( N ) { if ( N % 2 == 0 ) { document . write ( N / 2 + " " + N + " " ) ; } else { document . write ( ( N - 1 ) / 2 + " " + ( N - 1 ) + " " ) ; } }
Ref: 
void solve ( int N ) { if ( N % 2 == 0 ) { cout << N / 2 << " ▁ " << N << endl ; } else { cout << ( N - 1 ) / 2 << " ▁ " << ( N - 1 ) << endl ; } }
Hyp: 
void solve ( int N ) { if ( N % 2 == 0 ) { cout << N / 2 << " ▁ " << N << " ▁ " ; } else { cout << ( N - 1 ) / 2 << " ▁ " << N - 1 ; } }

BLEU: 82.8
Edit Sim: 17


Src: 
function octant ( x , y , z ) { if ( x >= 0 && y >= 0 && z >= 0 ) document . write ( " " + " " ) ; else if ( x < 0 && y >= 0 && z >= 0 ) document . write ( " " + " " ) ; else if ( x < 0 && y < 0 && z >= 0 ) document . write ( " " + " " ) ; else if ( x >= 0 && y < 0 && z >= 0 ) document . write ( " " + " " ) ; else if ( x >= 0 && y >= 0 && z < 0 ) document . write ( " " + " " ) ; else if ( x < 0 && y >= 0 && z < 0 ) document . write ( " " + " " ) ; else if ( x < 0 && y < 0 && z < 0 ) document . write ( " " + " " ) ; else if ( x >= 0 && y < 0 && z < 0 ) document . write ( " " + " " ) ; }
Ref: 
void octant ( float x , float y , float z ) { if ( x >= 0 && y >= 0 && z >= 0 ) cout << " Point ▁ lies ▁ in ▁ 1st ▁ octant STRNEWLINE " ; else if ( x < 0 && y >= 0 && z >= 0 ) cout << " Point ▁ lies ▁ in ▁ 2nd ▁ octant STRNEWLINE " ; else if ( x < 0 && y < 0 && z >= 0 ) cout << " Point ▁ lies ▁ in ▁ 3rd ▁ octant STRNEWLINE " ; else if ( x >= 0 && y < 0 && z >= 0 ) cout << " Point ▁ lies ▁ in ▁ 4th ▁ octant STRNEWLINE " ; else if ( x >= 0 && y >= 0 && z < 0 ) cout << " Point ▁ lies ▁ in ▁ 5th ▁ octant STRNEWLINE " ; else if ( x < 0 && y >= 0 && z < 0 ) cout << " Point ▁ lies ▁ in ▁ 6th ▁ octant STRNEWLINE " ; else if ( x < 0 && y < 0 && z < 0 ) cout << " Point ▁ lies ▁ in ▁ 7th ▁ octant STRNEWLINE " ; else if ( x >= 0 && y < 0 && z < 0 ) cout << " Point ▁ lies ▁ in ▁ 8th ▁ octant STRNEWLINE " ; }
Hyp: 
void octant ( int x , int y , int z ) { if ( x >= 0 && y >= 0 && z >= 0 ) cout << " YES " << endl ; else if ( x < 0 and y < 0 && z >= 0 ) cout << " NO " << endl ; else if ( x >= 0 and y < 0 and z >= 0 ) cout << " YES " << endl ; else if ( x >= 0 and y >= 0 and z < 0 ) cout << " NO " << endl ; else if ( x < 0 and y >= 0 and z < 0 ) cout << " YES " << endl ; else if ( x < 0 and y < 0 and z < 0 ) cout << " NO " << endl ; else if ( x < 0 and y < 0 and z < 0 ) cout << " NO " << endl ; else if ( x >= 0 and y < 0 and z < 0 ) cout << " YES " << endl ; else if ( x >= 0 and y < 0 and z < 0 ) cout << " NO " << endl ; }

BLEU: 42.75
Edit Sim: 407


Src: 
function calculateAreaSum ( l , b ) { var size = 1 ; var maxSize = Math . min ( l , b ) ; var totalArea = 0 ; for ( var i = 1 ; i <= maxSize ; i ++ ) { var totalSquares = ( l - size + 1 ) * ( b - size + 1 ) ; var area = totalSquares * size * size ; totalArea += area ; size ++ ; } return totalArea ; }
Ref: 
int calculateAreaSum ( int l , int b ) { int size = 1 ; int maxSize = min ( l , b ) ; int totalArea = 0 ; for ( int i = 1 ; i <= maxSize ; i ++ ) { int totalSquares = ( l - size + 1 ) * ( b - size + 1 ) ; int area = totalSquares * size * size ; totalArea += area ; size ++ ; } return totalArea ; }
Hyp: 
int calculateAreaSum ( int l , int b ) { int size = 1 ; int maxSize = min ( l , b ) ; int totalArea = 0 ; for ( int i = 1 ; i <= maxSize ; i ++ ) { int totalSquares = ( l - size + 1 ) * ( b - size + 1 ) ; int area = totalSquares * size * size ; totalArea += area ; size ++ ; } return totalArea ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function printSpiral ( n ) { for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { let x ; x = Math . min ( Math . min ( i , j ) , Math . min ( n - 1 - i , n - 1 - j ) ) ; if ( i <= j ) document . write ( ` ${ ( n - 2 * x ) * ( n - 2 * x ) - ( i - x ) - ( j - x ) } ` ) ; else document . write ( ` ${ ( n - 2 * x - 2 ) * ( n - 2 * x - 2 ) + ( i - x ) + ( j - x ) } ` ) ; } document . write ( " " ) ; } }
Ref: 
void printSpiral ( int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { int x ; x = min ( min ( i , j ) , min ( n - 1 - i , n - 1 - j ) ) ; if ( i <= j ) printf ( " % d TABSYMBOL ▁ " , ( n - 2 * x ) * ( n - 2 * x ) - ( i - x ) - ( j - x ) ) ; else printf ( " % d TABSYMBOL ▁ " , ( n - 2 * x - 2 ) * ( n - 2 * x - 2 ) + ( i - x ) + ( j - x ) ) ; } printf ( " STRNEWLINE " ) ; } }
Hyp: 
void printSpiral ( int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { int x ; x = min ( min ( i , j ) , min ( n - 1 - i , n - 1 - j ) ) ; if ( i <= j ) cout << ` ${ ( n - 2 * x ) * ( n - 2 * x ) - ( i - x ) - ( j - x ) } ` ; else cout << ` ${ ( n - 2 * x - 2 ) * ( n - 2 * x - 2 ) + ( i - x ) + ( j - x ) } ` ; } cout << endl ; } }

BLEU: 79.55
Edit Sim: 80


Src: 
function evenlength ( n ) { let res = n ; for ( let j = n . length - 1 ; j >= 0 ; -- j ) res += n [ j ] ; return res ; }
Ref: 
string evenlength ( string n ) { string res = n ; for ( int j = n . length ( ) - 1 ; j >= 0 ; -- j ) res += n [ j ] ; return res ; }
Hyp: 
int evenlength ( string n ) { int res = n ; for ( int j = n . length ( ) - 1 ; j >= 0 ; -- j ) res += n [ j ] ; return res ; }

BLEU: 91.65
Edit Sim: 8


Src: 
function DecakismyriagonNum ( N ) { return ( 99998 * N * N - 99996 * N ) / 2 ; }
Ref: 
int DecakismyriagonNum ( int N ) { return ( 99998 * N * N - 99996 * N ) / 2 ; }
Hyp: 
int DecakismyriagonNum ( int N ) { return ( 99998 * N * N - 99996 * N ) / 2 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function area_of_circle ( m , n ) { var square_of_radius = ( m * n ) / 4 ; var area = ( 3.141 * square_of_radius ) ; return area ; }
Ref: 
double area_of_circle ( int m , int n ) { int square_of_radius = ( m * n ) / 4 ; double area = ( 3.141 * square_of_radius ) ; return area ; }
Hyp: 
float area_of_circle ( int m , int n ) { float square_of_radius = ( m * n ) / 4 ; float area = ( 3.141 * square_of_radius ) ; return area ; }

BLEU: 81.52
Edit Sim: 16


Src: 
function isKthBitSet ( n , k ) { if ( ( n & ( 1 << ( k - 1 ) ) ) > 0 ) document . write ( " " ) ; else document . write ( " " ) ; }
Ref: 
void isKthBitSet ( int n , int k ) { if ( n & ( 1 << ( k - 1 ) ) ) cout << " SET " ; else cout << " NOT ▁ SET " ; }
Hyp: 
void isKthBitSet ( unsigned int n , unsigned int k ) { if ( ( n & ( 1 << ( k - 1 ) ) ) > 0 ) cout << " Yes " ; else cout << " No " ; }

BLEU: 62.13
Edit Sim: 37


Src: 
function reversingString ( str , start , end ) { while ( start < end ) { str [ start ] = String . fromCharCode ( str [ start ] . charCodeAt ( 0 ) ^ str [ end ] . charCodeAt ( 0 ) ) ; str [ end ] = String . fromCharCode ( str [ end ] . charCodeAt ( 0 ) ^ str [ start ] . charCodeAt ( 0 ) ) ; str [ start ] = String . fromCharCode ( str [ start ] . charCodeAt ( 0 ) ^ str [ end ] . charCodeAt ( 0 ) ) ; ++ start ; -- end ; } return ( str ) . join ( " " ) ; }
Ref: 
string reversingString ( string str , int start , int end ) { while ( start < end ) { str [ start ] ^= str [ end ] ; str [ end ] ^= str [ start ] ; str [ start ] ^= str [ end ] ; ++ start ; -- end ; } return str ; }
Hyp: 
void reversingString ( char * str , int start , int end ) { while ( start < end ) { str [ start ] = char ( str [ start ] ^ str [ end ] ) ; str [ end ] = char ( str [ end ] ^ str [ start ] ) ; str [ start ] = char ( str [ start ] ^ str [ end ] ) ; ++ start ; -- end ; } return str ; }

BLEU: 51.96
Edit Sim: 87


Src: 
function FindKthChar ( str , K , X ) { var ans = " " ; var sum = 0 ; for ( i = 0 ; i < str . length ; i ++ ) { var digit = parseInt ( str [ i ] ) ; var range = parseInt ( Math . pow ( digit , X ) ) ; sum += range ; if ( K <= sum ) { ans = str [ i ] ; break ; } } return ans ; }
Ref: 
char FindKthChar ( string str , long long K , int X ) { char ans ; int sum = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { int digit = str [ i ] - '0' ; int range = pow ( digit , X ) ; sum += range ; if ( K <= sum ) { ans = str [ i ] ; break ; } } return ans ; }
Hyp: 
string FindKthChar ( string str , int K , int X ) { string ans = " " ; int sum = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { int digit = stoi ( str [ i ] ) ; int range = pow ( digit , X ) ; sum += range ; if ( K <= sum ) { ans = str [ i ] ; break ; } } return ans ; }

BLEU: 82.14
Edit Sim: 37


Src: 
function smallestNum ( N ) { x = Math . pow ( 10.0 , ( N - 1 ) / 2.0 ) ; return Math . ceil ( x ) ; }
Ref: 
int smallestNum ( int N ) { float x = pow ( 10.0 , ( N - 1 ) / 2.0 ) ; return ceil ( x ) ; }
Hyp: 
int smallestNum ( int N ) { double x = pow ( 10.0 , ( N - 1 ) / 2.0 ) ; return ceil ( x ) ; }

BLEU: 91.28
Edit Sim: 6


Src: 
function get_palindrome_time ( str ) { let hh , mm ; hh = ( str [ 0 ] . charCodeAt ( ) - 48 ) * 10 + ( str [ 1 ] . charCodeAt ( ) - 48 ) ; mm = ( str [ 3 ] . charCodeAt ( ) - 48 ) * 10 + ( str [ 4 ] . charCodeAt ( ) - 48 ) ; let requiredTime = 0 ; while ( hh % 10 != Math . floor ( mm / 10 ) || Math . floor ( hh / 10 ) != mm % 10 ) { ++ mm ; if ( mm == 60 ) { mm = 0 ; ++ hh ; } if ( hh == 24 ) hh = 0 ; ++ requiredTime ; } return requiredTime ; }
Ref: 
int get_palindrome_time ( string str ) { int hh , mm ; hh = ( str [ 0 ] - 48 ) * 10 + ( str [ 1 ] - 48 ) ; mm = ( str [ 3 ] - 48 ) * 10 + ( str [ 4 ] - 48 ) ; int requiredTime = 0 ; while ( hh % 10 != mm / 10 hh / 10 != mm % 10 ) { ++ mm ; if ( mm == 60 ) { mm = 0 ; ++ hh ; } if ( hh == 24 ) hh = 0 ; ++ requiredTime ; } return requiredTime ; }
Hyp: 
int get_palindrome_time ( string str ) { int hh , mm ; hh = ( str [ 0 ] - 48 ) * 10 + ( str [ 1 ] - 48 ) ; mm = ( str [ 3 ] - 48 ) * 10 + ( str [ 4 ] - 48 ) ; int requiredTime = 0 ; while ( hh % 10 != ( mm / 10 ) || ( mm / 10 ) != mm % 10 ) { ++ mm ; if ( mm == 60 ) { mm = 0 ; ++ hh ; } if ( hh == 24 ) hh = 0 ; ++ requiredTime ; } return requiredTime ; }

BLEU: 91.36
Edit Sim: 13


Src: 
function countElements ( p , n ) { var ans = 0 ; for ( i = 1 ; i < n - 1 ; i ++ ) { if ( p [ i - 1 ] > p [ i ] && p [ i ] > p [ i + 1 ] ) ans ++ ; else if ( p [ i - 1 ] < p [ i ] && p [ i ] < p [ i + 1 ] ) ans ++ ; } return ans ; }
Ref: 
int countElements ( int p [ ] , int n ) { int ans = 0 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( p [ i - 1 ] > p [ i ] and p [ i ] > p [ i + 1 ] ) ans ++ ; else if ( p [ i - 1 ] < p [ i ] and p [ i ] < p [ i + 1 ] ) ans ++ ; } return ans ; }
Hyp: 
int countElements ( int p [ ] , int n ) { int ans = 0 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( p [ i - 1 ] > p [ i ] && p [ i ] > p [ i + 1 ] ) ans ++ ; else if ( p [ i - 1 ] < p [ i ] && p [ i ] < p [ i + 1 ] ) ans ++ ; } return ans ; }

BLEU: 94.82
Edit Sim: 6


Src: 
function min_index ( p , n ) { let ans = 0 ; let mini = Number . MAX_SAFE_INTEGER ; for ( let i = 0 ; i < n ; i ++ ) { if ( p [ i ] <= mini ) mini = p [ i ] ; if ( mini == p [ i ] ) ans ++ ; } return ans ; }
Ref: 
int min_index ( int p [ ] , int n ) { int ans = 0 ; int mini = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { if ( p [ i ] <= mini ) mini = p [ i ] ; if ( mini == p [ i ] ) ans ++ ; } return ans ; }
Hyp: 
int min_index ( int p [ ] , int n ) { int ans = 0 ; int mini = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { if ( p [ i ] <= mini ) mini = p [ i ] ; if ( mini == p [ i ] ) ans ++ ; } return ans ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function MaximumPath ( grid ) { let N = grid . length ; let M = grid [ 0 ] . length ; let sum = new Array ( N + 1 ) ; for ( var i = 0 ; i < sum . length ; i ++ ) { sum [ i ] = new Array ( 2 ) ; } for ( var i = 0 ; i < sum . length ; i ++ ) { for ( var j = 0 ; j < sum . length ; j ++ ) { sum [ i ] [ j ] = 0 ; } } for ( let i = 1 ; i <= N ; i ++ ) { for ( let j = 1 ; j <= M ; j ++ ) { sum [ i ] [ j ] = Math . max ( sum [ i - 1 ] [ j ] , sum [ i ] [ j - 1 ] ) + grid [ i - 1 ] [ j - 1 ] ; } } return sum [ N ] [ M ] ; }
Ref: 
int MaximumPath ( vector < vector < int > > & grid ) { int N = grid . size ( ) ; int M = grid [ 0 ] . size ( ) ; vector < vector < int > > sum ; sum . resize ( N + 1 , vector < int > ( M + 1 ) ) ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 1 ; j <= M ; j ++ ) { sum [ i ] [ j ] = max ( sum [ i - 1 ] [ j ] , sum [ i ] [ j - 1 ] ) + grid [ i - 1 ] [ j - 1 ] ; } } return sum [ N ] [ M ] ; }
Hyp: 
int MaximumPath ( vector < vector < int > > grid ) { int N = grid . size ( ) ; int M = grid [ 0 ] . size ( ) ; int sum [ N + 1 ] [ M + 1 ] ; memset ( sum , 0 , sizeof ( sum ) ) ; for ( int i = 0 ; i <= N ; i ++ ) { for ( int j = 1 ; j <= M ; j ++ ) { sum [ i ] [ j ] = 0 ; } } for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 1 ; j <= M ; j ++ ) { sum [ i ] [ j ] = max ( sum [ i - 1 ] [ j ] , sum [ i ] [ j - 1 ] ) + grid [ i - 1 ] [ j - 1 ] ; } } return sum [ N ] [ M ] ; }

BLEU: 66.42
Edit Sim: 122


Src: 
function CountSubarray ( arr , n , k ) { var temp = k , count = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == temp ) { if ( temp == 1 ) { count ++ ; temp = k ; } else temp -- ; } else { temp = k ; if ( arr [ i ] == k ) i -- ; } } return count ; }
Ref: 
int CountSubarray ( int arr [ ] , int n , int k ) { int temp = k , count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == temp ) { if ( temp == 1 ) { count ++ ; temp = k ; } else temp -- ; } else { temp = k ; if ( arr [ i ] == k ) i -- ; } } return count ; }
Hyp: 
int CountSubarray ( int arr [ ] , int n , int k ) { int temp = k , count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == temp ) { if ( temp == 1 ) { count ++ ; temp = k ; } else temp -- ; } else { temp = k ; if ( arr [ i ] == k ) i -- ; } } return count ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function getOrgString ( s ) { document . write ( s [ 0 ] ) ; var i = 1 ; while ( i < s . length ) { if ( s [ i ] . charCodeAt ( 0 ) >= " " . charCodeAt ( 0 ) && s [ i ] . charCodeAt ( 0 ) <= " " . charCodeAt ( 0 ) ) document . write ( " " + s [ i ] . toLowerCase ( ) ) ; else document . write ( s [ i ] ) ; i ++ ; } }
Ref: 
void getOrgString ( string s ) { cout << s [ 0 ] ; int i = 1 ; while ( i < s . length ( ) ) { if ( s [ i ] >= ' A ' && s [ i ] <= ' Z ' ) cout << " ▁ " << ( char ) tolower ( s [ i ] ) ; else cout << s [ i ] ; i ++ ; } }
Hyp: 
void getOrgString ( string s ) { cout << s [ 0 ] ; int i = 1 ; while ( i < s . size ( ) ) { if ( s [ i ] >= ' A ' && s [ i ] <= ' Z ' ) cout << " ▁ " << s [ i ] ; i ++ ; } }

BLEU: 76.79
Edit Sim: 50


Src: 
function singleDigitSubarrayCount ( arr , N ) { let res = 0 ; let count = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( arr [ i ] <= 9 ) { count ++ ; res += count ; } else { count = 0 ; } } document . write ( res ) ; }
Ref: 
int singleDigitSubarrayCount ( int arr [ ] , int N ) { int res = 0 ; int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] <= 9 ) { count ++ ; res += count ; } else { count = 0 ; } } cout << res ; }
Hyp: 
void singleDigitSubarrayCount ( int arr [ ] , int N ) { int res = 0 ; int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] <= 9 ) { count ++ ; res += count ; } else { count = 0 ; } } cout << res ; }

BLEU: 98.52
Edit Sim: 4


Src: 
function rearrange ( arr , n ) { let temp = new Array ( n ) ; let small = 0 , large = n - 1 ; let flag = true ; for ( let i = 0 ; i < n ; i ++ ) { if ( flag ) temp [ i ] = arr [ large -- ] ; else temp [ i ] = arr [ small ++ ] ; flag = ! flag ; } for ( let i = 0 ; i < n ; i ++ ) arr [ i ] = temp [ i ] ; }
Ref: 
void rearrange ( int arr [ ] , int n ) { int temp [ n ] ; int small = 0 , large = n - 1 ; int flag = true ; for ( int i = 0 ; i < n ; i ++ ) { if ( flag ) temp [ i ] = arr [ large -- ] ; else temp [ i ] = arr [ small ++ ] ; flag = ! flag ; } for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = temp [ i ] ; }
Hyp: 
void rearrange ( int arr [ ] , int n ) { int temp [ n ] ; int small = 0 , large = n - 1 ; bool flag = true ; for ( int i = 0 ; i < n ; i ++ ) { if ( flag ) temp [ i ] = arr [ large -- ] ; else temp [ i ] = arr [ small ++ ] ; flag = ! flag ; } for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = temp [ i ] ; }

BLEU: 97.64
Edit Sim: 4


Src: 
function maxPathSum ( tri , m , n ) { for ( let i = m - 1 ; i >= 0 ; i -- ) { for ( let j = 0 ; j <= i ; j ++ ) { if ( tri [ i + 1 ] [ j ] > tri [ i + 1 ] [ j + 1 ] ) tri [ i ] [ j ] += tri [ i + 1 ] [ j ] ; else tri [ i ] [ j ] += tri [ i + 1 ] [ j + 1 ] ; } } return tri [ 0 ] [ 0 ] ; }
Ref: 
int maxPathSum ( int tri [ ] [ N ] , int m , int n ) { for ( int i = m - 1 ; i >= 0 ; i -- ) { for ( int j = 0 ; j <= i ; j ++ ) { if ( tri [ i + 1 ] [ j ] > tri [ i + 1 ] [ j + 1 ] ) tri [ i ] [ j ] += tri [ i + 1 ] [ j ] ; else tri [ i ] [ j ] += tri [ i + 1 ] [ j + 1 ] ; } } return tri [ 0 ] [ 0 ] ; }
Hyp: 
int maxPathSum ( int tri [ ] [ MAX ] , int m , int n ) { for ( int i = m - 1 ; i >= 0 ; i -- ) { for ( int j = 0 ; j <= i ; j ++ ) { if ( tri [ i + 1 ] [ j ] > tri [ i + 1 ] [ j + 1 ] ) tri [ i ] [ j ] += tri [ i + 1 ] [ j ] ; else tri [ i ] [ j ] += tri [ i + 1 ] [ j + 1 ] ; } } return tri [ 0 ] [ 0 ] ; }

BLEU: 97.98
Edit Sim: 3


Src: 
function lbs ( arr , n ) { let i , j ; let lis = new Array ( n ) for ( i = 0 ; i < n ; i ++ ) lis [ i ] = 1 ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; let lds = new Array ( n ) ; for ( i = 0 ; i < n ; i ++ ) lds [ i ] = 1 ; for ( i = n - 2 ; i >= 0 ; i -- ) for ( j = n - 1 ; j > i ; j -- ) if ( arr [ i ] > arr [ j ] && lds [ i ] < lds [ j ] + 1 ) lds [ i ] = lds [ j ] + 1 ; let max = lis [ 0 ] + lds [ 0 ] - 1 ; for ( i = 1 ; i < n ; i ++ ) if ( lis [ i ] + lds [ i ] - 1 > max ) max = lis [ i ] + lds [ i ] - 1 ; return max ; }
Ref: 
int lbs ( int arr [ ] , int n ) { int i , j ; int * lis = new int [ n ] ; for ( i = 0 ; i < n ; i ++ ) lis [ i ] = 1 ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; int * lds = new int [ n ] ; for ( i = 0 ; i < n ; i ++ ) lds [ i ] = 1 ; for ( i = n - 2 ; i >= 0 ; i -- ) for ( j = n - 1 ; j > i ; j -- ) if ( arr [ i ] > arr [ j ] && lds [ i ] < lds [ j ] + 1 ) lds [ i ] = lds [ j ] + 1 ; int max = lis [ 0 ] + lds [ 0 ] - 1 ; for ( i = 1 ; i < n ; i ++ ) if ( lis [ i ] + lds [ i ] - 1 > max ) max = lis [ i ] + lds [ i ] - 1 ; return max ; }
Hyp: 
int lbs ( int arr [ ] , int n ) { int i , j ; int lis [ n ] ; for ( i = 0 ; i < n ; i ++ ) lis [ i ] = 1 ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; int lds [ n ] ; for ( i = 0 ; i < n ; i ++ ) lds [ i ] = 1 ; for ( i = n - 2 ; i >= 0 ; i -- ) for ( j = n - 1 ; j > i ; j -- ) if ( arr [ i ] > arr [ j ] && lds [ i ] < lds [ j ] + 1 ) lds [ i ] = lds [ j ] + 1 ; int max = lis [ 0 ] + lds [ 0 ] - 1 ; for ( i = 1 ; i < n ; i ++ ) if ( lis [ i ] + lds [ i ] - 1 > max ) max = lis [ i ] + lds [ i ] - 1 ; return max ; }

BLEU: 95.26
Edit Sim: 24


Src: 
function SquareCube ( N ) { let cnt = 0 , i = 1 ; while ( Math . floor ( Math . pow ( i , 6 ) ) <= N ) { ++ cnt ; ++ i ; } return cnt ; }
Ref: 
int SquareCube ( long long int N ) { int cnt = 0 , i = 1 ; while ( int ( pow ( i , 6 ) ) <= N ) { ++ cnt ; ++ i ; } return cnt ; }
Hyp: 
int SquareCube ( int N ) { int cnt = 0 , i = 1 ; while ( floor ( pow ( i , 6 ) ) <= N ) { ++ cnt ; ++ i ; } return cnt ; }

BLEU: 86.39
Edit Sim: 15


Src: 
function maximumSum ( arr , N ) { let sum ; arr . sort ( ) ; sum = ( arr [ N - 1 ] - arr [ 0 ] ) + ( arr [ N - 2 ] - arr [ 0 ] ) + ( arr [ N - 1 ] - arr [ N - 2 ] ) ; document . write ( sum ) ; }
Ref: 
void maximumSum ( int arr [ ] , int N ) { int sum ; sort ( arr , arr + N ) ; sum = ( arr [ N - 1 ] - arr [ 0 ] ) + ( arr [ N - 2 ] - arr [ 0 ] ) + ( arr [ N - 1 ] - arr [ N - 2 ] ) ; cout << sum ; }
Hyp: 
void maximumSum ( int arr [ ] , int N ) { int sum ; sort ( arr , arr + N ) ; sum = ( arr [ N - 1 ] - arr [ 0 ] ) + ( arr [ N - 2 ] - arr [ 0 ] ) + ( arr [ N - 1 ] - arr [ N - 2 ] ) ; cout << sum ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function SmallestPerfectSquare ( N ) { let X = 1e9 ; let ans ; for ( let i = 1 ; i < Math . sqrt ( N ) ; i ++ ) { if ( N % i == 0 ) { let a = i ; let b = N / i ; if ( ( b - a != 0 ) && ( ( b - a ) % 2 == 0 ) ) { X = Math . min ( X , ( b - a ) / 2 ) ; } } } if ( X != 1e9 ) ans = X * X ; else ans = - 1 ; return ans ; }
Ref: 
long SmallestPerfectSquare ( long N ) { long X = ( long ) 1e9 ; long ans ; for ( int i = 1 ; i < sqrt ( N ) ; i ++ ) { if ( N % i == 0 ) { long a = i ; long b = N / i ; if ( ( b - a != 0 ) && ( ( b - a ) % 2 == 0 ) ) { X = min ( X , ( b - a ) / 2 ) ; } } } if ( X != 1e9 ) ans = X * X ; else ans = -1 ; return ans ; }
Hyp: 
int SmallestPerfectSquare ( int N ) { int X = 1e9 ; int ans ; for ( int i = 1 ; i < sqrt ( N ) ; i ++ ) { if ( N % i == 0 ) { int a = i ; int b = N / i ; if ( ( b - a != 0 ) && ( ( b - a ) % 2 == 0 ) ) { X = min ( X , ( b - a ) / 2 ) ; } } } if ( X != 1e9 ) ans = X * X ; else ans = -1 ; return ans ; }

BLEU: 85.23
Edit Sim: 27


Src: 
function sum ( x , n ) { let i , total = 1.0 , multi = x ; document . write ( total + " " ) ; for ( i = 1 ; i < n ; i ++ ) { total = total + multi ; document . write ( multi + " " ) ; multi = multi * x ; } document . write ( " " ) ; return total ; }
Ref: 
double sum ( int x , int n ) { double i , total = 1.0 , multi = x ; cout << total << " ▁ " ; for ( i = 1 ; i < n ; i ++ ) { total = total + multi ; cout << multi << " ▁ " ; multi = multi * x ; } cout << " STRNEWLINE " ; return total ; }
Hyp: 
double sum ( double x , int n ) { int i , total = 1.0 , multi = x ; cout << total << " ▁ " ; for ( i = 1 ; i < n ; i ++ ) { total = total + multi ; cout << multi << " ▁ " ; multi = multi * x ; } cout << endl ; return total ; }

BLEU: 87.47
Edit Sim: 26


Src: 
function check ( n ) { return 1162261467 % n == 0 ; }
Ref: 
bool check ( int n ) { if ( n <= 0 ) return false ; return 1162261467 % n == 0 ; }
Hyp: 
bool check ( int n ) { return 1162261467 % n == 0 ; }

BLEU: 48.61
Edit Sim: 29


Src: 
function divisorsSame ( n ) { return ( n - 2 ) % 4 == 0 ; } let N = 6 ; if ( divisorsSame ( N ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
Ref: 
bool divisorsSame ( int n ) { return ( n - 2 ) % 4 == 0 ; }
Hyp: 
bool divisorsSame ( int n ) { return ( n - 2 ) % 4 == 0 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function trapezoidarea ( r ) { if ( r < 0 ) return - 1 ; var a = ( 3 * Math . sqrt ( 3 ) * Math . pow ( r , 2 ) ) / 4 ; return a ; }
Ref: 
float trapezoidarea ( float r ) { if ( r < 0 ) return -1 ; float a = ( 3 * sqrt ( 3 ) * pow ( r , 2 ) ) / 4 ; return a ; }
Hyp: 
float trapezoidarea ( float r ) { if ( r < 0 ) return -1 ; float a = ( 3 * sqrt ( 3 ) * pow ( r , 2 ) ) / 4 ; return a ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function Valid ( a , b , c ) { if ( a + b + c == 180 && a != 0 && b != 0 && c != 0 ) return 1 ; else return 0 ; } var a = 60 , b = 40 , c = 80 ; if ( ( Valid ( a , b , c ) ) == 1 ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
Ref: 
bool Valid ( int a , int b , int c ) { if ( a + b + c == 180 && a != 0 && b != 0 && c != 0 ) return true ; else return false ; }
Hyp: 
int Valid ( int a , int b , int c ) { if ( a + b + c == 180 && a != 0 && b != 0 && c != 0 ) return 1 ; else return 0 ; }

BLEU: 86.21
Edit Sim: 13


Src: 
function maxValue ( a , b ) { b . sort ( function ( x , y ) { return x - y ; } ) ; let n = a . length ; let m = b . length ; let j = m - 1 ; for ( let i = 0 ; i < n ; i ++ ) { if ( j < 0 ) break ; if ( b [ j ] > a [ i ] ) { a [ i ] = b [ j ] ; j -- ; } } return ( a ) . join ( " " ) ; }
Ref: 
string maxValue ( string a , string b ) { sort ( b . begin ( ) , b . end ( ) ) ; int n = a . length ( ) ; int m = b . length ( ) ; int j = m - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( j < 0 ) break ; if ( b [ j ] > a [ i ] ) { a [ i ] = b [ j ] ; j -- ; } } return a ; }
Hyp: 
void maxValue ( int a [ ] , int b [ ] ) { sort ( b , b + n ) ; int n = a . size ( ) ; int m = b . size ( ) ; int j = m - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( j < 0 ) break ; if ( b [ j ] > a [ i ] ) { a [ i ] = b [ j ] ; j -- ; } } return ( a ) ; }

BLEU: 76.8
Edit Sim: 54


Src: 
function minimumCost ( cost , n ) { let dp = new Array ( n ) ; if ( n == 1 ) return cost [ 0 ] ; dp [ 0 ] = cost [ 0 ] ; dp [ 1 ] = cost [ 1 ] ; for ( let i = 2 ; i < n ; i ++ ) { dp [ i ] = Math . min ( dp [ i - 1 ] , dp [ i - 2 ] ) + cost [ i ] ; } return Math . min ( dp [ n - 2 ] , dp [ n - 1 ] ) ; }
Ref: 
int minimumCost ( int cost [ ] , int n ) { int dp [ n ] ; if ( n == 1 ) return cost [ 0 ] ; dp [ 0 ] = cost [ 0 ] ; dp [ 1 ] = cost [ 1 ] ; for ( int i = 2 ; i < n ; i ++ ) { dp [ i ] = min ( dp [ i - 1 ] , dp [ i - 2 ] ) + cost [ i ] ; } return min ( dp [ n - 2 ] , dp [ n - 1 ] ) ; }
Hyp: 
int minimumCost ( int * cost , int n ) { int dp [ n ] ; if ( n == 1 ) return cost [ 0 ] ; dp [ 0 ] = cost [ 0 ] ; dp [ 1 ] = cost [ 1 ] ; for ( int i = 2 ; i < n ; i ++ ) { dp [ i ] = min ( dp [ i - 1 ] , dp [ i - 2 ] ) + cost [ i ] ; } return min ( dp [ n - 2 ] , dp [ n - 1 ] ) ; }

BLEU: 96.17
Edit Sim: 6


Src: 
function findSubstringCount ( str ) { var result = 0 ; var n = str . length ; for ( var i = 0 ; i < n - 1 ; i ++ ) { if ( String . fromCharCode ( str [ i ] . charCodeAt ( 0 ) + 1 ) == str [ i + 1 ] ) { result ++ ; while ( String . fromCharCode ( str [ i ] . charCodeAt ( 0 ) + 1 ) === str [ i + 1 ] ) { i ++ ; } } } return result ; }
Ref: 
int findSubstringCount ( string str ) { int result = 0 ; int n = str . size ( ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( str [ i ] + 1 == str [ i + 1 ] ) { result ++ ; while ( str [ i ] + 1 == str [ i + 1 ] ) { i ++ ; } } } return result ; }
Hyp: 
int findSubstringCount ( string str ) { int result = 0 ; int n = str . length ( ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( str [ i ] + 1 == str [ i + 1 ] ) { result ++ ; while ( str [ i ] + 1 == str [ i + 1 ] ) { i ++ ; } } } return result ; }

BLEU: 97.01
Edit Sim: 6


Src: 
function count ( n ) { let dp = [ ] ; dp [ 0 ] = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { if ( i >= 1 && i <= 3 ) dp [ i ] = 1 ; else if ( i == 4 ) dp [ i ] = 2 ; else { dp [ i ] = dp [ i - 1 ] + dp [ i - 4 ] ; } } return dp [ n ] ; }
Ref: 
int count ( int n ) { int dp [ n + 1 ] ; dp [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i >= 1 && i <= 3 ) dp [ i ] = 1 ; else if ( i == 4 ) dp [ i ] = 2 ; else dp [ i ] = dp [ i - 1 ] + dp [ i - 4 ] ; } return dp [ n ] ; }
Hyp: 
int count ( int n ) { int dp [ n + 1 ] ; dp [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i >= 1 && i <= 3 ) dp [ i ] = 1 ; else if ( i == 4 ) dp [ i ] = 2 ; else { dp [ i ] = dp [ i - 1 ] + dp [ i - 4 ] ; } } return dp [ n ] ; }

BLEU: 95.6
Edit Sim: 4


Src: 
function count ( N ) { var a = 0 ; a = ( N * ( N + 1 ) ) / 2 ; return a ; }
Ref: 
int count ( int N ) { int a = 0 ; a = ( N * ( N + 1 ) ) / 2 ; return a ; }
Hyp: 
int count ( int N ) { int a = 0 ; a = ( N * ( N + 1 ) ) / 2 ; return a ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function isDivisible ( n ) { temp = n ; sum = 0 ; while ( n ) { k = n % 10 ; sum += k ; n = parseInt ( n / 10 ) ; } if ( temp % sum == 0 ) return " " ; return " " ; }
Ref: 
string isDivisible ( long long int n ) { long long int temp = n ; int sum = 0 ; while ( n ) { int k = n % 10 ; sum += k ; n /= 10 ; } if ( temp % sum == 0 ) return " YES " ; return " NO " ; }
Hyp: 
string isDivisible ( int n ) { int temp = n , sum = 0 ; while ( n ) { int k = n % 10 ; sum += k ; n = n / 10 ; } if ( temp % sum == 0 ) return " Yes " ; return " No " ; }

BLEU: 68.99
Edit Sim: 33


Src: 
function count ( S , m , n ) { if ( n == 0 ) return 1 ; if ( n < 0 ) return 0 ; if ( m <= 0 && n >= 1 ) return 0 ; return count ( S , m - 1 , n ) + count ( S , m , n - S [ m - 1 ] ) ; }
Ref: 
int count ( int S [ ] , int m , int n ) { if ( n == 0 ) return 1 ; if ( n < 0 ) return 0 ; if ( m <= 0 && n >= 1 ) return 0 ; return count ( S , m - 1 , n ) + count ( S , m , n - S [ m - 1 ] ) ; }
Hyp: 
int count ( string & S , int m , int n ) { if ( n == 0 ) return 1 ; if ( n < 0 ) return 0 ; if ( m <= 0 && n >= 1 ) return 0 ; return count ( S , m - 1 , n ) + count ( S , m , n - S [ m - 1 ] ) ; }

BLEU: 92.9
Edit Sim: 8


Src: 
function newvol ( x ) { document . write ( " " + " " + ( Math . pow ( x , 3 ) / 10000 + 3 * x + ( 3 * Math . pow ( x , 2 ) ) / 100 ) + " " ) ; }
Ref: 
void newvol ( double x ) { cout << " percentage ▁ increase ▁ " << " in ▁ the ▁ volume ▁ of ▁ the ▁ cube ▁ is ▁ " << pow ( x , 3 ) / 10000 + 3 * x + ( 3 * pow ( x , 2 ) ) / 100 << " % " << endl ; }
Hyp: 
void newvol ( double x ) { cout << " percentage ▁ increase ▁ " << " in ▁ the ▁ volume ▁ of ▁ the ▁ cylinder ▁ is ▁ " << pow ( x , 3 ) / 10000 + 3 * x + ( 3 * pow ( x , 2 ) ) / 100 << endl ; }

BLEU: 88.69
Edit Sim: 15


Src: 
function countElement ( A , N , B , M , K ) { let cnt = 0 ; for ( let i = 0 ; i < M ; i ++ ) { let currentElement = B [ i ] ; for ( let j = 0 ; j < N ; j ++ ) { let diff = Math . abs ( currentElement - A [ j ] ) ; if ( diff <= K ) { cnt ++ ; break ; } } } document . write ( cnt ) ; }
Ref: 
void countElement ( int A [ ] , int N , int B [ ] , int M , int K ) { int cnt = 0 ; for ( int i = 0 ; i < M ; i ++ ) { int currentElement = B [ i ] ; for ( int j = 0 ; j < N ; j ++ ) { int diff = abs ( currentElement - A [ j ] ) ; if ( diff <= K ) { cnt ++ ; break ; } } } cout << cnt ; }
Hyp: 
void countElement ( int A [ ] , int N , int B [ ] , int M , int K ) { int cnt = 0 ; for ( int i = 0 ; i < M ; i ++ ) { int currentElement = B [ i ] ; for ( int j = 0 ; j < N ; j ++ ) { int diff = abs ( currentElement - A [ j ] ) ; if ( diff <= K ) { cnt ++ ; break ; } } } cout << cnt ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function parallel ( n , a ) { let x = true , y = true ; for ( let i = 0 ; i < n - 1 ; i ++ ) { if ( a [ i ] [ 0 ] != a [ i + 1 ] [ 0 ] ) x = false ; if ( a [ i ] [ 1 ] != a [ i + 1 ] [ 1 ] ) y = false ; } if ( x ) document . write ( " " + " " ) ; else if ( y ) document . write ( " " + " " ) ; else document . write ( " " + " " + " " ) ; }
Ref: 
void parallel ( int n , int a [ ] [ 2 ] ) { bool x = true , y = true ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( a [ i ] [ 0 ] != a [ i + 1 ] [ 0 ] ) x = false ; if ( a [ i ] [ 1 ] != a [ i + 1 ] [ 1 ] ) y = false ; } if ( x ) cout << " parallel ▁ to ▁ Y ▁ Axis " << endl ; else if ( y ) cout << " parallel ▁ to ▁ X ▁ Axis " << endl ; else cout << " Not ▁ parallel ▁ to ▁ X " << " ▁ and ▁ Y ▁ Axis " << endl ; }
Hyp: 
void parallel ( int n , int a [ ] [ 2 ] ) { bool x = true , y = true ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( a [ i ] [ 0 ] != a [ i + 1 ] [ 0 ] ) x = false ; if ( a [ i ] [ 1 ] != a [ i + 1 ] [ 1 ] ) y = false ; } if ( x ) cout << " No " << endl ; else if ( y ) cout << " Yes " << endl ; else cout << " No " << endl ; }

BLEU: 75.67
Edit Sim: 90


Src: 
function multiplicativeCongruentialMethod ( Xo , m , a , randomNums , noOfRandomNums ) { randomNums [ 0 ] = Xo ; for ( let i = 1 ; i < noOfRandomNums ; i ++ ) { randomNums [ i ] = ( randomNums [ i - 1 ] * a ) % m ; } } let Xo = 3 ; let m = 15 ; let a = 7 ; let noOfRandomNums = 10 ; let randomNums = new Array ( noOfRandomNums ) . fill ( 0 ) ; multiplicativeCongruentialMethod ( Xo , m , a , randomNums , noOfRandomNums ) ; for ( let i = 0 ; i < noOfRandomNums ; i ++ ) { document . write ( randomNums [ i ] + " " ) ; }
Ref: 
void multiplicativeCongruentialMethod ( int Xo , int m , int a , vector < int > & randomNums , int noOfRandomNums ) { randomNums [ 0 ] = Xo ; for ( int i = 1 ; i < noOfRandomNums ; i ++ ) { randomNums [ i ] = ( randomNums [ i - 1 ] * a ) % m ; } }
Hyp: 
void multiplicativeCongruentialMethod ( int Xo , int m , int a , vector < int > & randomNums , int noOfRandomNums ) { randomNums [ 0 ] = Xo ; for ( int i = 1 ; i < noOfRandomNums ; i ++ ) { randomNums [ i ] = ( randomNums [ i - 1 ] * a ) % m ; } }

BLEU: 100.0
Edit Sim: 0


Src: 
function count ( arr , N , K ) { let count = 0 , ans = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == K ) { count = count + 1 ; } else { ans += ( count * ( count + 1 ) ) / 2 ; count = 0 ; } } ans = ans + ( count * ( count + 1 ) ) / 2 ; return ans ; }
Ref: 
int count ( int arr [ ] , int N , int K ) { int count = 0 , ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == K ) { count = count + 1 ; } else { ans += ( count * ( count + 1 ) ) / 2 ; count = 0 ; } } ans = ans + ( count * ( count + 1 ) ) / 2 ; return ans ; }
Hyp: 
int count ( int arr [ ] , int N , int K ) { int count = 0 , ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == K ) { count = count + 1 ; } else { ans += ( count * ( count + 1 ) ) / 2 ; count = 0 ; } } ans = ans + ( count * ( count + 1 ) ) / 2 ; return ans ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function equalXORandOR ( n ) { var m = 0 ; var MSB = parseInt ( Math . log ( n ) ) ; for ( i = 0 ; i <= MSB ; i ++ ) { if ( ( n & ( 1 << i ) ) <= 0 ) { m += ( 1 << i ) ; } } return m ; }
Ref: 
int equalXORandOR ( int n ) { int m = 0 ; int MSB = ( int ) log2 ( n ) ; for ( int i = 0 ; i <= MSB ; i ++ ) { if ( ! ( n & ( 1 << i ) ) ) { m += ( 1 << i ) ; } } return m ; }
Hyp: 
int equalXORandOR ( int n ) { int m = 0 ; int MSB = log2 ( n ) ; for ( int i = 0 ; i <= MSB ; i ++ ) { if ( ( n & ( 1 << i ) ) <= 0 ) { m += ( 1 << i ) ; } } return m ; }

BLEU: 86.75
Edit Sim: 15


Src: 
function checkCollision ( a , b , c , x , y , radius ) { let dist = ( Math . abs ( a * x + b * y + c ) ) / Math . sqrt ( a * a + b * b ) ; if ( radius == dist ) document . write ( " " ) ; else if ( radius > dist ) document . write ( " " ) ; else document . write ( " " ) ; }
Ref: 
void checkCollision ( int a , int b , int c , int x , int y , int radius ) { int dist = ( abs ( a * x + b * y + c ) ) / sqrt ( a * a + b * b ) ; if ( radius == dist ) cout << " Touch " << endl ; else if ( radius > dist ) cout << " Intersect " << endl ; else cout << " Outside " << endl ; }
Hyp: 
void checkCollision ( int a , int b , int c , int x , int y , int radius ) { float dist = ( abs ( a * x + b * y + c ) ) / sqrt ( a * a + b * b ) ; if ( radius == dist ) cout << " Yes " ; else if ( radius > dist ) cout << " No " ; else cout << " Yes " ; }

BLEU: 79.42
Edit Sim: 48


Src: 
function check ( a , n ) { let ma = a [ 1 ] - a [ 0 ] ; for ( let i = 1 ; i < n - 1 ; i ++ ) { if ( ( a [ i ] > a [ i - 1 ] && a [ i + 1 ] < a [ i ] ) || ( a [ i ] < a [ i - 1 ] && a [ i + 1 ] > a [ i ] ) ) ma = Math . max ( ma , Math . abs ( a [ i ] - a [ i + 1 ] ) ) ; else return false ; } document . write ( " " + ma ) ; document . write ( " " ) ; return true ; }
Ref: 
bool check ( int a [ ] , int n ) { int ma = a [ 1 ] - a [ 0 ] ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( ( a [ i ] > a [ i - 1 ] && a [ i + 1 ] < a [ i ] ) || ( a [ i ] < a [ i - 1 ] && a [ i + 1 ] > a [ i ] ) ) ma = max ( ma , abs ( a [ i ] - a [ i + 1 ] ) ) ; else return false ; } cout << " Amplitude ▁ = ▁ " << ma ; cout << endl ; return true ; }
Hyp: 
bool check ( int a [ ] , int n ) { int ma = a [ 1 ] - a [ 0 ] ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( ( a [ i ] > a [ i - 1 ] && a [ i + 1 ] < a [ i ] ) || ( a [ i ] < a [ i - 1 ] && a [ i + 1 ] > a [ i ] ) ) ma = max ( ma , abs ( a [ i ] - a [ i + 1 ] ) ) ; else return false ; } cout << " Ma ▁ is ▁ [ " << ma ; cout << " STRNEWLINE " ; return true ; }

BLEU: 92.69
Edit Sim: 26


Src: 
function MaximumSum ( a , b , n ) { let dp = new Array ( n ) . fill ( 0 ) . map ( ( ) => new Array ( 2 ) ) ; dp [ 0 ] [ 0 ] = a [ 0 ] ; dp [ 0 ] [ 1 ] = b [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { dp [ i ] [ 0 ] = Math . max ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] ) + a [ i ] ; dp [ i ] [ 1 ] = Math . max ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] ) ; if ( i - 2 >= 0 ) { dp [ i ] [ 1 ] = Math . max ( dp [ i ] [ 1 ] , Math . max ( dp [ i - 2 ] [ 0 ] , dp [ i - 2 ] [ 1 ] ) + b [ i ] ) ; } else { dp [ i ] [ 1 ] = Math . max ( dp [ i ] [ 1 ] , b [ i ] ) ; } } return Math . max ( dp [ n - 1 ] [ 0 ] , dp [ n - 1 ] [ 1 ] ) ; }
Ref: 
int MaximumSum ( int a [ ] , int b [ ] , int n ) { int dp [ n ] [ 2 ] ; dp [ 0 ] [ 0 ] = a [ 0 ] ; dp [ 0 ] [ 1 ] = b [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { dp [ i ] [ 0 ] = max ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] ) + a [ i ] ; dp [ i ] [ 1 ] = max ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] ) ; if ( i - 2 >= 0 ) { dp [ i ] [ 1 ] = max ( dp [ i ] [ 1 ] , max ( dp [ i - 2 ] [ 0 ] , dp [ i - 2 ] [ 1 ] ) + b [ i ] ) ; } else { dp [ i ] [ 1 ] = max ( dp [ i ] [ 1 ] , b [ i ] ) ; } } return max ( dp [ n - 1 ] [ 0 ] , dp [ n - 1 ] [ 1 ] ) ; }
Hyp: 
int MaximumSum ( int a [ ] , int b [ ] , int n ) { vector < vector < int > > dp ( n , 0 ) ; dp [ 0 ] [ 0 ] = a [ 0 ] ; dp [ 0 ] [ 1 ] = b [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { dp [ i ] [ 0 ] = max ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] ) + a [ i ] ; dp [ i ] [ 1 ] = max ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] ) ; if ( i - 2 >= 0 ) { dp [ i ] [ 1 ] = max ( dp [ i ] [ 1 ] , max ( dp [ i - 2 ] [ 0 ] , dp [ i - 2 ] [ 1 ] ) + b [ i ] ) ; } else { dp [ i ] [ 1 ] = max ( dp [ i ] [ 1 ] , b [ i ] ) ; } } return max ( dp [ n - 1 ] [ 0 ] , dp [ n - 1 ] [ 1 ] ) ; }

BLEU: 94.46
Edit Sim: 28


Src: 
function checkTriangle ( x1 , y1 , x2 , y2 , x3 , y3 ) { let a = x1 * ( y2 - y3 ) + x2 * ( y3 - y1 ) + x3 * ( y1 - y2 ) ; if ( a == 0 ) document . write ( " " ) ; else document . write ( " " ) ; }
Ref: 
void checkTriangle ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 ) { int a = x1 * ( y2 - y3 ) + x2 * ( y3 - y1 ) + x3 * ( y1 - y2 ) ; if ( a == 0 ) cout << " No " ; else cout << " Yes " ; }
Hyp: 
void checkTriangle ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 ) { int a = x1 * ( y2 - y3 ) + x2 * ( y3 - y1 ) + x3 * ( y1 - y2 ) ; if ( a == 0 ) cout << " Yes " ; else cout << " No " ; }

BLEU: 99.25
Edit Sim: 6


Src: 
function AlternateRearrange ( arr , n ) { arr . sort ( ( a , b ) => a - b ) ; for ( var i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 == 0 ) v1 . push ( arr [ i ] ) ; else v2 . push ( arr [ i ] ) ; var index = 0 , i = 0 , j = 0 ; var flag = false ; if ( arr [ 0 ] % 2 == 0 ) flag = true ; while ( index < n ) { if ( flag == true ) { arr [ index ++ ] = v1 [ i ++ ] ; flag = ! flag ; } else { arr [ index ++ ] = v2 [ j ++ ] ; flag = ! flag ; } } for ( i = 0 ; i < n ; i ++ ) document . write ( arr [ i ] + " " ) ; }
Ref: 
void AlternateRearrange ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 == 0 ) v1 . push_back ( arr [ i ] ) ; else v2 . push_back ( arr [ i ] ) ; int index = 0 , i = 0 , j = 0 ; bool flag = false ; if ( arr [ 0 ] % 2 == 0 ) flag = true ; while ( index < n ) { if ( flag == true ) { arr [ index ++ ] = v1 [ i ++ ] ; flag = ! flag ; } else { arr [ index ++ ] = v2 [ j ++ ] ; flag = ! flag ; } } for ( i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; }
Hyp: 
void AlternateRearrange ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 == 0 ) v1 . push_back ( arr [ i ] ) ; else v2 . push_back ( arr [ i ] ) ; int index = 0 , i = 0 , j = 0 ; bool flag = false ; if ( arr [ 0 ] % 2 == 0 ) flag = true ; while ( index < n ) { if ( flag == true ) { arr [ index ++ ] = v1 [ i ++ ] ; flag = ! flag ; } else { arr [ index ++ ] = v2 [ j ++ ] ; flag = ! flag ; } } for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; }

BLEU: 98.59
Edit Sim: 4


Src: 
function minimumHammingDistance ( S , K ) { let n = S . length ; let pref = new Array ( n ) ; pref [ 0 ] = S [ 0 ] - ' ' ; for ( let i = 1 ; i < n ; i ++ ) pref [ i ] = pref [ i - 1 ] + ( S [ i ] - ' ' ) ; let cnt = pref [ n - 1 ] ; let ans = cnt ; for ( let i = 0 ; i < n - K ; i ++ ) { let value = pref [ i + K - 1 ] - ( i - 1 >= 0 ? pref [ i - 1 ] : 0 ) ; ans = Math . min ( ans , cnt - value + ( K - value ) ) ; } return ans ; }
Ref: 
int minimumHammingDistance ( string S , int K ) { int n = S . size ( ) ; int pref [ n ] ; pref [ 0 ] = S [ 0 ] - '0' ; for ( int i = 1 ; i < n ; i ++ ) pref [ i ] = pref [ i - 1 ] + ( S [ i ] - '0' ) ; int cnt = pref [ n - 1 ] ; int ans = cnt ; for ( int i = 0 ; i < n - K ; i ++ ) { int value = pref [ i + K - 1 ] - ( i - 1 >= 0 ? pref [ i - 1 ] : 0 ) ; ans = min ( ans , cnt - value + ( K - value ) ) ; } return ans ; }
Hyp: 
int minimumHammingDistance ( string S , int K ) { int n = S . size ( ) ; int pref [ n ] ; pref [ 0 ] = S [ 0 ] - '0' ; for ( int i = 1 ; i < n ; i ++ ) pref [ i ] = pref [ i - 1 ] + ( S [ i ] - '0' ) ; int cnt = pref [ n - 1 ] ; int ans = cnt ; for ( int i = 0 ; i < n - K ; i ++ ) { int value = pref [ i + K - 1 ] - ( i - 1 >= 0 ? pref [ i - 1 ] : 0 ) ; ans = min ( ans , cnt - value + ( K - value ) ) ; } return ans ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function printSeries ( N ) { let ith_term = 0 ; for ( let i = 1 ; i <= N ; i ++ ) { ith_term = ( 13 * i * ( i - 1 ) ) / 2 + 2 ; document . write ( ith_term + " " ) ; } }
Ref: 
void printSeries ( int N ) { int ith_term = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { ith_term = ( 13 * i * ( i - 1 ) ) / 2 + 2 ; cout << ith_term << " , ▁ " ; } }
Hyp: 
void printSeries ( int N ) { int ith_term = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { ith_term = ( 13 * i * ( i - 1 ) ) / 2 + 2 ; cout << ith_term << " ▁ " ; } }

BLEU: 95.43
Edit Sim: 2


Src: 
function minStartValue ( nums ) { let minValue = 0 ; let sum = 0 ; for ( let n = 0 ; n < nums . length ; n ++ ) { sum += nums [ n ] ; minValue = Math . min ( minValue , sum ) ; } let startValue = 1 - minValue ; return startValue ; }
Ref: 
int minStartValue ( vector < int > & nums ) { int minValue = 0 ; int sum = 0 ; for ( auto n : nums ) { sum += n ; minValue = min ( minValue , sum ) ; } int startValue = 1 - minValue ; return startValue ; }
Hyp: 
int minStartValue ( int nums [ ] , int n ) { int minValue = 0 ; int sum = 0 ; for ( int n = 0 ; n < nums . length ( ) ; n ++ ) { sum += nums [ n ] ; minValue = min ( minValue , sum ) ; } int startValue = 1 - minValue ; return startValue ; }

BLEU: 56.88
Edit Sim: 57


Src: 
function calculateWays ( arr1 , arr2 , N ) { let A = arr2 [ 0 ] , B = arr2 [ 1 ] ; let C = arr2 [ 2 ] , D = arr2 [ 3 ] ; let ans = 0 ; for ( let b = 0 ; b <= B && b * 5 <= ( N ) ; b ++ ) for ( let c = 0 ; c <= C && b * 5 + c * 10 <= ( N ) ; c ++ ) for ( let d = 0 ; d <= D && b * 5 + c * 10 + d * 20 <= ( N ) ; d ++ ) if ( ( b * 5 ) + ( c * 10 ) + ( d * 20 ) >= ( N - A ) ) ans ++ ; return ans ; }
Ref: 
int calculateWays ( int arr1 [ ] , int arr2 [ ] , int N ) { int A = arr2 [ 0 ] , B = arr2 [ 1 ] ; int C = arr2 [ 2 ] , D = arr2 [ 3 ] ; int ans = 0 ; for ( int b = 0 ; b <= B && b * 5 <= ( N ) ; b ++ ) for ( int c = 0 ; c <= C && b * 5 + c * 10 <= ( N ) ; c ++ ) for ( int d = 0 ; d <= D && b * 5 + c * 10 + d * 20 <= ( N ) ; d ++ ) if ( ( b * 5 ) + ( c * 10 ) + ( d * 20 ) >= ( N - A ) ) ans ++ ; return ans ; }
Hyp: 
int calculateWays ( int arr1 [ ] , int arr2 [ ] , int N ) { int A = arr2 [ 0 ] , B = arr2 [ 1 ] ; int C = arr2 [ 2 ] , D = arr2 [ 3 ] ; int ans = 0 ; for ( int b = 0 ; b <= B && b * 5 <= ( N ) ; b ++ ) for ( int c = 0 ; c <= C && b * 5 + c * 10 <= ( N ) ; c ++ ) for ( int d = 0 ; d <= D && b * 5 + c * 10 + d * 20 <= ( N ) ; d ++ ) if ( ( b * 5 ) + ( c * 10 ) + ( d * 20 ) >= ( N - A ) ) ans ++ ; return ans ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function nthSquareCube ( n ) { return n * n * n * n * n * n ; }
Ref: 
int nthSquareCube ( int n ) { return n * n * n * n * n * n ; }
Hyp: 
int nthSquareCube ( int n ) { return n * n * n * n * n ; }

BLEU: 90.01
Edit Sim: 4


Src: 
function is_linear ( s ) { let tmp = 0 ; let first = s [ 0 ] ; for ( let pos = 0 ; pos < s . length ; pos += tmp ) { if ( s [ pos ] != first ) { return false ; } tmp ++ ; } return true ; } let str = " " ; if ( is_linear ( str ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
Ref: 
int is_linear ( string s ) { int tmp = 0 ; char first = s [ 0 ] ; for ( int pos = 0 ; pos < s . length ( ) ; pos += tmp ) { if ( s [ pos ] != first ) { return false ; } tmp ++ ; } return true ; }
Hyp: 
bool is_linear ( string s ) { int tmp = 0 ; char first = s [ 0 ] ; for ( int pos = 0 ; pos < s . length ( ) ; pos += tmp ) { if ( s [ pos ] != first ) { return false ; } tmp ++ ; } return true ; }

BLEU: 98.37
Edit Sim: 4


Src: 
function linearCheck ( ar , arr ) { for ( let i = 0 ; i < m ; i ++ ) { let matched = true ; for ( let j = 0 ; j < n ; j ++ ) { if ( ar [ i ] [ j ] != arr [ j ] ) { matched = false ; break ; } } if ( matched ) return i + 1 ; } return - 1 ; }
Ref: 
int linearCheck ( int ar [ ] [ n ] , int arr [ ] ) { for ( int i = 0 ; i < m ; i ++ ) { bool matched = true ; for ( int j = 0 ; j < n ; j ++ ) { if ( ar [ i ] [ j ] != arr [ j ] ) { matched = false ; break ; } } if ( matched ) return i + 1 ; } return -1 ; }
Hyp: 
int linearCheck ( int ar [ ] [ MAX ] , int arr [ MAX ] ) { for ( int i = 0 ; i < m ; i ++ ) { bool matched = true ; for ( int j = 0 ; j < n ; j ++ ) { if ( ar [ i ] [ j ] != arr [ j ] ) { matched = false ; break ; } } if ( matched ) return i + 1 ; } return -1 ; }

BLEU: 94.41
Edit Sim: 7


Src: 
function canFormPalindrome ( a ) { var bitvector = 0 , mask = 0 ; for ( var i = 0 ; i < a . length ; i ++ ) { var x = a . charCodeAt ( i ) - 97 ; mask = 1 << x ; bitvector = bitvector ^ mask ; } return ( ( bitvector & ( bitvector - 1 ) ) == 0 ) ; }
Ref: 
bool canFormPalindrome ( string a ) { int bitvector = 0 , mask = 0 ; for ( int i = 0 ; a [ i ] != ' \0' ; i ++ ) { int x = a [ i ] - ' a ' ; mask = 1 << x ; bitvector = bitvector ^ mask ; } return ( bitvector & ( bitvector - 1 ) ) == 0 ; }
Hyp: 
bool canFormPalindrome ( string a ) { int bitvector = 0 , mask = 0 ; for ( int i = 0 ; i < a . length ( ) ; i ++ ) { int x = a [ i ] - 97 ; mask = 1 << x ; bitvector = bitvector ^ mask ; } return ( ( bitvector & ( bitvector - 1 ) ) == 0 ) ; }

BLEU: 79.92
Edit Sim: 22


Src: 
function countOfPairs ( x , y ) { var count = 0 ; var k ; for ( k = 1 ; k * k <= x ; ++ k ) { count += Math . max ( 0 , Math . min ( y , x / k - 1 ) - k ) ; } document . write ( count + " " ) ; }
Ref: 
void countOfPairs ( int x , int y ) { int count = 0 ; for ( int k = 1 ; k * k <= x ; ++ k ) { count += max ( 0 , min ( y , x / k - 1 ) - k ) ; } cout << count << " STRNEWLINE " ; }
Hyp: 
void countOfPairs ( int x , int y ) { int count = 0 ; int k ; for ( k = 1 ; k * k <= x ; ++ k ) { count += max ( 0 , min ( y , x / k - 1 ) - k ) ; } cout << count << endl ; }

BLEU: 88.36
Edit Sim: 25


Src: 
function pairExists ( arr1 , m , arr2 , n ) { let s = new Set ( ) ; for ( let i = 0 ; i < m ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { if ( s . has ( arr2 [ j ] - arr1 [ i ] ) ) return true ; } s . add ( arr1 [ i ] ) ; } return false ; }
Ref: 
bool pairExists ( int arr1 [ ] , int m , int arr2 [ ] , int n ) { unordered_set < int > s ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( s . find ( arr2 [ j ] - arr1 [ i ] ) != s . end ( ) ) return true ; } s . insert ( arr1 [ i ] ) ; } return false ; }
Hyp: 
bool pairExists ( int arr1 [ ] , int m , int arr2 [ ] , int n ) { unordered_set < int > s ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( s . find ( arr2 [ j ] - arr1 [ i ] ) != s . end ( ) ) return true ; } s . insert ( arr1 [ i ] ) ; } return false ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function checkDistribution ( R , B , D ) { if ( Math . max ( R , B ) <= Math . min ( R , B ) * ( D + 1 ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; } }
Ref: 
void checkDistribution ( int R , int B , int D ) { if ( max ( R , B ) <= min ( R , B ) * ( D + 1 ) ) { cout << " Yes " ; } else { cout << " No " ; } }
Hyp: 
void checkDistribution ( int R , int B , int D ) { if ( max ( R , B ) <= min ( R , B ) * ( D + 1 ) ) { cout << " Yes " ; } else { cout << " No " ; } }

BLEU: 100.0
Edit Sim: 0


Src: 
function maxMinDifference ( arr , n , k ) { if ( k >= n - 1 ) return 0 ; arr . sort ( ( a , b ) => a - b ) ; let ans = arr [ n - 1 ] - arr [ 0 ] ; for ( let i = k , j = n - 1 ; i >= 0 ; -- i , -- j ) { ans = Math . min ( arr [ j ] - arr [ i ] , ans ) ; } return ans ; }
Ref: 
int maxMinDifference ( int arr [ ] , int n , int k ) { if ( k >= n - 1 ) return 0 ; sort ( arr , arr + n ) ; int ans = arr [ n - 1 ] - arr [ 0 ] ; for ( int i = k , j = n - 1 ; i >= 0 ; -- i , -- j ) { ans = min ( arr [ j ] - arr [ i ] , ans ) ; } return ans ; }
Hyp: 
int maxMinDifference ( int arr [ ] , int n , int k ) { if ( k >= n - 1 ) return 0 ; sort ( arr , arr + n ) ; int ans = arr [ n - 1 ] - arr [ 0 ] ; for ( int i = k , j = n - 1 ; i >= 0 ; -- i , -- j ) { ans = min ( arr [ j ] - arr [ i ] , ans ) ; } return ans ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function rangeSum ( arr , N , L , R ) { let sum = 0 ; for ( let i = L - 1 ; i < R ; i ++ ) { sum += arr [ i % N ] ; } document . write ( sum ) ; }
Ref: 
void rangeSum ( int arr [ ] , int N , int L , int R ) { int sum = 0 ; for ( int i = L - 1 ; i < R ; i ++ ) { sum += arr [ i % N ] ; } cout << sum ; }
Hyp: 
void rangeSum ( int arr [ ] , int N , int L , int R ) { int sum = 0 ; for ( int i = L - 1 ; i < R ; i ++ ) { sum += arr [ i % N ] ; } cout << sum ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function smallerNumbers ( arr , N ) { var i ; for ( i = 0 ; i < N ; i ++ ) { var count = 0 ; for ( j = 0 ; j < N ; j ++ ) { if ( arr [ j ] < arr [ i ] ) { count += 1 ; } } document . write ( count + " " ) ; } }
Ref: 
void smallerNumbers ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < N ; j ++ ) { if ( arr [ j ] < arr [ i ] ) { count ++ ; } } cout << count << " ▁ " ; } }
Hyp: 
void smallerNumbers ( int arr [ ] , int N ) { int i ; for ( i = 0 ; i < N ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < N ; j ++ ) { if ( arr [ j ] < arr [ i ] ) { count += 1 ; } } cout << count << " ▁ " ; } }

BLEU: 88.52
Edit Sim: 14


Src: 
function checkIfDivisible ( str , num ) { let powerOf2 = ( Math . log ( num ) / Math . log ( 2 ) ) ; if ( str . length < powerOf2 ) return false ; if ( powerOf2 == 0 ) return true ; let i , number = 0 ; let len = str . length ; for ( i = len - powerOf2 ; i < len ; i ++ ) { number += ( str [ i ] - ' ' ) * Math . pow ( 10 , powerOf2 - 1 ) ; powerOf2 -- ; } if ( number % num != 0 ) return false ; else return true ; }
Ref: 
bool checkIfDivisible ( string str , long long int num ) { long long int powerOf2 = log2 ( num ) ; if ( str . length ( ) < powerOf2 ) return false ; if ( powerOf2 == 0 ) return true ; long long int i , number = 0 ; int len = str . length ( ) ; for ( i = len - powerOf2 ; i < len ; i ++ ) { number += ( str [ i ] - '0' ) * pow ( 10 , powerOf2 - 1 ) ; powerOf2 -- ; } if ( number % num ) return false ; else return true ; }
Hyp: 
bool checkIfDivisible ( string str , int num ) { int powerOf2 = ( log2 ( num ) ) ; if ( str . length ( ) < powerOf2 ) return false ; if ( powerOf2 == 0 ) return true ; int i , number = 0 ; int len = str . length ( ) ; for ( i = len - powerOf2 ; i < len ; i ++ ) { number += ( str [ i ] - '0' ) * pow ( 10 , powerOf2 - 1 ) ; powerOf2 -- ; } if ( number % num != 0 ) return false ; else return true ; }

BLEU: 87.42
Edit Sim: 39


Src: 
function anglechordtang ( z ) { document . write ( " " + " " + z + " " ) ; }
Ref: 
void anglechordtang ( int z ) { cout << " The ▁ angle ▁ between ▁ tangent " << " ▁ and ▁ the ▁ chord ▁ is ▁ " << z << " ▁ degrees " << endl ; }
Hyp: 
void anglechordtang ( int z ) { cout << " The ▁ angle ▁ of ▁ the ▁ circle ▁ is ▁ " << z << " ▁ degrees " << endl ; }

BLEU: 68.8
Edit Sim: 35


Src: 
function minimumSets ( s , y ) { let cnt = 0 ; let num = 0 ; let l = s . length ; let f = false ; for ( let i = 0 ; i < l ; i ++ ) { num = num * 10 + ( s [ i ] - ' ' ) ; if ( num <= y ) f = true ; { if ( f ) cnt += 1 ; num = s [ i ] - ' ' ; f = false ; if ( num <= y ) f = true ; else num = 0 ; } } if ( f == true ) cnt += 1 ; return cnt ; }
Ref: 
int minimumSets ( string s , int y ) { int cnt = 0 ; int num = 0 ; int l = s . length ( ) ; int f = 0 ; for ( int i = 0 ; i < l ; i ++ ) { num = num * 10 + ( s [ i ] - '0' ) ; if ( num <= y ) f = 1 ; { if ( f ) cnt += 1 ; num = s [ i ] - '0' ; f = 0 ; if ( num <= y ) f = 1 ; else num = 0 ; } } if ( f ) cnt += 1 ; return cnt ; }
Hyp: 
int minimumSets ( string s , int y ) { int cnt = 0 ; int num = 0 ; int l = s . length ( ) ; bool f = false ; for ( int i = 0 ; i < l ; i ++ ) { num = num * 10 + ( s [ i ] - '0' ) ; if ( num <= y ) f = true ; { if ( f ) cnt += 1 ; num = s [ i ] - '0' ; f = false ; if ( num <= y ) f = true ; else num = 0 ; } } if ( f == true ) cnt += 1 ; return cnt ; }

BLEU: 87.35
Edit Sim: 30


Src: 
function checkRectangles ( arr , n ) { let ans = true ; arr . sort ( ) ; var area = arr [ 0 ] * arr [ 4 * n - 1 ] ; for ( let i = 0 ; i < 2 * n ; i = i + 2 ) { if ( arr [ i ] != arr [ i + 1 ] arr [ 4 * n - i - 1 ] != arr [ 4 * n - i - 2 ] arr [ i ] * arr [ 4 * n - i - 1 ] != area ) { ans = false ; break ; } } if ( ans ) return true ; return false ; }
Ref: 
bool checkRectangles ( int * arr , int n ) { bool ans = true ; sort ( arr , arr + 4 * n ) ; int area = arr [ 0 ] * arr [ 4 * n - 1 ] ; for ( int i = 0 ; i < 2 * n ; i = i + 2 ) { if ( arr [ i ] != arr [ i + 1 ] arr [ 4 * n - i - 1 ] != arr [ 4 * n - i - 2 ] arr [ i ] * arr [ 4 * n - i - 1 ] != area ) { ans = false ; break ; } } if ( ans ) return true ; return false ; }
Hyp: 
bool checkRectangles ( int arr [ ] , int n ) { bool ans = true ; sort ( arr , arr + n ) ; int area = arr [ 0 ] * arr [ 4 * n - 1 ] ; for ( int i = 0 ; i < 2 * n ; i = i + 2 ) { if ( arr [ i ] != arr [ i + 1 ] arr [ 4 * n - i - 1 ] != arr [ 4 * n - i - 2 ] arr [ i ] * arr [ 4 * n - i - 1 ] != area ) { ans = false ; break ; } } if ( ans ) return true ; return false ; }

BLEU: 94.98
Edit Sim: 10


Src: 
function countRabbits ( Heads , Legs ) { var count = 0 ; count = ( Legs ) - 2 * ( Heads ) ; count = count / 2 ; return count ; }
Ref: 
int countRabbits ( int Heads , int Legs ) { int count = 0 ; count = ( Legs ) -2 * ( Heads ) ; count = count / 2 ; return count ; }
Hyp: 
int countRabbits ( int Heads , int Legs ) { int count = 0 ; count = ( Legs ) - 2 * ( Heads ) ; count = count / 2 ; return count ; }

BLEU: 90.25
Edit Sim: 1


Src: 
function get_last_two_digit ( N ) { if ( N <= 10 ) { let ans = 0 , fac = 1 ; for ( let i = 1 ; i <= N ; i ++ ) { fac = fac * i ; ans += fac ; } return ans % 100 ; } return 13 ; }
Ref: 
int get_last_two_digit ( long long int N ) { if ( N <= 10 ) { ll ans = 0 , fac = 1 ; for ( int i = 1 ; i <= N ; i ++ ) { fac = fac * i ; ans += fac ; } return ans % 100 ; } return 13 ; }
Hyp: 
int get_last_two_digit ( int N ) { if ( N <= 10 ) { int ans = 0 , fac = 1 ; for ( int i = 1 ; i <= N ; i ++ ) { fac = fac * i ; ans += fac ; } return ans % 100 ; } return 13 ; }

BLEU: 89.9
Edit Sim: 13


Src: 
function maxBalancedStr ( s ) { var open1 = 0 , close1 = 0 ; var open2 = 0 , close2 = 0 ; var open3 = 0 , close3 = 0 ; for ( i = 0 ; i < s . length ; i ++ ) { switch ( s . charAt ( i ) ) { case ' ' : open1 ++ ; break ; case ' ' : close1 ++ ; break ; case ' ' : open2 ++ ; break ; case ' ' : close2 ++ ; break ; case ' ' : open3 ++ ; break ; case ' ' : close3 ++ ; break ; } } var maxLen = 2 * Math . min ( open1 , close1 ) + 2 * Math . min ( open2 , close2 ) + 2 * Math . min ( open3 , close3 ) ; return maxLen ; }
Ref: 
int maxBalancedStr ( string s ) { int open1 = 0 , close1 = 0 ; int open2 = 0 , close2 = 0 ; int open3 = 0 , close3 = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { switch ( s [ i ] ) { case ' ( ' : open1 ++ ; break ; case ' ) ' : close1 ++ ; break ; case ' { ' : open2 ++ ; break ; case ' } ' : close2 ++ ; break ; case ' [ ' : open3 ++ ; break ; case ' ] ' : close3 ++ ; break ; } } int maxLen = 2 * min ( open1 , close1 ) + 2 * min ( open2 , close2 ) + 2 * min ( open3 , close3 ) ; return maxLen ; }
Hyp: 
int maxBalancedStr ( string s ) { int open1 = 0 , close1 = 0 ; int open2 = 0 , close2 = 0 ; int open3 = 0 , close3 = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { switch ( s [ i ] ) { case ' a ' : open1 ++ ; break ; case ' e ' : close1 ++ ; break ; case ' i ' : open2 ++ ; break ; case ' e ' : close2 ++ ; break ; case ' o ' : open3 ++ ; break ; case ' u ' : close3 ++ ; break ; } } int maxLen = 2 * min ( open1 , close1 ) + 2 * min ( open2 , close2 ) + 2 * min ( open3 , close3 ) ; return maxLen ; }

BLEU: 90.28
Edit Sim: 6


Src: 
function calculateArea ( A , B , C , D ) { let S = ( A + B + C + D ) / 2 let area = Math . sqrt ( ( S - A ) * ( S - B ) * ( S - C ) * ( S - D ) ) return area ; }
Ref: 
float calculateArea ( float A , float B , float C , float D ) { float S = ( A + B + C + D ) / 2 ; float area = sqrt ( ( S - A ) * ( S - B ) * ( S - C ) * ( S - D ) ) ; return area ; }
Hyp: 
double calculateArea ( int A , int B , int C , int D ) { int S = ( A + B + C + D ) / 2 ; double area = sqrt ( ( S - A ) * ( S - B ) * ( S - C ) * ( S - D ) ) ; return area ; }

BLEU: 76.09
Edit Sim: 32


Src: 
function findNthNumber ( A , B , N ) { var sum = 0 ; for ( i = 2 ; i < N ; i ++ ) { sum = A + B ; A = B ; B = sum ; } return sum ; }
Ref: 
int findNthNumber ( int A , int B , int N ) { int sum = 0 ; for ( int i = 2 ; i < N ; i ++ ) { sum = A + B ; A = B ; B = sum ; } return sum ; }
Hyp: 
int findNthNumber ( int A , int B , int N ) { int sum = 0 ; for ( int i = 2 ; i < N ; i ++ ) { sum = A + B ; A = B ; B = sum ; } return sum ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function binToDecimal3 ( n ) { var last_3 = ( ( n & 4 ) + ( n & 2 ) + ( n & 1 ) ) ; n = n >> 3 ; while ( n > 7 ) n = n >> 1 ; var first_3 = ( ( n & 4 ) + ( n & 2 ) + ( n & 1 ) ) ; document . write ( first_3 + " " + last_3 ) ; }
Ref: 
void binToDecimal3 ( int n ) { int last_3 = ( ( n & 4 ) + ( n & 2 ) + ( n & 1 ) ) ; n = n >> 3 ; while ( n > 7 ) n = n >> 1 ; int first_3 = ( ( n & 4 ) + ( n & 2 ) + ( n & 1 ) ) ; cout << first_3 << " ▁ " << last_3 ; }
Hyp: 
void binToDecimal3 ( int n ) { int last_3 = ( ( n & 4 ) + ( n & 2 ) + ( n & 1 ) ) ; n = n >> 3 ; while ( n > 7 ) n = n >> 1 ; int first_3 = ( ( n & 4 ) + ( n & 2 ) + ( n & 1 ) ) ; cout << first_3 << " ▁ " << last_3 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function floorDifference ( A , N , X ) { let totalSum = 0 ; let perElementSum = 0 ; for ( let i = 0 ; i < N ; i ++ ) { totalSum += A [ i ] ; perElementSum += Math . floor ( A [ i ] / X ) ; } let totalFloorSum = Math . floor ( totalSum / X ) ; return Math . abs ( totalFloorSum - perElementSum ) ; }
Ref: 
int floorDifference ( int A [ ] , int N , int X ) { int totalSum = 0 ; int perElementSum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { totalSum += A [ i ] ; perElementSum += A [ i ] / X ; } int totalFloorSum = totalSum / X ; return abs ( totalFloorSum - perElementSum ) ; }
Hyp: 
int floorDifference ( int A [ ] , int N , int X ) { int totalSum = 0 ; int perElementSum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { totalSum += A [ i ] ; perElementSum += A [ i ] / X ; } int totalFloorSum = floor ( totalSum / X ) ; return abs ( totalFloorSum - perElementSum ) ; }

BLEU: 91.96
Edit Sim: 10


Src: 
function minimumIncrease ( a , b , c ) { var arr = [ a , b , c ] ; arr . sort ( ( a , b ) => a - b ) ; if ( arr [ 0 ] + arr [ 1 ] >= arr [ 2 ] ) return 0 ; else return arr [ 2 ] - ( arr [ 0 ] + arr [ 1 ] ) ; }
Ref: 
int minimumIncrease ( int a , int b , int c ) { int arr [ ] = { a , b , c } ; sort ( arr , arr + 3 ) ; if ( arr [ 0 ] + arr [ 1 ] >= arr [ 2 ] ) return 0 ; else return arr [ 2 ] - ( arr [ 0 ] + arr [ 1 ] ) ; }
Hyp: 
int minimumIncrease ( int a , int b , int c ) { int arr [ 3 ] = { a , b , c } ; sort ( arr , arr + 3 ) ; if ( arr [ 0 ] + arr [ 1 ] >= arr [ 2 ] ) return 0 ; else return arr [ 2 ] - ( arr [ 0 ] + arr [ 1 ] ) ; }

BLEU: 96.65
Edit Sim: 2


Src: 
function search ( pat , txt ) { let M = pat . length ; let N = txt . length ; let i = 0 ; while ( i <= N - M ) { let j ; for ( j = 0 ; j < M ; j ++ ) if ( txt [ i + j ] != pat [ j ] ) break ; if ( j == M ) { document . write ( " " + i + " " ) ; i = i + M ; } else if ( j == 0 ) i = i + 1 ; else i = i + j ; } }
Ref: 
void search ( string pat , string txt ) { int M = pat . size ( ) ; int N = txt . size ( ) ; int i = 0 ; while ( i <= N - M ) { int j ; for ( j = 0 ; j < M ; j ++ ) if ( txt [ i + j ] != pat [ j ] ) break ; if ( j == M ) { cout << " Pattern ▁ found ▁ at ▁ index ▁ " << i << endl ; i = i + M ; } else if ( j == 0 ) i = i + 1 ; else i = i + j ; } }
Hyp: 
int search ( string pat , string txt ) { int M = pat . length ( ) ; int N = txt . length ( ) ; int i = 0 ; while ( i <= N - M ) { int j ; for ( j = 0 ; j < M ; j ++ ) if ( txt [ i + j ] != pat [ j ] ) break ; if ( j == M ) { cout << " Not ▁ Found " << i << " ▁ " ; i = i + M ; } else if ( j == 0 ) i = i + 1 ; else i = i + j ; } }

BLEU: 86.2
Edit Sim: 43


Src: 
function checkEquall ( arr , N ) { let sumEven = 0 , sumOdd = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( i % 2 == 1 ) sumOdd += arr [ i ] ; else sumEven += arr [ i ] ; } if ( sumEven == sumOdd ) return true ; else return false ; }
Ref: 
bool checkEquall ( int arr [ ] , int N ) { int sumEven = 0 , sumOdd = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( i & 1 ) sumOdd += arr [ i ] ; else sumEven += arr [ i ] ; } if ( sumEven == sumOdd ) return true ; else return false ; }
Hyp: 
bool checkEquall ( int arr [ ] , int N ) { int sumEven = 0 , sumOdd = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( i % 2 == 1 ) sumOdd += arr [ i ] ; else sumEven += arr [ i ] ; } if ( sumEven == sumOdd ) return true ; else return false ; }

BLEU: 93.84
Edit Sim: 6


Src: 
function sortExceptUandL ( a , l , u , n ) { let b = [ ] ; for ( let i = 0 ; i < l ; i ++ ) b [ i ] = a [ i ] ; for ( let i = u + 1 ; i < n ; i ++ ) b [ l + ( i - ( u + 1 ) ) ] = a [ i ] ; b . sort ( ) ; for ( let i = 0 ; i < l ; i ++ ) a [ i ] = b [ i ] ; for ( let i = u + 1 ; i < n ; i ++ ) a [ i ] = b [ l + ( i - ( u + 1 ) ) ] ; }
Ref: 
void sortExceptUandL ( int a [ ] , int l , int u , int n ) { int b [ n - ( u - l + 1 ) ] ; for ( int i = 0 ; i < l ; i ++ ) b [ i ] = a [ i ] ; for ( int i = u + 1 ; i < n ; i ++ ) b [ l + ( i - ( u + 1 ) ) ] = a [ i ] ; sort ( b , b + n - ( u - l + 1 ) ) ; for ( int i = 0 ; i < l ; i ++ ) a [ i ] = b [ i ] ; for ( int i = u + 1 ; i < n ; i ++ ) a [ i ] = b [ l + ( i - ( u + 1 ) ) ] ; }
Hyp: 
void sortExceptUandL ( int a [ ] , int l , int u , int n ) { vector < int > b ; for ( int i = 0 ; i < l ; i ++ ) b [ i ] = a [ i ] ; for ( int i = u + 1 ; i < n ; i ++ ) b [ l + ( i - ( u + 1 ) ) ] = a [ i ] ; sort ( b . begin ( ) , b . end ( ) ) ; for ( int i = 0 ; i < l ; i ++ ) a [ i ] = b [ i ] ; for ( int i = u + 1 ; i < n ; i ++ ) a [ i ] = b [ l + ( i - ( u + 1 ) ) ] ; }

BLEU: 85.04
Edit Sim: 36


Src: 
function checkPronic ( x ) { for ( var i = 0 ; i <= parseInt ( Math . sqrt ( x ) ) ; i ++ ) if ( x == i * ( i + 1 ) ) return true ; return false ; }
Ref: 
bool checkPronic ( int x ) { for ( int i = 0 ; i <= ( int ) ( sqrt ( x ) ) ; i ++ ) if ( x == i * ( i + 1 ) ) return true ; return false ; }
Hyp: 
bool checkPronic ( int x ) { for ( int i = 0 ; i <= sqrt ( x ) ; i ++ ) if ( x == i * ( i + 1 ) ) return true ; return false ; }

BLEU: 84.1
Edit Sim: 12


Src: 
function solve ( arr , n , X , Y ) { var diff = Y - X ; for ( var i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != 1 ) { diff = diff % ( arr [ i ] - 1 ) ; } } if ( diff == 0 ) document . write ( " " ) ; else document . write ( " " ) ; }
Ref: 
void solve ( int arr [ ] , int n , int X , int Y ) { int diff = Y - X ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != 1 ) { diff = diff % ( arr [ i ] - 1 ) ; } } if ( diff == 0 ) cout << " Yes " ; else cout << " No " ; }
Hyp: 
void solve ( int arr [ ] , int n , int X , int Y ) { int diff = Y - X ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != 1 ) { diff = diff % ( arr [ i ] - 1 ) ; } } if ( diff == 0 ) cout << " Yes " ; else cout << " No " ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function check ( n ) { var digits = new Set ( ) ; var temp = n ; var sum = 0 ; var count = 0 ; while ( temp > 0 ) { sum += temp % 10 ; digits . add ( temp % 10 ) ; count ++ ; temp = parseInt ( temp / 10 ) ; } if ( sum % count == 0 && digits . has ( sum / count ) ) document . write ( " " ) ; else document . write ( " " ) ; }
Ref: 
void check ( int n ) { set < int > digits ; int temp = n ; int sum = 0 ; int count = 0 ; while ( temp > 0 ) { sum += temp % 10 ; digits . insert ( temp % 10 ) ; count ++ ; temp = temp / 10 ; } if ( sum % count == 0 && digits . find ( sum / count ) != digits . end ( ) ) cout << " Yes " << endl ; else cout << " No " << endl ; }
Hyp: 
void check ( int n ) { set < int > digits ; int temp = n , sum = 0 , count = 0 ; while ( temp > 0 ) { sum += temp % 10 ; digits . insert ( temp % 10 ) ; count ++ ; temp = temp / 10 ; } if ( sum % count == 0 && digits . find ( sum / count ) != digits . end ( ) ) cout << " Yes " ; else cout << " No " ; }

BLEU: 86.03
Edit Sim: 26


Src: 
function findS ( s ) { var l = 1 , r = parseInt ( ( s / 2 ) + 1 ) ; while ( l <= r ) { var mid = parseInt ( ( l + r ) / 2 ) ; var sum = mid * parseInt ( ( mid + 1 ) / 2 ) ; if ( sum == s ) return mid ; else if ( sum > s ) r = mid - 1 ; else l = mid + 1 ; } return - 1 ; }
Ref: 
int findS ( int s ) { int l = 1 , r = ( s / 2 ) + 1 ; while ( l <= r ) { int mid = ( l + r ) / 2 ; int sum = mid * ( mid + 1 ) / 2 ; if ( sum == s ) return mid ; else if ( sum > s ) r = mid - 1 ; else l = mid + 1 ; } return -1 ; }
Hyp: 
int findS ( int s ) { int l = 1 , r = ( s / 2 ) + 1 ; while ( l <= r ) { int mid = ( l + r ) / 2 ; int sum = mid * ( mid + 1 ) / 2 ; if ( sum == s ) return mid ; else if ( sum > s ) r = mid - 1 ; else l = mid + 1 ; } return -1 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function string ( l , x , y ) { var p = 97 ; for ( var j = 0 ; j < l ; j ++ ) { var ans = String . fromCharCode ( p + ( j % y ) ) ; document . write ( ans ) ; } }
Ref: 
void String ( int l , int x , int y ) { int p = 97 ; for ( int j = 0 ; j < l ; j ++ ) { char ans = ( char ) ( p + ( j % y ) ) ; cout << ans ; } }
Hyp: 
void string ( int l , int x , int y ) { int p = 97 ; for ( int j = 0 ; j < l ; j ++ ) { char ans = ( char ) p + ( j % y ) ; cout << ans ; } }

BLEU: 88.77
Edit Sim: 5


Src: 
function prevGreater ( arr , n ) { let s = [ ] ; s . push ( arr [ 0 ] ) ; document . write ( " " ) ; for ( let i = 1 ; i < n ; i ++ ) { while ( s . length != 0 && s [ s . length - 1 ] < arr [ i ] ) s . pop ( ) ; if ( s . length == 0 ) document . write ( " " ) ; else document . write ( s [ s . length - 1 ] + " " ) ; s . push ( arr [ i ] ) ; } }
Ref: 
void prevGreater ( int arr [ ] , int n ) { stack < int > s ; s . push ( arr [ 0 ] ) ; cout << " - 1 , ▁ " ; for ( int i = 1 ; i < n ; i ++ ) { while ( s . empty ( ) == false && s . top ( ) < arr [ i ] ) s . pop ( ) ; s . empty ( ) ? cout << " - 1 , ▁ " : cout << s . top ( ) << " , ▁ " ; s . push ( arr [ i ] ) ; } }
Hyp: 
void prevGreater ( int arr [ ] , int n ) { stack < int > s ; s . push ( arr [ 0 ] ) ; cout << " - 1 , ▁ " ; for ( int i = 1 ; i < n ; i ++ ) { while ( ! s . empty ( ) && s . top ( ) < arr [ i ] ) s . pop ( ) ; if ( s . size ( ) == 0 ) cout << " - 1 , ▁ " ; else cout << s [ s . size ( ) - 1 ] << " , ▁ " ; s . push ( arr [ i ] ) ; } }

BLEU: 79.63
Edit Sim: 47


Src: 
function bs ( ar , n , ele ) { let start = 0 ; let end = n - 1 ; let ch = ' ' ; while ( start <= end ) { let mid = start + Math . floor ( ( end - start ) / 2 ) ; if ( ar [ mid ] == ele ) end = mid - 1 ; else if ( ar [ mid ] < ele ) { ch = ar [ mid ] ; start = mid + 1 ; } else end = mid - 1 ; } return ch ; }
Ref: 
char bs ( char ar [ ] , int n , int ele ) { int start = 0 ; int end = n - 1 ; char ch = ' @ ' ; while ( start <= end ) { int mid = start + ( end - start ) / 2 ; if ( ar [ mid ] == ele ) end = mid - 1 ; else if ( ar [ mid ] < ele ) { ch = ar [ mid ] ; start = mid + 1 ; } else end = mid - 1 ; } return ch ; }
Hyp: 
char bs ( char ar [ ] , int n , int ele ) { int start = 0 ; int end = n - 1 ; char ch = ' ' ; while ( start <= end ) { int mid = start + ( end - start ) / 2 ; if ( ar [ mid ] == ele ) end = mid - 1 ; else if ( ar [ mid ] < ele ) { ch = ar [ mid ] ; start = mid + 1 ; } else end = mid - 1 ; } return ch ; }

BLEU: 97.61
Edit Sim: 2


Src: 
function findCountOfPairs ( a , b , n ) { let ans = 0 ; for ( let i = 1 ; i <= a ; i ++ ) { ans += parseInt ( b / n , 10 ) ; ans += ( i % n + b % n ) >= n ? 1 : 0 ; } return ans ; }
Ref: 
int findCountOfPairs ( int a , int b , int n ) { int ans = 0 ; for ( int i = 1 ; i <= a ; i ++ ) { ans += b / n ; ans += ( i % n + b % n ) >= n ? 1 : 0 ; } return ans ; }
Hyp: 
int findCountOfPairs ( int a , int b , int n ) { int ans = 0 ; for ( int i = 1 ; i <= a ; i ++ ) { ans += ( b / n ) ; ans += ( i % n + b % n ) >= n ? 1 : 0 ; } return ans ; }

BLEU: 91.99
Edit Sim: 4


Src: 
function hexagonside ( a ) { if ( a < 0 ) return - 1 ; var x = a / 3 ; return x ; }
Ref: 
float hexagonside ( float a ) { if ( a < 0 ) return -1 ; float x = a / 3 ; return x ; }
Hyp: 
float hexagonside ( float a ) { if ( a < 0 ) return -1 ; float x = a / 3 ; return x ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function nDigitPerfectSquares ( n , b ) { var largest = Math . pow ( Math . ceil ( Math . sqrt ( Math . pow ( b , n ) ) ) - 1 , 2 ) ; document . write ( largest ) ; }
Ref: 
void nDigitPerfectSquares ( int n , int b ) { int largest = pow ( ceil ( sqrt ( pow ( b , n ) ) ) - 1 , 2 ) ; cout << largest ; }
Hyp: 
void nDigitPerfectSquares ( int n , int b ) { double largest = pow ( ceil ( sqrt ( pow ( b , n ) ) ) - 1 , 2 ) ; cout << largest ; }

BLEU: 93.18
Edit Sim: 6


Src: 
function countRect ( n ) { let ans = 0 ; for ( let length = 1 ; length <= parseInt ( Math . sqrt ( n ) , 10 ) ; ++ length ) for ( let height = length ; height * length <= n ; ++ height ) ans ++ ; return ans ; }
Ref: 
int countRect ( int n ) { int ans = 0 ; for ( int length = 1 ; length <= sqrt ( n ) ; ++ length ) for ( int height = length ; height * length <= n ; ++ height ) ans ++ ; return ans ; }
Hyp: 
int countRect ( int n ) { int ans = 0 ; for ( int length = 1 ; length <= sqrt ( n ) ; ++ length ) for ( int height = length ; height * length <= n ; ++ height ) ans ++ ; return ans ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countSwaps ( A , n ) { var mp = new Map ( ) ; var max_frequency = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( mp . has ( A [ i ] ) ) mp . set ( A [ i ] , mp . get ( A [ i ] ) + 1 ) else mp . set ( A [ i ] , 1 ) ; max_frequency = Math . max ( max_frequency , mp . get ( A [ i ] ) ) ; } return n - max_frequency ; }
Ref: 
int countSwaps ( int A [ ] , int n ) { map < int , int > mp ; int max_frequency = 0 ; for ( int i = 0 ; i < n ; i ++ ) { mp [ A [ i ] ] ++ ; max_frequency = max ( max_frequency , mp [ A [ i ] ] ) ; } return n - max_frequency ; }
Hyp: 
int countSwaps ( int A [ ] , int n ) { unordered_map < int , int > mp ; int max_frequency = 0 ; for ( int i = 0 ; i < n ; i ++ ) { mp [ A [ i ] ] ++ ; max_frequency = max ( max_frequency , mp [ A [ i ] ] ) ; } return n - max_frequency ; }

BLEU: 96.41
Edit Sim: 10


Src: 
function sum ( m , n ) { return 8 * m * n - 6 * m - 6 * n + 4 ; }
Ref: 
int sum ( int m , int n ) { return 8 * m * n - 6 * m - 6 * n + 4 ; }
Hyp: 
int sum ( int m , int n ) { return 8 * m * n - 6 * m - 6 * n + 4 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function printNumber ( holes ) { if ( holes == 0 ) document . write ( " " ) ; else if ( holes == 1 ) document . write ( " " ) ; else { let rem = 0 , quo = 0 ; rem = holes % 2 ; quo = parseInt ( holes / 2 , 10 ) ; if ( rem == 1 ) document . write ( " " ) ; for ( let i = 0 ; i < quo ; i ++ ) document . write ( " " ) ; } }
Ref: 
void printNumber ( int holes ) { if ( holes == 0 ) cout << "1" ; else if ( holes == 1 ) cout << "0" ; else { int rem = 0 , quo = 0 ; rem = holes % 2 ; quo = holes / 2 ; if ( rem == 1 ) cout << "4" ; for ( int i = 0 ; i < quo ; i ++ ) cout << "8" ; } }
Hyp: 
void printNumber ( int holes ) { if ( holes == 0 ) cout << " No " ; else if ( holes == 1 ) cout << " Yes " ; else { int rem = 0 , quo = 0 ; rem = holes % 2 ; quo = holes / 2 ; if ( rem == 1 ) cout << " Yes " ; for ( int i = 0 ; i < quo ; i ++ ) cout << " ▁ " ; } }

BLEU: 79.42
Edit Sim: 17


Src: 
function Reverseorder ( n ) { let prime = new Array ( n + 1 ) ; for ( let i = 0 ; i < n ; i ++ ) prime [ i ] = true ; for ( let p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( let i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } for ( let p = n ; p >= 2 ; p -- ) if ( prime [ p ] ) document . write ( p + " " ) ; }
Ref: 
void Reverseorder ( int n ) { bool prime [ n + 1 ] ; memset ( prime , true , sizeof ( prime ) ) ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } for ( int p = n ; p >= 2 ; p -- ) if ( prime [ p ] ) cout << p << " ▁ " ; }
Hyp: 
void Reverseorder ( int n ) { bool prime [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) prime [ i ] = true ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } for ( int p = n ; p >= 2 ; p -- ) if ( prime [ p ] ) cout << p << " ▁ " ; }

BLEU: 82.64
Edit Sim: 37


Src: 
function printSeriesSum ( N ) { let sum = 0 ; for ( let i = 1 ; i <= N ; i ++ ) { if ( i & 1 ) { sum += i / ( i + 1 ) ; } else { sum -= i / ( i + 1 ) ; } } document . write ( sum . toFixed ( 6 ) ) ; }
Ref: 
void printSeriesSum ( int N ) { double sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( i & 1 ) { sum += ( double ) i / ( i + 1 ) ; } else { sum -= ( double ) i / ( i + 1 ) ; } } cout << sum << endl ; }
Hyp: 
void printSeriesSum ( int N ) { double sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( i & 1 ) { sum += i / ( i + 1 ) ; } else { sum -= i / ( i + 1 ) ; } } cout << sum ; }

BLEU: 82.16
Edit Sim: 30


Src: 
function findOddPair ( A , N ) { let count = 0 ; for ( let i = 0 ; i < N ; i ++ ) if ( ( A [ i ] % 2 == 1 ) ) count ++ ; return count * ( count - 1 ) / 2 ; }
Ref: 
int findOddPair ( int A [ ] , int N ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( ( A [ i ] % 2 == 1 ) ) count ++ ; return count * ( count - 1 ) / 2 ; }
Hyp: 
int findOddPair ( int A [ ] , int N ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( ( A [ i ] % 2 == 1 ) ) count ++ ; return count * ( count - 1 ) / 2 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function sum ( a , b ) { var sum = 0 ; for ( var i = 1 ; i <= Math . min ( a , b ) ; i ++ ) if ( a % i == 0 && b % i == 0 ) sum += i ; return sum ; }
Ref: 
int sum ( int a , int b ) { int sum = 0 ; for ( int i = 1 ; i <= min ( a , b ) ; i ++ ) if ( a % i == 0 && b % i == 0 ) sum += i ; return sum ; }
Hyp: 
int sum ( int a , int b ) { int sum = 0 ; for ( int i = 1 ; i <= min ( a , b ) ; i ++ ) if ( a % i == 0 && b % i == 0 ) sum += i ; return sum ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function summation ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) sum += ( i * i ) ; return sum ; }
Ref: 
int summation ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += ( i * i ) ; return sum ; }
Hyp: 
int summation ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += ( i * i ) ; return sum ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countPermutations ( N ) { let adj = [ ] ; for ( let i = 0 ; i < 105 ; i ++ ) adj . push ( [ ] ) ; let indeg = 0 ; for ( let i = 1 ; i <= N ; i ++ ) { for ( let j = 1 ; j <= N ; j ++ ) { if ( i == j ) continue ; let sum = i + j ; if ( Math . ceil ( Math . sqrt ( sum ) ) == Math . floor ( Math . sqrt ( sum ) ) ) { adj [ i ] . push ( j ) ; } } if ( adj [ i ] . length == 1 ) indeg ++ ; } if ( indeg == 0 ) return N ; else if ( indeg <= 2 ) return 2 ; else return 0 ; }
Ref: 
int countPermutations ( int N ) { vector < vector < int > > adj ( 105 ) ; int indeg = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 1 ; j <= N ; j ++ ) { if ( i == j ) continue ; int sum = i + j ; if ( ceil ( sqrt ( sum ) ) == floor ( sqrt ( sum ) ) ) { adj [ i ] . push_back ( j ) ; } } if ( adj [ i ] . size ( ) == 1 ) indeg ++ ; } if ( indeg == 0 ) return N ; else if ( indeg <= 2 ) return 2 ; else return 0 ; }
Hyp: 
int countPermutations ( int N ) { vector < vector < int > > adj ; for ( int i = 0 ; i < 105 ; i ++ ) adj . push_back ( [ ] ) ; int indeg = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 1 ; j <= N ; j ++ ) { if ( i == j ) continue ; int sum = i + j ; if ( ceil ( sqrt ( sum ) ) == floor ( sqrt ( sum ) ) ) { adj [ i ] . push_back ( j ) ; } } if ( adj [ i ] . size ( ) == 1 ) indeg ++ ; } if ( indeg == 0 ) return N ; else if ( indeg <= 2 ) return 2 ; else return 0 ; }

BLEU: 86.19
Edit Sim: 53


Src: 
function multiplyBySevenByEight ( n ) { return ( n - ( n >> 3 ) ) ; }
Ref: 
int multiplyBySevenByEight ( int n ) { return ( n - ( n >> 3 ) ) ; }
Hyp: 
int multiplyBySevenByEight ( int n ) { return ( n - ( n >> 3 ) ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function printSubstrings ( n ) { var s = parseInt ( Math . log10 ( n ) ) ; var d = parseInt ( ( Math . pow ( 10 , s ) + 0.5 ) ) ; var k = d ; while ( n > 0 ) { while ( d > 0 ) { document . write ( parseInt ( n / d ) + " " ) ; d = parseInt ( d / 10 ) ; } n = n % k ; k = parseInt ( k / 10 ) ; d = k ; } }
Ref: 
void printSubstrings ( int n ) { int s = log10 ( n ) ; int d = ( int ) ( pow ( 10 , s ) + 0.5 ) ; int k = d ; while ( n ) { while ( d ) { cout << n / d << endl ; d = d / 10 ; } n = n % k ; k = k / 10 ; d = k ; } }
Hyp: 
void printSubstrings ( int n ) { int s = log10 ( n ) ; double d = pow ( 10 , s ) + 0.5 ; int k = d ; while ( n > 0 ) { while ( d > 0 ) { cout << n / d << " ▁ " ; d = d / 10 ; } n = n % k ; k = k / 10 ; d = k ; } }

BLEU: 78.65
Edit Sim: 29


Src: 
function minimumDifference ( N ) { var sum1 = ( 1 << N ) , sum2 = 0 ; for ( i = 1 ; i < N / 2 ; i ++ ) sum1 += ( 1 << i ) ; for ( i = N / 2 ; i < N ; i ++ ) sum2 += ( 1 << i ) ; document . write ( sum1 - sum2 ) ; }
Ref: 
void minimumDifference ( int N ) { int sum1 = ( 1 << N ) , sum2 = 0 ; for ( int i = 1 ; i < N / 2 ; i ++ ) sum1 += ( 1 << i ) ; for ( int i = N / 2 ; i < N ; i ++ ) sum2 += ( 1 << i ) ; cout << sum1 - sum2 ; }
Hyp: 
void minimumDifference ( int N ) { int sum1 = ( 1 << N ) , sum2 = 0 ; for ( int i = 1 ; i < N / 2 ; i ++ ) sum1 += ( 1 << i ) ; for ( int i = N / 2 ; i < N ; i ++ ) sum2 += ( 1 << i ) ; cout << sum1 - sum2 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function printbinomial ( max ) { for ( let m = 0 ; m <= max ; m ++ ) { document . write ( m ) ; let binom = 1 ; for ( let x = 0 ; x <= m ; x ++ ) { if ( m != 0 && x != 0 ) binom = binom * ( m - x + 1 ) / x ; document . write ( " " + binom + " " ) ; } document . write ( " " ) ; } }
Ref: 
int printbinomial ( int max ) { for ( int m = 0 ; m <= max ; m ++ ) { printf ( " % 2d " , m ) ; int binom = 1 ; for ( int x = 0 ; x <= m ; x ++ ) { if ( m != 0 && x != 0 ) binom = binom * ( m - x + 1 ) / x ; printf ( " % 4d " , binom ) ; } printf ( " STRNEWLINE " ) ; } }
Hyp: 
void printbinomial ( int max ) { for ( int m = 0 ; m <= max ; m ++ ) { cout << m ; int binom = 1 ; for ( int x = 0 ; x <= m ; x ++ ) { if ( m != 0 && x != 0 ) binom = binom * ( m - x + 1 ) / x ; cout << " ( " << binom << " ) " ; } cout << endl ; } }

BLEU: 71.43
Edit Sim: 62


Src: 
function countSubArrayWithOddProduct ( A , N ) { var count = 0 ; var last = - 1 ; var K = 0 ; for ( var i = 0 ; i < N ; i ++ ) { if ( A [ i ] % 2 == 0 ) { K = ( i - last - 1 ) ; count += ( K * ( K + 1 ) / 2 ) ; last = i ; } } K = ( N - last - 1 ) ; count += ( K * ( K + 1 ) / 2 ) ; return count ; }
Ref: 
int countSubArrayWithOddProduct ( int * A , int N ) { int count = 0 ; int last = -1 ; int K = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( A [ i ] % 2 == 0 ) { K = ( i - last - 1 ) ; count += ( K * ( K + 1 ) / 2 ) ; last = i ; } } K = ( N - last - 1 ) ; count += ( K * ( K + 1 ) / 2 ) ; return count ; }
Hyp: 
int countSubArrayWithOddProduct ( int A [ ] , int N ) { int count = 0 ; int last = -1 ; int K = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( A [ i ] % 2 == 0 ) { K = ( i - last - 1 ) ; count += ( K * ( K + 1 ) / 2 ) ; last = i ; } } K = ( N - last - 1 ) ; count += ( K * ( K + 1 ) / 2 ) ; return count ; }

BLEU: 96.17
Edit Sim: 4


Src: 
function series ( A , X , n ) { let term = Math . pow ( A , n ) ; document . write ( term + " " ) ; for ( let i = 1 ; i <= n ; i ++ ) { term = term * X * ( n - i + 1 ) / ( i * A ) ; document . write ( term + " " ) ; } }
Ref: 
void series ( int A , int X , int n ) { int term = pow ( A , n ) ; cout << term << " ▁ " ; for ( int i = 1 ; i <= n ; i ++ ) { term = term * X * ( n - i + 1 ) / ( i * A ) ; cout << term << " ▁ " ; } }
Hyp: 
void series ( double A , double X , int n ) { double term = pow ( A , n ) ; cout << term << " ▁ " ; for ( int i = 1 ; i <= n ; i ++ ) { term = term * X * ( n - i + 1 ) / ( i * A ) ; cout << term << " ▁ " ; } }

BLEU: 90.24
Edit Sim: 18


Src: 
function isPossible ( elements , sum ) { var dp = [ sum + 1 ] ; dp [ 0 ] = 1 ; for ( var i = 0 ; i < elements . length ; i ++ ) { for ( var j = sum ; j >= elements [ i ] ; j -- ) { if ( dp [ j - elements [ i ] ] == 1 ) dp [ j ] = 1 ; } } if ( dp [ sum ] == 1 ) return true ; return false ; }
Ref: 
bool isPossible ( int elements [ ] , int sum , int n ) { int dp [ sum + 1 ] ; dp [ 0 ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = sum ; j >= elements [ i ] ; j -- ) { if ( dp [ j - elements [ i ] ] == 1 ) dp [ j ] = 1 ; } } if ( dp [ sum ] == 1 ) return true ; return false ; }
Hyp: 
bool isPossible ( vector < int > elements , int sum ) { vector < int > dp ( sum + 1 , 0 ) ; dp [ 0 ] = 1 ; for ( int i = 0 ; i < elements . size ( ) ; i ++ ) { for ( int j = sum ; j >= elements [ i ] ; j -- ) { if ( dp [ j - elements [ i ] ] == 1 ) dp [ j ] = 1 ; } } if ( dp [ sum ] == 1 ) return true ; return false ; }

BLEU: 76.6
Edit Sim: 51


Src: 
function Count ( s , pos ) { let c = s [ pos - 1 ] ; let counter = 0 ; for ( let i = 0 ; i < pos - 1 ; i ++ ) { if ( s [ i ] == c ) counter = counter + 1 ; } return counter ; } let s = " " ; let pos ; let n = s . length ; let query = [ 9 , 3 , 2 ] ; let Q = query . length ; for ( let i = 0 ; i < Q ; i ++ ) { pos = query [ i ] ; document . write ( Count ( s , pos ) + " " ) ; }
Ref: 
int Count ( string s , int pos ) { int c = s [ pos - 1 ] ; int counter = 0 ; for ( int i = 0 ; i < pos - 1 ; i ++ ) { if ( s [ i ] == c ) counter = counter + 1 ; } return counter ; }
Hyp: 
int Count ( string s , int pos ) { char c = s [ pos - 1 ] ; int counter = 0 ; for ( int i = 0 ; i < pos - 1 ; i ++ ) { if ( s [ i ] == c ) counter = counter + 1 ; } return counter ; }

BLEU: 95.88
Edit Sim: 4


Src: 
function lengchord ( z ) { document . write ( " " + z ) ; }
Ref: 
void lengchord ( int z ) { cout << " The ▁ length ▁ is ▁ " << z << endl ; }
Hyp: 
void lengchord ( int z ) { cout << " The ▁ length ▁ of ▁ the ▁ longest ▁ chord " << endl ; }

BLEU: 64.68
Edit Sim: 23


Src: 
function Area ( b1 , b2 , h ) { return ( ( b1 + b2 ) / 2 ) * h ; }
Ref: 
double Area ( int b1 , int b2 , int h ) { return ( ( b1 + b2 ) / 2 ) * h ; }
Hyp: 
int Area ( int b1 , int b2 , int h ) { return ( ( b1 + b2 ) / 2 ) * h ; }

BLEU: 96.22
Edit Sim: 6


Src: 
function countSubStr ( str , n ) { let res = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( str [ i ] == ' ' ) { for ( let j = i + 1 ; j < n ; j ++ ) { if ( str [ j ] == ' ' ) res ++ ; } } } return res ; }
Ref: 
int countSubStr ( char str [ ] ) { int res = 0 ; for ( int i = 0 ; str [ i ] != ' \0' ; i ++ ) { if ( str [ i ] == '1' ) { for ( int j = i + 1 ; str [ j ] != ' \0' ; j ++ ) if ( str [ j ] == '1' ) res ++ ; } } return res ; }
Hyp: 
int countSubStr ( string str , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == ' ( ' ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( str [ j ] == ' ( ' ) res ++ ; } } } return res ; }

BLEU: 64.07
Edit Sim: 52


Src: 
function solve ( arr , n ) { var countzeroes = 0 ; var countones = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) countzeroes ++ ; else countones ++ ; } if ( Math . abs ( countzeroes - countones ) == 1 ) document . write ( " " ) ; else document . write ( " " ) ; }
Ref: 
void solve ( int arr [ ] , int n ) { int countzeroes = 0 ; int countones = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) countzeroes ++ ; else countones ++ ; } if ( abs ( countzeroes - countones ) == 1 ) cout << " Yes " ; else cout << " No " ; }
Hyp: 
void solve ( int arr [ ] , int n ) { int countzeroes = 0 ; int countones = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) countzeroes ++ ; else countones ++ ; } if ( abs ( countzeroes - countones ) == 1 ) cout << " Yes " ; else cout << " No " ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function lengtang ( r1 , r2 , d ) { document . write ( " " + " " + ( Math . sqrt ( Math . pow ( d , 2 ) - Math . pow ( ( r1 - r2 ) , 2 ) ) ) . toFixed ( 5 ) ) ; }
Ref: 
void lengtang ( double r1 , double r2 , double d ) { cout << " The ▁ length ▁ of ▁ the ▁ direct " << " ▁ common ▁ tangent ▁ is ▁ " << sqrt ( pow ( d , 2 ) - pow ( ( r1 - r2 ) , 2 ) ) << endl ; }
Hyp: 
void lengtang ( double r1 , double r2 , double d ) { cout << " The ▁ length ▁ of ▁ the ▁ longest ▁ chord " << " ▁ is ▁ " << sqrt ( pow ( d , 2 ) - pow ( ( r1 - r2 ) , 2 ) ) << endl ; }

BLEU: 88.25
Edit Sim: 25


Src: 
function countSubStr ( str , len , k ) { let count = 0 ; for ( let i = 0 ; i < len ; i ++ ) { let n = 0 ; for ( let j = i ; j < len ; j ++ ) { n = n * 10 + ( str [ j ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ) ; if ( n % k == 0 ) count ++ ; } } return count ; }
Ref: 
int countSubStr ( string str , int len , int k ) { int count = 0 ; for ( int i = 0 ; i < len ; i ++ ) { int n = 0 ; for ( int j = i ; j < len ; j ++ ) { n = n * 10 + ( str [ j ] - '0' ) ; if ( n % k == 0 ) count ++ ; } } return count ; }
Hyp: 
int countSubStr ( string str , int len , int k ) { int count = 0 ; for ( int i = 0 ; i < len ; i ++ ) { int n = 0 ; for ( int j = i ; j < len ; j ++ ) { n = n * 10 + ( str [ j ] - ' a ' ) ; if ( n % k == 0 ) count ++ ; } } return count ; }

BLEU: 94.77
Edit Sim: 3


Src: 
function check_position ( a , b , c , d , x1 , y1 , z1 , x2 , y2 , z2 ) { var value_1 = a * x1 + b * y1 + c * z1 + d ; var value_2 = a * x2 + b * y2 + c * z2 + d ; if ( ( value_1 > 0 && value_2 > 0 ) || ( value_1 < 0 && value_2 < 0 ) ) document . write ( " " ) ; if ( ( value_1 > 0 && value_2 < 0 ) || ( value_1 < 0 && value_2 > 0 ) ) document . write ( " " ) ; if ( value_1 == 0 && value_2 == 0 ) document . write ( " " ) ; if ( value_1 == 0 && value_2 != 0 ) document . write ( " " ) ; if ( value_1 != 0 && value_2 == 0 ) document . write ( " " ) ; }
Ref: 
void check_position ( int a , int b , int c , int d , int x1 , int y1 , int z1 , int x2 , int y2 , int z2 ) { int value_1 = a * x1 + b * y1 + c * z1 + d ; int value_2 = a * x2 + b * y2 + c * z2 + d ; if ( ( value_1 > 0 && value_2 > 0 ) || ( value_1 < 0 && value_2 < 0 ) ) cout << " On ▁ same ▁ side " ; if ( ( value_1 > 0 && value_2 < 0 ) || ( value_1 < 0 && value_2 > 0 ) ) cout << " On ▁ different ▁ sides " ; if ( value_1 == 0 && value_2 == 0 ) cout << " Both ▁ on ▁ the ▁ plane " ; if ( value_1 == 0 && value_2 != 0 ) cout << " Point ▁ 1 ▁ on ▁ the ▁ plane " ; if ( value_1 != 0 && value_2 == 0 ) cout << " Point ▁ 2 ▁ on ▁ the ▁ plane " ; }
Hyp: 
void check_position ( int a , int b , int c , int d , int x1 , int y1 , int z1 , int x2 , int y2 , int z2 ) { int value_1 = a * x1 + b * y1 + c * z1 + d ; int value_2 = a * x2 + b * y2 + c * z2 + d ; if ( ( value_1 > 0 && value_2 > 0 ) || ( value_1 < 0 && value_2 < 0 ) ) cout << " Yes " ; if ( ( value_1 > 0 && value_2 < 0 ) || ( value_1 < 0 && value_2 > 0 ) ) cout << " No " ; if ( value_1 == 0 && value_2 == 0 ) cout << " Yes " ; if ( value_1 == 0 && value_2 != 0 ) cout << " No " ; if ( value_1 != 0 && value_2 == 0 ) cout << " Yes " ; }

BLEU: 77.92
Edit Sim: 112


Src: 
function minDifferenceAmongMaxMin ( arr , N , K ) { arr . sort ( ( a , b ) => a - b ) ; let res = 2147483647 ; for ( let i = 0 ; i <= ( N - K ) ; i ++ ) { let curSeqDiff = arr [ i + K - 1 ] - arr [ i ] ; res = Math . min ( res , curSeqDiff ) ; } return res ; }
Ref: 
int minDifferenceAmongMaxMin ( int arr [ ] , int N , int K ) { sort ( arr , arr + N ) ; int res = INT_MAX ; for ( int i = 0 ; i <= ( N - K ) ; i ++ ) { int curSeqDiff = arr [ i + K - 1 ] - arr [ i ] ; res = min ( res , curSeqDiff ) ; } return res ; }
Hyp: 
int minDifferenceAmongMaxMin ( int arr [ ] , int N , int K ) { sort ( arr , arr + N ) ; int res = 2147483647 ; for ( int i = 0 ; i <= ( N - K ) ; i ++ ) { int curSeqDiff = arr [ i + K - 1 ] - arr [ i ] ; res = min ( res , curSeqDiff ) ; } return res ; }

BLEU: 96.78
Edit Sim: 10


Src: 
function countPairs ( arr , n ) { var result = 0 ; for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { var product = arr [ i ] * arr [ j ] ; for ( k = 0 ; k < n ; k ++ ) { if ( arr [ k ] == product ) { result ++ ; break ; } } } } return result ; }
Ref: 
int countPairs ( int arr [ ] , int n ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int product = arr [ i ] * arr [ j ] ; for ( int k = 0 ; k < n ; k ++ ) { if ( arr [ k ] == product ) { result ++ ; break ; } } } } return result ; }
Hyp: 
int countPairs ( int arr [ ] , int n ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int product = arr [ i ] * arr [ j ] ; for ( int k = 0 ; k < n ; k ++ ) { if ( arr [ k ] == product ) { result ++ ; break ; } } } } return result ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function sumEvenNumbers ( N , K ) { let check = N - 2 * ( K - 1 ) ; if ( check > 0 && check % 2 == 0 ) { for ( let i = 0 ; i < K - 1 ; i ++ ) { document . write ( " " ) ; } document . write ( check ) ; } else { document . write ( " " ) ; } }
Ref: 
void sumEvenNumbers ( int N , int K ) { int check = N - 2 * ( K - 1 ) ; if ( check > 0 && check % 2 == 0 ) { for ( int i = 0 ; i < K - 1 ; i ++ ) { cout << "2 ▁ " ; } cout << check ; } else { cout << " - 1" ; } }
Hyp: 
void sumEvenNumbers ( int N , int K ) { int check = N - 2 * ( K - 1 ) ; if ( check > 0 && check % 2 == 0 ) { for ( int i = 0 ; i < K - 1 ; i ++ ) { cout << "0" ; } cout << check ; } else { cout << " - 1" ; } }

BLEU: 93.91
Edit Sim: 4


Src: 
function findRadiusOfcircumcircle ( l , b ) { if ( l < 0 b < 0 ) return - 1 ; var radius = Math . sqrt ( Math . pow ( l , 2 ) + Math . pow ( b , 2 ) ) / 2 ; return radius ; }
Ref: 
float findRadiusOfcircumcircle ( float l , float b ) { if ( l < 0 b < 0 ) return -1 ; float radius = sqrt ( pow ( l , 2 ) + pow ( b , 2 ) ) / 2 ; return radius ; }
Hyp: 
float findRadiusOfcircumcircle ( float l , float b ) { if ( l < 0 b < 0 ) return -1 ; float radius = sqrt ( pow ( l , 2 ) + pow ( b , 2 ) ) / 2 ; return radius ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function sameChar ( S , N ) { var arr = S . split ( " " ) ; var sorted = arr . sort ( ) ; S = sorted . join ( " " ) ; var mid = S [ parseInt ( N / 2 ) ] . charCodeAt ( 0 ) ; var total_operations = 0 ; for ( var i = 0 ; i < N ; i ++ ) { total_operations += Math . abs ( S [ i ] . charCodeAt ( 0 ) - mid ) ; } document . write ( total_operations ) ; }
Ref: 
int sameChar ( string S , int N ) { sort ( S . begin ( ) , S . end ( ) ) ; int mid = S [ N / 2 ] ; int total_operations = 0 ; for ( int i = 0 ; i < N ; i ++ ) { total_operations += abs ( int ( S [ i ] ) - mid ) ; } cout << total_operations ; }
Hyp: 
void sameChar ( string S , int N ) { string arr [ ] ; sort ( arr , arr + N ) ; string sorted = sort ( sorted , S + N , greater < char > ( ) ) ; char mid = S [ N / 2 ] ; int total_operations = 0 ; for ( int i = 0 ; i < N ; i ++ ) { total_operations += abs ( S [ i ] - mid ) ; } cout << total_operations ; }

BLEU: 61.61
Edit Sim: 93


Src: 
function alternatingSumOfFirst_N ( N ) { var alternateSum = 0 ; for ( i = 1 ; i <= N ; i ++ ) { if ( i % 2 == 0 ) { alternateSum += - i ; } else { alternateSum += i ; } } return alternateSum ; }
Ref: 
int alternatingSumOfFirst_N ( int N ) { int alternateSum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( i % 2 == 0 ) { alternateSum += - i ; } else { alternateSum += i ; } } return alternateSum ; }
Hyp: 
int alternatingSumOfFirst_N ( int N ) { int alternateSum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( i % 2 == 0 ) { alternateSum += - i ; } else { alternateSum += i ; } } return alternateSum ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findNumber ( N ) { let ans = [ 1 , 2 , 4 , 8 , 7 , 5 ] ; return ans [ N % 6 ] ; }
Ref: 
int findNumber ( int N ) { int ans [ 6 ] = { 1 , 2 , 4 , 8 , 7 , 5 } ; return ans [ N % 6 ] ; }
Hyp: 
int findNumber ( int N ) { int ans [ ] = { 1 , 2 , 4 , 8 , 7 , 5 } ; return ans [ N % 6 ] ; }

BLEU: 92.79
Edit Sim: 2


Src: 
function minCost ( cost , n ) { var totalCost = 0 ; var boardingBus = 0 ; for ( i = 1 ; i < n ; i ++ ) { if ( cost [ boardingBus ] > cost [ i ] ) { totalCost += ( ( i - boardingBus ) * cost [ boardingBus ] ) ; boardingBus = i ; } } totalCost += ( ( n - boardingBus ) * cost [ boardingBus ] ) ; return totalCost ; }
Ref: 
int minCost ( vector < int > & cost , int n ) { int totalCost = 0 ; int boardingBus = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( cost [ boardingBus ] > cost [ i ] ) { totalCost += ( ( i - boardingBus ) * cost [ boardingBus ] ) ; boardingBus = i ; } } totalCost += ( ( n - boardingBus ) * cost [ boardingBus ] ) ; return totalCost ; }
Hyp: 
int minCost ( int * cost , int n ) { int totalCost = 0 ; int boardingBus = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( cost [ boardingBus ] > cost [ i ] ) { totalCost += ( ( i - boardingBus ) * cost [ boardingBus ] ) ; boardingBus = i ; } } totalCost += ( ( n - boardingBus ) * cost [ boardingBus ] ) ; return totalCost ; }

BLEU: 93.1
Edit Sim: 12


Src: 
function bridge_length ( trainLength , Speed , Time ) { return ( ( Time * Speed ) - trainLength ) ; }
Ref: 
int bridge_length ( int trainLength , int Speed , int Time ) { return ( ( Time * Speed ) - trainLength ) ; }
Hyp: 
int bridge_length ( int trainLength , int Speed , int Time ) { return ( ( Time * Speed ) - trainLength ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function squareRoot ( n , l ) { let x = n ; let root ; let count = 0 ; while ( true ) { count ++ ; root = 0.5 * ( x + ( n / x ) ) ; if ( Math . abs ( root - x ) < l ) break ; x = root ; } return root . toFixed ( 4 ) ; }
Ref: 
double squareRoot ( double n , float l ) { double x = n ; double root ; int count = 0 ; while ( 1 ) { count ++ ; root = 0.5 * ( x + ( n / x ) ) ; if ( abs ( root - x ) < l ) break ; x = root ; } return root ; }
Hyp: 
double squareRoot ( double n , double l ) { double x = n ; double root ; int count = 0 ; while ( 1 ) { count ++ ; root = 0.5 * ( x + ( n / x ) ) ; if ( abs ( root - x ) < l ) break ; x = root ; } return root ; }

BLEU: 96.2
Edit Sim: 6


Src: 
function NumberofWays ( n ) { var x = ( 1 * n * ( n - 1 ) * ( n - 2 ) * ( n - 3 ) ) / ( 4 * 3 * 2 * 1 ) ; var y = 1 * n * ( n - 1 ) * ( n - 2 ) * ( n - 3 ) ; return 1 * x * y ; }
Ref: 
long NumberofWays ( int n ) { long long x = ( 1LL * ( n ) * ( n - 1 ) * ( n - 2 ) * ( n - 3 ) ) / ( 4 * 3 * 2 * 1 ) ; long long y = ( 1LL * ( n ) * ( n - 1 ) * ( n - 2 ) * ( n - 3 ) ) ; return ( 1LL * x * y ) ; }
Hyp: 
int NumberofWays ( int n ) { float x = ( 1 * n * ( n - 1 ) * ( n - 2 ) * ( n - 3 ) ) / ( 4 * 3 * 2 * 1 ) ; float y = ( 1 * n * ( n - 1 ) * ( n - 2 ) * ( n - 3 ) ) / ( 4 * 3 * 2 * 1 ) ; return 1 * x * y ; }

BLEU: 67.38
Edit Sim: 51


Src: 
function sumOfSeries ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) for ( let j = 1 ; j <= i ; j ++ ) sum += j ; return sum ; }
Ref: 
int sumOfSeries ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= i ; j ++ ) sum += j ; return sum ; }
Hyp: 
int sumOfSeries ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= i ; j ++ ) sum += j ; return sum ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function summingSeries ( n ) { return Math . pow ( n , 2 ) ; }
Ref: 
int summingSeries ( long n ) { return pow ( n , 2 ) ; }
Hyp: 
int summingSeries ( int n ) { return pow ( n , 2 ) ; }

BLEU: 82.82
Edit Sim: 3


Src: 
function maxSubarrayXOR ( arr , n ) { let ans = Number . MIN_VALUE ; for ( let i = 0 ; i < n ; i ++ ) { let curr_xor = 0 ; for ( let j = i ; j < n ; j ++ ) { curr_xor = curr_xor ^ arr [ j ] ; ans = Math . max ( ans , curr_xor ) ; } } return ans ; }
Ref: 
int maxSubarrayXOR ( int arr [ ] , int n ) { int ans = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { curr_xor = curr_xor ^ arr [ j ] ; ans = max ( ans , curr_xor ) ; } } return ans ; }
Hyp: 
int maxSubarrayXOR ( int arr [ ] , int n ) { int ans = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { int curr_xor = 0 ; for ( int j = i ; j < n ; j ++ ) { curr_xor = curr_xor ^ arr [ j ] ; ans = max ( ans , curr_xor ) ; } } return ans ; }

BLEU: 91.35
Edit Sim: 19


Src: 
function highestPowerof2 ( n ) { let p = parseInt ( Math . log ( n ) / Math . log ( 2 ) , 10 ) ; return Math . pow ( 2 , p ) ; }
Ref: 
int highestPowerof2 ( int n ) { int p = ( int ) log2 ( n ) ; return ( int ) pow ( 2 , p ) ; }
Hyp: 
int highestPowerof2 ( int n ) { int p = log2 ( n ) ; return pow ( 2 , p ) ; }

BLEU: 67.09
Edit Sim: 16


Src: 
function find_distance ( n ) { return n * ( 3 * n + 7 ) ; }
Ref: 
int find_distance ( int n ) { return n * ( ( 3 * n ) + 7 ) ; }
Hyp: 
int find_distance ( int n ) { return n * ( 3 * n + 7 ) ; }

BLEU: 77.77
Edit Sim: 4


Src: 
function getPercentile ( rank , students ) { var result = ( students - rank ) / students * 100 ; return result ; }
Ref: 
float getPercentile ( int rank , int students ) { float result = float ( students - rank ) / students * 100 ; return result ; }
Hyp: 
double getPercentile ( int rank , int students ) { double result = ( students - rank ) / students * 100 ; return result ; }

BLEU: 78.4
Edit Sim: 18


Src: 
function otherNumber ( A , Lcm , Hcf ) { return ( Lcm * Hcf ) / A ; }
Ref: 
int otherNumber ( int A , int Lcm , int Hcf ) { return ( Lcm * Hcf ) / A ; }
Hyp: 
int otherNumber ( int A , int Lcm , int Hcf ) { return ( Lcm * Hcf ) / A ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function fib ( n ) { var f0 = 0 ; var f1 = 1 ; if ( n == 0 ) return 0 ; if ( n == 1 ) return 1 ; else { var rem = parseInt ( ( n % 60 ) ) ; if ( rem == 0 ) return 0 ; for ( i = 2 ; i < rem + 3 ; i ++ ) { var f = ( f0 + f1 ) % 60 ; f0 = f1 ; f1 = f ; } var s = f1 - 1 ; return s ; } }
Ref: 
long fib ( long long n ) { long long f0 = 0 ; long long f1 = 1 ; if ( n == 0 ) return 0 ; if ( n == 1 ) return 1 ; else { long long rem = n % 60 ; if ( rem == 0 ) return 0 ; for ( long long i = 2 ; i < rem + 3 ; i ++ ) { long long f = ( f0 + f1 ) % 60 ; f0 = f1 ; f1 = f ; } long long s = f1 - 1 ; return s ; } }
Hyp: 
int fib ( int n ) { int f0 = 0 ; int f1 = 1 ; if ( n == 0 ) return 0 ; if ( n == 1 ) return 1 ; else { int rem = ( n % 60 ) ; if ( rem == 0 ) return 0 ; for ( int i = 2 ; i < rem + 3 ; i ++ ) { int f = ( f0 + f1 ) % 60 ; f0 = f1 ; f1 = f ; } int s = f1 - 1 ; return s ; } }

BLEU: 73.5
Edit Sim: 63


Src: 
function isEven ( n ) { return ( ! ( n & 1 ) ) ; }
Ref: 
bool isEven ( int n ) { return ( ! ( n & 1 ) ) ; }
Hyp: 
bool isEven ( int n ) { return ( ! ( n & 1 ) ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function asPowerSum ( w , m ) { while ( m > 0 ) { if ( ( m - 1 ) % w == 0 ) m = ( m - 1 ) / w ; else if ( ( m + 1 ) % w == 0 ) m = ( m + 1 ) / w ; else if ( m % w == 0 ) m = m / w ; else } return ( m == 0 ) ; }
Ref: 
bool asPowerSum ( int w , int m ) { while ( m ) { if ( ( m - 1 ) % w == 0 ) m = ( m - 1 ) / w ; else if ( ( m + 1 ) % w == 0 ) m = ( m + 1 ) / w ; else if ( m % w == 0 ) m = m / w ; else } return ( m == 0 ) ; }
Hyp: 
bool asPowerSum ( int w , int m ) { while ( m > 0 ) { if ( ( m - 1 ) % w == 0 ) m = ( m - 1 ) / w ; else if ( ( m + 1 ) % w == 0 ) m = ( m + 1 ) / w ; else if ( m % w == 0 ) m = m / w ; else } return ( m == 0 ) ; }

BLEU: 95.93
Edit Sim: 4


Src: 
function numberOfGates ( s ) { let N = s . length ; let ans = 0 ; for ( let i = 0 ; i < s . length ; i ++ ) { if ( s [ i ] == ' ' s [ i ] == ' ' s [ i ] == ' ' ) { ans ++ ; } } document . write ( ans ) ; }
Ref: 
void numberOfGates ( string s ) { int N = s . size ( ) ; int ans = 0 ; for ( int i = 0 ; i < ( int ) s . size ( ) ; i ++ ) { if ( s [ i ] == ' . ' s [ i ] == ' + ' s [ i ] == '1' ) { ans ++ ; } } cout << ans ; }
Hyp: 
int numberOfGates ( string s ) { int N = s . length ( ) ; int ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( s [ i ] == '2' s [ i ] == '4' s [ i ] == '5' s [ i ] == '6' ) { ans ++ ; } } cout << ans ; }

BLEU: 68.68
Edit Sim: 39


Src: 
function MinimumX ( a , b , c , k ) { let x = Number . MAX_VALUE ; if ( k <= c ) return 0 ; let h = k - c ; let l = 0 ; while ( l <= h ) { let m = Math . floor ( ( l + h ) / 2 ) ; if ( ( a * m * m ) + ( b * m ) > ( k - c ) ) { x = Math . min ( x , m ) ; h = m - 1 ; } else if ( ( a * m * m ) + ( b * m ) < ( k - c ) ) l = m + 1 ; else return m ; } return x ; }
Ref: 
int MinimumX ( int a , int b , int c , int k ) { int x = INT_MAX ; if ( k <= c ) return 0 ; int h = k - c ; int l = 0 ; while ( l <= h ) { int m = ( l + h ) / 2 ; if ( ( a * m * m ) + ( b * m ) > ( k - c ) ) { x = min ( x , m ) ; h = m - 1 ; } else if ( ( a * m * m ) + ( b * m ) < ( k - c ) ) l = m + 1 ; else return m ; } return x ; }
Hyp: 
int MinimumX ( int a , int b , int c , int k ) { int x = INT_MAX ; if ( k <= c ) return 0 ; int h = k - c ; int l = 0 ; while ( l <= h ) { int m = ( l + h ) / 2 ; if ( ( a * m * m ) + ( b * m ) > ( k - c ) ) { x = min ( x , m ) ; h = m - 1 ; } else if ( ( a * m * m ) + ( b * m ) < ( k - c ) ) l = m + 1 ; else return m ; } return x ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function farthestCellDistance ( N , M , R , C ) { let d1 = N + M - R - C ; let d2 = R + C - 2 ; let d3 = N - R + C - 1 ; let d4 = M - C + R - 1 ; let maxDistance = Math . max ( d1 , Math . max ( d2 , Math . max ( d3 , d4 ) ) ) ; document . write ( maxDistance ) ; }
Ref: 
void farthestCellDistance ( int N , int M , int R , int C ) { int d1 = N + M - R - C ; int d2 = R + C - 2 ; int d3 = N - R + C - 1 ; int d4 = M - C + R - 1 ; int maxDistance = max ( d1 , max ( d2 , max ( d3 , d4 ) ) ) ; cout << maxDistance ; }
Hyp: 
void farthestCellDistance ( int N , int M , int R , int C ) { int d1 = N + M - R - C ; int d2 = R + C - 2 ; int d3 = N - R + C - 1 ; int d4 = M - C + R - 1 ; int maxDistance = max ( d1 , max ( d2 , max ( d3 , d4 ) ) ) ; cout << maxDistance ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function xorOfSum ( a , n ) { let answer = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i + 1 ; j < n ; j ++ ) answer ^= ( a [ i ] + a [ j ] ) ; } return answer ; }
Ref: 
int xorOfSum ( int a [ ] , int n ) { int answer = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) answer ^= ( a [ i ] + a [ j ] ) ; } return answer ; }
Hyp: 
int xorOfSum ( int a [ ] , int n ) { int answer = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) answer ^= ( a [ i ] + a [ j ] ) ; } return answer ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function CountTriangles ( A ) { var n = A . length ; A . sort ( ) ; var count = 0 ; for ( i = n - 1 ; i >= 1 ; i -- ) { var l = 0 , r = i - 1 ; while ( l < r ) { if ( A [ l ] + A [ r ] > A [ i ] ) { count += r - l ; r -- ; } else { l ++ ; } } } document . write ( " " + count ) ; }
Ref: 
void CountTriangles ( vector < int > A ) { int n = A . size ( ) ; sort ( A . begin ( ) , A . end ( ) ) ; int count = 0 ; for ( int i = n - 1 ; i >= 1 ; i -- ) { int l = 0 , r = i - 1 ; while ( l < r ) { if ( A [ l ] + A [ r ] > A [ i ] ) { count += r - l ; r -- ; } else l ++ ; } } cout << " No ▁ of ▁ possible ▁ solutions : ▁ " << count ; }
Hyp: 
void CountTriangles ( int A [ ] , int n ) { sort ( A , A + n ) ; int count = 0 ; for ( int i = n - 1 ; i >= 1 ; i -- ) { int l = 0 , r = i - 1 ; while ( l < r ) { if ( A [ l ] + A [ r ] > A [ i ] ) { count += r - l ; r -- ; } else { l ++ ; } } } cout << " Number ▁ Triangle ▁ is ▁ " << count ; }

BLEU: 69.38
Edit Sim: 71


Src: 
function printRotatedString ( str ) { var n = str . length ; var sb = str ; sb += ( str ) ; for ( var i = 0 ; i < n ; i ++ ) { for ( var j = 0 ; j != n ; j ++ ) document . write ( sb . charAt ( i + j ) ) ; document . write ( ' ' ) ; } }
Ref: 
void printRotatedString ( char str [ ] ) { int n = strlen ( str ) ; char temp [ 2 * n + 1 ] ; strcpy ( temp , str ) ; strcat ( temp , str ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j != n ; j ++ ) printf ( " % c " , temp [ i + j ] ) ; printf ( " STRNEWLINE " ) ; } }
Hyp: 
void printRotatedString ( string str ) { int n = str . length ( ) ; string sb = str ; sb += ( str ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j != n ; j ++ ) cout << sb [ i + j ] ; cout << ' ' ; } }

BLEU: 45.79
Edit Sim: 109


Src: 
function minimumSteps ( n , m , a , b ) { if ( n > m ) return MAXN ; if ( n == m ) return 0 ; return Math . min ( 1 + minimumSteps ( n * a , m , a , b ) , 1 + minimumSteps ( n * b , m , a , b ) ) ; }
Ref: 
int minimumSteps ( int n , int m , int a , int b ) { if ( n > m ) return MAXN ; if ( n == m ) return 0 ; return min ( 1 + minimumSteps ( n * a , m , a , b ) , 1 + minimumSteps ( n * b , m , a , b ) ) ; }
Hyp: 
int minimumSteps ( int n , int m , int a , int b ) { if ( n > m ) return MAXN ; if ( n == m ) return 0 ; return min ( 1 + minimumSteps ( n * a , m , a , b ) , 1 + minimumSteps ( n * b , m , a , b ) ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function sort ( s ) { var c = s . split ( ' ' ) ; c . sort ( ) ; var al_c = 0 , nu_c = 0 ; while ( c [ al_c ] . charCodeAt ( 0 ) < 97 ) al_c ++ ; for ( var i = 0 ; i < s . length ; i ++ ) { if ( s [ i ] . charCodeAt ( 0 ) < 97 ) s = s . substring ( 0 , i ) + c [ nu_c ++ ] + s . substring ( i + 1 ) ; else s = s . substring ( 0 , i ) + c [ al_c ++ ] + s . substring ( i + 1 ) ; } return s ; }
Ref: 
string sort ( string s ) { char c [ s . length ( ) + 1 ] ; strcpy ( c , s . c_str ( ) ) ; sort ( c , c + s . length ( ) ) ; int al_c = 0 , nu_c = 0 ; while ( c [ al_c ] < 97 ) al_c ++ ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] < 97 ) s [ i ] = c [ nu_c ++ ] ; else s [ i ] = c [ al_c ++ ] ; } return s ; }
Hyp: 
string sort ( string s ) { vector < int > c ; sort ( c . begin ( ) , c . end ( ) ) ; int al_c = 0 , nu_c = 0 ; while ( c [ al_c ] and c [ al_c ] < 97 ) al_c ++ ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { if ( s [ i ] and c [ nu_c ] < 97 ) s = s . substr ( 0 , i ) + c [ al_c ++ ] + s . substr ( i + 1 ) ; else s = s . substr ( 0 , i ) + c [ al_c ++ ] + s . substr ( i + 1 ) ; } return s ; }

BLEU: 53.3
Edit Sim: 180


Src: 
function FlipBits ( n ) { return n -= ( n & ( - n ) ) ; }
Ref: 
int FlipBits ( unsigned int n ) { return n -= ( n & ( - n ) ) ; }
Hyp: 
int FlipBits ( unsigned int n ) { return n -= ( n & ( - n ) ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function rearrange ( arr , n ) { let max_ele = arr [ n - 1 ] ; let min_ele = arr [ 0 ] ; for ( let i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { arr [ i ] = max_ele ; max_ele -= 1 ; } else { arr [ i ] = min_ele ; min_ele += 1 ; } } }
Ref: 
void rearrange ( int arr [ ] , int n ) { int max_ele = arr [ n - 1 ] ; int min_ele = arr [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { arr [ i ] = max_ele ; max_ele -= 1 ; } else { arr [ i ] = min_ele ; min_ele += 1 ; } } }
Hyp: 
void rearrange ( int arr [ ] , int n ) { int max_ele = arr [ n - 1 ] ; int min_ele = arr [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) arr [ i ] = max_ele ; max_ele -= 1 ; else arr [ i ] = min_ele ; min_ele += 1 ; } } }

BLEU: 91.57
Edit Sim: 6


Src: 
function minDiff ( A , K ) { A . sort ( function ( a , b ) { return a - b } ) ; let n = A . length ; if ( n <= K ) return 0 ; let mindiff = A [ n - 1 ] - A [ 0 ] ; if ( K == 0 ) return mindiff ; for ( let i = 0 , j = n - 1 - K ; j < n ; ) { mindiff = Math . min ( mindiff , A [ j ] - A [ i ] ) ; i ++ ; j ++ ; } return mindiff ; }
Ref: 
int minDiff ( int A [ ] , int K , int n ) { sort ( A , A + n ) ; if ( n <= K ) return 0 ; int mindiff = A [ n - 1 ] - A [ 0 ] ; if ( K == 0 ) return mindiff ; for ( int i = 0 , j = n - 1 - K ; j < n ; ) { mindiff = min ( mindiff , A [ j ] - A [ i ] ) ; i ++ ; j ++ ; } return mindiff ; }
Hyp: 
int minDiff ( vector < int > & A , int K ) { sort ( A , A + n ) ; if ( n <= K ) return 0 ; int mindiff = A [ n - 1 ] - A [ 0 ] ; if ( K == 0 ) return mindiff ; for ( int i = 0 , j = n - 1 - K ; j < n ; ) { mindiff = min ( mindiff , A [ j ] - A [ i ] ) ; i ++ ; j ++ ; } return mindiff ; }

BLEU: 90.92
Edit Sim: 14


Src: 
function sieve ( ) { let arr = new Array ( N + 1 ) ; for ( let i = 0 ; i < arr . length ; i ++ ) { arr [ i ] = 0 ; } arr [ 0 ] = 1 ; arr [ 1 ] = 1 ; for ( let i = 2 ; i <= Math . ceil ( Math . sqrt ( N ) + 1 ) ; i ++ ) if ( arr [ i ] == 0 ) for ( let j = i * i ; j <= N ; j += i ) arr [ j ] = 1 ; let runningPrimeSum = 0 ; for ( let i = 1 ; i <= N ; i ++ ) { if ( arr [ i ] == 0 ) runningPrimeSum += i ; dp [ i ] = runningPrimeSum ; } }
Ref: 
void sieve ( ) { int arr [ N + 1 ] ; arr [ 0 ] = 1 ; arr [ 1 ] = 1 ; for ( int i = 2 ; i <= sqrt ( N ) ; i ++ ) if ( arr [ i ] == 0 ) for ( int j = i * i ; j <= N ; j += i ) arr [ j ] = 1 ; long runningPrimeSum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( arr [ i ] == 0 ) runningPrimeSum += i ; dp [ i ] = runningPrimeSum ; } }
Hyp: 
void sieve ( int N ) { int arr [ N + 1 ] ; memset ( arr , 0 , sizeof ( arr ) ) ; arr [ 0 ] = 1 ; arr [ 1 ] = 1 ; for ( int i = 2 ; i <= sqrt ( N ) + 1 ; i ++ ) if ( arr [ i ] == 0 ) for ( int j = i * i ; j <= N ; j += i ) arr [ j ] = 1 ; int runningPrimeSum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( arr [ i ] == 0 ) runningPrimeSum += i ; dp [ i ] = runningPrimeSum ; } }

BLEU: 83.55
Edit Sim: 51


Src: 
function count ( n ) { return Math . pow ( 2 , n - 1 ) ; }
Ref: 
int count ( int n ) { return pow ( 2 , n - 1 ) ; }
Hyp: 
int count ( int n ) { return pow ( 2 , n - 1 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function printTriplets ( arr , n , sum ) { arr . sort ( function ( a , b ) { return a - b } ) ; for ( let i = 0 ; i < n - 2 ; i ++ ) { let j = i + 1 , k = n - 1 ; while ( j < k ) { if ( arr [ i ] + arr [ j ] + arr [ k ] >= sum ) k -- ; else { for ( let x = j + 1 ; x <= k ; x ++ ) document . write ( arr [ i ] + " " + arr [ j ] + " " + arr [ x ] + " " ) ; j ++ ; } } } }
Ref: 
int printTriplets ( int arr [ ] , int n , int sum ) { sort ( arr , arr + n ) ; for ( int i = 0 ; i < n - 2 ; i ++ ) { int j = i + 1 , k = n - 1 ; while ( j < k ) { if ( arr [ i ] + arr [ j ] + arr [ k ] >= sum ) k -- ; else { for ( int x = j + 1 ; x <= k ; x ++ ) cout << arr [ i ] << " , ▁ " << arr [ j ] << " , ▁ " << arr [ x ] << endl ; j ++ ; } } } }
Hyp: 
void printTriplets ( int arr [ ] , int n , int sum ) { sort ( arr , arr + n ) ; for ( int i = 0 ; i < n - 2 ; i ++ ) { int j = i + 1 , k = n - 1 ; while ( j < k ) { if ( arr [ i ] + arr [ j ] + arr [ k ] >= sum ) k -- ; else { for ( int x = j + 1 ; x <= k ; x ++ ) cout << arr [ i ] << " ▁ " << arr [ j ] << " ▁ " << arr [ x ] << " ▁ " ; j ++ ; } } } }

BLEU: 93.72
Edit Sim: 13


Src: 
function ceilSearch ( arr , low , high , x ) { let mid ; if ( x <= arr [ low ] ) return low ; if ( x > arr [ high ] ) return - 1 ; mid = ( low + high ) / 2 ; if ( arr [ mid ] == x ) return mid ; else if ( arr [ mid ] < x ) { if ( mid + 1 <= high && x <= arr [ mid + 1 ] ) return mid + 1 ; else return ceilSearch ( arr , mid + 1 , high , x ) ; } else { if ( mid - 1 >= low && x > arr [ mid - 1 ] ) return mid ; else return ceilSearch ( arr , low , mid - 1 , x ) ; } } let arr = [ 1 , 2 , 8 , 10 , 10 , 12 , 19 ] ; let n = arr . length ; let x = 20 ; let index = ceilSearch ( arr , 0 , n - 1 , x ) ; if ( index == - 1 ) { document . write ( ` ${ x } ` ) ; } else { document . write ( ` ${ x } ${ arr [ index ] } ` ) ; }
Ref: 
int ceilSearch ( int arr [ ] , int low , int high , int x ) { int mid ; if ( x <= arr [ low ] ) return low ; if ( x > arr [ high ] ) return -1 ; mid = ( low + high ) / 2 ; if ( arr [ mid ] == x ) return mid ; else if ( arr [ mid ] < x ) { if ( mid + 1 <= high && x <= arr [ mid + 1 ] ) return mid + 1 ; else return ceilSearch ( arr , mid + 1 , high , x ) ; } else { if ( mid - 1 >= low && x > arr [ mid - 1 ] ) return mid ; else return ceilSearch ( arr , low , mid - 1 , x ) ; } }
Hyp: 
int ceilSearch ( int arr [ ] , int low , int high , int x ) { int mid ; if ( x <= arr [ low ] ) return low ; if ( x > arr [ high ] ) return -1 ; mid = ( low + high ) / 2 ; if ( arr [ mid ] == x ) return mid ; else if ( arr [ mid ] < x ) { if ( mid + 1 <= high && x <= arr [ mid + 1 ] ) return mid + 1 ; else return ceilSearch ( arr , mid + 1 , high , x ) ; } else { if ( mid - 1 >= low && x > arr [ mid - 1 ] ) return mid ; else return ceilSearch ( arr , low , mid - 1 , x ) ; } }

BLEU: 100.0
Edit Sim: 0


Src: 
function countSmaller ( str ) { var n = str . length ; for ( var i = 0 ; i < n ; i ++ ) { var cnt = 0 ; for ( var j = i + 1 ; j < n ; j ++ ) { if ( str [ j ] < str [ i ] ) { cnt += 1 ; } } document . write ( cnt + " " ) ; } }
Ref: 
void countSmaller ( string str ) { int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int cnt = 0 ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( str [ j ] < str [ i ] ) { cnt += 1 ; } } cout << cnt << " ▁ " ; } }
Hyp: 
void countSmaller ( string str ) { int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int cnt = 0 ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( str [ j ] < str [ i ] ) { cnt += 1 ; } } cout << cnt << " ▁ " ; } }

BLEU: 100.0
Edit Sim: 0


Src: 
function splitArray ( arr , N ) { arr . sort ( ) ; let result = Number . MAX_VALUE ; for ( let i = 1 ; i < N ; i ++ ) { result = Math . min ( result , arr [ i ] - arr [ i - 1 ] ) ; } return result ; }
Ref: 
int splitArray ( int arr [ ] , int N ) { sort ( arr , arr + N ) ; int result = INT_MAX ; for ( int i = 1 ; i < N ; i ++ ) { result = min ( result , arr [ i ] - arr [ i - 1 ] ) ; } return result ; }
Hyp: 
int splitArray ( int arr [ ] , int N ) { sort ( arr , arr + N ) ; int result = INT_MAX ; for ( int i = 1 ; i < N ; i ++ ) { result = min ( result , arr [ i ] - arr [ i - 1 ] ) ; } return result ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findMinX ( num , rem , k ) { while ( true ) { var j ; for ( j = 0 ; j < k ; j ++ ) if ( x % num [ j ] != rem [ j ] ) break ; if ( j == k ) return x ; x ++ ; } }
Ref: 
int findMinX ( int num [ ] , int rem [ ] , int k ) { while ( true ) { int j ; for ( j = 0 ; j < k ; j ++ ) if ( x % num [ j ] != rem [ j ] ) break ; if ( j == k ) return x ; x ++ ; } return x ; }
Hyp: 
int findMinX ( int num [ ] , int rem [ ] , int k ) { while ( 1 ) { int j ; for ( j = 0 ; j < k ; j ++ ) if ( x % num [ j ] != rem [ j ] ) break ; if ( j == k ) return x ; x ++ ; } }

BLEU: 91.02
Edit Sim: 15


Src: 
function deleteElement ( arr , n , x ) { let i ; for ( i = 0 ; i < n ; i ++ ) if ( arr [ i ] == x ) break ; if ( i < n ) { n = n - 1 ; for ( let j = i ; j < n ; j ++ ) arr [ j ] = arr [ j + 1 ] ; } return n ; }
Ref: 
int deleteElement ( int arr [ ] , int n , int x ) { int i ; for ( i = 0 ; i < n ; i ++ ) if ( arr [ i ] == x ) break ; if ( i < n ) { n = n - 1 ; for ( int j = i ; j < n ; j ++ ) arr [ j ] = arr [ j + 1 ] ; } return n ; }
Hyp: 
int deleteElement ( int arr [ ] , int n , int x ) { int i ; for ( i = 0 ; i < n ; i ++ ) if ( arr [ i ] == x ) break ; if ( i < n ) { n = n - 1 ; for ( int j = i ; j < n ; j ++ ) arr [ j ] = arr [ j + 1 ] ; } return n ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findLen ( arr , n , m ) { var filter = [ ] ; for ( var i = 0 ; i < n ; i ++ ) if ( ( arr [ i ] & m ) == m ) filter . push ( arr [ i ] ) ; if ( filter . length == 0 ) return 0 ; var c_and = filter [ 0 ] ; for ( var i = 1 ; i < filter . length ; i ++ ) c_and &= filter [ i ] ; if ( c_and == m ) return filter . length ; return 0 ; }
Ref: 
int findLen ( int * arr , int n , int m ) { vector < int > filter ; for ( int i = 0 ; i < n ; i ++ ) if ( ( arr [ i ] & m ) == m ) filter . push_back ( arr [ i ] ) ; if ( filter . size ( ) == 0 ) return 0 ; int c_and = filter [ 0 ] ; for ( int i = 1 ; i < filter . size ( ) ; i ++ ) c_and &= filter [ i ] ; if ( c_and == m ) return filter . size ( ) ; return 0 ; }
Hyp: 
int findLen ( int arr [ ] , int n , int m ) { vector < int > filter ; for ( int i = 0 ; i < n ; i ++ ) if ( ( arr [ i ] & m ) == m ) filter . push_back ( arr [ i ] ) ; if ( filter . size ( ) == 0 ) return 0 ; int c_and = filter [ 0 ] ; for ( int i = 1 ; i < filter . size ( ) ; i ++ ) c_and &= filter [ i ] ; if ( c_and == m ) return filter . size ( ) ; return 0 ; }

BLEU: 96.45
Edit Sim: 6


Src: 
function minRotation ( input , unlock_code ) { let rotation = 0 ; let input_digit , code_digit ; while ( input > 0 unlock_code > 0 ) { input_digit = input % 10 ; code_digit = unlock_code % 10 ; rotation += Math . min ( Math . abs ( input_digit - code_digit ) , 10 - Math . abs ( input_digit - code_digit ) ) ; input = Math . floor ( input / 10 ) ; unlock_code = Math . floor ( unlock_code / 10 ) ; } return rotation ; }
Ref: 
int minRotation ( int input , int unlock_code ) { int rotation = 0 ; int input_digit , code_digit ; while ( input unlock_code ) { input_digit = input % 10 ; code_digit = unlock_code % 10 ; rotation += min ( abs ( input_digit - code_digit ) , 10 - abs ( input_digit - code_digit ) ) ; input /= 10 ; unlock_code /= 10 ; } return rotation ; }
Hyp: 
int minRotation ( int input , int unlock_code ) { int rotation = 0 ; int input_digit , code_digit ; while ( input > 0 unlock_code > 0 ) { input_digit = input % 10 ; code_digit = unlock_code % 10 ; rotation += min ( abs ( input_digit - code_digit ) , 10 - abs ( input_digit - code_digit ) ) ; input = input / 10 ; unlock_code = unlock_code / 10 ; } return rotation ; }

BLEU: 80.6
Edit Sim: 32


Src: 
function findMinSum ( num ) { let sum = 0 ; for ( let i = 2 ; i * i <= num ; i ++ ) { while ( num % i == 0 ) { sum += i ; num /= i ; } } sum += num ; return sum ; }
Ref: 
int findMinSum ( int num ) { int sum = 0 ; for ( int i = 2 ; i * i <= num ; i ++ ) { while ( num % i == 0 ) { sum += i ; num /= i ; } } sum += num ; return sum ; }
Hyp: 
int findMinSum ( int num ) { int sum = 0 ; for ( int i = 2 ; i * i <= num ; i ++ ) { while ( num % i == 0 ) { sum += i ; num /= i ; } } sum += num ; return sum ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countSubsequence ( s , n ) { var cntG = 0 , cntF = 0 , result = 0 , C = 0 ; for ( var i = 0 ; i < n ; i ++ ) { switch ( s [ i ] ) { case ' ' : cntG ++ ; result += C ; break ; case ' ' : cntF ++ ; C += cntG ; break ; default : continue ; } } document . write ( result ) ; }
Ref: 
void countSubsequence ( char s [ ] , int n ) { int cntG = 0 , cntF = 0 , result = 0 , C = 0 ; for ( int i = 0 ; i < n ; i ++ ) { switch ( s [ i ] ) { case ' G ' : cntG ++ ; result += C ; break ; case ' F ' : cntF ++ ; C += cntG ; break ; default : continue ; } } cout << result << endl ; }
Hyp: 
void countSubsequence ( string s , int n ) { int cntG = 0 , cntF = 0 , result = 0 , C = 0 ; for ( int i = 0 ; i < n ; i ++ ) { switch ( s [ i ] ) { case ' ( ' : cntG ++ ; result += C ; break ; case ' ( ' : cntF ++ ; C += cntG ; break ; default : continue ; } } cout << result ; }

BLEU: 85.14
Edit Sim: 18


Src: 
function findNewString ( s ) { var ans = 0 ; var freq = new Array ( 26 ) . fill ( 0 ) ; var n = s . length ; for ( let i = 0 ; i < n ; i ++ ) { ans += freq [ s [ i ] . charCodeAt ( 0 ) - " " . charCodeAt ( 0 ) ] ; freq [ s [ i ] . charCodeAt ( 0 ) - " " . charCodeAt ( 0 ) ] += 1 ; } return ans ; }
Ref: 
long findNewString ( string s ) { long long ans = 0 ; int freq [ 26 ] ; int n = s . length ( ) ; memset ( freq , 0 , sizeof freq ) ; for ( int i = 0 ; i < ( int ) s . length ( ) ; ++ i ) { ans += freq [ s [ i ] - ' a ' ] ; freq [ s [ i ] - ' a ' ] ++ ; } return ans ; }
Hyp: 
int findNewString ( string s ) { int ans = 0 ; vector < int > freq ( 26 , 0 ) ; int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { ans += freq [ s [ i ] - ' a ' ] ; freq [ s [ i ] - ' a ' ] += 1 ; } return ans ; }

BLEU: 62.44
Edit Sim: 89


Src: 
function minimumValue ( N , K ) { return Math . ceil ( K / N ) ; }
Ref: 
int minimumValue ( int N , int K ) { return ceil ( ( double ) K / ( double ) N ) ; }
Hyp: 
int minimumValue ( int N , int K ) { return ceil ( K / N ) ; }

BLEU: 61.05
Edit Sim: 22


Src: 
function linearSearch ( arr , n ) { let i ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == i ) return i ; } return - 1 ; }
Ref: 
int linearSearch ( int arr [ ] , int n ) { int i ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == i ) return i ; } return -1 ; }
Hyp: 
int linearSearch ( int arr [ ] , int n ) { int i ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == i ) return i ; } return -1 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function checkPoint ( radius , x , y , percent , startAngle ) { let endAngle = 360 / percent + startAngle ; let polarradius = Math . sqrt ( x * x + y * y ) ; let Angle = Math . atan ( y / x ) ; if ( Angle >= startAngle && Angle <= endAngle && polarradius < radius ) document . write ( " " + " " + x + " " + y + " " + " " ) ; else document . write ( " " + " " + x + " " + y + " " + " " ) ; }
Ref: 
void checkPoint ( int radius , int x , int y , float percent , float startAngle ) { float endAngle = 360 / percent + startAngle ; float polarradius = sqrt ( x * x + y * y ) ; float Angle = atan ( y / x ) ; if ( Angle >= startAngle && Angle <= endAngle && polarradius < radius ) printf ( " Point ▁ ( % d , ▁ % d ) ▁ exist ▁ in ▁ the ▁ circle ▁ sector STRNEWLINE " , x , y ) ; else printf ( " Point ▁ ( % d , ▁ % d ) ▁ does ▁ not ▁ exist ▁ in ▁ the ▁ circle ▁ sector STRNEWLINE " , x , y ) ; }
Hyp: 
void checkPoint ( float radius , float x , float y , float percent , float startAngle ) { float endAngle = 360 / percent + startAngle ; float polarradius = sqrt ( x * x + y * y ) ; float Angle = atan ( y / x ) ; if ( Angle >= startAngle && Angle <= endAngle && polarradius < radius ) cout << " Yes " << " ▁ " << x << " , ▁ " << y ; else cout << " No " << x << " , ▁ " << y ; }

BLEU: 45.65
Edit Sim: 170


Src: 
function cntKnightsAttackPawn ( knights , pawn , M ) { let cntKnights = 0 ; for ( let i = 0 ; i < M ; i ++ ) { let X = Math . abs ( knights [ i ] [ 0 ] - pawn [ 0 ] ) ; let Y = Math . abs ( knights [ i ] [ 1 ] - pawn [ 1 ] ) ; if ( ( X == 1 && Y == 2 ) || ( X == 2 && Y == 1 ) ) { cntKnights ++ ; } } return cntKnights ; }
Ref: 
int cntKnightsAttackPawn ( int knights [ ] [ 2 ] , int pawn [ ] , int M ) { int cntKnights = 0 ; for ( int i = 0 ; i < M ; i ++ ) { int X = abs ( knights [ i ] [ 0 ] - pawn [ 0 ] ) ; int Y = abs ( knights [ i ] [ 1 ] - pawn [ 1 ] ) ; if ( ( X == 1 && Y == 2 ) || ( X == 2 && Y == 1 ) ) { cntKnights ++ ; } } return cntKnights ; }
Hyp: 
int cntKnightsAttackPawn ( int knights [ ] [ MAX ] , int pawn [ MAX ] , int M ) { int cntKnights = 0 ; for ( int i = 0 ; i < M ; i ++ ) { int X = abs ( knights [ i ] [ 0 ] - pawn [ 0 ] ) ; int Y = abs ( knights [ i ] [ 1 ] - pawn [ 1 ] ) ; if ( ( X == 1 && Y == 2 ) || ( X == 2 && Y == 1 ) ) { cntKnights ++ ; } } return cntKnights ; }

BLEU: 95.43
Edit Sim: 7


Src: 
function placeValue ( N , num ) { var total = 1 , value = 0 , rem = 0 ; while ( true ) { rem = N % 10 ; N = parseInt ( N / 10 ) ; if ( rem == num ) { value = total * rem ; break ; } total = total * 10 ; } return value ; }
Ref: 
int placeValue ( int N , int num ) { int total = 1 , value = 0 , rem = 0 ; while ( true ) { rem = N % 10 ; N = N / 10 ; if ( rem == num ) { value = total * rem ; break ; } total = total * 10 ; } return value ; }
Hyp: 
int placeValue ( int N , int num ) { int total = 1 , value = 0 , rem = 0 ; while ( 1 ) { rem = N % 10 ; N /= 10 ; if ( rem == num ) { value = total * rem ; break ; } total = total * 10 ; } return value ; }

BLEU: 89.32
Edit Sim: 9


Src: 
function printMaxAfterRemoval ( s ) { let flag = false ; let n = s . length ; for ( let i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ' ' && flag == false ) { flag = true ; continue ; } else document . write ( s [ i ] ) ; } return 0 ; }
Ref: 
int printMaxAfterRemoval ( string s ) { bool flag = false ; int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == '0' && flag == false ) { flag = true ; continue ; } else cout << s [ i ] ; } }
Hyp: 
int printMaxAfterRemoval ( string s ) { bool flag = false ; int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == '0' && flag == false ) { flag = true ; continue ; } else cout << s [ i ] ; } return 0 ; }

BLEU: 94.59
Edit Sim: 11


Src: 
function sum ( L , R ) { let p = Math . floor ( R / 6 ) ; let q = Math . floor ( ( L - 1 ) / 6 ) ; let sumR = Math . floor ( 3 * ( p * ( p + 1 ) ) ) ; let sumL = Math . floor ( ( q * ( q + 1 ) ) * 3 ) ; return sumR - sumL ; }
Ref: 
int sum ( int L , int R ) { int p = R / 6 ; int q = ( L - 1 ) / 6 ; int sumR = 3 * ( p * ( p + 1 ) ) ; int sumL = ( q * ( q + 1 ) ) * 3 ; return sumR - sumL ; }
Hyp: 
int sum ( int L , int R ) { int p = R / 6 ; int q = ( L - 1 ) / 6 ; int sumR = 3 * ( p * ( p + 1 ) ) ; int sumL = ( q * ( q + 1 ) ) * 3 ; return sumR - sumL ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function areaCircle ( b ) { let area = 3.1415926 * b * b ; return area ; }
Ref: 
double areaCircle ( double b ) { double area = pi * b * b ; return area ; }
Hyp: 
float areaCircle ( float b ) { float area = 3.1415926 * b * b ; return area ; }

BLEU: 55.8
Edit Sim: 27


Src: 
function isdecagonal ( N ) { let n = ( 3 + Math . sqrt ( 16 * N + 9 ) ) / 8 ; return ( n - parseInt ( n ) ) == 0 ; } let N = 10 ; if ( isdecagonal ( N ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
Ref: 
bool isdecagonal ( int N ) { float n = ( 3 + sqrt ( 16 * N + 9 ) ) / 8 ; return ( n - ( int ) n ) == 0 ; }
Hyp: 
bool isdecagonal ( int N ) { float n = ( 3 + sqrt ( 16 * N + 9 ) ) / 8 ; return ( n - ( int ) n ) == 0 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function oddLengthPalindrome ( k ) { let palin = k ; k = Math . floor ( k / 10 ) ; while ( k > 0 ) { let rev = k % 10 ; palin = ( palin * 10 ) + rev ; k = Math . floor ( k / 10 ) ; } return palin ; }
Ref: 
int oddLengthPalindrome ( int k ) { int palin = k ; k = k / 10 ; while ( k > 0 ) { int rev = k % 10 ; palin = ( palin * 10 ) + rev ; k = k / 10 ; } return palin ; }
Hyp: 
int oddLengthPalindrome ( int k ) { int palin = k ; k = k / 10 ; while ( k > 0 ) { int rev = k % 10 ; palin = ( palin * 10 ) + rev ; k = k / 10 ; } return palin ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findValue ( arr , n , k ) { for ( let i = 0 ; i < n ; i ++ ) if ( arr [ i ] == k ) k *= 2 ; return k ; }
Ref: 
int findValue ( int a [ ] , int n , int k ) { sort ( a , a + n ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == k ) k *= 2 ; } return k ; }
Hyp: 
int findValue ( int arr [ ] , int n , int k ) { for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == k ) k *= 2 ; return k ; }

BLEU: 61.77
Edit Sim: 29


Src: 
function countEvenSum ( low , high , k ) { let even_count = high / 2 - ( low - 1 ) / 2 ; let odd_count = ( high + 1 ) / 2 - low / 2 ; let even_sum = 1 ; let odd_sum = 0 ; for ( let i = 0 ; i < k ; i ++ ) { let prev_even = even_sum ; let prev_odd = odd_sum ; even_sum = ( prev_even * even_count ) + ( prev_odd * odd_count ) ; odd_sum = ( prev_even * odd_count ) + ( prev_odd * even_count ) ; } document . write ( even_sum ) ; }
Ref: 
int countEvenSum ( int low , int high , int k ) { int even_count = high / 2 - ( low - 1 ) / 2 ; int odd_count = ( high + 1 ) / 2 - low / 2 ; long even_sum = 1 ; long odd_sum = 0 ; for ( int i = 0 ; i < k ; i ++ ) { long prev_even = even_sum ; long prev_odd = odd_sum ; even_sum = ( prev_even * even_count ) + ( prev_odd * odd_count ) ; odd_sum = ( prev_even * odd_count ) + ( prev_odd * even_count ) ; } cout << ( even_sum ) ; }
Hyp: 
void countEvenSum ( int low , int high , int k ) { int even_count = high / 2 - ( low - 1 ) / 2 ; int odd_count = ( high + 1 ) / 2 - low / 2 ; int even_sum = 1 ; int odd_sum = 0 ; for ( int i = 0 ; i < k ; i ++ ) { int prev_even = even_sum ; int prev_odd = odd_sum ; even_sum = ( prev_even * even_count ) + ( prev_odd * odd_count ) ; odd_sum = ( prev_even * odd_count ) + ( prev_odd * even_count ) ; } cout << even_sum ; }

BLEU: 86.78
Edit Sim: 20


Src: 
function clstNum ( N ) { return ( N - 1 ) ; }
Ref: 
int clstNum ( int N ) { return ( N - 1 ) ; }
Hyp: 
int clstNum ( int N ) { return ( N - 1 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countTriplets ( A ) { var cnt = 0 ; var tuples = new Map ( ) ; A . forEach ( a => { A . forEach ( b => { if ( tuples . has ( a & b ) ) tuples . set ( a & b , tuples . get ( a & b ) + 1 ) else tuples . set ( a & b , 1 ) } ) ; } ) ; A . forEach ( a => { tuples . forEach ( ( value , key ) => { if ( ( key & a ) == 0 ) cnt += value ; } ) ; } ) ; return cnt ; }
Ref: 
int countTriplets ( vector < int > & A ) { int cnt = 0 ; unordered_map < int , int > tuples ; for ( auto a : A ) for ( auto b : A ) ++ tuples [ a & b ] ; for ( auto a : A ) for ( auto t : tuples ) if ( ( t . first & a ) == 0 ) cnt += t . second ; return cnt ; }
Hyp: 
int countTriplets ( int A [ ] , int n ) { int cnt = 0 ; unordered_map < int , int > tuples ; for ( int a : A ) { for ( int b : A ) tuples [ a & b ] ++ ; } ) ; }

BLEU: 31.91
Edit Sim: 124


Src: 
function countPaths ( n , m ) { var dp = Array ( n + 1 ) . fill ( 0 ) . map ( x => Array ( m + 1 ) . fill ( 0 ) ) ; for ( i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = 1 ; for ( i = 0 ; i <= m ; i ++ ) dp [ 0 ] [ i ] = 1 ; for ( i = 1 ; i <= n ; i ++ ) for ( j = 1 ; j <= m ; j ++ ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] ; return dp [ n ] [ m ] ; }
Ref: 
int countPaths ( int n , int m ) { int dp [ n + 1 ] [ m + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = 1 ; for ( int i = 0 ; i <= m ; i ++ ) dp [ 0 ] [ i ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= m ; j ++ ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] ; return dp [ n ] [ m ] ; }
Hyp: 
int countPaths ( int n , int m ) { vector < vector < int > > dp ( n + 1 , vector < int > ( m + 1 ) ) ; for ( int i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = 1 ; for ( int i = 0 ; i <= m ; i ++ ) dp [ 0 ] [ i ] = 1 ; for ( i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= m ; j ++ ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] ; return dp [ n ] [ m ] ; }

BLEU: 84.69
Edit Sim: 47


Src: 
function getMaxGold ( gold , m , n ) { let goldTable = new Array ( m ) ; for ( let i = 0 ; i < m ; i ++ ) { goldTable [ i ] = new Array ( n ) ; for ( let j = 0 ; j < n ; j ++ ) { goldTable [ i ] [ j ] = 0 ; } } for ( let col = n - 1 ; col >= 0 ; col -- ) { for ( let row = 0 ; row < m ; row ++ ) { let right = ( col == n - 1 ) ? 0 : goldTable [ row ] [ col + 1 ] ; let right_up = ( row == 0 col == n - 1 ) ? 0 : goldTable [ row - 1 ] [ col + 1 ] ; let right_down = ( row == m - 1 col == n - 1 ) ? 0 : goldTable [ row + 1 ] [ col + 1 ] ; goldTable [ row ] [ col ] = gold [ row ] [ col ] + Math . max ( right , Math . max ( right_up , right_down ) ) ; } } let res = goldTable [ 0 ] [ 0 ] ; for ( let i = 1 ; i < m ; i ++ ) res = Math . max ( res , goldTable [ i ] [ 0 ] ) ; return res ; }
Ref: 
int getMaxGold ( int gold [ ] [ MAX ] , int m , int n ) { int goldTable [ m ] [ n ] ; memset ( goldTable , 0 , sizeof ( goldTable ) ) ; for ( int col = n - 1 ; col >= 0 ; col -- ) { for ( int row = 0 ; row < m ; row ++ ) { int right = ( col == n - 1 ) ? 0 : goldTable [ row ] [ col + 1 ] ; int right_up = ( row == 0 col == n - 1 ) ? 0 : goldTable [ row - 1 ] [ col + 1 ] ; int right_down = ( row == m - 1 col == n - 1 ) ? 0 : goldTable [ row + 1 ] [ col + 1 ] ; goldTable [ row ] [ col ] = gold [ row ] [ col ] + max ( right , max ( right_up , right_down ) ) ; } } int res = goldTable [ 0 ] [ 0 ] ; for ( int i = 1 ; i < m ; i ++ ) res = max ( res , goldTable [ i ] [ 0 ] ) ; return res ; }
Hyp: 
int getMaxGold ( int gold [ ] [ m ] , int m , int n ) { int goldTable [ m + 1 ] [ n ] ; memset ( goldTable , 0 , sizeof ( goldTable ) ) ; for ( int col = n - 1 ; col >= 0 ; col -- ) { for ( int row = 0 ; row < m ; row ++ ) { int right = ( col == n - 1 ) ? 0 : goldTable [ row ] [ col + 1 ] ; int right_up = ( row == 0 col == n - 1 ) ? 0 : goldTable [ row - 1 ] [ col + 1 ] ; int right_down = ( row == m - 1 col == n - 1 ) ? 0 : goldTable [ row + 1 ] [ col + 1 ] ; goldTable [ row ] [ col ] = gold [ row ] [ col ] + max ( right , max ( right_up , right_down ) ) ; } } int res = goldTable [ 0 ] [ 0 ] ; for ( int i = 1 ; i < m ; i ++ ) res = max ( res , goldTable [ i ] [ 0 ] ) ; return res ; }

BLEU: 97.57
Edit Sim: 7


Src: 
function removeAll ( arr , n ) { if ( arr [ 0 ] < arr [ n - 1 ] ) document . write ( " " ) ; else document . write ( " " ) ; }
Ref: 
void removeAll ( int arr [ ] , int n ) { if ( arr [ 0 ] < arr [ n - 1 ] ) cout << " YES " ; else cout << " NO " ; }
Hyp: 
void removeAll ( int arr [ ] , int n ) { if ( arr [ 0 ] < arr [ n - 1 ] ) cout << " Yes " ; else cout << " No " ; }

BLEU: 86.96
Edit Sim: 3


Src: 
function ceilSearch ( arr , low , high , x ) { let i ; if ( x <= arr [ low ] ) return low ; for ( i = low ; i < high ; i ++ ) { if ( arr [ i ] == x ) return i ; if ( arr [ i ] < x && arr [ i + 1 ] >= x ) return i + 1 ; } return - 1 ; }
Ref: 
int ceilSearch ( int arr [ ] , int low , int high , int x ) { int i ; if ( x <= arr [ low ] ) return low ; for ( i = low ; i < high ; i ++ ) { if ( arr [ i ] == x ) return i ; if ( arr [ i ] < x && arr [ i + 1 ] >= x ) return i + 1 ; } return -1 ; }
Hyp: 
int ceilSearch ( int arr [ ] , int low , int high , int x ) { int i ; if ( x <= arr [ low ] ) return low ; for ( i = low ; i < high ; i ++ ) { if ( arr [ i ] == x ) return i ; if ( arr [ i ] < x && arr [ i + 1 ] >= x ) return i + 1 ; } return -1 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function minNum ( n ) { if ( n < 3 ) document . write ( - 1 ) ; else document . write ( ( 210 * ( parseInt ( Math . pow ( 10 , n - 1 ) / 210 ) + 1 ) ) ) ; }
Ref: 
void minNum ( int n ) { if ( n < 3 ) cout << -1 ; else cout << ( 210 * ( ( int ) ( pow ( 10 , n - 1 ) / 210 ) + 1 ) ) ; }
Hyp: 
void minNum ( int n ) { if ( n < 3 ) cout << -1 ; else cout << ( 210 * ( pow ( 10 , n - 1 ) / 210 + 1 ) ) ; }

BLEU: 82.98
Edit Sim: 12


Src: 
function findSumOfAllSubsets ( arr , n , k ) { let factorial_N = 1 , factorial_d = 1 , factorial_D = 1 ; for ( let i = 1 ; i <= n - 1 ; i ++ ) factorial_N *= i ; for ( let i = 1 ; i <= k - 1 ; i ++ ) factorial_d *= i ; for ( let i = 1 ; i <= n - k ; i ++ ) factorial_D *= i ; let freq = factorial_N / ( factorial_d * factorial_D ) ; let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; sum = sum * freq ; document . write ( " " + k + " " + sum + " " ) ; }
Ref: 
void findSumOfAllSubsets ( int arr [ ] , int n , int k ) { int factorial_N = 1 , factorial_d = 1 , factorial_D = 1 ; for ( int i = 1 ; i <= n - 1 ; i ++ ) factorial_N *= i ; for ( int i = 1 ; i <= k - 1 ; i ++ ) factorial_d *= i ; for ( int i = 1 ; i <= n - k ; i ++ ) factorial_D *= i ; int freq = factorial_N / ( factorial_d * factorial_D ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; sum = sum * freq ; cout << " Sum ▁ of ▁ all ▁ subsets ▁ of ▁ size ▁ = ▁ " << k << " ▁ is ▁ = > ▁ " << sum << endl ; }
Hyp: 
void findSumOfAllSubsets ( int arr [ ] , int n , int k ) { long long factorial_N = 1 , factorial_d = 1 , factorial_D = 1 ; for ( long long i = 1 ; i <= n - 1 ; i ++ ) factorial_N *= i ; for ( long long i = 1 ; i <= k - 1 ; i ++ ) factorial_d *= i ; for ( long long i = 1 ; i <= n - k ; i ++ ) factorial_D *= i ; long long freq = factorial_N / ( factorial_d * factorial_D ) ; long long sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; sum = sum * freq ; cout << " Subset ▁ Sum ▁ of ▁ the ▁ longest ▁ chord " << k << " ▁ is ▁ " << sum << " ▁ degree " ; }

BLEU: 78.26
Edit Sim: 93


Src: 
function distinct ( S , M , n ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let set1 = new Set ( ) ; for ( let j = 0 ; j < S [ i ] . length ; j ++ ) { if ( ! set1 . has ( S [ i ] [ j ] ) ) set1 . add ( S [ i ] [ j ] ) ; } let c = set1 . size ; if ( c <= M ) count += 1 ; } document . write ( count ) ; }
Ref: 
void distinct ( string S [ ] , int M , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { set < char > set1 ; for ( int j = 0 ; j < S [ i ] . length ( ) ; j ++ ) { if ( set1 . find ( S [ i ] [ j ] ) == set1 . end ( ) ) set1 . insert ( S [ i ] [ j ] ) ; } int c = set1 . size ( ) ; if ( c <= M ) count += 1 ; } cout << ( count ) ; }
Hyp: 
void distinct ( vector < vector < int > > S , int M , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { set < int > set1 ; for ( int j = 0 ; j < S [ i ] . size ( ) ; j ++ ) { if ( set1 . find ( S [ i ] [ j ] ) == set1 . end ( ) ) set1 . insert ( S [ i ] [ j ] ) ; } int c = set1 . size ( ) ; if ( c <= M ) count += 1 ; } cout << count ; }

BLEU: 87.03
Edit Sim: 34


Src: 
function findMaximumProfit ( arr , M , N ) { let max_heap = [ ] ; let maxProfit = 0 ; for ( let i = 0 ; i < N ; i ++ ) max_heap . push ( arr [ i ] ) ; max_heap . sort ( function ( a , b ) { return a - b } ) ; max_heap . reverse ( ) ; while ( M > 0 ) { M -- ; let X = max_heap [ 0 ] ; max_heap . shift ( ) ; maxProfit += X ; max_heap . push ( X - 1 ) ; max_heap . sort ( function ( a , b ) { return a - b } ) ; max_heap . reverse ( ) ; } document . write ( maxProfit ) ; }
Ref: 
void findMaximumProfit ( int arr [ ] , int M , int N ) { priority_queue < int > max_heap ; int maxProfit = 0 ; for ( int i = 0 ; i < N ; i ++ ) max_heap . push ( arr [ i ] ) ; while ( M > 0 ) { M -- ; int X = max_heap . top ( ) ; max_heap . pop ( ) ; maxProfit += X ; max_heap . push ( X - 1 ) ; } cout << maxProfit ; }
Hyp: 
void findMaximumProfit ( int arr [ ] , int M , int N ) { vector < int > max_heap ; int maxProfit = 0 ; for ( int i = 0 ; i < N ; i ++ ) max_heap . push_back ( arr [ i ] ) ; sort ( max_heap . begin ( ) , max_heap . end ( ) ) ; while ( M > 0 ) { M -- ; int X = max_heap [ 0 ] ; max_heap . shift ( ) ; maxProfit += X ; max_heap . push_back ( X - 1 ) ; sort ( max_heap . begin ( ) , max_heap . end ( ) ) ; max_heap . reverse ( ) ; } cout << maxProfit ; }

BLEU: 61.73
Edit Sim: 166


Src: 
function minimumCost ( cost , n ) { let dp1 = 0 , dp2 = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let dp0 = cost [ i ] + Math . min ( dp1 , dp2 ) ; dp2 = dp1 ; dp1 = dp0 ; } return Math . min ( dp1 , dp2 ) ; }
Ref: 
int minimumCost ( int cost [ ] , int n ) { int dp1 = 0 , dp2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int dp0 = cost [ i ] + min ( dp1 , dp2 ) ; dp2 = dp1 ; dp1 = dp0 ; } return min ( dp1 , dp2 ) ; }
Hyp: 
int minimumCost ( int * cost , int n ) { int dp1 = 0 , dp2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int dp0 = cost [ i ] + min ( dp1 , dp2 ) ; dp2 = dp1 ; dp1 = dp0 ; } return min ( dp1 , dp2 ) ; }

BLEU: 93.73
Edit Sim: 6


Src: 
function nth_group ( n ) { return n * ( 2 * Math . pow ( n , 2 ) + 1 ) ; }
Ref: 
int nth_group ( int n ) { return n * ( 2 * pow ( n , 2 ) + 1 ) ; }
Hyp: 
int nth_group ( int n ) { return n * ( 2 * pow ( n , 2 ) + 1 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function evenbittogglenumber ( n ) { let res = 0 , count = 0 ; for ( let temp = n ; temp > 0 ; temp >>= 1 ) { if ( count % 2 == 1 ) res |= ( 1 << count ) ; count ++ ; } return n ^ res ; }
Ref: 
int evenbittogglenumber ( int n ) { int res = 0 , count = 0 ; for ( int temp = n ; temp > 0 ; temp >>= 1 ) { if ( count % 2 == 1 ) res |= ( 1 << count ) ; count ++ ; } return n ^ res ; }
Hyp: 
int evenbittogglenumber ( int n ) { int res = 0 , count = 0 ; for ( int temp = n ; temp > 0 ; temp >>= 1 ) { if ( count % 2 == 1 ) res |= ( 1 << count ) ; count ++ ; } return n ^ res ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function numberOfWays ( x ) { let dp = Array ( x + 1 ) . fill ( 0 ) ; dp [ 0 ] = dp [ 1 ] = 1 ; for ( i = 2 ; i <= x ; i ++ ) dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; return dp [ x ] ; }
Ref: 
int numberOfWays ( int x ) { int dp [ x + 1 ] ; dp [ 0 ] = dp [ 1 ] = 1 ; for ( int i = 2 ; i <= x ; i ++ ) dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; return dp [ x ] ; }
Hyp: 
int numberOfWays ( int x ) { int dp [ x + 1 ] ; dp [ 0 ] = dp [ 1 ] = 1 ; for ( int i = 2 ; i <= x ; i ++ ) dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; return dp [ x ] ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function NthTerm ( n ) { let x = ( 3 * n * n ) % 1000000009 ; return ( x - n + 1000000009 ) % 1000000009 ; }
Ref: 
int NthTerm ( long long n ) { long long x = ( 3 * n * n ) % mod ; return ( x - n + mod ) % mod ; }
Hyp: 
int NthTerm ( int n ) { int x = ( 3 * n * n ) % 1000000009 ; return ( x - n + 1000000009 ) % 1000000009 ; }

BLEU: 55.34
Edit Sim: 46


Src: 
function calculateSide ( n , r ) { var theta , theta_in_radians ; theta = 360 / n ; theta_in_radians = theta * 3.14 / 180 ; return 2 * r * Math . sin ( theta_in_radians / 2 ) ; }
Ref: 
float calculateSide ( float n , float r ) { float theta , theta_in_radians ; theta = 360 / n ; theta_in_radians = theta * 3.14 / 180 ; return 2 * r * sin ( theta_in_radians / 2 ) ; }
Hyp: 
int calculateSide ( int n , int r ) { double theta , theta_in_radians ; theta = 360 / n ; theta_in_radians = theta * 3.14 / 180 ; return 2 * r * sin ( theta_in_radians / 2 ) ; }

BLEU: 80.23
Edit Sim: 18


Src: 
function getElements ( a , arr , n ) { let elements = new Array ( n + 1 ) ; for ( let i = 0 ; i < n + 1 ; i ++ ) { elements [ i ] = 0 ; } elements [ 0 ] = a ; for ( let i = 0 ; i < n ; i ++ ) { elements [ i + 1 ] = arr [ i ] ^ elements [ i ] ; } for ( let i = 0 ; i < n + 1 ; i ++ ) document . write ( elements [ i ] + " " ) ; }
Ref: 
void getElements ( int a , int arr [ ] , int n ) { int elements [ n + 1 ] ; elements [ 0 ] = a ; for ( int i = 0 ; i < n ; i ++ ) { elements [ i + 1 ] = arr [ i ] ^ elements [ i ] ; } for ( int i = 0 ; i < n + 1 ; i ++ ) cout << elements [ i ] << " ▁ " ; }
Hyp: 
void getElements ( int a [ ] , int arr [ ] , int n ) { int elements [ n + 1 ] ; memset ( elements , 0 , sizeof ( elements ) ) ; elements [ 0 ] = a ; for ( int i = 0 ; i < n ; i ++ ) { elements [ i + 1 ] = arr [ i ] ^ elements [ i ] ; } for ( int i = 0 ; i < n + 1 ; i ++ ) cout << elements [ i ] << " ▁ " ; }

BLEU: 84.4
Edit Sim: 52


Src: 
function maxXOR ( arr , n ) { let xorArr = 0 ; for ( let i = 0 ; i < n ; i ++ ) xorArr ^= arr [ i ] ; let ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) ans = Math . max ( ans , ( xorArr ^ arr [ i ] ) ) ; return ans ; }
Ref: 
int maxXOR ( int * arr , int n ) { int xorArr = 0 ; for ( int i = 0 ; i < n ; i ++ ) xorArr ^= arr [ i ] ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) ans = max ( ans , ( xorArr ^ arr [ i ] ) ) ; return ans ; }
Hyp: 
int maxXOR ( int arr [ ] , int n ) { int xorArr = 0 ; for ( int i = 0 ; i < n ; i ++ ) xorArr ^= arr [ i ] ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) ans = max ( ans , ( xorArr ^ arr [ i ] ) ) ; return ans ; }

BLEU: 94.39
Edit Sim: 6


Src: 
function findCountOfPairs ( a , b , n ) { let ans = 0 ; ans += n * parseInt ( a / n , 10 ) * parseInt ( b / n , 10 ) ans += parseInt ( a / n , 10 ) * parseInt ( b % n , 10 ) ; ans += parseInt ( a % n , 10 ) * parseInt ( b / n , 10 ) ; ans += parseInt ( ( ( a % n ) + ( b % n ) ) / n , 10 ) ; return ans ; }
Ref: 
int findCountOfPairs ( int a , int b , int n ) { int ans = 0 ; ans += n * ( a / n ) * ( b / n ) ; ans += ( a / n ) * ( b % n ) ; ans += ( a % n ) * ( b / n ) ; ans += ( ( a % n ) + ( b % n ) ) / n ; return ans ; }
Hyp: 
int findCountOfPairs ( int a , int b , int n ) { int ans = 0 ; ans += n * ( a / n ) * ( b / n ) ; ans += ( a / n ) * ( b % n ) ; ans += ( a % n ) * ( b / n ) ; ans += ( ( a % n ) + ( b % n ) ) / n ; return ans ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function maximumSum ( a , b , n , index , lastpicked ) { if ( index == n ) return 0 ; let option1 = 0 , option2 = 0 ; if ( lastpicked == - 1 a [ lastpicked ] != a [ index ] ) option1 = b [ index ] + maximumSum ( a , b , n , index + 1 , index ) ; option2 = maximumSum ( a , b , n , index + 1 , lastpicked ) ; return Math . max ( option1 , option2 ) ; }
Ref: 
int maximumSum ( int a [ ] , int b [ ] , int n , int index , int lastpicked ) { if ( index == n ) return 0 ; int option1 = 0 , option2 = 0 ; if ( lastpicked == -1 a [ lastpicked ] != a [ index ] ) option1 = b [ index ] + maximumSum ( a , b , n , index + 1 , index ) ; option2 = maximumSum ( a , b , n , index + 1 , lastpicked ) ; return max ( option1 , option2 ) ; }
Hyp: 
int maximumSum ( int a [ ] , int b [ ] , int n , int index , int lastpicked ) { if ( index == n ) return 0 ; int option1 = 0 , option2 = 0 ; if ( lastpicked == -1 a [ lastpicked ] != a [ index ] ) option1 = b [ index ] + maximumSum ( a , b , n , index + 1 , index ) ; option2 = maximumSum ( a , b , n , index + 1 , lastpicked ) ; return max ( option1 , option2 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findLine ( distance , degree ) { let x = degree * 3.14159 / 180 ; if ( degree > 90 ) { document . write ( " " ) ; return ; } let result_1 = Math . sin ( x ) ; let result_2 = Math . cos ( x ) ; document . write ( result_2 . toPrecision ( 2 ) + " " + result_1 . toPrecision ( 2 ) + " " + distance ) ; }
Ref: 
void findLine ( int distance , float degree ) { float x = degree * 3.14159 / 180 ; if ( degree > 90 ) { cout << " Not ▁ Possible " ; return ; } float result_1 = sin ( x ) ; float result_2 = cos ( x ) ; cout << fixed << setprecision ( 2 ) << result_2 << " x ▁ + " << result_1 << " y ▁ = ▁ " << distance ; }
Hyp: 
void findLine ( int distance , int degree ) { double x = degree * 3.14159 / 180 ; if ( degree > 90 ) { cout << " NO " ; return ; } double result_1 = sin ( x ) ; double result_2 = cos ( x ) ; cout << result_2 << " ▁ " << result_1 << " ▁ " << distance ; }

BLEU: 59.66
Edit Sim: 76


Src: 
function multiplyWith3Point5 ( x ) { return ( x << 1 ) + x + ( x >> 1 ) ; }
Ref: 
int multiplyWith3Point5 ( int x ) { return ( x << 1 ) + x + ( x >> 1 ) ; }
Hyp: 
int multiplyWith3Point5 ( int x ) { return ( x << 1 ) + x + ( x >> 1 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function sumOfSquaredDifferences ( arr , N ) { let ans = 0 ; let sumA = 0 , sumB = 0 ; for ( let i = 0 ; i < N ; i ++ ) { sumA += ( arr [ i ] * arr [ i ] ) ; sumB += arr [ i ] ; } sumA = N * sumA ; sumB = ( sumB * sumB ) ; ans = sumA - sumB ; document . write ( ans ) ; }
Ref: 
void sumOfSquaredDifferences ( int arr [ ] , int N ) { int ans = 0 ; int sumA = 0 , sumB = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sumA += ( arr [ i ] * arr [ i ] ) ; sumB += arr [ i ] ; } sumA = N * sumA ; sumB = ( sumB * sumB ) ; ans = sumA - sumB ; cout << ans ; }
Hyp: 
int sumOfSquaredDifferences ( int arr [ ] , int N ) { int ans = 0 ; int sumA = 0 , sumB = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sumA += ( arr [ i ] * arr [ i ] ) ; sumB += arr [ i ] ; } sumA = N * sumA ; sumB = ( sumB * sumB ) ; ans = sumA - sumB ; cout << ans ; }

BLEU: 98.86
Edit Sim: 4


Src: 
function getWinner ( str , len ) { var total = 0 ; if ( str [ 0 ] == ' ' str [ len - 1 ] == ' ' ) return " " ; else { for ( var i = 0 ; i < len ; i ++ ) { if ( str [ i ] == ' ' ) { total ++ ; } } if ( ( total % 2 ) == 1 ) return " " ; return " " ; } }
Ref: 
string getWinner ( string str , int len ) { int total = 0 ; if ( str [ 0 ] == ' G ' str [ len - 1 ] == ' G ' ) return " First " ; else { for ( int i = 0 ; i < len ; i ++ ) { if ( str [ i ] == ' S ' ) { total ++ ; } } if ( ( total % 2 ) == 1 ) return " First " ; return " Second " ; } }
Hyp: 
string getWinner ( string str , int len ) { int total = 0 ; if ( str [ 0 ] == ' A ' str [ len - 1 ] == ' B ' ) return " A " ; else { for ( int i = 0 ; i < len ; i ++ ) { if ( str [ i ] == ' C ' ) { total ++ ; } } if ( ( total % 2 ) == 1 ) return " B " ; return " A " ; } }

BLEU: 84.07
Edit Sim: 19


Src: 
function precompute ( ) { var fact = 1 ; for ( var i = 1 ; i <= 18 ; i ++ ) { fact = fact * i ; m [ fact ] = i ; } }
Ref: 
int precompute ( ) { ll fact = 1 ; for ( ll i = 1 ; i <= 18 ; i ++ ) { fact = fact * i ; m [ fact ] = i ; } }
Hyp: 
void precompute ( ) { int fact = 1 ; for ( int i = 1 ; i <= 18 ; i ++ ) { fact = fact * i ; m [ fact ] = i ; } }

BLEU: 84.97
Edit Sim: 10


Src: 
function circle_equation ( x1 , y1 , r ) { let a = - 2 * x1 ; let b = - 2 * y1 ; let c = ( r * r ) - ( x1 * x1 ) - ( y1 * y1 ) ; document . write ( " " + a + " " ) ; document . write ( " " + b + " " ) ; document . write ( c + " " ) ; }
Ref: 
void circle_equation ( double x1 , double y1 , double r ) { double a = -2 * x1 ; double b = -2 * y1 ; double c = ( r * r ) - ( x1 * x1 ) - ( y1 * y1 ) ; cout << " x ^ 2 ▁ + ▁ ( " << a << " ▁ x ) ▁ + ▁ " ; cout << " y ^ 2 ▁ + ▁ ( " << b << " ▁ y ) ▁ = ▁ " ; cout << c << " . " << endl ; }
Hyp: 
void circle_equation ( int x1 , int y1 , int r ) { int a = - 2 * x1 ; int b = - 2 * y1 ; int c = ( r * r ) - ( x1 * x1 ) - ( y1 * y1 ) ; cout << " a ▁ = ▁ " << a << endl ; cout << " b ▁ = ▁ " << b << endl ; cout << c << endl ; }

BLEU: 42.26
Edit Sim: 93


Src: 
function Numberofways ( n ) { var count = 0 ; for ( var a = 1 ; a < n ; a ++ ) { for ( var b = 1 ; b < n ; b ++ ) { var c = n - ( a + b ) ; if ( a + b > c && a + c > b && b + c > a ) { count ++ ; } } } return count ; }
Ref: 
int Numberofways ( int n ) { int count = 0 ; for ( int a = 1 ; a < n ; a ++ ) { for ( int b = 1 ; b < n ; b ++ ) { int c = n - ( a + b ) ; if ( a + b > c && a + c > b && b + c > a ) { count ++ ; } } } return count ; }
Hyp: 
int Numberofways ( int n ) { int count = 0 ; for ( int a = 1 ; a < n ; a ++ ) { for ( int b = 1 ; b < n ; b ++ ) { int c = n - ( a + b ) ; if ( a + b > c && a + c > b && b + c > a ) { count ++ ; } } } return count ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function performQueries ( str , n , queries , q ) { var ptr = 0 ; for ( var i = 0 ; i < q ; i ++ ) { if ( queries [ i ] [ 0 ] == 1 ) { ptr = ( ptr + queries [ i ] [ 1 ] ) % n ; } else { var k = queries [ i ] [ 1 ] ; var index = ( ptr + k - 1 ) % n ; document . write ( str [ index ] + " " ) ; } } }
Ref: 
void performQueries ( string str , int n , int queries [ ] [ size ] , int q ) { int ptr = 0 ; for ( int i = 0 ; i < q ; i ++ ) { if ( queries [ i ] [ 0 ] == 1 ) { ptr = ( ptr + queries [ i ] [ 1 ] ) % n ; } else { int k = queries [ i ] [ 1 ] ; int index = ( ptr + k - 1 ) % n ; cout << str [ index ] << " STRNEWLINE " ; } } }
Hyp: 
void performQueries ( char * str , int n , vector < vector < int > > queries , int q ) { int ptr = 0 ; for ( int i = 0 ; i < q ; i ++ ) { if ( queries [ i ] [ 0 ] == 1 ) { ptr = ( ptr + queries [ i ] [ 1 ] ) % n ; } else { int k = queries [ i ] [ 1 ] ; int index = ( ptr + k - 1 ) % n ; cout << str [ index ] << " ▁ " ; } } }

BLEU: 86.55
Edit Sim: 41


Src: 
function findSum ( n ) { let multiTerms = n * ( n + 1 ) / 2 ; let sum = multiTerms ; for ( let i = 2 ; i <= n ; i ++ ) { multiTerms = multiTerms - ( i - 1 ) ; sum = sum + multiTerms * i ; } return sum ; }
Ref: 
int findSum ( int n ) { long long int multiTerms = n * ( n + 1 ) / 2 ; long long int sum = multiTerms ; for ( int i = 2 ; i <= n ; i ++ ) { multiTerms = multiTerms - ( i - 1 ) ; sum = sum + multiTerms * i ; } return sum ; }
Hyp: 
int findSum ( int n ) { int multiTerms = n * ( n + 1 ) / 2 ; int sum = multiTerms ; for ( int i = 2 ; i <= n ; i ++ ) { multiTerms = multiTerms - ( i - 1 ) ; sum = sum + multiTerms * i ; } return sum ; }

BLEU: 89.22
Edit Sim: 20


Src: 
function printTaxicab2 ( N ) { let i = 1 ; count = 0 ; while ( count < N ) { let int_count = 0 ; for ( let j = 1 ; j <= Math . pow ( i , 1.0 / 3 ) ; j ++ ) for ( let k = j + 1 ; k <= Math . pow ( i , 1.0 / 3 ) ; k ++ ) if ( j * j * j + k * k * k == i ) int_count ++ ; if ( int_count == 2 ) { count ++ ; document . write ( count + " " + i + " " ) ; } i ++ ; } }
Ref: 
void printTaxicab2 ( int N ) { int i = 1 , count = 0 ; while ( count < N ) { int int_count = 0 ; for ( int j = 1 ; j <= pow ( i , 1.0 / 3 ) ; j ++ ) for ( int k = j + 1 ; k <= pow ( i , 1.0 / 3 ) ; k ++ ) if ( j * j * j + k * k * k == i ) int_count ++ ; if ( int_count == 2 ) { count ++ ; cout << count << " ▁ " << i << endl ; } i ++ ; } }
Hyp: 
void printTaxicab2 ( int N ) { int i = 1 ; int count = 0 ; while ( count < N ) { int int_count = 0 ; for ( int j = 1 ; j <= pow ( i , 1.0 / 3 ) ; j ++ ) for ( int k = j + 1 ; k <= pow ( i , 1.0 / 3 ) ; k ++ ) if ( j * j * j + k * k * k == i ) int_count ++ ; if ( int_count == 2 ) { count ++ ; cout << count << " ▁ " << i << " ▁ " ; } i ++ ; } }

BLEU: 93.38
Edit Sim: 10


Src: 
function getBoundarySum ( a , m , n ) { let sum = 0 ; for ( let i = 0 ; i < m ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { if ( i == 0 ) sum += a [ i ] [ j ] ; else if ( i == m - 1 ) sum += a [ i ] [ j ] ; else if ( j == 0 ) sum += a [ i ] [ j ] ; else if ( j == n - 1 ) sum += a [ i ] [ j ] ; } } return sum ; }
Ref: 
int getBoundarySum ( int a [ ] [ MAX ] , int m , int n ) { long long int sum = 0 ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == 0 ) sum += a [ i ] [ j ] ; else if ( i == m - 1 ) sum += a [ i ] [ j ] ; else if ( j == 0 ) sum += a [ i ] [ j ] ; else if ( j == n - 1 ) sum += a [ i ] [ j ] ; } } return sum ; }
Hyp: 
int getBoundarySum ( int a [ ] [ MAX ] , int m , int n ) { int sum = 0 ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == 0 ) sum += a [ i ] [ j ] ; else if ( i == m - 1 ) sum += a [ i ] [ j ] ; else if ( j == 0 ) sum += a [ i ] [ j ] ; else if ( j == n - 1 ) sum += a [ i ] [ j ] ; } } return sum ; }

BLEU: 97.32
Edit Sim: 10


Src: 
function printOtherSides ( n ) { if ( n % 2 != 0 ) { if ( n == 1 ) document . write ( " " ) ; else { var b = ( n * n - 1 ) / 2 ; var c = ( n * n + 1 ) / 2 ; document . write ( " " + b + " " + c ) ; } } else { if ( n == 2 ) document . write ( " " ) ; else { var b = n * n / 4 - 1 ; var c = n * n / 4 + 1 ; document . write ( " " + b + " " + c ) ; } } }
Ref: 
void printOtherSides ( int n ) { if ( n & 1 ) { if ( n == 1 ) cout << -1 << endl ; else { int b = ( n * n - 1 ) / 2 ; int c = ( n * n + 1 ) / 2 ; cout << " b ▁ = ▁ " << b << " , ▁ c ▁ = ▁ " << c << endl ; } } else { if ( n == 2 ) cout << -1 << endl ; else { int b = n * n / 4 - 1 ; int c = n * n / 4 + 1 ; cout << " b ▁ = ▁ " << b << " , ▁ c ▁ = ▁ " << c << endl ; } } }
Hyp: 
void printOtherSides ( int n ) { if ( n % 2 != 0 ) { if ( n == 1 ) cout << " Yes " ; else { int b = ( n * n - 1 ) / 2 ; int c = ( n * n + 1 ) / 2 ; cout << " Yes " << b << " ▁ " << c ; } } else { if ( n == 2 ) cout << " No " ; else { int b = n * n / 4 - 1 ; int c = n * n / 4 + 1 ; cout << " Yes " << b << " ▁ " << c ; } } }

BLEU: 68.87
Edit Sim: 73


Src: 
function solve ( s ) { let area = ( 1.732 * Math . pow ( s , 2 ) ) / 8 ; return area ; }
Ref: 
double solve ( int s ) { double area = ( 1.732 * pow ( s , 2 ) ) / 8 ; return area ; }
Hyp: 
float solve ( int s ) { float area = ( 1.732 * pow ( s , 2 ) ) / 8 ; return area ; }

BLEU: 86.46
Edit Sim: 12


Src: 
function minValue ( n , x , y ) { let val = ( y * n ) / 100 ; if ( x >= val ) return 0 ; else return ( Math . ceil ( val ) - x ) ; }
Ref: 
int minValue ( int n , int x , int y ) { float val = ( y * n ) / 100 ; if ( x >= val ) return 0 ; else return ( ceil ( val ) - x ) ; }
Hyp: 
int minValue ( int n , int x , int y ) { float val = ( y * n ) / 100 ; if ( x >= val ) return 0 ; else return ( ceil ( val ) - x ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findMaxPairs ( a , b , n , k ) { a . sort ( function ( a , b ) { return a - b } ) ; b . sort ( function ( a , b ) { return a - b } ) ; let result = 0 ; for ( let i = 0 , j = 0 ; i < n && j < n ; ) { if ( Math . abs ( a [ i ] - b [ j ] ) <= k ) { result ++ ; i ++ ; j ++ ; } else if ( a [ i ] > b [ j ] ) j ++ ; else i ++ ; } return result ; }
Ref: 
ll findMaxPairs ( ll a [ ] , ll b [ ] , ll n , ll k ) { sort ( a , a + n ) ; sort ( b , b + n ) ; int result = 0 ; for ( int i = 0 , j = 0 ; i < n && j < n ; ) { if ( abs ( a [ i ] - b [ j ] ) <= k ) { result ++ ; i ++ ; j ++ ; } else if ( a [ i ] > b [ j ] ) j ++ ; else i ++ ; } return result ; }
Hyp: 
int findMaxPairs ( int a [ ] , int b [ ] , int n , int k ) { sort ( a , a + n ) ; sort ( b , b + n ) ; int result = 0 ; for ( int i = 0 , j = 0 ; i < n && j < n ; ) { if ( abs ( a [ i ] - b [ j ] ) <= k ) { result ++ ; i ++ ; j ++ ; } else if ( a [ i ] > b [ j ] ) j ++ ; else i ++ ; } return result ; }

BLEU: 90.89
Edit Sim: 15


Src: 
function smallestNum ( n ) { res = 1 ; for ( var i = 2 ; ; i *= 2 ) { var length = parseInt ( Math . log ( i ) / Math . log ( 10 ) ) + 1 ; if ( length == n ) return parseInt ( Math . log ( i ) / Math . log ( 2 ) ) ; } }
Ref: 
int smallestNum ( int n ) { int res = 1 ; for ( int i = 2 ; ; i *= 2 ) { int length = log10 ( i ) + 1 ; if ( length == n ) return log ( i ) / log ( 2 ) ; } }
Hyp: 
int smallestNum ( int n ) { int res = 1 ; for ( long long i = 2 ; ; i *= 2 ) { int length = log10 ( i ) + 1 ; if ( length == n ) return log2 ( i ) / log2 ( 2 ) ; } }

BLEU: 84.02
Edit Sim: 10


Src: 
function checkArrays ( arr1 , arr2 , N ) { let count = 0 ; let flag = true ; for ( let i = 0 ; i < N ; i ++ ) { if ( arr1 [ i ] != arr2 [ i ] ) { if ( arr1 [ i ] == 0 ) count ++ ; else { count -- ; if ( count < 0 ) { flag = false ; break ; } } } } if ( ( flag && ( count == 0 ) ) == true ) document . write ( " " ) ; else document . write ( " " ) ; }
Ref: 
void checkArrays ( int arr1 [ ] , int arr2 [ ] , int N ) { int count = 0 ; bool flag = true ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr1 [ i ] != arr2 [ i ] ) { if ( arr1 [ i ] == 0 ) count ++ ; else { count -- ; if ( count < 0 ) { flag = 0 ; break ; } } } } if ( flag && count == 0 ) cout << " Yes " << endl ; else cout << " No " << endl ; }
Hyp: 
void checkArrays ( int arr1 [ ] , int arr2 [ ] , int N ) { int count = 0 ; bool flag = true ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr1 [ i ] != arr2 [ i ] ) { if ( arr1 [ i ] == 0 ) count ++ ; else { count -- ; if ( count < 0 ) { flag = 0 ; break ; } } } } if ( ( flag && ( count == 0 ) ) == true ) cout << " Yes " ; else cout << " No " ; }

BLEU: 89.78
Edit Sim: 32


Src: 
function minimumLength ( s ) { var maxOcc = 0 , n = s . length ; var arr = Array ( 26 ) . fill ( 0 ) ; for ( var i = 0 ; i < n ; i ++ ) arr [ s [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; for ( var i = 0 ; i < 26 ; i ++ ) if ( arr [ i ] > maxOcc ) maxOcc = arr [ i ] ; return ( n - maxOcc ) ; }
Ref: 
int minimumLength ( string s ) { int maxOcc = 0 , n = s . length ( ) ; int arr [ 26 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) arr [ s [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < 26 ; i ++ ) if ( arr [ i ] > maxOcc ) maxOcc = arr [ i ] ; return ( n - maxOcc ) ; }
Hyp: 
int minimumLength ( string s ) { int maxOcc = 0 , n = s . length ( ) ; int * ptr = stackalloc ( 26 , 0 ) ; for ( int i = 0 ; i < n ; i ++ ) cout << ptr [ s [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < 26 ; i ++ ) if ( arr [ i ] > maxOcc ) maxOcc = arr [ i ] ; return ( n - maxOcc ) ; }

BLEU: 85.27
Edit Sim: 30


Src: 
function checkCount ( A , Q , q ) { for ( let i = 0 ; i < q ; i ++ ) { let L = Q [ i ] [ 0 ] ; let R = Q [ i ] [ 1 ] ; L -- ; R -- ; if ( ( A [ L ] < A [ L + 1 ] ) != ( A [ R - 1 ] < A [ R ] ) ) { document . write ( " " + " " ) ; } else { document . write ( " " + " " ) ; } } }
Ref: 
void checkCount ( int A [ ] , int Q [ ] [ 2 ] , int q ) { for ( int i = 0 ; i < q ; i ++ ) { int L = Q [ i ] [ 0 ] ; int R = Q [ i ] [ 1 ] ; L -- , R -- ; if ( ( A [ L ] < A [ L + 1 ] ) != ( A [ R - 1 ] < A [ R ] ) ) { cout << " Yes STRNEWLINE " ; } else { cout << " No STRNEWLINE " ; } } }
Hyp: 
void checkCount ( int A [ ] , int Q [ ] [ 2 ] , int q ) { for ( int i = 0 ; i < q ; i ++ ) { int L = Q [ i ] [ 0 ] ; int R = Q [ i ] [ 1 ] ; L -- ; R -- ; if ( ( A [ L ] < A [ L + 1 ] ) != ( A [ R - 1 ] < A [ R ] ) ) cout << " No " << endl ; else cout << " Yes " << endl ; } }

BLEU: 85.68
Edit Sim: 39


Src: 
function checkFactors ( N ) { let ev_count = 0 , od_count = 0 ; for ( let i = 1 ; i <= Math . sqrt ( N ) + 1 ; i ++ ) { if ( N % i == 0 ) { if ( i == Math . floor ( N / i ) ) { if ( i % 2 == 0 ) ev_count += 1 ; else od_count += 1 ; } else { if ( i % 2 == 0 ) ev_count += 1 ; else od_count += 1 ; if ( Math . floor ( N / i ) % 2 == 0 ) ev_count += 1 ; else od_count += 1 ; } } } if ( ev_count % 2 == 0 && od_count % 2 == 1 ) document . write ( " " + " " ) ; else document . write ( " " + " " ) ; }
Ref: 
void checkFactors ( lli N ) { lli ev_count = 0 , od_count = 0 ; for ( lli i = 1 ; i <= sqrt ( N ) + 1 ; i ++ ) { if ( N % i == 0 ) { if ( i == N / i ) { if ( i % 2 == 0 ) ev_count += 1 ; else od_count += 1 ; } else { if ( i % 2 == 0 ) ev_count += 1 ; else od_count += 1 ; if ( ( N / i ) % 2 == 0 ) ev_count += 1 ; else od_count += 1 ; } } } if ( ev_count % 2 == 0 && od_count % 2 == 1 ) cout << " Yes " << endl ; else cout << " No " << endl ; }
Hyp: 
void checkFactors ( int N ) { int ev_count = 0 , od_count = 0 ; for ( int i = 1 ; i <= sqrt ( N ) + 1 ; i ++ ) { if ( N % i == 0 ) { if ( i == N / i ) { if ( i % 2 == 0 ) ev_count += 1 ; else od_count += 1 ; } else { if ( i % 2 == 0 ) ev_count += 1 ; else od_count += 1 ; if ( N / i ) % 2 == 0 ) ev_count += 1 ; else od_count += 1 ; } } } if ( ev_count % 2 == 0 && od_count % 2 == 1 ) cout << " Yes " << endl ; else cout << " No " << endl ; }

BLEU: 93.62
Edit Sim: 11


Src: 
function countToMake0lternate ( s ) { let result = 0 ; for ( let i = 0 ; i < ( s . length - 1 ) ; i ++ ) if ( s [ i ] == s [ i + 1 ] ) return result ; }
Ref: 
void countToMake0lternate ( const string & s ) { int result = 0 ; for ( int i = 0 ; i < ( s . length ( ) - 1 ) ; i ++ ) if ( s [ i ] == s [ i + 1 ] ) return result ; }
Hyp: 
int countToMake0lternate ( string s ) { int result = 0 ; for ( int i = 0 ; i < ( s . length ( ) - 1 ) ; i ++ ) if ( s [ i ] == s [ i + 1 ] ) return result ; }

BLEU: 90.54
Edit Sim: 12


Src: 
function minCapacity ( enter , exit , n ) { let minCap = 0 ; let currCap = 0 ; for ( let i = 0 ; i < n ; i ++ ) { currCap = currCap + enter [ i ] - exit [ i ] ; minCap = Math . max ( minCap , currCap ) ; } return minCap ; }
Ref: 
int minCapacity ( int enter [ ] , int exit [ ] , int n ) { int minCap = 0 ; int currCap = 0 ; for ( int i = 0 ; i < n ; i ++ ) { currCap = currCap + enter [ i ] - exit [ i ] ; minCap = max ( minCap , currCap ) ; } return minCap ; }
Hyp: 
int minCapacity ( int enter [ ] , int exit [ ] , int n ) { int minCap = 0 ; int currCap = 0 ; for ( int i = 0 ; i < n ; i ++ ) { currCap = currCap + enter [ i ] - exit [ i ] ; minCap = max ( minCap , currCap ) ; } return minCap ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findAandB ( N ) { if ( N == 1 ) { document . write ( " " ) ; return ; } let a = N * N / ( N - 1 ) ; let b = a / N ; document . write ( " " + a + " " ) ; document . write ( " " + b + " " ) ; }
Ref: 
void findAandB ( double N ) { if ( N == 1 ) { cout << " No " ; return ; } double a = N * N / ( N - 1 ) ; double b = a / N ; cout << " a ▁ = ▁ " << a << endl ; cout << " b ▁ = ▁ " << b << endl ; }
Hyp: 
void findAandB ( int N ) { if ( N == 1 ) { cout << " NO " ; return ; } int a = N * N / ( N - 1 ) ; int b = a / N ; cout << " a ▁ = ▁ " << a << endl ; cout << " b ▁ = ▁ " << b << endl ; }

BLEU: 85.24
Edit Sim: 19


Src: 
function findNthTerm ( n ) { document . write ( n * ( 3 * n + 1 ) / 2 ) ; }
Ref: 
void findNthTerm ( int n ) { cout << n * ( 3 * n + 1 ) / 2 << endl ; }
Hyp: 
void findNthTerm ( int n ) { cout << n * ( 3 * n + 1 ) / 2 ; }

BLEU: 85.74
Edit Sim: 8


Src: 
function check_euler_four_square_identity ( a , b , ab ) { let s = 0 ; for ( let i = 0 ; i * i <= ab ; i ++ ) { s = i * i ; for ( let j = i ; j * j <= ab ; j ++ ) { s = j * j + i * i ; for ( let k = j ; k * k <= ab ; k ++ ) { s = k * k + j * j + i * i ; for ( let l = k ; l * l <= ab ; l ++ ) { s = l * l + k * k + j * j + i * i ; if ( s == ab ) { document . write ( " " + i + " " ) ; document . write ( " " + j + " " ) ; document . write ( " " + k + " " ) ; document . write ( " " + l + " " ) ; document . write ( " " + a + " " + b ) ; document . write ( " " + " " + " " + " " ) ; document . write ( ab + " " ) ; document . write ( i + " " + i + " " ) ; document . write ( j + " " + j + " " ) ; document . write ( k + " " + k + " " ) ; document . write ( l + " " + l + " " ) ; document . write ( " " ) ; } } } } } }
Ref: 
define show ( x )  cout << #x << " = " << x << " NEW_LINE " void check_euler_four_square_identity ( int a , int b , int ab ) { int s = 0 ; for ( int i = 0 ; i * i <= ab ; i ++ ) { s = i * i ; for ( int j = i ; j * j <= ab ; j ++ ) { s = j * j + i * i ; for ( int k = j ; k * k <= ab ; k ++ ) { s = k * k + j * j + i * i ; for ( int l = k ; l * l <= ab ; l ++ ) { s = l * l + k * k + j * j + i * i ; if ( s == ab ) { show ( i ) ; show ( j ) ; show ( k ) ; show ( l ) ; cout << " " << " Product ▁ of ▁ " << a << " ▁ and ▁ " << b ; cout << " ▁ can ▁ be ▁ written " << " ▁ as ▁ sum ▁ of ▁ squares ▁ of ▁ i , ▁ " << " j , ▁ k , ▁ l STRNEWLINE " ; cout << ab << " ▁ = ▁ " ; cout << i << " * " << i << " ▁ + ▁ " ; cout << j << " * " << j << " ▁ + ▁ " ; cout << k << " * " << k << " ▁ + ▁ " ; cout << l << " * " << l << " STRNEWLINE " ; cout << " STRNEWLINE " ; } } } } } }
Hyp: 
void check_euler_four_square_identity ( int a , int b , int ab ) { int s = 0 ; for ( int i = 0 ; i * i <= ab ; i ++ ) { s = i * i ; for ( int j = i ; j * j <= ab ; j ++ ) { s = j * j + i * i ; for ( int k = j ; k * k <= ab ; k ++ ) { s = k * k + j * j + i * i ; for ( int l = k ; l * l <= ab ; l ++ ) { s = l * l + k * k + j * j + i * i ; if ( s == ab ) { cout << " Yes " << i << " ▁ " << j << " ▁ " << k << " ▁ " << l << " STRNEWLINE " ; cout << " Yes " << a << " ▁ " << b ; cout << " No " << " STRNEWLINE " ; cout << " Yes STRNEWLINE " ; } } } } } }

BLEU: 52.74
Edit Sim: 341


Src: 
function Check_is_possible ( l , r , k ) { var div_count = ( r / k ) - ( l / k ) ; if ( l % k == 0 ) { div_count ++ ; } return ( div_count > 1 ) ; } var l = 30 , r = 70 , k = 10 ; if ( Check_is_possible ( l , r , k ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
Ref: 
int Check_is_possible ( int l , int r , int k ) { int div_count = ( r / k ) - ( l / k ) ; if ( l % k == 0 ) div_count ++ ; return ( div_count > 1 ) ; }
Hyp: 
bool Check_is_possible ( int l , int r , int k ) { int div_count = ( r / k ) - ( l / k ) ; if ( l % k == 0 ) { div_count ++ ; } return ( div_count > 1 ) ; }

BLEU: 87.38
Edit Sim: 8


Src: 
function prodSquare ( n ) { for ( i = 2 ; i * i <= n ; i ++ ) for ( j = 2 ; j <= n ; j ++ ) if ( i * i * j * j == n ) return true ; return false ; }
Ref: 
bool prodSquare ( int n ) { for ( long i = 2 ; i * i <= n ; i ++ ) for ( long j = 2 ; j <= n ; j ++ ) if ( i * i * j * j == n ) return true ; return false ; }
Hyp: 
bool prodSquare ( int n ) { for ( long i = 2 ; i * i <= n ; i ++ ) for ( long j = 2 ; j <= n ; j ++ ) if ( i * i * j * j == n ) return true ; return false ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function check ( n , marks ) { let x = Math . max ( ... marks ) ; let bonus = 100 - x ; let c = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( marks [ i ] + bonus >= 50 ) c += 1 ; } return c ; }
Ref: 
int check ( int n , int marks [ ] ) { int * x = std :: max_element ( marks , marks + 5 ) ; int bonus = 100 - ( int ) ( * x ) ; int c = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( marks [ i ] + bonus >= 50 ) c += 1 ; } return c ; }
Hyp: 
int check ( int n , int marks [ ] ) { int x = * max_element ( marks , marks + n ) ; int bonus = 100 - x ; int c = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( marks [ i ] + bonus >= 50 ) c += 1 ; } return c ; }

BLEU: 78.82
Edit Sim: 23


Src: 
function uniqueCharacters ( str ) { for ( let i = 0 ; i < str . length ; i ++ ) for ( let j = i + 1 ; j < str . length ; j ++ ) if ( str [ i ] == str [ j ] ) return false ; return true ; }
Ref: 
bool uniqueCharacters ( string str ) { for ( int i = 0 ; i < str . length ( ) - 1 ; i ++ ) { for ( int j = i + 1 ; j < str . length ( ) ; j ++ ) { if ( str [ i ] == str [ j ] ) { return false ; } } } return true ; }
Hyp: 
bool uniqueCharacters ( string str ) { for ( int i = 0 ; i < str . length ( ) ; i ++ ) for ( int j = i + 1 ; j < str . length ( ) ; j ++ ) if ( str [ i ] == str [ j ] ) return false ; return true ; }

BLEU: 77.28
Edit Sim: 16


Src: 
function checkEvenPower ( n ) { var low = 0 , high = n ; while ( low <= high ) { var mid = low + ( high - low ) / 2 ; var value = parseInt ( Math . pow ( 2 , mid ) ) ; if ( value == n ) { if ( mid % 2 == 1 ) return " " ; else return " " ; } else if ( value < n ) low = mid + 1 ; else high = mid - 1 ; } return " " ; }
Ref: 
string checkEvenPower ( int n ) { int low = 0 , high = n ; while ( low <= high ) { int mid = low + ( high - low ) / 2 ; int value = pow ( 2 , mid ) ; if ( value == n ) { if ( mid % 2 == 1 ) return " No " ; else return " Yes " ; } else if ( value < n ) low = mid + 1 ; else high = mid - 1 ; } return " No " ; }
Hyp: 
string checkEvenPower ( int n ) { int low = 0 , high = n ; while ( low <= high ) { int mid = low + ( high - low ) / 2 ; int value = pow ( 2 , mid ) ; if ( value == n ) { if ( mid % 2 == 1 ) return " Even " ; else return " Odd " ; } else if ( value < n ) low = mid + 1 ; else high = mid - 1 ; } return " No " ; }

BLEU: 94.92
Edit Sim: 7


Src: 
function getSingle ( arr , n ) { let ones = 0 , twos = 0 ; let common_bit_mask ; for ( let i = 0 ; i < n ; i ++ ) { twos = twos | ( ones & arr [ i ] ) ; ones = ones ^ arr [ i ] ; common_bit_mask = ~ ( ones & twos ) ; ones &= common_bit_mask ; twos &= common_bit_mask ; } return ones ; }
Ref: 
int getSingle ( int arr [ ] , int n ) { int ones = 0 , twos = 0 ; int common_bit_mask ; for ( int i = 0 ; i < n ; i ++ ) { twos = twos | ( ones & arr [ i ] ) ; ones = ones ^ arr [ i ] ; common_bit_mask = ~ ( ones & twos ) ; ones &= common_bit_mask ; twos &= common_bit_mask ; } return ones ; }
Hyp: 
int getSingle ( int arr [ ] , int n ) { int ones = 0 , twos = 0 ; int common_bit_mask ; for ( int i = 0 ; i < n ; i ++ ) { twos = twos | ( ones & arr [ i ] ) ; ones = ones ^ arr [ i ] ; common_bit_mask = ~ ( ones & twos ) ; ones &= common_bit_mask ; twos &= common_bit_mask ; } return ones ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function printSubsets ( n ) { for ( let i = n ; i > 0 ; i = ( i - 1 ) & n ) document . write ( i + " " ) ; document . write ( " " + " " ) ; }
Ref: 
void printSubsets ( int n ) { for ( int i = n ; i > 0 ; i = ( i - 1 ) & n ) cout << i << " ▁ " ; cout << 0 ; }
Hyp: 
void printSubsets ( int n ) { for ( int i = n ; i > 0 ; i = ( i - 1 ) & n ) cout << i << " ▁ " ; cout << " STRNEWLINE " ; }

BLEU: 89.92
Edit Sim: 14


Src: 
function findNthTerm ( n ) { document . write ( n * n - n + 1 ) ; }
Ref: 
void findNthTerm ( int n ) { cout << n * n - n + 1 << endl ; }
Hyp: 
void findNthTerm ( int n ) { cout << n * n - n + 1 ; }

BLEU: 82.69
Edit Sim: 8


Src: 
function reorder ( arr , index , n ) { var temp = [ ... Array ( n ) ] ; for ( var i = 0 ; i < n ; i ++ ) temp [ index [ i ] ] = arr [ i ] ; for ( var i = 0 ; i < n ; i ++ ) { arr [ i ] = temp [ i ] ; index [ i ] = i ; } }
Ref: 
void reorder ( int arr [ ] , int index [ ] , int n ) { int temp [ n ] ; for ( int i = 0 ; i < n ; i ++ ) temp [ index [ i ] ] = arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = temp [ i ] ; index [ i ] = i ; } }
Hyp: 
void reorder ( int arr [ ] , int index [ ] , int n ) { int temp [ n ] ; for ( int i = 0 ; i < n ; i ++ ) temp [ index [ i ] ] = arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = temp [ i ] ; index [ i ] = i ; } }

BLEU: 100.0
Edit Sim: 0


Src: 
function allBitsSetInTheGivenRange ( n , l , r ) { let num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ; let new_num = n & num ; if ( new_num == 0 ) return true ; return false ; }
Ref: 
bool allBitsSetInTheGivenRange ( unsigned int n , unsigned int l , unsigned int r ) { int num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ; int new_num = n & num ; if ( new_num == 0 ) return true ; return false ; }
Hyp: 
bool allBitsSetInTheGivenRange ( int n , int l , int r ) { int num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ; int new_num = n & num ; if ( new_num == 0 ) return true ; return false ; }

BLEU: 87.65
Edit Sim: 27


Src: 
function smallestSumSubarr ( arr , n ) { let min_ending_here = 2147483647 ; let min_so_far = 2147483647 ; for ( let i = 0 ; i < n ; i ++ ) { if ( min_ending_here > 0 ) min_ending_here = arr [ i ] ; else min_ending_here += arr [ i ] ; min_so_far = Math . min ( min_so_far , min_ending_here ) ; } return min_so_far ; }
Ref: 
int smallestSumSubarr ( int arr [ ] , int n ) { int min_ending_here = INT_MAX ; int min_so_far = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { if ( min_ending_here > 0 ) min_ending_here = arr [ i ] ; else min_ending_here += arr [ i ] ; min_so_far = min ( min_so_far , min_ending_here ) ; } return min_so_far ; }
Hyp: 
int smallestSumSubarr ( int arr [ ] , int n ) { int min_ending_here = 2147483647 ; int min_so_far = 2147483647 ; for ( int i = 0 ; i < n ; i ++ ) { if ( min_ending_here > 0 ) min_ending_here = arr [ i ] ; else min_ending_here += arr [ i ] ; min_so_far = min ( min_so_far , min_ending_here ) ; } return min_so_far ; }

BLEU: 92.9
Edit Sim: 20


Src: 
function clearBit ( num , i ) { let mask = ~ ( 1 << i ) ; return num & mask ; }
Ref: 
int clearBit ( int num , int i ) { int mask = ~ ( 1 << i ) ; return num & mask ; }
Hyp: 
int clearBit ( int num , int i ) { int mask = ~ ( 1 << i ) ; return num & mask ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function totalSumDivisibleByNum ( n , number ) { let firstnum = Math . pow ( 10 , n - 1 ) ; let lastnum = Math . pow ( 10 , n ) ; let sum = 0 ; for ( let i = firstnum ; i < lastnum ; i ++ ) if ( i % number == 0 ) sum += i ; return sum ; }
Ref: 
int totalSumDivisibleByNum ( int n , int number ) { int firstnum = pow ( 10 , n - 1 ) ; int lastnum = pow ( 10 , n ) ; int sum = 0 ; for ( int i = firstnum ; i < lastnum ; i ++ ) if ( i % number == 0 ) sum += i ; return sum ; }
Hyp: 
int totalSumDivisibleByNum ( int n , int number ) { int firstnum = pow ( 10 , n - 1 ) ; int lastnum = pow ( 10 , n ) ; int sum = 0 ; for ( int i = firstnum ; i < lastnum ; i ++ ) if ( i % number == 0 ) sum += i ; return sum ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countX ( a , b ) { if ( b > a ) return 0 ; else if ( a == b ) return - 1 ; else { let x = a - b , ans = 0 ; for ( let i = 1 ; i * i <= x ; i ++ ) { if ( x % i == 0 ) { let d1 = i , d2 = b - 1 ; if ( i * i != x ) d2 = parseInt ( x / i ) ; if ( d1 > b ) ans ++ ; if ( d2 > b ) ans ++ ; } } return ans ; } }
Ref: 
int countX ( int a , int b ) { if ( b > a ) return 0 ; else if ( a == b ) return -1 ; else { int x = a - b , ans = 0 ; for ( int i = 1 ; i * i <= x ; i ++ ) { if ( x % i == 0 ) { int d1 = i , d2 = b - 1 ; if ( i * i != x ) d2 = x / i ; if ( d1 > b ) ans ++ ; if ( d2 > b ) ans ++ ; } } return ans ; } }
Hyp: 
int countX ( int a , int b ) { if ( b > a ) return 0 ; else if ( a == b ) return -1 ; else { int x = a - b , ans = 0 ; for ( int i = 1 ; i * i <= x ; i ++ ) { if ( x % i == 0 ) { int d1 = i , d2 = b - 1 ; if ( i * i != x ) d2 = x / i ; if ( d1 > b ) ans ++ ; if ( d2 > b ) ans ++ ; } } return ans ; } }

BLEU: 100.0
Edit Sim: 0


Src: 
function findWays ( f , d , s ) { let mem = new Array ( d + 1 ) ; for ( let i = 0 ; i < ( d + 1 ) ; i ++ ) { mem [ i ] = new Array ( s + 1 ) ; for ( let j = 0 ; j < s + 1 ; j ++ ) { mem [ i ] [ j ] = 0 ; } } mem [ 0 ] [ 0 ] = 1 ; for ( let i = 1 ; i <= d ; i ++ ) { for ( let j = i ; j <= s ; j ++ ) { mem [ i ] [ j ] = mem [ i ] [ j - 1 ] + mem [ i - 1 ] [ j - 1 ] ; if ( j - f - 1 >= 0 ) mem [ i ] [ j ] -= mem [ i - 1 ] [ j - f - 1 ] ; } } return mem [ d ] [ s ] ; }
Ref: 
long findWays ( int f , int d , int s ) { long mem [ d + 1 ] [ s + 1 ] ; memset ( mem , 0 , sizeof mem ) ; mem [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= d ; i ++ ) { for ( int j = i ; j <= s ; j ++ ) { mem [ i ] [ j ] = mem [ i ] [ j - 1 ] + mem [ i - 1 ] [ j - 1 ] ; if ( j - f - 1 >= 0 ) mem [ i ] [ j ] -= mem [ i - 1 ] [ j - f - 1 ] ; } } return mem [ d ] [ s ] ; }
Hyp: 
int findWays ( int f , int d , int s ) { int mem [ d + 1 ] [ s + 1 ] ; mem [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= d ; i ++ ) { for ( int j = i ; j <= s ; j ++ ) { mem [ i ] [ j ] = mem [ i ] [ j - 1 ] + mem [ i - 1 ] [ j - 1 ] ; if ( j - f - 1 >= 0 ) mem [ i ] [ j ] -= mem [ i - 1 ] [ j - f - 1 ] ; } } return mem [ d ] [ s ] ; }

BLEU: 90.25
Edit Sim: 40


Src: 
function SubArraySum ( arr , n ) { let result = 0 , temp = 0 ; for ( let i = 0 ; i < n ; i ++ ) { temp = 0 ; for ( let j = i ; j < n ; j ++ ) { temp += arr [ j ] ; result += temp ; } } return result ; }
Ref: 
int SubArraySum ( int arr [ ] , int n ) { long int result = 0 , temp = 0 ; for ( int i = 0 ; i < n ; i ++ ) { temp = 0 ; for ( int j = i ; j < n ; j ++ ) { temp += arr [ j ] ; result += temp ; } } return result ; }
Hyp: 
int SubArraySum ( int arr [ ] , int n ) { int result = 0 , temp = 0 ; for ( int i = 0 ; i < n ; i ++ ) { temp = 0 ; for ( int j = i ; j < n ; j ++ ) { temp += arr [ j ] ; result += temp ; } } return result ; }

BLEU: 96.51
Edit Sim: 5


Src: 
function squarearea ( a , b ) { if ( a < 0 b < 0 ) return - 1 ; var area = 4 * ( ( Math . pow ( a , 2 ) + Math . pow ( b , 2 ) ) / ( Math . pow ( a , 2 ) * Math . pow ( b , 2 ) ) ) ; return area ; }
Ref: 
float squarearea ( float a , float b ) { if ( a < 0 b < 0 ) return -1 ; float area = 4 * ( ( pow ( a , 2 ) + pow ( b , 2 ) ) / ( pow ( a , 2 ) * pow ( b , 2 ) ) ) ; return area ; }
Hyp: 
float squarearea ( float a , float b ) { if ( a < 0 b < 0 ) return -1 ; float area = 4 * ( ( pow ( a , 2 ) + pow ( b , 2 ) ) / ( pow ( a , 2 ) * pow ( b , 2 ) ) ) ; return area ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function OddLengthSum ( arr ) { var sum = 0 ; var l = arr . length ; for ( var i = 0 ; i < l ; i ++ ) { for ( var j = i ; j < l ; j += 2 ) { for ( var k = i ; k <= j ; k ++ ) { sum += arr [ k ] ; } } } return sum ; }
Ref: 
int OddLengthSum ( vector < int > & arr ) { int sum = 0 ; int l = arr . size ( ) ; for ( int i = 0 ; i < l ; i ++ ) { for ( int j = i ; j < l ; j += 2 ) { for ( int k = i ; k <= j ; k ++ ) { sum += arr [ k ] ; } } } return sum ; }
Hyp: 
int OddLengthSum ( int arr [ ] , int n ) { int sum = 0 ; int l = n - 1 ; for ( int i = 0 ; i < l ; i ++ ) { for ( int j = i ; j < l ; j += 2 ) { for ( int k = i ; k <= j ; k ++ ) { sum += arr [ k ] ; } } } return sum ; }

BLEU: 83.9
Edit Sim: 28


Src: 
function countSubstrig ( str1 , str2 ) { let n1 = str1 . length ; let n2 = str2 . length ; if ( n1 == 0 n1 < n2 ) return 0 ; if ( str1 . substr ( 0 , n2 ) == ( str2 ) ) return countSubstrig ( str1 . substr ( n2 - 1 ) , str2 ) + 1 ; return countSubstrig ( str1 . substr ( n2 - 1 ) , str2 ) ; }
Ref: 
int countSubstrig ( string str1 , string str2 ) { int n1 = str1 . length ( ) ; int n2 = str2 . length ( ) ; if ( n1 == 0 n1 < n2 ) return 0 ; if ( str1 . substr ( 0 , n2 ) . compare ( str2 ) == 0 ) return countSubstrig ( str1 . substr ( n2 - 1 ) , str2 ) + 1 ; return countSubstrig ( str1 . substr ( n2 - 1 ) , str2 ) ; }
Hyp: 
int countSubstrig ( string str1 , string str2 ) { int n1 = str1 . length ( ) ; int n2 = str2 . length ( ) ; if ( n1 == 0 n1 < n2 ) return 0 ; if ( str1 . substr ( 0 , n2 ) == ( str2 ) ) return countSubstrig ( str1 . substr ( n2 - 1 ) , str2 ) + 1 ; return countSubstrig ( str1 . substr ( n2 - 1 ) , str2 ) ; }

BLEU: 92.69
Edit Sim: 14


Src: 
function findArea ( a , b , c ) { let area = 4 * 3.141592653 * Math . pow ( ( Math . pow ( a * b , 1.6 ) + Math . pow ( a * c , 1.6 ) + Math . pow ( b * c , 1.6 ) ) / 3 , 1 / 1.6 ) ; document . write ( area . toPrecision ( 6 ) ) ; }
Ref: 
void findArea ( double a , double b , double c ) { double area = 4 * 3.141592653 * pow ( ( pow ( a * b , 1.6 ) + pow ( a * c , 1.6 ) + pow ( b * c , 1.6 ) ) / 3 , 1 / 1.6 ) ; cout << fixed << setprecision ( 2 ) << area ; }
Hyp: 
void findArea ( double a , double b , double c ) { double area = 4 * 3.141592653 * pow ( ( pow ( a * b , 1.6 ) + pow ( a * c , 1.6 ) + pow ( b * c , 1.6 ) ) / 3 , 1 / 1.6 ) ; cout << area ; }

BLEU: 88.38
Edit Sim: 31


Src: 
function lengtang ( r1 , r2 ) { document . write ( " " + " " + ( 2 * Math . sqrt ( r1 * r2 ) ) . toFixed ( 5 ) ) ; }
Ref: 
void lengtang ( double r1 , double r2 ) { cout << " The ▁ length ▁ of ▁ the ▁ " << " direct ▁ common ▁ tangent ▁ is ▁ " << 2 * sqrt ( r1 * r2 ) << endl ; }
Hyp: 
void lengtang ( double r1 , double r2 ) { cout << " The ▁ length ▁ of ▁ the ▁ longest ▁ chord " << " ▁ or ▁ diameter ▁ of ▁ the ▁ circle ▁ is ▁ " << sqrt ( r1 * r2 ) << endl ; }

BLEU: 66.26
Edit Sim: 47


Src: 
function printRectPattern ( c1 , c2 , n ) { for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { document . write ( Math . max ( Math . abs ( c1 - i ) , Math . abs ( c2 - j ) ) + " " ) ; } document . write ( " " ) ; } }
Ref: 
void printRectPattern ( int c1 , int c2 , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { cout << ( max ( abs ( c1 - i ) , abs ( c2 - j ) ) ) << " ▁ " ; } cout << endl ; } }
Hyp: 
void printRectPattern ( int c1 , int c2 , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { cout << max ( abs ( c1 - i ) , abs ( c2 - j ) ) << " ▁ " ; } cout << endl ; } }

BLEU: 94.9
Edit Sim: 4


Src: 
function findNthTerm ( N ) { let ans = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( i % 2 == 0 ) { ans = ans + 6 ; } else { ans = ans + 2 ; } } document . write ( ans + " " ) ; }
Ref: 
void findNthTerm ( int N ) { int ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( i % 2 == 0 ) { ans = ans + 6 ; } else { ans = ans + 2 ; } } cout << ans << endl ; }
Hyp: 
void findNthTerm ( int N ) { int ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( i % 2 == 0 ) { ans = ans + 6 ; } else { ans = ans + 2 ; } } cout << ans << endl ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function polite ( n ) { n += 1 ; let base = 2 ; return n + ( Math . log ( ( n + ( Math . log ( n ) / Math . log ( base ) ) ) ) ) / Math . log ( base ) ; }
Ref: 
double polite ( double n ) { n += 1 ; double base = 2 ; return n + ( log ( ( n + ( log ( n ) / log ( base ) ) ) ) ) / log ( base ) ; }
Hyp: 
double polite ( int n ) { n += 1 ; int base = 2 ; return n + ( log ( ( n + ( log ( n ) / log ( base ) ) ) ) / log ( base ) ) ; }

BLEU: 85.69
Edit Sim: 16


Src: 
function check ( a , b , Na , Nb , k , m ) { if ( Na < k Nb < m ) return " " ; a . sort ( ) ; b . sort ( ) ; if ( a [ k - 1 ] < b [ Nb - m ] ) { return " " ; } return " " ; }
Ref: 
string check ( int a [ ] , int b [ ] , int Na , int Nb , int k , int m ) { if ( Na < k Nb < m ) return " No " ; sort ( a , a + Na ) ; sort ( b , b + Nb ) ; if ( a [ k - 1 ] < b [ Nb - m ] ) { return " Yes " ; } return " No " ; }
Hyp: 
string check ( int a [ ] , int b [ ] , int Na , int Nb , int k , int m ) { if ( Na < k Nb < m ) return " " ; sort ( a , a + N ) ; sort ( b , b + N ) ; if ( a [ k - 1 ] < b [ Nb - m ] ) { return " Yes " ; } return " No " ; }

BLEU: 91.19
Edit Sim: 5


Src: 
function countofPermutations ( N ) { return parseInt ( 3 * Math . pow ( 2 , N - 1 ) ) ; }
Ref: 
int countofPermutations ( int N ) { return int ( 3 * pow ( 2 , N - 1 ) ) ; }
Hyp: 
int countofPermutations ( int N ) { return 3 * pow ( 2 , N - 1 ) ; }

BLEU: 75.04
Edit Sim: 8


Src: 
function find_Solution ( x , n ) { let sum = x , e = 2 , o = 1 , p = 1 ; for ( let i = 2 ; i <= n ; i ++ ) { p += 2 ; sum += ( o / e ) * ( Math . pow ( x , p ) / p ) ; o = o * ( o + 2 ) ; e = e * ( e + 2 ) ; } document . write ( sum . toFixed ( 10 ) ) ; } let x = - 0.5 ; if ( Math . abs ( x ) >= 1 ) { document . write ( " " ) ; }
Ref: 
void find_Solution ( double x , int n ) { double sum = x , e = 2 , o = 1 , p = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { p += 2 ; sum += ( double ) ( o / e ) * ( double ) ( pow ( x , p ) / p ) ; o = o * ( o + 2 ) ; e = e * ( e + 2 ) ; } cout << setprecision ( 10 ) << sum ; }
Hyp: 
void find_Solution ( float x , int n ) { float sum = x , e = 2 , o = 1 , p = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { p += 2 ; sum += ( o / e ) * ( pow ( x , p ) / p ) ; o = o * ( o + 2 ) ; e = e * ( e + 2 ) ; } cout << sum ; }

BLEU: 81.32
Edit Sim: 57


Src: 
function countPairsWithDiffK ( arr , n , k ) { count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] - arr [ j ] == k arr [ j ] - arr [ i ] == k ) count ++ ; } return count ; }
Ref: 
int countPairsWithDiffK ( int arr [ ] , int n , int k ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] - arr [ j ] == k arr [ j ] - arr [ i ] == k ) count ++ ; } return count ; }
Hyp: 
int countPairsWithDiffK ( int arr [ ] , int n , int k ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] - arr [ j ] == k arr [ j ] - arr [ i ] == k ) count ++ ; } return count ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countLattice ( r ) { if ( r <= 0 ) return 0 ; var result = 4 ; for ( x = 1 ; x < r ; x ++ ) { var ySquare = r * r - x * x ; var y = parseInt ( Math . sqrt ( ySquare ) ) ; if ( y * y == ySquare ) result += 4 ; } return result ; }
Ref: 
int countLattice ( int r ) { if ( r <= 0 ) return 0 ; int result = 4 ; for ( int x = 1 ; x < r ; x ++ ) { int ySquare = r * r - x * x ; int y = sqrt ( ySquare ) ; if ( y * y == ySquare ) result += 4 ; } return result ; }
Hyp: 
int countLattice ( int r ) { if ( r <= 0 ) return 0 ; int result = 4 ; for ( int x = 1 ; x < r ; x ++ ) { long double ySquare = r * r - x * x ; long double y = sqrt ( ySquare ) ; if ( y * y == ySquare ) result += 4 ; } return result ; }

BLEU: 90.37
Edit Sim: 20


Src: 
function countPairs ( A , n , k ) { var ans = 0 ; A . sort ( ( a , b ) => a - b ) for ( var i = 0 ; i < n ; i ++ ) { for ( var j = i + 1 ; j < n ; j ++ ) { var x = 0 ; while ( ( A [ i ] * Math . pow ( k , x ) ) <= A [ j ] ) { if ( ( A [ i ] * Math . pow ( k , x ) ) == A [ j ] ) { ans ++ ; break ; } x ++ ; } } } return ans ; }
Ref: 
int countPairs ( int A [ ] , int n , int k ) { int ans = 0 ; sort ( A , A + n ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int x = 0 ; while ( ( A [ i ] * pow ( k , x ) ) <= A [ j ] ) { if ( ( A [ i ] * pow ( k , x ) ) == A [ j ] ) { ans ++ ; break ; } x ++ ; } } } return ans ; }
Hyp: 
int countPairs ( int A [ ] , int n , int k ) { int ans = 0 ; sort ( A , A + n ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int x = 0 ; while ( ( A [ i ] * pow ( k , x ) ) <= A [ j ] ) { if ( ( A [ i ] * pow ( k , x ) ) == A [ j ] ) { ans ++ ; break ; } x ++ ; } } } return ans ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function search ( ar , size ) { let a = 0 , b = size - 1 ; let mid = 0 ; while ( ( b - a ) > 1 ) { mid = ( a + b ) / 2 ; if ( ( ar [ a ] - a ) != ( ar [ mid ] - mid ) ) b = mid ; else if ( ( ar [ b ] - b ) != ( ar [ mid ] - mid ) ) a = mid ; } return ( ar [ a ] + 3 ) ; }
Ref: 
int search ( int ar [ ] , int size ) { int a = 0 , b = size - 1 ; int mid ; while ( ( b - a ) > 1 ) { mid = ( a + b ) / 2 ; if ( ( ar [ a ] - a ) != ( ar [ mid ] - mid ) ) b = mid ; else if ( ( ar [ b ] - b ) != ( ar [ mid ] - mid ) ) a = mid ; } return ( ar [ a ] + 1 ) ; }
Hyp: 
int search ( int ar [ ] , int size ) { int a = 0 , b = size - 1 ; int mid = 0 ; while ( ( b - a ) > 1 ) { mid = ( a + b ) / 2 ; if ( ( ar [ a ] - a ) != ( ar [ mid ] - mid ) ) b = mid ; else if ( ( ar [ b ] - b ) != ( ar [ mid ] - mid ) ) a = mid ; } return ( ar [ a ] + 3 ) ; }

BLEU: 94.48
Edit Sim: 5


Src: 
function lexo_small ( n , k ) { var arr = Array . from ( { length : n } , ( _ , i ) => ' ' ) ; for ( var i = n - 1 ; i >= 0 ; i -- ) { k -= i ; if ( k >= 0 ) { if ( k >= 26 ) { arr [ i ] = ' ' ; k -= 26 ; } else { arr [ i ] = String . fromCharCode ( k + 97 - 1 ) ; k -= arr [ i ] - ' ' + 1 ; } } else break ; k += i ; } return arr ; }
Ref: 
string lexo_small ( int n , int k ) { string arr = " " ; for ( int i = 0 ; i < n ; i ++ ) arr += ' a ' ; for ( int i = n - 1 ; i >= 0 ; i -- ) { k -= i ; if ( k >= 0 ) { if ( k >= 26 ) { arr [ i ] = ' z ' ; k -= 26 ; } else { char c = ( char ) ( k + 97 - 1 ) ; arr [ i ] = c ; k -= arr [ i ] - ' a ' + 1 ; } } else break ; k += i ; } return arr ; }
Hyp: 
char lexo_small ( int n , int k ) { char arr [ n ] ; for ( int i = n - 1 ; i >= 0 ; i -- ) { k -= i ; if ( k >= 0 ) { if ( k >= 26 ) { arr [ i ] = ' A ' ; k -= 26 ; } else { arr [ i ] = char ( k + 97 - 1 ) ; k -= arr [ i ] - ' A ' + 1 ; } } else break ; k += i ; } return arr ; }

BLEU: 65.98
Edit Sim: 89


Src: 
function sum ( N ) { var S1 , S2 , S3 ; S1 = ( ( ( N / 2 ) ) * parseInt ( 2 * 2 + parseInt ( N / 2 - 1 ) * 2 ) / 2 ) ; S2 = ( parseInt ( parseInt ( N / 7 ) ) * ( 2 * 7 + parseInt ( N / 7 - 1 ) * 7 ) / 2 ) ; S3 = ( parseInt ( parseInt ( N / 14 ) ) * ( 2 * 14 + parseInt ( N / 14 - 1 ) * 14 ) / 2 ) ; return S1 + S2 - S3 ; }
Ref: 
int sum ( int N ) { int S1 , S2 , S3 ; S1 = ( ( N / 2 ) ) * ( 2 * 2 + ( N / 2 - 1 ) * 2 ) / 2 ; S2 = ( ( N / 7 ) ) * ( 2 * 7 + ( N / 7 - 1 ) * 7 ) / 2 ; S3 = ( ( N / 14 ) ) * ( 2 * 14 + ( N / 14 - 1 ) * 14 ) / 2 ; return S1 + S2 - S3 ; }
Hyp: 
ll sum ( int N ) { ll S1 , S2 , S3 ; S1 = ( ( N / 2 ) ) * ( 2 * 2 + ( N / 2 - 1 ) * 2 ) / 2 ; S2 = ( ( N / 7 ) ) * ( 2 * 7 + ( N / 7 - 1 ) * 7 ) / 2 ; S3 = ( ( N / 14 ) ) * ( 2 * 14 + ( N / 14 - 1 ) * 14 ) / 2 ) ; return S1 + S2 - S3 ; }

BLEU: 94.32
Edit Sim: 8


Src: 
function pendulumArrangement ( arr , n ) { arr . sort ( function ( a , b ) { return a - b ; } ) ; var op = [ ... Array ( n ) ] ; var mid = parseInt ( ( n - 1 ) / 2 ) ; var j = 1 , i = 1 ; op [ mid ] = arr [ 0 ] ; for ( i = 1 ; i <= mid ; i ++ ) { op [ mid + i ] = arr [ j ++ ] ; op [ mid - i ] = arr [ j ++ ] ; } if ( n % 2 == 0 ) op [ mid + i ] = arr [ j ] ; document . write ( " " ) ; for ( i = 0 ; i < n ; i ++ ) document . write ( op [ i ] + " " ) ; document . write ( " " ) ; }
Ref: 
void pendulumArrangement ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int op [ n ] ; int mid = ( n - 1 ) / 2 ; int j = 1 , i = 1 ; op [ mid ] = arr [ 0 ] ; for ( i = 1 ; i <= mid ; i ++ ) { op [ mid + i ] = arr [ j ++ ] ; op [ mid - i ] = arr [ j ++ ] ; } if ( n % 2 == 0 ) op [ mid + i ] = arr [ j ] ; cout << " Pendulum ▁ arrangement : " << endl ; for ( i = 0 ; i < n ; i ++ ) cout << op [ i ] << " ▁ " ; cout << endl ; }
Hyp: 
void pendulumArrangement ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int op [ n ] ; int mid = ( n - 1 ) / 2 ; int j = 1 , i = 1 ; op [ mid ] = arr [ 0 ] ; for ( i = 1 ; i <= mid ; i ++ ) { op [ mid + i ] = arr [ j ++ ] ; op [ mid - i ] = arr [ j ++ ] ; } if ( n % 2 == 0 ) op [ mid + i ] = arr [ j ] ; cout << " Pendulum ▁ arrangement : " << endl ; for ( i = 0 ; i < n ; i ++ ) cout << op [ i ] << " ▁ " ; cout << endl ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countNumbers ( n ) { return n - parseInt ( n / 2 , 10 ) - parseInt ( n / 3 , 10 ) - parseInt ( n / 5 , 10 ) - parseInt ( n / 7 , 10 ) + parseInt ( n / 6 , 10 ) + parseInt ( n / 10 , 10 ) + parseInt ( n / 14 , 10 ) + parseInt ( n / 15 , 10 ) + parseInt ( n / 21 , 10 ) + parseInt ( n / 35 , 10 ) - parseInt ( n / 30 , 10 ) - parseInt ( n / 42 , 10 ) - parseInt ( n / 70 , 10 ) - parseInt ( n / 105 , 10 ) + parseInt ( n / 210 , 10 ) ; }
Ref: 
int countNumbers ( int n ) { return n - n / 2 - n / 3 - n / 5 - n / 7 + n / 6 + n / 10 + n / 14 + n / 15 + n / 21 + n / 35 - n / 30 - n / 42 - n / 70 - n / 105 + n / 210 ; }
Hyp: 
int countNumbers ( int n ) { return n - n / 2 , 10 ) - n / 3 , 10 ) - n / 5 , 10 ) - n / 7 , 10 ) + ( n / 10 , 10 ) + ( n / 14 , 10 ) + ( n / 15 , 10 ) + ( n / 21 , 10 ) + int ( n / 35 , 10 ) - n / 30 , 10 ) - n / 42 , 10 ) - n / 70 , 10 ) - n / 105 , 10 ) + n / 210 ; }

BLEU: 35.48
Edit Sim: 102


Src: 
function maxProd ( N ) { if ( N == 0 ) return 1 ; if ( N < 10 ) return N ; return Math . max ( maxProd ( parseInt ( N / 10 ) ) * ( N % 10 ) , maxProd ( parseInt ( N / 10 ) - 1 ) * 9 ) ; }
Ref: 
int maxProd ( int N ) { if ( N == 0 ) return 1 ; if ( N < 10 ) return N ; return max ( maxProd ( N / 10 ) * ( N % 10 ) , maxProd ( N / 10 - 1 ) * 9 ) ; }
Hyp: 
int maxProd ( int N ) { if ( N == 0 ) return 1 ; if ( N < 10 ) return N ; return max ( maxProd ( N / 10 ) ) * ( N % 10 ) , maxProd ( N / 10 - 1 ) * 9 ) ; }

BLEU: 96.74
Edit Sim: 2


Src: 
function findNumbers ( s ) { var n = s . length ; var count = 1 ; var result = 0 ; var left = 0 ; var right = 1 ; while ( right < n ) { if ( s [ left ] == s [ right ] ) { count ++ ; } else { result += parseInt ( count * ( count + 1 ) / 2 ) ; left = right ; count = 1 ; } right ++ ; } result += parseInt ( count * ( count + 1 ) / 2 ) ; document . write ( result ) ; }
Ref: 
void findNumbers ( string s ) { if ( s . empty ( ) ) return 0 ; int n = s . size ( ) ; int count = 1 ; int result = 0 ; int left = 0 ; int right = 1 ; while ( right < n ) { if ( s [ left ] == s [ right ] ) { count ++ ; } else { result += count * ( count + 1 ) / 2 ; left = right ; count = 1 ; } right ++ ; } result += count * ( count + 1 ) / 2 ; cout << result << endl ; }
Hyp: 
void findNumbers ( string s ) { int n = s . length ( ) ; int count = 1 ; int result = 0 ; int left = 0 ; int right = 1 ; while ( right < n ) { if ( s [ left ] == s [ right ] ) { count ++ ; } else { result += count * ( count + 1 ) / 2 ; left = right ; count = 1 ; } right ++ ; } result += count * ( count + 1 ) / 2 ; cout << result << endl ; }

BLEU: 86.68
Edit Sim: 38


Src: 
function removeElements ( arr , n ) { let brr = new Array ( n ) ; brr . fill ( 0 ) ; let l = 1 ; brr [ 0 ] = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { if ( brr [ l - 1 ] <= arr [ i ] ) { brr [ l ] = arr [ i ] ; l ++ ; } } for ( let i = 0 ; i < l ; i ++ ) document . write ( brr [ i ] + " " ) ; }
Ref: 
void removeElements ( int arr [ ] , int n ) { int brr [ n ] , l = 1 ; brr [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( brr [ l - 1 ] <= arr [ i ] ) { brr [ l ] = arr [ i ] ; l ++ ; } } for ( int i = 0 ; i < l ; i ++ ) cout << brr [ i ] << " ▁ " ; }
Hyp: 
void removeElements ( int arr [ ] , int n ) { int brr [ n ] ; brr [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( brr [ l - 1 ] <= arr [ i ] ) { brr [ l ] = arr [ i ] ; l ++ ; } } for ( int i = 0 ; i < l ; i ++ ) cout << brr [ i ] << " ▁ " ; }

BLEU: 94.56
Edit Sim: 8


Src: 
function alternate ( a , b , x ) { return x = a ^ b ^ x ; }
Ref: 
void alternate ( int & a , int & b , int & x ) { x = a ^ b ^ x ; }
Hyp: 
int alternate ( int a , int b , int x ) { return x = a ^ b ^ x ; }

BLEU: 54.31
Edit Sim: 17


Src: 
function printNum ( L , R ) { for ( let i = L ; i <= R ; i ++ ) { let temp = i ; let c = 10 ; let flag = 0 ; while ( temp > 0 ) { if ( temp % 10 >= c ) { flag = 1 ; break ; } c = temp % 10 ; temp /= 10 ; } if ( flag == 0 ) document . write ( i + " " ) ; } }
Ref: 
void printNum ( int L , int R ) { for ( int i = L ; i <= R ; i ++ ) { int temp = i ; int c = 10 ; int flag = 0 ; while ( temp > 0 ) { if ( temp % 10 >= c ) { flag = 1 ; break ; } c = temp % 10 ; temp /= 10 ; } if ( flag == 0 ) cout << i << " ▁ " ; } }
Hyp: 
void printNum ( int L , int R ) { for ( int i = L ; i <= R ; i ++ ) { int temp = i ; int c = 10 ; int flag = 0 ; while ( temp > 0 ) { if ( temp % 10 >= c ) { flag = 1 ; break ; } c = temp % 10 ; temp /= 10 ; } if ( flag == 0 ) cout << i << " ▁ " ; } }

BLEU: 100.0
Edit Sim: 0


Src: 
function countSubstringWithEqualEnds ( s ) { var result = 0 ; var n = s . length ; for ( i = 0 ; i < n ; i ++ ) for ( j = i ; j < n ; j ++ ) if ( s . charAt ( i ) == s . charAt ( j ) ) result ++ ; return result ; }
Ref: 
int countSubstringWithEqualEnds ( string s ) { int result = 0 ; int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i ; j < n ; j ++ ) if ( s [ i ] == s [ j ] ) result ++ ; return result ; }
Hyp: 
int countSubstringWithEqualEnds ( string s ) { int result = 0 ; int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i ; j < n ; j ++ ) if ( s [ i ] == s [ j ] ) result ++ ; return result ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function cntWaysConsArray ( A , N ) { var total = 1 ; var oddArray = 1 ; for ( i = 0 ; i < N ; i ++ ) { total = total * 3 ; if ( A [ i ] % 2 == 0 ) { oddArray *= 2 ; } } document . write ( total - oddArray ) ; }
Ref: 
void cntWaysConsArray ( int A [ ] , int N ) { int total = 1 ; int oddArray = 1 ; for ( int i = 0 ; i < N ; i ++ ) { total = total * 3 ; if ( A [ i ] % 2 == 0 ) { oddArray *= 2 ; } } cout << total - oddArray << " STRNEWLINE " ; }
Hyp: 
void cntWaysConsArray ( int A [ ] , int N ) { int total = 1 ; int oddArray = 1 ; for ( int i = 0 ; i < N ; i ++ ) { total = total * 3 ; if ( A [ i ] % 2 == 0 ) { oddArray *= 2 ; } } cout << total - oddArray ; }

BLEU: 92.52
Edit Sim: 18


Src: 
function minElements ( arr , N , K ) { let count = 0 ; let requiredNum = 1 ; let i = 0 ; while ( requiredNum <= K ) { if ( i < N && requiredNum >= arr [ i ] ) { requiredNum += arr [ i ] ; i ++ ; } else { count ++ ; requiredNum += requiredNum ; } } return count ; }
Ref: 
int minElements ( int arr [ ] , int N , int K ) { int count = 0 ; long long requiredNum = 1 ; int i = 0 ; while ( requiredNum <= K ) { if ( i < N && requiredNum >= arr [ i ] ) { requiredNum += arr [ i ] ; i ++ ; } else { count ++ ; requiredNum += requiredNum ; } } return count ; }
Hyp: 
int minElements ( int arr [ ] , int N , int K ) { int count = 0 ; int requiredNum = 1 ; int i = 0 ; while ( requiredNum <= K ) { if ( i < N && requiredNum >= arr [ i ] ) { requiredNum += arr [ i ] ; i ++ ; } else { count ++ ; requiredNum += requiredNum ; } } return count ; }

BLEU: 95.45
Edit Sim: 8


Src: 
function isLowerTriangularMatrix ( mat ) { for ( let i = 0 ; i < N ; i ++ ) for ( let j = i + 1 ; j < N ; j ++ ) if ( mat [ i ] [ j ] != 0 ) return false ; return true ; }
Ref: 
bool isLowerTriangularMatrix ( int mat [ N ] [ N ] ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = i + 1 ; j < N ; j ++ ) if ( mat [ i ] [ j ] != 0 ) return false ; return true ; }
Hyp: 
bool isLowerTriangularMatrix ( int mat [ N ] [ N ] ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = i + 1 ; j < N ; j ++ ) if ( mat [ i ] [ j ] != 0 ) return false ; return true ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function modFact ( n , m ) { let result = 1 ; for ( let i = 1 ; i <= m ; i ++ ) result = ( result * i ) % MOD ; return result ; }
Ref: 
int modFact ( int n , int m ) { int result = 1 ; for ( int i = 1 ; i <= m ; i ++ ) result = ( result * i ) % MOD ; return result ; }
Hyp: 
int modFact ( int n , int m ) { int result = 1 ; for ( int i = 1 ; i <= m ; i ++ ) result = ( result * i ) % MOD ; return result ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findWinner ( a , n ) { let win = 0 ; if ( n % 2 == 0 ) win = 1 ; else win = 0 ; for ( let i = n - 2 ; i >= 0 ; i -- ) { if ( i % 2 == 1 ) { if ( win == 0 && a [ i ] > 1 ) win = 1 ; } else { if ( win == 1 && a [ i ] > 1 ) win = 0 ; } } if ( win == 0 ) document . write ( " " ) ; else document . write ( " " ) ; }
Ref: 
void findWinner ( int a [ ] , int n ) { int win = 0 ; if ( n % 2 == 0 ) win = 1 ; else win = 0 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( i % 2 == 1 ) { if ( win == 0 && a [ i ] > 1 ) win = 1 ; } else { if ( win == 1 && a [ i ] > 1 ) win = 0 ; } } if ( win == 0 ) cout << " A " ; else cout << " B " ; }
Hyp: 
void findWinner ( int a [ ] , int n ) { int win = 0 ; if ( n % 2 == 0 ) win = 1 ; else win = 0 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( i % 2 == 1 ) { if ( win == 0 && a [ i ] > 1 ) win = 1 ; } else { if ( win == 1 && a [ i ] > 1 ) win = 0 ; } } if ( win == 0 ) cout << " No " ; else cout << " Yes " ; }

BLEU: 95.74
Edit Sim: 5


Src: 
function minOp ( num ) { var rem ; var count = 0 ; while ( num ) { rem = num % 10 ; if ( ! ( rem == 3 rem == 8 ) ) count ++ ; num = parseInt ( num / 10 ) ; } return count ; }
Ref: 
int minOp ( long long int num ) { int rem ; int count = 0 ; while ( num ) { rem = num % 10 ; if ( ! ( rem == 3 rem == 8 ) ) count ++ ; num /= 10 ; } return count ; }
Hyp: 
int minOp ( int num ) { int rem ; int count = 0 ; while ( num ) { rem = num % 10 ; if ( ! ( rem == 3 rem == 8 ) ) count ++ ; num = num / 10 ; } return count ; }

BLEU: 88.13
Edit Sim: 17


Src: 
function possibleAcyclicGraph ( N ) { document . write ( Math . pow ( 2 , N - 1 ) ) ; return ; }
Ref: 
void possibleAcyclicGraph ( int N ) { cout << pow ( 2 , N - 1 ) ; return ; }
Hyp: 
void possibleAcyclicGraph ( int N ) { cout << pow ( 2 , N - 1 ) ; return ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function printCollatz ( n ) { while ( n != 1 ) { document . write ( n + " " ) ; if ( ( n & 1 ) != 0 ) n = 3 * n + 1 ; else n = parseInt ( n / 2 , 10 ) ; } document . write ( n ) ; }
Ref: 
void printCollatz ( int n ) { while ( n != 1 ) { cout << n << " ▁ " ; if ( n & 1 ) n = 3 * n + 1 ; else n = n / 2 ; } cout << n ; }
Hyp: 
void printCollatz ( int n ) { while ( n != 1 ) { cout << n << " ▁ " ; if ( n & 1 ) n = 3 * n + 1 ; else n = n / 2 ; } cout << n ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function NumberofTimes ( str ) { var temporary_sum = 0 , count = 0 ; while ( str . length > 1 ) { temporary_sum = 0 ; for ( i = 0 ; i < str . length ; i ++ ) temporary_sum += ( str . charAt ( i ) - ' ' ) ; str = temporary_sum + " " ; count ++ ; } return count ; }
Ref: 
int NumberofTimes ( string str ) { int temporary_sum = 0 , count = 0 ; while ( str . length ( ) > 1 ) { temporary_sum = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) temporary_sum += ( str [ i ] - '0' ) ; str = to_string ( temporary_sum ) ; count ++ ; } return count ; }
Hyp: 
int NumberofTimes ( string str ) { int temporary_sum = 0 , count = 0 ; while ( str . length ( ) > 1 ) { temporary_sum = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) temporary_sum += ( str [ i ] - '0' ) ; str = temporary_sum + "0" ; count ++ ; } return count ; }

BLEU: 92.9
Edit Sim: 17


Src: 
function find_consecutive_steps ( arr , len ) { let count = 0 ; let maximum = 0 ; for ( let index = 1 ; index < len ; index ++ ) { if ( arr [ index ] > arr [ index - 1 ] ) count ++ ; else { maximum = Math . max ( maximum , count ) ; count = 0 ; } } return Math . max ( maximum , count ) ; }
Ref: 
int find_consecutive_steps ( int arr [ ] , int len ) { int count = 0 ; int maximum = 0 ; for ( int index = 1 ; index < len ; index ++ ) { if ( arr [ index ] > arr [ index - 1 ] ) count ++ ; else { maximum = max ( maximum , count ) ; count = 0 ; } } return max ( maximum , count ) ; }
Hyp: 
int find_consecutive_steps ( int arr [ ] , int len ) { int count = 0 ; int maximum = 0 ; for ( int index = 1 ; index < len ; index ++ ) { if ( arr [ index ] > arr [ index - 1 ] ) count ++ ; else { maximum = max ( maximum , count ) ; count = 0 ; } } return max ( maximum , count ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function negProdSubArr ( arr , n ) { let positive = 1 , negative = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 ) arr [ i ] = 1 ; else arr [ i ] = - 1 ; if ( i > 0 ) arr [ i ] *= arr [ i - 1 ] ; if ( arr [ i ] == 1 ) positive ++ ; else negative ++ ; } return ( positive * negative ) ; }
Ref: 
int negProdSubArr ( int arr [ ] , int n ) { int positive = 1 , negative = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 ) arr [ i ] = 1 ; else arr [ i ] = -1 ; if ( i > 0 ) arr [ i ] *= arr [ i - 1 ] ; if ( arr [ i ] == 1 ) positive ++ ; else negative ++ ; } return ( positive * negative ) ; }
Hyp: 
int negProdSubArr ( int arr [ ] , int n ) { int positive = 1 , negative = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 ) arr [ i ] = 1 ; else arr [ i ] = -1 ; if ( i > 0 ) arr [ i ] *= arr [ i - 1 ] ; if ( arr [ i ] == 1 ) positive ++ ; else negative ++ ; } return ( positive * negative ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function maxProduct ( arr , n ) { if ( n < 3 ) { return - 1 ; } arr . sort ( ) ; return Math . max ( arr [ 0 ] * arr [ 1 ] * arr [ n - 1 ] , arr [ n - 1 ] * arr [ n - 2 ] * arr [ n - 3 ] ) ; } var arr = [ - 10 , - 3 , 5 , 6 , - 20 ] ; var n = arr . length ; var max = maxProduct ( arr , n ) ; if ( max == - 1 ) { document . write ( " " ) ; } else { document . write ( " " + max ) ; }
Ref: 
int maxProduct ( int arr [ ] , int n ) { if ( n < 3 ) return -1 ; sort ( arr , arr + n ) ; return max ( arr [ 0 ] * arr [ 1 ] * arr [ n - 1 ] , arr [ n - 1 ] * arr [ n - 2 ] * arr [ n - 3 ] ) ; }
Hyp: 
int maxProduct ( int arr [ ] , int n ) { if ( n < 3 ) { return -1 ; } sort ( arr , arr + n ) ; return max ( arr [ 0 ] * arr [ 1 ] * arr [ n - 1 ] , arr [ n - 1 ] * arr [ n - 2 ] * arr [ n - 3 ] ) ; }

BLEU: 93.19
Edit Sim: 4


Src: 
function countSeq ( n ) { let nCr = 1 , res = 1 ; for ( let r = 1 ; r <= n ; r ++ ) { nCr = ( nCr * ( n + 1 - r ) ) / r ; res += nCr * nCr ; } return res ; }
Ref: 
int countSeq ( int n ) { int nCr = 1 , res = 1 ; for ( int r = 1 ; r <= n ; r ++ ) { nCr = ( nCr * ( n + 1 - r ) ) / r ; res += nCr * nCr ; } return res ; }
Hyp: 
int countSeq ( int n ) { int nCr = 1 , res = 1 ; for ( int r = 1 ; r <= n ; r ++ ) { nCr = ( nCr * ( n + 1 - r ) ) / r ; res += nCr * nCr ; } return res ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function SmallestString ( s , c ) { for ( let i = 0 ; i < s . length ; i ++ ) { if ( s [ i ] > c ) { let temp = s ; s = s . substring ( 0 , i ) ; s += c ; s += temp . substring ( i , temp . length ) ; return s ; } } s += c ; return s ; }
Ref: 
string SmallestString ( string s , char c ) { for ( int i = 0 ; i < s . size ( ) ; i ++ ) { if ( s [ i ] > c ) { s . insert ( i , 1 , c ) ; return s ; } } s += c ; return s ; }
Hyp: 
string SmallestString ( string s , char c ) { for ( int i = 0 ; i < s . size ( ) ; i ++ ) { if ( s [ i ] > c ) { string temp = s ; s . erase ( i , 1 ) ; s += c ; s += temp . substr ( i , temp . size ( ) ) ; return s ; } } s += c ; return s ; }

BLEU: 65.73
Edit Sim: 72


Src: 
function getSum ( arr , p ) { return arr . length ; }
Ref: 
int getSum ( vector < int > arr , int p ) { return arr . size ( ) ; }
Hyp: 
int dig ( int arr [ ] , int n ) { return sum ( arr , arr + n , p ) ; }

BLEU: 18.09
Edit Sim: 38


Src: 
function countPairs ( arr , N , K ) { let mp = new Map ( ) ; let cnt = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( mp . has ( K - arr [ i ] ) ) { cnt += mp . get ( K - arr [ i ] ) ; } if ( mp . has ( arr [ i ] ) ) { mp . set ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } else { mp . set ( arr [ i ] , 1 ) ; } } document . write ( cnt ) ; }
Ref: 
void countPairs ( int arr [ ] , int N , int K ) { unordered_map < int , int > mp ; int cnt = 0 ; for ( int i = 0 ; i < N ; i ++ ) { cnt += mp [ K - arr [ i ] ] ; mp [ arr [ i ] ] ++ ; } cout << cnt ; }
Hyp: 
void countPairs ( int arr [ ] , int N , int K ) { unordered_map < int , int > mp ; int cnt = 0 ; for ( int i = 0 ; i < N ; i ++ ) { mp [ K - arr [ i ] ] ++ ; cnt += mp [ arr [ i ] ] ; } cout << cnt ; }

BLEU: 94.03
Edit Sim: 20


Src: 
function Convert ( degree ) { let pi = 3.14159265359 ; return ( degree * ( pi / 180 ) ) ; }
Ref: 
double Convert ( double degree ) { double pi = 3.14159265359 ; return ( degree * ( pi / 180 ) ) ; }
Hyp: 
double Convert ( double degree ) { double pi = 3.14159265359 ; return ( degree * ( pi / 180 ) ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function squareArea ( l , b , h ) { if ( l < 0 b < 0 h < 0 ) return - 1 ; var a = ( l * b ) / ( l + b ) ; return a * a ; }
Ref: 
float squareArea ( float l , float b , float h ) { if ( l < 0 b < 0 h < 0 ) return -1 ; float a = ( l * b ) / ( l + b ) ; return a * a ; }
Hyp: 
float squareArea ( float l , float b , float h ) { if ( l < 0 b < 0 h < 0 ) return -1 ; float a = ( l * b ) / ( l + b ) ; return a * a ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function xorK ( n , k ) { let res = n ; for ( let i = 1 ; i < k ; i ++ ) res = ( res ^ n ) ; return n ; }
Ref: 
int xorK ( int n , int k ) { int res = n ; for ( int i = 1 ; i < k ; i ++ ) res = ( res ^ n ) ; return res ; }
Hyp: 
int xorK ( int n , int k ) { int res = n ; for ( int i = 1 ; i < k ; i ++ ) res = ( res ^ n ) ; return n ; }

BLEU: 94.36
Edit Sim: 3


Src: 
function printPairs ( arr , n ) { let pairs = new Set ( ) ; let pair_exists = false ; for ( let i = 0 ; i < n ; i ++ ) if ( arr [ i ] > 0 ) pairs . add ( arr [ i ] ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < 0 ) if ( pairs . has ( - arr [ i ] ) ) { document . write ( arr [ i ] + " " + - arr [ i ] + " " ) ; pair_exists = true ; } } if ( pair_exists == false ) document . write ( " " ) ; }
Ref: 
void printPairs ( int arr [ ] , int n ) { unordered_set < int > pairs ; bool pair_exists = false ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] > 0 ) pairs . insert ( arr [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < 0 ) if ( pairs . find ( - arr [ i ] ) != pairs . end ( ) ) cout << arr [ i ] << " , ▁ " << - arr [ i ] << endl ; pair_exists = true ; } } if ( pair_exists == false ) cout << " No ▁ such ▁ pair ▁ exists " ; }
Hyp: 
void printPairs ( int arr [ ] , int n ) { unordered_set < int > pairs ; bool pair_exists = false ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] > 0 ) pairs . insert ( arr [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < 0 ) if ( pairs . find ( - arr [ i ] ) != pairs . end ( ) ) { cout << arr [ i ] << " , ▁ " << - arr [ i ] << " , ▁ " ; pair_exists = true ; } } if ( pair_exists == false ) cout << " No " ; }

BLEU: 92.1
Edit Sim: 32


Src: 
function findMedian ( a , n ) { a . sort ( ) ; if ( n % 2 != 0 ) return a [ parseInt ( n / 2 ) ] ; return ( a [ parseInt ( ( n - 1 ) / 2 ) ] + a [ parseInt ( n / 2 ) ] ) / 2.0 ; }
Ref: 
double findMedian ( int a [ ] , int n ) { sort ( a , a + n ) ; if ( n % 2 != 0 ) return ( double ) a [ n / 2 ] ; return ( double ) ( a [ ( n - 1 ) / 2 ] + a [ n / 2 ] ) / 2.0 ; }
Hyp: 
float findMedian ( float a [ ] , int n ) { sort ( a , a + n ) ; if ( n % 2 != 0 ) return a [ n / 2 ] ; return ( a [ ( n - 1 ) / 2 ] + a [ n / 2 ] ) / 2.0 ; }

BLEU: 82.21
Edit Sim: 32


Src: 
function find_area ( r , d ) { let R = d / PI ; R += Math . pow ( r , 2 ) ; R = Math . sqrt ( R ) ; let area = PI * Math . pow ( R , 2 ) ; return area ; }
Ref: 
double find_area ( int r , int d ) { double R = d / PI ; R += pow ( r , 2 ) ; R = sqrt ( R ) ; double area = PI * pow ( R , 2 ) ; return area ; }
Hyp: 
double find_area ( int r , int d ) { double R = d / PI ; R += pow ( r , 2 ) ; R = sqrt ( R ) ; double area = PI * pow ( R , 2 ) ; return area ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function sum ( a , b , c , d , x ) { var ans = ( x * ( a + b ) * ( c - d ) ) / ( ( a * d ) - ( b * c ) ) ; return ans ; }
Ref: 
double sum ( double a , double b , double c , double d , double x ) { double ans = ( x * ( a + b ) * ( c - d ) ) / ( ( a * d ) - ( b * c ) ) ; return ans ; }
Hyp: 
int sum ( int a , int b , int c , int d , int x ) { int ans = ( x * ( a + b ) * ( c - d ) ) / ( ( a * d ) - ( b * c ) ) ; return ans ; }

BLEU: 72.59
Edit Sim: 42


Src: 
function BalancedNumber ( s ) { let Leftsum = 0 ; let Rightsum = 0 ; for ( let i = 0 ; i < s . length / 2 ; i ++ ) { Leftsum += ( s [ i ] - ' ' ) ; Rightsum += ( s [ s . length - 1 - i ] - ' ' ) ; } if ( Leftsum == Rightsum ) document . write ( " " ) ; else document . write ( " " ) ; }
Ref: 
void BalancedNumber ( string s ) { int Leftsum = 0 ; int Rightsum = 0 ; for ( int i = 0 ; i < s . size ( ) / 2 ; i ++ ) { Leftsum += int ( s [ i ] - '0' ) ; Rightsum += int ( s [ s . size ( ) - 1 - i ] - '0' ) ; } if ( Leftsum == Rightsum ) cout << " Balanced " << endl ; else cout << " Not ▁ Balanced " << endl ; }
Hyp: 
void BalancedNumber ( string s ) { int Leftsum = 0 ; int Rightsum = 0 ; for ( int i = 0 ; i < s . length ( ) / 2 ; i ++ ) { Leftsum += ( s [ i ] - '0' ) ; Rightsum += ( s [ s . length ( ) - 1 - i ] - '0' ) ; } if ( Leftsum == Rightsum ) cout << " Yes " ; else cout << " No " ; }

BLEU: 76.23
Edit Sim: 55


Src: 
function isPossibleToZero ( a , n ) { let num = 0 ; for ( let i = 0 ; i < n ; i ++ ) num = num * 10 + a [ i ] ; return ( num % 11 == 0 ) ; }
Ref: 
bool isPossibleToZero ( int a [ ] , int n ) { int num = 0 ; for ( int i = 0 ; i < n ; i ++ ) num = num * 10 + a [ i ] ; return ( num % 11 == 0 ) ; }
Hyp: 
bool isPossibleToZero ( int a [ ] , int n ) { int num = 0 ; for ( int i = 0 ; i < n ; i ++ ) num = num * 10 + a [ i ] ; return ( num % 11 == 0 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function minOperations ( s ) { var len = s . length ; var result = 0 ; for ( var i = 0 ; i < len / 2 ; i ++ ) { var D1 = Math . max ( s [ i ] . charCodeAt ( 0 ) , s [ len - 1 - i ] . charCodeAt ( 0 ) ) - Math . min ( s [ i ] . charCodeAt ( 0 ) , s [ len - 1 - i ] . charCodeAt ( 0 ) ) ; var D2 = 26 - D1 ; result += Math . min ( D1 , D2 ) ; } return result ; }
Ref: 
int minOperations ( string s ) { int len = s . length ( ) ; int result = 0 ; for ( int i = 0 ; i < len / 2 ; i ++ ) { int D1 = max ( s [ i ] , s [ len - 1 - i ] ) - min ( s [ i ] , s [ len - 1 - i ] ) ; int D2 = 26 - D1 ; result += min ( D1 , D2 ) ; } return result ; }
Hyp: 
int minOperations ( string s ) { int len = s . length ( ) ; int result = 0 ; for ( int i = 0 ; i < len / 2 ; i ++ ) { int D1 = max ( s [ i ] , s [ len - 1 - i ] ) - min ( s [ i ] , s [ len - 1 - i ] ) ; int D2 = 26 - D1 ; result += min ( D1 , D2 ) ; } return result ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function minDistance ( n , k , points ) { for ( let i = 0 ; i < k ; i ++ ) ( point [ i ] ) . sort ( function ( a , b ) { return a - b ; } ) ; for ( let i = 0 ; i < k ; i ++ ) document . write ( point [ i ] [ Math . ceil ( ( n / 2 ) - 1 ) ] + " " ) ; }
Ref: 
void minDistance ( int n , int k , vector < vector < int > > & point ) { for ( int i = 0 ; i < k ; ++ i ) sort ( point [ i ] . begin ( ) , point [ i ] . end ( ) ) ; for ( int i = 0 ; i < k ; ++ i ) cout << point [ i ] [ ( ceil ( ( double ) n / 2 ) - 1 ) ] << " ▁ " ; }
Hyp: 
void minDistance ( int n , int k , vector < int > & point ) { for ( int i = 0 ; i < k ; i ++ ) sort ( point [ i ] , point + n ) ; for ( int i = 0 ; i < k ; i ++ ) cout << point [ i ] [ ceil ( ( n / 2 ) - 1 ) ] << " ▁ " ; }

BLEU: 67.1
Edit Sim: 55


Src: 
function circlearea ( R ) { if ( R < 0 ) return - 1 ; var a = 3.14 * R * R / 4 ; return a ; }
Ref: 
float circlearea ( float R ) { if ( R < 0 ) return -1 ; float a = 3.14 * R * R / 4 ; return a ; }
Hyp: 
float circlearea ( float R ) { if ( R < 0 ) return -1 ; float a = 3.14 * R * R / 4 ; return a ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function CountWays ( n ) { let ans = Math . floor ( ( n - 1 ) / 2 ) ; return ans ; }
Ref: 
int CountWays ( int n ) { int ans = ( n - 1 ) / 2 ; return ans ; }
Hyp: 
int CountWays ( int n ) { int ans = ( n - 1 ) / 2 ; return ans ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countTriplets ( arr , n , m ) { let count = 0 ; arr . sort ( function ( a , b ) { return a - b } ) ; let end , start , mid ; for ( end = n - 1 ; end >= 2 ; end -- ) { start = 0 ; mid = end - 1 ; while ( start < mid ) { let prod = arr [ end ] * arr [ start ] * arr [ mid ] ; if ( prod > m ) mid -- ; else if ( prod < m ) start ++ ; else if ( prod == m ) { count ++ ; mid -- ; start ++ ; } } } return count ; }
Ref: 
int countTriplets ( int arr [ ] , int n , int m ) { int count = 0 ; sort ( arr , arr + n ) ; int end , start , mid ; for ( end = n - 1 ; end >= 2 ; end -- ) { int start = 0 , mid = end - 1 ; while ( start < mid ) { long int prod = arr [ end ] * arr [ start ] * arr [ mid ] ; if ( prod > m ) mid -- ; else if ( prod < m ) start ++ ; else if ( prod == m ) { count ++ ; mid -- ; start ++ ; } } } return count ; }
Hyp: 
int countTriplets ( int arr [ ] , int n , int m ) { int count = 0 ; sort ( arr , arr + n ) ; int end , start , mid ; for ( end = n - 1 ; end >= 2 ; end -- ) { start = 0 ; mid = end - 1 ; while ( start < mid ) { int prod = arr [ end ] * arr [ start ] * arr [ mid ] ; if ( prod > m ) mid -- ; else if ( prod < m ) start ++ ; else if ( prod == m ) { count ++ ; mid -- ; start ++ ; } } } return count ; }

BLEU: 94.61
Edit Sim: 10


Src: 
function maxOperations ( X , Y ) { if ( X > Y ) return - 1 ; let diff = Y - X ; if ( diff == 1 ) return - 1 ; if ( diff % 2 == 0 ) return ( diff / 2 ) ; return ( 1 + ( ( diff - 3 ) / 2 ) ) ; }
Ref: 
int maxOperations ( int X , int Y ) { if ( X > Y ) return -1 ; int diff = Y - X ; if ( diff == 1 ) return -1 ; if ( diff % 2 == 0 ) return ( diff / 2 ) ; return ( 1 + ( ( diff - 3 ) / 2 ) ) ; }
Hyp: 
int maxOperations ( int X , int Y ) { if ( X > Y ) return -1 ; int diff = Y - X ; if ( diff == 1 ) return -1 ; if ( diff % 2 == 0 ) return ( diff / 2 ) ; return 1 + ( ( diff - 3 ) / 2 ) ; }

BLEU: 93.39
Edit Sim: 4


Src: 
function countSortedArrays ( start , m , size , n ) { if ( size === m ) return 1 ; if ( start > n ) return 0 ; var notTaken = 0 , taken = 0 ; taken = countSortedArrays ( start , m , size + 1 , n ) ; notTaken = countSortedArrays ( start + 1 , m , size , n ) ; return taken + notTaken ; }
Ref: 
int countSortedArrays ( int start , int m , int size , int n ) { if ( size == m ) return 1 ; if ( start > n ) return 0 ; int notTaken = 0 , taken = 0 ; taken = countSortedArrays ( start , m , size + 1 , n ) ; notTaken = countSortedArrays ( start + 1 , m , size , n ) ; return taken + notTaken ; }
Hyp: 
int countSortedArrays ( int start , int m , int size , int n ) { if ( size == m ) return 1 ; if ( start > n ) return 0 ; int notTaken = 0 , taken = 0 ; taken = countSortedArrays ( start , m , size + 1 , n ) ; notTaken = countSortedArrays ( start + 1 , m , size , n ) ; return taken + notTaken ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function canSplitArray ( arr , n , k ) { for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] <= k ) { return " " ; } } return " " ; }
Ref: 
string canSplitArray ( int arr [ ] , int n , int k ) { for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] <= k ) { return " No " ; } } return " Yes " ; }
Hyp: 
string canSplitArray ( int arr [ ] , int n , int k ) { for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] <= k ) { return " Yes " ; } } return " No " ; }

BLEU: 99.0
Edit Sim: 6


Src: 
function stepRequired ( N ) { let cnt = 0 ; while ( N ) { N = N & ( N - 1 ) ; cnt ++ ; } return cnt ; }
Ref: 
int stepRequired ( int N ) { int cnt = 0 ; while ( N ) { N = N & ( N - 1 ) ; cnt ++ ; } return cnt ; }
Hyp: 
int stepRequired ( int N ) { int cnt = 0 ; while ( N ) { N = N & ( N - 1 ) ; cnt ++ ; } return cnt ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findPair ( x ) { let lim = 120 ; for ( let i = - lim ; i <= lim ; i ++ ) for ( let j = - lim ; j <= lim ; j ++ ) if ( Math . pow ( i , 5 ) - Math . pow ( j , 5 ) == x ) { document . write ( i + " " + j ) ; return ; } document . write ( " " ) ; }
Ref: 
void findPair ( int x ) { int lim = 120 ; for ( int i = - lim ; i <= lim ; i ++ ) { for ( int j = - lim ; j <= lim ; j ++ ) { if ( pow ( i , 5 ) - pow ( j , 5 ) == x ) { cout << i << ' ▁ ' << j << endl ; return ; } } } cout << " - 1" ; }
Hyp: 
void findPair ( int x ) { int lim = 120 ; for ( int i = - lim ; i <= lim ; i ++ ) for ( int j = - lim ; j <= lim ; j ++ ) if ( pow ( i , 5 ) - pow ( j , 5 ) == x ) { cout << i << " , ▁ " << j ; return ; } cout << " - 1" ; }

BLEU: 81.93
Edit Sim: 19


Src: 
function totalCountDifference ( n ) { if ( n == 1 ) return 1 ; return n + totalCountDifference ( Math . floor ( n / 2 ) ) ; }
Ref: 
int totalCountDifference ( int n ) { if ( n == 1 ) return 1 ; return n + totalCountDifference ( n / 2 ) ; }
Hyp: 
int totalCountDifference ( int n ) { if ( n == 1 ) return 1 ; return n + totalCountDifference ( n / 2 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countZeroes ( mat ) { let row = N - 1 , col = 0 ; let count = 0 ; while ( col < N ) { while ( mat [ row ] [ col ] > 0 ) if ( -- row < 0 ) return count ; count += ( row + 1 ) ; col ++ ; } return count ; }
Ref: 
int countZeroes ( int mat [ N ] [ N ] ) { int row = N - 1 , col = 0 ; int count = 0 ; while ( col < N ) { while ( mat [ row ] [ col ] ) if ( -- row < 0 ) return count ; count += ( row + 1 ) ; col ++ ; } return count ; }
Hyp: 
int countZeroes ( int mat [ N ] [ M ] ) { int row = N - 1 , col = 0 ; int count = 0 ; while ( col < N ) { while ( mat [ row ] [ col ] > 0 ) if ( -- row < 0 ) return count ; count += ( row + 1 ) ; col ++ ; } return count ; }

BLEU: 91.73
Edit Sim: 5


Src: 
function isPerfectSquare ( x ) { var sr = Math . round ( Math . sqrt ( x ) ) ; if ( sr * sr == x ) document . write ( " " ) ; else document . write ( " " ) ; }
Ref: 
void isPerfectSquare ( long long int x ) { long double sr = round ( sqrt ( x ) ) ; if ( sr * sr == x ) cout << " Yes " ; else cout << " No " ; }
Hyp: 
void isPerfectSquare ( int x ) { long double sr = long double ( sqrt ( x ) ) ; if ( sr * sr == x ) cout << " Yes " ; else cout << " No " ; }

BLEU: 86.07
Edit Sim: 19


Src: 
function maxAbsDiff ( arr , n ) { let minEle = arr [ 0 ] ; let maxEle = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { minEle = Math . min ( minEle , arr [ i ] ) ; maxEle = Math . max ( maxEle , arr [ i ] ) ; } return ( maxEle - minEle ) ; }
Ref: 
int maxAbsDiff ( int arr [ ] , int n ) { int minEle = arr [ 0 ] ; int maxEle = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { minEle = min ( minEle , arr [ i ] ) ; maxEle = max ( maxEle , arr [ i ] ) ; } return ( maxEle - minEle ) ; }
Hyp: 
int maxAbsDiff ( int arr [ ] , int n ) { int minEle = arr [ 0 ] ; int maxEle = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { minEle = min ( minEle , arr [ i ] ) ; maxEle = max ( maxEle , arr [ i ] ) ; } return ( maxEle - minEle ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function minLength ( str , N , K , M ) { var stackOfChar = [ ] ; for ( var i = 0 ; i < N ; i ++ ) { stackOfChar . push ( str [ i ] ) ; if ( stackOfChar . length >= M ) { var l = " " ; for ( var j = M - 1 ; j >= 0 ; j -- ) { if ( K [ j ] != stackOfChar [ stackOfChar . length - 1 ] ) { var f = 0 ; while ( f != l . length ) { stackOfChar . push ( l [ f ] ) ; f ++ ; } break ; } else { l = stackOfChar [ stackOfChar . length - 1 ] + l ; stackOfChar . pop ( ) ; } } } } return stackOfChar . length ; }
Ref: 
int minLength ( string str , int N , string K , int M ) { stack < char > stackOfChar ; for ( int i = 0 ; i < N ; i ++ ) { stackOfChar . push ( str [ i ] ) ; if ( stackOfChar . size ( ) >= M ) { string l = " " ; for ( int j = M - 1 ; j >= 0 ; j -- ) { if ( K [ j ] != stackOfChar . top ( ) ) { int f = 0 ; while ( f != l . size ( ) ) { stackOfChar . push ( l [ f ] ) ; f ++ ; } break ; } else { l = stackOfChar . top ( ) + l ; stackOfChar . pop ( ) ; } } } } return stackOfChar . size ( ) ; }
Hyp: 
int minLength ( string str , int N , int K [ ] , int M ) { stack < char > stackOfChar ; for ( int i = 0 ; i < N ; i ++ ) { stackOfChar . push ( str [ i ] ) ; if ( stackOfChar . size ( ) >= M ) { string l = " " ; for ( int j = M - 1 ; j >= 0 ; j -- ) { if ( K [ j ] != stackOfChar [ stackOfChar . size ( ) - 1 ] ) { int f = 0 ; while ( f != l . size ( ) ) { stackOfChar . push_back ( l [ f ] ) ; f ++ ; } break ; } else { l = stackOfChar [ stackOfChar . size ( ) - 1 ] + l ; stackOfChar . pop ( ) ; } } } return stackOfChar . size ( ) ; }

BLEU: 84.28
Edit Sim: 62


Src: 
function middlesum ( mat , n ) { var row_sum = 0 , col_sum = 0 ; for ( i = 0 ; i < n ; i ++ ) row_sum += mat [ parseInt ( n / 2 ) ] [ i ] ; document . write ( " " + row_sum + " " ) ; for ( i = 0 ; i < n ; i ++ ) col_sum += mat [ i ] [ parseInt ( n / 2 ) ] ; document . write ( " " + col_sum ) ; }
Ref: 
void middlesum ( int mat [ ] [ MAX ] , int n ) { int row_sum = 0 , col_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) row_sum += mat [ n / 2 ] [ i ] ; cout << " Sum ▁ of ▁ middle ▁ row ▁ = ▁ " << row_sum << endl ; for ( int i = 0 ; i < n ; i ++ ) col_sum += mat [ i ] [ n / 2 ] ; cout << " Sum ▁ of ▁ middle ▁ column ▁ = ▁ " << col_sum ; }
Hyp: 
void middlesum ( int mat [ ] [ MAX ] , int n ) { int row_sum = 0 , col_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) row_sum += mat [ n / 2 ] [ i ] ; cout << " x ^ 2 ▁ + ▁ ( " << row_sum << " ) ▁ + ▁ ( " << col_sum << " ) ▁ = ▁ 0" ; }

BLEU: 51.0
Edit Sim: 120


Src: 
function TotalWays ( n , s , k ) { let dp = new Array ( n ) ; dp . fill ( 0 ) ; dp [ s - 1 ] = 1 ; for ( let i = s ; i < n ; i ++ ) { let idx = Math . max ( s - 1 , i - k ) ; for ( let j = idx ; j < i ; j ++ ) { dp [ i ] += dp [ j ] ; } } return dp [ n - 1 ] ; }
Ref: 
int TotalWays ( int n , int s , int k ) { int dp [ n ] ; memset ( dp , 0 , sizeof ( dp ) ) ; dp [ s - 1 ] = 1 ; for ( int i = s ; i < n ; i ++ ) { int idx = max ( s - 1 , i - k ) ; for ( int j = idx ; j < i ; j ++ ) { dp [ i ] += dp [ j ] ; } } return dp [ n - 1 ] ; }
Hyp: 
int TotalWays ( int n , int s , int k ) { int dp [ n ] ; memset ( dp , 0 , sizeof dp ) ; dp [ s - 1 ] = 1 ; for ( int i = s ; i < n ; i ++ ) { int idx = max ( s - 1 , i - k ) ; for ( int j = idx ; j < i ; j ++ ) { dp [ i ] += dp [ j ] ; } } return dp [ n - 1 ] ; }

BLEU: 96.13
Edit Sim: 4


Src: 
function reverse ( str , len ) { if ( len == str . length ) { return ; } reverse ( str , len + 1 ) ; document . write ( str [ len ] ) ; }
Ref: 
void reverse ( string str ) { if ( str . size ( ) == 0 ) { return ; } reverse ( str . substr ( 1 ) ) ; cout << str [ 0 ] ; }
Hyp: 
void reverse ( string & str , int len ) { if ( len == str . length ( ) ) { return ; } reverse ( str , len + 1 ) ; cout << str [ len ] ; }

BLEU: 47.05
Edit Sim: 42


Src: 
function LucasSum ( N ) { var sum = 0 ; var a = 2 , b = 1 , c ; sum += a ; while ( b <= N ) { sum += b ; var c = a + b ; a = b ; b = c ; } return sum ; }
Ref: 
int LucasSum ( int N ) { int sum = 0 ; int a = 2 , b = 1 , c ; sum += a ; while ( b <= N ) { sum += b ; int c = a + b ; a = b ; b = c ; } return sum ; }
Hyp: 
int LucasSum ( int N ) { int sum = 0 ; int a = 2 , b = 1 , c ; sum += a ; while ( b <= N ) { sum += b ; int c = a + b ; a = b ; b = c ; } return sum ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function volumeOfEllipsoid ( r1 , r2 , r3 ) { let pi = 3.14 ; return 1.33 * pi * r1 * r2 * r3 ; }
Ref: 
float volumeOfEllipsoid ( float r1 , float r2 , float r3 ) { float pi = 3.14 ; return 1.33 * pi * r1 * r2 * r3 ; }
Hyp: 
double volumeOfEllipsoid ( float r1 , float r2 , float r3 ) { float pi = 3.14 ; return 1.33 * pi * r1 * r2 * r3 ; }

BLEU: 96.61
Edit Sim: 6


Src: 
function sumOfSeries ( n ) { return ( n * ( 2 * n - 1 ) * ( 2 * n + 1 ) ) / 3 ; }
Ref: 
int sumOfSeries ( int n ) { return ( n * ( 2 * n - 1 ) * ( 2 * n + 1 ) ) / 3 ; }
Hyp: 
int sumOfSeries ( int n ) { return ( n * ( 2 * n - 1 ) * ( 2 * n + 1 ) ) / 3 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function minIncr ( arr , n ) { let forEven = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( i % 2 ) { if ( ( arr [ i ] % 2 ) == 0 ) forEven += 1 ; } else { if ( arr [ i ] % 2 ) forEven += 1 ; } } return Math . min ( forEven , n - forEven ) ; }
Ref: 
int minIncr ( int * arr , int n ) { int forEven = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 ) { if ( ( arr [ i ] % 2 ) == 0 ) forEven += 1 ; } else { if ( arr [ i ] % 2 ) forEven += 1 ; } } return min ( forEven , n - forEven ) ; }
Hyp: 
int minIncr ( int arr [ ] , int n ) { int forEven = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 ) { if ( ! ( arr [ i ] % 2 ) ) forEven += 1 ; } else { if ( arr [ i ] % 2 ) forEven += 1 ; } } return min ( forEven , n - forEven ) ; }

BLEU: 89.94
Edit Sim: 13


Src: 
function EvenLIS ( arr ) { let n = arr . length ; let lis = new Array ( n ) . fill ( 1 ) ; for ( let i = 1 ; i < n ; i ++ ) { for ( let j = 0 ; j < i ; j ++ ) { if ( Math . abs ( arr [ i ] ) > Math . abs ( arr [ j ] ) && Math . abs ( arr [ i ] ) % 2 == 0 && Math . abs ( arr [ j ] ) % 2 == 0 && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; } } let maxlen = 0 ; for ( let i = 0 ; i < n ; i ++ ) maxlen = Math . max ( maxlen , lis [ i ] ) ; document . write ( maxlen ) ; }
Ref: 
void EvenLIS ( int arr [ ] , int n ) { int lis [ n ] ; for ( int i = 0 ; i < n ; i ++ ) lis [ i ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( abs ( arr [ i ] ) > abs ( arr [ j ] ) && abs ( arr [ i ] ) % 2 == 0 && abs ( arr [ j ] ) % 2 == 0 && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; } } int maxlen = 0 ; for ( int i = 0 ; i < n ; i ++ ) maxlen = max ( maxlen , lis [ i ] ) ; cout << maxlen << endl ; }
Hyp: 
void EvenLIS ( int arr [ ] , int n ) { int lis [ n ] ; lis [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( abs ( arr [ i ] ) > abs ( arr [ j ] ) && abs ( arr [ i ] ) % 2 == 0 && abs ( arr [ j ] ) % 2 == 0 && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; } } int maxlen = 0 ; for ( int i = 0 ; i < n ; i ++ ) maxlen = max ( maxlen , lis [ i ] ) ; cout << maxlen ; }

BLEU: 87.69
Edit Sim: 42


Src: 
function countCountries ( ans , N ) { let total_countries = 0 , i = 0 ; let invalid = false ; while ( i < N ) { let curr_size = ans [ i ] ; let num = ans [ i ] ; while ( num > 0 ) { if ( ans [ i ] != curr_size ) { document . write ( " " ) ; return ; } else num -- ; i ++ ; } total_countries ++ ; } document . write ( " " + total_countries + " " ) ; }
Ref: 
void countCountries ( int ans [ ] , int N ) { int total_countries = 0 , i = 0 ; bool invalid = false ; while ( i < N ) { int curr_size = ans [ i ] ; int num = ans [ i ] ; while ( num > 0 ) { if ( ans [ i ] != curr_size ) { cout << " Invalid ▁ Answer STRNEWLINE " ; return ; } else num -- ; i ++ ; } total_countries ++ ; } cout << " There ▁ are ▁ " << total_countries << " ▁ distinct ▁ companies ▁ in ▁ the ▁ group . STRNEWLINE " ; }
Hyp: 
void countCountries ( int ans [ ] , int N ) { int total_countries = 0 , i = 0 ; bool invalid = false ; while ( i < N ) { int curr_size = ans [ i ] ; int num = ans [ i ] ; while ( num ) { if ( ans [ i ] != curr_size ) { cout << " No " ; return ; } else num -- ; i ++ ; } total_countries ++ ; } cout << " Total ▁ Country : " << total_countries << endl ; }

BLEU: 73.49
Edit Sim: 97


Src: 
function printRect ( X , Y , n ) { var Xmax = X . reduce ( ( a , b ) => Math . max ( a , b ) ) ; var Xmin = X . reduce ( ( a , b ) => Math . min ( a , b ) ) ; var Ymax = Y . reduce ( ( a , b ) => Math . max ( a , b ) ) ; var Ymin = Y . reduce ( ( a , b ) => Math . min ( a , b ) ) ; document . write ( " " + Xmin + " " + Ymin + " " + " " ) ; document . write ( " " + Xmin + " " + Ymax + " " + " " ) ; document . write ( " " + Xmax + " " + Ymax + " " + " " ) ; document . write ( " " + Xmax + " " + Ymin + " " + " " ) ; }
Ref: 
void printRect ( int X [ ] , int Y [ ] , int n ) { int Xmax = * max_element ( X , X + n ) ; int Xmin = * min_element ( X , X + n ) ; int Ymax = * max_element ( Y , Y + n ) ; int Ymin = * min_element ( Y , Y + n ) ; cout << " { " << Xmin << " , ▁ " << Ymin << " } " << endl ; cout << " { " << Xmin << " , ▁ " << Ymax << " } " << endl ; cout << " { " << Xmax << " , ▁ " << Ymax << " } " << endl ; cout << " { " << Xmax << " , ▁ " << Ymin << " } " << endl ; }
Hyp: 
void printRect ( int * X , int * Y , int n ) { int Xmax = X . max ( ) ; int Xmin = X . min ( ) ; int Ymax = Y . reduce ( ( a , b ) => max ( a , b ) ) ; int Ymin = Y . reduce ( ( a , b ) => min ( a , b ) ) ; cout << " ( " << Xmin << " , ▁ " << Ymin << " , ▁ " << n << " ) ▁ " ; cout << " ( " << Xmax << " , ▁ " << Ymax << " , ▁ " << " ▁ " << Ymin << " , ▁ " ; cout << " ( " << Xmax << " , ▁ " << Ymin << " , ▁ " ) ; }

BLEU: 45.76
Edit Sim: 172


Src: 
function makeOdd ( n ) { if ( n % 2 != 0 ) return 1 ; var ans = 1 ; while ( n % 2 == 0 ) { n = parseInt ( n / 2 ) ; ans *= 2 ; } return ans ; }
Ref: 
int makeOdd ( int n ) { if ( n % 2 != 0 ) return 1 ; int resul = 1 ; while ( n % 2 == 0 ) { n /= 2 ; resul *= 2 ; } return resul ; }
Hyp: 
int makeOdd ( int n ) { if ( n % 2 != 0 ) return 1 ; int ans = 1 ; while ( n % 2 == 0 ) { n = n / 2 ; ans *= 2 ; } return ans ; }

BLEU: 74.55
Edit Sim: 17


Src: 
function area ( r ) { if ( r < 0 ) return - 1 ; var area = ( 3.14 * Math . pow ( r / ( 2 * Math . sqrt ( 2 ) ) , 2 ) ) ; return area ; }
Ref: 
float area ( float r ) { if ( r < 0 ) return -1 ; float area = 3.14 * pow ( r / ( 2 * sqrt ( 2 ) ) , 2 ) ; return area ; }
Hyp: 
float area ( float r ) { if ( r < 0 ) return -1 ; float area = 3.14 * pow ( r / ( 2 * sqrt ( 2 ) ) , 2 ) ; return area ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findLCMPrime ( a , b ) { if ( a == b ) { return a ; } return a * b ; }
Ref: 
int findLCMPrime ( int a , int b ) { if ( a == b ) { return a ; } return a * b ; }
Hyp: 
int findLCMPrime ( int a , int b ) { if ( a == b ) { return a ; } return a * b ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function printMatrix ( n , k ) { for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < n ; j ++ ) { if ( i == j ) document . write ( k + " " ) ; else document . write ( " " ) ; } document . write ( " " ) ; } }
Ref: 
void printMatrix ( int n , int k ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == j ) cout << k << " ▁ " ; else cout << "0 ▁ " ; } cout << " STRNEWLINE " ; } }
Hyp: 
void printMatrix ( int n , int k ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == j ) cout << k << " ▁ " ; else cout << " STRNEWLINE " ; } cout << " STRNEWLINE " ; } }

BLEU: 94.92
Edit Sim: 11


Src: 
function CountPairs ( arr , n ) { let even = 0 , odd = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) even ++ ; else odd ++ ; } return ( even * ( even - 1 ) ) / 2 + ( even * odd ) ; }
Ref: 
int CountPairs ( int arr [ ] , int n ) { int even = 0 , odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) even ++ ; else odd ++ ; } return ( even * ( even - 1 ) ) / 2 + ( even * odd ) ; }
Hyp: 
int CountPairs ( int arr [ ] , int n ) { int even = 0 , odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) even ++ ; else odd ++ ; } return ( even * ( even - 1 ) ) / 2 + ( even * odd ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function minProd ( X , Y , N ) { if ( X <= Y ) { if ( N < X ) return ( X - N ) * Y ; else { return Math . max ( Y - ( N - X + 1 ) , 1 ) ; } } if ( Y >= N ) return ( Y - N ) * X ; return Math . max ( X - ( N - Y + 1 ) , 1 ) ; }
Ref: 
int minProd ( int X , int Y , int N ) { if ( X <= Y ) { if ( N < X ) return ( X - N ) * Y ; else { return max ( Y - ( N - X + 1 ) , 1 ) ; } } if ( Y >= N ) return ( Y - N ) * X ; return max ( X - ( N - Y + 1 ) , 1 ) ; ; }
Hyp: 
int minProd ( int X , int Y , int N ) { if ( X <= Y ) { if ( N < X ) return ( X - N ) * Y ; else { return max ( Y - ( N - X + 1 ) , 1 ) ; } } if ( Y >= N ) return ( Y - N ) * X ; return max ( X - ( N - Y + 1 ) , 1 ) ; }

BLEU: 98.28
Edit Sim: 2


Src: 
function countOnes ( arr , low , high ) { if ( high >= low ) { let mid = Math . trunc ( low + ( high - low ) / 2 ) ; if ( ( mid == high arr [ mid + 1 ] == 0 ) && ( arr [ mid ] == 1 ) ) return mid + 1 ; if ( arr [ mid ] == 1 ) return countOnes ( arr , ( mid + 1 ) , high ) ; return countOnes ( arr , low , ( mid - 1 ) ) ; } return 0 ; }
Ref: 
int countOnes ( bool arr [ ] , int low , int high ) { if ( high >= low ) { int mid = low + ( high - low ) / 2 ; if ( ( mid == high arr [ mid + 1 ] == 0 ) && ( arr [ mid ] == 1 ) ) return mid + 1 ; if ( arr [ mid ] == 1 ) return countOnes ( arr , ( mid + 1 ) , high ) ; return countOnes ( arr , low , ( mid - 1 ) ) ; } return 0 ; }
Hyp: 
int countOnes ( bool arr [ ] , int low , int high ) { if ( high >= low ) { int mid = low + ( high - low ) / 2 ; if ( ( mid == high arr [ mid + 1 ] == 0 ) && ( arr [ mid ] == 1 ) ) return mid + 1 ; if ( arr [ mid ] == 1 ) return countOnes ( arr , ( mid + 1 ) , high ) ; return countOnes ( arr , low , ( mid - 1 ) ) ; } return 0 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countCharacterType ( str ) { var vowels = 0 , consonant = 0 , specialChar = 0 , digit = 0 ; for ( var i = 0 ; i < str . length ; i ++ ) { var ch = str [ i ] ; if ( ( ch >= " " && ch <= " " ) || ( ch >= " " && ch <= " " ) ) { ch = ch . toLowerCase ( ) ; if ( ch == " " ch == " " ch == " " ch == " " ch == " " ) vowels ++ ; else consonant ++ ; } else if ( ch >= " " && ch <= " " ) digit ++ ; else specialChar ++ ; } document . write ( " " + vowels + " " ) ; document . write ( " " + consonant + " " ) ; document . write ( " " + digit + " " ) ; document . write ( " " + specialChar + " " ) ; }
Ref: 
void countCharacterType ( string str ) { int vowels = 0 , consonant = 0 , specialChar = 0 , digit = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char ch = str [ i ] ; if ( ( ch >= ' a ' && ch <= ' z ' ) || ( ch >= ' A ' && ch <= ' Z ' ) ) { ch = tolower ( ch ) ; if ( ch == ' a ' ch == ' e ' ch == ' i ' ch == ' o ' ch == ' u ' ) vowels ++ ; else consonant ++ ; } else if ( ch >= '0' && ch <= '9' ) digit ++ ; else specialChar ++ ; } cout << " Vowels : ▁ " << vowels << endl ; cout << " Consonant : ▁ " << consonant << endl ; cout << " Digit : ▁ " << digit << endl ; cout << " Special ▁ Character : ▁ " << specialChar << endl ; }
Hyp: 
void countCharacterType ( string str ) { int vowels = 0 , consonant = 0 , specialChar = 0 , digit = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char ch = str [ i ] ; if ( ( ch >= ' a ' && ch <= ' z ' ) || ( ch >= ' a ' && ch <= ' z ' ) ) { ch = ch . toLowerCase ( ) ; if ( ch == ' a ' ch == ' e ' ch == ' z ' ) vowels ++ ; else consonant ++ ; } else if ( ch >= ' a ' && ch <= ' z ' ) digit ++ ; else specialChar ++ ; } cout << " Vowels ▁ = ▁ " << vowels << endl ; cout << " Consonant ▁ = ▁ " << consonant << endl ; cout << " Digit ▁ = ▁ " << digit << endl ; cout << " Special Char ▁ = ▁ " << specialChar << endl ; }

BLEU: 80.5
Edit Sim: 62


Src: 
function ReuleauxArea ( r ) { if ( r < 0 ) return - 1 ; var A = 0.70477 * 2 * Math . pow ( r , 2 ) ; return A ; }
Ref: 
float ReuleauxArea ( float r ) { if ( r < 0 ) return -1 ; float A = 0.70477 * 2 * pow ( r , 2 ) ; return A ; }
Hyp: 
float ReuleauxArea ( float r ) { if ( r < 0 ) return -1 ; float A = 0.70477 * 2 * pow ( r , 2 ) ; return A ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function lastTwoDigits ( N ) { if ( N >= 10 ) { cout << " " ; return ; } let fac = 1 ; for ( let i = 1 ; i <= N ; i ++ ) fac = ( fac * i ) % 100 ; document . write ( fac ) ; }
Ref: 
void lastTwoDigits ( long long N ) { if ( N >= 10 ) { cout << "00" ; return ; } long long fac = 1 ; for ( int i = 1 ; i <= N ; i ++ ) fac = ( fac * i ) % 100 ; cout << fac ; }
Hyp: 
void lastTwoDigits ( int N ) { if ( N >= 10 ) { cout << " No " ; return ; } int fac = 1 ; for ( int i = 1 ; i <= N ; i ++ ) fac = ( fac * i ) % 100 ; cout << fac ; }

BLEU: 82.82
Edit Sim: 20


Src: 
function cntCells ( n ) { var cells = Math . pow ( n , 2 ) + Math . pow ( n - 1 , 2 ) ; return cells ; }
Ref: 
int cntCells ( int n ) { int cells = pow ( n , 2 ) + pow ( n - 1 , 2 ) ; return cells ; }
Hyp: 
int cntCells ( int n ) { int cells = pow ( n , 2 ) + pow ( n - 1 , 2 ) ; return cells ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function surfaceArea ( b , s ) { return 2 * b * s + parseInt ( Math . pow ( b , 2 ) ) ; }
Ref: 
int surfaceArea ( int b , int s ) { return 2 * b * s + pow ( b , 2 ) ; }
Hyp: 
int surfaceArea ( int b , int s ) { return 2 * b * s + pow ( b , 2 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findNumberOfDigits ( n , base ) { var dig = parseInt ( Math . floor ( Math . log ( n ) / Math . log ( base ) ) + 1 ) ; document . write ( " " + " " + n + " " + base + " " + dig ) ; }
Ref: 
void findNumberOfDigits ( long n , int base ) { int dig = ( int ) ( floor ( log ( n ) / log ( base ) ) + 1 ) ; cout << " The ▁ Number ▁ of ▁ digits ▁ of ▁ " << " Number ▁ " << n << " ▁ in ▁ base ▁ " << base << " ▁ is ▁ " << dig ; }
Hyp: 
void findNumberOfDigits ( int n , int base ) { int dig = floor ( log2 ( n ) / log2 ( base ) ) + 1 ; cout << " Number ▁ of ▁ digits ▁ = ▁ " << n << " , ▁ base ▁ = ▁ " << base << " , ▁ dig ▁ = ▁ " << dig ; }

BLEU: 53.76
Edit Sim: 57


Src: 
function findUniqueElements ( arr , N , K ) { var s = new Set ( arr ) ; var arr_sum = arr . reduce ( ( a , b ) => a + b , 0 ) ; var set_sum = 0 ; s . forEach ( function ( value ) { set_sum += value ; } ) document . write ( Math . floor ( ( K * set_sum - arr_sum ) / ( K - 1 ) ) ) ; }
Ref: 
int findUniqueElements ( int arr [ ] , int N , int K ) { unordered_set < int > s ( arr , arr + N ) ; int arr_sum = accumulate ( arr , arr + N , 0 ) ; int set_sum = accumulate ( s . begin ( ) , s . end ( ) , 0 ) ; cout << ( K * set_sum - arr_sum ) / ( K - 1 ) ; }
Hyp: 
void findUniqueElements ( int arr [ ] , int N , int K ) { unordered_set < int > s ; int arr_sum = 0 ; s . insert ( arr [ 0 ] ) ; int set_sum = 0 ; s . forEach ( function ( value ) { set_sum += value ; } ) cout << floor ( ( K * set_sum - arr_sum ) / ( K - 1 ) ) ; }

BLEU: 52.17
Edit Sim: 98


Src: 
function checkPairs ( l , r ) { if ( ( l - r ) % 2 == 0 ) return false ; return true ; }
Ref: 
bool checkPairs ( int l , int r ) { if ( ( l - r ) % 2 == 0 ) return false ; return true ; }
Hyp: 
bool checkPairs ( int l , int r ) { if ( ( l - r ) % 2 == 0 ) return false ; return true ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function possible ( n ) { if ( n > 3 ) { let sum = parseInt ( ( n * ( n + 1 ) ) / 2 ) ; if ( sum % 3 == 0 ) { return true ; } } return false ; }
Ref: 
bool possible ( int n ) { if ( n > 3 ) { int sum = ( n * ( n + 1 ) ) / 2 ; if ( sum % 3 == 0 ) { return true ; } } return false ; }
Hyp: 
bool possible ( int n ) { if ( n > 3 ) { int sum = ( n * ( n + 1 ) ) / 2 ; if ( sum % 3 == 0 ) { return true ; } } return false ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function getMinNum ( a , b , c ) { if ( c < a c > b ) return c ; let x = ( parseInt ( b / c ) * c ) + c ; return x ; }
Ref: 
int getMinNum ( int a , int b , int c ) { if ( c < a c > b ) return c ; int x = ( ( b / c ) * c ) + c ; return x ; }
Hyp: 
int getMinNum ( int a , int b , int c ) { if ( c < a c > b ) return c ; int x = ( ( b / c ) * c ) + c ; return x ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function minSum ( A , n ) { let min_val = Math . min ( ... A ) ; return ( min_val * ( n - 1 ) ) ; }
Ref: 
int minSum ( int A [ ] , int n ) { int min_val = * min_element ( A , A + n ) ; return ( min_val * ( n - 1 ) ) ; }
Hyp: 
int minSum ( int A [ ] , int n ) { int min_val = * min_element ( A , A + n ) ; return ( min_val * ( n - 1 ) ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function maxSum ( arr , n ) { if ( n < 2 ) return - 1 ; let ans = arr [ 0 ] + arr [ 1 ] ; for ( let i = 1 ; i + 1 < n ; i ++ ) ans = Math . min ( ans , ( arr [ i ] + arr [ i + 1 ] ) ) ; return ans ; }
Ref: 
int maxSum ( int arr [ ] , int n ) { if ( n < 2 ) return -1 ; int ans = arr [ 0 ] + arr [ 1 ] ; for ( int i = 1 ; i + 1 < n ; i ++ ) ans = min ( ans , ( arr [ i ] + arr [ i + 1 ] ) ) ; return ans ; }
Hyp: 
int maxSum ( int arr [ ] , int n ) { if ( n < 2 ) return -1 ; int ans = arr [ 0 ] + arr [ 1 ] ; for ( int i = 1 ; i + 1 < n ; i ++ ) ans = min ( ans , ( arr [ i ] + arr [ i + 1 ] ) ) ; return ans ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function minOperations ( s , t , n ) { var ct0 = 0 , ct1 = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( s [ i ] === t [ i ] ) continue ; if ( s [ i ] === " " ) ct0 ++ ; else ct1 ++ ; } return Math . max ( ct0 , ct1 ) ; }
Ref: 
int minOperations ( string s , string t , int n ) { int ct0 = 0 , ct1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == t [ i ] ) continue ; if ( s [ i ] == '0' ) ct0 ++ ; else ct1 ++ ; } return max ( ct0 , ct1 ) ; }
Hyp: 
int minOperations ( string s , string t , int n ) { int ct0 = 0 , ct1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == t [ i ] ) continue ; if ( s [ i ] == '0' ) ct0 ++ ; else ct1 ++ ; } return max ( ct0 , ct1 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function calculateSum ( n ) { if ( n % 2 == 1 ) return ( n + 1 ) / 2 ; return - n / 2 ; }
Ref: 
int solve_sum ( int n ) { if ( n % 2 == 1 ) return ( n + 1 ) / 2 ; return - n / 2 ; }
Hyp: 
int calculateSum ( int n ) { if ( n % 2 == 1 ) return ( n + 1 ) / 2 ; return - n / 2 ; }

BLEU: 94.2
Edit Sim: 9


Src: 
function countPairs ( arr1 , arr2 , m , n , x ) { let count = 0 ; let l = 0 , r = n - 1 ; while ( l < m && r >= 0 ) { if ( ( arr1 [ l ] + arr2 [ r ] ) == x ) { l ++ ; r -- ; count ++ ; } else if ( ( arr1 [ l ] + arr2 [ r ] ) < x ) l ++ ; else r -- ; } return count ; }
Ref: 
int countPairs ( int arr1 [ ] , int arr2 [ ] , int m , int n , int x ) { int count = 0 ; int l = 0 , r = n - 1 ; while ( l < m && r >= 0 ) { if ( ( arr1 [ l ] + arr2 [ r ] ) == x ) { l ++ ; r -- ; count ++ ; } else if ( ( arr1 [ l ] + arr2 [ r ] ) < x ) l ++ ; else r -- ; } return count ; }
Hyp: 
int countPairs ( int arr1 [ ] , int arr2 [ ] , int m , int n , int x ) { int count = 0 ; int l = 0 , r = n - 1 ; while ( l < m && r >= 0 ) { if ( ( arr1 [ l ] + arr2 [ r ] ) == x ) { l ++ ; r -- ; count ++ ; } else if ( ( arr1 [ l ] + arr2 [ r ] ) < x ) l ++ ; else r -- ; } return count ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countFriendsPairings ( n ) { if ( dp [ n ] != - 1 ) return dp [ n ] ; if ( n > 2 ) return dp [ n ] = countFriendsPairings ( n - 1 ) + ( n - 1 ) * countFriendsPairings ( n - 2 ) ; else return dp [ n ] = n ; }
Ref: 
int countFriendsPairings ( int n ) { if ( dp [ n ] != -1 ) return dp [ n ] ; if ( n > 2 ) return dp [ n ] = countFriendsPairings ( n - 1 ) + ( n - 1 ) * countFriendsPairings ( n - 2 ) ; else return dp [ n ] = n ; }
Hyp: 
int countFriendsPairings ( int n ) { if ( dp [ n ] != -1 ) return dp [ n ] ; if ( n > 2 ) return dp [ n ] = countFriendsPairings ( n - 1 ) + ( n - 1 ) * countFriendsPairings ( n - 2 ) ; else return dp [ n ] = n ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function getCount ( arr , n , num1 , num2 ) { let i = 0 ; for ( i = 0 ; i < n ; i ++ ) if ( arr [ i ] == num1 ) break ; if ( i >= n - 1 ) return 0 ; let j ; for ( j = n - 1 ; j >= i + 1 ; j -- ) if ( arr [ j ] == num2 ) break ; if ( j == i ) return 0 ; return ( j - i - 1 ) ; }
Ref: 
int getCount ( int arr [ ] , int n , int num1 , int num2 ) { int i = 0 ; for ( i = 0 ; i < n ; i ++ ) if ( arr [ i ] == num1 ) break ; if ( i >= n - 1 ) return 0 ; int j ; for ( j = n - 1 ; j >= i + 1 ; j -- ) if ( arr [ j ] == num2 ) break ; if ( j == i ) return 0 ; return ( j - i - 1 ) ; }
Hyp: 
int getCount ( int arr [ ] , int n , int num1 , int num2 ) { int i ; for ( i = 0 ; i < n ; i ++ ) if ( arr [ i ] == num1 ) break ; if ( i >= n - 1 ) return 0 ; int j ; for ( j = n - 1 ; j >= i + 1 ; j -- ) if ( arr [ j ] == num2 ) break ; if ( j == i ) return 0 ; return ( j - i - 1 ) ; }

BLEU: 96.72
Edit Sim: 4


Src: 
function numberOfMen ( D , m , d ) { var Men = ( m * ( D - d ) ) / d ; return Men ; }
Ref: 
int numberOfMen ( int D , int m , int d ) { int Men = ( m * ( D - d ) ) / d ; return Men ; }
Hyp: 
int numberOfMen ( int D , int m , int d ) { int Men = ( m * ( D - d ) ) / d ; return Men ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function calculateSum ( n ) { return ( n * ( parseInt ( Math . pow ( n , 2 ) + 3 * n + 5 ) ) / 3 ) ; }
Ref: 
int findSum ( int n ) { return ( n * ( pow ( n , 2 ) + 3 * n + 5 ) ) / 3 ; }
Hyp: 
int calculateSum ( int n ) { return ( n * ( pow ( n , 2 ) + 3 * n + 5 ) ) / 3 ; }

BLEU: 94.0
Edit Sim: 9


Src: 
function findParity ( x ) { let y = x ^ ( x >> 1 ) ; y = y ^ ( y >> 2 ) ; y = y ^ ( y >> 4 ) ; y = y ^ ( y >> 8 ) ; y = y ^ ( y >> 16 ) ; if ( y & 1 ) return 1 ; return 0 ; }
Ref: 
bool findParity ( int x ) { int y = x ^ ( x >> 1 ) ; y = y ^ ( y >> 2 ) ; y = y ^ ( y >> 4 ) ; y = y ^ ( y >> 8 ) ; y = y ^ ( y >> 16 ) ; if ( y & 1 ) return 1 ; return 0 ; }
Hyp: 
int findParity ( int x ) { int y = x ^ ( x >> 1 ) ; y = y ^ ( y >> 2 ) ; y = y ^ ( y >> 4 ) ; y = y ^ ( y >> 8 ) ; y = y ^ ( y >> 16 ) ; if ( y & 1 ) return 1 ; return 0 ; }

BLEU: 98.58
Edit Sim: 4


Src: 
function getMinNumberForPattern ( seq ) { let n = seq . length ; if ( n >= 9 ) return " " ; let result = new Array ( n + 1 ) ; let count = 1 ; for ( let i = 0 ; i <= n ; i ++ ) { if ( i == n seq [ i ] == ' ' ) { for ( let j = i - 1 ; j >= - 1 ; j -- ) { result [ j + 1 ] = String . fromCharCode ( ' ' . charCodeAt ( ) + count ++ ) ; if ( j >= 0 && seq [ j ] == ' ' ) break ; } } } return result . join ( " " ) ; } let inputs = [ " " , " " , " " , " " , " " , " " , " " ] ; for ( let input = 0 ; input < inputs . length ; input ++ ) { document . write ( getMinNumberForPattern ( inputs [ input ] ) + " " ) ; }
Ref: 
string getMinNumberForPattern ( string seq ) { int n = seq . length ( ) ; if ( n >= 9 ) return " - 1" ; string result ( n + 1 , ' ▁ ' ) ; int count = 1 ; for ( int i = 0 ; i <= n ; i ++ ) { if ( i == n seq [ i ] == ' I ' ) { for ( int j = i - 1 ; j >= -1 ; j -- ) { result [ j + 1 ] = '0' + count ++ ; if ( j >= 0 && seq [ j ] == ' I ' ) break ; } } } return result ; }
Hyp: 
string getMinNumberForPattern ( string seq ) { int n = seq . length ( ) ; if ( n >= 9 ) return " " ; string result ( n + 1 ) ; int count = 1 ; for ( int i = 0 ; i <= n ; i ++ ) { if ( i == n seq [ i ] == ' I ' ) { for ( int j = i - 1 ; j >= -1 ; j -- ) { result [ j + 1 ] = char ( ' A ' + count ++ ) ; if ( j >= 0 && seq [ j ] == ' I ' ) break ; } } } return " " ; }

BLEU: 87.48
Edit Sim: 29


Src: 
function CountDigits ( n ) { if ( n == 1 ) return 1 ; var sum = 0 ; for ( i = 2 ; i <= n ; ++ i ) { sum += ( Math . log ( i ) / Math . log ( 10 ) ) ; } sum *= n ; return Math . ceil ( sum ) ; }
Ref: 
int CountDigits ( int n ) { if ( n == 1 ) return 1 ; double sum = 0 ; for ( int i = 2 ; i <= n ; ++ i ) { sum += ( double ) log ( i ) / ( double ) log ( 10 ) ; } sum *= ( double ) n ; }
Hyp: 
int CountDigits ( int n ) { if ( n == 1 ) return 1 ; int sum = 0 ; for ( int i = 2 ; i <= n ; ++ i ) { sum += ( log10 ( i ) / log10 ( 10 ) ) ; } sum *= n ; return ceil ( sum ) ; }

BLEU: 71.42
Edit Sim: 50


Src: 
function getFinalElement ( n ) { let finalNum ; for ( finalNum = 2 ; finalNum * 2 <= n ; finalNum *= 2 ) ; return finalNum ; }
Ref: 
long getFinalElement ( long n ) { long finalNum ; for ( finalNum = 2 ; finalNum * 2 <= n ; finalNum *= 2 ) ; return finalNum ; }
Hyp: 
int getFinalElement ( int n ) { int finalNum ; for ( finalNum = 2 ; finalNum * 2 <= n ; finalNum *= 2 ) ; return finalNum ; }

BLEU: 80.6
Edit Sim: 9


Src: 
function pairs ( n ) { let c = new Array ( 10 ) ; for ( var i = 0 ; i < c . length ; i ++ ) { c [ i ] = new Array ( 2 ) ; } for ( var i = 0 ; i < c . length ; i ++ ) { for ( var j = 0 ; j < c . length ; j ++ ) { c [ i ] [ j ] = 0 ; } } let tmp = 1 ; for ( let i = 1 ; i <= n ; i ++ ) { if ( i >= tmp * 10 ) tmp *= 10 ; c [ Math . floor ( i / tmp ) ] [ i % 10 ] ++ ; } let ans = 0 ; for ( let i = 1 ; i < 10 ; i ++ ) for ( let j = 1 ; j < 10 ; j ++ ) ans += c [ i ] [ j ] * c [ j ] [ i ] ; return ans ; }
Ref: 
int pairs ( int n ) { vector < vector < int > > c ( 10 , vector < int > ( 10 , 0 ) ) ; int tmp = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i >= tmp * 10 ) tmp *= 10 ; c [ i / tmp ] [ i % 10 ] ++ ; } long long ans = 0 ; for ( int i = 1 ; i < 10 ; i ++ ) for ( int j = 1 ; j < 10 ; j ++ ) ans += ( long long ) c [ i ] [ j ] * c [ j ] [ i ] ; return ans ; }
Hyp: 
int pairs ( int n ) { int c [ 10 ] [ 2 ] ; for ( int i = 0 ; i < 10 ; i ++ ) c [ i ] [ j ] = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) for ( int j = 1 ; j < 10 ; j ++ ) c [ i ] [ j ] = 0 ; int tmp = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i >= tmp * 10 ) tmp *= 10 ; c [ i / tmp ] [ i % 10 ] ++ ; } int ans = 0 ; for ( int i = 1 ; i < 10 ; i ++ ) for ( int j = 1 ; j < 10 ; j ++ ) ans += c [ i ] [ j ] * c [ j ] [ i ] ; return ans ; }

BLEU: 59.98
Edit Sim: 142


Src: 
function pell ( n ) { if ( n <= 2 ) return n ; return 2 * pell ( n - 1 ) + pell ( n - 2 ) ; }
Ref: 
int pell ( int n ) { if ( n <= 2 ) return n ; return 2 * pell ( n - 1 ) + pell ( n - 2 ) ; }
Hyp: 
int pell ( int n ) { if ( n <= 2 ) return n ; return 2 * pell ( n - 1 ) + pell ( n - 2 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function getmax ( arr , n , x ) { let s = 0 ; for ( let i = 0 ; i < n ; i ++ ) { s = s + arr [ i ] ; } document . write ( Math . min ( s , x ) ) ; }
Ref: 
void getmax ( int arr [ ] , int n , int x ) { int s = 0 ; for ( int i = 0 ; i < n ; i ++ ) { s = s + arr [ i ] ; } cout << min ( s , x ) ; }
Hyp: 
int getmax ( int arr [ ] , int n , int x ) { int s = 0 ; for ( int i = 0 ; i < n ; i ++ ) { s = s + arr [ i ] ; } cout << min ( s , x ) ; }

BLEU: 98.16
Edit Sim: 4


Src: 
function isPossible ( a , n ) { var cur = a [ 0 ] ; cur -- ; for ( var i = 1 ; i < n ; i ++ ) { var nxt = a [ i ] ; if ( nxt > cur ) nxt -- ; else if ( nxt < cur ) return false ; cur = nxt ; } return true ; }
Ref: 
bool isPossible ( int a [ ] , int n ) { int cur = a [ 0 ] ; cur -- ; for ( int i = 1 ; i < n ; i ++ ) { int nxt = a [ i ] ; if ( nxt > cur ) nxt -- ; else if ( nxt < cur ) return false ; cur = nxt ; } return true ; }
Hyp: 
bool isPossible ( int a [ ] , int n ) { int cur = a [ 0 ] ; cur -- ; for ( int i = 1 ; i < n ; i ++ ) { int nxt = a [ i ] ; if ( nxt > cur ) nxt -- ; else if ( nxt < cur ) return false ; cur = nxt ; } return true ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countNegative ( M , n , m ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < m ; j ++ ) { if ( M [ i ] [ j ] < 0 ) count += 1 ; else break ; } } return count ; }
Ref: 
int countNegative ( int M [ ] [ 4 ] , int n , int m ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( M [ i ] [ j ] < 0 ) count += 1 ; else break ; } } return count ; }
Hyp: 
int countNegative ( int M [ ] [ MAX ] , int n , int m ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( M [ i ] [ j ] < 0 ) count += 1 ; else break ; } } return count ; }

BLEU: 96.74
Edit Sim: 3


Src: 
function cyl ( R ) { if ( R < 0 ) return - 1 ; var V = ( ( 2 * 3.14 * Math . pow ( R , 3 ) ) / ( 3 * Math . sqrt ( 3 ) ) ) ; return V ; }
Ref: 
float cyl ( float R ) { if ( R < 0 ) return -1 ; float V = ( 2 * 3.14 * pow ( R , 3 ) ) / ( 3 * sqrt ( 3 ) ) ; return V ; }
Hyp: 
float cyl ( float R ) { if ( R < 0 ) return -1 ; float V = ( 2 * 3.14 * pow ( R , 3 ) ) / ( 3 * sqrt ( 3 ) ) ) ; return V ; }

BLEU: 97.23
Edit Sim: 2


Src: 
function largestNum ( arr ) { let set = new Set ( ) ; let res = 0 ; for ( let i = 0 ; i < arr . length ; i ++ ) { set . add ( arr [ i ] ) ; if ( set . has ( - 1 * arr [ i ] ) ) { res = Math . max ( res , Math . abs ( arr [ i ] ) ) ; } } return res ; }
Ref: 
int largestNum ( int arr [ ] , int n ) { set < int > st ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { st . insert ( arr [ i ] ) ; if ( st . find ( -1 * arr [ i ] ) != st . end ( ) ) { res = max ( res , abs ( arr [ i ] ) ) ; } } return res ; }
Hyp: 
int largestNum ( int arr [ ] , int n ) { unordered_set < int > set ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { set . insert ( arr [ i ] ) ; if ( set . find ( -1 * arr [ i ] ) != set . end ( ) ) { res = max ( res , abs ( arr [ i ] ) ) ; } } return res ; }

BLEU: 86.52
Edit Sim: 14


Src: 
function findSmallest ( a , n ) { for ( let i = 0 ; i < n ; i ++ ) { let j ; for ( j = 0 ; j < n ; j ++ ) if ( a [ j ] % a [ i ] >= 1 ) break ; if ( j == n ) return a [ i ] ; } return - 1 ; }
Ref: 
int findSmallest ( int a [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < n ; j ++ ) if ( a [ j ] % a [ i ] ) break ; if ( j == n ) return a [ i ] ; } return -1 ; }
Hyp: 
int findSmallest ( int a [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < n ; j ++ ) if ( a [ j ] % a [ i ] >= 1 ) break ; if ( j == n ) return a [ i ] ; } return -1 ; }

BLEU: 95.33
Edit Sim: 5


Src: 
function maxPairs ( nums , k ) { var m = new Map ( ) ; var result = 0 ; nums . forEach ( i => { if ( m . has ( i ) && m . get ( i ) > 0 ) { m . set ( i , m . get ( i ) - 1 ) ; result ++ ; } else { if ( m . has ( k - i ) ) m . set ( k - i , m . get ( k - i ) + 1 ) else m . set ( k - i , 1 ) } } ) ; document . write ( result ) ; }
Ref: 
void maxPairs ( vector < int > nums , int k ) { map < int , int > m ; int result = 0 ; for ( auto i : nums ) { if ( m . find ( i ) != m . end ( ) && m [ i ] > 0 ) { m [ i ] = m [ i ] - 1 ; result ++ ; } else { m [ k - i ] = m [ k - i ] + 1 ; } } cout << result ; }
Hyp: 
void maxPairs ( int nums [ ] , int k ) { unordered_map < int , int > m ; int result = 0 ; for ( int i : nums ) { if ( m . find ( i ) != m . end ( ) && m [ i ] > 0 ) { m [ i ] = m [ i ] - 1 ; result ++ ; } else { if ( m . find ( k - i ) != m . end ( ) ) m [ k - i ] ++ ; else m [ k - i ] = 1 ; } } ) ; cout << result << endl ; }

BLEU: 64.91
Edit Sim: 91


Src: 
function countOccurrences ( n , x ) { var count = 0 ; for ( var i = 1 ; i <= n ; i ++ ) { if ( x % i == 0 ) { if ( x / i <= n ) count ++ ; } } document . write ( count ) ; }
Ref: 
int countOccurrences ( int n , int x ) { int count = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( x % i == 0 ) { if ( x / i <= n ) count ++ ; } } cout << count ; }
Hyp: 
void countOccurrences ( int n , int x ) { int count = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( x % i == 0 ) { if ( x / i <= n ) count ++ ; } } cout << count ; }

BLEU: 98.23
Edit Sim: 4


Src: 
function printDivisors ( n ) { let v = [ ] ; let t = 0 ; for ( let i = 1 ; i <= parseInt ( Math . sqrt ( n ) ) ; i ++ ) { if ( n % i == 0 ) { if ( parseInt ( n / i ) == i ) document . write ( i + " " ) ; else { document . write ( i + " " ) ; v [ t ++ ] = parseInt ( n / i ) ; } } } for ( let i = v . length - 1 ; i >= 0 ; i -- ) { document . write ( v [ i ] + " " ) ; } }
Ref: 
void printDivisors ( int n ) { vector < int > v ; for ( int i = 1 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) printf ( " % d ▁ " , i ) ; else { printf ( " % d ▁ " , i ) ; v . push_back ( n / i ) ; } } } for ( int i = v . size ( ) - 1 ; i >= 0 ; i -- ) printf ( " % d ▁ " , v [ i ] ) ; }
Hyp: 
void printDivisors ( int n ) { vector < int > v ; int t = 0 ; for ( int i = 1 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) cout << i << " ▁ " ; else { cout << i << " ▁ " ; v [ t ++ ] = n / i ; } } } for ( int i = v . size ( ) - 1 ; i >= 0 ; i -- ) { cout << v [ i ] << " ▁ " ; } }

BLEU: 66.54
Edit Sim: 78


Src: 
function nthTerm ( n ) { return 5 * Math . pow ( n , 2 ) - 5 * n ; }
Ref: 
int nthTerm ( int n ) { return 5 * pow ( n , 2 ) - 5 * n ; }
Hyp: 
int nthTerm ( int n ) { return 5 * pow ( n , 2 ) - 5 * n ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function maximumSegments ( n , a , b , c ) { let dp = [ ] ; for ( let i = 0 ; i < n + 10 ; i ++ ) dp [ i ] = - 1 ; dp [ 0 ] = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( dp [ i ] != - 1 ) { dp [ i + a ] = Math . max ( dp [ i ] + 1 , dp [ i + a ] ) ; dp [ i + b ] = Math . max ( dp [ i ] + 1 , dp [ i + b ] ) ; dp [ i + c ] = Math . max ( dp [ i ] + 1 , dp [ i + c ] ) ; } } return dp [ n ] ; }
Ref: 
int maximumSegments ( int n , int a , int b , int c ) { int dp [ n + 1 ] ; memset ( dp , -1 , sizeof ( dp ) ) ; dp [ 0 ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( dp [ i ] != -1 ) { dp [ i + a ] = max ( dp [ i ] + 1 , dp [ i + a ] ) ; dp [ i + b ] = max ( dp [ i ] + 1 , dp [ i + b ] ) ; dp [ i + c ] = max ( dp [ i ] + 1 , dp [ i + c ] ) ; } } return dp [ n ] ; }
Hyp: 
int maximumSegments ( int n , int a , int b , int c ) { int dp [ n + 10 ] ; for ( int i = 0 ; i < n + 10 ; i ++ ) dp [ i ] = -1 ; dp [ 0 ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( dp [ i ] != -1 ) { dp [ i + a ] = max ( dp [ i ] + 1 , dp [ i + a ] ) ; dp [ i + b ] = max ( dp [ i ] + 1 , dp [ i + b ] ) ; dp [ i + c ] = max ( dp [ i ] + 1 , dp [ i + c ] ) ; } } return dp [ n ] ; }

BLEU: 84.44
Edit Sim: 39


Src: 
function maxSumAfterKReverse ( arr , K , N ) { let sum = Number . MIN_VALUE ; if ( K % 2 != 0 ) arr . reverse ( ) ; let currsum = 0 ; for ( let i = 0 ; i < N ; i ++ ) { currsum += arr [ i ] ; sum = Math . max ( sum , currsum ) ; } document . write ( sum ) ; }
Ref: 
int maxSumAfterKReverse ( int arr [ ] , int K , int N ) { int sum = INT_MIN ; if ( K & 1 ) reverse ( arr , arr + N ) ; int currsum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { currsum += arr [ i ] ; sum = max ( sum , currsum ) ; } cout << sum ; }
Hyp: 
void maxSumAfterKReverse ( int arr [ ] , int K , int N ) { int sum = INT_MIN ; if ( K % 2 != 0 ) reverse ( arr , arr + N , greater < int > ( ) ) ; int currsum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { currsum += arr [ i ] ; sum = max ( sum , currsum ) ; } cout << sum ; }

BLEU: 82.64
Edit Sim: 33


Src: 
function TetracontadigonalNum ( n ) { return ( 40 * n * n - 38 * n ) / 2 ; }
Ref: 
int TetracontadigonalNum ( int n ) { return ( 40 * n * n - 38 * n ) / 2 ; }
Hyp: 
int TetracontadigonalNum ( int n ) { return ( 40 * n * n - 38 * n ) / 2 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findSum ( n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum += i * ( n - i ) ; return 2 * sum ; }
Ref: 
int findSum ( int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += i * ( n - i ) ; return 2 * sum ; }
Hyp: 
int findSum ( int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += i * ( n - i ) ; return 2 * sum ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findMaximumPieces ( n ) { var x = parseInt ( n / 2 ) ; return ( ( x + 1 ) * ( n - x + 1 ) ) ; }
Ref: 
int findMaximumPieces ( int n ) { int x = n / 2 ; return ( ( x + 1 ) * ( n - x + 1 ) ) ; }
Hyp: 
int findMaximumPieces ( int n ) { int x = n / 2 ; return ( ( x + 1 ) * ( n - x + 1 ) ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function maxSum ( N ) { var ans = 0 ; for ( var u = 1 ; u <= N ; u ++ ) { for ( var v = 1 ; v <= N ; v ++ ) { if ( u == v ) continue ; var degreeU = 2 ; if ( u == 1 u == N ) degreeU = 1 ; var degreeV = 2 ; if ( v == 1 v == N ) degreeV = 1 ; ans += ( degreeU * degreeV ) ; } } return ans ; }
Ref: 
ll maxSum ( int N ) { ll ans = 0 ; for ( int u = 1 ; u <= N ; u ++ ) { for ( int v = 1 ; v <= N ; v ++ ) { if ( u == v ) continue ; int degreeU = 2 ; if ( u == 1 u == N ) degreeU = 1 ; int degreeV = 2 ; if ( v == 1 v == N ) degreeV = 1 ; ans += ( degreeU * degreeV ) ; } } return ans ; }
Hyp: 
int maxSum ( int N ) { int ans = 0 ; for ( int u = 1 ; u <= N ; u ++ ) { for ( int v = 1 ; v <= N ; v ++ ) { if ( u == v ) continue ; int degreeU = 2 ; if ( u == 1 u == N ) degreeU = 1 ; int degreeV = 2 ; if ( v == 1 v == N ) degreeV = 1 ; ans += ( degreeU * degreeV ) ; } } return ans ; }

BLEU: 96.46
Edit Sim: 6


Src: 
function maxResult ( n , a , b , c ) { let maxVal = 0 ; for ( let i = 0 ; i <= n ; i += a ) for ( let j = 0 ; j <= n - i ; j += b ) { let z = ( n - ( i + j ) ) / c ; if ( Math . floor ( z ) == Math . ceil ( z ) ) { let x = i / a ; let y = j / b ; maxVal = Math . max ( maxVal , x + y + z ) ; } } return maxVal ; }
Ref: 
int maxResult ( int n , int a , int b , int c ) { int maxVal = 0 ; for ( int i = 0 ; i <= n ; i += a ) { for ( int j = 0 ; j <= n - i ; j += b ) { float z = ( float ) ( n - ( i + j ) ) / ( float ) ( c ) ; if ( floor ( z ) == ceil ( z ) ) { int x = i / a ; int y = j / b ; maxVal = max ( maxVal , x + y + ( int ) z ) ; } } } return maxVal ; }
Hyp: 
int maxResult ( int n , int a , int b , int c ) { int maxVal = 0 ; for ( int i = 0 ; i <= n ; i += a ) for ( int j = 0 ; j <= n - i ; j += b ) { int z = ( n - ( i + j ) ) / c ; if ( floor ( z ) == ceil ( z ) ) { int x = i / a ; int y = j / b ; maxVal = max ( maxVal , x + y + z ) ; } } return maxVal ; }

BLEU: 82.48
Edit Sim: 40


Src: 
function check ( arr , x , n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let y = Math . sqrt ( arr [ i ] ) ; if ( Math . floor ( y ) == Math . ceil ( y ) ) { sum += arr [ i ] ; } } if ( sum % x == 0 ) return true ; else return false ; } let arr = [ 2 , 3 , 4 , 9 , 10 ] ; let n = arr . length ; let x = 13 ; if ( check ( arr , x , n ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
Ref: 
bool check ( int arr [ ] , int x , int n ) { long long sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { double x = sqrt ( arr [ i ] ) ; if ( floor ( x ) == ceil ( x ) ) { sum += arr [ i ] ; } } if ( sum % x == 0 ) return true ; else return false ; }
Hyp: 
bool check ( int arr [ ] , int x , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { long double y = sqrt ( arr [ i ] ) ; if ( floor ( y ) == ceil ( y ) ) { sum += arr [ i ] ; } } if ( sum % x == 0 ) return true ; else return false ; }

BLEU: 86.67
Edit Sim: 16


Src: 
function minCost ( cost ) { let dist = new Array ( N ) ; dist . fill ( 0 ) ; for ( let i = 0 ; i < N ; i ++ ) dist [ i ] = INF ; dist [ 0 ] = 0 ; for ( let i = 0 ; i < N ; i ++ ) for ( let j = i + 1 ; j < N ; j ++ ) if ( dist [ j ] > dist [ i ] + cost [ i ] [ j ] ) dist [ j ] = dist [ i ] + cost [ i ] [ j ] ; return dist [ N - 1 ] ; }
Ref: 
int minCost ( int cost [ ] [ N ] ) { int dist [ N ] ; for ( int i = 0 ; i < N ; i ++ ) dist [ i ] = INF ; dist [ 0 ] = 0 ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = i + 1 ; j < N ; j ++ ) if ( dist [ j ] > dist [ i ] + cost [ i ] [ j ] ) dist [ j ] = dist [ i ] + cost [ i ] [ j ] ; return dist [ N - 1 ] ; }
Hyp: 
int minCost ( int cost [ ] [ MAX ] ) { int dist [ N ] ; memset ( dist , 0 , sizeof ( dist ) ) ; for ( int i = 0 ; i < N ; i ++ ) dist [ i ] = INF ; dist [ 0 ] = 0 ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = i + 1 ; j < N ; j ++ ) if ( dist [ j ] > dist [ i ] + cost [ i ] [ j ] ) dist [ j ] = dist [ i ] + cost [ i ] [ j ] ; return dist [ N - 1 ] ; }

BLEU: 88.64
Edit Sim: 43


Src: 
function Square ( row , column , moves ) { var a = 0 , b = 0 , c = 0 , d = 0 , total = 0 ; a = row - moves ; b = row + moves ; c = column - moves ; d = column + moves ; if ( a < 1 ) a = 1 ; if ( c < 1 ) c = 1 ; if ( b > 8 ) b = 8 ; if ( d > 8 ) d = 8 ; total = ( b - a + 1 ) * ( d - c + 1 ) - 1 ; return total ; }
Ref: 
int Square ( int row , int column , int moves ) { int a = 0 , b = 0 , c = 0 , d = 0 , total = 0 ; a = row - moves ; b = row + moves ; c = column - moves ; d = column + moves ; if ( a < 1 ) a = 1 ; if ( c < 1 ) c = 1 ; if ( b > 8 ) b = 8 ; if ( d > 8 ) d = 8 ; total = ( b - a + 1 ) * ( d - c + 1 ) - 1 ; return total ; }
Hyp: 
int Square ( int row , int column , int moves ) { int a = 0 , b = 0 , c = 0 , d = 0 , total = 0 ; a = row - moves ; b = row + moves ; c = column - moves ; d = column + moves ; if ( a < 1 ) a = 1 ; if ( c < 1 ) c = 1 ; if ( b > 8 ) b = 8 ; if ( d > 8 ) d = 8 ; total = ( b - a + 1 ) * ( d - c + 1 ) - 1 ; return total ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function minPolets ( n , m ) { let ans = 0 ; if ( ( n % 2 != 0 ) && ( m % 2 != 0 ) ) { ans = Math . floor ( ( n * m ) / 2 ) + 1 ; } else { ans = Math . floor ( ( n * m ) / 2 ) ; } return ans ; }
Ref: 
int minPoints ( int n , int m ) { int ans = 0 ; if ( ( n % 2 != 0 ) && ( m % 2 != 0 ) ) { ans = ( ( n * m ) / 2 ) + 1 ; } else { ans = ( n * m ) / 2 ; } return ans ; }
Hyp: 
int minPolets ( int n , int m ) { int ans = 0 ; if ( ( n % 2 != 0 ) && ( m % 2 != 0 ) ) { ans = ( n * m ) / 2 + 1 ; } else { ans = ( n * m ) / 2 ; } return ans ; }

BLEU: 90.69
Edit Sim: 6


Src: 
function findLastElement ( arr , N ) { arr . sort ( ) ; let i = 0 ; for ( i = 1 ; i < N ; i ++ ) { if ( arr [ i ] - arr [ i - 1 ] != 0 && arr [ i ] - arr [ i - 1 ] != 2 ) { document . write ( " " + " " ) ; return ; } } document . write ( arr [ N - 1 ] + " " ) ; }
Ref: 
void findLastElement ( int arr [ ] , int N ) { sort ( arr , arr + N ) ; int i = 0 ; for ( i = 1 ; i < N ; i ++ ) { if ( arr [ i ] - arr [ i - 1 ] != 0 && arr [ i ] - arr [ i - 1 ] != 2 ) { cout << " - 1" << endl ; return ; } } cout << arr [ N - 1 ] << endl ; }
Hyp: 
void findLastElement ( int arr [ ] , int N ) { sort ( arr , arr + N ) ; int i = 0 ; for ( i = 1 ; i < N ; i ++ ) { if ( arr [ i ] - arr [ i - 1 ] != 0 && arr [ i ] - arr [ i - 1 ] != 2 ) { cout << " No " << endl ; return ; } } cout << arr [ N - 1 ] << endl ; }

BLEU: 96.27
Edit Sim: 3


Src: 
function check ( s ) { let l = s . length ; s . sort ( ) ; for ( let i = 1 ; i < l ; i ++ ) { if ( ( s [ i ] . charCodeAt ( ) - s [ i - 1 ] . charCodeAt ( ) ) != 1 ) return false ; } return true ; }
Ref: 
bool check ( string s ) { int l = s . length ( ) ; sort ( s . begin ( ) , s . end ( ) ) ; for ( int i = 1 ; i < l ; i ++ ) { if ( s [ i ] - s [ i - 1 ] != 1 ) return false ; } return true ; }
Hyp: 
bool check ( string s ) { int l = s . length ( ) ; sort ( s . begin ( ) , s . end ( ) ) ; for ( int i = 1 ; i < l ; i ++ ) { if ( ( s [ i ] - s [ i - 1 ] ) != 1 ) return false ; } return true ; }

BLEU: 93.97
Edit Sim: 4


Src: 
function findNumber ( N ) { let count = 0 ; while ( ( N & 1 ) == 1 ) { N = N >> 1 ; count ++ ; } return N << count ; }
Ref: 
int findNumber ( int N ) { int count = 0 ; while ( ( N & 1 ) == 1 ) { N = N >> 1 ; count ++ ; } return N << count ; }
Hyp: 
int findNumber ( int N ) { int count = 0 ; while ( ( N & 1 ) == 1 ) { N = N >> 1 ; count ++ ; } return N << count ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function canSplit ( S ) { let frequency = new Array ( 26 ) . fill ( 0 ) let cnt_singles = 0 let k = 0 for ( let i = 0 ; i < S . length ; i ++ ) { frequency [ S . charCodeAt ( i ) - ' ' . charCodeAt ( 0 ) ] += 1 } let odd = 0 let eve = 0 for ( let i = 0 ; i < 26 ; i ++ ) { if ( frequency [ i ] ) { odd += ( frequency [ i ] & 1 ) } } if ( eve >= odd ) { document . write ( " " ) } else { document . write ( " " ) } }
Ref: 
void canSplit ( string & S ) { vector < int > frequency ( 26 , 0 ) ; int cnt_singles = 0 ; int k = 0 ; for ( int i = 0 ; i < S . length ( ) ; i ++ ) frequency [ S [ i ] - ' a ' ] ++ ; int odd = 0 , eve = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( frequency [ i ] ) { odd += ( frequency [ i ] & 1 ) ; eve += frequency [ i ] / 2 ; } } if ( eve >= odd ) cout << " Yes " ; else cout << " No " ; }
Hyp: 
void canSplit ( string S ) { int frequency [ 26 ] = { 0 } int cnt_singles = 0 , k = 0 ; for ( char x : S ) frequency [ x - ' a ' ] += 1 ; int odd = 0 , eve = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( frequency [ i ] ) { odd += ( frequency [ i ] & 1 ) ; } } if ( eve >= odd ) { cout << " Yes " ; } else { cout << " No " ; } }

BLEU: 57.78
Edit Sim: 105


Src: 
function printSeriesSum ( N ) { let sum = 0 ; let a = 1 ; let cnt = 0 ; let flag = true ; sum += a ; while ( cnt < N ) { let nextElement ; if ( flag ) { nextElement = a * 2 ; sum += nextElement ; flag = ! flag ; } else { nextElement = a * 3 / 2 ; sum += nextElement ; flag = ! flag ; } a = nextElement ; cnt ++ ; } document . write ( sum ) ; }
Ref: 
void printSeriesSum ( int N ) { double sum = 0 ; int a = 1 ; int cnt = 0 ; bool flag = true ; sum += a ; while ( cnt < N ) { int nextElement ; if ( flag ) { nextElement = a * 2 ; sum += nextElement ; flag = ! flag ; } else { nextElement = a * 3 / 2 ; sum += nextElement ; flag = ! flag ; } a = nextElement ; cnt ++ ; } cout << sum << endl ; }
Hyp: 
void printSeriesSum ( int N ) { int sum = 0 ; int a = 1 ; int cnt = 0 ; bool flag = true ; sum += a ; while ( cnt < N ) { int nextElement ; if ( flag ) { nextElement = a * 2 ; sum += nextElement ; flag = ! flag ; } else { nextElement = a * 3 / 2 ; sum += nextElement ; flag = ! flag ; } a = nextElement ; cnt ++ ; } cout << sum ; }

BLEU: 93.99
Edit Sim: 14


Src: 
function Kmultiples ( n , k ) { var a = n ; for ( i = 1 ; i <= k ; i ++ ) { document . write ( n + " " + i + " " + a + " " ) ; var j = 0 ; while ( n >= ( 1 << j ) ) { a += n & ( 1 << j ) ; j ++ ; } } }
Ref: 
void Kmultiples ( int n , int k ) { int a = n ; for ( int i = 1 ; i <= k ; i ++ ) { cout << n << " ▁ * ▁ " << i << " ▁ = ▁ " << a << endl ; int j = 0 ; while ( n >= ( 1 << j ) ) { a += n & ( 1 << j ) ; j ++ ; } } }
Hyp: 
void Kmultiples ( unsigned int n , unsigned int k ) { unsigned int a = n ; for ( int i = 1 ; i <= k ; i ++ ) { cout << n << " * " << i << " * " << a << endl ; unsigned int j = 0 ; while ( n >= ( 1 << j ) ) { a += n & ( 1 << j ) ; j ++ ; } } }

BLEU: 81.76
Edit Sim: 45


Src: 
function countDigitOne ( n ) { let countr = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { let str = i . toString ( ) ; countr += str . split ( " " ) . length - 1 ; } return countr ; }
Ref: 
int countDigitOne ( int n ) { int countr = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { string str = to_string ( i ) ; countr += count ( str . begin ( ) , str . end ( ) , '1' ) ; } return countr ; }
Hyp: 
int countDigitOne ( int n ) { int countr = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { string str = to_string ( i ) ; countr += str . split ( "0" ) . size ( ) - 1 ; } return countr ; }

BLEU: 73.34
Edit Sim: 27


Src: 
function isFancy ( num ) { var fp = new Map ( ) ; fp . set ( ' ' , ' ' ) ; fp . set ( ' ' , ' ' ) ; fp . set ( ' ' , ' ' ) ; fp . set ( ' ' , ' ' ) ; fp . set ( ' ' , ' ' ) ; var n = num . length ; var l = 0 , r = n - 1 ; while ( l <= r ) { if ( ! fp . has ( num . charAt ( l ) ) || fp . get ( num . charAt ( l ) ) != num . charAt ( r ) ) return false ; l ++ ; r -- ; } return true ; }
Ref: 
bool isFancy ( string & num ) { map < char , char > fp ; fp [ '0' ] = '0' ; fp [ '1' ] = '1' ; fp [ '6' ] = '9' ; fp [ '8' ] = '8' ; fp [ '9' ] = '6' ; int n = num . length ( ) ; int l = 0 , r = n - 1 ; while ( l <= r ) { if ( fp . find ( num [ l ] ) == fp . end ( ) fp [ num [ l ] ] != num [ r ] ) return false ; l ++ ; r -- ; } return true ; }
Hyp: 
bool isFancy ( string num ) { unordered_map < char , int > fp ; fp [ ' A ' ] = ' B ' ; fp [ ' C ' ] = ' D ' ; fp [ ' E ' ] = ' C ' ; fp [ ' F ' ] = ' E ' ; int n = num . length ( ) ; int l = 0 , r = n - 1 ; while ( l <= r ) { if ( fp . find ( num [ l ] ) == fp . end ( ) ) return false ; l ++ ; r -- ; } return true ; }

BLEU: 60.33
Edit Sim: 83


Src: 
function numberOfWays ( x ) { if ( x == 0 x == 1 ) return 1 ; else return numberOfWays ( x - 1 ) + ( x - 1 ) * numberOfWays ( x - 2 ) ; }
Ref: 
int numberOfWays ( int x ) { if ( x == 0 x == 1 ) return 1 ; else return numberOfWays ( x - 1 ) + ( x - 1 ) * numberOfWays ( x - 2 ) ; }
Hyp: 
int numberOfWays ( int x ) { if ( x == 0 x == 1 ) return 1 ; else return numberOfWays ( x - 1 ) + ( x - 1 ) * numberOfWays ( x - 2 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function lengthOfLatusRectum ( A , B ) { var major = 2.0 * A ; var minor = 2.0 * B ; var latus_rectum = ( minor * minor ) / major ; return latus_rectum ; }
Ref: 
double lengthOfLatusRectum ( double A , double B ) { double major = 2.0 * A ; double minor = 2.0 * B ; double latus_rectum = ( minor * minor ) / major ; return latus_rectum ; }
Hyp: 
double lengthOfLatusRectum ( int A , int B ) { double major = 2.0 * A ; double minor = 2.0 * B ; double latus_rectum = ( minor * minor ) / major ; return latus_rectum ; }

BLEU: 87.35
Edit Sim: 12


Src: 
function isMagic ( n ) { var sum = 0 ; while ( n > 0 sum > 9 ) { if ( n = 0 ) { n = sum ; sum = 0 ; } sum += n % 10 ; n /= 10 ; } return ( sum = 1 ) ; }
Ref: 
bool isMagic ( int n ) { int sum = 0 ; while ( n > 0 sum > 9 ) { if ( n == 0 ) { n = sum ; sum = 0 ; } sum += n % 10 ; n /= 10 ; } return ( sum == 1 ) ; }
Hyp: 
int isMagic ( int n ) { int sum = 0 ; while ( n > 0 sum > 9 ) { if ( n = 0 ) { n = sum ; sum = 0 ; } sum += n % 10 ; n /= 10 ; } return ( sum = 1 ) ; }

BLEU: 89.2
Edit Sim: 6


Src: 
function gcd ( a , b ) { if ( a == b ) return a ; if ( a == 0 ) return b ; if ( b == 0 ) return a ; { return gcd ( a >> 1 , b ) ; return gcd ( a >> 1 , b >> 1 ) << 1 ; } if ( ( ~ b & 1 ) == 1 ) return gcd ( a , b >> 1 ) ; if ( a > b ) return gcd ( ( a - b ) >> 1 , b ) ; return gcd ( ( b - a ) >> 1 , a ) ; }
Ref: 
int gcd ( int a , int b ) { if ( a == b ) return a ; if ( a == 0 ) return b ; if ( b == 0 ) return a ; { return gcd ( a >> 1 , b ) ; return gcd ( a >> 1 , b >> 1 ) << 1 ; } return gcd ( a , b >> 1 ) ; if ( a > b ) return gcd ( ( a - b ) >> 1 , b ) ; return gcd ( ( b - a ) >> 1 , a ) ; }
Hyp: 
int gcd ( int a , int b ) { if ( a == b ) return a ; if ( a == 0 ) return b ; if ( b == 0 ) return a ; { return gcd ( a >> 1 , b ) ; return gcd ( a >> 1 , b >> 1 ) << 1 ; } if ( ( ~ b & 1 ) == 1 ) return gcd ( a , b >> 1 ) ; if ( a > b ) return gcd ( ( a - b ) >> 1 , b ) ; return gcd ( ( b - a ) >> 1 , a ) ; }

BLEU: 89.44
Edit Sim: 24


Src: 
function powerOptimised ( a , n ) { let ans = 1 ; while ( n > 0 ) { let last_bit = ( n & 1 ) ; if ( last_bit > 0 ) { ans = ans * a ; } a = a * a ; n = n >> 1 ; } return ans ; }
Ref: 
int powerOptimised ( int a , int n ) { int ans = 1 ; while ( n > 0 ) { int last_bit = ( n & 1 ) ; if ( last_bit ) { ans = ans * a ; } a = a * a ; n = n >> 1 ; } return ans ; }
Hyp: 
int powerOptimised ( int a , int n ) { int ans = 1 ; while ( n > 0 ) { bool last_bit = ( n & 1 ) ; if ( last_bit ) { ans = ans * a ; } a = a * a ; n = n >> 1 ; } return ans ; }

BLEU: 95.74
Edit Sim: 4


Src: 
function numberOfDigits ( N ) { let nod = Math . floor ( Math . log10 ( N ) + 1 ) ; let toDecrease = ( Math . pow ( 10 , nod ) - 1 ) / 9 ; document . write ( ( N + 1 ) * nod - toDecrease ) ; }
Ref: 
void numberOfDigits ( int N ) { int nod = floor ( log10 ( N ) + 1 ) ; int toDecrease = ( pow ( 10 , nod ) - 1 ) / 9 ; cout << ( N + 1 ) * nod - toDecrease << endl ; }
Hyp: 
void numberOfDigits ( int N ) { int nod = log10 ( N ) + 1 ; int toDecrease = ( pow ( 10 , nod ) - 1 ) / 9 ; cout << ( N + 1 ) * nod - toDecrease ; }

BLEU: 80.94
Edit Sim: 18


Src: 
function Squares ( n , m , a ) { return parseInt ( ( ( m + a - 1 ) / a ) ) * parseInt ( ( ( n + a - 1 ) / a ) ) ; }
Ref: 
int Squares ( int n , int m , int a ) { return ( ( m + a - 1 ) / a ) * ( ( n + a - 1 ) / a ) ; }
Hyp: 
int Squares ( int n , int m , int a ) { return ( ( m + a - 1 ) / a ) * ( ( n + a - 1 ) / a ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countTrailingZero ( x ) { let lookup = [ 32 , 0 , 1 , 26 , 2 , 23 , 27 , 0 , 3 , 16 , 24 , 30 , 28 , 11 , 0 , 13 , 4 , 7 , 17 , 0 , 25 , 22 , 31 , 15 , 29 , 10 , 12 , 6 , 0 , 21 , 14 , 9 , 5 , 20 , 8 , 19 , 18 ] ; return lookup [ ( - x & x ) % 37 ] ; }
Ref: 
int countTrailingZero ( int x ) { static const int lookup [ ] = { 32 , 0 , 1 , 26 , 2 , 23 , 27 , 0 , 3 , 16 , 24 , 30 , 28 , 11 , 0 , 13 , 4 , 7 , 17 , 0 , 25 , 22 , 31 , 15 , 29 , 10 , 12 , 6 , 0 , 21 , 14 , 9 , 5 , 20 , 8 , 19 , 18 } ; return lookup [ ( - x & x ) % 37 ] ; }
Hyp: 
int countTrailingZero ( int x ) { int lookup [ 37 ] ; lookup [ 32 ] = { 0 , 1 , 26 , 2 , 23 , 27 , 0 , 3 , 16 , 24 , 30 , 28 , 11 , 0 , 13 , 4 , 7 , 17 , 0 , 25 , 22 , 31 , 15 , 29 , 10 , 12 , 6 , 0 , 21 , 14 , 9 , 5 , 20 , 8 , 19 , 18 } ; return lookup [ ( - x & x ) % 37 ] ; }

BLEU: 90.17
Edit Sim: 24


Src: 
function printPairs ( arr , n , k ) { let isPairFound = true ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { if ( i != j && arr [ i ] % arr [ j ] == k ) { document . write ( " " + arr [ i ] + " " + arr [ j ] + " " + " " ) ; isPairFound = true ; } } } return isPairFound ; }
Ref: 
bool printPairs ( int arr [ ] , int n , int k ) { bool isPairFound = true ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i != j && arr [ i ] % arr [ j ] == k ) { cout << " ( " << arr [ i ] << " , ▁ " << arr [ j ] << " ) " << " ▁ " ; isPairFound = true ; } } } return isPairFound ; }
Hyp: 
bool printPairs ( int arr [ ] , int n , int k ) { bool isPairFound = false ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i != j && arr [ i ] % arr [ j ] == k ) { cout << " ( " << arr [ i ] << " , ▁ " << arr [ j ] << " ) " << " ) " << endl ; isPairFound = true ; } } } return isPairFound ; }

BLEU: 92.93
Edit Sim: 13


Src: 
function extrema ( a , n ) { let count = 0 ; for ( let i = 1 ; i < n - 1 ; i ++ ) { if ( a [ i ] > a [ i - 1 ] && a [ i ] > a [ i + 1 ] ) count += 1 ; if ( a [ i ] < a [ i - 1 ] && a [ i ] < a [ i + 1 ] ) count += 1 ; } return count ; }
Ref: 
int extrema ( int a [ ] , int n ) { int count = 0 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { count += ( a [ i ] > a [ i - 1 ] && a [ i ] > a [ i + 1 ] ) ; count += ( a [ i ] < a [ i - 1 ] && a [ i ] < a [ i + 1 ] ) ; } return count ; }
Hyp: 
int extrema ( int a [ ] , int n ) { int count = 0 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( a [ i ] > a [ i - 1 ] && a [ i ] > a [ i + 1 ] ) count += 1 ; if ( a [ i ] < a [ i - 1 ] && a [ i ] < a [ i + 1 ] ) count += 1 ; } return count ; }

BLEU: 87.84
Edit Sim: 28


Src: 
function findSum ( N , k ) { let sum = 0 ; for ( let i = 1 ; i <= N ; i ++ ) { sum += Math . pow ( i , k ) ; } return sum ; }
Ref: 
int findSum ( int N , int k ) { int sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { sum += pow ( i , k ) ; } return sum ; }
Hyp: 
int findSum ( int N , int k ) { int sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { sum += pow ( i , k ) ; } return sum ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function endPointOfDiameterofCircle ( x1 , y1 , c1 , c2 ) { document . write ( " " + ( 2 * c1 - x1 ) + " " ) ; document . write ( " " + ( 2 * c2 - y1 ) ) ; }
Ref: 
void endPointOfDiameterofCircle ( int x1 , int y1 , int c1 , int c2 ) { cout << " x2 ▁ = ▁ " << ( float ) ( 2 * c1 - x1 ) << " ▁ " ; cout << " y2 ▁ = ▁ " << ( float ) ( 2 * c2 - y1 ) ; }
Hyp: 
void endPointOfDiameterofCircle ( int x1 , int y1 , int c1 , int c2 ) { cout << " The ▁ end ▁ of ▁ the ▁ circle ▁ is ▁ " << ( 2 * c1 - x1 ) << " , ▁ " << ( 2 * c2 - y1 ) << endl ; }

BLEU: 61.21
Edit Sim: 62


Src: 
function Convert ( radian ) { let pi = 3.14159 ; return ( radian * ( 180 / pi ) ) ; }
Ref: 
double Convert ( double radian ) { double pi = 3.14159 ; return ( radian * ( 180 / pi ) ) ; }
Hyp: 
double Convert ( double radian ) { double pi = 3.14159 ; return ( radian * ( 180 / pi ) ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function printpairs ( arr , sum ) { let s = new Set ( ) ; for ( let i = 0 ; i < arr . length ; ++ i ) { let temp = sum - arr [ i ] ; if ( s . has ( temp ) ) { document . write ( " " + sum + " " + arr [ i ] + " " + temp + " " ) ; } s . add ( arr [ i ] ) ; } }
Ref: 
void printPairs ( int arr [ ] , int arr_size , int sum ) { unordered_set < int > s ; for ( int i = 0 ; i < arr_size ; i ++ ) { int temp = sum - arr [ i ] ; if ( s . find ( temp ) != s . end ( ) ) cout << " Pair ▁ with ▁ given ▁ sum ▁ " << sum << " ▁ is ▁ ( " << arr [ i ] << " , " << temp << " ) " << endl ; s . insert ( arr [ i ] ) ; } }
Hyp: 
void printpairs ( int arr [ ] , int sum ) { unordered_set < int > s ; for ( int i = 0 ; i < arr . length ( ) ; ++ i ) { int temp = sum - arr [ i ] ; if ( s . find ( temp ) != s . end ( ) ) { cout << " ( " << sum << " , ▁ " << arr [ i ] << " , ▁ " << temp << " ) " ; } s . insert ( arr [ i ] ) ; } }

BLEU: 72.27
Edit Sim: 75


Src: 
function printPermutation ( n , k ) { for ( var i = 1 ; i <= n ; i ++ ) { var x = 2 * i - 1 ; var y = 2 * i ; if ( i <= k ) document . write ( y + " " + x + " " ) ; else document . write ( x + " " + y + " " ) ; } }
Ref: 
void printPermutation ( int n , int k ) { for ( int i = 1 ; i <= n ; i ++ ) { int x = 2 * i - 1 ; int y = 2 * i ; if ( i <= k ) cout << y << " ▁ " << x << " ▁ " ; else cout << x << " ▁ " << y << " ▁ " ; } }
Hyp: 
void printPermutation ( int n , int k ) { for ( int i = 1 ; i <= n ; i ++ ) { int x = 2 * i - 1 ; int y = 2 * i ; if ( i <= k ) cout << y << " * " << x ; else cout << x << " * " << y ; } }

BLEU: 78.62
Edit Sim: 20


Src: 
function PrintReverseOrder ( N ) { for ( let i = N ; i > 0 ; i -- ) document . write ( i + " " ) ; }
Ref: 
void PrintReverseOrder ( int N ) { for ( int i = N ; i > 0 ; i -- ) cout << i << " ▁ " ; }
Hyp: 
void PrintReverseOrder ( int N ) { for ( int i = N ; i > 0 ; i -- ) cout << i << " ▁ " ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function to_upper ( input ) { var result = new Array ( input . length ) ; for ( var i = 0 ; i < input . length ; i ++ ) if ( " " . charCodeAt ( 0 ) <= input [ i ] . charCodeAt ( 0 ) <= " " . charCodeAt ( 0 ) ) result [ i ] = String . fromCharCode ( input [ i ] . charCodeAt ( 0 ) - " " . charCodeAt ( 0 ) + " " . charCodeAt ( 0 ) ) ; return result . join ( " " ) . toString ( ) ; }
Ref: 
string to_upper ( string & in ) { for ( int i = 0 ; i < in . length ( ) ; i ++ ) if ( ' a ' <= in [ i ] <= ' z ' ) in [ i ] = in [ i ] - ' a ' + ' A ' ; return in ; }
Hyp: 
string to_upper ( string input ) { vector < char > result ( input . length ( ) ) ; for ( int i = 0 ; i < input . length ( ) ; i ++ ) if ( ' A ' <= input [ i ] and ' Z ' <= input [ i ] and ' a ' <= ' z ' ) result [ i ] = char ( input [ i ] - ' a ' + ' z ' ) ; return result . toString ( ) ; }

BLEU: 41.82
Edit Sim: 130


Src: 
function countWays ( n ) { let count = 0 ; for ( let i = 1 ; i * i < n ; i ++ ) if ( n % i == 0 ) count ++ ; return count ; }
Ref: 
int countWays ( int n ) { int count = 0 ; for ( int i = 1 ; i * i < n ; i ++ ) if ( n % i == 0 ) count ++ ; return count ; }
Hyp: 
int countWays ( int n ) { int count = 0 ; for ( int i = 1 ; i * i < n ; i ++ ) if ( n % i == 0 ) count ++ ; return count ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findMin ( arr , n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; arr . sort ( ) ; let min = arr [ 0 ] ; let max = 0 ; for ( let i = n - 1 ; i >= 1 ; i -- ) { let num = arr [ i ] ; let total = num + min ; let j ; for ( j = 2 ; j <= num ; j ++ ) { if ( num % j == 0 ) { let d = j ; let now = parseInt ( num / d ) + ( min * d ) ; let reduce = total - now ; if ( reduce > max ) max = reduce ; } } } document . write ( sum - max ) ; }
Ref: 
void findMin ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; sort ( arr , arr + n ) ; int min = arr [ 0 ] ; int max = 0 ; for ( int i = n - 1 ; i >= 1 ; i -- ) { int num = arr [ i ] ; int total = num + min ; int j ; for ( j = 2 ; j <= num ; j ++ ) { if ( num % j == 0 ) { int d = j ; int now = ( num / d ) + ( min * d ) ; int reduce = total - now ; if ( reduce > max ) max = reduce ; } } } cout << ( sum - max ) ; }
Hyp: 
void findMin ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; sort ( arr , arr + n ) ; int min = arr [ 0 ] ; int max = 0 ; for ( int i = n - 1 ; i >= 1 ; i -- ) { int num = arr [ i ] ; int total = num + min ; int j ; for ( j = 2 ; j <= num ; j ++ ) { if ( num % j == 0 ) { int d = j ; int now = num / d + ( min * d ) ; int reduce = total - now ; if ( reduce > max ) max = reduce ; } } } cout << sum - max ; }

BLEU: 94.07
Edit Sim: 8


Src: 
function digitsNum ( N ) { if ( N == 0 ) document . write ( " " ) ; if ( N % 9 != 0 ) document . write ( N % 9 ) ; for ( var i = 1 ; i <= N / 9 ; ++ i ) document . write ( " " ) ; for ( var i = 1 ; i <= N ; ++ i ) document . write ( " " ) ; document . write ( " " ) ; }
Ref: 
void digitsNum ( int N ) { if ( N == 0 ) cout << "0 STRNEWLINE " ; if ( N % 9 != 0 ) cout << ( N % 9 ) ; for ( int i = 1 ; i <= ( N / 9 ) ; ++ i ) cout << "9" ; for ( int i = 1 ; i <= N ; ++ i ) cout << "0" ; cout << " STRNEWLINE " ; }
Hyp: 
void digitsNum ( int N ) { if ( N == 0 ) cout << "0" ; if ( N % 9 != 0 ) cout << N % 9 ; for ( int i = 1 ; i <= N / 9 ; ++ i ) cout << "0" ; for ( int i = 1 ; i <= N ; ++ i ) cout << "1" ; cout << "2" ; }

BLEU: 71.75
Edit Sim: 34


Src: 
function printKDistinct ( arr , n , k ) { var dist_count = 0 ; for ( var i = 0 ; i < n ; i ++ ) { var j ; for ( j = 0 ; j < n ; j ++ ) if ( i != j && arr [ j ] == arr [ i ] ) break ; if ( j == n ) dist_count ++ ; if ( dist_count == k ) return arr [ i ] ; } return - 1 ; }
Ref: 
int printKDistinct ( int arr [ ] , int n , int k ) { int dist_count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < n ; j ++ ) if ( i != j && arr [ j ] == arr [ i ] ) break ; if ( j == n ) dist_count ++ ; if ( dist_count == k ) return arr [ i ] ; } return -1 ; }
Hyp: 
int printKDistinct ( int arr [ ] , int n , int k ) { int dist_count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < n ; j ++ ) if ( i != j && arr [ j ] == arr [ i ] ) break ; if ( j == n ) dist_count ++ ; if ( dist_count == k ) return arr [ i ] ; } return -1 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function minNum ( arr , n ) { let odd = false ; for ( let i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 != 0 ) odd = ! odd ; if ( odd ) return 1 ; return 2 ; }
Ref: 
int minNum ( int arr [ ] , int n ) { bool odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 ) odd = ! odd ; if ( odd ) return 1 ; return 2 ; }
Hyp: 
int minNum ( int arr [ ] , int n ) { bool odd = false ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 != 0 ) odd = ! odd ; if ( odd ) return 1 ; return 2 ; }

BLEU: 89.79
Edit Sim: 10


Src: 
function circle ( x1 , y1 , x2 , y2 , r1 , r2 ) { let distSq = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ; let radSumSq = ( r1 + r2 ) * ( r1 + r2 ) ; if ( distSq == radSumSq ) return 1 ; else if ( distSq > radSumSq ) return - 1 ; else return 0 ; }
Ref: 
int circle ( int x1 , int y1 , int x2 , int y2 , int r1 , int r2 ) { int distSq = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ; int radSumSq = ( r1 + r2 ) * ( r1 + r2 ) ; if ( distSq == radSumSq ) return 1 ; else if ( distSq > radSumSq ) return -1 ; else return 0 ; }
Hyp: 
int circle ( int x1 , int y1 , int x2 , int y2 , int r1 , int r2 ) { int distSq = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ; int radSumSq = ( r1 + r2 ) * ( r1 + r2 ) ; if ( distSq == radSumSq ) return 1 ; else if ( distSq > radSumSq ) return -1 ; else return 0 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function radius ( n , d ) { document . write ( " " + d / ( 2 * n - 2 ) ) ; }
Ref: 
void radius ( int n , int d ) { cout << " The ▁ radius ▁ of ▁ each ▁ circle ▁ is ▁ " << d / ( 2 * n - 2 ) << endl ; }
Hyp: 
void radius ( int n , int d ) { cout << " The ▁ radius ▁ of ▁ the ▁ circle ▁ is ▁ " << d / ( 2 * n - 2 ) << endl ; }

BLEU: 93.54
Edit Sim: 4


Src: 
function nthTerm ( N ) { let nth = 0 , first_term = 12 ; nth = ( first_term * ( Math . pow ( 2 , N - 1 ) ) ) + 11 * ( ( Math . pow ( 2 , N - 1 ) ) - 1 ) ; return nth ; }
Ref: 
int nthTerm ( int N ) { int nth = 0 , first_term = 12 ; nth = ( first_term * ( pow ( 2 , N - 1 ) ) ) + 11 * ( ( pow ( 2 , N - 1 ) ) - 1 ) ; return nth ; }
Hyp: 
int nthTerm ( int N ) { int nth = 0 , first_term = 12 ; nth = ( first_term * ( pow ( 2 , N - 1 ) ) ) + 11 * ( ( pow ( 2 , N - 1 ) ) - 1 ) ; return nth ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function printBalancedExpression ( a , b , c , d ) { if ( ( ( a == d ) && ( a != 0 ) ) || ( ( a == 0 ) && ( c == 0 ) && ( d == 0 ) ) ) { for ( i = 1 ; i <= a ; i ++ ) document . write ( " " ) ; for ( i = 1 ; i <= c ; i ++ ) document . write ( " " ) ; for ( i = 1 ; i <= d ; i ++ ) document . write ( " " ) ; for ( i = 1 ; i <= b ; i ++ ) document . write ( " " ) ; } else document . write ( - 1 ) ; }
Ref: 
void printBalancedExpression ( int a , int b , int c , int d ) { if ( ( a == d && a ) || ( a == 0 && c == 0 && d == 0 ) ) { for ( int i = 1 ; i <= a ; i ++ ) cout << " ( ( " ; for ( int i = 1 ; i <= c ; i ++ ) cout << " ) ( " ; for ( int i = 1 ; i <= d ; i ++ ) cout << " ) ) " ; for ( int i = 1 ; i <= b ; i ++ ) cout << " ( ) " ; } else cout << -1 ; }
Hyp: 
void printBalancedExpression ( int a , int b , int c , int d ) { if ( ( ( a == d ) && ( a != 0 ) ) || ( ( a == 0 ) && ( c == 0 ) && ( d == 0 ) ) ) { for ( int i = 1 ; i <= a ; i ++ ) cout << " ▁ " ; for ( int i = 1 ; i <= c ; i ++ ) cout << " ▁ " ; for ( int i = 1 ; i <= d ; i ++ ) cout << " ▁ " ; for ( int i = 1 ; i <= b ; i ++ ) cout << " STRNEWLINE " ; } else cout << -1 ; }

BLEU: 79.06
Edit Sim: 44


Src: 
function area ( a ) { if ( a < 0 ) return - 1 ; var area = Math . pow ( ( a * Math . sqrt ( 3 ) ) / ( Math . sqrt ( 2 ) ) , 2 ) ; return area ; }
Ref: 
float area ( float a ) { if ( a < 0 ) return -1 ; float area = pow ( ( a * sqrt ( 3 ) ) / ( sqrt ( 2 ) ) , 2 ) ; return area ; }
Hyp: 
float area ( float a ) { if ( a < 0 ) return -1 ; float area = pow ( ( a * sqrt ( 3 ) ) / ( sqrt ( 2 ) ) , 2 ) ; return area ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function pairCount ( n , m ) { var cnt = 0 , b , a ; for ( b = 0 ; b <= Math . sqrt ( m ) ; b ++ ) { a = m - b * b ; if ( a * a + b == n ) { cnt ++ ; } } return cnt ; }
Ref: 
int pairCount ( int n , int m ) { int cnt = 0 , b , a ; for ( b = 0 ; b <= sqrt ( m ) ; b ++ ) { a = m - b * b ; if ( a * a + b == n ) { cnt ++ ; } } return cnt ; }
Hyp: 
int pairCount ( int n , int m ) { int cnt = 0 , b , a ; for ( b = 0 ; b <= sqrt ( m ) ; b ++ ) { a = m - b * b ; if ( a * a + b == n ) { cnt ++ ; } } return cnt ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function nthHarmonic ( N ) { let harmonic = 1.00 ; for ( let i = 2 ; i <= N ; i ++ ) { harmonic += parseFloat ( 1 ) / i ; } return harmonic ; }
Ref: 
double nthHarmonic ( int N ) { float harmonic = 1.00 ; for ( int i = 2 ; i <= N ; i ++ ) { harmonic += ( float ) 1 / i ; } return harmonic ; }
Hyp: 
double nthHarmonic ( int N ) { double harmonic = 1.00 ; for ( int i = 2 ; i <= N ; i ++ ) { harmonic += ( float ) 1 / i ; } return harmonic ; }

BLEU: 93.7
Edit Sim: 6


Src: 
function MinDiff ( n ) { var val = parseInt ( Math . pow ( 2 , n ) ) ; var sep = n / 2 ; var grp1 = 0 ; var grp2 = 0 ; grp1 = grp1 + val ; for ( i = 1 ; i < sep ; i ++ ) grp1 = grp1 + parseInt ( Math . pow ( 2 , i ) ) ; for ( i = sep ; i < n ; i ++ ) grp2 = grp2 + parseInt ( Math . pow ( 2 , i ) ) ; document . write ( Math . abs ( grp1 - grp2 ) ) ; }
Ref: 
void MinDiff ( int n ) { int val = pow ( 2 , n ) ; int sep = n / 2 ; int grp1 = 0 ; int grp2 = 0 ; grp1 = grp1 + val ; for ( int i = 1 ; i < sep ; i ++ ) grp1 = grp1 + pow ( 2 , i ) ; for ( int i = sep ; i < n ; i ++ ) grp2 = grp2 + pow ( 2 , i ) ; cout << ( abs ( grp1 - grp2 ) ) ; }
Hyp: 
void MinDiff ( int n ) { int val = pow ( 2 , n ) ; int sep = n / 2 ; int grp1 = 0 ; int grp2 = 0 ; grp1 = grp1 + val ; for ( int i = 1 ; i < sep ; i ++ ) grp1 = grp1 + pow ( 2 , i ) ; for ( int i = sep ; i < n ; i ++ ) grp2 = grp2 + pow ( 2 , i ) ; cout << abs ( grp1 - grp2 ) ; }

BLEU: 95.76
Edit Sim: 4


Src: 
function printNumberWithDR ( k , d ) { if ( d == 0 && k != 1 ) document . write ( " " ) ; else { document . write ( d ) ; k -- ; while ( k -- > 0 ) document . write ( " " ) ; } }
Ref: 
void printNumberWithDR ( int k , int d ) { if ( d == 0 && k != 1 ) cout << " - 1" ; else { cout << d ; k -- ; while ( k -- ) cout << "0" ; } }
Hyp: 
void printNumberWithDR ( int k , int d ) { if ( d == 0 && k != 1 ) cout << "0" ; else { cout << d ; k -- ; while ( k -- ) cout << "0" ; } }

BLEU: 89.96
Edit Sim: 4


Src: 
function findNthDigit ( p , q , N ) { var res ; while ( N > 0 ) { N -- ; p *= 10 ; res = parseInt ( p / q ) ; p %= q ; } return res ; }
Ref: 
int findNthDigit ( int p , int q , int N ) { int res ; while ( N > 0 ) { N -- ; p *= 10 ; res = p / q ; p %= q ; } return res ; }
Hyp: 
int findNthDigit ( long int p , long int q , int N ) { int res ; while ( N -- ) { p *= 10 ; res = p / q ; p %= q ; } return res ; }

BLEU: 75.88
Edit Sim: 20


Src: 
function knapSack ( nums , S ) { let sum = 0 ; for ( let i = 0 ; i < nums . length ; i ++ ) sum += nums [ i ] ; if ( sum < S || - sum > - S || ( S + sum ) % 2 == 1 ) return 0 ; let dp = new Array ( parseInt ( ( S + sum ) / 2 , 10 ) + 1 ) ; dp . fill ( 0 ) ; dp [ 0 ] = 1 ; for ( let num = 0 ; num < nums . length ; num ++ ) { for ( let i = dp . length - 1 ; i >= nums [ num ] ; i -- ) { dp [ i ] += dp [ i - nums [ num ] ] ; } } return dp [ dp . length - 1 ] ; }
Ref: 
int knapSack ( int nums [ ] , int S , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += nums [ i ] ; if ( sum < S || - sum > - S || ( S + sum ) % 2 == 1 ) return 0 ; int dp [ ( S + sum ) / 2 + 1 ] ; for ( int i = 0 ; i <= ( S + sum ) / 2 ; i ++ ) dp [ i ] = 0 ; dp [ 0 ] = 1 ; for ( int j = 0 ; j < n ; j ++ ) { for ( int i = ( S + sum ) / 2 ; i >= nums [ j ] ; i -- ) { dp [ i ] += dp [ i - nums [ j ] ] ; } } return dp [ ( S + sum ) / 2 ] ; }
Hyp: 
int knapSack ( int nums [ ] , int S ) { int sum = 0 ; for ( int i = 0 ; i < nums . size ( ) ; i ++ ) sum += nums [ i ] ; if ( sum < S || - sum > - S || ( S + sum ) % 2 == 1 ) return 0 ; int dp [ ( S + sum ) / 2 + 1 ] ; dp [ 0 ] = 1 ; for ( int num = 0 ; num < nums . size ( ) ; num ++ ) { for ( int i = dp . size ( ) - 1 ; i >= nums [ num ] ; i -- ) { dp [ i ] += dp [ i - nums [ num ] ] ; } } return dp [ dp . size ( ) - 1 ] ; }

BLEU: 64.46
Edit Sim: 122


Src: 
function swapBits ( x ) { even_bits = x & 0xAAAAAAAA ; odd_bits = x & 0x55555555 ; even_bits >>= 1 ; odd_bits <<= 1 ; return ( even_bits odd_bits ) ; }
Ref: 
int swapBits ( unsigned int x ) { unsigned int even_bits = x & 0xAAAAAAAA ; unsigned int odd_bits = x & 0x55555555 ; even_bits >>= 1 ; odd_bits <<= 1 ; return ( even_bits odd_bits ) ; }
Hyp: 
int swapBits ( int x ) { even_bits = x & 0AAAAAAAA ; odd_bits = x & 0x55555555 ; even_bits >>= 1 ; odd_bits <<= 1 ; return ( even_bits odd_bits ) ; }

BLEU: 69.16
Edit Sim: 36


Src: 
function findMaxAverage ( arr , n , k ) { if ( k > n ) return - 1 ; let sum = arr [ 0 ] ; for ( let i = 1 ; i < k ; i ++ ) sum += arr [ i ] ; let max_sum = sum ; let max_end = k - 1 ; for ( let i = k ; i < n ; i ++ ) { sum = sum + arr [ i ] - arr [ i - k ] ; if ( sum > max_sum ) { max_sum = sum ; max_end = i ; } } return max_end - k + 1 ; }
Ref: 
int findMaxAverage ( int arr [ ] , int n , int k ) { if ( k > n ) return -1 ; int sum = arr [ 0 ] ; for ( int i = 1 ; i < k ; i ++ ) sum += arr [ i ] ; int max_sum = sum , max_end = k - 1 ; for ( int i = k ; i < n ; i ++ ) { int sum = sum + arr [ i ] - arr [ i - k ] ; if ( sum > max_sum ) { max_sum = sum ; max_end = i ; } } return max_end - k + 1 ; }
Hyp: 
int findMaxAverage ( int arr [ ] , int n , int k ) { if ( k > n ) return -1 ; int sum = arr [ 0 ] ; for ( int i = 1 ; i < k ; i ++ ) sum += arr [ i ] ; int max_sum = sum ; int max_end = k - 1 ; for ( int i = k ; i < n ; i ++ ) { sum = sum + arr [ i ] - arr [ i - k ] ; if ( sum > max_sum ) { max_sum = sum ; max_end = i ; } } return max_end - k + 1 ; }

BLEU: 96.01
Edit Sim: 9


Src: 
function check ( str ) { let n = str . length ; let oddDigSum = 0 , evenDigSum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) oddDigSum += ( str [ i ] - ' ' ) ; else evenDigSum += ( str [ i ] - ' ' ) ; } return ( ( oddDigSum - evenDigSum ) % 11 == 0 ) ; }
Ref: 
int check ( string str ) { int n = str . length ( ) ; int oddDigSum = 0 , evenDigSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) oddDigSum += ( str [ i ] - '0' ) ; else evenDigSum += ( str [ i ] - '0' ) ; } return ( ( oddDigSum - evenDigSum ) % 11 == 0 ) ; }
Hyp: 
bool check ( string str ) { int n = str . length ( ) ; int oddDigSum = 0 , evenDigSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) oddDigSum += ( str [ i ] - '0' ) ; else evenDigSum += ( str [ i ] - '0' ) ; } return ( ( oddDigSum - evenDigSum ) % 11 == 0 ) ; }

BLEU: 98.83
Edit Sim: 4


Src: 
function numberSequence ( n ) { let num = Math . pow ( 4 , n ) - Math . pow ( 2 , n ) - 1 ; return num ; }
Ref: 
int numberSequence ( int n ) { int num = pow ( 4 , n ) - pow ( 2 , n ) - 1 ; return num ; }
Hyp: 
int numberSequence ( int n ) { int num = pow ( 4 , n ) - pow ( 2 , n ) - 1 ; return num ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findSolutions ( N ) { let count = 0 ; for ( let i = 1 ; i <= Math . sqrt ( N ) ; i ++ ) { if ( N % i == 0 ) { if ( ( i + parseInt ( N / i ) ) % 2 == 0 ) { count ++ ; } } } document . write ( 4 * count + " " ) ; }
Ref: 
void findSolutions ( int N ) { int count = 0 ; for ( int i = 1 ; i <= sqrt ( N ) ; i ++ ) { if ( N % i == 0 ) { if ( ( i + N / i ) % 2 == 0 ) { count ++ ; } } } cout << 4 * count << endl ; }
Hyp: 
void findSolutions ( int N ) { int count = 0 ; for ( long long i = 1 ; i <= sqrt ( N ) ; i ++ ) { if ( N % i == 0 ) { if ( ( i + N / i ) % 2 == 0 ) { count ++ ; } } } cout << 4 * count << endl ; }

BLEU: 94.92
Edit Sim: 8


Src: 
function subtract ( A , B , C ) { var i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < N ; j ++ ) C [ i ] [ j ] = A [ i ] [ j ] - B [ i ] [ j ] ; } var A = [ [ 1 , 1 , 1 , 1 ] , [ 2 , 2 , 2 , 2 ] , [ 3 , 3 , 3 , 3 ] , [ 4 , 4 , 4 , 4 ] ] ; var B = [ [ 1 , 1 , 1 , 1 ] , [ 2 , 2 , 2 , 2 ] , [ 3 , 3 , 3 , 3 ] , [ 4 , 4 , 4 , 4 ] ] ; var C = Array . from ( Array ( N ) , ( ) => Array ( N ) ) ; var i , j ; subtract ( A , B , C ) ; document . write ( " " + " " ) ; for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < N ; j ++ ) document . write ( C [ i ] [ j ] + " " ) ; document . write ( " " ) ; }
Ref: 
void subtract ( int A [ ] [ N ] , int B [ ] [ N ] , int C [ ] [ N ] ) { int i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < N ; j ++ ) C [ i ] [ j ] = A [ i ] [ j ] - B [ i ] [ j ] ; }
Hyp: 
void subtract ( int A [ ] [ N ] , int B [ ] [ N ] , int C [ N ] [ N ] ) { int i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < N ; j ++ ) C [ i ] [ j ] = A [ i ] [ j ] - B [ i ] [ j ] ; }

BLEU: 97.01
Edit Sim: 2


Src: 
function maximumSum ( a , count , index , n , dp ) { if ( index == n ) return 0 ; if ( dp [ index ] [ count ] != - 1 ) return dp [ index ] [ count ] ; var take_element = a [ index ] * count + maximumSum ( a , count + 1 , index + 1 , n , dp ) ; var dont_take = maximumSum ( a , count , index + 1 , n , dp ) ; return dp [ index ] [ count ] = Math . max ( take_element , dont_take ) ; }
Ref: 
int maximumSum ( int a [ ] , int count , int index , int n , int dp [ N ] [ N ] ) { if ( index == n ) return 0 ; if ( dp [ index ] [ count ] != -1 ) return dp [ index ] [ count ] ; int take_element = a [ index ] * count + maximumSum ( a , count + 1 , index + 1 , n , dp ) ; int dont_take = maximumSum ( a , count , index + 1 , n , dp ) ; return dp [ index ] [ count ] = max ( take_element , dont_take ) ; }
Hyp: 
int maximumSum ( int a [ ] , int count , int index , int n , int dp [ ] [ MAX ] ) { if ( index == n ) return 0 ; if ( dp [ index ] [ count ] != -1 ) return dp [ index ] [ count ] ; int take_element = a [ index ] * count + maximumSum ( a , count + 1 , index + 1 , n , dp ) ; int dont_take = maximumSum ( a , count , index + 1 , n , dp ) ; return dp [ index ] [ count ] = max ( take_element , dont_take ) ; }

BLEU: 95.96
Edit Sim: 5


Src: 
function calculateEvenSum ( n ) { if ( n <= 0 ) return 0 ; let fibo = Array ( 2 * n + 1 ) ; fibo [ 0 ] = 0 ; fibo [ 1 ] = 1 ; let sum = 0 ; for ( i = 2 ; i <= 2 * n ; i ++ ) { fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ; if ( i % 2 == 0 ) sum += fibo [ i ] ; } return sum ; }
Ref: 
int calculateEvenSum ( int n ) { if ( n <= 0 ) return 0 ; int fibo [ 2 * n + 1 ] ; fibo [ 0 ] = 0 , fibo [ 1 ] = 1 ; int sum = 0 ; for ( int i = 2 ; i <= 2 * n ; i ++ ) { fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ; if ( i % 2 == 0 ) sum += fibo [ i ] ; } return sum ; }
Hyp: 
int calculateEvenSum ( int n ) { if ( n <= 0 ) return 0 ; int fibo [ 2 * n + 1 ] ; fibo [ 0 ] = 0 , fibo [ 1 ] = 1 ; int sum = 0 ; for ( int i = 2 ; i <= 2 * n ; i ++ ) { fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ; if ( i % 2 == 0 ) sum += fibo [ i ] ; } return sum ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countSubString ( S , C ) { var count = 0 ; var conCount = 0 ; for ( var i = 0 ; i < S . length ; i ++ ) { var ch = S [ i ] ; if ( ch === C ) conCount ++ ; else { count += ( conCount * ( conCount + 1 ) ) / 2 ; conCount = 0 ; } } count += ( conCount * ( conCount + 1 ) ) / 2 ; document . write ( count ) ; }
Ref: 
void countSubString ( string S , char C ) { int count = 0 ; int conCount = 0 ; for ( char ch : S ) { if ( ch == C ) conCount ++ ; else { count += ( conCount * ( conCount + 1 ) ) / 2 ; conCount = 0 ; } } count += ( conCount * ( conCount + 1 ) ) / 2 ; cout << count ; }
Hyp: 
void countSubstring ( string S , char C ) { int count = 0 ; int conCount = 0 ; for ( int i = 0 ; i < S . size ( ) ; i ++ ) { char ch = S [ i ] ; if ( ch == C ) conCount ++ ; else { count += ( conCount * ( conCount + 1 ) ) / 2 ; conCount = 0 ; } } count += ( conCount * ( conCount + 1 ) ) / 2 ; cout << count ; }

BLEU: 72.39
Edit Sim: 48


Src: 
function sortDiff ( arr , n ) { arr . sort ( function ( a , b ) { return a - b ; } ) ; let out = [ ] ; while ( n > 0 ) { out . push ( arr [ Math . floor ( n / 2 ) ] ) ; arr . splice ( Math . floor ( n / 2 ) , 1 ) ; n = n - 1 ; } for ( let i = 0 ; i < out . length ; i ++ ) document . write ( out [ i ] + " " ) ; }
Ref: 
void sortDiff ( vector < int > arr , int n ) { sort ( arr . begin ( ) , arr . end ( ) ) ; vector < int > out ; while ( n > 0 ) { out . push_back ( arr [ n / 2 ] ) ; arr . erase ( arr . begin ( ) + n / 2 ) ; n = n - 1 ; } for ( auto i : out ) cout << i << " ▁ " ; }
Hyp: 
void sortDiff ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; vector < int > out ; while ( n > 0 ) { out . push_back ( arr [ n / 2 ] ) ; arr . erase ( n / 2 , 1 ) ; n = n - 1 ; } for ( int i = 0 ; i < out . size ( ) ; i ++ ) cout << out [ i ] << " ▁ " ; }

BLEU: 62.28
Edit Sim: 85


Src: 
function alternateFib ( n ) { if ( n < 0 ) return ; var f1 = 0 ; var f2 = 1 ; document . write ( f1 + " " ) ; for ( i = 2 ; i <= n ; i ++ ) { var f3 = f2 + f1 ; if ( i % 2 == 0 ) document . write ( f3 + " " ) ; f1 = f2 ; f2 = f3 ; } }
Ref: 
void alternateFib ( int n ) { if ( n < 0 ) return ; int f1 = 0 ; int f2 = 1 ; cout << f1 << " ▁ " ; for ( int i = 2 ; i <= n ; i ++ ) { int f3 = f2 + f1 ; if ( i % 2 == 0 ) cout << f3 << " ▁ " ; f1 = f2 ; f2 = f3 ; } }
Hyp: 
void alternateFib ( int n ) { if ( n < 0 ) return ; int f1 = 0 ; int f2 = 1 ; cout << f1 << " ▁ " ; for ( int i = 2 ; i <= n ; i ++ ) { int f3 = f2 + f1 ; if ( i % 2 == 0 ) cout << f3 << " ▁ " ; f1 = f2 ; f2 = f3 ; } }

BLEU: 100.0
Edit Sim: 0


Src: 
function sumOfProductOfDigits ( n1 , n2 ) { let sum = 0 ; while ( n1 > 0 && n2 > 0 ) { sum += ( ( n1 % 10 ) * ( n2 % 10 ) ) ; n1 = Math . floor ( n1 / 10 ) ; n2 = Math . floor ( n2 / 10 ) ; } return sum ; }
Ref: 
int sumOfProductOfDigits ( int n1 , int n2 ) { int sum = 0 ; while ( n1 > 0 && n2 > 0 ) { sum += ( ( n1 % 10 ) * ( n2 % 10 ) ) ; n1 /= 10 ; n2 /= 10 ; } return sum ; }
Hyp: 
int sumOfProductOfDigits ( int n1 , int n2 ) { int sum = 0 ; while ( n1 > 0 && n2 > 0 ) { sum += ( ( n1 % 10 ) * ( n2 % 10 ) ) ; n1 = n1 / 10 ; n2 = n2 / 10 ; } return sum ; }

BLEU: 84.44
Edit Sim: 12


Src: 
function countValues ( n ) { let unset_bits = 0 ; while ( n > 0 ) { if ( ( n & 1 ) == 0 ) unset_bits ++ ; n = n >> 1 ; } return 1 << unset_bits ; }
Ref: 
int countValues ( int n ) { int unset_bits = 0 ; while ( n ) { if ( ( n & 1 ) == 0 ) unset_bits ++ ; n = n >> 1 ; } return 1 << unset_bits ; }
Hyp: 
int countValues ( unsigned int n ) { unsigned int unset_bits = 0 ; while ( n > 0 ) { if ( ( n & 1 ) == 0 ) unset_bits ++ ; n = n >> 1 ; } return 1 << unset_bits ; }

BLEU: 81.17
Edit Sim: 22


Src: 
function getOccurence ( n , d ) { let result = 0 ; let itr = d ; while ( itr <= n ) { if ( itr % 10 == d ) result ++ ; if ( itr != 0 && Math . floor ( itr / 10 ) == d ) { result ++ ; itr ++ ; } else if ( Math . floor ( itr / 10 ) == d - 1 ) itr = itr + ( 10 - d ) ; else itr = itr + 10 ; } return result ; }
Ref: 
int getOccurence ( int n , int d ) { int itr = d ; while ( itr <= n ) { if ( itr % 10 == d ) result ++ ; if ( itr != 0 && itr / 10 == d ) { result ++ ; itr ++ ; } else if ( itr / 10 == d - 1 ) itr = itr + ( 10 - d ) ; else itr = itr + 10 ; } return result ; }
Hyp: 
int getOccurence ( int n , int d ) { int result = 0 ; int itr = d ; while ( itr <= n ) { if ( itr % 10 == d ) result ++ ; if ( itr != 0 && itr / 10 == d ) { result ++ ; itr ++ ; } else if ( itr / 10 == d - 1 ) itr = itr + ( 10 - d ) ; else itr = itr + 10 ; } return result ; }

BLEU: 93.63
Edit Sim: 17


Src: 
function isPalindrome ( num ) { var s = num . toString ( ) ; var low = 0 ; var high = s . length - 1 ; while ( low < high ) { if ( s [ low ] != s [ high ] ) return false ; low ++ ; high -- ; } return true ; }
Ref: 
bool isPalindrome ( float num ) { stringstream ss ; ss << num ; string s ; ss >> s ; int low = 0 ; int high = s . size ( ) - 1 ; while ( low < high ) { if ( s [ low ] != s [ high ] ) return false ; low ++ ; high -- ; } return true ; }
Hyp: 
bool isPalindrome ( int num ) { string s = to_string ( num ) ; int low = 0 ; int high = s . length ( ) - 1 ; while ( low < high ) { if ( s [ low ] != s [ high ] ) return false ; low ++ ; high -- ; } return true ; }

BLEU: 72.7
Edit Sim: 39


Src: 
function countSolutions ( n ) { let res = 0 ; for ( let x = 0 ; x * x < n ; x ++ ) { for ( let y = 0 ; x * x + y * y < n ; y ++ ) { res ++ ; } } return res ; }
Ref: 
int countSolutions ( int n ) { int res = 0 ; for ( int x = 0 ; x * x < n ; x ++ ) for ( int y = 0 ; x * x + y * y < n ; y ++ ) res ++ ; return res ; }
Hyp: 
int countSolutions ( int n ) { int res = 0 ; for ( int x = 0 ; x * x < n ; x ++ ) { for ( int y = 0 ; x * x + y * y < n ; y ++ ) { res ++ ; } } return res ; }

BLEU: 85.14
Edit Sim: 8


Src: 
function XorSum ( A , B , N , M ) { let ans1 = 0 , ans2 = 0 ; for ( let i = 0 ; i < N ; i ++ ) ans1 = ans1 ^ A [ i ] ; for ( let i = 0 ; i < M ; i ++ ) ans2 = ans2 ^ B [ i ] ; return ( ans1 & ans2 ) ; }
Ref: 
int XorSum ( int A [ ] , int B [ ] , int N , int M ) { int ans1 = 0 , ans2 = 0 ; for ( int i = 0 ; i < N ; i ++ ) ans1 = ans1 ^ A [ i ] ; for ( int i = 0 ; i < M ; i ++ ) ans2 = ans2 ^ B [ i ] ; return ( ans1 & ans2 ) ; }
Hyp: 
int XorSum ( int A [ ] , int B [ ] , int N , int M ) { int ans1 = 0 , ans2 = 0 ; for ( int i = 0 ; i < N ; i ++ ) ans1 = ans1 ^ A [ i ] ; for ( int i = 0 ; i < M ; i ++ ) ans2 = ans2 ^ B [ i ] ; return ( ans1 & ans2 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function minNum ( n , k ) { var x = parseInt ( Math . log ( n ) / Math . log ( k ) ) + 1 ; var mn = Math . pow ( k , x ) - n ; return mn ; }
Ref: 
int minNum ( int n , int k ) { int x = ( int ) ( log ( n ) / log ( k ) ) + 1 ; int mn = pow ( k , x ) - n ; return mn ; }
Hyp: 
int minNum ( int n , int k ) { int x = log2 ( n ) + log2 ( k ) ; int mn = pow ( k , x ) - n ; return mn ; }

BLEU: 67.56
Edit Sim: 19


Src: 
function uncrossedLines ( a , b , n , m ) { let dp = new Array ( n + 1 ) ; for ( let i = 0 ; i < ( n + 1 ) ; i ++ ) { dp [ i ] = new Array ( m + 1 ) ; for ( let j = 0 ; j < ( m + 1 ) ; j ++ ) { dp [ i ] [ j ] = 0 ; } } for ( let i = 0 ; i <= n ; i ++ ) { for ( let j = 0 ; j <= m ; j ++ ) { if ( i == 0 j == 0 ) dp [ i ] [ j ] = 0 ; else if ( a [ i - 1 ] == b [ j - 1 ] ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = Math . max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) ; } } return dp [ n ] [ m ] ; }
Ref: 
int uncrossedLines ( int * a , int * b , int n , int m ) { int dp [ n + 1 ] [ m + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= m ; j ++ ) { if ( i == 0 j == 0 ) dp [ i ] [ j ] = 0 ; else if ( a [ i - 1 ] == b [ j - 1 ] ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) ; } } return dp [ n ] [ m ] ; }
Hyp: 
int uncrossedLines ( int a [ ] , int b [ ] , int n , int m ) { int dp [ n + 1 ] [ m + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= m ; j ++ ) { if ( i == 0 j == 0 ) dp [ i ] [ j ] = 0 ; else if ( a [ i - 1 ] == b [ j - 1 ] ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) ; } } return dp [ n ] [ m ] ; }

BLEU: 94.96
Edit Sim: 8


Src: 
function largestKSubmatrix ( a ) { let dp = new Array ( Row ) ; for ( let i = 0 ; i < Row ; i ++ ) { dp [ i ] = new Array ( Col ) ; for ( let j = 0 ; j < Col ; j ++ ) { dp [ i ] [ j ] = 0 ; } } let result = 0 ; for ( let i = 0 ; i < Row ; i ++ ) { for ( let j = 0 ; j < Col ; j ++ ) { if ( i == 0 j == 0 ) dp [ i ] [ j ] = 1 ; else { if ( a [ i ] [ j ] == a [ i - 1 ] [ j ] && a [ i ] [ j ] == a [ i ] [ j - 1 ] && a [ i ] [ j ] == a [ i - 1 ] [ j - 1 ] ) { dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] > dp [ i ] [ j - 1 ] && dp [ i - 1 ] [ j ] > dp [ i - 1 ] [ j - 1 ] + 1 ) ? dp [ i - 1 ] [ j ] : ( dp [ i ] [ j - 1 ] > dp [ i - 1 ] [ j ] && dp [ i ] [ j - 1 ] > dp [ i - 1 ] [ j - 1 ] + 1 ) ? dp [ i ] [ j - 1 ] : dp [ i - 1 ] [ j - 1 ] + 1 ; } else dp [ i ] [ j ] = 1 ; } result = result > dp [ i ] [ j ] ? result : dp [ i ] [ j ] ; } } return result ; }
Ref: 
int largestKSubmatrix ( int a [ ] [ Col ] ) { int dp [ Row ] [ Col ] ; memset ( dp , sizeof ( dp ) , 0 ) ; int result = 0 ; for ( int i = 0 ; i < Row ; i ++ ) { for ( int j = 0 ; j < Col ; j ++ ) { if ( i == 0 j == 0 ) dp [ i ] [ j ] = 1 ; else { if ( a [ i ] [ j ] == a [ i - 1 ] [ j ] && a [ i ] [ j ] == a [ i ] [ j - 1 ] && a [ i ] [ j ] == a [ i - 1 ] [ j - 1 ] ) dp [ i ] [ j ] = min ( min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) , dp [ i - 1 ] [ j - 1 ] ) + 1 ; else dp [ i ] [ j ] = 1 ; } result = max ( result , dp [ i ] [ j ] ) ; } } return result ; }
Hyp: 
int largestKSubmatrix ( int a [ ] [ Row ] , int n ) { int dp [ Row ] [ Col ] ; memset ( dp , 0 , sizeof ( dp ) ) ; int result = 0 ; for ( int i = 0 ; i < Row ; i ++ ) { for ( int j = 0 ; j < Col ; j ++ ) { if ( i == 0 j == 0 ) dp [ i ] [ j ] = 1 ; else { if ( a [ i ] [ j ] == a [ i - 1 ] [ j ] && a [ i ] [ j ] == a [ i ] [ j - 1 ] && a [ i ] [ j ] == a [ i - 1 ] [ j - 1 ] ) { dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] > dp [ i ] [ j - 1 ] && dp [ i ] [ j - 1 ] > dp [ i - 1 ] [ j ] + 1 ) ? dp [ i ] [ j - 1 ] : dp [ i - 1 ] [ j - 1 ] + 1 ; } else dp [ i ] [ j ] = 1 ; } result = result > dp [ i ] [ j ] ? result : dp [ i ] [ j ] ; } return result ; }

BLEU: 73.58
Edit Sim: 121


Src: 
function CountSetBits ( n ) { if ( n == 0 ) return 0 ; if ( ( n & 1 ) == 1 ) return 1 + CountSetBits ( n >> 1 ) ; else return CountSetBits ( n >> 1 ) ; }
Ref: 
int CountSetBits ( int n ) { if ( n == 0 ) return 0 ; if ( ( n & 1 ) == 1 ) return 1 + CountSetBits ( n >> 1 ) ; else return CountSetBits ( n >> 1 ) ; }
Hyp: 
int CountSetBits ( int n ) { if ( n == 0 ) return 0 ; if ( ( n & 1 ) == 1 ) return 1 + CountSetBits ( n >> 1 ) ; else return CountSetBits ( n >> 1 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function maxValue ( n ) { if ( n == 1 ) return 0 ; return ( parseInt ( n * n / 2 ) - 1 ) ; }
Ref: 
int maxValue ( int n ) { if ( n == 1 ) return 0 ; return ( ( n * n / 2 ) - 1 ) ; }
Hyp: 
int maxValue ( int n ) { if ( n == 1 ) return 0 ; return ( ( n * n / 2 ) - 1 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function sumOfMinAbsDifferences ( arr , n ) { arr . sort ( function ( a , b ) { return a - b } ) ; let sum = 0 ; sum += Math . abs ( arr [ 0 ] - arr [ 1 ] ) ; sum += Math . abs ( arr [ n - 1 ] - arr [ n - 2 ] ) ; for ( let i = 1 ; i < n - 1 ; i ++ ) sum += Math . min ( Math . abs ( arr [ i ] - arr [ i - 1 ] ) , Math . abs ( arr [ i ] - arr [ i + 1 ] ) ) ; return sum ; }
Ref: 
int sumOfMinAbsDifferences ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int sum = 0 ; sum += abs ( arr [ 0 ] - arr [ 1 ] ) ; sum += abs ( arr [ n - 1 ] - arr [ n - 2 ] ) ; for ( int i = 1 ; i < n - 1 ; i ++ ) sum += min ( abs ( arr [ i ] - arr [ i - 1 ] ) , abs ( arr [ i ] - arr [ i + 1 ] ) ) ; return sum ; }
Hyp: 
int sumOfMinAbsDifferences ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int sum = 0 ; sum += abs ( arr [ 0 ] - arr [ 1 ] ) ; sum += abs ( arr [ n - 1 ] - arr [ n - 2 ] ) ; for ( int i = 1 ; i < n - 1 ; i ++ ) sum += min ( abs ( arr [ i ] - arr [ i - 1 ] ) , abs ( arr [ i ] - arr [ i + 1 ] ) ) ; return sum ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function nCr ( n , r ) { let res = 1 ; if ( r > n - r ) r = n - r ; for ( let i = 0 ; i < r ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; }
Ref: 
int nCr ( int n , int r ) { int res = 1 ; if ( r > n - r ) r = n - r ; for ( int i = 0 ; i < r ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; }
Hyp: 
int nCr ( int n , int r ) { int res = 1 ; if ( r > n - r ) r = n - r ; for ( int i = 0 ; i < r ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function is_possible ( x , y ) { if ( x < 2 && y != 0 ) return false ; y = y - x + 1 ; if ( y % 2 == 0 && y >= 0 ) return true ; else return false ; }
Ref: 
bool is_possible ( int x , int y ) { if ( x < 2 && y != 0 ) return false ; y = y - x + 1 ; if ( y % 2 == 0 && y >= 0 ) return true ; else return false ; }
Hyp: 
bool is_possible ( int x , int y ) { if ( x < 2 && y != 0 ) return false ; y = y - x + 1 ; if ( y % 2 == 0 && y >= 0 ) return true ; else return false ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function changeTheArray ( arr , n ) { let minEle = Math . min ( ... arr ) ; let maxEle = Math . max ( ... arr ) ; let minOperations = Number . MAX_VALUE ; for ( let num = minEle ; num <= maxEle ; num ++ ) { let operations = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != num ) { operations += ( Math . abs ( num - arr [ i ] ) - 1 ) ; } } minOperations = Math . min ( minOperations , operations ) ; } return minOperations ; }
Ref: 
int changeTheArray ( int arr [ ] , int n ) { int minEle = * ( std :: min_element ( arr , arr + n ) ) ; int maxEle = * ( std :: max_element ( arr , arr + n ) ) ; int minOperations = INT_MAX ; for ( int num = minEle ; num <= maxEle ; num ++ ) { int operations = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != num ) { operations += ( abs ( num - arr [ i ] ) - 1 ) ; } } minOperations = min ( minOperations , operations ) ; } return minOperations ; }
Hyp: 
int changeTheArray ( int arr [ ] , int n ) { int minEle = * min_element ( arr , arr + n ) ; int maxEle = * max_element ( arr , arr + n ) ; int minOperations = INT_MAX ; for ( int num = minEle ; num <= maxEle ; num ++ ) { int operations = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != num ) { operations += ( abs ( num - arr [ i ] ) - 1 ) ; } } minOperations = min ( minOperations , operations ) ; } return minOperations ; }

BLEU: 89.95
Edit Sim: 22


Src: 
function printAlter ( arr , N ) { for ( var currIndex = 0 ; currIndex < N ; currIndex ++ ) { if ( currIndex % 2 == 0 ) { document . write ( arr [ currIndex ] + " " ) ; } } }
Ref: 
void printAlter ( int arr [ ] , int N ) { for ( int currIndex = 0 ; currIndex < N ; currIndex ++ ) { if ( currIndex % 2 == 0 ) { cout << arr [ currIndex ] << " ▁ " ; } } }
Hyp: 
void printAlter ( int arr [ ] , int N ) { for ( int currIndex = 0 ; currIndex < N ; currIndex ++ ) { if ( currIndex % 2 == 0 ) { cout << arr [ currIndex ] << " ▁ " ; } } }

BLEU: 100.0
Edit Sim: 0


Src: 
function xor_operations ( N , arr , M , K ) { if ( M < 0 M >= N ) return - 1 ; if ( K < 0 K >= N - M ) return - 1 ; for ( let p = 0 ; p < M ; p ++ ) { let temp = [ ] ; for ( let i = 0 ; i < N ; i ++ ) { let value = arr [ i ] ^ arr [ i + 1 ] ; temp . push ( value ) ; arr [ i ] = temp [ i ] ; } } let ans = arr [ K ] ; return ans ; }
Ref: 
int xor_operations ( int N , int arr [ ] , int M , int K ) { if ( M < 0 or M > = N ) return -1 ; if ( K < 0 or K > = N - M ) return -1 ; for ( int p = 0 ; p < M ; p ++ ) { vector < int > temp ; for ( int i = 0 ; i < N ; i ++ ) { int value = arr [ i ] ^ arr [ i + 1 ] ; temp . push_back ( value ) ; arr [ i ] = temp [ i ] ; } } int ans = arr [ K ] ; return ans ; }
Hyp: 
int xor_operations ( int N , int arr [ ] , int M , int K ) { if ( M < 0 M >= N ) return -1 ; if ( K < 0 K >= N - M ) return -1 ; for ( int p = 0 ; p < M ; p ++ ) { vector < int > temp ; for ( int i = 0 ; i < N ; i ++ ) { int value = arr [ i ] ^ arr [ i + 1 ] ; temp . push ( value ) ; arr [ i ] = temp [ i ] ; } } int ans = arr [ K ] ; return ans ; }

BLEU: 89.84
Edit Sim: 13


Src: 
function steps ( N , M ) { if ( N == 1 ) return 0 ; return M ; return 2 * M + ( N - 3 ) ; }
Ref: 
int steps ( int N , int M ) { if ( N == 1 ) return 0 ; return M ; return 2 * M + ( N - 3 ) ; }
Hyp: 
int steps ( int N , int M ) { if ( N == 1 ) return 0 ; return M ; return 2 * M + ( N - 3 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function encrypt ( input ) { let evenPos = ' ' , oddPos = ' ' ; let repeat , ascii ; for ( let i = 0 ; i < input . length ; i ++ ) { ascii = input [ i ] . charCodeAt ( ) ; repeat = ascii >= 97 ? ascii - 96 : ascii - 64 ; for ( let j = 0 ; j < repeat ; j ++ ) { if ( i % 2 == 0 ) document . write ( oddPos ) ; else document . write ( evenPos ) ; } } }
Ref: 
void encrypt ( char input [ 100 ] ) { char evenPos = ' @ ' , oddPos = ' ! ' ; int repeat , ascii ; for ( int i = 0 ; i <= strlen ( input ) ; i ++ ) { ascii = input [ i ] ; repeat = ascii >= 97 ? ascii - 96 : ascii - 64 ; for ( int j = 0 ; j < repeat ; j ++ ) { if ( i % 2 == 0 ) cout << oddPos ; else cout << evenPos ; } } }
Hyp: 
void encrypt ( string input ) { char evenPos = '0' , oddPos = '0' ; int repeat , ascii ; for ( int i = 0 ; i < input . length ( ) ; i ++ ) { ascii = input [ i ] ; repeat = ascii >= 97 ? ascii - 96 : ascii - 64 ; for ( int j = 0 ; j < repeat ; j ++ ) { if ( i % 2 == 0 ) cout << oddPos ; else cout << evenPos ; } } }

BLEU: 79.9
Edit Sim: 35


Src: 
function search ( arr , n , x ) { let front = 0 , back = n - 1 ; while ( front <= back ) { if ( arr [ front ] == x arr [ back ] == x ) return true ; front ++ ; back -- ; } return false ; }
Ref: 
bool search ( int arr [ ] , int n , int x ) { int front = 0 , back = n - 1 ; while ( front <= back ) { if ( arr [ front ] == x arr [ back ] == x ) return true ; front ++ ; back -- ; } return false ; }
Hyp: 
bool search ( int arr [ ] , int n , int x ) { int front = 0 , back = n - 1 ; while ( front <= back ) { if ( arr [ front ] == x arr [ back ] == x ) return 1 ; front ++ ; back -- ; } return 0 ; }

BLEU: 92.16
Edit Sim: 9


Src: 
function isEvenOrOdd ( L , R ) { let oddCount = Math . floor ( ( R - L ) / 2 ) ; if ( R % 2 == 1 L % 2 == 1 ) oddCount ++ ; if ( oddCount % 2 == 0 ) return " " ; else return " " ; }
Ref: 
string isEvenOrOdd ( int L , int R ) { int oddCount = ( R - L ) / 2 ; if ( R % 2 == 1 L % 2 == 1 ) oddCount ++ ; if ( oddCount % 2 == 0 ) return " Even " ; else return " Odd " ; }
Hyp: 
string isEvenOrOdd ( int L , int R ) { int oddCount = ( R - L ) / 2 ; if ( R % 2 == 1 L % 2 == 1 ) oddCount ++ ; if ( oddCount % 2 == 0 ) return " Even " ; else return " Odd " ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countDigit ( arr ) { for ( let i = 0 ; i < M ; i ++ ) { for ( let j = 0 ; j < N ; j ++ ) { let X = arr [ i ] [ j ] ; let d = ( Math . floor ( Math . log10 ( X ) * 1.0 ) + 1 ) ; document . write ( d + " " ) ; } document . write ( " " ) ; } }
Ref: 
void countDigit ( int arr [ M ] [ N ] ) { for ( int i = 0 ; i < M ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { int X = arr [ i ] [ j ] ; int d = floor ( log10 ( X ) * 1.0 ) + 1 ; cout << d << " ▁ " ; } cout << endl ; } }
Hyp: 
void countDigit ( int arr [ M ] [ N ] ) { for ( int i = 0 ; i < M ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { double X = arr [ i ] [ j ] ; int d = ( floor ( log10 ( X ) * 1.0 ) + 1 ) ; cout << d << " ▁ " ; } cout << endl ; } }

BLEU: 91.09
Edit Sim: 10


Src: 
function canMake ( s ) { var o = 0 , z = 0 ; for ( i = 0 ; i < s . length ; i ++ ) { if ( s . charAt ( i ) . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) == 1 ) o ++ ; else z ++ ; } if ( o % 2 == 1 && z % 2 == 1 ) return " " ; else return " " ; }
Ref: 
string canMake ( string & s ) { int o = 0 , z = 0 ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { if ( s [ i ] - '0' == 1 ) o ++ ; else z ++ ; } if ( o % 2 == 1 && z % 2 == 1 ) return " NO " ; else return " YES " ; }
Hyp: 
string canMake ( string s ) { int o = 0 , z = 0 ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { if ( s [ i ] - ' a ' == 1 ) o ++ ; else z ++ ; } if ( o % 2 && z % 2 ) return " Yes " ; else return " No " ; }

BLEU: 78.25
Edit Sim: 21


Src: 
function xorPairSum ( ar , n ) { var sum = 0 ; for ( i = 0 ; i < n ; i ++ ) sum = sum ^ ar [ i ] ; return 2 * sum ; }
Ref: 
int xorPairSum ( int ar [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum ^ ar [ i ] ; return 2 * sum ; }
Hyp: 
int xorPairSum ( int ar [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum ^ ar [ i ] ; return 2 * sum ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function getQuadrant ( X , Y , R , PX , PY ) { if ( PX == X && PY == Y ) return 0 ; let val = Math . pow ( ( PX - X ) , 2 ) + Math . pow ( ( PY - Y ) , 2 ) ; if ( val > Math . pow ( R , 2 ) ) return - 1 ; if ( PX > X && PY >= Y ) return 1 ; if ( PX <= X && PY > Y ) return 2 ; if ( PX < X && PY <= Y ) return 3 ; if ( PX >= X && PY < Y ) return 4 ; }
Ref: 
int getQuadrant ( int X , int Y , int R , int PX , int PY ) { if ( PX == X && PY == Y ) return 0 ; int val = pow ( ( PX - X ) , 2 ) + pow ( ( PY - Y ) , 2 ) ; if ( val > pow ( R , 2 ) ) return -1 ; if ( PX > X && PY >= Y ) return 1 ; if ( PX <= X && PY > Y ) return 2 ; if ( PX < X && PY <= Y ) return 3 ; if ( PX >= X && PY < Y ) return 4 ; }
Hyp: 
int getQuadrant ( int X , int Y , int R , int PX , int PY ) { if ( PX == X && PY == Y ) return 0 ; int val = pow ( ( PX - X ) , 2 ) + pow ( ( PY - Y ) , 2 ) ; if ( val > pow ( R , 2 ) ) return -1 ; if ( PX > X && PY >= Y ) return 1 ; if ( PX <= X && PY > Y ) return 2 ; if ( PX < X && PY <= Y ) return 3 ; if ( PX >= X && PY < Y ) return 4 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countSubStr ( str , n ) { for ( let i = 0 ; i < n ; i ++ ) { if ( str [ i ] == ' ' ) m ++ ; } return m * Math . floor ( ( m - 1 ) / 2 ) ; }
Ref: 
int countSubStr ( char str [ ] ) { for ( int i = 0 ; str [ i ] != ' \0' ; i ++ ) { if ( str [ i ] == '1' ) m ++ ; } return m * ( m - 1 ) / 2 ; }
Hyp: 
int countSubStr ( string str , int n ) { int m = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == '1' ) m ++ ; } return m * floor ( ( m - 1 ) / 2 ) ; }

BLEU: 59.77
Edit Sim: 41


Src: 
function getMinSquares ( n ) { if ( n <= 3 ) return n ; let res = n ; for ( let x = 1 ; x <= n ; x ++ ) { let temp = x * x ; if ( temp > n ) break ; else res = Math . min ( res , 1 + getMinSquares ( n - temp ) ) ; } return res ; }
Ref: 
int getMinSquares ( unsigned int n ) { if ( sqrt ( n ) - floor ( sqrt ( n ) ) == 0 ) return 1 ; if ( n <= 3 ) return n ; int res = n ; for ( int x = 1 ; x <= n ; x ++ ) { int temp = x * x ; if ( temp > n ) break ; else res = min ( res , 1 + getMinSquares ( n - temp ) ) ; } return res ; }
Hyp: 
int getMinSquares ( int n ) { if ( n <= 3 ) return n ; int res = n ; for ( int x = 1 ; x <= n ; x ++ ) { int temp = x * x ; if ( temp > n ) break ; else res = min ( res , 1 + getMinSquares ( n - temp ) ) ; } return res ; }

BLEU: 73.15
Edit Sim: 66


Src: 
function sumofseries ( n ) { let res = 0 ; for ( let i = 1 ; i <= n ; i ++ ) res += ( i ) * ( i + 1 ) * ( i + 2 ) ; return res ; }
Ref: 
int sumofseries ( int n ) { int res = 0 ; for ( int i = 1 ; i <= n ; i ++ ) res += ( i ) * ( i + 1 ) * ( i + 2 ) ; return res ; }
Hyp: 
int sumofseries ( int n ) { long int res = 0 ; for ( int i = 1 ; i <= n ; i ++ ) res += ( i ) * ( i + 1 ) * ( i + 2 ) ; return res ; }

BLEU: 94.76
Edit Sim: 5


Src: 
function findElements ( arr , n ) { for ( let i = 0 ; i < n ; i ++ ) { let count = 0 ; for ( let j = 0 ; j < n ; j ++ ) if ( arr [ j ] > arr [ i ] ) count ++ ; if ( count >= 2 ) document . write ( arr [ i ] + " " ) ; } }
Ref: 
void findElements ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) if ( arr [ j ] > arr [ i ] ) count ++ ; if ( count >= 2 ) cout << arr [ i ] << " ▁ " ; } }
Hyp: 
void findElements ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) if ( arr [ j ] > arr [ i ] ) count ++ ; if ( count >= 2 ) cout << arr [ i ] << " ▁ " ; } }

BLEU: 100.0
Edit Sim: 0


Src: 
function removals ( arr , n , k ) { arr . sort ( ( a , b ) => a - b ) ; var dp = Array ( n ) ; for ( var i = 0 ; i < n ; i ++ ) dp [ i ] = - 1 ; var ans = n - 1 ; dp [ 0 ] = 0 ; for ( var i = 1 ; i < n ; i ++ ) { dp [ i ] = i ; var j = dp [ i - 1 ] ; while ( j != i && arr [ i ] - arr [ j ] > k ) { j ++ ; } dp [ i ] = Math . min ( dp [ i ] , j ) ; ans = Math . min ( ans , ( n - ( i - j + 1 ) ) ) ; } return ans ; }
Ref: 
int removals ( int arr [ ] , int n , int k ) { sort ( arr , arr + n ) ; int dp [ n ] ; for ( int i = 0 ; i < n ; i ++ ) dp [ i ] = -1 ; int ans = n - 1 ; dp [ 0 ] = 0 ; for ( int i = 1 ; i < n ; i ++ ) { dp [ i ] = i ; int j = dp [ i - 1 ] ; while ( j != i && arr [ i ] - arr [ j ] > k ) { j ++ ; } dp [ i ] = min ( dp [ i ] , j ) ; ans = min ( ans , ( n - ( i - j + 1 ) ) ) ; } return ans ; }
Hyp: 
int removals ( int arr [ ] , int n , int k ) { sort ( arr , arr + n ) ; int dp [ n ] ; dp [ 0 ] = 0 ; for ( int i = 1 ; i < n ; i ++ ) { dp [ i ] = i ; int j = dp [ i - 1 ] ; while ( j != i && arr [ i ] - arr [ j ] > k ) { j ++ ; } dp [ i ] = min ( dp [ i ] , j ) ; ans = min ( ans , ( n - ( i - j + 1 ) ) ) ; } return ans ; }

BLEU: 80.29
Edit Sim: 67


Src: 
function evenSum ( n ) { return ( n * ( n + 1 ) ) ; }
Ref: 
int evenSum ( int n ) { return ( n * ( n + 1 ) ) ; }
Hyp: 
int evenSum ( int n ) { return ( n * ( n + 1 ) ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findAverage ( N ) { let avg = ( ( 6 * N * N * N * N ) + ( 15 * N * N * N ) + ( 10 * N * N ) - 1 ) / 30.0 ; return avg ; }
Ref: 
double findAverage ( int N ) { double avg = ( ( 6 * N * N * N * N ) + ( 15 * N * N * N ) + ( 10 * N * N ) - 1 ) / 30.0 ; return avg ; }
Hyp: 
double findAverage ( int N ) { double avg = ( ( 6 * N * N * N * N ) + ( 15 * N * N * N ) + ( 10 * N * N ) - 1 ) / 30.0 ; return avg ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findMaximum ( arr , low , high ) { if ( low == high ) return arr [ low ] ; if ( ( high == low + 1 ) && arr [ low ] >= arr [ high ] ) return arr [ low ] ; if ( ( high == low + 1 ) && arr [ low ] < arr [ high ] ) return arr [ high ] ; mid = ( low + high ) / 2 ; if ( arr [ mid ] > arr [ mid + 1 ] && arr [ mid ] > arr [ mid - 1 ] ) return arr [ mid ] ; if ( arr [ mid ] > arr [ mid + 1 ] && arr [ mid ] < arr [ mid - 1 ] ) return findMaximum ( arr , low , mid - 1 ) ; return findMaximum ( arr , mid + 1 , high ) ; }
Ref: 
int findMaximum ( int arr [ ] , int low , int high ) { if ( low == high ) return arr [ low ] ; if ( ( high == low + 1 ) && arr [ low ] >= arr [ high ] ) return arr [ low ] ; if ( ( high == low + 1 ) && arr [ low ] < arr [ high ] ) return arr [ high ] ; int mid = ( low + high ) / 2 ; if ( arr [ mid ] > arr [ mid + 1 ] && arr [ mid ] > arr [ mid - 1 ] ) return arr [ mid ] ; if ( arr [ mid ] > arr [ mid + 1 ] && arr [ mid ] < arr [ mid - 1 ] ) return findMaximum ( arr , low , mid - 1 ) ; else return findMaximum ( arr , mid + 1 , high ) ; }
Hyp: 
int findMaximum ( int arr [ ] , int low , int high ) { if ( low == high ) return arr [ low ] ; if ( ( high == low + 1 ) && arr [ low ] >= arr [ high ] ) return arr [ low ] ; if ( ( high == low + 1 ) && arr [ low ] < arr [ high ] ) return arr [ high ] ; int mid = ( low + high ) / 2 ; if ( arr [ mid ] > arr [ mid + 1 ] && arr [ mid ] > arr [ mid - 1 ] ) return arr [ mid ] ; if ( arr [ mid ] > arr [ mid + 1 ] && arr [ mid ] < arr [ mid - 1 ] ) return findMaximum ( arr , low , mid - 1 ) ; return findMaximum ( arr , mid + 1 , high ) ; }

BLEU: 98.55
Edit Sim: 5


Src: 
function maxLevel ( boxes , n ) { boxes . sort ( ) ; let prev_width = boxes [ 0 ] ; let prev_count = 1 ; let curr_count = 0 ; let curr_width = 0 ; for ( let i = 1 ; i < n ; i ++ ) { curr_width += boxes [ i ] ; curr_count += 1 ; if ( curr_width > prev_width && curr_count > prev_count ) { prev_width = curr_width ; prev_count = curr_count ; curr_count = 0 ; curr_width = 0 ; ans ++ ; } } return ans ; }
Ref: 
int maxLevel ( int boxes [ ] , int n ) { sort ( boxes , boxes + n ) ; int prev_width = boxes [ 0 ] ; int prev_count = 1 ; int curr_count = 0 ; int curr_width = 0 ; for ( int i = 1 ; i < n ; i ++ ) { curr_width += boxes [ i ] ; curr_count += 1 ; if ( curr_width > prev_width && curr_count > prev_count ) { prev_width = curr_width ; prev_count = curr_count ; curr_count = 0 ; curr_width = 0 ; ans ++ ; } } return ans ; }
Hyp: 
int maxLevel ( int boxes [ ] , int n ) { sort ( boxes , boxes + n ) ; int prev_width = boxes [ 0 ] ; int prev_count = 1 ; int curr_count = 0 ; int curr_width = 0 ; for ( int i = 1 ; i < n ; i ++ ) { curr_width += boxes [ i ] ; curr_count += 1 ; if ( curr_width > prev_width && curr_count > prev_count ) { prev_width = curr_width ; prev_count = curr_count ; curr_count = 0 ; curr_width = 0 ; ans ++ ; } } return ans ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function Division ( a , n ) { let maxi = Number . MIN_VALUE , mini = Number . MAX_VALUE ; for ( let i = 0 ; i < n ; i ++ ) { maxi = Math . max ( a [ i ] , maxi ) ; mini = Math . min ( a [ i ] , mini ) ; } return parseInt ( maxi / mini ) ; }
Ref: 
int Division ( int a [ ] , int n ) { int maxi = INT_MIN , mini = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { maxi = max ( a [ i ] , maxi ) ; mini = min ( a [ i ] , mini ) ; } return maxi / mini ; }
Hyp: 
int Division ( int a [ ] , int n ) { int maxi = INT_MIN , mini = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { maxi = max ( a [ i ] , maxi ) ; mini = min ( a [ i ] , mini ) ; } return maxi / mini ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findLen ( arr , i , curr , n , m ) { if ( i == n ) { if ( ! curr ) return 0 ; else return - 1 ; } if ( v [ i ] [ curr ] ) return dp [ i ] [ curr ] ; v [ i ] [ curr ] = 1 ; var l = findLen ( arr , i + 1 , curr , n , m ) ; var r = findLen ( arr , i + 1 , ( curr + arr [ i ] ) % m , n , m ) ; dp [ i ] [ curr ] = l ; if ( r != - 1 ) dp [ i ] [ curr ] = Math . max ( dp [ i ] [ curr ] , r + 1 ) ; return dp [ i ] [ curr ] ; }
Ref: 
int findLen ( int * arr , int i , int curr , int n , int m ) { if ( i == n ) { if ( ! curr ) return 0 ; else return -1 ; } if ( v [ i ] [ curr ] ) return dp [ i ] [ curr ] ; v [ i ] [ curr ] = 1 ; int l = findLen ( arr , i + 1 , curr , n , m ) ; int r = findLen ( arr , i + 1 , ( curr + arr [ i ] ) % m , n , m ) ; dp [ i ] [ curr ] = l ; if ( r != -1 ) dp [ i ] [ curr ] = max ( dp [ i ] [ curr ] , r + 1 ) ; return dp [ i ] [ curr ] ; }
Hyp: 
int findLen ( int * arr , int i , int curr , int n , int m ) { if ( i == n ) { if ( ! curr ) return 0 ; else return -1 ; } if ( v [ i ] [ curr ] ) return dp [ i ] [ curr ] ; v [ i ] [ curr ] = 1 ; int l = findLen ( arr , i + 1 , curr , n , m ) ; int r = findLen ( arr , i + 1 , ( curr + arr [ i ] ) % m , n , m ) ; dp [ i ] [ curr ] = l ; if ( r != -1 ) dp [ i ] [ curr ] = max ( dp [ i ] [ curr ] , r + 1 ) ; return dp [ i ] [ curr ] ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function solve ( n ) { var ans = 0 ; for ( y = n + 1 ; y <= n * n + n ; y ++ ) { if ( ( n * n ) % ( y - n ) == 0 ) { ans += 1 ; } } document . write ( ans ) ; }
Ref: 
void solve ( int n ) { int ans = 0 ; for ( int y = n + 1 ; y <= n * n + n ; y ++ ) { if ( ( n * n ) % ( y - n ) == 0 ) { ans += 1 ; } } cout << ans ; }
Hyp: 
int solve ( int n ) { int ans = 0 ; for ( int y = n + 1 ; y <= n * n + n ; y ++ ) { if ( ( n * n ) % ( y - n ) == 0 ) { ans += 1 ; } } cout << ans ; }

BLEU: 98.35
Edit Sim: 4


Src: 
function minAtEachIndex ( n , arr ) { var dp1 = Array ( n ) ; var dp2 = Array ( n ) ; var i ; dp1 [ 0 ] = arr [ 0 ] ; for ( i = 1 ; i < n ; i ++ ) dp1 [ i ] = Math . min ( arr [ i ] , dp1 [ i - 1 ] + 1 ) ; dp2 [ n - 1 ] = arr [ n - 1 ] ; for ( i = n - 2 ; i >= 0 ; i -- ) dp2 [ i ] = Math . min ( arr [ i ] , dp2 [ i + 1 ] + 1 ) ; var v = [ ] ; for ( i = 0 ; i < n ; i ++ ) v . push ( Math . min ( dp1 [ i ] , dp2 [ i ] ) ) ; v . forEach ( x => { document . write ( x + " " ) ; } ) ; }
Ref: 
void minAtEachIndex ( int n , int arr [ ] ) { int dp1 [ n ] ; int dp2 [ n ] ; int i ; dp1 [ 0 ] = arr [ 0 ] ; for ( i = 1 ; i < n ; i ++ ) dp1 [ i ] = min ( arr [ i ] , dp1 [ i - 1 ] + 1 ) ; dp2 [ n - 1 ] = arr [ n - 1 ] ; for ( i = n - 2 ; i >= 0 ; i -- ) dp2 [ i ] = min ( arr [ i ] , dp2 [ i + 1 ] + 1 ) ; vector < int > v ; for ( i = 0 ; i < n ; i ++ ) v . push_back ( min ( dp1 [ i ] , dp2 [ i ] ) ) ; for ( auto x : v ) cout << x << " ▁ " ; }
Hyp: 
void minAtEachIndex ( int n , int arr [ ] ) { int dp1 [ n ] ; int dp2 [ n ] ; int i ; dp1 [ 0 ] = arr [ 0 ] ; for ( i = 1 ; i < n ; i ++ ) dp1 [ i ] = min ( arr [ i ] , dp1 [ i - 1 ] + 1 ) ; dp2 [ n - 1 ] = arr [ n - 1 ] ; for ( i = n - 2 ; i >= 0 ; i -- ) dp2 [ i ] = min ( arr [ i ] , dp2 [ i + 1 ] + 1 ) ; int v [ ] ; for ( int i = 0 ; i < n ; i ++ ) v . push_back ( min ( dp1 [ i ] , dp2 [ i ] ) ) ; v . forEach ( x => cout << x << " ▁ " ; }

BLEU: 91.24
Edit Sim: 31


Src: 
function findPattern ( n ) { let prev = n % 2 ; n = Math . floor ( n / 2 ) ; while ( n > 0 ) { let curr = n % 2 ; if ( curr == prev ) return false ; prev = curr ; n = Math . floor ( n / 2 ) ; } return true ; }
Ref: 
bool findPattern ( int n ) { int prev = n % 2 ; n = n / 2 ; while ( n > 0 ) { int curr = n % 2 ; if ( curr == prev ) return false ; prev = curr ; n = n / 2 ; } return true ; }
Hyp: 
bool findPattern ( int n ) { int prev = n % 2 ; n = n / 2 ; while ( n > 0 ) { int curr = n % 2 ; if ( curr == prev ) return false ; prev = curr ; n = n / 2 ; } return true ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function canBeEqual ( a , b , c , k ) { var arr = Array ( 3 ) ; arr [ 0 ] = a ; arr [ 1 ] = b ; arr [ 2 ] = c ; arr . sort ( ( a , b ) => a - b ) ; var diff = 2 * arr [ 2 ] - arr [ 1 ] - arr [ 0 ] ; k = k - diff ; if ( k < 0 k % 3 != 0 ) return false ; return true ; }
Ref: 
bool canBeEqual ( int a , int b , int c , int k ) { int arr [ 3 ] ; arr [ 0 ] = a ; arr [ 1 ] = b ; arr [ 2 ] = c ; sort ( arr , arr + 3 ) ; int diff = 2 * arr [ 2 ] - arr [ 1 ] - arr [ 0 ] ; k = k - diff ; if ( k < 0 k % 3 != 0 ) return false ; return true ; }
Hyp: 
bool canBeEqual ( int a , int b , int c , int k ) { int arr [ 3 ] ; arr [ 0 ] = a ; arr [ 1 ] = b ; arr [ 2 ] = c ; sort ( arr , arr + 3 ) ; int diff = 2 * arr [ 2 ] - arr [ 1 ] - arr [ 0 ] ; k = k - diff ; if ( k < 0 k % 3 != 0 ) return false ; return true ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countOfBinaryNumberLessThanN ( N ) { var q = [ ] ; q . push ( 1 ) ; var cnt = 0 ; var t ; while ( q . length > 0 ) { t = q . pop ( ) ; if ( t <= N ) { cnt ++ ; q . push ( t * 10 ) ; q . push ( t * 10 + 1 ) ; } } return cnt ; }
Ref: 
int countOfBinaryNumberLessThanN ( int N ) { queue < int > q ; q . push ( 1 ) ; int cnt = 0 ; int t ; while ( ! q . empty ( ) ) { t = q . front ( ) ; q . pop ( ) ; if ( t <= N ) { cnt ++ ; q . push ( t * 10 ) ; q . push ( t * 10 + 1 ) ; } } return cnt ; }
Hyp: 
int countOfBinaryNumberLessThanN ( int N ) { queue < int > q ; q . push_back ( 1 ) ; int cnt = 0 ; int t ; while ( q . size ( ) > 0 ) { t = q . pop ( ) ; if ( t <= N ) { cnt ++ ; q . push_back ( t * 10 ) ; q . push_back ( t * 10 + 1 ) ; } } return cnt ; }

BLEU: 76.85
Edit Sim: 39


Src: 
function secondary_polygon ( Angle ) { var edges_primary = 360 / Angle ; if ( edges_primary >= 6 ) { var edges_max_secondary = edges_primary / 2 ; document . write ( edges_max_secondary + 3 ) ; } else document . write ( " " ) ; }
Ref: 
void secondary_polygon ( int Angle ) { int edges_primary = 360 / Angle ; if ( edges_primary >= 6 ) { int edges_max_secondary = edges_primary / 2 ; cout << edges_max_secondary + 3 ; } else cout << " Not ▁ Possible " ; }
Hyp: 
void secondary_polygon ( double Angle ) { double edges_primary = 360 / Angle ; if ( edges_primary >= 6 ) { int edges_max_secondary = edges_primary / 2 ; cout << edges_max_secondary + 3 ; } else cout << " No " ; }

BLEU: 77.99
Edit Sim: 24


Src: 
function nobleInteger ( arr ) { let size = arr . length ; for ( let i = 0 ; i < size ; i ++ ) { let count = 0 ; for ( let j = 0 ; j < size ; j ++ ) if ( arr [ i ] < arr [ j ] ) count ++ ; if ( count == arr [ i ] ) return arr [ i ] ; } return - 1 ; }
Ref: 
int nobleInteger ( int arr [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < size ; j ++ ) if ( arr [ i ] < arr [ j ] ) count ++ ; if ( count == arr [ i ] ) return arr [ i ] ; } return -1 ; }
Hyp: 
int nobleInteger ( int arr [ ] , int n ) { int size = arr . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) if ( arr [ i ] < arr [ j ] ) count ++ ; if ( count == arr [ i ] ) return arr [ i ] ; } return -1 ; }

BLEU: 80.48
Edit Sim: 36


Src: 
function countPaths ( n , m ) { if ( n == 0 m == 0 ) return 1 ; return ( countPaths ( n - 1 , m ) + countPaths ( n , m - 1 ) ) ; }
Ref: 
int countPaths ( int n , int m ) { if ( n == 0 m == 0 ) return 1 ; return ( countPaths ( n - 1 , m ) + countPaths ( n , m - 1 ) ) ; }
Hyp: 
int countPaths ( int n , int m ) { if ( n == 0 m == 0 ) return 1 ; return ( countPaths ( n - 1 , m ) + countPaths ( n , m - 1 ) ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function areaOctagon ( side ) { return ( 2 * ( 1 + Math . sqrt ( 2 ) ) * side * side ) ; }
Ref: 
double areaOctagon ( double side ) { return ( float ) ( 2 * ( 1 + sqrt ( 2 ) ) * side * side ) ; }
Hyp: 
int areaOctagon ( int side ) { return ( 2 * ( 1 + sqrt ( 2 ) ) * side * side ) ; }

BLEU: 74.6
Edit Sim: 22


Src: 
function pairs ( arr , n , k ) { var smallest = 1000000000 ; var count = 0 ; for ( var i = 0 ; i < n ; i ++ ) for ( var j = i + 1 ; j < n ; j ++ ) { if ( Math . abs ( arr [ i ] + arr [ j ] - k ) < smallest ) { smallest = Math . abs ( arr [ i ] + arr [ j ] - k ) ; count = 1 ; } else if ( Math . abs ( arr [ i ] + arr [ j ] - k ) == smallest ) count ++ ; } document . write ( " " + smallest + " " ) ; document . write ( " " + count + " " ) ; }
Ref: 
void pairs ( int arr [ ] , int n , int k ) { int smallest = INT_MAX ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) { if ( abs ( arr [ i ] + arr [ j ] - k ) < smallest ) { smallest = abs ( arr [ i ] + arr [ j ] - k ) ; count = 1 ; } else if ( abs ( arr [ i ] + arr [ j ] - k ) == smallest ) count ++ ; } cout << " Minimal ▁ Value ▁ = ▁ " << smallest << " STRNEWLINE " ; cout << " Total ▁ Pairs ▁ = ▁ " << count << " STRNEWLINE " ; }
Hyp: 
void pairs ( int arr [ ] , int n , int k ) { int smallest = INT_MAX ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) { if ( abs ( arr [ i ] + arr [ j ] - k ) < smallest ) { smallest = abs ( arr [ i ] + arr [ j ] - k ) ; count = 1 ; } else if ( abs ( arr [ i ] + arr [ j ] - k ) == smallest ) count ++ ; } cout << " Even ▁ = ▁ " << smallest << endl ; cout << " Odd ▁ Count ▁ = ▁ " << count << endl ; }

BLEU: 88.69
Edit Sim: 53


Src: 
function isPossible ( index , sum ) { if ( index == n ) { if ( ( sum % M ) == 0 ) return true ; return false ; } let placeAdd = isPossible ( index + 1 , sum + arr [ index ] ) ; let placeMinus = isPossible ( index + 1 , sum - arr [ index ] ) ; if ( placeAdd placeMinus ) return true ; return false ; }
Ref: 
bool isPossible ( int index , int sum ) { if ( index == n ) { if ( ( sum % M ) == 0 ) return true ; return false ; } bool placeAdd = isPossible ( index + 1 , sum + arr [ index ] ) ; bool placeMinus = isPossible ( index + 1 , sum - arr [ index ] ) ; if ( placeAdd placeMinus ) return true ; return false ; }
Hyp: 
bool isPossible ( int index , int sum ) { if ( index == n ) { if ( ( sum % M ) == 0 ) return true ; return false ; } int placeAdd = isPossible ( index + 1 , sum + arr [ index ] ) ; int placeMinus = isPossible ( index + 1 , sum - arr [ index ] ) ; if ( placeAdd placeMinus ) return true ; return false ; }

BLEU: 93.62
Edit Sim: 8


Src: 
function minOperations ( arr , n ) { var oddcount = 0 , evencount = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 1 ) oddcount ++ ; else evencount ++ ; } return Math . min ( oddcount , evencount ) ; }
Ref: 
int minOperations ( int arr [ ] , int n ) { int oddcount = 0 , evencount = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 1 ) oddcount ++ ; else evencount ++ ; } return min ( oddcount , evencount ) ; }
Hyp: 
int minOperations ( int arr [ ] , int n ) { int oddcount = 0 , evencount = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 1 ) oddcount ++ ; else evencount ++ ; } return min ( oddcount , evencount ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function sumNodes ( l ) { let leafNodeCount = Math . pow ( 2 , l - 1 ) ; let sumLastLevel = 0 ; sumLastLevel = ( leafNodeCount * ( leafNodeCount + 1 ) ) / 2 ; let sum = sumLastLevel * l ; return sum ; }
Ref: 
int sumNodes ( int l ) { int leafNodeCount = pow ( 2 , l - 1 ) ; int sumLastLevel = 0 ; sumLastLevel = ( leafNodeCount * ( leafNodeCount + 1 ) ) / 2 ; int sum = sumLastLevel * l ; return sum ; }
Hyp: 
int sumNodes ( int l ) { int leafNodeCount = pow ( 2 , l - 1 ) ; int sumLastLevel = 0 ; sumLastLevel = ( leafNodeCount * ( leafNodeCount + 1 ) ) / 2 ; int sum = sumLastLevel * l ; return sum ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function leftRotate ( arr , d , n ) { if ( d == 0 d == n ) return ; let i = d ; let j = n - d ; while ( i != j ) { if ( i < j ) { arr = swap ( arr , d - i , d + j - i , i ) ; j -= i ; } else { arr = swap ( arr , d - i , d , j ) ; i -= j ; } } arr = swap ( arr , d - i , d , i ) ; }
Ref: 
void leftRotate ( int arr [ ] , int d , int n ) { int i , j ; if ( d == 0 d == n ) return ; i = d ; j = n - d ; while ( i != j ) { if ( i < j ) { swap ( arr , d - i , d + j - i , i ) ; j -= i ; } else { swap ( arr , d - i , d , j ) ; i -= j ; } } swap ( arr , d - i , d , i ) ; }
Hyp: 
void leftRotate ( int arr [ ] , int d , int n ) { if ( d == 0 d == n ) return ; int i = d ; int j = n - d ; while ( i != j ) { if ( i < j ) { arr [ d - i ] = d + j - i , i ) ; j -= i ; } else { arr [ d - i ] = d , j ; i -= j ; } } arr [ d - i ] = d , i ) ; }

BLEU: 68.05
Edit Sim: 55


Src: 
function maxGCD ( N , K ) { var minSum = ( K * ( K + 1 ) ) / 2 ; if ( N < minSum ) return - 1 ; var i = parseInt ( Math . sqrt ( N ) ) ; var res = 1 ; while ( i >= 1 ) { if ( N % i == 0 ) { if ( i >= minSum ) res = Math . max ( res , N / i ) ; if ( N / i >= minSum ) res = Math . max ( res , i ) ; } i -- ; } return res ; }
Ref: 
int maxGCD ( int N , int K ) { int minSum = ( K * ( K + 1 ) ) / 2 ; if ( N < minSum ) return -1 ; int i = sqrt ( N ) ; int res = 1 ; while ( i >= 1 ) { if ( N % i == 0 ) { if ( i >= minSum ) res = max ( res , N / i ) ; if ( N / i >= minSum ) res = max ( res , i ) ; } i -- ; } return res ; }
Hyp: 
int maxGCD ( int N , int K ) { int minSum = ( K * ( K + 1 ) ) / 2 ; if ( N < minSum ) return -1 ; int i = sqrt ( N ) ; int res = 1 ; while ( i >= 1 ) { if ( N % i == 0 ) { if ( i >= minSum ) res = max ( res , N / i ) ; if ( N / i >= minSum ) res = max ( res , i ) ; } i -- ; } return res ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function maxArea ( polet_x , polet_y , n , length , width ) { polet_x . sort ( ( a , b ) => a - b ) ; ; polet_y . sort ( ( a , b ) => a - b ) ; ; let dx = polet_x [ 0 ] ; let dy = polet_y [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { dx = Math . max ( dx , polet_x [ i ] - polet_x [ i - 1 ] ) ; dy = Math . max ( dy , polet_y [ i ] - polet_y [ i - 1 ] ) ; } dx = Math . max ( dx , ( length + 1 ) - polet_x [ n - 1 ] ) ; dy = Math . max ( dy , ( width + 1 ) - polet_y [ n - 1 ] ) ; document . write ( ( dx - 1 ) * ( dy - 1 ) ) ; }
Ref: 
void maxArea ( int point_x [ ] , int point_y [ ] , int n , int length , int width ) { sort ( point_x , point_x + n ) ; sort ( point_y , point_y + n ) ; int dx = point_x [ 0 ] ; int dy = point_y [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { dx = max ( dx , point_x [ i ] - point_x [ i - 1 ] ) ; dy = max ( dy , point_y [ i ] - point_y [ i - 1 ] ) ; } dx = max ( dx , ( length + 1 ) - point_x [ n - 1 ] ) ; dy = max ( dy , ( width + 1 ) - point_y [ n - 1 ] ) ; cout << ( dx - 1 ) * ( dy - 1 ) ; cout << endl ; }
Hyp: 
void maxArea ( int polet_x [ ] , int polet_y [ ] , int n , int length , int width ) { sort ( polet_x , polet_x + n ) ; sort ( polet_y , polet_y + n ) ; int dx = polet_x [ 0 ] ; int dy = polet_y [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { dx = max ( dx , polet_x [ i ] - polet_x [ i - 1 ] ) ; dy = max ( dy , polet_y [ i ] - polet_y [ i - 1 ] ) ; } dx = max ( dx , ( length + 1 ) - polet_x [ n - 1 ] ) ; dy = max ( dy , ( width + 1 ) - polet_y [ n - 1 ] ) ; cout << ( dx - 1 ) * ( dy - 1 ) ; }

BLEU: 77.02
Edit Sim: 43


Src: 
function ways ( i , arr , n ) { if ( i == n - 1 ) return 1 ; let sum = 0 ; for ( let j = 1 ; j + i < n && j <= arr [ i ] ; j ++ ) { sum += ( ways ( i + j , arr , n ) ) % mod ; sum %= mod ; } return sum % mod ; }
Ref: 
int ways ( int i , int arr [ ] , int n ) { if ( i == n - 1 ) return 1 ; int sum = 0 ; for ( int j = 1 ; j + i < n && j <= arr [ i ] ; j ++ ) { sum += ( ways ( i + j , arr , n ) ) % mod ; sum %= mod ; } return sum % mod ; }
Hyp: 
int ways ( int i , int arr [ ] , int n ) { if ( i == n - 1 ) return 1 ; int sum = 0 ; for ( int j = 1 ; j + i < n && j <= arr [ i ] ; j ++ ) { sum += ( ways ( i + j , arr , n ) ) % mod ; sum %= mod ; } return sum % mod ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countNumberOfStrings ( s ) { let n = s . length - 1 ; let count = ( Math . pow ( 2 , n ) ) ; return count ; }
Ref: 
int countNumberOfStrings ( string s ) { int length = s . length ( ) ; int n = length - 1 ; long long int count = pow ( 2 , n ) ; return count ; }
Hyp: 
int countNumberOfStrings ( string s ) { int n = s . length ( ) - 1 ; int count = ( pow ( 2 , n ) ) ; return count ; }

BLEU: 61.64
Edit Sim: 36


Src: 
function moduloMultiplication ( a , b , mod ) { let res = 0 ; a = ( a % mod ) ; while ( b > 0 ) { if ( ( b & 1 ) > 0 ) { res = ( res + a ) % mod ; } a = ( 2 * a ) % mod ; } return res ; }
Ref: 
long moduloMultiplication ( long long a , long long b , long long mod ) { a %= mod ; while ( b ) { if ( b & 1 ) res = ( res + a ) % mod ; a = ( 2 * a ) % mod ; } return res ; }
Hyp: 
int moduloMultiplication ( int a , int b , int mod ) { int res = 0 ; a = ( a % mod ) ; while ( b > 0 ) { if ( b & 1 ) { res = ( res + a ) % mod ; } a = ( 2 * a ) % mod ; } return res ; }

BLEU: 55.08
Edit Sim: 47


Src: 
function minSum ( n , num , price ) { let dp = Array . from ( { length : n } , ( _ , i ) => Number . MAX_VALUE ) ; let ans = Number . MAX_VALUE ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i + 1 ; j < n ; j ++ ) { if ( num [ j ] > num [ i ] ) { dp [ j ] = Math . min ( dp [ j ] , price [ i ] + price [ j ] ) ; ans = Math . min ( ans , dp [ i ] + price [ j ] ) ; } } } return ans != Number . MAX_VALUE ? ans : - 1 ; }
Ref: 
long minSum ( int n , int num [ ] , int price [ ] ) { long dp [ n ] ; for ( int i = 0 ; i < n ; i ++ ) dp [ i ] = INT_MAX ; long ans = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( num [ j ] > num [ i ] ) { dp [ j ] = ( long ) min ( ( long ) dp [ j ] , ( long ) price [ i ] + ( long ) price [ j ] ) ; ans = min ( ans , ( long ) dp [ i ] + ( long ) price [ j ] ) ; } } } return ans != INT_MAX ? ans : -1 ; }
Hyp: 
int minSum ( int n , int num [ ] , int price [ ] ) { int dp [ n ] ; int ans = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( num [ j ] > num [ i ] ) { dp [ j ] = min ( dp [ j ] , price [ i ] + price [ j ] ) ; ans = min ( ans , dp [ i ] + price [ j ] ) ; } } } return ans != INT_MAX ? ans : -1 ; }

BLEU: 64.64
Edit Sim: 115


Src: 
function lcsOf3 ( X , Y , Z , m , n , o ) { let L = new Array ( m + 1 ) ; for ( let i = 0 ; i < m + 1 ; i ++ ) { L [ i ] = new Array ( n + 1 ) ; for ( let j = 0 ; j < n + 1 ; j ++ ) { L [ i ] [ j ] = new Array ( o + 1 ) ; for ( let k = 0 ; k < o + 1 ; k ++ ) { L [ i ] [ j ] [ k ] = 0 ; } } } for ( let i = 0 ; i <= m ; i ++ ) { for ( let j = 0 ; j <= n ; j ++ ) { for ( let k = 0 ; k <= o ; k ++ ) { if ( i == 0 j == 0 k == 0 ) L [ i ] [ j ] [ k ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] && X [ i - 1 ] == Z [ k - 1 ] ) L [ i ] [ j ] [ k ] = L [ i - 1 ] [ j - 1 ] [ k - 1 ] + 1 ; else L [ i ] [ j ] [ k ] = Math . max ( Math . max ( L [ i - 1 ] [ j ] [ k ] , L [ i ] [ j - 1 ] [ k ] ) , L [ i ] [ j ] [ k - 1 ] ) ; } } } return L [ m ] [ n ] [ o ] ; }
Ref: 
int lcsOf3 ( string X , string Y , string Z , int m , int n , int o ) { int L [ m + 1 ] [ n + 1 ] [ o + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { for ( int k = 0 ; k <= o ; k ++ ) { if ( i == 0 j == 0 k == 0 ) L [ i ] [ j ] [ k ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] && X [ i - 1 ] == Z [ k - 1 ] ) L [ i ] [ j ] [ k ] = L [ i - 1 ] [ j - 1 ] [ k - 1 ] + 1 ; else L [ i ] [ j ] [ k ] = max ( max ( L [ i - 1 ] [ j ] [ k ] , L [ i ] [ j - 1 ] [ k ] ) , L [ i ] [ j ] [ k - 1 ] ) ; } } } return L [ m ] [ n ] [ o ] ; }
Hyp: 
int lcsOf3 ( int X [ ] , int Y [ ] , int Z [ ] , int m , int n , int o ) { int L [ m + 1 ] [ n + 1 ] [ o + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { for ( int k = 0 ; k <= o ; k ++ ) { if ( i == 0 j == 0 k == 0 ) L [ i ] [ j ] [ k ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] && X [ i - 1 ] == Z [ k - 1 ] ) L [ i ] [ j ] [ k ] = L [ i - 1 ] [ j - 1 ] [ k - 1 ] + 1 ; else L [ i ] [ j ] [ k ] = max ( max ( L [ i - 1 ] [ j ] [ k ] , L [ i ] [ j - 1 ] [ k ] ) , L [ i ] [ j ] [ k - 1 ] ) ; } } } return L [ m ] [ n ] [ o ] ; }

BLEU: 94.28
Edit Sim: 20


Src: 
function solve ( s1 , s2 ) { let flag1 = 0 , flag2 = 0 ; if ( s1 . length != s2 . length ) return false ; let l = s1 . length ; for ( let i = 0 ; i < l ; i ++ ) { if ( s1 [ i ] == ' ' ) flag1 = 1 ; if ( s2 [ i ] == ' ' ) flag2 = 1 ; if ( flag1 && flag2 ) return true ; } if ( ! flag1 && ! flag2 ) return true ; return false ; }
Ref: 
bool solve ( string s1 , string s2 ) { bool flag1 = 0 , flag2 = 0 ; if ( s1 . length ( ) != s2 . length ( ) ) return false ; int l = s1 . length ( ) ; for ( int i = 0 ; i < l ; i ++ ) { if ( s1 [ i ] == '1' ) flag1 = 1 ; if ( s2 [ i ] == '1' ) flag2 = 1 ; if ( flag1 && flag2 ) return true ; } if ( ! flag1 && ! flag2 ) return true ; return false ; }
Hyp: 
bool solve ( string s1 , string s2 ) { int flag1 = 0 , flag2 = 0 ; if ( s1 . length ( ) != s2 . length ( ) ) return false ; int l = s1 . length ( ) ; for ( int i = 0 ; i < l ; i ++ ) { if ( s1 [ i ] == '0' ) flag1 = 1 ; if ( s2 [ i ] == '0' ) flag2 = 1 ; if ( flag1 && flag2 ) return true ; } if ( ! flag1 && flag2 ) return true ; return false ; }

BLEU: 90.81
Edit Sim: 8


Src: 
function equilibrium ( arr , n ) { sum = 0 ; leftsum = 0 ; for ( let i = 0 ; i < n ; ++ i ) sum += arr [ i ] ; for ( let i = 0 ; i < n ; ++ i ) { sum -= arr [ i ] ; if ( leftsum == sum ) return i ; leftsum += arr [ i ] ; } return - 1 ; }
Ref: 
int equilibrium ( int arr [ ] , int n ) { int sum = 0 ; int leftsum = 0 ; for ( int i = 0 ; i < n ; ++ i ) sum += arr [ i ] ; for ( int i = 0 ; i < n ; ++ i ) { sum -= arr [ i ] ; if ( leftsum == sum ) return i ; leftsum += arr [ i ] ; } return -1 ; }
Hyp: 
int equilibrium ( int arr [ ] , int n ) { int sum = 0 ; int leftsum = 0 ; for ( int i = 0 ; i < n ; ++ i ) sum += arr [ i ] ; for ( int i = 0 ; i < n ; ++ i ) { sum -= arr [ i ] ; if ( leftsum == sum ) return i ; leftsum += arr [ i ] ; } return -1 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function nextGreatestAlphabet ( alphabets , K ) { var l = 0 , r = alphabets . length - 1 ; var ans = - 1 ; while ( l <= r ) { var mid = ( l + r ) / 2 ; if ( alphabets [ mid ] > K ) { ans = mid ; r = mid - 1 ; } else l = mid + 1 ; } return alphabets [ ans ] ; }
Ref: 
char nextGreatestAlphabet ( vector < char > & alphabets , char K ) { int n = alphabets . size ( ) ; if ( K >= alphabets [ n - 1 ] ) return alphabets [ 0 ] ; int l = 0 , r = alphabets . size ( ) - 1 ; int ans = -1 ; while ( l <= r ) { int mid = ( l + r ) / 2 ; if ( alphabets [ mid ] > K ) { r = mid - 1 ; ans = mid ; } else l = mid + 1 ; } return alphabets [ ans ] ; }
Hyp: 
char nextGreatestAlphabet ( string alphabets [ ] , char K ) { int l = 0 , r = alphabets . length ( ) - 1 ; int ans = -1 ; while ( l <= r ) { int mid = ( l + r ) / 2 ; if ( alphabets [ mid ] > K ) { ans = mid ; r = mid - 1 ; } else l = mid + 1 ; } return alphabets [ ans ] ; }

BLEU: 62.11
Edit Sim: 122


Src: 
function constructArray ( A , N , K ) { let B = new Array ( N ) ; let totalXOR = A [ 0 ] ^ K ; for ( let i = 0 ; i < N ; i ++ ) B [ i ] = totalXOR ^ A [ i ] ; for ( let i = 0 ; i < N ; i ++ ) { document . write ( B [ i ] + " " ) ; } }
Ref: 
void constructArray ( int A [ ] , int N , int K ) { int B [ N ] ; int totalXOR = A [ 0 ] ^ K ; for ( int i = 0 ; i < N ; i ++ ) B [ i ] = totalXOR ^ A [ i ] ; for ( int i = 0 ; i < N ; i ++ ) { cout << B [ i ] << " ▁ " ; } }
Hyp: 
void constructArray ( int A [ ] , int N , int K ) { int B [ N ] ; int totalXOR = A [ 0 ] ^ K ; for ( int i = 0 ; i < N ; i ++ ) B [ i ] = totalXOR ^ A [ i ] ; for ( int i = 0 ; i < N ; i ++ ) cout << B [ i ] << " ▁ " ; }

BLEU: 95.82
Edit Sim: 4


Src: 
function check ( str ) { let n = str . length ; if ( ( str [ n - 1 ] - ' ' ) % 2 != 0 ) return false ; let digitSum = 0 ; for ( let i = 0 ; i < n ; i ++ ) digitSum += ( str [ i ] - ' ' ) ; return ( digitSum % 3 == 0 ) ; }
Ref: 
bool check ( string str ) { int n = str . length ( ) ; if ( ( str [ n - 1 ] - '0' ) % 2 != 0 ) return false ; int digitSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) digitSum += ( str [ i ] - '0' ) ; return ( digitSum % 3 == 0 ) ; }
Hyp: 
bool check ( string str ) { int n = str . length ( ) ; if ( ( str [ n - 1 ] - '0' ) % 2 != 0 ) return false ; int digitSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) digitSum += ( str [ i ] - '0' ) ; return ( digitSum % 3 == 0 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function maxHeight ( h1 , h2 ) { return ( ( h1 * h2 ) - h1 - h2 ) ; }
Ref: 
int maxHeight ( int h1 , int h2 ) { return ( ( h1 * h2 ) - h1 - h2 ) ; }
Hyp: 
int maxHeight ( int h1 , int h2 ) { return ( ( h1 * h2 ) - h1 - h2 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function cal_IST ( h , r ) { let IST = ( h * r * 1.0 ) / 360 ; let int_IST = parseInt ( IST ) ; let float_IST = Math . ceil ( parseInt ( ( IST - int_IST ) * 60 ) ) ; document . write ( int_IST + " " + float_IST ) ; }
Ref: 
void cal_IST ( int h , float r ) { float IST = ( h * r * 1.0 ) / 360 ; int int_IST = ( int ) IST ; int float_IST = ceil ( ( IST - int_IST ) * 60 ) ; cout << int_IST << " : " << float_IST ; }
Hyp: 
void cal_IST ( int h , int r ) { double IST = ( h * r * 1.0 ) / 360 ; int int_IST = ( IST ) ; float float_IST = ceil ( ( IST - int_IST ) * 60 ) ; cout << int_IST << " ▁ " << float_IST ; }

BLEU: 75.93
Edit Sim: 21


Src: 
function getSum ( n ) { var sum = 0 ; if ( n == 1 ) { sum = 45.0 ; } else { sum = ( 99.0 / 2.0 ) * Math . pow ( 10 , n - 1 ) * Math . pow ( 10 , parseInt ( ( n - 1 ) / 2 ) ) ; } return sum ; }
Ref: 
double getSum ( int n ) { long double sum = 0 ; if ( n == 1 ) { sum = 45.0 ; } else { sum = ( 99.0 / 2.0 ) * pow ( 10 , n - 1 ) * pow ( 10 , ( n - 1 ) / 2 ) ; } return sum ; }
Hyp: 
double digSum ( int n ) { double sum = 0 ; if ( n == 1 ) { sum = 45.0 ; } else { sum = ( 99.0 / 2.0 ) * pow ( 10 , n - 1 ) * pow ( 10 , ( n - 1 ) / 2 ) ; } return sum ; }

BLEU: 93.01
Edit Sim: 8


Src: 
function toggleKthBit ( n , k ) { return ( n ^ ( 1 << ( k - 1 ) ) ) ; }
Ref: 
int toggleKthBit ( int n , int k ) { return ( n ^ ( 1 << ( k - 1 ) ) ) ; }
Hyp: 
int toggleKthBit ( int n , int k ) { return ( n ^ ( 1 << ( k - 1 ) ) ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function sumOfTheSeries ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { let k = 1 ; for ( let j = 1 ; j <= i ; j ++ ) { sum += k ; k += 2 ; } } return sum ; }
Ref: 
int sumOfTheSeries ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int k = 1 ; for ( int j = 1 ; j <= i ; j ++ ) { sum += k ; k += 2 ; } } return sum ; }
Hyp: 
int sumOfTheSeries ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int k = 1 ; for ( int j = 1 ; j <= i ; j ++ ) { sum += k ; k += 2 ; } } return sum ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function Conversion ( centi ) { let pixels = ( 96 * centi ) / 2.54 ; document . write ( pixels ) ; return 0 ; }
Ref: 
void Conversion ( double centi ) { double pixels = ( 96 * centi ) / 2.54 ; cout << fixed << setprecision ( 2 ) << pixels ; }
Hyp: 
int Conversion ( int centi ) { float pixels = ( 96 * centi ) / 2.54 ; cout << pixels ; return 0 ; }

BLEU: 50.11
Edit Sim: 44


Src: 
function merge ( m , n ) { for ( let i = n - 1 ; i >= 0 ; i -- ) { let j , last = arr1 [ m - 1 ] ; for ( j = m - 2 ; j >= 0 && arr1 [ j ] > arr2 [ i ] ; j -- ) arr1 [ j + 1 ] = arr1 [ j ] ; if ( j != m - 2 last > arr2 [ i ] ) { arr1 [ j + 1 ] = arr2 [ i ] ; arr2 [ i ] = last ; } } } merge ( arr1 . length , arr2 . length ) ; document . write ( " " ) ; for ( let i = 0 ; i < arr1 . length ; i ++ ) { document . write ( arr1 [ i ] + " " ) ; } document . write ( " " ) ; for ( let i = 0 ; i < arr2 . length ; i ++ ) { document . write ( arr2 [ i ] + " " ) ; }
Ref: 
void merge ( int ar1 [ ] , int ar2 [ ] , int m , int n ) { for ( int i = n - 1 ; i >= 0 ; i -- ) { int j , last = ar1 [ m - 1 ] ; for ( j = m - 2 ; j >= 0 && ar1 [ j ] > ar2 [ i ] ; j -- ) ar1 [ j + 1 ] = ar1 [ j ] ; if ( j != m - 2 last > ar2 [ i ] ) { ar1 [ j + 1 ] = ar2 [ i ] ; ar2 [ i ] = last ; } } }
Hyp: 
void merge ( int m , int n ) { for ( int i = n - 1 ; i >= 0 ; i -- ) { int j , last = arr1 [ m - 1 ] ; for ( j = m - 2 ; j >= 0 && arr1 [ j ] > arr2 [ i ] ; j -- ) arr1 [ j + 1 ] = arr1 [ j ] ; if ( j != m - 2 last > arr2 [ i ] ) { arr1 [ j + 1 ] = arr2 [ i ] ; arr2 [ i ] = last ; } } }

BLEU: 71.96
Edit Sim: 37


Src: 
function smallestNumber ( N ) { let L = Math . pow ( 10 , N ) - 1 ; let S = Math . pow ( 10 , N - 1 ) ; for ( let i = S ; i <= L ; i ++ ) { if ( i % N == 0 ) { document . write ( i ) ; return ; } } }
Ref: 
void smallestNumber ( int N ) { int L = pow ( 10 , N ) - 1 ; int S = pow ( 10 , N - 1 ) ; for ( int i = S ; i <= L ; i ++ ) { if ( i % N == 0 ) { cout << i ; return ; } } }
Hyp: 
void smallestNumber ( int N ) { int L = pow ( 10 , N ) - 1 ; int S = pow ( 10 , N - 1 ) ; for ( int i = S ; i <= L ; i ++ ) { if ( i % N == 0 ) { cout << i ; return ; } } }

BLEU: 100.0
Edit Sim: 0


Src: 
function decode_String ( str , K ) { let ans = " " ; for ( let i = 0 ; i < str . length ; i += K ) ans += str [ i ] ; for ( let i = str . length - ( K - 1 ) ; i < str . length ; i ++ ) ans += str [ i ] ; document . write ( ans ) ; }
Ref: 
void decode_String ( string str , int K ) { string ans = " " ; for ( int i = 0 ; i < str . size ( ) ; i += K ) ans += str [ i ] ; for ( int i = str . size ( ) - ( K - 1 ) ; i < str . size ( ) ; i ++ ) ans += str [ i ] ; cout << ans << endl ; }
Hyp: 
void decode_string ( string str , int K ) { string ans = " " ; for ( int i = 0 ; i < str . length ( ) ; i += K ) ans += str [ i ] ; for ( int i = str . length ( ) - ( K - 1 ) ; i < str . length ( ) ; i ++ ) ans += str [ i ] ; cout << ans ; }

BLEU: 84.76
Edit Sim: 27


Src: 
function isRepunitNum ( n , b ) { let length = 0 ; let countOne = 0 ; while ( n != 0 ) { let r = n % b ; length ++ ; if ( r == 1 ) countOne ++ ; n = parseInt ( n / b ) ; } return countOne >= 3 && countOne == length ; }
Ref: 
bool isRepunitNum ( int n , int b ) { int length = 0 ; int countOne = 0 ; while ( n != 0 ) { int r = n % b ; length ++ ; if ( r == 1 ) countOne ++ ; n = n / b ; } return countOne >= 3 && countOne == length ; }
Hyp: 
bool isRepunitNum ( int n , int b ) { int length = 0 ; int countOne = 0 ; while ( n != 0 ) { int r = n % b ; length ++ ; if ( r == 1 ) countOne ++ ; n = n / b ; } return countOne >= 3 && countOne == length ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findSum ( arr , n , k , l , r ) { if ( ( l ) + ( n - 1 - r ) == k ) return arr [ r ] - arr [ l ] ; if ( vis [ l ] [ r ] ) return dp [ l ] [ r ] ; vis [ l ] [ r ] = 1 ; dp [ l ] [ r ] = Math . min ( findSum ( arr , n , k , l , r - 1 ) , findSum ( arr , n , k , l + 1 , r ) ) ; return dp [ l ] [ r ] ; }
Ref: 
int findSum ( int * arr , int n , int k , int l , int r ) { if ( ( l ) + ( n - 1 - r ) == k ) return arr [ r ] - arr [ l ] ; if ( vis [ l ] [ r ] ) return dp [ l ] [ r ] ; vis [ l ] [ r ] = 1 ; return dp [ l ] [ r ] = min ( findSum ( arr , n , k , l , r - 1 ) , findSum ( arr , n , k , l + 1 , r ) ) ; }
Hyp: 
int findSum ( int * arr , int n , int k , int l , int r ) { if ( ( l ) + ( n - 1 - r ) == k ) return arr [ r ] - arr [ l ] ; if ( vis [ l ] [ r ] ) return dp [ l ] [ r ] ; vis [ l ] [ r ] = 1 ; dp [ l ] [ r ] = min ( findSum ( arr , n , k , l , r - 1 ) , findSum ( arr , n , k , l + 1 , r ) ) ; return dp [ l ] [ r ] ; }

BLEU: 92.67
Edit Sim: 31


Src: 
function isPrime ( n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( var i = 5 ; i * i <= n ; i = i + 6 ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) { return false ; } } return true ; } var n = 17 ; if ( isPrime ( n ) && ( n % 16 == 1 ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
Ref: 
bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) { return false ; } } return true ; }
Hyp: 
bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) { return false ; } } return true ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function find_Numb_ways ( n ) { var odd_indices = n / 2 ; var even_indices = ( n / 2 ) + ( n % 2 ) ; var arr_odd = Math . pow ( 4 , odd_indices ) ; var arr_even = Math . pow ( 5 , even_indices ) ; return arr_odd * arr_even ; }
Ref: 
int find_Numb_ways ( int n ) { int odd_indices = n / 2 ; int even_indices = ( n / 2 ) + ( n % 2 ) ; int arr_odd = pow ( 4 , odd_indices ) ; int arr_even = pow ( 5 , even_indices ) ; return arr_odd * arr_even ; }
Hyp: 
int find_Numb_ways ( int n ) { int odd_indices = n / 2 ; int even_indices = ( n / 2 ) + ( n % 2 ) ; int arr_odd = pow ( 4 , odd_indices ) ; int arr_even = pow ( 5 , even_indices ) ; return arr_odd * arr_even ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findPrimeFactors ( ) { for ( let i = 2 ; i < N ; i ++ ) if ( primeFactors [ i ] == 0 ) for ( let j = i ; j < N ; j += i ) primeFactors [ j ] = primeFactors [ parseInt ( j / i , 10 ) ] + 1 ; for ( let i = 1 ; i < N ; i ++ ) primeFactors [ i ] += primeFactors [ i - 1 ] ; }
Ref: 
void findPrimeFactors ( ) { for ( int i = 2 ; i < N ; i ++ ) if ( primeFactors [ i ] == 0 ) for ( int j = i ; j < N ; j += i ) primeFactors [ j ] = primeFactors [ j / i ] + 1 ; for ( int i = 1 ; i < N ; i ++ ) primeFactors [ i ] += primeFactors [ i - 1 ] ; }
Hyp: 
void findPrimeFactors ( int N ) { for ( int i = 2 ; i < N ; i ++ ) if ( primeFactors [ i ] == 0 ) for ( int j = i ; j < N ; j += i ) primeFactors [ j ] = primeFactors [ j / i ] + 1 ; for ( int i = 1 ; i < N ; i ++ ) primeFactors [ i ] += primeFactors [ i - 1 ] ; }

BLEU: 95.88
Edit Sim: 6


Src: 
function find_max ( n , k ) { var X = Array . from ( { length : 32 } , ( _ , i ) => 0 ) ; var cnt = 0 ; for ( i = 31 ; i >= 0 && cnt != k ; i -- ) { if ( ( n & ( 1 << i ) ) != 0 ) { X [ i ] = 1 ; cnt ++ ; } } var s = " " ; for ( i = 31 ; i >= 0 ; i -- ) s += X [ i ] == 0 ? ' ' : ' ' ; return parseInt ( s , 2 ) ; }
Ref: 
int find_max ( int n , int k ) { bitset < 32 > X ( 0 ) ; int cnt = 0 ; for ( int i = 31 ; i >= 0 && cnt != k ; i -- ) { if ( n & ( 1 << i ) ) { X [ i ] = 1 ; cnt ++ ; } } return X . to_ulong ( ) ; }
Hyp: 
int find_max ( int n , int k ) { int X [ 32 ] ; int cnt = 0 ; for ( int i = 31 ; i >= 0 && cnt != k ; i -- ) { if ( n & ( 1 << i ) ) { X [ i ] = 1 ; cnt ++ ; } } string s ; for ( int i = 31 ; i >= 0 ; i -- ) s += X [ i ] == 0 ? '1' : '0' ; return s ; }

BLEU: 60.35
Edit Sim: 92


Src: 
function findNumberOfStrings ( n ) { return ( n + 1 ) * ( n + 2 ) * ( n + 3 ) * ( n + 4 ) / 24 ; }
Ref: 
int findNumberOfStrings ( int n ) { return ( n + 1 ) * ( n + 2 ) * ( n + 3 ) * ( n + 4 ) / 24 ; }
Hyp: 
long findNumberOfStrings ( int n ) { return ( n + 1 ) * ( n + 2 ) * ( n + 3 ) * ( n + 4 ) / 24 ; }

BLEU: 97.1
Edit Sim: 3


Src: 
function firstDigit ( x ) { while ( x >= 10 ) x = x / 10 ; return Math . floor ( x ) ; }
Ref: 
int firstDigit ( int x ) { while ( x >= 10 ) x = x / 10 ; return x ; }
Hyp: 
int firstDigit ( long int x ) { while ( x >= 10 ) x = x / 10 ; return x ; }

BLEU: 88.95
Edit Sim: 5


Src: 
function checkrules ( s ) { if ( s . length == 0 ) return true ; if ( s [ 0 ] != ' ' ) return false ; if ( s . length > 2 ) { if ( s [ 1 ] == ' ' && s [ 2 ] == ' ' ) return checkrules ( s . substring ( 3 ) ) ; } return checkrules ( s . substring ( 1 ) ) ; } var str = " " ; if ( checkrules ( str ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
Ref: 
bool checkrules ( string s ) { if ( s . length ( ) == 0 ) return true ; if ( s [ 0 ] != '1' ) return false ; if ( s . length ( ) > 2 ) { if ( s [ 1 ] == '0' && s [ 2 ] == '0' ) return checkrules ( s . substr ( 3 ) ) ; } return checkrules ( s . substr ( 1 ) ) ; }
Hyp: 
bool checkrules ( string s ) { if ( s . length ( ) == 0 ) return true ; if ( s [ 0 ] != ' ( ' ) return false ; if ( s . length ( ) > 2 ) { if ( s [ 1 ] == ' ( ' && s [ 2 ] == ' ( ' ) return checkrules ( s . substr ( 3 ) ) ; } return checkrules ( s . substr ( 1 ) ) ; }

BLEU: 84.6
Edit Sim: 9


Src: 
function sum ( A , B , R ) { let sum = 0 ; for ( let i = 1 ; i <= R ; i ++ ) { sum = sum + ( i * A ) ; A = A + B ; } return sum ; }
Ref: 
int sum ( int A , int B , int R ) { int sum = 0 ; for ( int i = 1 ; i <= R ; i ++ ) { sum = sum + ( i * A ) ; A = A + B ; } return sum ; }
Hyp: 
int sum ( int A , int B , int R ) { int sum = 0 ; for ( int i = 1 ; i <= R ; i ++ ) { sum = sum + ( i * A ) ; A = A + B ; } return sum ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function isPossible ( str ) { let freq = new Map ( ) ; let max_freq = 0 ; for ( let j = 0 ; j < ( str . length ) ; j ++ ) { if ( freq . has ( str [ j ] ) ) { freq . set ( str [ j ] , freq . get ( str [ j ] ) + 1 ) ; if ( freq . get ( str [ j ] ) > max_freq ) max_freq = freq . get ( str [ j ] ) ; } else { freq . set ( str [ j ] , 1 ) ; if ( freq . get ( str [ j ] ) > max_freq ) max_freq = freq . get ( str [ j ] ) ; } } if ( max_freq <= ( str . length - max_freq + 1 ) ) return true ; return false ; }
Ref: 
int isPossible ( string str ) { unordered_map < char , int > freq ; int max_freq = 0 ; for ( int j = 0 ; j < ( str . length ( ) ) ; j ++ ) { freq [ str [ j ] ] ++ ; if ( freq [ str [ j ] ] > max_freq ) max_freq = freq [ str [ j ] ] ; } if ( max_freq <= ( str . length ( ) - max_freq + 1 ) ) return true ; return false ; }
Hyp: 
bool isPossible ( string str ) { unordered_map < char , int > freq ; int max_freq = 0 ; for ( int j = 0 ; j < ( str . length ( ) ) ; j ++ ) { freq [ str [ j ] ] ++ ; if ( freq [ str [ j ] ] > max_freq ) max_freq = freq [ str [ j ] ] ; } else { freq [ str [ j ] ] = 1 ; if ( freq [ str [ j ] ] > max_freq ) max_freq = freq [ str [ j ] ] ; } } if ( max_freq <= ( str . length ( ) - max_freq + 1 ) ) return true ; return false ; }

BLEU: 71.28
Edit Sim: 109


Src: 
function evenNumSubstring ( str ) { let len = str . length ; let count = 0 ; for ( let i = 0 ; i < len ; i ++ ) { let temp = str [ i ] - ' ' ; if ( temp % 2 == 0 ) count += ( i + 1 ) ; } return count ; }
Ref: 
int evenNumSubstring ( char str [ ] ) { int len = strlen ( str ) ; int count = 0 ; for ( int i = 0 ; i < len ; i ++ ) { int temp = str [ i ] - '0' ; if ( temp % 2 == 0 ) count += ( i + 1 ) ; } return count ; }
Hyp: 
int evenNumSubstring ( string str ) { int len = str . length ( ) ; int count = 0 ; for ( int i = 0 ; i < len ; i ++ ) { int temp = str [ i ] - '0' ; if ( temp % 2 == 0 ) count += ( i + 1 ) ; } return count ; }

BLEU: 86.43
Edit Sim: 19


Src: 
function countWays ( n ) { if ( n <= 2 ) document . write ( " " ) ; else { var ans = ( n - 1 ) * ( n - 2 ) / 2 ; document . write ( ans ) ; } }
Ref: 
void countWays ( int n ) { if ( n <= 2 ) cout << " - 1" ; else { int ans = ( n - 1 ) * ( n - 2 ) / 2 ; cout << ans ; } }
Hyp: 
void countWays ( int n ) { if ( n <= 2 ) cout << " No " ; else { int ans = ( n - 1 ) * ( n - 2 ) / 2 ; cout << ans ; } }

BLEU: 91.84
Edit Sim: 3


Src: 
function findPermutation ( arr , N ) { var pos = arr . size + 1 ; if ( pos > N ) return 1 ; var res = 0 ; for ( var i = 1 ; i <= N ; i ++ ) { if ( ! arr . has ( i ) ) { if ( i % pos == 0 pos % i == 0 ) { arr . add ( i ) ; res += findPermutation ( arr , N ) ; arr . delete ( i ) ; } } } return res ; }
Ref: 
int findPermutation ( unordered_set < int > & arr , int N ) { int pos = arr . size ( ) + 1 ; if ( pos > N ) return 1 ; int res = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( arr . find ( i ) == arr . end ( ) ) { if ( i % pos == 0 or pos % i == 0 ) { arr . insert ( i ) ; res += findPermutation ( arr , N ) ; arr . erase ( arr . find ( i ) ) ; } } } return res ; }
Hyp: 
int findPermutation ( vector < int > & arr , int N ) { int pos = arr . size ( ) + 1 ; if ( pos > N ) return 1 ; int res = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( arr . find ( i ) == arr . end ( ) ) { if ( i % pos == 0 pos % i == 0 ) { arr . insert ( i ) ; res += findPermutation ( arr , N ) ; arr . erase ( i ) ; } } } return res ; }

BLEU: 90.18
Edit Sim: 30


Src: 
function countEvenPairs ( N , M ) { let count = 0 ; nEven = parseInt ( Math . floor ( N / 2 ) ) ; nOdd = parseInt ( Math . ceil ( N / 2 ) ) ; mEven = parseInt ( Math . floor ( M / 2 ) ) ; mOdd = parseInt ( Math . ceil ( M / 2 ) ) ; count = nEven * mEven + nOdd * mOdd ; return count ; }
Ref: 
int countEvenPairs ( int N , int M ) { int count = 0 ; int nEven = floor ( N / 2 ) ; int nOdd = ceil ( N / 2 ) ; int mEven = floor ( M / 2 ) ; int mOdd = ceil ( M / 2 ) ; count = nEven * mEven + nOdd * mOdd ; return count ; }
Hyp: 
int countEvenPairs ( int N , int M ) { int count = 0 ; nEven = floor ( N / 2 ) ; nOdd = ceil ( N / 2 ) ; mEven = floor ( M / 2 ) ; mOdd = ceil ( M / 2 ) ; count = nEven * mEven + nOdd * mOdd ; return count ; }

BLEU: 84.91
Edit Sim: 16


Src: 
function pentdiagonal ( a ) { if ( a < 0 ) return - 1 ; let d = 1.22 * a ; return d ; }
Ref: 
float pentdiagonal ( float a ) { if ( a < 0 ) return -1 ; float d = 1.22 * a ; return d ; }
Hyp: 
float pentdiagonal ( float a ) { if ( a < 0 ) return -1 ; float d = 1.22 * a ; return d ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function productAtKthLevel ( tree , k , level ) { if ( tree [ i ++ ] == ' ' ) { if ( tree [ i ] == ' ' ) return 1 ; var product = 1 ; if ( level == k ) product = tree [ i ] - ' ' ; ++ i ; var leftproduct = productAtKthLevel ( tree , k , level + 1 ) ; ++ i ; var rightproduct = productAtKthLevel ( tree , k , level + 1 ) ; ++ i ; return product * leftproduct * rightproduct ; } return int . MinValue ; }
Ref: 
int productAtKthLevel ( string tree , int k , int & i , int level ) { if ( tree [ i ++ ] == ' ( ' ) { if ( tree [ i ] == ' ) ' ) return 1 ; int product = 1 ; if ( level == k ) product = tree [ i ] - '0' ; int leftproduct = productAtKthLevel ( tree , k , ++ i , level + 1 ) ; int rightproduct = productAtKthLevel ( tree , k , ++ i , level + 1 ) ; ++ i ; return product * leftproduct * rightproduct ; } }
Hyp: 
int productAtKthLevel ( char * tree , int k , int level ) { if ( tree [ i ++ ] == '1' ) { if ( tree [ i ] == '2' ) return 1 ; int product = 1 ; if ( level == k ) product = tree [ i ] - '0' ; ++ i ; int leftproduct = productAtKthLevel ( tree , k , level + 1 ) ; ++ i ; int rightproduct = productAtKthLevel ( tree , k , level + 1 ) ; ++ i ; return product * leftproduct * rightproduct ; } return int . MinValue ; }

BLEU: 77.75
Edit Sim: 74


Src: 
function isValid ( str , len ) { for ( let i = 1 ; i < len ; i ++ ) { if ( str [ i ] == str [ i - 1 ] ) return false ; } return true ; }
Ref: 
bool isValid ( string str , int len ) { for ( int i = 1 ; i < len ; i ++ ) { if ( str [ i ] == str [ i - 1 ] ) return false ; } return true ; }
Hyp: 
bool isValid ( string str , int len ) { for ( int i = 1 ; i < len ; i ++ ) { if ( str [ i ] == str [ i - 1 ] ) return false ; } return true ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function minValue ( A , B , n ) { A . sort ( ) ; B . sort ( ) ; let result = 0 ; for ( let i = 0 ; i < n ; i ++ ) result += ( A [ i ] * B [ n - i - 1 ] ) ; return result ; }
Ref: 
int minValue ( int A [ ] , int B [ ] , int n ) { sort ( A , A + n ) ; sort ( B , B + n ) ; long long int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) result += ( A [ i ] * B [ n - i - 1 ] ) ; return result ; }
Hyp: 
int minValue ( int A [ ] , int B [ ] , int n ) { sort ( A , A + n ) ; sort ( B , B + n ) ; int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) result += ( A [ i ] * B [ n - i - 1 ] ) ; return result ; }

BLEU: 95.43
Edit Sim: 10


Src: 
function printLeaders ( arr , size ) { for ( let i = 0 ; i < size ; i ++ ) { let j ; for ( j = i + 1 ; j < size ; j ++ ) { if ( arr [ i ] <= arr [ j ] ) break ; } if ( j == size ) document . write ( arr [ i ] + " " ) ; } }
Ref: 
void printLeaders ( int arr [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) { int j ; for ( j = i + 1 ; j < size ; j ++ ) { if ( arr [ i ] <= arr [ j ] ) break ; } if ( j == size ) cout << arr [ i ] << " ▁ " ; } }
Hyp: 
void printLeaders ( int arr [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) { int j ; for ( j = i + 1 ; j < size ; j ++ ) { if ( arr [ i ] <= arr [ j ] ) break ; } if ( j == size ) cout << arr [ i ] << " ▁ " ; } }

BLEU: 100.0
Edit Sim: 0


Src: 
function isPower ( n ) { for ( x = 2 ; x <= parseInt ( Math . sqrt ( n ) ) ; x ++ ) { var f = Math . log ( n ) / Math . log ( x ) ; if ( ( f - parseInt ( f ) ) == 0.0 ) return true ; } return false ; }
Ref: 
bool isPower ( unsigned int n ) { for ( int x = 2 ; x <= sqrt ( n ) ; x ++ ) { float f = log ( n ) / log ( x ) ; if ( ( f - ( int ) f ) == 0.0 ) return true ; } return false ; }
Hyp: 
bool isPower ( int n ) { for ( int x = 2 ; x <= sqrt ( n ) ; x ++ ) { double f = log ( n ) / log ( x ) ; if ( ( f - ( int ) f ) == 0.0 ) return true ; } return false ; }

BLEU: 91.44
Edit Sim: 15


Src: 
function count ( n ) { return 3 * n * ( n - 1 ) + 1 ; }
Ref: 
int count ( int n ) { return 3 * n * ( n - 1 ) + 1 ; }
Hyp: 
int count ( int n ) { return 3 * n * ( n - 1 ) + 1 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function find ( N ) { var T , F , O ; F = parseInt ( ( N - 4 ) / 5 ) ; if ( ( ( N - 5 * F ) % 2 ) == 0 ) { O = 2 ; } else { O = 1 ; } T = Math . floor ( ( N - 5 * F - O ) / 2 ) ; document . write ( " " + F + " " ) ; document . write ( " " + T + " " ) ; document . write ( " " + O + " " ) ; }
Ref: 
void find ( int N ) { int T , F , O ; F = int ( ( N - 4 ) / 5 ) ; if ( ( ( N - 5 * F ) % 2 ) == 0 ) { O = 2 ; } else { O = 1 ; } T = floor ( ( N - 5 * F - O ) / 2 ) ; cout << " Count ▁ of ▁ 5 ▁ valueds ▁ coins : ▁ " << F << endl ; cout << " Count ▁ of ▁ 2 ▁ valueds ▁ coins : ▁ " << T << endl ; cout << " Count ▁ of ▁ 1 ▁ valueds ▁ coins : ▁ " << O << endl ; }
Hyp: 
void find ( int N ) { int T , F , O ; F = ( N - 4 ) / 5 ; if ( ( ( N - 5 * F ) % 2 ) == 0 ) { O = 2 ; } else { O = 1 ; } T = ( N - 5 * F - O ) / 2 ; cout << " F ▁ = ▁ " << F << endl ; cout << " T ▁ = ▁ " << T << endl ; cout << " O ▁ = ▁ " << O << endl ; }

BLEU: 63.61
Edit Sim: 111


Src: 
function kthRoot ( n , k ) { return Math . pow ( k , ( 1.0 / k ) * ( Math . log ( n ) / Math . log ( k ) ) ) ; }
Ref: 
double kthRoot ( double n , int k ) { return pow ( k , ( 1.0 / k ) * ( log ( n ) / log ( k ) ) ) ; }
Hyp: 
double kthRoot ( double n , int k ) { return pow ( k , ( 1.0 / k ) * ( log ( n ) / log ( k ) ) ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countDistinct ( arr , n ) { let hs = new Set ( ) ; for ( let i = 0 ; i < n ; i ++ ) { hs . add ( arr [ i ] ) ; } return hs . size ; }
Ref: 
int countDistinct ( int arr [ ] , int n ) { unordered_set < int > s ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . find ( arr [ i ] ) == s . end ( ) ) { s . insert ( arr [ i ] ) ; res ++ ; } } return res ; }
Hyp: 
int countDistinct ( int arr [ ] , int n ) { set < int > hs ; for ( int i = 0 ; i < n ; i ++ ) { hs . insert ( arr [ i ] ) ; } return hs . size ( ) ; }

BLEU: 45.35
Edit Sim: 90


Src: 
function ToCheckPowerofX ( n , x ) { while ( n > 0 ) { var rem = n % x ; if ( rem >= 2 ) { return false ; } n = n / x ; } return true ; } var N = 10 , X = 3 ; if ( ToCheckPowerofX ( N , X ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
Ref: 
bool ToCheckPowerofX ( int n , int x ) { while ( n > 0 ) { int rem = n % x ; if ( rem >= 2 ) { return false ; } n = n / x ; } return true ; }
Hyp: 
bool ToCheckPowerofX ( int n , int x ) { while ( n > 0 ) { int rem = n % x ; if ( rem >= 2 ) { return false ; } n = n / x ; } return true ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function isPossibleToZero ( a , n ) { let even = 0 , odd = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( ( i & 1 ) == 0 ) odd += a [ i ] ; else even += a [ i ] ; } return ( odd == even ) ; }
Ref: 
bool isPossibleToZero ( int a [ ] , int n ) { int even = 0 , odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i & 1 ) odd += a [ i ] ; else even += a [ i ] ; } return ( odd == even ) ; }
Hyp: 
bool isPossibleToZero ( int a [ ] , int n ) { int even = 0 , odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( i & 1 ) == 0 ) odd += a [ i ] ; else even += a [ i ] ; } return ( odd == even ) ; }

BLEU: 92.01
Edit Sim: 9


Src: 
function gcdMax ( a , b , n , N ) { let cnt = Array . from ( { length : N } , ( _ , i ) => 0 ) ; let first = Array . from ( { length : N } , ( _ , i ) => 0 ) ; let second = Array . from ( { length : N } , ( _ , i ) => 0 ) ; for ( let i = 0 ; i < n ; ++ i ) cnt [ a [ i ] ] = 1 ; for ( let i = 1 ; i < N ; ++ i ) for ( let j = i ; j < N ; j += i ) if ( cnt [ j ] > 0 ) first [ i ] = Math . max ( first [ i ] , j ) ; cnt = Array . from ( { length : N } , ( _ , i ) => 0 ) ; for ( let i = 0 ; i < n ; ++ i ) cnt [ b [ i ] ] = 1 ; for ( let i = 1 ; i < N ; ++ i ) for ( let j = i ; j < N ; j += i ) if ( cnt [ j ] > 0 ) second [ i ] = Math . max ( second [ i ] , j ) ; let x ; for ( x = N - 1 ; x >= 0 ; x -- ) if ( first [ x ] > 0 && second [ x ] > 0 ) break ; document . write ( first [ x ] + " " + second [ x ] ) ; }
Ref: 
void gcdMax ( int a [ ] , int b [ ] , int n , int N ) { int cnt [ N ] = { 0 } ; int first [ N ] = { 0 } , second [ N ] = { 0 } ; for ( int i = 0 ; i < n ; ++ i ) cnt [ a [ i ] ] = 1 ; for ( int i = 1 ; i < N ; ++ i ) for ( int j = i ; j < N ; j += i ) if ( cnt [ j ] ) first [ i ] = max ( first [ i ] , j ) ; memset ( cnt , 0 , sizeof ( cnt ) ) ; for ( int i = 0 ; i < n ; ++ i ) cnt [ b [ i ] ] = true ; for ( int i = 1 ; i < N ; ++ i ) for ( int j = i ; j < N ; j += i ) if ( cnt [ j ] ) second [ i ] = max ( second [ i ] , j ) ; int i ; for ( i = N - 1 ; i >= 0 ; i -- ) if ( first [ i ] && second [ i ] ) break ; cout << " Maximum ▁ GCD ▁ pair ▁ with ▁ maximum ▁ " " sum ▁ is ▁ " << first [ i ] << " ▁ " << second [ i ] << endl ; }
Hyp: 
void gcdMax ( int a [ ] , int b [ ] , int n , int N ) { int cnt [ N ] ; int first [ N ] , second [ N ] ; for ( int i = 0 ; i < n ; ++ i ) cnt [ a [ i ] ] = 1 ; for ( int i = 1 ; i < N ; ++ i ) for ( int j = i ; j < N ; j += i ) if ( cnt [ j ] > 0 ) first [ i ] = max ( first [ i ] , j ) ; cnt = Array . from ( { length : N } , ( _ , i ) => 0 ) ; for ( int i = 0 ; i < n ; ++ i ) cnt [ b [ i ] ] = 1 ; for ( int i = 1 ; i < N ; ++ i ) for ( int j = i ; j < N ; j += i ) if ( cnt [ j ] > 0 ) second [ i ] = max ( second [ i ] , j ) ; int x ; for ( x = N - 1 ; x >= 0 ; x -- ) if ( first [ x ] > 0 && second [ x ] > 0 ) break ; cout << first [ x ] << " ▁ " << second [ x ] ; }

BLEU: 73.17
Edit Sim: 162


Src: 
function getChar ( str ) { let sum = 0 ; for ( let i = 0 ; i < str . length ; i ++ ) { sum += ( str [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) + 1 ) ; } if ( sum % 26 == 0 ) return ' ' ; else { sum = sum % 26 ; return String . fromCharCode ( ' ' . charCodeAt ( ) + sum - 1 ) ; } }
Ref: 
char getChar ( string str ) { int sum = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { sum += ( str [ i ] - ' a ' + 1 ) ; } if ( sum % 26 == 0 ) return ' z ' ; else { sum = sum % 26 ; return ( char ) ( ' a ' + sum - 1 ) ; } }
Hyp: 
char getChar ( string str ) { int sum = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { sum += ( str [ i ] - ' a ' + 1 ) ; } if ( sum % 26 == 0 ) return ' A ' ; else { sum = sum % 26 ; return ' Z ' + sum - 1 ; } }

BLEU: 85.01
Edit Sim: 15


Src: 
function seriesFunc ( n ) { let sumSquare = ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; let sumNatural = ( n * ( n + 1 ) / 2 ) ; return ( sumSquare + sumNatural + 1 ) ; }
Ref: 
int seriesFunc ( int n ) { int sumSquare = ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; int sumNatural = ( n * ( n + 1 ) / 2 ) ; return ( sumSquare + sumNatural + 1 ) ; }
Hyp: 
int seriesFunc ( int n ) { int sumSquare = ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; int sumNatural = ( n * ( n + 1 ) / 2 ) ; return ( sumSquare + sumNatural + 1 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findElement ( arr , n , key ) { let i ; for ( i = 0 ; i < n ; i ++ ) if ( arr [ i ] == key ) return i ; return - 1 ; }
Ref: 
int findElement ( int arr [ ] , int n , int key ) { int i ; for ( i = 0 ; i < n ; i ++ ) if ( arr [ i ] == key ) return i ; return -1 ; }
Hyp: 
int findElement ( int arr [ ] , int n , int key ) { int i ; for ( i = 0 ; i < n ; i ++ ) if ( arr [ i ] == key ) return i ; return -1 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function minValue ( arr , n ) { var minimum = Math . min . apply ( Math , arr ) ; var sum = 0 ; var i ; for ( i = 0 ; i < n ; i ++ ) { sum = sum + ( arr [ i ] - minimum ) ; } return sum ; }
Ref: 
int minValue ( int arr [ ] , int n ) { int minimum = * min_element ( arr , arr + n ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + ( arr [ i ] - minimum ) ; } return sum ; }
Hyp: 
int minValue ( int arr [ ] , int n ) { int minimum = * min_element ( arr , arr + n ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + ( arr [ i ] - minimum ) ; } return sum ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countPairs ( X , Y , m , n ) { let suffix = Array . from ( { length : 1005 } , ( _ , i ) => 0 ) ; let total_pairs = 0 ; for ( let i = 0 ; i < n ; i ++ ) suffix [ Y [ i ] ] ++ ; for ( let i = 1e3 ; i >= 3 ; i -- ) suffix [ i ] += suffix [ i + 1 ] ; for ( let i = 0 ; i < m ; i ++ ) { if ( X [ i ] == 0 ) continue ; else if ( X [ i ] == 1 ) { total_pairs += suffix [ 0 ] ; continue ; } else if ( X [ i ] == 2 ) total_pairs += suffix [ 5 ] ; else if ( X [ i ] == 3 ) total_pairs += suffix [ 2 ] + suffix [ 4 ] ; else total_pairs += suffix [ X [ i ] + 1 ] ; total_pairs += suffix [ 0 ] + suffix [ 1 ] ; } return total_pairs ; }
Ref: 
int countPairs ( int X [ ] , int Y [ ] , int m , int n ) { vector < int > suffix ( 1005 ) ; long long total_pairs = 0 ; for ( int i = 0 ; i < n ; i ++ ) suffix [ Y [ i ] ] ++ ; for ( int i = 1e3 ; i >= 3 ; i -- ) suffix [ i ] += suffix [ i + 1 ] ; for ( int i = 0 ; i < m ; i ++ ) { if ( X [ i ] == 0 ) continue ; else if ( X [ i ] == 1 ) { total_pairs += suffix [ 0 ] ; continue ; } else if ( X [ i ] == 2 ) total_pairs += suffix [ 5 ] ; else if ( X [ i ] == 3 ) total_pairs += suffix [ 2 ] + suffix [ 4 ] ; else total_pairs += suffix [ X [ i ] + 1 ] ; total_pairs += suffix [ 0 ] + suffix [ 1 ] ; } return total_pairs ; }
Hyp: 
int countPairs ( int X [ ] , int Y [ ] , int m , int n ) { int suffix [ 1005 ] ; int total_pairs = 0 ; for ( int i = 0 ; i < n ; i ++ ) suffix [ Y [ i ] ] ++ ; for ( int i = 1e3 ; i >= 3 ; i -- ) suffix [ i ] += suffix [ i + 1 ] ; for ( int i = 0 ; i < m ; i ++ ) { if ( X [ i ] == 0 ) continue ; else if ( X [ i ] == 1 ) { total_pairs += suffix [ 0 ] ; continue ; } else if ( X [ i ] == 2 ) total_pairs += suffix [ 5 ] ; else if ( X [ i ] == 3 ) total_pairs += suffix [ 2 ] + suffix [ 4 ] ; else total_pairs += suffix [ X [ i ] + 1 ] ; total_pairs += suffix [ 0 ] + suffix [ 1 ] ; } return total_pairs ; }

BLEU: 94.2
Edit Sim: 21


Src: 
function printOddFactorNumber ( n , m ) { for ( let i = n ; i <= m ; i ++ ) { if ( ( i > 0 ) && ( ( i & ( i - 1 ) ) != 0 ) ) document . write ( i + " " ) ; } return 0 ; }
Ref: 
int printOddFactorNumber ( int n , int m ) { for ( int i = n ; i <= m ; i ++ ) { if ( ( i > 0 ) && ( ( i & ( i - 1 ) ) != 0 ) ) cout << i << " ▁ " ; } }
Hyp: 
int printOddFactorNumber ( int n , int m ) { for ( int i = n ; i <= m ; i ++ ) { if ( ( i > 0 ) && ( ( i & ( i - 1 ) ) != 0 ) ) cout << i << " ▁ " ; } return 0 ; }

BLEU: 93.68
Edit Sim: 11


Src: 
function mirrorMatrix ( mat1 , mat2 , N ) { let row = 0 ; let col = 0 ; let isMirrorImage = true ; for ( let i = 0 ; i < N ; i ++ ) { for ( let j = N - 1 ; j >= 0 ; j -- ) { if ( mat2 [ row ] [ col ] != mat1 [ i ] [ j ] ) { isMirrorImage = false ; } col ++ ; } col = 0 ; row ++ ; } if ( isMirrorImage ) document . write ( " " ) ; else document . write ( " " ) ; }
Ref: 
void mirrorMatrix ( int mat1 [ ] [ 4 ] , int mat2 [ ] [ 4 ] , int N ) { int row = 0 ; int col = 0 ; bool isMirrorImage = true ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = N - 1 ; j >= 0 ; j -- ) { if ( mat2 [ row ] [ col ] != mat1 [ i ] [ j ] ) { isMirrorImage = false ; } col ++ ; } col = 0 ; row ++ ; } if ( isMirrorImage ) cout << " Yes " ; else cout << " No " ; }
Hyp: 
void mirrorMatrix ( int mat1 [ ] [ MAX ] , int mat2 [ ] [ MAX ] , int N ) { int row = 0 ; int col = 0 ; bool isMirrorImage = true ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = N - 1 ; j >= 0 ; j -- ) { if ( mat2 [ row ] [ col ] != mat1 [ i ] [ j ] ) { isMirrorImage = false ; } col ++ ; } col = 0 ; row ++ ; } if ( isMirrorImage ) cout << " Mirror " ; else cout << " Not ▁ Present " ; }

BLEU: 90.33
Edit Sim: 23


Src: 
function isRotation ( x , y ) { var x64 = x | ( x << 32 ) ; while ( x64 >= y ) { if ( x64 == y ) { return true ; } x64 >>= 1 ; } return false ; } var x = 122 ; var y = 2147483678 ; if ( isRotation ( x , y ) == false ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
Ref: 
bool isRotation ( unsigned int x , unsigned int y ) { unsigned long long int x64 = x | ( ( unsigned long long int ) x << 32 ) ; while ( x64 >= y ) { if ( unsigned ( x64 ) == y ) return true ; x64 >>= 1 ; } return false ; }
Hyp: 
bool isRotation ( int x , int y ) { long long int x64 = x | ( x << 32 ) ; while ( x64 >= y ) { if ( x64 == y ) { return true ; } x64 >>= 1 ; } return false ; }

BLEU: 58.31
Edit Sim: 71


Src: 
function expectedSteps ( x ) { if ( x == 0 ) return 0 ; if ( x <= 5 ) return 6 ; if ( v [ x ] ) return dp [ x ] ; v [ x ] = 1 ; dp [ x ] = 1 + ( expectedSteps ( x - 1 ) + expectedSteps ( x - 2 ) + expectedSteps ( x - 3 ) + expectedSteps ( x - 4 ) + expectedSteps ( x - 5 ) + expectedSteps ( x - 6 ) ) / 6 ; return dp [ x ] ; }
Ref: 
double expectedSteps ( int x ) { if ( x == 0 ) return 0 ; if ( x <= 5 ) return 6 ; if ( v [ x ] ) return dp [ x ] ; v [ x ] = 1 ; dp [ x ] = 1 + ( expectedSteps ( x - 1 ) + expectedSteps ( x - 2 ) + expectedSteps ( x - 3 ) + expectedSteps ( x - 4 ) + expectedSteps ( x - 5 ) + expectedSteps ( x - 6 ) ) / 6 ; return dp [ x ] ; }
Hyp: 
int expectedSteps ( int x ) { if ( x == 0 ) return 0 ; if ( x <= 5 ) return 6 ; if ( v [ x ] ) return dp [ x ] ; v [ x ] = 1 ; dp [ x ] = 1 + ( expectedSteps ( x - 1 ) + expectedSteps ( x - 2 ) + expectedSteps ( x - 3 ) + expectedSteps ( x - 4 ) + expectedSteps ( x - 5 ) + expectedSteps ( x - 6 ) ) / 6 ; return dp [ x ] ; }

BLEU: 99.04
Edit Sim: 6


Src: 
function printPattern ( str , len ) { for ( var i = 0 ; i < len ; i ++ ) { for ( var j = 0 ; j < len ; j ++ ) { if ( ( i == j ) || ( i + j == len - 1 ) ) document . write ( str . charAt ( j ) ) ; else document . write ( " " ) ; } document . write ( ' ' ) ; } }
Ref: 
void printPattern ( string str , int len ) { for ( int i = 0 ; i < len ; i ++ ) { for ( int j = 0 ; j < len ; j ++ ) { if ( ( i == j ) || ( i + j == len - 1 ) ) cout << str [ j ] ; else cout << " ▁ " ; } cout << endl ; } }
Hyp: 
void printPattern ( string str , int len ) { for ( int i = 0 ; i < len ; i ++ ) { for ( int j = 0 ; j < len ; j ++ ) { if ( ( i == j ) || ( i + j == len - 1 ) ) cout << str [ j ] ; else cout << '0' ; } cout << '1' ; } }

BLEU: 90.98
Edit Sim: 9


Src: 
function inversegrayCode ( n ) { let inv = 0 ; for ( ; n ; n = n >> 1 ) inv ^= n ; return inv ; }
Ref: 
int inversegrayCode ( int n ) { int inv = 0 ; for ( ; n ; n = n >> 1 ) inv ^= n ; return inv ; }
Hyp: 
int inversegrayCode ( int n ) { int inv = 0 ; for ( ; n ; n = n >> 1 ) inv ^= n ; return inv ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function maxPartitions ( arr , n ) { let ans = 0 , max_so_far = 0 ; for ( let i = 0 ; i < n ; ++ i ) { max_so_far = Math . max ( max_so_far , arr [ i ] ) ; if ( max_so_far == i ) ans ++ ; } return ans ; }
Ref: 
int maxPartitions ( int arr [ ] , int n ) { int ans = 0 , max_so_far = 0 ; for ( int i = 0 ; i < n ; ++ i ) { max_so_far = max ( max_so_far , arr [ i ] ) ; if ( max_so_far == i ) ans ++ ; } return ans ; }
Hyp: 
int maxPartitions ( int arr [ ] , int n ) { int ans = 0 , max_so_far = 0 ; for ( int i = 0 ; i < n ; ++ i ) { max_so_far = max ( max_so_far , arr [ i ] ) ; if ( max_so_far == i ) ans ++ ; } return ans ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function minimumX ( n , k ) { let ans = Number . MAX_VALUE ; for ( let rem = k - 1 ; rem > 0 ; rem -- ) { if ( n % rem == 0 ) ans = Math . min ( ans , rem + ( n / rem ) * k ) ; } return ans ; }
Ref: 
int minimumX ( int n , int k ) { int ans = INT_MAX ; for ( int rem = k - 1 ; rem > 0 ; rem -- ) { if ( n % rem == 0 ) ans = min ( ans , rem + ( n / rem ) * k ) ; } return ans ; }
Hyp: 
int minimumX ( int n , int k ) { int ans = INT_MAX ; for ( int rem = k - 1 ; rem > 0 ; rem -- ) { if ( n % rem == 0 ) ans = min ( ans , rem + ( n / rem ) * k ) ; } return ans ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function zigzag ( n , k ) { if ( n == 0 && k == 0 ) return 1 ; if ( k == 0 ) return 0 ; return zigzag ( n , k - 1 ) + zigzag ( n - 1 , n - k ) ; }
Ref: 
int zigzag ( int n , int k ) { if ( n == 0 && k == 0 ) return 1 ; if ( k == 0 ) return 0 ; return zigzag ( n , k - 1 ) + zigzag ( n - 1 , n - k ) ; }
Hyp: 
int zigzag ( int n , int k ) { if ( n == 0 && k == 0 ) return 1 ; if ( k == 0 ) return 0 ; return zigzag ( n , k - 1 ) + zigzag ( n - 1 , n - k ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function highestPowerOf2 ( n ) { return ( n & ( ~ ( n - 1 ) ) ) ; }
Ref: 
int highestPowerOf2 ( int n ) { return ( n & ( ~ ( n - 1 ) ) ) ; }
Hyp: 
int highestPowerOf2 ( unsigned int n ) { return ( n & ( ~ ( n - 1 ) ) ) ; }

BLEU: 88.44
Edit Sim: 9


Src: 
function equation_ellipse ( x1 , y1 , a , b , c , e ) { var t = a * a + b * b ; var a1 = t - e * ( a * a ) ; var b1 = t - e * ( b * b ) ; var c1 = ( - 2 * t * x1 ) - ( 2 * e * c * a ) ; var d1 = ( - 2 * t * y1 ) - ( 2 * e * c * b ) ; var e1 = - 2 * e * a * b ; var f1 = ( - e * c * c ) + ( t * x1 * x1 ) + ( t * y1 * y1 ) ; document . write ( " " + " " ) ; document . write ( a1 + " " + b1 + " " + c1 + " " + d1 + " " + e1 + " " + f1 + " " ) ; }
Ref: 
void equation_ellipse ( float x1 , float y1 , float a , float b , float c , float e ) { float t = a * a + b * b ; float a1 = t - e * ( a * a ) ; float b1 = t - e * ( b * b ) ; float c1 = ( -2 * t * x1 ) - ( 2 * e * c * a ) ; float d1 = ( -2 * t * y1 ) - ( 2 * e * c * b ) ; float e1 = -2 * e * a * b ; float f1 = ( - e * c * c ) + ( t * x1 * x1 ) + ( t * y1 * y1 ) ; cout << fixed ; cout << setprecision ( 2 ) ; cout << " Equation ▁ of ▁ ellipse ▁ is ▁ STRNEWLINE " << a1 << " ▁ x ^ 2 ▁ + ▁ " << b1 << " ▁ y ^ 2 ▁ + ▁ " << c1 << " ▁ x ▁ + ▁ " << d1 << " ▁ y ▁ + ▁ " << e1 << " ▁ xy ▁ + ▁ " << f1 << " ▁ = ▁ 0" ; }
Hyp: 
void equation_ellipse ( int x1 , int y1 , int a , int b , int c , int e ) { int t = a * a + b * b ; int a1 = t - e * ( a * a ) ; int b1 = t - e * ( b * b ) ; int c1 = ( - 2 * t * x1 ) - ( 2 * e * c * a ) ; int d1 = ( - 2 * t * y1 ) - ( 2 * e * c * b ) ; int e1 = - 2 * e * a * b ; int f1 = ( - e * c * c ) + ( t * x1 * x1 ) + ( t * y1 * y1 ) ; cout << a1 << " ▁ " << b1 << " ▁ " << c1 << " ▁ " << d1 << " ▁ " << e1 << " ▁ " << f1 << " STRNEWLINE " ; }

BLEU: 56.28
Edit Sim: 209


Src: 
function countPairs ( A , n ) { let count = 0 , i , j ; for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { if ( ( A [ i ] % 2 == 0 && A [ j ] % 2 == 0 ) || ( A [ i ] % 2 != 0 && A [ j ] % 2 != 0 ) ) count ++ ; } } return count ; }
Ref: 
int countPairs ( int A [ ] , int n ) { int count = 0 , i , j ; for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { if ( ( A [ i ] % 2 == 0 && A [ j ] % 2 == 0 ) || ( A [ i ] % 2 != 0 && A [ j ] % 2 != 0 ) ) count ++ ; } } return count ; }
Hyp: 
int countPairs ( int A [ ] , int n ) { int count = 0 , i , j ; for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { if ( ( A [ i ] % 2 == 0 && A [ j ] % 2 == 0 ) || ( A [ i ] % 2 != 0 && A [ j ] % 2 != 0 ) ) count ++ ; } } return count ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function vectorMagnitude ( x , y , z ) { var sum = x * x + y * y + z * z ; return Math . sqrt ( sum ) ; }
Ref: 
float vectorMagnitude ( int x , int y , int z ) { int sum = x * x + y * y + z * z ; return sqrt ( sum ) ; }
Hyp: 
double vectorMagnitude ( int x , int y , int z ) { int sum = x * x + y * y + z * z ; return sqrt ( sum ) ; }

BLEU: 97.1
Edit Sim: 6


Src: 
function printLastElement ( arr , N ) { var leftTurn = true ; var remainElements = N ; var step = 1 ; var head = 1 ; while ( remainElements > 1 ) { if ( leftTurn ) { head = head + step ; } else { if ( remainElements % 2 == 1 ) head = head + step ; } remainElements = remainElements / 2 ; step = step * 2 ; leftTurn = ! leftTurn ; } document . write ( arr [ head - 1 ] ) ; }
Ref: 
void printLastElement ( int arr [ ] , int N ) { bool leftTurn = true ; int remainElements = N ; int step = 1 ; int head = 1 ; while ( remainElements > 1 ) { if ( leftTurn ) { head = head + step ; } else { if ( remainElements % 2 == 1 ) head = head + step ; } remainElements = remainElements / 2 ; step = step * 2 ; leftTurn = ! leftTurn ; } cout << arr [ head - 1 ] ; }
Hyp: 
void printLastElement ( int arr [ ] , int N ) { bool leftTurn = true ; int remainElements = N ; int step = 1 ; int head = 1 ; while ( remainElements > 1 ) { if ( leftTurn ) { head = head + step ; } else { if ( remainElements % 2 == 1 ) head = head + step ; } remainElements = remainElements / 2 ; step = step * 2 ; leftTurn = ! leftTurn ; } cout << arr [ head - 1 ] ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function calculateSum ( n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { sum = sum + ( 1 << i ) ; } return sum ; }
Ref: 
int calculateSum ( int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + ( 1 << i ) ; } return sum ; }
Hyp: 
int calculateSum ( int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + ( 1 << i ) ; } return sum ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function Diagonals ( a , b , c , d ) { var p = parseFloat ( Math . sqrt ( ( ( a * c ) + ( b * d ) ) * ( ( a * d ) + ( b * c ) ) / ( ( a * b ) + ( c * d ) ) ) ) ; var q = parseFloat ( Math . sqrt ( ( ( a * c ) + ( b * d ) ) * ( ( a * b ) + ( c * d ) ) / ( ( a * d ) + ( b * c ) ) ) ) ; return [ p , q ] ; }
Ref: 
> Diagonals ( int a , int b , int c , int d ) { vector < float > ans ; ans . push_back ( sqrt ( ( ( a * c ) + ( b * d ) ) * ( ( a * d ) + ( b * c ) ) / ( ( a * b ) + ( c * d ) ) ) ) ; ans . push_back ( sqrt ( ( ( a * c ) + ( b * d ) ) * ( ( a * b ) + ( c * d ) ) / ( ( a * d ) + ( b * c ) ) ) ) ; return ans ; }
Hyp: 
float Diagonals ( int a , int b , int c , int d ) { float p = sqrt ( ( ( a * c ) + ( b * d ) ) * ( ( a * d ) + ( b * c ) ) / ( ( a * b ) + ( c * d ) ) ) ; float q = sqrt ( ( ( a * c ) + ( b * d ) ) * ( ( a * b ) + ( c * d ) ) / ( ( a * d ) + ( b * c ) ) ) ; return [ p , q ] ; }

BLEU: 82.31
Edit Sim: 65


Src: 
function countSubarrays ( A , N ) { let ans = 0 ; for ( let i = 0 ; i < N - 1 ; i ++ ) { if ( A [ i ] != A [ i + 1 ] ) { ans ++ ; for ( let j = i - 1 , k = i + 2 ; j >= 0 && k < N && A [ j ] == A [ i ] && A [ k ] == A [ i + 1 ] ; j -- , k ++ ) { ans ++ ; } } } document . write ( ans + " " ) ; }
Ref: 
void countSubarrays ( int A [ ] , int N ) { int ans = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( A [ i ] != A [ i + 1 ] ) { ans ++ ; for ( int j = i - 1 , k = i + 2 ; j >= 0 && k < N && A [ j ] == A [ i ] && A [ k ] == A [ i + 1 ] ; j -- , k ++ ) { ans ++ ; } } } cout << ans << " STRNEWLINE " ; }
Hyp: 
void countSubarrays ( int A [ ] , int N ) { int ans = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( A [ i ] != A [ i + 1 ] ) { ans ++ ; for ( int j = i - 1 , k = i + 2 ; j >= 0 && k < N && A [ j ] == A [ i ] && A [ k ] == A [ i + 1 ] ; j -- , k ++ ) { ans ++ ; } } } cout << ans << " STRNEWLINE " ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function prletGroups ( n ) { let x = 1 ; let y = n * n ; for ( let i = 1 ; i <= n ; i ++ ) { for ( let j = 1 ; j <= n / 2 ; j ++ ) { document . write ( " " + x + " " + y + " " ) ; x ++ ; y -- ; } document . write ( " " ) ; } }
Ref: 
void printGroups ( int n ) { int x = 1 ; int y = n * n ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n / 2 ; j ++ ) { cout << " { ▁ " << x << " , ▁ " << y << " } ▁ " ; x ++ ; y -- ; } cout << endl ; } }
Hyp: 
void printGroups ( int n ) { int x = 1 ; int y = n * n ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n / 2 ; j ++ ) { cout << " ( " << x << " , ▁ " << y << " ) " ; x ++ ; y -- ; } cout << " ( " ; } }

BLEU: 88.61
Edit Sim: 11


Src: 
function min_noOf_operation ( arr , n , k ) { let noOfSubtraction ; let res = 0 ; for ( let i = 1 ; i < n ; i ++ ) { noOfSubtraction = 0 ; if ( arr [ i ] > arr [ i - 1 ] ) { noOfSubtraction = ( arr [ i ] - arr [ i - 1 ] ) / k ; if ( ( arr [ i ] - arr [ i - 1 ] ) % k != 0 ) noOfSubtraction ++ ; arr [ i ] = arr [ i ] - k * noOfSubtraction ; } res = res + noOfSubtraction ; } return res ; }
Ref: 
int min_noOf_operation ( int arr [ ] , int n , int k ) { int noOfSubtraction ; int res = 0 ; for ( int i = 1 ; i < n ; i ++ ) { noOfSubtraction = 0 ; if ( arr [ i ] > arr [ i - 1 ] ) { noOfSubtraction = ( arr [ i ] - arr [ i - 1 ] ) / k ; if ( ( arr [ i ] - arr [ i - 1 ] ) % k != 0 ) noOfSubtraction ++ ; arr [ i ] = arr [ i ] - k * noOfSubtraction ; } res = res + noOfSubtraction ; } return res ; }
Hyp: 
int min_noOf_operation ( int arr [ ] , int n , int k ) { int noOfSubtraction ; int res = 0 ; for ( int i = 1 ; i < n ; i ++ ) { noOfSubtraction = 0 ; if ( arr [ i ] > arr [ i - 1 ] ) { noOfSubtraction = ( arr [ i ] - arr [ i - 1 ] ) / k ; if ( ( arr [ i ] - arr [ i - 1 ] ) % k != 0 ) noOfSubtraction ++ ; arr [ i ] = arr [ i ] - k * noOfSubtraction ; } res = res + noOfSubtraction ; } return res ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function product ( a , n ) { var ans = 1 ; var val = Math . pow ( 2 , n - 1 ) ; for ( var i = 0 ; i < n ; i ++ ) { ans *= Math . pow ( a [ i ] , val ) ; } return ans ; }
Ref: 
int product ( int a [ ] , int n ) { int ans = 1 ; int val = pow ( 2 , n - 1 ) ; for ( int i = 0 ; i < n ; i ++ ) { ans *= pow ( a [ i ] , val ) ; } return ans ; }
Hyp: 
int product ( int a [ ] , int n ) { int ans = 1 ; int val = pow ( 2 , n - 1 ) ; for ( int i = 0 ; i < n ; i ++ ) { ans *= pow ( a [ i ] , val ) ; } return ans ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function getInvCount ( arr ) { let inv_count = 0 ; for ( let i = 0 ; i < arr . length - 1 ; i ++ ) { for ( let j = i + 1 ; j < arr . length ; j ++ ) { if ( arr [ i ] > arr [ j ] ) inv_count ++ ; } } return inv_count ; }
Ref: 
int getInvCount ( int arr [ ] , int n ) { int inv_count = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] > arr [ j ] ) inv_count ++ ; return inv_count ; }
Hyp: 
int getInvCount ( int arr [ ] , int n ) { int inv_count = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] > arr [ j ] ) inv_count ++ ; } } return inv_count ; }

BLEU: 87.9
Edit Sim: 8


Src: 
function maxProduct ( arr , n ) { if ( n < 4 ) return - 1 ; arr . sort ( function ( a , b ) { return a - b ; } ) ; let x = arr [ n - 1 ] * arr [ n - 2 ] * arr [ n - 3 ] * arr [ n - 4 ] ; let y = arr [ 0 ] * arr [ 1 ] * arr [ 2 ] * arr [ 3 ] ; let z = arr [ 0 ] * arr [ 1 ] * arr [ n - 1 ] * arr [ n - 2 ] ; return Math . max ( x , Math . max ( y , z ) ) ; }
Ref: 
int maxProduct ( int arr [ ] , int n ) { if ( n < 4 ) return -1 ; sort ( arr , arr + n ) ; int x = arr [ n - 1 ] * arr [ n - 2 ] * arr [ n - 3 ] * arr [ n - 4 ] ; int y = arr [ 0 ] * arr [ 1 ] * arr [ 2 ] * arr [ 3 ] ; int z = arr [ 0 ] * arr [ 1 ] * arr [ n - 1 ] * arr [ n - 2 ] ; return max ( x , max ( y , z ) ) ; }
Hyp: 
int maxProduct ( int arr [ ] , int n ) { if ( n < 4 ) return -1 ; sort ( arr , arr + n ) ; int x = arr [ n - 1 ] * arr [ n - 2 ] * arr [ n - 3 ] * arr [ n - 4 ] ; int y = arr [ 0 ] * arr [ 1 ] * arr [ 2 ] * arr [ 3 ] ; int z = arr [ 0 ] * arr [ 1 ] * arr [ n - 1 ] * arr [ n - 2 ] ; return max ( x , max ( y , z ) ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function heptacontagonNum ( n ) { return ( 68 * n * n - 66 * n ) / 2 ; }
Ref: 
int heptacontagonNum ( int n ) { return ( 68 * n * n - 66 * n ) / 2 ; }
Hyp: 
int heptacontagonNum ( int n ) { return ( 68 * n * n - 66 * n ) / 2 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function minSum ( arr , n ) { let sum = 0 ; arr . sort ( function ( a , b ) { return b - a } ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( i % 4 < 2 ) sum = sum + arr [ i ] ; } return sum ; }
Ref: 
int minSum ( int arr [ ] , int n ) { int sum = 0 ; sort ( arr , arr + n , greater < int > ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 4 < 2 ) sum = sum + arr [ i ] ; } return sum ; }
Hyp: 
int minSum ( int arr [ ] , int n ) { int sum = 0 ; sort ( arr , arr + n ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 4 < 2 ) sum = sum + arr [ i ] ; } return sum ; }

BLEU: 87.29
Edit Sim: 22


Src: 
function square ( n ) { if ( n < 0 ) n = - n ; let res = n ; for ( let i = 1 ; i < n ; i ++ ) res += n ; return res ; }
Ref: 
int square ( int n ) { if ( n < 0 ) n = - n ; int res = n ; for ( int i = 1 ; i < n ; i ++ ) res += n ; return res ; }
Hyp: 
int square ( int n ) { if ( n < 0 ) n = - n ; int res = n ; for ( int i = 1 ; i < n ; i ++ ) res += n ; return res ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function modifiedBinaryPattern ( n ) { for ( let i = 1 ; i <= n ; i ++ ) { for ( let j = 1 ; j <= i ; j ++ ) { if ( j == 1 j == i ) document . write ( 1 ) ; else document . write ( 0 ) ; } document . write ( " " ) ; } }
Ref: 
void modifiedBinaryPattern ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) { if ( j == 1 j == i ) cout << 1 ; else cout << 0 ; } cout << endl ; } }
Hyp: 
void modifiedBinaryPattern ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) { if ( j == 1 j == i ) cout << 1 ; else cout << 0 ; } cout << " STRNEWLINE " ; } }

BLEU: 92.86
Edit Sim: 14


Src: 
function countDyckPaths ( n ) { let res = 1 ; for ( let i = 0 ; i < n ; ++ i ) { res *= ( 2 * n - i ) ; res /= ( i + 1 ) ; } return res / ( n + 1 ) ; }
Ref: 
int countDyckPaths ( unsigned int n ) { int res = 1 ; for ( int i = 0 ; i < n ; ++ i ) { res *= ( 2 * n - i ) ; res /= ( i + 1 ) ; } return res / ( n + 1 ) ; }
Hyp: 
double countDyckPaths ( int n ) { double res = 1 ; for ( int i = 0 ; i < n ; ++ i ) { res *= ( 2 * n - i ) ; res /= ( i + 1 ) ; } return res / ( n + 1 ) ; }

BLEU: 89.68
Edit Sim: 21


Src: 
function findTrailingZeros ( n ) { let count = 0 ; for ( let i = 5 ; Math . floor ( n / i ) >= 1 ; i *= 5 ) count += Math . floor ( n / i ) ; return count ; }
Ref: 
int findTrailingZeros ( int n ) { int count = 0 ; for ( int i = 5 ; n / i >= 1 ; i *= 5 ) count += n / i ; return count ; }
Hyp: 
int findTrailingZeros ( int n ) { int count = 0 ; for ( int i = 5 ; n / i >= 1 ; i *= 5 ) count += n / i ; return count ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function isLoeschian ( n ) { for ( let x = 1 ; x <= Math . sqrt ( n ) ; x ++ ) { for ( let y = 1 ; y <= Math . sqrt ( n ) ; y ++ ) { if ( x * x + x * y + y * y == n ) return true ; } } return false ; }
Ref: 
bool isLoeschian ( int n ) { for ( int x = 1 ; x <= sqrt ( n ) ; x ++ ) { for ( int y = 1 ; y <= sqrt ( n ) ; y ++ ) { if ( x * x + x * y + y * y == n ) return true ; } } return false ; }
Hyp: 
bool isLoeschian ( int n ) { for ( long long int x = 1 ; x <= sqrt ( n ) ; x ++ ) { for ( long long int y = 1 ; y <= sqrt ( n ) ; y ++ ) { if ( x * x + x * y + y * y == n ) return true ; } } return false ; }

BLEU: 90.1
Edit Sim: 20


Src: 
function findCount ( m , n ) { let num1 = 0 ; for ( let i = 0 ; i < m ; i ++ ) num1 = ( num1 * 10 ) + 9 ; let num2 = 0 ; for ( let i = 0 ; i < ( m - 1 ) ; i ++ ) num2 = ( num2 * 10 ) + 9 ; return ( ( num1 / n ) - ( num2 / n ) ) ; }
Ref: 
int findCount ( int m , int n ) { int num1 = 0 ; for ( int i = 0 ; i < m ; i ++ ) num1 = ( num1 * 10 ) + 9 ; int num2 = 0 ; for ( int i = 0 ; i < ( m - 1 ) ; i ++ ) num2 = ( num2 * 10 ) + 9 ; return ( ( num1 / n ) - ( num2 / n ) ) ; }
Hyp: 
int findCount ( int m , int n ) { int num1 = 0 ; for ( int i = 0 ; i < m ; i ++ ) num1 = ( num1 * 10 ) + 9 ; int num2 = 0 ; for ( int i = 0 ; i < ( m - 1 ) ; i ++ ) num2 = ( num2 * 10 ) + 9 ; return ( ( num1 / n ) - ( num2 / n ) ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function flipBitsOfAandB ( A , B ) { for ( i = 0 ; i < 32 ; i ++ ) { if ( ( ( A & ( 1 << i ) ) & ( B & ( 1 << i ) ) ) != 0 ) { A = A ^ ( 1 << i ) ; B = B ^ ( 1 << i ) ; } } document . write ( A + " " + B ) ; }
Ref: 
void flipBitsOfAandB ( int A , int B ) { for ( int i = 0 ; i < 32 ; i ++ ) { if ( ( A & ( 1 << i ) ) && ( B & ( 1 << i ) ) ) { A = A ^ ( 1 << i ) ; B = B ^ ( 1 << i ) ; } } cout << A << " ▁ " << B ; }
Hyp: 
void flipBitsOfAandB ( int A , int B ) { for ( int i = 0 ; i < 32 ; i ++ ) { if ( ( ( A & ( 1 << i ) ) & ( B & ( 1 << i ) ) ) != 0 ) { A = A ^ ( 1 << i ) ; B = B ^ ( 1 << i ) ; } } cout << A << " ▁ " << B ; }

BLEU: 91.04
Edit Sim: 10


Src: 
function chiliagonNum ( n ) { return ( 998 * n * n - 996 * n ) / 2 ; }
Ref: 
int chiliagonNum ( int n ) { return ( 998 * n * n - 996 * n ) / 2 ; }
Hyp: 
int chiliagonNum ( int n ) { return ( 998 * n * n - 996 * n ) / 2 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function lexNext ( s , n ) { for ( let i = n - 1 ; i >= 0 ; i -- ) { if ( s [ i ] != ' ' ) { let code = s . charCodeAt ( i ) + 1 ; let str = String . fromCharCode ( code ) ; return s . substr ( 0 , i ) + str + s . substr ( i + 1 ) ; } s [ i ] = ' ' ; } }
Ref: 
string lexNext ( string s , int n ) { for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( s [ i ] != ' z ' ) { s [ i ] ++ ; return s ; } s [ i ] = ' a ' ; } }
Hyp: 
string lexNext ( string s , int n ) { for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( s [ i ] != ' ( ' ) { int code = s [ i ] + 1 ; string str = str ( code ) ; return s . substr ( 0 , i ) + str + s . substr ( i + 1 ) ; } s [ i ] = ' ( ' ; } }

BLEU: 54.23
Edit Sim: 91


Src: 
function largestSquare ( matrix , R , C , q_i , q_j , K , Q ) { for ( var q = 0 ; q < Q ; q ++ ) { var i = q_i [ q ] ; var j = q_j [ q ] ; var min_dist = Math . min ( Math . min ( i , j ) , Math . min ( R - i - 1 , C - j - 1 ) ) ; var ans = - 1 ; for ( var k = 0 ; k <= min_dist ; k ++ ) { var count = 0 ; for ( var row = i - k ; row <= i + k ; row ++ ) for ( var col = j - k ; col <= j + k ; col ++ ) count += matrix [ row ] [ col ] ; if ( count > K ) break ; ans = 2 * k + 1 ; } document . write ( ans + " " ) ; } }
Ref: 
void largestSquare ( int matrix [ ] [ MAX ] , int R , int C , int q_i [ ] , int q_j [ ] , int K , int Q ) { for ( int q = 0 ; q < Q ; q ++ ) { int i = q_i [ q ] ; int j = q_j [ q ] ; int min_dist = min ( min ( i , j ) , min ( R - i - 1 , C - j - 1 ) ) ; int ans = -1 ; for ( int k = 0 ; k <= min_dist ; k ++ ) { int count = 0 ; for ( int row = i - k ; row <= i + k ; row ++ ) for ( int col = j - k ; col <= j + k ; col ++ ) count += matrix [ row ] [ col ] ; if ( count > K ) break ; ans = 2 * k + 1 ; } cout << ans << " STRNEWLINE " ; } }
Hyp: 
void largestSquare ( int matrix [ ] [ MAX ] , int R , int C , int q_i [ ] , int q_j [ ] , int K , int Q ) { for ( int q = 0 ; q < Q ; q ++ ) { int i = q_i [ q ] ; int j = q_j [ q ] ; int min_dist = min ( min ( i , j ) , min ( R - i - 1 , C - j - 1 ) ) ; int ans = -1 ; for ( int k = 0 ; k <= min_dist ; k ++ ) { int count = 0 ; for ( int row = i - k ; row <= i + k ; row ++ ) for ( int col = j - k ; col <= j + k ; col ++ ) count += matrix [ row ] [ col ] ; if ( count > K ) break ; ans = 2 * k + 1 ; } cout << ans << " ▁ " ; } }

BLEU: 98.68
Edit Sim: 10


Src: 
function checkSorted ( n , arr ) { var b = Array ( n ) . fill ( 0 ) ; for ( var i = 0 ; i < n ; i ++ ) b [ i ] = arr [ i ] ; b . sort ( ) ; var ct = 0 ; for ( var i = 0 ; i < n ; i ++ ) if ( arr [ i ] != b [ i ] ) ct ++ ; if ( ct == 0 ct == 2 ) return true ; else return false ; }
Ref: 
bool checkSorted ( int n , int arr [ ] ) { int b [ n ] ; for ( int i = 0 ; i < n ; i ++ ) b [ i ] = arr [ i ] ; sort ( b , b + n ) ; int ct = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] != b [ i ] ) ct ++ ; if ( ct == 0 ct == 2 ) return true ; else return false ; }
Hyp: 
bool checkSorted ( int n , int arr [ ] ) { vector < int > b ( n , 0 ) ; for ( int i = 0 ; i < n ; i ++ ) b [ i ] = arr [ i ] ; sort ( b . begin ( ) , b . end ( ) ) ; int ct = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] != b [ i ] ) ct ++ ; if ( ct == 0 ct == 2 ) return true ; else return false ; }

BLEU: 80.76
Edit Sim: 36


Src: 
function ReplaceElements ( arr , n ) { if ( n <= 1 ) return ; let prev = arr [ 0 ] ; arr [ 0 ] = arr [ 0 ] ^ arr [ 1 ] ; for ( let i = 1 ; i < n - 1 ; i ++ ) { let curr = arr [ i ] ; arr [ i ] = prev ^ arr [ i + 1 ] ; prev = curr ; } arr [ n - 1 ] = prev ^ arr [ n - 1 ] ; }
Ref: 
void ReplaceElements ( int arr [ ] , int n ) { if ( n <= 1 ) return ; int prev = arr [ 0 ] ; arr [ 0 ] = arr [ 0 ] ^ arr [ 1 ] ; for ( int i = 1 ; i < n - 1 ; i ++ ) { int curr = arr [ i ] ; arr [ i ] = prev ^ arr [ i + 1 ] ; prev = curr ; } arr [ n - 1 ] = prev ^ arr [ n - 1 ] ; }
Hyp: 
void ReplaceElements ( int arr [ ] , int n ) { if ( n <= 1 ) return ; int prev = arr [ 0 ] ; arr [ 0 ] = arr [ 0 ] ^ arr [ 1 ] ; for ( int i = 1 ; i < n - 1 ; i ++ ) { int curr = arr [ i ] ; arr [ i ] = prev ^ arr [ i + 1 ] ; prev = curr ; } arr [ n - 1 ] = prev ^ arr [ n - 1 ] ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function no_of_moves ( Matrix , x , y ) { let moves = 0 ; for ( let i = 0 ; i < M ; i ++ ) { for ( let j = 0 ; j < N ; j ++ ) { if ( Matrix [ i ] [ j ] != 0 ) { moves += Math . abs ( x - i ) ; moves += Math . abs ( y - j ) ; } } } document . write ( moves ) ; }
Ref: 
void no_of_moves ( int Matrix [ M ] [ N ] , int x , int y ) { int moves = 0 ; for ( int i = 0 ; i < M ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( Matrix [ i ] [ j ] != 0 ) { moves += abs ( x - i ) ; moves += abs ( y - j ) ; } } } cout << moves << " STRNEWLINE " ; }
Hyp: 
void no_of_moves ( int Matrix [ M ] [ N ] , int x , int y ) { int moves = 0 ; for ( int i = 0 ; i < M ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( Matrix [ i ] [ j ] != 0 ) { moves += abs ( x - i ) ; moves += abs ( y - j ) ; } } } cout << moves ; }

BLEU: 94.48
Edit Sim: 18


Src: 
function isPossible ( arr , n ) { var mini = Number . MAX_VALUE ; for ( var i = 0 ; i < n ; i ++ ) mini = Math . min ( mini , arr [ i ] ) ; for ( var i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == mini ) continue ; var Max = ( arr [ i ] + 1 ) / 2 - 1 ; if ( mini < 0 mini > Max ) return " " ; } return " " ; }
Ref: 
string isPossible ( int arr [ ] , int n ) { int mini = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) mini = min ( mini , arr [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == mini ) continue ; int Max = ( arr [ i ] + 1 ) / 2 - 1 ; if ( mini < 0 mini > Max ) return " No " ; } return " Yes " ; }
Hyp: 
string isPossible ( int arr [ ] , int n ) { int mini = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) mini = min ( mini , arr [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == mini ) continue ; int Max = ( arr [ i ] + 1 ) / 2 - 1 ; if ( mini < 0 mini > Max ) return " Yes " ; } return " No " ; }

BLEU: 99.52
Edit Sim: 6


Src: 
function largestSquare ( matrix , R , C , q_i , q_j , K , Q ) { let countDP = new Array ( R ) ; for ( let i = 0 ; i < R ; i ++ ) { countDP [ i ] = new Array ( C ) ; for ( let j = 0 ; j < C ; j ++ ) countDP [ i ] [ j ] = 0 ; } countDP [ 0 ] [ 0 ] = matrix [ 0 ] [ 0 ] ; for ( let i = 1 ; i < R ; i ++ ) countDP [ i ] [ 0 ] = countDP [ i - 1 ] [ 0 ] + matrix [ i ] [ 0 ] ; for ( let j = 1 ; j < C ; j ++ ) countDP [ 0 ] [ j ] = countDP [ 0 ] [ j - 1 ] + matrix [ 0 ] [ j ] ; for ( let i = 1 ; i < R ; i ++ ) for ( let j = 1 ; j < C ; j ++ ) countDP [ i ] [ j ] = matrix [ i ] [ j ] + countDP [ i - 1 ] [ j ] + countDP [ i ] [ j - 1 ] - countDP [ i - 1 ] [ j - 1 ] ; for ( let q = 0 ; q < Q ; q ++ ) { let i = q_i [ q ] ; let j = q_j [ q ] ; let min_dist = Math . min ( Math . min ( i , j ) , Math . min ( R - i - 1 , C - j - 1 ) ) ; let ans = - 1 ; for ( let k = 0 ; k <= min_dist ; k ++ ) { let x1 = i - k , x2 = i + k ; let y1 = j - k , y2 = j + k ; let count = countDP [ x2 ] [ y2 ] ; if ( x1 > 0 ) count -= countDP [ x1 - 1 ] [ y2 ] ; if ( y1 > 0 ) count -= countDP [ x2 ] [ y1 - 1 ] ; if ( x1 > 0 && y1 > 0 ) count += countDP [ x1 - 1 ] [ y1 - 1 ] ; if ( count > K ) break ; ans = 2 * k + 1 ; } document . write ( ans + " " ) ; } }
Ref: 
void largestSquare ( int matrix [ ] [ MAX ] , int R , int C , int q_i [ ] , int q_j [ ] , int K , int Q ) { int countDP [ R ] [ C ] ; memset ( countDP , 0 , sizeof ( countDP ) ) ; countDP [ 0 ] [ 0 ] = matrix [ 0 ] [ 0 ] ; for ( int i = 1 ; i < R ; i ++ ) countDP [ i ] [ 0 ] = countDP [ i - 1 ] [ 0 ] + matrix [ i ] [ 0 ] ; for ( int j = 1 ; j < C ; j ++ ) countDP [ 0 ] [ j ] = countDP [ 0 ] [ j - 1 ] + matrix [ 0 ] [ j ] ; for ( int i = 1 ; i < R ; i ++ ) for ( int j = 1 ; j < C ; j ++ ) countDP [ i ] [ j ] = matrix [ i ] [ j ] + countDP [ i - 1 ] [ j ] + countDP [ i ] [ j - 1 ] - countDP [ i - 1 ] [ j - 1 ] ; for ( int q = 0 ; q < Q ; q ++ ) { int i = q_i [ q ] ; int j = q_j [ q ] ; int min_dist = min ( min ( i , j ) , min ( R - i - 1 , C - j - 1 ) ) ; int ans = -1 ; for ( int k = 0 ; k <= min_dist ; k ++ ) { int x1 = i - k , x2 = i + k ; int y1 = j - k , y2 = j + k ; int count = countDP [ x2 ] [ y2 ] ; if ( x1 > 0 ) count -= countDP [ x1 - 1 ] [ y2 ] ; if ( y1 > 0 ) count -= countDP [ x2 ] [ y1 - 1 ] ; if ( x1 > 0 && y1 > 0 ) count += countDP [ x1 - 1 ] [ y1 - 1 ] ; if ( count > K ) break ; ans = 2 * k + 1 ; } cout << ans << " STRNEWLINE " ; } }
Hyp: 
void largestSquare ( int matrix [ ] [ R ] , int C , int q_i [ ] , int q_j [ ] , int K , int Q ) { int countDP [ R ] [ C ] ; memset ( countDP , 0 , sizeof ( countDP ) ) ; for ( int i = 0 ; i < R ; i ++ ) countDP [ i ] [ 0 ] = matrix [ 0 ] [ 0 ] ; for ( int j = 1 ; j < C ; j ++ ) countDP [ 0 ] [ j ] = countDP [ 0 ] [ j - 1 ] + matrix [ 0 ] [ j ] ; for ( int i = 1 ; i < R ; i ++ ) for ( int j = 1 ; j < C ; j ++ ) countDP [ i ] [ j ] = matrix [ i ] [ j ] + countDP [ i - 1 ] [ j ] + countDP [ i ] [ j - 1 ] - countDP [ i - 1 ] [ j - 1 ] ; for ( int q = 0 ; q < Q ; q ++ ) { int i = q_i [ q ] ; int j = q_j [ q ] ; int min_dist = min ( min ( i , j ) , min ( R - i - 1 , C - j - 1 ) ) ; int ans = -1 ; for ( int k = 0 ; k <= min_dist ; k ++ ) { int x1 = i - k , x2 = i + k ; int y1 = j - k , y2 = j + k ; int count = countDP [ x2 ] [ y2 ] ; if ( x1 > 0 ) count -= countDP [ x1 - 1 ] [ y2 ] ; if ( y1 > 0 ) count -= countDP [ x1 - 1 ] [ y1 - 1 ] ; if ( count > K ) break ; ans = 2 * k + 1 ; } cout << ans << " STRNEWLINE " ; } }

BLEU: 86.07
Edit Sim: 143


Src: 
function findWinner ( X , Y ) { let first = ( X ^ Y ) ; let second = ( X + Y ) ; if ( first == second ) { document . write ( " " ) ; } else { document . write ( " " ) ; } }
Ref: 
void findWinner ( int X , int Y ) { int first = ( X ^ Y ) ; int second = ( X + Y ) ; if ( first == second ) { cout << " No " ; } else { cout << " Yes " ; } }
Hyp: 
void findWinner ( int X , int Y ) { int first = ( X ^ Y ) ; int second = ( X + Y ) ; if ( first == second ) { cout << " A " ; } else { cout << " B " ; } }

BLEU: 90.08
Edit Sim: 5


Src: 
function FindIndexKthBit ( n , k ) { let cnt = 0 ; let ind = 0 ; while ( n > 0 ) { if ( n & 1 > 0 ) cnt ++ ; if ( cnt == k ) return ind ; ind ++ ; n = n >> 1 ; } return - 1 ; }
Ref: 
int FindIndexKthBit ( int n , int k ) { int cnt = 0 ; int ind = 0 ; while ( n ) { if ( n & 1 ) cnt ++ ; if ( cnt == k ) return ind ; ind ++ ; n = n >> 1 ; } return -1 ; }
Hyp: 
int FindIndexKthBit ( unsigned int n , unsigned int k ) { unsigned int cnt = 0 ; unsigned int ind = 0 ; while ( n > 0 ) { if ( n & 1 > 0 ) cnt ++ ; if ( cnt == k ) return ind ; ind ++ ; n = n >> 1 ; } return -1 ; }

BLEU: 72.64
Edit Sim: 44


Src: 
function minDel ( s1 , s2 ) { var i = s1 . length ; var j = s2 . length ; while ( i > 0 && j > 0 ) { if ( s1 [ i - 1 ] != s2 [ j - 1 ] ) { break ; } i -- ; j -- ; } return i + j ; }
Ref: 
int minDel ( string s1 , string s2 ) { int i = s1 . length ( ) ; int j = s2 . length ( ) ; while ( i > 0 && j > 0 ) { if ( s1 [ i - 1 ] != s2 [ j - 1 ] ) { break ; } i -- ; j -- ; } return i + j ; }
Hyp: 
int minDel ( string s1 , string s2 ) { int i = s1 . size ( ) , j = s2 . size ( ) ; while ( i > 0 && j > 0 ) { if ( s1 [ i - 1 ] != s2 [ j - 1 ] ) { break ; } i -- ; j -- ; } return i + j ; }

BLEU: 88.28
Edit Sim: 17


Src: 
function polyarea ( n , a ) { if ( a < 0 && n < 0 ) return - 1 ; var A = ( a * a * n ) / ( 4 * Math . tan ( ( 180 / n ) * 3.14159 / 180 ) ) ; return A ; }
Ref: 
float polyarea ( float n , float a ) { if ( a < 0 && n < 0 ) return -1 ; float A = ( a * a * n ) / ( 4 * tan ( ( 180 / n ) * 3.14159 / 180 ) ) ; return A ; }
Hyp: 
float polyarea ( float n , float a ) { if ( a < 0 && n < 0 ) return -1 ; float A = ( a * a * n ) / ( 4 * tan ( ( 180 / n ) * 3.14159 / 180 ) ) ; return A ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function printCountDP ( dist ) { var ways = [ ] , n = dist ; ways . length = 3 ; ways [ 0 ] = 1 ; ways [ 1 ] = 1 ; ways [ 2 ] = 2 ; for ( var i = 3 ; i <= n ; i ++ ) ways [ i % 3 ] = ways [ ( i - 1 ) % 3 ] + ways [ ( i - 2 ) % 3 ] + ways [ ( i - 3 ) % 3 ] ; return ways [ n % 3 ] ; }
Ref: 
int printCountDP ( int dist ) { int ways [ 3 ] , n = dist ; ways [ 0 ] = 1 ; ways [ 1 ] = 1 ; ways [ 2 ] = 2 ; for ( int i = 3 ; i <= n ; i ++ ) ways [ i % 3 ] = ways [ ( i - 1 ) % 3 ] + ways [ ( i - 2 ) % 3 ] + ways [ ( i - 3 ) % 3 ] ; return ways [ n % 3 ] ; }
Hyp: 
int printCountDP ( int dist ) { int ways [ 3 ] , n = dist ; ways . length = 3 ; ways [ 0 ] = 1 ; ways [ 1 ] = 1 ; ways [ 2 ] = 2 ; for ( int i = 3 ; i <= n ; i ++ ) ways [ i % 3 ] = ways [ ( i - 1 ) % 3 ] + ways [ ( i - 2 ) % 3 ] + ways [ ( i - 3 ) % 3 ] ; return ways [ n % 3 ] ; }

BLEU: 94.13
Edit Sim: 20


Src: 
function longestGP ( A , N ) { if ( N < 2 ) return N ; let length = 1 , common_ratio = 1 ; let maxlength = 1 ; for ( let i = 0 ; i < N - 1 ; i ++ ) { if ( A [ i + 1 ] % A [ i ] == 0 ) { if ( A [ i + 1 ] / A [ i ] == common_ratio ) { length = length + 1 ; maxlength = Math . max ( maxlength , length ) ; } else { common_ratio = A [ i + 1 ] / A [ i ] ; length = 2 ; } } else { maxlength = Math . max ( maxlength , length ) ; length = 1 ; } } maxlength = Math . max ( maxlength , length ) ; return maxlength ; }
Ref: 
int longestGP ( int A [ ] , int N ) { if ( N < 2 ) return N ; int length = 1 , common_ratio = 1 ; int maxlength = 1 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( A [ i + 1 ] % A [ i ] == 0 ) { if ( A [ i + 1 ] / A [ i ] == common_ratio ) { length = length + 1 ; maxlength = max ( maxlength , length ) ; } else { common_ratio = A [ i + 1 ] / A [ i ] ; length = 2 ; } } else { maxlength = max ( maxlength , length ) ; length = 1 ; } } maxlength = max ( maxlength , length ) ; return maxlength ; }
Hyp: 
int longestGP ( int A [ ] , int N ) { if ( N < 2 ) return N ; int length = 1 , common_ratio = 1 ; int maxlength = 1 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( A [ i + 1 ] % A [ i ] == 0 ) { if ( A [ i + 1 ] / A [ i ] == common_ratio ) { length = length + 1 ; maxlength = max ( maxlength , length ) ; } else { common_ratio = A [ i + 1 ] / A [ i ] ; length = 2 ; } } else { maxlength = max ( maxlength , length ) ; length = 1 ; } } maxlength = max ( maxlength , length ) ; return maxlength ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function max_min ( a , n ) { a . sort ( ) ; return Math . min ( a [ n - 2 ] - a [ 0 ] , a [ n - 1 ] - a [ 1 ] ) ; }
Ref: 
int max_min ( int a [ ] , int n ) { sort ( a , a + n ) ; return min ( a [ n - 2 ] - a [ 0 ] , a [ n - 1 ] - a [ 1 ] ) ; }
Hyp: 
int max_min ( int a [ ] , int n ) { sort ( a , a + n ) ; return min ( a [ n - 2 ] - a [ 0 ] , a [ n - 1 ] - a [ 1 ] ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function printCharWithFreq ( str ) { let n = str . length ; let freq = new Array ( SIZE ) ; for ( let i = 0 ; i < freq . length ; i ++ ) { freq [ i ] = 0 ; } for ( let i = 0 ; i < n ; i ++ ) freq [ str [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; for ( let i = 0 ; i < n ; i ++ ) { if ( freq [ str [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] != 0 ) { document . write ( str [ i ] ) ; document . write ( freq [ str [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] + " " ) ; freq [ str [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] = 0 ; } } }
Ref: 
void printCharWithFreq ( string str ) { int n = str . size ( ) ; int freq [ SIZE ] ; memset ( freq , 0 , sizeof ( freq ) ) ; for ( int i = 0 ; i < n ; i ++ ) freq [ str [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < n ; i ++ ) { if ( freq [ str [ i ] - ' a ' ] != 0 ) { cout << str [ i ] << freq [ str [ i ] - ' a ' ] << " ▁ " ; freq [ str [ i ] - ' a ' ] = 0 ; } } }
Hyp: 
void printCharWithFreq ( string str ) { int n = str . length ( ) ; int freq [ SIZE ] ; for ( int i = 0 ; i < n ; i ++ ) freq [ str [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < n ; i ++ ) { if ( freq [ str [ i ] - ' a ' ] != 0 ) { cout << str [ i ] ; cout << freq [ str [ i ] - ' a ' ] << " ▁ " ; freq [ str [ i ] - ' a ' ] = 0 ; } } }

BLEU: 87.24
Edit Sim: 53


Src: 
function getMinVal ( p , q ) { if ( q % p == 0 ) return p ; return - 1 ; }
Ref: 
int getMinVal ( int p , int q ) { if ( q % p == 0 ) return p ; return -1 ; }
Hyp: 
int getMinVal ( int p , int q ) { if ( q % p == 0 ) return p ; return -1 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function sum ( n ) { if ( n == 1 ) return 1 ; else return ( Math . pow ( n , n ) + sum ( n - 1 ) ) ; }
Ref: 
ll sum ( int n ) { if ( n == 1 ) return 1 ; else return ( ( ll ) pow ( n , n ) + sum ( n - 1 ) ) ; }
Hyp: 
int sum ( int n ) { if ( n == 1 ) return 1 ; else return ( pow ( n , n ) + sum ( n - 1 ) ) ; }

BLEU: 84.97
Edit Sim: 10


Src: 
function findDiagonal ( s ) { return Math . sqrt ( 2 ) * s ; }
Ref: 
double findDiagonal ( double s ) { return sqrt ( 2 ) * s ; }
Hyp: 
double findDiagonal ( double s ) { return sqrt ( 2 ) * s ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findCount ( mat , i , j , m ) { if ( i == 0 && j == 0 ) { if ( m == mat [ 0 ] [ 0 ] ) return 1 ; else return 0 ; } if ( m < 0 ) return 0 ; if ( i < 0 j < 0 ) return 0 ; if ( v [ i ] [ j ] [ m ] ) return dp [ i ] [ j ] [ m ] ; v [ i ] [ j ] [ m ] = true ; dp [ i ] [ j ] [ m ] = findCount ( mat , i - 1 , j , m - mat [ i ] [ j ] ) + findCount ( mat , i , j - 1 , m - mat [ i ] [ j ] ) ; return dp [ i ] [ j ] [ m ] ; }
Ref: 
int findCount ( int mat [ ] [ n ] , int i , int j , int m ) { if ( i == 0 && j == 0 ) { if ( m == mat [ 0 ] [ 0 ] ) return 1 ; else return 0 ; } if ( m < 0 ) return 0 ; if ( i < 0 j < 0 ) return 0 ; if ( v [ i ] [ j ] [ m ] ) return dp [ i ] [ j ] [ m ] ; v [ i ] [ j ] [ m ] = true ; dp [ i ] [ j ] [ m ] = findCount ( mat , i - 1 , j , m - mat [ i ] [ j ] ) + findCount ( mat , i , j - 1 , m - mat [ i ] [ j ] ) ; return dp [ i ] [ j ] [ m ] ; }
Hyp: 
int findCount ( int mat [ ] [ 2 ] , int i , int j , int m ) { if ( i == 0 && j == 0 ) { if ( m == mat [ 0 ] [ 0 ] ) return 1 ; else return 0 ; } if ( m < 0 ) return 0 ; if ( i < 0 j < 0 ) return 0 ; if ( v [ i ] [ j ] [ m ] ) return dp [ i ] [ j ] [ m ] ; v [ i ] [ j ] [ m ] = true ; dp [ i ] [ j ] [ m ] = findCount ( mat , i - 1 , j , m - mat [ i ] [ j ] ) + findCount ( mat , i , j - 1 , m - mat [ i ] [ j ] ) ; return dp [ i ] [ j ] [ m ] ; }

BLEU: 98.58
Edit Sim: 1


Src: 
function maxLenSubStr ( s ) { if ( s . length < 3 ) return s . length ; let temp = 2 ; let ans = 2 ; for ( let i = 2 ; i < s . length ; i ++ ) { if ( s [ i ] != s [ i - 1 ] s [ i ] != s [ i - 2 ] ) temp ++ ; else { ans = Math . max ( temp , ans ) ; temp = 2 ; } } ans = Math . max ( temp , ans ) ; return ans ; }
Ref: 
int maxLenSubStr ( string & s ) { if ( s . length ( ) < 3 ) return s . length ( ) ; int temp = 2 ; int ans = 2 ; for ( int i = 2 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] != s [ i - 1 ] s [ i ] != s [ i - 2 ] ) temp ++ ; else { ans = max ( temp , ans ) ; temp = 2 ; } } ans = max ( temp , ans ) ; return ans ; }
Hyp: 
int maxLenSubStr ( string s ) { if ( s . length ( ) < 3 ) return s . length ( ) ; int temp = 2 ; int ans = 2 ; for ( int i = 2 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] != s [ i - 1 ] s [ i ] != s [ i - 2 ] ) temp ++ ; else { ans = max ( temp , ans ) ; temp = 2 ; } } ans = max ( temp , ans ) ; return ans ; }

BLEU: 97.74
Edit Sim: 2


Src: 
function KvisibleFromLeft ( N , K ) { if ( N == K ) return 1 ; if ( K == 1 ) { let ans = 1 ; for ( let i = 1 ; i < N ; i ++ ) ans *= i ; return ans ; } return KvisibleFromLeft ( N - 1 , K - 1 ) + ( N - 1 ) * KvisibleFromLeft ( N - 1 , K ) ; }
Ref: 
int KvisibleFromLeft ( int N , int K ) { if ( N == K ) return 1 ; if ( K == 1 ) { int ans = 1 ; for ( int i = 1 ; i < N ; i ++ ) ans *= i ; return ans ; } return KvisibleFromLeft ( N - 1 , K - 1 ) + ( N - 1 ) * KvisibleFromLeft ( N - 1 , K ) ; }
Hyp: 
int KvisibleFromLeft ( int N , int K ) { if ( N == K ) return 1 ; if ( K == 1 ) { int ans = 1 ; for ( int i = 1 ; i < N ; i ++ ) ans *= i ; return ans ; } return KvisibleFromLeft ( N - 1 , K - 1 ) + ( N - 1 ) * KvisibleFromLeft ( N - 1 , K ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function checkConcurrent ( a1 , b1 , c1 , a2 , b2 , c2 , a3 , b3 , c3 ) { return ( a3 * ( b1 * c2 - b2 * c1 ) + b3 * ( c1 * a2 - c2 * a1 ) + c3 * ( a1 * b2 - a2 * b1 ) == 0 ) ; }
Ref: 
bool checkConcurrent ( int a1 , int b1 , int c1 , int a2 , int b2 , int c2 , int a3 , int b3 , int c3 ) { return ( a3 * ( b1 * c2 - b2 * c1 ) + b3 * ( c1 * a2 - c2 * a1 ) + c3 * ( a1 * b2 - a2 * b1 ) == 0 ) ; }
Hyp: 
bool checkConcurrent ( int a1 , int b1 , int c1 , int a2 , int b2 , int c2 , int a3 , int b3 , int c3 ) { return ( a3 * ( b1 * c2 - b2 * c1 ) + b3 * ( c1 * a2 - c2 * a1 ) + c3 * ( a1 * b2 - a2 * b1 ) == 0 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function check ( arr , n ) { var hm = new Map ( ) ; for ( var i = 0 ; i < n ; i ++ ) { hm . set ( arr [ i ] , 1 ) ; for ( var j = i + 1 ; j < n ; j ++ ) { if ( hm . has ( arr [ j ] ) ) hm . set ( arr [ j ] , hm . get ( arr [ j ] ) + 1 ) ; else hm . set ( arr [ j ] , 1 ) var flag = false ; hm . forEach ( ( value , key ) => { if ( value == 1 ) { flag = true ; } } ) ; if ( ! flag ) return " " ; } hm = new Map ( ) ; } return " " ; }
Ref: 
string check ( int arr [ ] , int n ) { map < int , int > hm ; for ( int i = 0 ; i < n ; i ++ ) { hm [ arr [ i ] ] = 1 ; for ( int j = i + 1 ; j < n ; j ++ ) { hm [ arr [ j ] ] ++ ; bool flag = false ; for ( auto x : hm ) { if ( x . second == 1 ) { flag = true ; break ; } } if ( ! flag ) return " No " ; } hm . clear ( ) ; } return " Yes " ; }
Hyp: 
string check ( int arr [ ] , int n ) { unordered_map < int , int > hm ; for ( int i = 0 ; i < n ; i ++ ) { hm [ arr [ i ] ] ++ ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( hm . find ( arr [ j ] ) != hm . end ( ) ) hm [ arr [ j ] ] ++ ; else hm [ arr [ j ] ] = 1 ; } hm . clear ( ) ; } return " Yes " ; }

BLEU: 65.61
Edit Sim: 113


Src: 
function summation ( n ) { let sum ; sum = ( Math . pow ( 10 , n + 1 ) - 10 - ( 9 * n ) ) / 81 ; return sum ; }
Ref: 
int summation ( int n ) { int sum ; sum = ( pow ( 10 , n + 1 ) - 10 - ( 9 * n ) ) / 81 ; return sum ; }
Hyp: 
double summation ( int n ) { double sum ; sum = ( pow ( 10 , n + 1 ) - 10 - ( 9 * n ) ) / 81 ; return sum ; }

BLEU: 90.25
Edit Sim: 12


Src: 
function nthTerm ( n ) { return 2 * Math . pow ( n , 2 ) + 4 * n - 2 ; }
Ref: 
int nthTerm ( int n ) { return 2 * pow ( n , 2 ) + 4 * n - 2 ; }
Hyp: 
int nthTerm ( int n ) { return 2 * pow ( n , 2 ) + 4 * n - 2 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function angle ( R1 , R2 , D ) { var ans = ( R1 * R1 + R2 * R2 - D * D ) / ( 2 * R1 * R2 ) ; return ans ; }
Ref: 
float angle ( float R1 , float R2 , float D ) { float ans = ( R1 * R1 + R2 * R2 - D * D ) / ( 2 * R1 * R2 ) ; return ans ; }
Hyp: 
int angle ( int R1 , int R2 , int D ) { int ans = ( R1 * R1 + R2 * R2 - D * D ) / ( 2 * R1 * R2 ) ; return ans ; }

BLEU: 74.51
Edit Sim: 20


Src: 
function CountPairs ( n ) { let k = n ; let imin = 1 ; let ans = 0 ; while ( imin <= n ) { let imax = Math . floor ( n / k ) ; ans += k * ( imax - imin + 1 ) ; imin = imax + 1 ; k = Math . floor ( n / imin ) ; } return ans ; }
Ref: 
int CountPairs ( int n ) { int k = n ; int imin = 1 ; int ans = 0 ; while ( imin <= n ) { int imax = n / k ; ans += k * ( imax - imin + 1 ) ; imin = imax + 1 ; k = n / imin ; } return ans ; }
Hyp: 
int CountPairs ( int n ) { int k = n ; int imin = 1 ; int ans = 0 ; while ( imin <= n ) { int imax = n / k ; ans += k * ( imax - imin + 1 ) ; imin = imax + 1 ; k = n / imin ; } return ans ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function minimum_required_operations ( arr , n , k ) { let answer = 0 ; let mod = 1000000007 ; for ( let i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] + arr [ i + 1 ] > k ) { if ( arr [ i ] > k ) { answer += ( arr [ i ] - k ) ; arr [ i ] = k ; } answer += ( arr [ i ] + arr [ i + 1 ] ) - k ; arr [ i + 1 ] = ( k - arr [ i ] ) ; answer %= mod ; } } return answer ; }
Ref: 
int minimum_required_operations ( int arr [ ] , int n , int k ) { int answer = 0 ; long long mod = 1000000007 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] + arr [ i + 1 ] > k ) { if ( arr [ i ] > k ) { answer += ( arr [ i ] - k ) ; arr [ i ] = k ; } answer += ( arr [ i ] + arr [ i + 1 ] ) - k ; arr [ i + 1 ] = ( k - arr [ i ] ) ; answer %= mod ; } } return answer ; }
Hyp: 
int minimum_required_operations ( int arr [ ] , int n , int k ) { int answer = 0 ; int mod = 1000000007 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] + arr [ i + 1 ] > k ) { if ( arr [ i ] > k ) { answer += ( arr [ i ] - k ) ; arr [ i ] = k ; } answer += ( arr [ i ] + arr [ i + 1 ] ) - k ; arr [ i + 1 ] = ( k - arr [ i ] ) ; answer %= mod ; } } return answer ; }

BLEU: 97.35
Edit Sim: 8


Src: 
function getTotalXorOfSubarrayXors ( arr , N ) { let res = 0 ; for ( let i = 0 ; i < N ; i ++ ) { let freq = ( i + 1 ) * ( N - i ) ; if ( freq % 2 == 1 ) res = res ^ arr [ i ] ; } return res ; }
Ref: 
int getTotalXorOfSubarrayXors ( int arr [ ] , int N ) { int res = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int freq = ( i + 1 ) * ( N - i ) ; if ( freq % 2 == 1 ) res = res ^ arr [ i ] ; } return res ; }
Hyp: 
int getTotalXorOfSubarrayXors ( int arr [ ] , int N ) { int res = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int freq = ( i + 1 ) * ( N - i ) ; if ( freq % 2 == 1 ) res = res ^ arr [ i ] ; } return res ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function allBitsSetInTheGivenRange ( n , l , r ) { var num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ; var new_num = n & num ; if ( num == new_num ) return " " ; return " " ; }
Ref: 
string allBitsSetInTheGivenRange ( unsigned int n , unsigned int l , unsigned int r ) { int num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ; int new_num = n & num ; if ( num == new_num ) return " Yes " ; return " No " ; }
Hyp: 
string allBitsSetInTheGivenRange ( int n , int l , int r ) { int num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ; int new_num = n & num ; if ( num == new_num ) return " Yes " ; return " No " ; }

BLEU: 88.42
Edit Sim: 27


Src: 
function String_palindrome ( N , K ) { for ( let i = 0 ; i < K ; i ++ ) document . write ( " " ) ; let s = " " ; for ( let i = 0 ; i < N - K ; i ++ ) document . write ( s [ i % 3 ] ) ; }
Ref: 
void string_palindrome ( int N , int K ) { for ( int i = 0 ; i < K ; i ++ ) cout << " a " ; string s = " bcd " ; for ( int i = 0 ; i < N - K ; i ++ ) cout << s [ i % 3 ] ; }
Hyp: 
void String_palindrome ( int N , int K ) { for ( int i = 0 ; i < K ; i ++ ) cout << " ▁ " ; string s = " ▁ " ; for ( int i = 0 ; i < N - K ; i ++ ) cout << s [ i % 3 ] ; }

BLEU: 89.02
Edit Sim: 5


Src: 
function findMax ( arr , n ) { var res = 0 ; var i , j ; for ( i = 0 ; i < n ; i ++ ) { var count = 0 ; for ( j = 0 ; j < i ; j ++ ) { if ( arr [ j ] % arr [ i ] == 0 ) count += 1 ; } res = Math . max ( count , res ) ; } return res ; }
Ref: 
int findMax ( int arr [ ] , int n ) { int res = 0 ; int i , j ; for ( i = 0 ; i < n ; i ++ ) { int count = 0 ; for ( j = 0 ; j < i ; j ++ ) { if ( arr [ j ] % arr [ i ] == 0 ) count += 1 ; } res = max ( count , res ) ; } return res ; }
Hyp: 
int findMax ( int arr [ ] , int n ) { int res = 0 ; int i , j ; for ( i = 0 ; i < n ; i ++ ) { int count = 0 ; for ( j = 0 ; j < i ; j ++ ) { if ( arr [ j ] % arr [ i ] == 0 ) count += 1 ; } res = max ( count , res ) ; } return res ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function repeatingElement ( arr , N ) { let M = 0 , sum = 0 ; for ( let i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; M = Math . max ( M , arr [ i ] ) ; } let sum1 = parseInt ( M * ( M + 1 ) / 2 ) ; let ans = parseInt ( ( sum - sum1 ) / ( N - M ) ) ; return ans ; }
Ref: 
int repeatingElement ( int arr [ ] , int N ) { int M = 0 , sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; M = max ( M , arr [ i ] ) ; } int sum1 = M * ( M + 1 ) / 2 ; int ans = ( sum - sum1 ) / ( N - M ) ; return ans ; }
Hyp: 
int repeatingElement ( int arr [ ] , int N ) { int M = 0 , sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; M = max ( M , arr [ i ] ) ; } int sum1 = M * ( M + 1 ) / 2 ; int ans = ( sum - sum1 ) / ( N - M ) ; return ans ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findLCM ( a , b ) { var lar = Math . max ( a , b ) ; var small = Math . min ( a , b ) ; for ( i = lar ; ; i += lar ) { if ( i % small == 0 ) return i ; } }
Ref: 
int findLCM ( int a , int b ) { int lar = max ( a , b ) ; int small = min ( a , b ) ; for ( int i = lar ; ; i += lar ) { if ( i % small == 0 ) return i ; } }
Hyp: 
int findLCM ( int a , int b ) { int lar = max ( a , b ) ; int small = min ( a , b ) ; for ( int i = lar ; ; i += lar ) { if ( i % small == 0 ) return i ; } }

BLEU: 100.0
Edit Sim: 0


Src: 
function sum ( n ) { let i , s = 0.0 ; for ( i = 1 ; i <= n ; i ++ ) s = s + 1 / i ; return s ; }
Ref: 
double sum ( int n ) { double i , s = 0.0 ; for ( i = 1 ; i <= n ; i ++ ) s = s + 1 / i ; return s ; }
Hyp: 
double sum ( int n ) { int i , s = 0.0 ; for ( i = 1 ; i <= n ; i ++ ) s = s + 1 / i ; return s ; }

BLEU: 93.37
Edit Sim: 6


Src: 
function checkType ( arr , n ) { if ( arr [ 0 ] <= arr [ 1 ] && arr [ n - 2 ] <= arr [ n - 1 ] ) document . write ( " " ) ; else if ( arr [ 0 ] >= arr [ 1 ] && arr [ n - 2 ] >= arr [ n - 1 ] ) document . write ( " " ) ; else if ( arr [ 0 ] <= arr [ 1 ] && arr [ n - 2 ] >= arr [ n - 1 ] ) document . write ( " " ) ; else document . write ( " " ) ; }
Ref: 
void checkType ( int arr [ ] , int n ) { if ( arr [ 0 ] <= arr [ 1 ] && arr [ n - 2 ] <= arr [ n - 1 ] ) cout << " Increasing " ; else if ( arr [ 0 ] >= arr [ 1 ] && arr [ n - 2 ] >= arr [ n - 1 ] ) cout << " Decreasing " ; else if ( arr [ 0 ] <= arr [ 1 ] && arr [ n - 2 ] >= arr [ n - 1 ] ) cout << " Increasing ▁ then ▁ decreasing " ; else cout << " Decreasing ▁ then ▁ increasing " ; }
Hyp: 
void checkType ( int arr [ ] , int n ) { if ( arr [ 0 ] <= arr [ 1 ] && arr [ n - 2 ] <= arr [ n - 1 ] ) cout << " YES " ; else if ( arr [ 0 ] >= arr [ 1 ] && arr [ n - 2 ] >= arr [ n - 1 ] ) cout << " YES " ; else if ( arr [ 0 ] <= arr [ 1 ] && arr [ n - 2 ] >= arr [ n - 1 ] ) cout << " NO " ; else if ( arr [ 0 ] >= arr [ 1 ] && arr [ n - 2 ] >= arr [ n - 1 ] ) cout << " YES " ; else cout << " NO " ; }

BLEU: 71.33
Edit Sim: 109


Src: 
function numberOfPairs ( n ) { if ( n % 2 == 0 ) return ( n / 2 - 1 ) ; else return ( n / 2 ) ; }
Ref: 
int numberOfPairs ( int n ) { if ( n % 2 == 0 ) return n / 2 - 1 ; else return n / 2 ; }
Hyp: 
int numberOfPairs ( int n ) { if ( n % 2 == 0 ) return ( n / 2 - 1 ) ; else return ( n / 2 ) ; }

BLEU: 68.14
Edit Sim: 8


Src: 
function solve ( X , Y ) { if ( X > Y ) { let temp = X ; X = Y ; Y = temp ; } if ( X == Y ) document . write ( 0 ) ; else if ( Y % X == 0 ) document . write ( 1 ) ; else document . write ( 2 ) ; }
Ref: 
int solve ( int X , int Y ) { if ( X > Y ) { int temp = X ; X = Y ; Y = temp ; } if ( X == Y ) cout << 0 << endl ; else if ( Y % X == 0 ) cout << 1 << endl ; else cout << 2 << endl ; }
Hyp: 
void solve ( int X , int Y ) { if ( X > Y ) { int temp = X ; X = Y ; Y = temp ; } if ( X == Y ) cout << 0 ; else if ( Y % X == 0 ) cout << 1 ; else cout << 2 ; }

BLEU: 82.27
Edit Sim: 28


Src: 
function isPossible ( A , B , N , K , L ) { let needa , needb ; if ( A % K == 0 ) needa = Math . floor ( A / K ) ; else needa = Math . floor ( A / K ) + 1 ; if ( B % L == 0 ) needb = Math . floor ( B / L ) ; else needb = Math . floor ( B / L ) + 1 ; let total = needa + needb ; if ( total > N ) return false ; else return true ; }
Ref: 
bool isPossible ( int A , int B , int N , int K , int L ) { int needa , needb ; if ( A % K == 0 ) needa = A / K ; else needa = A / K + 1 ; if ( B % L == 0 ) needb = B / L ; else needb = B / L + 1 ; int total = needa + needb ; if ( total > N ) return false ; else return true ; }
Hyp: 
bool isPossible ( int A , int B , int N , int K , int L ) { int needa , needb ; if ( A % K == 0 ) needa = floor ( A / K ) ; else needa = floor ( A / K ) + 1 ; if ( B % L == 0 ) needb = floor ( B / L ) ; else needb = floor ( B / L ) + 1 ; int total = needa + needb ; if ( total > N ) return false ; else return true ; }

BLEU: 75.95
Edit Sim: 40


Src: 
function countNumbers ( n ) { let k = 0 ; let count = 0 ; while ( n > 0 ) { if ( ( n & 1 ) == 0 ) count += ( Math . pow ( 2 , k ) ) ; k += 1 ; n >>= 1 ; } return count ; }
Ref: 
int countNumbers ( int n ) { int k = 0 ; while ( n > 0 ) { if ( ( n & 1 ) == 0 ) count += pow ( 2 , k ) ; k += 1 ; n >>= 1 ; } return count ; }
Hyp: 
int countNumbers ( unsigned int n ) { unsigned int k = 0 ; unsigned int count = 0 ; while ( n > 0 ) { if ( n & 1 ) count += ( pow ( 2 , k ) ) ; k += 1 ; n >>= 1 ; } return count ; }

BLEU: 70.33
Edit Sim: 55


Src: 
function printCountDP ( dist ) { let count = new Array ( dist + 1 ) ; count [ 0 ] = 1 ; if ( dist >= 1 ) count [ 1 ] = 1 ; if ( dist >= 2 ) count [ 2 ] = 2 ; for ( let i = 3 ; i <= dist ; i ++ ) count [ i ] = count [ i - 1 ] + count [ i - 2 ] + count [ i - 3 ] ; return count [ dist ] ; }
Ref: 
int printCountDP ( int dist ) { int count [ dist + 1 ] ; count [ 0 ] = 1 ; if ( dist >= 1 ) count [ 1 ] = 1 ; if ( dist >= 2 ) count [ 2 ] = 2 ; for ( int i = 3 ; i <= dist ; i ++ ) count [ i ] = count [ i - 1 ] + count [ i - 2 ] + count [ i - 3 ] ; return count [ dist ] ; }
Hyp: 
int printCountDP ( int dist ) { int count [ dist + 1 ] ; count [ 0 ] = 1 ; if ( dist >= 1 ) count [ 1 ] = 1 ; if ( dist >= 2 ) count [ 2 ] = 2 ; for ( int i = 3 ; i <= dist ; i ++ ) count [ i ] = count [ i - 1 ] + count [ i - 2 ] + count [ i - 3 ] ; return count [ dist ] ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function usingBinarySearch ( start , end , N , S ) { if ( start >= end ) return start ; let mid = start + ( end - start ) / 2 ; let totalSum = ( N * ( N + 1 ) ) / 2 ; let midSum = ( mid * ( mid + 1 ) ) / 2 ; if ( ( totalSum - midSum ) <= S ) { return usingBinarySearch ( start , mid , N , S ) ; } return usingBinarySearch ( mid + 1 , end , N , S ) ; }
Ref: 
int usingBinarySearch ( int start , int end , int N , int S ) { if ( start >= end ) return start ; int mid = start + ( end - start ) / 2 ; int totalSum = ( N * ( N + 1 ) ) / 2 ; int midSum = ( mid * ( mid + 1 ) ) / 2 ; if ( ( totalSum - midSum ) <= S ) { return usingBinarySearch ( start , mid , N , S ) ; } return usingBinarySearch ( mid + 1 , end , N , S ) ; }
Hyp: 
int usingBinarySearch ( int start , int end , int N , int S ) { if ( start >= end ) return start ; int mid = start + ( end - start ) / 2 ; int totalSum = ( N * ( N + 1 ) ) / 2 ; int midSum = ( mid * ( mid + 1 ) ) / 2 ; if ( ( totalSum - midSum ) <= S ) { return usingBinarySearch ( start , mid , N , S ) ; } return usingBinarySearch ( mid + 1 , end , N , S ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countSubarrays ( a , n , k ) { var ans = 0 ; var pref = [ ] ; pref . push ( 0 ) ; for ( var i = 0 ; i < n ; i ++ ) pref . push ( ( a [ i ] + pref [ i ] ) % k ) ; for ( var i = 1 ; i <= n ; i ++ ) { for ( var j = i ; j <= n ; j ++ ) { if ( ( pref [ j ] - pref [ i - 1 ] + k ) % k == j - i + 1 ) { ans ++ ; } } } document . write ( ans + ' ' ) ; }
Ref: 
int countSubarrays ( int a [ ] , int n , int k ) { int ans = 0 ; vector < int > pref ; pref . push_back ( 0 ) ; for ( int i = 0 ; i < n ; i ++ ) pref . push_back ( ( a [ i ] + pref [ i ] ) % k ) ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = i ; j <= n ; j ++ ) { if ( ( pref [ j ] - pref [ i - 1 ] + k ) % k == j - i + 1 ) { ans ++ ; } } } cout << ans << ' ▁ ' ; }
Hyp: 
int countSubarrays ( int a [ ] , int n , int k ) { int ans = 0 ; vector < int > pref ; pref . push_back ( 0 ) ; for ( int i = 0 ; i < n ; i ++ ) pref . push_back ( ( a [ i ] + pref [ i ] ) % k ) ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = i ; j <= n ; j ++ ) { if ( ( pref [ j ] - pref [ i - 1 ] + k ) % k == j - i + 1 ) { ans ++ ; } } } cout << ans << ' ▁ ' ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countSegments ( a , n , x ) { let flag = false ; let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] > x ) { flag = true ; } else { if ( flag ) count += 1 ; flag = false ; } } if ( flag ) count += 1 ; return count ; }
Ref: 
int countSegments ( int a [ ] , int n , int x ) { bool flag = false ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > x ) { flag = true ; } else { if ( flag ) count += 1 ; flag = false ; } } if ( flag ) count += 1 ; return count ; }
Hyp: 
int countSegments ( int a [ ] , int n , int x ) { bool flag = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > x ) { flag = 1 ; } else { if ( flag ) count += 1 ; flag = false ; } } if ( flag ) count += 1 ; return count ; }

BLEU: 93.86
Edit Sim: 9


Src: 
function minCost ( coin , n , k ) { coin . sort ( function ( a , b ) { return a - b } ) var coins_needed = Math . ceil ( n / ( k + 1 ) ) ; var ans = 0 ; for ( var i = 0 ; i <= coins_needed - 1 ; i ++ ) ans += coin [ i ] ; return ans ; }
Ref: 
int minCost ( int coin [ ] , int n , int k ) { sort ( coin , coin + n ) ; int coins_needed = ceil ( 1.0 * n / ( k + 1 ) ) ; int ans = 0 ; for ( int i = 0 ; i <= coins_needed - 1 ; i ++ ) ans += coin [ i ] ; return ans ; }
Hyp: 
int minCost ( int coin [ ] , int n , int k ) { sort ( coin , coin + n ) ; int coins_needed = ceil ( n / ( k + 1 ) ) ; int ans = 0 ; for ( int i = 0 ; i <= coins_needed - 1 ; i ++ ) ans += coin [ i ] ; return ans ; }

BLEU: 95.05
Edit Sim: 6


Src: 
function findMajority ( arr , n ) { return arr [ Math . floor ( n / 2 ) ] ; }
Ref: 
int findMajority ( int arr [ ] , int n ) { return arr [ n / 2 ] ; }
Hyp: 
int findMajority ( int arr [ ] , int n ) { return arr [ n / 2 ] ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function checkExists ( arr , N , M , K ) { let count = 0 ; for ( let i = 0 ; i < N - M ; i ++ ) { if ( arr [ i ] == arr [ i + M ] ) count ++ ; else count = 0 ; if ( count == M * ( K - 1 ) ) return true ; } return false ; } let arr = [ 2 , 1 , 2 , 1 , 1 , 1 , 3 ] ; let N = arr . length ; let M = 2 , K = 2 ; if ( checkExists ( arr , N , M , K ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
Ref: 
bool checkExists ( int arr [ ] , int N , int M , int K ) { int count = 0 ; for ( int i = 0 ; i < N - M ; i ++ ) { if ( arr [ i ] == arr [ i + M ] ) count ++ ; else count = 0 ; if ( count == M * ( K - 1 ) ) return true ; } return false ; }
Hyp: 
bool checkExists ( int arr [ ] , int N , int M , int K ) { int count = 0 ; for ( int i = 0 ; i < N - M ; i ++ ) { if ( arr [ i ] == arr [ i + M ] ) count ++ ; else count = 0 ; if ( count == M * ( K - 1 ) ) return true ; } return false ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function calculate ( ar , size ) { var count = 0 ; for ( i = 0 ; i < size ; i ++ ) if ( ar [ i ] % 2 == 0 && ar [ i ] != 0 && ar [ i ] != 2 ) count ++ ; return count ; }
Ref: 
int calculate ( int * array , int size ) { int count = 0 ; for ( int i = 0 ; i < size ; i ++ ) if ( array [ i ] % 2 == 0 && array [ i ] != 0 && array [ i ] != 2 ) count ++ ; return count ; }
Hyp: 
int calculate ( int ar [ ] , int size ) { int count = 0 ; for ( int i = 0 ; i < size ; i ++ ) if ( ar [ i ] % 2 == 0 && ar [ i ] != 0 && ar [ i ] != 2 ) count ++ ; return count ; }

BLEU: 80.31
Edit Sim: 15


Src: 
function canBeEmptied ( A , B ) { if ( Math . max ( A , B ) > 2 * Math . min ( A , B ) ) { document . write ( " " ) ; return ; } if ( ( A + B ) % 3 == 0 ) document . write ( " " ) ; else document . write ( " " ) ; }
Ref: 
void canBeEmptied ( int A , int B ) { if ( max ( A , B ) > 2 * min ( A , B ) ) { cout << " No " ; return ; } if ( ( A + B ) % 3 == 0 ) cout << " Yes " ; else cout << " No " ; }
Hyp: 
void canBeEmptied ( int A , int B ) { if ( max ( A , B ) > 2 * min ( A , B ) ) { cout << " No " ; return ; } if ( ( A + B ) % 3 == 0 ) cout << " Yes " ; else cout << " No " ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countNumEnds ( A , L , R ) { let temp = 0 , count = 0 , digits = 0 ; let cycle = 0 ; digits = Math . round ( Math . log10 ( A ) ) + 1 ; temp = Math . round ( Math . pow ( 10 , digits ) ) ; cycle = temp ; while ( temp <= R ) { if ( temp >= L ) count ++ ; temp += cycle ; } document . write ( count ) ; }
Ref: 
void countNumEnds ( int A , int L , int R ) { int temp , count = 0 , digits ; int cycle ; digits = log10 ( A ) + 1 ; temp = pow ( 10 , digits ) ; cycle = temp ; while ( temp <= R ) { if ( temp >= L ) count ++ ; temp += cycle ; } cout << count ; }
Hyp: 
void countNumEnds ( int A , int L , int R ) { int temp = 0 , count = 0 , digits = 0 ; int cycle = 0 ; digits = log10 ( A ) + 1 ; temp = round ( pow ( 10 , digits ) ) ; cycle = temp ; while ( temp <= R ) { if ( temp >= L ) count ++ ; temp += cycle ; } cout << count << endl ; }

BLEU: 76.77
Edit Sim: 30


Src: 
function findIndex ( n ) { if ( n <= 1 ) return n ; let a = 0 , b = 1 , c = 1 ; let res = 1 ; while ( c < n ) { c = a + b ; res ++ ; a = b ; b = c ; } return res ; }
Ref: 
int findIndex ( int n ) { if ( n <= 1 ) return n ; int a = 0 , b = 1 , c = 1 ; int res = 1 ; while ( c < n ) { c = a + b ; res ++ ; a = b ; b = c ; } return res ; }
Hyp: 
int findIndex ( int n ) { if ( n <= 1 ) return n ; int a = 0 , b = 1 , c = 1 ; int res = 1 ; while ( c < n ) { c = a + b ; res ++ ; a = b ; b = c ; } return res ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function minCost ( cost , n ) { let dp = new Array ( n + 1 ) ; dp [ 0 ] = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { let min_cost = Number . MAX_VALUE ; for ( let j = 0 ; j < i ; j ++ ) if ( j < n ) min_cost = Math . min ( min_cost , cost [ j ] + dp [ i - j - 1 ] ) ; dp [ i ] = min_cost ; } return dp [ n ] ; }
Ref: 
int minCost ( int cost [ ] , int n ) { int dp [ n + 1 ] ; dp [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int min_cost = INT_MAX ; for ( int j = 0 ; j < i ; j ++ ) if ( j < n && cost [ j ] != -1 ) min_cost = min ( min_cost , cost [ j ] + dp [ i - j - 1 ] ) ; dp [ i ] = min_cost ; } return dp [ n ] ; }
Hyp: 
int minCost ( int * cost , int n ) { int dp [ n + 1 ] ; dp [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int min_cost = INT_MAX ; for ( int j = 0 ; j < i ; j ++ ) if ( j < n ) min_cost = min ( min_cost , cost [ j ] + dp [ i - j - 1 ] ) ; dp [ i ] = min_cost ; } return dp [ n ] ; }

BLEU: 88.07
Edit Sim: 26


Src: 
function findSum ( n ) { return n * ( n + 1 ) / 2 ; }
Ref: 
int findSum ( int n ) { return n * ( n + 1 ) / 2 ; }
Hyp: 
int findSum ( int n ) { return n * ( n + 1 ) / 2 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function divParts ( N ) { if ( N % 2 == 0 ) document . write ( ( N / 2 ) - 1 ) ; else document . write ( ( N / 2 ) ) ; }
Ref: 
int divParts ( int N ) { if ( N % 2 == 0 ) cout << ( N / 2 ) - 1 << endl ; else cout << N / 2 << endl ; }
Hyp: 
void divParts ( int N ) { if ( N % 2 == 0 ) cout << ( N / 2 ) - 1 ; else cout << ( N / 2 ) ; }

BLEU: 73.78
Edit Sim: 21


Src: 
function maxSheets ( A , B ) { let area = A * B ; let count = 1 ; while ( area % 2 == 0 ) { area /= 2 ; count *= 2 ; } return count ; }
Ref: 
int maxSheets ( int A , int B ) { int area = A * B ; int count = 1 ; while ( area % 2 == 0 ) { area /= 2 ; count *= 2 ; } return count ; }
Hyp: 
int maxSheets ( int A , int B ) { int area = A * B ; int count = 1 ; while ( area % 2 == 0 ) { area /= 2 ; count *= 2 ; } return count ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countDigit ( n ) { if ( n / 10 == 0 ) return 1 ; return 1 + countDigit ( parseInt ( n / 10 ) ) ; }
Ref: 
int countDigit ( long long n ) { if ( n / 10 == 0 ) return 1 ; return 1 + countDigit ( n / 10 ) ; }
Hyp: 
int countDigit ( int n ) { if ( n / 10 == 0 ) return 1 ; return 1 + countDigit ( n / 10 ) ; }

BLEU: 87.88
Edit Sim: 8


Src: 
function eulerian ( n , m ) { if ( m >= n n == 0 ) return 0 ; if ( m == 0 ) return 1 ; return ( n - m ) * eulerian ( n - 1 , m - 1 ) + ( m + 1 ) * eulerian ( n - 1 , m ) ; }
Ref: 
int eulerian ( int n , int m ) { if ( m >= n n == 0 ) return 0 ; if ( m == 0 ) return 1 ; return ( n - m ) * eulerian ( n - 1 , m - 1 ) + ( m + 1 ) * eulerian ( n - 1 , m ) ; }
Hyp: 
int eulerian ( int n , int m ) { if ( m >= n n == 0 ) return 0 ; if ( m == 0 ) return 1 ; return ( n - m ) * eulerian ( n - 1 , m - 1 ) + ( m + 1 ) * eulerian ( n - 1 , m ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function octacontagonNum ( n ) { return ( 78 * n * n - 76 * n ) / 2 ; }
Ref: 
int octacontagonNum ( int n ) { return ( 78 * n * n - 76 * n ) / 2 ; }
Hyp: 
int octacontagonNum ( int n ) { return ( 78 * n * n - 76 * n ) / 2 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findLen ( arr , i , curr , n , m ) { if ( i == n ) { if ( curr == m ) return 0 ; else return - 1 ; } if ( v [ i ] [ curr ] ) return dp [ i ] [ curr ] ; v [ i ] [ curr ] = 1 ; var l = findLen ( arr , i + 1 , curr , n , m ) ; var r = findLen ( arr , i + 1 , curr arr [ i ] , n , m ) ; dp [ i ] [ curr ] = l ; if ( r != - 1 ) dp [ i ] [ curr ] = Math . max ( dp [ i ] [ curr ] , r + 1 ) ; return dp [ i ] [ curr ] ; }
Ref: 
int findLen ( int * arr , int i , int curr , int n , int m ) { if ( i == n ) { if ( curr == m ) return 0 ; else return -1 ; } if ( v [ i ] [ curr ] ) return dp [ i ] [ curr ] ; v [ i ] [ curr ] = 1 ; int l = findLen ( arr , i + 1 , curr , n , m ) ; int r = findLen ( arr , i + 1 , curr arr [ i ] , n , m ) ; dp [ i ] [ curr ] = l ; if ( r != -1 ) dp [ i ] [ curr ] = max ( dp [ i ] [ curr ] , r + 1 ) ; return dp [ i ] [ curr ] ; }
Hyp: 
int findLen ( int * arr , int i , int curr , int n , int m ) { if ( i == n ) { if ( curr == m ) return 0 ; else return -1 ; } if ( v [ i ] [ curr ] ) return dp [ i ] [ curr ] ; v [ i ] [ curr ] = 1 ; int l = findLen ( arr , i + 1 , curr , n , m ) ; int r = findLen ( arr , i + 1 , curr arr [ i ] , n , m ) ; dp [ i ] [ curr ] = l ; if ( r != -1 ) dp [ i ] [ curr ] = max ( dp [ i ] [ curr ] , r + 1 ) ; return dp [ i ] [ curr ] ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function maxSubsequences ( arr , n ) { let map = new Map ( ) ; let maxCount = 0 ; let count ; for ( let i = 0 ; i < n ; i ++ ) { if ( map . has ( arr [ i ] ) ) { count = map [ arr [ i ] ] ; if ( count > 1 ) { map . add ( arr [ i ] , count - 1 ) ; } else map . delete ( arr [ i ] ) ; if ( arr [ i ] - 1 > 0 ) if ( map . has ( arr [ i ] - 1 ) ) map [ arr [ i ] - 1 ] ++ ; else map . set ( arr [ i ] - 1 , 1 ) ; } else { maxCount ++ ; if ( arr [ i ] - 1 > 0 ) if ( map . has ( arr [ i ] - 1 ) ) map [ arr [ i ] - 1 ] ++ ; else map . set ( arr [ i ] - 1 , 1 ) ; } } return maxCount ; }
Ref: 
int maxSubsequences ( int arr [ ] , int n ) { unordered_map < int , int > m ; int maxCount = 0 ; int count ; for ( int i = 0 ; i < n ; i ++ ) { if ( m . find ( arr [ i ] ) != m . end ( ) ) { count = m [ arr [ i ] ] ; if ( count > 1 ) { m [ arr [ i ] ] = count - 1 ; } else m . erase ( arr [ i ] ) ; if ( arr [ i ] - 1 > 0 ) m [ arr [ i ] - 1 ] += 1 ; } else { maxCount ++ ; if ( arr [ i ] - 1 > 0 ) m [ arr [ i ] - 1 ] += 1 ; } } return maxCount ; }
Hyp: 
int maxSubsequences ( int arr [ ] , int n ) { unordered_map < int , int > mp ; int maxCount = 0 ; int count ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . find ( arr [ i ] ) != mp . end ( ) ) { count = mp [ arr [ i ] ] ; if ( count > 1 ) mp [ arr [ i ] ] ++ ; else mp [ arr [ i ] - 1 ] = 1 ; } else { maxCount ++ ; if ( arr [ i ] - 1 > 0 ) if ( mp . find ( arr [ i ] - 1 ) != mp . end ( ) ) mp [ arr [ i ] - 1 ] ++ ; else mp [ arr [ i ] - 1 ] = 1 ; } } return maxCount ; }

BLEU: 71.62
Edit Sim: 99


Src: 
function NumberOfSolutions ( a , b , c , d ) { let ans = 0 ; for ( let i = a ; i <= b ; i ++ ) if ( d >= Math . max ( c , i + 1 ) ) ans += d - Math . max ( c , i + 1 ) + 1 ; return ans ; }
Ref: 
int NumberOfSolutions ( int a , int b , int c , int d ) { int ans = 0 ; for ( int i = a ; i <= b ; i ++ ) if ( d >= max ( c , i + 1 ) ) ans += d - max ( c , i + 1 ) + 1 ; return ans ; }
Hyp: 
int NumberOfSolutions ( int a , int b , int c , int d ) { int ans = 0 ; for ( int i = a ; i <= b ; i ++ ) if ( d >= max ( c , i + 1 ) ) ans += d - max ( c , i + 1 ) + 1 ; return ans ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function MaximumSum ( a , b , n ) { let sum1 = 0 , sum2 = 0 ; for ( let i = 0 ; i < n ; i ++ ) { sum1 |= a [ i ] ; sum2 |= b [ i ] ; } document . write ( sum1 + sum2 ) ; }
Ref: 
void MaximumSum ( int a [ ] , int b [ ] , int n ) { int sum1 = 0 , sum2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum1 |= a [ i ] ; sum2 |= b [ i ] ; } cout << sum1 + sum2 << endl ; }
Hyp: 
void MaximumSum ( int a [ ] , int b [ ] , int n ) { int sum1 = 0 , sum2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum1 |= a [ i ] ; sum2 |= b [ i ] ; } cout << sum1 + sum2 ; }

BLEU: 94.91
Edit Sim: 8


Src: 
function centered_heptagonal_num ( n ) { return parseInt ( ( 7 * n * n - 7 * n + 2 ) / 2 ) ; }
Ref: 
int centered_heptagonal_num ( long int n ) { return ( 7 * n * n - 7 * n + 2 ) / 2 ; }
Hyp: 
int centered_heptagonal_num ( long int n ) { return ( 7 * n * n - 7 * n + 2 ) / 2 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function Nth_Term ( n ) { return ( 3 * Math . pow ( n , 2 ) - n + 2 ) / ( 2 ) ; }
Ref: 
int Nth_Term ( int n ) { return ( 3 * pow ( n , 2 ) - n + 2 ) / ( 2 ) ; }
Hyp: 
int Nth_Term ( int n ) { return ( 3 * pow ( n , 2 ) - n + 2 ) / ( 2 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function CountTriangles ( n ) { var curr = 1 ; var Tri_count = 0 ; for ( i = 1 ; i <= n ; i ++ ) { Tri_count = ( curr * 3 ) + 2 ; curr = Tri_count ; } return Tri_count ; }
Ref: 
int CountTriangles ( int n ) { int curr = 1 ; int Tri_count = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { Tri_count = ( curr * 3 ) + 2 ; curr = Tri_count ; } return Tri_count ; }
Hyp: 
int CountTriangles ( int n ) { int curr = 1 ; int Tri_count = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { Tri_count = ( curr * 3 ) + 2 ; curr = Tri_count ; } return Tri_count ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countPairs ( n ) { let count = 0 ; for ( let x = 1 ; x < n ; x ++ ) { for ( let y = x + 1 ; y <= n ; y ++ ) { if ( ( y * x ) % ( y + x ) == 0 ) count ++ ; } } return count ; }
Ref: 
int countPairs ( int n ) { int count = 0 ; for ( int x = 1 ; x < n ; x ++ ) { for ( int y = x + 1 ; y <= n ; y ++ ) { if ( ( y * x ) % ( y + x ) == 0 ) count ++ ; } } return count ; }
Hyp: 
int countPairs ( int n ) { int count = 0 ; for ( int x = 1 ; x < n ; x ++ ) { for ( int y = x + 1 ; y <= n ; y ++ ) { if ( ( y * x ) % ( y + x ) == 0 ) count ++ ; } } return count ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function No_of_cubes ( N , K ) { let No = 0 ; No = ( N - K + 1 ) ; No = Math . pow ( No , 3 ) ; return No ; }
Ref: 
int No_of_cubes ( int N , int K ) { int No = 0 ; No = ( N - K + 1 ) ; No = pow ( No , 3 ) ; return No ; }
Hyp: 
int No_of_cubes ( int N , int K ) { int No = 0 ; No = ( N - K + 1 ) ; No = pow ( No , 3 ) ; return No ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function sum_series ( n ) { let nSquare = n * n ; return nSquare * ( nSquare - 1 ) / 4 ; }
Ref: 
int sum_series ( int n ) { int nSquare = n * n ; return nSquare * ( nSquare - 1 ) / 4 ; }
Hyp: 
int sum_series ( int n ) { int nSquare = n * n ; return nSquare * ( nSquare - 1 ) / 4 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function pentacontagonNum ( n ) { return ( 48 * n * n - 46 * n ) / 2 ; }
Ref: 
int pentacontagonNum ( int n ) { return ( 48 * n * n - 46 * n ) / 2 ; }
Hyp: 
int pentacontagonNum ( int n ) { return ( 48 * n * n - 46 * n ) / 2 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function nthTerm ( n ) { return 6 * Math . pow ( n , 2 ) - 4 * n - 2 ; }
Ref: 
int nthTerm ( int n ) { return 6 * pow ( n , 2 ) - 4 * n - 2 ; }
Hyp: 
int nthTerm ( int n ) { return 6 * pow ( n , 2 ) - 4 * n - 2 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function makePolygon ( a ) { var n = parseFloat ( 360 / ( 180 - a ) ) ; if ( n === parseInt ( n ) ) document . write ( " " ) ; else document . write ( " " ) ; }
Ref: 
void makePolygon ( float a ) { float n = 360 / ( 180 - a ) ; if ( n == ( int ) n ) cout << " YES " ; else cout << " NO " ; }
Hyp: 
void makePolygon ( float a ) { float n = 360 / ( 180 - a ) ; if ( n == ( int ) n ) cout << " Yes " ; else cout << " No " ; }

BLEU: 87.29
Edit Sim: 3


Src: 
function isSubSeqDivisible ( str ) { let i , j , k , l = str . length ; let arr = [ ] ; for ( i = 0 ; i < l ; i ++ ) arr [ i ] = str [ i ] - ' ' ; for ( i = 0 ; i < l ; i ++ ) { for ( j = i ; j < l ; j ++ ) { for ( k = j ; k < l ; k ++ ) { if ( arr [ i ] % 8 == 0 ) return true ; else if ( ( arr [ i ] * 10 + arr [ j ] ) % 8 == 0 && i != j ) return true ; else if ( ( arr [ i ] * 100 + arr [ j ] * 10 + arr [ k ] ) % 8 == 0 && i != j && j != k && i != k ) return true ; } } } return false ; }
Ref: 
bool isSubSeqDivisible ( string str ) { int l = str . length ( ) ; int arr [ l ] ; for ( int i = 0 ; i < l ; i ++ ) arr [ i ] = str [ i ] - '0' ; for ( int i = 0 ; i < l ; i ++ ) { for ( int j = i ; j < l ; j ++ ) { for ( int k = j ; k < l ; k ++ ) { if ( arr [ i ] % 8 == 0 ) return true ; else if ( ( arr [ i ] * 10 + arr [ j ] ) % 8 == 0 && i != j ) return true ; else if ( ( arr [ i ] * 100 + arr [ j ] * 10 + arr [ k ] ) % 8 == 0 && i != j && j != k && i != k ) return true ; } } } return false ; }
Hyp: 
bool isSubSeqDivisible ( string str ) { int i , j , k , l = str . length ( ) ; int arr [ l ] ; for ( i = 0 ; i < l ; i ++ ) arr [ i ] = str [ i ] - '0' ; for ( i = 0 ; i < l ; i ++ ) { for ( j = i ; j < l ; j ++ ) { for ( k = j ; k < l ; k ++ ) { if ( arr [ i ] % 8 == 0 ) return true ; else if ( ( arr [ i ] * 10 + arr [ j ] ) % 8 == 0 && i != j ) return true ; else if ( ( arr [ i ] * 100 + arr [ j ] * 10 + arr [ k ] ) % 8 == 0 && i != j && j != k && i != k ) return true ; } } } return false ; }

BLEU: 92.82
Edit Sim: 28


Src: 
function lengtang ( r1 , r2 , d ) { document . write ( " " + Math . sqrt ( Math . pow ( d , 2 ) - Math . pow ( ( r1 - r2 ) , 2 ) ) ) ; }
Ref: 
void lengtang ( double r1 , double r2 , double d ) { cout << " The ▁ length ▁ of ▁ the ▁ direct " << " ▁ common ▁ tangent ▁ is ▁ " << sqrt ( pow ( d , 2 ) - pow ( ( r1 - r2 ) , 2 ) ) << endl ; }
Hyp: 
void lengtang ( int r1 , int r2 , int d ) { cout << " The ▁ length ▁ of ▁ the ▁ longest ▁ chord " << sqrt ( pow ( d , 2 ) - pow ( ( r1 - r2 ) , 2 ) ) ; }

BLEU: 61.08
Edit Sim: 58


Src: 
function count_required_sequence ( n , arr ) { var total_required_subsequence = 0 ; var total_n_required_subsequence = 0 ; var dp = Array . from ( Array ( N ) , ( ) => Array ( 2 ) . fill ( 0 ) ) ; for ( var i = 0 ; i < n ; i ++ ) { var turn_required = 0 ; for ( var j = - 1 ; j <= 1 ; j ++ ) turn_required += dp [ arr [ i ] + j ] [ 0 ] ; var required_end_i = ( total_required_subsequence + turn_required ) ; var n_required_end_i = ( 1 + total_n_required_subsequence - turn_required ) ; total_required_subsequence += required_end_i ; total_n_required_subsequence += n_required_end_i ; dp [ arr [ i ] ] [ 1 ] += required_end_i ; dp [ arr [ i ] ] [ 0 ] += n_required_end_i ; } return total_required_subsequence ; }
Ref: 
int count_required_sequence ( int n , int arr [ ] ) { int total_required_subsequence = 0 ; int total_n_required_subsequence = 0 ; int dp [ N ] [ 2 ] ; for ( int i = 0 ; i < n ; i ++ ) { int turn_required = 0 ; for ( int j = -1 ; j <= 1 ; j ++ ) turn_required += dp [ arr [ i ] + j ] [ 0 ] ; int required_end_i = ( total_required_subsequence + turn_required ) ; int n_required_end_i = ( 1 + total_n_required_subsequence - turn_required ) ; total_required_subsequence += required_end_i ; total_n_required_subsequence += n_required_end_i ; dp [ arr [ i ] ] [ 1 ] += required_end_i ; dp [ arr [ i ] ] [ 0 ] += n_required_end_i ; } return total_required_subsequence ; }
Hyp: 
int count_required_sequence ( int n , int arr [ ] ) { int total_required_subsequence = 0 ; int total_n_required_subsequence = 0 ; int dp [ N ] [ 2 ] ; for ( int i = 0 ; i < n ; i ++ ) { int turn_required = 0 ; for ( int j = -1 ; j <= 1 ; j ++ ) turn_required += dp [ arr [ i ] + j ] [ 0 ] ; int required_end_i = ( total_required_subsequence + turn_required ) ; int n_required_end_i = ( 1 + total_n_required_subsequence - turn_required ) ; total_required_subsequence += required_end_i ; total_n_required_subsequence += n_required_end_i ; dp [ arr [ i ] ] [ 1 ] += required_end_i ; dp [ arr [ i ] ] [ 0 ] += n_required_end_i ; } return total_required_subsequence ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function printAP ( a , d , n ) { let curr_term ; curr_term = a ; for ( let i = 1 ; i <= n ; i ++ ) { document . write ( curr_term + " " ) ; curr_term = curr_term + d ; } }
Ref: 
void printAP ( int a , int d , int n ) { int curr_term ; curr_term = a ; for ( int i = 1 ; i <= n ; i ++ ) { cout << curr_term << " ▁ " ; curr_term = curr_term + d ; } }
Hyp: 
void printAP ( int a , int d , int n ) { int curr_term ; curr_term = a ; for ( int i = 1 ; i <= n ; i ++ ) { cout << curr_term << " ▁ " ; curr_term = curr_term + d ; } }

BLEU: 100.0
Edit Sim: 0


Src: 
function numberOfDays ( a , b , n ) { var Days = b * ( n + a ) / ( a + b ) ; return Days ; }
Ref: 
int numberOfDays ( int a , int b , int n ) { int Days = b * ( n + a ) / ( a + b ) ; return Days ; }
Hyp: 
int numberOfDays ( int a , int b , int n ) { int Days = b * ( n + a ) / ( a + b ) ; return Days ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function count ( n ) { return parseInt ( n * ( 3 * n - 1 ) / 2 ) ; }
Ref: 
int count ( int n ) { return n * ( 3 * n - 1 ) / 2 ; }
Hyp: 
int count ( int n ) { return n * ( 3 * n - 1 ) / 2 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function calculateProbability ( N ) { let probability = N / ( N + 1 ) ; return probability ; }
Ref: 
double calculateProbability ( int N ) { double probability = ( double ) N / ( N + 1 ) ; return probability ; }
Hyp: 
double calculateProbability ( int N ) { double probability = N / ( N + 1 ) ; return probability ; }

BLEU: 80.76
Edit Sim: 11


Src: 
function findMinSum ( A , K , n ) { let minimum_sum = Number . MAX_VALUE ; for ( let i = 0 ; i < n ; i ++ ) { let mini = Number . MAX_VALUE ; for ( let j = i + K ; j < n ; j ++ ) mini = Math . min ( mini , A [ j ] ) ; if ( mini == Number . MAX_VALUE ) continue ; minimum_sum = Math . min ( minimum_sum , A [ i ] + mini ) ; } document . write ( minimum_sum ) ; }
Ref: 
void findMinSum ( int A [ ] , int K , int n ) { int minimum_sum = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { int mini = INT_MAX ; for ( int j = i + K ; j < n ; j ++ ) mini = min ( mini , A [ j ] ) ; if ( mini == INT_MAX ) continue ; minimum_sum = min ( minimum_sum , A [ i ] + mini ) ; } cout << ( minimum_sum ) ; }
Hyp: 
void findMinSum ( int A [ ] , int K , int n ) { int minimum_sum = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { int mini = INT_MAX ; for ( int j = i + K ; j < n ; j ++ ) mini = min ( mini , A [ j ] ) ; if ( mini == INT_MAX ) continue ; minimum_sum = min ( minimum_sum , A [ i ] + mini ) ; } cout << minimum_sum ; }

BLEU: 95.87
Edit Sim: 4


Src: 
function numPairs ( a , n ) { let ans , i , index ; ans = 0 ; for ( i = 0 ; i < n ; i ++ ) a [ i ] = Math . abs ( a [ i ] ) ; a . sort ( ) ; for ( i = 0 ; i < n ; i ++ ) { index = 2 ; ans += index - i - 1 ; } return ans ; }
Ref: 
int numPairs ( int a [ ] , int n ) { int ans , i , index ; ans = 0 ; for ( i = 0 ; i < n ; i ++ ) a [ i ] = abs ( a [ i ] ) ; sort ( a , a + n ) ; for ( i = 0 ; i < n ; i ++ ) { index = upper_bound ( a , a + n , 2 * a [ i ] ) - a ; ans += index - i - 1 ; } return ans ; }
Hyp: 
int numPairs ( int a [ ] , int n ) { int ans , i , index ; ans = 0 ; for ( i = 0 ; i < n ; i ++ ) a [ i ] = abs ( a [ i ] ) ; sort ( a , a + n ) ; for ( i = 0 ; i < n ; i ++ ) { index = 2 ; ans += index - i - 1 ; } return ans ; }

BLEU: 81.39
Edit Sim: 42


Src: 
function check ( str ) { let n = str . length ; if ( n == 0 ) return false ; if ( n == 1 ) return ( ( str [ 0 ] - ' ' ) % 8 == 0 ) ; if ( n == 2 ) return ( ( ( str [ n - 2 ] - ' ' ) * 10 + ( str [ n - 1 ] - ' ' ) ) % 8 == 0 ) ; let last = str [ n - 1 ] - ' ' ; let second_last = str [ n - 2 ] - ' ' ; let third_last = str [ n - 3 ] - ' ' ; return ( ( third_last * 100 + second_last * 10 + last ) % 8 == 0 ) ; }
Ref: 
bool check ( string str ) { int n = str . length ( ) ; if ( n == 0 ) return false ; if ( n == 1 ) return ( ( str [ 0 ] - '0' ) % 8 == 0 ) ; if ( n == 2 ) return ( ( ( str [ n - 2 ] - '0' ) * 10 + ( str [ n - 1 ] - '0' ) ) % 8 == 0 ) ; int last = str [ n - 1 ] - '0' ; int second_last = str [ n - 2 ] - '0' ; int third_last = str [ n - 3 ] - '0' ; return ( ( third_last * 100 + second_last * 10 + last ) % 8 == 0 ) ; }
Hyp: 
bool check ( string str ) { int n = str . length ( ) ; if ( n == 0 ) return false ; if ( n == 1 ) return ( ( str [ 0 ] - '0' ) % 8 == 0 ) ; if ( n == 2 ) return ( ( ( str [ n - 2 ] - '0' ) * 10 + ( str [ n - 1 ] - '0' ) ) % 8 == 0 ) ; int last = str [ n - 1 ] - '0' ; int second_last = str [ n - 2 ] - '0' ; int third_last = str [ n - 3 ] - '0' ; return ( ( third_last * 100 + second_last * 10 + last ) % 8 == 0 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function SubString ( str , n ) { for ( var i = 0 ; i < n ; i ++ ) for ( var j = i + 1 ; j <= n ; j ++ ) document . write ( str . substring ( i , j ) + " " ) ; }
Ref: 
void subString ( string s , int n ) { for ( int i = 0 ; i < n ; i ++ ) for ( int len = 1 ; len <= n - i ; len ++ ) cout << s . substr ( i , len ) << endl ; }
Hyp: 
void SubString ( string str , int n ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j <= n ; j ++ ) cout << str [ i ] [ j ] << " ▁ " ; }

BLEU: 50.52
Edit Sim: 37


Src: 
function fourthPowerSum ( n ) { return ( ( 6 * n * n * n * n * n ) + ( 15 * n * n * n * n ) + ( 10 * n * n * n ) - n ) / 30 ; }
Ref: 
int fourthPowerSum ( int n ) { return ( ( 6 * n * n * n * n * n ) + ( 15 * n * n * n * n ) + ( 10 * n * n * n ) - n ) / 30 ; }
Hyp: 
int fourthPowerSum ( int n ) { return ( ( 6 * n * n * n * n ) + ( 15 * n * n * n ) + ( 10 * n * n * n ) - n ) / 30 ; }

BLEU: 91.84
Edit Sim: 8


Src: 
function check ( S , prices , type , n ) { for ( let j = 0 ; j < n ; j ++ ) { for ( let k = j + 1 ; k < n ; k ++ ) { if ( ( type [ j ] == 0 && type [ k ] == 1 ) || ( type [ j ] == 1 && type [ k ] == 0 ) ) { if ( prices [ j ] + prices [ k ] <= S ) { return " " ; } } } } return " " ; }
Ref: 
string check ( int S , int prices [ ] , int type [ ] , int n ) { for ( int j = 0 ; j < n ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) { if ( ( type [ j ] == 0 && type [ k ] == 1 ) || ( type [ j ] == 1 && type [ k ] == 0 ) ) { if ( prices [ j ] + prices [ k ] <= S ) { return " Yes " ; } } } } return " No " ; }
Hyp: 
string check ( int S , int * prices , int type [ ] , int n ) { for ( int j = 0 ; j < n ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) { if ( ( type [ j ] == 0 && type [ k ] == 1 ) || ( type [ j ] == 1 && type [ k ] == 0 ) ) { if ( prices [ j ] + prices [ k ] <= S ) { return " Yes " ; } } } } return " No " ; }

BLEU: 96.33
Edit Sim: 6


Src: 
function findCntTriplet ( N ) { let cntTriplet = 0 ; for ( let i = 1 ; i < N ; i ++ ) { if ( N % i != 0 ) { cntTriplet += Math . floor ( N / i ) ; } else { cntTriplet += Math . floor ( N / i ) - 1 ; } } return cntTriplet ; }
Ref: 
int findCntTriplet ( int N ) { int cntTriplet = 0 ; for ( int i = 1 ; i < N ; i ++ ) { if ( N % i != 0 ) { cntTriplet += N / i ; } else { cntTriplet += ( N / i ) - 1 ; } } return cntTriplet ; }
Hyp: 
int findCntTriplet ( int N ) { int cntTriplet = 0 ; for ( int i = 1 ; i < N ; i ++ ) { if ( N % i != 0 ) { cntTriplet += N / i ; } else { cntTriplet += N / i - 1 ; } } return cntTriplet ; }

BLEU: 91.56
Edit Sim: 4


Src: 
function sumOfTwoCubes ( n ) { var lo = 1 , hi = ( n ) ; while ( lo <= hi ) { var curr = ( lo * lo * lo + hi * hi * hi ) ; if ( curr == n ) return true ; if ( curr < n ) lo ++ ; else hi -- ; } return false ; } var N = 28 ; if ( sumOfTwoCubes ( N ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
Ref: 
bool sumOfTwoCubes ( int n ) { long long int lo = 1 , hi = ( long long int ) cbrt ( n ) ; while ( lo <= hi ) { long long int curr = ( lo * lo * lo + hi * hi * hi ) ; if ( curr == n ) return true ; if ( curr < n ) lo ++ ; else hi -- ; } return false ; }
Hyp: 
bool sumOfTwoCubes ( int n ) { int lo = 1 , hi = ( n ) ; while ( lo <= hi ) { int curr = ( lo * lo * lo + hi * hi * hi ) ; if ( curr == n ) return true ; if ( curr < n ) lo ++ ; else hi -- ; } return false ; }

BLEU: 81.61
Edit Sim: 43


Src: 
function lengequichord ( z ) { document . write ( " " + " " + z + " " ) ; }
Ref: 
void lengequichord ( int z ) { cout << " The ▁ distance ▁ between ▁ the ▁ " << " chord ▁ and ▁ the ▁ center ▁ is ▁ " << z << endl ; }
Hyp: 
void lengequichord ( int z ) { cout << " The ▁ length ▁ of ▁ the ▁ longest ▁ chord " << " ▁ is ▁ " << z << " ▁ degrees " << endl ; }

BLEU: 57.96
Edit Sim: 49


Src: 
function powerNumbers ( n ) { let v = new Set ( ) ; for ( let i = 2 ; i * i * i <= n ; i ++ ) { let j = i * i ; while ( j * i <= n ) { j *= i ; let s = parseInt ( Math . sqrt ( j ) , 10 ) ; if ( s * s != j ) v . add ( j ) ; } } return v . size + parseInt ( Math . sqrt ( n ) , 10 ) ; }
Ref: 
int powerNumbers ( int n ) { vector < int > v ; for ( ll i = 2 ; i * i * i <= n ; i ++ ) { ll j = i * i ; while ( j * i <= n ) { j *= i ; ll s = sqrt ( j ) ; if ( s * s != j ) v . push_back ( j ) ; } } sort ( v . begin ( ) , v . end ( ) ) ; v . erase ( unique ( v . begin ( ) , v . end ( ) ) , v . end ( ) ) ; return v . size ( ) + ( ll ) sqrt ( n ) ; }
Hyp: 
int powerNumbers ( int n ) { unordered_set < int > v ; for ( int i = 2 ; i * i * i <= n ; i ++ ) { int j = i * i ; while ( j * i <= n ) { j *= i ; int s = sqrt ( j ) ; if ( s * s != j ) v . insert ( j ) ; } } return v . size ( ) + sqrt ( n ) ; }

BLEU: 50.34
Edit Sim: 144


Src: 
function findWinner ( N ) { return N & 1 ; }
Ref: 
bool findWinner ( int N ) { return N & 1 ; }
Hyp: 
int findWinner ( int N ) { return N & 1 ; }

BLEU: 91.93
Edit Sim: 4


Src: 
function toggle ( n ) { let temp = 1 ; while ( temp <= n ) { n = n ^ temp ; temp = temp << 1 ; } return n ; }
Ref: 
void toggle ( int & n ) { int temp = 1 ; while ( temp <= n ) { n = n ^ temp ; temp = temp << 1 ; } }
Hyp: 
int toggle ( int n ) { int temp = 1 ; while ( temp <= n ) { n = n ^ temp ; temp = temp << 1 ; } return n ; }

BLEU: 82.12
Edit Sim: 17


Src: 
function getValue ( n ) { let i = 0 , k = 1 ; while ( i < n ) { i = i + k ; k = k * 2 ; } return parseInt ( k / 2 ) ; }
Ref: 
int getValue ( int n ) { int i = 0 , k = 1 ; while ( i < n ) { i = i + k ; k = k * 2 ; } return k / 2 ; }
Hyp: 
int getValue ( int n ) { int i = 0 , k = 1 ; while ( i < n ) { i = i + k ; k = k * 2 ; } return k / 2 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function thirdLargest ( arr , arr_size ) { if ( arr_size < 3 ) { document . write ( " " ) ; return ; } let first = arr [ 0 ] ; for ( let i = 1 ; i < arr_size ; i ++ ) if ( arr [ i ] > first ) first = arr [ i ] ; let second = Number . MIN_VALUE ; for ( let i = 0 ; i < arr_size ; i ++ ) if ( arr [ i ] > second && arr [ i ] < first ) second = arr [ i ] ; let third = Number . MIN_VALUE ; for ( let i = 0 ; i < arr_size ; i ++ ) if ( arr [ i ] > third && arr [ i ] < second ) third = arr [ i ] ; document . write ( " " + " " , third ) ; }
Ref: 
void thirdLargest ( int arr [ ] , int arr_size ) { if ( arr_size < 3 ) { printf ( " ▁ Invalid ▁ Input ▁ " ) ; return ; } int first = arr [ 0 ] ; for ( int i = 1 ; i < arr_size ; i ++ ) if ( arr [ i ] > first ) first = arr [ i ] ; int second = INT_MIN ; for ( int i = 0 ; i < arr_size ; i ++ ) if ( arr [ i ] > second && arr [ i ] < first ) second = arr [ i ] ; int third = INT_MIN ; for ( int i = 0 ; i < arr_size ; i ++ ) if ( arr [ i ] > third && arr [ i ] < second ) third = arr [ i ] ; printf ( " The ▁ third ▁ Largest ▁ element ▁ is ▁ % d STRNEWLINE " , third ) ; }
Hyp: 
void thirdLargest ( int arr [ ] , int arr_size ) { if ( arr_size < 3 ) { cout << " NO " ; return ; } int first = arr [ 0 ] ; for ( int i = 1 ; i < arr_size ; i ++ ) if ( arr [ i ] > first ) first = arr [ i ] ; int second = INT_MIN ; for ( int i = 0 ; i < arr_size ; i ++ ) if ( arr [ i ] > second && arr [ i ] < first ) second = arr [ i ] ; int third = INT_MIN ; for ( int i = 0 ; i < arr_size ; i ++ ) if ( arr [ i ] > third && arr [ i ] < second ) third = arr [ i ] ; cout << " ▁ " << " ▁ " << third ; }

BLEU: 82.39
Edit Sim: 86


Src: 
function nthTerm ( N ) { let nth = 0 , first_term = 4 ; let pi = 1 , po = 1 ; let n = N ; while ( n > 1 ) { pi *= n - 1 ; n -- ; po *= 2 ; } nth = ( first_term * pi ) / po ; return nth ; }
Ref: 
int nthTerm ( int N ) { int nth = 0 , first_term = 4 ; int pi = 1 , po = 1 ; int n = N ; while ( n > 1 ) { pi *= n - 1 ; n -- ; po *= 2 ; } nth = ( first_term * pi ) / po ; return nth ; }
Hyp: 
int nthTerm ( int N ) { int nth = 0 , first_term = 4 ; int pi = 1 , po = 1 ; int n = N ; while ( n > 1 ) { pi *= n - 1 ; n -- ; po *= 2 ; } nth = ( first_term * pi ) / po ; return nth ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function count ( n ) { let table = new Array ( n + 1 ) , i ; for ( let j = 0 ; j < n + 1 ; j ++ ) table [ j ] = 0 ; table [ 0 ] = 1 ; for ( i = 3 ; i <= n ; i ++ ) table [ i ] += table [ i - 3 ] ; for ( i = 5 ; i <= n ; i ++ ) table [ i ] += table [ i - 5 ] ; for ( i = 10 ; i <= n ; i ++ ) table [ i ] += table [ i - 10 ] ; return table [ n ] ; }
Ref: 
int count ( int n ) { int table [ n + 1 ] , i ; for ( int j = 0 ; j < n + 1 ; j ++ ) table [ j ] = 0 ; table [ 0 ] = 1 ; for ( i = 3 ; i <= n ; i ++ ) table [ i ] += table [ i - 3 ] ; for ( i = 5 ; i <= n ; i ++ ) table [ i ] += table [ i - 5 ] ; for ( i = 10 ; i <= n ; i ++ ) table [ i ] += table [ i - 10 ] ; return table [ n ] ; }
Hyp: 
int count ( int n ) { int table [ n + 1 ] , i ; for ( int j = 0 ; j < n + 1 ; j ++ ) table [ j ] = 0 ; table [ 0 ] = 1 ; for ( i = 3 ; i <= n ; i ++ ) table [ i ] += table [ i - 3 ] ; for ( i = 5 ; i <= n ; i ++ ) table [ i ] += table [ i - 5 ] ; for ( i = 10 ; i <= n ; i ++ ) table [ i ] += table [ i - 10 ] ; return table [ n ] ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findRepeatFirstN2 ( s ) { let p = - 1 , i , j ; for ( i = 0 ; i < s . length ; i ++ ) { for ( j = i + 1 ; j < s . length ; j ++ ) { if ( s [ i ] == s [ j ] ) { p = i ; break ; } } if ( p != - 1 ) break ; } return p ; }
Ref: 
int findRepeatFirstN2 ( char * s ) { int p = -1 , i , j ; for ( i = 0 ; i < strlen ( s ) ; i ++ ) { for ( j = i + 1 ; j < strlen ( s ) ; j ++ ) { if ( s [ i ] == s [ j ] ) { p = i ; break ; } } if ( p != -1 ) break ; } return p ; }
Hyp: 
int findRepeatFirstN2 ( string s ) { int p = -1 , i , j ; for ( i = 0 ; i < s . length ( ) ; i ++ ) { for ( j = i + 1 ; j < s . length ( ) ; j ++ ) { if ( s [ i ] == s [ j ] ) { p = i ; break ; } } if ( p != -1 ) break ; } return p ; }

BLEU: 85.46
Edit Sim: 20


Src: 
function minimumStepReqArr ( arr , N ) { let cntStep = 0 ; N += 1 ; for ( let i = 31 ; i >= 0 ; i -- ) { if ( ( N & ( 1 << i ) ) != 0 ) { cntStep += 1 ; } } return cntStep ; }
Ref: 
int minimumStepReqArr ( int arr [ ] , int N ) { int cntStep = 0 ; N += 1 ; for ( int i = 31 ; i >= 0 ; i -- ) { if ( N & ( 1 << i ) ) { cntStep += 1 ; } } return cntStep ; }
Hyp: 
int minimumStepReqArr ( int arr [ ] , int N ) { int cntStep = 0 ; N += 1 ; for ( int i = 31 ; i >= 0 ; i -- ) { if ( ( N & ( 1 << i ) ) != 0 ) { cntStep += 1 ; } } return cntStep ; }

BLEU: 90.81
Edit Sim: 9


Src: 
function nextPerfectSquare ( N ) { let nextN = Math . floor ( Math . sqrt ( N ) ) + 1 ; return nextN * nextN ; }
Ref: 
int nextPerfectSquare ( int N ) { int nextN = floor ( sqrt ( N ) ) + 1 ; return nextN * nextN ; }
Hyp: 
int nextPerfectSquare ( int N ) { int nextN = floor ( sqrt ( N ) ) + 1 ; return nextN * nextN ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countSolutions ( n ) { let x = 0 , yCount , res = 0 ; for ( yCount = 0 ; yCount * yCount < n ; yCount ++ ) ; while ( yCount != 0 ) { res += yCount ; x ++ ; while ( yCount != 0 && ( x * x + ( yCount - 1 ) * ( yCount - 1 ) >= n ) ) yCount -- ; } return res ; }
Ref: 
int countSolutions ( int n ) { int x = 0 , yCount , res = 0 ; for ( yCount = 0 ; yCount * yCount < n ; yCount ++ ) ; while ( yCount != 0 ) { res += yCount ; x ++ ; while ( yCount != 0 && ( x * x + ( yCount - 1 ) * ( yCount - 1 ) >= n ) ) yCount -- ; } return res ; }
Hyp: 
int countSolutions ( int n ) { int x = 0 , yCount , res = 0 ; for ( yCount = 0 ; yCount * yCount < n ; yCount ++ ) ; while ( yCount != 0 ) { res += yCount ; x ++ ; while ( yCount != 0 && ( x * x + ( yCount - 1 ) * ( yCount - 1 ) >= n ) ) yCount -- ; } return res ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function isEqualFactors ( N ) { let ev_count = 0 , od_count = 0 ; for ( let i = 1 ; i <= Math . sqrt ( N ) + 1 ; i ++ ) { if ( N % i == 0 ) { if ( i == N / i ) { if ( i % 2 == 0 ) ev_count += 1 ; else od_count += 1 ; } else { if ( i % 2 == 0 ) ev_count += 1 ; else od_count += 1 ; if ( ( N / i ) % 2 == 0 ) ev_count += 1 ; else od_count += 1 ; } } } if ( ev_count == od_count ) document . write ( " " + " " ) ; else document . write ( " " + " " ) ; }
Ref: 
void isEqualFactors ( lli N ) { lli ev_count = 0 , od_count = 0 ; for ( lli i = 1 ; i <= sqrt ( N ) + 1 ; i ++ ) { if ( N % i == 0 ) { if ( i == N / i ) { if ( i % 2 == 0 ) ev_count += 1 ; else od_count += 1 ; } else { if ( i % 2 == 0 ) ev_count += 1 ; else od_count += 1 ; if ( ( N / i ) % 2 == 0 ) ev_count += 1 ; else od_count += 1 ; } } } if ( ev_count == od_count ) cout << " YES " << endl ; else cout << " NO " << endl ; }
Hyp: 
void isEqualFactors ( int N ) { int ev_count = 0 , od_count = 0 ; for ( int i = 1 ; i <= sqrt ( N ) + 1 ; i ++ ) { if ( N % i == 0 ) { if ( i == N / i ) { if ( i % 2 == 0 ) ev_count += 1 ; else od_count += 1 ; } else { if ( i % 2 == 0 ) ev_count += 1 ; else od_count += 1 ; if ( ( N / i ) % 2 == 0 ) ev_count += 1 ; else od_count += 1 ; } } } if ( ev_count == od_count ) cout << " Yes " << endl ; else cout << " No " << endl ; }

BLEU: 90.85
Edit Sim: 12


Src: 
function lastDigit ( a , b ) { var lastDig = ( a [ a . length - 1 ] - ' ' ) * ( b [ b . length - 1 ] - ' ' ) ; document . write ( lastDig % 10 ) ; }
Ref: 
void lastDigit ( string a , string b ) { int lastDig = ( a [ a . length ( ) - 1 ] - '0' ) * ( b [ b . length ( ) - 1 ] - '0' ) ; cout << lastDig % 10 ; }
Hyp: 
void lastDigit ( string a , string b ) { int lastDig = ( a [ a . length ( ) - 1 ] - '0' ) * ( b [ b . length ( ) - 1 ] - '0' ) ; cout << lastDig % 10 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function nthEnneadecagonal ( n ) { return ( 17 * n * n - 15 * n ) / 2 ; }
Ref: 
int nthEnneadecagonal ( long int n ) { return ( 17 * n * n - 15 * n ) / 2 ; }
Hyp: 
int nthEnneadecagonal ( int n ) { return ( 17 * n * n - 15 * n ) / 2 ; }

BLEU: 88.96
Edit Sim: 5


Src: 
function countPaths ( sum , get , m , n , dp ) { if ( sum < 0 ) return 0 ; if ( sum == 0 ) return get ; if ( dp [ sum ] [ get ] != - 1 ) return dp [ sum ] [ get ] ; let res = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { if ( i == m ) res += countPaths ( sum - i , 1 , m , n , dp ) ; else res += countPaths ( sum - i , get , m , n , dp ) ; } dp [ sum ] [ get ] = res ; return dp [ sum ] [ get ] ; } let n = 3 , m = 2 , x = 3 ; let dp = new Array ( max + 1 ) ; for ( let i = 0 ; i <= max ; i ++ ) { dp [ i ] = new Array ( 2 ) for ( let j = 0 ; j < 2 ; j ++ ) dp [ i ] [ j ] = - 1 ; }
Ref: 
int countPaths ( int sum , int get , int m , int n , int dp [ ] ) { if ( sum < 0 ) return 0 ; if ( sum == 0 ) return get ; if ( dp [ sum ] [ get ] != -1 ) return dp [ sum ] [ get ] ; int res = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i == m ) res += countPaths ( sum - i , 1 , m , n , dp ) ; res += countPaths ( sum - i , get , m , n , dp ) ; } dp [ sum ] [ get ] = res ; return dp [ sum ] [ get ] ; }
Hyp: 
int countPaths ( int sum , int get , int m , int n , int dp [ ] [ max + 1 ] ) { if ( sum < 0 ) return 0 ; if ( sum == 0 ) return get ; if ( dp [ sum ] [ get ] != -1 ) return dp [ sum ] [ get ] ; int res = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i == m ) res += countPaths ( sum - i , 1 , m , n , dp ) ; else res += countPaths ( sum - i , get , m , n , dp ) ; } dp [ sum ] [ get ] = res ; return dp [ sum ] [ get ] ; }

BLEU: 94.35
Edit Sim: 17


Src: 
function tetracontagonNum ( n ) { return ( 38 * n * n - 36 * n ) / 2 ; }
Ref: 
int tetracontagonNum ( int n ) { return ( 38 * n * n - 36 * n ) / 2 ; }
Hyp: 
int tetracontagonNum ( int n ) { return ( 38 * n * n - 36 * n ) / 2 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function ishendecagonal ( N ) { let n = ( 7 + Math . sqrt ( 72 * N + 49 ) ) / 18 ; return ( n - parseInt ( n ) ) == 0 ; } let N = 11 ; if ( ishendecagonal ( N ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
Ref: 
bool ishendecagonal ( int N ) { float n = ( 7 + sqrt ( 72 * N + 49 ) ) / 18 ; return ( n - ( int ) n ) == 0 ; }
Hyp: 
bool ishendecagonal ( int N ) { float n = ( 7 + sqrt ( 72 * N + 49 ) ) / 18 ; return ( n - ( int ) n ) == 0 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countBits ( a , b ) { var count = 0 ; while ( a b ) { var last_bit_a = a & 1 ; var last_bit_b = b & 1 ; if ( last_bit_a != last_bit_b ) count ++ ; a = a >> 1 ; b = b >> 1 ; } return count ; }
Ref: 
int countBits ( int a , int b ) { int count = 0 ; while ( a b ) { int last_bit_a = a & 1 ; int last_bit_b = b & 1 ; if ( last_bit_a != last_bit_b ) count ++ ; a = a >> 1 ; b = b >> 1 ; } return count ; }
Hyp: 
int countBits ( int a , int b ) { int count = 0 ; while ( a b ) { int last_bit_a = a & 1 ; int last_bit_b = b & 1 ; if ( last_bit_a != last_bit_b ) count ++ ; a = a >> 1 ; b = b >> 1 ; } return count ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countOccurrences ( str , word ) { let a = str . split ( " " ) ; let count = 0 ; for ( let i = 0 ; i < a . length ; i ++ ) { if ( word == ( a [ i ] ) ) count ++ ; } return count ; }
Ref: 
int countOccurrences ( char * str , string word ) { char * p ; vector < string > a ; p = strtok ( str , " ▁ " ) ; while ( p != NULL ) { a . push_back ( p ) ; p = strtok ( NULL , " ▁ " ) ; } int c = 0 ; for ( int i = 0 ; i < a . size ( ) ; i ++ ) if ( word == a [ i ] ) c ++ ; return c ; }
Hyp: 
int countOccurrences ( string str , string word ) { string ar [ ] ; int count = 0 ; for ( int i = 0 ; i < ar [ 0 ] ; i ++ ) { if ( word == ar [ i ] ) count ++ ; } return count ; }

BLEU: 22.69
Edit Sim: 150


Src: 
function charactersCount ( str , n ) { let count = 0 ; while ( n > 0 ) { let cur = str [ 0 ] . charCodeAt ( ) ; let ind = 0 ; for ( let j = 1 ; j < n ; j ++ ) { if ( str [ j ] . charCodeAt ( ) < cur ) { cur = str [ j ] . charCodeAt ( ) ; ind = j ; } } str = str . substring ( 0 , ind ) + str . substring ( ind + 1 ) ; n -- ; count += ind + 1 ; } document . write ( count + " " ) ; }
Ref: 
void charactersCount ( string str , int n ) { int count = 0 ; while ( n > 0 ) { char cur = str [ 0 ] ; int ind = 0 ; for ( int j = 1 ; j < n ; j ++ ) { if ( str [ j ] < cur ) { cur = str [ j ] ; ind = j ; } } str . erase ( str . begin ( ) + ind ) ; n -- ; count += ind + 1 ; } cout << count << endl ; }
Hyp: 
void charactersCount ( string str , int n ) { int count = 0 ; while ( n ) { char cur = str [ 0 ] ; int ind = 0 ; for ( int j = 1 ; j < n ; j ++ ) { if ( str [ j ] < cur ) { cur = str [ j ] ; ind = j ; } } str = str . substr ( 0 , ind ) + str . substr ( ind + 1 ) ; n -- ; count += ind + 1 ; } cout << count << " STRNEWLINE " ; }

BLEU: 80.52
Edit Sim: 53


Src: 
function area ( R ) { var base = 1.732 * R ; var height = ( 1.5 ) * R ; var area = 0.5 * base * height ; return area ; }
Ref: 
double area ( int R ) { double base = 1.732 * R ; double height = ( 1.5 ) * R ; double area = 0.5 * base * height ; return area ; }
Hyp: 
float area ( float R ) { float base = 1.732 * R ; float height = ( 1.5 ) * R ; float area = 0.5 * base * height ; return area ; }

BLEU: 68.16
Edit Sim: 28


Src: 
function leastValue ( P , A , N , a ) { let ans = - 1 ; let tmp = Number . MAX_VALUE ; for ( let i = 0 ; i < N ; i ++ ) { let t = ( P - a [ i ] * 0.006 ) ; if ( Math . abs ( t - A ) < tmp ) { tmp = Math . abs ( t - A ) ; ans = i ; } } return a [ ans ] ; }
Ref: 
int leastValue ( int P , int A , int N , int a [ ] ) { int ans = -1 ; float tmp = ( float ) INFINITY ; for ( int i = 0 ; i < N ; i ++ ) { float t = P - a [ i ] * 0.006 ; if ( abs ( t - A ) < tmp ) { tmp = abs ( t - A ) ; ans = i ; } } return a [ ans ] ; }
Hyp: 
int leastValue ( float P , float A , int N , int a [ ] ) { int ans = -1 ; float tmp = INT_MAX ; for ( int i = 0 ; i < N ; i ++ ) { float t = ( P - a [ i ] * 0.006 ) ; if ( abs ( t - A ) < tmp ) { tmp = abs ( t - A ) ; ans = i ; } } return a [ ans ] ; }

BLEU: 86.49
Edit Sim: 28


Src: 
function countNumbers ( n ) { return ( n / 2520 ) ; }
Ref: 
int countNumbers ( int n ) { return ( n / 2520 ) ; }
Hyp: 
int countNumbers ( int n ) { return ( n / 2520 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function distinct ( arr , n ) { let count = 0 ; if ( n == 1 ) return 1 ; for ( let i = 0 ; i < n - 1 ; i ++ ) { if ( i == 0 ) { if ( arr [ i ] != arr [ i + 1 ] ) count += 1 ; } else { if ( arr [ i ] != arr [ i + 1 ] arr [ i ] != arr [ i - 1 ] ) count += 1 ; } } if ( arr [ n - 1 ] != arr [ n - 2 ] ) count += 1 ; return count ; }
Ref: 
int distinct ( int arr [ ] , int n ) { int count = 0 ; if ( n == 1 ) return 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( i == 0 ) { if ( arr [ i ] != arr [ i + 1 ] ) count += 1 ; } else { if ( arr [ i ] != arr [ i + 1 ] arr [ i ] != arr [ i - 1 ] ) count += 1 ; } } if ( arr [ n - 1 ] != arr [ n - 2 ] ) count += 1 ; return count ; }
Hyp: 
int distinct ( int arr [ ] , int n ) { int count = 0 ; if ( n == 1 ) return 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( i == 0 ) { if ( arr [ i ] != arr [ i + 1 ] ) count += 1 ; } else { if ( arr [ i ] != arr [ i + 1 ] arr [ i ] != arr [ i - 1 ] ) count += 1 ; } } if ( arr [ n - 1 ] != arr [ n - 2 ] ) count += 1 ; return count ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countPairs ( s1 , n1 , s2 , n2 ) { let freq1 = new Array ( 26 ) ; let freq2 = new Array ( 26 ) ; freq1 . fill ( 0 ) ; freq2 . fill ( 0 ) ; let i , count = 0 ; for ( i = 0 ; i < n1 ; i ++ ) freq1 [ s1 [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ] ++ ; for ( i = 0 ; i < n2 ; i ++ ) freq2 [ s2 [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ] ++ ; for ( i = 0 ; i < 26 ; i ++ ) count += ( Math . min ( freq1 [ i ] , freq2 [ i ] ) ) ; return count ; }
Ref: 
int countPairs ( string s1 , int n1 , string s2 , int n2 ) { int freq1 [ 26 ] = { 0 } ; int freq2 [ 26 ] = { 0 } ; int i , count = 0 ; for ( i = 0 ; i < n1 ; i ++ ) freq1 [ s1 [ i ] - ' a ' ] ++ ; for ( i = 0 ; i < n2 ; i ++ ) freq2 [ s2 [ i ] - ' a ' ] ++ ; for ( i = 0 ; i < 26 ; i ++ ) count += ( min ( freq1 [ i ] , freq2 [ i ] ) ) ; return count ; }
Hyp: 
int countPairs ( string s1 , int n1 , string s2 , int n2 ) { int freq1 [ 26 ] , freq2 [ 26 ] ; memset ( freq1 , 0 , sizeof freq1 ) ; for ( int i = 0 ; i < n1 ; i ++ ) freq1 [ s1 [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < n2 ; i ++ ) freq2 [ s2 [ i ] - ' a ' ] ++ ; for ( i = 0 ; i < 26 ; i ++ ) count += ( min ( freq1 [ i ] , freq2 [ i ] ) ) ; return count ; }

BLEU: 83.04
Edit Sim: 49


Src: 
function canBeReduced ( x , y ) { var maxi = Math . max ( x , y ) ; var mini = Math . min ( x , y ) ; if ( ( ( x + y ) % 3 ) == 0 && maxi <= 2 * mini ) document . write ( " " + " " ) ; else document . write ( " " + " " ) ; }
Ref: 
void canBeReduced ( int x , int y ) { int maxi = max ( x , y ) ; int mini = min ( x , y ) ; if ( ( ( x + y ) % 3 ) == 0 && maxi <= 2 * mini ) cout << " YES " << endl ; else cout << " NO " << endl ; }
Hyp: 
void canBeReduced ( int x , int y ) { int maxi = max ( x , y ) ; int mini = min ( x , y ) ; if ( ( ( x + y ) % 3 ) == 0 && maxi <= 2 * mini ) cout << " Yes " << endl ; else cout << " No " << endl ; }

BLEU: 92.47
Edit Sim: 3


Src: 
function slope ( x1 , y1 , x2 , y2 ) { if ( x1 == x2 ) return Number . MAX_VALUE ; return ( y2 - y1 ) / ( x2 - x1 ) ; }
Ref: 
float slope ( float x1 , float y1 , float x2 , float y2 ) { if ( x1 == x2 ) return INT_MAX ; return ( y2 - y1 ) / ( x2 - x1 ) ; }
Hyp: 
int slope ( int x1 , int y1 , int x2 , int y2 ) { if ( x1 == x2 ) return INT_MAX ; return ( y2 - y1 ) / ( x2 - x1 ) ; }

BLEU: 73.21
Edit Sim: 20


Src: 
function arePermutation ( str1 , str2 ) { let n1 = str1 . length ; let n2 = str2 . length ; if ( n1 != n2 ) return false ; let ch1 = str1 . split ( ' ' ) ; let ch2 = str2 . split ( ' ' ) ; ch1 . sort ( ) ; ch2 . sort ( ) ; for ( let i = 0 ; i < n1 ; i ++ ) if ( ch1 [ i ] != ch2 [ i ] ) return false ; return true ; }
Ref: 
bool arePermutation ( string str1 , string str2 ) { int n1 = str1 . length ( ) ; int n2 = str2 . length ( ) ; if ( n1 != n2 ) return false ; sort ( str1 . begin ( ) , str1 . end ( ) ) ; sort ( str2 . begin ( ) , str2 . end ( ) ) ; for ( int i = 0 ; i < n1 ; i ++ ) if ( str1 [ i ] != str2 [ i ] ) return false ; return true ; }
Hyp: 
bool arePermutation ( string str1 , string str2 ) { int n1 = str1 . length ( ) ; int n2 = str2 . length ( ) ; if ( n1 != n2 ) return false ; string ch1 [ ] , ch2 [ ] ; sort ( ch1 , ch1 + n1 ) ; sort ( ch2 , ch2 + n2 ) ; for ( int i = 0 ; i < n1 ; i ++ ) if ( ch1 [ i ] != ch2 [ i ] ) return false ; return true ; }

BLEU: 69.22
Edit Sim: 62


Src: 
function maxlength ( s ) { let n = s . length , i , j ; let ans = 0 ; for ( i = 0 ; i <= n - 1 ; i ++ ) { if ( s [ i ] == ' ' ) { let count = 1 ; for ( j = i + 1 ; j <= n - 1 && s [ j ] == ' ' ; j ++ ) count ++ ; ans = Math . max ( ans , count ) ; } } return ans ; }
Ref: 
int maxlength ( string s ) { int n = s . length ( ) , i , j ; int ans = 0 ; for ( i = 0 ; i <= n - 1 ; i ++ ) { if ( s [ i ] == '1' ) { int count = 1 ; for ( j = i + 1 ; j <= n - 1 && s [ j ] == '1' ; j ++ ) count ++ ; ans = max ( ans , count ) ; } } return ans ; }
Hyp: 
int maxlength ( string s ) { int n = s . length ( ) , i , j ; int ans = 0 ; for ( i = 0 ; i <= n - 1 ; i ++ ) { if ( s [ i ] == '0' ) { int count = 1 ; for ( j = i + 1 ; j <= n - 1 && s [ j ] == '0' ; j ++ ) count ++ ; ans = max ( ans , count ) ; } } return ans ; }

BLEU: 94.82
Edit Sim: 2


Src: 
function Solution ( A ) { let ans = 2 ; let n = A . length ; if ( n <= 2 ) { return n ; } let llap = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { llap [ i ] = 2 ; } A . sort ( function ( a , b ) { return a - b } ) ; for ( let j = n - 2 ; j >= 0 ; j -- ) { let i = j - 1 ; let k = j + 1 ; while ( i >= 0 && k < n ) { if ( A [ i ] + A [ k ] == ( 2 * A [ j ] ) ) { llap [ j ] = Math . max ( ( llap [ k ] + 1 ) , llap [ j ] ) ; ans = Math . max ( ans , llap [ j ] ) ; i -= 1 ; k += 1 ; } else if ( A [ i ] + A [ k ] < 2 * A [ j ] ) k += 1 ; else i -= 1 ; } } return ans ; }
Ref: 
int Solution ( vector < int > A ) { int ans = 2 ; int n = A . size ( ) ; if ( n <= 2 ) return n ; vector < int > llap ( n , 2 ) ; sort ( A . begin ( ) , A . end ( ) ) ; for ( int j = n - 2 ; j >= 0 ; j -- ) { int i = j - 1 ; int k = j + 1 ; while ( i >= 0 && k < n ) { if ( A [ i ] + A [ k ] == 2 * A [ j ] ) { llap [ j ] = max ( llap [ k ] + 1 , llap [ j ] ) ; ans = max ( ans , llap [ j ] ) ; i -= 1 ; k += 1 ; } else if ( A [ i ] + A [ k ] < 2 * A [ j ] ) k += 1 ; else i -= 1 ; } } return ans ; }
Hyp: 
int Solution ( int A [ ] , int n ) { int ans = 2 ; int llap [ n ] ; if ( n <= 2 ) { return n ; } sort ( A , A + n ) ; for ( int j = n - 2 ; j >= 0 ; j -- ) { int i = j - 1 ; int k = j + 1 ; while ( i >= 0 && k < n ) { if ( A [ i ] + A [ k ] == ( 2 * A [ j ] ) ) { llap [ j ] = max ( ( llap [ k ] + 1 ) , llap [ j ] ) ; ans = max ( ans , llap [ j ] ) ; i -= 1 ; k += 1 ; } else if ( A [ i ] + A [ k ] < 2 * A [ j ] ) k += 1 ; else i -= 1 ; } } return ans ; }

BLEU: 78.73
Edit Sim: 86


Src: 
function getPairsCount ( a , n ) { let count = 0 ; for ( let i = 0 ; i < n - 1 ; i ++ ) { for ( let j = i + 1 ; j < n ; j ++ ) { if ( ( a [ i ] * a [ j ] ) == Math . abs ( i - j ) ) count ++ ; } } return count ; }
Ref: 
int getPairsCount ( int a [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( ( a [ i ] * a [ j ] ) == abs ( i - j ) ) count ++ ; } } return count ; }
Hyp: 
int getPairsCount ( int a [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( ( a [ i ] * a [ j ] ) == abs ( i - j ) ) count ++ ; } } return count ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countChar ( str ) { var n = str . length ; if ( n <= 2 ) return n ; var count = 2 ; for ( var i = 1 ; i < n - 1 ; i ++ ) if ( str [ i - 1 ] == str [ i + 1 ] ) count ++ ; return count ; }
Ref: 
int countChar ( string str ) { int n = str . length ( ) ; if ( n <= 2 ) return n ; int count = 2 ; for ( int i = 1 ; i < n - 1 ; i ++ ) if ( str [ i - 1 ] == str [ i + 1 ] ) count ++ ; return count ; }
Hyp: 
int countChar ( string str ) { int n = str . length ( ) ; if ( n <= 2 ) return n ; int count = 2 ; for ( int i = 1 ; i < n - 1 ; i ++ ) if ( str [ i - 1 ] == str [ i + 1 ] ) count ++ ; return count ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findK ( A , i , j , n , m , k ) { if ( n < 1 m < 1 ) return - 1 ; if ( k <= m ) return A [ i + 0 ] [ j + k - 1 ] ; if ( k <= ( m + n - 1 ) ) return A [ i + ( k - m ) ] [ j + m - 1 ] ; if ( k <= ( m + n - 1 + m - 1 ) ) return A [ i + n - 1 ] [ j + m - 1 - ( k - ( m + n - 1 ) ) ] ; if ( k <= ( m + n - 1 + m - 1 + n - 2 ) ) return A [ i + n - 1 - ( k - ( m + n - 1 + m - 1 ) ) ] [ j + 0 ] ; return findK ( A , i + 1 , j + 1 , n - 2 , m - 2 , k - ( 2 * n + 2 * m - 4 ) ) ; }
Ref: 
int findK ( int A [ MAX ] [ MAX ] , int n , int m , int k ) { if ( n < 1 m < 1 ) return -1 ; if ( k <= m ) return A [ 0 ] [ k - 1 ] ; if ( k <= ( m + n - 1 ) ) return A [ ( k - m ) ] [ m - 1 ] ; if ( k <= ( m + n - 1 + m - 1 ) ) return A [ n - 1 ] [ m - 1 - ( k - ( m + n - 1 ) ) ] ; if ( k <= ( m + n - 1 + m - 1 + n - 2 ) ) return A [ n - 1 - ( k - ( m + n - 1 + m - 1 ) ) ] [ 0 ] ; return findK ( ( int ( * ) [ MAX ] ) ( & ( A [ 1 ] [ 1 ] ) ) , n - 2 , m - 2 , k - ( 2 * n + 2 * m - 4 ) ) ; }
Hyp: 
int findK ( int A [ ] [ j + 1 ] , int n , int m , int k ) { if ( n < 1 m < 1 ) return -1 ; if ( k <= m ) return A [ i + 0 ] [ j + k - 1 ] ; if ( k <= ( m + n - 1 ) ) return A [ i + ( k - m ) ] [ j + m - 1 ] ; if ( k <= ( m + n - 1 + m - 1 ) ) return A [ i + n - 1 ] [ j + m - 1 - ( k - ( m + n - 1 ) ) ] ; if ( k <= ( m + n - 1 + m - 1 + n - 2 ) ) return A [ i + n - 1 - ( k - ( m + n - 1 + m - 1 ) ) ] [ j + 0 ] ; return findK ( A , i + 1 , j + 1 , n - 2 , m - 2 , k - ( 2 * n + 2 * m - 4 ) ) ; }

BLEU: 80.15
Edit Sim: 75


Src: 
function predictTheWinner ( K , N ) { if ( N % ( K + 1 ) == 0 ) document . write ( " " ) ; else document . write ( " " ) ; }
Ref: 
void predictTheWinner ( int K , int N ) { if ( N % ( K + 1 ) == 0 ) cout << " Bob " ; else cout << " Alice " ; }
Hyp: 
void predictTheWinner ( int K , int N ) { if ( N % ( K + 1 ) == 0 ) cout << " A " ; else cout << " B " ; }

BLEU: 85.43
Edit Sim: 8


Src: 
function countDigits ( a , b ) { var count = 0 ; var p = Math . abs ( parseInt ( a / b ) ) ; if ( p == 0 ) return 1 ; while ( p > 0 ) { count ++ ; p = parseInt ( p / 10 ) ; } return count ; }
Ref: 
int countDigits ( int a , int b ) { int count = 0 ; int p = abs ( a / b ) ; if ( p == 0 ) return 1 ; while ( p > 0 ) { count ++ ; p = p / 10 ; } return count ; }
Hyp: 
int countDigits ( int a , int b ) { int count = 0 ; int p = abs ( a / b ) ; if ( p == 0 ) return 1 ; while ( p > 0 ) { count ++ ; p = p / 10 ; } return count ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countSubstrings ( s , n ) { var count = 0 , sum = 0 ; var mp = new Map ( ) ; if ( mp . has ( 0 ) ) mp . set ( 0 , mp . get ( 0 ) + 1 ) else mp . set ( 0 , 1 ) ; for ( var i = 0 ; i < n ; ++ i ) { sum += ( s [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ) ; if ( mp . has ( sum - ( i + 1 ) ) ) count += mp . get ( sum - ( i + 1 ) ) ; if ( mp . has ( sum - ( i + 1 ) ) ) mp . set ( sum - ( i + 1 ) , mp . get ( sum - ( i + 1 ) ) + 1 ) else mp . set ( sum - ( i + 1 ) , 1 ) } return count ; }
Ref: 
int countSubstrings ( string s , int n ) { int count = 0 , sum = 0 ; unordered_map < int , int > mp ; mp [ 0 ] ++ ; for ( int i = 0 ; i < n ; ++ i ) { sum += ( s [ i ] - '0' ) ; count += mp [ sum - ( i + 1 ) ] ; ++ mp [ sum - ( i + 1 ) ] ; } return count ; }
Hyp: 
int countSubstrings ( string s , int n ) { int count = 0 , sum = 0 ; unordered_map < int , int > mp ; mp [ 0 ] ++ ; for ( int i = 0 ; i < n ; ++ i ) { sum += ( s [ i ] - ' a ' ) ; if ( mp . find ( sum - ( i + 1 ) ) != mp . end ( ) ) count += mp [ sum - ( i + 1 ) ] ; if ( mp . find ( sum - ( i + 1 ) ) != mp . end ( ) ) mp [ sum - ( i + 1 ) ] ++ ; } return count ; }

BLEU: 60.99
Edit Sim: 110


Src: 
function minToggle ( arr , n ) { let zero = new Array ( n + 1 ) ; zero [ 0 ] = 0 ; for ( let i = 1 ; i <= n ; ++ i ) { if ( arr [ i - 1 ] == 0 ) zero [ i ] = zero [ i - 1 ] + 1 ; else zero [ i ] = zero [ i - 1 ] ; } let ans = n ; for ( let i = 1 ; i <= n ; ++ i ) ans = Math . min ( ans , i - zero [ i ] + zero [ n ] - zero [ i ] ) ; return ans ; }
Ref: 
int minToggle ( int arr [ ] , int n ) { int zero [ n + 1 ] ; zero [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { if ( arr [ i - 1 ] == 0 ) zero [ i ] = zero [ i - 1 ] + 1 ; else zero [ i ] = zero [ i - 1 ] ; } int ans = n ; for ( int i = 1 ; i <= n ; ++ i ) ans = min ( ans , i - zero [ i ] + zero [ n ] - zero [ i ] ) ; return ans ; }
Hyp: 
int minToggle ( int arr [ ] , int n ) { int zero [ n + 1 ] ; zero [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { if ( arr [ i - 1 ] == 0 ) zero [ i ] = zero [ i - 1 ] + 1 ; else zero [ i ] = zero [ i - 1 ] ; } int ans = n ; for ( int i = 1 ; i <= n ; ++ i ) ans = min ( ans , i - zero [ i ] + zero [ n ] - zero [ i ] ) ; return ans ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findDigits ( n , b ) { if ( n < 0 ) return 0 ; if ( n <= 1 ) return 1 ; var M_PI = 3.141592 ; var M_E = 2.7182 ; var x = ( ( n * Math . log10 ( n / M_E ) + Math . log10 ( 2 * M_PI * n ) / 2.0 ) ) / ( Math . log10 ( b ) ) ; return Math . floor ( x ) + 1 ; }
Ref: 
long findDigits ( int n , int b ) { if ( n < 0 ) return 0 ; if ( n <= 1 ) return 1 ; double x = ( ( n * log10 ( n / M_E ) + log10 ( 2 * M_PI * n ) / 2.0 ) ) / ( log10 ( b ) ) ; return floor ( x ) + 1 ; }
Hyp: 
int findDigits ( int n , int b ) { if ( n < 0 ) return 0 ; if ( n <= 1 ) return 1 ; double M_PI = 3.141592 ; double M_E = 2.7182 ; double x = ( ( n * log10 ( n / M_E ) + log10 ( 2 * M_PI * n ) / 2.0 ) ) / ( log10 ( b ) ) ; return floor ( x ) + 1 ; }

BLEU: 86.01
Edit Sim: 50


Src: 
function unique ( s ) { let str = " " ; let len = s . length ; for ( let i = 0 ; i < len ; i ++ ) { let c = s [ i ] ; if ( str . indexOf ( c ) < 0 ) { str += c ; } } return str ; }
Ref: 
string unique ( string s ) { string str ; int len = s . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { char c = s [ i ] ; auto found = str . find ( c ) ; if ( found == std :: string :: npos ) { str += c ; } } return str ; }
Hyp: 
string unique ( string s ) { string str = " " ; int len = s . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { char c = s [ i ] ; if ( str . find ( c ) < 0 ) { str += c ; } } return str ; }

BLEU: 77.31
Edit Sim: 52


Src: 
function interchangeFirstLast ( m ) { let rows = m . length ; for ( let i = 0 ; i < m [ 0 ] . length ; i ++ ) { let t = m [ 0 ] [ i ] ; m [ 0 ] [ i ] = m [ rows - 1 ] [ i ] ; m [ rows - 1 ] [ i ] = t ; } } let m = [ [ 8 , 9 , 7 , 6 ] , [ 4 , 7 , 6 , 5 ] , [ 3 , 2 , 1 , 8 ] , [ 9 , 9 , 7 , 7 ] ] interchangeFirstLast ( m ) ; for ( let i = 0 ; i < m . length ; i ++ ) { for ( let j = 0 ; j < m [ 0 ] . length ; j ++ ) document . write ( m [ i ] [ j ] + " " ) ; document . write ( " " ) ; }
Ref: 
void interchangeFirstLast ( int m [ ] [ n ] ) { int rows = n ; for ( int i = 0 ; i < n ; i ++ ) { int t = m [ 0 ] [ i ] ; m [ 0 ] [ i ] = m [ rows - 1 ] [ i ] ; m [ rows - 1 ] [ i ] = t ; } }
Hyp: 
void interchangeFirstLast ( vector < vector < int > > & m ) { int rows = m . size ( ) ; for ( auto x : m ) { int t = m [ 0 ] [ i ] ; m [ 0 ] [ i ] = m [ rows - 1 ] [ i ] ; m [ rows - 1 ] [ i ] = t ; } }

BLEU: 69.08
Edit Sim: 45


Src: 
function evenbittogglenumber ( n ) { let res = 0 , count = 0 ; for ( let temp = n ; temp > 0 ; temp >>= 1 ) { if ( count % 2 == 0 ) res |= ( 1 << count ) ; count ++ ; } return n ^ res ; }
Ref: 
int evenbittogglenumber ( int n ) { int res = 0 , count = 0 ; for ( int temp = n ; temp > 0 ; temp >>= 1 ) { if ( count % 2 == 0 ) res |= ( 1 << count ) ; count ++ ; } return n ^ res ; }
Hyp: 
int evenbittogglenumber ( int n ) { int res = 0 , count = 0 ; for ( int temp = n ; temp > 0 ; temp >>= 1 ) { if ( count % 2 == 0 ) res |= ( 1 << count ) ; count ++ ; } return n ^ res ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function maxRegions ( n ) { let num ; num = parseInt ( n * ( n + 1 ) / 2 ) + 1 ; document . write ( num ) ; }
Ref: 
void maxRegions ( int n ) { int num ; num = n * ( n + 1 ) / 2 + 1 ; cout << num ; }
Hyp: 
void maxRegions ( int n ) { int num ; num = n * ( n + 1 ) / 2 + 1 ; cout << num ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function maxSubStrings ( s , k ) { var maxSubStr = 0 , n = s . length ; for ( var c = 0 ; c < 26 ; c ++ ) { var ch = String . fromCharCode ( " " . charCodeAt ( 0 ) + c ) ; var curr = 0 ; for ( var i = 0 ; i <= n - k ; i ++ ) { if ( s [ i ] !== ch ) continue ; var cnt = 0 ; while ( i < n && s [ i ] === ch && cnt !== k ) { i ++ ; cnt ++ ; } i -- ; if ( cnt === k ) curr ++ ; } maxSubStr = Math . max ( maxSubStr , curr ) ; } return maxSubStr ; }
Ref: 
int maxSubStrings ( string s , int k ) { int maxSubStr = 0 , n = s . size ( ) ; for ( int c = 0 ; c < 26 ; c ++ ) { char ch = ' a ' + c ; int curr = 0 ; for ( int i = 0 ; i <= n - k ; i ++ ) { if ( s [ i ] != ch ) continue ; int cnt = 0 ; while ( i < n && s [ i ] == ch && cnt != k ) { i ++ ; cnt ++ ; } i -- ; if ( cnt == k ) curr ++ ; } maxSubStr = max ( maxSubStr , curr ) ; } return maxSubStr ; }
Hyp: 
int maxSubStrings ( string s , int k ) { int maxSubStr = 0 , n = s . length ( ) ; for ( char c = 0 ; c < 26 ; c ++ ) { char ch = ( char ) ( ' A ' + c ) ; int curr = 0 ; for ( int i = 0 ; i <= n - k ; i ++ ) { if ( s [ i ] != ch ) continue ; int cnt = 0 ; while ( i < n && s [ i ] == ch && cnt != k ) { i ++ ; cnt ++ ; } i -- ; if ( cnt == k ) curr ++ ; } maxSubStr = max ( maxSubStr , curr ) ; } return maxSubStr ; }

BLEU: 89.48
Edit Sim: 24


Src: 
function findMaximumScore ( a , n ) { let freq = new Map ( ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( freq . has ( a [ i ] ) ) { freq . set ( a [ i ] , freq . get ( a [ i ] ) + 1 ) ; } else { freq . set ( a [ i ] , 1 ) ; } } let dp = new Array ( Math . max ( ... a ) + 1 ) ; dp [ 0 ] = 0 ; dp [ 1 ] = freq . get ( 1 ) ; for ( let i = 2 ; i < dp . length ; i ++ ) dp [ i ] = Math . max ( dp [ i - 1 ] , dp [ i - 2 ] + freq . get ( i ) * i ) ; return dp [ dp . length - 1 ] ; }
Ref: 
int findMaximumScore ( vector < int > a , int n ) { unordered_map < int , int > freq ; for ( int i = 0 ; i < n ; i ++ ) { freq [ a [ i ] ] ++ ; } vector < int > dp ( * max_element ( a . begin ( ) , a . end ( ) ) + 1 , 0 ) ; dp [ 0 ] = 0 ; dp [ 1 ] = freq [ 1 ] ; for ( int i = 2 ; i < dp . size ( ) ; i ++ ) dp [ i ] = max ( dp [ i - 1 ] , dp [ i - 2 ] + freq [ i ] * i ) ; return dp [ dp . size ( ) - 1 ] ; }
Hyp: 
int findMaximumScore ( int a [ ] , int n ) { unordered_map < int , int > freq ; for ( int i = 0 ; i < n ; i ++ ) { freq [ a [ i ] ] ++ ; } int dp [ n + 1 ] ; dp [ 0 ] = 0 ; dp [ 1 ] = freq [ 1 ] ; for ( int i = 2 ; i < dp . size ( ) ; i ++ ) dp [ i ] = max ( dp [ i - 1 ] , dp [ i - 2 ] + freq [ i ] * i ) ; return dp [ dp . size ( ) - 1 ] ; }

BLEU: 77.54
Edit Sim: 73


Src: 
function numberOfPaths ( m , n ) { var count = Array ( m ) . fill ( 0 ) . map ( x => Array ( n ) . fill ( 0 ) ) ; for ( i = 0 ; i < m ; i ++ ) count [ i ] [ 0 ] = 1 ; for ( j = 0 ; j < n ; j ++ ) count [ 0 ] [ j ] = 1 ; for ( i = 1 ; i < m ; i ++ ) { for ( j = 1 ; j < n ; j ++ ) count [ i ] [ j ] = count [ i - 1 ] [ j ] + count [ i ] [ j - 1 ] + count [ i - 1 ] [ j - 1 ] ; ; } return count [ m - 1 ] [ n - 1 ] ; }
Ref: 
int numberOfPaths ( int m , int n ) { int count [ m ] [ n ] ; for ( int i = 0 ; i < m ; i ++ ) count [ i ] [ 0 ] = 1 ; for ( int j = 0 ; j < n ; j ++ ) count [ 0 ] [ j ] = 1 ; for ( int i = 1 ; i < m ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) } return count [ m - 1 ] [ n - 1 ] ; }
Hyp: 
int numberOfPaths ( int m , int n ) { int count [ m ] [ n ] ; for ( int i = 0 ; i < m ; i ++ ) count [ i ] [ 0 ] = 1 ; for ( int j = 0 ; j < n ; j ++ ) count [ 0 ] [ j ] = 1 ; for ( int i = 1 ; i < m ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) count [ i ] [ j ] = count [ i - 1 ] [ j ] + count [ i ] [ j - 1 ] + count [ i - 1 ] [ j - 1 ] ; ; } return count [ m - 1 ] [ n - 1 ] ; }

BLEU: 71.93
Edit Sim: 98


Src: 
function findMinDiff ( arr , n ) { arr . sort ( function ( a , b ) { return a - b } ) ; let diff = Number . MAX_VALUE ; for ( let i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i + 1 ] - arr [ i ] < diff ) diff = arr [ i + 1 ] - arr [ i ] ; return diff ; }
Ref: 
int findMinDiff ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int diff = INT_MAX ; for ( int i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i + 1 ] - arr [ i ] < diff ) diff = arr [ i + 1 ] - arr [ i ] ; return diff ; }
Hyp: 
int findMinDiff ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int diff = INT_MAX ; for ( int i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i + 1 ] - arr [ i ] < diff ) diff = arr [ i + 1 ] - arr [ i ] ; return diff ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function checkFibinnary ( n ) { var prev_last = 0 ; while ( n != 0 ) { if ( ( n & 1 ) != 0 && prev_last != 0 ) return false ; prev_last = n & 1 ; n >>= 1 ; } return true ; }
Ref: 
bool checkFibinnary ( int n ) { int prev_last = 0 ; while ( n ) { if ( ( n & 1 ) && prev_last ) return false ; prev_last = n & 1 ; n >>= 1 ; } return true ; }
Hyp: 
bool checkFibinnary ( unsigned int n ) { unsigned int prev_last = 0 ; while ( n ) { if ( ( n & 1 ) != 0 && prev_last != 0 ) return false ; prev_last = n & 1 ; n >>= 1 ; } return true ; }

BLEU: 76.04
Edit Sim: 28


Src: 
function checkPointRange ( arr , X , Y , N ) { for ( let i = 0 ; i < N ; i ++ ) { let dist = Math . sqrt ( ( arr [ i ] [ 0 ] - X ) * ( arr [ i ] [ 0 ] - X ) + ( arr [ i ] [ 1 ] - Y ) * ( arr [ i ] [ 1 ] - Y ) ) ; if ( dist <= arr [ i ] [ 2 ] ) { return true ; } } return false ; } let arr = [ [ 1 , 1 , 3 ] , [ 10 , 10 , 3 ] , [ 15 , 15 , 15 ] ] ; let X = 5 , Y = 5 ; let N = arr . length ; if ( checkPointRange ( arr , X , Y , N ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
Ref: 
bool checkPointRange ( int arr [ ] [ 3 ] , int X , int Y , int N ) { for ( int i = 0 ; i < N ; i ++ ) { double dist = sqrt ( ( arr [ i ] [ 0 ] - X ) * ( arr [ i ] [ 0 ] - X ) + ( arr [ i ] [ 1 ] - Y ) * ( arr [ i ] [ 1 ] - Y ) ) ; if ( dist <= arr [ i ] [ 2 ] ) { return true ; } } return false ; }
Hyp: 
bool checkPointRange ( int arr [ ] [ 3 ] , int X , int Y , int N ) { for ( int i = 0 ; i < N ; i ++ ) { int dist = sqrt ( ( arr [ i ] [ 0 ] - X ) * ( arr [ i ] [ 0 ] - X ) + ( arr [ i ] [ 1 ] - Y ) * ( arr [ i ] [ 1 ] - Y ) ) ; if ( dist <= arr [ i ] [ 2 ] ) { return true ; } } return false ; }

BLEU: 97.74
Edit Sim: 6


Src: 
function minCost ( A , n ) { var cost = 0 ; A . sort ( ) ; var K = A [ parseInt ( n / 2 ) ] ; var i ; for ( i = 0 ; i < n ; ++ i ) cost += Math . abs ( A [ i ] - K ) ; if ( n % 2 == 0 ) { var tempCost = 0 ; K = A [ parseInt ( n / 2 ) - 1 ] ; for ( i = 0 ; i < n ; ++ i ) tempCost += Math . abs ( A [ i ] - K ) ; cost = Math . min ( cost , tempCost ) ; } return cost ; }
Ref: 
int minCost ( int A [ ] , int n ) { int cost = 0 ; sort ( A , A + n ) ; int K = A [ n / 2 ] ; for ( int i = 0 ; i < n ; ++ i ) cost += abs ( A [ i ] - K ) ; if ( n % 2 == 0 ) { int tempCost = 0 ; K = A [ ( n / 2 ) - 1 ] ; for ( int i = 0 ; i < n ; ++ i ) tempCost += abs ( A [ i ] - K ) ; cost = min ( cost , tempCost ) ; } return cost ; }
Hyp: 
int minCost ( int A [ ] , int n ) { int cost = 0 ; sort ( A , A + n ) ; int K = A [ n / 2 ] ; int i ; for ( i = 0 ; i < n ; ++ i ) cost += abs ( A [ i ] - K ) ; if ( n % 2 == 0 ) { int tempCost = 0 ; K = A [ n / 2 - 1 ] ; for ( i = 0 ; i < n ; ++ i ) tempCost += abs ( A [ i ] - K ) ; cost = min ( cost , tempCost ) ; } return cost ; }

BLEU: 91.87
Edit Sim: 19


Src: 
function maxPrefix ( s , t ) { let count = 0 ; for ( let i = 0 ; i < t . length ; i ++ ) { if ( count == s . length ) break ; if ( t [ i ] == s [ count ] ) count ++ ; } return count ; }
Ref: 
int maxPrefix ( char s [ ] , char t [ ] ) { int count = 0 ; for ( int i = 0 ; i < strlen ( t ) ; i ++ ) { if ( count == strlen ( s ) ) break ; if ( t [ i ] == s [ count ] ) count ++ ; } return count ; }
Hyp: 
int maxPrefix ( string s , string t ) { int count = 0 ; for ( int i = 0 ; i < t . length ( ) ; i ++ ) { if ( count == s . length ( ) ) break ; if ( t [ i ] == s [ count ] ) count ++ ; } return count ; }

BLEU: 73.35
Edit Sim: 31


Src: 
function largestCoprime ( N ) { if ( N == 6 ) return 1 ; else if ( N % 4 == 0 ) return ( N / 2 ) - 1 ; else if ( N % 2 == 0 ) return ( N / 2 ) - 2 ; else return ( ( N - 1 ) / 2 ) ; }
Ref: 
long largestCoprime ( long long N ) { if ( N == 6 ) return 1 ; else if ( N % 4 == 0 ) return ( N / 2 ) - 1 ; else if ( N % 2 == 0 ) return ( N / 2 ) - 2 ; else return ( ( N - 1 ) / 2 ) ; }
Hyp: 
int largestCoprime ( int N ) { if ( N == 6 ) return 1 ; else if ( N % 4 == 0 ) return ( N / 2 ) - 1 ; else if ( N % 2 == 0 ) return ( N / 2 ) - 2 ; else return ( ( N - 1 ) / 2 ) ; }

BLEU: 93.48
Edit Sim: 11


Src: 
function CountPair ( L , R ) { let x = ( R - L + 1 ) ; document . write ( x / 2 + " " ) ; }
Ref: 
void CountPair ( int L , int R ) { int x = ( R - L + 1 ) ; cout << x / 2 << " STRNEWLINE " ; }
Hyp: 
void CountPair ( int L , int R ) { int x = ( R - L + 1 ) ; cout << x / 2 << endl ; }

BLEU: 86.27
Edit Sim: 14


Src: 
function geometricMean ( n ) { return Math . sqrt ( n ) ; }
Ref: 
int geometricMean ( int n ) { return sqrt ( n ) ; }
Hyp: 
double geometricMean ( int n ) { return sqrt ( n ) ; }

BLEU: 92.54
Edit Sim: 6


Src: 
function productPuzzle ( a , n ) { var sum = 0 ; for ( var i = 0 ; i < n ; i ++ ) sum += Math . log10 ( a [ i ] ) ; for ( var i = 0 ; i < n ; i ++ ) document . write ( parseInt ( ( EPS + Math . pow ( 10.00 , sum - Math . log10 ( a [ i ] ) ) ) ) + " " ) ; }
Ref: 
void productPuzzle ( int a [ ] , int n ) { long double sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += ( long double ) log10 ( a [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) cout << ( int ) ( EPS + pow ( ( long double ) 10.00 , sum - log10 ( a [ i ] ) ) ) << " ▁ " ; }
Hyp: 
void productPuzzle ( int a [ ] , int n ) { double sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += log10 ( a [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) cout << pow ( 10.00 , sum - log10 ( a [ i ] ) ) << " ▁ " ; }

BLEU: 74.64
Edit Sim: 55


Src: 
function findCount ( arr , n ) { let res = 0 ; for ( let i = 0 ; i < n - 1 ; i ++ ) for ( let j = i + 1 ; j < n ; j ++ ) if ( ( arr [ i ] % 2 == 0 ) && ( arr [ j ] % 2 == 1 ) ) { res ++ ; } return res ; }
Ref: 
int findCount ( int arr [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( ( arr [ i ] % 2 == 0 ) && ( arr [ j ] % 2 == 1 ) ) { res ++ ; } return res ; }
Hyp: 
int findCount ( int arr [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( ( arr [ i ] % 2 == 0 ) && ( arr [ j ] % 2 == 1 ) ) { res ++ ; } return res ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function maxTripletSum ( arr , n ) { let sum = - 1000000 ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = i + 1 ; j < n ; j ++ ) for ( let k = j + 1 ; k < n ; k ++ ) if ( sum < arr [ i ] + arr [ j ] + arr [ k ] ) sum = arr [ i ] + arr [ j ] + arr [ k ] ; return sum ; }
Ref: 
int maxTripletSum ( int arr [ ] , int n ) { int sum = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) for ( int k = j + 1 ; k < n ; k ++ ) if ( sum < arr [ i ] + arr [ j ] + arr [ k ] ) sum = arr [ i ] + arr [ j ] + arr [ k ] ; return sum ; }
Hyp: 
int maxTripletSum ( int arr [ ] , int n ) { int sum = -1 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) for ( int k = j + 1 ; k < n ; k ++ ) if ( sum < arr [ i ] + arr [ j ] + arr [ k ] ) sum = arr [ i ] + arr [ j ] + arr [ k ] ; return sum ; }

BLEU: 97.54
Edit Sim: 7


Src: 
function mod ( a , m ) { return ( a % m + m ) % m ; }
Ref: 
int mod ( int a , int m ) { return ( a % m + m ) % m ; }
Hyp: 
int mod ( int a , int m ) { return ( a % m + m ) % m ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function numberOfMinutes ( S , S1 ) { let Min = 0 ; Min = ( ( S - S1 ) / Math . floor ( S ) ) * 60 ; return Min ; }
Ref: 
int numberOfMinutes ( int S , int S1 ) { int Min = 0 ; Min = ( ( S - S1 ) / floor ( S ) ) * 60 ; return Min ; }
Hyp: 
int numberOfMinutes ( int S , int S1 ) { int Min = 0 ; Min = ( ( S - S1 ) / floor ( S ) ) * 60 ; return Min ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findSum ( N , K ) { let ans = 0 ; let y = N / K ; let x = N % K ; ans = ( K * ( K - 1 ) / 2 ) * y + ( x * ( x + 1 ) ) / 2 ; return ans ; }
Ref: 
int findSum ( int N , int K ) { int ans = 0 ; int y = N / K ; int x = N % K ; ans = ( K * ( K - 1 ) / 2 ) * y + ( x * ( x + 1 ) ) / 2 ; return ans ; }
Hyp: 
int findSum ( int N , int K ) { int ans = 0 ; int y = N / K ; int x = N % K ; ans = ( K * ( K - 1 ) / 2 ) * y + ( x * ( x + 1 ) ) / 2 ; return ans ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function NumberOfRectangles ( n , m ) { if ( n % 2 == 0 ) return ( n / 2 ) * m ; else if ( m % 2 == 0 ) return ( m / 2 ) * n ; return ( n * m - 1 ) / 2 ; }
Ref: 
int NumberOfRectangles ( int n , int m ) { if ( n % 2 == 0 ) return ( n / 2 ) * m ; else if ( m % 2 == 0 ) return ( m / 2 ) * n ; return ( n * m - 1 ) / 2 ; }
Hyp: 
int NumberOfRectangles ( int n , int m ) { if ( n % 2 == 0 ) return ( n / 2 ) * m ; else if ( m % 2 == 0 ) return ( m / 2 ) * n ; return ( n * m - 1 ) / 2 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function minTotalDistance ( grid ) { if ( ROW == 0 COL == 0 ) return 0 ; let vertical = [ ] ; let horizontal = [ ] ; for ( let i = 0 ; i < ROW ; i ++ ) { for ( let j = 0 ; j < COL ; j ++ ) { if ( grid [ i ] [ j ] == 1 ) { vertical . push ( i ) ; horizontal . push ( j ) ; } } } ( vertical ) . sort ( function ( a , b ) { return a - b ; } ) ; ( horizontal ) . sort ( function ( a , b ) { return a - b ; } ) ; let size = vertical . length / 2 ; let x = vertical [ size ] ; let y = horizontal [ size ] ; let distance = 0 ; for ( let i = 0 ; i < ROW ; i ++ ) for ( let j = 0 ; j < COL ; j ++ ) if ( grid [ i ] [ j ] == 1 ) distance += Math . abs ( x - i ) + Math . abs ( y - j ) ; return distance ; }
Ref: 
int minTotalDistance ( int grid [ ] [ COL ] ) { if ( ROW == 0 COL == 0 ) return 0 ; vector < int > vertical ; vector < int > horizontal ; for ( int i = 0 ; i < ROW ; i ++ ) { for ( int j = 0 ; j < COL ; j ++ ) { if ( grid [ i ] [ j ] == 1 ) { vertical . push_back ( i ) ; horizontal . push_back ( j ) ; } } } sort ( vertical . begin ( ) , vertical . end ( ) ) ; sort ( horizontal . begin ( ) , horizontal . end ( ) ) ; int size = vertical . size ( ) / 2 ; int x = vertical [ size ] ; int y = horizontal [ size ] ; int distance = 0 ; for ( int i = 0 ; i < ROW ; i ++ ) for ( int j = 0 ; j < COL ; j ++ ) if ( grid [ i ] [ j ] == 1 ) distance += abs ( x - i ) + abs ( y - j ) ; return distance ; }
Hyp: 
int minTotalDistance ( int grid [ ] [ COL ] ) { if ( ROW == 0 COL == 0 ) return 0 ; vector < int > vertical ; vector < int > horizontal ; for ( int i = 0 ; i < ROW ; i ++ ) { for ( int j = 0 ; j < COL ; j ++ ) { if ( grid [ i ] [ j ] == 1 ) { vertical . push_back ( i ) ; horizontal . push_back ( j ) ; } } } ( vertical ) . sort ( ) ; ( horizontal ) . sort ( ) ; int size = vertical . size ( ) / 2 ; int x = vertical [ size ] ; int y = horizontal [ size ] ; int distance = 0 ; for ( int i = 0 ; i < ROW ; i ++ ) for ( int j = 0 ; j < COL ; j ++ ) if ( grid [ i ] [ j ] == 1 ) distance += abs ( x - i ) + abs ( y - j ) ; return distance ; }

BLEU: 88.59
Edit Sim: 61


Src: 
function toggleLastMBits ( n , m ) { var num = ( 1 << m ) - 1 ; return ( n ^ num ) ; }
Ref: 
int toggleLastMBits ( unsigned int n , unsigned int m ) { unsigned int num = ( 1 << m ) - 1 ; return ( n ^ num ) ; }
Hyp: 
int toggleLastMBits ( int n , int m ) { int num = ( 1 << m ) - 1 ; return ( n ^ num ) ; }

BLEU: 74.65
Edit Sim: 27


Src: 
function GetMinSubarrayLength ( a , n ) { var ans = Math . max ( a [ 0 ] , a [ n - 1 ] ) ; var lo = 0 , hi = n - 1 ; while ( lo < n && a [ lo ] % ans == 0 ) lo ++ ; while ( hi > lo && a [ hi ] % ans == 0 ) hi -- ; return ( hi - lo + 1 ) ; }
Ref: 
int GetMinSubarrayLength ( int a [ ] , int n ) { int ans = max ( a [ 0 ] , a [ n - 1 ] ) ; int lo = 0 , hi = n - 1 ; while ( lo < n and a [ lo ] % ans == 0 ) lo ++ ; while ( hi > lo and a [ hi ] % ans == 0 ) hi -- ; return ( hi - lo + 1 ) ; }
Hyp: 
int GetMinSubarrayLength ( int a [ ] , int n ) { int ans = max ( a [ 0 ] , a [ n - 1 ] ) ; int lo = 0 , hi = n - 1 ; while ( lo < n && a [ lo ] % ans == 0 ) lo ++ ; while ( hi > lo && a [ hi ] % ans == 0 ) hi -- ; return ( hi - lo + 1 ) ; }

BLEU: 94.15
Edit Sim: 6


Src: 
function sumOfDivisors ( N ) { return N ; }
Ref: 
int sumOfDivisors ( int N ) { return N ; }
Hyp: 
int sumOfDivisors ( int N ) { return N * ( int ) N ; }

BLEU: 61.77
Edit Sim: 12


Src: 
function smallestMultiple ( n ) { if ( n == 1 ) return 5 ; return Math . pow ( 10 , n - 1 ) ; }
Ref: 
int smallestMultiple ( int n ) { if ( n == 1 ) return 5 ; return pow ( 10 , n - 1 ) ; }
Hyp: 
int smallestMultiple ( int n ) { if ( n == 1 ) return 5 ; return pow ( 10 , n - 1 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function series ( n ) { return ( 8 * n * n ) + 1 ; }
Ref: 
int series ( int n ) { return ( 8 * n * n ) + 1 ; }
Hyp: 
int series ( int n ) { return ( 8 * n * n ) + 1 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function calculate_minimum_split ( n , a , k ) { let p = Array . from ( { length : n - 1 } , ( _ , i ) => 0 ) ; for ( let i = 1 ; i < n ; i ++ ) p [ i - 1 ] = a [ i ] - a [ i - 1 ] ; p . sort ( ( a , b ) => a - b ) ; p . reverse ( ) ; let min_sum = 0 ; for ( let i = 0 ; i < k - 1 ; i ++ ) min_sum += p [ i ] ; let res = a [ n - 1 ] - a [ 0 ] - min_sum ; return res ; }
Ref: 
int calculate_minimum_split ( int n , int a [ ] , int k ) { int p [ n - 1 ] ; for ( int i = 1 ; i < n ; i ++ ) p [ i - 1 ] = a [ i ] - a [ i - 1 ] ; sort ( p , p + n - 1 , greater < int > ( ) ) ; int min_sum = 0 ; for ( int i = 0 ; i < k - 1 ; i ++ ) min_sum += p [ i ] ; int res = a [ n - 1 ] - a [ 0 ] - min_sum ; return res ; }
Hyp: 
int calculate_minimum_split ( int n , int a [ ] , int k ) { vector < int > p ( n - 1 , 0 ) ; for ( int i = 1 ; i < n ; i ++ ) p [ i - 1 ] = a [ i ] - a [ i - 1 ] ; sort ( p . begin ( ) , p . end ( ) ) ; int min_sum = 0 ; for ( int i = 0 ; i < k - 1 ; i ++ ) min_sum += p [ i ] ; int res = a [ n - 1 ] - a [ 0 ] - min_sum ; return res ; }

BLEU: 85.38
Edit Sim: 36


Src: 
function areBookingsPossible ( A , B , K , N ) { A . sort ( ) ; B . sort ( ) ; for ( let i = 0 ; i < N ; i ++ ) { if ( i + K < N && A [ i + K ] < B [ i ] ) { return " " ; } } return " " ; }
Ref: 
string areBookingsPossible ( int A [ ] , int B [ ] , int K , int N ) { sort ( A , A + N ) ; sort ( B , B + N ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( i + K < N && A [ i + K ] < B [ i ] ) { return " No " ; } } return " Yes " ; }
Hyp: 
string areBookingsPossible ( int A [ ] , int B [ ] , int K , int N ) { sort ( A , A + N ) ; sort ( B , B + N ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( i + K < N && A [ i + K ] < B [ i ] ) { return " NO " ; } } return " YES " ; }

BLEU: 94.15
Edit Sim: 3


Src: 
function findMaxAverage ( arr , n , k ) { if ( k > n ) return - 1 ; let csum = new Array ( n ) ; csum [ 0 ] = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) csum [ i ] = csum [ i - 1 ] + arr [ i ] ; let max_sum = csum [ k - 1 ] , max_end = k - 1 ; for ( let i = k ; i < n ; i ++ ) { let curr_sum = csum [ i ] - csum [ i - k ] ; if ( curr_sum > max_sum ) { max_sum = curr_sum ; max_end = i ; } } return max_end - k + 1 ; }
Ref: 
int findMaxAverage ( int arr [ ] , int n , int k ) { if ( k > n ) return -1 ; int * csum = new int [ n ] ; csum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) csum [ i ] = csum [ i - 1 ] + arr [ i ] ; int max_sum = csum [ k - 1 ] , max_end = k - 1 ; for ( int i = k ; i < n ; i ++ ) { int curr_sum = csum [ i ] - csum [ i - k ] ; if ( curr_sum > max_sum ) { max_sum = curr_sum ; max_end = i ; } } delete [ ] csum ; return max_end - k + 1 ; }
Hyp: 
int findMaxAverage ( int arr [ ] , int n , int k ) { if ( k > n ) return -1 ; int csum [ n ] ; csum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) csum [ i ] = csum [ i - 1 ] + arr [ i ] ; int max_sum = csum [ k - 1 ] , max_end = k - 1 ; for ( int i = k ; i < n ; i ++ ) { int curr_sum = csum [ i ] - csum [ i - k ] ; if ( curr_sum > max_sum ) { max_sum = curr_sum ; max_end = i ; } } return max_end - k + 1 ; }

BLEU: 91.34
Edit Sim: 30


Src: 
function towerOfHanoi ( n , from_rod , to_rod , aux_rod ) { if ( n == 1 ) { document . write ( " " + from_rod + " " + to_rod + " " ) ; return ; } towerOfHanoi ( n - 1 , from_rod , aux_rod , to_rod ) ; document . write ( " " + n + " " + from_rod + " " + to_rod + " " ) ; towerOfHanoi ( n - 1 , aux_rod , to_rod , from_rod ) ; }
Ref: 
void towerOfHanoi ( int n , char from_rod , char to_rod , char aux_rod ) { if ( n == 1 ) { cout << " Move ▁ disk ▁ 1 ▁ from ▁ rod ▁ " << from_rod << " ▁ to ▁ rod ▁ " << to_rod << endl ; return ; } towerOfHanoi ( n - 1 , from_rod , aux_rod , to_rod ) ; cout << " Move ▁ disk ▁ " << n << " ▁ from ▁ rod ▁ " << from_rod << " ▁ to ▁ rod ▁ " << to_rod << endl ; towerOfHanoi ( n - 1 , aux_rod , to_rod , from_rod ) ; }
Hyp: 
void towerOfHanoi ( int n , int from_rod , int to_rod , int aux_rod ) { if ( n == 1 ) { cout << " No " << from_rod << " ▁ " << to_rod << " ▁ " ; return ; } towerOfHanoi ( n - 1 , from_rod , aux_rod , to_rod ) ; cout << " Yes " << n << " ▁ " << from_rod << " ▁ " << to_rod << " ▁ " ; towerOfHanoi ( n - 1 , aux_rod , to_rod , from_rod ) ; }

BLEU: 61.14
Edit Sim: 97


Src: 
function Remainder ( str , R ) { var len = str . length ; var Num , Rem = 0 ; for ( var i = 0 ; i < len ; i ++ ) { Num = Rem * 10 + ( str [ i ] - ' ' ) ; Rem = Num % R ; } return Rem ; }
Ref: 
int Remainder ( string str , int R ) { int len = str . length ( ) ; int Num , Rem = 0 ; for ( int i = 0 ; i < len ; i ++ ) { Num = Rem * 10 + ( str [ i ] - '0' ) ; Rem = Num % R ; } return Rem ; }
Hyp: 
int Remainder ( string str , int R ) { int len = str . length ( ) ; int Num , Rem = 0 ; for ( int i = 0 ; i < len ; i ++ ) { Num = Rem * 10 + ( str [ i ] - '0' ) ; Rem = Num % R ; } return Rem ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function calculate ( arr ) { let n = arr . length ; let ans = [ ] ; for ( let i = 0 ; i < arr . length ; i ++ ) { let sum = 0 ; for ( let j = 0 ; j < arr . length ; j ++ ) { sum += Math . abs ( arr [ i ] - arr [ j ] ) ; } ans . push ( sum ) ; } return ans ; }
Ref: 
> calculate ( int * arr , int n ) { vector < int > ans ; for ( int i = 0 ; i < n ; i ++ ) { int sum = 0 ; for ( int j = 0 ; j < n ; j ++ ) { sum += abs ( arr [ i ] - arr [ j ] ) ; } ans . push_back ( sum ) ; } return ans ; }
Hyp: 
int calculate ( int arr [ ] , int n ) { int ans [ ] ; for ( int i = 0 ; i < n ; i ++ ) { int sum = 0 ; for ( int j = 0 ; j < arr . length ( ) ; j ++ ) { sum += abs ( arr [ i ] - arr [ j ] ) ; } ans . push_back ( sum ) ; } return ans ; }

BLEU: 79.68
Edit Sim: 37


Src: 
function productOfSingelDgt ( n ) { if ( n >= 0 && n <= 9 ) return true ; var prime = [ 2 , 3 , 5 , 7 ] ; for ( i = 0 ; i < SIZE && n > 1 ; i ++ ) while ( n % prime [ i ] == 0 ) n = n / prime [ i ] ; return ( n == 1 ) ; }
Ref: 
bool productOfSingelDgt ( int n ) { if ( n >= 0 && n <= 9 ) return true ; int prime [ ] = { 2 , 3 , 5 , 7 } ; for ( int i = 0 ; i < SIZE && n > 1 ; i ++ ) while ( n % prime [ i ] == 0 ) n = n / prime [ i ] ; return ( n == 1 ) ; }
Hyp: 
bool productOfSingelDgt ( int n ) { if ( n >= 0 && n <= 9 ) return true ; int prime [ SIZE ] ; for ( int i = 0 ; i < SIZE && n > 1 ; i ++ ) while ( n % prime [ i ] == 0 ) n = n / prime [ i ] ; return ( n == 1 ) ; }

BLEU: 84.19
Edit Sim: 20


Src: 
function bitonicSequence ( num , lower , upper ) { if ( num > ( upper - lower ) * 2 + 1 ) { document . write ( - 1 ) ; return ; } var ans = [ ] ; for ( var i = 0 ; i < Math . min ( upper - lower + 1 , num - 1 ) ; i ++ ) ans . push ( upper - i ) ; for ( var i = 0 ; i < num - ans . length ; i ++ ) { ans . splice ( 0 , 0 , upper - i - 1 ) } document . write ( ' ' ) ; ans . forEach ( element => { document . write ( " " + element ) ; } ) ; document . write ( ' ' + ' ' ) ; }
Ref: 
void bitonicSequence ( int num , int lower , int upper ) { if ( num > ( upper - lower ) * 2 + 1 ) { cout << -1 ; return ; } deque < int > ans ; deque < int > :: iterator j = ans . begin ( ) ; for ( int i = 0 ; i < min ( upper - lower + 1 , num - 1 ) ; i ++ ) ans . push_back ( upper - i ) ; for ( int i = 0 ; i < num - ans . size ( ) ; i ++ ) ans . push_front ( upper - i - 1 ) ; cout << ' [ ' ; for ( j = ans . begin ( ) ; j != ans . end ( ) ; ++ j ) cout << ' ▁ ' << * j ; cout << ' ▁ ' << ' ] ' ; }
Hyp: 
void bitonicSequence ( int num , int lower , int upper ) { if ( num > ( upper - lower ) * 2 + 1 ) { cout << -1 ; return ; } vector < int > ans ; for ( int i = 0 ; i < min ( upper - lower + 1 , num - 1 ) ; i ++ ) ans . push_back ( upper - i ) ; for ( int i = 0 ; i < num - ans . size ( ) ; i ++ ) { ans . erase ( 0 , 0 , upper - i - 1 ) ; } cout << ' ▁ ' ; ans . reverse ( ) ; cout << ' STRNEWLINE ' ; }

BLEU: 62.74
Edit Sim: 142


Src: 
function findMaximumGcd ( n ) { let max_gcd = 1 ; for ( let i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( i > max_gcd ) max_gcd = i ; if ( ( n / i != i ) && ( n / i != n ) && ( ( n / i ) > max_gcd ) ) max_gcd = n / i ; } } return max_gcd ; }
Ref: 
int findMaximumGcd ( int n ) { int max_gcd = 1 ; for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( i > max_gcd ) max_gcd = i ; if ( ( n / i != i ) && ( n / i != n ) && ( ( n / i ) > max_gcd ) ) max_gcd = n / i ; } } return max_gcd ; }
Hyp: 
int findMaximumGcd ( int n ) { int max_gcd = 1 ; for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( i > max_gcd ) max_gcd = i ; if ( ( n / i != i ) && ( n / i != n ) && ( ( n / i ) > max_gcd ) ) max_gcd = n / i ; } } return max_gcd ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findMax ( n , a , b , k , m ) { let arr = new Array ( n ) ; arr . fill ( 0 ) ; for ( let i = 0 ; i < m ; i ++ ) { let lowerbound = a [ i ] ; let upperbound = b [ i ] ; for ( let j = lowerbound ; j <= upperbound ; j ++ ) arr [ j ] += k [ i ] ; } let res = Number . MIN_VALUE ; for ( let i = 0 ; i < n ; i ++ ) res = Math . max ( res , arr [ i ] ) ; return res ; }
Ref: 
int findMax ( int n , int a [ ] , int b [ ] , int k [ ] , int m ) { int arr [ n ] ; memset ( arr , 0 , sizeof ( arr ) ) ; for ( int i = 0 ; i < m ; i ++ ) { int lowerbound = a [ i ] ; int upperbound = b [ i ] ; for ( int j = lowerbound ; j <= upperbound ; j ++ ) arr [ j ] += k [ i ] ; } int res = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) res = max ( res , arr [ i ] ) ; return res ; }
Hyp: 
int findMax ( int n , int a [ ] , int b [ ] , int k [ ] , int m ) { int arr [ n ] ; memset ( arr , 0 , sizeof ( arr ) ) ; for ( int i = 0 ; i < m ; i ++ ) { int lowerbound = a [ i ] ; int upperbound = b [ i ] ; for ( int j = lowerbound ; j <= upperbound ; j ++ ) arr [ j ] += k [ i ] ; } int res = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) res = max ( res , arr [ i ] ) ; return res ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function sum ( n ) { let sum = 0 ; let fact = 1 ; for ( let i = 1 ; i <= n ; i ++ ) { fact *= i ; sum += 1.0 / fact ; } return sum . toFixed ( 5 ) ; }
Ref: 
double sum ( int n ) { double sum = 0 ; int fact = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { fact *= i ; sum += 1.0 / fact ; } return sum ; }
Hyp: 
double sum ( int n ) { double sum = 0 ; double fact = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { fact *= i ; sum += 1.0 / fact ; } return sum ; }

BLEU: 94.53
Edit Sim: 6


Src: 
function countSubsets ( a , n ) { let answer = 0 ; for ( let i = 0 ; i < ( 1 << n ) ; i ++ ) { let bitwiseAND = - 1 ; let bitwiseOR = 0 ; let bitwiseXOR = 0 ; for ( let j = 0 ; j < n ; j ++ ) { if ( ( i & ( 1 << j ) ) != 0 ) { if ( bitwiseAND == - 1 ) bitwiseAND = a [ j ] ; else bitwiseAND &= a [ j ] ; bitwiseOR |= a [ j ] ; bitwiseXOR ^= a [ j ] ; } } if ( bitwiseAND == bitwiseOR && bitwiseOR == bitwiseXOR ) answer = ( answer + 1 ) % mod ; } return answer ; }
Ref: 
int countSubsets ( int a [ ] , int n ) { int answer = 0 ; for ( int i = 0 ; i < ( 1 << n ) ; i ++ ) { int bitwiseAND = -1 ; int bitwiseOR = 0 ; int bitwiseXOR = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( i & ( 1 << j ) ) { if ( bitwiseAND == -1 ) bitwiseAND = a [ j ] ; else bitwiseAND &= a [ j ] ; bitwiseOR |= a [ j ] ; bitwiseXOR ^= a [ j ] ; } } if ( bitwiseAND == bitwiseOR && bitwiseOR == bitwiseXOR ) answer = ( answer + 1 ) % mod ; } return answer ; }
Hyp: 
int countSubsets ( int a [ ] , int n ) { int answer = 0 ; for ( int i = 0 ; i < ( 1 << n ) ; i ++ ) { int bitwiseAND = -1 ; int bitwiseOR = 0 ; int bitwiseXOR = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( i & ( 1 << j ) ) != 0 ) { if ( bitwiseAND == -1 ) bitwiseAND = a [ j ] ; else bitwiseAND &= a [ j ] ; bitwiseOR |= a [ j ] ; bitwiseXOR ^= a [ j ] ; } } if ( bitwiseAND == bitwiseOR && bitwiseOR == bitwiseXOR ) answer = ( answer + 1 ) % mod ; } return answer ; }

BLEU: 96.12
Edit Sim: 9


Src: 
function RemoveHTMLTags ( s ) { const pattern = new RegExp ( " \\ \\ " ) ; s = new String ( s ) . replace ( pattern , " " ) ; document . write ( s ) ; return ; }
Ref: 
void RemoveHTMLTags ( string s ) { const regex pattern ( " \\ < . * ? \\ > " ) ; s = regex_replace ( s , pattern , " " ) ; cout << s ; return ; }
Hyp: 
void RemoveHTMLTags ( string s ) { const string pattern = " (^|\\s)" ; s = s . replace ( pattern , " ▁ " ) ; cout << s ; return ; }

BLEU: 46.96
Edit Sim: 35


Src: 
function deleteAlt ( head ) { if ( head == null ) return ; var node = head . next ; if ( node == null ) return ; head . next = node . next ; head . next = deleteAlt ( head . next ) ; }
Ref: 
void deleteAlt ( Node * head ) { if ( head == NULL ) return ; Node * node = head -> next ; if ( node == NULL ) return ; head -> next = node -> next ; free ( node ) ; deleteAlt ( head -> next ) ; }
Hyp: 
void deleteAlt ( Node * head ) { if ( head == NULL ) return ; Node * node = head -> next ; if ( node == NULL ) return ; head -> next = node -> next ; head -> next = deleteAlt ( head . next ) ; }

BLEU: 84.46
Edit Sim: 13


Src: 
function maximumCount ( arr , N ) { let odd = 0 ; let even = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 ) odd ++ ; else even ++ ; } if ( odd && even ) return N - 2 ; else return N - 1 ; }
Ref: 
int maximumCount ( int arr [ ] , int N ) { int odd = 0 ; int even = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 ) odd ++ ; else even ++ ; } if ( odd and even ) return N - 2 ; else return N - 1 ; }
Hyp: 
int maximumCount ( int arr [ ] , int N ) { int odd = 0 ; int even = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 ) odd ++ ; else even ++ ; } if ( odd && even ) return N - 2 ; else return N - 1 ; }

BLEU: 96.46
Edit Sim: 3


Src: 
function findMinZero ( p ) { let first = 1 ; let second = 1 ; let number = 2 ; let next = 1 ; while ( next ) { next = ( first + second ) % p ; first = second ; second = next ; number ++ ; } return number ; }
Ref: 
int findMinZero ( int p ) { int first = 1 , second = 1 , number = 2 , next = 1 ; while ( next ) { next = ( first + second ) % p ; first = second ; second = next ; number ++ ; } return number ; }
Hyp: 
int findMinZero ( int p ) { int first = 1 ; int second = 1 ; int number = 2 ; int next = 1 ; while ( next ) { next = ( first + second ) % p ; first = second ; second = next ; number ++ ; } return number ; }

BLEU: 81.38
Edit Sim: 15


Src: 
function flipBitsOfAandB ( A , B ) { A = A ^ ( A & B ) ; B = B ^ ( A & B ) ; document . write ( A + " " + B ) ; }
Ref: 
void flipBitsOfAandB ( int A , int B ) { A = A ^ ( A & B ) ; B = B ^ ( A & B ) ; cout << A << " ▁ " << B ; }
Hyp: 
void flipBitsOfAandB ( int A , int B ) { A = A ^ ( A & B ) ; B = B ^ ( A & B ) ; cout << A << " ▁ " << B ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function cntOnesArrWithGivenOp ( arr , N ) { var cntOnes = 0 ; cntOnes = parseInt ( Math . sqrt ( N ) ) ; return cntOnes ; }
Ref: 
int cntOnesArrWithGivenOp ( int arr [ ] , int N ) { int cntOnes = 0 ; cntOnes = sqrt ( N ) ; return cntOnes ; }
Hyp: 
int cntOnesArrWithGivenOp ( int arr [ ] , int N ) { int cntOnes = 0 ; cntOnes = sqrt ( N ) ; return cntOnes ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findSides ( A , C , c ) { let B = 180 - ( A + C ) ; A = A * ( 3.14159 / 180 ) ; C = C * ( 3.14159 / 180 ) ; B = B * ( 3.14159 / 180 ) ; let a = ( c / Math . sin ( C ) ) * Math . sin ( A ) ; let b = ( c / Math . sin ( C ) ) * Math . sin ( B ) ; document . write ( a . toPrecision ( 4 ) + " " ) ; document . write ( b . toPrecision ( 4 ) + " " ) ; }
Ref: 
void findSides ( double A , double C , double c ) { double B = 180 - ( A + C ) ; A = A * ( 3.14159 / 180 ) ; C = C * ( 3.14159 / 180 ) ; B = B * ( 3.14159 / 180 ) ; double a = ( c / sin ( C ) ) * sin ( A ) ; double b = ( c / sin ( C ) ) * sin ( B ) ; cout << fixed << setprecision ( 2 ) ; cout << a << endl ; cout << b << endl ; }
Hyp: 
void findSides ( double A , double C , double c ) { double B = 180 - ( A + C ) ; A = A * ( 3.14159 / 180 ) ; C = C * ( 3.14159 / 180 ) ; B = B * ( 3.14159 / 180 ) ; double a = ( c / sin ( C ) ) * sin ( A ) ; double b = ( c / sin ( C ) ) * sin ( B ) ; cout << a << toPrecision ( 4 ) << " ▁ " ; cout << b << toPrecision ( 4 ) << " ▁ " ; }

BLEU: 84.41
Edit Sim: 40


Src: 
function hexagonArea ( d ) { return ( 3 * Math . sqrt ( 3 ) * Math . pow ( d , 2 ) ) / 8 ; }
Ref: 
float hexagonArea ( float d ) { return ( 3 * sqrt ( 3 ) * pow ( d , 2 ) ) / 8 ; }
Hyp: 
double hexagonArea ( int d ) { return ( 3 * sqrt ( 3 ) * pow ( d , 2 ) ) / 8 ; }

BLEU: 87.52
Edit Sim: 10


Src: 
function MinimumMoves ( a , n , x ) { var ans = 0 ; for ( i = 1 ; i < n ; i ++ ) { if ( a [ i ] <= a [ i - 1 ] ) { var p = parseInt ( ( a [ i - 1 ] - a [ i ] ) / x + 1 ) ; ans += p ; a [ i ] += p * x ; } } return ans ; }
Ref: 
int MinimumMoves ( int a [ ] , int n , int x ) { int ans = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] <= a [ i - 1 ] ) { int p = ( a [ i - 1 ] - a [ i ] ) / x + 1 ; ans += p ; a [ i ] += p * x ; } } return ans ; }
Hyp: 
int MinimumMoves ( int a [ ] , int n , int x ) { int ans = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] <= a [ i - 1 ] ) { int p = ( a [ i - 1 ] - a [ i ] ) / x + 1 ; ans += p ; a [ i ] += p * x ; } } return ans ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countCommon ( mat , n ) { let res = 0 ; for ( let i = 0 ; i < n ; i ++ ) if ( mat [ i ] [ i ] == mat [ i ] [ n - i - 1 ] ) res ++ ; return res ; }
Ref: 
int countCommon ( int mat [ ] [ MAX ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( mat [ i ] [ i ] == mat [ i ] [ n - i - 1 ] ) res ++ ; return res ; }
Hyp: 
int countCommon ( int mat [ ] [ MAX ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( mat [ i ] [ i ] == mat [ i ] [ n - i - 1 ] ) res ++ ; return res ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function Min_Replace ( arr , n , k ) { arr . sort ( ( a , b ) => a - b ) var freq = Array ( MAX ) . fill ( 0 ) ; var p = 0 ; freq [ p ] = 1 ; for ( var i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] ) ++ freq [ p ] ; else ++ freq [ ++ p ] ; } freq . sort ( ( a , b ) => b - a ) ; var ans = 0 ; for ( var i = k ; i <= p ; i ++ ) ans += freq [ i ] ; return ans ; }
Ref: 
int Min_Replace ( int arr [ ] , int n , int k ) { sort ( arr , arr + n ) ; int freq [ MAX ] ; memset ( freq , 0 , sizeof freq ) ; int p = 0 ; freq [ p ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] ) ++ freq [ p ] ; else ++ freq [ ++ p ] ; } sort ( freq , freq + n , greater < int > ( ) ) ; int ans = 0 ; for ( int i = k ; i <= p ; i ++ ) ans += freq [ i ] ; return ans ; }
Hyp: 
int Min_Replace ( int arr [ ] , int n , int k ) { sort ( arr , arr + n ) ; int freq [ MAX ] ; int p = 0 ; freq [ p ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] ) ++ freq [ p ] ; else ++ freq [ ++ p ] ; } sort ( freq , freq + MAX ) ; int ans = 0 ; for ( int i = k ; i <= p ; i ++ ) ans += freq [ i ] ; return ans ; }

BLEU: 84.98
Edit Sim: 59


Src: 
function divide ( a , b ) { for ( let i = 2 ; i <= Math . min ( a , b ) ; i ++ ) { while ( a % i == 0 && b % i == 0 ) { a = a / i ; b = b / i ; } } document . write ( " " + a + " " + b + " " ) ; }
Ref: 
void divide ( int a , int b ) { for ( int i = 2 ; i <= min ( a , b ) ; i ++ ) { while ( a % i == 0 && b % i == 0 ) { a = a / i ; b = b / i ; } } cout << " A ▁ = ▁ " << a << " , ▁ B ▁ = ▁ " << b << endl ; }
Hyp: 
void divide ( int a , int b ) { for ( int i = 2 ; i <= min ( a , b ) ; i ++ ) { while ( a % i == 0 && b % i == 0 ) { a = a / i ; b = b / i ; } } cout << " a ▁ = ▁ " << a << " , ▁ b ▁ = ▁ " << b << " STRNEWLINE " ; }

BLEU: 89.06
Edit Sim: 16


Src: 
function findSet ( N , K ) { let a = [ ] ; for ( let i = 1 ; i <= N ; i ++ ) { if ( i != K ) a . push ( i ) ; } let MaxDistinct = ( N - K ) + parseInt ( K / 2 ) ; a . reverse ( ) ; for ( let i = 0 ; i < MaxDistinct ; i ++ ) document . write ( a [ i ] + " " ) ; }
Ref: 
void findSet ( int N , int K ) { vector < int > a ; for ( int i = 1 ; i <= N ; i ++ ) { if ( i != K ) a . push_back ( i ) ; } int MaxDistinct = ( N - K ) + ( K / 2 ) ; reverse ( a . begin ( ) , a . end ( ) ) ; for ( int i = 0 ; i < MaxDistinct ; i ++ ) cout << a [ i ] << " ▁ " ; }
Hyp: 
void findSet ( int N , int K ) { vector < int > a ; for ( int i = 1 ; i <= N ; i ++ ) { if ( i != K ) a . push_back ( i ) ; } int MaxDistinct = ( N - K ) + K / 2 ; reverse ( a . begin ( ) , a . end ( ) ) ; for ( int i = 0 ; i < MaxDistinct ; i ++ ) cout << a [ i ] << " ▁ " ; }

BLEU: 94.96
Edit Sim: 4


Src: 
function AvgofSquareN ( n ) { return ( ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; }
Ref: 
float AvgofSquareN ( int n ) { return ( float ) ( ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; }
Hyp: 
int AvgofSquareN ( int n ) { return ( ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; }

BLEU: 83.39
Edit Sim: 14


Src: 
function getRemainder ( num , divisor ) { while ( num >= divisor ) num -= divisor ; return num ; }
Ref: 
int getRemainder ( int num , int divisor ) { while ( num >= divisor ) num -= divisor ; return num ; }
Hyp: 
int getRemainder ( int num , int divisor ) { while ( num >= divisor ) num -= divisor ; return num ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findUnique ( a , n , k ) { let sizeof_let = 4 ; let LET_SIZE = 8 * sizeof_let ; let count = Array . from ( { length : LET_SIZE } , ( _ , i ) => 0 ) ; for ( let i = 0 ; i < LET_SIZE ; i ++ ) for ( let j = 0 ; j < n ; j ++ ) if ( ( a [ j ] & ( 1 << i ) ) != 0 ) count [ i ] += 1 ; let res = 0 ; for ( let i = 0 ; i < LET_SIZE ; i ++ ) res += ( count [ i ] % k ) * ( 1 << i ) ; return res ; }
Ref: 
int findUnique ( unsigned int a [ ] , int n , int k ) { int INT_SIZE = 8 * sizeof ( unsigned int ) ; int count [ INT_SIZE ] ; memset ( count , 0 , sizeof ( count ) ) ; for ( int i = 0 ; i < INT_SIZE ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( ( a [ j ] & ( 1 << i ) ) != 0 ) count [ i ] += 1 ; unsigned res = 0 ; for ( int i = 0 ; i < INT_SIZE ; i ++ ) res += ( count [ i ] % k ) * ( 1 << i ) ; return res ; }
Hyp: 
int findUnique ( int a [ ] , int n , int k ) { const int sizeof_let = 4 ; int LET_SIZE = 8 * sizeof_let ; int count [ LET_SIZE ] ; memset ( count , 0 , sizeof_let ) ; for ( int i = 0 ; i < LET_SIZE ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( ( a [ j ] & ( 1 << i ) ) != 0 ) count [ i ] += 1 ; int res = 0 ; for ( int i = 0 ; i < LET_SIZE ; i ++ ) res += ( count [ i ] % k ) * ( 1 << i ) ; return res ; }

BLEU: 79.46
Edit Sim: 74


Src: 
function isDivisible ( n ) { temp = n ; while ( n ) { k = n % 10 ; if ( temp % k == 0 ) return " " ; n = Math . floor ( n / 10 ) ; } return " " ; }
Ref: 
string isDivisible ( long long int n ) { long long int temp = n ; while ( n ) { int k = n % 10 ; if ( temp % k == 0 ) return " YES " ; n /= 10 ; } return " NO " ; }
Hyp: 
string isDivisible ( int n ) { int temp = n ; while ( n ) { k = n % 10 ; if ( temp % k == 0 ) return " Yes " ; n /= 10 ; } return " No " ; }

BLEU: 71.94
Edit Sim: 27


Src: 
function printSquares ( n ) { let square = 0 , odd = 1 ; for ( let x = 0 ; x < n ; x ++ ) { document . write ( square + " " ) ; square = square + odd ; odd = odd + 2 ; } }
Ref: 
void printSquares ( int n ) { int square = 0 , odd = 1 ; for ( int x = 0 ; x < n ; x ++ ) { cout << square << " ▁ " ; square = square + odd ; odd = odd + 2 ; } }
Hyp: 
void printSquares ( int n ) { int square = 0 , odd = 1 ; for ( int x = 0 ; x < n ; x ++ ) { cout << square << " ▁ " ; square = square + odd ; odd = odd + 2 ; } }

BLEU: 100.0
Edit Sim: 0


Src: 
function multiply ( x , n ) { return x << n ; }
Ref: 
ll multiply ( ll x , ll n ) { return x << n ; }
Hyp: 
int multiply ( int x , int n ) { return x << n ; }

BLEU: 62.33
Edit Sim: 9


Src: 
function countWays ( N ) { if ( N < 4 ) return 0 ; let ans = ( ( N - 1 ) * ( N - 2 ) ) / 2 ; let s = 0 ; for ( let i = 2 ; i <= N - 3 ; i ++ ) { for ( let j = 1 ; j < i ; j ++ ) { if ( N == 2 * i + j ) s ++ ; } } if ( N % 3 == 0 ) s = 3 * s + 1 ; else s = 3 * s ; return ans - s ; }
Ref: 
int countWays ( int N ) { if ( N < 4 ) return 0 ; int ans = ( ( N - 1 ) * ( N - 2 ) ) / 2 ; int s = 0 ; for ( int i = 2 ; i <= N - 3 ; i ++ ) { for ( int j = 1 ; j < i ; j ++ ) { if ( N == 2 * i + j ) s ++ ; } } if ( N % 3 == 0 ) s = 3 * s + 1 ; else s = 3 * s ; return ans - s ; }
Hyp: 
int countWays ( int N ) { if ( N < 4 ) return 0 ; int ans = ( ( N - 1 ) * ( N - 2 ) ) / 2 ; int s = 0 ; for ( int i = 2 ; i <= N - 3 ; i ++ ) { for ( int j = 1 ; j < i ; j ++ ) { if ( N == 2 * i + j ) s ++ ; } } if ( N % 3 == 0 ) s = 3 * s + 1 ; else s = 3 * s ; return ans - s ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function hasAllcodes ( s , k ) { let us = new Set ( ) ; for ( let i = 0 ; i + k <= s . length ; i ++ ) { us . add ( s . substring ( i , i + k ) ) ; } return ( us . size == ( 1 << k ) ) ; } let s = " " ; let k = 2 ; if ( hasAllcodes ( s , k ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
Ref: 
bool hasAllcodes ( string s , int k ) { unordered_set < string > us ; for ( int i = 0 ; i + k <= s . size ( ) ; i ++ ) { us . insert ( s . substr ( i , k ) ) ; } return us . size ( ) == 1 << k ; }
Hyp: 
bool hasAllcodes ( string s , int k ) { unordered_set < string > us ; for ( int i = 0 ; i + k <= s . length ( ) ; i ++ ) { us . insert ( s . substr ( i , k ) ) ; } return ( us . size ( ) == ( 1 << k ) ) ; }

BLEU: 83.72
Edit Sim: 14


Src: 
function multiplyByFifteen ( n ) { var prod = ( n << 3 ) ; prod += ( n << 2 ) ; prod += ( n << 1 ) ; prod += n ; return prod ; }
Ref: 
long multiplyByFifteen ( long n ) { long prod = ( n << 3 ) ; prod += ( n << 2 ) ; prod += ( n << 1 ) ; prod += n ; return prod ; }
Hyp: 
int multiplyByFifteen ( int n ) { int prod = ( n << 3 ) ; prod += ( n << 2 ) ; prod += ( n << 1 ) ; prod += n ; return prod ; }

BLEU: 85.13
Edit Sim: 9


Src: 
function calcSum ( arr , n , k ) { var sum = 0 ; for ( var i = 0 ; i < k ; i ++ ) sum += arr [ i ] ; document . write ( sum + " " ) ; for ( var i = k ; i < n ; i ++ ) { sum = ( sum - arr [ i - k ] ) + arr [ i ] ; document . write ( sum + " " ) ; } }
Ref: 
int calcSum ( int arr [ ] , int n , int k ) { int sum = 0 ; for ( int i = 0 ; i < k ; i ++ ) sum += arr [ i ] ; cout << sum << " ▁ " ; for ( int i = k ; i < n ; i ++ ) { sum = ( sum - arr [ i - k ] ) + arr [ i ] ; cout << sum << " ▁ " ; } }
Hyp: 
void calcSum ( int arr [ ] , int n , int k ) { int sum = 0 ; for ( int i = 0 ; i < k ; i ++ ) sum += arr [ i ] ; cout << sum << " ▁ " ; for ( int i = k ; i < n ; i ++ ) { sum = ( sum - arr [ i - k ] ) + arr [ i ] ; cout << sum << " ▁ " ; } }

BLEU: 98.91
Edit Sim: 4


Src: 
function weightedMean ( X , W , n ) { let sum = 0 , numWeight = 0 ; for ( let i = 0 ; i < n ; i ++ ) { numWeight = numWeight + X [ i ] * W [ i ] ; sum = sum + W [ i ] ; } return ( numWeight ) / sum ; }
Ref: 
float weightedMean ( int X [ ] , int W [ ] , int n ) { int sum = 0 , numWeight = 0 ; for ( int i = 0 ; i < n ; i ++ ) { numWeight = numWeight + X [ i ] * W [ i ] ; sum = sum + W [ i ] ; } return ( float ) numWeight / sum ; }
Hyp: 
float weightedMean ( int X [ ] , int W [ ] , int n ) { float sum = 0 , numWeight = 0 ; for ( int i = 0 ; i < n ; i ++ ) { numWeight = numWeight + X [ i ] * W [ i ] ; sum = sum + W [ i ] ; } return ( numWeight ) / sum ; }

BLEU: 91.31
Edit Sim: 14


Src: 
function minimumIncreasingSubsequences ( arr , N ) { arr . sort ( function ( a , b ) { return a - b } ) ; let count = 0 ; let i = 0 ; while ( i < N ) { let x = arr [ i ] ; let freqX = 0 ; while ( i < N && arr [ i ] == x ) { freqX ++ ; i ++ ; } count = Math . max ( count , freqX ) ; } document . write ( count ) ; }
Ref: 
int minimumIncreasingSubsequences ( int arr [ ] , int N ) { sort ( arr , arr + N ) ; int count = 0 ; int i = 0 ; while ( i < N ) { int x = arr [ i ] ; int freqX = 0 ; while ( i < N && arr [ i ] == x ) { freqX ++ ; i ++ ; } count = max ( count , freqX ) ; } cout << count ; }
Hyp: 
void minimumIncreasingSubsequences ( int arr [ ] , int N ) { sort ( arr , arr + N ) ; int count = 0 ; int i = 0 ; while ( i < N ) { int x = arr [ i ] ; int freqX = 0 ; while ( i < N && arr [ i ] == x ) { freqX ++ ; i ++ ; } count = max ( count , freqX ) ; } cout << count ; }

BLEU: 98.84
Edit Sim: 4


Src: 
function evenproduct ( arr , length ) { var total_subarray = length * ( length + 1 ) / 2 ; var total_odd = 0 ; var count_odd = 0 ; for ( i = 0 ; i < arr . length ; ++ i ) { if ( arr [ i ] % 2 == 0 ) { count_odd = 0 ; } else { ++ count_odd ; total_odd += count_odd ; } } document . write ( total_subarray - total_odd ) ; }
Ref: 
void evenproduct ( int arr [ ] , int length ) { int total_subarray = length * ( length + 1 ) / 2 ; int total_odd = 0 ; int count_odd = 0 ; for ( int i = 0 ; i < length ; ++ i ) { if ( arr [ i ] % 2 == 0 ) { count_odd = 0 ; } else { ++ count_odd ; total_odd += count_odd ; } } cout << ( total_subarray - total_odd ) << endl ; }
Hyp: 
void evenproduct ( int arr [ ] , int length ) { int total_subarray = length * ( length + 1 ) / 2 ; int total_odd = 0 ; int count_odd = 0 ; for ( int i = 0 ; i < arr . length ( ) ; ++ i ) { if ( arr [ i ] % 2 == 0 ) { count_odd = 0 ; } else { ++ count_odd ; total_odd += count_odd ; } } cout << total_subarray - total_odd ; }

BLEU: 90.21
Edit Sim: 22


Src: 
function isDivisibleBy5 ( str ) { n = str . length ; return ( ( ( str [ n - 1 ] - ' ' ) == 0 ) || ( ( str [ n - 1 ] - ' ' ) == 5 ) ) ; }
Ref: 
bool isDivisibleBy5 ( string str ) { int n = str . length ( ) ; return ( ( ( str [ n - 1 ] - '0' ) == 0 ) || ( ( str [ n - 1 ] - '0' ) == 5 ) ) ; }
Hyp: 
bool isDivisibleBy5 ( string str ) { int n = str . length ( ) ; return ( ( ( str [ n - 1 ] - '0' ) == 0 ) || ( ( str [ n - 1 ] - '0' ) == 5 ) ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function Area ( l , b , h ) { if ( l < 0 b < 0 h < 0 ) return - 1 ; let x = ( l * b ) / ( l + b ) ; let A = 0.70477 * Math . pow ( x , 2 ) ; return A ; }
Ref: 
float Area ( float l , float b , float h ) { if ( l < 0 b < 0 h < 0 ) return -1 ; float x = ( l * b ) / ( l + b ) ; float A = 0.70477 * pow ( x , 2 ) ; return A ; }
Hyp: 
float Area ( float l , float b , float h ) { if ( l < 0 b < 0 h < 0 ) return -1 ; float x = ( l * b ) / ( l + b ) ; float A = 0.70477 * pow ( x , 2 ) ; return A ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function isAlphabaticOrder ( s ) { var n = s . length ; var c = new Array ( n ) ; for ( var i = 0 ; i < n ; i ++ ) { c [ i ] = s [ i ] ; } c . sort ( ) ; for ( var i = 0 ; i < n ; i ++ ) if ( c [ i ] != s [ i ] ) return false ; return true ; }
Ref: 
bool isAlphabaticOrder ( string s ) { int n = s . length ( ) ; char c [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { c [ i ] = s [ i ] ; } sort ( c , c + n ) ; for ( int i = 0 ; i < n ; i ++ ) if ( c [ i ] != s [ i ] ) return false ; return true ; }
Hyp: 
bool isAlphabaticOrder ( string s ) { int n = s . length ( ) ; char c [ n ] ; for ( int i = 0 ; i < n ; i ++ ) c [ i ] = s [ i ] ; sort ( c , c + n ) ; for ( int i = 0 ; i < n ; i ++ ) if ( c [ i ] != s [ i ] ) return false ; return true ; }

BLEU: 94.33
Edit Sim: 4


Src: 
function fourthPowerSum ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) sum = sum + ( i * i * i * i ) ; return sum ; }
Ref: 
int fourthPowerSum ( int n ) { long long int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum = sum + ( i * i * i * i ) ; return sum ; }
Hyp: 
int fourthPowerSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum = sum + ( i * i * i * i ) ; return sum ; }

BLEU: 92.16
Edit Sim: 10


Src: 
function subset ( ar , n ) { let res = 0 ; ar . sort ( ) ; for ( let i = 0 ; i < n ; i ++ ) { let count = 1 ; for ( ; i < n - 1 ; i ++ ) { if ( ar [ i ] == ar [ i + 1 ] ) count ++ ; else break ; } res = Math . max ( res , count ) ; } return res ; }
Ref: 
int subset ( int ar [ ] , int n ) { int res = 0 ; sort ( ar , ar + n ) ; for ( int i = 0 ; i < n ; i ++ ) { int count = 1 ; for ( ; i < n - 1 ; i ++ ) { if ( ar [ i ] == ar [ i + 1 ] ) count ++ ; else break ; } res = max ( res , count ) ; } return res ; }
Hyp: 
int subset ( int ar [ ] , int n ) { int res = 0 ; sort ( ar , ar + n ) ; for ( int i = 0 ; i < n ; i ++ ) { int count = 1 ; for ( ; i < n - 1 ; i ++ ) { if ( ar [ i ] == ar [ i + 1 ] ) count ++ ; else break ; } res = max ( res , count ) ; } return res ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function polygonArea ( X , Y , n ) { let area = 0.0 ; let j = n - 1 ; for ( let i = 0 ; i < n ; i ++ ) { area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) ; } return Math . abs ( area / 2.0 ) ; }
Ref: 
double polygonArea ( double X [ ] , double Y [ ] , int n ) { double area = 0.0 ; int j = n - 1 ; for ( int i = 0 ; i < n ; i ++ ) { area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) ; } return abs ( area / 2.0 ) ; }
Hyp: 
double polygonArea ( int X [ ] , int Y [ ] , int n ) { double area = 0.0 ; int j = n - 1 ; for ( int i = 0 ; i < n ; i ++ ) { area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) ; } return abs ( area / 2.0 ) ; }

BLEU: 93.62
Edit Sim: 12


Src: 
function getSum ( a , n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; ++ i ) { sum += ( i / Math . pow ( a , i ) ) ; } return sum ; }
Ref: 
float getSum ( int a , int n ) { float sum = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { sum += ( i / pow ( a , i ) ) ; } return sum ; }
Hyp: 
int digSum ( int a , int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { sum += ( i / pow ( a , i ) ) ; } return sum ; }

BLEU: 90.43
Edit Sim: 11


Src: 
function multiple ( a , b , x ) { if ( b < 0 ) { if ( a == 1 && x == 1 ) document . write ( " " ) ; else document . write ( " " ) ; } var mul = parseInt ( Math . pow ( a , b ) ) ; var ans = mul / x ; var ans1 = x * ans ; var ans2 = x * ( ans + 1 ) ; document . write ( ( ( mul - ans1 ) <= ( ans2 - mul ) ) ? ans1 : ans2 ) ; }
Ref: 
void multiple ( int a , int b , int x ) { if ( b < 0 ) { if ( a == 1 && x == 1 ) cout << "1" ; else cout << "0" ; } int mul = pow ( a , b ) ; int ans = mul / x ; int ans1 = x * ans ; int ans2 = x * ( ans + 1 ) ; cout << ( ( ( mul - ans1 ) <= ( ans2 - mul ) ) ? ans1 : ans2 ) ; }
Hyp: 
void multiple ( int a , int b , int x ) { if ( b < 0 ) { if ( a == 1 && x == 1 ) cout << " Yes " ; else cout << " No " ; } int mul = pow ( a , b ) ; int ans = mul / x ; int ans1 = x * ans ; int ans2 = x * ( ans + 1 ) ; cout << ( ( mul - ans1 ) <= ( ans2 - mul ) ) ? ans1 : ans2 ) ; }

BLEU: 90.73
Edit Sim: 11


Src: 
function oddFib ( n ) { n = ( 3 * n + 1 ) / 2 ; var a = - 1 , b = 1 , c , i ; for ( i = 1 ; i <= n ; i ++ ) { c = a + b ; a = b ; b = c ; } return c ; }
Ref: 
int oddFib ( int n ) { n = ( 3 * n + 1 ) / 2 ; int a = -1 , b = 1 , c , i ; for ( i = 1 ; i <= n ; i ++ ) { c = a + b ; a = b ; b = c ; } return c ; }
Hyp: 
int oddFib ( int n ) { n = ( 3 * n + 1 ) / 2 ; int a = -1 , b = 1 , c , i ; for ( i = 1 ; i <= n ; i ++ ) { c = a + b ; a = b ; b = c ; } return c ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function maximumTiles ( n , m ) { document . write ( ( m * n ) / 2 ) ; }
Ref: 
void maximumTiles ( int n , int m ) { cout << ( m * n ) / 2 << endl ; }
Hyp: 
void maximumTiles ( int n , int m ) { cout << ( m * n ) / 2 ; }

BLEU: 85.08
Edit Sim: 8


Src: 
function divisorGame ( N , A , dp ) { if ( N == 1 N == 3 ) return false ; if ( N == 2 ) return true ; if ( dp [ N ] [ A ] != - 1 ) return dp [ N ] [ A ] ; let ans = ( A == 1 ) ? 0 : 1 ; for ( let i = 1 ; i * i <= N ; i ++ ) { if ( N % i == 0 ) { if ( A ) ans |= divisorGame ( N - i , 0 , dp ) ; else ans &= divisorGame ( N - i , 1 , dp ) ; } } return dp [ N ] [ A ] = ans ; } let N = 3 ; let dp = [ ] ; for ( let i = 0 ; i < N + 1 ; i ++ ) { let temp = [ - 1 ] for ( let j = 0 ; j < 2 ; j ++ ) { temp . push ( [ - 1 ] ) } dp . push ( temp ) }
Ref: 
bool divisorGame ( int N , bool A , int dp [ ] [ 2 ] ) { if ( N == 1 or N == 3 ) return false ; if ( N == 2 ) return true ; if ( dp [ N ] [ A ] != -1 ) return dp [ N ] [ A ] ; int ans = ( A == 1 ) ? 0 : 1 ; for ( int i = 1 ; i * i <= N ; i ++ ) { if ( N % i == 0 ) { if ( A ) ans |= divisorGame ( N - i , 0 , dp ) ; else ans &= divisorGame ( N - i , 1 , dp ) ; } } return dp [ N ] [ A ] = ans ; }
Hyp: 
int divisorGame ( int N , int A , vector < int > & dp ) { if ( N == 1 N == 3 ) return false ; if ( N == 2 ) return true ; if ( dp [ N ] [ A ] != -1 ) return dp [ N ] [ A ] ; int ans = ( A == 1 ) ? 0 : 1 ; for ( int i = 1 ; i * i <= N ; i ++ ) { if ( N % i == 0 ) { if ( A ) ans |= divisorGame ( N - i , 0 , dp ) ; else ans &= divisorGame ( N - i , 1 , dp ) ; } } return dp [ N ] [ A ] = ans ; }

BLEU: 90.59
Edit Sim: 25


Src: 
function findK ( n , k ) { let a = [ ] ; for ( let i = 1 ; i < n ; i ++ ) if ( i % 2 == 1 ) a . push ( i ) ; for ( let i = 1 ; i < n ; i ++ ) if ( i % 2 == 0 ) a . push ( i ) ; return ( a [ k - 1 ] ) ; }
Ref: 
int findK ( int n , int k ) { vector < long > a ; for ( int i = 1 ; i < n ; i ++ ) if ( i % 2 == 1 ) a . push_back ( i ) ; for ( int i = 1 ; i < n ; i ++ ) if ( i % 2 == 0 ) a . push_back ( i ) ; return ( a [ k - 1 ] ) ; }
Hyp: 
int findK ( int n , int k ) { vector < int > a ; for ( int i = 1 ; i < n ; i ++ ) if ( i % 2 == 1 ) a . push_back ( i ) ; for ( int i = 1 ; i < n ; i ++ ) if ( i % 2 == 0 ) a . push_back ( i ) ; return ( a [ k - 1 ] ) ; }

BLEU: 97.01
Edit Sim: 3


Src: 
function splitString ( str ) { let alpha = " " ; let num = " " ; let special = " " ; for ( let i = 0 ; i < str . length ; i ++ ) { if ( ! isNaN ( String ( str [ i ] ) * 1 ) ) num += str [ i ] ; else if ( ( str [ i ] >= ' ' && str [ i ] <= ' ' ) || ( str [ i ] >= ' ' && str [ i ] <= ' ' ) ) alpha += str [ i ] ; else special += str [ i ] ; } document . write ( alpha + " " ) ; document . write ( num + " " ) ; document . write ( special + " " ) ; }
Ref: 
void splitString ( string str ) { string alpha , num , special ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( isdigit ( str [ i ] ) ) num . push_back ( str [ i ] ) ; else if ( ( str [ i ] >= ' A ' && str [ i ] <= ' Z ' ) || ( str [ i ] >= ' a ' && str [ i ] <= ' z ' ) ) alpha . push_back ( str [ i ] ) ; else special . push_back ( str [ i ] ) ; } cout << alpha << endl ; cout << num << endl ; cout << special << endl ; }
Hyp: 
void splitString ( string str ) { string alpha = " " ; string num = " " ; string special = " " ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( ! isNaN ( str [ i ] ) ) num += str [ i ] ; else if ( ( str [ i ] >= ' A ' && str [ i ] <= ' Z ' ) || ( str [ i ] >= ' a ' && str [ i ] <= ' z ' ) ) alpha += str [ i ] ; else special += str [ i ] ; } cout << alpha << " ▁ " ; cout << num << " ▁ " ; cout << special << " ▁ " ; }

BLEU: 68.6
Edit Sim: 101


Src: 
function sum_of_series ( n ) { let result = 0 ; if ( n % 2 == 0 ) { result = - ( n * ( n + 1 ) ) / 2 ; } else { result = ( n * ( n + 1 ) ) / 2 ; } return result ; }
Ref: 
int sum_of_series ( int n ) { int result = 0 ; if ( n % 2 == 0 ) { result = - ( n * ( n + 1 ) ) / 2 ; } else { result = ( n * ( n + 1 ) ) / 2 ; } return result ; }
Hyp: 
int sum_of_series ( int n ) { int result = 0 ; if ( n % 2 == 0 ) { result = - ( n * ( n + 1 ) ) / 2 ; } else { result = ( n * ( n + 1 ) ) / 2 ; } return result ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function midpoint ( x1 , x2 , y1 , y2 ) { document . write ( ( x1 + x2 ) / 2 + " " + ( y1 + y2 ) / 2 ) ; }
Ref: 
void midpoint ( int x1 , int x2 , int y1 , int y2 ) { cout << ( float ) ( x1 + x2 ) / 2 << " ▁ , ▁ " << ( float ) ( y1 + y2 ) / 2 ; }
Hyp: 
void midpoint ( int x1 , int x2 , int y1 , int y2 ) { cout << ( float ) ( x1 + x2 ) / 2 << " , ▁ " << ( float ) ( y1 + y2 ) / 2 ; }

BLEU: 94.53
Edit Sim: 2


Src: 
function isSaintExuperyNum ( n ) { for ( i = 1 ; i <= n / 3 ; i ++ ) { for ( j = i + 1 ; j <= n / 2 ; j ++ ) { let k = n / i / j ; if ( i * i + j * j == k * k ) { if ( i * j * k == n ) return true ; } } } return false ; }
Ref: 
bool isSaintExuperyNum ( int n ) { for ( int i = 1 ; i <= n / 3 ; i ++ ) { for ( int j = i + 1 ; j <= n / 2 ; j ++ ) { int k = n / i / j ; if ( i * i + j * j == k * k ) { if ( i * j * k == n ) return true ; ; } } } return false ; }
Hyp: 
bool isSaintExuperyNum ( int n ) { for ( int i = 1 ; i <= n / 3 ; i ++ ) { for ( int j = i + 1 ; j <= n / 2 ; j ++ ) { int k = n / i / j ; if ( i * i + j * j == k * k ) { if ( i * j * k == n ) return true ; } } } return false ; }

BLEU: 97.98
Edit Sim: 2


Src: 
function catalanDP ( n ) { let catalan = [ ] ; catalan [ 0 ] = catalan [ 1 ] = 1 ; for ( let i = 2 ; i <= n ; i ++ ) { catalan [ i ] = 0 ; for ( let j = 0 ; j < i ; j ++ ) catalan [ i ] += catalan [ j ] * catalan [ i - j - 1 ] ; } return catalan [ n ] ; }
Ref: 
int catalanDP ( unsigned int n ) { unsigned long int catalan [ n + 1 ] ; catalan [ 0 ] = catalan [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { catalan [ i ] = 0 ; for ( int j = 0 ; j < i ; j ++ ) catalan [ i ] += catalan [ j ] * catalan [ i - j - 1 ] ; } return catalan [ n ] ; }
Hyp: 
int catalanDP ( int n ) { int catalan [ n + 1 ] ; catalan [ 0 ] = catalan [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { catalan [ i ] = 0 ; for ( int j = 0 ; j < i ; j ++ ) catalan [ i ] += catalan [ j ] * catalan [ i - j - 1 ] ; } return catalan [ n ] ; }

BLEU: 93.42
Edit Sim: 23


Src: 
function findNature ( a , b , n ) { var seq = Array ( MAX ) . fill ( 0 ) ; seq [ 0 ] = a ; seq [ 1 ] = b ; for ( var i = 2 ; i <= n ; i ++ ) seq [ i ] = seq [ i - 1 ] + seq [ i - 2 ] ; return ( seq [ n ] & 1 ) ; }
Ref: 
bool findNature ( int a , int b , int n ) { int seq [ MAX ] = { 0 } ; seq [ 0 ] = a ; seq [ 1 ] = b ; for ( int i = 2 ; i <= n ; i ++ ) seq [ i ] = seq [ i - 1 ] + seq [ i - 2 ] ; return ( seq [ n ] & 1 ) ; }
Hyp: 
int findNature ( int a , int b , int n ) { int seq [ MAX ] ; seq [ 0 ] = a ; seq [ 1 ] = b ; for ( int i = 2 ; i <= n ; i ++ ) seq [ i ] = seq [ i - 1 ] + seq [ i - 2 ] ; return ( seq [ n ] & 1 ) ; }

BLEU: 91.8
Edit Sim: 12


Src: 
function largestArea ( arr1 , n , arr2 , m ) { var end = 0 , start = 0 , i = 0 , j = 0 ; arr1 . sort ( ) ; arr2 . sort ( ) ; while ( i < n && j < m ) { if ( arr1 [ i ] == arr2 [ j ] ) { if ( start == 0 ) start = arr1 [ i ] ; else end = arr1 [ i ] ; i ++ ; j ++ ; } else if ( arr1 [ i ] > arr2 [ j ] ) j ++ ; else i ++ ; } if ( end == 0 start == 0 ) return 0 ; else return ( end - start ) ; }
Ref: 
int largestArea ( int arr1 [ ] , int n , int arr2 [ ] , int m ) { int end = 0 , start = 0 , i = 0 , j = 0 ; sort ( arr1 , arr1 + n ) ; sort ( arr2 , arr2 + m ) ; while ( i < n and j < m ) { if ( arr1 [ i ] == arr2 [ j ] ) { if ( start == 0 ) start = arr1 [ i ] ; else end = arr1 [ i ] ; i ++ ; j ++ ; } else if ( arr1 [ i ] > arr2 [ j ] ) j ++ ; else i ++ ; } if ( end == 0 or start == 0 ) return 0 ; else return ( end - start ) ; }
Hyp: 
int largestArea ( int arr1 [ ] , int n , int arr2 [ ] , int m ) { int end = 0 , start = 0 , i = 0 , j = 0 ; sort ( arr1 , arr1 + n ) ; sort ( arr2 , arr2 + m ) ; while ( i < n && j < m ) { if ( arr1 [ i ] == arr2 [ j ] ) { if ( start == 0 ) start = arr1 [ i ] ; else end = arr1 [ i ] ; i ++ ; j ++ ; } else if ( arr1 [ i ] > arr2 [ j ] ) j ++ ; else i ++ ; } if ( end == 0 start == 0 ) return 0 ; else return ( end - start ) ; }

BLEU: 96.63
Edit Sim: 6


Src: 
function KthMinValAfterMconcatenate ( A , N , M , K ) { A . sort ( ( a , b ) => a - b ) return ( A [ ( ( K - 1 ) / M ) ] ) ; }
Ref: 
int KthMinValAfterMconcatenate ( int A [ ] , int N , int M , int K ) { sort ( A , A + N ) ; return ( A [ ( ( K - 1 ) / M ) ] ) ; }
Hyp: 
int KthMinValAfterMconcatenate ( int A [ ] , int N , int M , int K ) { sort ( A , A + N ) ; return ( A [ ( K - 1 ) / M ] ) ; }

BLEU: 89.94
Edit Sim: 4


Src: 
function subString ( s , n ) { let hash = new Map ( ) ; hash . set ( 0 , 1 ) ; let pre = 0 ; let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { pre ^= ( 1 << s [ i ] . charCodeAt ( 0 ) - 97 ) ; if ( ! hash . has ( pre ) ) hash . set ( pre , 0 ) ; count += ( hash . get ( pre ) ) ; hash . set ( pre , hash . get ( pre ) == null ? 0 : hash . get ( pre ) + 1 ) ; } return count ; }
Ref: 
int subString ( string s , int n ) { map < int , int > hash ; hash [ 0 ] = 1 ; int pre = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { pre ^= ( 1 << int ( s [ i ] ) - 97 ) ; count += hash [ pre ] ; hash [ pre ] = hash [ pre ] + 1 ; } return count ; }
Hyp: 
int subString ( string s , int n ) { unordered_map < int , int > hash ; hash [ 0 ] = 1 ; int pre = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { pre ^= ( 1 << s [ i ] - 97 ) ; if ( hash . find ( pre ) == hash . end ( ) ) hash [ pre ] ++ ; count += ( hash [ pre ] ) ; hash [ pre ] ++ ; } return count ; }

BLEU: 68.82
Edit Sim: 74


Src: 
function sum_of_4_squares ( n ) { var i , odd = 0 , even = 0 ; for ( i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( i % 2 == 0 ) even += i ; else odd += i ; if ( ( n / i ) != i ) { if ( ( n / i ) % 2 == 0 ) even += ( n / i ) ; else odd += ( n / i ) ; } } } if ( n % 2 == 1 ) return 8 * ( odd + even ) ; else return 24 * ( odd ) ; }
Ref: 
int sum_of_4_squares ( int n ) { int i , odd = 0 , even = 0 ; for ( i = 1 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( i % 2 == 0 ) even += i ; else odd += i ; if ( ( n / i ) != i ) { if ( ( n / i ) % 2 == 0 ) even += ( n / i ) ; else odd += ( n / i ) ; } } } if ( n % 2 == 1 ) return 8 * ( odd + even ) ; else return 24 * ( odd ) ; }
Hyp: 
int sum_of_4_squares ( int n ) { int i , odd = 0 , even = 0 ; for ( i = 1 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( i % 2 == 0 ) even += i ; else odd += i ; if ( ( n / i ) != i ) { if ( ( n / i ) % 2 == 0 ) even += ( n / i ) ; else odd += ( n / i ) ; } } } if ( n % 2 == 1 ) return 8 * ( odd + even ) ; else return 24 * ( odd ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function avg_of_odd_num ( n ) { return n ; }
Ref: 
int avg_of_odd_num ( int n ) { return n ; }
Hyp: 
int avg_of_odd_num ( int n ) { return n % 2 ; }

BLEU: 72.72
Edit Sim: 4


Src: 
function swapBitsInPair ( x ) { return ( ( x & 0b10101010 ) >> 1 ) | ( ( x & 0b01010101 ) << 1 ) ; }
Ref: 
int swapBitsInPair ( unsigned int x ) { return ( ( x & 0b10101010 ) >> 1 ) | ( ( x & 0b01010101 ) << 1 ) ; }
Hyp: 
int swapBitsInPair ( int x ) { return ( ( x & 0b10101010 ) >> 1 ) | ( ( x & 0b01010101 ) << 1 ) ; }

BLEU: 91.28
Edit Sim: 9


Src: 
function countTriplets ( a , n ) { var s = [ ] ; for ( i = 0 ; i < n ; i ++ ) s . push ( a [ i ] ) ; var count = 0 ; for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { var xr = a [ i ] ^ a [ j ] ; if ( s . includes ( xr ) && xr != a [ i ] && xr != a [ j ] ) count ++ ; } } return count / 3 ; }
Ref: 
int countTriplets ( int a [ ] , int n ) { unordered_set < int > s ; for ( int i = 0 ; i < n ; i ++ ) s . insert ( a [ i ] ) ; int count = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int xr = a [ i ] ^ a [ j ] ; if ( s . find ( xr ) != s . end ( ) && xr != a [ i ] && xr != a [ j ] ) count ++ ; } } return count / 3 ; }
Hyp: 
int countTriplets ( int a [ ] , int n ) { vector < int > s ; for ( int i = 0 ; i < n ; i ++ ) s . push_back ( a [ i ] ) ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int xr = a [ i ] ^ a [ j ] ; if ( s . find ( xr ) != s . end ( ) && xr != a [ i ] && xr != a [ j ] ) count ++ ; } } return count / 3 ; }

BLEU: 93.57
Edit Sim: 24


Src: 
function findMaxValue ( arr , n ) { arr . sort ( ( a , b ) => a - b ) ; let ans = arr [ n - 1 ] ; let maxPossible = arr [ n - 1 ] ; for ( let i = n - 2 ; i >= 0 ; -- i ) { if ( maxPossible > 0 ) { if ( arr [ i ] >= maxPossible ) { ans += ( maxPossible - 1 ) ; maxPossible = maxPossible - 1 ; } else { maxPossible = arr [ i ] ; ans += maxPossible ; } } } return ans ; }
Ref: 
ll findMaxValue ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; ll ans = arr [ n - 1 ] ; ll maxPossible = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; -- i ) { if ( maxPossible > 0 ) { if ( arr [ i ] >= maxPossible ) { ans += ( maxPossible - 1 ) ; maxPossible = maxPossible - 1 ; } else { maxPossible = arr [ i ] ; ans += maxPossible ; } } } return ans ; }
Hyp: 
int findMaxValue ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int ans = arr [ n - 1 ] ; int maxPossible = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; -- i ) { if ( maxPossible ) { if ( arr [ i ] >= maxPossible ) { ans += ( maxPossible - 1 ) ; maxPossible = maxPossible - 1 ; } else { maxPossible = arr [ i ] ; ans += maxPossible ; } } } return ans ; }

BLEU: 91.23
Edit Sim: 13


Src: 
function countDigits ( a , b ) { let count = 0 ; let p = Math . abs ( a * b ) ; if ( p == 0 ) return 1 ; while ( p > 0 ) { count ++ ; p = parseInt ( p / 10 , 10 ) ; } return count ; }
Ref: 
int countDigits ( int a , int b ) { int count = 0 ; int p = abs ( a * b ) ; if ( p == 0 ) return 1 ; while ( p > 0 ) { count ++ ; p = p / 10 ; } return count ; }
Hyp: 
int countDigits ( int a , int b ) { int count = 0 ; int p = abs ( a * b ) ; if ( p == 0 ) return 1 ; while ( p > 0 ) { count ++ ; p = p / 10 ; } return count ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function OR ( a , n ) { var ans = a [ 0 ] ; for ( var i = 1 ; i < n ; ++ i ) ans |= a [ i ] ; return ans ; }
Ref: 
int OR ( int a [ ] , int n ) { int ans = a [ 0 ] ; for ( int i = 1 ; i < n ; ++ i ) ans |= a [ i ] ; return ans ; }
Hyp: 
int OR ( int a [ ] , int n ) { int ans = a [ 0 ] ; for ( int i = 1 ; i < n ; ++ i ) ans |= a [ i ] ; return ans ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function sum ( N , X , Y ) { var S1 , S2 , S3 ; S1 = ( parseInt ( N / X ) ) * ( 2 * X + parseInt ( N / X - 1 ) * X ) / 2 ; S2 = ( parseInt ( N / Y ) ) * ( 2 * Y + parseInt ( N / Y - 1 ) * Y ) / 2 ; S3 = ( parseInt ( N / ( X * Y ) ) ) * ( 2 * ( X * Y ) + parseInt ( N / ( X * Y ) - 1 ) * ( X * Y ) ) / 2 ; return S1 + S2 - S3 ; }
Ref: 
int sum ( int N , int X , int Y ) { int S1 , S2 , S3 ; S1 = ( ( N / X ) ) * ( 2 * X + ( N / X - 1 ) * X ) / 2 ; S2 = ( ( N / Y ) ) * ( 2 * Y + ( N / Y - 1 ) * Y ) / 2 ; S3 = ( ( N / ( X * Y ) ) ) * ( 2 * ( X * Y ) + ( N / ( X * Y ) - 1 ) * ( X * Y ) ) / 2 ; return S1 + S2 - S3 ; }
Hyp: 
int sum ( int N , int X , int Y ) { int S1 , S2 , S3 ; S1 = ( N / X ) ) * ( 2 * X + N / X - 1 ) * X ) / 2 ; S2 = ( N / Y ) ) * ( 2 * Y + N / Y - 1 ) * Y ) / 2 ; S3 = ( N / ( X * Y ) ) ) * ( 2 * ( X * Y ) + ( N / ( X * Y ) - 1 ) * ( X * Y ) ) / 2 ; return S1 + S2 - S3 ; }

BLEU: 91.79
Edit Sim: 10


Src: 
function countOddRotations ( n ) { var odd_count = 0 , even_count = 0 ; do { var digit = n % 10 ; if ( digit % 2 == 1 ) odd_count ++ ; else even_count ++ ; n = parseInt ( n / 10 ) ; } while ( n != 0 ) ; document . write ( " " + odd_count + " " ) ; document . write ( " " + even_count + " " ) ; }
Ref: 
void countOddRotations ( int n ) { int odd_count = 0 , even_count = 0 ; do { int digit = n % 10 ; if ( digit % 2 == 1 ) odd_count ++ ; else even_count ++ ; n = n / 10 ; } while ( n != 0 ) ; cout << " Odd ▁ = ▁ " << odd_count << endl ; cout << " Even ▁ = ▁ " << even_count << endl ; }
Hyp: 
void countOddRotations ( int n ) { int odd_count = 0 , even_count = 0 ; do { int digit = n % 10 ; if ( digit % 2 == 1 ) odd_count ++ ; else even_count ++ ; n = n / 10 ; } while ( n != 0 ) ; cout << " Odd ▁ Rotations : " << odd_count << endl ; cout << " Even ▁ Rotations : " << even_count << endl ; }

BLEU: 91.22
Edit Sim: 20


Src: 
function printTetra ( n ) { let dp = new Array ( n + 5 ) ; dp [ 0 ] = 0 ; dp [ 1 ] = dp [ 2 ] = 1 ; dp [ 3 ] = 2 ; for ( let i = 4 ; i <= n ; i ++ ) dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] + dp [ i - 3 ] + dp [ i - 4 ] ; document . write ( dp [ n ] ) ; }
Ref: 
int printTetra ( int n ) { int dp [ n + 5 ] ; dp [ 0 ] = 0 ; dp [ 1 ] = dp [ 2 ] = 1 ; dp [ 3 ] = 2 ; for ( int i = 4 ; i <= n ; i ++ ) dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] + dp [ i - 3 ] + dp [ i - 4 ] ; cout << dp [ n ] ; }
Hyp: 
void printTetra ( int n ) { int dp [ n + 5 ] ; dp [ 0 ] = 0 ; dp [ 1 ] = dp [ 2 ] = 1 ; dp [ 3 ] = 2 ; for ( int i = 4 ; i <= n ; i ++ ) dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] + dp [ i - 3 ] + dp [ i - 4 ] ; cout << dp [ n ] ; }

BLEU: 98.95
Edit Sim: 4


Src: 
function minPushes ( N , K , arr ) { let dp = new Array ( 100000 ) . fill ( - 1 ) ; dp [ N ] = 0 ; for ( let i = 0 ; i < arr . length ; i ++ ) { for ( let xx = 0 ; xx < 100000 ; xx ++ ) { let x = xx ; if ( dp [ x ] == - 1 ) continue ; let next = ( x + arr [ i ] ) % 100000 ; while ( dp [ next ] == - 1 dp [ next ] > dp [ x ] + 1 ) { dp [ next ] = dp [ x ] + 1 ; x = next ; next = ( next + arr [ i ] ) % 100000 ; } } } return dp [ K ] ; }
Ref: 
int minPushes ( int N , int K , vector < int > arr ) { vector < int > dp ( 100000 , -1 ) ; dp [ N ] = 0 ; for ( int i = 0 ; i < arr . size ( ) ; i ++ ) { for ( int xx = 0 ; xx < 100000 ; xx ++ ) { int x = xx ; if ( dp [ x ] == -1 ) continue ; int next = ( x + arr [ i ] ) % 100000 ; while ( dp [ next ] == -1 dp [ next ] > dp [ x ] + 1 ) { dp [ next ] = dp [ x ] + 1 ; x = next ; next = ( next + arr [ i ] ) % 100000 ; } } } return dp [ K ] ; }
Hyp: 
int minPushes ( int N , int K , int arr [ ] ) { int dp [ 100000 ] ; memset ( dp , -1 , sizeof dp ) ; dp [ N ] = 0 ; for ( int i = 0 ; i < arr . length ( ) ; i ++ ) { for ( int xx = 0 ; xx < 100000 ; xx ++ ) { int x = xx ; if ( dp [ x ] == -1 ) continue ; int next = ( x + arr [ i ] ) % 100000 ; while ( dp [ next ] == -1 dp [ next ] > dp [ x ] + 1 ) { dp [ next ] = dp [ x ] + 1 ; x = next ; next = ( next + arr [ i ] ) % 100000 ; } } } return dp [ K ] ; }

BLEU: 86.89
Edit Sim: 51


Src: 
function PositionRightmostSetbit ( n ) { let position = 1 ; let m = 1 ; while ( ( n & m ) == 0 ) { m = m << 1 ; position ++ ; } return position ; }
Ref: 
int PositionRightmostSetbit ( int n ) { int position = 1 ; int m = 1 ; while ( ! ( n & m ) ) { m = m << 1 ; position ++ ; } return position ; }
Hyp: 
int PositionRightmostSetbit ( int n ) { int position = 1 ; int m = 1 ; while ( ( n & m ) == 0 ) { m = m << 1 ; position ++ ; } return position ; }

BLEU: 87.61
Edit Sim: 7


Src: 
function distribution ( arr , n ) { arr . sort ( ( a , b ) => a - b ) ; var count = 1 ; for ( var i = 1 ; i < n ; i ++ ) if ( arr [ i ] > arr [ i - 1 ] ) count ++ ; return Math . min ( count , parseInt ( n / 2 ) ) ; }
Ref: 
int distribution ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int count = 1 ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] > arr [ i - 1 ] ) count ++ ; return min ( count , n / 2 ) ; }
Hyp: 
int distribution ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int count = 1 ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] > arr [ i - 1 ] ) count ++ ; return min ( count , n / 2 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function func ( a , k ) { for ( let i = 0 ; i < a . length ; i ++ ) if ( a [ i ] % k == 0 ) return true ; return false ; }
Ref: 
bool func ( int a [ ] , int k , int n ) { for ( int i = 0 ; i < n ; i ++ ) if ( a [ i ] % k == 0 ) return true ; return false ; }
Hyp: 
bool func ( int a [ ] , int k ) { for ( int i = 0 ; i < a . length ( ) ; i ++ ) if ( a [ i ] % k == 0 ) return true ; return false ; }

BLEU: 82.88
Edit Sim: 21


Src: 
function findDecimal ( arr , N ) { let bit , power = 0 , result = 0 ; for ( let i = N - 1 ; i >= 0 ; i -- ) { bit = Math . abs ( Math . floor ( arr [ i ] ) - Math . round ( arr [ i ] ) ) ; if ( bit != 0 ) result += Math . pow ( 2 , power ) ; power ++ ; } document . write ( result ) ; }
Ref: 
int findDecimal ( float arr [ ] , int N ) { int bit , power = 0 , result = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { bit = abs ( floor ( arr [ i ] ) - round ( arr [ i ] ) ) ; if ( bit ) result += pow ( 2 , power ) ; power ++ ; } cout << result ; }
Hyp: 
void findDecimal ( int arr [ ] , int N ) { int bit , power = 0 , result = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { bit = abs ( arr [ i ] ) - round ( arr [ i ] ) ; if ( bit != 0 ) result += pow ( 2 , power ) ; power ++ ; } cout << result ; }

BLEU: 88.9
Edit Sim: 23


Src: 
function fibWord ( n ) { var Sn_1 = " " ; var Sn = " " ; var tmp ; for ( var i = 2 ; i <= n ; i ++ ) { tmp = Sn ; Sn += Sn_1 ; Sn_1 = tmp ; } return Sn ; }
Ref: 
string fibWord ( int n ) { string Sn_1 = "0" ; string Sn = "01" ; string tmp ; for ( int i = 2 ; i <= n ; i ++ ) { tmp = Sn ; Sn += Sn_1 ; Sn_1 = tmp ; } return Sn ; }
Hyp: 
string fibWord ( int n ) { string Sn_1 = " " ; string Sn = " " ; string tmp ; for ( int i = 2 ; i <= n ; i ++ ) { tmp = Sn ; Sn += Sn_1 ; Sn_1 = tmp ; } return Sn ; }

BLEU: 86.71
Edit Sim: 3


Src: 
function isSuffix ( s1 , s2 ) { let n1 = s1 . length , n2 = s2 . length ; if ( n1 > n2 ) return false ; for ( let i = 0 ; i < n1 ; i ++ ) if ( s1 [ n1 - i - 1 ] != s2 [ n2 - i - 1 ] ) return false ; return true ; }
Ref: 
bool isSuffix ( string s1 , string s2 ) { int n1 = s1 . length ( ) , n2 = s2 . length ( ) ; if ( n1 > n2 ) return false ; for ( int i = 0 ; i < n1 ; i ++ ) if ( s1 [ n1 - i - 1 ] != s2 [ n2 - i - 1 ] ) return false ; return true ; }
Hyp: 
bool isSuffix ( string s1 , string s2 ) { int n1 = s1 . length ( ) , n2 = s2 . length ( ) ; if ( n1 > n2 ) return false ; for ( int i = 0 ; i < n1 ; i ++ ) if ( s1 [ n1 - i - 1 ] != s2 [ n2 - i - 1 ] ) return false ; return true ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function sortExceptK ( arr , k , n ) { let temp = arr [ k ] ; arr [ k ] = arr [ n - 1 ] ; arr [ n - 1 ] = temp ; arr . sort ( function ( a , b ) { return a - b } ) ; let last = arr [ n - 1 ] ; for ( let i = n - 1 ; i > k ; i -- ) arr [ i ] = arr [ i - 1 ] ; arr [ k ] = last ; temp = arr [ k ] ; arr [ k ] = arr [ n - 1 ] ; arr [ n - 1 ] = temp ; return 0 ; }
Ref: 
int sortExceptK ( int arr [ ] , int k , int n ) { swap ( arr [ k ] , arr [ n - 1 ] ) ; sort ( arr , arr + n - 1 ) ; int last = arr [ n - 1 ] ; for ( int i = n - 1 ; i > k ; i -- ) arr [ i ] = arr [ i - 1 ] ; arr [ k ] = last ; }
Hyp: 
int sortExceptK ( int arr [ ] , int k , int n ) { int temp = arr [ k ] ; arr [ k ] = arr [ n - 1 ] ; arr [ n - 1 ] = temp ; sort ( arr , arr + n ) ; int last = arr [ n - 1 ] ; for ( int i = n - 1 ; i > k ; i -- ) arr [ i ] = arr [ i - 1 ] ; arr [ k ] = last ; temp = arr [ k ] ; arr [ k ] = arr [ n - 1 ] ; arr [ n - 1 ] = temp ; return 0 ; }

BLEU: 57.87
Edit Sim: 128


Src: 
function Centered_Triangular_num ( n ) { return ( 3 * n * n + 3 * n + 2 ) / 2 ; }
Ref: 
int Centered_Triangular_num ( int n ) { return ( 3 * n * n + 3 * n + 2 ) / 2 ; }
Hyp: 
int Centered_Triangular_num ( int n ) { return ( 3 * n * n + 3 * n + 2 ) / 2 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function minDiff ( n , x , A ) { var mn = A [ 0 ] , mx = A [ 0 ] ; for ( var i = 0 ; i < n ; ++ i ) { mn = Math . min ( mn , A [ i ] ) ; mx = Math . max ( mx , A [ i ] ) ; } return Math . max ( 0 , mx - mn - 2 * x ) ; }
Ref: 
int minDiff ( int n , int x , int A [ ] ) { int mn = A [ 0 ] , mx = A [ 0 ] ; for ( int i = 0 ; i < n ; ++ i ) { mn = min ( mn , A [ i ] ) ; mx = max ( mx , A [ i ] ) ; } return max ( 0 , mx - mn - 2 * x ) ; }
Hyp: 
int minDiff ( int n , int x , int A [ ] ) { int mn = A [ 0 ] , mx = A [ 0 ] ; for ( int i = 0 ; i < n ; ++ i ) { mn = min ( mn , A [ i ] ) ; mx = max ( mx , A [ i ] ) ; } return max ( 0 , mx - mn - 2 * x ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function numberOfTiles ( n , m ) { if ( n % 2 == 1 ) { return - 1 ; } return ( m * n ) / 2 ; }
Ref: 
int numberOfTiles ( int N , int M ) { if ( N % 2 == 1 ) { return -1 ; } return ( N * 1LL * M ) / 2 ; }
Hyp: 
int numberOfTiles ( int n , int m ) { if ( n % 2 == 1 ) { return -1 ; } return ( m * n ) / 2 ; }

BLEU: 58.67
Edit Sim: 11


Src: 
function totalSumDivisibleByNum ( digit , number ) { let firstnum = Math . pow ( 10 , digit - 1 ) ; let lastnum = Math . pow ( 10 , digit ) ; firstnum = ( firstnum - firstnum % number ) + number ; lastnum = ( lastnum - lastnum % number ) ; let count = ( ( lastnum - firstnum ) / number + 1 ) ; return ( ( lastnum + firstnum ) * count ) / 2 ; }
Ref: 
int totalSumDivisibleByNum ( int digit , int number ) { int firstnum = pow ( 10 , digit - 1 ) ; int lastnum = pow ( 10 , digit ) ; firstnum = ( firstnum - firstnum % number ) + number ; lastnum = ( lastnum - lastnum % number ) ; int count = ( ( lastnum - firstnum ) / number + 1 ) ; return ( ( lastnum + firstnum ) * count ) / 2 ; }
Hyp: 
int totalSumDivisibleByNum ( int digit , int number ) { long double firstnum = pow ( 10 , digit - 1 ) ; long double lastnum = pow ( 10 , digit ) ; firstnum = ( firstnum - firstnum % number ) + number ; lastnum = ( lastnum - lastnum % number ) ; int count = ( ( lastnum - firstnum ) / number + 1 ) ; return ( ( lastnum + firstnum ) * count ) / 2 ; }

BLEU: 91.64
Edit Sim: 20


Src: 
function findElements ( arr , n ) { arr . sort ( ) ; for ( let i = 0 ; i < n - 2 ; i ++ ) document . write ( arr [ i ] + " " ) ; }
Ref: 
void findElements ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; for ( int i = 0 ; i < n - 2 ; i ++ ) cout << arr [ i ] << " ▁ " ; }
Hyp: 
void findElements ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; for ( int i = 0 ; i < n - 2 ; i ++ ) cout << arr [ i ] << " ▁ " ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function adjacentSet ( n ) { let x = ( n & ( n >> 1 ) ) ; if ( x > 0 ) return true ; else return false ; }
Ref: 
bool adjacentSet ( int n ) { return ( n & ( n >> 1 ) ) ; }
Hyp: 
bool adjacentSet ( int n ) { int x = ( n & ( n >> 1 ) ) ; if ( x > 0 ) return true ; else return false ; }

BLEU: 46.17
Edit Sim: 53


Src: 
function Add ( x , y ) { while ( y != 0 ) { let carry = x & y ; x = x ^ y ; y = carry << 1 ; } return x ; }
Ref: 
int Add ( int x , int y ) { while ( y != 0 ) { int carry = x & y ; x = x ^ y ; y = carry << 1 ; } return x ; }
Hyp: 
int Add ( int x , int y ) { while ( y != 0 ) { int carry = x & y ; x = x ^ y ; y = carry << 1 ; } return x ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function ShortestPalindrome ( s ) { let n = s . length ; let ans = s [ 0 ] . charCodeAt ( ) ; for ( let i = 1 ; i < n ; i ++ ) { ans = Math . min ( ans , s [ i ] . charCodeAt ( ) ) ; } return String . fromCharCode ( ans ) ; }
Ref: 
char ShortestPalindrome ( string s ) { int n = s . length ( ) ; char ans = s [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { ans = min ( ans , s [ i ] ) ; } return ans ; }
Hyp: 
char ShortestPalindrome ( string s ) { int n = s . length ( ) ; int ans = s [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { ans = min ( ans , s [ i ] ) ; } return ( char ) ans ; }

BLEU: 88.25
Edit Sim: 13


Src: 
function permute ( input ) { var n = input . length ; var max = 1 << n ; input = input . toLowerCase ( ) ; for ( var i = 0 ; i < max ; i ++ ) { var combination = input . split ( ' ' ) ; for ( var j = 0 ; j < n ; j ++ ) { if ( ( ( i >> j ) & 1 ) == 1 ) combination [ j ] = String . fromCharCode ( combination [ j ] . charCodeAt ( 0 ) - 32 ) ; } document . write ( combination . join ( ' ' ) ) ; document . write ( " " ) ; } }
Ref: 
void permute ( string input ) { int n = input . length ( ) ; int max = 1 << n ; transform ( input . begin ( ) , input . end ( ) , input . begin ( ) , :: tolower ) ; for ( int i = 0 ; i < max ; i ++ ) { string combination = input ; for ( int j = 0 ; j < n ; j ++ ) if ( ( ( i >> j ) & 1 ) == 1 ) combination [ j ] = toupper ( input . at ( j ) ) ; cout << combination << " ▁ " ; } }
Hyp: 
void permute ( string input ) { int n = input . length ( ) ; int max = 1 << n ; input = input . toLowerCase ( ) ; for ( int i = 0 ; i < max ; i ++ ) { string combination = input . split ( ' ▁ ' ) ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( ( i >> j ) & 1 ) == 1 ) combination [ j ] = combination [ j ] - 32 ; } cout << combination << endl ; } }

BLEU: 66.44
Edit Sim: 109


Src: 
function isDiagonalMatrix ( mat ) { for ( let i = 0 ; i < N ; i ++ ) for ( let j = 0 ; j < N ; j ++ ) if ( ( i != j ) && ( mat [ i ] [ j ] != 0 ) ) return false ; return true ; }
Ref: 
bool isDiagonalMatrix ( int mat [ N ] [ N ] ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) if ( ( i != j ) && ( mat [ i ] [ j ] != 0 ) ) return false ; return true ; }
Hyp: 
bool isDiagonalMatrix ( int mat [ N ] [ N ] ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) if ( ( i != j ) && ( mat [ i ] [ j ] != 0 ) ) return false ; return true ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function minNum ( arr , n ) { let odd = 0 ; for ( let i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 != 0 ) odd += 1 ; return ( ( odd % 2 ) != 0 ) ? 1 : 2 ; }
Ref: 
int minNum ( int arr [ ] , int n ) { int odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 ) odd += 1 ; return ( odd % 2 ) ? 1 : 2 ; }
Hyp: 
int minNum ( int arr [ ] , int n ) { int odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 != 0 ) odd += 1 ; return ( ( odd % 2 ) != 0 ) ? 1 : 2 ; }

BLEU: 85.15
Edit Sim: 14


Src: 
function answer ( n ) { let dp = new Array ( n + 1 ) ; for ( var i = 0 ; i < dp . length ; i ++ ) { dp [ i ] = new Array ( 2 ) ; } if ( n == 1 ) return 10 ; for ( let j = 0 ; j <= 9 ; j ++ ) dp [ 1 ] [ j ] = 1 ; for ( let i = 2 ; i <= n ; i ++ ) { for ( let j = 0 ; j <= 9 ; j ++ ) { if ( j == 0 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] ; else if ( j == 9 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] ; } } let sum = 0 ; for ( let j = 1 ; j <= 9 ; j ++ ) sum += dp [ n ] [ j ] ; return sum ; }
Ref: 
long answer ( int n ) { int dp [ n + 1 ] [ 10 ] ; if ( n == 1 ) return 10 ; for ( int j = 0 ; j <= 9 ; j ++ ) dp [ 1 ] [ j ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= 9 ; j ++ ) { if ( j == 0 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] ; else if ( j == 9 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] ; } } long long sum = 0 ; for ( int j = 1 ; j <= 9 ; j ++ ) sum += dp [ n ] [ j ] ; return sum ; }
Hyp: 
int answer ( int n ) { int dp [ n + 1 ] [ 9 + 1 ] ; if ( n == 1 ) return 10 ; for ( int j = 0 ; j <= 9 ; j ++ ) dp [ 1 ] [ j ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= 9 ; j ++ ) { if ( j == 0 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] ; else if ( j == 9 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] ; } } int sum = 0 ; for ( int j = 1 ; j <= 9 ; j ++ ) sum += dp [ n ] [ j ] ; return sum ; }

BLEU: 96.06
Edit Sim: 16


Src: 
function countAPs ( S , D ) { S = S * 2 ; let answer = 0 ; for ( let i = 1 ; i <= Math . sqrt ( S ) ; i ++ ) { if ( S % i == 0 ) { if ( ( ( S / i ) - D * i + D ) % 2 == 0 ) answer ++ ; if ( ( D * i - ( S / i ) + D ) % 2 == 0 ) answer ++ ; } } return answer ; }
Ref: 
int countAPs ( int S , int D ) { S = S * 2 ; int answer = 0 ; for ( int i = 1 ; i <= sqrt ( S ) ; i ++ ) { if ( S % i == 0 ) { if ( ( ( S / i ) - D * i + D ) % 2 == 0 ) answer ++ ; if ( ( D * i - ( S / i ) + D ) % 2 == 0 ) answer ++ ; } } return answer ; }
Hyp: 
int countAPs ( int S , int D ) { S = S * 2 ; int answer = 0 ; for ( int i = 1 ; i <= sqrt ( S ) ; i ++ ) { if ( S % i == 0 ) { if ( ( ( S / i ) - D * i + D ) % 2 == 0 ) answer ++ ; if ( ( D * i - ( S / i ) + D ) % 2 == 0 ) answer ++ ; } } return answer ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findNumbers ( n , b ) { var even = 0 , odd = 0 ; if ( b % 2 == 0 ) { even = Math . pow ( b , n ) - 2 ; odd = Math . pow ( b , n ) - 1 ; } else { even = Math . pow ( b , n ) - 1 ; odd = Math . pow ( b , n ) - 2 ; } document . write ( " " + even + " " ) ; document . write ( " " + odd ) ; }
Ref: 
void findNumbers ( int n , int b ) { int even = 0 , odd = 0 ; if ( b % 2 == 0 ) { even = pow ( b , n ) - 2 ; odd = pow ( b , n ) - 1 ; } else { even = pow ( b , n ) - 1 ; odd = pow ( b , n ) - 2 ; } cout << " Even ▁ Number ▁ = ▁ " << even << ' ' ; cout << " Odd ▁ Number ▁ = ▁ " << odd ; }
Hyp: 
void findNumbers ( int n , int b ) { int even = 0 , odd = 0 ; if ( b % 2 == 0 ) { even = pow ( b , n ) - 2 ; odd = pow ( b , n ) - 1 ; } else { even = pow ( b , n ) - 1 ; odd = pow ( b , n ) - 2 ; } cout << " Even ▁ = ▁ " << even << endl ; cout << " Odd ▁ = ▁ " << odd ; }

BLEU: 91.31
Edit Sim: 22


Src: 
function countTriplets ( N ) { let cnt = 0 ; for ( let A = 1 ; A <= N ; ++ A ) { for ( let B = 1 ; B <= N / A ; ++ B ) { cnt += N / ( A * B ) ; } } return cnt ; }
Ref: 
int countTriplets ( int N ) { int cnt = 0 ; for ( int A = 1 ; A <= N ; ++ A ) { for ( int B = 1 ; B <= N / A ; ++ B ) { cnt += N / ( A * B ) ; } } return cnt ; }
Hyp: 
int countTriplets ( int N ) { int cnt = 0 ; for ( int A = 1 ; A <= N ; ++ A ) { for ( int B = 1 ; B <= N / A ; ++ B ) { cnt += N / ( A * B ) ; } } return cnt ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findAns ( mat , x , y , n , m ) { let ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < m ; j ++ ) { if ( mat [ i ] [ j ] == 1 ) { ans += Math . abs ( x - i ) + Math . abs ( y - j ) ; } } } return ans ; }
Ref: 
int findAns ( vector < vector < int > > mat , int x , int y , int n , int m ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( mat [ i ] [ j ] == 1 ) { ans += abs ( x - i ) + abs ( y - j ) ; } } } return ans ; }
Hyp: 
int findAns ( int mat [ 4 ] [ 4 ] , int x , int y , int n , int m ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( mat [ i ] [ j ] == 1 ) { ans += abs ( x - i ) + abs ( y - j ) ; } } } return ans ; }

BLEU: 90.53
Edit Sim: 21


Src: 
function distinctRemainders ( n ) { if ( n % 2 == 0 ) return parseInt ( n / 2 ) ; return ( 1 + parseInt ( n / 2 ) ) ; }
Ref: 
int distinctRemainders ( int n ) { if ( n % 2 == 0 ) return ( n / 2 ) ; return ( 1 + ( n / 2 ) ) ; }
Hyp: 
int distinctRemainders ( int n ) { if ( n % 2 == 0 ) return n / 2 ; return ( 1 + n / 2 ) ; }

BLEU: 72.03
Edit Sim: 8


Src: 
function phi ( n ) { let result = n ; for ( let p = 2 ; p * p <= n ; ++ p ) { if ( n % p == 0 ) { while ( n % p == 0 ) n /= p ; result *= ( 1.0 - ( 1.0 / p ) ) ; } } if ( n > 1 ) result *= ( 1.0 - ( 1.0 / n ) ) ; return parseInt ( result ) ; } for ( let n = 1 ; n <= 10 ; n ++ ) document . write ( ` ${ n } ${ phi ( n ) }
Ref: 
int phi ( int n ) { float result = n ; for ( int p = 2 ; p * p <= n ; ++ p ) { if ( n % p == 0 ) { while ( n % p == 0 ) n /= p ; result *= ( 1.0 - ( 1.0 / ( float ) p ) ) ; } } if ( n > 1 ) result *= ( 1.0 - ( 1.0 / ( float ) n ) ) ; return ( int ) result ; }
Hyp: 
int phi ( int n ) { long double result = n ; for ( long double p = 2 ; p * p <= n ; ++ p ) { if ( n % p == 0 ) { while ( n % p == 0 ) n /= p ; result *= ( 1.0 - ( 1.0 / p ) ) ; } } if ( n > 1 ) result *= ( 1.0 - ( 1.0 / n ) ) ; return ( int ) result ; }

BLEU: 84.93
Edit Sim: 40


Src: 
function countIntervals ( arr , V , N ) { let min = Number . MAX_VALUE , max = Number . MIN_VALUE ; let li , ri ; let freq = new Array ( MAX_VAL ) ; freq . fill ( 0 ) ; for ( let i = 0 ; i < N ; i ++ ) { li = arr [ i ] [ 0 ] ; freq [ li ] = freq [ li ] + 1 ; ri = arr [ i ] [ 1 ] ; freq [ ri + 1 ] = freq [ ri + 1 ] - 1 ; if ( li < min ) min = li ; if ( ri > max ) max = ri ; } for ( let i = min ; i <= max ; i ++ ) freq [ i ] = freq [ i ] + freq [ i - 1 ] ; return freq [ V ] ; }
Ref: 
int countIntervals ( int arr [ ] [ 2 ] , int V , int N ) { int min = INT_MAX ; int max = INT_MIN ; int li , ri ; int freq [ MAX_VAL ] ; for ( int i = 0 ; i < N ; i ++ ) { li = arr [ i ] [ 0 ] ; freq [ li ] = freq [ li ] + 1 ; ri = arr [ i ] [ 1 ] ; freq [ ri + 1 ] = freq [ ri + 1 ] - 1 ; if ( li < min ) min = li ; if ( ri > max ) max = ri ; } for ( int i = min ; i <= max ; i ++ ) freq [ i ] = freq [ i ] + freq [ i - 1 ] ; return freq [ V ] ; }
Hyp: 
int countIntervals ( int arr [ ] [ 2 ] , int V , int N ) { int min = INT_MAX , max = INT_MIN ; int li , ri ; int freq [ MAX_VAL ] ; memset ( freq , 0 , sizeof freq ) ; for ( int i = 0 ; i < N ; i ++ ) { li = arr [ i ] [ 0 ] ; freq [ li ] = freq [ li ] + 1 ; ri = arr [ i ] [ 1 ] ; freq [ ri + 1 ] = freq [ ri + 1 ] - 1 ; if ( li < min ) min = li ; if ( ri > max ) max = ri ; } for ( int i = min ; i <= max ; i ++ ) freq [ i ] = freq [ i ] + freq [ i - 1 ] ; return freq [ V ] ; }

BLEU: 92.31
Edit Sim: 41


Src: 
function findSum ( str ) { let temp = " " ; let sum = 0 ; for ( let i = 0 ; i < str . length ; i ++ ) { let ch = str [ i ] ; if ( ! isNaN ( String ( ch ) * 1 ) ) temp += ch ; else { sum += parseInt ( temp ) ; temp = " " ; } } return sum + parseInt ( temp ) ; }
Ref: 
int findSum ( string str ) { string temp = " " ; int sum = 0 ; for ( char ch : str ) { if ( isdigit ( ch ) ) temp += ch ; else { sum += atoi ( temp . c_str ( ) ) ; temp = " " ; } } return sum + atoi ( temp . c_str ( ) ) ; }
Hyp: 
int findSum ( string str ) { string temp = " " ; int sum = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char ch = str [ i ] ; if ( ! isNaN ( ch * 1 ) ) temp += ch ; else { sum += temp ; temp = " " ; } } return sum + temp ; }

BLEU: 54.45
Edit Sim: 103


Src: 
function kthpair ( n , k , arr ) { let i , t = 0 ; arr . sort ( ) ; -- k ; for ( i = 0 ; i < n ; i += t ) { for ( t = 1 ; arr [ i ] == arr [ i + t ] ; ++ t ) ; if ( t * n > k ) break ; k = k - t * n ; } document . write ( arr [ i ] + " " + arr [ k / t ] ) ; }
Ref: 
void kthpair ( int n , int k , int arr [ ] ) { int i , t ; sort ( arr , arr + n ) ; -- k ; for ( i = 0 ; i < n ; i += t ) { for ( t = 1 ; arr [ i ] == arr [ i + t ] ; ++ t ) ; if ( t * n > k ) break ; k = k - t * n ; } cout << arr [ i ] << ' ▁ ' << arr [ k / t ] ; }
Hyp: 
void kthpair ( int n , int k , int arr [ ] ) { sort ( arr , arr + n ) ; -- k ; for ( int i = 0 ; i < n ; i += t ) { for ( int t = 1 ; arr [ i ] == arr [ i + t ] ; ++ t ) ; if ( t * n > k ) break ; k = k - t * n ; } cout << arr [ i ] << " , ▁ " << arr [ k / t ] ; }

BLEU: 87.56
Edit Sim: 24


Src: 
function form_sieve ( ) { sieve_Prime [ 1 ] = 1 ; for ( i = 2 ; i <= MAX ; i ++ ) { if ( sieve_Prime [ i ] == 0 ) { for ( j = i * 2 ; j <= MAX ; j += i ) { if ( sieve_Prime [ j ] == 0 ) { sieve_Prime [ j ] = 1 ; sieve_count [ i ] ++ ; } } } } }
Ref: 
void form_sieve ( ) { sieve_Prime [ 1 ] = 1 ; for ( int i = 2 ; i <= MAX ; i ++ ) { if ( sieve_Prime [ i ] == 0 ) { for ( int j = i * 2 ; j <= MAX ; j += i ) { if ( sieve_Prime [ j ] == 0 ) { sieve_Prime [ j ] = 1 ; sieve_count [ i ] ++ ; } } } } }
Hyp: 
void form_sieve ( void ) { sieve_Prime [ 1 ] = 1 ; for ( int i = 2 ; i <= MAX ; i ++ ) { if ( sieve_Prime [ i ] == 0 ) { for ( int j = i * 2 ; j <= MAX ; j += i ) { if ( sieve_Prime [ j ] == 0 ) { sieve_Prime [ j ] = 1 ; sieve_count [ i ] ++ ; } } } } }

BLEU: 96.98
Edit Sim: 5


Src: 
function printMinDiffPairs ( arr , n ) { if ( n <= 1 ) return ; arr . sort ( ) ; let minDiff = arr [ 1 ] - arr [ 0 ] ; for ( let i = 2 ; i < n ; i ++ ) minDiff = Math . min ( minDiff , arr [ i ] - arr [ i - 1 ] ) ; for ( let i = 1 ; i < n ; i ++ ) { if ( ( arr [ i ] - arr [ i - 1 ] ) == minDiff ) { document . write ( " " + arr [ i - 1 ] + " " + arr [ i ] + " " ) ; } } }
Ref: 
void printMinDiffPairs ( int arr [ ] , int n ) { if ( n <= 1 ) return ; sort ( arr , arr + n ) ; int minDiff = arr [ 1 ] - arr [ 0 ] ; for ( int i = 2 ; i < n ; i ++ ) minDiff = min ( minDiff , arr [ i ] - arr [ i - 1 ] ) ; for ( int i = 1 ; i < n ; i ++ ) if ( ( arr [ i ] - arr [ i - 1 ] ) == minDiff ) cout << " ( " << arr [ i - 1 ] << " , ▁ " << arr [ i ] << " ) , ▁ " ; }
Hyp: 
void printMinDiffPairs ( int arr [ ] , int n ) { if ( n <= 1 ) return ; sort ( arr , arr + n ) ; int minDiff = arr [ 1 ] - arr [ 0 ] ; for ( int i = 2 ; i < n ; i ++ ) minDiff = min ( minDiff , arr [ i ] - arr [ i - 1 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { if ( ( arr [ i ] - arr [ i - 1 ] ) == minDiff ) { cout << " ( " << arr [ i - 1 ] << " , ▁ " << arr [ i ] << " ) " << endl ; } } }

BLEU: 92.12
Edit Sim: 15


Src: 
function lenghtOfLongestAP ( A , n ) { var dp = new Map ( ) ; var res = 2 ; for ( var i = 0 ; i < n ; ++ i ) { for ( var j = i + 1 ; j < n ; ++ j ) { var d = A [ j ] - A [ i ] ; if ( dp . has ( d ) ) { if ( dp . get ( d ) . has ( i ) ) { var tmp = dp . get ( d ) ; tmp . set ( j , dp . get ( d ) . get ( i ) + 1 ) ; } else { var tmp = new Map ( ) ; tmp . set ( j , 2 ) ; dp . set ( d , tmp ) ; } } else { var tmp = new Map ( ) ; tmp . set ( j , 2 ) ; dp . set ( d , tmp ) ; } res = Math . max ( res , dp . get ( d ) . get ( j ) ) ; } } return res ; }
Ref: 
int lenghtOfLongestAP ( int A [ ] , int n ) { unordered_map < int , unordered_map < int , int > > dp ; int res = 2 ; for ( int i = 0 ; i < n ; ++ i ) { for ( int j = i + 1 ; j < n ; ++ j ) { int d = A [ j ] - A [ i ] ; dp [ d ] [ j ] = dp [ d ] . count ( i ) ? dp [ d ] [ i ] + 1 : 2 ; res = max ( res , dp [ d ] [ j ] ) ; } } return res ; }
Hyp: 
int lenghtOfLongestAP ( int A [ ] , int n ) { unordered_map < int , int > dp ; int res = 2 ; for ( int i = 0 ; i < n ; ++ i ) { for ( int j = i + 1 ; j < n ; ++ j ) { int d = A [ j ] - A [ i ] ; if ( dp . find ( d ) != dp . end ( ) ) { if ( dp [ d ] . find ( i ) != dp . end ( ) ) { int tmp = dp . find ( d ) ; tmp [ j ] = dp [ d ] . find ( i ) + 1 ; } else { int tmp = new Map ( ) ; tmp [ j , 2 ) ; dp [ d ] = tmp ; } } else { int tmp = new Map ( ) ; tmp . set ( j , 2 ) ; dp [ d ] = tmp ; } res = max ( res , dp [ d ] [ j ] ) ; } } return res ; }

BLEU: 50.85
Edit Sim: 265


Src: 
function minTime ( arr , n ) { if ( n <= 0 ) return 0 ; let incl = arr [ 0 ] ; let excl = 0 ; for ( let i = 1 ; i < n ; i ++ ) { let incl_new = arr [ i ] + Math . min ( excl , incl ) ; let excl_new = incl ; incl = incl_new ; excl = excl_new ; } return Math . min ( incl , excl ) ; }
Ref: 
int minTime ( int arr [ ] , int n ) { if ( n <= 0 ) return 0 ; int incl = arr [ 0 ] ; int excl = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int incl_new = arr [ i ] + min ( excl , incl ) ; int excl_new = incl ; incl = incl_new ; excl = excl_new ; } return min ( incl , excl ) ; }
Hyp: 
int minTime ( int arr [ ] , int n ) { if ( n <= 0 ) return 0 ; int incl = arr [ 0 ] ; int excl = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int incl_new = arr [ i ] + min ( excl , incl ) ; int excl_new = incl ; incl = incl_new ; excl = excl_new ; } return min ( incl , excl ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findCount ( arr , n ) { var countOdd = 0 ; for ( var i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 == 1 ) countOdd ++ ; if ( countOdd % 2 == 0 ) return 1 ; else return 0 ; }
Ref: 
int findCount ( int arr [ ] , int n ) { int countOdd = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 == 1 ) countOdd ++ ; if ( countOdd % 2 == 0 ) return 1 ; else return 0 ; }
Hyp: 
int findCount ( int arr [ ] , int n ) { int countOdd = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 == 1 ) countOdd ++ ; if ( countOdd % 2 == 0 ) return 1 ; else return 0 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function power ( x , y ) { let res = 1 ; while ( y > 0 ) { if ( y & 1 ) res = res * x ; y = y >> 1 ; x = x * x ; } return res ; }
Ref: 
int power ( int x , int y ) { int res = 1 ; while ( y ) { if ( y % 2 == 1 ) res = ( res * x ) ; y = y >> 1 ; x = ( x * x ) ; } return res ; }
Hyp: 
int power ( long long x , unsigned int y ) { int res = 1 ; while ( y > 0 ) { if ( y & 1 ) res = res * x ; y = y >> 1 ; x = x * x ; } return res ; }

BLEU: 61.17
Edit Sim: 35


Src: 
function findTriangle ( S ) { let X1 = 0 , Y1 = 0 ; let X2 = MAX , Y2 = 1 ; let X3 = ( MAX - S % MAX ) % MAX ; let Y3 = ( S + X3 ) / MAX ; document . write ( " " + X1 + " " + Y1 + " " ) ; document . write ( " " + X2 + " " + Y2 + " " ) ; document . write ( " " + X3 + " " + Y3 + " " ) }
Ref: 
void findTriangle ( long S ) { long X1 = 0 , Y1 = 0 ; long X2 = MAX , Y2 = 1 ; long X3 = ( MAX - S % MAX ) % MAX ; long Y3 = ( S + X3 ) / MAX ; cout << " ( " << X1 << " , ▁ " << Y1 << " ) STRNEWLINE " ; cout << " ( " << X2 << " , ▁ " << Y2 << " ) STRNEWLINE " ; cout << " ( " << X3 << " , ▁ " << Y3 << " ) " ; }
Hyp: 
void findTriangle ( int S ) { int X1 = 0 , Y1 = 0 ; int X2 = MAX , Y2 = 1 ; int X3 = ( MAX - S % MAX ) % MAX ; int Y3 = ( S + X3 ) / MAX ; cout << " ( " << X1 << " , ▁ " << Y1 << " ) " ; cout << " ( " << X2 << " , ▁ " << Y2 << " ) ▁ " << X3 << " ) ▁ " ; cout << " ( " << X3 << " , ▁ Y3 ) ▁ " ; }

BLEU: 78.02
Edit Sim: 54


Src: 
function isScalarMatrix ( mat ) { for ( let i = 0 ; i < N ; i ++ ) for ( let j = 0 ; j < N ; j ++ ) if ( ( i != j ) && ( mat [ i ] [ j ] != 0 ) ) return false ; for ( let i = 0 ; i < N - 1 ; i ++ ) if ( mat [ i ] [ i ] != mat [ i + 1 ] [ i + 1 ] ) return false ; return true ; }
Ref: 
bool isScalarMatrix ( int mat [ N ] [ N ] ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) if ( ( i != j ) && ( mat [ i ] [ j ] != 0 ) ) return false ; for ( int i = 0 ; i < N - 1 ; i ++ ) if ( mat [ i ] [ i ] != mat [ i + 1 ] [ i + 1 ] ) return false ; return true ; }
Hyp: 
bool isScalarMatrix ( int mat [ ] [ MAX ] ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) if ( ( i != j ) && ( mat [ i ] [ j ] != 0 ) ) return false ; for ( int i = 0 ; i < N - 1 ; i ++ ) if ( mat [ i ] [ i ] != mat [ i + 1 ] [ i + 1 ] ) return false ; return true ; }

BLEU: 95.59
Edit Sim: 5


Src: 
function countElements ( arr , n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; let mean = sum / n ; let cnt = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let newMean = ( sum - arr [ i ] ) / ( n - 1 ) ; if ( newMean == mean ) cnt ++ ; } return cnt ; }
Ref: 
int countElements ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; float mean = ( float ) sum / n ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { float newMean = ( float ) ( sum - arr [ i ] ) / ( n - 1 ) ; if ( newMean == mean ) cnt ++ ; } return cnt ; }
Hyp: 
int countElements ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; int mean = sum / n ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int newMean = ( sum - arr [ i ] ) / ( n - 1 ) ; if ( newMean == mean ) cnt ++ ; } return cnt ; }

BLEU: 87.06
Edit Sim: 28


Src: 
function findArea ( arr , n ) { arr . sort ( ( a , b ) => { return b - a ; } ) var dimension = [ 0 , 0 ] ; for ( var i = 0 , j = 0 ; i < n - 1 && j < 2 ; i ++ ) if ( arr [ i ] == arr [ i + 1 ] ) dimension [ j ++ ] = arr [ i ++ ] ; return ( dimension [ 0 ] * dimension [ 1 ] ) ; }
Ref: 
int findArea ( int arr [ ] , int n ) { sort ( arr , arr + n , greater < int > ( ) ) ; int dimension [ 2 ] = { 0 , 0 } ; for ( int i = 0 , j = 0 ; i < n - 1 && j < 2 ; i ++ ) if ( arr [ i ] == arr [ i + 1 ] ) dimension [ j ++ ] = arr [ i ++ ] ; return ( dimension [ 0 ] * dimension [ 1 ] ) ; }
Hyp: 
int findArea ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int dimension [ 2 ] ; for ( int i = 0 , j = 0 ; i < n - 1 && j < 2 ; i ++ ) if ( arr [ i ] == arr [ i + 1 ] ) dimension [ j ++ ] = arr [ i ++ ] ; return ( dimension [ 0 ] * dimension [ 1 ] ) ; }

BLEU: 83.76
Edit Sim: 34


Src: 
function countRotation ( arr , n ) { for ( let i = 1 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ i - 1 ] ) { return i ; } } return 0 ; }
Ref: 
int countRotation ( int arr [ ] , int n ) { for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ i - 1 ] ) { return i ; } } return 0 ; }
Hyp: 
int countRotation ( int arr [ ] , int n ) { for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ i - 1 ] ) { return i ; } } return 0 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function minOperations ( str , n ) { var count = 0 ; for ( var i = 0 ; i < n - 1 ; i ++ ) { if ( str [ i ] != str [ i + 1 ] ) count ++ ; } return ( count + 1 ) / 2 ; }
Ref: 
int minOperations ( string str , int n ) { int count = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( str [ i ] != str [ i + 1 ] ) count ++ ; } return ( count + 1 ) / 2 ; }
Hyp: 
int minOperations ( string str , int n ) { int count = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( str [ i ] != str [ i + 1 ] ) count ++ ; } return ( count + 1 ) / 2 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function Circumradius ( a , b , c , d ) { var s = ( a + b + c + d ) / 2.0 ; var radius = Math . sqrt ( ( ( a * b ) + ( c * d ) ) * ( ( a * c ) + ( b * d ) ) * ( ( a * d ) + ( b * c ) ) / ( ( s - a ) * ( s - b ) * ( s - c ) * ( s - d ) ) ) ; return radius / 4 ; }
Ref: 
double Circumradius ( int a , int b , int c , int d ) { double s = ( a + b + c + d ) / 2.0 ; double radius = sqrt ( ( ( a * b ) + ( c * d ) ) * ( ( a * c ) + ( b * d ) ) * ( ( a * d ) + ( b * c ) ) / ( ( s - a ) * ( s - b ) * ( s - c ) * ( s - d ) ) ) ; return radius / 4 ; }
Hyp: 
float Circumradius ( float a , float b , float c , float d ) { float s = ( a + b + c + d ) / 2.0 ; float radius = sqrt ( ( ( a * b ) + ( c * d ) ) * ( ( a * c ) + ( b * d ) ) * ( ( a * d ) + ( b * c ) ) / ( ( s - a ) * ( s - b ) * ( s - c ) * ( s - d ) ) ) ; return radius / 4 ; }

BLEU: 86.23
Edit Sim: 34


Src: 
function countDivisibleSubseq ( str , n ) { let len = str . length ; let dp = new Array ( len ) ; for ( let i = 0 ; i < len ; i ++ ) { dp [ i ] = new Array ( n ) ; for ( let j = 0 ; j < n ; j ++ ) { dp [ i ] [ j ] = 0 ; } } dp [ 0 ] [ ( str [ 0 ] - ' ' ) % n ] ++ ; for ( let i = 1 ; i < len ; i ++ ) { dp [ i ] [ ( str [ i ] - ' ' ) % n ] ++ ; for ( let j = 0 ; j < n ; j ++ ) { dp [ i ] [ j ] += dp [ i - 1 ] [ j ] ; dp [ i ] [ ( j * 10 + ( str [ i ] - ' ' ) ) % n ] += dp [ i - 1 ] [ j ] ; } } return dp [ len - 1 ] [ 0 ] ; }
Ref: 
int countDivisibleSubseq ( string str , int n ) { int len = str . length ( ) ; int dp [ len ] [ n ] ; memset ( dp , 0 , sizeof ( dp ) ) ; dp [ 0 ] [ ( str [ 0 ] - '0' ) % n ] ++ ; for ( int i = 1 ; i < len ; i ++ ) { dp [ i ] [ ( str [ i ] - '0' ) % n ] ++ ; for ( int j = 0 ; j < n ; j ++ ) { dp [ i ] [ j ] += dp [ i - 1 ] [ j ] ; dp [ i ] [ ( j * 10 + ( str [ i ] - '0' ) ) % n ] += dp [ i - 1 ] [ j ] ; } } return dp [ len - 1 ] [ 0 ] ; }
Hyp: 
int countDivisibleSubseq ( string str , int n ) { int len = str . length ( ) ; int dp [ len + 1 ] [ n + 1 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; dp [ 0 ] [ ( str [ 0 ] - '0' ) % n ] ++ ; for ( int i = 1 ; i < len ; i ++ ) { dp [ i ] [ ( str [ i ] - '0' ) % n ] ++ ; for ( int j = 0 ; j < n ; j ++ ) { dp [ i ] [ j ] += dp [ i - 1 ] [ j ] ; dp [ i ] [ ( j * 10 + ( str [ i ] - '0' ) ) % n ] += dp [ i - 1 ] [ j ] ; } } return dp [ len - 1 ] [ 0 ] ; }

BLEU: 95.97
Edit Sim: 8


Src: 
function myXOR ( x , y ) { return ( x y ) & ( ~ x ~ y ) ; }
Ref: 
int myXOR ( int x , int y ) { return ( x y ) & ( ~ x ~ y ) ; }
Hyp: 
int myXOR ( int x , int y ) { return ( x y ) & ( ~ x ~ y ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function LCSubStr ( s , t , n , m ) { var dp = Array ( 2 ) . fill ( ) . map ( ( ) => Array ( m + 1 ) . fill ( 0 ) ) ; var res = 0 ; for ( var i = 1 ; i <= n ; i ++ ) { for ( var j = 1 ; j <= m ; j ++ ) { if ( s . charAt ( i - 1 ) == t . charAt ( j - 1 ) ) { dp [ i % 2 ] [ j ] = dp [ ( i - 1 ) % 2 ] [ j - 1 ] + 1 ; if ( dp [ i % 2 ] [ j ] > res ) res = dp [ i % 2 ] [ j ] ; } else dp [ i % 2 ] [ j ] = 0 ; } } return res ; }
Ref: 
int LCSubStr ( string s , string t , int n , int m ) { int dp [ 2 ] [ m + 1 ] ; int res = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { if ( s [ i - 1 ] == t [ j - 1 ] ) { dp [ i % 2 ] [ j ] = dp [ ( i - 1 ) % 2 ] [ j - 1 ] + 1 ; if ( dp [ i % 2 ] [ j ] > res ) res = dp [ i % 2 ] [ j ] ; } else dp [ i % 2 ] [ j ] = 0 ; } } return res ; }
Hyp: 
int LCSubStr ( string s , string t , int n , int m ) { vector < vector < int > > dp ( 2 , vector < int > ( m + 1 ) ) ; int res = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { if ( s [ i - 1 ] == t [ j - 1 ] ) { dp [ i % 2 ] [ j ] = dp [ ( i - 1 ) % 2 ] [ j - 1 ] + 1 ; if ( dp [ i % 2 ] [ j ] > res ) res = dp [ i % 2 ] [ j ] ; } else dp [ i % 2 ] [ j ] = 0 ; } } return res ; }

BLEU: 87.58
Edit Sim: 43


Src: 
function nthTerm ( n ) { return 2 * Math . pow ( n , 2 ) + n - 3 ; }
Ref: 
int nthTerm ( int n ) { return 2 * pow ( n , 2 ) + n - 3 ; }
Hyp: 
int nthTerm ( int n ) { return 2 * pow ( n , 2 ) + n - 3 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function max_area ( n , m , k ) { if ( k > ( n + m - 2 ) ) document . write ( " " ) ; else { let result ; if ( k < Math . max ( m , n ) - 1 ) { result = Math . max ( m * ( n / ( k + 1 ) ) , n * ( m / ( k + 1 ) ) ) ; } else { result = Math . max ( m / ( k - n + 2 ) , n / ( k - m + 2 ) ) ; } document . write ( result ) ; } }
Ref: 
void max_area ( int n , int m , int k ) { if ( k > ( n + m - 2 ) ) cout << " Not ▁ possible " << endl ; else { int result ; if ( k < max ( m , n ) - 1 ) { result = max ( m * ( n / ( k + 1 ) ) , n * ( m / ( k + 1 ) ) ) ; } else { result = max ( m / ( k - n + 2 ) , n / ( k - m + 2 ) ) ; } cout << result << endl ; } }
Hyp: 
void max_area ( int n , int m , int k ) { if ( k > ( n + m - 2 ) ) cout << " NO " ; else { int result ; if ( k < max ( m , n ) - 1 ) { result = max ( m * ( n / ( k + 1 ) ) , n * ( m / ( k + 1 ) ) ) ; } else { result = max ( m / ( k - n + 2 ) , n / ( k - m + 2 ) ) ; } cout << result << endl ; } }

BLEU: 93.87
Edit Sim: 21


Src: 
function cntSplits ( s ) { if ( s [ s . length - 1 ] == ' ' ) return - 1 ; var ans = 0 ; for ( var i = 0 ; i < s . length ; i ++ ) ans += ( s [ i ] == ' ' ) ; return ans ; }
Ref: 
int cntSplits ( string s ) { if ( s [ s . size ( ) - 1 ] == '1' ) return -1 ; int ans = 0 ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) ans += ( s [ i ] == '0' ) ; return ans ; }
Hyp: 
int cntSplits ( string s ) { if ( s [ s . length ( ) - 1 ] == '0' ) return -1 ; int ans = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) ans += ( s [ i ] == '1' ) ; return ans ; }

BLEU: 88.33
Edit Sim: 14


Src: 
function solve ( n , m , x , y , d ) { let top = Math . min ( d , x - 1 ) ; let down = Math . min ( d , n - x ) ; let left = Math . min ( d , y - 1 ) ; let right = Math . min ( d , m - y ) ; let quad1 = top * left ; let quad2 = left * down ; let quad3 = down * right ; let quad4 = right * top ; let totalsq = quad1 + quad2 + quad3 + quad4 ; let singleBlocks = top + down + left + right + 1 ; return totalsq + singleBlocks ; }
Ref: 
int solve ( int n , int m , int x , int y , int d ) { int top = min ( d , x - 1 ) ; int down = min ( d , n - x ) ; int left = min ( d , y - 1 ) ; int right = min ( d , m - y ) ; int quad1 = top * left ; int quad2 = left * down ; int quad3 = down * right ; int quad4 = right * top ; int totalsq = quad1 + quad2 + quad3 + quad4 ; int singleBlocks = top + down + left + right + 1 ; return totalsq + singleBlocks ; }
Hyp: 
int solve ( int n , int m , int x , int y , int d ) { int top = min ( d , x - 1 ) ; int down = min ( d , n - x ) ; int left = min ( d , y - 1 ) ; int right = min ( d , m - y ) ; int quad1 = top * left ; int quad2 = left * down ; int quad3 = down * right ; int quad4 = right * top ; int totalsq = quad1 + quad2 + quad3 + quad4 ; int singleBlocks = top + down + left + right + 1 ; return totalsq + singleBlocks ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countPairs ( N , arr ) { let count = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( i == arr [ arr [ i ] - 1 ] - 1 ) { count ++ ; } } document . write ( count / 2 ) ; }
Ref: 
void countPairs ( int N , int arr [ ] ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( i == arr [ arr [ i ] - 1 ] - 1 ) { count ++ ; } } cout << ( count / 2 ) << endl ; }
Hyp: 
void countPairs ( int N , int arr [ ] ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( i == arr [ arr [ i ] - 1 ] - 1 ) { count ++ ; } } cout << count / 2 ; }

BLEU: 89.29
Edit Sim: 12


Src: 
function maximumSum ( arr , N ) { let ans = 0 ; for ( let bit = 0 ; bit < 32 ; bit ++ ) { let sum = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( arr [ i ] & ( 1 << bit ) ) { sum += arr [ i ] ; } } ans = Math . max ( ans , sum ) ; } return ans ; }
Ref: 
int maximumSum ( int arr [ ] , int N ) { int ans = 0 ; for ( int bit = 0 ; bit < 32 ; bit ++ ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] & ( 1 << bit ) ) { sum += arr [ i ] ; } } ans = max ( ans , sum ) ; } return ans ; }
Hyp: 
int maximumSum ( int arr [ ] , int N ) { int ans = 0 ; for ( int bit = 0 ; bit < 32 ; bit ++ ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] & ( 1 << bit ) ) { sum += arr [ i ] ; } } ans = max ( ans , sum ) ; } return ans ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function sum ( n ) { if ( n < 2 ) { return 1 } else { return 1 / n + ( sum ( n - 1 ) ) } }
Ref: 
float sum ( float n ) { if ( n < 2 ) return 1 ; else return 1 / n + ( sum ( n - 1 ) ) ; }
Hyp: 
float sum ( int n ) { if ( n < 2 ) { return 1 } else { return 1 / n + ( sum ( n - 1 ) ) ; } }

BLEU: 69.87
Edit Sim: 11


Src: 
function countIslands ( mat , m , n ) { let count = 0 ; for ( let i = 0 ; i < m ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { if ( mat [ i ] [ j ] == ' ' ) { if ( ( i == 0 mat [ i - 1 ] [ j ] == ' ' ) && ( j == 0 mat [ i ] [ j - 1 ] == ' ' ) ) count ++ ; } } } return count ; }
Ref: 
int countIslands ( int mat [ ] [ N ] ) { int count = 0 ; for ( int i = 0 ; i < M ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( mat [ i ] [ j ] == ' X ' ) { if ( ( i == 0 mat [ i - 1 ] [ j ] == ' O ' ) && ( j == 0 mat [ i ] [ j - 1 ] == ' O ' ) ) count ++ ; } } } return count ; }
Hyp: 
int countIslands ( vector < vector < int > > & mat , int m , int n ) { int count = 0 ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( mat [ i ] [ j ] == 'I ' ) { if ( ( i == 0 mat [ i - 1 ] [ j ] == 'C ' ) && ( j == 0 mat [ i ] [ j - 1 ] == ' E ' ) ) count ++ ; } } } return count ; }

BLEU: 75.4
Edit Sim: 42


Src: 
function sumPairs ( arr , n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { sum = sum + ( arr [ i ] * ( 2 * n ) ) ; } return sum ; }
Ref: 
int sumPairs ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + ( arr [ i ] * ( 2 * n ) ) ; } return sum ; }
Hyp: 
int sumPairs ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + ( arr [ i ] * ( 2 * n ) ) ; } return sum ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function findCnt ( arr , i , required_sum , n ) { if ( i == n ) { if ( required_sum == 0 ) return 1 ; else return 0 ; } if ( v [ i ] [ required_sum + base ] ) return dp [ i ] [ required_sum + base ] ; v [ i ] [ required_sum + base ] = 1 ; dp [ i ] [ required_sum + base ] = findCnt ( arr , i + 1 , required_sum , n ) + findCnt ( arr , i + 1 , required_sum - arr [ i ] , n ) ; return dp [ i ] [ required_sum + base ] ; }
Ref: 
int findCnt ( int * arr , int i , int required_sum , int n ) { if ( i == n ) { if ( required_sum == 0 ) return 1 ; else return 0 ; } if ( v [ i ] [ required_sum + base ] ) return dp [ i ] [ required_sum + base ] ; v [ i ] [ required_sum + base ] = 1 ; dp [ i ] [ required_sum + base ] = findCnt ( arr , i + 1 , required_sum , n ) + findCnt ( arr , i + 1 , required_sum - arr [ i ] , n ) ; return dp [ i ] [ required_sum + base ] ; }
Hyp: 
int findCnt ( int * arr , int i , int required_sum , int n ) { if ( i == n ) { if ( required_sum == 0 ) return 1 ; else return 0 ; } if ( v [ i ] [ required_sum + base ] ) return dp [ i ] [ required_sum + base ] ; v [ i ] [ required_sum + base ] = 1 ; dp [ i ] [ required_sum + base ] = findCnt ( arr , i + 1 , required_sum , n ) + findCnt ( arr , i + 1 , required_sum - arr [ i ] , n ) ; return dp [ i ] [ required_sum + base ] ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function numberofpairs ( arr , N ) { let answer = 0 ; arr . sort ( ) ; let minDiff = Number . MAX_VALUE ; for ( let i = 0 ; i < N - 1 ; i ++ ) minDiff = Math . min ( minDiff , arr [ i + 1 ] - arr [ i ] ) ; for ( let i = 0 ; i < N - 1 ; i ++ ) { if ( arr [ i + 1 ] - arr [ i ] == minDiff ) answer ++ ; } return answer ; }
Ref: 
int numberofpairs ( int arr [ ] , int N ) { int answer = 0 ; sort ( arr , arr + N ) ; int minDiff = INT_MAX ; for ( int i = 0 ; i < N - 1 ; i ++ ) minDiff = min ( minDiff , arr [ i + 1 ] - arr [ i ] ) ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( arr [ i + 1 ] - arr [ i ] == minDiff ) answer ++ ; } return answer ; }
Hyp: 
int numberofpairs ( int arr [ ] , int N ) { int answer = 0 ; sort ( arr , arr + N ) ; int minDiff = INT_MAX ; for ( int i = 0 ; i < N ; i ++ ) minDiff = min ( minDiff , arr [ i + 1 ] - arr [ i ] ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i + 1 ] - arr [ i ] == minDiff ) answer ++ ; } return answer ; }

BLEU: 93.33
Edit Sim: 8


Src: 
function getHeight ( X ) { return ( 2 * X ) ; }
Ref: 
int getHeight ( int X ) { return ( 2 * X ) ; }
Hyp: 
int getHeight ( int X ) { return ( 2 * X ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function maxSumIS ( arr , n ) { let i , j , max = 0 ; let msis = new Array ( n ) ; for ( i = 0 ; i < n ; i ++ ) msis [ i ] = arr [ i ] ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && msis [ i ] < msis [ j ] + arr [ i ] ) msis [ i ] = msis [ j ] + arr [ i ] ; for ( i = 0 ; i < n ; i ++ ) if ( max < msis [ i ] ) max = msis [ i ] ; return max ; }
Ref: 
int maxSumIS ( int arr [ ] , int n ) { int i , j , max = 0 ; int msis [ n ] ; for ( i = 0 ; i < n ; i ++ ) msis [ i ] = arr [ i ] ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && msis [ i ] < msis [ j ] + arr [ i ] ) msis [ i ] = msis [ j ] + arr [ i ] ; for ( i = 0 ; i < n ; i ++ ) if ( max < msis [ i ] ) max = msis [ i ] ; return max ; }
Hyp: 
int maxSumIS ( int arr [ ] , int n ) { int i , j , max = 0 ; int msis [ n ] ; for ( i = 0 ; i < n ; i ++ ) msis [ i ] = arr [ i ] ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && msis [ i ] < msis [ j ] + arr [ i ] ) msis [ i ] = msis [ j ] + arr [ i ] ; for ( i = 0 ; i < n ; i ++ ) if ( max < msis [ i ] ) max = msis [ i ] ; return max ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function testSomeNumbers ( limit , n ) { if ( n < 3 ) return ; for ( let a = 1 ; a <= limit ; a ++ ) for ( let b = a ; b <= limit ; b ++ ) { let pow_sum = ( Math . pow ( a , n ) + Math . pow ( b , n ) ) ; let c = Math . pow ( pow_sum , 1.0 / n ) ; let c_pow = Math . pow ( Math . round ( c ) , n ) ; if ( c_pow == pow_sum ) { document . write ( " " ) ; return ; } } document . write ( " " + " " ) ; }
Ref: 
void testSomeNumbers ( int limit , int n ) { if ( n < 3 ) return ; for ( int a = 1 ; a <= limit ; a ++ ) for ( int b = a ; b <= limit ; b ++ ) { int pow_sum = pow ( a , n ) + pow ( b , n ) ; double c = pow ( pow_sum , 1.0 / n ) ; int c_pow = pow ( ( int ) c , n ) ; if ( c_pow == pow_sum ) { cout << " Count ▁ example ▁ found " ; return ; } } cout << " No ▁ counter ▁ example ▁ within ▁ given " " ▁ range ▁ and ▁ data " ; }
Hyp: 
void testSomeNumbers ( int limit , int n ) { if ( n < 3 ) return ; for ( int a = 1 ; a <= limit ; a ++ ) for ( int b = a ; b <= limit ; b ++ ) { double pow_sum = ( pow ( a , n ) + pow ( b , n ) ) ; double c = pow ( pow_sum , 1.0 / n ) ; double c_pow = pow ( round ( c ) , n ) ; if ( c_pow == pow_sum ) { cout << " Yes " << endl ; return ; } } cout << " No " << endl ; }

BLEU: 71.5
Edit Sim: 100


Src: 
function findCost ( a , n ) { a . sort ( ( x , y ) => y - x ) ; var count = 0 ; for ( var j = 0 ; j < n ; j ++ ) { var p = a [ j ] - j ; a [ j ] = 0 ; if ( p < 0 ) { p = 0 ; continue ; } count += p ; } return count ; }
Ref: 
int findCost ( int * a , int n ) { sort ( a , a + n , greater < int > ( ) ) ; int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { int p = a [ j ] - j ; a [ j ] = 0 ; if ( p < 0 ) { p = 0 ; continue ; } count += p ; } return count ; }
Hyp: 
int findCost ( int a [ ] , int n ) { sort ( a , a + n ) ; int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { int p = a [ j ] - j ; a [ j ] = 0 ; if ( p < 0 ) { p = 0 ; continue ; } count += p ; } return count ; }

BLEU: 86.13
Edit Sim: 26


Src: 
function minMovesToSort ( arr , n ) { var moves = 0 ; var i , mn = arr [ n - 1 ] ; for ( i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] > mn ) moves += arr [ i ] - mn ; mn = arr [ i ] ; } return moves ; }
Ref: 
int minMovesToSort ( int arr [ ] , int n ) { int moves = 0 ; int i , mn = arr [ n - 1 ] ; for ( i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] > mn ) moves += arr [ i ] - mn ; } return moves ; }
Hyp: 
int minMovesToSort ( int arr [ ] , int n ) { int moves = 0 ; int i , mn = arr [ n - 1 ] ; for ( i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] > mn ) moves += arr [ i ] - mn ; mn = arr [ i ] ; } return moves ; }

BLEU: 89.57
Edit Sim: 17


Src: 
function Bubble_Sort ( arr , n ) { Boolean ( flag = true ) ; for ( var i = 1 ; i < n ; ++ i ) { flag = false ; for ( var j = 0 ; j <= ( n - i - 1 ) ; ++ j ) { if ( arr [ j ] > arr [ j + 1 ] ) { var temp = arr [ j ] ; arr [ j ] = arr [ j + 1 ] ; arr [ j + 1 ] = temp ; flag = true ; } } if ( flag == false ) break ; } }
Ref: 
void Bubble_Sort ( int arr [ ] , int n ) { bool flag ; for ( int i = 1 ; i < n ; ++ i ) { flag = false ; for ( int j = 0 ; j <= ( n - i - 1 ) ; ++ j ) { if ( arr [ j ] > arr [ j + 1 ] ) { swap ( arr [ j ] , arr [ j + 1 ] ) ; flag = true ; } } if ( flag == false ) break ; } }
Hyp: 
void Bubble_Sort ( int arr [ ] , int n ) { Boolean ( flag = true ) ; for ( int i = 1 ; i < n ; ++ i ) { flag = false ; for ( int j = 0 ; j <= ( n - i - 1 ) ; ++ j ) { if ( arr [ j ] > arr [ j + 1 ] ) { int temp = arr [ j ] ; arr [ j ] = arr [ j + 1 ] ; arr [ j + 1 ] = temp ; flag = true ; } } if ( flag == false ) break ; } }

BLEU: 75.32
Edit Sim: 58


Src: 
function primesInRange ( n ) { let fact = 1 ; for ( let k = 2 ; k < n ; k ++ ) { fact = fact * ( k - 1 ) ; if ( ( fact + 1 ) % k == 0 ) document . write ( ( k + " " ) ) ; } }
Ref: 
void primesInRange ( int n ) { int fact = 1 ; for ( int k = 2 ; k < n ; k ++ ) { fact = fact * ( k - 1 ) ; if ( ( fact + 1 ) % k == 0 ) cout << k << endl ; } }
Hyp: 
void primesInRange ( int n ) { int fact = 1 ; for ( int k = 2 ; k < n ; k ++ ) { fact = fact * ( k - 1 ) ; if ( ( fact + 1 ) % k == 0 ) cout << ( k << " ▁ " ) ; } }

BLEU: 87.06
Edit Sim: 9


Src: 
function product ( arr ) { let occurrence = Math . pow ( 2 , arr . length - 1 ) ; let product = 1 ; for ( let i = 0 ; i < arr . length ; i ++ ) { product *= Math . pow ( arr [ i ] , occurrence ) ; } return product ; }
Ref: 
long product ( int arr [ ] , int n ) { double occurrence = pow ( 2 , n - 1 ) ; double product = 1 ; for ( int i = 0 ; i < n ; i ++ ) { product *= pow ( arr [ i ] , occurrence ) ; } return ( long ) product ; }
Hyp: 
long product ( int arr [ ] , int n ) { int occurrence = pow ( 2 , n - 1 ) ; long long product = 1 ; for ( int i = 0 ; i < n ; i ++ ) { product *= pow ( arr [ i ] , occurrence ) ; } return product ; }

BLEU: 85.09
Edit Sim: 22


Src: 
function sumBitDifferences ( arr , n ) { let ans = 0 ; for ( let i = 0 ; i < 32 ; i ++ ) { let count = 0 ; for ( let j = 0 ; j < n ; j ++ ) if ( ( arr [ j ] & ( 1 << i ) ) ) count ++ ; ans += ( count * ( n - count ) * 2 ) ; } return ans ; }
Ref: 
int sumBitDifferences ( int arr [ ] , int n ) { for ( int i = 0 ; i < 32 ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) if ( ( arr [ j ] & ( 1 << i ) ) ) count ++ ; ans += ( count * ( n - count ) * 2 ) ; } return ans ; }
Hyp: 
int sumBitDifferences ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < 32 ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) if ( arr [ j ] & ( 1 << i ) ) count ++ ; ans += ( count * ( n - count ) * 2 ) ; } return ans ; }

BLEU: 91.15
Edit Sim: 18


Src: 
function minimumCost ( a , b ) { var fre1 = Array ( 256 ) . fill ( 0 ) , fre2 = Array ( 256 ) . fill ( 0 ) ; a . split ( ' ' ) . forEach ( c => { fre1 [ c . charCodeAt ( 0 ) ] ++ ; } ) ; b . split ( ' ' ) . forEach ( c => { fre2 [ c . charCodeAt ( 0 ) ] ++ ; } ) ; var mincost = 0 ; for ( var i = 0 ; i < 256 ; i ++ ) { mincost += Math . abs ( fre1 [ i ] - fre2 [ i ] ) ; } document . write ( mincost ) ; }
Ref: 
void minimumCost ( string a , string b ) { vector < int > fre1 ( 256 ) , fre2 ( 256 ) ; for ( char c : a ) fre1 [ ( int ) ( c ) ] ++ ; for ( char c : b ) fre2 [ ( int ) ( c ) ] ++ ; int mincost = 0 ; for ( int i = 0 ; i < 256 ; i ++ ) { mincost += abs ( fre1 [ i ] - fre2 [ i ] ) ; } cout << mincost << endl ; }
Hyp: 
void minimumCost ( string a , string b ) { int fre1 [ 256 ] = { 0 } , fre2 [ 256 ] = { 0 } ; for ( char c : a ) fre1 [ c ] ++ ; for ( char c : b ) fre2 [ c ] ++ ; int mincost = 0 ; for ( int i = 0 ; i < 256 ; i ++ ) { mincost += abs ( fre1 [ i ] - fre2 [ i ] ) ; } cout << mincost ; }

BLEU: 69.65
Edit Sim: 63


Src: 
function Volume_of_cone ( R ) { let V = ( ( 1 / 3.0 ) * ( 3.14 ) * ( 2 * ( R * R ) ) * ( 4 * R ) ) ; return V ; }
Ref: 
float Volume_of_cone ( float R ) { float V = ( 1 / 3.0 ) * ( 3.14 ) * ( 2 * ( R * R ) ) * ( 4 * R ) ; return V ; }
Hyp: 
double Volume_of_cone ( double R ) { double V = ( 1 / 3.0 ) * ( 3.14 ) * ( 2 * ( R * R ) ) * ( 4 * R ) ) ; return V ; }

BLEU: 80.97
Edit Sim: 20


Src: 
function findLen ( arr , n , m ) { var filter = [ ] ; for ( var i = 0 ; i < n ; i ++ ) if ( ( arr [ i ] m ) == m ) filter . push ( arr [ i ] ) ; if ( filter . length == 0 ) return 0 ; var c_or = filter [ 0 ] ; for ( var i = 1 ; i < filter . length ; i ++ ) c_or |= filter [ i ] ; if ( c_or == m ) return filter . length ; return 0 ; }
Ref: 
int findLen ( int * arr , int n , int m ) { vector < int > filter ; for ( int i = 0 ; i < n ; i ++ ) if ( ( arr [ i ] m ) == m ) filter . push_back ( arr [ i ] ) ; if ( filter . size ( ) == 0 ) return 0 ; int c_or = filter [ 0 ] ; for ( int i = 1 ; i < filter . size ( ) ; i ++ ) c_or |= filter [ i ] ; if ( c_or == m ) return filter . size ( ) ; return 0 ; }
Hyp: 
int findLen ( int arr [ ] , int n , int m ) { vector < int > filter ; for ( int i = 0 ; i < n ; i ++ ) if ( ( arr [ i ] m ) == m ) filter . push_back ( arr [ i ] ) ; if ( filter . size ( ) == 0 ) return 0 ; int c_or = filter [ 0 ] ; for ( int i = 1 ; i < filter . size ( ) ; i ++ ) c_or |= filter [ i ] ; if ( c_or == m ) return filter . size ( ) ; return 0 ; }

BLEU: 96.42
Edit Sim: 6


Src: 
function query ( s , i , j ) { let n = s . length ; i %= n ; j %= n ; if ( s [ i ] == s [ j ] ) document . write ( " " + " " ) ; else document . write ( " " + " " ) ; }
Ref: 
void query ( char s [ ] , int i , int j ) { int n = strlen ( s ) ; i %= n ; j %= n ; ( s [ i ] == s [ j ] ) ? ( cout << " Yes " << endl ) : ( cout << " No " << endl ) ; }
Hyp: 
void query ( string & s , int i , int j ) { int n = s . length ( ) ; i %= n ; j %= n ; if ( s [ i ] == s [ j ] ) cout << " Yes " << endl ; else cout << " No " << endl ; }

BLEU: 65.55
Edit Sim: 29


Src: 
function setBitNumber ( n ) { n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; n = n + 1 ; return ( n >> 1 ) ; }
Ref: 
int setBitNumber ( int n ) { n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; n = n + 1 ; return ( n >> 1 ) ; }
Hyp: 
int setBitNumber ( int n ) { n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; n = n + 1 ; return ( n >> 1 ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function lastNon0Digit ( n ) { if ( n < 10 ) return dig [ n ] ; if ( ( parseInt ( n / 10 , 10 ) % 10 ) % 2 == 0 ) return ( 6 * lastNon0Digit ( parseInt ( n / 5 , 10 ) ) * dig [ n % 10 ] ) % 10 ; else return ( 4 * lastNon0Digit ( parseInt ( n / 5 , 10 ) ) * dig [ n % 10 ] ) % 10 ; }
Ref: 
int lastNon0Digit ( int n ) { if ( n < 10 ) return dig [ n ] ; if ( ( ( n / 10 ) % 10 ) % 2 == 0 ) return ( 6 * lastNon0Digit ( n / 5 ) * dig [ n % 10 ] ) % 10 ; else return ( 4 * lastNon0Digit ( n / 5 ) * dig [ n % 10 ] ) % 10 ; }
Hyp: 
int lastNon0Digit ( int n ) { if ( n < 10 ) return dig [ n ] ; if ( ( n / 10 ) % 10 ) % 2 == 0 ) return ( 6 * lastNon0Digit ( n / 5 , 10 ) ) * dig [ n % 10 ] ) % 10 ; else return ( 4 * lastNon0Digit ( n / 5 , 10 ) ) * dig [ n % 10 ] ) % 10 ; }

BLEU: 88.82
Edit Sim: 16


Src: 
function computeXOR ( n ) { switch ( n & 3 ) { case 0 : return n ; case 1 : return 1 ; case 2 : return n + 1 ; case 3 : return 0 ; } }
Ref: 
long computeXOR ( const int n ) { switch ( n & 3 ) { case 0 : return n ; case 1 : return 1 ; case 2 : return n + 1 ; case 3 : return 0 ; } }
Hyp: 
int computeXOR ( int n ) { switch ( n & 3 ) { case 0 : return n ; case 1 : return 1 ; case 2 : return n + 1 ; case 3 : return 0 ; } }

BLEU: 92.28
Edit Sim: 9


Src: 
function findMinMoves ( a , b ) { let ans = 0 ; if ( a == b || Math . abs ( a - b ) == 1 ) { ans = a + b ; } else { let k = Math . min ( a , b ) ; let j = Math . max ( a , b ) ; ans = 2 * k + 2 * ( j - k ) - 1 ; } document . write ( ans ) ; }
Ref: 
void findMinMoves ( int a , int b ) { int ans = 0 ; if ( a == b || abs ( a - b ) == 1 ) { ans = a + b ; } else { int k = min ( a , b ) ; int j = max ( a , b ) ; ans = 2 * k + 2 * ( j - k ) - 1 ; } cout << ans ; }
Hyp: 
int findMinMoves ( int a , int b ) { int ans = 0 ; if ( a == b || abs ( a - b ) == 1 ) { ans = a + b ; } else { int k = min ( a , b ) ; int j = max ( a , b ) ; ans = 2 * k + 2 * ( j - k ) - 1 ; } cout << ans ; }

BLEU: 98.77
Edit Sim: 4


Src: 
function countUnmarked ( N ) { if ( N % 2 == 0 ) return N / 2 ; else return N / 2 + 1 ; }
Ref: 
int countUnmarked ( int N ) { if ( N % 2 == 0 ) return N / 2 ; else return N / 2 + 1 ; }
Hyp: 
int countUnmarked ( int N ) { if ( N % 2 == 0 ) return N / 2 ; else return N / 2 + 1 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function SellingPrice ( CP , PP ) { var P_decimal = 1 + ( PP / 100 ) ; var res = P_decimal * CP ; return res . toFixed ( 1 ) ; }
Ref: 
float SellingPrice ( float CP , float PP ) { float P_decimal = 1 + ( PP / 100 ) ; float res = P_decimal * CP ; return res ; }
Hyp: 
double SellingPrice ( double CP , double PP ) { double P_decimal = 1 + ( PP / 100 ) ; double res = P_decimal * CP ; return res ; }

BLEU: 64.87
Edit Sim: 30


Src: 
function rotateRec ( n , L , B ) { var m = Number . MAX_VALUE for ( var i = 0 ; i < n ; i ++ ) { if ( Math . max ( L [ i ] , B [ i ] ) <= m ) m = Math . max ( L [ i ] , B [ i ] ) ; else if ( Math . min ( L [ i ] , B [ i ] ) <= m ) m = Math . min ( L [ i ] , B [ i ] ) ; else { return 0 ; } } return 1 ; }
Ref: 
int rotateRec ( int n , int L [ ] , int B [ ] ) { int m = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { if ( max ( L [ i ] , B [ i ] ) <= m ) m = max ( L [ i ] , B [ i ] ) ; else if ( min ( L [ i ] , B [ i ] ) <= m ) m = min ( L [ i ] , B [ i ] ) ; else { return 0 ; } } return 1 ; }
Hyp: 
int rotateRec ( int n , int L [ ] , int B [ ] ) { int m = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { if ( max ( L [ i ] , B [ i ] ) <= m ) m = max ( L [ i ] , B [ i ] ) ; else if ( min ( L [ i ] , B [ i ] ) <= m ) m = min ( L [ i ] , B [ i ] ) ; else { return 0 ; } } return 1 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function maxFraction ( first , sec ) { a = first [ 0 ] ; b = first [ 1 ] c = sec [ 0 ] ; d = sec [ 1 ] Y = a * d - b * c return ( Y > 0 ) ? first : sec ; }
Ref: 
Fraction maxFraction ( Fraction first , Fraction sec ) { int a = first . num ; int b = first . den ; int c = sec . num ; int d = sec . den ; int Y = a * d - b * c ; return ( Y > 0 ) ? first : sec ; }
Hyp: 
int maxFraction ( int first [ ] , int sec [ ] ) { a = first [ 0 ] ; b = first [ 1 ] c = sec [ 0 ] ; d = sec [ 1 ] Y = a * d - b * c ; return ( Y > 0 ) ? first : sec ; }

BLEU: 47.89
Edit Sim: 61


Src: 
function findNthNumber ( N ) { let result = 0 ; let p = 1 ; while ( N > 0 ) { result += ( p * ( N % 9 ) ) ; N = parseInt ( N / 9 , 10 ) ; p = p * 10 ; } return result ; }
Ref: 
long findNthNumber ( long long N ) { long long result = 0 ; long long p = 1 ; while ( N > 0 ) { result += ( p * ( N % 9 ) ) ; N = N / 9 ; p = p * 10 ; } return result ; }
Hyp: 
int findNthNumber ( int N ) { int result = 0 ; int p = 1 ; while ( N > 0 ) { result += ( p * ( N % 9 ) ) ; N /= 9 ; p = p * 10 ; } return result ; }

BLEU: 70.75
Edit Sim: 32


Src: 
function productAtKthLevel ( tree , k ) { let level = - 1 ; let product = 1 ; let n = tree . length ; for ( let i = 0 ; i < n ; i ++ ) { if ( tree [ i ] == ' ' ) level ++ ; else if ( tree [ i ] == ' ' ) level -- ; else { if ( level == k ) product *= ( tree [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ) ; } } return product ; }
Ref: 
int productAtKthLevel ( string tree , int k ) { int level = -1 ; int n = tree . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( tree [ i ] == ' ( ' ) level ++ ; else if ( tree [ i ] == ' ) ' ) level -- ; else { if ( level == k ) product *= ( tree [ i ] - '0' ) ; } } return product ; }
Hyp: 
int productAtKthLevel ( string tree , int k ) { int level = -1 ; int product = 1 ; int n = tree . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( tree [ i ] == ' ( ' ) level ++ ; else if ( tree [ i ] == ' ( ' ) level -- ; else { if ( level == k ) product *= ( tree [ i ] - ' a ' ) ; } } return product ; }

BLEU: 85.29
Edit Sim: 28


Src: 
function findMinMoves ( arr , N ) { let sum = 0 ; for ( let i = 0 ; i < N ; i ++ ) sum += arr [ i ] ; if ( sum % N != 0 ) return - 1 ; let avg = sum / N ; let total = 0 ; let needCount = 0 ; for ( let i = 0 ; i < N ; i ++ ) { needCount += ( arr [ i ] - avg ) ; total = Math . max ( Math . max ( Math . abs ( needCount ) , arr [ i ] - avg ) , total ) ; } return total ; }
Ref: 
int findMinMoves ( int arr [ ] , int N ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) sum += arr [ i ] ; if ( sum % N != 0 ) return -1 ; int avg = sum / N ; int total = 0 ; int needCount = 0 ; for ( int i = 0 ; i < N ; i ++ ) { needCount += ( arr [ i ] - avg ) ; total = max ( max ( abs ( needCount ) , arr [ i ] - avg ) , total ) ; } return total ; }
Hyp: 
int findMinMoves ( int arr [ ] , int N ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) sum += arr [ i ] ; if ( sum % N != 0 ) return -1 ; int avg = sum / N ; int total = 0 ; int needCount = 0 ; for ( int i = 0 ; i < N ; i ++ ) { needCount += ( arr [ i ] - avg ) ; total = max ( abs ( needCount ) , arr [ i ] - avg ) , total ) ; } return total ; }

BLEU: 98.09
Edit Sim: 6


Src: 
function countPairs ( arr , n ) { let count = 0 ; for ( let i = 0 ; i < n - 1 ; i ++ ) { for ( let j = i + 1 ; j < n ; j ++ ) { if ( ( arr [ j ] % arr [ i ] == 0 ) && ( j + 1 ) % ( i + 1 ) == 0 && ( arr [ j ] / arr [ i ] == ( j + 1 ) / ( i + 1 ) ) ) { count ++ ; } } } return count ; }
Ref: 
int countPairs ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( ( arr [ j ] % arr [ i ] == 0 ) && ( j + 1 ) % ( i + 1 ) == 0 && ( arr [ j ] / arr [ i ] == ( j + 1 ) / ( i + 1 ) ) ) { count ++ ; } } } return count ; }
Hyp: 
int countPairs ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( ( arr [ j ] % arr [ i ] == 0 ) && ( j + 1 ) % ( i + 1 ) == 0 && ( arr [ j ] / arr [ i ] == ( j + 1 ) / ( i + 1 ) ) ) { count ++ ; } } } return count ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function possibleways ( n ) { if ( n % 2 == 1 ) return 0 ; else if ( n % 4 == 0 ) return n / 4 - 1 ; else return n / 4 ; }
Ref: 
int possibleways ( int n ) { if ( n % 2 == 1 ) return 0 ; else if ( n % 4 == 0 ) return n / 4 - 1 ; else return n / 4 ; }
Hyp: 
int possibleways ( int n ) { if ( n % 2 == 1 ) return 0 ; else if ( n % 4 == 0 ) return n / 4 - 1 ; else return n / 4 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function minPerimeter ( n ) { let l = Math . sqrt ( n ) ; let sq = l * l ; if ( sq == n ) return l * 4 ; else { let row = n / l ; let perimeter = 2 * ( l + row ) ; if ( n % l != 0 ) perimeter += 2 ; return perimeter ; } }
Ref: 
int minPerimeter ( int n ) { int l = sqrt ( n ) ; int sq = l * l ; if ( sq == n ) return l * 4 ; else { long long int row = n / l ; long long int perimeter = 2 * ( l + row ) ; if ( n % l != 0 ) perimeter += 2 ; return perimeter ; } }
Hyp: 
int minPerimeter ( int n ) { int l = sqrt ( n ) ; int sq = l * l ; if ( sq == n ) return l * 4 ; else { int row = n / l ; int perimeter = 2 * ( l + row ) ; if ( n % l != 0 ) perimeter += 2 ; return perimeter ; } }

BLEU: 90.27
Edit Sim: 20


Src: 
function countOrderedPairs ( N ) { var count_pairs = 0 ; for ( var i = 1 ; i <= Math . sqrt ( N - 1 ) ; ++ i ) { for ( var j = i ; j * i < N ; ++ j ) ++ count_pairs ; } count_pairs *= 2 ; count_pairs -= parseInt ( Math . sqrt ( N - 1 ) ) ; return count_pairs ; }
Ref: 
int countOrderedPairs ( int N ) { int count_pairs = 0 ; for ( int i = 1 ; i <= sqrt ( N - 1 ) ; ++ i ) { for ( int j = i ; j * i < N ; ++ j ) ++ count_pairs ; } count_pairs *= 2 ; count_pairs -= int ( sqrt ( N - 1 ) ) ; return count_pairs ; }
Hyp: 
int countOrderedPairs ( int N ) { int count_pairs = 0 ; for ( int i = 1 ; i <= sqrt ( N - 1 ) ; ++ i ) { for ( int j = i ; j * i < N ; ++ j ) ++ count_pairs ; } count_pairs *= 2 ; count_pairs -= sqrt ( N - 1 ) ; return count_pairs ; }

BLEU: 92.52
Edit Sim: 8


Src: 
function printNumberOfPairs ( N ) { var st = new Set ( ) ; for ( let i = 2 ; i * i <= N ; i ++ ) { let x = i ; while ( x <= N ) { x *= i ; if ( x <= N ) { st . add ( x ) ; } } } document . write ( st . size ) ; }
Ref: 
void printNumberOfPairs ( int N ) { unordered_set < int > st ; for ( int i = 2 ; i * i <= N ; i ++ ) { int x = i ; while ( x <= N ) { x *= i ; if ( x <= N ) { st . insert ( x ) ; } } } cout << st . size ( ) ; }
Hyp: 
void printNumberOfPairs ( int N ) { unordered_set < int > st ; for ( int i = 2 ; i * i <= N ; i ++ ) { int x = i ; while ( x <= N ) { x *= i ; if ( x <= N ) { st . insert ( x ) ; } } } cout << st . size ( ) ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function maxSum ( arr , n ) { arr . sort ( ) ; let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum += ( arr [ i ] * i ) ; return sum ; }
Ref: 
int maxSum ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += ( arr [ i ] * i ) ; return sum ; }
Hyp: 
int maxSum ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += ( arr [ i ] * i ) ; return sum ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countFreq ( str ) { let count = new Array ( limit + 1 ) ; for ( let i = 0 ; i < count . length ; i ++ ) { count [ i ] = 0 ; } for ( let i = 0 ; i < str . length ; i ++ ) count [ str [ i ] . charCodeAt ( 0 ) ] ++ ; for ( let i = 0 ; i <= limit ; i ++ ) { if ( count [ i ] > 0 ) document . write ( String . fromCharCode ( i ) + " " + count [ i ] + " " ) ; } }
Ref: 
void countFreq ( string str ) { vector < int > count ( limit + 1 , 0 ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) count [ str [ i ] ] ++ ; for ( int i = 0 ; i <= limit ; i ++ ) if ( count [ i ] > 0 ) cout << ( char ) i << " ▁ " << count [ i ] << endl ; }
Hyp: 
void countFreq ( char * str , int limit ) { int count [ limit + 1 ] ; memset ( count , 0 , sizeof ( count ) ) ; for ( char x : str ) count [ x ] ++ ; for ( int i = 0 ; i <= limit ; i ++ ) { if ( count [ i ] ) cout << char ( i ) << " ▁ " << count [ i ] << " ▁ " ; } }

BLEU: 46.83
Edit Sim: 88


Src: 
function countNumbers ( l , r ) { let count = 0 ; for ( let i = l ; i <= r ; i ++ ) { if ( ( i & 1 ) == 0 ) { count ++ ; } } return count ; }
Ref: 
int countNumbers ( int l , int r ) { int count = 0 ; for ( int i = l ; i <= r ; i ++ ) { if ( ( i & 1 ) == 0 ) { count ++ ; } } return count ; }
Hyp: 
int countNumbers ( int l , int r ) { int count = 0 ; for ( int i = l ; i <= r ; i ++ ) { if ( ( i & 1 ) == 0 ) { count ++ ; } } return count ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function seriesSum ( n ) { return ( n * ( n + 1 ) * ( n + 2 ) ) / 6 ; }
Ref: 
int seriesSum ( int n ) { return ( n * ( n + 1 ) * ( n + 2 ) ) / 6 ; }
Hyp: 
int seriesSum ( int n ) { return ( n * ( n + 1 ) * ( n + 2 ) ) / 6 ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function multiply ( n , m ) { let ans = 0 , count = 0 ; while ( m ) { if ( m % 2 == 1 ) ans += n << count ; count ++ ; m = Math . floor ( m / 2 ) ; } return ans ; }
Ref: 
int multiply ( int n , int m ) { int ans = 0 , count = 0 ; while ( m ) { if ( m % 2 == 1 ) ans += n << count ; count ++ ; m /= 2 ; } return ans ; }
Hyp: 
int multiply ( int n , int m ) { int ans = 0 , count = 0 ; while ( m ) { if ( m % 2 == 1 ) ans += n << count ; count ++ ; m = m / 2 ; } return ans ; }

BLEU: 91.18
Edit Sim: 5


Src: 
function xorPairCount ( arr , n , x ) { let s = new Set ( ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( s . has ( x ^ arr [ i ] ) ) { result ++ ; } s . add ( arr [ i ] ) ; } return result ; }
Ref: 
int xorPairCount ( int arr [ ] , int n , int x ) { unordered_set < int > s ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . find ( x ^ arr [ i ] ) != s . end ( ) ) result ++ ; s . insert ( arr [ i ] ) ; } return result ; }
Hyp: 
int xorPairCount ( int arr [ ] , int n , int x ) { unordered_set < int > s ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . find ( x ^ arr [ i ] ) != s . end ( ) ) { result ++ ; } s . insert ( arr [ i ] ) ; } return result ; }

BLEU: 93.28
Edit Sim: 4


Src: 
function hexDiagonal ( a ) { if ( a < 0 ) return - 1 ; var d = 1.73 * a ; return d ; }
Ref: 
float hexDiagonal ( float a ) { if ( a < 0 ) return -1 ; float d = 1.73 * a ; return d ; }
Hyp: 
float hexDiagonal ( float a ) { if ( a < 0 ) return -1 ; float d = 1.73 * a ; return d ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function countRectangles ( radius ) { let rectangles = 0 ; let diameter = 2 * radius ; let diameterSquare = diameter * diameter ; for ( let a = 1 ; a < 2 * radius ; a ++ ) { for ( let b = 1 ; b < 2 * radius ; b ++ ) { let diagonalLengthSquare = ( a * a + b * b ) ; if ( diagonalLengthSquare <= diameterSquare ) { rectangles ++ ; } } } return rectangles ; }
Ref: 
int countRectangles ( int radius ) { int rectangles = 0 ; int diameter = 2 * radius ; int diameterSquare = diameter * diameter ; for ( int a = 1 ; a < 2 * radius ; a ++ ) { for ( int b = 1 ; b < 2 * radius ; b ++ ) { int diagonalLengthSquare = ( a * a + b * b ) ; if ( diagonalLengthSquare <= diameterSquare ) { rectangles ++ ; } } } return rectangles ; }
Hyp: 
int countRectangles ( int radius ) { int rectangles = 0 ; int diameter = 2 * radius ; int diameterSquare = diameter * diameter ; for ( int a = 1 ; a < 2 * radius ; a ++ ) { for ( int b = 1 ; b < 2 * radius ; b ++ ) { int diagonalLengthSquare = ( a * a + b * b ) ; if ( diagonalLengthSquare <= diameterSquare ) { rectangles ++ ; } } } return rectangles ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function getCount ( N ) { if ( N % 2 == 1 ) return " " ; let result = " " ; for ( let i = 1 ; i <= N / 2 - 1 ; i ++ ) result += " " ; return result ; }
Ref: 
string getCount ( int N ) { if ( N % 2 == 1 ) return 0 ; string result = "9" ; for ( int i = 1 ; i <= N / 2 - 1 ; i ++ ) result += "0" ; return result ; }
Hyp: 
string getCount ( int N ) { if ( N % 2 == 1 ) return " Yes " ; string result = " No " ; for ( int i = 1 ; i <= N / 2 - 1 ; i ++ ) result += " ▁ " ; return result ; }

BLEU: 74.79
Edit Sim: 14


Src: 
function findSum ( n ) { n -- ; let sum = 0 ; sum += ( n * ( n + 1 ) ) / 2 ; sum += ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; return sum ; }
Ref: 
int findSum ( int n ) { n -- ; int sum = 0 ; sum += ( n * ( n + 1 ) ) / 2 ; sum += ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; return sum ; }
Hyp: 
int findSum ( int n ) { n -- ; int sum = 0 ; sum += ( n * ( n + 1 ) ) / 2 ; sum += ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; return sum ; }

BLEU: 100.0
Edit Sim: 0


Src: 
function checkSolution ( a , b , c ) { if ( ( ( b * b ) - ( 4 * a * c ) ) > 0 ) document . write ( " " ) ; else if ( ( ( b * b ) - ( 4 * a * c ) ) == 0 ) document . write ( " " ) ; else document . write ( " " ) ; }
Ref: 
void checkSolution ( int a , int b , int c ) { if ( ( ( b * b ) - ( 4 * a * c ) ) > 0 ) cout << "2 ▁ solutions " ; else if ( ( ( b * b ) - ( 4 * a * c ) ) == 0 ) cout << "1 ▁ solution " ; else cout << " No ▁ solutions " ; }
Hyp: 
void checkSolution ( int a , int b , int c ) { if ( ( ( b * b ) - ( 4 * a * c ) ) > 0 ) cout << " Yes " ; else if ( ( ( b * b ) - ( 4 * a * c ) ) == 0 ) cout << " No " ; else cout << " Yes " ; }

BLEU: 83.59
Edit Sim: 34


