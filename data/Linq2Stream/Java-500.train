public List<Pair<String, Double>> customerInRegionOrdersTotalAverage(String region) { List<Customer> customers = getCustomerList(); List<Pair<String, Double>> ordersTotalAverage = customers.stream().filter(c -> c.getRegion().equals(region)) .map(c -> Pair.with(c.getCustomerId(), c.getOrders().stream().mapToDouble(o -> o.getTotal()).average().getAsDouble())).toList(); return ordersTotalAverage; }
public List<Triplet<String, Integer, Integer>> customerSelectManyCustomerOrderDateYearAndMonth() { List<Customer> customers = getCustomerList(); List<Triplet<String, Integer, Integer>> customerProperties = customers.stream().flatMap(c -> c.getOrders() .stream().map(o -> Triplet.with(c.getCustomerId(), o.getOrderDate().getYear(), o.getOrderDate().getMonthValue()))).toList(); return customerProperties; }
public List<Pair<String, Product>> productLeftOuterJoinCategories() { String[] categories = {"Beverages", "Condiments", "Vegetables", "Dairy Products", "Seafood"}; List<Product> products = getProductList(); List<Pair<String, Product>> q = Arrays.stream(categories).map( c -> Pair.with(c, products.stream().filter(p -> p.getCategory().equals(c)) .collect(Collectors.toList()))).flatMap(t -> defaultIfEmpty(t.getValue1(), null).stream() .map(p1 -> Pair.with(t.getValue0(), p1))).toList(); return q; }
public List<Pair<Boolean, List<Double>>> doubleGroupByBoolOrderbyFraction() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; List<Pair<Boolean, List<Double>>> numbersGroups = Arrays.stream(numbers).boxed().collect(groupingBy(n -> n > 5)) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().sorted(Comparator.comparing( n -> n - (int) n.doubleValue())).toList())).toList(); return numbersGroups; }
public List<Pair<String, List<Customer>>> customerEachCountryOrdersMinCustomer() { List<Customer> customers = getCustomerList(); List<Pair<String, List<Customer>>> customerOrdersMin = customers.stream().collect(groupingBy(c -> c.getCountry())) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream(). collect(groupingBy(c -> c.getOrders().size())).entrySet() .stream().min(Map.Entry.comparingByKey()).get().getValue())).toList(); return customerOrdersMin; }
public Map<String, List<Product>> productEachGroupTakeWhile() { List<Product> products = getProductList(); Map<String, List<Product>> after3EachGroups = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().takeWhile(p -> p.getProductId() > 100).toList())); return after3EachGroups; }
public Map<Boolean, List<Double>> doubleGroupByBoolDictOrderby() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; Map<Boolean, List<Double>> numbersGroups = Arrays.stream(numbers).boxed().collect(groupingBy(n -> n > 5)) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().sorted().toList())); return numbersGroups; }
public List<Double> bigDoubleOrderbyFractionDescendingThenby() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; List<Double> sortedNumbers = Arrays.stream(numbers).filter(n->n>3).boxed().sorted( Comparator.comparing((Double n) -> n - (int) n.doubleValue(),Comparator.reverseOrder()) .thenComparing(Comparator.naturalOrder())).toList(); return sortedNumbers; }
public double[] doublesConvertToDescendingArray() { double[] doubles = {1.7, 2.3, 1.9, 4.1, 2.9}; double[] doublesArray = Arrays.stream(doubles).boxed().sorted(Comparator.reverseOrder()).mapToDouble(d -> d).toArray(); return doublesArray; }
public double[] convertSelectedDoubleItemToArrayAndPrint() { Object[] numbers = { null, 1.0, "two", 3, "four", 5, "six", 7.0 }; double[] doubles = Arrays.stream(numbers).filter(o->o instanceof Double).mapToDouble(d-> (double) d).toArray(); for (int i = 0; i < doubles.length; i++) System.out.println(doubles[i]); return doubles; }
public Map<String, Integer> customerDistinctOrdersCountDict() { List<Customer> customers = getCustomerList(); Map<String, Integer> orderCounts = customers.stream().collect(toMap( c -> c.getCustomerId(), c -> (int) c.getOrders().stream().distinct().count())); return orderCounts; }
public List<Customer> repeatedCustomers() { List<Customer> customers =  Collections.nCopies(5, Customer.DEFAULT); return customers; }
public int[] bigIntAddIndex() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int[] bigNumbers = Arrays.stream(numbers).filter(n -> n > 5).toArray(); int[] numSelected = IntStream.range(0, bigNumbers.length).map(i -> bigNumbers[i] + i).toArray(); return numSelected; }
public List<Product> expensiveProductSkipWhile() { List<Product> products = getProductList(); List<Product> after3Products = products.stream().filter(p -> p.getUnitPrice() > 100).dropWhile(p -> p.getProductId() > 100).toList(); return after3Products; }
public int numbersSumTwice() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int numbersSum = Arrays.stream(numbers).map(n -> n * 2).sum(); return numbersSum; }
public int intDotProduct() { int[] numbersA = {0, 2, 4, 5, 6, 8, 9}; int[] numbersB = {1, 3, 5, 7, 8, 10, 11}; int length = numbersA.length; int dotProduct = IntStream.range(0, length).map(i -> numbersA[i] * numbersB[i]).sum(); return dotProduct; }
public boolean customerOrdersNestedAnyMatch() { List<Customer> customers = getCustomerList(); boolean anyMatch = customers.stream().flatMap(c -> c.getOrders().stream() .map(o -> Pair.with(c.getCustomerId(), o.getOrderDate()))) .anyMatch(t -> t.getValue1().isAfter(LocalDate.of(2000, 1, 1))); return anyMatch; }
public List<String> indexedSelectManyString() { List<Customer> customers = getCustomerList(); List<String> customerOrders = IntStream.range(0, customers.size()).boxed().flatMap( i -> customers.get(i).getOrders().stream().map( o -> "Customer #" + (i + 1) + " has an order with OrderID " + o.getOrderId())) .collect(Collectors.toList()); return customerOrders; }
public double[] doubleUnion() { double[] numbersA = {0.1, 2.2, 4.3, 5.4, 6.5, 8.6, 9.7}; double[] numbersB = {0.1, 3.3, 5.4, 7.7, 8.6}; double[] uniqueNumbers = DoubleStream.concat(Arrays.stream(numbersA), Arrays.stream(numbersB)).distinct().toArray(); return uniqueNumbers; }
public Map<Pair<String, Integer>, List<Customer>> customerGroupJoinRegionsWithCodeRegion() { List<Pair<String, Integer>> regions = Arrays.asList( Pair.with("BC", 101), Pair.with("BC", 105), Pair.with("OR", 121), Pair.with("LA", 143) ); List<Customer> customers = getCustomerList(); Map<Pair<String, Integer>, List<Customer>> q = regions.stream().map(r -> Pair.with(r, customers.stream() .filter(c -> c.getRegion().equals(r.getValue0())).toList())) .collect(toMap(t->t.getValue0(),t->t.getValue1())); return q; }
public List<Integer> intTake() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; List<Integer> after3Numbers = Arrays.stream(numbers).limit(3).boxed().toList(); return after3Numbers; }
public List<Pair<String, Order>> customerIdAndFirstOrDefaultOrder() { List<Customer> customers = getCustomerList(); List<Pair<String, Order>> customerProperties = customers.stream().map(c -> Pair.with(c.getCustomerId(), c.getOrders().stream().findFirst().orElse(Order.DEFAULT))).toList(); return customerProperties; }
public int[] intUnion() { int[] numbersA = {0, 2, 4, 5, 9}; int[] numbersB = {0, 2, 4, 5, 9}; int[] uniqueNumbers = IntStream.concat(Arrays.stream(numbersA), Arrays.stream(numbersB)).distinct().toArray(); return uniqueNumbers; }
public List<Pair<String, List<Product>>> productEachCategoryMaxUnitPriceProducts() { List<Product> products = getProductList(); List<Pair<String, List<Product>>> categories = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().collect(groupingBy(p -> p.getUnitPrice())) .entrySet().stream().max(Map.Entry.comparingByKey()).get().getValue())).toList(); return categories; }
public List<Integer> shortStringLengthOrderby() { String[] words = {"cherry", "apple", "blueberry", "pear", "peach", "melon"}; List<Integer> sortedWords = Arrays.stream(words).filter(w -> w.length() < 6).map(w -> w.length()).sorted().toList(); return sortedWords; }
public List<String> stringTakeCount(int n) { String[] words = {"cherry", "apple", "blueberry", "banana", "abacus"}; List<String> afterNWords = Arrays.stream(words).limit(3).toList(); return afterNWords; }
public boolean oddIntAnyMatch() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; boolean anyMatch = Arrays.stream(numbers).filter(i -> i % 2 == 1).anyMatch(n -> n > 3); return anyMatch; }
public boolean unequalInts() { int[] numbersA = {0, 2, 4, 5, 9}; int[] numbersB = {1, 3, 5, 6, 10}; boolean equal = Arrays.equals(numbersA, numbersB); return equal; }
public List<String> stringOrderbyCustomThenbyLengthCustom() { String[] words = {"aPPLE", "AbAcUs", "bRaNcH", "BlUeBeRrY", "ClOvEr", "cHeRry"}; List<String> sortedWords = Arrays.stream(words) .sorted(Comparator.comparing((String w) -> w,new CaseInsensitiveComparer()) .thenComparing(w -> w.length(),new CustomNumberComparer())).toList(); return sortedWords; }
public List<String> stringOrderbyDescendingLength() { String[] words = {"cherry", "apple", "blueberry"}; List<String> sortedWords = Arrays.stream(words).sorted(Comparator.comparing(w -> w.length(), Comparator.reverseOrder())).toList(); return sortedWords; }
public Map<Character, List<String>> stringGroupByFirstCharDictOrderby() { String[] words = {"blueberry", "chimpanzee", "abacus", "banana", "apple", "cheese"}; Map<Character, List<String>> wordsGroups = Arrays.stream(words).collect(groupingBy(w -> w.charAt(0))) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().sorted().toList())); return wordsGroups; }
public List<Pair<String, List<Product>>> expensiveProductEachCategoryMaxUnitPriceProducts() { List<Product> products = getProductList(); List<Pair<String, List<Product>>> categories = products.stream().filter(p -> p.getUnitPrice() > 100). collect(groupingBy(p -> p.getCategory())).entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().collect(groupingBy(p -> p.getUnitPrice())) .entrySet().stream().max(Map.Entry.comparingByKey()).get().getValue())).toList(); return categories; }
public List<Double> bigDoubleOrderbyModDescendingThenbyDescending() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; List<Double> sortedNumbers = Arrays.stream(numbers).filter(n->n>3).boxed().sorted( Comparator.comparing((Double n) -> n % 1.5,Comparator.reverseOrder()) .thenComparing(Comparator.reverseOrder())).toList(); return sortedNumbers; }
public List<Integer> repeatedIntsWithValue(int value) { List<Integer> numbers = Collections.nCopies(10, value); return numbers; }
public List<Pair<Boolean, List<Double>>> doubleGroupByBoolOrderbyDescending() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; List<Pair<Boolean, List<Double>>> numbersGroups = Arrays.stream(numbers).boxed().collect(groupingBy(n -> n > 5)) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().sorted(Comparator.reverseOrder()).toList())).toList(); return numbersGroups; }
public List<String> stringOrderbyDescending() { String[] words = {"cherry", "apple", "blueberry"}; List<String> sortedWords = Arrays.stream(words).sorted(Comparator.reverseOrder()).toList(); return sortedWords; }
public List<Product> productSkipWhile() { List<Product> products = getProductList(); List<Product> after3Products = products.stream().dropWhile(p -> p.getProductId() > 100).toList(); return after3Products; }
public List<Pair<String, LocalDate>> waCustomerOrdersEachNestedSkipWhile() { List<Customer> customers = getCustomerList(); List<Pair<String, LocalDate>> after3EachWAOrders = customers.stream().filter(c -> c.getRegion().equals("WA")) .flatMap(c -> c.getOrders().stream().dropWhile(o -> o.getOrderDate() .isAfter(LocalDate.of(2000, 1, 1))) .map(o -> Pair.with(c.getCustomerId(), o.getOrderDate()))).toList(); return after3EachWAOrders; }
public Map<String, Map<String, Map<String, Customer>>> customerNestedGroupByRegionAndCountryAndName() { List<Customer> customers = getCustomerList(); Map<String, Map<String, Map<String, Customer>>> customerGroups = customers.stream().collect(groupingBy(p -> p.getRegion())) .entrySet().stream().collect(toMap( g -> g.getKey(), g -> g.getValue().stream().collect(groupingBy(c -> c.getCountry())) .entrySet().stream().collect(toMap( g1 -> g1.getKey(), g1 -> g1.getValue().stream().collect(toMap( c -> c.getCompanyName(), c -> c)))))); return customerGroups; }
public List<String> intersectOfName() { List<Product> products = getProductList(); List<Customer> customers = getCustomerList(); var productNames = products.stream().map(p -> p.getProductName()); var customerNames = customers.stream().map(c -> c.getCompanyName()); List<String> sharedNames = productNames.distinct().filter(a -> customerNames.anyMatch(b -> b.equals(a))).toList(); return sharedNames; }
public void shortStringLengthEager() { String[] words = {"cherry", "apple", "blueberry"}; AtomicInteger i = new AtomicInteger(0); var q = Arrays.stream(words).filter(w->w.length()<7).map(w -> w.length()).map(n -> i.addAndGet(n)).toList(); for (var v : q) System.out.println(v + " " + i); }
public boolean productAllMatch() { List<Product> products = getProductList(); boolean allMatch = products.stream().allMatch(p -> p.getUnitsInStock() > 0); return allMatch; }
public double numbersAggregateFindMax() { double[] numbers = {1.7, 2.3, 1.9, 4.1, 2.9}; double aggregateSum = Arrays.stream(numbers).filter(n -> n > 2).reduce((a, b) -> Math.max(a, b)).getAsDouble(); return aggregateSum; }
public int bigNumbersSum() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int numbersSum = Arrays.stream(numbers).filter(n -> n >= 5).sum(); return numbersSum; }
public Map<Boolean, List<String>> stringGroupByLengthDictOrderbyLengthCustom() { String[] words = {"aPPLE", "AbAcUs", "bRaNcH", "BlUeBeRrY", "ClOvEr", "cHeRry"}; Map<Boolean, List<String>> wordsGroups = Arrays.stream(words).collect(groupingBy(w -> w.length() > 8)) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().sorted( Comparator.comparing(w -> w.length(), new CustomNumberComparer())).toList())); return wordsGroups; }
public double bigDoubleNumbersMax() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; double maxNum = Arrays.stream(numbers).filter(n -> n >= 5).max().getAsDouble(); return maxNum; }
public Map<Boolean, Integer> countExpensiveProductByInStockDict() { List<Product> products = getProductList(); Map<Boolean, Integer> inStockCounts = products.stream().collect(groupingBy(p -> p.getUnitsInStock() == 0)) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> (int) g.getValue().stream().filter(p -> p.getUnitPrice() > 100).count())); return inStockCounts; }
public List<Integer> repeatedInts() { List<Integer> numbers = Collections.nCopies(50, 0); return numbers; }
public Map<String, Map<String, Map<String, Customer>>> customerNestedGroupByRegionAndCountryAndNamePrint() { List<Customer> customers = getCustomerList(); Map<String, Map<String, Map<String, Customer>>> customerGroups = customers.stream().collect(groupingBy(p -> p.getRegion())) .entrySet().stream().collect(toMap( g -> g.getKey(), g -> g.getValue().stream().collect(groupingBy(c -> c.getCountry())) .entrySet().stream().collect(toMap( g1 -> g1.getKey(), g1 -> g1.getValue().stream().collect(toMap( c -> c.getCompanyName(), c -> c)))))); for (var e1 : customerGroups.entrySet()) { System.out.println(e1.getKey() + ":"); for (var e2 : e1.getValue().entrySet()) { System.out.println("\t" + e2.getKey() + ":"); for (var e3 : e2.getValue().entrySet()) System.out.println("\t\t" + e3.getKey() + ":" + e3.getValue()); } } return customerGroups; }
public List<Pair<String, LocalDate>> waCustomerOrdersNestedSkipWhile() { List<Customer> customers = getCustomerList(); List<Pair<String, LocalDate>> after3WAOrders = customers.stream().filter(c -> c.getRegion().equals("WA")) .flatMap(c -> c.getOrders().stream().map(o -> Pair.with(c.getCustomerId(), o.getOrderDate()))) .dropWhile(t -> t.getValue1().isAfter(LocalDate.of(2000, 1, 1))).toList(); return after3WAOrders; }
public double bigDoubleNumbersElementAt() { double[] numbers = { 3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0 }; double numAt = Arrays.stream(numbers).filter(d -> d>5).skip(1).findFirst().getAsDouble(); return numAt; }
public Map<String, Integer> productEachCategoryStockDict() { List<Product> products = getProductList(); Map<String, Integer> categories = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().mapToInt(p -> p.getUnitsInStock()).min().getAsInt())); return categories; }
public void bigDoubleNumbersEager() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; AtomicReference<Double> d = new AtomicReference<>(0.0); var q = Arrays.stream(numbers).filter(n->n>5).map(n -> d.accumulateAndGet(n, Double::sum)).boxed().toList(); for (var v : q) System.out.println(v + " " + d); }
public Map<String, List<Product>> productGroupByCategoryDictOrderbyDescendingName() { List<Product> products = getProductList(); Map<String, List<Product>> productsGroups = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream(). sorted(Comparator.comparing(p -> p.getProductName(),Comparator.reverseOrder())).toList())); return productsGroups; }
public Map<String, Double> customerExpensiveOrdersTotalMaxDict() { List<Customer> customers = getCustomerList(); Map<String, Double> ordersTotalMax = customers.stream().collect(toMap(c -> c.getCustomerId(), c -> c.getOrders().stream().filter(o -> o.getTotal() > 100) .mapToDouble(o -> o.getTotal()).max().getAsDouble())); return ordersTotalMax; }
public List<String> shortStringReverse() { String[] words = { "cherry", "apple", "blueberry", "pear", "peach", "melon" }; List<String> sortedWords = Arrays.stream(words).filter(w -> w.length() < 6).collect( collectingAndThen(toList(),l->{Collections.reverse(l);return l;})); return sortedWords; }
public int customerInRegionCount(String region) { List<Customer> customers = getCustomerList(); int count = (int) customers.stream().filter(c -> c.getRegion().equals(region)).count(); return count; }
public List<Character> unionOfNameFirstChar() { List<Product> products = getProductList(); List<Customer> customers = getCustomerList(); var productFirstChars = products.stream().map(p -> p.getProductName().charAt(0)); var customerFirstChars = customers.stream().map(c -> c.getCompanyName().charAt(0)); List<Character> uniqueFirstChars = Stream.concat(productFirstChars, customerFirstChars).distinct().toList(); return uniqueFirstChars; }
public List<Pair<String, Product>> productCrossGroupJoinCategories() { String[] categories = {"Beverages", "Condiments", "Vegetables", "Dairy Products", "Seafood"}; List<Product> products = getProductList(); List<Pair<String, Product>> q = Arrays.stream(categories).map( c -> Pair.with(c, products.stream().filter(p -> p.getCategory().equals(c)) .collect(Collectors.toList()))).flatMap(t -> t.getValue1().stream() .map(p1 -> Pair.with(t.getValue0(), p1))).toList(); return q; }
public List<Pair<String, LocalDate>> waCustomerOrdersNestedTakeWhile() { List<Customer> customers = getCustomerList(); List<Pair<String, LocalDate>> after3WAOrders = customers.stream().filter(c -> c.getRegion().equals("WA")) .flatMap(c -> c.getOrders().stream().map(o -> Pair.with(c.getCustomerId(), o.getOrderDate()))) .takeWhile(t -> t.getValue1().isAfter(LocalDate.of(2000, 1, 1))).toList(); return after3WAOrders; }
public List<String> stringSkipWhile() { String[] words = {"cherry", "apple", "blueberry", "banana", "abacus"}; List<String> afterNNumbers = Arrays.stream(words).dropWhile(w -> w.charAt(0) > 'b').toList(); return afterNNumbers; }
public Map<String, Integer> customerEachCountryOrdersMinDict() { List<Customer> customers = getCustomerList(); Map<String, Integer> ordersMin = customers.stream().collect(groupingBy(c -> c.getCountry())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().mapToInt(c -> c.getOrders().size()).min().getAsInt())); return ordersMin; }
public double stringAverageLength() { String[] words = {"cherry", "apple", "blueberry"}; double averageLength = Arrays.stream(words).mapToInt(w -> w.length()).average().getAsDouble(); return averageLength; }
public List<Pair<String, Integer>> productEachCategoryStock() { List<Product> products = getProductList(); List<Pair<String, Integer>> categories = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().mapToInt(p -> p.getUnitsInStock()).max().getAsInt())).toList(); return categories; }
public Map<Integer, List<Customer>> customerGroupJoinRegionsWithCode() { List<Pair<String, Integer>> regions = Arrays.asList( Pair.with("BC", 101), Pair.with("BC", 105), Pair.with("OR", 121), Pair.with("LA", 143) ); List<Customer> customers = getCustomerList(); Map<Integer, List<Customer>> q = regions.stream().map(r -> Pair.with(r.getValue1(), customers.stream() .filter(c -> c.getRegion().equals(r.getValue0())).toList())).collect(toMap(t->t.getValue0(),t->t.getValue1())); return q; }
public List<Pair<Boolean, List<Integer>>> productGroupByInStockWithId() { List<Product> products = getProductList(); List<Pair<Boolean, List<Integer>>> productGroup = products.stream().collect(groupingBy(p -> p.getUnitsInStock() > 0)) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().map(p -> p.getProductId()).toList())).toList(); return productGroup; }
public int productLongNameLengthSum() { List<Product> products = getProductList(); int totalSum = products.stream().map(p -> p.getProductName()) .filter(name -> name.length() > 7).mapToInt(name -> name.length()).sum(); return totalSum; }
public void bigNumbersEager() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; AtomicInteger i = new AtomicInteger(0); var q = Arrays.stream(numbers).filter(n->n>5).map(n -> i.addAndGet(n)).boxed().toList(); for (var v : q) System.out.println(v + " " + i); }
public List<Pair<Character, List<String>>> stringGroupByFirstCharOrderbyDescendingCustom() { String[] words = {"aPPLE", "AbAcUs", "bRaNcH", "BlUeBeRrY", "ClOvEr", "cHeRry"}; List<Pair<Character, List<String>>> wordsGroups = Arrays.stream(words).collect(groupingBy(w -> Character.toLowerCase(w.charAt(0)))) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().sorted(new CaseInsensitiveComparer().reversed()).toList())).toList(); return wordsGroups; }
public List<String> stringOrderbyLengthThenbyDescendingCustom() { String[] words = {"aPPLE", "AbAcUs", "bRaNcH", "BlUeBeRrY", "ClOvEr", "cHeRry"}; List<String> sortedWords =Arrays.stream(words).sorted(Comparator.comparing((String w) -> w.length()) .thenComparing(new CaseInsensitiveComparer().reversed())).toList(); return sortedWords; }
public List<String> outOfStockProductName() { List<Product> products = getProductList(); List<String> productNames = products.stream().filter(p -> p.getUnitsInStock() == 0).map(p -> p.getProductName()).toList(); return productNames; }
public int stringSumLength() { String[] words = {"cherry", "apple", "blueberry"}; int totalChars = Arrays.stream(words).mapToInt(w -> w.length()).sum(); return totalChars; }
public boolean expensiveProductAnyMatch() { List<Product> products = getProductList(); boolean anyMatch = products.stream().filter(p -> p.getUnitPrice() > 100).anyMatch(p -> p.getUnitsInStock() > 0); return anyMatch; }
public List<String> longStringOrginalIndexedWhere() { String[] words = {"cherry", "apple", "blueberry", "banana", "abacus"}; List<String> q = IntStream.range(0, words.length).filter(i -> words[i].length() < i * 3 && words[i].length() > 5).mapToObj(i -> words[i]).toList(); return q; }
public Map<String, List<String>> customerGroupJoinRegionsPhone() { String[] regions = {"BC", "SP", "OR", "LA"}; List<Customer> customers = getCustomerList(); Map<String, List<String>> q = Arrays.stream(regions).map(r -> Pair.with(r, customers.stream() .filter(c -> c.getRegion().equals(r)).map(c->c.getPhone()).toList())) .collect(toMap(t->t.getValue0(),t->t.getValue1())); return q; }
public List<Pair<String, Double>> customerExpensiveOrdersTotalSum() { List<Customer> customers = getCustomerList(); List<Pair<String, Double>> ordersTotalSum = customers.stream().map(c -> Pair.with(c.getCustomerId(), c.getOrders().stream().filter(o -> o.getTotal() > 100) .mapToDouble(o -> o.getTotal()).sum())).toList(); return ordersTotalSum; }
public int numbersMax() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int maxNum = Arrays.stream(numbers).max().getAsInt(); return maxNum; }
public int[] intAddIndex() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int[] numSelected = IntStream.range(0, numbers.length).map(i -> numbers[i] + i).toArray(); return numSelected; }
public boolean stringAnyMatchCount(String[] strings, char c) { boolean anyMatch = Arrays.stream(strings).anyMatch(w -> w.charAt(0) > c); return anyMatch; }
public List<Pair<String, Double>> customerEachRegionOrdersTotalMin() { List<Customer> customers = getCustomerList(); List<Pair<String, Double>> ordersTotalMin = customers.stream().collect(groupingBy(c -> c.getRegion())) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().flatMap(c -> c.getOrders().stream()).mapToDouble(o -> o.getTotal()).min().getAsDouble())).toList(); return ordersTotalMin; }
public double numbersDoubledAggregateMultiply() { double[] numbers = {1.7, 2.3, 1.9, 4.1, 2.9}; double product = Arrays.stream(numbers).map(n -> n * 2).reduce((a, b) -> a * b).getAsDouble(); return product; }
public String[] transformIndexHashToString() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; String[] strings = {"zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"}; String[] textNums = (String[]) Arrays.stream(numbers).mapToObj(n -> numbers[n * 97 % 10]).toArray(); return textNums; }
public Map<String, List<Product>> expensiveProductEachCategoryMinUnitPriceProductsDict() { List<Product> products = getProductList(); Map<String, List<Product>> categories = products.stream().filter(p -> p.getUnitPrice() > 100).collect( groupingBy(p -> p.getCategory())).entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().collect(groupingBy(p -> p.getUnitPrice())) .entrySet().stream().min(Map.Entry.comparingByKey()).get().getValue())); return categories; }
public List<Pair<Boolean, Integer>> countExpensiveProductByInStock() { List<Product> products = getProductList(); List<Pair<Boolean, Integer>> inStockCounts = products.stream().collect(groupingBy(p -> p.getUnitsInStock() == 0)) .entrySet().stream().map(g -> Pair.with(g.getKey(), (int) g.getValue().stream().filter(p -> p.getUnitPrice() > 100).count())).toList(); return inStockCounts; }
public int distinctOrdersCount(String region) { List<Customer> customers = getCustomerList(); int count = (int) customers.stream().flatMap(c -> c.getOrders().stream()).distinct().count(); return count; }
public boolean customerOrdersAnyMatch() { List<Customer> customers = getCustomerList(); boolean anyMatch = customers.stream().flatMap(c -> c.getOrders().stream()) .anyMatch(o -> o.getOrderDate().isAfter(LocalDate.of(2000, 1, 1))); return anyMatch; }
public List<Integer> intSkipWhile() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; List<Integer> after3Numbers = Arrays.stream(numbers).dropWhile(i -> i > 3).boxed().toList(); return after3Numbers; }
public List<Pair<String, String>> customerCrossGroupJoinRegionsName() { String[] regions = {"BC", "SP", "OR", "LA"}; List<Customer> customers = getCustomerList(); List<Pair<String, String>> q = Arrays.stream(regions).map( r -> Pair.with(r, customers.stream().filter(c -> c.getRegion().equals(r)) .collect(Collectors.toList()))).flatMap(t -> t.getValue1().stream() .map(c1 -> Pair.with(t.getValue0(), c1.getCompanyName()))).toList(); return q; }
public List<String> stringOrderbyReverse() { String[] words = { "cherry", "apple", "blueberry" }; List<String> sortedWords = Arrays.stream(words).sorted().collect( collectingAndThen(toList(),l->{Collections.reverse(l);return l;})); return sortedWords; }
public List<Pair<String, String>> customerRegionAndCountry() { List<Customer> customers = getCustomerList(); List<Pair<String, String>> customerProperties = customers.stream().map(c -> Pair.with(c.getRegion(), c.getCountry())).toList(); return customerProperties; }
public boolean categoryProductAllMatch() { List<Product> products = getProductList(); boolean allMatch = products.stream().filter(p -> p.getCategory() == "Beverages").allMatch(p -> p.getUnitsInStock() > 0); return allMatch; }
public List<Integer> stringLengthSkip() { String[] words = {"cherry", "apple", "blueberry", "banana", "abacus"}; List<Integer> after3Words = Arrays.stream(words).map(w -> w.length()).skip(3).toList(); return after3Words; }
public List<Pair<Boolean, List<String>>> stringGroupByLengthOrderbyDescendingLengthCustom() { String[] words = {"aPPLE", "AbAcUs", "bRaNcH", "BlUeBeRrY", "ClOvEr", "cHeRry"}; List<Pair<Boolean, List<String>>> wordsGroups = Arrays.stream(words).collect(groupingBy(w -> w.length() > 8)) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().sorted( Comparator.comparing(w -> w.length(), new CustomNumberComparer().reversed())).toList())).toList(); return wordsGroups; }
public double numbersAverage() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; double averageNum = Arrays.stream(numbers).average().getAsDouble(); return averageNum; }
public List<Order> customerOrdersSkipWhile() { List<Customer> customers = getCustomerList(); List<Order> after3Orders = customers.stream().flatMap(c -> c.getOrders().stream()) .dropWhile(o -> o.getOrderDate().isAfter(LocalDate.of(2000, 1, 1))).toList(); return after3Orders; }
public List<Pair<String, List<Customer>>> customerEachRegionOrdersMinCustomer() { List<Customer> customers = getCustomerList(); List<Pair<String, List<Customer>>> customerOrdersMin = customers.stream().collect(groupingBy(c -> c.getRegion())) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream(). collect(groupingBy(c -> c.getOrders().size())).entrySet() .stream().min(Map.Entry.comparingByKey()).get().getValue())).toList(); return customerOrdersMin; }
public List<Pair<String, List<Product>>> productEachCategoryMinUnitPriceProducts() { List<Product> products = getProductList(); List<Pair<String, List<Product>>> categories = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().collect(groupingBy(p -> p.getUnitPrice())) .entrySet().stream().min(Map.Entry.comparingByKey()).get().getValue())).toList(); return categories; }
public double expensiveProductStockAverage() { List<Product> products = getProductList(); double averageUnitPrice = products.stream().filter(p -> p.getUnitPrice() > 100) .mapToInt(p -> p.getUnitsInStock()).average().getAsDouble(); return averageUnitPrice; }
public double oddNumbersAverageTwice() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; double averageNum = Arrays.stream(numbers).filter(n -> n % 2 == 0).map(n -> n * 2).average().getAsDouble(); return averageNum; }
public List<String> productNameOrderbyDescending() { List<Product> products = getProductList(); List<String> sortedProducts = products.stream().map(p -> p.getProductName()) .sorted(Comparator.reverseOrder()).toList(); return sortedProducts; }
public int[] oddIntAddOriginalIndex() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int[] numSelected = IntStream.range(0, numbers.length).filter(i -> numbers[i] % 2 == 1).map(i -> numbers[i] + i).toArray(); return numSelected; }
public List<Integer> oddIntIndexedWhere() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int[] oddNumbers = Arrays.stream(numbers).filter(i -> i % 2 == 1).toArray(); List<Integer> q = IntStream.range(0, oddNumbers.length).filter(i -> oddNumbers[i] < i) .map(i -> oddNumbers[i]).boxed().toList(); return q; }
public List<Integer> oddIntSkip() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; List<Integer> after3Numbers = Arrays.stream(numbers).filter(i -> i % 2 == 1).skip(3).boxed().toList(); return after3Numbers; }
public List<Order> waCustomerIndexedSelectManyOrdersTake() { List<Customer> customers = getCustomerList(); List<Order> customerProperties = IntStream.range(0, customers.size()).boxed().filter(i->customers.get(i).getRegion().equals("WA")) .flatMap(i -> customers.get(i).getOrders().stream().limit(i<10?5:1)).toList(); return customerProperties; }
public List<Double> doubleFractionOrderbyDescending() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; List<Double> sortedNumbers = Arrays.stream(numbers).map(n -> n - (int) n).boxed().sorted(Comparator.reverseOrder()).toList(); return sortedNumbers; }
public void numbersEager() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; AtomicInteger i = new AtomicInteger(0); var q = Arrays.stream(numbers).map(n -> i.addAndGet(n)).boxed().toList(); for (var v : q) System.out.println(v + " " + i); }
public List<Triplet<String, Integer, Integer>> customerSelectManyCustomerNewOrderDateYearAndMonth() { List<Customer> customers = getCustomerList(); List<Triplet<String, Integer, Integer>> customerProperties = customers.stream().flatMap(c -> c.getOrders() .stream().filter(o -> o.getOrderDate().isAfter(LocalDate.of(1998, 1, 1))) .map(o -> Triplet.with(c.getCustomerId(), o.getOrderDate().getYear(), o.getOrderDate().getMonthValue()))).toList(); return customerProperties; }
public List<Product> productsConvertToDescendingListAndPrintForeach() { List<Product> products = getProductList(); List<Product> productsList = products.stream().sorted(Comparator.comparing( p -> p.getUnitPrice(), Comparator.reverseOrder())).toList(); for (Product p : productsList) System.out.println(p); return productsList; }
public List<Integer> oddIntTake() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; List<Integer> after3Numbers = Arrays.stream(numbers).filter(i -> i % 2 == 1).limit(3).boxed().toList(); return after3Numbers; }
public List<Pair<String, Order>> customerSelectManyCustomerNewOrders() { List<Customer> customers = getCustomerList(); List<Pair<String, Order>> customerProperties = customers.stream().flatMap(c -> c.getOrders() .stream().filter(o -> o.getOrderDate().isAfter(LocalDate.of(1998, 1, 1))) .map(o -> Pair.with(c.getCustomerId(), o))).toList(); return customerProperties; }
public List<Integer> stringLengthOrderbyDescending() { String[] words = {"cherry", "apple", "blueberry"}; List<Integer> sortedWords = Arrays.stream(words).map(w -> w.length()).sorted(Comparator.reverseOrder()).toList(); return sortedWords; }
public List<Pair<String, List<Customer>>> customerEachCountryOrdersFirstOrDefaultCustomer() { List<Customer> customers = getCustomerList(); List<Pair<String, List<Customer>>> customerOrdersFirstOrDefault = customers.stream().collect(groupingBy(c -> c.getRegion())) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().filter( c -> c.getOrders().size() == g.getValue().stream().findFirst().orElse(Customer.DEFAULT).getOrders().size()).toList())).toList(); return customerOrdersFirstOrDefault; }
public List<Integer> intSkipWhileIndexedCount(int[] numbers, int n) { List<Integer> afterNumbers = IntStream.range(0, numbers.length) .dropWhile(i -> n > i).map(i -> numbers[i]).boxed().toList(); return afterNumbers; }
public List<Integer> stringLengthOrderbyDescendingCustom() { String[] words = {"aPPLE", "AbAcUs", "bRaNcH", "BlUeBeRrY", "ClOvEr", "cHeRry"}; List<Integer> sortedWords = Arrays.stream(words).map(w -> w.length()).sorted(new CustomNumberComparer().reversed()).toList(); return sortedWords; }
public List<Pair<String, Double>> customerExpensiveOrdersTotalMin() { List<Customer> customers = getCustomerList(); List<Pair<String, Double>> ordersTotalMin = customers.stream().map(c -> Pair.with(c.getCustomerId(), c.getOrders().stream().filter(o -> o.getTotal() > 100) .mapToDouble(o -> o.getTotal()).min().getAsDouble())).toList(); return ordersTotalMin; }
public double productUnitPriceMax() { List<Product> products = getProductList(); double maxUnitPrice = products.stream().mapToDouble(p -> p.getUnitPrice()).max().getAsDouble(); return maxUnitPrice; }
public String[] stringZipAdd() { String[] wordsA = {"Alpha", "Beta", "Gamma"}; String[] wordsB = {"red", "green", "blue"}; int length = wordsA.length; String[] results = (String[]) IntStream.range(0, length).mapToObj(i -> wordsA[i] + wordsB[i]).toArray(); return results; }
public List<Product> productOrderbyCategoryThenbyId() { List<Product> products = getProductList(); List<Product> sortedProducts = products.stream().sorted(Comparator.comparing((Product p) -> p.getCategory()) .thenComparing(p -> p.getProductId())).toList(); return sortedProducts; }
public int newOrdersCount(String region) { List<Customer> customers = getCustomerList(); int count = (int) customers.stream().flatMap(c -> c.getOrders().stream()) .filter(o -> o.getOrderDate().isAfter(LocalDate.of(2000, 1, 1))).count(); return count; }
public int bigNumbersFirstOrDefault() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int firstNum = Arrays.stream(numbers).filter(n -> n > 5).findFirst().orElse(0); return firstNum; }
public List<Pair<String, Double>> customerExpensiveOrdersTotalAverage() { List<Customer> customers = getCustomerList(); List<Pair<String, Double>> ordersTotalAverage = customers.stream().map(c -> Pair.with(c.getCustomerId(), c.getOrders().stream().filter(o -> o.getTotal() > 100) .mapToDouble(o -> o.getTotal()).average().getAsDouble())).toList(); return ordersTotalAverage; }
public Map<String, List<Order>> customerEachRegionOrdersTotalMinCustomerDict() { List<Customer> customers = getCustomerList(); Map<String, List<Order>> customerOrdersTotalMin = customers.stream().collect(groupingBy(c -> c.getCountry())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream() .flatMap(c -> c.getOrders().stream()).collect(groupingBy(o -> o.getTotal())) .entrySet().stream().min(Map.Entry.comparingByKey()).get().getValue())); return customerOrdersTotalMin; }
public List<Pair<Character, List<String>>> stringGroupByFirstCharOrderby() { String[] words = {"blueberry", "chimpanzee", "abacus", "banana", "apple", "cheese"}; List<Pair<Character, List<String>>> wordsGroups = Arrays.stream(words).collect(groupingBy(w -> w.charAt(0))) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().sorted().toList())).toList(); return wordsGroups; }
public Map<String, Double> customerEachRegionOrdersAverageDict() { List<Customer> customers = getCustomerList(); Map<String, Double> ordersAverage = customers.stream().collect(groupingBy(c -> c.getRegion())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().mapToInt(c -> c.getOrders().size()).average().getAsDouble())); return ordersAverage; }
public Map<Boolean, List<Integer>> intGroupByBoolDict() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; Map<Boolean, List<Integer>> numberGroups = Arrays.stream(numbers).boxed().collect(groupingBy(n -> n > 4)); return numberGroups; }
public Map<String, Map<Integer, Map<Integer, List<Order>>>> customerNestedGroupByNameAndOrderYearAndMonthPrint() { List<Customer> customers = getCustomerList(); Map<String, Map<Integer, Map<Integer, List<Order>>>> customerOrderGroups = customers.stream().collect(toMap( c -> c.getCompanyName(), c -> c.getOrders().stream().collect(groupingBy(o -> o.getOrderDate().getYear())).entrySet().stream().collect(toMap( g -> g.getKey(), g -> g.getValue().stream().collect(groupingBy( o -> o.getOrderDate().getMonthValue() )))))); for (var e1 : customerOrderGroups.entrySet()) { System.out.println(e1.getKey() + ":"); for (var e2 : e1.getValue().entrySet()) { System.out.println("\t" + e2.getKey() + ":"); for (var e3 : e2.getValue().entrySet()) { System.out.println("\t\t" + e3.getKey() + ":"); e3.getValue().forEach(o -> System.out.println("\t\t\t" + o)); } } } return customerOrderGroups; }
public List<Pair<Boolean, List<Double>>> doubleGroupByBool() { double[] numbers = {5.8, 4.3, 1.5, 3.7, 9.3}; List<Pair<Boolean, List<Double>>> numberGroups = numberGroups = Arrays.stream(numbers).boxed().collect(groupingBy(n -> n > 3)) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue())).toList(); return numberGroups; }
public List<Triplet<String, Integer, Integer>> waCustomerSelectManyCustomerNewOrderDateYearAndMonth() { List<Customer> customers = getCustomerList(); List<Triplet<String, Integer, Integer>> customerProperties = customers.stream().filter(c -> c.getRegion().equals("WA")).flatMap(c -> c.getOrders() .stream().filter(o -> o.getOrderDate().isAfter(LocalDate.of(1998, 1, 1))) .map(o -> Triplet.with(c.getCustomerId(), o.getOrderDate().getYear(), o.getOrderDate().getMonthValue()))).toList(); return customerProperties; }
public List<Pair<Integer, String>> customerLeftOuterJoinRegionsWithCodeName() { List<Pair<String, Integer>> regions = Arrays.asList( Pair.with("BC", 101), Pair.with("BC", 105), Pair.with("OR", 121), Pair.with("LA", 143) ); List<Customer> customers = getCustomerList(); List<Pair<Integer, String>> q = regions.stream().map( r -> Pair.with(r.getValue1(), customers.stream().filter(c -> c.getRegion().equals(r)) .collect(Collectors.toList()))).flatMap(t -> defaultIfEmpty(t.getValue1(), null).stream() .map(p1 -> Pair.with(t.getValue0(), p1!=null?p1.getCompanyName():"No Customer"))).toList(); return q; }
public boolean waCustomerOrdersNestedAllMatch() { List<Customer> customers = getCustomerList(); boolean allMatch = customers.stream().filter(c -> c.getRegion() == "WA").flatMap(c -> c.getOrders().stream() .map(o -> Pair.with(c.getCustomerId(), o.getOrderDate()))) .allMatch(t -> t.getValue1().isAfter(LocalDate.of(2000, 1, 1))); return allMatch; }
public List<Pair<Boolean, List<Double>>> doubleGroupByBoolOrderbyDescendingFraction() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; List<Pair<Boolean, List<Double>>> numbersGroups = Arrays.stream(numbers).boxed().collect(groupingBy(n -> n > 5)) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().sorted(Comparator.comparing( n -> n - (int) n.doubleValue(), Comparator.reverseOrder())).toList())).toList(); return numbersGroups; }
public Map<String, Double> customerInRegionOrdersTotalMaxDict(String region) { List<Customer> customers = getCustomerList(); Map<String, Double> ordersTotalMax = customers.stream().filter(c -> c.getRegion().equals(region)) .collect(toMap(c -> c.getCustomerId(), c -> c.getOrders().stream().mapToDouble(o -> o.getTotal()).max().getAsDouble())); return ordersTotalMax; }
public int oddNumbersMin() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int minNum = Arrays.stream(numbers).filter(n -> n % 2 == 0).min().getAsInt(); return minNum; }
public List<String> stringOrderbyLengthCustomThenbyCustom() { String[] words = {"aPPLE", "AbAcUs", "bRaNcH", "BlUeBeRrY", "ClOvEr", "cHeRry"}; List<String> sortedWords = Arrays.stream(words).sorted(Comparator .comparing((String w) -> w.length(),new CustomNumberComparer()) .thenComparing(new CaseInsensitiveComparer())).toList(); return sortedWords; }
public Map<String,Integer> convertSelectedTupleToDictionary() { Object[] numbers = { Pair.with("Alice", "50"), Pair.with("Bob", 40), Pair.with("Cathy", 45) }; Map<String,Integer> strings = Arrays.stream(numbers).filter(o->o instanceof Pair && ((Pair)o).getValue0() instanceof String &&((Pair)o).getValue1() instanceof Integer) .map(o->(Pair<String,Integer>)o).collect(toMap(p->p.getValue0(),p->p.getValue1())); return strings; }
public List<Pair<String, LocalDate>> customerOrdersEachNestedTake() { List<Customer> customers = getCustomerList(); List<Pair<String, LocalDate>> after3EachOrders = customers.stream().flatMap(c -> c.getOrders().stream().limit(3) .map(o -> Pair.with(c.getCustomerId(), o.getOrderDate()))).toList(); return after3EachOrders; }
public List<String> concatOfCategory() { String[] categories = {"Furnitures", "Seagoods"}; List<Product> products = getProductList(); var productCategories = products.stream().map(p -> p.getCategory()); List<String> allCategories = Stream.concat(productCategories, Arrays.stream(categories)).toList(); return allCategories; }
public Map<String, List<Product>> productGroupByCategoryDictOrderbyName() { List<Product> products = getProductList(); Map<String, List<Product>> productsGroups = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream(). sorted(Comparator.comparing(p -> p.getProductName())).toList())); return productsGroups; }
public List<Integer> rangeOfSquareIntsStartFrom(int start,int count) { List<Integer> numbers = IntStream.range(start, start+count).map(n->n*n).boxed().toList(); return numbers; }
public List<Triplet<String, String, String>> customerCityAndAddressAndPostal() { List<Customer> customers = getCustomerList(); List<Triplet<String, String, String>> customerProperties = customers.stream().map(c -> Triplet.with(c.getCity(), c.getAddress(), c.getPostalCode())).toList(); return customerProperties; }
public Map<String, Map<String, List<Customer>>> customerNestedGroupByRegionAndCountry() { List<Customer> customers = getCustomerList(); Map<String, Map<String, List<Customer>>> customerGroups = customers.stream().collect(groupingBy(p -> p.getRegion())) .entrySet().stream().collect(toMap( g -> g.getKey(), g -> g.getValue().stream().collect(groupingBy( c -> c.getCountry())))); return customerGroups; }
public Map<String, List<Product>> productGroupByCategoryDict() { List<Product> products = getProductList(); Map<String, List<Product>> category = products.stream().collect(groupingBy(p -> p.getCategory())); return category; }
public List<Pair<String, Double>> customerOrdersTotalMax() { List<Customer> customers = getCustomerList(); List<Pair<String, Double>> ordersTotalMax = customers.stream().map(c -> Pair.with(c.getCustomerId(), c.getOrders().stream().mapToDouble(o -> o.getTotal()).max().getAsDouble())).toList(); return ordersTotalMax; }
public void doubleDeferred() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; AtomicReference<Double> d = new AtomicReference<>(0.0); var q = Arrays.stream(numbers).map(n -> d.accumulateAndGet(n, Double::sum)); q.forEach(v -> System.out.println(v + " " + d)); }
public Map<String, Integer> expensiveProductEachCategoryStockDict() { List<Product> products = getProductList(); Map<String, Integer> categories = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().filter( p -> p.getUnitPrice() > 100).mapToInt(p -> p.getUnitsInStock()).min().getAsInt())); return categories; }
public Map<String, Double> customerEachRegionOrdersTotalAverageDict() { List<Customer> customers = getCustomerList(); Map<String, Double> ordersTotalAverage = customers.stream().collect(groupingBy(c -> c.getRegion())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().flatMap(c -> c.getOrders().stream()).mapToDouble(o -> o.getTotal()).average().getAsDouble())); return ordersTotalAverage; }
public List<Product> inStockProductTake() { List<Product> products = getProductList(); List<Product> after3Products = products.stream().filter(p -> p.getUnitsInStock() > 100).limit(3).toList(); return after3Products; }
public List<Pair<String, Integer>> customerEachCountryOrdersMax() { List<Customer> customers = getCustomerList(); List<Pair<String, Integer>> ordersMax = customers.stream().collect(groupingBy(c -> c.getCountry())) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().mapToInt(c -> c.getOrders().size()).max().getAsInt())).toList(); return ordersMax; }
public List<Integer> repeatedIntsWithValueAndCount(int value,int count) { List<Integer> numbers = Collections.nCopies(count, value); return numbers; }
public List<Integer> intsConvertToListAndPrintForeach() { int[] ints = {2, 3, 1, 5, 4}; List<Integer> intsList = Arrays.stream(ints).boxed().sorted().toList(); for (int i : intsList) System.out.println(i); return intsList; }
public int projectedBigNumbersFirstOrDefault() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int firstNum = Arrays.stream(numbers).map(i -> (int) Math.pow(2, i)).filter(n -> n > 100).findFirst().orElse(100); return firstNum; }
public List<Integer> stringLengthOrderby() { String[] words = {"cherry", "apple", "blueberry"}; List<Integer> sortedWords = Arrays.stream(words).map(w -> w.length()).sorted().toList(); return sortedWords; }
public List<Product> productOrderbyCategoryThenbyIdCustom() { List<Product> products = getProductList(); List<Product> sortedProducts = products.stream().sorted(Comparator.comparing((Product p) -> p.getCategory()) .thenComparing(p -> p.getProductId(),new CustomNumberComparer())).toList(); return sortedProducts; }
public double bigDoubleNumbersAverage() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; double averageNum = Arrays.stream(numbers).filter(n -> n >= 5).average().getAsDouble(); return averageNum; }
public void bigNumbersTwiceEager() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; AtomicInteger i = new AtomicInteger(0); var q = Arrays.stream(numbers).filter(n->n>5).map(n->n*2).map(n -> i.addAndGet(n)).boxed().toList(); for (var v : q) System.out.println(v + " " + i); }
public List<Integer> intSquareIndexedWhere() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; List<Integer> q = IntStream.range(0, numbers.length).filter(i -> numbers[i] * numbers[i] < i) .map(i -> numbers[i] * numbers[i]).boxed().toList(); return q; }
public int numbersFirst() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int firstNum = Arrays.stream(numbers).findFirst().getAsInt(); return firstNum; }
public int stringMaxLength() { String[] words = {"cherry", "apple", "blueberry"}; int maxLength = Arrays.stream(words).mapToInt(w -> w.length()).max().getAsInt(); return maxLength; }
public List<String> concatOfName() { List<Product> products = getProductList(); List<Customer> customers = getCustomerList(); var productNames = products.stream().map(p -> p.getProductName()); var customerNames = customers.stream().map(c -> c.getCompanyName()); List<String> allNames = Stream.concat(productNames, customerNames).toList(); return allNames; }
public Map<Boolean, List<String>> stringGroupByLengthDictOrderbyLength() { String[] words = {"blueberry", "chimpanzee", "abacus", "banana", "apple", "cheese"}; Map<Boolean, List<String>> wordsGroups = Arrays.stream(words).collect(groupingBy(w -> w.length() > 8)) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().sorted(Comparator.comparing(w -> w.length())).toList())); return wordsGroups; }
public List<Pair<String, LocalDate>> customerOrdersNestedSkipWhile() { List<Customer> customers = getCustomerList(); List<Pair<String, LocalDate>> after3Orders = customers.stream().flatMap(c -> c.getOrders().stream() .map(o -> Pair.with(c.getCustomerId(), o.getOrderDate()))) .dropWhile(t -> t.getValue1().isAfter(LocalDate.of(2000, 1, 1))).toList(); return after3Orders; }
public int[] oddIntTwice() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int[] numSelected = Arrays.stream(numbers).filter(n -> n % 2 == 1).map(n -> n * 2).toArray(); return numSelected; }
public List<String> convertSelectedStringItemToList() { Object[] numbers = { null, 1.0, "two", 3, "four", 5, "six", 7.0 }; List<String> strings =  Arrays.stream(numbers).filter(o->o instanceof String).map(s->(String)s).toList(); return strings; }
public Map<String, List<Customer>> customerGroupByRegionDict() { List<Customer> customers = getCustomerList(); Map<String, List<Customer>> catagory = customers.stream().collect(groupingBy(c -> c.getRegion())); return catagory; }
public List<Product> expensiveProductTake() { List<Product> products = getProductList(); List<Product> after3Products = products.stream().filter(p -> p.getUnitPrice() > 100).limit(3).toList(); return after3Products; }
public Map<Double, List<Double>> doubleGroupByModDict() { double[] numbers = {5.8, 4.3, 1.5, 3.7, 9.3}; Map<Double, List<Double>> numberGroups = Arrays.stream(numbers).boxed().collect(groupingBy(n -> n % 1.5)); return numberGroups; }
public List<Pair<String, LocalDate>> waCustomerOrdersNestedSkip() { List<Customer> customers = getCustomerList(); List<Pair<String, LocalDate>> after3WAOrders = customers.stream().filter(c -> c.getRegion().equals("WA")) .flatMap(c -> c.getOrders().stream().map(o -> Pair.with(c.getCustomerId(), o.getOrderDate()))).skip(3).toList(); return after3WAOrders; }
public boolean stringAllMatch() { String[] words = {"cherry", "apple", "blueberry", "banana", "abacus"}; boolean allMatch = Arrays.stream(words).allMatch(n -> n.compareTo("b") > 0); return allMatch; }
public List<Double> doubleOrderbyFractionThenbyDescending() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; List<Double> sortedNumbers = Arrays.stream(numbers).boxed().sorted( Comparator.comparing((Double n) -> n - (int) n.doubleValue()) .thenComparing(Comparator.reverseOrder())).toList(); return sortedNumbers; }
public Map<Boolean, List<String>> stringGroupByLengthDictOrderbyDescendingLength() { String[] words = {"blueberry", "chimpanzee", "abacus", "banana", "apple", "cheese"}; Map<Boolean, List<String>> wordsGroups = Arrays.stream(words).collect(groupingBy(w -> w.length() > 8)) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream() .sorted(Comparator.comparing(w -> w.length(), Comparator.reverseOrder())).toList())); return wordsGroups; }
public Map<String, Double> customerEachRegionOrdersTotalMinDict() { List<Customer> customers = getCustomerList(); Map<String, Double> ordersTotalMin = customers.stream().collect(groupingBy(c -> c.getRegion())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().flatMap(c -> c.getOrders().stream()).mapToDouble(o -> o.getTotal()).min().getAsDouble())); return ordersTotalMin; }
public Map<Integer, List<Integer>> intGroupByModDict() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; Map<Integer, List<Integer>> numberGroups = Arrays.stream(numbers).boxed().collect(groupingBy(n -> n % 5)); return numberGroups; }
public List<Pair<String, List<Order>>> customerEachRegionOrdersTotalMinCustomer() { List<Customer> customers = getCustomerList(); List<Pair<String, List<Order>>> customerOrdersTotalMin = customers.stream().collect(groupingBy(c -> c.getRegion())) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream() .flatMap(c -> c.getOrders().stream()).collect(groupingBy(o -> o.getTotal())) .entrySet().stream().min(Map.Entry.comparingByKey()).get().getValue())).toList(); return customerOrdersTotalMin; }
public Map<String, List<Product>> productGroupTakeWhile() { List<Product> products = getProductList(); Map<String, List<Product>> after3Groups = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().takeWhile(g -> g.getKey().length() > 6).collect(toMap(g -> g.getKey(), g -> g.getValue())); return after3Groups; }
public List<Product> productOrderbyCategoryThenbyDescendingIdCustom() { List<Product> products = getProductList(); List<Product> sortedProducts = products.stream().sorted(Comparator.comparing((Product p) -> p.getCategory()) .thenComparing(p -> p.getProductId(),new CustomNumberComparer().reversed())).toList(); return sortedProducts; }
public List<String> stringOrderbyDescendingLengthCustom() { String[] words = {"aPPLE", "AbAcUs", "bRaNcH", "BlUeBeRrY", "ClOvEr", "cHeRry"}; List<String> sortedWords = Arrays.stream(words).sorted(Comparator.comparing(w -> w.length(), new CustomNumberComparer().reversed())).toList(); return sortedWords; }
public List<Integer> intSquareTakeWhile() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; List<Integer> after3Numbers = Arrays.stream(numbers).map(i -> i * i).takeWhile(i -> i > 3).boxed().toList(); return after3Numbers; }
public List<String> stringSkipCount(int n) { String[] words = {"cherry", "apple", "blueberry", "banana", "abacus"}; List<String> afterNWords = Arrays.stream(words).skip(3).toList(); return afterNWords; }
public List<Pair<String, LocalDate>> waCustomerOrdersNestedTake() { List<Customer> customers = getCustomerList(); List<Pair<String, LocalDate>> after3WAOrders = customers.stream().filter(c -> c.getRegion().equals("WA")) .flatMap(c -> c.getOrders().stream().map(o -> Pair.with(c.getCustomerId(), o.getOrderDate()))).limit(3).toList(); return after3WAOrders; }
public List<String> longStringTake() { String[] words = {"cherry", "apple", "blueberry", "banana", "abacus"}; List<String> after3Words = Arrays.stream(words).filter(w -> w.length() > 5).limit(3).toList(); return after3Words; }
public List<Pair<String, Integer>> customerNewOrdersCount() { List<Customer> customers = getCustomerList(); List<Pair<String, Integer>> orderCounts = customers.stream().map(c -> Pair.with(c.getCustomerId(), (int) c.getOrders().stream() .filter(o -> o.getOrderDate().isAfter(LocalDate.of(2000, 1, 1))).count())).toList(); return orderCounts; }
public double doubleAverage() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; double averageNum = Arrays.stream(numbers).average().getAsDouble(); return averageNum; }
public List<String> stringOrderbyCustom() { String[] words = {"aPPLE", "AbAcUs", "bRaNcH", "BlUeBeRrY", "ClOvEr", "cHeRry"}; List<String> sortedWords = Arrays.stream(words).sorted(new CaseInsensitiveComparer()).toList(); return sortedWords; }
public List<Double> bigDoubleOrderbyFractionDescendingThenbyDescending() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; List<Double> sortedNumbers = Arrays.stream(numbers).filter(n->n>3).boxed().sorted( Comparator.comparing((Double n) -> n - (int) n.doubleValue(),Comparator.reverseOrder()) .thenComparing(Comparator.reverseOrder())).toList(); return sortedNumbers; }
public List<Product> expensiveProductOrderbyName() { List<Product> products = getProductList(); List<Product> sortedProducts = products.stream().filter(p -> p.getUnitPrice() > 100).sorted(Comparator.comparing(p -> p.getProductName())).toList(); return sortedProducts; }
public List<Character> exceptOfNameFirstChar() { List<Product> products = getProductList(); List<Customer> customers = getCustomerList(); var productFirstChars = products.stream().map(p -> p.getProductName().charAt(0)); var customerFirstChars = customers.stream().map(c -> c.getCompanyName().charAt(0)); List<Character> differemtFirstChars = productFirstChars.distinct().filter(a -> customerFirstChars.allMatch(b -> b != a)).toList(); return differemtFirstChars; }
public List<Double> doubleReverse() { double[] numbers = { 3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0 }; List<Double> sortedNumbers = Arrays.stream(numbers).boxed().collect( collectingAndThen(toList(),l->{Collections.reverse(l);return l;})); return sortedNumbers; }
public List<Pair<String, Order>> customerIdAndFirstOrder() { List<Customer> customers = getCustomerList(); List<Pair<String, Order>> customerProperties = customers.stream().map(c -> Pair.with(c.getCustomerId(), c.getOrders().stream().findFirst().get())).toList(); return customerProperties; }
public List<Pair<String, List<Customer>>> customerEachCountryOrdersMaxCustomer() { List<Customer> customers = getCustomerList(); List<Pair<String, List<Customer>>> customerOrdersMax = customers.stream().collect(groupingBy(c -> c.getCountry())) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream(). collect(groupingBy(c -> c.getOrders().size())).entrySet() .stream().max(Map.Entry.comparingByKey()).get().getValue())).toList(); return customerOrdersMax; }
public List<Character> intersectOfNameFirstChar() { List<Product> products = getProductList(); List<Customer> customers = getCustomerList(); var productFirstChars = products.stream().map(p -> p.getProductName().charAt(0)); var customerFirstChars = customers.stream().map(c -> c.getCompanyName().charAt(0)); List<Character> sharedFirstChars = productFirstChars.distinct().filter(a -> customerFirstChars.anyMatch(b -> b == a)).toList(); return sharedFirstChars; }
public double doubleMax() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; double maxNum = Arrays.stream(numbers).max().getAsDouble(); return maxNum; }
public List<Pair<String, Integer>> customerIdAndOrdersCount() { List<Customer> customers = getCustomerList(); List<Pair<String, Integer>> customerProperties = customers.stream().map(c -> Pair.with(c.getCustomerId(), c.getOrders().size())).toList(); return customerProperties; }
public List<Order> repeatedOrders() { List<Order> orders = Collections.nCopies(10, Order.DEFAULT); return orders; }
public boolean intAnyMatch() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; boolean anyMatch = Arrays.stream(numbers).anyMatch(n -> n > 3); return anyMatch; }
public Product expensiveProductElementAt() { List<Product> products = getProductList(); Product expensiveProduct = products.stream().filter(p->p.getUnitPrice()>100) .skip(2).findFirst().get(); return expensiveProduct; }
public List<Pair<String, Integer>> countDistinctProductByCategory() { List<Product> products = getProductList(); List<Pair<String, Integer>> categoryCounts = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().map(g -> Pair.with(g.getKey(), (int) g.getValue().stream().distinct().count())).toList(); return categoryCounts; }
public List<Pair<String, Integer>> expensiveProductEachCategoryStock() { List<Product> products = getProductList(); List<Pair<String, Integer>> categories = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().filter( p -> p.getUnitPrice() > 100).mapToInt(p -> p.getUnitsInStock()).max().getAsInt())).toList(); return categories; }
public List<Integer> rangeOfIntsWithStartAndCount(int start,int count) { List<Integer> numbers = IntStream.range(start, start+count).boxed().toList(); return numbers; }
public List<String> shortStringOrderbyLengthCustom() { String[] words = {"aPPLE", "AbAcUs", "bRaNcH", "BlUeBeRrY", "ClOvEr", "cHeRry"}; List<String> sortedWords = Arrays.stream(words).filter(w -> w.length() < 6).sorted(Comparator.comparing(w -> w.length(), new CustomNumberComparer())).toList(); return sortedWords; }
public List<Double> doublesConvertToDescendingList() { double[] doubles = {1.7, 2.3, 1.9, 4.1, 2.9}; List<Double> doublesList = Arrays.stream(doubles).boxed(). sorted(Comparator.reverseOrder()).toList(); return doublesList; }
public List<Pair<Character, List<String>>> stringGroupByFirstChar() { String[] words = {"blueberry", "chimpanzee", "abacus", "banana", "apple", "cheese"}; List<Pair<Character, List<String>>> wordsGroups = Arrays.stream(words).collect(groupingBy(w -> w.charAt(0))) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue())).toList(); return wordsGroups; }
public double numbersAggregateMultiplyWithSeed() { double[] numbers = {1.7, 2.3, 1.9, 4.1, 2.9}; double seed = 1.6; double product = Arrays.stream(numbers).reduce(seed, (a, b) -> a * b); return product; }
public List<Integer> stringLengthTakeWhile() { String[] words = {"cherry", "apple", "blueberry", "banana", "abacus"}; List<Integer> after3Words = Arrays.stream(words).map(w -> w.length()).takeWhile(n -> n > 5).toList(); return after3Words; }
public String stringFirstStartWith(char c) { String[] strings = {"zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"}; String startWithChar = Arrays.stream(strings).filter(s -> s.charAt(0) == c).findFirst().get(); return startWithChar; }
public List<Pair<String, List<Order>>> customerEachRegionOrdersTotalMaxCustomer() { List<Customer> customers = getCustomerList(); List<Pair<String, List<Order>>> customerOrdersTotalMax = customers.stream().collect(groupingBy(c -> c.getRegion())) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream() .flatMap(c -> c.getOrders().stream()).collect(groupingBy(o -> o.getTotal())) .entrySet().stream().max(Map.Entry.comparingByKey()).get().getValue())).toList(); return customerOrdersTotalMax; }
public Map<String, Integer> customerEachRegionOrdersMaxDict() { List<Customer> customers = getCustomerList(); Map<String, Integer> ordersMax = customers.stream().collect(groupingBy(c -> c.getRegion())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().mapToInt(c -> c.getOrders().size()).max().getAsInt())); return ordersMax; }
public int[] stringProjectionZipAddInt() { String[] wordsA = {"Alpha", "Beta", "Gamma"}; String[] wordsB = {"red", "green", "blue"}; int length = wordsA.length; int[] results = IntStream.range(0, length).map(i -> wordsA[i].length() + wordsB[i].length()).toArray(); return results; }
public double bigDoubleNumbersMin() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; double minNum = Arrays.stream(numbers).filter(n -> n >= 5).min().getAsDouble(); return minNum; }
public void doubleEager() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; AtomicReference<Double> d = new AtomicReference<>(0.0); var q = Arrays.stream(numbers).map(n -> d.accumulateAndGet(n, Double::sum)).boxed().toList(); for (var v : q) System.out.println(v + " " + d); }
public List<Double> intSqrtSkipWhileIndexed() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; List<Double> afterNumbers =  IntStream.range(0, numbers.length) .dropWhile(i -> Math.sqrt(numbers[i]) > i).mapToDouble(i -> Math.sqrt(numbers[i]) ).boxed().toList(); return afterNumbers; }
public List<Pair<String, String>> customerCrossJoinRegionsName() { String[] regions = {"BC", "SP", "OR", "LA"}; List<Customer> customers = getCustomerList(); List<Pair<String, String>> q = Arrays.stream(regions).flatMap( r -> customers.stream().filter(c -> c.getRegion().equals(r)).map( c -> Pair.with(r, c.getCompanyName()))).toList(); return q; }
public boolean intAllMatchInput(int i) { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; boolean allMatch = Arrays.stream(numbers).allMatch(n -> n > i); return allMatch; }
public List<String> convertSelectedStringItemToListAndPrintForeach() { Object[] numbers = { null, 1.0, "two", 3, "four", 5, "six", 7.0 }; List<String> strings = Arrays.stream(numbers).filter(o->o instanceof String).map(s->(String)s).toList(); for (String s : strings) System.out.println(s); return strings; }
public List<String> expensiveProductName() { List<Product> products = getProductList(); List<String> productNames = products.stream().filter(p -> p.getUnitPrice() > 100).map(p -> p.getProductName()).toList(); return productNames; }
public List<Pair<String, Double>> customerEachRegionOrdersAverage() { List<Customer> customers = getCustomerList(); List<Pair<String, Double>> ordersAverage = customers.stream().collect(groupingBy(c -> c.getRegion())) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().mapToInt(c -> c.getOrders().size()).average().getAsDouble())).toList(); return ordersAverage; }
public List<Pair<Integer, Integer>> uniqueFactorOf300CountByOddEven() { int[] factorsOf300 = {2, 2, 3, 5, 5}; List<Pair<Integer, Integer>> uniqueFactorsCount = Arrays.stream(factorsOf300).boxed().collect( groupingBy(n -> n % 2)).entrySet().stream().map(g -> Pair.with(g.getKey(), (int) g.getValue() .stream().distinct().count())).toList(); return uniqueFactorsCount; }
public List<Product> expensiveProductOrderbyCategoryThenbyIdCustom() { List<Product> products = getProductList(); List<Product> sortedProducts = products.stream().filter(p->p.getUnitPrice()>100) .sorted(Comparator.comparing((Product p) -> p.getCategory()) .thenComparing(p -> p.getProductId(),new CustomNumberComparer().reversed())).toList(); return sortedProducts; }
public List<Order> customerOrdersSkip() { List<Customer> customers = getCustomerList(); List<Order> after3Orders = customers.stream().flatMap(c -> c.getOrders().stream()).skip(3).toList(); return after3Orders; }
public boolean intAllMatch() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; boolean allMatch = Arrays.stream(numbers).allMatch(n -> n > 3); return allMatch; }
public List<String> stringOrderbyThenbyLength() { String[] words = {"cherry", "apple", "blueberry", "banana", "abacus"}; List<String> sortedWords = Arrays.stream(words).sorted(Comparator.comparing((String w) -> w) .thenComparing(w -> w.length())).toList(); return sortedWords; }
public List<Order> customerIndexedSelectManyOrdersTake() { List<Customer> customers = getCustomerList(); List<Order> customerProperties = IntStream.range(0, customers.size()).boxed(). flatMap(i -> customers.get(i).getOrders().stream().limit(i<10?5:1)).toList(); return customerProperties; }
public int[] oddNumbersCount(int[][] numbers) { int[] oddNumbersCount = Arrays.stream(numbers) .mapToInt(a -> (int) Arrays.stream(a).filter(n -> n % 2 == 1).count()).toArray(); return oddNumbersCount; }
public int productNameWithFirstLetterCount() { List<Product> products = getProductList(); int count = (int) products.stream().map(p -> p.getProductName()).filter(c -> c.startsWith("c")).count(); return count; }
public List<String> shortStringOrderbyDescending() { String[] words = {"cherry", "apple", "blueberry", "pear", "peach", "melon"}; List<String> sortedWords = Arrays.stream(words).filter(w -> w.length() < 6).sorted(Comparator.reverseOrder()).toList(); return sortedWords; }
public List<String> stringOrderbyLengthThenby() { String[] words = {"cherry", "apple", "blueberry", "banana", "abacus"}; List<String> sortedWords = Arrays.stream(words).sorted(Comparator.comparing((String w) -> w.length()) .thenComparing(Comparator.naturalOrder())).toList(); return sortedWords; }
public double[] productsConvertToUnitPriceArray() { List<Product> products = getProductList(); double[] pricesArray = products.stream().mapToDouble(p -> p.getUnitPrice()).sorted().toArray(); return pricesArray; }
public boolean intSquareAnyMatch() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; boolean anyMatch = Arrays.stream(numbers).map(i -> i * i).anyMatch(n -> n > 3); return anyMatch; }
public Pair<Integer, Integer>[] selectManyJoin() { int[] numbersA = {0, 2, 4, 5, 6, 8, 9}; int[] numbersB = {1, 3, 5, 7, 8}; Pair<Integer, Integer>[] pairs = (Pair<Integer, Integer>[]) Arrays.stream(numbersA).boxed().flatMap( a -> Arrays.stream(numbersB).mapToObj(b -> Pair.with(a, b))).toArray(); return pairs; }
public boolean equalStringsLengths() { List<String> wordsA = Arrays.asList("Alpha", "Beta", "Gamma"); List<String> wordsB = Arrays.asList("Gamma", "Beta", "Alpha"); boolean equal = wordsA.stream().map(w -> w.length()).toList().equals(wordsB); return equal; }
public String[] stringZipAddInt() { String[] words = {"Alpha", "Beta", "Gamma"}; int[] numbers = {1, 2, 3}; int length = words.length; String[] results = (String[]) IntStream.range(0, length).mapToObj(i -> words[i] + numbers[i]).toArray(); return results; }
public List<Pair<String, Integer>> customerEachRegionOrdersSum() { List<Customer> customers = getCustomerList(); List<Pair<String, Integer>> ordersSum = customers.stream().collect(groupingBy(c -> c.getRegion())) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().mapToInt(c -> c.getOrders().size()).sum())).toList(); return ordersSum; }
public Map<String, Double> customerOrdersTotalAverageDict() { List<Customer> customers = getCustomerList(); Map<String, Double> ordersTotalAverage = customers.stream().collect(toMap(c -> c.getCustomerId(), c -> c.getOrders().stream().mapToDouble(o -> o.getTotal()).average().getAsDouble())); return ordersTotalAverage; }
public List<Pair<Boolean, List<String>>> stringGroupByLengthOrderbyLength() { String[] words = {"blueberry", "chimpanzee", "abacus", "banana", "apple", "cheese"}; List<Pair<Boolean, List<String>>> wordsGroups = Arrays.stream(words).collect(groupingBy(w -> w.length() > 8)) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().sorted(Comparator.comparing(w -> w.length())).toList())).toList(); return wordsGroups; }
public int productLongCategoryCount() { List<Product> products = getProductList(); int count = (int) products.stream().map(p -> p.getCategory()).filter(c -> c.length() > 8).count(); return count; }
public double productUnitPriceAverage() { List<Product> products = getProductList(); double averageUnitPrice = products.stream().mapToDouble(p -> p.getUnitPrice()).average().getAsDouble(); return averageUnitPrice; }
public int expensiveProductStockSum() { List<Product> products = getProductList(); int totalSum = products.stream().filter(p -> p.getUnitPrice() > 100) .mapToInt(p -> p.getUnitsInStock()).sum(); return totalSum; }
public int[] intIntersect() { int[] numbersA = {0, 2, 4, 5, 9}; int[] numbersB = {0, 2, 4, 5, 9}; int[] sharedNumbers = Arrays.stream(numbersA).distinct().filter(a -> Arrays.stream(numbersB).anyMatch(b -> b == a)).toArray(); return sharedNumbers; }
public List<String> stringSkipWhileCount(char c) { String[] words = {"cherry", "apple", "blueberry", "banana", "abacus"}; List<String> afterNWords = Arrays.stream(words).dropWhile(w -> w.charAt(0) > c).toList(); return afterNWords; }
public boolean stringAllMatchCount(String[] strings, char c) { boolean allMatch = Arrays.stream(strings).allMatch(w -> w.charAt(0) > c); return allMatch; }
public Pair<Integer, Integer>[] selectManyJoinOdd() { int[] numbersA = {0, 2, 4, 5, 6, 8, 9}; int[] numbersB = {1, 3, 5, 7, 8}; Pair<Integer, Integer>[] pairs = (Pair<Integer, Integer>[]) Arrays.stream(numbersA).boxed().flatMap(a -> Arrays.stream(numbersB) .filter(b -> b % 2 == 1).mapToObj(b -> Pair.with(a, b))).toArray(); return pairs; }
public List<Double> doubleOrderbyModDescendingThenby() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; List<Double> sortedNumbers = Arrays.stream(numbers).boxed().sorted( Comparator.comparing((Double n) -> n % 1.5,Comparator.reverseOrder()) .thenComparing(Comparator.naturalOrder())).toList(); return sortedNumbers; }
public List<Integer> intSkipCount(int n) { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; List<Integer> after3Numbers = Arrays.stream(numbers).skip(n).boxed().toList(); return after3Numbers; }
public Map<String, List<Customer>> customerGroupJoinRegions() { String[] regions = {"BC", "SP", "OR", "LA"}; List<Customer> customers = getCustomerList(); Map<String, List<Customer>> q = Arrays.stream(regions).map(r -> Pair.with(r, customers.stream() .filter(c -> c.getRegion().equals(r)).toList())).collect(toMap(t->t.getValue0(),t->t.getValue1())); return q; }
public List<Pair<String, List<Double>>> productGroupUnitPrice() { List<Product> products = getProductList(); List<Pair<String, List<Double>>> productNames = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().map(p -> p.getUnitPrice()).toList())).toList(); return productNames; }
public Map<String, List<Product>> productGroupByCategoryDictOrderbyId() { List<Product> products = getProductList(); Map<String, List<Product>> productsGroups = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream() .sorted(Comparator.comparing(p -> p.getProductId())).toList())); return productsGroups; }
public Map<String, Order> customerEachRegionFirstOrDefaultOrderDict() { List<Customer> customers = getCustomerList(); Map<String, Order> ordersFirstOrDefault = customers.stream().collect(groupingBy(c -> c.getRegion())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().flatMap(c -> c.getOrders().stream()).findFirst().orElse(Order.DEFAULT))); return ordersFirstOrDefault; }
public List<Double> bigDoubleOrderbyFraction() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; List<Double> sortedNumbers = Arrays.stream(numbers).filter(n -> n > 5).boxed().sorted(Comparator.comparing(n -> n - (int) n.doubleValue())).toList(); return sortedNumbers; }
public void bigNumbersDeferred() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; AtomicInteger i = new AtomicInteger(0); var q = Arrays.stream(numbers).filter(n->n>5).map(n -> i.addAndGet(n)); q.forEach(v -> System.out.println(v + " " + i)); }
public List<Pair<String, Double>> productEachCategoryStock() { List<Product> products = getProductList(); List<Pair<String, Double>> categories = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().mapToInt(p -> p.getUnitsInStock()).average().getAsDouble())).toList(); return categories; }
public Map<String, Integer> productEachCategoryStockDict() { List<Product> products = getProductList(); Map<String, Integer> categories = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().mapToInt(p -> p.getUnitsInStock()).max().getAsInt())); return categories; }
public List<Integer> intTakeWhileCount(int n) { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; List<Integer> after3Numbers = Arrays.stream(numbers).takeWhile(i -> i > n).boxed().toList(); return after3Numbers; }
public List<Pair<Boolean, List<String>>> stringGroupByLengthOrderbyDescendingLength() { String[] words = {"blueberry", "chimpanzee", "abacus", "banana", "apple", "cheese"}; List<Pair<Boolean, List<String>>> wordsGroups = Arrays.stream(words).collect(groupingBy(w -> w.length() > 8)) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream() .sorted(Comparator.comparing(w -> w.length(), Comparator.reverseOrder())).toList())).toList(); return wordsGroups; }
public List<Pair<String, List<Product>>> productGroupByCategoryOrderbyName() { List<Product> products = getProductList(); List<Pair<String, List<Product>>> productsGroups = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream() .sorted(Comparator.comparing(p -> p.getProductName())).toList())).toList(); return productsGroups; }
public List<Pair<String, List<Customer>>> customerEachRegionOrdersMaxCustomer() { List<Customer> customers = getCustomerList(); List<Pair<String, List<Customer>>> customerOrdersMax = customers.stream().collect(groupingBy(c -> c.getRegion())) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream(). collect(groupingBy(c -> c.getOrders().size())).entrySet() .stream().max(Map.Entry.comparingByKey()).get().getValue())).toList(); return customerOrdersMax; }
public List<Product> productOrderbyCategoryThenbyNameCustom() { List<Product> products = getProductList(); List<Product> sortedProducts = products.stream().sorted(Comparator.comparing((Product p) -> p.getCategory()) .thenComparing(p -> p.getProductName(),new CaseInsensitiveComparer())).toList(); return sortedProducts; }
public List<Pair<String, Double>> customerEachRegionOrdersTotalAverage() { List<Customer> customers = getCustomerList(); List<Pair<String, Double>> ordersTotalAverage = customers.stream().collect(groupingBy(c -> c.getRegion())) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().flatMap(c -> c.getOrders().stream()).mapToDouble(o -> o.getTotal()).average().getAsDouble())).toList(); return ordersTotalAverage; }
public List<Pair<String, List<Product>>> productGroupByCategory() { List<Product> products = getProductList(); List<Pair<String, List<Product>>> category = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue())).toList(); return category; }
public List<Integer> shortStringLengthOrderbyCustom() { String[] words = {"aPPLE", "AbAcUs", "bRaNcH", "BlUeBeRrY", "ClOvEr", "cHeRry"}; List<Integer> sortedWords = Arrays.stream(words).filter(w -> w.length() < 6).map(w -> w.length()). sorted(new CustomNumberComparer()).toList(); return sortedWords; }
public List<String> shortStringOrderbyLengthReverse() { String[] words = { "cherry", "apple", "blueberry", "pear", "peach", "melon" }; List<String> sortedWords = Arrays.stream(words).filter(w -> w.length() < 6) .sorted(Comparator.comparing(w->w.length())).collect( collectingAndThen(toList(),l->{Collections.reverse(l);return l;})); return sortedWords; }
public double productLongNameLengthAverage() { List<Product> products = getProductList(); double averageUnitPrice = products.stream().map(p -> p.getProductName()) .filter(name -> name.length() > 7).mapToInt(name -> name.length()).average().getAsDouble(); return averageUnitPrice; }
public List<Double> doubleOrderbyReverse() { double[] numbers = { 3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0 }; List<Double> sortedNumbers = Arrays.stream(numbers).sorted().boxed().collect( collectingAndThen(toList(),l->{Collections.reverse(l);return l;})); return sortedNumbers; }
public List<Pair<Boolean, List<Product>>> productGroupByPrice() { List<Product> products = getProductList(); List<Pair<Boolean, List<Product>>> productGroup = products.stream().collect(groupingBy(p -> p.getUnitPrice() > 100)) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue())).toList(); return productGroup; }
public int distinctProductLongCategoryCount() { List<Product> products = getProductList(); int count = (int) products.stream().map(p -> p.getCategory()).distinct().filter(c -> c.length() > 8).count(); return count; }
public List<Integer> rangeOfSquareIntsStartFrom() { List<Integer> numbers = IntStream.range(100, 120).map(n->n*n).boxed().toList(); return numbers; }
public List<Boolean> waCustomerOrdersEachNestedAnyMatch() { List<Customer> customers = getCustomerList(); List<Boolean> anyMatch = customers.stream().filter(c -> c.getRegion() == "WA").map(c -> c.getOrders().stream().anyMatch(o -> o.getOrderDate().isAfter(LocalDate.of(2000, 1, 1)))).toList(); return anyMatch; }
public Map<String, Integer> countRegionExpensiveOrdersDict() { List<Customer> customers = getCustomerList(); Map<String, Integer> regionCounts = customers.stream().collect(groupingBy(c -> c.getRegion())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> (int) g.getValue().stream(). flatMap(c -> c.getOrders().stream()).filter(o -> o.getTotal() > 100).count())); return regionCounts; }
public int expensiveProductCount() { List<Product> products = getProductList(); int count = (int) products.stream().filter(p -> p.getUnitPrice() > 100).count(); return count; }
public int expensiveProductStockMax() { List<Product> products = getProductList(); int maxUnitPrice = products.stream().filter(p -> p.getUnitPrice() > 100) .mapToInt(p -> p.getUnitsInStock()).max().getAsInt(); return maxUnitPrice; }
public List<String> shortStringOrderbyDescendingLengthCustom() { String[] words = {"aPPLE", "AbAcUs", "bRaNcH", "BlUeBeRrY", "ClOvEr", "cHeRry"}; List<String> sortedWords = Arrays.stream(words).filter(w -> w.length() < 6).sorted(Comparator.comparing(w -> w.length(), new CustomNumberComparer().reversed())).toList(); return sortedWords; }
public List<Pair<String, List<Product>>> productGroupByCategoryOrderbyDescendingId() { List<Product> products = getProductList(); List<Pair<String, List<Product>>> productsGroups = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream() .sorted(Comparator.comparing(p -> p.getProductId(),Comparator.reverseOrder())).toList())).toList(); return productsGroups; }
public Map<Boolean, List<Double>> doubleGroupByBoolDict() { double[] numbers = {5.8, 4.3, 1.5, 3.7, 9.3}; Map<Boolean, List<Double>> numberGroups = Arrays.stream(numbers).boxed().collect(groupingBy(n -> n > 3)); return numberGroups; }
public List<Pair<String, String>> customerLeftOuterJoinRegionsPhone() { String[] regions = {"BC", "SP", "OR", "LA"}; List<Customer> customers = getCustomerList(); List<Pair<String, String>> q = Arrays.stream(regions).map( r -> Pair.with(r, customers.stream().filter(c -> c.getRegion().equals(r)) .collect(Collectors.toList()))).flatMap(t -> defaultIfEmpty(t.getValue1(), null).stream() .map(p1 -> Pair.with(t.getValue0(), p1!=null?p1.getPhone():"No phone"))).toList(); return q; }
public void shortStringLengthDeferred() { String[] words = {"cherry", "apple", "blueberry"}; AtomicInteger i = new AtomicInteger(0); var q = Arrays.stream(words).filter(w->w.length()<7).map(w -> w.length()).map(n -> i.addAndGet(n)); q.forEach(v -> System.out.println(v + " " + i)); }
public List<String> unionOfRegion() { String[] regions = {"WA", "AF", "RO"}; List<Customer> customers = getCustomerList(); var customerRegions = customers.stream().map(c -> c.getRegion()); List<String> uniqueRegions = Stream.concat(customerRegions, Arrays.stream(regions)).distinct().toList(); return uniqueRegions; }
public int[] intConcat() { int[] numbersA = {0, 2, 4, 5, 9}; int[] numbersB = {0, 2, 4, 5, 9}; int[] allNumbers = IntStream.concat(Arrays.stream(numbersA), Arrays.stream(numbersB)).toArray(); return allNumbers; }
public List<Pair<String, Integer>> expensiveProductEachCategoryStock() { List<Product> products = getProductList(); List<Pair<String, Integer>> categories = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().filter( p -> p.getUnitPrice() > 100).mapToInt(p -> p.getUnitsInStock()).sum())).toList(); return categories; }
public Map<String, Double> productEachCategoryStockDict() { List<Product> products = getProductList(); Map<String, Double> categories = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().mapToInt(p -> p.getUnitsInStock()).average().getAsDouble())); return categories; }
public List<Pair<Integer, List<Integer>>> intGroupByMod() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; List<Pair<Integer, List<Integer>>> numberGroups = Arrays.stream(numbers).boxed().collect(groupingBy(n -> n % 5)) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue())).toList(); return numberGroups; }
public Map<String, Double> customerInRegionOrdersTotalMinDict(String region) { List<Customer> customers = getCustomerList(); Map<String, Double> ordersTotalMin = customers.stream().filter(c -> c.getRegion().equals(region)) .collect(toMap(c -> c.getCustomerId(), c -> c.getOrders().stream().mapToDouble(o -> o.getTotal()).min().getAsDouble())); return ordersTotalMin; }
public double productUnitPriceAggregateAverage() { List<Product> products = getProductList(); double aggregateSum = products.stream().map(p -> p.getUnitPrice()).reduce((a, b) ->(a + b) / 2).get(); return aggregateSum; }
public List<String> exceptOfRegion() { String[] regions = {"WA", "AF", "RO"}; List<Customer> customers = getCustomerList(); var customerRegions = customers.stream().map(c -> c.getRegion()); List<String> differemtRegions = customerRegions.distinct().filter(a -> Arrays.stream(regions).allMatch(b -> !b.equals(a))).toList(); return differemtRegions; }
public List<String> exceptOfName() { List<Product> products = getProductList(); List<Customer> customers = getCustomerList(); var productNames = products.stream().map(p -> p.getProductName()); var customerNames = customers.stream().map(c -> c.getCompanyName()); List<String> differemtNames = productNames.distinct().filter(a -> customerNames.allMatch(b -> !b.equals(a))).toList(); return differemtNames; }
public List<String> stringTakeWhileCount(char c) { String[] words = {"cherry", "apple", "blueberry", "banana", "abacus"}; List<String> afterNWords = Arrays.stream(words).takeWhile(w -> w.charAt(0) > c).toList(); return afterNWords; }
public double[] projectionDoubleUnion() { double[] numbersA = {0.1, 2.2, 4.3, 5.4, 6.5, 8.6, 9.7}; double[] numbersB = {0.1, 3.3, 5.4, 7.7, 8.6}; var first = Arrays.stream(numbersA).map(n -> n - (int) n); var second = Arrays.stream(numbersB).map(n -> n - (int) n); double[] uniqueNumbers = DoubleStream.concat(first, second).distinct().toArray(); return uniqueNumbers; }
public Map<Double, Double> convertArrayToDictionaryAndPrint() { double[] doubles = {1.7, 2.3, 1.9, 4.1, 2.9}; Map<Double, Double> doublesDict = Arrays.stream(doubles).boxed().collect(toMap( sr -> sr, sr -> sr*2)); for(var pair : doublesDict.entrySet()) System.out.println(pair.getKey() + " " + pair.getValue()); return doublesDict; }
public List<String> stringSkip() { String[] words = {"cherry", "apple", "blueberry", "banana", "abacus"}; List<String> afterNNumbers = Arrays.stream(words).skip(3).toList(); return afterNNumbers; }
public double numbersAggregateSqrt() { double[] numbers = {1.7, 2.3, 1.9, 4.1, 2.9}; double aggregateSum = Arrays.stream(numbers).filter(n -> n > 2).reduce((a, b) -> Math.sqrt(a * b)).getAsDouble(); return aggregateSum; }
public int productLongNameLengthMin() { List<Product> products = getProductList(); int minUnitPrice = products.stream().map(p -> p.getProductName()) .filter(name -> name.length() > 7).mapToInt(name -> name.length()).min().getAsInt(); return minUnitPrice; }
public void oddNumbersDeferred() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; AtomicInteger i = new AtomicInteger(0); var q = Arrays.stream(numbers).filter(n->n%2==1).map(n -> i.addAndGet(n)); q.forEach(v -> System.out.println(v + " " + i)); }
public List<String> stringOrderbyLengthCustomThenbyDescendingCustom() { String[] words = {"aPPLE", "AbAcUs", "bRaNcH", "BlUeBeRrY", "ClOvEr", "cHeRry"}; List<String> sortedWords = Arrays.stream(words) .sorted(Comparator.comparing((String w) -> w.length(),new CustomNumberComparer()) .thenComparing(new CaseInsensitiveComparer().reversed())).toList(); return sortedWords; }
public int intAddMultiply() { int[] numbersA = {0, 2, 4, 5, 6, 8, 9}; int[] numbersB = {1, 3, 5, 7, 8, 10, 11}; int length = numbersA.length; int product = IntStream.range(0, length).map(i -> numbersA[i] + numbersB[i]) .reduce((a, b) -> a * b).getAsInt(); return product; }
public double oddNumbersAverage() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; double averageNum = Arrays.stream(numbers).filter(n -> n % 2 == 0).average().getAsDouble(); return averageNum; }
public List<Integer> oddIntSkipWhile() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; List<Integer> after3Numbers = Arrays.stream(numbers).filter(i -> i % 2 == 1).dropWhile(i -> i > 3).boxed().toList(); return after3Numbers; }
public List<Pair<String, Double>> productLeftOuterJoinCategoriesUnitPrice() { String[] categories = {"Beverages", "Condiments", "Vegetables", "Dairy Products", "Seafood"}; List<Product> products = getProductList(); List<Pair<String, Double>> q = Arrays.stream(categories).map( c -> Pair.with(c, products.stream().filter(p -> p.getCategory().equals(c)) .collect(Collectors.toList()))).flatMap(t -> defaultIfEmpty(t.getValue1(), null).stream() .map(p1 -> Pair.with(t.getValue0(), p1!=null?p1.getUnitPrice():0))).toList(); return q; }
public List<String> stringOrderbyCustomThenbyLength() { String[] words = {"aPPLE", "AbAcUs", "bRaNcH", "BlUeBeRrY", "ClOvEr", "cHeRry"}; List<String> sortedWords =Arrays.stream(words) .sorted(Comparator.comparing((String w) -> w,new CaseInsensitiveComparer()) .thenComparing(w -> w.length())).toList(); return sortedWords; }
public List<Product> productOrderbyCategoryThenbyDescendingNameCustom() { List<Product> products = getProductList(); List<Product> sortedProducts = products.stream().sorted(Comparator.comparing((Product p) -> p.getCategory()) .thenComparing(p -> p.getProductName(),new CaseInsensitiveComparer().reversed())).toList(); return sortedProducts; }
public List<Triplet<String, String, String>> customerRegionAndCountryAndCity() { List<Customer> customers = getCustomerList(); List<Triplet<String, String, String>> customerProperties = customers.stream().map(c -> Triplet.with(c.getRegion(), c.getCountry(), c.getCity())).toList(); return customerProperties; }
public Character[] projectionStringIntersect() { String[] wordsA = {"Alice", "Bob", "Foo", "Bar"}; String[] wordsB = {"Cafe", "Bar", "Restaurant"}; var first = Arrays.stream(wordsA).map(n -> n.charAt(0)); var second = Arrays.stream(wordsB).map(n -> n.charAt(0)); Character[] sharedWords = (Character[]) first.distinct().filter(a -> second.anyMatch(b -> b == a)).toArray(); return sharedWords; }
public int[] indexedSelectManyBig() { int[] numbersA = {0, 2, 4, 5, 6, 8, 9}; int[] numbersB = {1, 3, 5, 7, 8}; int[] pairs = IntStream.range(0, numbersA.length).flatMap(i -> Arrays.stream(numbersB).filter( b ->b<numbersA[i]+i)).toArray(); return pairs; }
public Map<Boolean, List<String>> stringGroupByLengthDictOrderbyDescendingLengthCustom() { String[] words = {"aPPLE", "AbAcUs", "bRaNcH", "BlUeBeRrY", "ClOvEr", "cHeRry"}; Map<Boolean, List<String>> wordsGroups = Arrays.stream(words).collect(groupingBy(w -> w.length() > 8)) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().sorted( Comparator.comparing(w -> w.length(), new CustomNumberComparer().reversed())).toList())); return wordsGroups; }
public Map<Integer, Integer> uniqueFactorOf300CountByOddEvenDict() { int[] factorsOf300 = {2, 2, 3, 5, 5}; Map<Integer, Integer> uniqueFactorsCount = Arrays.stream(factorsOf300).boxed().collect( groupingBy(n -> n % 2)).entrySet().stream().collect(toMap(g -> g.getKey(), g -> (int) g.getValue().stream().distinct().count())); return uniqueFactorsCount; }
public List<Double> doubleOrderbyFractionReverse() { double[] numbers = { 3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0 }; List<Double> sortedNumbers = Arrays.stream(numbers).boxed().sorted(Comparator.comparing(n -> n-(int)n.doubleValue())) .collect(collectingAndThen(toList(),l->{Collections.reverse(l);return l;})); return sortedNumbers; }
public List<Triplet<String, Integer, Double>> waCustomerSelectManyCustomerNewOrderIdAndTotals() { List<Customer> customers = getCustomerList(); List<Triplet<String, Integer, Double>> customerProperties = customers.stream().filter(c -> c.getRegion().equals("WA")).flatMap(c -> c.getOrders() .stream().filter(o -> o.getOrderDate().isAfter(LocalDate.of(1998, 1, 1))) .map(o -> Triplet.with(c.getCustomerId(), o.getOrderId(), o.getTotal()))).toList(); return customerProperties; }
public List<Product> productTake() { List<Product> products = getProductList(); List<Product> after3Products = products.stream().limit(3).toList(); return after3Products; }
public Map<String, Double> productsConvertFieldsToDictionary() { List<Product> products = getProductList(); Map<String, Double> productsUnitPrice = products.stream().collect(toMap( p ->p.getProductName(), p ->p.getUnitPrice())); return productsUnitPrice; }
public void numbersDeferred() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; AtomicInteger i = new AtomicInteger(0); var q = Arrays.stream(numbers).map(n -> i.addAndGet(n)); q.forEach(v -> System.out.println(v + " " + i)); }
public void numbersTwiceDeferred() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; AtomicInteger i = new AtomicInteger(0); var q = Arrays.stream(numbers).map(n->n*2).map(n -> i.addAndGet(n)); q.forEach(v -> System.out.println(v + " " + i)); }
public List<Integer> oddIntTakeWhile() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; List<Integer> after3Numbers = Arrays.stream(numbers).filter(i -> i % 2 == 1).takeWhile(i -> i > 3).boxed().toList(); return after3Numbers; }
public int[] projectionIntExcept() { int[] numbersA = {0, 2, 4, 5, 6, 8, 9}; int[] numbersB = {1, 3, 5, 7, 8}; var first = Arrays.stream(numbersA).map(n -> n + 1); var second = Arrays.stream(numbersB).map(n -> n - 1); int[] differemtNumbers = first.distinct().filter(a -> second.allMatch(b -> b != a)).toArray(); return differemtNumbers; }
public List<Double> doubleOrderbyModDescendingThenbyDescending() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; List<Double> sortedNumbers = Arrays.stream(numbers).boxed().sorted( Comparator.comparing((Double n) -> n % 1.5,Comparator.reverseOrder()) .thenComparing(Comparator.reverseOrder())).toList(); return sortedNumbers; }
public List<Product> productsConvertToDescendingListAndPrint() { List<Product> products = getProductList(); List<Product> productsList = products.stream().sorted(Comparator.comparing( p -> p.getUnitPrice(), Comparator.reverseOrder())).toList(); for (int i = 0; i < productsList.size(); i++) System.out.println(productsList.get(i)); return productsList; }
public int bigNumbersFirst() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int firstNum = Arrays.stream(numbers).filter(n -> n > 5).findFirst().getAsInt(); return firstNum; }
public List<Integer> rangeOfInts() { List<Integer> numbers = IntStream.range(0, 50).boxed().toList(); return numbers; }
public List<Pair<Boolean, List<String>>> stringGroupByLength() { String[] words = {"blueberry", "chimpanzee", "abacus", "banana", "apple", "cheese"}; List<Pair<Boolean, List<String>>> wordsGroups = Arrays.stream(words).collect(groupingBy(w -> w.length() > 8)) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue())).toList(); return wordsGroups; }
public String stringFirstLong() { String[] strings = {"zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"}; String startsWithO = Arrays.stream(strings).filter(s -> s.length() > 4).findFirst().get(); return startsWithO; }
public int numbersElementAt() { int[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 }; int numAt = Arrays.stream(numbers).skip(1).findFirst().getAsInt(); return numAt; }
public int[] projectionIntIntersect() { int[] numbersA = {0, 2, 4, 5, 6, 8, 9}; int[] numbersB = {1, 3, 5, 7, 8}; var first = Arrays.stream(numbersA).map(n -> n + 1); var second = Arrays.stream(numbersB).map(n -> n - 1); int[] sharedNumbers = first.distinct().filter(a -> second.anyMatch(b -> b == a)).toArray(); return sharedNumbers; }
public List<Product> inStockProductSkip() { List<Product> products = getProductList(); List<Product> after3Products = products.stream().filter(p -> p.getUnitsInStock() > 100).skip(3).toList(); return after3Products; }
public Pair<String, String>[] selectByCase() { String[] words = {"aPPLE", "BlUeBeRrY", "cHeRry"}; Pair<String, String>[] upperLowerWords = (Pair<String, String>[]) Arrays.stream(words).map(w -> Pair.with(w.toUpperCase(), w.toLowerCase())).toArray(); return upperLowerWords; }
public Map<Boolean, List<Integer>> productGroupByPriceWithIdDict() { List<Product> products = getProductList(); Map<Boolean, List<Integer>> productGroup = products.stream().collect(groupingBy(p -> p.getUnitPrice() > 100)) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().map(p -> p.getProductId()).toList())); return productGroup; }
public List<Pair<String, LocalDate>> customerOrdersNestedTake() { List<Customer> customers = getCustomerList(); List<Pair<String, LocalDate>> after3Orders = customers.stream().flatMap(c -> c.getOrders().stream() .map(o -> Pair.with(c.getCustomerId(), o.getOrderDate()))).limit(3).toList(); return after3Orders; }
public List<Pair<String, LocalDate>> waCustomerOrdersEachNestedTake() { List<Customer> customers = getCustomerList(); List<Pair<String, LocalDate>> after3EachWAOrders = customers.stream().filter(c -> c.getRegion().equals("WA")) .flatMap(c -> c.getOrders().stream().limit(3).map(o -> Pair.with(c.getCustomerId(), o.getOrderDate()))).toList(); return after3EachWAOrders; }
public List<Integer> rangeOfIntsStartFrom() { List<Integer> numbers = IntStream.range(100, 150).boxed().toList(); return numbers; }
public List<Double> doublesConvertToListAndPrint() { double[] doubles = {1.7, 2.3, 1.9, 4.1, 2.9}; List<Double> doublesList = Arrays.stream(doubles).boxed(). sorted().toList(); for (int i = 0; i < doublesList.size(); i++) System.out.println(doublesList.get(i)); return doublesList; }
public Boolean[] oddIntWithIndex() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int[] oddNumbers = Arrays.stream(numbers).filter(n -> n % 2 == 1).toArray(); Boolean[] numSelected = (Boolean[]) IntStream.range(0, oddNumbers.length).mapToObj(i -> oddNumbers[i] == i).toArray(); return numSelected; }
public List<Integer> intSkipWhileCount(int n) { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; List<Integer> after3Numbers = Arrays.stream(numbers).dropWhile(i -> i > n).boxed().toList(); return after3Numbers; }
public List<Integer> stringLengthSkipWhile() { String[] words = {"cherry", "apple", "blueberry", "banana", "abacus"}; List<Integer> after3Words = Arrays.stream(words).map(w -> w.length()).dropWhile(n -> n > 5).toList(); return after3Words; }
public double numbersAggregateFindMinWithSeed() { double[] numbers = {1.7, 2.3, 1.9, 4.1, 2.9}; double seed = 3; double aggregateSum = Arrays.stream(numbers).filter(n -> n > 2).reduce(seed, (a, b) -> Math.min(a, b)); return aggregateSum; }
public boolean oddIntAllMatch() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; boolean allMatch = Arrays.stream(numbers).filter(i -> i % 2 == 1).allMatch(n -> n > 3); return allMatch; }
public int[] indexedSelectMany() { int[] numbersA = {0, 2, 4, 5, 6, 8, 9}; int[] numbersB = {1, 3, 5, 7, 8}; int[] pairs = IntStream.range(0, numbersA.length).flatMap(i -> Arrays.stream(numbersB).map( b -> i % 2 == 0 ? numbersA[i] : b)).toArray(); return pairs; }
public List<String> intersectOfRegion() { String[] regions = {"WA", "AF", "RO"}; List<Customer> customers = getCustomerList(); var customerRegions = customers.stream().map(c -> c.getRegion()); List<String> sharedRegions = customerRegions.distinct().filter(a -> Arrays.stream(regions).anyMatch(b -> b.equals(a))).toList(); return sharedRegions; }
public String[] selectByEvenOddConcat() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; String[] strings = {"zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"}; String[] evenOddWords = (String[]) Arrays.stream(numbers).mapToObj(n -> strings[n] + (n % 2 == 0 ? " even" : " odd")).toArray(); return evenOddWords; }
public Map<Double, Double> convertArrayToDictionaryWithDistinct() { double[] doubles = {1.7, 2.3, 1.9, 4.1, 1.7, 2.9}; Map<Double, Double> doublesDict = Arrays.stream(doubles).distinct().boxed().collect(toMap( sr -> sr, sr -> sr*2)); return doublesDict; }
public Map<Double, Double> convertArrayToDictionary() { double[] doubles = {1.7, 2.3, 1.9, 4.1, 2.9}; Map<Double, Double> doublesDict = Arrays.stream(doubles).boxed().collect(toMap( sr -> sr, sr -> sr*2)); return doublesDict; }
public List<Double> bigDoubleOrderbyFractionThenby() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; List<Double> sortedNumbers = Arrays.stream(numbers).boxed().sorted( Comparator.comparing((Double n) -> n - (int) n.doubleValue()) .thenComparing(Comparator.naturalOrder())).toList(); return sortedNumbers; }
public Map<String, Double> expensiveProductEachCategoryStockDict() { List<Product> products = getProductList(); Map<String, Double> categories = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().filter( p -> p.getUnitPrice() > 100).mapToInt(p -> p.getUnitsInStock()).average().getAsDouble())); return categories; }
public List<Integer> intTakeWhileCount(int[] numbers, int n) { List<Integer> afterNNumbers = Arrays.stream(numbers).takeWhile(i -> i > n).boxed().toList(); return afterNNumbers; }
public Character[] projectionStringUnion() { String[] wordsA = {"Alice", "Bob", "Foo", "Bar"}; String[] wordsB = {"Cafe", "Bar", "Restaurant"}; var first = Arrays.stream(wordsA).map(n -> n.charAt(0)); var second = Arrays.stream(wordsB).map(n -> n.charAt(0)); Character[] uniqueWords = (Character[]) Stream.concat(first, second).distinct().toArray(); return uniqueWords; }
public List<Pair<String, LocalDate>> waCustomerSelectManyCustomerNewOrderDates() { List<Customer> customers = getCustomerList(); List<Pair<String, LocalDate>> customerProperties = customers.stream().filter(c -> c.getRegion().equals("WA")).flatMap(c -> c.getOrders() .stream().filter(o -> o.getOrderDate().isAfter(LocalDate.of(1998, 1, 1))) .map(o -> Pair.with(c.getCustomerId(), o.getOrderDate()))).toList(); return customerProperties; }
public double[] doublesConvertToArrayAndPrint() { double[] doubles = {1.7, 2.3, 1.9, 4.1, 2.9}; double[] doublesArray = Arrays.stream(doubles).sorted().toArray(); for (int i = 0; i < doublesArray.length; i++) System.out.println(doublesArray[i]); return doublesArray; }
public List<Integer> intSquareTakeWhileIndexed() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; List<Integer> afterNumbers =  IntStream.range(0, numbers.length) .takeWhile(i -> numbers[i]*numbers[i] > i).map(i -> numbers[i]*numbers[i]).boxed().toList(); return afterNumbers; }
public String[] stringUnion() { String[] wordsA = {"Alice", "Bob", "Foo", "Bar"}; String[] wordsB = {"Cafe", "Bar", "Restaurant"}; String[] uniqueWords = (String[]) Stream.concat(Arrays.stream(wordsA), Arrays.stream(wordsB)).distinct().toArray(); return uniqueWords; }
public Pair<Integer, Integer>[] selectManyJoinBig() { int[] numbersA = {0, 2, 4, 5, 6, 8, 9}; int[] numbersB = {1, 3, 5, 7, 8}; Pair<Integer, Integer>[] pairs = (Pair<Integer, Integer>[]) Arrays.stream(numbersA).boxed().flatMap(a -> Arrays.stream(numbersB) .filter(b -> b > 5).mapToObj(b -> Pair.with(a, b))).toArray(); return pairs; }
public List<Pair<String, List<Product>>> productEachCategoryFirstUnitPriceProducts() { List<Product> products = getProductList(); List<Pair<String, List<Product>>> categories = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().filter(p -> p.getUnitPrice() == g.getValue().stream().findFirst().get().getUnitPrice()).toList())).toList(); return categories; }
public List<Double> doublesConvertToDescendingListAndPrintForeach() { double[] doubles = {1.7, 2.3, 1.9, 4.1, 2.9}; List<Double> doublesList = Arrays.stream(doubles).boxed(). sorted(Comparator.reverseOrder()).toList(); for (double d : doublesList) System.out.println(d); return doublesList; }
public boolean intAllMatchInput(int[] numbers, int i) { boolean allMatch = Arrays.stream(numbers).allMatch(n -> n > i); return allMatch; }
public Map<String, List<Product>> productGroupJoinCategories() { String[] categories = {"Beverages", "Condiments", "Vegetables", "Dairy Products", "Seafood"}; List<Product> products = getProductList(); Map<String, List<Product>> q = Arrays.stream(categories).map(c -> Pair.with(c, products.stream() .filter(p -> p.getCategory().equals(c)).toList())) .collect(toMap(t -> t.getValue0(), t -> t.getValue1())); return q; }
public int customerDistinctRegionsCount() { List<Customer> customers = getCustomerList(); int count = (int) customers.stream().map(c -> c.getRegion()).distinct().count(); return count; }
public List<Pair<String, Integer>> customerEachCountryOrdersSum() { List<Customer> customers = getCustomerList(); List<Pair<String, Integer>> ordersSum = customers.stream().collect(groupingBy(c -> c.getCountry())) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().mapToInt(c -> c.getOrders().size()).sum())).toList(); return ordersSum; }
public List<Boolean> customerOrdersEachNestedAllMatch() { List<Customer> customers = getCustomerList(); List<Boolean> allMatch = customers.stream().map(c -> c.getOrders().stream().allMatch(o -> o.getOrderDate().isAfter(LocalDate.of(2000, 1, 1)))).toList(); return allMatch; }
public Map<Integer, List<String>> customerGroupJoinRegionsWithCodeName() { List<Pair<String, Integer>> regions = Arrays.asList( Pair.with("BC", 101), Pair.with("BC", 105), Pair.with("OR", 121), Pair.with("LA", 143) ); List<Customer> customers = getCustomerList(); Map<Integer, List<String>> q = regions.stream().map(r -> Pair.with(r.getValue1(), customers.stream() .filter(c -> c.getRegion().equals(r.getValue0())).map(c->c.getCompanyName()).toList())) .collect(toMap(t->t.getValue0(),t->t.getValue1())); return q; }
public List<String> productNameOrderby() { List<Product> products = getProductList(); List<String> sortedProducts = products.stream().map(p -> p.getProductName()).sorted().toList(); return sortedProducts; }
public List<Integer> repeatedIntsWithCount(int count) { List<Integer> numbers = Collections.nCopies(count, 0); return numbers; }
public boolean customerOrdersAllMatch() { List<Customer> customers = getCustomerList(); boolean allMatch = customers.stream().flatMap(c -> c.getOrders().stream()) .allMatch(o -> o.getOrderDate().isAfter(LocalDate.of(2000, 1, 1))); return allMatch; }
public double[] convertSelectedDoubleItemToArray() { Object[] numbers = { null, 1.0, "two", 3, "four", 5, "six", 7.0 }; double[] doubles = Arrays.stream(numbers).filter(o->o instanceof Double).mapToDouble(d-> (double) d).toArray(); return doubles; }
public Map<String, List<Integer>> productGroupByCategoryWithIdDict() { List<Product> products = getProductList(); Map<String, List<Integer>> category = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().map(p -> p.getProductId()).toList())); return category; }
public List<Pair<String, String>> customerCityAndAddress() { List<Customer> customers = getCustomerList(); List<Pair<String, String>> customerProperties = customers.stream().map(c -> Pair.with(c.getCity(), c.getAddress())).toList(); return customerProperties; }
public List<Double> doubleFractionReverse() { double[] numbers = { 3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0 }; List<Double> sortedNumbers = Arrays.stream(numbers).map(n -> n-(int)n).boxed() .collect(collectingAndThen(toList(),l->{Collections.reverse(l);return l;})); return sortedNumbers; }
public List<Integer> intSkipCount(int[] numbers, int n) { List<Integer> afterNNumbers = Arrays.stream(numbers).skip(n).boxed().toList(); return afterNNumbers; }
public Map<String, Double> customerEachRegionOrdersTotalSumDict() { List<Customer> customers = getCustomerList(); Map<String, Double> ordersTotalSum = customers.stream().collect(groupingBy(c -> c.getRegion())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().flatMap(c -> c.getOrders().stream()).mapToDouble(o -> o.getTotal()).sum())); return ordersTotalSum; }
public double numbersAggregateFindMaxWithSeed() { double[] numbers = {1.7, 2.3, 1.9, 4.1, 2.9}; double seed = 5; double aggregateSum = Arrays.stream(numbers).filter(n -> n > 2).reduce(seed, (a, b) -> Math.max(a, b)); return aggregateSum; }
public List<Double> doubleFractionOrderby() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; List<Double> sortedNumbers = Arrays.stream(numbers).map(n -> n - (int) n).boxed().sorted().toList(); return sortedNumbers; }
public List<String> productName() { List<Product> products = getProductList(); List<String> productNames = products.stream().map(p -> p.getProductName()).toList(); return productNames; }
public Product productFirst() { List<Product> products = getProductList(); Product product12 = products.stream().filter(p -> p.getProductId() == 12).findFirst().get(); return product12; }
public boolean intAnyMatchInput(int[] numbers, int i) { boolean anyMatch = Arrays.stream(numbers).anyMatch(n -> n > i); return anyMatch; }
public List<Order> customerOrdersTake() { List<Customer> customers = getCustomerList(); List<Order> after3Orders = customers.stream().flatMap(c -> c.getOrders().stream()).limit(3).toList(); return after3Orders; }
public int stringMinLength() { String[] words = {"cherry", "apple", "blueberry"}; int minLength = Arrays.stream(words).mapToInt(w -> w.length()).min().getAsInt(); return minLength; }
public int oddNumbersElementAt() { int[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 }; int numAt = Arrays.stream(numbers).filter(n -> n % 2 == 1).skip(3).findFirst().getAsInt(); return numAt; }
public List<Double> productUnitPrice() { List<Product> products = getProductList(); List<Double> productNames = products.stream().map(p -> p.getUnitPrice()).toList(); return productNames; }
public int uniqueOddFactorOf300Count() { int[] factorsOf300 = {2, 2, 3, 5, 5}; int uniqueFactorsCount = (int) Arrays.stream(factorsOf300).distinct().filter(n -> (n % 2 == 1)).count(); return uniqueFactorsCount; }
public List<Integer> intTakeCount(int n) { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; List<Integer> after3Numbers = Arrays.stream(numbers).limit(n).boxed().toList(); return after3Numbers; }
public boolean unequalDoubles() { double[] numbersA = {0.5, 2.3, 4.7, 5.4, 9.8}; double[] numbersB = {6.5, 1.3, 8.7, 2.4, 4.8}; boolean equal = Arrays.equals(numbersA, numbersB); return equal; }
public List<Product> expensiveProductIndexedWhere() { List<Product> products = getProductList(); List<Product> q = IntStream.range(0, products.size()).filter(i -> products.get(i).getUnitPrice() > 100 && i % 2 == 1).mapToObj(i -> products.get(i)).toList(); return q; }
public List<Pair<String, Order>> customerEachRegionFirstOrDefaultOrder() { List<Customer> customers = getCustomerList(); List<Pair<String, Order>> ordersFirstOrDefault = customers.stream().collect(groupingBy(c -> c.getRegion())) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().flatMap(c -> c.getOrders().stream()).findFirst().orElse(Order.DEFAULT))).toList(); return ordersFirstOrDefault; }
public String stringFirstOrDefaultStartWithO() { String[] strings = {"zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"}; String startWithO = Arrays.stream(strings).filter(s -> s.charAt(0) == 'o').findFirst().orElse("none"); return startWithO; }
public List<Double> productsConvertToUnitPriceList() { List<Product> products = getProductList(); List<Double> pricesList = products.stream().map(p -> p.getUnitPrice()).sorted().toList(); return pricesList; }
public List<Pair<Pair<String, Integer>, Customer>> customerCrossGroupJoinRegionsWithCodeRegion() { List<Pair<String, Integer>> regions = Arrays.asList( Pair.with("BC", 101), Pair.with("BC", 105), Pair.with("OR", 121), Pair.with("LA", 143) ); List<Customer> customers = getCustomerList(); List<Pair<Pair<String, Integer>, Customer>> q = regions.stream().map( r -> Pair.with(r, customers.stream().filter(c -> c.getRegion().equals(r)) .collect(Collectors.toList()))).flatMap(t -> t.getValue1().stream() .map(c1 -> Pair.with(t.getValue0(), c1))).toList(); return q; }
public boolean stringLengthAllMatch() { String[] words = {"cherry", "apple", "blueberry", "banana", "abacus"}; boolean allMatch = Arrays.stream(words).map(w -> w.length()).allMatch(n -> n > 5); return allMatch; }
public List<Pair<String, List<Product>>> productGroupByCategoryOrderbyDescendingName() { List<Product> products = getProductList(); List<Pair<String, List<Product>>> productsGroups = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream() .sorted(Comparator.comparing(p -> p.getProductName(),Comparator.reverseOrder())).toList())).toList(); return productsGroups; }
public List<Pair<String, Product>> productEachCategoryFirstOrDefault() { List<Product> products = getProductList(); List<Pair<String, Product>> categories = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().findFirst().orElse(Product.DEFAULT))).toList(); return categories; }
public List<Pair<String, LocalDate>> waCustomerOrdersEachNestedSkip() { List<Customer> customers = getCustomerList(); List<Pair<String, LocalDate>> after3EachWAOrders = customers.stream().filter(c -> c.getRegion().equals("WA")) .flatMap(c -> c.getOrders().stream().skip(3).map(o -> Pair.with(c.getCustomerId(), o.getOrderDate()))).toList(); return after3EachWAOrders; }
public Map<String, List<Product>> productGroupTake() { List<Product> products = getProductList(); Map<String, List<Product>> after3Groups = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().limit(3).collect(toMap(g -> g.getKey(), g -> g.getValue())); return after3Groups; }
public Map<String, Product> productEachCategoryFirstOrDefaultDict() { List<Product> products = getProductList(); Map<String, Product> categories = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().findFirst().orElse(Product.DEFAULT))); return categories; }
public List<Double> bigDoubleOrderbyFractionThenbyDescending() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; List<Double> sortedNumbers = Arrays.stream(numbers).filter(n->n>3).boxed().sorted( Comparator.comparing((Double n) -> n - (int) n.doubleValue()) .thenComparing(Comparator.reverseOrder())).toList(); return sortedNumbers; }
public List<Triplet<String, Integer, Integer>> customerSelectManyCustomerBigOrderDateYearAndMonth() { List<Customer> customers = getCustomerList(); List<Triplet<String, Integer, Integer>> customerProperties = customers.stream().flatMap(c -> c.getOrders() .stream().filter(o -> o.getTotal() > 100).map(o -> Triplet.with(c.getCustomerId(), o.getOrderDate().getYear(), o.getOrderDate().getMonthValue()))).toList(); return customerProperties; }
public List<String> convertSelectedStringItemToListAndPrint() { Object[] numbers = { null, 1.0, "two", 3, "four", 5, "six", 7.0 }; List<String> strings =  Arrays.stream(numbers).filter(o->o instanceof String).map(s->(String)s).toList(); for (int i = 0; i < strings.size(); i++) System.out.println(strings.get(i)); return strings; }
public Map<String, Double> customerInRegionOrdersTotalAverageDict(String region) { List<Customer> customers = getCustomerList(); Map<String, Double> ordersTotalAverage = customers.stream().filter(c -> c.getRegion().equals(region)) .collect(toMap(c -> c.getCustomerId(), c -> c.getOrders().stream().mapToDouble(o -> o.getTotal()).average().getAsDouble())); return ordersTotalAverage; }
public int numbersMaxTwice() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int maxNum = Arrays.stream(numbers).map(n -> n * 2).max().getAsInt(); return maxNum; }
public Map<Boolean, List<Double>> doubleGroupByBoolDictOrderbyDescendingFraction() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; Map<Boolean, List<Double>> numbersGroups = Arrays.stream(numbers).boxed().collect(groupingBy(n -> n > 5)) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().sorted(Comparator.comparing( n -> n - (int) n.doubleValue(), Comparator.reverseOrder())).toList())); return numbersGroups; }
public Map<String, List<Product>> productEachGroupSkipWhile() { List<Product> products = getProductList(); Map<String, List<Product>> after3EachGroups = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().dropWhile(p -> p.getProductId() > 100).toList())); return after3EachGroups; }
public int productLongNameLengthMax() { List<Product> products = getProductList(); int maxUnitPrice = products.stream().map(p -> p.getProductName()) .filter(name -> name.length() > 7).mapToInt(name -> name.length()).max().getAsInt(); return maxUnitPrice; }
public String[] stringIntersect() { String[] wordsA = {"Alice", "Bob", "Foo", "Bar"}; String[] wordsB = {"Cafe", "Bar", "Restaurant"}; String[] sharedWords = (String[]) Arrays.stream(wordsA).distinct().filter(a -> Arrays.stream(wordsB).anyMatch(b -> b.equals(a))).toArray(); return sharedWords; }
public Pair<String, Integer>[] selectByStringAndLength() { String[] words = {"aPPLE", "BlUeBeRrY", "cHeRry"}; Pair<String, Integer>[] upperLowerWords = (Pair<String, Integer>[]) Arrays.stream(words).map(w -> Pair.with(w, w.length())).toArray(); return upperLowerWords; }
public List<Pair<String, Integer>> countRegionExpensiveOrders() { List<Customer> customers = getCustomerList(); List<Pair<String, Integer>> regionCounts = customers.stream().collect(groupingBy(c -> c.getRegion())) .entrySet().stream().map(g -> Pair.with(g.getKey(), (int) g.getValue(). stream().flatMap(c -> c.getOrders().stream()).filter(o -> o.getTotal() > 100).count())).toList(); return regionCounts; }
public String[] transformIndexToString() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; String[] strings = {"zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"}; String[] textNums = (String[]) Arrays.stream(numbers).mapToObj(n -> strings[n]).toArray(); return textNums; }
public int[] oddIntAddIndex() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int[] oddNumbers = Arrays.stream(numbers).filter(n -> n % 2 == 1).toArray(); int[] numSelected = IntStream.range(0, oddNumbers.length).map(i -> oddNumbers[i] + i).toArray(); return numSelected; }
public List<String> stringTakeWhile() { String[] words = {"cherry", "apple", "blueberry", "banana", "abacus"}; List<String> afterNNumbers = Arrays.stream(words).takeWhile(w -> w.charAt(0) > 'b').toList(); return afterNNumbers; }
public double numbersAverageTwice() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; double averageNum = Arrays.stream(numbers).map(n -> n * 2).average().getAsDouble(); return averageNum; }
public List<Pair<String, Integer>> customerEachRegionOrdersMax() { List<Customer> customers = getCustomerList(); List<Pair<String, Integer>> ordersMax = customers.stream().collect(groupingBy(c -> c.getRegion())) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().mapToInt(c -> c.getOrders().size()).max().getAsInt())).toList(); return ordersMax; }
public List<Boolean> customerOrdersEachNestedAnyMatch() { List<Customer> customers = getCustomerList(); List<Boolean> anyMatch = customers.stream().map(c -> c.getOrders().stream().anyMatch(o -> o.getOrderDate().isAfter(LocalDate.of(2000, 1, 1)))).toList(); return anyMatch; }
public List<Integer> intSquareTake() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; List<Integer> after3Numbers = Arrays.stream(numbers).map(i -> i * i).limit(3).boxed().toList(); return after3Numbers; }
public int[] uniqueFactorOf300And900Count() { int[][] factorsOf300And900 = { {2, 2, 3, 5, 5}, {2, 2, 3, 3, 5, 5} }; int[] uniqueFactorsCount = Arrays.stream(factorsOf300And900) .mapToInt(a -> (int) Arrays.stream(a).distinct().count()).toArray(); return uniqueFactorsCount; }
public String stringFirstStartWithO() { String[] strings = {"zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"}; String startWithO = Arrays.stream(strings).filter(s -> s.charAt(0) == 'o').findFirst().get(); return startWithO; }
public int shortStringSumLength() { String[] words = {"cherry", "apple", "blueberry"}; int totalChars = Arrays.stream(words).filter(w -> w.length() < 7).mapToInt(w -> w.length()).sum(); return totalChars; }
public List<Double> bigDoubleOrderbyDescendingFraction() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; List<Double> sortedNumbers = Arrays.stream(numbers).filter(n -> n > 5).boxed().sorted( Comparator.comparing(n -> n - (int) n.doubleValue(), Comparator.reverseOrder())).toList(); return sortedNumbers; }
public int bigNumbersMax() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int maxNum = Arrays.stream(numbers).filter(n -> n >= 5).max().getAsInt(); return maxNum; }
public double numbersAggregateMultiply() { double[] numbers = {1.7, 2.3, 1.9, 4.1, 2.9}; double product = Arrays.stream(numbers).reduce((a, b) -> a * b).getAsDouble(); return product; }
public int productOutOfStock() { List<Product> products = getProductList(); int count = (int) products.stream().filter(c -> c.getUnitsInStock() == 0).count(); return count; }
public Map<String, Map<Integer, Map<Integer, List<Order>>>> customerNestedGroupByNameAndOrderYearAndMonth() { List<Customer> customers = getCustomerList(); Map<String, Map<Integer, Map<Integer, List<Order>>>> customerOrderGroups = customers.stream().collect(toMap( c -> c.getCompanyName(), c -> c.getOrders().stream().collect(groupingBy(o -> o.getOrderDate().getYear())).entrySet().stream().collect(toMap( g -> g.getKey(), g -> g.getValue().stream().collect(groupingBy( o -> o.getOrderDate().getMonthValue() )))))); return customerOrderGroups; }
public boolean equalStrings() { List<String> wordsA = Arrays.asList("Alpha", "Beta", "Gamma"); List<String> wordsB = Arrays.asList("Alpha", "Beta", "Gamma"); boolean equal = wordsA.equals(wordsB); return equal; }
public double inputNumbersAggregateWithSeed(double[] numbers, double seed) { double product = Arrays.stream(numbers).reduce(seed, (a, b) -> a * b); return product; }
public List<Pair<String, Integer>> productEachCategoryStock() { List<Product> products = getProductList(); List<Pair<String, Integer>> categories = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().mapToInt(p -> p.getUnitsInStock()).min().getAsInt())).toList(); return categories; }
public List<Integer> rangeOfEvenInts() { List<Integer> numbers = IntStream.range(0, 50).filter(n->n%2==0).boxed().toList(); return numbers; }
public Map<String, Boolean> productEachGroupAnyMatch() { List<Product> products = getProductList(); Map<String, Boolean> anyMatch = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().anyMatch(p -> p.getUnitsInStock() > 0))); return anyMatch; }
public List<Integer> shortStringLengthOrderbyDescendingCustom() { String[] words = {"aPPLE", "AbAcUs", "bRaNcH", "BlUeBeRrY", "ClOvEr", "cHeRry"}; List<Integer> sortedWords = Arrays.stream(words).filter(w -> w.length() < 6).map(w -> w.length()). sorted(new CustomNumberComparer().reversed()).toList(); return sortedWords; }
public int[] intZipMultiply() { int[] numbersA = {0, 2, 4, 5, 6, 8, 9}; int[] numbersB = {1, 3, 5, 7, 8, 10, 11}; int length = numbersA.length; int[] multiplyNumbers = IntStream.range(0, length).map(i -> numbersA[i] * numbersB[i]).toArray(); return multiplyNumbers; }
public Map<String, Integer> customerExpensiveOrdersCountDict() { List<Customer> customers = getCustomerList(); Map<String, Integer> orderCounts = customers.stream().collect(toMap( c -> c.getCustomerId(), c -> (int) c.getOrders().stream().filter(o -> o.getTotal() > 100).count())); return orderCounts; }
public Map<String, Product> productEachCategoryFirstDict() { List<Product> products = getProductList(); Map<String, Product> categories = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().findFirst().get())); return categories; }
public boolean stringAllMatch(char c) { String[] words = {"cherry", "apple", "blueberry", "banana", "abacus"}; boolean allMatch = Arrays.stream(words).allMatch(w -> w.charAt(0) > c); return allMatch; }
public List<Pair<Integer, Customer>> customerLeftOuterJoinRegionsWithCode() { List<Pair<String, Integer>> regions = Arrays.asList( Pair.with("BC", 101), Pair.with("BC", 105), Pair.with("OR", 121), Pair.with("LA", 143) ); List<Customer> customers = getCustomerList(); List<Pair<Integer, Customer>> q = regions.stream().map( r -> Pair.with(r.getValue1(), customers.stream().filter(c -> c.getRegion().equals(r)) .collect(Collectors.toList()))).flatMap(t -> defaultIfEmpty(t.getValue1(), null).stream() .map(p1 -> Pair.with(t.getValue0(), p1))).toList(); return q; }
public int oddNumbersCount(int[] numbers) { int oddNumbersCount = (int) Arrays.stream(numbers).filter(n -> (n % 2 == 1)).count(); return oddNumbersCount; }
public List<Pair<String, LocalDate>> customerOrdersNestedSkip() { List<Customer> customers = getCustomerList(); List<Pair<String, LocalDate>> after3Orders = customers.stream().flatMap(c -> c.getOrders().stream() .map(o -> Pair.with(c.getCustomerId(), o.getOrderDate()))).skip(3).toList(); return after3Orders; }
public int customerWithManyOrdersCount() { List<Customer> customers = getCustomerList(); int count = (int) customers.stream().filter(c -> c.getOrders().size() > 5).count(); return count; }
public Map<String, Double> customerEachCountryOrdersAverageDict() { List<Customer> customers = getCustomerList(); Map<String, Double> ordersAverage = customers.stream().collect(groupingBy(c -> c.getCountry())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().mapToInt(c -> c.getOrders().size()).average().getAsDouble())); return ordersAverage; }
public List<Pair<Pair<String, Integer>, String>> customerCrossGroupJoinRegionsWithCodeNameRegion() { List<Pair<String, Integer>> regions = Arrays.asList( Pair.with("BC", 101), Pair.with("BC", 105), Pair.with("OR", 121), Pair.with("LA", 143) ); List<Customer> customers = getCustomerList(); List<Pair<Pair<String, Integer>, String>> q = regions.stream().map( r -> Pair.with(r, customers.stream().filter(c -> c.getRegion().equals(r)) .collect(Collectors.toList()))).flatMap(t -> t.getValue1().stream() .map(c1 -> Pair.with(t.getValue0(), c1.getCompanyName()))).toList(); return q; }
public Map<String, List<Product>> expensiveProductEachCategoryMaxUnitPriceProductsDict() { List<Product> products = getProductList(); Map<String, List<Product>> categories = products.stream().filter(p -> p.getUnitPrice() > 100).collect( groupingBy(p -> p.getCategory())).entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().collect(groupingBy(p -> p.getUnitPrice())) .entrySet().stream().max(Map.Entry.comparingByKey()).get().getValue())); return categories; }
public Map<Integer, Map<Integer, List<Order>>> customerNestedGroupByOrderYearAndMonthPrint() { List<Customer> customers = getCustomerList(); Map<Integer, Map<Integer, List<Order>>> customerOrderGroups = customers.stream().flatMap(c -> c.getOrders().stream()) .collect(groupingBy(o -> o.getOrderDate().getYear())).entrySet().stream().collect(toMap( g -> g.getKey(), g -> g.getValue().stream().collect(groupingBy( o -> o.getOrderDate().getMonthValue() )))); for (var e1 : customerOrderGroups.entrySet()) { System.out.println(e1.getKey() + ":"); for (var e2 : e1.getValue().entrySet()) { System.out.println("\t" + e2.getKey() + ":"); e2.getValue().stream().forEach(o -> System.out.println("\t\t" + o)); } } return customerOrderGroups; }
public double expensiveProductUnitPriceMax() { List<Product> products = getProductList(); double maxUnitPrice = products.stream().filter(p -> p.getUnitPrice() > 100) .mapToDouble(p -> p.getUnitPrice()).max().getAsDouble(); return maxUnitPrice; }
public double doubleMin() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; double minNum = Arrays.stream(numbers).min().getAsDouble(); return minNum; }
public Boolean[] oddIntWithOriginalIndex() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; Boolean[] numSelected = (Boolean[]) IntStream.range(0, numbers.length).filter(i -> numbers[i] % 2 == 1).mapToObj(i -> numbers[i] == i).toArray(); return numSelected; }
public List<Pair<String, Double>> customerOrdersTotalMin() { List<Customer> customers = getCustomerList(); List<Pair<String, Double>> ordersTotalMin = customers.stream().map(c -> Pair.with(c.getCustomerId(), c.getOrders().stream().mapToDouble(o -> o.getTotal()).min().getAsDouble())).toList(); return ordersTotalMin; }
public List<Pair<String, String>> productCrossJoinCategoriesName() { String[] categories = {"Beverages", "Condiments", "Vegetables", "Dairy Products", "Seafood"}; List<Product> products = getProductList(); List<Pair<String, String>> q = Arrays.stream(categories).flatMap( c -> products.stream().filter(p -> p.getCategory().equals(c)).map( p -> Pair.with(c, p.getProductName()))).toList(); return q; }
public List<String> shortStringOrderbyLength() { String[] words = {"cherry", "apple", "blueberry", "pear", "peach", "melon"}; List<String> sortedWords = Arrays.stream(words).filter(w -> w.length() < 6).sorted(Comparator.comparing(w -> w.length())).toList(); return sortedWords; }
public List<Pair<String, LocalDate>> customerSelectManyCustomerBigOrderDates() { List<Customer> customers = getCustomerList(); List<Pair<String, LocalDate>> customerProperties = customers.stream().flatMap(c -> c.getOrders() .stream().filter(o -> o.getTotal() > 100).map(o -> Pair.with(c.getCustomerId(), o.getOrderDate()))).toList(); return customerProperties; }
public void stringLengthDeferred() { String[] words = {"cherry", "apple", "blueberry"}; AtomicInteger i = new AtomicInteger(0); var q = Arrays.stream(words).map(w -> w.length()).map(n -> i.addAndGet(n)); q.forEach(v -> System.out.println(v + " " + i)); }
public boolean equalDoubles() { double[] numbersA = {0.5, 2.3, 4.7, 5.4, 9.8}; double[] numbersB = {0.5, 2.3, 4.7, 5.4, 9.8}; boolean equal = Arrays.equals(numbersA, numbersB); return equal; }
public List<String> stringTake() { String[] words = {"cherry", "apple", "blueberry", "banana", "abacus"}; List<String> afterNNumbers = Arrays.stream(words).limit(3).toList(); return afterNNumbers; }
public int[] uniqueFactorsCount(int[][] factors) { int[] factorsCount = Arrays.stream(factors) .mapToInt(a -> (int) Arrays.stream(a).distinct().count()).toArray(); return factorsCount; }
public List<Pair<Integer, Customer>> customerCrossGroupJoinRegionsWithCode() { List<Pair<String, Integer>> regions = Arrays.asList( Pair.with("BC", 101), Pair.with("BC", 105), Pair.with("OR", 121), Pair.with("LA", 143) ); List<Customer> customers = getCustomerList(); List<Pair<Integer, Customer>> q = regions.stream().map( r -> Pair.with(r.getValue1(), customers.stream().filter(c -> c.getRegion().equals(r)) .collect(Collectors.toList()))).flatMap(t -> t.getValue1().stream() .map(c1 -> Pair.with(t.getValue0(), c1))).toList(); return q; }
public Pair<Integer, Integer>[] selectManyJoinSmaller() { int[] numbersA = {0, 2, 4, 5, 6, 8, 9}; int[] numbersB = {1, 3, 5, 7, 8}; Pair<Integer, Integer>[] pairs = (Pair<Integer, Integer>[]) Arrays.stream(numbersA).boxed().flatMap(a -> Arrays.stream(numbersB) .filter(b -> a < b).mapToObj(b -> Pair.with(a, b))).toArray(); return pairs; }
public Map<String, Double> productsConvertFieldsToDictionaryAndPrint() { List<Product> products = getProductList(); Map<String, Double> productsUnitPrice = products.stream().collect(toMap( p ->p.getProductName(), p ->p.getUnitPrice())); for(var pair : productsUnitPrice.entrySet()) System.out.println(pair.getKey() + " " + pair.getValue()); return productsUnitPrice; }
public List<Pair<String, Order>> customerSelectManyCustomerBigOrders() { List<Customer> customers = getCustomerList(); List<Pair<String, Order>> customerProperties = customers.stream().flatMap(c -> c.getOrders() .stream().filter(o -> o.getTotal() > 100).map(o -> Pair.with(c.getCustomerId(), o))).toList(); return customerProperties; }
public Map<String, Map<Integer, List<Order>>> customerNestedGroupByNameAndOrderYear() { List<Customer> customers = getCustomerList(); Map<String, Map<Integer, List<Order>>> customerOrderGroups = customers.stream().collect(toMap( c -> c.getCompanyName(), c -> c.getOrders().stream().collect( groupingBy(o -> o.getOrderDate().getYear())) )); return customerOrderGroups; }
public int oddNumbersSumTwice() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int numbersSum = Arrays.stream(numbers).filter(n -> n % 2 == 0).map(n -> n * 2).sum(); return numbersSum; }
public List<Pair<String, Double>> customerInRegionOrdersTotalMax(String region) { List<Customer> customers = getCustomerList(); List<Pair<String, Double>> ordersTotalMax = customers.stream().filter(c -> c.getRegion().equals(region)) .map(c -> Pair.with(c.getCustomerId(), c.getOrders().stream().mapToDouble(o -> o.getTotal()).max().getAsDouble())).toList(); return ordersTotalMax; }
public List<Integer> intSkip() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; List<Integer> after3Numbers = Arrays.stream(numbers).skip(3).boxed().toList(); return after3Numbers; }
public List<Product> expensiveProductOrderbyCategoryThenbyNameCustom() { List<Product> products = getProductList(); List<Product> sortedProducts = products.stream().filter(p->p.getUnitPrice()>100) .sorted(Comparator.comparing((Product p) -> p.getCategory()) .thenComparing(p -> p.getProductName(),new CaseInsensitiveComparer().reversed())).toList(); return sortedProducts; }
public List<Triplet<String, Integer, Double>> customerSelectManyCustomerBigOrderIdAndTotals() { List<Customer> customers = getCustomerList(); List<Triplet<String, Integer, Double>> customerProperties = customers.stream().flatMap(c -> c.getOrders() .stream().filter(o -> o.getTotal() > 100).map(o -> Triplet.with(c.getCustomerId(), o.getOrderId(), o.getTotal()))).toList(); return customerProperties; }
public List<String> stringOrderbyLengthThenbyCustom() { String[] words = {"aPPLE", "AbAcUs", "bRaNcH", "BlUeBeRrY", "ClOvEr", "cHeRry"}; List<String> sortedWords = Arrays.stream(words).sorted(Comparator.comparing((String w) -> w.length()) .thenComparing(new CaseInsensitiveComparer())).toList(); return sortedWords; }
public Map<Boolean, List<Double>> doubleGroupByBoolDictOrderbyDescending() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; Map<Boolean, List<Double>> numbersGroups = Arrays.stream(numbers).boxed().collect(groupingBy(n -> n > 5)) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().sorted(Comparator.reverseOrder()).toList())); return numbersGroups; }
public List<Product> expensiveProductOrderbyCategoryThenbyName() { List<Product> products = getProductList(); List<Product> sortedProducts = products.stream().filter(p->p.getUnitPrice()>100) .sorted(Comparator.comparing((Product p) -> p.getCategory()) .thenComparing(p -> p.getProductName())).toList(); return sortedProducts; }
public int[] intsConvertToArray() { int[] ints = {2, 3, 1, 5, 4}; int[] intsArray = Arrays.stream(ints).sorted().toArray(); return intsArray; }
public int numbersMinTwice() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int minNum = Arrays.stream(numbers).map(n -> n * 2).min().getAsInt(); return minNum; }
public int aggregateWithdrawMoneyWithSeed() { int startBalance = 100; int[] attemptedWithdrawals = {20, 10, 40, 50, 10, 70, 30}; int endBalance = Arrays.stream(attemptedWithdrawals).reduce(startBalance,(balance, nextWithdrawal) -> nextWithdrawal <= balance ? balance - nextWithdrawal : balance); return 0; }
public int[] intZipAddReverse() { int[] numbersA = {0, 2, 4, 5, 6, 8, 9}; int[] numbersB = {1, 3, 5, 7, 8, 10, 11}; int length = numbersA.length; int[] addNumbers = IntStream.range(0, length).map(i -> numbersA[i] + numbersB[length - 1 - i]).toArray(); return addNumbers; }
public List<String> stringOrderbyLengthCustom() { String[] words = {"aPPLE", "AbAcUs", "bRaNcH", "BlUeBeRrY", "ClOvEr", "cHeRry"}; List<String> sortedWords = Arrays.stream(words).sorted(Comparator.comparing(w -> w.length(), new CustomNumberComparer())).toList(); return sortedWords; }
public List<Pair<Integer, Customer>> customerCrossJoinRegionsWithCode() { List<Pair<String, Integer>> regions = Arrays.asList( Pair.with("BC", 101), Pair.with("BC", 105), Pair.with("OR", 121), Pair.with("LA", 143) ); List<Customer> customers = getCustomerList(); List<Pair<Integer, Customer>> q = regions.stream().flatMap( r -> customers.stream().filter(c -> c.getRegion().equals(r.getValue0())).map( c -> Pair.with(r.getValue1(), c))).toList(); return q; }
public Map<String, Integer> countRegionDistinctCustomerDict() { List<Customer> customers = getCustomerList(); Map<String, Integer> regionCounts = customers.stream().collect(groupingBy(c -> c.getRegion())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> (int) g.getValue().stream().distinct().count())); return regionCounts; }
public Map<String, List<Customer>> customerEachCountryOrdersMinCustomerDict() { List<Customer> customers = getCustomerList(); Map<String, List<Customer>> customerOrdersMin = customers.stream().collect(groupingBy(c -> c.getCountry())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream(). collect(groupingBy(c -> c.getOrders().size())).entrySet() .stream().min(Map.Entry.comparingByKey()).get().getValue())); return customerOrdersMin; }
public Map<String, Double> customerExpensiveOrdersTotalAverageDict() { List<Customer> customers = getCustomerList(); Map<String, Double> ordersTotalAverage = customers.stream().collect(toMap(c -> c.getCustomerId(), c -> c.getOrders().stream().filter(o -> o.getTotal() > 100) .mapToDouble(o -> o.getTotal()).average().getAsDouble())); return ordersTotalAverage; }
public List<Integer> intSkipWhileCount(int[] numbers, int n) { List<Integer> afterNNumbers = Arrays.stream(numbers).dropWhile(i -> i > n).boxed().toList(); return afterNNumbers; }
public int[] intExcept() { int[] numbersA = {0, 2, 4, 5, 9}; int[] numbersB = {0, 2, 4, 5, 9}; int[] differemtNumbers = Arrays.stream(numbersA).distinct().filter(a -> Arrays.stream(numbersB).allMatch(b -> b != a)).toArray(); return differemtNumbers; }
public List<String> exceptOfCategory() { String[] categories = {"Furnitures", "Seagoods"}; List<Product> products = getProductList(); var productCategories = products.stream().map(p -> p.getCategory()); List<String> differemtCategories = productCategories.distinct().filter(a -> Arrays.stream(categories).allMatch(b -> !b.equals(a))).toList(); return differemtCategories; }
public List<Pair<String, Order>> customerEachRegionFirstOrder() { List<Customer> customers = getCustomerList(); List<Pair<String, Order>> ordersFirst = customers.stream().collect(groupingBy(c -> c.getRegion())) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().flatMap(c -> c.getOrders().stream()).findFirst().get())).toList(); return ordersFirst; }
public Map<String, List<Customer>> customerEachRegionOrdersMinCustomerDict() { List<Customer> customers = getCustomerList(); Map<String, List<Customer>> customerOrdersMin = customers.stream().collect(groupingBy(c -> c.getRegion())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream(). collect(groupingBy(c -> c.getOrders().size())).entrySet() .stream().min(Map.Entry.comparingByKey()).get().getValue())); return customerOrdersMin; }
public List<Pair<String, Integer>> expensiveProductEachCategoryStock() { List<Product> products = getProductList(); List<Pair<String, Integer>> categories = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().filter( p -> p.getUnitPrice() > 100).mapToInt(p -> p.getUnitsInStock()).min().getAsInt())).toList(); return categories; }
public int[] intsConvertToDescendingArrayAndPrint() { int[] ints = {2, 3, 1, 5, 4}; int[] intsArray = Arrays.stream(ints).boxed().sorted(Comparator.reverseOrder()).mapToInt(d -> d).toArray(); for (int i = 0; i < intsArray.length; i++) System.out.println(intsArray[i]); return intsArray; }
public Map<String, Product> productEachCategoryElementAtDict() { List<Product> products = getProductList(); Map<String, Product> categories = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().collect(toMap(g -> g.getKey(), g->g.getValue().stream().skip(1).findFirst().get())); return categories; }
public Map<String, List<Product>> productEachCategoryFirstOrDefaultUnitPriceProductsDict() { List<Product> products = getProductList(); Map<String, List<Product>> categories = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().filter(p -> p.getUnitPrice() == g.getValue().stream().findFirst().orElse(Product.DEFAULT).getUnitPrice()).toList())); return categories; }
public List<String> unionOfName() { List<Product> products = getProductList(); List<Customer> customers = getCustomerList(); var productNames = products.stream().map(p -> p.getProductName()); var customerNames = customers.stream().map(c -> c.getCompanyName()); List<String> uniqueNames = Stream.concat(productNames, customerNames).distinct().toList(); return uniqueNames; }
public Map<String, List<Customer>> customerEachCountryOrdersFirstOrDefaultCustomerDict() { List<Customer> customers = getCustomerList(); Map<String, List<Customer>> customerOrdersFirstOrDefault = customers.stream().collect(groupingBy(c -> c.getRegion())) .entrySet().stream().collect(toMap(g -> g.getKey(), g->g.getValue().stream().filter( c -> c.getOrders().size() == g.getValue().stream().findFirst().orElse(Customer.DEFAULT).getOrders().size()).toList())); return customerOrdersFirstOrDefault; }
public List<Pair<String, Double>> customerIdAndBiggestTotal() { List<Customer> customers = getCustomerList(); List<Pair<String, Double>> customerProperties = customers.stream().map(c -> Pair.with(c.getCustomerId(),c.getOrders().stream() .mapToDouble(o -> o.getTotal()).max().getAsDouble())).toList(); return customerProperties; }
public Map<String, Boolean> expensiveProductEachGroupAnyMatch() { List<Product> products = getProductList(); Map<String, Boolean> anyMatch = products.stream().filter(p -> p.getUnitPrice() > 100).collect(groupingBy(p -> p.getCategory())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().anyMatch(p -> p.getUnitsInStock() > 0))); return anyMatch; }
public List<Pair<String, List<Integer>>> productGroupByCategoryWithId() { List<Product> products = getProductList(); List<Pair<String, List<Integer>>> category = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().map(p -> p.getProductId()).toList())).toList(); return category; }
public List<Integer> stringLengthOrderbyCustom() { String[] words = {"aPPLE", "AbAcUs", "bRaNcH", "BlUeBeRrY", "ClOvEr", "cHeRry"}; List<Integer> sortedWords = Arrays.stream(words).map(w -> w.length()).sorted(new CustomNumberComparer()).toList(); return sortedWords; }
public List<Double> bigDoubleOrderbyModDescendingThenby() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; List<Double> sortedNumbers = Arrays.stream(numbers).filter(n->n>3).boxed().sorted( Comparator.comparing((Double n) -> n % 1.5,Comparator.reverseOrder()) .thenComparing(Comparator.naturalOrder())).toList(); return sortedNumbers; }
public List<Pair<Boolean, List<Double>>> doubleGroupByBoolOrderby() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; List<Pair<Boolean, List<Double>>> numbersGroups = Arrays.stream(numbers).boxed().collect(groupingBy(n -> n > 5)) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().sorted().toList())).toList(); return numbersGroups; }
public Character[] stringFirstChar() { String[] strings = {"zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"}; Character[] selected = (Character[]) Arrays.stream(strings).map(w -> w.charAt(0)).toArray(); return selected; }
public List<Product> expensiveProductOrderbyDescendingId() { List<Product> products = getProductList(); List<Product> sortedProducts = products.stream().filter(p -> p.getUnitPrice() > 100) .sorted(Comparator.comparing(p -> p.getProductId(), Comparator.reverseOrder())).toList(); return sortedProducts; }
public List<Pair<String, Double>> customerInRegionOrdersTotalSum(String region) { List<Customer> customers = getCustomerList(); List<Pair<String, Double>> ordersTotalSum = customers.stream().filter(c -> c.getRegion().equals(region)) .map(c -> Pair.with(c.getCustomerId(), c.getOrders().stream().mapToDouble(o -> o.getTotal()).sum())).toList(); return ordersTotalSum; }
public int[] bigIntAddOriginalIndex() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int[] numSelected = IntStream.range(0, numbers.length).filter(i -> numbers[i] > 5).filter(i -> numbers[i] % 2 == 1).map(i -> numbers[i] + i).toArray(); return numSelected; }
public boolean customerOrdersNestedAllMatch() { List<Customer> customers = getCustomerList(); boolean allMatch = customers.stream().flatMap(c -> c.getOrders().stream() .map(o -> Pair.with(c.getCustomerId(), o.getOrderDate()))) .allMatch(t -> t.getValue1().isAfter(LocalDate.of(2000, 1, 1))); return allMatch; }
public Map<String, Integer> productEachCategoryStockDict() { List<Product> products = getProductList(); Map<String, Integer> categories = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().mapToInt(p -> p.getUnitsInStock()).sum())); return categories; }
public void bigNumbersTwiceDeferred() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; AtomicInteger i = new AtomicInteger(0); var q = Arrays.stream(numbers).filter(n->n>5).map(n->n*2).map(n -> i.addAndGet(n)); q.forEach(v -> System.out.println(v + " " + i)); }
public Map<Boolean, List<Integer>> productGroupByInStockWithIdDict() { List<Product> products = getProductList(); Map<Boolean, List<Integer>> productGroup = products.stream().collect(groupingBy(p -> p.getUnitsInStock() > 0)) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().map(p -> p.getProductId()).toList())); return productGroup; }
public int distinctOddNumbersCount(int[] numbers) { int oddNumbersCount = (int) Arrays.stream(numbers).distinct().filter(n -> (n % 2 == 1)).count(); return oddNumbersCount; }
public double[] doubleExcept() { double[] numbersA = {0.1, 2.2, 4.3, 5.4, 6.5, 8.6, 9.7}; double[] numbersB = {0.1, 3.3, 5.4, 7.7, 8.6}; double[] differemtNumbers = Arrays.stream(numbersA).distinct().filter(a -> Arrays.stream(numbersB).allMatch(b -> b != a)).toArray(); return differemtNumbers; }
public List<Product> expensiveProductOrderbyCategoryThenbyId() { List<Product> products = getProductList(); List<Product> sortedProducts = products.stream().filter(p->p.getUnitPrice()>100) .sorted(Comparator.comparing((Product p) -> p.getCategory()) .thenComparing(p -> p.getProductName())).toList(); return sortedProducts; }
public List<Order> customerSelectManyOrders() { List<Customer> customers = getCustomerList(); List<Order> customerProperties = customers.stream().flatMap(c -> c.getOrders().stream()).toList(); return customerProperties; }
public double expensiveProductUnitPriceAggregateAverage() { List<Product> products = getProductList(); double aggregateSum = products.stream().map(p -> p.getUnitPrice()).filter(d -> d > 100) .reduce((a, b) ->(a + b) / 2).get(); return aggregateSum; }
public int cheapProductCount() { List<Product> products = getProductList(); int count = (int) products.stream().filter(p -> p.getUnitPrice() < 100).count(); return count; }
public int[] bigIntPlusOne() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int[] numSelected = Arrays.stream(numbers).filter(n -> n > 5).map(n -> n + 1).toArray(); return numSelected; }
public List<Product> expensiveProductSkip() { List<Product> products = getProductList(); List<Product> after3Products = products.stream().filter(p -> p.getUnitPrice() > 100).skip(3).toList(); return after3Products; }
public double[] convertSelectedDoubleItemToArrayAndPrintForeach() { Object[] numbers = { null, 1.0, "two", 3, "four", 5, "six", 7.0 }; double[] doubles = Arrays.stream(numbers).filter(o->o instanceof Double).mapToDouble(d-> (double) d).toArray(); for (double d : doubles) System.out.println(d); return doubles; }
public List<Integer> oddIntOriginalIndexedWhere() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; List<Integer> q = IntStream.range(0, numbers.length).filter(i -> numbers[i] < i && numbers[i] % 2 == 1) .map(i -> numbers[i]).boxed().toList(); return q; }
public double projectedDoubleElementAt() { double[] numbers = { 3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0 }; double numAt = Arrays.stream(numbers).map(i -> Math.log(i)).filter(n -> n > 3).skip(2).findFirst().getAsDouble(); return numAt; }
public List<Integer> intSquareSkipWhileIndexed() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; List<Integer> afterNumbers =  IntStream.range(0, numbers.length) .dropWhile(i -> numbers[i]*numbers[i] > i).map(i -> numbers[i]*numbers[i]).boxed().toList(); return afterNumbers; }
public List<Pair<String, Integer>> productEachCategoryStock() { List<Product> products = getProductList(); List<Pair<String, Integer>> categories = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().mapToInt(p -> p.getUnitsInStock()).sum())).toList(); return categories; }
public int expensiveProductStockMin() { List<Product> products = getProductList(); int minUnitPrice = products.stream().filter(p -> p.getUnitPrice() > 100) .mapToInt(p -> p.getUnitsInStock()).min().getAsInt(); return minUnitPrice; }
public Map<String, List<Double>> productGroupJoinCategoriesUnitPrice() { String[] categories = {"Beverages", "Condiments", "Vegetables", "Dairy Products", "Seafood"}; List<Product> products = getProductList(); Map<String, List<Double>> q = Arrays.stream(categories).map(c -> Pair.with(c, products.stream() .filter(p -> p.getCategory().equals(c)).map(p1 -> p1.getUnitPrice()).toList())) .collect(toMap(t -> t.getValue0(), t -> t.getValue1())); return q; }
