public List<Pair<String, Double>> customerInRegionOrdersTotalAverage(String region) { List<Customer> customers = getCustomerList(); List<Pair<String, Double>> ordersTotalAverage = customers.stream().filter(c -> c.getRegion().equals(region)) .map(c -> Pair.with(c.getCustomerId(), c.getOrders().stream().mapToDouble(o -> o.getTotal()).average().getAsDouble())).toList(); return ordersTotalAverage; }
public List<Triplet<String, Integer, Integer>> customerSelectManyCustomerOrderDateYearAndMonth() { List<Customer> customers = getCustomerList(); List<Triplet<String, Integer, Integer>> customerProperties = customers.stream().flatMap(c -> c.getOrders() .stream().map(o -> Triplet.with(c.getCustomerId(), o.getOrderDate().getYear(), o.getOrderDate().getMonthValue()))).toList(); return customerProperties; }
public List<Pair<String, Product>> productLeftOuterJoinCategories() { String[] categories = {"Beverages", "Condiments", "Vegetables", "Dairy Products", "Seafood"}; List<Product> products = getProductList(); List<Pair<String, Product>> q = Arrays.stream(categories).map( c -> Pair.with(c, products.stream().filter(p -> p.getCategory().equals(c)) .collect(Collectors.toList()))).flatMap(t -> defaultIfEmpty(t.getValue1(), null).stream() .map(p1 -> Pair.with(t.getValue0(), p1))).toList(); return q; }
public List<Pair<Boolean, List<Double>>> doubleGroupByBoolOrderbyFraction() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; List<Pair<Boolean, List<Double>>> numbersGroups = Arrays.stream(numbers).boxed().collect(groupingBy(n -> n > 5)) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().sorted(Comparator.comparing( n -> n - (int) n.doubleValue())).toList())).toList(); return numbersGroups; }
public List<Pair<String, List<Customer>>> customerEachCountryOrdersMinCustomer() { List<Customer> customers = getCustomerList(); List<Pair<String, List<Customer>>> customerOrdersMin = customers.stream().collect(groupingBy(c -> c.getCountry())) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream(). collect(groupingBy(c -> c.getOrders().size())).entrySet() .stream().min(Map.Entry.comparingByKey()).get().getValue())).toList(); return customerOrdersMin; }
public Map<String, List<Product>> productEachGroupTakeWhile() { List<Product> products = getProductList(); Map<String, List<Product>> after3EachGroups = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().takeWhile(p -> p.getProductId() > 100).toList())); return after3EachGroups; }
public Map<Boolean, List<Double>> doubleGroupByBoolDictOrderby() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; Map<Boolean, List<Double>> numbersGroups = Arrays.stream(numbers).boxed().collect(groupingBy(n -> n > 5)) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().sorted().toList())); return numbersGroups; }
public List<Double> bigDoubleOrderbyFractionDescendingThenby() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; List<Double> sortedNumbers = Arrays.stream(numbers).filter(n->n>3).boxed().sorted( Comparator.comparing((Double n) -> n - (int) n.doubleValue(),Comparator.reverseOrder()) .thenComparing(Comparator.naturalOrder())).toList(); return sortedNumbers; }
public double[] doublesConvertToDescendingArray() { double[] doubles = {1.7, 2.3, 1.9, 4.1, 2.9}; double[] doublesArray = Arrays.stream(doubles).boxed().sorted(Comparator.reverseOrder()).mapToDouble(d -> d).toArray(); return doublesArray; }
public double[] convertSelectedDoubleItemToArrayAndPrint() { Object[] numbers = { null, 1.0, "two", 3, "four", 5, "six", 7.0 }; double[] doubles = Arrays.stream(numbers).filter(o->o instanceof Double).mapToDouble(d-> (double) d).toArray(); for (int i = 0; i < doubles.length; i++) System.out.println(doubles[i]); return doubles; }
public Map<String, Integer> customerDistinctOrdersCountDict() { List<Customer> customers = getCustomerList(); Map<String, Integer> orderCounts = customers.stream().collect(toMap( c -> c.getCustomerId(), c -> (int) c.getOrders().stream().distinct().count())); return orderCounts; }
public List<Customer> repeatedCustomers() { List<Customer> customers =  Collections.nCopies(5, Customer.DEFAULT); return customers; }
public int[] bigIntAddIndex() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int[] bigNumbers = Arrays.stream(numbers).filter(n -> n > 5).toArray(); int[] numSelected = IntStream.range(0, bigNumbers.length).map(i -> bigNumbers[i] + i).toArray(); return numSelected; }
public List<Product> expensiveProductSkipWhile() { List<Product> products = getProductList(); List<Product> after3Products = products.stream().filter(p -> p.getUnitPrice() > 100).dropWhile(p -> p.getProductId() > 100).toList(); return after3Products; }
public int numbersSumTwice() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int numbersSum = Arrays.stream(numbers).map(n -> n * 2).sum(); return numbersSum; }
public int intDotProduct() { int[] numbersA = {0, 2, 4, 5, 6, 8, 9}; int[] numbersB = {1, 3, 5, 7, 8, 10, 11}; int length = numbersA.length; int dotProduct = IntStream.range(0, length).map(i -> numbersA[i] * numbersB[i]).sum(); return dotProduct; }
public boolean customerOrdersNestedAnyMatch() { List<Customer> customers = getCustomerList(); boolean anyMatch = customers.stream().flatMap(c -> c.getOrders().stream() .map(o -> Pair.with(c.getCustomerId(), o.getOrderDate()))) .anyMatch(t -> t.getValue1().isAfter(LocalDate.of(2000, 1, 1))); return anyMatch; }
public List<String> indexedSelectManyString() { List<Customer> customers = getCustomerList(); List<String> customerOrders = IntStream.range(0, customers.size()).boxed().flatMap( i -> customers.get(i).getOrders().stream().map( o -> "Customer #" + (i + 1) + " has an order with OrderID " + o.getOrderId())) .collect(Collectors.toList()); return customerOrders; }
public double[] doubleUnion() { double[] numbersA = {0.1, 2.2, 4.3, 5.4, 6.5, 8.6, 9.7}; double[] numbersB = {0.1, 3.3, 5.4, 7.7, 8.6}; double[] uniqueNumbers = DoubleStream.concat(Arrays.stream(numbersA), Arrays.stream(numbersB)).distinct().toArray(); return uniqueNumbers; }
public Map<Pair<String, Integer>, List<Customer>> customerGroupJoinRegionsWithCodeRegion() { List<Pair<String, Integer>> regions = Arrays.asList( Pair.with("BC", 101), Pair.with("BC", 105), Pair.with("OR", 121), Pair.with("LA", 143) ); List<Customer> customers = getCustomerList(); Map<Pair<String, Integer>, List<Customer>> q = regions.stream().map(r -> Pair.with(r, customers.stream() .filter(c -> c.getRegion().equals(r.getValue0())).toList())) .collect(toMap(t->t.getValue0(),t->t.getValue1())); return q; }
public List<Integer> intTake() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; List<Integer> after3Numbers = Arrays.stream(numbers).limit(3).boxed().toList(); return after3Numbers; }
public List<Pair<String, Order>> customerIdAndFirstOrDefaultOrder() { List<Customer> customers = getCustomerList(); List<Pair<String, Order>> customerProperties = customers.stream().map(c -> Pair.with(c.getCustomerId(), c.getOrders().stream().findFirst().orElse(Order.DEFAULT))).toList(); return customerProperties; }
public int[] intUnion() { int[] numbersA = {0, 2, 4, 5, 9}; int[] numbersB = {0, 2, 4, 5, 9}; int[] uniqueNumbers = IntStream.concat(Arrays.stream(numbersA), Arrays.stream(numbersB)).distinct().toArray(); return uniqueNumbers; }
public List<Pair<String, List<Product>>> productEachCategoryMaxUnitPriceProducts() { List<Product> products = getProductList(); List<Pair<String, List<Product>>> categories = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().collect(groupingBy(p -> p.getUnitPrice())) .entrySet().stream().max(Map.Entry.comparingByKey()).get().getValue())).toList(); return categories; }
public List<Integer> shortStringLengthOrderby() { String[] words = {"cherry", "apple", "blueberry", "pear", "peach", "melon"}; List<Integer> sortedWords = Arrays.stream(words).filter(w -> w.length() < 6).map(w -> w.length()).sorted().toList(); return sortedWords; }
public List<String> stringTakeCount(int n) { String[] words = {"cherry", "apple", "blueberry", "banana", "abacus"}; List<String> afterNWords = Arrays.stream(words).limit(3).toList(); return afterNWords; }
public boolean oddIntAnyMatch() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; boolean anyMatch = Arrays.stream(numbers).filter(i -> i % 2 == 1).anyMatch(n -> n > 3); return anyMatch; }
public boolean unequalInts() { int[] numbersA = {0, 2, 4, 5, 9}; int[] numbersB = {1, 3, 5, 6, 10}; boolean equal = Arrays.equals(numbersA, numbersB); return equal; }
public List<String> stringOrderbyCustomThenbyLengthCustom() { String[] words = {"aPPLE", "AbAcUs", "bRaNcH", "BlUeBeRrY", "ClOvEr", "cHeRry"}; List<String> sortedWords = Arrays.stream(words) .sorted(Comparator.comparing((String w) -> w,new CaseInsensitiveComparer()) .thenComparing(w -> w.length(),new CustomNumberComparer())).toList(); return sortedWords; }
public List<String> stringOrderbyDescendingLength() { String[] words = {"cherry", "apple", "blueberry"}; List<String> sortedWords = Arrays.stream(words).sorted(Comparator.comparing(w -> w.length(), Comparator.reverseOrder())).toList(); return sortedWords; }
public Map<Character, List<String>> stringGroupByFirstCharDictOrderby() { String[] words = {"blueberry", "chimpanzee", "abacus", "banana", "apple", "cheese"}; Map<Character, List<String>> wordsGroups = Arrays.stream(words).collect(groupingBy(w -> w.charAt(0))) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().sorted().toList())); return wordsGroups; }
public List<Pair<String, List<Product>>> expensiveProductEachCategoryMaxUnitPriceProducts() { List<Product> products = getProductList(); List<Pair<String, List<Product>>> categories = products.stream().filter(p -> p.getUnitPrice() > 100). collect(groupingBy(p -> p.getCategory())).entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().collect(groupingBy(p -> p.getUnitPrice())) .entrySet().stream().max(Map.Entry.comparingByKey()).get().getValue())).toList(); return categories; }
public List<Double> bigDoubleOrderbyModDescendingThenbyDescending() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; List<Double> sortedNumbers = Arrays.stream(numbers).filter(n->n>3).boxed().sorted( Comparator.comparing((Double n) -> n % 1.5,Comparator.reverseOrder()) .thenComparing(Comparator.reverseOrder())).toList(); return sortedNumbers; }
public List<Integer> repeatedIntsWithValue(int value) { List<Integer> numbers = Collections.nCopies(10, value); return numbers; }
public List<Pair<Boolean, List<Double>>> doubleGroupByBoolOrderbyDescending() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; List<Pair<Boolean, List<Double>>> numbersGroups = Arrays.stream(numbers).boxed().collect(groupingBy(n -> n > 5)) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().sorted(Comparator.reverseOrder()).toList())).toList(); return numbersGroups; }
public List<String> stringOrderbyDescending() { String[] words = {"cherry", "apple", "blueberry"}; List<String> sortedWords = Arrays.stream(words).sorted(Comparator.reverseOrder()).toList(); return sortedWords; }
public List<Product> productSkipWhile() { List<Product> products = getProductList(); List<Product> after3Products = products.stream().dropWhile(p -> p.getProductId() > 100).toList(); return after3Products; }
public List<Pair<String, LocalDate>> waCustomerOrdersEachNestedSkipWhile() { List<Customer> customers = getCustomerList(); List<Pair<String, LocalDate>> after3EachWAOrders = customers.stream().filter(c -> c.getRegion().equals("WA")) .flatMap(c -> c.getOrders().stream().dropWhile(o -> o.getOrderDate() .isAfter(LocalDate.of(2000, 1, 1))) .map(o -> Pair.with(c.getCustomerId(), o.getOrderDate()))).toList(); return after3EachWAOrders; }
public Map<String, Map<String, Map<String, Customer>>> customerNestedGroupByRegionAndCountryAndName() { List<Customer> customers = getCustomerList(); Map<String, Map<String, Map<String, Customer>>> customerGroups = customers.stream().collect(groupingBy(p -> p.getRegion())) .entrySet().stream().collect(toMap( g -> g.getKey(), g -> g.getValue().stream().collect(groupingBy(c -> c.getCountry())) .entrySet().stream().collect(toMap( g1 -> g1.getKey(), g1 -> g1.getValue().stream().collect(toMap( c -> c.getCompanyName(), c -> c)))))); return customerGroups; }
public List<String> intersectOfName() { List<Product> products = getProductList(); List<Customer> customers = getCustomerList(); var productNames = products.stream().map(p -> p.getProductName()); var customerNames = customers.stream().map(c -> c.getCompanyName()); List<String> sharedNames = productNames.distinct().filter(a -> customerNames.anyMatch(b -> b.equals(a))).toList(); return sharedNames; }
public void shortStringLengthEager() { String[] words = {"cherry", "apple", "blueberry"}; AtomicInteger i = new AtomicInteger(0); var q = Arrays.stream(words).filter(w->w.length()<7).map(w -> w.length()).map(n -> i.addAndGet(n)).toList(); for (var v : q) System.out.println(v + " " + i); }
public boolean productAllMatch() { List<Product> products = getProductList(); boolean allMatch = products.stream().allMatch(p -> p.getUnitsInStock() > 0); return allMatch; }
public double numbersAggregateFindMax() { double[] numbers = {1.7, 2.3, 1.9, 4.1, 2.9}; double aggregateSum = Arrays.stream(numbers).filter(n -> n > 2).reduce((a, b) -> Math.max(a, b)).getAsDouble(); return aggregateSum; }
public int bigNumbersSum() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int numbersSum = Arrays.stream(numbers).filter(n -> n >= 5).sum(); return numbersSum; }
public Map<Boolean, List<String>> stringGroupByLengthDictOrderbyLengthCustom() { String[] words = {"aPPLE", "AbAcUs", "bRaNcH", "BlUeBeRrY", "ClOvEr", "cHeRry"}; Map<Boolean, List<String>> wordsGroups = Arrays.stream(words).collect(groupingBy(w -> w.length() > 8)) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().sorted( Comparator.comparing(w -> w.length(), new CustomNumberComparer())).toList())); return wordsGroups; }
public double bigDoubleNumbersMax() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; double maxNum = Arrays.stream(numbers).filter(n -> n >= 5).max().getAsDouble(); return maxNum; }
public Map<Boolean, Integer> countExpensiveProductByInStockDict() { List<Product> products = getProductList(); Map<Boolean, Integer> inStockCounts = products.stream().collect(groupingBy(p -> p.getUnitsInStock() == 0)) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> (int) g.getValue().stream().filter(p -> p.getUnitPrice() > 100).count())); return inStockCounts; }
public List<Integer> repeatedInts() { List<Integer> numbers = Collections.nCopies(50, 0); return numbers; }
public Map<String, Map<String, Map<String, Customer>>> customerNestedGroupByRegionAndCountryAndNamePrint() { List<Customer> customers = getCustomerList(); Map<String, Map<String, Map<String, Customer>>> customerGroups = customers.stream().collect(groupingBy(p -> p.getRegion())) .entrySet().stream().collect(toMap( g -> g.getKey(), g -> g.getValue().stream().collect(groupingBy(c -> c.getCountry())) .entrySet().stream().collect(toMap( g1 -> g1.getKey(), g1 -> g1.getValue().stream().collect(toMap( c -> c.getCompanyName(), c -> c)))))); for (var e1 : customerGroups.entrySet()) { System.out.println(e1.getKey() + ":"); for (var e2 : e1.getValue().entrySet()) { System.out.println("\t" + e2.getKey() + ":"); for (var e3 : e2.getValue().entrySet()) System.out.println("\t\t" + e3.getKey() + ":" + e3.getValue()); } } return customerGroups; }
public List<Pair<String, LocalDate>> waCustomerOrdersNestedSkipWhile() { List<Customer> customers = getCustomerList(); List<Pair<String, LocalDate>> after3WAOrders = customers.stream().filter(c -> c.getRegion().equals("WA")) .flatMap(c -> c.getOrders().stream().map(o -> Pair.with(c.getCustomerId(), o.getOrderDate()))) .dropWhile(t -> t.getValue1().isAfter(LocalDate.of(2000, 1, 1))).toList(); return after3WAOrders; }
public double bigDoubleNumbersElementAt() { double[] numbers = { 3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0 }; double numAt = Arrays.stream(numbers).filter(d -> d>5).skip(1).findFirst().getAsDouble(); return numAt; }
public Map<String, Integer> productEachCategoryStockDict() { List<Product> products = getProductList(); Map<String, Integer> categories = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().mapToInt(p -> p.getUnitsInStock()).min().getAsInt())); return categories; }
public void bigDoubleNumbersEager() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; AtomicReference<Double> d = new AtomicReference<>(0.0); var q = Arrays.stream(numbers).filter(n->n>5).map(n -> d.accumulateAndGet(n, Double::sum)).boxed().toList(); for (var v : q) System.out.println(v + " " + d); }
public Map<String, List<Product>> productGroupByCategoryDictOrderbyDescendingName() { List<Product> products = getProductList(); Map<String, List<Product>> productsGroups = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream(). sorted(Comparator.comparing(p -> p.getProductName(),Comparator.reverseOrder())).toList())); return productsGroups; }
public Map<String, Double> customerExpensiveOrdersTotalMaxDict() { List<Customer> customers = getCustomerList(); Map<String, Double> ordersTotalMax = customers.stream().collect(toMap(c -> c.getCustomerId(), c -> c.getOrders().stream().filter(o -> o.getTotal() > 100) .mapToDouble(o -> o.getTotal()).max().getAsDouble())); return ordersTotalMax; }
public List<String> shortStringReverse() { String[] words = { "cherry", "apple", "blueberry", "pear", "peach", "melon" }; List<String> sortedWords = Arrays.stream(words).filter(w -> w.length() < 6).collect( collectingAndThen(toList(),l->{Collections.reverse(l);return l;})); return sortedWords; }
public int customerInRegionCount(String region) { List<Customer> customers = getCustomerList(); int count = (int) customers.stream().filter(c -> c.getRegion().equals(region)).count(); return count; }
public List<Character> unionOfNameFirstChar() { List<Product> products = getProductList(); List<Customer> customers = getCustomerList(); var productFirstChars = products.stream().map(p -> p.getProductName().charAt(0)); var customerFirstChars = customers.stream().map(c -> c.getCompanyName().charAt(0)); List<Character> uniqueFirstChars = Stream.concat(productFirstChars, customerFirstChars).distinct().toList(); return uniqueFirstChars; }
public List<Pair<String, Product>> productCrossGroupJoinCategories() { String[] categories = {"Beverages", "Condiments", "Vegetables", "Dairy Products", "Seafood"}; List<Product> products = getProductList(); List<Pair<String, Product>> q = Arrays.stream(categories).map( c -> Pair.with(c, products.stream().filter(p -> p.getCategory().equals(c)) .collect(Collectors.toList()))).flatMap(t -> t.getValue1().stream() .map(p1 -> Pair.with(t.getValue0(), p1))).toList(); return q; }
public List<Pair<String, LocalDate>> waCustomerOrdersNestedTakeWhile() { List<Customer> customers = getCustomerList(); List<Pair<String, LocalDate>> after3WAOrders = customers.stream().filter(c -> c.getRegion().equals("WA")) .flatMap(c -> c.getOrders().stream().map(o -> Pair.with(c.getCustomerId(), o.getOrderDate()))) .takeWhile(t -> t.getValue1().isAfter(LocalDate.of(2000, 1, 1))).toList(); return after3WAOrders; }
public List<String> stringSkipWhile() { String[] words = {"cherry", "apple", "blueberry", "banana", "abacus"}; List<String> afterNNumbers = Arrays.stream(words).dropWhile(w -> w.charAt(0) > 'b').toList(); return afterNNumbers; }
public Map<String, Integer> customerEachCountryOrdersMinDict() { List<Customer> customers = getCustomerList(); Map<String, Integer> ordersMin = customers.stream().collect(groupingBy(c -> c.getCountry())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().mapToInt(c -> c.getOrders().size()).min().getAsInt())); return ordersMin; }
public double stringAverageLength() { String[] words = {"cherry", "apple", "blueberry"}; double averageLength = Arrays.stream(words).mapToInt(w -> w.length()).average().getAsDouble(); return averageLength; }
public List<Pair<String, Integer>> productEachCategoryStock() { List<Product> products = getProductList(); List<Pair<String, Integer>> categories = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().mapToInt(p -> p.getUnitsInStock()).max().getAsInt())).toList(); return categories; }
public Map<Integer, List<Customer>> customerGroupJoinRegionsWithCode() { List<Pair<String, Integer>> regions = Arrays.asList( Pair.with("BC", 101), Pair.with("BC", 105), Pair.with("OR", 121), Pair.with("LA", 143) ); List<Customer> customers = getCustomerList(); Map<Integer, List<Customer>> q = regions.stream().map(r -> Pair.with(r.getValue1(), customers.stream() .filter(c -> c.getRegion().equals(r.getValue0())).toList())).collect(toMap(t->t.getValue0(),t->t.getValue1())); return q; }
public List<Pair<Boolean, List<Integer>>> productGroupByInStockWithId() { List<Product> products = getProductList(); List<Pair<Boolean, List<Integer>>> productGroup = products.stream().collect(groupingBy(p -> p.getUnitsInStock() > 0)) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().map(p -> p.getProductId()).toList())).toList(); return productGroup; }
public int productLongNameLengthSum() { List<Product> products = getProductList(); int totalSum = products.stream().map(p -> p.getProductName()) .filter(name -> name.length() > 7).mapToInt(name -> name.length()).sum(); return totalSum; }
public void bigNumbersEager() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; AtomicInteger i = new AtomicInteger(0); var q = Arrays.stream(numbers).filter(n->n>5).map(n -> i.addAndGet(n)).boxed().toList(); for (var v : q) System.out.println(v + " " + i); }
public List<Pair<Character, List<String>>> stringGroupByFirstCharOrderbyDescendingCustom() { String[] words = {"aPPLE", "AbAcUs", "bRaNcH", "BlUeBeRrY", "ClOvEr", "cHeRry"}; List<Pair<Character, List<String>>> wordsGroups = Arrays.stream(words).collect(groupingBy(w -> Character.toLowerCase(w.charAt(0)))) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().sorted(new CaseInsensitiveComparer().reversed()).toList())).toList(); return wordsGroups; }
public List<String> stringOrderbyLengthThenbyDescendingCustom() { String[] words = {"aPPLE", "AbAcUs", "bRaNcH", "BlUeBeRrY", "ClOvEr", "cHeRry"}; List<String> sortedWords =Arrays.stream(words).sorted(Comparator.comparing((String w) -> w.length()) .thenComparing(new CaseInsensitiveComparer().reversed())).toList(); return sortedWords; }
public List<String> outOfStockProductName() { List<Product> products = getProductList(); List<String> productNames = products.stream().filter(p -> p.getUnitsInStock() == 0).map(p -> p.getProductName()).toList(); return productNames; }
public int stringSumLength() { String[] words = {"cherry", "apple", "blueberry"}; int totalChars = Arrays.stream(words).mapToInt(w -> w.length()).sum(); return totalChars; }
public boolean expensiveProductAnyMatch() { List<Product> products = getProductList(); boolean anyMatch = products.stream().filter(p -> p.getUnitPrice() > 100).anyMatch(p -> p.getUnitsInStock() > 0); return anyMatch; }
public List<String> longStringOrginalIndexedWhere() { String[] words = {"cherry", "apple", "blueberry", "banana", "abacus"}; List<String> q = IntStream.range(0, words.length).filter(i -> words[i].length() < i * 3 && words[i].length() > 5).mapToObj(i -> words[i]).toList(); return q; }
public Map<String, List<String>> customerGroupJoinRegionsPhone() { String[] regions = {"BC", "SP", "OR", "LA"}; List<Customer> customers = getCustomerList(); Map<String, List<String>> q = Arrays.stream(regions).map(r -> Pair.with(r, customers.stream() .filter(c -> c.getRegion().equals(r)).map(c->c.getPhone()).toList())) .collect(toMap(t->t.getValue0(),t->t.getValue1())); return q; }
public List<Pair<String, Double>> customerExpensiveOrdersTotalSum() { List<Customer> customers = getCustomerList(); List<Pair<String, Double>> ordersTotalSum = customers.stream().map(c -> Pair.with(c.getCustomerId(), c.getOrders().stream().filter(o -> o.getTotal() > 100) .mapToDouble(o -> o.getTotal()).sum())).toList(); return ordersTotalSum; }
public int numbersMax() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int maxNum = Arrays.stream(numbers).max().getAsInt(); return maxNum; }
public int[] intAddIndex() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int[] numSelected = IntStream.range(0, numbers.length).map(i -> numbers[i] + i).toArray(); return numSelected; }
public boolean stringAnyMatchCount(String[] strings, char c) { boolean anyMatch = Arrays.stream(strings).anyMatch(w -> w.charAt(0) > c); return anyMatch; }
public List<Pair<String, Double>> customerEachRegionOrdersTotalMin() { List<Customer> customers = getCustomerList(); List<Pair<String, Double>> ordersTotalMin = customers.stream().collect(groupingBy(c -> c.getRegion())) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().flatMap(c -> c.getOrders().stream()).mapToDouble(o -> o.getTotal()).min().getAsDouble())).toList(); return ordersTotalMin; }
public double numbersDoubledAggregateMultiply() { double[] numbers = {1.7, 2.3, 1.9, 4.1, 2.9}; double product = Arrays.stream(numbers).map(n -> n * 2).reduce((a, b) -> a * b).getAsDouble(); return product; }
public String[] transformIndexHashToString() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; String[] strings = {"zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"}; String[] textNums = (String[]) Arrays.stream(numbers).mapToObj(n -> numbers[n * 97 % 10]).toArray(); return textNums; }
public Map<String, List<Product>> expensiveProductEachCategoryMinUnitPriceProductsDict() { List<Product> products = getProductList(); Map<String, List<Product>> categories = products.stream().filter(p -> p.getUnitPrice() > 100).collect( groupingBy(p -> p.getCategory())).entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().collect(groupingBy(p -> p.getUnitPrice())) .entrySet().stream().min(Map.Entry.comparingByKey()).get().getValue())); return categories; }
public List<Pair<Boolean, Integer>> countExpensiveProductByInStock() { List<Product> products = getProductList(); List<Pair<Boolean, Integer>> inStockCounts = products.stream().collect(groupingBy(p -> p.getUnitsInStock() == 0)) .entrySet().stream().map(g -> Pair.with(g.getKey(), (int) g.getValue().stream().filter(p -> p.getUnitPrice() > 100).count())).toList(); return inStockCounts; }
public int distinctOrdersCount(String region) { List<Customer> customers = getCustomerList(); int count = (int) customers.stream().flatMap(c -> c.getOrders().stream()).distinct().count(); return count; }
public boolean customerOrdersAnyMatch() { List<Customer> customers = getCustomerList(); boolean anyMatch = customers.stream().flatMap(c -> c.getOrders().stream()) .anyMatch(o -> o.getOrderDate().isAfter(LocalDate.of(2000, 1, 1))); return anyMatch; }
public List<Integer> intSkipWhile() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; List<Integer> after3Numbers = Arrays.stream(numbers).dropWhile(i -> i > 3).boxed().toList(); return after3Numbers; }
public List<Pair<String, String>> customerCrossGroupJoinRegionsName() { String[] regions = {"BC", "SP", "OR", "LA"}; List<Customer> customers = getCustomerList(); List<Pair<String, String>> q = Arrays.stream(regions).map( r -> Pair.with(r, customers.stream().filter(c -> c.getRegion().equals(r)) .collect(Collectors.toList()))).flatMap(t -> t.getValue1().stream() .map(c1 -> Pair.with(t.getValue0(), c1.getCompanyName()))).toList(); return q; }
public List<String> stringOrderbyReverse() { String[] words = { "cherry", "apple", "blueberry" }; List<String> sortedWords = Arrays.stream(words).sorted().collect( collectingAndThen(toList(),l->{Collections.reverse(l);return l;})); return sortedWords; }
public List<Pair<String, String>> customerRegionAndCountry() { List<Customer> customers = getCustomerList(); List<Pair<String, String>> customerProperties = customers.stream().map(c -> Pair.with(c.getRegion(), c.getCountry())).toList(); return customerProperties; }
public boolean categoryProductAllMatch() { List<Product> products = getProductList(); boolean allMatch = products.stream().filter(p -> p.getCategory() == "Beverages").allMatch(p -> p.getUnitsInStock() > 0); return allMatch; }
public List<Integer> stringLengthSkip() { String[] words = {"cherry", "apple", "blueberry", "banana", "abacus"}; List<Integer> after3Words = Arrays.stream(words).map(w -> w.length()).skip(3).toList(); return after3Words; }
public List<Pair<Boolean, List<String>>> stringGroupByLengthOrderbyDescendingLengthCustom() { String[] words = {"aPPLE", "AbAcUs", "bRaNcH", "BlUeBeRrY", "ClOvEr", "cHeRry"}; List<Pair<Boolean, List<String>>> wordsGroups = Arrays.stream(words).collect(groupingBy(w -> w.length() > 8)) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().sorted( Comparator.comparing(w -> w.length(), new CustomNumberComparer().reversed())).toList())).toList(); return wordsGroups; }
public double numbersAverage() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; double averageNum = Arrays.stream(numbers).average().getAsDouble(); return averageNum; }
public List<Order> customerOrdersSkipWhile() { List<Customer> customers = getCustomerList(); List<Order> after3Orders = customers.stream().flatMap(c -> c.getOrders().stream()) .dropWhile(o -> o.getOrderDate().isAfter(LocalDate.of(2000, 1, 1))).toList(); return after3Orders; }
public List<Pair<String, List<Customer>>> customerEachRegionOrdersMinCustomer() { List<Customer> customers = getCustomerList(); List<Pair<String, List<Customer>>> customerOrdersMin = customers.stream().collect(groupingBy(c -> c.getRegion())) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream(). collect(groupingBy(c -> c.getOrders().size())).entrySet() .stream().min(Map.Entry.comparingByKey()).get().getValue())).toList(); return customerOrdersMin; }
public List<Pair<String, List<Product>>> productEachCategoryMinUnitPriceProducts() { List<Product> products = getProductList(); List<Pair<String, List<Product>>> categories = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().collect(groupingBy(p -> p.getUnitPrice())) .entrySet().stream().min(Map.Entry.comparingByKey()).get().getValue())).toList(); return categories; }
public double expensiveProductStockAverage() { List<Product> products = getProductList(); double averageUnitPrice = products.stream().filter(p -> p.getUnitPrice() > 100) .mapToInt(p -> p.getUnitsInStock()).average().getAsDouble(); return averageUnitPrice; }
public double oddNumbersAverageTwice() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; double averageNum = Arrays.stream(numbers).filter(n -> n % 2 == 0).map(n -> n * 2).average().getAsDouble(); return averageNum; }
public List<String> productNameOrderbyDescending() { List<Product> products = getProductList(); List<String> sortedProducts = products.stream().map(p -> p.getProductName()) .sorted(Comparator.reverseOrder()).toList(); return sortedProducts; }
