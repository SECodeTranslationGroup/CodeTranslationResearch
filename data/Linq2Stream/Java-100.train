public int numbersFirstOrDefaultOrDefault() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int firstNum = Arrays.stream(numbers).findFirst().orElse(-1); return firstNum; }
public int[] oddFactorOf300And900Count() { int[][] factorsOf300And900 = { {2, 2, 3, 5, 5}, {2, 2, 3, 3, 5, 5} }; int[] factorsCount = Arrays.stream(factorsOf300And900) .mapToInt(a -> (int) Arrays.stream(a).filter(n -> n % 2 == 1).count()).toArray(); return factorsCount; }
public List<String> stringOrderbyDescendingCustom() { String[] words = {"aPPLE", "AbAcUs", "bRaNcH", "BlUeBeRrY", "ClOvEr", "cHeRry"}; List<String> sortedWords = Arrays.stream(words).sorted(new CaseInsensitiveComparer().reversed()).toList(); return sortedWords; }
public List<Pair<String, Double>> customerExpensiveOrdersTotalAverage() { List<Customer> customers = getCustomerList(); List<Pair<String, Double>> ordersTotalAverage = customers.stream().map(c -> Pair.with(c.getCustomerId(), c.getOrders().stream().filter(o -> o.getTotal() > 100) .mapToDouble(o -> o.getTotal()).average().getAsDouble())).toList(); return ordersTotalAverage; }
public List<Pair<String, String>> productCrossGroupJoinCategoriesName() { String[] categories = {"Beverages", "Condiments", "Vegetables", "Dairy Products", "Seafood"}; List<Product> products = getProductList(); List<Pair<String, String>> q = Arrays.stream(categories).map( c -> Pair.with(c, products.stream().filter(p -> p.getCategory().equals(c)) .collect(Collectors.toList()))).flatMap(t -> t.getValue1().stream() .map(p1 -> Pair.with(t.getValue0(), p1.getProductName()))).toList(); return q; }
public Pair<Integer, Integer>[] selectManyJoinSumEven() { int[] numbersA = {0, 2, 4, 5, 6, 8, 9}; int[] numbersB = {1, 3, 5, 7, 8}; Pair<Integer, Integer>[] pairs = (Pair<Integer, Integer>[]) Arrays.stream(numbersA).boxed().flatMap(a -> Arrays.stream(numbersB) .filter(b -> (a + b) % 2 == 0).mapToObj(b -> Pair.with(a, b))).toArray(); return pairs; }
public void numbersEager() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; AtomicInteger i = new AtomicInteger(0); var q = Arrays.stream(numbers).map(n -> i.addAndGet(n)).boxed().toList(); for (var v : q) System.out.println(v + " " + i); }
public int[] shortStringLength() { String[] strings = {"zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"}; int[] selected = Arrays.stream(strings).filter(w -> w.length() < 4).mapToInt(w -> w.length()).toArray(); return selected; }
public int distinctOrdersCount(String region) { List<Customer> customers = getCustomerList(); int count = (int) customers.stream().flatMap(c -> c.getOrders().stream()).distinct().count(); return count; }
public Map<String, Double> customerInRegionOrdersTotalMinDict(String region) { List<Customer> customers = getCustomerList(); Map<String, Double> ordersTotalMin = customers.stream().filter(c -> c.getRegion().equals(region)) .collect(toMap(c -> c.getCustomerId(), c -> c.getOrders().stream().mapToDouble(o -> o.getTotal()).min().getAsDouble())); return ordersTotalMin; }
public Map<String, List<Customer>> customerEachRegionOrdersMinCustomerDict() { List<Customer> customers = getCustomerList(); Map<String, List<Customer>> customerOrdersMin = customers.stream().collect(groupingBy(c -> c.getRegion())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream(). collect(groupingBy(c -> c.getOrders().size())).entrySet() .stream().min(Map.Entry.comparingByKey()).get().getValue())); return customerOrdersMin; }
public List<Double> bigDoubleOrderbyFraction() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; List<Double> sortedNumbers = Arrays.stream(numbers).filter(n -> n > 5).boxed().sorted(Comparator.comparing(n -> n - (int) n.doubleValue())).toList(); return sortedNumbers; }
public List<Product> productOrderbyDescendingId() { List<Product> products = getProductList(); List<Product> sortedProducts = products.stream().sorted( Comparator.comparing(p -> p.getProductId(), Comparator.reverseOrder())).toList(); return sortedProducts; }
public int[] oddIntAddOriginalIndex() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int[] numSelected = IntStream.range(0, numbers.length).filter(i -> numbers[i] % 2 == 1).map(i -> numbers[i] + i).toArray(); return numSelected; }
public List<String> stringSkipWhileCount(char c) { String[] words = {"cherry", "apple", "blueberry", "banana", "abacus"}; List<String> afterNWords = Arrays.stream(words).dropWhile(w -> w.charAt(0) > c).toList(); return afterNWords; }
public List<Integer> rangeOfInts() { List<Integer> numbers = IntStream.range(0, 50).boxed().toList(); return numbers; }
public List<Integer> rangeOfEvenIntsStartFrom(int start,int count) { List<Integer> numbers = IntStream.range(start, start+count).filter(n->n%2==0).boxed().toList(); return numbers; }
public List<Product> expensiveProductOrderbyCategoryThenbyName() { List<Product> products = getProductList(); List<Product> sortedProducts = products.stream().filter(p->p.getUnitPrice()>100) .sorted(Comparator.comparing((Product p) -> p.getCategory()) .thenComparing(p -> p.getProductName())).toList(); return sortedProducts; }
public int[] bigIntAddOriginalIndex() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int[] numSelected = IntStream.range(0, numbers.length).filter(i -> numbers[i] > 5).filter(i -> numbers[i] % 2 == 1).map(i -> numbers[i] + i).toArray(); return numSelected; }
public List<Integer> rangeOfEvenInts() { List<Integer> numbers = IntStream.range(0, 50).filter(n->n%2==0).boxed().toList(); return numbers; }
public List<Pair<Integer, String>> customerCrossGroupJoinRegionsWithCodeName() { List<Pair<String, Integer>> regions = Arrays.asList( Pair.with("BC", 101), Pair.with("BC", 105), Pair.with("OR", 121), Pair.with("LA", 143) ); List<Customer> customers = getCustomerList(); List<Pair<Integer, String>> q = regions.stream().map( r -> Pair.with(r.getValue1(), customers.stream().filter(c -> c.getRegion().equals(r)) .collect(Collectors.toList()))).flatMap(t -> t.getValue1().stream() .map(c1 -> Pair.with(t.getValue0(), c1.getCompanyName()))).toList(); return q; }
public List<Integer> shortStringLengthOrderbyCustom() { String[] words = {"aPPLE", "AbAcUs", "bRaNcH", "BlUeBeRrY", "ClOvEr", "cHeRry"}; List<Integer> sortedWords = Arrays.stream(words).filter(w -> w.length() < 6).map(w -> w.length()). sorted(new CustomNumberComparer()).toList(); return sortedWords; }
public Map<Boolean, List<Double>> doubleGroupByBoolDictOrderbyDescending() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; Map<Boolean, List<Double>> numbersGroups = Arrays.stream(numbers).boxed().collect(groupingBy(n -> n > 5)) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().sorted(Comparator.reverseOrder()).toList())); return numbersGroups; }
public List<Integer> rangeOfIntsWithStartAndCount(int start,int count) { List<Integer> numbers = IntStream.range(start, start+count).boxed().toList(); return numbers; }
public List<String> intersectOfCategory() { String[] categories = {"Furnitures", "Seagoods"}; List<Product> products = getProductList(); var productCategories = products.stream().map(p -> p.getCategory()); List<String> sharedCategories = productCategories.distinct().filter(a -> Arrays.stream(categories).anyMatch(b -> b.equals(a))).toList(); return sharedCategories; }
public Product productFirst() { List<Product> products = getProductList(); Product product12 = products.stream().filter(p -> p.getProductId() == 12).findFirst().get(); return product12; }
public double doubleFirstOrDefault() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; double firstNum = Arrays.stream(numbers).findFirst().orElse(3.14); return firstNum; }
public boolean equalStrings() { List<String> wordsA = Arrays.asList("Alpha", "Beta", "Gamma"); List<String> wordsB = Arrays.asList("Alpha", "Beta", "Gamma"); boolean equal = wordsA.equals(wordsB); return equal; }
public List<Product> repeatedProductsWithCount(int count) { List<Product> products = Collections.nCopies(count,Product.DEFAULT); return products; }
public Map<Boolean, List<Product>> productGroupByPriceDict() { List<Product> products = getProductList(); Map<Boolean, List<Product>> productGroup = products.stream().collect(groupingBy(p -> p.getUnitPrice() > 100)); return productGroup; }
public Map<String, Integer> productEachCategoryStockDict() { List<Product> products = getProductList(); Map<String, Integer> categories = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().mapToInt(p -> p.getUnitsInStock()).sum())); return categories; }
public Product[] productsConvertToArray() { List<Product> products = getProductList(); Product[] productsArray = (Product[]) products.stream().sorted(Comparator.comparing( p -> p.getUnitPrice())).toArray(); return productsArray; }
public Map<String, Integer> productEachCategoryStockDict() { List<Product> products = getProductList(); Map<String, Integer> categories = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().mapToInt(p -> p.getUnitsInStock()).min().getAsInt())); return categories; }
public List<Pair<String, Double>> customerOrdersTotalMin() { List<Customer> customers = getCustomerList(); List<Pair<String, Double>> ordersTotalMin = customers.stream().map(c -> Pair.with(c.getCustomerId(), c.getOrders().stream().mapToDouble(o -> o.getTotal()).min().getAsDouble())).toList(); return ordersTotalMin; }
public List<Product> productsConvertToDescendingListAndPrintForeach() { List<Product> products = getProductList(); List<Product> productsList = products.stream().sorted(Comparator.comparing( p -> p.getUnitPrice(), Comparator.reverseOrder())).toList(); for (Product p : productsList) System.out.println(p); return productsList; }
public List<Pair<Character, List<String>>> stringGroupByFirstCharOrderbyDescendingCustom() { String[] words = {"aPPLE", "AbAcUs", "bRaNcH", "BlUeBeRrY", "ClOvEr", "cHeRry"}; List<Pair<Character, List<String>>> wordsGroups = Arrays.stream(words).collect(groupingBy(w -> Character.toLowerCase(w.charAt(0)))) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().sorted(new CaseInsensitiveComparer().reversed()).toList())).toList(); return wordsGroups; }
public double bigNumbersAggregateMultiply() { double[] numbers = {1.7, 2.3, 1.9, 4.1, 2.9}; double product = Arrays.stream(numbers).filter(n -> n > 2).reduce((a, b) -> a * b).getAsDouble(); return product; }
public List<Pair<String, Double>> customerEachRegionOrdersTotalMax() { List<Customer> customers = getCustomerList(); List<Pair<String, Double>> ordersTotalMax = customers.stream().collect(groupingBy(c -> c.getRegion())) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().flatMap(c -> c.getOrders().stream()).mapToDouble(o -> o.getTotal()).max().getAsDouble())).toList(); return ordersTotalMax; }
public List<Integer> intTake() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; List<Integer> after3Numbers = Arrays.stream(numbers).limit(3).boxed().toList(); return after3Numbers; }
public double doubleAverage() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; double averageNum = Arrays.stream(numbers).average().getAsDouble(); return averageNum; }
public void bigNumbersTwiceEager() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; AtomicInteger i = new AtomicInteger(0); var q = Arrays.stream(numbers).filter(n->n>5).map(n->n*2).map(n -> i.addAndGet(n)).boxed().toList(); for (var v : q) System.out.println(v + " " + i); }
public List<String> stringReverse() { String[] words = { "cherry", "apple", "blueberry" }; List<String> sortedWords = Arrays.stream(words).collect( collectingAndThen(toList(),l->{Collections.reverse(l);return l;})); return sortedWords; }
public List<String> unionOfName() { List<Product> products = getProductList(); List<Customer> customers = getCustomerList(); var productNames = products.stream().map(p -> p.getProductName()); var customerNames = customers.stream().map(c -> c.getCompanyName()); List<String> uniqueNames = Stream.concat(productNames, customerNames).distinct().toList(); return uniqueNames; }
public Map<String, Double> customerOrdersTotalAverageDict() { List<Customer> customers = getCustomerList(); Map<String, Double> ordersTotalAverage = customers.stream().collect(toMap(c -> c.getCustomerId(), c -> c.getOrders().stream().mapToDouble(o -> o.getTotal()).average().getAsDouble())); return ordersTotalAverage; }
public List<Triplet<String, Integer, Integer>> customerSelectManyCustomerOrderDateYearAndMonth() { List<Customer> customers = getCustomerList(); List<Triplet<String, Integer, Integer>> customerProperties = customers.stream().flatMap(c -> c.getOrders() .stream().map(o -> Triplet.with(c.getCustomerId(), o.getOrderDate().getYear(), o.getOrderDate().getMonthValue()))).toList(); return customerProperties; }
public List<Pair<String, List<Product>>> productEachCategoryFirstOrDefaultUnitPriceProducts() { List<Product> products = getProductList(); List<Pair<String, List<Product>>> categories = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().filter(p -> p.getUnitPrice() == g.getValue().stream().findFirst().orElse(Product.DEFAULT).getUnitPrice()).toList())).toList(); return categories; }
public Pair<Integer, Integer>[] selectManyJoin() { int[] numbersA = {0, 2, 4, 5, 6, 8, 9}; int[] numbersB = {1, 3, 5, 7, 8}; Pair<Integer, Integer>[] pairs = (Pair<Integer, Integer>[]) Arrays.stream(numbersA).boxed().flatMap( a -> Arrays.stream(numbersB).mapToObj(b -> Pair.with(a, b))).toArray(); return pairs; }
public List<String> stringOrderbyCustomThenbyLengthCustom() { String[] words = {"aPPLE", "AbAcUs", "bRaNcH", "BlUeBeRrY", "ClOvEr", "cHeRry"}; List<String> sortedWords = Arrays.stream(words) .sorted(Comparator.comparing((String w) -> w,new CaseInsensitiveComparer()) .thenComparing(w -> w.length(),new CustomNumberComparer())).toList(); return sortedWords; }
public List<Pair<String, Integer>> customerIdAndOrdersCount() { List<Customer> customers = getCustomerList(); List<Pair<String, Integer>> customerProperties = customers.stream().map(c -> Pair.with(c.getCustomerId(), c.getOrders().size())).toList(); return customerProperties; }
public double[] doublesConvertToDescendingArray() { double[] doubles = {1.7, 2.3, 1.9, 4.1, 2.9}; double[] doublesArray = Arrays.stream(doubles).boxed().sorted(Comparator.reverseOrder()).mapToDouble(d -> d).toArray(); return doublesArray; }
public void doubleDeferred() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; AtomicReference<Double> d = new AtomicReference<>(0.0); var q = Arrays.stream(numbers).map(n -> d.accumulateAndGet(n, Double::sum)); q.forEach(v -> System.out.println(v + " " + d)); }
public List<Pair<String, Integer>> customerEachRegionOrdersMax() { List<Customer> customers = getCustomerList(); List<Pair<String, Integer>> ordersMax = customers.stream().collect(groupingBy(c -> c.getRegion())) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().mapToInt(c -> c.getOrders().size()).max().getAsInt())).toList(); return ordersMax; }
public List<String> expensiveProductName() { List<Product> products = getProductList(); List<String> productNames = products.stream().filter(p -> p.getUnitPrice() > 100).map(p -> p.getProductName()).toList(); return productNames; }
public List<Double> doublesConvertToDescendingList() { double[] doubles = {1.7, 2.3, 1.9, 4.1, 2.9}; List<Double> doublesList = Arrays.stream(doubles).boxed(). sorted(Comparator.reverseOrder()).toList(); return doublesList; }
public List<Product> productTake() { List<Product> products = getProductList(); List<Product> after3Products = products.stream().limit(3).toList(); return after3Products; }
public List<Double> intSqrtTakeWhileIndexed() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; List<Double> afterNumbers =  IntStream.range(0, numbers.length) .takeWhile(i -> Math.sqrt(numbers[i]) > i).mapToDouble(i -> Math.sqrt(numbers[i]) ).boxed().toList(); return afterNumbers; }
public List<Double> doublesConvertToListAndPrint() { double[] doubles = {1.7, 2.3, 1.9, 4.1, 2.9}; List<Double> doublesList = Arrays.stream(doubles).boxed(). sorted().toList(); for (int i = 0; i < doublesList.size(); i++) System.out.println(doublesList.get(i)); return doublesList; }
public double productUnitPriceAggregateAverage() { List<Product> products = getProductList(); double aggregateSum = products.stream().map(p -> p.getUnitPrice()).reduce((a, b) ->(a + b) / 2).get(); return aggregateSum; }
public int oddNumbersFirstOrDefault() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int firstNum = Arrays.stream(numbers).filter(n -> n % 2 == 1).findFirst().orElse(-2); return firstNum; }
public List<Pair<String, Customer>> customerCrossGroupJoinRegions() { String[] regions = {"BC", "SP", "OR", "LA"}; List<Customer> customers = getCustomerList(); List<Pair<String, Customer>> q = Arrays.stream(regions).map( r -> Pair.with(r, customers.stream().filter(c -> c.getRegion().equals(r)) .collect(Collectors.toList()))).flatMap(t -> t.getValue1().stream() .map(c1 -> Pair.with(t.getValue0(), c1))).toList(); return q; }
public Map<String, Integer> customerEachRegionOrdersSumDict() { List<Customer> customers = getCustomerList(); Map<String, Integer> ordersSum = customers.stream().collect(groupingBy(c -> c.getRegion())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().mapToInt(c -> c.getOrders().size()).sum())); return ordersSum; }
public double bigDoubleNumbersFirstOrDefault() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; double firstNum = Arrays.stream(numbers).filter(d -> d > 5).findFirst().orElse(-2.3); return firstNum; }
public List<Integer> repeatedIntsWithCount(int count) { List<Integer> numbers = Collections.nCopies(count, 0); return numbers; }
public List<String> stringOrderbyLengthCustomThenby() { String[] words = {"cherry", "apple", "blueberry", "banana", "abacus"}; List<String> sortedWords =  Arrays.stream(words).sorted(Comparator.comparing((String w) -> w.length(), new CustomNumberComparer()).thenComparing(Comparator.naturalOrder())).toList(); return sortedWords; }
public List<String> intersectOfName() { List<Product> products = getProductList(); List<Customer> customers = getCustomerList(); var productNames = products.stream().map(p -> p.getProductName()); var customerNames = customers.stream().map(c -> c.getCompanyName()); List<String> sharedNames = productNames.distinct().filter(a -> customerNames.anyMatch(b -> b.equals(a))).toList(); return sharedNames; }
public List<String> concatOfRegion() { String[] regions = {"WA", "AF", "RO"}; List<Customer> customers = getCustomerList(); var customerRegions = customers.stream().map(c -> c.getRegion()); List<String> allRegions = Stream.concat(customerRegions, Arrays.stream(regions)).toList(); return allRegions; }
public List<Pair<String, LocalDate>> waCustomerSelectManyCustomerNewOrderDates() { List<Customer> customers = getCustomerList(); List<Pair<String, LocalDate>> customerProperties = customers.stream().filter(c -> c.getRegion().equals("WA")).flatMap(c -> c.getOrders() .stream().filter(o -> o.getOrderDate().isAfter(LocalDate.of(1998, 1, 1))) .map(o -> Pair.with(c.getCustomerId(), o.getOrderDate()))).toList(); return customerProperties; }
public List<Pair<String, LocalDate>> waCustomerOrdersEachNestedSkipWhile() { List<Customer> customers = getCustomerList(); List<Pair<String, LocalDate>> after3EachWAOrders = customers.stream().filter(c -> c.getRegion().equals("WA")) .flatMap(c -> c.getOrders().stream().dropWhile(o -> o.getOrderDate() .isAfter(LocalDate.of(2000, 1, 1))) .map(o -> Pair.with(c.getCustomerId(), o.getOrderDate()))).toList(); return after3EachWAOrders; }
public List<Pair<String, Integer>> customerEachCountryOrdersMax() { List<Customer> customers = getCustomerList(); List<Pair<String, Integer>> ordersMax = customers.stream().collect(groupingBy(c -> c.getCountry())) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().mapToInt(c -> c.getOrders().size()).max().getAsInt())).toList(); return ordersMax; }
public List<Product> repeatedProducts() { List<Product> products = Collections.nCopies(30,Product.DEFAULT); return products; }
public List<Pair<String, Integer>> customerDistinctOrdersCount() { List<Customer> customers = getCustomerList(); List<Pair<String, Integer>> orderCounts = customers.stream().map(c -> Pair.with(c.getCustomerId(), (int) c.getOrders().stream().distinct().count())).toList(); return orderCounts; }
public List<Integer> stringLengthOrderbyDescendingCustom() { String[] words = {"aPPLE", "AbAcUs", "bRaNcH", "BlUeBeRrY", "ClOvEr", "cHeRry"}; List<Integer> sortedWords = Arrays.stream(words).map(w -> w.length()).sorted(new CustomNumberComparer().reversed()).toList(); return sortedWords; }
public int oddNumbersMinTwice() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int minNum = Arrays.stream(numbers).filter(n -> n % 2 == 0).map(n -> n * 2).min().getAsInt(); return minNum; }
public List<Integer> rangeOfSquareInts() { List<Integer> numbers = IntStream.range(0, 50).map(n->n*n).boxed().toList(); return numbers; }
public List<Pair<String, Integer>> expensiveProductEachCategoryStock() { List<Product> products = getProductList(); List<Pair<String, Integer>> categories = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().filter( p -> p.getUnitPrice() > 100).mapToInt(p -> p.getUnitsInStock()).sum())).toList(); return categories; }
public Map<Boolean, List<Integer>> productGroupByPriceWithIdDict() { List<Product> products = getProductList(); Map<Boolean, List<Integer>> productGroup = products.stream().collect(groupingBy(p -> p.getUnitPrice() > 100)) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().map(p -> p.getProductId()).toList())); return productGroup; }
public List<String> stringIndexedWhere() { String[] words = {"cherry", "apple", "blueberry", "banana", "abacus"}; IntStream.range(0, words.length).filter(i -> words[i].length() < i).mapToObj(i -> words[i]).toList(); List<String> q = IntStream.range(0, words.length).filter(i -> words[i].length() < i).mapToObj(i -> words[i]).toList(); return q; }
public Map<Double, Double> convertArrayToDictionary() { double[] doubles = {1.7, 2.3, 1.9, 4.1, 2.9}; Map<Double, Double> doublesDict = Arrays.stream(doubles).boxed().collect(toMap( sr -> sr, sr -> sr*2)); return doublesDict; }
public List<Integer> intsConvertToListAndPrintForeach() { int[] ints = {2, 3, 1, 5, 4}; List<Integer> intsList = Arrays.stream(ints).boxed().sorted().toList(); for (int i : intsList) System.out.println(i); return intsList; }
public List<String> shortStringOrderbyLengthReverse() { String[] words = { "cherry", "apple", "blueberry", "pear", "peach", "melon" }; List<String> sortedWords = Arrays.stream(words).filter(w -> w.length() < 6) .sorted(Comparator.comparing(w->w.length())).collect( collectingAndThen(toList(),l->{Collections.reverse(l);return l;})); return sortedWords; }
public double[] doublesConvertToArrayAndPrint() { double[] doubles = {1.7, 2.3, 1.9, 4.1, 2.9}; double[] doublesArray = Arrays.stream(doubles).sorted().toArray(); for (int i = 0; i < doublesArray.length; i++) System.out.println(doublesArray[i]); return doublesArray; }
public Map<Integer, List<Customer>> customerGroupJoinRegionsWithCode() { List<Pair<String, Integer>> regions = Arrays.asList( Pair.with("BC", 101), Pair.with("BC", 105), Pair.with("OR", 121), Pair.with("LA", 143) ); List<Customer> customers = getCustomerList(); Map<Integer, List<Customer>> q = regions.stream().map(r -> Pair.with(r.getValue1(), customers.stream() .filter(c -> c.getRegion().equals(r.getValue0())).toList())).collect(toMap(t->t.getValue0(),t->t.getValue1())); return q; }
public Map<String, List<Product>> expensiveProductEachCategoryMinUnitPriceProductsDict() { List<Product> products = getProductList(); Map<String, List<Product>> categories = products.stream().filter(p -> p.getUnitPrice() > 100).collect( groupingBy(p -> p.getCategory())).entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().collect(groupingBy(p -> p.getUnitPrice())) .entrySet().stream().min(Map.Entry.comparingByKey()).get().getValue())); return categories; }
public Map<String, List<Product>> productGroupTakeWhile() { List<Product> products = getProductList(); Map<String, List<Product>> after3Groups = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().takeWhile(g -> g.getKey().length() > 6).collect(toMap(g -> g.getKey(), g -> g.getValue())); return after3Groups; }
public List<Double> bigDoubleFractionOrderbyDescending() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; List<Double> sortedNumbers = Arrays.stream(numbers).filter(n -> n > 5).map(n -> n - (int) n).boxed() .sorted(Comparator.reverseOrder()).toList(); return sortedNumbers; }
public int productOutOfStock() { List<Product> products = getProductList(); int count = (int) products.stream().filter(c -> c.getUnitsInStock() == 0).count(); return count; }
public Map<String, Boolean> expensiveProductEachGroupAllMatch() { List<Product> products = getProductList(); Map<String, Boolean> allMatch = products.stream().filter(p -> p.getUnitPrice() > 100).collect(groupingBy(p -> p.getCategory())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().allMatch(p -> p.getUnitsInStock() > 0))); return allMatch; }
public List<Double> doubleOrderbyModDescendingThenbyDescending() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; List<Double> sortedNumbers = Arrays.stream(numbers).boxed().sorted( Comparator.comparing((Double n) -> n % 1.5,Comparator.reverseOrder()) .thenComparing(Comparator.reverseOrder())).toList(); return sortedNumbers; }
public List<String> longStringTake() { String[] words = {"cherry", "apple", "blueberry", "banana", "abacus"}; List<String> after3Words = Arrays.stream(words).filter(w -> w.length() > 5).limit(3).toList(); return after3Words; }
public Map<String, List<Product>> expensiveProductEachCategoryMaxUnitPriceProductsDict() { List<Product> products = getProductList(); Map<String, List<Product>> categories = products.stream().filter(p -> p.getUnitPrice() > 100).collect( groupingBy(p -> p.getCategory())).entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().collect(groupingBy(p -> p.getUnitPrice())) .entrySet().stream().max(Map.Entry.comparingByKey()).get().getValue())); return categories; }
public List<Pair<String, String>> customerCrossJoinRegionsPhone() { String[] regions = {"BC", "SP", "OR", "LA"}; List<Customer> customers = getCustomerList(); List<Pair<String, String>> q = Arrays.stream(regions).flatMap( r -> customers.stream().filter(c -> c.getRegion().equals(r)).map( c -> Pair.with(r, c.getPhone()))).toList(); return q; }
public Map<String, Map<Integer, Map<Integer, List<Order>>>> customerNestedGroupByNameAndOrderYearAndMonth() { List<Customer> customers = getCustomerList(); Map<String, Map<Integer, Map<Integer, List<Order>>>> customerOrderGroups = customers.stream().collect(toMap( c -> c.getCompanyName(), c -> c.getOrders().stream().collect(groupingBy(o -> o.getOrderDate().getYear())).entrySet().stream().collect(toMap( g -> g.getKey(), g -> g.getValue().stream().collect(groupingBy( o -> o.getOrderDate().getMonthValue() )))))); return customerOrderGroups; }
public Boolean[] bigIntWithOriginalIndex() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; Boolean[] numSelected = (Boolean[]) IntStream.range(0, numbers.length).filter(i -> numbers[i] > 5).filter(i -> numbers[i] % 2 == 1) .mapToObj(i -> numbers[i] == i).toArray(); return numSelected; }
public double expensiveProductStockAverage() { List<Product> products = getProductList(); double averageUnitPrice = products.stream().filter(p -> p.getUnitPrice() > 100) .mapToInt(p -> p.getUnitsInStock()).average().getAsDouble(); return averageUnitPrice; }
public List<Pair<String, LocalDate>> customerOrdersEachNestedSkipWhile() { List<Customer> customers = getCustomerList(); List<Pair<String, LocalDate>> after3EachOrders = customers.stream().flatMap(c -> c.getOrders().stream() .dropWhile(o -> o.getOrderDate().isAfter(LocalDate.of(2000, 1, 1))) .map(o -> Pair.with(c.getCustomerId(), o.getOrderDate()))).toList(); return after3EachOrders; }
public List<String> exceptOfRegion() { String[] regions = {"WA", "AF", "RO"}; List<Customer> customers = getCustomerList(); var customerRegions = customers.stream().map(c -> c.getRegion()); List<String> differemtRegions = customerRegions.distinct().filter(a -> Arrays.stream(regions).allMatch(b -> !b.equals(a))).toList(); return differemtRegions; }
public List<String> stringOrderbyDescending() { String[] words = {"cherry", "apple", "blueberry"}; List<String> sortedWords = Arrays.stream(words).sorted(Comparator.reverseOrder()).toList(); return sortedWords; }
public List<Character> concatOfNameFirstChar() { List<Product> products = getProductList(); List<Customer> customers = getCustomerList(); var productFirstChars = products.stream().map(p -> p.getProductName().charAt(0)); var customerFirstChars = customers.stream().map(c -> c.getCompanyName().charAt(0)); List<Character> allFirstChars = Stream.concat(productFirstChars, customerFirstChars).toList(); return allFirstChars; }
public Map<String, Product> productEachCategoryFirstDict() { List<Product> products = getProductList(); Map<String, Product> categories = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().findFirst().get())); return categories; }
public double bigDoubleNumbersFirst() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; double firstNum = Arrays.stream(numbers).filter(d -> d > 5).findFirst().getAsDouble(); return firstNum; }
