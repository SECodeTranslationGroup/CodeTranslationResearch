public int numbersFirstOrDefaultOrDefault() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int firstNum = Arrays.stream(numbers).findFirst().orElse(-1); return firstNum; }
public int[] oddFactorOf300And900Count() { int[][] factorsOf300And900 = { {2, 2, 3, 5, 5}, {2, 2, 3, 3, 5, 5} }; int[] factorsCount = Arrays.stream(factorsOf300And900) .mapToInt(a -> (int) Arrays.stream(a).filter(n -> n % 2 == 1).count()).toArray(); return factorsCount; }
public List<String> stringOrderbyDescendingCustom() { String[] words = {"aPPLE", "AbAcUs", "bRaNcH", "BlUeBeRrY", "ClOvEr", "cHeRry"}; List<String> sortedWords = Arrays.stream(words).sorted(new CaseInsensitiveComparer().reversed()).toList(); return sortedWords; }
public List<Pair<String, Double>> customerExpensiveOrdersTotalAverage() { List<Customer> customers = getCustomerList(); List<Pair<String, Double>> ordersTotalAverage = customers.stream().map(c -> Pair.with(c.getCustomerId(), c.getOrders().stream().filter(o -> o.getTotal() > 100) .mapToDouble(o -> o.getTotal()).average().getAsDouble())).toList(); return ordersTotalAverage; }
public List<Pair<String, String>> productCrossGroupJoinCategoriesName() { String[] categories = {"Beverages", "Condiments", "Vegetables", "Dairy Products", "Seafood"}; List<Product> products = getProductList(); List<Pair<String, String>> q = Arrays.stream(categories).map( c -> Pair.with(c, products.stream().filter(p -> p.getCategory().equals(c)) .collect(Collectors.toList()))).flatMap(t -> t.getValue1().stream() .map(p1 -> Pair.with(t.getValue0(), p1.getProductName()))).toList(); return q; }
public Pair<Integer, Integer>[] selectManyJoinSumEven() { int[] numbersA = {0, 2, 4, 5, 6, 8, 9}; int[] numbersB = {1, 3, 5, 7, 8}; Pair<Integer, Integer>[] pairs = (Pair<Integer, Integer>[]) Arrays.stream(numbersA).boxed().flatMap(a -> Arrays.stream(numbersB) .filter(b -> (a + b) % 2 == 0).mapToObj(b -> Pair.with(a, b))).toArray(); return pairs; }
public void numbersEager() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; AtomicInteger i = new AtomicInteger(0); var q = Arrays.stream(numbers).map(n -> i.addAndGet(n)).boxed().toList(); for (var v : q) System.out.println(v + " " + i); }
public int[] shortStringLength() { String[] strings = {"zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"}; int[] selected = Arrays.stream(strings).filter(w -> w.length() < 4).mapToInt(w -> w.length()).toArray(); return selected; }
public int distinctOrdersCount(String region) { List<Customer> customers = getCustomerList(); int count = (int) customers.stream().flatMap(c -> c.getOrders().stream()).distinct().count(); return count; }
public Map<String, Double> customerInRegionOrdersTotalMinDict(String region) { List<Customer> customers = getCustomerList(); Map<String, Double> ordersTotalMin = customers.stream().filter(c -> c.getRegion().equals(region)) .collect(toMap(c -> c.getCustomerId(), c -> c.getOrders().stream().mapToDouble(o -> o.getTotal()).min().getAsDouble())); return ordersTotalMin; }
public Map<String, List<Customer>> customerEachRegionOrdersMinCustomerDict() { List<Customer> customers = getCustomerList(); Map<String, List<Customer>> customerOrdersMin = customers.stream().collect(groupingBy(c -> c.getRegion())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream(). collect(groupingBy(c -> c.getOrders().size())).entrySet() .stream().min(Map.Entry.comparingByKey()).get().getValue())); return customerOrdersMin; }
public List<Double> bigDoubleOrderbyFraction() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; List<Double> sortedNumbers = Arrays.stream(numbers).filter(n -> n > 5).boxed().sorted(Comparator.comparing(n -> n - (int) n.doubleValue())).toList(); return sortedNumbers; }
public List<Product> productOrderbyDescendingId() { List<Product> products = getProductList(); List<Product> sortedProducts = products.stream().sorted( Comparator.comparing(p -> p.getProductId(), Comparator.reverseOrder())).toList(); return sortedProducts; }
public int[] oddIntAddOriginalIndex() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int[] numSelected = IntStream.range(0, numbers.length).filter(i -> numbers[i] % 2 == 1).map(i -> numbers[i] + i).toArray(); return numSelected; }
public List<String> stringSkipWhileCount(char c) { String[] words = {"cherry", "apple", "blueberry", "banana", "abacus"}; List<String> afterNWords = Arrays.stream(words).dropWhile(w -> w.charAt(0) > c).toList(); return afterNWords; }
public List<Integer> rangeOfInts() { List<Integer> numbers = IntStream.range(0, 50).boxed().toList(); return numbers; }
public List<Integer> rangeOfEvenIntsStartFrom(int start,int count) { List<Integer> numbers = IntStream.range(start, start+count).filter(n->n%2==0).boxed().toList(); return numbers; }
public List<Product> expensiveProductOrderbyCategoryThenbyName() { List<Product> products = getProductList(); List<Product> sortedProducts = products.stream().filter(p->p.getUnitPrice()>100) .sorted(Comparator.comparing((Product p) -> p.getCategory()) .thenComparing(p -> p.getProductName())).toList(); return sortedProducts; }
public int[] bigIntAddOriginalIndex() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int[] numSelected = IntStream.range(0, numbers.length).filter(i -> numbers[i] > 5).filter(i -> numbers[i] % 2 == 1).map(i -> numbers[i] + i).toArray(); return numSelected; }
public List<Integer> rangeOfEvenInts() { List<Integer> numbers = IntStream.range(0, 50).filter(n->n%2==0).boxed().toList(); return numbers; }
public List<Pair<Integer, String>> customerCrossGroupJoinRegionsWithCodeName() { List<Pair<String, Integer>> regions = Arrays.asList( Pair.with("BC", 101), Pair.with("BC", 105), Pair.with("OR", 121), Pair.with("LA", 143) ); List<Customer> customers = getCustomerList(); List<Pair<Integer, String>> q = regions.stream().map( r -> Pair.with(r.getValue1(), customers.stream().filter(c -> c.getRegion().equals(r)) .collect(Collectors.toList()))).flatMap(t -> t.getValue1().stream() .map(c1 -> Pair.with(t.getValue0(), c1.getCompanyName()))).toList(); return q; }
public List<Integer> shortStringLengthOrderbyCustom() { String[] words = {"aPPLE", "AbAcUs", "bRaNcH", "BlUeBeRrY", "ClOvEr", "cHeRry"}; List<Integer> sortedWords = Arrays.stream(words).filter(w -> w.length() < 6).map(w -> w.length()). sorted(new CustomNumberComparer()).toList(); return sortedWords; }
public Map<Boolean, List<Double>> doubleGroupByBoolDictOrderbyDescending() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; Map<Boolean, List<Double>> numbersGroups = Arrays.stream(numbers).boxed().collect(groupingBy(n -> n > 5)) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().sorted(Comparator.reverseOrder()).toList())); return numbersGroups; }
public List<Integer> rangeOfIntsWithStartAndCount(int start,int count) { List<Integer> numbers = IntStream.range(start, start+count).boxed().toList(); return numbers; }
public List<String> intersectOfCategory() { String[] categories = {"Furnitures", "Seagoods"}; List<Product> products = getProductList(); var productCategories = products.stream().map(p -> p.getCategory()); List<String> sharedCategories = productCategories.distinct().filter(a -> Arrays.stream(categories).anyMatch(b -> b.equals(a))).toList(); return sharedCategories; }
public Product productFirst() { List<Product> products = getProductList(); Product product12 = products.stream().filter(p -> p.getProductId() == 12).findFirst().get(); return product12; }
public double doubleFirstOrDefault() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; double firstNum = Arrays.stream(numbers).findFirst().orElse(3.14); return firstNum; }
public boolean equalStrings() { List<String> wordsA = Arrays.asList("Alpha", "Beta", "Gamma"); List<String> wordsB = Arrays.asList("Alpha", "Beta", "Gamma"); boolean equal = wordsA.equals(wordsB); return equal; }
public List<Product> repeatedProductsWithCount(int count) { List<Product> products = Collections.nCopies(count,Product.DEFAULT); return products; }
public Map<Boolean, List<Product>> productGroupByPriceDict() { List<Product> products = getProductList(); Map<Boolean, List<Product>> productGroup = products.stream().collect(groupingBy(p -> p.getUnitPrice() > 100)); return productGroup; }
public Map<String, Integer> productEachCategoryStockDict() { List<Product> products = getProductList(); Map<String, Integer> categories = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().mapToInt(p -> p.getUnitsInStock()).sum())); return categories; }
public Product[] productsConvertToArray() { List<Product> products = getProductList(); Product[] productsArray = (Product[]) products.stream().sorted(Comparator.comparing( p -> p.getUnitPrice())).toArray(); return productsArray; }
public Map<String, Integer> productEachCategoryStockDict() { List<Product> products = getProductList(); Map<String, Integer> categories = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().mapToInt(p -> p.getUnitsInStock()).min().getAsInt())); return categories; }
public List<Pair<String, Double>> customerOrdersTotalMin() { List<Customer> customers = getCustomerList(); List<Pair<String, Double>> ordersTotalMin = customers.stream().map(c -> Pair.with(c.getCustomerId(), c.getOrders().stream().mapToDouble(o -> o.getTotal()).min().getAsDouble())).toList(); return ordersTotalMin; }
public List<Product> productsConvertToDescendingListAndPrintForeach() { List<Product> products = getProductList(); List<Product> productsList = products.stream().sorted(Comparator.comparing( p -> p.getUnitPrice(), Comparator.reverseOrder())).toList(); for (Product p : productsList) System.out.println(p); return productsList; }
public List<Pair<Character, List<String>>> stringGroupByFirstCharOrderbyDescendingCustom() { String[] words = {"aPPLE", "AbAcUs", "bRaNcH", "BlUeBeRrY", "ClOvEr", "cHeRry"}; List<Pair<Character, List<String>>> wordsGroups = Arrays.stream(words).collect(groupingBy(w -> Character.toLowerCase(w.charAt(0)))) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().sorted(new CaseInsensitiveComparer().reversed()).toList())).toList(); return wordsGroups; }
public double bigNumbersAggregateMultiply() { double[] numbers = {1.7, 2.3, 1.9, 4.1, 2.9}; double product = Arrays.stream(numbers).filter(n -> n > 2).reduce((a, b) -> a * b).getAsDouble(); return product; }
public List<Pair<String, Double>> customerEachRegionOrdersTotalMax() { List<Customer> customers = getCustomerList(); List<Pair<String, Double>> ordersTotalMax = customers.stream().collect(groupingBy(c -> c.getRegion())) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().flatMap(c -> c.getOrders().stream()).mapToDouble(o -> o.getTotal()).max().getAsDouble())).toList(); return ordersTotalMax; }
public List<Integer> intTake() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; List<Integer> after3Numbers = Arrays.stream(numbers).limit(3).boxed().toList(); return after3Numbers; }
public double doubleAverage() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; double averageNum = Arrays.stream(numbers).average().getAsDouble(); return averageNum; }
public void bigNumbersTwiceEager() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; AtomicInteger i = new AtomicInteger(0); var q = Arrays.stream(numbers).filter(n->n>5).map(n->n*2).map(n -> i.addAndGet(n)).boxed().toList(); for (var v : q) System.out.println(v + " " + i); }
public List<String> stringReverse() { String[] words = { "cherry", "apple", "blueberry" }; List<String> sortedWords = Arrays.stream(words).collect( collectingAndThen(toList(),l->{Collections.reverse(l);return l;})); return sortedWords; }
public List<String> unionOfName() { List<Product> products = getProductList(); List<Customer> customers = getCustomerList(); var productNames = products.stream().map(p -> p.getProductName()); var customerNames = customers.stream().map(c -> c.getCompanyName()); List<String> uniqueNames = Stream.concat(productNames, customerNames).distinct().toList(); return uniqueNames; }
public Map<String, Double> customerOrdersTotalAverageDict() { List<Customer> customers = getCustomerList(); Map<String, Double> ordersTotalAverage = customers.stream().collect(toMap(c -> c.getCustomerId(), c -> c.getOrders().stream().mapToDouble(o -> o.getTotal()).average().getAsDouble())); return ordersTotalAverage; }
public List<Triplet<String, Integer, Integer>> customerSelectManyCustomerOrderDateYearAndMonth() { List<Customer> customers = getCustomerList(); List<Triplet<String, Integer, Integer>> customerProperties = customers.stream().flatMap(c -> c.getOrders() .stream().map(o -> Triplet.with(c.getCustomerId(), o.getOrderDate().getYear(), o.getOrderDate().getMonthValue()))).toList(); return customerProperties; }
public List<Pair<String, List<Product>>> productEachCategoryFirstOrDefaultUnitPriceProducts() { List<Product> products = getProductList(); List<Pair<String, List<Product>>> categories = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().filter(p -> p.getUnitPrice() == g.getValue().stream().findFirst().orElse(Product.DEFAULT).getUnitPrice()).toList())).toList(); return categories; }
public Pair<Integer, Integer>[] selectManyJoin() { int[] numbersA = {0, 2, 4, 5, 6, 8, 9}; int[] numbersB = {1, 3, 5, 7, 8}; Pair<Integer, Integer>[] pairs = (Pair<Integer, Integer>[]) Arrays.stream(numbersA).boxed().flatMap( a -> Arrays.stream(numbersB).mapToObj(b -> Pair.with(a, b))).toArray(); return pairs; }
public List<String> stringOrderbyCustomThenbyLengthCustom() { String[] words = {"aPPLE", "AbAcUs", "bRaNcH", "BlUeBeRrY", "ClOvEr", "cHeRry"}; List<String> sortedWords = Arrays.stream(words) .sorted(Comparator.comparing((String w) -> w,new CaseInsensitiveComparer()) .thenComparing(w -> w.length(),new CustomNumberComparer())).toList(); return sortedWords; }
public List<Pair<String, Integer>> customerIdAndOrdersCount() { List<Customer> customers = getCustomerList(); List<Pair<String, Integer>> customerProperties = customers.stream().map(c -> Pair.with(c.getCustomerId(), c.getOrders().size())).toList(); return customerProperties; }
public double[] doublesConvertToDescendingArray() { double[] doubles = {1.7, 2.3, 1.9, 4.1, 2.9}; double[] doublesArray = Arrays.stream(doubles).boxed().sorted(Comparator.reverseOrder()).mapToDouble(d -> d).toArray(); return doublesArray; }
public void doubleDeferred() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; AtomicReference<Double> d = new AtomicReference<>(0.0); var q = Arrays.stream(numbers).map(n -> d.accumulateAndGet(n, Double::sum)); q.forEach(v -> System.out.println(v + " " + d)); }
public List<Pair<String, Integer>> customerEachRegionOrdersMax() { List<Customer> customers = getCustomerList(); List<Pair<String, Integer>> ordersMax = customers.stream().collect(groupingBy(c -> c.getRegion())) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().mapToInt(c -> c.getOrders().size()).max().getAsInt())).toList(); return ordersMax; }
public List<String> expensiveProductName() { List<Product> products = getProductList(); List<String> productNames = products.stream().filter(p -> p.getUnitPrice() > 100).map(p -> p.getProductName()).toList(); return productNames; }
public List<Double> doublesConvertToDescendingList() { double[] doubles = {1.7, 2.3, 1.9, 4.1, 2.9}; List<Double> doublesList = Arrays.stream(doubles).boxed(). sorted(Comparator.reverseOrder()).toList(); return doublesList; }
public List<Product> productTake() { List<Product> products = getProductList(); List<Product> after3Products = products.stream().limit(3).toList(); return after3Products; }
public List<Double> intSqrtTakeWhileIndexed() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; List<Double> afterNumbers =  IntStream.range(0, numbers.length) .takeWhile(i -> Math.sqrt(numbers[i]) > i).mapToDouble(i -> Math.sqrt(numbers[i]) ).boxed().toList(); return afterNumbers; }
public List<Double> doublesConvertToListAndPrint() { double[] doubles = {1.7, 2.3, 1.9, 4.1, 2.9}; List<Double> doublesList = Arrays.stream(doubles).boxed(). sorted().toList(); for (int i = 0; i < doublesList.size(); i++) System.out.println(doublesList.get(i)); return doublesList; }
public double productUnitPriceAggregateAverage() { List<Product> products = getProductList(); double aggregateSum = products.stream().map(p -> p.getUnitPrice()).reduce((a, b) ->(a + b) / 2).get(); return aggregateSum; }
public int oddNumbersFirstOrDefault() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int firstNum = Arrays.stream(numbers).filter(n -> n % 2 == 1).findFirst().orElse(-2); return firstNum; }
public List<Pair<String, Customer>> customerCrossGroupJoinRegions() { String[] regions = {"BC", "SP", "OR", "LA"}; List<Customer> customers = getCustomerList(); List<Pair<String, Customer>> q = Arrays.stream(regions).map( r -> Pair.with(r, customers.stream().filter(c -> c.getRegion().equals(r)) .collect(Collectors.toList()))).flatMap(t -> t.getValue1().stream() .map(c1 -> Pair.with(t.getValue0(), c1))).toList(); return q; }
public Map<String, Integer> customerEachRegionOrdersSumDict() { List<Customer> customers = getCustomerList(); Map<String, Integer> ordersSum = customers.stream().collect(groupingBy(c -> c.getRegion())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().mapToInt(c -> c.getOrders().size()).sum())); return ordersSum; }
public double bigDoubleNumbersFirstOrDefault() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; double firstNum = Arrays.stream(numbers).filter(d -> d > 5).findFirst().orElse(-2.3); return firstNum; }
public List<Integer> repeatedIntsWithCount(int count) { List<Integer> numbers = Collections.nCopies(count, 0); return numbers; }
public List<String> stringOrderbyLengthCustomThenby() { String[] words = {"cherry", "apple", "blueberry", "banana", "abacus"}; List<String> sortedWords =  Arrays.stream(words).sorted(Comparator.comparing((String w) -> w.length(), new CustomNumberComparer()).thenComparing(Comparator.naturalOrder())).toList(); return sortedWords; }
public List<String> intersectOfName() { List<Product> products = getProductList(); List<Customer> customers = getCustomerList(); var productNames = products.stream().map(p -> p.getProductName()); var customerNames = customers.stream().map(c -> c.getCompanyName()); List<String> sharedNames = productNames.distinct().filter(a -> customerNames.anyMatch(b -> b.equals(a))).toList(); return sharedNames; }
public List<String> concatOfRegion() { String[] regions = {"WA", "AF", "RO"}; List<Customer> customers = getCustomerList(); var customerRegions = customers.stream().map(c -> c.getRegion()); List<String> allRegions = Stream.concat(customerRegions, Arrays.stream(regions)).toList(); return allRegions; }
public List<Pair<String, LocalDate>> waCustomerSelectManyCustomerNewOrderDates() { List<Customer> customers = getCustomerList(); List<Pair<String, LocalDate>> customerProperties = customers.stream().filter(c -> c.getRegion().equals("WA")).flatMap(c -> c.getOrders() .stream().filter(o -> o.getOrderDate().isAfter(LocalDate.of(1998, 1, 1))) .map(o -> Pair.with(c.getCustomerId(), o.getOrderDate()))).toList(); return customerProperties; }
public List<Pair<String, LocalDate>> waCustomerOrdersEachNestedSkipWhile() { List<Customer> customers = getCustomerList(); List<Pair<String, LocalDate>> after3EachWAOrders = customers.stream().filter(c -> c.getRegion().equals("WA")) .flatMap(c -> c.getOrders().stream().dropWhile(o -> o.getOrderDate() .isAfter(LocalDate.of(2000, 1, 1))) .map(o -> Pair.with(c.getCustomerId(), o.getOrderDate()))).toList(); return after3EachWAOrders; }
public List<Pair<String, Integer>> customerEachCountryOrdersMax() { List<Customer> customers = getCustomerList(); List<Pair<String, Integer>> ordersMax = customers.stream().collect(groupingBy(c -> c.getCountry())) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().mapToInt(c -> c.getOrders().size()).max().getAsInt())).toList(); return ordersMax; }
public List<Product> repeatedProducts() { List<Product> products = Collections.nCopies(30,Product.DEFAULT); return products; }
public List<Pair<String, Integer>> customerDistinctOrdersCount() { List<Customer> customers = getCustomerList(); List<Pair<String, Integer>> orderCounts = customers.stream().map(c -> Pair.with(c.getCustomerId(), (int) c.getOrders().stream().distinct().count())).toList(); return orderCounts; }
public List<Integer> stringLengthOrderbyDescendingCustom() { String[] words = {"aPPLE", "AbAcUs", "bRaNcH", "BlUeBeRrY", "ClOvEr", "cHeRry"}; List<Integer> sortedWords = Arrays.stream(words).map(w -> w.length()).sorted(new CustomNumberComparer().reversed()).toList(); return sortedWords; }
public int oddNumbersMinTwice() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int minNum = Arrays.stream(numbers).filter(n -> n % 2 == 0).map(n -> n * 2).min().getAsInt(); return minNum; }
public List<Integer> rangeOfSquareInts() { List<Integer> numbers = IntStream.range(0, 50).map(n->n*n).boxed().toList(); return numbers; }
public List<Pair<String, Integer>> expensiveProductEachCategoryStock() { List<Product> products = getProductList(); List<Pair<String, Integer>> categories = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().filter( p -> p.getUnitPrice() > 100).mapToInt(p -> p.getUnitsInStock()).sum())).toList(); return categories; }
public Map<Boolean, List<Integer>> productGroupByPriceWithIdDict() { List<Product> products = getProductList(); Map<Boolean, List<Integer>> productGroup = products.stream().collect(groupingBy(p -> p.getUnitPrice() > 100)) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().map(p -> p.getProductId()).toList())); return productGroup; }
public List<String> stringIndexedWhere() { String[] words = {"cherry", "apple", "blueberry", "banana", "abacus"}; IntStream.range(0, words.length).filter(i -> words[i].length() < i).mapToObj(i -> words[i]).toList(); List<String> q = IntStream.range(0, words.length).filter(i -> words[i].length() < i).mapToObj(i -> words[i]).toList(); return q; }
public Map<Double, Double> convertArrayToDictionary() { double[] doubles = {1.7, 2.3, 1.9, 4.1, 2.9}; Map<Double, Double> doublesDict = Arrays.stream(doubles).boxed().collect(toMap( sr -> sr, sr -> sr*2)); return doublesDict; }
public List<Integer> intsConvertToListAndPrintForeach() { int[] ints = {2, 3, 1, 5, 4}; List<Integer> intsList = Arrays.stream(ints).boxed().sorted().toList(); for (int i : intsList) System.out.println(i); return intsList; }
public List<String> shortStringOrderbyLengthReverse() { String[] words = { "cherry", "apple", "blueberry", "pear", "peach", "melon" }; List<String> sortedWords = Arrays.stream(words).filter(w -> w.length() < 6) .sorted(Comparator.comparing(w->w.length())).collect( collectingAndThen(toList(),l->{Collections.reverse(l);return l;})); return sortedWords; }
public double[] doublesConvertToArrayAndPrint() { double[] doubles = {1.7, 2.3, 1.9, 4.1, 2.9}; double[] doublesArray = Arrays.stream(doubles).sorted().toArray(); for (int i = 0; i < doublesArray.length; i++) System.out.println(doublesArray[i]); return doublesArray; }
public Map<Integer, List<Customer>> customerGroupJoinRegionsWithCode() { List<Pair<String, Integer>> regions = Arrays.asList( Pair.with("BC", 101), Pair.with("BC", 105), Pair.with("OR", 121), Pair.with("LA", 143) ); List<Customer> customers = getCustomerList(); Map<Integer, List<Customer>> q = regions.stream().map(r -> Pair.with(r.getValue1(), customers.stream() .filter(c -> c.getRegion().equals(r.getValue0())).toList())).collect(toMap(t->t.getValue0(),t->t.getValue1())); return q; }
public Map<String, List<Product>> expensiveProductEachCategoryMinUnitPriceProductsDict() { List<Product> products = getProductList(); Map<String, List<Product>> categories = products.stream().filter(p -> p.getUnitPrice() > 100).collect( groupingBy(p -> p.getCategory())).entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().collect(groupingBy(p -> p.getUnitPrice())) .entrySet().stream().min(Map.Entry.comparingByKey()).get().getValue())); return categories; }
public Map<String, List<Product>> productGroupTakeWhile() { List<Product> products = getProductList(); Map<String, List<Product>> after3Groups = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().takeWhile(g -> g.getKey().length() > 6).collect(toMap(g -> g.getKey(), g -> g.getValue())); return after3Groups; }
public List<Double> bigDoubleFractionOrderbyDescending() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; List<Double> sortedNumbers = Arrays.stream(numbers).filter(n -> n > 5).map(n -> n - (int) n).boxed() .sorted(Comparator.reverseOrder()).toList(); return sortedNumbers; }
public int productOutOfStock() { List<Product> products = getProductList(); int count = (int) products.stream().filter(c -> c.getUnitsInStock() == 0).count(); return count; }
public Map<String, Boolean> expensiveProductEachGroupAllMatch() { List<Product> products = getProductList(); Map<String, Boolean> allMatch = products.stream().filter(p -> p.getUnitPrice() > 100).collect(groupingBy(p -> p.getCategory())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().allMatch(p -> p.getUnitsInStock() > 0))); return allMatch; }
public List<Double> doubleOrderbyModDescendingThenbyDescending() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; List<Double> sortedNumbers = Arrays.stream(numbers).boxed().sorted( Comparator.comparing((Double n) -> n % 1.5,Comparator.reverseOrder()) .thenComparing(Comparator.reverseOrder())).toList(); return sortedNumbers; }
public List<String> longStringTake() { String[] words = {"cherry", "apple", "blueberry", "banana", "abacus"}; List<String> after3Words = Arrays.stream(words).filter(w -> w.length() > 5).limit(3).toList(); return after3Words; }
public Map<String, List<Product>> expensiveProductEachCategoryMaxUnitPriceProductsDict() { List<Product> products = getProductList(); Map<String, List<Product>> categories = products.stream().filter(p -> p.getUnitPrice() > 100).collect( groupingBy(p -> p.getCategory())).entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().collect(groupingBy(p -> p.getUnitPrice())) .entrySet().stream().max(Map.Entry.comparingByKey()).get().getValue())); return categories; }
public List<Pair<String, String>> customerCrossJoinRegionsPhone() { String[] regions = {"BC", "SP", "OR", "LA"}; List<Customer> customers = getCustomerList(); List<Pair<String, String>> q = Arrays.stream(regions).flatMap( r -> customers.stream().filter(c -> c.getRegion().equals(r)).map( c -> Pair.with(r, c.getPhone()))).toList(); return q; }
public Map<String, Map<Integer, Map<Integer, List<Order>>>> customerNestedGroupByNameAndOrderYearAndMonth() { List<Customer> customers = getCustomerList(); Map<String, Map<Integer, Map<Integer, List<Order>>>> customerOrderGroups = customers.stream().collect(toMap( c -> c.getCompanyName(), c -> c.getOrders().stream().collect(groupingBy(o -> o.getOrderDate().getYear())).entrySet().stream().collect(toMap( g -> g.getKey(), g -> g.getValue().stream().collect(groupingBy( o -> o.getOrderDate().getMonthValue() )))))); return customerOrderGroups; }
public Boolean[] bigIntWithOriginalIndex() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; Boolean[] numSelected = (Boolean[]) IntStream.range(0, numbers.length).filter(i -> numbers[i] > 5).filter(i -> numbers[i] % 2 == 1) .mapToObj(i -> numbers[i] == i).toArray(); return numSelected; }
public double expensiveProductStockAverage() { List<Product> products = getProductList(); double averageUnitPrice = products.stream().filter(p -> p.getUnitPrice() > 100) .mapToInt(p -> p.getUnitsInStock()).average().getAsDouble(); return averageUnitPrice; }
public List<Pair<String, LocalDate>> customerOrdersEachNestedSkipWhile() { List<Customer> customers = getCustomerList(); List<Pair<String, LocalDate>> after3EachOrders = customers.stream().flatMap(c -> c.getOrders().stream() .dropWhile(o -> o.getOrderDate().isAfter(LocalDate.of(2000, 1, 1))) .map(o -> Pair.with(c.getCustomerId(), o.getOrderDate()))).toList(); return after3EachOrders; }
public List<String> exceptOfRegion() { String[] regions = {"WA", "AF", "RO"}; List<Customer> customers = getCustomerList(); var customerRegions = customers.stream().map(c -> c.getRegion()); List<String> differemtRegions = customerRegions.distinct().filter(a -> Arrays.stream(regions).allMatch(b -> !b.equals(a))).toList(); return differemtRegions; }
public List<String> stringOrderbyDescending() { String[] words = {"cherry", "apple", "blueberry"}; List<String> sortedWords = Arrays.stream(words).sorted(Comparator.reverseOrder()).toList(); return sortedWords; }
public List<Character> concatOfNameFirstChar() { List<Product> products = getProductList(); List<Customer> customers = getCustomerList(); var productFirstChars = products.stream().map(p -> p.getProductName().charAt(0)); var customerFirstChars = customers.stream().map(c -> c.getCompanyName().charAt(0)); List<Character> allFirstChars = Stream.concat(productFirstChars, customerFirstChars).toList(); return allFirstChars; }
public Map<String, Product> productEachCategoryFirstDict() { List<Product> products = getProductList(); Map<String, Product> categories = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().findFirst().get())); return categories; }
public double bigDoubleNumbersFirst() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; double firstNum = Arrays.stream(numbers).filter(d -> d > 5).findFirst().getAsDouble(); return firstNum; }
public Map<String, Integer> expensiveProductEachCategoryStockDict() { List<Product> products = getProductList(); Map<String, Integer> categories = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().filter( p -> p.getUnitPrice() > 100).mapToInt(p -> p.getUnitsInStock()).sum())); return categories; }
public Map<String, Integer> customerEachCountryOrdersSumDict() { List<Customer> customers = getCustomerList(); Map<String, Integer> ordersSum = customers.stream().collect(groupingBy(c -> c.getCountry())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().mapToInt(c -> c.getOrders().size()).sum())); return ordersSum; }
public int numbersMin() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int minNum = Arrays.stream(numbers).min().getAsInt(); return minNum; }
public Map<Double, Double> convertArrayToDictionaryWithDistinct() { double[] doubles = {1.7, 2.3, 1.9, 4.1, 1.7, 2.9}; Map<Double, Double> doublesDict = Arrays.stream(doubles).distinct().boxed().collect(toMap( sr -> sr, sr -> sr*2)); return doublesDict; }
public List<Pair<String, LocalDate>> customerOrdersNestedTake() { List<Customer> customers = getCustomerList(); List<Pair<String, LocalDate>> after3Orders = customers.stream().flatMap(c -> c.getOrders().stream() .map(o -> Pair.with(c.getCustomerId(), o.getOrderDate()))).limit(3).toList(); return after3Orders; }
public Map<String, Map<String, Customer>> customerNestedGroupByRegionAndName() { List<Customer> customers = getCustomerList(); Map<String, Map<String, Customer>> customerGroups = customers.stream().collect(groupingBy(p -> p.getRegion())) .entrySet().stream().collect(toMap( g -> g.getKey(), g -> g.getValue().stream().collect(toMap( c -> c.getCompanyName(), c -> c)))); return customerGroups; }
public double[] doubleExcept() { double[] numbersA = {0.1, 2.2, 4.3, 5.4, 6.5, 8.6, 9.7}; double[] numbersB = {0.1, 3.3, 5.4, 7.7, 8.6}; double[] differemtNumbers = Arrays.stream(numbersA).distinct().filter(a -> Arrays.stream(numbersB).allMatch(b -> b != a)).toArray(); return differemtNumbers; }
public List<String> stringOrderbyLength() { String[] words = {"cherry", "apple", "blueberry"}; List<String> sortedWords = Arrays.stream(words).sorted(Comparator.comparing(w -> w.length())).toList(); return sortedWords; }
public List<Integer> intSkipWhileCount(int[] numbers, int n) { List<Integer> afterNNumbers = Arrays.stream(numbers).dropWhile(i -> i > n).boxed().toList(); return afterNNumbers; }
public Map<String, List<Product>> productGroupByCategoryDict() { List<Product> products = getProductList(); Map<String, List<Product>> category = products.stream().collect(groupingBy(p -> p.getCategory())); return category; }
public List<Pair<String,Integer>> convertSelectedTupleToList() { Object[] numbers = { Pair.with("Alice", "50"), Pair.with("Bob", 40), Pair.with("Cathy", 45) }; List<Pair<String,Integer>> strings = Arrays.stream(numbers).filter(o->o instanceof Pair && ((Pair)o).getValue0() instanceof String &&((Pair)o).getValue1() instanceof Integer) .map(o->(Pair<String,Integer>)o).toList(); return strings; }
public Character[] projectionStringExcept() { String[] wordsA = {"Alice", "Bob", "Foo", "Bar"}; String[] wordsB = {"Cafe", "Bar", "Restaurant"}; var first = Arrays.stream(wordsA).map(n -> n.charAt(0)); var second = Arrays.stream(wordsB).map(n -> n.charAt(0)); Character[] differemtWords = (Character[]) first.distinct().filter(a -> second.allMatch(b -> b != a)).toArray(); return differemtWords; }
public List<Pair<Boolean, List<Double>>> doubleGroupByBoolOrderbyDescending() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; List<Pair<Boolean, List<Double>>> numbersGroups = Arrays.stream(numbers).boxed().collect(groupingBy(n -> n > 5)) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().sorted(Comparator.reverseOrder()).toList())).toList(); return numbersGroups; }
public List<String> stringOrderbyCustomThenbyLengthDescendingCustom() { String[] words = {"aPPLE", "AbAcUs", "bRaNcH", "BlUeBeRrY", "ClOvEr", "cHeRry"}; List<String> sortedWords = Arrays.stream(words).sorted(Comparator.comparing((String w) -> w,new CaseInsensitiveComparer()) .thenComparing(w -> w.length(),new CustomNumberComparer().reversed())).toList(); return sortedWords; }
public String stringFirstOrDefaultLong() { String[] strings = {"zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"}; String startsWithO = Arrays.stream(strings).filter(s -> s.length() > 4).findFirst().orElse("empty"); return startsWithO; }
public Character[] projectionStringIntersect() { String[] wordsA = {"Alice", "Bob", "Foo", "Bar"}; String[] wordsB = {"Cafe", "Bar", "Restaurant"}; var first = Arrays.stream(wordsA).map(n -> n.charAt(0)); var second = Arrays.stream(wordsB).map(n -> n.charAt(0)); Character[] sharedWords = (Character[]) first.distinct().filter(a -> second.anyMatch(b -> b == a)).toArray(); return sharedWords; }
public List<Product> expensiveProductOrderbyDescendingId() { List<Product> products = getProductList(); List<Product> sortedProducts = products.stream().filter(p -> p.getUnitPrice() > 100) .sorted(Comparator.comparing(p -> p.getProductId(), Comparator.reverseOrder())).toList(); return sortedProducts; }
public List<String> stringSkipCount(int n) { String[] words = {"cherry", "apple", "blueberry", "banana", "abacus"}; List<String> afterNWords = Arrays.stream(words).skip(3).toList(); return afterNWords; }
public Map<Integer, List<String>> customerGroupJoinRegionsWithCodeName() { List<Pair<String, Integer>> regions = Arrays.asList( Pair.with("BC", 101), Pair.with("BC", 105), Pair.with("OR", 121), Pair.with("LA", 143) ); List<Customer> customers = getCustomerList(); Map<Integer, List<String>> q = regions.stream().map(r -> Pair.with(r.getValue1(), customers.stream() .filter(c -> c.getRegion().equals(r.getValue0())).map(c->c.getCompanyName()).toList())) .collect(toMap(t->t.getValue0(),t->t.getValue1())); return q; }
public List<String> stringSkipWhileCount(String[] strings, char c) { List<String> afterNWords = Arrays.stream(strings).dropWhile(w -> w.charAt(0) > c).toList(); return afterNWords; }
public Product expensiveProductElementAt() { List<Product> products = getProductList(); Product expensiveProduct = products.stream().filter(p->p.getUnitPrice()>100) .skip(2).findFirst().get(); return expensiveProduct; }
public int uniqueOddFactorOf300Count() { int[] factorsOf300 = {2, 2, 3, 5, 5}; int uniqueFactorsCount = (int) Arrays.stream(factorsOf300).distinct().filter(n -> (n % 2 == 1)).count(); return uniqueFactorsCount; }
public List<String> stringOrderbyDescendingLengthCustom() { String[] words = {"aPPLE", "AbAcUs", "bRaNcH", "BlUeBeRrY", "ClOvEr", "cHeRry"}; List<String> sortedWords = Arrays.stream(words).sorted(Comparator.comparing(w -> w.length(), new CustomNumberComparer().reversed())).toList(); return sortedWords; }
public void shortStringLengthDeferred() { String[] words = {"cherry", "apple", "blueberry"}; AtomicInteger i = new AtomicInteger(0); var q = Arrays.stream(words).filter(w->w.length()<7).map(w -> w.length()).map(n -> i.addAndGet(n)); q.forEach(v -> System.out.println(v + " " + i)); }
public List<Double> bigDoubleOrderbyFractionThenbyDescending() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; List<Double> sortedNumbers = Arrays.stream(numbers).filter(n->n>3).boxed().sorted( Comparator.comparing((Double n) -> n - (int) n.doubleValue()) .thenComparing(Comparator.reverseOrder())).toList(); return sortedNumbers; }
public Map<Boolean, List<Integer>> intGroupByBoolDict() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; Map<Boolean, List<Integer>> numberGroups = Arrays.stream(numbers).boxed().collect(groupingBy(n -> n > 4)); return numberGroups; }
public Map<String, Boolean> expensiveProductEachGroupAnyMatch() { List<Product> products = getProductList(); Map<String, Boolean> anyMatch = products.stream().filter(p -> p.getUnitPrice() > 100).collect(groupingBy(p -> p.getCategory())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().anyMatch(p -> p.getUnitsInStock() > 0))); return anyMatch; }
public List<String> stringOrderbyDescendingLength() { String[] words = {"cherry", "apple", "blueberry"}; List<String> sortedWords = Arrays.stream(words).sorted(Comparator.comparing(w -> w.length(), Comparator.reverseOrder())).toList(); return sortedWords; }
public boolean stringAnyMatch(char c) { String[] words = {"cherry", "apple", "blueberry", "banana", "abacus"}; boolean anyMatch = Arrays.stream(words).anyMatch(w -> w.charAt(0) > c); return anyMatch; }
public Map<String, Double> customerExpensiveOrdersTotalAverageDict() { List<Customer> customers = getCustomerList(); Map<String, Double> ordersTotalAverage = customers.stream().collect(toMap(c -> c.getCustomerId(), c -> c.getOrders().stream().filter(o -> o.getTotal() > 100) .mapToDouble(o -> o.getTotal()).average().getAsDouble())); return ordersTotalAverage; }
public List<String> productName() { List<Product> products = getProductList(); List<String> productNames = products.stream().map(p -> p.getProductName()).toList(); return productNames; }
public Map<String, List<Double>> productGroupUnitPriceDict() { List<Product> products = getProductList(); Map<String, List<Double>> productNames = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().map(p -> p.getUnitPrice()).toList())); return productNames; }
public List<Integer> oddIntTake() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; List<Integer> after3Numbers = Arrays.stream(numbers).filter(i -> i % 2 == 1).limit(3).boxed().toList(); return after3Numbers; }
public List<Order> waCustomerSelectManyNewOrders() { List<Customer> customers = getCustomerList(); List<parallel.linq101.datasource.Order> customerProperties = customers.stream().filter(c -> c.getRegion().equals("WA")).flatMap(c -> c.getOrders() .stream().filter(o -> o.getOrderDate().isAfter(LocalDate.of(1998, 1, 1)))).toList(); return customerProperties; }
public int customerInRegionCount(String region) { List<Customer> customers = getCustomerList(); int count = (int) customers.stream().filter(c -> c.getRegion().equals(region)).count(); return count; }
public int[] oddIntPlusOne() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int[] numSelected = Arrays.stream(numbers).filter(n -> n % 2 == 1).map(n -> n + 1).toArray(); return numSelected; }
public List<Double> outOfStockProductUnitPrice() { List<Product> products = getProductList(); List<Double> productNames = products.stream().filter(p -> p.getUnitsInStock() == 0).map(p -> p.getUnitPrice()).toList(); return productNames; }
public List<Integer> oddIntTakeWhile() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; List<Integer> after3Numbers = Arrays.stream(numbers).filter(i -> i % 2 == 1).takeWhile(i -> i > 3).boxed().toList(); return after3Numbers; }
public List<Integer> intSquareSkip() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; List<Integer> after3Numbers = Arrays.stream(numbers).map(i -> i * i).skip(3).boxed().toList(); return after3Numbers; }
public int[] intIntersect() { int[] numbersA = {0, 2, 4, 5, 9}; int[] numbersB = {0, 2, 4, 5, 9}; int[] sharedNumbers = Arrays.stream(numbersA).distinct().filter(a -> Arrays.stream(numbersB).anyMatch(b -> b == a)).toArray(); return sharedNumbers; }
public List<Pair<Integer, Customer>> customerCrossGroupJoinRegionsWithCode() { List<Pair<String, Integer>> regions = Arrays.asList( Pair.with("BC", 101), Pair.with("BC", 105), Pair.with("OR", 121), Pair.with("LA", 143) ); List<Customer> customers = getCustomerList(); List<Pair<Integer, Customer>> q = regions.stream().map( r -> Pair.with(r.getValue1(), customers.stream().filter(c -> c.getRegion().equals(r)) .collect(Collectors.toList()))).flatMap(t -> t.getValue1().stream() .map(c1 -> Pair.with(t.getValue0(), c1))).toList(); return q; }
public Map<String, List<String>> customerGroupJoinRegionsName() { String[] regions = {"BC", "SP", "OR", "LA"}; List<Customer> customers = getCustomerList(); Map<String, List<String>> q = Arrays.stream(regions).map(r -> Pair.with(r, customers.stream() .filter(c -> c.getRegion().equals(r)).map(c->c.getCompanyName()).toList())) .collect(toMap(t->t.getValue0(),t->t.getValue1())); return q; }
public List<Pair<String, Integer>> expensiveProductEachCategoryStock() { List<Product> products = getProductList(); List<Pair<String, Integer>> categories = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().filter( p -> p.getUnitPrice() > 100).mapToInt(p -> p.getUnitsInStock()).max().getAsInt())).toList(); return categories; }
public List<Product> expensiveProductOrderbyCategoryThenbyNameCustom() { List<Product> products = getProductList(); List<Product> sortedProducts = products.stream().filter(p->p.getUnitPrice()>100) .sorted(Comparator.comparing((Product p) -> p.getCategory()) .thenComparing(p -> p.getProductName(),new CaseInsensitiveComparer().reversed())).toList(); return sortedProducts; }
public List<Integer> intTakeWhileCount(int n) { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; List<Integer> after3Numbers = Arrays.stream(numbers).takeWhile(i -> i > n).boxed().toList(); return after3Numbers; }
public List<Pair<String, List<Product>>> productEachCategoryMinUnitPriceProducts() { List<Product> products = getProductList(); List<Pair<String, List<Product>>> categories = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().collect(groupingBy(p -> p.getUnitPrice())) .entrySet().stream().min(Map.Entry.comparingByKey()).get().getValue())).toList(); return categories; }
public int intAddMultiply() { int[] numbersA = {0, 2, 4, 5, 6, 8, 9}; int[] numbersB = {1, 3, 5, 7, 8, 10, 11}; int length = numbersA.length; int product = IntStream.range(0, length).map(i -> numbersA[i] + numbersB[i]) .reduce((a, b) -> a * b).getAsInt(); return product; }
public int oddNumbersElementAt() { int[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 }; int numAt = Arrays.stream(numbers).filter(n -> n % 2 == 1).skip(3).findFirst().getAsInt(); return numAt; }
public List<Integer> intSquareIndexedWhere() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; List<Integer> q = IntStream.range(0, numbers.length).filter(i -> numbers[i] * numbers[i] < i) .map(i -> numbers[i] * numbers[i]).boxed().toList(); return q; }
public List<Pair<String, List<Order>>> customerEachRegionOrdersTotalMaxCustomer() { List<Customer> customers = getCustomerList(); List<Pair<String, List<Order>>> customerOrdersTotalMax = customers.stream().collect(groupingBy(c -> c.getRegion())) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream() .flatMap(c -> c.getOrders().stream()).collect(groupingBy(o -> o.getTotal())) .entrySet().stream().max(Map.Entry.comparingByKey()).get().getValue())).toList(); return customerOrdersTotalMax; }
public List<Product> productOrderbyCategoryThenbyDescendingNameCustom() { List<Product> products = getProductList(); List<Product> sortedProducts = products.stream().sorted(Comparator.comparing((Product p) -> p.getCategory()) .thenComparing(p -> p.getProductName(),new CaseInsensitiveComparer().reversed())).toList(); return sortedProducts; }
public Map<String, List<Product>> productGroupSkipWhile() { List<Product> products = getProductList(); Map<String, List<Product>> after3Groups = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().dropWhile(g -> g.getKey().length() > 6).collect(toMap(g -> g.getKey(), g -> g.getValue())); return after3Groups; }
public List<Double> bigDoubleFractionOrderby() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; List<Double> sortedNumbers = Arrays.stream(numbers).filter(n -> n > 5).map(n -> n - (int) n).boxed().sorted().toList(); return sortedNumbers; }
public double[] projectionDoubleUnion() { double[] numbersA = {0.1, 2.2, 4.3, 5.4, 6.5, 8.6, 9.7}; double[] numbersB = {0.1, 3.3, 5.4, 7.7, 8.6}; var first = Arrays.stream(numbersA).map(n -> n - (int) n); var second = Arrays.stream(numbersB).map(n -> n - (int) n); double[] uniqueNumbers = DoubleStream.concat(first, second).distinct().toArray(); return uniqueNumbers; }
public List<Pair<Pair<String, Integer>, String>> customerLeftOuterJoinRegionsWithCodeNameRegion() { List<Pair<String, Integer>> regions = Arrays.asList( Pair.with("BC", 101), Pair.with("BC", 105), Pair.with("OR", 121), Pair.with("LA", 143) ); List<Customer> customers = getCustomerList(); List<Pair<Pair<String, Integer>, String>> q = regions.stream().map( r -> Pair.with(r, customers.stream().filter(c -> c.getRegion().equals(r)) .collect(Collectors.toList()))).flatMap(t -> defaultIfEmpty(t.getValue1(), null).stream() .map(p1 -> Pair.with(t.getValue0(), p1!=null?p1.getCompanyName():"No Customer"))).toList(); return q; }
public boolean intAllMatch() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; boolean allMatch = Arrays.stream(numbers).allMatch(n -> n > 3); return allMatch; }
public List<Triplet<String, Integer, Integer>> customerSelectManyCustomerBigOrderDateYearAndMonth() { List<Customer> customers = getCustomerList(); List<Triplet<String, Integer, Integer>> customerProperties = customers.stream().flatMap(c -> c.getOrders() .stream().filter(o -> o.getTotal() > 100).map(o -> Triplet.with(c.getCustomerId(), o.getOrderDate().getYear(), o.getOrderDate().getMonthValue()))).toList(); return customerProperties; }
public Map<String, Double> customerEachRegionOrdersTotalAverageDict() { List<Customer> customers = getCustomerList(); Map<String, Double> ordersTotalAverage = customers.stream().collect(groupingBy(c -> c.getRegion())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().flatMap(c -> c.getOrders().stream()).mapToDouble(o -> o.getTotal()).average().getAsDouble())); return ordersTotalAverage; }
public Map<String, Double> customerEachRegionOrdersTotalMinDict() { List<Customer> customers = getCustomerList(); Map<String, Double> ordersTotalMin = customers.stream().collect(groupingBy(c -> c.getRegion())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().flatMap(c -> c.getOrders().stream()).mapToDouble(o -> o.getTotal()).min().getAsDouble())); return ordersTotalMin; }
public List<Integer> intSquareSkipWhile() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; List<Integer> after3Numbers = Arrays.stream(numbers).map(i -> i * i).dropWhile(i -> i > 3).boxed().toList(); return after3Numbers; }
public List<Pair<String, Double>> customerOrdersTotalMax() { List<Customer> customers = getCustomerList(); List<Pair<String, Double>> ordersTotalMax = customers.stream().map(c -> Pair.with(c.getCustomerId(), c.getOrders().stream().mapToDouble(o -> o.getTotal()).max().getAsDouble())).toList(); return ordersTotalMax; }
public List<Double> intSqrtSkipWhileIndexed() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; List<Double> afterNumbers =  IntStream.range(0, numbers.length) .dropWhile(i -> Math.sqrt(numbers[i]) > i).mapToDouble(i -> Math.sqrt(numbers[i]) ).boxed().toList(); return afterNumbers; }
public Map<String, List<Customer>> customerEachCountryOrdersMaxCustomerDict() { List<Customer> customers = getCustomerList(); Map<String, List<Customer>> customerOrdersMax = customers.stream().collect(groupingBy(c -> c.getCountry())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream(). collect(groupingBy(c -> c.getOrders().size())).entrySet() .stream().max(Map.Entry.comparingByKey()).get().getValue())); return customerOrdersMax; }
public List<Pair<String, Product>> productLeftOuterJoinCategories() { String[] categories = {"Beverages", "Condiments", "Vegetables", "Dairy Products", "Seafood"}; List<Product> products = getProductList(); List<Pair<String, Product>> q = Arrays.stream(categories).map( c -> Pair.with(c, products.stream().filter(p -> p.getCategory().equals(c)) .collect(Collectors.toList()))).flatMap(t -> defaultIfEmpty(t.getValue1(), null).stream() .map(p1 -> Pair.with(t.getValue0(), p1))).toList(); return q; }
public List<Pair<String, Integer>> productEachCategoryStock() { List<Product> products = getProductList(); List<Pair<String, Integer>> categories = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().mapToInt(p -> p.getUnitsInStock()).max().getAsInt())).toList(); return categories; }
public List<Pair<Boolean, List<String>>> stringGroupByLengthOrderbyLength() { String[] words = {"blueberry", "chimpanzee", "abacus", "banana", "apple", "cheese"}; List<Pair<Boolean, List<String>>> wordsGroups = Arrays.stream(words).collect(groupingBy(w -> w.length() > 8)) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().sorted(Comparator.comparing(w -> w.length())).toList())).toList(); return wordsGroups; }
public List<Pair<String, List<Customer>>> customerEachCountryOrdersFirstCustomer() { List<Customer> customers = getCustomerList(); List<Pair<String, List<Customer>>> customerOrdersFirst = customers.stream().collect(groupingBy(c -> c.getRegion())) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().filter( c -> c.getOrders().size() == g.getValue().stream().findFirst().get().getOrders().size()).toList())).toList(); return customerOrdersFirst; }
public double numbersAggregateFindMaxWithSeed() { double[] numbers = {1.7, 2.3, 1.9, 4.1, 2.9}; double seed = 5; double aggregateSum = Arrays.stream(numbers).filter(n -> n > 2).reduce(seed, (a, b) -> Math.max(a, b)); return aggregateSum; }
public List<Character> unionOfNameFirstChar() { List<Product> products = getProductList(); List<Customer> customers = getCustomerList(); var productFirstChars = products.stream().map(p -> p.getProductName().charAt(0)); var customerFirstChars = customers.stream().map(c -> c.getCompanyName().charAt(0)); List<Character> uniqueFirstChars = Stream.concat(productFirstChars, customerFirstChars).distinct().toList(); return uniqueFirstChars; }
public double productUnitPriceMax() { List<Product> products = getProductList(); double maxUnitPrice = products.stream().mapToDouble(p -> p.getUnitPrice()).max().getAsDouble(); return maxUnitPrice; }
public void oddNumbersTwiceEager() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; AtomicInteger i = new AtomicInteger(0); var q = Arrays.stream(numbers).filter(n->n%2==1).map(n->n*2).map(n -> i.addAndGet(n)).boxed().toList(); for (var v : q) System.out.println(v + " " + i); }
public int stringMinLength() { String[] words = {"cherry", "apple", "blueberry"}; int minLength = Arrays.stream(words).mapToInt(w -> w.length()).min().getAsInt(); return minLength; }
public boolean projectionEqualInts() { int[] numbersA = {0, 2, 4, 5, 9}; int[] numbersB = {1, 3, 5, 6, 10}; boolean equal = Arrays.equals(Arrays.stream(numbersA).map(n -> n + 1). toArray(), numbersB); return equal; }
public String stringFirstStartWith(char c) { String[] strings = {"zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"}; String startWithChar = Arrays.stream(strings).filter(s -> s.charAt(0) == c).findFirst().get(); return startWithChar; }
public List<Product> productsConvertToList() { List<Product> products = getProductList(); List<Product> productsList = products.stream().sorted(Comparator.comparing(p -> p.getUnitPrice())).toList(); return productsList; }
public int[] transformIndexHashToInt() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int[] textNums = Arrays.stream(numbers).map(n -> numbers[n * 97 % 10]).toArray(); return textNums; }
public List<String> shortStringOrderby() { String[] words = {"cherry", "apple", "blueberry", "pear", "peach", "melon"}; List<String> sortedWords = Arrays.stream(words).filter(w -> w.length() < 6).sorted().toList(); return sortedWords; }
public double[] doubleUnion() { double[] numbersA = {0.1, 2.2, 4.3, 5.4, 6.5, 8.6, 9.7}; double[] numbersB = {0.1, 3.3, 5.4, 7.7, 8.6}; double[] uniqueNumbers = DoubleStream.concat(Arrays.stream(numbersA), Arrays.stream(numbersB)).distinct().toArray(); return uniqueNumbers; }
public double[] projectionDoubleConcat() { double[] numbersA = {0.1, 2.2, 4.3, 5.4, 6.5, 8.6, 9.7}; double[] numbersB = {0.1, 3.3, 5.4, 7.7, 8.6}; var first = Arrays.stream(numbersA).map(n -> n - (int) n); var second = Arrays.stream(numbersB).map(n -> n - (int) n); double[] allNumbers = DoubleStream.concat(first, second).toArray(); return allNumbers; }
public int[] intZipSub() { int[] numbersA = {0, 2, 4, 5, 6, 8, 9}; int[] numbersB = {1, 3, 5, 7, 8, 10, 11}; int length = numbersA.length; int[] subNumbers = IntStream.range(0, length).map(i -> numbersA[i] - numbersB[i]).toArray(); return subNumbers; }
public List<Order> customerOrdersTakeWhile() { List<Customer> customers = getCustomerList(); List<Order> after3Orders = customers.stream().flatMap(c -> c.getOrders().stream()) .takeWhile(o -> o.getOrderDate().isAfter(LocalDate.of(2000, 1, 1))).toList(); return after3Orders; }
public Map<Boolean, List<Integer>> productGroupByInStockWithIdDictPrint() { List<Product> products = getProductList(); Map<Boolean, List<Integer>> productGroup = products.stream().collect(groupingBy(p -> p.getUnitsInStock() > 0)) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().map(p -> p.getProductId()).toList())); productGroup.get(true).stream().forEach(n -> System.out.print(n)); System.out.println(); productGroup.get(false).stream().forEach(n -> System.out.print(n)); return productGroup; }
public List<String> concatOfCategory() { String[] categories = {"Furnitures", "Seagoods"}; List<Product> products = getProductList(); var productCategories = products.stream().map(p -> p.getCategory()); List<String> allCategories = Stream.concat(productCategories, Arrays.stream(categories)).toList(); return allCategories; }
public List<Pair<String, String>> customerCityAndAddress() { List<Customer> customers = getCustomerList(); List<Pair<String, String>> customerProperties = customers.stream().map(c -> Pair.with(c.getCity(), c.getAddress())).toList(); return customerProperties; }
public List<Integer> stringLengthSkip() { String[] words = {"cherry", "apple", "blueberry", "banana", "abacus"}; List<Integer> after3Words = Arrays.stream(words).map(w -> w.length()).skip(3).toList(); return after3Words; }
public List<Pair<String, List<Integer>>> productGroupByCategoryWithId() { List<Product> products = getProductList(); List<Pair<String, List<Integer>>> category = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().map(p -> p.getProductId()).toList())).toList(); return category; }
public List<Pair<Boolean, List<Double>>> doubleGroupByBool() { double[] numbers = {5.8, 4.3, 1.5, 3.7, 9.3}; List<Pair<Boolean, List<Double>>> numberGroups = numberGroups = Arrays.stream(numbers).boxed().collect(groupingBy(n -> n > 3)) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue())).toList(); return numberGroups; }
public List<Pair<String, Order>> customerEachRegionFirstOrDefaultOrder() { List<Customer> customers = getCustomerList(); List<Pair<String, Order>> ordersFirstOrDefault = customers.stream().collect(groupingBy(c -> c.getRegion())) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().flatMap(c -> c.getOrders().stream()).findFirst().orElse(Order.DEFAULT))).toList(); return ordersFirstOrDefault; }
public List<Boolean> waCustomerOrdersEachNestedAllMatch() { List<Customer> customers = getCustomerList(); List<Boolean> allMatch = customers.stream().filter(c -> c.getRegion() == "WA").map(c -> c.getOrders().stream().allMatch(o -> o.getOrderDate().isAfter(LocalDate.of(2000, 1, 1)))).toList(); return allMatch; }
public List<Pair<String, String>> productCrossJoinCategoriesName() { String[] categories = {"Beverages", "Condiments", "Vegetables", "Dairy Products", "Seafood"}; List<Product> products = getProductList(); List<Pair<String, String>> q = Arrays.stream(categories).flatMap( c -> products.stream().filter(p -> p.getCategory().equals(c)).map( p -> Pair.with(c, p.getProductName()))).toList(); return q; }
public boolean intAllMatchInput(int[] numbers, int i) { boolean allMatch = Arrays.stream(numbers).allMatch(n -> n > i); return allMatch; }
public List<Pair<Boolean, List<String>>> stringGroupByLengthOrderbyDescendingLength() { String[] words = {"blueberry", "chimpanzee", "abacus", "banana", "apple", "cheese"}; List<Pair<Boolean, List<String>>> wordsGroups = Arrays.stream(words).collect(groupingBy(w -> w.length() > 8)) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream() .sorted(Comparator.comparing(w -> w.length(), Comparator.reverseOrder())).toList())).toList(); return wordsGroups; }
public int oddNumbersMax() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int maxNum = Arrays.stream(numbers).filter(n -> n % 2 == 0).max().getAsInt(); return maxNum; }
public Map<Character, List<String>> stringGroupByFirstCharDictOrderbyDescending() { String[] words = {"blueberry", "chimpanzee", "abacus", "banana", "apple", "cheese"}; Map<Character, List<String>> wordsGroups = Arrays.stream(words).collect(groupingBy(w -> w.charAt(0))) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().sorted(Comparator.reverseOrder()).toList())); return wordsGroups; }
public int numbersMinTwice() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int minNum = Arrays.stream(numbers).map(n -> n * 2).min().getAsInt(); return minNum; }
public void bigNumbersTwiceDeferred() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; AtomicInteger i = new AtomicInteger(0); var q = Arrays.stream(numbers).filter(n->n>5).map(n->n*2).map(n -> i.addAndGet(n)); q.forEach(v -> System.out.println(v + " " + i)); }
public List<Pair<String, LocalDate>> waCustomerOrdersEachNestedSkip() { List<Customer> customers = getCustomerList(); List<Pair<String, LocalDate>> after3EachWAOrders = customers.stream().filter(c -> c.getRegion().equals("WA")) .flatMap(c -> c.getOrders().stream().skip(3).map(o -> Pair.with(c.getCustomerId(), o.getOrderDate()))).toList(); return after3EachWAOrders; }
public List<Pair<String, Double>> customerInRegionOrdersTotalSum(String region) { List<Customer> customers = getCustomerList(); List<Pair<String, Double>> ordersTotalSum = customers.stream().filter(c -> c.getRegion().equals(region)) .map(c -> Pair.with(c.getCustomerId(), c.getOrders().stream().mapToDouble(o -> o.getTotal()).sum())).toList(); return ordersTotalSum; }
public List<Order> customerSelectManyNewOrders() { List<Customer> customers = getCustomerList(); List<Order> customerProperties = customers.stream().flatMap(c -> c.getOrders() .stream().filter(o -> o.getOrderDate().isAfter(LocalDate.of(1998, 1, 1)))).toList(); return customerProperties; }
public boolean longStringAnyMatch() { String[] words = {"cherry", "apple", "blueberry", "banana", "abacus"}; boolean anyMatch = Arrays.stream(words).filter(w -> w.length() > 5).anyMatch(n -> n.compareTo("b") > 0); return anyMatch; }
