public List<Product> productOrderbyId() { List<Product> products = getProductList(); List<Product> sortedProducts = products.stream().sorted(Comparator.comparing(p -> p.getProductId())).toList(); return sortedProducts; }
public List<Product> productOrderbyName() { List<Product> products = getProductList(); List<Product> sortedProducts = products.stream().sorted(Comparator.comparing(p -> p.getProductName())).toList(); return sortedProducts; }
public List<String> productNameOrderby() { List<Product> products = getProductList(); List<String> sortedProducts = products.stream().map(p -> p.getProductName()).sorted().toList(); return sortedProducts; }
public List<Product> expensiveProductOrderbyId() { List<Product> products = getProductList(); List<Product> sortedProducts = products.stream().filter(p -> p.getUnitPrice() > 100).sorted(Comparator.comparing(p -> p.getProductId())).toList(); return sortedProducts; }
public List<Product> expensiveProductOrderbyName() { List<Product> products = getProductList(); List<Product> sortedProducts = products.stream().filter(p -> p.getUnitPrice() > 100).sorted(Comparator.comparing(p -> p.getProductName())).toList(); return sortedProducts; }
public List<String> expensiveProductNameOrderby() { List<Product> products = getProductList(); List<String> sortedProducts = products.stream().filter(p -> p.getUnitPrice() > 100).map(p -> p.getProductName()).sorted().toList(); return sortedProducts; }
public List<Pair<String, List<Product>>> productGroupByCategoryOrderbyId() { List<Product> products = getProductList(); List<Pair<String, List<Product>>> productsGroups = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream() .sorted(Comparator.comparing(p -> p.getProductId())).toList())).toList(); return productsGroups; }
public Map<String, List<Product>> productGroupByCategoryDictOrderbyId() { List<Product> products = getProductList(); Map<String, List<Product>> productsGroups = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream() .sorted(Comparator.comparing(p -> p.getProductId())).toList())); return productsGroups; }
public List<Pair<String, List<Product>>> productGroupByCategoryOrderbyName() { List<Product> products = getProductList(); List<Pair<String, List<Product>>> productsGroups = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream() .sorted(Comparator.comparing(p -> p.getProductName())).toList())).toList(); return productsGroups; }
public Map<String, List<Product>> productGroupByCategoryDictOrderbyName() { List<Product> products = getProductList(); Map<String, List<Product>> productsGroups = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream(). sorted(Comparator.comparing(p -> p.getProductName())).toList())); return productsGroups; }
public List<String> stringOrderbyCustom() { String[] words = {"aPPLE", "AbAcUs", "bRaNcH", "BlUeBeRrY", "ClOvEr", "cHeRry"}; List<String> sortedWords = Arrays.stream(words).sorted(new CaseInsensitiveComparer()).toList(); return sortedWords; }
public List<String> stringOrderbyLengthCustom() { String[] words = {"aPPLE", "AbAcUs", "bRaNcH", "BlUeBeRrY", "ClOvEr", "cHeRry"}; List<String> sortedWords = Arrays.stream(words).sorted(Comparator.comparing(w -> w.length(), new CustomNumberComparer())).toList(); return sortedWords; }
public List<Integer> stringLengthOrderbyCustom() { String[] words = {"aPPLE", "AbAcUs", "bRaNcH", "BlUeBeRrY", "ClOvEr", "cHeRry"}; List<Integer> sortedWords = Arrays.stream(words).map(w -> w.length()).sorted(new CustomNumberComparer()).toList(); return sortedWords; }
public List<String> shortStringOrderbyCustom() { String[] words = {"aPPLE", "AbAcUs", "bRaNcH", "BlUeBeRrY", "ClOvEr", "cHeRry"}; List<String> sortedWords = Arrays.stream(words).filter(w -> w.length() < 6).sorted(new CaseInsensitiveComparer()). toList(); return sortedWords; }
public List<String> shortStringOrderbyLengthCustom() { String[] words = {"aPPLE", "AbAcUs", "bRaNcH", "BlUeBeRrY", "ClOvEr", "cHeRry"}; List<String> sortedWords = Arrays.stream(words).filter(w -> w.length() < 6).sorted(Comparator.comparing(w -> w.length(), new CustomNumberComparer())).toList(); return sortedWords; }
public List<Integer> shortStringLengthOrderbyCustom() { String[] words = {"aPPLE", "AbAcUs", "bRaNcH", "BlUeBeRrY", "ClOvEr", "cHeRry"}; List<Integer> sortedWords = Arrays.stream(words).filter(w -> w.length() < 6).map(w -> w.length()). sorted(new CustomNumberComparer()).toList(); return sortedWords; }
public List<Pair<Character, List<String>>> stringGroupByFirstCharOrderbyCustom() { String[] words = {"aPPLE", "AbAcUs", "bRaNcH", "BlUeBeRrY", "ClOvEr", "cHeRry"}; List<Pair<Character, List<String>>> wordsGroups = Arrays.stream(words).collect(groupingBy(w -> Character.toLowerCase(w.charAt(0)))) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().sorted(new CaseInsensitiveComparer()).toList())).toList(); return wordsGroups; }
public Map<Character, List<String>> stringGroupByFirstCharDictOrderbyCustom() { String[] words = {"aPPLE", "AbAcUs", "bRaNcH", "BlUeBeRrY", "ClOvEr", "cHeRry"}; Map<Character, List<String>> wordsGroups = Arrays.stream(words).collect(groupingBy(w -> Character.toLowerCase(w.charAt(0)))) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().sorted(new CaseInsensitiveComparer()).toList())); return wordsGroups; }
public List<Pair<Boolean, List<String>>> stringGroupByLengthOrderbyLengthCustom() { String[] words = {"aPPLE", "AbAcUs", "bRaNcH", "BlUeBeRrY", "ClOvEr", "cHeRry"}; List<Pair<Boolean, List<String>>> wordsGroups = Arrays.stream(words).collect(groupingBy(w -> w.length() > 8)) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().sorted( Comparator.comparing(w -> w.length(), new CustomNumberComparer())).toList())).toList(); return wordsGroups; }
public Map<Boolean, List<String>> stringGroupByLengthDictOrderbyLengthCustom() { String[] words = {"aPPLE", "AbAcUs", "bRaNcH", "BlUeBeRrY", "ClOvEr", "cHeRry"}; Map<Boolean, List<String>> wordsGroups = Arrays.stream(words).collect(groupingBy(w -> w.length() > 8)) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().sorted( Comparator.comparing(w -> w.length(), new CustomNumberComparer())).toList())); return wordsGroups; }
public void numbersDeferred() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; AtomicInteger i = new AtomicInteger(0); var q = Arrays.stream(numbers).map(n -> i.addAndGet(n)); q.forEach(v -> System.out.println(v + " " + i)); }
public void bigNumbersDeferred() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; AtomicInteger i = new AtomicInteger(0); var q = Arrays.stream(numbers).filter(n->n>5).map(n -> i.addAndGet(n)); q.forEach(v -> System.out.println(v + " " + i)); }
public void oddNumbersDeferred() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; AtomicInteger i = new AtomicInteger(0); var q = Arrays.stream(numbers).filter(n->n%2==1).map(n -> i.addAndGet(n)); q.forEach(v -> System.out.println(v + " " + i)); }
public void doubleDeferred() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; AtomicReference<Double> d = new AtomicReference<>(0.0); var q = Arrays.stream(numbers).map(n -> d.accumulateAndGet(n, Double::sum)); q.forEach(v -> System.out.println(v + " " + d)); }
public void bigDoubleNumbersDeferred() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; AtomicReference<Double> d = new AtomicReference<>(0.0); var q = Arrays.stream(numbers).filter(n->n>5).map(n -> d.accumulateAndGet(n, Double::sum)); q.forEach(v -> System.out.println(v + " " + d)); }
public void numbersTwiceDeferred() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; AtomicInteger i = new AtomicInteger(0); var q = Arrays.stream(numbers).map(n->n*2).map(n -> i.addAndGet(n)); q.forEach(v -> System.out.println(v + " " + i)); }
public void bigNumbersTwiceDeferred() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; AtomicInteger i = new AtomicInteger(0); var q = Arrays.stream(numbers).filter(n->n>5).map(n->n*2).map(n -> i.addAndGet(n)); q.forEach(v -> System.out.println(v + " " + i)); }
public void oddNumbersTwiceDeferred() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; AtomicInteger i = new AtomicInteger(0); var q = Arrays.stream(numbers).filter(n->n%2==1).map(n->n*2).map(n -> i.addAndGet(n)); q.forEach(v -> System.out.println(v + " " + i)); }
public void stringLengthDeferred() { String[] words = {"cherry", "apple", "blueberry"}; AtomicInteger i = new AtomicInteger(0); var q = Arrays.stream(words).map(w -> w.length()).map(n -> i.addAndGet(n)); q.forEach(v -> System.out.println(v + " " + i)); }
public void shortStringLengthDeferred() { String[] words = {"cherry", "apple", "blueberry"}; AtomicInteger i = new AtomicInteger(0); var q = Arrays.stream(words).filter(w->w.length()<7).map(w -> w.length()).map(n -> i.addAndGet(n)); q.forEach(v -> System.out.println(v + " " + i)); }
public void numbersEager() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; AtomicInteger i = new AtomicInteger(0); var q = Arrays.stream(numbers).map(n -> i.addAndGet(n)).boxed().toList(); for (var v : q) System.out.println(v + " " + i); }
public void bigNumbersEager() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; AtomicInteger i = new AtomicInteger(0); var q = Arrays.stream(numbers).filter(n->n>5).map(n -> i.addAndGet(n)).boxed().toList(); for (var v : q) System.out.println(v + " " + i); }
public void oddNumbersEager() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; AtomicInteger i = new AtomicInteger(0); var q = Arrays.stream(numbers).filter(n->n%2==1).map(n -> i.addAndGet(n)).boxed().toList(); for (var v : q) System.out.println(v + " " + i); }
public void doubleEager() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; AtomicReference<Double> d = new AtomicReference<>(0.0); var q = Arrays.stream(numbers).map(n -> d.accumulateAndGet(n, Double::sum)).boxed().toList(); for (var v : q) System.out.println(v + " " + d); }
public void bigDoubleNumbersEager() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; AtomicReference<Double> d = new AtomicReference<>(0.0); var q = Arrays.stream(numbers).filter(n->n>5).map(n -> d.accumulateAndGet(n, Double::sum)).boxed().toList(); for (var v : q) System.out.println(v + " " + d); }
public void numbersTwiceEager() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; AtomicInteger i = new AtomicInteger(0); var q = Arrays.stream(numbers).map(n->n*2).map(n -> i.addAndGet(n)).boxed().toList(); for (var v : q) System.out.println(v + " " + i); }
public void bigNumbersTwiceEager() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; AtomicInteger i = new AtomicInteger(0); var q = Arrays.stream(numbers).filter(n->n>5).map(n->n*2).map(n -> i.addAndGet(n)).boxed().toList(); for (var v : q) System.out.println(v + " " + i); }
public void oddNumbersTwiceEager() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; AtomicInteger i = new AtomicInteger(0); var q = Arrays.stream(numbers).filter(n->n%2==1).map(n->n*2).map(n -> i.addAndGet(n)).boxed().toList(); for (var v : q) System.out.println(v + " " + i); }
public void stringLengthEager() { String[] words = {"cherry", "apple", "blueberry"}; AtomicInteger i = new AtomicInteger(0); var q = Arrays.stream(words).map(w -> w.length()).map(n -> i.addAndGet(n)).toList(); for (var v : q) System.out.println(v + " " + i); }
public void shortStringLengthEager() { String[] words = {"cherry", "apple", "blueberry"}; AtomicInteger i = new AtomicInteger(0); var q = Arrays.stream(words).filter(w->w.length()<7).map(w -> w.length()).map(n -> i.addAndGet(n)).toList(); for (var v : q) System.out.println(v + " " + i); }
public Pair<Integer, Integer>[] selectManyJoin() { int[] numbersA = {0, 2, 4, 5, 6, 8, 9}; int[] numbersB = {1, 3, 5, 7, 8}; Pair<Integer, Integer>[] pairs = (Pair<Integer, Integer>[]) Arrays.stream(numbersA).boxed().flatMap( a -> Arrays.stream(numbersB).mapToObj(b -> Pair.with(a, b))).toArray(); return pairs; }
public Pair<Integer, Integer>[] selectManyJoinOdd() { int[] numbersA = {0, 2, 4, 5, 6, 8, 9}; int[] numbersB = {1, 3, 5, 7, 8}; Pair<Integer, Integer>[] pairs = (Pair<Integer, Integer>[]) Arrays.stream(numbersA).boxed().flatMap(a -> Arrays.stream(numbersB) .filter(b -> b % 2 == 1).mapToObj(b -> Pair.with(a, b))).toArray(); return pairs; }
public Pair<Integer, Integer>[] selectManyJoinBig() { int[] numbersA = {0, 2, 4, 5, 6, 8, 9}; int[] numbersB = {1, 3, 5, 7, 8}; Pair<Integer, Integer>[] pairs = (Pair<Integer, Integer>[]) Arrays.stream(numbersA).boxed().flatMap(a -> Arrays.stream(numbersB) .filter(b -> b > 5).mapToObj(b -> Pair.with(a, b))).toArray(); return pairs; }
public Pair<Integer, Integer>[] selectManyJoinSmaller() { int[] numbersA = {0, 2, 4, 5, 6, 8, 9}; int[] numbersB = {1, 3, 5, 7, 8}; Pair<Integer, Integer>[] pairs = (Pair<Integer, Integer>[]) Arrays.stream(numbersA).boxed().flatMap(a -> Arrays.stream(numbersB) .filter(b -> a < b).mapToObj(b -> Pair.with(a, b))).toArray(); return pairs; }
public Pair<Integer, Integer>[] selectManyJoinSumEven() { int[] numbersA = {0, 2, 4, 5, 6, 8, 9}; int[] numbersB = {1, 3, 5, 7, 8}; Pair<Integer, Integer>[] pairs = (Pair<Integer, Integer>[]) Arrays.stream(numbersA).boxed().flatMap(a -> Arrays.stream(numbersB) .filter(b -> (a + b) % 2 == 0).mapToObj(b -> Pair.with(a, b))).toArray(); return pairs; }
public List<Order> customerSelectManyOrders() { List<Customer> customers = getCustomerList(); List<Order> customerProperties = customers.stream().flatMap(c -> c.getOrders().stream()).toList(); return customerProperties; }
public List<Pair<String, Order>> customerSelectManyCustomerOrders() { List<Customer> customers = getCustomerList(); List<Pair<String, Order>> customerProperties = customers.stream().flatMap(c -> c.getOrders() .stream().map(o -> Pair.with(c.getCustomerId(), o))).toList(); return customerProperties; }
public List<Pair<String, LocalDate>> customerSelectManyCustomerOrderDates() { List<Customer> customers = getCustomerList(); List<Pair<String, LocalDate>> customerProperties = customers.stream().flatMap(c -> c.getOrders() .stream().map(o -> Pair.with(c.getCustomerId(), o.getOrderDate()))).toList(); return customerProperties; }
public List<Triplet<String, Integer, Double>> customerSelectManyCustomerOrderIdAndTotals() { List<Customer> customers = getCustomerList(); List<Triplet<String, Integer, Double>> customerProperties = customers.stream().flatMap(c -> c.getOrders() .stream().map(o -> Triplet.with(c.getCustomerId(), o.getOrderId(), o.getTotal()))).toList(); return customerProperties; }
public List<Triplet<String, Integer, Integer>> customerSelectManyCustomerOrderDateYearAndMonth() { List<Customer> customers = getCustomerList(); List<Triplet<String, Integer, Integer>> customerProperties = customers.stream().flatMap(c -> c.getOrders() .stream().map(o -> Triplet.with(c.getCustomerId(), o.getOrderDate().getYear(), o.getOrderDate().getMonthValue()))).toList(); return customerProperties; }
public List<Order> customerSelectManyBigOrders() { List<Customer> customers = getCustomerList(); List<Order> customerProperties = customers.stream().flatMap(c -> c.getOrders() .stream().filter(o -> o.getTotal() > 100)).toList(); return customerProperties; }
public List<Pair<String, Order>> customerSelectManyCustomerBigOrders() { List<Customer> customers = getCustomerList(); List<Pair<String, Order>> customerProperties = customers.stream().flatMap(c -> c.getOrders() .stream().filter(o -> o.getTotal() > 100).map(o -> Pair.with(c.getCustomerId(), o))).toList(); return customerProperties; }
public List<Pair<String, LocalDate>> customerSelectManyCustomerBigOrderDates() { List<Customer> customers = getCustomerList(); List<Pair<String, LocalDate>> customerProperties = customers.stream().flatMap(c -> c.getOrders() .stream().filter(o -> o.getTotal() > 100).map(o -> Pair.with(c.getCustomerId(), o.getOrderDate()))).toList(); return customerProperties; }
public List<Triplet<String, Integer, Double>> customerSelectManyCustomerBigOrderIdAndTotals() { List<Customer> customers = getCustomerList(); List<Triplet<String, Integer, Double>> customerProperties = customers.stream().flatMap(c -> c.getOrders() .stream().filter(o -> o.getTotal() > 100).map(o -> Triplet.with(c.getCustomerId(), o.getOrderId(), o.getTotal()))).toList(); return customerProperties; }
public List<Triplet<String, Integer, Integer>> customerSelectManyCustomerBigOrderDateYearAndMonth() { List<Customer> customers = getCustomerList(); List<Triplet<String, Integer, Integer>> customerProperties = customers.stream().flatMap(c -> c.getOrders() .stream().filter(o -> o.getTotal() > 100).map(o -> Triplet.with(c.getCustomerId(), o.getOrderDate().getYear(), o.getOrderDate().getMonthValue()))).toList(); return customerProperties; }
public List<Order> customerSelectManyNewOrders() { List<Customer> customers = getCustomerList(); List<Order> customerProperties = customers.stream().flatMap(c -> c.getOrders() .stream().filter(o -> o.getOrderDate().isAfter(LocalDate.of(1998, 1, 1)))).toList(); return customerProperties; }
public List<Pair<String, Order>> customerSelectManyCustomerNewOrders() { List<Customer> customers = getCustomerList(); List<Pair<String, Order>> customerProperties = customers.stream().flatMap(c -> c.getOrders() .stream().filter(o -> o.getOrderDate().isAfter(LocalDate.of(1998, 1, 1))) .map(o -> Pair.with(c.getCustomerId(), o))).toList(); return customerProperties; }
public List<Pair<String, LocalDate>> customerSelectManyCustomerNewOrderDates() { List<Customer> customers = getCustomerList(); List<Pair<String, LocalDate>> customerProperties = customers.stream().flatMap(c -> c.getOrders() .stream().filter(o -> o.getOrderDate().isAfter(LocalDate.of(1998, 1, 1))) .map(o -> Pair.with(c.getCustomerId(), o.getOrderDate()))).toList(); return customerProperties; }
public List<Triplet<String, Integer, Double>> customerSelectManyCustomerNewOrderIdAndTotals() { List<Customer> customers = getCustomerList(); List<Triplet<String, Integer, Double>> customerProperties = customers.stream().flatMap(c -> c.getOrders() .stream().filter(o -> o.getOrderDate().isAfter(LocalDate.of(1998, 1, 1))) .map(o -> Triplet.with(c.getCustomerId(), o.getOrderId(), o.getTotal()))).toList(); return customerProperties; }
public List<Triplet<String, Integer, Integer>> customerSelectManyCustomerNewOrderDateYearAndMonth() { List<Customer> customers = getCustomerList(); List<Triplet<String, Integer, Integer>> customerProperties = customers.stream().flatMap(c -> c.getOrders() .stream().filter(o -> o.getOrderDate().isAfter(LocalDate.of(1998, 1, 1))) .map(o -> Triplet.with(c.getCustomerId(), o.getOrderDate().getYear(), o.getOrderDate().getMonthValue()))).toList(); return customerProperties; }
public List<Order> waCustomerSelectManyNewOrders() { List<Customer> customers = getCustomerList(); List<parallel.linq101.datasource.Order> customerProperties = customers.stream().filter(c -> c.getRegion().equals("WA")).flatMap(c -> c.getOrders() .stream().filter(o -> o.getOrderDate().isAfter(LocalDate.of(1998, 1, 1)))).toList(); return customerProperties; }
public List<Pair<String, Order>> waCustomerSelectManyCustomerNewOrders() { List<Customer> customers = getCustomerList(); List<Pair<String, Order>> customerProperties = customers.stream().filter(c -> c.getRegion().equals("WA")).flatMap(c -> c.getOrders() .stream().filter(o -> o.getOrderDate().isAfter(LocalDate.of(1998, 1, 1))) .map(o -> Pair.with(c.getCustomerId(), o))).toList(); return customerProperties; }
public List<Pair<String, LocalDate>> waCustomerSelectManyCustomerNewOrderDates() { List<Customer> customers = getCustomerList(); List<Pair<String, LocalDate>> customerProperties = customers.stream().filter(c -> c.getRegion().equals("WA")).flatMap(c -> c.getOrders() .stream().filter(o -> o.getOrderDate().isAfter(LocalDate.of(1998, 1, 1))) .map(o -> Pair.with(c.getCustomerId(), o.getOrderDate()))).toList(); return customerProperties; }
public List<Triplet<String, Integer, Double>> waCustomerSelectManyCustomerNewOrderIdAndTotals() { List<Customer> customers = getCustomerList(); List<Triplet<String, Integer, Double>> customerProperties = customers.stream().filter(c -> c.getRegion().equals("WA")).flatMap(c -> c.getOrders() .stream().filter(o -> o.getOrderDate().isAfter(LocalDate.of(1998, 1, 1))) .map(o -> Triplet.with(c.getCustomerId(), o.getOrderId(), o.getTotal()))).toList(); return customerProperties; }
public List<Triplet<String, Integer, Integer>> waCustomerSelectManyCustomerNewOrderDateYearAndMonth() { List<Customer> customers = getCustomerList(); List<Triplet<String, Integer, Integer>> customerProperties = customers.stream().filter(c -> c.getRegion().equals("WA")).flatMap(c -> c.getOrders() .stream().filter(o -> o.getOrderDate().isAfter(LocalDate.of(1998, 1, 1))) .map(o -> Triplet.with(c.getCustomerId(), o.getOrderDate().getYear(), o.getOrderDate().getMonthValue()))).toList(); return customerProperties; }
public int[] indexedSelectMany() { int[] numbersA = {0, 2, 4, 5, 6, 8, 9}; int[] numbersB = {1, 3, 5, 7, 8}; int[] pairs = IntStream.range(0, numbersA.length).flatMap(i -> Arrays.stream(numbersB).map( b -> i % 2 == 0 ? numbersA[i] : b)).toArray(); return pairs; }
public int[] indexedSelectManyBig() { int[] numbersA = {0, 2, 4, 5, 6, 8, 9}; int[] numbersB = {1, 3, 5, 7, 8}; int[] pairs = IntStream.range(0, numbersA.length).flatMap(i -> Arrays.stream(numbersB).filter( b ->b<numbersA[i]+i)).toArray(); return pairs; }
public List<Order> customerIndexedSelectManyOrdersTake() { List<Customer> customers = getCustomerList(); List<Order> customerProperties = IntStream.range(0, customers.size()).boxed(). flatMap(i -> customers.get(i).getOrders().stream().limit(i<10?5:1)).toList(); return customerProperties; }
public List<Order> waCustomerIndexedSelectManyOrdersTake() { List<Customer> customers = getCustomerList(); List<Order> customerProperties = IntStream.range(0, customers.size()).boxed().filter(i->customers.get(i).getRegion().equals("WA")) .flatMap(i -> customers.get(i).getOrders().stream().limit(i<10?5:1)).toList(); return customerProperties; }
public List<String> indexedSelectManyString() { List<Customer> customers = getCustomerList(); List<String> customerOrders = IntStream.range(0, customers.size()).boxed().flatMap( i -> customers.get(i).getOrders().stream().map( o -> "Customer #" + (i + 1) + " has an order with OrderID " + o.getOrderId())) .collect(Collectors.toList()); return customerOrders; }
public int[] intPlusOne() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int[] numSelected = Arrays.stream(numbers).map(n -> n + 1).toArray(); return numSelected; }
public int[] oddIntPlusOne() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int[] numSelected = Arrays.stream(numbers).filter(n -> n % 2 == 1).map(n -> n + 1).toArray(); return numSelected; }
public int[] bigIntPlusOne() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int[] numSelected = Arrays.stream(numbers).filter(n -> n > 5).map(n -> n + 1).toArray(); return numSelected; }
public int[] intTwice() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int[] numSelected = Arrays.stream(numbers).map(n -> n * 2).toArray(); return numSelected; }
public int[] oddIntTwice() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int[] numSelected = Arrays.stream(numbers).filter(n -> n % 2 == 1).map(n -> n * 2).toArray(); return numSelected; }
public int[] bigIntTwice() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int[] numSelected = Arrays.stream(numbers).filter(n -> n > 5).map(n -> n * 2).toArray(); return numSelected; }
public Character[] stringFirstChar() { String[] strings = {"zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"}; Character[] selected = (Character[]) Arrays.stream(strings).map(w -> w.charAt(0)).toArray(); return selected; }
public Character[] shortStringFirstChar() { String[] strings = {"zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"}; Character[] selected = (Character[]) Arrays.stream(strings).filter(w -> w.length() < 4) .map(w -> w.charAt(0)).toArray(); return selected; }
public int[] stringLength() { String[] strings = {"zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"}; int[] selected = Arrays.stream(strings).mapToInt(w -> w.length()).toArray(); return selected; }
public int[] shortStringLength() { String[] strings = {"zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"}; int[] selected = Arrays.stream(strings).filter(w -> w.length() < 4).mapToInt(w -> w.length()).toArray(); return selected; }
public List<String> productName() { List<Product> products = getProductList(); List<String> productNames = products.stream().map(p -> p.getProductName()).toList(); return productNames; }
public List<Double> productUnitPrice() { List<Product> products = getProductList(); List<Double> productNames = products.stream().map(p -> p.getUnitPrice()).toList(); return productNames; }
public List<String> expensiveProductName() { List<Product> products = getProductList(); List<String> productNames = products.stream().filter(p -> p.getUnitPrice() > 100).map(p -> p.getProductName()).toList(); return productNames; }
public List<Double> expensiveProductUnitPrice() { List<Product> products = getProductList(); List<Double> productNames = products.stream().filter(p -> p.getUnitPrice() > 100).map(p -> p.getUnitPrice()).toList(); return productNames; }
public List<String> outOfStockProductName() { List<Product> products = getProductList(); List<String> productNames = products.stream().filter(p -> p.getUnitsInStock() == 0).map(p -> p.getProductName()).toList(); return productNames; }
public List<Double> outOfStockProductUnitPrice() { List<Product> products = getProductList(); List<Double> productNames = products.stream().filter(p -> p.getUnitsInStock() == 0).map(p -> p.getUnitPrice()).toList(); return productNames; }
public List<Pair<String, List<String>>> productGroupName() { List<Product> products = getProductList(); List<Pair<String, List<String>>> productNames = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().map(p -> p.getProductName()).toList())).toList(); return productNames; }
public Map<String, List<String>> productGroupNameDict() { List<Product> products = getProductList(); Map<String, List<String>> productNames = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().map(p -> p.getProductName()).toList())); return productNames; }
public List<Pair<String, List<Double>>> productGroupUnitPrice() { List<Product> products = getProductList(); List<Pair<String, List<Double>>> productNames = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().map(p -> p.getUnitPrice()).toList())).toList(); return productNames; }
public Map<String, List<Double>> productGroupUnitPriceDict() { List<Product> products = getProductList(); Map<String, List<Double>> productNames = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().map(p -> p.getUnitPrice()).toList())); return productNames; }
public int[] transformIndexToInt() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int[] textNums = Arrays.stream(numbers).map(n -> numbers[n]).toArray(); return textNums; }
public String[] transformIndexToString() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; String[] strings = {"zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"}; String[] textNums = (String[]) Arrays.stream(numbers).mapToObj(n -> strings[n]).toArray(); return textNums; }
public int[] transformIndexHashToInt() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int[] textNums = Arrays.stream(numbers).map(n -> numbers[n * 97 % 10]).toArray(); return textNums; }
public String[] transformIndexHashToString() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; String[] strings = {"zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"}; String[] textNums = (String[]) Arrays.stream(numbers).mapToObj(n -> numbers[n * 97 % 10]).toArray(); return textNums; }
public Pair<String, String>[] selectByCase() { String[] words = {"aPPLE", "BlUeBeRrY", "cHeRry"}; Pair<String, String>[] upperLowerWords = (Pair<String, String>[]) Arrays.stream(words).map(w -> Pair.with(w.toUpperCase(), w.toLowerCase())).toArray(); return upperLowerWords; }
public String[] selectByCaseConcat() { String[] words = {"aPPLE", "BlUeBeRrY", "cHeRry"}; String[] upperLowerWords = (String[]) Arrays.stream(words).map(w -> w.toUpperCase() + w.toLowerCase()).toArray(); return upperLowerWords; }
public Pair<String, Integer>[] selectByStringAndLength() { String[] words = {"aPPLE", "BlUeBeRrY", "cHeRry"}; Pair<String, Integer>[] upperLowerWords = (Pair<String, Integer>[]) Arrays.stream(words).map(w -> Pair.with(w, w.length())).toArray(); return upperLowerWords; }
public String[] selectByStringAndLengthConcat() { String[] words = {"aPPLE", "BlUeBeRrY", "cHeRry"}; String[] upperLowerWords = (String[]) Arrays.stream(words).map(w -> w + w.length()).toArray(); return upperLowerWords; }
public Pair<String, Boolean>[] selectByEvenOdd() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; String[] strings = {"zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"}; Pair<String, Boolean>[] evenOddWords = (Pair<String, Boolean>[]) Arrays.stream(numbers).mapToObj(n -> Pair.with(strings[n], n % 2 == 0)).toArray(); return evenOddWords; }
public String[] selectByEvenOddConcat() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; String[] strings = {"zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"}; String[] evenOddWords = (String[]) Arrays.stream(numbers).mapToObj(n -> strings[n] + (n % 2 == 0 ? " even" : " odd")).toArray(); return evenOddWords; }
public List<Pair<String, String>> customerIdAndName() { List<Customer> customers = getCustomerList(); List<Pair<String, String>> customerProperties = customers.stream().map(c -> Pair.with(c.getCustomerId(), c.getCompanyName())).toList(); return customerProperties; }
public List<Pair<String, String>> customerRegionAndCountry() { List<Customer> customers = getCustomerList(); List<Pair<String, String>> customerProperties = customers.stream().map(c -> Pair.with(c.getRegion(), c.getCountry())).toList(); return customerProperties; }
public List<Pair<String, String>> customerCityAndAddress() { List<Customer> customers = getCustomerList(); List<Pair<String, String>> customerProperties = customers.stream().map(c -> Pair.with(c.getCity(), c.getAddress())).toList(); return customerProperties; }
public List<Triplet<String, String, String>> customerRegionAndCountryAndCity() { List<Customer> customers = getCustomerList(); List<Triplet<String, String, String>> customerProperties = customers.stream().map(c -> Triplet.with(c.getRegion(), c.getCountry(), c.getCity())).toList(); return customerProperties; }
public List<Triplet<String, String, String>> customerCityAndAddressAndPostal() { List<Customer> customers = getCustomerList(); List<Triplet<String, String, String>> customerProperties = customers.stream().map(c -> Triplet.with(c.getCity(), c.getAddress(), c.getPostalCode())).toList(); return customerProperties; }
public List<Pair<String, List<Order>>> customerIdAndOrders() { List<Customer> customers = getCustomerList(); List<Pair<String, List<Order>>> customerProperties = customers.stream().map(c -> Pair.with(c.getCustomerId(), c.getOrders())).toList(); return customerProperties; }
public List<Pair<String, Integer>> customerIdAndOrdersCount() { List<Customer> customers = getCustomerList(); List<Pair<String, Integer>> customerProperties = customers.stream().map(c -> Pair.with(c.getCustomerId(), c.getOrders().size())).toList(); return customerProperties; }
public List<Pair<String, Order>> customerIdAndFirstOrder() { List<Customer> customers = getCustomerList(); List<Pair<String, Order>> customerProperties = customers.stream().map(c -> Pair.with(c.getCustomerId(), c.getOrders().stream().findFirst().get())).toList(); return customerProperties; }
public List<Pair<String, Order>> customerIdAndFirstOrDefaultOrder() { List<Customer> customers = getCustomerList(); List<Pair<String, Order>> customerProperties = customers.stream().map(c -> Pair.with(c.getCustomerId(), c.getOrders().stream().findFirst().orElse(Order.DEFAULT))).toList(); return customerProperties; }
public List<Pair<String, Double>> customerIdAndBiggestTotal() { List<Customer> customers = getCustomerList(); List<Pair<String, Double>> customerProperties = customers.stream().map(c -> Pair.with(c.getCustomerId(),c.getOrders().stream() .mapToDouble(o -> o.getTotal()).max().getAsDouble())).toList(); return customerProperties; }
public Boolean[] intWithIndex() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; Boolean[] numSelected = (Boolean[]) IntStream.range(0, numbers.length).mapToObj(i -> numbers[i] == i).toArray(); return numSelected; }
public int[] intAddIndex() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int[] numSelected = IntStream.range(0, numbers.length).map(i -> numbers[i] + i).toArray(); return numSelected; }
public Boolean[] oddIntWithIndex() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int[] oddNumbers = Arrays.stream(numbers).filter(n -> n % 2 == 1).toArray(); Boolean[] numSelected = (Boolean[]) IntStream.range(0, oddNumbers.length).mapToObj(i -> oddNumbers[i] == i).toArray(); return numSelected; }
public int[] oddIntAddIndex() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int[] oddNumbers = Arrays.stream(numbers).filter(n -> n % 2 == 1).toArray(); int[] numSelected = IntStream.range(0, oddNumbers.length).map(i -> oddNumbers[i] + i).toArray(); return numSelected; }
public Boolean[] oddIntWithOriginalIndex() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; Boolean[] numSelected = (Boolean[]) IntStream.range(0, numbers.length).filter(i -> numbers[i] % 2 == 1).mapToObj(i -> numbers[i] == i).toArray(); return numSelected; }
public int[] oddIntAddOriginalIndex() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int[] numSelected = IntStream.range(0, numbers.length).filter(i -> numbers[i] % 2 == 1).map(i -> numbers[i] + i).toArray(); return numSelected; }
public Boolean[] bigIntWithIndex() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int[] bigNumbers = Arrays.stream(numbers).filter(n -> n > 5).toArray(); Boolean[] numSelected = (Boolean[]) IntStream.range(0, bigNumbers.length).mapToObj(i -> bigNumbers[i] == i).toArray(); return numSelected; }
public int[] bigIntAddIndex() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int[] bigNumbers = Arrays.stream(numbers).filter(n -> n > 5).toArray(); int[] numSelected = IntStream.range(0, bigNumbers.length).map(i -> bigNumbers[i] + i).toArray(); return numSelected; }
public Boolean[] bigIntWithOriginalIndex() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; Boolean[] numSelected = (Boolean[]) IntStream.range(0, numbers.length).filter(i -> numbers[i] > 5).filter(i -> numbers[i] % 2 == 1) .mapToObj(i -> numbers[i] == i).toArray(); return numSelected; }
public int[] bigIntAddOriginalIndex() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int[] numSelected = IntStream.range(0, numbers.length).filter(i -> numbers[i] > 5).filter(i -> numbers[i] % 2 == 1).map(i -> numbers[i] + i).toArray(); return numSelected; }
public int[] intUnion() { int[] numbersA = {0, 2, 4, 5, 9}; int[] numbersB = {0, 2, 4, 5, 9}; int[] uniqueNumbers = IntStream.concat(Arrays.stream(numbersA), Arrays.stream(numbersB)).distinct().toArray(); return uniqueNumbers; }
public double[] doubleUnion() { double[] numbersA = {0.1, 2.2, 4.3, 5.4, 6.5, 8.6, 9.7}; double[] numbersB = {0.1, 3.3, 5.4, 7.7, 8.6}; double[] uniqueNumbers = DoubleStream.concat(Arrays.stream(numbersA), Arrays.stream(numbersB)).distinct().toArray(); return uniqueNumbers; }
public String[] stringUnion() { String[] wordsA = {"Alice", "Bob", "Foo", "Bar"}; String[] wordsB = {"Cafe", "Bar", "Restaurant"}; String[] uniqueWords = (String[]) Stream.concat(Arrays.stream(wordsA), Arrays.stream(wordsB)).distinct().toArray(); return uniqueWords; }
public int[] projectionIntUnion() { int[] numbersA = {0, 2, 4, 5, 6, 8, 9}; int[] numbersB = {1, 3, 5, 7, 8}; var first = Arrays.stream(numbersA).map(n -> n + 1); var second = Arrays.stream(numbersB).map(n -> n - 1); int[] uniqueNumbers = IntStream.concat(first, second).distinct().toArray(); return uniqueNumbers; }
public double[] projectionDoubleUnion() { double[] numbersA = {0.1, 2.2, 4.3, 5.4, 6.5, 8.6, 9.7}; double[] numbersB = {0.1, 3.3, 5.4, 7.7, 8.6}; var first = Arrays.stream(numbersA).map(n -> n - (int) n); var second = Arrays.stream(numbersB).map(n -> n - (int) n); double[] uniqueNumbers = DoubleStream.concat(first, second).distinct().toArray(); return uniqueNumbers; }
public Character[] projectionStringUnion() { String[] wordsA = {"Alice", "Bob", "Foo", "Bar"}; String[] wordsB = {"Cafe", "Bar", "Restaurant"}; var first = Arrays.stream(wordsA).map(n -> n.charAt(0)); var second = Arrays.stream(wordsB).map(n -> n.charAt(0)); Character[] uniqueWords = (Character[]) Stream.concat(first, second).distinct().toArray(); return uniqueWords; }
public List<String> unionOfCategory() { String[] categories = {"Furnitures", "Seagoods"}; List<Product> products = getProductList(); var productCategories = products.stream().map(p -> p.getCategory()); List<String> uniqueCategories = Stream.concat(productCategories, Arrays.stream(categories)).distinct().toList(); return uniqueCategories; }
public List<String> unionOfRegion() { String[] regions = {"WA", "AF", "RO"}; List<Customer> customers = getCustomerList(); var customerRegions = customers.stream().map(c -> c.getRegion()); List<String> uniqueRegions = Stream.concat(customerRegions, Arrays.stream(regions)).distinct().toList(); return uniqueRegions; }
public List<String> unionOfName() { List<Product> products = getProductList(); List<Customer> customers = getCustomerList(); var productNames = products.stream().map(p -> p.getProductName()); var customerNames = customers.stream().map(c -> c.getCompanyName()); List<String> uniqueNames = Stream.concat(productNames, customerNames).distinct().toList(); return uniqueNames; }
public List<Character> unionOfNameFirstChar() { List<Product> products = getProductList(); List<Customer> customers = getCustomerList(); var productFirstChars = products.stream().map(p -> p.getProductName().charAt(0)); var customerFirstChars = customers.stream().map(c -> c.getCompanyName().charAt(0)); List<Character> uniqueFirstChars = Stream.concat(productFirstChars, customerFirstChars).distinct().toList(); return uniqueFirstChars; }
public int[] intIntersect() { int[] numbersA = {0, 2, 4, 5, 9}; int[] numbersB = {0, 2, 4, 5, 9}; int[] sharedNumbers = Arrays.stream(numbersA).distinct().filter(a -> Arrays.stream(numbersB).anyMatch(b -> b == a)).toArray(); return sharedNumbers; }
public double[] doubleIntersect() { double[] numbersA = {0.1, 2.2, 4.3, 5.4, 6.5, 8.6, 9.7}; double[] numbersB = {0.1, 3.3, 5.4, 7.7, 8.6}; double[] sharedNumbers = Arrays.stream(numbersA).distinct().filter(a -> Arrays.stream(numbersB).anyMatch(b -> b == a)).toArray(); return sharedNumbers; }
public String[] stringIntersect() { String[] wordsA = {"Alice", "Bob", "Foo", "Bar"}; String[] wordsB = {"Cafe", "Bar", "Restaurant"}; String[] sharedWords = (String[]) Arrays.stream(wordsA).distinct().filter(a -> Arrays.stream(wordsB).anyMatch(b -> b.equals(a))).toArray(); return sharedWords; }
public int[] projectionIntIntersect() { int[] numbersA = {0, 2, 4, 5, 6, 8, 9}; int[] numbersB = {1, 3, 5, 7, 8}; var first = Arrays.stream(numbersA).map(n -> n + 1); var second = Arrays.stream(numbersB).map(n -> n - 1); int[] sharedNumbers = first.distinct().filter(a -> second.anyMatch(b -> b == a)).toArray(); return sharedNumbers; }
public double[] projectionDoubleIntersect() { double[] numbersA = {0.1, 2.2, 4.3, 5.4, 6.5, 8.6, 9.7}; double[] numbersB = {0.1, 3.3, 5.4, 7.7, 8.6}; var first = Arrays.stream(numbersA).map(n -> n - (int) n); var second = Arrays.stream(numbersB).map(n -> n - (int) n); double[] sharedNumbers = first.distinct().filter(a -> second.anyMatch(b -> b == a)).toArray(); return sharedNumbers; }
public Character[] projectionStringIntersect() { String[] wordsA = {"Alice", "Bob", "Foo", "Bar"}; String[] wordsB = {"Cafe", "Bar", "Restaurant"}; var first = Arrays.stream(wordsA).map(n -> n.charAt(0)); var second = Arrays.stream(wordsB).map(n -> n.charAt(0)); Character[] sharedWords = (Character[]) first.distinct().filter(a -> second.anyMatch(b -> b == a)).toArray(); return sharedWords; }
public List<String> intersectOfCategory() { String[] categories = {"Furnitures", "Seagoods"}; List<Product> products = getProductList(); var productCategories = products.stream().map(p -> p.getCategory()); List<String> sharedCategories = productCategories.distinct().filter(a -> Arrays.stream(categories).anyMatch(b -> b.equals(a))).toList(); return sharedCategories; }
public List<String> intersectOfRegion() { String[] regions = {"WA", "AF", "RO"}; List<Customer> customers = getCustomerList(); var customerRegions = customers.stream().map(c -> c.getRegion()); List<String> sharedRegions = customerRegions.distinct().filter(a -> Arrays.stream(regions).anyMatch(b -> b.equals(a))).toList(); return sharedRegions; }
public List<String> intersectOfName() { List<Product> products = getProductList(); List<Customer> customers = getCustomerList(); var productNames = products.stream().map(p -> p.getProductName()); var customerNames = customers.stream().map(c -> c.getCompanyName()); List<String> sharedNames = productNames.distinct().filter(a -> customerNames.anyMatch(b -> b.equals(a))).toList(); return sharedNames; }
public List<Character> intersectOfNameFirstChar() { List<Product> products = getProductList(); List<Customer> customers = getCustomerList(); var productFirstChars = products.stream().map(p -> p.getProductName().charAt(0)); var customerFirstChars = customers.stream().map(c -> c.getCompanyName().charAt(0)); List<Character> sharedFirstChars = productFirstChars.distinct().filter(a -> customerFirstChars.anyMatch(b -> b == a)).toList(); return sharedFirstChars; }
public int[] intExcept() { int[] numbersA = {0, 2, 4, 5, 9}; int[] numbersB = {0, 2, 4, 5, 9}; int[] differemtNumbers = Arrays.stream(numbersA).distinct().filter(a -> Arrays.stream(numbersB).allMatch(b -> b != a)).toArray(); return differemtNumbers; }
public double[] doubleExcept() { double[] numbersA = {0.1, 2.2, 4.3, 5.4, 6.5, 8.6, 9.7}; double[] numbersB = {0.1, 3.3, 5.4, 7.7, 8.6}; double[] differemtNumbers = Arrays.stream(numbersA).distinct().filter(a -> Arrays.stream(numbersB).allMatch(b -> b != a)).toArray(); return differemtNumbers; }
public String[] stringExcept() { String[] wordsA = {"Alice", "Bob", "Foo", "Bar"}; String[] wordsB = {"Cafe", "Bar", "Restaurant"}; String[] differemtWords = (String[]) Arrays.stream(wordsA).distinct().filter(a -> Arrays.stream(wordsB).allMatch(b -> !b.equals(a))).toArray(); return differemtWords; }
public int[] projectionIntExcept() { int[] numbersA = {0, 2, 4, 5, 6, 8, 9}; int[] numbersB = {1, 3, 5, 7, 8}; var first = Arrays.stream(numbersA).map(n -> n + 1); var second = Arrays.stream(numbersB).map(n -> n - 1); int[] differemtNumbers = first.distinct().filter(a -> second.allMatch(b -> b != a)).toArray(); return differemtNumbers; }
public double[] projectionDoubleExcept() { double[] numbersA = {0.1, 2.2, 4.3, 5.4, 6.5, 8.6, 9.7}; double[] numbersB = {0.1, 3.3, 5.4, 7.7, 8.6}; var first = Arrays.stream(numbersA).map(n -> n - (int) n); var second = Arrays.stream(numbersB).map(n -> n - (int) n); double[] differemtNumbers = first.distinct().filter(a -> second.allMatch(b -> b != a)).toArray(); return differemtNumbers; }
public Character[] projectionStringExcept() { String[] wordsA = {"Alice", "Bob", "Foo", "Bar"}; String[] wordsB = {"Cafe", "Bar", "Restaurant"}; var first = Arrays.stream(wordsA).map(n -> n.charAt(0)); var second = Arrays.stream(wordsB).map(n -> n.charAt(0)); Character[] differemtWords = (Character[]) first.distinct().filter(a -> second.allMatch(b -> b != a)).toArray(); return differemtWords; }
public List<String> exceptOfCategory() { String[] categories = {"Furnitures", "Seagoods"}; List<Product> products = getProductList(); var productCategories = products.stream().map(p -> p.getCategory()); List<String> differemtCategories = productCategories.distinct().filter(a -> Arrays.stream(categories).allMatch(b -> !b.equals(a))).toList(); return differemtCategories; }
public List<String> exceptOfRegion() { String[] regions = {"WA", "AF", "RO"}; List<Customer> customers = getCustomerList(); var customerRegions = customers.stream().map(c -> c.getRegion()); List<String> differemtRegions = customerRegions.distinct().filter(a -> Arrays.stream(regions).allMatch(b -> !b.equals(a))).toList(); return differemtRegions; }
public List<String> exceptOfName() { List<Product> products = getProductList(); List<Customer> customers = getCustomerList(); var productNames = products.stream().map(p -> p.getProductName()); var customerNames = customers.stream().map(c -> c.getCompanyName()); List<String> differemtNames = productNames.distinct().filter(a -> customerNames.allMatch(b -> !b.equals(a))).toList(); return differemtNames; }
public List<Character> exceptOfNameFirstChar() { List<Product> products = getProductList(); List<Customer> customers = getCustomerList(); var productFirstChars = products.stream().map(p -> p.getProductName().charAt(0)); var customerFirstChars = customers.stream().map(c -> c.getCompanyName().charAt(0)); List<Character> differemtFirstChars = productFirstChars.distinct().filter(a -> customerFirstChars.allMatch(b -> b != a)).toList(); return differemtFirstChars; }
public List<Integer> intSkip() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; List<Integer> after3Numbers = Arrays.stream(numbers).skip(3).boxed().toList(); return after3Numbers; }
public List<Integer> oddIntSkip() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; List<Integer> after3Numbers = Arrays.stream(numbers).filter(i -> i % 2 == 1).skip(3).boxed().toList(); return after3Numbers; }
public List<Integer> intSquareSkip() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; List<Integer> after3Numbers = Arrays.stream(numbers).map(i -> i * i).skip(3).boxed().toList(); return after3Numbers; }
public List<Integer> intSkipCount(int n) { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; List<Integer> after3Numbers = Arrays.stream(numbers).skip(n).boxed().toList(); return after3Numbers; }
public List<Integer> intSkipCount(int[] numbers, int n) { List<Integer> afterNNumbers = Arrays.stream(numbers).skip(n).boxed().toList(); return afterNNumbers; }
public List<String> stringSkip() { String[] words = {"cherry", "apple", "blueberry", "banana", "abacus"}; List<String> afterNNumbers = Arrays.stream(words).skip(3).toList(); return afterNNumbers; }
public List<String> longStringSkip() { String[] words = {"cherry", "apple", "blueberry", "banana", "abacus"}; List<String> after3Words = Arrays.stream(words).filter(w -> w.length() > 5).skip(3).toList(); return after3Words; }
public List<Integer> stringLengthSkip() { String[] words = {"cherry", "apple", "blueberry", "banana", "abacus"}; List<Integer> after3Words = Arrays.stream(words).map(w -> w.length()).skip(3).toList(); return after3Words; }
public List<String> stringSkipCount(int n) { String[] words = {"cherry", "apple", "blueberry", "banana", "abacus"}; List<String> afterNWords = Arrays.stream(words).skip(3).toList(); return afterNWords; }
public List<String> stringSkipCount(String[] strings, int n) { List<String> afterNWords = Arrays.stream(strings).skip(3).toList(); return afterNWords; }
public List<Product> productSkip() { List<Product> products = getProductList(); List<Product> after3Products = products.stream().skip(3).toList(); return after3Products; }
public List<Product> expensiveProductSkip() { List<Product> products = getProductList(); List<Product> after3Products = products.stream().filter(p -> p.getUnitPrice() > 100).skip(3).toList(); return after3Products; }
public List<Product> inStockProductSkip() { List<Product> products = getProductList(); List<Product> after3Products = products.stream().filter(p -> p.getUnitsInStock() > 100).skip(3).toList(); return after3Products; }
public Map<String, List<Product>> productGroupSkip() { List<Product> products = getProductList(); Map<String, List<Product>> after3Groups = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().skip(3).collect(toMap(g -> g.getKey(), g -> g.getValue())); return after3Groups; }
public Map<String, List<Product>> productEachGroupSkip() { List<Product> products = getProductList(); Map<String, List<Product>> after3EachGroups = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().skip(3).toList())); return after3EachGroups; }
public List<Order> customerOrdersSkip() { List<Customer> customers = getCustomerList(); List<Order> after3Orders = customers.stream().flatMap(c -> c.getOrders().stream()).skip(3).toList(); return after3Orders; }
public List<Pair<String, LocalDate>> customerOrdersNestedSkip() { List<Customer> customers = getCustomerList(); List<Pair<String, LocalDate>> after3Orders = customers.stream().flatMap(c -> c.getOrders().stream() .map(o -> Pair.with(c.getCustomerId(), o.getOrderDate()))).skip(3).toList(); return after3Orders; }
public List<Pair<String, LocalDate>> customerOrdersEachNestedSkip() { List<Customer> customers = getCustomerList(); List<Pair<String, LocalDate>> after3EachOrders = customers.stream().flatMap(c -> c.getOrders().stream().skip(3) .map(o -> Pair.with(c.getCustomerId(), o.getOrderDate()))).toList(); return after3EachOrders; }
public List<Pair<String, LocalDate>> waCustomerOrdersNestedSkip() { List<Customer> customers = getCustomerList(); List<Pair<String, LocalDate>> after3WAOrders = customers.stream().filter(c -> c.getRegion().equals("WA")) .flatMap(c -> c.getOrders().stream().map(o -> Pair.with(c.getCustomerId(), o.getOrderDate()))).skip(3).toList(); return after3WAOrders; }
public List<Pair<String, LocalDate>> waCustomerOrdersEachNestedSkip() { List<Customer> customers = getCustomerList(); List<Pair<String, LocalDate>> after3EachWAOrders = customers.stream().filter(c -> c.getRegion().equals("WA")) .flatMap(c -> c.getOrders().stream().skip(3).map(o -> Pair.with(c.getCustomerId(), o.getOrderDate()))).toList(); return after3EachWAOrders; }
public List<Integer> intSkipWhile() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; List<Integer> after3Numbers = Arrays.stream(numbers).dropWhile(i -> i > 3).boxed().toList(); return after3Numbers; }
public List<Integer> oddIntSkipWhile() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; List<Integer> after3Numbers = Arrays.stream(numbers).filter(i -> i % 2 == 1).dropWhile(i -> i > 3).boxed().toList(); return after3Numbers; }
public List<Integer> intSquareSkipWhile() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; List<Integer> after3Numbers = Arrays.stream(numbers).map(i -> i * i).dropWhile(i -> i > 3).boxed().toList(); return after3Numbers; }
public List<Integer> intSkipWhileCount(int n) { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; List<Integer> after3Numbers = Arrays.stream(numbers).dropWhile(i -> i > n).boxed().toList(); return after3Numbers; }
public List<Integer> intSkipWhileCount(int[] numbers, int n) { List<Integer> afterNNumbers = Arrays.stream(numbers).dropWhile(i -> i > n).boxed().toList(); return afterNNumbers; }
public List<String> stringSkipWhile() { String[] words = {"cherry", "apple", "blueberry", "banana", "abacus"}; List<String> afterNNumbers = Arrays.stream(words).dropWhile(w -> w.charAt(0) > 'b').toList(); return afterNNumbers; }
public List<String> longStringSkipWhile() { String[] words = {"cherry", "apple", "blueberry", "banana", "abacus"}; List<String> after3Words = Arrays.stream(words).filter(w -> w.length() > 5).dropWhile(w -> w.charAt(0) > 'b').toList(); return after3Words; }
public List<Integer> stringLengthSkipWhile() { String[] words = {"cherry", "apple", "blueberry", "banana", "abacus"}; List<Integer> after3Words = Arrays.stream(words).map(w -> w.length()).dropWhile(n -> n > 5).toList(); return after3Words; }
public List<String> stringSkipWhileCount(char c) { String[] words = {"cherry", "apple", "blueberry", "banana", "abacus"}; List<String> afterNWords = Arrays.stream(words).dropWhile(w -> w.charAt(0) > c).toList(); return afterNWords; }
public List<String> stringSkipWhileCount(String[] strings, char c) { List<String> afterNWords = Arrays.stream(strings).dropWhile(w -> w.charAt(0) > c).toList(); return afterNWords; }
public List<Product> productSkipWhile() { List<Product> products = getProductList(); List<Product> after3Products = products.stream().dropWhile(p -> p.getProductId() > 100).toList(); return after3Products; }
public List<Product> expensiveProductSkipWhile() { List<Product> products = getProductList(); List<Product> after3Products = products.stream().filter(p -> p.getUnitPrice() > 100).dropWhile(p -> p.getProductId() > 100).toList(); return after3Products; }
public List<Product> inStockProductSkipWhile() { List<Product> products = getProductList(); List<Product> after3Products = products.stream().filter(p -> p.getUnitsInStock() > 100).dropWhile(p -> p.getProductId() > 100).toList(); return after3Products; }
public Map<String, List<Product>> productGroupSkipWhile() { List<Product> products = getProductList(); Map<String, List<Product>> after3Groups = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().dropWhile(g -> g.getKey().length() > 6).collect(toMap(g -> g.getKey(), g -> g.getValue())); return after3Groups; }
public Map<String, List<Product>> productEachGroupSkipWhile() { List<Product> products = getProductList(); Map<String, List<Product>> after3EachGroups = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().dropWhile(p -> p.getProductId() > 100).toList())); return after3EachGroups; }
public List<Order> customerOrdersSkipWhile() { List<Customer> customers = getCustomerList(); List<Order> after3Orders = customers.stream().flatMap(c -> c.getOrders().stream()) .dropWhile(o -> o.getOrderDate().isAfter(LocalDate.of(2000, 1, 1))).toList(); return after3Orders; }
public List<Pair<String, LocalDate>> customerOrdersNestedSkipWhile() { List<Customer> customers = getCustomerList(); List<Pair<String, LocalDate>> after3Orders = customers.stream().flatMap(c -> c.getOrders().stream() .map(o -> Pair.with(c.getCustomerId(), o.getOrderDate()))) .dropWhile(t -> t.getValue1().isAfter(LocalDate.of(2000, 1, 1))).toList(); return after3Orders; }
public List<Pair<String, LocalDate>> customerOrdersEachNestedSkipWhile() { List<Customer> customers = getCustomerList(); List<Pair<String, LocalDate>> after3EachOrders = customers.stream().flatMap(c -> c.getOrders().stream() .dropWhile(o -> o.getOrderDate().isAfter(LocalDate.of(2000, 1, 1))) .map(o -> Pair.with(c.getCustomerId(), o.getOrderDate()))).toList(); return after3EachOrders; }
public List<Pair<String, LocalDate>> waCustomerOrdersNestedSkipWhile() { List<Customer> customers = getCustomerList(); List<Pair<String, LocalDate>> after3WAOrders = customers.stream().filter(c -> c.getRegion().equals("WA")) .flatMap(c -> c.getOrders().stream().map(o -> Pair.with(c.getCustomerId(), o.getOrderDate()))) .dropWhile(t -> t.getValue1().isAfter(LocalDate.of(2000, 1, 1))).toList(); return after3WAOrders; }
public List<Pair<String, LocalDate>> waCustomerOrdersEachNestedSkipWhile() { List<Customer> customers = getCustomerList(); List<Pair<String, LocalDate>> after3EachWAOrders = customers.stream().filter(c -> c.getRegion().equals("WA")) .flatMap(c -> c.getOrders().stream().dropWhile(o -> o.getOrderDate() .isAfter(LocalDate.of(2000, 1, 1))) .map(o -> Pair.with(c.getCustomerId(), o.getOrderDate()))).toList(); return after3EachWAOrders; }
public List<Integer> intSkipWhileIndexed() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; List<Integer> afterNumbers = IntStream.range(0, numbers.length) .dropWhile(i -> numbers[i] > i).map(i -> numbers[i]).boxed().toList(); return afterNumbers; }
public List<Integer> intSquareSkipWhileIndexed() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; List<Integer> afterNumbers =  IntStream.range(0, numbers.length) .dropWhile(i -> numbers[i]*numbers[i] > i).map(i -> numbers[i]*numbers[i]).boxed().toList(); return afterNumbers; }
public List<Double> intSqrtSkipWhileIndexed() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; List<Double> afterNumbers =  IntStream.range(0, numbers.length) .dropWhile(i -> Math.sqrt(numbers[i]) > i).mapToDouble(i -> Math.sqrt(numbers[i]) ).boxed().toList(); return afterNumbers; }
public List<Integer> intSkipWhileIndexedCount(int n) { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; List<Integer> afterNumbers = IntStream.range(0, numbers.length) .dropWhile(i -> n > i).map(i -> numbers[i]).boxed().toList(); return afterNumbers; }
public List<Integer> intSkipWhileIndexedCount(int[] numbers, int n) { List<Integer> afterNumbers = IntStream.range(0, numbers.length) .dropWhile(i -> n > i).map(i -> numbers[i]).boxed().toList(); return afterNumbers; }
public int numbersSum() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int numbersSum = Arrays.stream(numbers).sum(); return numbersSum; }
public int bigNumbersSum() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int numbersSum = Arrays.stream(numbers).filter(n -> n >= 5).sum(); return numbersSum; }
public int oddNumbersSum() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int numbersSum = Arrays.stream(numbers).filter(n -> n % 2 == 0).sum(); return numbersSum; }
public double doubleSum() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; double numbersSum = Arrays.stream(numbers).sum(); return numbersSum; }
public double bigDoubleNumbersSum() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; double numbersSum = Arrays.stream(numbers).filter(n -> n >= 5).sum(); return numbersSum; }
public int numbersSumTwice() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int numbersSum = Arrays.stream(numbers).map(n -> n * 2).sum(); return numbersSum; }
public int bigNumbersSumTwice() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int numbersSum = Arrays.stream(numbers).filter(n -> n >= 5).map(n -> n * 2).sum(); return numbersSum; }
public int oddNumbersSumTwice() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int numbersSum = Arrays.stream(numbers).filter(n -> n % 2 == 0).map(n -> n * 2).sum(); return numbersSum; }
public int stringSumLength() { String[] words = {"cherry", "apple", "blueberry"}; int totalChars = Arrays.stream(words).mapToInt(w -> w.length()).sum(); return totalChars; }
public int shortStringSumLength() { String[] words = {"cherry", "apple", "blueberry"}; int totalChars = Arrays.stream(words).filter(w -> w.length() < 7).mapToInt(w -> w.length()).sum(); return totalChars; }
public double productUnitPriceSum() { List<Product> products = getProductList(); double totalSum = products.stream().mapToDouble(p -> p.getUnitPrice()).sum(); return totalSum; }
public double expensiveProductUnitPriceSum() { List<Product> products = getProductList(); double totalSum = products.stream().filter(p -> p.getUnitPrice() > 100) .mapToDouble(p -> p.getUnitPrice()).sum(); return totalSum; }
public int expensiveProductStockSum() { List<Product> products = getProductList(); int totalSum = products.stream().filter(p -> p.getUnitPrice() > 100) .mapToInt(p -> p.getUnitsInStock()).sum(); return totalSum; }
public int productLongNameLengthSum() { List<Product> products = getProductList(); int totalSum = products.stream().map(p -> p.getProductName()) .filter(name -> name.length() > 7).mapToInt(name -> name.length()).sum(); return totalSum; }
public List<Pair<String, Double>> customerOrdersTotalSum() { List<Customer> customers = getCustomerList(); List<Pair<String, Double>> ordersTotalSum = customers.stream().map(c -> Pair.with(c.getCustomerId(), c.getOrders().stream().mapToDouble(o -> o.getTotal()).sum())).toList(); return ordersTotalSum; }
public Map<String, Double> customerOrdersTotalSumDict() { List<Customer> customers = getCustomerList(); Map<String, Double> ordersTotalSum = customers.stream().collect(toMap(c -> c.getCustomerId(), c -> c.getOrders().stream().mapToDouble(o -> o.getTotal()).sum())); return ordersTotalSum; }
public List<Pair<String, Double>> customerInRegionOrdersTotalSum(String region) { List<Customer> customers = getCustomerList(); List<Pair<String, Double>> ordersTotalSum = customers.stream().filter(c -> c.getRegion().equals(region)) .map(c -> Pair.with(c.getCustomerId(), c.getOrders().stream().mapToDouble(o -> o.getTotal()).sum())).toList(); return ordersTotalSum; }
public Map<String, Double> customerInRegionOrdersTotalSumDict(String region) { List<Customer> customers = getCustomerList(); Map<String, Double> ordersTotalSum = customers.stream().filter(c -> c.getRegion().equals(region)) .collect(toMap(c -> c.getCustomerId(), c -> c.getOrders().stream().mapToDouble(o -> o.getTotal()).sum())); return ordersTotalSum; }
public List<Pair<String, Double>> customerExpensiveOrdersTotalSum() { List<Customer> customers = getCustomerList(); List<Pair<String, Double>> ordersTotalSum = customers.stream().map(c -> Pair.with(c.getCustomerId(), c.getOrders().stream().filter(o -> o.getTotal() > 100) .mapToDouble(o -> o.getTotal()).sum())).toList(); return ordersTotalSum; }
public Map<String, Double> customerExpensiveOrdersTotalSumDict() { List<Customer> customers = getCustomerList(); Map<String, Double> ordersTotalSum = customers.stream().collect(toMap(c -> c.getCustomerId(), c -> c.getOrders().stream().filter(o -> o.getTotal() > 100) .mapToDouble(o -> o.getTotal()).sum())); return ordersTotalSum; }
public List<Pair<String, Integer>> productEachCategoryStock() { List<Product> products = getProductList(); List<Pair<String, Integer>> categories = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().mapToInt(p -> p.getUnitsInStock()).sum())).toList(); return categories; }
public Map<String, Integer> productEachCategoryStockDict() { List<Product> products = getProductList(); Map<String, Integer> categories = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().mapToInt(p -> p.getUnitsInStock()).sum())); return categories; }
public List<Pair<String, Integer>> expensiveProductEachCategoryStock() { List<Product> products = getProductList(); List<Pair<String, Integer>> categories = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().filter( p -> p.getUnitPrice() > 100).mapToInt(p -> p.getUnitsInStock()).sum())).toList(); return categories; }
public Map<String, Integer> expensiveProductEachCategoryStockDict() { List<Product> products = getProductList(); Map<String, Integer> categories = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().filter( p -> p.getUnitPrice() > 100).mapToInt(p -> p.getUnitsInStock()).sum())); return categories; }
public List<Pair<String, Integer>> customerEachRegionOrdersSum() { List<Customer> customers = getCustomerList(); List<Pair<String, Integer>> ordersSum = customers.stream().collect(groupingBy(c -> c.getRegion())) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().mapToInt(c -> c.getOrders().size()).sum())).toList(); return ordersSum; }
public Map<String, Integer> customerEachRegionOrdersSumDict() { List<Customer> customers = getCustomerList(); Map<String, Integer> ordersSum = customers.stream().collect(groupingBy(c -> c.getRegion())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().mapToInt(c -> c.getOrders().size()).sum())); return ordersSum; }
public List<Pair<String, Integer>> customerEachCountryOrdersSum() { List<Customer> customers = getCustomerList(); List<Pair<String, Integer>> ordersSum = customers.stream().collect(groupingBy(c -> c.getCountry())) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().mapToInt(c -> c.getOrders().size()).sum())).toList(); return ordersSum; }
public Map<String, Integer> customerEachCountryOrdersSumDict() { List<Customer> customers = getCustomerList(); Map<String, Integer> ordersSum = customers.stream().collect(groupingBy(c -> c.getCountry())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().mapToInt(c -> c.getOrders().size()).sum())); return ordersSum; }
public List<Pair<String, Double>> customerEachRegionOrdersTotalSum() { List<Customer> customers = getCustomerList(); List<Pair<String, Double>> ordersTotalSum = customers.stream().collect(groupingBy(c -> c.getRegion())) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().flatMap(c -> c.getOrders().stream()).mapToDouble(o -> o.getTotal()).sum())).toList(); return ordersTotalSum; }
public Map<String, Double> customerEachRegionOrdersTotalSumDict() { List<Customer> customers = getCustomerList(); Map<String, Double> ordersTotalSum = customers.stream().collect(groupingBy(c -> c.getRegion())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().flatMap(c -> c.getOrders().stream()).mapToDouble(o -> o.getTotal()).sum())); return ordersTotalSum; }
public List<Integer> intTake() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; List<Integer> after3Numbers = Arrays.stream(numbers).limit(3).boxed().toList(); return after3Numbers; }
public List<Integer> oddIntTake() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; List<Integer> after3Numbers = Arrays.stream(numbers).filter(i -> i % 2 == 1).limit(3).boxed().toList(); return after3Numbers; }
public List<Integer> intSquareTake() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; List<Integer> after3Numbers = Arrays.stream(numbers).map(i -> i * i).limit(3).boxed().toList(); return after3Numbers; }
public List<Integer> intTakeCount(int n) { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; List<Integer> after3Numbers = Arrays.stream(numbers).limit(n).boxed().toList(); return after3Numbers; }
public List<Integer> intTakeCount(int[] numbers, int n) { List<Integer> afterNNumbers = Arrays.stream(numbers).limit(n).boxed().toList(); return afterNNumbers; }
public List<String> stringTake() { String[] words = {"cherry", "apple", "blueberry", "banana", "abacus"}; List<String> afterNNumbers = Arrays.stream(words).limit(3).toList(); return afterNNumbers; }
public List<String> longStringTake() { String[] words = {"cherry", "apple", "blueberry", "banana", "abacus"}; List<String> after3Words = Arrays.stream(words).filter(w -> w.length() > 5).limit(3).toList(); return after3Words; }
public List<Integer> stringLengthTake() { String[] words = {"cherry", "apple", "blueberry", "banana", "abacus"}; List<Integer> after3Words = Arrays.stream(words).map(w -> w.length()).limit(3).toList(); return after3Words; }
public List<String> stringTakeCount(int n) { String[] words = {"cherry", "apple", "blueberry", "banana", "abacus"}; List<String> afterNWords = Arrays.stream(words).limit(3).toList(); return afterNWords; }
public List<String> stringTakeCount(String[] strings, int n) { List<String> afterNWords = Arrays.stream(strings).limit(3).toList(); return afterNWords; }
public List<Product> productTake() { List<Product> products = getProductList(); List<Product> after3Products = products.stream().limit(3).toList(); return after3Products; }
public List<Product> expensiveProductTake() { List<Product> products = getProductList(); List<Product> after3Products = products.stream().filter(p -> p.getUnitPrice() > 100).limit(3).toList(); return after3Products; }
public List<Product> inStockProductTake() { List<Product> products = getProductList(); List<Product> after3Products = products.stream().filter(p -> p.getUnitsInStock() > 100).limit(3).toList(); return after3Products; }
public Map<String, List<Product>> productGroupTake() { List<Product> products = getProductList(); Map<String, List<Product>> after3Groups = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().limit(3).collect(toMap(g -> g.getKey(), g -> g.getValue())); return after3Groups; }
public Map<String, List<Product>> productEachGroupTake() { List<Product> products = getProductList(); Map<String, List<Product>> after3EachGroups = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().limit(3).toList())); return after3EachGroups; }
public List<Order> customerOrdersTake() { List<Customer> customers = getCustomerList(); List<Order> after3Orders = customers.stream().flatMap(c -> c.getOrders().stream()).limit(3).toList(); return after3Orders; }
public List<Pair<String, LocalDate>> customerOrdersNestedTake() { List<Customer> customers = getCustomerList(); List<Pair<String, LocalDate>> after3Orders = customers.stream().flatMap(c -> c.getOrders().stream() .map(o -> Pair.with(c.getCustomerId(), o.getOrderDate()))).limit(3).toList(); return after3Orders; }
public List<Pair<String, LocalDate>> customerOrdersEachNestedTake() { List<Customer> customers = getCustomerList(); List<Pair<String, LocalDate>> after3EachOrders = customers.stream().flatMap(c -> c.getOrders().stream().limit(3) .map(o -> Pair.with(c.getCustomerId(), o.getOrderDate()))).toList(); return after3EachOrders; }
public List<Pair<String, LocalDate>> waCustomerOrdersNestedTake() { List<Customer> customers = getCustomerList(); List<Pair<String, LocalDate>> after3WAOrders = customers.stream().filter(c -> c.getRegion().equals("WA")) .flatMap(c -> c.getOrders().stream().map(o -> Pair.with(c.getCustomerId(), o.getOrderDate()))).limit(3).toList(); return after3WAOrders; }
public List<Pair<String, LocalDate>> waCustomerOrdersEachNestedTake() { List<Customer> customers = getCustomerList(); List<Pair<String, LocalDate>> after3EachWAOrders = customers.stream().filter(c -> c.getRegion().equals("WA")) .flatMap(c -> c.getOrders().stream().limit(3).map(o -> Pair.with(c.getCustomerId(), o.getOrderDate()))).toList(); return after3EachWAOrders; }
public List<Integer> intTakeWhile() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; List<Integer> after3Numbers = Arrays.stream(numbers).takeWhile(i -> i > 3).boxed().toList(); return after3Numbers; }
public List<Integer> oddIntTakeWhile() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; List<Integer> after3Numbers = Arrays.stream(numbers).filter(i -> i % 2 == 1).takeWhile(i -> i > 3).boxed().toList(); return after3Numbers; }
public List<Integer> intSquareTakeWhile() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; List<Integer> after3Numbers = Arrays.stream(numbers).map(i -> i * i).takeWhile(i -> i > 3).boxed().toList(); return after3Numbers; }
public List<Integer> intTakeWhileCount(int n) { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; List<Integer> after3Numbers = Arrays.stream(numbers).takeWhile(i -> i > n).boxed().toList(); return after3Numbers; }
public List<Integer> intTakeWhileCount(int[] numbers, int n) { List<Integer> afterNNumbers = Arrays.stream(numbers).takeWhile(i -> i > n).boxed().toList(); return afterNNumbers; }
public List<String> stringTakeWhile() { String[] words = {"cherry", "apple", "blueberry", "banana", "abacus"}; List<String> afterNNumbers = Arrays.stream(words).takeWhile(w -> w.charAt(0) > 'b').toList(); return afterNNumbers; }
public List<String> longStringTakeWhile() { String[] words = {"cherry", "apple", "blueberry", "banana", "abacus"}; List<String> after3Words = Arrays.stream(words).filter(w -> w.length() > 5).takeWhile(w -> w.charAt(0) > 'b').toList(); return after3Words; }
public List<Integer> stringLengthTakeWhile() { String[] words = {"cherry", "apple", "blueberry", "banana", "abacus"}; List<Integer> after3Words = Arrays.stream(words).map(w -> w.length()).takeWhile(n -> n > 5).toList(); return after3Words; }
public List<String> stringTakeWhileCount(char c) { String[] words = {"cherry", "apple", "blueberry", "banana", "abacus"}; List<String> afterNWords = Arrays.stream(words).takeWhile(w -> w.charAt(0) > c).toList(); return afterNWords; }
public List<String> stringTakeWhileCount(String[] strings, char c) { List<String> afterNWords = Arrays.stream(strings).takeWhile(w -> w.charAt(0) > c).toList(); return afterNWords; }
public List<Product> productTakeWhile() { List<Product> products = getProductList(); List<Product> after3Products = products.stream().takeWhile(p -> p.getProductId() > 100).toList(); return after3Products; }
public List<Product> expensiveProductTakeWhile() { List<Product> products = getProductList(); List<Product> after3Products = products.stream().filter(p -> p.getUnitPrice() > 100).takeWhile(p -> p.getProductId() > 100).toList(); return after3Products; }
public List<Product> inStockProductTakeWhile() { List<Product> products = getProductList(); List<Product> after3Products = products.stream().filter(p -> p.getUnitsInStock() > 100).takeWhile(p -> p.getProductId() > 100).toList(); return after3Products; }
public Map<String, List<Product>> productGroupTakeWhile() { List<Product> products = getProductList(); Map<String, List<Product>> after3Groups = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().takeWhile(g -> g.getKey().length() > 6).collect(toMap(g -> g.getKey(), g -> g.getValue())); return after3Groups; }
public Map<String, List<Product>> productEachGroupTakeWhile() { List<Product> products = getProductList(); Map<String, List<Product>> after3EachGroups = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().takeWhile(p -> p.getProductId() > 100).toList())); return after3EachGroups; }
public List<Order> customerOrdersTakeWhile() { List<Customer> customers = getCustomerList(); List<Order> after3Orders = customers.stream().flatMap(c -> c.getOrders().stream()) .takeWhile(o -> o.getOrderDate().isAfter(LocalDate.of(2000, 1, 1))).toList(); return after3Orders; }
public List<Pair<String, LocalDate>> customerOrdersNestedTakeWhile() { List<Customer> customers = getCustomerList(); List<Pair<String, LocalDate>> after3Orders = customers.stream().flatMap(c -> c.getOrders().stream() .map(o -> Pair.with(c.getCustomerId(), o.getOrderDate()))) .takeWhile(t -> t.getValue1().isAfter(LocalDate.of(2000, 1, 1))).toList(); return after3Orders; }
public List<Pair<String, LocalDate>> customerOrdersEachNestedTakeWhile() { List<Customer> customers = getCustomerList(); List<Pair<String, LocalDate>> after3EachOrders = customers.stream().flatMap(c -> c.getOrders().stream() .takeWhile(o -> o.getOrderDate().isAfter(LocalDate.of(2000, 1, 1))) .map(o -> Pair.with(c.getCustomerId(), o.getOrderDate()))).toList(); return after3EachOrders; }
public List<Pair<String, LocalDate>> waCustomerOrdersNestedTakeWhile() { List<Customer> customers = getCustomerList(); List<Pair<String, LocalDate>> after3WAOrders = customers.stream().filter(c -> c.getRegion().equals("WA")) .flatMap(c -> c.getOrders().stream().map(o -> Pair.with(c.getCustomerId(), o.getOrderDate()))) .takeWhile(t -> t.getValue1().isAfter(LocalDate.of(2000, 1, 1))).toList(); return after3WAOrders; }
public List<Pair<String, LocalDate>> waCustomerOrdersEachNestedTakeWhile() { List<Customer> customers = getCustomerList(); List<Pair<String, LocalDate>> after3EachWAOrders = customers.stream().filter(c -> c.getRegion().equals("WA")) .flatMap(c -> c.getOrders().stream().takeWhile(o -> o.getOrderDate() .isAfter(LocalDate.of(2000, 1, 1))) .map(o -> Pair.with(c.getCustomerId(), o.getOrderDate()))).toList(); return after3EachWAOrders; }
public List<Integer> intTakeWhileIndexed() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; List<Integer> afterNumbers = IntStream.range(0, numbers.length) .takeWhile(i -> numbers[i] > i).map(i -> numbers[i]).boxed().toList(); return afterNumbers; }
public List<Integer> intSquareTakeWhileIndexed() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; List<Integer> afterNumbers =  IntStream.range(0, numbers.length) .takeWhile(i -> numbers[i]*numbers[i] > i).map(i -> numbers[i]*numbers[i]).boxed().toList(); return afterNumbers; }
public List<Double> intSqrtTakeWhileIndexed() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; List<Double> afterNumbers =  IntStream.range(0, numbers.length) .takeWhile(i -> Math.sqrt(numbers[i]) > i).mapToDouble(i -> Math.sqrt(numbers[i]) ).boxed().toList(); return afterNumbers; }
public List<Integer> intTakeWhileIndexedCount(int n) { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; List<Integer> afterNumbers = IntStream.range(0, numbers.length) .takeWhile(i -> n > i).map(i -> numbers[i]).boxed().toList(); return afterNumbers; }
public List<Integer> intTakeWhileIndexedCount(int[] numbers, int n) { List<Integer> afterNumbers = IntStream.range(0, numbers.length) .takeWhile(i -> n > i).map(i -> numbers[i]).boxed().toList(); return afterNumbers; }
public List<Double> doubleOrderbyFractionThenby() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; List<Double> sortedNumbers = Arrays.stream(numbers).boxed().sorted( Comparator.comparing((Double n) -> n - (int) n.doubleValue()) .thenComparing(Comparator.naturalOrder())).toList(); return sortedNumbers; }
public List<Double> doubleOrderbyModThenby() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; List<Double> sortedNumbers = Arrays.stream(numbers).boxed().sorted( Comparator.comparing((Double n) -> n % 1.5) .thenComparing(Comparator.naturalOrder())).toList(); return sortedNumbers; }
public List<Double> doubleOrderbyFractionDescendingThenby() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; List<Double> sortedNumbers = Arrays.stream(numbers).boxed().sorted( Comparator.comparing((Double n) -> n - (int) n.doubleValue(),Comparator.reverseOrder()) .thenComparing(Comparator.naturalOrder())).toList(); return sortedNumbers; }
public List<Double> doubleOrderbyModDescendingThenby() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; List<Double> sortedNumbers = Arrays.stream(numbers).boxed().sorted( Comparator.comparing((Double n) -> n % 1.5,Comparator.reverseOrder()) .thenComparing(Comparator.naturalOrder())).toList(); return sortedNumbers; }
public List<Double> doubleOrderbyFractionThenbyDescending() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; List<Double> sortedNumbers = Arrays.stream(numbers).boxed().sorted( Comparator.comparing((Double n) -> n - (int) n.doubleValue()) .thenComparing(Comparator.reverseOrder())).toList(); return sortedNumbers; }
public List<Double> doubleOrderbyModThenbyDescending() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; List<Double> sortedNumbers = Arrays.stream(numbers).boxed().sorted( Comparator.comparing((Double n) -> n % 1.5) .thenComparing(Comparator.reverseOrder())).toList(); return sortedNumbers; }
public List<Double> doubleOrderbyFractionDescendingThenbyDescending() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; List<Double> sortedNumbers = Arrays.stream(numbers).boxed().sorted( Comparator.comparing((Double n) -> n - (int) n.doubleValue(),Comparator.reverseOrder()) .thenComparing(Comparator.reverseOrder())).toList(); return sortedNumbers; }
public List<Double> doubleOrderbyModDescendingThenbyDescending() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; List<Double> sortedNumbers = Arrays.stream(numbers).boxed().sorted( Comparator.comparing((Double n) -> n % 1.5,Comparator.reverseOrder()) .thenComparing(Comparator.reverseOrder())).toList(); return sortedNumbers; }
public List<Double> bigDoubleOrderbyFractionThenby() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; List<Double> sortedNumbers = Arrays.stream(numbers).boxed().sorted( Comparator.comparing((Double n) -> n - (int) n.doubleValue()) .thenComparing(Comparator.naturalOrder())).toList(); return sortedNumbers; }
public List<Double> bigDoubleOrderbyModThenby() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; List<Double> sortedNumbers = Arrays.stream(numbers).filter(n->n>3).boxed().sorted( Comparator.comparing((Double n) -> n % 1.5) .thenComparing(Comparator.naturalOrder())).toList(); return sortedNumbers; }
public List<Double> bigDoubleOrderbyFractionDescendingThenby() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; List<Double> sortedNumbers = Arrays.stream(numbers).filter(n->n>3).boxed().sorted( Comparator.comparing((Double n) -> n - (int) n.doubleValue(),Comparator.reverseOrder()) .thenComparing(Comparator.naturalOrder())).toList(); return sortedNumbers; }
public List<Double> bigDoubleOrderbyModDescendingThenby() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; List<Double> sortedNumbers = Arrays.stream(numbers).filter(n->n>3).boxed().sorted( Comparator.comparing((Double n) -> n % 1.5,Comparator.reverseOrder()) .thenComparing(Comparator.naturalOrder())).toList(); return sortedNumbers; }
public List<Double> bigDoubleOrderbyFractionThenbyDescending() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; List<Double> sortedNumbers = Arrays.stream(numbers).filter(n->n>3).boxed().sorted( Comparator.comparing((Double n) -> n - (int) n.doubleValue()) .thenComparing(Comparator.reverseOrder())).toList(); return sortedNumbers; }
public List<Double> bigDoubleOrderbyModThenbyDescending() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; List<Double> sortedNumbers = Arrays.stream(numbers).filter(n->n>3).boxed().sorted( Comparator.comparing((Double n) -> n % 1.5) .thenComparing(Comparator.reverseOrder())).toList(); return sortedNumbers; }
public List<Double> bigDoubleOrderbyFractionDescendingThenbyDescending() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; List<Double> sortedNumbers = Arrays.stream(numbers).filter(n->n>3).boxed().sorted( Comparator.comparing((Double n) -> n - (int) n.doubleValue(),Comparator.reverseOrder()) .thenComparing(Comparator.reverseOrder())).toList(); return sortedNumbers; }
public List<Double> bigDoubleOrderbyModDescendingThenbyDescending() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; List<Double> sortedNumbers = Arrays.stream(numbers).filter(n->n>3).boxed().sorted( Comparator.comparing((Double n) -> n % 1.5,Comparator.reverseOrder()) .thenComparing(Comparator.reverseOrder())).toList(); return sortedNumbers; }
public List<String> stringOrderbyLengthThenby() { String[] words = {"cherry", "apple", "blueberry", "banana", "abacus"}; List<String> sortedWords = Arrays.stream(words).sorted(Comparator.comparing((String w) -> w.length()) .thenComparing(Comparator.naturalOrder())).toList(); return sortedWords; }
public List<String> stringOrderbyThenbyLength() { String[] words = {"cherry", "apple", "blueberry", "banana", "abacus"}; List<String> sortedWords = Arrays.stream(words).sorted(Comparator.comparing((String w) -> w) .thenComparing(w -> w.length())).toList(); return sortedWords; }
public List<String> stringOrderbyLengthCustomThenby() { String[] words = {"cherry", "apple", "blueberry", "banana", "abacus"}; List<String> sortedWords =  Arrays.stream(words).sorted(Comparator.comparing((String w) -> w.length(), new CustomNumberComparer()).thenComparing(Comparator.naturalOrder())).toList(); return sortedWords; }
public List<String> stringOrderbyThenbyLengthCustom() { String[] words = {"cherry", "apple", "blueberry", "banana", "abacus"}; List<String> sortedWords = Arrays.stream(words).sorted(Comparator.comparing((String w) -> w) .thenComparing(w -> w.length(),new CustomNumberComparer())).toList(); return sortedWords; }
public List<String> stringOrderbyLengthThenbyCustom() { String[] words = {"aPPLE", "AbAcUs", "bRaNcH", "BlUeBeRrY", "ClOvEr", "cHeRry"}; List<String> sortedWords = Arrays.stream(words).sorted(Comparator.comparing((String w) -> w.length()) .thenComparing(new CaseInsensitiveComparer())).toList(); return sortedWords; }
public List<String> stringOrderbyCustomThenbyLength() { String[] words = {"aPPLE", "AbAcUs", "bRaNcH", "BlUeBeRrY", "ClOvEr", "cHeRry"}; List<String> sortedWords =Arrays.stream(words) .sorted(Comparator.comparing((String w) -> w,new CaseInsensitiveComparer()) .thenComparing(w -> w.length())).toList(); return sortedWords; }
public List<String> stringOrderbyLengthCustomThenbyCustom() { String[] words = {"aPPLE", "AbAcUs", "bRaNcH", "BlUeBeRrY", "ClOvEr", "cHeRry"}; List<String> sortedWords = Arrays.stream(words).sorted(Comparator .comparing((String w) -> w.length(),new CustomNumberComparer()) .thenComparing(new CaseInsensitiveComparer())).toList(); return sortedWords; }
public List<String> stringOrderbyCustomThenbyLengthCustom() { String[] words = {"aPPLE", "AbAcUs", "bRaNcH", "BlUeBeRrY", "ClOvEr", "cHeRry"}; List<String> sortedWords = Arrays.stream(words) .sorted(Comparator.comparing((String w) -> w,new CaseInsensitiveComparer()) .thenComparing(w -> w.length(),new CustomNumberComparer())).toList(); return sortedWords; }
public List<String> stringOrderbyThenbyLengthDescendingCustom() { String[] words = {"cherry", "apple", "blueberry", "banana", "abacus"}; List<String> sortedWords =Arrays.stream(words).sorted(Comparator.comparing((String w) -> w) .thenComparing(w -> w.length(),new CustomNumberComparer().reversed())).toList(); return sortedWords; }
public List<String> stringOrderbyLengthThenbyDescendingCustom() { String[] words = {"aPPLE", "AbAcUs", "bRaNcH", "BlUeBeRrY", "ClOvEr", "cHeRry"}; List<String> sortedWords =Arrays.stream(words).sorted(Comparator.comparing((String w) -> w.length()) .thenComparing(new CaseInsensitiveComparer().reversed())).toList(); return sortedWords; }
public List<String> stringOrderbyLengthCustomThenbyDescendingCustom() { String[] words = {"aPPLE", "AbAcUs", "bRaNcH", "BlUeBeRrY", "ClOvEr", "cHeRry"}; List<String> sortedWords = Arrays.stream(words) .sorted(Comparator.comparing((String w) -> w.length(),new CustomNumberComparer()) .thenComparing(new CaseInsensitiveComparer().reversed())).toList(); return sortedWords; }
public List<String> stringOrderbyCustomThenbyLengthDescendingCustom() { String[] words = {"aPPLE", "AbAcUs", "bRaNcH", "BlUeBeRrY", "ClOvEr", "cHeRry"}; List<String> sortedWords = Arrays.stream(words).sorted(Comparator.comparing((String w) -> w,new CaseInsensitiveComparer()) .thenComparing(w -> w.length(),new CustomNumberComparer().reversed())).toList(); return sortedWords; }
public List<Product> productOrderbyCategoryThenbyId() { List<Product> products = getProductList(); List<Product> sortedProducts = products.stream().sorted(Comparator.comparing((Product p) -> p.getCategory()) .thenComparing(p -> p.getProductId())).toList(); return sortedProducts; }
public List<Product> productOrderbyCategoryThenbyName() { List<Product> products = getProductList(); List<Product> sortedProducts = products.stream().sorted(Comparator.comparing((Product p) -> p.getCategory()) .thenComparing(p -> p.getProductName())).toList(); return sortedProducts; }
public List<Product> productOrderbyCategoryThenbyDescendingId() { List<Product> products = getProductList(); List<Product> sortedProducts = products.stream().sorted(Comparator.comparing((Product p) -> p.getCategory()) .thenComparing(p -> p.getProductId(),Comparator.reverseOrder())).toList(); return sortedProducts; }
public List<Product> productOrderbyCategoryThenbyDescendingName() { List<Product> products = getProductList(); List<Product> sortedProducts =products.stream().sorted(Comparator.comparing((Product p) -> p.getCategory()) .thenComparing(p -> p.getProductName(),Comparator.reverseOrder())).toList(); return sortedProducts; }
public List<Product> expensiveProductOrderbyCategoryThenbyId() { List<Product> products = getProductList(); List<Product> sortedProducts = products.stream().filter(p->p.getUnitPrice()>100) .sorted(Comparator.comparing((Product p) -> p.getCategory()) .thenComparing(p -> p.getProductName())).toList(); return sortedProducts; }
public List<Product> expensiveProductOrderbyCategoryThenbyName() { List<Product> products = getProductList(); List<Product> sortedProducts = products.stream().filter(p->p.getUnitPrice()>100) .sorted(Comparator.comparing((Product p) -> p.getCategory()) .thenComparing(p -> p.getProductName())).toList(); return sortedProducts; }
public List<Product> productOrderbyCategoryThenbyIdCustom() { List<Product> products = getProductList(); List<Product> sortedProducts = products.stream().sorted(Comparator.comparing((Product p) -> p.getCategory()) .thenComparing(p -> p.getProductId(),new CustomNumberComparer())).toList(); return sortedProducts; }
public List<Product> productOrderbyCategoryThenbyNameCustom() { List<Product> products = getProductList(); List<Product> sortedProducts = products.stream().sorted(Comparator.comparing((Product p) -> p.getCategory()) .thenComparing(p -> p.getProductName(),new CaseInsensitiveComparer())).toList(); return sortedProducts; }
public List<Product> productOrderbyCategoryThenbyDescendingIdCustom() { List<Product> products = getProductList(); List<Product> sortedProducts = products.stream().sorted(Comparator.comparing((Product p) -> p.getCategory()) .thenComparing(p -> p.getProductId(),new CustomNumberComparer().reversed())).toList(); return sortedProducts; }
public List<Product> productOrderbyCategoryThenbyDescendingNameCustom() { List<Product> products = getProductList(); List<Product> sortedProducts = products.stream().sorted(Comparator.comparing((Product p) -> p.getCategory()) .thenComparing(p -> p.getProductName(),new CaseInsensitiveComparer().reversed())).toList(); return sortedProducts; }
public List<Product> expensiveProductOrderbyCategoryThenbyIdCustom() { List<Product> products = getProductList(); List<Product> sortedProducts = products.stream().filter(p->p.getUnitPrice()>100) .sorted(Comparator.comparing((Product p) -> p.getCategory()) .thenComparing(p -> p.getProductId(),new CustomNumberComparer().reversed())).toList(); return sortedProducts; }
public List<Product> expensiveProductOrderbyCategoryThenbyNameCustom() { List<Product> products = getProductList(); List<Product> sortedProducts = products.stream().filter(p->p.getUnitPrice()>100) .sorted(Comparator.comparing((Product p) -> p.getCategory()) .thenComparing(p -> p.getProductName(),new CaseInsensitiveComparer().reversed())).toList(); return sortedProducts; }
public List<Integer> intIndexedWhere() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; List<Integer> q = IntStream.range(0, numbers.length).filter(i -> numbers[i] < i).map(i -> numbers[i]).boxed().toList(); return q; }
public List<Integer> oddIntIndexedWhere() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int[] oddNumbers = Arrays.stream(numbers).filter(i -> i % 2 == 1).toArray(); List<Integer> q = IntStream.range(0, oddNumbers.length).filter(i -> oddNumbers[i] < i) .map(i -> oddNumbers[i]).boxed().toList(); return q; }
public List<Integer> oddIntOriginalIndexedWhere() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; List<Integer> q = IntStream.range(0, numbers.length).filter(i -> numbers[i] < i && numbers[i] % 2 == 1) .map(i -> numbers[i]).boxed().toList(); return q; }
public List<Integer> intSquareIndexedWhere() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; List<Integer> q = IntStream.range(0, numbers.length).filter(i -> numbers[i] * numbers[i] < i) .map(i -> numbers[i] * numbers[i]).boxed().toList(); return q; }
public List<Integer> intWithSquareIndexedWhere() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; List<Integer> q = IntStream.range(0, numbers.length).filter(i -> numbers[i] < i * i) .map(i -> numbers[i]).boxed().toList(); return q; }
public List<String> stringIndexedWhere() { String[] words = {"cherry", "apple", "blueberry", "banana", "abacus"}; IntStream.range(0, words.length).filter(i -> words[i].length() < i).mapToObj(i -> words[i]).toList(); List<String> q = IntStream.range(0, words.length).filter(i -> words[i].length() < i).mapToObj(i -> words[i]).toList(); return q; }
public List<String> longStringIndexedWhere() { String[] words = {"cherry", "apple", "blueberry", "banana", "abacus"}; String[] longWords = (String[]) Arrays.stream(words).filter(w -> w.length() > 5).toArray(); List<String> q = IntStream.range(0, longWords.length).filter(i -> longWords[i].length() < i * 3) .mapToObj(i -> longWords[i]).toList(); return q; }
public List<String> longStringOrginalIndexedWhere() { String[] words = {"cherry", "apple", "blueberry", "banana", "abacus"}; List<String> q = IntStream.range(0, words.length).filter(i -> words[i].length() < i * 3 && words[i].length() > 5).mapToObj(i -> words[i]).toList(); return q; }
public List<Product> productIndexedWhere() { List<Product> products = getProductList(); List<Product> q = IntStream.range(0, products.size()).filter(i -> products.get(i).getUnitsInStock() > 0 && i % 2 == 1).mapToObj(i -> products.get(i)).toList(); return q; }
public List<Product> expensiveProductIndexedWhere() { List<Product> products = getProductList(); List<Product> q = IntStream.range(0, products.size()).filter(i -> products.get(i).getUnitPrice() > 100 && i % 2 == 1).mapToObj(i -> products.get(i)).toList(); return q; }
