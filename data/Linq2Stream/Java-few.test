public List<Product> productOrderbyId() { List<Product> products = getProductList(); List<Product> sortedProducts = products.stream().sorted(Comparator.comparing(p -> p.getProductId())).toList(); return sortedProducts; }
public List<Product> productOrderbyName() { List<Product> products = getProductList(); List<Product> sortedProducts = products.stream().sorted(Comparator.comparing(p -> p.getProductName())).toList(); return sortedProducts; }
public List<String> productNameOrderby() { List<Product> products = getProductList(); List<String> sortedProducts = products.stream().map(p -> p.getProductName()).sorted().toList(); return sortedProducts; }
public List<Product> expensiveProductOrderbyId() { List<Product> products = getProductList(); List<Product> sortedProducts = products.stream().filter(p -> p.getUnitPrice() > 100).sorted(Comparator.comparing(p -> p.getProductId())).toList(); return sortedProducts; }
public List<Product> expensiveProductOrderbyName() { List<Product> products = getProductList(); List<Product> sortedProducts = products.stream().filter(p -> p.getUnitPrice() > 100).sorted(Comparator.comparing(p -> p.getProductName())).toList(); return sortedProducts; }
public List<String> expensiveProductNameOrderby() { List<Product> products = getProductList(); List<String> sortedProducts = products.stream().filter(p -> p.getUnitPrice() > 100).map(p -> p.getProductName()).sorted().toList(); return sortedProducts; }
public List<Pair<String, List<Product>>> productGroupByCategoryOrderbyId() { List<Product> products = getProductList(); List<Pair<String, List<Product>>> productsGroups = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream() .sorted(Comparator.comparing(p -> p.getProductId())).toList())).toList(); return productsGroups; }
public Map<String, List<Product>> productGroupByCategoryDictOrderbyId() { List<Product> products = getProductList(); Map<String, List<Product>> productsGroups = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream() .sorted(Comparator.comparing(p -> p.getProductId())).toList())); return productsGroups; }
public List<Pair<String, List<Product>>> productGroupByCategoryOrderbyName() { List<Product> products = getProductList(); List<Pair<String, List<Product>>> productsGroups = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream() .sorted(Comparator.comparing(p -> p.getProductName())).toList())).toList(); return productsGroups; }
public Map<String, List<Product>> productGroupByCategoryDictOrderbyName() { List<Product> products = getProductList(); Map<String, List<Product>> productsGroups = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream(). sorted(Comparator.comparing(p -> p.getProductName())).toList())); return productsGroups; }
public List<String> stringOrderbyCustom() { String[] words = {"aPPLE", "AbAcUs", "bRaNcH", "BlUeBeRrY", "ClOvEr", "cHeRry"}; List<String> sortedWords = Arrays.stream(words).sorted(new CaseInsensitiveComparer()).toList(); return sortedWords; }
public List<String> stringOrderbyLengthCustom() { String[] words = {"aPPLE", "AbAcUs", "bRaNcH", "BlUeBeRrY", "ClOvEr", "cHeRry"}; List<String> sortedWords = Arrays.stream(words).sorted(Comparator.comparing(w -> w.length(), new CustomNumberComparer())).toList(); return sortedWords; }
public List<Integer> stringLengthOrderbyCustom() { String[] words = {"aPPLE", "AbAcUs", "bRaNcH", "BlUeBeRrY", "ClOvEr", "cHeRry"}; List<Integer> sortedWords = Arrays.stream(words).map(w -> w.length()).sorted(new CustomNumberComparer()).toList(); return sortedWords; }
public List<String> shortStringOrderbyCustom() { String[] words = {"aPPLE", "AbAcUs", "bRaNcH", "BlUeBeRrY", "ClOvEr", "cHeRry"}; List<String> sortedWords = Arrays.stream(words).filter(w -> w.length() < 6).sorted(new CaseInsensitiveComparer()). toList(); return sortedWords; }
public List<String> shortStringOrderbyLengthCustom() { String[] words = {"aPPLE", "AbAcUs", "bRaNcH", "BlUeBeRrY", "ClOvEr", "cHeRry"}; List<String> sortedWords = Arrays.stream(words).filter(w -> w.length() < 6).sorted(Comparator.comparing(w -> w.length(), new CustomNumberComparer())).toList(); return sortedWords; }
public List<Integer> shortStringLengthOrderbyCustom() { String[] words = {"aPPLE", "AbAcUs", "bRaNcH", "BlUeBeRrY", "ClOvEr", "cHeRry"}; List<Integer> sortedWords = Arrays.stream(words).filter(w -> w.length() < 6).map(w -> w.length()). sorted(new CustomNumberComparer()).toList(); return sortedWords; }
public List<Pair<Character, List<String>>> stringGroupByFirstCharOrderbyCustom() { String[] words = {"aPPLE", "AbAcUs", "bRaNcH", "BlUeBeRrY", "ClOvEr", "cHeRry"}; List<Pair<Character, List<String>>> wordsGroups = Arrays.stream(words).collect(groupingBy(w -> Character.toLowerCase(w.charAt(0)))) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().sorted(new CaseInsensitiveComparer()).toList())).toList(); return wordsGroups; }
public Map<Character, List<String>> stringGroupByFirstCharDictOrderbyCustom() { String[] words = {"aPPLE", "AbAcUs", "bRaNcH", "BlUeBeRrY", "ClOvEr", "cHeRry"}; Map<Character, List<String>> wordsGroups = Arrays.stream(words).collect(groupingBy(w -> Character.toLowerCase(w.charAt(0)))) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().sorted(new CaseInsensitiveComparer()).toList())); return wordsGroups; }
public List<Pair<Boolean, List<String>>> stringGroupByLengthOrderbyLengthCustom() { String[] words = {"aPPLE", "AbAcUs", "bRaNcH", "BlUeBeRrY", "ClOvEr", "cHeRry"}; List<Pair<Boolean, List<String>>> wordsGroups = Arrays.stream(words).collect(groupingBy(w -> w.length() > 8)) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().sorted( Comparator.comparing(w -> w.length(), new CustomNumberComparer())).toList())).toList(); return wordsGroups; }
public Map<Boolean, List<String>> stringGroupByLengthDictOrderbyLengthCustom() { String[] words = {"aPPLE", "AbAcUs", "bRaNcH", "BlUeBeRrY", "ClOvEr", "cHeRry"}; Map<Boolean, List<String>> wordsGroups = Arrays.stream(words).collect(groupingBy(w -> w.length() > 8)) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().sorted( Comparator.comparing(w -> w.length(), new CustomNumberComparer())).toList())); return wordsGroups; }
public void numbersDeferred() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; AtomicInteger i = new AtomicInteger(0); var q = Arrays.stream(numbers).map(n -> i.addAndGet(n)); q.forEach(v -> System.out.println(v + " " + i)); }
public void bigNumbersDeferred() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; AtomicInteger i = new AtomicInteger(0); var q = Arrays.stream(numbers).filter(n->n>5).map(n -> i.addAndGet(n)); q.forEach(v -> System.out.println(v + " " + i)); }
public void oddNumbersDeferred() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; AtomicInteger i = new AtomicInteger(0); var q = Arrays.stream(numbers).filter(n->n%2==1).map(n -> i.addAndGet(n)); q.forEach(v -> System.out.println(v + " " + i)); }
public void doubleDeferred() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; AtomicReference<Double> d = new AtomicReference<>(0.0); var q = Arrays.stream(numbers).map(n -> d.accumulateAndGet(n, Double::sum)); q.forEach(v -> System.out.println(v + " " + d)); }
public void bigDoubleNumbersDeferred() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; AtomicReference<Double> d = new AtomicReference<>(0.0); var q = Arrays.stream(numbers).filter(n->n>5).map(n -> d.accumulateAndGet(n, Double::sum)); q.forEach(v -> System.out.println(v + " " + d)); }
public void numbersTwiceDeferred() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; AtomicInteger i = new AtomicInteger(0); var q = Arrays.stream(numbers).map(n->n*2).map(n -> i.addAndGet(n)); q.forEach(v -> System.out.println(v + " " + i)); }
public void bigNumbersTwiceDeferred() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; AtomicInteger i = new AtomicInteger(0); var q = Arrays.stream(numbers).filter(n->n>5).map(n->n*2).map(n -> i.addAndGet(n)); q.forEach(v -> System.out.println(v + " " + i)); }
public void oddNumbersTwiceDeferred() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; AtomicInteger i = new AtomicInteger(0); var q = Arrays.stream(numbers).filter(n->n%2==1).map(n->n*2).map(n -> i.addAndGet(n)); q.forEach(v -> System.out.println(v + " " + i)); }
public void stringLengthDeferred() { String[] words = {"cherry", "apple", "blueberry"}; AtomicInteger i = new AtomicInteger(0); var q = Arrays.stream(words).map(w -> w.length()).map(n -> i.addAndGet(n)); q.forEach(v -> System.out.println(v + " " + i)); }
public void shortStringLengthDeferred() { String[] words = {"cherry", "apple", "blueberry"}; AtomicInteger i = new AtomicInteger(0); var q = Arrays.stream(words).filter(w->w.length()<7).map(w -> w.length()).map(n -> i.addAndGet(n)); q.forEach(v -> System.out.println(v + " " + i)); }
public void numbersEager() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; AtomicInteger i = new AtomicInteger(0); var q = Arrays.stream(numbers).map(n -> i.addAndGet(n)).boxed().toList(); for (var v : q) System.out.println(v + " " + i); }
public void bigNumbersEager() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; AtomicInteger i = new AtomicInteger(0); var q = Arrays.stream(numbers).filter(n->n>5).map(n -> i.addAndGet(n)).boxed().toList(); for (var v : q) System.out.println(v + " " + i); }
public void oddNumbersEager() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; AtomicInteger i = new AtomicInteger(0); var q = Arrays.stream(numbers).filter(n->n%2==1).map(n -> i.addAndGet(n)).boxed().toList(); for (var v : q) System.out.println(v + " " + i); }
public void doubleEager() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; AtomicReference<Double> d = new AtomicReference<>(0.0); var q = Arrays.stream(numbers).map(n -> d.accumulateAndGet(n, Double::sum)).boxed().toList(); for (var v : q) System.out.println(v + " " + d); }
public void bigDoubleNumbersEager() { double[] numbers = {3.1, 4.2, 1.6, 0.7, 8.7, 6.9, 7.4, 2.5, 5.7, 0}; AtomicReference<Double> d = new AtomicReference<>(0.0); var q = Arrays.stream(numbers).filter(n->n>5).map(n -> d.accumulateAndGet(n, Double::sum)).boxed().toList(); for (var v : q) System.out.println(v + " " + d); }
public void numbersTwiceEager() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; AtomicInteger i = new AtomicInteger(0); var q = Arrays.stream(numbers).map(n->n*2).map(n -> i.addAndGet(n)).boxed().toList(); for (var v : q) System.out.println(v + " " + i); }
public void bigNumbersTwiceEager() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; AtomicInteger i = new AtomicInteger(0); var q = Arrays.stream(numbers).filter(n->n>5).map(n->n*2).map(n -> i.addAndGet(n)).boxed().toList(); for (var v : q) System.out.println(v + " " + i); }
public void oddNumbersTwiceEager() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; AtomicInteger i = new AtomicInteger(0); var q = Arrays.stream(numbers).filter(n->n%2==1).map(n->n*2).map(n -> i.addAndGet(n)).boxed().toList(); for (var v : q) System.out.println(v + " " + i); }
public void stringLengthEager() { String[] words = {"cherry", "apple", "blueberry"}; AtomicInteger i = new AtomicInteger(0); var q = Arrays.stream(words).map(w -> w.length()).map(n -> i.addAndGet(n)).toList(); for (var v : q) System.out.println(v + " " + i); }
public void shortStringLengthEager() { String[] words = {"cherry", "apple", "blueberry"}; AtomicInteger i = new AtomicInteger(0); var q = Arrays.stream(words).filter(w->w.length()<7).map(w -> w.length()).map(n -> i.addAndGet(n)).toList(); for (var v : q) System.out.println(v + " " + i); }
public Pair<Integer, Integer>[] selectManyJoin() { int[] numbersA = {0, 2, 4, 5, 6, 8, 9}; int[] numbersB = {1, 3, 5, 7, 8}; Pair<Integer, Integer>[] pairs = (Pair<Integer, Integer>[]) Arrays.stream(numbersA).boxed().flatMap( a -> Arrays.stream(numbersB).mapToObj(b -> Pair.with(a, b))).toArray(); return pairs; }
public Pair<Integer, Integer>[] selectManyJoinOdd() { int[] numbersA = {0, 2, 4, 5, 6, 8, 9}; int[] numbersB = {1, 3, 5, 7, 8}; Pair<Integer, Integer>[] pairs = (Pair<Integer, Integer>[]) Arrays.stream(numbersA).boxed().flatMap(a -> Arrays.stream(numbersB) .filter(b -> b % 2 == 1).mapToObj(b -> Pair.with(a, b))).toArray(); return pairs; }
public Pair<Integer, Integer>[] selectManyJoinBig() { int[] numbersA = {0, 2, 4, 5, 6, 8, 9}; int[] numbersB = {1, 3, 5, 7, 8}; Pair<Integer, Integer>[] pairs = (Pair<Integer, Integer>[]) Arrays.stream(numbersA).boxed().flatMap(a -> Arrays.stream(numbersB) .filter(b -> b > 5).mapToObj(b -> Pair.with(a, b))).toArray(); return pairs; }
public Pair<Integer, Integer>[] selectManyJoinSmaller() { int[] numbersA = {0, 2, 4, 5, 6, 8, 9}; int[] numbersB = {1, 3, 5, 7, 8}; Pair<Integer, Integer>[] pairs = (Pair<Integer, Integer>[]) Arrays.stream(numbersA).boxed().flatMap(a -> Arrays.stream(numbersB) .filter(b -> a < b).mapToObj(b -> Pair.with(a, b))).toArray(); return pairs; }
public Pair<Integer, Integer>[] selectManyJoinSumEven() { int[] numbersA = {0, 2, 4, 5, 6, 8, 9}; int[] numbersB = {1, 3, 5, 7, 8}; Pair<Integer, Integer>[] pairs = (Pair<Integer, Integer>[]) Arrays.stream(numbersA).boxed().flatMap(a -> Arrays.stream(numbersB) .filter(b -> (a + b) % 2 == 0).mapToObj(b -> Pair.with(a, b))).toArray(); return pairs; }
public List<Order> customerSelectManyOrders() { List<Customer> customers = getCustomerList(); List<Order> customerProperties = customers.stream().flatMap(c -> c.getOrders().stream()).toList(); return customerProperties; }
public List<Pair<String, Order>> customerSelectManyCustomerOrders() { List<Customer> customers = getCustomerList(); List<Pair<String, Order>> customerProperties = customers.stream().flatMap(c -> c.getOrders() .stream().map(o -> Pair.with(c.getCustomerId(), o))).toList(); return customerProperties; }
public List<Pair<String, LocalDate>> customerSelectManyCustomerOrderDates() { List<Customer> customers = getCustomerList(); List<Pair<String, LocalDate>> customerProperties = customers.stream().flatMap(c -> c.getOrders() .stream().map(o -> Pair.with(c.getCustomerId(), o.getOrderDate()))).toList(); return customerProperties; }
public List<Triplet<String, Integer, Double>> customerSelectManyCustomerOrderIdAndTotals() { List<Customer> customers = getCustomerList(); List<Triplet<String, Integer, Double>> customerProperties = customers.stream().flatMap(c -> c.getOrders() .stream().map(o -> Triplet.with(c.getCustomerId(), o.getOrderId(), o.getTotal()))).toList(); return customerProperties; }
public List<Triplet<String, Integer, Integer>> customerSelectManyCustomerOrderDateYearAndMonth() { List<Customer> customers = getCustomerList(); List<Triplet<String, Integer, Integer>> customerProperties = customers.stream().flatMap(c -> c.getOrders() .stream().map(o -> Triplet.with(c.getCustomerId(), o.getOrderDate().getYear(), o.getOrderDate().getMonthValue()))).toList(); return customerProperties; }
public List<Order> customerSelectManyBigOrders() { List<Customer> customers = getCustomerList(); List<Order> customerProperties = customers.stream().flatMap(c -> c.getOrders() .stream().filter(o -> o.getTotal() > 100)).toList(); return customerProperties; }
public List<Pair<String, Order>> customerSelectManyCustomerBigOrders() { List<Customer> customers = getCustomerList(); List<Pair<String, Order>> customerProperties = customers.stream().flatMap(c -> c.getOrders() .stream().filter(o -> o.getTotal() > 100).map(o -> Pair.with(c.getCustomerId(), o))).toList(); return customerProperties; }
public List<Pair<String, LocalDate>> customerSelectManyCustomerBigOrderDates() { List<Customer> customers = getCustomerList(); List<Pair<String, LocalDate>> customerProperties = customers.stream().flatMap(c -> c.getOrders() .stream().filter(o -> o.getTotal() > 100).map(o -> Pair.with(c.getCustomerId(), o.getOrderDate()))).toList(); return customerProperties; }
public List<Triplet<String, Integer, Double>> customerSelectManyCustomerBigOrderIdAndTotals() { List<Customer> customers = getCustomerList(); List<Triplet<String, Integer, Double>> customerProperties = customers.stream().flatMap(c -> c.getOrders() .stream().filter(o -> o.getTotal() > 100).map(o -> Triplet.with(c.getCustomerId(), o.getOrderId(), o.getTotal()))).toList(); return customerProperties; }
public List<Triplet<String, Integer, Integer>> customerSelectManyCustomerBigOrderDateYearAndMonth() { List<Customer> customers = getCustomerList(); List<Triplet<String, Integer, Integer>> customerProperties = customers.stream().flatMap(c -> c.getOrders() .stream().filter(o -> o.getTotal() > 100).map(o -> Triplet.with(c.getCustomerId(), o.getOrderDate().getYear(), o.getOrderDate().getMonthValue()))).toList(); return customerProperties; }
public List<Order> customerSelectManyNewOrders() { List<Customer> customers = getCustomerList(); List<Order> customerProperties = customers.stream().flatMap(c -> c.getOrders() .stream().filter(o -> o.getOrderDate().isAfter(LocalDate.of(1998, 1, 1)))).toList(); return customerProperties; }
public List<Pair<String, Order>> customerSelectManyCustomerNewOrders() { List<Customer> customers = getCustomerList(); List<Pair<String, Order>> customerProperties = customers.stream().flatMap(c -> c.getOrders() .stream().filter(o -> o.getOrderDate().isAfter(LocalDate.of(1998, 1, 1))) .map(o -> Pair.with(c.getCustomerId(), o))).toList(); return customerProperties; }
public List<Pair<String, LocalDate>> customerSelectManyCustomerNewOrderDates() { List<Customer> customers = getCustomerList(); List<Pair<String, LocalDate>> customerProperties = customers.stream().flatMap(c -> c.getOrders() .stream().filter(o -> o.getOrderDate().isAfter(LocalDate.of(1998, 1, 1))) .map(o -> Pair.with(c.getCustomerId(), o.getOrderDate()))).toList(); return customerProperties; }
public List<Triplet<String, Integer, Double>> customerSelectManyCustomerNewOrderIdAndTotals() { List<Customer> customers = getCustomerList(); List<Triplet<String, Integer, Double>> customerProperties = customers.stream().flatMap(c -> c.getOrders() .stream().filter(o -> o.getOrderDate().isAfter(LocalDate.of(1998, 1, 1))) .map(o -> Triplet.with(c.getCustomerId(), o.getOrderId(), o.getTotal()))).toList(); return customerProperties; }
public List<Triplet<String, Integer, Integer>> customerSelectManyCustomerNewOrderDateYearAndMonth() { List<Customer> customers = getCustomerList(); List<Triplet<String, Integer, Integer>> customerProperties = customers.stream().flatMap(c -> c.getOrders() .stream().filter(o -> o.getOrderDate().isAfter(LocalDate.of(1998, 1, 1))) .map(o -> Triplet.with(c.getCustomerId(), o.getOrderDate().getYear(), o.getOrderDate().getMonthValue()))).toList(); return customerProperties; }
public List<Order> waCustomerSelectManyNewOrders() { List<Customer> customers = getCustomerList(); List<parallel.linq101.datasource.Order> customerProperties = customers.stream().filter(c -> c.getRegion().equals("WA")).flatMap(c -> c.getOrders() .stream().filter(o -> o.getOrderDate().isAfter(LocalDate.of(1998, 1, 1)))).toList(); return customerProperties; }
public List<Pair<String, Order>> waCustomerSelectManyCustomerNewOrders() { List<Customer> customers = getCustomerList(); List<Pair<String, Order>> customerProperties = customers.stream().filter(c -> c.getRegion().equals("WA")).flatMap(c -> c.getOrders() .stream().filter(o -> o.getOrderDate().isAfter(LocalDate.of(1998, 1, 1))) .map(o -> Pair.with(c.getCustomerId(), o))).toList(); return customerProperties; }
public List<Pair<String, LocalDate>> waCustomerSelectManyCustomerNewOrderDates() { List<Customer> customers = getCustomerList(); List<Pair<String, LocalDate>> customerProperties = customers.stream().filter(c -> c.getRegion().equals("WA")).flatMap(c -> c.getOrders() .stream().filter(o -> o.getOrderDate().isAfter(LocalDate.of(1998, 1, 1))) .map(o -> Pair.with(c.getCustomerId(), o.getOrderDate()))).toList(); return customerProperties; }
public List<Triplet<String, Integer, Double>> waCustomerSelectManyCustomerNewOrderIdAndTotals() { List<Customer> customers = getCustomerList(); List<Triplet<String, Integer, Double>> customerProperties = customers.stream().filter(c -> c.getRegion().equals("WA")).flatMap(c -> c.getOrders() .stream().filter(o -> o.getOrderDate().isAfter(LocalDate.of(1998, 1, 1))) .map(o -> Triplet.with(c.getCustomerId(), o.getOrderId(), o.getTotal()))).toList(); return customerProperties; }
public List<Triplet<String, Integer, Integer>> waCustomerSelectManyCustomerNewOrderDateYearAndMonth() { List<Customer> customers = getCustomerList(); List<Triplet<String, Integer, Integer>> customerProperties = customers.stream().filter(c -> c.getRegion().equals("WA")).flatMap(c -> c.getOrders() .stream().filter(o -> o.getOrderDate().isAfter(LocalDate.of(1998, 1, 1))) .map(o -> Triplet.with(c.getCustomerId(), o.getOrderDate().getYear(), o.getOrderDate().getMonthValue()))).toList(); return customerProperties; }
public int[] indexedSelectMany() { int[] numbersA = {0, 2, 4, 5, 6, 8, 9}; int[] numbersB = {1, 3, 5, 7, 8}; int[] pairs = IntStream.range(0, numbersA.length).flatMap(i -> Arrays.stream(numbersB).map( b -> i % 2 == 0 ? numbersA[i] : b)).toArray(); return pairs; }
public int[] indexedSelectManyBig() { int[] numbersA = {0, 2, 4, 5, 6, 8, 9}; int[] numbersB = {1, 3, 5, 7, 8}; int[] pairs = IntStream.range(0, numbersA.length).flatMap(i -> Arrays.stream(numbersB).filter( b ->b<numbersA[i]+i)).toArray(); return pairs; }
public List<Order> customerIndexedSelectManyOrdersTake() { List<Customer> customers = getCustomerList(); List<Order> customerProperties = IntStream.range(0, customers.size()).boxed(). flatMap(i -> customers.get(i).getOrders().stream().limit(i<10?5:1)).toList(); return customerProperties; }
public List<Order> waCustomerIndexedSelectManyOrdersTake() { List<Customer> customers = getCustomerList(); List<Order> customerProperties = IntStream.range(0, customers.size()).boxed().filter(i->customers.get(i).getRegion().equals("WA")) .flatMap(i -> customers.get(i).getOrders().stream().limit(i<10?5:1)).toList(); return customerProperties; }
public List<String> indexedSelectManyString() { List<Customer> customers = getCustomerList(); List<String> customerOrders = IntStream.range(0, customers.size()).boxed().flatMap( i -> customers.get(i).getOrders().stream().map( o -> "Customer #" + (i + 1) + " has an order with OrderID " + o.getOrderId())) .collect(Collectors.toList()); return customerOrders; }
public int[] intPlusOne() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int[] numSelected = Arrays.stream(numbers).map(n -> n + 1).toArray(); return numSelected; }
public int[] oddIntPlusOne() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int[] numSelected = Arrays.stream(numbers).filter(n -> n % 2 == 1).map(n -> n + 1).toArray(); return numSelected; }
public int[] bigIntPlusOne() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int[] numSelected = Arrays.stream(numbers).filter(n -> n > 5).map(n -> n + 1).toArray(); return numSelected; }
public int[] intTwice() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int[] numSelected = Arrays.stream(numbers).map(n -> n * 2).toArray(); return numSelected; }
public int[] oddIntTwice() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int[] numSelected = Arrays.stream(numbers).filter(n -> n % 2 == 1).map(n -> n * 2).toArray(); return numSelected; }
public int[] bigIntTwice() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int[] numSelected = Arrays.stream(numbers).filter(n -> n > 5).map(n -> n * 2).toArray(); return numSelected; }
public Character[] stringFirstChar() { String[] strings = {"zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"}; Character[] selected = (Character[]) Arrays.stream(strings).map(w -> w.charAt(0)).toArray(); return selected; }
public Character[] shortStringFirstChar() { String[] strings = {"zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"}; Character[] selected = (Character[]) Arrays.stream(strings).filter(w -> w.length() < 4) .map(w -> w.charAt(0)).toArray(); return selected; }
public int[] stringLength() { String[] strings = {"zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"}; int[] selected = Arrays.stream(strings).mapToInt(w -> w.length()).toArray(); return selected; }
public int[] shortStringLength() { String[] strings = {"zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"}; int[] selected = Arrays.stream(strings).filter(w -> w.length() < 4).mapToInt(w -> w.length()).toArray(); return selected; }
public List<String> productName() { List<Product> products = getProductList(); List<String> productNames = products.stream().map(p -> p.getProductName()).toList(); return productNames; }
public List<Double> productUnitPrice() { List<Product> products = getProductList(); List<Double> productNames = products.stream().map(p -> p.getUnitPrice()).toList(); return productNames; }
public List<String> expensiveProductName() { List<Product> products = getProductList(); List<String> productNames = products.stream().filter(p -> p.getUnitPrice() > 100).map(p -> p.getProductName()).toList(); return productNames; }
public List<Double> expensiveProductUnitPrice() { List<Product> products = getProductList(); List<Double> productNames = products.stream().filter(p -> p.getUnitPrice() > 100).map(p -> p.getUnitPrice()).toList(); return productNames; }
public List<String> outOfStockProductName() { List<Product> products = getProductList(); List<String> productNames = products.stream().filter(p -> p.getUnitsInStock() == 0).map(p -> p.getProductName()).toList(); return productNames; }
public List<Double> outOfStockProductUnitPrice() { List<Product> products = getProductList(); List<Double> productNames = products.stream().filter(p -> p.getUnitsInStock() == 0).map(p -> p.getUnitPrice()).toList(); return productNames; }
public List<Pair<String, List<String>>> productGroupName() { List<Product> products = getProductList(); List<Pair<String, List<String>>> productNames = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().map(p -> p.getProductName()).toList())).toList(); return productNames; }
public Map<String, List<String>> productGroupNameDict() { List<Product> products = getProductList(); Map<String, List<String>> productNames = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().map(p -> p.getProductName()).toList())); return productNames; }
public List<Pair<String, List<Double>>> productGroupUnitPrice() { List<Product> products = getProductList(); List<Pair<String, List<Double>>> productNames = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().map(g -> Pair.with(g.getKey(), g.getValue().stream().map(p -> p.getUnitPrice()).toList())).toList(); return productNames; }
public Map<String, List<Double>> productGroupUnitPriceDict() { List<Product> products = getProductList(); Map<String, List<Double>> productNames = products.stream().collect(groupingBy(p -> p.getCategory())) .entrySet().stream().collect(toMap(g -> g.getKey(), g -> g.getValue().stream().map(p -> p.getUnitPrice()).toList())); return productNames; }
public int[] transformIndexToInt() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int[] textNums = Arrays.stream(numbers).map(n -> numbers[n]).toArray(); return textNums; }
public String[] transformIndexToString() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; String[] strings = {"zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"}; String[] textNums = (String[]) Arrays.stream(numbers).mapToObj(n -> strings[n]).toArray(); return textNums; }
public int[] transformIndexHashToInt() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; int[] textNums = Arrays.stream(numbers).map(n -> numbers[n * 97 % 10]).toArray(); return textNums; }
public String[] transformIndexHashToString() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; String[] strings = {"zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"}; String[] textNums = (String[]) Arrays.stream(numbers).mapToObj(n -> numbers[n * 97 % 10]).toArray(); return textNums; }
public Pair<String, String>[] selectByCase() { String[] words = {"aPPLE", "BlUeBeRrY", "cHeRry"}; Pair<String, String>[] upperLowerWords = (Pair<String, String>[]) Arrays.stream(words).map(w -> Pair.with(w.toUpperCase(), w.toLowerCase())).toArray(); return upperLowerWords; }
public String[] selectByCaseConcat() { String[] words = {"aPPLE", "BlUeBeRrY", "cHeRry"}; String[] upperLowerWords = (String[]) Arrays.stream(words).map(w -> w.toUpperCase() + w.toLowerCase()).toArray(); return upperLowerWords; }
public Pair<String, Integer>[] selectByStringAndLength() { String[] words = {"aPPLE", "BlUeBeRrY", "cHeRry"}; Pair<String, Integer>[] upperLowerWords = (Pair<String, Integer>[]) Arrays.stream(words).map(w -> Pair.with(w, w.length())).toArray(); return upperLowerWords; }
public String[] selectByStringAndLengthConcat() { String[] words = {"aPPLE", "BlUeBeRrY", "cHeRry"}; String[] upperLowerWords = (String[]) Arrays.stream(words).map(w -> w + w.length()).toArray(); return upperLowerWords; }
public Pair<String, Boolean>[] selectByEvenOdd() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; String[] strings = {"zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"}; Pair<String, Boolean>[] evenOddWords = (Pair<String, Boolean>[]) Arrays.stream(numbers).mapToObj(n -> Pair.with(strings[n], n % 2 == 0)).toArray(); return evenOddWords; }
public String[] selectByEvenOddConcat() { int[] numbers = {5, 4, 1, 3, 9, 8, 6, 7, 2, 0}; String[] strings = {"zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"}; String[] evenOddWords = (String[]) Arrays.stream(numbers).mapToObj(n -> strings[n] + (n % 2 == 0 ? " even" : " odd")).toArray(); return evenOddWords; }
