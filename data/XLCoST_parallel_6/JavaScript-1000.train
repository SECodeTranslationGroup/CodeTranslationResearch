function calculate ( a , n ) { a . sort ( ) ; let i , j ; let s = [ ] ; for ( i = 0 , j = n - 1 ; i < j ; i ++ , j -- ) s . push ( ( a [ i ] + a [ j ] ) ) ; let mini = Math . min ( ... s ) ; let maxi = Math . max ( ... s ) ; return Math . abs ( maxi - mini ) ; }
function cyl ( r , h ) { if ( r < 0 && h < 0 ) return - 1 ; var R = ( 2 * r ) / 3 ; var H = ( 2 * h ) / 3 ; var V = 3.14 * Math . pow ( R , 2 ) * H ; return V ; }
function printTwoSetBitNums ( n ) { let x = 1 ; while ( n > 0 ) { let y = 0 ; while ( y < x ) { document . write ( ( 1 << x ) + ( 1 << y ) + " " ) ; n -- ; if ( n == 0 ) return ; y ++ ; } x ++ ; } }
function minNumber ( a , n , x ) { let l = 0 , h = 0 , e = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] == x ) e ++ ; else if ( a [ i ] > x ) h ++ ; else if ( a [ i ] < x ) l ++ ; } let ans = 0 ; if ( l > h ) ans = l - h ; else if ( l < h ) ans = h - l - 1 ; return ans + 1 - e ; }
function printKthBit ( n , k ) { document . write ( ( n & ( 1 << ( k - 1 ) ) ) >> ( k - 1 ) ) ; }
function equilibrium ( arr , n ) { sum = 0 ; leftsum = 0 ; for ( let i = 0 ; i < n ; ++ i ) sum += arr [ i ] ; for ( let i = 0 ; i < n ; ++ i ) { sum -= arr [ i ] ; if ( leftsum == sum ) return i ; leftsum += arr [ i ] ; } return - 1 ; }
function countRhombi ( h , w ) { let ct = 0 ; for ( let i = 2 ; i <= h ; i += 2 ) for ( let j = 2 ; j <= w ; j += 2 ) ct += ( h - i + 1 ) * ( w - j + 1 ) ; return ct ; }
function sumofoddFactors ( n ) { let res = 1 ; while ( n % 2 == 0 ) n = n / 2 ; for ( let i = 3 ; i <= Math . sqrt ( n ) ; i ++ ) { let count = 0 ; let curr_sum = 1 ; let curr_term = 1 ; while ( n % i == 0 ) { count ++ ; n = n / i ; curr_term *= i ; curr_sum += curr_term ; } res *= curr_sum ; } if ( n >= 2 ) res *= ( 1 + n ) ; return res ; }
function isPower ( n ) { for ( x = 2 ; x <= parseInt ( Math . sqrt ( n ) ) ; x ++ ) { var f = Math . log ( n ) / Math . log ( x ) ; if ( ( f - parseInt ( f ) ) == 0.0 ) return true ; } return false ; }
function sumOfSeries ( n ) { return n * ( n + 1 ) * ( 6 * n * n * n + 9 * n * n + n - 1 ) / 30 ; }
function sum ( n ) { let i , s = 0.0 ; for ( i = 1 ; i <= n ; i ++ ) s = s + 1 / i ; return s ; }
function countRect ( n ) { let ans = 0 ; for ( let length = 1 ; length <= parseInt ( Math . sqrt ( n ) , 10 ) ; ++ length ) for ( let height = length ; height * length <= n ; ++ height ) ans ++ ; return ans ; }
function isSquareFree ( n ) { if ( n % 2 == 0 ) n = n / 2 ; if ( n % 2 == 0 ) return false ; for ( let i = 3 ; i <= Math . sqrt ( n ) ; i = i + 2 ) { if ( n % i == 0 ) { n = n / i ; if ( n % i == 0 ) return false ; } } return true ; }
function constructXOR ( A , n ) { let XOR = 0 ; for ( let i = 0 ; i < n ; i ++ ) XOR ^= A [ i ] ; for ( let i = 0 ; i < n ; i ++ ) A [ i ] = XOR ^ A [ i ] ; }
function maxArea ( perimeter ) { let length = Math . ceil ( perimeter / 4 ) ; let breadth = Math . floor ( perimeter / 4 ) ; return length * breadth ; }
function isPowerOfK ( n , k ) { let oneSeen = false ; while ( n > 0 ) { let digit = n % k ; if ( digit > 1 ) return false ; if ( digit == 1 ) { if ( oneSeen ) return false ; oneSeen = true ; } n = Math . floor ( n / k ) ; } return true ; }
function ReuleauxArea ( a ) { if ( a < 0 ) return - 1 ; var A = 0.70477 * Math . pow ( a , 2 ) ; return A ; }
function squareArea ( a ) { if ( a < 0 ) return - 1 ; var area = ( Math . pow ( 1.268 , 2 ) * Math . pow ( a , 2 ) ) ; return area ; }
function cal_cos ( n ) { let accuracy = 0.0001 , x1 , denominator , cosx , cosval ; n = n * ( 3.142 / 180.0 ) ; x1 = 1 ; cosx = x1 ; cosval = Math . cos ( n ) ; let i = 1 ; do { denominator = 2 * i * ( 2 * i - 1 ) ; x1 = - x1 * n * n / denominator ; cosx = cosx + x1 ; i = i + 1 ; } while ( accuracy <= Math . abs ( cosval - cosx ) ) ; document . write ( cosx . toFixed ( 5 ) ) ; }
function divisorSum ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; ++ i ) { for ( let j = 1 ; j * j <= i ; ++ j ) { if ( i % j == 0 ) { if ( i / j == j ) sum += j ; else sum += j + i / j ; } } } return sum ; }
function hexadecagonalNum ( n ) { return ( ( 14 * n * n ) - 12 * n ) / 2 ; }
function minValue ( n , x , y ) { let val = ( y * n ) / 100 ; if ( x >= val ) return 0 ; else return ( Math . ceil ( val ) - x ) ; }
function middlesum ( mat , n ) { var row_sum = 0 , col_sum = 0 ; for ( i = 0 ; i < n ; i ++ ) row_sum += mat [ parseInt ( n / 2 ) ] [ i ] ; document . write ( " " + row_sum + " " ) ; for ( i = 0 ; i < n ; i ++ ) col_sum += mat [ i ] [ parseInt ( n / 2 ) ] ; document . write ( " " + col_sum ) ; }
function printBalancedExpression ( a , b , c , d ) { if ( ( ( a == d ) && ( a != 0 ) ) || ( ( a == 0 ) && ( c == 0 ) && ( d == 0 ) ) ) { for ( i = 1 ; i <= a ; i ++ ) document . write ( " " ) ; for ( i = 1 ; i <= c ; i ++ ) document . write ( " " ) ; for ( i = 1 ; i <= d ; i ++ ) document . write ( " " ) ; for ( i = 1 ; i <= b ; i ++ ) document . write ( " " ) ; } else document . write ( - 1 ) ; }
function judgeSquareSum ( n ) { for ( i = 2 ; i * i <= n ; i ++ ) { var count = 0 ; if ( n % i == 0 ) { while ( n % i == 0 ) { count ++ ; n = parseInt ( n / i ) ; } if ( i % 4 == 3 && count % 2 != 0 ) return false ; } } return n % 4 != 3 ; }
function highestPowerOf2 ( n ) { return ( n & ( ~ ( n - 1 ) ) ) ; }
function printMaxSum ( arr , n ) { let dp = new Array ( n ) ; dp . fill ( 0 ) ; for ( let i = 0 ; i < n ; i ++ ) { dp [ i ] = arr [ i ] ; let maxi = 0 ; for ( let j = 1 ; j <= Math . sqrt ( i + 1 ) ; j ++ ) { if ( ( ( i + 1 ) % j == 0 ) && ( i + 1 ) != j ) { if ( dp [ j - 1 ] > maxi ) maxi = dp [ j - 1 ] ; if ( dp [ parseInt ( ( i + 1 ) / j , 10 ) - 1 ] > maxi && j != 1 ) maxi = dp [ parseInt ( ( i + 1 ) / j , 10 ) - 1 ] ; } } dp [ i ] += maxi ; } for ( let i = 0 ; i < n ; i ++ ) document . write ( dp [ i ] + " " ) ; }
function isInGivenBase ( str , bas ) { if ( bas > 16 ) return false ; else if ( bas <= 10 ) { for ( let i = 0 ; i < str . length ; i ++ ) if ( ! ( str [ i ] . charCodeAt ( ) >= ' ' . charCodeAt ( ) && str [ i ] . charCodeAt ( ) < ( ' ' . charCodeAt ( ) + bas ) ) ) return false ; } else { for ( let i = 0 ; i < str . length ; i ++ ) if ( ! ( ( str [ i ] . charCodeAt ( ) >= ' ' . charCodeAt ( ) && str [ i ] . charCodeAt ( ) < ( ' ' . charCodeAt ( ) + bas ) ) || ( str [ i ] . charCodeAt ( ) >= ' ' . charCodeAt ( ) && str [ i ] . charCodeAt ( ) < ( ' ' . charCodeAt ( ) + bas - 10 ) ) ) ) return false ; } return true ; }
function convert ( str ) { let n = str . length ; let str1 = " " ; for ( i = 0 ; i < n ; i ++ ) { if ( str [ i ] == ' ' ) str1 = str1 + ' ' ; else str1 = str1 + ( str [ i ] ) . toLowerCase ( ) ; } document . write ( str1 ) ; }
function hammingDistance ( n1 , n2 ) { let x = n1 ^ n2 ; let setBits = 0 ; while ( x > 0 ) { setBits += x & 1 ; x >>= 1 ; } return setBits ; }
function round ( n ) { let a = parseInt ( n / 10 , 10 ) * 10 ; let b = a + 10 ; return ( n - a > b - n ) ? b : a ; }
function absSumDidd ( a ) { a . sort ( ( a , b ) => a - b ) ; var midValue = a [ a . length / 2 ] ; var sum = 0 ; for ( var i = 0 ; i < a . length ; i ++ ) { sum = sum + Math . abs ( a [ i ] - midValue ) ; } return sum ; }
function sumN ( n ) { n = parseInt ( ( n + 1 ) / 2 ) ; return ( n * n ) ; }
function getPairsCount ( arr , n , sum ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] + arr [ j ] == sum ) count ++ ; return count ; }
function bin ( n ) { if ( n > 1 ) bin ( n >> 1 ) ; document . write ( n & 1 ) ; }
function countSetBits ( n ) { var count = 0 ; while ( n ) { count += n & 1 ; n >>= 1 ; } return count ; }
function findNature ( a , b , n ) { if ( n == 0 ) return ( a & 1 ) == 1 ? true : false ; if ( n == 1 ) return ( b & 1 ) == 1 ? true : false ; if ( ( a & 1 ) == 0 ) { if ( ( b & 1 ) == 0 ) return false ; else return ( n % 3 != 0 ) ; } else { if ( ( b & 1 ) == 0 ) return ( ( n - 1 ) % 3 != 0 ) ; else return ( ( n + 1 ) % 3 != 0 ) ; } }
function getCount ( N ) { if ( N % 2 == 1 ) return " " ; let result = " " ; for ( let i = 1 ; i <= N / 2 - 1 ; i ++ ) result += " " ; return result ; }
function longOddEvenIncSeq ( arr , n ) { let lioes = [ ] ; let maxLen = 0 ; for ( let i = 0 ; i < n ; i ++ ) lioes [ i ] = 1 ; for ( let i = 1 ; i < n ; i ++ ) for ( let j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && ( arr [ i ] + arr [ j ] ) % 2 != 0 && lioes [ i ] < lioes [ j ] + 1 ) lioes [ i ] = lioes [ j ] + 1 ; for ( let i = 0 ; i < n ; i ++ ) if ( maxLen < lioes [ i ] ) maxLen = lioes [ i ] ; return maxLen ; }
function rad ( d , h ) { document . write ( " " + ( ( d * d ) / ( 8 * h ) + h / 2 ) ) ; }
function printAllAPTriplets ( arr , n ) { const s = new Set ( ) for ( let i = 0 ; i < n - 1 ; i ++ ) { for ( let j = i + 1 ; j < n ; j ++ ) { let diff = arr [ j ] - arr [ i ] ; if ( s . has ( arr [ i ] - diff ) ) document . write ( arr [ i ] - diff + " " + arr [ i ] + " " + arr [ j ] + " " ) ; } s . add ( arr [ i ] ) ; } }
function sumOfSeries ( x , k ) { var y = ( ( ( x ) / 81 ) * ( 9 * k - 1 + Math . pow ( 10 , ( - 1 ) * k ) ) ) ; return y ; }
function binaryToDecimal ( n ) { let num = n ; let dec_value = 0 ; let base = 1 ; let temp = num ; while ( temp ) { let last_digit = temp % 10 ; temp = Math . floor ( temp / 10 ) ; dec_value += last_digit * base ; base = base * 2 ; } return dec_value ; }
function nobleInteger ( arr ) { arr . sort ( function ( a , b ) { return a - b ; } ) ; let n = arr . length ; for ( let i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) continue ; if ( arr [ i ] == n - i - 1 ) return arr [ i ] ; } if ( arr [ n - 1 ] == 0 ) return arr [ n - 1 ] ; return - 1 ; }
function pad ( n ) { let pPrevPrev = 1 ; let pPrev = 1 ; let pCurr = 1 ; let pNext = 1 ; for ( let i = 3 ; i <= n ; i ++ ) { pNext = pPrevPrev + pPrev ; pPrevPrev = pPrev ; pPrev = pCurr ; pCurr = pNext ; } return pNext ; }
function findSubsequence ( str , k ) { var a = Array ( MAX_CHAR ) . fill ( 0 ) ; for ( var i = 0 ; i < str . length ; i ++ ) a [ str [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; for ( var i = 0 ; i < str . length ; i ++ ) if ( a [ str [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] >= k ) document . write ( str [ i ] ) ; }
function count_square ( n ) { let count = 0 ; for ( let i = 1 ; i <= n ; i = i + 2 ) { let k = n - i + 1 ; count += ( k * k ) ; } return count ; }
function countTriplets ( arr , n , m ) { let count = 0 ; arr . sort ( function ( a , b ) { return a - b } ) ; let end , start , mid ; for ( end = n - 1 ; end >= 2 ; end -- ) { start = 0 ; mid = end - 1 ; while ( start < mid ) { let prod = arr [ end ] * arr [ start ] * arr [ mid ] ; if ( prod > m ) mid -- ; else if ( prod < m ) start ++ ; else if ( prod == m ) { count ++ ; mid -- ; start ++ ; } } } return count ; }
function calculateArea ( x , y ) { var pi = 3.1415926536 ; var arx = pi * x * x ; var ary = pi * y * y ; return arx - ary ; }
function maxMin ( arr , n ) { let min = + 2147483647 ; let max = - 2147483648 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j <= n / 2 ; j ++ ) { if ( arr [ i ] [ j ] > arr [ i ] [ n - j - 1 ] ) { if ( min > arr [ i ] [ n - j - 1 ] ) min = arr [ i ] [ n - j - 1 ] ; if ( max < arr [ i ] [ j ] ) max = arr [ i ] [ j ] ; } else { if ( min > arr [ i ] [ j ] ) min = arr [ i ] [ j ] ; if ( max < arr [ i ] [ n - j - 1 ] ) max = arr [ i ] [ n - j - 1 ] ; } } } document . write ( " " + max + " " + min ) ; }
function checkFittingArrays ( A , B , N ) { A . sort ( function ( a , b ) { return a - b ; } ) ; B . sort ( function ( a , b ) { return a - b ; } ) ; for ( let i = 0 ; i < N ; i ++ ) if ( A [ i ] > B [ i ] ) return false ; return true ; }
function printTrib ( n ) { let dp = Array . from ( { length : n } , ( _ , i ) => 0 ) ; dp [ 0 ] = dp [ 1 ] = 0 ; dp [ 2 ] = 1 ; for ( let i = 3 ; i < n ; i ++ ) dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] + dp [ i - 3 ] ; for ( let i = 0 ; i < n ; i ++ ) document . write ( dp [ i ] + " " ) ; }
function isUnique ( a , n , k ) { var sum = 0 ; for ( i = 0 ; i < n ; i ++ ) sum += a [ i ] ; sum += n - 1 ; return ( sum == k ) ; }
function nthTerm ( n ) { return 2 * Math . pow ( n , 2 ) + 4 * n - 2 ; }
function printSquares ( n ) { let square = 0 , odd = 1 ; for ( let x = 0 ; x < n ; x ++ ) { document . write ( square + " " ) ; square = square + odd ; odd = odd + 2 ; } }
function pentagon_pyramidal ( n ) { return n * n * ( n + 1 ) / 2 ; }
function oddEquivalent ( s , n ) { var count = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ' ' ) count ++ ; } return count ; }
function countWays ( index , cnt , dp , n , m , k ) { if ( index == n ) { if ( cnt == k ) return 1 ; else return 0 ; } if ( dp [ index ] [ cnt ] != - 1 ) return dp [ index ] [ cnt ] ; let ans = 0 ; ans += countWays ( index + 1 , cnt , dp , n , m , k ) ; ans += ( m - 1 ) * countWays ( index + 1 , cnt + 1 , dp , n , m , k ) ; return dp [ index ] [ cnt ] = ans ; } let n = 3 , m = 3 , k = 2 ; let dp = new Array ( n + 1 ) ; for ( let i = 0 ; i < n + 1 ; i ++ ) { dp [ i ] = new Array ( max ) ; for ( let j = 0 ; j < max ; j ++ ) dp [ i ] [ j ] = - 1 ; }
function polyarea ( n , a ) { if ( a < 0 && n < 0 ) return - 1 ; var A = ( a * a * n ) / ( 4 * Math . tan ( ( 180 / n ) * 3.14159 / 180 ) ) ; return A ; }
function countSol ( coeff , start , end , rhs ) { if ( rhs == 0 ) return 1 ; let result = 0 ; for ( let i = start ; i <= end ; i ++ ) if ( coeff [ i ] <= rhs ) result += countSol ( coeff , i , end , rhs - coeff [ i ] ) ; return result ; }
function findMaximumPieces ( n ) { var x = parseInt ( n / 2 ) ; return ( ( x + 1 ) * ( n - x + 1 ) ) ; }
function nthTerm ( n ) { return 6 * Math . pow ( n , 2 ) - 4 * n - 2 ; }
function isSurd ( n ) { for ( let i = 2 ; i * i <= n ; i ++ ) { let j = i ; while ( j < n ) j = j * i ; if ( j == n ) return false ; } return true ; }
function swap ( a , b , c , d ) { a = a + b ; b = a - b ; a = a - b ; b = b + c ; c = b - c ; b = b - c ; c = c + d ; d = c - d ; c = c - d ; document . write ( " " + " " ) ; document . write ( " " + a + " " ) ; document . write ( " " + b + " " ) ; document . write ( " " + c + " " ) ; document . write ( " " + d ) ; }
function checkPronic ( x ) { for ( var i = 0 ; i <= parseInt ( Math . sqrt ( x ) ) ; i ++ ) if ( x == i * ( i + 1 ) ) return true ; return false ; }
function FindMaxSum ( arr , n ) { let incl = arr [ 0 ] ; let excl = 0 ; let excl_new ; let i ; for ( i = 1 ; i < n ; i ++ ) { excl_new = ( incl > excl ) ? incl : excl ; incl = excl + arr [ i ] ; excl = excl_new ; } return ( ( incl > excl ) ? incl : excl ) ; }
function maxGameByWinner ( N ) { let dp = new Array ( N ) . fill ( 0 ) ; dp [ 0 ] = 1 ; dp [ 1 ] = 2 ; let i = 2 ; do { dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] ; } while ( dp [ i ++ ] <= N ) ; return ( i - 2 ) ; }
function Area ( r ) { if ( r < 0 ) return - 1 ; var x = ( 2 * r ) / ( Math . sqrt ( 5 ) ) ; var A = 0.70477 * ( Math . pow ( x , 2 ) ) ; return A ; }
function findAnswer ( X , N ) { return ( N - 1 ) * 9 + X ; }
function checkPandigital ( b , n ) { if ( n . length < b ) return 0 ; let hash = [ ] ; for ( let i = 0 ; i < b ; i ++ ) hash [ i ] = 0 ; for ( let i = 0 ; i < n . length ; i ++ ) { if ( n [ i ] >= ' ' && n [ i ] <= ' ' ) hash [ n [ i ] - ' ' ] = 1 ; else if ( n . charCodeAt ( i ) - ' ' . charCodeAt ( 0 ) <= b - 11 ) hash [ n . charCodeAt ( i ) - ' ' . charCodeAt ( 0 ) + 10 ] = 1 ; } for ( let i = 0 ; i < b ; i ++ ) if ( hash [ i ] == 0 ) return 0 ; return 1 ; }
function maxSumIS ( arr , n ) { let i , j , max = 0 ; let msis = new Array ( n ) ; for ( i = 0 ; i < n ; i ++ ) msis [ i ] = arr [ i ] ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && msis [ i ] < msis [ j ] + arr [ i ] ) msis [ i ] = msis [ j ] + arr [ i ] ; for ( i = 0 ; i < n ; i ++ ) if ( max < msis [ i ] ) max = msis [ i ] ; return max ; }
function findCommon ( ar1 , ar2 , ar3 , n1 , n2 , n3 ) { var i = 0 , j = 0 , k = 0 ; while ( i < n1 && j < n2 && k < n3 ) { if ( ar1 [ i ] == ar2 [ j ] && ar2 [ j ] == ar3 [ k ] ) { document . write ( ar1 [ i ] + " " ) ; i ++ ; j ++ ; k ++ ; } else if ( ar1 [ i ] < ar2 [ j ] ) i ++ ; else if ( ar2 [ j ] < ar3 [ k ] ) j ++ ; else k ++ ; } }
function answerQuery ( a , n , l , r ) { var count = 0 ; l = l - 1 ; for ( i = l ; i < r ; i ++ ) { var element = a [ i ] ; var divisors = 0 ; for ( j = l ; j < r ; j ++ ) { if ( a [ j ] % a [ i ] == 0 ) divisors ++ ; else break ; } if ( divisors == ( r - l ) ) count ++ ; } return count ; }
function productAtKthLevel ( tree , k ) { let level = - 1 ; let product = 1 ; let n = tree . length ; for ( let i = 0 ; i < n ; i ++ ) { if ( tree [ i ] == ' ' ) level ++ ; else if ( tree [ i ] == ' ' ) level -- ; else { if ( level == k ) product *= ( tree [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ) ; } } return product ; }
function Cycles ( N ) { var fact = 1 , result = 0 ; result = N - 1 ; var i = result ; while ( i > 0 ) { fact = fact * i ; i -- ; } return fact / 2 ; }
function findFourElements ( A , n , X ) { for ( let i = 0 ; i < n - 3 ; i ++ ) { for ( let j = i + 1 ; j < n - 2 ; j ++ ) { for ( let k = j + 1 ; k < n - 1 ; k ++ ) { for ( let l = k + 1 ; l < n ; l ++ ) if ( A [ i ] + A [ j ] + A [ k ] + A [ l ] == X ) document . write ( A [ i ] + " " + A [ j ] + " " + A [ k ] + " " + A [ l ] ) ; } } } }
function minOperations ( s , t , n ) { var ct0 = 0 , ct1 = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( s [ i ] === t [ i ] ) continue ; if ( s [ i ] === " " ) ct0 ++ ; else ct1 ++ ; } return Math . max ( ct0 , ct1 ) ; }
function countOfBinaryNumberLessThanN ( N ) { var q = [ ] ; q . push ( 1 ) ; var cnt = 0 ; var t ; while ( q . length > 0 ) { t = q . pop ( ) ; if ( t <= N ) { cnt ++ ; q . push ( t * 10 ) ; q . push ( t * 10 + 1 ) ; } } return cnt ; }
function countPairs ( a , n , k ) { a . sort ( ( a , b ) => a - b ) ; let res = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let j = i + 1 ; while ( j < n && a [ j ] - a [ i ] < k ) { res ++ ; j ++ ; } } return res ; }
function findMinRooms ( slots , n , m ) { let counts = Array ( m ) . fill ( 0 ) ; for ( let i = 0 ; i < m ; i ++ ) counts [ i ] = 0 ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = 0 ; j < m ; j ++ ) if ( slots [ i ] [ j ] == ' ' ) counts [ j ] ++ ; let max = - 1 ; for ( let i = 0 ; i < m ; i ++ ) if ( max < counts [ i ] ) max = counts [ i ] ; return max ; }
function minimumLength ( x , y , z ) { return 1 + Math . abs ( x - y ) + Math . abs ( y - z ) ; }
function find_greatest_divisor ( l , r ) { if ( l == r ) return l ; return 1 ; }
function lbs ( arr , n ) { let i , j ; let lis = new Array ( n ) for ( i = 0 ; i < n ; i ++ ) lis [ i ] = 1 ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; let lds = new Array ( n ) ; for ( i = 0 ; i < n ; i ++ ) lds [ i ] = 1 ; for ( i = n - 2 ; i >= 0 ; i -- ) for ( j = n - 1 ; j > i ; j -- ) if ( arr [ i ] > arr [ j ] && lds [ i ] < lds [ j ] + 1 ) lds [ i ] = lds [ j ] + 1 ; let max = lis [ 0 ] + lds [ 0 ] - 1 ; for ( i = 1 ; i < n ; i ++ ) if ( lis [ i ] + lds [ i ] - 1 > max ) max = lis [ i ] + lds [ i ] - 1 ; return max ; }
function countWays ( n , m ) { let count = new Array ( n + 1 ) ; count [ 0 ] = 0 ; let i ; for ( i = 1 ; i <= n ; i ++ ) { if ( i > m ) count [ i ] = count [ i - 1 ] + count [ i - m ] ; else if ( i < m i == 1 ) count [ i ] = 1 ; else count [ i ] = 2 ; } return count [ n ] ; }
function catalanDP ( n ) { let catalan = [ ] ; catalan [ 0 ] = catalan [ 1 ] = 1 ; for ( let i = 2 ; i <= n ; i ++ ) { catalan [ i ] = 0 ; for ( let j = 0 ; j < i ; j ++ ) catalan [ i ] += catalan [ j ] * catalan [ i - j - 1 ] ; } return catalan [ n ] ; }
function getQuadrant ( X , Y , R , PX , PY ) { if ( PX == X && PY == Y ) return 0 ; let val = Math . pow ( ( PX - X ) , 2 ) + Math . pow ( ( PY - Y ) , 2 ) ; if ( val > Math . pow ( R , 2 ) ) return - 1 ; if ( PX > X && PY >= Y ) return 1 ; if ( PX <= X && PY > Y ) return 2 ; if ( PX < X && PY <= Y ) return 3 ; if ( PX >= X && PY < Y ) return 4 ; }
function decdiagonal ( a ) { if ( a < 0 ) return - 1 ; var d = 1.902 * a ; return d ; }
function shortest_distance ( x1 , y1 , z1 , a , b , c , d ) { d = Math . abs ( ( a * x1 + b * y1 + c * z1 + d ) ) ; let e = Math . sqrt ( a * a + b * b + c * c ) ; document . write ( " " + ( d / e ) ) ; return ; }
function findGreatest ( arr , n ) { let result = - 1 ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = 0 ; j < n - 1 ; j ++ ) for ( let k = j + 1 ; k < n ; k ++ ) if ( arr [ j ] * arr [ k ] == arr [ i ] ) result = Math . max ( result , arr [ i ] ) ; return result ; }
function findCount ( str1 , str2 ) { var len = str1 . length ; var len2 = str2 . length ; var ans = 21474836473 ; var hash1 = new Array ( 26 ) . fill ( 0 ) ; var hash2 = new Array ( 26 ) . fill ( 0 ) ; for ( var i = 0 ; i < len ; i ++ ) hash1 [ str1 [ i ] . charCodeAt ( 0 ) - " " . charCodeAt ( 0 ) ] ++ ; for ( var i = 0 ; i < len2 ; i ++ ) hash2 [ str2 [ i ] . charCodeAt ( 0 ) - " " . charCodeAt ( 0 ) ] ++ ; for ( var i = 0 ; i < 26 ; i ++ ) if ( hash2 [ i ] ) ans = Math . min ( ans , hash1 [ i ] / hash2 [ i ] ) ; return ans ; }
function difference ( arr , n ) { let d1 = 0 , d2 = 0 ; for ( let i = 0 ; i < n ; i ++ ) { d1 += arr [ i ] [ i ] ; d2 += arr [ i ] [ n - i - 1 ] ; } return Math . abs ( d1 - d2 ) ; }
function minimumLectures ( m , n ) { let ans = 0 ; if ( n < Math . ceil ( 0.75 * m ) ) ans = Math . ceil ( ( ( 0.75 * m ) - n ) / 0.25 ) ; else ans = 0 ; return ans ; }
function func ( a , k ) { for ( let i = 0 ; i < a . length ; i ++ ) if ( a [ i ] % k == 0 ) return true ; return false ; }
function circlearea ( a , b ) { if ( a < 0 b < 0 ) return - 1 ; var A = ( ( 3.14 * Math . pow ( a , 2 ) * Math . pow ( b , 2 ) ) / ( 4 * ( Math . pow ( a , 2 ) + Math . pow ( b , 2 ) ) ) ) ; return A ; }
function minDiff ( arr , n , k ) { var result = Number . MAX_VALUE ; arr . sort ( ( a , b ) => a - b ) ; for ( i = 0 ; i <= n - k ; i ++ ) result = Math . min ( result , arr [ i + k - 1 ] - arr [ i ] ) ; return result ; }
function Square ( row , column , moves ) { var a = 0 , b = 0 , c = 0 , d = 0 , total = 0 ; a = row - moves ; b = row + moves ; c = column - moves ; d = column + moves ; if ( a < 1 ) a = 1 ; if ( c < 1 ) c = 1 ; if ( b > 8 ) b = 8 ; if ( d > 8 ) d = 8 ; total = ( b - a + 1 ) * ( d - c + 1 ) - 1 ; return total ; }
function findOccurrences ( str1 , substr1 ) { let counter = 0 ; for ( let i = 0 ; i < str1 . length ; i ++ ) { if ( str1 [ i ] == substr1 [ 0 ] ) { for ( let j = i + 1 ; j < str1 . length ; j ++ ) { if ( str1 [ j ] == substr1 [ 1 ] ) { for ( let k = j + 1 ; k < str1 . length ; k ++ ) { if ( str1 [ k ] == substr1 [ 2 ] ) counter ++ ; } } } } } return counter ; }
function nswp ( n ) { let dp = new Array ( n + 1 ) ; dp [ 0 ] = dp [ 1 ] = 1 ; for ( let i = 2 ; i <= n ; i ++ ) dp [ i ] = 2 * dp [ i - 1 ] + dp [ i - 2 ] ; return dp [ n ] ; }
function divide ( a , b ) { for ( let i = 2 ; i <= Math . min ( a , b ) ; i ++ ) { while ( a % i == 0 && b % i == 0 ) { a = a / i ; b = b / i ; } } document . write ( " " + a + " " + b + " " ) ; }
function SubArraySum ( arr , n ) { let result = 0 , temp = 0 ; for ( let i = 0 ; i < n ; i ++ ) { temp = 0 ; for ( let j = i ; j < n ; j ++ ) { temp += arr [ j ] ; result += temp ; } } return result ; }
function countReduce ( str ) { let n = str . length ; let res = 0 ; for ( let i = 0 ; i < parseInt ( n / 2 , 10 ) ; i ++ ) res += Math . abs ( str [ i ] . charCodeAt ( ) - str [ n - i - 1 ] . charCodeAt ( ) ) ; return res ; }
function numberOfWays ( x ) { let dp = Array ( x + 1 ) . fill ( 0 ) ; dp [ 0 ] = dp [ 1 ] = 1 ; for ( i = 2 ; i <= x ; i ++ ) dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; return dp [ x ] ; }
function countNonDecreasing ( n ) { let dp = new Array ( 10 ) ; for ( let i = 0 ; i < 10 ; i ++ ) { dp [ i ] = new Array ( n + 1 ) ; } for ( let i = 0 ; i < 10 ; i ++ ) { for ( let j = 0 ; j < n + 1 ; j ++ ) { dp [ i ] [ j ] = 0 ; } } for ( let i = 0 ; i < 10 ; i ++ ) dp [ i ] [ 1 ] = 1 ; for ( let digit = 0 ; digit <= 9 ; digit ++ ) { for ( let len = 2 ; len <= n ; len ++ ) { for ( let x = 0 ; x <= digit ; x ++ ) dp [ digit ] [ len ] += dp [ x ] [ len - 1 ] ; } } let count = 0 ; for ( let i = 0 ; i < 10 ; i ++ ) count += dp [ i ] [ n ] ; return count ; }
function countOddRotations ( n ) { var odd_count = 0 , even_count = 0 ; do { var digit = n % 10 ; if ( digit % 2 == 1 ) odd_count ++ ; else even_count ++ ; n = parseInt ( n / 10 ) ; } while ( n != 0 ) ; document . write ( " " + odd_count + " " ) ; document . write ( " " + even_count + " " ) ; }
function check ( n ) { let sum = 0 ; while ( n != 0 ) { sum += n % 10 ; n = Math . floor ( n / 10 ) ; } if ( sum % 7 == 0 ) return 1 ; else return 0 ; }
function search ( arr , n , x ) { let front = 0 , back = n - 1 ; while ( front <= back ) { if ( arr [ front ] == x arr [ back ] == x ) return true ; front ++ ; back -- ; } return false ; }
function countNumbers ( x , n ) { if ( x > n ) return 0 ; return 1 + countNumbers ( x * 10 , n ) + countNumbers ( x * 10 + 1 , n ) ; }
function LastTwoDigit ( num ) { let one = num % 10 ; num = Math . floor ( num / 10 ) ; let tens = num % 10 ; tens *= 10 ; num = tens + one ; return num ; }
function checkOrigin ( x1 , y1 , x2 , y2 ) { return ( x1 * ( y2 - y1 ) == y1 * ( x2 - x1 ) ) ; }
function calculateSum ( n ) { let a1 = 1 , a2 = 2 ; let r = 2 ; let d = 1 ; return ( n ) * ( 2 * a1 + ( n - 1 ) * d ) / 2 + a2 * ( Math . pow ( r , n ) - 1 ) / ( r - 1 ) ; }
function highestPowerof2 ( n ) { let res = 0 ; for ( let i = n ; i >= 1 ; i -- ) { if ( ( i & ( i - 1 ) ) == 0 ) { res = i ; break ; } } return res ; }
function countDecreasing ( A , n ) { var len = 1 ; for ( var i = 0 ; i < n - 1 ; ++ i ) { if ( A [ i + 1 ] < A [ i ] ) len ++ ; else { cnt += parseInt ( ( ( len - 1 ) * len ) / 2 ) ; len = 1 ; } } if ( len > 1 ) cnt += parseInt ( ( ( len - 1 ) * len ) / 2 ) ; return cnt ; }
function divide ( n , m ) { document . write ( " " + ( ( n ) & ( m - 1 ) ) + " " ) ; document . write ( " " + ( n >> ( Math . log ( m ) / Math . log ( 2 ) ) ) ) ; }
function checkCollision ( a , b , c , x , y , radius ) { let dist = ( Math . abs ( a * x + b * y + c ) ) / Math . sqrt ( a * a + b * b ) ; if ( radius == dist ) document . write ( " " ) ; else if ( radius > dist ) document . write ( " " ) ; else document . write ( " " ) ; }
function nthTerm ( N ) { return ( ( 3 * N * N ) - ( 6 * N ) + 2 ) ; }
function solve ( s , k ) { var count = 0 , length = 0 , pos = 0 ; var m = new Map ( ) ; for ( var i = 0 ; i < s . length ; i ++ ) { if ( ! m . has ( s [ i ] ) ) { m . set ( s [ i ] , 0 ) ; } m . set ( s [ i ] , m . get ( s [ i ] ) + 1 ) ; length ++ ; if ( length > k ) { if ( ! m . has ( s [ pos ] ) ) { m . set ( s [ pos ] , 0 ) ; } m . set ( s [ pos ] , m [ s [ pos ] ] - 1 ) ; pos += 1 ; length -- ; } if ( length == k && m . get ( s [ i ] ) == length ) count ++ ; } document . write ( count ) ; }
function sumofseries ( n ) { let res = 0 ; for ( let i = 1 ; i <= n ; i ++ ) res += ( i ) * ( i + 1 ) * ( i + 2 ) ; return res ; }
function isPossible ( n , k , arr ) { let sum = arr [ 0 ] ; let maxVal = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { sum += arr [ i ] ; maxVal = Math . max ( maxVal , arr [ i ] ) ; } if ( maxVal > ( sum + k ) / n ) return false ; return true ; }
function stirlingFactorial ( n ) { if ( n == 1 ) return 1 ; let z ; let e = 2.71 ; z = Math . sqrt ( 2 * 3.14 * n ) * Math . pow ( ( n / e ) , n ) ; return Math . floor ( z ) ; }
function isPalindrome ( n ) { var divisor = 1 ; while ( parseInt ( n / divisor ) >= 10 ) divisor *= 10 ; while ( n != 0 ) { var leading = parseInt ( n / divisor ) ; var trailing = n % 10 ; if ( leading != trailing ) return false ; n = parseInt ( ( n % divisor ) / 10 ) ; divisor = divisor / 100 ; } return true ; }
function toggle ( n ) { let temp = 1 ; while ( temp <= n ) { n = n ^ temp ; temp = temp << 1 ; } return n ; }
function dealnnoy ( n , m ) { var dp = Array . from ( Array ( m + 1 ) , ( ) => Array ( n + 1 ) ) ; for ( var i = 0 ; i <= m ; i ++ ) dp [ i ] [ 0 ] = 1 ; for ( var i = 0 ; i <= m ; i ++ ) dp [ 0 ] [ i ] = 1 ; for ( var i = 1 ; i <= m ; i ++ ) for ( var j = 1 ; j <= n ; j ++ ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] + dp [ i ] [ j - 1 ] ; return dp [ m ] [ n ] ; }
function findVolume ( u , v , w , U , V , W , b ) { let uPow = Math . pow ( u , 2 ) ; let vPow = Math . pow ( v , 2 ) ; let wPow = Math . pow ( w , 2 ) ; let UPow = Math . pow ( U , 2 ) ; let VPow = Math . pow ( V , 2 ) ; let WPow = Math . pow ( W , 2 ) ; let a = 4 * ( uPow * vPow * wPow ) - uPow * Math . pow ( ( vPow + wPow - UPow ) , 2 ) - vPow * Math . pow ( ( wPow + uPow - VPow ) , 2 ) - wPow * Math . pow ( ( uPow + vPow - WPow ) , 2 ) + ( vPow + wPow - UPow ) * ( wPow + uPow - VPow ) * ( uPow + vPow - WPow ) ; let vol = Math . sqrt ( a ) ; vol /= b ; document . write ( vol . toFixed ( 4 ) ) ; }
function distance ( x1 , y1 , z1 , x2 , y2 , z2 ) { var d = Math . pow ( ( Math . pow ( x2 - x1 , 2 ) + Math . pow ( y2 - y1 , 2 ) + Math . pow ( z2 - z1 , 2 ) * 1.0 ) , 0.5 ) ; document . write ( " " + d . toFixed ( 10 ) ) ; return ; }
function printNthElement ( n ) { var arr = Array ( n + 1 ) . fill ( 0 ) ; arr [ 1 ] = 4 ; arr [ 2 ] = 7 ; for ( var i = 3 ; i <= n ; i ++ ) { if ( i % 2 != 0 ) arr [ i ] = arr [ i / 2 ] * 10 + 4 ; else arr [ i ] = arr [ ( i / 2 ) - 1 ] * 10 + 7 ; } return arr [ n ] ; }
function calSum ( n ) { let a = 3 , b = 0 , c = 2 ; return 3 ; return 3 ; return 5 ; let sum = 5 ; while ( n > 2 ) { let d = a + b ; sum += d ; a = b ; b = c ; c = d ; n -- ; } return sum ; }
function recLen ( str ) { if ( str == " " ) return 0 ; else return recLen ( str . substring ( 1 ) ) + 1 ; }
function findNth ( N ) { let b = 14 ; for ( let i = 2 ; i <= N ; i ++ ) { if ( i % 2 == 0 ) b = b * 2 ; else b = b - 8 ; } return b ; }
function geometricMean ( arr , n ) { var sum = 0 ; for ( var i = 0 ; i < n ; i ++ ) sum = sum + Math . log ( arr [ i ] ) ; sum = sum / n ; return Math . exp ( sum ) ; }
function allBitsSetInTheGivenRange ( n , l , r ) { var num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ; var new_num = n & num ; if ( new_num == 0 ) return " " ; return " " ; }
function subtractOne ( x ) { return ( ( x << 1 ) + ( ~ x ) ) ; }
function AvgofSquareN ( n ) { return ( ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; }
function countNumbers ( n ) { if ( n % 2 == 1 ) return 0 ; return ( 9 * Math . pow ( 10 , parseInt ( n / 2 ) - 1 ) ) ; }
function printSubsets ( n ) { for ( let i = n ; i > 0 ; i = ( i - 1 ) & n ) document . write ( i + " " ) ; document . write ( " " + " " ) ; }
function leftRotate ( arr , n , k ) { let mod = k % n ; for ( let i = 0 ; i < n ; i ++ ) document . write ( ( arr [ ( mod + i ) % n ] ) + " " ) ; document . write ( " " ) ; }
function length_of_chord ( r , x ) { document . write ( " " + " " + 2 * r * Math . sin ( x * ( 3.14 / 180 ) ) + " " ) ; }
function printLeaders ( arr , size ) { for ( let i = 0 ; i < size ; i ++ ) { let j ; for ( j = i + 1 ; j < size ; j ++ ) { if ( arr [ i ] <= arr [ j ] ) break ; } if ( j == size ) document . write ( arr [ i ] + " " ) ; } }
function sumOfAP ( a , d , n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { sum = sum + a ; a = a + d ; } return sum ; }
function sum ( k , n ) { let sum = 0 ; for ( let i = 0 ; i <= n ; i ++ ) { let p = 1 ; for ( let j = 0 ; j < n - i ; j ++ ) { p = p * k ; } for ( let j = 0 ; j < i ; j ++ ) { p = p * ( k - 1 ) ; } sum = sum + p ; } return sum ; }
function polygonArea ( X , Y , n ) { let area = 0.0 ; let j = n - 1 ; for ( let i = 0 ; i < n ; i ++ ) { area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) ; } return Math . abs ( area / 2.0 ) ; }
function countOccurrences ( str , word ) { let a = str . split ( " " ) ; let count = 0 ; for ( let i = 0 ; i < a . length ; i ++ ) { if ( word == ( a [ i ] ) ) count ++ ; } return count ; }
function maxVol ( P , A ) { let l = ( P - Math . sqrt ( P * P - 24 * A ) ) / 12 ; let V = l * ( A / 2.0 - l * ( P / 4.0 - l ) ) ; return V ; }
function rearrange ( arr , n ) { let temp = new Array ( n ) ; let small = 0 , large = n - 1 ; let flag = true ; for ( let i = 0 ; i < n ; i ++ ) { if ( flag ) temp [ i ] = arr [ large -- ] ; else temp [ i ] = arr [ small ++ ] ; flag = ! flag ; } for ( let i = 0 ; i < n ; i ++ ) arr [ i ] = temp [ i ] ; }
function printXYZ ( n ) { if ( n == 1 ) document . write ( - 1 ) ; else document . write ( " " + n + " " + ( n + 1 ) + " " + n * ( n + 1 ) ) ; }
function check ( arr , n ) { for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] & 1 ) return true ; } return false ; }
function isOsiris ( n ) { let a = n % 10 ; let b = parseInt ( ( n / 10 ) % 10 ) ; let c = parseInt ( n / 100 ) ; let digit_sum = a + b + c ; if ( n == ( 2 * ( digit_sum ) * 11 ) ) { return true ; } return false ; }
function findMedian ( a , n ) { a . sort ( ) ; if ( n % 2 != 0 ) return a [ parseInt ( n / 2 ) ] ; return ( a [ parseInt ( ( n - 1 ) / 2 ) ] + a [ parseInt ( n / 2 ) ] ) / 2.0 ; }
function gcd ( a , b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
function numberOfSquares ( base ) { base = ( base - 2 ) ; base = Math . floor ( base / 2 ) ; return base * ( base + 1 ) / 2 ; }
function centereddecagonalnum ( n ) { return ( 5 * n * n + 5 * n + 1 ) ; }
function replace ( s , c1 , c2 ) { let l = s . length ; let arr = s . split ( " " ) ; for ( let i = 0 ; i < l ; i ++ ) { if ( arr [ i ] == c1 ) arr [ i ] = c2 ; else if ( arr [ i ] == c2 ) arr [ i ] = c1 ; } return arr . join ( " " ) ; }
function printMaxActivities ( s , f , n ) { let i , j ; document . write ( " " ) ; i = 0 ; document . write ( i + " " ) ; for ( j = 1 ; j < n ; j ++ ) { if ( s [ j ] >= f [ i ] ) { document . write ( j + " " ) ; i = j ; } } }
function sumOfSeries ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) for ( let j = 1 ; j <= i ; j ++ ) sum = sum + i ; return sum ; }
function find_area ( r , d ) { let R = d / PI ; R += Math . pow ( r , 2 ) ; R = Math . sqrt ( R ) ; let area = PI * Math . pow ( R , 2 ) ; return area ; }
function search ( pat , txt ) { let M = pat . length ; let N = txt . length ; let i = 0 ; while ( i <= N - M ) { let j ; for ( j = 0 ; j < M ; j ++ ) if ( txt [ i + j ] != pat [ j ] ) break ; if ( j == M ) { document . write ( " " + i + " " ) ; i = i + M ; } else if ( j == 0 ) i = i + 1 ; else i = i + j ; } }
function minRemoval ( str ) { var hash = Array ( MAX_CHAR ) . fill ( 0 ) ; for ( var i = 0 ; str [ i ] ; i ++ ) hash [ str [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; var count = 0 ; for ( var i = 0 ; i < MAX_CHAR ; i ++ ) if ( hash [ i ] % 2 ) count ++ ; return ( count == 0 ) ? 0 : count - 1 ; }
function smallest_pair ( a , n ) { let min = Number . MAX_VALUE , secondMin = Number . MAX_VALUE ; for ( let j = 0 ; j < n ; j ++ ) { if ( a [ j ] < min ) { secondMin = min ; min = a [ j ] ; } else if ( ( a [ j ] < secondMin ) && a [ j ] != min ) secondMin = a [ j ] ; } return ( secondMin + min ) ; }
function doMatch ( A , B ) { for ( i = 0 ; i < A . length ; i ++ ) { if ( A . charAt ( i ) != ' ' && B . charAt ( i ) != ' ' ) { if ( A . charAt ( i ) != B . charAt ( i ) ) return 0 ; } } return 1 ; }
function find ( start , adj , n , dp ) { if ( start == n ) return 0 ; if ( dp [ start ] != - 1 ) return dp [ start ] ; dp [ start ] = 0 ; var one = 0 , zero = 0 , k ; for ( k = start ; k < n ; k ++ ) { if ( adj [ k ] == ' ' ) one ++ ; else zero ++ ; if ( one > zero ) dp [ start ] = Math . max ( dp [ start ] , find ( k + 1 , adj , n , dp ) + k - start + 1 ) ; else dp [ start ] = Math . max ( dp [ start ] , find ( k + 1 , adj , n , dp ) ) ; } return dp [ start ] ; }
function findpos ( n ) { var pos = 0 ; for ( i = 0 ; i < n . length ; i ++ ) { switch ( n . charAt ( i ) ) { case ' ' : pos = pos * 4 + 1 ; break ; case ' ' : pos = pos * 4 + 2 ; break ; case ' ' : pos = pos * 4 + 3 ; break ; case ' ' : pos = pos * 4 + 4 ; break ; } } return pos ; }
function findWinner ( A , n ) { let res = 0 ; for ( let i = 0 ; i < n ; i ++ ) res ^= A [ i ] ; if ( res == 0 n % 2 == 0 ) return " " ; else return " " ; }
function maxAND ( L , R ) { if ( L == R ) return L ; else if ( ( R - L ) == 1 ) return ( R & L ) ; else { if ( ( ( R - 1 ) & R ) > ( ( R - 2 ) & ( R - 1 ) ) ) return ( ( R - 1 ) & R ) ; else return ( ( R - 2 ) & ( R - 1 ) ) ; } }
function isFibbinaryNum ( n ) { if ( ( n & ( n >> 1 ) ) == 0 ) return true ; return false ; }
function printTriplets ( arr , n , sum ) { arr . sort ( function ( a , b ) { return a - b } ) ; for ( let i = 0 ; i < n - 2 ; i ++ ) { let j = i + 1 , k = n - 1 ; while ( j < k ) { if ( arr [ i ] + arr [ j ] + arr [ k ] >= sum ) k -- ; else { for ( let x = j + 1 ; x <= k ; x ++ ) document . write ( arr [ i ] + " " + arr [ j ] + " " + arr [ x ] + " " ) ; j ++ ; } } } }
function decToBinary ( n ) { let binaryNum = new Array ( 32 ) ; let i = 0 ; while ( n > 0 ) { binaryNum [ i ] = n % 2 ; n = Math . floor ( n / 2 ) ; i ++ ; } for ( let j = i - 1 ; j >= 0 ; j -- ) document . write ( binaryNum [ j ] ) ; }
function LargestString ( na ) { let N = na . length ; let c = new Array ( N ) ; let m = 1 ; for ( let j = 0 ; j < N ; j ++ ) { let character = new Array ( 26 , 0 ) ; for ( let k = 0 ; k < na [ j ] . length ; k ++ ) { let x = na [ j ] [ k ] . charCodeAt ( 0 ) - 65 ; if ( ( na [ j ] [ k ] != ' ' ) && ( character [ x ] == 0 ) ) { c [ j ] ++ ; character [ x ] = 1 ; } } if ( c [ j ] > c [ m ] ) m = j ; } document . write ( na [ m ] ) ; }
function minSteps ( str ) { let count = 0 ; for ( let i = 0 ; i < str . length - 2 ; i ++ ) { if ( ( str [ i ] ) == ' ' ) { if ( str [ i + 1 ] == ' ' ) { if ( str [ i + 2 ] == ' ' ) { count ++ ; i += 2 ; } } } } return count ; }
function sortExceptK ( arr , k , n ) { let temp = arr [ k ] ; arr [ k ] = arr [ n - 1 ] ; arr [ n - 1 ] = temp ; arr . sort ( function ( a , b ) { return a - b } ) ; let last = arr [ n - 1 ] ; for ( let i = n - 1 ; i > k ; i -- ) arr [ i ] = arr [ i - 1 ] ; arr [ k ] = last ; temp = arr [ k ] ; arr [ k ] = arr [ n - 1 ] ; arr [ n - 1 ] = temp ; return 0 ; }
function isAutomorphic ( N ) { let sq = N * N ; while ( N > 0 ) { if ( N % 10 != sq % 10 ) return - 1 ; N /= 10 ; sq /= 10 ; } return 1 ; }
function center_hexadecagonal_num ( n ) { return 8 * n * n - 8 * n + 1 ; }
function nthTerm ( N ) { let nth = 0 ; nth = parseInt ( ( N * N * ( N + 1 ) ) / 2 ) ; return nth ; }
function isInside ( circle_x , circle_y , rad , x , y ) { if ( ( x - circle_x ) * ( x - circle_x ) + ( y - circle_y ) * ( y - circle_y ) <= rad * rad ) return true ; else return false ; } var x = 1 ; var y = 1 ; var circle_x = 0 ; var circle_y = 1 ; var rad = 2 ; if ( isInside ( circle_x , circle_y , rad , x , y ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function avg_of_odd_num ( n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum += ( 2 * i + 1 ) ; return sum / n ; }
function posOfRightMostDiffBit ( m , n ) { return parseInt ( Math . floor ( Math . log10 ( Math . pow ( m ^ n , 2 ) ) ) , 10 ) + 2 ; }
function steps ( source , step , dest ) { if ( Math . abs ( source ) > ( dest ) ) return Number . MAX_SAFE_INTEGER ; if ( source == dest ) return step ; let pos = steps ( source + step + 1 , step + 1 , dest ) ; let neg = steps ( source - step - 1 , step + 1 , dest ) ; return Math . min ( pos , neg ) ; }
function calculateSum ( n ) { return ( n * ( 4 * n * n + 6 * n - 1 ) / 3 ) ; }
function isPath ( arr ) { arr [ 0 ] [ 0 ] = 1 ; for ( var i = 1 ; i < 5 ; i ++ ) if ( arr [ i ] [ 0 ] != - 1 ) arr [ i ] [ 0 ] = arr [ i - 1 ] [ 0 ] ; for ( var j = 1 ; j < 5 ; j ++ ) if ( arr [ 0 ] [ j ] != - 1 ) arr [ 0 ] [ j ] = arr [ 0 ] [ j - 1 ] ; for ( var i = 1 ; i < 5 ; i ++ ) for ( var j = 1 ; j < 5 ; j ++ ) if ( arr [ i ] [ j ] != - 1 ) arr [ i ] [ j ] = Math . max ( arr [ i ] [ j - 1 ] , arr [ i - 1 ] [ j ] ) ; return ( arr [ 5 - 1 ] [ 5 - 1 ] == 1 ) ; }
function minimumSteps ( n , m , a , b ) { if ( n > m ) return MAXN ; if ( n == m ) return 0 ; return Math . min ( 1 + minimumSteps ( n * a , m , a , b ) , 1 + minimumSteps ( n * b , m , a , b ) ) ; }
function findUniquePair ( arr , n ) { let XOR = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) XOR = XOR ^ arr [ i ] ; let set_bit_no = XOR & ~ ( XOR - 1 ) ; let x = 0 , y = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] & set_bit_no ) > 0 ) x = x ^ arr [ i ] ; else y = y ^ arr [ i ] ; } document . write ( " " + x + " " + y + " " + " " ) ; }
function areacircumscribed ( a ) { return ( a * a * ( 3.1415 / 2 ) ) ; }
function Div_by_8 ( n ) { return ( ( ( n >> 3 ) << 3 ) == n ) ; }
function getSum ( n ) { let sum = 0 ; while ( n > 0 sum > 9 ) { if ( n == 0 ) { n = sum ; sum = 0 ; } sum = sum + n % 10 ; n = Math . floor ( n / 10 ) ; } return sum ; }
function countDigit ( n ) { let temp = n ; let sum = 0 ; let product = 1 ; while ( temp != 0 ) { let d = temp % 10 ; temp = parseInt ( temp / 10 ) ; if ( d > 0 && n % d == 0 ) { sum += d ; product *= d ; } } document . write ( " " + sum ) ; document . write ( " " + product ) ; }
function cosXSertiesSum ( x , n ) { x = x * ( PI / 180.0 ) ; let res = 1 ; let sign = 1 , fact = 1 , pow = 1 , i ; for ( i = 1 ; i < 5 ; i ++ ) { sign = sign * - 1 ; fact = fact * ( 2 * i - 1 ) * ( 2 * i ) ; pow = pow * x * x ; res = res + sign * pow / fact ; } return res ; }
function nthTerm ( n ) { return ( n * n ) + ( n * n * n ) ; }
function countDyckPaths ( n ) { let res = 1 ; for ( let i = 0 ; i < n ; ++ i ) { res *= ( 2 * n - i ) ; res /= ( i + 1 ) ; } return res / ( n + 1 ) ; }
function getSum ( a , n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; ++ i ) { sum += ( i / Math . pow ( a , i ) ) ; } return sum ; }
function maximumResult ( a , b , c ) { let countOfNegative = 0 ; let sum = a + b + c ; let product = a * b * c ; let largest = Math . max ( a , Math . max ( b , c ) ) ; let smallest = Math . min ( a , Math . min ( b , c ) ) ; if ( a < 0 ) countOfNegative ++ ; if ( b < 0 ) countOfNegative ++ ; if ( c < 0 ) countOfNegative ++ ; switch ( countOfNegative ) { case 0 : return ( sum - largest ) * largest ; case 1 : return ( product / smallest ) + smallest ; case 2 : return ( product / largest ) + largest ; case 3 : return ( sum - smallest ) * smallest ; } }
function numberOfWays ( x ) { if ( x == 0 x == 1 ) return 1 ; else return numberOfWays ( x - 1 ) + ( x - 1 ) * numberOfWays ( x - 2 ) ; }
function otherNumber ( A , Lcm , Hcf ) { return ( Lcm * Hcf ) / A ; }
function findevenPair ( A , N ) { let i , j ; let evenPair = 0 ; for ( i = 0 ; i < N ; i ++ ) { for ( j = i + 1 ; j < N ; j ++ ) { if ( ( A [ i ] & A [ j ] ) % 2 == 0 ) evenPair ++ ; } } return evenPair ; }
function removeRecur ( n ) { let prev_digit = n % 10 ; let pow = 10 ; let res = prev_digit ; while ( n > 0 ) { let curr_digit = n % 10 ; if ( curr_digit != prev_digit ) { res += curr_digit * pow ; prev_digit = curr_digit ; pow *= 10 ; } n = parseInt ( n / 10 , 10 ) ; } return res ; }
function toggleBits ( n1 , n2 ) { return ( n1 ^ n2 ) ; }
function count ( n ) { if ( n < 3 ) return n ; if ( n >= 3 && n < 10 ) return n - 1 ; var po = 1 ; while ( parseInt ( n / po ) > 9 ) po = po * 10 ; var msd = parseInt ( n / po ) ; if ( msd != 3 ) return count ( msd ) * count ( po - 1 ) + count ( msd ) + count ( n % po ) ; else return count ( msd * po - 1 ) ; }
function submatrixXor ( arr ) { let ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { let top_left = ( i + 1 ) * ( j + 1 ) ; let bottom_right = ( n - i ) * ( n - j ) ; if ( ( top_left % 2 == 1 ) && ( bottom_right % 2 == 1 ) ) ans = ( ans ^ arr [ i ] [ j ] ) ; } } return ans ; }
function findMaxRec ( A , n ) { if ( n == 1 ) return A [ 0 ] ; return Math . max ( A [ n - 1 ] , findMaxRec ( A , n - 1 ) ) ; }
function answer_query ( a , n , l , r ) { var count = 0 ; for ( var i = l ; i < r ; i ++ ) if ( a [ i ] == a [ i + 1 ] ) count += 1 ; return count ; }
function sequence ( n ) { let f = [ ] ; f [ 0 ] = 0 ; f [ 1 ] = 1 ; f [ 2 ] = 1 ; document . write ( f [ 1 ] + " " + f [ 2 ] + " " ) ; for ( let i = 3 ; i <= n ; i ++ ) { f [ i ] = f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ] ; document . write ( f [ i ] + " " ) ; } }
function power ( x , y , p ) { let res = 1 ; x = x % p ; if ( x == 0 ) return 0 ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % p ; y = $y / 2 y = y >> 1 ; x = ( x * x ) % p ; } return res ; }
function countStrings ( n , k ) { let dp = new Array ( n + 1 ) ; for ( let i = 0 ; i < n + 1 ; i ++ ) { dp [ i ] = new Array ( k + 1 ) ; for ( let j = 0 ; j < k + 1 ; j ++ ) { dp [ i ] [ j ] = new Array ( 2 ) ; for ( let l = 0 ; l < 2 ; l ++ ) { dp [ i ] [ j ] [ l ] = 0 ; } } } dp [ 1 ] [ 0 ] [ 0 ] = 1 ; dp [ 1 ] [ 0 ] [ 1 ] = 1 ; for ( let i = 2 ; i <= n ; i ++ ) { for ( let j = 0 ; j < i && j < k + 1 ; j ++ ) { dp [ i ] [ j ] [ 0 ] = dp [ i - 1 ] [ j ] [ 0 ] + dp [ i - 1 ] [ j ] [ 1 ] ; dp [ i ] [ j ] [ 1 ] = dp [ i - 1 ] [ j ] [ 0 ] ; if ( j - 1 >= 0 ) { dp [ i ] [ j ] [ 1 ] += dp [ i - 1 ] [ j - 1 ] [ 1 ] ; } } } return dp [ n ] [ k ] [ 0 ] + dp [ n ] [ k ] [ 1 ] ; }
function CalPeri ( ) { var S = 5 , Perimeter ; Perimeter = 10 * S ; document . write ( " " + Perimeter ) ; }
function heptdiagonal ( a ) { if ( a < 0 ) return - 1 ; var d = 1.802 * a ; return d ; }
function nobleInteger ( arr ) { let size = arr . length ; for ( let i = 0 ; i < size ; i ++ ) { let count = 0 ; for ( let j = 0 ; j < size ; j ++ ) if ( arr [ i ] < arr [ j ] ) count ++ ; if ( count == arr [ i ] ) return arr [ i ] ; } return - 1 ; }
function calculate_sum ( a , N ) { m = N / a ; sum = m * ( m + 1 ) / 2 ; ans = a * sum ; return ans ; }
function average ( arr , n , k ) { var total = 0 ; if ( 2 * k >= n ) return 0 ; arr . sort ( ) ; var start = k , end = n - k - 1 ; for ( i = start ; i <= end ; i ++ ) total += arr [ i ] ; return ( total / ( n - 2 * k ) ) ; }
function totalSumDivisibleByNum ( digit , number ) { let firstnum = Math . pow ( 10 , digit - 1 ) ; let lastnum = Math . pow ( 10 , digit ) ; firstnum = ( firstnum - firstnum % number ) + number ; lastnum = ( lastnum - lastnum % number ) ; let count = ( ( lastnum - firstnum ) / number + 1 ) ; return ( ( lastnum + firstnum ) * count ) / 2 ; }
function countNum ( arr , n ) { let count = 0 ; arr . sort ( ) ; for ( let i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] != arr [ i + 1 ] && arr [ i ] != arr [ i + 1 ] - 1 ) count += arr [ i + 1 ] - arr [ i ] - 1 ; return count ; }
function printMaxNumber ( n ) { if ( n & 1 ) { document . write ( " " ) ; for ( var i = 0 ; i < ( n - 3 ) / 2 ; i ++ ) document . write ( " " ) ; } else { for ( var i = 0 ; i < n / 2 ; i ++ ) document . write ( " " ) ; } }
function middleOfThree ( a , b , c ) { if ( ( a < b && b < c ) || ( c < b && b < a ) ) return b ; else if ( ( b < a && a < c ) || ( c < a && a < b ) ) return a ; else return c ; }
function findPairs ( arr1 , arr2 , n , m , x ) { for ( let i = 0 ; i < n ; i ++ ) for ( let j = 0 ; j < m ; j ++ ) if ( arr1 [ i ] + arr2 [ j ] == x ) document . write ( arr1 [ i ] + " " + arr2 [ j ] + " " ) ; }
function check ( str ) { let n = str . length ; let oddDigSum = 0 , evenDigSum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) oddDigSum += ( str [ i ] - ' ' ) ; else evenDigSum += ( str [ i ] - ' ' ) ; } return ( ( oddDigSum - evenDigSum ) % 11 == 0 ) ; }
function countPairs ( n ) { let count = 0 ; for ( let x = 1 ; x < n ; x ++ ) { for ( let y = x + 1 ; y <= n ; y ++ ) { if ( ( y * x ) % ( y + x ) == 0 ) count ++ ; } } return count ; }
function maxBalancedStr ( s ) { var open1 = 0 , close1 = 0 ; var open2 = 0 , close2 = 0 ; var open3 = 0 , close3 = 0 ; for ( i = 0 ; i < s . length ; i ++ ) { switch ( s . charAt ( i ) ) { case ' ' : open1 ++ ; break ; case ' ' : close1 ++ ; break ; case ' ' : open2 ++ ; break ; case ' ' : close2 ++ ; break ; case ' ' : open3 ++ ; break ; case ' ' : close3 ++ ; break ; } } var maxLen = 2 * Math . min ( open1 , close1 ) + 2 * Math . min ( open2 , close2 ) + 2 * Math . min ( open3 , close3 ) ; return maxLen ; }
function findNthNonSquare ( n ) { var x = n ; var ans = x + Math . floor ( 0.5 + Math . sqrt ( x ) ) ; return parseInt ( ans ) ; }
function printMedian ( arr , n , K ) { arr . sort ( ) ; document . write ( arr [ Math . floor ( ( n + K ) / 2 ) ] ) ; }
function squareSum ( n ) { return n * ( 4 * n * n - 1 ) / 3 ; }
function calculateSum ( n ) { if ( n % 2 == 1 ) return ( n + 1 ) / 2 ; return - n / 2 ; }
function isDivisibleBy5 ( str ) { n = str . length ; return ( ( ( str [ n - 1 ] - ' ' ) == 0 ) || ( ( str [ n - 1 ] - ' ' ) == 5 ) ) ; }
function checkcircle ( r , R , r1 , x1 , y1 ) { let dis = Math . sqrt ( x1 * x1 + y1 * y1 ) ; return ( dis - r1 >= R && dis + r1 <= r ) ; }
function Remainder ( str , R ) { var len = str . length ; var Num , Rem = 0 ; for ( var i = 0 ; i < len ; i ++ ) { Num = Rem * 10 + ( str [ i ] - ' ' ) ; Rem = Num % R ; } return Rem ; }
function gcdMax ( a , b , n , N ) { let cnt = Array . from ( { length : N } , ( _ , i ) => 0 ) ; let first = Array . from ( { length : N } , ( _ , i ) => 0 ) ; let second = Array . from ( { length : N } , ( _ , i ) => 0 ) ; for ( let i = 0 ; i < n ; ++ i ) cnt [ a [ i ] ] = 1 ; for ( let i = 1 ; i < N ; ++ i ) for ( let j = i ; j < N ; j += i ) if ( cnt [ j ] > 0 ) first [ i ] = Math . max ( first [ i ] , j ) ; cnt = Array . from ( { length : N } , ( _ , i ) => 0 ) ; for ( let i = 0 ; i < n ; ++ i ) cnt [ b [ i ] ] = 1 ; for ( let i = 1 ; i < N ; ++ i ) for ( let j = i ; j < N ; j += i ) if ( cnt [ j ] > 0 ) second [ i ] = Math . max ( second [ i ] , j ) ; let x ; for ( x = N - 1 ; x >= 0 ; x -- ) if ( first [ x ] > 0 && second [ x ] > 0 ) break ; document . write ( first [ x ] + " " + second [ x ] ) ; }
function findEletobeInserted ( A , n , k ) { var ans = k ; for ( var i = 0 ; i < n ; i ++ ) ans ^= A [ i ] ; return ans ; }
function countPairs ( n ) { let num = ( parseInt ( n / 2 , 10 ) + 1 ) ; let max = n % num ; let count = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { for ( let j = 1 ; j <= n ; j ++ ) { let val = ( ( n % i ) % j ) % n ; if ( val == max ) count ++ ; } } return count ; }
function printString ( str , n ) { let ones = 0 ; for ( let i = 0 ; i < n ; i ++ ) if ( str [ i ] == ' ' ) ones ++ ; let used = false ; for ( let i = 0 ; i < n ; i ++ ) { if ( str [ i ] == ' ' && ! used ) { used = true ; for ( let j = 0 ; j < ones ; j ++ ) document . write ( " " ) ; } if ( str [ i ] != ' ' ) document . write ( str [ i ] ) ; } if ( ! used ) for ( let j = 0 ; j < ones ; j ++ ) document . write ( " " ) ; }
function getGreatestSum ( a ) { let prev_max = 0 ; for ( let j = 0 ; j < N ; j ++ ) if ( prev_max < a [ N - 1 ] [ j ] ) prev_max = a [ N - 1 ] [ j ] ; let sum = prev_max ; for ( let i = N - 2 ; i >= 0 ; i -- ) { let curr_max = - 2147483648 ; for ( let j = 0 ; j < N ; j ++ ) if ( prev_max > a [ i ] [ j ] && a [ i ] [ j ] > curr_max ) curr_max = a [ i ] [ j ] ; if ( curr_max == - 2147483648 ) return - 1 ; prev_max = curr_max ; sum += prev_max ; } return sum ; }
function coin ( totalRupees , X , Y , Z ) { var one = 0 , fifty = 0 , twentyfive = 0 , result = 0 , total = 0 ; one = X * 1 ; fifty = ( ( Y * 1 ) / 2.0 ) ; twentyfive = ( ( Z * 1 ) / 4.0 ) ; total = one + fifty + twentyfive ; result = ( ( totalRupees ) / total ) ; return result ; }
function countSetBitsRec ( num ) { var nibble = 0 ; if ( 0 == num ) return num_to_bits [ 0 ] ; nibble = num & 0xf ; return num_to_bits [ nibble ] + countSetBitsRec ( num >> 4 ) ; }
function surfaceArea ( b , s ) { return 2 * b * s + parseInt ( Math . pow ( b , 2 ) ) ; }
function findMaxAverage ( arr , n , k ) { if ( k > n ) return - 1 ; let sum = arr [ 0 ] ; for ( let i = 1 ; i < k ; i ++ ) sum += arr [ i ] ; let max_sum = sum ; let max_end = k - 1 ; for ( let i = k ; i < n ; i ++ ) { sum = sum + arr [ i ] - arr [ i - k ] ; if ( sum > max_sum ) { max_sum = sum ; max_end = i ; } } return max_end - k + 1 ; }
function findValue ( arr , n ) { var ans = 0 ; for ( var i = 0 ; i < n ; i ++ ) for ( var j = 0 ; j < n ; j ++ ) ans = Math . max ( ans , Math . abs ( arr [ i ] - arr [ j ] ) + Math . abs ( i - j ) ) ; return ans ; }
function getMinVal ( p , q ) { if ( q % p == 0 ) return p ; return - 1 ; }
function checkSame ( n ) { let set = 0 , unset = 0 ; while ( n ) { if ( n & 1 ) set ++ ; else unset ++ ; n = n >> 1 ; } if ( set == unset ) return true ; else return false ; }
function sort ( arr ) { var n = arr . length ; var output = Array . from ( { length : n } , ( _ , i ) => 0 ) ; var count = Array . from ( { length : 256 } , ( _ , i ) => 0 ) ; for ( var i = 0 ; i < n ; ++ i ) ++ count [ arr [ i ] . charCodeAt ( 0 ) ] ; for ( var i = 1 ; i <= 255 ; ++ i ) count [ i ] += count [ i - 1 ] ; for ( var i = n - 1 ; i >= 0 ; i -- ) { output [ count [ arr [ i ] . charCodeAt ( 0 ) ] - 1 ] = arr [ i ] ; -- count [ arr [ i ] . charCodeAt ( 0 ) ] ; } for ( var i = 0 ; i < n ; ++ i ) arr [ i ] = output [ i ] ; return arr ; }
function ksmallest ( arr , n , k ) { arr . sort ( function ( a , b ) { return a - b } ) ; if ( k < arr [ 0 ] ) return k ; if ( k == arr [ 0 ] ) return arr [ 0 ] + 1 ; if ( k > arr [ n - 1 ] ) return k + n ; if ( arr [ 0 ] == 1 ) k -- ; else k -= ( arr [ 0 ] - 1 ) ; for ( let i = 1 ; i < n ; i ++ ) { let c = arr [ i ] - arr [ i - 1 ] - 1 ; if ( k <= c ) return arr [ i - 1 ] + k ; else k -= c ; } return arr [ n - 1 ] + k ; }
function calculateProduct ( A , L , R , P ) { L = L - 1 ; R = R - 1 ; let ans = 1 ; for ( let i = L ; i <= R ; i ++ ) { ans = ans * A [ i ] ; ans = ans % P ; } return ans ; }
function LucasSum ( N ) { var sum = 0 ; var a = 2 , b = 1 , c ; sum += a ; while ( b <= N ) { sum += b ; var c = a + b ; a = b ; b = c ; } return sum ; }
function centeredTridecagonalNum ( n ) { return ( 13 * n * ( n - 1 ) + 2 ) / 2 ; }
function vol_tetra ( side ) { let volume = ( Math . pow ( side , 3 ) / ( 6 * Math . sqrt ( 2 ) ) ) ; return volume ; }
function check ( str ) { let n = str . length ; if ( n == 0 && n == 1 ) return false ; if ( n == 2 ) return ( ( ( str [ n - 2 ] - ' ' ) * 10 + ( str [ n - 1 ] - ' ' ) ) % 16 == 0 ) ; if ( n == 3 ) return ( ( ( str [ n - 3 ] - ' ' ) * 100 + ( str [ n - 2 ] - ' ' ) * 10 + ( str [ n - 1 ] - ' ' ) ) % 16 == 0 ) ; let last = str [ n - 1 ] - ' ' ; let second_last = str [ n - 2 ] - ' ' ; let third_last = str [ n - 3 ] - ' ' ; let fourth_last = str [ n - 4 ] - ' ' ; return ( ( fourth_last * 1000 + third_last * 100 + second_last * 10 + last ) % 16 == 0 ) ; }
function findS ( s ) { var sum = 0 ; for ( n = 1 ; sum < s ; n ++ ) { sum += n ; if ( sum == s ) return n ; } return - 1 ; }
function MaximumHeight ( a , n ) { let result = 1 ; for ( i = 1 ; i <= n ; ++ i ) { let y = ( i * ( i + 1 ) ) / 2 ; if ( y < n ) result = i ; else break ; } return result ; }
function calculateSum ( n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { sum = sum + ( 1 << i ) ; } return sum ; }
function countNumbers ( n ) { return n - parseInt ( n / 2 , 10 ) - parseInt ( n / 3 , 10 ) - parseInt ( n / 5 , 10 ) - parseInt ( n / 7 , 10 ) + parseInt ( n / 6 , 10 ) + parseInt ( n / 10 , 10 ) + parseInt ( n / 14 , 10 ) + parseInt ( n / 15 , 10 ) + parseInt ( n / 21 , 10 ) + parseInt ( n / 35 , 10 ) - parseInt ( n / 30 , 10 ) - parseInt ( n / 42 , 10 ) - parseInt ( n / 70 , 10 ) - parseInt ( n / 105 , 10 ) + parseInt ( n / 210 , 10 ) ; }
function lengtang ( r1 , r2 ) { document . write ( " " + " " + ( 2 * Math . sqrt ( r1 * r2 ) ) . toFixed ( 5 ) ) ; }
function isEven ( n ) { let isEven = true ; for ( let i = 1 ; i <= n ; i ++ ) isEven = ! isEven ; return isEven ; }
function search ( txt , pat ) { let M = pat . length ; let N = txt . length ; for ( let i = 0 ; i <= N - M ; i ++ ) { let j ; for ( j = 0 ; j < M ; j ++ ) if ( txt [ i + j ] != pat [ j ] ) break ; if ( j == M ) document . write ( " " + i + " " ) ; } }
function isIdentity ( mat , N ) { for ( let row = 0 ; row < N ; row ++ ) { for ( let col = 0 ; col < N ; col ++ ) { if ( row == col && mat [ row ] [ col ] != 1 ) return false ; else if ( row != col && mat [ row ] [ col ] != 0 ) return false ; } } return true ; }
function distance ( a1 , b1 , c1 , d1 , a2 , b2 , c2 , d2 ) { let x1 , y1 , z1 , d ; if ( a1 / a2 == b1 / b2 && b1 / b2 == c1 / c2 ) { x1 = y1 = 0 ; z1 = - d1 / c1 ; d = Math . abs ( ( c2 * z1 + d2 ) ) / ( Math . sqrt ( a2 * a2 + b2 * b2 + c2 * c2 ) ) ; document . write ( " " + d ) ; } else document . write ( " " ) ; }
function maxCost ( mat , N ) { let dp = new Array ( N ) ; for ( let i = 0 ; i < N ; i ++ ) { dp [ i ] = new Array ( N ) ; for ( let j = 0 ; j < N ; j ++ ) { dp [ i ] [ j ] = 0 ; } } dp [ 0 ] [ 0 ] = mat [ 0 ] [ 0 ] ; for ( let i = 1 ; i < N ; i ++ ) dp [ i ] [ 0 ] = mat [ i ] [ 0 ] + dp [ i - 1 ] [ 0 ] ; for ( let i = 1 ; i < N ; i ++ ) for ( let j = 1 ; j < i + 1 && j < N ; j ++ ) dp [ i ] [ j ] = mat [ i ] [ j ] + Math . max ( dp [ i - 1 ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ; let result = 0 ; for ( let i = 0 ; i < N ; i ++ ) if ( result < dp [ N - 1 ] [ i ] ) result = dp [ N - 1 ] [ i ] ; return result ; }
function printFourSquares ( a ) { for ( let i = 0 ; i * i <= a ; i ++ ) { for ( let j = i ; j * j <= a ; j ++ ) { for ( let k = j ; k * k <= a ; k ++ ) { for ( let l = k ; l * l <= a ; l ++ ) { if ( i * i + j * j + k * k + l * l == a ) { document . write ( a + " " + i + " " + i + " " + j + " " + j + " " ) ; document . write ( k + " " + k + " " + l + " " + l + " " ) ; } } } } } }
function calcSafe ( pos ) { let j = pos % 10 ; let i = Math . floor ( pos / 10 ) ; let dis_11 = Math . min ( Math . abs ( 1 - i ) , Math . abs ( 1 - j ) ) ; let dis_18 = Math . min ( Math . abs ( 1 - i ) , Math . abs ( 8 - j ) ) ; let dis_81 = Math . min ( Math . abs ( 8 - i ) , Math . abs ( 1 - j ) ) ; let dis_88 = Math . min ( Math . abs ( 8 - i ) , Math . abs ( 8 - j ) ) ; let sum = dis_11 + dis_18 + dis_81 + dis_88 + 1 ; return ( 64 - sum ) ; }
function fitOrNotFit ( R , r , x , y , rad ) { var val = Math . sqrt ( Math . pow ( x , 2 ) + Math . pow ( y , 2 ) ) ; if ( val + rad <= R && val - rad >= R - r ) document . write ( " " ) ; else document . write ( " " ) ; }
function sumOfDigitsFrom1ToN ( n ) { if ( n < 10 ) return ( n * ( n + 1 ) / 2 ) ; let d = parseInt ( Math . log ( n ) / Math . log ( 10 ) , 10 ) ; let a = new Array ( d + 1 ) ; a [ 0 ] = 0 ; a [ 1 ] = 45 ; for ( let i = 2 ; i <= d ; i ++ ) a [ i ] = a [ i - 1 ] * 10 + 45 * parseInt ( Math . ceil ( Math . pow ( 10 , i - 1 ) ) , 10 ) ; let p = parseInt ( Math . ceil ( Math . pow ( 10 , d ) ) , 10 ) ; let msd = parseInt ( n / p , 10 ) ; return ( msd * a [ d ] + ( msd * ( msd - 1 ) / 2 ) * p + msd * ( 1 + n % p ) + sumOfDigitsFrom1ToN ( n % p ) ) ; }
function trianglearea ( a , b ) { if ( a < 0 b < 0 ) return - 1 ; var area = ( 3 * Math . sqrt ( 3 ) * Math . pow ( a , 2 ) ) / ( 4 * b ) ; return area ; }
function exponentMod ( A , B , C ) { if ( A == 0 ) return 0 ; if ( B == 0 ) return 1 ; var y ; if ( B % 2 == 0 ) { y = exponentMod ( A , B / 2 , C ) ; y = ( y * y ) % C ; } else { y = A % C ; y = ( y * exponentMod ( A , B - 1 , C ) % C ) % C ; } return parseInt ( ( ( y + C ) % C ) ) ; }
function lastCoordinate ( n , a , b ) { return ( parseInt ( n + 1 ) / 2 ) * a - parseInt ( n / 2 ) * b ; }
function maxAbsDiff ( arr , n ) { let minEle = arr [ 0 ] ; let maxEle = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { minEle = Math . min ( minEle , arr [ i ] ) ; maxEle = Math . max ( maxEle , arr [ i ] ) ; } return ( maxEle - minEle ) ; }
function largestCube ( r ) { if ( r < 0 ) return - 1 ; var a = ( 2 * r ) / Math . sqrt ( 3 ) ; return a ; }
function checkPowerof8 ( n ) { let i = Math . log ( n ) / Math . log ( 8 ) ; return ( i - Math . floor ( i ) < 0.000001 ) ; }
function getInvCount ( arr ) { let inv_count = 0 ; for ( let i = 0 ; i < arr . length - 1 ; i ++ ) { for ( let j = i + 1 ; j < arr . length ; j ++ ) { if ( arr [ i ] > arr [ j ] ) inv_count ++ ; } } return inv_count ; }
function onlyFirstAndLastAreSet ( n ) { if ( n == 1 ) return true ; if ( n == 2 ) return false ; return ( ( ( n - 1 ) & ( n - 2 ) ) == 0 ) ; }
function getMinCost ( n , m ) { let cost = ( n - 1 ) * m + ( m - 1 ) * n ; return cost ; }
function minimum ( n ) { let product = 1 ; for ( let i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { while ( n % i == 0 ) n = n / i ; product = product * i ; } } if ( n >= 2 ) product = product * n ; return product ; }
function minAbsDiff ( n ) { let mod = n % 4 ; if ( mod == 0 mod == 3 ) { return 0 ; } return 1 ; }
function centeredTetrahedralNumber ( n ) { return ( 2 * n + 1 ) * ( n * n + n + 3 ) / 3 ; }
function countPairs ( A , n , k ) { var ans = 0 ; A . sort ( ( a , b ) => a - b ) for ( var i = 0 ; i < n ; i ++ ) { for ( var j = i + 1 ; j < n ; j ++ ) { var x = 0 ; while ( ( A [ i ] * Math . pow ( k , x ) ) <= A [ j ] ) { if ( ( A [ i ] * Math . pow ( k , x ) ) == A [ j ] ) { ans ++ ; break ; } x ++ ; } } } return ans ; }
function countLattice ( r ) { if ( r <= 0 ) return 0 ; var result = 4 ; for ( x = 1 ; x < r ; x ++ ) { var ySquare = r * r - x * x ; var y = parseInt ( Math . sqrt ( ySquare ) ) ; if ( y * y == ySquare ) result += 4 ; } return result ; }
function largestGCDSubsequence ( arr , n ) { var ans = 0 ; var maxele = Math . max ( ... arr ) ; for ( var i = 2 ; i <= maxele ; ++ i ) { var count = 0 ; for ( j = 0 ; j < n ; ++ j ) { if ( arr [ j ] % i == 0 ) ++ count ; } ans = Math . max ( ans , count ) ; } return ans ; }
function countNums ( n , x , y ) { arr = Array ( n + 1 ) . fill ( false ) ; if ( x <= n ) arr [ x ] = true ; if ( y <= n ) arr [ y ] = true ; var result = 0 ; for ( i = Math . min ( x , y ) ; i <= n ; i ++ ) { if ( arr [ i ] ) { if ( i + x <= n ) arr [ i + x ] = true ; if ( i + y <= n ) arr [ i + y ] = true ; result ++ ; } } return result ; }
function generateSequence ( n , g ) { for ( var i = 1 ; i <= n ; i ++ ) { document . write ( i * g + " " ) ; } }
function check ( str ) { let n = str . length ; if ( n == 0 ) return false ; if ( n == 1 ) return ( ( str [ 0 ] - ' ' ) % 8 == 0 ) ; if ( n == 2 ) return ( ( ( str [ n - 2 ] - ' ' ) * 10 + ( str [ n - 1 ] - ' ' ) ) % 8 == 0 ) ; let last = str [ n - 1 ] - ' ' ; let second_last = str [ n - 2 ] - ' ' ; let third_last = str [ n - 3 ] - ' ' ; return ( ( third_last * 100 + second_last * 10 + last ) % 8 == 0 ) ; }
function sum ( x , y , n ) { sum1 = ( Math . pow ( x , 2 ) * ( Math . pow ( x , 2 * n ) - 1 ) ) / ( Math . pow ( x , 2 ) - 1 ) ; sum2 = ( x * y * ( Math . pow ( x , n ) * Math . pow ( y , n ) - 1 ) ) / ( x * y - 1 ) ; return sum1 + sum2 ; }
function countRotations ( arr , n ) { let min = arr [ 0 ] , min_index = - 1 ; for ( let i = 0 ; i < n ; i ++ ) { if ( min > arr [ i ] ) { min = arr [ i ] ; min_index = i ; } } return min_index ; }
function check ( N , D ) { let temp = ( N * ( N + 1 ) ) / 2 + D ; return ( temp % 2 == 0 ) ; }
function sumofsquare ( n ) { let C = new Array ( n + 1 ) ; for ( let i = 0 ; i < C . length ; i ++ ) { C [ i ] = new Array ( 2 ) ; } let i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= Math . min ( i , n ) ; j ++ ) { if ( j == 0 j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } let sum = 0 ; for ( i = 0 ; i <= n ; i ++ ) sum += ( C [ n ] [ i ] * C [ n ] [ i ] ) ; return sum ; }
function getInvCount ( arr , n ) { let invcount = 0 ; for ( let i = 0 ; i < n - 1 ; i ++ ) { let small = 0 ; for ( let j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] > arr [ j ] ) small ++ ; let great = 0 ; for ( let j = i - 1 ; j >= 0 ; j -- ) if ( arr [ i ] < arr [ j ] ) great ++ ; invcount += great * small ; } return invcount ; }
function isEven ( n ) { return ( parseInt ( n / 2 , 10 ) * 2 == n ) ; }
function divide ( dividend , divisor ) { var sign = ( ( dividend < 0 ) ? 1 : 0 ^ ( divisor < 0 ) ? 1 : 0 ) ? - 1 : 1 ; dividend = Math . abs ( dividend ) ; divisor = Math . abs ( divisor ) ; var quotient = 0 , temp = 0 ; while ( dividend >= divisor ) { dividend -= divisor ; ++ quotient ; } if ( sign == - 1 ) quotient = - quotient ; return quotient ; }
function sumBitDifferences ( arr , n ) { let ans = 0 ; for ( let i = 0 ; i < 32 ; i ++ ) { let count = 0 ; for ( let j = 0 ; j < n ; j ++ ) if ( ( arr [ j ] & ( 1 << i ) ) ) count ++ ; ans += ( count * ( n - count ) * 2 ) ; } return ans ; }
function nthElement ( a , b , n ) { let seq = [ ] ; for ( let i = 1 ; i <= n ; i ++ ) seq . push ( a * i ) ; seq . sort ( function ( a , b ) { return a - b } ) ; for ( let i = 1 , k = n ; i <= n && k > 0 ; i ++ ) { if ( ! seq . includes ( b * i ) ) { seq . push ( b * i ) ; seq . sort ( function ( a , b ) { return a - b } ) ; k -- ; } } return seq [ n - 1 ] ; }
function countAnomalies ( arr , n , k ) { let res = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let j ; for ( j = 0 ; j < n ; j ++ ) if ( i != j && Math . abs ( arr [ i ] - arr [ j ] ) <= k ) break ; if ( j == n ) res ++ ; } return res ; }
function sumOddFibonacci ( n ) { var Sum = Array ( n + 1 ) . fill ( 0 ) ; Sum [ 0 ] = 0 ; Sum [ 1 ] = 1 ; Sum [ 2 ] = 2 ; Sum [ 3 ] = 5 ; Sum [ 4 ] = 10 ; Sum [ 5 ] = 23 ; for ( i = 6 ; i <= n ; i ++ ) { Sum [ i ] = ( ( Sum [ i - 1 ] + ( 4 * Sum [ i - 2 ] ) % mod - ( 4 * Sum [ i - 3 ] ) % mod + mod ) % mod + ( Sum [ i - 4 ] - Sum [ i - 5 ] + mod ) % mod ) % mod ; } return Sum [ n ] ; }
function calcNodes ( N , I ) { var result = 0 ; result = I * ( N - 1 ) + 1 ; return result ; }
function binomialCoeff ( n , k ) { if ( k > n ) return 0 ; var res = 1 ; if ( k > n - k ) k = n - k ; for ( var i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; }
function findMaxSum ( arr , n ) { var res = - 1000000000 ; for ( var i = 0 ; i < n ; i ++ ) { var prefix_sum = arr [ i ] ; for ( var j = 0 ; j < i ; j ++ ) prefix_sum += arr [ j ] ; var suffix_sum = arr [ i ] ; for ( var j = n - 1 ; j > i ; j -- ) suffix_sum += arr [ j ] ; if ( prefix_sum == suffix_sum ) res = Math . max ( res , prefix_sum ) ; } return res ; }
function countValues ( n ) { let countV = 0 ; for ( let i = 0 ; i <= n ; i ++ ) if ( ( n + i ) == ( n ^ i ) ) countV ++ ; return countV ; }
function countBuildings ( arr , n ) { let count = 1 ; let curr_max = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > curr_max arr [ i ] == curr_max ) { count ++ ; curr_max = arr [ i ] ; } } return count ; }
function noOfYears ( t1 , n1 , t2 ) { var years = ( ( t2 - 1 ) * n1 / ( t1 - 1 ) ) ; return years ; }
function countAnomalies ( arr , n , k ) { var cnt = 0 ; var i , sum = 0 ; for ( i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; for ( i = 0 ; i < n ; i ++ ) if ( Math . abs ( arr [ i ] - ( sum - arr [ i ] ) ) > k ) cnt ++ ; return cnt ; }
function minOperation ( arr ) { let ans = 0 ; for ( let i = N - 1 ; i >= 0 ; i -- ) { for ( let j = M - 1 ; j >= 0 ; j -- ) { if ( arr [ i ] [ j ] == false ) { ans ++ ; for ( let k = 0 ; k <= i ; k ++ ) { for ( let h = 0 ; h <= j ; h ++ ) { if ( arr [ k ] [ h ] == true ) { arr [ k ] [ h ] = false ; } else { arr [ k ] [ h ] = true ; } } } } } } return ans ; }
function printTriplets ( arr , n , sum ) { for ( let i = 0 ; i < n - 2 ; i ++ ) { for ( let j = i + 1 ; j < n - 1 ; j ++ ) { for ( let k = j + 1 ; k < n ; k ++ ) if ( arr [ i ] + arr [ j ] + arr [ k ] < sum ) document . write ( arr [ i ] + " " + arr [ j ] + " " + arr [ k ] + " " ) ; } } }
function findLongestRepeatingSubSeq ( str ) { var n = str . length ; var dp = new Array ( n + 1 ) ; for ( var i = 0 ; i <= n ; i ++ ) { dp [ i ] = new Array ( n + 1 ) ; for ( var j = 0 ; j <= n ; j ++ ) { dp [ i ] [ j ] = 0 ; } } for ( var i = 1 ; i <= n ; i ++ ) { for ( var j = 1 ; j <= n ; j ++ ) { if ( ( str [ i - 1 ] == str [ j - 1 ] ) && ( i != j ) ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = Math . max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ; } } return dp [ n ] [ n ] ; }
function find ( n ) { let b = n ; let a = b * ( n - 1 ) ; if ( a * b > n && a / b < n ) { document . write ( " " + a + " " + b ) ; } else document . write ( - 1 ) ; }
function findWaysToPair ( p ) { var dp = Array ( p + 1 ) ; dp [ 1 ] = 1 ; dp [ 2 ] = 2 ; for ( var i = 3 ; i <= p ; i ++ ) { dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; } return dp [ p ] ; }
function printCombination ( n ) { document . write ( 1 + " " ) ; if ( ( n - 2 ) % 3 == 0 ) document . write ( 2 + " " + ( n - 3 ) ) ; else document . write ( 1 + " " + ( n - 2 ) ) ; }
function countSteps ( x , y ) { if ( x < y ) { return x + y + 2 * parseInt ( ( y - x ) / 2 ) ; } else { return x + y + 2 * parseInt ( ( ( x - y ) + 1 ) / 2 ) ; } }
function minMovesToSort ( arr , n ) { var moves = 0 ; var i , mn = arr [ n - 1 ] ; for ( i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] > mn ) moves += arr [ i ] - mn ; mn = arr [ i ] ; } return moves ; }
function MinOperation ( a , n , k ) { let result = 0 ; for ( let i = 0 ; i < n ; ++ i ) { if ( a [ i ] != 1 && a [ i ] > k ) { result = result + Math . min ( a [ i ] % k , k - a [ i ] % k ) ; } else { result = result + k - a [ i ] ; } } return result ; }
function maxProduct ( arr , n ) { if ( n < 4 ) return - 1 ; arr . sort ( function ( a , b ) { return a - b ; } ) ; let x = arr [ n - 1 ] * arr [ n - 2 ] * arr [ n - 3 ] * arr [ n - 4 ] ; let y = arr [ 0 ] * arr [ 1 ] * arr [ 2 ] * arr [ 3 ] ; let z = arr [ 0 ] * arr [ 1 ] * arr [ n - 1 ] * arr [ n - 2 ] ; return Math . max ( x , Math . max ( y , z ) ) ; }
function minMaxProduct ( arr1 , arr2 , n1 , n2 ) { arr1 . sort ( ( a , b ) => a - b ) ; arr2 . sort ( ( a , b ) => a - b ) ; return ( arr1 [ n1 - 1 ] * arr2 [ 0 ] ) ; }
function printThreeParts ( N ) { if ( N % 3 == 0 ) document . write ( " " + ( N - 2 ) ) ; else document . write ( " " + ( N - 3 ) ) ; }
function getTotalXorOfSubarrayXors ( arr , N ) { if ( N % 2 == 0 ) return 0 ; let res = 0 ; for ( let i = 0 ; i < N ; i += 2 ) { res ^= arr [ i ] ; } return res ; }
function calculateSum ( n ) { let fibo = [ ] ; if ( n <= 0 ) return 0 ; fibo [ 0 ] = 0 ; fibo [ 1 ] = 1 ; let sum = fibo [ 0 ] + fibo [ 1 ] ; for ( let i = 2 ; i <= n ; i ++ ) { fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ; sum += fibo [ i ] ; } return sum ; } let n = 4 ; document . write ( ` ${ calculateSum ( n ) }
function maxSum ( n ) { if ( n == 1 ) return 1 ; else return ( parseInt ( n * ( n - 1 ) / 2 , 10 ) - 1 + parseInt ( n / 2 , 10 ) ) ; }
function isWoodall ( x ) { if ( x % 2 == 0 ) return false ; if ( x == 1 ) return true ; x ++ ; let p = 0 ; while ( x % 2 == 0 ) { x = x / 2 ; p ++ ; if ( p == x ) return true ; } return false ; }
function printLines ( n , k ) { for ( i = 0 ; i < n ; i ++ ) { document . write ( k * ( 6 * i + 1 ) + " " + k * ( 6 * i + 2 ) + " " + k * ( 6 * i + 3 ) + " " + k * ( 6 * i + 5 ) + " " ) ; } }
function snoob ( x ) { let rightOne , nextHigherOneBit , rightOnesPattern , next = 0 ; if ( x > 0 ) { rightOne = x & - x ; nextHigherOneBit = x + rightOne ; rightOnesPattern = x ^ nextHigherOneBit ; rightOnesPattern = ( rightOnesPattern ) / rightOne ; rightOnesPattern >>= 2 ; next = nextHigherOneBit | rightOnesPattern ; } return next ; }
function isPower ( x , y ) { var res1 = parseInt ( Math . log ( y ) ) / parseInt ( Math . log ( x ) ) ; var res2 = Math . log ( y ) / Math . log ( x ) ; return ( res1 == res2 ) ; }
function shortdis ( r , d ) { document . write ( " " + " " + Math . sqrt ( ( r * r ) - ( ( d * d ) / 4 ) ) + " " ) ; }
function countSetBits ( n ) { if ( n == 0 ) return 0 ; else return 1 + countSetBits ( n & ( n - 1 ) ) ; }
function remAnagram ( str1 , str2 ) { var count1 = Array . from ( { length : 26 } , ( _ , i ) => 0 ) ; var count2 = Array . from ( { length : 26 } , ( _ , i ) => 0 ) ; for ( i = 0 ; i < str1 . length ; i ++ ) count1 [ str1 . charAt ( i ) . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; for ( i = 0 ; i < str2 . length ; i ++ ) count2 [ str2 . charAt ( i ) . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; var result = 0 ; for ( i = 0 ; i < 26 ; i ++ ) result += Math . abs ( count1 [ i ] - count2 [ i ] ) ; return result ; }
function squarearea ( r ) { if ( r < 0 ) return - 1 ; var a = 4 * ( Math . pow ( r , 2 ) / 5 ) ; return a ; }
function maxSubArraySum ( a , size ) { var maxint = Math . pow ( 2 , 53 ) var max_so_far = - maxint - 1 var max_ending_here = 0 for ( var i = 0 ; i < size ; i ++ ) { max_ending_here = max_ending_here + a [ i ] if ( max_so_far < max_ending_here ) max_so_far = max_ending_here if ( max_ending_here < 0 ) max_ending_here = 0 } return max_so_far }
function findLargestDivisor ( n ) { for ( let i = 2 ; i < Math . sqrt ( n ) + 1 ; i ++ ) { while ( n % ( i * i ) == 0 ) { n = n / i ; } } return n ; }
function countIntegralSolutions ( n ) { return Math . floor ( ( ( n + 1 ) * ( n + 2 ) ) / 2 ) ; }
function count ( n ) { let dp = [ ] ; dp [ 0 ] = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { if ( i >= 1 && i <= 3 ) dp [ i ] = 1 ; else if ( i == 4 ) dp [ i ] = 2 ; else { dp [ i ] = dp [ i - 1 ] + dp [ i - 4 ] ; } } return dp [ n ] ; }
function maxDP ( n ) { let res = [ ] ; res [ 0 ] = 0 ; res [ 1 ] = 1 ; for ( let i = 2 ; i <= n ; i ++ ) { res [ i ] = Math . max ( i , ( res [ Math . floor ( i / 2 ) ] + res [ Math . floor ( i / 3 ) ] + res [ Math . floor ( i / 4 ) ] + res [ Math . floor ( i / 5 ) ] ) ) ; } return res [ n ] ; }
function calculateSum ( n ) { return ( n * ( parseInt ( Math . pow ( n , 2 ) + 3 * n + 5 ) ) / 3 ) ; }
function Series ( n ) { let i ; let sums = 0 ; for ( i = 1 ; i <= n ; i ++ ) sums += ( i * i ) ; return sums ; }
function setallbitgivenrange ( n , l , r ) { let range = ( ( ( 1 << ( l - 1 ) ) - 1 ) ^ ( ( 1 << ( r ) ) - 1 ) ) ; return ( n range ) ; }
function isPanalphabeticWindow ( s , n ) { var ch = ' ' ; for ( var i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ch ) ch = String . fromCharCode ( ch . charCodeAt ( 0 ) + 1 ) ; if ( ch == String . fromCharCode ( ' ' . charCodeAt ( 0 ) + 1 ) ) return true ; } return false ; }
function computeXOR ( n ) { switch ( n & 3 ) { case 0 : return n ; case 1 : return 1 ; case 2 : return n + 1 ; case 3 : return 0 ; } }
function ceilSearch ( arr , low , high , x ) { let mid ; if ( x <= arr [ low ] ) return low ; if ( x > arr [ high ] ) return - 1 ; mid = ( low + high ) / 2 ; if ( arr [ mid ] == x ) return mid ; else if ( arr [ mid ] < x ) { if ( mid + 1 <= high && x <= arr [ mid + 1 ] ) return mid + 1 ; else return ceilSearch ( arr , mid + 1 , high , x ) ; } else { if ( mid - 1 >= low && x > arr [ mid - 1 ] ) return mid ; else return ceilSearch ( arr , low , mid - 1 , x ) ; } } let arr = [ 1 , 2 , 8 , 10 , 10 , 12 , 19 ] ; let n = arr . length ; let x = 20 ; let index = ceilSearch ( arr , 0 , n - 1 , x ) ; if ( index == - 1 ) { document . write ( ` ${ x } ` ) ; } else { document . write ( ` ${ x } ${ arr [ index ] } ` ) ; }
function maxTripletSum ( arr , n ) { let sum = - 1000000 ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = i + 1 ; j < n ; j ++ ) for ( let k = j + 1 ; k < n ; k ++ ) if ( sum < arr [ i ] + arr [ j ] + arr [ k ] ) sum = arr [ i ] + arr [ j ] + arr [ k ] ; return sum ; }
function solve ( M , N , s ) { let ans = Math . floor ( ( ( Math . ceil ( M / s ) ) * ( Math . ceil ( N / s ) ) ) ) ; return ans ; }
function gcd ( a , b ) { if ( a == 0 && b == 0 ) return 0 ; if ( a == 0 ) return b ; if ( b == 0 ) return a ; if ( a == b ) return a ; if ( a > b ) return gcd ( a - b , b ) ; return gcd ( a , b - a ) ; }
function polygonArea ( X , Y , n ) { let area = 0.0 ; let j = n - 1 ; for ( let i = 0 ; i < n ; i ++ ) { area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) ; j = i ; } return Math . abs ( area / 2.0 ) ; }
function findNature ( a , b , n ) { var seq = Array ( MAX ) . fill ( 0 ) ; seq [ 0 ] = a ; seq [ 1 ] = b ; for ( var i = 2 ; i <= n ; i ++ ) seq [ i ] = seq [ i - 1 ] + seq [ i - 2 ] ; return ( seq [ n ] & 1 ) ; }
function asciiToSentence ( str , len ) { var num = 0 ; for ( var i = 0 ; i < len ; i ++ ) { num = num * 10 + ( str [ i ] - ' ' ) ; if ( num >= 32 && num <= 122 ) { var ch = String . fromCharCode ( num ) ; document . write ( ch ) ; num = 0 ; } } }
function countMultiples ( n ) { return Math . floor ( n / 3 + n / 7 - n / 21 ) ; }
function findMinRec ( A , n ) { if ( n == 1 ) return A [ 0 ] ; return Math . min ( A [ n - 1 ] , findMinRec ( A , n - 1 ) ) ; }
function isSumEqual ( ar , n ) { let sum = 0 ; for ( let i = 0 ; i < n - 1 ; i ++ ) sum += ar [ i ] ; if ( sum == ar [ n - 1 ] ) return true ; return false ; }
function maxFreq ( s , a , b ) { var fre = new Array ( 10 ) . fill ( 0 ) ; var n = s . length ; if ( a > b ) { var temp = a ; a = b ; b = temp ; } for ( var i = 0 ; i < n ; i ++ ) fre [ s [ i ] . charCodeAt ( 0 ) - " " . charCodeAt ( 0 ) ] ++ ; if ( fre [ a ] === 0 && fre [ b ] === 0 ) return - 1 ; else if ( fre [ a ] >= fre [ b ] ) return a ; else return b ; }
function extrema ( a , n ) { let count = 0 ; for ( let i = 1 ; i < n - 1 ; i ++ ) { if ( a [ i ] > a [ i - 1 ] && a [ i ] > a [ i + 1 ] ) count += 1 ; if ( a [ i ] < a [ i - 1 ] && a [ i ] < a [ i + 1 ] ) count += 1 ; } return count ; }
function digit_product_Sum ( N ) { var a = [ ... Array ( N ) ] ; var product = 1 ; a [ 0 ] = 1 ; for ( var i = 1 ; i <= N ; i ++ ) { product = parseInt ( a [ i - 1 ] / 10 ) ; if ( product == 0 ) product = 1 ; else product = a [ i - 1 ] % 10 ; var val = parseInt ( a [ i - 1 ] / 10 ) ; if ( val == 0 ) val = a [ i - 1 ] ; a [ i ] = a [ i - 1 ] + val * product ; } for ( var i = 0 ; i < N ; i ++ ) document . write ( a [ i ] + " " ) ; }
function colMaxDiff ( mat ) { let max_diff = Number . MIN_VALUE ; for ( let i = 0 ; i < N ; i ++ ) { let max_val = mat [ 0 ] [ i ] , min_val = mat [ 0 ] [ i ] ; for ( let j = 1 ; j < N ; j ++ ) { max_val = Math . max ( max_val , mat [ j ] [ i ] ) ; min_val = Math . min ( min_val , mat [ j ] [ i ] ) ; } max_diff = Math . max ( max_diff , max_val - min_val ) ; } return max_diff ; }
function percent ( a , b ) { var result = 0 ; result = ( ( b - a ) * 100 ) / a ; return result ; }
function factorial ( n ) { return ( n == 1 n == 0 ) ? 1 : n * factorial ( n - 1 ) ; }
function vol_of_dodecahedron ( side ) { return ( ( ( 15 + ( 7 * ( Math . sqrt ( 5 ) ) ) ) / 4 ) * ( Math . pow ( side , 3 ) ) ) ; }
function minCoins ( coins , m , V ) { if ( V == 0 ) return 0 ; let res = Number . MAX_VALUE ; for ( let i = 0 ; i < m ; i ++ ) { if ( coins [ i ] <= V ) { let sub_res = minCoins ( coins , m , V - coins [ i ] ) ; if ( sub_res != Number . MAX_VALUE && sub_res + 1 < res ) res = sub_res + 1 ; } } return res ; }
function checkSolution ( a , b , c ) { if ( ( ( b * b ) - ( 4 * a * c ) ) > 0 ) document . write ( " " ) ; else if ( ( ( b * b ) - ( 4 * a * c ) ) == 0 ) document . write ( " " ) ; else document . write ( " " ) ; }
function modInverse ( a , m ) { for ( let x = 1 ; x < m ; x ++ ) if ( ( ( a % m ) * ( x % m ) ) % m == 1 ) return x ; }
function getCount ( arr , n , num1 , num2 ) { let i = 0 ; for ( i = 0 ; i < n ; i ++ ) if ( arr [ i ] == num1 ) break ; if ( i >= n - 1 ) return 0 ; let j ; for ( j = n - 1 ; j >= i + 1 ; j -- ) if ( arr [ j ] == num2 ) break ; if ( j == i ) return 0 ; return ( j - i - 1 ) ; }
function countTriplets ( arr , n , a , b ) { var ans = 0 ; for ( var i = 0 ; i < n - 2 ; i ++ ) { for ( var j = i + 1 ; j < n - 1 ; j ++ ) { for ( var k = j + 1 ; k < n ; k ++ ) if ( arr [ i ] + arr [ j ] + arr [ k ] >= a && arr [ i ] + arr [ j ] + arr [ k ] <= b ) ans ++ ; } } return ans ; }
function findEvenPair ( A , N ) { let count = 0 ; for ( let i = 0 ; i < N ; i ++ ) if ( ( ! ( ( A [ i ] & 1 ) > 0 ) ) ) count ++ ; return count * ( count - 1 ) / 2 ; }
function countWords ( str ) { var state = OUT ; var wc = 0 ; var i = 0 ; while ( i < str . length ) { if ( str [ i ] == ' ' str [ i ] == ' ' str [ i ] == ' ' ) state = OUT ; else if ( state == OUT ) { state = IN ; ++ wc ; } ++ i ; } return wc ; }
function findNthEvenDigitNumber ( n ) { let count = 0 ; for ( let i = 0 ; ; i ++ ) { let curr = i ; let isCurrEvenDigit = true ; while ( curr != 0 ) { if ( curr % 10 == 1 curr % 10 == 3 curr % 10 == 5 curr % 10 == 7 curr % 10 == 9 ) isCurrEvenDigit = false ; curr = Math . floor ( curr / 10 ) ; } if ( isCurrEvenDigit === true ) count ++ ; if ( count === n ) return i ; } }
function minimumMoves ( a , n ) { let operations = 0 ; a . sort ( ) ; for ( let i = 0 ; i < n ; i ++ ) operations += Math . abs ( a [ i ] - ( i + 1 ) ) ; return operations ; }
function center_nonadecagon_num ( n ) { return ( 19 * n * n - 19 * n + 2 ) / 2 ; }
function getTime ( u , v , x ) { let speed = u + v ; let time = x / speed ; return time ; }
function kthOdd ( arr , n , k ) { for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 1 ) k -- ; if ( k == 0 ) return arr [ i ] ; } return - 1 ; }
function nthSquareCube ( n ) { return n * n * n * n * n * n ; }
function countDigits ( n ) { return ( n * Math . log10 ( 2 ) + 1 ) ; }
function add ( A , B , C ) { let i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < N ; j ++ ) C [ i ] [ j ] = A [ i ] [ j ] + B [ i ] [ j ] ; } let A = [ [ 1 , 1 , 1 , 1 ] , [ 2 , 2 , 2 , 2 ] , [ 3 , 3 , 3 , 3 ] , [ 4 , 4 , 4 , 4 ] ] ; let B = [ [ 1 , 1 , 1 , 1 ] , [ 2 , 2 , 2 , 2 ] , [ 3 , 3 , 3 , 3 ] , [ 4 , 4 , 4 , 4 ] ] ; let C = new Array ( N ) ; for ( let k = 0 ; k < N ; k ++ ) C [ k ] = new Array ( N ) ; let i , j ; add ( A , B , C ) ; document . write ( " " ) ; for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < N ; j ++ ) document . write ( C [ i ] [ j ] + " " ) ; document . write ( " " ) ; }
function countNegative ( M , n , m ) { let count = 0 ; let i = 0 ; let j = m - 1 ; while ( j >= 0 && i < n ) { if ( M [ i ] [ j ] < 0 ) { count += j + 1 ; i += 1 ; } else j -= 1 ; } return count ; }
function isLucky ( n ) { let counter = 2 ; let next_position = n ; if ( counter > n ) return 1 ; if ( n % counter == 0 ) return 0 ; next_position -= Math . floor ( next_position / counter ) ; counter ++ ; return isLucky ( next_position ) ; }
function findElements ( arr , n ) { for ( let i = 0 ; i < n ; i ++ ) { let count = 0 ; for ( let j = 0 ; j < n ; j ++ ) if ( arr [ j ] > arr [ i ] ) count ++ ; if ( count >= 2 ) document . write ( arr [ i ] + " " ) ; } }
function nthTerm ( n ) { return Math . pow ( n , 2 ) + 4 * n ; }
function minInsertionStepToSortArray ( arr , N ) { let lis = new Array ( N ) ; for ( let i = 0 ; i < N ; i ++ ) { lis [ i ] = 1 ; } for ( let i = 1 ; i < N ; i ++ ) { for ( let j = 0 ; j < i ; j ++ ) { if ( arr [ i ] >= arr [ j ] && lis [ i ] < lis [ j ] + 1 ) { lis [ i ] = lis [ j ] + 1 ; } } } let max = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( max < lis [ i ] ) { max = lis [ i ] ; } } return ( N - max ) ; }
function countPaths ( n , m ) { if ( n == 0 m == 0 ) return 1 ; return ( countPaths ( n - 1 , m ) + countPaths ( n , m - 1 ) ) ; }
function nthTerm ( n ) { return 4 * Math . pow ( n , 2 ) - 3 * n + 2 ; }
function sumofseries ( n ) { return ( n * ( n + 1 ) * ( n + 2 ) * ( n + 3 ) / 4 ) ; }
function isEvenOrOdd ( L , R ) { let oddCount = Math . floor ( ( R - L ) / 2 ) ; if ( R % 2 == 1 L % 2 == 1 ) oddCount ++ ; if ( oddCount % 2 == 0 ) return " " ; else return " " ; }
function nthTerm ( N ) { return ( 2 * N + 3 ) * ( 2 * N + 3 ) - 2 * N ; }
function CountCharacters ( str , l , r ) { let cnt = 0 ; let len = str . length ; for ( let i = 0 ; i < len ; i ++ ) { if ( l <= str [ i ] . charCodeAt ( 0 ) && str [ i ] . charCodeAt ( 0 ) <= r ) { cnt ++ ; document . write ( str [ i ] + " " ) ; } } return cnt ; }
function digSum ( n ) { if ( n == 0 ) return 0 ; return ( n % 9 == 0 ) ? 9 : ( n % 9 ) ; }
function lengtang ( r1 , r2 , d ) { document . write ( " " + Math . sqrt ( Math . pow ( d , 2 ) - Math . pow ( ( r1 - r2 ) , 2 ) ) ) ; }
function printOrder ( arr , k ) { let n = arr . length ; arr = arr . slice ( 0 , k ) . sort ( function ( a , b ) { return a - b ; } ) . concat ( arr . slice ( k , n ) . sort ( function ( a , b ) { return b - a ; } ) ) ; return arr ; }
function numberOfElements ( height , n ) { var max_so_far = 0 ; var coun = 0 ; for ( let i = n - 1 ; i >= 0 ; i -- ) { if ( height [ i ] > max_so_far ) { max_so_far = height [ i ] ; coun ++ ; } } return coun ; }
function findCountOfPairs ( a , b , n ) { let ans = 0 ; ans += n * parseInt ( a / n , 10 ) * parseInt ( b / n , 10 ) ans += parseInt ( a / n , 10 ) * parseInt ( b % n , 10 ) ; ans += parseInt ( a % n , 10 ) * parseInt ( b / n , 10 ) ; ans += parseInt ( ( ( a % n ) + ( b % n ) ) / n , 10 ) ; return ans ; }
function wastedWater ( V , M , N ) { let wasted_amt , amt_per_min , time_to_fill ; amt_per_min = M - N ; time_to_fill = V / amt_per_min ; wasted_amt = N * time_to_fill ; return wasted_amt ; }
function uniqueCharacters ( str ) { for ( let i = 0 ; i < str . length ; i ++ ) for ( let j = i + 1 ; j < str . length ; j ++ ) if ( str [ i ] == str [ j ] ) return false ; return true ; }
function ReuleauxArea ( r ) { if ( r < 0 ) return - 1 ; var A = 0.70477 * 2 * Math . pow ( r , 2 ) ; return A ; }
function isProduct ( arr , n , x ) { for ( var i = 0 ; i < n - 1 ; i ++ ) for ( var j = i + 1 ; i < n ; i ++ ) if ( arr [ i ] * arr [ j ] == x ) return true ; return false ; }
function survival ( S , N , M ) { if ( ( ( N * 6 ) < ( M * 7 ) && S > 6 ) M > N ) document . write ( " " ) ; else { let days = ( M * S ) / N ; if ( ( ( M * S ) % N ) != 0 ) days ++ ; document . write ( " " + Math . round ( days ) ) ; } }
function occurredOnce ( arr , n ) { arr . sort ( function ( a , b ) { return a - b ; } ) ; if ( arr [ 0 ] != arr [ 1 ] ) document . write ( arr [ 0 ] + " " ) ; for ( let i = 1 ; i < n - 1 ; i ++ ) if ( arr [ i ] != arr [ i + 1 ] && arr [ i ] != arr [ i - 1 ] ) document . write ( arr [ i ] + " " ) ; if ( arr [ n - 2 ] != arr [ n - 1 ] ) document . write ( arr [ n - 1 ] + " " ) ; }
function area_of_segment ( radius , angle ) { let area_of_sector = pi * ( radius * radius ) * ( angle / 360 ) ; let area_of_triangle = 1 / 2 * ( radius * radius ) * Math . sin ( ( angle * pi ) / 180 ) ; return area_of_sector - area_of_triangle ; }
function printOriginalMatrix ( a , b , mat ) { for ( let i = 0 ; i < N ; i ++ ) { for ( let j = 0 ; j < M ; j ++ ) { if ( mat [ i ] [ j ] == 1 ) document . write ( Math . min ( a [ i ] , b [ j ] ) + " " ) ; else document . write ( " " + " " ) ; } document . write ( " " ) ; } }
function possibleOrNot ( a1 , a2 , b1 , b2 , c1 , c2 ) { var dis1 = Math . pow ( b1 - a1 , 2 ) + Math . pow ( b2 - a2 , 2 ) ; var dis2 = Math . pow ( c1 - b1 , 2 ) + Math . pow ( c2 - b2 , 2 ) ; if ( dis1 != dis2 ) document . write ( " " ) ; else if ( b1 == ( ( a1 + c1 ) / 2.0 ) && b2 == ( ( a2 + c2 ) / 2.0 ) ) document . write ( " " ) ; else document . write ( " " ) ; }
function maximumSegments ( n , a , b , c ) { let dp = [ ] ; for ( let i = 0 ; i < n + 10 ; i ++ ) dp [ i ] = - 1 ; dp [ 0 ] = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( dp [ i ] != - 1 ) { dp [ i + a ] = Math . max ( dp [ i ] + 1 , dp [ i + a ] ) ; dp [ i + b ] = Math . max ( dp [ i ] + 1 , dp [ i + b ] ) ; dp [ i + c ] = Math . max ( dp [ i ] + 1 , dp [ i + c ] ) ; } } return dp [ n ] ; }
function countPairs ( arr1 , arr2 , m , n , x ) { let count = 0 ; for ( let i = 0 ; i < m ; i ++ ) for ( let j = 0 ; j < n ; j ++ ) if ( ( arr1 [ i ] + arr2 [ j ] ) == x ) count ++ ; return count ; }
function nthKyneaNumber ( n ) { n = ( 1 << n ) + 1 ; n = n * n ; n = n - 2 ; return n ; }
function findNum ( div , rem , N ) { var num = rem [ N - 1 ] ; for ( var i = N - 2 ; i >= 0 ; i -- ) { num = num * div [ i ] + rem [ i ] ; } return num ; }
function MaxTraceSub ( mat ) { var max_trace = 0 ; for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < N ; j ++ ) { var r = i , s = j , trace = 0 ; while ( r < N && s < N ) { trace += mat [ r ] [ s ] ; r ++ ; s ++ ; max_trace = Math . max ( trace , max_trace ) ; } } } return max_trace ; }
function findMissing ( arr1 , arr2 , M , N ) { if ( M != N - 1 && N != M - 1 ) { document . write ( " " ) ; return ; } let res = 0 ; for ( let i = 0 ; i < M ; i ++ ) res = res ^ arr1 [ i ] ; for ( let i = 0 ; i < N ; i ++ ) res = res ^ arr2 [ i ] ; document . write ( " " + res ) ; }
function findPair ( arr , size , n ) { let i = 0 ; let j = 1 ; while ( i < size && j < size ) { if ( i != j && arr [ j ] - arr [ i ] == n ) { document . write ( " " + arr [ i ] + " " + arr [ j ] + " " ) ; return true ; } else if ( arr [ j ] - arr [ i ] < n ) j ++ ; else i ++ ; } document . write ( " " ) ; return false ; }
function moduloMultiplication ( a , b , mod ) { let res = 0 ; a = ( a % mod ) ; while ( b > 0 ) { if ( ( b & 1 ) > 0 ) { res = ( res + a ) % mod ; } a = ( 2 * a ) % mod ; } return res ; }
function check ( str ) { let n = str . length ; let digitSum = 0 ; for ( let i = 0 ; i < n ; i ++ ) digitSum += ( str [ i ] - ' ' ) ; return ( digitSum % 9 == 0 ) ; }
function calculateSide ( n , r ) { var theta , theta_in_radians ; theta = 360 / n ; theta_in_radians = theta * 3.14 / 180 ; return 2 * r * Math . sin ( theta_in_radians / 2 ) ; }
function isTriangular ( num ) { if ( num < 0 ) return false ; let sum = 0 ; for ( let n = 1 ; sum <= num ; n ++ ) { sum = sum + n ; if ( sum == num ) return true ; } return false ; }
function turnOnK ( n , k ) { if ( k <= 0 ) return n ; return ( n | ( 1 << ( k - 1 ) ) ) ; }
function solve ( N , M , cp , sp ) { let profit = new Array ( N ) ; for ( let i = 0 ; i < N ; i ++ ) profit [ i ] = sp [ i ] - cp [ i ] ; profit . sort ( function ( a , b ) { return b - a ; } ) ; let sum = 0 ; for ( let i = 0 ; i < M ; i ++ ) { if ( profit [ i ] > 0 ) sum += profit [ i ] ; else break ; } return sum ; }
function findArea ( arr , n ) { arr . sort ( ( a , b ) => { return b - a ; } ) var dimension = [ 0 , 0 ] ; for ( var i = 0 , j = 0 ; i < n - 1 && j < 2 ; i ++ ) if ( arr [ i ] == arr [ i + 1 ] ) dimension [ j ++ ] = arr [ i ++ ] ; return ( dimension [ 0 ] * dimension [ 1 ] ) ; }
function findSum ( N ) { return ( N * ( N + 1 ) * ( 2 * N - 5 ) + 4 * N ) / 2 ; }
function findMaxCock ( ar ) { if ( R < 3 C < 3 ) return - 1 ; var max_sum = - 1000000000 ; for ( var i = 0 ; i < R - 2 ; i ++ ) { for ( var j = 0 ; j < C - 2 ; j ++ ) { var sum = ( ar [ i ] [ j ] + ar [ i ] [ j + 2 ] ) + ( ar [ i + 1 ] [ j + 1 ] ) + ( ar [ i + 2 ] [ j ] + ar [ i + 2 ] [ j + 1 ] + ar [ i + 2 ] [ j + 2 ] ) ; max_sum = Math . max ( max_sum , sum ) ; } } return max_sum ; }
function maxSumBitonicSubArr ( arr , n ) { let msis = new Array ( n ) ; msis . fill ( 0 ) ; let msds = new Array ( n ) ; msds . fill ( 0 ) ; let max_sum = Number . MIN_VALUE ; msis [ 0 ] = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) if ( arr [ i ] > arr [ i - 1 ] ) msis [ i ] = msis [ i - 1 ] + arr [ i ] ; else msis [ i ] = arr [ i ] ; msds [ n - 1 ] = arr [ n - 1 ] ; for ( let i = n - 2 ; i >= 0 ; i -- ) if ( arr [ i ] > arr [ i + 1 ] ) msds [ i ] = msds [ i + 1 ] + arr [ i ] ; else msds [ i ] = arr [ i ] ; for ( let i = 0 ; i < n ; i ++ ) if ( max_sum < ( msis [ i ] + msds [ i ] - arr [ i ] ) ) max_sum = msis [ i ] + msds [ i ] - arr [ i ] ; return max_sum ; }
function hammingDist ( str1 , str2 ) { let i = 0 , count = 0 ; while ( i < str1 . length ) { if ( str1 [ i ] != str2 [ i ] ) count ++ ; i ++ ; } return count ; }
function findAngle ( n ) { let interiorAngle , exteriorAngle ; interiorAngle = Math . floor ( ( n - 2 ) * 180 / n ) ; exteriorAngle = Math . floor ( 360 / n ) ; document . write ( " " + interiorAngle + " " ) ; document . write ( " " + exteriorAngle ) ; }
function numberOfWays ( x ) { let dp = Array ( x + 1 ) . fill ( 0 ) ; dp [ 0 ] = dp [ 1 ] = 1 ; for ( i = 2 ; i <= x ; i ++ ) dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; return dp [ x ] ; }
function findevenPair ( A , N ) { let count = 0 ; for ( let i = 0 ; i < N ; i ++ ) if ( A [ i ] % 2 != 0 ) count ++ ; let oddCount = parseInt ( ( count * ( count - 1 ) ) / 2 ) ; return parseInt ( ( N * ( N - 1 ) ) / 2 ) - oddCount ; }
function maxPartitions ( arr , n ) { let ans = 0 , max_so_far = 0 ; for ( let i = 0 ; i < n ; ++ i ) { max_so_far = Math . max ( max_so_far , arr [ i ] ) ; if ( max_so_far == i ) ans ++ ; } return ans ; }
function reverse ( str , len ) { if ( len == str . length ) { return ; } reverse ( str , len + 1 ) ; document . write ( str [ len ] ) ; }
function squaresum ( n ) { return ( n * ( n + 1 ) / 2 ) * ( 2 * n + 1 ) / 3 ; }
function binarySearch ( arr , x ) { let l = 0 , r = arr . length - 1 ; while ( l <= r ) { let m = l + Math . floor ( ( r - l ) / 2 ) ; let res = x . localeCompare ( arr [ m ] ) ; if ( res == 0 ) return m ; if ( res > 0 ) l = m + 1 ; else r = m - 1 ; } return - 1 ; }
function findLargestd ( S , n ) { let found = false ; S . sort ( ) ; for ( let i = n - 1 ; i >= 0 ; i -- ) { for ( let j = 0 ; j < n ; j ++ ) { if ( i == j ) continue ; for ( let k = j + 1 ; k < n ; k ++ ) { if ( i == k ) continue ; for ( let l = k + 1 ; l < n ; l ++ ) { if ( i == l ) continue ; if ( S [ i ] == S [ j ] + S [ k ] + S [ l ] ) { found = true ; return S [ i ] ; } } } } } if ( found == false ) return Number . MAX_VALUE ; return - 1 ; }
function cyl ( a ) { if ( a < 0 ) return - 1 ; var r = ( 2 * a * ( Math . sqrt ( 2 ) ) / 3 ) ; var h = ( 2 * a ) / 3 ; var V = ( 3.14 * ( Math . pow ( r , 2 ) * h ) ) ; return V ; }
function maxSum ( arr , n ) { arr . sort ( ) ; let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum += ( arr [ i ] * i ) ; return sum ; }
function printDivisors ( n ) { let v = [ ] ; let t = 0 ; for ( let i = 1 ; i <= parseInt ( Math . sqrt ( n ) ) ; i ++ ) { if ( n % i == 0 ) { if ( parseInt ( n / i ) == i ) document . write ( i + " " ) ; else { document . write ( i + " " ) ; v [ t ++ ] = parseInt ( n / i ) ; } } } for ( let i = v . length - 1 ; i >= 0 ; i -- ) { document . write ( v [ i ] + " " ) ; } }
function maxIndexDiff ( arr , n ) { let maxDiff = - 1 ; let i , j ; for ( i = 0 ; i < n ; ++ i ) { for ( j = n - 1 ; j > i ; -- j ) { if ( arr [ j ] > arr [ i ] && maxDiff < ( j - i ) ) maxDiff = j - i ; } } return maxDiff ; }
function harmonicMean ( arr , freq , n ) { let sum = 0 , frequency_sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { sum = sum + ( freq [ i ] / arr [ i ] ) ; frequency_sum = frequency_sum + freq [ i ] ; } return frequency_sum / sum ; }
function checkValidity ( a , b , c ) { if ( a + b <= c a + c <= b b + c <= a ) return false ; else return true ; }
function rhombusAreaPeri ( d1 , d2 ) { let area , perimeter ; area = Math . floor ( ( d1 * d2 ) / 2 ) ; perimeter = Math . floor ( 2 * Math . sqrt ( Math . pow ( d1 , 2 ) + Math . pow ( d2 , 2 ) ) ) ; document . write ( " " + d1 + " " + d2 + " " + area + " " + " " ) ; document . write ( " " + d1 + " " + d2 + " " + perimeter + " " + " " ) ; }
function overflow ( H , r , h , N , R ) { let tank_cap = 3.14 * r * r * H ; let water_vol = 3.14 * r * r * h ; let balls_vol = N * ( 4 / 3 ) * 3.14 * R * R * R ; let vol = water_vol + balls_vol ; if ( vol > tank_cap ) { document . write ( " " ) ; } else { document . write ( " " ) ; } }
function findS ( s ) { let sum = 0 ; for ( let n = 1 ; sum < s ; n ++ ) { sum += n * n * n ; if ( sum == s ) return n ; } return - 1 ; }
function countNegative ( M , n , m ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < m ; j ++ ) { if ( M [ i ] [ j ] < 0 ) count += 1 ; else break ; } } return count ; }
function printTaxicab2 ( N ) { let i = 1 ; count = 0 ; while ( count < N ) { let int_count = 0 ; for ( let j = 1 ; j <= Math . pow ( i , 1.0 / 3 ) ; j ++ ) for ( let k = j + 1 ; k <= Math . pow ( i , 1.0 / 3 ) ; k ++ ) if ( j * j * j + k * k * k == i ) int_count ++ ; if ( int_count == 2 ) { count ++ ; document . write ( count + " " + i + " " ) ; } i ++ ; } }
function query ( s , i , j ) { let n = s . length ; i %= n ; j %= n ; if ( s [ i ] == s [ j ] ) document . write ( " " + " " ) ; else document . write ( " " + " " ) ; }
function countNumbers ( n ) { return ( n / 2520 ) ; }
function check ( arr , x , n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let y = Math . sqrt ( arr [ i ] ) ; if ( Math . floor ( y ) == Math . ceil ( y ) ) { sum += arr [ i ] ; } } if ( sum % x == 0 ) return true ; else return false ; } let arr = [ 2 , 3 , 4 , 9 , 10 ] ; let n = arr . length ; let x = 13 ; if ( check ( arr , x , n ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function FindIndexKthBit ( n , k ) { let cnt = 0 ; let ind = 0 ; while ( n > 0 ) { if ( n & 1 > 0 ) cnt ++ ; if ( cnt == k ) return ind ; ind ++ ; n = n >> 1 ; } return - 1 ; }
function minDaysToEmpty ( C , l ) { if ( l >= C ) return C ; let eq_root = ( Math . sqrt ( 1 + 8 * ( C - l ) ) - 1 ) / 2 ; return ( Math . ceil ( eq_root ) + l ) ; }
function checkEquilibrium ( x1 , y1 , z1 , x2 , y2 , z2 , x3 , y3 , z3 ) { var resx = x1 + x2 + x3 ; var resy = y1 + y2 + y3 ; var resz = z1 + z2 + z3 ; if ( resx == 0 & resy == 0 & resz == 0 ) return true ; else return false ; }
function SellingPrice ( CP , PP ) { var P_decimal = 1 + ( PP / 100 ) ; var res = P_decimal * CP ; return res . toFixed ( 1 ) ; }
function findPosition ( n , f , b ) { return n - Math . max ( f + 1 , n - b ) + 1 ; }
function findOptimalSolution ( a , N ) { a . sort ( function ( a , b ) { return a - b } ) ; let points = 0 ; for ( let i = 0 ; i < N ; i ++ ) { points += a [ i ] * i ; } return points ; }
function linearSearch ( arr , n ) { let i ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == i ) return i ; } return - 1 ; }
function printTetra ( n ) { let dp = new Array ( n + 5 ) ; dp [ 0 ] = 0 ; dp [ 1 ] = dp [ 2 ] = 1 ; dp [ 3 ] = 2 ; for ( let i = 4 ; i <= n ; i ++ ) dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] + dp [ i - 3 ] + dp [ i - 4 ] ; document . write ( dp [ n ] ) ; }
function firstkdigits ( n , k ) { let product = 1 ; for ( let i = 0 ; i < n ; i ++ ) product *= n ; while ( Math . floor ( product / Math . pow ( 10 , k ) ) != 0 ) product = Math . floor ( product / 10 ) ; return product ; }
function sumOfSeries ( n ) { var sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) sum = sum + i * i ; return sum ; }
function PointInKSquares ( n , a , k ) { a . sort ( ) ; return a [ n - k ] ; }
function phi ( n ) { let result = n ; for ( let p = 2 ; p * p <= n ; ++ p ) { if ( n % p == 0 ) { while ( n % p == 0 ) n /= p ; result *= ( 1.0 - ( 1.0 / p ) ) ; } } if ( n > 1 ) result *= ( 1.0 - ( 1.0 / n ) ) ; return parseInt ( result ) ; } for ( let n = 1 ; n <= 10 ; n ++ ) document . write ( ` ${ n } ${ phi ( n ) }
function findpair ( l , r ) { let ans1 = l ; let ans2 = 2 * l ; document . write ( ans1 + " " + ans2 ) ; }
function nextPerfectSquare ( N ) { let nextN = Math . floor ( Math . sqrt ( N ) ) + 1 ; return nextN * nextN ; }
function totalTriangles ( h , v ) { if ( h == 0 && v == 0 ) return 1 ; if ( h == 0 ) return ( ( v + 1 ) * ( v + 2 ) / 2 ) ; if ( v == 0 ) return ( h + 1 ) ; var total = ( h + 1 ) * ( ( v + 1 ) * ( v + 2 ) / 2 ) ; return total ; }
function areSetBitsIncreasing ( n ) { var prev_count = Number . MAX_VALUE ; while ( n > 0 ) { while ( n > 0 && n % 2 == 0 ) n = parseInt ( n / 2 ) ; var curr_count = 1 ; while ( n > 0 && n % 2 == 1 ) { n = n / 2 ; curr_count ++ ; } if ( curr_count >= prev_count ) return false ; prev_count = curr_count ; } return true ; }
function sumOfTheSeries ( n ) { let sum = 0.0 ; for ( let i = 1 ; i <= n ; i ++ ) sum += 1.0 / ( i * ( i + 1 ) ) ; return sum ; }
function changeEvenBits ( n ) { let to_subtract = 0 ; let m = 0 ; for ( x = n ; x ; x >>= 2 ) { if ( x & 1 ) to_subtract += ( 1 << m ) ; m += 2 ; } return n - to_subtract ; }
function divisibleBy20 ( num ) { let lastTwoDigits = parseInt ( num . slice ( - 2 , num . length ) ) console . log ( num . slice ( - 2 , 1 ) ) return ( ( lastTwoDigits % 5 == 0 ) && ( lastTwoDigits % 4 == 0 ) ) }
function longestsubarray ( arr , n , k ) { let current_count = 0 ; let max_count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % k == 0 ) current_count ++ ; else current_count = 0 ; max_count = Math . max ( current_count , max_count ) ; } return max_count ; }
function squareRootExists ( n , p ) { n = n % p ; for ( let x = 2 ; x < p ; x ++ ) if ( ( x * x ) % p == n ) return true ; return false ; }
function numbers ( n ) { return ( Math . pow ( 2 , n + 1 ) ) - 2 ; }
function nextPerfectCube ( N ) { let nextN = Math . floor ( Math . cbrt ( N ) ) + 1 ; return nextN * nextN * nextN ; }
function isPossible ( a , n ) { let sum = 0 , maxS = 0 ; for ( let i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; maxS = Math . max ( a [ i ] , maxS ) ; } if ( ( sum - maxS ) > maxS ) return true ; return false ; }
function lengthOfTangent ( r1 , r2 , d ) { document . write ( " " + " " + Math . sqrt ( Math . pow ( d , 2 ) - Math . pow ( ( r1 + r2 ) , 2 ) ) ) ; }
function minDistance ( n , k , points ) { for ( let i = 0 ; i < k ; i ++ ) ( point [ i ] ) . sort ( function ( a , b ) { return a - b ; } ) ; for ( let i = 0 ; i < k ; i ++ ) document . write ( point [ i ] [ Math . ceil ( ( n / 2 ) - 1 ) ] + " " ) ; }
function minimumCost ( cost , n ) { let dp = new Array ( n ) ; if ( n == 1 ) return cost [ 0 ] ; dp [ 0 ] = cost [ 0 ] ; dp [ 1 ] = cost [ 1 ] ; for ( let i = 2 ; i < n ; i ++ ) { dp [ i ] = Math . min ( dp [ i - 1 ] , dp [ i - 2 ] ) + cost [ i ] ; } return Math . min ( dp [ n - 2 ] , dp [ n - 1 ] ) ; }
function convert ( m , n ) { if ( m == n ) return 0 ; if ( m > n ) return m - n ; if ( m <= 0 && n > 0 ) return - 1 ; if ( n % 2 == 1 ) return 1 + convert ( m , n + 1 ) ; else return 1 + convert ( m , n / 2 ) ; }
function isAlphabaticOrder ( s ) { let n = s . length ; for ( let i = 1 ; i < n ; i ++ ) { if ( s [ i ] < s [ i - 1 ] ) return false ; } return true ; }
function nonFibonacci ( n ) { let prevPrev = 1 , prev = 2 , curr = 3 ; while ( n > 0 ) { prevPrev = prev ; prev = curr ; curr = prevPrev + prev ; n = n - ( curr - prev - 1 ) ; } n = n + ( curr - prev - 1 ) ; return prev + n ; }
function findNumbers ( n ) { var odd = Math . pow ( 10 , n ) - 1 ; var even = odd - 1 ; document . write ( " " + even + " " ) ; document . write ( " " + odd ) ; }
function minAND ( arr , n ) { let s = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { s = s & arr [ i ] ; } document . write ( ( s ) + " " ) ; }
function Mixture ( X , Y , Z ) { var result = 0.0 , result1 = 0.0 ; result1 = ( ( X - Y ) / X ) ; result = Math . pow ( result1 , Z ) ; result = result * X ; return result ; }
function sumOfAP ( a , d , n ) { let sum = ( n / 2 ) * ( 2 * a + ( n - 1 ) * d ) ; return sum ; }
function validate ( n ) { for ( let i = 0 ; i < 10 ; i ++ ) { let temp = n ; let count = 0 ; while ( temp > 0 ) { if ( temp % 10 == i ) count ++ ; if ( count > i ) return false ; temp /= 10 ; } } return true ; }
function countDigits ( a , b ) { return Math . floor ( ( Math . log ( Math . abs ( a ) ) / Math . log ( 10 ) ) - ( Math . log ( Math . abs ( b ) ) / Math . log ( 10 ) ) ) + 1 ; }
function Area ( a ) { if ( a < 0 ) return - 1 ; let x = 0.464 * a ; let A = 0.70477 * Math . pow ( x , 2 ) ; return A ; }
function vertices ( N , A , B ) { var position = 0 ; var minisum = Number . MAX_VALUE ; var sum = 0 ; for ( var i = 1 ; i <= N ; i ++ ) { if ( i == A i == B ) continue ; else { var x = Math . abs ( i - A ) ; var y = Math . abs ( i - B ) ; sum = x + y ; if ( sum < minisum ) { minisum = sum ; position = i ; } } } return position ; }
function hendecagonal_num ( n ) { return ( 9 * n * n - 7 * n ) / 2 ; }
function maxHamming ( arr , n ) { let brr = new Array ( 2 * n + 1 ) ; for ( let i = 0 ; i < n ; i ++ ) brr [ i ] = arr [ i ] ; for ( let i = 0 ; i < n ; i ++ ) brr [ n + i ] = arr [ i ] ; let maxHam = 0 ; for ( let i = 1 ; i < n ; i ++ ) { let currHam = 0 ; for ( let j = i , k = 0 ; j < ( i + n ) ; j ++ , k ++ ) if ( brr [ j ] != arr [ k ] ) currHam ++ ; if ( currHam == n ) return n ; maxHam = max ( maxHam , currHam ) ; } return maxHam ; }
function hexagonside ( a ) { if ( a < 0 ) return - 1 ; var x = a / 3 ; return x ; }
function power ( x , y ) { var temp ; if ( y == 0 ) return 1 ; temp = power ( x , parseInt ( y / 2 ) ) ; if ( y % 2 == 0 ) return temp * temp ; else { if ( y > 0 ) return x * temp * temp ; else return ( temp * temp ) / x ; } }
function isPowerOfFour ( n ) { let count = 0 ; if ( n && ! ( n & ( n - 1 ) ) ) { while ( n > 1 ) { n >>= 1 ; count += 1 ; } return ( count % 2 == 0 ) ? 1 : 0 ; } return 0 ; }
function findIntersection ( intervals , N ) { let l = intervals [ 0 ] [ 0 ] ; let r = intervals [ 0 ] [ 1 ] ; for ( let i = 1 ; i < N ; i ++ ) { if ( intervals [ i ] [ 0 ] > r intervals [ i ] [ 1 ] < l ) { document . write ( - 1 + " " ) ; return ; } else { l = Math . max ( l , intervals [ i ] [ 0 ] ) ; r = Math . min ( r , intervals [ i ] [ 1 ] ) ; } } document . write ( " " + l + " " + r + " " + " " ) ; }
function sumOfTermsInNthRow ( n ) { let sum = n * ( 2 * Math . pow ( n , 2 ) + 1 ) ; return sum ; }
function findXor ( arr , n ) { let xoR = 0 ; for ( let i = 0 ; i < n ; i ++ ) { xoR = xoR ^ arr [ i ] ; } return xoR * 2 ; }
function minimumSets ( arr , n , key ) { var i , j ; arr . sort ( ( a , b ) => a - b ) for ( i = 0 , j = n - 1 ; i <= j ; ++ i ) if ( arr [ i ] + arr [ j ] <= key ) j -- ; return i ; }
function countMaxSetBits ( left , right ) { while ( ( left | ( left + 1 ) ) <= right ) left |= left + 1 ; return left ; }
function nthKyneaNumber ( n ) { return ( ( 1 << ( 2 * n ) ) + ( 1 << ( n + 1 ) ) - 1 ) ; }
function zigzag ( n , k ) { if ( n == 0 && k == 0 ) return 1 ; if ( k == 0 ) return 0 ; return zigzag ( n , k - 1 ) + zigzag ( n - 1 , n - k ) ; }
function MatrixChainOrder ( p , i , j ) { if ( i == j ) return 0 ; var min = Number . MAX_VALUE ; var k = 0 ; for ( k = i ; k < j ; k ++ ) { var count = MatrixChainOrder ( p , i , k ) + MatrixChainOrder ( p , k + 1 , j ) + p [ i - 1 ] * p [ k ] * p [ j ] ; if ( count < min ) min = count ; } return min ; }
function countDistinct ( arr , n ) { let res = 1 ; for ( let i = 1 ; i < n ; i ++ ) { let j = 0 ; for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] === arr [ j ] ) break ; if ( i === j ) res ++ ; } return res ; }
function findEle ( arr , n ) { var sum = 0 ; for ( var i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; for ( var i = 0 ; i < n ; i ++ ) if ( arr [ i ] == sum - arr [ i ] ) return arr [ i ] ; return - 1 ; }
function area ( a ) { if ( a < 0 ) return - 1 ; var area = Math . pow ( ( a * Math . sqrt ( 3 ) ) / ( Math . sqrt ( 2 ) ) , 2 ) ; return area ; }
function findDigits ( n ) { if ( n < 0 ) return 0 ; if ( n <= 1 ) return 1 ; let digits = 0 ; for ( let i = 2 ; i <= n ; i ++ ) digits += Math . log10 ( i ) ; return Math . floor ( digits ) + 1 ; }
function pattern ( str , len ) { for ( var i = 0 ; i < len ; i ++ ) { var j = len - 1 - i ; for ( var k = 0 ; k < len ; k ++ ) { if ( k == i k == j ) document . write ( str . charAt ( k ) ) ; else document . write ( " " ) ; } document . write ( ' ' ) ; } }
function ispowerof2 ( num ) { if ( ( num & ( num - 1 ) ) == 0 ) return 1 ; return 0 ; }
function numberOfTriangles ( n ) { var ans = 2 * ( Math . pow ( 3 , n ) ) - 1 ; return ans ; }
function countNumbersWith4 ( n ) { if ( n < 4 ) return 0 ; let d = Math . floor ( Math . log10 ( n ) ) ; let a = new Array ( d + 2 ) ; for ( let i = 0 ; i < d + 2 ; i ++ ) { a [ i ] = 0 ; } a [ 0 ] = 0 ; a [ 1 ] = 1 ; for ( let i = 2 ; i <= d ; i ++ ) a [ i ] = a [ i - 1 ] * 9 + Math . floor ( Math . ceil ( Math . pow ( 10 , i - 1 ) ) ) ; let p = Math . floor ( Math . ceil ( Math . pow ( 10 , d ) ) ) ; let msd = Math . floor ( n / p ) ; if ( msd == 4 ) return ( msd ) * a [ d ] + ( n % p ) + 1 ; if ( msd > 4 ) return ( msd - 1 ) * a [ d ] + p + countNumbersWith4 ( n % p ) ; return ( msd ) * a [ d ] + countNumbersWith4 ( n % p ) ; }
function setbitsfromLtoR ( L , R ) { return ( 1 << ( R + 1 ) ) - ( 1 << L ) ; }
function avg_of_odd_num ( n ) { return n ; }
function findVolume ( l , b , h ) { let volume = ( l * b * h ) / 2 ; return volume ; }
function removeDuplicatesFromString ( string ) { let counter = 0 ; let str = string . split ( " " ) ; let i = 0 ; let size = str . length ; let x ; let length = 0 ; while ( i < size ) { x = str [ i ] . charCodeAt ( 0 ) - 97 ; if ( ( counter & ( 1 << x ) ) == 0 ) { str [ length ] = String . fromCharCode ( ' ' . charCodeAt ( 0 ) + x ) ; counter = counter | ( 1 << x ) ; length ++ ; } i ++ ; } return str . join ( " " ) . slice ( 0 , length ) ; }
function printDiagonalSums ( mat , n ) { let principal = 0 , secondary = 0 ; for ( let i = 0 ; i < n ; i ++ ) { principal += mat [ i ] [ i ] ; secondary += mat [ i ] [ n - i - 1 ] ; } document . write ( " " + principal + " " ) ; document . write ( " " + secondary ) ; }
function findPairs ( n ) { var cubeRoot = parseInt ( Math . pow ( n , 1.0 / 3.0 ) ) ; var cube = Array . from ( { length : cubeRoot + 1 } , ( _ , i ) => 0 ) ; for ( i = 1 ; i <= cubeRoot ; i ++ ) cube [ i ] = i * i * i ; var l = 1 ; var r = cubeRoot ; while ( l < r ) { if ( cube [ l ] + cube [ r ] < n ) l ++ ; else if ( cube [ l ] + cube [ r ] > n ) r -- ; else { document . write ( " " + l + " " + r + " " ) ; l ++ ; r -- ; } } }
function minimumX ( n , k ) { let ans = Number . MAX_VALUE ; for ( let rem = k - 1 ; rem > 0 ; rem -- ) { if ( n % rem == 0 ) ans = Math . min ( ans , rem + ( n / rem ) * k ) ; } return ans ; }
function fourthPowerSum ( n ) { return ( ( 6 * n * n * n * n * n ) + ( 15 * n * n * n * n ) + ( 10 * n * n * n ) - n ) / 30 ; }
function lds ( arr , n ) { let lds = new Array ( n ) ; let i , j , max = 0 ; for ( i = 0 ; i < n ; i ++ ) lds [ i ] = 1 ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] < arr [ j ] && lds [ i ] < lds [ j ] + 1 ) lds [ i ] = lds [ j ] + 1 ; for ( i = 0 ; i < n ; i ++ ) if ( max < lds [ i ] ) max = lds [ i ] ; return max ; }
function calculateProbability ( N ) { let probability = N / ( N + 1 ) ; return probability ; }
function getSlope ( m ) { return m ; }
function binomialCoeffSum ( n ) { return ( 1 << n ) ; }
function minimumMoves ( k , l , r ) { let count = r - l + 1 ; if ( count % k == 0 ) return 0 ; return ( k - ( count % k ) ) ; }
function printSpiral ( mat , r , c ) { let i , a = 0 , b = 2 ; let low_row = ( 0 > a ) ? 0 : a ; let low_column = ( 0 > b ) ? 0 : b - 1 ; let high_row = ( ( a + 1 ) >= r ) ? r - 1 : a + 1 ; let high_column = ( ( b + 1 ) >= c ) ? c - 1 : b + 1 ; while ( ( low_row > 0 - r && low_column > 0 - c ) ) { for ( i = low_column + 1 ; i <= high_column && i < c && low_row >= 0 ; ++ i ) document . write ( mat [ low_row ] [ i ] + " " ) ; low_row -= 1 ; for ( i = low_row + 2 ; i <= high_row && i < r && high_column < c ; ++ i ) document . write ( mat [ i ] [ high_column ] + " " ) ; high_column += 1 ; for ( i = high_column - 2 ; i >= low_column && i >= 0 && high_row < r ; -- i ) document . write ( mat [ high_row ] [ i ] + " " ) ; high_row += 1 ; for ( i = high_row - 2 ; i > low_row && i >= 0 && low_column >= 0 ; -- i ) document . write ( mat [ i ] [ low_column ] + " " ) ; low_column -= 1 ; } document . write ( " " ) ; }
function printKDistinct ( arr , n , k ) { var dist_count = 0 ; for ( var i = 0 ; i < n ; i ++ ) { var j ; for ( j = 0 ; j < n ; j ++ ) if ( i != j && arr [ j ] == arr [ i ] ) break ; if ( j == n ) dist_count ++ ; if ( dist_count == k ) return arr [ i ] ; } return - 1 ; }
function make_sequence ( N ) { var arr = Array ( N + 1 ) , sum = 0 ; for ( var i = 1 ; i <= N ; i ++ ) { if ( i % 2 == 1 ) arr [ i ] = 1 ; else arr [ i ] = 2 ; sum += arr [ i ] ; } if ( sum % 2 == 1 ) arr [ 2 ] = 3 ; for ( var i = 1 ; i <= N ; i ++ ) document . write ( arr [ i ] + " " ) ; }
function Nth_Term ( n ) { return ( 3 * Math . pow ( n , 2 ) - n + 2 ) / ( 2 ) ; }
function uniqueCharacters ( str ) { let checker = 0 ; for ( let i = 0 ; i < str . length ; i ++ ) { let bitAtIndex = str [ i ] - ' ' ; if ( ( checker & ( 1 << bitAtIndex ) ) > 0 ) { return false ; } checker = checker | ( 1 << bitAtIndex ) ; } return true ; } let input = " " ; if ( uniqueCharacters ( input ) ) { document . write ( " " + input + " " ) ; } else { document . write ( " " + input + " " ) ; }
function calculate ( ar , size ) { var count = 0 ; for ( i = 0 ; i < size ; i ++ ) if ( ar [ i ] % 2 == 0 && ar [ i ] != 0 && ar [ i ] != 2 ) count ++ ; return count ; }
function countNumbers ( N ) { return ( Math . pow ( 10 , N ) - 1 ) - ( Math . pow ( 10 , N ) - Math . pow ( 8 , N ) ) / 2 ; }
function findM ( s , x ) { var cnt = 0 ; for ( i = 0 ; i < s . length ; i ++ ) { if ( s . charCodeAt ( i ) - ' ' . charCodeAt ( 0 ) != x ) cnt ++ ; } return cnt ; }
function isEven ( s ) { let l = s . length ; let dotSeen = false ; for ( let i = l - 1 ; i >= 0 ; i -- ) { if ( s [ i ] == ' ' && dotSeen == false ) continue ; if ( s [ i ] == ' ' ) { dotSeen = true ; continue ; } if ( ( s [ i ] - ' ' ) % 2 == 0 ) return true ; return false ; } }
function nDigitPerfectCubes ( n ) { document . write ( Math . pow ( Math . ceil ( Math . cbrt ( Math . pow ( 10 , ( n - 1 ) ) ) ) , 3 ) + " " ) ; document . write ( Math . pow ( Math . ceil ( Math . cbrt ( Math . pow ( 10 , ( n ) ) ) ) - 1 , 3 ) ) ; }
function findoptimal ( N ) { if ( N <= 6 ) return N ; let max = 0 ; let b ; for ( b = N - 3 ; b >= 1 ; b -- ) { let curr = ( N - b - 1 ) * findoptimal ( b ) ; if ( curr > max ) max = curr ; } return max ; }
function maxXorSum ( n , k ) { if ( k == 1 ) return n ; let res = 1 ; while ( res <= n ) res <<= 1 ; return res - 1 ; }
function missingK ( a , k , n ) { let difference = 0 , ans = 0 , count = k ; let flag = false ; for ( let i = 0 ; i < n - 1 ; i ++ ) { difference = 0 ; if ( ( a [ i ] + 1 ) != a [ i + 1 ] ) { difference += ( a [ i + 1 ] - a [ i ] ) - 1 ; if ( difference >= count ) { ans = a [ i ] + count ; flag = true ; break ; } else count -= difference ; } } if ( flag ) return ans ; else return - 1 ; }
function volumeOfEllipsoid ( r1 , r2 , r3 ) { let pi = 3.14 ; return 1.33 * pi * r1 * r2 * r3 ; }
function freq ( ar , m , n ) { let even = 0 , odd = 0 ; for ( let i = 0 ; i < m ; ++ i ) { for ( let j = 0 ; j < n ; ++ j ) { if ( ( ar [ i ] [ j ] % 2 ) == 0 ) ++ even ; else ++ odd ; } } document . write ( " " + odd + " " ) ; document . write ( " " + even + " " ) ; }
function countGreater ( arr , n , k ) { var l = 0 ; var r = n - 1 ; var leftGreater = n ; while ( l <= r ) { var m = l + parseInt ( ( r - l ) / 2 ) ; if ( arr [ m ] > k ) { leftGreater = m ; r = m - 1 ; } else l = m + 1 ; } return ( n - leftGreater ) ; }
function Maxsum ( c1 , c2 , c3 , c4 ) { let sum = 0 ; let two34 = Math . min ( c2 , Math . min ( c3 , c4 ) ) ; sum = two34 * 234 ; c2 -= two34 ; sum += Math . min ( c2 , c1 ) * 12 ; return sum ; }
function MinOfCubedDP ( k ) { let DP = new Array ( k + 1 ) ; DP . fill ( 0 ) ; let j = 1 , t = 1 ; DP [ 0 ] = 0 ; for ( let i = 1 ; i <= k ; i ++ ) { DP [ i ] = Number . MAX_VALUE ; while ( j <= i ) { if ( j == i ) DP [ i ] = 1 ; else if ( DP [ i ] > DP [ i - j ] ) DP [ i ] = DP [ i - j ] + 1 ; t ++ ; j = t * t * t ; } t = j = 1 ; } return DP [ k ] ; }
function printbinomial ( max ) { for ( let m = 0 ; m <= max ; m ++ ) { document . write ( m ) ; let binom = 1 ; for ( let x = 0 ; x <= m ; x ++ ) { if ( m != 0 && x != 0 ) binom = binom * ( m - x + 1 ) / x ; document . write ( " " + binom + " " ) ; } document . write ( " " ) ; } }
function decToHexa ( n ) { var hexaDeciNum = Array . from ( { length : 100 } , ( _ , i ) => 0 ) ; var i = 0 ; while ( n != 0 ) { var temp = 0 ; temp = n % 16 ; if ( temp < 10 ) { hexaDeciNum [ i ] = String . fromCharCode ( temp + 48 ) ; i ++ ; } else { hexaDeciNum [ i ] = String . fromCharCode ( temp + 55 ) ; i ++ ; } n = parseInt ( n / 16 ) ; } for ( j = i - 1 ; j >= 0 ; j -- ) document . write ( hexaDeciNum [ j ] ) ; }
function printNumHavingAltBitPatrn ( n ) { var curr_num = 1 ; document . write ( curr_num + " " ) ; while ( true ) { curr_num <<= 1 ; if ( n < curr_num ) break ; document . write ( curr_num + " " ) ; curr_num = ( ( curr_num ) << 1 ) ^ 1 ; if ( n < curr_num ) break ; document . write ( curr_num + " " ) ; } }
function summingSeries ( n ) { return Math . pow ( n , 2 ) ; }
function countTrailingZero ( x ) { let count = 0 ; while ( ( x & 1 ) == 0 ) { x = x >> 1 ; count ++ ; } return count ; }
function digitsNum ( N ) { if ( N == 0 ) document . write ( " " ) ; if ( N % 9 != 0 ) document . write ( N % 9 ) ; for ( var i = 1 ; i <= N / 9 ; ++ i ) document . write ( " " ) ; for ( var i = 1 ; i <= N ; ++ i ) document . write ( " " ) ; document . write ( " " ) ; }
function setBitNumber ( n ) { n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; n = n + 1 ; return ( n >> 1 ) ; }
function sortBinaryArray ( a , n ) { let j = - 1 ; for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] < 1 ) { j ++ ; let temp = a [ j ] ; a [ j ] = a [ i ] ; a [ i ] = temp ; } } }
function NumberOfRectangles ( n , m ) { if ( n % 2 == 0 ) return ( n / 2 ) * m ; else if ( m % 2 == 0 ) return ( m / 2 ) * n ; return ( n * m - 1 ) / 2 ; }
function findSmallest ( a , n ) { for ( let i = 0 ; i < n ; i ++ ) { let j ; for ( j = 0 ; j < n ; j ++ ) if ( a [ j ] % a [ i ] >= 1 ) break ; if ( j == n ) return a [ i ] ; } return - 1 ; }
function findElement ( arr , n , key ) { let i ; for ( i = 0 ; i < n ; i ++ ) if ( arr [ i ] == key ) return i ; return - 1 ; }
function findElements ( arr , n ) { arr . sort ( ) ; for ( let i = 0 ; i < n - 2 ; i ++ ) document . write ( arr [ i ] + " " ) ; }
function maxDistance ( array ) { let max1 = Number . MIN_VALUE ; let min1 = Number . MAX_VALUE ; let max2 = Number . MIN_VALUE ; let min2 = Number . MAX_VALUE ; for ( let i = 0 ; i < array . length ; i ++ ) { max1 = Math . max ( max1 , array [ i ] + i ) ; min1 = Math . min ( min1 , array [ i ] + i ) ; max2 = Math . max ( max2 , array [ i ] - i ) ; min2 = Math . min ( min2 , array [ i ] - i ) ; } return Math . max ( max1 - min1 , max2 - min2 ) ; }
function findCountOfSolutions ( n , p ) { let ans = 0 ; for ( let x = 1 ; x < p ; x ++ ) { if ( ( x * x ) % p == 1 ) { let last = x + p * ( n / p ) ; if ( last > n ) last -= p ; ans += ( ( last - x ) / p + 1 ) ; } } return ans ; }
function printSubstrings ( n ) { var s = parseInt ( Math . log10 ( n ) ) ; var d = parseInt ( ( Math . pow ( 10 , s ) + 0.5 ) ) ; var k = d ; while ( n > 0 ) { while ( d > 0 ) { document . write ( parseInt ( n / d ) + " " ) ; d = parseInt ( d / 10 ) ; } n = n % k ; k = parseInt ( k / 10 ) ; d = k ; } }
function numberSequence ( n ) { let num = Math . pow ( 4 , n ) - Math . pow ( 2 , n ) - 1 ; return num ; }
function Conversion ( centi ) { let pixels = ( 96 * centi ) / 2.54 ; document . write ( pixels ) ; return 0 ; }
function mergeTwoHalf ( A , n ) { A . sort ( ( a , b ) => a - b ) ; }
function items ( n , a ) { a . sort ( function ( a , b ) { return a - b } ) ; let z = a [ n - 1 ] ; let x = 1 ; let s = 0 ; for ( let i = 0 ; i < n - 1 ; i ++ ) { s += a [ i ] ; if ( s <= z ) x += 1 ; else break ; } return x ; }
function findNumbers ( arr , n ) { sumN = ( n * ( n + 1 ) ) / 2 ; sumSqN = ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; let sum = 0 ; let sumSq = 0 ; for ( let i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; sumSq += Math . pow ( arr [ i ] , 2 ) ; } B = ( ( ( sumSq - sumSqN ) / ( sum - sumN ) ) + sumN - sum ) / 2 ; A = sum - sumN + B ; document . write ( " " + A , " " , B ) ; }
function completeSequence ( s ) { let n = s . length ; let open = 0 , close = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ' ' ) open ++ ; else close ++ ; if ( close > open ) { document . write ( " " ) ; return ; } } document . write ( s ) ; for ( let i = 0 ; i < open - close ; i ++ ) document . write ( " " ) ; }
function printRect ( X , Y , n ) { var Xmax = X . reduce ( ( a , b ) => Math . max ( a , b ) ) ; var Xmin = X . reduce ( ( a , b ) => Math . min ( a , b ) ) ; var Ymax = Y . reduce ( ( a , b ) => Math . max ( a , b ) ) ; var Ymin = Y . reduce ( ( a , b ) => Math . min ( a , b ) ) ; document . write ( " " + Xmin + " " + Ymin + " " + " " ) ; document . write ( " " + Xmin + " " + Ymax + " " + " " ) ; document . write ( " " + Xmax + " " + Ymax + " " + " " ) ; document . write ( " " + Xmax + " " + Ymin + " " + " " ) ; }
function check ( s ) { for ( let i = 0 ; i < s . length - 1 ; i ++ ) if ( s [ i ] == s [ i + 1 ] ) return true ; return false ; }
function countSubstrs ( str , i , j , n ) { if ( n == 1 ) return 1 ; if ( n <= 0 ) return 0 ; let res = countSubstrs ( str , i + 1 , j , n - 1 ) + countSubstrs ( str , i , j - 1 , n - 1 ) - countSubstrs ( str , i + 1 , j - 1 , n - 2 ) ; if ( str [ i ] == str [ j ] ) res ++ ; return res ; }
function findMaxAverage ( arr , n , k ) { if ( k > n ) return - 1 ; let csum = new Array ( n ) ; csum [ 0 ] = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) csum [ i ] = csum [ i - 1 ] + arr [ i ] ; let max_sum = csum [ k - 1 ] , max_end = k - 1 ; for ( let i = k ; i < n ; i ++ ) { let curr_sum = csum [ i ] - csum [ i - k ] ; if ( curr_sum > max_sum ) { max_sum = curr_sum ; max_end = i ; } } return max_end - k + 1 ; }
function printCountDP ( dist ) { let count = new Array ( dist + 1 ) ; count [ 0 ] = 1 ; if ( dist >= 1 ) count [ 1 ] = 1 ; if ( dist >= 2 ) count [ 2 ] = 2 ; for ( let i = 3 ; i <= dist ; i ++ ) count [ i ] = count [ i - 1 ] + count [ i - 2 ] + count [ i - 3 ] ; return count [ dist ] ; }
function nextPowerOf2 ( n ) { n -= 1 n |= n >> 1 n |= n >> 2 n |= n >> 4 n |= n >> 8 n |= n >> 16 n += 1 return n }
function isSubSequence ( str1 , str2 , m , n ) { if ( m == 0 ) return true ; if ( n == 0 ) return false ; if ( str1 [ m - 1 ] == str2 [ n - 1 ] ) return isSubSequence ( str1 , str2 , m - 1 , n - 1 ) ; return isSubSequence ( str1 , str2 , m , n - 1 ) ; }
function minCoins ( coins , m , v ) { let table = new Array ( V + 1 ) ; for ( let i = 0 ; i < V + 1 ; i ++ ) { table [ i ] = 0 ; } for ( let i = 1 ; i <= V ; i ++ ) { table [ i ] = Number . MAX_VALUE ; } for ( let i = 1 ; i <= V ; i ++ ) { for ( let j = 0 ; j < m ; j ++ ) if ( coins [ j ] <= i ) { let sub_res = table [ i - coins [ j ] ] ; if ( sub_res != Number . MAX_VALUE && sub_res + 1 < table [ i ] ) table [ i ] = sub_res + 1 ; } } if ( table [ V ] == Number . MAX_VALUE ) return - 1 ; return table [ V ] ; }
function fnMod ( n ) { if ( n % 5 == 1 ) return 4 ; else return 0 ; }
function nth_group ( n ) { return n * ( 2 * Math . pow ( n , 2 ) + 1 ) ; }
function sumOfTheSeries ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { let k = 2 ; for ( let j = 1 ; j <= i ; j ++ ) { sum += k ; k += 2 ; } } return sum ; }
function maximumSumSubarray ( arr , n ) { let min_prefix_sum = 0 ; let res = Number . MIN_VALUE ; let prefix_sum = [ ] ; prefix_sum [ 0 ] = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) prefix_sum [ i ] = prefix_sum [ i - 1 ] + arr [ i ] ; for ( let i = 0 ; i < n ; i ++ ) { res = Math . max ( res , prefix_sum [ i ] - min_prefix_sum ) ; min_prefix_sum = Math . min ( min_prefix_sum , prefix_sum [ i ] ) ; } return res ; }
function countSquares ( row , column ) { var topLeft = Math . min ( row , column ) - 1 ; var bottomRight = 8 - Math . max ( row , column ) ; var topRight = Math . min ( row , 9 - column ) - 1 ; var bottomLeft = 8 - Math . max ( row , 9 - column ) ; return ( topLeft + topRight + bottomRight + bottomLeft ) ; }
function findWinner ( x , y , n ) { var dp = Array ( n + 1 ) . fill ( 0 ) ; dp [ 0 ] = false ; dp [ 1 ] = true ; for ( var i = 2 ; i <= n ; i ++ ) { if ( i - 1 >= 0 && ! dp [ i - 1 ] ) dp [ i ] = true ; else if ( i - x >= 0 && ! dp [ i - x ] ) dp [ i ] = true ; else if ( i - y >= 0 && ! dp [ i - y ] ) dp [ i ] = true ; else dp [ i ] = false ; } return dp [ n ] ; }
function reachTarget ( target ) { target = Math . abs ( target ) ; let sum = 0 , step = 0 ; while ( sum < target || ( sum - target ) % 2 != 0 ) { step ++ ; sum += step ; } return step ; }
function count ( N , K , R ) { var sum = 0 ; for ( i = 1 ; i <= N ; i ++ ) { if ( i % K == R ) sum += i ; } return sum ; }
function findNum ( N , K ) { var rem = ( N + K ) % K ; if ( rem == 0 ) return N ; else return N + K - rem ; }
function maxSum ( N ) { var ans = 0 ; for ( var u = 1 ; u <= N ; u ++ ) { for ( var v = 1 ; v <= N ; v ++ ) { if ( u == v ) continue ; var degreeU = 2 ; if ( u == 1 u == N ) degreeU = 1 ; var degreeV = 2 ; if ( v == 1 v == N ) degreeV = 1 ; ans += ( degreeU * degreeV ) ; } } return ans ; }
function fact ( n ) { if ( n == 0 ) return 1 ; return n * fact ( n - 1 ) ; }
function unitDigitXRaisedY ( x , y ) { let res = 1 ; for ( let i = 0 ; i < y ; i ++ ) res = ( res * x ) % 10 ; return res ; }
function nthprimedigitsnumber ( number ) { let rem ; let num = " " ; while ( number > 0 ) { rem = number % 4 ; switch ( rem ) { case 1 : num += ' ' ; break ; case 2 : num += ' ' ; break ; case 3 : num += ' ' ; break ; case 0 : num += ' ' ; break ; } if ( number % 4 == 0 ) number -- ; number = parseInt ( number / 4 , 10 ) ; } let st = num . split ( ' ' ) ; st . reverse ( ) ; return ( st . join ( " " ) ) ; }
function countDivisors ( n , k ) { var count = 0 , i ; for ( i = 1 ; i <= n ; i ++ ) { if ( n % i == 0 && i % k == 0 ) { count ++ ; } } return count ; }
function middleOfThree ( a , b , c ) { let x = a - b ; let y = b - c ; let z = a - c ; if ( x * y > 0 ) return b ; else if ( x * z > 0 ) return c ; else return a ; }
function nthTerm ( n ) { return 2 * Math . pow ( n , 2 ) + n - 3 ; }
function search ( arr , n , x ) { let res = - 1 ; for ( let i = 0 ; i < n ; i ++ ) if ( x == arr [ i ] ) res = i ; if ( res == - 1 ) return false ; let temp = arr [ res ] ; for ( let i = res ; i > 0 ; i -- ) arr [ i ] = arr [ i - 1 ] ; arr [ 0 ] = temp ; return true ; }
function calTime ( arr , n ) { var work = 0 ; for ( i = 0 ; i < n ; i ++ ) work += 1 / arr [ i ] ; return 1 / work ; }
function maxDiff ( arr , n ) { let maxDiff = - 1 ; let maxRight = arr [ n - 1 ] ; for ( let i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] > maxRight ) maxRight = arr [ i ] ; else { let diff = maxRight - arr [ i ] ; if ( diff > maxDiff ) { maxDiff = diff ; } } } return maxDiff ; }
function maxSubArraySumRepeated ( a , n , k ) { let max_so_far = 0 ; let INT_MIN , max_ending_here = 0 ; for ( let i = 0 ; i < n * k ; i ++ ) { max_ending_here = max_ending_here + a [ i % n ] ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; if ( max_ending_here < 0 ) max_ending_here = 0 ; } return max_so_far ; }
function printCase ( n ) { if ( n <= 2 ) { document . write ( - 1 ) ; return ; } for ( let i = n ; i >= 1 ; i -- ) document . write ( i + " " ) ; }
function pronic_check ( n ) { var x = parseInt ( Math . sqrt ( n ) ) ; if ( x * ( x + 1 ) == n ) return true ; else return false ; }
function getTotalNumberOfSequences ( m , n ) { let T = new Array ( m + 1 ) ; for ( let i = 0 ; i < m + 1 ; i ++ ) { T [ i ] = new Array ( n + 1 ) ; for ( let j = 0 ; j < n + 1 ; j ++ ) { if ( i == 0 j == 0 ) T [ i ] [ j ] = 0 ; else if ( i < j ) T [ i ] [ j ] = 0 ; else if ( j == 1 ) T [ i ] [ j ] = i ; else T [ i ] [ j ] = T [ i - 1 ] [ j ] + T [ parseInt ( i / 2 , 10 ) ] [ j - 1 ] ; } } return T [ m ] [ n ] ; }
function findCount ( mat , i , j , m ) { if ( i == 0 && j == 0 ) { if ( m == mat [ 0 ] [ 0 ] ) return 1 ; else return 0 ; } if ( m < 0 ) return 0 ; if ( i < 0 j < 0 ) return 0 ; if ( v [ i ] [ j ] [ m ] ) return dp [ i ] [ j ] [ m ] ; v [ i ] [ j ] [ m ] = true ; dp [ i ] [ j ] [ m ] = findCount ( mat , i - 1 , j , m - mat [ i ] [ j ] ) + findCount ( mat , i , j - 1 , m - mat [ i ] [ j ] ) ; return dp [ i ] [ j ] [ m ] ; }
function isTrimorphic ( N ) { let cube = N * N * N ; while ( N > 0 ) { if ( N % 10 != cube % 10 ) return false ; N = parseInt ( N / 10 , 10 ) ; cube = parseInt ( cube / 10 , 10 ) ; } return true ; }
function findCount ( str ) { var result = 0 ; for ( var i = 0 ; i < str . length ; i ++ ) if ( i === str [ i ] . charCodeAt ( 0 ) - " " . charCodeAt ( 0 ) || i === str [ i ] . charCodeAt ( 0 ) - " " . charCodeAt ( 0 ) ) result ++ ; return result ; }
function LiesInsieRectangle ( a , b , x , y ) { if ( x - y - b <= 0 && x - y + b >= 0 && x + y - 2 * a + b <= 0 && x + y - b >= 0 ) return true ; return false ; }
function countDigitOne ( n ) { let countr = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { let str = i . toString ( ) ; countr += str . split ( " " ) . length - 1 ; } return countr ; }
function length_rope ( r ) { return ( ( 2 * PI * r ) + 6 * r ) ; }
function countUnmarked ( N ) { if ( N % 2 == 0 ) return N / 2 ; else return N / 2 + 1 ; }
function difference ( arr , n ) { let d1 = 0 , d2 = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { if ( i == j ) d1 += arr [ i ] [ j ] ; if ( i == n - j - 1 ) d2 += arr [ i ] [ j ] ; } } return Math . abs ( d1 - d2 ) ; }
function maxLength ( s , n ) { var right = 0 , left = 0 ; var coun = 0 , max_length = Number . MIN_VALUE ; s = s + ' ' ; for ( var i = 0 ; i <= n ; i ++ ) { if ( s [ i ] == ' ' ) coun ++ ; else { if ( coun > max_length ) { right = 0 ; left = 0 ; if ( s [ i ] == ' ' ) right = 1 ; if ( ( ( i - coun ) > 0 ) && ( s [ i - coun - 1 ] == ' ' ) ) left = 1 ; coun = Math . ceil ( coun / ( right + left ) ) ; max_length = Math . max ( max_length , coun ) ; } coun = 0 ; } } return max_length ; }
function maxAverageOfPath ( cost , N ) { let dp = new Array ( N + 1 ) ; for ( let i = 0 ; i < N + 1 ; i ++ ) { dp [ i ] = new Array ( N + 1 ) ; for ( let j = 0 ; j < N + 1 ; j ++ ) { dp [ i ] [ j ] = 0 ; } } dp [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] ; for ( let i = 1 ; i < N ; i ++ ) dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ] ; for ( let j = 1 ; j < N ; j ++ ) dp [ 0 ] [ j ] = dp [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ] ; for ( let i = 1 ; i < N ; i ++ ) for ( let j = 1 ; j < N ; j ++ ) dp [ i ] [ j ] = Math . max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) + cost [ i ] [ j ] ; return dp [ N - 1 ] [ N - 1 ] / ( 2 * N - 1 ) ; }
function countPaths ( sum , get , m , n , dp ) { if ( sum < 0 ) return 0 ; if ( sum == 0 ) return get ; if ( dp [ sum ] [ get ] != - 1 ) return dp [ sum ] [ get ] ; let res = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { if ( i == m ) res += countPaths ( sum - i , 1 , m , n , dp ) ; else res += countPaths ( sum - i , get , m , n , dp ) ; } dp [ sum ] [ get ] = res ; return dp [ sum ] [ get ] ; } let n = 3 , m = 2 , x = 3 ; let dp = new Array ( max + 1 ) ; for ( let i = 0 ; i <= max ; i ++ ) { dp [ i ] = new Array ( 2 ) for ( let j = 0 ; j < 2 ; j ++ ) dp [ i ] [ j ] = - 1 ; }
function findPCSlope ( m ) { return - 1.0 / m ; }
function findPrimeFactors ( ) { for ( let i = 2 ; i < N ; i ++ ) if ( primeFactors [ i ] == 0 ) for ( let j = i ; j < N ; j += i ) primeFactors [ j ] = primeFactors [ parseInt ( j / i , 10 ) ] + 1 ; for ( let i = 1 ; i < N ; i ++ ) primeFactors [ i ] += primeFactors [ i - 1 ] ; }
function maxSum ( arr , n ) { if ( n < 2 ) return - 1 ; let ans = arr [ 0 ] + arr [ 1 ] ; for ( let i = 1 ; i + 1 < n ; i ++ ) ans = Math . min ( ans , ( arr [ i ] + arr [ i + 1 ] ) ) ; return ans ; }
function octahedral_num ( n ) { return n * ( 2 * n * n + 1 ) / 3 ; }
function sumOfSeries ( n ) { let ans = Math . pow ( n % MOD , 2 ) ; return ( ans % MOD ) ; }
function findSum ( n ) { let sum = 0 ; for ( x = 1 ; x <= n ; x ++ ) sum = sum + x ; return sum ; }
function totEdge ( n ) { var result = 0 ; result = ( n * ( n - 1 ) ) / 2 ; return result ; }
function superSeq ( X , Y , m , n ) { if ( m == 0 ) return n ; if ( n == 0 ) return m ; if ( X . charAt ( m - 1 ) == Y . charAt ( n - 1 ) ) return 1 + superSeq ( X , Y , m - 1 , n - 1 ) ; return 1 + Math . min ( superSeq ( X , Y , m - 1 , n ) , superSeq ( X , Y , m , n - 1 ) ) ; }
function arekAnagrams ( str1 , str2 , k ) { let n = str1 . length ; if ( str2 . length != n ) return false ; let count1 = new Array ( MAX_CHAR ) ; let count2 = new Array ( MAX_CHAR ) ; let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) count1 [ str1 [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; for ( let i = 0 ; i < n ; i ++ ) count2 [ str2 [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; for ( let i = 0 ; i < MAX_CHAR ; i ++ ) if ( count1 [ i ] > count2 [ i ] ) count = count + Math . abs ( count1 [ i ] - count2 [ i ] ) ; return ( count <= k ) ; }
function EqualNumbers ( a , n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum += a [ i ] ; if ( sum % n ) return n - 1 ; return n ; }
function countStrings ( n ) { let a = [ ] , b = [ ] ; a [ 0 ] = b [ 0 ] = 1 ; for ( let i = 1 ; i < n ; i ++ ) { a [ i ] = a [ i - 1 ] + b [ i - 1 ] ; b [ i ] = a [ i - 1 ] ; } return ( 1 << n ) - a [ n - 1 ] - b [ n - 1 ] ; }
function isTriPerfect ( n ) { let sum = 1 + n ; let i = 2 ; while ( i * i <= n ) { if ( n % i == 0 ) { if ( parseInt ( n / i , 10 ) == i ) sum = sum + i ; else sum = sum + i + parseInt ( n / i , 10 ) ; } i += 1 ; } if ( sum == 3 * n & n != 1 ) return true ; else return false ; }
function checkCentrosymmetricted ( n , m ) { let mid_row ; if ( n & 1 ) mid_row = Math . floor ( n / 2 ) + 1 ; else mid_row = n / 2 ; for ( let i = 0 ; i < mid_row ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { if ( m [ i ] [ j ] != m [ n - i - 1 ] [ n - j - 1 ] ) return false ; } } return true ; }
function countFriendsPairings ( n ) { if ( dp [ n ] != - 1 ) return dp [ n ] ; if ( n > 2 ) return dp [ n ] = countFriendsPairings ( n - 1 ) + ( n - 1 ) * countFriendsPairings ( n - 2 ) ; else return dp [ n ] = n ; }
function getElements ( a , arr , n ) { let elements = new Array ( n + 1 ) ; for ( let i = 0 ; i < n + 1 ; i ++ ) { elements [ i ] = 0 ; } elements [ 0 ] = a ; for ( let i = 0 ; i < n ; i ++ ) { elements [ i + 1 ] = arr [ i ] ^ elements [ i ] ; } for ( let i = 0 ; i < n + 1 ; i ++ ) document . write ( elements [ i ] + " " ) ; }
function isKthBitSet ( n , k ) { if ( ( ( n >> ( k - 1 ) ) & 1 ) > 0 ) document . write ( " " ) ; else document . write ( " " ) ; }
function findTrailingZeros ( n ) { let count = 0 ; for ( let i = 5 ; Math . floor ( n / i ) >= 1 ; i *= 5 ) count += Math . floor ( n / i ) ; return count ; }
function MinOperation ( a , b , n ) { a . sort ( function ( a , b ) { return a - b } ) ; b . sort ( function ( a , b ) { return a - b } ) ; let result = 0 ; for ( let i = 0 ; i < n ; ++ i ) { if ( a [ i ] > b [ i ] ) result = result + Math . abs ( a [ i ] - b [ i ] ) ; else if ( a [ i ] < b [ i ] ) result = result + Math . abs ( a [ i ] - b [ i ] ) ; } return result ; }
function countOddSum ( ar , n ) { let result = 0 ; for ( let i = 0 ; i <= n - 1 ; i ++ ) { let val = 0 ; for ( let j = i ; j <= n - 1 ; j ++ ) { val = val + ar [ j ] ; if ( val % 2 != 0 ) result ++ ; } } return ( result ) ; }
function findParity ( x ) { let y = x ^ ( x >> 1 ) ; y = y ^ ( y >> 2 ) ; y = y ^ ( y >> 4 ) ; y = y ^ ( y >> 8 ) ; y = y ^ ( y >> 16 ) ; if ( y & 1 ) return 1 ; return 0 ; }
function Add ( x , y ) { while ( y != 0 ) { let carry = x & y ; x = x ^ y ; y = carry << 1 ; } return x ; }
function printTetra ( n ) { if ( n < 0 ) return ; var first = 0 , second = 1 ; var third = 1 , fourth = 2 ; var curr ; if ( n == 0 ) cout << first ; else if ( n == 1 n == 2 ) cout << second ; else if ( n == 3 ) cout << fourth ; else { for ( var i = 4 ; i <= n ; i ++ ) { curr = first + second + third + fourth ; first = second ; second = third ; third = fourth ; fourth = curr ; } document . write ( curr ) ; } }
function fun ( n ) { return n & ( n - 1 ) ; }
function rearrange ( arr , n ) { if ( arr == null n % 2 == 1 ) return ; let currIdx = Math . floor ( ( n - 1 ) / 2 ) ; while ( currIdx > 0 ) { let count = currIdx , swapIdx = currIdx ; while ( count -- > 0 ) { let temp = arr [ swapIdx + 1 ] ; arr [ swapIdx + 1 ] = arr [ swapIdx ] ; arr [ swapIdx ] = temp ; swapIdx ++ ; } currIdx -- ; } }
function countOddSquares ( n , m ) { return Math . pow ( m , 0.5 ) - Math . pow ( n - 1 , 0.5 ) ; }
function isSubsetAndZero ( array , len , N ) { var arrAnd = array [ 0 ] ; for ( var i = 1 ; i < len ; i ++ ) { arrAnd = arrAnd & array [ i ] ; } if ( ( arrAnd & N ) == 0 ) document . write ( " " + " " ) ; else document . write ( " " + " " ) ; }
function isSumOfPowersOfTwo ( n ) { if ( n % 2 == 1 ) return false ; else return true ; }
function minItems ( k , r ) { for ( let i = 1 ; i < 10 ; i ++ ) if ( ( i * k - r ) % 10 == 0 || ( i * k ) % 10 == 0 ) return i ; return 10 ; }
function result ( n , k , t ) { if ( t <= k ) document . write ( t ) ; else if ( t <= n ) document . write ( k ) ; else { let temp = t - n ; temp = k - temp ; document . write ( temp ) ; } }
function isMember ( a , d , x ) { if ( d == 0 ) return ( x == a ) ; return ( ( x - a ) % d == 0 && ( x - a ) / d >= 0 ) ; }
function numberOfSolutions ( n ) { let c = 0 ; for ( let x = 0 ; x <= n ; ++ x ) if ( n == x + n ^ x ) ++ c ; return c ; }
function findSDSFunc ( n ) { let DP = [ ] ; DP [ 0 ] = 0 ; DP [ 1 ] = 1 ; for ( let i = 2 ; i <= n ; i ++ ) { if ( i % 2 == 0 ) DP [ i ] = DP [ i / 2 ] ; else DP [ i ] = DP [ ( i - 1 ) / 2 ] + DP [ ( i + 1 ) / 2 ] ; } return DP [ n ] ; }
function findSum ( n , a , b ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) if ( i % a == 0 i % b == 0 ) sum += i ; return sum ; }
function maxSumWO3Consec ( n ) { if ( sum [ n ] != - 1 ) { return sum [ n ] ; } if ( n == 0 ) { return sum [ n ] = 0 ; } if ( n == 1 ) { return sum [ n ] = arr [ 0 ] ; } if ( n == 2 ) { return sum [ n ] = arr [ 1 ] + arr [ 0 ] ; } return sum [ n ] = 500 + Math . max ( Math . max ( maxSumWO3Consec ( n - 1 ) , maxSumWO3Consec ( n - 2 ) + arr [ n ] ) , arr [ n ] + arr [ n - 1 ] + maxSumWO3Consec ( n - 3 ) ) ; }
function findValues ( a , b ) { if ( ( a - b ) % 2 == 1 ) { document . write ( " " ) ; return ; } document . write ( ( a - b ) / 2 + " " + ( a + b ) / 2 ) ; }
function printNonConsecutive ( n ) { let p = ( 1 << n ) ; for ( let i = 1 ; i < p ; i ++ ) if ( ( i & ( i << 1 ) ) == 0 ) document . write ( i + " " ) ; }
function zigzag ( n , k ) { let dp = new Array ( n + 1 ) ; for ( var i = 0 ; i < dp . length ; i ++ ) { dp [ i ] = new Array ( 2 ) ; } dp [ 0 ] [ 0 ] = 1 ; for ( let i = 1 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { for ( let j = 1 ; j <= Math . min ( i , k ) ; j ++ ) dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ i - j ] ; } return dp [ n ] [ k ] ; }
function countWords ( str , len ) { let count = 1 ; if ( len == 1 ) return count ; if ( str [ 0 ] == str [ 1 ] ) count *= 1 ; else count *= 2 ; for ( let j = 1 ; j < len - 1 ; j ++ ) { if ( str [ j ] == str [ j - 1 ] && str [ j ] == str [ j + 1 ] ) count *= 1 ; else if ( str [ j ] == str [ j - 1 ] str [ j ] == str [ j + 1 ] str [ j - 1 ] == str [ j + 1 ] ) count *= 2 ; else count *= 3 ; } if ( str [ len - 1 ] == str [ len - 2 ] ) count *= 1 ; else count *= 2 ; return count ; }
function xorCalc ( k ) { if ( k == 1 ) return 2 ; if ( ( ( k + 1 ) & k ) == 0 ) return parseInt ( k / 2 ) ; return 1 ; }
function maxAND ( arr , n ) { var res = 0 ; for ( var i = 0 ; i < n ; i ++ ) for ( var j = i + 1 ; j < n ; j ++ ) res = Math . max ( res , arr [ i ] & arr [ j ] ) ; return res ; }
function nswp ( n ) { if ( n == 0 n == 1 ) return 1 ; return 2 * nswp ( n - 1 ) + nswp ( n - 2 ) ; }
function sumOfInternalAngles ( n ) { if ( n < 3 ) return 0 ; return ( n - 2 ) * 180 ; }
function maxPrefix ( s , t ) { let count = 0 ; for ( let i = 0 ; i < t . length ; i ++ ) { if ( count == s . length ) break ; if ( t [ i ] == s [ count ] ) count ++ ; } return count ; }
function printClosest ( arr , n , x ) { let res_l = 0 , res_r = 0 ; let l = 0 , r = n - 1 , diff = Number . MAX_VALUE ; while ( r > l ) { if ( Math . abs ( arr [ l ] + arr [ r ] - x ) < diff ) { res_l = l ; res_r = r ; diff = Math . abs ( arr [ l ] + arr [ r ] - x ) ; } if ( arr [ l ] + arr [ r ] > x ) r -- ; else l ++ ; } document . write ( " " + arr [ res_l ] + " " + arr [ res_r ] ) ; }
function solve ( a , n ) { let ones = 0 , twos = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 1 ) ones ++ ; else twos ++ ; } let ind = 0 ; if ( twos > 0 ) a [ ind ++ ] = 2 ; let evenOnes = ( ones % 2 == 0 ) ? true : false ; if ( evenOnes ) ones -= 1 ; for ( let i = 0 ; i < ones ; i ++ ) a [ ind ++ ] = 1 ; for ( let i = 0 ; i < twos - 1 ; i ++ ) a [ ind ++ ] = 2 ; if ( evenOnes ) a [ ind ++ ] = 1 ; for ( let i = 0 ; i < n ; i ++ ) document . write ( a [ i ] + " " ) ; }
function countSolutions ( n , val ) { let total = 0 ; if ( n == 1 && val >= 0 ) return 1 ; for ( let i = 0 ; i <= val ; i ++ ) { total += countSolutions ( n - 1 , val - i ) ; } return total ; }
function GIF ( n ) { return Math . floor ( n ) ; }
function gcd ( a , b ) { if ( a < b ) return gcd ( b , a ) ; if ( Math . abs ( b ) < 0.001 ) return a ; else return ( gcd ( b , a - Math . floor ( a / b ) * b ) ) ; }
function trianglearea ( a ) { if ( a < 0 ) return - 1 ; var area = ( 3 * Math . sqrt ( 3 ) * Math . pow ( a , 2 ) ) / 4 ; return area . toFixed ( 4 ) ; }
function solve ( n , k ) { if ( n >= ( k * ( k + 1 ) ) / 2 ) { return true ; } return false ; }
function multiplyWith4 ( n ) { return ( n << 2 ) ; }
function findSmallest ( arr , n ) { var res = 1 ; for ( i = 0 ; i < n && arr [ i ] <= res ; i ++ ) res = res + arr [ i ] ; return res ; }
function minSum ( A , n ) { let min_val = Math . min ( ... A ) ; return ( min_val * ( n - 1 ) ) ; }
function calculateAreaSum ( l , b ) { var size = 1 ; var maxSize = Math . min ( l , b ) ; var totalArea = 0 ; for ( var i = 1 ; i <= maxSize ; i ++ ) { var totalSquares = ( l - size + 1 ) * ( b - size + 1 ) ; var area = totalSquares * size * size ; totalArea += area ; size ++ ; } return totalArea ; }
function multiply ( n , m ) { let ans = 0 , count = 0 ; while ( m ) { if ( m % 2 == 1 ) ans += n << count ; count ++ ; m = Math . floor ( m / 2 ) ; } return ans ; }
function countZeroes ( mat ) { let row = N - 1 , col = 0 ; let count = 0 ; while ( col < N ) { while ( mat [ row ] [ col ] > 0 ) if ( -- row < 0 ) return count ; count += ( row + 1 ) ; col ++ ; } return count ; }
function magicOfSequence ( N ) { let sum = 0 ; for ( let i = 1 ; i <= N ; i ++ ) sum += ( i * i * i + i * 2 ) ; return sum ; }
function isUpperTriangularMatrix ( mat ) { for ( let i = 1 ; i < N ; i ++ ) for ( let j = 0 ; j < i ; j ++ ) if ( mat [ i ] [ j ] != 0 ) return false ; return true ; }
function nthTerm ( n ) { return 3 * Math . pow ( n , 2 ) + 2 * n - 5 ; }
function addNDigits ( a , b , n ) { let num = a ; for ( let i = 0 ; i <= 9 ; i ++ ) { let tmp = a * 10 + i ; if ( tmp % b == 0 ) { a = tmp ; break ; } } if ( num == a ) return - 1 ; for ( let j = 0 ; j < n - 1 ; j ++ ) a *= 10 ; return a ; }
function term ( n ) { let x = parseInt ( ( ( 1 ) + Math . sqrt ( 1 + ( 8 * n ) ) ) / 2 ) ; return x ; }
function setKthBit ( n , k ) { return ( ( 1 << k ) n ) ; }
function cyl ( r , R , h ) { if ( h < 0 && r < 0 && R < 0 ) return - 1 ; var r1 = r ; var h1 = h ; var V = ( 3.14 * Math . pow ( r1 , 2 ) * h1 ) ; return V ; }
function getValueOfF ( n ) { if ( n == 1 ) return 0 ; if ( n == 2 ) return 1 ; let cnt = 0 ; while ( n % 2 == 0 ) { cnt += 1 ; n = parseInt ( n / 2 , 10 ) ; } return 2 * cnt ; }
function getSum ( n , d ) { let sum = 0 ; while ( d <= n ) { sum += d ; d += 10 ; } return sum ; }
function getCount ( a , b ) { if ( b . length % a . length != 0 ) return - 1 ; var count = parseInt ( b . length / a . length ) ; var str = " " ; for ( i = 0 ; i < count ; i ++ ) { str = str + a ; } if ( str == ( b ) ) return count ; return - 1 ; }
function kPresentProbability ( a , n , k ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) if ( a [ i ] == k ) count += 1 ; return count / n ; }
function countCrossLine ( arr , n ) { let count_crossline = 0 ; let i , key , j ; for ( i = 1 ; i < n ; i ++ ) { key = arr [ i ] ; j = i - 1 ; while ( j >= 0 && arr [ j ] > key ) { arr [ j + 1 ] = arr [ j ] ; j = j - 1 ; count_crossline ++ ; } arr [ j + 1 ] = key ; } return count_crossline ; }
function findSum ( n ) { if ( n % 2 == 0 ) return ( n / 2 ) * ( n + 1 ) else return ( ( n + 1 ) / 2 ) * n }
function count_triples ( n , k ) { var i = 0 , j = 0 , l = 0 ; var count = 0 ; for ( i = 1 ; i <= n ; i ++ ) { for ( j = 1 ; j <= n ; j ++ ) { for ( l = 1 ; l <= n ; l ++ ) { if ( ( i + j ) % k == 0 && ( i + l ) % k == 0 && ( j + l ) % k == 0 ) count ++ ; } } } return count ; }
function checking ( s ) { let c = 0 ; let n = s . length ; for ( let i = n - 1 ; i >= 0 ; i -- ) { if ( s [ i ] == ' ' ) c ++ ; if ( c >= 6 && s [ i ] == ' ' ) return true ; } return false ; }
function findMinSum ( arr , n ) { var occ = n - 1 , sum = 0 ; for ( var i = 0 ; i < n ; i ++ ) { sum += arr [ i ] * Math . pow ( 2 , occ ) ; occ -- ; } return sum ; }
function minParentheses ( p ) { var bal = 0 ; var ans = 0 ; for ( var i = 0 ; i < p . length ; ++ i ) { bal += p [ i ] == ' ' ? 1 : - 1 ; if ( bal == - 1 ) { ans += 1 ; bal += 1 ; } } return bal + ans ; }
function printFibonacciNumbers ( n ) { let f1 = 0 , f2 = 1 , i ; if ( n < 1 ) return ; document . write ( f1 + " " ) ; for ( i = 1 ; i < n ; i ++ ) { document . write ( f2 + " " ) ; let next = f1 + f2 ; f1 = f2 ; f2 = next ; } }
function lenoflongestnonpalindrome ( s ) { let max1 = 1 , len = 0 ; for ( let i = 0 ; i < s . length - 1 ; i ++ ) { if ( s [ i ] == s [ i + 1 ] ) len = 0 ; else if ( s [ i + 1 ] == s [ i - 1 ] && i > 0 ) len = 1 ; len ++ ; } if ( max1 == 1 ) return 0 ; else return max1 ; }
function maxOnesIndex ( arr , n ) { let max_count = 0 ; let max_index = 0 ; let prev_zero = - 1 ; let prev_prev_zero = - 1 ; for ( let curr = 0 ; curr < n ; ++ curr ) { if ( arr [ curr ] == 0 ) { if ( curr - prev_prev_zero > max_count ) { max_count = curr - prev_prev_zero ; max_index = prev_zero ; } prev_prev_zero = prev_zero ; prev_zero = curr ; } } if ( n - prev_prev_zero > max_count ) max_index = prev_zero ; return max_index ; }
function isDivisibleby17 ( n ) { if ( n == 0 n == 17 ) return true ; if ( n < 17 ) return false ; return isDivisibleby17 ( Math . floor ( n >> 4 ) - Math . floor ( n & 15 ) ) ; }
function profitLoss ( N , M ) { if ( N == M ) document . write ( " " ) ; else { var result = 0.0 ; result = ( Math . abs ( N - M ) ) / M ; if ( N - M < 0 ) document . write ( " " + result . toFixed ( 6 ) * 100 + " " ) ; else document . write ( " " + result . toFixed ( 6 ) * 100 + " " ) ; } }
function findX ( A , B ) { let j = 0 , x = 0 ; while ( A != 0 B != 0 ) { if ( ( A % 2 == 1 ) && ( B % 2 == 1 ) ) { x += ( 1 << j ) ; } A >>= 1 ; B >>= 1 ; j += 1 ; } return x ; }
function NumberofWays ( n ) { var x = ( 1 * n * ( n - 1 ) * ( n - 2 ) * ( n - 3 ) ) / ( 4 * 3 * 2 * 1 ) ; var y = 1 * n * ( n - 1 ) * ( n - 2 ) * ( n - 3 ) ; return 1 * x * y ; }
function smallestSumSubarr ( arr , n ) { let min_ending_here = 2147483647 ; let min_so_far = 2147483647 ; for ( let i = 0 ; i < n ; i ++ ) { if ( min_ending_here > 0 ) min_ending_here = arr [ i ] ; else min_ending_here += arr [ i ] ; min_so_far = Math . min ( min_so_far , min_ending_here ) ; } return min_so_far ; }
function count ( S , X ) { var count = 0 ; var N = S . length ; for ( var i = 0 ; i < N ; ++ i ) { if ( S [ i ] != ' ' ) { for ( var len = 1 ; ( i + len ) <= N ; ++ len ) { if ( parseInt ( S . substring ( i , i + len ) ) > X ) count ++ ; } } } return count ; }
function findMinDifference ( arr , n ) { arr . sort ( ) ; let diff1 = arr [ n - 1 ] - arr [ 1 ] ; let diff2 = arr [ n - 2 ] - arr [ 0 ] ; return Math . min ( diff1 , diff2 ) ; }
function nthTerm ( n ) { return Math . pow ( n , 2 ) + 2 * n + 2 ; }
function fib ( n ) { if ( n <= 1 ) return n ; return fib ( n - 1 ) + fib ( n - 2 ) ; }
function makeAndCheckString ( words , str ) { let n = words . length ; let first = false , second = false ; for ( let i = 0 ; i < n ; i ++ ) { if ( words [ i ] == str ) return true ; if ( str [ 0 ] == words [ i ] [ 1 ] ) first = true ; if ( str [ 1 ] == words [ i ] [ 0 ] ) second = true ; if ( first && second ) return true ; } return false ; }
function minimumflip ( mat , n ) { let transpose = new Array ( n ) ; for ( var i = 0 ; i < transpose . length ; i ++ ) { transpose [ i ] = new Array ( 2 ) ; } for ( let i = 0 ; i < n ; i ++ ) for ( let j = 0 ; j < n ; j ++ ) transpose [ i ] [ j ] = mat [ j ] [ i ] ; let flip = 0 ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = 0 ; j < n ; j ++ ) if ( transpose [ i ] [ j ] != mat [ i ] [ j ] ) flip ++ ; return flip / 2 ; }
function search ( ar , size ) { let a = 0 , b = size - 1 ; let mid = 0 ; while ( ( b - a ) > 1 ) { mid = ( a + b ) / 2 ; if ( ( ar [ a ] - a ) != ( ar [ mid ] - mid ) ) b = mid ; else if ( ( ar [ b ] - b ) != ( ar [ mid ] - mid ) ) a = mid ; } return ( ar [ a ] + 3 ) ; }
function maxPathSum ( tri , m , n ) { for ( let i = m - 1 ; i >= 0 ; i -- ) { for ( let j = 0 ; j <= i ; j ++ ) { if ( tri [ i + 1 ] [ j ] > tri [ i + 1 ] [ j + 1 ] ) tri [ i ] [ j ] += tri [ i + 1 ] [ j ] ; else tri [ i ] [ j ] += tri [ i + 1 ] [ j + 1 ] ; } } return tri [ 0 ] [ 0 ] ; }
function factorial ( n ) { return ( n == 1 n == 0 ) ? 1 : n * factorial ( n - 1 ) ; }
function findMissing ( arr , n ) { let l = 0 , h = n - 1 ; let mid ; while ( h > l ) { mid = l + Math . floor ( ( h - l ) / 2 ) ; if ( arr [ mid ] - mid == arr [ 0 ] ) { if ( arr [ mid + 1 ] - arr [ mid ] > 1 ) return arr [ mid ] + 1 ; else { l = mid + 1 ; } } else { if ( arr [ mid ] - arr [ mid - 1 ] > 1 ) return arr [ mid ] - 1 ; else { h = mid - 1 ; } } } return - 1 ; }
function lucas ( n ) { let a = 2 , b = 1 , c , i ; if ( n == 0 ) return a ; for ( i = 2 ; i <= n ; i ++ ) { c = a + b ; a = b ; b = c ; } return b ; }
function printMaxOfMin ( n ) { for ( k = 1 ; k <= n ; k ++ ) { var maxOfMin = Number . MIN_VALUE ; for ( i = 0 ; i <= n - k ; i ++ ) { var min = arr [ i ] ; for ( j = 1 ; j < k ; j ++ ) { if ( arr [ i + j ] < min ) min = arr [ i + j ] ; } if ( min > maxOfMin ) maxOfMin = min ; } document . write ( maxOfMin + " " ) ; } }
function gcd ( a , b ) { if ( a == b ) return a ; if ( a == 0 ) return b ; if ( b == 0 ) return a ; { return gcd ( a >> 1 , b ) ; return gcd ( a >> 1 , b >> 1 ) << 1 ; } if ( ( ~ b & 1 ) == 1 ) return gcd ( a , b >> 1 ) ; if ( a > b ) return gcd ( ( a - b ) >> 1 , b ) ; return gcd ( ( b - a ) >> 1 , a ) ; }
function longestAlternating ( arr , n ) { let count = new Array ( n ) ; count [ n - 1 ] = 1 ; for ( let i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] * arr [ i + 1 ] < 0 ) count [ i ] = count [ i + 1 ] + 1 ; else count [ i ] = 1 ; } for ( let i = 0 ; i < n ; i ++ ) document . write ( count [ i ] + " " ) ; }
function findSingle ( ar , ar_size ) { let res = ar [ 0 ] ; for ( let i = 1 ; i < ar_size ; i ++ ) res = res ^ ar [ i ] ; return res ; }
function nthTerm ( n ) { return 2 * Math . pow ( n , 3 ) + Math . pow ( n , 2 ) ; }
function minReplacement ( s , len ) { var ans = 0 ; for ( var i = 0 ; i < len ; i ++ ) { if ( i % 2 == 0 && s [ i ] == ' ' ) ans ++ ; if ( i % 2 == 1 && s [ i ] == ' ' ) ans ++ ; } return Math . min ( ans , len - ans ) ; }
function countDigits ( a , b ) { let count = 0 ; let p = Math . abs ( a * b ) ; if ( p == 0 ) return 1 ; while ( p > 0 ) { count ++ ; p = parseInt ( p / 10 , 10 ) ; } return count ; }
function rainDayProbability ( a , n ) { let count = 0 , m ; for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 1 ) count ++ ; } m = count / n ; return m ; }
function get_max_splits ( num_String ) { let count = 0 , current_num ; let running_sum = 0 ; for ( let i = 0 ; i < num_String . length ; i ++ ) { current_num = num_String [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ; running_sum += current_num ; if ( current_num % 3 == 0 || ( running_sum != 0 && running_sum % 3 == 0 ) ) { count += 1 ; running_sum = 0 ; } } return count ; }
function isDudeney ( n ) { let cube_rt = parseInt ( Math . round ( ( Math . pow ( n , 1.0 / 3.0 ) ) ) ) ; if ( cube_rt * cube_rt * cube_rt != n ) return false ; let dig_sum = 0 ; let temp = n ; while ( temp > 0 ) { let rem = temp % 10 ; dig_sum += rem ; temp = parseInt ( temp / 10 ) ; } if ( cube_rt != dig_sum ) return false ; return true ; }
function numbersWith3Divisors ( n ) { let prime = new Array ( n + 1 ) ; prime . fill ( true ) ; prime [ 0 ] = prime [ 1 ] = 0 ; for ( let p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( let i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } document . write ( " " + " " ) ; for ( let i = 0 ; i * i <= n ; i ++ ) if ( prime [ i ] ) document . write ( i * i + " " ) ; }
function isPrime ( n , i ) { if ( n <= 2 ) return ( n == 2 ) ? true : false ; if ( n % i == 0 ) return false ; if ( i * i > n ) return true ; return isPrime ( n , i + 1 ) ; }
function modFact ( n , p ) { if ( n >= p ) return 0 ; let result = 1 ; for ( let i = 1 ; i <= n ; i ++ ) result = ( result * i ) % p ; return result ; }
function printPairs ( arr , n , k ) { let isPairFound = true ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { if ( i != j && arr [ i ] % arr [ j ] == k ) { document . write ( " " + arr [ i ] + " " + arr [ j ] + " " + " " ) ; isPairFound = true ; } } } return isPairFound ; }
function findMaxValue ( N , mat ) { let maxValue = Number . MIN_VALUE ; for ( let a = 0 ; a < N - 1 ; a ++ ) for ( let b = 0 ; b < N - 1 ; b ++ ) for ( let d = a + 1 ; d < N ; d ++ ) for ( let e = b + 1 ; e < N ; e ++ ) if ( maxValue < ( mat [ d ] [ e ] - mat [ a ] [ b ] ) ) maxValue = mat [ d ] [ e ] - mat [ a ] [ b ] ; return maxValue ; }
function isDivBy2PowerM ( n , m ) { if ( ( n & ( ( 1 << m ) - 1 ) ) == 0 ) return true ; return false ; }
function rectanglearea ( a , b ) { if ( a < 0 b < 0 ) return - 1 ; return 2 * a * b ; }
function sph ( r , R , h ) { if ( r < 0 && R < 0 && h < 0 ) return - 1 ; var x = r ; var V = ( ( 4 * 3.14 * Math . pow ( r , 3 ) ) / 3 ) ; return V ; }
function getFinalElement ( n ) { let finalNum ; for ( finalNum = 2 ; finalNum * 2 <= n ; finalNum *= 2 ) ; return finalNum ; }
function weightedMean ( n ) { return parseInt ( ( 2 * n + 1 ) / 3 , 10 ) ; }
function finalPosition ( move ) { let l = move . length ; let countUp = 0 , countDown = 0 ; let countLeft = 0 , countRight = 0 ; for ( let i = 0 ; i < l ; i ++ ) { if ( move [ i ] == ' ' ) countUp ++ ; else if ( move [ i ] == ' ' ) countDown ++ ; else if ( move [ i ] == ' ' ) countLeft ++ ; else if ( move [ i ] == ' ' ) countRight ++ ; } document . write ( " " + ( countRight - countLeft ) + " " + ( countUp - countDown ) + " " ) ; }
function pairInSortedRotated ( arr , n , x ) { let i ; for ( i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] > arr [ i + 1 ] ) break ; let l = ( i + 1 ) % n ; let r = i ; while ( l != r ) { if ( arr [ l ] + arr [ r ] == x ) return true ; if ( arr [ l ] + arr [ r ] < x ) l = ( l + 1 ) % n ; else r = ( n + r - 1 ) % n ; } return false ; }
function arrayEvenAndOdd ( arr , n ) { let i = - 1 , j = 0 ; let t ; while ( j != n ) { if ( arr [ j ] % 2 == 0 ) { i ++ ; let temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; } j ++ ; } for ( let i = 0 ; i < n ; i ++ ) document . write ( arr [ i ] + " " ) ; }
function getPairs ( a ) { let count = 0 ; for ( let i = 0 ; i < a . length ; i ++ ) { for ( let j = 0 ; j < a . length ; j ++ ) { if ( a [ i ] < a [ j ] ) count ++ ; } } return count ; }
function AlternateRearrange ( arr , n ) { arr . sort ( ( a , b ) => a - b ) ; for ( var i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 == 0 ) v1 . push ( arr [ i ] ) ; else v2 . push ( arr [ i ] ) ; var index = 0 , i = 0 , j = 0 ; var flag = false ; if ( arr [ 0 ] % 2 == 0 ) flag = true ; while ( index < n ) { if ( flag == true ) { arr [ index ++ ] = v1 [ i ++ ] ; flag = ! flag ; } else { arr [ index ++ ] = v2 [ j ++ ] ; flag = ! flag ; } } for ( i = 0 ; i < n ; i ++ ) document . write ( arr [ i ] + " " ) ; }
function findMinimumCost ( n , x , y ) { let dp = new Array ( n + 1 ) ; dp [ 1 ] = x ; for ( let i = 2 ; i <= n ; i ++ ) { if ( ( i & 1 ) != 0 ) { dp [ i ] = Math . min ( dp [ i - 1 ] + x , dp [ parseInt ( ( i + 1 ) / 2 , 10 ) ] + y + x ) ; } else { dp [ i ] = Math . min ( dp [ i - 1 ] + x , dp [ parseInt ( i / 2 , 10 ) ] + y ) ; } } return dp [ n ] ; }
function Nth_of_AP ( a , d , N ) { return ( a + ( N - 1 ) * d ) ; }
function largestPalinSub ( s ) { let res = " " ; let mx = s [ 0 ] ; for ( let i = 1 ; i < s . length ; i ++ ) mx = String . fromCharCode ( Math . max ( mx . charCodeAt ( ) , s [ i ] . charCodeAt ( ) ) ) ; for ( let i = 0 ; i < s . length ; i ++ ) if ( s [ i ] == mx ) res += s [ i ] ; return res ; }
function countP ( n , k ) { if ( n == 0 k == 0 k > n ) return 0 ; if ( k == 1 k == n ) return 1 ; return ( k * countP ( n - 1 , k ) + countP ( n - 1 , k - 1 ) ) ; }
function dupLastIndex ( arr , n ) { if ( arr == null n <= 0 ) return ; for ( let i = n - 1 ; i > 0 ; i -- ) { if ( arr [ i ] == arr [ i - 1 ] ) { document . write ( " " + i + " " ) ; document . write ( " " + arr [ i ] + " " ) ; return ; } } document . write ( " " ) ; }
function Kroneckerproduct ( A , B ) { let C = new Array ( rowa * rowb ) for ( let i = 0 ; i < ( rowa * rowb ) ; i ++ ) { C [ i ] = new Array ( cola * colb ) ; for ( let j = 0 ; j < ( cola * colb ) ; j ++ ) { C [ i ] [ j ] = 0 ; } } for ( let i = 0 ; i < rowa ; i ++ ) { for ( let k = 0 ; k < rowb ; k ++ ) { for ( let j = 0 ; j < cola ; j ++ ) { for ( let l = 0 ; l < colb ; l ++ ) { C [ i + l + 1 ] [ j + k + 1 ] = A [ i ] [ j ] * B [ k ] [ l ] ; document . write ( C [ i + l + 1 ] [ j + k + 1 ] + " " ) ; } } document . write ( " " ) ; } } }
function isPentagonal ( N ) { var i = 1 , M ; do { M = ( 3 * i * i - i ) / 2 ; i += 1 ; } while ( M < N ) ; return ( M == N ) ; }
function rearrange ( arr , n ) { let max_idx = n - 1 , min_idx = 0 ; let max_elem = arr [ n - 1 ] + 1 ; for ( let i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { arr [ i ] += ( arr [ max_idx ] % max_elem ) * max_elem ; max_idx -- ; } else { arr [ i ] += ( arr [ min_idx ] % max_elem ) * max_elem ; min_idx ++ ; } } for ( let i = 0 ; i < n ; i ++ ) arr [ i ] = Math . floor ( arr [ i ] / max_elem ) ; }
function getTotalXorOfSubarrayXors ( arr , N ) { let res = 0 ; for ( let i = 0 ; i < N ; i ++ ) for ( let j = i ; j < N ; j ++ ) for ( let k = i ; k <= j ; k ++ ) res = res ^ arr [ k ] ; return res ; }
function no_of_digit ( a , b ) { return ( Math . round ( ( b * Math . log10 ( a ) ) + 1 ) ) ; }
function minSum ( arr , n ) { let sum = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] ) { let j = i ; while ( j < n && arr [ j ] <= arr [ j - 1 ] ) { arr [ j ] = arr [ j ] + 1 ; j ++ ; } } sum = sum + arr [ i ] ; } return sum ; }
function replace_elements ( arr , n ) { let pos = 0 ; for ( let i = 0 ; i < n ; i ++ ) { arr [ pos ++ ] = arr [ i ] ; while ( pos > 1 && arr [ pos - 2 ] == arr [ pos - 1 ] ) { pos -- ; arr [ pos - 1 ] ++ ; } } for ( let i = 0 ; i < pos ; i ++ ) document . write ( arr [ i ] + " " ) ; }
function sum_series ( n ) { let nSquare = n * n ; return nSquare * ( nSquare - 1 ) / 4 ; }
function countDivisors ( n ) { let count = 0 ; for ( let i = 1 ; i <= Math . sqrt ( n ) + 1 ; i ++ ) { if ( n % i == 0 ) count += ( Math . floor ( n / i ) == i ) ? 1 : 2 ; } if ( count % 2 == 0 ) document . write ( " " + " " ) ; else document . write ( " " + " " ) ; }
function floorSqrt ( x ) { if ( x == 0 x == 1 ) return x ; let i = 1 ; let result = 1 ; while ( result <= x ) { i ++ ; result = i * i ; } return i - 1 ; }
function isConvertible ( str1 , str2 , k ) { if ( ( str1 . length + str2 . length ) < k ) return true ; var commonLength = 0 ; for ( var i = 0 ; i < Math . min ( str1 . length , str2 . length ) ; i ++ ) { if ( str1 [ i ] == str2 [ i ] ) commonLength ++ ; else break ; } if ( ( k - str1 . length - str2 . length + 2 * commonLength ) % 2 == 0 ) return true ; return false ; }
function checksum ( n ) { if ( n % 3 == 0 ) document . write ( n / 3 - 1 + " " + n / 3 + " " + ( n / 3 + 1 ) ) ; else document . write ( " " ) ; }
function evenbittogglenumber ( n ) { let res = 0 , count = 0 ; for ( let temp = n ; temp > 0 ; temp >>= 1 ) { if ( count % 2 == 0 ) res |= ( 1 << count ) ; count ++ ; } return n ^ res ; }
function partitions ( n ) { var p = Array ( n + 1 ) . fill ( 0 ) ; p [ 0 ] = 1 ; for ( i = 1 ; i <= n ; ++ i ) { var k = 1 ; while ( ( k * ( 3 * k - 1 ) ) / 2 <= i ) { p [ i ] += ( k % 2 != 0 ? 1 : - 1 ) * p [ i - ( k * ( 3 * k - 1 ) ) / 2 ] ; if ( k > 0 ) { k *= - 1 ; } else { k = 1 - k ; } } } return p [ n ] ; }
function findEdges ( s1 , s2 , s3 ) { let a = Math . sqrt ( s1 * s2 / s3 ) ; let b = Math . sqrt ( s3 * s1 / s2 ) ; let c = Math . sqrt ( s3 * s2 / s1 ) ; let sum = a + b + c ; return 4 * sum ; }
function getSingle ( arr , n ) { let ones = 0 , twos = 0 ; let common_bit_mask ; for ( let i = 0 ; i < n ; i ++ ) { twos = twos | ( ones & arr [ i ] ) ; ones = ones ^ arr [ i ] ; common_bit_mask = ~ ( ones & twos ) ; ones &= common_bit_mask ; twos &= common_bit_mask ; } return ones ; }
function calculateSum ( n ) { return ( Math . pow ( 2 , n + 1 ) + n - 2 ) ; }
function countPairs ( arr , n ) { var result = 0 ; for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { var product = arr [ i ] * arr [ j ] ; for ( k = 0 ; k < n ; k ++ ) { if ( arr [ k ] == product ) { result ++ ; break ; } } } } return result ; }
function minimumSets ( s , y ) { let cnt = 0 ; let num = 0 ; let l = s . length ; let f = false ; for ( let i = 0 ; i < l ; i ++ ) { num = num * 10 + ( s [ i ] - ' ' ) ; if ( num <= y ) f = true ; { if ( f ) cnt += 1 ; num = s [ i ] - ' ' ; f = false ; if ( num <= y ) f = true ; else num = 0 ; } } if ( f == true ) cnt += 1 ; return cnt ; }
function count9s ( number ) { let count = 0 ; let n = ( number . length ) ; for ( let i = 0 ; i < n ; i ++ ) { let sum = number [ i ] - ' ' ; if ( number [ i ] == ' ' ) { count ++ ; } for ( let j = i + 1 ; j < n ; j ++ ) { sum = ( sum + number [ j ] - ' ' ) % 9 ; if ( sum == 0 ) { count ++ ; } } } return count ; }
function findCount ( d ) { return 9 * ( ( Math . pow ( 10 , d - 1 ) ) - ( Math . pow ( 9 , d - 1 ) ) ) ; }
function maxSumLCM ( n ) { for ( let i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { max_sum += i ; if ( n / i != i ) max_sum += ( n / i ) ; } } return max_sum ; }
function surface_area_octahedron ( side ) { return ( 2 * ( Math . sqrt ( 3 ) ) * ( side * side ) ) ; }
function isMultipleOf4 ( n ) { if ( n == 1 ) return false ; let XOR = 0 ; for ( let i = 1 ; i <= n ; i ++ ) XOR = XOR ^ i ; return ( XOR == n ) ; }
function nextPowerOf2 ( n ) { var count = 0 ; if ( n && ! ( n & ( n - 1 ) ) ) return n ; while ( n != 0 ) { n >>= 1 ; count += 1 ; } return 1 << count ; }
function LCIS ( arr1 , n , arr2 , m ) { let table = [ ] ; for ( let j = 0 ; j < m ; j ++ ) table [ j ] = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let current = 0 ; for ( let j = 0 ; j < m ; j ++ ) { if ( arr1 [ i ] == arr2 [ j ] ) if ( current + 1 > table [ j ] ) table [ j ] = current + 1 ; if ( arr1 [ i ] > arr2 [ j ] ) if ( table [ j ] > current ) current = table [ j ] ; } } let result = 0 ; for ( let i = 0 ; i < m ; i ++ ) if ( table [ i ] > result ) result = table [ i ] ; return result ; }
function sumOfTheSeries ( n ) { return ( n * ( n + 1 ) / 2 ) * ( 2 * n + 1 ) / 3 ; }
function count_minimum_operations ( n ) { let count = 0 ; while ( n > 1 ) { if ( n % 3 == 0 ) n /= 3 ; else if ( n % 3 == 1 ) n -- ; else { if ( n == 2 ) n -- ; else n ++ ; } count ++ ; } return count ; }
function countOfMultiples ( n ) { return ( parseInt ( n / 3 , 10 ) + parseInt ( n / 5 , 10 ) - parseInt ( n / 15 , 10 ) ) ; }
function findLarger ( arr , n ) { arr . sort ( ) ; for ( let i = n - 1 ; i >= n / 2 ; i -- ) document . write ( arr [ i ] + " " ) ; }
function Preprocess ( A , B ) { let n = A . length ; let ans = 0 ; for ( let i = 0 ; i < n / 2 ; i ++ ) { let mp = new Map ( ) ; if ( mp . has ( A [ i ] ) ) mp . set ( A [ i ] , mp . get ( A [ i ] ) + 1 ) ; else mp . set ( A [ i ] , 1 ) ; if ( mp . has ( A [ n - i - 1 ] ) ) mp . set ( A [ n - i - 1 ] , mp . get ( A [ n - i - 1 ] ) + 1 ) ; else mp . set ( A [ n - i - 1 ] , 1 ) ; if ( mp . has ( B [ i ] ) ) mp . set ( B [ i ] , mp . get ( B [ i ] ) + 1 ) ; else mp . set ( B [ i ] , 1 ) ; if ( mp . has ( B [ n - i - 1 ] ) ) mp . set ( B [ n - i - 1 ] , mp . get ( B [ n - i - 1 ] ) + 1 ) ; else mp . set ( B [ n - i - 1 ] , 1 ) ; let sz = mp . size ; if ( sz == 4 ) ans += 2 ; else if ( sz == 3 ) ans += 1 + ( A [ i ] == A [ n - i - 1 ] ? 1 : 0 ) ; else if ( sz == 2 ) ans += mp . get ( A [ i ] ) != 2 ? 1 : 0 ; } if ( n % 2 == 1 && A [ Math . floor ( n / 2 ) ] != B [ Math . floor ( n / 2 ) ] ) ans ++ ; return ans ; }
function countPairs ( arr , n ) { let ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] == arr [ j ] ) ans ++ ; return ans ; }
function precomputation ( arr , n ) { for ( var i = 1 ; i < max_Element ; i ++ ) for ( var j = i ; j < max_Element ; j += i ) sum1 [ j ] += i ; for ( var i = 1 ; i < max_Element ; i ++ ) for ( var j = i ; j < max_Element ; j += i ) sum2 [ j ] += ( sum1 [ j ] - i ) * i ; for ( var i = 1 ; i < max_Element ; i ++ ) sum2 [ i ] /= 2 ; for ( var i = 1 ; i < max_Element ; i ++ ) for ( var j = i ; j < max_Element ; j += i ) sum3 [ j ] += i * ( sum2 [ j ] - i * ( sum1 [ j ] - i ) ) ; for ( var i = 1 ; i < max_Element ; i ++ ) sum3 [ i ] /= 3 ; for ( var i = 0 ; i < n ; i ++ ) document . write ( sum3 [ arr [ i ] ] + " " ) ; }
function findpair ( l , r ) { let c = 0 ; for ( let i = l ; i <= r ; i ++ ) { for ( let j = i + 1 ; j <= r ; j ++ ) { if ( j % i == 0 && j != i ) { document . write ( i + " " + j + " " ) ; c = 1 ; break ; } } if ( c == 1 ) break ; } }
function findLUSlength ( a , b ) { if ( a === b ) return 0 ; return Math . max ( a . length , b . length ) ; }
function gouldSequence ( n ) { for ( var row_num = 1 ; row_num <= n ; row_num ++ ) { var count = 1 ; var c = 1 ; for ( var i = 1 ; i <= row_num ; i ++ ) { c = c * ( row_num - i ) / i ; if ( c % 2 == 1 ) count ++ ; } document . write ( count + " " ) ; } }
function asPowerSum ( w , m ) { while ( m > 0 ) { if ( ( m - 1 ) % w == 0 ) m = ( m - 1 ) / w ; else if ( ( m + 1 ) % w == 0 ) m = ( m + 1 ) / w ; else if ( m % w == 0 ) m = m / w ; else } return ( m == 0 ) ; }
function largestPower ( n , p ) { let x = 0 ; while ( n ) { n = parseInt ( n / p ) ; x += n ; } return Math . floor ( x ) ; }
function circlearea ( l , b ) { if ( l < 0 b < 0 ) return - 1 ; if ( l < b ) return ( 3.14 * Math . pow ( l / 2 , 2 ) ) ; else return ( 3.14 * Math . pow ( b / 2 , 2 ) ) ; }
function centeredHexagonalNumber ( n ) { return 3 * n * ( n - 1 ) + 1 ; }
function countTripletsLessThanL ( n , L , arr ) { arr . sort ( ) ; var ways = 0 ; for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { for ( k = j + 1 ; k < n ; k ++ ) { var mostDistantDistance = arr [ k ] - arr [ i ] ; if ( mostDistantDistance <= L ) { ways ++ ; } } } } return ways ; }
function Squares ( n , m , a ) { return parseInt ( ( ( m + a - 1 ) / a ) ) * parseInt ( ( ( n + a - 1 ) / a ) ) ; }
function minInsertions ( H , n , K ) { var inser = 0 ; for ( var i = 1 ; i < n ; ++ i ) { var diff = Math . abs ( H [ i ] - H [ i - 1 ] ) ; if ( diff <= K ) continue ; else inser += Math . ceil ( diff / K ) - 1 ; } return inser ; }
function findVolume ( a ) { if ( a < 0 ) return - 1 ; var r = a / 2 ; var h = a ; var V = ( 3.14 * Math . pow ( r , 2 ) * h ) ; return V ; }
function power ( n ) { if ( n == 1 ) return 2 ; return 2 * power ( n - 1 ) ; }
function oddbitsetnumber ( n ) { let count = 0 ; let res = 0 ; for ( let temp = n ; temp > 0 ; temp >>= 1 ) { if ( count % 2 == 0 ) res |= ( 1 << count ) ; count ++ ; } return ( n res ) ; }
function octaside ( a ) { if ( a < 0 ) return - 1 ; var s = a / ( Math . sqrt ( 2 ) + 1 ) ; return s ; }
function productOfSingelDgt ( n ) { if ( n >= 0 && n <= 9 ) return true ; var prime = [ 2 , 3 , 5 , 7 ] ; for ( i = 0 ; i < SIZE && n > 1 ; i ++ ) while ( n % prime [ i ] == 0 ) n = n / prime [ i ] ; return ( n == 1 ) ; }
function seriesSum ( n ) { let i = 1 ; let res = 0.0 ; let sign = true ; while ( n > 0 ) { n -- ; if ( sign ) { sign = ! sign ; res = res + ++ i / ++ i ; } else { sign = ! sign ; res = res - ++ i / ++ i ; } } return res ; }
function countarray ( n , k , x ) { let dp = [ ] ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; for ( let i = 2 ; i < n ; i ++ ) dp [ i ] = ( k - 2 ) * dp [ i - 1 ] + ( k - 1 ) * dp [ i - 2 ] ; return ( x == 1 ? ( k - 1 ) * dp [ n - 2 ] : dp [ n - 1 ] ) ; }
function intToRoman ( num ) { let m = [ " " , " " , " " , " " ] ; let c = [ " " , " " , " " , " " , " " , " " , " " , " " , " " , " " ] ; let x = [ " " , " " , " " , " " , " " , " " , " " , " " , " " , " " ] ; let i = [ " " , " " , " " , " " , " " , " " , " " , " " , " " , " " ] ; let thousands = m [ Math . floor ( num / 1000 ) ] ; let hundereds = c [ Math . floor ( ( num % 1000 ) / 100 ) ] ; let tens = x [ Math . floor ( ( num % 100 ) / 10 ) ] ; let ones = i [ num % 10 ] ; let ans = thousands + hundereds + tens + ones ; return ans ; }
function fnMod ( n ) { var rem = n % 4 ; if ( rem == 0 rem == 3 ) return 0 ; else if ( rem == 1 rem == 2 ) return 1 ; return 0 ; }
function alternateFib ( n ) { if ( n < 0 ) return ; var f1 = 0 ; var f2 = 1 ; document . write ( f1 + " " ) ; for ( i = 2 ; i <= n ; i ++ ) { var f3 = f2 + f1 ; if ( i % 2 == 0 ) document . write ( f3 + " " ) ; f1 = f2 ; f2 = f3 ; } }
function convert ( s ) { var n = s . length ; var s1 = " " ; s1 = s1 + s . charAt ( 0 ) . toLowerCase ( ) ; for ( i = 1 ; i < n ; i ++ ) { if ( s . charAt ( i ) == ' ' && i < n ) { s1 = s1 + " " + s . charAt ( i + 1 ) . toLowerCase ( ) ; i ++ ; } else s1 = s1 + s . charAt ( i ) . toUpperCase ( ) ; } return s1 ; }
function noOfTriples ( arr , n ) { arr . sort ( ) ; let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) if ( arr [ i ] == arr [ 2 ] ) count ++ ; if ( arr [ 0 ] == arr [ 2 ] ) return ( count - 2 ) * ( count - 1 ) * ( count ) / 6 ; else if ( arr [ 1 ] == arr [ 2 ] ) return ( count - 1 ) * ( count ) / 2 ; return count ; }
function findArea ( d ) { return ( d * d ) / 2 ; }
function breakEvenPoint ( exp , S , M ) { var earn = S - M ; var res = Math . ceil ( exp / earn ) ; return res ; }
function findSteps ( n , m , a ) { var cur = 1 ; var steps = 0 ; for ( var i = 0 ; i < m ; i ++ ) { if ( a [ i ] >= cur ) steps += ( a [ i ] - cur ) ; else steps += ( n - cur + a [ i ] ) ; cur = a [ i ] ; } return steps ; }
function NthTerm ( n ) { let x = ( 3 * n * n ) % 1000000009 ; return ( x - n + 1000000009 ) % 1000000009 ; }
function areEqual ( arr1 , arr2 ) { let n = arr1 . length ; let m = arr2 . length ; if ( n != m ) return false ; arr1 . sort ( ) ; arr2 . sort ( ) ; for ( let i = 0 ; i < n ; i ++ ) if ( arr1 [ i ] != arr2 [ i ] ) return false ; return true ; }
function check ( n , marks ) { let x = Math . max ( ... marks ) ; let bonus = 100 - x ; let c = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( marks [ i ] + bonus >= 50 ) c += 1 ; } return c ; }
function fourthPowerSum ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) sum = sum + ( i * i * i * i ) ; return sum ; }
function procal ( n ) { return ( 3.0 * n ) / ( 4.0 * ( n * n ) - 1 ) ; }
function checkEVENodd ( arr , n , l , r ) { if ( arr [ r ] == 1 ) document . write ( " " ) ; else document . write ( " " ) ; }
function solve ( a , n ) { let max1 = Number . MIN_VALUE ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { if ( Math . abs ( a [ i ] - a [ j ] ) > max1 ) { max1 = Math . abs ( a [ i ] - a [ j ] ) ; } } } return max1 ; }
function ifPossible ( arr , n ) { let copy = arr ; copy . sort ( ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( ! ( arr [ i ] == copy [ i ] ) && ! ( arr [ n - 1 - i ] == copy [ i ] ) ) return false ; } return true ; }
function solution ( a , b , n ) { for ( let i = 0 ; i * a <= n ; i ++ ) { if ( ( n - ( i * a ) ) % b == 0 ) { document . write ( " " + i + " " + ( n - ( i * a ) ) / b ) ; return ; } } document . write ( " " ) ; }
function countPairs ( a , n , k ) { var res = 0 ; for ( var i = 0 ; i < n ; i ++ ) for ( var j = i + 1 ; j < n ; j ++ ) if ( Math . abs ( a [ j ] - a [ i ] ) < k ) res ++ ; return res ; }
function getSingle ( arr , n ) { let result = 0 ; let x , sum ; for ( let i = 0 ; i < INT_SIZE ; i ++ ) { sum = 0 ; x = ( 1 << i ) ; for ( let j = 0 ; j < n ; j ++ ) { if ( arr [ j ] & x ) sum ++ ; } if ( ( sum % 3 ) != 0 ) result |= x ; } return result ; }
function FirstAndLast ( str ) { var ch = str . split ( ' ' ) ; for ( var i = 0 ; i < ch . length ; i ++ ) { var k = i ; while ( i < ch . length && ch [ i ] != ' ' ) i ++ ; ch [ k ] = String . fromCharCode ( ch [ k ] >= ' ' && ch [ k ] <= ' ' ? ( ch [ k ] . charCodeAt ( 0 ) - 32 ) : ch [ k ] . charCodeAt ( 0 ) ) ; ch [ i - 1 ] = String . fromCharCode ( ch [ i - 1 ] >= ' ' && ch [ i - 1 ] <= ' ' ? ( ch [ i - 1 ] . charCodeAt ( 0 ) - 32 ) : ch [ i - 1 ] . charCodeAt ( 0 ) ) ; } return ch . join ( ' ' ) ; }
function countPairsWithDiffK ( arr , n , k ) { let count = 0 ; arr . sort ( ) ; let l = 0 ; let r = 0 ; while ( r < n ) { if ( arr [ r ] - arr [ l ] == k ) { count ++ ; l ++ ; r ++ ; } else if ( arr [ r ] - arr [ l ] > k ) l ++ ; else r ++ ; } return count ; }
function find ( n , k ) { if ( n + 1 >= k ) return ( k - 1 ) ; else return ( 2 * n + 1 - k ) ; }
function check ( str ) { let n = str . length ; if ( ( str [ n - 1 ] - ' ' ) % 2 != 0 ) return false ; let digitSum = 0 ; for ( let i = 0 ; i < n ; i ++ ) digitSum += ( str [ i ] - ' ' ) ; return ( digitSum % 3 == 0 ) ; }
function motzkin ( n ) { if ( n == 0 n == 1 ) return 1 ; return ( ( 2 * n + 1 ) * motzkin ( n - 1 ) + ( 3 * n - 3 ) * motzkin ( n - 2 ) ) / ( n + 2 ) ; }
function Check_is_possible ( l , r , k ) { var div_count = ( r / k ) - ( l / k ) ; if ( l % k == 0 ) { div_count ++ ; } return ( div_count > 1 ) ; } var l = 30 , r = 70 , k = 10 ; if ( Check_is_possible ( l , r , k ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function Nonagonal ( n ) { for ( let i = 1 ; i <= n ; i ++ ) { document . write ( parseInt ( i * ( 7 * i - 5 ) / 2 ) + " " ) ; } }
function averageValue ( s ) { let sum_char = 0 ; for ( let i = 0 ; i < s . length ; i ++ ) { sum_char += ( s [ i ] ) . charCodeAt ( 0 ) ; } return Math . floor ( sum_char / s . length ) ; }
function check ( s ) { let n = s . length ; for ( let i = 0 ; i < n - 1 ; i ++ ) { if ( s [ i ] > s [ i + 1 ] ) return true ; } return false ; }
function minIndex ( arr , n , pos ) { var num = arr [ pos ] ; var i = pos - 1 ; while ( i >= 0 ) { if ( arr [ i ] != num ) break ; i -- ; } return i + 1 ; }
function toggleLastMBits ( n , m ) { var num = ( 1 << m ) - 1 ; return ( n ^ num ) ; }
function printGolomb ( n ) { let dp = Array ( n + 1 ) . fill ( 0 ) ; dp [ 1 ] = 1 ; document . write ( dp [ 1 ] + " " ) ; for ( i = 2 ; i <= n ; i ++ ) { dp [ i ] = 1 + dp [ i - dp [ dp [ i - 1 ] ] ] ; document . write ( dp [ i ] + " " ) ; } }
function calcScore ( str ) { var score = 0 ; var len = str . length ; for ( var i = 0 ; i < len ; ) { var chunkSize = 1 ; var currentChar = str [ i ++ ] ; while ( i < len && str [ i ] == currentChar ) { chunkSize ++ ; i ++ ; } if ( currentChar == ' ' ) score += Math . pow ( chunkSize , 2 ) ; else score -= Math . pow ( chunkSize , 2 ) ; } return score ; }
function getModulo ( n , d ) { return ( n & ( d - 1 ) ) ; }
function bankNotes ( A , B , S , N ) { let numerator = S - ( B * N ) ; let denominator = A - B ; if ( numerator % denominator == 0 ) return ( Math . floor ( numerator / denominator ) ) ; return - 1 ; }
function sumOfSeries ( n ) { return ( n * ( 2 * n - 1 ) * ( 2 * n + 1 ) ) / 3 ; }
function isNumber ( s ) { for ( let i = 0 ; i < s . length ; i ++ ) if ( s [ i ] < ' ' s [ i ] > ' ' ) return false ; return true ; }
function solve ( s1 , s2 ) { let flag1 = 0 , flag2 = 0 ; if ( s1 . length != s2 . length ) return false ; let l = s1 . length ; for ( let i = 0 ; i < l ; i ++ ) { if ( s1 [ i ] == ' ' ) flag1 = 1 ; if ( s2 [ i ] == ' ' ) flag2 = 1 ; if ( flag1 && flag2 ) return true ; } if ( ! flag1 && ! flag2 ) return true ; return false ; }
function sum ( a , b ) { var sum = 0 ; for ( var i = 1 ; i <= Math . min ( a , b ) ; i ++ ) if ( a % i == 0 && b % i == 0 ) sum += i ; return sum ; }
function checkPalindrome ( str ) { let n = str . length ; let count = 0 ; for ( let i = 0 ; i < parseInt ( n / 2 , 10 ) ; ++ i ) if ( str [ i ] != str [ n - i - 1 ] ) ++ count ; return ( count <= 1 ) ; }
function avgOfFirstN ( n ) { return ( 1 + n ) / 2 ; }
function area ( a , b , c ) { var d = Math . abs ( ( c * c ) / ( 2 * a * b ) ) ; return d ; }
function getTotalNumberOfSequences ( m , n ) { if ( m < n ) return 0 ; if ( n == 0 ) return 1 ; return getTotalNumberOfSequences ( m - 1 , n ) + getTotalNumberOfSequences ( m / 2 , n - 1 ) ; }
function evenFib ( n ) { if ( n < 1 ) return n ; if ( n == 1 ) return 2 ; return ( ( 4 * evenFib ( n - 1 ) ) + evenFib ( n - 2 ) ) ; }
function isPowerOfTwo ( x ) { return x != 0 && ( ( x & ( x - 1 ) ) == 0 ) ; }
function possibleStrings ( n , r , b , g ) { let fact = new Array ( n + 1 ) ; fact [ 0 ] = 1 ; for ( let i = 1 ; i <= n ; i ++ ) fact [ i ] = fact [ i - 1 ] * i ; let left = n - ( r + g + b ) ; let sum = 0 ; for ( let i = 0 ; i <= left ; i ++ ) { for ( let j = 0 ; j <= left - i ; j ++ ) { let k = left - ( i + j ) ; sum = sum + fact [ n ] / ( fact [ i + r ] * fact [ j + b ] * fact [ k + g ] ) ; } } return sum ; }
function sumProductDifference ( a , b , c , d , e ) { var rootSum = ( - 1 * b ) / a ; var rootProduct = e / a ; return Math . abs ( rootSum - rootProduct ) ; }
function cyl ( R ) { if ( R < 0 ) return - 1 ; var V = ( ( 2 * 3.14 * Math . pow ( R , 3 ) ) / ( 3 * Math . sqrt ( 3 ) ) ) ; return V ; }
function findSum ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) for ( let j = i ; j <= n ; j ++ ) sum = sum + i * j ; return sum ; }
function calcDeterminant ( arr ) { let determinant = 0 ; for ( let i = 0 ; i < N ; i ++ ) { determinant += Math . pow ( arr [ i ] , 3 ) ; } determinant -= 3 * arr [ 0 ] * arr [ 1 ] * arr [ 2 ] ; return determinant ; }
function countInRange ( arr , n , x , y ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] >= x && arr [ i ] <= y ) count ++ ; } return count ; }
function countPaths ( m , n ) { let dp = new Array ( m + 1 ) ; for ( let i = 0 ; i <= m ; i ++ ) { dp [ i ] = new Array ( n + 1 ) ; for ( let j = 0 ; j <= n ; j ++ ) { dp [ i ] [ j ] = 0 ; } } for ( let i = 1 ; i <= m ; i ++ ) { for ( let j = 1 ; j <= n ; j ++ ) { if ( i == 1 j == 1 ) dp [ i ] [ j ] = 1 ; else dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] ; } } return dp [ m ] [ n ] ; }
function pairStar ( input , i ) { output = output + input [ i ] ; if ( i == input . length - 1 ) return ; if ( input [ i ] == input [ i + 1 ] ) output = output + ' ' ; pairStar ( input , i + 1 ) ; }
function minNum ( arr , n ) { let odd = false ; for ( let i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 != 0 ) odd = ! odd ; if ( odd ) return 1 ; return 2 ; }
function is_possible ( s ) { let l = s . length ; let one = 0 , zero = 0 ; for ( let i = 0 ; i < l ; i ++ ) { if ( s [ i ] == ' ' ) zero ++ ; else one ++ ; } if ( l % 2 == 0 ) return ( one == zero ) ; else return ( Math . abs ( one - zero ) == 1 ) ; }
function odd_even ( arr , n ) { var odd_indexes = [ ] ; var even_indexes = [ ] ; for ( var i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) odd_indexes . push ( arr [ i ] ) ; else even_indexes . push ( arr [ i ] ) ; } odd_indexes . sort ( ) ; even_indexes . sort ( ) ; for ( var i = 0 ; i < odd_indexes . length ; i ++ ) document . write ( odd_indexes [ i ] + " " ) ; for ( var i = 0 ; i < even_indexes . length ; i ++ ) document . write ( even_indexes [ i ] + " " ) ; }
function sum ( n ) { if ( n == 1 ) return 1 ; else return ( Math . pow ( n , n ) + sum ( n - 1 ) ) ; }
function printPossible ( a , b , c ) { if ( ( a + b + c ) % 2 != 0 a + b < c ) document . write ( " " ) ; else document . write ( " " ) ; }
function printLastChar ( str ) { str = str + " " ; for ( var i = 1 ; i < str . length ; i ++ ) { if ( str [ i ] === " " ) document . write ( str [ i - 1 ] + " " ) ; } }
function maxProduct ( arr , n ) { if ( n < 3 ) { return - 1 ; } arr . sort ( ) ; return Math . max ( arr [ 0 ] * arr [ 1 ] * arr [ n - 1 ] , arr [ n - 1 ] * arr [ n - 2 ] * arr [ n - 3 ] ) ; } var arr = [ - 10 , - 3 , 5 , 6 , - 20 ] ; var n = arr . length ; var max = maxProduct ( arr , n ) ; if ( max == - 1 ) { document . write ( " " ) ; } else { document . write ( " " + max ) ; }
function maxSum ( arr , n ) { let cum_sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) cum_sum += arr [ i ] ; let curr_val = 0 ; for ( let i = 0 ; i < n ; i ++ ) curr_val += i * arr [ i ] ; let res = curr_val ; for ( let i = 1 ; i < n ; i ++ ) { let next_val = curr_val - ( cum_sum - arr [ i - 1 ] ) + arr [ i - 1 ] * ( n - 1 ) ; curr_val = next_val ; res = Math . max ( res , next_val ) ; } return res ; }
function minOps ( arr , n , k ) { var max = arr [ 0 ] ; for ( var i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; } var res = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( ( max - arr [ i ] ) % k != 0 ) return - 1 ; else res += ( max - arr [ i ] ) / k ; } return res ; }
function findTriangle ( a , n ) { let b = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { b [ i ] = 0 ; } for ( let i = 0 ; i < n ; i ++ ) b [ i ] = a [ i ] * a [ i ] ; a . sort ( function ( i , j ) { return i - j ; } ) ; b . sort ( function ( i , j ) { return i - j ; } ) ; let x = 0 , y = 0 , z = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let p = i + 1 ; let q = i + 1 ; for ( let j = i + 1 ; j < n ; j ++ ) { while ( p < n - 1 && b [ i ] + b [ j ] >= b [ p + 1 ] ) p ++ ; q = Math . max ( q , p ) ; while ( q < n - 1 && a [ i ] + a [ j ] > a [ q + 1 ] ) q ++ ; if ( b [ i ] + b [ j ] == b [ p ] ) { x += Math . max ( p - j - 1 , 0 ) ; y ++ ; z += q - p ; } else { x += Math . max ( p - j , 0 ) ; z += q - p ; } } } document . write ( " " + x + " " ) ; document . write ( " " + y + " " ) ; document . write ( " " + z + " " ) ; }
function Nth_Term ( n ) { return ( 2 * Math . pow ( n , 3 ) - 3 * Math . pow ( n , 2 ) + n + 6 ) / 6 ; }
function myXOR ( x , y ) { return ( x y ) & ( ~ x ~ y ) ; }
function isPrime ( n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( var i = 5 ; i * i <= n ; i = i + 6 ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) { return false ; } } return true ; } var n = 17 ; if ( isPrime ( n ) && ( n % 16 == 1 ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function rev ( n , temp ) { if ( n == 0 ) return temp ; temp = ( temp * 10 ) + ( n % 10 ) ; return rev ( Math . floor ( n / 10 ) , temp ) ; }
function findGreater ( x , y ) { if ( x > y ) { return false ; } else { return true ; } }
function evenNumSubstring ( str ) { let len = str . length ; let count = 0 ; for ( let i = 0 ; i < len ; i ++ ) { let temp = str [ i ] - ' ' ; if ( temp % 2 == 0 ) count += ( i + 1 ) ; } return count ; }
function minValue ( A , B , n ) { A . sort ( ) ; B . sort ( ) ; let result = 0 ; for ( let i = 0 ; i < n ; i ++ ) result += ( A [ i ] * B [ n - i - 1 ] ) ; return result ; }
function minimumChar ( S1 , S2 ) { let n = S1 . length ; let m = S2 . length ; let ans = Number . MAX_VALUE ; for ( let i = 0 ; i < m - n + 1 ; i ++ ) { let minRemovedChar = 0 ; for ( let j = 0 ; j < n ; j ++ ) { if ( S1 [ j ] != S2 [ i + j ] ) { minRemovedChar ++ ; } } ans = Math . min ( minRemovedChar , ans ) ; } return ans ; }
function check ( n ) { return 1162261467 % n == 0 ; }
function squareArea ( l , b , h ) { if ( l < 0 b < 0 h < 0 ) return - 1 ; var a = ( l * b ) / ( l + b ) ; return a * a ; }
function findSum ( n ) { let multiTerms = n * ( n + 1 ) / 2 ; let sum = multiTerms ; for ( let i = 2 ; i <= n ; i ++ ) { multiTerms = multiTerms - ( i - 1 ) ; sum = sum + multiTerms * i ; } return sum ; }
function area_of_tetrahedron ( side ) { return ( Math . sqrt ( 3 ) * ( side * side ) ) ; }
function Area ( a ) { if ( a < 0 ) return - 1 ; let h = 1.268 * a ; let A = 0.70477 * Math . pow ( h , 2 ) ; return A ; }
function countStrings ( s ) { let sum = 1 ; for ( let i = 0 ; i < s . length ; i ++ ) { if ( i % 2 == 0 && s [ i ] == ' ' ) sum *= 21 ; else if ( s [ i ] == ' ' ) sum *= 5 ; } return sum ; }
function pythagoreanTriplet ( n ) { for ( let i = 1 ; i <= n / 3 ; i ++ ) { for ( let j = i + 1 ; j <= n / 2 ; j ++ ) { let k = n - i - j ; if ( i * i + j * j == k * k ) { document . write ( i + " " + j + " " + k ) ; return ; } } } document . write ( " " ) ; }
function isComposite ( n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return false ; if ( n % 2 == 0 n % 3 == 0 ) return true ; for ( let i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return true ; return false ; }
function sum ( n ) { let sum = 0 ; let fact = 1 ; for ( let i = 1 ; i <= n ; i ++ ) { fact *= i ; sum += 1.0 / fact ; } return sum . toFixed ( 5 ) ; }
function calculateSum ( n ) { return n * ( n + 1 ) / 2 + Math . pow ( ( n * ( n + 1 ) / 2 ) , 2 ) ; }
function getNumToAdd ( arr , n ) { arr . sort ( function ( a , b ) { return a - b } ) ; var d = arr [ 1 ] - arr [ 0 ] ; var numToAdd = - 1 ; var numAdded = false ; for ( var i = 2 ; i < n ; i ++ ) { var diff = arr [ i ] - arr [ i - 1 ] ; if ( diff != d ) { if ( numAdded ) return - 1 ; if ( diff == 2 * d ) { numToAdd = arr [ i ] - d ; numAdded = true ; } else return - 1 ; } } if ( numToAdd == - 1 ) return ( arr [ n - 1 ] + d ) ; return numToAdd ; }
function rectanglearea ( r ) { if ( r < 0 ) return - 1 ; var a = r * r ; return a ; }
function minNumber ( a , n , x ) { a . sort ( ) ; let k ; for ( k = 0 ; a [ parseInt ( ( n - 1 ) / 2 , 10 ) ] != x ; k ++ ) { a [ n ++ ] = x ; a . sort ( ) ; } return k ; }
function findF_N ( n ) { var ans = 0 ; for ( var i = 0 ; i < n ; ++ i ) ans += ( i + 1 ) * ( n - i - 1 ) ; return ans ; }
function countChar ( str , x ) { let count = 0 ; let n = 10 ; for ( let i = 0 ; i < str . length ; i ++ ) if ( str [ i ] == x ) count ++ ; let repetitions = n / str . length ; count = count * repetitions ; for ( let i = 0 ; i < n % str . length ; i ++ ) { if ( str [ i ] == x ) count ++ ; } return count ; }
function countPS ( i , j ) { if ( i > j ) return 0 ; if ( dp [ i ] [ j ] != - 1 ) return dp [ i ] [ j ] ; if ( i == j ) return dp [ i ] [ j ] = 1 ; else if ( str [ i ] == str [ j ] ) return dp [ i ] [ j ] = countPS ( i + 1 , j ) + countPS ( i , j - 1 ) + 1 ; else return dp [ i ] [ j ] = countPS ( i + 1 , j ) + countPS ( i , j - 1 ) - countPS ( i + 1 , j - 1 ) ; }
function findRepeatingElement ( arr , low , high ) { if ( low > high ) return - 1 ; var mid = parseInt ( ( low + high ) / 2 ) ; if ( arr [ mid ] != mid + 1 ) { if ( mid > 0 && arr [ mid ] == arr [ mid - 1 ] ) return mid ; return findRepeatingElement ( arr , low , mid - 1 ) ; } return findRepeatingElement ( arr , mid + 1 , high ) ; }
function isPossible ( a , b , n , k ) { a . sort ( function ( a , b ) { return a - b } ) ; b . reverse ( ) ; for ( let i = 0 ; i < n ; i ++ ) if ( a [ i ] + b [ i ] < k ) return false ; return true ; }
function countSubStr ( str , n , x ) { let res = 0 , count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( str [ i ] == x ) { res += ( ( count + 1 ) * ( n - i ) ) ; count = 0 ; } else count ++ ; } return res ; }
function printOtherSides ( n ) { if ( n % 2 != 0 ) { if ( n == 1 ) document . write ( " " ) ; else { var b = ( n * n - 1 ) / 2 ; var c = ( n * n + 1 ) / 2 ; document . write ( " " + b + " " + c ) ; } } else { if ( n == 2 ) document . write ( " " ) ; else { var b = n * n / 4 - 1 ; var c = n * n / 4 + 1 ; document . write ( " " + b + " " + c ) ; } } }
function findMax ( arr ) { var row = 0 , i , j ; for ( i = 0 , j = N - 1 ; i < N ; i ++ ) { while ( arr [ i ] [ j ] == 1 && j >= 0 ) { row = i ; j -- ; } } document . write ( " " + ( row + 1 ) ) ; document . write ( " " + ( N - 1 - j ) ) ; }
function twoEggDrop ( k ) { return Math . ceil ( ( - 1.0 + Math . sqrt ( 1 + 8 * k ) ) / 2.0 ) ; }
function transpose ( A , B ) { var i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < M ; j ++ ) B [ i ] [ j ] = A [ j ] [ i ] ; } var A = [ [ 1 , 1 , 1 , 1 ] , [ 2 , 2 , 2 , 2 ] , [ 3 , 3 , 3 , 3 ] ] ; var B = Array ( N ) ; for ( i = 0 ; i < N ; i ++ ) B [ i ] = Array ( M ) . fill ( 0 ) ; transpose ( A , B ) ; document . write ( " " ) ; for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < M ; j ++ ) document . write ( B [ i ] [ j ] + " " ) ; document . write ( " " ) ; }
function largest ( arr , n ) { arr . sort ( ) ; return arr [ n - 1 ] ; }
function smallestSumSubarr ( arr , n ) { for ( let i = 0 ; i < n ; i ++ ) arr [ i ] = - arr [ i ] ; let sum_here = arr [ 0 ] , max_sum = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { sum_here = Math . max ( sum_here + arr [ i ] , arr [ i ] ) ; max_sum = Math . max ( max_sum , sum_here ) ; } return ( - 1 ) * max_sum ; }
function isMajority ( arr , n , x ) { let i , last_index = 0 ; last_index = ( n % 2 == 0 ) ? parseInt ( n / 2 , 10 ) : parseInt ( n / 2 , 10 ) + 1 ; for ( i = 0 ; i < last_index ; i ++ ) { if ( arr [ i ] == x && arr [ i + parseInt ( n / 2 , 10 ) ] == x ) return true ; } return false ; }
function SumDivisible ( n , k ) { let sum = 0 , position = 1 ; while ( n > 0 ) { if ( position % 2 == 1 ) sum += n % 10 ; n = Math . floor ( n / 10 ) ; position ++ ; } if ( sum % k == 0 ) return true ; return false ; }
function checkNumber ( N ) { let temp = N ; while ( temp > 0 ) { if ( temp % 1000 == 144 ) temp = parseInt ( temp / 1000 , 10 ) ; else if ( temp % 100 == 14 ) temp = parseInt ( temp / 100 , 10 ) ; else if ( temp % 10 == 1 ) temp = parseInt ( temp / 10 , 10 ) ; else { return " " ; } } return " " ; }
function foot ( a , b , c , d , x1 , y1 , z1 ) { var k = ( - a * x1 - b * y1 - c * z1 - d ) / ( a * a + b * b + c * c ) ; var x2 = a * k + x1 ; var y2 = b * k + y1 ; var z2 = c * k + z1 ; document . write ( " " + x2 . toFixed ( 1 ) + " " ) ; document . write ( " " + y2 . toFixed ( 1 ) + " " ) ; document . write ( " " + z2 . toFixed ( 1 ) + " " ) ; }
function term ( n ) { return parseInt ( n * ( n + 1 ) / 2 ) ; }
function calculateEnergy ( mat , n ) { let i_des , j_des , q ; let tot_energy = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { q = Math . floor ( mat [ i ] [ j ] / n ) ; i_des = q ; j_des = mat [ i ] [ j ] - ( n * q ) ; tot_energy += Math . abs ( i_des - i ) + Math . abs ( j_des - j ) ; } } return tot_energy ; }
function findDuplicate ( arr , n , k ) { arr . sort ( ) ; let i = 0 ; while ( i < n ) { let j , count = 1 ; for ( j = i + 1 ; j < n && arr [ j ] == arr [ i ] ; j ++ ) count ++ ; if ( count == k ) return arr [ i ] ; i = j ; } return - 1 ; }
function minDifferenceAmongMaxMin ( arr , N , K ) { arr . sort ( ( a , b ) => a - b ) ; let res = 2147483647 ; for ( let i = 0 ; i <= ( N - K ) ; i ++ ) { let curSeqDiff = arr [ i + K - 1 ] - arr [ i ] ; res = Math . min ( res , curSeqDiff ) ; } return res ; }
function segments ( n , p , m ) { var c = new Map ( ) ; c . set ( 0 , 1 ) ; var hs = false ; var sum = 0 ; var ans = 0 ; var r ; for ( r = 0 ; r < n ; r ++ ) { if ( p [ r ] < m ) sum -- ; else if ( p [ r ] > m ) sum ++ ; if ( p [ r ] == m ) hs = true ; if ( hs ) { if ( c . has ( sum ) && c . has ( sum - 1 ) ) ans += c . get ( sum ) + c . get ( sum - 1 ) ; else if ( c . has ( sum ) ) ans += c . get ( sum ) ; else if ( c . has ( sum - 1 ) ) ans += c . get ( sum - 1 ) ; } else { if ( c . has ( sum ) ) c . set ( sum , c . get ( sum ) + 1 ) ; else c . set ( sum , 1 ) ; } } return ans ; }
function FirstDigit ( arr , n ) { let S = 0 ; for ( let i = 0 ; i < n ; i ++ ) S = S + Math . log10 ( arr [ i ] * 1.0 ) ; let fract_S = S - Math . floor ( S ) ; let ans = parseInt ( Math . pow ( 10 , fract_S ) , 10 ) ; return ans ; }
function countNumberOfTriangles ( n ) { return n * ( n - 1 ) * ( n - 2 ) / 6 ; }
function subArraySum ( arr , n , sum ) { let curr_sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { curr_sum = arr [ i ] ; for ( let j = i + 1 ; j <= n ; j ++ ) { if ( curr_sum == sum ) { document . write ( " " + i + " " + ( j - 1 ) ) ; return ; } if ( curr_sum > sum j == n ) break ; curr_sum = curr_sum + arr [ j ] ; } } document . write ( " " ) ; return ; }
function prletNthElement ( n ) { let arr = Array ( n + 1 ) . fill ( 0 ) ; arr [ 1 ] = 3 ; arr [ 2 ] = 5 ; for ( i = 3 ; i <= n ; i ++ ) { if ( i % 2 != 0 ) arr [ i ] = arr [ i / 2 ] * 10 + 3 ; else arr [ i ] = arr [ ( i / 2 ) - 1 ] * 10 + 5 ; } return arr [ n ] ; }
function powerNumbers ( n ) { let v = new Set ( ) ; for ( let i = 2 ; i * i * i <= n ; i ++ ) { let j = i * i ; while ( j * i <= n ) { j *= i ; let s = parseInt ( Math . sqrt ( j ) , 10 ) ; if ( s * s != j ) v . add ( j ) ; } } return v . size + parseInt ( Math . sqrt ( n ) , 10 ) ; }
function count ( a , b , m , n ) { if ( ( m == 0 && n == 0 ) n == 0 ) return 1 ; if ( m == 0 ) return 0 ; if ( a [ m - 1 ] == b [ n - 1 ] ) return count ( a , b , m - 1 , n - 1 ) + count ( a , b , m - 1 , n ) ; else return count ( a , b , m - 1 , n ) ; }
function findMinSum ( arr , n ) { var sum = 0 ; for ( var i = 0 ; i < n ; i ++ ) sum += arr [ i ] * ( n - i ) ; return sum ; }
function isEven ( n ) { return ( ! ( n & 1 ) ) ; }
function subsetCount ( arr , n ) { return 1 << n ; }
function sph ( r , h ) { if ( r < 0 && h < 0 ) return - 1 ; var R = r ; return R ; }
function findSum ( N , K ) { let ans = 0 ; let y = N / K ; let x = N % K ; ans = ( K * ( K - 1 ) / 2 ) * y + ( x * ( x + 1 ) ) / 2 ; return ans ; }
function printPalindrome ( n ) { if ( n == 1 ) { document . write ( " " ) ; document . write ( " " ) ; } else { document . write ( " " + ( parseInt ( Math . pow ( 10 , n - 1 ) ) + 1 ) ) ; document . write ( " " + parseInt ( Math . pow ( 10 , n ) - 1 ) ) ; } }
function nthTerm ( n ) { return 3 * Math . pow ( n , 2 ) + n - 2 ; }
function countPairs ( str ) { let result = 0 ; let n = str . length ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = i + 1 ; j < n ; j ++ ) if ( Math . abs ( str [ i ] . charCodeAt ( ) - str [ j ] . charCodeAt ( ) ) == Math . abs ( i - j ) ) result ++ ; return result ; }
function CntDivbyX ( arr , n , x ) { let number = 0 ; let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { number = number * 2 + arr [ i ] ; if ( ( number % x == 0 ) ) count += 1 ; } return count ; }
function countValues ( n ) { let unset_bits = 0 ; while ( n > 0 ) { if ( ( n & 1 ) == 0 ) unset_bits ++ ; n = n >> 1 ; } return 1 << unset_bits ; }
function findMissing ( a , b , n , m ) { for ( let i = 0 ; i < n ; i ++ ) { let j ; for ( j = 0 ; j < m ; j ++ ) if ( a [ i ] == b [ j ] ) break ; if ( j == m ) document . write ( a [ i ] + " " ) ; } }
function countXOR ( n ) { let count0 = 0 , count1 = 0 ; while ( n != 0 ) { if ( n % 2 == 0 ) count0 ++ ; else count1 ++ ; n = Math . floor ( n / 2 ) ; } return ( count0 ^ count1 ) ; }
function countMaxChoco ( money , price , wrap ) { if ( money < price ) return 0 ; let choc = parseInt ( money / price , 10 ) ; choc = choc + parseInt ( ( choc - 1 ) / ( wrap - 1 ) , 10 ) ; return choc ; }
function countIntegralSolutions ( n ) { let result = 0 ; for ( let i = 0 ; i <= n ; i ++ ) for ( let j = 0 ; j <= n - i ; j ++ ) for ( let k = 0 ; k <= ( n - i - j ) ; k ++ ) if ( i + j + k == n ) result ++ ; return result ; }
function countSetBits ( n ) { let i = 0 ; let ans = 0 ; while ( ( 1 << i ) <= n ) { let k = 0 ; let change = 1 << i ; for ( let j = 0 ; j <= n ; j ++ ) { ans += k ; if ( change == 1 ) { k = ! k ; change = 1 << i ; } else { change -- ; } } i ++ ; } return ans ; }
function perfectPowerOf2 ( n ) { let per_pow = 1 ; while ( n > 0 ) { per_pow = per_pow << 1 ; n = n >> 1 ; } return per_pow ; }
function Triplets ( n ) { var ans = 0 ; for ( let i = 1 ; i <= n ; ++ i ) { for ( let j = i ; j <= n ; ++ j ) { var x = i * i + j * j ; var y = parseInt ( Math . sqrt ( x ) ) ; if ( y * y == x && y <= n ) ++ ans ; } } return ans ; }
function Circular ( n ) { var Result = 1 ; while ( n > 0 ) { Result = Result * n ; n -- ; } return Result ; }
function getMinCost ( arr , n ) { let min_ele = Number . MAX_VALUE ; for ( let i = 0 ; i < n ; i ++ ) { min_ele = Math . min ( min_ele , arr [ i ] ) ; } return min_ele * ( n - 1 ) ; }
function smallestDivisor ( n ) { if ( n % 2 == 0 ) return 2 ; for ( var i = 3 ; i * i <= n ; i += 2 ) { if ( n % i == 0 ) return i ; } return n ; }
function constructArr ( arr , pair , n ) { arr [ 0 ] = Math . floor ( ( pair [ 0 ] + pair [ 1 ] - pair [ n - 1 ] ) / 2 ) ; for ( let i = 1 ; i < n ; i ++ ) arr [ i ] = pair [ i - 1 ] - arr [ 0 ] ; }
function compute ( a , b ) { var AM = ( a + b ) / 2 ; var GM = Math . sqrt ( a * b ) ; var HM = ( GM * GM ) / AM ; return HM ; }
function findValue ( arr , n , k ) { for ( let i = 0 ; i < n ; i ++ ) if ( arr [ i ] == k ) k *= 2 ; return k ; }
function rod ( h , r ) { if ( h < 0 && r < 0 ) return - 1 ; var l = ( Math . sqrt ( Math . pow ( h , 2 ) + 4 * Math . pow ( r , 2 ) ) ) ; return l ; }
function sum ( n ) { let ans = parseInt ( ( n * ( n - 1 ) ) / 2 ) ; return ans ; }
function MatrixChainOrder ( p , n ) { var m = Array ( n ) . fill ( 0 ) . map ( x => Array ( n ) . fill ( 0 ) ) ; var i , j , k , L , q ; for ( i = 1 ; i < n ; i ++ ) m [ i ] [ i ] = 0 ; for ( L = 2 ; L < n ; L ++ ) { for ( i = 1 ; i < n - L + 1 ; i ++ ) { j = i + L - 1 ; if ( j == n ) continue ; m [ i ] [ j ] = Number . MAX_VALUE ; for ( k = i ; k <= j - 1 ; k ++ ) { q = m [ i ] [ k ] + m [ k + 1 ] [ j ] + p [ i - 1 ] * p [ k ] * p [ j ] ; if ( q < m [ i ] [ j ] ) m [ i ] [ j ] = q ; } } } return m [ 1 ] [ n - 1 ] ; }
function findPattern ( n ) { let prev = n % 2 ; n = Math . floor ( n / 2 ) ; while ( n > 0 ) { let curr = n % 2 ; if ( curr == prev ) return false ; prev = curr ; n = Math . floor ( n / 2 ) ; } return true ; }
function countkDist ( str , k ) { var res = 0 ; var n = str . length ; var cnt = Array . from ( { length : 26 } , ( _ , i ) => 0 ) ; for ( i = 0 ; i < n ; i ++ ) { var dist_count = 0 ; for ( j = i ; j < n ; j ++ ) { if ( cnt [ str . charAt ( j ) . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] == 0 ) dist_count ++ ; cnt [ str . charAt ( j ) . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; if ( dist_count == k ) res ++ ; } } return res ; }
function fib ( n ) { if ( n < 6 ) return f [ n ] ; let t = 5 , fn = 5 ; while ( t < n ) { fn = Math . round ( fn * PHI ) ; t ++ ; } return fn ; }
function printMaxAfterRemoval ( s ) { let flag = false ; let n = s . length ; for ( let i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ' ' && flag == false ) { flag = true ; continue ; } else document . write ( s [ i ] ) ; } return 0 ; }
function Centered_Triangular_num ( n ) { return ( 3 * n * n + 3 * n + 2 ) / 2 ; }
function nthHarmonic ( N ) { let harmonic = 1.00 ; for ( let i = 2 ; i <= N ; i ++ ) { harmonic += parseFloat ( 1 ) / i ; } return harmonic ; }
function maxDiff ( arr , arr_size ) { let max_diff = arr [ 1 ] - arr [ 0 ] ; for ( let i = 0 ; i < arr_size ; i ++ ) { for ( let j = i + 1 ; j < arr_size ; j ++ ) { if ( arr [ j ] - arr [ i ] > max_diff ) max_diff = arr [ j ] - arr [ i ] ; } } return max_diff ; }
function countSolutions ( n ) { let res = 0 ; for ( let x = 0 ; x * x < n ; x ++ ) { for ( let y = 0 ; x * x + y * y < n ; y ++ ) { res ++ ; } } return res ; }
function findDivisor ( x , y ) { if ( x == y ) return y ; return 2 ; }
function findNoIsDivisibleOrNot ( a , n , l ) { for ( let i = 0 ; i < l ; i ++ ) { if ( a [ i ] % n != 0 ) return false ; } return true ; }
function missing4 ( arr ) { let helper = [ ] ; for ( let i = 0 ; i < 4 ; i ++ ) { helper [ i ] = 0 ; } for ( let i = 0 ; i < arr . length ; i ++ ) { let temp = Math . abs ( arr [ i ] ) ; if ( temp <= arr . length ) arr [ temp - 1 ] = Math . floor ( arr [ temp - 1 ] * ( - 1 ) ) ; else if ( temp > arr . length ) { if ( temp % arr . length != 0 ) helper [ temp % arr . length - 1 ] = - 1 ; else helper [ ( temp % arr . length ) + arr . length - 1 ] = - 1 ; } } for ( let i = 0 ; i < arr . length ; i ++ ) if ( arr [ i ] > 0 ) document . write ( i + 1 + " " ) ; for ( let i = 0 ; i < helper . length ; i ++ ) if ( helper [ i ] >= 0 ) document . write ( arr . length + i + 1 + " " ) ; return ; }
function minElements ( arr , n ) { let halfSum = 0 ; for ( let i = 0 ; i < n ; i ++ ) halfSum = halfSum + arr [ i ] ; halfSum = parseInt ( halfSum / 2 , 10 ) ; arr . sort ( function ( a , b ) { return a - b } ) ; arr . reverse ( ) ; let res = 0 , curr_sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { curr_sum += arr [ i ] ; res ++ ; if ( curr_sum > halfSum ) return res ; } return res ; }
function maxOfSegmentMins ( a , n , k ) { if ( k == 1 ) { a . sort ( ) ; return a [ 0 ] ; } if ( k == 2 ) return Math . max ( a [ 0 ] , a [ n - 1 ] ) ; return a [ n - 1 ] ; }
function permute ( input ) { var n = input . length ; var max = 1 << n ; input = input . toLowerCase ( ) ; for ( var i = 0 ; i < max ; i ++ ) { var combination = input . split ( ' ' ) ; for ( var j = 0 ; j < n ; j ++ ) { if ( ( ( i >> j ) & 1 ) == 1 ) combination [ j ] = String . fromCharCode ( combination [ j ] . charCodeAt ( 0 ) - 32 ) ; } document . write ( combination . join ( ' ' ) ) ; document . write ( " " ) ; } }
function nthterm ( n ) { let An = ( Math . pow ( 1 , n ) + Math . pow ( 2 , n ) ) * Math . pow ( 3 , n ) ; return An ; }
function checkJumbled ( num ) { if ( parseInt ( num / 10 , 10 ) == 0 ) return true ; while ( num != 0 ) { if ( parseInt ( num / 10 , 10 ) == 0 ) return true ; let digit1 = num % 10 ; let digit2 = parseInt ( num / 10 , 10 ) % 10 ; if ( Math . abs ( digit2 - digit1 ) > 1 ) return false ; num = parseInt ( num / 10 , 10 ) ; } return true ; }
function isDiagonalMatrix ( mat ) { for ( let i = 0 ; i < N ; i ++ ) for ( let j = 0 ; j < N ; j ++ ) if ( ( i != j ) && ( mat [ i ] [ j ] != 0 ) ) return false ; return true ; }
function minOperations ( N ) { var x = Math . log ( N ) / Math . log ( 2 ) ; var ans = parseInt ( ( Math . ceil ( x ) ) ) ; return ans ; }
function printSpiral ( n ) { for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { let x ; x = Math . min ( Math . min ( i , j ) , Math . min ( n - 1 - i , n - 1 - j ) ) ; if ( i <= j ) document . write ( ` ${ ( n - 2 * x ) * ( n - 2 * x ) - ( i - x ) - ( j - x ) } ` ) ; else document . write ( ` ${ ( n - 2 * x - 2 ) * ( n - 2 * x - 2 ) + ( i - x ) + ( j - x ) } ` ) ; } document . write ( " " ) ; } }
function countIncreasing ( arr , n ) { let cnt = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i + 1 ; j < n ; j ++ ) { if ( arr [ j ] > arr [ j - 1 ] ) cnt ++ ; else break ; } } return cnt ; }
function check ( n , m ) { if ( n == 2 m == 2 n % m == 0 ) { document . write ( " " + " " ) ; } else { document . write ( " " + " " ) ; } }
function summation ( n ) { return n << ( n - 1 ) ; }
function maxDiff ( arr , n ) { let diff = arr [ 1 ] - arr [ 0 ] ; let curr_sum = diff ; let max_sum = curr_sum ; for ( let i = 1 ; i < n - 1 ; i ++ ) { diff = arr [ i + 1 ] - arr [ i ] ; if ( curr_sum > 0 ) curr_sum += diff ; else curr_sum = diff ; if ( curr_sum > max_sum ) max_sum = curr_sum ; } return max_sum ; }
function find_prob ( N , P ) { let dp = [ ] ; dp [ 0 ] = 1 ; dp [ 1 ] = 0 ; dp [ 2 ] = P ; dp [ 3 ] = 1 - P ; for ( let i = 4 ; i <= N ; ++ i ) dp [ i ] = ( P ) * dp [ i - 2 ] + ( 1 - P ) * dp [ i - 3 ] ; return ( dp [ N ] ) ; }
function MaximumSum ( a , b , n ) { let sum1 = 0 , sum2 = 0 ; for ( let i = 0 ; i < n ; i ++ ) { sum1 |= a [ i ] ; sum2 |= b [ i ] ; } document . write ( sum1 + sum2 ) ; }
function almostSort ( A , n ) { for ( let i = 0 ; i < n - 1 ; i ++ ) { if ( A [ i ] > A [ i + 1 ] ) { let temp = A [ i ] ; A [ i ] = A [ i + 1 ] ; A [ i + 1 ] = temp ; i ++ ; } } for ( let i = 0 ; i < n - 1 ; i ++ ) if ( A [ i ] > A [ i + 1 ] ) return false ; return true ; }
function findsolution ( n , x , y ) { if ( ( y - n + 1 ) * ( y - n + 1 ) + n - 1 < x y < n ) { document . write ( " " ) ; return ; } document . write ( y - n + 1 ) ; while ( n -- > 1 ) document . write ( " " + 1 ) ; }
function isScalarMatrix ( mat ) { for ( let i = 0 ; i < N ; i ++ ) for ( let j = 0 ; j < N ; j ++ ) if ( ( i != j ) && ( mat [ i ] [ j ] != 0 ) ) return false ; for ( let i = 0 ; i < N - 1 ; i ++ ) if ( mat [ i ] [ i ] != mat [ i + 1 ] [ i + 1 ] ) return false ; return true ; }
function findOptimalPairs ( arr , N ) { arr . sort ( function ( a , b ) { return a - b ; } ) ; for ( var i = 0 , j = N - 1 ; i <= j ; i ++ , j -- ) document . write ( " " + arr [ i ] + " " + arr [ j ] + " " + " " ) ; }
function findSum ( n ) { let ans = 0 , temp = 0 , num ; for ( let i = 1 ; i <= n && temp < n ; i ++ ) { temp = i - 1 ; num = 1 ; while ( temp < n ) { if ( temp + i <= n ) ans += ( i * num ) ; else ans += ( ( n - temp ) * num ) ; temp += i ; num ++ ; } } return ans ; }
function makeOdd ( n ) { if ( n % 2 != 0 ) return 1 ; var i ; for ( i = 2 ; i <= n ; i ++ ) if ( ( n % i == 0 ) && ( ( n / i ) % 2 == 1 ) ) break ; return i ; }
function checksum ( n ) { if ( n % 5 == 0 ) document . write ( ( n / 5 - 2 ) + " " + ( n / 5 - 1 ) + " " + ( n / 5 ) + " " + ( n / 5 + 1 ) + " " + ( n / 5 + 2 ) ) ; else document . write ( " " ) ; }
function interchangeFirstLast ( m ) { let rows = m . length ; for ( let i = 0 ; i < m [ 0 ] . length ; i ++ ) { let t = m [ 0 ] [ i ] ; m [ 0 ] [ i ] = m [ rows - 1 ] [ i ] ; m [ rows - 1 ] [ i ] = t ; } } let m = [ [ 8 , 9 , 7 , 6 ] , [ 4 , 7 , 6 , 5 ] , [ 3 , 2 , 1 , 8 ] , [ 9 , 9 , 7 , 7 ] ] interchangeFirstLast ( m ) ; for ( let i = 0 ; i < m . length ; i ++ ) { for ( let j = 0 ; j < m [ 0 ] . length ; j ++ ) document . write ( m [ i ] [ j ] + " " ) ; document . write ( " " ) ; }
function sizeSubSet ( a , k , n ) { a . sort ( function ( a , b ) { return a - b ; } ) ; let s = new Map ( ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] % k != 0 || s . get ( a [ i ] / k ) == null ) s . set ( a [ i ] , s . get ( a [ i ] ) == null ? 1 : s . get ( a [ i ] ) + 1 ) ; } return s . size ; }
function findTangent ( A , x , y ) { var dif = A - x * 2 ; if ( y == ( 2 * x - x * x ) ) { if ( dif < 0 ) document . write ( " " + dif + " " + ( x * dif + y ) + " " ) ; else if ( dif > 0 ) document . write ( " " + dif + " " + - x * dif + y + " " ) ; else document . write ( " " + " " ) ; } }
function parallel ( n , a ) { let x = true , y = true ; for ( let i = 0 ; i < n - 1 ; i ++ ) { if ( a [ i ] [ 0 ] != a [ i + 1 ] [ 0 ] ) x = false ; if ( a [ i ] [ 1 ] != a [ i + 1 ] [ 1 ] ) y = false ; } if ( x ) document . write ( " " + " " ) ; else if ( y ) document . write ( " " + " " ) ; else document . write ( " " + " " + " " ) ; }
function sackRace ( p1 , s1 , p2 , s2 ) { return ( ( s1 > s2 && ( p2 - p1 ) % ( s1 - s2 ) == 0 ) || ( s2 > s1 && ( p1 - p2 ) % ( s2 - s1 ) == 0 ) ) ; }
function deleteElement ( A , L , R , N ) { let i , j = 0 ; for ( i = 0 ; i < N ; i ++ ) { if ( i <= L i >= R ) { A [ j ] = A [ i ] ; j ++ ; } } return j ; }
function first ( a , b , c ) { a %= b ; for ( let i = 1 ; i <= b ; i ++ ) { a = a * 10 ; if ( a / b == c ) return i ; a %= b ; } return - 1 ; }
function maxTripletSum ( arr , n ) { arr . sort ( ) ; return arr [ n - 1 ] + arr [ n - 2 ] + arr [ n - 3 ] ; }
function findSum ( n ) { let sum = 0 ; for ( let x = 1 ; x <= n ; x ++ ) sum = sum + x ; return sum ; }
function smallestIndex ( a , n ) { let right1 = 0 , right0 = 0 ; let i ; for ( i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 1 ) right1 = i ; else right0 = i ; } return Math . min ( right1 , right0 ) ; }
function findSum ( n ) { return ( n * ( n + 1 ) * ( n + 1 ) * ( n + 2 ) ) / 12 ; }
function recaman ( n ) { let arr = new Array ( n ) ; arr [ 0 ] = 0 ; document . write ( arr [ 0 ] + " " ) ; for ( let i = 1 ; i < n ; i ++ ) { let curr = arr [ i - 1 ] - i ; let j ; for ( j = 0 ; j < i ; j ++ ) { if ( ( arr [ j ] == curr ) curr < 0 ) { curr = arr [ i - 1 ] + i ; break ; } } arr [ i ] = curr ; document . write ( arr [ i ] + " " ) ; } }
function sumBetweenTwoKth ( arr , k1 , k2 ) { arr . sort ( function ( a , b ) { return a - b } ) ; var result = 0 ; for ( var i = k1 ; i < k2 - 1 ; i ++ ) result += arr [ i ] ; return result ; }
function calculateSquareSum ( n ) { if ( n <= 0 ) return 0 ; var fibo = Array ( n + 1 ) . fill ( 0 ) ; fibo [ 0 ] = 0 ; fibo [ 1 ] = 1 ; var sum = ( fibo [ 0 ] * fibo [ 0 ] ) + ( fibo [ 1 ] * fibo [ 1 ] ) ; for ( i = 2 ; i <= n ; i ++ ) { fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ; sum += ( fibo [ i ] * fibo [ i ] ) ; } return sum ; }
function area_fun ( side ) { let area = side * side ; return area ; }
function angle_triangle ( x1 , x2 , x3 , y1 , y2 , y3 , z1 , z2 , z3 ) { let num = ( x2 - x1 ) * ( x3 - x1 ) + ( y2 - y1 ) * ( y3 - y1 ) + ( z2 - z1 ) * ( z3 - z1 ) ; let den = Math . sqrt ( Math . pow ( ( x2 - x1 ) , 2 ) + Math . pow ( ( y2 - y1 ) , 2 ) + Math . pow ( ( z2 - z1 ) , 2 ) ) * Math . sqrt ( Math . pow ( ( x3 - x1 ) , 2 ) + Math . pow ( ( y3 - y1 ) , 2 ) + Math . pow ( ( z3 - z1 ) , 2 ) ) ; let angle = Math . acos ( num / den ) * ( 180.0 / 3.141592653589793238463 ) ; return angle ; }
function findCount ( m , n ) { let num1 = 0 ; for ( let i = 0 ; i < m ; i ++ ) num1 = ( num1 * 10 ) + 9 ; let num2 = 0 ; for ( let i = 0 ; i < ( m - 1 ) ; i ++ ) num2 = ( num2 * 10 ) + 9 ; return ( ( num1 / n ) - ( num2 / n ) ) ; }
function isPossible ( x , y , z ) { let a = Math . round ( x * x + y * y + z * z ) ; if ( Math . ceil ( a ) == 1 && Math . floor ( a ) == 1 ) return true ; return false ; }
function findDivisors ( n ) { let div = new Array ( n + 1 ) . fill ( 0 ) ; for ( let i = 1 ; i <= n ; i ++ ) { for ( let j = 1 ; j * i <= n ; j ++ ) div [ i * j ] ++ ; } for ( let i = 1 ; i <= n ; i ++ ) document . write ( div [ i ] + " " ) ; }
function countConsecutive ( s ) { let count = 0 ; for ( let i = 0 ; i < s . length ; i ++ ) { if ( s [ i ] == s [ i + 1 ] ) i ++ ; else count ++ ; } return count ; }
function maxProductSum ( str , m ) { let n = str . length ; let maxProd = Number . MIN_VALUE , maxSum = Number . MIN_VALUE ; for ( let i = 0 ; i <= n - m ; i ++ ) { let product = 1 , sum = 0 ; for ( let j = i ; j < m + i ; j ++ ) { product = product * ( str [ j ] - ' ' ) ; sum = sum + ( str [ j ] - ' ' ) ; } maxProd = Math . max ( maxProd , product ) ; maxSum = Math . max ( maxSum , sum ) ; } document . write ( " " + maxProd + " " ) ; document . write ( " " + maxSum ) ; }
function nextPowerOf2 ( n ) { p = 1 ; if ( n && ! ( n & ( n - 1 ) ) ) return n ; while ( p < n ) p <<= 1 ; return p ; }
function minCells ( mat , m , n ) { let dp = new Array ( m ) ; for ( var i = 0 ; i < dp . length ; i ++ ) { dp [ i ] = new Array ( 2 ) ; } for ( let i = 0 ; i < m ; i ++ ) for ( let j = 0 ; j < n ; j ++ ) dp [ i ] [ j ] = Number . MAX_VALUE ; dp [ 0 ] [ 0 ] = 1 ; for ( let i = 0 ; i < m ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { if ( dp [ i ] [ j ] != Number . MAX_VALUE && ( j + mat [ i ] [ j ] ) < n && ( dp [ i ] [ j ] + 1 ) < dp [ i ] [ j + mat [ i ] [ j ] ] ) dp [ i ] [ j + mat [ i ] [ j ] ] = dp [ i ] [ j ] + 1 ; if ( dp [ i ] [ j ] != Number . MAX_VALUE && ( i + mat [ i ] [ j ] ) < m && ( dp [ i ] [ j ] + 1 ) < dp [ i + mat [ i ] [ j ] ] [ j ] ) dp [ i + mat [ i ] [ j ] ] [ j ] = dp [ i ] [ j ] + 1 ; } } if ( dp [ m - 1 ] [ n - 1 ] != Number . MAX_VALUE ) return dp [ m - 1 ] [ n - 1 ] ; return - 1 ; }
function findXOR ( Set , n ) { if ( n == 1 ) return Set [ 0 ] ; else return 0 ; }
function lastPosition ( n , m , k ) { if ( m <= n - k + 1 ) return m + k - 1 ; m = m - ( n - k + 1 ) ; return ( m % n == 0 ) ? n : ( m % n ) ; }
function increment ( i ) { let i1 = - ( ~ ( i ) . charCodeAt ( ) ) ; return String . fromCharCode ( i1 ) ; }
function addOne ( x ) { return ( - ( ~ x ) ) ; }
function andSum ( arr , n ) { var ans = 0 ; for ( i = 0 ; i < BITS ; i ++ ) { var countSetBits = 0 ; for ( j = 0 ; j < n ; j ++ ) { if ( ( arr [ j ] & ( 1 << i ) ) != 0 ) countSetBits ++ ; } var subset = ( 1 << countSetBits ) - 1 ; subset = ( subset * ( 1 << i ) ) ; ans += subset ; } return ans ; }
function solve ( p , n ) { let G = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( p [ i ] % 2 != 0 ) G ^= ( p [ i ] + 1 ) ; else G ^= ( p [ i ] - 1 ) ; } return G ; }
function countSubstrings ( s , c ) { var n = s . length ; var cnt = 0 ; var sum = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) != c ) cnt ++ ; else { sum += ( cnt * ( cnt + 1 ) ) / 2 ; cnt = 0 ; } } sum += ( cnt * ( cnt + 1 ) ) / 2 ; return sum ; }
function print ( n ) { document . write ( n + parseInt ( n / 2 ) + " " ) ; for ( i = 2 ; i <= n ; i += 2 ) document . write ( i + " " ) ; for ( i = 1 ; i <= n ; i += 2 ) document . write ( i + " " ) ; for ( i = 2 ; i <= n ; i += 2 ) document . write ( i + " " ) ; }
function DivisibleBy41 ( first , second , c , n ) { let digit = new Array ( n ) . fill ( 0 ) ; digit [ 0 ] = first ; digit [ 1 ] = second ; for ( let i = 2 ; i < n ; i ++ ) digit [ i ] = ( digit [ i - 1 ] * c + digit [ i - 2 ] ) % 10 ; let ans = digit [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) ans = ( ans * 10 + digit [ i ] ) % 41 ; if ( ans % 41 == 0 ) return true ; else return false ; }
function Reverseorder ( n ) { let prime = new Array ( n + 1 ) ; for ( let i = 0 ; i < n ; i ++ ) prime [ i ] = true ; for ( let p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( let i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } for ( let p = n ; p >= 2 ; p -- ) if ( prime [ p ] ) document . write ( p + " " ) ; }
function answer ( n ) { let dp = new Array ( n + 1 ) ; for ( var i = 0 ; i < dp . length ; i ++ ) { dp [ i ] = new Array ( 2 ) ; } if ( n == 1 ) return 10 ; for ( let j = 0 ; j <= 9 ; j ++ ) dp [ 1 ] [ j ] = 1 ; for ( let i = 2 ; i <= n ; i ++ ) { for ( let j = 0 ; j <= 9 ; j ++ ) { if ( j == 0 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] ; else if ( j == 9 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] ; } } let sum = 0 ; for ( let j = 1 ; j <= 9 ; j ++ ) sum += dp [ n ] [ j ] ; return sum ; }
function findNumber ( n ) { let x = Math . floor ( ( - 1 + Math . sqrt ( 1 + 8 * n - 8 ) ) / 2 ) ; let base = ( x * ( x + 1 ) ) / 2 + 1 ; return n - base + 1 ; }
function center_pentadecagonal_num ( n ) { return ( 15 * n * n - 15 * n + 2 ) / 2 ; }
function minStepToDeleteString ( str ) { let N = str . length ; let dp = new Array ( N + 1 ) ; for ( let i = 0 ; i <= N ; i ++ ) { dp [ i ] = new Array ( N + 1 ) ; for ( let j = 0 ; j <= N ; j ++ ) dp [ i ] [ j ] = 0 ; } for ( let len = 1 ; len <= N ; len ++ ) { for ( let i = 0 , j = len - 1 ; j < N ; i ++ , j ++ ) { if ( len == 1 ) dp [ i ] [ j ] = 1 ; else { dp [ i ] [ j ] = 1 + dp [ i + 1 ] [ j ] ; if ( str [ i ] == str [ i + 1 ] ) dp [ i ] [ j ] = Math . min ( 1 + dp [ i + 2 ] [ j ] , dp [ i ] [ j ] ) ; for ( let K = i + 2 ; K <= j ; K ++ ) if ( str [ i ] == str [ K ] ) dp [ i ] [ j ] = Math . min ( dp [ i + 1 ] [ K - 1 ] + dp [ K + 1 ] [ j ] , dp [ i ] [ j ] ) ; } } } return dp [ 0 ] [ N - 1 ] ; }
function findWater ( arr , n ) { let result = 0 ; let left_max = 0 , right_max = 0 ; let lo = 0 , hi = n - 1 ; while ( lo <= hi ) { if ( arr [ lo ] < arr [ hi ] ) { if ( arr [ lo ] > left_max ) left_max = arr [ lo ] ; else result += left_max - arr [ lo ] ; lo ++ ; } else { if ( arr [ hi ] > right_max ) right_max = arr [ hi ] ; else result += right_max - arr [ hi ] ; hi -- ; } } return result ; }
function CountPair ( L , R ) { let x = ( R - L + 1 ) ; document . write ( x / 2 + " " ) ; }
function findTerm ( n ) { if ( n == 1 ) return n ; else { let term = 7 ; for ( let i = 2 ; i <= n ; i ++ ) term = term * 2 + ( i - 1 ) ; return term ; } }
function get_unit_digit ( N ) { if ( N == 0 N == 1 ) return 1 ; else if ( N == 2 ) return 3 ; else if ( N == 3 ) return 9 ; return 3 ; }
function findWater ( n ) { let left = new Array ( n ) ; let right = new Array ( n ) ; let water = 0 ; left [ 0 ] = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) left [ i ] = Math . max ( left [ i - 1 ] , arr [ i ] ) ; right [ n - 1 ] = arr [ n - 1 ] ; for ( let i = n - 2 ; i >= 0 ; i -- ) right [ i ] = Math . max ( right [ i + 1 ] , arr [ i ] ) ; for ( let i = 0 ; i < n ; i ++ ) water += Math . min ( left [ i ] , right [ i ] ) - arr [ i ] ; return water ; }
function computeTotient ( n ) { let phi = new Array ( n + 1 ) ; for ( let i = 1 ; i <= n ; i ++ ) phi [ i ] = i ; for ( let p = 2 ; p <= n ; p ++ ) { if ( phi [ p ] == p ) { phi [ p ] = p - 1 ; for ( let i = 2 * p ; i <= n ; i += p ) { phi [ i ] = parseInt ( phi [ i ] / p , 10 ) * ( p - 1 ) ; } } } for ( let i = 1 ; i <= n ; i ++ ) document . write ( " " + i + " " + phi [ i ] + " " ) ; }
function isDivisible ( n ) { while ( Math . floor ( n / 100 ) > 0 ) { let d = n % 10 ; n = Math . floor ( n / 10 ) ; n -= d * 5 ; } return ( n % 17 == 0 ) ; }
function modInverse ( a , m ) { let m0 = m ; let y = 0 ; let x = 1 ; if ( m == 1 ) return 0 ; while ( a > 1 ) { let q = parseInt ( a / m ) ; let t = m ; m = a % m ; a = t ; t = y ; y = x - q * y ; x = t ; } if ( x < 0 ) x += m0 ; return x ; } let a = 3 ; let m = 11 ; document . write ( ` ${ modInverse ( a , m ) }
function dealnnoy ( n , m ) { if ( m == 0 n == 0 ) return 1 ; return dealnnoy ( m - 1 , n ) + dealnnoy ( m - 1 , n - 1 ) + dealnnoy ( m , n - 1 ) ; }
function xorPairSum ( ar , n ) { var sum = 0 ; for ( i = 0 ; i < n ; i ++ ) sum = sum ^ ar [ i ] ; return 2 * sum ; }
function repUnitValue ( n ) { if ( n % 2 == 0 n % 5 == 0 ) return 0 ; let rem = 1 ; let power = 1 ; let k = 1 ; while ( rem % n != 0 ) { k ++ ; power = power * 10 % n ; rem = ( rem + power ) % n ; } return k ; }
function printLargest ( a , n ) { let max = - 1 ; let ind = - 1 ; for ( let i = 0 ; i < n ; i ++ ) { let num = a [ i ] ; while ( num > 0 ) { let r = num % 10 ; num = Math . floor ( num / 10 ) ; if ( num == 0 ) { if ( max < r ) { max = r ; ind = i ; } } } } for ( let i = ind ; i < n ; i ++ ) document . write ( a [ i ] ) ; for ( let i = 0 ; i < ind ; i ++ ) document . write ( a [ i ] ) ; }
function bellNumber ( n ) { let bell = new Array ( n + 1 ) ; for ( let i = 0 ; i < n + 1 ; i ++ ) { bell [ i ] = new Array ( n + 1 ) ; } bell [ 0 ] [ 0 ] = 1 ; for ( let i = 1 ; i <= n ; i ++ ) { bell [ i ] [ 0 ] = bell [ i - 1 ] [ i - 1 ] ; for ( let j = 1 ; j <= i ; j ++ ) bell [ i ] [ j ] = bell [ i - 1 ] [ j - 1 ] + bell [ i ] [ j - 1 ] ; } return bell [ n ] [ 0 ] ; }
function printNGE ( arr , n ) { var next , i , j ; for ( i = 0 ; i < n ; i ++ ) { next = - 1 ; for ( j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] < arr [ j ] ) { next = arr [ j ] ; break ; } } document . write ( arr [ i ] + " " + next ) ; document . write ( " " ) ; } }
function countNonIncreasing ( arr , n ) { var cnt = 0 ; var len = 1 ; for ( var i = 0 ; i < n - 1 ; ++ i ) { if ( arr [ i + 1 ] <= arr [ i ] ) len ++ ; else { cnt += parseInt ( ( ( len + 1 ) * len ) / 2 ) ; len = 1 ; } } if ( len > 1 ) cnt += parseInt ( ( ( len + 1 ) * len ) / 2 ) ; return cnt ; }
function maximumSum ( arr , n , k ) { for ( let i = 1 ; i <= k ; i ++ ) { let min = + 2147483647 ; let index = - 1 ; for ( let j = 0 ; j < n ; j ++ ) { if ( arr [ j ] < min ) { min = arr [ j ] ; index = j ; } } if ( min == 0 ) break ; arr [ index ] = - arr [ index ] ; } let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; return sum ; }
function countGroups ( position , previous_sum , length , num ) { if ( position == length ) return 1 ; let res = 0 ; let sum = 0 ; for ( let i = position ; i < length ; i ++ ) { sum += ( num [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ) ; if ( sum >= previous_sum ) res += countGroups ( i + 1 , sum , length , num ) ; } return res ; }
function sumOfSeries ( n ) { x = 0 if ( n % 2 == 0 ) x = ( n / 2 ) * ( n + 1 ) else x = ( ( n + 1 ) / 2 ) * n return ( x * x ) }
function maxSumPairWithDifferenceLessThanK ( arr , N , K ) { arr . sort ( ) ; let dp = [ ] ; dp [ 0 ] = 0 ; for ( let i = 1 ; i < N ; i ++ ) { dp [ i ] = dp [ i - 1 ] ; if ( arr [ i ] - arr [ i - 1 ] < K ) { if ( i >= 2 ) dp [ i ] = Math . max ( dp [ i ] , dp [ i - 2 ] + arr [ i ] + arr [ i - 1 ] ) ; else dp [ i ] = Math . max ( dp [ i ] , arr [ i ] + arr [ i - 1 ] ) ; } } return dp [ N - 1 ] ; }
function numberOfPaths ( m , n ) { var count = Array ( m ) . fill ( 0 ) . map ( x => Array ( n ) . fill ( 0 ) ) ; for ( i = 0 ; i < m ; i ++ ) count [ i ] [ 0 ] = 1 ; for ( j = 0 ; j < n ; j ++ ) count [ 0 ] [ j ] = 1 ; for ( i = 1 ; i < m ; i ++ ) { for ( j = 1 ; j < n ; j ++ ) count [ i ] [ j ] = count [ i - 1 ] [ j ] + count [ i ] [ j - 1 ] + count [ i - 1 ] [ j - 1 ] ; ; } return count [ m - 1 ] [ n - 1 ] ; }
function countSolutions ( n ) { let x = 0 , yCount , res = 0 ; for ( yCount = 0 ; yCount * yCount < n ; yCount ++ ) ; while ( yCount != 0 ) { res += yCount ; x ++ ; while ( yCount != 0 && ( x * x + ( yCount - 1 ) * ( yCount - 1 ) >= n ) ) yCount -- ; } return res ; }
function power ( n , r ) { let count = 0 ; for ( let i = r ; ( n / i ) >= 1 ; i = i * r ) count += n / i ; return count ; }
function minimumNumbers ( n , s ) { if ( s % n ) return parseInt ( s / n ) + 1 ; else return parseInt ( s / n ) ; }
function avg_of_even_num ( n ) { return n + 1 ; }
function possibleToReach ( a , b ) { let c = Math . cbrt ( a * b ) ; let re1 = a / c ; let re2 = b / c ; if ( ( re1 * re1 * re2 == a ) && ( re2 * re2 * re1 == b ) ) return true ; else return false ; }
function area ( a , b ) { if ( a < 0 b < 0 ) return - 1 ; var A = a * b ; return A ; }
function isUndulating ( n ) { if ( n . length <= 2 ) return false ; for ( let i = 2 ; i < n . length ; i ++ ) if ( n [ i - 2 ] != n [ i ] ) return false ; return true ; }
function seiresSum ( n , a ) { let res = 0 , i ; for ( i = 0 ; i < 2 * n ; i ++ ) { if ( i % 2 == 0 ) res += a [ i ] * a [ i ] ; else res -= a [ i ] * a [ i ] ; } return res ; }
function isRefactorableNumber ( n ) { let divCount = 0 ; for ( let i = 1 ; i <= Math . sqrt ( n ) ; ++ i ) { if ( n % i == 0 ) { if ( n / i == i ) ++ divCount ; else divCount += 2 ; } } return n % divCount == 0 ; }
function printDemlo ( str ) { let len = str . length ; let res = " " ; for ( let i = 1 ; i <= len ; i ++ ) res += i . toString ( ) ; for ( let i = len - 1 ; i >= 1 ; i -- ) res += i . toString ( ) ; return res ; }
function Move ( a , x , b ) { if ( ( ( ( b - a ) % x == 0 ) || ( ( b - a - 1 ) % x == 0 ) && a + 1 != b ) && b >= a ) return true ; return false ; }
function maxConsecutiveOnes ( x ) { let count = 0 ; while ( x != 0 ) { x = ( x & ( x << 1 ) ) ; count ++ ; } return count ; }
function Cel_To_Fah ( n ) { return ( ( n * 9.0 / 5.0 ) + 32.0 ) ; }
function getPosition ( n , m ) { if ( m > ( n / 2 ) ) return ( m - parseInt ( n / 2 ) ) ; return ( m + parseInt ( n / 2 ) ) ; }
function isequal ( str ) { let n = str . length ; let num = 0 , x = 1 , i = n - 1 ; for ( i = n - 1 ; i >= 0 ; i -- ) { if ( ' ' <= str [ i ] && str [ i ] <= ' ' ) { num = ( str [ i ] - ' ' ) * x + num ; x = x * 10 ; if ( num >= n ) return false ; } else break ; } return num == i + 1 ; }
function seriesFunc ( n ) { let sumSquare = ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; let sumNatural = ( n * ( n + 1 ) / 2 ) ; return ( sumSquare + sumNatural + 1 ) ; }
function getProbability ( a , b , c , d ) { var p = a / b ; var q = c / d ; var ans = p * ( 1 / ( 1 - ( 1 - q ) * ( 1 - p ) ) ) ; return ans ; }
function find_probability ( p , q , r , s ) { var t = ( 1 - p / q ) * ( 1 - r / s ) ; var ans = ( p / q ) / ( 1 - t ) ; return ans ; }
function endPointOfDiameterofCircle ( x1 , y1 , c1 , c2 ) { document . write ( " " + ( 2 * c1 - x1 ) + " " ) ; document . write ( " " + ( 2 * c2 - y1 ) ) ; }
function nextPowerOf2 ( n ) { var count = 0 ; if ( n && ! ( n & ( n - 1 ) ) ) return n ; while ( n != 0 ) { n >>= 1 ; count += 1 ; } return 1 << count ; }
function center_octadecagon_num ( n ) { return 9 * n * n - 9 * n + 1 ; }
function gcd ( a , b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
function sum ( x , n ) { let total = 1.0 ; let multi = x ; for ( let i = 1 ; i <= n ; i ++ ) { total = total + multi / i ; multi = multi * x ; } return total ; }
function smallest ( x , y , z ) { let c = 0 ; while ( x && y && z ) { x -- ; y -- ; z -- ; c ++ ; } return c ; }
function countWays ( N ) { if ( N == 1 ) return 4 ; let countB = 1 , countS = 1 , prev_countB , prev_countS ; for ( let i = 2 ; i <= N ; i ++ ) { prev_countB = countB ; prev_countS = countS ; countS = prev_countB + prev_countS ; countB = prev_countS ; } let result = countS + countB ; return ( result * result ) ; }
function getProbability ( p , q ) { p /= 100 ; q /= 100 ; let probability = ( p * p + q * q ) / ( p + q ) ; return probability ; }
function Pentatope_number ( n ) { return n * ( n + 1 ) * ( n + 2 ) * ( n + 3 ) / 24 ; }
function closestMultiple ( n , x ) { if ( x > n ) return x ; n = n + parseInt ( x / 2 , 10 ) ; n = n - ( n % x ) ; return n ; }
function findMaximum ( arr , low , high ) { if ( low == high ) return arr [ low ] ; if ( ( high == low + 1 ) && arr [ low ] >= arr [ high ] ) return arr [ low ] ; if ( ( high == low + 1 ) && arr [ low ] < arr [ high ] ) return arr [ high ] ; mid = ( low + high ) / 2 ; if ( arr [ mid ] > arr [ mid + 1 ] && arr [ mid ] > arr [ mid - 1 ] ) return arr [ mid ] ; if ( arr [ mid ] > arr [ mid + 1 ] && arr [ mid ] < arr [ mid - 1 ] ) return findMaximum ( arr , low , mid - 1 ) ; return findMaximum ( arr , mid + 1 , high ) ; }
function isMultipleof5 ( n ) { str = Array ( n ) . fill ( ' ' ) ; var len = str . length ; if ( str [ len - 1 ] == ' ' str [ len - 1 ] == ' ' ) return true ; return false ; }
function swapThree ( ) { a = a ^ b ^ c ; b = a ^ b ^ c ; c = a ^ b ^ c ; a = a ^ b ^ c ; }
