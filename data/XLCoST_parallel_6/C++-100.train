ll calculate ( ll a [ ] , ll n ) { sort ( a , a + n ) ; vector < ll > s ; for ( int i = 0 , j = n - 1 ; i < j ; i ++ , j -- ) s . push_back ( a [ i ] + a [ j ] ) ; ll mini = * min_element ( s . begin ( ) , s . end ( ) ) ; ll maxi = * max_element ( s . begin ( ) , s . end ( ) ) ; return abs ( maxi - mini ) ; }
float cyl ( float r , float h ) { if ( r < 0 && h < 0 ) return -1 ; float R = ( 2 * r ) / 3 ; float H = ( 2 * h ) / 3 ; float V = 3.14 * pow ( R , 2 ) * H ; return V ; }
void printTwoSetBitNums ( int n ) { int x = 1 ; while ( n > 0 ) { int y = 0 ; while ( y < x ) { cout << ( 1 << x ) + ( 1 << y ) << " ▁ " ; n -- ; if ( n == 0 ) return ; y ++ ; } x ++ ; } }
int minNumber ( int a [ ] , int n , int x ) { int l = 0 , h = 0 , e = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == x ) e ++ ; else if ( a [ i ] > x ) h ++ ; else if ( a [ i ] < x ) l ++ ; } int ans = 0 ; if ( l > h ) ans = l - h ; else if ( l < h ) ans = h - l - 1 ; return ans + 1 - e ; }
void printKthBit ( unsigned int n , unsigned int k ) { cout << ( ( n & ( 1 << ( k - 1 ) ) ) >> ( k - 1 ) ) ; }
int equilibrium ( int arr [ ] , int n ) { int sum = 0 ; int leftsum = 0 ; for ( int i = 0 ; i < n ; ++ i ) sum += arr [ i ] ; for ( int i = 0 ; i < n ; ++ i ) { sum -= arr [ i ] ; if ( leftsum == sum ) return i ; leftsum += arr [ i ] ; } return -1 ; }
long countRhombi ( int h , int w ) { long long ct = 0 ; for ( int i = 2 ; i <= h ; i += 2 ) for ( int j = 2 ; j <= w ; j += 2 ) ct += ( h - i + 1 ) * ( w - j + 1 ) ; return ct ; }
int sumofoddFactors ( int n ) { int res = 1 ; while ( n % 2 == 0 ) n = n / 2 ; for ( int i = 3 ; i <= sqrt ( n ) ; i ++ ) { int count = 0 , curr_sum = 1 ; int curr_term = 1 ; while ( n % i == 0 ) { count ++ ; n = n / i ; curr_term *= i ; curr_sum += curr_term ; } res *= curr_sum ; } if ( n >= 2 ) res *= ( 1 + n ) ; return res ; }
bool isPower ( unsigned int n ) { for ( int x = 2 ; x <= sqrt ( n ) ; x ++ ) { float f = log ( n ) / log ( x ) ; if ( ( f - ( int ) f ) == 0.0 ) return true ; } return false ; }
int sumOfSeries ( int n ) { return n * ( n + 1 ) * ( 6 * n * n * n + 9 * n * n + n - 1 ) / 30 ; }
double sum ( int n ) { double i , s = 0.0 ; for ( i = 1 ; i <= n ; i ++ ) s = s + 1 / i ; return s ; }
int countRect ( int n ) { int ans = 0 ; for ( int length = 1 ; length <= sqrt ( n ) ; ++ length ) for ( int height = length ; height * length <= n ; ++ height ) ans ++ ; return ans ; }
bool isSquareFree ( int n ) { if ( n % 2 == 0 ) n = n / 2 ; if ( n % 2 == 0 ) return false ; for ( int i = 3 ; i <= sqrt ( n ) ; i = i + 2 ) { if ( n % i == 0 ) { n = n / i ; if ( n % i == 0 ) return false ; } } return true ; }
void constructXOR ( int A [ ] , int n ) { int XOR = 0 ; for ( int i = 0 ; i < n ; i ++ ) XOR ^= A [ i ] ; for ( int i = 0 ; i < n ; i ++ ) A [ i ] = XOR ^ A [ i ] ; }
int maxArea ( float perimeter ) { int length = ( int ) ceil ( perimeter / 4 ) ; int breadth = ( int ) floor ( perimeter / 4 ) ; return length * breadth ; }
bool isPowerOfK ( unsigned int n , unsigned int k ) { bool oneSeen = false ; while ( n > 0 ) { int digit = n % k ; if ( digit > 1 ) return false ; if ( digit == 1 ) { if ( oneSeen ) return false ; oneSeen = true ; } n /= k ; } return true ; }
float ReuleauxArea ( float a ) { if ( a < 0 ) return -1 ; float A = 0.70477 * pow ( a , 2 ) ; return A ; }
float squareArea ( float a ) { if ( a < 0 ) return -1 ; float area = pow ( 1.268 , 2 ) * pow ( a , 2 ) ; return area ; }
void cal_cos ( float n ) { float accuracy = 0.0001 , x1 , denominator , cosx , cosval ; n = n * ( 3.142 / 180.0 ) ; x1 = 1 ; cosx = x1 ; cosval = cos ( n ) ; int i = 1 ; do { denominator = 2 * i * ( 2 * i - 1 ) ; x1 = - x1 * n * n / denominator ; cosx = cosx + x1 ; i = i + 1 ; } while ( accuracy <= fabs ( cosval - cosx ) ) ; cout << cosx ; }
int divisorSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j * j <= i ; ++ j ) { if ( i % j == 0 ) { if ( i / j == j ) sum += j ; else sum += j + i / j ; } } } return sum ; }
int hexadecagonalNum ( long int n ) { return ( ( 14 * n * n ) - 12 * n ) / 2 ; }
int minValue ( int n , int x , int y ) { float val = ( y * n ) / 100 ; if ( x >= val ) return 0 ; else return ( ceil ( val ) - x ) ; }
void middlesum ( int mat [ ] [ MAX ] , int n ) { int row_sum = 0 , col_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) row_sum += mat [ n / 2 ] [ i ] ; cout << " Sum ▁ of ▁ middle ▁ row ▁ = ▁ " << row_sum << endl ; for ( int i = 0 ; i < n ; i ++ ) col_sum += mat [ i ] [ n / 2 ] ; cout << " Sum ▁ of ▁ middle ▁ column ▁ = ▁ " << col_sum ; }
void printBalancedExpression ( int a , int b , int c , int d ) { if ( ( a == d && a ) || ( a == 0 && c == 0 && d == 0 ) ) { for ( int i = 1 ; i <= a ; i ++ ) cout << " ( ( " ; for ( int i = 1 ; i <= c ; i ++ ) cout << " ) ( " ; for ( int i = 1 ; i <= d ; i ++ ) cout << " ) ) " ; for ( int i = 1 ; i <= b ; i ++ ) cout << " ( ) " ; } else cout << -1 ; }
bool judgeSquareSum ( int n ) { for ( int i = 2 ; i * i <= n ; i ++ ) { int count = 0 ; if ( n % i == 0 ) { while ( n % i == 0 ) { count ++ ; n /= i ; } if ( i % 4 == 3 && count % 2 != 0 ) return false ; } } return n % 4 != 3 ; }
int highestPowerOf2 ( int n ) { return ( n & ( ~ ( n - 1 ) ) ) ; }
void printMaxSum ( int arr [ ] , int n ) { int dp [ n ] ; memset ( dp , 0 , sizeof dp ) ; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] = arr [ i ] ; int maxi = 0 ; for ( int j = 1 ; j <= sqrt ( i + 1 ) ; j ++ ) { if ( ( ( i + 1 ) % j == 0 ) && ( i + 1 ) != j ) { if ( dp [ j - 1 ] > maxi ) maxi = dp [ j - 1 ] ; if ( dp [ ( i + 1 ) / j - 1 ] > maxi && j != 1 ) maxi = dp [ ( i + 1 ) / j - 1 ] ; } } dp [ i ] += maxi ; } for ( int i = 0 ; i < n ; i ++ ) cout << dp [ i ] << " ▁ " ; }
bool isInGivenBase ( string str , int base ) { if ( base > 16 ) return false ; else if ( base <= 10 ) { for ( int i = 0 ; i < str . length ( ) ; i ++ ) if ( ! ( str [ i ] >= '0' and str [ i ] < ( '0' + base ) ) ) return false ; } else { for ( int i = 0 ; i < str . length ( ) ; i ++ ) if ( ! ( ( str [ i ] >= '0' && str [ i ] < ( '0' + base ) ) || ( str [ i ] >= ' A ' && str [ i ] < ( ' A ' + base - 10 ) ) ) ) return false ; } return true ; }
void convert ( string str ) { int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( str . at ( i ) == ' ▁ ' ) str . at ( i ) = ' _ ' ; else str . at ( i ) = tolower ( str . at ( i ) ) ; } cout << str ; }
int hammingDistance ( int n1 , int n2 ) { int x = n1 ^ n2 ; int setBits = 0 ; while ( x > 0 ) { setBits += x & 1 ; x >>= 1 ; } return setBits ; }
int round ( int n ) { int a = ( n / 10 ) * 10 ; int b = a + 10 ; return ( n - a > b - n ) ? b : a ; }
int absSumDidd ( int a [ ] , int n ) { sort ( a , a + n ) ; int midValue = a [ ( int ) ( n / 2 ) ] ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + abs ( a [ i ] - midValue ) ; } return sum ; }
int sumN ( int n ) { n = ( n + 1 ) / 2 ; return ( n * n ) ; }
int getPairsCount ( int arr [ ] , int n , int sum ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] + arr [ j ] == sum ) count ++ ; return count ; }
void bin ( unsigned n ) { if ( n > 1 ) bin ( n >> 1 ) ; printf ( " % d " , n & 1 ) ; }
int countSetBits ( unsigned int n ) { unsigned int count = 0 ; while ( n ) { count += n & 1 ; n >>= 1 ; } return count ; }
bool findNature ( int a , int b , int n ) { if ( n == 0 ) return ( a & 1 ) ; if ( n == 1 ) return ( b & 1 ) ; if ( ! ( a & 1 ) ) { if ( ! ( b & 1 ) ) return false ; else return ( n % 3 != 0 ) ; } else { if ( ! ( b & 1 ) ) return ( ( n - 1 ) % 3 != 0 ) ; else return ( ( n + 1 ) % 3 != 0 ) ; } }
string getCount ( int N ) { if ( N % 2 == 1 ) return 0 ; string result = "9" ; for ( int i = 1 ; i <= N / 2 - 1 ; i ++ ) result += "0" ; return result ; }
int longOddEvenIncSeq ( int arr [ ] , int n ) { int lioes [ n ] ; int maxLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) lioes [ i ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && ( arr [ i ] + arr [ j ] ) % 2 != 0 && lioes [ i ] < lioes [ j ] + 1 ) lioes [ i ] = lioes [ j ] + 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( maxLen < lioes [ i ] ) maxLen = lioes [ i ] ; return maxLen ; }
void rad ( double d , double h ) { cout << " The ▁ radius ▁ of ▁ the ▁ circle ▁ is ▁ " << ( ( d * d ) / ( 8 * h ) + h / 2 ) << endl ; }
void printAllAPTriplets ( int arr [ ] , int n ) { unordered_set < int > s ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int diff = arr [ j ] - arr [ i ] ; if ( s . find ( arr [ i ] - diff ) != s . end ( ) ) cout << arr [ i ] - diff << " ▁ " << arr [ i ] << " ▁ " << arr [ j ] << endl ; } s . insert ( arr [ i ] ) ; } }
float sumOfSeries ( int x , int k ) { return ( float ( x ) / 81 ) * ( 9 * k - 1 + pow ( 10 , ( -1 ) * k ) ) ; }
int binaryToDecimal ( int n ) { int num = n ; int dec_value = 0 ; int base = 1 ; int temp = num ; while ( temp ) { int last_digit = temp % 10 ; temp = temp / 10 ; dec_value += last_digit * base ; base = base * 2 ; } return dec_value ; }
int nobleInteger ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) continue ; if ( arr [ i ] == n - i - 1 ) return arr [ i ] ; } if ( arr [ n - 1 ] == 0 ) return arr [ n - 1 ] ; return -1 ; }
int pad ( int n ) { int pPrevPrev = 1 , pPrev = 1 , pCurr = 1 , pNext = 1 ; for ( int i = 3 ; i <= n ; i ++ ) { pNext = pPrevPrev + pPrev ; pPrevPrev = pPrev ; pPrev = pCurr ; pCurr = pNext ; } return pNext ; }
void findSubsequence ( string str , int k ) { int a [ MAX_CHAR ] = { 0 } ; for ( int i = 0 ; i < str . size ( ) ; i ++ ) a [ str [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < l ; i ++ ) if ( a [ str [ i ] - ' a ' ] >= k ) cout << str [ i ] ; }
int count_square ( int n ) { int count = 0 ; for ( int i = 1 ; i <= n ; i = i + 2 ) { int k = n - i + 1 ; count += ( k * k ) ; } return count ; }
int countTriplets ( int arr [ ] , int n , int m ) { int count = 0 ; sort ( arr , arr + n ) ; int end , start , mid ; for ( end = n - 1 ; end >= 2 ; end -- ) { int start = 0 , mid = end - 1 ; while ( start < mid ) { long int prod = arr [ end ] * arr [ start ] * arr [ mid ] ; if ( prod > m ) mid -- ; else if ( prod < m ) start ++ ; else if ( prod == m ) { count ++ ; mid -- ; start ++ ; } } } return count ; }
double calculateArea ( int x , int y ) { double pi = 3.1415926536 ; double arx = pi * x * x ; double ary = pi * y * y ; return arx - ary ; }
void maxMin ( int arr [ ] [ MAX ] , int n ) { int min = INT_MAX ; int max = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j <= n / 2 ; j ++ ) { if ( arr [ i ] [ j ] > arr [ i ] [ n - j - 1 ] ) { if ( min > arr [ i ] [ n - j - 1 ] ) min = arr [ i ] [ n - j - 1 ] ; if ( max < arr [ i ] [ j ] ) max = arr [ i ] [ j ] ; } else { if ( min > arr [ i ] [ j ] ) min = arr [ i ] [ j ] ; if ( max < arr [ i ] [ n - j - 1 ] ) max = arr [ i ] [ n - j - 1 ] ; } } } cout << " Maximum ▁ = ▁ " << max << " , ▁ Minimum ▁ = ▁ " << min ; }
bool checkFittingArrays ( int A [ ] , int B [ ] , int N ) { sort ( A , A + N ) ; sort ( B , B + N ) ; for ( int i = 0 ; i < N ; i ++ ) if ( A [ i ] > B [ i ] ) return false ; return true ; }
int printTrib ( int n ) { int dp [ n ] ; dp [ 0 ] = dp [ 1 ] = 0 ; dp [ 2 ] = 1 ; for ( int i = 3 ; i < n ; i ++ ) dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] + dp [ i - 3 ] ; for ( int i = 0 ; i < n ; i ++ ) cout << dp [ i ] << " ▁ " ; }
bool isUnique ( int a [ ] , int n , int k ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += a [ i ] ; sum += n - 1 ; return ( sum == k ) ; }
int nthTerm ( int n ) { return 2 * pow ( n , 2 ) + 4 * n - 2 ; }
void printSquares ( int n ) { int square = 0 , odd = 1 ; for ( int x = 0 ; x < n ; x ++ ) { cout << square << " ▁ " ; square = square + odd ; odd = odd + 2 ; } }
int pentagon_pyramidal ( int n ) { return n * n * ( n + 1 ) / 2 ; }
int oddEquivalent ( string s , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == '1' ) count ++ ; } return count ; }
int countWays ( int index , int cnt , int dp [ ] [ max ] , int n , int m , int k ) { if ( index == n ) { if ( cnt == k ) return 1 ; else return 0 ; } if ( dp [ index ] [ cnt ] != -1 ) return dp [ index ] [ cnt ] ; int ans = 0 ; ans += countWays ( index + 1 , cnt , dp , n , m , k ) ; ans += ( m - 1 ) * countWays ( index + 1 , cnt + 1 , dp , n , m , k ) ; return dp [ index ] [ cnt ] = ans ; }
float polyarea ( float n , float a ) { if ( a < 0 && n < 0 ) return -1 ; float A = ( a * a * n ) / ( 4 * tan ( ( 180 / n ) * 3.14159 / 180 ) ) ; return A ; }
int countSol ( int coeff [ ] , int start , int end , int rhs ) { if ( rhs == 0 ) return 1 ; int result = 0 ; for ( int i = start ; i <= end ; i ++ ) if ( coeff [ i ] <= rhs ) result += countSol ( coeff , i , end , rhs - coeff [ i ] ) ; return result ; }
int findMaximumPieces ( int n ) { int x = n / 2 ; return ( ( x + 1 ) * ( n - x + 1 ) ) ; }
int nthTerm ( int n ) { return 6 * pow ( n , 2 ) - 4 * n - 2 ; }
bool isSurd ( int n ) { for ( int i = 2 ; i * i <= n ; i ++ ) { int j = i ; while ( j < n ) j = j * i ; if ( j == n ) return false ; } return true ; }
void swap ( int a , int b , int c , int d ) { a = a + b ; b = a - b ; a = a - b ; b = b + c ; c = b - c ; b = b - c ; c = c + d ; d = c - d ; c = c - d ; cout << " values ▁ after ▁ swapping ▁ are ▁ : ▁ " << endl ; cout << " a ▁ = ▁ " << a << endl ; cout << " b ▁ = ▁ " << b << endl ; cout << " c ▁ = ▁ " << c << endl ; cout << " d ▁ = ▁ " << d << endl ; }
bool checkPronic ( int x ) { for ( int i = 0 ; i <= ( int ) ( sqrt ( x ) ) ; i ++ ) if ( x == i * ( i + 1 ) ) return true ; return false ; }
int FindMaxSum ( vector < int > arr , int n ) { int incl = arr [ 0 ] ; int excl = 0 ; int excl_new ; int i ; for ( i = 1 ; i < n ; i ++ ) { excl_new = ( incl > excl ) ? incl : excl ; incl = excl + arr [ i ] ; excl = excl_new ; } return ( ( incl > excl ) ? incl : excl ) ; }
int maxGameByWinner ( int N ) { int dp [ N ] ; dp [ 0 ] = 1 ; dp [ 1 ] = 2 ; int i = 2 ; do { dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] ; } while ( dp [ i ++ ] <= N ) ; return ( i - 2 ) ; }
float Area ( float r ) { if ( r < 0 ) return -1 ; float x = ( 2 * r ) / sqrt ( 5 ) ; float A = 0.70477 * pow ( x , 2 ) ; return A ; }
int findAnswer ( int X , int N ) { return ( N - 1 ) * 9 + X ; }
bool checkPandigital ( int b , char n [ ] ) { if ( strlen ( n ) < b ) return false ; bool hash [ b ] ; memset ( hash , false , sizeof ( hash ) ) ; for ( int i = 0 ; i < strlen ( n ) ; i ++ ) { if ( n [ i ] >= '0' && n [ i ] <= '9' ) hash [ n [ i ] - '0' ] = true ; else if ( n [ i ] - ' A ' <= b - 11 ) hash [ n [ i ] - ' A ' + 10 ] = true ; } for ( int i = 0 ; i < b ; i ++ ) if ( hash [ i ] == false ) return false ; return true ; }
int maxSumIS ( int arr [ ] , int n ) { int i , j , max = 0 ; int msis [ n ] ; for ( i = 0 ; i < n ; i ++ ) msis [ i ] = arr [ i ] ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && msis [ i ] < msis [ j ] + arr [ i ] ) msis [ i ] = msis [ j ] + arr [ i ] ; for ( i = 0 ; i < n ; i ++ ) if ( max < msis [ i ] ) max = msis [ i ] ; return max ; }
void findCommon ( int ar1 [ ] , int ar2 [ ] , int ar3 [ ] , int n1 , int n2 , int n3 ) { int i = 0 , j = 0 , k = 0 ; while ( i < n1 && j < n2 && k < n3 ) { if ( ar1 [ i ] == ar2 [ j ] && ar2 [ j ] == ar3 [ k ] ) { cout << ar1 [ i ] << " ▁ " ; i ++ ; j ++ ; k ++ ; } else if ( ar1 [ i ] < ar2 [ j ] ) i ++ ; else if ( ar2 [ j ] < ar3 [ k ] ) j ++ ; else k ++ ; } }
int answerQuery ( int a [ ] , int n , int l , int r ) { int count = 0 ; l = l - 1 ; for ( int i = l ; i < r ; i ++ ) { int element = a [ i ] ; int divisors = 0 ; for ( int j = l ; j < r ; j ++ ) { if ( a [ j ] % a [ i ] == 0 ) divisors ++ ; else break ; } if ( divisors == ( r - l ) ) count ++ ; } return count ; }
int productAtKthLevel ( string tree , int k ) { int level = -1 ; int n = tree . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( tree [ i ] == ' ( ' ) level ++ ; else if ( tree [ i ] == ' ) ' ) level -- ; else { if ( level == k ) product *= ( tree [ i ] - '0' ) ; } } return product ; }
int Cycles ( int N ) { int fact = 1 , result = 0 ; result = N - 1 ; int i = result ; while ( i > 0 ) { fact = fact * i ; i -- ; } return fact / 2 ; }
void findFourElements ( int A [ ] , int n , int X ) { for ( int i = 0 ; i < n - 3 ; i ++ ) { for ( int j = i + 1 ; j < n - 2 ; j ++ ) { for ( int k = j + 1 ; k < n - 1 ; k ++ ) { for ( int l = k + 1 ; l < n ; l ++ ) if ( A [ i ] + A [ j ] + A [ k ] + A [ l ] == X ) cout << A [ i ] << " , ▁ " << A [ j ] << " , ▁ " << A [ k ] << " , ▁ " << A [ l ] ; } } } }
int minOperations ( string s , string t , int n ) { int ct0 = 0 , ct1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == t [ i ] ) continue ; if ( s [ i ] == '0' ) ct0 ++ ; else ct1 ++ ; } return max ( ct0 , ct1 ) ; }
int countOfBinaryNumberLessThanN ( int N ) { queue < int > q ; q . push ( 1 ) ; int cnt = 0 ; int t ; while ( ! q . empty ( ) ) { t = q . front ( ) ; q . pop ( ) ; if ( t <= N ) { cnt ++ ; q . push ( t * 10 ) ; q . push ( t * 10 + 1 ) ; } } return cnt ; }
int countPairs ( int a [ ] , int n , int k ) { sort ( a , a + n ) ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int j = i + 1 ; while ( j < n && a [ j ] - a [ i ] < k ) { res ++ ; j ++ ; } } return res ; }
int findMinRooms ( string slots [ ] , int n , int m ) { int counts [ m ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( slots [ i ] [ j ] == '1' ) counts [ j ] ++ ; return * max_element ( counts , counts + m ) ; }
int minimumLength ( int x , int y , int z ) { return 1 + abs ( x - y ) + abs ( y - z ) ; }
int find_greatest_divisor ( int l , int r ) { if ( l == r ) return l ; return 1 ; }
int lbs ( int arr [ ] , int n ) { int i , j ; int * lis = new int [ n ] ; for ( i = 0 ; i < n ; i ++ ) lis [ i ] = 1 ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; int * lds = new int [ n ] ; for ( i = 0 ; i < n ; i ++ ) lds [ i ] = 1 ; for ( i = n - 2 ; i >= 0 ; i -- ) for ( j = n - 1 ; j > i ; j -- ) if ( arr [ i ] > arr [ j ] && lds [ i ] < lds [ j ] + 1 ) lds [ i ] = lds [ j ] + 1 ; int max = lis [ 0 ] + lds [ 0 ] - 1 ; for ( i = 1 ; i < n ; i ++ ) if ( lis [ i ] + lds [ i ] - 1 > max ) max = lis [ i ] + lds [ i ] - 1 ; return max ; }
int countWays ( int n , int m ) { int count [ n + 1 ] ; count [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i > m ) count [ i ] = count [ i - 1 ] + count [ i - m ] ; else if ( i < m i == 1 ) count [ i ] = 1 ; else count [ i ] = 2 ; } return count [ n ] ; }
int catalanDP ( unsigned int n ) { unsigned long int catalan [ n + 1 ] ; catalan [ 0 ] = catalan [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { catalan [ i ] = 0 ; for ( int j = 0 ; j < i ; j ++ ) catalan [ i ] += catalan [ j ] * catalan [ i - j - 1 ] ; } return catalan [ n ] ; }
int getQuadrant ( int X , int Y , int R , int PX , int PY ) { if ( PX == X && PY == Y ) return 0 ; int val = pow ( ( PX - X ) , 2 ) + pow ( ( PY - Y ) , 2 ) ; if ( val > pow ( R , 2 ) ) return -1 ; if ( PX > X && PY >= Y ) return 1 ; if ( PX <= X && PY > Y ) return 2 ; if ( PX < X && PY <= Y ) return 3 ; if ( PX >= X && PY < Y ) return 4 ; }
float decdiagonal ( float a ) { if ( a < 0 ) return -1 ; float d = 1.902 * a ; return d ; }
void shortest_distance ( float x1 , float y1 , float z1 , float a , float b , float c , float d ) { d = fabs ( ( a * x1 + b * y1 + c * z1 + d ) ) ; float e = sqrt ( a * a + b * b + c * c ) ; cout << " Perpendicular ▁ distance ▁ is ▁ " << ( d / e ) ; return ; }
int findGreatest ( int arr [ ] , int n ) { int result = -1 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n - 1 ; j ++ ) for ( int k = j + 1 ; k < n ; k ++ ) if ( arr [ j ] * arr [ k ] == arr [ i ] ) result = max ( result , arr [ i ] ) ; return result ; }
int findCount ( string str1 , string str2 ) { int len = str1 . size ( ) ; int len2 = str2 . size ( ) ; int ans = INT_MAX ; int hash1 [ 26 ] = { 0 } , hash2 [ 26 ] = { 0 } ; for ( int i = 0 ; i < len ; i ++ ) hash1 [ str1 [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < len2 ; i ++ ) hash2 [ str2 [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < 26 ; i ++ ) if ( hash2 [ i ] ) ans = min ( ans , hash1 [ i ] / hash2 [ i ] ) ; return ans ; }
int difference ( int arr [ ] [ MAX ] , int n ) { int d1 = 0 , d2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { d1 += arr [ i ] [ i ] ; d2 += arr [ i ] [ n - i - 1 ] ; } return abs ( d1 - d2 ) ; }
int minimumLectures ( int m , int n ) { int ans = 0 ; if ( n < ( int ) ceil ( 0.75 * m ) ) ans = ( int ) ceil ( ( ( 0.75 * m ) - n ) / 0.25 ) ; else ans = 0 ; return ans ; }
bool func ( int a [ ] , int k , int n ) { for ( int i = 0 ; i < n ; i ++ ) if ( a [ i ] % k == 0 ) return true ; return false ; }
float circlearea ( float a , float b ) { if ( a < 0 b < 0 ) return -1 ; float A = ( 3.14 * pow ( a , 2 ) * pow ( b , 2 ) ) / ( 4 * ( pow ( a , 2 ) + pow ( b , 2 ) ) ) ; return A ; }
int minDiff ( int arr [ ] , int n , int k ) { int result = INT_MAX ; sort ( arr , arr + n ) ; for ( int i = 0 ; i <= n - k ; i ++ ) result = min ( result , arr [ i + k - 1 ] - arr [ i ] ) ; return result ; }
int Square ( int row , int column , int moves ) { int a = 0 , b = 0 , c = 0 , d = 0 , total = 0 ; a = row - moves ; b = row + moves ; c = column - moves ; d = column + moves ; if ( a < 1 ) a = 1 ; if ( c < 1 ) c = 1 ; if ( b > 8 ) b = 8 ; if ( d > 8 ) d = 8 ; total = ( b - a + 1 ) * ( d - c + 1 ) - 1 ; return total ; }
int findOccurrences ( string str , string substr ) { int counter = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] == substr [ 0 ] ) { for ( int j = i + 1 ; j < str . length ( ) ; j ++ ) { if ( str [ j ] == substr [ 1 ] ) { for ( int k = j + 1 ; k < str . length ( ) ; k ++ ) { if ( str [ k ] == substr [ 2 ] ) counter ++ ; } } } } } return counter ; }
int nswp ( int n ) { int dp [ n + 1 ] ; dp [ 0 ] = dp [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) dp [ i ] = 2 * dp [ i - 1 ] + dp [ i - 2 ] ; return dp [ n ] ; }
void divide ( int a , int b ) { for ( int i = 2 ; i <= min ( a , b ) ; i ++ ) { while ( a % i == 0 && b % i == 0 ) { a = a / i ; b = b / i ; } } cout << " A ▁ = ▁ " << a << " , ▁ B ▁ = ▁ " << b << endl ; }
int SubArraySum ( int arr [ ] , int n ) { long int result = 0 , temp = 0 ; for ( int i = 0 ; i < n ; i ++ ) { temp = 0 ; for ( int j = i ; j < n ; j ++ ) { temp += arr [ j ] ; result += temp ; } } return result ; }
