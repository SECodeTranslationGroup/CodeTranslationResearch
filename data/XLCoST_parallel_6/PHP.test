function checkIsAP ( $ arr , $ n ) { if ( $ n == 1 ) return true ; sort ( $ arr ) ; $ d = $ arr [ 1 ] - $ arr [ 0 ] ; for ( $ i = 2 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] - $ arr [ $ i - 1 ] != $ d ) return false ; return true ; }
function longestSubArray ( $ arr , $ n ) { $ isZeroPresent = false ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] == 0 ) { $ isZeroPresent = true ; break ; } } if ( $ isZeroPresent ) return $ n ; return 0 ; }
function F ( $ A , $ B ) { if ( $ A == 1 ) return ( 4 % $ B ) ; else { $ temp = F ( $ A - 1 , $ B ) ; return ( $ temp * $ temp ) % $ B ; } }
function sentencePalindrome ( $ str ) { $ l = 0 ; $ h = strlen ( $ str ) - 1 ; for ( $ i = 0 ; $ i < $ h ; $ i ++ ) $ str [ $ i ] = strtolower ( $ str [ $ i ] ) ; while ( $ l <= $ h ) { if ( ! ( $ str [ $ l ] >= ' a ' && $ str [ $ l ] <= ' z ' ) ) $ l ++ ; else if ( ! ( $ str [ $ h ] >= ' a ' && $ str [ $ h ] <= ' z ' ) ) $ h -- ; else if ( $ str [ $ l ] == $ str [ $ h ] ) { $ l ++ ; $ h -- ; } else return false ; } return true ; }
function Calculate_GST ( $ org_cost , $ N_price ) { return ( ( ( $ N_price - $ org_cost ) * 100 ) / $ org_cost ) ; }
function FindPoints ( $ x1 , $ y1 , $ x2 , $ y2 , $ x3 , $ y3 , $ x4 , $ y4 ) { $ x5 = max ( $ x1 , $ x3 ) ; $ y5 = max ( $ y1 , $ y3 ) ; $ x6 = min ( $ x2 , $ x4 ) ; $ y6 = min ( $ y2 , $ y4 ) ; if ( $ x5 > $ x6 $ y5 > $ y6 ) { echo " No ▁ intersection " ; return ; } echo " ( " . $ x5 . " , " ▁ . ▁ $ y5 ▁ . ▁ " ) " ; echo " ( " . $ x6 . " , " ▁ . ▁ $ y6 ▁ . ▁ " ) " ; $ x7 = $ x5 ; $ y7 = $ y6 ; echo " ( " . $ x7 . " , " ▁ . ▁ $ y7 ▁ . ▁ " ) " ; $ x8 = $ x6 ; $ y8 = $ y5 ; echo " ( " . $ x8 . " , " ▁ . ▁ $ y8 ▁ . ▁ " ) " ; }
function maxSum ( $ mat , $ n ) { if ( $ n == 1 ) return $ mat [ 0 ] [ 0 ] ; $ dp = array ( array ( ) ) ; $ maxSum = PHP_INT_MIN ; $ max ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) $ dp [ $ n - 1 ] [ $ j ] = $ mat [ $ n - 1 ] [ $ j ] ; for ( $ i = $ n - 2 ; $ i >= 0 ; $ i -- ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { $ max = PHP_INT_MIN ; if ( ( ( $ j - 1 ) >= 0 ) and ( $ max < $ dp [ $ i + 1 ] [ $ j - 1 ] ) ) $ max = $ dp [ $ i + 1 ] [ $ j - 1 ] ; if ( ( ( $ j + 1 ) < $ n ) and ( $ max < $ dp [ $ i + 1 ] [ $ j + 1 ] ) ) $ max = $ dp [ $ i + 1 ] [ $ j + 1 ] ; $ dp [ $ i ] [ $ j ] = $ mat [ $ i ] [ $ j ] + $ max ; } } for ( $ j = 0 ; $ j < $ n ; $ j ++ ) if ( $ maxSum < $ dp [ 0 ] [ $ j ] ) $ maxSum = $ dp [ 0 ] [ $ j ] ; return $ maxSum ; }
function pell ( $ n ) { if ( $ n <= 2 ) return $ n ; return 2 * pell ( $ n - 1 ) + pell ( $ n - 2 ) ; }
function testSomeNumbers ( $ limit , $ n ) { if ( $ n < 3 ) for ( $ a = 1 ; $ a <= $ limit ; $ a ++ ) for ( $ b = $ a ; $ b <= $ limit ; $ b ++ ) { $ pow_sum = pow ( $ a , $ n ) + pow ( $ b , $ n ) ; $ c = pow ( $ pow_sum , 1.0 / $ n ) ; $ c_pow = pow ( $ c , $ n ) ; if ( $ c_pow != $ pow_sum ) { echo " Count ▁ example ▁ found " ; return ; } } echo " No ▁ counter ▁ example ▁ within ▁ " . " given ▁ range ▁ and ▁ data " ; }
function find3Numbers ( $ A , $ arr_size , $ sum ) { $ l ; $ r ; for ( $ i = 0 ; $ i < $ arr_size - 2 ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ arr_size - 1 ; $ j ++ ) { for ( $ k = $ j + 1 ; $ k < $ arr_size ; $ k ++ ) { if ( $ A [ $ i ] + $ A [ $ j ] + $ A [ $ k ] == $ sum ) { echo " Triplet ▁ is " , " ▁ " , $ A [ $ i ] , " , ▁ " , $ A [ $ j ] , " , ▁ " , $ A [ $ k ] ; return true ; } } } } return false ; }
function ways ( $ n ) { $ first = 2 ; $ second = 3 ; $ res = 0 ; for ( $ i = 3 ; $ i <= $ n ; $ i ++ ) { $ res = $ first + $ second ; $ first = $ second ; $ second = $ res ; } return $ res ; }
function pentdiagonal ( $ a ) { if ( $ a < 0 ) return -1 ; $ d = 1.22 * $ a ; return $ d ; }
function evenNumSubstring ( $ str ) { $ len = strlen ( $ str ) ; $ count = 0 ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { $ temp = $ str [ $ i ] - '0' ; if ( $ temp % 2 == 0 ) $ count += ( $ i + 1 ) ; } return $ count ; }
function divisorSum ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; ++ $ i ) $ sum += floor ( $ n / $ i ) * $ i ; return $ sum ; }
function isPerfectSquareString ( $ str ) { $ sum = 0 ; $ len = strlen ( $ str ) ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) $ sum += ( int ) $ str [ $ i ] ; $ squareRoot = sqrt ( $ sum ) ; return ( ( $ squareRoot - floor ( $ squareRoot ) ) == 0 ) ; }
function kthSmallest ( $ n , $ k ) { return ( 2 * $ k ) ; }
function MinOfCubed ( $ k ) { if ( $ k < 8 ) return $ k ; $ res = $ k ; for ( $ i = 1 ; $ i <= $ k ; $ i ++ ) { if ( ( $ i * $ i * $ i ) > $ k ) return $ res ; $ res = min ( $ res , MinOfCubed ( $ k - ( $ i * $ i * $ i ) ) + 1 ) ; } return $ res ; }
function StepstoReachTarget ( $ target ) { $ target = abs ( $ target ) ; $ n = ceil ( ( -1.0 + sqrt ( 1 + 8.0 * $ target ) ) / 2 ) ; $ sum = $ n * ( $ n + 1 ) / 2 ; if ( $ sum == $ target ) return $ n ; $ d = $ sum - $ target ; if ( ( $ d & 1 ) == 0 ) return n ; else return $ n + ( ( $ n & 1 ) ? 2 : 1 ) ; }
function findAreaShaded ( $ a ) { $ sqArea = $ a * $ a ; $ semiCircleArea = ( 3.14 * ( $ a * $ a ) / 8 ) ; $ ShadedArea = 4 * $ semiCircleArea - $ sqArea ; return $ ShadedArea ; }
function findNth ( $ n ) { $ count = 0 ; for ( $ curr = 19 ; ; $ curr += 9 ) { $ sum = 0 ; for ( $ x = $ curr ; $ x > 0 ; $ x = ( int ) $ x / 10 ) $ sum = $ sum + $ x % 10 ; if ( $ sum == 10 ) $ count ++ ; if ( $ count == $ n ) return $ curr ; } return -1 ; }
function numberOfPaths ( $ m , $ n ) { $ path = 1 ; for ( $ i = $ n ; $ i < ( $ m + $ n - 1 ) ; $ i ++ ) { $ path *= $ i ; $ path /= ( $ i - $ n + 1 ) ; } return $ path ; } { echo ( numberOfPaths ( 3 , 3 ) ) ; }
function maxSum ( $ arr , $ i , $ n ) { if ( $ i >= $ n ) return 0 ; if ( $ GLOBALS [ ' v ' ] [ $ i ] ) return $ GLOBALS [ ' dp ' ] [ $ i ] ; $ GLOBALS [ ' v ' ] [ $ i ] = 1 ; $ GLOBALS [ ' dp ' ] [ $ i ] = max ( maxSum ( $ arr , $ i + 1 , $ n ) , $ arr [ $ i ] + maxSum ( $ arr , $ i + 2 , $ n ) ) ; return $ GLOBALS [ ' dp ' ] [ $ i ] ; }
function maxLines ( $ n , $ x1 , $ y1 , $ x2 , $ y2 ) { $ s = array ( ) ; $ slope ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { if ( $ x1 [ $ i ] == $ x2 [ $ i ] ) $ slope = PHP_INT_MAX ; else $ slope = ( $ y2 [ $ i ] - $ y1 [ $ i ] ) * 1.0 / ( $ x2 [ $ i ] - $ x1 [ $ i ] ) * 1.0 ; array_push ( $ s , $ slope ) ; } return count ( $ s ) ; }
function findSum ( $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum += $ i * ( $ n - $ i ) ; return 2 * $ sum ; }
function areaOctagon ( $ side ) { return ( 2 * ( 1 + sqrt ( 2 ) ) * $ side * $ side ) ; }
function pairwiseDifference ( $ arr , $ n ) { $ diff = 0 ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { $ diff = abs ( $ arr [ $ i ] - $ arr [ $ i + 1 ] ) ; echo $ diff . " " ; } }
function minDiff ( $ n , $ x , $ A ) { $ mn = $ A [ 0 ] ; $ mx = $ A [ 0 ] ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { $ mn = min ( $ mn , $ A [ $ i ] ) ; $ mx = max ( $ mx , $ A [ $ i ] ) ; } return max ( 0 , $ mx - $ mn - 2 * $ x ) ; }
function findFirstMissing ( $ array , $ start , $ end ) { if ( $ start > $ end ) return $ end + 1 ; if ( $ start != $ array [ $ start ] ) return $ start ; $ mid = ( $ start + $ end ) / 2 ; if ( $ array [ $ mid ] == $ mid ) return findFirstMissing ( $ array , $ mid + 1 , $ end ) ; return findFirstMissing ( $ array , $ start , $ mid ) ; }
function solve ( $ idx , $ diff , $ N , $ M , $ K ) { global $ dp , $ MOD ; if ( $ idx > $ N ) { if ( $ diff == $ K ) return 1 ; return 0 ; } if ( $ dp [ $ idx ] [ $ diff ] != -1 ) return $ dp [ $ idx ] [ $ diff ] ; $ ans = solve ( $ idx + 1 , $ diff , $ N , $ M , $ K ) ; $ ans += ( $ M - 1 ) * solve ( $ idx + 1 , $ diff + 1 , $ N , $ M , $ K ) ; return $ dp [ $ idx ] [ $ diff ] = $ ans % $ MOD ; }
function minNum ( $ arr , $ n ) { $ odd = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] % 2 ) $ odd += 1 ; return ( $ odd % 2 ) ? 1 : 2 ; }
function encryptString ( $ str , $ n ) { $ i = 0 ; $ cnt = 0 ; $ encryptedStr = " " ; while ( $ i < $ n ) { $ cnt = $ i + 1 ; while ( $ cnt -- ) $ encryptedStr . = $ str [ $ i ] ; $ i ++ ; } return $ encryptedStr ; }
function calcFunction ( $ n , $ r ) { $ finalDenominator = 1 ; $ mx = max ( $ r , $ n - $ r ) ; for ( $ i = $ mx + 1 ; $ i <= $ n ; $ i ++ ) { $ denominator = pow ( $ i , $ i ) ; $ numerator = pow ( $ i - $ mx , $ i - $ mx ) ; $ finalDenominator = ( $ finalDenominator * $ denominator ) / $ numerator ; } return $ finalDenominator ; }
function maxSum ( $ a , $ n ) { $ ans = 0 ; $ arr = array ( ) ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ arr [ $ i ] = $ a [ $ i - 1 ] ; $ dp = array ( array ( ) ) ; for ( $ i = 1 ; $ i <= $ n ; ++ $ i ) { $ dp [ $ i ] [ 0 ] = max ( $ arr [ $ i ] , $ dp [ $ i - 1 ] [ 0 ] + $ arr [ $ i ] ) ; $ dp [ $ i ] [ 1 ] = max ( 0 , $ dp [ $ i - 1 ] [ 0 ] ) - $ arr [ $ i ] ; if ( $ i >= 2 ) $ dp [ $ i ] [ 1 ] = max ( $ dp [ $ i ] [ 1 ] , $ dp [ $ i - 1 ] [ 1 ] + $ arr [ $ i ] ) ; if ( $ i >= 2 ) $ dp [ $ i ] [ 2 ] = $ dp [ $ i - 1 ] [ 1 ] - $ arr [ $ i ] ; if ( $ i >= 3 ) $ dp [ $ i ] [ 2 ] = max ( $ dp [ $ i ] [ 2 ] , $ dp [ $ i - 1 ] [ 2 ] + $ arr [ $ i ] ) ; $ ans = max ( $ ans , $ dp [ $ i ] [ 0 ] ) ; $ ans = max ( $ ans , $ dp [ $ i ] [ 1 ] ) ; $ ans = max ( $ ans , $ dp [ $ i ] [ 2 ] ) ; } return $ ans ; }
function findAllSequence ( $ N ) { if ( $ N % 2 == 0 ) { return pow ( 2 , $ N / 2 + 1 ) + pow ( 2 , $ N / 2 ) - 2 ; } else { return pow ( 2 , ( $ N + 1 ) / 2 ) + pow ( 2 , ( $ N + 1 ) / 2 ) - 2 ; } }
function binarySearch ( $ arr , $ left , $ right ) { if ( $ left <= $ right ) { $ mid = ( $ left + $ right ) / 2 ; if ( $ arr [ $ mid - 1 ] < $ arr [ $ mid ] && $ arr [ $ mid ] > $ arr [ $ mid + 1 ] ) return $ mid ; if ( $ arr [ $ mid ] < $ arr [ $ mid + 1 ] ) return binarySearch ( $ arr , $ mid + 1 , $ right ) ; else return binarySearch ( $ arr , $ left , $ mid - 1 ) ; } return -1 ; }
function isDvisibleBy12 ( $ num ) { if ( strlen ( $ num ) >= 3 ) { $ d1 = ( int ) $ num [ strlen ( $ num ) - 1 ] ; if ( $ d1 % 2 != 0 ) return ( 0 ) ; $ d2 = ( int ) $ num [ strlen ( $ num ) - 2 ] ; $ sum = 0 ; for ( $ i = 0 ; $ i < strlen ( $ num ) ; $ i ++ ) $ sum += $ num [ $ i ] ; return ( $ sum % 3 == 0 && ( $ d2 * 10 + $ d1 ) % 4 == 0 ) ; } else { $ number = stoi ( $ num ) ; return ( $ number % 12 == 0 ) ; } }
function printPascal ( $ n ) { for ( $ line = 1 ; $ line <= $ n ; $ line ++ ) { $ C = 1 ; for ( $ i = 1 ; $ i <= $ line ; $ i ++ ) { print ( $ C . " " ) ; $ C = $ C * ( $ line - $ i ) / $ i ; } print ( " STRNEWLINE " ) ; } }
function square ( $ n ) { if ( $ n < 0 ) $ n = - $ n ; $ res = $ n ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ res += $ n ; return $ res ; }
function number_of_tower ( $ house , $ range , $ n ) { sort ( $ house ) ; $ numOfTower = 0 ; $ i = 0 ; while ( $ i < $ n ) { $ numOfTower ++ ; $ loc = $ house [ $ i ] + $ range ; while ( $ i < $ n && $ house [ $ i ] <= $ loc ) $ i ++ ; -- $ i ; $ loc = $ house [ $ i ] + $ range ; while ( $ i < $ n && $ house [ $ i ] <= $ loc ) $ i ++ ; } return $ numOfTower ; }
function reArrange ( $ words , $ n ) { $ freq = array ( ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ freq [ $ words [ $ i ] ] = ( $ i + 1 ) ; } sort ( $ words ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ freq [ $ words [ $ i ] ] , " ▁ " ; }
function rearrange ( & $ a , $ size ) { $ positive = 0 ; $ negative = 1 ; while ( true ) { while ( $ positive < $ size && $ a [ $ positive ] >= 0 ) $ positive += 2 ; while ( $ negative < $ size && $ a [ $ negative ] <= 0 ) $ negative += 2 ; if ( $ positive < $ size && $ negative < $ size ) { $ temp = $ a [ $ positive ] ; $ a [ $ positive ] = $ a [ $ negative ] ; $ a [ $ negative ] = $ temp ; } else break ; } }
function countDe ( $ arr , $ n ) { $ v = $ arr ; sort ( $ arr ) ; $ count1 = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] != $ v [ $ i ] ) $ count1 ++ ; rsort ( $ arr ) ; $ count2 = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] != $ v [ $ i ] ) $ count2 ++ ; return ( min ( $ count1 , $ count2 ) ) ; }
function SectorArea ( $ radius , $ angle ) { if ( $ angle >= 360 ) echo ( " Angle ▁ not ▁ possible " ) ; else { $ sector = ( ( 22 * $ radius * $ radius ) / 7 ) * ( $ angle / 360 ) ; echo ( $ sector ) ; } }
function results ( $ n , $ k ) { return round ( pow ( $ n , ( 1.0 / pow ( 2 , $ k ) ) ) ) ; }
function findRepeatFirstN2 ( $ s ) { $ p = -1 ; for ( $ i = 0 ; $ i < strlen ( $ s ) ; $ i ++ ) { for ( $ j = ( $ i + 1 ) ; $ j < strlen ( $ s ) ; $ j ++ ) { if ( $ s [ $ i ] == $ s [ $ j ] ) { $ p = $ i ; break ; } } if ( $ p != -1 ) break ; } return $ p ; }
function missingNumber ( $ arr1 , $ arr2 , $ n ) { $ mnum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ mnum = $ mnum ^ $ arr1 [ $ i ] ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) $ mnum = $ mnum ^ $ arr2 [ $ i ] ; return $ mnum ; }
function countSequences ( $ arr , $ n ) { $ count = 1 ; sort ( $ arr ) ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) if ( $ arr [ $ i ] + 1 != $ arr [ $ i + 1 ] ) $ count ++ ; return $ count ; }
function oddTriangularNumber ( $ N ) { return ( $ N * ( ( 2 * $ N ) - 1 ) ) ; }
function numberOfDistinct ( $ n ) { $ ans = 0 ; for ( $ i = 1 ; $ i <= sqrt ( $ n ) ; $ i ++ ) { if ( $ n % $ i == 0 ) { $ ans ++ ; if ( ( $ n / $ i ) != $ i ) $ ans ++ ; } } return $ ans ; }
function countBits ( $ number ) { return ( int ) ( log ( $ number ) / log ( 2 ) ) + 1 ; }
function countNumbers ( $ n ) { $ k = 0 ; $ count = 0 ; while ( $ n > 0 ) { if ( ( $ n & 1 ) == 0 ) $ count += pow ( 2 , $ k ) ; $ k += 1 ; $ n >>= 1 ; } return $ count ; }
function first ( $ str ) { for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) if ( ctype_upper ( $ str [ $ i ] ) ) { return $ str [ $ i ] ; } return 0 ; }
function center ( $ x1 , $ x2 , $ y1 , $ y2 ) { echo ( ( float ) ( $ x1 + $ x2 ) / 2 . " , ▁ " . ( float ) ( $ y1 + $ y2 ) / 2 ) ; }
function evenbinomialCoeffSum ( $ n ) { return ( 1 << ( $ n - 1 ) ) ; }
function multiply ( $ x , $ n ) { return $ x << $ n ; }
function Regions ( $ Vertices , $ Edges ) { $ R = $ Edges + 2 - $ Vertices ; return $ R ; }
function calculate ( $ n , $ power ) { $ sum = 0 ; $ bp = ( int ) pow ( $ n , $ power ) ; while ( $ bp != 0 ) { $ d = $ bp % 10 ; $ sum += $ d ; $ bp /= 10 ; } return $ sum ; }
function minimal ( $ a , $ n ) { $ lo = 0 ; $ hi = $ n - 1 ; while ( $ lo < $ hi ) { $ mid = ( $ lo + $ hi ) >> 1 ; if ( $ a [ $ mid ] < $ a [ $ mid + 1 ] ) { $ hi = $ mid ; } else { $ lo = $ mid + 1 ; } } return $ lo ; }
function fifthPowerSum ( $ n ) { return ( ( 2 * $ n * $ n * $ n * $ n * $ n * $ n ) + ( 6 * $ n * $ n * $ n * $ n * $ n ) + ( 5 * $ n * $ n * $ n * $ n ) - ( $ n * $ n ) ) / 12 ; }
function printTwoOdd ( $ arr , $ size ) { $ xor2 = $ arr [ 0 ] ; $ set_bit_no ; $ i ; $ n = $ size - 2 ; $ x = 0 ; $ y = 0 ; for ( $ i = 1 ; $ i < $ size ; $ i ++ ) $ xor2 = $ xor2 ^ $ arr [ $ i ] ; $ set_bit_no = $ xor2 & ~ ( $ xor2 - 1 ) ; for ( $ i = 0 ; $ i < $ size ; $ i ++ ) { if ( $ arr [ $ i ] & $ set_bit_no ) $ x = $ x ^ $ arr [ $ i ] ; else $ y = $ y ^ $ arr [ $ i ] ; } echo " The ▁ two ▁ ODD ▁ elements ▁ are ▁ " , $ x , " ▁ & ▁ " , $ y ; }
function minSum ( $ arr , $ n , $ x ) { $ sum = 0 ; $ largestDivisible = -1 ; $ minimum = $ arr [ 0 ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sum += $ arr [ $ i ] ; if ( $ arr [ $ i ] % $ x == 0 && $ largestDivisible < $ arr [ $ i ] ) $ largestDivisible = $ arr [ $ i ] ; if ( $ arr [ $ i ] < $ minimum ) $ minimum = $ arr [ $ i ] ; } if ( $ largestDivisible == -1 ) return $ sum ; $ sumAfterOperation = $ sum - $ minimum - $ largestDivisible + ( $ x * $ minimum ) + ( $ largestDivisible / $ x ) ; return min ( $ sum , $ sumAfterOperation ) ; }
function sum_of_series ( $ n ) { $ result = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { if ( $ i % 2 == 0 ) $ result = $ result - pow ( $ i , 2 ) ; else $ result = $ result + pow ( $ i , 2 ) ; } return $ result ; }
function FirstRepeated ( $ str ) { $ checker = 0 ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; ++ $ i ) { $ val = ( ord ( $ str [ $ i ] ) - ord ( ' a ' ) ) ; if ( ( $ checker & ( 1 << $ val ) ) > 0 ) return $ i ; $ checker |= ( 1 << $ val ) ; } return -1 ; }
function findMaxGuests ( $ arrl , $ exit , $ n ) { sort ( $ arrl ) ; sort ( $ exit ) ; $ guests_in = 1 ; $ max_guests = 1 ; $ time = $ arrl [ 0 ] ; $ i = 1 ; $ j = 0 ; while ( $ i < $ n and $ j < $ n ) { if ( $ arrl [ $ i ] <= $ exit [ $ j ] ) { $ guests_in ++ ; if ( $ guests_in > $ max_guests ) { $ max_guests = $ guests_in ; $ time = $ arrl [ $ i ] ; } $ i ++ ; } else { $ guests_in -- ; $ j ++ ; } } echo " Maximum ▁ Number ▁ of ▁ Guests ▁ = ▁ " , $ max_guests , " ▁ at ▁ time ▁ " , $ time ; }
function numberofways ( $ n , $ m ) { global $ MAX ; $ dp = array_fill ( 0 , $ n + 2 , array_fill ( 0 , $ n + 2 , NULL ) ) ; $ dp [ 0 ] [ $ n + 1 ] = 1 ; for ( $ k = $ n ; $ k >= $ m ; $ k -- ) { for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) { $ dp [ $ i ] [ $ k ] = $ dp [ $ i ] [ $ k + 1 ] ; if ( $ i - $ k >= 0 ) $ dp [ $ i ] [ $ k ] = ( $ dp [ $ i ] [ $ k ] + $ dp [ $ i - $ k ] [ $ k ] ) ; } } return $ dp [ $ n ] [ $ m ] ; }
function series ( $ n ) { return ( 8 * $ n * $ n ) + 1 ; }
function find ( $ p ) { return ceil ( sqrt ( 2 * 365 * log ( 1 / ( 1 - $ p ) ) ) ) ; }
function CalculateMax ( $ arr , $ n ) { sort ( $ arr ) ; $ min_sum = $ arr [ 0 ] + $ arr [ 1 ] ; $ max_sum = $ arr [ $ n - 1 ] + $ arr [ $ n - 2 ] ; return abs ( $ max_sum - $ min_sum ) ; }
function updateString ( $ S , $ A , $ B ) { $ l = strlen ( $ A ) ; for ( $ i = 0 ; $ i + $ l <= strlen ( $ S ) ; $ i ++ ) { $ curr = substr ( $ S , $ i , $ i + $ l ) ; if ( strcmp ( $ curr , $ A ) == 0 ) { $ new_string = substr ( $ S , 0 , $ i ) . $ B . substr ( $ S , $ i + $ l , strlen ( $ S ) ) ; $ S = $ new_string ; $ i += $ l - 1 ; } else { $ new_string = substr ( $ S , 0 , $ i ) . $ A . substr ( $ S , $ i + $ l , strlen ( $ S ) ) ; $ S = $ new_string ; $ i += $ l - 1 ; } } return $ S ; }
function MinimumMail ( $ n , $ k , $ x ) { $ m = ( $ n - 1 ) + ceil ( ( $ n - 1 ) * 1.0 / $ x ) * ( $ n - 1 ) + ceil ( $ n * 1.0 / $ x ) * ( $ k - $ n ) ; return $ m ; }
function countPairs ( $ N ) { $ count = 0 ; for ( $ i = 1 ; $ i <= ( int ) pow ( $ N , 1 / 3 ) ; $ i ++ ) { $ cb = $ i * $ i * $ i ; $ diff = ( $ N - $ cb ) ; $ cbrtDiff = ( int ) pow ( $ diff , 1 / 3 ) ; if ( $ cbrtDiff * $ cbrtDiff * $ cbrtDiff == $ diff ) $ count ++ ; } return $ count ; }
function pendulumArrangement ( $ arr , $ n ) { sort ( $ arr , $ n ) ; sort ( $ arr ) ; $ op [ $ n ] = NULL ; $ mid = floor ( ( $ n - 1 ) / 2 ) ; $ j = 1 ; $ i = 1 ; $ op [ $ mid ] = $ arr [ 0 ] ; for ( $ i = 1 ; $ i <= $ mid ; $ i ++ ) { $ op [ $ mid + $ i ] = $ arr [ $ j ++ ] ; $ op [ $ mid - $ i ] = $ arr [ $ j ++ ] ; } if ( $ n % 2 == 0 ) $ op [ $ mid + $ i ] = $ arr [ $ j ] ; echo " Pendulum ▁ arrangement : " ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ op [ $ i ] , " ▁ " ; echo " STRNEWLINE " ; }
function countDigit ( $ n ) { $ temp = $ n ; $ count = 0 ; while ( $ temp != 0 ) { $ d = $ temp % 10 ; $ temp /= 10 ; if ( $ d > 0 && $ n % $ d == 0 ) $ count ++ ; } return $ count ; }
function sum ( $ n ) { return $ n * ( $ n + 1 ) * ( $ n + 2 ) / 3 ; }
function maxLength ( $ s , $ n ) { $ dp = array_fill ( 0 , $ n , array_fill ( 0 , $ n , NULL ) ) ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) if ( $ s [ $ i ] == ' ( ' && $ s [ $ i + 1 ] == ' ) ' ) $ dp [ $ i ] [ $ i + 1 ] = 2 ; for ( $ l = 2 ; $ l < $ n ; $ l ++ ) { for ( $ i = 0 , $ j = $ l ; $ j < $ n ; $ i ++ , $ j ++ ) { if ( $ s [ $ i ] == ' ( ' && $ s [ $ j ] == ' ) ' ) $ dp [ $ i ] [ $ j ] = 2 + $ dp [ $ i + 1 ] [ $ j - 1 ] ; for ( $ k = $ i ; $ k < $ j ; $ k ++ ) $ dp [ $ i ] [ $ j ] = max ( $ dp [ $ i ] [ $ j ] , $ dp [ $ i ] [ $ k ] + $ dp [ $ k + 1 ] [ $ j ] ) ; } } return $ dp [ 0 ] [ $ n - 1 ] ; }
function countRotations ( $ arr , $ low , $ high ) { if ( $ high < $ low ) return 0 ; if ( $ high == $ low ) return $ low ; $ mid = $ low + ( $ high - $ low ) / 2 ; if ( $ mid < $ high && $ arr [ $ mid + 1 ] < $ arr [ $ mid ] ) return ( int ) ( $ mid + 1 ) ; if ( $ mid > $ low && $ arr [ $ mid ] < $ arr [ $ mid - 1 ] ) return ( int ) ( $ mid ) ; if ( $ arr [ $ high ] > $ arr [ $ mid ] ) return countRotations ( $ arr , $ low , $ mid - 1 ) ; return countRotations ( $ arr , $ mid + 1 , $ high ) ; }
function findKthGoodNo ( $ n ) { $ lastDig = $ n % 10 ; if ( $ lastDig >= 0 && $ lastDig <= 4 ) return $ n << 1 ; else return ( $ n << 1 ) + 1 ; }
function countBT ( $ h ) { global $ mod ; $ dp [ 0 ] = $ dp [ 1 ] = 1 ; for ( $ i = 2 ; $ i <= $ h ; $ i ++ ) { $ dp [ $ i ] = ( $ dp [ $ i - 1 ] * ( ( 2 * $ dp [ $ i - 2 ] ) % $ mod + $ dp [ $ i - 1 ] ) % $ mod ) % $ mod ; } return $ dp [ $ h ] ; }
function pythagorean_quadruple ( $ a , $ b , $ c , $ d ) { $ sum = $ a * $ a + $ b * $ b + $ c * $ c ; if ( $ d * $ d == $ sum ) return true ; else return false ; }
function search ( $ pat , $ txt ) { $ M = strlen ( $ pat ) ; $ N = strlen ( $ txt ) ; $ i = 0 ; while ( $ i <= $ N - $ M ) { $ j ; for ( $ j = 0 ; $ j < $ M ; $ j ++ ) if ( $ txt [ $ i + $ j ] != $ pat [ $ j ] ) break ; if ( $ j == $ M ) { echo ( " Pattern ▁ found ▁ at ▁ index ▁ $ i " . " STRNEWLINE " ) ; $ i = $ i + $ M ; } else if ( $ j == 0 ) $ i = $ i + 1 ; else $ i = $ i + $ j ; } }
function countChar ( $ str ) { $ n = strlen ( $ str ) ; if ( $ n <= 2 ) return $ n ; $ count = 2 ; for ( $ i = 1 ; $ i < $ n - 1 ; $ i ++ ) if ( $ str [ $ i - 1 ] == $ str [ $ i + 1 ] ) $ count ++ ; return $ count ; }
function calculateLeaps ( $ n ) { if ( $ n == 0 $ n == 1 ) { return 1 ; } else { $ leaps = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ leaps += calculateLeaps ( $ i ) ; return $ leaps ; } }
function minCost ( $ A , $ n ) { $ cost = 0 ; sort ( $ A ) ; $ K = $ A [ $ n / 2 ] ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) $ cost += abs ( $ A [ $ i ] - $ K ) ; if ( $ n % 2 == 0 ) { $ tempCost = 0 ; $ K = $ A [ ( $ n / 2 ) - 1 ] ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) $ tempCost += abs ( $ A [ $ i ] - $ K ) ; $ cost = min ( $ cost , $ tempCost ) ; } return $ cost ; }
function LongestSubarray ( $ arr , $ n , $ k ) { $ cnt = 1 ; $ max_length = 1 ; $ prev_mod = $ arr [ 0 ] % $ k ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ curr_mod = $ arr [ $ i ] % $ k ; if ( $ curr_mod == $ prev_mod ) { $ cnt ++ ; } else { $ max_length = max ( $ max_length , $ cnt ) ; $ cnt = 1 ; $ prev_mod = $ curr_mod ; } } return max ( $ max_length , $ cnt ) ; }
function Race ( $ B , $ C ) { $ result = 0 ; $ result = ( ( $ C * 100 ) / $ B ) ; return 100 - $ result ; }
function nthPalindrome ( $ n , $ k ) { $ temp = ( $ k & 1 ) ? ( int ) ( $ k / 2 ) : ( int ) ( $ k / 2 - 1 ) ; $ palindrome = ( int ) pow ( 10 , $ temp ) ; $ palindrome += $ n - 1 ; print ( $ palindrome ) ; if ( $ k & 1 ) $ palindrome = ( int ) ( $ palindrome / 10 ) ; while ( $ palindrome > 0 ) { print ( $ palindrome % 10 ) ; $ palindrome = ( int ) ( $ palindrome / 10 ) ; } print ( " STRNEWLINE " ) ; }
function getMaxNum ( $ a , $ b , $ c ) { if ( $ b % $ c == 0 ) return $ b ; $ x = ( ( int ) ( $ b / $ c ) * $ c ) ; if ( $ x >= $ a && $ x <= $ b ) return $ x ; else return -1 ; }
function FindMinimumCost ( $ ind , $ a , $ n , $ k , $ dp ) { if ( $ ind == ( $ n - 1 ) ) return 0 ; else if ( $ dp [ $ ind ] != -1 ) return $ dp [ $ ind ] ; else { $ ans = PHP_INT_MAX ; for ( $ i = 1 ; $ i <= $ k ; $ i ++ ) { if ( $ ind + $ i < $ n ) $ ans = min ( $ ans , abs ( $ a [ $ ind + $ i ] - $ a [ $ ind ] ) + FindMinimumCost ( $ ind + $ i , $ a , $ n , $ k , $ dp ) ) ; else break ; } return $ dp [ $ ind ] = $ ans ; } }
function Sum_upto_nth_Term ( $ n ) { $ r = $ n * ( $ n + 1 ) * ( 2 * $ n + 7 ) / 3 ; echo $ r ; }
function minRotation ( $ input , $ unlock_code ) { $ rotation = 0 ; $ input_digit ; $ code_digit ; while ( $ input $ unlock_code ) { $ input_digit = $ input % 10 ; $ code_digit = $ unlock_code % 10 ; $ rotation += min ( abs ( $ input_digit - $ code_digit ) , 10 - abs ( $ input_digit - $ code_digit ) ) ; $ input /= 10 ; $ unlock_code /= 10 ; } return $ rotation ; }
function sumSquare ( int $ n ) { for ( $ i = 1 ; $ i * $ i <= $ n ; $ i ++ ) for ( $ j = 1 ; $ j * $ j <= $ n ; $ j ++ ) if ( $ i * $ i + $ j * $ j == $ n ) { echo $ i , " ^ 2 ▁ + ▁ " , $ j , " ^ 2" ; return true ; } return false ; }
function solve ( $ i , $ par , & $ a , $ n , $ k , $ current_ans ) { global $ inf , $ ans ; if ( $ par > $ k ) return ; if ( $ par == $ k && $ i == $ n - 1 ) { $ ans = min ( $ ans , $ current_ans ) ; return ; } for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) solve ( $ j , $ par + 1 , $ a , $ n , $ k , $ current_ans + ( $ a [ $ j ] - $ a [ $ i + 1 ] ) * ( $ a [ $ j ] - $ a [ $ i + 1 ] ) ) ; }
function calculate ( $ s ) { $ ans = 6 ; for ( $ i = 0 ; $ i < 10 ; ++ $ i ) { for ( $ j = 0 ; $ j < 10 ; ++ $ j ) { for ( $ k = 0 ; $ k < 10 ; ++ $ k ) { for ( $ l = 0 ; $ l < 10 ; ++ $ l ) { for ( $ m = 0 ; $ m < 10 ; ++ $ m ) { for ( $ n = 0 ; $ n < 10 ; ++ $ n ) { if ( $ i + $ j + $ k == $ l + $ m + $ n ) { $ c = 0 ; if ( $ i != $ s [ 0 ] - '0' ) $ c ++ ; if ( $ j != $ s [ 1 ] - '0' ) $ c ++ ; if ( $ k != $ s [ 2 ] - '0' ) $ c ++ ; if ( $ l != $ s [ 3 ] - '0' ) $ c ++ ; if ( $ m != $ s [ 4 ] - '0' ) $ c ++ ; if ( $ n != $ s [ 5 ] - '0' ) $ c ++ ; if ( $ c < $ ans ) $ ans = $ c ; } } } } } } } return $ ans ; }
function number_of_tower ( $ house , $ range , $ n ) { sort ( $ house ) ; $ numOfTower = 0 ; $ i = 0 ; while ( $ i < $ n ) { $ numOfTower ++ ; $ loc = $ house [ $ i ] + $ range ; while ( $ i < $ n && $ house [ $ i ] <= $ loc ) $ i ++ ; -- $ i ; $ loc = $ house [ $ i ] + $ range ; while ( $ i < $ n && $ house [ $ i ] <= $ loc ) $ i ++ ; } return $ numOfTower ; }
function getOddOccurrence ( & $ arr , $ arr_size ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ arr_size ; $ i ++ ) { for ( $ j = 0 ; $ j < $ arr_size ; $ j ++ ) { if ( $ arr [ $ i ] == $ arr [ $ j ] ) $ count ++ ; } if ( $ count % 2 != 0 ) return $ arr [ $ i ] ; } return -1 ; }
function day_of_the_week ( $ y , $ m , $ d ) { $ t = array ( 0 , 3 , 2 , 5 , 0 , 3 , 5 , 1 , 4 , 6 , 2 , 4 ) ; if ( $ m < 3 ) $ y -= 1 ; return ( ( $ y + $ y / 4 - $ y / 100 + $ y / 400 + $ t [ $ m - 1 ] + $ d ) % 7 ) ; }
function countDistinct ( $ arr , $ n ) { $ s = array ( ) ; $ res = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { array_push ( $ s , $ arr [ $ i ] ) ; } $ s = array_unique ( $ s ) ; return count ( $ s ) ; }
function isLowerTriangularMatrix ( $ mat ) { global $ N ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ N ; $ j ++ ) if ( $ mat [ $ i ] [ $ j ] != 0 ) return false ; return true ; }
function summation ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ sum += ( $ i * $ i ) ; return $ sum ; }
function findNum ( $ N , $ K ) { $ rem = $ N % $ K ; if ( $ rem == 0 ) return $ N ; else return $ N - $ rem ; }
function maxLitres ( $ budget , $ plastic , $ glass , $ refund ) { if ( $ glass - $ refund < $ plastic ) { $ ans = max ( ( int ) ( $ budget - $ refund ) / ( $ glass - $ refund ) , 0 ) ; $ budget -= $ ans * ( $ glass - $ refund ) ; $ ans += ( int ) ( $ budget / $ plastic ) ; echo $ ans . " STRNEWLINE " ; } else echo ( int ) ( $ budget / $ plastic ) . " STRNEWLINE " ; }
function spiralDiaSum ( $ n ) { if ( $ n == 1 ) return 1 ; return ( 4 * $ n * $ n - 6 * $ n + 6 + spiralDiaSum ( $ n - 2 ) ) ; }
function lcsOf3 ( $ X , $ Y , $ Z , $ m , $ n , $ o ) { $ L [ $ m + 1 ] [ $ n + 1 ] [ $ o + 1 ] = array ( array ( array ( ) ) ) ; for ( $ i = 0 ; $ i <= $ m ; $ i ++ ) { for ( $ j = 0 ; $ j <= $ n ; $ j ++ ) { for ( $ k = 0 ; $ k <= $ o ; $ k ++ ) { if ( $ i == 0 $ j == 0 $ k == 0 ) $ L [ $ i ] [ $ j ] [ $ k ] = 0 ; else if ( $ X [ $ i - 1 ] == $ Y [ $ j - 1 ] && $ X [ $ i - 1 ] == $ Z [ $ k - 1 ] ) $ L [ $ i ] [ $ j ] [ $ k ] = $ L [ $ i - 1 ] [ $ j - 1 ] [ $ k - 1 ] + 1 ; else $ L [ $ i ] [ $ j ] [ $ k ] = max ( max ( $ L [ $ i - 1 ] [ $ j ] [ $ k ] , $ L [ $ i ] [ $ j - 1 ] [ $ k ] ) , $ L [ $ i ] [ $ j ] [ $ k - 1 ] ) ; } } } return $ L [ $ m ] [ $ n ] [ $ o ] ; }
function isPossibleToZero ( $ a , $ n ) { $ num = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ num = $ num * 10 + $ a [ $ i ] ; return ( $ num % 11 == 0 ) ; }
function findLastIndex ( $ str , $ x ) { $ index = -1 ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) if ( $ str [ $ i ] == $ x ) $ index = $ i ; return $ index ; }
function minPerimeter ( $ n ) { $ l = floor ( sqrt ( $ n ) ) ; $ sq = $ l * $ l ; if ( $ sq == $ n ) return $ l * 4 ; else { $ row = floor ( $ n / $ l ) ; $ perimeter = 2 * ( $ l + $ row ) ; if ( $ n % $ l != 0 ) $ perimeter += 2 ; return $ perimeter ; } }
function Nonagonal ( $ n ) { return $ n * ( 7 * $ n - 5 ) / 2 ; }
function totalFlips ( $ A , $ B , $ C , $ N ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ N ; ++ $ i ) { if ( $ A [ $ i ] == $ B [ $ i ] && $ C [ $ i ] == '1' ) ++ $ count ; else if ( $ A [ $ i ] != $ B [ $ i ] && $ C [ $ i ] == '0' ) ++ $ count ; } return $ count ; }
function calculateSum ( $ n ) { $ a = ( int ) $ n ; return ( 2 * ( pow ( $ n , 6 ) + 15 * pow ( $ n , 4 ) + 15 * pow ( $ n , 2 ) + 1 ) ) ; }
function getOccurence ( $ n , $ d ) { $ result = 0 ; $ itr = $ d ; while ( $ itr <= $ n ) { if ( $ itr % 10 == $ d ) $ result ++ ; if ( $ itr != 0 && floor ( $ itr / 10 ) == $ d ) { $ result ++ ; $ itr ++ ; } else if ( floor ( $ itr / 10 ) == $ d - 1 ) $ itr = $ itr + ( 10 - $ d ) ; else $ itr = $ itr + 10 ; } return $ result ; }
function circle ( $ x1 , $ y1 , $ x2 , $ y2 , $ r1 , $ r2 ) { $ distSq = ( $ x1 - $ x2 ) * ( $ x1 - $ x2 ) + ( $ y1 - $ y2 ) * ( $ y1 - $ y2 ) ; $ radSumSq = ( $ r1 + $ r2 ) * ( $ r1 + $ r2 ) ; if ( $ distSq == $ radSumSq ) return 1 ; else if ( $ distSq > $ radSumSq ) return -1 ; else return 0 ; }
function nextGreater ( $ N ) { $ power_of_2 = 1 ; $ shift_count = 0 ; while ( true ) { if ( ( ( $ N >> $ shift_count ) & 1 ) % 2 == 0 ) break ; $ shift_count ++ ; $ power_of_2 = $ power_of_2 * 2 ; } return ( $ N + $ power_of_2 ) ; }
function countSolutions ( $ a ) { $ count = 0 ; for ( $ i = 0 ; $ i <= $ a ; $ i ++ ) { if ( $ a == ( $ i + ( $ a ^ $ i ) ) ) $ count ++ ; } return $ count ; }
function twoWaySort ( & $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ arr [ $ i ] *= -1 ; sort ( $ arr ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] & 1 ) $ arr [ $ i ] *= -1 ; }
function numBoxes ( $ A , $ n , $ K ) { sort ( $ A ) ; $ i = 0 ; $ j = $ n - 1 ; $ ans = 0 ; while ( $ i <= $ j ) { $ ans ++ ; if ( $ A [ $ i ] + $ A [ $ j ] <= $ K ) $ i ++ ; $ j -- ; } return $ ans ; }
function countCountries ( $ ans , $ N ) { $ total_countries = 0 ; $ i = 0 ; $ invalid = false ; while ( $ i < $ N ) { $ curr_size = $ ans [ $ i ] ; $ num = $ ans [ $ i ] ; while ( $ num > 0 ) { if ( $ ans [ $ i ] != $ curr_size ) { echo " Invalid ▁ Answer STRNEWLINE " ; return ; } else $ num -- ; $ i ++ ; } $ total_countries ++ ; } echo " There ▁ are ▁ " , $ total_countries , " ▁ distinct ▁ companies ▁ in ▁ the ▁ group . STRNEWLINE " ; }
function countObtuseAngles ( $ a , $ b , $ k ) { $ c1 = ( $ b - $ a ) - 1 ; $ c2 = ( $ k - $ b ) + ( $ a - 1 ) ; if ( $ c1 == $ c2 ) return 0 ; return min ( $ c1 , $ c2 ) ; }
function findSmallestDifference ( $ A , $ B , $ m , $ n ) { sort ( $ A ) ; sort ( $ A , $ m ) ; sort ( $ B ) ; sort ( $ B , $ n ) ; $ a = 0 ; $ b = 0 ; $ INT_MAX = 1 ; $ result = $ INT_MAX ; while ( $ a < $ m && $ b < $ n ) { if ( abs ( $ A [ $ a ] - $ B [ $ b ] ) < $ result ) $ result = abs ( $ A [ $ a ] - $ B [ $ b ] ) ; if ( $ A [ $ a ] < $ B [ $ b ] ) $ a ++ ; else $ b ++ ; } return $ result ; } { $ A = array ( 1 , 2 , 11 , 5 ) ; $ B = array ( 4 , 12 , 19 , 23 , 127 , 235 ) ; $ m = sizeof ( $ A ) / sizeof ( $ A [ 0 ] ) ; $ n = sizeof ( $ B ) / sizeof ( $ B [ 0 ] ) ; echo findSmallestDifference ( $ A , $ B , $ m , $ n ) ; return 0 ; }
function subString ( $ str , $ n ) { for ( $ len = 1 ; $ len <= $ n ; $ len ++ ) { for ( $ i = 0 ; $ i <= $ n - $ len ; $ i ++ ) { $ j = $ i + $ len - 1 ; for ( $ k = $ i ; $ k <= $ j ; $ k ++ ) echo $ str [ $ k ] ; echo " STRNEWLINE " ; } } }
function swap ( & $ xp , & $ yp ) { $ xp = $ xp ^ $ yp ; $ yp = $ xp ^ $ yp ; $ xp = $ xp ^ $ yp ; }
function isPerfect ( $ n ) { $ sum = 1 ; for ( $ i = 2 ; $ i * $ i <= $ n ; $ i ++ ) { if ( $ n % $ i == 0 ) { if ( $ i * $ i != $ n ) $ sum = $ sum + $ i + ( int ) ( $ n / $ i ) ; else $ sum = $ sum + $ i ; } } if ( $ sum == $ n && $ n != 1 ) return true ; return false ; }
function areAllBitsSet ( $ n ) { if ( $ n == 0 ) return " No " ; if ( ( ( $ n + 1 ) & $ n ) == 0 ) return " Yes " ; return " No " ; }
function numOfCombinations ( $ arr , $ N ) { $ C = array ( 0 , 0 , 0 ) ; for ( $ i = 0 ; $ i < $ N ; ++ $ i ) ++ $ C [ $ arr [ $ i ] % 3 ] ; return $ C [ 1 ] * $ C [ 2 ] + $ C [ 0 ] * ( $ C [ 0 ] - 1 ) / 2 + $ C [ 0 ] * ( $ C [ 0 ] - 1 ) * ( $ C [ 0 ] - 2 ) / 6 + $ C [ 1 ] * ( $ C [ 1 ] - 1 ) * ( $ C [ 1 ] - 2 ) / 6 + $ C [ 2 ] * ( $ C [ 2 ] - 1 ) * ( $ C [ 2 ] - 2 ) / 6 + $ C [ 0 ] * $ C [ 1 ] * $ C [ 2 ] ; }
function isKthBitSet ( $ n , $ k ) { if ( $ n & ( 1 << ( $ k - 1 ) ) ) echo " SET " ; else echo " NOT ▁ SET " ; }
function firstDigit ( $ x ) { while ( $ x >= 10 ) $ x = $ x / 10 ; return floor ( $ x ) ; }
function findCountOfPairs ( $ a , $ b , $ n ) { $ ans = 0 ; for ( $ i = 1 ; $ i <= $ a ; $ i ++ ) { $ ans += ( int ) ( $ b / $ n ) ; $ ans += ( ( $ i % $ n ) + ( $ b % $ n ) ) >= $ n ? 1 : 0 ; } return $ ans ; }
function sumOfSeries ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) for ( $ j = 1 ; $ j <= $ i ; $ j ++ ) $ sum += $ j ; return $ sum ; }
function isProductEven ( $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( ( $ arr [ $ i ] & 1 ) == 0 ) return true ; return false ; }
function setleftmostunsetbit ( $ n ) { if ( ( $ n & ( $ n + 1 ) ) == 0 ) return $ n ; $ pos = 0 ; for ( $ temp = $ n , $ count = 0 ; $ temp > 0 ; $ temp >>= 1 , $ count ++ ) if ( ( $ temp & 1 ) == 0 ) $ pos = $ count ; return ( $ n | ( 1 << ( $ pos ) ) ) ; }
function countsubarray ( $ array , $ n , $ k ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ array [ $ i ] < $ k ) $ count ++ ; $ mul = $ array [ $ i ] ; for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) { $ mul = $ mul * $ array [ $ j ] ; if ( $ mul < $ k ) $ count ++ ; else break ; } } return $ count ; }
function sumOfSeries ( $ n ) { $ ans = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ ans += $ i * $ i * $ i * $ i ; return $ ans ; }
function isMagic ( $ n ) { $ sum = 0 ; while ( $ n > 0 $ sum > 9 ) { if ( $ n == 0 ) { $ n = $ sum ; $ sum = 0 ; } $ sum += $ n % 10 ; $ n /= 10 ; } return ( $ sum == 1 ) ; }
function setBitNumber ( $ n ) { if ( $ n == 0 ) return 0 ; $ msb = 0 ; $ n = $ n / 2 ; while ( $ n != 0 ) { $ n = $ n / 2 ; $ msb ++ ; } return ( 1 << $ msb ) ; }
function CountPairs ( $ n ) { $ k = $ n ; $ imin = 1 ; $ ans = 0 ; while ( $ imin <= $ n ) { $ imax = $ n / $ k ; $ ans += $ k * ( $ imax - $ imin + 1 ) ; $ imin = $ imax + 1 ; $ k = ( int ) ( $ n / $ imin ) ; } return $ ans ; }
function occurredOnce ( & $ arr , $ n ) { $ i = 1 ; $ len = $ n ; if ( $ arr [ 0 ] == $ arr [ $ len - 1 ] ) { $ i = 2 ; $ len -- ; } for ( ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] == $ arr [ $ i - 1 ] ) $ i ++ ; else echo $ arr [ $ i - 1 ] . " ▁ " ; if ( $ arr [ $ n - 1 ] != $ arr [ 0 ] && $ arr [ $ n - 1 ] != $ arr [ $ n - 2 ] ) echo $ arr [ $ n - 1 ] ; }
function squaresum ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ sum += ( $ i * $ i ) ; return $ sum ; }
function minRevolutions ( $ r , $ x1 , $ y1 , $ x2 , $ y2 ) { $ d = sqrt ( ( $ x1 - $ x2 ) * ( $ x1 - $ x2 ) + ( $ y1 - $ y2 ) * ( $ y1 - $ y2 ) ) ; return ceil ( $ d / ( 2 * $ r ) ) ; }
function printCoins ( & $ arr , $ n ) { $ oddSum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i += 2 ) $ oddSum += $ arr [ $ i ] ; $ evenSum = 0 ; for ( $ i = 1 ; $ i < $ n ; $ i += 2 ) $ evenSum += $ arr [ $ i ] ; $ start = ( ( $ oddSum > $ evenSum ) ? 0 : 1 ) ; for ( $ i = $ start ; $ i < $ n ; $ i += 2 ) echo $ arr [ $ i ] . " ▁ " ; }
function printCountRec ( $ dist ) { if ( $ dist < 0 ) return 0 ; if ( $ dist == 0 ) return 1 ; return printCountRec ( $ dist - 1 ) + printCountRec ( $ dist - 2 ) + printCountRec ( $ dist - 3 ) ; }
function getResult ( $ n ) { if ( $ n & 1 ) return 1 ; return -1 ; }
function Nthterm ( $ n ) { $ numerator = ( pow ( $ n , 2 ) ) -1 ; $ denomenator = 2 * $ n - 3 ; echo $ numerator , " / " , $ denomenator ; return $ Tn ; }
function squares ( $ l , $ b , $ a ) { return ceil ( $ l / ( double ) $ a ) * ceil ( $ b / ( double ) $ a ) ; }
function countMoves ( $ n ) { $ ct = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ ct += $ i * ( $ n - $ i ) ; $ ct += $ n ; return $ ct ; }
function countPieces ( $ N ) { return 2 * $ N ; }
function sumOfSeries ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ sum = $ sum + ( 2 * $ i - 1 ) * ( 2 * $ i - 1 ) ; return $ sum ; }
function maxProd ( $ N ) { if ( $ N == 0 ) return 1 ; if ( $ N < 10 ) return $ N ; return max ( maxProd ( ( int ) ( $ N / 10 ) ) * ( $ N % 10 ) , maxProd ( ( int ) ( $ N / 10 ) - 1 ) * 9 ) ; }
function diameter ( $ r ) { echo " The ▁ length ▁ of ▁ the ▁ longest ▁ chord " , " ▁ or ▁ diameter ▁ of ▁ the ▁ circle ▁ is ▁ " , 2 * $ r << " STRNEWLINE " ; }
function strScore ( $ str , $ s , $ n ) { $ score = 0 ; $ index ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ str [ $ i ] == $ s ) { for ( $ j = 0 ; $ j < strlen ( $ s ) ; $ j ++ ) $ score += ( ord ( $ s [ $ j ] ) - ord ( ' a ' ) ) + 1 ; $ index = ( $ i + 1 ) ; break ; } } $ score = $ score * $ index ; return $ score ; }
function printKPFNums ( $ A , $ B , $ K ) { $ prime = array_fill ( true , $ B + 1 , NULL ) ; $ p_factors = array_fill ( 0 , $ B + 1 , NULL ) ; for ( $ p = 2 ; $ p <= $ B ; $ p ++ ) if ( $ p_factors [ $ p ] == 0 ) for ( $ i = $ p ; $ i <= $ B ; $ i += $ p ) $ p_factors [ $ i ] ++ ; for ( $ i = $ A ; $ i <= $ B ; $ i ++ ) if ( $ p_factors [ $ i ] == $ K ) echo $ i . " " ; }
function getInteger ( $ L , $ R ) { $ number = 0 ; for ( $ i = $ L ; $ i <= $ R ; $ i ++ ) $ number += pow ( 2 , $ i ) ; return $ number ; }
function largestKSubmatrix ( & $ a ) { global $ Row , $ Col ; $ result = 0 ; for ( $ i = 0 ; $ i < $ Row ; $ i ++ ) { for ( $ j = 0 ; $ j < $ Col ; $ j ++ ) { if ( $ i == 0 $ j == 0 ) $ dp [ $ i ] [ $ j ] = 1 ; else { if ( $ a [ $ i ] [ $ j ] == $ a [ $ i - 1 ] [ $ j ] && $ a [ $ i ] [ $ j ] == $ a [ $ i ] [ $ j - 1 ] && $ a [ $ i ] [ $ j ] == $ a [ $ i - 1 ] [ $ j - 1 ] ) $ dp [ $ i ] [ $ j ] = min ( min ( $ dp [ $ i - 1 ] [ $ j ] , $ dp [ $ i ] [ $ j - 1 ] ) , $ dp [ $ i - 1 ] [ $ j - 1 ] ) + 1 ; else $ dp [ $ i ] [ $ j ] = 1 ; } $ result = max ( $ result , $ dp [ $ i ] [ $ j ] ) ; } } return $ result ; }
function cal_minimum_time ( $ X ) { $ t = 0 ; $ sum = 0 ; while ( $ sum < $ X ) { $ t ++ ; $ sum = $ sum + $ t ; } return $ t ; }
function getAverage ( $ x , $ y ) { $ avg = ( $ x & $ y ) + ( ( $ x ^ $ y ) >> 1 ) ; return $ avg ; }
function findAandB ( $ N ) { $ val = $ N * $ N - 4.0 * $ N ; if ( $ val < 0 ) { echo " NO " ; return ; } $ a = ( $ N + sqrt ( $ val ) ) / 2.0 ; $ b = ( $ N - sqrt ( $ val ) ) / 2.0 ; echo " a = " ▁ , ▁ $ a , ▁ " " ; STRNEWLINE TABSYMBOL echo ▁ " b = " ▁ , ▁ $ b , ▁ " " }
function numberOfSticks ( $ x ) { return ( 3 * $ x * ( $ x + 1 ) ) / 2 ; }
function calculateEvenSum ( $ n ) { if ( $ n <= 0 ) return 0 ; $ fibo [ 2 * $ n + 1 ] = array ( ) ; $ fibo [ 0 ] = 0 ; $ fibo [ 1 ] = 1 ; $ sum = 0 ; for ( $ i = 2 ; $ i <= 2 * $ n ; $ i ++ ) { $ fibo [ $ i ] = $ fibo [ $ i - 1 ] + $ fibo [ $ i - 2 ] ; if ( $ i % 2 == 0 ) $ sum += $ fibo [ $ i ] ; } return $ sum ; }
function sumOfSeries ( $ n ) { return ( $ n * ( $ n + 1 ) * ( 2 * $ n + 1 ) ) / 6 ; }
function nthOdd ( $ n ) { return ( 2 * $ n - 1 ) ; }
function countSegments ( $ a , $ n , $ x ) { $ flag = false ; $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] > $ x ) { $ flag = true ; } else { if ( $ flag ) $ count += 1 ; $ flag = false ; } } if ( $ flag ) $ count += 1 ; return $ count ; }
function LeadingZeros ( $ x , $ y ) { if ( ( $ x ^ $ y ) <= ( $ x & $ y ) ) echo " Equal " else if ( ( $ x & ( ~ $ y ) ) > $ y ) echo $ y ; else echo $ x ; }
function countCon ( $ ar , $ n ) { $ cnt = 0 ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { if ( $ ar [ $ i ] == $ ar [ $ i + 1 ] ) $ cnt ++ ; } return $ cnt ; }
function transformString ( & $ s ) { $ ch = " a " ; if ( strlen ( $ s ) < 26 ) return false ; for ( $ i = 0 ; $ i < strlen ( $ s ) ; $ i ++ ) { if ( ord ( $ ch ) > ord ( " z " ) ) break ; if ( $ s [ $ i ] <= $ ch ) { $ s [ $ i ] = $ ch ; $ ch = chr ( ord ( $ ch ) + 1 ) ; } } if ( $ ch <= " z " ) return false ; return true ; }
function boost_hyperfactorial ( $ num ) { $ val = 1 ; for ( $ i = 1 ; $ i <= $ num ; $ i ++ ) { for ( $ j = 1 ; $ j <= $ i ; $ j ++ ) { $ val *= $ i ; } } return $ val ; }
function checkPairs ( $ l , $ r ) { if ( ( $ l - $ r ) % 2 == 0 ) return false ; return true ; }
function ReuleauxArea ( $ a ) { if ( $ a < 0 ) return -1 ; $ A = 0.70477 * pow ( $ a , 2 ) ; return $ A ; }
function multiplyBySevenByEight ( $ n ) { return ( $ n - ( $ n >> 3 ) ) ; }
function findNumber ( $ n , $ m ) { $ num = ( $ m - 1 ) * 9 + $ n ; return $ num ; }
function countPairsWithDiffK ( $ arr , $ n , $ k ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) if ( $ arr [ $ i ] - $ arr [ $ j ] == $ k or $ arr [ $ j ] - $ arr [ $ i ] == $ k ) $ count ++ ; } return $ count ; }
function maxvolume ( $ s ) { $ maxvalue = 0 ; for ( $ i = 1 ; $ i <= $ s - 2 ; $ i ++ ) { for ( $ j = 1 ; $ j <= $ s - 1 ; $ j ++ ) { $ k = $ s - $ i - $ j ; $ maxvalue = max ( $ maxvalue , $ i * $ j * $ k ) ; } } return $ maxvalue ; }
function maxFraction ( $ first , $ sec ) { $ a = $ first [ 0 ] ; $ b = $ first [ 1 ] ; $ c = $ sec [ 0 ] ; $ d = $ sec [ 1 ] ; $ Y = $ a * $ d - $ b * $ c ; return ( $ Y ) ? $ first : $ sec ; }
function Identity ( $ num ) { $ row ; $ col ; for ( $ row = 0 ; $ row < $ num ; $ row ++ ) { for ( $ col = 0 ; $ col < $ num ; $ col ++ ) { if ( $ row == $ col ) echo 1 , " ▁ " ; else echo 0 , " ▁ " ; } echo " STRNEWLINE " ; } return 0 ; }
function print_C ( $ p0 ) { $ p1 = 0 ; $ i = 0 ; $ x ; $ flag ; $ k ; while ( 1 ) { $ flag = 1 ; $ x = pow ( 2 , $ i ) ; $ p1 = $ x * $ p0 + ( $ x - 1 ) ; for ( $ k = 2 ; $ k < $ p1 ; $ k ++ ) { if ( $ p1 % $ k == 0 ) { $ flag = 0 ; break ; } } if ( $ flag == 0 ) break ; echo $ p1 . " " ; $ i ++ ; } }
function calculateSum ( $ n ) { return pow ( $ n * ( $ n + 1 ) / 2 , 2 ) ; }
function getHermiteNumber ( $ n ) { if ( $ n == 0 ) return 1 ; if ( $ n == 1 ) return 0 ; else return -2 * ( $ n - 1 ) * getHermiteNumber ( $ n - 2 ) ; }
function ellipsearea ( $ r ) { if ( $ r < 0 ) return -1 ; $ a = ( 3.14 * $ r * $ r ) / 4 ; return $ a ; }
function minAbsDiff ( $ n ) { $ left = 1 << ( ( floor ( log ( $ n ) / log ( 2 ) ) ) ) ; $ right = $ left * 2 ; return min ( ( $ n - $ left ) , ( $ right - $ n ) ) ; }
function isPalindrome ( $ n ) { if ( $ n % 11 == 0 ) { return true ; } return false ; }
function findWinner ( $ N ) { return $ N & 1 ; }
function minInsertion ( $ str ) { $ n = strlen ( $ str ) ; $ res = 0 ; $ count = array ( 26 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ count [ ord ( $ str [ $ i ] ) - ord ( ' a ' ) ] ++ ; for ( $ i = 0 ; $ i < 26 ; $ i ++ ) { if ( $ count [ $ i ] % 2 == 1 ) $ res ++ ; } return ( $ res == 0 ) ? 0 : $ res - 1 ; }
function getValue ( $ n ) { $ i = 0 ; $ k = 1 ; while ( $ i < $ n ) { $ i = $ i + $ k ; $ k = $ k * 2 ; } return ( int ) $ k / 2 ; }
function polyapothem ( $ n , $ a ) { if ( $ a < 0 && $ n < 0 ) return -1 ; return $ a / ( 2 * tan ( ( 180 / $ n ) * 3.14159 / 180 ) ) ; }
function findSum ( $ n ) { return ( pow ( 10 , $ n + 1 ) * ( 9 * $ n - 1 ) + 10 ) / pow ( 9 , 3 ) - $ n * ( $ n + 1 ) / 18 ; }
function countOddSquares ( $ n , $ m ) { return ( int ) pow ( $ m , 0.5 ) - ( int ) pow ( $ n - 1 , 0.5 ) ; }
function hexagonside ( $ a ) { if ( $ a < 0 ) return -1 ; $ x = 0.5176 * $ a ; return $ x ; }
function countBits ( $ n ) { $ count = 0 ; while ( $ n ) { $ count ++ ; $ n >>= 1 ; } return $ count ; }
function meanVector ( $ mat ) { global $ rows , $ cols ; echo " [ ▁ " ; for ( $ i = 0 ; $ i < $ rows ; $ i ++ ) { $ mean = 0.00 ; $ sum = 0 ; for ( $ j = 0 ; $ j < $ cols ; $ j ++ ) $ sum += $ mat [ $ j ] [ $ i ] ; $ mean = $ sum / $ rows ; echo $ mean , " " ; ▁ } ▁ echo ▁ " ] " }
function translate ( & $ str ) { if ( $ str [ 0 ] == ' ' ) return ; for ( $ i = 1 ; $ i < strlen ( $ str ) ; $ i ++ ) { if ( $ str [ $ i - 1 ] == ' A ' && $ str [ $ i ] == ' B ' ) { $ str [ $ i - 1 ] = ' C ' ; for ( $ j = $ i ; $ j < strlen ( $ str ) ; $ j ++ ) $ str [ $ j ] = $ str [ $ j + 1 ] ; } } return ; }
function CountDigits ( $ n ) { if ( $ n == 1 ) return 1 ; $ sum = 0 ; for ( $ i = 2 ; $ i <= $ n ; ++ $ i ) { $ sum += log ( $ i ) / log ( 10 ) ; } $ sum *= $ n ; }
function possibleToSort ( $ arr , $ n , $ str ) { $ max_element = -1 ; for ( $ i = 0 ; $ i < sizeof ( $ str ) ; $ i ++ ) { $ max_element = max ( $ max_element , $ arr [ $ i ] ) ; if ( $ str [ $ i ] == '0' ) { if ( $ max_element > $ i + 1 ) return " No " ; } } return " Yes " ; }
function lastFiveDigits ( $ n ) { $ n = ( int ) ( $ n / 10000 ) * 10000 + ( ( int ) ( $ n / 100 ) % 10 ) * 1000 + ( $ n % 10 ) * 100 + ( ( int ) ( $ n / 10 ) % 10 ) * 10 + ( int ) ( $ n / 1000 ) % 10 ; $ ans = 1 ; for ( $ i = 0 ; $ i < 5 ; $ i ++ ) { $ ans *= $ n ; $ ans %= 100000 ; } echo $ ans ; }
function lcs ( $ X , $ Y ) { $ m = strlen ( $ X ) ; $ n = strlen ( $ Y ) ; $ L = array ( array ( ) ) ; for ( $ i = 0 ; $ i <= $ m ; $ i ++ ) { $ bi = $ i & 1 ; for ( $ j = 0 ; $ j <= $ n ; $ j ++ ) { if ( $ i == 0 $ j == 0 ) $ L [ $ bi ] [ $ j ] = 0 ; else if ( $ X [ $ i - 1 ] == $ Y [ $ j - 1 ] ) $ L [ $ bi ] [ $ j ] = $ L [ 1 - $ bi ] [ $ j - 1 ] + 1 ; else $ L [ $ bi ] [ $ j ] = max ( $ L [ 1 - $ bi ] [ $ j ] , $ L [ $ bi ] [ $ j - 1 ] ) ; } } return $ L [ $ bi ] [ $ n ] ; }
function checkStar ( $ mat ) { global $ size ; $ vertexD1 = 0 ; $ vertexDn_1 = 0 ; if ( $ size == 1 ) return ( $ mat [ 0 ] [ 0 ] == 0 ) ; if ( $ size == 2 ) return ( $ mat [ 0 ] [ 0 ] == 0 && $ mat [ 0 ] [ 1 ] == 1 && $ mat [ 1 ] [ 0 ] == 1 && $ mat [ 1 ] [ 1 ] == 0 ) ; for ( $ i = 0 ; $ i < $ size ; $ i ++ ) { $ degreeI = 0 ; for ( $ j = 0 ; $ j < $ size ; $ j ++ ) if ( $ mat [ $ i ] [ $ j ] ) $ degreeI ++ ; if ( $ degreeI == 1 ) $ vertexD1 ++ ; else if ( $ degreeI == $ size - 1 ) $ vertexDn_1 ++ ; } return ( $ vertexD1 == ( $ size - 1 ) && $ vertexDn_1 == 1 ) ; }
function findgroups ( $ arr , $ n ) { $ c = array ( 0 , 0 , 0 ) ; $ res = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ c [ $ arr [ $ i ] % 3 ] += 1 ; $ res += ( ( $ c [ 0 ] * ( $ c [ 0 ] - 1 ) ) >> 1 ) ; $ res += $ c [ 1 ] * $ c [ 2 ] ; $ res += ( $ c [ 0 ] * ( $ c [ 0 ] - 1 ) * ( $ c [ 0 ] - 2 ) ) / 6 ; $ res += ( $ c [ 1 ] * ( $ c [ 1 ] - 1 ) * ( $ c [ 1 ] - 2 ) ) / 6 ; $ res += ( ( $ c [ 2 ] * ( $ c [ 2 ] - 1 ) * ( $ c [ 2 ] - 2 ) ) / 6 ) ; $ res += $ c [ 0 ] * $ c [ 1 ] * $ c [ 2 ] ; return $ res ; }
function countDigits ( $ a , $ b ) { if ( $ a == 0 or $ b == 0 ) return 1 ; return floor ( log10 ( abs ( $ a ) ) + log10 ( abs ( $ b ) ) ) + 1 ; }
function findMinDiff ( $ arr , $ n , $ m ) { if ( $ m == 0 $ n == 0 ) return 0 ; sort ( $ arr ) ; if ( $ n < $ m ) return -1 ; $ min_diff = PHP_INT_MAX ; for ( $ i = 0 ; $ i + $ m - 1 < $ n ; $ i ++ ) { $ diff = $ arr [ $ i + $ m - 1 ] - $ arr [ $ i ] ; if ( $ diff < $ min_diff ) $ min_diff = $ diff ; } return $ min_diff ; }
function countWays ( $ n ) { $ dp [ 0 ] [ 1 ] = 1 ; $ dp [ 1 ] [ 1 ] = 2 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { $ dp [ 0 ] [ $ i ] = $ dp [ 0 ] [ $ i - 1 ] + $ dp [ 1 ] [ $ i - 1 ] ; $ dp [ 1 ] [ $ i ] = $ dp [ 0 ] [ $ i - 1 ] * 2 + $ dp [ 1 ] [ $ i - 1 ] ; } return $ dp [ 0 ] [ $ n ] + $ dp [ 1 ] [ $ n ] ; }
function findIndex ( $ arr , $ len ) { $ maxIndex = 0 ; for ( $ i = 0 ; $ i < $ len ; ++ $ i ) if ( $ arr [ $ i ] > $ arr [ $ maxIndex ] ) $ maxIndex = $ i ; for ( $ i = 0 ; $ i < $ len ; ++ $ i ) if ( $ maxIndex != $ i and $ arr [ $ maxIndex ] < 2 * $ arr [ $ i ] ) return -1 ; return $ maxIndex ; }
function minimumflip ( $ mat , $ n ) { $ flip = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ i ; $ j ++ ) if ( $ mat [ $ i ] [ $ j ] != $ mat [ $ j ] [ $ i ] ) $ flip ++ ; return $ flip ; }
function checkIndices ( $ Arr , $ N ) { for ( $ i = 0 ; $ i < $ N - 1 ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ N ; $ j ++ ) { if ( $ Arr [ $ i ] != $ Arr [ $ j ] ) { if ( $ Arr [ $ Arr [ $ i ] - 1 ] == $ Arr [ $ Arr [ $ j ] - 1 ] ) return true ; } } } return false ; }
function countOddPair ( $ A , $ N ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) if ( ! ( $ A [ $ i ] & 1 ) ) $ count ++ ; $ evenPairCount = $ count * ( $ count - 1 ) / 2 ; $ totPairs = $ N * ( $ N - 1 ) / 2 ; return ( $ totPairs - $ evenPairCount ) ; }
function AvgofSquareN ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ sum += ( $ i * $ i ) ; return $ sum / $ n ; }
function getHCF ( $ x , $ y ) { $ minimum = min ( $ x , $ y ) ; if ( $ x % $ minimum == 0 && $ y % $ minimum == 0 ) return $ minimum ; for ( $ i = $ minimum / 2 ; $ i >= 2 ; $ i -- ) { if ( $ x % $ i == 0 && $ y % $ i == 0 ) return $ i ; } return 1 ; }
function search ( $ arr , $ x ) { $ n = sizeof ( $ arr ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] == $ x ) return $ i ; } return -1 ; }
function checkMarkov ( $ m ) { $ n = 3 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sum = 0 ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) $ sum = $ sum + $ m [ $ i ] [ $ j ] ; if ( $ sum != 1 ) return false ; } return true ; }
function findMaximumPieces ( $ n ) { return 1 + $ n * ( $ n + 1 ) / 2 ; }
function printSorted ( $ a , $ b , $ c ) { $ get_max = max ( $ a , max ( $ b , $ c ) ) ; $ get_min = - max ( - $ a , max ( - $ b , - $ c ) ) ; $ get_mid = ( $ a + $ b + $ c ) - ( $ get_max + $ get_min ) ; echo $ get_min , " " ▁ , ▁ $ get _ mid , ▁ " " }
function findMaximumPieces ( $ n ) { return 1 + $ n * ( $ n + 1 ) / 2 ; }
function isAMultipleOf4 ( $ n ) { if ( ( $ n & 3 ) == 0 ) return " Yes " ; return " No " ; }
function heptagonalNumber ( $ n ) { return ( ( 5 * $ n * $ n ) - ( 3 * $ n ) ) / 2 ; }
function MinimumMoves ( & $ a , $ n , $ x ) { $ ans = 0 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] <= $ a [ $ i - 1 ] ) { $ p = ( $ a [ $ i - 1 ] - $ a [ $ i ] ) / $ x + 1 ; $ ans += $ p ; $ a [ $ i ] += $ p * $ x ; } } return $ ans ; }
function octadiagonal ( $ a ) { if ( $ a < 0 ) return -1 ; return $ a * sqrt ( 4 + ( 2 * sqrt ( 2 ) ) ) ; }
function subsetXOR ( $ arr , $ n , $ k ) { $ max_ele = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] > $ max_ele ) $ max_ele = $ arr [ $ i ] ; $ m = ( 1 << ( int ) ( log ( $ max_ele , 2 ) + 1 ) ) - 1 ; if ( $ k > $ m ) { return 0 ; } for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) for ( $ j = 0 ; $ j <= $ m ; $ j ++ ) $ dp [ $ i ] [ $ j ] = 0 ; $ dp [ 0 ] [ 0 ] = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) for ( $ j = 0 ; $ j <= $ m ; $ j ++ ) $ dp [ $ i ] [ $ j ] = $ dp [ $ i - 1 ] [ $ j ] + $ dp [ $ i - 1 ] [ $ j ^ $ arr [ $ i - 1 ] ] ; return $ dp [ $ n ] [ $ k ] ; }
function findRightAngle ( $ A , $ H ) { $ D = pow ( $ H , 4 ) - 16 * $ A * $ A ; if ( $ D >= 0 ) { $ root1 = ( $ H * $ H + sqrt ( $ D ) ) / 2 ; $ root2 = ( $ H * $ H - sqrt ( $ D ) ) / 2 ; $ a = sqrt ( $ root1 ) ; $ b = sqrt ( $ root2 ) ; if ( $ b >= $ a ) echo $ a , " ▁ " , $ b , " ▁ " , $ H ; else echo $ b , " ▁ " , $ a , " ▁ " , $ H ; } else echo " - 1" ; }
function countWays ( $ n ) { $ counter = 0 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) for ( $ j = $ i ; $ j < $ n ; $ j ++ ) for ( $ k = $ j ; $ k < $ n ; $ k ++ ) for ( $ l = $ k ; $ l < $ n ; $ l ++ ) if ( $ i + $ j + $ k + $ l == $ n ) $ counter ++ ; return $ counter ; }
function swapBits ( $ x ) { $ even_bits = $ x & 0xAAAAAAAA ; $ odd_bits = $ x & 0x55555555 ; $ even_bits >>= 1 ; $ odd_bits <<= 1 ; return ( $ even_bits $ odd_bits ) ; }
function findOddPair ( $ A , $ N ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { if ( $ A [ $ i ] % 2 == 0 ) $ count ++ ; } return $ count * ( $ N - $ count ) ; }
function hexagonArea ( $ d ) { return ( 3 * sqrt ( 3 ) * pow ( $ d , 2 ) ) / 8 ; }
function isValidISBN ( $ isbn ) { $ n = strlen ( $ isbn ) ; if ( $ n != 10 ) return -1 ; $ sum = 0 ; for ( $ i = 0 ; $ i < 9 ; $ i ++ ) { $ digit = $ isbn [ $ i ] - '0' ; if ( 0 > $ digit 9 < $ digit ) return -1 ; $ sum += ( $ digit * ( 10 - $ i ) ) ; } $ last = $ isbn [ 9 ] ; if ( $ last != ' X ' && ( $ last < '0' $ last > '9' ) ) return -1 ; $ sum += ( ( $ last == ' X ' ) ? 10 : ( $ last - '0' ) ) ; return ( $ sum % 11 == 0 ) ; }
function Alphabet_N_Pattern ( $ N ) { $ index ; $ side_index ; $ size ; $ Right = 1 ; $ Left = 1 ; $ Diagonal = 2 ; for ( $ index = 0 ; $ index < $ N ; $ index ++ ) { echo $ Left ++ ; for ( $ side_index = 0 ; $ side_index < 2 * ( $ index ) ; $ side_index ++ ) echo " ▁ " ; if ( $ index != 0 && $ index != $ N - 1 ) echo $ Diagonal ++ ; else echo " ▁ " ; for ( $ side_index = 0 ; $ side_index < 2 * ( $ N - $ index - 1 ) ; $ side_index ++ ) echo " ▁ " ; echo $ Right ++ ; echo " STRNEWLINE " ; } }
function isSuffix ( $ s1 , $ s2 ) { $ n1 = ( $ s1 ) ; $ n2 = strlen ( $ s2 ) ; if ( $ n1 > $ n2 ) return false ; for ( $ i = 0 ; $ i < $ n1 ; $ i ++ ) if ( $ s1 [ $ n1 - $ i - 1 ] != $ s2 [ $ n2 - $ i - 1 ] ) return false ; return true ; }
function countSubStr ( $ str ) { $ res = 0 ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) { if ( $ str [ $ i ] == '1' ) { for ( $ j = $ i + 1 ; $ j < strlen ( $ str ) ; $ j ++ ) if ( $ str [ $ j ] == '1' ) $ res ++ ; } } return $ res ; }
function trapezoidarea ( $ r ) { if ( $ r < 0 ) return -1 ; $ a = ( 3 * sqrt ( 3 ) * pow ( $ r , 2 ) ) / 4 ; return $ a ; }
function cone ( $ a ) { if ( $ a < 0 ) return -1 ; $ r = ( $ a * sqrt ( 2 ) ) / 3 ; $ h = ( 2 * $ a ) / 3 ; $ V = 3.14 * pow ( $ r , 2 ) * $ h ; return $ V ; }
function NumberOfSolutions ( $ x , $ y , $ z , $ n ) { $ ans = 0 ; for ( $ i = 0 ; $ i <= $ x ; $ i ++ ) { for ( $ j = 0 ; $ j <= $ y ; $ j ++ ) { $ temp = $ n - $ i - $ j ; if ( $ temp >= 0 ) { $ temp = min ( $ temp , $ z ) ; $ ans += $ temp + 1 ; } } } return $ ans ; }
function isPerfectSquare ( $ n ) { for ( $ sum = 0 , $ i = 1 ; $ sum < $ n ; $ i += 2 ) { $ sum += $ i ; if ( $ sum == $ n ) return true ; } return false ; }
function findString ( $ n , $ k ) { $ res = " " ; for ( $ i = 0 ; $ i < $ k ; $ i ++ ) $ res = $ res . chr ( ord ( ' a ' ) + $ i ) ; $ count = 0 ; for ( $ i = 0 ; $ i < $ n - $ k ; $ i ++ ) { $ res = $ res . chr ( ord ( ' a ' ) + $ count ) ; $ count ++ ; if ( $ count == $ k ) $ count = 0 ; } return $ res ; }
function series ( $ A , $ X , $ n ) { $ term = pow ( $ A , $ n ) ; echo $ term , " " ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ term = $ term * $ X * ( $ n - $ i + 1 ) / ( $ i * $ A ) ; echo $ term , " " ; } }
function isValid ( $ str , $ n ) { if ( ! ( ( $ str [ 0 ] >= ' a ' && $ str [ 0 ] <= ' z ' ) || ( $ str [ 0 ] >= ' A ' && $ str [ 0 ] <= ' Z ' ) $ str [ 0 ] == ' _ ' ) ) return false ; for ( $ i = 1 ; $ i < strlen ( $ str ) ; $ i ++ ) { if ( ! ( ( $ str [ $ i ] >= ' a ' && $ str [ $ i ] <= ' z ' ) || ( $ str [ $ i ] >= ' A ' && $ str [ $ i ] <= ' Z ' ) || ( $ str [ $ i ] >= '0' && $ str [ $ i ] <= '9' ) $ str [ $ i ] == ' _ ' ) ) return false ; } return true ; }
function cubeSide ( $ h , $ r ) { if ( $ h < 0 && $ r < 0 ) return -1 ; $ a = ( $ h * $ r * sqrt ( 2 ) ) / ( $ h + sqrt ( 2 ) * $ r ) ; return $ a ; }
function MinimumMaximumPairs ( $ n , $ m ) { $ max_pairs = ( ( $ n - $ m + 1 ) * ( $ n - $ m ) ) / 2 ; $ min_pairs = $ m * ( int ) ( ( ( ( int ) ( $ n - $ m ) / $ m + 1 ) * ( ( int ) ( $ n - $ m ) / $ m ) ) / 2 ) + ( int ) ceil ( ( $ n - $ m ) / $ m ) * ( ( $ n - $ m ) % $ m ) ; echo ( " Minimum ▁ no . ▁ of ▁ pairs ▁ = ▁ " . " $ min _ pairs " . " STRNEWLINE " ) ; echo ( " Maximum ▁ no . ▁ of ▁ pairs ▁ = ▁ " . " $ max _ pairs " ) ; }
function sumOfMinAbsDifferences ( $ arr , $ n ) { sort ( $ arr ) ; sort ( $ arr , $ n ) ; $ sum = 0 ; $ sum += abs ( $ arr [ 0 ] - $ arr [ 1 ] ) ; $ sum += abs ( $ arr [ $ n - 1 ] - $ arr [ $ n - 2 ] ) ; for ( $ i = 1 ; $ i < $ n - 1 ; $ i ++ ) $ sum += min ( abs ( $ arr [ $ i ] - $ arr [ $ i - 1 ] ) , abs ( $ arr [ $ i ] - $ arr [ $ i + 1 ] ) ) ; return $ sum ; }
function findMinimum ( $ x , $ y ) { $ low = 0 ; $ high = $ y ; while ( $ low <= $ high ) { $ mid = ( $ low + $ high ) >> 1 ; if ( ( $ mid * 2 + ( $ y - $ mid ) ) >= $ x ) $ high = $ mid - 1 ; else $ low = $ mid + 1 ; } return $ low ; }
function numberofterm ( $ n , $ number ) { $ firstnum = pow ( 10 , $ n - 1 ) ; $ lastnum = pow ( 10 , $ n ) ; $ count = 0 ; for ( $ i = $ firstnum ; $ i < $ lastnum ; $ i ++ ) if ( $ i % $ number == 0 ) $ count ++ ; return $ count ; }
function printElements ( $ arr , $ n ) { for ( $ i = 1 ; $ i < $ n - 1 ; $ i ++ ) { if ( $ arr [ $ i ] > $ arr [ $ i - 1 ] and $ arr [ $ i ] > $ arr [ $ i + 1 ] ) echo $ arr [ $ i ] . " ▁ " ; } }
function Check_is_possible ( $ l , $ r , $ k ) { $ count = 0 ; for ( $ i = $ l ; $ i <= $ r ; $ i ++ ) { if ( $ i % $ k == 0 ) $ count ++ ; } return ( $ count > 1 ) ; }
function breakSum ( $ n ) { $ dp = array_fill ( 0 , $ n + 1 , 0 ) ; $ dp [ 0 ] = 0 ; $ dp [ 1 ] = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) $ dp [ $ i ] = max ( $ dp [ ( int ) ( $ i / 2 ) ] + $ dp [ ( int ) ( $ i / 3 ) ] + $ dp [ ( int ) ( $ i / 4 ) ] , $ i ) ; return $ dp [ $ n ] ; }
function maxPathSum ( $ tri ) { global $ N ; $ ans = 0 ; for ( $ i = $ N - 2 ; $ i >= 0 ; $ i -- ) { for ( $ j = 0 ; $ j < $ N - $ i ; $ j ++ ) { if ( $ j - 1 >= 0 ) $ tri [ $ i ] [ $ j ] += max ( $ tri [ $ i + 1 ] [ $ j ] , $ tri [ $ i + 1 ] [ $ j - 1 ] ) ; else $ tri [ $ i ] [ $ j ] += $ tri [ $ i + 1 ] [ $ j ] ; $ ans = max ( $ ans , $ tri [ $ i ] [ $ j ] ) ; } } return $ ans ; }
function contiguousPerfectSquare ( $ arr , $ n ) { $ current_length = 0 ; $ max_length = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ b = ( float ) sqrt ( $ arr [ $ i ] ) ; $ a = ( int ) $ b ; if ( $ a == $ b ) $ current_length = $ current_length + 1 ; else $ current_length = 0 ; $ max_length = max ( $ max_length , $ current_length ) ; } return $ max_length ; }
function octant ( $ x , $ y , $ z ) { if ( $ x >= 0 && $ y >= 0 && $ z >= 0 ) echo " Point ▁ lies ▁ in ▁ 1st ▁ octant STRNEWLINE " ; else if ( $ x < 0 && $ y >= 0 && $ z >= 0 ) echo " Point ▁ lies ▁ in ▁ 2nd ▁ octant STRNEWLINE " ; else if ( $ x < 0 && $ y < 0 && $ z >= 0 ) echo " Point ▁ lies ▁ in ▁ 3rd ▁ octant STRNEWLINE " ; else if ( $ x >= 0 && $ y < 0 && $ z >= 0 ) echo " Point ▁ lies ▁ in ▁ 4th ▁ octant STRNEWLINE " ; else if ( $ x >= 0 && $ y >= 0 && $ z < 0 ) echo " Point ▁ lies ▁ in ▁ 5th ▁ octant STRNEWLINE " ; else if ( $ x < 0 && $ y >= 0 && $ z < 0 ) echo " Point ▁ lies ▁ in ▁ 6th ▁ octant STRNEWLINE " ; else if ( $ x < 0 && $ y < 0 && $ z < 0 ) echo " Point ▁ lies ▁ in ▁ 7th ▁ octant STRNEWLINE " ; else if ( $ x >= 0 && $ y < 0 && $ z < 0 ) echo " Point ▁ lies ▁ in ▁ 8th ▁ octant STRNEWLINE " ; }
function countSol ( $ coeff , $ n , $ rhs ) { $ dp = str_repeat ( " \0" , 256 ) ; $ dp [ 0 ] = 1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = $ coeff [ $ i ] ; $ j <= $ rhs ; $ j ++ ) $ dp [ $ j ] = $ dp [ $ j ] + ( $ dp [ $ j - $ coeff [ $ i ] ] ) ; return $ dp [ $ rhs ] ; }
function winner ( $ a , $ n , $ k ) { if ( $ k >= $ n - 1 ) return $ n ; $ best = 0 ; $ times = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] > $ best ) { $ best = $ a [ $ i ] ; if ( $ i ) $ times = 1 ; } else $ times += 1 ; if ( $ times >= $ k ) return $ best ; } return $ best ; }
function seriesSum ( $ n ) { return ( $ n * ( $ n + 1 ) * ( $ n + 2 ) ) / 6 ; }
function Permutations ( $ n , $ k ) { $ ans = 1 ; if ( $ k >= 2 ) $ ans += ( $ n ) * ( $ n - 1 ) / 2 ; if ( $ k >= 3 ) $ ans += ( $ n ) * ( $ n - 1 ) * ( $ n - 2 ) * 2 / 6 ; if ( $ k >= 4 ) $ ans += ( $ n ) * ( $ n - 1 ) * ( $ n - 2 ) * ( $ n - 3 ) * 9 / 24 ; return $ ans ; }
function findNumber ( $ n , $ d ) { $ ans = " " ; if ( $ d != 10 ) { $ ans . = strval ( $ d ) ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ ans . = '0' ; } else { if ( n == 1 ) $ ans . = " Impossible " ; else $ ans . = '1' ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ ans . = '0' ; } return $ ans ; }
function find_sum ( $ n , $ k ) { $ total_sum = ( $ n * ( $ n + 1 ) ) / 2 ; $ power = $ k ; while ( $ power <= $ n ) { $ total_sum -= $ power ; $ power *= $ k ; } return $ total_sum ; }
function findPermutation ( $ n ) { $ len = ceil ( log10 ( $ n ) ) ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { if ( $ n % 2 != 0 ) { return ( int ) $ n ; } else { $ n = ( $ n / 10 ) + ( $ n % 10 ) * pow ( 10 , $ len - $ i - 1 ) ; continue ; } } return -1 ; }
function sumOfSeries ( $ n ) { return 0.0246 * ( pow ( 10 , $ n ) - 1 - ( 9 * $ n ) ) ; }
function search ( $ arr , $ n , $ x ) { $ i = 0 ; while ( $ i < $ n ) { if ( $ arr [ $ i ] == $ x ) return $ i ; $ i = $ i + abs ( $ arr [ $ i ] - $ x ) ; } echo " number ▁ is ▁ not ▁ present ! " ; return -1 ; }
function primesInRange ( $ n ) { $ fact = 1 ; for ( $ k = 2 ; $ k < $ n ; $ k ++ ) { $ fact = $ fact * ( $ k - 1 ) ; if ( ( $ fact + 1 ) % $ k == 0 ) print ( $ k . " STRNEWLINE " ) ; } }
function geometricMean ( $ arr , $ n ) { $ product = 1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ product = $ product * $ arr [ $ i ] ; $ gm = pow ( $ product , ( float ) ( 1 / $ n ) ) ; return $ gm ; }
function printPermutation ( $ n , $ k ) { for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ x = 2 * $ i - 1 ; $ y = 2 * $ i ; if ( $ i <= $ k ) echo $ y . " " ▁ . ▁ $ x ▁ . ▁ " " else echo $ x . " ▁ " . $ y . " ▁ " ; } }
function bitPos ( $ n1 , $ n2 ) { if ( $ n1 == $ n2 ) return 0 ; $ bitCount1 = floor ( log ( $ n1 , 2 ) ) + 1 ; $ bitCount2 = floor ( log ( $ n2 , 2 ) ) + 1 ; $ bitDiff = abs ( $ bitCount1 - $ bitCount2 ) ; $ maxBitCount = max ( $ bitCount1 , $ bitCount2 ) ; if ( $ bitCount1 > $ bitCount2 ) { $ n2 = $ n2 * pow ( 2 , $ bitDiff ) ; } else { $ n1 = $ n1 * pow ( 2 , $ bitDiff ) ; } $ xorValue = $ n1 ^ $ n2 ; $ bitCountXorValue = floor ( log ( $ xorValue , 2 ) ) + 1 ; $ disSimilarBitPosition = $ maxBitCount - $ bitCountXorValue + 1 ; return $ disSimilarBitPosition ; }
function countDer ( $ n ) { $ der [ 1 ] = 0 ; $ der [ 2 ] = 1 ; for ( $ i = 3 ; $ i <= $ n ; ++ $ i ) $ der [ $ i ] = ( $ i - 1 ) * ( $ der [ $ i - 1 ] + $ der [ $ i - 2 ] ) ; return $ der [ $ n ] ; }
function equation_ellipse ( $ x1 , $ y1 , $ a , $ b , $ c , $ e ) { $ t = ( $ a * $ a ) + ( $ b * $ b ) ; $ a1 = $ t - $ e * ( $ a * $ a ) ; $ b1 = $ t - $ e * ( $ b * $ b ) ; $ c1 = ( -2 * $ t * $ x1 ) - ( 2 * $ e * $ c * $ a ) ; $ d1 = ( -2 * $ t * $ y1 ) - ( 2 * $ e * $ c * $ b ) ; $ e1 = -2 * $ e * $ a * $ b ; $ f1 = ( - $ e * $ c * $ c ) + ( $ t * $ x1 * $ x1 ) + ( $ t * $ y1 * $ y1 ) ; $ fixed ; echo " Equation ▁ of ▁ ellipse ▁ is ▁ STRNEWLINE " , $ a1 , " ▁ x ^ 2 ▁ + ▁ " , $ b1 , " ▁ y ^ 2 ▁ + ▁ " , $ c1 , " ▁ x ▁ + ▁ " , $ d1 , " ▁ y ▁ + ▁ " , $ e1 , " ▁ xy ▁ + ▁ " , $ f1 , " ▁ = ▁ 0" ; }
function reversDigits ( $ num ) { global $ rev_num ; global $ base_pos ; if ( $ num > 0 ) { reversDigits ( ( int ) ( $ num / 10 ) ) ; $ rev_num += ( $ num % 10 ) * $ base_pos ; $ base_pos *= 10 ; } return $ rev_num ; }
function findMinZero ( $ p ) { $ first = 1 ; $ second = 1 ; $ number = 2 ; $ next = 1 ; while ( $ next ) { $ next = ( $ first + $ second ) % $ p ; $ first = $ second ; $ second = $ next ; $ number ++ ; } return $ number ; }
function findMinSum ( $ a , $ b , $ n ) { sort ( $ a ) ; sort ( $ a , $ n ) ; sort ( $ b ) ; sort ( $ b , $ n ) ; $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum = $ sum + abs ( $ a [ $ i ] - $ b [ $ i ] ) ; return $ sum ; }
function areAllBitsSet ( $ n ) { if ( $ n == 0 ) return " No " ; while ( $ n > 0 ) { if ( ( $ n & 1 ) == 0 ) return " No " ; $ n = $ n >> 1 ; } return " Yes " ; }
function maxArea ( $ a , $ b , $ c , $ d ) { $ semiperimeter = ( $ a + $ b + $ c + $ d ) / 2 ; return sqrt ( ( $ semiperimeter - $ a ) * ( $ semiperimeter - $ b ) * ( $ semiperimeter - $ c ) * ( $ semiperimeter - $ d ) ) ; }
function isCornerPresent ( $ str , $ corner ) { $ n = strlen ( $ str ) ; $ cl = strlen ( $ corner ) ; if ( $ n < $ cl ) return false ; return ( ! strcmp ( substr ( $ str , 0 , $ cl ) , $ corner ) && ! strcmp ( substr ( $ str , $ n - $ cl , $ cl ) , $ corner ) ) ; }
function maxXOR ( $ n , $ k ) { $ c = log ( $ n , 2 ) + 1 ; return ( ( 1 << $ c ) - 1 ) ; }
function findRadiusOfIncircle ( $ a , $ b , $ c ) { if ( $ a < 0 $ b < 0 $ c < 0 ) return -1 ; $ p = ( $ a + $ b + $ c ) / 2 ; $ area = sqrt ( $ p * ( $ p - $ a ) * ( $ p - $ b ) * ( $ p - $ c ) ) ; $ radius = $ area / $ p ; return $ radius ; }
function FindPoint ( $ x1 , $ y1 , $ x2 , $ y2 , $ x , $ y ) { if ( $ x > $ x1 and $ x < $ x2 and $ y > $ y1 and $ y < $ y2 ) return true ; return false ; }
function isSpiltPossible ( $ n , $ a ) { $ sum = 0 ; $ c1 = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sum += $ a [ $ i ] ; if ( $ a [ $ i ] == 1 ) { $ c1 ++ ; } } if ( $ sum % 2 != 0 ) return false ; if ( ( $ sum / 2 ) % 2 == 0 ) return true ; if ( $ c1 > 0 ) return true ; else return false ; }
function countSubStr ( $ str ) { for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) { if ( $ str [ $ i ] == '1' ) { $ m ++ ; } } return $ m * ( $ m - 1 ) / 2 ; }
function SubArraySum ( $ arr , $ n ) { $ result = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ result += ( $ arr [ $ i ] * ( $ i + 1 ) * ( $ n - $ i ) ) ; return $ result ; }
function harmonicMean ( $ arr , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum = $ sum + ( float ) ( 1 / $ arr [ $ i ] ) ; return ( float ) ( $ n / $ sum ) ; }
function find_rectangle ( $ area ) { $ M = floor ( sqrt ( $ area ) ) ; for ( $ i = $ M ; $ i >= 1 ; $ i -- ) { if ( $ area % $ i == 0 ) { $ l = floor ( $ area / $ i ) ; $ b = $ i ; break ; } } echo " l = " , ▁ $ l , ▁ " , b = " , ▁ $ b , ▁ " " }
function binarySearch ( $ arr , $ l , $ r , $ x ) { if ( $ r >= $ l ) { $ mid = ceil ( $ l + ( $ r - $ l ) / 2 ) ; if ( $ arr [ $ mid ] == $ x ) return floor ( $ mid ) ; if ( $ arr [ $ mid ] > $ x ) return binarySearch ( $ arr , $ l , $ mid - 1 , $ x ) ; return binarySearch ( $ arr , $ mid + 1 , $ r , $ x ) ; } return -1 ; }
function findMinSum ( $ num ) { $ sum = 0 ; for ( $ i = 2 ; $ i * $ i <= $ num ; $ i ++ ) { while ( $ num % $ i == 0 ) { $ sum += $ i ; $ num /= $ i ; } } $ sum += $ num ; return $ sum ; }
function counts ( $ n ) { for ( $ j = 0 ; $ j < $ n + 1 ; $ j ++ ) $ table [ $ j ] = 0 ; $ table [ 0 ] = 1 ; for ( $ i = 3 ; $ i <= $ n ; $ i ++ ) $ table [ $ i ] += $ table [ $ i - 3 ] ; for ( $ i = 5 ; $ i <= $ n ; $ i ++ ) $ table [ $ i ] += $ table [ $ i - 5 ] ; for ( $ i = 10 ; $ i <= $ n ; $ i ++ ) $ table [ $ i ] += $ table [ $ i - 10 ] ; return $ table [ $ n ] ; }
function countDigits ( $ a , $ b ) { $ count = 0 ; $ p = abs ( $ a / $ b ) ; if ( $ p == 0 ) return 1 ; while ( $ p > 0 ) { $ count ++ ; $ p = ( int ) ( $ p / 10 ) ; } return $ count ; }
function pairs ( $ arr , $ n , $ k ) { $ smallest = PHP_INT_MAX ; $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) { if ( abs ( $ arr [ $ i ] + $ arr [ $ j ] - $ k ) < $ smallest ) { $ smallest = abs ( $ arr [ $ i ] + $ arr [ $ j ] - $ k ) ; $ count = 1 ; } else if ( abs ( $ arr [ $ i ] + $ arr [ $ j ] - $ k ) == $ smallest ) $ count ++ ; } echo " Minimal Value = " ▁ , ▁ $ smallest ▁ , ▁ " " ; STRNEWLINE TABSYMBOL TABSYMBOL echo ▁ " Total Pairs = " , ▁ $ count ▁ , ▁ " " }
function Area ( $ b1 , $ b2 , $ h ) { return ( ( $ b1 + $ b2 ) / 2 ) * $ h ; }
function maxSum ( $ arr , $ n ) { $ res = PHP_INT_MIN ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ curr_sum = 0 ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { $ index = ( $ i + $ j ) % $ n ; $ curr_sum += $ j * $ arr [ $ index ] ; } $ res = max ( $ res , $ curr_sum ) ; } return $ res ; }
function minSum ( $ a , $ n ) { sort ( $ a ) ; $ num1 = 0 ; $ num2 = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ i % 2 == 0 ) $ num1 = $ num1 * 10 + $ a [ $ i ] ; else $ num2 = $ num2 * 10 + $ a [ $ i ] ; } return ( $ num2 + $ num1 ) ; }
function tidyNum ( $ str , $ len ) { for ( $ i = $ len - 2 ; $ i >= 0 ; $ i -- ) { if ( $ str [ $ i ] > $ str [ $ i + 1 ] ) { $ x = ord ( $ str [ $ i ] ) ; $ x -- ; $ str [ $ i ] = chr ( $ x ) ; for ( $ j = $ i + 1 ; $ j < $ len ; $ j ++ ) $ str [ $ j ] = '9' ; } } return $ str ; }
function minPower ( $ n , $ x ) { if ( $ x == 1 ) return $ n ; $ ans = 0 ; while ( $ n > 0 ) { $ ans += ( $ n % $ x ) ; $ n /= $ x ; } return $ ans ; }
function splitArr ( & $ arr , $ n , $ k ) { for ( $ i = 0 ; $ i < $ k ; $ i ++ ) { $ x = $ arr [ 0 ] ; for ( $ j = 0 ; $ j < $ n - 1 ; ++ $ j ) $ arr [ $ j ] = $ arr [ $ j + 1 ] ; $ arr [ $ n - 1 ] = $ x ; } }
function areSame ( $ a , $ b ) { if ( ! ( $ a - $ b ) ) echo " Same " ; else echo " Not ▁ Same " ; }
function area ( $ r ) { if ( $ r < 0 ) return -1 ; $ area = 3.14 * pow ( $ r / ( 2 * sqrt ( 2 ) ) , 2 ) ; return $ area ; }
function print_t ( $ p0 ) { $ p1 ; $ i = 0 ; $ x ; $ flag ; $ k ; while ( 1 ) { $ flag = 1 ; $ x = pow ( 2 , $ i ) ; $ p1 = $ x * $ p0 - ( $ x - 1 ) ; for ( $ k = 2 ; $ k < $ p1 ; $ k ++ ) { if ( $ p1 % $ k == 0 ) { $ flag = 0 ; break ; } } if ( $ flag == 0 ) break ; echo $ p1 . " " ; $ i ++ ; } }
function area_circumscribed ( $ c ) { global $ PI ; return ( $ c * $ c * ( $ PI / 4 ) ) ; }
function bestApproximate ( $ x , $ y , $ n ) { $ i ; $ j ; $ m ; $ c ; $ sum_x = 0 ; $ sum_y = 0 ; $ sum_xy = 0 ; $ sum_x2 = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sum_x += $ x [ $ i ] ; $ sum_y += $ y [ $ i ] ; $ sum_xy += $ x [ $ i ] * $ y [ $ i ] ; $ sum_x2 += ( $ x [ $ i ] * $ x [ $ i ] ) ; } $ m = ( $ n * $ sum_xy - $ sum_x * $ sum_y ) / ( $ n * $ sum_x2 - ( $ sum_x * $ sum_x ) ) ; $ c = ( $ sum_y - $ m * $ sum_x ) / $ n ; echo " m = " , ▁ $ m ; STRNEWLINE TABSYMBOL echo ▁ " c = " }
function maxProduct ( $ arr , $ n ) { if ( $ n < 4 ) return -1 ; $ max_product = PHP_INT_MIN ; for ( $ i = 0 ; $ i < $ n - 3 ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n - 2 ; $ j ++ ) for ( $ k = $ j + 1 ; $ k < $ n - 1 ; $ k ++ ) for ( $ l = $ k + 1 ; $ l < $ n ; $ l ++ ) $ max_product = max ( $ max_product , $ arr [ $ i ] * $ arr [ $ j ] * $ arr [ $ k ] * $ arr [ $ l ] ) ; return $ max_product ; }
function findDiff ( $ arr , $ n ) { sort ( $ arr ) ; $ count = 0 ; $ max_count = 0 ; $ min_count = $ n ; for ( $ i = 0 ; $ i < ( $ n - 1 ) ; $ i ++ ) { if ( $ arr [ $ i ] == $ arr [ $ i + 1 ] ) { $ count += 1 ; continue ; } else { $ max_count = max ( $ max_count , $ count ) ; $ min_count = min ( $ min_count , $ count ) ; $ count = 0 ; } } return ( $ max_count - $ min_count ) ; }
function arraySum ( $ arr , $ n ) { $ x = ( $ n + 1 ) / 2 ; return ( $ arr [ 0 ] - 1 ) * $ n + $ x * $ x ; }
function countgroup ( $ a , $ n ) { $ xs = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ xs = $ xs ^ $ a [ $ i ] ; if ( $ xs == 0 ) return ( 1 << ( $ n - 1 ) ) - 1 ; return 0 ; }
function countSubarrays ( $ arr , $ n , $ K ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = $ i ; $ j < $ n ; $ j ++ ) { $ product = 1 ; for ( $ x = $ i ; $ x <= $ j ; $ x ++ ) $ product *= $ arr [ $ x ] ; if ( $ product % $ K == 0 ) $ count ++ ; } } return $ count ; }
function form_sieve ( ) { global $ sieve_Prime , $ sieve_count , $ MAX ; $ sieve_Prime [ 1 ] = 1 ; for ( $ i = 2 ; $ i <= $ MAX ; $ i ++ ) { if ( $ sieve_Prime [ $ i ] == 0 ) { for ( $ j = $ i * 2 ; $ j <= $ MAX ; $ j += $ i ) { if ( $ sieve_Prime [ $ j ] == 0 ) { $ sieve_Prime [ $ j ] = 1 ; $ sieve_count [ $ i ] ++ ; } } } } }
function calculate ( $ x , $ k , $ m ) { $ result = $ x ; $ k -- ; while ( $ k -- ) { $ result = pow ( $ result , $ x ) ; if ( $ result > $ m ) $ result %= $ m ; } return $ result ; }
function largestSubset ( $ a , $ n ) { $ dp = array ( ) ; $ dp [ $ n - 1 ] = 1 ; for ( $ i = $ n - 2 ; $ i >= 0 ; $ i -- ) { $ mxm = 0 ; for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) if ( $ a [ $ j ] % $ a [ $ i ] == 0 or $ a [ $ i ] % $ a [ $ j ] == 0 ) $ mxm = max ( $ mxm , $ dp [ $ j ] ) ; $ dp [ $ i ] = 1 + $ mxm ; } return max ( $ dp ) ; }
function findNumberOfDigits ( $ n , $ b ) { $ dig = ( int ) ( floor ( log ( $ n ) / log ( $ b ) ) + 1 ) ; echo ( " The ▁ Number ▁ of ▁ digits " . " ▁ of ▁ Number ▁ " . $ n . " ▁ in ▁ base ▁ " . $ b . " ▁ is ▁ " . $ dig ) ; }
function decideWinner ( $ a , $ n ) { $ count0 = 0 ; $ count1 = 0 ; $ count2 = 0 ; $ count3 = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] % 4 == 0 ) $ count0 ++ ; else if ( $ a [ $ i ] % 4 == 1 ) $ count1 ++ ; else if ( $ a [ $ i ] % 4 == 2 ) $ count2 ++ ; else if ( $ a [ $ i ] % 4 == 3 ) $ count3 ++ ; } if ( $ count0 % 2 == 0 && $ count1 % 2 == 0 && $ count2 % 2 == 0 && $ count3 == 0 ) return 1 ; else return 2 ; }
function minToggle ( $ arr , $ n ) { $ zero [ 0 ] = 0 ; $ zero [ $ n + 1 ] = 0 ; for ( $ i = 1 ; $ i <= $ n ; ++ $ i ) { if ( $ arr [ $ i - 1 ] == 0 ) $ zero [ $ i ] = $ zero [ $ i - 1 ] + 1 ; else $ zero [ $ i ] = $ zero [ $ i - 1 ] ; } $ ans = $ n ; for ( $ i = 1 ; $ i <= $ n ; ++ $ i ) $ ans = min ( $ ans , $ i - $ zero [ $ i ] + $ zero [ $ n ] - $ zero [ $ i ] ) ; return $ ans ; }
function calculateSum ( $ n ) { return ( $ n * ( 2 * $ n * $ n * $ n + 12 * $ n * $ n + 25 * $ n + 21 ) ) / 2 ; }
function checkConcurrent ( $ a1 , $ b1 , $ c1 , $ a2 , $ b2 , $ c2 , $ a3 , $ b3 , $ c3 ) { return ( $ a3 * ( $ b1 * $ c2 - $ b2 * $ c1 ) + $ b3 * ( $ c1 * $ a2 - $ c2 * $ a1 ) + $ c3 * ( $ a1 * $ b2 - $ a2 * $ b1 ) == 0 ) ; }
function distance ( $ x1 , $ y1 , $ x2 , $ y2 ) { return sqrt ( pow ( $ x2 - $ x1 , 2 ) + pow ( $ y2 - $ y1 , 2 ) * 1.0 ) ; }
function findExtra ( $ arr1 , $ arr2 , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr1 [ $ i ] != $ arr2 [ $ i ] ) return $ i ; return $ n ; }
function count_of_ways ( $ n ) { $ count ; $ count = ( $ n + 1 ) * ( $ n + 2 ) / 2 ; return $ count ; }
function maximumDifferenceSum ( $ arr , $ N ) { $ dp = array ( array ( ) ) ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) $ dp [ $ i ] [ 0 ] = $ dp [ $ i ] [ 1 ] = 0 ; for ( $ i = 0 ; $ i < ( $ N - 1 ) ; $ i ++ ) { $ dp [ $ i + 1 ] [ 0 ] = max ( $ dp [ $ i ] [ 0 ] , $ dp [ $ i ] [ 1 ] + abs ( 1 - $ arr [ $ i ] ) ) ; $ dp [ $ i + 1 ] [ 1 ] = max ( $ dp [ $ i ] [ 0 ] + abs ( $ arr [ $ i + 1 ] - 1 ) , $ dp [ $ i ] [ 1 ] + abs ( $ arr [ $ i + 1 ] - $ arr [ $ i ] ) ) ; } return max ( $ dp [ $ N - 1 ] [ 0 ] , $ dp [ $ N - 1 ] [ 1 ] ) ; }
function countSetBits ( $ n ) { $ count = 0 ; while ( $ n ) { $ count += $ n & 1 ; $ n >>= 1 ; } return $ count ; }
function next0 ( $ arr , $ target ) { $ start = 0 ; $ end = sizeof ( $ arr ) - 1 ; $ ans = -1 ; while ( $ start <= $ end ) { $ mid = ( int ) ( ( $ start + $ end ) / 2 ) ; if ( $ arr [ $ mid ] <= $ target ) { $ start = $ mid + 1 ; } else { $ ans = $ mid ; $ end = $ mid - 1 ; } } return $ ans ; } { $ arr = array ( 1 , 2 , 3 , 5 , 8 , 12 ) ; echo ( next0 ( $ arr , 8 ) ) ; }
function countSubstringWithEqualEnds ( $ s ) { $ result = 0 ; $ n = strlen ( $ s ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = $ i ; $ j < $ n ; $ j ++ ) if ( $ s [ $ i ] == $ s [ $ j ] ) $ result ++ ; return $ result ; }
function countDigitOne ( $ n ) { $ countr = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i *= 10 ) { $ divider = $ i * 10 ; $ countr += ( int ) ( $ n / $ divider ) * $ i + min ( max ( $ n % $ divider - $ i + 1 , 0 ) , $ i ) ; } return $ countr ; }
function multiplyWith3Point5 ( $ x ) { return ( $ x << 1 ) + $ x + ( $ x >> 1 ) ; }
function findPoint ( $ x1 , $ y1 , $ x2 , $ y2 ) { echo " ( " , 2 * $ x2 - $ x1 , " , ▁ " , 2 * $ y2 - $ y1 , " ) " ; }
function square ( $ a ) { if ( $ a < 0 ) return -1 ; $ x = 0.464 * $ a ; return $ x ; }
function decryptString ( $ str , $ n ) { $ i = 0 ; $ jump = 1 ; $ decryptedStr = " " ; while ( $ i < $ n ) { $ decryptedStr . = $ str [ $ i ] ; $ i += $ jump ; $ jump ++ ; } return $ decryptedStr ; }
function remainder ( $ str ) { $ len = strlen ( $ str ) ; $ num ; $ rem = 0 ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { $ num = $ rem * 10 + ( $ str [ $ i ] - '0' ) ; $ rem = $ num % 11 ; } return $ rem ; }
function checkpoint ( $ h , $ k , $ x , $ y , $ a ) { $ p = pow ( ( $ y - $ k ) , 2 ) - 4 * $ a * ( $ x - $ h ) ; return $ p ; }
function coutSubSeq ( $ A , $ N , $ M ) { $ sum = 0 ; $ ans = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ N ; $ j ++ ) { for ( $ k = $ j + 1 ; $ k < $ N ; $ k ++ ) { $ sum = $ A [ $ i ] + $ A [ $ j ] + $ A [ $ k ] ; if ( $ sum % $ M == 0 ) $ ans ++ ; } } } return $ ans ; }
function countPairs ( $ n ) { if ( $ n == 2 ) return 4 ; $ num = ( ( int ) ( $ n / 2 ) + 1 ) ; $ max = $ n % $ num ; $ count = ( $ n - $ max ) ; return $ count ; }
function longestCommonSum ( $ arr1 , $ arr2 , $ n ) { $ maxLen = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sum1 = 0 ; $ sum2 = 0 ; for ( $ j = $ i ; $ j < $ n ; $ j ++ ) { $ sum1 += $ arr1 [ $ j ] ; $ sum2 += $ arr2 [ $ j ] ; if ( $ sum1 == $ sum2 ) { $ len = $ j - $ i + 1 ; if ( $ len > $ maxLen ) $ maxLen = $ len ; } } } return $ maxLen ; }
function maxSubarrayXOR ( $ arr , $ n ) { $ ans = PHP_INT_MIN ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ curr_xor = 0 ; for ( $ j = $ i ; $ j < $ n ; $ j ++ ) { $ curr_xor = $ curr_xor ^ $ arr [ $ j ] ; $ ans = max ( $ ans , $ curr_xor ) ; } } return $ ans ; }
function hexagonArea ( $ s ) { return ( ( 3 * sqrt ( 3 ) * ( $ s * $ s ) ) / 2 ) ; }
function solve ( $ arr , $ n ) { sort ( $ arr ) ; sort ( $ arr , $ n ) ; $ a = 0 ; $ b = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ i & 1 ) $ a = $ a * 10 + $ arr [ $ i ] ; else $ b = $ b * 10 + $ arr [ $ i ] ; } return $ a + $ b ; }
function powerOfJump ( $ s ) { $ count = 1 ; $ max_so_far = PHP_INT_MIN ; $ ch = $ s [ strlen ( $ s ) - 1 ] ; for ( $ i = 0 ; $ i < strlen ( $ s ) ; $ i ++ ) { if ( $ s [ $ i ] == $ ch ) { if ( $ count > $ max_so_far ) { $ max_so_far = $ count ; } $ count = 1 ; } else $ count ++ ; } return $ max_so_far ; }
function findNumbers ( $ n ) { $ i = 1 ; while ( $ i <= $ n ) { echo ( ( 2 * $ i ) - 1 ) . " ▁ " ; $ i ++ ; } }
function sumArray ( $ arr , $ n ) { $ leftSum = array_fill ( 0 , $ n , 0 ) ; $ rightSum = array_fill ( 0 , $ n , 0 ) ; $ Sum = array_fill ( 0 , $ n , 0 ) ; $ leftSum [ 0 ] = 0 ; $ rightSum [ $ n - 1 ] = 0 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ leftSum [ $ i ] = $ arr [ $ i - 1 ] + $ leftSum [ $ i - 1 ] ; for ( $ j = $ n - 2 ; $ j >= 0 ; $ j -- ) $ rightSum [ $ j ] = $ arr [ $ j + 1 ] + $ rightSum [ $ j + 1 ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ Sum [ $ i ] = $ leftSum [ $ i ] + $ rightSum [ $ i ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ Sum [ $ i ] . " ▁ " ; }
function boost_hyperfactorial ( $ num ) { $ val = 1 ; for ( $ i = 1 ; $ i <= $ num ; $ i ++ ) { $ val = $ val * pow ( $ i , $ i ) ; } return $ val ; }
function gcd ( $ a , $ b ) { if ( $ b == 0 ) return $ a ; return gcd ( $ b , $ a % $ b ) ; }
function Permutation ( $ n , $ k ) { $ p = array ( ) ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ p [ $ i ] = $ i ; for ( $ i = 1 ; $ i < $ n - $ k ; $ i ++ ) $ p [ $ i + 1 ] = $ i ; $ p [ 1 ] = $ n - $ k ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) echo $ p [ $ i ] , " ▁ " ; }
function find ( $ index , $ openbrk , $ n , $ adj ) { global $ MAX_VAL ; global $ dp ; if ( $ openbrk < 0 ) return $ MAX_VAL ; if ( $ index == $ n ) { if ( $ openbrk == 0 ) { return 0 ; } return $ MAX_VAL ; } if ( $ dp [ $ index ] [ $ openbrk ] != -1 ) return $ dp [ $ index ] [ $ openbrk ] ; $ dp [ $ index ] [ $ openbrk ] = min ( $ adj [ $ index ] [ 1 ] + find ( $ index + 1 , $ openbrk + 1 , $ n , $ adj ) , $ adj [ $ index ] [ 0 ] + find ( $ index + 1 , $ openbrk - 1 , $ n , $ adj ) ) ; return $ dp [ $ index ] [ $ openbrk ] ; }
function multiplyFactors ( $ n ) { global $ M ; $ prod = 1 ; for ( $ i = 1 ; $ i * $ i <= $ n ; $ i ++ ) { if ( $ n % $ i == 0 ) { if ( $ n / $ i == $ i ) $ prod = ( $ prod * $ i ) % $ M ; else { $ prod = ( $ prod * $ i ) % $ M ; $ prod = ( $ prod * $ n / $ i ) % $ M ; } } } return $ prod ; }
function polydiagonal ( $ n , $ a ) { if ( $ a < 0 && $ n < 0 ) return -1 ; return 2 * $ a * sin ( ( ( ( $ n - 2 ) * 180 ) / ( 2 * $ n ) ) * 3.14159 / 180 ) ; }
function NumberofTimes ( $ str ) { $ temporary_sum = 0 ; $ count = 0 ; while ( strlen ( $ str ) > 1 ) { $ temporary_sum = 0 ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) $ temporary_sum += ( $ str [ $ i ] - '0' ) ; $ str = ( string ) ( $ temporary_sum ) ; $ count ++ ; } return $ count ; }
function evenlength ( $ n ) { $ res = $ n ; for ( $ j = strlen ( $ n ) - 1 ; $ j >= 0 ; -- $ j ) $ res = $ res . $ n [ $ j ] ; return $ res ; }
function findMaxSum ( $ arr , $ n ) { $ preSum [ $ n ] = array ( ) ; $ suffSum [ $ n ] = array ( ) ; $ ans = PHP_INT_MIN ; $ preSum [ 0 ] = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ preSum [ $ i ] = $ preSum [ $ i - 1 ] + $ arr [ $ i ] ; $ suffSum [ $ n - 1 ] = $ arr [ $ n - 1 ] ; if ( $ preSum [ $ n - 1 ] == $ suffSum [ $ n - 1 ] ) $ ans = max ( $ ans , $ preSum [ $ n - 1 ] ) ; for ( $ i = $ n - 2 ; $ i >= 0 ; $ i -- ) { $ suffSum [ $ i ] = $ suffSum [ $ i + 1 ] + $ arr [ $ i ] ; if ( $ suffSum [ $ i ] == $ preSum [ $ i ] ) $ ans = max ( $ ans , $ preSum [ $ i ] ) ; } return $ ans ; }
function minproduct ( $ a , $ b , $ n , $ k ) { $ diff = 0 ; $ res = 0 ; $ temp ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ pro = $ a [ $ i ] * $ b [ $ i ] ; $ res = $ res + $ pro ; if ( $ pro < 0 and $ b [ $ i ] < 0 ) $ temp = ( $ a [ $ i ] + 2 * $ k ) * $ b [ $ i ] ; else if ( $ pro < 0 and $ a [ $ i ] < 0 ) $ temp = ( $ a [ $ i ] - 2 * $ k ) * $ b [ $ i ] ; else if ( $ pro > 0 and $ a [ $ i ] < 0 ) $ temp = ( $ a [ $ i ] + 2 * $ k ) * $ b [ $ i ] ; else if ( $ pro > 0 and $ a [ $ i ] > 0 ) $ temp = ( $ a [ $ i ] - 2 * $ k ) * $ b [ $ i ] ; $ d = abs ( $ pro - $ temp ) ; if ( $ d > $ diff ) $ diff = $ d ; } return $ res - $ diff ; }
function getSum ( $ arr , $ p ) { return count ( $ arr ) ; }
function printSeries ( $ n ) { for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ num = $ i * ( $ i + 1 ) * ( $ i + 2 ) / 6 ; echo ( $ num . " " ) ; } }
function otherEndPoint ( $ x1 , $ y1 , $ m1 , $ m2 ) { $ x2 = ( 2 * $ m1 - $ x1 ) ; $ y2 = ( 2 * $ m2 - $ y1 ) ; echo " x2 ▁ = ▁ " . $ x2 . " , ▁ y2 ▁ = ▁ " . $ y2 ; }
function rangeSum ( $ l , $ r ) { global $ MOD ; $ a = 1 ; $ b = 9 ; $ res = 0 ; for ( $ i = 1 ; $ i <= 10 ; $ i ++ ) { $ L = max ( $ l , $ a ) ; $ R = min ( $ r , $ b ) ; if ( $ L <= $ R ) { $ sum = ( $ L + $ R ) * ( $ R - $ L + 1 ) / 2 ; $ res += ( $ i * $ i ) * ( $ sum % $ MOD ) ; $ res %= $ MOD ; } $ a = $ a * 10 ; $ b = $ b * 10 + 9 ; } return $ res ; }
function numberOfPaths ( $ m , $ n ) { if ( $ m == 1 $ n == 1 ) return 1 ; return numberOfPaths ( $ m - 1 , $ n ) + numberOfPaths ( $ m , $ n - 1 ) ; }
function printSorted ( $ arr , $ start , $ end ) { if ( $ start > $ end ) return ; printSorted ( $ arr , $ start * 2 + 1 , $ end ) ; echo ( $ arr [ $ start ] . " " ) ; printSorted ( $ arr , $ start * 2 + 2 , $ end ) ; }
function printSumSimple ( $ mat , $ k ) { global $ n ; if ( $ k > $ n ) return ; for ( $ i = 0 ; $ i < $ n - $ k + 1 ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n - $ k + 1 ; $ j ++ ) { $ sum = 0 ; for ( $ p = $ i ; $ p < $ k + $ i ; $ p ++ ) for ( $ q = $ j ; $ q < $ k + $ j ; $ q ++ ) $ sum += $ mat [ $ p ] [ $ q ] ; echo $ sum , " " ; } echo " STRNEWLINE " ; } }
function seiresSum ( $ n , $ a ) { return $ n * ( $ a [ 0 ] * $ a [ 0 ] - $ a [ 2 * $ n - 1 ] * $ a [ 2 * $ n - 1 ] ) / ( 2 * $ n - 1 ) ; }
function maxSumPairWithDifferenceLessThanK ( $ arr , $ N , $ k ) { $ maxSum = 0 ; sort ( $ arr ) ; for ( $ i = $ N - 1 ; $ i > 0 ; -- $ i ) { if ( $ arr [ $ i ] - $ arr [ $ i - 1 ] < $ k ) { $ maxSum += $ arr [ $ i ] ; $ maxSum += $ arr [ $ i - 1 ] ; -- $ i ; } } return $ maxSum ; }
function convert ( $ str ) { $ w = " " ; $ z = " " ; $ str = strtoupper ( $ str ) . " ▁ " ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) { $ ch = $ str [ $ i ] ; if ( $ ch != ' ▁ ' ) $ w = $ w . $ ch ; else { $ z = $ z . strtolower ( $ w [ 0 ] ) . substr ( $ w , 1 ) . " ▁ " ; $ w = " " ; } } return $ z ; }
function printRepeating ( $ arr , $ size ) { $ i ; $ j ; echo " ▁ Repeating ▁ elements ▁ are ▁ " ; for ( $ i = 0 ; $ i < $ size ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ size ; $ j ++ ) if ( $ arr [ $ i ] == $ arr [ $ j ] ) echo $ arr [ $ i ] , " ▁ " ; }
function multiplyByFifteen ( $ n ) { $ prod = ( $ n << 4 ) ; $ prod = $ prod - $ n ; return $ prod ; }
function LCSubStr ( $ X , $ Y , $ m , $ n ) { $ LCSuff = array_fill ( 0 , $ m + 1 , array_fill ( 0 , $ n + 1 , NULL ) ) ; $ result = 0 ; for ( $ i = 0 ; $ i <= $ m ; $ i ++ ) { for ( $ j = 0 ; $ j <= $ n ; $ j ++ ) { if ( $ i == 0 $ j == 0 ) $ LCSuff [ $ i ] [ $ j ] = 0 ; else if ( $ X [ $ i - 1 ] == $ Y [ $ j - 1 ] ) { $ LCSuff [ $ i ] [ $ j ] = $ LCSuff [ $ i - 1 ] [ $ j - 1 ] + 1 ; $ result = max ( $ result , $ LCSuff [ $ i ] [ $ j ] ) ; } else $ LCSuff [ $ i ] [ $ j ] = 0 ; } } return $ result ; }
function modularSum ( $ arr , $ n , $ m ) { if ( $ n > $ m ) return true ; $ DP = Array_fill ( 0 , $ m , false ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ DP [ 0 ] ) return true ; $ temp = array_fill ( 0 , $ m , false ) ; for ( $ j = 0 ; $ j < $ m ; $ j ++ ) { if ( $ DP [ $ j ] == true ) { if ( $ DP [ ( $ j + $ arr [ $ i ] ) % $ m ] == false ) $ temp [ ( $ j + $ arr [ $ i ] ) % $ m ] = true ; } } for ( $ j = 0 ; $ j < $ m ; $ j ++ ) if ( $ temp [ $ j ] ) $ DP [ $ j ] = true ; $ DP [ $ arr [ $ i ] % $ m ] = true ; } return $ DP [ 0 ] ; }
function maxSum ( $ a , $ n ) { $ s = 0 ; $ l = array ( ) ; for ( $ i = 0 ; $ i < count ( $ a ) ; $ i ++ ) { $ s += abs ( $ a [ $ i ] ) ; if ( $ a [ $ i ] >= 0 ) continue ; if ( $ i == 0 ) array_push ( $ l , $ i + 1 ) ; else { array_push ( $ l , $ i + 1 ) ; array_push ( $ l , $ i ) ; } } echo $ s . " STRNEWLINE " ; for ( $ i = 0 ; $ i < count ( $ l ) ; $ i ++ ) echo $ l [ $ i ] . " ▁ " ; }
function sumOfTheSeries ( $ n ) { $ sum_n = ( $ n * ( $ n + 1 ) / 2 ) ; $ sum_sq_n = ( $ n * ( $ n + 1 ) / 2 ) * ( 2 * $ n + 1 ) / 3 ; return ( $ sum_n + $ sum_sq_n ) ; }
function numOfways ( $ n , $ k ) { $ p = 1 ; if ( $ k % 2 ) $ p = -1 ; return ( pow ( $ n - 1 , $ k ) + $ p * ( $ n - 1 ) ) / $ n ; }
function possibleways ( $ n ) { if ( $ n % 2 == 1 ) return 0 ; else if ( $ n % 4 == 0 ) return $ n / 4 - 1 ; else return $ n / 4 ; }
function inversegrayCode ( $ n ) { $ inv = 0 ; for ( ; $ n ; $ n = $ n >> 1 ) $ inv ^= $ n ; return $ inv ; }
function longCommomAnagramSubseq ( $ str1 , $ str2 , $ n1 , $ n2 ) { global $ SIZE ; $ freq1 = array ( ) ; $ freq2 = array ( ) ; for ( $ i = 0 ; $ i < $ SIZE ; $ i ++ ) { $ freq1 [ $ i ] = 0 ; $ freq2 [ $ i ] = 0 ; } $ len = 0 ; for ( $ i = 0 ; $ i < $ n1 ; $ i ++ ) $ freq1 [ ord ( $ str1 [ $ i ] ) - ord ( ' a ' ) ] ++ ; for ( $ i = 0 ; $ i < $ n2 ; $ i ++ ) $ freq2 [ ord ( $ str2 [ $ i ] ) - ord ( ' a ' ) ] ++ ; for ( $ i = 0 ; $ i < $ SIZE ; $ i ++ ) { $ len += min ( $ freq1 [ $ i ] , $ freq2 [ $ i ] ) ; } return $ len ; }
function countOnes ( $ arr , $ low , $ high ) { if ( $ high >= $ low ) { $ mid = $ low + ( $ high - $ low ) / 2 ; if ( ( $ mid == $ high or $ arr [ $ mid + 1 ] == 0 ) and ( $ arr [ $ mid ] == 1 ) ) return $ mid + 1 ; if ( $ arr [ $ mid ] == 1 ) return countOnes ( $ arr , ( $ mid + 1 ) , $ high ) ; return countOnes ( $ arr , $ low , ( $ mid - 1 ) ) ; } return 0 ; }
function minIndex ( & $ arr , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum += $ arr [ $ i ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( 2 * $ arr [ $ i ] == $ sum ) return ( $ i + 1 ) ; } return -1 ; }
function dodecahedral_num ( $ n ) { return $ n * ( 3 * $ n - 1 ) * ( 3 * $ n - 2 ) / 2 ; }
function findLCM ( $ a , $ b ) { $ lar = max ( $ a , $ b ) ; $ small = min ( $ a , $ b ) ; for ( $ i = $ lar ; ; $ i += $ lar ) { if ( $ i % $ small == 0 ) return $ i ; } }
function countNumbers ( $ l , $ r ) { return ( ( int ) ( $ r / 6 ) - ( int ) ( ( $ l - 1 ) / 6 ) ) ; }
function findSum ( $ n ) { $ sum2 = ( ( int ) ( $ n / 2 ) * ( 4 + ( ( int ) ( $ n / 2 ) - 1 ) * 2 ) ) / 2 ; $ sum5 = ( ( int ) ( $ n / 5 ) * ( 10 + ( $ n / 5 - 1 ) * 5 ) ) / 2 ; $ sum10 = ( ( int ) ( $ n / 10 ) * ( 20 + ( $ n / 10 - 1 ) * 10 ) ) / 2 ; return $ sum2 + $ sum5 - $ sum10 ; }
function checkFibinnary ( $ n ) { $ prev_last = 0 ; while ( $ n ) { if ( ( $ n & 1 ) && $ prev_last ) return false ; $ prev_last = $ n & 1 ; $ n >>= 1 ; } return true ; }
function findMin ( $ arr , $ low , $ high ) { if ( $ high < $ low ) return $ arr [ 0 ] ; if ( $ high == $ low ) return $ arr [ $ low ] ; $ mid = $ low + ( $ high - $ low ) / 2 ; if ( $ mid < $ high && $ arr [ $ mid + 1 ] < $ arr [ $ mid ] ) return $ arr [ $ mid + 1 ] ; if ( $ mid > $ low && $ arr [ $ mid ] < $ arr [ $ mid - 1 ] ) return $ arr [ $ mid ] ; if ( $ arr [ $ high ] > $ arr [ $ mid ] ) return findMin ( $ arr , $ low , $ mid - 1 ) ; return findMin ( $ arr , $ mid + 1 , $ high ) ; }
function getMaxGold ( $ gold , $ m , $ n ) { $ MAX = 100 ; $ goldTable = array ( array ( ) ) ; for ( $ i = 0 ; $ i < $ m ; $ i ++ ) for ( $ j = 0 ; $ j < $ n ; $ j ++ ) $ goldTable [ $ i ] [ $ j ] = 0 ; for ( $ col = $ n - 1 ; $ col >= 0 ; $ col -- ) { for ( $ row = 0 ; $ row < $ m ; $ row ++ ) { if ( $ col == $ n - 1 ) $ right = 0 ; else $ right = $ goldTable [ $ row ] [ $ col + 1 ] ; if ( $ row == 0 or $ col == $ n - 1 ) $ right_up = 0 ; else $ right_up = $ goldTable [ $ row - 1 ] [ $ col + 1 ] ; if ( $ row == $ m - 1 or $ col == $ n - 1 ) $ right_down = 0 ; else $ right_down = $ goldTable [ $ row + 1 ] [ $ col + 1 ] ; $ goldTable [ $ row ] [ $ col ] = $ gold [ $ row ] [ $ col ] + max ( $ right , $ right_up , $ right_down ) ; } } $ res = $ goldTable [ 0 ] [ 0 ] ; for ( $ i = 0 ; $ i < $ m ; $ i ++ ) $ res = max ( $ res , $ goldTable [ $ i ] [ 0 ] ) ; return $ res ; }
function areDisjoint ( $ set1 , $ set2 , $ m , $ n ) { for ( $ i = 0 ; $ i < $ m ; $ i ++ ) for ( $ j = 0 ; $ j < $ n ; $ j ++ ) if ( $ set1 [ $ i ] == $ set2 [ $ j ] ) return false ; return true ; }
function findMinX ( $ num , $ rem , $ k ) { while ( true ) { $ j ; for ( $ j = 0 ; $ j < $ k ; $ j ++ ) if ( $ x % $ num [ $ j ] != $ rem [ $ j ] ) break ; if ( $ j == $ k ) return $ x ; $ x ++ ; } return $ x ; }
function diagonal_length ( $ a ) { $ L ; $ L = $ a * sqrt ( 3 ) ; return $ L ; }
function fibonacci ( $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ fib = ( pow ( ( 1 + sqrt ( 5 ) ) , $ i ) - pow ( ( 1 - sqrt ( 5 ) ) , $ i ) ) / ( pow ( 2 , $ i ) * sqrt ( 5 ) ) ; echo $ fib , " " ; } }
function polyarea ( $ n , $ r ) { if ( $ r < 0 && $ n < 0 ) return -1 ; $ A = ( ( $ r * $ r * $ n ) * sin ( ( 360 / $ n ) * 3.14159 / 180 ) ) / 2 ; return $ A ; }
function countSquares ( $ m , $ n ) { if ( $ n < $ m ) list ( $ m , $ n ) = array ( $ n , $ m ) ; return $ m * ( $ m + 1 ) * ( 2 * $ m + 1 ) / 6 + ( $ n - $ m ) * $ m * ( $ m + 1 ) / 2 ; }
function evenbittogglenumber ( $ n ) { $ res = 0 ; $ count = 0 ; for ( $ temp = $ n ; $ temp > 0 ; $ temp >>= 1 ) { if ( $ count % 2 == 1 ) $ res |= ( 1 << $ count ) ; $ count ++ ; } return $ n ^ $ res ; }
function segregate0and1 ( & $ arr , $ size ) { $ left = 0 ; $ right = $ size - 1 ; while ( $ left < $ right ) { while ( $ arr [ $ left ] == 0 && $ left < $ right ) $ left ++ ; while ( $ arr [ $ right ] == 1 && $ left < $ right ) $ right -- ; if ( $ left < $ right ) { $ arr [ $ left ] = 0 ; $ arr [ $ right ] = 1 ; $ left ++ ; $ right -- ; } } }
function search ( $ arr , $ l , $ h , $ key ) { if ( $ l > $ h ) return -1 ; $ mid = ( $ l + $ h ) / 2 ; if ( $ arr [ $ mid ] == $ key ) return $ mid ; if ( $ arr [ $ l ] <= $ arr [ $ mid ] ) { if ( $ key >= $ arr [ $ l ] && $ key <= $ arr [ $ mid ] ) return search ( $ arr , $ l , $ mid - 1 , $ key ) ; return search ( $ arr , $ mid + 1 , $ h , $ key ) ; } if ( $ key >= $ arr [ $ mid ] && $ key <= $ arr [ $ h ] ) return search ( $ arr , $ mid + 1 , $ h , $ key ) ; return search ( $ arr , $ l , $ mid - 1 , $ key ) ; }
function printOdds ( $ arr , $ n ) { $ res = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ res = $ res ^ $ arr [ $ i ] ; $ set_bit = $ res & ( ~ ( $ res - 1 ) ) ; $ x = 0 ; $ y = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] & $ set_bit ) $ x = $ x ^ $ arr [ $ i ] ; else $ y = $ y ^ $ arr [ $ i ] ; } echo ( $ x . " ▁ " . $ y ) ; }
function oddSum ( $ n ) { $ sum = 0 ; $ curr = 1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sum += $ curr ; $ curr += 2 ; } return $ sum ; }
function sumOfSubstrings ( $ num ) { $ sum = 0 ; $ mf = 1 ; for ( $ i = strlen ( $ num ) - 1 ; $ i >= 0 ; $ i -- ) { $ sum += ( $ num [ $ i ] - '0' ) * ( $ i + 1 ) * $ mf ; $ mf = $ mf * 10 + 1 ; } return $ sum ; }
function printIntersection ( $ A , $ B ) { $ N = 4 ; $ M = 4 ; for ( $ i = 0 ; $ i < $ M ; $ i ++ ) { for ( $ j = 0 ; $ j < $ N ; $ j ++ ) { if ( $ A [ $ i ] [ $ j ] == $ B [ $ i ] [ $ j ] ) echo $ A [ $ i ] [ $ j ] . " ▁ " ; else echo " * ▁ " ; } echo " STRNEWLINE " ; } }
function PossibleValues ( $ b , $ x , $ n ) { $ leastdivisible = ( intval ( $ b / $ x ) + 1 ) * $ x ; $ flag = 1 ; while ( $ leastdivisible <= $ n ) { if ( $ leastdivisible - $ b >= 1 ) { echo $ leastdivisible - $ b . " " ; $ leastdivisible += $ x ; $ flag = 0 ; } else break ; } if ( $ flag ) echo " - 1" ; }
function maxSquare ( $ b , $ m ) { return ( $ b / $ m - 1 ) * ( $ b / $ m ) / 2 ; }
function dist ( $ x1 , $ y1 , $ x2 , $ y2 , $ r ) { echo " The ▁ shortest ▁ distance ▁ between ▁ a ▁ point ▁ and ▁ a ▁ circle ▁ is ▁ " , sqrt ( ( pow ( ( $ x2 - $ x1 ) , 2 ) ) + ( pow ( ( $ y2 - $ y1 ) , 2 ) ) ) - $ r ; }
function midpoint ( $ x1 , $ x2 , $ y1 , $ y2 ) { echo ( ( float ) ( $ x1 + $ x2 ) / 2 . " ▁ , ▁ " . ( float ) ( $ y1 + $ y2 ) / 2 ) ; }
function oddNumSum ( $ n ) { return ( $ n * ( 2 * $ n + 1 ) * ( 24 * $ n * $ n * $ n - 12 * $ n * $ n - 14 * $ n + 7 ) ) / 15 ; }
function findMean ( $ arr , $ l , $ r ) { $ sum = 0 ; $ count = 0 ; for ( $ i = $ l ; $ i <= $ r ; $ i ++ ) { $ sum += $ arr [ $ i ] ; $ count ++ ; } $ mean = floor ( $ sum / $ count ) ; return $ mean ; }
function printDivisors ( $ n ) { for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) if ( $ n % $ i == 0 ) echo $ i , " ▁ " ; }
function kth ( $ arr1 , $ arr2 , $ m , $ n , $ k ) { $ sorted1 [ $ m + $ n ] = 0 ; $ i = 0 ; $ j = 0 ; $ d = 0 ; while ( $ i < $ m && $ j < $ n ) { if ( $ arr1 [ $ i ] < $ arr2 [ $ j ] ) $ sorted1 [ $ d ++ ] = $ arr1 [ $ i ++ ] ; else $ sorted1 [ $ d ++ ] = $ arr2 [ $ j ++ ] ; } while ( $ i < $ m ) $ sorted1 [ $ d ++ ] = $ arr1 [ $ i ++ ] ; while ( $ j < $ n ) $ sorted1 [ $ d ++ ] = $ arr2 [ $ j ++ ] ; return $ sorted1 [ $ k - 1 ] ; }
function MaximumPath ( & $ Mat ) { global $ N ; $ result = 0 ; $ dp = array_fill ( 0 , $ N , array_fill ( 0 , $ N + 2 , NULL ) ) ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) $ dp [ 0 ] [ $ i + 1 ] = $ Mat [ 0 ] [ $ i ] ; for ( $ i = 1 ; $ i < $ N ; $ i ++ ) for ( $ j = 1 ; $ j <= $ N ; $ j ++ ) $ dp [ $ i ] [ $ j ] = max ( $ dp [ $ i - 1 ] [ $ j - 1 ] , max ( $ dp [ $ i - 1 ] [ $ j ] , $ dp [ $ i - 1 ] [ $ j + 1 ] ) ) + $ Mat [ $ i ] [ $ j - 1 ] ; for ( $ i = 0 ; $ i <= $ N ; $ i ++ ) $ result = max ( $ result , $ dp [ $ N - 1 ] [ $ i ] ) ; return $ result ; }
function spellsCount ( $ num ) { $ n = strlen ( $ num ) ; $ result = 1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ count = 1 ; while ( $ i < $ n - 1 && $ num [ $ i + 1 ] == $ num [ $ i ] ) { $ count ++ ; $ i ++ ; } $ result = $ result * pow ( 2 , $ count - 1 ) ; } return $ result ; }
function countWaysToJump ( $ arr , $ n ) { $ count_jump ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ count_jump [ $ i ] = 0 ; for ( $ i = $ n - 2 ; $ i >= 0 ; $ i -- ) { if ( $ arr [ $ i ] >= $ n - $ i - 1 ) $ count_jump [ $ i ] ++ ; for ( $ j = $ i + 1 ; $ j < $ n - 1 && $ j <= $ arr [ $ i ] + $ i ; $ j ++ ) if ( $ count_jump [ $ j ] != -1 ) $ count_jump [ $ i ] += $ count_jump [ $ j ] ; if ( $ count_jump [ $ i ] == 0 ) $ count_jump [ $ i ] = -1 ; } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ count_jump [ $ i ] . " ▁ " ; }
function countIslands ( $ mat ) { $ M = 6 ; $ N = 3 ; $ count = 0 ; for ( $ i = 0 ; $ i < $ M ; $ i ++ ) { for ( $ j = 0 ; $ j < $ N ; $ j ++ ) { if ( $ mat [ $ i ] [ $ j ] == ' X ' ) { if ( ( $ i == 0 $ mat [ $ i - 1 ] [ $ j ] == ' O ' ) && ( $ j == 0 $ mat [ $ i ] [ $ j - 1 ] == ' O ' ) ) $ count ++ ; } } } return $ count ; }
function sum ( $ a , $ n ) { $ maxSum = PHP_INT_MIN ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) $ maxSum = max ( $ maxSum , $ a [ $ i ] + $ a [ $ j ] ) ; $ c = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) if ( $ a [ $ i ] + $ a [ $ j ] == $ maxSum ) $ c ++ ; return $ c ; }
function minimumX ( $ n , $ k ) { $ mini = PHP_INT_MAX ; for ( $ i = 1 ; $ i * $ i <= $ n ; $ i ++ ) { if ( $ n % $ i == 0 ) { $ fir = $ i ; $ sec = ( int ) $ n / $ i ; $ num1 = $ fir * $ k + $ sec ; $ res = ( int ) ( $ num1 / $ k ) * ( $ num1 % $ k ) ; if ( $ res == $ n ) $ mini = min ( $ num1 , $ mini ) ; $ num2 = $ sec * $ k + $ fir ; $ res = ( int ) ( $ num2 / $ k ) * ( $ num2 % $ k ) ; if ( $ res == $ n ) $ mini = min ( $ num2 , $ mini ) ; } } return $ mini ; }
function findMinAvgSubarray ( $ arr , $ n , $ k ) { if ( $ n < $ k ) return ; $ res_index = 0 ; $ curr_sum = 0 ; for ( $ i = 0 ; $ i < $ k ; $ i ++ ) $ curr_sum += $ arr [ $ i ] ; $ min_sum = $ curr_sum ; for ( $ i = $ k ; $ i < $ n ; $ i ++ ) { $ curr_sum += $ arr [ $ i ] - $ arr [ $ i - $ k ] ; if ( $ curr_sum < $ min_sum ) { $ min_sum = $ curr_sum ; $ res_index = ( $ i - $ k + 1 ) ; } } echo " Subarray between [ " ▁ , $ res _ index ▁ , ▁ " , " ▁ , $ res _ index ▁ + ▁ $ k ▁ - ▁ 1 , ▁ " ] has minimum average " ; }
function circle ( $ x1 , $ y1 , $ x2 , $ y2 , $ r1 , $ r2 ) { $ distSq = ( $ x1 - $ x2 ) * ( $ x1 - $ x2 ) + ( $ y1 - $ y2 ) * ( $ y1 - $ y2 ) ; $ radSumSq = ( $ r1 + $ r2 ) * ( $ r1 + $ r2 ) ; if ( $ distSq == $ radSumSq ) return 1 ; else if ( $ distSq > $ radSumSq ) return -1 ; else return 0 ; }
function isDivisibleBy25 ( $ str ) { $ n = strlen ( $ str ) ; if ( $ n == 1 ) return false ; return ( ( $ str [ $ n - 1 ] - '0' == 0 && $ str [ $ n - 2 ] - '0' == 0 ) || ( ( $ str [ $ n - 2 ] - '0' ) * 10 + ( $ str [ $ n - 1 ] - '0' ) ) % 25 == 0 ) ; }
function Minsteps ( $ n , $ m ) { $ ans = 0 ; while ( $ m > $ n ) { if ( $ m % 2 != 0 ) { $ m ++ ; $ ans ++ ; } $ m /= 2 ; $ ans ++ ; } return $ ans + $ n - $ m ; }
function CheckArray ( $ arr , $ n ) { $ prod = 1 ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) $ prod *= $ arr [ $ i ] ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) if ( $ arr [ $ i ] == $ prod / $ arr [ $ i ] ) return true ; return false ; }
function ANDS ( & $ a , $ n ) { $ ans = $ a [ 0 ] ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) $ ans &= $ a [ $ i ] ; return $ ans ; }
function nondecdigits ( $ n ) { $ x = 0 ; for ( $ x = $ n ; $ x >= 1 ; $ x -- ) { $ no = $ x ; $ prev_dig = 11 ; $ flag = true ; while ( $ no != 0 ) { if ( $ prev_dig < $ no % 10 ) { $ flag = false ; break ; } $ prev_dig = $ no % 10 ; $ no /= 10 ; } if ( $ flag == true ) break ; } return $ x ; }
function Loss ( $ SP , $ P ) { $ loss = 0 ; $ loss = ( ( 2 * $ P * $ P * $ SP ) / ( 100 * 100 - $ P * $ P ) ) ; print ( " Loss ▁ = ▁ " . round ( $ loss , 3 ) ) ; }
function segregateElements ( & $ arr , $ n ) { $ temp = array ( 0 , $ n , NULL ) ; $ j = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] >= 0 ) $ temp [ $ j ++ ] = $ arr [ $ i ] ; if ( $ j == $ n $ j == 0 ) return ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] < 0 ) $ temp [ $ j ++ ] = $ arr [ $ i ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ arr [ $ i ] = $ temp [ $ i ] ; }
function remainingArea ( $ N , $ M , $ K ) { while ( $ K -- && $ N && $ M ) { if ( $ N > $ M ) $ N = $ N - $ M ; else $ M = $ M - $ N ; } if ( $ N > 0 && $ M > 0 ) return $ N * $ M ; else return 0 ; }
function countCompositions ( $ n ) { return ( ( 1 ) << ( $ n - 1 ) ) ; }
function countConsecutive ( $ N ) { $ count = 0 ; for ( $ L = 1 ; $ L * ( $ L + 1 ) < 2 * $ N ; $ L ++ ) { $ a = ( int ) ( 1.0 * $ N - ( $ L * ( int ) ( $ L + 1 ) ) / 2 ) / ( $ L + 1 ) ; if ( $ a - ( int ) $ a == 0.0 ) $ count ++ ; } return $ count ; }
function areVowelsInOrder ( $ s ) { $ n = strlen ( $ s ) ; $ c = chr ( 64 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ s [ $ i ] == ' a ' $ s [ $ i ] == ' e ' $ s [ $ i ] == ' $ i ' $ s [ $ i ] == ' o ' $ s [ $ i ] == ' u ' ) { if ( $ s [ $ i ] < $ c ) return false ; else { $ c = $ s [ $ i ] ; } } } return true ; }
function countDer ( $ n ) { if ( $ n == 1 ) return 0 ; if ( $ n == 2 ) return 1 ; return ( $ n - 1 ) * ( countDer ( $ n - 1 ) + countDer ( $ n - 2 ) ) ; }
function rmsValue ( $ arr , $ n ) { $ square = 0 ; $ mean = 0.0 ; $ root = 0.0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ square += pow ( $ arr [ $ i ] , 2 ) ; } $ mean = ( $ square / ( float ) ( $ n ) ) ; $ root = sqrt ( $ mean ) ; return $ root ; }
function solve ( $ low , $ high , $ T ) { while ( $ low <= $ high ) { $ mid = ( $ low + $ high ) / 2 ; if ( ( $ mid * ( $ mid + 1 ) ) == $ T ) return $ mid ; if ( $ mid > 0 && ( $ mid * ( $ mid + 1 ) ) > $ T && ( $ mid * ( $ mid - 1 ) ) <= $ T ) return $ mid - 1 ; if ( ( $ mid * ( $ mid + 1 ) ) > $ T ) $ high = $ mid - 1 ; else $ low = $ mid + 1 ; } return -1 ; }
function findN ( $ k ) { $ ans ; if ( $ k == 0 ) $ ans = 3 ; if ( $ k == 1 ) $ ans = 1 ; else if ( $ k % 4 == 0 ) $ ans = $ k ; else if ( $ k % 4 == 3 ) $ ans = $ k - 1 ; else $ ans = -1 ; return $ ans ; }
function MatrixChainOrder ( $ p , $ n ) { $ dp = array ( ) ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ dp [ $ i ] [ $ i ] = 0 ; for ( $ L = 1 ; $ L < $ n - 1 ; $ L ++ ) for ( $ i = 1 ; $ i < $ n - $ L ; $ i ++ ) $ dp [ $ i ] [ $ i + $ L ] = min ( $ dp [ $ i + 1 ] [ $ i + $ L ] + $ p [ $ i - 1 ] * $ p [ $ i ] * $ p [ $ i + $ L ] , $ dp [ $ i ] [ $ i + $ L - 1 ] + $ p [ $ i - 1 ] * $ p [ $ i + $ L - 1 ] * $ p [ $ i + $ L ] ) ; return $ dp [ 1 ] [ $ n - 1 ] ; }
function superSeq ( $ X , $ Y , $ m , $ n ) { $ dp = array_fill ( 0 , $ m + 1 , array_fill ( 0 , $ n + 1 , 0 ) ) ; for ( $ i = 0 ; $ i <= $ m ; $ i ++ ) { for ( $ j = 0 ; $ j <= $ n ; $ j ++ ) { if ( ! $ i ) $ dp [ $ i ] [ $ j ] = $ j ; else if ( ! $ j ) $ dp [ $ i ] [ $ j ] = $ i ; else if ( $ X [ $ i - 1 ] == $ Y [ $ j - 1 ] ) $ dp [ $ i ] [ $ j ] = 1 + $ dp [ $ i - 1 ] [ $ j - 1 ] ; else $ dp [ $ i ] [ $ j ] = 1 + min ( $ dp [ $ i - 1 ] [ $ j ] , $ dp [ $ i ] [ $ j - 1 ] ) ; } } return $ dp [ $ m ] [ $ n ] ; }
function sum ( $ n ) { if ( $ n < 2 ) return 1 ; else return 1 / $ n + ( sum ( $ n - 1 ) ) ; }
function arcLength ( $ diameter , $ angle ) { $ pi = 22.0 / 7.0 ; $ arc ; if ( $ angle >= 360 ) { echo " Angle ▁ cannot " , " ▁ be ▁ formed " ; return 0 ; } else { $ arc = ( $ pi * $ diameter ) * ( $ angle / 360.0 ) ; return $ arc ; } }
function printRepeating ( $ arr , $ size ) { $ i ; echo " The ▁ repeating ▁ elements ▁ are " , " ▁ " ; for ( $ i = 0 ; $ i < $ size ; $ i ++ ) { if ( $ arr [ abs ( $ arr [ $ i ] ) ] > 0 ) $ arr [ abs ( $ arr [ $ i ] ) ] = - $ arr [ abs ( $ arr [ $ i ] ) ] ; else echo abs ( $ arr [ $ i ] ) , " ▁ " ; } }
function isPerfectSquare ( $ x ) { $ sr = sqrt ( $ x ) ; return ( ( $ sr - floor ( $ sr ) ) == 0 ) ; }
function countSeq ( $ n ) { $ nCr = 1 ; $ res = 1 ; for ( $ r = 1 ; $ r <= $ n ; $ r ++ ) { $ nCr = ( $ nCr * ( $ n + 1 - $ r ) ) / $ r ; $ res = $ res + ( $ nCr * $ nCr ) ; } return $ res ; }
function maxArea ( $ A , $ len ) { $ l = 0 ; $ r = $ len - 1 ; $ area = 0 ; while ( $ l < $ r ) { $ area = max ( $ area , min ( $ A [ $ l ] , $ A [ $ r ] ) * ( $ r - $ l ) ) ; if ( $ A [ $ l ] < $ A [ $ r ] ) $ l += 1 ; else $ r -= 1 ; } return $ area ; }
function findPairCount ( $ N , $ K ) { $ count = 0 ; $ rem = array ( 0 , $ K , NULL ) ; $ rem [ 0 ] = intval ( $ N / $ K ) ; for ( $ i = 1 ; $ i < $ K ; $ i ++ ) $ rem [ $ i ] = intval ( ( $ N - $ i ) / $ K ) + 1 ; if ( $ K % 2 == 0 ) { $ count += ( $ rem [ 0 ] * intval ( ( $ rem [ 0 ] - 1 ) ) / 2 ) ; for ( $ i = 1 ; $ i < intval ( $ K / 2 ) ; $ i ++ ) $ count += $ rem [ $ i ] * $ rem [ $ K - $ i ] ; $ count += ( $ rem [ intval ( $ K / 2 ) ] * intval ( ( $ rem [ intval ( $ K / 2 ) ] - 1 ) ) / 2 ) ; } else { $ count += ( $ rem [ 0 ] * intval ( ( $ rem [ 0 ] - 1 ) ) / 2 ) ; for ( $ i = 1 ; $ i <= intval ( $ K / 2 ) ; $ i ++ ) $ count += $ rem [ $ i ] * $ rem [ $ K - $ i ] ; } return $ count ; }
function getMaxOnes ( $ n , $ x ) { $ zeroes = ( int ) ( $ n / $ x ) ; $ zeroes = $ zeroes * $ zeroes ; $ total = $ n * $ n ; $ ans = $ total - $ zeroes ; return $ ans ; }
function SquareCube ( $ N ) { $ cnt = 0 ; $ i = 1 ; while ( ( pow ( $ i , 6 ) ) <= $ N ) { ++ $ cnt ; ++ $ i ; } return $ cnt ; }
function subtract ( & $ A , & $ B , & $ C ) { $ N = 4 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) for ( $ j = 0 ; $ j < $ N ; $ j ++ ) $ C [ $ i ] [ $ j ] = $ A [ $ i ] [ $ j ] - $ B [ $ i ] [ $ j ] ; } $ N = 4 ; $ A = array ( array ( 1 , 1 , 1 , 1 ) , array ( 2 , 2 , 2 , 2 ) , array ( 3 , 3 , 3 , 3 ) , array ( 4 , 4 , 4 , 4 ) ) ; $ B = array ( array ( 1 , 1 , 1 , 1 ) , array ( 2 , 2 , 2 , 2 ) , array ( 3 , 3 , 3 , 3 ) , array ( 4 , 4 , 4 , 4 ) ) ; subtract ( $ A , $ B , $ C ) ; echo " Result ▁ matrix ▁ is ▁ STRNEWLINE " ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { for ( $ j = 0 ; $ j < $ N ; $ j ++ ) { echo $ C [ $ i ] [ $ j ] ; echo " ▁ " ; } echo " STRNEWLINE " ; }
function findPieces ( $ n ) { return ( $ n * ( $ n + 1 ) ) / 2 + 1 ; }
function countSubStr ( $ str , $ len , $ k ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { $ n = 0 ; for ( $ j = $ i ; $ j < $ len ; $ j ++ ) { $ n = $ n * 10 + ( $ str [ $ j ] - '0' ) ; if ( $ n % $ k == 0 ) $ count ++ ; } } return $ count ; }
function centered_cube ( $ n ) { return ( 2 * $ n + 1 ) * ( $ n * $ n + $ n + 1 ) ; }
function squareSum ( $ n ) { return 2 * $ n * ( $ n + 1 ) * ( 2 * $ n + 1 ) / 3 ; }
function validQuadruple ( $ arr , $ n ) { if ( $ n >= MAX ) return true ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) for ( $ k = $ j + 1 ; $ k < $ n ; $ k ++ ) for ( $ l = $ k + 1 ; $ l < $ n ; $ l ++ ) { if ( ( $ arr [ $ i ] ^ $ arr [ $ j ] ^ $ arr [ $ k ] ^ $ arr [ $ l ] ) == 0 ) { return true ; } } return false ; }
function minSumPath ( & $ A ) { $ memo = array ( ) ; for ( $ i = 0 ; $ i < count ( $ A ) ; $ i ++ ) $ memo [ $ i ] = 0 ; $ n = count ( $ A ) - 1 ; for ( $ i = 0 ; $ i < count ( $ A [ $ n ] ) ; $ i ++ ) $ memo [ $ i ] = $ A [ $ n ] [ $ i ] ; for ( $ i = count ( $ A ) - 2 ; $ i >= 0 ; $ i -- ) for ( $ j = 0 ; $ j < count ( $ A [ $ i + 1 ] ) - 1 ; $ j ++ ) $ memo [ $ j ] = $ A [ $ i ] [ $ j ] + min ( $ memo [ $ j ] , $ memo [ $ j + 1 ] ) ; return $ memo [ 0 ] ; }
function countEvenSum ( $ arr , $ n ) { $ result = 0 ; for ( $ i = 0 ; $ i <= $ n - 1 ; $ i ++ ) { $ sum = 0 ; for ( $ j = $ i ; $ j <= $ n - 1 ; $ j ++ ) { $ sum = $ sum + $ arr [ $ j ] ; if ( $ sum % 2 == 0 ) $ result ++ ; } } return ( $ result ) ; }
function check ( $ s , $ m ) { $ l = count ( $ s ) ; $ c1 = 0 ; $ c2 = 0 ; for ( $ i = 0 ; $ i <= $ l ; $ i ++ ) { if ( $ s [ $ i ] == '0' ) { $ c2 = 0 ; $ c1 ++ ; } else { $ c1 = 0 ; $ c2 ++ ; } if ( $ c1 == $ m or $ c2 == $ m ) return true ; } return false ; }
function alter ( $ x , $ y ) { while ( true ) { if ( $ x == 0 $ y == 0 ) break ; if ( $ x >= 2 * $ y ) $ x = $ x % ( 2 * $ y ) ; else if ( $ y >= 2 * $ x ) $ y = $ y % ( 2 * $ x ) ; else break ; } echo " X = " , ▁ $ x , ▁ " , " , ▁ " Y = " }
function swapBits ( $ x , $ p1 , $ p2 , $ n ) { $ set1 = ( $ x >> $ p1 ) & ( ( 1 << $ n ) - 1 ) ; $ set2 = ( $ x >> $ p2 ) & ( ( 1 << $ n ) - 1 ) ; $ xor = ( $ set1 ^ $ set2 ) ; $ xor = ( $ xor << $ p1 ) | ( $ xor << $ p2 ) ; $ result = $ x ^ $ xor ; return $ result ; }
function findSum ( $ n ) { $ arr = array ( array ( ) ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ n ; $ j ++ ) $ arr [ $ i ] [ $ j ] = abs ( $ i - $ j ) ; $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ n ; $ j ++ ) $ sum += $ arr [ $ i ] [ $ j ] ; return $ sum ; }
function findTriplet ( $ a1 , $ a2 , $ a3 , $ n1 , $ n2 , $ n3 , $ sum ) { for ( $ i = 0 ; $ i < $ n1 ; $ i ++ ) for ( $ j = 0 ; $ j < $ n2 ; $ j ++ ) for ( $ k = 0 ; $ k < $ n3 ; $ k ++ ) if ( $ a1 [ $ i ] + $ a2 [ $ j ] + $ a3 [ $ k ] == $ sum ) return true ; return false ; }
function findLastIndex ( $ str , $ x ) { for ( $ i = strlen ( $ str ) - 1 ; $ i >= 0 ; $ i -- ) if ( $ str [ $ i ] == $ x ) return $ i ; return -1 ; }
function factorial ( $ n ) { if ( $ n == 0 ) return 1 ; return $ n * factorial ( $ n - 1 ) ; }
function isTriangular ( $ num ) { if ( $ num < 0 ) return false ; $ c = ( -2 * $ num ) ; $ b = 1 ; $ a = 1 ; $ d = ( $ b * $ b ) - ( 4 * $ a * $ c ) ; if ( $ d < 0 ) return false ; $ root1 = ( - $ b + ( float ) sqrt ( $ d ) ) / ( 2 * $ a ) ; $ root2 = ( - $ b - ( float ) sqrt ( $ d ) ) / ( 2 * $ a ) ; if ( $ root1 > 0 && floor ( $ root1 ) == $ root1 ) return true ; if ( $ root2 > 0 && floor ( $ root2 ) == $ root2 ) return true ; return false ; }
function numberOfCuts ( $ M , $ N ) { $ result = 0 ; $ result = ( $ M - 1 ) * ( $ N - 1 ) ; return $ result ; }
function BalanceArray ( $ A , & $ Q ) { $ ANS = array ( ) ; $ sum = 0 ; for ( $ i = 0 ; $ i < count ( $ A ) ; $ i ++ ) if ( $ A [ $ i ] % 2 == 0 ) $ sum = $ sum + $ A [ $ i ] ; for ( $ i = 0 ; $ i < count ( $ Q ) ; $ i ++ ) { $ index = $ Q [ $ i ] [ 0 ] ; $ value = $ Q [ $ i ] [ 1 ] ; if ( $ A [ $ index ] % 2 == 0 ) $ sum = $ sum - $ A [ $ index ] ; $ A [ $ index ] = $ A [ $ index ] + $ value ; if ( $ A [ $ index ] % 2 == 0 ) $ sum = $ sum + $ A [ $ index ] ; array_push ( $ ANS , $ sum ) ; } for ( $ i = 0 ; $ i < count ( $ ANS ) ; $ i ++ ) echo $ ANS [ $ i ] . " ▁ " ; }
function countMaxIntersect ( $ n ) { return ( $ n ) * ( $ n - 1 ) / 2 ; }
function findDigits ( $ n ) { if ( $ n < 0 ) return 0 ; if ( $ n <= 1 ) return 1 ; $ x = ( ( $ n * log10 ( $ n / M_E ) + log10 ( 2 * M_PI * $ n ) / 2.0 ) ) ; return floor ( $ x ) + 1 ; }
function nthTerm ( $ n ) { return 2 * pow ( $ n , 2 ) + 3 * $ n - 5 ; }
function findTriplets ( $ arr , $ n , $ sum ) { for ( $ i = 0 ; $ i < $ n - 2 ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ n - 1 ; $ j ++ ) { for ( $ k = $ j + 1 ; $ k < $ n ; $ k ++ ) { if ( $ arr [ $ i ] + $ arr [ $ j ] + $ arr [ $ k ] == $ sum ) { echo $ arr [ $ i ] , " " , $ arr [ $ j ] , " " , $ arr [ $ k ] , " " ; } } } } }
function equation_plane ( $ x1 , $ y1 , $ z1 , $ x2 , $ y2 , $ z2 , $ x3 , $ y3 , $ z3 , $ x , $ y , $ z ) { $ a1 = $ x2 - $ x1 ; $ b1 = $ y2 - $ y1 ; $ c1 = $ z2 - $ z1 ; $ a2 = $ x3 - $ x1 ; $ b2 = $ y3 - $ y1 ; $ c2 = $ z3 - $ z1 ; $ a = $ b1 * $ c2 - $ b2 * $ c1 ; $ b = $ a2 * $ c1 - $ a1 * $ c2 ; $ c = $ a1 * $ b2 - $ b1 * $ a2 ; $ d = ( - $ a * $ x1 - $ b * $ y1 - $ c * $ z1 ) ; if ( $ a * $ x + $ b * $ y + $ c * $ z + $ d == 0 ) echo ( " Coplanar " ) ; else echo ( " Not ▁ Coplanar " ) ; }
function printNSE ( $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ next = -1 ; for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) { if ( $ arr [ $ i ] > $ arr [ $ j ] ) { $ next = $ arr [ $ j ] ; break ; } } echo $ arr [ $ i ] . " -- " . ▁ $ next . " " } }
function NicomachuTheorum_sum ( $ n ) { $ sum = 0 ; for ( $ k = 1 ; $ k <= $ n ; $ k ++ ) $ sum += $ k * $ k * $ k ; $ triNo = $ n * ( $ n + 1 ) / 2 ; if ( $ sum == $ triNo * $ triNo ) echo " Yes " ; else echo " No " ; }
function largestNum ( $ a , $ b ) { return ( $ a * ( boolean ) floor ( ( $ a / $ b ) ) ) + ( $ b * ( boolean ) floor ( ( $ b / $ a ) ) ) ; }
function answer ( $ n ) { $ m = 2 ; $ ans = 1 ; $ r = 1 ; while ( $ r < $ n ) { $ r = ( pow ( 2 , $ m ) - 1 ) * ( pow ( 2 , $ m - 1 ) ) ; if ( $ r < $ n ) $ ans = $ r ; $ m ++ ; } return $ ans ; }
function nthTerm ( $ n ) { return 3 * pow ( $ n , 2 ) - 4 * $ n + 2 ; }
function circle_inscribed ( $ a ) { return 3.14 * ( $ a * $ a ) / 12 ; }
function maxLevel ( $ boxes , $ n ) { sort ( $ boxes ) ; $ ans = 1 ; $ prev_width = $ boxes [ 0 ] ; $ prev_count = 1 ; $ curr_count = 0 ; $ curr_width = 0 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ curr_width += $ boxes [ $ i ] ; $ curr_count += 1 ; if ( $ curr_width > $ prev_width and $ curr_count > $ prev_count ) { $ prev_width = $ curr_width ; $ prev_count = $ curr_count ; $ curr_count = 0 ; $ curr_width = 0 ; $ ans ++ ; } } return $ ans ; }
function cost ( $ a , $ n ) { return ( $ n - 1 ) * ( min ( $ a ) ) ; }
function countValues ( $ x ) { $ count = 0 ; $ n = 1 ; while ( $ x != 0 ) { if ( $ x % 2 == 0 ) $ count += $ n ; $ n *= 2 ; $ x /= 2 ; $ x = ( int ) $ x ; } return $ count ; }
function nthTerm ( $ n ) { return 2 * pow ( $ n , 2 ) - $ n - 1 ; }
function stringPalindrome ( $ A , $ B ) { global $ MAX_CHAR ; $ countA = array_fill ( 0 , $ MAX_CHAR , 0 ) ; $ countB = array_fill ( 0 , $ MAX_CHAR , 0 ) ; $ l1 = strlen ( $ A ) ; $ l2 = strlen ( $ B ) ; for ( $ i = 0 ; $ i < $ l1 ; $ i ++ ) $ countA [ ord ( $ A [ $ i ] ) - ord ( ' a ' ) ] ++ ; for ( $ i = 0 ; $ i < $ l2 ; $ i ++ ) $ countB [ ord ( $ B [ $ i ] ) - ord ( ' a ' ) ] ++ ; for ( $ i = 0 ; $ i < 26 ; $ i ++ ) if ( ( $ countA [ $ i ] > 1 && $ countB [ $ i ] == 0 ) ) return ' A ' ; return ' B ' ; }
function countOdd ( $ L , $ R ) { $ N = ( $ R - $ L ) / 2 ; if ( $ R % 2 != 0 $ L % 2 != 0 ) $ N ++ ; return $ N ; }
function findSum ( $ n ) { return sqrt ( 3 ) * ( $ n * ( $ n + 1 ) / 2 ) ; }
function kthdigit ( $ a , $ b , $ k ) { $ p = pow ( $ a , $ b ) ; $ count = 0 ; while ( $ p > 0 and $ count < $ k ) { $ rem = $ p % 10 ; $ count ++ ; if ( $ count == $ k ) return $ rem ; $ p = $ p / 10 ; } return 0 ; }
function centeredNonagonal ( $ n ) { return ( 3 * $ n - 2 ) * ( 3 * $ n - 1 ) / 2 ; }
function pentagon_pyramidal ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ p = ( 3 * $ i * $ i - $ i ) / 2 ; $ sum = $ sum + $ p ; } return $ sum ; }
function evenbitsetnumber ( $ n ) { $ count = 0 ; $ res = 0 ; for ( $ temp = $ n ; $ temp > 0 ; $ temp >>= 1 ) { if ( $ count % 2 == 1 ) $ res |= ( 1 << $ count ) ; $ count ++ ; } return ( $ n $ res ) ; }
function isValid ( $ str , $ len ) { for ( $ i = 1 ; $ i < $ len ; $ i ++ ) { if ( $ str [ $ i ] == $ str [ $ i - 1 ] ) return false ; } return true ; }
function checkArray ( $ arr , $ n ) { return ( $ arr [ 0 ] % 2 ) && ( $ arr [ $ n - 1 ] % 2 ) && ( $ n % 2 ) ; }
function term ( $ n ) { $ d = 2 ; $ a1 = 0 ; $ An = $ a1 + ( $ n - 1 ) * $ d ; return pow ( $ An , 3 ) ; }
function findTwoThreePrime ( $ l , $ r ) { if ( $ l == 1 ) $ l ++ ; $ count = 0 ; for ( $ i = $ l ; $ i <= $ r ; $ i ++ ) { $ num = $ i ; while ( $ num % 2 == 0 ) $ num /= 2 ; while ( $ num % 3 == 0 ) $ num /= 3 ; if ( $ num == 1 ) $ count ++ ; } return $ count ; }
function checkForSorting ( $ arr , $ n ) { $ temp = 0 ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { if ( $ arr [ $ i ] > $ arr [ $ i + 1 ] ) { if ( $ arr [ $ i ] - $ arr [ $ i + 1 ] == 1 ) { $ temp = $ arr [ $ i ] ; $ arr [ $ i ] = $ arr [ $ i + 1 ] ; $ arr [ $ i + 1 ] = $ temp ; } else return false ; } } return true ; }
function multiplyTen ( $ n ) { return ( $ n << 1 ) + ( $ n << 3 ) ; }
function slopeOfNum ( $ num , $ n ) { $ slope = 0 ; for ( $ i = 1 ; $ i < $ n - 1 ; $ i ++ ) { if ( $ num [ $ i ] > $ num [ $ i - 1 ] && $ num [ $ i ] > $ num [ $ i + 1 ] ) $ slope ++ ; else if ( $ num [ $ i ] < $ num [ $ i - 1 ] && $ num [ $ i ] < $ num [ $ i + 1 ] ) $ slope ++ ; } return $ slope ; }
function findAnswer ( $ n , $ arr ) { sort ( $ arr ) ; $ sum = 0 ; for ( $ i = 0 ; $ i < $ n / 2 ; ++ $ i ) { $ sum += ( $ arr [ $ i ] + $ arr [ $ n - $ i - 1 ] ) * ( $ arr [ $ i ] + $ arr [ $ n - $ i - 1 ] ) ; } return $ sum ; }
function getIndexInSortedArray ( $ arr , $ n , $ idx ) { $ result = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] < $ arr [ $ idx ] ) $ result ++ ; if ( $ arr [ $ i ] == $ arr [ $ idx ] and $ i < $ idx ) $ result ++ ; } return $ result ; }
function isValidNesbitt ( $ a , $ b , $ c ) { $ A = $ a / ( $ b + $ c ) ; $ B = $ b / ( $ a + $ c ) ; $ C = $ c / ( $ a + $ b ) ; $ inequality = $ A + $ B + $ C ; return ( $ inequality >= 1.5 ) ; }
function binToDecimal3 ( $ n ) { $ last_3 = ( ( $ n & 4 ) + ( $ n & 2 ) + ( $ n & 1 ) ) ; $ n = $ n >> 3 ; while ( $ n > 7 ) $ n = $ n >> 1 ; $ first_3 = ( ( $ n & 4 ) + ( $ n & 2 ) + ( $ n & 1 ) ) ; echo ( $ first_3 ) ; echo ( " ▁ " ) ; echo ( $ last_3 ) ; }
function KthMinValAfterMconcatenate ( $ A , $ N , $ M , $ K ) { sort ( $ A ) ; return ( $ A [ ( ( $ K - 1 ) / $ M ) ] ) ; }
function isPrime ( $ n ) { if ( $ n <= 1 ) return false ; for ( $ i = 2 ; $ i < $ n ; $ i ++ ) if ( $ n % $ i == 0 ) return false ; return true ; }
function minRemove ( $ arr , $ n ) { $ LIS = array ( ) ; $ len = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ LIS [ $ i ] = 1 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ i ; $ j ++ ) { if ( $ arr [ $ i ] > $ arr [ $ j ] ) $ LIS [ $ i ] = max ( $ LIS [ $ i ] , $ LIS [ $ j ] + 1 ) ; } $ len = max ( $ len , $ LIS [ $ i ] ) ; } return $ n - $ len ; }
function countNumbers ( $ N ) { return ( pow ( 10 , $ N ) - pow ( 8 , $ N ) ) / 2 ; }
function productAscii ( $ str ) { $ prod = 1 ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) { $ prod *= ord ( $ str [ $ i ] ) ; } return $ prod ; }
function mixtureConcentration ( $ n , $ p ) { $ res = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ res += $ p [ $ i ] ; $ res /= $ n ; return $ res ; }
function findThirdDigit ( $ n ) { if ( $ n < 3 ) return 0 ; return $ n & 1 ? 1 : 6 ; }
function evenPowerSum ( $ n ) { return ( 8 * $ n * ( $ n + 1 ) * ( 2 * $ n + 1 ) * ( 3 * $ n * $ n + 3 * $ n - 1 ) ) / 15 ; }
function find_distance ( $ n ) { return $ n * ( ( 3 * $ n ) + 7 ) ; }
function LowerInsertionPoint ( $ arr , $ n , $ X ) { if ( $ X < $ arr [ 0 ] ) return 0 ; else if ( $ X > $ arr [ $ n - 1 ] ) return $ n ; $ lowerPnt = 0 ; $ i = 1 ; while ( $ i < $ n && $ arr [ $ i ] < $ X ) { $ lowerPnt = $ i ; $ i = $ i * 2 ; } while ( $ lowerPnt < $ n && $ arr [ $ lowerPnt ] < $ X ) $ lowerPnt ++ ; return $ lowerPnt ; }
function maxRepeating ( $ arr , $ n , $ k ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ arr [ $ arr [ $ i ] % $ k ] += $ k ; $ max = $ arr [ 0 ] ; $ result = 0 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] > $ max ) { $ max = $ arr [ $ i ] ; $ result = $ i ; } } return $ result ; }
function maxResult ( $ n , $ a , $ b , $ c ) { $ maxVal = 0 ; for ( $ i = 0 ; $ i <= $ n ; $ i += $ a ) for ( $ j = 0 ; $ j <= $ n - $ i ; $ j += $ b ) { $ z = ( $ n - ( $ i + $ j ) ) / $ c ; if ( floor ( $ z ) == ceil ( $ z ) ) { $ x = ( int ) ( $ i / $ a ) ; $ y = ( int ) ( $ j / $ b ) ; $ maxVal = max ( $ maxVal , $ x + $ y + ( int ) $ z ) ; } } return $ maxVal ; }
function evenFibSum ( $ limit ) { if ( $ limit < 2 ) return 0 ; $ ef1 = 0 ; $ ef2 = 2 ; $ sum = $ ef1 + $ ef2 ; while ( $ ef2 <= $ limit ) { $ ef3 = 4 * $ ef2 + $ ef1 ; if ( $ ef3 > $ limit ) break ; $ ef1 = $ ef2 ; $ ef2 = $ ef3 ; $ sum += $ ef2 ; } return $ sum ; }
function getMaxMedian ( $ arr , $ n , $ k ) { $ size = $ n + $ k ; sort ( $ arr , $ n ) ; if ( $ size % 2 == 0 ) { $ median = ( float ) ( $ arr [ ( $ size / 2 ) - 1 ] + $ arr [ $ size / 2 ] ) / 2 ; return $ median ; } $ median = $ arr [ $ size / 2 ] ; return $ median ; }
function icosidigonal_num ( $ n ) { return ( 20 * $ n * $ n - 18 * $ n ) / 2 ; }
function timeToMeet ( $ s , $ v ) { $ V = 3 * $ v / 2 ; $ time = $ s / $ V ; echo $ time ; }
function Perimeter ( $ s , $ n ) { $ perimeter = 1 ; $ perimeter = $ n * $ s ; return $ perimeter ; }
function max_min ( & $ a , $ n ) { sort ( $ a ) ; return min ( $ a [ $ n - 2 ] - $ a [ 0 ] , $ a [ $ n - 1 ] - $ a [ 1 ] ) ; }
function maxDiff ( $ arr , $ n ) { $ result = 0 ; sort ( $ arr ) ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { if ( $ arr [ $ i ] != $ arr [ $ i + 1 ] ) $ result += abs ( $ arr [ $ i ] ) ; else $ i ++ ; } if ( $ arr [ $ n - 2 ] != $ arr [ $ n - 1 ] ) $ result += abs ( $ arr [ $ n - 1 ] ) ; return $ result ; }
function findFlips ( $ str , $ n ) { $ last = ' ▁ ' ; $ res = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ last != $ str [ $ i ] ) $ res ++ ; $ last = $ str [ $ i ] ; } return intval ( $ res / 2 ) ; }
function calculateSum ( $ n ) { return $ n * ( $ n + 1 ) / 2 + $ n * ( $ n + 1 ) * ( 2 * $ n + 1 ) / 6 ; }
function getMinSquares ( $ n ) { $ dp ; $ dp [ 0 ] = 0 ; $ dp [ 1 ] = 1 ; $ dp [ 2 ] = 2 ; $ dp [ 3 ] = 3 ; for ( $ i = 4 ; $ i <= $ n ; $ i ++ ) { $ dp [ $ i ] = $ i ; for ( $ x = 1 ; $ x <= ceil ( sqrt ( $ i ) ) ; $ x ++ ) { $ temp = $ x * $ x ; if ( $ temp > $ i ) break ; else $ dp [ $ i ] = min ( $ dp [ $ i ] , ( 1 + $ dp [ $ i - $ temp ] ) ) ; } } $ res = $ dp [ $ n ] ; return $ res ; }
function subArray ( $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = $ i ; $ j < $ n ; $ j ++ ) { for ( $ k = $ i ; $ k <= $ j ; $ k ++ ) echo $ arr [ $ k ] , " ▁ " ; echo " STRNEWLINE " ; } } }
function minDistance ( $ n1 , $ n2 ) { $ bitCount1 = floor ( log ( $ n1 , 2 ) ) + 1 ; $ bitCount2 = floor ( log ( $ n2 , 2 ) ) + 1 ; $ bitDiff = abs ( $ bitCount1 - $ bitCount2 ) ; $ maxBitCount = max ( $ bitCount1 , $ bitCount2 ) ; if ( $ bitCount1 > $ bitCount2 ) { $ n2 = $ n2 * pow ( 2 , $ bitDiff ) ; } else { $ n1 = $ n1 * pow ( 2 , $ bitDiff ) ; } $ xorValue = $ n1 ^ $ n2 ; $ bitCountXorValue = floor ( log ( $ xorValue , 2 ) ) + 1 ; $ disSimilarBitPosition = $ maxBitCount - $ bitCountXorValue ; $ result = $ bitCount1 + $ bitCount2 - 2 * $ disSimilarBitPosition ; return $ result ; }
function minRadius ( $ k , $ x , $ y , $ n ) { $ dis = array ( ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ dis [ $ i ] = $ x [ $ i ] * $ x [ $ i ] + $ y [ $ i ] * $ y [ $ i ] ; sort ( $ dis ) ; return $ dis [ $ k - 1 ] ; }
function getBoundarySum ( $ a , $ m , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ m ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ i == 0 ) $ sum += $ a [ $ i ] [ $ j ] ; else if ( $ i == $ m - 1 ) $ sum += $ a [ $ i ] [ $ j ] ; else if ( $ j == 0 ) $ sum += $ a [ $ i ] [ $ j ] ; else if ( $ j == $ n - 1 ) $ sum += $ a [ $ i ] [ $ j ] ; } } return $ sum ; }
function trianglearea ( $ r ) { if ( $ r < 0 ) return -1 ; return $ r * $ r ; }
function pairORSum ( $ arr , $ n ) { $ ans = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) $ ans += $ arr [ $ i ] | $ arr [ $ j ] ; return $ ans ; }
function areaSquare ( $ side ) { $ area = $ side * $ side ; return $ area ; }
function SubseqWidths ( & $ A , $ n ) { global $ MOD ; sort ( $ A ) ; $ pow2 = array_fill ( 0 , $ n , NULL ) ; $ pow2 [ 0 ] = 1 ; for ( $ i = 1 ; $ i < $ n ; ++ $ i ) $ pow2 [ $ i ] = ( $ pow2 [ $ i - 1 ] * 2 ) % $ MOD ; $ ans = 0 ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) $ ans = ( $ ans + ( $ pow2 [ $ i ] - $ pow2 [ $ n - 1 - $ i ] ) * $ A [ $ i ] ) % $ MOD ; return $ ans ; }
function CntDivbyX ( $ arr , $ n , $ x ) { $ number = 0 ; $ count1 = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ number = ( $ number * 2 + $ arr [ $ i ] ) % $ x ; if ( $ number == 0 ) $ count1 += 1 ; } return $ count1 ; }
function heightCalculate ( $ H , $ n , $ m ) { $ N = $ n * 1.0 ; $ M = $ m * 1.0 ; $ h = $ H * sqrt ( $ N / ( $ N + $ M ) ) ; return $ h ; }
function printGP ( $ a , $ r , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ curr_term = $ a * pow ( $ r , $ i ) ; echo $ curr_term , " " ; } }
function printClosest ( $ ar1 , $ ar2 , $ m , $ n , $ x ) { $ diff = PHP_INT_MAX ; $ res_l ; $ res_r ; $ l = 0 ; $ r = $ n - 1 ; while ( $ l < $ m and $ r >= 0 ) { if ( abs ( $ ar1 [ $ l ] + $ ar2 [ $ r ] - $ x ) < $ diff ) { $ res_l = $ l ; $ res_r = $ r ; $ diff = abs ( $ ar1 [ $ l ] + $ ar2 [ $ r ] - $ x ) ; } if ( $ ar1 [ $ l ] + $ ar2 [ $ r ] > $ x ) $ r -- ; else $ l ++ ; } echo " The ▁ closest ▁ pair ▁ is ▁ [ " , $ ar1 [ $ res_l ] , " , ▁ " , $ ar2 [ $ res_r ] , " ] ▁ STRNEWLINE " ; }
function isMultipleof5 ( $ n ) { while ( $ n > 0 ) $ n = $ n - 5 ; if ( $ n == 0 ) return true ; return false ; }
function minCost ( $ N , $ P , $ Q ) { $ cost = 0 ; while ( $ N > 0 ) { if ( $ N & 1 ) { $ cost += $ P ; $ N -- ; } else { $ temp = $ N / 2 ; if ( $ temp * $ P > $ Q ) $ cost += $ Q ; else $ cost += $ P * $ temp ; $ N /= 2 ; } } return $ cost ; }
function calculateAlternateSum ( $ n ) { if ( $ n <= 0 ) return 0 ; $ fibo = array ( ) ; $ fibo [ 0 ] = 0 ; $ fibo [ 1 ] = 1 ; $ sum = pow ( $ fibo [ 0 ] , 2 ) + pow ( $ fibo [ 1 ] , 2 ) ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { $ fibo [ $ i ] = $ fibo [ $ i - 1 ] + $ fibo [ $ i - 2 ] ; if ( $ i % 2 == 0 ) $ sum -= $ fibo [ $ i ] ; else $ sum += $ fibo [ $ i ] ; } return $ sum ; }
function poww ( $ a , $ b ) { if ( $ b == 0 ) return 1 ; $ answer = $ a ; $ increment = $ a ; $ i ; $ j ; for ( $ i = 1 ; $ i < $ b ; $ i ++ ) { for ( $ j = 1 ; $ j < $ a ; $ j ++ ) { $ answer += $ increment ; } $ increment = $ answer ; } return $ answer ; }
function longestSubstring ( $ s ) { $ cnt = 1 ; $ maxi = 1 ; $ n = strlen ( $ s ) ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( $ s [ $ i ] != $ s [ $ i - 1 ] ) $ cnt ++ ; else { $ maxi = max ( $ cnt , $ maxi ) ; $ cnt = 1 ; } } $ maxi = max ( $ cnt , $ maxi ) ; return $ maxi ; }
function ellipse ( $ l , $ b ) { if ( $ l < 0 $ b < 0 ) return -1 ; $ x = ( 3.14 * $ l * $ b ) / 4 ; return $ x ; }
function findGreater ( $ a , $ b , $ n ) { if ( ! ( $ n & 1 ) ) { $ a = abs ( $ a ) ; $ b = abs ( $ b ) ; } if ( $ a == $ b ) echo " a ^ n ▁ is ▁ equal ▁ to ▁ b ^ n " ; else if ( $ a > $ b ) echo " a ^ n ▁ is ▁ greater ▁ than ▁ b ^ n " ; else echo " b ^ n ▁ is ▁ greater ▁ than ▁ a ^ n " ; }
function minLettersNeeded ( $ n ) { if ( $ n % 26 == 0 ) return floor ( ( $ n / 26 ) ) ; else return floor ( ( $ n / 26 ) + 1 ) ; }
function toBinary ( $ n ) { if ( $ n >= 1 $ n <= 0 ) return " ERROR " ; $ frac = 0.5 ; $ answer = " . " ; while ( $ n > 0 ) { if ( strlen ( $ answer ) >= 32 ) return " ERROR " ; if ( $ n >= $ frac ) { $ answer . = "1" ; $ n = $ n - $ frac ; } else { $ answer . = "0" ; } $ frac = ( $ frac / 2 ) ; } return $ answer ; }
function binomialCoeff ( $ n , $ k ) { $ C = array_fill ( 0 , $ k + 1 , 0 ) ; $ C [ 0 ] = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { for ( $ j = min ( $ i , $ k ) ; $ j > 0 ; $ j -- ) $ C [ $ j ] = $ C [ $ j ] + $ C [ $ j - 1 ] ; } return $ C [ $ k ] ; }
function check ( $ a , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ a [ $ i ] ) return true ; return false ; }
function countFriendsPairings ( $ n ) { $ dp [ $ n + 1 ] = 0 ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) { if ( $ i <= 2 ) $ dp [ $ i ] = $ i ; else $ dp [ $ i ] = $ dp [ $ i - 1 ] + ( $ i - 1 ) * $ dp [ $ i - 2 ] ; } return $ dp [ $ n ] ; }
function Area ( $ a , $ b ) { if ( $ a < 0 && $ b < 0 ) return -1 ; $ h = sqrt ( ( ( pow ( $ a , 2 ) + pow ( $ b , 2 ) ) / ( pow ( $ a , 2 ) * pow ( $ b , 2 ) ) ) ) ; $ A = 0.70477 * pow ( $ h , 2 ) ; return $ A ; }
function findRectNum ( $ n ) { return $ n * ( $ n + 1 ) ; }
function getRemainder ( $ num , $ divisor ) { $ t = ( $ num - $ divisor * ( int ) ( $ num / $ divisor ) ) ; return $ t ; }
function maxSum ( $ a , $ n ) { $ maxAnd = max ( $ a ) ; $ maxOR = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ maxOR |= $ a [ $ i ] ; print ( $ maxAnd + $ maxOR ) ; }
function countStr ( $ n , $ bCount , $ cCount ) { if ( $ bCount < 0 $ cCount < 0 ) return 0 ; if ( $ n == 0 ) return 1 ; if ( $ bCount == 0 && $ cCount == 0 ) return 1 ; $ res = countStr ( $ n - 1 , $ bCount , $ cCount ) ; $ res += countStr ( $ n - 1 , $ bCount - 1 , $ cCount ) ; $ res += countStr ( $ n - 1 , $ bCount , $ cCount - 1 ) ; return $ res ; }
function findPair ( $ arr , $ n ) { $ found = false ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) { for ( $ k = 0 ; $ k < $ n ; $ k ++ ) { if ( $ arr [ $ i ] + $ arr [ $ j ] == $ arr [ $ k ] ) { echo $ arr [ $ i ] , " ▁ " , $ arr [ $ j ] ; $ found = true ; } } } } if ( $ found == false ) echo " Not ▁ exist " ; }
function quadrant ( $ x , $ y ) { if ( $ x > 0 and $ y > 0 ) echo ( " lies ▁ in ▁ First ▁ quadrant " ) ; else if ( $ x < 0 and $ y > 0 ) echo ( " lies ▁ in ▁ Second ▁ quadrant " ) ; else if ( $ x < 0 and $ y < 0 ) echo ( " lies ▁ in ▁ Third ▁ quadrant " ) ; else if ( $ x > 0 and $ y < 0 ) echo ( " lies ▁ in ▁ Fourth ▁ quadrant " ) ; else if ( $ x == 0 and $ y > 0 ) echo ( " lies ▁ at ▁ positive ▁ y ▁ axis " ) ; else if ( $ x == 0 and $ y < 0 ) echo ( " lies ▁ at ▁ negative ▁ y ▁ axis " ) ; else if ( $ y == 0 and $ x < 0 ) echo ( " lies ▁ at ▁ negative ▁ x ▁ axis " ) ; else if ( $ y == 0 and $ x > 0 ) echo ( " lies ▁ at ▁ positive ▁ x ▁ axis " ) ; else echo ( " lies ▁ at ▁ origin " ) ; }
function printDuplicates ( $ arr , $ n ) { $ i ; $ fl = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ arr [ $ i ] % $ n ] >= $ n ) { if ( $ arr [ $ arr [ $ i ] % $ n ] < 2 * $ n ) { echo $ arr [ $ i ] % $ n . " " ; $ fl = 1 ; } } $ arr [ $ arr [ $ i ] % $ n ] += $ n ; } if ( ! $ fl ) echo " - 1" ; }
function distribution ( $ arr , $ n ) { sort ( $ arr ) ; $ count = 1 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] > $ arr [ $ i - 1 ] ) $ count ++ ; return min ( $ count , $ n / 2 ) ; }
function maxSubArraySum ( $ a , $ size ) { $ max_so_far = $ a [ 0 ] ; $ curr_max = $ a [ 0 ] ; for ( $ i = 1 ; $ i < $ size ; $ i ++ ) { $ curr_max = max ( $ a [ $ i ] , $ curr_max + $ a [ $ i ] ) ; $ max_so_far = max ( $ max_so_far , $ curr_max ) ; } return $ max_so_far ; }
function Dodecagonal_number ( $ n ) { return 5 * $ n * $ n - 4 * $ n ; }
function getSum ( $ n , $ d ) { if ( $ n < $ d ) return 0 ; while ( $ n % 10 != $ d ) $ n -- ; $ k = ( int ) ( $ n / 10 ) ; return ( $ k + 1 ) * $ d + ( $ k * 10 + 10 * $ k * $ k ) / 2 ; }
function calculateSum ( $ arr , $ n ) { if ( $ n == 0 ) return 0 ; $ s = $ arr [ 0 ] ; $ value = ( int ) $ s ; $ sum = $ value ; for ( $ i = 2 ; $ i < $ n ; $ i = $ i + 2 ) { $ s = $ arr [ $ i ] ; $ value = ( int ) $ s ; $ operation = $ arr [ $ i - 1 ] ; if ( $ operation == ' + ' ) $ sum += $ value ; else if ( $ operation == ' - ' ) $ sum -= $ value ; } return $ sum ; }
function nthSHN ( $ n , $ dp ) { if ( $ n == 1 $ n == 2 ) return $ dp [ $ n ] = 1 ; if ( $ dp [ $ n ] != -1 ) return $ dp [ $ n ] ; return $ dp [ $ n ] = ( ( 6 * $ n - 9 ) * nthSHN ( $ n - 1 , $ dp ) - ( $ n - 3 ) * nthSHN ( $ n - 2 , $ dp ) ) / $ n ; }
function xorZero ( $ str ) { $ one_count = 0 ; $ zero_count = 0 ; $ n = strlen ( $ str ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ str [ $ i ] == '1' ) $ one_count ++ ; else $ zero_count ++ ; if ( $ one_count % 2 == 0 ) return $ zero_count ; return $ one_count ; }
function positions ( $ str , $ n ) { $ a = 31 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { print ( ( ord ( $ str [ $ i ] ) & ( $ a ) ) . " " ) ; } }
function polite ( $ n ) { $ n += 1 ; $ base = 2 ; return $ n + ( log ( ( $ n + ( log ( $ n ) / log ( $ base ) ) ) ) ) / log ( $ base ) ; }
function isRotation ( $ x , $ y ) { $ x64 = $ x | ( $ x << 32 ) ; while ( $ x64 >= $ y ) { if ( ( $ x64 ) == $ y ) return 1 ; $ x64 >>= 1 ; } return -1 ; }
function search ( & $ mat , $ n , $ x ) { $ i = 0 ; $ j = $ n - 1 ; while ( $ i < $ n && $ j >= 0 ) { if ( $ mat [ $ i ] [ $ j ] == $ x ) { echo " n ▁ found ▁ at ▁ " . $ i . " , ▁ " . $ j ; return 1 ; } if ( $ mat [ $ i ] [ $ j ] > $ x ) $ j -- ; else $ i ++ ; } echo " n ▁ Element ▁ not ▁ found " ; return 0 ; }
function kthgroupsum ( $ k ) { return $ k * $ k * $ k ; }
function equation_plane ( $ x1 , $ y1 , $ z1 , $ x2 , $ y2 , $ z2 , $ x3 , $ y3 , $ z3 ) { $ a1 = $ x2 - $ x1 ; $ b1 = $ y2 - $ y1 ; $ c1 = $ z2 - $ z1 ; $ a2 = $ x3 - $ x1 ; $ b2 = $ y3 - $ y1 ; $ c2 = $ z3 - $ z1 ; $ a = $ b1 * $ c2 - $ b2 * $ c1 ; $ b = $ a2 * $ c1 - $ a1 * $ c2 ; $ c = $ a1 * $ b2 - $ b1 * $ a2 ; $ d = ( - $ a * $ x1 - $ b * $ y1 - $ c * $ z1 ) ; echo sprintf ( " equation ▁ of ▁ the ▁ plane ▁ is ▁ % .2fx " . " ▁ + ▁ % .2fy ▁ + ▁ % .2fz ▁ + ▁ % .2f ▁ = ▁ 0" , $ a , $ b , $ c , $ d ) ; }
function area ( $ a ) { if ( $ a < 0 ) return -1 ; $ area = sqrt ( $ a ) / 6 ; return $ area ; }
function printCubes ( $ a , $ b ) { for ( $ i = $ a ; $ i <= $ b ; $ i ++ ) { for ( $ j = 1 ; $ j * $ j * $ j <= $ i ; $ j ++ ) { if ( $ j * $ j * $ j == $ i ) { echo $ j * $ j * $ j , " " ; break ; } } } }
function maxSum ( $ grid , $ n ) { $ incl = max ( $ grid [ 0 ] [ 0 ] , $ grid [ 1 ] [ 0 ] ) ; $ excl = 0 ; $ excl_new ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ excl_new = max ( $ excl , $ incl ) ; $ incl = $ excl + max ( $ grid [ 0 ] [ $ i ] , $ grid [ 1 ] [ $ i ] ) ; $ excl = $ excl_new ; } return max ( $ excl , $ incl ) ; }
function printFactorialNums ( $ n ) { $ fact = 1 ; $ x = 2 ; while ( $ fact <= $ n ) { echo $ fact , " " ; $ fact = $ fact * $ x ; $ x ++ ; } }
function reorder ( $ arr , $ index , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ temp [ $ index [ $ i ] ] = $ arr [ $ i ] ; } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ arr [ $ i ] = $ temp [ $ i ] ; $ index [ $ i ] = $ i ; } echo " Reordered ▁ array ▁ is : ▁ STRNEWLINE " ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { echo $ arr [ $ i ] . " " ; } echo " Modified Index array is : " for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { echo $ index [ $ i ] . " " ; } }
function rectCount ( $ n , $ m ) { return ( $ m * $ n * ( $ n + 1 ) * ( $ m + 1 ) ) / 4 ; }
function printCollatz ( $ n ) { while ( $ n != 1 ) { echo $ n . " " ; if ( $ n & 1 ) $ n = 3 * $ n + 1 ; else $ n = $ n / 2 ; } echo $ n ; }
function Series ( $ n ) { $ i ; $ sums = 0.0 ; $ ser ; for ( $ i = 1 ; $ i <= $ n ; ++ $ i ) { $ ser = 1 / pow ( $ i , $ i ) ; $ sums += $ ser ; } return $ sums ; }
function term ( $ n ) { $ ans = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ ans += $ i ; return $ ans ; }
function countNonDecreasing ( $ n ) { $ N = 10 ; $ count = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ count *= ( $ N + $ i - 1 ) ; $ count /= $ i ; } return $ count ; }
function maxProduct ( $ arr , $ n ) { $ INT_MIN = 0 ; if ( $ n < 3 ) return -1 ; $ max_product = $ INT_MIN ; for ( $ i = 0 ; $ i < $ n - 2 ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n - 1 ; $ j ++ ) for ( $ k = $ j + 1 ; $ k < $ n ; $ k ++ ) $ max_product = max ( $ max_product , $ arr [ $ i ] * $ arr [ $ j ] * $ arr [ $ k ] ) ; return $ max_product ; }
function count_1 ( & $ S , $ m , $ n ) { $ table = array_fill ( 0 , $ n + 1 , NULl ) ; $ table [ 0 ] = 1 ; for ( $ i = 0 ; $ i < $ m ; $ i ++ ) for ( $ j = $ S [ $ i ] ; $ j <= $ n ; $ j ++ ) $ table [ $ j ] += $ table [ $ j - $ S [ $ i ] ] ; return $ table [ $ n ] ; }
function countCommon ( $ mat , $ n ) { global $ MAX ; $ res = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ mat [ $ i ] [ $ i ] == $ mat [ $ i ] [ $ n - $ i - 1 ] ) $ res ++ ; return $ res ; }
function isOverflow ( $ a , $ b ) { if ( $ a == 0 $ b == 0 ) return false ; $ result = $ a * $ b ; if ( $ a == ( int ) $ result / $ b ) return false ; else return true ; }
function countOccurrences ( $ arr , $ n , $ x ) { $ res = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ x == $ arr [ $ i ] ) $ res ++ ; return $ res ; }
function pairsInSortedRotated ( $ arr , $ n , $ x ) { $ i ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) if ( $ arr [ $ i ] > $ arr [ $ i + 1 ] ) break ; $ l = ( $ i + 1 ) % $ n ; $ r = $ i ; $ cnt = 0 ; while ( $ l != $ r ) { if ( $ arr [ $ l ] + $ arr [ $ r ] == $ x ) { $ cnt ++ ; if ( $ l == ( $ r - 1 + $ n ) % $ n ) { return $ cnt ; } $ l = ( $ l + 1 ) % $ n ; $ r = ( $ r - 1 + $ n ) % $ n ; } else if ( $ arr [ $ l ] + $ arr [ $ r ] < $ x ) $ l = ( $ l + 1 ) % $ n ; else $ r = ( $ n + $ r - 1 ) % $ n ; } return $ cnt ; }
function mirror_point ( $ a , $ b , $ c , $ d , $ x1 , $ y1 , $ z1 ) { $ k = ( - $ a * $ x1 - $ b * $ y1 - $ c * $ z1 - $ d ) / ( $ a * $ a + $ b * $ b + $ c * $ c ) ; $ x2 = $ a * $ k + $ x1 ; $ y2 = $ b * $ k + $ y1 ; $ z2 = $ c * $ k + $ z1 ; $ x3 = 2 * $ x2 - $ x1 ; $ y3 = 2 * $ y2 - $ y1 ; $ z3 = 2 * $ z2 - $ z1 ; echo sprintf ( " x3 ▁ = ▁ % .1f ▁ " , $ x3 ) ; echo sprintf ( " y3 ▁ = ▁ % .1f ▁ " , $ y3 ) ; echo sprintf ( " z3 ▁ = ▁ % .1f ▁ " , $ z3 ) ; }
function exponential ( $ n , $ x ) { $ sum = 1.0 ; for ( $ i = $ n - 1 ; $ i > 0 ; -- $ i ) $ sum = 1 + $ x * $ sum / $ i ; return $ sum ; }
function countSteps ( $ n ) { $ steps = 0 ; while ( $ n ) { $ largest = ( int ) sqrt ( $ n ) ; $ n -= ( $ largest * $ largest ) ; $ steps ++ ; } return $ steps ; }
function correlationCoefficient ( $ X , $ Y , $ n ) { $ sum_X = 0 ; $ sum_Y = 0 ; $ sum_XY = 0 ; $ squareSum_X = 0 ; $ squareSum_Y = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sum_X = $ sum_X + $ X [ $ i ] ; $ sum_Y = $ sum_Y + $ Y [ $ i ] ; $ sum_XY = $ sum_XY + $ X [ $ i ] * $ Y [ $ i ] ; $ squareSum_X = $ squareSum_X + $ X [ $ i ] * $ X [ $ i ] ; $ squareSum_Y = $ squareSum_Y + $ Y [ $ i ] * $ Y [ $ i ] ; } $ corr = ( float ) ( $ n * $ sum_XY - $ sum_X * $ sum_Y ) / sqrt ( ( $ n * $ squareSum_X - $ sum_X * $ sum_X ) * ( $ n * $ squareSum_Y - $ sum_Y * $ sum_Y ) ) ; return $ corr ; }
function hexDiagonal ( $ a ) { if ( $ a < 0 ) return -1 ; $ d = 1.73 * $ a ; return $ d ; }
function isTriangleExists ( $ a , $ b , $ c ) { if ( $ a != 0 && $ b != 0 && $ c != 0 && ( $ a + $ b + $ c ) == 180 ) if ( ( $ a + $ b ) >= $ c || ( $ b + $ c ) >= $ a || ( $ a + $ c ) >= $ b ) return " YES " ; else return " NO " ; else return " NO " ; }
function countDivisors ( $ n ) { $ cnt = 0 ; for ( $ i = 1 ; $ i <= sqrt ( $ n ) ; $ i ++ ) { if ( $ n % $ i == 0 ) { if ( $ n / $ i == $ i ) $ cnt ++ ; else $ cnt = $ cnt + 2 ; } } return $ cnt ; }
function minimumCost ( & $ cost , $ n ) { $ dp1 = 0 ; $ dp2 = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ dp0 = $ cost [ $ i ] + min ( $ dp1 , $ dp2 ) ; $ dp2 = $ dp1 ; $ dp1 = $ dp0 ; } return min ( $ dp1 , $ dp2 ) ; }
function findOddPair ( & $ A , $ N ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) if ( ( $ A [ $ i ] % 2 == 1 ) ) $ count ++ ; return $ count * ( $ count - 1 ) / 2 ; }
function setRightmostUnsetBit ( $ n ) { if ( ( $ n & ( $ n + 1 ) ) == 0 ) return $ n ; return $ n | ( $ n + 1 ) ; }
function distance ( $ a1 , $ b1 , $ c1 , $ a2 , $ b2 , $ c2 ) { $ d = ( $ a1 * $ a2 + $ b1 * $ b2 + $ c1 * $ c2 ) ; $ e1 = sqrt ( $ a1 * $ a1 + $ b1 * $ b1 + $ c1 * $ c1 ) ; $ e2 = sqrt ( $ a2 * $ a2 + $ b2 * $ b2 + $ c2 * $ c2 ) ; $ d = $ d / ( $ e1 * $ e2 ) ; $ pi = 3.14159 ; $ A = ( 180 / $ pi ) * ( acos ( $ d ) ) ; echo sprintf ( " Angle ▁ is ▁ % .2f ▁ degree " , $ A ) ; }
function Circumference ( $ a ) { return 4 * $ a ; }
function isSubsetSum ( $ arr , $ n , $ sum ) { $ subset [ 2 ] [ $ sum + 1 ] = array ( ) ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 0 ; $ j <= $ sum ; $ j ++ ) { if ( $ j == 0 ) $ subset [ $ i % 2 ] [ $ j ] = true ; else if ( $ i == 0 ) $ subset [ $ i % 2 ] [ $ j ] = false ; else if ( $ arr [ $ i - 1 ] <= $ j ) $ subset [ $ i % 2 ] [ $ j ] = $ subset [ ( $ i + 1 ) % 2 ] [ $ j - $ arr [ $ i - 1 ] ] || $ subset [ ( $ i + 1 ) % 2 ] [ $ j ] ; else $ subset [ $ i % 2 ] [ $ j ] = $ subset [ ( $ i + 1 ) % 2 ] [ $ j ] ; } } return $ subset [ $ n % 2 ] [ $ sum ] ; }
function printSequence ( & $ arr , $ input ) { $ output = " " ; $ n = strlen ( $ input ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ input [ $ i ] == ' ▁ ' ) $ output = $ output + "0" ; else { $ position = ord ( $ input [ $ i ] ) - ord ( ' A ' ) ; $ output = $ output . $ arr [ $ position ] ; } } return $ output ; }
function numofstring ( $ n , $ m ) { if ( $ n == 1 ) return $ m ; if ( $ n == 2 ) return $ m * ( $ m - 1 ) ; return $ m * ( $ m - 1 ) * pow ( $ m - 2 , $ n - 2 ) ; } { $ n = 2 ; $ m = 3 ; echo numofstring ( $ n , $ m ) ; return 0 ; }
function CubeVolume ( $ d ) { $ Volume ; $ Volume = ( sqrt ( 3 ) * pow ( $ d , 3 ) ) / 9 ; return $ Volume ; }
function SieveOfSundaram ( $ n ) { $ nNew = ( $ n - 1 ) / 2 ; $ marked = array_fill ( 0 , ( $ nNew + 1 ) , false ) ; for ( $ i = 1 ; $ i <= $ nNew ; $ i ++ ) for ( $ j = $ i ; ( $ i + $ j + 2 * $ i * $ j ) <= $ nNew ; $ j ++ ) $ marked [ $ i + $ j + 2 * $ i * $ j ] = true ; if ( $ n > 2 ) echo "2 ▁ " ; for ( $ i = 1 ; $ i <= $ nNew ; $ i ++ ) if ( $ marked [ $ i ] == false ) echo ( 2 * $ i + 1 ) . " ▁ " ; }
function noAdjacentDup ( $ s ) { $ n = strlen ( $ s ) ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( $ s [ $ i ] == $ s [ $ i - 1 ] ) { $ s [ $ i ] = ' a ' ; while ( $ s [ $ i ] == $ s [ $ i - 1 ] || ( $ i + 1 < $ n && $ s [ $ i ] == $ s [ $ i + 1 ] ) ) $ s [ $ i ] ++ ; $ i ++ ; } } return $ s ; }
function cen_octagonalnum ( $ n ) { return ( 4 * $ n * $ n - 4 * $ n + 1 ) ; }
function highestPowerof2 ( $ n ) { $ p = ( int ) log ( $ n , 2 ) ; return ( int ) pow ( 2 , $ p ) ; }
function sum ( $ N ) { $ S1 = ( int ) ( ( $ N / 2 ) ) * ( int ) ( 2 * 2 + ( int ) ( $ N / 2 - 1 ) * 2 ) / 2 ; $ S2 = ( int ) ( ( $ N / 7 ) ) * ( int ) ( 2 * 7 + ( int ) ( $ N / 7 - 1 ) * 7 ) / 2 ; $ S3 = ( int ) ( ( $ N / 14 ) ) * ( int ) ( 2 * 14 + ( int ) ( $ N / 14 - 1 ) * 14 ) / 2 ; return ( $ S1 + $ S2 ) - $ S3 ; }
function printCharWithFreq ( $ str ) { global $ SIZE ; $ n = strlen ( $ str ) ; $ freq = array_fill ( 0 , $ SIZE , NULL ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ freq [ ord ( $ str [ $ i ] ) - ord ( ' a ' ) ] ++ ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ freq [ ord ( $ str [ $ i ] ) - ord ( ' a ' ) ] != 0 ) { echo $ str [ $ i ] . $ freq [ ord ( $ str [ $ i ] ) - ord ( ' a ' ) ] . " " ; $ freq [ ord ( $ str [ $ i ] ) - ord ( ' a ' ) ] = 0 ; } } }
function countPermutations ( $ N , $ B ) { $ x = pow ( $ B , $ N ) ; $ y = pow ( $ B , $ N - 1 ) ; echo ( $ x - $ y ) , " STRNEWLINE " ; }
function numLen ( $ K ) { if ( $ K % 2 == 0 $ K % 5 == 0 ) return -1 ; $ number = 0 ; $ len = 1 ; for ( $ len = 1 ; $ len <= $ K ; $ len ++ ) { $ number = ( $ number * 10 + 1 ) % $ K ; if ( $ number == 0 ) return $ len ; } return -1 ; }
function printSubsets ( $ n ) { for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) if ( ( $ n & $ i ) == $ i ) echo $ i . " " ; }
function sumOfSeries ( $ n ) { return ( int ) ( 0.6172 * ( pow ( 10 , $ n ) - 1 ) - 0.55 * $ n ) ; }
function maxValue ( $ n ) { if ( $ n == 1 ) return 0 ; return ( ( $ n * $ n / 2 ) - 1 ) ; }
function maxRevenue ( $ m , $ x , $ revenue , $ n , $ t ) { $ maxRev = array_fill ( 0 , $ m + 1 , false ) ; $ nxtbb = 0 ; for ( $ i = 1 ; $ i <= $ m ; $ i ++ ) { if ( $ nxtbb < $ n ) { if ( $ x [ $ nxtbb ] != $ i ) $ maxRev [ $ i ] = $ maxRev [ $ i - 1 ] ; else { if ( $ i <= $ t ) $ maxRev [ $ i ] = max ( $ maxRev [ $ i - 1 ] , $ revenue [ $ nxtbb ] ) ; else $ maxRev [ $ i ] = max ( $ maxRev [ $ i - $ t - 1 ] + $ revenue [ $ nxtbb ] , $ maxRev [ $ i - 1 ] ) ; $ nxtbb ++ ; } } else $ maxRev [ $ i ] = $ maxRev [ $ i - 1 ] ; } return $ maxRev [ $ m ] ; }
function sortExceptUandL ( $ a , $ l , $ u , $ n ) { $ b = array ( ) ; for ( $ i = 0 ; $ i < $ l ; $ i ++ ) $ b [ $ i ] = $ a [ $ i ] ; for ( $ i = $ u + 1 ; $ i < $ n ; $ i ++ ) $ b [ $ l + ( $ i - ( $ u + 1 ) ) ] = $ a [ $ i ] ; sort ( $ b ) ; for ( $ i = 0 ; $ i < $ l ; $ i ++ ) $ a [ $ i ] = $ b [ $ i ] ; for ( $ i = $ u + 1 ; $ i < $ n ; $ i ++ ) $ a [ $ i ] = $ b [ $ l + ( $ i - ( $ u + 1 ) ) ] ; }
function PowerOFPINnfactorial ( $ n , $ p ) { $ ans = 0 ; $ temp = $ p ; while ( $ temp <= $ n ) { $ ans += $ n / $ temp ; $ temp = $ temp * $ p ; } return $ ans ; }
function eulerian ( $ n , $ m ) { $ dp = array ( array ( ) ) ; for ( $ i = 0 ; $ i < $ n + 1 ; $ i ++ ) for ( $ j = 0 ; $ j < $ m + 1 ; $ j ++ ) $ dp [ $ i ] [ $ j ] = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 0 ; $ j <= $ m ; $ j ++ ) { if ( $ i > $ j ) { if ( $ j == 0 ) $ dp [ $ i ] [ $ j ] = 1 ; else $ dp [ $ i ] [ $ j ] = ( ( $ i - $ j ) * $ dp [ $ i - 1 ] [ $ j - 1 ] ) + ( ( $ j + 1 ) * $ dp [ $ i - 1 ] [ $ j ] ) ; } } } return $ dp [ $ n ] [ $ m ] ; }
function nonDecNums ( $ n ) { for ( $ i = 0 ; $ i <= 9 ; $ i ++ ) $ a [ 0 ] [ $ i ] = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ a [ $ i ] [ 9 ] = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) for ( $ j = 8 ; $ j >= 0 ; $ j -- ) $ a [ $ i ] [ $ j ] = $ a [ $ i - 1 ] [ $ j ] + $ a [ $ i ] [ $ j + 1 ] ; return $ a [ $ n ] [ 0 ] ; }
function isPowerOfTwo ( $ n ) { if ( $ n == 0 ) return 0 ; while ( $ n != 1 ) { if ( $ n % 2 != 0 ) return 0 ; $ n = $ n / 2 ; } return 1 ; }
function Series ( $ x , $ n ) { $ sum = 1 ; $ term = 1 ; $ fct = 1 ; $ p = 1 ; $ multi = 1 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ fct = $ fct * $ multi * ( $ multi + 1 ) ; $ p = $ p * $ x * $ x ; $ term = ( -1 ) * $ term ; $ multi += 2 ; $ sum = $ sum + ( $ term * $ p ) / $ fct ; } return $ sum ; }
function countSubStr ( $ str , $ n ) { $ len = strlen ( $ str ) ; return ( $ len - $ n + 1 ) ; }
function findMajority ( $ arr , $ n ) { return $ arr [ intval ( $ n / 2 ) ] ; }
function countOrderedPairs ( $ N ) { $ count_pairs = 0 ; for ( $ i = 1 ; $ i <= sqrt ( $ N - 1 ) ; ++ $ i ) { for ( $ j = $ i ; $ j * $ i < $ N ; ++ $ j ) ++ $ count_pairs ; } $ count_pairs *= 2 ; $ count_pairs -= ( sqrt ( $ N - 1 ) ) ; return $ count_pairs ; }
function maxvolume ( $ s ) { $ length = ( int ) ( $ s / 3 ) ; $ s -= $ length ; $ breadth = ( int ) ( $ s / 2 ) ; $ height = $ s - $ breadth ; return $ length * $ breadth * $ height ; }
function countWays ( $ n ) { $ count = 0 ; for ( $ i = 1 ; $ i * $ i < $ n ; $ i ++ ) if ( $ n % $ i == 0 ) $ count ++ ; return $ count ; }
function averageEven ( $ n ) { if ( $ n % 2 != 0 ) { echo ( " Invalid ▁ Input " ) ; return -1 ; } return ( $ n + 2 ) / 2 ; }
function evenPowerSum ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ j = 2 * $ i ; $ sum = $ sum + ( $ j * $ j * $ j * $ j ) ; } return $ sum ; }
function kthgroupsum ( $ k ) { $ cur = ( $ k * ( $ k - 1 ) ) + 1 ; $ sum = 0 ; while ( $ k -- ) { $ sum += $ cur ; $ cur += 2 ; } return $ sum ; }
function solve ( $ A , $ B , $ C , $ i , $ j , $ k ) { $ min_diff ; $ current_diff ; $ max_term ; $ min_diff = abs ( max ( $ A [ $ i ] , max ( $ B [ $ j ] , $ C [ $ k ] ) ) - min ( $ A [ $ i ] , min ( $ B [ $ j ] , $ C [ $ k ] ) ) ) ; while ( $ i != -1 && $ j != -1 && $ k != -1 ) { $ current_diff = abs ( max ( $ A [ $ i ] , max ( $ B [ $ j ] , $ C [ $ k ] ) ) - min ( $ A [ $ i ] , min ( $ B [ $ j ] , $ C [ $ k ] ) ) ) ; if ( $ current_diff < $ min_diff ) $ min_diff = $ current_diff ; $ max_term = max ( $ A [ $ i ] , max ( $ B [ $ j ] , $ C [ $ k ] ) ) ; if ( $ A [ $ i ] == $ max_term ) $ i -= 1 ; else if ( $ B [ $ j ] == $ max_term ) $ j -= 1 ; else $ k -= 1 ; } return $ min_diff ; }
function removeChars ( $ s ) { $ modifiedStr = " " ; $ modifiedStr = $ modifiedStr . $ s [ 0 ] ; for ( $ i = 1 ; $ i < strlen ( $ s ) ; $ i ++ ) { if ( ctype_upper ( $ s [ $ i ] ) && ctype_lower ( $ s [ $ i - 1 ] ) || ctype_lower ( $ s [ $ i ] ) && ctype_upper ( $ s [ $ i - 1 ] ) ) $ modifiedStr = $ modifiedStr . $ s [ $ i ] ; } return $ modifiedStr ; }
function equilibrium ( $ arr , $ n ) { $ i ; $ j ; $ leftsum ; $ rightsum ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { $ leftsum = 0 ; $ rightsum = 0 ; for ( $ j = 0 ; $ j < $ i ; $ j ++ ) $ leftsum += $ arr [ $ j ] ; for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) $ rightsum += $ arr [ $ j ] ; if ( $ leftsum == $ rightsum ) return $ i ; } return -1 ; }
function findKCF ( $ x , $ y , $ k ) { $ small = min ( $ x , $ y ) ; $ count = 1 ; for ( $ i = 2 ; $ i <= $ small ; $ i ++ ) { if ( $ x % $ i == 0 && $ y % $ i == 0 ) $ count ++ ; if ( $ count == $ k ) return $ i ; } return -1 ; }
function printAMeans ( $ A , $ B , $ N ) { $ d = ( $ B - $ A ) / ( $ N + 1 ) ; for ( $ i = 1 ; $ i <= $ N ; $ i ++ ) echo ( $ A + $ i * $ d ) , " ▁ " ; }
function isSymmetric ( $ mat , $ N ) { for ( $ i = 0 ; $ i < $ N ; $ i ++ ) for ( $ j = 0 ; $ j < $ N ; $ j ++ ) if ( $ mat [ $ i ] [ $ j ] != $ mat [ $ j ] [ $ i ] ) return false ; return true ; }
function breakSum ( $ n ) { if ( $ n == 0 $ n == 1 ) return $ n ; return max ( ( breakSum ( intval ( $ n / 2 ) ) + breakSum ( intval ( $ n / 3 ) ) + breakSum ( intval ( $ n / 4 ) ) ) , $ n ) ; }
function sum ( $ L , $ R ) { $ p = intval ( $ R / 6 ) ; $ q = intval ( ( $ L - 1 ) / 6 ) ; $ sumR = intval ( 3 * ( $ p * ( $ p + 1 ) ) ) ; $ sumL = intval ( ( $ q * ( $ q + 1 ) ) * 3 ) ; return $ sumR - $ sumL ; }
function max_area ( $ n , $ m , $ k ) { if ( $ k > ( $ n + $ m - 2 ) ) echo " Not ▁ possible " , " STRNEWLINE " ; else { $ result ; if ( $ k < max ( $ m , $ n ) - 1 ) { $ result = max ( $ m * ( $ n / ( $ k + 1 ) ) , $ n * ( $ m / ( $ k + 1 ) ) ) ; } else { $ result = max ( $ m / ( $ k - $ n + 2 ) , $ n / ( $ k - $ m + 2 ) ) ; } echo $ result , " STRNEWLINE " ; } }
function countSubArrays ( $ arr , $ n , $ K ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { $ bitwise_or = 0 ; for ( $ k = $ i ; $ k < $ j + 1 ; $ k ++ ) $ bitwise_or = $ bitwise_or | $ arr [ $ k ] ; if ( $ bitwise_or >= $ K ) $ count += 1 ; } } return $ count ; }
function thirdLargest ( $ arr , $ arr_size ) { if ( $ arr_size < 3 ) { echo " ▁ Invalid ▁ Input ▁ " ; return ; } $ first = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ arr_size ; $ i ++ ) if ( $ arr [ $ i ] > $ first ) $ first = $ arr [ $ i ] ; $ second = PHP_INT_MIN ; for ( $ i = 0 ; $ i < $ arr_size ; $ i ++ ) if ( $ arr [ $ i ] > $ second && $ arr [ $ i ] < $ first ) $ second = $ arr [ $ i ] ; $ third = PHP_INT_MIN ; for ( $ i = 0 ; $ i < $ arr_size ; $ i ++ ) if ( $ arr [ $ i ] > $ third && $ arr [ $ i ] < $ second ) $ third = $ arr [ $ i ] ; echo " The ▁ third ▁ Largest ▁ element ▁ is ▁ " , $ third , " STRNEWLINE " ; }
function reverse ( $ str , $ x ) { $ n = ( strlen ( $ str ) - $ x ) / 2 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo ( $ str [ $ i ] ) ; for ( $ i = $ n + $ x - 1 ; $ i >= $ n ; $ i -- ) echo ( $ str [ $ i ] ) ; for ( $ i = $ n + $ x ; $ i < strlen ( $ str ) ; $ i ++ ) echo $ str [ $ i ] ; }
function nthTerm ( $ N ) { $ nth = 0 ; $ i ; for ( $ i = $ N ; $ i > 0 ; $ i -- ) { $ nth += pow ( $ i , $ i ) ; } return $ nth ; }
function sumNodes ( $ l ) { $ leafNodeCount = ( $ l - 1 ) * ( $ l - 1 ) ; $ sumLastLevel = 0 ; $ sumLastLevel = ( $ leafNodeCount * ( $ leafNodeCount + 1 ) ) / 2 ; $ sum = $ sumLastLevel * $ l ; return $ sum ; }
function maxAND ( $ L , $ R ) { $ maximum = $ L & $ R ; for ( $ i = $ L ; $ i < $ R ; $ i ++ ) for ( $ j = $ i + 1 ; $ j <= $ R ; $ j ++ ) $ maximum = max ( $ maximum , ( $ i & $ j ) ) ; return $ maximum ; }
function findSum ( $ N , $ K ) { $ ans = 0 ; for ( $ i = 1 ; $ i <= $ N ; $ i ++ ) $ ans += ( $ i % $ K ) ; return $ ans ; }
function maxbalancedprefix ( $ str , $ n ) { $ sum = 0 ; $ maxi = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ str [ $ i ] == ' ( ' ) $ sum += 1 ; else $ sum -= 1 ; if ( $ sum < 0 ) break ; if ( $ sum == 0 ) $ maxi = $ i + 1 ; } return $ maxi ; }
function avg_of_even_num ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ sum += 2 * $ i ; return $ sum / $ n ; }
function middleOfThree ( $ a , $ b , $ c ) { if ( $ a > $ b ) { if ( $ b > $ c ) return $ b ; else if ( $ a > $ c ) return $ c ; else return $ a ; } else { if ( $ a > $ c ) return $ a ; else if ( $ b > $ c ) return $ c ; else return $ b ; } }
function seriesSum ( $ n ) { return ( $ n * ( $ n + 1 ) * ( $ n + 2 ) ) / 6 ; }
function Valid ( $ a , $ b , $ c , $ d ) { if ( $ a + $ b + $ c + $ d == 360 ) return true ; return false ; }
function binarySearch ( $ arr , $ low , $ high ) { if ( $ high >= $ low ) { $ mid = ( int ) ( ( $ low + $ high ) / 2 ) ; if ( $ mid == $ arr [ $ mid ] ) return $ mid ; if ( $ mid > $ arr [ $ mid ] ) return binarySearch ( $ arr , ( $ mid + 1 ) , $ high ) ; else return binarySearch ( $ arr , $ low , ( $ mid - 1 ) ) ; } return -1 ; }
function solve ( $ a , $ n ) { $ min1 = $ a [ 0 ] ; $ max1 = $ a [ 0 ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] > $ max1 ) $ max1 = $ a [ $ i ] ; if ( $ a [ $ i ] < $ min1 ) $ min1 = $ a [ $ i ] ; } return abs ( $ min1 - $ max1 ) ; }
function minChanges ( $ A , $ n ) { $ cnt = 0 ; for ( $ i = 0 ; $ i < $ n - 2 ; ++ $ i ) { if ( ( $ i - 1 >= 0 ) && $ A [ $ i - 1 ] == 1 && $ A [ $ i + 1 ] == 1 && $ A [ $ i ] == 0 ) { $ A [ $ i + 1 ] = 0 ; $ cnt ++ ; } } return $ cnt ; }
function evenSum ( $ n ) { $ C = array ( array ( ) ) ; $ i ; $ j ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 0 ; $ j <= min ( $ i , $ n ) ; $ j ++ ) { if ( $ j == 0 or $ j == $ i ) $ C [ $ i ] [ $ j ] = 1 ; else $ C [ $ i ] [ $ j ] = $ C [ $ i - 1 ] [ $ j - 1 ] + $ C [ $ i - 1 ] [ $ j ] ; } } $ sum = 0 ; for ( $ i = 0 ; $ i <= $ n ; $ i += 2 ) $ sum += $ C [ $ n ] [ $ i ] ; return $ sum ; }
function minAdjustmentCost ( $ A , $ n , $ target ) { global $ M ; $ dp = array ( array ( ) ) ; for ( $ j = 0 ; $ j <= $ M ; $ j ++ ) $ dp [ 0 ] [ $ j ] = abs ( $ j - $ A [ 0 ] ) ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j <= $ M ; $ j ++ ) { $ dp [ $ i ] [ $ j ] = PHP_INT_MAX ; for ( $ k = max ( $ j - $ target , 0 ) ; $ k <= min ( $ M , $ j + $ target ) ; $ k ++ ) $ dp [ $ i ] [ $ j ] = min ( $ dp [ $ i ] [ $ j ] , $ dp [ $ i - 1 ] [ $ k ] + abs ( $ A [ $ i ] - $ j ) ) ; } } $ res = PHP_INT_MAX ; for ( $ j = 0 ; $ j <= $ M ; $ j ++ ) $ res = min ( $ res , $ dp [ $ n - 1 ] [ $ j ] ) ; return $ res ; }
function unitnumber ( $ x , $ y ) { $ x = $ x % 10 ; if ( $ y != 0 ) $ y = $ y % 4 + 4 ; return ( ( ( int ) ( pow ( $ x , $ y ) ) ) % 10 ) ; }
function findAllTriplets ( $ arr , $ n ) { for ( $ i = 1 ; $ i < $ n - 1 ; $ i ++ ) { for ( $ j = $ i - 1 , $ k = $ i + 1 ; $ j >= 0 && $ k < $ n { if ( $ arr [ $ j ] + $ arr [ $ k ] == 2 * $ arr [ $ i ] ) { echo $ arr [ $ j ] . " ▁ " . $ arr [ $ i ] . " ▁ " . $ arr [ $ k ] . " STRNEWLINE " ; $ k ++ ; $ j -- ; } else if ( $ arr [ $ j ] + $ arr [ $ k ] < 2 * $ arr [ $ i ] ) $ k ++ ; else $ j -- ; } } }
function getTotalXorOfSubarrayXors ( $ arr , $ N ) { $ res = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { $ freq = ( $ i + 1 ) * ( $ N - $ i ) ; if ( $ freq % 2 == 1 ) $ res = $ res ^ $ arr [ $ i ] ; } return $ res ; }
function find_consecutive_steps ( $ arr , $ len ) { $ count = 0 ; $ maximum = 0 ; for ( $ index = 1 ; $ index < $ len ; $ index ++ ) { if ( $ arr [ $ index ] > $ arr [ $ index - 1 ] ) $ count ++ ; else { $ maximum = max ( $ maximum , $ count ) ; $ count = 0 ; } } return max ( $ maximum , $ count ) ; }
function findExtra ( $ arr1 , $ arr2 , $ n ) { $ index = $ n ; $ left = 0 ; $ right = $ n - 1 ; while ( $ left <= $ right ) { $ mid = ( $ left + $ right ) / 2 ; if ( $ arr2 [ $ mid ] == $ arr1 [ $ mid ] ) $ left = $ mid + 1 ; else { $ index = $ mid ; $ right = $ mid - 1 ; } } return $ index ; } { $ arr1 = array ( 2 , 4 , 6 , 8 , 10 , 12 , 13 ) ; $ arr2 = array ( 2 , 4 , 6 , 8 , 10 , 12 ) ; $ n = sizeof ( $ arr2 ) / sizeof ( $ arr2 [ 0 ] ) ; echo findExtra ( $ arr1 , $ arr2 , $ n ) ; return 0 ; }
function sum ( $ N ) { $ S1 ; $ S2 ; $ S3 ; $ S1 = ( ( $ N / 3 ) ) * ( 2 * 3 + ( $ N / 3 - 1 ) * 3 ) / 2 ; $ S2 = ( ( $ N / 4 ) ) * ( 2 * 4 + ( $ N / 4 - 1 ) * 4 ) / 2 ; $ S3 = ( ( $ N / 12 ) ) * ( 2 * 12 + ( $ N / 12 - 1 ) * 12 ) / 2 ; return $ S1 + $ S2 - $ S3 ; }
function haversine ( $ lat1 , $ lon1 , $ lat2 , $ lon2 ) { $ dLat = ( $ lat2 - $ lat1 ) * M_PI / 180.0 ; $ dLon = ( $ lon2 - $ lon1 ) * M_PI / 180.0 ; $ lat1 = ( $ lat1 ) * M_PI / 180.0 ; $ lat2 = ( $ lat2 ) * M_PI / 180.0 ; $ a = pow ( sin ( $ dLat / 2 ) , 2 ) + pow ( sin ( $ dLon / 2 ) , 2 ) * cos ( $ lat1 ) * cos ( $ lat2 ) ; $ rad = 6371 ; $ c = 2 * asin ( sqrt ( $ a ) ) ; return $ rad * $ c ; }
function increment ( $ i ) { $ i = - ( ~ $ i ) ; return $ i ; }
function printPascal ( $ n ) { $ arr = array ( array ( ) ) ; for ( $ line = 0 ; $ line < $ n ; $ line ++ ) { for ( $ i = 0 ; $ i <= $ line ; $ i ++ ) { if ( $ line == $ i $ i == 0 ) $ arr [ $ line ] [ $ i ] = 1 ; else $ arr [ $ line ] [ $ i ] = $ arr [ $ line - 1 ] [ $ i - 1 ] + $ arr [ $ line - 1 ] [ $ i ] ; echo $ arr [ $ line ] [ $ i ] . " " ; } echo " STRNEWLINE " ; } }
function smallestSubWithSum ( $ arr , $ n , $ x ) { $ curr_sum = 0 ; $ min_len = $ n + 1 ; $ start = 0 ; $ end = 0 ; while ( $ end < $ n ) { while ( $ curr_sum <= $ x && $ end < $ n ) $ curr_sum += $ arr [ $ end ++ ] ; while ( $ curr_sum > $ x && $ start < $ n ) { if ( $ end - $ start < $ min_len ) $ min_len = $ end - $ start ; $ curr_sum -= $ arr [ $ start ++ ] ; } } return $ min_len ; }
function maxXOR ( $ mat , $ N ) { $ r_xor ; $ c_xor ; $ max_xor = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { $ r_xor = 0 ; $ c_xor = 0 ; for ( $ j = 0 ; $ j < $ N ; $ j ++ ) { $ r_xor = $ r_xor ^ $ mat [ $ i ] [ $ j ] ; $ c_xor = $ c_xor ^ $ mat [ $ j ] [ $ i ] ; } if ( $ max_xor < max ( $ r_xor , $ c_xor ) ) $ max_xor = max ( $ r_xor , $ c_xor ) ; } return $ max_xor ; }
function divCount ( $ n ) { $ hash = array_fill ( 0 , $ n + 1 , 1 ) ; for ( $ p = 2 ; ( $ p * $ p ) < $ n ; $ p ++ ) if ( $ hash [ $ p ] == 1 ) for ( $ i = ( $ p * 2 ) ; $ i < $ n ; $ i = ( $ i + $ p ) ) $ hash [ $ i ] = 0 ; $ total = 1 ; for ( $ p = 2 ; $ p <= $ n ; $ p ++ ) { if ( $ hash [ $ p ] == 1 ) { $ count = 0 ; if ( $ n % $ p == 0 ) { while ( $ n % $ p == 0 ) { $ n = ( $ n / $ p ) ; $ count ++ ; } $ total = $ total * ( $ count + 1 ) ; } } } return $ total ; }
function Rate ( $ N1 , $ N2 ) { $ rate = ( $ N2 - $ N1 ) * 100 / $ N1 ; return $ rate ; }
function countXorPair ( $ arr , $ n ) { $ odd = 0 ; $ even = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] % 2 == 0 ) $ even ++ ; else $ odd ++ ; } return $ odd * $ even ; }
function countDigits ( $ n ) { $ ans = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ ans += log10 ( $ i ) ; $ ans = $ ans * $ n ; return 1 + floor ( $ ans ) ; }
function complement ( $ num ) { $ i ; $ len = 0 ; $ comp ; $ temp = $ num ; while ( 1 ) { $ len ++ ; $ num = ( int ) ( $ num / 10 ) ; if ( abs ( $ num ) == 0 ) break ; } $ num = $ temp ; $ comp = pow ( 10 , $ len ) - $ num ; return $ comp ; }
function distancesum ( $ x , $ y , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) $ sum += ( abs ( $ x [ $ i ] - $ x [ $ j ] ) + abs ( $ y [ $ i ] - $ y [ $ j ] ) ) ; return $ sum ; }
function closetAND ( & $ arr , $ n , $ k ) { $ ans = PHP_INT_MAX ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ X = $ arr [ $ i ] ; for ( $ j = $ i ; $ j < $ n ; $ j ++ ) { $ X &= $ arr [ $ j ] ; $ ans = min ( $ ans , abs ( $ k - $ X ) ) ; } } return $ ans ; }
function findSum ( $ N ) { return ( 2 * $ N * ( $ N + 1 ) * ( 4 * $ N + 17 ) + 54 * $ N ) / 6 ; }
function isEditDistanceOne ( $ s1 , $ s2 ) { $ m = strlen ( $ s1 ) ; $ n = strlen ( $ s2 ) ; if ( abs ( $ m - $ n ) > 1 ) return false ; $ count = 0 ; $ i = 0 ; $ j = 0 ; while ( $ i < $ m && $ j < $ n ) { if ( $ s1 [ $ i ] != $ s2 [ $ j ] ) { if ( $ count == 1 ) return false ; if ( $ m > $ n ) $ i ++ ; else if ( $ m < $ n ) $ j ++ ; else { $ i ++ ; $ j ++ ; } $ count ++ ; } else { $ i ++ ; $ j ++ ; } } if ( $ i < $ m $ j < $ n ) $ count ++ ; return $ count == 1 ; }
function cube ( $ h , $ r ) { if ( $ h < 0 && $ r < 0 ) return -1 ; $ a = pow ( $ h , 3 ) ; return $ a ; }
function findMaximum ( $ arr , $ low , $ high ) { $ max = $ arr [ $ low ] ; $ i ; for ( $ i = $ low ; $ i <= $ high ; $ i ++ ) { if ( $ arr [ $ i ] > $ max ) $ max = $ arr [ $ i ] ; } return $ max ; }
function sum ( $ N , $ X , $ Y ) { $ S1 ; $ S2 ; $ S3 ; $ S1 = floor ( ( ( int ) $ N / $ X ) ) * ( 2 * $ X + ( int ) ( ( int ) $ N / $ X - 1 ) * $ X ) / 2 ; $ S2 = floor ( ( ( int ) $ N / $ Y ) ) * ( 2 * $ Y + ( int ) ( ( int ) $ N / $ Y - 1 ) * $ Y ) / 2 ; $ S3 = floor ( ( ( int ) $ N / ( $ X * $ Y ) ) ) * ( 2 * ( $ X * $ Y ) + ( ( int ) $ N / ( $ X * $ Y ) - 1 ) * ( int ) ( $ X * $ Y ) ) / 2 ; return ceil ( $ S1 + ( $ S2 - $ S3 ) ) ; }
function generate_derangement ( $ N ) { $ S = array ( ) ; for ( $ i = 1 ; $ i <= $ N ; $ i ++ ) $ S [ $ i ] = $ i ; $ D = array ( ) ; for ( $ i = 1 ; $ i <= $ N ; $ i += 2 ) { if ( $ i == $ N ) { $ D [ $ N ] = $ S [ $ N - 1 ] ; $ D [ $ N - 1 ] = $ S [ $ N ] ; } else { $ D [ $ i ] = $ i + 1 ; $ D [ $ i + 1 ] = $ i ; } } for ( $ i = 1 ; $ i <= $ N ; $ i ++ ) echo $ D [ $ i ] . " ▁ " ; echo " STRNEWLINE " ; }
function oddSum ( $ n ) { return ( $ n * $ n ) ; }
function sphere ( $ a ) { if ( $ a < 0 ) return -1 ; $ r = ( $ a / 2 ) ; return $ r ; }
function computeLastDigit ( $ A , $ B ) { $ variable = 1 ; if ( $ A == $ B ) return 1 ; else if ( ( $ B - $ A ) >= 5 ) return 0 ; else { for ( $ i = $ A + 1 ; $ i <= $ B ; $ i ++ ) $ variable = ( $ variable * ( $ i % 10 ) ) % 10 ; return $ variable % 10 ; } }
function swapBitsInPair ( $ x ) { return ( ( $ x & 0b10101010 ) >> 1 ) | ( ( $ x & 0b01010101 ) << 1 ) ; }
function count_t ( $ n ) { $ cnt = 0 ; $ p = 1 ; while ( $ p <= $ n ) { $ cnt ++ ; $ p *= 2 ; } return $ cnt ; }
function maxValue ( $ a , $ b ) { sort ( $ b ) ; $ n = sizeof ( $ a ) ; $ m = sizeof ( $ b ) ; $ j = $ m - 1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ j < 0 ) break ; if ( $ b [ $ j ] > $ a [ $ i ] ) { $ a [ $ i ] = $ b [ $ j ] ; $ j -- ; } } $ a = implode ( " " , $ a ) ; return $ a ; }
function isDivisible ( $ str , $ k ) { $ n = strlen ( $ str ) ; $ c = 0 ; for ( $ i = 0 ; $ i < $ k ; $ i ++ ) if ( $ str [ $ n - $ i - 1 ] == '0' ) $ c ++ ; return ( $ c == $ k ) ; }
function getNthTerm ( $ N ) { return 4 * pow ( $ N , 2 ) - 3 * $ N + 2 ; }
function minOp ( $ num ) { $ count = 0 ; while ( $ num ) { $ rem = intval ( $ num % 10 ) ; if ( ! ( $ rem == 3 $ rem == 8 ) ) $ count ++ ; $ num = intval ( $ num / 10 ) ; } return $ count ; }
function isDivisible ( $ n ) { $ temp = $ n ; while ( $ n ) { $ k = $ n % 10 ; if ( $ temp % $ k == 0 ) return " YES " ; $ n = floor ( $ n / 10 ) ; } return " NO " ; }
function maxPrimefactorNum ( $ N ) { if ( $ N < 2 ) return 0 ; $ arr = array_fill ( 0 , ( $ N + 1 ) , true ) ; $ prod = 1 ; $ res = 0 ; for ( $ p = 2 ; $ p * $ p <= $ N ; $ p ++ ) { if ( $ arr [ $ p ] == true ) { for ( $ i = $ p * 2 ; $ i <= $ N ; $ i += $ p ) $ arr [ $ i ] = false ; $ prod *= $ p ; if ( $ prod > $ N ) return $ res ; $ res ++ ; } } return $ res ; }
function nDigitPerfectSquares ( $ n ) { echo pow ( ceil ( sqrt ( pow ( 10 , $ n - 1 ) ) ) , 2 ) , " " ; echo pow ( ceil ( sqrt ( pow ( 10 , $ n ) ) ) - 1 , 2 ) ; }
function printTrib ( $ n ) { if ( $ n < 1 ) return ; $ first = 0 ; $ second = 0 ; $ third = 1 ; echo $ first , " " ; if ( $ n > 1 ) echo $ second , " ▁ " ; if ( $ n > 2 ) echo $ second , " ▁ " ; for ( $ i = 3 ; $ i < $ n ; $ i ++ ) { $ curr = $ first + $ second + $ third ; $ first = $ second ; $ second = $ third ; $ third = $ curr ; echo $ curr , " " ; } }
function printGMeans ( $ A , $ B , $ N ) { $ R = pow ( ( $ B / $ A ) , 1.0 / ( $ N + 1 ) ) ; for ( $ i = 1 ; $ i <= $ N ; $ i ++ ) echo $ A * pow ( $ R , $ i ) , " ▁ " ; }
function minSum ( $ arr , $ n ) { $ sum = $ arr [ 0 ] ; $ prev = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] <= $ prev ) { $ prev = $ prev + 1 ; $ sum = $ sum + $ prev ; } else { $ sum = $ sum + $ arr [ $ i ] ; $ prev = $ arr [ $ i ] ; } } return $ sum ; }
function lengtang ( $ r1 , $ r2 , $ d ) { echo " The ▁ length ▁ of ▁ the ▁ direct ▁ common ▁ tangent ▁ is ▁ " , sqrt ( pow ( $ d , 2 ) - pow ( ( $ r1 - $ r2 ) , 2 ) ) ; }
function findMinDiff ( $ arr , $ n ) { $ diff = PHP_INT_MAX ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) if ( abs ( $ arr [ $ i ] - $ arr [ $ j ] ) < $ diff ) $ diff = abs ( $ arr [ $ i ] - $ arr [ $ j ] ) ; return $ diff ; }
function maxLenSub ( $ arr , $ n ) { $ mls = array ( ) ; $ max = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ mls [ $ i ] = 1 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ i ; $ j ++ ) if ( abs ( $ arr [ $ i ] - $ arr [ $ j ] ) <= 1 and $ mls [ $ i ] < $ mls [ $ j ] + 1 ) $ mls [ $ i ] = $ mls [ $ j ] + 1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ max < $ mls [ $ i ] ) $ max = $ mls [ $ i ] ; return $ max ; }
function sum_of_series ( $ n ) { $ result = 0 ; if ( $ n % 2 == 0 ) { $ result = - ( $ n * ( $ n + 1 ) ) / 2 ; } else { $ result = ( $ n * ( $ n + 1 ) ) / 2 ; } return $ result ; }
function smallestOdd ( $ n ) { if ( $ n == 1 ) return 1 ; return pow ( 10 , $ n - 1 ) + 1 ; }
function printSeries ( $ n ) { for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ num = ( $ i * ( $ i + 1 ) * ( $ i + 2 ) * ( $ i + 3 ) / 24 ) ; echo ( $ num . " " ) ; } }
function binomialCoeff ( $ n , $ k ) { if ( $ k > $ n ) return 0 ; if ( $ k == 0 $ k == $ n ) return 1 ; return binomialCoeff ( $ n - 1 , $ k - 1 ) + binomialCoeff ( $ n - 1 , $ k ) ; }
function alternate ( & $ a , & $ b , & $ x ) { $ x = $ a ^ $ b ^ $ x ; }
function subtractOne ( $ x ) { $ m = 1 ; while ( ! ( $ x & $ m ) ) { $ x = $ x ^ $ m ; $ m <<= 1 ; } $ x = $ x ^ $ m ; return $ x ; }
function printRotatedString ( $ str ) { $ n = strlen ( $ str ) ; $ temp = $ str . $ str ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j != $ n ; $ j ++ ) print ( $ temp [ $ i + $ j ] ) ; print ( " STRNEWLINE " ) ; } }
function countDistinct ( $ arr , $ n ) { sort ( $ arr , 0 ) ; $ res = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { while ( $ i < $ n - 1 && $ arr [ $ i ] == $ arr [ $ i + 1 ] ) $ i ++ ; $ res ++ ; } return $ res ; }
function isSubstring ( $ s1 , $ s2 ) { $ M = strlen ( $ s1 ) ; $ N = strlen ( $ s2 ) ; for ( $ i = 0 ; $ i <= $ N - $ M ; $ i ++ ) { $ j = 0 ; for ( ; $ j < $ M ; $ j ++ ) if ( $ s2 [ $ i + $ j ] != $ s1 [ $ j ] ) break ; if ( $ j == $ M ) return $ i ; } return -1 ; }
function PositionRightmostSetbit ( $ n ) { $ position = 1 ; $ m = 1 ; while ( ! ( $ n & $ m ) ) { $ m = $ m << 1 ; $ position ++ ; } return $ position ; }
function calculate ( $ a , $ n ) { sort ( $ a ) ; $ count = 1 ; $ answer = 0 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] == $ a [ $ i - 1 ] ) { $ count += 1 ; } else { $ answer = $ answer + ( $ count * ( $ count - 1 ) ) / 2 ; $ count = 1 ; } } $ answer = $ answer + ( $ count * ( $ count - 1 ) ) / 2 ; return $ answer ; }
function circumference ( $ r ) { global $ PI ; $ cir = 2 * $ PI * $ r ; return $ cir ; }
function allBitsSetInTheGivenRange ( $ n , $ l , $ r ) { $ num = ( ( 1 << $ r ) - 1 ) ^ ( ( 1 << ( $ l - 1 ) ) - 1 ) ; $ new_num = $ n & $ num ; if ( $ num == $ new_num ) return " Yes " ; return " No " ; }
function areSumSame ( $ a , $ n , $ m ) { $ sum1 = 0 ; $ sum2 = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sum1 = 0 ; $ sum2 = 0 ; for ( $ j = 0 ; $ j < $ m ; $ j ++ ) { $ sum1 += $ a [ $ i ] [ $ j ] ; $ sum2 += $ a [ $ j ] [ $ i ] ; } if ( $ sum1 == $ sum2 ) return true ; } return false ; }
function check ( $ str ) { $ n = strlen ( $ str ) ; $ digitSum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ digitSum += ( $ str [ $ i ] - '0' ) ; return ( $ digitSum % 3 == 0 ) ; }
function summation ( $ n ) { $ sum ; $ sum = ( pow ( 10 , $ n + 1 ) - 10 - ( 9 * $ n ) ) / 81 ; return $ sum ; }
function isPossible ( $ Sx , $ Sy , $ Dx , $ Dy , $ x , $ y ) { if ( abs ( $ Sx - $ Dx ) % $ x == 0 && abs ( $ Sy - $ Dy ) % $ y == 0 && ( abs ( $ Sx - $ Dx ) / $ x ) % 2 == ( abs ( $ Sy - $ Dy ) / $ y ) % 2 ) return true ; return false ; }
function productPuzzle ( $ a , $ n ) { global $ EPS ; $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum += ( double ) log10 ( $ a [ $ i ] ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo ( int ) ( $ EPS + pow ( ( double ) 10.00 , $ sum - log10 ( $ a [ $ i ] ) ) ) . " ▁ " ; }
function permutationCoeff ( $ n , $ k ) { $ fact = array ( ) ; $ fact [ 0 ] = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ fact [ $ i ] = $ i * $ fact [ $ i - 1 ] ; return $ fact [ $ n ] / $ fact [ $ n - $ k ] ; }
function T_ime ( $ arr , $ n , $ Emptypipe ) { $ fill = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ fill += 1 / $ arr [ $ i ] ; $ fill = $ fill - ( 1 / $ Emptypipe ) ; return 1 / $ fill ; }
function countRabbits ( $ Heads , $ Legs ) { $ count = 0 ; $ count = ( $ Legs ) - 2 * ( $ Heads ) ; $ count = ( int ) $ count / 2 ; return $ count ; }
function coun ( $ S , $ m , $ n ) { if ( $ n == 0 ) return 1 ; if ( $ n < 0 ) return 0 ; if ( $ m <= 0 && $ n >= 1 ) return 0 ; return coun ( $ S , $ m - 1 , $ n ) + coun ( $ S , $ m , $ n - $ S [ $ m - 1 ] ) ; }
function countWays ( $ n , $ k ) { $ total = $ k ; $ mod = 1000000007 ; $ same = 0 ; $ diff = $ k ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { $ same = $ diff ; $ diff = $ total * ( $ k - 1 ) ; $ diff = $ diff % $ mod ; $ total = ( $ same + $ diff ) % $ mod ; } return $ total ; }
function findStarNum ( $ n ) { return ( 6 * $ n * ( $ n - 1 ) + 1 ) ; }
function findProffesion ( $ level , $ pos ) { if ( $ level == 1 ) return ' e ' ; if ( findProffesion ( $ level - 1 , ( $ pos + 1 ) / 2 ) == ' d ' ) return ( $ pos % 2 ) ? ' d ' : ' e ' ; return ( $ pos % 2 ) ? ' e ' : ' d ' ; }
function checkpoint ( $ h , $ k , $ x , $ y , $ a , $ b ) { $ p = ( pow ( ( $ x - $ h ) , 2 ) / pow ( $ a , 2 ) ) + ( pow ( ( $ y - $ k ) , 2 ) / pow ( $ b , 2 ) ) ; return $ p ; }
function isDivisible ( $ n ) { while ( intval ( $ n / 100 ) ) { $ last_digit = $ n % 10 ; $ n = intval ( $ n / 10 ) ; $ n += $ last_digit * 3 ; } return ( $ n % 29 == 0 ) ; }
function calculate ( $ X ) { $ number_of_bits = 8 ; return ( ( 1 << $ number_of_bits ) - 1 ) ^ $ X ; }
function calculate ( $ a , $ b , $ n , $ m ) { $ mul = 1 ; for ( $ i = 0 ; $ i < $ m ; $ i ++ ) if ( $ b [ $ i ] != 0 ) $ mul = $ mul * $ b [ $ i ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ x = floor ( $ a [ $ i ] / $ mul ) ; echo $ x , " " ; } }
function countDigitsToBeRemoved ( $ N , $ K ) { $ s = strval ( $ N ) ; $ res = 0 ; $ f_zero = 0 ; for ( $ i = strlen ( $ s ) - 1 ; $ i >= 0 ; $ i -- ) { if ( $ K == 0 ) return $ res ; if ( $ s [ $ i ] == '0' ) { $ f_zero = 1 ; $ K -- ; } else $ res ++ ; } if ( ! $ K ) return $ res ; else if ( $ f_zero ) return strlen ( $ s ) - 1 ; return -1 ; }
function countWays ( $ N ) { $ E = ( $ N * ( $ N - 1 ) ) / 2 ; if ( $ N == 1 ) return 0 ; return ( int ) pow ( 2 , $ E - 1 ) ; }
function CountCharacters ( $ str , $ l , $ r ) { $ cnt = 0 ; $ m = array_fill ( 0 , 256 , NULL ) ; $ len = strlen ( $ str ) ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { if ( ! ( $ l <= ord ( $ str [ $ i ] ) and ord ( $ str [ $ i ] ) <= $ r ) ) { $ cnt ++ ; if ( isset ( $ m [ ord ( $ str [ $ i ] ) ] ) != 1 ) { echo $ str [ $ i ] . " " ; $ m [ ord ( $ str [ $ i ] ) ] ++ ; } } } return $ cnt ; }
function isSubsetSum ( $ set , $ n , $ sum ) { if ( $ sum == 0 ) return true ; if ( $ n == 0 ) return false ; if ( $ set [ $ n - 1 ] > $ sum ) return isSubsetSum ( $ set , $ n - 1 , $ sum ) ; return isSubsetSum ( $ set , $ n - 1 , $ sum ) || isSubsetSum ( $ set , $ n - 1 , $ sum - $ set [ $ n - 1 ] ) ; }
function squareSide ( $ a ) { if ( $ a < 0 ) return -1 ; $ x = 0.423 * $ a ; return $ x ; }
function countOnes ( $ n ) { $ count = 1 ; $ rem = 1 ; while ( $ rem != 0 ) { $ rem = ( $ rem * 10 + 1 ) % $ n ; $ count ++ ; } return $ count ; }
function maxPrimes ( $ n ) { return ( int ) ( $ n / 2 ) ; }
function transpose ( & $ A ) { for ( $ i = 0 ; $ i < $ N ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ N ; $ j ++ ) { $ temp = $ A [ $ i ] [ $ j ] ; $ A [ $ i ] [ $ j ] = $ A [ $ j ] [ $ i ] ; $ A [ $ j ] [ $ i ] = $ temp ; } } $ N = 4 ; $ A = array ( array ( 1 , 1 , 1 , 1 ) , array ( 2 , 2 , 2 , 2 ) , array ( 3 , 3 , 3 , 3 ) , array ( 4 , 4 , 4 , 4 ) ) ; transpose ( $ A ) ; echo " Modified ▁ matrix ▁ is ▁ " . " STRNEWLINE " ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { for ( $ j = 0 ; $ j < $ N ; $ j ++ ) echo $ A [ $ i ] [ $ j ] . " ▁ " ; echo " STRNEWLINE " ; }
function MinimumX ( $ a , $ b , $ c , $ k ) { $ x = PHP_INT_MAX ; if ( $ k <= $ c ) return 0 ; $ h = $ k - $ c ; $ l = 0 ; while ( $ l <= $ h ) { $ m = floor ( ( $ l + $ h ) / 2 ) ; if ( ( $ a * $ m * $ m ) + ( $ b * $ m ) > ( $ k - $ c ) ) { $ x = min ( $ x , $ m ) ; $ h = $ m - 1 ; } else if ( ( $ a * $ m * $ m ) + ( $ b * $ m ) < ( $ k - $ c ) ) $ l = $ m + 1 ; else return $ m ; } return $ x ; }
function nthTerm ( $ n ) { return 5 * pow ( $ n , 2 ) - 5 * $ n ; }
function maxRepeating ( $ str ) { $ n = strlen ( $ str ) ; $ count = 0 ; $ res = $ str [ 0 ] ; $ cur_count = 1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ i < $ n - 1 && $ str [ $ i ] == $ str [ $ i + 1 ] ) $ cur_count ++ ; else { if ( $ cur_count > $ count ) { $ count = $ cur_count ; $ res = $ str [ $ i ] ; } $ cur_count = 1 ; } } return $ res ; }
function trianglearea ( $ l , $ b ) { if ( $ l < 0 or $ b < 0 ) return -1 ; $ area = ( $ l * $ b ) / 2 ; return $ area ; }
function lbs ( & $ arr , $ n ) { $ lis = array_fill ( 0 , $ n , NULL ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ lis [ $ i ] = 1 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ i ; $ j ++ ) if ( $ arr [ $ i ] > $ arr [ $ j ] && $ lis [ $ i ] < $ lis [ $ j ] + 1 ) $ lis [ $ i ] = $ lis [ $ j ] + 1 ; $ lds = array_fill ( 0 , $ n , NULL ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ lds [ $ i ] = 1 ; for ( $ i = $ n - 2 ; $ i >= 0 ; $ i -- ) for ( $ j = $ n - 1 ; $ j > $ i ; $ j -- ) if ( $ arr [ $ i ] > $ arr [ $ j ] && $ lds [ $ i ] < $ lds [ $ j ] + 1 ) $ lds [ $ i ] = $ lds [ $ j ] + 1 ; $ max = $ lis [ 0 ] + $ lds [ 0 ] - 1 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) if ( $ lis [ $ i ] + $ lds [ $ i ] - 1 > $ max ) $ max = $ lis [ $ i ] + $ lds [ $ i ] - 1 ; return $ max ; }
function hexadiagonal ( $ a ) { if ( $ a < 0 ) return -1 ; return 2 * $ a ; }
function countSteps ( $ x , $ y ) { if ( $ x % $ y == 0 ) return floor ( ( ( int ) $ x / $ y ) ) ; return floor ( ( ( int ) $ x / $ y ) + countSteps ( $ y , $ x % $ y ) ) ; }
function segregate0and1 ( $ arr , $ n ) { $ type0 = 0 ; $ type1 = $ n - 1 ; while ( $ type0 < $ type1 ) { if ( $ arr [ $ type0 ] == 1 ) { $ temp = $ arr [ $ type0 ] ; $ arr [ $ type0 ] = $ arr [ $ type1 ] ; $ arr [ $ type1 ] = $ temp ; $ type1 -- ; } else { $ type0 ++ ; } } return $ arr ; }
function makeOdd ( $ n ) { if ( $ n % 2 != 0 ) return 1 ; $ resul = 1 ; while ( $ n % 2 == 0 ) { $ n /= 2 ; $ resul *= 2 ; } return $ resul ; }
function find_sum_of_two_squares ( $ a , $ b ) { $ ab = $ a * $ b ; for ( $ i = 0 ; $ i * $ i <= $ ab ; $ i ++ ) { for ( $ j = $ i ; $ i * $ i + $ j * $ j <= $ ab ; $ j ++ ) { if ( $ i * $ i + $ j * $ j == $ ab ) echo $ i , " ^ 2 ▁ + ▁ " , $ j , " ^ 2 ▁ = ▁ " , $ ab , " STRNEWLINE " ; } } }
function calculateSum ( $ n ) { $ sum = 0 ; for ( $ row = 0 ; $ row < $ n ; $ row ++ ) { $ sum = $ sum + ( 1 << $ row ) ; } return $ sum ; }
function calculateSum ( $ n ) { $ sum = 0 ; $ sum = 1 << $ n ; return ( $ sum - 1 ) ; }
function EqualNumber ( $ A , $ B ) { return ( $ A ^ $ B ) ; }
function minCost ( $ cost ) { global $ INF ; global $ N ; $ dist [ $ N ] = array ( ) ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) $ dist [ $ i ] = $ INF ; $ dist [ 0 ] = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ N ; $ j ++ ) if ( $ dist [ $ j ] > $ dist [ $ i ] + $ cost [ $ i ] [ $ j ] ) $ dist [ $ j ] = $ dist [ $ i ] + $ cost [ $ i ] [ $ j ] ; return $ dist [ $ N - 1 ] ; }
function findRadiusOfcircumcircle ( $ l , $ b ) { if ( $ l < 0 $ b < 0 ) return -1 ; $ radius = sqrt ( pow ( $ l , 2 ) + pow ( $ b , 2 ) ) / 2 ; return $ radius ; }
function countWays ( $ n ) { $ res [ 0 ] = 1 ; $ res [ 1 ] = 1 ; $ res [ 2 ] = 2 ; for ( $ i = 3 ; $ i <= $ n ; $ i ++ ) $ res [ $ i ] = $ res [ $ i - 1 ] + $ res [ $ i - 2 ] + $ res [ $ i - 3 ] ; return $ res [ $ n ] ; }
function sumofNterm ( $ a , $ d , $ b , $ r , $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ sum += ( ( $ a + ( $ i - 1 ) * $ d ) * ( $ b * pow ( $ r , $ i - 1 ) ) ) ; return $ sum ; }
function perimeter ( $ diameter , $ height ) { return 2 * ( $ diameter + $ height ) ; }
function smallestEven ( $ n ) { if ( $ n == 1 ) return 0 ; return pow ( 10 , $ n - 1 ) ; }
function totalSumDivisibleByNum ( $ n , $ number ) { $ firstnum = pow ( 10 , $ n - 1 ) ; $ lastnum = pow ( 10 , $ n ) ; $ sum = 0 ; for ( $ i = $ firstnum ; $ i < $ lastnum ; $ i ++ ) if ( $ i % $ number == 0 ) $ sum += $ i ; return $ sum ; }
function printPair ( $ g , $ l ) { echo $ g ; echo ( " ▁ " ) ; echo $ l ; }
function leftRotate ( $ arr , $ n , $ k ) { for ( $ i = $ k ; $ i < $ k + $ n ; $ i ++ ) echo $ arr [ $ i % $ n ] , " ▁ " ; }
function normal ( $ m , $ n ) { $ N = ( abs ( $ m ) * abs ( $ n ) ) / sqrt ( ( abs ( $ m ) * abs ( $ m ) ) + ( abs ( $ n ) * abs ( $ n ) ) ) ; return $ N ; }
function countPaths ( $ m , $ n ) { if ( $ m == 1 $ n == 1 ) return 1 ; return countPaths ( $ m - 1 , $ n ) + countPaths ( $ m , $ n - 1 ) ; }
function seriesSum ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ sum += $ i * ( $ i + 1 ) / 2 ; return $ sum ; }
function nthMagicNo ( $ n ) { $ pow = 1 ; $ answer = 0 ; while ( $ n ) { $ pow = $ pow * 5 ; if ( $ n & 1 ) $ answer += $ pow ; } return $ answer ; }
function findSumSubsets ( $ n ) { return ( $ n * ( $ n + 1 ) / 2 ) * ( 1 << ( $ n - 1 ) ) ; }
function countPaths ( $ n ) { $ zB = 1 ; $ zADC = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ nzB = $ zADC * 3 ; $ nzADC = ( $ zADC * 2 + $ zB ) ; $ zB = $ nzB ; $ zADC = $ nzADC ; } return $ zB ; }
function pell ( $ n ) { if ( $ n <= 2 ) return $ n ; $ a = 1 ; $ b = 2 ; $ c ; $ i ; for ( $ i = 3 ; $ i <= $ n ; $ i ++ ) { $ c = 2 * $ b + $ a ; $ a = $ b ; $ b = $ c ; } return $ b ; }
function shortestLength ( $ n , & $ x , & $ y ) { $ answer = 0 ; $ i = 0 ; while ( $ n -- ) { if ( $ x [ $ i ] + $ y [ $ i ] > $ answer ) $ answer = $ x [ $ i ] + $ y [ $ i ] ; $ i ++ ; } echo " Length ▁ - > ▁ " . $ answer . " STRNEWLINE " ; echo " Path ▁ - > ▁ " . " ( 1 , " ▁ . $ answer ▁ . " ) " . STRNEWLINE TABSYMBOL TABSYMBOL " and ( " ▁ . $ answer ▁ . ▁ " , 1 ) " ; }
function isRatioPossible ( $ lowCost , $ upCost , $ lowQuant , $ upQuant , $ r ) { for ( $ i = $ lowQuant ; $ i <= $ upQuant ; $ i ++ ) { $ ans = $ i * $ r ; if ( $ lowCost <= $ ans && $ ans <= $ upCost ) return true ; } return false ; }
function isTidy ( $ num ) { $ prev = 10 ; while ( $ num ) { $ rem = $ num % 10 ; $ num = ( int ) $ num / 10 ; if ( $ rem > $ prev ) return false ; $ prev = $ rem ; } return true ; }
function complement ( $ number ) { for ( $ i = 0 ; $ i < strlen ( $ number ) ; $ i ++ ) if ( $ number [ $ i ] != ' . ' ) $ number [ $ i ] = '9' - $ number [ $ i ] + '0' ; echo "9 ' s ▁ complement ▁ is ▁ : ▁ " , $ number ; }
function pendulumArrangement ( $ arr , $ n ) { sort ( $ arr , $ n ) ; sort ( $ arr ) ; $ op [ $ n ] = NULL ; $ mid = floor ( ( $ n - 1 ) / 2 ) ; $ j = 1 ; $ i = 1 ; $ op [ $ mid ] = $ arr [ 0 ] ; for ( $ i = 1 ; $ i <= $ mid ; $ i ++ ) { $ op [ $ mid + $ i ] = $ arr [ $ j ++ ] ; $ op [ $ mid - $ i ] = $ arr [ $ j ++ ] ; } if ( $ n % 2 == 0 ) $ op [ $ mid + $ i ] = $ arr [ $ j ] ; echo " Pendulum ▁ arrangement : " ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ op [ $ i ] , " ▁ " ; echo " STRNEWLINE " ; }
function findS ( $ s ) { $ l = 1 ; $ r = 1 + ( int ) $ s / 2 ; while ( $ l <= $ r ) { $ mid = ( int ) ( ( $ l + $ r ) / 2 ) ; $ sum = ( int ) ( $ mid * ( $ mid + 1 ) / 2 ) ; if ( $ sum == $ s ) return $ mid ; else if ( $ sum > $ s ) $ r = $ mid - 1 ; else $ l = $ mid + 1 ; } return -1 ; }
function printNumberWithDR ( $ k , $ d ) { if ( $ d == 0 && $ k != 1 ) echo " - 1" ; else { echo $ d ; $ k -- ; while ( $ k -- ) echo "0" ; } }
function fib ( $ n ) { $ a = 0 ; $ b = 1 ; $ c ; if ( $ n >= 0 ) echo $ a , " ▁ " ; if ( $ n >= 1 ) echo $ b , " ▁ " ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { $ c = $ a + $ b ; echo $ c , " " ; $ a = $ b ; $ b = $ c ; } }
function Next_greater ( $ a , $ n , $ x ) { sort ( $ a ) ; $ low = 0 ; $ high = $ n - 1 ; $ ans = $ x + 1 ; while ( $ low <= $ high ) { $ mid = ( $ low + $ high ) / 2 ; if ( $ a [ $ mid ] <= $ ans ) { if ( $ a [ $ mid ] == $ ans ) { $ ans ++ ; $ high = $ n - 1 ; } $ low = $ mid + 1 ; } else $ high = $ mid - 1 ; } return $ ans ; }
function minTime ( $ arr , $ n ) { if ( $ n <= 0 ) return 0 ; $ excl = 0 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ incl_new = $ arr [ $ i ] + min ( $ excl , $ incl ) ; $ excl_new = $ incl ; $ incl = $ incl_new ; $ excl = $ excl_new ; } return min ( $ incl , $ excl ) ; }
function countPaths ( $ n , $ m ) { for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) $ dp [ $ i ] [ 0 ] = 1 ; for ( $ i = 0 ; $ i <= $ m ; $ i ++ ) $ dp [ 0 ] [ $ i ] = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) for ( $ j = 1 ; $ j <= $ m ; $ j ++ ) $ dp [ $ i ] [ $ j ] = $ dp [ $ i - 1 ] [ $ j ] + $ dp [ $ i ] [ $ j - 1 ] ; return $ dp [ $ n ] [ $ m ] ; }
function maxSumWO3Consec ( $ arr , $ n ) { $ sum = array ( ) ; if ( $ n >= 1 ) $ sum [ 0 ] = $ arr [ 0 ] ; if ( $ n >= 2 ) $ sum [ 1 ] = $ arr [ 0 ] + $ arr [ 1 ] ; if ( $ n > 2 ) $ sum [ 2 ] = max ( $ sum [ 1 ] , max ( $ arr [ 1 ] + $ arr [ 2 ] , $ arr [ 0 ] + $ arr [ 2 ] ) ) ; for ( $ i = 3 ; $ i < $ n ; $ i ++ ) $ sum [ $ i ] = max ( max ( $ sum [ $ i - 1 ] , $ sum [ $ i - 2 ] + $ arr [ $ i ] ) , $ arr [ $ i ] + $ arr [ $ i - 1 ] + $ sum [ $ i - 3 ] ) ; return $ sum [ $ n - 1 ] ; }
function centered_heptagonal_num ( $ n ) { return ( 7 * $ n * $ n - 7 * $ n + 2 ) / 2 ; }
function isSubsetSum ( $ set , $ n , $ sum ) { if ( $ sum == 0 ) return true ; if ( $ n == 0 ) return false ; if ( $ set [ $ n - 1 ] > $ sum ) return isSubsetSum ( $ set , $ n - 1 , $ sum ) ; return isSubsetSum ( $ set , $ n - 1 , $ sum ) || isSubsetSum ( $ set , $ n - 1 , $ sum - $ set [ $ n - 1 ] ) ; }
function makePolygon ( $ a ) { $ n = 360 / ( 180 - $ a ) ; if ( $ n == ( int ) $ n ) echo " YES " ; else echo " NO " ; }
function binomialCoeff ( $ n , $ k ) { $ res = 1 ; if ( $ k > $ n - $ k ) $ k = $ n - $ k ; for ( $ i = 0 ; $ i < $ k ; ++ $ i ) { $ res *= ( $ n - $ i ) ; $ res /= ( $ i + 1 ) ; } return $ res ; }
function minimumBox ( $ arr , $ n ) { $ q = array ( ) ; sort ( $ arr ) ; array_push ( $ q , $ arr [ 0 ] ) ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ now = $ q [ 0 ] ; if ( $ arr [ $ i ] >= 2 * $ now ) array_pop ( $ q ) ; array_push ( $ q , $ arr [ $ i ] ) ; } return count ( $ q ) ; }
function countIncreasing ( $ arr , $ n ) { $ cnt = 0 ; $ len = 1 ; for ( $ i = 0 ; $ i < $ n - 1 ; ++ $ i ) { if ( $ arr [ $ i + 1 ] > $ arr [ $ i ] ) $ len ++ ; else { $ cnt += ( ( ( $ len - 1 ) * $ len ) / 2 ) ; $ len = 1 ; } } if ( $ len > 1 ) $ cnt += ( ( ( $ len - 1 ) * $ len ) / 2 ) ; return $ cnt ; }
function longestSubseqWithDiffOne ( $ arr , $ n ) { $ dp [ $ n ] = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ dp [ $ i ] = 1 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ i ; $ j ++ ) { if ( ( $ arr [ $ i ] == $ arr [ $ j ] + 1 ) || ( $ arr [ $ i ] == $ arr [ $ j ] - 1 ) ) $ dp [ $ i ] = max ( $ dp [ $ i ] , $ dp [ $ j ] + 1 ) ; } } $ result = 1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ result < $ dp [ $ i ] ) $ result = $ dp [ $ i ] ; return $ result ; }
function closestNumber ( $ n , $ m ) { $ q = ( int ) ( $ n / $ m ) ; $ n1 = $ m * $ q ; $ n2 = ( $ n * $ m ) > 0 ? ( $ m * ( $ q + 1 ) ) : ( $ m * ( $ q - 1 ) ) ; if ( abs ( $ n - $ n1 ) < abs ( $ n - $ n2 ) ) return $ n1 ; return $ n2 ; }
function problemsLeft ( $ K , $ P , $ N ) { if ( $ K <= $ P ) return 0 ; else return ( $ K - $ P ) * $ N ; }
function section ( $ x1 , $ x2 , $ y1 , $ y2 , $ z1 , $ z2 , $ m , $ n ) { $ x = ( ( $ m * $ x2 ) + ( $ n * $ x1 ) ) / ( $ m + $ n ) ; $ y = ( ( $ m * $ y2 ) + ( $ n * $ y1 ) ) / ( $ m + $ n ) ; $ z = ( ( $ m * $ z2 ) + ( $ n * $ z1 ) ) / ( $ m + $ n ) ; echo " ( " . $ x . " , " ; ▁ echo ▁ $ y ▁ . ▁ " , " ; ▁ echo ▁ $ z ▁ . ▁ " ) " ▁ . " " }
function findValue ( $ X , $ Y , $ P ) { if ( $ P % 2 == 0 ) return ( int ) ( max ( $ X , $ Y ) / min ( $ X , $ Y ) ) ; else return ( int ) ( max ( 2 * $ X , $ Y ) / min ( 2 * $ X , $ Y ) ) ; }
function weightedMean ( $ X , $ W , $ n ) { $ sum = 0 ; $ numWeight = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ numWeight = $ numWeight + $ X [ $ i ] * $ W [ $ i ] ; $ sum = $ sum + $ W [ $ i ] ; } return ( float ) ( $ numWeight / $ sum ) ; }
function gcd ( $ a , $ b ) { if ( $ a == 0 ) return $ b ; if ( $ b == 0 ) return $ a ; if ( $ a == $ b ) return $ a ; if ( $ a > $ b ) return gcd ( $ a - $ b , $ b ) ; return gcd ( $ a , $ b - $ a ) ; }
function nthTerm ( $ n ) { return 4 * pow ( $ n , 2 ) - 7 * $ n + 3 ; }
function last_digit ( $ X , $ Y ) { echo ( $ X % $ Y ) ; }
function ceilSearch ( $ arr , $ low , $ high , $ x ) { if ( $ x <= $ arr [ $ low ] ) return $ low ; for ( $ i = $ low ; $ i < $ high ; $ i ++ ) { if ( $ arr [ $ i ] == $ x ) return $ i ; if ( $ arr [ $ i ] < $ x && $ arr [ $ i + 1 ] >= $ x ) return $ i + 1 ; } return -1 ; }
function getPeriod ( $ n ) { $ rem = 1 ; for ( $ i = 1 ; $ i <= $ n + 1 ; $ i ++ ) $ rem = ( 10 * $ rem ) % $ n ; $ d = $ rem ; $ count = 0 ; do { $ rem = ( 10 * $ rem ) % $ n ; $ count ++ ; } while ( $ rem != $ d ) ; return $ count ; }
function rhombusarea ( $ l , $ b ) { if ( $ l < 0 $ b < 0 ) return -1 ; return ( $ l * $ b ) / 2 ; }
function search ( $ arr , $ n , $ x ) { if ( $ arr [ $ n - 1 ] == $ x ) return " Found " ; $ backup = $ arr [ $ n - 1 ] ; $ arr [ $ n - 1 ] = $ x ; for ( $ i = 0 ; ; $ i ++ ) { if ( $ arr [ $ i ] == $ x ) { $ arr [ $ n - 1 ] = $ backup ; if ( $ i < $ n - 1 ) return " Found " ; return " Not ▁ Found " ; } } }
function printRepeating ( $ arr , $ size ) { $ count = array_fill ( 0 , $ size , 0 ) ; echo " Repeated ▁ elements ▁ are ▁ " ; for ( $ i = 0 ; $ i < $ size ; $ i ++ ) { if ( $ count [ $ arr [ $ i ] ] == 1 ) echo $ arr [ $ i ] . " ▁ " ; else $ count [ $ arr [ $ i ] ] ++ ; } }
function find_Area ( $ r ) { return ( 2 * $ r * $ r ) ; }
function getNthTerm ( $ N ) { return ( pow ( $ N , 2 ) + $ N + 1 ) ; }
function countPS ( $ str ) { $ N = strlen ( $ str ) ; $ cps = array_fill ( 0 , $ N + 1 , array_fill ( 0 , $ N + 1 , NULL ) ) ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) $ cps [ $ i ] [ $ i ] = 1 ; for ( $ L = 2 ; $ L <= $ N ; $ L ++ ) { for ( $ i = 0 ; $ i <= $ N - $ L ; $ i ++ ) { $ k = $ L + $ i - 1 ; if ( $ str [ $ i ] == $ str [ $ k ] ) $ cps [ $ i ] [ $ k ] = $ cps [ $ i ] [ $ k - 1 ] + $ cps [ $ i + 1 ] [ $ k ] + 1 ; else $ cps [ $ i ] [ $ k ] = $ cps [ $ i ] [ $ k - 1 ] + $ cps [ $ i + 1 ] [ $ k ] - $ cps [ $ i + 1 ] [ $ k - 1 ] ; } } return $ cps [ 0 ] [ $ N - 1 ] ; }
function magicOfSequence ( $ N ) { return ( $ N * ( $ N + 1 ) / 2 ) + 2 * $ N ; }
function mod ( $ num , $ a ) { $ res = 0 ; for ( $ i = 0 ; $ i < $ r = strlen ( $ num ) ; $ i ++ ) $ res = ( $ res * 10 + $ num [ $ i ] - '0' ) % $ a ; return $ res ; }
function ReplaceElements ( & $ arr , $ n ) { if ( $ n <= 1 ) return ; $ prev = $ arr [ 0 ] ; $ arr [ 0 ] = $ arr [ 0 ] ^ $ arr [ 1 ] ; for ( $ i = 1 ; $ i < $ n - 1 ; $ i ++ ) { $ curr = $ arr [ $ i ] ; $ arr [ $ i ] = $ prev ^ $ arr [ $ i + 1 ] ; $ prev = $ curr ; } $ arr [ $ n - 1 ] = $ prev ^ $ arr [ $ n - 1 ] ; }
function prevGreater ( & $ arr , $ n ) { echo ( " - 1 , ▁ " ) ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { for ( $ j = $ i - 1 ; $ j >= 0 ; $ j -- ) { if ( $ arr [ $ i ] < $ arr [ $ j ] ) { echo ( $ arr [ $ j ] ) ; echo ( " , ▁ " ) ; break ; } } if ( $ j == -1 ) echo ( " - 1 , ▁ " ) ; } }
function isPowerOfTwo ( $ x ) { return $ x && ( ! ( $ x & ( $ x - 1 ) ) ) ; }
function rotateRec ( $ n , $ L , $ B ) { $ m = PHP_INT_MAX ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( max ( $ L [ $ i ] , $ B [ $ i ] ) <= $ m ) $ m = max ( $ L [ $ i ] , $ B [ $ i ] ) ; else if ( min ( $ L [ $ i ] , $ B [ $ i ] ) <= $ m ) $ m = min ( $ L [ $ i ] , $ B [ $ i ] ) ; else { return 0 ; } } return 1 ; }
function print_result ( $ a , $ n , $ k , $ m ) { $ v = array_fill ( 0 , $ m + 1 , array ( ) ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ rem = $ a [ $ i ] % $ m ; array_push ( $ v [ $ rem ] , $ a [ $ i ] ) ; if ( count ( $ v [ $ rem ] ) == $ k ) { for ( $ j = 0 ; $ j < $ k ; $ j ++ ) echo $ v [ $ rem ] [ $ j ] . " ▁ " ; return ; } } echo " - 1" ; }
function sumofproduct ( $ n ) { $ ans = 0 ; for ( $ x = 1 ; $ x <= $ n ; $ x ++ ) { $ y = ( int ) ( $ n / $ x ) ; $ ans += ( $ y * $ x ) ; } return $ ans ; }
function printDivisors ( $ n ) { for ( $ i = 1 ; $ i <= sqrt ( $ n ) ; $ i ++ ) { if ( $ n % $ i == 0 ) { if ( $ n / $ i == $ i ) echo $ i , " ▁ " ; else echo $ i , " ▁ " , $ n / $ i , " ▁ " ; } } }
function findSubsequenceCount ( $ S , $ T ) { $ m = strlen ( $ T ) ; $ n = strlen ( $ S ) ; if ( $ m > $ n ) return 0 ; $ mat = array ( array ( ) ) ; for ( $ i = 1 ; $ i <= $ m ; $ i ++ ) $ mat [ $ i ] [ 0 ] = 0 ; for ( $ j = 0 ; $ j <= $ n ; $ j ++ ) $ mat [ 0 ] [ $ j ] = 1 ; for ( $ i = 1 ; $ i <= $ m ; $ i ++ ) { for ( $ j = 1 ; $ j <= $ n ; $ j ++ ) { if ( $ T [ $ i - 1 ] != $ S [ $ j - 1 ] ) $ mat [ $ i ] [ $ j ] = $ mat [ $ i ] [ $ j - 1 ] ; else $ mat [ $ i ] [ $ j ] = $ mat [ $ i ] [ $ j - 1 ] + $ mat [ $ i - 1 ] [ $ j - 1 ] ; } } return $ mat [ $ m ] [ $ n ] ; }
function counLastDigitK ( $ low , $ high , $ k ) { $ count = 0 ; for ( $ i = $ low ; $ i <= $ high ; $ i ++ ) if ( $ i % 10 == $ k ) $ count ++ ; return $ count ; }
function subtract ( $ x , $ y ) { while ( $ y != 0 ) { $ borrow = ( ~ $ x ) & $ y ; $ x = $ x ^ $ y ; $ y = $ borrow << 1 ; } return $ x ; }
function findOddPair ( & $ A , $ N ) { $ oddPair = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ N ; $ j ++ ) { if ( ( $ A [ $ i ] & $ A [ $ j ] ) % 2 != 0 ) $ oddPair = $ oddPair + 1 ; } } return $ oddPair ; }
function printSubsequences ( $ arr , $ n ) { $ opsize = pow ( 2 , $ n ) ; for ( $ counter = 1 ; $ counter < $ opsize ; $ counter ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ counter & ( 1 << $ j ) ) echo $ arr [ $ j ] , " ▁ " ; } echo " STRNEWLINE " ; } }
function getMinSquares ( $ n ) { if ( $ n <= 3 ) return $ n ; $ res = $ n ; for ( $ x = 1 ; $ x <= $ n ; $ x ++ ) { $ temp = $ x * $ x ; if ( $ temp > $ n ) break ; else $ res = min ( $ res , 1 + getMinSquares ( $ n - $ temp ) ) ; } return $ res ; }
function firstDigit ( $ n ) { $ fact = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { $ fact = $ fact * $ i ; while ( $ fact % 10 == 0 ) $ fact = $ fact / 10 ; } while ( $ fact >= 10 ) $ fact = $ fact / 10 ; return floor ( $ fact ) ; }
function findSum ( $ n ) { $ n -- ; $ sum = 0 ; $ sum += ( $ n * ( $ n + 1 ) ) / 2 ; $ sum += ( $ n * ( $ n + 1 ) * ( 2 * $ n + 1 ) ) / 6 ; return $ sum ; }
function getCount ( $ a , $ b , $ c ) { $ count = 0 ; for ( $ i = 1 ; $ i <= 81 ; $ i ++ ) { $ cr = $ b * ( int ) pow ( $ i , $ a ) + $ c ; $ tmp = $ cr ; $ sm = 0 ; while ( $ tmp != 0 ) { $ sm += $ tmp % 10 ; $ tmp /= 10 ; } if ( $ sm == $ i && $ cr < 1e9 ) $ count ++ ; } return $ count ; } { $ a = 3 ; $ b = 2 ; $ c = 8 ; echo ( getCount ( $ a , $ b , $ c ) ) ; }
function subtract ( $ x , $ y ) { if ( $ y == 0 ) return $ x ; return subtract ( $ x ^ $ y , ( ~ $ x & $ y ) << 1 ) ; }
function countNumbers ( $ N ) { return ( int ) ( sqrt ( $ N ) ) - 1 ; }
function ASCIISentence ( $ str ) { for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) echo ord ( $ str [ $ i ] ) ; }
function countToMake0lternate ( $ s ) { $ result = 0 ; for ( $ i = 0 ; $ i < ( strlen ( $ s ) - 1 ) ; $ i ++ ) if ( $ s [ $ i ] == $ s [ $ i + 1 ] ) $ result ++ ; return $ result ; }
function minAdjDifference ( $ arr , $ n ) { if ( $ n < 2 ) return ; $ res = abs ( $ arr [ 1 ] - $ arr [ 0 ] ) ; for ( $ i = 2 ; $ i < $ n ; $ i ++ ) $ res = min ( $ res , abs ( $ arr [ $ i ] - $ arr [ $ i - 1 ] ) ) ; $ res = min ( $ res , abs ( $ arr [ $ n - 1 ] - $ arr [ 0 ] ) ) ; echo " Min ▁ Difference ▁ = ▁ " , $ res ; }
function printSubsequences ( $ str ) { $ n = strlen ( $ str ) ; $ opsize = pow ( 2 , $ n - 1 ) ; for ( $ counter = 0 ; $ counter < $ opsize ; $ counter ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { echo $ str [ $ j ] ; if ( $ counter & ( 1 << $ j ) ) echo " ▁ " ; } echo " STRNEWLINE " ; } }
function Convert ( $ radian ) { $ pi = 3.14159 ; return ( $ radian * ( 180 / $ pi ) ) ; }
function number_of_digits ( $ n ) { $ i ; $ res ; $ sum = 0 ; for ( $ i = 4 , $ res = 1 ; ; $ i *= 4 , $ res ++ ) { $ sum += $ i ; if ( $ sum >= $ n ) break ; } return $ res ; }
function findK ( $ n , $ k ) { $ a ; $ index = 0 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) if ( $ i % 2 == 1 ) $ a [ $ index ++ ] = $ i ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) if ( $ i % 2 == 0 ) $ a [ $ index ++ ] = $ i ; return ( $ a [ $ k - 1 ] ) ; }
function findWays ( $ m , $ n , $ x ) { $ table ; for ( $ i = 1 ; $ i < $ n + 1 ; $ i ++ ) for ( $ j = 1 ; $ j < $ x + 1 ; $ j ++ ) $ table [ $ i ] [ $ j ] = 0 ; for ( $ j = 1 ; $ j <= $ m && $ j <= $ x ; $ j ++ ) $ table [ 1 ] [ $ j ] = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) for ( $ j = 1 ; $ j <= $ x ; $ j ++ ) for ( $ k = 1 ; $ k <= $ m && $ k < $ j ; $ k ++ ) $ table [ $ i ] [ $ j ] += $ table [ $ i - 1 ] [ $ j - $ k ] ; return $ table [ $ n ] [ $ x ] ; }
function oppositeSigns ( $ x , $ y ) { return ( ( $ x ^ $ y ) < 0 ) ; }
function pointIsOnLine ( $ m , $ c , $ x , $ y ) { if ( $ y == ( ( $ m * $ x ) + $ c ) ) return true ; return false ; }
function findMinDiff ( $ arr , $ n ) { sort ( $ arr ) ; $ diff = PHP_INT_MAX ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) if ( $ arr [ $ i + 1 ] - $ arr [ $ i ] < $ diff ) $ diff = $ arr [ $ i + 1 ] - $ arr [ $ i ] ; return $ diff ; }
function swapTwoHalves ( $ a , $ b ) { $ la = strlen ( $ a ) ; $ lb = strlen ( $ b ) ; $ c = substr ( $ a , 0 , intval ( $ la / 2 ) ) . substr ( $ b , intval ( $ lb / 2 ) , $ lb ) ; $ d = substr ( $ b , 0 , intval ( $ lb / 2 ) ) . substr ( $ a , intval ( $ la / 2 ) , $ la ) ; echo ( $ c . " " ▁ . ▁ $ d ▁ . ▁ " " }
function findNumber ( $ n ) { $ n -- ; $ i = 1 ; while ( $ n >= 0 ) { $ n -= $ i ; ++ $ i ; } return ( $ n + $ i ) ; }
function minimumIncrease ( $ a , $ b , $ c ) { $ arr = array ( $ a , $ b , $ c ) ; sort ( $ arr ) ; if ( $ arr [ 0 ] + $ arr [ 1 ] >= $ arr [ 2 ] ) return 0 ; else return $ arr [ 2 ] - ( $ arr [ 0 ] + $ arr [ 1 ] ) ; }
function divisibleBy36 ( $ num ) { $ l = strlen ( $ num ) ; if ( $ l == 0 ) return " No " ; if ( $ l == 1 && $ num [ 0 ] != '0' ) return " No " ; $ two_digit_num = ( $ num [ $ l - 2 ] - '0' ) * 10 + ( $ num [ $ l - 1 ] - '0' ) ; if ( $ two_digit_num % 4 != 0 ) return " No " ; $ sum = 0 ; for ( $ i = 0 ; $ i < $ l ; $ i ++ ) $ sum += ( $ num [ $ i ] - '0' ) ; if ( $ sum % 9 != 0 ) return " No " ; return " Yes " ; }
function min_elimination ( $ n , $ arr ) { $ count = 0 ; $ prev_val = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ curr_val = $ arr [ $ i ] ; if ( $ curr_val % 2 == $ prev_val % 2 ) $ count ++ ; $ prev_val = $ curr_val ; } return $ count ; }
function lastDigit ( $ a , $ b ) { $ lastDig = ( ord ( $ a [ strlen ( $ a ) - 1 ] ) - 48 ) * ( ord ( $ b [ strlen ( $ b ) - 1 ] ) - 48 ) ; echo $ lastDig % 10 ; }
function sumOfSeries ( $ n ) { return ( 0.666 ) * ( 1 - 1 / pow ( 10 , $ n ) ) ; }
function Area ( $ l , $ b , $ h ) { if ( $ l < 0 or $ b < 0 or $ h < 0 ) return -1 ; $ x = ( $ l * $ b ) / ( $ l + $ b ) ; $ A = 0.70477 * pow ( $ x , 2 ) ; return $ A ; }
function countPairs ( $ arr1 , $ arr2 , $ m , $ n , $ x ) { $ count = 0 ; $ l = 0 ; $ r = $ n - 1 ; while ( $ l < $ m and $ r >= 0 ) { if ( ( $ arr1 [ $ l ] + $ arr2 [ $ r ] ) == $ x ) { $ l ++ ; $ r -- ; $ count ++ ; } else if ( ( $ arr1 [ $ l ] + $ arr2 [ $ r ] ) < $ x ) $ l ++ ; else $ r -- ; } return $ count ; }
function maximum_toys ( $ cost , $ N , $ K ) { $ count = 0 ; $ sum = 0 ; sort ( $ cost ) ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { if ( $ sum + $ cost [ $ i ] <= $ K ) { $ sum = $ sum + $ cost [ $ i ] ; $ count ++ ; } } return $ count ; }
function printCombination ( $ n ) { for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( $ i % 3 != 0 ) { for ( $ j = 1 ; $ j < $ n ; $ j ++ ) { if ( $ j % 3 != 0 ) { for ( $ k = 1 ; $ k < $ n ; $ k ++ ) { if ( $ k % 3 != 0 && ( $ i + $ j + $ k ) == $ n ) { echo $ i , " " ▁ , ▁ $ j ▁ , ▁ " " return ; } } } } } } }
function printPairs ( $ arr , $ n , $ sum ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) if ( $ arr [ $ i ] + $ arr [ $ j ] == $ sum ) echo " ( " , $ arr [ $ i ] , " , ▁ " , $ arr [ $ j ] , " ) " , " STRNEWLINE " ; }
function bitExtracted ( $ number , $ k , $ p ) { return ( ( ( 1 << $ k ) - 1 ) & ( $ number >> ( $ p - 1 ) ) ) ; }
function setBitNumber ( $ n ) { $ k = ( int ) ( log ( $ n , 2 ) ) ; return 1 << $ k ; }
function countTrailingZero ( $ x ) { $ lookup = array ( 32 , 0 , 1 , 26 , 2 , 23 , 27 , 0 , 3 , 16 , 24 , 30 , 28 , 11 , 0 , 13 , 4 , 7 , 17 , 0 , 25 , 22 , 31 , 15 , 29 , 10 , 12 , 6 , 0 , 21 , 14 , 9 , 5 , 20 , 8 , 19 , 18 ) ; return $ lookup [ ( - $ x & $ x ) % 37 ] ; }
function maxOR ( $ arr , $ n , $ k , $ x ) { $ res ; $ pow = 1 ; for ( $ i = 0 ; $ i < $ k ; $ i ++ ) $ pow *= $ x ; $ preSum [ 0 ] = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ preSum [ $ i + 1 ] = $ preSum [ $ i ] | $ arr [ $ i ] ; $ suffSum [ $ n ] = 0 ; for ( $ i = $ n - 1 ; $ i >= 0 ; $ i -- ) $ suffSum [ $ i ] = $ suffSum [ $ i + 1 ] | $ arr [ $ i ] ; $ res = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ res = max ( $ res , $ preSum [ $ i ] | ( $ arr [ $ i ] * $ pow ) $ suffSum [ $ i + 1 ] ) ; return $ res ; }
function findPoints ( $ l1 , $ r1 , $ l2 , $ r2 ) { $ x = ( $ l1 != $ l2 ) ? min ( $ l1 , $ l2 ) : -1 ; $ y = ( $ r1 != $ r2 ) ? max ( $ r1 , $ r2 ) : -1 ; echo $ x , " " , $ y ; }
function bridge_length ( $ trainLength , $ Speed , $ Time ) { return ( ( $ Time * $ Speed ) - $ trainLength ) ; }
function totalDigits ( $ n ) { $ number_of_digits = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i *= 10 ) $ number_of_digits += ( $ n - $ i + 1 ) ; return $ number_of_digits ; }
function countSquares ( $ r , $ c , $ m ) { $ squares = 0 ; for ( $ i = 1 ; $ i <= 8 ; $ i ++ ) { for ( $ j = 1 ; $ j <= 8 ; $ j ++ ) { if ( max ( abs ( $ i - $ r ) , abs ( $ j - $ c ) ) <= $ m ) $ squares ++ ; } } return $ squares ; }
function check_euler_four_square_identity ( $ a , $ b , $ ab ) { $ s = 0 ; for ( $ i = 0 ; $ i * $ i <= $ ab ; $ i ++ ) { $ s = $ i * $ i ; for ( $ j = $ i ; $ j * $ j <= $ ab ; $ j ++ ) { $ s = $ j * $ j + $ i * $ i ; for ( $ k = $ j ; $ k * $ k <= $ ab ; $ k ++ ) { $ s = $ k * $ k + $ j * $ j + $ i * $ i ; for ( $ l = $ k ; $ l * $ l <= $ ab ; $ l ++ ) { $ s = $ l * $ l + $ k * $ k + $ j * $ j + $ i * $ i ; if ( $ s == $ ab ) { echo ( " i ▁ = ▁ " . $ i . " STRNEWLINE " ) ; echo ( " j ▁ = ▁ " . $ j . " STRNEWLINE " ) ; echo ( " k ▁ = ▁ " . $ k . " STRNEWLINE " ) ; echo ( " l ▁ = ▁ " . $ l . " STRNEWLINE " ) ; echo " " . " Product ▁ of ▁ " . $ a . " ▁ and ▁ " . $ b ; echo " ▁ can ▁ be ▁ written " . " ▁ as ▁ sum ▁ of ▁ squares ▁ of ▁ i , ▁ " . " j , ▁ k , ▁ l STRNEWLINE " ; echo $ ab . " ▁ = ▁ " ; echo $ i . " * " ▁ . ▁ $ i . ▁ " + " echo $ j . " * " . $ j . " ▁ + ▁ " ; echo $ k . " * " ▁ . ▁ $ k ▁ . ▁ " + " echo $ l . " * " . $ l . " STRNEWLINE " ; echo " STRNEWLINE " ; } } } } } }
function sumOfSeries ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ sum = $ sum + $ i * ( $ i + 1 ) * ( $ i + 2 ) ; return $ sum ; }
function addOne ( $ x ) { $ m = 1 ; while ( $ x & $ m ) { $ x = $ x ^ $ m ; $ m <<= 1 ; } $ x = $ x ^ $ m ; return $ x ; }
function firstFactorialDivisibleNumber ( $ x ) { $ i = 1 ; $ fact = 1 ; for ( $ i = 1 ; $ i < $ x ; $ i ++ ) { $ fact = $ fact * $ i ; if ( $ fact % $ x == 0 ) break ; } return $ i ; }
function check ( $ m , $ n ) { $ RHS = $ m * log ( $ n ) ; $ LHS = $ n * log ( $ m ) ; if ( $ LHS > $ RHS ) echo " m ^ n ▁ > ▁ n ^ m " ; else if ( $ LHS < $ RHS ) echo " m ^ n ▁ < ▁ n ^ m " ; else echo " m ^ n ▁ = ▁ n ^ m " ; }
function checkHankelMatrix ( $ n , $ m ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ i + $ j < $ n ) { if ( $ m [ $ i ] [ $ j ] != $ m [ $ i + $ j ] [ 0 ] ) return false ; } else { if ( $ m [ $ i ] [ $ j ] != $ m [ $ i + $ j - $ n + 1 ] [ $ n - 1 ] ) return false ; } } } return true ; }
function minCost ( $ coin , $ n , $ k ) { sort ( $ coin ) ; sort ( $ coin , $ n ) ; $ coins_needed = ceil ( 1.0 * $ n / ( $ k + 1 ) ) ; $ ans = 0 ; for ( $ i = 0 ; $ i <= $ coins_needed - 1 ; $ i ++ ) $ ans += $ coin [ $ i ] ; return $ ans ; } { $ coin = array ( 8 , 5 , 3 , 10 , 2 , 1 , 15 , 25 ) ; $ n = sizeof ( $ coin ) / sizeof ( $ coin [ 0 ] ) ; $ k = 3 ; echo minCost ( $ coin , $ n , $ k ) ; return 0 ; }
function toggleKthBit ( $ n , $ k ) { return ( $ n ^ ( 1 << ( $ k - 1 ) ) ) ; }
function maxCandies ( $ arr , $ n ) { $ prevBought = $ arr [ $ n - 1 ] ; $ candies = $ prevBought ; for ( $ i = $ n - 2 ; $ i >= 0 ; $ i -- ) { $ x = min ( $ prevBought - 1 , $ arr [ $ i ] ) ; if ( $ x >= 0 ) { $ candies += $ x ; $ prevBought = $ x ; } } return $ candies ; }
function isPossible ( $ n ) { $ fac = array ( ) ; $ fac [ 0 ] = $ fac [ 1 ] = 1 ; for ( $ i = 2 ; $ i < 10 ; $ i ++ ) $ fac [ $ i ] = $ fac [ $ i - 1 ] * $ i ; $ sum = 0 ; $ x = $ n ; while ( $ x ) { $ sum += $ fac [ $ x % 10 ] ; $ x /= 10 ; } if ( $ sum % $ n == 0 ) return true ; return false ; }
function divisible ( $ num ) { $ n = strlen ( $ num ) ; $ sum = ( $ num ) ; ( $ num ) ; 0 - '0' ; if ( $ sum % 3 == 0 ) return 0 ; if ( $ n == 1 ) return -1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ sum % 3 == ( $ num [ $ i ] - '0' ) % 3 ) return 1 ; if ( $ n == 2 ) return -1 ; return 2 ; }
function findSum ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; ( 1 << $ i ) < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ i ; $ j ++ ) { $ num = ( 1 << $ i ) + ( 1 << $ j ) ; if ( $ num <= $ n ) $ sum += $ num ; } } return $ sum ; }
function min_noOf_operation ( $ arr , $ n , $ k ) { $ noOfSubtraction ; $ res = 0 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ noOfSubtraction = 0 ; if ( $ arr [ $ i ] > $ arr [ $ i - 1 ] ) { $ noOfSubtraction = ( $ arr [ $ i ] - $ arr [ $ i - 1 ] ) / $ k ; if ( ( $ arr [ $ i ] - $ arr [ $ i - 1 ] ) % $ k != 0 ) $ noOfSubtraction ++ ; $ arr [ $ i ] = $ arr [ $ i ] - $ k * $ noOfSubtraction ; } $ res = $ res + $ noOfSubtraction ; } return floor ( $ res ) ; }
function findArea ( $ a , $ b ) { $ Area ; $ Area = 3.142 * $ a * $ b ; echo " Area : ▁ " . $ Area ; }
function maxDifference ( $ arr , $ N , $ k ) { $ M ; $ S = 0 ; $ S1 = 0 ; $ max_difference = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) $ S += $ arr [ $ i ] ; rsort ( $ arr ) ; $ M = max ( $ k , $ N - $ k ) ; for ( $ i = 0 ; $ i < $ M ; $ i ++ ) $ S1 += $ arr [ $ i ] ; $ max_difference = $ S1 - ( $ S - $ S1 ) ; return $ max_difference ; }
function minJumps ( $ arr , $ l , $ h ) { if ( $ h == $ l ) return 0 ; if ( $ arr [ $ l ] == 0 ) return INT_MAX ; $ min = 999999 ; for ( $ i = $ l + 1 ; $ i <= $ h && $ i <= $ l + $ arr [ $ l ] ; $ i ++ ) { $ jumps = minJumps ( $ arr , $ i , $ h ) ; if ( $ jumps != 999999 && $ jumps + 1 < $ min ) $ min = $ jumps + 1 ; } return $ min ; }
function evenSum ( $ n ) { return ( $ n * ( $ n + 1 ) ) ; }
function printArray ( $ arr , $ n ) { sort ( $ arr ) ; $ l = 0 ; $ r = $ n - 1 ; $ flag = 0 ; $ k = 2 ; while ( $ l <= $ r ) { if ( $ flag == 0 ) { for ( $ i = $ l ; $ i < $ l + $ k && $ i <= $ r ; $ i ++ ) echo $ arr [ $ i ] , " ▁ " ; $ flag = 1 ; $ l = $ i ; } { for ( $ i = $ r ; $ i > $ r - $ k && $ i >= $ l ; $ i -- ) echo $ arr [ $ i ] , " ▁ " ; $ flag = 0 ; $ r = $ i ; } $ k ++ ; } }
function nthEnneadecagonal ( $ n ) { return ( 17 * $ n * $ n - 15 * $ n ) / 2 ; }
function findMaxNum ( & $ arr , $ n ) { rsort ( $ arr ) ; $ num = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ num = $ num * 10 + $ arr [ $ i ] ; } return $ num ; }
function multiple ( $ a , $ b , $ x ) { if ( $ b < 0 ) { if ( $ a == 1 && $ x == 1 ) echo "1" ; else echo "0" ; } $ mul = pow ( $ a , $ b ) ; $ ans = $ mul / $ x ; $ ans1 = $ x * $ ans ; $ ans2 = $ x * ( $ ans + 1 ) ; $ k = ( ( ( $ mul - $ ans1 ) <= ( $ ans2 - $ mul ) ) ? $ ans1 : $ ans2 ) ; echo ( $ k ) ; }
function countKeyPressed ( $ str , $ len ) { global $ arr ; $ count = 0 ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) $ count = $ count + $ arr [ ord ( $ str [ $ i ] ) - ord ( ' a ' ) ] ; return $ count ; }
function merge ( & $ ar1 , & $ ar2 , $ m , $ n ) { for ( $ i = $ n - 1 ; $ i >= 0 ; $ i -- ) { $ last = $ ar1 [ $ m - 1 ] ; for ( $ j = $ m - 2 ; $ j >= 0 && $ ar1 [ $ j ] > $ ar2 [ $ i ] ; $ j -- ) $ ar1 [ $ j + 1 ] = $ ar1 [ $ j ] ; if ( $ j != $ m - 2 $ last > $ ar2 [ $ i ] ) { $ ar1 [ $ j + 1 ] = $ ar2 [ $ i ] ; $ ar2 [ $ i ] = $ last ; } } }
function evenSum ( $ n ) { $ curr = 2 ; $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ sum += $ curr ; $ curr += 2 ; } return $ sum ; }
function lastNon0Digit ( $ n ) { global $ dig ; if ( $ n < 10 ) return $ dig [ $ n ] ; if ( ( ( $ n / 10 ) % 10 ) % 2 == 0 ) return ( 6 * lastNon0Digit ( $ n / 5 ) * $ dig [ $ n % 10 ] ) % 10 ; else return ( 4 * lastNon0Digit ( $ n / 5 ) * $ dig [ $ n % 10 ] ) % 10 ; }
function isDivisible ( $ n ) { $ temp = $ n ; $ sum = 0 ; while ( $ n ) { $ k = $ n % 10 ; $ sum += $ k ; $ n = ( int ) ( $ n / 10 ) ; } if ( $ temp % $ sum == 0 ) return " YES " ; return " NO " ; }
function isSumDivides ( $ N ) { $ temp = $ N ; $ sum = 0 ; while ( $ temp ) { $ sum += $ temp % 10 ; $ temp = ( int ) $ temp / 10 ; } if ( $ N % $ sum == 0 ) return 1 ; else return 0 ; }
function findLength ( $ str , $ n ) { $ current_sum = 0 ; $ max_sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ current_sum += ( $ str [ $ i ] == '0' ? 1 : -1 ) ; if ( $ current_sum < 0 ) $ current_sum = 0 ; $ max_sum = max ( $ current_sum , $ max_sum ) ; } return $ max_sum == 0 ? -1 : $ max_sum ; }
function seriesSum ( $ calculated , $ current , $ N ) { $ i ; $ cur = 1 ; if ( $ current == $ N + 1 ) return 0 ; for ( $ i = $ calculated ; $ i < $ calculated + $ current ; $ i ++ ) $ cur *= $ i ; return $ cur + seriesSum ( $ i , $ current + 1 , $ N ) ; }
function findCount ( $ arr , $ n ) { $ countOdd = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] % 2 == 1 ) $ countOdd ++ ; if ( $ countOdd % 2 == 0 ) return 1 ; else return 0 ; }
function matrixSum ( $ arr ) { $ n = 3 ; $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { $ top_left = ( $ i + 1 ) * ( $ j + 1 ) ; $ bottom_right = ( $ n - $ i ) * ( $ n - $ j ) ; $ sum += ( $ top_left * $ bottom_right * $ arr [ $ i ] [ $ j ] ) ; } return $ sum ; }
function smallestMultiple ( $ n ) { if ( $ n == 1 ) return 5 ; return pow ( 10 , $ n - 1 ) ; }
function segregate0and1 ( & $ arr , $ size ) { $ type0 = 0 ; $ type1 = $ size - 1 ; while ( $ type0 < $ type1 ) { if ( $ arr [ $ type0 ] == 1 ) { $ temp = $ arr [ $ type0 ] ; $ arr [ $ type0 ] = $ arr [ $ type1 ] ; $ arr [ $ type1 ] = $ temp ; $ type1 -- ; } else $ type0 ++ ; } }
function findIndex ( $ n ) { if ( $ n <= 1 ) return $ n ; $ a = 0 ; $ b = 1 ; $ c = 1 ; $ res = 1 ; while ( $ c < $ n ) { $ c = $ a + $ b ; $ res ++ ; $ a = $ b ; $ b = $ c ; } return $ res ; }
function sum ( $ n ) { $ root = intval ( sqrt ( $ n ) ) ; $ ans = 0 ; for ( $ i = 1 ; $ i <= $ root ; $ i ++ ) $ ans += intval ( $ n / $ i ) ; $ ans = ( 2 * $ ans ) - ( $ root * $ root ) ; return $ ans ; }
function findBucketNo ( $ p ) { return ceil ( ( sqrt ( 8 * $ p + 1 ) - 1 ) / 2 ) ; }
function nthTermOfTheSeries ( $ n ) { if ( $ n % 2 == 0 ) $ nthTerm = pow ( $ n - 1 , 2 ) + $ n ; else $ nthTerm = pow ( $ n + 1 , 2 ) + $ n ; return $ nthTerm ; }
function O_R ( $ a , $ n ) { $ ans = $ a [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; ++ $ i ) $ ans |= $ a [ $ i ] ; return $ ans ; }
function countXorPair ( $ arr , $ n ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) if ( ( $ arr [ $ i ] ^ $ arr [ $ j ] ) % 2 == 1 ) $ count ++ ; } return $ count ; }
function printPFsInPairs ( $ n ) { for ( $ i = 1 ; $ i * $ i <= $ n ; $ i ++ ) if ( $ n % $ i == 0 ) echo $ i . " * " . ▁ $ n ▁ / ▁ $ i ▁ . " " }
function countSubstringWithEqualEnds ( $ s ) { global $ MAX_CHAR ; $ result = 0 ; $ n = strlen ( $ s ) ; $ count = array_fill ( 0 , $ MAX_CHAR , 0 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ count [ ord ( $ s [ $ i ] ) - ord ( ' a ' ) ] ++ ; for ( $ i = 0 ; $ i < $ MAX_CHAR ; $ i ++ ) $ result += ( $ count [ $ i ] * ( $ count [ $ i ] + 1 ) / 2 ) ; return $ result ; }
function areaCircle ( $ b ) { $ area = $ GLOBALS [ ' pi ' ] * $ b * $ b ; return $ area ; }
function printMinDiffPairs ( $ arr , $ n ) { if ( $ n <= 1 ) return ; sort ( $ arr ) ; $ minDiff = $ arr [ 1 ] - $ arr [ 0 ] ; for ( $ i = 2 ; $ i < $ n ; $ i ++ ) $ minDiff = min ( $ minDiff , $ arr [ $ i ] - $ arr [ $ i - 1 ] ) ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) if ( ( $ arr [ $ i ] - $ arr [ $ i - 1 ] ) == $ minDiff ) echo " ( " , $ arr [ $ i - 1 ] , " , ▁ " , $ arr [ $ i ] , " ) , ▁ " ; }
function isMultipleOf10 ( $ n ) { return ( $ n % 15 == 0 ) ; }
function sumofFactors ( $ n ) { if ( $ n % 2 != 0 ) return 0 ; $ res = 1 ; for ( $ i = 2 ; $ i <= sqrt ( $ n ) ; $ i ++ ) { $ count = 0 ; $ curr_sum = 1 ; $ curr_term = 1 ; while ( $ n % $ i == 0 ) { $ count ++ ; $ n = floor ( $ n / $ i ) ; if ( $ i == 2 && $ count == 1 ) $ curr_sum = 0 ; $ curr_term *= $ i ; $ curr_sum += $ curr_term ; } $ res *= $ curr_sum ; } if ( $ n >= 2 ) $ res *= ( 1 + $ n ) ; return $ res ; }
function longestRodInCuboid ( $ length , $ breadth , $ height ) { $ result ; $ temp ; $ temp = $ length * $ length + $ breadth * $ breadth + $ height * $ height ; $ result = sqrt ( $ temp ) ; return $ result ; }
function getMinNum ( $ a , $ b , $ c ) { if ( $ c < $ a $ c > $ b ) return $ c ; $ x = ( floor ( ( $ b / $ c ) ) * $ c ) + $ c ; return $ x ; }
function sphereSide ( $ h , $ r ) { if ( $ h < 0 && $ r < 0 ) return -1 ; $ R = ( ( $ h * $ r * sqrt ( 2 ) ) / ( $ h + sqrt ( 2 ) * $ r ) ) / 2 ; return $ R ; }
function Colour_Combination ( $ s ) { $ temp = $ s [ 0 ] ; for ( $ i = 1 ; $ i < strlen ( $ s ) ; $ i ++ ) { if ( $ temp != $ s [ $ i ] ) { if ( ( $ temp == ' B ' $ temp == ' G ' ) && ( $ s [ $ i ] == ' G ' $ s [ $ i ] == ' B ' ) ) $ temp = ' Y ' ; else if ( ( $ temp == ' B ' $ temp == ' Y ' ) && ( $ s [ $ i ] == ' Y ' $ s [ $ i ] == ' B ' ) ) $ temp = ' G ' ; else $ temp = ' B ' ; } } return $ temp ; }
function line ( $ x0 , $ y0 ) { $ c = 2 * $ y0 * $ x0 ; echo $ y0 , " x " , " ▁ + ▁ " , $ x0 , " y ▁ = ▁ " , $ c ; }
function isDefeat ( $ s1 , $ s2 , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( ( $ s1 [ $ i ] == '0' && $ s2 [ $ i ] == '1' ) || ( $ s1 [ $ i ] == '1' && $ s2 [ $ i ] == '0' ) ) continue ; else if ( ( $ s1 [ $ i ] == '0' && $ s2 [ $ i ] == ' Z ' ) || ( $ s1 [ $ i ] == ' Z ' && $ s2 [ $ i ] == '0' ) ) continue ; else { return true ; } } return false ; }
function smallestGreater ( $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ diff = PHP_INT_MAX ; $ closest = -1 ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ arr [ $ i ] < $ arr [ $ j ] && $ arr [ $ j ] - $ arr [ $ i ] < $ diff ) { $ diff = $ arr [ $ j ] - $ arr [ $ i ] ; $ closest = $ j ; } } if ( $ closest == -1 ) echo " _ ▁ " ; else echo $ arr [ $ closest ] , " ▁ " ; } }
function countP ( $ n , $ k ) { $ dp [ $ n + 1 ] [ $ k + 1 ] = array ( array ( ) ) ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) $ dp [ $ i ] [ 0 ] = 0 ; for ( $ i = 0 ; $ i <= $ k ; $ i ++ ) $ dp [ 0 ] [ $ k ] = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) for ( $ j = 1 ; $ j <= $ i ; $ j ++ ) if ( $ j == 1 $ i == $ j ) $ dp [ $ i ] [ $ j ] = 1 ; else $ dp [ $ i ] [ $ j ] = $ j * $ dp [ $ i - 1 ] [ $ j ] + $ dp [ $ i - 1 ] [ $ j - 1 ] ; return $ dp [ $ n ] [ $ k ] ; }
function println ( $ n , $ k ) { $ rem = 1 ; for ( $ i = 0 ; $ i < $ k ; $ i ++ ) { echo floor ( ( 10 * $ rem ) / $ n ) ; $ rem = ( 10 * $ rem ) % $ n ; } }
function minOperations ( $ A , $ n ) { if ( $ n & 1 ) return -1 ; $ zeros = 0 ; $ consZeros = 0 ; $ ones = 0 ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { $ A [ $ i ] == 0 ? $ zeros ++ : $ ones ++ ; if ( ( $ i + 1 ) < $ n ) { if ( $ A [ $ i ] == 0 && $ A [ $ i + 1 ] == 0 ) $ consZeros ++ ; } } if ( $ A [ 0 ] == $ A [ $ n - 1 ] && $ A [ 0 ] == 0 ) $ consZeros ++ ; if ( $ zeros == $ ones ) return $ consZeros ; else return -1 ; }
function aliquotSum ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) if ( $ n % $ i == 0 ) $ sum += $ i ; return $ sum ; }
function countRectangles ( $ radius ) { $ rectangles = 0 ; $ diameter = 2 * $ radius ; $ diameterSquare = $ diameter * $ diameter ; for ( $ a = 1 ; $ a < 2 * $ radius ; $ a ++ ) { for ( $ b = 1 ; $ b < 2 * $ radius ; $ b ++ ) { $ diagonalLengthSquare = ( $ a * $ a + $ b * $ b ) ; if ( $ diagonalLengthSquare <= $ diameterSquare ) { $ rectangles ++ ; } } } return $ rectangles ; }
function maxSum ( $ arr , $ n , $ K ) { $ maximum = PHP_INT_MIN ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sumk = 0 ; for ( $ j = $ i ; $ j < $ n ; $ j += $ K ) $ sumk = $ sumk + $ arr [ $ j ] ; $ maximum = max ( $ maximum , $ sumk ) ; } return $ maximum ; }
function LIS ( $ a , $ n ) { $ dp = array ( ) ; $ d = array ( ) ; $ ans = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ dp [ $ a [ $ i ] ] = 1 ; for ( $ j = 2 ; $ j * $ j <= $ a [ $ i ] ; $ j ++ ) { if ( $ a [ $ i ] % $ j == 0 ) { $ dp [ $ a [ $ i ] ] = max ( $ dp [ $ a [ $ i ] ] , $ dp [ $ d [ $ j ] ] + 1 ) ; $ dp [ $ a [ $ i ] ] = max ( $ dp [ $ a [ $ i ] ] , $ dp [ $ d [ $ a [ $ i ] / $ j ] ] + 1 ) ; $ d [ $ j ] = $ a [ $ i ] ; $ d [ $ a [ $ i ] / $ j ] = $ a [ $ i ] ; } } $ ans = max ( $ ans , $ dp [ $ a [ $ i ] ] ) ; $ d [ $ a [ $ i ] ] = $ a [ $ i ] ; } return $ ans ; }
function steps ( $ N , $ M ) { if ( $ N == 1 ) return 0 ; return $ M ; return 2 * $ M + ( $ N - 3 ) ; }
function findUnique ( $ a , $ n , $ k ) { $ INT_SIZE = 8 * PHP_INT_SIZE ; $ count = array ( ) ; for ( $ i = 0 ; $ i < $ INT_SIZE ; $ i ++ ) $ count [ $ i ] = 0 ; for ( $ i = 0 ; $ i < $ INT_SIZE ; $ i ++ ) for ( $ j = 0 ; $ j < $ n ; $ j ++ ) if ( ( $ a [ $ j ] & ( 1 << $ i ) ) != 0 ) $ count [ $ i ] += 1 ; $ res = 0 ; for ( $ i = 0 ; $ i < $ INT_SIZE ; $ i ++ ) $ res += ( $ count [ $ i ] % $ k ) * ( 1 << $ i ) ; return $ res ; }
function get_maximum ( $ s , $ a ) { $ n = strlen ( $ s ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ s [ $ i ] - '0' < $ a [ $ s [ $ i ] - '0' ] ) { $ j = $ i ; while ( $ j < $ n && ( $ s [ $ j ] - '0' <= $ a [ $ s [ $ j ] - '0' ] ) ) { $ s [ $ j ] = '0' + $ a [ $ s [ $ j ] - '0' ] ; $ j ++ ; } return $ s ; } } return $ s ; }
function sqroot ( $ s ) { $ pSq = 0 ; $ N = 0 ; for ( $ i = intval ( $ s ) ; $ i > 0 ; $ i -- ) { for ( $ j = 1 ; $ j < $ i ; $ j ++ ) { if ( $ j * $ j == $ i ) { $ pSq = $ i ; $ N = $ j ; break ; } } if ( $ pSq > 0 ) break ; } $ d = $ s - $ pSq ; $ P = $ d / ( 2.0 * $ N ) ; $ A = $ N + $ P ; $ sqrt_of_s = $ A - ( ( $ P * $ P ) / ( 2.0 * $ A ) ) ; return $ sqrt_of_s ; }
function idstrt ( $ a1 , $ b1 , $ c1 , $ a2 , $ b2 , $ c2 ) { if ( ( $ a1 / $ a2 == $ b1 / $ b2 ) && ( $ a1 / $ a2 == $ c1 / $ c2 ) && ( $ b1 / $ b2 == $ c1 / $ c2 ) ) echo " The ▁ given ▁ straight ▁ lines ▁ are ▁ identical " , " STRNEWLINE " ; else echo " The ▁ given ▁ straight ▁ lines ▁ are ▁ not ▁ identical " , " STRNEWLINE " ; }
function printAP ( $ a , $ d , $ n ) { $ curr_term ; $ curr_term = a ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { echo ( $ curr_term . " " ) ; $ curr_term += $ d ; } }
function printRoots ( $ a , $ b , $ c ) { echo "1" ; echo " , ▁ " ; echo $ c / ( $ a * 1.0 ) ; }
function countIntervals ( $ arr , $ V , $ N ) { global $ MAX_VAL ; $ min = PHP_INT_MAX ; $ max = 0 ; $ li = 0 ; $ ri = 0 ; $ freq = array_fill ( 0 , $ MAX_VAL , 0 ) ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { $ li = $ arr [ $ i ] [ 0 ] ; $ freq [ $ li ] = $ freq [ $ li ] + 1 ; $ ri = $ arr [ $ i ] [ 1 ] ; $ freq [ $ ri + 1 ] = $ freq [ $ ri + 1 ] - 1 ; if ( $ li < $ min ) $ min = $ li ; if ( $ ri > $ max ) $ max = $ ri ; } for ( $ i = $ min ; $ i <= $ max ; $ i ++ ) $ freq [ $ i ] = $ freq [ $ i ] + $ freq [ $ i - 1 ] ; return $ freq [ $ V ] ; }
function subset ( $ ar , $ n ) { $ res = 0 ; sort ( $ ar ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ count = 1 ; for ( ; $ i < $ n - 1 ; $ i ++ ) { if ( $ ar [ $ i ] == $ ar [ $ i + 1 ] ) $ count ++ ; else break ; } $ res = max ( $ res , $ count ) ; } return $ res ; }
function leastValue ( $ P , $ A , $ N , $ a ) { $ ans = -1 ; $ tmp = PHP_INT_MAX ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { $ t = $ P - $ a [ $ i ] * 0.006 ; if ( abs ( $ t - $ A ) < $ tmp ) { $ tmp = abs ( $ t - $ A ) ; $ ans = $ i ; } } return $ a [ $ ans ] ; }
function isLucky ( $ n ) { $ arr = array ( ) ; for ( $ i = 0 ; $ i < 10 ; $ i ++ ) $ arr [ $ i ] = false ; while ( $ n > 0 ) { $ digit = $ n % 10 ; if ( $ arr [ $ digit ] ) return false ; $ arr [ $ digit ] = true ; $ n = ( int ) ( $ n / 10 ) ; } return true ; }
function countSubsequences ( $ s ) { $ aCount = 0 ; $ bCount = 0 ; $ cCount = 0 ; for ( $ i = 0 ; $ i < strlen ( $ s ) ; $ i ++ ) { if ( $ s [ $ i ] == ' a ' ) $ aCount = ( 1 + 2 * $ aCount ) ; else if ( $ s [ $ i ] == ' b ' ) $ bCount = ( $ aCount + 2 * $ bCount ) ; else if ( $ s [ $ i ] == ' c ' ) $ cCount = ( $ bCount + 2 * $ cCount ) ; } return $ cCount ; }
function isPrime ( $ p ) { $ checkNumber = pow ( 2 , $ p ) - 1 ; $ nextval = 4 % $ checkNumber ; for ( $ i = 1 ; $ i < $ p - 1 ; $ i ++ ) $ nextval = ( $ nextval * $ nextval - 2 ) % $ checkNumber ; return ( $ nextval == 0 ) ; }
function power ( $ x , $ y , $ p ) { $ res = 1 ; $ x = $ x % $ p ; while ( $ y > 0 ) { if ( $ y & 1 ) $ res = ( $ res * $ x ) % $ p ; $ x = ( $ x * $ x ) % $ p ; } return $ res ; }
function printClosest ( $ arr , $ n , $ x ) { $ res_l ; $ res_r ; $ l = 0 ; $ r = $ n - 1 ; $ diff = PHP_INT_MAX ; while ( $ r > $ l ) { if ( abs ( $ arr [ $ l ] + $ arr [ $ r ] - $ x ) < $ diff ) { $ res_l = $ l ; $ res_r = $ r ; $ diff = abs ( $ arr [ $ l ] + $ arr [ $ r ] - $ x ) ; } if ( $ arr [ $ l ] + $ arr [ $ r ] > $ x ) $ r -- ; else $ l ++ ; } echo " ▁ The ▁ closest ▁ pair ▁ is ▁ " , $ arr [ $ res_l ] , " ▁ and ▁ " , $ arr [ $ res_r ] ; }
function CountCharacters ( $ str , $ k ) { $ cnt = 0 ; $ len = strlen ( $ str ) ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { if ( $ str [ $ i ] < chr ( $ k ) ) $ cnt += 1 ; } return $ cnt ; }
function canTakeDown ( $ bishopX , $ bishopY , $ pawnX , $ pawnY ) { if ( $ pawnX - $ bishopX == $ pawnY - $ bishopY ) return true ; else if ( - $ pawnX + $ bishopX == $ pawnY - $ bishopY ) return true ; else return false ; }
function centeredIcosahedralNum ( $ n ) { return ( 2 * $ n + 1 ) * ( 5 * $ n * $ n + 5 * $ n + 3 ) / 3 ; }
function findRadiusOfcircumcircle ( $ n , $ a ) { if ( $ n < 0 $ a < 0 ) return -1 ; $ radius = $ a / sqrt ( 2 - ( 2 * cos ( 360 / $ n ) ) ) ; return $ radius ; }
function solve ( $ A , $ B ) { $ count = 0 ; for ( $ i = 0 ; $ i < 32 ; $ i ++ ) { if ( ( ( $ A >> $ i ) & 1 ) != ( ( $ B >> $ i ) & 1 ) ) { $ count ++ ; } } echo " Number ▁ of ▁ different ▁ bits ▁ : ▁ $ count " ; }
function centered_pentagonal_Num ( $ n ) { return ( 5 * $ n * $ n - 5 * $ n + 2 ) / 2 ; }
function check ( $ k , $ d0 , $ d1 ) { $ s = ( 2 * ( $ d0 + $ d1 ) ) % 10 + ( 4 * ( $ d0 + $ d1 ) ) % 10 + ( 8 * ( $ d0 + $ d1 ) ) % 10 + ( 6 * ( $ d0 + $ d1 ) ) % 10 ; $ a = ( $ k - 3 ) % 4 ; $ x ; switch ( $ a ) { case 0 : $ x = 0 ; break ; case 1 : $ x = ( 2 * ( $ d0 + $ d1 ) ) % 10 ; break ; case 2 : $ x = ( 2 * ( $ d0 + $ d1 ) ) % 10 + ( 4 * ( $ d0 + $ d1 ) ) % 10 ; break ; case 3 : $ x = ( 2 * ( $ d0 + $ d1 ) ) % 10 + ( 4 * ( $ d0 + $ d1 ) ) % 10 + ( 8 * ( $ d0 + $ d1 ) ) % 10 ; break ; } $ sum = $ d0 + $ d1 + ( int ) ( ( $ k - 3 ) / 4 ) * $ s + $ x ; if ( $ sum % 3 == 0 ) return " YES " ; return " NO " ; }
function printGroups ( $ n ) { $ x = 1 ; $ y = $ n * $ n ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 1 ; $ j <= $ n / 2 ; $ j ++ ) { echo " { " ▁ , ▁ $ x ▁ , ▁ " , " ▁ , ▁ $ y ▁ , ▁ " } " $ x ++ ; $ y -- ; } echo " STRNEWLINE " ; } }
function largestCoprime ( $ N ) { if ( $ N == 6 ) return 1 ; else if ( $ N % 4 == 0 ) return ( $ N / 2 ) - 1 ; else if ( $ N % 2 == 0 ) return ( $ N / 2 ) - 2 ; else return ( ( $ N - 1 ) / 2 ) ; }
function areChractersUnique ( $ str ) { $ checker = 0 ; for ( $ i = 0 ; $ i < $ len = strlen ( $ str ) ; ++ $ i ) { $ val = ( $ str [ $ i ] - ' a ' ) ; if ( ( $ checker & ( 1 << $ val ) ) > 0 ) return false ; $ checker |= ( 1 << $ val ) ; } return true ; }
function NumberOfSolutions ( $ a , $ b , $ c , $ d ) { $ ans = 0 ; for ( $ i = $ a ; $ i <= $ b ; $ i ++ ) if ( $ d >= max ( $ c , $ i + 1 ) ) $ ans += $ d - max ( $ c , $ i + 1 ) + 1 ; return $ ans ; }
function allBitsSetInTheGivenRange ( $ n , $ l , $ r ) { $ num = ( ( 1 << $ r ) - 1 ) ^ ( ( 1 << ( $ l - 1 ) ) - 1 ) ; $ new_num = $ n & $ num ; if ( $ new_num == 0 ) return true ; return false ; }
function findNumbers ( $ n , $ d ) { for ( $ i = 0 ; $ i < $ n - 2 ; $ i ++ ) echo "1" , " ▁ " ; echo "2" , " ▁ " ; echo $ n + $ d , " STRNEWLINE " ; }
function getParity ( $ n ) { $ parity = 0 ; while ( $ n ) { $ parity = ! $ parity ; $ n = $ n & ( $ n - 1 ) ; } return $ parity ; }
function countDigit ( $ n ) { if ( $ n / 10 == 0 ) return 1 ; return 1 + countDigit ( ( int ) ( $ n / 10 ) ) ; }
function pairAndSum ( $ arr , $ n ) { $ ans = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) $ ans += $ arr [ $ i ] & $ arr [ $ j ] ; return $ ans ; }
function halfsquare ( $ n , $ x , $ y ) { $ half = $ n / 2 ; if ( ( $ half == $ x $ half == $ x - 1 ) && ( $ half == $ y $ half == $ y - 1 ) ) echo " NO " ; else echo " YES " ; }
function canBeSumofConsec ( $ n ) { return ( ( $ n & ( $ n - 1 ) ) && $ n ) ; }
function optimalStrategyOfGame ( $ arr , $ n ) { $ table = array_fill ( 0 , $ n , array_fill ( 0 , $ n , 0 ) ) ; for ( $ gap = 0 ; $ gap < $ n ; ++ $ gap ) { for ( $ i = 0 , $ j = $ gap ; $ j < $ n ; ++ $ i , ++ $ j ) { $ x = ( ( $ i + 2 ) <= $ j ) ? $ table [ $ i + 2 ] [ $ j ] : 0 ; $ y = ( ( $ i + 1 ) <= ( $ j - 1 ) ) ? $ table [ $ i + 1 ] [ $ j - 1 ] : 0 ; $ z = ( $ i <= ( $ j - 2 ) ) ? $ table [ $ i ] [ $ j - 2 ] : 0 ; $ table [ $ i ] [ $ j ] = max ( $ arr [ $ i ] + min ( $ x , $ y ) , $ arr [ $ j ] + min ( $ y , $ z ) ) ; } } return $ table [ 0 ] [ $ n - 1 ] ; }
function evenDecimalValue ( $ str , $ n ) { $ result = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = $ i ; $ j < $ n ; $ j ++ ) { $ decimalValue = 0 ; $ powerOf2 = 1 ; for ( $ k = $ i ; $ k <= $ j ; $ k ++ ) { $ decimalValue += ( ( $ str [ $ k ] - '0' ) * $ powerOf2 ) ; $ powerOf2 *= 2 ; } if ( $ decimalValue % 2 == 0 ) $ result ++ ; } } return $ result ; }
function alternateSubarray ( & $ arr , $ n ) { $ len = array_fill ( 0 , $ n , NULL ) ; $ len [ $ n - 1 ] = 1 ; for ( $ i = $ n - 2 ; $ i >= 0 ; -- $ i ) { if ( $ arr [ $ i ] ^ $ arr [ $ i + 1 ] == 1 ) $ len [ $ i ] = $ len [ $ i + 1 ] + 1 ; else $ len [ $ i ] = 1 ; } for ( $ i = 0 ; $ i < $ n ; ++ $ i ) echo $ len [ $ i ] . " ▁ " ; }
function areaSquare ( $ side , $ fold ) { $ area = $ side * $ side ; return $ area * 1.0 / pow ( 2 , $ fold ) ; }
function findMin ( $ a , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum += log ( $ a [ $ i ] ) ; $ x = exp ( $ sum / $ n ) ; return ( int ) ( $ x + 1 ) ; }
function patternCount ( $ str ) { $ last = $ str [ 0 ] ; $ i = 1 ; $ counter = 0 ; while ( $ i < strlen ( $ str ) ) { if ( $ str [ $ i ] == '0' && $ last == '1' ) { while ( $ str [ $ i ] == '0' ) $ i ++ ; if ( $ str [ $ i ] == '1' ) $ counter ++ ; } $ last = $ str [ $ i ] ; $ i ++ ; } return $ counter ; }
function get_last_two_digit ( $ N ) { if ( $ N <= 10 ) { $ ans = 0 ; $ fac = 1 ; for ( $ i = 1 ; $ i <= $ N ; $ i ++ ) { $ fac = $ fac * $ i ; $ ans += $ fac ; } return $ ans % 100 ; } return 13 ; }
function Substring ( $ s ) { $ ans = 1 ; $ temp = 1 ; for ( $ i = 1 ; $ i < strlen ( $ s ) ; $ i ++ ) { if ( $ s [ $ i ] == $ s [ $ i - 1 ] ) { ++ $ temp ; } else { $ ans = max ( $ ans , $ temp ) ; $ temp = 1 ; } } $ ans = max ( $ ans , $ temp ) ; return $ ans ; }
function countSymmetric ( $ n ) { if ( $ n == 0 ) return 1 ; return 1 << ( ( $ n * ( $ n + 1 ) ) / 2 ) ; }
function countNonEmptySubstr ( $ str ) { $ n = strlen ( $ str ) ; return $ n * ( $ n + 1 ) / 2 ; }
function findIndex ( $ a , $ n ) { $ min_diff = PHP_INT_MAX ; $ prod = array ( ) ; $ prod [ 0 ] = $ a [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ prod [ $ i ] = $ prod [ $ i - 1 ] * $ a [ $ i ] ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { $ curr_diff = abs ( ( $ prod [ $ n - 1 ] / $ prod [ $ i ] ) - $ prod [ $ i ] ) ; if ( $ curr_diff < $ min_diff ) { $ min_diff = $ curr_diff ; $ res = $ i ; } } return $ res ; }
function printMinimumProduct ( $ arr , $ n ) { $ first_min = min ( $ arr [ 0 ] , $ arr [ 1 ] ) ; $ second_min = max ( $ arr [ 0 ] , $ arr [ 1 ] ) ; for ( $ i = 2 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] < $ first_min ) { $ second_min = $ first_min ; $ first_min = $ arr [ $ i ] ; } else if ( $ arr [ $ i ] < $ second_min ) $ second_min = $ arr [ $ i ] ; } return $ first_min * $ second_min ; }
function findElements ( $ arr , $ n ) { $ first = PHP_INT_MIN ; $ second = PHP_INT_MIN ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] > $ first ) { $ second = $ first ; $ first = $ arr [ $ i ] ; } else if ( $ arr [ $ i ] > $ second ) $ second = $ arr [ $ i ] ; } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] < $ second ) echo $ arr [ $ i ] , " ▁ " ; }
function fib ( $ n ) { if ( $ n <= 1 ) return $ n ; return fib ( $ n - 1 ) + fib ( $ n - 2 ) ; }
function maxHandshake ( $ n ) { return ( $ n * ( $ n - 1 ) ) / 2 ; }
function countPoints ( $ n , $ m , $ a , $ b , $ x , $ y ) { sort ( $ a ) ; sort ( $ b ) ; $ j = 0 ; $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { while ( $ j < $ m ) { if ( $ a [ $ i ] + $ y < $ b [ $ j ] ) break ; if ( $ b [ $ j ] >= $ a [ $ i ] - $ x && $ b [ $ j ] <= $ a [ $ i ] + $ y ) { $ count ++ ; $ j ++ ; break ; } else $ j ++ ; } } return $ count ; }
function pushZerosToEnd ( & $ arr , $ n ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] != 0 ) $ arr [ $ count ++ ] = $ arr [ $ i ] ; while ( $ count < $ n ) $ arr [ $ count ++ ] = 0 ; }
function CalculatePairs ( $ a , $ n ) { $ cnt_zero = 0 ; $ cnt_one = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] % 2 == 0 ) $ cnt_zero += 1 ; else $ cnt_one += 1 ; } $ total_XOR_pairs = $ cnt_zero * $ cnt_one ; $ total_AND_pairs = ( $ cnt_one ) * ( $ cnt_one - 1 ) / 2 ; $ total_OR_pairs = $ cnt_zero * $ cnt_one + ( $ cnt_one ) * ( $ cnt_one - 1 ) / 2 ; echo ( " cntXOR ▁ = ▁ $ total _ XOR _ pairs STRNEWLINE " ) ; echo ( " cntAND ▁ = ▁ $ total _ AND _ pairs STRNEWLINE " ) ; echo ( " cntOR ▁ = ▁ $ total _ OR _ pairs STRNEWLINE " ) ; }
function countOnes ( $ arr , $ low , $ high ) { if ( $ high >= $ low ) { $ mid = $ low + ( $ high - $ low ) / 2 ; if ( ( $ mid == $ high or $ arr [ $ mid + 1 ] == 0 ) and ( $ arr [ $ mid ] == 1 ) ) return $ mid + 1 ; if ( $ arr [ $ mid ] == 1 ) return countOnes ( $ arr , ( $ mid + 1 ) , $ high ) ; return countOnes ( $ arr , $ low , ( $ mid - 1 ) ) ; } return 0 ; }
function maxEdges ( $ N ) { $ edges = 0 ; $ edges = floor ( ( $ N * $ N ) / 4 ) ; return $ edges ; }
function eulerian ( $ n , $ m ) { if ( $ m >= $ n $ n == 0 ) return 0 ; if ( $ m == 0 ) return 1 ; return ( $ n - $ m ) * eulerian ( $ n - 1 , $ m - 1 ) + ( $ m + 1 ) * eulerian ( $ n - 1 , $ m ) ; }
function SternSequenceFunc ( & $ BrocotSequence , $ n ) { for ( $ i = 1 ; count ( $ BrocotSequence ) < $ n ; $ i ++ ) { $ considered_element = $ BrocotSequence [ $ i ] ; $ precedent = $ BrocotSequence [ $ i - 1 ] ; array_push ( $ BrocotSequence , $ considered_element + $ precedent ) ; array_push ( $ BrocotSequence , $ considered_element ) ; } for ( $ i = 0 ; $ i < 15 ; ++ $ i ) echo ( $ BrocotSequence [ $ i ] . " ▁ " ) ; }
function calculateSum ( $ n ) { return 2 * ( $ n * ( $ n + 1 ) * ( 2 * $ n + 1 ) / 6 ) + $ n * ( $ n + 1 ) / 2 + 2 * ( $ n ) ; }
function circle_equation ( $ x1 , $ y1 , $ r ) { $ a = -2 * $ x1 ; $ b = -2 * $ y1 ; $ c = ( $ r * $ r ) - ( $ x1 * $ x1 ) - ( $ y1 * $ y1 ) ; echo " x ^ 2 + ( " ▁ . ▁ $ a ▁ . ▁ " x ) + " echo " y ^ 2 ▁ + ▁ ( " . $ b . " ▁ y ) ▁ = ▁ " ; echo $ c . " . " . " STRNEWLINE " ; }
function isEven ( $ n ) { return ( $ n % 2 == 0 ) ; }
function findSubArray ( & $ arr , $ n ) { $ sum = 0 ; $ maxsize = -1 ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { $ sum = ( $ arr [ $ i ] == 0 ) ? -1 : 1 ; for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) { ( $ arr [ $ j ] == 0 ) ? ( $ sum += -1 ) : ( $ sum += 1 ) ; if ( $ sum == 0 && $ maxsize < $ j - $ i + 1 ) { $ maxsize = $ j - $ i + 1 ; $ startindex = $ i ; } } } if ( $ maxsize == -1 ) echo " No ▁ such ▁ subarray " ; else echo $ startindex . " ▁ to ▁ " . ( $ startindex + $ maxsize - 1 ) ; return $ maxsize ; }
function squarearea ( $ a , $ b ) { if ( $ a < 0 or $ b < 0 ) return -1 ; $ area = 4 * ( ( ( pow ( $ a , 2 ) + pow ( $ b , 2 ) ) / ( pow ( $ a , 2 ) * pow ( $ b , 2 ) ) ) ) ; return $ area ; }
function cost ( $ str ) { $ len = strlen ( $ str ) ; $ res = 0 ; for ( $ i = 0 , $ j = $ len - 1 ; $ i < $ j ; $ i ++ , $ j -- ) if ( $ str [ $ i ] != $ str [ $ j ] ) $ res += ( min ( ord ( $ str [ $ i ] ) , ord ( $ str [ $ j ] ) ) - ord ( ' a ' ) + 1 ) ; return $ res ; }
function isPossibleToZero ( $ a , $ n ) { $ even = 0 ; $ odd = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ i & 1 ) $ odd += $ a [ $ i ] ; else $ even += $ a [ $ i ] ; } return ( $ odd == $ even ) ; }
