function checkIsAP ( $ arr , $ n ) { if ( $ n == 1 ) return true ; sort ( $ arr ) ; $ d = $ arr [ 1 ] - $ arr [ 0 ] ; for ( $ i = 2 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] - $ arr [ $ i - 1 ] != $ d ) return false ; return true ; }
function longestSubArray ( $ arr , $ n ) { $ isZeroPresent = false ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] == 0 ) { $ isZeroPresent = true ; break ; } } if ( $ isZeroPresent ) return $ n ; return 0 ; }
function F ( $ A , $ B ) { if ( $ A == 1 ) return ( 4 % $ B ) ; else { $ temp = F ( $ A - 1 , $ B ) ; return ( $ temp * $ temp ) % $ B ; } }
function sentencePalindrome ( $ str ) { $ l = 0 ; $ h = strlen ( $ str ) - 1 ; for ( $ i = 0 ; $ i < $ h ; $ i ++ ) $ str [ $ i ] = strtolower ( $ str [ $ i ] ) ; while ( $ l <= $ h ) { if ( ! ( $ str [ $ l ] >= ' a ' && $ str [ $ l ] <= ' z ' ) ) $ l ++ ; else if ( ! ( $ str [ $ h ] >= ' a ' && $ str [ $ h ] <= ' z ' ) ) $ h -- ; else if ( $ str [ $ l ] == $ str [ $ h ] ) { $ l ++ ; $ h -- ; } else return false ; } return true ; }
function Calculate_GST ( $ org_cost , $ N_price ) { return ( ( ( $ N_price - $ org_cost ) * 100 ) / $ org_cost ) ; }
function FindPoints ( $ x1 , $ y1 , $ x2 , $ y2 , $ x3 , $ y3 , $ x4 , $ y4 ) { $ x5 = max ( $ x1 , $ x3 ) ; $ y5 = max ( $ y1 , $ y3 ) ; $ x6 = min ( $ x2 , $ x4 ) ; $ y6 = min ( $ y2 , $ y4 ) ; if ( $ x5 > $ x6 $ y5 > $ y6 ) { echo " No ▁ intersection " ; return ; } echo " ( " . $ x5 . " , " ▁ . ▁ $ y5 ▁ . ▁ " ) " ; echo " ( " . $ x6 . " , " ▁ . ▁ $ y6 ▁ . ▁ " ) " ; $ x7 = $ x5 ; $ y7 = $ y6 ; echo " ( " . $ x7 . " , " ▁ . ▁ $ y7 ▁ . ▁ " ) " ; $ x8 = $ x6 ; $ y8 = $ y5 ; echo " ( " . $ x8 . " , " ▁ . ▁ $ y8 ▁ . ▁ " ) " ; }
function maxSum ( $ mat , $ n ) { if ( $ n == 1 ) return $ mat [ 0 ] [ 0 ] ; $ dp = array ( array ( ) ) ; $ maxSum = PHP_INT_MIN ; $ max ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) $ dp [ $ n - 1 ] [ $ j ] = $ mat [ $ n - 1 ] [ $ j ] ; for ( $ i = $ n - 2 ; $ i >= 0 ; $ i -- ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { $ max = PHP_INT_MIN ; if ( ( ( $ j - 1 ) >= 0 ) and ( $ max < $ dp [ $ i + 1 ] [ $ j - 1 ] ) ) $ max = $ dp [ $ i + 1 ] [ $ j - 1 ] ; if ( ( ( $ j + 1 ) < $ n ) and ( $ max < $ dp [ $ i + 1 ] [ $ j + 1 ] ) ) $ max = $ dp [ $ i + 1 ] [ $ j + 1 ] ; $ dp [ $ i ] [ $ j ] = $ mat [ $ i ] [ $ j ] + $ max ; } } for ( $ j = 0 ; $ j < $ n ; $ j ++ ) if ( $ maxSum < $ dp [ 0 ] [ $ j ] ) $ maxSum = $ dp [ 0 ] [ $ j ] ; return $ maxSum ; }
function pell ( $ n ) { if ( $ n <= 2 ) return $ n ; return 2 * pell ( $ n - 1 ) + pell ( $ n - 2 ) ; }
function testSomeNumbers ( $ limit , $ n ) { if ( $ n < 3 ) for ( $ a = 1 ; $ a <= $ limit ; $ a ++ ) for ( $ b = $ a ; $ b <= $ limit ; $ b ++ ) { $ pow_sum = pow ( $ a , $ n ) + pow ( $ b , $ n ) ; $ c = pow ( $ pow_sum , 1.0 / $ n ) ; $ c_pow = pow ( $ c , $ n ) ; if ( $ c_pow != $ pow_sum ) { echo " Count ▁ example ▁ found " ; return ; } } echo " No ▁ counter ▁ example ▁ within ▁ " . " given ▁ range ▁ and ▁ data " ; }
function find3Numbers ( $ A , $ arr_size , $ sum ) { $ l ; $ r ; for ( $ i = 0 ; $ i < $ arr_size - 2 ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ arr_size - 1 ; $ j ++ ) { for ( $ k = $ j + 1 ; $ k < $ arr_size ; $ k ++ ) { if ( $ A [ $ i ] + $ A [ $ j ] + $ A [ $ k ] == $ sum ) { echo " Triplet ▁ is " , " ▁ " , $ A [ $ i ] , " , ▁ " , $ A [ $ j ] , " , ▁ " , $ A [ $ k ] ; return true ; } } } } return false ; }
function ways ( $ n ) { $ first = 2 ; $ second = 3 ; $ res = 0 ; for ( $ i = 3 ; $ i <= $ n ; $ i ++ ) { $ res = $ first + $ second ; $ first = $ second ; $ second = $ res ; } return $ res ; }
function pentdiagonal ( $ a ) { if ( $ a < 0 ) return -1 ; $ d = 1.22 * $ a ; return $ d ; }
function evenNumSubstring ( $ str ) { $ len = strlen ( $ str ) ; $ count = 0 ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { $ temp = $ str [ $ i ] - '0' ; if ( $ temp % 2 == 0 ) $ count += ( $ i + 1 ) ; } return $ count ; }
function divisorSum ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; ++ $ i ) $ sum += floor ( $ n / $ i ) * $ i ; return $ sum ; }
function isPerfectSquareString ( $ str ) { $ sum = 0 ; $ len = strlen ( $ str ) ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) $ sum += ( int ) $ str [ $ i ] ; $ squareRoot = sqrt ( $ sum ) ; return ( ( $ squareRoot - floor ( $ squareRoot ) ) == 0 ) ; }
function kthSmallest ( $ n , $ k ) { return ( 2 * $ k ) ; }
function MinOfCubed ( $ k ) { if ( $ k < 8 ) return $ k ; $ res = $ k ; for ( $ i = 1 ; $ i <= $ k ; $ i ++ ) { if ( ( $ i * $ i * $ i ) > $ k ) return $ res ; $ res = min ( $ res , MinOfCubed ( $ k - ( $ i * $ i * $ i ) ) + 1 ) ; } return $ res ; }
function StepstoReachTarget ( $ target ) { $ target = abs ( $ target ) ; $ n = ceil ( ( -1.0 + sqrt ( 1 + 8.0 * $ target ) ) / 2 ) ; $ sum = $ n * ( $ n + 1 ) / 2 ; if ( $ sum == $ target ) return $ n ; $ d = $ sum - $ target ; if ( ( $ d & 1 ) == 0 ) return n ; else return $ n + ( ( $ n & 1 ) ? 2 : 1 ) ; }
function findAreaShaded ( $ a ) { $ sqArea = $ a * $ a ; $ semiCircleArea = ( 3.14 * ( $ a * $ a ) / 8 ) ; $ ShadedArea = 4 * $ semiCircleArea - $ sqArea ; return $ ShadedArea ; }
function findNth ( $ n ) { $ count = 0 ; for ( $ curr = 19 ; ; $ curr += 9 ) { $ sum = 0 ; for ( $ x = $ curr ; $ x > 0 ; $ x = ( int ) $ x / 10 ) $ sum = $ sum + $ x % 10 ; if ( $ sum == 10 ) $ count ++ ; if ( $ count == $ n ) return $ curr ; } return -1 ; }
function numberOfPaths ( $ m , $ n ) { $ path = 1 ; for ( $ i = $ n ; $ i < ( $ m + $ n - 1 ) ; $ i ++ ) { $ path *= $ i ; $ path /= ( $ i - $ n + 1 ) ; } return $ path ; } { echo ( numberOfPaths ( 3 , 3 ) ) ; }
function maxSum ( $ arr , $ i , $ n ) { if ( $ i >= $ n ) return 0 ; if ( $ GLOBALS [ ' v ' ] [ $ i ] ) return $ GLOBALS [ ' dp ' ] [ $ i ] ; $ GLOBALS [ ' v ' ] [ $ i ] = 1 ; $ GLOBALS [ ' dp ' ] [ $ i ] = max ( maxSum ( $ arr , $ i + 1 , $ n ) , $ arr [ $ i ] + maxSum ( $ arr , $ i + 2 , $ n ) ) ; return $ GLOBALS [ ' dp ' ] [ $ i ] ; }
function maxLines ( $ n , $ x1 , $ y1 , $ x2 , $ y2 ) { $ s = array ( ) ; $ slope ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { if ( $ x1 [ $ i ] == $ x2 [ $ i ] ) $ slope = PHP_INT_MAX ; else $ slope = ( $ y2 [ $ i ] - $ y1 [ $ i ] ) * 1.0 / ( $ x2 [ $ i ] - $ x1 [ $ i ] ) * 1.0 ; array_push ( $ s , $ slope ) ; } return count ( $ s ) ; }
function findSum ( $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum += $ i * ( $ n - $ i ) ; return 2 * $ sum ; }
function areaOctagon ( $ side ) { return ( 2 * ( 1 + sqrt ( 2 ) ) * $ side * $ side ) ; }
function pairwiseDifference ( $ arr , $ n ) { $ diff = 0 ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { $ diff = abs ( $ arr [ $ i ] - $ arr [ $ i + 1 ] ) ; echo $ diff . " " ; } }
function minDiff ( $ n , $ x , $ A ) { $ mn = $ A [ 0 ] ; $ mx = $ A [ 0 ] ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { $ mn = min ( $ mn , $ A [ $ i ] ) ; $ mx = max ( $ mx , $ A [ $ i ] ) ; } return max ( 0 , $ mx - $ mn - 2 * $ x ) ; }
function findFirstMissing ( $ array , $ start , $ end ) { if ( $ start > $ end ) return $ end + 1 ; if ( $ start != $ array [ $ start ] ) return $ start ; $ mid = ( $ start + $ end ) / 2 ; if ( $ array [ $ mid ] == $ mid ) return findFirstMissing ( $ array , $ mid + 1 , $ end ) ; return findFirstMissing ( $ array , $ start , $ mid ) ; }
function solve ( $ idx , $ diff , $ N , $ M , $ K ) { global $ dp , $ MOD ; if ( $ idx > $ N ) { if ( $ diff == $ K ) return 1 ; return 0 ; } if ( $ dp [ $ idx ] [ $ diff ] != -1 ) return $ dp [ $ idx ] [ $ diff ] ; $ ans = solve ( $ idx + 1 , $ diff , $ N , $ M , $ K ) ; $ ans += ( $ M - 1 ) * solve ( $ idx + 1 , $ diff + 1 , $ N , $ M , $ K ) ; return $ dp [ $ idx ] [ $ diff ] = $ ans % $ MOD ; }
function minNum ( $ arr , $ n ) { $ odd = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] % 2 ) $ odd += 1 ; return ( $ odd % 2 ) ? 1 : 2 ; }
function encryptString ( $ str , $ n ) { $ i = 0 ; $ cnt = 0 ; $ encryptedStr = " " ; while ( $ i < $ n ) { $ cnt = $ i + 1 ; while ( $ cnt -- ) $ encryptedStr . = $ str [ $ i ] ; $ i ++ ; } return $ encryptedStr ; }
function calcFunction ( $ n , $ r ) { $ finalDenominator = 1 ; $ mx = max ( $ r , $ n - $ r ) ; for ( $ i = $ mx + 1 ; $ i <= $ n ; $ i ++ ) { $ denominator = pow ( $ i , $ i ) ; $ numerator = pow ( $ i - $ mx , $ i - $ mx ) ; $ finalDenominator = ( $ finalDenominator * $ denominator ) / $ numerator ; } return $ finalDenominator ; }
function maxSum ( $ a , $ n ) { $ ans = 0 ; $ arr = array ( ) ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ arr [ $ i ] = $ a [ $ i - 1 ] ; $ dp = array ( array ( ) ) ; for ( $ i = 1 ; $ i <= $ n ; ++ $ i ) { $ dp [ $ i ] [ 0 ] = max ( $ arr [ $ i ] , $ dp [ $ i - 1 ] [ 0 ] + $ arr [ $ i ] ) ; $ dp [ $ i ] [ 1 ] = max ( 0 , $ dp [ $ i - 1 ] [ 0 ] ) - $ arr [ $ i ] ; if ( $ i >= 2 ) $ dp [ $ i ] [ 1 ] = max ( $ dp [ $ i ] [ 1 ] , $ dp [ $ i - 1 ] [ 1 ] + $ arr [ $ i ] ) ; if ( $ i >= 2 ) $ dp [ $ i ] [ 2 ] = $ dp [ $ i - 1 ] [ 1 ] - $ arr [ $ i ] ; if ( $ i >= 3 ) $ dp [ $ i ] [ 2 ] = max ( $ dp [ $ i ] [ 2 ] , $ dp [ $ i - 1 ] [ 2 ] + $ arr [ $ i ] ) ; $ ans = max ( $ ans , $ dp [ $ i ] [ 0 ] ) ; $ ans = max ( $ ans , $ dp [ $ i ] [ 1 ] ) ; $ ans = max ( $ ans , $ dp [ $ i ] [ 2 ] ) ; } return $ ans ; }
function findAllSequence ( $ N ) { if ( $ N % 2 == 0 ) { return pow ( 2 , $ N / 2 + 1 ) + pow ( 2 , $ N / 2 ) - 2 ; } else { return pow ( 2 , ( $ N + 1 ) / 2 ) + pow ( 2 , ( $ N + 1 ) / 2 ) - 2 ; } }
function binarySearch ( $ arr , $ left , $ right ) { if ( $ left <= $ right ) { $ mid = ( $ left + $ right ) / 2 ; if ( $ arr [ $ mid - 1 ] < $ arr [ $ mid ] && $ arr [ $ mid ] > $ arr [ $ mid + 1 ] ) return $ mid ; if ( $ arr [ $ mid ] < $ arr [ $ mid + 1 ] ) return binarySearch ( $ arr , $ mid + 1 , $ right ) ; else return binarySearch ( $ arr , $ left , $ mid - 1 ) ; } return -1 ; }
function isDvisibleBy12 ( $ num ) { if ( strlen ( $ num ) >= 3 ) { $ d1 = ( int ) $ num [ strlen ( $ num ) - 1 ] ; if ( $ d1 % 2 != 0 ) return ( 0 ) ; $ d2 = ( int ) $ num [ strlen ( $ num ) - 2 ] ; $ sum = 0 ; for ( $ i = 0 ; $ i < strlen ( $ num ) ; $ i ++ ) $ sum += $ num [ $ i ] ; return ( $ sum % 3 == 0 && ( $ d2 * 10 + $ d1 ) % 4 == 0 ) ; } else { $ number = stoi ( $ num ) ; return ( $ number % 12 == 0 ) ; } }
function printPascal ( $ n ) { for ( $ line = 1 ; $ line <= $ n ; $ line ++ ) { $ C = 1 ; for ( $ i = 1 ; $ i <= $ line ; $ i ++ ) { print ( $ C . " " ) ; $ C = $ C * ( $ line - $ i ) / $ i ; } print ( " STRNEWLINE " ) ; } }
function square ( $ n ) { if ( $ n < 0 ) $ n = - $ n ; $ res = $ n ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ res += $ n ; return $ res ; }
function number_of_tower ( $ house , $ range , $ n ) { sort ( $ house ) ; $ numOfTower = 0 ; $ i = 0 ; while ( $ i < $ n ) { $ numOfTower ++ ; $ loc = $ house [ $ i ] + $ range ; while ( $ i < $ n && $ house [ $ i ] <= $ loc ) $ i ++ ; -- $ i ; $ loc = $ house [ $ i ] + $ range ; while ( $ i < $ n && $ house [ $ i ] <= $ loc ) $ i ++ ; } return $ numOfTower ; }
function reArrange ( $ words , $ n ) { $ freq = array ( ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ freq [ $ words [ $ i ] ] = ( $ i + 1 ) ; } sort ( $ words ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ freq [ $ words [ $ i ] ] , " ▁ " ; }
function rearrange ( & $ a , $ size ) { $ positive = 0 ; $ negative = 1 ; while ( true ) { while ( $ positive < $ size && $ a [ $ positive ] >= 0 ) $ positive += 2 ; while ( $ negative < $ size && $ a [ $ negative ] <= 0 ) $ negative += 2 ; if ( $ positive < $ size && $ negative < $ size ) { $ temp = $ a [ $ positive ] ; $ a [ $ positive ] = $ a [ $ negative ] ; $ a [ $ negative ] = $ temp ; } else break ; } }
function countDe ( $ arr , $ n ) { $ v = $ arr ; sort ( $ arr ) ; $ count1 = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] != $ v [ $ i ] ) $ count1 ++ ; rsort ( $ arr ) ; $ count2 = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] != $ v [ $ i ] ) $ count2 ++ ; return ( min ( $ count1 , $ count2 ) ) ; }
function SectorArea ( $ radius , $ angle ) { if ( $ angle >= 360 ) echo ( " Angle ▁ not ▁ possible " ) ; else { $ sector = ( ( 22 * $ radius * $ radius ) / 7 ) * ( $ angle / 360 ) ; echo ( $ sector ) ; } }
function results ( $ n , $ k ) { return round ( pow ( $ n , ( 1.0 / pow ( 2 , $ k ) ) ) ) ; }
function findRepeatFirstN2 ( $ s ) { $ p = -1 ; for ( $ i = 0 ; $ i < strlen ( $ s ) ; $ i ++ ) { for ( $ j = ( $ i + 1 ) ; $ j < strlen ( $ s ) ; $ j ++ ) { if ( $ s [ $ i ] == $ s [ $ j ] ) { $ p = $ i ; break ; } } if ( $ p != -1 ) break ; } return $ p ; }
function missingNumber ( $ arr1 , $ arr2 , $ n ) { $ mnum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ mnum = $ mnum ^ $ arr1 [ $ i ] ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) $ mnum = $ mnum ^ $ arr2 [ $ i ] ; return $ mnum ; }
function countSequences ( $ arr , $ n ) { $ count = 1 ; sort ( $ arr ) ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) if ( $ arr [ $ i ] + 1 != $ arr [ $ i + 1 ] ) $ count ++ ; return $ count ; }
function oddTriangularNumber ( $ N ) { return ( $ N * ( ( 2 * $ N ) - 1 ) ) ; }
function numberOfDistinct ( $ n ) { $ ans = 0 ; for ( $ i = 1 ; $ i <= sqrt ( $ n ) ; $ i ++ ) { if ( $ n % $ i == 0 ) { $ ans ++ ; if ( ( $ n / $ i ) != $ i ) $ ans ++ ; } } return $ ans ; }
function countBits ( $ number ) { return ( int ) ( log ( $ number ) / log ( 2 ) ) + 1 ; }
function countNumbers ( $ n ) { $ k = 0 ; $ count = 0 ; while ( $ n > 0 ) { if ( ( $ n & 1 ) == 0 ) $ count += pow ( 2 , $ k ) ; $ k += 1 ; $ n >>= 1 ; } return $ count ; }
function first ( $ str ) { for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) if ( ctype_upper ( $ str [ $ i ] ) ) { return $ str [ $ i ] ; } return 0 ; }
function center ( $ x1 , $ x2 , $ y1 , $ y2 ) { echo ( ( float ) ( $ x1 + $ x2 ) / 2 . " , ▁ " . ( float ) ( $ y1 + $ y2 ) / 2 ) ; }
function evenbinomialCoeffSum ( $ n ) { return ( 1 << ( $ n - 1 ) ) ; }
function multiply ( $ x , $ n ) { return $ x << $ n ; }
function Regions ( $ Vertices , $ Edges ) { $ R = $ Edges + 2 - $ Vertices ; return $ R ; }
function calculate ( $ n , $ power ) { $ sum = 0 ; $ bp = ( int ) pow ( $ n , $ power ) ; while ( $ bp != 0 ) { $ d = $ bp % 10 ; $ sum += $ d ; $ bp /= 10 ; } return $ sum ; }
function minimal ( $ a , $ n ) { $ lo = 0 ; $ hi = $ n - 1 ; while ( $ lo < $ hi ) { $ mid = ( $ lo + $ hi ) >> 1 ; if ( $ a [ $ mid ] < $ a [ $ mid + 1 ] ) { $ hi = $ mid ; } else { $ lo = $ mid + 1 ; } } return $ lo ; }
function fifthPowerSum ( $ n ) { return ( ( 2 * $ n * $ n * $ n * $ n * $ n * $ n ) + ( 6 * $ n * $ n * $ n * $ n * $ n ) + ( 5 * $ n * $ n * $ n * $ n ) - ( $ n * $ n ) ) / 12 ; }
function printTwoOdd ( $ arr , $ size ) { $ xor2 = $ arr [ 0 ] ; $ set_bit_no ; $ i ; $ n = $ size - 2 ; $ x = 0 ; $ y = 0 ; for ( $ i = 1 ; $ i < $ size ; $ i ++ ) $ xor2 = $ xor2 ^ $ arr [ $ i ] ; $ set_bit_no = $ xor2 & ~ ( $ xor2 - 1 ) ; for ( $ i = 0 ; $ i < $ size ; $ i ++ ) { if ( $ arr [ $ i ] & $ set_bit_no ) $ x = $ x ^ $ arr [ $ i ] ; else $ y = $ y ^ $ arr [ $ i ] ; } echo " The ▁ two ▁ ODD ▁ elements ▁ are ▁ " , $ x , " ▁ & ▁ " , $ y ; }
function minSum ( $ arr , $ n , $ x ) { $ sum = 0 ; $ largestDivisible = -1 ; $ minimum = $ arr [ 0 ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sum += $ arr [ $ i ] ; if ( $ arr [ $ i ] % $ x == 0 && $ largestDivisible < $ arr [ $ i ] ) $ largestDivisible = $ arr [ $ i ] ; if ( $ arr [ $ i ] < $ minimum ) $ minimum = $ arr [ $ i ] ; } if ( $ largestDivisible == -1 ) return $ sum ; $ sumAfterOperation = $ sum - $ minimum - $ largestDivisible + ( $ x * $ minimum ) + ( $ largestDivisible / $ x ) ; return min ( $ sum , $ sumAfterOperation ) ; }
function sum_of_series ( $ n ) { $ result = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { if ( $ i % 2 == 0 ) $ result = $ result - pow ( $ i , 2 ) ; else $ result = $ result + pow ( $ i , 2 ) ; } return $ result ; }
function FirstRepeated ( $ str ) { $ checker = 0 ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; ++ $ i ) { $ val = ( ord ( $ str [ $ i ] ) - ord ( ' a ' ) ) ; if ( ( $ checker & ( 1 << $ val ) ) > 0 ) return $ i ; $ checker |= ( 1 << $ val ) ; } return -1 ; }
function findMaxGuests ( $ arrl , $ exit , $ n ) { sort ( $ arrl ) ; sort ( $ exit ) ; $ guests_in = 1 ; $ max_guests = 1 ; $ time = $ arrl [ 0 ] ; $ i = 1 ; $ j = 0 ; while ( $ i < $ n and $ j < $ n ) { if ( $ arrl [ $ i ] <= $ exit [ $ j ] ) { $ guests_in ++ ; if ( $ guests_in > $ max_guests ) { $ max_guests = $ guests_in ; $ time = $ arrl [ $ i ] ; } $ i ++ ; } else { $ guests_in -- ; $ j ++ ; } } echo " Maximum ▁ Number ▁ of ▁ Guests ▁ = ▁ " , $ max_guests , " ▁ at ▁ time ▁ " , $ time ; }
function numberofways ( $ n , $ m ) { global $ MAX ; $ dp = array_fill ( 0 , $ n + 2 , array_fill ( 0 , $ n + 2 , NULL ) ) ; $ dp [ 0 ] [ $ n + 1 ] = 1 ; for ( $ k = $ n ; $ k >= $ m ; $ k -- ) { for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) { $ dp [ $ i ] [ $ k ] = $ dp [ $ i ] [ $ k + 1 ] ; if ( $ i - $ k >= 0 ) $ dp [ $ i ] [ $ k ] = ( $ dp [ $ i ] [ $ k ] + $ dp [ $ i - $ k ] [ $ k ] ) ; } } return $ dp [ $ n ] [ $ m ] ; }
function series ( $ n ) { return ( 8 * $ n * $ n ) + 1 ; }
function find ( $ p ) { return ceil ( sqrt ( 2 * 365 * log ( 1 / ( 1 - $ p ) ) ) ) ; }
function CalculateMax ( $ arr , $ n ) { sort ( $ arr ) ; $ min_sum = $ arr [ 0 ] + $ arr [ 1 ] ; $ max_sum = $ arr [ $ n - 1 ] + $ arr [ $ n - 2 ] ; return abs ( $ max_sum - $ min_sum ) ; }
function updateString ( $ S , $ A , $ B ) { $ l = strlen ( $ A ) ; for ( $ i = 0 ; $ i + $ l <= strlen ( $ S ) ; $ i ++ ) { $ curr = substr ( $ S , $ i , $ i + $ l ) ; if ( strcmp ( $ curr , $ A ) == 0 ) { $ new_string = substr ( $ S , 0 , $ i ) . $ B . substr ( $ S , $ i + $ l , strlen ( $ S ) ) ; $ S = $ new_string ; $ i += $ l - 1 ; } else { $ new_string = substr ( $ S , 0 , $ i ) . $ A . substr ( $ S , $ i + $ l , strlen ( $ S ) ) ; $ S = $ new_string ; $ i += $ l - 1 ; } } return $ S ; }
function MinimumMail ( $ n , $ k , $ x ) { $ m = ( $ n - 1 ) + ceil ( ( $ n - 1 ) * 1.0 / $ x ) * ( $ n - 1 ) + ceil ( $ n * 1.0 / $ x ) * ( $ k - $ n ) ; return $ m ; }
function countPairs ( $ N ) { $ count = 0 ; for ( $ i = 1 ; $ i <= ( int ) pow ( $ N , 1 / 3 ) ; $ i ++ ) { $ cb = $ i * $ i * $ i ; $ diff = ( $ N - $ cb ) ; $ cbrtDiff = ( int ) pow ( $ diff , 1 / 3 ) ; if ( $ cbrtDiff * $ cbrtDiff * $ cbrtDiff == $ diff ) $ count ++ ; } return $ count ; }
function pendulumArrangement ( $ arr , $ n ) { sort ( $ arr , $ n ) ; sort ( $ arr ) ; $ op [ $ n ] = NULL ; $ mid = floor ( ( $ n - 1 ) / 2 ) ; $ j = 1 ; $ i = 1 ; $ op [ $ mid ] = $ arr [ 0 ] ; for ( $ i = 1 ; $ i <= $ mid ; $ i ++ ) { $ op [ $ mid + $ i ] = $ arr [ $ j ++ ] ; $ op [ $ mid - $ i ] = $ arr [ $ j ++ ] ; } if ( $ n % 2 == 0 ) $ op [ $ mid + $ i ] = $ arr [ $ j ] ; echo " Pendulum ▁ arrangement : " ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ op [ $ i ] , " ▁ " ; echo " STRNEWLINE " ; }
function countDigit ( $ n ) { $ temp = $ n ; $ count = 0 ; while ( $ temp != 0 ) { $ d = $ temp % 10 ; $ temp /= 10 ; if ( $ d > 0 && $ n % $ d == 0 ) $ count ++ ; } return $ count ; }
function sum ( $ n ) { return $ n * ( $ n + 1 ) * ( $ n + 2 ) / 3 ; }
function maxLength ( $ s , $ n ) { $ dp = array_fill ( 0 , $ n , array_fill ( 0 , $ n , NULL ) ) ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) if ( $ s [ $ i ] == ' ( ' && $ s [ $ i + 1 ] == ' ) ' ) $ dp [ $ i ] [ $ i + 1 ] = 2 ; for ( $ l = 2 ; $ l < $ n ; $ l ++ ) { for ( $ i = 0 , $ j = $ l ; $ j < $ n ; $ i ++ , $ j ++ ) { if ( $ s [ $ i ] == ' ( ' && $ s [ $ j ] == ' ) ' ) $ dp [ $ i ] [ $ j ] = 2 + $ dp [ $ i + 1 ] [ $ j - 1 ] ; for ( $ k = $ i ; $ k < $ j ; $ k ++ ) $ dp [ $ i ] [ $ j ] = max ( $ dp [ $ i ] [ $ j ] , $ dp [ $ i ] [ $ k ] + $ dp [ $ k + 1 ] [ $ j ] ) ; } } return $ dp [ 0 ] [ $ n - 1 ] ; }
function countRotations ( $ arr , $ low , $ high ) { if ( $ high < $ low ) return 0 ; if ( $ high == $ low ) return $ low ; $ mid = $ low + ( $ high - $ low ) / 2 ; if ( $ mid < $ high && $ arr [ $ mid + 1 ] < $ arr [ $ mid ] ) return ( int ) ( $ mid + 1 ) ; if ( $ mid > $ low && $ arr [ $ mid ] < $ arr [ $ mid - 1 ] ) return ( int ) ( $ mid ) ; if ( $ arr [ $ high ] > $ arr [ $ mid ] ) return countRotations ( $ arr , $ low , $ mid - 1 ) ; return countRotations ( $ arr , $ mid + 1 , $ high ) ; }
function findKthGoodNo ( $ n ) { $ lastDig = $ n % 10 ; if ( $ lastDig >= 0 && $ lastDig <= 4 ) return $ n << 1 ; else return ( $ n << 1 ) + 1 ; }
function countBT ( $ h ) { global $ mod ; $ dp [ 0 ] = $ dp [ 1 ] = 1 ; for ( $ i = 2 ; $ i <= $ h ; $ i ++ ) { $ dp [ $ i ] = ( $ dp [ $ i - 1 ] * ( ( 2 * $ dp [ $ i - 2 ] ) % $ mod + $ dp [ $ i - 1 ] ) % $ mod ) % $ mod ; } return $ dp [ $ h ] ; }
function pythagorean_quadruple ( $ a , $ b , $ c , $ d ) { $ sum = $ a * $ a + $ b * $ b + $ c * $ c ; if ( $ d * $ d == $ sum ) return true ; else return false ; }
function search ( $ pat , $ txt ) { $ M = strlen ( $ pat ) ; $ N = strlen ( $ txt ) ; $ i = 0 ; while ( $ i <= $ N - $ M ) { $ j ; for ( $ j = 0 ; $ j < $ M ; $ j ++ ) if ( $ txt [ $ i + $ j ] != $ pat [ $ j ] ) break ; if ( $ j == $ M ) { echo ( " Pattern ▁ found ▁ at ▁ index ▁ $ i " . " STRNEWLINE " ) ; $ i = $ i + $ M ; } else if ( $ j == 0 ) $ i = $ i + 1 ; else $ i = $ i + $ j ; } }
function countChar ( $ str ) { $ n = strlen ( $ str ) ; if ( $ n <= 2 ) return $ n ; $ count = 2 ; for ( $ i = 1 ; $ i < $ n - 1 ; $ i ++ ) if ( $ str [ $ i - 1 ] == $ str [ $ i + 1 ] ) $ count ++ ; return $ count ; }
function calculateLeaps ( $ n ) { if ( $ n == 0 $ n == 1 ) { return 1 ; } else { $ leaps = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ leaps += calculateLeaps ( $ i ) ; return $ leaps ; } }
function minCost ( $ A , $ n ) { $ cost = 0 ; sort ( $ A ) ; $ K = $ A [ $ n / 2 ] ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) $ cost += abs ( $ A [ $ i ] - $ K ) ; if ( $ n % 2 == 0 ) { $ tempCost = 0 ; $ K = $ A [ ( $ n / 2 ) - 1 ] ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) $ tempCost += abs ( $ A [ $ i ] - $ K ) ; $ cost = min ( $ cost , $ tempCost ) ; } return $ cost ; }
function LongestSubarray ( $ arr , $ n , $ k ) { $ cnt = 1 ; $ max_length = 1 ; $ prev_mod = $ arr [ 0 ] % $ k ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ curr_mod = $ arr [ $ i ] % $ k ; if ( $ curr_mod == $ prev_mod ) { $ cnt ++ ; } else { $ max_length = max ( $ max_length , $ cnt ) ; $ cnt = 1 ; $ prev_mod = $ curr_mod ; } } return max ( $ max_length , $ cnt ) ; }
function Race ( $ B , $ C ) { $ result = 0 ; $ result = ( ( $ C * 100 ) / $ B ) ; return 100 - $ result ; }
function nthPalindrome ( $ n , $ k ) { $ temp = ( $ k & 1 ) ? ( int ) ( $ k / 2 ) : ( int ) ( $ k / 2 - 1 ) ; $ palindrome = ( int ) pow ( 10 , $ temp ) ; $ palindrome += $ n - 1 ; print ( $ palindrome ) ; if ( $ k & 1 ) $ palindrome = ( int ) ( $ palindrome / 10 ) ; while ( $ palindrome > 0 ) { print ( $ palindrome % 10 ) ; $ palindrome = ( int ) ( $ palindrome / 10 ) ; } print ( " STRNEWLINE " ) ; }
function getMaxNum ( $ a , $ b , $ c ) { if ( $ b % $ c == 0 ) return $ b ; $ x = ( ( int ) ( $ b / $ c ) * $ c ) ; if ( $ x >= $ a && $ x <= $ b ) return $ x ; else return -1 ; }
function FindMinimumCost ( $ ind , $ a , $ n , $ k , $ dp ) { if ( $ ind == ( $ n - 1 ) ) return 0 ; else if ( $ dp [ $ ind ] != -1 ) return $ dp [ $ ind ] ; else { $ ans = PHP_INT_MAX ; for ( $ i = 1 ; $ i <= $ k ; $ i ++ ) { if ( $ ind + $ i < $ n ) $ ans = min ( $ ans , abs ( $ a [ $ ind + $ i ] - $ a [ $ ind ] ) + FindMinimumCost ( $ ind + $ i , $ a , $ n , $ k , $ dp ) ) ; else break ; } return $ dp [ $ ind ] = $ ans ; } }
function Sum_upto_nth_Term ( $ n ) { $ r = $ n * ( $ n + 1 ) * ( 2 * $ n + 7 ) / 3 ; echo $ r ; }
function minRotation ( $ input , $ unlock_code ) { $ rotation = 0 ; $ input_digit ; $ code_digit ; while ( $ input $ unlock_code ) { $ input_digit = $ input % 10 ; $ code_digit = $ unlock_code % 10 ; $ rotation += min ( abs ( $ input_digit - $ code_digit ) , 10 - abs ( $ input_digit - $ code_digit ) ) ; $ input /= 10 ; $ unlock_code /= 10 ; } return $ rotation ; }
function sumSquare ( int $ n ) { for ( $ i = 1 ; $ i * $ i <= $ n ; $ i ++ ) for ( $ j = 1 ; $ j * $ j <= $ n ; $ j ++ ) if ( $ i * $ i + $ j * $ j == $ n ) { echo $ i , " ^ 2 ▁ + ▁ " , $ j , " ^ 2" ; return true ; } return false ; }
function solve ( $ i , $ par , & $ a , $ n , $ k , $ current_ans ) { global $ inf , $ ans ; if ( $ par > $ k ) return ; if ( $ par == $ k && $ i == $ n - 1 ) { $ ans = min ( $ ans , $ current_ans ) ; return ; } for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) solve ( $ j , $ par + 1 , $ a , $ n , $ k , $ current_ans + ( $ a [ $ j ] - $ a [ $ i + 1 ] ) * ( $ a [ $ j ] - $ a [ $ i + 1 ] ) ) ; }
function calculate ( $ s ) { $ ans = 6 ; for ( $ i = 0 ; $ i < 10 ; ++ $ i ) { for ( $ j = 0 ; $ j < 10 ; ++ $ j ) { for ( $ k = 0 ; $ k < 10 ; ++ $ k ) { for ( $ l = 0 ; $ l < 10 ; ++ $ l ) { for ( $ m = 0 ; $ m < 10 ; ++ $ m ) { for ( $ n = 0 ; $ n < 10 ; ++ $ n ) { if ( $ i + $ j + $ k == $ l + $ m + $ n ) { $ c = 0 ; if ( $ i != $ s [ 0 ] - '0' ) $ c ++ ; if ( $ j != $ s [ 1 ] - '0' ) $ c ++ ; if ( $ k != $ s [ 2 ] - '0' ) $ c ++ ; if ( $ l != $ s [ 3 ] - '0' ) $ c ++ ; if ( $ m != $ s [ 4 ] - '0' ) $ c ++ ; if ( $ n != $ s [ 5 ] - '0' ) $ c ++ ; if ( $ c < $ ans ) $ ans = $ c ; } } } } } } } return $ ans ; }
function number_of_tower ( $ house , $ range , $ n ) { sort ( $ house ) ; $ numOfTower = 0 ; $ i = 0 ; while ( $ i < $ n ) { $ numOfTower ++ ; $ loc = $ house [ $ i ] + $ range ; while ( $ i < $ n && $ house [ $ i ] <= $ loc ) $ i ++ ; -- $ i ; $ loc = $ house [ $ i ] + $ range ; while ( $ i < $ n && $ house [ $ i ] <= $ loc ) $ i ++ ; } return $ numOfTower ; }
function getOddOccurrence ( & $ arr , $ arr_size ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ arr_size ; $ i ++ ) { for ( $ j = 0 ; $ j < $ arr_size ; $ j ++ ) { if ( $ arr [ $ i ] == $ arr [ $ j ] ) $ count ++ ; } if ( $ count % 2 != 0 ) return $ arr [ $ i ] ; } return -1 ; }
function day_of_the_week ( $ y , $ m , $ d ) { $ t = array ( 0 , 3 , 2 , 5 , 0 , 3 , 5 , 1 , 4 , 6 , 2 , 4 ) ; if ( $ m < 3 ) $ y -= 1 ; return ( ( $ y + $ y / 4 - $ y / 100 + $ y / 400 + $ t [ $ m - 1 ] + $ d ) % 7 ) ; }
function countDistinct ( $ arr , $ n ) { $ s = array ( ) ; $ res = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { array_push ( $ s , $ arr [ $ i ] ) ; } $ s = array_unique ( $ s ) ; return count ( $ s ) ; }
function isLowerTriangularMatrix ( $ mat ) { global $ N ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ N ; $ j ++ ) if ( $ mat [ $ i ] [ $ j ] != 0 ) return false ; return true ; }
function summation ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ sum += ( $ i * $ i ) ; return $ sum ; }
function findNum ( $ N , $ K ) { $ rem = $ N % $ K ; if ( $ rem == 0 ) return $ N ; else return $ N - $ rem ; }
