ll calculate ( ll a [ ] , ll n ) { sort ( a , a + n ) ; vector < ll > s ; for ( int i = 0 , j = n - 1 ; i < j ; i ++ , j -- ) s . push_back ( a [ i ] + a [ j ] ) ; ll mini = * min_element ( s . begin ( ) , s . end ( ) ) ; ll maxi = * max_element ( s . begin ( ) , s . end ( ) ) ; return abs ( maxi - mini ) ; }
float cyl ( float r , float h ) { if ( r < 0 && h < 0 ) return -1 ; float R = ( 2 * r ) / 3 ; float H = ( 2 * h ) / 3 ; float V = 3.14 * pow ( R , 2 ) * H ; return V ; }
void printTwoSetBitNums ( int n ) { int x = 1 ; while ( n > 0 ) { int y = 0 ; while ( y < x ) { cout << ( 1 << x ) + ( 1 << y ) << " ▁ " ; n -- ; if ( n == 0 ) return ; y ++ ; } x ++ ; } }
int minNumber ( int a [ ] , int n , int x ) { int l = 0 , h = 0 , e = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == x ) e ++ ; else if ( a [ i ] > x ) h ++ ; else if ( a [ i ] < x ) l ++ ; } int ans = 0 ; if ( l > h ) ans = l - h ; else if ( l < h ) ans = h - l - 1 ; return ans + 1 - e ; }
void printKthBit ( unsigned int n , unsigned int k ) { cout << ( ( n & ( 1 << ( k - 1 ) ) ) >> ( k - 1 ) ) ; }
int equilibrium ( int arr [ ] , int n ) { int sum = 0 ; int leftsum = 0 ; for ( int i = 0 ; i < n ; ++ i ) sum += arr [ i ] ; for ( int i = 0 ; i < n ; ++ i ) { sum -= arr [ i ] ; if ( leftsum == sum ) return i ; leftsum += arr [ i ] ; } return -1 ; }
long countRhombi ( int h , int w ) { long long ct = 0 ; for ( int i = 2 ; i <= h ; i += 2 ) for ( int j = 2 ; j <= w ; j += 2 ) ct += ( h - i + 1 ) * ( w - j + 1 ) ; return ct ; }
int sumofoddFactors ( int n ) { int res = 1 ; while ( n % 2 == 0 ) n = n / 2 ; for ( int i = 3 ; i <= sqrt ( n ) ; i ++ ) { int count = 0 , curr_sum = 1 ; int curr_term = 1 ; while ( n % i == 0 ) { count ++ ; n = n / i ; curr_term *= i ; curr_sum += curr_term ; } res *= curr_sum ; } if ( n >= 2 ) res *= ( 1 + n ) ; return res ; }
bool isPower ( unsigned int n ) { for ( int x = 2 ; x <= sqrt ( n ) ; x ++ ) { float f = log ( n ) / log ( x ) ; if ( ( f - ( int ) f ) == 0.0 ) return true ; } return false ; }
int sumOfSeries ( int n ) { return n * ( n + 1 ) * ( 6 * n * n * n + 9 * n * n + n - 1 ) / 30 ; }
double sum ( int n ) { double i , s = 0.0 ; for ( i = 1 ; i <= n ; i ++ ) s = s + 1 / i ; return s ; }
int countRect ( int n ) { int ans = 0 ; for ( int length = 1 ; length <= sqrt ( n ) ; ++ length ) for ( int height = length ; height * length <= n ; ++ height ) ans ++ ; return ans ; }
bool isSquareFree ( int n ) { if ( n % 2 == 0 ) n = n / 2 ; if ( n % 2 == 0 ) return false ; for ( int i = 3 ; i <= sqrt ( n ) ; i = i + 2 ) { if ( n % i == 0 ) { n = n / i ; if ( n % i == 0 ) return false ; } } return true ; }
void constructXOR ( int A [ ] , int n ) { int XOR = 0 ; for ( int i = 0 ; i < n ; i ++ ) XOR ^= A [ i ] ; for ( int i = 0 ; i < n ; i ++ ) A [ i ] = XOR ^ A [ i ] ; }
int maxArea ( float perimeter ) { int length = ( int ) ceil ( perimeter / 4 ) ; int breadth = ( int ) floor ( perimeter / 4 ) ; return length * breadth ; }
bool isPowerOfK ( unsigned int n , unsigned int k ) { bool oneSeen = false ; while ( n > 0 ) { int digit = n % k ; if ( digit > 1 ) return false ; if ( digit == 1 ) { if ( oneSeen ) return false ; oneSeen = true ; } n /= k ; } return true ; }
float ReuleauxArea ( float a ) { if ( a < 0 ) return -1 ; float A = 0.70477 * pow ( a , 2 ) ; return A ; }
float squareArea ( float a ) { if ( a < 0 ) return -1 ; float area = pow ( 1.268 , 2 ) * pow ( a , 2 ) ; return area ; }
void cal_cos ( float n ) { float accuracy = 0.0001 , x1 , denominator , cosx , cosval ; n = n * ( 3.142 / 180.0 ) ; x1 = 1 ; cosx = x1 ; cosval = cos ( n ) ; int i = 1 ; do { denominator = 2 * i * ( 2 * i - 1 ) ; x1 = - x1 * n * n / denominator ; cosx = cosx + x1 ; i = i + 1 ; } while ( accuracy <= fabs ( cosval - cosx ) ) ; cout << cosx ; }
int divisorSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j * j <= i ; ++ j ) { if ( i % j == 0 ) { if ( i / j == j ) sum += j ; else sum += j + i / j ; } } } return sum ; }
int hexadecagonalNum ( long int n ) { return ( ( 14 * n * n ) - 12 * n ) / 2 ; }
int minValue ( int n , int x , int y ) { float val = ( y * n ) / 100 ; if ( x >= val ) return 0 ; else return ( ceil ( val ) - x ) ; }
void middlesum ( int mat [ ] [ MAX ] , int n ) { int row_sum = 0 , col_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) row_sum += mat [ n / 2 ] [ i ] ; cout << " Sum ▁ of ▁ middle ▁ row ▁ = ▁ " << row_sum << endl ; for ( int i = 0 ; i < n ; i ++ ) col_sum += mat [ i ] [ n / 2 ] ; cout << " Sum ▁ of ▁ middle ▁ column ▁ = ▁ " << col_sum ; }
void printBalancedExpression ( int a , int b , int c , int d ) { if ( ( a == d && a ) || ( a == 0 && c == 0 && d == 0 ) ) { for ( int i = 1 ; i <= a ; i ++ ) cout << " ( ( " ; for ( int i = 1 ; i <= c ; i ++ ) cout << " ) ( " ; for ( int i = 1 ; i <= d ; i ++ ) cout << " ) ) " ; for ( int i = 1 ; i <= b ; i ++ ) cout << " ( ) " ; } else cout << -1 ; }
bool judgeSquareSum ( int n ) { for ( int i = 2 ; i * i <= n ; i ++ ) { int count = 0 ; if ( n % i == 0 ) { while ( n % i == 0 ) { count ++ ; n /= i ; } if ( i % 4 == 3 && count % 2 != 0 ) return false ; } } return n % 4 != 3 ; }
int highestPowerOf2 ( int n ) { return ( n & ( ~ ( n - 1 ) ) ) ; }
void printMaxSum ( int arr [ ] , int n ) { int dp [ n ] ; memset ( dp , 0 , sizeof dp ) ; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] = arr [ i ] ; int maxi = 0 ; for ( int j = 1 ; j <= sqrt ( i + 1 ) ; j ++ ) { if ( ( ( i + 1 ) % j == 0 ) && ( i + 1 ) != j ) { if ( dp [ j - 1 ] > maxi ) maxi = dp [ j - 1 ] ; if ( dp [ ( i + 1 ) / j - 1 ] > maxi && j != 1 ) maxi = dp [ ( i + 1 ) / j - 1 ] ; } } dp [ i ] += maxi ; } for ( int i = 0 ; i < n ; i ++ ) cout << dp [ i ] << " ▁ " ; }
bool isInGivenBase ( string str , int base ) { if ( base > 16 ) return false ; else if ( base <= 10 ) { for ( int i = 0 ; i < str . length ( ) ; i ++ ) if ( ! ( str [ i ] >= '0' and str [ i ] < ( '0' + base ) ) ) return false ; } else { for ( int i = 0 ; i < str . length ( ) ; i ++ ) if ( ! ( ( str [ i ] >= '0' && str [ i ] < ( '0' + base ) ) || ( str [ i ] >= ' A ' && str [ i ] < ( ' A ' + base - 10 ) ) ) ) return false ; } return true ; }
void convert ( string str ) { int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( str . at ( i ) == ' ▁ ' ) str . at ( i ) = ' _ ' ; else str . at ( i ) = tolower ( str . at ( i ) ) ; } cout << str ; }
int hammingDistance ( int n1 , int n2 ) { int x = n1 ^ n2 ; int setBits = 0 ; while ( x > 0 ) { setBits += x & 1 ; x >>= 1 ; } return setBits ; }
int round ( int n ) { int a = ( n / 10 ) * 10 ; int b = a + 10 ; return ( n - a > b - n ) ? b : a ; }
int absSumDidd ( int a [ ] , int n ) { sort ( a , a + n ) ; int midValue = a [ ( int ) ( n / 2 ) ] ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + abs ( a [ i ] - midValue ) ; } return sum ; }
int sumN ( int n ) { n = ( n + 1 ) / 2 ; return ( n * n ) ; }
int getPairsCount ( int arr [ ] , int n , int sum ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] + arr [ j ] == sum ) count ++ ; return count ; }
void bin ( unsigned n ) { if ( n > 1 ) bin ( n >> 1 ) ; printf ( " % d " , n & 1 ) ; }
int countSetBits ( unsigned int n ) { unsigned int count = 0 ; while ( n ) { count += n & 1 ; n >>= 1 ; } return count ; }
bool findNature ( int a , int b , int n ) { if ( n == 0 ) return ( a & 1 ) ; if ( n == 1 ) return ( b & 1 ) ; if ( ! ( a & 1 ) ) { if ( ! ( b & 1 ) ) return false ; else return ( n % 3 != 0 ) ; } else { if ( ! ( b & 1 ) ) return ( ( n - 1 ) % 3 != 0 ) ; else return ( ( n + 1 ) % 3 != 0 ) ; } }
string getCount ( int N ) { if ( N % 2 == 1 ) return 0 ; string result = "9" ; for ( int i = 1 ; i <= N / 2 - 1 ; i ++ ) result += "0" ; return result ; }
int longOddEvenIncSeq ( int arr [ ] , int n ) { int lioes [ n ] ; int maxLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) lioes [ i ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && ( arr [ i ] + arr [ j ] ) % 2 != 0 && lioes [ i ] < lioes [ j ] + 1 ) lioes [ i ] = lioes [ j ] + 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( maxLen < lioes [ i ] ) maxLen = lioes [ i ] ; return maxLen ; }
void rad ( double d , double h ) { cout << " The ▁ radius ▁ of ▁ the ▁ circle ▁ is ▁ " << ( ( d * d ) / ( 8 * h ) + h / 2 ) << endl ; }
void printAllAPTriplets ( int arr [ ] , int n ) { unordered_set < int > s ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int diff = arr [ j ] - arr [ i ] ; if ( s . find ( arr [ i ] - diff ) != s . end ( ) ) cout << arr [ i ] - diff << " ▁ " << arr [ i ] << " ▁ " << arr [ j ] << endl ; } s . insert ( arr [ i ] ) ; } }
float sumOfSeries ( int x , int k ) { return ( float ( x ) / 81 ) * ( 9 * k - 1 + pow ( 10 , ( -1 ) * k ) ) ; }
int binaryToDecimal ( int n ) { int num = n ; int dec_value = 0 ; int base = 1 ; int temp = num ; while ( temp ) { int last_digit = temp % 10 ; temp = temp / 10 ; dec_value += last_digit * base ; base = base * 2 ; } return dec_value ; }
int nobleInteger ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) continue ; if ( arr [ i ] == n - i - 1 ) return arr [ i ] ; } if ( arr [ n - 1 ] == 0 ) return arr [ n - 1 ] ; return -1 ; }
int pad ( int n ) { int pPrevPrev = 1 , pPrev = 1 , pCurr = 1 , pNext = 1 ; for ( int i = 3 ; i <= n ; i ++ ) { pNext = pPrevPrev + pPrev ; pPrevPrev = pPrev ; pPrev = pCurr ; pCurr = pNext ; } return pNext ; }
void findSubsequence ( string str , int k ) { int a [ MAX_CHAR ] = { 0 } ; for ( int i = 0 ; i < str . size ( ) ; i ++ ) a [ str [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < l ; i ++ ) if ( a [ str [ i ] - ' a ' ] >= k ) cout << str [ i ] ; }
int count_square ( int n ) { int count = 0 ; for ( int i = 1 ; i <= n ; i = i + 2 ) { int k = n - i + 1 ; count += ( k * k ) ; } return count ; }
int countTriplets ( int arr [ ] , int n , int m ) { int count = 0 ; sort ( arr , arr + n ) ; int end , start , mid ; for ( end = n - 1 ; end >= 2 ; end -- ) { int start = 0 , mid = end - 1 ; while ( start < mid ) { long int prod = arr [ end ] * arr [ start ] * arr [ mid ] ; if ( prod > m ) mid -- ; else if ( prod < m ) start ++ ; else if ( prod == m ) { count ++ ; mid -- ; start ++ ; } } } return count ; }
double calculateArea ( int x , int y ) { double pi = 3.1415926536 ; double arx = pi * x * x ; double ary = pi * y * y ; return arx - ary ; }
void maxMin ( int arr [ ] [ MAX ] , int n ) { int min = INT_MAX ; int max = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j <= n / 2 ; j ++ ) { if ( arr [ i ] [ j ] > arr [ i ] [ n - j - 1 ] ) { if ( min > arr [ i ] [ n - j - 1 ] ) min = arr [ i ] [ n - j - 1 ] ; if ( max < arr [ i ] [ j ] ) max = arr [ i ] [ j ] ; } else { if ( min > arr [ i ] [ j ] ) min = arr [ i ] [ j ] ; if ( max < arr [ i ] [ n - j - 1 ] ) max = arr [ i ] [ n - j - 1 ] ; } } } cout << " Maximum ▁ = ▁ " << max << " , ▁ Minimum ▁ = ▁ " << min ; }
bool checkFittingArrays ( int A [ ] , int B [ ] , int N ) { sort ( A , A + N ) ; sort ( B , B + N ) ; for ( int i = 0 ; i < N ; i ++ ) if ( A [ i ] > B [ i ] ) return false ; return true ; }
int printTrib ( int n ) { int dp [ n ] ; dp [ 0 ] = dp [ 1 ] = 0 ; dp [ 2 ] = 1 ; for ( int i = 3 ; i < n ; i ++ ) dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] + dp [ i - 3 ] ; for ( int i = 0 ; i < n ; i ++ ) cout << dp [ i ] << " ▁ " ; }
bool isUnique ( int a [ ] , int n , int k ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += a [ i ] ; sum += n - 1 ; return ( sum == k ) ; }
int nthTerm ( int n ) { return 2 * pow ( n , 2 ) + 4 * n - 2 ; }
void printSquares ( int n ) { int square = 0 , odd = 1 ; for ( int x = 0 ; x < n ; x ++ ) { cout << square << " ▁ " ; square = square + odd ; odd = odd + 2 ; } }
int pentagon_pyramidal ( int n ) { return n * n * ( n + 1 ) / 2 ; }
int oddEquivalent ( string s , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == '1' ) count ++ ; } return count ; }
int countWays ( int index , int cnt , int dp [ ] [ max ] , int n , int m , int k ) { if ( index == n ) { if ( cnt == k ) return 1 ; else return 0 ; } if ( dp [ index ] [ cnt ] != -1 ) return dp [ index ] [ cnt ] ; int ans = 0 ; ans += countWays ( index + 1 , cnt , dp , n , m , k ) ; ans += ( m - 1 ) * countWays ( index + 1 , cnt + 1 , dp , n , m , k ) ; return dp [ index ] [ cnt ] = ans ; }
float polyarea ( float n , float a ) { if ( a < 0 && n < 0 ) return -1 ; float A = ( a * a * n ) / ( 4 * tan ( ( 180 / n ) * 3.14159 / 180 ) ) ; return A ; }
int countSol ( int coeff [ ] , int start , int end , int rhs ) { if ( rhs == 0 ) return 1 ; int result = 0 ; for ( int i = start ; i <= end ; i ++ ) if ( coeff [ i ] <= rhs ) result += countSol ( coeff , i , end , rhs - coeff [ i ] ) ; return result ; }
int findMaximumPieces ( int n ) { int x = n / 2 ; return ( ( x + 1 ) * ( n - x + 1 ) ) ; }
int nthTerm ( int n ) { return 6 * pow ( n , 2 ) - 4 * n - 2 ; }
bool isSurd ( int n ) { for ( int i = 2 ; i * i <= n ; i ++ ) { int j = i ; while ( j < n ) j = j * i ; if ( j == n ) return false ; } return true ; }
void swap ( int a , int b , int c , int d ) { a = a + b ; b = a - b ; a = a - b ; b = b + c ; c = b - c ; b = b - c ; c = c + d ; d = c - d ; c = c - d ; cout << " values ▁ after ▁ swapping ▁ are ▁ : ▁ " << endl ; cout << " a ▁ = ▁ " << a << endl ; cout << " b ▁ = ▁ " << b << endl ; cout << " c ▁ = ▁ " << c << endl ; cout << " d ▁ = ▁ " << d << endl ; }
bool checkPronic ( int x ) { for ( int i = 0 ; i <= ( int ) ( sqrt ( x ) ) ; i ++ ) if ( x == i * ( i + 1 ) ) return true ; return false ; }
int FindMaxSum ( vector < int > arr , int n ) { int incl = arr [ 0 ] ; int excl = 0 ; int excl_new ; int i ; for ( i = 1 ; i < n ; i ++ ) { excl_new = ( incl > excl ) ? incl : excl ; incl = excl + arr [ i ] ; excl = excl_new ; } return ( ( incl > excl ) ? incl : excl ) ; }
int maxGameByWinner ( int N ) { int dp [ N ] ; dp [ 0 ] = 1 ; dp [ 1 ] = 2 ; int i = 2 ; do { dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] ; } while ( dp [ i ++ ] <= N ) ; return ( i - 2 ) ; }
float Area ( float r ) { if ( r < 0 ) return -1 ; float x = ( 2 * r ) / sqrt ( 5 ) ; float A = 0.70477 * pow ( x , 2 ) ; return A ; }
int findAnswer ( int X , int N ) { return ( N - 1 ) * 9 + X ; }
bool checkPandigital ( int b , char n [ ] ) { if ( strlen ( n ) < b ) return false ; bool hash [ b ] ; memset ( hash , false , sizeof ( hash ) ) ; for ( int i = 0 ; i < strlen ( n ) ; i ++ ) { if ( n [ i ] >= '0' && n [ i ] <= '9' ) hash [ n [ i ] - '0' ] = true ; else if ( n [ i ] - ' A ' <= b - 11 ) hash [ n [ i ] - ' A ' + 10 ] = true ; } for ( int i = 0 ; i < b ; i ++ ) if ( hash [ i ] == false ) return false ; return true ; }
int maxSumIS ( int arr [ ] , int n ) { int i , j , max = 0 ; int msis [ n ] ; for ( i = 0 ; i < n ; i ++ ) msis [ i ] = arr [ i ] ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && msis [ i ] < msis [ j ] + arr [ i ] ) msis [ i ] = msis [ j ] + arr [ i ] ; for ( i = 0 ; i < n ; i ++ ) if ( max < msis [ i ] ) max = msis [ i ] ; return max ; }
void findCommon ( int ar1 [ ] , int ar2 [ ] , int ar3 [ ] , int n1 , int n2 , int n3 ) { int i = 0 , j = 0 , k = 0 ; while ( i < n1 && j < n2 && k < n3 ) { if ( ar1 [ i ] == ar2 [ j ] && ar2 [ j ] == ar3 [ k ] ) { cout << ar1 [ i ] << " ▁ " ; i ++ ; j ++ ; k ++ ; } else if ( ar1 [ i ] < ar2 [ j ] ) i ++ ; else if ( ar2 [ j ] < ar3 [ k ] ) j ++ ; else k ++ ; } }
int answerQuery ( int a [ ] , int n , int l , int r ) { int count = 0 ; l = l - 1 ; for ( int i = l ; i < r ; i ++ ) { int element = a [ i ] ; int divisors = 0 ; for ( int j = l ; j < r ; j ++ ) { if ( a [ j ] % a [ i ] == 0 ) divisors ++ ; else break ; } if ( divisors == ( r - l ) ) count ++ ; } return count ; }
int productAtKthLevel ( string tree , int k ) { int level = -1 ; int n = tree . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( tree [ i ] == ' ( ' ) level ++ ; else if ( tree [ i ] == ' ) ' ) level -- ; else { if ( level == k ) product *= ( tree [ i ] - '0' ) ; } } return product ; }
int Cycles ( int N ) { int fact = 1 , result = 0 ; result = N - 1 ; int i = result ; while ( i > 0 ) { fact = fact * i ; i -- ; } return fact / 2 ; }
void findFourElements ( int A [ ] , int n , int X ) { for ( int i = 0 ; i < n - 3 ; i ++ ) { for ( int j = i + 1 ; j < n - 2 ; j ++ ) { for ( int k = j + 1 ; k < n - 1 ; k ++ ) { for ( int l = k + 1 ; l < n ; l ++ ) if ( A [ i ] + A [ j ] + A [ k ] + A [ l ] == X ) cout << A [ i ] << " , ▁ " << A [ j ] << " , ▁ " << A [ k ] << " , ▁ " << A [ l ] ; } } } }
int minOperations ( string s , string t , int n ) { int ct0 = 0 , ct1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == t [ i ] ) continue ; if ( s [ i ] == '0' ) ct0 ++ ; else ct1 ++ ; } return max ( ct0 , ct1 ) ; }
int countOfBinaryNumberLessThanN ( int N ) { queue < int > q ; q . push ( 1 ) ; int cnt = 0 ; int t ; while ( ! q . empty ( ) ) { t = q . front ( ) ; q . pop ( ) ; if ( t <= N ) { cnt ++ ; q . push ( t * 10 ) ; q . push ( t * 10 + 1 ) ; } } return cnt ; }
int countPairs ( int a [ ] , int n , int k ) { sort ( a , a + n ) ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int j = i + 1 ; while ( j < n && a [ j ] - a [ i ] < k ) { res ++ ; j ++ ; } } return res ; }
int findMinRooms ( string slots [ ] , int n , int m ) { int counts [ m ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( slots [ i ] [ j ] == '1' ) counts [ j ] ++ ; return * max_element ( counts , counts + m ) ; }
int minimumLength ( int x , int y , int z ) { return 1 + abs ( x - y ) + abs ( y - z ) ; }
int find_greatest_divisor ( int l , int r ) { if ( l == r ) return l ; return 1 ; }
int lbs ( int arr [ ] , int n ) { int i , j ; int * lis = new int [ n ] ; for ( i = 0 ; i < n ; i ++ ) lis [ i ] = 1 ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; int * lds = new int [ n ] ; for ( i = 0 ; i < n ; i ++ ) lds [ i ] = 1 ; for ( i = n - 2 ; i >= 0 ; i -- ) for ( j = n - 1 ; j > i ; j -- ) if ( arr [ i ] > arr [ j ] && lds [ i ] < lds [ j ] + 1 ) lds [ i ] = lds [ j ] + 1 ; int max = lis [ 0 ] + lds [ 0 ] - 1 ; for ( i = 1 ; i < n ; i ++ ) if ( lis [ i ] + lds [ i ] - 1 > max ) max = lis [ i ] + lds [ i ] - 1 ; return max ; }
int countWays ( int n , int m ) { int count [ n + 1 ] ; count [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i > m ) count [ i ] = count [ i - 1 ] + count [ i - m ] ; else if ( i < m i == 1 ) count [ i ] = 1 ; else count [ i ] = 2 ; } return count [ n ] ; }
int catalanDP ( unsigned int n ) { unsigned long int catalan [ n + 1 ] ; catalan [ 0 ] = catalan [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { catalan [ i ] = 0 ; for ( int j = 0 ; j < i ; j ++ ) catalan [ i ] += catalan [ j ] * catalan [ i - j - 1 ] ; } return catalan [ n ] ; }
int getQuadrant ( int X , int Y , int R , int PX , int PY ) { if ( PX == X && PY == Y ) return 0 ; int val = pow ( ( PX - X ) , 2 ) + pow ( ( PY - Y ) , 2 ) ; if ( val > pow ( R , 2 ) ) return -1 ; if ( PX > X && PY >= Y ) return 1 ; if ( PX <= X && PY > Y ) return 2 ; if ( PX < X && PY <= Y ) return 3 ; if ( PX >= X && PY < Y ) return 4 ; }
float decdiagonal ( float a ) { if ( a < 0 ) return -1 ; float d = 1.902 * a ; return d ; }
void shortest_distance ( float x1 , float y1 , float z1 , float a , float b , float c , float d ) { d = fabs ( ( a * x1 + b * y1 + c * z1 + d ) ) ; float e = sqrt ( a * a + b * b + c * c ) ; cout << " Perpendicular ▁ distance ▁ is ▁ " << ( d / e ) ; return ; }
int findGreatest ( int arr [ ] , int n ) { int result = -1 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n - 1 ; j ++ ) for ( int k = j + 1 ; k < n ; k ++ ) if ( arr [ j ] * arr [ k ] == arr [ i ] ) result = max ( result , arr [ i ] ) ; return result ; }
int findCount ( string str1 , string str2 ) { int len = str1 . size ( ) ; int len2 = str2 . size ( ) ; int ans = INT_MAX ; int hash1 [ 26 ] = { 0 } , hash2 [ 26 ] = { 0 } ; for ( int i = 0 ; i < len ; i ++ ) hash1 [ str1 [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < len2 ; i ++ ) hash2 [ str2 [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < 26 ; i ++ ) if ( hash2 [ i ] ) ans = min ( ans , hash1 [ i ] / hash2 [ i ] ) ; return ans ; }
int difference ( int arr [ ] [ MAX ] , int n ) { int d1 = 0 , d2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { d1 += arr [ i ] [ i ] ; d2 += arr [ i ] [ n - i - 1 ] ; } return abs ( d1 - d2 ) ; }
int minimumLectures ( int m , int n ) { int ans = 0 ; if ( n < ( int ) ceil ( 0.75 * m ) ) ans = ( int ) ceil ( ( ( 0.75 * m ) - n ) / 0.25 ) ; else ans = 0 ; return ans ; }
bool func ( int a [ ] , int k , int n ) { for ( int i = 0 ; i < n ; i ++ ) if ( a [ i ] % k == 0 ) return true ; return false ; }
float circlearea ( float a , float b ) { if ( a < 0 b < 0 ) return -1 ; float A = ( 3.14 * pow ( a , 2 ) * pow ( b , 2 ) ) / ( 4 * ( pow ( a , 2 ) + pow ( b , 2 ) ) ) ; return A ; }
int minDiff ( int arr [ ] , int n , int k ) { int result = INT_MAX ; sort ( arr , arr + n ) ; for ( int i = 0 ; i <= n - k ; i ++ ) result = min ( result , arr [ i + k - 1 ] - arr [ i ] ) ; return result ; }
int Square ( int row , int column , int moves ) { int a = 0 , b = 0 , c = 0 , d = 0 , total = 0 ; a = row - moves ; b = row + moves ; c = column - moves ; d = column + moves ; if ( a < 1 ) a = 1 ; if ( c < 1 ) c = 1 ; if ( b > 8 ) b = 8 ; if ( d > 8 ) d = 8 ; total = ( b - a + 1 ) * ( d - c + 1 ) - 1 ; return total ; }
int findOccurrences ( string str , string substr ) { int counter = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] == substr [ 0 ] ) { for ( int j = i + 1 ; j < str . length ( ) ; j ++ ) { if ( str [ j ] == substr [ 1 ] ) { for ( int k = j + 1 ; k < str . length ( ) ; k ++ ) { if ( str [ k ] == substr [ 2 ] ) counter ++ ; } } } } } return counter ; }
int nswp ( int n ) { int dp [ n + 1 ] ; dp [ 0 ] = dp [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) dp [ i ] = 2 * dp [ i - 1 ] + dp [ i - 2 ] ; return dp [ n ] ; }
void divide ( int a , int b ) { for ( int i = 2 ; i <= min ( a , b ) ; i ++ ) { while ( a % i == 0 && b % i == 0 ) { a = a / i ; b = b / i ; } } cout << " A ▁ = ▁ " << a << " , ▁ B ▁ = ▁ " << b << endl ; }
int SubArraySum ( int arr [ ] , int n ) { long int result = 0 , temp = 0 ; for ( int i = 0 ; i < n ; i ++ ) { temp = 0 ; for ( int j = i ; j < n ; j ++ ) { temp += arr [ j ] ; result += temp ; } } return result ; }
int countReduce ( string & str ) { int n = str . length ( ) ; int res = 0 ; for ( int i = 0 ; i < n / 2 ; i ++ ) res += abs ( str [ i ] - str [ n - i - 1 ] ) ; return res ; }
int numberOfWays ( int x ) { int dp [ x + 1 ] ; dp [ 0 ] = dp [ 1 ] = 1 ; for ( int i = 2 ; i <= x ; i ++ ) dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; return dp [ x ] ; }
int countNonDecreasing ( int n ) { long long int dp [ 10 ] [ n + 1 ] ; memset ( dp , 0 , sizeof dp ) ; for ( int i = 0 ; i < 10 ; i ++ ) dp [ i ] [ 1 ] = 1 ; for ( int digit = 0 ; digit <= 9 ; digit ++ ) { for ( int len = 2 ; len <= n ; len ++ ) { for ( int x = 0 ; x <= digit ; x ++ ) dp [ digit ] [ len ] += dp [ x ] [ len - 1 ] ; } } long long int count = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) count += dp [ i ] [ n ] ; return count ; }
void countOddRotations ( int n ) { int odd_count = 0 , even_count = 0 ; do { int digit = n % 10 ; if ( digit % 2 == 1 ) odd_count ++ ; else even_count ++ ; n = n / 10 ; } while ( n != 0 ) ; cout << " Odd ▁ = ▁ " << odd_count << endl ; cout << " Even ▁ = ▁ " << even_count << endl ; }
int check ( int n ) { int sum = 0 ; while ( n != 0 ) { sum += n % 10 ; n = n / 10 ; } if ( sum % 7 == 0 ) return 1 ; else return 0 ; }
bool search ( int arr [ ] , int n , int x ) { int front = 0 , back = n - 1 ; while ( front <= back ) { if ( arr [ front ] == x arr [ back ] == x ) return true ; front ++ ; back -- ; } return false ; }
int countNumbers ( int x , int n ) { if ( x > n ) return 0 ; return 1 + countNumbers ( x * 10 , n ) + countNumbers ( x * 10 + 1 , n ) ; }
int LastTwoDigit ( long long int num ) { int one = num % 10 ; num /= 10 ; int tens = num % 10 ; tens *= 10 ; num = tens + one ; return num ; }
bool checkOrigin ( int x1 , int y1 , int x2 , int y2 ) { return ( x1 * ( y2 - y1 ) == y1 * ( x2 - x1 ) ) ; }
int calculateSum ( int n ) { int a1 = 1 , a2 = 2 ; int r = 2 ; int d = 1 ; return ( n ) * ( 2 * a1 + ( n - 1 ) * d ) / 2 + a2 * ( pow ( r , n ) - 1 ) / ( r - 1 ) ; }
int highestPowerof2 ( int n ) { int res = 0 ; for ( int i = n ; i >= 1 ; i -- ) { if ( ( i & ( i - 1 ) ) == 0 ) { res = i ; break ; } } return res ; }
int countDecreasing ( int A [ ] , int n ) { int len = 1 ; for ( int i = 0 ; i < n - 1 ; ++ i ) { if ( A [ i + 1 ] < A [ i ] ) len ++ ; else { cnt += ( ( ( len - 1 ) * len ) / 2 ) ; len = 1 ; } } if ( len > 1 ) cnt += ( ( ( len - 1 ) * len ) / 2 ) ; return cnt ; }
void divide ( int n , int m ) { cout << " Remainder ▁ = ▁ " << ( ( n ) & ( m - 1 ) ) ; cout << " Quotient = " }
void checkCollision ( int a , int b , int c , int x , int y , int radius ) { int dist = ( abs ( a * x + b * y + c ) ) / sqrt ( a * a + b * b ) ; if ( radius == dist ) cout << " Touch " << endl ; else if ( radius > dist ) cout << " Intersect " << endl ; else cout << " Outside " << endl ; }
int nthTerm ( int N ) { return ( ( 3 * N * N ) - ( 6 * N ) + 2 ) ; }
void solve ( string s , int k ) { int count = 0 , length = 0 , pos = 0 ; map < char , int > m ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { m [ s [ i ] ] ++ ; length ++ ; if ( length > k ) { m [ s [ pos ++ ] ] -- ; length -- ; } if ( length == k && m [ s [ i ] ] == length ) count ++ ; } cout << count << endl ; }
int sumofseries ( int n ) { int res = 0 ; for ( int i = 1 ; i <= n ; i ++ ) res += ( i ) * ( i + 1 ) * ( i + 2 ) ; return res ; }
bool isPossible ( int n , int k , int arr [ ] ) { int sum = arr [ 0 ] , maxVal = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { sum += arr [ i ] ; maxVal = max ( maxVal , arr [ i ] ) ; } if ( ( float ) maxVal > ( float ) ( sum + k ) / n ) return false ; return true ; }
int stirlingFactorial ( int n ) { if ( n == 1 ) return 1 ; long int z ; z = sqrt ( 2 * 3.14 * n ) * pow ( ( n / e ) , n ) ; return z ; }
bool isPalindrome ( int n ) { int divisor = 1 ; while ( n / divisor >= 10 ) divisor *= 10 ; while ( n != 0 ) { int leading = n / divisor ; int trailing = n % 10 ; if ( leading != trailing ) return false ; n = ( n % divisor ) / 10 ; divisor = divisor / 100 ; } return true ; }
void toggle ( int & n ) { int temp = 1 ; while ( temp <= n ) { n = n ^ temp ; temp = temp << 1 ; } }
int dealnnoy ( int n , int m ) { int dp [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) dp [ i ] [ 0 ] = 1 ; for ( int i = 0 ; i <= m ; i ++ ) dp [ 0 ] [ i ] = 1 ; for ( int i = 1 ; i <= m ; i ++ ) for ( int j = 1 ; j <= n ; j ++ ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] + dp [ i ] [ j - 1 ] ; return dp [ m ] [ n ] ; }
void findVolume ( db u , db v , db w , db U , db V , db W , db b ) { db uPow = pow ( u , 2 ) ; db vPow = pow ( v , 2 ) ; db wPow = pow ( w , 2 ) ; db UPow = pow ( U , 2 ) ; db VPow = pow ( V , 2 ) ; db WPow = pow ( W , 2 ) ; db a = 4 * ( uPow * vPow * wPow ) - uPow * pow ( ( vPow + wPow - UPow ) , 2 ) - vPow * pow ( ( wPow + uPow - VPow ) , 2 ) - wPow * pow ( ( uPow + vPow - WPow ) , 2 ) + ( vPow + wPow - UPow ) * ( wPow + uPow - VPow ) * ( uPow + vPow - WPow ) ; db vol = sqrt ( a ) ; vol /= b ; cout << fixed << setprecision ( 4 ) << vol ; }
void distance ( float x1 , float y1 , float z1 , float x2 , float y2 , float z2 ) { float d = sqrt ( pow ( x2 - x1 , 2 ) + pow ( y2 - y1 , 2 ) + pow ( z2 - z1 , 2 ) * 1.0 ) ; std :: cout << std :: fixed ; std :: cout << std :: setprecision ( 2 ) ; cout << " ▁ Distance ▁ is ▁ " << d ; return ; }
int printNthElement ( int n ) { int arr [ n + 1 ] ; arr [ 1 ] = 4 ; arr [ 2 ] = 7 ; for ( int i = 3 ; i <= n ; i ++ ) { if ( i % 2 != 0 ) arr [ i ] = arr [ i / 2 ] * 10 + 4 ; else arr [ i ] = arr [ ( i / 2 ) - 1 ] * 10 + 7 ; } return arr [ n ] ; }
int calSum ( int n ) { int a = 3 , b = 0 , c = 2 ; return 3 ; return 3 ; return 5 ; int sum = 5 ; while ( n > 2 ) { sum += d ; a = b ; b = c ; c = d ; n -- ; } return sum ; }
int recLen ( char * str ) { if ( * str == ' \0' ) return 0 ; else return 1 + recLen ( str + 1 ) ; }
int findNth ( int N ) { int b = 14 ; int i ; for ( i = 2 ; i <= N ; i ++ ) { if ( i % 2 == 0 ) b = b * 2 ; else b = b - 8 ; } return b ; }
float geometricMean ( int arr [ ] , int n ) { float sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum + log ( arr [ i ] ) ; sum = sum / n ; return exp ( sum ) ; }
string allBitsSetInTheGivenRange ( unsigned int n , unsigned int l , unsigned int r ) { int num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ; int new_num = n & num ; if ( new_num == 0 ) return " Yes " ; return " No " ; }
int subtractOne ( int x ) { return ( ( x << 1 ) + ( ~ x ) ) ; }
float AvgofSquareN ( int n ) { return ( float ) ( ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; }
int countNumbers ( int n ) { if ( n % 2 == 1 ) return 0 ; return ( 9 * pow ( 10 , n / 2 - 1 ) ) ; }
void printSubsets ( int n ) { for ( int i = n ; i > 0 ; i = ( i - 1 ) & n ) cout << i << " ▁ " ; cout << 0 ; }
void leftRotate ( int arr [ ] , int n , int k ) { int mod = k % n ; for ( int i = 0 ; i < n ; i ++ ) cout << ( arr [ ( mod + i ) % n ] ) << " ▁ " ; cout << " STRNEWLINE " ; }
void length_of_chord ( double r , double x ) { cout << " The ▁ length ▁ of ▁ the ▁ chord " << " ▁ of ▁ the ▁ circle ▁ is ▁ " << 2 * r * sin ( x * ( 3.14 / 180 ) ) << endl ; }
void printLeaders ( int arr [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) { int j ; for ( j = i + 1 ; j < size ; j ++ ) { if ( arr [ i ] <= arr [ j ] ) break ; } if ( j == size ) cout << arr [ i ] << " ▁ " ; } }
float sumOfAP ( float a , float d , int n ) { float sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + a ; a = a + d ; } return sum ; }
int sum ( int k , int n ) { int sum = pow ( k , n + 1 ) - pow ( k - 1 , n + 1 ) ; return sum ; }
double polygonArea ( double X [ ] , double Y [ ] , int n ) { double area = 0.0 ; int j = n - 1 ; for ( int i = 0 ; i < n ; i ++ ) { area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) ; } return abs ( area / 2.0 ) ; }
int countOccurrences ( char * str , string word ) { char * p ; vector < string > a ; p = strtok ( str , " ▁ " ) ; while ( p != NULL ) { a . push_back ( p ) ; p = strtok ( NULL , " ▁ " ) ; } int c = 0 ; for ( int i = 0 ; i < a . size ( ) ; i ++ ) if ( word == a [ i ] ) c ++ ; return c ; }
float maxVol ( float P , float A ) { float l = ( P - sqrt ( P * P - 24 * A ) ) / 12 ; float V = l * ( A / 2.0 - l * ( P / 4.0 - l ) ) ; return V ; }
void rearrange ( int arr [ ] , int n ) { int temp [ n ] ; int small = 0 , large = n - 1 ; int flag = true ; for ( int i = 0 ; i < n ; i ++ ) { if ( flag ) temp [ i ] = arr [ large -- ] ; else temp [ i ] = arr [ small ++ ] ; flag = ! flag ; } for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = temp [ i ] ; }
void printXYZ ( int n ) { if ( n == 1 ) cout << -1 ; else cout << " x ▁ is ▁ " << n << " STRNEWLINE y ▁ is ▁ " << n + 1 << " STRNEWLINE z ▁ is ▁ " << n * ( n + 1 ) ; }
bool check ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] & 1 ) return true ; } return false ; }
bool isOsiris ( int n ) { int a = n % 10 ; int b = ( n / 10 ) % 10 ; int c = n / 100 ; int digit_sum = a + b + c ; if ( n == ( 2 * ( digit_sum ) * 11 ) ) { return true ; } return false ; }
double findMedian ( int a [ ] , int n ) { sort ( a , a + n ) ; if ( n % 2 != 0 ) return ( double ) a [ n / 2 ] ; return ( double ) ( a [ ( n - 1 ) / 2 ] + a [ n / 2 ] ) / 2.0 ; }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
int numberOfSquares ( int base ) { base = ( base - 2 ) ; base = floor ( base / 2 ) ; return base * ( base + 1 ) / 2 ; }
int centereddecagonalnum ( int n ) { return ( 5 * n * n + 5 * n + 1 ) ; }
string replace ( string s , char c1 , char c2 ) { int l = s . length ( ) ; for ( int i = 0 ; i < l ; i ++ ) { if ( s [ i ] == c1 ) s [ i ] = c2 ; else if ( s [ i ] == c2 ) s [ i ] = c1 ; } return s ; }
void printMaxActivities ( int s [ ] , int f [ ] , int n ) { int i , j ; cout << " Following ▁ activities ▁ are ▁ selected ▁ " << endl ; i = 0 ; cout << " ▁ " << i ; for ( j = 1 ; j < n ; j ++ ) { if ( s [ j ] >= f [ i ] ) { cout << " ▁ " << j ; i = j ; } } }
int sumOfSeries ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= i ; j ++ ) sum = sum + i ; return sum ; }
double find_area ( int r , int d ) { double R = d / PI ; R += pow ( r , 2 ) ; R = sqrt ( R ) ; double area = PI * pow ( R , 2 ) ; return area ; }
void search ( string pat , string txt ) { int M = pat . size ( ) ; int N = txt . size ( ) ; int i = 0 ; while ( i <= N - M ) { int j ; for ( j = 0 ; j < M ; j ++ ) if ( txt [ i + j ] != pat [ j ] ) break ; if ( j == M ) { cout << " Pattern ▁ found ▁ at ▁ index ▁ " << i << endl ; i = i + M ; } else if ( j == 0 ) i = i + 1 ; else i = i + j ; } }
int minRemoval ( string str ) { int hash [ MAX_CHAR ] ; memset ( hash , 0 , sizeof ( hash ) ) ; for ( int i = 0 ; str [ i ] ; i ++ ) hash [ str [ i ] - ' a ' ] ++ ; int count = 0 ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) if ( hash [ i ] % 2 ) count ++ ; return ( count == 0 ) ? 0 : count - 1 ; }
int smallest_pair ( int a [ ] , int n ) { int min = INT_MAX , secondMin = INT_MAX ; for ( int j = 0 ; j < n ; j ++ ) { if ( a [ j ] < min ) { secondMin = min ; min = a [ j ] ; } else if ( ( a [ j ] < secondMin ) && a [ j ] != min ) secondMin = a [ j ] ; } return ( secondMin + min ) ; }
bool doMatch ( string A , string B ) { for ( int i = 0 ; i < A . length ( ) ; i ++ ) if ( A [ i ] != ' * ' && B [ i ] != ' * ' ) if ( A [ i ] != B [ i ] ) return false ; return true ; }
int find ( int start , string adj , int n , int dp [ ] ) { if ( start == n ) return 0 ; if ( dp [ start ] != -1 ) return dp [ start ] ; dp [ start ] = 0 ; int one = 0 , zero = 0 , k ; for ( k = start ; k < n ; k ++ ) { if ( adj [ k ] == '1' ) one ++ ; else zero ++ ; if ( one > zero ) dp [ start ] = max ( dp [ start ] , find ( k + 1 , adj , n , dp ) + k - start + 1 ) ; else dp [ start ] = max ( dp [ start ] , find ( k + 1 , adj , n , dp ) ) ; } return dp [ start ] ; }
int findpos ( string n ) { int pos = 0 ; for ( int i = 0 ; n [ i ] != ' \0' ; i ++ ) { switch ( n [ i ] ) { case '2' : pos = pos * 4 + 1 ; break ; case '3' : pos = pos * 4 + 2 ; break ; case '5' : pos = pos * 4 + 3 ; break ; case '7' : pos = pos * 4 + 4 ; break ; } } return pos ; }
string findWinner ( int A [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) res ^= A [ i ] ; if ( res == 0 n % 2 == 0 ) return " Alice " ; else return " Bob " ; }
int maxAND ( int L , int R ) { if ( L == R ) return L ; else if ( ( R - L ) == 1 ) return ( R & L ) ; else { if ( ( ( R - 1 ) & R ) > ( ( R - 2 ) & ( R - 1 ) ) ) return ( ( R - 1 ) & R ) ; else return ( ( R - 2 ) & ( R - 1 ) ) ; } }
bool isFibbinaryNum ( unsigned int n ) { if ( ( n & ( n >> 1 ) ) == 0 ) return true ; return false ; }
int printTriplets ( int arr [ ] , int n , int sum ) { sort ( arr , arr + n ) ; for ( int i = 0 ; i < n - 2 ; i ++ ) { int j = i + 1 , k = n - 1 ; while ( j < k ) { if ( arr [ i ] + arr [ j ] + arr [ k ] >= sum ) k -- ; else { for ( int x = j + 1 ; x <= k ; x ++ ) cout << arr [ i ] << " , ▁ " << arr [ j ] << " , ▁ " << arr [ x ] << endl ; j ++ ; } } } }
void decToBinary ( int n ) { int binaryNum [ 32 ] ; int i = 0 ; while ( n > 0 ) { binaryNum [ i ] = n % 2 ; n = n / 2 ; i ++ ; } for ( int j = i - 1 ; j >= 0 ; j -- ) cout << binaryNum [ j ] ; }
void LargestString ( string * na ) { int N = sizeof ( na ) / sizeof ( na [ 0 ] ) ; int c [ N ] ; int m = 1 ; for ( int j = 0 ; j < N ; j ++ ) { bool character [ 26 ] ; for ( int k = 0 ; k < na [ j ] . size ( ) ; k ++ ) { int x = ( int ) ( na [ j ] [ k ] - ' A ' ) ; if ( na [ j ] [ k ] != ' ▁ ' && character [ x ] == false ) { c [ j ] ++ ; character [ x ] = true ; } } if ( c [ j ] > c [ m ] ) m = j ; } cout << na [ m ] << endl ; }
int minSteps ( string str ) { int count = 0 ; for ( int i = 0 ; i < str . length ( ) - 2 ; i ++ ) { if ( str [ i ] == '0' ) { if ( str [ i + 1 ] == '1' ) { if ( str [ i + 2 ] == '0' ) { count ++ ; i += 2 ; } } } } return count ; }
int sortExceptK ( int arr [ ] , int k , int n ) { swap ( arr [ k ] , arr [ n - 1 ] ) ; sort ( arr , arr + n - 1 ) ; int last = arr [ n - 1 ] ; for ( int i = n - 1 ; i > k ; i -- ) arr [ i ] = arr [ i - 1 ] ; arr [ k ] = last ; }
bool isAutomorphic ( int N ) { int sq = N * N ; while ( N > 0 ) { if ( N % 10 != sq % 10 ) return false ; N /= 10 ; sq /= 10 ; } return true ; }
int center_hexadecagonal_num ( long int n ) { return 8 * n * n - 8 * n + 1 ; }
int nthTerm ( int N ) { int nth = 0 ; nth = ( N * N * ( N + 1 ) ) / 2 ; return nth ; }
bool isInside ( int circle_x , int circle_y , int rad , int x , int y ) { if ( ( x - circle_x ) * ( x - circle_x ) + ( y - circle_y ) * ( y - circle_y ) <= rad * rad ) return true ; else return false ; }
int avg_of_odd_num ( int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += ( 2 * i + 1 ) ; return sum / n ; }
int posOfRightMostDiffBit ( int m , int n ) { return ffs ( m ^ n ) ; }
int steps ( int source , int step , int dest ) { if ( abs ( source ) > ( dest ) ) return INT_MAX ; if ( source == dest ) return step ; int pos = steps ( source + step + 1 , step + 1 , dest ) ; int neg = steps ( source - step - 1 , step + 1 , dest ) ; return min ( pos , neg ) ; }
int calculateSum ( int n ) { return ( n * ( 4 * n * n + 6 * n - 1 ) / 3 ) ; }
bool isPath ( int arr [ row ] [ col ] ) { arr [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i < row ; i ++ ) if ( arr [ i ] [ 0 ] != -1 ) arr [ i ] [ 0 ] = arr [ i - 1 ] [ 0 ] ; for ( int j = 1 ; j < col ; j ++ ) if ( arr [ 0 ] [ j ] != -1 ) arr [ 0 ] [ j ] = arr [ 0 ] [ j - 1 ] ; for ( int i = 1 ; i < row ; i ++ ) for ( int j = 1 ; j < col ; j ++ ) if ( arr [ i ] [ j ] != -1 ) arr [ i ] [ j ] = max ( arr [ i ] [ j - 1 ] , arr [ i - 1 ] [ j ] ) ; return ( arr [ row - 1 ] [ col - 1 ] == 1 ) ; }
int minimumSteps ( int n , int m , int a , int b ) { if ( n > m ) return MAXN ; if ( n == m ) return 0 ; return min ( 1 + minimumSteps ( n * a , m , a , b ) , 1 + minimumSteps ( n * b , m , a , b ) ) ; }
void findUniquePair ( int arr [ ] , int n ) { int XOR = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) XOR = XOR ^ arr [ i ] ; int set_bit_no = XOR & ~ ( XOR - 1 ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] & set_bit_no ) x = x ^ arr [ i ] ; else y = y ^ arr [ i ] ; } printf ( " The ▁ unique ▁ pair ▁ is ▁ ( % d , ▁ % d ) " , x , y ) ; }
float areacircumscribed ( float a ) { return ( a * a * ( PI / 2 ) ) ; }
int Div_by_8 ( int n ) { return ( ( ( n >> 3 ) << 3 ) == n ) ; }
int digSum ( int n ) { int sum = 0 ; while ( n > 0 sum > 9 ) { if ( n == 0 ) { n = sum ; sum = 0 ; } sum += n % 10 ; n /= 10 ; } return sum ; }
void countDigit ( int n ) { int temp = n , sum = 0 , product = 1 ; while ( temp != 0 ) { int d = temp % 10 ; temp /= 10 ; if ( d > 0 && n % d == 0 ) { sum += d ; product *= d ; } } cout << " Sum ▁ = ▁ " << sum ; cout << " Product = " }
double cosXSertiesSum ( double x , int n ) { x = x * ( PI / 180.0 ) ; double res = 1 ; double sign = 1 , fact = 1 , pow = 1 ; for ( int i = 1 ; i < 5 ; i ++ ) { sign = sign * -1 ; fact = fact * ( 2 * i - 1 ) * ( 2 * i ) ; pow = pow * x * x ; res = res + sign * pow / fact ; } return res ; }
int nthTerm ( int n ) { return ( n * n ) + ( n * n * n ) ; }
int countDyckPaths ( unsigned int n ) { int res = 1 ; for ( int i = 0 ; i < n ; ++ i ) { res *= ( 2 * n - i ) ; res /= ( i + 1 ) ; } return res / ( n + 1 ) ; }
float getSum ( int a , int n ) { float sum = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { sum += ( i / pow ( a , i ) ) ; } return sum ; }
int maximumResult ( int a , int b , int c ) { int countOfNegative = 0 ; int sum = a + b + c ; int product = a * b * c ; int largest = max ( a , max ( b , c ) ) ; int smallest = min ( a , min ( b , c ) ) ; if ( a < 0 ) countOfNegative ++ ; if ( b < 0 ) countOfNegative ++ ; if ( c < 0 ) countOfNegative ++ ; switch ( countOfNegative ) { case 0 : return ( sum - largest ) * largest ; case 1 : return ( product / smallest ) + smallest ; case 2 : return ( product / largest ) + largest ; case 3 : return ( sum - smallest ) * smallest ; } }
int numberOfWays ( int x ) { if ( x == 0 x == 1 ) return 1 ; else return numberOfWays ( x - 1 ) + ( x - 1 ) * numberOfWays ( x - 2 ) ; }
int otherNumber ( int A , int Lcm , int Hcf ) { return ( Lcm * Hcf ) / A ; }
int findevenPair ( int A [ ] , int N ) { int i , j ; int evenPair = 0 ; for ( i = 0 ; i < N ; i ++ ) { for ( j = i + 1 ; j < N ; j ++ ) { if ( ( A [ i ] & A [ j ] ) % 2 == 0 ) evenPair ++ ; } } return evenPair ; }
int removeRecur ( long int n ) { int prev_digit = n % 10 ; long int pow = 10 ; long int res = prev_digit ; while ( n ) { int curr_digit = n % 10 ; if ( curr_digit != prev_digit ) { res += curr_digit * pow ; prev_digit = curr_digit ; pow *= 10 ; } n = n / 10 ; } return res ; }
int toggleBits ( int n1 , int n2 ) { return n1 ^ n2 ; }
int count ( int n ) { if ( n < 3 ) return n ; if ( n >= 3 && n < 10 ) return n - 1 ; int po = 1 ; while ( n / po > 9 ) po = po * 10 ; int msd = n / po ; if ( msd != 3 ) return count ( msd ) * count ( po - 1 ) + count ( msd ) + count ( n % po ) ; else return count ( msd * po - 1 ) ; }
int submatrixXor ( int arr [ ] [ n ] ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { int top_left = ( i + 1 ) * ( j + 1 ) ; int bottom_right = ( n - i ) * ( n - j ) ; if ( ( top_left % 2 == 1 ) && ( bottom_right % 2 == 1 ) ) ans = ( ans ^ arr [ i ] [ j ] ) ; } } return ans ; }
int findMaxRec ( int A [ ] , int n ) { if ( n == 1 ) return A [ 0 ] ; return max ( A [ n - 1 ] , findMaxRec ( A , n - 1 ) ) ; }
int answer_query ( int a [ ] , int n , int l , int r ) { int count = 0 ; for ( int i = l ; i < r ; i ++ ) if ( a [ i ] == a [ i + 1 ] ) count += 1 ; return count ; }
void sequence ( int n ) { int f [ n + 1 ] ; f [ 0 ] = 0 ; f [ 1 ] = 1 ; f [ 2 ] = 1 ; cout << f [ 1 ] << " ▁ " << f [ 2 ] << " ▁ " ; for ( int i = 3 ; i <= n ; i ++ ) { f [ i ] = f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ] ; cout << f [ i ] << " ▁ " ; } }
int power ( long long x , unsigned int y , int p ) { int res = 1 ; x = x % p ; if ( x == 0 ) return 0 ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % p ; y = y >> 1 ; y = y / 2 x = ( x * x ) % p ; } return res ; }
int countStrings ( int n , int k ) { int dp [ n + 1 ] [ k + 1 ] [ 2 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; dp [ 1 ] [ 0 ] [ 0 ] = 1 ; dp [ 1 ] [ 0 ] [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= k ; j ++ ) { dp [ i ] [ j ] [ 0 ] = dp [ i - 1 ] [ j ] [ 0 ] + dp [ i - 1 ] [ j ] [ 1 ] ; dp [ i ] [ j ] [ 1 ] = dp [ i - 1 ] [ j ] [ 0 ] ; if ( j - 1 >= 0 ) dp [ i ] [ j ] [ 1 ] += dp [ i - 1 ] [ j - 1 ] [ 1 ] ; } } return dp [ n ] [ k ] [ 0 ] + dp [ n ] [ k ] [ 1 ] ; }
