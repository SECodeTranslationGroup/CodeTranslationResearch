function calculate ( $ a , $ n ) { sort ( $ a ) ; $ s = array ( ) ; for ( $ i = 0 , $ j = $ n - 1 ; $ i < $ j ; $ i ++ , $ j -- ) array_push ( $ s , ( $ a [ $ i ] + $ a [ $ j ] ) ) ; $ mini = min ( $ s ) ; $ maxi = max ( $ s ) ; return abs ( $ maxi - $ mini ) ; }
function cyl ( $ r , $ h ) { if ( $ r < 0 && $ h < 0 ) return -1 ; $ R = ( int ) ( 2 * $ r ) / 3 ; $ H = ( int ) ( 2 * $ h ) / 3 ; $ V = 3.14 * pow ( $ R , 2 ) * $ H ; return $ V ; }
function printTwoSetBitNums ( $ n ) { $ x = 1 ; while ( $ n > 0 ) { $ y = 0 ; while ( $ y < $ x ) { echo ( 1 << $ x ) + ( 1 << $ y ) , " ▁ " ; $ n -- ; if ( $ n == 0 ) return ; $ y ++ ; } $ x ++ ; } }
function minNumber ( $ a , $ n , $ x ) { $ l = 0 ; $ h = 0 ; $ e = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] == $ x ) $ e ++ ; else if ( $ a [ $ i ] > $ x ) $ h ++ ; else if ( $ a [ $ i ] < $ x ) $ l ++ ; } $ ans = 0 ; if ( $ l > $ h ) $ ans = $ l - $ h ; else if ( $ l < $ h ) $ ans = $ h - $ l - 1 ; return $ ans + 1 - $ e ; }
function printKthBit ( $ n , $ k ) { echo ( $ n & ( 1 << ( $ k - 1 ) ) ) ; }
function equilibrium ( $ arr , $ n ) { $ sum = 0 ; $ leftsum = 0 ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) $ sum += $ arr [ $ i ] ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { $ sum -= $ arr [ $ i ] ; if ( $ leftsum == $ sum ) return $ i ; $ leftsum += $ arr [ $ i ] ; } return -1 ; }
function countRhombi ( $ h , $ w ) { $ ct = 0 ; for ( $ i = 2 ; $ i <= $ h ; $ i += 2 ) for ( $ j = 2 ; $ j <= $ w ; $ j += 2 ) $ ct += ( $ h - $ i + 1 ) * ( $ w - $ j + 1 ) ; return $ ct ; }
function sumofoddFactors ( $ n ) { $ res = 1 ; while ( $ n % 2 == 0 ) $ n = $ n / 2 ; for ( $ i = 3 ; $ i <= sqrt ( $ n ) ; $ i ++ ) { $ count = 0 ; $ curr_sum = 1 ; $ curr_term = 1 ; while ( $ n % $ i == 0 ) { $ count ++ ; $ n = $ n / $ i ; $ curr_term *= $ i ; $ curr_sum += $ curr_term ; } $ res *= $ curr_sum ; } if ( $ n >= 2 ) $ res *= ( 1 + $ n ) ; return $ res ; }
function isPower ( $ n ) { for ( $ x = 2 ; $ x <= sqrt ( $ n ) ; $ x ++ ) { $ f = log ( $ n ) / log ( $ x ) ; if ( ( $ f - ( int ) $ f ) == 0.0 ) return true ; } return false ; }
function sumOfSeries ( $ n ) { return $ n * ( $ n + 1 ) * ( 6 * $ n * $ n * $ n + 9 * $ n * $ n + $ n - 1 ) / 30 ; }
function sum ( $ n ) { $ i ; $ s = 0.0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ s = $ s + 1 / $ i ; return $ s ; }
function countRect ( $ n ) { $ ans = 0 ; for ( $ length = 1 ; $ length <= sqrt ( $ n ) ; $ length ++ ) for ( $ height = $ length ; $ height * $ length <= $ n ; $ height ++ ) $ ans ++ ; return $ ans ; }
function isSquareFree ( $ n ) { if ( $ n % 2 == 0 ) $ n = $ n / 2 ; if ( $ n % 2 == 0 ) return false ; for ( $ i = 3 ; $ i <= sqrt ( $ n ) ; $ i = $ i + 2 ) { if ( $ n % $ i == 0 ) { $ n = $ n / $ i ; if ( $ n % $ i == 0 ) return false ; } } return true ; }
function constructXOR ( & $ A , $ n ) { $ XOR = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ XOR ^= $ A [ $ i ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ A [ $ i ] = $ XOR ^ $ A [ $ i ] ; }
function maxArea ( $ perimeter ) { $ length = ( int ) ceil ( $ perimeter / 4 ) ; $ breadth = ( int ) floor ( $ perimeter / 4 ) ; return ( $ length * $ breadth ) ; }
function isPowerOfK ( $ n , $ k ) { $ oneSeen = false ; while ( $ n > 0 ) { $ digit = $ n % $ k ; if ( $ digit > 1 ) return false ; if ( $ digit == 1 ) { if ( $ oneSeen ) return false ; $ oneSeen = true ; } $ n = ( int ) $ n / $ k ; } return true ; }
function ReuleauxArea ( $ a ) { if ( $ a < 0 ) return -1 ; $ A = 0.70477 * pow ( $ a , 2 ) ; return $ A ; }
function squareArea ( $ a ) { if ( $ a < 0 ) return -1 ; $ area = pow ( 1.268 , 2 ) * pow ( $ a , 2 ) ; return $ area ; }
function cal_cos ( $ n ) { $ accuracy = 0.0001 ; $ n = $ n * ( 3.142 / 180.0 ) ; $ x1 = 1 ; $ cosx = $ x1 ; $ cosval = cos ( $ n ) ; $ i = 1 ; do { $ denominator = 2 * $ i * ( 2 * $ i - 1 ) ; $ x1 = - $ x1 * $ n * $ n / $ denominator ; $ cosx = $ cosx + $ x1 ; $ i = $ i + 1 ; } while ( $ accuracy <= abs ( $ cosval - $ cosx ) ) ; echo round ( $ cosx , 6 ) ; }
function divisorSum ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; ++ $ i ) { for ( $ j = 1 ; $ j * $ j <= $ i ; ++ $ j ) { if ( $ i % $ j == 0 ) { if ( $ i / $ j == $ j ) $ sum += $ j ; else $ sum += $ j + $ i / $ j ; } } } return $ sum ; }
function hexadecagonalNum ( $ n ) { return ( ( 14 * $ n * $ n ) - 12 * $ n ) / 2 ; }
function minValue ( $ n , $ x , $ y ) { $ val = ( $ y * $ n ) / 100 ; if ( $ x >= $ val ) return 0 ; else return ( ceil ( $ val ) - $ x ) ; } { $ n = 10 ; $ x = 2 ; $ y = 40 ; echo ( minValue ( $ n , $ x , $ y ) ) ; }
function middlesum ( $ mat , $ n ) { $ row_sum = 0 ; $ col_sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ row_sum += $ mat [ $ n / 2 ] [ $ i ] ; echo " Sum ▁ of ▁ middle ▁ row ▁ = ▁ " , $ row_sum , " STRNEWLINE " ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ col_sum += $ mat [ $ i ] [ $ n / 2 ] ; echo " Sum ▁ of ▁ middle ▁ column ▁ = ▁ " , $ col_sum ; }
function printBalancedExpression ( $ a , $ b , $ c , $ d ) { if ( ( $ a == $ d && $ a ) || ( $ a == 0 && $ c == 0 && $ d == 0 ) ) { for ( $ i = 1 ; $ i <= $ a ; $ i ++ ) echo " ( ( " ; for ( $ i = 1 ; $ i <= $ c ; $ i ++ ) echo " ) ( " ; for ( $ i = 1 ; $ i <= $ d ; $ i ++ ) echo " ) ) " ; for ( $ i = 1 ; $ i <= $ b ; $ i ++ ) echo " ( ) " ; } else echo - 1 ; }
function judgeSquareSum ( $ n ) { for ( $ i = 2 ; $ i * $ i <= $ n ; $ i ++ ) { $ count = 0 ; if ( $ n % $ i == 0 ) { while ( $ n % $ i == 0 ) { $ count ++ ; $ n = ( int ) $ n / $ i ; } if ( $ i % 4 == 3 && $ count % 2 != 0 ) return false ; } } return $ n % 4 != 3 ; }
function highestPowerOf2 ( $ n ) { return ( $ n & ( ~ ( $ n - 1 ) ) ) ; }
function printMaxSum ( $ arr , $ n ) { $ dp = array ( ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ dp [ $ i ] = $ arr [ $ i ] ; $ maxi = 0 ; for ( $ j = 1 ; $ j <= sqrt ( $ i + 1 ) ; $ j ++ ) { if ( ( ( $ i + 1 ) % $ j == 0 ) && ( $ i + 1 ) != $ j ) { if ( $ dp [ $ j - 1 ] > $ maxi ) $ maxi = $ dp [ $ j - 1 ] ; if ( $ dp [ ( $ i + 1 ) / $ j - 1 ] > $ maxi && $ j != 1 ) $ maxi = $ dp [ ( $ i + 1 ) / $ j - 1 ] ; } } $ dp [ $ i ] += $ maxi ; } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ dp [ $ i ] , " ▁ " ; }
function isInGivenBase ( $ str , $ base ) { if ( $ base > 16 ) return false ; else if ( $ base <= 10 ) { for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) if ( ! ( $ str [ $ i ] >= '0' and $ str [ $ i ] < ( '0' + $ base ) ) ) return false ; } else { for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) if ( ! ( ( $ str [ $ i ] >= '0' && $ str [ $ i ] < ( '0' + $ base ) ) || ( $ str [ $ i ] >= ' A ' && $ str [ $ i ] < ( ' A ' + $ base - 10 ) ) ) ) return false ; } return true ; }
function convert ( $ str ) { $ n = strlen ( $ str ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ str [ $ i ] == ' ▁ ' ) $ str [ $ i ] = ' _ ' ; else $ str [ $ i ] = strtolower ( $ str [ $ i ] ) ; } echo $ str ; }
function hammingDistance ( $ n1 , $ n2 ) { $ x = $ n1 ^ $ n2 ; $ setBits = 0 ; while ( $ x > 0 ) { $ setBits += $ x & 1 ; $ x >>= 1 ; } return $ setBits ; }
function roundFunation ( $ n ) { $ a = ( int ) ( $ n / 10 ) * 10 ; $ b = ( $ a + 10 ) ; return ( $ n - $ a > $ b - $ n ) ? $ b : $ a ; }
function absSumDidd ( $ a , $ n ) { sort ( $ a ) ; $ midValue = $ a [ ( $ n / 2 ) ] ; $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sum = $ sum + abs ( $ a [ $ i ] - $ midValue ) ; } return $ sum ; }
function sumN ( $ n ) { $ n = ( int ) ( ( $ n + 1 ) / 2 ) ; return ( $ n * $ n ) ; }
function getPairsCount ( $ arr , $ n , $ sum ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) if ( $ arr [ $ i ] + $ arr [ $ j ] == $ sum ) $ count ++ ; return $ count ; }
function bin ( $ n ) { if ( $ n > 1 ) bin ( $ n >> 1 ) ; echo ( $ n & 1 ) ; }
function countSetBits ( $ n ) { $ count = 0 ; while ( $ n ) { $ count += $ n & 1 ; $ n >>= 1 ; } return $ count ; }
function findNature ( $ a , $ b , $ n ) { if ( $ n == 0 ) return ( $ a & 1 ) ; if ( $ n == 1 ) return ( $ b & 1 ) ; if ( ! ( $ a & 1 ) ) { if ( ! ( $ b & 1 ) ) return false ; else return ( $ n % 3 != 0 ) ; } else { if ( ! ( $ b & 1 ) ) return ( ( $ n - 1 ) % 3 != 0 ) ; else return ( ( $ n + 1 ) % 3 != 0 ) ; } }
function getCount ( $ N ) { if ( $ N % 2 == 1 ) return 0 ; $ result = "9" ; for ( $ i = 1 ; $ i <= $ N / 2 - 1 ; $ i ++ ) $ result . = "0" ; return $ result ; }
function longOddEvenIncSeq ( & $ arr , $ n ) { $ lioes = array_fill ( 0 , $ n , NULL ) ; $ maxLen = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ lioes [ $ i ] = 1 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ i ; $ j ++ ) if ( $ arr [ $ i ] > $ arr [ $ j ] && ( $ arr [ $ i ] + $ arr [ $ j ] ) % 2 != 0 && $ lioes [ $ i ] < $ lioes [ $ j ] + 1 ) $ lioes [ $ i ] = $ lioes [ $ j ] + 1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ maxLen < $ lioes [ $ i ] ) $ maxLen = $ lioes [ $ i ] ; return $ maxLen ; }
function rad ( $ d , $ h ) { echo " The ▁ radius ▁ of ▁ the ▁ circle ▁ is ▁ " , ( ( $ d * $ d ) / ( 8 * $ h ) + $ h / 2 ) , " STRNEWLINE " ; }
function printAllAPTriplets ( $ arr , $ n ) { $ s = array ( ) ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) { $ diff = $ arr [ $ j ] - $ arr [ $ i ] ; if ( in_array ( $ arr [ $ i ] - $ diff , $ arr ) ) echo ( ( $ arr [ $ i ] - $ diff ) . " " ▁ . ▁ $ arr [ $ i ] ▁ . ▁ " " ▁ . ▁ $ arr [ $ j ] ▁ . ▁ " " } array_push ( $ s , $ arr [ $ i ] ) ; } }
function sumOfSeries ( $ x , $ k ) { return ( ( $ x ) / 81 ) * ( 9 * $ k - 1 + pow ( 10 , ( -1 ) * $ k ) ) ; }
function binaryToDecimal ( $ n ) { $ num = $ n ; $ dec_value = 0 ; $ base = 1 ; $ temp = $ num ; while ( $ temp ) { $ last_digit = $ temp % 10 ; $ temp = $ temp / 10 ; $ dec_value += $ last_digit * $ base ; $ base = $ base * 2 ; } return $ dec_value ; }
function nobleInteger ( $ arr ) { sort ( $ arr ) ; $ n = count ( $ arr ) ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { if ( $ arr [ $ i ] == $ arr [ $ i + 1 ] ) continue ; if ( $ arr [ $ i ] == $ n - $ i - 1 ) return $ arr [ $ i ] ; } if ( $ arr [ $ n - 1 ] == 0 ) return $ arr [ $ n - 1 ] ; return -1 ; }
function pad ( $ n ) { $ pPrevPrev = 1 ; $ pPrev = 1 ; $ pCurr = 1 ; $ pNext = 1 ; for ( $ i = 3 ; $ i <= $ n ; $ i ++ ) { $ pNext = $ pPrevPrev + $ pPrev ; $ pPrevPrev = $ pPrev ; $ pPrev = $ pCurr ; $ pCurr = $ pNext ; } return $ pNext ; }
function findSubsequence ( $ str , $ k ) { $ a = array ( 1024 ) ; for ( $ i = 0 ; $ i < 26 ; $ i ++ ) $ a [ $ i ] = 0 ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) { $ temp = ord ( $ str [ $ i ] ) - ord ( ' a ' ) ; $ a [ $ temp ] += 1 ; } for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) if ( $ a [ ord ( $ str [ $ i ] ) - ord ( ' a ' ) ] >= $ k ) echo $ str [ $ i ] ; }
function count_square ( $ n ) { $ count = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i = $ i + 2 ) { $ k = $ n - $ i + 1 ; $ count += ( $ k * $ k ) ; } return $ count ; }
function countTriplets ( $ arr , $ n , $ m ) { $ count = 0 ; sort ( $ arr ) ; $ end ; $ start ; $ mid ; for ( $ end = $ n - 1 ; $ end >= 2 ; $ end -- ) { $ start = 0 ; $ mid = $ end - 1 ; while ( $ start < $ mid ) { $ prod = $ arr [ $ end ] * $ arr [ $ start ] * $ arr [ $ mid ] ; if ( $ prod > $ m ) $ mid -- ; else if ( $ prod < $ m ) $ start ++ ; else if ( $ prod == $ m ) { $ count ++ ; $ mid -- ; $ start ++ ; } } } return $ count ; }
function calculateArea ( $ x , $ y ) { $ pi = 3.1415926536 ; $ arx = $ pi * $ x * $ x ; $ ary = $ pi * $ y * $ y ; return ( $ arx - $ ary ) ; }
function maxMin ( $ arr , $ n ) { $ min = PHP_INT_MAX ; $ max = PHP_INT_MIN ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j <= $ n / 2 ; $ j ++ ) { if ( $ arr [ $ i ] [ $ j ] > $ arr [ $ i ] [ $ n - $ j - 1 ] ) { if ( $ min > $ arr [ $ i ] [ $ n - $ j - 1 ] ) $ min = $ arr [ $ i ] [ $ n - $ j - 1 ] ; if ( $ max < $ arr [ $ i ] [ $ j ] ) $ max = $ arr [ $ i ] [ $ j ] ; } else { if ( $ min > $ arr [ $ i ] [ $ j ] ) $ min = $ arr [ $ i ] [ $ j ] ; if ( $ max < $ arr [ $ i ] [ $ n - $ j - 1 ] ) $ max = $ arr [ $ i ] [ $ n - $ j - 1 ] ; } } } echo " Maximum = " ▁ , ▁ $ max STRNEWLINE TABSYMBOL TABSYMBOL , " , Minimum = " }
function checkFittingArrays ( $ A , $ B , $ N ) { sort ( $ A ) ; sort ( $ B ) ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) if ( $ A [ $ i ] > $ B [ $ i ] ) return false ; return true ; }
function printTrib ( $ n ) { $ dp [ 0 ] = $ dp [ 1 ] = 0 ; $ dp [ 2 ] = 1 ; for ( $ i = 3 ; $ i < $ n ; $ i ++ ) $ dp [ $ i ] = $ dp [ $ i - 1 ] + $ dp [ $ i - 2 ] + $ dp [ $ i - 3 ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ dp [ $ i ] , " ▁ " ; }
function isUnique ( $ a , $ n , $ k ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum += $ a [ $ i ] ; $ sum += $ n - 1 ; return ( $ sum == $ k ) ; }
function nthTerm ( $ n ) { return 2 * pow ( $ n , 2 ) + 4 * $ n - 2 ; }
function printSquares ( $ n ) { $ square = 0 ; $ odd = 1 ; for ( $ x = 0 ; $ x < $ n ; $ x ++ ) { echo $ square , " " ; $ square = $ square + $ odd ; $ odd = $ odd + 2 ; } }
function pentagon_pyramidal ( $ n ) { return $ n * $ n * ( $ n + 1 ) / 2 ; }
function oddEquivalent ( $ s , $ n ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ s [ $ i ] == '1' ) $ count ++ ; } return $ count ; }
function countWays ( $ index , $ cnt , $ dp , $ n , $ m , $ k ) { if ( $ index == $ n ) { if ( $ cnt == $ k ) return 1 ; else return 0 ; } if ( $ dp [ $ index ] [ $ cnt ] != -1 ) return $ dp [ $ index ] [ $ cnt ] ; $ ans = 0 ; $ ans += countWays ( $ index + 1 , $ cnt , $ dp , $ n , $ m , $ k ) ; $ ans += ( $ m - 1 ) * countWays ( $ index + 1 , $ cnt + 1 , $ dp , $ n , $ m , $ k ) ; $ dp [ $ index ] [ $ cnt ] = $ ans ; return $ dp [ $ index ] [ $ cnt ] ; }
function polyarea ( $ n , $ a ) { if ( $ a < 0 && $ n < 0 ) return -1 ; $ A = ( $ a * $ a * $ n ) / ( 4 * tan ( ( 180 / $ n ) * 3.14159 / 180 ) ) ; return $ A ; }
function countSol ( $ coeff , $ start , $ end , $ rhs ) { if ( $ rhs == 0 ) return 1 ; $ result = 0 ; for ( $ i = $ start ; $ i <= $ end ; $ i ++ ) if ( $ coeff [ $ i ] <= $ rhs ) $ result += countSol ( $ coeff , $ i , $ end , $ rhs - $ coeff [ $ i ] ) ; return $ result ; }
function findMaximumPieces ( $ n ) { $ x = ( int ) ( $ n / 2 ) ; return ( ( $ x + 1 ) * ( $ n - $ x + 1 ) ) ; }
function nthTerm ( $ n ) { return 6 * pow ( $ n , 2 ) - 4 * $ n - 2 ; }
function isSurd ( $ n ) { for ( $ i = 2 ; $ i * $ i <= $ n ; $ i ++ ) { $ j = $ i ; while ( $ j < $ n ) $ j = $ j * $ i ; if ( $ j == $ n ) return false ; } return true ; }
function swap ( $ a , $ b , $ c , $ d ) { $ a = $ a + $ b ; $ b = $ a - $ b ; $ a = $ a - $ b ; $ b = $ b + $ c ; $ c = $ b - $ c ; $ b = $ b - $ c ; $ c = $ c + $ d ; $ d = $ c - $ d ; $ c = $ c - $ d ; echo " values ▁ after ▁ swapping ▁ are ▁ : ▁ " , " STRNEWLINE " ; echo " a = " ▁ , ▁ $ a ▁ , " " ; STRNEWLINE TABSYMBOL echo ▁ " b = " ▁ , ▁ $ b ▁ , " " ; STRNEWLINE TABSYMBOL echo ▁ " c = " ▁ , $ c ▁ , " " ; STRNEWLINE TABSYMBOL echo ▁ " d = " ▁ , ▁ $ d ▁ , " " }
function checkPronic ( $ x ) { for ( $ i = 0 ; $ i <= ( sqrt ( $ x ) ) ; $ i ++ ) if ( $ x == $ i * ( $ i + 1 ) ) return true ; return false ; }
function FindMaxSum ( $ arr , $ n ) { $ incl = $ arr [ 0 ] ; $ excl = 0 ; $ excl_new ; $ i ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ excl_new = ( $ incl > $ excl ) ? $ incl : $ excl ; $ incl = $ excl + $ arr [ $ i ] ; $ excl = $ excl_new ; } return ( ( $ incl > $ excl ) ? $ incl : $ excl ) ; }
function maxGameByWinner ( $ N ) { $ dp [ $ N ] = 0 ; $ dp [ 0 ] = 1 ; $ dp [ 1 ] = 2 ; $ i = 2 ; do { $ dp [ $ i ] = $ dp [ $ i - 1 ] + $ dp [ $ i - 2 ] ; } while ( $ dp [ $ i ++ ] <= $ N ) ; return ( $ i - 2 ) ; }
function Area ( $ r ) { if ( $ r < 0 ) return -1 ; $ x = ( 2 * $ r ) / sqrt ( 5 ) ; $ A = 0.70477 * pow ( $ x , 2 ) ; return $ A ; }
function findAnswer ( $ X , $ N ) { return ( $ N - 1 ) * 9 + $ X ; }
function checkPandigital ( $ b , $ n ) { if ( strlen ( $ n ) < $ b ) return 0 ; $ hash = array ( ) ; for ( $ i = 0 ; $ i < $ b ; $ i ++ ) $ hash [ $ i ] = 0 ; for ( $ i = 0 ; $ i < strlen ( $ n ) ; $ i ++ ) { if ( $ n [ $ i ] >= '0' && $ n [ $ i ] <= '9' ) $ hash [ $ n [ $ i ] - '0' ] = 1 ; else if ( ord ( $ n [ $ i ] ) - ord ( ' A ' ) <= $ b - 11 ) $ hash [ ord ( $ n [ $ i ] ) - ord ( ' A ' ) + 10 ] = 1 ; } for ( $ i = 0 ; $ i < $ b ; $ i ++ ) if ( $ hash [ $ i ] == 0 ) return 0 ; return 1 ; }
function maxSumIS ( $ arr , $ n ) { $ max = 0 ; $ msis = array ( $ n ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ msis [ $ i ] = $ arr [ $ i ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ i ; $ j ++ ) if ( $ arr [ $ i ] > $ arr [ $ j ] && $ msis [ $ i ] < $ msis [ $ j ] + $ arr [ $ i ] ) $ msis [ $ i ] = $ msis [ $ j ] + $ arr [ $ i ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ max < $ msis [ $ i ] ) $ max = $ msis [ $ i ] ; return $ max ; }
function findCommon ( $ ar1 , $ ar2 , $ ar3 , $ n1 , $ n2 , $ n3 ) { $ i = 0 ; $ j = 0 ; $ k = 0 ; while ( $ i < $ n1 && $ j < $ n2 && $ k < $ n3 ) { if ( $ ar1 [ $ i ] == $ ar2 [ $ j ] && $ ar2 [ $ j ] == $ ar3 [ $ k ] ) { echo $ ar1 [ $ i ] , " " ; $ i ++ ; $ j ++ ; $ k ++ ; } else if ( $ ar1 [ $ i ] < $ ar2 [ $ j ] ) $ i ++ ; else if ( $ ar2 [ $ j ] < $ ar3 [ $ k ] ) $ j ++ ; else $ k ++ ; } }
function answerQuery ( $ a , $ n , $ l , $ r ) { $ count = 0 ; $ l = $ l - 1 ; for ( $ i = $ l ; $ i < $ r ; $ i ++ ) { $ element = $ a [ $ i ] ; $ divisors = 0 ; for ( $ j = $ l ; $ j < $ r ; $ j ++ ) { if ( $ a [ $ j ] % $ a [ $ i ] == 0 ) $ divisors ++ ; else break ; } if ( $ divisors == ( $ r - $ l ) ) $ count ++ ; } return $ count ; }
function productAtKthLevel ( $ tree , $ k ) { $ level = -1 ; $ n = strlen ( $ tree ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ tree [ $ i ] == ' ( ' ) $ level ++ ; else if ( $ tree [ $ i ] == ' ) ' ) $ level -- ; else { if ( $ level == $ k ) $ product *= ( ord ( $ tree [ $ i ] ) - ord ( '0' ) ) ; } } return $ product ; }
function Cycles ( $ N ) { $ fact = 1 ; $ result = 0 ; $ result = $ N - 1 ; $ i = $ result ; while ( $ i > 0 ) { $ fact = $ fact * $ i ; $ i -- ; } return floor ( $ fact / 2 ) ; }
function findFourElements ( $ A , $ n , $ X ) { for ( $ i = 0 ; $ i < $ n - 3 ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ n - 2 ; $ j ++ ) { for ( $ k = $ j + 1 ; $ k < $ n - 1 ; $ k ++ ) { for ( $ l = $ k + 1 ; $ l < $ n ; $ l ++ ) if ( $ A [ $ i ] + $ A [ $ j ] + $ A [ $ k ] + $ A [ $ l ] == $ X ) echo $ A [ $ i ] , " , ▁ " , $ A [ $ j ] , " , ▁ " , $ A [ $ k ] , " , ▁ " , $ A [ $ l ] ; } } } }
function minOperations ( $ s , $ t , $ n ) { $ ct0 = 0 ; $ ct1 = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ s [ $ i ] == $ t [ $ i ] ) continue ; if ( $ s [ $ i ] == '0' ) $ ct0 ++ ; else $ ct1 ++ ; } return max ( $ ct0 , $ ct1 ) ; }
function countOfBinaryNumberLessThanN ( $ N ) { $ q = array ( ) ; array_push ( $ q , 1 ) ; $ cnt = 0 ; $ t = 0 ; while ( ! empty ( $ q ) ) { $ t = array_pop ( $ q ) ; if ( $ t <= $ N ) { $ cnt ++ ; array_push ( $ q , $ t * 10 ) ; array_push ( $ q , ( $ t * 10 + 1 ) ) ; } } return $ cnt ; }
function countPairs ( $ a , $ n , $ k ) { sort ( $ a ) ; $ res = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ j = $ i + 1 ; while ( $ j < $ n and $ a [ $ j ] - $ a [ $ i ] < $ k ) { $ res ++ ; $ j ++ ; } } return $ res ; }
function findMinRooms ( $ slots , $ n , $ m ) { $ counts = array_fill ( 0 , $ m , 0 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ m ; $ j ++ ) if ( $ slots [ $ i ] [ $ j ] == '1' ) $ counts [ $ j ] ++ ; return max ( $ counts ) ; }
function minimumLength ( $ x , $ y , $ z ) { return 1 + abs ( $ x - $ y ) + abs ( $ y - $ z ) ; }
function find_greatest_divisor ( $ l , $ r ) { if ( $ l == $ r ) return $ l ; return 1 ; }
function lbs ( & $ arr , $ n ) { $ lis = array_fill ( 0 , $ n , NULL ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ lis [ $ i ] = 1 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ i ; $ j ++ ) if ( $ arr [ $ i ] > $ arr [ $ j ] && $ lis [ $ i ] < $ lis [ $ j ] + 1 ) $ lis [ $ i ] = $ lis [ $ j ] + 1 ; $ lds = array_fill ( 0 , $ n , NULL ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ lds [ $ i ] = 1 ; for ( $ i = $ n - 2 ; $ i >= 0 ; $ i -- ) for ( $ j = $ n - 1 ; $ j > $ i ; $ j -- ) if ( $ arr [ $ i ] > $ arr [ $ j ] && $ lds [ $ i ] < $ lds [ $ j ] + 1 ) $ lds [ $ i ] = $ lds [ $ j ] + 1 ; $ max = $ lis [ 0 ] + $ lds [ 0 ] - 1 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) if ( $ lis [ $ i ] + $ lds [ $ i ] - 1 > $ max ) $ max = $ lis [ $ i ] + $ lds [ $ i ] - 1 ; return $ max ; }
function countWays ( $ n , $ m ) { $ count [ 0 ] = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { if ( $ i > $ m ) $ count [ $ i ] = $ count [ $ i - 1 ] + $ count [ $ i - $ m ] ; else if ( $ i < $ m or $ i == 1 ) $ count [ $ i ] = 1 ; else $ count [ $ i ] = 2 ; } return $ count [ $ n ] ; }
function catalanDP ( $ n ) { $ catalan = array ( ) ; $ catalan [ 0 ] = $ catalan [ 1 ] = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { $ catalan [ $ i ] = 0 ; for ( $ j = 0 ; $ j < $ i ; $ j ++ ) $ catalan [ $ i ] += $ catalan [ $ j ] * $ catalan [ $ i - $ j - 1 ] ; } return $ catalan [ $ n ] ; }
function getQuadrant ( $ X , $ Y , $ R , $ PX , $ PY ) { if ( $ PX == $ X and $ PY == $ Y ) return 0 ; $ val = pow ( ( $ PX - $ X ) , 2 ) + pow ( ( $ PY - $ Y ) , 2 ) ; if ( $ val > pow ( $ R , 2 ) ) return -1 ; if ( $ PX > $ X and $ PY >= $ Y ) return 1 ; if ( $ PX <= $ X and $ PY > $ Y ) return 2 ; if ( $ PX < $ X and $ PY <= $ Y ) return 3 ; if ( $ PX >= $ X and $ PY < $ Y ) return 4 ; }
function decdiagonal ( $ a ) { if ( $ a < 0 ) return -1 ; $ d = 1.902 * $ a ; return $ d ; }
function shortest_distance ( $ x1 , $ y1 , $ z1 , $ a , $ b , $ c , $ d ) { $ d = abs ( ( $ a * $ x1 + $ b * $ y1 + $ c * $ z1 + $ d ) ) ; $ e = sqrt ( $ a * $ a + $ b * $ b + $ c * $ c ) ; echo " Perpendicular ▁ distance ▁ is ▁ " . $ d / $ e ; }
function findGreatest ( $ arr , $ n ) { $ result = -1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ n - 1 ; $ j ++ ) for ( $ k = $ j + 1 ; $ k < $ n ; $ k ++ ) if ( $ arr [ $ j ] * $ arr [ $ k ] == $ arr [ $ i ] ) $ result = max ( $ result , $ arr [ $ i ] ) ; return $ result ; }
function findCount ( $ str1 , $ str2 ) { $ len = strlen ( $ str1 ) ; $ len2 = strlen ( $ str1 ) ; $ ans = PHP_INT_MAX ; $ hash1 = array_fill ( 0 , 26 , 0 ) ; $ hash2 = array_fill ( 0 , 26 , 0 ) ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) $ hash1 [ ord ( $ str1 [ $ i ] ) - ord ( ' a ' ) ] ++ ; for ( $ i = 0 ; $ i < $ len2 ; $ i ++ ) $ hash2 [ ord ( $ str2 [ $ i ] ) - ord ( ' a ' ) ] ++ ; for ( $ i = 0 ; $ i < 26 ; $ i ++ ) if ( $ hash2 [ $ i ] ) $ ans = min ( $ ans , $ hash1 [ $ i ] / $ hash2 [ $ i ] ) ; return $ ans ; }
function difference ( $ arr , $ n ) { $ d1 = 0 ; $ d2 = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ d1 += $ arr [ $ i ] [ $ i ] ; $ d2 += $ arr [ $ i ] [ $ n - $ i - 1 ] ; } return abs ( $ d1 - $ d2 ) ; } { $ n = 3 ; $ arr = array ( array ( 11 , 2 , 4 ) , array ( 4 , 5 , 6 ) , array ( 10 , 8 , -12 ) ) ; echo difference ( $ arr , $ n ) ; return 0 ; }
function minimumLectures ( $ m , $ n ) { $ ans = 0 ; if ( $ n < ceil ( 0.75 * $ m ) ) $ ans = ( int ) ceil ( ( ( 0.75 * $ m ) - $ n ) / 0.25 ) ; else $ ans = 0 ; return $ ans ; }
function func ( $ a , $ k , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ a [ $ i ] % $ k == 0 ) return true ; return false ; }
function circlearea ( $ a , $ b ) { if ( $ a < 0 $ b < 0 ) return -1 ; $ A = ( 3.14 * pow ( $ a , 2 ) * pow ( $ b , 2 ) ) / ( 4 * ( pow ( $ a , 2 ) + pow ( $ b , 2 ) ) ) ; return $ A ; }
function minDiff ( $ arr , $ n , $ k ) { $ INT_MAX = 2147483647 ; $ result = $ INT_MAX ; sort ( $ arr , $ n ) ; sort ( $ arr ) ; for ( $ i = 0 ; $ i <= $ n - $ k ; $ i ++ ) $ result = min ( $ result , $ arr [ $ i + $ k - 1 ] - $ arr [ $ i ] ) ; return $ result ; }
function Square ( $ row , $ column , $ moves ) { $ a = 0 ; $ b = 0 ; $ c = 0 ; $ d = 0 ; $ total = 0 ; $ a = $ row - $ moves ; $ b = $ row + $ moves ; $ c = $ column - $ moves ; $ d = $ column + $ moves ; if ( $ a < 1 ) $ a = 1 ; if ( $ c < 1 ) $ c = 1 ; if ( $ b > 8 ) $ b = 8 ; if ( $ d > 8 ) $ d = 8 ; $ total = ( $ b - $ a + 1 ) * ( $ d - $ c + 1 ) - 1 ; return $ total ; }
function findOccurrences ( $ str , $ substr ) { $ counter = 0 ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) { if ( $ str [ $ i ] == $ substr [ 0 ] ) { for ( $ j = $ i + 1 ; $ j < strlen ( $ str ) ; $ j ++ ) { if ( $ str [ $ j ] == $ substr [ 1 ] ) { for ( $ k = $ j + 1 ; $ k < strlen ( $ str ) ; $ k ++ ) { if ( $ str [ $ k ] == $ substr [ 2 ] ) $ counter ++ ; } } } } } return $ counter ; }
function nswp ( $ n ) { $ dp [ 0 ] = $ dp [ 1 ] = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) $ dp [ $ i ] = 2 * $ dp [ $ i - 1 ] + $ dp [ $ i - 2 ] ; return $ dp [ $ n ] ; }
function divide ( $ a , $ b ) { for ( $ i = 2 ; $ i <= min ( $ a , $ b ) ; $ i ++ ) { while ( $ a % $ i == 0 && $ b % $ i == 0 ) { $ a = $ a / $ i ; $ b = $ b / $ i ; } } echo " A = " , ▁ $ a , ▁ " , B = " , ▁ $ b , ▁ " " }
function SubArraySum ( $ arr , $ n ) { $ result = 0 ; $ temp = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ temp = 0 ; for ( $ j = $ i ; $ j < $ n ; $ j ++ ) { $ temp += $ arr [ $ j ] $ result += $ temp ; } } return $ result ; }
function countReduce ( $ str ) { $ n = strlen ( $ str ) ; $ res = 0 ; for ( $ i = 0 ; $ i < $ n / 2 ; $ i ++ ) $ res += abs ( ord ( $ str [ $ i ] ) - ord ( $ str [ ( $ n - $ i - 1 ) ] ) ) ; return $ res ; }
function numberOfWays ( $ x ) { $ dp [ 0 ] = 1 ; $ dp [ 1 ] = 1 ; for ( $ i = 2 ; $ i <= $ x ; $ i ++ ) $ dp [ $ i ] = $ dp [ $ i - 1 ] + ( $ i - 1 ) * $ dp [ $ i - 2 ] ; return $ dp [ $ x ] ; }
function countNonDecreasing ( $ n ) { $ dp = array_fill ( 0 , 10 , array_fill ( 0 , $ n + 1 , NULL ) ) ; for ( $ i = 0 ; $ i < 10 ; $ i ++ ) $ dp [ $ i ] [ 1 ] = 1 ; for ( $ digit = 0 ; $ digit <= 9 ; $ digit ++ ) { for ( $ len = 2 ; $ len <= $ n ; $ len ++ ) { for ( $ x = 0 ; $ x <= $ digit ; $ x ++ ) $ dp [ $ digit ] [ $ len ] += $ dp [ $ x ] [ $ len - 1 ] ; } } $ count = 0 ; for ( $ i = 0 ; $ i < 10 ; $ i ++ ) $ count += $ dp [ $ i ] [ $ n ] ; return $ count ; }
function countOddRotations ( $ n ) { $ odd_count = 0 ; $ even_count = 0 ; do { $ digit = $ n % 10 ; if ( $ digit % 2 == 1 ) $ odd_count ++ ; else $ even_count ++ ; $ n = ( int ) ( $ n / 10 ) ; } while ( $ n != 0 ) ; echo " Odd = " , ▁ $ odd _ count , ▁ " " ; STRNEWLINE TABSYMBOL echo ▁ " Even = " , ▁ $ even _ count , ▁ " " }
function check ( $ n ) { $ sum = 0 ; while ( $ n != 0 ) { $ sum += $ n % 10 ; $ n = ( int ) ( $ n / 10 ) ; } if ( $ sum % 7 == 0 ) return 1 ; else return 0 ; }
function search ( $ arr , $ n , $ x ) { $ front = 0 ; $ back = $ n - 1 ; while ( $ front <= $ back ) { if ( $ arr [ $ front ] == $ x $ arr [ $ back ] == $ x ) return true ; $ front ++ ; $ back -- ; } return false ; }
function countNumbers ( $ x , $ n ) { if ( $ x > $ n ) return 0 ; return 1 + countNumbers ( $ x * 10 , $ n ) + countNumbers ( $ x * 10 + 1 , $ n ) ; }
function LastTwoDigit ( $ num ) { $ one = $ num % 10 ; $ num /= 10 ; $ tens = $ num % 10 ; $ tens *= 10 ; $ num = $ tens + $ one ; return $ num ; }
function checkOrigin ( $ x1 , $ y1 , $ x2 , $ y2 ) { return ( $ x1 * ( $ y2 - $ y1 ) == $ y1 * ( $ x2 - $ x1 ) ) ; }
function calculateSum ( $ n ) { $ a1 = 1 ; $ a2 = 2 ; $ r = 2 ; $ d = 1 ; return ( $ n ) * ( 2 * $ a1 + ( $ n - 1 ) * $ d ) / 2 + $ a2 * ( pow ( $ r , $ n ) - 1 ) / ( $ r - 1 ) ; }
function highestPowerof2 ( $ n ) { $ res = 0 ; for ( $ i = $ n ; $ i >= 1 ; $ i -- ) { if ( ( $ i & ( $ i - 1 ) ) == 0 ) { $ res = $ i ; break ; } } return $ res ; }
function countDecreasing ( $ A , $ n ) { $ len = 1 ; for ( $ i = 0 ; $ i < $ n - 1 ; ++ $ i ) { if ( $ A [ $ i + 1 ] < $ A [ $ i ] ) $ len ++ ; else { $ cnt += ( ( ( $ len - 1 ) * $ len ) / 2 ) ; $ len = 1 ; } } if ( $ len > 1 ) $ cnt += ( ( ( $ len - 1 ) * $ len ) / 2 ) ; return $ cnt ; }
function divide ( $ n , $ m ) { echo " Remainder = " . ▁ ( ( $ n ) ▁ & ( $ m ▁ - ▁ 1 ) ) ; STRNEWLINE TABSYMBOL echo ▁ " Quotient = " }
function checkCollision ( $ a , $ b , $ c , $ x , $ y , $ radius ) { $ dist = ( abs ( $ a * $ x + $ b * $ y + $ c ) ) / sqrt ( $ a * $ a + $ b * $ b ) ; if ( $ radius == $ dist ) echo " Touch " ; else if ( $ radius > $ dist ) echo " Intersect " ; else echo " Outside " ; }
function nthTerm ( $ N ) { return ( ( 3 * $ N * $ N ) - ( 6 * $ N ) + 2 ) ; }
function solve ( $ s , $ k ) { $ count = 0 ; $ length = 0 ; $ pos = 0 ; $ m = array ( ) ; for ( $ i = 0 ; $ i < strlen ( $ s ) ; $ i ++ ) { $ m [ $ s [ $ i ] ] ++ ; $ length ++ ; if ( $ length > $ k ) { $ m [ $ s [ $ pos ++ ] ] -- ; $ length -- ; } if ( $ length == $ k && $ m [ $ s [ $ i ] ] == $ length ) $ count ++ ; } echo $ count . " STRNEWLINE " ; }
function sumofseries ( $ n ) { $ res = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ res += ( $ i ) * ( $ i + 1 ) * ( $ i + 2 ) ; return $ res ; }
function isPossible ( $ n , $ k , $ arr ) { $ sum = $ arr [ 0 ] ; $ maxVal = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ sum += $ arr [ $ i ] ; $ maxVal = max ( $ maxVal , $ arr [ $ i ] ) ; } if ( ( float ) $ maxVal > ( float ) ( $ sum + $ k ) / $ n ) return false ; return true ; }
function stirlingFactorial ( $ n ) { if ( $ n == 1 ) return 1 ; $ z ; $ e = 2.71 ; $ z = sqrt ( 2 * 3.14 * $ n ) * pow ( ( $ n / $ e ) , $ n ) ; return floor ( $ z ) ; }
function isPalindrome ( $ n ) { $ divisor = 1 ; while ( $ n / $ divisor >= 10 ) $ divisor *= 10 ; while ( $ n != 0 ) { $ leading = floor ( $ n / $ divisor ) ; $ trailing = $ n % 10 ; if ( $ leading != $ trailing ) return false ; $ n = ( $ n % $ divisor ) / 10 ; $ divisor = $ divisor / 100 ; } return true ; }
function toggle ( & $ n ) { $ temp = 1 ; while ( $ temp <= $ n ) { $ n = $ n ^ $ temp ; $ temp = $ temp << 1 ; } }
function dealnnoy ( $ n , $ m ) { $ dp [ $ m + 1 ] [ $ n + 1 ] = 0 ; for ( $ i = 0 ; $ i <= $ m ; $ i ++ ) $ dp [ $ i ] [ 0 ] = 1 ; for ( $ i = 0 ; $ i <= $ m ; $ i ++ ) $ dp [ 0 ] [ $ i ] = 1 ; for ( $ i = 1 ; $ i <= $ m ; $ i ++ ) for ( $ j = 1 ; $ j <= $ n ; $ j ++ ) $ dp [ $ i ] [ $ j ] = $ dp [ $ i - 1 ] [ $ j ] + $ dp [ $ i - 1 ] [ $ j - 1 ] + $ dp [ $ i ] [ $ j - 1 ] ; return $ dp [ $ m ] [ $ n ] ; }
function findVolume ( $ u , $ v , $ w , $ U , $ V , $ W , $ b ) { $ uPow = pow ( $ u , 2 ) ; $ vPow = pow ( $ v , 2 ) ; $ wPow = pow ( $ w , 2 ) ; $ UPow = pow ( $ U , 2 ) ; $ VPow = pow ( $ V , 2 ) ; $ WPow = pow ( $ W , 2 ) ; $ a = 4 * ( $ uPow * $ vPow * $ wPow ) - $ uPow * pow ( ( $ vPow + $ wPow - $ UPow ) , 2 ) - $ vPow * pow ( ( $ wPow + $ uPow - $ VPow ) , 2 ) - $ wPow * pow ( ( $ uPow + $ vPow - $ WPow ) , 2 ) + ( $ vPow + $ wPow - $ UPow ) * ( $ wPow + $ uPow - $ VPow ) * ( $ uPow + $ vPow - $ WPow ) ; $ vol = sqrt ( $ a ) ; $ vol /= $ b ; echo $ vol ; }
function distance ( $ x1 , $ y1 , $ z1 , $ x2 , $ y2 , $ z2 ) { $ d = sqrt ( pow ( $ x2 - $ x1 , 2 ) + pow ( $ y2 - $ y1 , 2 ) + pow ( $ z2 - $ z1 , 2 ) * 1.0 ) ; echo " Distance ▁ is ▁ " . $ d ; }
function printNthElement ( $ n ) { $ arr [ 1 ] = 4 ; $ arr [ 2 ] = 7 ; for ( $ i = 3 ; $ i <= $ n ; $ i ++ ) { if ( $ i % 2 != 0 ) $ arr [ $ i ] = $ arr [ $ i / 2 ] * 10 + 4 ; else $ arr [ $ i ] = $ arr [ ( $ i / 2 ) - 1 ] * 10 + 7 ; } return $ arr [ $ n ] ; }
function calSum ( $ n ) { $ a = 3 ; $ b = 0 ; $ c = 2 ; return 3 ; return 3 ; return 5 ; $ sum = 5 ; while ( $ n > 2 ) { $ d = $ a + $ b ; $ sum += $ d ; $ a = $ b ; $ b = $ c ; $ c = $ d ; $ n -- ; } return $ sum ; }
function recLen ( & $ str , $ i ) { if ( $ i == strlen ( $ str ) ) return 0 ; else return 1 + recLen ( $ str , $ i + 1 ) ; }
function findNth ( $ N ) { $ b = 14 ; for ( $ i = 2 ; $ i <= $ N ; $ i ++ ) { if ( $ i % 2 == 0 ) $ b = $ b * 2 ; else $ b = $ b - 8 ; } return $ b ; }
function geometricMean ( $ arr , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum = $ sum + log ( $ arr [ $ i ] ) ; $ sum = $ sum / $ n ; return exp ( $ sum ) ; }
function allBitsSetInTheGivenRange ( $ n , $ l , $ r ) { $ num = ( ( 1 << $ r ) - 1 ) ^ ( ( 1 << ( $ l - 1 ) ) - 1 ) ; $ new_num = $ n & $ num ; if ( $ new_num == 0 ) return " Yes " ; return " No " ; }
function subtractOne ( $ x ) { return ( ( $ x << 1 ) + ( ~ $ x ) ) ; }
function AvgofSquareN ( $ n ) { return ( ( $ n + 1 ) * ( 2 * $ n + 1 ) ) / 6 ; }
function countNumbers ( $ n ) { if ( $ n % 2 == 1 ) return 0 ; return ( 9 * ( int ) pow ( 10 , $ n / 2 - 1 ) ) ; }
function printSubsets ( $ n ) { for ( $ i = $ n ; $ i > 0 ; $ i = ( $ i - 1 ) & $ n ) echo $ i . " " ; echo "0" ; }
function leftRotate ( $ arr , $ n , $ k ) { $ mod = $ k % $ n ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo ( $ arr [ ( $ mod + $ i ) % $ n ] ) , " ▁ " ; echo " STRNEWLINE " ; }
function length_of_chord ( $ r , $ x ) { echo " The ▁ length ▁ of ▁ the ▁ chord " , " ▁ of ▁ the ▁ circle ▁ is ▁ " , 2 * $ r * sin ( $ x * ( 3.14 / 180 ) ) ; }
function printLeaders ( $ arr , $ size ) { for ( $ i = 0 ; $ i < $ size ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ size ; $ j ++ ) { if ( $ arr [ $ i ] <= $ arr [ $ j ] ) break ; } if ( $ j == $ size ) echo ( $ arr [ $ i ] . " ▁ " ) ; } }
function sumOfAP ( $ a , $ d , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sum = $ sum + $ a ; $ a = $ a + $ d ; } return $ sum ; }
function sum ( $ k , $ n ) { $ sum = pow ( $ k , $ n + 1 ) - pow ( $ k - 1 , $ n + 1 ) ; return $ sum ; }
function polygonArea ( $ X , $ Y , $ n ) { $ area = 0.0 ; $ j = $ n - 1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ area += ( $ X [ $ j ] + $ X [ $ i ] ) * ( $ Y [ $ j ] - $ Y [ $ i ] ) ; $ j = $ i ; } return abs ( $ area / 2.0 ) ; }
function countOccurrences ( $ str , $ word ) { $ a = explode ( " ▁ " , $ str ) ; $ count = 0 ; for ( $ i = 0 ; $ i < sizeof ( $ a ) ; $ i ++ ) { if ( $ word == $ a [ $ i ] ) $ count ++ ; } return $ count ; }
function maxVol ( $ P , $ A ) { $ l = ( $ P - sqrt ( $ P * $ P - 24 * $ A ) ) / 12 ; $ V = $ l * ( $ A / 2.0 - $ l * ( $ P / 4.0 - $ l ) ) ; return $ V ; }
function rearrange ( & $ arr , $ n ) { $ temp = array ( ) ; $ small = 0 ; $ large = $ n - 1 ; $ flag = true ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ flag ) $ temp [ $ i ] = $ arr [ $ large -- ] ; else $ temp [ $ i ] = $ arr [ $ small ++ ] ; $ flag = ! $ flag ; } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ arr [ $ i ] = $ temp [ $ i ] ; }
function printXYZ ( $ n ) { if ( $ n == 1 ) echo - 1 ; else echo " x ▁ is ▁ " , $ n , " STRNEWLINE y ▁ is ▁ " , $ n + 1 , " STRNEWLINE z ▁ is ▁ " , $ n * ( $ n + 1 ) ; }
function check ( $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] & 1 ) return true ; } return false ; }
function isOsiris ( $ n ) { $ a = $ n % 10 ; $ b = floor ( $ n / 10 ) % 10 ; $ c = floor ( $ n / 100 ) ; $ digit_sum = $ a + $ b + $ c ; if ( $ n == ( 2 * ( $ digit_sum ) * 11 ) ) { return true ; } return false ; }
function findMedian ( & $ a , $ n ) { sort ( $ a ) ; if ( $ n % 2 != 0 ) return ( double ) $ a [ $ n / 2 ] ; return ( double ) ( $ a [ ( $ n - 1 ) / 2 ] + $ a [ $ n / 2 ] ) / 2.0 ; }
function gcd ( $ a , $ b ) { if ( $ b == 0 ) return $ a ; return gcd ( $ b , $ a % $ b ) ; }
function numberOfSquares ( $ base ) { $ base = ( $ base - 2 ) ; $ base = intdiv ( $ base , 2 ) ; return $ base * ( $ base + 1 ) / 2 ; }
function centereddecagonalnum ( $ n ) { return ( 5 * $ n * $ n + 5 * $ n + 1 ) ; }
function replace ( $ s , $ c1 , $ c2 ) { $ l = strlen ( $ s ) ; for ( $ i = 0 ; $ i < $ l ; $ i ++ ) { if ( $ s [ $ i ] == $ c1 ) $ s [ $ i ] = $ c2 ; else if ( $ s [ $ i ] == $ c2 ) $ s [ $ i ] = $ c1 ; } return $ s ; }
function printMaxActivities ( $ s , $ f , $ n ) { echo " Following ▁ activities ▁ are ▁ selected ▁ " . " STRNEWLINE " ; $ i = 0 ; echo $ i . " " ; for ( $ j = 1 ; $ j < $ n ; $ j ++ ) { if ( $ s [ $ j ] >= $ f [ $ i ] ) { echo $ j . " " ; $ i = $ j ; } } }
function sumOfSeries ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) for ( $ j = 1 ; $ j <= $ i ; $ j ++ ) $ sum = $ sum + $ i ; return $ sum ; }
function find_area ( $ r , $ d ) { $ R = $ d / PI ; $ R += pow ( $ r , 2 ) ; $ R = sqrt ( $ R ) ; $ area = PI * pow ( $ R , 2 ) ; return $ area ; }
function search ( $ pat , $ txt ) { $ M = strlen ( $ pat ) ; $ N = strlen ( $ txt ) ; $ i = 0 ; while ( $ i <= $ N - $ M ) { $ j ; for ( $ j = 0 ; $ j < $ M ; $ j ++ ) if ( $ txt [ $ i + $ j ] != $ pat [ $ j ] ) break ; if ( $ j == $ M ) { echo ( " Pattern ▁ found ▁ at ▁ index ▁ $ i " . " STRNEWLINE " ) ; $ i = $ i + $ M ; } else if ( $ j == 0 ) $ i = $ i + 1 ; else $ i = $ i + $ j ; } }
function minRemoval ( $ str ) { $ hash = array_fill ( 0 , 26 , 0 ) ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) $ hash [ ord ( $ str [ $ i ] ) - 97 ] ++ ; $ count = 0 ; for ( $ i = 0 ; $ i < 26 ; $ i ++ ) if ( $ hash [ $ i ] % 2 ) $ count ++ ; return ( $ count == 0 ) ? 0 : $ count - 1 ; }
function smallest_pair ( $ a , $ n ) { $ min = PHP_INT_MAX ; $ secondMin = PHP_INT_MAX ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ a [ $ j ] < $ min ) { $ secondMin = $ min ; $ min = $ a [ $ j ] ; } else if ( ( $ a [ $ j ] < $ secondMin ) && $ a [ $ j ] != $ min ) $ secondMin = $ a [ $ j ] ; } return ( $ secondMin + $ min ) ; }
function doMatch ( $ A , $ B ) { for ( $ i = 0 ; $ i < strlen ( $ A ) ; $ i ++ ) if ( $ A [ $ i ] != ' * ' && $ B [ $ i ] != ' * ' ) if ( $ A [ $ i ] != $ B [ $ i ] ) return false ; return true ; }
function find ( $ start , $ adj , $ n , $ dp ) { if ( $ start == $ n ) return 0 ; if ( $ dp [ $ start ] != -1 ) return $ dp [ $ start ] ; $ dp [ $ start ] = 0 ; $ one = 0 ; $ zero = 0 ; for ( $ k = $ start ; $ k < $ n ; $ k ++ ) { if ( $ adj [ $ k ] == '1' ) $ one ++ ; else $ zero ++ ; if ( $ one > $ zero ) $ dp [ $ start ] = max ( $ dp [ $ start ] , find ( $ k + 1 , $ adj , $ n , $ dp ) + $ k - $ start + 1 ) ; else $ dp [ $ start ] = max ( $ dp [ $ start ] , find ( $ k + 1 , $ adj , $ n , $ dp ) ) ; } return $ dp [ $ start ] ; }
function findpos ( $ n ) { $ pos = 0 ; for ( $ i = 0 ; isset ( $ n [ $ i ] ) != NULL ; $ i ++ ) { switch ( $ n [ $ i ] ) { case '2' : $ pos = $ pos * 4 + 1 ; break ; case '3' : $ pos = $ pos * 4 + 2 ; break ; case '5' : $ pos = $ pos * 4 + 3 ; break ; case '7' : $ pos = $ pos * 4 + 4 ; break ; } } return $ pos ; }
function findWinner ( $ A , $ n ) { $ res = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ res ^= $ A [ $ i ] ; if ( $ res == 0 or $ n % 2 == 0 ) return " Alice " ; else return " Bob " ; }
function maxAND ( $ L , $ R ) { if ( $ L == $ R ) return $ L ; else if ( ( $ R - $ L ) == 1 ) return ( $ R & $ L ) ; else { if ( ( ( $ R - 1 ) & $ R ) > ( ( $ R - 2 ) & ( $ R - 1 ) ) ) return ( ( $ R - 1 ) & $ R ) ; else return ( ( $ R - 2 ) & ( $ R - 1 ) ) ; } }
function isFibbinaryNum ( $ n ) { if ( ( $ n & ( $ n >> 1 ) ) == 0 ) return true ; return false ; }
function printTriplets ( $ arr , $ n , $ sum ) { sort ( $ arr , 0 ) ; for ( $ i = 0 ; $ i < $ n - 2 ; $ i ++ ) { $ j = $ i + 1 ; $ k = $ n - 1 ; while ( $ j < $ k ) { if ( $ arr [ $ i ] + $ arr [ $ j ] + $ arr [ $ k ] >= $ sum ) $ k -- ; else { for ( $ x = $ j + 1 ; $ x <= $ k ; $ x ++ ) echo $ arr [ $ i ] . " , " ▁ . ▁ $ arr [ $ j ] ▁ . STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL " , " ▁ . ▁ $ arr [ $ x ] ▁ . ▁ " " $ j ++ ; } } } }
function decToBinary ( $ n ) { $ binaryNum ; $ i = 0 ; while ( $ n > 0 ) { $ binaryNum [ $ i ] = $ n % 2 ; $ n = ( int ) ( $ n / 2 ) ; $ i ++ ; } for ( $ j = $ i - 1 ; $ j >= 0 ; $ j -- ) echo $ binaryNum [ $ j ] ; }
function LargestString ( $ na ) { $ N = sizeof ( $ na ) ; $ c = array_fill ( 0 , $ N , 0 ) ; $ m = 0 ; for ( $ j = 0 ; $ j < $ N ; $ j ++ ) { $ character = array_fill ( 0 , 26 , false ) ; for ( $ k = 0 ; $ k < strlen ( $ na [ $ j ] ) ; $ k ++ ) { $ x = ord ( $ na [ $ j ] [ $ k ] ) - 65 ; if ( ( $ na [ $ j ] [ $ k ] != ' ▁ ' ) && ( $ character [ $ x ] == false ) ) { $ c [ $ j ] ++ ; $ character [ $ x ] = true ; } } if ( $ c [ $ j ] > $ c [ $ m ] ) $ m = $ j ; } echo $ na [ $ m ] . " STRNEWLINE " ; }
function minSteps ( $ str ) { $ count = 0 ; for ( $ i = 0 ; $ i < strlen ( $ str ) - 2 ; $ i ++ ) { if ( $ str [ $ i ] == '0' ) { if ( $ str [ $ i + 1 ] == '1' ) { if ( $ str [ $ i + 2 ] == '0' ) { $ count ++ ; $ i += 2 ; } } } } return $ count ; }
function sortExceptK ( & $ arr , $ k , $ n ) { $ t = $ arr [ $ k ] ; $ arr [ $ k ] = $ arr [ $ n - 1 ] ; $ arr [ $ n - 1 ] = $ t ; $ t = $ arr [ count ( $ arr ) - 1 ] ; $ arr = array_slice ( $ arr , 0 , -1 ) ; sort ( $ arr ) ; array_push ( $ arr , $ t ) ; $ last = $ arr [ $ n - 1 ] ; for ( $ i = $ n - 1 ; $ i > $ k ; $ i -- ) $ arr [ $ i ] = $ arr [ $ i - 1 ] ; $ arr [ $ k ] = $ last ; }
function isAutomorphic ( $ N ) { $ sq = $ N * $ N ; while ( $ N > 0 ) { if ( $ N % 10 != $ sq % 10 ) return -1 ; $ N /= 10 ; $ sq /= 10 ; } return 1 ; }
function center_hexadecagonal_num ( $ n ) { return 8 * $ n * $ n - 8 * $ n + 1 ; }
function nthTerm ( $ N ) { $ nth = 0 ; $ nth = ( $ N * $ N * ( $ N + 1 ) ) / 2 ; return $ nth ; }
function isInside ( $ circle_x , $ circle_y , $ rad , $ x , $ y ) { if ( ( $ x - $ circle_x ) * ( $ x - $ circle_x ) + ( $ y - $ circle_y ) * ( $ y - $ circle_y ) <= $ rad * $ rad ) return true ; else return false ; }
function avg_of_odd_num ( $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum += ( 2 * $ i + 1 ) ; return $ sum / $ n ; }
function posOfRightMostDiffBit ( $ m , $ n ) { $ t = floor ( log ( $ m ^ $ n , 2 ) ) ; return $ t ; }
function steps ( $ source , $ step , $ dest ) { if ( abs ( $ source ) > ( $ dest ) ) return PHP_INT_MAX ; if ( $ source == $ dest ) return $ step ; $ pos = steps ( $ source + $ step + 1 , $ step + 1 , $ dest ) ; $ neg = steps ( $ source - $ step - 1 , $ step + 1 , $ dest ) ; return min ( $ pos , $ neg ) ; }
function calculateSum ( $ n ) { return ( $ n * ( 4 * $ n * $ n + 6 * $ n - 1 ) / 3 ) ; }
function isPath ( $ arr ) { global $ row , $ col ; $ arr [ 0 ] [ 0 ] = 1 ; for ( $ i = 1 ; $ i < $ row ; $ i ++ ) if ( $ arr [ $ i ] [ 0 ] != -1 ) $ arr [ $ i ] [ 0 ] = $ arr [ $ i - 1 ] [ 0 ] ; for ( $ j = 1 ; $ j < $ col ; $ j ++ ) if ( $ arr [ 0 ] [ $ j ] != -1 ) $ arr [ 0 ] [ $ j ] = $ arr [ 0 ] [ $ j - 1 ] ; for ( $ i = 1 ; $ i < $ row ; $ i ++ ) for ( $ j = 1 ; $ j < $ col ; $ j ++ ) if ( $ arr [ $ i ] [ $ j ] != -1 ) $ arr [ $ i ] [ $ j ] = max ( $ arr [ $ i ] [ $ j - 1 ] , $ arr [ $ i - 1 ] [ $ j ] ) ; return ( $ arr [ $ row - 1 ] [ $ col - 1 ] == 1 ) ; }
function minimumSteps ( $ n , $ m , $ a , $ b ) { global $ MAXN ; if ( $ n > $ m ) return $ MAXN ; if ( $ n == $ m ) return 0 ; return min ( 1 + minimumSteps ( $ n * $ a , $ m , $ a , $ b ) , 1 + minimumSteps ( $ n * $ b , $ m , $ a , $ b ) ) ; }
function findUniquePair ( $ arr , $ n ) { $ XOR = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ XOR = $ XOR ^ $ arr [ $ i ] ; $ set_bit_no = $ XOR & ~ ( $ XOR - 1 ) ; $ x = 0 ; $ y = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] & $ set_bit_no ) $ x = $ x ^ $ arr [ $ i ] ; else $ y = $ y ^ $ arr [ $ i ] ; } echo " The ▁ unique ▁ pair ▁ is ▁ " , " ( " , $ x , " ▁ " , $ y , " ) " ; }
function areacircumscribed ( $ a ) { global $ PI ; return ( $ a * $ a * ( $ PI / 2 ) ) ; }
function Div_by_8 ( $ n ) { return ( ( ( $ n >> 3 ) << 3 ) == $ n ) ; }
function digSum ( $ n ) { $ sum = 0 ; while ( $ n > 0 $ sum > 9 ) { if ( $ n == 0 ) { $ n = $ sum ; $ sum = 0 ; } $ sum += $ n % 10 ; $ n = ( int ) $ n / 10 ; } return $ sum ; }
function countDigit ( $ n ) { $ temp = $ n ; $ sum = 0 ; $ product = 1 ; while ( $ temp != 0 ) { $ d = $ temp % 10 ; $ temp = ( int ) ( $ temp / 10 ) ; if ( $ d > 0 && $ n % $ d == 0 ) { $ sum += $ d ; $ product *= $ d ; } } echo " Sum = " . $ sum ; STRNEWLINE TABSYMBOL echo ▁ " Product = " }
function cosXSertiesSum ( $ x , $ n ) { global $ PI ; $ x = $ x * ( $ PI / 180.0 ) ; $ res = 1 ; $ sign = 1 ; $ fact = 1 ; $ pow = 1 ; for ( $ i = 1 ; $ i < 5 ; $ i ++ ) { $ sign = $ sign * -1 ; $ fact = $ fact * ( 2 * $ i - 1 ) * ( 2 * $ i ) ; $ pow = $ pow * $ x * $ x ; $ res = $ res + $ sign * $ pow / $ fact ; } return $ res ; }
function nthTerm ( $ n ) { return ( $ n * $ n ) + ( $ n * $ n * $ n ) ; }
function countDyckPaths ( $ n ) { $ res = 1 ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { $ res *= ( 2 * $ n - $ i ) ; $ res /= ( $ i + 1 ) ; } return $ res / ( $ n + 1 ) ; }
function getSum ( $ a , $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; ++ $ i ) { $ sum += ( $ i / pow ( $ a , $ i ) ) ; } return $ sum ; }
function maximumResult ( $ a , $ b , $ c ) { $ countOfNegative = 0 ; $ sum = $ a + $ b + $ c ; $ product = $ a * $ b * $ c ; $ largest = max ( $ a , $ b , $ c ) ; $ smallest = min ( $ a , $ b , $ c ) ; if ( $ a < 0 ) $ countOfNegative ++ ; if ( $ b < 0 ) $ countOfNegative ++ ; if ( $ c < 0 ) $ countOfNegative ++ ; switch ( $ countOfNegative ) { case 0 : return ( $ sum - $ largest ) * $ largest ; case 1 : return ( $ product / $ smallest ) + $ smallest ; case 2 : return ( $ product / $ largest ) + $ largest ; case 3 : return ( $ sum - $ smallest ) * $ smallest ; } }
function numberOfWays ( $ x ) { if ( $ x == 0 $ x == 1 ) return 1 ; else return numberOfWays ( $ x - 1 ) + ( $ x - 1 ) * numberOfWays ( $ x - 2 ) ; }
function otherNumber ( $ A , $ Lcm , $ Hcf ) { return ( $ Lcm * $ Hcf ) / $ A ; }
function findevenPair ( $ A , $ N ) { $ evenPair = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ N ; $ j ++ ) { if ( ( $ A [ $ i ] & $ A [ $ j ] ) % 2 == 0 ) $ evenPair ++ ; } } return $ evenPair ; }
function removeRecur ( $ n ) { $ prev_digit = $ n % 10 ; $ pow = 10 ; $ res = $ prev_digit ; while ( $ n ) { $ curr_digit = $ n % 10 ; if ( $ curr_digit != $ prev_digit ) { $ res += $ curr_digit * $ pow ; $ prev_digit = $ curr_digit ; $ pow *= 10 ; } $ n = $ n / 10 ; } return $ res ; }
function toggleBits ( $ n1 , $ n2 ) { return $ n1 ^ $ n2 ; }
function count1 ( $ n ) { if ( $ n < 3 ) return $ n ; if ( $ n >= 3 && $ n < 10 ) return $ n - 1 ; $ po = 1 ; for ( $ x = intval ( $ n / $ po ) ; $ x > 9 ; $ x = intval ( $ n / $ po ) ) $ po = $ po * 10 ; $ msd = intval ( $ n / $ po ) ; if ( $ msd != 3 ) return count1 ( $ msd ) * count1 ( $ po - 1 ) + count1 ( $ msd ) + count1 ( $ n % $ po ) ; else return count1 ( $ msd * $ po - 1 ) ; }
function submatrixXor ( $ arr ) { $ ans = 0 ; $ n = 3 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { $ top_left = ( $ i + 1 ) * ( $ j + 1 ) ; $ bottom_right = ( $ n - $ i ) * ( $ n - $ j ) ; if ( ( $ top_left % 2 == 1 ) && ( $ bottom_right % 2 == 1 ) ) $ ans = ( $ ans ^ $ arr [ $ i ] [ $ j ] ) ; } } return $ ans ; }
function findMaxRec ( $ A , $ n ) { if ( $ n == 1 ) return $ A [ 0 ] ; return max ( $ A [ $ n - 1 ] , findMaxRec ( $ A , $ n - 1 ) ) ; }
function answer_query ( $ a , $ n , $ l , $ r ) { $ count = 0 ; for ( $ i = $ l ; $ i < $ r ; $ i ++ ) if ( $ a [ $ i ] == $ a [ $ i + 1 ] ) $ count += 1 ; return $ count ; }
function sequence ( $ n ) { $ f = array ( 0 ) ; $ f [ 0 ] = 0 ; $ f [ 1 ] = 1 ; $ f [ 2 ] = 1 ; echo $ f [ 1 ] , " " ▁ , ▁ $ f [ 2 ] ▁ , ▁ " " for ( $ i = 3 ; $ i <= $ n ; $ i ++ ) { $ f [ $ i ] = $ f [ $ f [ $ i - 1 ] ] + $ f [ $ i - $ f [ $ i - 1 ] ] ; echo $ f [ $ i ] , " " ; } } { $ n = 13 ; sequence ( $ n ) ; return 0 ; }
function power ( $ x , $ y , $ p ) { $ res = 1 ; $ x = $ x % $ p ; if ( $ x == 0 ) return 0 ; while ( $ y > 0 ) { if ( $ y & 1 ) $ res = ( $ res * $ x ) % $ p ; y = $ y / 2 $ y = $ y >> 1 ; $ x = ( $ x * $ x ) % $ p ; } return $ res ; }
function countStrings ( $ n , $ k ) { $ dp = array_fill ( 0 , $ n + 1 , array_fill ( 0 , $ k + 1 , array_fill ( 0 , 2 , 0 ) ) ) ; $ dp [ 1 ] [ 0 ] [ 0 ] = 1 ; $ dp [ 1 ] [ 0 ] [ 1 ] = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ i ; $ j ++ ) { if ( isset ( $ dp [ $ i ] [ $ j ] [ 0 ] ) || isset ( $ dp [ $ i ] [ $ j ] [ 1 ] ) ) { $ dp [ $ i ] [ $ j ] [ 0 ] = $ dp [ $ i - 1 ] [ $ j ] [ 0 ] + $ dp [ $ i - 1 ] [ $ j ] [ 1 ] ; $ dp [ $ i ] [ $ j ] [ 1 ] = $ dp [ $ i - 1 ] [ $ j ] [ 0 ] ; } if ( $ j - 1 >= 0 && isset ( $ dp [ $ i ] [ $ j ] [ 1 ] ) ) $ dp [ $ i ] [ $ j ] [ 1 ] += $ dp [ $ i - 1 ] [ $ j - 1 ] [ 1 ] ; } } return $ dp [ $ n ] [ $ k ] [ 0 ] + $ dp [ $ n ] [ $ k ] [ 1 ] ; }
function CalPeri ( $ s ) { $ Perimeter = 10 * $ s ; echo " The ▁ Perimeter ▁ of ▁ Decagon ▁ is ▁ : ▁ $ Perimeter " ; }
function heptdiagonal ( $ a ) { if ( $ a < 0 ) return -1 ; $ d = 1.802 * $ a ; return $ d ; }
function nobleInteger ( $ arr , $ size ) { for ( $ i = 0 ; $ i < $ size ; $ i ++ ) { $ count = 0 ; for ( $ j = 0 ; $ j < $ size ; $ j ++ ) if ( $ arr [ $ i ] < $ arr [ $ j ] ) $ count ++ ; if ( $ count == $ arr [ $ i ] ) return $ arr [ $ i ] ; } return -1 ; }
function calculate_sum ( $ a , $ N ) { $ m = $ N / $ a ; $ sum = $ m * ( $ m + 1 ) / 2 ; $ ans = $ a * $ sum ; return $ ans ; }
function average ( $ arr , $ n , $ k ) { $ total = 0 ; if ( 2 * $ k >= $ n ) return 0 ; sort ( $ arr ) ; $ start = $ k ; $ end = $ n - $ k - 1 ; for ( $ i = $ start ; $ i <= $ end ; $ i ++ ) $ total += $ arr [ $ i ] ; return ( $ total / ( $ n - 2 * $ k ) ) ; }
function totalSumDivisibleByNum ( $ digit , $ number ) { $ firstnum = pow ( 10 , $ digit - 1 ) ; $ lastnum = pow ( 10 , $ digit ) ; $ firstnum = ( $ firstnum - $ firstnum % $ number ) + $ number ; $ lastnum = ( $ lastnum - $ lastnum % $ number ) ; $ count = ( ( $ lastnum - $ firstnum ) / $ number + 1 ) ; return ( ( $ lastnum + $ firstnum ) * $ count ) / 2 ; }
function countNum ( $ arr , $ n ) { $ count = 0 ; sort ( $ arr ) ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) if ( $ arr [ $ i ] != $ arr [ $ i + 1 ] && $ arr [ $ i ] != $ arr [ $ i + 1 ] - 1 ) $ count += $ arr [ $ i + 1 ] - $ arr [ $ i ] - 1 ; return $ count ; }
function printMaxNumber ( $ n ) { if ( $ n & 1 ) { echo "7" ; for ( $ i = 0 ; $ i < ( $ n - 3 ) / 2 ; $ i ++ ) echo "1" ; } else { for ( $ i = 0 ; $ i < $ n / 2 ; $ i ++ ) echo "1" ; } }
function middleOfThree ( $ a , $ b , $ c ) { if ( ( $ a < $ b && $ b < $ c ) or ( $ c < $ b && $ b < $ a ) ) return $ b ; else if ( ( $ b < $ a and $ a < $ c ) or ( $ c < $ a and $ a < $ b ) ) return $ a ; else return $ c ; }
function findPairs ( $ arr1 , $ arr2 , $ n , $ m , $ x ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ m ; $ j ++ ) if ( $ arr1 [ $ i ] + $ arr2 [ $ j ] == $ x ) echo $ arr1 [ $ i ] . " ▁ " . $ arr2 [ $ j ] . " STRNEWLINE " ; }
function check ( $ str ) { $ n = strlen ( $ str ) ; $ oddDigSum = 0 ; $ evenDigSum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ i % 2 == 0 ) $ oddDigSum += ( $ str [ $ i ] - '0' ) ; else $ evenDigSum += ( $ str [ $ i ] - '0' ) ; } return ( ( $ oddDigSum - $ evenDigSum ) % 11 == 0 ) ; }
function countPairs ( $ n ) { $ count = 0 ; for ( $ x = 1 ; $ x < $ n ; $ x ++ ) { for ( $ y = $ x + 1 ; $ y <= $ n ; $ y ++ ) { if ( ( $ y * $ x ) % ( $ y + $ x ) == 0 ) $ count ++ ; } } return $ count ; }
function maxBalancedStr ( $ s ) { $ open1 = 0 ; $ close1 = 0 ; $ open2 = 0 ; $ close2 = 0 ; $ open3 = 0 ; $ close3 = 0 ; for ( $ i = 0 ; $ i < strlen ( $ s ) ; $ i ++ ) { switch ( $ s [ $ i ] ) { case ' ( ' : $ open1 ++ ; break ; case ' ) ' : $ close1 ++ ; break ; case ' { ' : $ open2 ++ ; break ; case ' } ' : $ close2 ++ ; break ; case ' [ ' : $ open3 ++ ; break ; case ' ] ' : $ close3 ++ ; break ; } } $ maxLen = 2 * min ( $ open1 , $ close1 ) + 2 * min ( $ open2 , $ close2 ) + 2 * min ( $ open3 , $ close3 ) ; return $ maxLen ; } { $ s = " ) ) [ ] ] ( ( " ; echo ( maxBalancedStr ( $ s ) ) ; }
function findNthNonSquare ( $ n ) { $ x = $ n ; $ ans = $ x + floor ( 0.5 + sqrt ( $ x ) ) ; return ( int ) $ ans ; }
function printMedian ( $ arr , $ n , $ K ) { sort ( $ arr ) ; echo $ arr [ ( $ n + $ K ) / 2 ] ; }
function squareSum ( $ n ) { return $ n * ( 4 * $ n * $ n - 1 ) / 3 ; }
function solve_sum ( $ n ) { if ( $ n % 2 == 1 ) return ( $ n + 1 ) / 2 ; return - $ n / 2 ; }
function isDivisibleBy5 ( $ str ) { $ n = strlen ( $ str ) ; return ( ( ( $ str [ $ n - 1 ] - '0' ) == 0 ) || ( ( $ str [ $ n - 1 ] - '0' ) == 5 ) ) ; }
function checkcircle ( $ r , $ R , $ r1 , $ x1 , $ y1 ) { $ dis = sqrt ( $ x1 * $ x1 + $ y1 * $ y1 ) ; return ( $ dis - $ r1 >= $ R && $ dis + $ r1 <= $ r ) ; }
function Remainder ( $ str , $ R ) { $ len = strlen ( $ str ) ; $ Num = 0 ; $ Rem = 0 ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { $ Num = $ Rem * 10 + ( $ str [ $ i ] - '0' ) ; $ Rem = $ Num % $ R ; } return $ Rem ; }
function gcdMax ( $ a , $ b , $ n , $ N ) { $ cnt = array_fill ( 0 , $ N , 0 ) ; $ first = array_fill ( 0 , $ N , 0 ) ; $ second = array_fill ( 0 , $ N , 0 ) ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) $ cnt [ $ a [ $ i ] ] = 1 ; for ( $ i = 1 ; $ i < $ N ; ++ $ i ) for ( $ j = $ i ; $ j < $ N ; $ j += $ i ) if ( $ cnt [ $ j ] ) $ first [ $ i ] = max ( $ first [ $ i ] , $ j ) ; $ cnt = array_fill ( 0 , $ N , 0 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ cnt [ $ b [ $ i ] ] = 1 ; for ( $ i = 1 ; $ i < $ N ; $ i ++ ) for ( $ j = $ i ; $ j < $ N ; $ j += $ i ) if ( $ cnt [ $ j ] ) $ second [ $ i ] = max ( $ second [ $ i ] , $ j ) ; $ x = $ N - 1 ; for ( ; $ x >= 0 ; $ x -- ) if ( $ first [ $ x ] && $ second [ $ x ] ) break ; echo $ first [ $ x ] . " ▁ " . $ second [ $ x ] . " STRNEWLINE " ; }
function findEletobeInserted ( $ A , $ n , $ k ) { $ ans = $ k ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ ans ^= $ A [ $ i ] ; return $ ans ; }
function countPairs ( $ n ) { $ num = ( ( $ n / 2 ) + 1 ) ; $ max = $ n % $ num ; $ count = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 1 ; $ j <= $ n ; $ j ++ ) { $ val = ( ( $ n % $ i ) % $ j ) % $ n ; if ( $ val == $ max ) $ count ++ ; } } return $ count ; }
function printString ( $ str , $ n ) { $ ones = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ str [ $ i ] == '1' ) $ ones ++ ; $ used = false ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ str [ $ i ] == '2' && ! $ used ) { $ used = 1 ; for ( $ j = 0 ; $ j < $ ones ; $ j ++ ) echo "1" ; } if ( $ str [ $ i ] != '1' ) echo $ str [ $ i ] ; } if ( ! $ used ) for ( $ j = 0 ; $ j < $ ones ; $ j ++ ) echo "1" ; }
function getGreatestSum ( $ a ) { global $ N ; $ prev_max = 0 ; for ( $ j = 0 ; $ j < $ N ; $ j ++ ) if ( $ prev_max < $ a [ $ N - 1 ] [ $ j ] ) $ prev_max = $ a [ $ N - 1 ] [ $ j ] ; $ sum = $ prev_max ; for ( $ i = $ N - 2 ; $ i >= 0 ; $ i -- ) { $ curr_max = PHP_INT_MIN ; for ( $ j = 0 ; $ j < $ N ; $ j ++ ) if ( $ prev_max > $ a [ $ i ] [ $ j ] and $ a [ $ i ] [ $ j ] > $ curr_max ) $ curr_max = $ a [ $ i ] [ $ j ] ; if ( $ curr_max == PHP_INT_MIN ) return -1 ; $ prev_max = $ curr_max ; $ sum += $ prev_max ; } return $ sum ; }
function coin ( $ totalRupees , $ X , $ Y , $ Z ) { $ one = 0 ; $ fifty = 0 ; $ twentyfive = 0 ; $ result = 0 ; $ total = 0 ; $ one = $ X * 1 ; $ fifty = ( ( $ Y * 1 ) / 2.0 ) ; $ twentyfive = ( ( $ Z * 1 ) / 4.0 ) ; $ total = $ one + $ fifty + $ twentyfive ; $ result = ( ( $ totalRupees ) / $ total ) ; return $ result ; }
function countSetBitsRec ( $ num ) { global $ num_to_bits ; $ nibble = 0 ; if ( 0 == $ num ) return $ num_to_bits [ 0 ] ; $ nibble = $ num & 0xf ; return $ num_to_bits [ $ nibble ] + countSetBitsRec ( $ num >> 4 ) ; }
function surfaceArea ( $ b , $ s ) { return 2 * $ b * $ s + pow ( $ b , 2 ) ; }
function findMaxAverage ( $ arr , $ n , $ k ) { if ( $ k > $ n ) return -1 ; $ sum = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ k ; $ i ++ ) $ sum += $ arr [ $ i ] ; $ max_sum = $ sum ; $ max_end = $ k - 1 ; for ( $ i = $ k ; $ i < $ n ; $ i ++ ) { $ sum = $ sum + $ arr [ $ i ] - $ arr [ $ i - $ k ] ; if ( $ sum > $ max_sum ) { $ max_sum = $ sum ; $ max_end = $ i ; } } return $ max_end - $ k + 1 ; }
function findValue ( $ arr , $ n ) { $ ans = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ n ; $ j ++ ) $ ans = max ( $ ans , abs ( $ arr [ $ i ] - $ arr [ $ j ] ) + abs ( $ i - $ j ) ) ; return $ ans ; }
function getMinVal ( $ p , $ q ) { if ( $ q % $ p == 0 ) return $ p ; return -1 ; }
function checkSame ( $ n ) { $ set = 0 ; $ unset = 0 ; while ( $ n ) { if ( $ n & 1 ) $ set ++ ; else $ unset ++ ; $ n = $ n >> 1 ; } if ( $ set == $ unset ) return true ; else return false ; }
function countSort ( $ arr ) { global $ RANGE ; $ output = array ( strlen ( $ arr ) ) ; $ len = strlen ( $ arr ) ; $ count = array_fill ( 0 , $ RANGE + 1 , 0 ) ; for ( $ i = 0 ; $ i < $ len ; ++ $ i ) ++ $ count [ ord ( $ arr [ $ i ] ) ] ; for ( $ i = 1 ; $ i <= $ RANGE ; ++ $ i ) $ count [ $ i ] += $ count [ $ i - 1 ] ; for ( $ i = $ len - 1 ; $ i >= 0 ; $ i -- ) { $ output [ $ count [ ord ( $ arr [ $ i ] ) ] - 1 ] = $ arr [ $ i ] ; -- $ count [ ord ( $ arr [ $ i ] ) ] ; } for ( $ i = 0 ; $ i < $ len ; ++ $ i ) $ arr [ $ i ] = $ output [ $ i ] ; return $ arr ; }
function ksmallest ( $ arr , $ n , $ k ) { sort ( $ arr ) ; if ( $ k < $ arr [ 0 ] ) return $ k ; if ( $ k == $ arr [ 0 ] ) return $ arr [ 0 ] + 1 ; if ( $ k > $ arr [ $ n - 1 ] ) return $ k + $ n ; if ( $ arr [ 0 ] == 1 ) $ k -- ; else $ k -= ( $ arr [ 0 ] - 1 ) ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ c = $ arr [ $ i ] - $ arr [ $ i - 1 ] - 1 ; if ( $ k <= $ c ) return $ arr [ $ i - 1 ] + $ k ; else $ k -= $ c ; } return $ arr [ $ n - 1 ] + $ k ; }
function calculateProduct ( $ A , $ L , $ R , $ P ) { $ L = $ L - 1 ; $ R = $ R - 1 ; $ ans = 1 ; for ( $ i = $ L ; $ i <= $ R ; $ i ++ ) { $ ans = $ ans * $ A [ $ i ] ; $ ans = $ ans % $ P ; } return $ ans ; }
function LucasSum ( $ N ) { $ sum = 0 ; $ a = 2 ; $ b = 1 ; $ c ; $ sum += $ a ; while ( $ b <= $ N ) { $ sum += $ b ; $ c = $ a + $ b ; $ a = $ b ; $ b = $ c ; } return $ sum ; }
function centeredTridecagonalNum ( $ n ) { return ( 13 * $ n * ( $ n - 1 ) + 2 ) / 2 ; }
function vol_tetra ( $ side ) { $ volume = ( pow ( $ side , 3 ) / ( 6 * sqrt ( 2 ) ) ) ; return $ volume ; }
function check ( $ str ) { $ n = strlen ( $ str ) ; if ( $ n == 0 && $ n == 1 ) return false ; if ( $ n == 2 ) return ( ( ( $ str [ $ n - 2 ] - '0' ) * 10 + ( $ str [ $ n - 1 ] - '0' ) ) % 16 == 0 ) ; if ( $ n == 3 ) return ( ( ( $ str [ $ n - 3 ] - '0' ) * 100 + ( $ str [ $ n - 2 ] - '0' ) * 10 + ( $ str [ $ n - 1 ] - '0' ) ) % 16 == 0 ) ; $ last = $ str [ $ n - 1 ] - '0' ; $ second_last = $ str [ $ n - 2 ] - '0' ; $ third_last = $ str [ $ n - 3 ] - '0' ; $ fourth_last = $ str [ $ n - 4 ] - '0' ; return ( ( $ fourth_last * 1000 + $ third_last * 100 + $ second_last * 10 + $ last ) % 16 == 0 ) ; }
function findS ( $ s ) { $ sum = 0 ; for ( $ n = 1 ; $ sum < $ s ; $ n ++ ) { $ sum += $ n ; if ( $ sum == $ s ) return $ n ; } return -1 ; }
function MaximumHeight ( $ a , $ n ) { $ result = 1 ; for ( $ i = 1 ; $ i <= $ n ; ++ $ i ) { $ y = ( $ i * ( $ i + 1 ) ) / 2 ; if ( $ y < $ n ) $ result = $ i ; else break ; } return $ result ; }
function calculateSum ( $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sum = $ sum + ( 1 << $ i ) ; } return $ sum ; }
function countNumbers ( $ n ) { return ( int ) ( $ n - $ n / 2 ) - ( int ) ( $ n / 3 ) - ( int ) ( $ n / 5 ) - ( int ) ( $ n / 7 ) + ( int ) ( $ n / 6 ) + ( int ) ( $ n / 10 ) + ( int ) ( $ n / 14 ) + ( int ) ( $ n / 15 ) + ( int ) ( $ n / 21 ) + ( int ) ( $ n / 35 ) - ( int ) ( $ n / 30 ) - ( int ) ( $ n / 42 ) - ( int ) ( $ n / 70 ) - ( int ) ( $ n / 105 ) + ( int ) ( $ n / 210 ) ; }
function lengtang ( $ r1 , $ r2 ) { echo " The ▁ length ▁ of ▁ the ▁ " , " direct ▁ common ▁ tangent ▁ is ▁ " , 2 * sqrt ( $ r1 * $ r2 ) ; }
function isEven ( $ n ) { $ isEven = true ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ isEven = ! $ isEven ; return $ isEven ; }
function search ( $ pat , $ txt ) { $ M = strlen ( $ pat ) ; $ N = strlen ( $ txt ) ; for ( $ i = 0 ; $ i <= $ N - $ M ; $ i ++ ) { for ( $ j = 0 ; $ j < $ M ; $ j ++ ) if ( $ txt [ $ i + $ j ] != $ pat [ $ j ] ) break ; if ( $ j == $ M ) echo " Pattern ▁ found ▁ at ▁ index ▁ " , $ i . " STRNEWLINE " ; } }
function isIdentity ( $ mat , $ N ) { for ( $ row = 0 ; $ row < $ N ; $ row ++ ) { for ( $ col = 0 ; $ col < $ N ; $ col ++ ) { if ( $ row == $ col and $ mat [ $ row ] [ $ col ] != 1 ) return false ; else if ( $ row != $ col && $ mat [ $ row ] [ $ col ] != 0 ) return false ; } } return true ; }
function distance ( $ a1 , $ b1 , $ c1 , $ d1 , $ a2 , $ b2 , $ c2 , $ d2 ) { if ( $ a1 / $ a2 == $ b1 / $ b2 && $ b1 / $ b2 == $ c1 / $ c2 ) { $ x1 = $ y1 = 0 ; $ z1 = - $ d1 / $ c1 ; $ d = abs ( ( $ c2 * $ z1 + $ d2 ) ) / ( sqrt ( $ a2 * $ a2 + $ b2 * $ b2 + $ c2 * $ c2 ) ) ; echo " Perpendicular ▁ distance ▁ is ▁ " , $ d ; } else echo " Planes ▁ are ▁ not ▁ parallel " ; }
function maxCost ( $ mat , $ N ) { $ dp = array ( array ( ) ) ; memset ( dp , 0 , sizeof ( dp ) ) ; $ dp [ 0 ] [ 0 ] = $ mat [ 0 ] [ 0 ] ; for ( $ i = 1 ; $ i < $ N ; $ i ++ ) $ dp [ $ i ] [ 0 ] = $ mat [ $ i ] [ 0 ] + $ dp [ $ i - 1 ] [ 0 ] ; for ( $ i = 1 ; $ i < $ N ; $ i ++ ) { for ( $ j = 1 ; $ j < $ i + 1 && $ j < $ N ; $ j ++ ) $ dp [ $ i ] [ $ j ] = $ mat [ $ i ] [ $ j ] + max ( $ dp [ $ i - 1 ] [ $ j - 1 ] , $ dp [ $ i - 1 ] [ $ j ] ) ; } $ result = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) if ( $ result < $ dp [ $ N - 1 ] [ $ i ] ) $ result = $ dp [ $ N - 1 ] [ $ i ] ; return $ result ; }
function printFourSquares ( $ a ) { for ( $ i = 0 ; $ i * $ i <= $ a ; $ i ++ ) { for ( $ j = $ i ; $ j * $ j <= $ a ; $ j ++ ) { for ( $ k = $ j ; $ k * $ k <= $ a ; $ k ++ ) { for ( $ l = $ k ; $ l * $ l <= $ a ; $ l ++ ) { if ( $ i * $ i + $ j * $ j + $ k * $ k + $ l * $ l == $ a ) { echo $ a , " = " ▁ , ▁ $ i ▁ , ▁ " * " ▁ , $ i , STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL " + " ▁ , ▁ $ j ▁ , ▁ " * " ▁ , ▁ $ j ▁ , ▁ " + " echo $ k , " * " ▁ , ▁ $ k ▁ , ▁ " + " $ l , " * " , $ l , " STRNEWLINE " ; } } } } } }
function calcSafe ( $ pos ) { $ j = $ pos % 10 ; $ i = $ pos / 10 ; $ dis_11 = min ( abs ( 1 - $ i ) , abs ( 1 - $ j ) ) ; $ dis_18 = min ( abs ( 1 - $ i ) , abs ( 8 - $ j ) ) ; $ dis_81 = min ( abs ( 8 - $ i ) , abs ( 1 - $ j ) ) ; $ dis_88 = min ( abs ( 8 - $ i ) , abs ( 8 - $ j ) ) ; $ sum = $ dis_11 + $ dis_18 + $ dis_81 + $ dis_88 + 1 ; return ceil ( 64 - $ sum ) ; }
function fitOrNotFit ( $ R , $ r , $ x , $ y , $ rad ) { $ val = sqrt ( pow ( $ x , 2 ) + pow ( $ y , 2 ) ) ; if ( $ val + $ rad <= $ R && $ val - $ rad >= $ R - $ r ) echo " Fits STRNEWLINE " ; else echo " Doesn ' t ▁ Fit STRNEWLINE " ; }
function sumOfDigitsFrom1ToN ( $ n ) { if ( $ n < 10 ) return ( $ n * ( $ n + 1 ) / 2 ) ; $ d = ( int ) ( log10 ( $ n ) ) ; $ a [ $ d + 1 ] = array ( ) ; $ a [ 0 ] = 0 ; $ a [ 1 ] = 45 ; for ( $ i = 2 ; $ i <= $ d ; $ i ++ ) $ a [ $ i ] = $ a [ $ i - 1 ] * 10 + 45 * ( int ) ( ceil ( pow ( 10 , $ i - 1 ) ) ) ; $ p = ( int ) ( ceil ( pow ( 10 , $ d ) ) ) ; $ msd = ( int ) ( $ n / $ p ) ; return ( $ msd * $ a [ $ d ] + ( $ msd * ( int ) ( $ msd - 1 ) / 2 ) * $ p + $ msd * ( 1 + $ n % $ p ) + sumOfDigitsFrom1ToN ( $ n % $ p ) ) ; }
function trianglearea ( $ a , $ b ) { if ( $ a < 0 $ b < 0 ) return -1 ; $ area = ( 3 * sqrt ( 3 ) * pow ( $ a , 2 ) ) / ( 4 * $ b ) ; return $ area ; }
function exponentMod ( $ A , $ B , $ C ) { if ( $ A == 0 ) return 0 ; if ( $ B == 0 ) return 1 ; if ( $ B % 2 == 0 ) { $ y = exponentMod ( $ A , $ B / 2 , $ C ) ; $ y = ( $ y * $ y ) % $ C ; } else { $ y = $ A % $ C ; $ y = ( $ y * exponentMod ( $ A , $ B - 1 , $ C ) % $ C ) % $ C ; } return ( ( $ y + $ C ) % $ C ) ; }
function lastCoordinate ( $ n , $ a , $ b ) { return ( ( $ n + 1 ) / 2 ) * $ a - ( int ) ( $ n / 2 ) * $ b ; }
function maxAbsDiff ( $ arr , $ n ) { $ minEle = $ arr [ 0 ] ; $ maxEle = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ minEle = min ( $ minEle , $ arr [ $ i ] ) ; $ maxEle = max ( $ maxEle , $ arr [ $ i ] ) ; } return ( $ maxEle - $ minEle ) ; }
function largestCube ( $ r ) { if ( $ r < 0 ) return -1 ; $ a = ( float ) ( ( 2 * $ r ) / sqrt ( 3 ) ) ; return $ a ; }
function checkPowerof8 ( $ n ) { $ i = log ( $ n ) / log ( 8 ) ; return ( $ i - floor ( $ i ) < 0.000001 ) ; }
function getInvCount ( & $ arr , $ n ) { $ inv_count = 0 ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) if ( $ arr [ $ i ] > $ arr [ $ j ] ) $ inv_count ++ ; return $ inv_count ; }
function onlyFirstAndLastAreSet ( $ n ) { if ( $ n == 1 ) return true ; if ( $ n == 2 ) return false ; return ( ( ( $ n - 1 ) & ( $ n - 2 ) ) == 0 ) ; }
function getMinCost ( $ n , $ m ) { $ cost = ( $ n - 1 ) * $ m + ( $ m - 1 ) * $ n ; return $ cost ; }
function minimum ( $ n ) { $ product = 1 ; for ( $ i = 2 ; $ i * $ i <= $ n ; $ i ++ ) { if ( $ n % $ i == 0 ) { while ( $ n % $ i == 0 ) $ n = $ n / $ i ; $ product = $ product * $ i ; } } if ( $ n >= 2 ) $ product = $ product * $ n ; return $ product ; }
function minAbsDiff ( $ n ) { $ mod = $ n % 4 ; if ( $ mod == 0 $ mod == 3 ) return 0 ; return 1 ; }
function centeredTetrahedralNumber ( $ n ) { return ( 2 * $ n + 1 ) * ( $ n * $ n + $ n + 3 ) / 3 ; }
function countPairs ( $ A , $ n , $ k ) { $ ans = 0 ; sort ( $ A ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) { $ x = 0 ; while ( ( $ A [ $ i ] * pow ( $ k , $ x ) ) <= $ A [ $ j ] ) { if ( ( $ A [ $ i ] * pow ( $ k , $ x ) ) == $ A [ $ j ] ) { $ ans ++ ; break ; } $ x ++ ; } } } return $ ans ; }
function countLattice ( $ r ) { if ( $ r <= 0 ) return 0 ; $ result = 4 ; for ( $ x = 1 ; $ x < $ r ; $ x ++ ) { $ ySquare = $ r * $ r - $ x * $ x ; $ y = ceil ( sqrt ( $ ySquare ) ) ; if ( $ y * $ y == $ ySquare ) $ result += 4 ; } return $ result ; }
function largestGCDSubsequence ( $ arr , $ n ) { $ ans = 0 ; $ maxele = max ( $ arr ) ; for ( $ i = 2 ; $ i <= $ maxele ; ++ $ i ) { $ count = 0 ; for ( $ j = 0 ; $ j < $ n ; ++ $ j ) { if ( $ arr [ $ j ] % $ i == 0 ) ++ $ count ; } $ ans = max ( $ ans , $ count ) ; } return $ ans ; }
function countNums ( $ n , $ x , $ y ) { $ arr = array_fill ( 0 , $ n + 1 , false ) ; if ( $ x <= $ n ) $ arr [ $ x ] = true ; if ( $ y <= $ n ) $ arr [ $ y ] = true ; $ result = 0 ; for ( $ i = min ( $ x , $ y ) ; $ i <= $ n ; $ i ++ ) { if ( $ arr [ $ i ] ) { if ( $ i + $ x <= $ n ) $ arr [ $ i + $ x ] = true ; if ( $ i + $ y <= $ n ) $ arr [ $ i + $ y ] = true ; $ result ++ ; } } return $ result ; }
function generateSequence ( $ n , $ g ) { for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) echo $ i * $ g . " ▁ " ; }
function check ( $ str ) { $ n = strlen ( $ str ) ; if ( $ n == 0 ) return false ; if ( $ n == 1 ) return ( ( $ str [ 0 ] - '0' ) % 8 == 0 ) ; if ( $ n == 2 ) return ( ( ( $ str [ $ n - 2 ] - '0' ) * 10 + ( $ str [ $ n - 1 ] - '0' ) ) % 8 == 0 ) ; $ last = $ str [ $ n - 1 ] - '0' ; $ second_last = $ str [ $ n - 2 ] - '0' ; $ third_last = $ str [ $ n - 3 ] - '0' ; return ( ( $ third_last * 100 + $ second_last * 10 + $ last ) % 8 == 0 ) ; }
function sum ( $ x , $ y , $ n ) { $ sum1 = ( pow ( $ x , 2 ) * ( pow ( $ x , 2 * $ n ) - 1 ) ) / ( pow ( $ x , 2 ) - 1 ) ; $ sum2 = ( $ x * $ y * ( pow ( $ x , $ n ) * pow ( $ y , $ n ) - 1 ) ) / ( $ x * $ y - 1 ) ; return $ sum1 + $ sum2 ; }
function countRotations ( $ arr , $ n ) { $ min = $ arr [ 0 ] ; $ min_index ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ min > $ arr [ $ i ] ) { $ min = $ arr [ $ i ] ; $ min_index = $ i ; } } return $ min_index ; }
function check ( $ N , $ D ) { $ temp = ( $ N * ( $ N + 1 ) ) / 2 + $ D ; return ( $ temp % 2 == 0 ) ; }
function sumofsquare ( $ n ) { $ i ; $ j ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 0 ; $ j <= min ( $ i , $ n ) ; $ j ++ ) { if ( $ j == 0 $ j == $ i ) $ C [ $ i ] [ $ j ] = 1 ; else $ C [ $ i ] [ $ j ] = $ C [ $ i - 1 ] [ $ j - 1 ] + $ C [ $ i - 1 ] [ $ j ] ; } } $ sum = 0 ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) $ sum += ( $ C [ $ n ] [ $ i ] * $ C [ $ n ] [ $ i ] ) ; return $ sum ; }
function getInvCount ( $ arr , $ n ) { $ invcount = 0 ; for ( $ i = 1 ; $ i < $ n - 1 ; $ i ++ ) { $ small = 0 ; for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) if ( $ arr [ $ i ] > $ arr [ $ j ] ) $ small ++ ; $ great = 0 ; for ( $ j = $ i - 1 ; $ j >= 0 ; $ j -- ) if ( $ arr [ $ i ] < $ arr [ $ j ] ) $ great ++ ; $ invcount += $ great * $ small ; } return $ invcount ; }
function isEven ( $ n ) { return ( ( int ) ( $ n / 2 ) * 2 == $ n ) ; }
function divide ( $ dividend , $ divisor ) { $ sign = ( ( $ dividend < 0 ) ^ ( $ divisor < 0 ) ) ? -1 : 1 ; $ dividend = abs ( $ dividend ) ; $ divisor = abs ( $ divisor ) ; $ quotient = 0 ; $ temp = 0 ; for ( $ i = 31 ; $ i >= 0 ; -- $ i ) { if ( $ temp + ( $ divisor << $ i ) <= $ dividend ) { $ temp += $ divisor << $ i ; $ quotient |= ( double ) ( 1 ) << $ i ; } } if ( $ sign == -1 ) $ quotient = - $ quotient ; return $ quotient ; }
function sumBitDifferences ( $ arr , $ n ) { $ ans = 0 ; for ( $ i = 0 ; $ i < 32 ; $ i ++ ) { $ count = 0 ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) if ( ( $ arr [ $ j ] & ( 1 << $ i ) ) ) $ count ++ ; $ ans += ( $ count * ( $ n - $ count ) * 2 ) ; } return $ ans ; }
function nthElement ( $ a , $ b , $ n ) { $ seq = array ( ) ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) array_push ( $ seq , $ a * $ i ) ; sort ( $ seq ) ; for ( $ i = 1 , $ k = $ n ; $ i <= $ n && $ k > 0 ; $ i ++ ) { if ( array_search ( $ b * $ i , $ seq ) == 0 ) { array_push ( $ seq , $ b * $ i ) ; sort ( $ seq ) ; $ k -- ; } } return $ seq [ $ n - 1 ] ; }
function countAnomalies ( & $ arr , $ n , $ k ) { $ res = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) if ( $ i != $ j && abs ( $ arr [ $ i ] - $ arr [ $ j ] ) <= $ k ) break ; if ( $ j == $ n ) $ res ++ ; } return $ res ; }
function sumOddFibonacci ( $ n ) { global $ mod ; $ Sum [ $ n + 1 ] = array ( ) ; $ Sum [ 0 ] = 0 ; $ Sum [ 1 ] = 1 ; $ Sum [ 2 ] = 2 ; $ Sum [ 3 ] = 5 ; $ Sum [ 4 ] = 10 ; $ Sum [ 5 ] = 23 ; for ( $ i = 6 ; $ i <= $ n ; $ i ++ ) { $ Sum [ $ i ] = ( ( $ Sum [ $ i - 1 ] + ( 4 * $ Sum [ $ i - 2 ] ) % $ mod - ( 4 * $ Sum [ $ i - 3 ] ) % $ mod + $ mod ) % $ mod + ( $ Sum [ $ i - 4 ] - $ Sum [ $ i - 5 ] + $ mod ) % $ mod ) % $ mod ; } return $ Sum [ $ n ] ; }
function calcNodes ( $ N , $ I ) { $ result = 0 ; $ result = $ I * ( $ N - 1 ) + 1 ; return $ result ; }
function binomialCoeff ( $ n , $ k ) { if ( $ k > $ n ) return 0 ; $ res = 1 ; if ( $ k > $ n - $ k ) $ k = $ n - $ k ; for ( $ i = 0 ; $ i < $ k ; ++ $ i ) { $ res *= ( $ n - $ i ) ; $ res /= ( $ i + 1 ) ; } return $ res ; }
function findMaxSum ( $ arr , $ n ) { $ res = PHP_INT_MIN ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ prefix_sum = $ arr [ $ i ] ; for ( $ j = 0 ; $ j < $ i ; $ j ++ ) $ prefix_sum += $ arr [ $ j ] ; $ suffix_sum = $ arr [ $ i ] ; for ( $ j = $ n - 1 ; $ j > $ i ; $ j -- ) $ suffix_sum += $ arr [ $ j ] ; if ( $ prefix_sum == $ suffix_sum ) $ res = max ( $ res , $ prefix_sum ) ; } return $ res ; }
function countValues ( $ n ) { $ countV = 0 ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) if ( ( $ n + $ i ) == ( $ n ^ $ i ) ) $ countV ++ ; return $ countV ; }
function countBuildings ( $ arr , $ n ) { $ count = 1 ; $ curr_max = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] > $ curr_max $ arr [ $ i ] == $ curr_max ) { $ count ++ ; $ curr_max = $ arr [ $ i ] ; } } return $ count ; }
function noOfYears ( $ t1 , $ n1 , $ t2 ) { $ years = ( ( $ t2 - 1 ) * $ n1 / ( $ t1 - 1 ) ) ; return $ years ; }
function countAnomalies ( $ arr , $ n , $ k ) { $ cnt = 0 ; $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum += $ arr [ $ i ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( abs ( $ arr [ $ i ] - ( $ sum - $ arr [ $ i ] ) ) > $ k ) $ cnt ++ ; return $ cnt ; }
function minOperation ( & $ arr ) { global $ N , $ M ; $ ans = 0 ; for ( $ i = $ N - 1 ; $ i >= 0 ; $ i -- ) { for ( $ j = $ M - 1 ; $ j >= 0 ; $ j -- ) { if ( $ arr [ $ i ] [ $ j ] == 0 ) { $ ans ++ ; for ( $ k = 0 ; $ k <= $ i ; $ k ++ ) { for ( $ h = 0 ; $ h <= $ j ; $ h ++ ) { if ( $ arr [ $ k ] [ $ h ] == 1 ) $ arr [ $ k ] [ $ h ] = 0 ; else $ arr [ $ k ] [ $ h ] = 1 ; } } } } } return $ ans ; }
function printTriplets ( & $ arr , $ n , $ sum ) { for ( $ i = 0 ; $ i < $ n - 2 ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ n - 1 ; $ j ++ ) { for ( $ k = $ j + 1 ; $ k < $ n ; $ k ++ ) if ( $ arr [ $ i ] + $ arr [ $ j ] + $ arr [ $ k ] < $ sum ) { echo ( $ arr [ $ i ] ) ; echo ( " , ▁ " ) ; echo ( $ arr [ $ j ] ) ; echo ( " , ▁ " ) ; echo ( $ arr [ $ k ] ) ; echo ( " STRNEWLINE " ) ; } } } }
function findLongestRepeatingSubSeq ( $ str ) { $ n = strlen ( $ str ) ; $ dp = array ( array ( ) ) ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) for ( $ j = 0 ; $ j <= $ n ; $ j ++ ) $ dp [ $ i ] [ $ j ] = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 1 ; $ j <= $ n ; $ j ++ ) { if ( $ str [ $ i - 1 ] == $ str [ $ j - 1 ] && $ i != $ j ) $ dp [ $ i ] [ $ j ] = 1 + $ dp [ $ i - 1 ] [ $ j - 1 ] ; else $ dp [ $ i ] [ $ j ] = max ( $ dp [ $ i ] [ $ j - 1 ] , $ dp [ $ i - 1 ] [ $ j ] ) ; } } return $ dp [ $ n ] [ $ n ] ; }
function find ( $ n ) { $ b = $ n ; $ a = $ b * ( $ n - 1 ) ; if ( $ a * $ b > $ n && $ a / $ b < $ n ) { echo " a = " ▁ , ▁ $ a ▁ , ▁ " , b = " } else echo - 1 ; }
function findWaysToPair ( $ p ) { $ dp = array ( ) ; $ dp [ 1 ] = 1 ; $ dp [ 2 ] = 2 ; for ( $ i = 3 ; $ i <= $ p ; $ i ++ ) { $ dp [ $ i ] = $ dp [ $ i - 1 ] + ( $ i - 1 ) * $ dp [ $ i - 2 ] ; } return $ dp [ $ p ] ; }
function printCombination ( $ n ) { echo "1 ▁ " ; if ( ( $ n - 2 ) % 3 == 0 ) echo "2 ▁ " . ( $ n - 3 ) ; else echo "1 ▁ " . ( $ n - 2 ) ; }
function countSteps ( $ x , $ y ) { if ( $ x < $ y ) { return $ x + $ y + 2 * ( ( $ y - $ x ) / 2 ) ; } else { return $ x + $ y + 2 * ( ( ( $ x - $ y ) + 1 ) / 2 ) ; } }
function minMovesToSort ( $ arr , $ n ) { $ moves = 0 ; $ mn = $ arr [ $ n - 1 ] ; for ( $ i = $ n - 2 ; $ i >= 0 ; $ i -- ) { if ( $ arr [ $ i ] > $ mn ) $ moves += $ arr [ $ i ] - $ mn ; } return $ moves ; }
function MinOperation ( $ a , $ n , $ k ) { $ result = 0 ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { if ( $ a [ $ i ] != 1 && $ a [ $ i ] > $ k ) { $ result = $ result + min ( $ a [ $ i ] % $ k , $ k - $ a [ $ i ] % $ k ) ; } else { $ result = $ result + $ k - $ a [ $ i ] ; } } return $ result ; }
function maxProduct ( $ arr , $ n ) { if ( $ n < 4 ) return -1 ; sort ( $ arr ) ; $ x = $ arr [ $ n - 1 ] * $ arr [ $ n - 2 ] * $ arr [ $ n - 3 ] * $ arr [ $ n - 4 ] ; $ y = $ arr [ 0 ] * $ arr [ 1 ] * $ arr [ 2 ] * $ arr [ 3 ] ; $ z = $ arr [ 0 ] * $ arr [ 1 ] * $ arr [ $ n - 1 ] * $ arr [ $ n - 2 ] ; return max ( $ x , max ( $ y , $ z ) ) ; }
function minMaxProduct ( $ arr1 , $ arr2 , $ n1 , $ n2 ) { sort ( $ arr1 ) ; sort ( $ arr2 ) ; return $ arr1 [ $ n1 - 1 ] * $ arr2 [ 0 ] ; }
function printThreeParts ( $ N ) { if ( $ N % 3 == 0 ) echo " ▁ x ▁ = ▁ 1 , ▁ y ▁ = ▁ 1 , ▁ z ▁ = ▁ " . ( $ N - 2 ) . " STRNEWLINE " ; else echo " ▁ x ▁ = ▁ 1 , ▁ y ▁ = ▁ 2 , ▁ z ▁ = ▁ " . ( $ N - 3 ) . " STRNEWLINE " ; }
function getTotalXorOfSubarrayXors ( $ arr , $ N ) { if ( $ N % 2 == 0 ) return 0 ; $ res = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i += 2 ) $ res ^= $ arr [ $ i ] ; return $ res ; }
function calculateSum ( $ n ) { if ( $ n <= 0 ) return 0 ; $ fibo [ 0 ] = 0 ; $ fibo [ 1 ] = 1 ; $ sum = $ fibo [ 0 ] + $ fibo [ 1 ] ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { $ fibo [ $ i ] = $ fibo [ $ i - 1 ] + $ fibo [ $ i - 2 ] ; $ sum += $ fibo [ $ i ] ; } return $ sum ; }
function maxSum ( $ n ) { if ( $ n == 1 ) return 1 ; else return ( $ n * ( $ n - 1 ) / 2 ) - 1 + $ n / 2 ; }
function isWoodall ( $ x ) { if ( $ x % 2 == 0 ) return false ; if ( $ x == 1 ) return true ; $ x ++ ; $ p = 0 ; while ( $ x % 2 == 0 ) { $ x = $ x / 2 ; $ p ++ ; if ( $ p == $ x ) return true ; } return false ; }
function printLines ( $ n , $ k ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { echo ( $ k * ( 6 * $ i + 1 ) ) ; echo ( " ▁ " ) ; echo ( $ k * ( 6 * $ i + 2 ) ) ; echo ( " ▁ " ) ; echo ( $ k * ( 6 * $ i + 3 ) ) ; echo ( " ▁ " ) ; echo ( $ k * ( 6 * $ i + 5 ) ) ; echo ( " STRNEWLINE " ) ; } }
function snoob ( $ x ) { $ next = 0 ; if ( $ x ) { $ rightOne = $ x & - $ x ; $ nextHigherOneBit = $ x + $ rightOne ; $ rightOnesPattern = $ x ^ $ nextHigherOneBit ; $ rightOnesPattern = intval ( ( $ rightOnesPattern ) / $ rightOne ) ; $ rightOnesPattern >>= 2 ; $ next = $ nextHigherOneBit | $ rightOnesPattern ; } return $ next ; }
function isPower ( $ x , $ y ) { $ res1 = log ( $ y ) / log ( $ x ) ; $ res2 = log ( $ y ) / log ( $ x ) ; return ( $ res1 == $ res2 ) ; }
function shortdis ( $ r , $ d ) { echo " The ▁ shortest ▁ distance ▁ " ; echo " from ▁ the ▁ chord ▁ to ▁ centre ▁ " ; echo sqrt ( ( $ r * $ r ) - ( ( $ d * $ d ) / 4 ) ) ; }
function countSetBits ( $ n ) { if ( $ n == 0 ) return 0 ; else return 1 + countSetBits ( $ n & ( $ n - 1 ) ) ; }
function remAnagram ( $ str1 , $ str2 ) { $ count1 = array ( 26 ) ; $ count2 = array ( 26 ) ; for ( $ i = 0 ; $ i < strlen ( $ str1 ) ; $ i ++ ) $ count1 [ $ str1 [ $ i ] - ' a ' ] ++ ; for ( $ i = 0 ; $ i < strlen ( $ str2 ) ; $ i ++ ) $ count2 [ $ str2 [ $ i ] - ' a ' ] ++ ; $ result = 0 ; for ( $ i = 0 ; $ i < 26 ; $ i ++ ) $ result += abs ( $ count1 [ $ i ] - $ count2 [ $ i ] ) ; return $ result ; } { $ str1 = " bcadeh " ; $ str2 = " hea " ; echo ( remAnagram ( $ str1 , $ str2 ) ) ; }
function squarearea ( $ r ) { if ( $ r < 0 ) return -1 ; $ a = 4 * ( pow ( $ r , 2 ) / 5 ) ; return $ a ; }
function maxSubArraySum ( $ a , $ size ) { $ max_so_far = PHP_INT_MIN ; $ max_ending_here = 0 ; for ( $ i = 0 ; $ i < $ size ; $ i ++ ) { $ max_ending_here = $ max_ending_here + $ a [ $ i ] ; if ( $ max_so_far < $ max_ending_here ) $ max_so_far = $ max_ending_here ; if ( $ max_ending_here < 0 ) $ max_ending_here = 0 ; } return $ max_so_far ; }
function findLargestDivisor ( $ n ) { for ( $ i = 2 ; $ i < sqrt ( $ n ) + 1 ; $ i ++ ) { while ( $ n % ( $ i * $ i ) == 0 ) { $ n = $ n / $ i ; } } return $ n ; }
function countIntegralSolutions ( $ n ) { return ( ( $ n + 1 ) * ( $ n + 2 ) ) / 2 ; }
function countt ( $ n ) { $ dp [ $ n + 1 ] = 0 ; $ dp [ 0 ] = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { if ( $ i >= 1 && $ i <= 3 ) $ dp [ $ i ] = 1 ; else if ( $ i == 4 ) $ dp [ $ i ] = 2 ; else $ dp [ $ i ] = $ dp [ $ i - 1 ] + $ dp [ $ i - 4 ] ; } return $ dp [ $ n ] ; }
function maxDP ( $ n ) { $ res [ 0 ] = 0 ; $ res [ 1 ] = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) $ res [ $ i ] = max ( $ i , ( $ res [ $ i / 2 ] + $ res [ $ i / 3 ] + $ res [ $ i / 4 ] + $ res [ $ i / 5 ] ) ) ; return $ res [ $ n ] ; }
function findSum ( $ n ) { return ( $ n * ( pow ( $ n , 2 ) + 3 * $ n + 5 ) ) / 3 ; }
function Series ( $ n ) { $ i ; $ sums = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ sums += ( $ i * $ i ) ; return $ sums ; }
function setallbitgivenrange ( $ n , $ l , $ r ) { $ range = ( ( ( 1 << ( $ l - 1 ) ) - 1 ) ^ ( ( 1 << ( $ r ) ) - 1 ) ) ; return ( $ n $ range ) ; }
function isPanalphabeticWindow ( $ s , $ n ) { $ ch = ' a ' ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ s [ $ i ] == $ ch ) $ ch ++ ; if ( $ ch == ' z ' ) return true ; } return false ; }
function computeXOR ( $ n ) { $ x = $ n & 3 ; switch ( $ x ) { case 0 : return $ n ; case 1 : return 1 ; case 2 : return $ n + 1 ; case 3 : return 0 ; } return 0 ; }
function ceilSearch ( $ arr , $ low , $ high , $ x ) { $ mid ; if ( $ x <= $ arr [ $ low ] ) return $ low ; if ( $ x > $ arr [ $ high ] ) return -1 ; $ mid = ( $ low + $ high ) / 2 ; if ( $ arr [ $ mid ] == $ x ) return $ mid ; else if ( $ arr [ $ mid ] < $ x ) { if ( $ mid + 1 <= $ high && $ x <= $ arr [ $ mid + 1 ] ) return $ mid + 1 ; else return ceilSearch ( $ arr , $ mid + 1 , $ high , $ x ) ; } else { if ( $ mid - 1 >= $ low && $ x > $ arr [ $ mid - 1 ] ) return $ mid ; else return ceilSearch ( $ arr , $ low , $ mid - 1 , $ x ) ; } }
function maxTripletSum ( $ arr , $ n ) { $ sum = PHP_INT_MIN ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) for ( $ k = $ j + 1 ; $ k < $ n ; $ k ++ ) if ( $ sum < $ arr [ $ i ] + $ arr [ $ j ] + $ arr [ $ k ] ) $ sum = $ arr [ $ i ] + $ arr [ $ j ] + $ arr [ $ k ] ; return $ sum ; }
function solve ( $ M , $ N , $ s ) { $ ans = ( ( int ) ( ceil ( $ M / $ s ) ) * ( int ) ( ceil ( $ N / $ s ) ) ) ; return $ ans ; }
function gcd ( $ a , $ b ) { if ( $ a == 0 && $ b == 0 ) return 0 ; if ( $ a == 0 ) return $ b ; if ( $ b == 0 ) return $ a ; if ( $ a == $ b ) return $ a ; if ( $ a > $ b ) return gcd ( $ a - $ b , $ b ) ; return gcd ( $ a , $ b - $ a ) ; }
function polygonArea ( $ X , $ Y , $ n ) { $ area = 0.0 ; $ j = $ n - 1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ area += ( $ X [ $ j ] + $ X [ $ i ] ) * ( $ Y [ $ j ] - $ Y [ $ i ] ) ; $ j = $ i ; } return abs ( $ area / 2.0 ) ; }
function findNature ( $ a , $ b , $ n ) { global $ MAX ; $ seq = array_fill ( 0 , $ MAX , 0 ) ; $ seq [ 0 ] = $ a ; $ seq [ 1 ] = $ b ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) $ seq [ $ i ] = $ seq [ $ i - 1 ] + $ seq [ $ i - 2 ] ; return ( $ seq [ $ n ] & 1 ) ; }
function asciiToSentence ( $ string , $ length ) { $ num = 0 ; for ( $ i = 0 ; $ i < $ length ; $ i ++ ) { $ num = $ num * 10 + ( ord ( $ string [ $ i ] ) - ord ( '0' ) ) ; if ( $ num >= 32 && $ num <= 122 ) { $ ch = chr ( $ num ) ; print ( $ ch ) ; $ num = 0 ; } } }
function countMultiples ( $ n ) { return floor ( $ n / 3 + $ n / 7 - $ n / 21 ) ; }
function findMinRec ( $ A , $ n ) { if ( $ n == 1 ) return $ A [ 0 ] ; return min ( $ A [ $ n - 1 ] , findMinRec ( $ A , $ n - 1 ) ) ; }
function isSumEqual ( $ ar , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) $ sum += $ ar [ $ i ] ; if ( $ sum == $ ar [ $ n - 1 ] ) return true ; return false ; }
function maxFreq ( $ s , $ a , $ b ) { $ fre = array_fill ( 0 , 10 , 0 ) ; $ n = strlen ( $ s ) ; if ( $ a > $ b ) { $ xx = $ a ; $ a = $ b ; $ b = $ xx ; } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ a = ord ( $ s [ $ i ] ) - ord ( '0' ) ; $ fre [ $ a ] += 1 ; } if ( $ fre [ $ a ] == 0 and $ fre [ $ b ] == 0 ) return -1 ; else if ( $ fre [ $ a ] >= $ fre [ $ b ] ) return $ a ; else return $ b ; }
function extrema ( $ a , $ n ) { $ count = 0 ; for ( $ i = 1 ; $ i < $ n - 1 ; $ i ++ ) { $ count += ( $ a [ $ i ] > $ a [ $ i - 1 ] and $ a [ $ i ] > $ a [ $ i + 1 ] ) ; $ count += ( $ a [ $ i ] < $ a [ $ i - 1 ] and $ a [ $ i ] < $ a [ $ i + 1 ] ) ; } return $ count ; }
function digit_product_Sum ( $ N ) { $ a = array_fill ( 0 , $ N , 0 ) ; $ product = 1 ; $ a [ 0 ] = 1 ; for ( $ i = 1 ; $ i <= $ N ; $ i ++ ) { $ product = ( int ) ( $ a [ $ i - 1 ] / 10 ) ; if ( $ product == 0 ) $ product = 1 ; else $ product = $ a [ $ i - 1 ] % 10 ; $ val = ( int ) ( $ a [ $ i - 1 ] / 10 ) ; if ( $ val == 0 ) $ val = $ a [ $ i - 1 ] ; $ a [ $ i ] = $ a [ $ i - 1 ] + ( $ val * $ product ) ; } for ( $ i = 0 ; $ i < $ N ; $ i ++ ) echo $ a [ $ i ] . " ▁ " ; }
function colMaxDiff ( $ mat ) { $ N = 5 ; $ max_diff = PHP_INT_MIN ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { $ max_val = $ mat [ 0 ] [ $ i ] ; $ min_val = $ mat [ 0 ] [ $ i ] ; for ( $ j = 1 ; $ j < $ N ; $ j ++ ) { $ max_val = max ( $ max_val , $ mat [ $ j ] [ $ i ] ) ; $ min_val = min ( $ min_val , $ mat [ $ j ] [ $ i ] ) ; } $ max_diff = max ( $ max_diff , $ max_val - $ min_val ) ; } return $ max_diff ; }
function percent ( $ a , $ b ) { $ result = 0 ; $ result = ( ( $ b - $ a ) * 100 ) / $ a ; return $ result ; }
function factorial ( $ n ) { return ( $ n == 1 $ n == 0 ) ? 1 : $ n * factorial ( $ n - 1 ) ; }
function vol_of_dodecahedron ( $ side ) { return ( ( ( 15 + ( 7 * ( sqrt ( 5 ) ) ) ) / 4 ) * ( pow ( $ side , 3 ) ) ) ; }
function minCoins ( $ coins , $ m , $ V ) { if ( $ V == 0 ) return 0 ; $ res = PHP_INT_MAX ; for ( $ i = 0 ; $ i < $ m ; $ i ++ ) { if ( $ coins [ $ i ] <= $ V ) { $ sub_res = minCoins ( $ coins , $ m , $ V - $ coins [ $ i ] ) ; if ( $ sub_res != PHP_INT_MAX && $ sub_res + 1 < $ res ) $ res = $ sub_res + 1 ; } } return $ res ; }
function checkSolution ( $ a , $ b , $ c ) { if ( ( ( $ b * $ b ) - ( 4 * $ a * $ c ) ) > 0 ) echo "2 ▁ solutions " ; else if ( ( ( $ b * $ b ) - ( 4 * $ a * $ c ) ) == 0 ) echo "1 ▁ solution " ; else echo " No ▁ solutions " ; }
function modInverse ( $ a , $ m ) { for ( $ x = 1 ; $ x < $ m ; $ x ++ ) if ( ( ( $ a % $ m ) * ( $ x % $ m ) ) % $ m == 1 ) return $ x ; }
function getCount ( $ arr , $ n , $ num1 , $ num2 ) { $ i = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] == $ num1 ) break ; if ( $ i >= $ n - 1 ) return 0 ; $ j ; for ( $ j = $ n - 1 ; $ j >= $ i + 1 ; $ j -- ) if ( $ arr [ $ j ] == $ num2 ) break ; if ( $ j == $ i ) return 0 ; return ( $ j - $ i - 1 ) ; }
function countTriplets ( $ arr , $ n , $ a , $ b ) { $ ans = 0 ; for ( $ i = 0 ; $ i < $ n - 2 ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ n - 1 ; $ j ++ ) { for ( $ k = $ j + 1 ; $ k < $ n ; $ k ++ ) if ( $ arr [ $ i ] + $ arr [ $ j ] + $ arr [ $ k ] >= $ a && $ arr [ $ i ] + $ arr [ $ j ] + $ arr [ $ k ] <= $ b ) $ ans ++ ; } } return $ ans ; }
function findEvenPair ( & $ A , $ N ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) if ( ! ( $ A [ $ i ] & 1 ) ) $ count ++ ; return $ count * ( $ count - 1 ) / 2 ; }
function countWords ( $ str ) { global $ OUT , $ IN ; $ state = $ OUT ; $ wc = 0 ; $ i = 0 ; while ( $ i < strlen ( $ str ) ) { if ( $ str [ $ i ] == " ▁ " $ str [ $ i ] == " STRNEWLINE " $ str [ $ i ] == " TABSYMBOL " ) $ state = $ OUT ; else if ( $ state == $ OUT ) { $ state = $ IN ; ++ $ wc ; } ++ $ i ; } return $ wc ; }
function findNthEvenDigitNumber ( $ n ) { $ count = 0 ; for ( $ i = 0 ; ; $ i ++ ) { $ curr = $ i ; $ isCurrEvenDigit = true ; while ( $ curr != 0 ) { if ( $ curr % 10 == 1 $ curr % 10 == 3 $ curr % 10 == 5 $ curr % 10 == 7 $ curr % 10 == 9 ) $ isCurrEvenDigit = false ; $ curr = $ curr / 10 ; } if ( $ isCurrEvenDigit == true ) $ count ++ ; if ( $ count == $ n ) return $ i ; } }
function minimumMoves ( $ a , $ n ) { $ operations = 0 ; sort ( $ a ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ operations += abs ( $ a [ $ i ] - ( $ i + 1 ) ) ; return $ operations ; }
function center_nonadecagon_num ( $ n ) { return ( 19 * $ n * $ n - 19 * $ n + 2 ) / 2 ; }
function getTime ( $ u , $ v , $ x ) { $ speed = $ u + $ v ; $ time = $ x / $ speed ; return $ time ; }
function kthOdd ( $ arr , $ n , $ k ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] % 2 == 1 ) $ k -- ; if ( $ k == 0 ) return $ arr [ $ i ] ; } return -1 ; }
function nthSquareCube ( $ n ) { return $ n * $ n * $ n * $ n * $ n * $ n ; }
function countDigits ( $ n ) { return intval ( $ n * log10 ( 2 ) + 1 ) ; }
function add ( & $ A , & $ B , & $ C ) { for ( $ i = 0 ; $ i < $ N ; $ i ++ ) for ( $ j = 0 ; $ j < $ N ; $ j ++ ) $ C [ $ i ] [ $ j ] = $ A [ $ i ] [ $ j ] + $ B [ $ i ] [ $ j ] ; } $ A = array ( array ( 1 , 1 , 1 , 1 ) , array ( 2 , 2 , 2 , 2 ) , array ( 3 , 3 , 3 , 3 ) , array ( 4 , 4 , 4 , 4 ) ) ; $ B = array ( array ( 1 , 1 , 1 , 1 ) , array ( 2 , 2 , 2 , 2 ) , array ( 3 , 3 , 3 , 3 ) , array ( 4 , 4 , 4 , 4 ) ) ; $ N = 4 ; add ( $ A , $ B , $ C ) ; echo " Result ▁ matrix ▁ is ▁ STRNEWLINE " ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { for ( $ j = 0 ; $ j < $ N ; $ j ++ ) { echo $ C [ $ i ] [ $ j ] ; echo " ▁ " ; } echo " STRNEWLINE " ; }
function countNegative ( $ M , $ n , $ m ) { $ count = 0 ; $ i = 0 ; $ j = $ m - 1 ; while ( $ j >= 0 and $ i < $ n ) { if ( $ M [ $ i ] [ $ j ] < 0 ) { $ count += $ j + 1 ; $ i += 1 ; } else $ j -= 1 ; } return $ count ; }
function isLucky ( $ n ) { $ counter = 2 ; $ next_position = $ n ; if ( $ counter > $ n ) return 1 ; if ( $ n % $ counter == 0 ) return 0 ; $ next_position -= $ next_position / $ counter ; $ counter ++ ; return isLucky ( $ next_position ) ; }
function findElements ( $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ count = 0 ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) if ( $ arr [ $ j ] > $ arr [ $ i ] ) $ count ++ ; if ( $ count >= 2 ) echo $ arr [ $ i ] . " ▁ " ; } }
function nthTerm ( $ n ) { return pow ( $ n , 2 ) + 4 * $ n ; }
function minInsertionStepToSortArray ( $ arr , $ N ) { $ lis [ $ N ] = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) $ lis [ $ i ] = 1 ; for ( $ i = 1 ; $ i < $ N ; $ i ++ ) for ( $ j = 0 ; $ j < $ i ; $ j ++ ) if ( $ arr [ $ i ] >= $ arr [ $ j ] && $ lis [ $ i ] < $ lis [ $ j ] + 1 ) $ lis [ $ i ] = $ lis [ $ j ] + 1 ; $ max = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) if ( $ max < $ lis [ $ i ] ) $ max = $ lis [ $ i ] ; return ( $ N - $ max ) ; }
function countPaths ( $ n , $ m ) { if ( $ n == 0 $ m == 0 ) return 1 ; return ( countPaths ( $ n - 1 , $ m ) + countPaths ( $ n , $ m - 1 ) ) ; }
function nthTerm ( $ n ) { return 4 * pow ( $ n , 2 ) - 3 * $ n + 2 ; }
function sumofseries ( $ n ) { return ( $ n * ( $ n + 1 ) * ( $ n + 2 ) * ( $ n + 3 ) / 4 ) ; }
function isEvenOrOdd ( $ L , $ R ) { $ oddCount = floor ( ( $ R - $ L ) / 2 ) ; if ( $ R % 2 == 1 $ L % 2 == 1 ) $ oddCount ++ ; if ( $ oddCount % 2 == 0 ) return " Even " ; else return " Odd " ; }
function nthTerm ( $ N ) { return ( 2 * $ N + 3 ) * ( 2 * $ N + 3 ) - 2 * $ N ; }
function CountCharacters ( $ str , $ l , $ r ) { $ cnt = 0 ; $ len = strlen ( $ str ) ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { if ( $ l <= ord ( $ str [ $ i ] ) && ord ( $ str [ $ i ] ) <= $ r ) { $ cnt ++ ; echo $ str [ $ i ] . " " ; } } return $ cnt ; }
function digSum ( $ n ) { if ( $ n == 0 ) return 0 ; return ( $ n % 9 == 0 ) ? 9 : ( $ n % 9 ) ; }
function lengtang ( $ r1 , $ r2 , $ d ) { echo " The ▁ length ▁ of ▁ the ▁ direct " , " ▁ common ▁ tangent ▁ is ▁ " , sqrt ( pow ( $ d , 2 ) - pow ( ( $ r1 - $ r2 ) , 2 ) ) , " STRNEWLINE " ; }
function printOrder ( $ arr , $ n , $ k ) { $ a = array_slice ( $ arr , 0 , $ k ) ; sort ( $ a ) ; $ b = array_slice ( $ arr , $ k , $ n ) ; sort ( $ b ) ; $ b = array_reverse ( $ b ) ; unset ( $ arr ) ; $ arr = $ a ; return array_merge ( $ arr , $ b ) ; }
function numberOfElements ( $ height , $ n ) { $ max_so_far = 0 ; $ coun = 0 ; for ( $ i = $ n - 1 ; $ i >= 0 ; $ i -- ) { if ( $ height [ $ i ] > $ max_so_far ) { $ max_so_far = $ height [ $ i ] ; $ coun ++ ; } } return $ coun ; }
function findCountOfPairs ( $ a , $ b , $ n ) { $ ans = 0 ; $ ans += $ n * ( int ) ( $ a / $ n ) * ( int ) ( $ b / $ n ) ; $ ans += ( int ) ( $ a / $ n ) * ( $ b % $ n ) ; $ ans += ( $ a % $ n ) * ( int ) ( $ b / $ n ) ; $ ans += ( ( $ a % $ n ) + ( int ) ( $ b % $ n ) ) / $ n ; return $ ans ; }
function wastedWater ( $ V , $ M , $ N ) { $ amt_per_min = $ M - $ N ; $ time_to_fill = $ V / $ amt_per_min ; $ wasted_amt = $ N * $ time_to_fill ; return $ wasted_amt ; }
function uniqueCharacters ( $ str ) { for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < strlen ( $ str ) ; $ j ++ ) { if ( $ str [ $ i ] == $ str [ $ j ] ) { return false ; } } } return true ; } $ str = " GeeksforGeeks " ; if ( uniqueCharacters ( $ str ) ) { echo " The ▁ String ▁ " , $ str , " ▁ has ▁ all ▁ unique ▁ characters STRNEWLINE " ; } else { echo " The ▁ String ▁ " , $ str , " ▁ has ▁ duplicate ▁ characters STRNEWLINE " ; }
function ReuleauxArea ( $ r ) { if ( $ r < 0 ) return -1 ; $ A = 0.70477 * 2 * pow ( $ r , 2 ) ; return $ A ; }
function isProduct ( $ arr , $ n , $ x ) { for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) for ( $ j = $ i + 1 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] * $ arr [ $ j ] == $ x ) return true ; return false ; }
function survival ( $ S , $ N , $ M ) { if ( ( ( $ N * 6 ) < ( $ M * 7 ) && $ S > 6 ) $ M > $ N ) echo " No " ; else { $ days = ( $ M * $ S ) / $ N ; if ( ( ( $ M * $ S ) % $ N ) != 0 ) $ days ++ ; echo " Yes ▁ " , floor ( $ days ) ; } }
function occurredOnce ( & $ arr , $ n ) { sort ( $ arr ) ; if ( $ arr [ 0 ] != $ arr [ 1 ] ) echo $ arr [ 0 ] . " ▁ " ; for ( $ i = 1 ; $ i < $ n - 1 ; $ i ++ ) if ( $ arr [ $ i ] != $ arr [ $ i + 1 ] && $ arr [ $ i ] != $ arr [ $ i - 1 ] ) echo $ arr [ $ i ] . " ▁ " ; if ( $ arr [ $ n - 2 ] != $ arr [ $ n - 1 ] ) echo $ arr [ $ n - 1 ] . " ▁ " ; }
function area_of_segment ( $ radius , $ angle ) { $ pi = 3.14159 ; $ area_of_sector = $ pi * ( $ radius * $ radius ) * ( $ angle / 360 ) ; $ area_of_triangle = 1 / 2 * ( $ radius * $ radius ) * sin ( ( $ angle * $ pi ) / 180 ) ; return $ area_of_sector - $ area_of_triangle ; }
function printOriginalMatrix ( $ a , $ b , $ mat ) { for ( $ i = 0 ; $ i < $ GLOBALS [ ' N ' ] ; $ i ++ ) { for ( $ j = 0 ; $ j < $ GLOBALS [ ' M ' ] ; $ j ++ ) { if ( $ mat [ $ i ] [ $ j ] == 1 ) echo min ( $ a [ $ i ] , $ b [ $ j ] ) . " ▁ " ; else echo "0" . " ▁ " ; } echo " \r STRNEWLINE " ; } }
function possibleOrNot ( $ a1 , $ a2 , $ b1 , $ b2 , $ c1 , $ c2 ) { $ dis1 = pow ( $ b1 - $ a1 , 2 ) + pow ( $ b2 - $ a2 , 2 ) ; $ dis2 = pow ( $ c1 - $ b1 , 2 ) + pow ( $ c2 - $ b2 , 2 ) ; if ( $ dis1 != $ dis2 ) echo " No " ; else if ( $ b1 == ( ( $ a1 + $ c1 ) / 2.0 ) && $ b2 == ( ( $ a2 + $ c2 ) / 2.0 ) ) echo " No " ; else echo " Yes " ; }
function maximumSegments ( $ n , $ a , $ b , $ c ) { $ dp = array ( ) ; for ( $ i = 0 ; $ i < $ n + 10 ; $ i ++ ) $ dp [ $ i ] = -1 ; $ dp [ 0 ] = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ dp [ $ i ] != -1 ) { $ dp [ $ i + $ a ] = max ( $ dp [ $ i ] + 1 , $ dp [ $ i + $ a ] ) ; $ dp [ $ i + $ b ] = max ( $ dp [ $ i ] + 1 , $ dp [ $ i + $ b ] ) ; $ dp [ $ i + $ c ] = max ( $ dp [ $ i ] + 1 , $ dp [ $ i + $ c ] ) ; } } return $ dp [ $ n ] ; }
function countPairs ( $ arr1 , $ arr2 , $ m , $ n , $ x ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ m ; $ i ++ ) for ( $ j = 0 ; $ j < $ n ; $ j ++ ) if ( ( $ arr1 [ $ i ] + $ arr2 [ $ j ] ) == $ x ) $ count ++ ; return $ count ; }
function nthKyneaNumber ( $ n ) { $ n = ( 1 << $ n ) + 1 ; $ n = $ n * $ n ; $ n = $ n - 2 ; return $ n ; }
function findNum ( $ div , $ rem , $ N ) { $ num = $ rem [ $ N - 1 ] ; for ( $ i = $ N - 2 ; $ i >= 0 ; $ i -- ) { $ num = $ num * $ div [ $ i ] + $ rem [ $ i ] ; } return $ num ; }
function MaxTraceSub ( $ mat ) { global $ N ; $ max_trace = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { for ( $ j = 0 ; $ j < $ N ; $ j ++ ) { $ r = $ i ; $ s = $ j ; $ trace = 0 ; while ( $ r < $ N && $ s < $ N ) { $ trace += $ mat [ $ r ] [ $ s ] ; $ r ++ ; $ s ++ ; $ max_trace = max ( $ trace , $ max_trace ) ; } } } return $ max_trace ; }
function findMissing ( $ arr1 , $ arr2 , $ M , $ N ) { if ( $ M != $ N - 1 && $ N != $ M - 1 ) { echo " Invalid ▁ Input " ; return ; } $ res = 0 ; for ( $ i = 0 ; $ i < $ M ; $ i ++ ) $ res = $ res ^ $ arr1 [ $ i ] ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) $ res = $ res ^ $ arr2 [ $ i ] ; echo " Missing ▁ element ▁ is ▁ " , $ res ; }
function findPair ( & $ arr , $ size , $ n ) { $ i = 0 ; $ j = 1 ; while ( $ i < $ size && $ j < $ size ) { if ( $ i != $ j && $ arr [ $ j ] - $ arr [ $ i ] == $ n ) { echo " Pair ▁ Found : ▁ " . " ( " . $ arr [ $ i ] . " , ▁ " . $ arr [ $ j ] . " ) " ; return true ; } else if ( $ arr [ $ j ] - $ arr [ $ i ] < $ n ) $ j ++ ; else $ i ++ ; } echo " No ▁ such ▁ pair " ; return false ; }
function moduloMultiplication ( $ a , $ b , $ mod ) { $ a %= $ mod ; while ( $ b ) { if ( $ b & 1 ) $ res = ( $ res + $ a ) % $ mod ; $ a = ( 2 * $ a ) % $ mod ; } return $ res ; }
function check ( $ str ) { $ n = strlen ( $ str ) ; $ digitSum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ digitSum += ( $ str [ $ i ] - '0' ) ; return ( $ digitSum % 9 == 0 ) ; }
function calculateSide ( $ n , $ r ) { $ theta ; $ theta_in_radians ; $ theta = 360 / $ n ; $ theta_in_radians = $ theta * 3.14 / 180 ; return 2 * $ r * sin ( $ theta_in_radians / 2 ) ; }
function isTriangular ( $ num ) { if ( $ num < 0 ) return false ; $ sum = 0 ; for ( $ n = 1 ; $ sum <= $ num ; $ n ++ ) { $ sum = $ sum + $ n ; if ( $ sum == $ num ) return true ; } return false ; }
function turnOnK ( $ n , $ k ) { if ( $ k <= 0 ) return $ n ; return ( $ n | ( 1 << ( $ k - 1 ) ) ) ; }
function solve ( $ N , $ M , & $ cp , & $ sp ) { $ profit = array_fill ( 0 , $ N , NULL ) ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) $ profit [ $ i ] = $ sp [ $ i ] - $ cp [ $ i ] ; rsort ( $ profit ) ; $ sum = 0 ; for ( $ i = 0 ; $ i < $ M ; $ i ++ ) { if ( $ profit [ $ i ] > 0 ) $ sum += $ profit [ $ i ] ; else break ; } return $ sum ; }
function findArea ( $ arr , $ n ) { rsort ( $ arr ) ; $ dimension = array ( 0 , 0 ) ; for ( $ i = 0 , $ j = 0 ; $ i < $ n - 1 && $ j < 2 ; $ i ++ ) if ( $ arr [ $ i ] == $ arr [ $ i + 1 ] ) $ dimension [ $ j ++ ] = $ arr [ $ i ++ ] ; return ( $ dimension [ 0 ] * $ dimension [ 1 ] ) ; }
function findSum ( $ N ) { return ( $ N * ( $ N + 1 ) * ( 2 * $ N - 5 ) + 4 * $ N ) / 2 ; }
function findMaxCock ( $ ar ) { global $ R , $ C ; if ( $ R < 3 $ C < 3 ) return -1 ; $ max_sum = PHP_INT_MIN ; for ( $ i = 0 ; $ i < $ R - 2 ; $ i ++ ) { for ( $ j = 0 ; $ j < $ C - 2 ; $ j ++ ) { $ sum = ( $ ar [ $ i ] [ $ j ] + $ ar [ $ i ] [ $ j + 2 ] ) + ( $ ar [ $ i + 1 ] [ $ j + 1 ] ) + ( $ ar [ $ i + 2 ] [ $ j ] + $ ar [ $ i + 2 ] [ $ j + 1 ] + $ ar [ $ i + 2 ] [ $ j + 2 ] ) ; $ max_sum = max ( $ max_sum , $ sum ) ; } } return $ max_sum ; }
function maxSumBitonicSubArr ( $ arr , $ n ) { $ msis = array ( ) ; $ msds = array ( ) ; $ max_sum = PHP_INT_MIN ; $ msis [ 0 ] = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] > $ arr [ $ i - 1 ] ) $ msis [ $ i ] = $ msis [ $ i - 1 ] + $ arr [ $ i ] ; else $ msis [ $ i ] = $ arr [ $ i ] ; $ msds [ $ n - 1 ] = $ arr [ $ n - 1 ] ; for ( $ i = $ n - 2 ; $ i >= 0 ; $ i -- ) if ( $ arr [ $ i ] > $ arr [ $ i + 1 ] ) $ msds [ $ i ] = $ msds [ $ i + 1 ] + $ arr [ $ i ] ; else $ msds [ $ i ] = $ arr [ $ i ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ max_sum < ( $ msis [ $ i ] + $ msds [ $ i ] - $ arr [ $ i ] ) ) $ max_sum = $ msis [ $ i ] + $ msds [ $ i ] - $ arr [ $ i ] ; return $ max_sum ; }
function hammingDist ( $ str1 , $ str2 ) { $ i = 0 ; $ count = 0 ; while ( isset ( $ str1 [ $ i ] ) != ' ' ) { if ( $ str1 [ $ i ] != $ str2 [ $ i ] ) $ count ++ ; $ i ++ ; } return $ count ; }
function findAngle ( $ n ) { $ interiorAngle ; $ exteriorAngle ; $ interiorAngle = ( $ n - 2 ) * 180 / $ n ; $ exteriorAngle = 360 / $ n ; echo " Interior ▁ angle : ▁ " , $ interiorAngle , " STRNEWLINE " ; echo " Exterior ▁ angle : ▁ " , $ exteriorAngle ; }
function numberOfWays ( $ x ) { $ dp [ 0 ] = 1 ; $ dp [ 1 ] = 1 ; for ( $ i = 2 ; $ i <= $ x ; $ i ++ ) $ dp [ $ i ] = $ dp [ $ i - 1 ] + ( $ i - 1 ) * $ dp [ $ i - 2 ] ; return $ dp [ $ x ] ; }
function findevenPair ( $ A , $ N ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) if ( $ A [ $ i ] % 2 != 0 ) $ count ++ ; $ oddCount = $ count * ( $ count - 1 ) / 2 ; return ( $ N * ( $ N - 1 ) / 2 ) - $ oddCount ; }
function maxPartitions ( $ arr , $ n ) { $ ans = 0 ; $ max_so_far = 0 ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { $ max_so_far = max ( $ max_so_far , $ arr [ $ i ] ) ; if ( $ max_so_far == $ i ) $ ans ++ ; } return $ ans ; } { $ arr = array ( 1 , 0 , 2 , 3 , 4 ) ; $ n = sizeof ( $ arr ) / sizeof ( $ arr [ 0 ] ) ; echo maxPartitions ( $ arr , $ n ) ; return 0 ; }
function reverse ( $ str ) { if ( ( $ str == null ) || ( strlen ( $ str ) <= 1 ) ) echo ( $ str ) ; else { echo ( $ str [ strlen ( $ str ) - 1 ] ) ; reverse ( substr ( $ str , 0 , ( strlen ( $ str ) - 1 ) ) ) ; } }
function squaresum ( $ n ) { return ( $ n * ( $ n + 1 ) / 2 ) * ( 2 * $ n + 1 ) / 3 ; }
function binarySearch ( $ arr , $ x ) { $ l = 0 ; $ r = count ( $ arr ) ; while ( $ l <= $ r ) { $ m = $ l + ( int ) ( ( $ r - $ l ) / 2 ) ; $ res = strcmp ( $ x , $ arr [ $ m ] ) ; if ( $ res == 0 ) return $ m - 1 ; if ( $ res > 0 ) $ l = $ m + 1 ; else $ r = $ m - 1 ; } return -1 ; }
function findLargestd ( $ S , $ n ) { $ found = false ; sort ( $ S ) ; for ( $ i = $ n - 1 ; $ i >= 0 ; $ i -- ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ i == $ j ) continue ; for ( $ k = $ j + 1 ; $ k < $ n ; $ k ++ ) { if ( $ i == $ k ) continue ; for ( $ l = $ k + 1 ; $ l < $ n ; $ l ++ ) { if ( $ i == $ l ) continue ; if ( $ S [ $ i ] == $ S [ $ j ] + $ S [ $ k ] + $ S [ $ l ] ) { $ found = true ; return $ S [ $ i ] ; } } } } } if ( $ found == false ) return PHP_INT_MIN ; }
function cyl ( $ a ) { if ( $ a < 0 ) return -1 ; $ r = ( 2 * $ a * sqrt ( 2 ) ) / 3 ; $ h = ( 2 * $ a ) / 3 ; $ V = 3.14 * pow ( $ r , 2 ) * $ h ; return $ V ; }
function maxSum ( $ arr , $ n ) { sort ( $ arr ) ; $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum += ( $ arr [ $ i ] * $ i ) ; return $ sum ; }
function printDivisors ( $ n ) { $ v ; $ t = 0 ; for ( $ i = 1 ; $ i <= ( int ) sqrt ( $ n ) ; $ i ++ ) { if ( $ n % $ i == 0 ) { if ( ( int ) $ n / $ i == $ i ) echo $ i . " " ; else { echo $ i . " " ; $ v [ $ t ++ ] = ( int ) $ n / $ i ; } } } for ( $ i = count ( $ v ) - 1 ; $ i >= 0 ; $ i -- ) echo $ v [ $ i ] . " ▁ " ; }
function maxIndexDiff ( $ arr , $ n ) { $ maxDiff = -1 ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { for ( $ j = $ n - 1 ; $ j > $ i ; -- $ j ) { if ( $ arr [ $ j ] > $ arr [ $ i ] && $ maxDiff < ( $ j - $ i ) ) $ maxDiff = $ j - $ i ; } } return $ maxDiff ; }
function harmonicMean ( $ arr , $ freq , $ n ) { $ sum = 0 ; $ frequency_sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sum = $ sum + ( float ) ( $ freq [ $ i ] / $ arr [ $ i ] ) ; $ frequency_sum = $ frequency_sum + $ freq [ $ i ] ; } return ( $ frequency_sum / $ sum ) ; }
function checkValidity ( $ a , $ b , $ c ) { if ( $ a + $ b <= $ c $ a + $ c <= $ b $ b + $ c <= $ a ) return false ; else return true ; }
function rhombusAreaPeri ( $ d1 , $ d2 ) { $ area = ( $ d1 * $ d2 ) / 2 ; $ perimeter = 2 * sqrt ( pow ( $ d1 , 2 ) + pow ( $ d2 , 2 ) ) ; echo " The ▁ area ▁ of ▁ rhombus ▁ with ▁ diagonals ▁ " . $ d1 . " ▁ and ▁ " . $ d2 . " ▁ is ▁ " . $ area . " . " . " STRNEWLINE " ; echo " The ▁ perimeter ▁ of ▁ rhombus ▁ with ▁ diagonals ▁ " . $ d1 . " ▁ and ▁ " . $ d2 . " ▁ is ▁ " . $ perimeter . " . " . " STRNEWLINE " ; }
function overflow ( $ H , $ r , $ h , $ N , $ R ) { $ tank_cap = 3.14 * $ r * $ r * $ H ; $ water_vol = 3.14 * $ r * $ r * $ h ; $ balls_vol = $ N * ( 4 / 3 ) * 3.14 * $ R * $ R * $ R ; $ vol = $ water_vol + $ balls_vol ; if ( $ vol > $ tank_cap ) { echo " Overflow " , " STRNEWLINE " ; } else { echo " Not ▁ in ▁ overflow ▁ state " , " STRNEWLINE " ; } }
function findS ( $ s ) { $ sum = 0 ; for ( $ n = 1 ; $ sum < $ s ; $ n ++ ) { $ sum += $ n * $ n * $ n ; if ( $ sum == $ s ) return $ n ; } return -1 ; }
function countNegative ( $ M , $ n , $ m ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ m ; $ j ++ ) { if ( $ M [ $ i ] [ $ j ] < 0 ) $ count += 1 ; else break ; } } return $ count ; }
function printTaxicab2 ( $ N ) { $ i = 1 ; $ count = 0 ; while ( $ count < $ N ) { $ int_count = 0 ; for ( $ j = 1 ; $ j <= pow ( $ i , 1.0 / 3 ) ; $ j ++ ) for ( $ k = $ j + 1 ; $ k <= pow ( $ i , 1.0 / 3 ) ; $ k ++ ) if ( $ j * $ j * $ j + $ k * $ k * $ k == $ i ) $ int_count ++ ; if ( $ int_count == 2 ) { $ count ++ ; echo $ count , " " , ▁ $ i , ▁ " " } $ i ++ ; } }
function query ( $ s , $ i , $ j ) { $ n = strlen ( $ s ) ; $ i %= $ n ; $ j %= $ n ; if ( ( $ s [ $ i ] == $ s [ $ j ] ) ) echo " Yes STRNEWLINE " ; else echo " No " ; }
function countNumbers ( $ n ) { return ( int ) ( $ n / 2520 ) ; }
function check ( $ arr , $ x , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ x = sqrt ( $ arr [ $ i ] ) ; if ( floor ( $ x ) == ceil ( $ x ) ) { $ sum += $ arr [ $ i ] ; } } if ( ( $ sum % $ x ) == 0 ) return true ; else return false ; } $ arr = array ( 2 , 3 , 4 , 9 , 10 ) ; $ n = sizeof ( $ arr ) ; $ x = 13 ; if ( ! check ( $ arr , $ x , $ n ) ) { echo " Yes " ; } else { echo " No " ; }
function FindIndexKthBit ( $ n , $ k ) { $ cnt = 0 ; $ ind = 0 ; while ( $ n ) { if ( $ n & 1 ) $ cnt ++ ; if ( $ cnt == $ k ) return $ ind ; $ ind ++ ; $ n = $ n >> 1 ; } return -1 ; }
function minDaysToEmpty ( $ C , $ l ) { if ( $ l >= $ C ) return $ C ; $ eq_root = ( int ) sqrt ( 1 + 8 * ( $ C - $ l ) - 1 ) / 2 ; return ceil ( $ eq_root ) + $ l ; }
function checkEquilibrium ( $ x1 , $ y1 , $ z1 , $ x2 , $ y2 , $ z2 , $ x3 , $ y3 , $ z3 ) { $ resx = $ x1 + $ x2 + $ x3 ; $ resy = $ y1 + $ y2 + $ y3 ; $ resz = $ z1 + $ z2 + $ z3 ; if ( $ resx == 0 and $ resy == 0 and $ resz == 0 ) return true ; else return false ; }
function SellingPrice ( $ CP , $ PP ) { $ P_decimal = 1 + ( $ PP / 100 ) ; $ res = $ P_decimal * $ CP ; return $ res ; }
function findPosition ( $ n , $ f , $ b ) { return $ n - max ( $ f + 1 , $ n - $ b ) + 1 ; }
function findOptimalSolution ( $ a , $ N ) { sort ( $ a ) ; $ points = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { $ points += $ a [ $ i ] * $ i ; } return $ points ; }
function linearSearch ( $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] == $ i ) return $ i ; } return -1 ; }
function printTetra ( $ n ) { $ dp = array_fill ( 0 , $ n + 5 , 0 ) ; $ dp [ 0 ] = 0 ; $ dp [ 1 ] = $ dp [ 2 ] = 1 ; $ dp [ 3 ] = 2 ; for ( $ i = 4 ; $ i <= $ n ; $ i ++ ) $ dp [ $ i ] = $ dp [ $ i - 1 ] + $ dp [ $ i - 2 ] + $ dp [ $ i - 3 ] + $ dp [ $ i - 4 ] ; echo $ dp [ $ n ] ; }
function firstkdigits ( $ n , $ k ) { $ product = 1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ product *= $ n ; while ( ( int ) ( $ product / pow ( 10 , $ k ) ) != 0 ) $ product = ( int ) $ product / 10 ; return floor ( $ product ) ; }
function sumOfSeries ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ sum = $ sum + $ i * $ i ; return $ sum ; }
function PointInKSquares ( $ n , $ a , $ k ) { sort ( $ a ) ; return $ a [ $ n - $ k ] ; }
function phi ( $ n ) { $ result = $ n ; for ( $ p = 2 ; $ p * $ p <= $ n ; ++ $ p ) { if ( $ n % $ p == 0 ) { while ( $ n % $ p == 0 ) $ n /= $ p ; $ result *= ( 1.0 - ( 1.0 / $ p ) ) ; } } if ( $ n > 1 ) $ result *= ( 1.0 - ( 1.0 / $ n ) ) ; return intval ( $ result ) ; }
function findpair ( $ l , $ r ) { $ ans1 = $ l ; $ ans2 = 2 * $ l ; echo ( $ ans1 . " , ▁ " . $ ans2 ) ; }
function nextPerfectSquare ( $ N ) { $ nextN = floor ( sqrt ( $ N ) ) + 1 ; return $ nextN * $ nextN ; }
function totalTriangles ( $ h , $ v ) { if ( $ h == 0 && $ v == 0 ) return 1 ; if ( $ h == 0 ) return ( ( $ v + 1 ) * ( $ v + 2 ) / 2 ) ; if ( $ v == 0 ) return ( $ h + 1 ) ; $ Total = ( $ h + 1 ) * ( ( $ v + 1 ) * ( $ v + 2 ) / 2 ) ; return $ Total ; }
function areSetBitsIncreasing ( $ n ) { $ prev_count = PHP_INT_MAX ; while ( $ n > 0 ) { while ( $ n > 0 && $ n % 2 == 0 ) $ n = $ n / 2 ; $ curr_count = 1 ; while ( $ n > 0 and $ n % 2 == 1 ) { $ n = $ n / 2 ; $ curr_count ++ ; } if ( $ curr_count >= $ prev_count ) return false ; $ prev_count = $ curr_count ; } return true ; }
function sumOfTheSeries ( $ n ) { $ sum = 0.0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ sum += 1.0 / ( $ i * ( $ i + 1 ) ) ; return $ sum ; }
function changeEvenBits ( $ n ) { $ to_subtract = 0 ; $ m = 0 ; for ( $ x = $ n ; $ x ; $ x >>= 2 ) { if ( $ x & 1 ) $ to_subtract += ( 1 << $ m ) ; $ m += 2 ; } return $ n - $ to_subtract ; }
function divisibleBy20 ( $ num ) { $ lastTwoDigits = intval ( substr ( $ num , ( strlen ( $ num ) - 2 ) , 2 ) ) ; return ( ( $ lastTwoDigits % 5 == 0 ) && ( $ lastTwoDigits % 4 == 0 ) ) ; }
function longestsubarray ( $ arr , $ n , $ k ) { $ current_count = 0 ; $ max_count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] % $ k == 0 ) $ current_count ++ ; else $ current_count = 0 ; $ max_count = max ( $ current_count , $ max_count ) ; } return $ max_count ; }
function squareRootExists ( $ n , $ p ) { $ n = $ n % $ p ; for ( $ x = 2 ; $ x < $ p ; $ x ++ ) if ( ( $ x * $ x ) % $ p == $ n ) return true ; return false ; }
function numbers ( $ n ) { return ( pow ( 2 , $ n + 1 ) ) - 2 ; }
function nextPerfectCube ( $ N ) { $ nextN = ( int ) ( floor ( pow ( $ N , ( 1 / 3 ) ) ) + 1 ) ; return $ nextN * $ nextN * $ nextN ; }
function isPossible ( $ a , $ n ) { $ sum = 0 ; $ maxS = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sum += $ a [ $ i ] ; $ maxS = max ( $ a [ $ i ] , $ maxS ) ; } if ( ( $ sum - $ maxS ) > $ maxS ) return true ; return false ; }
function lengthOfTangent ( $ r1 , $ r2 , $ d ) { echo " The ▁ length ▁ of ▁ the ▁ transverse ▁ common ▁ tangent ▁ is ▁ " , sqrt ( pow ( $ d , 2 ) - pow ( ( $ r1 + $ r2 ) , 2 ) ) ; }
function minDistance ( $ n , $ k , & $ point ) { for ( $ i = 0 ; $ i < $ k ; ++ $ i ) sort ( $ point [ $ i ] ) ; for ( $ i = 0 ; $ i < $ k ; ++ $ i ) echo $ point [ $ i ] [ ( ceil ( ( double ) $ n / 2 ) - 1 ) ] . " ▁ " ; }
function minimumCost ( & $ cost , $ n ) { if ( $ n == 1 ) return $ cost [ 0 ] ; $ dp [ 0 ] = $ cost [ 0 ] ; $ dp [ 1 ] = $ cost [ 1 ] ; for ( $ i = 2 ; $ i < $ n ; $ i ++ ) { $ dp [ $ i ] = min ( $ dp [ $ i - 1 ] , $ dp [ $ i - 2 ] ) + $ cost [ $ i ] ; } return min ( $ dp [ $ n - 2 ] , $ dp [ $ n - 1 ] ) ; }
function convert ( $ m , $ n ) { if ( $ m == $ n ) return 0 ; if ( $ m > $ n ) return $ m - $ n ; if ( $ m <= 0 && $ n > 0 ) return -1 ; if ( $ n % 2 == 1 ) return 1 + convert ( $ m , $ n + 1 ) ; else return 1 + convert ( $ m , $ n / 2 ) ; } { $ m = 3 ; $ n = 11 ; echo " Minimum ▁ number ▁ of ▁ " . " operations ▁ : ▁ " , convert ( $ m , $ n ) ; return 0 ; }
function isAlphabaticOrder ( $ s ) { $ n = strlen ( $ s ) ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( $ s [ $ i ] < $ s [ $ i - 1 ] ) return false ; } return true ; }
function nonFibonacci ( $ n ) { $ prevPrev = 1 ; $ prev = 2 ; $ curr = 3 ; while ( $ n > 0 ) { $ prevPrev = $ prev ; $ prev = $ curr ; $ curr = $ prevPrev + $ prev ; $ n = $ n - ( $ curr - $ prev - 1 ) ; } $ n = $ n + ( $ curr - $ prev - 1 ) ; return $ prev + $ n ; }
function findNumbers ( $ n ) { $ odd = pow ( 10 , $ n ) - 1 ; $ even = $ odd - 1 ; echo " Even ▁ = ▁ $ even ▁ STRNEWLINE " ; echo " Odd ▁ = ▁ $ odd " ; }
function minAND ( $ arr , $ n ) { $ s = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ s = $ s & $ arr [ $ i ] ; } print ( $ s . " " ) ; }
function Mixture ( $ X , $ Y , $ Z ) { $ result = 0.0 ; $ result1 = 0.0 ; $ result1 = ( ( $ X - $ Y ) / $ X ) ; $ result = pow ( $ result1 , $ Z ) ; $ result = $ result * $ X ; return $ result ; }
function sumOfAP ( $ a , $ d , $ n ) { $ sum = ( $ n / 2 ) * ( 2 * $ a + ( $ n - 1 ) * $ d ) ; return $ sum ; }
function validate ( $ n ) { for ( $ i = 0 ; $ i < 10 ; $ i ++ ) { $ temp = $ n ; $ count = 0 ; while ( $ temp ) { if ( $ temp % 10 == $ i ) $ count ++ ; if ( $ count > $ i ) return -1 ; $ temp /= 10 ; } } return 1 ; }
function countDigits ( $ a , $ b ) { return floor ( log10 ( abs ( $ a ) ) - log10 ( abs ( $ b ) ) ) + 1 ; }
function Area ( $ a ) { if ( $ a < 0 ) return -1 ; $ x = 0.464 * $ a ; $ A = 0.70477 * pow ( $ x , 2 ) ; return $ A ; }
function vertices ( $ N , $ A , $ B ) { $ position = 0 ; $ minisum = PHP_INT_MAX ; $ sum = 0 ; for ( $ i = 1 ; $ i <= $ N ; $ i ++ ) { if ( $ i == $ A $ i == $ B ) continue ; else { $ x = abs ( $ i - $ A ) ; $ y = abs ( $ i - $ B ) ; $ sum = $ x + $ y ; if ( $ sum < $ minisum ) { $ minisum = $ sum ; $ position = $ i ; } } } return $ position ; }
function hendecagonal_num ( $ n ) { return ( 9 * $ n * $ n - 7 * $ n ) / 2 ; }
function maxHamming ( $ arr , $ n ) { $ brr = array ( ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ brr [ $ i ] = $ arr [ $ i ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ brr [ $ n + $ i ] = $ arr [ $ i ] ; $ maxHam = 0 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ currHam = 0 ; for ( $ j = $ i , $ k = 0 ; $ j < ( $ i + $ n ) ; $ j ++ , $ k ++ ) if ( $ brr [ $ j ] != $ arr [ $ k ] ) $ currHam ++ ; if ( $ currHam == $ n ) return $ n ; $ maxHam = max ( $ maxHam , $ currHam ) ; } return $ maxHam ; }
function hexagonside ( $ a ) { if ( $ a < 0 ) return -1 ; $ x = $ a / 3 ; return $ x ; }
function power ( $ x , $ y ) { $ temp ; if ( $ y == 0 ) return 1 ; $ temp = power ( $ x , $ y / 2 ) ; if ( $ y % 2 == 0 ) return $ temp * $ temp ; else { if ( $ y > 0 ) return $ x * $ temp * $ temp ; else return ( $ temp * $ temp ) / $ x ; } }
function isPowerOfFour ( $ n ) { $ count = 0 ; if ( $ n && ! ( $ n & ( $ n - 1 ) ) ) { while ( $ n > 1 ) { $ n >>= 1 ; $ count += 1 ; } return ( $ count % 2 == 0 ) ? 1 : 0 ; } return 0 ; }
function findIntersection ( $ intervals , $ N ) { $ l = $ intervals [ 0 ] [ 0 ] ; $ r = $ intervals [ 0 ] [ 1 ] ; for ( $ i = 1 ; $ i < $ N ; $ i ++ ) { if ( $ intervals [ $ i ] [ 0 ] > $ r $ intervals [ $ i ] [ 1 ] < $ l ) { echo - 1 ; return ; } else { $ l = max ( $ l , $ intervals [ $ i ] [ 0 ] ) ; $ r = min ( $ r , $ intervals [ $ i ] [ 1 ] ) ; } } echo " [ " ▁ . ▁ $ l ▁ . ▁ " , " ▁ . ▁ $ r ▁ . ▁ " ] " ; }
function sumOfTermsInNthRow ( $ n ) { $ sum = $ n * ( 2 * pow ( $ n , 2 ) + 1 ) ; return $ sum ; }
function findXor ( $ arr , $ n ) { $ xoR = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ xoR = $ xoR ^ $ arr [ $ i ] ; } return $ xoR * 2 ; }
function minimumSets ( $ arr , $ n , $ key ) { $ i ; $ j ; sort ( $ arr ) ; for ( $ i = 0 , $ j = $ n - 1 ; $ i <= $ j ; ++ $ i ) if ( $ arr [ $ i ] + $ arr [ $ j ] <= $ key ) $ j -- ; return $ i ; }
function countMaxSetBits ( $ left , $ right ) { while ( ( $ left | ( $ left + 1 ) ) <= $ right ) $ left |= $ left + 1 ; return $ left ; }
function nthKyneaNumber ( $ n ) { return ( ( 1 << ( 2 * $ n ) ) + ( 1 << ( $ n + 1 ) ) - 1 ) ; }
function zigzag ( $ n , $ k ) { if ( $ n == 0 and $ k == 0 ) return 1 ; if ( $ k == 0 ) return 0 ; return zigzag ( $ n , $ k - 1 ) + zigzag ( $ n - 1 , $ n - $ k ) ; }
function MatrixChainOrder ( & $ p , $ i , $ j ) { if ( $ i == $ j ) return 0 ; $ min = PHP_INT_MAX ; for ( $ k = $ i ; $ k < $ j ; $ k ++ ) { $ count = MatrixChainOrder ( $ p , $ i , $ k ) + MatrixChainOrder ( $ p , $ k + 1 , $ j ) + $ p [ $ i - 1 ] * $ p [ $ k ] * $ p [ $ j ] ; if ( $ count < $ min ) $ min = $ count ; } return $ min ; }
function countDistinct ( & $ arr , $ n ) { $ res = 1 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ i ; $ j ++ ) if ( $ arr [ $ i ] == $ arr [ $ j ] ) break ; if ( $ i == $ j ) $ res ++ ; } return $ res ; }
function findEle ( $ arr , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum += $ arr [ $ i ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] == $ sum - $ arr [ $ i ] ) return $ arr [ $ i ] ; return -1 ; }
function area ( $ a ) { if ( $ a < 0 ) return -1 ; $ area = pow ( ( $ a * sqrt ( 3 ) ) / ( sqrt ( 2 ) ) , 2 ) ; return $ area ; }
function findDigits ( $ n ) { if ( $ n < 0 ) return 0 ; if ( $ n <= 1 ) return 1 ; $ digits = 0 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) $ digits += log10 ( $ i ) ; return floor ( $ digits ) + 1 ; }
function pattern ( $ str , $ len ) { for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { $ j = $ len - 1 - $ i ; for ( $ k = 0 ; $ k < $ len ; $ k ++ ) { if ( $ k == $ i $ k == $ j ) echo $ str [ $ k ] ; else echo " ▁ " ; } echo " STRNEWLINE " ; } }
function ispowerof2 ( $ num ) { if ( ( $ num & ( $ num - 1 ) ) == 0 ) return 1 ; return 0 ; }
function numberOfTriangles ( $ n ) { $ ans = 2 * ( pow ( 3 , $ n ) ) - 1 ; return $ ans ; }
function countNumbersWith4 ( $ n ) { if ( $ n < 4 ) return 0 ; $ d = ( int ) log10 ( $ n ) ; $ a = array_fill ( 0 , $ d + 1 , NULL ) ; $ a [ 0 ] = 0 ; $ a [ 1 ] = 1 ; for ( $ i = 2 ; $ i <= $ d ; $ i ++ ) $ a [ $ i ] = $ a [ $ i - 1 ] * 9 + ceil ( pow ( 10 , $ i - 1 ) ) ; $ p = ceil ( pow ( 10 , $ d ) ) ; $ msd = intval ( $ n / $ p ) ; if ( $ msd == 4 ) return ( $ msd ) * $ a [ $ d ] + ( $ n % $ p ) + 1 ; if ( $ msd > 4 ) return ( $ msd - 1 ) * $ a [ $ d ] + $ p + countNumbersWith4 ( $ n % $ p ) ; return ( $ msd ) * $ a [ $ d ] + countNumbersWith4 ( $ n % $ p ) ; }
function setbitsfromLtoR ( $ L , $ R ) { return ( 1 << ( $ R + 1 ) ) - ( 1 << $ L ) ; }
function avg_of_odd_num ( $ n ) { return $ n ; }
function findVolume ( $ l , $ b , $ h ) { $ volume = ( $ l * $ b * $ h ) / 2 ; return $ volume ; }
function removeDuplicatesFromString ( $ str ) { $ counter = 0 ; $ i = 0 ; $ size = strlen ( $ str ) ; $ x = 0 ; $ length = 0 ; while ( $ i < $ size ) { $ x = ord ( $ str [ $ i ] ) - 97 ; if ( ( $ counter & ( 1 << $ x ) ) == 0 ) { $ str [ $ length ] = chr ( 97 + $ x ) ; $ counter = $ counter | ( 1 << $ x ) ; $ length ++ ; } $ i ++ ; } return substr ( $ str , 0 , $ length ) ; }
function printDiagonalSums ( $ mat , $ n ) { global $ MAX ; $ principal = 0 ; $ secondary = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ principal += $ mat [ $ i ] [ $ i ] ; $ secondary += $ mat [ $ i ] [ $ n - $ i - 1 ] ; } echo " Principal ▁ Diagonal : " , $ principal , " STRNEWLINE " ; echo " Secondary ▁ Diagonal : " , $ secondary , " STRNEWLINE " ; }
function findPairs ( $ n ) { $ cubeRoot = pow ( $ n , 1.0 / 3.0 ) ; $ cube = array ( ) ; for ( $ i = 1 ; $ i <= $ cubeRoot ; $ i ++ ) $ cube [ $ i ] = $ i * $ i * $ i ; $ l = 1 ; $ r = $ cubeRoot ; while ( $ l < $ r ) { if ( $ cube [ $ l ] + $ cube [ $ r ] < $ n ) $ l ++ ; else if ( $ cube [ $ l ] + $ cube [ $ r ] > $ n ) $ r -- ; else { echo " ( " , $ l , " , ▁ " , floor ( $ r ) , " ) " ; echo " STRNEWLINE " ; $ l ++ ; $ r -- ; } } }
function minimumX ( $ n , $ k ) { $ ans = PHP_INT_MAX ; for ( $ rem = $ k - 1 ; $ rem > 0 ; $ rem -- ) { if ( $ n % $ rem == 0 ) $ ans = min ( $ ans , $ rem + ( $ n / $ rem ) * $ k ) ; } return $ ans ; }
function fourthPowerSum ( $ n ) { return ( ( 6 * $ n * $ n * $ n * $ n * $ n ) + ( 15 * $ n * $ n * $ n * $ n ) + ( 10 * $ n * $ n * $ n ) - $ n ) / 30 ; }
function lds ( $ arr , $ n ) { $ lds = array ( ) ; $ i ; $ j ; $ max = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ lds [ $ i ] = 1 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ i ; $ j ++ ) if ( $ arr [ $ i ] < $ arr [ $ j ] and $ lds [ $ i ] < $ lds [ $ j ] + 1 ) { $ lds [ $ i ] = $ lds [ $ j ] + 1 ; } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ max < $ lds [ $ i ] ) $ max = $ lds [ $ i ] ; return $ max ; }
function calculateProbability ( $ N ) { $ probability = $ N / ( $ N + 1 ) ; return $ probability ; }
function getSlope ( $ m ) { return $ m ; }
function binomialCoeffSum ( $ n ) { return ( 1 << $ n ) ; }
function minimumMoves ( $ k , $ l , $ r ) { $ count = $ r - $ l + 1 ; if ( $ count % $ k == 0 ) return 0 ; return ( $ k - ( $ count % $ k ) ) ; }
function printSpiral ( $ mat , $ r , $ c ) { global $ MAX ; $ i ; $ a = 0 ; $ b = 2 ; $ low_row = ( 0 > $ a ) ? 0 : $ a ; $ low_column = ( 0 > $ b ) ? 0 : $ b - 1 ; $ high_row = ( ( $ a + 1 ) >= $ r ) ? $ r - 1 : $ a + 1 ; $ high_column = ( ( $ b + 1 ) >= $ c ) ? $ c - 1 : $ b + 1 ; while ( ( $ low_row > 0 - $ r && $ low_column > 0 - $ c ) ) { for ( $ i = $ low_column + 1 ; $ i <= $ high_column && $ i < $ c && $ low_row >= 0 ; ++ $ i ) echo $ mat [ $ low_row ] [ $ i ] , " ▁ " ; $ low_row -= 1 ; for ( $ i = $ low_row + 2 ; $ i <= $ high_row && $ i < $ r && $ high_column < $ c ; ++ $ i ) echo $ mat [ $ i ] [ $ high_column ] , " ▁ " ; $ high_column += 1 ; for ( $ i = $ high_column - 2 ; $ i >= $ low_column && $ i >= 0 && $ high_row < $ r ; -- $ i ) echo $ mat [ $ high_row ] [ $ i ] , " ▁ " ; $ high_row += 1 ; for ( $ i = $ high_row - 2 ; $ i > $ low_row && $ i >= 0 && $ low_column >= 0 ; -- $ i ) echo $ mat [ $ i ] [ $ low_column ] , " ▁ " ; $ low_column -= 1 ; } echo " STRNEWLINE " ; }
function printKDistinct ( $ arr , $ n , $ k ) { $ dist_count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ j ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) if ( $ i != $ j && $ arr [ $ j ] == $ arr [ $ i ] ) break ; if ( $ j == $ n ) $ dist_count ++ ; if ( $ dist_count == $ k ) return $ arr [ $ i ] ; } return -1 ; }
function make_sequence ( $ N ) { $ arr = array ( ) ; $ sum = 0 ; for ( $ i = 1 ; $ i <= $ N ; $ i ++ ) { if ( $ i % 2 == 1 ) $ arr [ $ i ] = 1 ; else $ arr [ $ i ] = 2 ; $ sum += $ arr [ $ i ] ; } if ( $ sum % 2 == 1 ) $ arr [ 2 ] = 3 ; for ( $ i = 1 ; $ i <= $ N ; $ i ++ ) echo $ arr [ $ i ] , " ▁ " ; }
function Nth_Term ( $ n ) { return ( 3 * pow ( $ n , 2 ) - $ n + 2 ) / ( 2 ) ; }
function uniqueCharacters ( $ str ) { $ checker = 0 ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) { $ bitAtIndex = $ str [ $ i ] - ' a ' ; if ( ( $ checker & ( 1 << $ bitAtIndex ) ) > 0 ) { return false ; } $ checker = $ checker | ( 1 << $ bitAtIndex ) ; } return true ; } $ str = " geeksforgeeks " ; if ( uniqueCharacters ( $ str ) ) { echo " The ▁ String ▁ " , $ str , " ▁ has ▁ all ▁ unique ▁ characters STRNEWLINE " ; } else { echo " The ▁ String ▁ " , $ str , " ▁ has ▁ duplicate ▁ characters STRNEWLINE " ; }
function calculate ( & $ array , $ size ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ size ; $ i ++ ) if ( $ array [ $ i ] % 2 == 0 && $ array [ $ i ] != 0 && $ array [ $ i ] != 2 ) $ count ++ ; return $ count ; }
function countNumbers ( $ N ) { return ( pow ( 10 , $ N ) - 1 ) - ( pow ( 10 , $ N ) - pow ( 8 , $ N ) ) / 2 ; }
function findM ( $ s , $ x ) { $ cnt = 0 ; for ( $ i = 0 ; $ i < strlen ( $ s ) ; $ i ++ ) { if ( ord ( $ s [ $ i ] ) - ord ( '0' ) != $ x ) $ cnt ++ ; } return $ cnt ; }
function isEven ( $ s ) { $ l = strlen ( $ s ) ; $ dotSeen = false ; for ( $ i = $ l - 1 ; $ i >= 0 ; $ i -- ) { if ( $ s [ $ i ] == '0' && $ dotSeen == false ) continue ; if ( $ s [ $ i ] == ' . ' ) { $ dotSeen = true ; continue ; } if ( ( $ s [ $ i ] - '0' ) % 2 == 0 ) return true ; return false ; } }
