function sumNodes ( $ l ) { $ leafNodeCount = ( $ l - 1 ) * ( $ l - 1 ) ; $ sumLastLevel = 0 ; $ sumLastLevel = ( $ leafNodeCount * ( $ leafNodeCount + 1 ) ) / 2 ; $ sum = $ sumLastLevel * $ l ; return $ sum ; }
function minCost ( $ cost ) { global $ INF ; global $ N ; $ dist [ $ N ] = array ( ) ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) $ dist [ $ i ] = $ INF ; $ dist [ 0 ] = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ N ; $ j ++ ) if ( $ dist [ $ j ] > $ dist [ $ i ] + $ cost [ $ i ] [ $ j ] ) $ dist [ $ j ] = $ dist [ $ i ] + $ cost [ $ i ] [ $ j ] ; return $ dist [ $ N - 1 ] ; }
function numOfways ( $ n , $ k ) { $ p = 1 ; if ( $ k % 2 ) $ p = -1 ; return ( pow ( $ n - 1 , $ k ) + $ p * ( $ n - 1 ) ) / $ n ; }
function power ( $ n ) { if ( $ n == 1 ) return 2 ; return 2 * power ( $ n - 1 ) ; } { $ n = 4 ; echo ( power ( $ n ) ) ; } }
function checkStar ( $ mat ) { global $ size ; $ vertexD1 = 0 ; $ vertexDn_1 = 0 ; if ( $ size == 1 ) return ( $ mat [ 0 ] [ 0 ] == 0 ) ; if ( $ size == 2 ) return ( $ mat [ 0 ] [ 0 ] == 0 && $ mat [ 0 ] [ 1 ] == 1 && $ mat [ 1 ] [ 0 ] == 1 && $ mat [ 1 ] [ 1 ] == 0 ) ; for ( $ i = 0 ; $ i < $ size ; $ i ++ ) { $ degreeI = 0 ; for ( $ j = 0 ; $ j < $ size ; $ j ++ ) if ( $ mat [ $ i ] [ $ j ] ) $ degreeI ++ ; if ( $ degreeI == 1 ) $ vertexD1 ++ ; else if ( $ degreeI == $ size - 1 ) $ vertexDn_1 ++ ; } return ( $ vertexD1 == ( $ size - 1 ) && $ vertexDn_1 == 1 ) ; }
function printSorted ( $ arr , $ start , $ end ) { if ( $ start > $ end ) return ; printSorted ( $ arr , $ start * 2 + 1 , $ end ) ; echo ( $ arr [ $ start ] . " " ) ; printSorted ( $ arr , $ start * 2 + 2 , $ end ) ; }
function pairs ( $ arr , $ n , $ k ) { $ smallest = PHP_INT_MAX ; $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) { if ( abs ( $ arr [ $ i ] + $ arr [ $ j ] - $ k ) < $ smallest ) { $ smallest = abs ( $ arr [ $ i ] + $ arr [ $ j ] - $ k ) ; $ count = 1 ; } else if ( abs ( $ arr [ $ i ] + $ arr [ $ j ] - $ k ) == $ smallest ) $ count ++ ; } echo " Minimal Value = " ▁ , ▁ $ smallest ▁ , ▁ " " ; STRNEWLINE TABSYMBOL TABSYMBOL echo ▁ " Total Pairs = " , ▁ $ count ▁ , ▁ " " }
function middlesum ( $ mat , $ n ) { $ row_sum = 0 ; $ col_sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ row_sum += $ mat [ $ n / 2 ] [ $ i ] ; echo " Sum ▁ of ▁ middle ▁ row ▁ = ▁ " , $ row_sum , " STRNEWLINE " ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ col_sum += $ mat [ $ i ] [ $ n / 2 ] ; echo " Sum ▁ of ▁ middle ▁ column ▁ = ▁ " , $ col_sum ; }
function interchangeFirstLast ( & $ m ) { global $ n ; $ rows = $ n ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ t = $ m [ 0 ] [ $ i ] ; $ m [ 0 ] [ $ i ] = $ m [ $ rows - 1 ] [ $ i ] ; $ m [ $ rows - 1 ] [ $ i ] = $ t ; } } $ m = array ( array ( 8 , 9 , 7 , 6 ) , array ( 4 , 7 , 6 , 5 ) , array ( 3 , 2 , 1 , 8 ) , array ( 9 , 9 , 7 , 7 ) ) ; interchangeFirstLast ( $ m ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) echo $ m [ $ i ] [ $ j ] . " ▁ " ; echo " STRNEWLINE " ; }
function checkMarkov ( $ m ) { $ n = 3 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sum = 0 ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) $ sum = $ sum + $ m [ $ i ] [ $ j ] ; if ( $ sum != 1 ) return false ; } return true ; }
function isDiagonalMatrix ( $ mat ) { global $ N ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) for ( $ j = 0 ; $ j < $ N ; $ j ++ ) if ( ( $ i != $ j ) && ( $ mat [ $ i ] [ $ j ] != 0 ) ) return false ; return true ; }
function isScalarMatrix ( $ mat ) { global $ N ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) for ( $ j = 0 ; $ j < $ N ; $ j ++ ) if ( ( $ i != $ j ) && ( $ mat [ $ i ] [ $ j ] != 0 ) ) return false ; for ( $ i = 0 ; $ i < $ N - 1 ; $ i ++ ) if ( $ mat [ $ i ] [ $ i ] != $ mat [ $ i + 1 ] [ $ i + 1 ] ) return false ; return true ; }
function Kroneckerproduct ( $ A , $ B ) { global $ cola ; global $ rowa ; global $ colb ; global $ rowb ; $ C ; for ( $ i = 0 ; $ i < $ rowa ; $ i ++ ) { for ( $ k = 0 ; $ k < $ rowb ; $ k ++ ) { for ( $ j = 0 ; $ j < $ cola ; $ j ++ ) { for ( $ l = 0 ; $ l < $ colb ; $ l ++ ) { $ C [ $ i + $ l + 1 ] [ $ j + $ k + 1 ] = $ A [ $ i ] [ $ j ] * $ B [ $ k ] [ $ l ] ; echo ( $ C [ $ i + $ l + 1 ] [ $ j + $ k + 1 ] ) , " TABSYMBOL " ; } } echo " STRNEWLINE " ; } } }
function find ( $ n , $ k ) { if ( $ n + 1 >= $ k ) return ( $ k - 1 ) ; else return ( 2 * $ n + 1 - $ k ) ; }
function minimumflip ( $ mat , $ n ) { global $ N ; $ transpose ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ n ; $ j ++ ) $ transpose [ $ i ] [ $ j ] = $ mat [ $ j ] [ $ i ] ; $ flip = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ n ; $ j ++ ) if ( $ transpose [ $ i ] [ $ j ] != $ mat [ $ i ] [ $ j ] ) $ flip ++ ; return $ flip / 2 ; }
function minimumflip ( $ mat , $ n ) { $ flip = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ i ; $ j ++ ) if ( $ mat [ $ i ] [ $ j ] != $ mat [ $ j ] [ $ i ] ) $ flip ++ ; return $ flip ; }
function isLowerTriangularMatrix ( $ mat ) { global $ N ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ N ; $ j ++ ) if ( $ mat [ $ i ] [ $ j ] != 0 ) return false ; return true ; }
function isUpperTriangularMatrix ( $ mat ) { global $ N ; for ( $ i = 1 ; $ i < $ N ; $ i ++ ) for ( $ j = 0 ; $ j < $ i ; $ j ++ ) if ( $ mat [ $ i ] [ $ j ] != 0 ) return false ; return true ; }
function freq ( $ ar , $ m , $ n ) { $ even = 0 ; $ odd = 0 ; for ( $ i = 0 ; $ i < $ m ; ++ $ i ) { for ( $ j = 0 ; $ j < $ n ; ++ $ j ) { if ( ( $ ar [ $ i ] [ $ j ] % 2 ) == 0 ) ++ $ even ; else ++ $ odd ; } } echo " ▁ Frequency ▁ of ▁ odd ▁ number ▁ = ▁ " , $ odd , " STRNEWLINE " ; echo " ▁ Frequency ▁ of ▁ even ▁ number ▁ = ▁ " , $ even ; }
function Identity ( $ num ) { $ row ; $ col ; for ( $ row = 0 ; $ row < $ num ; $ row ++ ) { for ( $ col = 0 ; $ col < $ num ; $ col ++ ) { if ( $ row == $ col ) echo 1 , " ▁ " ; else echo 0 , " ▁ " ; } echo " STRNEWLINE " ; } return 0 ; }
function isIdentity ( $ mat , $ N ) { for ( $ row = 0 ; $ row < $ N ; $ row ++ ) { for ( $ col = 0 ; $ col < $ N ; $ col ++ ) { if ( $ row == $ col and $ mat [ $ row ] [ $ col ] != 1 ) return false ; else if ( $ row != $ col && $ mat [ $ row ] [ $ col ] != 0 ) return false ; } } return true ; }
function search ( & $ mat , $ n , $ x ) { $ i = 0 ; $ j = $ n - 1 ; while ( $ i < $ n && $ j >= 0 ) { if ( $ mat [ $ i ] [ $ j ] == $ x ) { echo " n ▁ found ▁ at ▁ " . $ i . " , ▁ " . $ j ; return 1 ; } if ( $ mat [ $ i ] [ $ j ] > $ x ) $ j -- ; else $ i ++ ; } echo " n ▁ Element ▁ not ▁ found " ; return 0 ; }
function calculateEnergy ( $ mat , $ n ) { $ i_des ; $ j_des ; $ q ; $ tot_energy = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { $ q = ( int ) ( $ mat [ $ i ] [ $ j ] / $ n ) ; $ i_des = $ q ; $ j_des = $ mat [ $ i ] [ $ j ] - ( $ n * $ q ) ; $ tot_energy += abs ( $ i_des - $ i ) + abs ( $ j_des - $ j ) ; } } return $ tot_energy ; }
function countCommon ( $ mat , $ n ) { global $ MAX ; $ res = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ mat [ $ i ] [ $ i ] == $ mat [ $ i ] [ $ n - $ i - 1 ] ) $ res ++ ; return $ res ; }
function areSumSame ( $ a , $ n , $ m ) { $ sum1 = 0 ; $ sum2 = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sum1 = 0 ; $ sum2 = 0 ; for ( $ j = 0 ; $ j < $ m ; $ j ++ ) { $ sum1 += $ a [ $ i ] [ $ j ] ; $ sum2 += $ a [ $ j ] [ $ i ] ; } if ( $ sum1 == $ sum2 ) return true ; } return false ; }
function findMax ( $ arr ) { global $ N ; $ row = 0 ; $ i ; $ j = $ N - 1 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { while ( $ arr [ $ i ] [ $ j ] == 1 && $ j >= 0 ) { $ row = $ i ; $ j -- ; } } echo " Row ▁ number ▁ = ▁ " , $ row + 1 ; echo " , MaxCount = " }
function isSymmetric ( $ mat , $ N ) { for ( $ i = 0 ; $ i < $ N ; $ i ++ ) for ( $ j = 0 ; $ j < $ N ; $ j ++ ) if ( $ mat [ $ i ] [ $ j ] != $ mat [ $ j ] [ $ i ] ) return false ; return true ; }
function printDiagonalSums ( $ mat , $ n ) { global $ MAX ; $ principal = 0 ; $ secondary = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ principal += $ mat [ $ i ] [ $ i ] ; $ secondary += $ mat [ $ i ] [ $ n - $ i - 1 ] ; } echo " Principal ▁ Diagonal : " , $ principal , " STRNEWLINE " ; echo " Secondary ▁ Diagonal : " , $ secondary , " STRNEWLINE " ; }
function getBoundarySum ( $ a , $ m , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ m ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ i == 0 ) $ sum += $ a [ $ i ] [ $ j ] ; else if ( $ i == $ m - 1 ) $ sum += $ a [ $ i ] [ $ j ] ; else if ( $ j == 0 ) $ sum += $ a [ $ i ] [ $ j ] ; else if ( $ j == $ n - 1 ) $ sum += $ a [ $ i ] [ $ j ] ; } } return $ sum ; }
function printSpiral ( $ mat , $ r , $ c ) { global $ MAX ; $ i ; $ a = 0 ; $ b = 2 ; $ low_row = ( 0 > $ a ) ? 0 : $ a ; $ low_column = ( 0 > $ b ) ? 0 : $ b - 1 ; $ high_row = ( ( $ a + 1 ) >= $ r ) ? $ r - 1 : $ a + 1 ; $ high_column = ( ( $ b + 1 ) >= $ c ) ? $ c - 1 : $ b + 1 ; while ( ( $ low_row > 0 - $ r && $ low_column > 0 - $ c ) ) { for ( $ i = $ low_column + 1 ; $ i <= $ high_column && $ i < $ c && $ low_row >= 0 ; ++ $ i ) echo $ mat [ $ low_row ] [ $ i ] , " ▁ " ; $ low_row -= 1 ; for ( $ i = $ low_row + 2 ; $ i <= $ high_row && $ i < $ r && $ high_column < $ c ; ++ $ i ) echo $ mat [ $ i ] [ $ high_column ] , " ▁ " ; $ high_column += 1 ; for ( $ i = $ high_column - 2 ; $ i >= $ low_column && $ i >= 0 && $ high_row < $ r ; -- $ i ) echo $ mat [ $ high_row ] [ $ i ] , " ▁ " ; $ high_row += 1 ; for ( $ i = $ high_row - 2 ; $ i > $ low_row && $ i >= 0 && $ low_column >= 0 ; -- $ i ) echo $ mat [ $ i ] [ $ low_column ] , " ▁ " ; $ low_column -= 1 ; } echo " STRNEWLINE " ; }
function difference ( $ arr , $ n ) { $ d1 = 0 ; $ d2 = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ i == $ j ) $ d1 += $ arr [ $ i ] [ $ j ] ; if ( $ i == $ n - $ j - 1 ) $ d2 += $ arr [ $ i ] [ $ j ] ; } } return abs ( $ d1 - $ d2 ) ; } { $ n = 3 ; $ arr = array ( array ( 11 , 2 , 4 ) , array ( 4 , 5 , 6 ) , array ( 10 , 8 , -12 ) ) ; echo difference ( $ arr , $ n ) ; return 0 ; }
function difference ( $ arr , $ n ) { $ d1 = 0 ; $ d2 = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ d1 += $ arr [ $ i ] [ $ i ] ; $ d2 += $ arr [ $ i ] [ $ n - $ i - 1 ] ; } return abs ( $ d1 - $ d2 ) ; } { $ n = 3 ; $ arr = array ( array ( 11 , 2 , 4 ) , array ( 4 , 5 , 6 ) , array ( 10 , 8 , -12 ) ) ; echo difference ( $ arr , $ n ) ; return 0 ; }
function maxMin ( $ arr , $ n ) { $ min = PHP_INT_MAX ; $ max = PHP_INT_MIN ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j <= $ n / 2 ; $ j ++ ) { if ( $ arr [ $ i ] [ $ j ] > $ arr [ $ i ] [ $ n - $ j - 1 ] ) { if ( $ min > $ arr [ $ i ] [ $ n - $ j - 1 ] ) $ min = $ arr [ $ i ] [ $ n - $ j - 1 ] ; if ( $ max < $ arr [ $ i ] [ $ j ] ) $ max = $ arr [ $ i ] [ $ j ] ; } else { if ( $ min > $ arr [ $ i ] [ $ j ] ) $ min = $ arr [ $ i ] [ $ j ] ; if ( $ max < $ arr [ $ i ] [ $ n - $ j - 1 ] ) $ max = $ arr [ $ i ] [ $ n - $ j - 1 ] ; } } } echo " Maximum = " ▁ , ▁ $ max STRNEWLINE TABSYMBOL TABSYMBOL , " , Minimum = " }
function minOperation ( & $ arr ) { global $ N , $ M ; $ ans = 0 ; for ( $ i = $ N - 1 ; $ i >= 0 ; $ i -- ) { for ( $ j = $ M - 1 ; $ j >= 0 ; $ j -- ) { if ( $ arr [ $ i ] [ $ j ] == 0 ) { $ ans ++ ; for ( $ k = 0 ; $ k <= $ i ; $ k ++ ) { for ( $ h = 0 ; $ h <= $ j ; $ h ++ ) { if ( $ arr [ $ k ] [ $ h ] == 1 ) $ arr [ $ k ] [ $ h ] = 0 ; else $ arr [ $ k ] [ $ h ] = 1 ; } } } } } return $ ans ; }
function findSum ( $ n ) { $ ans = 0 ; $ temp = 0 ; $ num ; for ( $ i = 1 ; $ i <= $ n and $ temp < $ n ; $ i ++ ) { $ temp = $ i - 1 ; $ num = 1 ; while ( $ temp < $ n ) { if ( $ temp + $ i <= $ n ) $ ans += ( $ i * $ num ) ; else $ ans += ( ( $ n - $ temp ) * $ num ) ; $ temp += $ i ; $ num ++ ; } } return $ ans ; }
function findSum ( $ n ) { $ arr = array ( array ( ) ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ n ; $ j ++ ) $ arr [ $ i ] [ $ j ] = abs ( $ i - $ j ) ; $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ n ; $ j ++ ) $ sum += $ arr [ $ i ] [ $ j ] ; return $ sum ; }
function findSum ( $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum += $ i * ( $ n - $ i ) ; return 2 * $ sum ; }
function findSum ( $ n ) { $ n -- ; $ sum = 0 ; $ sum += ( $ n * ( $ n + 1 ) ) / 2 ; $ sum += ( $ n * ( $ n + 1 ) * ( 2 * $ n + 1 ) ) / 6 ; return $ sum ; }
function spiralDiaSum ( $ n ) { if ( $ n == 1 ) return 1 ; return ( 4 * $ n * $ n - 6 * $ n + 6 + spiralDiaSum ( $ n - 2 ) ) ; }
function maxXOR ( $ mat , $ N ) { $ r_xor ; $ c_xor ; $ max_xor = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { $ r_xor = 0 ; $ c_xor = 0 ; for ( $ j = 0 ; $ j < $ N ; $ j ++ ) { $ r_xor = $ r_xor ^ $ mat [ $ i ] [ $ j ] ; $ c_xor = $ c_xor ^ $ mat [ $ j ] [ $ i ] ; } if ( $ max_xor < max ( $ r_xor , $ c_xor ) ) $ max_xor = max ( $ r_xor , $ c_xor ) ; } return $ max_xor ; }
function countZeroes ( $ mat ) { $ row = $ N - 1 ; $ col = 0 ; $ count = 0 ; while ( $ col < $ N ) { while ( $ mat [ $ row ] [ $ col ] ) if ( -- $ row < 0 ) return $ count ; $ count += ( $ row + 1 ) ; $ col ++ ; } return $ count ; }
function countNegative ( $ M , $ n , $ m ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ m ; $ j ++ ) { if ( $ M [ $ i ] [ $ j ] < 0 ) $ count += 1 ; else break ; } } return $ count ; }
function countNegative ( $ M , $ n , $ m ) { $ count = 0 ; $ i = 0 ; $ j = $ m - 1 ; while ( $ j >= 0 and $ i < $ n ) { if ( $ M [ $ i ] [ $ j ] < 0 ) { $ count += $ j + 1 ; $ i += 1 ; } else $ j -= 1 ; } return $ count ; }
function printSpiral ( $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { $ x ; $ x = min ( min ( $ i , $ j ) , min ( $ n - 1 - $ i , $ n - 1 - $ j ) ) ; if ( $ i <= $ j ) echo " TABSYMBOL ▁ " , ( $ n - 2 * $ x ) * ( $ n - 2 * $ x ) - ( $ i - $ x ) - ( $ j - $ x ) ; else echo " TABSYMBOL ▁ " , ( $ n - 2 * $ x - 2 ) * ( $ n - 2 * $ x - 2 ) + ( $ i - $ x ) + ( $ j - $ x ) ; } echo " STRNEWLINE " ; } }
function findMaxValue ( & $ mat ) { global $ N ; $ maxValue = PHP_INT_MIN ; for ( $ a = 0 ; $ a < $ N - 1 ; $ a ++ ) for ( $ b = 0 ; $ b < $ N - 1 ; $ b ++ ) for ( $ d = $ a + 1 ; $ d < $ N ; $ d ++ ) for ( $ e = $ b + 1 ; $ e < $ N ; $ e ++ ) if ( $ maxValue < ( $ mat [ $ d ] [ $ e ] - $ mat [ $ a ] [ $ b ] ) ) $ maxValue = $ mat [ $ d ] [ $ e ] - $ mat [ $ a ] [ $ b ] ; return $ maxValue ; }
function countIslands ( $ mat ) { $ M = 6 ; $ N = 3 ; $ count = 0 ; for ( $ i = 0 ; $ i < $ M ; $ i ++ ) { for ( $ j = 0 ; $ j < $ N ; $ j ++ ) { if ( $ mat [ $ i ] [ $ j ] == ' X ' ) { if ( ( $ i == 0 $ mat [ $ i - 1 ] [ $ j ] == ' O ' ) && ( $ j == 0 $ mat [ $ i ] [ $ j - 1 ] == ' O ' ) ) $ count ++ ; } } } return $ count ; }
function printSumSimple ( $ mat , $ k ) { global $ n ; if ( $ k > $ n ) return ; for ( $ i = 0 ; $ i < $ n - $ k + 1 ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n - $ k + 1 ; $ j ++ ) { $ sum = 0 ; for ( $ p = $ i ; $ p < $ k + $ i ; $ p ++ ) for ( $ q = $ j ; $ q < $ k + $ j ; $ q ++ ) $ sum += $ mat [ $ p ] [ $ q ] ; echo $ sum , " " ; } echo " STRNEWLINE " ; } }
function transpose ( & $ A , & $ B ) { for ( $ i = 0 ; $ i < $ N ; $ i ++ ) for ( $ j = 0 ; $ j < $ M ; $ j ++ ) $ B [ $ i ] [ $ j ] = $ A [ $ j ] [ $ i ] ; } $ A = array ( array ( 1 , 1 , 1 , 1 ) , array ( 2 , 2 , 2 , 2 ) , array ( 3 , 3 , 3 , 3 ) ) ; $ N = 4 ; $ M = 3 ; transpose ( $ A , $ B ) ; echo " Result ▁ matrix ▁ is ▁ STRNEWLINE " ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { for ( $ j = 0 ; $ j < $ M ; $ j ++ ) { echo $ B [ $ i ] [ $ j ] ; echo " ▁ " ; } echo " STRNEWLINE " ; }
function transpose ( & $ A ) { for ( $ i = 0 ; $ i < $ N ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ N ; $ j ++ ) { $ temp = $ A [ $ i ] [ $ j ] ; $ A [ $ i ] [ $ j ] = $ A [ $ j ] [ $ i ] ; $ A [ $ j ] [ $ i ] = $ temp ; } } $ N = 4 ; $ A = array ( array ( 1 , 1 , 1 , 1 ) , array ( 2 , 2 , 2 , 2 ) , array ( 3 , 3 , 3 , 3 ) , array ( 4 , 4 , 4 , 4 ) ) ; transpose ( $ A ) ; echo " Modified ▁ matrix ▁ is ▁ " . " STRNEWLINE " ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { for ( $ j = 0 ; $ j < $ N ; $ j ++ ) echo $ A [ $ i ] [ $ j ] . " ▁ " ; echo " STRNEWLINE " ; }
function add ( & $ A , & $ B , & $ C ) { for ( $ i = 0 ; $ i < $ N ; $ i ++ ) for ( $ j = 0 ; $ j < $ N ; $ j ++ ) $ C [ $ i ] [ $ j ] = $ A [ $ i ] [ $ j ] + $ B [ $ i ] [ $ j ] ; } $ A = array ( array ( 1 , 1 , 1 , 1 ) , array ( 2 , 2 , 2 , 2 ) , array ( 3 , 3 , 3 , 3 ) , array ( 4 , 4 , 4 , 4 ) ) ; $ B = array ( array ( 1 , 1 , 1 , 1 ) , array ( 2 , 2 , 2 , 2 ) , array ( 3 , 3 , 3 , 3 ) , array ( 4 , 4 , 4 , 4 ) ) ; $ N = 4 ; add ( $ A , $ B , $ C ) ; echo " Result ▁ matrix ▁ is ▁ STRNEWLINE " ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { for ( $ j = 0 ; $ j < $ N ; $ j ++ ) { echo $ C [ $ i ] [ $ j ] ; echo " ▁ " ; } echo " STRNEWLINE " ; }
function subtract ( & $ A , & $ B , & $ C ) { $ N = 4 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) for ( $ j = 0 ; $ j < $ N ; $ j ++ ) $ C [ $ i ] [ $ j ] = $ A [ $ i ] [ $ j ] - $ B [ $ i ] [ $ j ] ; } $ N = 4 ; $ A = array ( array ( 1 , 1 , 1 , 1 ) , array ( 2 , 2 , 2 , 2 ) , array ( 3 , 3 , 3 , 3 ) , array ( 4 , 4 , 4 , 4 ) ) ; $ B = array ( array ( 1 , 1 , 1 , 1 ) , array ( 2 , 2 , 2 , 2 ) , array ( 3 , 3 , 3 , 3 ) , array ( 4 , 4 , 4 , 4 ) ) ; subtract ( $ A , $ B , $ C ) ; echo " Result ▁ matrix ▁ is ▁ STRNEWLINE " ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { for ( $ j = 0 ; $ j < $ N ; $ j ++ ) { echo $ C [ $ i ] [ $ j ] ; echo " ▁ " ; } echo " STRNEWLINE " ; }
function printNGE ( $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ next = -1 ; for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) { if ( $ arr [ $ i ] < $ arr [ $ j ] ) { $ next = $ arr [ $ j ] ; break ; } } echo $ arr [ $ i ] . " -- " . ▁ $ next . " " } }
function printMaxOfMin ( $ arr , $ n ) { for ( $ k = 1 ; $ k <= $ n ; $ k ++ ) { $ maxOfMin = PHP_INT_MIN ; for ( $ i = 0 ; $ i <= $ n - $ k ; $ i ++ ) { $ min = $ arr [ $ i ] ; for ( $ j = 1 ; $ j < $ k ; $ j ++ ) { if ( $ arr [ $ i + $ j ] < $ min ) $ min = $ arr [ $ i + $ j ] ; } if ( $ min > $ maxOfMin ) $ maxOfMin = $ min ; } echo $ maxOfMin , " " ; } }
function generate_derangement ( $ N ) { $ S = array ( ) ; for ( $ i = 1 ; $ i <= $ N ; $ i ++ ) $ S [ $ i ] = $ i ; $ D = array ( ) ; for ( $ i = 1 ; $ i <= $ N ; $ i += 2 ) { if ( $ i == $ N ) { $ D [ $ N ] = $ S [ $ N - 1 ] ; $ D [ $ N - 1 ] = $ S [ $ N ] ; } else { $ D [ $ i ] = $ i + 1 ; $ D [ $ i + 1 ] = $ i ; } } for ( $ i = 1 ; $ i <= $ N ; $ i ++ ) echo $ D [ $ i ] . " ▁ " ; echo " STRNEWLINE " ; }
function sumBetweenTwoKth ( $ arr , $ n , $ k1 , $ k2 ) { sort ( $ arr ) ; $ result = 0 ; for ( $ i = $ k1 ; $ i < $ k2 - 1 ; $ i ++ ) $ result += $ arr [ $ i ] ; return $ result ; }
function minSum ( $ a , $ n ) { sort ( $ a ) ; $ num1 = 0 ; $ num2 = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ i % 2 == 0 ) $ num1 = $ num1 * 10 + $ a [ $ i ] ; else $ num2 = $ num2 * 10 + $ a [ $ i ] ; } return ( $ num2 + $ num1 ) ; }
function areDisjoint ( $ set1 , $ set2 , $ m , $ n ) { for ( $ i = 0 ; $ i < $ m ; $ i ++ ) for ( $ j = 0 ; $ j < $ n ; $ j ++ ) if ( $ set1 [ $ i ] == $ set2 [ $ j ] ) return false ; return true ; }
function findMissing ( $ a , $ b , $ n , $ m ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ j ; for ( $ j = 0 ; $ j < $ m ; $ j ++ ) if ( $ a [ $ i ] == $ b [ $ j ] ) break ; if ( $ j == $ m ) echo $ a [ $ i ] , " ▁ " ; } }
function areEqual ( $ arr1 , $ arr2 , $ n , $ m ) { if ( $ n != $ m ) return false ; sort ( $ arr1 ) ; sort ( $ arr2 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr1 [ $ i ] != $ arr2 [ $ i ] ) return false ; return true ; }
function isProduct ( $ arr , $ n , $ x ) { for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) for ( $ j = $ i + 1 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] * $ arr [ $ j ] == $ x ) return true ; return false ; }
function findGreatest ( $ arr , $ n ) { $ result = -1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ n - 1 ; $ j ++ ) for ( $ k = $ j + 1 ; $ k < $ n ; $ k ++ ) if ( $ arr [ $ j ] * $ arr [ $ k ] == $ arr [ $ i ] ) $ result = max ( $ result , $ arr [ $ i ] ) ; return $ result ; }
function subset ( $ ar , $ n ) { $ res = 0 ; sort ( $ ar ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ count = 1 ; for ( ; $ i < $ n - 1 ; $ i ++ ) { if ( $ ar [ $ i ] == $ ar [ $ i + 1 ] ) $ count ++ ; else break ; } $ res = max ( $ res , $ count ) ; } return $ res ; }
function getPairsCount ( $ arr , $ n , $ sum ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) if ( $ arr [ $ i ] + $ arr [ $ j ] == $ sum ) $ count ++ ; return $ count ; }
function countPairs ( $ arr1 , $ arr2 , $ m , $ n , $ x ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ m ; $ i ++ ) for ( $ j = 0 ; $ j < $ n ; $ j ++ ) if ( ( $ arr1 [ $ i ] + $ arr2 [ $ j ] ) == $ x ) $ count ++ ; return $ count ; }
function countPairs ( $ arr1 , $ arr2 , $ m , $ n , $ x ) { $ count = 0 ; $ l = 0 ; $ r = $ n - 1 ; while ( $ l < $ m and $ r >= 0 ) { if ( ( $ arr1 [ $ l ] + $ arr2 [ $ r ] ) == $ x ) { $ l ++ ; $ r -- ; $ count ++ ; } else if ( ( $ arr1 [ $ l ] + $ arr2 [ $ r ] ) < $ x ) $ l ++ ; else $ r -- ; } return $ count ; }
function countPairs ( $ arr , $ n ) { $ result = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) { $ product = $ arr [ $ i ] * $ arr [ $ j ] ; for ( $ k = 0 ; $ k < $ n ; $ k ++ ) { if ( $ arr [ $ k ] == $ product ) { $ result ++ ; break ; } } } } return $ result ; }
function findPairs ( $ arr1 , $ arr2 , $ n , $ m , $ x ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ m ; $ j ++ ) if ( $ arr1 [ $ i ] + $ arr2 [ $ j ] == $ x ) echo $ arr1 [ $ i ] . " ▁ " . $ arr2 [ $ j ] . " STRNEWLINE " ; }
function findPair ( $ arr , $ n ) { $ found = false ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) { for ( $ k = 0 ; $ k < $ n ; $ k ++ ) { if ( $ arr [ $ i ] + $ arr [ $ j ] == $ arr [ $ k ] ) { echo $ arr [ $ i ] , " ▁ " , $ arr [ $ j ] ; $ found = true ; } } } } if ( $ found == false ) echo " Not ▁ exist " ; }
function printPairs ( $ arr , $ n , $ k ) { $ isPairFound = true ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ i != $ j && $ arr [ $ i ] % $ arr [ $ j ] == $ k ) { echo " ( " , $ arr [ $ i ] , " , ▁ " , $ arr [ $ j ] , " ) " , " ▁ " ; $ isPairFound = true ; } } } return $ isPairFound ; }
function printKDistinct ( $ arr , $ n , $ k ) { $ dist_count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ j ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) if ( $ i != $ j && $ arr [ $ j ] == $ arr [ $ i ] ) break ; if ( $ j == $ n ) $ dist_count ++ ; if ( $ dist_count == $ k ) return $ arr [ $ i ] ; } return -1 ; }
function findTriplet ( $ a1 , $ a2 , $ a3 , $ n1 , $ n2 , $ n3 , $ sum ) { for ( $ i = 0 ; $ i < $ n1 ; $ i ++ ) for ( $ j = 0 ; $ j < $ n2 ; $ j ++ ) for ( $ k = 0 ; $ k < $ n3 ; $ k ++ ) if ( $ a1 [ $ i ] + $ a2 [ $ j ] + $ a3 [ $ k ] == $ sum ) return true ; return false ; }
function minInsertion ( $ str ) { $ n = strlen ( $ str ) ; $ res = 0 ; $ count = array ( 26 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ count [ ord ( $ str [ $ i ] ) - ord ( ' a ' ) ] ++ ; for ( $ i = 0 ; $ i < 26 ; $ i ++ ) { if ( $ count [ $ i ] % 2 == 1 ) $ res ++ ; } return ( $ res == 0 ) ? 0 : $ res - 1 ; }
function findDiff ( $ arr , $ n ) { sort ( $ arr ) ; $ count = 0 ; $ max_count = 0 ; $ min_count = $ n ; for ( $ i = 0 ; $ i < ( $ n - 1 ) ; $ i ++ ) { if ( $ arr [ $ i ] == $ arr [ $ i + 1 ] ) { $ count += 1 ; continue ; } else { $ max_count = max ( $ max_count , $ count ) ; $ min_count = min ( $ min_count , $ count ) ; $ count = 0 ; } } return ( $ max_count - $ min_count ) ; }
function maxDiff ( $ arr , $ n ) { $ result = 0 ; sort ( $ arr ) ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { if ( $ arr [ $ i ] != $ arr [ $ i + 1 ] ) $ result += abs ( $ arr [ $ i ] ) ; else $ i ++ ; } if ( $ arr [ $ n - 2 ] != $ arr [ $ n - 1 ] ) $ result += abs ( $ arr [ $ n - 1 ] ) ; return $ result ; }
function calculate ( $ a , $ n ) { sort ( $ a ) ; $ count = 1 ; $ answer = 0 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] == $ a [ $ i - 1 ] ) { $ count += 1 ; } else { $ answer = $ answer + ( $ count * ( $ count - 1 ) ) / 2 ; $ count = 1 ; } } $ answer = $ answer + ( $ count * ( $ count - 1 ) ) / 2 ; return $ answer ; }
function findSubArray ( & $ arr , $ n ) { $ sum = 0 ; $ maxsize = -1 ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { $ sum = ( $ arr [ $ i ] == 0 ) ? -1 : 1 ; for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) { ( $ arr [ $ j ] == 0 ) ? ( $ sum += -1 ) : ( $ sum += 1 ) ; if ( $ sum == 0 && $ maxsize < $ j - $ i + 1 ) { $ maxsize = $ j - $ i + 1 ; $ startindex = $ i ; } } } if ( $ maxsize == -1 ) echo " No ▁ such ▁ subarray " ; else echo $ startindex . " ▁ to ▁ " . ( $ startindex + $ maxsize - 1 ) ; return $ maxsize ; }
function printAllAPTriplets ( $ arr , $ n ) { $ s = array ( ) ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) { $ diff = $ arr [ $ j ] - $ arr [ $ i ] ; if ( in_array ( $ arr [ $ i ] - $ diff , $ arr ) ) echo ( ( $ arr [ $ i ] - $ diff ) . " " ▁ . ▁ $ arr [ $ i ] ▁ . ▁ " " ▁ . ▁ $ arr [ $ j ] ▁ . ▁ " " } array_push ( $ s , $ arr [ $ i ] ) ; } }
function findAllTriplets ( $ arr , $ n ) { for ( $ i = 1 ; $ i < $ n - 1 ; $ i ++ ) { for ( $ j = $ i - 1 , $ k = $ i + 1 ; $ j >= 0 && $ k < $ n { if ( $ arr [ $ j ] + $ arr [ $ k ] == 2 * $ arr [ $ i ] ) { echo $ arr [ $ j ] . " ▁ " . $ arr [ $ i ] . " ▁ " . $ arr [ $ k ] . " STRNEWLINE " ; $ k ++ ; $ j -- ; } else if ( $ arr [ $ j ] + $ arr [ $ k ] < 2 * $ arr [ $ i ] ) $ k ++ ; else $ j -- ; } } }
function countPairs ( $ arr , $ n ) { $ ans = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) if ( $ arr [ $ i ] == $ arr [ $ j ] ) $ ans ++ ; return $ ans ; }
function countNum ( $ arr , $ n ) { $ count = 0 ; sort ( $ arr ) ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) if ( $ arr [ $ i ] != $ arr [ $ i + 1 ] && $ arr [ $ i ] != $ arr [ $ i + 1 ] - 1 ) $ count += $ arr [ $ i + 1 ] - $ arr [ $ i ] - 1 ; return $ count ; }
function findLargestd ( $ S , $ n ) { $ found = false ; sort ( $ S ) ; for ( $ i = $ n - 1 ; $ i >= 0 ; $ i -- ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ i == $ j ) continue ; for ( $ k = $ j + 1 ; $ k < $ n ; $ k ++ ) { if ( $ i == $ k ) continue ; for ( $ l = $ k + 1 ; $ l < $ n ; $ l ++ ) { if ( $ i == $ l ) continue ; if ( $ S [ $ i ] == $ S [ $ j ] + $ S [ $ k ] + $ S [ $ l ] ) { $ found = true ; return $ S [ $ i ] ; } } } } } if ( $ found == false ) return PHP_INT_MIN ; }
function recaman ( $ n ) { $ arr [ 0 ] = 0 ; echo $ arr [ 0 ] , " , ▁ " ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ curr = $ arr [ $ i - 1 ] - $ i ; $ j ; for ( $ j = 0 ; $ j < $ i ; $ j ++ ) { if ( ( $ arr [ $ j ] == $ curr ) $ curr < 0 ) { $ curr = $ arr [ $ i - 1 ] + $ i ; break ; } } $ arr [ $ i ] = $ curr ; echo $ arr [ $ i ] , " , ▁ " ; } }
function findArea ( $ arr , $ n ) { rsort ( $ arr ) ; $ dimension = array ( 0 , 0 ) ; for ( $ i = 0 , $ j = 0 ; $ i < $ n - 1 && $ j < 2 ; $ i ++ ) if ( $ arr [ $ i ] == $ arr [ $ i + 1 ] ) $ dimension [ $ j ++ ] = $ arr [ $ i ++ ] ; return ( $ dimension [ 0 ] * $ dimension [ 1 ] ) ; }
function search ( $ arr , $ l , $ h , $ key ) { if ( $ l > $ h ) return -1 ; $ mid = ( $ l + $ h ) / 2 ; if ( $ arr [ $ mid ] == $ key ) return $ mid ; if ( $ arr [ $ l ] <= $ arr [ $ mid ] ) { if ( $ key >= $ arr [ $ l ] && $ key <= $ arr [ $ mid ] ) return search ( $ arr , $ l , $ mid - 1 , $ key ) ; return search ( $ arr , $ mid + 1 , $ h , $ key ) ; } if ( $ key >= $ arr [ $ mid ] && $ key <= $ arr [ $ h ] ) return search ( $ arr , $ mid + 1 , $ h , $ key ) ; return search ( $ arr , $ l , $ mid - 1 , $ key ) ; }
function pairInSortedRotated ( $ arr , $ n , $ x ) { $ i ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) if ( $ arr [ $ i ] > $ arr [ $ i + 1 ] ) break ; $ l = ( $ i + 1 ) % $ n ; $ r = $ i ; while ( $ l != $ r ) { if ( $ arr [ $ l ] + $ arr [ $ r ] == $ x ) return true ; if ( $ arr [ $ l ] + $ arr [ $ r ] < $ x ) $ l = ( $ l + 1 ) % $ n ; else $ r = ( $ n + $ r - 1 ) % $ n ; } return false ; }
function pairsInSortedRotated ( $ arr , $ n , $ x ) { $ i ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) if ( $ arr [ $ i ] > $ arr [ $ i + 1 ] ) break ; $ l = ( $ i + 1 ) % $ n ; $ r = $ i ; $ cnt = 0 ; while ( $ l != $ r ) { if ( $ arr [ $ l ] + $ arr [ $ r ] == $ x ) { $ cnt ++ ; if ( $ l == ( $ r - 1 + $ n ) % $ n ) { return $ cnt ; } $ l = ( $ l + 1 ) % $ n ; $ r = ( $ r - 1 + $ n ) % $ n ; } else if ( $ arr [ $ l ] + $ arr [ $ r ] < $ x ) $ l = ( $ l + 1 ) % $ n ; else $ r = ( $ n + $ r - 1 ) % $ n ; } return $ cnt ; }
function maxSum ( $ arr , $ n ) { $ res = PHP_INT_MIN ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ curr_sum = 0 ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { $ index = ( $ i + $ j ) % $ n ; $ curr_sum += $ j * $ arr [ $ index ] ; } $ res = max ( $ res , $ curr_sum ) ; } return $ res ; }
function maxSum ( $ arr , $ n ) { $ cum_sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ cum_sum += $ arr [ $ i ] ; $ curr_val = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ curr_val += $ i * $ arr [ $ i ] ; $ res = $ curr_val ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ next_val = $ curr_val - ( $ cum_sum - $ arr [ $ i - 1 ] ) + $ arr [ $ i - 1 ] * ( $ n - 1 ) ; $ curr_val = $ next_val ; $ res = max ( $ res , $ next_val ) ; } return $ res ; }
function countRotations ( $ arr , $ n ) { $ min = $ arr [ 0 ] ; $ min_index ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ min > $ arr [ $ i ] ) { $ min = $ arr [ $ i ] ; $ min_index = $ i ; } } return $ min_index ; }
function countRotations ( $ arr , $ low , $ high ) { if ( $ high < $ low ) return 0 ; if ( $ high == $ low ) return $ low ; $ mid = $ low + ( $ high - $ low ) / 2 ; if ( $ mid < $ high && $ arr [ $ mid + 1 ] < $ arr [ $ mid ] ) return ( int ) ( $ mid + 1 ) ; if ( $ mid > $ low && $ arr [ $ mid ] < $ arr [ $ mid - 1 ] ) return ( int ) ( $ mid ) ; if ( $ arr [ $ high ] > $ arr [ $ mid ] ) return countRotations ( $ arr , $ low , $ mid - 1 ) ; return countRotations ( $ arr , $ mid + 1 , $ high ) ; }
function leftRotate ( $ arr , $ n , $ k ) { for ( $ i = $ k ; $ i < $ k + $ n ; $ i ++ ) echo $ arr [ $ i % $ n ] , " ▁ " ; }
function findMin ( $ arr , $ low , $ high ) { if ( $ high < $ low ) return $ arr [ 0 ] ; if ( $ high == $ low ) return $ arr [ $ low ] ; $ mid = $ low + ( $ high - $ low ) / 2 ; if ( $ mid < $ high && $ arr [ $ mid + 1 ] < $ arr [ $ mid ] ) return $ arr [ $ mid + 1 ] ; if ( $ mid > $ low && $ arr [ $ mid ] < $ arr [ $ mid - 1 ] ) return $ arr [ $ mid ] ; if ( $ arr [ $ high ] > $ arr [ $ mid ] ) return findMin ( $ arr , $ low , $ mid - 1 ) ; return findMin ( $ arr , $ mid + 1 , $ high ) ; }
function maxHamming ( $ arr , $ n ) { $ brr = array ( ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ brr [ $ i ] = $ arr [ $ i ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ brr [ $ n + $ i ] = $ arr [ $ i ] ; $ maxHam = 0 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ currHam = 0 ; for ( $ j = $ i , $ k = 0 ; $ j < ( $ i + $ n ) ; $ j ++ , $ k ++ ) if ( $ brr [ $ j ] != $ arr [ $ k ] ) $ currHam ++ ; if ( $ currHam == $ n ) return $ n ; $ maxHam = max ( $ maxHam , $ currHam ) ; } return $ maxHam ; }
function leftRotate ( $ arr , $ n , $ k ) { $ mod = $ k % $ n ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo ( $ arr [ ( $ mod + $ i ) % $ n ] ) , " ▁ " ; echo " STRNEWLINE " ; }
function splitArr ( & $ arr , $ n , $ k ) { for ( $ i = 0 ; $ i < $ k ; $ i ++ ) { $ x = $ arr [ 0 ] ; for ( $ j = 0 ; $ j < $ n - 1 ; ++ $ j ) $ arr [ $ j ] = $ arr [ $ j + 1 ] ; $ arr [ $ n - 1 ] = $ x ; } }
function pushZerosToEnd ( & $ arr , $ n ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] != 0 ) $ arr [ $ count ++ ] = $ arr [ $ i ] ; while ( $ count < $ n ) $ arr [ $ count ++ ] = 0 ; }
function reorder ( $ arr , $ index , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ temp [ $ index [ $ i ] ] = $ arr [ $ i ] ; } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ arr [ $ i ] = $ temp [ $ i ] ; $ index [ $ i ] = $ i ; } echo " Reordered ▁ array ▁ is : ▁ STRNEWLINE " ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { echo $ arr [ $ i ] . " " ; } echo " Modified Index array is : " for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { echo $ index [ $ i ] . " " ; } }
function rearrange ( & $ arr , $ n ) { $ temp = array ( ) ; $ small = 0 ; $ large = $ n - 1 ; $ flag = true ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ flag ) $ temp [ $ i ] = $ arr [ $ large -- ] ; else $ temp [ $ i ] = $ arr [ $ small ++ ] ; $ flag = ! $ flag ; } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ arr [ $ i ] = $ temp [ $ i ] ; }
function rearrange ( & $ arr , $ n ) { $ max_idx = $ n - 1 ; $ min_idx = 0 ; $ max_elem = $ arr [ $ n - 1 ] + 1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ i % 2 == 0 ) { $ arr [ $ i ] += ( $ arr [ $ max_idx ] % $ max_elem ) * $ max_elem ; $ max_idx -- ; } else { $ arr [ $ i ] += ( $ arr [ $ min_idx ] % $ max_elem ) * $ max_elem ; $ min_idx ++ ; } } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ arr [ $ i ] = ( int ) ( $ arr [ $ i ] / $ max_elem ) ; }
function segregateElements ( & $ arr , $ n ) { $ temp = array ( 0 , $ n , NULL ) ; $ j = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] >= 0 ) $ temp [ $ j ++ ] = $ arr [ $ i ] ; if ( $ j == $ n $ j == 0 ) return ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] < 0 ) $ temp [ $ j ++ ] = $ arr [ $ i ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ arr [ $ i ] = $ temp [ $ i ] ; }
function rearrange ( & $ a , $ size ) { $ positive = 0 ; $ negative = 1 ; while ( true ) { while ( $ positive < $ size && $ a [ $ positive ] >= 0 ) $ positive += 2 ; while ( $ negative < $ size && $ a [ $ negative ] <= 0 ) $ negative += 2 ; if ( $ positive < $ size && $ negative < $ size ) { $ temp = $ a [ $ positive ] ; $ a [ $ positive ] = $ a [ $ negative ] ; $ a [ $ negative ] = $ temp ; } else break ; } }
function arrayEvenAndOdd ( $ arr , $ n ) { $ i = -1 ; $ j = 0 ; $ t ; while ( $ j != $ n ) { if ( $ arr [ $ j ] % 2 == 0 ) { $ i ++ ; $ x = $ arr [ $ i ] ; $ arr [ $ i ] = $ arr [ $ j ] ; $ arr [ $ j ] = $ x ; } $ j ++ ; } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ arr [ $ i ] . " ▁ " ; }
function largest ( $ arr , $ n ) { return max ( $ arr ) ; }
function findElements ( $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ count = 0 ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) if ( $ arr [ $ j ] > $ arr [ $ i ] ) $ count ++ ; if ( $ count >= 2 ) echo $ arr [ $ i ] . " ▁ " ; } }
function findElements ( $ arr , $ n ) { sort ( $ arr ) ; for ( $ i = 0 ; $ i < $ n - 2 ; $ i ++ ) echo $ arr [ $ i ] , " ▁ " ; }
function findElements ( $ arr , $ n ) { $ first = PHP_INT_MIN ; $ second = PHP_INT_MIN ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] > $ first ) { $ second = $ first ; $ first = $ arr [ $ i ] ; } else if ( $ arr [ $ i ] > $ second ) $ second = $ arr [ $ i ] ; } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] < $ second ) echo $ arr [ $ i ] , " ▁ " ; }
function findFirstMissing ( $ array , $ start , $ end ) { if ( $ start > $ end ) return $ end + 1 ; if ( $ start != $ array [ $ start ] ) return $ start ; $ mid = ( $ start + $ end ) / 2 ; if ( $ array [ $ mid ] == $ mid ) return findFirstMissing ( $ array , $ mid + 1 , $ end ) ; return findFirstMissing ( $ array , $ start , $ mid ) ; }
function FindMaxSum ( $ arr , $ n ) { $ incl = $ arr [ 0 ] ; $ excl = 0 ; $ excl_new ; $ i ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ excl_new = ( $ incl > $ excl ) ? $ incl : $ excl ; $ incl = $ excl + $ arr [ $ i ] ; $ excl = $ excl_new ; } return ( ( $ incl > $ excl ) ? $ incl : $ excl ) ; }
function countInRange ( $ arr , $ n , $ x , $ y ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] >= $ x && $ arr [ $ i ] <= $ y ) $ count ++ ; } return $ count ; }
function answerQuery ( $ a , $ n , $ l , $ r ) { $ count = 0 ; $ l = $ l - 1 ; for ( $ i = $ l ; $ i < $ r ; $ i ++ ) { $ element = $ a [ $ i ] ; $ divisors = 0 ; for ( $ j = $ l ; $ j < $ r ; $ j ++ ) { if ( $ a [ $ j ] % $ a [ $ i ] == 0 ) $ divisors ++ ; else break ; } if ( $ divisors == ( $ r - $ l ) ) $ count ++ ; } return $ count ; }
function answer_query ( $ a , $ n , $ l , $ r ) { $ count = 0 ; for ( $ i = $ l ; $ i < $ r ; $ i ++ ) if ( $ a [ $ i ] == $ a [ $ i + 1 ] ) $ count += 1 ; return $ count ; }
function maxSubArraySum ( $ a , $ size ) { $ max_so_far = PHP_INT_MIN ; $ max_ending_here = 0 ; for ( $ i = 0 ; $ i < $ size ; $ i ++ ) { $ max_ending_here = $ max_ending_here + $ a [ $ i ] ; if ( $ max_so_far < $ max_ending_here ) $ max_so_far = $ max_ending_here ; if ( $ max_ending_here < 0 ) $ max_ending_here = 0 ; } return $ max_so_far ; }
function maxSubArraySum ( $ a , $ size ) { $ max_so_far = $ a [ 0 ] ; $ curr_max = $ a [ 0 ] ; for ( $ i = 1 ; $ i < $ size ; $ i ++ ) { $ curr_max = max ( $ a [ $ i ] , $ curr_max + $ a [ $ i ] ) ; $ max_so_far = max ( $ max_so_far , $ curr_max ) ; } return $ max_so_far ; }
function findMinAvgSubarray ( $ arr , $ n , $ k ) { if ( $ n < $ k ) return ; $ res_index = 0 ; $ curr_sum = 0 ; for ( $ i = 0 ; $ i < $ k ; $ i ++ ) $ curr_sum += $ arr [ $ i ] ; $ min_sum = $ curr_sum ; for ( $ i = $ k ; $ i < $ n ; $ i ++ ) { $ curr_sum += $ arr [ $ i ] - $ arr [ $ i - $ k ] ; if ( $ curr_sum < $ min_sum ) { $ min_sum = $ curr_sum ; $ res_index = ( $ i - $ k + 1 ) ; } } echo " Subarray between [ " ▁ , $ res _ index ▁ , ▁ " , " ▁ , $ res _ index ▁ + ▁ $ k ▁ - ▁ 1 , ▁ " ] has minimum average " ; }
function minJumps ( $ arr , $ l , $ h ) { if ( $ h == $ l ) return 0 ; if ( $ arr [ $ l ] == 0 ) return INT_MAX ; $ min = 999999 ; for ( $ i = $ l + 1 ; $ i <= $ h && $ i <= $ l + $ arr [ $ l ] ; $ i ++ ) { $ jumps = minJumps ( $ arr , $ i , $ h ) ; if ( $ jumps != 999999 && $ jumps + 1 < $ min ) $ min = $ jumps + 1 ; } return $ min ; }
function smallestSubWithSum ( $ arr , $ n , $ x ) { $ curr_sum = 0 ; $ min_len = $ n + 1 ; $ start = 0 ; $ end = 0 ; while ( $ end < $ n ) { while ( $ curr_sum <= $ x && $ end < $ n ) $ curr_sum += $ arr [ $ end ++ ] ; while ( $ curr_sum > $ x && $ start < $ n ) { if ( $ end - $ start < $ min_len ) $ min_len = $ end - $ start ; $ curr_sum -= $ arr [ $ start ++ ] ; } } return $ min_len ; }
function findMaxAverage ( $ arr , $ n , $ k ) { if ( $ k > $ n ) return -1 ; $ csum = array ( ) ; $ csum [ 0 ] = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ csum [ $ i ] = $ csum [ $ i - 1 ] + $ arr [ $ i ] ; $ max_sum = $ csum [ $ k - 1 ] ; $ max_end = $ k - 1 ; for ( $ i = $ k ; $ i < $ n ; $ i ++ ) { $ curr_sum = $ csum [ $ i ] - $ csum [ $ i - $ k ] ; if ( $ curr_sum > $ max_sum ) { $ max_sum = $ curr_sum ; $ max_end = $ i ; } } return $ max_end - $ k + 1 ; }
function findMaxAverage ( $ arr , $ n , $ k ) { if ( $ k > $ n ) return -1 ; $ sum = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ k ; $ i ++ ) $ sum += $ arr [ $ i ] ; $ max_sum = $ sum ; $ max_end = $ k - 1 ; for ( $ i = $ k ; $ i < $ n ; $ i ++ ) { $ sum = $ sum + $ arr [ $ i ] - $ arr [ $ i - $ k ] ; if ( $ sum > $ max_sum ) { $ max_sum = $ sum ; $ max_end = $ i ; } } return $ max_end - $ k + 1 ; }
function findSmallest ( $ arr , $ n ) { $ res = 1 ; for ( $ i = 0 ; $ i < $ n and $ arr [ $ i ] <= $ res ; $ i ++ ) $ res = $ res + $ arr [ $ i ] ; return $ res ; }
function findMinDiff ( $ arr , $ n ) { $ diff = PHP_INT_MAX ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) if ( abs ( $ arr [ $ i ] - $ arr [ $ j ] ) < $ diff ) $ diff = abs ( $ arr [ $ i ] - $ arr [ $ j ] ) ; return $ diff ; }
function findMinDiff ( $ arr , $ n ) { sort ( $ arr ) ; $ diff = PHP_INT_MAX ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) if ( $ arr [ $ i + 1 ] - $ arr [ $ i ] < $ diff ) $ diff = $ arr [ $ i + 1 ] - $ arr [ $ i ] ; return $ diff ; }
function longestCommonSum ( $ arr1 , $ arr2 , $ n ) { $ maxLen = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sum1 = 0 ; $ sum2 = 0 ; for ( $ j = $ i ; $ j < $ n ; $ j ++ ) { $ sum1 += $ arr1 [ $ j ] ; $ sum2 += $ arr2 [ $ j ] ; if ( $ sum1 == $ sum2 ) { $ len = $ j - $ i + 1 ; if ( $ len > $ maxLen ) $ maxLen = $ len ; } } } return $ maxLen ; }
function segregate0and1 ( $ arr , $ n ) { $ type0 = 0 ; $ type1 = $ n - 1 ; while ( $ type0 < $ type1 ) { if ( $ arr [ $ type0 ] == 1 ) { $ temp = $ arr [ $ type0 ] ; $ arr [ $ type0 ] = $ arr [ $ type1 ] ; $ arr [ $ type1 ] = $ temp ; $ type1 -- ; } else { $ type0 ++ ; } } return $ arr ; }
function getInvCount ( & $ arr , $ n ) { $ inv_count = 0 ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) if ( $ arr [ $ i ] > $ arr [ $ j ] ) $ inv_count ++ ; return $ inv_count ; }
function countPairsWithDiffK ( $ arr , $ n , $ k ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) if ( $ arr [ $ i ] - $ arr [ $ j ] == $ k or $ arr [ $ j ] - $ arr [ $ i ] == $ k ) $ count ++ ; } return $ count ; }
function countPairsWithDiffK ( $ arr , $ n , $ k ) { $ count = 0 ; sort ( $ arr ) ; $ l = 0 ; $ r = 0 ; while ( $ r < $ n ) { if ( $ arr [ $ r ] - $ arr [ $ l ] == $ k ) { $ count ++ ; $ l ++ ; $ r ++ ; } else if ( $ arr [ $ r ] - $ arr [ $ l ] > $ k ) $ l ++ ; else $ r ++ ; } return $ count ; }
function constructArr ( $ pair ) { $ arr = array ( ) ; $ n = 5 ; $ arr [ 0 ] = intval ( ( $ pair [ 0 ] + $ pair [ 1 ] - $ pair [ $ n - 1 ] ) / 2 ) ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ arr [ $ i ] = $ pair [ $ i - 1 ] - $ arr [ 0 ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ arr [ $ i ] . " ▁ " ; }
function merge ( & $ ar1 , & $ ar2 , $ m , $ n ) { for ( $ i = $ n - 1 ; $ i >= 0 ; $ i -- ) { $ last = $ ar1 [ $ m - 1 ] ; for ( $ j = $ m - 2 ; $ j >= 0 && $ ar1 [ $ j ] > $ ar2 [ $ i ] ; $ j -- ) $ ar1 [ $ j + 1 ] = $ ar1 [ $ j ] ; if ( $ j != $ m - 2 $ last > $ ar2 [ $ i ] ) { $ ar1 [ $ j + 1 ] = $ ar2 [ $ i ] ; $ ar2 [ $ i ] = $ last ; } } }
function minMaxProduct ( $ arr1 , $ arr2 , $ n1 , $ n2 ) { sort ( $ arr1 ) ; sort ( $ arr2 ) ; return $ arr1 [ $ n1 - 1 ] * $ arr2 [ 0 ] ; }
function findElement ( $ arr , $ n , $ key ) { $ i ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] == $ key ) return $ i ; return -1 ; }
function findCommon ( $ ar1 , $ ar2 , $ ar3 , $ n1 , $ n2 , $ n3 ) { $ i = 0 ; $ j = 0 ; $ k = 0 ; while ( $ i < $ n1 && $ j < $ n2 && $ k < $ n3 ) { if ( $ ar1 [ $ i ] == $ ar2 [ $ j ] && $ ar2 [ $ j ] == $ ar3 [ $ k ] ) { echo $ ar1 [ $ i ] , " " ; $ i ++ ; $ j ++ ; $ k ++ ; } else if ( $ ar1 [ $ i ] < $ ar2 [ $ j ] ) $ i ++ ; else if ( $ ar2 [ $ j ] < $ ar3 [ $ k ] ) $ j ++ ; else $ k ++ ; } }
function findSingle ( $ ar , $ ar_size ) { $ res = $ ar [ 0 ] ; for ( $ i = 1 ; $ i < $ ar_size ; $ i ++ ) $ res = $ res ^ $ ar [ $ i ] ; return $ res ; }
function findMaxSum ( $ arr , $ n ) { $ res = PHP_INT_MIN ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ prefix_sum = $ arr [ $ i ] ; for ( $ j = 0 ; $ j < $ i ; $ j ++ ) $ prefix_sum += $ arr [ $ j ] ; $ suffix_sum = $ arr [ $ i ] ; for ( $ j = $ n - 1 ; $ j > $ i ; $ j -- ) $ suffix_sum += $ arr [ $ j ] ; if ( $ prefix_sum == $ suffix_sum ) $ res = max ( $ res , $ prefix_sum ) ; } return $ res ; }
function findMaxSum ( $ arr , $ n ) { $ preSum [ $ n ] = array ( ) ; $ suffSum [ $ n ] = array ( ) ; $ ans = PHP_INT_MIN ; $ preSum [ 0 ] = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ preSum [ $ i ] = $ preSum [ $ i - 1 ] + $ arr [ $ i ] ; $ suffSum [ $ n - 1 ] = $ arr [ $ n - 1 ] ; if ( $ preSum [ $ n - 1 ] == $ suffSum [ $ n - 1 ] ) $ ans = max ( $ ans , $ preSum [ $ n - 1 ] ) ; for ( $ i = $ n - 2 ; $ i >= 0 ; $ i -- ) { $ suffSum [ $ i ] = $ suffSum [ $ i + 1 ] + $ arr [ $ i ] ; if ( $ suffSum [ $ i ] == $ preSum [ $ i ] ) $ ans = max ( $ ans , $ preSum [ $ i ] ) ; } return $ ans ; }
function equilibrium ( $ arr , $ n ) { $ i ; $ j ; $ leftsum ; $ rightsum ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { $ leftsum = 0 ; $ rightsum = 0 ; for ( $ j = 0 ; $ j < $ i ; $ j ++ ) $ leftsum += $ arr [ $ j ] ; for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) $ rightsum += $ arr [ $ j ] ; if ( $ leftsum == $ rightsum ) return $ i ; } return -1 ; }
function equilibrium ( $ arr , $ n ) { $ sum = 0 ; $ leftsum = 0 ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) $ sum += $ arr [ $ i ] ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { $ sum -= $ arr [ $ i ] ; if ( $ leftsum == $ sum ) return $ i ; $ leftsum += $ arr [ $ i ] ; } return -1 ; }
function printLeaders ( $ arr , $ size ) { for ( $ i = 0 ; $ i < $ size ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ size ; $ j ++ ) { if ( $ arr [ $ i ] <= $ arr [ $ j ] ) break ; } if ( $ j == $ size ) echo ( $ arr [ $ i ] . " ▁ " ) ; } }
function ceilSearch ( $ arr , $ low , $ high , $ x ) { if ( $ x <= $ arr [ $ low ] ) return $ low ; for ( $ i = $ low ; $ i < $ high ; $ i ++ ) { if ( $ arr [ $ i ] == $ x ) return $ i ; if ( $ arr [ $ i ] < $ x && $ arr [ $ i + 1 ] >= $ x ) return $ i + 1 ; } return -1 ; }
function ceilSearch ( $ arr , $ low , $ high , $ x ) { $ mid ; if ( $ x <= $ arr [ $ low ] ) return $ low ; if ( $ x > $ arr [ $ high ] ) return -1 ; $ mid = ( $ low + $ high ) / 2 ; if ( $ arr [ $ mid ] == $ x ) return $ mid ; else if ( $ arr [ $ mid ] < $ x ) { if ( $ mid + 1 <= $ high && $ x <= $ arr [ $ mid + 1 ] ) return $ mid + 1 ; else return ceilSearch ( $ arr , $ mid + 1 , $ high , $ x ) ; } else { if ( $ mid - 1 >= $ low && $ x > $ arr [ $ mid - 1 ] ) return $ mid ; else return ceilSearch ( $ arr , $ low , $ mid - 1 , $ x ) ; } }
function isMajority ( $ arr , $ n , $ x ) { $ i ; $ last_index = $ n % 2 ? ( $ n / 2 + 1 ) : ( $ n / 2 ) ; for ( $ i = 0 ; $ i < $ last_index ; $ i ++ ) { if ( $ arr [ $ i ] == $ x && $ arr [ $ i + $ n / 2 ] == $ x ) return 1 ; } return 0 ; }
function printRepeating ( $ arr , $ size ) { $ i ; $ j ; echo " ▁ Repeating ▁ elements ▁ are ▁ " ; for ( $ i = 0 ; $ i < $ size ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ size ; $ j ++ ) if ( $ arr [ $ i ] == $ arr [ $ j ] ) echo $ arr [ $ i ] , " ▁ " ; }
function printRepeating ( $ arr , $ size ) { $ count = array_fill ( 0 , $ size , 0 ) ; echo " Repeated ▁ elements ▁ are ▁ " ; for ( $ i = 0 ; $ i < $ size ; $ i ++ ) { if ( $ count [ $ arr [ $ i ] ] == 1 ) echo $ arr [ $ i ] . " ▁ " ; else $ count [ $ arr [ $ i ] ] ++ ; } }
function printRepeating ( $ arr , $ size ) { $ i ; echo " The ▁ repeating ▁ elements ▁ are " , " ▁ " ; for ( $ i = 0 ; $ i < $ size ; $ i ++ ) { if ( $ arr [ abs ( $ arr [ $ i ] ) ] > 0 ) $ arr [ abs ( $ arr [ $ i ] ) ] = - $ arr [ abs ( $ arr [ $ i ] ) ] ; else echo abs ( $ arr [ $ i ] ) , " ▁ " ; } }
function linearSearch ( $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] == $ i ) return $ i ; } return -1 ; }
function binarySearch ( $ arr , $ low , $ high ) { if ( $ high >= $ low ) { $ mid = ( int ) ( ( $ low + $ high ) / 2 ) ; if ( $ mid == $ arr [ $ mid ] ) return $ mid ; if ( $ mid > $ arr [ $ mid ] ) return binarySearch ( $ arr , ( $ mid + 1 ) , $ high ) ; else return binarySearch ( $ arr , $ low , ( $ mid - 1 ) ) ; } return -1 ; }
function subArraySum ( $ arr , $ n , $ sum ) { $ curr_sum ; $ i ; $ j ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ curr_sum = $ arr [ $ i ] ; for ( $ j = $ i + 1 ; $ j <= $ n ; $ j ++ ) { if ( $ curr_sum == $ sum ) { echo " Sum ▁ found ▁ between ▁ indexes ▁ " , $ i , " ▁ and ▁ " , $ j - 1 ; return 1 ; } if ( $ curr_sum > $ sum $ j == $ n ) break ; $ curr_sum = $ curr_sum + $ arr [ $ j ] ; } } echo " No ▁ subarray ▁ found " ; return 0 ; }
function maxTripletSum ( $ arr , $ n ) { $ sum = PHP_INT_MIN ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) for ( $ k = $ j + 1 ; $ k < $ n ; $ k ++ ) if ( $ sum < $ arr [ $ i ] + $ arr [ $ j ] + $ arr [ $ k ] ) $ sum = $ arr [ $ i ] + $ arr [ $ j ] + $ arr [ $ k ] ; return $ sum ; }
function maxTripletSum ( $ arr , $ n ) { sort ( $ arr ) ; return $ arr [ $ n - 1 ] + $ arr [ $ n - 2 ] + $ arr [ $ n - 3 ] ; }
function find3Numbers ( $ A , $ arr_size , $ sum ) { $ l ; $ r ; for ( $ i = 0 ; $ i < $ arr_size - 2 ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ arr_size - 1 ; $ j ++ ) { for ( $ k = $ j + 1 ; $ k < $ arr_size ; $ k ++ ) { if ( $ A [ $ i ] + $ A [ $ j ] + $ A [ $ k ] == $ sum ) { echo " Triplet ▁ is " , " ▁ " , $ A [ $ i ] , " , ▁ " , $ A [ $ j ] , " , ▁ " , $ A [ $ k ] ; return true ; } } } } return false ; }
function subArray ( $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = $ i ; $ j < $ n ; $ j ++ ) { for ( $ k = $ i ; $ k <= $ j ; $ k ++ ) echo $ arr [ $ k ] , " ▁ " ; echo " STRNEWLINE " ; } } }
function printSubsequences ( $ arr , $ n ) { $ opsize = pow ( 2 , $ n ) ; for ( $ counter = 1 ; $ counter < $ opsize ; $ counter ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ counter & ( 1 << $ j ) ) echo $ arr [ $ j ] , " ▁ " ; } echo " STRNEWLINE " ; } }
function minOps ( $ arr , $ n , $ k ) { $ max = max ( $ arr ) ; $ res = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( ( $ max - $ arr [ $ i ] ) % $ k != 0 ) return -1 ; else $ res += ( $ max - $ arr [ $ i ] ) / $ k ; } return $ res ; }
function solve ( $ A , $ B , $ C , $ i , $ j , $ k ) { $ min_diff ; $ current_diff ; $ max_term ; $ min_diff = abs ( max ( $ A [ $ i ] , max ( $ B [ $ j ] , $ C [ $ k ] ) ) - min ( $ A [ $ i ] , min ( $ B [ $ j ] , $ C [ $ k ] ) ) ) ; while ( $ i != -1 && $ j != -1 && $ k != -1 ) { $ current_diff = abs ( max ( $ A [ $ i ] , max ( $ B [ $ j ] , $ C [ $ k ] ) ) - min ( $ A [ $ i ] , min ( $ B [ $ j ] , $ C [ $ k ] ) ) ) ; if ( $ current_diff < $ min_diff ) $ min_diff = $ current_diff ; $ max_term = max ( $ A [ $ i ] , max ( $ B [ $ j ] , $ C [ $ k ] ) ) ; if ( $ A [ $ i ] == $ max_term ) $ i -= 1 ; else if ( $ B [ $ j ] == $ max_term ) $ j -= 1 ; else $ k -= 1 ; } return $ min_diff ; }
function search ( $ arr , $ x ) { $ n = sizeof ( $ arr ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] == $ x ) return $ i ; } return -1 ; }
function binarySearch ( $ arr , $ l , $ r , $ x ) { if ( $ r >= $ l ) { $ mid = ceil ( $ l + ( $ r - $ l ) / 2 ) ; if ( $ arr [ $ mid ] == $ x ) return floor ( $ mid ) ; if ( $ arr [ $ mid ] > $ x ) return binarySearch ( $ arr , $ l , $ mid - 1 , $ x ) ; return binarySearch ( $ arr , $ mid + 1 , $ r , $ x ) ; } return -1 ; }
function countSort ( $ arr ) { global $ RANGE ; $ output = array ( strlen ( $ arr ) ) ; $ len = strlen ( $ arr ) ; $ count = array_fill ( 0 , $ RANGE + 1 , 0 ) ; for ( $ i = 0 ; $ i < $ len ; ++ $ i ) ++ $ count [ ord ( $ arr [ $ i ] ) ] ; for ( $ i = 1 ; $ i <= $ RANGE ; ++ $ i ) $ count [ $ i ] += $ count [ $ i - 1 ] ; for ( $ i = $ len - 1 ; $ i >= 0 ; $ i -- ) { $ output [ $ count [ ord ( $ arr [ $ i ] ) ] - 1 ] = $ arr [ $ i ] ; -- $ count [ ord ( $ arr [ $ i ] ) ] ; } for ( $ i = 0 ; $ i < $ len ; ++ $ i ) $ arr [ $ i ] = $ output [ $ i ] ; return $ arr ; }
function printClosest ( $ ar1 , $ ar2 , $ m , $ n , $ x ) { $ diff = PHP_INT_MAX ; $ res_l ; $ res_r ; $ l = 0 ; $ r = $ n - 1 ; while ( $ l < $ m and $ r >= 0 ) { if ( abs ( $ ar1 [ $ l ] + $ ar2 [ $ r ] - $ x ) < $ diff ) { $ res_l = $ l ; $ res_r = $ r ; $ diff = abs ( $ ar1 [ $ l ] + $ ar2 [ $ r ] - $ x ) ; } if ( $ ar1 [ $ l ] + $ ar2 [ $ r ] > $ x ) $ r -- ; else $ l ++ ; } echo " The ▁ closest ▁ pair ▁ is ▁ [ " , $ ar1 [ $ res_l ] , " , ▁ " , $ ar2 [ $ res_r ] , " ] ▁ STRNEWLINE " ; }
function printClosest ( $ arr , $ n , $ x ) { $ res_l ; $ res_r ; $ l = 0 ; $ r = $ n - 1 ; $ diff = PHP_INT_MAX ; while ( $ r > $ l ) { if ( abs ( $ arr [ $ l ] + $ arr [ $ r ] - $ x ) < $ diff ) { $ res_l = $ l ; $ res_r = $ r ; $ diff = abs ( $ arr [ $ l ] + $ arr [ $ r ] - $ x ) ; } if ( $ arr [ $ l ] + $ arr [ $ r ] > $ x ) $ r -- ; else $ l ++ ; } echo " ▁ The ▁ closest ▁ pair ▁ is ▁ " , $ arr [ $ res_l ] , " ▁ and ▁ " , $ arr [ $ res_r ] ; }
function countOnes ( $ arr , $ low , $ high ) { if ( $ high >= $ low ) { $ mid = $ low + ( $ high - $ low ) / 2 ; if ( ( $ mid == $ high or $ arr [ $ mid + 1 ] == 0 ) and ( $ arr [ $ mid ] == 1 ) ) return $ mid + 1 ; if ( $ arr [ $ mid ] == 1 ) return countOnes ( $ arr , ( $ mid + 1 ) , $ high ) ; return countOnes ( $ arr , $ low , ( $ mid - 1 ) ) ; } return 0 ; }
function printMaxActivities ( $ s , $ f , $ n ) { echo " Following ▁ activities ▁ are ▁ selected ▁ " . " STRNEWLINE " ; $ i = 0 ; echo $ i . " " ; for ( $ j = 1 ; $ j < $ n ; $ j ++ ) { if ( $ s [ $ j ] >= $ f [ $ i ] ) { echo $ j . " " ; $ i = $ j ; } } }
function count_1 ( & $ S , $ m , $ n ) { $ table = array_fill ( 0 , $ n + 1 , NULl ) ; $ table [ 0 ] = 1 ; for ( $ i = 0 ; $ i < $ m ; $ i ++ ) for ( $ j = $ S [ $ i ] ; $ j <= $ n ; $ j ++ ) $ table [ $ j ] += $ table [ $ j - $ S [ $ i ] ] ; return $ table [ $ n ] ; }
function MatrixChainOrder ( $ p , $ n ) { $ m [ ] [ ] = array ( $ n , $ n ) ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ m [ $ i ] [ $ i ] = 0 ; for ( $ L = 2 ; $ L < $ n ; $ L ++ ) { for ( $ i = 1 ; $ i < $ n - $ L + 1 ; $ i ++ ) { $ j = $ i + $ L - 1 ; if ( $ j == $ n ) continue ; $ m [ $ i ] [ $ j ] = PHP_INT_MAX ; for ( $ k = $ i ; $ k <= $ j - 1 ; $ k ++ ) { $ q = $ m [ $ i ] [ $ k ] + $ m [ $ k + 1 ] [ $ j ] + $ p [ $ i - 1 ] * $ p [ $ k ] * $ p [ $ j ] ; if ( $ q < $ m [ $ i ] [ $ j ] ) $ m [ $ i ] [ $ j ] = $ q ; } } } return $ m [ 1 ] [ $ n - 1 ] ; }
function binomialCoeff ( $ n , $ k ) { if ( $ k > $ n ) return 0 ; if ( $ k == 0 $ k == $ n ) return 1 ; return binomialCoeff ( $ n - 1 , $ k - 1 ) + binomialCoeff ( $ n - 1 , $ k ) ; }
function binomialCoeff ( $ n , $ k ) { $ C = array_fill ( 0 , $ k + 1 , 0 ) ; $ C [ 0 ] = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { for ( $ j = min ( $ i , $ k ) ; $ j > 0 ; $ j -- ) $ C [ $ j ] = $ C [ $ j ] + $ C [ $ j - 1 ] ; } return $ C [ $ k ] ; }
function lbs ( & $ arr , $ n ) { $ lis = array_fill ( 0 , $ n , NULL ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ lis [ $ i ] = 1 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ i ; $ j ++ ) if ( $ arr [ $ i ] > $ arr [ $ j ] && $ lis [ $ i ] < $ lis [ $ j ] + 1 ) $ lis [ $ i ] = $ lis [ $ j ] + 1 ; $ lds = array_fill ( 0 , $ n , NULL ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ lds [ $ i ] = 1 ; for ( $ i = $ n - 2 ; $ i >= 0 ; $ i -- ) for ( $ j = $ n - 1 ; $ j > $ i ; $ j -- ) if ( $ arr [ $ i ] > $ arr [ $ j ] && $ lds [ $ i ] < $ lds [ $ j ] + 1 ) $ lds [ $ i ] = $ lds [ $ j ] + 1 ; $ max = $ lis [ 0 ] + $ lds [ 0 ] - 1 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) if ( $ lis [ $ i ] + $ lds [ $ i ] - 1 > $ max ) $ max = $ lis [ $ i ] + $ lds [ $ i ] - 1 ; return $ max ; }
function isSubsetSum ( $ set , $ n , $ sum ) { if ( $ sum == 0 ) return true ; if ( $ n == 0 ) return false ; if ( $ set [ $ n - 1 ] > $ sum ) return isSubsetSum ( $ set , $ n - 1 , $ sum ) ; return isSubsetSum ( $ set , $ n - 1 , $ sum ) || isSubsetSum ( $ set , $ n - 1 , $ sum - $ set [ $ n - 1 ] ) ; }
function countNonDecreasing ( $ n ) { $ dp = array_fill ( 0 , 10 , array_fill ( 0 , $ n + 1 , NULL ) ) ; for ( $ i = 0 ; $ i < 10 ; $ i ++ ) $ dp [ $ i ] [ 1 ] = 1 ; for ( $ digit = 0 ; $ digit <= 9 ; $ digit ++ ) { for ( $ len = 2 ; $ len <= $ n ; $ len ++ ) { for ( $ x = 0 ; $ x <= $ digit ; $ x ++ ) $ dp [ $ digit ] [ $ len ] += $ dp [ $ x ] [ $ len - 1 ] ; } } $ count = 0 ; for ( $ i = 0 ; $ i < 10 ; $ i ++ ) $ count += $ dp [ $ i ] [ $ n ] ; return $ count ; }
function countNonDecreasing ( $ n ) { $ N = 10 ; $ count = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ count *= ( $ N + $ i - 1 ) ; $ count /= $ i ; } return $ count ; }
function getMinSquares ( $ n ) { if ( $ n <= 3 ) return $ n ; $ res = $ n ; for ( $ x = 1 ; $ x <= $ n ; $ x ++ ) { $ temp = $ x * $ x ; if ( $ temp > $ n ) break ; else $ res = min ( $ res , 1 + getMinSquares ( $ n - $ temp ) ) ; } return $ res ; }
function getMinSquares ( $ n ) { $ dp ; $ dp [ 0 ] = 0 ; $ dp [ 1 ] = 1 ; $ dp [ 2 ] = 2 ; $ dp [ 3 ] = 3 ; for ( $ i = 4 ; $ i <= $ n ; $ i ++ ) { $ dp [ $ i ] = $ i ; for ( $ x = 1 ; $ x <= ceil ( sqrt ( $ i ) ) ; $ x ++ ) { $ temp = $ x * $ x ; if ( $ temp > $ i ) break ; else $ dp [ $ i ] = min ( $ dp [ $ i ] , ( 1 + $ dp [ $ i - $ temp ] ) ) ; } } $ res = $ dp [ $ n ] ; return $ res ; }
function minCoins ( $ coins , $ m , $ V ) { if ( $ V == 0 ) return 0 ; $ res = PHP_INT_MAX ; for ( $ i = 0 ; $ i < $ m ; $ i ++ ) { if ( $ coins [ $ i ] <= $ V ) { $ sub_res = minCoins ( $ coins , $ m , $ V - $ coins [ $ i ] ) ; if ( $ sub_res != PHP_INT_MAX && $ sub_res + 1 < $ res ) $ res = $ sub_res + 1 ; } } return $ res ; }
function minCoins ( $ coins , $ m , $ V ) { $ table [ $ V + 1 ] = array ( ) ; $ table [ 0 ] = 0 ; for ( $ i = 1 ; $ i <= $ V ; $ i ++ ) $ table [ $ i ] = PHP_INT_MAX ; for ( $ i = 1 ; $ i <= $ V ; $ i ++ ) { for ( $ j = 0 ; $ j < $ m ; $ j ++ ) if ( $ coins [ $ j ] <= $ i ) { $ sub_res = $ table [ $ i - $ coins [ $ j ] ] ; if ( $ sub_res != PHP_INT_MAX && $ sub_res + 1 < $ table [ $ i ] ) $ table [ $ i ] = $ sub_res + 1 ; } } if ( $ table [ $ V ] == PHP_INT_MAX ) return -1 ; return $ table [ $ V ] ; }
function superSeq ( $ X , $ Y , $ m , $ n ) { if ( ! $ m ) return $ n ; if ( ! $ n ) return $ m ; if ( $ X [ $ m - 1 ] == $ Y [ $ n - 1 ] ) return 1 + superSeq ( $ X , $ Y , $ m - 1 , $ n - 1 ) ; return 1 + min ( superSeq ( $ X , $ Y , $ m - 1 , $ n ) , superSeq ( $ X , $ Y , $ m , $ n - 1 ) ) ; }
function superSeq ( $ X , $ Y , $ m , $ n ) { $ dp = array_fill ( 0 , $ m + 1 , array_fill ( 0 , $ n + 1 , 0 ) ) ; for ( $ i = 0 ; $ i <= $ m ; $ i ++ ) { for ( $ j = 0 ; $ j <= $ n ; $ j ++ ) { if ( ! $ i ) $ dp [ $ i ] [ $ j ] = $ j ; else if ( ! $ j ) $ dp [ $ i ] [ $ j ] = $ i ; else if ( $ X [ $ i - 1 ] == $ Y [ $ j - 1 ] ) $ dp [ $ i ] [ $ j ] = 1 + $ dp [ $ i - 1 ] [ $ j - 1 ] ; else $ dp [ $ i ] [ $ j ] = 1 + min ( $ dp [ $ i - 1 ] [ $ j ] , $ dp [ $ i ] [ $ j - 1 ] ) ; } } return $ dp [ $ m ] [ $ n ] ; }
function sumOfDigitsFrom1ToN ( $ n ) { if ( $ n < 10 ) return ( $ n * ( $ n + 1 ) / 2 ) ; $ d = ( int ) ( log10 ( $ n ) ) ; $ a [ $ d + 1 ] = array ( ) ; $ a [ 0 ] = 0 ; $ a [ 1 ] = 45 ; for ( $ i = 2 ; $ i <= $ d ; $ i ++ ) $ a [ $ i ] = $ a [ $ i - 1 ] * 10 + 45 * ( int ) ( ceil ( pow ( 10 , $ i - 1 ) ) ) ; $ p = ( int ) ( ceil ( pow ( 10 , $ d ) ) ) ; $ msd = ( int ) ( $ n / $ p ) ; return ( $ msd * $ a [ $ d ] + ( $ msd * ( int ) ( $ msd - 1 ) / 2 ) * $ p + $ msd * ( 1 + $ n % $ p ) + sumOfDigitsFrom1ToN ( $ n % $ p ) ) ; }
function countWays ( $ N ) { if ( $ N == 1 ) return 4 ; $ countB = 1 ; $ countS = 1 ; $ prev_countB ; $ prev_countS ; for ( $ i = 2 ; $ i <= $ N ; $ i ++ ) { $ prev_countB = $ countB ; $ prev_countS = $ countS ; $ countS = $ prev_countB + $ prev_countS ; $ countB = $ prev_countS ; } $ result = $ countS + $ countB ; return ( $ result * $ result ) ; }
function findoptimal ( $ N ) { if ( $ N <= 6 ) return $ N ; $ max = 0 ; $ b ; for ( $ b = $ N - 3 ; $ b >= 1 ; $ b -= 1 ) { $ curr = ( $ N - $ b - 1 ) * findoptimal ( $ b ) ; if ( $ curr > $ max ) $ max = $ curr ; } return $ max ; }
function counts ( $ n ) { for ( $ j = 0 ; $ j < $ n + 1 ; $ j ++ ) $ table [ $ j ] = 0 ; $ table [ 0 ] = 1 ; for ( $ i = 3 ; $ i <= $ n ; $ i ++ ) $ table [ $ i ] += $ table [ $ i - 3 ] ; for ( $ i = 5 ; $ i <= $ n ; $ i ++ ) $ table [ $ i ] += $ table [ $ i - 5 ] ; for ( $ i = 10 ; $ i <= $ n ; $ i ++ ) $ table [ $ i ] += $ table [ $ i - 10 ] ; return $ table [ $ n ] ; }
function search ( $ pat , $ txt ) { $ M = strlen ( $ pat ) ; $ N = strlen ( $ txt ) ; for ( $ i = 0 ; $ i <= $ N - $ M ; $ i ++ ) { for ( $ j = 0 ; $ j < $ M ; $ j ++ ) if ( $ txt [ $ i + $ j ] != $ pat [ $ j ] ) break ; if ( $ j == $ M ) echo " Pattern ▁ found ▁ at ▁ index ▁ " , $ i . " STRNEWLINE " ; } }
function search ( $ pat , $ txt ) { $ M = strlen ( $ pat ) ; $ N = strlen ( $ txt ) ; $ i = 0 ; while ( $ i <= $ N - $ M ) { $ j ; for ( $ j = 0 ; $ j < $ M ; $ j ++ ) if ( $ txt [ $ i + $ j ] != $ pat [ $ j ] ) break ; if ( $ j == $ M ) { echo ( " Pattern ▁ found ▁ at ▁ index ▁ $ i " . " STRNEWLINE " ) ; $ i = $ i + $ M ; } else if ( $ j == 0 ) $ i = $ i + 1 ; else $ i = $ i + $ j ; } }
function power ( $ x , $ y ) { $ temp ; if ( $ y == 0 ) return 1 ; $ temp = power ( $ x , $ y / 2 ) ; if ( $ y % 2 == 0 ) return $ temp * $ temp ; else { if ( $ y > 0 ) return $ x * $ temp * $ temp ; else return ( $ temp * $ temp ) / $ x ; } }
function isLucky ( $ n ) { $ counter = 2 ; $ next_position = $ n ; if ( $ counter > $ n ) return 1 ; if ( $ n % $ counter == 0 ) return 0 ; $ next_position -= $ next_position / $ counter ; $ counter ++ ; return isLucky ( $ next_position ) ; }
function poww ( $ a , $ b ) { if ( $ b == 0 ) return 1 ; $ answer = $ a ; $ increment = $ a ; $ i ; $ j ; for ( $ i = 1 ; $ i < $ b ; $ i ++ ) { for ( $ j = 1 ; $ j < $ a ; $ j ++ ) { $ answer += $ increment ; } $ increment = $ answer ; } return $ answer ; }
function count1 ( $ n ) { if ( $ n < 3 ) return $ n ; if ( $ n >= 3 && $ n < 10 ) return $ n - 1 ; $ po = 1 ; for ( $ x = intval ( $ n / $ po ) ; $ x > 9 ; $ x = intval ( $ n / $ po ) ) $ po = $ po * 10 ; $ msd = intval ( $ n / $ po ) ; if ( $ msd != 3 ) return count1 ( $ msd ) * count1 ( $ po - 1 ) + count1 ( $ msd ) + count1 ( $ n % $ po ) ; else return count1 ( $ msd * $ po - 1 ) ; }
function binomialCoeff ( $ n , $ k ) { $ res = 1 ; if ( $ k > $ n - $ k ) $ k = $ n - $ k ; for ( $ i = 0 ; $ i < $ k ; ++ $ i ) { $ res *= ( $ n - $ i ) ; $ res /= ( $ i + 1 ) ; } return $ res ; }
function printPascal ( $ n ) { $ arr = array ( array ( ) ) ; for ( $ line = 0 ; $ line < $ n ; $ line ++ ) { for ( $ i = 0 ; $ i <= $ line ; $ i ++ ) { if ( $ line == $ i $ i == 0 ) $ arr [ $ line ] [ $ i ] = 1 ; else $ arr [ $ line ] [ $ i ] = $ arr [ $ line - 1 ] [ $ i - 1 ] + $ arr [ $ line - 1 ] [ $ i ] ; echo $ arr [ $ line ] [ $ i ] . " " ; } echo " STRNEWLINE " ; } }
function printPascal ( $ n ) { for ( $ line = 1 ; $ line <= $ n ; $ line ++ ) { $ C = 1 ; for ( $ i = 1 ; $ i <= $ line ; $ i ++ ) { print ( $ C . " " ) ; $ C = $ C * ( $ line - $ i ) / $ i ; } print ( " STRNEWLINE " ) ; } }
function exponential ( $ n , $ x ) { $ sum = 1.0 ; for ( $ i = $ n - 1 ; $ i > 0 ; -- $ i ) $ sum = 1 + $ x * $ sum / $ i ; return $ sum ; }
function findgroups ( $ arr , $ n ) { $ c = array ( 0 , 0 , 0 ) ; $ res = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ c [ $ arr [ $ i ] % 3 ] += 1 ; $ res += ( ( $ c [ 0 ] * ( $ c [ 0 ] - 1 ) ) >> 1 ) ; $ res += $ c [ 1 ] * $ c [ 2 ] ; $ res += ( $ c [ 0 ] * ( $ c [ 0 ] - 1 ) * ( $ c [ 0 ] - 2 ) ) / 6 ; $ res += ( $ c [ 1 ] * ( $ c [ 1 ] - 1 ) * ( $ c [ 1 ] - 2 ) ) / 6 ; $ res += ( ( $ c [ 2 ] * ( $ c [ 2 ] - 1 ) * ( $ c [ 2 ] - 2 ) ) / 6 ) ; $ res += $ c [ 0 ] * $ c [ 1 ] * $ c [ 2 ] ; return $ res ; }
function findTrailingZeros ( $ n ) { $ count = 0 ; for ( $ i = 5 ; $ n / $ i >= 1 ; $ i *= 5 ) $ count += $ n / $ i ; return $ count ; }
function catalanDP ( $ n ) { $ catalan = array ( ) ; $ catalan [ 0 ] = $ catalan [ 1 ] = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { $ catalan [ $ i ] = 0 ; for ( $ j = 0 ; $ j < $ i ; $ j ++ ) $ catalan [ $ i ] += $ catalan [ $ j ] * $ catalan [ $ i - $ j - 1 ] ; } return $ catalan [ $ n ] ; }
function find ( $ p ) { return ceil ( sqrt ( 2 * 365 * log ( 1 / ( 1 - $ p ) ) ) ) ; }
function countSolutions ( $ n ) { $ res = 0 ; for ( $ x = 0 ; $ x * $ x < $ n ; $ x ++ ) for ( $ y = 0 ; $ x * $ x + $ y * $ y < $ n ; $ y ++ ) $ res ++ ; return $ res ; } { echo " Total ▁ Number ▁ of ▁ distinct ▁ Non - Negative ▁ pairs ▁ is ▁ " ; echo countSolutions ( 6 ) ; return 0 ; }
function countSolutions ( $ n ) { $ x = 0 ; $ yCount ; $ res = 0 ; for ( $ yCount = 0 ; $ yCount * $ yCount < $ n ; $ yCount ++ ) ; while ( $ yCount != 0 ) { $ res += $ yCount ; $ x ++ ; while ( $ yCount != 0 and ( $ x * $ x + ( $ yCount - 1 ) * ( $ yCount - 1 ) >= $ n ) ) $ yCount -- ; } return $ res ; }
function getSingle ( $ arr , $ n ) { $ ones = 0 ; $ twos = 0 ; $ common_bit_mask ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ twos = $ twos | ( $ ones & $ arr [ $ i ] ) ; $ ones = $ ones ^ $ arr [ $ i ] ; $ common_bit_mask = ~ ( $ ones & $ twos ) ; $ ones &= $ common_bit_mask ; $ twos &= $ common_bit_mask ; } return $ ones ; }
function getSingle ( $ arr , $ n ) { global $ INT_SIZE ; $ result = 0 ; $ x ; $ sum ; for ( $ i = 0 ; $ i < $ INT_SIZE ; $ i ++ ) { $ sum = 0 ; $ x = ( 1 << $ i ) ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ arr [ $ j ] & $ x ) $ sum ++ ; } if ( ( $ sum % 3 ) != 0 ) $ result |= $ x ; } return $ result ; }
function oppositeSigns ( $ x , $ y ) { return ( ( $ x ^ $ y ) < 0 ) ; }
function countSetBits ( $ n ) { $ i = 0 ; $ ans = 0 ; while ( ( 1 << $ i ) <= $ n ) { $ k = 0 ; $ change = 1 << $ i ; for ( $ j = 0 ; $ j <= $ n ; $ j ++ ) { $ ans += $ k ; if ( $ change == 1 ) { $ k = ! $ k ; $ change = 1 << $ i ; } else { $ change -- ; } } $ i ++ ; } return $ ans ; }
function swapBits ( $ x , $ p1 , $ p2 , $ n ) { $ set1 = ( $ x >> $ p1 ) & ( ( 1 << $ n ) - 1 ) ; $ set2 = ( $ x >> $ p2 ) & ( ( 1 << $ n ) - 1 ) ; $ xor = ( $ set1 ^ $ set2 ) ; $ xor = ( $ xor << $ p1 ) | ( $ xor << $ p2 ) ; $ result = $ x ^ $ xor ; return $ result ; }
function Add ( $ x , $ y ) { while ( $ y != 0 ) { $ carry = $ x & $ y ; $ x = $ x ^ $ y ; $ y = $ carry << 1 ; } return $ x ; }
function smallest ( $ x , $ y , $ z ) { $ c = 0 ; while ( $ x && $ y && $ z ) { $ x -- ; $ y -- ; $ z -- ; $ c ++ ; } return $ c ; }
function snoob ( $ x ) { $ next = 0 ; if ( $ x ) { $ rightOne = $ x & - $ x ; $ nextHigherOneBit = $ x + $ rightOne ; $ rightOnesPattern = $ x ^ $ nextHigherOneBit ; $ rightOnesPattern = intval ( ( $ rightOnesPattern ) / $ rightOne ) ; $ rightOnesPattern >>= 2 ; $ next = $ nextHigherOneBit | $ rightOnesPattern ; } return $ next ; }
function addOne ( $ x ) { $ m = 1 ; while ( $ x & $ m ) { $ x = $ x ^ $ m ; $ m <<= 1 ; } $ x = $ x ^ $ m ; return $ x ; }
function addOne ( $ x ) { return ( - ( ~ $ x ) ) ; }
function multiplyWith3Point5 ( $ x ) { return ( $ x << 1 ) + $ x + ( $ x >> 1 ) ; }
function fun ( $ n ) { return $ n & ( $ n - 1 ) ; }
function isPowerOfFour ( $ n ) { $ count = 0 ; if ( $ n && ! ( $ n & ( $ n - 1 ) ) ) { while ( $ n > 1 ) { $ n >>= 1 ; $ count += 1 ; } return ( $ count % 2 == 0 ) ? 1 : 0 ; } return 0 ; }
function getModulo ( $ n , $ d ) { return ( $ n & ( $ d - 1 ) ) ; }
function getOddOccurrence ( & $ arr , $ arr_size ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ arr_size ; $ i ++ ) { for ( $ j = 0 ; $ j < $ arr_size ; $ j ++ ) { if ( $ arr [ $ i ] == $ arr [ $ j ] ) $ count ++ ; } if ( $ count % 2 != 0 ) return $ arr [ $ i ] ; } return -1 ; }
function countSetBits ( $ n ) { $ count = 0 ; while ( $ n ) { $ count += $ n & 1 ; $ n >>= 1 ; } return $ count ; }
function countSetBits ( $ n ) { if ( $ n == 0 ) return 0 ; else return 1 + countSetBits ( $ n & ( $ n - 1 ) ) ; }
function countSetBitsRec ( $ num ) { global $ num_to_bits ; $ nibble = 0 ; if ( 0 == $ num ) return $ num_to_bits [ 0 ] ; $ nibble = $ num & 0xf ; return $ num_to_bits [ $ nibble ] + countSetBitsRec ( $ num >> 4 ) ; }
function nextPowerOf2 ( $ n ) { $ count = 0 ; if ( $ n && ! ( $ n & ( $ n - 1 ) ) ) return $ n ; while ( $ n != 0 ) { $ n >>= 1 ; $ count += 1 ; } return 1 << $ count ; }
function nextPowerOf2 ( $ n ) { $ count = 0 ; if ( $ n && ! ( $ n & ( $ n - 1 ) ) ) return $ n ; while ( $ n != 0 ) { $ n >>= 1 ; $ count += 1 ; } return 1 << $ count ; }
function nextPowerOf2 ( $ n ) { $ n -- ; $ n |= $ n >> 1 ; $ n |= $ n >> 2 ; $ n |= $ n >> 4 ; $ n |= $ n >> 8 ; $ n |= $ n >> 16 ; $ n ++ ; return $ n ; }
function getParity ( $ n ) { $ parity = 0 ; while ( $ n ) { $ parity = ! $ parity ; $ n = $ n & ( $ n - 1 ) ; } return $ parity ; }
function isPowerOfTwo ( $ n ) { if ( $ n == 0 ) return 0 ; while ( $ n != 1 ) { if ( $ n % 2 != 0 ) return 0 ; $ n = $ n / 2 ; } return 1 ; }
function isPowerOfTwo ( $ x ) { return $ x && ( ! ( $ x & ( $ x - 1 ) ) ) ; }
function PositionRightmostSetbit ( $ n ) { $ position = 1 ; $ m = 1 ; while ( ! ( $ n & $ m ) ) { $ m = $ m << 1 ; $ position ++ ; } return $ position ; }
function bin ( $ n ) { if ( $ n > 1 ) bin ( $ n >> 1 ) ; echo ( $ n & 1 ) ; }
function swapBits ( $ x ) { $ even_bits = $ x & 0xAAAAAAAA ; $ odd_bits = $ x & 0x55555555 ; $ even_bits >>= 1 ; $ odd_bits <<= 1 ; return ( $ even_bits $ odd_bits ) ; }
function swap ( & $ xp , & $ yp ) { $ xp = $ xp ^ $ yp ; $ yp = $ xp ^ $ yp ; $ xp = $ xp ^ $ yp ; }
function maxOnesIndex ( $ arr , $ n ) { $ max_count = 0 ; $ max_index ; $ prev_zero = -1 ; $ prev_prev_zero = -1 ; for ( $ curr = 0 ; $ curr < $ n ; ++ $ curr ) { if ( $ arr [ $ curr ] == 0 ) { if ( $ curr - $ prev_prev_zero > $ max_count ) { $ max_count = $ curr - $ prev_prev_zero ; $ max_index = $ prev_zero ; } $ prev_prev_zero = $ prev_zero ; $ prev_zero = $ curr ; } } if ( $ n - $ prev_prev_zero > $ max_count ) $ max_index = $ prev_zero ; return $ max_index ; }
function isSubSequence ( $ str1 , $ str2 , $ m , $ n ) { if ( $ m == 0 ) return true ; if ( $ n == 0 ) return false ; if ( $ str1 [ $ m - 1 ] == $ str2 [ $ n - 1 ] ) return isSubSequence ( $ str1 , $ str2 , $ m - 1 , $ n - 1 ) ; return isSubSequence ( $ str1 , $ str2 , $ m , $ n - 1 ) ; }
function segregate0and1 ( & $ arr , $ size ) { $ left = 0 ; $ right = $ size - 1 ; while ( $ left < $ right ) { while ( $ arr [ $ left ] == 0 && $ left < $ right ) $ left ++ ; while ( $ arr [ $ right ] == 1 && $ left < $ right ) $ right -- ; if ( $ left < $ right ) { $ arr [ $ left ] = 0 ; $ arr [ $ right ] = 1 ; $ left ++ ; $ right -- ; } } }
function segregate0and1 ( & $ arr , $ size ) { $ type0 = 0 ; $ type1 = $ size - 1 ; while ( $ type0 < $ type1 ) { if ( $ arr [ $ type0 ] == 1 ) { $ temp = $ arr [ $ type0 ] ; $ arr [ $ type0 ] = $ arr [ $ type1 ] ; $ arr [ $ type1 ] = $ temp ; $ type1 -- ; } else $ type0 ++ ; } }
function replace_elements ( $ arr , $ n ) { $ pos = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ arr [ $ pos ++ ] = $ arr [ $ i ] ; while ( $ pos > 1 && $ arr [ $ pos - 2 ] == $ arr [ $ pos - 1 ] ) { $ pos -- ; $ arr [ $ pos - 1 ] ++ ; } } for ( $ i = 0 ; $ i < $ pos ; $ i ++ ) echo $ arr [ $ i ] . " ▁ " ; }
function rearrange ( & $ arr , $ n ) { if ( $ arr == NULL $ n % 2 == 1 ) return ; $ currIdx = intval ( ( $ n - 1 ) / 2 ) ; while ( $ currIdx > 0 ) { $ count = $ currIdx ; $ swapIdx = $ currIdx ; while ( $ count -- > 0 ) { $ temp = $ arr [ $ swapIdx + 1 ] ; $ arr [ $ swapIdx + 1 ] = $ arr [ $ swapIdx ] ; $ arr [ $ swapIdx ] = $ temp ; $ swapIdx ++ ; } $ currIdx -- ; } }
function maxDiff ( $ arr , $ arr_size ) { $ max_diff = $ arr [ 1 ] - $ arr [ 0 ] ; for ( $ i = 0 ; $ i < $ arr_size ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ arr_size ; $ j ++ ) { if ( $ arr [ $ j ] - $ arr [ $ i ] > $ max_diff ) $ max_diff = $ arr [ $ j ] - $ arr [ $ i ] ; } } return $ max_diff ; }
function maxDiff ( $ arr , $ n ) { $ maxDiff = -1 ; $ maxRight = $ arr [ $ n - 1 ] ; for ( $ i = $ n - 2 ; $ i >= 0 ; $ i -- ) { if ( $ arr [ $ i ] > $ maxRight ) $ maxRight = $ arr [ $ i ] ; else { $ diff = $ maxRight - $ arr [ $ i ] ; if ( $ diff > $ maxDiff ) { $ maxDiff = $ diff ; } } } return $ maxDiff ; }
function maxDiff ( $ arr , $ n ) { $ diff = $ arr [ 1 ] - $ arr [ 0 ] ; $ curr_sum = $ diff ; $ max_sum = $ curr_sum ; for ( $ i = 1 ; $ i < $ n - 1 ; $ i ++ ) { $ diff = $ arr [ $ i + 1 ] - $ arr [ $ i ] ; if ( $ curr_sum > 0 ) $ curr_sum += $ diff ; else $ curr_sum = $ diff ; if ( $ curr_sum > $ max_sum ) $ max_sum = $ curr_sum ; } return $ max_sum ; }
function maxIndexDiff ( $ arr , $ n ) { $ maxDiff = -1 ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { for ( $ j = $ n - 1 ; $ j > $ i ; -- $ j ) { if ( $ arr [ $ j ] > $ arr [ $ i ] && $ maxDiff < ( $ j - $ i ) ) $ maxDiff = $ j - $ i ; } } return $ maxDiff ; }
function findMaximum ( $ arr , $ low , $ high ) { $ max = $ arr [ $ low ] ; $ i ; for ( $ i = $ low ; $ i <= $ high ; $ i ++ ) { if ( $ arr [ $ i ] > $ max ) $ max = $ arr [ $ i ] ; } return $ max ; }
function findMaximum ( $ arr , $ low , $ high ) { if ( $ low == $ high ) return $ arr [ $ low ] ; if ( ( $ high == $ low + 1 ) && $ arr [ $ low ] >= $ arr [ $ high ] ) return $ arr [ $ low ] ; if ( ( $ high == $ low + 1 ) && $ arr [ $ low ] < $ arr [ $ high ] ) return $ arr [ $ high ] ; $ mid = ( $ low + $ high ) / 2 ; if ( $ arr [ $ mid ] > $ arr [ $ mid + 1 ] && $ arr [ $ mid ] > $ arr [ $ mid - 1 ] ) return $ arr [ $ mid ] ; if ( $ arr [ $ mid ] > $ arr [ $ mid + 1 ] && $ arr [ $ mid ] < $ arr [ $ mid - 1 ] ) return findMaximum ( $ arr , $ low , $ mid - 1 ) ; else return findMaximum ( $ arr , $ mid + 1 , $ high ) ; }
function maxRepeating ( $ arr , $ n , $ k ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ arr [ $ arr [ $ i ] % $ k ] += $ k ; $ max = $ arr [ 0 ] ; $ result = 0 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] > $ max ) { $ max = $ arr [ $ i ] ; $ result = $ i ; } } return $ result ; }
function smallestGreater ( $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ diff = PHP_INT_MAX ; $ closest = -1 ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ arr [ $ i ] < $ arr [ $ j ] && $ arr [ $ j ] - $ arr [ $ i ] < $ diff ) { $ diff = $ arr [ $ j ] - $ arr [ $ i ] ; $ closest = $ j ; } } if ( $ closest == -1 ) echo " _ ▁ " ; else echo $ arr [ $ closest ] , " ▁ " ; } }
function countIncreasing ( $ arr , $ n ) { $ cnt = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) { if ( $ arr [ $ j ] > $ arr [ $ j - 1 ] ) $ cnt ++ ; else break ; } } return $ cnt ; }
function countIncreasing ( $ arr , $ n ) { $ cnt = 0 ; $ len = 1 ; for ( $ i = 0 ; $ i < $ n - 1 ; ++ $ i ) { if ( $ arr [ $ i + 1 ] > $ arr [ $ i ] ) $ len ++ ; else { $ cnt += ( ( ( $ len - 1 ) * $ len ) / 2 ) ; $ len = 1 ; } } if ( $ len > 1 ) $ cnt += ( ( ( $ len - 1 ) * $ len ) / 2 ) ; return $ cnt ; }
function minNumber ( $ a , $ n , $ x ) { sort ( $ a ) ; $ k ; for ( $ k = 0 ; $ a [ ( $ n - 1 ) / 2 ] != $ x ; $ k ++ ) { $ a [ $ n ++ ] = $ x ; sort ( $ a ) ; } return $ k ; }
function minNumber ( $ a , $ n , $ x ) { $ l = 0 ; $ h = 0 ; $ e = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] == $ x ) $ e ++ ; else if ( $ a [ $ i ] > $ x ) $ h ++ ; else if ( $ a [ $ i ] < $ x ) $ l ++ ; } $ ans = 0 ; if ( $ l > $ h ) $ ans = $ l - $ h ; else if ( $ l < $ h ) $ ans = $ h - $ l - 1 ; return $ ans + 1 - $ e ; }
function checkEVENodd ( $ arr , $ n , $ l , $ r ) { if ( $ arr [ $ r ] == 1 ) echo " odd " , " STRNEWLINE " ; else echo " even " , " STRNEWLINE " ; }
function findMean ( $ arr , $ l , $ r ) { $ sum = 0 ; $ count = 0 ; for ( $ i = $ l ; $ i <= $ r ; $ i ++ ) { $ sum += $ arr [ $ i ] ; $ count ++ ; } $ mean = floor ( $ sum / $ count ) ; return $ mean ; }
function calculateProduct ( $ A , $ L , $ R , $ P ) { $ L = $ L - 1 ; $ R = $ R - 1 ; $ ans = 1 ; for ( $ i = $ L ; $ i <= $ R ; $ i ++ ) { $ ans = $ ans * $ A [ $ i ] ; $ ans = $ ans % $ P ; } return $ ans ; }
function countDe ( $ arr , $ n ) { $ v = $ arr ; sort ( $ arr ) ; $ count1 = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] != $ v [ $ i ] ) $ count1 ++ ; rsort ( $ arr ) ; $ count2 = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] != $ v [ $ i ] ) $ count2 ++ ; return ( min ( $ count1 , $ count2 ) ) ; }
function maxOfSegmentMins ( $ a , $ n , $ k ) { if ( $ k == 1 ) return min ( $ a ) ; if ( $ k == 2 ) return max ( $ a [ 0 ] , $ a [ $ n - 1 ] ) ; return max ( $ a ) ; }
function printMinimumProduct ( $ arr , $ n ) { $ first_min = min ( $ arr [ 0 ] , $ arr [ 1 ] ) ; $ second_min = max ( $ arr [ 0 ] , $ arr [ 1 ] ) ; for ( $ i = 2 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] < $ first_min ) { $ second_min = $ first_min ; $ first_min = $ arr [ $ i ] ; } else if ( $ arr [ $ i ] < $ second_min ) $ second_min = $ arr [ $ i ] ; } return $ first_min * $ second_min ; }
function noOfTriples ( $ arr , $ n ) { sort ( $ arr ) ; $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] == $ arr [ 2 ] ) $ count ++ ; if ( $ arr [ 0 ] == $ arr [ 2 ] ) return ( $ count - 2 ) * ( $ count - 1 ) * ( $ count ) / 6 ; else if ( $ arr [ 1 ] == $ arr [ 2 ] ) return ( $ count - 1 ) * ( $ count ) / 2 ; return $ count ; }
function MinOperation ( $ a , $ b , $ n ) { sort ( $ a ) ; sort ( $ b ) ; $ result = 0 ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { if ( $ a [ $ i ] > $ b [ $ i ] ) $ result = $ result + abs ( $ a [ $ i ] - $ b [ $ i ] ) ; else if ( $ a [ $ i ] < $ b [ $ i ] ) $ result = $ result + abs ( $ a [ $ i ] - $ b [ $ i ] ) ; } return $ result ; }
function sortExceptUandL ( $ a , $ l , $ u , $ n ) { $ b = array ( ) ; for ( $ i = 0 ; $ i < $ l ; $ i ++ ) $ b [ $ i ] = $ a [ $ i ] ; for ( $ i = $ u + 1 ; $ i < $ n ; $ i ++ ) $ b [ $ l + ( $ i - ( $ u + 1 ) ) ] = $ a [ $ i ] ; sort ( $ b ) ; for ( $ i = 0 ; $ i < $ l ; $ i ++ ) $ a [ $ i ] = $ b [ $ i ] ; for ( $ i = $ u + 1 ; $ i < $ n ; $ i ++ ) $ a [ $ i ] = $ b [ $ l + ( $ i - ( $ u + 1 ) ) ] ; }
function sortExceptK ( & $ arr , $ k , $ n ) { $ t = $ arr [ $ k ] ; $ arr [ $ k ] = $ arr [ $ n - 1 ] ; $ arr [ $ n - 1 ] = $ t ; $ t = $ arr [ count ( $ arr ) - 1 ] ; $ arr = array_slice ( $ arr , 0 , -1 ) ; sort ( $ arr ) ; array_push ( $ arr , $ t ) ; $ last = $ arr [ $ n - 1 ] ; for ( $ i = $ n - 1 ; $ i > $ k ; $ i -- ) $ arr [ $ i ] = $ arr [ $ i - 1 ] ; $ arr [ $ k ] = $ last ; }
function maxPartitions ( $ arr , $ n ) { $ ans = 0 ; $ max_so_far = 0 ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { $ max_so_far = max ( $ max_so_far , $ arr [ $ i ] ) ; if ( $ max_so_far == $ i ) $ ans ++ ; } return $ ans ; } { $ arr = array ( 1 , 0 , 2 , 3 , 4 ) ; $ n = sizeof ( $ arr ) / sizeof ( $ arr [ 0 ] ) ; echo maxPartitions ( $ arr , $ n ) ; return 0 ; }
function min_noOf_operation ( $ arr , $ n , $ k ) { $ noOfSubtraction ; $ res = 0 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ noOfSubtraction = 0 ; if ( $ arr [ $ i ] > $ arr [ $ i - 1 ] ) { $ noOfSubtraction = ( $ arr [ $ i ] - $ arr [ $ i - 1 ] ) / $ k ; if ( ( $ arr [ $ i ] - $ arr [ $ i - 1 ] ) % $ k != 0 ) $ noOfSubtraction ++ ; $ arr [ $ i ] = $ arr [ $ i ] - $ k * $ noOfSubtraction ; } $ res = $ res + $ noOfSubtraction ; } return floor ( $ res ) ; }
function maxSum ( $ arr , $ n ) { sort ( $ arr ) ; $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum += ( $ arr [ $ i ] * $ i ) ; return $ sum ; }
function countPairs ( $ a , $ n , $ k ) { $ res = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) if ( abs ( $ a [ $ j ] - $ a [ $ i ] ) < $ k ) $ res ++ ; return $ res ; }
function countPairs ( $ a , $ n , $ k ) { sort ( $ a ) ; $ res = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ j = $ i + 1 ; while ( $ j < $ n and $ a [ $ j ] - $ a [ $ i ] < $ k ) { $ res ++ ; $ j ++ ; } } return $ res ; }
function sumOfMinAbsDifferences ( $ arr , $ n ) { sort ( $ arr ) ; sort ( $ arr , $ n ) ; $ sum = 0 ; $ sum += abs ( $ arr [ 0 ] - $ arr [ 1 ] ) ; $ sum += abs ( $ arr [ $ n - 1 ] - $ arr [ $ n - 2 ] ) ; for ( $ i = 1 ; $ i < $ n - 1 ; $ i ++ ) $ sum += min ( abs ( $ arr [ $ i ] - $ arr [ $ i - 1 ] ) , abs ( $ arr [ $ i ] - $ arr [ $ i + 1 ] ) ) ; return $ sum ; }
function findSmallestDifference ( $ A , $ B , $ m , $ n ) { sort ( $ A ) ; sort ( $ A , $ m ) ; sort ( $ B ) ; sort ( $ B , $ n ) ; $ a = 0 ; $ b = 0 ; $ INT_MAX = 1 ; $ result = $ INT_MAX ; while ( $ a < $ m && $ b < $ n ) { if ( abs ( $ A [ $ a ] - $ B [ $ b ] ) < $ result ) $ result = abs ( $ A [ $ a ] - $ B [ $ b ] ) ; if ( $ A [ $ a ] < $ B [ $ b ] ) $ a ++ ; else $ b ++ ; } return $ result ; } { $ A = array ( 1 , 2 , 11 , 5 ) ; $ B = array ( 4 , 12 , 19 , 23 , 127 , 235 ) ; $ m = sizeof ( $ A ) / sizeof ( $ A [ 0 ] ) ; $ n = sizeof ( $ B ) / sizeof ( $ B [ 0 ] ) ; echo findSmallestDifference ( $ A , $ B , $ m , $ n ) ; return 0 ; }
function findLarger ( $ arr , $ n ) { sort ( $ arr ) ; for ( $ i = $ n - 1 ; $ i >= $ n / 2 ; $ i -- ) echo $ arr [ $ i ] , " ▁ " ; }
function countOccurrences ( $ arr , $ n , $ x ) { $ res = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ x == $ arr [ $ i ] ) $ res ++ ; return $ res ; }
function printClosest ( $ arr , $ n , $ x ) { $ res_l ; $ res_r ; $ l = 0 ; $ r = $ n - 1 ; $ diff = PHP_INT_MAX ; while ( $ r > $ l ) { if ( abs ( $ arr [ $ l ] + $ arr [ $ r ] - $ x ) < $ diff ) { $ res_l = $ l ; $ res_r = $ r ; $ diff = abs ( $ arr [ $ l ] + $ arr [ $ r ] - $ x ) ; } if ( $ arr [ $ l ] + $ arr [ $ r ] > $ x ) $ r -- ; else $ l ++ ; } echo " ▁ The ▁ closest ▁ pair ▁ is ▁ " , $ arr [ $ res_l ] , " ▁ and ▁ " , $ arr [ $ res_r ] ; }
function countOnes ( $ arr , $ low , $ high ) { if ( $ high >= $ low ) { $ mid = $ low + ( $ high - $ low ) / 2 ; if ( ( $ mid == $ high or $ arr [ $ mid + 1 ] == 0 ) and ( $ arr [ $ mid ] == 1 ) ) return $ mid + 1 ; if ( $ arr [ $ mid ] == 1 ) return countOnes ( $ arr , ( $ mid + 1 ) , $ high ) ; return countOnes ( $ arr , $ low , ( $ mid - 1 ) ) ; } return 0 ; }
function findMissing ( $ arr1 , $ arr2 , $ M , $ N ) { if ( $ M != $ N - 1 && $ N != $ M - 1 ) { echo " Invalid ▁ Input " ; return ; } $ res = 0 ; for ( $ i = 0 ; $ i < $ M ; $ i ++ ) $ res = $ res ^ $ arr1 [ $ i ] ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) $ res = $ res ^ $ arr2 [ $ i ] ; echo " Missing ▁ element ▁ is ▁ " , $ res ; }
function printTwoOdd ( $ arr , $ size ) { $ xor2 = $ arr [ 0 ] ; $ set_bit_no ; $ i ; $ n = $ size - 2 ; $ x = 0 ; $ y = 0 ; for ( $ i = 1 ; $ i < $ size ; $ i ++ ) $ xor2 = $ xor2 ^ $ arr [ $ i ] ; $ set_bit_no = $ xor2 & ~ ( $ xor2 - 1 ) ; for ( $ i = 0 ; $ i < $ size ; $ i ++ ) { if ( $ arr [ $ i ] & $ set_bit_no ) $ x = $ x ^ $ arr [ $ i ] ; else $ y = $ y ^ $ arr [ $ i ] ; } echo " The ▁ two ▁ ODD ▁ elements ▁ are ▁ " , $ x , " ▁ & ▁ " , $ y ; }
function findPair ( & $ arr , $ size , $ n ) { $ i = 0 ; $ j = 1 ; while ( $ i < $ size && $ j < $ size ) { if ( $ i != $ j && $ arr [ $ j ] - $ arr [ $ i ] == $ n ) { echo " Pair ▁ Found : ▁ " . " ( " . $ arr [ $ i ] . " , ▁ " . $ arr [ $ j ] . " ) " ; return true ; } else if ( $ arr [ $ j ] - $ arr [ $ i ] < $ n ) $ j ++ ; else $ i ++ ; } echo " No ▁ such ▁ pair " ; return false ; }
function findFourElements ( $ A , $ n , $ X ) { for ( $ i = 0 ; $ i < $ n - 3 ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ n - 2 ; $ j ++ ) { for ( $ k = $ j + 1 ; $ k < $ n - 1 ; $ k ++ ) { for ( $ l = $ k + 1 ; $ l < $ n ; $ l ++ ) if ( $ A [ $ i ] + $ A [ $ j ] + $ A [ $ k ] + $ A [ $ l ] == $ X ) echo $ A [ $ i ] , " , ▁ " , $ A [ $ j ] , " , ▁ " , $ A [ $ k ] , " , ▁ " , $ A [ $ l ] ; } } } }
function search ( $ arr , $ n , $ x ) { $ i = 0 ; while ( $ i < $ n ) { if ( $ arr [ $ i ] == $ x ) return $ i ; $ i = $ i + abs ( $ arr [ $ i ] - $ x ) ; } echo " number ▁ is ▁ not ▁ present ! " ; return -1 ; }
function thirdLargest ( $ arr , $ arr_size ) { if ( $ arr_size < 3 ) { echo " ▁ Invalid ▁ Input ▁ " ; return ; } $ first = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ arr_size ; $ i ++ ) if ( $ arr [ $ i ] > $ first ) $ first = $ arr [ $ i ] ; $ second = PHP_INT_MIN ; for ( $ i = 0 ; $ i < $ arr_size ; $ i ++ ) if ( $ arr [ $ i ] > $ second && $ arr [ $ i ] < $ first ) $ second = $ arr [ $ i ] ; $ third = PHP_INT_MIN ; for ( $ i = 0 ; $ i < $ arr_size ; $ i ++ ) if ( $ arr [ $ i ] > $ third && $ arr [ $ i ] < $ second ) $ third = $ arr [ $ i ] ; echo " The ▁ third ▁ Largest ▁ element ▁ is ▁ " , $ third , " STRNEWLINE " ; }
function search ( $ arr , $ n , $ x ) { if ( $ arr [ $ n - 1 ] == $ x ) return " Found " ; $ backup = $ arr [ $ n - 1 ] ; $ arr [ $ n - 1 ] = $ x ; for ( $ i = 0 ; ; $ i ++ ) { if ( $ arr [ $ i ] == $ x ) { $ arr [ $ n - 1 ] = $ backup ; if ( $ i < $ n - 1 ) return " Found " ; return " Not ▁ Found " ; } } }
function findMajority ( $ arr , $ n ) { return $ arr [ intval ( $ n / 2 ) ] ; }
function minAdjDifference ( $ arr , $ n ) { if ( $ n < 2 ) return ; $ res = abs ( $ arr [ 1 ] - $ arr [ 0 ] ) ; for ( $ i = 2 ; $ i < $ n ; $ i ++ ) $ res = min ( $ res , abs ( $ arr [ $ i ] - $ arr [ $ i - 1 ] ) ) ; $ res = min ( $ res , abs ( $ arr [ $ n - 1 ] - $ arr [ 0 ] ) ) ; echo " Min ▁ Difference ▁ = ▁ " , $ res ; }
function getInvCount ( $ arr , $ n ) { $ invcount = 0 ; for ( $ i = 1 ; $ i < $ n - 1 ; $ i ++ ) { $ small = 0 ; for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) if ( $ arr [ $ i ] > $ arr [ $ j ] ) $ small ++ ; $ great = 0 ; for ( $ j = $ i - 1 ; $ j >= 0 ; $ j -- ) if ( $ arr [ $ i ] < $ arr [ $ j ] ) $ great ++ ; $ invcount += $ great * $ small ; } return $ invcount ; }
function findWater ( $ arr , $ n ) { $ water = 0 ; $ left [ 0 ] = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ left [ $ i ] = max ( $ left [ $ i - 1 ] , $ arr [ $ i ] ) ; $ right [ $ n - 1 ] = $ arr [ $ n - 1 ] ; for ( $ i = $ n - 2 ; $ i >= 0 ; $ i -- ) $ right [ $ i ] = max ( $ right [ $ i + 1 ] , $ arr [ $ i ] ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ water += min ( $ left [ $ i ] , $ right [ $ i ] ) - $ arr [ $ i ] ; return $ water ; }
function findWater ( $ arr , $ n ) { $ result = 0 ; $ left_max = 0 ; $ right_max = 0 ; $ lo = 0 ; $ hi = $ n - 1 ; while ( $ lo <= $ hi ) { if ( $ arr [ $ lo ] < $ arr [ $ hi ] ) { if ( $ arr [ $ lo ] > $ left_max ) $ left_max = $ arr [ $ lo ] ; else $ result += $ left_max - $ arr [ $ lo ] ; $ lo ++ ; } else { if ( $ arr [ $ hi ] > $ right_max ) $ right_max = $ arr [ $ hi ] ; else $ result += $ right_max - $ arr [ $ hi ] ; $ hi -- ; } } return $ result ; }
function missingK ( & $ a , $ k , $ n ) { $ difference = 0 ; $ ans = 0 ; $ count = $ k ; $ flag = 0 ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { $ difference = 0 ; if ( ( $ a [ $ i ] + 1 ) != $ a [ $ i + 1 ] ) { $ difference += ( $ a [ $ i + 1 ] - $ a [ $ i ] ) - 1 ; if ( $ difference >= $ count ) { $ ans = $ a [ $ i ] + $ count ; $ flag = 1 ; break ; } else $ count -= $ difference ; } } if ( $ flag ) return $ ans ; else return -1 ; }
function countPairs ( $ A , $ n , $ k ) { $ ans = 0 ; sort ( $ A ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) { $ x = 0 ; while ( ( $ A [ $ i ] * pow ( $ k , $ x ) ) <= $ A [ $ j ] ) { if ( ( $ A [ $ i ] * pow ( $ k , $ x ) ) == $ A [ $ j ] ) { $ ans ++ ; break ; } $ x ++ ; } } } return $ ans ; }
function findValue ( $ arr , $ n , $ k ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] == $ k ) $ k *= 2 ; return $ k ; }
function dupLastIndex ( $ arr , $ n ) { if ( $ arr == null or $ n <= 0 ) return ; for ( $ i = $ n - 1 ; $ i > 0 ; $ i -- ) { if ( $ arr [ $ i ] == $ arr [ $ i - 1 ] ) { echo " Last ▁ index : " , $ i , " STRNEWLINE " ; echo " Last ▁ duplicate ▁ item : " , $ arr [ $ i ] ; return ; } } echo " no ▁ duplicate ▁ found " ; }
function findSmallest ( $ a , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ j ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) if ( $ a [ $ j ] % $ a [ $ i ] ) break ; if ( $ j == $ n ) return $ a [ $ i ] ; } return -1 ; }
function findIndex ( $ arr , $ len ) { $ maxIndex = 0 ; for ( $ i = 0 ; $ i < $ len ; ++ $ i ) if ( $ arr [ $ i ] > $ arr [ $ maxIndex ] ) $ maxIndex = $ i ; for ( $ i = 0 ; $ i < $ len ; ++ $ i ) if ( $ maxIndex != $ i and $ arr [ $ maxIndex ] < 2 * $ arr [ $ i ] ) return -1 ; return $ maxIndex ; }
function find_consecutive_steps ( $ arr , $ len ) { $ count = 0 ; $ maximum = 0 ; for ( $ index = 1 ; $ index < $ len ; $ index ++ ) { if ( $ arr [ $ index ] > $ arr [ $ index - 1 ] ) $ count ++ ; else { $ maximum = max ( $ maximum , $ count ) ; $ count = 0 ; } } return max ( $ maximum , $ count ) ; }
function CalculateMax ( $ arr , $ n ) { sort ( $ arr ) ; $ min_sum = $ arr [ 0 ] + $ arr [ 1 ] ; $ max_sum = $ arr [ $ n - 1 ] + $ arr [ $ n - 2 ] ; return abs ( $ max_sum - $ min_sum ) ; }
function calculate ( $ a , $ n ) { sort ( $ a ) ; $ s = array ( ) ; for ( $ i = 0 , $ j = $ n - 1 ; $ i < $ j ; $ i ++ , $ j -- ) array_push ( $ s , ( $ a [ $ i ] + $ a [ $ j ] ) ) ; $ mini = min ( $ s ) ; $ maxi = max ( $ s ) ; return abs ( $ maxi - $ mini ) ; }
function printMinDiffPairs ( $ arr , $ n ) { if ( $ n <= 1 ) return ; sort ( $ arr ) ; $ minDiff = $ arr [ 1 ] - $ arr [ 0 ] ; for ( $ i = 2 ; $ i < $ n ; $ i ++ ) $ minDiff = min ( $ minDiff , $ arr [ $ i ] - $ arr [ $ i - 1 ] ) ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) if ( ( $ arr [ $ i ] - $ arr [ $ i - 1 ] ) == $ minDiff ) echo " ( " , $ arr [ $ i - 1 ] , " , ▁ " , $ arr [ $ i ] , " ) , ▁ " ; }
function maxDistance ( $ arr , $ n ) { $ max1 = PHP_INT_MIN ; $ min1 = PHP_INT_MAX ; $ max2 = PHP_INT_MIN ; $ min2 = PHP_INT_MAX ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ max1 = max ( $ max1 , $ arr [ $ i ] + $ i ) ; $ min1 = min ( $ min1 , $ arr [ $ i ] + $ i ) ; $ max2 = max ( $ max2 , $ arr [ $ i ] - $ i ) ; $ min2 = min ( $ min2 , $ arr [ $ i ] - $ i ) ; } return max ( $ max1 - $ min1 , $ max2 - $ min2 ) ; }
function extrema ( $ a , $ n ) { $ count = 0 ; for ( $ i = 1 ; $ i < $ n - 1 ; $ i ++ ) { $ count += ( $ a [ $ i ] > $ a [ $ i - 1 ] and $ a [ $ i ] > $ a [ $ i + 1 ] ) ; $ count += ( $ a [ $ i ] < $ a [ $ i - 1 ] and $ a [ $ i ] < $ a [ $ i + 1 ] ) ; } return $ count ; }
function sum ( $ a , $ n ) { $ maxSum = PHP_INT_MIN ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) $ maxSum = max ( $ maxSum , $ a [ $ i ] + $ a [ $ j ] ) ; $ c = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) if ( $ a [ $ i ] + $ a [ $ j ] == $ maxSum ) $ c ++ ; return $ c ; }
function nobleInteger ( $ arr , $ size ) { for ( $ i = 0 ; $ i < $ size ; $ i ++ ) { $ count = 0 ; for ( $ j = 0 ; $ j < $ size ; $ j ++ ) if ( $ arr [ $ i ] < $ arr [ $ j ] ) $ count ++ ; if ( $ count == $ arr [ $ i ] ) return $ arr [ $ i ] ; } return -1 ; }
function nobleInteger ( $ arr ) { sort ( $ arr ) ; $ n = count ( $ arr ) ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { if ( $ arr [ $ i ] == $ arr [ $ i + 1 ] ) continue ; if ( $ arr [ $ i ] == $ n - $ i - 1 ) return $ arr [ $ i ] ; } if ( $ arr [ $ n - 1 ] == 0 ) return $ arr [ $ n - 1 ] ; return -1 ; }
function findMinSum ( $ a , $ b , $ n ) { sort ( $ a ) ; sort ( $ a , $ n ) ; sort ( $ b ) ; sort ( $ b , $ n ) ; $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum = $ sum + abs ( $ a [ $ i ] - $ b [ $ i ] ) ; return $ sum ; }
function checkIsAP ( $ arr , $ n ) { if ( $ n == 1 ) return true ; sort ( $ arr ) ; $ d = $ arr [ 1 ] - $ arr [ 0 ] ; for ( $ i = 2 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] - $ arr [ $ i - 1 ] != $ d ) return false ; return true ; }
function countOddRotations ( $ n ) { $ odd_count = 0 ; $ even_count = 0 ; do { $ digit = $ n % 10 ; if ( $ digit % 2 == 1 ) $ odd_count ++ ; else $ even_count ++ ; $ n = ( int ) ( $ n / 10 ) ; } while ( $ n != 0 ) ; echo " Odd = " , ▁ $ odd _ count , ▁ " " ; STRNEWLINE TABSYMBOL echo ▁ " Even = " , ▁ $ even _ count , ▁ " " }
function occurredOnce ( & $ arr , $ n ) { sort ( $ arr ) ; if ( $ arr [ 0 ] != $ arr [ 1 ] ) echo $ arr [ 0 ] . " ▁ " ; for ( $ i = 1 ; $ i < $ n - 1 ; $ i ++ ) if ( $ arr [ $ i ] != $ arr [ $ i + 1 ] && $ arr [ $ i ] != $ arr [ $ i - 1 ] ) echo $ arr [ $ i ] . " ▁ " ; if ( $ arr [ $ n - 2 ] != $ arr [ $ n - 1 ] ) echo $ arr [ $ n - 1 ] . " ▁ " ; }
function occurredOnce ( & $ arr , $ n ) { $ i = 1 ; $ len = $ n ; if ( $ arr [ 0 ] == $ arr [ $ len - 1 ] ) { $ i = 2 ; $ len -- ; } for ( ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] == $ arr [ $ i - 1 ] ) $ i ++ ; else echo $ arr [ $ i - 1 ] . " ▁ " ; if ( $ arr [ $ n - 1 ] != $ arr [ 0 ] && $ arr [ $ n - 1 ] != $ arr [ $ n - 2 ] ) echo $ arr [ $ n - 1 ] ; }
function isRotation ( $ x , $ y ) { $ x64 = $ x | ( $ x << 32 ) ; while ( $ x64 >= $ y ) { if ( ( $ x64 ) == $ y ) return 1 ; $ x64 >>= 1 ; } return -1 ; }
function power ( $ x , $ y , $ p ) { $ res = 1 ; $ x = $ x % $ p ; while ( $ y > 0 ) { if ( $ y & 1 ) $ res = ( $ res * $ x ) % $ p ; $ x = ( $ x * $ x ) % $ p ; } return $ res ; }
function getMinVal ( $ p , $ q ) { if ( $ q % $ p == 0 ) return $ p ; return -1 ; }
function findPoints ( $ l1 , $ r1 , $ l2 , $ r2 ) { $ x = ( $ l1 != $ l2 ) ? min ( $ l1 , $ l2 ) : -1 ; $ y = ( $ r1 != $ r2 ) ? max ( $ r1 , $ r2 ) : -1 ; echo $ x , " " , $ y ; }
function minOperations ( $ N ) { $ x = log ( $ N , 2 ) ; $ ans = ceil ( $ x ) ; return $ ans ; }
function find_greatest_divisor ( $ l , $ r ) { if ( $ l == $ r ) return $ l ; return 1 ; }
function findNumbers ( $ arr , $ n ) { $ sumN = ( $ n * ( $ n + 1 ) ) / 2 ; $ sumSqN = ( $ n * ( $ n + 1 ) * ( 2 * $ n + 1 ) ) / 6 ; $ sum = 0 ; $ sumSq = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sum += $ arr [ $ i ] ; $ sumSq += pow ( $ arr [ $ i ] , 2 ) ; } $ B = ( ( ( $ sumSq - $ sumSqN ) / ( $ sum - $ sumN ) ) + $ sumN - $ sum ) / 2 ; $ A = $ sum - $ sumN + $ B ; echo " A = " , ▁ $ A , ▁ " B = " }
function getProbability ( $ p , $ q ) { $ p /= 100 ; $ q /= 100 ; $ probability = ( $ p * $ p + $ q * $ q ) / ( $ p + $ q ) ; return $ probability ; }
function check ( $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] & 1 ) return true ; } return false ; }
function fib ( $ n ) { if ( $ n <= 1 ) return $ n ; return fib ( $ n - 1 ) + fib ( $ n - 2 ) ; }
function fact ( $ n ) { if ( $ n == 0 ) return 1 ; return $ n * fact ( $ n - 1 ) ; }
function MinimumX ( $ a , $ b , $ c , $ k ) { $ x = PHP_INT_MAX ; if ( $ k <= $ c ) return 0 ; $ h = $ k - $ c ; $ l = 0 ; while ( $ l <= $ h ) { $ m = floor ( ( $ l + $ h ) / 2 ) ; if ( ( $ a * $ m * $ m ) + ( $ b * $ m ) > ( $ k - $ c ) ) { $ x = min ( $ x , $ m ) ; $ h = $ m - 1 ; } else if ( ( $ a * $ m * $ m ) + ( $ b * $ m ) < ( $ k - $ c ) ) $ l = $ m + 1 ; else return $ m ; } return $ x ; }
function findMissing ( $ arr , $ n ) { $ l = 0 ; $ h = $ n - 1 ; while ( $ h > $ l ) { $ mid = floor ( $ l + ( $ h - $ l ) / 2 ) ; if ( $ arr [ $ mid ] - $ mid == $ arr [ 0 ] ) { if ( $ arr [ $ mid + 1 ] - $ arr [ $ mid ] > 1 ) return $ arr [ $ mid ] + 1 ; else { $ l = $ mid + 1 ; } } else { if ( $ arr [ $ mid ] - $ arr [ $ mid - 1 ] > 1 ) return $ arr [ $ mid ] - 1 ; else { $ h = $ mid - 1 ; } } } return -1 ; }
function maxSum ( $ arr , $ n , $ K ) { $ maximum = PHP_INT_MIN ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sumk = 0 ; for ( $ j = $ i ; $ j < $ n ; $ j += $ K ) $ sumk = $ sumk + $ arr [ $ j ] ; $ maximum = max ( $ maximum , $ sumk ) ; } return $ maximum ; }
function countGreater ( $ arr , $ n , $ k ) { $ l = 0 ; $ r = $ n - 1 ; $ leftGreater = $ n ; while ( $ l <= $ r ) { $ m = $ l + ( int ) ( ( $ r - $ l ) / 2 ) ; if ( $ arr [ $ m ] > $ k ) { $ leftGreater = $ m ; $ r = $ m - 1 ; } else $ l = $ m + 1 ; } return ( $ n - $ leftGreater ) ; }
function findpair ( $ l , $ r ) { $ c = 0 ; for ( $ i = $ l ; $ i <= $ r ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j <= $ r ; $ j ++ ) { if ( $ j % $ i == 0 && $ j != $ i ) { echo ( $ i . " , ▁ " . $ j ) ; $ c = 1 ; break ; } } if ( $ c == 1 ) break ; } }
function findpair ( $ l , $ r ) { $ ans1 = $ l ; $ ans2 = 2 * $ l ; echo ( $ ans1 . " , ▁ " . $ ans2 ) ; }
function minIndex ( $ arr , $ n , $ pos ) { $ num = $ arr [ $ pos ] ; $ i = $ pos - 1 ; while ( $ i >= 0 ) { if ( $ arr [ $ i ] != $ num ) break ; $ i -- ; } return $ i + 1 ; }
function countSubArrays ( $ arr , $ n , $ K ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { $ bitwise_or = 0 ; for ( $ k = $ i ; $ k < $ j + 1 ; $ k ++ ) $ bitwise_or = $ bitwise_or | $ arr [ $ k ] ; if ( $ bitwise_or >= $ K ) $ count += 1 ; } } return $ count ; }
function max_min ( & $ a , $ n ) { sort ( $ a ) ; return min ( $ a [ $ n - 2 ] - $ a [ 0 ] , $ a [ $ n - 1 ] - $ a [ 1 ] ) ; }
function findMinDifference ( $ arr , $ n ) { sort ( $ arr , 0 ) ; $ diff1 = $ arr [ $ n - 1 ] - $ arr [ 1 ] ; $ diff2 = $ arr [ $ n - 2 ] - $ arr [ 0 ] ; return min ( $ diff1 , $ diff2 ) ; }
function minimal ( $ a , $ n ) { $ lo = 0 ; $ hi = $ n - 1 ; while ( $ lo < $ hi ) { $ mid = ( $ lo + $ hi ) >> 1 ; if ( $ a [ $ mid ] < $ a [ $ mid + 1 ] ) { $ hi = $ mid ; } else { $ lo = $ mid + 1 ; } } return $ lo ; }
function LowerInsertionPoint ( $ arr , $ n , $ X ) { if ( $ X < $ arr [ 0 ] ) return 0 ; else if ( $ X > $ arr [ $ n - 1 ] ) return $ n ; $ lowerPnt = 0 ; $ i = 1 ; while ( $ i < $ n && $ arr [ $ i ] < $ X ) { $ lowerPnt = $ i ; $ i = $ i * 2 ; } while ( $ lowerPnt < $ n && $ arr [ $ lowerPnt ] < $ X ) $ lowerPnt ++ ; return $ lowerPnt ; }
function minIndex ( & $ arr , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum += $ arr [ $ i ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( 2 * $ arr [ $ i ] == $ sum ) return ( $ i + 1 ) ; } return -1 ; }
function smallest_pair ( $ a , $ n ) { $ min = PHP_INT_MAX ; $ secondMin = PHP_INT_MAX ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ a [ $ j ] < $ min ) { $ secondMin = $ min ; $ min = $ a [ $ j ] ; } else if ( ( $ a [ $ j ] < $ secondMin ) && $ a [ $ j ] != $ min ) $ secondMin = $ a [ $ j ] ; } return ( $ secondMin + $ min ) ; }
function printIntersection ( $ A , $ B ) { $ N = 4 ; $ M = 4 ; for ( $ i = 0 ; $ i < $ M ; $ i ++ ) { for ( $ j = 0 ; $ j < $ N ; $ j ++ ) { if ( $ A [ $ i ] [ $ j ] == $ B [ $ i ] [ $ j ] ) echo $ A [ $ i ] [ $ j ] . " ▁ " ; else echo " * ▁ " ; } echo " STRNEWLINE " ; } }
function checkIndices ( $ Arr , $ N ) { for ( $ i = 0 ; $ i < $ N - 1 ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ N ; $ j ++ ) { if ( $ Arr [ $ i ] != $ Arr [ $ j ] ) { if ( $ Arr [ $ Arr [ $ i ] - 1 ] == $ Arr [ $ Arr [ $ j ] - 1 ] ) return true ; } } } return false ; }
function LongestSubarray ( $ arr , $ n , $ k ) { $ cnt = 1 ; $ max_length = 1 ; $ prev_mod = $ arr [ 0 ] % $ k ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ curr_mod = $ arr [ $ i ] % $ k ; if ( $ curr_mod == $ prev_mod ) { $ cnt ++ ; } else { $ max_length = max ( $ max_length , $ cnt ) ; $ cnt = 1 ; $ prev_mod = $ curr_mod ; } } return max ( $ max_length , $ cnt ) ; }
function longestsubarray ( $ arr , $ n , $ k ) { $ current_count = 0 ; $ max_count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] % $ k == 0 ) $ current_count ++ ; else $ current_count = 0 ; $ max_count = max ( $ current_count , $ max_count ) ; } return $ max_count ; }
function countSegments ( $ a , $ n , $ x ) { $ flag = false ; $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] > $ x ) { $ flag = true ; } else { if ( $ flag ) $ count += 1 ; $ flag = false ; } } if ( $ flag ) $ count += 1 ; return $ count ; }
function check ( $ s ) { for ( $ i = 0 ; $ i < strlen ( $ s ) - 1 ; $ i ++ ) if ( $ s [ $ i ] == $ s [ $ i + 1 ] ) return true ; return false ; }
function numberOfElements ( $ height , $ n ) { $ max_so_far = 0 ; $ coun = 0 ; for ( $ i = $ n - 1 ; $ i >= 0 ; $ i -- ) { if ( $ height [ $ i ] > $ max_so_far ) { $ max_so_far = $ height [ $ i ] ; $ coun ++ ; } } return $ coun ; }
function count_triples ( $ n , $ k ) { $ i = 0 ; $ j = 0 ; $ l = 0 ; $ count = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 1 ; $ j <= $ n ; $ j ++ ) { for ( $ l = 1 ; $ l <= $ n ; $ l ++ ) { if ( ( $ i + $ j ) % $ k == 0 && ( $ i + $ l ) % $ k == 0 && ( $ j + $ l ) % $ k == 0 ) $ count ++ ; } } } return $ count ; }
function countAnomalies ( & $ arr , $ n , $ k ) { $ res = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) if ( $ i != $ j && abs ( $ arr [ $ i ] - $ arr [ $ j ] ) <= $ k ) break ; if ( $ j == $ n ) $ res ++ ; } return $ res ; }
function colMaxDiff ( $ mat ) { $ N = 5 ; $ max_diff = PHP_INT_MIN ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { $ max_val = $ mat [ 0 ] [ $ i ] ; $ min_val = $ mat [ 0 ] [ $ i ] ; for ( $ j = 1 ; $ j < $ N ; $ j ++ ) { $ max_val = max ( $ max_val , $ mat [ $ j ] [ $ i ] ) ; $ min_val = min ( $ min_val , $ mat [ $ j ] [ $ i ] ) ; } $ max_diff = max ( $ max_diff , $ max_val - $ min_val ) ; } return $ max_diff ; }
function countChar ( $ str ) { $ n = strlen ( $ str ) ; if ( $ n <= 2 ) return $ n ; $ count = 2 ; for ( $ i = 1 ; $ i < $ n - 1 ; $ i ++ ) if ( $ str [ $ i - 1 ] == $ str [ $ i + 1 ] ) $ count ++ ; return $ count ; }
function search ( $ ar , $ size ) { $ a = 0 ; $ b = $ size - 1 ; $ mid ; while ( ( $ b - $ a ) > 1 ) { $ mid = ( int ) ( ( $ a + $ b ) / 2 ) ; if ( ( $ ar [ $ a ] - $ a ) != ( $ ar [ $ mid ] - $ mid ) ) $ b = $ mid ; else if ( ( $ ar [ $ b ] - $ b ) != ( $ ar [ $ mid ] - $ mid ) ) $ a = $ mid ; } return ( $ ar [ $ a ] + 1 ) ; }
function next0 ( $ arr , $ target ) { $ start = 0 ; $ end = sizeof ( $ arr ) - 1 ; $ ans = -1 ; while ( $ start <= $ end ) { $ mid = ( int ) ( ( $ start + $ end ) / 2 ) ; if ( $ arr [ $ mid ] <= $ target ) { $ start = $ mid + 1 ; } else { $ ans = $ mid ; $ end = $ mid - 1 ; } } return $ ans ; } { $ arr = array ( 1 , 2 , 3 , 5 , 8 , 12 ) ; echo ( next0 ( $ arr , 8 ) ) ; }
function printNSE ( $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ next = -1 ; for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) { if ( $ arr [ $ i ] > $ arr [ $ j ] ) { $ next = $ arr [ $ j ] ; break ; } } echo $ arr [ $ i ] . " -- " . ▁ $ next . " " } }
function deleteElement ( & $ A , $ L , $ R , $ N ) { $ i = 0 ; $ j = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { if ( $ i <= $ L $ i >= $ R ) { $ A [ $ j ] = $ A [ $ i ] ; $ j ++ ; } } return $ j ; } $ A = array ( 5 , 8 , 11 , 15 , 26 , 14 , 19 , 17 , 10 , 14 ) ; $ L = 2 ; $ R = 7 ; $ n = sizeof ( $ A ) ; $ res_size = deleteElement ( $ A , $ L , $ R , $ n ) ; for ( $ i = 0 ; $ i < $ res_size ; $ i ++ ) { echo ( $ A [ $ i ] ) ; echo ( " ▁ " ) ; }
function search ( $ arr , $ n , $ x ) { $ res = -1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ x == $ arr [ $ i ] ) $ res = $ i ; if ( $ res == -1 ) return false ; $ temp = $ arr [ $ res ] ; for ( $ i = $ res ; $ i > 0 ; $ i -- ) $ arr [ $ i ] = $ arr [ $ i - 1 ] ; $ arr [ 0 ] = $ temp ; return true ; }
function kPresentProbability ( & $ a , $ n , $ k ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ a [ $ i ] == $ k ) $ count ++ ; return $ count / $ n ; }
function slopeOfNum ( $ num , $ n ) { $ slope = 0 ; for ( $ i = 1 ; $ i < $ n - 1 ; $ i ++ ) { if ( $ num [ $ i ] > $ num [ $ i - 1 ] && $ num [ $ i ] > $ num [ $ i + 1 ] ) $ slope ++ ; else if ( $ num [ $ i ] < $ num [ $ i - 1 ] && $ num [ $ i ] < $ num [ $ i + 1 ] ) $ slope ++ ; } return $ slope ; }
function prevGreater ( & $ arr , $ n ) { echo ( " - 1 , ▁ " ) ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { for ( $ j = $ i - 1 ; $ j >= 0 ; $ j -- ) { if ( $ arr [ $ i ] < $ arr [ $ j ] ) { echo ( $ arr [ $ j ] ) ; echo ( " , ▁ " ) ; break ; } } if ( $ j == -1 ) echo ( " - 1 , ▁ " ) ; } }
function printDuplicates ( $ arr , $ n ) { $ i ; $ fl = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ arr [ $ i ] % $ n ] >= $ n ) { if ( $ arr [ $ arr [ $ i ] % $ n ] < 2 * $ n ) { echo $ arr [ $ i ] % $ n . " " ; $ fl = 1 ; } } $ arr [ $ arr [ $ i ] % $ n ] += $ n ; } if ( ! $ fl ) echo " - 1" ; }
function findTriplets ( $ arr , $ n , $ sum ) { for ( $ i = 0 ; $ i < $ n - 2 ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ n - 1 ; $ j ++ ) { for ( $ k = $ j + 1 ; $ k < $ n ; $ k ++ ) { if ( $ arr [ $ i ] + $ arr [ $ j ] + $ arr [ $ k ] == $ sum ) { echo $ arr [ $ i ] , " " , $ arr [ $ j ] , " " , $ arr [ $ k ] , " " ; } } } } }
function printPairs ( $ arr , $ n , $ sum ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) if ( $ arr [ $ i ] + $ arr [ $ j ] == $ sum ) echo " ( " , $ arr [ $ i ] , " , ▁ " , $ arr [ $ j ] , " ) " , " STRNEWLINE " ; }
function solve ( $ a , $ n ) { $ max1 = PHP_INT_MIN ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( abs ( $ a [ $ i ] - $ a [ $ j ] ) > $ max1 ) { $ max1 = abs ( $ a [ $ i ] - $ a [ $ j ] ) ; } } } return $ max1 ; }
function solve ( $ a , $ n ) { $ min1 = $ a [ 0 ] ; $ max1 = $ a [ 0 ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] > $ max1 ) $ max1 = $ a [ $ i ] ; if ( $ a [ $ i ] < $ min1 ) $ min1 = $ a [ $ i ] ; } return abs ( $ min1 - $ max1 ) ; }
function maxProduct ( $ arr , $ n ) { if ( $ n < 4 ) return -1 ; $ max_product = PHP_INT_MIN ; for ( $ i = 0 ; $ i < $ n - 3 ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n - 2 ; $ j ++ ) for ( $ k = $ j + 1 ; $ k < $ n - 1 ; $ k ++ ) for ( $ l = $ k + 1 ; $ l < $ n ; $ l ++ ) $ max_product = max ( $ max_product , $ arr [ $ i ] * $ arr [ $ j ] * $ arr [ $ k ] * $ arr [ $ l ] ) ; return $ max_product ; }
function maxProduct ( $ arr , $ n ) { if ( $ n < 4 ) return -1 ; sort ( $ arr ) ; $ x = $ arr [ $ n - 1 ] * $ arr [ $ n - 2 ] * $ arr [ $ n - 3 ] * $ arr [ $ n - 4 ] ; $ y = $ arr [ 0 ] * $ arr [ 1 ] * $ arr [ 2 ] * $ arr [ 3 ] ; $ z = $ arr [ 0 ] * $ arr [ 1 ] * $ arr [ $ n - 1 ] * $ arr [ $ n - 2 ] ; return max ( $ x , max ( $ y , $ z ) ) ; }
function maxSum ( $ arr , $ n ) { if ( $ n < 2 ) return -1 ; $ ans = $ arr [ 0 ] + $ arr [ 1 ] ; for ( $ i = 1 ; $ i + 1 < $ n ; $ i ++ ) $ ans = min ( $ ans , ( $ arr [ $ i ] + $ arr [ $ i + 1 ] ) ) ; return $ ans ; }
function countTripletsLessThanL ( $ n , $ L , $ arr ) { sort ( $ arr ) ; $ ways = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) { for ( $ k = $ j + 1 ; $ k < $ n ; $ k ++ ) { $ mostDistantDistance = $ arr [ $ k ] - $ arr [ $ i ] ; if ( $ mostDistantDistance <= $ L ) { $ ways ++ ; } } } } return $ ways ; }
function isSuffix ( $ s1 , $ s2 ) { $ n1 = ( $ s1 ) ; $ n2 = strlen ( $ s2 ) ; if ( $ n1 > $ n2 ) return false ; for ( $ i = 0 ; $ i < $ n1 ; $ i ++ ) if ( $ s1 [ $ n1 - $ i - 1 ] != $ s2 [ $ n2 - $ i - 1 ] ) return false ; return true ; }
function search ( $ arr , $ n , $ x ) { $ front = 0 ; $ back = $ n - 1 ; while ( $ front <= $ back ) { if ( $ arr [ $ front ] == $ x $ arr [ $ back ] == $ x ) return true ; $ front ++ ; $ back -- ; } return false ; }
function getGreatestSum ( $ a ) { global $ N ; $ prev_max = 0 ; for ( $ j = 0 ; $ j < $ N ; $ j ++ ) if ( $ prev_max < $ a [ $ N - 1 ] [ $ j ] ) $ prev_max = $ a [ $ N - 1 ] [ $ j ] ; $ sum = $ prev_max ; for ( $ i = $ N - 2 ; $ i >= 0 ; $ i -- ) { $ curr_max = PHP_INT_MIN ; for ( $ j = 0 ; $ j < $ N ; $ j ++ ) if ( $ prev_max > $ a [ $ i ] [ $ j ] and $ a [ $ i ] [ $ j ] > $ curr_max ) $ curr_max = $ a [ $ i ] [ $ j ] ; if ( $ curr_max == PHP_INT_MIN ) return -1 ; $ prev_max = $ curr_max ; $ sum += $ prev_max ; } return $ sum ; }
function minSum ( $ arr , $ n ) { $ sum = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] == $ arr [ $ i - 1 ] ) { $ j = $ i ; while ( $ j < $ n && $ arr [ $ j ] <= $ arr [ $ j - 1 ] ) { $ arr [ $ j ] = $ arr [ $ j ] + 1 ; $ j ++ ; } } $ sum = $ sum + $ arr [ $ i ] ; } return $ sum ; }
function minSum ( $ arr , $ n ) { $ sum = $ arr [ 0 ] ; $ prev = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] <= $ prev ) { $ prev = $ prev + 1 ; $ sum = $ sum + $ prev ; } else { $ sum = $ sum + $ arr [ $ i ] ; $ prev = $ arr [ $ i ] ; } } return $ sum ; }
function findLastIndex ( $ str , $ x ) { $ index = -1 ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) if ( $ str [ $ i ] == $ x ) $ index = $ i ; return $ index ; }
function findLastIndex ( $ str , $ x ) { for ( $ i = strlen ( $ str ) - 1 ; $ i >= 0 ; $ i -- ) if ( $ str [ $ i ] == $ x ) return $ i ; return -1 ; }
function middleOfThree ( $ a , $ b , $ c ) { if ( ( $ a < $ b && $ b < $ c ) or ( $ c < $ b && $ b < $ a ) ) return $ b ; else if ( ( $ b < $ a and $ a < $ c ) or ( $ c < $ a and $ a < $ b ) ) return $ a ; else return $ c ; }
function middleOfThree ( $ a , $ b , $ c ) { if ( $ a > $ b ) { if ( $ b > $ c ) return $ b ; else if ( $ a > $ c ) return $ c ; else return $ a ; } else { if ( $ a > $ c ) return $ a ; else if ( $ b > $ c ) return $ c ; else return $ b ; } }
function middleOfThree ( $ a , $ b , $ c ) { $ x = $ a - $ b ; $ y = $ b - $ c ; $ z = $ a - $ c ; if ( $ x * $ y > 0 ) return $ b ; else if ( $ x * $ z > 0 ) return $ c ; else return $ a ; }
function findValue ( $ X , $ Y , $ P ) { if ( $ P % 2 == 0 ) return ( int ) ( max ( $ X , $ Y ) / min ( $ X , $ Y ) ) ; else return ( int ) ( max ( 2 * $ X , $ Y ) / min ( 2 * $ X , $ Y ) ) ; }
function countCountries ( $ ans , $ N ) { $ total_countries = 0 ; $ i = 0 ; $ invalid = false ; while ( $ i < $ N ) { $ curr_size = $ ans [ $ i ] ; $ num = $ ans [ $ i ] ; while ( $ num > 0 ) { if ( $ ans [ $ i ] != $ curr_size ) { echo " Invalid ▁ Answer STRNEWLINE " ; return ; } else $ num -- ; $ i ++ ; } $ total_countries ++ ; } echo " There ▁ are ▁ " , $ total_countries , " ▁ distinct ▁ companies ▁ in ▁ the ▁ group . STRNEWLINE " ; }
function countMaxSetBits ( $ left , $ right ) { while ( ( $ left | ( $ left + 1 ) ) <= $ right ) $ left |= $ left + 1 ; return $ left ; }
function findS ( $ s ) { $ sum = 0 ; for ( $ n = 1 ; $ sum < $ s ; $ n ++ ) { $ sum += $ n ; if ( $ sum == $ s ) return $ n ; } return -1 ; }
function findS ( $ s ) { $ l = 1 ; $ r = 1 + ( int ) $ s / 2 ; while ( $ l <= $ r ) { $ mid = ( int ) ( ( $ l + $ r ) / 2 ) ; $ sum = ( int ) ( $ mid * ( $ mid + 1 ) / 2 ) ; if ( $ sum == $ s ) return $ mid ; else if ( $ sum > $ s ) $ r = $ mid - 1 ; else $ l = $ mid + 1 ; } return -1 ; }
function calcSafe ( $ pos ) { $ j = $ pos % 10 ; $ i = $ pos / 10 ; $ dis_11 = min ( abs ( 1 - $ i ) , abs ( 1 - $ j ) ) ; $ dis_18 = min ( abs ( 1 - $ i ) , abs ( 8 - $ j ) ) ; $ dis_81 = min ( abs ( 8 - $ i ) , abs ( 1 - $ j ) ) ; $ dis_88 = min ( abs ( 8 - $ i ) , abs ( 8 - $ j ) ) ; $ sum = $ dis_11 + $ dis_18 + $ dis_81 + $ dis_88 + 1 ; return ceil ( 64 - $ sum ) ; }
function countCrossLine ( $ arr , $ n ) { $ count_crossline = 0 ; $ i ; $ key ; $ j ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ key = $ arr [ $ i ] ; $ j = $ i - 1 ; while ( $ j >= 0 and $ arr [ $ j ] > $ key ) { $ arr [ $ j + 1 ] = $ arr [ $ j ] ; $ j = $ j - 1 ; $ count_crossline ++ ; } $ arr [ $ j + 1 ] = $ key ; } return $ count_crossline ; }
function missing4 ( $ arr , $ n ) { $ helper = array ( 0 , 0 , 0 , 0 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ temp = abs ( $ arr [ $ i ] ) ; if ( $ temp <= $ n ) $ arr [ $ temp - 1 ] = $ arr [ $ temp - 1 ] * ( -1 ) ; else if ( $ temp > $ n ) { if ( $ temp % $ n != 0 ) $ helper [ $ temp % $ n - 1 ] = -1 ; else $ helper [ ( $ temp % $ n ) + $ n - 1 ] = -1 ; } } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] > 0 ) { $ a = $ i + 1 ; echo " $ a " , " ▁ " ; } for ( $ i = 0 ; $ i < 4 ; $ i ++ ) if ( $ helper [ $ i ] >= 0 ) { $ b = $ n + $ i + 1 ; echo " $ b " , " ▁ " ; } echo " STRNEWLINE " ; return ; }
function getCount ( $ arr , $ n , $ num1 , $ num2 ) { $ i = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] == $ num1 ) break ; if ( $ i >= $ n - 1 ) return 0 ; $ j ; for ( $ j = $ n - 1 ; $ j >= $ i + 1 ; $ j -- ) if ( $ arr [ $ j ] == $ num2 ) break ; if ( $ j == $ i ) return 0 ; return ( $ j - $ i - 1 ) ; }
function findMinRec ( $ A , $ n ) { if ( $ n == 1 ) return $ A [ 0 ] ; return min ( $ A [ $ n - 1 ] , findMinRec ( $ A , $ n - 1 ) ) ; }
function findMaxRec ( $ A , $ n ) { if ( $ n == 1 ) return $ A [ 0 ] ; return max ( $ A [ $ n - 1 ] , findMaxRec ( $ A , $ n - 1 ) ) ; }
function countBuildings ( $ arr , $ n ) { $ count = 1 ; $ curr_max = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] > $ curr_max $ arr [ $ i ] == $ curr_max ) { $ count ++ ; $ curr_max = $ arr [ $ i ] ; } } return $ count ; }
function findExtra ( $ arr1 , $ arr2 , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr1 [ $ i ] != $ arr2 [ $ i ] ) return $ i ; return $ n ; }
function findExtra ( $ arr1 , $ arr2 , $ n ) { $ index = $ n ; $ left = 0 ; $ right = $ n - 1 ; while ( $ left <= $ right ) { $ mid = ( $ left + $ right ) / 2 ; if ( $ arr2 [ $ mid ] == $ arr1 [ $ mid ] ) $ left = $ mid + 1 ; else { $ index = $ mid ; $ right = $ mid - 1 ; } } return $ index ; } { $ arr1 = array ( 2 , 4 , 6 , 8 , 10 , 12 , 13 ) ; $ arr2 = array ( 2 , 4 , 6 , 8 , 10 , 12 ) ; $ n = sizeof ( $ arr2 ) / sizeof ( $ arr2 [ 0 ] ) ; echo findExtra ( $ arr1 , $ arr2 , $ n ) ; return 0 ; }
function Next_greater ( $ a , $ n , $ x ) { sort ( $ a ) ; $ low = 0 ; $ high = $ n - 1 ; $ ans = $ x + 1 ; while ( $ low <= $ high ) { $ mid = ( $ low + $ high ) / 2 ; if ( $ a [ $ mid ] <= $ ans ) { if ( $ a [ $ mid ] == $ ans ) { $ ans ++ ; $ high = $ n - 1 ; } $ low = $ mid + 1 ; } else $ high = $ mid - 1 ; } return $ ans ; }
function reArrange ( $ words , $ n ) { $ freq = array ( ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ freq [ $ words [ $ i ] ] = ( $ i + 1 ) ; } sort ( $ words ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ freq [ $ words [ $ i ] ] , " ▁ " ; }
function getMaxMedian ( $ arr , $ n , $ k ) { $ size = $ n + $ k ; sort ( $ arr , $ n ) ; if ( $ size % 2 == 0 ) { $ median = ( float ) ( $ arr [ ( $ size / 2 ) - 1 ] + $ arr [ $ size / 2 ] ) / 2 ; return $ median ; } $ median = $ arr [ $ size / 2 ] ; return $ median ; }
function countPoints ( $ n , $ m , $ a , $ b , $ x , $ y ) { sort ( $ a ) ; sort ( $ b ) ; $ j = 0 ; $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { while ( $ j < $ m ) { if ( $ a [ $ i ] + $ y < $ b [ $ j ] ) break ; if ( $ b [ $ j ] >= $ a [ $ i ] - $ x && $ b [ $ j ] <= $ a [ $ i ] + $ y ) { $ count ++ ; $ j ++ ; break ; } else $ j ++ ; } } return $ count ; }
function findAnswer ( $ n , $ arr ) { sort ( $ arr ) ; $ sum = 0 ; for ( $ i = 0 ; $ i < $ n / 2 ; ++ $ i ) { $ sum += ( $ arr [ $ i ] + $ arr [ $ n - $ i - 1 ] ) * ( $ arr [ $ i ] + $ arr [ $ n - $ i - 1 ] ) ; } return $ sum ; }
function odd_even ( $ n ) { $ odd_indexes = array ( ) ; $ even_indexes = array ( ) ; for ( $ i = 0 ; $ i < sizeof ( $ n ) ; $ i ++ ) { if ( $ i % 2 == 0 ) array_push ( $ odd_indexes , $ n [ $ i ] ) ; else array_push ( $ even_indexes , $ n [ $ i ] ) ; } sort ( $ odd_indexes ) ; for ( $ i = 0 ; $ i < sizeof ( $ odd_indexes ) ; $ i ++ ) echo $ odd_indexes [ $ i ] , " ▁ " ; sort ( $ even_indexes ) ; for ( $ i = 0 ; $ i < sizeof ( $ even_indexes ) ; $ i ++ ) echo $ even_indexes [ $ i ] , " ▁ " ; }
function AlternateRearrange ( $ arr , $ n ) { sort ( $ arr ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] % 2 == 0 ) array_push ( $ v1 , $ arr [ $ i ] ) ; else array_push ( $ v2 , $ arr [ $ i ] ) ; $ index = 0 ; $ i = 0 ; $ j = 0 ; $ flag = false ; if ( $ arr [ 0 ] % 2 == 0 ) $ flag = true ; while ( $ index < $ n ) { if ( $ flag == true ) { $ arr [ $ index ++ ] = $ v1 [ $ i ++ ] ; $ flag = ! $ flag ; } else { $ arr [ $ index ++ ] = $ v2 [ $ j ++ ] ; $ flag = ! $ flag ; } } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ arr [ $ i ] , " ▁ " ; }
function countDistinct ( & $ arr , $ n ) { $ res = 1 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ i ; $ j ++ ) if ( $ arr [ $ i ] == $ arr [ $ j ] ) break ; if ( $ i == $ j ) $ res ++ ; } return $ res ; }
function countDistinct ( $ arr , $ n ) { sort ( $ arr , 0 ) ; $ res = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { while ( $ i < $ n - 1 && $ arr [ $ i ] == $ arr [ $ i + 1 ] ) $ i ++ ; $ res ++ ; } return $ res ; }
function countDistinct ( $ arr , $ n ) { $ s = array ( ) ; $ res = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { array_push ( $ s , $ arr [ $ i ] ) ; } $ s = array_unique ( $ s ) ; return count ( $ s ) ; }
function getNumToAdd ( $ arr , $ n ) { sort ( $ arr ) ; $ d = $ arr [ 1 ] - $ arr [ 0 ] ; $ numToAdd = -1 ; $ numAdded = false ; for ( $ i = 2 ; $ i < $ n ; $ i ++ ) { $ diff = $ arr [ $ i ] - $ arr [ $ i - 1 ] ; if ( $ diff != $ d ) { if ( $ numAdded ) return -1 ; if ( $ diff == 2 * $ d ) { $ numToAdd = $ arr [ $ i ] - $ d ; $ numAdded = true ; } else return -1 ; } } if ( $ numToAdd == -1 ) return ( $ arr [ $ n - 1 ] + $ d ) ; return $ numToAdd ; }
function countSequences ( $ arr , $ n ) { $ count = 1 ; sort ( $ arr ) ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) if ( $ arr [ $ i ] + 1 != $ arr [ $ i + 1 ] ) $ count ++ ; return $ count ; }
function average ( $ arr , $ n , $ k ) { $ total = 0 ; if ( 2 * $ k >= $ n ) return 0 ; sort ( $ arr ) ; $ start = $ k ; $ end = $ n - $ k - 1 ; for ( $ i = $ start ; $ i <= $ end ; $ i ++ ) $ total += $ arr [ $ i ] ; return ( $ total / ( $ n - 2 * $ k ) ) ; }
function minMovesToSort ( $ arr , $ n ) { $ moves = 0 ; $ mn = $ arr [ $ n - 1 ] ; for ( $ i = $ n - 2 ; $ i >= 0 ; $ i -- ) { if ( $ arr [ $ i ] > $ mn ) $ moves += $ arr [ $ i ] - $ mn ; } return $ moves ; }
function PointInKSquares ( $ n , $ a , $ k ) { sort ( $ a ) ; return $ a [ $ n - $ k ] ; }
function minimumMoves ( $ a , $ n ) { $ operations = 0 ; sort ( $ a ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ operations += abs ( $ a [ $ i ] - ( $ i + 1 ) ) ; return $ operations ; }
function printCase ( $ n ) { if ( $ n <= 2 ) { echo ( -1 ) ; return ; } for ( $ i = $ n ; $ i >= 1 ; $ i -- ) { echo ( $ i ) ; echo ( " ▁ " ) ; } }
function minCost ( $ A , $ n ) { $ cost = 0 ; sort ( $ A ) ; $ K = $ A [ $ n / 2 ] ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) $ cost += abs ( $ A [ $ i ] - $ K ) ; if ( $ n % 2 == 0 ) { $ tempCost = 0 ; $ K = $ A [ ( $ n / 2 ) - 1 ] ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) $ tempCost += abs ( $ A [ $ i ] - $ K ) ; $ cost = min ( $ cost , $ tempCost ) ; } return $ cost ; }
function items ( $ n , $ a ) { sort ( $ a ) ; $ z = $ a [ $ n - 1 ] ; $ x = 1 ; $ s = 0 ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { $ s += $ a [ $ i ] ; if ( $ s <= $ z ) $ x += 1 ; else break ; } return $ x ; }
function SubseqWidths ( & $ A , $ n ) { global $ MOD ; sort ( $ A ) ; $ pow2 = array_fill ( 0 , $ n , NULL ) ; $ pow2 [ 0 ] = 1 ; for ( $ i = 1 ; $ i < $ n ; ++ $ i ) $ pow2 [ $ i ] = ( $ pow2 [ $ i - 1 ] * 2 ) % $ MOD ; $ ans = 0 ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) $ ans = ( $ ans + ( $ pow2 [ $ i ] - $ pow2 [ $ n - 1 - $ i ] ) * $ A [ $ i ] ) % $ MOD ; return $ ans ; }
function findOptimalSolution ( $ a , $ N ) { sort ( $ a ) ; $ points = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { $ points += $ a [ $ i ] * $ i ; } return $ points ; }
function numBoxes ( $ A , $ n , $ K ) { sort ( $ A ) ; $ i = 0 ; $ j = $ n - 1 ; $ ans = 0 ; while ( $ i <= $ j ) { $ ans ++ ; if ( $ A [ $ i ] + $ A [ $ j ] <= $ K ) $ i ++ ; $ j -- ; } return $ ans ; }
function printArray ( $ arr , $ n ) { sort ( $ arr ) ; $ l = 0 ; $ r = $ n - 1 ; $ flag = 0 ; $ k = 2 ; while ( $ l <= $ r ) { if ( $ flag == 0 ) { for ( $ i = $ l ; $ i < $ l + $ k && $ i <= $ r ; $ i ++ ) echo $ arr [ $ i ] , " ▁ " ; $ flag = 1 ; $ l = $ i ; } { for ( $ i = $ r ; $ i > $ r - $ k && $ i >= $ l ; $ i -- ) echo $ arr [ $ i ] , " ▁ " ; $ flag = 0 ; $ r = $ i ; } $ k ++ ; } }
function number_of_tower ( $ house , $ range , $ n ) { sort ( $ house ) ; $ numOfTower = 0 ; $ i = 0 ; while ( $ i < $ n ) { $ numOfTower ++ ; $ loc = $ house [ $ i ] + $ range ; while ( $ i < $ n && $ house [ $ i ] <= $ loc ) $ i ++ ; -- $ i ; $ loc = $ house [ $ i ] + $ range ; while ( $ i < $ n && $ house [ $ i ] <= $ loc ) $ i ++ ; } return $ numOfTower ; }
function isAlphabaticOrder ( $ s ) { $ n = strlen ( $ s ) ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( $ s [ $ i ] < $ s [ $ i - 1 ] ) return false ; } return true ; }
function rotateRec ( $ n , $ L , $ B ) { $ m = PHP_INT_MAX ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( max ( $ L [ $ i ] , $ B [ $ i ] ) <= $ m ) $ m = max ( $ L [ $ i ] , $ B [ $ i ] ) ; else if ( min ( $ L [ $ i ] , $ B [ $ i ] ) <= $ m ) $ m = min ( $ L [ $ i ] , $ B [ $ i ] ) ; else { return 0 ; } } return 1 ; }
function minimumIncrease ( $ a , $ b , $ c ) { $ arr = array ( $ a , $ b , $ c ) ; sort ( $ arr ) ; if ( $ arr [ 0 ] + $ arr [ 1 ] >= $ arr [ 2 ] ) return 0 ; else return $ arr [ 2 ] - ( $ arr [ 0 ] + $ arr [ 1 ] ) ; }
function absSumDidd ( $ a , $ n ) { sort ( $ a ) ; $ midValue = $ a [ ( $ n / 2 ) ] ; $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sum = $ sum + abs ( $ a [ $ i ] - $ midValue ) ; } return $ sum ; }
function minDistance ( $ n , $ k , & $ point ) { for ( $ i = 0 ; $ i < $ k ; ++ $ i ) sort ( $ point [ $ i ] ) ; for ( $ i = 0 ; $ i < $ k ; ++ $ i ) echo $ point [ $ i ] [ ( ceil ( ( double ) $ n / 2 ) - 1 ) ] . " ▁ " ; }
function solve ( $ N , $ M , & $ cp , & $ sp ) { $ profit = array_fill ( 0 , $ N , NULL ) ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) $ profit [ $ i ] = $ sp [ $ i ] - $ cp [ $ i ] ; rsort ( $ profit ) ; $ sum = 0 ; for ( $ i = 0 ; $ i < $ M ; $ i ++ ) { if ( $ profit [ $ i ] > 0 ) $ sum += $ profit [ $ i ] ; else break ; } return $ sum ; }
function printOrder ( $ arr , $ n , $ k ) { $ a = array_slice ( $ arr , 0 , $ k ) ; sort ( $ a ) ; $ b = array_slice ( $ arr , $ k , $ n ) ; sort ( $ b ) ; $ b = array_reverse ( $ b ) ; unset ( $ arr ) ; $ arr = $ a ; return array_merge ( $ arr , $ b ) ; }
function countTriplets ( $ arr , $ n , $ m ) { $ count = 0 ; sort ( $ arr ) ; $ end ; $ start ; $ mid ; for ( $ end = $ n - 1 ; $ end >= 2 ; $ end -- ) { $ start = 0 ; $ mid = $ end - 1 ; while ( $ start < $ mid ) { $ prod = $ arr [ $ end ] * $ arr [ $ start ] * $ arr [ $ mid ] ; if ( $ prod > $ m ) $ mid -- ; else if ( $ prod < $ m ) $ start ++ ; else if ( $ prod == $ m ) { $ count ++ ; $ mid -- ; $ start ++ ; } } } return $ count ; }
function findMaxNum ( & $ arr , $ n ) { rsort ( $ arr ) ; $ num = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ num = $ num * 10 + $ arr [ $ i ] ; } return $ num ; }
function minimumSets ( $ arr , $ n , $ key ) { $ i ; $ j ; sort ( $ arr ) ; for ( $ i = 0 , $ j = $ n - 1 ; $ i <= $ j ; ++ $ i ) if ( $ arr [ $ i ] + $ arr [ $ j ] <= $ key ) $ j -- ; return $ i ; }
function distribution ( $ arr , $ n ) { sort ( $ arr ) ; $ count = 1 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] > $ arr [ $ i - 1 ] ) $ count ++ ; return min ( $ count , $ n / 2 ) ; }
function printTriplets ( & $ arr , $ n , $ sum ) { for ( $ i = 0 ; $ i < $ n - 2 ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ n - 1 ; $ j ++ ) { for ( $ k = $ j + 1 ; $ k < $ n ; $ k ++ ) if ( $ arr [ $ i ] + $ arr [ $ j ] + $ arr [ $ k ] < $ sum ) { echo ( $ arr [ $ i ] ) ; echo ( " , ▁ " ) ; echo ( $ arr [ $ j ] ) ; echo ( " , ▁ " ) ; echo ( $ arr [ $ k ] ) ; echo ( " STRNEWLINE " ) ; } } } }
function printTriplets ( $ arr , $ n , $ sum ) { sort ( $ arr , 0 ) ; for ( $ i = 0 ; $ i < $ n - 2 ; $ i ++ ) { $ j = $ i + 1 ; $ k = $ n - 1 ; while ( $ j < $ k ) { if ( $ arr [ $ i ] + $ arr [ $ j ] + $ arr [ $ k ] >= $ sum ) $ k -- ; else { for ( $ x = $ j + 1 ; $ x <= $ k ; $ x ++ ) echo $ arr [ $ i ] . " , " ▁ . ▁ $ arr [ $ j ] ▁ . STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL " , " ▁ . ▁ $ arr [ $ x ] ▁ . ▁ " " $ j ++ ; } } } }
function countTriplets ( $ arr , $ n , $ a , $ b ) { $ ans = 0 ; for ( $ i = 0 ; $ i < $ n - 2 ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ n - 1 ; $ j ++ ) { for ( $ k = $ j + 1 ; $ k < $ n ; $ k ++ ) if ( $ arr [ $ i ] + $ arr [ $ j ] + $ arr [ $ k ] >= $ a && $ arr [ $ i ] + $ arr [ $ j ] + $ arr [ $ k ] <= $ b ) $ ans ++ ; } } return $ ans ; }
function checkFittingArrays ( $ A , $ B , $ N ) { sort ( $ A ) ; sort ( $ B ) ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) if ( $ A [ $ i ] > $ B [ $ i ] ) return false ; return true ; }
function maximum_toys ( $ cost , $ N , $ K ) { $ count = 0 ; $ sum = 0 ; sort ( $ cost ) ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { if ( $ sum + $ cost [ $ i ] <= $ K ) { $ sum = $ sum + $ cost [ $ i ] ; $ count ++ ; } } return $ count ; }
function findOptimalPairs ( $ arr , $ N ) { sort ( $ arr ) ; for ( $ i = 0 , $ j = $ N - 1 ; $ i <= $ j ; $ i ++ , $ j -- ) echo " ( " , $ arr [ $ i ] , " , ▁ " , $ arr [ $ j ] , " ) " , " ▁ " ; }
function minElements ( $ arr , $ n ) { $ halfSum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ halfSum = $ halfSum + $ arr [ $ i ] ; $ halfSum = $ halfSum / 2 ; rsort ( $ arr ) ; $ res = 0 ; $ curr_sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ curr_sum += $ arr [ $ i ] ; $ res ++ ; if ( $ curr_sum > $ halfSum ) return $ res ; } return $ res ; }
function distancesum ( $ x , $ y , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) $ sum += ( abs ( $ x [ $ i ] - $ x [ $ j ] ) + abs ( $ y [ $ i ] - $ y [ $ j ] ) ) ; return $ sum ; }
function minimumBox ( $ arr , $ n ) { $ q = array ( ) ; sort ( $ arr ) ; array_push ( $ q , $ arr [ 0 ] ) ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ now = $ q [ 0 ] ; if ( $ arr [ $ i ] >= 2 * $ now ) array_pop ( $ q ) ; array_push ( $ q , $ arr [ $ i ] ) ; } return count ( $ q ) ; }
function printMedian ( $ arr , $ n , $ K ) { sort ( $ arr ) ; echo $ arr [ ( $ n + $ K ) / 2 ] ; }
function sortBinaryArray ( $ a , $ n ) { $ j = -1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] < 1 ) { $ j ++ ; $ temp = $ a [ $ j ] ; $ a [ $ j ] = $ a [ $ i ] ; $ a [ $ i ] = $ temp ; } } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ a [ $ i ] . " ▁ " ; }
function almostSort ( $ A , $ n ) { for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { if ( $ A [ $ i ] > $ A [ $ i + 1 ] ) { list ( $ A [ $ i ] , $ A [ $ i + 1 ] ) = array ( $ A [ $ i + 1 ] , $ A [ $ i ] ) ; $ i ++ ; } } for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) if ( $ A [ $ i ] > $ A [ $ i + 1 ] ) return false ; return true ; }
function findDuplicate ( $ arr , $ n , $ k ) { sort ( $ arr ) ; $ i = 0 ; while ( $ i < $ n ) { $ j ; $ count = 1 ; for ( $ j = $ i + 1 ; $ j < $ n && $ arr [ $ j ] == $ arr [ $ i ] ; $ j ++ ) $ count ++ ; if ( $ count == $ k ) return $ arr [ $ i ] ; $ i = $ j ; } return -1 ; }
function checkForSorting ( $ arr , $ n ) { $ temp = 0 ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { if ( $ arr [ $ i ] > $ arr [ $ i + 1 ] ) { if ( $ arr [ $ i ] - $ arr [ $ i + 1 ] == 1 ) { $ temp = $ arr [ $ i ] ; $ arr [ $ i ] = $ arr [ $ i + 1 ] ; $ arr [ $ i + 1 ] = $ temp ; } else return false ; } } return true ; }
function pendulumArrangement ( $ arr , $ n ) { sort ( $ arr , $ n ) ; sort ( $ arr ) ; $ op [ $ n ] = NULL ; $ mid = floor ( ( $ n - 1 ) / 2 ) ; $ j = 1 ; $ i = 1 ; $ op [ $ mid ] = $ arr [ 0 ] ; for ( $ i = 1 ; $ i <= $ mid ; $ i ++ ) { $ op [ $ mid + $ i ] = $ arr [ $ j ++ ] ; $ op [ $ mid - $ i ] = $ arr [ $ j ++ ] ; } if ( $ n % 2 == 0 ) $ op [ $ mid + $ i ] = $ arr [ $ j ] ; echo " Pendulum ▁ arrangement : " ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ op [ $ i ] , " ▁ " ; echo " STRNEWLINE " ; }
function maxLevel ( $ boxes , $ n ) { sort ( $ boxes ) ; $ ans = 1 ; $ prev_width = $ boxes [ 0 ] ; $ prev_count = 1 ; $ curr_count = 0 ; $ curr_width = 0 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ curr_width += $ boxes [ $ i ] ; $ curr_count += 1 ; if ( $ curr_width > $ prev_width and $ curr_count > $ prev_count ) { $ prev_width = $ curr_width ; $ prev_count = $ curr_count ; $ curr_count = 0 ; $ curr_width = 0 ; $ ans ++ ; } } return $ ans ; }
function minDifferenceAmongMaxMin ( $ arr , $ N , $ K ) { $ INT_MAX = 2 ; sort ( $ arr ) ; sort ( $ arr , $ N ) ; $ res = $ INT_MAX ; for ( $ i = 0 ; $ i <= ( $ N - $ K ) ; $ i ++ ) { $ curSeqDiff = $ arr [ $ i + $ K - 1 ] - $ arr [ $ i ] ; $ res = min ( $ res , $ curSeqDiff ) ; } return $ res ; }
function printSorted ( $ a , $ b , $ c ) { $ get_max = max ( $ a , max ( $ b , $ c ) ) ; $ get_min = - max ( - $ a , max ( - $ b , - $ c ) ) ; $ get_mid = ( $ a + $ b + $ c ) - ( $ get_max + $ get_min ) ; echo $ get_min , " " ▁ , ▁ $ get _ mid , ▁ " " }
function twoWaySort ( & $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ arr [ $ i ] *= -1 ; sort ( $ arr ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] & 1 ) $ arr [ $ i ] *= -1 ; }
function ksmallest ( $ arr , $ n , $ k ) { sort ( $ arr ) ; if ( $ k < $ arr [ 0 ] ) return $ k ; if ( $ k == $ arr [ 0 ] ) return $ arr [ 0 ] + 1 ; if ( $ k > $ arr [ $ n - 1 ] ) return $ k + $ n ; if ( $ arr [ 0 ] == 1 ) $ k -- ; else $ k -= ( $ arr [ 0 ] - 1 ) ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ c = $ arr [ $ i ] - $ arr [ $ i - 1 ] - 1 ; if ( $ k <= $ c ) return $ arr [ $ i - 1 ] + $ k ; else $ k -= $ c ; } return $ arr [ $ n - 1 ] + $ k ; }
function mergeTwoHalf ( & $ A , $ n ) { sort ( $ A , 0 ) ; }
function minDiff ( $ arr , $ n , $ k ) { $ INT_MAX = 2147483647 ; $ result = $ INT_MAX ; sort ( $ arr , $ n ) ; sort ( $ arr ) ; for ( $ i = 0 ; $ i <= $ n - $ k ; $ i ++ ) $ result = min ( $ result , $ arr [ $ i + $ k - 1 ] - $ arr [ $ i ] ) ; return $ result ; }
function isPossible ( $ a , $ b , $ n , $ k ) { sort ( $ a ) ; rsort ( $ b ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ a [ $ i ] + $ b [ $ i ] < $ k ) return false ; return true ; }
function findMinDiff ( $ arr , $ n , $ m ) { if ( $ m == 0 $ n == 0 ) return 0 ; sort ( $ arr ) ; if ( $ n < $ m ) return -1 ; $ min_diff = PHP_INT_MAX ; for ( $ i = 0 ; $ i + $ m - 1 < $ n ; $ i ++ ) { $ diff = $ arr [ $ i + $ m - 1 ] - $ arr [ $ i ] ; if ( $ diff < $ min_diff ) $ min_diff = $ diff ; } return $ min_diff ; }
function getIndexInSortedArray ( $ arr , $ n , $ idx ) { $ result = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] < $ arr [ $ idx ] ) $ result ++ ; if ( $ arr [ $ i ] == $ arr [ $ idx ] and $ i < $ idx ) $ result ++ ; } return $ result ; }
function minValue ( $ A , $ B , $ n ) { sort ( $ A ) ; sort ( $ A , $ n ) ; sort ( $ B ) ; sort ( $ B , $ n ) ; $ result = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ result += ( $ A [ $ i ] * $ B [ $ n - $ i - 1 ] ) ; return $ result ; }
function isEven ( $ n ) { return ( $ n % 2 == 0 ) ; }
function isEven ( $ n ) { return ( ! ( n & 1 ) ) ; }
function findSubsequenceCount ( $ S , $ T ) { $ m = strlen ( $ T ) ; $ n = strlen ( $ S ) ; if ( $ m > $ n ) return 0 ; $ mat = array ( array ( ) ) ; for ( $ i = 1 ; $ i <= $ m ; $ i ++ ) $ mat [ $ i ] [ 0 ] = 0 ; for ( $ j = 0 ; $ j <= $ n ; $ j ++ ) $ mat [ 0 ] [ $ j ] = 1 ; for ( $ i = 1 ; $ i <= $ m ; $ i ++ ) { for ( $ j = 1 ; $ j <= $ n ; $ j ++ ) { if ( $ T [ $ i - 1 ] != $ S [ $ j - 1 ] ) $ mat [ $ i ] [ $ j ] = $ mat [ $ i ] [ $ j - 1 ] ; else $ mat [ $ i ] [ $ j ] = $ mat [ $ i ] [ $ j - 1 ] + $ mat [ $ i - 1 ] [ $ j - 1 ] ; } } return $ mat [ $ m ] [ $ n ] ; }
function solve ( $ arr , $ n ) { sort ( $ arr ) ; sort ( $ arr , $ n ) ; $ a = 0 ; $ b = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ i & 1 ) $ a = $ a * 10 + $ arr [ $ i ] ; else $ b = $ b * 10 + $ arr [ $ i ] ; } return $ a + $ b ; }
function maxProduct ( $ arr , $ n ) { $ INT_MIN = 0 ; if ( $ n < 3 ) return -1 ; $ max_product = $ INT_MIN ; for ( $ i = 0 ; $ i < $ n - 2 ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n - 1 ; $ j ++ ) for ( $ k = $ j + 1 ; $ k < $ n ; $ k ++ ) $ max_product = max ( $ max_product , $ arr [ $ i ] * $ arr [ $ j ] * $ arr [ $ k ] ) ; return $ max_product ; }
function maxProduct ( $ arr , $ n ) { if ( $ n < 3 ) { return -1 ; } sort ( $ arr ) ; return max ( $ arr [ 0 ] * $ arr [ 1 ] * $ arr [ $ n - 1 ] , $ arr [ $ n - 1 ] * $ arr [ $ n - 2 ] * $ arr [ $ n - 3 ] ) ; } $ arr = array ( -10 , -3 , 5 , 6 , -20 ) ; $ n = sizeof ( $ arr ) ; $ max = maxProduct ( $ arr , $ n ) ; if ( $ max == -1 ) { echo ( " No ▁ Triplet ▁ Exists " ) ; } else { echo ( " Maximum ▁ product ▁ is ▁ " . $ max ) ; }
function findMaxGuests ( $ arrl , $ exit , $ n ) { sort ( $ arrl ) ; sort ( $ exit ) ; $ guests_in = 1 ; $ max_guests = 1 ; $ time = $ arrl [ 0 ] ; $ i = 1 ; $ j = 0 ; while ( $ i < $ n and $ j < $ n ) { if ( $ arrl [ $ i ] <= $ exit [ $ j ] ) { $ guests_in ++ ; if ( $ guests_in > $ max_guests ) { $ max_guests = $ guests_in ; $ time = $ arrl [ $ i ] ; } $ i ++ ; } else { $ guests_in -- ; $ j ++ ; } } echo " Maximum ▁ Number ▁ of ▁ Guests ▁ = ▁ " , $ max_guests , " ▁ at ▁ time ▁ " , $ time ; }
function Substring ( $ s ) { $ ans = 1 ; $ temp = 1 ; for ( $ i = 1 ; $ i < strlen ( $ s ) ; $ i ++ ) { if ( $ s [ $ i ] == $ s [ $ i - 1 ] ) { ++ $ temp ; } else { $ ans = max ( $ ans , $ temp ) ; $ temp = 1 ; } } $ ans = max ( $ ans , $ temp ) ; return $ ans ; }
function printMaxNumber ( $ n ) { if ( $ n & 1 ) { echo "7" ; for ( $ i = 0 ; $ i < ( $ n - 3 ) / 2 ; $ i ++ ) echo "1" ; } else { for ( $ i = 0 ; $ i < $ n / 2 ; $ i ++ ) echo "1" ; } }
function get_maximum ( $ s , $ a ) { $ n = strlen ( $ s ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ s [ $ i ] - '0' < $ a [ $ s [ $ i ] - '0' ] ) { $ j = $ i ; while ( $ j < $ n && ( $ s [ $ j ] - '0' <= $ a [ $ s [ $ j ] - '0' ] ) ) { $ s [ $ j ] = '0' + $ a [ $ s [ $ j ] - '0' ] ; $ j ++ ; } return $ s ; } } return $ s ; }
function bankNotes ( $ A , $ B , $ S , $ N ) { $ numerator = $ S - ( $ B * $ N ) ; $ denominator = $ A - $ B ; if ( $ numerator % $ denominator == 0 ) return ( $ numerator / $ denominator ) ; return -1 ; }
function countSteps ( $ n ) { $ steps = 0 ; while ( $ n ) { $ largest = ( int ) sqrt ( $ n ) ; $ n -= ( $ largest * $ largest ) ; $ steps ++ ; } return $ steps ; }
function longestSubstring ( $ s ) { $ cnt = 1 ; $ maxi = 1 ; $ n = strlen ( $ s ) ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( $ s [ $ i ] != $ s [ $ i - 1 ] ) $ cnt ++ ; else { $ maxi = max ( $ cnt , $ maxi ) ; $ cnt = 1 ; } } $ maxi = max ( $ cnt , $ maxi ) ; return $ maxi ; }
function Minsteps ( $ n , $ m ) { $ ans = 0 ; while ( $ m > $ n ) { if ( $ m % 2 != 0 ) { $ m ++ ; $ ans ++ ; } $ m /= 2 ; $ ans ++ ; } return $ ans + $ n - $ m ; }
function maxCandies ( $ arr , $ n ) { $ prevBought = $ arr [ $ n - 1 ] ; $ candies = $ prevBought ; for ( $ i = $ n - 2 ; $ i >= 0 ; $ i -- ) { $ x = min ( $ prevBought - 1 , $ arr [ $ i ] ) ; if ( $ x >= 0 ) { $ candies += $ x ; $ prevBought = $ x ; } } return $ candies ; }
function Maxsum ( $ c1 , $ c2 , $ c3 , $ c4 ) { $ sum = 0 ; $ two34 = min ( $ c2 , min ( $ c3 , $ c4 ) ) ; $ sum = $ two34 * 234 ; $ c2 -= $ two34 ; $ sum += min ( $ c2 , $ c1 ) * 12 ; return $ sum ; }
function maximumResult ( $ a , $ b , $ c ) { $ countOfNegative = 0 ; $ sum = $ a + $ b + $ c ; $ product = $ a * $ b * $ c ; $ largest = max ( $ a , $ b , $ c ) ; $ smallest = min ( $ a , $ b , $ c ) ; if ( $ a < 0 ) $ countOfNegative ++ ; if ( $ b < 0 ) $ countOfNegative ++ ; if ( $ c < 0 ) $ countOfNegative ++ ; switch ( $ countOfNegative ) { case 0 : return ( $ sum - $ largest ) * $ largest ; case 1 : return ( $ product / $ smallest ) + $ smallest ; case 2 : return ( $ product / $ largest ) + $ largest ; case 3 : return ( $ sum - $ smallest ) * $ smallest ; } }
function findCountOfPairs ( $ a , $ b , $ n ) { $ ans = 0 ; for ( $ i = 1 ; $ i <= $ a ; $ i ++ ) { $ ans += ( int ) ( $ b / $ n ) ; $ ans += ( ( $ i % $ n ) + ( $ b % $ n ) ) >= $ n ? 1 : 0 ; } return $ ans ; }
function findCountOfPairs ( $ a , $ b , $ n ) { $ ans = 0 ; $ ans += $ n * ( int ) ( $ a / $ n ) * ( int ) ( $ b / $ n ) ; $ ans += ( int ) ( $ a / $ n ) * ( $ b % $ n ) ; $ ans += ( $ a % $ n ) * ( int ) ( $ b / $ n ) ; $ ans += ( ( $ a % $ n ) + ( int ) ( $ b % $ n ) ) / $ n ; return $ ans ; }
function encryptString ( $ str , $ n ) { $ i = 0 ; $ cnt = 0 ; $ encryptedStr = " " ; while ( $ i < $ n ) { $ cnt = $ i + 1 ; while ( $ cnt -- ) $ encryptedStr . = $ str [ $ i ] ; $ i ++ ; } return $ encryptedStr ; }
function min_elimination ( $ n , $ arr ) { $ count = 0 ; $ prev_val = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ curr_val = $ arr [ $ i ] ; if ( $ curr_val % 2 == $ prev_val % 2 ) $ count ++ ; $ prev_val = $ curr_val ; } return $ count ; }
function getCount ( $ N ) { if ( $ N % 2 == 1 ) return 0 ; $ result = "9" ; for ( $ i = 1 ; $ i <= $ N / 2 - 1 ; $ i ++ ) $ result . = "0" ; return $ result ; }
function findIntersection ( $ intervals , $ N ) { $ l = $ intervals [ 0 ] [ 0 ] ; $ r = $ intervals [ 0 ] [ 1 ] ; for ( $ i = 1 ; $ i < $ N ; $ i ++ ) { if ( $ intervals [ $ i ] [ 0 ] > $ r $ intervals [ $ i ] [ 1 ] < $ l ) { echo - 1 ; return ; } else { $ l = max ( $ l , $ intervals [ $ i ] [ 0 ] ) ; $ r = min ( $ r , $ intervals [ $ i ] [ 1 ] ) ; } } echo " [ " ▁ . ▁ $ l ▁ . ▁ " , " ▁ . ▁ $ r ▁ . ▁ " ] " ; }
function find_rectangle ( $ area ) { $ M = floor ( sqrt ( $ area ) ) ; for ( $ i = $ M ; $ i >= 1 ; $ i -- ) { if ( $ area % $ i == 0 ) { $ l = floor ( $ area / $ i ) ; $ b = $ i ; break ; } } echo " l = " , ▁ $ l , ▁ " , b = " , ▁ $ b , ▁ " " }
function sizeSubSet ( $ a , $ k , $ n ) { sort ( $ a ) ; $ s = array ( ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] % $ k != 0 or ! in_array ( floor ( $ a [ $ i ] / $ k ) , $ s ) ) array_push ( $ s , $ a [ $ i ] ) ; } return sizeof ( $ s ) ; }
function minimumSets ( $ s , $ y ) { $ cnt = 0 ; $ num = 0 ; $ l = strlen ( $ s ) ; $ f = 0 ; for ( $ i = 0 ; $ i < $ l ; $ i ++ ) { $ num = $ num * 10 + ( $ s [ $ i ] - '0' ) ; if ( $ num <= $ y ) $ f = 1 ; { if ( $ f ) $ cnt += 1 ; $ num = $ s [ $ i ] - '0' ; $ f = 0 ; if ( $ num <= $ y ) $ f = 1 ; else $ num = 0 ; } } if ( $ f ) $ cnt += 1 ; return $ cnt ; }
function minItems ( $ k , $ r ) { for ( $ i = 1 ; $ i < 10 ; $ i ++ ) if ( ( $ i * $ k - $ r ) % 10 == 0 || ( $ i * $ k ) % 10 == 0 ) return $ i ; return 10 ; }
function check ( $ n , $ marks ) { $ x = max ( $ marks ) ; $ bonus = 100 - $ x ; $ c = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ marks [ $ i ] + $ bonus >= 50 ) $ c += 1 ; } return $ c ; }
function find_sum ( $ n , $ k ) { $ total_sum = ( $ n * ( $ n + 1 ) ) / 2 ; $ power = $ k ; while ( $ power <= $ n ) { $ total_sum -= $ power ; $ power *= $ k ; } return $ total_sum ; }
function maxLitres ( $ budget , $ plastic , $ glass , $ refund ) { if ( $ glass - $ refund < $ plastic ) { $ ans = max ( ( int ) ( $ budget - $ refund ) / ( $ glass - $ refund ) , 0 ) ; $ budget -= $ ans * ( $ glass - $ refund ) ; $ ans += ( int ) ( $ budget / $ plastic ) ; echo $ ans . " STRNEWLINE " ; } else echo ( int ) ( $ budget / $ plastic ) . " STRNEWLINE " ; }
function minChanges ( $ A , $ n ) { $ cnt = 0 ; for ( $ i = 0 ; $ i < $ n - 2 ; ++ $ i ) { if ( ( $ i - 1 >= 0 ) && $ A [ $ i - 1 ] == 1 && $ A [ $ i + 1 ] == 1 && $ A [ $ i ] == 0 ) { $ A [ $ i + 1 ] = 0 ; $ cnt ++ ; } } return $ cnt ; }
function completeSequence ( $ s ) { $ n = strlen ( $ s ) ; $ open = 0 ; $ close = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ s [ $ i ] == ' ( ' ) $ open ++ ; else $ close ++ ; if ( $ close > $ open ) { echo ( " IMPOSSIBLE " ) ; return ; } } echo ( $ s ) ; for ( $ i = 0 ; $ i < $ open - $ close ; $ i ++ ) echo ( " ) " ) ; }
function leastValue ( $ P , $ A , $ N , $ a ) { $ ans = -1 ; $ tmp = PHP_INT_MAX ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { $ t = $ P - $ a [ $ i ] * 0.006 ; if ( abs ( $ t - $ A ) < $ tmp ) { $ tmp = abs ( $ t - $ A ) ; $ ans = $ i ; } } return $ a [ $ ans ] ; }
function minInsertions ( $ H , $ n , $ K ) { $ inser = 0 ; for ( $ i = 1 ; $ i < $ n ; ++ $ i ) { $ diff = abs ( $ H [ $ i ] - $ H [ $ i - 1 ] ) ; if ( $ diff <= $ K ) continue ; else $ inser += ceil ( $ diff / $ K ) - 1 ; } return $ inser ; }
function minCost ( $ N , $ P , $ Q ) { $ cost = 0 ; while ( $ N > 0 ) { if ( $ N & 1 ) { $ cost += $ P ; $ N -- ; } else { $ temp = $ N / 2 ; if ( $ temp * $ P > $ Q ) $ cost += $ Q ; else $ cost += $ P * $ temp ; $ N /= 2 ; } } return $ cost ; }
function count_minimum_operations ( $ n ) { $ count = 0 ; while ( $ n > 1 ) { if ( $ n % 3 == 0 ) $ n /= 3 ; else if ( $ n % 3 == 1 ) $ n -- ; else { if ( $ n == 2 ) $ n -- ; else $ n ++ ; } $ count ++ ; } return $ count ; }
function findPermutation ( $ n ) { $ len = ceil ( log10 ( $ n ) ) ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { if ( $ n % 2 != 0 ) { return ( int ) $ n ; } else { $ n = ( $ n / 10 ) + ( $ n % 10 ) * pow ( 10 , $ len - $ i - 1 ) ; continue ; } } return -1 ; }
function getMinCost ( $ arr , $ n ) { $ min_ele = min ( $ arr ) ; return $ min_ele * ( $ n - 1 ) ; }
function cal_minimum_time ( $ X ) { $ t = 0 ; $ sum = 0 ; while ( $ sum < $ X ) { $ t ++ ; $ sum = $ sum + $ t ; } return $ t ; }
function minDiff ( $ n , $ x , $ A ) { $ mn = $ A [ 0 ] ; $ mx = $ A [ 0 ] ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { $ mn = min ( $ mn , $ A [ $ i ] ) ; $ mx = max ( $ mx , $ A [ $ i ] ) ; } return max ( 0 , $ mx - $ mn - 2 * $ x ) ; }
function maxSum ( $ a , $ n ) { $ s = 0 ; $ l = array ( ) ; for ( $ i = 0 ; $ i < count ( $ a ) ; $ i ++ ) { $ s += abs ( $ a [ $ i ] ) ; if ( $ a [ $ i ] >= 0 ) continue ; if ( $ i == 0 ) array_push ( $ l , $ i + 1 ) ; else { array_push ( $ l , $ i + 1 ) ; array_push ( $ l , $ i ) ; } } echo $ s . " STRNEWLINE " ; for ( $ i = 0 ; $ i < count ( $ l ) ; $ i ++ ) echo $ l [ $ i ] . " ▁ " ; }
function CountPair ( $ L , $ R ) { $ x = ( $ R - $ L + 1 ) ; echo $ x / 2 , " STRNEWLINE " ; }
function problemsLeft ( $ K , $ P , $ N ) { if ( $ K <= $ P ) return 0 ; else return ( $ K - $ P ) * $ N ; }
function printCoins ( & $ arr , $ n ) { $ oddSum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i += 2 ) $ oddSum += $ arr [ $ i ] ; $ evenSum = 0 ; for ( $ i = 1 ; $ i < $ n ; $ i += 2 ) $ evenSum += $ arr [ $ i ] ; $ start = ( ( $ oddSum > $ evenSum ) ? 0 : 1 ) ; for ( $ i = $ start ; $ i < $ n ; $ i += 2 ) echo $ arr [ $ i ] . " ▁ " ; }
function results ( $ n , $ k ) { return round ( pow ( $ n , ( 1.0 / pow ( 2 , $ k ) ) ) ) ; }
function smallestSumSubarr ( $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ arr [ $ i ] = - $ arr [ $ i ] ; $ sum_here = $ arr [ 0 ] ; $ max_sum = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ sum_here = max ( $ sum_here + $ arr [ $ i ] , $ arr [ $ i ] ) ; $ max_sum = max ( $ max_sum , $ sum_here ) ; } return ( -1 ) * $ max_sum ; }
function printLargest ( $ a , $ n ) { $ max = -1 ; $ ind = -1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ num = $ a [ $ i ] ; while ( $ num ) { $ r = $ num % 10 ; $ num = ( int ) $ num / 10 ; if ( $ num == 0 ) { if ( $ max < $ r ) { $ max = $ r ; $ ind = $ i ; } } } } for ( $ i = $ ind ; $ i < $ n ; $ i ++ ) echo $ a [ $ i ] ; for ( $ i = 0 ; $ i < $ ind ; $ i ++ ) echo $ a [ $ i ] ; }
function steps ( $ N , $ M ) { if ( $ N == 1 ) return 0 ; return $ M ; return 2 * $ M + ( $ N - 3 ) ; }
function ifPossible ( & $ arr , $ n ) { $ cp = array ( ) ; $ cp = $ arr ; sort ( $ cp ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( ! ( $ arr [ $ i ] == $ cp [ $ i ] ) && ! ( $ arr [ $ n - 1 - $ i ] == $ cp [ $ i ] ) ) return false ; } return true ; }
function findMinRooms ( $ slots , $ n , $ m ) { $ counts = array_fill ( 0 , $ m , 0 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ m ; $ j ++ ) if ( $ slots [ $ i ] [ $ j ] == '1' ) $ counts [ $ j ] ++ ; return max ( $ counts ) ; }
function MinOperation ( $ a , $ n , $ k ) { $ result = 0 ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { if ( $ a [ $ i ] != 1 && $ a [ $ i ] > $ k ) { $ result = $ result + min ( $ a [ $ i ] % $ k , $ k - $ a [ $ i ] % $ k ) ; } else { $ result = $ result + $ k - $ a [ $ i ] ; } } return $ result ; }
function survival ( $ S , $ N , $ M ) { if ( ( ( $ N * 6 ) < ( $ M * 7 ) && $ S > 6 ) $ M > $ N ) echo " No " ; else { $ days = ( $ M * $ S ) / $ N ; if ( ( ( $ M * $ S ) % $ N ) != 0 ) $ days ++ ; echo " Yes ▁ " , floor ( $ days ) ; } }
function digitsNum ( $ N ) { if ( $ N == 0 ) echo "0 STRNEWLINE " ; if ( $ N % 9 != 0 ) echo ( $ N % 9 ) ; for ( $ i = 1 ; $ i <= ( $ N / 9 ) ; ++ $ i ) echo "9" ; for ( $ i = 1 ; $ i <= $ N ; ++ $ i ) echo "0" ; echo " STRNEWLINE " ; }
function noAdjacentDup ( $ s ) { $ n = strlen ( $ s ) ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( $ s [ $ i ] == $ s [ $ i - 1 ] ) { $ s [ $ i ] = ' a ' ; while ( $ s [ $ i ] == $ s [ $ i - 1 ] || ( $ i + 1 < $ n && $ s [ $ i ] == $ s [ $ i + 1 ] ) ) $ s [ $ i ] ++ ; $ i ++ ; } } return $ s ; }
function cost ( $ a , $ n ) { return ( $ n - 1 ) * ( min ( $ a ) ) ; }
function maxDifference ( $ arr , $ N , $ k ) { $ M ; $ S = 0 ; $ S1 = 0 ; $ max_difference = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) $ S += $ arr [ $ i ] ; rsort ( $ arr ) ; $ M = max ( $ k , $ N - $ k ) ; for ( $ i = 0 ; $ i < $ M ; $ i ++ ) $ S1 += $ arr [ $ i ] ; $ max_difference = $ S1 - ( $ S - $ S1 ) ; return $ max_difference ; }
function winner ( $ a , $ n , $ k ) { if ( $ k >= $ n - 1 ) return $ n ; $ best = 0 ; $ times = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] > $ best ) { $ best = $ a [ $ i ] ; if ( $ i ) $ times = 1 ; } else $ times += 1 ; if ( $ times >= $ k ) return $ best ; } return $ best ; }
function minproduct ( $ a , $ b , $ n , $ k ) { $ diff = 0 ; $ res = 0 ; $ temp ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ pro = $ a [ $ i ] * $ b [ $ i ] ; $ res = $ res + $ pro ; if ( $ pro < 0 and $ b [ $ i ] < 0 ) $ temp = ( $ a [ $ i ] + 2 * $ k ) * $ b [ $ i ] ; else if ( $ pro < 0 and $ a [ $ i ] < 0 ) $ temp = ( $ a [ $ i ] - 2 * $ k ) * $ b [ $ i ] ; else if ( $ pro > 0 and $ a [ $ i ] < 0 ) $ temp = ( $ a [ $ i ] + 2 * $ k ) * $ b [ $ i ] ; else if ( $ pro > 0 and $ a [ $ i ] > 0 ) $ temp = ( $ a [ $ i ] - 2 * $ k ) * $ b [ $ i ] ; $ d = abs ( $ pro - $ temp ) ; if ( $ d > $ diff ) $ diff = $ d ; } return $ res - $ diff ; }
function minSum ( $ A , $ n ) { $ min_val = min ( $ A ) ; return ( $ min_val * ( $ n - 1 ) ) ; }
function minRotation ( $ input , $ unlock_code ) { $ rotation = 0 ; $ input_digit ; $ code_digit ; while ( $ input $ unlock_code ) { $ input_digit = $ input % 10 ; $ code_digit = $ unlock_code % 10 ; $ rotation += min ( abs ( $ input_digit - $ code_digit ) , 10 - abs ( $ input_digit - $ code_digit ) ) ; $ input /= 10 ; $ unlock_code /= 10 ; } return $ rotation ; }
function minCost ( $ coin , $ n , $ k ) { sort ( $ coin ) ; sort ( $ coin , $ n ) ; $ coins_needed = ceil ( 1.0 * $ n / ( $ k + 1 ) ) ; $ ans = 0 ; for ( $ i = 0 ; $ i <= $ coins_needed - 1 ; $ i ++ ) $ ans += $ coin [ $ i ] ; return $ ans ; } { $ coin = array ( 8 , 5 , 3 , 10 , 2 , 1 , 15 , 25 ) ; $ n = sizeof ( $ coin ) / sizeof ( $ coin [ 0 ] ) ; $ k = 3 ; echo minCost ( $ coin , $ n , $ k ) ; return 0 ; }
function maximumSum ( $ arr , $ n , $ k ) { $ INT_MAX = 0 ; for ( $ i = 1 ; $ i <= $ k ; $ i ++ ) { $ min = $ INT_MAX ; $ index = -1 ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ arr [ $ j ] < $ min ) { $ min = $ arr [ $ j ] ; $ index = $ j ; } } if ( $ min == 0 ) break ; $ arr [ $ index ] = - $ arr [ $ index ] ; } $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum += $ arr [ $ i ] ; return $ sum ; }
function maxSum ( $ arr , $ i , $ n ) { if ( $ i >= $ n ) return 0 ; if ( $ GLOBALS [ ' v ' ] [ $ i ] ) return $ GLOBALS [ ' dp ' ] [ $ i ] ; $ GLOBALS [ ' v ' ] [ $ i ] = 1 ; $ GLOBALS [ ' dp ' ] [ $ i ] = max ( maxSum ( $ arr , $ i + 1 , $ n ) , $ arr [ $ i ] + maxSum ( $ arr , $ i + 2 , $ n ) ) ; return $ GLOBALS [ ' dp ' ] [ $ i ] ; }
function MinOfCubed ( $ k ) { if ( $ k < 8 ) return $ k ; $ res = $ k ; for ( $ i = 1 ; $ i <= $ k ; $ i ++ ) { if ( ( $ i * $ i * $ i ) > $ k ) return $ res ; $ res = min ( $ res , MinOfCubed ( $ k - ( $ i * $ i * $ i ) ) + 1 ) ; } return $ res ; }
function MinOfCubedDP ( $ k ) { $ DP = array ( $ k + 1 ) ; $ j = 1 ; $ t = 1 ; $ DP [ 0 ] = 0 ; for ( $ i = 1 ; $ i <= $ k ; $ i ++ ) { $ DP [ $ i ] = PHP_INT_MAX ; while ( $ j <= $ i ) { if ( $ j == $ i ) $ DP [ $ i ] = 1 ; else if ( $ DP [ $ i ] > $ DP [ $ i - $ j ] ) $ DP [ $ i ] = $ DP [ $ i - $ j ] + 1 ; $ t ++ ; $ j = $ t * $ t * $ t ; } $ t = $ j = 1 ; } return $ DP [ $ k ] ; }
function LIS ( $ a , $ n ) { $ dp = array ( ) ; $ d = array ( ) ; $ ans = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ dp [ $ a [ $ i ] ] = 1 ; for ( $ j = 2 ; $ j * $ j <= $ a [ $ i ] ; $ j ++ ) { if ( $ a [ $ i ] % $ j == 0 ) { $ dp [ $ a [ $ i ] ] = max ( $ dp [ $ a [ $ i ] ] , $ dp [ $ d [ $ j ] ] + 1 ) ; $ dp [ $ a [ $ i ] ] = max ( $ dp [ $ a [ $ i ] ] , $ dp [ $ d [ $ a [ $ i ] / $ j ] ] + 1 ) ; $ d [ $ j ] = $ a [ $ i ] ; $ d [ $ a [ $ i ] / $ j ] = $ a [ $ i ] ; } } $ ans = max ( $ ans , $ dp [ $ a [ $ i ] ] ) ; $ d [ $ a [ $ i ] ] = $ a [ $ i ] ; } return $ ans ; }
function maxSum ( $ a , $ n ) { $ ans = 0 ; $ arr = array ( ) ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ arr [ $ i ] = $ a [ $ i - 1 ] ; $ dp = array ( array ( ) ) ; for ( $ i = 1 ; $ i <= $ n ; ++ $ i ) { $ dp [ $ i ] [ 0 ] = max ( $ arr [ $ i ] , $ dp [ $ i - 1 ] [ 0 ] + $ arr [ $ i ] ) ; $ dp [ $ i ] [ 1 ] = max ( 0 , $ dp [ $ i - 1 ] [ 0 ] ) - $ arr [ $ i ] ; if ( $ i >= 2 ) $ dp [ $ i ] [ 1 ] = max ( $ dp [ $ i ] [ 1 ] , $ dp [ $ i - 1 ] [ 1 ] + $ arr [ $ i ] ) ; if ( $ i >= 2 ) $ dp [ $ i ] [ 2 ] = $ dp [ $ i - 1 ] [ 1 ] - $ arr [ $ i ] ; if ( $ i >= 3 ) $ dp [ $ i ] [ 2 ] = max ( $ dp [ $ i ] [ 2 ] , $ dp [ $ i - 1 ] [ 2 ] + $ arr [ $ i ] ) ; $ ans = max ( $ ans , $ dp [ $ i ] [ 0 ] ) ; $ ans = max ( $ ans , $ dp [ $ i ] [ 1 ] ) ; $ ans = max ( $ ans , $ dp [ $ i ] [ 2 ] ) ; } return $ ans ; }
function findCount ( $ mat , $ i , $ j , $ m ) { if ( $ i == 0 && $ j == 0 ) { if ( $ m == $ mat [ 0 ] [ 0 ] ) return 1 ; else return 0 ; } if ( $ m < 0 ) return 0 ; if ( $ i < 0 $ j < 0 ) return 0 ; if ( $ v [ $ i ] [ $ j ] [ $ m ] ) return $ dp [ $ i ] [ $ j ] [ $ m ] ; $ v [ $ i ] [ $ j ] [ $ m ] = true ; $ dp [ $ i ] [ $ j ] [ $ m ] = findCount ( $ mat , $ i - 1 , $ j , $ m - $ mat [ $ i ] [ $ j ] ) + findCount ( $ mat , $ i , $ j - 1 , $ m - $ mat [ $ i ] [ $ j ] ) ; return $ dp [ $ i ] [ $ j ] [ $ m ] ; }
function FindMinimumCost ( $ ind , $ a , $ n , $ k , $ dp ) { if ( $ ind == ( $ n - 1 ) ) return 0 ; else if ( $ dp [ $ ind ] != -1 ) return $ dp [ $ ind ] ; else { $ ans = PHP_INT_MAX ; for ( $ i = 1 ; $ i <= $ k ; $ i ++ ) { if ( $ ind + $ i < $ n ) $ ans = min ( $ ans , abs ( $ a [ $ ind + $ i ] - $ a [ $ ind ] ) + FindMinimumCost ( $ ind + $ i , $ a , $ n , $ k , $ dp ) ) ; else break ; } return $ dp [ $ ind ] = $ ans ; } }
function findWaysToPair ( $ p ) { $ dp = array ( ) ; $ dp [ 1 ] = 1 ; $ dp [ 2 ] = 2 ; for ( $ i = 3 ; $ i <= $ p ; $ i ++ ) { $ dp [ $ i ] = $ dp [ $ i - 1 ] + ( $ i - 1 ) * $ dp [ $ i - 2 ] ; } return $ dp [ $ p ] ; }
function solve ( $ idx , $ diff , $ N , $ M , $ K ) { global $ dp , $ MOD ; if ( $ idx > $ N ) { if ( $ diff == $ K ) return 1 ; return 0 ; } if ( $ dp [ $ idx ] [ $ diff ] != -1 ) return $ dp [ $ idx ] [ $ diff ] ; $ ans = solve ( $ idx + 1 , $ diff , $ N , $ M , $ K ) ; $ ans += ( $ M - 1 ) * solve ( $ idx + 1 , $ diff + 1 , $ N , $ M , $ K ) ; return $ dp [ $ idx ] [ $ diff ] = $ ans % $ MOD ; }
function maxPathSum ( $ tri ) { global $ N ; $ ans = 0 ; for ( $ i = $ N - 2 ; $ i >= 0 ; $ i -- ) { for ( $ j = 0 ; $ j < $ N - $ i ; $ j ++ ) { if ( $ j - 1 >= 0 ) $ tri [ $ i ] [ $ j ] += max ( $ tri [ $ i + 1 ] [ $ j ] , $ tri [ $ i + 1 ] [ $ j - 1 ] ) ; else $ tri [ $ i ] [ $ j ] += $ tri [ $ i + 1 ] [ $ j ] ; $ ans = max ( $ ans , $ tri [ $ i ] [ $ j ] ) ; } } return $ ans ; }
function get_max_splits ( $ num_string ) { $ count = 0 ; $ running_sum = 0 ; for ( $ i = 0 ; $ i < strlen ( $ num_string ) ; $ i ++ ) { $ current_num = intval ( $ num_string [ $ i ] ) ; $ running_sum += $ current_num ; if ( $ current_num % 3 == 0 or ( $ running_sum != 0 and $ running_sum % 3 == 0 ) ) { $ count += 1 ; $ running_sum = 0 ; } } return $ count ; }
function countPaths ( $ sum , $ get , $ m , $ n , & $ dp ) { global $ max , $ c ; if ( $ sum < 0 ) return 0 ; if ( $ sum == 0 ) return $ get ; if ( $ dp [ $ sum ] [ $ get ] != -1 ) return $ dp [ $ sum ] [ $ get ] ; $ res = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { if ( $ i == $ m ) $ res += countPaths ( $ sum - $ i , 1 , $ m , $ n , $ dp ) ; $ res += countPaths ( $ sum - $ i , $ get , $ m , $ n , $ dp ) ; } $ dp [ $ sum ] [ $ get ] = $ res ; return $ dp [ $ sum ] [ $ get ] ; }
function findMinimumCost ( $ n , $ x , $ y ) { $ dp [ $ n + 1 ] = array ( ) ; $ dp [ 1 ] = $ x ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { if ( $ i & 1 ) { $ dp [ $ i ] = min ( $ dp [ $ i - 1 ] + $ x , $ dp [ ( $ i + 1 ) / 2 ] + $ y + $ x ) ; } else { $ dp [ $ i ] = min ( $ dp [ $ i - 1 ] + $ x , $ dp [ $ i / 2 ] + $ y ) ; } } return $ dp [ $ n ] ; }
function countWays ( $ index , $ cnt , $ dp , $ n , $ m , $ k ) { if ( $ index == $ n ) { if ( $ cnt == $ k ) return 1 ; else return 0 ; } if ( $ dp [ $ index ] [ $ cnt ] != -1 ) return $ dp [ $ index ] [ $ cnt ] ; $ ans = 0 ; $ ans += countWays ( $ index + 1 , $ cnt , $ dp , $ n , $ m , $ k ) ; $ ans += ( $ m - 1 ) * countWays ( $ index + 1 , $ cnt + 1 , $ dp , $ n , $ m , $ k ) ; $ dp [ $ index ] [ $ cnt ] = $ ans ; return $ dp [ $ index ] [ $ cnt ] ; }
function sumOddFibonacci ( $ n ) { global $ mod ; $ Sum [ $ n + 1 ] = array ( ) ; $ Sum [ 0 ] = 0 ; $ Sum [ 1 ] = 1 ; $ Sum [ 2 ] = 2 ; $ Sum [ 3 ] = 5 ; $ Sum [ 4 ] = 10 ; $ Sum [ 5 ] = 23 ; for ( $ i = 6 ; $ i <= $ n ; $ i ++ ) { $ Sum [ $ i ] = ( ( $ Sum [ $ i - 1 ] + ( 4 * $ Sum [ $ i - 2 ] ) % $ mod - ( 4 * $ Sum [ $ i - 3 ] ) % $ mod + $ mod ) % $ mod + ( $ Sum [ $ i - 4 ] - $ Sum [ $ i - 5 ] + $ mod ) % $ mod ) % $ mod ; } return $ Sum [ $ n ] ; }
function calculateEvenSum ( $ n ) { if ( $ n <= 0 ) return 0 ; $ fibo [ 2 * $ n + 1 ] = array ( ) ; $ fibo [ 0 ] = 0 ; $ fibo [ 1 ] = 1 ; $ sum = 0 ; for ( $ i = 2 ; $ i <= 2 * $ n ; $ i ++ ) { $ fibo [ $ i ] = $ fibo [ $ i - 1 ] + $ fibo [ $ i - 2 ] ; if ( $ i % 2 == 0 ) $ sum += $ fibo [ $ i ] ; } return $ sum ; }
function find ( $ index , $ openbrk , $ n , $ adj ) { global $ MAX_VAL ; global $ dp ; if ( $ openbrk < 0 ) return $ MAX_VAL ; if ( $ index == $ n ) { if ( $ openbrk == 0 ) { return 0 ; } return $ MAX_VAL ; } if ( $ dp [ $ index ] [ $ openbrk ] != -1 ) return $ dp [ $ index ] [ $ openbrk ] ; $ dp [ $ index ] [ $ openbrk ] = min ( $ adj [ $ index ] [ 1 ] + find ( $ index + 1 , $ openbrk + 1 , $ n , $ adj ) , $ adj [ $ index ] [ 0 ] + find ( $ index + 1 , $ openbrk - 1 , $ n , $ adj ) ) ; return $ dp [ $ index ] [ $ openbrk ] ; }
function gouldSequence ( $ n ) { for ( $ row_num = 1 ; $ row_num <= $ n ; $ row_num ++ ) { $ count = 1 ; $ c = 1 ; for ( $ i = 1 ; $ i <= $ row_num ; $ i ++ ) { $ c = $ c * ( $ row_num - $ i ) / $ i ; if ( $ c % 2 == 1 ) $ count ++ ; } echo $ count , " " ; } }
function partitions ( $ n ) { $ p = array_fill ( 0 , $ n + 1 , 0 ) ; $ p [ 0 ] = 1 ; for ( $ i = 1 ; $ i < $ n + 1 ; $ i ++ ) { $ k = 1 ; while ( ( $ k * ( 3 * $ k - 1 ) ) / 2 <= $ i ) { $ p [ $ i ] += ( ( $ k % 2 ? 1 : -1 ) * $ p [ $ i - ( $ k * ( 3 * $ k - 1 ) ) / 2 ] ) ; if ( $ k > 0 ) $ k *= -1 ; else $ k = 1 - $ k ; } } return $ p [ $ n ] ; }
function countPaths ( $ m , $ n ) { if ( $ m == 1 $ n == 1 ) return 1 ; return countPaths ( $ m - 1 , $ n ) + countPaths ( $ m , $ n - 1 ) ; }
function countPaths ( $ m , $ n ) { $ dp ; for ( $ i = 1 ; $ i <= $ m ; $ i ++ ) { for ( $ j = 1 ; $ j <= $ n ; $ j ++ ) { if ( $ i == 1 $ j == 1 ) $ dp [ $ i ] [ $ j ] = 1 ; else $ dp [ $ i ] [ $ j ] = $ dp [ $ i - 1 ] [ $ j ] + $ dp [ $ i ] [ $ j - 1 ] ; } } return $ dp [ $ m ] [ $ n ] ; }
function MatrixChainOrder ( $ p , $ n ) { $ dp = array ( ) ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ dp [ $ i ] [ $ i ] = 0 ; for ( $ L = 1 ; $ L < $ n - 1 ; $ L ++ ) for ( $ i = 1 ; $ i < $ n - $ L ; $ i ++ ) $ dp [ $ i ] [ $ i + $ L ] = min ( $ dp [ $ i + 1 ] [ $ i + $ L ] + $ p [ $ i - 1 ] * $ p [ $ i ] * $ p [ $ i + $ L ] , $ dp [ $ i ] [ $ i + $ L - 1 ] + $ p [ $ i - 1 ] * $ p [ $ i + $ L - 1 ] * $ p [ $ i + $ L ] ) ; return $ dp [ 1 ] [ $ n - 1 ] ; }
function find ( $ start , $ adj , $ n , $ dp ) { if ( $ start == $ n ) return 0 ; if ( $ dp [ $ start ] != -1 ) return $ dp [ $ start ] ; $ dp [ $ start ] = 0 ; $ one = 0 ; $ zero = 0 ; for ( $ k = $ start ; $ k < $ n ; $ k ++ ) { if ( $ adj [ $ k ] == '1' ) $ one ++ ; else $ zero ++ ; if ( $ one > $ zero ) $ dp [ $ start ] = max ( $ dp [ $ start ] , find ( $ k + 1 , $ adj , $ n , $ dp ) + $ k - $ start + 1 ) ; else $ dp [ $ start ] = max ( $ dp [ $ start ] , find ( $ k + 1 , $ adj , $ n , $ dp ) ) ; } return $ dp [ $ start ] ; }
function alternateFib ( $ n ) { if ( $ n < 0 ) return ; $ f1 = 0 ; $ f2 = 1 ; echo $ f1 . " " ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { $ f3 = $ f2 + $ f1 ; if ( $ i % 2 == 0 ) echo $ f3 . " " ; $ f1 = $ f2 ; $ f2 = $ f3 ; } }
function printTetra ( $ n ) { $ dp = array_fill ( 0 , $ n + 5 , 0 ) ; $ dp [ 0 ] = 0 ; $ dp [ 1 ] = $ dp [ 2 ] = 1 ; $ dp [ 3 ] = 2 ; for ( $ i = 4 ; $ i <= $ n ; $ i ++ ) $ dp [ $ i ] = $ dp [ $ i - 1 ] + $ dp [ $ i - 2 ] + $ dp [ $ i - 3 ] + $ dp [ $ i - 4 ] ; echo $ dp [ $ n ] ; }
function printTetra ( $ n ) { if ( $ n < 0 ) return ; $ first = 0 ; $ second = 1 ; $ third = 1 ; $ fourth = 2 ; $ curr ; if ( $ n == 0 ) echo $ first ; else if ( $ n == 1 $ n == 2 ) echo $ second ; else if ( $ n == 3 ) echo $ fourth ; else { for ( $ i = 4 ; $ i <= $ n ; $ i ++ ) { $ curr = $ first + $ second + $ third + $ fourth ; $ first = $ second ; $ second = $ third ; $ third = $ fourth ; $ fourth = $ curr ; } echo $ curr ; } }
function minimumCost ( & $ cost , $ n ) { if ( $ n == 1 ) return $ cost [ 0 ] ; $ dp [ 0 ] = $ cost [ 0 ] ; $ dp [ 1 ] = $ cost [ 1 ] ; for ( $ i = 2 ; $ i < $ n ; $ i ++ ) { $ dp [ $ i ] = min ( $ dp [ $ i - 1 ] , $ dp [ $ i - 2 ] ) + $ cost [ $ i ] ; } return min ( $ dp [ $ n - 2 ] , $ dp [ $ n - 1 ] ) ; }
function minimumCost ( & $ cost , $ n ) { $ dp1 = 0 ; $ dp2 = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ dp0 = $ cost [ $ i ] + min ( $ dp1 , $ dp2 ) ; $ dp2 = $ dp1 ; $ dp1 = $ dp0 ; } return min ( $ dp1 , $ dp2 ) ; }
function countPaths ( $ n ) { $ zB = 1 ; $ zADC = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ nzB = $ zADC * 3 ; $ nzADC = ( $ zADC * 2 + $ zB ) ; $ zB = $ nzB ; $ zADC = $ nzADC ; } return $ zB ; }
function fib ( $ n ) { if ( $ n <= 1 ) return $ n ; return fib ( $ n - 1 ) + fib ( $ n - 2 ) ; }
function lds ( $ arr , $ n ) { $ lds = array ( ) ; $ i ; $ j ; $ max = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ lds [ $ i ] = 1 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ i ; $ j ++ ) if ( $ arr [ $ i ] < $ arr [ $ j ] and $ lds [ $ i ] < $ lds [ $ j ] + 1 ) { $ lds [ $ i ] = $ lds [ $ j ] + 1 ; } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ max < $ lds [ $ i ] ) $ max = $ lds [ $ i ] ; return $ max ; }
function summation ( $ n ) { return $ n << ( $ n - 1 ) ; }
function fib ( $ n ) { $ a = 0 ; $ b = 1 ; $ c ; if ( $ n >= 0 ) echo $ a , " ▁ " ; if ( $ n >= 1 ) echo $ b , " ▁ " ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { $ c = $ a + $ b ; echo $ c , " " ; $ a = $ b ; $ b = $ c ; } }
function minSumPath ( & $ A ) { $ memo = array ( ) ; for ( $ i = 0 ; $ i < count ( $ A ) ; $ i ++ ) $ memo [ $ i ] = 0 ; $ n = count ( $ A ) - 1 ; for ( $ i = 0 ; $ i < count ( $ A [ $ n ] ) ; $ i ++ ) $ memo [ $ i ] = $ A [ $ n ] [ $ i ] ; for ( $ i = count ( $ A ) - 2 ; $ i >= 0 ; $ i -- ) for ( $ j = 0 ; $ j < count ( $ A [ $ i + 1 ] ) - 1 ; $ j ++ ) $ memo [ $ j ] = $ A [ $ i ] [ $ j ] + min ( $ memo [ $ j ] , $ memo [ $ j + 1 ] ) ; return $ memo [ 0 ] ; }
function findSDSFunc ( $ n ) { $ DP [ 0 ] = 0 ; $ DP [ 1 ] = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { if ( $ i % 2 == 0 ) $ DP [ $ i ] = $ DP [ $ i / 2 ] ; else $ DP [ $ i ] = $ DP [ ( $ i - 1 ) / 2 ] + $ DP [ ( $ i + 1 ) / 2 ] ; } return $ DP [ $ n ] ; }
function printGolomb ( $ n ) { $ dp [ 1 ] = 1 ; echo $ dp [ 1 ] , " " ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { $ dp [ $ i ] = 1 + $ dp [ $ i - $ dp [ $ dp [ $ i - 1 ] ] ] ; echo $ dp [ $ i ] , " " ; } }
function maximumSegments ( $ n , $ a , $ b , $ c ) { $ dp = array ( ) ; for ( $ i = 0 ; $ i < $ n + 10 ; $ i ++ ) $ dp [ $ i ] = -1 ; $ dp [ 0 ] = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ dp [ $ i ] != -1 ) { $ dp [ $ i + $ a ] = max ( $ dp [ $ i ] + 1 , $ dp [ $ i + $ a ] ) ; $ dp [ $ i + $ b ] = max ( $ dp [ $ i ] + 1 , $ dp [ $ i + $ b ] ) ; $ dp [ $ i + $ c ] = max ( $ dp [ $ i ] + 1 , $ dp [ $ i + $ c ] ) ; } } return $ dp [ $ n ] ; }
function sequence ( $ n ) { $ f = array ( 0 ) ; $ f [ 0 ] = 0 ; $ f [ 1 ] = 1 ; $ f [ 2 ] = 1 ; echo $ f [ 1 ] , " " ▁ , ▁ $ f [ 2 ] ▁ , ▁ " " for ( $ i = 3 ; $ i <= $ n ; $ i ++ ) { $ f [ $ i ] = $ f [ $ f [ $ i - 1 ] ] + $ f [ $ i - $ f [ $ i - 1 ] ] ; echo $ f [ $ i ] , " " ; } } { $ n = 13 ; sequence ( $ n ) ; return 0 ; }
function findLength ( $ str , $ n ) { $ current_sum = 0 ; $ max_sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ current_sum += ( $ str [ $ i ] == '0' ? 1 : -1 ) ; if ( $ current_sum < 0 ) $ current_sum = 0 ; $ max_sum = max ( $ current_sum , $ max_sum ) ; } return $ max_sum == 0 ? -1 : $ max_sum ; }
function find_prob ( $ N , $ P ) { $ dp ; $ dp [ 0 ] = 1 ; $ dp [ 1 ] = 0 ; $ dp [ 2 ] = $ P ; $ dp [ 3 ] = 1 - $ P ; for ( $ i = 4 ; $ i <= $ N ; ++ $ i ) $ dp [ $ i ] = ( $ P ) * $ dp [ $ i - 2 ] + ( 1 - $ P ) * $ dp [ $ i - 3 ] ; return $ dp [ $ N ] ; }
function maxSubArraySumRepeated ( $ a , $ n , $ k ) { $ INT_MIN = 0 ; $ max_so_far = $ INT_MIN ; $ max_ending_here = 0 ; for ( $ i = 0 ; $ i < $ n * $ k ; $ i ++ ) { $ max_ending_here = $ max_ending_here + $ a [ $ i % $ n ] ; if ( $ max_so_far < $ max_ending_here ) $ max_so_far = $ max_ending_here ; if ( $ max_ending_here < 0 ) $ max_ending_here = 0 ; } return $ max_so_far ; }
function maximumSumSubarray ( $ arr , $ n ) { $ min_prefix_sum = 0 ; $ res = PHP_INT_MIN ; $ prefix_sum = array ( ) ; $ prefix_sum [ 0 ] = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ prefix_sum [ $ i ] = $ prefix_sum [ $ i - 1 ] + $ arr [ $ i ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ res = max ( $ res , $ prefix_sum [ $ i ] - $ min_prefix_sum ) ; $ min_prefix_sum = min ( $ min_prefix_sum , $ prefix_sum [ $ i ] ) ; } return $ res ; }
function isPath ( $ arr ) { global $ row , $ col ; $ arr [ 0 ] [ 0 ] = 1 ; for ( $ i = 1 ; $ i < $ row ; $ i ++ ) if ( $ arr [ $ i ] [ 0 ] != -1 ) $ arr [ $ i ] [ 0 ] = $ arr [ $ i - 1 ] [ 0 ] ; for ( $ j = 1 ; $ j < $ col ; $ j ++ ) if ( $ arr [ 0 ] [ $ j ] != -1 ) $ arr [ 0 ] [ $ j ] = $ arr [ 0 ] [ $ j - 1 ] ; for ( $ i = 1 ; $ i < $ row ; $ i ++ ) for ( $ j = 1 ; $ j < $ col ; $ j ++ ) if ( $ arr [ $ i ] [ $ j ] != -1 ) $ arr [ $ i ] [ $ j ] = max ( $ arr [ $ i ] [ $ j - 1 ] , $ arr [ $ i - 1 ] [ $ j ] ) ; return ( $ arr [ $ row - 1 ] [ $ col - 1 ] == 1 ) ; }
function countWays ( $ n ) { $ res [ 0 ] = 1 ; $ res [ 1 ] = 1 ; $ res [ 2 ] = 2 ; for ( $ i = 3 ; $ i <= $ n ; $ i ++ ) $ res [ $ i ] = $ res [ $ i - 1 ] + $ res [ $ i - 2 ] + $ res [ $ i - 3 ] ; return $ res [ $ n ] ; }
function numberofways ( $ n , $ m ) { global $ MAX ; $ dp = array_fill ( 0 , $ n + 2 , array_fill ( 0 , $ n + 2 , NULL ) ) ; $ dp [ 0 ] [ $ n + 1 ] = 1 ; for ( $ k = $ n ; $ k >= $ m ; $ k -- ) { for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) { $ dp [ $ i ] [ $ k ] = $ dp [ $ i ] [ $ k + 1 ] ; if ( $ i - $ k >= 0 ) $ dp [ $ i ] [ $ k ] = ( $ dp [ $ i ] [ $ k ] + $ dp [ $ i - $ k ] [ $ k ] ) ; } } return $ dp [ $ n ] [ $ m ] ; }
function zigzag ( $ n , $ k ) { if ( $ n == 0 and $ k == 0 ) return 1 ; if ( $ k == 0 ) return 0 ; return zigzag ( $ n , $ k - 1 ) + zigzag ( $ n - 1 , $ n - $ k ) ; }
function zigzag ( $ n , $ k ) { $ dp = array ( array ( ) ) ; $ dp [ 0 ] [ 0 ] = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ dp [ $ i ] [ 0 ] = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 1 ; $ j <= $ i ; $ j ++ ) $ dp [ $ i ] [ $ j ] = $ dp [ $ i ] [ $ j - 1 ] + $ dp [ $ i - 1 ] [ $ i - $ j ] ; } return $ dp [ $ n ] [ $ k ] ; }
function eulerian ( $ n , $ m ) { if ( $ m >= $ n $ n == 0 ) return 0 ; if ( $ m == 0 ) return 1 ; return ( $ n - $ m ) * eulerian ( $ n - 1 , $ m - 1 ) + ( $ m + 1 ) * eulerian ( $ n - 1 , $ m ) ; }
function eulerian ( $ n , $ m ) { $ dp = array ( array ( ) ) ; for ( $ i = 0 ; $ i < $ n + 1 ; $ i ++ ) for ( $ j = 0 ; $ j < $ m + 1 ; $ j ++ ) $ dp [ $ i ] [ $ j ] = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 0 ; $ j <= $ m ; $ j ++ ) { if ( $ i > $ j ) { if ( $ j == 0 ) $ dp [ $ i ] [ $ j ] = 1 ; else $ dp [ $ i ] [ $ j ] = ( ( $ i - $ j ) * $ dp [ $ i - 1 ] [ $ j - 1 ] ) + ( ( $ j + 1 ) * $ dp [ $ i - 1 ] [ $ j ] ) ; } } } return $ dp [ $ n ] [ $ m ] ; }
function nswp ( $ n ) { if ( $ n == 0 $ n == 1 ) return 1 ; return 2 * nswp ( $ n - 1 ) + nswp ( $ n - 2 ) ; }
function nswp ( $ n ) { $ dp [ 0 ] = $ dp [ 1 ] = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) $ dp [ $ i ] = 2 * $ dp [ $ i - 1 ] + $ dp [ $ i - 2 ] ; return $ dp [ $ n ] ; }
function longOddEvenIncSeq ( & $ arr , $ n ) { $ lioes = array_fill ( 0 , $ n , NULL ) ; $ maxLen = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ lioes [ $ i ] = 1 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ i ; $ j ++ ) if ( $ arr [ $ i ] > $ arr [ $ j ] && ( $ arr [ $ i ] + $ arr [ $ j ] ) % 2 != 0 && $ lioes [ $ i ] < $ lioes [ $ j ] + 1 ) $ lioes [ $ i ] = $ lioes [ $ j ] + 1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ maxLen < $ lioes [ $ i ] ) $ maxLen = $ lioes [ $ i ] ; return $ maxLen ; }
function dealnnoy ( $ n , $ m ) { if ( $ m == 0 or $ n == 0 ) return 1 ; return dealnnoy ( $ m - 1 , $ n ) + dealnnoy ( $ m - 1 , $ n - 1 ) + dealnnoy ( $ m , $ n - 1 ) ; }
function dealnnoy ( $ n , $ m ) { $ dp [ $ m + 1 ] [ $ n + 1 ] = 0 ; for ( $ i = 0 ; $ i <= $ m ; $ i ++ ) $ dp [ $ i ] [ 0 ] = 1 ; for ( $ i = 0 ; $ i <= $ m ; $ i ++ ) $ dp [ 0 ] [ $ i ] = 1 ; for ( $ i = 1 ; $ i <= $ m ; $ i ++ ) for ( $ j = 1 ; $ j <= $ n ; $ j ++ ) $ dp [ $ i ] [ $ j ] = $ dp [ $ i - 1 ] [ $ j ] + $ dp [ $ i - 1 ] [ $ j - 1 ] + $ dp [ $ i ] [ $ j - 1 ] ; return $ dp [ $ m ] [ $ n ] ; }
function longestAlternating ( $ arr , $ n ) { $ count = array ( ) ; $ count [ $ n - 1 ] = 1 ; for ( $ i = $ n - 2 ; $ i >= 0 ; $ i -- ) { if ( $ arr [ $ i ] * $ arr [ $ i + 1 ] < 0 ) $ count [ $ i ] = $ count [ $ i + 1 ] + 1 ; else $ count [ $ i ] = 1 ; } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ count [ $ i ] , " ▁ " ; }
function maxDP ( $ n ) { $ res [ 0 ] = 0 ; $ res [ 1 ] = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) $ res [ $ i ] = max ( $ i , ( $ res [ $ i / 2 ] + $ res [ $ i / 3 ] + $ res [ $ i / 4 ] + $ res [ $ i / 5 ] ) ) ; return $ res [ $ n ] ; }
function countarray ( $ n , $ k , $ x ) { $ dp = array ( 0 ) ; $ dp [ 0 ] = 0 ; $ dp [ 1 ] = 1 ; for ( $ i = 2 ; $ i < $ n ; $ i ++ ) $ dp [ $ i ] = ( $ k - 2 ) * $ dp [ $ i - 1 ] + ( $ k - 1 ) * $ dp [ $ i - 2 ] ; return ( $ x == 1 ? ( $ k - 1 ) * $ dp [ $ n - 2 ] : $ dp [ $ n - 1 ] ) ; }
function largestSubset ( $ a , $ n ) { $ dp = array ( ) ; $ dp [ $ n - 1 ] = 1 ; for ( $ i = $ n - 2 ; $ i >= 0 ; $ i -- ) { $ mxm = 0 ; for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) if ( $ a [ $ j ] % $ a [ $ i ] == 0 or $ a [ $ i ] % $ a [ $ j ] == 0 ) $ mxm = max ( $ mxm , $ dp [ $ j ] ) ; $ dp [ $ i ] = 1 + $ mxm ; } return max ( $ dp ) ; }
function maxSum ( $ mat , $ n ) { if ( $ n == 1 ) return $ mat [ 0 ] [ 0 ] ; $ dp = array ( array ( ) ) ; $ maxSum = PHP_INT_MIN ; $ max ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) $ dp [ $ n - 1 ] [ $ j ] = $ mat [ $ n - 1 ] [ $ j ] ; for ( $ i = $ n - 2 ; $ i >= 0 ; $ i -- ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { $ max = PHP_INT_MIN ; if ( ( ( $ j - 1 ) >= 0 ) and ( $ max < $ dp [ $ i + 1 ] [ $ j - 1 ] ) ) $ max = $ dp [ $ i + 1 ] [ $ j - 1 ] ; if ( ( ( $ j + 1 ) < $ n ) and ( $ max < $ dp [ $ i + 1 ] [ $ j + 1 ] ) ) $ max = $ dp [ $ i + 1 ] [ $ j + 1 ] ; $ dp [ $ i ] [ $ j ] = $ mat [ $ i ] [ $ j ] + $ max ; } } for ( $ j = 0 ; $ j < $ n ; $ j ++ ) if ( $ maxSum < $ dp [ 0 ] [ $ j ] ) $ maxSum = $ dp [ 0 ] [ $ j ] ; return $ maxSum ; }
function answer ( $ n ) { if ( $ n == 1 ) return 10 ; for ( $ j = 0 ; $ j <= 9 ; $ j ++ ) $ dp [ 1 ] [ $ j ] = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 0 ; $ j <= 9 ; $ j ++ ) { if ( $ j == 0 ) $ dp [ $ i ] [ $ j ] = $ dp [ $ i - 1 ] [ $ j + 1 ] ; else if ( $ j == 9 ) $ dp [ $ i ] [ $ j ] = $ dp [ $ i - 1 ] [ $ j - 1 ] ; else $ dp [ $ i ] [ $ j ] = $ dp [ $ i - 1 ] [ $ j - 1 ] + $ dp [ $ i - 1 ] [ $ j + 1 ] ; } } $ sum = 0 ; for ( $ j = 1 ; $ j <= 9 ; $ j ++ ) $ sum += $ dp [ $ n ] [ $ j ] ; return $ sum ; }
function maxLength ( $ s , $ n ) { $ dp = array_fill ( 0 , $ n , array_fill ( 0 , $ n , NULL ) ) ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) if ( $ s [ $ i ] == ' ( ' && $ s [ $ i + 1 ] == ' ) ' ) $ dp [ $ i ] [ $ i + 1 ] = 2 ; for ( $ l = 2 ; $ l < $ n ; $ l ++ ) { for ( $ i = 0 , $ j = $ l ; $ j < $ n ; $ i ++ , $ j ++ ) { if ( $ s [ $ i ] == ' ( ' && $ s [ $ j ] == ' ) ' ) $ dp [ $ i ] [ $ j ] = 2 + $ dp [ $ i + 1 ] [ $ j - 1 ] ; for ( $ k = $ i ; $ k < $ j ; $ k ++ ) $ dp [ $ i ] [ $ j ] = max ( $ dp [ $ i ] [ $ j ] , $ dp [ $ i ] [ $ k ] + $ dp [ $ k + 1 ] [ $ j ] ) ; } } return $ dp [ 0 ] [ $ n - 1 ] ; }
function numberOfWays ( $ x ) { if ( $ x == 0 $ x == 1 ) return 1 ; else return numberOfWays ( $ x - 1 ) + ( $ x - 1 ) * numberOfWays ( $ x - 2 ) ; }
function numberOfWays ( $ x ) { $ dp [ 0 ] = 1 ; $ dp [ 1 ] = 1 ; for ( $ i = 2 ; $ i <= $ x ; $ i ++ ) $ dp [ $ i ] = $ dp [ $ i - 1 ] + ( $ i - 1 ) * $ dp [ $ i - 2 ] ; return $ dp [ $ x ] ; }
function alternateSubarray ( & $ arr , $ n ) { $ len = array_fill ( 0 , $ n , NULL ) ; $ len [ $ n - 1 ] = 1 ; for ( $ i = $ n - 2 ; $ i >= 0 ; -- $ i ) { if ( $ arr [ $ i ] ^ $ arr [ $ i + 1 ] == 1 ) $ len [ $ i ] = $ len [ $ i + 1 ] + 1 ; else $ len [ $ i ] = 1 ; } for ( $ i = 0 ; $ i < $ n ; ++ $ i ) echo $ len [ $ i ] . " ▁ " ; }
function minCells ( $ mat , $ m , $ n ) { $ dp = array ( array ( ) ) ; for ( $ i = 0 ; $ i < $ m ; $ i ++ ) for ( $ j = 0 ; $ j < $ n ; $ j ++ ) $ dp [ $ i ] [ $ j ] = PHP_INT_MAX ; $ dp [ 0 ] [ 0 ] = 1 ; for ( $ i = 0 ; $ i < $ m ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ dp [ $ i ] [ $ j ] != PHP_INT_MAX and ( $ j + $ mat [ $ i ] [ $ j ] ) < $ n and ( $ dp [ $ i ] [ $ j ] + 1 ) < $ dp [ $ i ] [ $ j + $ mat [ $ i ] [ $ j ] ] ) $ dp [ $ i ] [ $ j + $ mat [ $ i ] [ $ j ] ] = $ dp [ $ i ] [ $ j ] + 1 ; if ( $ dp [ $ i ] [ $ j ] != PHP_INT_MAX and ( $ i + $ mat [ $ i ] [ $ j ] ) < $ m and ( $ dp [ $ i ] [ $ j ] + 1 ) < $ dp [ $ i + $ mat [ $ i ] [ $ j ] ] [ $ j ] ) $ dp [ $ i + $ mat [ $ i ] [ $ j ] ] [ $ j ] = $ dp [ $ i ] [ $ j ] + 1 ; } } if ( $ dp [ $ m - 1 ] [ $ n - 1 ] != PHP_INT_MAX ) return $ dp [ $ m - 1 ] [ $ n - 1 ] ; return -1 ; }
function maxSumBitonicSubArr ( $ arr , $ n ) { $ msis = array ( ) ; $ msds = array ( ) ; $ max_sum = PHP_INT_MIN ; $ msis [ 0 ] = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] > $ arr [ $ i - 1 ] ) $ msis [ $ i ] = $ msis [ $ i - 1 ] + $ arr [ $ i ] ; else $ msis [ $ i ] = $ arr [ $ i ] ; $ msds [ $ n - 1 ] = $ arr [ $ n - 1 ] ; for ( $ i = $ n - 2 ; $ i >= 0 ; $ i -- ) if ( $ arr [ $ i ] > $ arr [ $ i + 1 ] ) $ msds [ $ i ] = $ msds [ $ i + 1 ] + $ arr [ $ i ] ; else $ msds [ $ i ] = $ arr [ $ i ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ max_sum < ( $ msis [ $ i ] + $ msds [ $ i ] - $ arr [ $ i ] ) ) $ max_sum = $ msis [ $ i ] + $ msds [ $ i ] - $ arr [ $ i ] ; return $ max_sum ; }
function countWays ( $ n ) { $ dp [ 0 ] [ 1 ] = 1 ; $ dp [ 1 ] [ 1 ] = 2 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { $ dp [ 0 ] [ $ i ] = $ dp [ 0 ] [ $ i - 1 ] + $ dp [ 1 ] [ $ i - 1 ] ; $ dp [ 1 ] [ $ i ] = $ dp [ 0 ] [ $ i - 1 ] * 2 + $ dp [ 1 ] [ $ i - 1 ] ; } return $ dp [ 0 ] [ $ n ] + $ dp [ 1 ] [ $ n ] ; }
function maxLenSub ( $ arr , $ n ) { $ mls = array ( ) ; $ max = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ mls [ $ i ] = 1 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ i ; $ j ++ ) if ( abs ( $ arr [ $ i ] - $ arr [ $ j ] ) <= 1 and $ mls [ $ i ] < $ mls [ $ j ] + 1 ) $ mls [ $ i ] = $ mls [ $ j ] + 1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ max < $ mls [ $ i ] ) $ max = $ mls [ $ i ] ; return $ max ; }
function findWinner ( $ x , $ y , $ n ) { $ dp = array ( ) ; $ dp [ 0 ] = false ; $ dp [ 1 ] = true ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { if ( $ i - 1 >= 0 and ! $ dp [ $ i - 1 ] ) $ dp [ $ i ] = true ; else if ( $ i - $ x >= 0 and ! $ dp [ $ i - $ x ] ) $ dp [ $ i ] = true ; else if ( $ i - $ y >= 0 and ! $ dp [ $ i - $ y ] ) $ dp [ $ i ] = true ; else $ dp [ $ i ] = false ; } return $ dp [ $ n ] ; }
function maxGameByWinner ( $ N ) { $ dp [ $ N ] = 0 ; $ dp [ 0 ] = 1 ; $ dp [ 1 ] = 2 ; $ i = 2 ; do { $ dp [ $ i ] = $ dp [ $ i - 1 ] + $ dp [ $ i - 2 ] ; } while ( $ dp [ $ i ++ ] <= $ N ) ; return ( $ i - 2 ) ; }
function isSubsetSum ( $ arr , $ n , $ sum ) { $ subset [ 2 ] [ $ sum + 1 ] = array ( ) ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 0 ; $ j <= $ sum ; $ j ++ ) { if ( $ j == 0 ) $ subset [ $ i % 2 ] [ $ j ] = true ; else if ( $ i == 0 ) $ subset [ $ i % 2 ] [ $ j ] = false ; else if ( $ arr [ $ i - 1 ] <= $ j ) $ subset [ $ i % 2 ] [ $ j ] = $ subset [ ( $ i + 1 ) % 2 ] [ $ j - $ arr [ $ i - 1 ] ] || $ subset [ ( $ i + 1 ) % 2 ] [ $ j ] ; else $ subset [ $ i % 2 ] [ $ j ] = $ subset [ ( $ i + 1 ) % 2 ] [ $ j ] ; } } return $ subset [ $ n % 2 ] [ $ sum ] ; }
function minRemove ( $ arr , $ n ) { $ LIS = array ( ) ; $ len = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ LIS [ $ i ] = 1 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ i ; $ j ++ ) { if ( $ arr [ $ i ] > $ arr [ $ j ] ) $ LIS [ $ i ] = max ( $ LIS [ $ i ] , $ LIS [ $ j ] + 1 ) ; } $ len = max ( $ len , $ LIS [ $ i ] ) ; } return $ n - $ len ; }
function smallestSumSubarr ( $ arr , $ n ) { $ min_ending_here = 999999 ; $ min_so_far = 999999 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ min_ending_here > 0 ) $ min_ending_here = $ arr [ $ i ] ; else $ min_ending_here += $ arr [ $ i ] ; $ min_so_far = min ( $ min_so_far , $ min_ending_here ) ; } return $ min_so_far ; }
function nonDecNums ( $ n ) { for ( $ i = 0 ; $ i <= 9 ; $ i ++ ) $ a [ 0 ] [ $ i ] = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ a [ $ i ] [ 9 ] = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) for ( $ j = 8 ; $ j >= 0 ; $ j -- ) $ a [ $ i ] [ $ j ] = $ a [ $ i - 1 ] [ $ j ] + $ a [ $ i ] [ $ j + 1 ] ; return $ a [ $ n ] [ 0 ] ; }
function countWays ( $ n , $ k ) { $ total = $ k ; $ mod = 1000000007 ; $ same = 0 ; $ diff = $ k ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { $ same = $ diff ; $ diff = $ total * ( $ k - 1 ) ; $ diff = $ diff % $ mod ; $ total = ( $ same + $ diff ) % $ mod ; } return $ total ; }
function countBT ( $ h ) { global $ mod ; $ dp [ 0 ] = $ dp [ 1 ] = 1 ; for ( $ i = 2 ; $ i <= $ h ; $ i ++ ) { $ dp [ $ i ] = ( $ dp [ $ i - 1 ] * ( ( 2 * $ dp [ $ i - 2 ] ) % $ mod + $ dp [ $ i - 1 ] ) % $ mod ) % $ mod ; } return $ dp [ $ h ] ; }
function countPaths ( $ n , $ m ) { if ( $ n == 0 $ m == 0 ) return 1 ; return ( countPaths ( $ n - 1 , $ m ) + countPaths ( $ n , $ m - 1 ) ) ; }
function countPaths ( $ n , $ m ) { for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) $ dp [ $ i ] [ 0 ] = 1 ; for ( $ i = 0 ; $ i <= $ m ; $ i ++ ) $ dp [ 0 ] [ $ i ] = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) for ( $ j = 1 ; $ j <= $ m ; $ j ++ ) $ dp [ $ i ] [ $ j ] = $ dp [ $ i - 1 ] [ $ j ] + $ dp [ $ i ] [ $ j - 1 ] ; return $ dp [ $ n ] [ $ m ] ; }
function sumOfSubstrings ( $ num ) { $ sum = 0 ; $ mf = 1 ; for ( $ i = strlen ( $ num ) - 1 ; $ i >= 0 ; $ i -- ) { $ sum += ( $ num [ $ i ] - '0' ) * ( $ i + 1 ) * $ mf ; $ mf = $ mf * 10 + 1 ; } return $ sum ; }
function countWays ( $ n , $ m ) { $ count [ 0 ] = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { if ( $ i > $ m ) $ count [ $ i ] = $ count [ $ i - 1 ] + $ count [ $ i - $ m ] ; else if ( $ i < $ m or $ i == 1 ) $ count [ $ i ] = 1 ; else $ count [ $ i ] = 2 ; } return $ count [ $ n ] ; }
function maxSum ( $ grid , $ n ) { $ incl = max ( $ grid [ 0 ] [ 0 ] , $ grid [ 1 ] [ 0 ] ) ; $ excl = 0 ; $ excl_new ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ excl_new = max ( $ excl , $ incl ) ; $ incl = $ excl + max ( $ grid [ 0 ] [ $ i ] , $ grid [ 1 ] [ $ i ] ) ; $ excl = $ excl_new ; } return max ( $ excl , $ incl ) ; }
function getTotalNumberOfSequences ( $ m , $ n ) { if ( $ m < $ n ) return 0 ; if ( $ n == 0 ) return 1 ; return getTotalNumberOfSequences ( $ m - 1 , $ n ) + getTotalNumberOfSequences ( $ m / 2 , $ n - 1 ) ; }
function getTotalNumberOfSequences ( $ m , $ n ) { $ T = array ( array ( ) ) ; for ( $ i = 0 ; $ i < $ m + 1 ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n + 1 ; $ j ++ ) { if ( $ i == 0 or $ j == 0 ) $ T [ $ i ] [ $ j ] = 0 ; else if ( $ i < $ j ) $ T [ $ i ] [ $ j ] = 0 ; else if ( $ j == 1 ) $ T [ $ i ] [ $ j ] = $ i ; else $ T [ $ i ] [ $ j ] = $ T [ $ i - 1 ] [ $ j ] + $ T [ $ i / 2 ] [ $ j - 1 ] ; } } return $ T [ $ m ] [ $ n ] ; }
function minInsertionStepToSortArray ( $ arr , $ N ) { $ lis [ $ N ] = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) $ lis [ $ i ] = 1 ; for ( $ i = 1 ; $ i < $ N ; $ i ++ ) for ( $ j = 0 ; $ j < $ i ; $ j ++ ) if ( $ arr [ $ i ] >= $ arr [ $ j ] && $ lis [ $ i ] < $ lis [ $ j ] + 1 ) $ lis [ $ i ] = $ lis [ $ j ] + 1 ; $ max = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) if ( $ max < $ lis [ $ i ] ) $ max = $ lis [ $ i ] ; return ( $ N - $ max ) ; }
function countWaysToJump ( $ arr , $ n ) { $ count_jump ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ count_jump [ $ i ] = 0 ; for ( $ i = $ n - 2 ; $ i >= 0 ; $ i -- ) { if ( $ arr [ $ i ] >= $ n - $ i - 1 ) $ count_jump [ $ i ] ++ ; for ( $ j = $ i + 1 ; $ j < $ n - 1 && $ j <= $ arr [ $ i ] + $ i ; $ j ++ ) if ( $ count_jump [ $ j ] != -1 ) $ count_jump [ $ i ] += $ count_jump [ $ j ] ; if ( $ count_jump [ $ i ] == 0 ) $ count_jump [ $ i ] = -1 ; } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ count_jump [ $ i ] . " ▁ " ; }
function minStepToDeleteString ( $ str ) { $ N = strlen ( $ str ) ; $ dp [ $ N + 1 ] [ $ N + 1 ] = array ( array ( ) ) ; for ( $ i = 0 ; $ i <= $ N ; $ i ++ ) for ( $ j = 0 ; $ j <= $ N ; $ j ++ ) $ dp [ $ i ] [ $ j ] = 0 ; for ( $ len = 1 ; $ len <= $ N ; $ len ++ ) { for ( $ i = 0 , $ j = $ len - 1 ; $ j < $ N ; $ i ++ , $ j ++ ) { if ( $ len == 1 ) $ dp [ $ i ] [ $ j ] = 1 ; else { $ dp [ $ i ] [ $ j ] = 1 + $ dp [ $ i + 1 ] [ $ j ] ; if ( $ str [ $ i ] == $ str [ $ i + 1 ] ) $ dp [ $ i ] [ $ j ] = min ( 1 + $ dp [ $ i + 2 ] [ $ j ] , $ dp [ $ i ] [ $ j ] ) ; for ( $ K = $ i + 2 ; $ K <= $ j ; $ K ++ ) if ( $ str [ $ i ] == $ str [ $ K ] ) $ dp [ $ i ] [ $ j ] = min ( $ dp [ $ i + 1 ] [ $ K - 1 ] + $ dp [ $ K + 1 ] [ $ j ] , $ dp [ $ i ] [ $ j ] ) ; } } } return $ dp [ 0 ] [ $ N - 1 ] ; }
function solve ( $ i , $ par , & $ a , $ n , $ k , $ current_ans ) { global $ inf , $ ans ; if ( $ par > $ k ) return ; if ( $ par == $ k && $ i == $ n - 1 ) { $ ans = min ( $ ans , $ current_ans ) ; return ; } for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) solve ( $ j , $ par + 1 , $ a , $ n , $ k , $ current_ans + ( $ a [ $ j ] - $ a [ $ i + 1 ] ) * ( $ a [ $ j ] - $ a [ $ i + 1 ] ) ) ; }
function modularSum ( $ arr , $ n , $ m ) { if ( $ n > $ m ) return true ; $ DP = Array_fill ( 0 , $ m , false ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ DP [ 0 ] ) return true ; $ temp = array_fill ( 0 , $ m , false ) ; for ( $ j = 0 ; $ j < $ m ; $ j ++ ) { if ( $ DP [ $ j ] == true ) { if ( $ DP [ ( $ j + $ arr [ $ i ] ) % $ m ] == false ) $ temp [ ( $ j + $ arr [ $ i ] ) % $ m ] = true ; } } for ( $ j = 0 ; $ j < $ m ; $ j ++ ) if ( $ temp [ $ j ] ) $ DP [ $ j ] = true ; $ DP [ $ arr [ $ i ] % $ m ] = true ; } return $ DP [ 0 ] ; }
function countSubsequences ( $ s ) { $ aCount = 0 ; $ bCount = 0 ; $ cCount = 0 ; for ( $ i = 0 ; $ i < strlen ( $ s ) ; $ i ++ ) { if ( $ s [ $ i ] == ' a ' ) $ aCount = ( 1 + 2 * $ aCount ) ; else if ( $ s [ $ i ] == ' b ' ) $ bCount = ( $ aCount + 2 * $ bCount ) ; else if ( $ s [ $ i ] == ' c ' ) $ cCount = ( $ bCount + 2 * $ cCount ) ; } return $ cCount ; }
function maximumDifferenceSum ( $ arr , $ N ) { $ dp = array ( array ( ) ) ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) $ dp [ $ i ] [ 0 ] = $ dp [ $ i ] [ 1 ] = 0 ; for ( $ i = 0 ; $ i < ( $ N - 1 ) ; $ i ++ ) { $ dp [ $ i + 1 ] [ 0 ] = max ( $ dp [ $ i ] [ 0 ] , $ dp [ $ i ] [ 1 ] + abs ( 1 - $ arr [ $ i ] ) ) ; $ dp [ $ i + 1 ] [ 1 ] = max ( $ dp [ $ i ] [ 0 ] + abs ( $ arr [ $ i + 1 ] - 1 ) , $ dp [ $ i ] [ 1 ] + abs ( $ arr [ $ i + 1 ] - $ arr [ $ i ] ) ) ; } return max ( $ dp [ $ N - 1 ] [ 0 ] , $ dp [ $ N - 1 ] [ 1 ] ) ; }
function countStr ( $ n , $ bCount , $ cCount ) { if ( $ bCount < 0 $ cCount < 0 ) return 0 ; if ( $ n == 0 ) return 1 ; if ( $ bCount == 0 && $ cCount == 0 ) return 1 ; $ res = countStr ( $ n - 1 , $ bCount , $ cCount ) ; $ res += countStr ( $ n - 1 , $ bCount - 1 , $ cCount ) ; $ res += countStr ( $ n - 1 , $ bCount , $ cCount - 1 ) ; return $ res ; }
function maxRevenue ( $ m , $ x , $ revenue , $ n , $ t ) { $ maxRev = array_fill ( 0 , $ m + 1 , false ) ; $ nxtbb = 0 ; for ( $ i = 1 ; $ i <= $ m ; $ i ++ ) { if ( $ nxtbb < $ n ) { if ( $ x [ $ nxtbb ] != $ i ) $ maxRev [ $ i ] = $ maxRev [ $ i - 1 ] ; else { if ( $ i <= $ t ) $ maxRev [ $ i ] = max ( $ maxRev [ $ i - 1 ] , $ revenue [ $ nxtbb ] ) ; else $ maxRev [ $ i ] = max ( $ maxRev [ $ i - $ t - 1 ] + $ revenue [ $ nxtbb ] , $ maxRev [ $ i - 1 ] ) ; $ nxtbb ++ ; } } else $ maxRev [ $ i ] = $ maxRev [ $ i - 1 ] ; } return $ maxRev [ $ m ] ; }
function getMaxGold ( $ gold , $ m , $ n ) { $ MAX = 100 ; $ goldTable = array ( array ( ) ) ; for ( $ i = 0 ; $ i < $ m ; $ i ++ ) for ( $ j = 0 ; $ j < $ n ; $ j ++ ) $ goldTable [ $ i ] [ $ j ] = 0 ; for ( $ col = $ n - 1 ; $ col >= 0 ; $ col -- ) { for ( $ row = 0 ; $ row < $ m ; $ row ++ ) { if ( $ col == $ n - 1 ) $ right = 0 ; else $ right = $ goldTable [ $ row ] [ $ col + 1 ] ; if ( $ row == 0 or $ col == $ n - 1 ) $ right_up = 0 ; else $ right_up = $ goldTable [ $ row - 1 ] [ $ col + 1 ] ; if ( $ row == $ m - 1 or $ col == $ n - 1 ) $ right_down = 0 ; else $ right_down = $ goldTable [ $ row + 1 ] [ $ col + 1 ] ; $ goldTable [ $ row ] [ $ col ] = $ gold [ $ row ] [ $ col ] + max ( $ right , $ right_up , $ right_down ) ; } } $ res = $ goldTable [ 0 ] [ 0 ] ; for ( $ i = 0 ; $ i < $ m ; $ i ++ ) $ res = max ( $ res , $ goldTable [ $ i ] [ 0 ] ) ; return $ res ; }
function largestKSubmatrix ( & $ a ) { global $ Row , $ Col ; $ result = 0 ; for ( $ i = 0 ; $ i < $ Row ; $ i ++ ) { for ( $ j = 0 ; $ j < $ Col ; $ j ++ ) { if ( $ i == 0 $ j == 0 ) $ dp [ $ i ] [ $ j ] = 1 ; else { if ( $ a [ $ i ] [ $ j ] == $ a [ $ i - 1 ] [ $ j ] && $ a [ $ i ] [ $ j ] == $ a [ $ i ] [ $ j - 1 ] && $ a [ $ i ] [ $ j ] == $ a [ $ i - 1 ] [ $ j - 1 ] ) $ dp [ $ i ] [ $ j ] = min ( min ( $ dp [ $ i - 1 ] [ $ j ] , $ dp [ $ i ] [ $ j - 1 ] ) , $ dp [ $ i - 1 ] [ $ j - 1 ] ) + 1 ; else $ dp [ $ i ] [ $ j ] = 1 ; } $ result = max ( $ result , $ dp [ $ i ] [ $ j ] ) ; } } return $ result ; }
function MaximumPath ( & $ Mat ) { global $ N ; $ result = 0 ; $ dp = array_fill ( 0 , $ N , array_fill ( 0 , $ N + 2 , NULL ) ) ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) $ dp [ 0 ] [ $ i + 1 ] = $ Mat [ 0 ] [ $ i ] ; for ( $ i = 1 ; $ i < $ N ; $ i ++ ) for ( $ j = 1 ; $ j <= $ N ; $ j ++ ) $ dp [ $ i ] [ $ j ] = max ( $ dp [ $ i - 1 ] [ $ j - 1 ] , max ( $ dp [ $ i - 1 ] [ $ j ] , $ dp [ $ i - 1 ] [ $ j + 1 ] ) ) + $ Mat [ $ i ] [ $ j - 1 ] ; for ( $ i = 0 ; $ i <= $ N ; $ i ++ ) $ result = max ( $ result , $ dp [ $ N - 1 ] [ $ i ] ) ; return $ result ; }
function countStrings ( $ n , $ k ) { $ dp = array_fill ( 0 , $ n + 1 , array_fill ( 0 , $ k + 1 , array_fill ( 0 , 2 , 0 ) ) ) ; $ dp [ 1 ] [ 0 ] [ 0 ] = 1 ; $ dp [ 1 ] [ 0 ] [ 1 ] = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ i ; $ j ++ ) { if ( isset ( $ dp [ $ i ] [ $ j ] [ 0 ] ) || isset ( $ dp [ $ i ] [ $ j ] [ 1 ] ) ) { $ dp [ $ i ] [ $ j ] [ 0 ] = $ dp [ $ i - 1 ] [ $ j ] [ 0 ] + $ dp [ $ i - 1 ] [ $ j ] [ 1 ] ; $ dp [ $ i ] [ $ j ] [ 1 ] = $ dp [ $ i - 1 ] [ $ j ] [ 0 ] ; } if ( $ j - 1 >= 0 && isset ( $ dp [ $ i ] [ $ j ] [ 1 ] ) ) $ dp [ $ i ] [ $ j ] [ 1 ] += $ dp [ $ i - 1 ] [ $ j - 1 ] [ 1 ] ; } } return $ dp [ $ n ] [ $ k ] [ 0 ] + $ dp [ $ n ] [ $ k ] [ 1 ] ; }
function countFriendsPairings ( $ n ) { $ dp [ $ n + 1 ] = 0 ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) { if ( $ i <= 2 ) $ dp [ $ i ] = $ i ; else $ dp [ $ i ] = $ dp [ $ i - 1 ] + ( $ i - 1 ) * $ dp [ $ i - 2 ] ; } return $ dp [ $ n ] ; }
function countFriendsPairings ( $ n ) { $ dp = array_fill ( 0 , 1000 , -1 ) ; if ( $ dp [ $ n ] != -1 ) return $ dp [ $ n ] ; if ( $ n > 2 ) { $ dp [ $ n ] = countFriendsPairings ( $ n - 1 ) + ( $ n - 1 ) * countFriendsPairings ( $ n - 2 ) ; return $ dp [ $ n ] ; } else { $ dp [ $ n ] = $ n ; return $ dp [ $ n ] ; } }
function maxPathSum ( $ tri , $ m , $ n ) { for ( $ i = $ m - 1 ; $ i >= 0 ; $ i -- ) { for ( $ j = 0 ; $ j <= $ i ; $ j ++ ) { if ( $ tri [ $ i + 1 ] [ $ j ] > $ tri [ $ i + 1 ] [ $ j + 1 ] ) $ tri [ $ i ] [ $ j ] += $ tri [ $ i + 1 ] [ $ j ] ; else $ tri [ $ i ] [ $ j ] += $ tri [ $ i + 1 ] [ $ j + 1 ] ; } } return $ tri [ 0 ] [ 0 ] ; }
function lcsOf3 ( $ X , $ Y , $ Z , $ m , $ n , $ o ) { $ L [ $ m + 1 ] [ $ n + 1 ] [ $ o + 1 ] = array ( array ( array ( ) ) ) ; for ( $ i = 0 ; $ i <= $ m ; $ i ++ ) { for ( $ j = 0 ; $ j <= $ n ; $ j ++ ) { for ( $ k = 0 ; $ k <= $ o ; $ k ++ ) { if ( $ i == 0 $ j == 0 $ k == 0 ) $ L [ $ i ] [ $ j ] [ $ k ] = 0 ; else if ( $ X [ $ i - 1 ] == $ Y [ $ j - 1 ] && $ X [ $ i - 1 ] == $ Z [ $ k - 1 ] ) $ L [ $ i ] [ $ j ] [ $ k ] = $ L [ $ i - 1 ] [ $ j - 1 ] [ $ k - 1 ] + 1 ; else $ L [ $ i ] [ $ j ] [ $ k ] = max ( max ( $ L [ $ i - 1 ] [ $ j ] [ $ k ] , $ L [ $ i ] [ $ j - 1 ] [ $ k ] ) , $ L [ $ i ] [ $ j ] [ $ k - 1 ] ) ; } } } return $ L [ $ m ] [ $ n ] [ $ o ] ; }
function printMaxSum ( $ arr , $ n ) { $ dp = array ( ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ dp [ $ i ] = $ arr [ $ i ] ; $ maxi = 0 ; for ( $ j = 1 ; $ j <= sqrt ( $ i + 1 ) ; $ j ++ ) { if ( ( ( $ i + 1 ) % $ j == 0 ) && ( $ i + 1 ) != $ j ) { if ( $ dp [ $ j - 1 ] > $ maxi ) $ maxi = $ dp [ $ j - 1 ] ; if ( $ dp [ ( $ i + 1 ) / $ j - 1 ] > $ maxi && $ j != 1 ) $ maxi = $ dp [ ( $ i + 1 ) / $ j - 1 ] ; } } $ dp [ $ i ] += $ maxi ; } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ dp [ $ i ] , " ▁ " ; }
function longestSubseqWithDiffOne ( $ arr , $ n ) { $ dp [ $ n ] = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ dp [ $ i ] = 1 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ i ; $ j ++ ) { if ( ( $ arr [ $ i ] == $ arr [ $ j ] + 1 ) || ( $ arr [ $ i ] == $ arr [ $ j ] - 1 ) ) $ dp [ $ i ] = max ( $ dp [ $ i ] , $ dp [ $ j ] + 1 ) ; } } $ result = 1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ result < $ dp [ $ i ] ) $ result = $ dp [ $ i ] ; return $ result ; }
function maxSumWO3Consec ( $ arr , $ n ) { $ sum = array ( ) ; if ( $ n >= 1 ) $ sum [ 0 ] = $ arr [ 0 ] ; if ( $ n >= 2 ) $ sum [ 1 ] = $ arr [ 0 ] + $ arr [ 1 ] ; if ( $ n > 2 ) $ sum [ 2 ] = max ( $ sum [ 1 ] , max ( $ arr [ 1 ] + $ arr [ 2 ] , $ arr [ 0 ] + $ arr [ 2 ] ) ) ; for ( $ i = 3 ; $ i < $ n ; $ i ++ ) $ sum [ $ i ] = max ( max ( $ sum [ $ i - 1 ] , $ sum [ $ i - 2 ] + $ arr [ $ i ] ) , $ arr [ $ i ] + $ arr [ $ i - 1 ] + $ sum [ $ i - 3 ] ) ; return $ sum [ $ n - 1 ] ; }
function maxSumWO3Consec ( $ n ) { global $ sum , $ arr ; if ( $ sum [ $ n ] != -1 ) return $ sum [ $ n ] ; if ( $ n == 0 ) return $ sum [ $ n ] = 0 ; if ( $ n == 1 ) return $ sum [ $ n ] = $ arr [ 0 ] ; if ( $ n == 2 ) return $ sum [ $ n ] = $ arr [ 1 ] + $ arr [ 0 ] ; return $ sum [ $ n ] = max ( max ( maxSumWO3Consec ( $ n - 1 ) , maxSumWO3Consec ( $ n - 2 ) + $ arr [ $ n ] ) , $ arr [ $ n ] + $ arr [ $ n - 1 ] + maxSumWO3Consec ( $ n - 3 ) ) ; }
function pad ( $ n ) { $ pPrevPrev = 1 ; $ pPrev = 1 ; $ pCurr = 1 ; $ pNext = 1 ; for ( $ i = 3 ; $ i <= $ n ; $ i ++ ) { $ pNext = $ pPrevPrev + $ pPrev ; $ pPrevPrev = $ pPrev ; $ pPrev = $ pCurr ; $ pCurr = $ pNext ; } return $ pNext ; }
function maxSumPairWithDifferenceLessThanK ( $ arr , $ N , $ K ) { sort ( $ arr ) ; $ dp = array ( ) ; $ dp [ 0 ] = 0 ; for ( $ i = 1 ; $ i < $ N ; $ i ++ ) { $ dp [ $ i ] = $ dp [ $ i - 1 ] ; if ( $ arr [ $ i ] - $ arr [ $ i - 1 ] < $ K ) { if ( $ i >= 2 ) $ dp [ $ i ] = max ( $ dp [ $ i ] , $ dp [ $ i - 2 ] + $ arr [ $ i ] + $ arr [ $ i - 1 ] ) ; else $ dp [ $ i ] = max ( $ dp [ $ i ] , $ arr [ $ i ] + $ arr [ $ i - 1 ] ) ; } } return $ dp [ $ N - 1 ] ; }
function maxSumPairWithDifferenceLessThanK ( $ arr , $ N , $ k ) { $ maxSum = 0 ; sort ( $ arr ) ; for ( $ i = $ N - 1 ; $ i > 0 ; -- $ i ) { if ( $ arr [ $ i ] - $ arr [ $ i - 1 ] < $ k ) { $ maxSum += $ arr [ $ i ] ; $ maxSum += $ arr [ $ i - 1 ] ; -- $ i ; } } return $ maxSum ; }
function lucas ( $ n ) { $ a = 2 ; $ b = 1 ; $ c ; $ i ; if ( $ n == 0 ) return $ a ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { $ c = $ a + $ b ; $ a = $ b ; $ b = $ c ; } return $ b ; }
function maxAverageOfPath ( $ cost , $ N ) { $ dp = array ( array ( ) ) ; $ dp [ 0 ] [ 0 ] = $ cost [ 0 ] [ 0 ] ; for ( $ i = 1 ; $ i < $ N ; $ i ++ ) $ dp [ $ i ] [ 0 ] = $ dp [ $ i - 1 ] [ 0 ] + $ cost [ $ i ] [ 0 ] ; for ( $ j = 1 ; $ j < $ N ; $ j ++ ) $ dp [ 0 ] [ $ j ] = $ dp [ 0 ] [ $ j - 1 ] + $ cost [ 0 ] [ $ j ] ; for ( $ i = 1 ; $ i < $ N ; $ i ++ ) { for ( $ j = 1 ; $ j <= $ N ; $ j ++ ) $ dp [ $ i ] [ $ j ] = max ( $ dp [ $ i - 1 ] [ $ j ] , $ dp [ $ i ] [ $ j - 1 ] ) + $ cost [ $ i ] [ $ j ] ; } return $ dp [ $ N - 1 ] [ $ N - 1 ] / ( 2 * $ N - 1 ) ; }
function breakSum ( $ n ) { if ( $ n == 0 $ n == 1 ) return $ n ; return max ( ( breakSum ( intval ( $ n / 2 ) ) + breakSum ( intval ( $ n / 3 ) ) + breakSum ( intval ( $ n / 4 ) ) ) , $ n ) ; }
function breakSum ( $ n ) { $ dp = array_fill ( 0 , $ n + 1 , 0 ) ; $ dp [ 0 ] = 0 ; $ dp [ 1 ] = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) $ dp [ $ i ] = max ( $ dp [ ( int ) ( $ i / 2 ) ] + $ dp [ ( int ) ( $ i / 3 ) ] + $ dp [ ( int ) ( $ i / 4 ) ] , $ i ) ; return $ dp [ $ n ] ; }
function countPS ( $ str ) { $ N = strlen ( $ str ) ; $ cps = array_fill ( 0 , $ N + 1 , array_fill ( 0 , $ N + 1 , NULL ) ) ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) $ cps [ $ i ] [ $ i ] = 1 ; for ( $ L = 2 ; $ L <= $ N ; $ L ++ ) { for ( $ i = 0 ; $ i <= $ N - $ L ; $ i ++ ) { $ k = $ L + $ i - 1 ; if ( $ str [ $ i ] == $ str [ $ k ] ) $ cps [ $ i ] [ $ k ] = $ cps [ $ i ] [ $ k - 1 ] + $ cps [ $ i + 1 ] [ $ k ] + 1 ; else $ cps [ $ i ] [ $ k ] = $ cps [ $ i ] [ $ k - 1 ] + $ cps [ $ i + 1 ] [ $ k ] - $ cps [ $ i + 1 ] [ $ k - 1 ] ; } } return $ cps [ 0 ] [ $ N - 1 ] ; }
function countPS ( $ i , $ j ) { global $ str , $ dp , $ n ; if ( $ i > $ j ) return 0 ; if ( $ dp [ $ i ] [ $ j ] != -1 ) return $ dp [ $ i ] [ $ j ] ; if ( $ i == $ j ) return $ dp [ $ i ] [ $ j ] = 1 ; else if ( $ str [ $ i ] == $ str [ $ j ] ) return $ dp [ $ i ] [ $ j ] = countPS ( $ i + 1 , $ j ) + countPS ( $ i , $ j - 1 ) + 1 ; else return $ dp [ $ i ] [ $ j ] = countPS ( $ i + 1 , $ j ) + countPS ( $ i , $ j - 1 ) - countPS ( $ i + 1 , $ j - 1 ) ; }
function maxCost ( $ mat , $ N ) { $ dp = array ( array ( ) ) ; memset ( dp , 0 , sizeof ( dp ) ) ; $ dp [ 0 ] [ 0 ] = $ mat [ 0 ] [ 0 ] ; for ( $ i = 1 ; $ i < $ N ; $ i ++ ) $ dp [ $ i ] [ 0 ] = $ mat [ $ i ] [ 0 ] + $ dp [ $ i - 1 ] [ 0 ] ; for ( $ i = 1 ; $ i < $ N ; $ i ++ ) { for ( $ j = 1 ; $ j < $ i + 1 && $ j < $ N ; $ j ++ ) $ dp [ $ i ] [ $ j ] = $ mat [ $ i ] [ $ j ] + max ( $ dp [ $ i - 1 ] [ $ j - 1 ] , $ dp [ $ i - 1 ] [ $ j ] ) ; } $ result = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) if ( $ result < $ dp [ $ N - 1 ] [ $ i ] ) $ result = $ dp [ $ N - 1 ] [ $ i ] ; return $ result ; }
function countGroups ( $ position , $ previous_sum , $ length , $ num ) { if ( $ position == $ length ) return 1 ; $ res = 0 ; $ sum = 0 ; for ( $ i = $ position ; $ i < $ length ; $ i ++ ) { $ sum += ( $ num [ $ i ] - '0' ) ; if ( $ sum >= $ previous_sum ) $ res += countGroups ( $ i + 1 , $ sum , $ length , $ num ) ; } return $ res ; }
function count_1 ( $ a , $ b , $ m , $ n ) { if ( ( $ m == 0 && $ n == 0 ) $ n == 0 ) return 1 ; if ( $ m == 0 ) return 0 ; if ( $ a [ $ m - 1 ] == $ b [ $ n - 1 ] ) return count_1 ( $ a , $ b , $ m - 1 , $ n - 1 ) + count_1 ( $ a , $ b , $ m - 1 , $ n ) ; else return count_1 ( $ a , $ b , $ m - 1 , $ n ) ; }
function minAdjustmentCost ( $ A , $ n , $ target ) { global $ M ; $ dp = array ( array ( ) ) ; for ( $ j = 0 ; $ j <= $ M ; $ j ++ ) $ dp [ 0 ] [ $ j ] = abs ( $ j - $ A [ 0 ] ) ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j <= $ M ; $ j ++ ) { $ dp [ $ i ] [ $ j ] = PHP_INT_MAX ; for ( $ k = max ( $ j - $ target , 0 ) ; $ k <= min ( $ M , $ j + $ target ) ; $ k ++ ) $ dp [ $ i ] [ $ j ] = min ( $ dp [ $ i ] [ $ j ] , $ dp [ $ i - 1 ] [ $ k ] + abs ( $ A [ $ i ] - $ j ) ) ; } } $ res = PHP_INT_MAX ; for ( $ j = 0 ; $ j <= $ M ; $ j ++ ) $ res = min ( $ res , $ dp [ $ n - 1 ] [ $ j ] ) ; return $ res ; }
function countIntegralSolutions ( $ n ) { $ result = 0 ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) for ( $ j = 0 ; $ j <= $ n - $ i ; $ j ++ ) for ( $ k = 0 ; $ k <= ( $ n - $ i - $ j ) ; $ k ++ ) if ( $ i + $ j + $ k == $ n ) $ result ++ ; return $ result ; }
function countIntegralSolutions ( $ n ) { return ( ( $ n + 1 ) * ( $ n + 2 ) ) / 2 ; }
function LCIS ( $ arr1 , $ n , $ arr2 , $ m ) { $ table = Array ( ) ; for ( $ j = 0 ; $ j < $ m ; $ j ++ ) $ table [ $ j ] = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ current = 0 ; for ( $ j = 0 ; $ j < $ m ; $ j ++ ) { if ( $ arr1 [ $ i ] == $ arr2 [ $ j ] ) if ( $ current + 1 > $ table [ $ j ] ) $ table [ $ j ] = $ current + 1 ; if ( $ arr1 [ $ i ] > $ arr2 [ $ j ] ) if ( $ table [ $ j ] > $ current ) $ current = $ table [ $ j ] ; } } $ result = 0 ; for ( $ i = 0 ; $ i < $ m ; $ i ++ ) if ( $ table [ $ i ] > $ result ) $ result = $ table [ $ i ] ; return $ result ; }
function minTime ( $ arr , $ n ) { if ( $ n <= 0 ) return 0 ; $ excl = 0 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ incl_new = $ arr [ $ i ] + min ( $ excl , $ incl ) ; $ excl_new = $ incl ; $ incl = $ incl_new ; $ excl = $ excl_new ; } return min ( $ incl , $ excl ) ; }
function lcs ( $ X , $ Y ) { $ m = strlen ( $ X ) ; $ n = strlen ( $ Y ) ; $ L = array ( array ( ) ) ; for ( $ i = 0 ; $ i <= $ m ; $ i ++ ) { $ bi = $ i & 1 ; for ( $ j = 0 ; $ j <= $ n ; $ j ++ ) { if ( $ i == 0 $ j == 0 ) $ L [ $ bi ] [ $ j ] = 0 ; else if ( $ X [ $ i - 1 ] == $ Y [ $ j - 1 ] ) $ L [ $ bi ] [ $ j ] = $ L [ 1 - $ bi ] [ $ j - 1 ] + 1 ; else $ L [ $ bi ] [ $ j ] = max ( $ L [ 1 - $ bi ] [ $ j ] , $ L [ $ bi ] [ $ j - 1 ] ) ; } } return $ L [ $ bi ] [ $ n ] ; }
function countt ( $ n ) { $ dp [ $ n + 1 ] = 0 ; $ dp [ 0 ] = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { if ( $ i >= 1 && $ i <= 3 ) $ dp [ $ i ] = 1 ; else if ( $ i == 4 ) $ dp [ $ i ] = 2 ; else $ dp [ $ i ] = $ dp [ $ i - 1 ] + $ dp [ $ i - 4 ] ; } return $ dp [ $ n ] ; }
function subsetXOR ( $ arr , $ n , $ k ) { $ max_ele = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] > $ max_ele ) $ max_ele = $ arr [ $ i ] ; $ m = ( 1 << ( int ) ( log ( $ max_ele , 2 ) + 1 ) ) - 1 ; if ( $ k > $ m ) { return 0 ; } for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) for ( $ j = 0 ; $ j <= $ m ; $ j ++ ) $ dp [ $ i ] [ $ j ] = 0 ; $ dp [ 0 ] [ 0 ] = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) for ( $ j = 0 ; $ j <= $ m ; $ j ++ ) $ dp [ $ i ] [ $ j ] = $ dp [ $ i - 1 ] [ $ j ] + $ dp [ $ i - 1 ] [ $ j ^ $ arr [ $ i - 1 ] ] ; return $ dp [ $ n ] [ $ k ] ; }
function permutationCoeff ( $ n , $ k ) { $ fact = array ( ) ; $ fact [ 0 ] = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ fact [ $ i ] = $ i * $ fact [ $ i - 1 ] ; return $ fact [ $ n ] / $ fact [ $ n - $ k ] ; }
function countDer ( $ n ) { if ( $ n == 1 ) return 0 ; if ( $ n == 2 ) return 1 ; return ( $ n - 1 ) * ( countDer ( $ n - 1 ) + countDer ( $ n - 2 ) ) ; }
function countDer ( $ n ) { $ der [ 1 ] = 0 ; $ der [ 2 ] = 1 ; for ( $ i = 3 ; $ i <= $ n ; ++ $ i ) $ der [ $ i ] = ( $ i - 1 ) * ( $ der [ $ i - 1 ] + $ der [ $ i - 2 ] ) ; return $ der [ $ n ] ; }
function countP ( $ n , $ k ) { if ( $ n == 0 $ k == 0 $ k > $ n ) return 0 ; if ( $ k == 1 $ k == $ n ) return 1 ; return $ k * countP ( $ n - 1 , $ k ) + countP ( $ n - 1 , $ k - 1 ) ; }
function countP ( $ n , $ k ) { $ dp [ $ n + 1 ] [ $ k + 1 ] = array ( array ( ) ) ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) $ dp [ $ i ] [ 0 ] = 0 ; for ( $ i = 0 ; $ i <= $ k ; $ i ++ ) $ dp [ 0 ] [ $ k ] = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) for ( $ j = 1 ; $ j <= $ i ; $ j ++ ) if ( $ j == 1 $ i == $ j ) $ dp [ $ i ] [ $ j ] = 1 ; else $ dp [ $ i ] [ $ j ] = $ j * $ dp [ $ i - 1 ] [ $ j ] + $ dp [ $ i - 1 ] [ $ j - 1 ] ; return $ dp [ $ n ] [ $ k ] ; }
function bellNumber ( $ n ) { $ bell [ 0 ] [ 0 ] = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ bell [ $ i ] [ 0 ] = $ bell [ $ i - 1 ] [ $ i - 1 ] ; for ( $ j = 1 ; $ j <= $ i ; $ j ++ ) $ bell [ $ i ] [ $ j ] = $ bell [ $ i - 1 ] [ $ j - 1 ] + $ bell [ $ i ] [ $ j - 1 ] ; } return $ bell [ $ n ] [ 0 ] ; }
function countSol ( $ coeff , $ start , $ end , $ rhs ) { if ( $ rhs == 0 ) return 1 ; $ result = 0 ; for ( $ i = $ start ; $ i <= $ end ; $ i ++ ) if ( $ coeff [ $ i ] <= $ rhs ) $ result += countSol ( $ coeff , $ i , $ end , $ rhs - $ coeff [ $ i ] ) ; return $ result ; }
function countSol ( $ coeff , $ n , $ rhs ) { $ dp = str_repeat ( " \0" , 256 ) ; $ dp [ 0 ] = 1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = $ coeff [ $ i ] ; $ j <= $ rhs ; $ j ++ ) $ dp [ $ j ] = $ dp [ $ j ] + ( $ dp [ $ j - $ coeff [ $ i ] ] ) ; return $ dp [ $ rhs ] ; }
function printCountRec ( $ dist ) { if ( $ dist < 0 ) return 0 ; if ( $ dist == 0 ) return 1 ; return printCountRec ( $ dist - 1 ) + printCountRec ( $ dist - 2 ) + printCountRec ( $ dist - 3 ) ; }
function printCountDP ( $ dist ) { $ count = array ( ) ; $ count [ 0 ] = 1 ; $ count [ 1 ] = 1 ; $ count [ 2 ] = 2 ; for ( $ i = 3 ; $ i <= $ dist ; $ i ++ ) $ count [ $ i ] = $ count [ $ i - 1 ] + $ count [ $ i - 2 ] + $ count [ $ i - 3 ] ; return $ count [ $ dist ] ; }
function countSeq ( $ n ) { $ nCr = 1 ; $ res = 1 ; for ( $ r = 1 ; $ r <= $ n ; $ r ++ ) { $ nCr = ( $ nCr * ( $ n + 1 - $ r ) ) / $ r ; $ res = $ res + ( $ nCr * $ nCr ) ; } return $ res ; }
function findLongestRepeatingSubSeq ( $ str ) { $ n = strlen ( $ str ) ; $ dp = array ( array ( ) ) ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) for ( $ j = 0 ; $ j <= $ n ; $ j ++ ) $ dp [ $ i ] [ $ j ] = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 1 ; $ j <= $ n ; $ j ++ ) { if ( $ str [ $ i - 1 ] == $ str [ $ j - 1 ] && $ i != $ j ) $ dp [ $ i ] [ $ j ] = 1 + $ dp [ $ i - 1 ] [ $ j - 1 ] ; else $ dp [ $ i ] [ $ j ] = max ( $ dp [ $ i ] [ $ j - 1 ] , $ dp [ $ i - 1 ] [ $ j ] ) ; } } return $ dp [ $ n ] [ $ n ] ; }
function steps ( $ source , $ step , $ dest ) { if ( abs ( $ source ) > ( $ dest ) ) return PHP_INT_MAX ; if ( $ source == $ dest ) return $ step ; $ pos = steps ( $ source + $ step + 1 , $ step + 1 , $ dest ) ; $ neg = steps ( $ source - $ step - 1 , $ step + 1 , $ dest ) ; return min ( $ pos , $ neg ) ; }
function countNumbersWith4 ( $ n ) { if ( $ n < 4 ) return 0 ; $ d = ( int ) log10 ( $ n ) ; $ a = array_fill ( 0 , $ d + 1 , NULL ) ; $ a [ 0 ] = 0 ; $ a [ 1 ] = 1 ; for ( $ i = 2 ; $ i <= $ d ; $ i ++ ) $ a [ $ i ] = $ a [ $ i - 1 ] * 9 + ceil ( pow ( 10 , $ i - 1 ) ) ; $ p = ceil ( pow ( 10 , $ d ) ) ; $ msd = intval ( $ n / $ p ) ; if ( $ msd == 4 ) return ( $ msd ) * $ a [ $ d ] + ( $ n % $ p ) + 1 ; if ( $ msd > 4 ) return ( $ msd - 1 ) * $ a [ $ d ] + $ p + countNumbersWith4 ( $ n % $ p ) ; return ( $ msd ) * $ a [ $ d ] + countNumbersWith4 ( $ n % $ p ) ; }
function numberOfPaths ( $ m , $ n ) { if ( $ m == 1 $ n == 1 ) return 1 ; return numberOfPaths ( $ m - 1 , $ n ) + numberOfPaths ( $ m , $ n - 1 ) ; }
function numberOfPaths ( $ m , $ n ) { $ count = array ( ) ; for ( $ i = 0 ; $ i < $ m ; $ i ++ ) $ count [ $ i ] [ 0 ] = 1 ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) $ count [ 0 ] [ $ j ] = 1 ; for ( $ i = 1 ; $ i < $ m ; $ i ++ ) { for ( $ j = 1 ; $ j < $ n ; $ j ++ ) $ count [ $ i ] [ $ j ] = $ count [ $ i - 1 ] [ $ j ] + $ count [ $ i ] [ $ j - 1 ] + count [ i - 1 ] [ j - 1 ] ; } return $ count [ $ m - 1 ] [ $ n - 1 ] ; }
function numberOfPaths ( $ m , $ n ) { $ path = 1 ; for ( $ i = $ n ; $ i < ( $ m + $ n - 1 ) ; $ i ++ ) { $ path *= $ i ; $ path /= ( $ i - $ n + 1 ) ; } return $ path ; } { echo ( numberOfPaths ( 3 , 3 ) ) ; }
function optimalStrategyOfGame ( $ arr , $ n ) { $ table = array_fill ( 0 , $ n , array_fill ( 0 , $ n , 0 ) ) ; for ( $ gap = 0 ; $ gap < $ n ; ++ $ gap ) { for ( $ i = 0 , $ j = $ gap ; $ j < $ n ; ++ $ i , ++ $ j ) { $ x = ( ( $ i + 2 ) <= $ j ) ? $ table [ $ i + 2 ] [ $ j ] : 0 ; $ y = ( ( $ i + 1 ) <= ( $ j - 1 ) ) ? $ table [ $ i + 1 ] [ $ j - 1 ] : 0 ; $ z = ( $ i <= ( $ j - 2 ) ) ? $ table [ $ i ] [ $ j - 2 ] : 0 ; $ table [ $ i ] [ $ j ] = max ( $ arr [ $ i ] + min ( $ x , $ y ) , $ arr [ $ j ] + min ( $ y , $ z ) ) ; } } return $ table [ 0 ] [ $ n - 1 ] ; }
function findWays ( $ m , $ n , $ x ) { $ table ; for ( $ i = 1 ; $ i < $ n + 1 ; $ i ++ ) for ( $ j = 1 ; $ j < $ x + 1 ; $ j ++ ) $ table [ $ i ] [ $ j ] = 0 ; for ( $ j = 1 ; $ j <= $ m && $ j <= $ x ; $ j ++ ) $ table [ 1 ] [ $ j ] = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) for ( $ j = 1 ; $ j <= $ x ; $ j ++ ) for ( $ k = 1 ; $ k <= $ m && $ k < $ j ; $ k ++ ) $ table [ $ i ] [ $ j ] += $ table [ $ i - 1 ] [ $ j - $ k ] ; return $ table [ $ n ] [ $ x ] ; }
function LCSubStr ( $ X , $ Y , $ m , $ n ) { $ LCSuff = array_fill ( 0 , $ m + 1 , array_fill ( 0 , $ n + 1 , NULL ) ) ; $ result = 0 ; for ( $ i = 0 ; $ i <= $ m ; $ i ++ ) { for ( $ j = 0 ; $ j <= $ n ; $ j ++ ) { if ( $ i == 0 $ j == 0 ) $ LCSuff [ $ i ] [ $ j ] = 0 ; else if ( $ X [ $ i - 1 ] == $ Y [ $ j - 1 ] ) { $ LCSuff [ $ i ] [ $ j ] = $ LCSuff [ $ i - 1 ] [ $ j - 1 ] + 1 ; $ result = max ( $ result , $ LCSuff [ $ i ] [ $ j ] ) ; } else $ LCSuff [ $ i ] [ $ j ] = 0 ; } } return $ result ; }
function isSubsetSum ( $ set , $ n , $ sum ) { if ( $ sum == 0 ) return true ; if ( $ n == 0 ) return false ; if ( $ set [ $ n - 1 ] > $ sum ) return isSubsetSum ( $ set , $ n - 1 , $ sum ) ; return isSubsetSum ( $ set , $ n - 1 , $ sum ) || isSubsetSum ( $ set , $ n - 1 , $ sum - $ set [ $ n - 1 ] ) ; }
function lbs ( & $ arr , $ n ) { $ lis = array_fill ( 0 , $ n , NULL ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ lis [ $ i ] = 1 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ i ; $ j ++ ) if ( $ arr [ $ i ] > $ arr [ $ j ] && $ lis [ $ i ] < $ lis [ $ j ] + 1 ) $ lis [ $ i ] = $ lis [ $ j ] + 1 ; $ lds = array_fill ( 0 , $ n , NULL ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ lds [ $ i ] = 1 ; for ( $ i = $ n - 2 ; $ i >= 0 ; $ i -- ) for ( $ j = $ n - 1 ; $ j > $ i ; $ j -- ) if ( $ arr [ $ i ] > $ arr [ $ j ] && $ lds [ $ i ] < $ lds [ $ j ] + 1 ) $ lds [ $ i ] = $ lds [ $ j ] + 1 ; $ max = $ lis [ 0 ] + $ lds [ 0 ] - 1 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) if ( $ lis [ $ i ] + $ lds [ $ i ] - 1 > $ max ) $ max = $ lis [ $ i ] + $ lds [ $ i ] - 1 ; return $ max ; }
function maxSumIS ( $ arr , $ n ) { $ max = 0 ; $ msis = array ( $ n ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ msis [ $ i ] = $ arr [ $ i ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ i ; $ j ++ ) if ( $ arr [ $ i ] > $ arr [ $ j ] && $ msis [ $ i ] < $ msis [ $ j ] + $ arr [ $ i ] ) $ msis [ $ i ] = $ msis [ $ j ] + $ arr [ $ i ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ max < $ msis [ $ i ] ) $ max = $ msis [ $ i ] ; return $ max ; }
function MatrixChainOrder ( & $ p , $ i , $ j ) { if ( $ i == $ j ) return 0 ; $ min = PHP_INT_MAX ; for ( $ k = $ i ; $ k < $ j ; $ k ++ ) { $ count = MatrixChainOrder ( $ p , $ i , $ k ) + MatrixChainOrder ( $ p , $ k + 1 , $ j ) + $ p [ $ i - 1 ] * $ p [ $ k ] * $ p [ $ j ] ; if ( $ count < $ min ) $ min = $ count ; } return $ min ; }
function coun ( $ S , $ m , $ n ) { if ( $ n == 0 ) return 1 ; if ( $ n < 0 ) return 0 ; if ( $ m <= 0 && $ n >= 1 ) return 0 ; return coun ( $ S , $ m - 1 , $ n ) + coun ( $ S , $ m , $ n - $ S [ $ m - 1 ] ) ; }
function updateString ( $ S , $ A , $ B ) { $ l = strlen ( $ A ) ; for ( $ i = 0 ; $ i + $ l <= strlen ( $ S ) ; $ i ++ ) { $ curr = substr ( $ S , $ i , $ i + $ l ) ; if ( strcmp ( $ curr , $ A ) == 0 ) { $ new_string = substr ( $ S , 0 , $ i ) . $ B . substr ( $ S , $ i + $ l , strlen ( $ S ) ) ; $ S = $ new_string ; $ i += $ l - 1 ; } else { $ new_string = substr ( $ S , 0 , $ i ) . $ A . substr ( $ S , $ i + $ l , strlen ( $ S ) ) ; $ S = $ new_string ; $ i += $ l - 1 ; } } return $ S ; }
function findCount ( $ str1 , $ str2 ) { $ len = strlen ( $ str1 ) ; $ len2 = strlen ( $ str1 ) ; $ ans = PHP_INT_MAX ; $ hash1 = array_fill ( 0 , 26 , 0 ) ; $ hash2 = array_fill ( 0 , 26 , 0 ) ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) $ hash1 [ ord ( $ str1 [ $ i ] ) - ord ( ' a ' ) ] ++ ; for ( $ i = 0 ; $ i < $ len2 ; $ i ++ ) $ hash2 [ ord ( $ str2 [ $ i ] ) - ord ( ' a ' ) ] ++ ; for ( $ i = 0 ; $ i < 26 ; $ i ++ ) if ( $ hash2 [ $ i ] ) $ ans = min ( $ ans , $ hash1 [ $ i ] / $ hash2 [ $ i ] ) ; return $ ans ; }
function getCount ( $ a , $ b ) { if ( strlen ( $ b ) % strlen ( $ a ) != 0 ) return -1 ; $ count = floor ( strlen ( $ b ) / strlen ( $ a ) ) ; $ str = " " ; for ( $ i = 0 ; $ i < $ count ; $ i ++ ) { $ str = $ str . $ a ; } if ( strcmp ( $ a , $ b ) ) return $ count ; return -1 ; }
function getSum ( $ n , $ d ) { if ( $ n < $ d ) return 0 ; while ( $ n % 10 != $ d ) $ n -- ; $ k = ( int ) ( $ n / 10 ) ; return ( $ k + 1 ) * $ d + ( $ k * 10 + 10 * $ k * $ k ) / 2 ; }
function countDecreasing ( $ A , $ n ) { $ len = 1 ; for ( $ i = 0 ; $ i < $ n - 1 ; ++ $ i ) { if ( $ A [ $ i + 1 ] < $ A [ $ i ] ) $ len ++ ; else { $ cnt += ( ( ( $ len - 1 ) * $ len ) / 2 ) ; $ len = 1 ; } } if ( $ len > 1 ) $ cnt += ( ( ( $ len - 1 ) * $ len ) / 2 ) ; return $ cnt ; }
function doMatch ( $ A , $ B ) { for ( $ i = 0 ; $ i < strlen ( $ A ) ; $ i ++ ) if ( $ A [ $ i ] != ' * ' && $ B [ $ i ] != ' * ' ) if ( $ A [ $ i ] != $ B [ $ i ] ) return false ; return true ; }
function minimumChar ( $ S1 , $ S2 ) { $ n = strlen ( $ S1 ) ; $ m = strlen ( $ S2 ) ; $ ans = PHP_INT_MAX ; for ( $ i = 0 ; $ i < $ m - $ n + 1 ; $ i ++ ) { $ minRemovedChar = 0 ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ S1 [ $ j ] != $ S2 [ $ i + $ j ] ) { $ minRemovedChar ++ ; } } $ ans = min ( $ minRemovedChar , $ ans ) ; } return $ ans ; }
function isSubstring ( $ s1 , $ s2 ) { $ M = strlen ( $ s1 ) ; $ N = strlen ( $ s2 ) ; for ( $ i = 0 ; $ i <= $ N - $ M ; $ i ++ ) { $ j = 0 ; for ( ; $ j < $ M ; $ j ++ ) if ( $ s2 [ $ i + $ j ] != $ s1 [ $ j ] ) break ; if ( $ j == $ M ) return $ i ; } return -1 ; }
function patternCount ( $ str ) { $ last = $ str [ 0 ] ; $ i = 1 ; $ counter = 0 ; while ( $ i < strlen ( $ str ) ) { if ( $ str [ $ i ] == '0' && $ last == '1' ) { while ( $ str [ $ i ] == '0' ) $ i ++ ; if ( $ str [ $ i ] == '1' ) $ counter ++ ; } $ last = $ str [ $ i ] ; $ i ++ ; } return $ counter ; }
function maxPrefix ( $ s , $ t ) { $ count = 0 ; for ( $ i = 0 ; $ i < strlen ( $ t ) ; $ i ++ ) { if ( $ count == strlen ( $ s ) ) break ; if ( $ t [ $ i ] == $ s [ $ count ] ) $ count ++ ; } return $ count ; } { $ S = " digger " ; $ T = " biggerdiagram " ; echo maxPrefix ( $ S , $ T ) ; return 0 ; }
function translate ( & $ str ) { if ( $ str [ 0 ] == ' ' ) return ; for ( $ i = 1 ; $ i < strlen ( $ str ) ; $ i ++ ) { if ( $ str [ $ i - 1 ] == ' A ' && $ str [ $ i ] == ' B ' ) { $ str [ $ i - 1 ] = ' C ' ; for ( $ j = $ i ; $ j < strlen ( $ str ) ; $ j ++ ) $ str [ $ j ] = $ str [ $ j + 1 ] ; } } return ; }
function search ( $ pat , $ txt ) { $ M = strlen ( $ pat ) ; $ N = strlen ( $ txt ) ; $ i = 0 ; while ( $ i <= $ N - $ M ) { $ j ; for ( $ j = 0 ; $ j < $ M ; $ j ++ ) if ( $ txt [ $ i + $ j ] != $ pat [ $ j ] ) break ; if ( $ j == $ M ) { echo ( " Pattern ▁ found ▁ at ▁ index ▁ $ i " . " STRNEWLINE " ) ; $ i = $ i + $ M ; } else if ( $ j == 0 ) $ i = $ i + 1 ; else $ i = $ i + $ j ; } }
function number_of_tower ( $ house , $ range , $ n ) { sort ( $ house ) ; $ numOfTower = 0 ; $ i = 0 ; while ( $ i < $ n ) { $ numOfTower ++ ; $ loc = $ house [ $ i ] + $ range ; while ( $ i < $ n && $ house [ $ i ] <= $ loc ) $ i ++ ; -- $ i ; $ loc = $ house [ $ i ] + $ range ; while ( $ i < $ n && $ house [ $ i ] <= $ loc ) $ i ++ ; } return $ numOfTower ; }
function pendulumArrangement ( $ arr , $ n ) { sort ( $ arr , $ n ) ; sort ( $ arr ) ; $ op [ $ n ] = NULL ; $ mid = floor ( ( $ n - 1 ) / 2 ) ; $ j = 1 ; $ i = 1 ; $ op [ $ mid ] = $ arr [ 0 ] ; for ( $ i = 1 ; $ i <= $ mid ; $ i ++ ) { $ op [ $ mid + $ i ] = $ arr [ $ j ++ ] ; $ op [ $ mid - $ i ] = $ arr [ $ j ++ ] ; } if ( $ n % 2 == 0 ) $ op [ $ mid + $ i ] = $ arr [ $ j ] ; echo " Pendulum ▁ arrangement : " ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ op [ $ i ] , " ▁ " ; echo " STRNEWLINE " ; }
function positions ( $ str , $ n ) { $ a = 31 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { print ( ( ord ( $ str [ $ i ] ) & ( $ a ) ) . " " ) ; } }
function lenoflongestnonpalindrome ( $ s ) { $ max1 = 1 ; $ len = 0 ; for ( $ i = 0 ; $ i < strlen ( $ s ) - 1 ; $ i ++ ) { if ( $ s [ $ i ] == $ s [ $ i + 1 ] ) $ len = 0 ; else if ( $ s [ $ i + 1 ] == $ s [ $ i - 1 ] && $ i > 0 ) $ len = 1 ; $ len ++ ; } if ( $ max1 == 1 ) return 0 ; else return $ max1 ; }
function calcScore ( $ str ) { $ score = 0 ; $ len = strlen ( $ str ) ; for ( $ i = 0 ; $ i < $ len { $ chunkSize = 1 ; $ currentChar = $ str [ $ i ++ ] ; while ( $ i < $ len && $ str [ $ i ] == $ currentChar ) { $ chunkSize ++ ; $ i ++ ; } if ( $ currentChar == '1' ) $ score += pow ( $ chunkSize , 2 ) ; else $ score -= pow ( $ chunkSize , 2 ) ; } return $ score ; }
function check ( $ s ) { $ n = strlen ( $ s ) ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { if ( $ s [ $ i ] > $ s [ $ i + 1 ] ) return true ; } return false ; }
function countSubStr ( $ str , $ n , $ x ) { $ res = 0 ; $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ str [ $ i ] == $ x ) { $ res += ( ( $ count + 1 ) * ( $ n - $ i ) ) ; $ count = 0 ; } else $ count ++ ; } return $ res ; }
function isValid ( $ str , $ n ) { if ( ! ( ( $ str [ 0 ] >= ' a ' && $ str [ 0 ] <= ' z ' ) || ( $ str [ 0 ] >= ' A ' && $ str [ 0 ] <= ' Z ' ) $ str [ 0 ] == ' _ ' ) ) return false ; for ( $ i = 1 ; $ i < strlen ( $ str ) ; $ i ++ ) { if ( ! ( ( $ str [ $ i ] >= ' a ' && $ str [ $ i ] <= ' z ' ) || ( $ str [ $ i ] >= ' A ' && $ str [ $ i ] <= ' Z ' ) || ( $ str [ $ i ] >= '0' && $ str [ $ i ] <= '9' ) $ str [ $ i ] == ' _ ' ) ) return false ; } return true ; }
function countSubStr ( $ str , $ n ) { $ len = strlen ( $ str ) ; return ( $ len - $ n + 1 ) ; }
function countSubstrings ( $ s , $ c ) { $ n = strlen ( $ s ) ; $ cnt = 0 ; $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ s [ $ i ] != $ c ) $ cnt ++ ; else { $ sum += floor ( ( $ cnt * ( $ cnt + 1 ) ) / 2 ) ; $ cnt = 0 ; } } $ sum += floor ( ( $ cnt * ( $ cnt + 1 ) ) / 2 ) ; return $ sum ; }
function FirstAndLast ( $ str ) { $ ch = $ str ; for ( $ i = 0 ; $ i < strlen ( $ ch ) ; $ i ++ ) { $ k = $ i ; while ( $ i < strlen ( $ ch ) && $ ch [ $ i ] != ' ▁ ' ) $ i ++ ; $ ch [ $ k ] = chr ( ( $ ch [ $ k ] >= ' a ' && $ ch [ $ k ] <= ' z ' ) ? ( ord ( $ ch [ $ k ] ) - 32 ) : ( ord ( $ ch [ $ k ] ) ) ) ; $ ch [ $ i - 1 ] = chr ( ( $ ch [ $ i - 1 ] >= ' a ' && $ ch [ $ i - 1 ] <= ' z ' ) ? ( ord ( $ ch [ $ i - 1 ] ) - 32 ) : ( ord ( $ ch [ $ i - 1 ] ) ) ) ; } return $ ch ; }
function findM ( $ s , $ x ) { $ cnt = 0 ; for ( $ i = 0 ; $ i < strlen ( $ s ) ; $ i ++ ) { if ( ord ( $ s [ $ i ] ) - ord ( '0' ) != $ x ) $ cnt ++ ; } return $ cnt ; }
function printLastChar ( $ str ) { $ str = $ str . " ▁ " ; for ( $ i = 1 ; $ i < strlen ( $ str ) ; $ i ++ ) { if ( ! strcmp ( $ str [ $ i ] , ' ▁ ' ) ) echo ( $ str [ $ i - 1 ] . " ▁ " ) ; } }
function asciiToSentence ( $ string , $ length ) { $ num = 0 ; for ( $ i = 0 ; $ i < $ length ; $ i ++ ) { $ num = $ num * 10 + ( ord ( $ string [ $ i ] ) - ord ( '0' ) ) ; if ( $ num >= 32 && $ num <= 122 ) { $ ch = chr ( $ num ) ; print ( $ ch ) ; $ num = 0 ; } } }
function countKeyPressed ( $ str , $ len ) { global $ arr ; $ count = 0 ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) $ count = $ count + $ arr [ ord ( $ str [ $ i ] ) - ord ( ' a ' ) ] ; return $ count ; }
function minLettersNeeded ( $ n ) { if ( $ n % 26 == 0 ) return floor ( ( $ n / 26 ) ) ; else return floor ( ( $ n / 26 ) + 1 ) ; }
function minReplacement ( $ s , $ len ) { $ ans = 0 ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { if ( $ i % 2 == 0 && $ s [ $ i ] == '1' ) $ ans ++ ; if ( $ i % 2 == 1 && $ s [ $ i ] == '0' ) $ ans ++ ; } return min ( $ ans , $ len - $ ans ) ; }
function maxBalancedStr ( $ s ) { $ open1 = 0 ; $ close1 = 0 ; $ open2 = 0 ; $ close2 = 0 ; $ open3 = 0 ; $ close3 = 0 ; for ( $ i = 0 ; $ i < strlen ( $ s ) ; $ i ++ ) { switch ( $ s [ $ i ] ) { case ' ( ' : $ open1 ++ ; break ; case ' ) ' : $ close1 ++ ; break ; case ' { ' : $ open2 ++ ; break ; case ' } ' : $ close2 ++ ; break ; case ' [ ' : $ open3 ++ ; break ; case ' ] ' : $ close3 ++ ; break ; } } $ maxLen = 2 * min ( $ open1 , $ close1 ) + 2 * min ( $ open2 , $ close2 ) + 2 * min ( $ open3 , $ close3 ) ; return $ maxLen ; } { $ s = " ) ) [ ] ] ( ( " ; echo ( maxBalancedStr ( $ s ) ) ; }
function Preprocess ( $ A , $ B ) { $ n = strlen ( $ A ) ; $ ans = 0 ; $ mp = array ( ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ mp [ $ A [ $ i ] ] = 0 ; for ( $ i = 0 ; $ i < floor ( $ n / 2 ) ; $ i ++ ) { $ mp [ $ A [ $ i ] ] ++ ; $ mp [ $ A [ $ n - $ i - 1 ] ] ++ ; $ mp [ $ B [ $ i ] ] ++ ; $ mp [ $ B [ $ n - $ i - 1 ] ] ++ ; $ sz = sizeof ( $ mp ) ; if ( $ sz == 4 ) $ ans += 2 ; else if ( $ sz == 3 ) if ( $ A [ $ i ] == $ A [ $ n - $ i - 1 ] ) $ ans += 1 ; else $ ans += 1 ; else if ( $ sz == 2 ) $ ans += $ mp [ $ A [ $ i ] ] != 2 ; } if ( $ n % 2 == 1 && ( $ A [ floor ( $ n / 2 ) ] != $ B [ floor ( $ n / 2 ) ] ) ) $ ans ++ ; return $ ans ; }
function minOperations ( $ s , $ t , $ n ) { $ ct0 = 0 ; $ ct1 = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ s [ $ i ] == $ t [ $ i ] ) continue ; if ( $ s [ $ i ] == '0' ) $ ct0 ++ ; else $ ct1 ++ ; } return max ( $ ct0 , $ ct1 ) ; }
function maxValue ( $ a , $ b ) { sort ( $ b ) ; $ n = sizeof ( $ a ) ; $ m = sizeof ( $ b ) ; $ j = $ m - 1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ j < 0 ) break ; if ( $ b [ $ j ] > $ a [ $ i ] ) { $ a [ $ i ] = $ b [ $ j ] ; $ j -- ; } } $ a = implode ( " " , $ a ) ; return $ a ; }
function largestPalinSub ( $ s ) { $ res = " " ; $ mx = $ s [ 0 ] ; for ( $ i = 1 ; $ i < strlen ( $ s ) ; $ i ++ ) { $ mx = max ( $ mx , $ s [ $ i ] ) ; } for ( $ i = 0 ; $ i < strlen ( $ s ) ; $ i ++ ) { if ( $ s [ $ i ] == $ mx ) { $ res . = $ s [ $ i ] ; } } return $ res ; }
function isValid ( $ str , $ len ) { for ( $ i = 1 ; $ i < $ len ; $ i ++ ) { if ( $ str [ $ i ] == $ str [ $ i - 1 ] ) return false ; } return true ; }
function decryptString ( $ str , $ n ) { $ i = 0 ; $ jump = 1 ; $ decryptedStr = " " ; while ( $ i < $ n ) { $ decryptedStr . = $ str [ $ i ] ; $ i += $ jump ; $ jump ++ ; } return $ decryptedStr ; }
function countSubStr ( $ str , $ len , $ k ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { $ n = 0 ; for ( $ j = $ i ; $ j < $ len ; $ j ++ ) { $ n = $ n * 10 + ( $ str [ $ j ] - '0' ) ; if ( $ n % $ k == 0 ) $ count ++ ; } } return $ count ; }
function printString ( $ str , $ n ) { $ ones = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ str [ $ i ] == '1' ) $ ones ++ ; $ used = false ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ str [ $ i ] == '2' && ! $ used ) { $ used = 1 ; for ( $ j = 0 ; $ j < $ ones ; $ j ++ ) echo "1" ; } if ( $ str [ $ i ] != '1' ) echo $ str [ $ i ] ; } if ( ! $ used ) for ( $ j = 0 ; $ j < $ ones ; $ j ++ ) echo "1" ; }
function Colour_Combination ( $ s ) { $ temp = $ s [ 0 ] ; for ( $ i = 1 ; $ i < strlen ( $ s ) ; $ i ++ ) { if ( $ temp != $ s [ $ i ] ) { if ( ( $ temp == ' B ' $ temp == ' G ' ) && ( $ s [ $ i ] == ' G ' $ s [ $ i ] == ' B ' ) ) $ temp = ' Y ' ; else if ( ( $ temp == ' B ' $ temp == ' Y ' ) && ( $ s [ $ i ] == ' Y ' $ s [ $ i ] == ' B ' ) ) $ temp = ' G ' ; else $ temp = ' B ' ; } } return $ temp ; }
function reverse ( $ str , $ x ) { $ n = ( strlen ( $ str ) - $ x ) / 2 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo ( $ str [ $ i ] ) ; for ( $ i = $ n + $ x - 1 ; $ i >= $ n ; $ i -- ) echo ( $ str [ $ i ] ) ; for ( $ i = $ n + $ x ; $ i < strlen ( $ str ) ; $ i ++ ) echo $ str [ $ i ] ; }
function removeChars ( $ s ) { $ modifiedStr = " " ; $ modifiedStr = $ modifiedStr . $ s [ 0 ] ; for ( $ i = 1 ; $ i < strlen ( $ s ) ; $ i ++ ) { if ( ctype_upper ( $ s [ $ i ] ) && ctype_lower ( $ s [ $ i - 1 ] ) || ctype_lower ( $ s [ $ i ] ) && ctype_upper ( $ s [ $ i - 1 ] ) ) $ modifiedStr = $ modifiedStr . $ s [ $ i ] ; } return $ modifiedStr ; }
function pairStar ( & $ input , & $ output , $ i = 0 ) { $ output = $ output . $ input [ $ i ] ; if ( $ i == strlen ( $ input ) - 1 ) return ; if ( $ input [ $ i ] == $ input [ $ i + 1 ] ) $ output = $ output . ' * ' ; pairStar ( $ input , $ output , $ i +1 ) ; }
function binarySearch ( $ arr , $ x ) { $ l = 0 ; $ r = count ( $ arr ) ; while ( $ l <= $ r ) { $ m = $ l + ( int ) ( ( $ r - $ l ) / 2 ) ; $ res = strcmp ( $ x , $ arr [ $ m ] ) ; if ( $ res == 0 ) return $ m - 1 ; if ( $ res > 0 ) $ l = $ m + 1 ; else $ r = $ m - 1 ; } return -1 ; }
function maxFreq ( $ s , $ a , $ b ) { $ fre = array_fill ( 0 , 10 , 0 ) ; $ n = strlen ( $ s ) ; if ( $ a > $ b ) { $ xx = $ a ; $ a = $ b ; $ b = $ xx ; } for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ a = ord ( $ s [ $ i ] ) - ord ( '0' ) ; $ fre [ $ a ] += 1 ; } if ( $ fre [ $ a ] == 0 and $ fre [ $ b ] == 0 ) return -1 ; else if ( $ fre [ $ a ] >= $ fre [ $ b ] ) return $ a ; else return $ b ; }
function CountCharacters ( $ str , $ l , $ r ) { $ cnt = 0 ; $ m = array_fill ( 0 , 256 , NULL ) ; $ len = strlen ( $ str ) ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { if ( ! ( $ l <= ord ( $ str [ $ i ] ) and ord ( $ str [ $ i ] ) <= $ r ) ) { $ cnt ++ ; if ( isset ( $ m [ ord ( $ str [ $ i ] ) ] ) != 1 ) { echo $ str [ $ i ] . " " ; $ m [ ord ( $ str [ $ i ] ) ] ++ ; } } } return $ cnt ; }
function strScore ( $ str , $ s , $ n ) { $ score = 0 ; $ index ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ str [ $ i ] == $ s ) { for ( $ j = 0 ; $ j < strlen ( $ s ) ; $ j ++ ) $ score += ( ord ( $ s [ $ j ] ) - ord ( ' a ' ) ) + 1 ; $ index = ( $ i + 1 ) ; break ; } } $ score = $ score * $ index ; return $ score ; }
function countChar ( $ str , $ x ) { $ count = 0 ; $ n = 10 ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) if ( $ str [ $ i ] == $ x ) $ count ++ ; $ repetitions = ( int ) ( $ n / strlen ( $ str ) ) ; $ count = $ count * $ repetitions ; for ( $ i = 0 ; $ i < $ n % strlen ( $ str ) ; $ i ++ ) { if ( $ str [ $ i ] == $ x ) $ count ++ ; } return $ count ; }
function maxProductSum ( $ str , $ m ) { $ n = strlen ( $ str ) ; $ maxProd = PHP_INT_MIN ; $ maxSum = PHP_INT_MIN ; for ( $ i = 0 ; $ i <= ( $ n - $ m ) ; $ i ++ ) { $ product = 1 ; $ sum = 0 ; for ( $ j = $ i ; $ j < ( $ m + $ i ) ; $ j ++ ) { $ product = $ product * ( $ str [ $ j ] - '0' ) ; $ sum = $ sum + ( $ str [ $ j ] - '0' ) ; } $ maxProd = max ( $ maxProd , $ product ) ; $ maxSum = max ( $ maxSum , $ sum ) ; } echo " Maximum ▁ Product ▁ = ▁ " , $ maxProd ; echo " Maximum Sum = " }
function countConsecutive ( $ s ) { $ count = 0 ; for ( $ i = 0 ; $ i < strlen ( $ s ) ; $ i ++ ) { if ( $ s [ $ i ] == $ s [ $ i + 1 ] ) $ i ++ ; else $ count ++ ; } return $ count ; }
function CountCharacters ( $ str , $ l , $ r ) { $ cnt = 0 ; $ len = strlen ( $ str ) ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { if ( $ l <= ord ( $ str [ $ i ] ) && ord ( $ str [ $ i ] ) <= $ r ) { $ cnt ++ ; echo $ str [ $ i ] . " " ; } } return $ cnt ; }
function minSteps ( $ str ) { $ count = 0 ; for ( $ i = 0 ; $ i < strlen ( $ str ) - 2 ; $ i ++ ) { if ( $ str [ $ i ] == '0' ) { if ( $ str [ $ i + 1 ] == '1' ) { if ( $ str [ $ i + 2 ] == '0' ) { $ count ++ ; $ i += 2 ; } } } } return $ count ; }
function CountCharacters ( $ str , $ k ) { $ cnt = 0 ; $ len = strlen ( $ str ) ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { if ( $ str [ $ i ] < chr ( $ k ) ) $ cnt += 1 ; } return $ cnt ; }
function maxLength ( $ s , $ n ) { $ right = 0 ; $ left = 0 ; $ coun = 0 ; $ max_length = PHP_INT_MIN ; $ s = $ s . '1' ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) { if ( $ s [ $ i ] == ' o ' ) $ coun ++ ; else { if ( $ coun > $ max_length ) { $ right = 0 ; $ left = 0 ; if ( $ s [ $ i ] == ' x ' ) $ right = 1 ; if ( ( ( $ i - $ coun ) > 0 ) && ( $ s [ $ i - $ coun - 1 ] == ' x ' ) ) $ left = 1 ; $ coun = ( int ) ceil ( ( double ) $ coun / ( $ right + $ left ) ) ; $ max_length = max ( $ max_length , $ coun ) ; } $ coun = 0 ; } } return $ max_length ; }
function is_possible ( $ s ) { $ l = strlen ( $ s ) ; $ one = 0 ; $ zero = 0 ; for ( $ i = 0 ; $ i < $ l ; $ i ++ ) { if ( $ s [ $ i ] == '0' ) $ zero ++ ; else $ one ++ ; } if ( $ l % 2 == 0 ) return ( $ one == $ zero ) ; else return ( abs ( $ one - $ zero ) == 1 ) ; }
function countSubStr ( $ S , $ X ) { $ cnt = 0 ; $ N = strlen ( $ S ) ; for ( $ i = 0 ; $ i < $ N ; ++ $ i ) { if ( $ S [ $ i ] != '0' ) { for ( $ len = 1 ; ( $ i + $ len ) <= $ N ; ++ $ len ) { $ num = intval ( substr ( $ S , $ i , $ len ) ) ; if ( $ num > $ X ) $ cnt ++ ; } } } return $ cnt ; }
function areVowelsInOrder ( $ s ) { $ n = strlen ( $ s ) ; $ c = chr ( 64 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ s [ $ i ] == ' a ' $ s [ $ i ] == ' e ' $ s [ $ i ] == ' $ i ' $ s [ $ i ] == ' o ' $ s [ $ i ] == ' u ' ) { if ( $ s [ $ i ] < $ c ) return false ; else { $ c = $ s [ $ i ] ; } } } return true ; }
function solve ( $ s , $ k ) { $ count = 0 ; $ length = 0 ; $ pos = 0 ; $ m = array ( ) ; for ( $ i = 0 ; $ i < strlen ( $ s ) ; $ i ++ ) { $ m [ $ s [ $ i ] ] ++ ; $ length ++ ; if ( $ length > $ k ) { $ m [ $ s [ $ pos ++ ] ] -- ; $ length -- ; } if ( $ length == $ k && $ m [ $ s [ $ i ] ] == $ length ) $ count ++ ; } echo $ count . " STRNEWLINE " ; }
function minParentheses ( $ p ) { $ bal = 0 ; $ ans = 0 ; for ( $ i = 0 ; $ i < strlen ( $ p ) ; ++ $ i ) { if ( $ p [ $ i ] == ' ( ' ) $ bal += 1 ; else $ bal += -1 ; if ( $ bal == -1 ) { $ ans += 1 ; $ bal += 1 ; } } return $ bal + $ ans ; }
function Remainder ( $ str , $ R ) { $ len = strlen ( $ str ) ; $ Num = 0 ; $ Rem = 0 ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { $ Num = $ Rem * 10 + ( $ str [ $ i ] - '0' ) ; $ Rem = $ Num % $ R ; } return $ Rem ; }
function productAscii ( $ str ) { $ prod = 1 ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) { $ prod *= ord ( $ str [ $ i ] ) ; } return $ prod ; }
function oddEquivalent ( $ s , $ n ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ s [ $ i ] == '1' ) $ count ++ ; } return $ count ; }
function countStrings ( $ s ) { $ sum = 1 ; for ( $ i = 0 ; $ i < strlen ( $ s ) ; $ i ++ ) { if ( $ i % 2 == 0 && $ s [ $ i ] == ' $ ' ) $ sum *= 21 ; else if ( $ s [ $ i ] == ' $ ' ) $ sum *= 5 ; } return $ sum ; }
function removeDuplicatesFromString ( $ str ) { $ counter = 0 ; $ i = 0 ; $ size = strlen ( $ str ) ; $ x = 0 ; $ length = 0 ; while ( $ i < $ size ) { $ x = ord ( $ str [ $ i ] ) - 97 ; if ( ( $ counter & ( 1 << $ x ) ) == 0 ) { $ str [ $ length ] = chr ( 97 + $ x ) ; $ counter = $ counter | ( 1 << $ x ) ; $ length ++ ; } $ i ++ ; } return substr ( $ str , 0 , $ length ) ; }
function isInGivenBase ( $ str , $ base ) { if ( $ base > 16 ) return false ; else if ( $ base <= 10 ) { for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) if ( ! ( $ str [ $ i ] >= '0' and $ str [ $ i ] < ( '0' + $ base ) ) ) return false ; } else { for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) if ( ! ( ( $ str [ $ i ] >= '0' && $ str [ $ i ] < ( '0' + $ base ) ) || ( $ str [ $ i ] >= ' A ' && $ str [ $ i ] < ( ' A ' + $ base - 10 ) ) ) ) return false ; } return true ; }
function powerOfJump ( $ s ) { $ count = 1 ; $ max_so_far = PHP_INT_MIN ; $ ch = $ s [ strlen ( $ s ) - 1 ] ; for ( $ i = 0 ; $ i < strlen ( $ s ) ; $ i ++ ) { if ( $ s [ $ i ] == $ ch ) { if ( $ count > $ max_so_far ) { $ max_so_far = $ count ; } $ count = 1 ; } else $ count ++ ; } return $ max_so_far ; }
function averageValue ( $ s ) { $ sum_char = 0 ; for ( $ i = 0 ; $ i < strlen ( $ s ) ; $ i ++ ) { $ sum_char += ord ( $ s [ $ i ] ) ; } return ( int ) ( $ sum_char / strlen ( $ s ) ) ; }
function solve ( $ s1 , $ s2 ) { if ( strlen ( $ s1 ) != strlen ( $ s2 ) ) return false ; $ l = strlen ( $ s1 ) ; for ( $ i = 0 ; $ i < 1 ; $ i ++ ) { if ( $ s1 [ $ i ] == '1' ) $ flag1 = 1 ; if ( $ s2 [ $ i ] == '1' ) $ flag2 = 1 ; if ( ! $ flag1 && ! $ flag2 ) return true ; } return false ; }
function check ( $ s , $ m ) { $ l = count ( $ s ) ; $ c1 = 0 ; $ c2 = 0 ; for ( $ i = 0 ; $ i <= $ l ; $ i ++ ) { if ( $ s [ $ i ] == '0' ) { $ c2 = 0 ; $ c1 ++ ; } else { $ c1 = 0 ; $ c2 ++ ; } if ( $ c1 == $ m or $ c2 == $ m ) return true ; } return false ; }
function possibleToSort ( $ arr , $ n , $ str ) { $ max_element = -1 ; for ( $ i = 0 ; $ i < sizeof ( $ str ) ; $ i ++ ) { $ max_element = max ( $ max_element , $ arr [ $ i ] ) ; if ( $ str [ $ i ] == '0' ) { if ( $ max_element > $ i + 1 ) return " No " ; } } return " Yes " ; }
function isDivisible ( $ str , $ k ) { $ n = strlen ( $ str ) ; $ c = 0 ; for ( $ i = 0 ; $ i < $ k ; $ i ++ ) if ( $ str [ $ n - $ i - 1 ] == '0' ) $ c ++ ; return ( $ c == $ k ) ; }
function countNonEmptySubstr ( $ str ) { $ n = strlen ( $ str ) ; return $ n * ( $ n + 1 ) / 2 ; }
function isPerfectSquareString ( $ str ) { $ sum = 0 ; $ len = strlen ( $ str ) ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) $ sum += ( int ) $ str [ $ i ] ; $ squareRoot = sqrt ( $ sum ) ; return ( ( $ squareRoot - floor ( $ squareRoot ) ) == 0 ) ; }
function transformString ( & $ s ) { $ ch = " a " ; if ( strlen ( $ s ) < 26 ) return false ; for ( $ i = 0 ; $ i < strlen ( $ s ) ; $ i ++ ) { if ( ord ( $ ch ) > ord ( " z " ) ) break ; if ( $ s [ $ i ] <= $ ch ) { $ s [ $ i ] = $ ch ; $ ch = chr ( ord ( $ ch ) + 1 ) ; } } if ( $ ch <= " z " ) return false ; return true ; }
function numofstring ( $ n , $ m ) { if ( $ n == 1 ) return $ m ; if ( $ n == 2 ) return $ m * ( $ m - 1 ) ; return $ m * ( $ m - 1 ) * pow ( $ m - 2 , $ n - 2 ) ; } { $ n = 2 ; $ m = 3 ; echo numofstring ( $ n , $ m ) ; return 0 ; }
function calculateSum ( $ arr , $ n ) { if ( $ n == 0 ) return 0 ; $ s = $ arr [ 0 ] ; $ value = ( int ) $ s ; $ sum = $ value ; for ( $ i = 2 ; $ i < $ n ; $ i = $ i + 2 ) { $ s = $ arr [ $ i ] ; $ value = ( int ) $ s ; $ operation = $ arr [ $ i - 1 ] ; if ( $ operation == ' + ' ) $ sum += $ value ; else if ( $ operation == ' - ' ) $ sum -= $ value ; } return $ sum ; }
function productAtKthLevel ( $ tree , $ k ) { $ level = -1 ; $ n = strlen ( $ tree ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ tree [ $ i ] == ' ( ' ) $ level ++ ; else if ( $ tree [ $ i ] == ' ) ' ) $ level -- ; else { if ( $ level == $ k ) $ product *= ( ord ( $ tree [ $ i ] ) - ord ( '0' ) ) ; } } return $ product ; }
function LargestString ( $ na ) { $ N = sizeof ( $ na ) ; $ c = array_fill ( 0 , $ N , 0 ) ; $ m = 0 ; for ( $ j = 0 ; $ j < $ N ; $ j ++ ) { $ character = array_fill ( 0 , 26 , false ) ; for ( $ k = 0 ; $ k < strlen ( $ na [ $ j ] ) ; $ k ++ ) { $ x = ord ( $ na [ $ j ] [ $ k ] ) - 65 ; if ( ( $ na [ $ j ] [ $ k ] != ' ▁ ' ) && ( $ character [ $ x ] == false ) ) { $ c [ $ j ] ++ ; $ character [ $ x ] = true ; } } if ( $ c [ $ j ] > $ c [ $ m ] ) $ m = $ j ; } echo $ na [ $ m ] . " STRNEWLINE " ; }
function isCornerPresent ( $ str , $ corner ) { $ n = strlen ( $ str ) ; $ cl = strlen ( $ corner ) ; if ( $ n < $ cl ) return false ; return ( ! strcmp ( substr ( $ str , 0 , $ cl ) , $ corner ) && ! strcmp ( substr ( $ str , $ n - $ cl , $ cl ) , $ corner ) ) ; }
function minRemoval ( $ str ) { $ hash = array_fill ( 0 , 26 , 0 ) ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) $ hash [ ord ( $ str [ $ i ] ) - 97 ] ++ ; $ count = 0 ; for ( $ i = 0 ; $ i < 26 ; $ i ++ ) if ( $ hash [ $ i ] % 2 ) $ count ++ ; return ( $ count == 0 ) ? 0 : $ count - 1 ; }
function printSequence ( & $ arr , $ input ) { $ output = " " ; $ n = strlen ( $ input ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ input [ $ i ] == ' ▁ ' ) $ output = $ output + "0" ; else { $ position = ord ( $ input [ $ i ] ) - ord ( ' A ' ) ; $ output = $ output . $ arr [ $ position ] ; } } return $ output ; }
function findSubsequence ( $ str , $ k ) { $ a = array ( 1024 ) ; for ( $ i = 0 ; $ i < 26 ; $ i ++ ) $ a [ $ i ] = 0 ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) { $ temp = ord ( $ str [ $ i ] ) - ord ( ' a ' ) ; $ a [ $ temp ] += 1 ; } for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) if ( $ a [ ord ( $ str [ $ i ] ) - ord ( ' a ' ) ] >= $ k ) echo $ str [ $ i ] ; }
function isConvertible ( $ str1 , $ str2 , $ k ) { if ( ( strlen ( $ str1 ) + strlen ( $ str2 ) ) < $ k ) return true ; $ commonLength = 0 ; for ( $ i = 0 ; $ i < min ( strlen ( $ str1 ) , strlen ( $ str2 ) ) ; $ i ++ ) { if ( $ str1 == $ str2 ) $ commonLength += 1 ; else break ; } if ( ( $ k - strlen ( $ str1 ) - strlen ( $ str2 ) + 2 * $ commonLength ) % 2 == 0 ) return true ; return false ; }
function checkPalindrome ( $ str ) { $ n = strlen ( $ str ) ; $ count = 0 ; for ( $ i = 0 ; $ i < $ n / 2 ; ++ $ i ) if ( $ str [ $ i ] != $ str [ $ n - $ i - 1 ] ) ++ $ count ; return ( $ count <= 1 ) ; } { $ str = " abccaa " ; if ( checkPalindrome ( $ str ) ) echo " Yes " ; else echo " No " ; return 0 ; }
function findLUSlength ( $ a , $ b ) { if ( ! strcmp ( $ a , $ b ) ) return 0 ; return max ( strlen ( $ a ) , strlen ( $ b ) ) ; }
function convert ( $ str ) { $ w = " " ; $ z = " " ; $ str = strtoupper ( $ str ) . " ▁ " ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) { $ ch = $ str [ $ i ] ; if ( $ ch != ' ▁ ' ) $ w = $ w . $ ch ; else { $ z = $ z . strtolower ( $ w [ 0 ] ) . substr ( $ w , 1 ) . " ▁ " ; $ w = " " ; } } return $ z ; }
function convert ( $ s ) { $ n = strlen ( $ s ) ; $ s [ 0 ] = strtolower ( $ s [ 0 ] ) ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( $ s [ $ i ] == ' ▁ ' && $ i < $ n ) { $ s [ $ i + 1 ] = strtolower ( $ s [ $ i + 1 ] ) ; $ i ++ ; } else $ s [ $ i ] = strtoupper ( $ s [ $ i ] ) ; } return $ s ; }
function first ( $ str ) { for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) if ( ctype_upper ( $ str [ $ i ] ) ) { return $ str [ $ i ] ; } return 0 ; }
function evenDecimalValue ( $ str , $ n ) { $ result = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = $ i ; $ j < $ n ; $ j ++ ) { $ decimalValue = 0 ; $ powerOf2 = 1 ; for ( $ k = $ i ; $ k <= $ j ; $ k ++ ) { $ decimalValue += ( ( $ str [ $ k ] - '0' ) * $ powerOf2 ) ; $ powerOf2 *= 2 ; } if ( $ decimalValue % 2 == 0 ) $ result ++ ; } } return $ result ; }
function swapTwoHalves ( $ a , $ b ) { $ la = strlen ( $ a ) ; $ lb = strlen ( $ b ) ; $ c = substr ( $ a , 0 , intval ( $ la / 2 ) ) . substr ( $ b , intval ( $ lb / 2 ) , $ lb ) ; $ d = substr ( $ b , 0 , intval ( $ lb / 2 ) ) . substr ( $ a , intval ( $ la / 2 ) , $ la ) ; echo ( $ c . " " ▁ . ▁ $ d ▁ . ▁ " " }
function recLen ( & $ str , $ i ) { if ( $ i == strlen ( $ str ) ) return 0 ; else return 1 + recLen ( $ str , $ i + 1 ) ; }
function longCommomAnagramSubseq ( $ str1 , $ str2 , $ n1 , $ n2 ) { global $ SIZE ; $ freq1 = array ( ) ; $ freq2 = array ( ) ; for ( $ i = 0 ; $ i < $ SIZE ; $ i ++ ) { $ freq1 [ $ i ] = 0 ; $ freq2 [ $ i ] = 0 ; } $ len = 0 ; for ( $ i = 0 ; $ i < $ n1 ; $ i ++ ) $ freq1 [ ord ( $ str1 [ $ i ] ) - ord ( ' a ' ) ] ++ ; for ( $ i = 0 ; $ i < $ n2 ; $ i ++ ) $ freq2 [ ord ( $ str2 [ $ i ] ) - ord ( ' a ' ) ] ++ ; for ( $ i = 0 ; $ i < $ SIZE ; $ i ++ ) { $ len += min ( $ freq1 [ $ i ] , $ freq2 [ $ i ] ) ; } return $ len ; }
function isPanalphabeticWindow ( $ s , $ n ) { $ ch = ' a ' ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ s [ $ i ] == $ ch ) $ ch ++ ; if ( $ ch == ' z ' ) return true ; } return false ; }
function roundFunation ( $ n ) { $ a = ( int ) ( $ n / 10 ) * 10 ; $ b = ( $ a + 10 ) ; return ( $ n - $ a > $ b - $ n ) ? $ b : $ a ; }
function ASCIISentence ( $ str ) { for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) echo ord ( $ str [ $ i ] ) ; }
function convert ( $ str ) { $ n = strlen ( $ str ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ str [ $ i ] == ' ▁ ' ) $ str [ $ i ] = ' _ ' ; else $ str [ $ i ] = strtolower ( $ str [ $ i ] ) ; } echo $ str ; }
function findOccurrences ( $ str , $ substr ) { $ counter = 0 ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) { if ( $ str [ $ i ] == $ substr [ 0 ] ) { for ( $ j = $ i + 1 ; $ j < strlen ( $ str ) ; $ j ++ ) { if ( $ str [ $ j ] == $ substr [ 1 ] ) { for ( $ k = $ j + 1 ; $ k < strlen ( $ str ) ; $ k ++ ) { if ( $ str [ $ k ] == $ substr [ 2 ] ) $ counter ++ ; } } } } } return $ counter ; }
function isEven ( $ s ) { $ l = strlen ( $ s ) ; $ dotSeen = false ; for ( $ i = $ l - 1 ; $ i >= 0 ; $ i -- ) { if ( $ s [ $ i ] == '0' && $ dotSeen == false ) continue ; if ( $ s [ $ i ] == ' . ' ) { $ dotSeen = true ; continue ; } if ( ( $ s [ $ i ] - '0' ) % 2 == 0 ) return true ; return false ; } }
function finalPosition ( $ move ) { $ l = strlen ( $ move ) ; $ countUp = 0 ; $ countDown = 0 ; $ countLeft = 0 ; $ countRight = 0 ; for ( $ i = 0 ; $ i < $ l ; $ i ++ ) { if ( $ move [ $ i ] == ' U ' ) $ countUp ++ ; else if ( $ move [ $ i ] == ' D ' ) $ countDown ++ ; else if ( $ move [ $ i ] == ' L ' ) $ countLeft ++ ; else if ( $ move [ $ i ] == ' R ' ) $ countRight ++ ; } echo " Final ▁ Position : ▁ ( " . ( $ countRight - $ countLeft ) . " , " ▁ , ▁ ( $ countUp ▁ - ▁ $ countDown ) ▁ . ▁ " ) " ▁ . " " }
function replace ( $ s , $ c1 , $ c2 ) { $ l = strlen ( $ s ) ; for ( $ i = 0 ; $ i < $ l ; $ i ++ ) { if ( $ s [ $ i ] == $ c1 ) $ s [ $ i ] = $ c2 ; else if ( $ s [ $ i ] == $ c2 ) $ s [ $ i ] = $ c1 ; } return $ s ; }
function maxbalancedprefix ( $ str , $ n ) { $ sum = 0 ; $ maxi = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ str [ $ i ] == ' ( ' ) $ sum += 1 ; else $ sum -= 1 ; if ( $ sum < 0 ) break ; if ( $ sum == 0 ) $ maxi = $ i + 1 ; } return $ maxi ; }
function countOccurrences ( $ str , $ word ) { $ a = explode ( " ▁ " , $ str ) ; $ count = 0 ; for ( $ i = 0 ; $ i < sizeof ( $ a ) ; $ i ++ ) { if ( $ word == $ a [ $ i ] ) $ count ++ ; } return $ count ; }
function cost ( $ str ) { $ len = strlen ( $ str ) ; $ res = 0 ; for ( $ i = 0 , $ j = $ len - 1 ; $ i < $ j ; $ i ++ , $ j -- ) if ( $ str [ $ i ] != $ str [ $ j ] ) $ res += ( min ( ord ( $ str [ $ i ] ) , ord ( $ str [ $ j ] ) ) - ord ( ' a ' ) + 1 ) ; return $ res ; }
function isValidISBN ( $ isbn ) { $ n = strlen ( $ isbn ) ; if ( $ n != 10 ) return -1 ; $ sum = 0 ; for ( $ i = 0 ; $ i < 9 ; $ i ++ ) { $ digit = $ isbn [ $ i ] - '0' ; if ( 0 > $ digit 9 < $ digit ) return -1 ; $ sum += ( $ digit * ( 10 - $ i ) ) ; } $ last = $ isbn [ 9 ] ; if ( $ last != ' X ' && ( $ last < '0' $ last > '9' ) ) return -1 ; $ sum += ( ( $ last == ' X ' ) ? 10 : ( $ last - '0' ) ) ; return ( $ sum % 11 == 0 ) ; }
function remainder ( $ str ) { $ len = strlen ( $ str ) ; $ num ; $ rem = 0 ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { $ num = $ rem * 10 + ( $ str [ $ i ] - '0' ) ; $ rem = $ num % 11 ; } return $ rem ; }
function isUnique ( $ a , $ n , $ k ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum += $ a [ $ i ] ; $ sum += $ n - 1 ; return ( $ sum == $ k ) ; }
function findString ( $ n , $ k ) { $ res = " " ; for ( $ i = 0 ; $ i < $ k ; $ i ++ ) $ res = $ res . chr ( ord ( ' a ' ) + $ i ) ; $ count = 0 ; for ( $ i = 0 ; $ i < $ n - $ k ; $ i ++ ) { $ res = $ res . chr ( ord ( ' a ' ) + $ count ) ; $ count ++ ; if ( $ count == $ k ) $ count = 0 ; } return $ res ; }
function countReduce ( $ str ) { $ n = strlen ( $ str ) ; $ res = 0 ; for ( $ i = 0 ; $ i < $ n / 2 ; $ i ++ ) $ res += abs ( ord ( $ str [ $ i ] ) - ord ( $ str [ ( $ n - $ i - 1 ) ] ) ) ; return $ res ; }
function calculate ( $ s ) { $ ans = 6 ; for ( $ i = 0 ; $ i < 10 ; ++ $ i ) { for ( $ j = 0 ; $ j < 10 ; ++ $ j ) { for ( $ k = 0 ; $ k < 10 ; ++ $ k ) { for ( $ l = 0 ; $ l < 10 ; ++ $ l ) { for ( $ m = 0 ; $ m < 10 ; ++ $ m ) { for ( $ n = 0 ; $ n < 10 ; ++ $ n ) { if ( $ i + $ j + $ k == $ l + $ m + $ n ) { $ c = 0 ; if ( $ i != $ s [ 0 ] - '0' ) $ c ++ ; if ( $ j != $ s [ 1 ] - '0' ) $ c ++ ; if ( $ k != $ s [ 2 ] - '0' ) $ c ++ ; if ( $ l != $ s [ 3 ] - '0' ) $ c ++ ; if ( $ m != $ s [ 4 ] - '0' ) $ c ++ ; if ( $ n != $ s [ 5 ] - '0' ) $ c ++ ; if ( $ c < $ ans ) $ ans = $ c ; } } } } } } } return $ ans ; }
function makeAndCheckString ( $ words , $ str ) { $ n = sizeof ( $ words ) ; $ first = false ; $ second = false ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ words [ $ i ] == $ str ) return true ; if ( $ str [ 0 ] == $ words [ $ i ] [ 1 ] ) $ first = true ; if ( $ str [ 1 ] == $ words [ $ i ] [ 0 ] ) $ second = true ; if ( $ first && $ second ) return true ; } return false ; }
function findRepeatFirstN2 ( $ s ) { $ p = -1 ; for ( $ i = 0 ; $ i < strlen ( $ s ) ; $ i ++ ) { for ( $ j = ( $ i + 1 ) ; $ j < strlen ( $ s ) ; $ j ++ ) { if ( $ s [ $ i ] == $ s [ $ j ] ) { $ p = $ i ; break ; } } if ( $ p != -1 ) break ; } return $ p ; }
function countSubstrs ( $ str , $ i , $ j , $ n ) { if ( $ n == 1 ) return 1 ; if ( $ n <= 0 ) return 0 ; $ res = countSubstrs ( $ str , $ i + 1 , $ j , $ n - 1 ) + countSubstrs ( $ str , $ i , $ j - 1 , $ n - 1 ) - countSubstrs ( $ str , $ i + 1 , $ j - 1 , $ n - 2 ) ; if ( $ str [ $ i ] == $ str [ $ j ] ) $ res ++ ; return $ res ; }
function stringPalindrome ( $ A , $ B ) { global $ MAX_CHAR ; $ countA = array_fill ( 0 , $ MAX_CHAR , 0 ) ; $ countB = array_fill ( 0 , $ MAX_CHAR , 0 ) ; $ l1 = strlen ( $ A ) ; $ l2 = strlen ( $ B ) ; for ( $ i = 0 ; $ i < $ l1 ; $ i ++ ) $ countA [ ord ( $ A [ $ i ] ) - ord ( ' a ' ) ] ++ ; for ( $ i = 0 ; $ i < $ l2 ; $ i ++ ) $ countB [ ord ( $ B [ $ i ] ) - ord ( ' a ' ) ] ++ ; for ( $ i = 0 ; $ i < 26 ; $ i ++ ) if ( ( $ countA [ $ i ] > 1 && $ countB [ $ i ] == 0 ) ) return ' A ' ; return ' B ' ; }
function printCharWithFreq ( $ str ) { global $ SIZE ; $ n = strlen ( $ str ) ; $ freq = array_fill ( 0 , $ SIZE , NULL ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ freq [ ord ( $ str [ $ i ] ) - ord ( ' a ' ) ] ++ ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ freq [ ord ( $ str [ $ i ] ) - ord ( ' a ' ) ] != 0 ) { echo $ str [ $ i ] . $ freq [ ord ( $ str [ $ i ] ) - ord ( ' a ' ) ] . " " ; $ freq [ ord ( $ str [ $ i ] ) - ord ( ' a ' ) ] = 0 ; } } }
function FirstRepeated ( $ str ) { $ checker = 0 ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; ++ $ i ) { $ val = ( ord ( $ str [ $ i ] ) - ord ( ' a ' ) ) ; if ( ( $ checker & ( 1 << $ val ) ) > 0 ) return $ i ; $ checker |= ( 1 << $ val ) ; } return -1 ; }
function printSubsequences ( $ str ) { $ n = strlen ( $ str ) ; $ opsize = pow ( 2 , $ n - 1 ) ; for ( $ counter = 0 ; $ counter < $ opsize ; $ counter ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { echo $ str [ $ j ] ; if ( $ counter & ( 1 << $ j ) ) echo " ▁ " ; } echo " STRNEWLINE " ; } }
function sentencePalindrome ( $ str ) { $ l = 0 ; $ h = strlen ( $ str ) - 1 ; for ( $ i = 0 ; $ i < $ h ; $ i ++ ) $ str [ $ i ] = strtolower ( $ str [ $ i ] ) ; while ( $ l <= $ h ) { if ( ! ( $ str [ $ l ] >= ' a ' && $ str [ $ l ] <= ' z ' ) ) $ l ++ ; else if ( ! ( $ str [ $ h ] >= ' a ' && $ str [ $ h ] <= ' z ' ) ) $ h -- ; else if ( $ str [ $ l ] == $ str [ $ h ] ) { $ l ++ ; $ h -- ; } else return false ; } return true ; }
function permute ( $ input ) { $ n = strlen ( $ input ) ; $ max = 1 << $ n ; $ input = strtolower ( $ input ) ; for ( $ i = 0 ; $ i < $ max ; $ i ++ ) { $ combination = $ input ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( ( ( $ i >> $ j ) & 1 ) == 1 ) $ combination [ $ j ] = chr ( ord ( $ combination [ $ j ] ) - 32 ) ; } echo $ combination . " " ; } }
function xorZero ( $ str ) { $ one_count = 0 ; $ zero_count = 0 ; $ n = strlen ( $ str ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ str [ $ i ] == '1' ) $ one_count ++ ; else $ zero_count ++ ; if ( $ one_count % 2 == 0 ) return $ zero_count ; return $ one_count ; }
function findFlips ( $ str , $ n ) { $ last = ' ▁ ' ; $ res = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ last != $ str [ $ i ] ) $ res ++ ; $ last = $ str [ $ i ] ; } return intval ( $ res / 2 ) ; }
function isNumber ( $ s ) { for ( $ i = 0 ; $ i < strlen ( $ s ) ; $ i ++ ) if ( is_numeric ( $ s [ $ i ] ) == false ) return false ; return true ; }
function evenlength ( $ n ) { $ res = $ n ; for ( $ j = strlen ( $ n ) - 1 ; $ j >= 0 ; -- $ j ) $ res = $ res . $ n [ $ j ] ; return $ res ; }
function possibleStrings ( $ n , $ r , $ b , $ g ) { $ fact [ 0 ] = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ fact [ $ i ] = $ fact [ $ i - 1 ] * $ i ; $ left = $ n - ( $ r + $ g + $ b ) ; $ sum = 0 ; for ( $ i = 0 ; $ i <= $ left ; $ i ++ ) { for ( $ j = 0 ; $ j <= $ left - $ i ; $ j ++ ) { $ k = $ left - ( $ i + $ j ) ; $ sum = $ sum + $ fact [ $ n ] / ( $ fact [ $ i + $ r ] * $ fact [ $ j + $ b ] * $ fact [ $ k + $ g ] ) ; } } return $ sum ; }
function subString ( $ str , $ n ) { for ( $ len = 1 ; $ len <= $ n ; $ len ++ ) { for ( $ i = 0 ; $ i <= $ n - $ len ; $ i ++ ) { $ j = $ i + $ len - 1 ; for ( $ k = $ i ; $ k <= $ j ; $ k ++ ) echo $ str [ $ k ] ; echo " STRNEWLINE " ; } } }
function uniqueCharacters ( $ str ) { for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < strlen ( $ str ) ; $ j ++ ) { if ( $ str [ $ i ] == $ str [ $ j ] ) { return false ; } } } return true ; } $ str = " GeeksforGeeks " ; if ( uniqueCharacters ( $ str ) ) { echo " The ▁ String ▁ " , $ str , " ▁ has ▁ all ▁ unique ▁ characters STRNEWLINE " ; } else { echo " The ▁ String ▁ " , $ str , " ▁ has ▁ duplicate ▁ characters STRNEWLINE " ; }
function uniqueCharacters ( $ str ) { $ checker = 0 ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) { $ bitAtIndex = $ str [ $ i ] - ' a ' ; if ( ( $ checker & ( 1 << $ bitAtIndex ) ) > 0 ) { return false ; } $ checker = $ checker | ( 1 << $ bitAtIndex ) ; } return true ; } $ str = " geeksforgeeks " ; if ( uniqueCharacters ( $ str ) ) { echo " The ▁ String ▁ " , $ str , " ▁ has ▁ all ▁ unique ▁ characters STRNEWLINE " ; } else { echo " The ▁ String ▁ " , $ str , " ▁ has ▁ duplicate ▁ characters STRNEWLINE " ; }
function printRotatedString ( $ str ) { $ n = strlen ( $ str ) ; $ temp = $ str . $ str ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j != $ n ; $ j ++ ) print ( $ temp [ $ i + $ j ] ) ; print ( " STRNEWLINE " ) ; } }
function isKthBitSet ( $ n , $ k ) { if ( $ n & ( 1 << ( $ k - 1 ) ) ) echo " SET " ; else echo " NOT ▁ SET " ; }
function isKthBitSet ( $ n , $ k ) { if ( ( $ n >> ( $ k - 1 ) ) & 1 ) echo " SET " ; else echo " NOT ▁ SET " ; }
function evenNumSubstring ( $ str ) { $ len = strlen ( $ str ) ; $ count = 0 ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { $ temp = $ str [ $ i ] - '0' ; if ( $ temp % 2 == 0 ) $ count += ( $ i + 1 ) ; } return $ count ; }
function countSubstringWithEqualEnds ( $ s ) { $ result = 0 ; $ n = strlen ( $ s ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = $ i ; $ j < $ n ; $ j ++ ) if ( $ s [ $ i ] == $ s [ $ j ] ) $ result ++ ; return $ result ; }
function countSubstringWithEqualEnds ( $ s ) { global $ MAX_CHAR ; $ result = 0 ; $ n = strlen ( $ s ) ; $ count = array_fill ( 0 , $ MAX_CHAR , 0 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ count [ ord ( $ s [ $ i ] ) - ord ( ' a ' ) ] ++ ; for ( $ i = 0 ; $ i < $ MAX_CHAR ; $ i ++ ) $ result += ( $ count [ $ i ] * ( $ count [ $ i ] + 1 ) / 2 ) ; return $ result ; }
function maxRepeating ( $ str ) { $ n = strlen ( $ str ) ; $ count = 0 ; $ res = $ str [ 0 ] ; $ cur_count = 1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ i < $ n - 1 && $ str [ $ i ] == $ str [ $ i + 1 ] ) $ cur_count ++ ; else { if ( $ cur_count > $ count ) { $ count = $ cur_count ; $ res = $ str [ $ i ] ; } $ cur_count = 1 ; } } return $ res ; }
function check ( $ str ) { $ n = strlen ( $ str ) ; $ oddDigSum = 0 ; $ evenDigSum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ i % 2 == 0 ) $ oddDigSum += ( $ str [ $ i ] - '0' ) ; else $ evenDigSum += ( $ str [ $ i ] - '0' ) ; } return ( ( $ oddDigSum - $ evenDigSum ) % 11 == 0 ) ; }
function areChractersUnique ( $ str ) { $ checker = 0 ; for ( $ i = 0 ; $ i < $ len = strlen ( $ str ) ; ++ $ i ) { $ val = ( $ str [ $ i ] - ' a ' ) ; if ( ( $ checker & ( 1 << $ val ) ) > 0 ) return false ; $ checker |= ( 1 << $ val ) ; } return true ; }
function countWords ( $ str , $ len ) { $ count = 1 ; if ( $ len == 1 ) return $ count ; if ( $ str [ 0 ] == $ str [ 1 ] ) $ count *= 1 ; else $ count *= 2 ; for ( $ j = 1 ; $ j < $ len - 1 ; $ j ++ ) { if ( $ str [ $ j ] == $ str [ $ j - 1 ] && $ str [ $ j ] == $ str [ $ j + 1 ] ) $ count *= 1 ; else if ( $ str [ $ j ] == $ str [ $ j - 1 ] $ str [ $ j ] == $ str [ $ j + 1 ] $ str [ $ j - 1 ] == $ str [ $ j + 1 ] ) $ count *= 2 ; else $ count *= 3 ; } if ( $ str [ $ len - 1 ] == $ str [ $ len - 2 ] ) $ count *= 1 ; else $ count *= 2 ; return $ count ; }
function hammingDist ( $ str1 , $ str2 ) { $ i = 0 ; $ count = 0 ; while ( isset ( $ str1 [ $ i ] ) != ' ' ) { if ( $ str1 [ $ i ] != $ str2 [ $ i ] ) $ count ++ ; $ i ++ ; } return $ count ; }
function query ( $ s , $ i , $ j ) { $ n = strlen ( $ s ) ; $ i %= $ n ; $ j %= $ n ; if ( ( $ s [ $ i ] == $ s [ $ j ] ) ) echo " Yes STRNEWLINE " ; else echo " No " ; }
function isequal ( $ str ) { $ n = strlen ( $ str ) ; $ num = 0 ; $ x = 1 ; $ i = $ n - 1 ; for ( $ i = $ n - 1 ; $ i >= 0 ; $ i -- ) { if ( '0' <= $ str [ $ i ] && $ str [ $ i ] <= '9' ) { $ num = ( $ str [ $ i ] - '0' ) * $ x + $ num ; $ x = $ x * 10 ; if ( $ num >= $ n ) return false ; } else break ; } return $ num == $ i + 1 ; }
function arekAnagrams ( $ str1 , $ str2 , $ k ) { global $ MAX_CHAR ; $ n = strlen ( $ str1 ) ; if ( strlen ( $ str2 ) != $ n ) return false ; $ count1 = ( 0 ) ; $ count2 = ( 0 ) ; $ count = 0 ; for ( $ i = 0 ; $ i < $ MAX_CHAR ; $ i ++ ) if ( $ count1 [ $ i ] > $ count2 [ $ i ] ) $ count = $ count + abs ( $ count1 [ $ i ] - $ count2 [ $ i ] ) ; return ( $ count <= $ k ) ; }
function countToMake0lternate ( $ s ) { $ result = 0 ; for ( $ i = 0 ; $ i < ( strlen ( $ s ) - 1 ) ; $ i ++ ) if ( $ s [ $ i ] == $ s [ $ i + 1 ] ) $ result ++ ; return $ result ; }
function countPairs ( $ str ) { $ result = 0 ; $ n = strlen ( $ str ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) if ( abs ( ord ( $ str [ $ i ] ) - ord ( $ str [ $ j ] ) ) == abs ( $ i - $ j ) ) $ result ++ ; return $ result ; }
function findCount ( $ str ) { $ result = 0 ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) { if ( ( $ i == ord ( $ str [ $ i ] ) - ord ( ' a ' ) ) or ( $ i == ord ( $ str [ $ i ] ) - ord ( ' A ' ) ) ) $ result += 1 ; } return $ result ; }
function remAnagram ( $ str1 , $ str2 ) { $ count1 = array ( 26 ) ; $ count2 = array ( 26 ) ; for ( $ i = 0 ; $ i < strlen ( $ str1 ) ; $ i ++ ) $ count1 [ $ str1 [ $ i ] - ' a ' ] ++ ; for ( $ i = 0 ; $ i < strlen ( $ str2 ) ; $ i ++ ) $ count2 [ $ str2 [ $ i ] - ' a ' ] ++ ; $ result = 0 ; for ( $ i = 0 ; $ i < 26 ; $ i ++ ) $ result += abs ( $ count1 [ $ i ] - $ count2 [ $ i ] ) ; return $ result ; } { $ str1 = " bcadeh " ; $ str2 = " hea " ; echo ( remAnagram ( $ str1 , $ str2 ) ) ; }
function intToRoman ( $ num ) { $ m = array ( " " , " M " , " MM " , " MMM " ) ; $ c = array ( " " , " C " , " CC " , " CCC " , " CD " , " D " , " DC " , " DCC " , " DCCC " , " CM " ) ; $ x = array ( " " , " X " , " XX " , " XXX " , " XL " , " L " , " LX " , " LXX " , " LXXX " , " XC " ) ; $ i = array ( " " , " I " , " II " , " III " , " IV " , " V " , " VI " , " VII " , " VIII " , " IX " ) ; $ thousands = $ m [ $ num / 1000 ] ; $ hundereds = $ c [ ( $ num % 1000 ) / 100 ] ; $ tens = $ x [ ( $ num % 100 ) / 10 ] ; $ ones = $ i [ $ num % 10 ] ; $ ans = $ thousands . $ hundereds . $ tens . $ ones ; return $ ans ; }
function countkDist ( $ str , $ k ) { $ res = 0 ; $ n = strlen ( $ str ) ; $ cnt = array ( ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ dist_count = 0 ; $ cnt = array_fill ( 0 , 0 , true ) ; for ( $ j = $ i ; $ j < $ n ; $ j ++ ) { if ( $ cnt [ ord ( $ str [ $ j ] ) - ord ( ' a ' ) ] == 0 ) $ dist_count ++ ; $ cnt [ ord ( $ str [ $ j ] ) - ord ( ' a ' ) ] ++ ; if ( $ dist_count == $ k ) $ res ++ ; } } return $ res ; } { $ ch = " abcbaa " ; $ k = 3 ; echo ( " Total ▁ substrings ▁ with ▁ exactly ▁ " . $ k . " ▁ distinct ▁ characters ▁ : ▁ " . countkDist ( $ ch , $ k ) ) ; }
function isEditDistanceOne ( $ s1 , $ s2 ) { $ m = strlen ( $ s1 ) ; $ n = strlen ( $ s2 ) ; if ( abs ( $ m - $ n ) > 1 ) return false ; $ count = 0 ; $ i = 0 ; $ j = 0 ; while ( $ i < $ m && $ j < $ n ) { if ( $ s1 [ $ i ] != $ s2 [ $ j ] ) { if ( $ count == 1 ) return false ; if ( $ m > $ n ) $ i ++ ; else if ( $ m < $ n ) $ j ++ ; else { $ i ++ ; $ j ++ ; } $ count ++ ; } else { $ i ++ ; $ j ++ ; } } if ( $ i < $ m $ j < $ n ) $ count ++ ; return $ count == 1 ; }
function maxSubarrayXOR ( $ arr , $ n ) { $ ans = PHP_INT_MIN ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ curr_xor = 0 ; for ( $ j = $ i ; $ j < $ n ; $ j ++ ) { $ curr_xor = $ curr_xor ^ $ arr [ $ j ] ; $ ans = max ( $ ans , $ curr_xor ) ; } } return $ ans ; }
function pattern ( $ str , $ len ) { for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { $ j = $ len - 1 - $ i ; for ( $ k = 0 ; $ k < $ len ; $ k ++ ) { if ( $ k == $ i $ k == $ j ) echo $ str [ $ k ] ; else echo " ▁ " ; } echo " STRNEWLINE " ; } }
function removeRecur ( $ n ) { $ prev_digit = $ n % 10 ; $ pow = 10 ; $ res = $ prev_digit ; while ( $ n ) { $ curr_digit = $ n % 10 ; if ( $ curr_digit != $ prev_digit ) { $ res += $ curr_digit * $ pow ; $ prev_digit = $ curr_digit ; $ pow *= 10 ; } $ n = $ n / 10 ; } return $ res ; }
function countSubStr ( $ str ) { $ res = 0 ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) { if ( $ str [ $ i ] == '1' ) { for ( $ j = $ i + 1 ; $ j < strlen ( $ str ) ; $ j ++ ) if ( $ str [ $ j ] == '1' ) $ res ++ ; } } return $ res ; }
function countSubStr ( $ str ) { for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) { if ( $ str [ $ i ] == '1' ) { $ m ++ ; } } return $ m * ( $ m - 1 ) / 2 ; }
function count9s ( $ number ) { $ count = 0 ; $ n = strlen ( $ number ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sum = $ number [ $ i ] - '0' ; if ( $ number [ $ i ] == '9' ) $ count ++ ; for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) { $ sum = ( $ sum + $ number [ $ j ] - '0' ) % 9 ; if ( $ sum == 0 ) $ count ++ ; } } return $ count ; }
function countWords ( $ str ) { global $ OUT , $ IN ; $ state = $ OUT ; $ wc = 0 ; $ i = 0 ; while ( $ i < strlen ( $ str ) ) { if ( $ str [ $ i ] == " ▁ " $ str [ $ i ] == " STRNEWLINE " $ str [ $ i ] == " TABSYMBOL " ) $ state = $ OUT ; else if ( $ state == $ OUT ) { $ state = $ IN ; ++ $ wc ; } ++ $ i ; } return $ wc ; }
function reverse ( $ str ) { if ( ( $ str == null ) || ( strlen ( $ str ) <= 1 ) ) echo ( $ str ) ; else { echo ( $ str [ strlen ( $ str ) - 1 ] ) ; reverse ( substr ( $ str , 0 , ( strlen ( $ str ) - 1 ) ) ) ; } }
function F ( $ A , $ B ) { if ( $ A == 1 ) return ( 4 % $ B ) ; else { $ temp = F ( $ A - 1 , $ B ) ; return ( $ temp * $ temp ) % $ B ; } }
function rangeSum ( $ l , $ r ) { global $ MOD ; $ a = 1 ; $ b = 9 ; $ res = 0 ; for ( $ i = 1 ; $ i <= 10 ; $ i ++ ) { $ L = max ( $ l , $ a ) ; $ R = min ( $ r , $ b ) ; if ( $ L <= $ R ) { $ sum = ( $ L + $ R ) * ( $ R - $ L + 1 ) / 2 ; $ res += ( $ i * $ i ) * ( $ sum % $ MOD ) ; $ res %= $ MOD ; } $ a = $ a * 10 ; $ b = $ b * 10 + 9 ; } return $ res ; }
function exponentMod ( $ A , $ B , $ C ) { if ( $ A == 0 ) return 0 ; if ( $ B == 0 ) return 1 ; if ( $ B % 2 == 0 ) { $ y = exponentMod ( $ A , $ B / 2 , $ C ) ; $ y = ( $ y * $ y ) % $ C ; } else { $ y = $ A % $ C ; $ y = ( $ y * exponentMod ( $ A , $ B - 1 , $ C ) % $ C ) % $ C ; } return ( ( $ y + $ C ) % $ C ) ; }
function minDaysToEmpty ( $ C , $ l ) { if ( $ l >= $ C ) return $ C ; $ eq_root = ( int ) sqrt ( 1 + 8 * ( $ C - $ l ) - 1 ) / 2 ; return ceil ( $ eq_root ) + $ l ; }
function kth ( $ arr1 , $ arr2 , $ m , $ n , $ k ) { $ sorted1 [ $ m + $ n ] = 0 ; $ i = 0 ; $ j = 0 ; $ d = 0 ; while ( $ i < $ m && $ j < $ n ) { if ( $ arr1 [ $ i ] < $ arr2 [ $ j ] ) $ sorted1 [ $ d ++ ] = $ arr1 [ $ i ++ ] ; else $ sorted1 [ $ d ++ ] = $ arr2 [ $ j ++ ] ; } while ( $ i < $ m ) $ sorted1 [ $ d ++ ] = $ arr1 [ $ i ++ ] ; while ( $ j < $ n ) $ sorted1 [ $ d ++ ] = $ arr2 [ $ j ++ ] ; return $ sorted1 [ $ k - 1 ] ; }
function binarySearch ( $ arr , $ left , $ right ) { if ( $ left <= $ right ) { $ mid = ( $ left + $ right ) / 2 ; if ( $ arr [ $ mid - 1 ] < $ arr [ $ mid ] && $ arr [ $ mid ] > $ arr [ $ mid + 1 ] ) return $ mid ; if ( $ arr [ $ mid ] < $ arr [ $ mid + 1 ] ) return binarySearch ( $ arr , $ mid + 1 , $ right ) ; else return binarySearch ( $ arr , $ left , $ mid - 1 ) ; } return -1 ; }
function findRepeatingElement ( $ arr , $ low , $ high ) { if ( $ low > $ high ) return -1 ; $ mid = floor ( ( $ low + $ high ) / 2 ) ; if ( $ arr [ $ mid ] != $ mid + 1 ) { if ( $ mid > 0 && $ arr [ $ mid ] == $ arr [ $ mid - 1 ] ) return $ mid ; return findRepeatingElement ( $ arr , $ low , $ mid - 1 ) ; } return findRepeatingElement ( $ arr , $ mid + 1 , $ high ) ; }
function power ( $ x , $ y , $ p ) { $ res = 1 ; $ x = $ x % $ p ; if ( $ x == 0 ) return 0 ; while ( $ y > 0 ) { if ( $ y & 1 ) $ res = ( $ res * $ x ) % $ p ; y = $ y / 2 $ y = $ y >> 1 ; $ x = ( $ x * $ x ) % $ p ; } return $ res ; }
function floorSqrt ( $ x ) { if ( $ x == 0 $ x == 1 ) return $ x ; $ i = 1 ; $ result = 1 ; while ( $ result <= $ x ) { $ i ++ ; $ result = $ i * $ i ; } return $ i - 1 ; }
function sumOfInternalAngles ( $ n ) { if ( $ n < 3 ) return 0 ; return ( ( $ n - 2 ) * 180 ) ; }
function diagonal_length ( $ a ) { $ L ; $ L = $ a * sqrt ( 3 ) ; return $ L ; }
function find_area ( $ r , $ d ) { $ R = $ d / PI ; $ R += pow ( $ r , 2 ) ; $ R = sqrt ( $ R ) ; $ area = PI * pow ( $ R , 2 ) ; return $ area ; }
function Valid ( $ a , $ b , $ c , $ d ) { if ( $ a + $ b + $ c + $ d == 360 ) return true ; return false ; }
function circle ( $ x1 , $ y1 , $ x2 , $ y2 , $ r1 , $ r2 ) { $ distSq = ( $ x1 - $ x2 ) * ( $ x1 - $ x2 ) + ( $ y1 - $ y2 ) * ( $ y1 - $ y2 ) ; $ radSumSq = ( $ r1 + $ r2 ) * ( $ r1 + $ r2 ) ; if ( $ distSq == $ radSumSq ) return 1 ; else if ( $ distSq > $ radSumSq ) return -1 ; else return 0 ; }
function Regions ( $ Vertices , $ Edges ) { $ R = $ Edges + 2 - $ Vertices ; return $ R ; }
function lengthOfTangent ( $ r1 , $ r2 , $ d ) { echo " The ▁ length ▁ of ▁ the ▁ transverse ▁ common ▁ tangent ▁ is ▁ " , sqrt ( pow ( $ d , 2 ) - pow ( ( $ r1 + $ r2 ) , 2 ) ) ; }
function remainingArea ( $ N , $ M , $ K ) { while ( $ K -- && $ N && $ M ) { if ( $ N > $ M ) $ N = $ N - $ M ; else $ M = $ M - $ N ; } if ( $ N > 0 && $ M > 0 ) return $ N * $ M ; else return 0 ; }
function lengtang ( $ r1 , $ r2 , $ d ) { echo " The ▁ length ▁ of ▁ the ▁ direct ▁ common ▁ tangent ▁ is ▁ " , sqrt ( pow ( $ d , 2 ) - pow ( ( $ r1 - $ r2 ) , 2 ) ) ; }
function rad ( $ d , $ h ) { echo " The ▁ radius ▁ of ▁ the ▁ circle ▁ is ▁ " , ( ( $ d * $ d ) / ( 8 * $ h ) + $ h / 2 ) , " STRNEWLINE " ; }
function shortdis ( $ r , $ d ) { echo " The ▁ shortest ▁ distance ▁ " ; echo " from ▁ the ▁ chord ▁ to ▁ centre ▁ " ; echo sqrt ( ( $ r * $ r ) - ( ( $ d * $ d ) / 4 ) ) ; }
function lengtang ( $ r1 , $ r2 ) { echo " The ▁ length ▁ of ▁ the ▁ " , " direct ▁ common ▁ tangent ▁ is ▁ " , 2 * sqrt ( $ r1 * $ r2 ) ; }
function dist ( $ x1 , $ y1 , $ x2 , $ y2 , $ r ) { echo " The ▁ shortest ▁ distance ▁ between ▁ a ▁ point ▁ and ▁ a ▁ circle ▁ is ▁ " , sqrt ( ( pow ( ( $ x2 - $ x1 ) , 2 ) ) + ( pow ( ( $ y2 - $ y1 ) , 2 ) ) ) - $ r ; }
function lengtang ( $ r1 , $ r2 , $ d ) { echo " The ▁ length ▁ of ▁ the ▁ direct " , " ▁ common ▁ tangent ▁ is ▁ " , sqrt ( pow ( $ d , 2 ) - pow ( ( $ r1 - $ r2 ) , 2 ) ) , " STRNEWLINE " ; }
function length_of_chord ( $ r , $ x ) { echo " The ▁ length ▁ of ▁ the ▁ chord " , " ▁ of ▁ the ▁ circle ▁ is ▁ " , 2 * $ r * sin ( $ x * ( 3.14 / 180 ) ) ; }
function diameter ( $ r ) { echo " The ▁ length ▁ of ▁ the ▁ longest ▁ chord " , " ▁ or ▁ diameter ▁ of ▁ the ▁ circle ▁ is ▁ " , 2 * $ r << " STRNEWLINE " ; }
function normal ( $ m , $ n ) { $ N = ( abs ( $ m ) * abs ( $ n ) ) / sqrt ( ( abs ( $ m ) * abs ( $ m ) ) + ( abs ( $ n ) * abs ( $ n ) ) ) ; return $ N ; }
function getSlope ( $ m ) { return $ m ; }
function totalTriangles ( $ h , $ v ) { if ( $ h == 0 && $ v == 0 ) return 1 ; if ( $ h == 0 ) return ( ( $ v + 1 ) * ( $ v + 2 ) / 2 ) ; if ( $ v == 0 ) return ( $ h + 1 ) ; $ Total = ( $ h + 1 ) * ( ( $ v + 1 ) * ( $ v + 2 ) / 2 ) ; return $ Total ; }
function ellipse ( $ l , $ b ) { if ( $ l < 0 $ b < 0 ) return -1 ; $ x = ( 3.14 * $ l * $ b ) / 4 ; return $ x ; }
function isPossible ( $ a , $ n ) { $ sum = 0 ; $ maxS = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sum += $ a [ $ i ] ; $ maxS = max ( $ a [ $ i ] , $ maxS ) ; } if ( ( $ sum - $ maxS ) > $ maxS ) return true ; return false ; }
function findAreaShaded ( $ a ) { $ sqArea = $ a * $ a ; $ semiCircleArea = ( 3.14 * ( $ a * $ a ) / 8 ) ; $ ShadedArea = 4 * $ semiCircleArea - $ sqArea ; return $ ShadedArea ; }
function countSteps ( $ x , $ y ) { if ( $ x < $ y ) { return $ x + $ y + 2 * ( ( $ y - $ x ) / 2 ) ; } else { return $ x + $ y + 2 * ( ( ( $ x - $ y ) + 1 ) / 2 ) ; } }
function pointIsOnLine ( $ m , $ c , $ x , $ y ) { if ( $ y == ( ( $ m * $ x ) + $ c ) ) return true ; return false ; }
function sph ( $ r , $ R , $ h ) { if ( $ r < 0 && $ R < 0 && $ h < 0 ) return -1 ; $ x = $ r ; $ V = ( 4 * 3.14 * pow ( $ r , 3 ) ) / 3 ; return $ V ; }
function Area ( $ a , $ b ) { if ( $ a < 0 && $ b < 0 ) return -1 ; $ h = sqrt ( ( ( pow ( $ a , 2 ) + pow ( $ b , 2 ) ) / ( pow ( $ a , 2 ) * pow ( $ b , 2 ) ) ) ) ; $ A = 0.70477 * pow ( $ h , 2 ) ; return $ A ; }
function cone ( $ a ) { if ( $ a < 0 ) return -1 ; $ r = ( $ a * sqrt ( 2 ) ) / 3 ; $ h = ( 2 * $ a ) / 3 ; $ V = 3.14 * pow ( $ r , 2 ) * $ h ; return $ V ; }
function Area ( $ a ) { if ( $ a < 0 ) return -1 ; $ h = 1.268 * $ a ; $ A = 0.70477 * pow ( $ h , 2 ) ; return $ A ; }
function Area ( $ r ) { if ( $ r < 0 ) return -1 ; $ x = ( 2 * $ r ) / sqrt ( 5 ) ; $ A = 0.70477 * pow ( $ x , 2 ) ; return $ A ; }
function Area ( $ a ) { if ( $ a < 0 ) return -1 ; $ x = 0.464 * $ a ; $ A = 0.70477 * pow ( $ x , 2 ) ; return $ A ; }
function areaCircle ( $ b ) { $ area = $ GLOBALS [ ' pi ' ] * $ b * $ b ; return $ area ; }
function areaSquare ( $ side , $ fold ) { $ area = $ side * $ side ; return $ area * 1.0 / pow ( 2 , $ fold ) ; }
function square ( $ a ) { if ( $ a < 0 ) return -1 ; $ x = 0.464 * $ a ; return $ x ; }
function ReuleauxArea ( $ r ) { if ( $ r < 0 ) return -1 ; $ A = 0.70477 * 2 * pow ( $ r , 2 ) ; return $ A ; }
function cyl ( $ a ) { if ( $ a < 0 ) return -1 ; $ r = ( 2 * $ a * sqrt ( 2 ) ) / 3 ; $ h = ( 2 * $ a ) / 3 ; $ V = 3.14 * pow ( $ r , 2 ) * $ h ; return $ V ; }
function Area ( $ l , $ b , $ h ) { if ( $ l < 0 or $ b < 0 or $ h < 0 ) return -1 ; $ x = ( $ l * $ b ) / ( $ l + $ b ) ; $ A = 0.70477 * pow ( $ x , 2 ) ; return $ A ; }
function squareSide ( $ a ) { if ( $ a < 0 ) return -1 ; $ x = 0.423 * $ a ; return $ x ; }
function isPossible ( $ x , $ y , $ z ) { $ a = round ( $ x * $ x + $ y * $ y + $ z * $ z ) ; if ( ceil ( $ a ) == 1 && floor ( $ a ) == 1 ) return true ; return false ; }
function polyapothem ( $ n , $ a ) { if ( $ a < 0 && $ n < 0 ) return -1 ; return $ a / ( 2 * tan ( ( 180 / $ n ) * 3.14159 / 180 ) ) ; }
function polydiagonal ( $ n , $ a ) { if ( $ a < 0 && $ n < 0 ) return -1 ; return 2 * $ a * sin ( ( ( ( $ n - 2 ) * 180 ) / ( 2 * $ n ) ) * 3.14159 / 180 ) ; }
function polyarea ( $ n , $ r ) { if ( $ r < 0 && $ n < 0 ) return -1 ; $ A = ( ( $ r * $ r * $ n ) * sin ( ( 360 / $ n ) * 3.14159 / 180 ) ) / 2 ; return $ A ; }
function polyarea ( $ n , $ a ) { if ( $ a < 0 && $ n < 0 ) return -1 ; $ A = ( $ a * $ a * $ n ) / ( 4 * tan ( ( 180 / $ n ) * 3.14159 / 180 ) ) ; return $ A ; }
function decdiagonal ( $ a ) { if ( $ a < 0 ) return -1 ; $ d = 1.902 * $ a ; return $ d ; }
function heptdiagonal ( $ a ) { if ( $ a < 0 ) return -1 ; $ d = 1.802 * $ a ; return $ d ; }
function ReuleauxArea ( $ a ) { if ( $ a < 0 ) return -1 ; $ A = 0.70477 * pow ( $ a , 2 ) ; return $ A ; }
function hexagonside ( $ a ) { if ( $ a < 0 ) return -1 ; $ x = 0.5176 * $ a ; return $ x ; }
function hexagonside ( $ a ) { if ( $ a < 0 ) return -1 ; $ x = $ a / 3 ; return $ x ; }
function hexDiagonal ( $ a ) { if ( $ a < 0 ) return -1 ; $ d = 1.73 * $ a ; return $ d ; }
function pentdiagonal ( $ a ) { if ( $ a < 0 ) return -1 ; $ d = 1.22 * $ a ; return $ d ; }
function ReuleauxArea ( $ a ) { if ( $ a < 0 ) return -1 ; $ A = 0.70477 * pow ( $ a , 2 ) ; return $ A ; }
function calculateSide ( $ n , $ r ) { $ theta ; $ theta_in_radians ; $ theta = 360 / $ n ; $ theta_in_radians = $ theta * 3.14 / 180 ; return 2 * $ r * sin ( $ theta_in_radians / 2 ) ; }
function squareArea ( $ a ) { if ( $ a < 0 ) return -1 ; $ area = pow ( 1.268 , 2 ) * pow ( $ a , 2 ) ; return $ area ; }
function trianglearea ( $ a ) { if ( $ a < 0 ) return -1 ; $ area = ( 3 * sqrt ( 3 ) * pow ( $ a , 2 ) ) / 4 ; return $ area ; }
function CubeVolume ( $ d ) { $ Volume ; $ Volume = ( sqrt ( 3 ) * pow ( $ d , 3 ) ) / 9 ; return $ Volume ; }
function hexagonArea ( $ d ) { return ( 3 * sqrt ( 3 ) * pow ( $ d , 2 ) ) / 8 ; }
function cyl ( $ r , $ R , $ h ) { if ( $ h < 0 && $ r < 0 && $ R < 0 ) return -1 ; $ r1 = $ r ; $ h1 = $ h ; $ V = ( 3.14 * pow ( $ r1 , 2 ) * $ h1 ) ; return $ V ; }
function findVolume ( $ a ) { if ( $ a < 0 ) return -1 ; $ r = $ a / 2 ; $ h = $ a ; $ V = 3.14 * pow ( $ r , 2 ) * $ h ; return $ V ; }
function length_rope ( $ r ) { global $ PI ; return ( ( 2 * $ PI * $ r ) + 6 * $ r ) ; }
function area_circumscribed ( $ c ) { global $ PI ; return ( $ c * $ c * ( $ PI / 4 ) ) ; }
function cyl ( $ r , $ h ) { if ( $ r < 0 && $ h < 0 ) return -1 ; $ R = ( int ) ( 2 * $ r ) / 3 ; $ H = ( int ) ( 2 * $ h ) / 3 ; $ V = 3.14 * pow ( $ R , 2 ) * $ H ; return $ V ; }
function cube ( $ h , $ r ) { if ( $ h < 0 && $ r < 0 ) return -1 ; $ a = pow ( $ h , 3 ) ; return $ a ; }
function sph ( $ r , $ h ) { if ( $ r < 0 && $ h < 0 ) return -1 ; $ R = $ r ; return $ R ; }
function cyl ( $ R ) { if ( $ R < 0 ) return -1 ; $ V = ( 2 * 3.14 * pow ( $ R , 3 ) ) / ( 3 * sqrt ( 3 ) ) ; return $ V ; }
function rod ( $ h , $ r ) { if ( $ h < 0 && $ r < 0 ) return -1 ; $ l = sqrt ( pow ( $ h , 2 ) + 4 * pow ( $ r , 2 ) ) ; return $ l ; }
function cubeSide ( $ h , $ r ) { if ( $ h < 0 && $ r < 0 ) return -1 ; $ a = ( $ h * $ r * sqrt ( 2 ) ) / ( $ h + sqrt ( 2 ) * $ r ) ; return $ a ; }
function largestCube ( $ r ) { if ( $ r < 0 ) return -1 ; $ a = ( float ) ( ( 2 * $ r ) / sqrt ( 3 ) ) ; return $ a ; }
function sphere ( $ a ) { if ( $ a < 0 ) return -1 ; $ r = ( $ a / 2 ) ; return $ r ; }
function numberOfCuts ( $ M , $ N ) { $ result = 0 ; $ result = ( $ M - 1 ) * ( $ N - 1 ) ; return $ result ; }
function maxVol ( $ P , $ A ) { $ l = ( $ P - sqrt ( $ P * $ P - 24 * $ A ) ) / 12 ; $ V = $ l * ( $ A / 2.0 - $ l * ( $ P / 4.0 - $ l ) ) ; return $ V ; }
function rhombusAreaPeri ( $ d1 , $ d2 ) { $ area = ( $ d1 * $ d2 ) / 2 ; $ perimeter = 2 * sqrt ( pow ( $ d1 , 2 ) + pow ( $ d2 , 2 ) ) ; echo " The ▁ area ▁ of ▁ rhombus ▁ with ▁ diagonals ▁ " . $ d1 . " ▁ and ▁ " . $ d2 . " ▁ is ▁ " . $ area . " . " . " STRNEWLINE " ; echo " The ▁ perimeter ▁ of ▁ rhombus ▁ with ▁ diagonals ▁ " . $ d1 . " ▁ and ▁ " . $ d2 . " ▁ is ▁ " . $ perimeter . " . " . " STRNEWLINE " ; }
function equation_ellipse ( $ x1 , $ y1 , $ a , $ b , $ c , $ e ) { $ t = ( $ a * $ a ) + ( $ b * $ b ) ; $ a1 = $ t - $ e * ( $ a * $ a ) ; $ b1 = $ t - $ e * ( $ b * $ b ) ; $ c1 = ( -2 * $ t * $ x1 ) - ( 2 * $ e * $ c * $ a ) ; $ d1 = ( -2 * $ t * $ y1 ) - ( 2 * $ e * $ c * $ b ) ; $ e1 = -2 * $ e * $ a * $ b ; $ f1 = ( - $ e * $ c * $ c ) + ( $ t * $ x1 * $ x1 ) + ( $ t * $ y1 * $ y1 ) ; $ fixed ; echo " Equation ▁ of ▁ ellipse ▁ is ▁ STRNEWLINE " , $ a1 , " ▁ x ^ 2 ▁ + ▁ " , $ b1 , " ▁ y ^ 2 ▁ + ▁ " , $ c1 , " ▁ x ▁ + ▁ " , $ d1 , " ▁ y ▁ + ▁ " , $ e1 , " ▁ xy ▁ + ▁ " , $ f1 , " ▁ = ▁ 0" ; }
function maxArea ( $ perimeter ) { $ length = ( int ) ceil ( $ perimeter / 4 ) ; $ breadth = ( int ) floor ( $ perimeter / 4 ) ; return ( $ length * $ breadth ) ; }
function countMaxIntersect ( $ n ) { return ( $ n ) * ( $ n - 1 ) / 2 ; }
function foot ( $ a , $ b , $ c , $ d , $ x1 , $ y1 , $ z1 ) { $ k = ( - $ a * $ x1 - $ b * $ y1 - $ c * $ z1 - $ d ) / ( $ a * $ a + $ b * $ b + $ c * $ c ) ; $ x2 = $ a * $ k + $ x1 ; $ y2 = $ b * $ k + $ y1 ; $ z2 = $ c * $ k + $ z1 ; echo " x2 = " ▁ . ▁ round ( $ x2 , ▁ 1 ) ; STRNEWLINE TABSYMBOL echo ▁ " y2 = " ▁ . ▁ round ( $ y2 , ▁ 1 ) ; STRNEWLINE TABSYMBOL echo ▁ " z2 = " }
function circle_equation ( $ x1 , $ y1 , $ r ) { $ a = -2 * $ x1 ; $ b = -2 * $ y1 ; $ c = ( $ r * $ r ) - ( $ x1 * $ x1 ) - ( $ y1 * $ y1 ) ; echo " x ^ 2 + ( " ▁ . ▁ $ a ▁ . ▁ " x ) + " echo " y ^ 2 ▁ + ▁ ( " . $ b . " ▁ y ) ▁ = ▁ " ; echo $ c . " . " . " STRNEWLINE " ; }
function section ( $ x1 , $ x2 , $ y1 , $ y2 , $ z1 , $ z2 , $ m , $ n ) { $ x = ( ( $ m * $ x2 ) + ( $ n * $ x1 ) ) / ( $ m + $ n ) ; $ y = ( ( $ m * $ y2 ) + ( $ n * $ y1 ) ) / ( $ m + $ n ) ; $ z = ( ( $ m * $ z2 ) + ( $ n * $ z1 ) ) / ( $ m + $ n ) ; echo " ( " . $ x . " , " ; ▁ echo ▁ $ y ▁ . ▁ " , " ; ▁ echo ▁ $ z ▁ . ▁ " ) " ▁ . " " }
function Squares ( $ n , $ m , $ a ) { return ( ( int ) ( ( $ m + $ a - 1 ) / $ a ) ) * ( ( int ) ( ( $ n + $ a - 1 ) / $ a ) ) ; }
function Perimeter ( $ s , $ n ) { $ perimeter = 1 ; $ perimeter = $ n * $ s ; return $ perimeter ; }
function checkEquilibrium ( $ x1 , $ y1 , $ z1 , $ x2 , $ y2 , $ z2 , $ x3 , $ y3 , $ z3 ) { $ resx = $ x1 + $ x2 + $ x3 ; $ resy = $ y1 + $ y2 + $ y3 ; $ resz = $ z1 + $ z2 + $ z3 ; if ( $ resx == 0 and $ resy == 0 and $ resz == 0 ) return true ; else return false ; }
function findTangent ( $ A , $ x , $ y ) { $ dif = $ A - $ x * 2 ; if ( $ y == ( 2 * $ x - $ x * $ x ) ) { if ( $ dif < 0 ) echo " y = " , ▁ $ dif ▁ , ▁ " x " ( $ x * $ dif ) + ( $ y ) ; else if ( $ dif > 0 ) echo " y ▁ = ▁ " , $ dif , " x + " , - $ x * $ dif + $ y ; else echo " Not ▁ possible " ; } }
function hexadiagonal ( $ a ) { if ( $ a < 0 ) return -1 ; return 2 * $ a ; }
function octadiagonal ( $ a ) { if ( $ a < 0 ) return -1 ; return $ a * sqrt ( 4 + ( 2 * sqrt ( 2 ) ) ) ; }
function CalPeri ( $ s ) { $ Perimeter = 10 * $ s ; echo " The ▁ Perimeter ▁ of ▁ Decagon ▁ is ▁ : ▁ $ Perimeter " ; }
function octaside ( $ a ) { if ( $ a < 0 ) return -1 ; $ s = $ a / ( sqrt ( 2 ) + 1 ) ; return $ s ; }
function findEdges ( $ s1 , $ s2 , $ s3 ) { $ a = sqrt ( $ s1 * $ s2 / $ s3 ) ; $ b = sqrt ( $ s3 * $ s1 / $ s2 ) ; $ c = sqrt ( $ s3 * $ s2 / $ s1 ) ; $ sum = $ a + $ b + $ c ; return 4 * $ sum ; }
function findRadiusOfcircumcircle ( $ n , $ a ) { if ( $ n < 0 $ a < 0 ) return -1 ; $ radius = $ a / sqrt ( 2 - ( 2 * cos ( 360 / $ n ) ) ) ; return $ radius ; }
function rhombusarea ( $ l , $ b ) { if ( $ l < 0 $ b < 0 ) return -1 ; return ( $ l * $ b ) / 2 ; }
function Move ( $ a , $ x , $ b ) { if ( ( ( ( $ b - $ a ) % $ x == 0 ) || ( ( $ b - $ a - 1 ) % $ x == 0 ) && $ a + 1 != $ b ) && $ b >= $ a ) return true ; return false ; }
function area ( $ a , $ b ) { if ( $ a < 0 $ b < 0 ) return -1 ; $ A = $ a * $ b ; return $ A ; }
function circle_inscribed ( $ a ) { return 3.14 * ( $ a * $ a ) / 12 ; }
function findRadiusOfcircumcircle ( $ l , $ b ) { if ( $ l < 0 $ b < 0 ) return -1 ; $ radius = sqrt ( pow ( $ l , 2 ) + pow ( $ b , 2 ) ) / 2 ; return $ radius ; }
function surfaceArea ( $ b , $ s ) { return 2 * $ b * $ s + pow ( $ b , 2 ) ; }
function findRadiusOfIncircle ( $ a , $ b , $ c ) { if ( $ a < 0 $ b < 0 $ c < 0 ) return -1 ; $ p = ( $ a + $ b + $ c ) / 2 ; $ area = sqrt ( $ p * ( $ p - $ a ) * ( $ p - $ b ) * ( $ p - $ c ) ) ; $ radius = $ area / $ p ; return $ radius ; }
function trianglearea ( $ l , $ b ) { if ( $ l < 0 or $ b < 0 ) return -1 ; $ area = ( $ l * $ b ) / 2 ; return $ area ; }
function area ( $ a ) { if ( $ a < 0 ) return -1 ; $ area = sqrt ( $ a ) / 6 ; return $ area ; }
function halfsquare ( $ n , $ x , $ y ) { $ half = $ n / 2 ; if ( ( $ half == $ x $ half == $ x - 1 ) && ( $ half == $ y $ half == $ y - 1 ) ) echo " NO " ; else echo " YES " ; }
function checkpoint ( $ h , $ k , $ x , $ y , $ a ) { $ p = pow ( ( $ y - $ k ) , 2 ) - 4 * $ a * ( $ x - $ h ) ; return $ p ; }
function checkpoint ( $ h , $ k , $ x , $ y , $ a , $ b ) { $ p = ( pow ( ( $ x - $ h ) , 2 ) / pow ( $ a , 2 ) ) + ( pow ( ( $ y - $ k ) , 2 ) / pow ( $ b , 2 ) ) ; return $ p ; }
function findVolume ( $ u , $ v , $ w , $ U , $ V , $ W , $ b ) { $ uPow = pow ( $ u , 2 ) ; $ vPow = pow ( $ v , 2 ) ; $ wPow = pow ( $ w , 2 ) ; $ UPow = pow ( $ U , 2 ) ; $ VPow = pow ( $ V , 2 ) ; $ WPow = pow ( $ W , 2 ) ; $ a = 4 * ( $ uPow * $ vPow * $ wPow ) - $ uPow * pow ( ( $ vPow + $ wPow - $ UPow ) , 2 ) - $ vPow * pow ( ( $ wPow + $ uPow - $ VPow ) , 2 ) - $ wPow * pow ( ( $ uPow + $ vPow - $ WPow ) , 2 ) + ( $ vPow + $ wPow - $ UPow ) * ( $ wPow + $ uPow - $ VPow ) * ( $ uPow + $ vPow - $ WPow ) ; $ vol = sqrt ( $ a ) ; $ vol /= $ b ; echo $ vol ; }
function trianglearea ( $ a , $ b ) { if ( $ a < 0 $ b < 0 ) return -1 ; $ area = ( 3 * sqrt ( 3 ) * pow ( $ a , 2 ) ) / ( 4 * $ b ) ; return $ area ; }
function squarearea ( $ a , $ b ) { if ( $ a < 0 or $ b < 0 ) return -1 ; $ area = 4 * ( ( ( pow ( $ a , 2 ) + pow ( $ b , 2 ) ) / ( pow ( $ a , 2 ) * pow ( $ b , 2 ) ) ) ) ; return $ area ; }
function longestRodInCuboid ( $ length , $ breadth , $ height ) { $ result ; $ temp ; $ temp = $ length * $ length + $ breadth * $ breadth + $ height * $ height ; $ result = sqrt ( $ temp ) ; return $ result ; }
function trianglearea ( $ r ) { if ( $ r < 0 ) return -1 ; return $ r * $ r ; }
function squarearea ( $ r ) { if ( $ r < 0 ) return -1 ; $ a = 4 * ( pow ( $ r , 2 ) / 5 ) ; return $ a ; }
function rectanglearea ( $ a , $ b ) { if ( $ a < 0 or $ b < 0 ) return -1 ; return 2 * $ a * $ b ; }
function trapezoidarea ( $ r ) { if ( $ r < 0 ) return -1 ; $ a = ( 3 * sqrt ( 3 ) * pow ( $ r , 2 ) ) / 4 ; return $ a ; }
function squareArea ( $ l , $ b , $ h ) { if ( $ l < 0 $ b < 0 $ h < 0 ) return -1 ; $ a = ( $ l * $ b ) / ( $ l + $ b ) ; return $ a * $ a ; }
function circlearea ( $ a , $ b ) { if ( $ a < 0 $ b < 0 ) return -1 ; $ A = ( 3.14 * pow ( $ a , 2 ) * pow ( $ b , 2 ) ) / ( 4 * ( pow ( $ a , 2 ) + pow ( $ b , 2 ) ) ) ; return $ A ; }
function circlearea ( $ l , $ b ) { if ( $ l < 0 $ b < 0 ) return -1 ; if ( $ l < $ b ) return 3.14 * pow ( $ l / 2 , 2 ) ; else return 3.14 * pow ( $ b / 2 , 2 ) ; }
function rectanglearea ( $ r ) { if ( $ r < 0 ) return -1 ; $ a = $ r * $ r ; return $ a ; }
function shortestLength ( $ n , & $ x , & $ y ) { $ answer = 0 ; $ i = 0 ; while ( $ n -- ) { if ( $ x [ $ i ] + $ y [ $ i ] > $ answer ) $ answer = $ x [ $ i ] + $ y [ $ i ] ; $ i ++ ; } echo " Length ▁ - > ▁ " . $ answer . " STRNEWLINE " ; echo " Path ▁ - > ▁ " . " ( 1 , " ▁ . $ answer ▁ . " ) " . STRNEWLINE TABSYMBOL TABSYMBOL " and ( " ▁ . $ answer ▁ . ▁ " , 1 ) " ; }
function maxLines ( $ n , $ x1 , $ y1 , $ x2 , $ y2 ) { $ s = array ( ) ; $ slope ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { if ( $ x1 [ $ i ] == $ x2 [ $ i ] ) $ slope = PHP_INT_MAX ; else $ slope = ( $ y2 [ $ i ] - $ y1 [ $ i ] ) * 1.0 / ( $ x2 [ $ i ] - $ x1 [ $ i ] ) * 1.0 ; array_push ( $ s , $ slope ) ; } return count ( $ s ) ; }
function squares ( $ l , $ b , $ a ) { return ceil ( $ l / ( double ) $ a ) * ceil ( $ b / ( double ) $ a ) ; }
function angle_triangle ( $ x1 , $ x2 , $ x3 , $ y1 , $ y2 , $ y3 , $ z1 , $ z2 , $ z3 ) { $ num = ( $ x2 - $ x1 ) * ( $ x3 - $ x1 ) + ( $ y2 - $ y1 ) * ( $ y3 - $ y1 ) + ( $ z2 - $ z1 ) * ( $ z3 - $ z1 ) ; $ den = sqrt ( pow ( ( $ x2 - $ x1 ) , 2 ) + pow ( ( $ y2 - $ y1 ) , 2 ) + pow ( ( $ z2 - $ z1 ) , 2 ) ) * sqrt ( pow ( ( $ x3 - $ x1 ) , 2 ) + pow ( ( $ y3 - $ y1 ) , 2 ) + pow ( ( $ z3 - $ z1 ) , 2 ) ) ; $ angle = acos ( $ num / $ den ) * ( 180.0 / 3.141592653589793238463 ) ; return $ angle ; }
function findMaximumPieces ( $ n ) { $ x = ( int ) ( $ n / 2 ) ; return ( ( $ x + 1 ) * ( $ n - $ x + 1 ) ) ; }
function makePolygon ( $ a ) { $ n = 360 / ( 180 - $ a ) ; if ( $ n == ( int ) $ n ) echo " YES " ; else echo " NO " ; }
function LiesInsieRectangle ( $ a , $ b , $ x , $ y ) { if ( $ x - $ y - $ b <= 0 && $ x - $ y + $ b >= 0 && $ x + $ y - 2 * $ a + $ b <= 0 && $ x + $ y - $ b >= 0 ) return true ; return false ; }
function equation_plane ( $ x1 , $ y1 , $ z1 , $ x2 , $ y2 , $ z2 , $ x3 , $ y3 , $ z3 , $ x , $ y , $ z ) { $ a1 = $ x2 - $ x1 ; $ b1 = $ y2 - $ y1 ; $ c1 = $ z2 - $ z1 ; $ a2 = $ x3 - $ x1 ; $ b2 = $ y3 - $ y1 ; $ c2 = $ z3 - $ z1 ; $ a = $ b1 * $ c2 - $ b2 * $ c1 ; $ b = $ a2 * $ c1 - $ a1 * $ c2 ; $ c = $ a1 * $ b2 - $ b1 * $ a2 ; $ d = ( - $ a * $ x1 - $ b * $ y1 - $ c * $ z1 ) ; if ( $ a * $ x + $ b * $ y + $ c * $ z + $ d == 0 ) echo ( " Coplanar " ) ; else echo ( " Not ▁ Coplanar " ) ; }
function solve ( $ M , $ N , $ s ) { $ ans = ( ( int ) ( ceil ( $ M / $ s ) ) * ( int ) ( ceil ( $ N / $ s ) ) ) ; return $ ans ; }
function FindPoints ( $ x1 , $ y1 , $ x2 , $ y2 , $ x3 , $ y3 , $ x4 , $ y4 ) { $ x5 = max ( $ x1 , $ x3 ) ; $ y5 = max ( $ y1 , $ y3 ) ; $ x6 = min ( $ x2 , $ x4 ) ; $ y6 = min ( $ y2 , $ y4 ) ; if ( $ x5 > $ x6 $ y5 > $ y6 ) { echo " No ▁ intersection " ; return ; } echo " ( " . $ x5 . " , " ▁ . ▁ $ y5 ▁ . ▁ " ) " ; echo " ( " . $ x6 . " , " ▁ . ▁ $ y6 ▁ . ▁ " ) " ; $ x7 = $ x5 ; $ y7 = $ y6 ; echo " ( " . $ x7 . " , " ▁ . ▁ $ y7 ▁ . ▁ " ) " ; $ x8 = $ x6 ; $ y8 = $ y5 ; echo " ( " . $ x8 . " , " ▁ . ▁ $ y8 ▁ . ▁ " ) " ; }
function FindPoint ( $ x1 , $ y1 , $ x2 , $ y2 , $ x , $ y ) { if ( $ x > $ x1 and $ x < $ x2 and $ y > $ y1 and $ y < $ y2 ) return true ; return false ; }
function distance ( $ a1 , $ b1 , $ c1 , $ d1 , $ a2 , $ b2 , $ c2 , $ d2 ) { if ( $ a1 / $ a2 == $ b1 / $ b2 && $ b1 / $ b2 == $ c1 / $ c2 ) { $ x1 = $ y1 = 0 ; $ z1 = - $ d1 / $ c1 ; $ d = abs ( ( $ c2 * $ z1 + $ d2 ) ) / ( sqrt ( $ a2 * $ a2 + $ b2 * $ b2 + $ c2 * $ c2 ) ) ; echo " Perpendicular ▁ distance ▁ is ▁ " , $ d ; } else echo " Planes ▁ are ▁ not ▁ parallel " ; }
function distance ( $ a1 , $ b1 , $ c1 , $ a2 , $ b2 , $ c2 ) { $ d = ( $ a1 * $ a2 + $ b1 * $ b2 + $ c1 * $ c2 ) ; $ e1 = sqrt ( $ a1 * $ a1 + $ b1 * $ b1 + $ c1 * $ c1 ) ; $ e2 = sqrt ( $ a2 * $ a2 + $ b2 * $ b2 + $ c2 * $ c2 ) ; $ d = $ d / ( $ e1 * $ e2 ) ; $ pi = 3.14159 ; $ A = ( 180 / $ pi ) * ( acos ( $ d ) ) ; echo sprintf ( " Angle ▁ is ▁ % .2f ▁ degree " , $ A ) ; }
function shortest_distance ( $ x1 , $ y1 , $ z1 , $ a , $ b , $ c , $ d ) { $ d = abs ( ( $ a * $ x1 + $ b * $ y1 + $ c * $ z1 + $ d ) ) ; $ e = sqrt ( $ a * $ a + $ b * $ b + $ c * $ c ) ; echo " Perpendicular ▁ distance ▁ is ▁ " . $ d / $ e ; }
function haversine ( $ lat1 , $ lon1 , $ lat2 , $ lon2 ) { $ dLat = ( $ lat2 - $ lat1 ) * M_PI / 180.0 ; $ dLon = ( $ lon2 - $ lon1 ) * M_PI / 180.0 ; $ lat1 = ( $ lat1 ) * M_PI / 180.0 ; $ lat2 = ( $ lat2 ) * M_PI / 180.0 ; $ a = pow ( sin ( $ dLat / 2 ) , 2 ) + pow ( sin ( $ dLon / 2 ) , 2 ) * cos ( $ lat1 ) * cos ( $ lat2 ) ; $ rad = 6371 ; $ c = 2 * asin ( sqrt ( $ a ) ) ; return $ rad * $ c ; }
function equation_plane ( $ x1 , $ y1 , $ z1 , $ x2 , $ y2 , $ z2 , $ x3 , $ y3 , $ z3 ) { $ a1 = $ x2 - $ x1 ; $ b1 = $ y2 - $ y1 ; $ c1 = $ z2 - $ z1 ; $ a2 = $ x3 - $ x1 ; $ b2 = $ y3 - $ y1 ; $ c2 = $ z3 - $ z1 ; $ a = $ b1 * $ c2 - $ b2 * $ c1 ; $ b = $ a2 * $ c1 - $ a1 * $ c2 ; $ c = $ a1 * $ b2 - $ b1 * $ a2 ; $ d = ( - $ a * $ x1 - $ b * $ y1 - $ c * $ z1 ) ; echo sprintf ( " equation ▁ of ▁ the ▁ plane ▁ is ▁ % .2fx " . " ▁ + ▁ % .2fy ▁ + ▁ % .2fz ▁ + ▁ % .2f ▁ = ▁ 0" , $ a , $ b , $ c , $ d ) ; }
function mirror_point ( $ a , $ b , $ c , $ d , $ x1 , $ y1 , $ z1 ) { $ k = ( - $ a * $ x1 - $ b * $ y1 - $ c * $ z1 - $ d ) / ( $ a * $ a + $ b * $ b + $ c * $ c ) ; $ x2 = $ a * $ k + $ x1 ; $ y2 = $ b * $ k + $ y1 ; $ z2 = $ c * $ k + $ z1 ; $ x3 = 2 * $ x2 - $ x1 ; $ y3 = 2 * $ y2 - $ y1 ; $ z3 = 2 * $ z2 - $ z1 ; echo sprintf ( " x3 ▁ = ▁ % .1f ▁ " , $ x3 ) ; echo sprintf ( " y3 ▁ = ▁ % .1f ▁ " , $ y3 ) ; echo sprintf ( " z3 ▁ = ▁ % .1f ▁ " , $ z3 ) ; }
function octant ( $ x , $ y , $ z ) { if ( $ x >= 0 && $ y >= 0 && $ z >= 0 ) echo " Point ▁ lies ▁ in ▁ 1st ▁ octant STRNEWLINE " ; else if ( $ x < 0 && $ y >= 0 && $ z >= 0 ) echo " Point ▁ lies ▁ in ▁ 2nd ▁ octant STRNEWLINE " ; else if ( $ x < 0 && $ y < 0 && $ z >= 0 ) echo " Point ▁ lies ▁ in ▁ 3rd ▁ octant STRNEWLINE " ; else if ( $ x >= 0 && $ y < 0 && $ z >= 0 ) echo " Point ▁ lies ▁ in ▁ 4th ▁ octant STRNEWLINE " ; else if ( $ x >= 0 && $ y >= 0 && $ z < 0 ) echo " Point ▁ lies ▁ in ▁ 5th ▁ octant STRNEWLINE " ; else if ( $ x < 0 && $ y >= 0 && $ z < 0 ) echo " Point ▁ lies ▁ in ▁ 6th ▁ octant STRNEWLINE " ; else if ( $ x < 0 && $ y < 0 && $ z < 0 ) echo " Point ▁ lies ▁ in ▁ 7th ▁ octant STRNEWLINE " ; else if ( $ x >= 0 && $ y < 0 && $ z < 0 ) echo " Point ▁ lies ▁ in ▁ 8th ▁ octant STRNEWLINE " ; }
function findVolume ( $ l , $ b , $ h ) { $ volume = ( $ l * $ b * $ h ) / 2 ; return $ volume ; }
function countNumberOfTriangles ( $ n ) { return $ n * ( $ n - 1 ) * ( $ n - 2 ) / 6 ; }
function countRectangles ( $ radius ) { $ rectangles = 0 ; $ diameter = 2 * $ radius ; $ diameterSquare = $ diameter * $ diameter ; for ( $ a = 1 ; $ a < 2 * $ radius ; $ a ++ ) { for ( $ b = 1 ; $ b < 2 * $ radius ; $ b ++ ) { $ diagonalLengthSquare = ( $ a * $ a + $ b * $ b ) ; if ( $ diagonalLengthSquare <= $ diameterSquare ) { $ rectangles ++ ; } } } return $ rectangles ; }
function heptagonalNumber ( $ n ) { return ( ( 5 * $ n * $ n ) - ( 3 * $ n ) ) / 2 ; }
function centeredTridecagonalNum ( $ n ) { return ( 13 * $ n * ( $ n - 1 ) + 2 ) / 2 ; }
function pentagon_pyramidal ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ p = ( 3 * $ i * $ i - $ i ) / 2 ; $ sum = $ sum + $ p ; } return $ sum ; }
function pentagon_pyramidal ( $ n ) { return $ n * $ n * ( $ n + 1 ) / 2 ; }
function checkConcurrent ( $ a1 , $ b1 , $ c1 , $ a2 , $ b2 , $ c2 , $ a3 , $ b3 , $ c3 ) { return ( $ a3 * ( $ b1 * $ c2 - $ b2 * $ c1 ) + $ b3 * ( $ c1 * $ a2 - $ c2 * $ a1 ) + $ c3 * ( $ a1 * $ b2 - $ a2 * $ b1 ) == 0 ) ; }
function getQuadrant ( $ X , $ Y , $ R , $ PX , $ PY ) { if ( $ PX == $ X and $ PY == $ Y ) return 0 ; $ val = pow ( ( $ PX - $ X ) , 2 ) + pow ( ( $ PY - $ Y ) , 2 ) ; if ( $ val > pow ( $ R , 2 ) ) return -1 ; if ( $ PX > $ X and $ PY >= $ Y ) return 1 ; if ( $ PX <= $ X and $ PY > $ Y ) return 2 ; if ( $ PX < $ X and $ PY <= $ Y ) return 3 ; if ( $ PX >= $ X and $ PY < $ Y ) return 4 ; }
function center_pentadecagonal_num ( $ n ) { return ( 15 * $ n * $ n - 15 * $ n + 2 ) / 2 ; }
function icosidigonal_num ( $ n ) { return ( 20 * $ n * $ n - 18 * $ n ) / 2 ; }
function center_nonadecagon_num ( $ n ) { return ( 19 * $ n * $ n - 19 * $ n + 2 ) / 2 ; }
function center_octadecagon_num ( $ n ) { return ( 9 * $ n * $ n - 9 * $ n + 1 ) ; }
function hendecagonal_num ( $ n ) { return ( 9 * $ n * $ n - 7 * $ n ) / 2 ; }
function centereddecagonalnum ( $ n ) { return ( 5 * $ n * $ n + 5 * $ n + 1 ) ; }
function cen_octagonalnum ( $ n ) { return ( 4 * $ n * $ n - 4 * $ n + 1 ) ; }
function centered_cube ( $ n ) { return ( 2 * $ n + 1 ) * ( $ n * $ n + $ n + 1 ) ; }
function nthEnneadecagonal ( $ n ) { return ( 17 * $ n * $ n - 15 * $ n ) / 2 ; }
function hexadecagonalNum ( $ n ) { return ( ( 14 * $ n * $ n ) - 12 * $ n ) / 2 ; }
function centered_pentagonal_Num ( $ n ) { return ( 5 * $ n * $ n - 5 * $ n + 2 ) / 2 ; }
function findPoint ( $ x1 , $ y1 , $ x2 , $ y2 ) { echo " ( " , 2 * $ x2 - $ x1 , " , ▁ " , 2 * $ y2 - $ y1 , " ) " ; }
function findPCSlope ( $ m ) { return -1.0 / $ m ; }
function parallel ( $ n , $ a ) { $ x = true ; $ y = true ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { if ( $ a [ $ i ] [ 0 ] != $ a [ $ i + 1 ] [ 0 ] ) $ x = false ; if ( $ a [ $ i ] [ 1 ] != $ a [ $ i + 1 ] [ 1 ] ) $ y = false ; } if ( $ x ) echo " parallel ▁ to ▁ Y ▁ Axis " ; else if ( y ) echo " parallel ▁ to ▁ X ▁ Axis " ; else echo " Not ▁ parallel ▁ to ▁ X " , " ▁ and ▁ Y ▁ Axis " ; }
function otherEndPoint ( $ x1 , $ y1 , $ m1 , $ m2 ) { $ x2 = ( 2 * $ m1 - $ x1 ) ; $ y2 = ( 2 * $ m2 - $ y1 ) ; echo " x2 ▁ = ▁ " . $ x2 . " , ▁ y2 ▁ = ▁ " . $ y2 ; }
function numberOfSticks ( $ x ) { return ( 3 * $ x * ( $ x + 1 ) ) / 2 ; }
function printRect ( $ X , $ Y , $ n ) { $ Xmax = max ( $ X ) ; $ Xmin = min ( $ X ) ; $ Ymax = max ( $ Y ) ; $ Ymin = min ( $ Y ) ; echo " { " , $ Xmin , " , ▁ " , $ Ymin , " } " , " STRNEWLINE " ; echo " { " , $ Xmin , " , ▁ " , $ Ymax , " } " , " STRNEWLINE " ; echo " { " , $ Xmax , " , ▁ " , $ Ymax , " } " , " STRNEWLINE " ; echo " { " , $ Xmax , " , ▁ " , $ Ymin , " } " ; }
function checkOrigin ( $ x1 , $ y1 , $ x2 , $ y2 ) { return ( $ x1 * ( $ y2 - $ y1 ) == $ y1 * ( $ x2 - $ x1 ) ) ; }
function checkcircle ( $ r , $ R , $ r1 , $ x1 , $ y1 ) { $ dis = sqrt ( $ x1 * $ x1 + $ y1 * $ y1 ) ; return ( $ dis - $ r1 >= $ R && $ dis + $ r1 <= $ r ) ; }
function areacircumscribed ( $ a ) { global $ PI ; return ( $ a * $ a * ( $ PI / 2 ) ) ; }
function surface_area_octahedron ( $ side ) { return ( 2 * ( sqrt ( 3 ) ) * ( $ side * $ side ) ) ; }
function find_Area ( $ r ) { return ( 2 * $ r * $ r ) ; }
function checkValidity ( $ a , $ b , $ c ) { if ( $ a + $ b <= $ c $ a + $ c <= $ b $ b + $ c <= $ a ) return false ; else return true ; }
function pythagorean_quadruple ( $ a , $ b , $ c , $ d ) { $ sum = $ a * $ a + $ b * $ b + $ c * $ c ; if ( $ d * $ d == $ sum ) return true ; else return false ; }
function vol_of_dodecahedron ( $ side ) { return ( ( ( 15 + ( 7 * ( sqrt ( 5 ) ) ) ) / 4 ) * ( pow ( $ side , 3 ) ) ) ; }
function center ( $ x1 , $ x2 , $ y1 , $ y2 ) { echo ( ( float ) ( $ x1 + $ x2 ) / 2 . " , ▁ " . ( float ) ( $ y1 + $ y2 ) / 2 ) ; }
function perimeter ( $ diameter , $ height ) { return 2 * ( $ diameter + $ height ) ; }
function area_of_segment ( $ radius , $ angle ) { $ pi = 3.14159 ; $ area_of_sector = $ pi * ( $ radius * $ radius ) * ( $ angle / 360 ) ; $ area_of_triangle = 1 / 2 * ( $ radius * $ radius ) * sin ( ( $ angle * $ pi ) / 180 ) ; return $ area_of_sector - $ area_of_triangle ; }
function midpoint ( $ x1 , $ x2 , $ y1 , $ y2 ) { echo ( ( float ) ( $ x1 + $ x2 ) / 2 . " ▁ , ▁ " . ( float ) ( $ y1 + $ y2 ) / 2 ) ; }
function area_of_tetrahedron ( $ side ) { return ( sqrt ( 3 ) * ( $ side * $ side ) ) ; }
function vol_tetra ( $ side ) { $ volume = ( pow ( $ side , 3 ) / ( 6 * sqrt ( 2 ) ) ) ; return $ volume ; }
function overflow ( $ H , $ r , $ h , $ N , $ R ) { $ tank_cap = 3.14 * $ r * $ r * $ H ; $ water_vol = 3.14 * $ r * $ r * $ h ; $ balls_vol = $ N * ( 4 / 3 ) * 3.14 * $ R * $ R * $ R ; $ vol = $ water_vol + $ balls_vol ; if ( $ vol > $ tank_cap ) { echo " Overflow " , " STRNEWLINE " ; } else { echo " Not ▁ in ▁ overflow ▁ state " , " STRNEWLINE " ; } }
function numberOfWays ( $ x ) { $ dp [ 0 ] = 1 ; $ dp [ 1 ] = 1 ; for ( $ i = 2 ; $ i <= $ x ; $ i ++ ) $ dp [ $ i ] = $ dp [ $ i - 1 ] + ( $ i - 1 ) * $ dp [ $ i - 2 ] ; return $ dp [ $ x ] ; }
function maxvolume ( $ s ) { $ maxvalue = 0 ; for ( $ i = 1 ; $ i <= $ s - 2 ; $ i ++ ) { for ( $ j = 1 ; $ j <= $ s - 1 ; $ j ++ ) { $ k = $ s - $ i - $ j ; $ maxvalue = max ( $ maxvalue , $ i * $ j * $ k ) ; } } return $ maxvalue ; }
function maxvolume ( $ s ) { $ length = ( int ) ( $ s / 3 ) ; $ s -= $ length ; $ breadth = ( int ) ( $ s / 2 ) ; $ height = $ s - $ breadth ; return $ length * $ breadth * $ height ; }
function volumeOfEllipsoid ( $ r1 , $ r2 , $ r3 ) { $ pi = 3.14 ; return 1.33 * $ pi * $ r1 * $ r2 * $ r3 ; }
function areaOctagon ( $ side ) { return ( 2 * ( 1 + sqrt ( 2 ) ) * $ side * $ side ) ; }
function Area ( $ b1 , $ b2 , $ h ) { return ( ( $ b1 + $ b2 ) / 2 ) * $ h ; }
function hexagonArea ( $ s ) { return ( ( 3 * sqrt ( 3 ) * ( $ s * $ s ) ) / 2 ) ; }
function Circumference ( $ a ) { return 4 * $ a ; }
function maxArea ( $ a , $ b , $ c , $ d ) { $ semiperimeter = ( $ a + $ b + $ c + $ d ) / 2 ; return sqrt ( ( $ semiperimeter - $ a ) * ( $ semiperimeter - $ b ) * ( $ semiperimeter - $ c ) * ( $ semiperimeter - $ d ) ) ; }
function arcLength ( $ diameter , $ angle ) { $ pi = 22.0 / 7.0 ; $ arc ; if ( $ angle >= 360 ) { echo " Angle ▁ cannot " , " ▁ be ▁ formed " ; return 0 ; } else { $ arc = ( $ pi * $ diameter ) * ( $ angle / 360.0 ) ; return $ arc ; } }
function SectorArea ( $ radius , $ angle ) { if ( $ angle >= 360 ) echo ( " Angle ▁ not ▁ possible " ) ; else { $ sector = ( ( 22 * $ radius * $ radius ) / 7 ) * ( $ angle / 360 ) ; echo ( $ sector ) ; } }
function minRadius ( $ k , $ x , $ y , $ n ) { $ dis = array ( ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ dis [ $ i ] = $ x [ $ i ] * $ x [ $ i ] + $ y [ $ i ] * $ y [ $ i ] ; sort ( $ dis ) ; return $ dis [ $ k - 1 ] ; }
function circumference ( $ r ) { global $ PI ; $ cir = 2 * $ PI * $ r ; return $ cir ; }
function areaSquare ( $ side ) { $ area = $ side * $ side ; return $ area ; }
function maxSquare ( $ b , $ m ) { return ( $ b / $ m - 1 ) * ( $ b / $ m ) / 2 ; }
function minPerimeter ( $ n ) { $ l = floor ( sqrt ( $ n ) ) ; $ sq = $ l * $ l ; if ( $ sq == $ n ) return $ l * 4 ; else { $ row = floor ( $ n / $ l ) ; $ perimeter = 2 * ( $ l + $ row ) ; if ( $ n % $ l != 0 ) $ perimeter += 2 ; return $ perimeter ; } }
function checkCollision ( $ a , $ b , $ c , $ x , $ y , $ radius ) { $ dist = ( abs ( $ a * $ x + $ b * $ y + $ c ) ) / sqrt ( $ a * $ a + $ b * $ b ) ; if ( $ radius == $ dist ) echo " Touch " ; else if ( $ radius > $ dist ) echo " Intersect " ; else echo " Outside " ; }
function possibleOrNot ( $ a1 , $ a2 , $ b1 , $ b2 , $ c1 , $ c2 ) { $ dis1 = pow ( $ b1 - $ a1 , 2 ) + pow ( $ b2 - $ a2 , 2 ) ; $ dis2 = pow ( $ c1 - $ b1 , 2 ) + pow ( $ c2 - $ b2 , 2 ) ; if ( $ dis1 != $ dis2 ) echo " No " ; else if ( $ b1 == ( ( $ a1 + $ c1 ) / 2.0 ) && $ b2 == ( ( $ a2 + $ c2 ) / 2.0 ) ) echo " No " ; else echo " Yes " ; }
function fitOrNotFit ( $ R , $ r , $ x , $ y , $ rad ) { $ val = sqrt ( pow ( $ x , 2 ) + pow ( $ y , 2 ) ) ; if ( $ val + $ rad <= $ R && $ val - $ rad >= $ R - $ r ) echo " Fits STRNEWLINE " ; else echo " Doesn ' t ▁ Fit STRNEWLINE " ; }
function circle ( $ x1 , $ y1 , $ x2 , $ y2 , $ r1 , $ r2 ) { $ distSq = ( $ x1 - $ x2 ) * ( $ x1 - $ x2 ) + ( $ y1 - $ y2 ) * ( $ y1 - $ y2 ) ; $ radSumSq = ( $ r1 + $ r2 ) * ( $ r1 + $ r2 ) ; if ( $ distSq == $ radSumSq ) return 1 ; else if ( $ distSq > $ radSumSq ) return -1 ; else return 0 ; }
function rectCount ( $ n , $ m ) { return ( $ m * $ n * ( $ n + 1 ) * ( $ m + 1 ) ) / 4 ; }
function countObtuseAngles ( $ a , $ b , $ k ) { $ c1 = ( $ b - $ a ) - 1 ; $ c2 = ( $ k - $ b ) + ( $ a - 1 ) ; if ( $ c1 == $ c2 ) return 0 ; return min ( $ c1 , $ c2 ) ; }
function countRect ( $ n ) { $ ans = 0 ; for ( $ length = 1 ; $ length <= sqrt ( $ n ) ; $ length ++ ) for ( $ height = $ length ; $ height * $ length <= $ n ; $ height ++ ) $ ans ++ ; return $ ans ; }
function bestApproximate ( $ x , $ y , $ n ) { $ i ; $ j ; $ m ; $ c ; $ sum_x = 0 ; $ sum_y = 0 ; $ sum_xy = 0 ; $ sum_x2 = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sum_x += $ x [ $ i ] ; $ sum_y += $ y [ $ i ] ; $ sum_xy += $ x [ $ i ] * $ y [ $ i ] ; $ sum_x2 += ( $ x [ $ i ] * $ x [ $ i ] ) ; } $ m = ( $ n * $ sum_xy - $ sum_x * $ sum_y ) / ( $ n * $ sum_x2 - ( $ sum_x * $ sum_x ) ) ; $ c = ( $ sum_y - $ m * $ sum_x ) / $ n ; echo " m = " , ▁ $ m ; STRNEWLINE TABSYMBOL echo ▁ " c = " }
function minRevolutions ( $ r , $ x1 , $ y1 , $ x2 , $ y2 ) { $ d = sqrt ( ( $ x1 - $ x2 ) * ( $ x1 - $ x2 ) + ( $ y1 - $ y2 ) * ( $ y1 - $ y2 ) ) ; return ceil ( $ d / ( 2 * $ r ) ) ; }
function findRightAngle ( $ A , $ H ) { $ D = pow ( $ H , 4 ) - 16 * $ A * $ A ; if ( $ D >= 0 ) { $ root1 = ( $ H * $ H + sqrt ( $ D ) ) / 2 ; $ root2 = ( $ H * $ H - sqrt ( $ D ) ) / 2 ; $ a = sqrt ( $ root1 ) ; $ b = sqrt ( $ root2 ) ; if ( $ b >= $ a ) echo $ a , " ▁ " , $ b , " ▁ " , $ H ; else echo $ b , " ▁ " , $ a , " ▁ " , $ H ; } else echo " - 1" ; }
function numberOfSquares ( $ base ) { $ base = ( $ base - 2 ) ; $ base = intdiv ( $ base , 2 ) ; return $ base * ( $ base + 1 ) / 2 ; }
function findMaximumPieces ( $ n ) { return 1 + $ n * ( $ n + 1 ) / 2 ; }
function findTriangle ( $ a , $ n ) { $ b [ $ n + 2 ] = array ( ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ b [ $ i ] = $ a [ $ i ] * $ a [ $ i ] ; sort ( $ a ) ; sort ( $ b ) ; $ x = 0 ; $ y = 0 ; $ z = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ p = $ i + 1 ; $ q = $ i + 1 ; for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) { while ( $ p < $ n - 1 && $ b [ $ i ] + $ b [ $ j ] >= $ b [ $ p + 1 ] ) $ p ++ ; $ q = max ( $ q , $ p ) ; while ( $ q < $ n - 1 && $ a [ $ i ] + $ a [ $ j ] > $ a [ $ q + 1 ] ) $ q ++ ; if ( $ b [ $ i ] + $ b [ $ j ] == $ b [ $ p ] ) { $ x += max ( $ p - $ j - 1 , 0 ) ; $ y ++ ; $ z += $ q - $ p ; } else { $ x += max ( $ p - $ j , 0 ) ; $ z += $ q - $ p ; } } } echo " Acute ▁ Triangle : ▁ " , $ x , " STRNEWLINE " ; echo " Right ▁ Triangle : ▁ " , $ y , " STRNEWLINE " ; echo " Obtuse ▁ Triangle : ▁ " , $ z , " STRNEWLINE " ; }
function countLattice ( $ r ) { if ( $ r <= 0 ) return 0 ; $ result = 4 ; for ( $ x = 1 ; $ x < $ r ; $ x ++ ) { $ ySquare = $ r * $ r - $ x * $ x ; $ y = ceil ( sqrt ( $ ySquare ) ) ; if ( $ y * $ y == $ ySquare ) $ result += 4 ; } return $ result ; }
function polygonArea ( $ X , $ Y , $ n ) { $ area = 0.0 ; $ j = $ n - 1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ area += ( $ X [ $ j ] + $ X [ $ i ] ) * ( $ Y [ $ j ] - $ Y [ $ i ] ) ; $ j = $ i ; } return abs ( $ area / 2.0 ) ; }
function polygonArea ( $ X , $ Y , $ n ) { $ area = 0.0 ; $ j = $ n - 1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ area += ( $ X [ $ j ] + $ X [ $ i ] ) * ( $ Y [ $ j ] - $ Y [ $ i ] ) ; $ j = $ i ; } return abs ( $ area / 2.0 ) ; }
function Conversion ( $ centi ) { $ pixels = ( 96 * $ centi ) / 2.54 ; echo ( $ pixels . " " ) ; }
function last_digit ( $ X , $ Y ) { echo ( $ X % $ Y ) ; }
function printRoots ( $ a , $ b , $ c ) { echo "1" ; echo " , ▁ " ; echo $ c / ( $ a * 1.0 ) ; }
function evenNumSubstring ( $ str ) { $ len = strlen ( $ str ) ; $ count = 0 ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { $ temp = $ str [ $ i ] - '0' ; if ( $ temp % 2 == 0 ) $ count += ( $ i + 1 ) ; } return $ count ; }
function validQuadruple ( $ arr , $ n ) { if ( $ n >= MAX ) return true ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) for ( $ k = $ j + 1 ; $ k < $ n ; $ k ++ ) for ( $ l = $ k + 1 ; $ l < $ n ; $ l ++ ) { if ( ( $ arr [ $ i ] ^ $ arr [ $ j ] ^ $ arr [ $ k ] ^ $ arr [ $ l ] ) == 0 ) { return true ; } } return false ; }
function getAverage ( $ x , $ y ) { $ avg = ( $ x & $ y ) + ( ( $ x ^ $ y ) >> 1 ) ; return $ avg ; }
function solve ( $ n , $ k ) { if ( $ n >= ( $ k * ( $ k + 1 ) ) / 2 ) { return true ; } return false ; }
function closetAND ( & $ arr , $ n , $ k ) { $ ans = PHP_INT_MAX ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ X = $ arr [ $ i ] ; for ( $ j = $ i ; $ j < $ n ; $ j ++ ) { $ X &= $ arr [ $ j ] ; $ ans = min ( $ ans , abs ( $ k - $ X ) ) ; } } return $ ans ; }
function count_square ( $ n ) { $ count = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i = $ i + 2 ) { $ k = $ n - $ i + 1 ; $ count += ( $ k * $ k ) ; } return $ count ; }
function Rate ( $ N1 , $ N2 ) { $ rate = ( $ N2 - $ N1 ) * 100 / $ N1 ; return $ rate ; }
function solve ( $ a , $ n ) { $ ones = 0 ; $ twos = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] == 1 ) $ ones ++ ; else $ twos ++ ; } $ ind = 0 ; if ( $ twos ) $ a [ $ ind ++ ] = 2 ; $ evenOnes = ( $ ones % 2 == 0 ) ? true : false ; if ( $ evenOnes ) $ ones -= 1 ; for ( $ i = 0 ; $ i < $ ones ; $ i ++ ) $ a [ $ ind ++ ] = 1 ; for ( $ i = 0 ; $ i < $ twos - 1 ; $ i ++ ) $ a [ $ ind ++ ] = 2 ; if ( $ evenOnes ) $ a [ $ ind ++ ] = 1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ a [ $ i ] , " ▁ " ; }
function maxEdges ( $ N ) { $ edges = 0 ; $ edges = floor ( ( $ N * $ N ) / 4 ) ; return $ edges ; }
function findX ( $ A , $ B ) { $ j = 0 ; $ x = 0 ; while ( $ A $ B ) { if ( ( $ A & 1 ) && ( $ B & 1 ) ) { $ x += ( 1 << $ j ) ; } $ A >>= 1 ; $ B >>= 1 ; $ j += 1 ; } return $ x ; }
function isSumEqual ( $ ar , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) $ sum += $ ar [ $ i ] ; if ( $ sum == $ ar [ $ n - 1 ] ) return true ; return false ; }
function findIndex ( $ a , $ n ) { $ min_diff = PHP_INT_MAX ; $ prod = array ( ) ; $ prod [ 0 ] = $ a [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ prod [ $ i ] = $ prod [ $ i - 1 ] * $ a [ $ i ] ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { $ curr_diff = abs ( ( $ prod [ $ n - 1 ] / $ prod [ $ i ] ) - $ prod [ $ i ] ) ; if ( $ curr_diff < $ min_diff ) { $ min_diff = $ curr_diff ; $ res = $ i ; } } return $ res ; }
function Permutation ( $ n , $ k ) { $ p = array ( ) ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ p [ $ i ] = $ i ; for ( $ i = 1 ; $ i < $ n - $ k ; $ i ++ ) $ p [ $ i + 1 ] = $ i ; $ p [ 1 ] = $ n - $ k ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) echo $ p [ $ i ] , " ▁ " ; }
function vertices ( $ N , $ A , $ B ) { $ position = 0 ; $ minisum = PHP_INT_MAX ; $ sum = 0 ; for ( $ i = 1 ; $ i <= $ N ; $ i ++ ) { if ( $ i == $ A $ i == $ B ) continue ; else { $ x = abs ( $ i - $ A ) ; $ y = abs ( $ i - $ B ) ; $ sum = $ x + $ y ; if ( $ sum < $ minisum ) { $ minisum = $ sum ; $ position = $ i ; } } } return $ position ; }
function getValueOfF ( $ n ) { if ( $ n == 1 ) return 0 ; if ( $ n == 2 ) return 1 ; $ cnt = 0 ; while ( $ n % 2 == 0 ) { $ cnt += 1 ; $ n /= 2 ; } return 2 * $ cnt ; }
function maxProd ( $ N ) { if ( $ N == 0 ) return 1 ; if ( $ N < 10 ) return $ N ; return max ( maxProd ( ( int ) ( $ N / 10 ) ) * ( $ N % 10 ) , maxProd ( ( int ) ( $ N / 10 ) - 1 ) * 9 ) ; }
function oddTriangularNumber ( $ N ) { return ( $ N * ( ( 2 * $ N ) - 1 ) ) ; }
function idstrt ( $ a1 , $ b1 , $ c1 , $ a2 , $ b2 , $ c2 ) { if ( ( $ a1 / $ a2 == $ b1 / $ b2 ) && ( $ a1 / $ a2 == $ c1 / $ c2 ) && ( $ b1 / $ b2 == $ c1 / $ c2 ) ) echo " The ▁ given ▁ straight ▁ lines ▁ are ▁ identical " , " STRNEWLINE " ; else echo " The ▁ given ▁ straight ▁ lines ▁ are ▁ not ▁ identical " , " STRNEWLINE " ; }
function area ( $ a , $ b , $ c ) { $ d = abs ( ( $ c * $ c ) / ( 2 * $ a * $ b ) ) ; return $ d ; }
function line ( $ x0 , $ y0 ) { $ c = 2 * $ y0 * $ x0 ; echo $ y0 , " x " , " ▁ + ▁ " , $ x0 , " y ▁ = ▁ " , $ c ; }
function printOriginalMatrix ( $ a , $ b , $ mat ) { for ( $ i = 0 ; $ i < $ GLOBALS [ ' N ' ] ; $ i ++ ) { for ( $ j = 0 ; $ j < $ GLOBALS [ ' M ' ] ; $ j ++ ) { if ( $ mat [ $ i ] [ $ j ] == 1 ) echo min ( $ a [ $ i ] , $ b [ $ j ] ) . " ▁ " ; else echo "0" . " ▁ " ; } echo " \r STRNEWLINE " ; } }
function maxAbsDiff ( $ arr , $ n ) { $ minEle = $ arr [ 0 ] ; $ maxEle = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ minEle = min ( $ minEle , $ arr [ $ i ] ) ; $ maxEle = max ( $ maxEle , $ arr [ $ i ] ) ; } return ( $ maxEle - $ minEle ) ; }
function isOsiris ( $ n ) { $ a = $ n % 10 ; $ b = floor ( $ n / 10 ) % 10 ; $ c = floor ( $ n / 100 ) ; $ digit_sum = $ a + $ b + $ c ; if ( $ n == ( 2 * ( $ digit_sum ) * 11 ) ) { return true ; } return false ; }
function isDudeney ( $ n ) { $ cube_rt = floor ( round ( ( pow ( $ n , 1.0 / 3.0 ) ) ) ) ; if ( $ cube_rt * $ cube_rt * $ cube_rt != $ n ) return false ; $ dig_sum = 0 ; $ temp = $ n ; while ( $ temp > 0 ) { $ rem = $ temp % 10 ; $ dig_sum += $ rem ; $ temp = $ temp / 10 ; } if ( $ cube_rt != $ dig_sum ) return false ; return true ; }
function smallestMultiple ( $ n ) { if ( $ n == 1 ) return 5 ; return pow ( 10 , $ n - 1 ) ; }
function countAnomalies ( $ arr , $ n , $ k ) { $ cnt = 0 ; $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum += $ arr [ $ i ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( abs ( $ arr [ $ i ] - ( $ sum - $ arr [ $ i ] ) ) > $ k ) $ cnt ++ ; return $ cnt ; }
function getHCF ( $ x , $ y ) { $ minimum = min ( $ x , $ y ) ; if ( $ x % $ minimum == 0 && $ y % $ minimum == 0 ) return $ minimum ; for ( $ i = $ minimum / 2 ; $ i >= 2 ; $ i -- ) { if ( $ x % $ i == 0 && $ y % $ i == 0 ) return $ i ; } return 1 ; }
function findDivisors ( $ n ) { $ div = array_fill ( 0 , $ n + 2 , 0 ) ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 1 ; $ j * $ i <= $ n ; $ j ++ ) $ div [ $ i * $ j ] ++ ; } for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) echo $ div [ $ i ] , " ▁ " ; }
function findMaxCock ( $ ar ) { global $ R , $ C ; if ( $ R < 3 $ C < 3 ) return -1 ; $ max_sum = PHP_INT_MIN ; for ( $ i = 0 ; $ i < $ R - 2 ; $ i ++ ) { for ( $ j = 0 ; $ j < $ C - 2 ; $ j ++ ) { $ sum = ( $ ar [ $ i ] [ $ j ] + $ ar [ $ i ] [ $ j + 2 ] ) + ( $ ar [ $ i + 1 ] [ $ j + 1 ] ) + ( $ ar [ $ i + 2 ] [ $ j ] + $ ar [ $ i + 2 ] [ $ j + 1 ] + $ ar [ $ i + 2 ] [ $ j + 2 ] ) ; $ max_sum = max ( $ max_sum , $ sum ) ; } } return $ max_sum ; }
function segments ( $ n , $ p , $ m ) { $ c = array ( ) ; $ c [ 0 ] = 1 ; $ has = false ; $ sum = 0 ; $ ans = 0 ; for ( $ r = 0 ; $ r < $ n ; $ r ++ ) { if ( $ p [ $ r ] < $ m ) $ sum -- ; else if ( $ p [ $ r ] > $ m ) $ sum ++ ; if ( $ p [ $ r ] == $ m ) $ has = true ; if ( $ has ) $ ans += $ c [ $ sum ] + $ c [ $ sum - 1 ] ; else $ c [ $ sum ] ++ ; } return $ ans ; }
function ellipsearea ( $ r ) { if ( $ r < 0 ) return -1 ; $ a = ( 3.14 * $ r * $ r ) / 4 ; return $ a ; }
function decideWinner ( $ a , $ n ) { $ count0 = 0 ; $ count1 = 0 ; $ count2 = 0 ; $ count3 = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] % 4 == 0 ) $ count0 ++ ; else if ( $ a [ $ i ] % 4 == 1 ) $ count1 ++ ; else if ( $ a [ $ i ] % 4 == 2 ) $ count2 ++ ; else if ( $ a [ $ i ] % 4 == 3 ) $ count3 ++ ; } if ( $ count0 % 2 == 0 && $ count1 % 2 == 0 && $ count2 % 2 == 0 && $ count3 == 0 ) return 1 ; else return 2 ; }
function CntDivbyX ( $ arr , $ n , $ x ) { $ number = 0 ; $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ number = $ number * 2 + $ arr [ $ i ] ; if ( ( $ number % $ x == 0 ) ) $ count += 1 ; } return $ count ; }
function CntDivbyX ( $ arr , $ n , $ x ) { $ number = 0 ; $ count1 = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ number = ( $ number * 2 + $ arr [ $ i ] ) % $ x ; if ( $ number == 0 ) $ count1 += 1 ; } return $ count1 ; }
function smallestIndex ( $ a , $ n ) { $ right1 = 0 ; $ right0 = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] == 1 ) $ right1 = $ i ; else $ right0 = $ i ; } return min ( $ right1 , $ right0 ) ; }
function countCon ( $ ar , $ n ) { $ cnt = 0 ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { if ( $ ar [ $ i ] == $ ar [ $ i + 1 ] ) $ cnt ++ ; } return $ cnt ; }
function printElements ( $ arr , $ n ) { for ( $ i = 1 ; $ i < $ n - 1 ; $ i ++ ) { if ( $ arr [ $ i ] > $ arr [ $ i - 1 ] and $ arr [ $ i ] > $ arr [ $ i + 1 ] ) echo $ arr [ $ i ] . " ▁ " ; } }
function noOfYears ( $ t1 , $ n1 , $ t2 ) { $ years = ( ( $ t2 - 1 ) * $ n1 / ( $ t1 - 1 ) ) ; return $ years ; }
function numLen ( $ K ) { if ( $ K % 2 == 0 $ K % 5 == 0 ) return -1 ; $ number = 0 ; $ len = 1 ; for ( $ len = 1 ; $ len <= $ K ; $ len ++ ) { $ number = ( $ number * 10 + 1 ) % $ K ; if ( $ number == 0 ) return $ len ; } return -1 ; }
function precomputation ( $ arr , $ n ) { global $ max_Element , $ sum3 , $ sum2 , $ sum1 ; for ( $ i = 1 ; $ i < $ max_Element ; $ i ++ ) for ( $ j = $ i ; $ j < $ max_Element ; $ j += $ i ) $ sum1 [ $ j ] += $ i ; for ( $ i = 1 ; $ i < $ max_Element ; $ i ++ ) for ( $ j = $ i ; $ j < $ max_Element ; $ j += $ i ) $ sum2 [ $ j ] += ( $ sum1 [ $ j ] - $ i ) * $ i ; for ( $ i = 1 ; $ i < $ max_Element ; $ i ++ ) $ sum2 [ $ i ] = ( int ) ( $ sum2 [ $ i ] / 2 ) ; for ( $ i = 1 ; $ i < $ max_Element ; $ i ++ ) for ( $ j = $ i ; $ j < $ max_Element ; $ j += $ i ) $ sum3 [ $ j ] += $ i * ( $ sum2 [ $ j ] - $ i * ( $ sum1 [ $ j ] - $ i ) ) ; for ( $ i = 1 ; $ i < $ max_Element ; $ i ++ ) $ sum3 [ $ i ] = ( int ) ( $ sum3 [ $ i ] / 3 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ sum3 [ $ arr [ $ i ] ] . " ▁ " ; }
function sum ( $ k , $ n ) { $ sum = pow ( $ k , $ n + 1 ) - pow ( $ k - 1 , $ n + 1 ) ; return $ sum ; }
function isPossible ( $ n ) { $ fac = array ( ) ; $ fac [ 0 ] = $ fac [ 1 ] = 1 ; for ( $ i = 2 ; $ i < 10 ; $ i ++ ) $ fac [ $ i ] = $ fac [ $ i - 1 ] * $ i ; $ sum = 0 ; $ x = $ n ; while ( $ x ) { $ sum += $ fac [ $ x % 10 ] ; $ x /= 10 ; } if ( $ sum % $ n == 0 ) return true ; return false ; }
function computeXOR ( $ n ) { $ x = $ n & 3 ; switch ( $ x ) { case 0 : return $ n ; case 1 : return 1 ; case 2 : return $ n + 1 ; case 3 : return 0 ; } return 0 ; }
function countNumbers ( $ x , $ n ) { if ( $ x > $ n ) return 0 ; return 1 + countNumbers ( $ x * 10 , $ n ) + countNumbers ( $ x * 10 + 1 , $ n ) ; }
function countSquares ( $ r , $ c , $ m ) { $ squares = 0 ; for ( $ i = 1 ; $ i <= 8 ; $ i ++ ) { for ( $ j = 1 ; $ j <= 8 ; $ j ++ ) { if ( max ( abs ( $ i - $ r ) , abs ( $ j - $ c ) ) <= $ m ) $ squares ++ ; } } return $ squares ; }
function countNonIncreasing ( $ arr , $ n ) { $ cnt = 0 ; $ len = 1 ; for ( $ i = 0 ; $ i < $ n - 1 ; ++ $ i ) { if ( $ arr [ $ i + 1 ] <= $ arr [ $ i ] ) $ len ++ ; else { $ cnt += ( ( $ len + 1 ) * $ len ) / 2 ; $ len = 1 ; } } if ( $ len > 1 ) $ cnt += ( ( $ len + 1 ) * $ len ) / 2 ; return $ cnt ; }
function minimumSteps ( $ n , $ m , $ a , $ b ) { global $ MAXN ; if ( $ n > $ m ) return $ MAXN ; if ( $ n == $ m ) return 0 ; return min ( 1 + minimumSteps ( $ n * $ a , $ m , $ a , $ b ) , 1 + minimumSteps ( $ n * $ b , $ m , $ a , $ b ) ) ; }
function wastedWater ( $ V , $ M , $ N ) { $ amt_per_min = $ M - $ N ; $ time_to_fill = $ V / $ amt_per_min ; $ wasted_amt = $ N * $ time_to_fill ; return $ wasted_amt ; }
function sphereSide ( $ h , $ r ) { if ( $ h < 0 && $ r < 0 ) return -1 ; $ R = ( ( $ h * $ r * sqrt ( 2 ) ) / ( $ h + sqrt ( 2 ) * $ r ) ) / 2 ; return $ R ; }
function Loss ( $ SP , $ P ) { $ loss = 0 ; $ loss = ( ( 2 * $ P * $ P * $ SP ) / ( 100 * 100 - $ P * $ P ) ) ; print ( " Loss ▁ = ▁ " . round ( $ loss , 3 ) ) ; }
function possibleways ( $ n ) { if ( $ n % 2 == 1 ) return 0 ; else if ( $ n % 4 == 0 ) return $ n / 4 - 1 ; else return $ n / 4 ; }
function countSubarrays ( $ arr , $ n , $ K ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = $ i ; $ j < $ n ; $ j ++ ) { $ product = 1 ; for ( $ x = $ i ; $ x <= $ j ; $ x ++ ) $ product *= $ arr [ $ x ] ; if ( $ product % $ K == 0 ) $ count ++ ; } } return $ count ; }
function Permutations ( $ n , $ k ) { $ ans = 1 ; if ( $ k >= 2 ) $ ans += ( $ n ) * ( $ n - 1 ) / 2 ; if ( $ k >= 3 ) $ ans += ( $ n ) * ( $ n - 1 ) * ( $ n - 2 ) * 2 / 6 ; if ( $ k >= 4 ) $ ans += ( $ n ) * ( $ n - 1 ) * ( $ n - 2 ) * ( $ n - 3 ) * 9 / 24 ; return $ ans ; }
function findPairCount ( $ N , $ K ) { $ count = 0 ; $ rem = array ( 0 , $ K , NULL ) ; $ rem [ 0 ] = intval ( $ N / $ K ) ; for ( $ i = 1 ; $ i < $ K ; $ i ++ ) $ rem [ $ i ] = intval ( ( $ N - $ i ) / $ K ) + 1 ; if ( $ K % 2 == 0 ) { $ count += ( $ rem [ 0 ] * intval ( ( $ rem [ 0 ] - 1 ) ) / 2 ) ; for ( $ i = 1 ; $ i < intval ( $ K / 2 ) ; $ i ++ ) $ count += $ rem [ $ i ] * $ rem [ $ K - $ i ] ; $ count += ( $ rem [ intval ( $ K / 2 ) ] * intval ( ( $ rem [ intval ( $ K / 2 ) ] - 1 ) ) / 2 ) ; } else { $ count += ( $ rem [ 0 ] * intval ( ( $ rem [ 0 ] - 1 ) ) / 2 ) ; for ( $ i = 1 ; $ i <= intval ( $ K / 2 ) ; $ i ++ ) $ count += $ rem [ $ i ] * $ rem [ $ K - $ i ] ; } return $ count ; }
function nDigitPerfectSquares ( $ n ) { echo pow ( ceil ( sqrt ( pow ( 10 , $ n - 1 ) ) ) , 2 ) , " " ; echo pow ( ceil ( sqrt ( pow ( 10 , $ n ) ) ) - 1 , 2 ) ; }
function MaxTraceSub ( $ mat ) { global $ N ; $ max_trace = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { for ( $ j = 0 ; $ j < $ N ; $ j ++ ) { $ r = $ i ; $ s = $ j ; $ trace = 0 ; while ( $ r < $ N && $ s < $ N ) { $ trace += $ mat [ $ r ] [ $ s ] ; $ r ++ ; $ s ++ ; $ max_trace = max ( $ trace , $ max_trace ) ; } } } return $ max_trace ; }
function lastDigit ( $ a , $ b ) { $ lastDig = ( ord ( $ a [ strlen ( $ a ) - 1 ] ) - 48 ) * ( ord ( $ b [ strlen ( $ b ) - 1 ] ) - 48 ) ; echo $ lastDig % 10 ; }
function printPalindrome ( $ n ) { if ( $ n == 1 ) { echo " Smallest ▁ Palindrome : ▁ 0 STRNEWLINE " ; echo " Largest ▁ Palindrome : ▁ 9" ; } else { echo " Smallest ▁ Palindrome : ▁ " , pow ( 10 , $ n - 1 ) + 1 ; echo " Largest Palindrome : " pow ( 10 , $ n ) - 1 ; } }
function countDigits ( $ a , $ b ) { $ count = 0 ; $ p = abs ( $ a / $ b ) ; if ( $ p == 0 ) return 1 ; while ( $ p > 0 ) { $ count ++ ; $ p = ( int ) ( $ p / 10 ) ; } return $ count ; }
function countDigits ( $ a , $ b ) { return floor ( log10 ( abs ( $ a ) ) - log10 ( abs ( $ b ) ) ) + 1 ; }
function smallestOdd ( $ n ) { if ( $ n == 1 ) return 1 ; return pow ( 10 , $ n - 1 ) + 1 ; }
function nDigitPerfectCubes ( $ n ) { print ( pow ( ceil ( pow ( pow ( 10 , ( $ n - 1 ) ) , 1 / 3 ) ) , 3 ) . " ▁ " ) ; print ( ( int ) pow ( ceil ( pow ( pow ( 10 , ( $ n ) ) , 1 / 3 ) ) - 1 , 3 ) ) ; }
function findNumbers ( $ n ) { $ odd = pow ( 10 , $ n ) - 1 ; $ even = $ odd - 1 ; echo " Even ▁ = ▁ $ even ▁ STRNEWLINE " ; echo " Odd ▁ = ▁ $ odd " ; }
function longestSubArray ( $ arr , $ n ) { $ isZeroPresent = false ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] == 0 ) { $ isZeroPresent = true ; break ; } } if ( $ isZeroPresent ) return $ n ; return 0 ; }
function smallestEven ( $ n ) { if ( $ n == 1 ) return 0 ; return pow ( 10 , $ n - 1 ) ; }
function printBalancedExpression ( $ a , $ b , $ c , $ d ) { if ( ( $ a == $ d && $ a ) || ( $ a == 0 && $ c == 0 && $ d == 0 ) ) { for ( $ i = 1 ; $ i <= $ a ; $ i ++ ) echo " ( ( " ; for ( $ i = 1 ; $ i <= $ c ; $ i ++ ) echo " ) ( " ; for ( $ i = 1 ; $ i <= $ d ; $ i ++ ) echo " ) ) " ; for ( $ i = 1 ; $ i <= $ b ; $ i ++ ) echo " ( ) " ; } else echo - 1 ; }
function sumOfSeries ( $ n ) { $ ans = pow ( $ n % $ GLOBALS [ ' MOD ' ] , 2 ) ; return ( $ ans % $ GLOBALS [ ' MOD ' ] ) ; }
function kthOdd ( $ arr , $ n , $ k ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] % 2 == 1 ) $ k -- ; if ( $ k == 0 ) return $ arr [ $ i ] ; } return -1 ; }
function lastFiveDigits ( $ n ) { $ n = ( int ) ( $ n / 10000 ) * 10000 + ( ( int ) ( $ n / 100 ) % 10 ) * 1000 + ( $ n % 10 ) * 100 + ( ( int ) ( $ n / 10 ) % 10 ) * 10 + ( int ) ( $ n / 1000 ) % 10 ; $ ans = 1 ; for ( $ i = 0 ; $ i < 5 ; $ i ++ ) { $ ans *= $ n ; $ ans %= 100000 ; } echo $ ans ; }
function maxValue ( $ n ) { if ( $ n == 1 ) return 0 ; return ( ( $ n * $ n / 2 ) - 1 ) ; }
function countNumbers ( $ n ) { if ( $ n % 2 == 1 ) return 0 ; return ( 9 * ( int ) pow ( 10 , $ n / 2 - 1 ) ) ; }
function count_t ( $ n ) { $ cnt = 0 ; $ p = 1 ; while ( $ p <= $ n ) { $ cnt ++ ; $ p *= 2 ; } return $ cnt ; }
function KthMinValAfterMconcatenate ( $ A , $ N , $ M , $ K ) { sort ( $ A ) ; return ( $ A [ ( ( $ K - 1 ) / $ M ) ] ) ; }
function sumN ( $ n ) { $ n = ( int ) ( ( $ n + 1 ) / 2 ) ; return ( $ n * $ n ) ; }
function countNumbers ( $ n ) { return ( int ) ( $ n - $ n / 2 ) - ( int ) ( $ n / 3 ) - ( int ) ( $ n / 5 ) - ( int ) ( $ n / 7 ) + ( int ) ( $ n / 6 ) + ( int ) ( $ n / 10 ) + ( int ) ( $ n / 14 ) + ( int ) ( $ n / 15 ) + ( int ) ( $ n / 21 ) + ( int ) ( $ n / 35 ) - ( int ) ( $ n / 30 ) - ( int ) ( $ n / 42 ) - ( int ) ( $ n / 70 ) - ( int ) ( $ n / 105 ) + ( int ) ( $ n / 210 ) ; }
function sum ( $ n ) { if ( $ n == 1 ) return 1 ; else return ( pow ( $ n , $ n ) + sum ( $ n - 1 ) ) ; }
function findThirdDigit ( $ n ) { if ( $ n < 3 ) return 0 ; return $ n & 1 ? 1 : 6 ; }
function maxPrimes ( $ n ) { return ( int ) ( $ n / 2 ) ; }
function sum ( $ n ) { return $ n * ( $ n + 1 ) * ( $ n + 2 ) / 3 ; }
function numbers ( $ n ) { return ( pow ( 2 , $ n + 1 ) ) - 2 ; }
function NumberofWays ( $ n ) { $ x = ( 1 * ( $ n ) * ( $ n - 1 ) * ( $ n - 2 ) * ( $ n - 3 ) ) / ( 4 * 3 * 2 * 1 ) ; $ y = ( 1 * ( $ n ) * ( $ n - 1 ) * ( $ n - 2 ) * ( $ n - 3 ) ) ; return ( 1 * $ x * $ y ) ; }
function countNumbers ( $ n ) { return ( int ) ( $ n / 2520 ) ; }
function nthTerm ( $ N ) { $ nth = 0 ; $ i ; for ( $ i = $ N ; $ i > 0 ; $ i -- ) { $ nth += pow ( $ i , $ i ) ; } return $ nth ; }
function nthTerm ( $ N ) { $ nth = 0 ; $ nth = ( $ N * $ N * ( $ N + 1 ) ) / 2 ; return $ nth ; }
function kthSmallest ( $ n , $ k ) { return ( 2 * $ k ) ; }
function isSumOfPowersOfTwo ( $ n ) { if ( $ n % 2 == 1 ) return false ; else return true ; }
function findNumbers ( $ n ) { $ i = 1 ; while ( $ i <= $ n ) { echo ( ( 2 * $ i ) - 1 ) . " ▁ " ; $ i ++ ; } }
function getTime ( $ u , $ v , $ x ) { $ speed = $ u + $ v ; $ time = $ x / $ speed ; return $ time ; }
function getProbability ( $ a , $ b , $ c , $ d ) { $ p = $ a / $ b ; $ q = $ c / $ d ; $ ans = $ p * ( 1 / ( 1 - ( 1 - $ q ) * ( 1 - $ p ) ) ) ; return round ( $ ans , 6 ) ; }
function findMinimum ( $ x , $ y ) { $ low = 0 ; $ high = $ y ; while ( $ low <= $ high ) { $ mid = ( $ low + $ high ) >> 1 ; if ( ( $ mid * 2 + ( $ y - $ mid ) ) >= $ x ) $ high = $ mid - 1 ; else $ low = $ mid + 1 ; } return $ low ; }
function LucasSum ( $ N ) { $ sum = 0 ; $ a = 2 ; $ b = 1 ; $ c ; $ sum += $ a ; while ( $ b <= $ N ) { $ sum += $ b ; $ c = $ a + $ b ; $ a = $ b ; $ b = $ c ; } return $ sum ; }
function countNumbers ( $ l , $ r ) { return ( ( int ) ( $ r / 6 ) - ( int ) ( ( $ l - 1 ) / 6 ) ) ; }
function countWays ( $ N ) { $ E = ( $ N * ( $ N - 1 ) ) / 2 ; if ( $ N == 1 ) return 0 ; return ( int ) pow ( 2 , $ E - 1 ) ; }
function BalanceArray ( $ A , & $ Q ) { $ ANS = array ( ) ; $ sum = 0 ; for ( $ i = 0 ; $ i < count ( $ A ) ; $ i ++ ) if ( $ A [ $ i ] % 2 == 0 ) $ sum = $ sum + $ A [ $ i ] ; for ( $ i = 0 ; $ i < count ( $ Q ) ; $ i ++ ) { $ index = $ Q [ $ i ] [ 0 ] ; $ value = $ Q [ $ i ] [ 1 ] ; if ( $ A [ $ index ] % 2 == 0 ) $ sum = $ sum - $ A [ $ index ] ; $ A [ $ index ] = $ A [ $ index ] + $ value ; if ( $ A [ $ index ] % 2 == 0 ) $ sum = $ sum + $ A [ $ index ] ; array_push ( $ ANS , $ sum ) ; } for ( $ i = 0 ; $ i < count ( $ ANS ) ; $ i ++ ) echo $ ANS [ $ i ] . " ▁ " ; }
function findMinSum ( $ arr , $ n ) { $ occ1 = ( $ n ) ; $ occ = $ occ1 - 1 ; $ Sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ Sum += $ arr [ $ i ] * pow ( 2 , $ occ ) ; $ occ -= 1 ; } return $ Sum ; }
function findMinSum ( $ arr , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum += $ arr [ $ i ] * ( $ n - $ i ) ; return $ sum ; }
function getPosition ( $ n , $ m ) { if ( $ m > ( $ n / 2 ) ) return ( $ m - ( $ n / 2 ) ) ; return ( $ m + ( $ n / 2 ) ) ; }
function minSum ( $ arr , $ n , $ x ) { $ sum = 0 ; $ largestDivisible = -1 ; $ minimum = $ arr [ 0 ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sum += $ arr [ $ i ] ; if ( $ arr [ $ i ] % $ x == 0 && $ largestDivisible < $ arr [ $ i ] ) $ largestDivisible = $ arr [ $ i ] ; if ( $ arr [ $ i ] < $ minimum ) $ minimum = $ arr [ $ i ] ; } if ( $ largestDivisible == -1 ) return $ sum ; $ sumAfterOperation = $ sum - $ minimum - $ largestDivisible + ( $ x * $ minimum ) + ( $ largestDivisible / $ x ) ; return min ( $ sum , $ sumAfterOperation ) ; }
function submatrixXor ( $ arr ) { $ ans = 0 ; $ n = 3 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { $ top_left = ( $ i + 1 ) * ( $ j + 1 ) ; $ bottom_right = ( $ n - $ i ) * ( $ n - $ j ) ; if ( ( $ top_left % 2 == 1 ) && ( $ bottom_right % 2 == 1 ) ) $ ans = ( $ ans ^ $ arr [ $ i ] [ $ j ] ) ; } } return $ ans ; }
function findAnswer ( $ X , $ N ) { return ( $ N - 1 ) * 9 + $ X ; }
function count1 ( $ N , $ K , $ R ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ N ; $ i ++ ) { if ( $ i % $ K == $ R ) $ sum += $ i ; } return $ sum ; }
function getCount ( $ a , $ b , $ c ) { $ count = 0 ; for ( $ i = 1 ; $ i <= 81 ; $ i ++ ) { $ cr = $ b * ( int ) pow ( $ i , $ a ) + $ c ; $ tmp = $ cr ; $ sm = 0 ; while ( $ tmp != 0 ) { $ sm += $ tmp % 10 ; $ tmp /= 10 ; } if ( $ sm == $ i && $ cr < 1e9 ) $ count ++ ; } return $ count ; } { $ a = 3 ; $ b = 2 ; $ c = 8 ; echo ( getCount ( $ a , $ b , $ c ) ) ; }
function isSpiltPossible ( $ n , $ a ) { $ sum = 0 ; $ c1 = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sum += $ a [ $ i ] ; if ( $ a [ $ i ] == 1 ) { $ c1 ++ ; } } if ( $ sum % 2 != 0 ) return false ; if ( ( $ sum / 2 ) % 2 == 0 ) return true ; if ( $ c1 > 0 ) return true ; else return false ; }
function matrixSum ( $ arr ) { $ n = 3 ; $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { $ top_left = ( $ i + 1 ) * ( $ j + 1 ) ; $ bottom_right = ( $ n - $ i ) * ( $ n - $ j ) ; $ sum += ( $ top_left * $ bottom_right * $ arr [ $ i ] [ $ j ] ) ; } return $ sum ; }
function maxAND ( $ L , $ R ) { $ maximum = $ L & $ R ; for ( $ i = $ L ; $ i < $ R ; $ i ++ ) for ( $ j = $ i + 1 ; $ j <= $ R ; $ j ++ ) $ maximum = max ( $ maximum , ( $ i & $ j ) ) ; return $ maximum ; }
function maxAND ( $ L , $ R ) { if ( $ L == $ R ) return $ L ; else if ( ( $ R - $ L ) == 1 ) return ( $ R & $ L ) ; else { if ( ( ( $ R - 1 ) & $ R ) > ( ( $ R - 2 ) & ( $ R - 1 ) ) ) return ( ( $ R - 1 ) & $ R ) ; else return ( ( $ R - 2 ) & ( $ R - 1 ) ) ; } }
function checkArray ( $ arr , $ n ) { return ( $ arr [ 0 ] % 2 ) && ( $ arr [ $ n - 1 ] % 2 ) && ( $ n % 2 ) ; }
function findCount ( $ arr , $ n ) { $ countOdd = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] % 2 == 1 ) $ countOdd ++ ; if ( $ countOdd % 2 == 0 ) return 1 ; else return 0 ; }
function Cycles ( $ N ) { $ fact = 1 ; $ result = 0 ; $ result = $ N - 1 ; $ i = $ result ; while ( $ i > 0 ) { $ fact = $ fact * $ i ; $ i -- ; } return floor ( $ fact / 2 ) ; }
function getMaxNum ( $ a , $ b , $ c ) { if ( $ b % $ c == 0 ) return $ b ; $ x = ( ( int ) ( $ b / $ c ) * $ c ) ; if ( $ x >= $ a && $ x <= $ b ) return $ x ; else return -1 ; }
function printPermutation ( $ n , $ k ) { for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ x = 2 * $ i - 1 ; $ y = 2 * $ i ; if ( $ i <= $ k ) echo $ y . " " ▁ . ▁ $ x ▁ . ▁ " " else echo $ x . " ▁ " . $ y . " ▁ " ; } }
function isPossible ( $ Sx , $ Sy , $ Dx , $ Dy , $ x , $ y ) { if ( abs ( $ Sx - $ Dx ) % $ x == 0 && abs ( $ Sy - $ Dy ) % $ y == 0 && ( abs ( $ Sx - $ Dx ) / $ x ) % 2 == ( abs ( $ Sy - $ Dy ) / $ y ) % 2 ) return true ; return false ; }
function getPairs ( $ a ) { $ count = 0 ; for ( $ i = 0 ; $ i < sizeof ( $ a ) ; $ i ++ ) { for ( $ j = 0 ; $ j < sizeof ( $ a ) ; $ j ++ ) { if ( $ a [ $ i ] < $ a [ $ j ] ) $ count ++ ; } } return $ count ; }
function calcNodes ( $ N , $ I ) { $ result = 0 ; $ result = $ I * ( $ N - 1 ) + 1 ; return $ result ; }
function countRhombi ( $ h , $ w ) { $ ct = 0 ; for ( $ i = 2 ; $ i <= $ h ; $ i += 2 ) for ( $ j = 2 ; $ j <= $ w ; $ j += 2 ) $ ct += ( $ h - $ i + 1 ) * ( $ w - $ j + 1 ) ; return $ ct ; }
function maxSum ( $ N ) { $ ans = 0 ; for ( $ u = 1 ; $ u <= $ N ; $ u ++ ) { for ( $ v = 1 ; $ v <= $ N ; $ v ++ ) { if ( $ u == $ v ) continue ; $ degreeU = 2 ; if ( $ u == 1 $ u == $ N ) $ degreeU = 1 ; $ degreeV = 2 ; if ( $ v == 1 $ v == $ N ) $ degreeV = 1 ; $ ans += ( $ degreeU * $ degreeV ) ; } } return $ ans ; }
function countSquares ( $ row , $ column ) { $ topLeft = min ( $ row , $ column ) - 1 ; $ bottomRight = 8 - max ( $ row , $ column ) ; $ topRight = min ( $ row , 9 - $ column ) - 1 ; $ bottomLeft = 8 - max ( $ row , 9 - $ column ) ; return ( $ topLeft + $ topRight + $ bottomRight + $ bottomLeft ) ; }
function canTakeDown ( $ bishopX , $ bishopY , $ pawnX , $ pawnY ) { if ( $ pawnX - $ bishopX == $ pawnY - $ bishopY ) return true ; else if ( - $ pawnX + $ bishopX == $ pawnY - $ bishopY ) return true ; else return false ; }
function calculateArea ( $ x , $ y ) { $ pi = 3.1415926536 ; $ arx = $ pi * $ x * $ x ; $ ary = $ pi * $ y * $ y ; return ( $ arx - $ ary ) ; }
function findValues ( $ a , $ b ) { if ( ( $ a - $ b ) % 2 == 1 ) { echo " - 1" ; return ; } echo ( $ a - $ b ) / 2 , " ▁ " , ( $ a + $ b ) / 2 ; }
function findPrimeFactors ( ) { global $ N , $ primeFactors ; for ( $ i = 2 ; $ i < $ N ; $ i ++ ) if ( $ primeFactors [ $ i ] == 0 ) for ( $ j = $ i ; $ j < $ N ; $ j += $ i ) $ primeFactors [ $ j ] = $ primeFactors [ ( int ) ( $ j / $ i ) ] + 1 ; for ( $ i = 1 ; $ i < $ N ; $ i ++ ) $ primeFactors [ $ i ] += $ primeFactors [ $ i - 1 ] ; }
function minValue ( $ n , $ x , $ y ) { $ val = ( $ y * $ n ) / 100 ; if ( $ x >= $ val ) return 0 ; else return ( ceil ( $ val ) - $ x ) ; } { $ n = 10 ; $ x = 2 ; $ y = 40 ; echo ( minValue ( $ n , $ x , $ y ) ) ; }
function mixtureConcentration ( $ n , $ p ) { $ res = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ res += $ p [ $ i ] ; $ res /= $ n ; return $ res ; }
function isPossible ( $ n , $ k , $ arr ) { $ sum = $ arr [ 0 ] ; $ maxVal = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ sum += $ arr [ $ i ] ; $ maxVal = max ( $ maxVal , $ arr [ $ i ] ) ; } if ( ( float ) $ maxVal > ( float ) ( $ sum + $ k ) / $ n ) return false ; return true ; }
function countOddSquares ( $ n , $ m ) { return ( int ) pow ( $ m , 0.5 ) - ( int ) pow ( $ n - 1 , 0.5 ) ; }
function Square ( $ row , $ column , $ moves ) { $ a = 0 ; $ b = 0 ; $ c = 0 ; $ d = 0 ; $ total = 0 ; $ a = $ row - $ moves ; $ b = $ row + $ moves ; $ c = $ column - $ moves ; $ d = $ column + $ moves ; if ( $ a < 1 ) $ a = 1 ; if ( $ c < 1 ) $ c = 1 ; if ( $ b > 8 ) $ b = 8 ; if ( $ d > 8 ) $ d = 8 ; $ total = ( $ b - $ a + 1 ) * ( $ d - $ c + 1 ) - 1 ; return $ total ; }
function findNumber ( $ n , $ m ) { $ num = ( $ m - 1 ) * 9 + $ n ; return $ num ; }
function maxResult ( $ n , $ a , $ b , $ c ) { $ maxVal = 0 ; for ( $ i = 0 ; $ i <= $ n ; $ i += $ a ) for ( $ j = 0 ; $ j <= $ n - $ i ; $ j += $ b ) { $ z = ( $ n - ( $ i + $ j ) ) / $ c ; if ( floor ( $ z ) == ceil ( $ z ) ) { $ x = ( int ) ( $ i / $ a ) ; $ y = ( int ) ( $ j / $ b ) ; $ maxVal = max ( $ maxVal , $ x + $ y + ( int ) $ z ) ; } } return $ maxVal ; }
function make_sequence ( $ N ) { $ arr = array ( ) ; $ sum = 0 ; for ( $ i = 1 ; $ i <= $ N ; $ i ++ ) { if ( $ i % 2 == 1 ) $ arr [ $ i ] = 1 ; else $ arr [ $ i ] = 2 ; $ sum += $ arr [ $ i ] ; } if ( $ sum % 2 == 1 ) $ arr [ 2 ] = 3 ; for ( $ i = 1 ; $ i <= $ N ; $ i ++ ) echo $ arr [ $ i ] , " ▁ " ; }
function countOdd ( $ L , $ R ) { $ N = ( $ R - $ L ) / 2 ; if ( $ R % 2 != 0 $ L % 2 != 0 ) $ N ++ ; return $ N ; }
function getMinCost ( $ n , $ m ) { $ cost = ( $ n - 1 ) * $ m + ( $ m - 1 ) * $ n ; return $ cost ; }
function binomialCoeff ( $ n , $ k ) { if ( $ k > $ n ) return 0 ; $ res = 1 ; if ( $ k > $ n - $ k ) $ k = $ n - $ k ; for ( $ i = 0 ; $ i < $ k ; ++ $ i ) { $ res *= ( $ n - $ i ) ; $ res /= ( $ i + 1 ) ; } return $ res ; }
function minAbsDiff ( $ n ) { $ mod = $ n % 4 ; if ( $ mod == 0 $ mod == 3 ) return 0 ; return 1 ; }
function generateSequence ( $ n , $ g ) { for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) echo $ i * $ g . " ▁ " ; }
function getMinNum ( $ a , $ b , $ c ) { if ( $ c < $ a $ c > $ b ) return $ c ; $ x = ( floor ( ( $ b / $ c ) ) * $ c ) + $ c ; return $ x ; }
function isEvenOrOdd ( $ L , $ R ) { $ oddCount = floor ( ( $ R - $ L ) / 2 ) ; if ( $ R % 2 == 1 $ L % 2 == 1 ) $ oddCount ++ ; if ( $ oddCount % 2 == 0 ) return " Even " ; else return " Odd " ; }
function countPairs ( $ n ) { $ num = ( ( $ n / 2 ) + 1 ) ; $ max = $ n % $ num ; $ count = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 1 ; $ j <= $ n ; $ j ++ ) { $ val = ( ( $ n % $ i ) % $ j ) % $ n ; if ( $ val == $ max ) $ count ++ ; } } return $ count ; }
function countPairs ( $ n ) { if ( $ n == 2 ) return 4 ; $ num = ( ( int ) ( $ n / 2 ) + 1 ) ; $ max = $ n % $ num ; $ count = ( $ n - $ max ) ; return $ count ; }
function isDivisible ( $ n ) { $ temp = $ n ; $ sum = 0 ; while ( $ n ) { $ k = $ n % 10 ; $ sum += $ k ; $ n = ( int ) ( $ n / 10 ) ; } if ( $ temp % $ sum == 0 ) return " YES " ; return " NO " ; }
function alter ( $ x , $ y ) { while ( true ) { if ( $ x == 0 $ y == 0 ) break ; if ( $ x >= 2 * $ y ) $ x = $ x % ( 2 * $ y ) ; else if ( $ y >= 2 * $ x ) $ y = $ y % ( 2 * $ x ) ; else break ; } echo " X = " , ▁ $ x , ▁ " , " , ▁ " Y = " }
function isDivisible ( $ n ) { $ temp = $ n ; while ( $ n ) { $ k = $ n % 10 ; if ( $ temp % $ k == 0 ) return " YES " ; $ n = floor ( $ n / 10 ) ; } return " NO " ; }
function largestCoprime ( $ N ) { if ( $ N == 6 ) return 1 ; else if ( $ N % 4 == 0 ) return ( $ N / 2 ) - 1 ; else if ( $ N % 2 == 0 ) return ( $ N / 2 ) - 2 ; else return ( ( $ N - 1 ) / 2 ) ; }
function sum ( $ n ) { $ i ; $ s = 0.0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ s = $ s + 1 / $ i ; return $ s ; }
function sum ( $ n ) { if ( $ n < 2 ) return 1 ; else return 1 / $ n + ( sum ( $ n - 1 ) ) ; }
function nthTermOfTheSeries ( $ n ) { if ( $ n % 2 == 0 ) $ nthTerm = pow ( $ n - 1 , 2 ) + $ n ; else $ nthTerm = pow ( $ n + 1 , 2 ) + $ n ; return $ nthTerm ; }
function divide ( $ a , $ b ) { for ( $ i = 2 ; $ i <= min ( $ a , $ b ) ; $ i ++ ) { while ( $ a % $ i == 0 && $ b % $ i == 0 ) { $ a = $ a / $ i ; $ b = $ b / $ i ; } } echo " A = " , ▁ $ a , ▁ " , B = " , ▁ $ b , ▁ " " }
function minAbsDiff ( $ n ) { $ left = 1 << ( ( floor ( log ( $ n ) / log ( 2 ) ) ) ) ; $ right = $ left * 2 ; return min ( ( $ n - $ left ) , ( $ right - $ n ) ) ; }
function find_probability ( $ p , $ q , $ r , $ s ) { $ t = ( 1 - $ p / $ q ) * ( 1 - $ r / $ s ) ; $ ans = ( $ p / $ q ) / ( 1 - $ t ) ; return $ ans ; }
function Nthterm ( $ n ) { $ numerator = ( pow ( $ n , 2 ) ) -1 ; $ denomenator = 2 * $ n - 3 ; echo $ numerator , " / " , $ denomenator ; return $ Tn ; }
function sumArray ( $ arr , $ n ) { $ leftSum = array_fill ( 0 , $ n , 0 ) ; $ rightSum = array_fill ( 0 , $ n , 0 ) ; $ Sum = array_fill ( 0 , $ n , 0 ) ; $ leftSum [ 0 ] = 0 ; $ rightSum [ $ n - 1 ] = 0 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ leftSum [ $ i ] = $ arr [ $ i - 1 ] + $ leftSum [ $ i - 1 ] ; for ( $ j = $ n - 2 ; $ j >= 0 ; $ j -- ) $ rightSum [ $ j ] = $ arr [ $ j + 1 ] + $ rightSum [ $ j + 1 ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ Sum [ $ i ] = $ leftSum [ $ i ] + $ rightSum [ $ i ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ Sum [ $ i ] . " ▁ " ; }
function calculateSum ( $ n ) { return ( $ n * ( 2 * $ n * $ n * $ n + 12 * $ n * $ n + 25 * $ n + 21 ) ) / 2 ; }
function getElements ( $ a , & $ arr , & $ n ) { $ elements [ 0 ] = $ a ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ elements [ $ i + 1 ] = $ arr [ $ i ] ^ $ elements [ $ i ] ; } for ( $ i = 0 ; $ i < $ n + 1 ; $ i ++ ) { echo ( $ elements [ $ i ] . " " ) ; } }
function nthterm ( $ n ) { $ An = ( pow ( 1 , $ n ) + pow ( 2 , $ n ) ) * pow ( 3 , $ n ) ; return $ An ; }
function minimumX ( $ n , $ k ) { $ mini = PHP_INT_MAX ; for ( $ i = 1 ; $ i * $ i <= $ n ; $ i ++ ) { if ( $ n % $ i == 0 ) { $ fir = $ i ; $ sec = ( int ) $ n / $ i ; $ num1 = $ fir * $ k + $ sec ; $ res = ( int ) ( $ num1 / $ k ) * ( $ num1 % $ k ) ; if ( $ res == $ n ) $ mini = min ( $ num1 , $ mini ) ; $ num2 = $ sec * $ k + $ fir ; $ res = ( int ) ( $ num2 / $ k ) * ( $ num2 % $ k ) ; if ( $ res == $ n ) $ mini = min ( $ num2 , $ mini ) ; } } return $ mini ; }
function minimumX ( $ n , $ k ) { $ ans = PHP_INT_MAX ; for ( $ rem = $ k - 1 ; $ rem > 0 ; $ rem -- ) { if ( $ n % $ rem == 0 ) $ ans = min ( $ ans , $ rem + ( $ n / $ rem ) * $ k ) ; } return $ ans ; }
function getSum ( $ arr , $ p ) { return count ( $ arr ) ; }
function getHermiteNumber ( $ n ) { if ( $ n == 0 ) return 1 ; if ( $ n == 1 ) return 0 ; else return -2 * ( $ n - 1 ) * getHermiteNumber ( $ n - 2 ) ; }
function find ( $ n ) { $ b = $ n ; $ a = $ b * ( $ n - 1 ) ; if ( $ a * $ b > $ n && $ a / $ b < $ n ) { echo " a = " ▁ , ▁ $ a ▁ , ▁ " , b = " } else echo - 1 ; }
function SquareCube ( $ N ) { $ cnt = 0 ; $ i = 1 ; while ( ( pow ( $ i , 6 ) ) <= $ N ) { ++ $ cnt ; ++ $ i ; } return $ cnt ; }
function getSum ( $ n , $ d ) { $ sum = 0 ; while ( $ d <= $ n ) { $ sum += $ d ; $ d += 10 ; } return $ sum ; }
function term ( $ n ) { $ d = 2 ; $ a1 = 0 ; $ An = $ a1 + ( $ n - 1 ) * $ d ; return pow ( $ An , 3 ) ; }
function printThreeParts ( $ N ) { if ( $ N % 3 == 0 ) echo " ▁ x ▁ = ▁ 1 , ▁ y ▁ = ▁ 1 , ▁ z ▁ = ▁ " . ( $ N - 2 ) . " STRNEWLINE " ; else echo " ▁ x ▁ = ▁ 1 , ▁ y ▁ = ▁ 2 , ▁ z ▁ = ▁ " . ( $ N - 3 ) . " STRNEWLINE " ; }
function countDigitsToBeRemoved ( $ N , $ K ) { $ s = strval ( $ N ) ; $ res = 0 ; $ f_zero = 0 ; for ( $ i = strlen ( $ s ) - 1 ; $ i >= 0 ; $ i -- ) { if ( $ K == 0 ) return $ res ; if ( $ s [ $ i ] == '0' ) { $ f_zero = 1 ; $ K -- ; } else $ res ++ ; } if ( ! $ K ) return $ res ; else if ( $ f_zero ) return strlen ( $ s ) - 1 ; return -1 ; }
function findSum ( $ n ) { $ sum = 0 ; for ( $ x = 1 ; $ x <= $ n ; $ x ++ ) $ sum = $ sum + $ x ; return $ sum ; }
function check ( $ arr , $ x , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ x = sqrt ( $ arr [ $ i ] ) ; if ( floor ( $ x ) == ceil ( $ x ) ) { $ sum += $ arr [ $ i ] ; } } if ( ( $ sum % $ x ) == 0 ) return true ; else return false ; } $ arr = array ( 2 , 3 , 4 , 9 , 10 ) ; $ n = sizeof ( $ arr ) ; $ x = 13 ; if ( ! check ( $ arr , $ x , $ n ) ) { echo " Yes " ; } else { echo " No " ; }
function findSum ( $ n , $ a , $ b ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ i % $ a == 0 $ i % $ b == 0 ) $ sum += $ i ; return $ sum ; }
function findLargestDivisor ( $ n ) { for ( $ i = 2 ; $ i < sqrt ( $ n ) + 1 ; $ i ++ ) { while ( $ n % ( $ i * $ i ) == 0 ) { $ n = $ n / $ i ; } } return $ n ; }
function findMedian ( & $ a , $ n ) { sort ( $ a ) ; if ( $ n % 2 != 0 ) return ( double ) $ a [ $ n / 2 ] ; return ( double ) ( $ a [ ( $ n - 1 ) / 2 ] + $ a [ $ n / 2 ] ) / 2.0 ; }
function printAMeans ( $ A , $ B , $ N ) { $ d = ( $ B - $ A ) / ( $ N + 1 ) ; for ( $ i = 1 ; $ i <= $ N ; $ i ++ ) echo ( $ A + $ i * $ d ) , " ▁ " ; }
function getFinalElement ( $ n ) { $ finalNum = 0 ; for ( $ finalNum = 2 ; ( $ finalNum * 2 ) <= $ n ; $ finalNum *= 2 ) ; return $ finalNum ; }
function isTriPerfect ( $ n ) { $ sum = 1 + $ n ; $ i = 2 ; while ( $ i * $ i <= $ n ) { if ( $ n % $ i == 0 ) { if ( $ n / $ i == $ i ) $ sum = $ sum + $ i ; else $ sum = $ sum + $ i + $ n / $ i ; } $ i += 1 ; } if ( $ sum == 3 * $ n and $ n != 1 ) return true ; else false ; }
function MinimumMaximumPairs ( $ n , $ m ) { $ max_pairs = ( ( $ n - $ m + 1 ) * ( $ n - $ m ) ) / 2 ; $ min_pairs = $ m * ( int ) ( ( ( ( int ) ( $ n - $ m ) / $ m + 1 ) * ( ( int ) ( $ n - $ m ) / $ m ) ) / 2 ) + ( int ) ceil ( ( $ n - $ m ) / $ m ) * ( ( $ n - $ m ) % $ m ) ; echo ( " Minimum ▁ no . ▁ of ▁ pairs ▁ = ▁ " . " $ min _ pairs " . " STRNEWLINE " ) ; echo ( " Maximum ▁ no . ▁ of ▁ pairs ▁ = ▁ " . " $ max _ pairs " ) ; }
function sum ( $ N , $ X , $ Y ) { $ S1 ; $ S2 ; $ S3 ; $ S1 = floor ( ( ( int ) $ N / $ X ) ) * ( 2 * $ X + ( int ) ( ( int ) $ N / $ X - 1 ) * $ X ) / 2 ; $ S2 = floor ( ( ( int ) $ N / $ Y ) ) * ( 2 * $ Y + ( int ) ( ( int ) $ N / $ Y - 1 ) * $ Y ) / 2 ; $ S3 = floor ( ( ( int ) $ N / ( $ X * $ Y ) ) ) * ( 2 * ( $ X * $ Y ) + ( ( int ) $ N / ( $ X * $ Y ) - 1 ) * ( int ) ( $ X * $ Y ) ) / 2 ; return ceil ( $ S1 + ( $ S2 - $ S3 ) ) ; }
function findTwoThreePrime ( $ l , $ r ) { if ( $ l == 1 ) $ l ++ ; $ count = 0 ; for ( $ i = $ l ; $ i <= $ r ; $ i ++ ) { $ num = $ i ; while ( $ num % 2 == 0 ) $ num /= 2 ; while ( $ num % 3 == 0 ) $ num /= 3 ; if ( $ num == 1 ) $ count ++ ; } return $ count ; }
function countIntervals ( $ arr , $ V , $ N ) { global $ MAX_VAL ; $ min = PHP_INT_MAX ; $ max = 0 ; $ li = 0 ; $ ri = 0 ; $ freq = array_fill ( 0 , $ MAX_VAL , 0 ) ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { $ li = $ arr [ $ i ] [ 0 ] ; $ freq [ $ li ] = $ freq [ $ li ] + 1 ; $ ri = $ arr [ $ i ] [ 1 ] ; $ freq [ $ ri + 1 ] = $ freq [ $ ri + 1 ] - 1 ; if ( $ li < $ min ) $ min = $ li ; if ( $ ri > $ max ) $ max = $ ri ; } for ( $ i = $ min ; $ i <= $ max ; $ i ++ ) $ freq [ $ i ] = $ freq [ $ i ] + $ freq [ $ i - 1 ] ; return $ freq [ $ V ] ; }
function findNth ( $ N ) { $ b = 14 ; for ( $ i = 2 ; $ i <= $ N ; $ i ++ ) { if ( $ i % 2 == 0 ) $ b = $ b * 2 ; else $ b = $ b - 8 ; } return $ b ; }
function addNDigits ( $ a , $ b , $ n ) { $ num = $ a ; for ( $ i = 0 ; $ i <= 9 ; $ i ++ ) { $ tmp = $ a * 10 + $ i ; if ( $ tmp % $ b == 0 ) { $ a = $ tmp ; break ; } } if ( $ num == $ a ) return -1 ; for ( $ j = 0 ; $ j < $ n - 1 ; $ j ++ ) $ a *= 10 ; return $ a ; }
function countMoves ( $ n ) { $ ct = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ ct += $ i * ( $ n - $ i ) ; $ ct += $ n ; return $ ct ; }
function Triplets ( $ n ) { $ ans = 0 ; for ( $ i = 1 ; $ i <= $ n ; ++ $ i ) { for ( $ j = $ i ; $ j <= $ n ; ++ $ j ) { $ x = $ i * $ i + $ j * $ j ; $ y = ( int ) sqrt ( $ x ) ; if ( $ y * $ y == $ x && $ y <= $ n ) ++ $ ans ; } } return $ ans ; }
function countNumbers ( $ N ) { return ( pow ( 10 , $ N ) - 1 ) - ( pow ( 10 , $ N ) - pow ( 8 , $ N ) ) / 2 ; }
function calcDeterminant ( $ arr ) { global $ N ; $ determinant = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { $ determinant += pow ( $ arr [ $ i ] , 3 ) ; } $ determinant -= 3 * $ arr [ 0 ] * $ arr [ 1 ] * $ arr [ 2 ] ; return $ determinant ; }
function minimumMoves ( $ k , $ l , $ r ) { $ count = $ r - $ l + 1 ; if ( $ count % $ k == 0 ) return 0 ; return ( $ k - ( $ count % $ k ) ) ; }
function Alphabet_N_Pattern ( $ N ) { $ index ; $ side_index ; $ size ; $ Right = 1 ; $ Left = 1 ; $ Diagonal = 2 ; for ( $ index = 0 ; $ index < $ N ; $ index ++ ) { echo $ Left ++ ; for ( $ side_index = 0 ; $ side_index < 2 * ( $ index ) ; $ side_index ++ ) echo " ▁ " ; if ( $ index != 0 && $ index != $ N - 1 ) echo $ Diagonal ++ ; else echo " ▁ " ; for ( $ side_index = 0 ; $ side_index < 2 * ( $ N - $ index - 1 ) ; $ side_index ++ ) echo " ▁ " ; echo $ Right ++ ; echo " STRNEWLINE " ; } }
function printGroups ( $ n ) { $ x = 1 ; $ y = $ n * $ n ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 1 ; $ j <= $ n / 2 ; $ j ++ ) { echo " { " ▁ , ▁ $ x ▁ , ▁ " , " ▁ , ▁ $ y ▁ , ▁ " } " $ x ++ ; $ y -- ; } echo " STRNEWLINE " ; } }
function findEle ( $ arr , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum += $ arr [ $ i ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] == $ sum - $ arr [ $ i ] ) return $ arr [ $ i ] ; return -1 ; }
function CheckArray ( $ arr , $ n ) { $ prod = 1 ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) $ prod *= $ arr [ $ i ] ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) if ( $ arr [ $ i ] == $ prod / $ arr [ $ i ] ) return true ; return false ; }
function breakEvenPoint ( $ exp , $ S , $ M ) { $ earn = $ S - $ M ; $ res = ceil ( $ exp / $ earn ) ; return $ res ; }
function otherNumber ( $ A , $ Lcm , $ Hcf ) { return ( $ Lcm * $ Hcf ) / $ A ; }
function sum ( $ a , $ b ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= min ( $ a , $ b ) ; $ i ++ ) if ( $ a % $ i == 0 && $ b % $ i == 0 ) $ sum += $ i ; return $ sum ; }
function minimumNumbers ( $ n , $ s ) { if ( $ s % $ n ) return round ( $ s / $ n + 1 ) ; else return round ( $ s / $ n ) ; }
function contiguousPerfectSquare ( $ arr , $ n ) { $ current_length = 0 ; $ max_length = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ b = ( float ) sqrt ( $ arr [ $ i ] ) ; $ a = ( int ) $ b ; if ( $ a == $ b ) $ current_length = $ current_length + 1 ; else $ current_length = 0 ; $ max_length = max ( $ max_length , $ current_length ) ; } return $ max_length ; }
function checkNumber ( $ N ) { $ temp = $ N ; while ( $ temp > 0 ) { if ( $ temp % 1000 == 144 ) $ temp /= 1000 ; else if ( $ temp % 100 == 14 ) $ temp /= 100 ; else if ( $ temp % 10 == 1 ) $ temp /= 10 ; else { return " YES " ; } } return " NO " ; }
function countPairs ( $ n ) { $ count = 0 ; for ( $ x = 1 ; $ x < $ n ; $ x ++ ) { for ( $ y = $ x + 1 ; $ y <= $ n ; $ y ++ ) { if ( ( $ y * $ x ) % ( $ y + $ x ) == 0 ) $ count ++ ; } } return $ count ; }
function getSum ( $ a , $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; ++ $ i ) { $ sum += ( $ i / pow ( $ a , $ i ) ) ; } return $ sum ; }
function calcFunction ( $ n , $ r ) { $ finalDenominator = 1 ; $ mx = max ( $ r , $ n - $ r ) ; for ( $ i = $ mx + 1 ; $ i <= $ n ; $ i ++ ) { $ denominator = pow ( $ i , $ i ) ; $ numerator = pow ( $ i - $ mx , $ i - $ mx ) ; $ finalDenominator = ( $ finalDenominator * $ denominator ) / $ numerator ; } return $ finalDenominator ; }
function getResult ( $ n ) { if ( $ n & 1 ) return 1 ; return -1 ; }
function findAandB ( $ N ) { $ val = $ N * $ N - 4.0 * $ N ; if ( $ val < 0 ) { echo " NO " ; return ; } $ a = ( $ N + sqrt ( $ val ) ) / 2.0 ; $ b = ( $ N - sqrt ( $ val ) ) / 2.0 ; echo " a = " ▁ , ▁ $ a , ▁ " " ; STRNEWLINE TABSYMBOL echo ▁ " b = " ▁ , ▁ $ b , ▁ " " }
function minOperations ( $ A , $ n ) { if ( $ n & 1 ) return -1 ; $ zeros = 0 ; $ consZeros = 0 ; $ ones = 0 ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { $ A [ $ i ] == 0 ? $ zeros ++ : $ ones ++ ; if ( ( $ i + 1 ) < $ n ) { if ( $ A [ $ i ] == 0 && $ A [ $ i + 1 ] == 0 ) $ consZeros ++ ; } } if ( $ A [ 0 ] == $ A [ $ n - 1 ] && $ A [ 0 ] == 0 ) $ consZeros ++ ; if ( $ zeros == $ ones ) return $ consZeros ; else return -1 ; }
function findNum ( $ div , $ rem , $ N ) { $ num = $ rem [ $ N - 1 ] ; for ( $ i = $ N - 2 ; $ i >= 0 ; $ i -- ) { $ num = $ num * $ div [ $ i ] + $ rem [ $ i ] ; } return $ num ; }
function profitLoss ( $ N , $ M ) { if ( $ N == $ M ) echo " No ▁ Profit ▁ nor ▁ Loss " ; else { $ result = 0.0 ; $ result = ( abs ( $ N - $ M ) ) / $ M ; if ( $ N - $ M < 0 ) echo " Loss ▁ = ▁ - " , $ result * 100 , " % " ; else echo " Profit ▁ = ▁ " , $ result * 100 , " % " ; } }
function countPieces ( $ N ) { return 2 * $ N ; }
function SellingPrice ( $ CP , $ PP ) { $ P_decimal = 1 + ( $ PP / 100 ) ; $ res = $ P_decimal * $ CP ; return $ res ; }
function lastCoordinate ( $ n , $ a , $ b ) { return ( ( $ n + 1 ) / 2 ) * $ a - ( int ) ( $ n / 2 ) * $ b ; }
function findNum ( $ N , $ K ) { $ rem = ( $ N + $ K ) % $ K ; if ( $ rem == 0 ) return $ N ; else return $ N + $ K - $ rem ; }
function minimum ( $ n ) { $ product = 1 ; for ( $ i = 2 ; $ i * $ i <= $ n ; $ i ++ ) { if ( $ n % $ i == 0 ) { while ( $ n % $ i == 0 ) $ n = $ n / $ i ; $ product = $ product * $ i ; } } if ( $ n >= 2 ) $ product = $ product * $ n ; return $ product ; }
function countDigit ( $ n ) { $ temp = $ n ; $ sum = 0 ; $ product = 1 ; while ( $ temp != 0 ) { $ d = $ temp % 10 ; $ temp = ( int ) ( $ temp / 10 ) ; if ( $ d > 0 && $ n % $ d == 0 ) { $ sum += $ d ; $ product *= $ d ; } } echo " Sum = " . $ sum ; STRNEWLINE TABSYMBOL echo ▁ " Product = " }
function findNum ( $ N , $ K ) { $ rem = $ N % $ K ; if ( $ rem == 0 ) return $ N ; else return $ N - $ rem ; }
function countNumbers ( $ N ) { return ( int ) ( sqrt ( $ N ) ) - 1 ; }
function countOrderedPairs ( $ N ) { $ count_pairs = 0 ; for ( $ i = 1 ; $ i <= sqrt ( $ N - 1 ) ; ++ $ i ) { for ( $ j = $ i ; $ j * $ i < $ N ; ++ $ j ) ++ $ count_pairs ; } $ count_pairs *= 2 ; $ count_pairs -= ( sqrt ( $ N - 1 ) ) ; return $ count_pairs ; }
function pairwiseDifference ( $ arr , $ n ) { $ diff = 0 ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) { $ diff = abs ( $ arr [ $ i ] - $ arr [ $ i + 1 ] ) ; echo $ diff . " " ; } }
function GIF ( $ n ) { return floor ( $ n ) ; }
function smallestDivisor ( $ n ) { if ( $ n % 2 == 0 ) return 2 ; for ( $ i = 3 ; $ i * $ i <= $ n ; $ i += 2 ) { if ( $ n % $ i == 0 ) return $ i ; } return $ n ; }
function countRabbits ( $ Heads , $ Legs ) { $ count = 0 ; $ count = ( $ Legs ) - 2 * ( $ Heads ) ; $ count = ( int ) $ count / 2 ; return $ count ; }
function SumDivisible ( $ n , $ k ) { $ sum = 0 ; $ position = 1 ; while ( $ n > 0 ) { if ( $ position % 2 == 1 ) $ sum += $ n % 10 ; $ n = ( int ) $ n / 10 ; $ position ++ ; } if ( $ sum % $ k == 0 ) return true ; return false ; }
function isTriangleExists ( $ a , $ b , $ c ) { if ( $ a != 0 && $ b != 0 && $ c != 0 && ( $ a + $ b + $ c ) == 180 ) if ( ( $ a + $ b ) >= $ c || ( $ b + $ c ) >= $ a || ( $ a + $ c ) >= $ b ) return " YES " ; else return " NO " ; else return " NO " ; }
function maxSum ( $ a , $ n ) { $ maxAnd = max ( $ a ) ; $ maxOR = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ maxOR |= $ a [ $ i ] ; print ( $ maxAnd + $ maxOR ) ; }
function calculateSum ( $ n ) { $ a = ( int ) $ n ; return ( 2 * ( pow ( $ n , 6 ) + 15 * pow ( $ n , 4 ) + 15 * pow ( $ n , 2 ) + 1 ) ) ; }
function countBits ( $ n ) { $ count = 0 ; while ( $ n ) { $ count ++ ; $ n >>= 1 ; } return $ count ; }
function Check_is_possible ( $ l , $ r , $ k ) { $ count = 0 ; for ( $ i = $ l ; $ i <= $ r ; $ i ++ ) { if ( $ i % $ k == 0 ) $ count ++ ; } return ( $ count > 1 ) ; }
function Check_is_possible ( $ l , $ r , $ k ) { $ div_count = ( int ) ( $ r / $ k ) - ( int ) ( $ l / $ k ) ; if ( $ l % $ k == 0 ) $ div_count ++ ; return ( $ div_count > 1 ) ; }
function sum ( $ N ) { $ S1 = ( int ) ( ( $ N / 2 ) ) * ( int ) ( 2 * 2 + ( int ) ( $ N / 2 - 1 ) * 2 ) / 2 ; $ S2 = ( int ) ( ( $ N / 7 ) ) * ( int ) ( 2 * 7 + ( int ) ( $ N / 7 - 1 ) * 7 ) / 2 ; $ S3 = ( int ) ( ( $ N / 14 ) ) * ( int ) ( 2 * 14 + ( int ) ( $ N / 14 - 1 ) * 14 ) / 2 ; return ( $ S1 + $ S2 ) - $ S3 ; }
function nth_group ( $ n ) { return $ n * ( 2 * pow ( $ n , 2 ) + 1 ) ; }
function printPossible ( $ a , $ b , $ c ) { if ( ( $ a + $ b + $ c ) % 2 != 0 $ a + $ b < $ c ) echo ( " NO " ) ; else echo ( " YES " ) ; }
function Nth_Term ( $ n ) { return ( 2 * pow ( $ n , 3 ) - 3 * pow ( $ n , 2 ) + $ n + 6 ) / 6 ; }
function Sum_upto_nth_Term ( $ n ) { $ r = $ n * ( $ n + 1 ) * ( 2 * $ n + 7 ) / 3 ; echo $ r ; }
function Nth_Term ( $ n ) { return ( 3 * pow ( $ n , 2 ) - $ n + 2 ) / ( 2 ) ; }
function countPermutations ( $ N , $ B ) { $ x = pow ( $ B , $ N ) ; $ y = pow ( $ B , $ N - 1 ) ; echo ( $ x - $ y ) , " STRNEWLINE " ; }
function EqualNumbers ( $ a , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum += $ a [ $ i ] ; if ( $ sum % $ n ) return $ n - 1 ; return $ n ; }
function printNumberWithDR ( $ k , $ d ) { if ( $ d == 0 && $ k != 1 ) echo " - 1" ; else { echo $ d ; $ k -- ; while ( $ k -- ) echo "0" ; } }
function findSteps ( $ n , $ m , $ a ) { $ cur = 1 ; $ steps = 0 ; for ( $ i = 0 ; $ i < $ m ; $ i ++ ) { if ( $ a [ $ i ] >= $ cur ) $ steps += ( $ a [ $ i ] - $ cur ) ; else $ steps += ( $ n - $ cur + $ a [ $ i ] ) ; $ cur = $ a [ $ i ] ; } return $ steps ; }
function PossibleValues ( $ b , $ x , $ n ) { $ leastdivisible = ( intval ( $ b / $ x ) + 1 ) * $ x ; $ flag = 1 ; while ( $ leastdivisible <= $ n ) { if ( $ leastdivisible - $ b >= 1 ) { echo $ leastdivisible - $ b . " " ; $ leastdivisible += $ x ; $ flag = 0 ; } else break ; } if ( $ flag ) echo " - 1" ; }
function sum_of_series ( $ n ) { $ result = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { if ( $ i % 2 == 0 ) $ result = $ result - pow ( $ i , 2 ) ; else $ result = $ result + pow ( $ i , 2 ) ; } return $ result ; }
function sum_of_series ( $ n ) { $ result = 0 ; if ( $ n % 2 == 0 ) { $ result = - ( $ n * ( $ n + 1 ) ) / 2 ; } else { $ result = ( $ n * ( $ n + 1 ) ) / 2 ; } return $ result ; }
function numberOfDistinct ( $ n ) { $ ans = 0 ; for ( $ i = 1 ; $ i <= sqrt ( $ n ) ; $ i ++ ) { if ( $ n % $ i == 0 ) { $ ans ++ ; if ( ( $ n / $ i ) != $ i ) $ ans ++ ; } } return $ ans ; }
function calculateAlternateSum ( $ n ) { if ( $ n <= 0 ) return 0 ; $ fibo = array ( ) ; $ fibo [ 0 ] = 0 ; $ fibo [ 1 ] = 1 ; $ sum = pow ( $ fibo [ 0 ] , 2 ) + pow ( $ fibo [ 1 ] , 2 ) ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { $ fibo [ $ i ] = $ fibo [ $ i - 1 ] + $ fibo [ $ i - 2 ] ; if ( $ i % 2 == 0 ) $ sum -= $ fibo [ $ i ] ; else $ sum += $ fibo [ $ i ] ; } return $ sum ; }
function getValue ( $ n ) { $ i = 0 ; $ k = 1 ; while ( $ i < $ n ) { $ i = $ i + $ k ; $ k = $ k * 2 ; } return ( int ) $ k / 2 ; }
function nthKyneaNumber ( $ n ) { $ n = ( 1 << $ n ) + 1 ; $ n = $ n * $ n ; $ n = $ n - 2 ; return $ n ; }
function nthKyneaNumber ( $ n ) { return ( ( 1 << ( 2 * $ n ) ) + ( 1 << ( $ n + 1 ) ) - 1 ) ; }
function get_last_two_digit ( $ N ) { if ( $ N <= 10 ) { $ ans = 0 ; $ fac = 1 ; for ( $ i = 1 ; $ i <= $ N ; $ i ++ ) { $ fac = $ fac * $ i ; $ ans += $ fac ; } return $ ans % 100 ; } return 13 ; }
function isProductEven ( $ arr , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( ( $ arr [ $ i ] & 1 ) == 0 ) return true ; return false ; }
function get_unit_digit ( $ N ) { if ( $ N == 0 $ N == 1 ) return 1 ; else if ( $ N == 2 ) return 3 ; else if ( $ N == 3 ) return 9 ; return 3 ; }
function calculateSquareSum ( $ n ) { if ( $ n <= 0 ) return 0 ; $ fibo [ 0 ] = 0 ; $ fibo [ 1 ] = 1 ; $ sum = ( $ fibo [ 0 ] * $ fibo [ 0 ] ) + ( $ fibo [ 1 ] * $ fibo [ 1 ] ) ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { $ fibo [ $ i ] = $ fibo [ $ i - 1 ] + $ fibo [ $ i - 2 ] ; $ sum += ( $ fibo [ $ i ] * $ fibo [ $ i ] ) ; } return $ sum ; }
function fnMod ( $ n ) { $ rem = $ n % 4 ; if ( $ rem == 0 or $ rem == 3 ) return 0 ; else if ( $ rem == 1 or $ rem == 2 ) return 1 ; }
function MinimumMoves ( & $ a , $ n , $ x ) { $ ans = 0 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] <= $ a [ $ i - 1 ] ) { $ p = ( $ a [ $ i - 1 ] - $ a [ $ i ] ) / $ x + 1 ; $ ans += $ p ; $ a [ $ i ] += $ p * $ x ; } } return $ ans ; }
function printLines ( $ n , $ k ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { echo ( $ k * ( 6 * $ i + 1 ) ) ; echo ( " ▁ " ) ; echo ( $ k * ( 6 * $ i + 2 ) ) ; echo ( " ▁ " ) ; echo ( $ k * ( 6 * $ i + 3 ) ) ; echo ( " ▁ " ) ; echo ( $ k * ( 6 * $ i + 5 ) ) ; echo ( " STRNEWLINE " ) ; } }
function NumberOfRectangles ( $ n , $ m ) { if ( $ n % 2 == 0 ) return ( $ n / 2 ) * $ m ; else if ( $ m % 2 == 0 ) return ( $ m / 2 ) * $ n ; return ( $ n * $ m - 1 ) / 2 ; }
function NumberOfSolutions ( $ x , $ y , $ z , $ n ) { $ ans = 0 ; for ( $ i = 0 ; $ i <= $ x ; $ i ++ ) { for ( $ j = 0 ; $ j <= $ y ; $ j ++ ) { $ temp = $ n - $ i - $ j ; if ( $ temp >= 0 ) { $ temp = min ( $ temp , $ z ) ; $ ans += $ temp + 1 ; } } } return $ ans ; }
function NumberOfSolutions ( $ a , $ b , $ c , $ d ) { $ ans = 0 ; for ( $ i = $ a ; $ i <= $ b ; $ i ++ ) if ( $ d >= max ( $ c , $ i + 1 ) ) $ ans += $ d - max ( $ c , $ i + 1 ) + 1 ; return $ ans ; }
function isSumDivides ( $ N ) { $ temp = $ N ; $ sum = 0 ; while ( $ temp ) { $ sum += $ temp % 10 ; $ temp = ( int ) $ temp / 10 ; } if ( $ N % $ sum == 0 ) return 1 ; else return 0 ; }
function CountDigits ( $ n ) { if ( $ n == 1 ) return 1 ; $ sum = 0 ; for ( $ i = 2 ; $ i <= $ n ; ++ $ i ) { $ sum += log ( $ i ) / log ( 10 ) ; } $ sum *= $ n ; }
function findF_N ( $ n ) { $ ans = 0 ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) $ ans += ( $ i + 1 ) * ( $ n - $ i - 1 ) ; return $ ans ; }
function findNumber ( $ n , $ d ) { $ ans = " " ; if ( $ d != 10 ) { $ ans . = strval ( $ d ) ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ ans . = '0' ; } else { if ( n == 1 ) $ ans . = " Impossible " ; else $ ans . = '1' ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ ans . = '0' ; } return $ ans ; }
function form_sieve ( ) { global $ sieve_Prime , $ sieve_count , $ MAX ; $ sieve_Prime [ 1 ] = 1 ; for ( $ i = 2 ; $ i <= $ MAX ; $ i ++ ) { if ( $ sieve_Prime [ $ i ] == 0 ) { for ( $ j = $ i * 2 ; $ j <= $ MAX ; $ j += $ i ) { if ( $ sieve_Prime [ $ j ] == 0 ) { $ sieve_Prime [ $ j ] = 1 ; $ sieve_count [ $ i ] ++ ; } } } } }
function nthTerm ( $ n ) { return pow ( $ n , 2 ) + 4 * $ n ; }
function NthTerm ( $ n ) { $ mod = 1000000009 ; $ x = ( 3 * $ n * $ n ) % $ mod ; return ( $ x - $ n + $ mod ) % $ mod ; }
function isPrime ( $ n ) { if ( $ n <= 1 ) return false ; if ( $ n <= 3 ) return true ; if ( $ n % 2 == 0 $ n % 3 == 0 ) return false ; for ( $ i = 5 ; $ i * $ i <= $ n ; $ i = $ i + 6 ) { if ( $ n % $ i == 0 || $ n % ( $ i + 2 ) == 0 ) { return false ; } } return true ; } $ n = 17 ; if ( isPrime ( $ n ) && ( $ n % 16 == 1 ) ) { echo " YES " ; } else { echo " NO " ; }
function sum ( $ N ) { $ S1 ; $ S2 ; $ S3 ; $ S1 = ( ( $ N / 3 ) ) * ( 2 * 3 + ( $ N / 3 - 1 ) * 3 ) / 2 ; $ S2 = ( ( $ N / 4 ) ) * ( 2 * 4 + ( $ N / 4 - 1 ) * 4 ) / 2 ; $ S3 = ( ( $ N / 12 ) ) * ( 2 * 12 + ( $ N / 12 - 1 ) * 12 ) / 2 ; return $ S1 + $ S2 - $ S3 ; }
function nextGreater ( $ N ) { $ power_of_2 = 1 ; $ shift_count = 0 ; while ( true ) { if ( ( ( $ N >> $ shift_count ) & 1 ) % 2 == 0 ) break ; $ shift_count ++ ; $ power_of_2 = $ power_of_2 * 2 ; } return ( $ N + $ power_of_2 ) ; }
function area ( $ r ) { if ( $ r < 0 ) return -1 ; $ area = 3.14 * pow ( $ r / ( 2 * sqrt ( 2 ) ) , 2 ) ; return $ area ; }
function area ( $ a ) { if ( $ a < 0 ) return -1 ; $ area = pow ( ( $ a * sqrt ( 3 ) ) / ( sqrt ( 2 ) ) , 2 ) ; return $ area ; }
function sumProductDifference ( $ a , $ b , $ c , $ d , $ e ) { $ rootSum = ( double ) ( -1 * $ b ) / $ a ; $ rootProduct = ( double ) $ e / $ a ; return abs ( $ rootSum - $ rootProduct ) ; }
function heightCalculate ( $ H , $ n , $ m ) { $ N = $ n * 1.0 ; $ M = $ m * 1.0 ; $ h = $ H * sqrt ( $ N / ( $ N + $ M ) ) ; return $ h ; }
function numberOfSolutions ( $ n ) { $ c = 0 ; for ( $ x = 0 ; $ x <= $ n ; ++ $ x ) if ( $ n == $ x + $ n ^ $ x ) ++ $ c ; return $ c ; }
function minimumLectures ( $ m , $ n ) { $ ans = 0 ; if ( $ n < ceil ( 0.75 * $ m ) ) $ ans = ( int ) ceil ( ( ( 0.75 * $ m ) - $ n ) / 0.25 ) ; else $ ans = 0 ; return $ ans ; }
function countNumbers ( $ N ) { return ( pow ( 10 , $ N ) - pow ( 8 , $ N ) ) / 2 ; }
function findsolution ( $ n , $ x , $ y ) { if ( ( $ y - $ n + 1 ) * ( $ y - $ n + 1 ) + $ n - 1 < $ x $ y < $ n ) { echo " No ▁ solution " ; return ; } echo $ y - $ n + 1 ; while ( $ n -- > 1 ) echo " STRNEWLINE " . 1 ; }
function findPosition ( $ n , $ f , $ b ) { return $ n - max ( $ f + 1 , $ n - $ b ) + 1 ; }
function nthOdd ( $ n ) { return ( 2 * $ n - 1 ) ; }
function countSolutions ( $ a ) { $ count = 0 ; for ( $ i = 0 ; $ i <= $ a ; $ i ++ ) { if ( $ a == ( $ i + ( $ a ^ $ i ) ) ) $ count ++ ; } return $ count ; }
function nthHarmonic ( $ N ) { $ harmonic = 1.00 ; for ( $ i = 2 ; $ i <= $ N ; $ i ++ ) { $ harmonic += ( float ) 1 / $ i ; } return $ harmonic ; }
function nthTerm ( $ n ) { return 2 * pow ( $ n , 2 ) + $ n - 3 ; }
function nthTerm ( $ n ) { return 5 * pow ( $ n , 2 ) - 5 * $ n ; }
function nthTerm ( $ n ) { return 3 * pow ( $ n , 2 ) + $ n - 2 ; }
function nthTerm ( $ n ) { return 2 * pow ( $ n , 2 ) + 4 * $ n - 2 ; }
function nthTerm ( $ n ) { return 3 * pow ( $ n , 2 ) + 2 * $ n - 5 ; }
function nthTerm ( $ n ) { return 2 * pow ( $ n , 2 ) + 3 * $ n - 5 ; }
function nthTerm ( $ n ) { return 3 * pow ( $ n , 2 ) - 4 * $ n + 2 ; }
function nthTerm ( $ n ) { return 4 * pow ( $ n , 2 ) - 3 * $ n + 2 ; }
function countDivisors ( $ n , $ k ) { $ count = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { if ( $ n % $ i == 0 && $ i % $ k == 0 ) { $ count ++ ; } } return $ count ; }
function nthTerm ( $ n ) { return 2 * pow ( $ n , 3 ) + pow ( $ n , 2 ) ; }
function calculateSum ( $ n ) { return $ n * ( $ n + 1 ) / 2 + pow ( ( $ n * ( $ n + 1 ) / 2 ) , 2 ) ; }
function calculateSum ( $ n ) { return $ n * ( $ n + 1 ) / 2 + $ n * ( $ n + 1 ) * ( 2 * $ n + 1 ) / 6 ; }
function calculateSum ( $ n ) { return 2 * ( $ n * ( $ n + 1 ) * ( 2 * $ n + 1 ) / 6 ) + $ n * ( $ n + 1 ) / 2 + 2 * ( $ n ) ; }
function nthTerm ( $ n ) { return 2 * pow ( $ n , 2 ) - $ n - 1 ; }
function nthTerm ( $ n ) { return 6 * pow ( $ n , 2 ) - 4 * $ n - 2 ; }
function nthTerm ( $ n ) { return 4 * pow ( $ n , 2 ) - 7 * $ n + 3 ; }
function nthTerm ( $ n ) { return pow ( $ n , 2 ) + 2 * $ n + 2 ; }
function checkSolution ( $ a , $ b , $ c ) { if ( ( ( $ b * $ b ) - ( 4 * $ a * $ c ) ) > 0 ) echo "2 ▁ solutions " ; else if ( ( ( $ b * $ b ) - ( 4 * $ a * $ c ) ) == 0 ) echo "1 ▁ solution " ; else echo " No ▁ solutions " ; }
function sum ( $ n ) { $ ans = ( $ n * ( $ n - 1 ) ) / 2 ; return $ ans ; }
function getNthTerm ( $ N ) { return ( pow ( $ N , 2 ) + $ N + 1 ) ; }
function findSum ( $ N ) { return ( $ N * ( $ N + 1 ) * ( 2 * $ N - 5 ) + 4 * $ N ) / 2 ; }
function getNthTerm ( $ N ) { return 4 * pow ( $ N , 2 ) - 3 * $ N + 2 ; }
function findSum ( $ N ) { return ( 2 * $ N * ( $ N + 1 ) * ( 4 * $ N + 17 ) + 54 * $ N ) / 6 ; }
function findSum ( $ n ) { $ sum2 = ( ( int ) ( $ n / 2 ) * ( 4 + ( ( int ) ( $ n / 2 ) - 1 ) * 2 ) ) / 2 ; $ sum5 = ( ( int ) ( $ n / 5 ) * ( 10 + ( $ n / 5 - 1 ) * 5 ) ) / 2 ; $ sum10 = ( ( int ) ( $ n / 10 ) * ( 20 + ( $ n / 10 - 1 ) * 10 ) ) / 2 ; return $ sum2 + $ sum5 - $ sum10 ; }
function printNthElement ( $ n ) { $ arr = array_fill ( 0 , ( $ n + 1 ) , NULL ) ; $ arr [ 1 ] = 3 ; $ arr [ 2 ] = 5 ; for ( $ i = 3 ; $ i <= $ n ; $ i ++ ) { if ( $ i % 2 != 0 ) $ arr [ $ i ] = $ arr [ $ i / 2 ] * 10 + 3 ; else $ arr [ $ i ] = $ arr [ ( $ i / 2 ) - 1 ] * 10 + 5 ; } return $ arr [ $ n ] ; }
function nthTerm ( $ N ) { return ( ( 3 * $ N * $ N ) - ( 6 * $ N ) + 2 ) ; }
function nthTerm ( $ N ) { return ( 2 * $ N + 3 ) * ( 2 * $ N + 3 ) - 2 * $ N ; }
function nextPerfectCube ( $ N ) { $ nextN = ( int ) ( floor ( pow ( $ N , ( 1 / 3 ) ) ) + 1 ) ; return $ nextN * $ nextN * $ nextN ; }
function findSum ( $ n ) { return sqrt ( 3 ) * ( $ n * ( $ n + 1 ) / 2 ) ; }
function sum ( $ x , $ y , $ n ) { $ sum1 = ( pow ( $ x , 2 ) * ( pow ( $ x , 2 * $ n ) - 1 ) ) / ( pow ( $ x , 2 ) - 1 ) ; $ sum2 = ( $ x * $ y * ( pow ( $ x , $ n ) * pow ( $ y , $ n ) - 1 ) ) / ( $ x * $ y - 1 ) ; return $ sum1 + $ sum2 ; }
function findSum ( $ n ) { return ( $ n * ( pow ( $ n , 2 ) + 3 * $ n + 5 ) ) / 3 ; }
function findSum ( $ n ) { return ( pow ( 10 , $ n + 1 ) * ( 9 * $ n - 1 ) + 10 ) / pow ( 9 , 3 ) - $ n * ( $ n + 1 ) / 18 ; }
function solve_sum ( $ n ) { if ( $ n % 2 == 1 ) return ( $ n + 1 ) / 2 ; return - $ n / 2 ; }
function calculateSum ( $ n ) { return pow ( $ n * ( $ n + 1 ) / 2 , 2 ) ; }
function printPair ( $ g , $ l ) { echo $ g ; echo ( " ▁ " ) ; echo $ l ; }
function findMaximumPieces ( $ n ) { return 1 + $ n * ( $ n + 1 ) / 2 ; }
function totEdge ( $ n ) { $ result = 0 ; $ result = ( $ n * ( $ n - 1 ) ) / 2 ; return $ result ; }
function rmsValue ( $ arr , $ n ) { $ square = 0 ; $ mean = 0.0 ; $ root = 0.0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ square += pow ( $ arr [ $ i ] , 2 ) ; } $ mean = ( $ square / ( float ) ( $ n ) ) ; $ root = sqrt ( $ mean ) ; return $ root ; }
function Mixture ( $ X , $ Y , $ Z ) { $ result = 0.0 ; $ result1 = 0.0 ; $ result1 = ( ( $ X - $ Y ) / $ X ) ; $ result = pow ( $ result1 , $ Z ) ; $ result = $ result * $ X ; return $ result ; }
function coin ( $ totalRupees , $ X , $ Y , $ Z ) { $ one = 0 ; $ fifty = 0 ; $ twentyfive = 0 ; $ result = 0 ; $ total = 0 ; $ one = $ X * 1 ; $ fifty = ( ( $ Y * 1 ) / 2.0 ) ; $ twentyfive = ( ( $ Z * 1 ) / 4.0 ) ; $ total = $ one + $ fifty + $ twentyfive ; $ result = ( ( $ totalRupees ) / $ total ) ; return $ result ; }
function sumOfSeries ( $ x , $ k ) { return ( ( $ x ) / 81 ) * ( 9 * $ k - 1 + pow ( 10 , ( -1 ) * $ k ) ) ; }
function calculateSum ( $ n ) { $ a1 = 1 ; $ a2 = 2 ; $ r = 2 ; $ d = 1 ; return ( $ n ) * ( 2 * $ a1 + ( $ n - 1 ) * $ d ) / 2 + $ a2 * ( pow ( $ r , $ n ) - 1 ) / ( $ r - 1 ) ; }
function Race ( $ B , $ C ) { $ result = 0 ; $ result = ( ( $ C * 100 ) / $ B ) ; return 100 - $ result ; }
function isDivisible ( $ n ) { while ( $ n / 100 != 0 ) { $ d = ( int ) $ n % 10 ; $ n /= 10 ; $ n -= $ d * 5 ; } return ( $ n % 17 == 0 ) ; }
function calculateSum ( $ n ) { return ( pow ( 2 , $ n + 1 ) + $ n - 2 ) ; }
function calculateSum ( $ n ) { return ( $ n * ( 4 * $ n * $ n + 6 * $ n - 1 ) / 3 ) ; }
function bridge_length ( $ trainLength , $ Speed , $ Time ) { return ( ( $ Time * $ Speed ) - $ trainLength ) ; }
function findN ( $ k ) { $ ans ; if ( $ k == 0 ) $ ans = 3 ; if ( $ k == 1 ) $ ans = 1 ; else if ( $ k % 4 == 0 ) $ ans = $ k ; else if ( $ k % 4 == 3 ) $ ans = $ k - 1 ; else $ ans = -1 ; return $ ans ; }
function Circular ( $ n ) { $ Result = 1 ; while ( $ n > 0 ) { $ Result = $ Result * $ n ; $ n -- ; } return $ Result ; }
function T_ime ( $ arr , $ n , $ Emptypipe ) { $ fill = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ fill += 1 / $ arr [ $ i ] ; $ fill = $ fill - ( 1 / $ Emptypipe ) ; return 1 / $ fill ; }
function calculateAreaSum ( $ l , $ b ) { $ size = 1 ; $ maxSize = min ( $ l , $ b ) ; $ totalArea = 0 ; for ( $ i = 1 ; $ i <= $ maxSize ; $ i ++ ) { $ totalSquares = ( $ l - $ size + 1 ) * ( $ b - $ size + 1 ) ; $ area = $ totalSquares * $ size * $ size ; $ totalArea += $ area ; $ size ++ ; } return $ totalArea ; }
function printCombination ( $ n ) { for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { if ( $ i % 3 != 0 ) { for ( $ j = 1 ; $ j < $ n ; $ j ++ ) { if ( $ j % 3 != 0 ) { for ( $ k = 1 ; $ k < $ n ; $ k ++ ) { if ( $ k % 3 != 0 && ( $ i + $ j + $ k ) == $ n ) { echo $ i , " " ▁ , ▁ $ j ▁ , ▁ " " return ; } } } } } } }
function printCombination ( $ n ) { echo "1 ▁ " ; if ( ( $ n - 2 ) % 3 == 0 ) echo "2 ▁ " . ( $ n - 3 ) ; else echo "1 ▁ " . ( $ n - 2 ) ; }
function checkPairs ( $ l , $ r ) { if ( ( $ l - $ r ) % 2 == 0 ) return false ; return true ; }
function calTime ( & $ arr , $ n ) { $ work = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ work += 1 / $ arr [ $ i ] ; return 1 / $ work ; }
function isPalindrome ( $ n ) { if ( $ n % 11 == 0 ) { return true ; } return false ; }
function percent ( $ a , $ b ) { $ result = 0 ; $ result = ( ( $ b - $ a ) * 100 ) / $ a ; return $ result ; }
function nextPerfectSquare ( $ N ) { $ nextN = floor ( sqrt ( $ N ) ) + 1 ; return $ nextN * $ nextN ; }
function printSubstrings ( $ n ) { $ s = ( int ) log10 ( $ n ) ; $ d = ( int ) ( pow ( 10 , $ s ) + 0.5 ) ; $ k = $ d ; while ( $ n ) { while ( $ d ) { echo ( int ) ( $ n / $ d ) . " STRNEWLINE " ; $ d = ( int ) ( $ d / 10 ) ; } $ n = $ n % $ k ; $ k = ( int ) ( $ k / 10 ) ; $ d = $ k ; } }
function check ( $ n ) { $ sum = 0 ; while ( $ n != 0 ) { $ sum += $ n % 10 ; $ n = ( int ) ( $ n / 10 ) ; } if ( $ sum % 7 == 0 ) return 1 ; else return 0 ; }
function gcd ( $ a , $ b ) { if ( $ a == 0 ) return $ b ; return gcd ( $ b % $ a , $ a ) ; }
function numberSequence ( $ n ) { $ num = pow ( 4 , $ n ) - pow ( 2 , $ n ) - 1 ; return $ num ; }
function complement ( $ num ) { $ i ; $ len = 0 ; $ comp ; $ temp = $ num ; while ( 1 ) { $ len ++ ; $ num = ( int ) ( $ num / 10 ) ; if ( abs ( $ num ) == 0 ) break ; } $ num = $ temp ; $ comp = pow ( 10 , $ len ) - $ num ; return $ comp ; }
function calculate ( & $ array , $ size ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ size ; $ i ++ ) if ( $ array [ $ i ] % 2 == 0 && $ array [ $ i ] != 0 && $ array [ $ i ] != 2 ) $ count ++ ; return $ count ; }
function findGreater ( $ x , $ y ) { if ( $ x > $ y ) { return false ; } else { return true ; } }
function print_C ( $ p0 ) { $ p1 = 0 ; $ i = 0 ; $ x ; $ flag ; $ k ; while ( 1 ) { $ flag = 1 ; $ x = pow ( 2 , $ i ) ; $ p1 = $ x * $ p0 + ( $ x - 1 ) ; for ( $ k = 2 ; $ k < $ p1 ; $ k ++ ) { if ( $ p1 % $ k == 0 ) { $ flag = 0 ; break ; } } if ( $ flag == 0 ) break ; echo $ p1 . " " ; $ i ++ ; } }
function print_t ( $ p0 ) { $ p1 ; $ i = 0 ; $ x ; $ flag ; $ k ; while ( 1 ) { $ flag = 1 ; $ x = pow ( 2 , $ i ) ; $ p1 = $ x * $ p0 - ( $ x - 1 ) ; for ( $ k = 2 ; $ k < $ p1 ; $ k ++ ) { if ( $ p1 % $ k == 0 ) { $ flag = 0 ; break ; } } if ( $ flag == 0 ) break ; echo $ p1 . " " ; $ i ++ ; } }
function boost_hyperfactorial ( $ num ) { $ val = 1 ; for ( $ i = 1 ; $ i <= $ num ; $ i ++ ) { $ val = $ val * pow ( $ i , $ i ) ; } return $ val ; }
function boost_hyperfactorial ( $ num ) { $ val = 1 ; for ( $ i = 1 ; $ i <= $ num ; $ i ++ ) { for ( $ j = 1 ; $ j <= $ i ; $ j ++ ) { $ val *= $ i ; } } return $ val ; }
function findOddPair ( & $ A , $ N ) { $ oddPair = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ N ; $ j ++ ) { if ( ( $ A [ $ i ] & $ A [ $ j ] ) % 2 != 0 ) $ oddPair = $ oddPair + 1 ; } } return $ oddPair ; }
function findOddPair ( & $ A , $ N ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) if ( ( $ A [ $ i ] % 2 == 1 ) ) $ count ++ ; return $ count * ( $ count - 1 ) / 2 ; }
function gcd ( $ a , $ b ) { if ( $ a == 0 && $ b == 0 ) return 0 ; if ( $ a == 0 ) return $ b ; if ( $ b == 0 ) return $ a ; if ( $ a == $ b ) return $ a ; if ( $ a > $ b ) return gcd ( $ a - $ b , $ b ) ; return gcd ( $ a , $ b - $ a ) ; }
function gcd ( $ a , $ b ) { if ( $ b == 0 ) return $ a ; return gcd ( $ b , $ a % $ b ) ; }
function isSurd ( $ n ) { for ( $ i = 2 ; $ i * $ i <= $ n ; $ i ++ ) { $ j = $ i ; while ( $ j < $ n ) $ j = $ j * $ i ; if ( $ j == $ n ) return false ; } return true ; }
function LastTwoDigit ( $ num ) { $ one = $ num % 10 ; $ num /= 10 ; $ tens = $ num % 10 ; $ tens *= 10 ; $ num = $ tens + $ one ; return $ num ; }
function countOddSum ( & $ ar , $ n ) { $ result = 0 ; for ( $ i = 0 ; $ i <= $ n - 1 ; $ i ++ ) { $ val = 0 ; for ( $ j = $ i ; $ j <= $ n - 1 ; $ j ++ ) { $ val = $ val + $ ar [ $ j ] ; if ( $ val % 2 != 0 ) $ result ++ ; } } return ( $ result ) ; }
function printPFsInPairs ( $ n ) { for ( $ i = 1 ; $ i * $ i <= $ n ; $ i ++ ) if ( $ n % $ i == 0 ) echo $ i . " * " . ▁ $ n ▁ / ▁ $ i ▁ . " " }
function findAngle ( $ n ) { $ interiorAngle ; $ exteriorAngle ; $ interiorAngle = ( $ n - 2 ) * 180 / $ n ; $ exteriorAngle = 360 / $ n ; echo " Interior ▁ angle : ▁ " , $ interiorAngle , " STRNEWLINE " ; echo " Exterior ▁ angle : ▁ " , $ exteriorAngle ; }
function rainDayProbability ( $ a , $ n ) { $ count = 0 ; $ m ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] == 1 ) $ count ++ ; } $ m = $ count / $ n ; return $ m ; }
function distance ( $ x1 , $ y1 , $ z1 , $ x2 , $ y2 , $ z2 ) { $ d = sqrt ( pow ( $ x2 - $ x1 , 2 ) + pow ( $ y2 - $ y1 , 2 ) + pow ( $ z2 - $ z1 , 2 ) * 1.0 ) ; echo " Distance ▁ is ▁ " . $ d ; }
function twoEggDrop ( $ k ) { return ceil ( ( -1.0 + sqrt ( 1 + 8 * $ k ) ) / 2.0 ) ; }
function DivisibleBy41 ( $ first , $ second , $ c , $ n ) { $ digit [ $ n ] = range ( 1 , $ n ) ; $ digit [ 0 ] = $ first ; $ digit [ 1 ] = $ second ; for ( $ i = 2 ; $ i < $ n ; $ i ++ ) $ digit [ $ i ] = ( $ digit [ $ i - 1 ] * $ c + $ digit [ $ i - 2 ] ) % 10 ; $ ans = $ digit [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ ans = ( $ ans * 10 + $ digit [ $ i ] ) % 41 ; if ( $ ans % 41 == 0 ) return true ; else return false ; }
function printSeries ( $ n ) { for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ num = ( $ i * ( $ i + 1 ) * ( $ i + 2 ) * ( $ i + 3 ) / 24 ) ; echo ( $ num . " " ) ; } }
function printSeries ( $ n ) { for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ num = $ i * ( $ i + 1 ) * ( $ i + 2 ) / 6 ; echo ( $ num . " " ) ; } }
function calculateSum ( $ n ) { $ sum = 0 ; for ( $ row = 0 ; $ row < $ n ; $ row ++ ) { $ sum = $ sum + ( 1 << $ row ) ; } return $ sum ; }
function calculateSum ( $ n ) { $ sum = 0 ; $ sum = 1 << $ n ; return ( $ sum - 1 ) ; }
function findNthNonSquare ( $ n ) { $ x = $ n ; $ ans = $ x + floor ( 0.5 + sqrt ( $ x ) ) ; return ( int ) $ ans ; }
function getMaxOnes ( $ n , $ x ) { $ zeroes = ( int ) ( $ n / $ x ) ; $ zeroes = $ zeroes * $ zeroes ; $ total = $ n * $ n ; $ ans = $ total - $ zeroes ; return $ ans ; }
function ways ( $ n ) { $ first = 2 ; $ second = 3 ; $ res = 0 ; for ( $ i = 3 ; $ i <= $ n ; $ i ++ ) { $ res = $ first + $ second ; $ first = $ second ; $ second = $ res ; } return $ res ; }
function check ( $ n , $ m ) { if ( $ n == 2 $ m == 2 $ n % $ m == 0 ) { echo " Yes " , " STRNEWLINE " ; } else { echo " No " , " ▁ STRNEWLINE " ; } }
function MinimumMail ( $ n , $ k , $ x ) { $ m = ( $ n - 1 ) + ceil ( ( $ n - 1 ) * 1.0 / $ x ) * ( $ n - 1 ) + ceil ( $ n * 1.0 / $ x ) * ( $ k - $ n ) ; return $ m ; }
function findAllSequence ( $ N ) { if ( $ N % 2 == 0 ) { return pow ( 2 , $ N / 2 + 1 ) + pow ( 2 , $ N / 2 ) - 2 ; } else { return pow ( 2 , ( $ N + 1 ) / 2 ) + pow ( 2 , ( $ N + 1 ) / 2 ) - 2 ; } }
function findArea ( $ a , $ b ) { $ Area ; $ Area = 3.142 * $ a * $ b ; echo " Area : ▁ " . $ Area ; }
function calculate ( $ x , $ k , $ m ) { $ result = $ x ; $ k -- ; while ( $ k -- ) { $ result = pow ( $ result , $ x ) ; if ( $ result > $ m ) $ result %= $ m ; } return $ result ; }
function rev ( $ n , $ temp ) { if ( $ n == 0 ) return $ temp ; $ temp = ( $ temp * 10 ) + ( $ n % 10 ) ; return rev ( $ n / 10 , $ temp ) ; }
function countOnes ( $ n ) { $ count = 1 ; $ rem = 1 ; while ( $ rem != 0 ) { $ rem = ( $ rem * 10 + 1 ) % $ n ; $ count ++ ; } return $ count ; }
function findGreater ( $ a , $ b , $ n ) { if ( ! ( $ n & 1 ) ) { $ a = abs ( $ a ) ; $ b = abs ( $ b ) ; } if ( $ a == $ b ) echo " a ^ n ▁ is ▁ equal ▁ to ▁ b ^ n " ; else if ( $ a > $ b ) echo " a ^ n ▁ is ▁ greater ▁ than ▁ b ^ n " ; else echo " b ^ n ▁ is ▁ greater ▁ than ▁ a ^ n " ; }
function fibonacci ( $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ fib = ( pow ( ( 1 + sqrt ( 5 ) ) , $ i ) - pow ( ( 1 - sqrt ( 5 ) ) , $ i ) ) / ( pow ( 2 , $ i ) * sqrt ( 5 ) ) ; echo $ fib , " " ; } }
function findLCM ( $ a , $ b ) { $ lar = max ( $ a , $ b ) ; $ small = min ( $ a , $ b ) ; for ( $ i = $ lar ; ; $ i += $ lar ) { if ( $ i % $ small == 0 ) return $ i ; } }
function largestNum ( $ a , $ b ) { return ( $ a * ( boolean ) floor ( ( $ a / $ b ) ) ) + ( $ b * ( boolean ) floor ( ( $ b / $ a ) ) ) ; }
function center_hexadecagonal_num ( $ n ) { return 8 * $ n * $ n - 8 * $ n + 1 ; }
function findNature ( $ a , $ b , $ n ) { global $ MAX ; $ seq = array_fill ( 0 , $ MAX , 0 ) ; $ seq [ 0 ] = $ a ; $ seq [ 1 ] = $ b ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) $ seq [ $ i ] = $ seq [ $ i - 1 ] + $ seq [ $ i - 2 ] ; return ( $ seq [ $ n ] & 1 ) ; }
function findNature ( $ a , $ b , $ n ) { if ( $ n == 0 ) return ( $ a & 1 ) ; if ( $ n == 1 ) return ( $ b & 1 ) ; if ( ! ( $ a & 1 ) ) { if ( ! ( $ b & 1 ) ) return false ; else return ( $ n % 3 != 0 ) ; } else { if ( ! ( $ b & 1 ) ) return ( ( $ n - 1 ) % 3 != 0 ) ; else return ( ( $ n + 1 ) % 3 != 0 ) ; } }
function check ( $ m , $ n ) { $ RHS = $ m * log ( $ n ) ; $ LHS = $ n * log ( $ m ) ; if ( $ LHS > $ RHS ) echo " m ^ n ▁ > ▁ n ^ m " ; else if ( $ LHS < $ RHS ) echo " m ^ n ▁ < ▁ n ^ m " ; else echo " m ^ n ▁ = ▁ n ^ m " ; }
function subtractOne ( $ x ) { $ m = 1 ; while ( ! ( $ x & $ m ) ) { $ x = $ x ^ $ m ; $ m <<= 1 ; } $ x = $ x ^ $ m ; return $ x ; }
function subtractOne ( $ x ) { return ( ( $ x << 1 ) + ( ~ $ x ) ) ; }
function meanVector ( $ mat ) { global $ rows , $ cols ; echo " [ ▁ " ; for ( $ i = 0 ; $ i < $ rows ; $ i ++ ) { $ mean = 0.00 ; $ sum = 0 ; for ( $ j = 0 ; $ j < $ cols ; $ j ++ ) $ sum += $ mat [ $ j ] [ $ i ] ; $ mean = $ sum / $ rows ; echo $ mean , " " ; ▁ } ▁ echo ▁ " ] " }
function countDigits ( $ n ) { $ ans = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ ans += log10 ( $ i ) ; $ ans = $ ans * $ n ; return 1 + floor ( $ ans ) ; }
function checksum ( $ n ) { if ( $ n % 5 == 0 ) echo $ n / 5 - 2 , " ▁ " , $ n / 5 - 1 , " ▁ " , $ n / 5 , " ▁ " , $ n / 5 + 1 , " ▁ " , $ n / 5 + 2 ; else echo " - 1" ; }
function sumOfSeries ( $ n ) { $ ans = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ ans += $ i * $ i * $ i * $ i ; return $ ans ; }
function sumOfSeries ( $ n ) { return $ n * ( $ n + 1 ) * ( 6 * $ n * $ n * $ n + 9 * $ n * $ n + $ n - 1 ) / 30 ; }
function octahedral_num ( $ n ) { return $ n * ( 2 * $ n * $ n + 1 ) / 3 ; }
function countUnmarked ( $ N ) { if ( $ N % 2 == 0 ) return $ N / 2 ; else return $ N / 2 + 1 ; }
function Pentatope_number ( $ n ) { return $ n * ( $ n + 1 ) * ( $ n + 2 ) * ( $ n + 3 ) / 24 ; }
function minimumLength ( $ x , $ y , $ z ) { return 1 + abs ( $ x - $ y ) + abs ( $ y - $ z ) ; }
function endPointOfDiameterofCircle ( $ x1 , $ y1 , $ c1 , $ c2 ) { echo " x2 = " , (2 ▁ * ▁ $ c1 ▁ - ▁ $ x1 ) , " " ; STRNEWLINE TABSYMBOL echo ▁ " y2 = " }
function dodecahedral_num ( $ n ) { return $ n * ( 3 * $ n - 1 ) * ( 3 * $ n - 2 ) / 2 ; }
function centeredTetrahedralNumber ( $ n ) { return ( 2 * $ n + 1 ) * ( $ n * $ n + $ n + 3 ) / 3 ; }
function centered_heptagonal_num ( $ n ) { return ( 7 * $ n * $ n - 7 * $ n + 2 ) / 2 ; }
function centeredIcosahedralNum ( $ n ) { return ( 2 * $ n + 1 ) * ( 5 * $ n * $ n + 5 * $ n + 3 ) / 3 ; }
function findSum ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ sum += ( ( $ i * ( $ i + 1 ) * ( 2 * $ i + 1 ) ) / 6 ) ; return $ sum ; }
function checkHankelMatrix ( $ n , $ m ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ i + $ j < $ n ) { if ( $ m [ $ i ] [ $ j ] != $ m [ $ i + $ j ] [ 0 ] ) return false ; } else { if ( $ m [ $ i ] [ $ j ] != $ m [ $ i + $ j - $ n + 1 ] [ $ n - 1 ] ) return false ; } } } return true ; }
function swap ( $ a , $ b , $ c , $ d ) { $ a = $ a + $ b ; $ b = $ a - $ b ; $ a = $ a - $ b ; $ b = $ b + $ c ; $ c = $ b - $ c ; $ b = $ b - $ c ; $ c = $ c + $ d ; $ d = $ c - $ d ; $ c = $ c - $ d ; echo " values ▁ after ▁ swapping ▁ are ▁ : ▁ " , " STRNEWLINE " ; echo " a = " ▁ , ▁ $ a ▁ , " " ; STRNEWLINE TABSYMBOL echo ▁ " b = " ▁ , ▁ $ b ▁ , " " ; STRNEWLINE TABSYMBOL echo ▁ " c = " ▁ , $ c ▁ , " " ; STRNEWLINE TABSYMBOL echo ▁ " d = " ▁ , ▁ $ d ▁ , " " }
function seriesSum ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ sum += $ i * ( $ i + 1 ) / 2 ; return $ sum ; }
function seriesSum ( $ n ) { return ( $ n * ( $ n + 1 ) * ( $ n + 2 ) ) / 6 ; }
function checkCentrosymmetricted ( $ n , $ m ) { $ mid_row ; if ( $ n & 1 ) $ mid_row = $ n / 2 + 1 ; else $ mid_row = $ n / 2 ; for ( $ i = 0 ; $ i < $ mid_row ; $ i ++ ) { for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ m [ $ i ] [ $ j ] != $ m [ $ n - $ i - 1 ] [ $ n - $ j - 1 ] ) return false ; } } return true ; }
function Centered_Triangular_num ( $ n ) { return ( 3 * $ n * $ n + 3 * $ n + 2 ) / 2 ; }
function Dodecagonal_number ( $ n ) { return 5 * $ n * $ n - 4 * $ n ; }
function isPower ( $ n ) { for ( $ x = 2 ; $ x <= sqrt ( $ n ) ; $ x ++ ) { $ f = log ( $ n ) / log ( $ x ) ; if ( ( $ f - ( int ) $ f ) == 0.0 ) return true ; } return false ; }
function number_of_digits ( $ n ) { $ i ; $ res ; $ sum = 0 ; for ( $ i = 4 , $ res = 1 ; ; $ i *= 4 , $ res ++ ) { $ sum += $ i ; if ( $ sum >= $ n ) break ; } return $ res ; }
function check ( $ k , $ d0 , $ d1 ) { $ s = ( 2 * ( $ d0 + $ d1 ) ) % 10 + ( 4 * ( $ d0 + $ d1 ) ) % 10 + ( 8 * ( $ d0 + $ d1 ) ) % 10 + ( 6 * ( $ d0 + $ d1 ) ) % 10 ; $ a = ( $ k - 3 ) % 4 ; $ x ; switch ( $ a ) { case 0 : $ x = 0 ; break ; case 1 : $ x = ( 2 * ( $ d0 + $ d1 ) ) % 10 ; break ; case 2 : $ x = ( 2 * ( $ d0 + $ d1 ) ) % 10 + ( 4 * ( $ d0 + $ d1 ) ) % 10 ; break ; case 3 : $ x = ( 2 * ( $ d0 + $ d1 ) ) % 10 + ( 4 * ( $ d0 + $ d1 ) ) % 10 + ( 8 * ( $ d0 + $ d1 ) ) % 10 ; break ; } $ sum = $ d0 + $ d1 + ( int ) ( ( $ k - 3 ) / 4 ) * $ s + $ x ; if ( $ sum % 3 == 0 ) return " YES " ; return " NO " ; }
function Reverseorder ( $ n ) { $ prime = array_fill ( 0 , $ n + 1 , true ) ; for ( $ p = 2 ; $ p * $ p <= $ n ; $ p ++ ) { if ( $ prime [ $ p ] == true ) { for ( $ i = $ p * 2 ; $ i <= $ n ; $ i += $ p ) $ prime [ $ i ] = false ; } } for ( $ p = $ n ; $ p >= 2 ; $ p -- ) if ( $ prime [ $ p ] ) echo $ p . " " ; }
function MaximumHeight ( $ a , $ n ) { $ result = 1 ; for ( $ i = 1 ; $ i <= $ n ; ++ $ i ) { $ y = ( $ i * ( $ i + 1 ) ) / 2 ; if ( $ y < $ n ) $ result = $ i ; else break ; } return $ result ; }
function printCollatz ( $ n ) { while ( $ n != 1 ) { echo $ n . " " ; if ( $ n & 1 ) $ n = 3 * $ n + 1 ; else $ n = $ n / 2 ; } echo $ n ; }
function findpos ( $ n ) { $ pos = 0 ; for ( $ i = 0 ; isset ( $ n [ $ i ] ) != NULL ; $ i ++ ) { switch ( $ n [ $ i ] ) { case '2' : $ pos = $ pos * 4 + 1 ; break ; case '3' : $ pos = $ pos * 4 + 2 ; break ; case '5' : $ pos = $ pos * 4 + 3 ; break ; case '7' : $ pos = $ pos * 4 + 4 ; break ; } } return $ pos ; }
function magicOfSequence ( $ N ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ N ; $ i ++ ) $ sum += ( $ i * $ i * $ i + $ i * 2 ) ; return $ sum ; }
function magicOfSequence ( $ N ) { return ( $ N * ( $ N + 1 ) / 2 ) + 2 * $ N ; }
function repUnitValue ( $ n ) { if ( $ n % 2 == 0 $ n % 5 == 0 ) return 0 ; $ rem = 1 ; $ power = 1 ; $ k = 1 ; while ( $ rem % $ n != 0 ) { $ k ++ ; $ power = $ power * 10 % $ n ; $ rem = ( $ rem + $ power ) % $ n ; } return $ k ; }
function isPossibleToZero ( $ a , $ n ) { $ even = 0 ; $ odd = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ i & 1 ) $ odd += $ a [ $ i ] ; else $ even += $ a [ $ i ] ; } return ( $ odd == $ even ) ; }
function isPossibleToZero ( $ a , $ n ) { $ num = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ num = $ num * 10 + $ a [ $ i ] ; return ( $ num % 11 == 0 ) ; }
function cosXSertiesSum ( $ x , $ n ) { global $ PI ; $ x = $ x * ( $ PI / 180.0 ) ; $ res = 1 ; $ sign = 1 ; $ fact = 1 ; $ pow = 1 ; for ( $ i = 1 ; $ i < 5 ; $ i ++ ) { $ sign = $ sign * -1 ; $ fact = $ fact * ( 2 * $ i - 1 ) * ( 2 * $ i ) ; $ pow = $ pow * $ x * $ x ; $ res = $ res + $ sign * $ pow / $ fact ; } return $ res ; }
function summingSeries ( $ n ) { return pow ( $ n , 2 ) ; }
function check ( $ N , $ D ) { $ temp = ( $ N * ( $ N + 1 ) ) / 2 + $ D ; return ( $ temp % 2 == 0 ) ; }
function findNumberOfDigits ( $ n , $ b ) { $ dig = ( int ) ( floor ( log ( $ n ) / log ( $ b ) ) + 1 ) ; echo ( " The ▁ Number ▁ of ▁ digits " . " ▁ of ▁ Number ▁ " . $ n . " ▁ in ▁ base ▁ " . $ b . " ▁ is ▁ " . $ dig ) ; }
function isValidNesbitt ( $ a , $ b , $ c ) { $ A = $ a / ( $ b + $ c ) ; $ B = $ b / ( $ a + $ c ) ; $ C = $ c / ( $ a + $ b ) ; $ inequality = $ A + $ B + $ C ; return ( $ inequality >= 1.5 ) ; }
function printFourSquares ( $ a ) { for ( $ i = 0 ; $ i * $ i <= $ a ; $ i ++ ) { for ( $ j = $ i ; $ j * $ j <= $ a ; $ j ++ ) { for ( $ k = $ j ; $ k * $ k <= $ a ; $ k ++ ) { for ( $ l = $ k ; $ l * $ l <= $ a ; $ l ++ ) { if ( $ i * $ i + $ j * $ j + $ k * $ k + $ l * $ l == $ a ) { echo $ a , " = " ▁ , ▁ $ i ▁ , ▁ " * " ▁ , $ i , STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL " + " ▁ , ▁ $ j ▁ , ▁ " * " ▁ , ▁ $ j ▁ , ▁ " + " echo $ k , " * " ▁ , ▁ $ k ▁ , ▁ " + " $ l , " * " , $ l , " STRNEWLINE " ; } } } } } }
function no_of_digit ( $ a , $ b ) { return ( ( int ) ( $ b * log10 ( $ a ) ) + 1 ) ; }
function find_sum_of_two_squares ( $ a , $ b ) { $ ab = $ a * $ b ; for ( $ i = 0 ; $ i * $ i <= $ ab ; $ i ++ ) { for ( $ j = $ i ; $ i * $ i + $ j * $ j <= $ ab ; $ j ++ ) { if ( $ i * $ i + $ j * $ j == $ ab ) echo $ i , " ^ 2 ▁ + ▁ " , $ j , " ^ 2 ▁ = ▁ " , $ ab , " STRNEWLINE " ; } } }
function check_euler_four_square_identity ( $ a , $ b , $ ab ) { $ s = 0 ; for ( $ i = 0 ; $ i * $ i <= $ ab ; $ i ++ ) { $ s = $ i * $ i ; for ( $ j = $ i ; $ j * $ j <= $ ab ; $ j ++ ) { $ s = $ j * $ j + $ i * $ i ; for ( $ k = $ j ; $ k * $ k <= $ ab ; $ k ++ ) { $ s = $ k * $ k + $ j * $ j + $ i * $ i ; for ( $ l = $ k ; $ l * $ l <= $ ab ; $ l ++ ) { $ s = $ l * $ l + $ k * $ k + $ j * $ j + $ i * $ i ; if ( $ s == $ ab ) { echo ( " i ▁ = ▁ " . $ i . " STRNEWLINE " ) ; echo ( " j ▁ = ▁ " . $ j . " STRNEWLINE " ) ; echo ( " k ▁ = ▁ " . $ k . " STRNEWLINE " ) ; echo ( " l ▁ = ▁ " . $ l . " STRNEWLINE " ) ; echo " " . " Product ▁ of ▁ " . $ a . " ▁ and ▁ " . $ b ; echo " ▁ can ▁ be ▁ written " . " ▁ as ▁ sum ▁ of ▁ squares ▁ of ▁ i , ▁ " . " j , ▁ k , ▁ l STRNEWLINE " ; echo $ ab . " ▁ = ▁ " ; echo $ i . " * " ▁ . ▁ $ i . ▁ " + " echo $ j . " * " . $ j . " ▁ + ▁ " ; echo $ k . " * " ▁ . ▁ $ k ▁ . ▁ " + " echo $ l . " * " . $ l . " STRNEWLINE " ; echo " STRNEWLINE " ; } } } } } }
function inversegrayCode ( $ n ) { $ inv = 0 ; for ( ; $ n ; $ n = $ n >> 1 ) $ inv ^= $ n ; return $ inv ; }
function firstDigit ( $ n ) { $ fact = 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { $ fact = $ fact * $ i ; while ( $ fact % 10 == 0 ) $ fact = $ fact / 10 ; } while ( $ fact >= 10 ) $ fact = $ fact / 10 ; return floor ( $ fact ) ; }
function possibleToReach ( $ a , $ b ) { $ c = ( $ a * $ b ) ; $ re1 = $ a / $ c ; $ re2 = $ b / $ c ; if ( ( $ re1 * $ re1 * $ re2 == $ a ) && ( $ re2 * $ re2 * $ re1 == $ b ) ) return 1 ; else return -1 ; }
function nthSquareCube ( $ n ) { return $ n * $ n * $ n * $ n * $ n * $ n ; }
function findS ( $ s ) { $ sum = 0 ; for ( $ n = 1 ; $ sum < $ s ; $ n ++ ) { $ sum += $ n * $ n * $ n ; if ( $ sum == $ s ) return $ n ; } return -1 ; }
function findKthGoodNo ( $ n ) { $ lastDig = $ n % 10 ; if ( $ lastDig >= 0 && $ lastDig <= 4 ) return $ n << 1 ; else return ( $ n << 1 ) + 1 ; }
function powerNumbers ( $ n ) { $ v = array ( ) ; for ( $ i = 2 ; $ i * $ i * $ i <= $ n ; $ i ++ ) { $ j = $ i * $ i ; while ( $ j * $ i <= $ n ) { $ j *= $ i ; $ s = sqrt ( $ j ) ; if ( $ s * $ s != $ j ) array_push ( $ v , $ j ) ; } } sort ( $ v ) ; $ uni = array_unique ( $ v ) ; for ( $ i = 0 ; $ i < count ( $ uni ) ; $ i ++ ) { $ key = array_search ( $ uni [ $ i ] , $ v ) ; unset ( $ v [ $ key ] ) ; } return count ( $ v ) + 3 + intval ( sqrt ( $ n ) ) ; }
function NicomachuTheorum_sum ( $ n ) { $ sum = 0 ; for ( $ k = 1 ; $ k <= $ n ; $ k ++ ) $ sum += $ k * $ k * $ k ; $ triNo = $ n * ( $ n + 1 ) / 2 ; if ( $ sum == $ triNo * $ triNo ) echo " Yes " ; else echo " No " ; }
function countDigits ( $ n ) { return intval ( $ n * log10 ( 2 ) + 1 ) ; }
function findBucketNo ( $ p ) { return ceil ( ( sqrt ( 8 * $ p + 1 ) - 1 ) / 2 ) ; }
function calculateProbability ( $ N ) { $ probability = $ N / ( $ N + 1 ) ; return $ probability ; }
function isUndulating ( $ n ) { if ( strlen ( $ n ) <= 2 ) return false ; for ( $ i = 2 ; $ i < strlen ( $ n ) ; $ i ++ ) if ( $ n [ $ i - 2 ] != $ n [ $ i ] ) false ; return true ; }
function findNth ( $ n ) { $ count = 0 ; for ( $ curr = 19 ; ; $ curr += 9 ) { $ sum = 0 ; for ( $ x = $ curr ; $ x > 0 ; $ x = ( int ) $ x / 10 ) $ sum = $ sum + $ x % 10 ; if ( $ sum == 10 ) $ count ++ ; if ( $ count == $ n ) return $ curr ; } return -1 ; }
function pythagoreanTriplet ( $ n ) { for ( $ i = 1 ; $ i <= $ n / 3 ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j <= $ n / 2 ; $ j ++ ) { $ k = $ n - $ i - $ j ; if ( $ i * $ i + $ j * $ j == $ k * $ k ) { echo $ i , " , ▁ " , $ j , " , ▁ " , $ k ; return ; } } } echo " No ▁ Triplet " ; }
function findSum ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) for ( $ j = $ i ; $ j <= $ n ; $ j ++ ) $ sum = $ sum + $ i * $ j ; return $ sum ; }
function findSum ( $ n ) { $ multiTerms = ( int ) ( $ n * ( $ n + 1 ) / 2 ) ; $ sum = $ multiTerms ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { $ multiTerms = $ multiTerms - ( $ i - 1 ) ; $ sum = $ sum + $ multiTerms * $ i ; } return $ sum ; }
function procal ( $ n ) { return ( 3.0 * $ n ) / ( 4.0 * ( $ n * $ n ) - 1 ) ; }
function testSomeNumbers ( $ limit , $ n ) { if ( $ n < 3 ) for ( $ a = 1 ; $ a <= $ limit ; $ a ++ ) for ( $ b = $ a ; $ b <= $ limit ; $ b ++ ) { $ pow_sum = pow ( $ a , $ n ) + pow ( $ b , $ n ) ; $ c = pow ( $ pow_sum , 1.0 / $ n ) ; $ c_pow = pow ( $ c , $ n ) ; if ( $ c_pow != $ pow_sum ) { echo " Count ▁ example ▁ found " ; return ; } } echo " No ▁ counter ▁ example ▁ within ▁ " . " given ▁ range ▁ and ▁ data " ; }
function series ( $ A , $ X , $ n ) { $ term = pow ( $ A , $ n ) ; echo $ term , " " ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ term = $ term * $ X * ( $ n - $ i + 1 ) / ( $ i * $ A ) ; echo $ term , " " ; } }
function fnMod ( $ n ) { if ( $ n % 5 == 1 ) return 4 ; else return 0 ; }
function totalSumDivisibleByNum ( $ n , $ number ) { $ firstnum = pow ( 10 , $ n - 1 ) ; $ lastnum = pow ( 10 , $ n ) ; $ sum = 0 ; for ( $ i = $ firstnum ; $ i < $ lastnum ; $ i ++ ) if ( $ i % $ number == 0 ) $ sum += $ i ; return $ sum ; }
function totalSumDivisibleByNum ( $ digit , $ number ) { $ firstnum = pow ( 10 , $ digit - 1 ) ; $ lastnum = pow ( 10 , $ digit ) ; $ firstnum = ( $ firstnum - $ firstnum % $ number ) + $ number ; $ lastnum = ( $ lastnum - $ lastnum % $ number ) ; $ count = ( ( $ lastnum - $ firstnum ) / $ number + 1 ) ; return ( ( $ lastnum + $ firstnum ) * $ count ) / 2 ; }
function numberofterm ( $ n , $ number ) { $ firstnum = pow ( 10 , $ n - 1 ) ; $ lastnum = pow ( 10 , $ n ) ; $ count = 0 ; for ( $ i = $ firstnum ; $ i < $ lastnum ; $ i ++ ) if ( $ i % $ number == 0 ) $ count ++ ; return $ count ; }
function sumofseries ( $ n ) { $ res = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ res += ( $ i ) * ( $ i + 1 ) * ( $ i + 2 ) ; return $ res ; }
function sumofseries ( $ n ) { return ( $ n * ( $ n + 1 ) * ( $ n + 2 ) * ( $ n + 3 ) / 4 ) ; }
function seiresSum ( $ n , $ a ) { $ res = 0 ; for ( $ i = 0 ; $ i < 2 * $ n ; $ i ++ ) { if ( $ i % 2 == 0 ) $ res += $ a [ $ i ] * $ a [ $ i ] ; else $ res -= $ a [ $ i ] * $ a [ $ i ] ; } return $ res ; }
function seiresSum ( $ n , $ a ) { return $ n * ( $ a [ 0 ] * $ a [ 0 ] - $ a [ 2 * $ n - 1 ] * $ a [ 2 * $ n - 1 ] ) / ( 2 * $ n - 1 ) ; }
function printGMeans ( $ A , $ B , $ N ) { $ R = pow ( ( $ B / $ A ) , 1.0 / ( $ N + 1 ) ) ; for ( $ i = 1 ; $ i <= $ N ; $ i ++ ) echo $ A * pow ( $ R , $ i ) , " ▁ " ; }
function isDivisible ( $ n ) { while ( intval ( $ n / 100 ) ) { $ last_digit = $ n % 10 ; $ n = intval ( $ n / 10 ) ; $ n += $ last_digit * 3 ; } return ( $ n % 29 == 0 ) ; }
function pronic_check ( $ n ) { $ x = floor ( sqrt ( $ n ) ) ; if ( $ x * ( $ x + 1 ) == $ n ) return true ; else return false ; }
function power ( $ n , $ r ) { $ count = 0 ; for ( $ i = $ r ; ( $ n / $ i ) >= 1 ; $ i = $ i * $ r ) $ count += $ n / $ i ; return $ count ; }
function isPrime ( $ p ) { $ checkNumber = pow ( 2 , $ p ) - 1 ; $ nextval = 4 % $ checkNumber ; for ( $ i = 1 ; $ i < $ p - 1 ; $ i ++ ) $ nextval = ( $ nextval * $ nextval - 2 ) % $ checkNumber ; return ( $ nextval == 0 ) ; }
function isPerfectSquare ( $ x ) { $ sr = sqrt ( $ x ) ; return ( ( $ sr - floor ( $ sr ) ) == 0 ) ; }
function printGP ( $ a , $ r , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ curr_term = $ a * pow ( $ r , $ i ) ; echo $ curr_term , " " ; } }
function Nth_of_AP ( $ a , $ d , $ N ) { return ( $ a + ( $ N - 1 ) * $ d ) ; }
function checkFibinnary ( $ n ) { $ prev_last = 0 ; while ( $ n ) { if ( ( $ n & 1 ) && $ prev_last ) return false ; $ prev_last = $ n & 1 ; $ n >>= 1 ; } return true ; }
function sumOfSeries ( $ n ) { return ( int ) ( 0.6172 * ( pow ( 10 , $ n ) - 1 ) - 0.55 * $ n ) ; }
function Nonagonal ( $ n ) { return $ n * ( 7 * $ n - 5 ) / 2 ; }
function Nonagonal ( $ n ) { for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { echo $ i * ( 7 * $ i - 5 ) / 2 ; echo " ▁ " ; } }
function seriesFunc ( $ n ) { $ sumSquare = ( $ n * ( $ n + 1 ) * ( 2 * $ n + 1 ) ) / 6 ; $ sumNatural = ( $ n * ( $ n + 1 ) / 2 ) ; return ( $ sumSquare + $ sumNatural + 1 ) ; }
function sum_series ( $ n ) { $ nSquare = $ n * $ n ; return $ nSquare * ( $ nSquare - 1 ) / 4 ; }
function day_of_the_week ( $ y , $ m , $ d ) { $ t = array ( 0 , 3 , 2 , 5 , 0 , 3 , 5 , 1 , 4 , 6 , 2 , 4 ) ; if ( $ m < 3 ) $ y -= 1 ; return ( ( $ y + $ y / 4 - $ y / 100 + $ y / 400 + $ t [ $ m - 1 ] + $ d ) % 7 ) ; }
function Div_by_8 ( $ n ) { return ( ( ( $ n >> 3 ) << 3 ) == $ n ) ; }
function divisibleBy20 ( $ num ) { $ lastTwoDigits = intval ( substr ( $ num , ( strlen ( $ num ) - 2 ) , 2 ) ) ; return ( ( $ lastTwoDigits % 5 == 0 ) && ( $ lastTwoDigits % 4 == 0 ) ) ; }
function isPrime ( $ n , $ i = 2 ) { if ( $ n <= 2 ) return ( $ n == 2 ) ? true : false ; if ( $ n % $ i == 0 ) return false ; if ( $ i * $ i > $ n ) return true ; return isPrime ( $ n , $ i + 1 ) ; }
function subsetCount ( $ arr , $ n ) { return 1 << $ n ; }
function isSquareFree ( $ n ) { if ( $ n % 2 == 0 ) $ n = $ n / 2 ; if ( $ n % 2 == 0 ) return false ; for ( $ i = 3 ; $ i <= sqrt ( $ n ) ; $ i = $ i + 2 ) { if ( $ n % $ i == 0 ) { $ n = $ n / $ i ; if ( $ n % $ i == 0 ) return false ; } } return true ; }
function findArea ( $ d ) { return ( $ d * $ d ) / 2 ; }
function sumOfSeries ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ sum = $ sum + ( 2 * $ i - 1 ) * ( 2 * $ i - 1 ) ; return $ sum ; }
function sumOfSeries ( $ n ) { return ( $ n * ( 2 * $ n - 1 ) * ( 2 * $ n + 1 ) ) / 3 ; }
function isDvisibleBy12 ( $ num ) { if ( strlen ( $ num ) >= 3 ) { $ d1 = ( int ) $ num [ strlen ( $ num ) - 1 ] ; if ( $ d1 % 2 != 0 ) return ( 0 ) ; $ d2 = ( int ) $ num [ strlen ( $ num ) - 2 ] ; $ sum = 0 ; for ( $ i = 0 ; $ i < strlen ( $ num ) ; $ i ++ ) $ sum += $ num [ $ i ] ; return ( $ sum % 3 == 0 && ( $ d2 * 10 + $ d1 ) % 4 == 0 ) ; } else { $ number = stoi ( $ num ) ; return ( $ number % 12 == 0 ) ; } }
function StepstoReachTarget ( $ target ) { $ target = abs ( $ target ) ; $ n = ceil ( ( -1.0 + sqrt ( 1 + 8.0 * $ target ) ) / 2 ) ; $ sum = $ n * ( $ n + 1 ) / 2 ; if ( $ sum == $ target ) return $ n ; $ d = $ sum - $ target ; if ( ( $ d & 1 ) == 0 ) return n ; else return $ n + ( ( $ n & 1 ) ? 2 : 1 ) ; }
function Calculate_GST ( $ org_cost , $ N_price ) { return ( ( ( $ N_price - $ org_cost ) * 100 ) / $ org_cost ) ; }
function avg_of_even_num ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ sum += 2 * $ i ; return $ sum / $ n ; }
function avg_of_even_num ( $ n ) { return $ n + 1 ; }
function avg_of_odd_num ( $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum += ( 2 * $ i + 1 ) ; return $ sum / $ n ; }
function avg_of_odd_num ( $ n ) { return $ n ; }
function seriesSum ( $ n ) { $ i = 1 ; $ res = 0.0 ; $ sign = true ; while ( $ n > 0 ) { $ n -- ; if ( $ sign ) { $ sign = ! $ sign ; $ res = $ res + ( double ) ++ $ i / ++ $ i ; } else { $ sign = ! $ sign ; $ res = $ res - ( double ) ++ $ i / ++ $ i ; } } return $ res ; }
function countSymmetric ( $ n ) { if ( $ n == 0 ) return 1 ; return 1 << ( ( $ n * ( $ n + 1 ) ) / 2 ) ; }
function SternSequenceFunc ( & $ BrocotSequence , $ n ) { for ( $ i = 1 ; count ( $ BrocotSequence ) < $ n ; $ i ++ ) { $ considered_element = $ BrocotSequence [ $ i ] ; $ precedent = $ BrocotSequence [ $ i - 1 ] ; array_push ( $ BrocotSequence , $ considered_element + $ precedent ) ; array_push ( $ BrocotSequence , $ considered_element ) ; } for ( $ i = 0 ; $ i < 15 ; ++ $ i ) echo ( $ BrocotSequence [ $ i ] . " ▁ " ) ; }
function centeredNonagonal ( $ n ) { return ( 3 * $ n - 2 ) * ( 3 * $ n - 1 ) / 2 ; }
function printAP ( $ a , $ d , $ n ) { $ curr_term ; $ curr_term = a ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { echo ( $ curr_term . " " ) ; $ curr_term += $ d ; } }
function isRatioPossible ( $ lowCost , $ upCost , $ lowQuant , $ upQuant , $ r ) { for ( $ i = $ lowQuant ; $ i <= $ upQuant ; $ i ++ ) { $ ans = $ i * $ r ; if ( $ lowCost <= $ ans && $ ans <= $ upCost ) return true ; } return false ; }
function findNumbers ( $ n , $ d ) { for ( $ i = 0 ; $ i < $ n - 2 ; $ i ++ ) echo "1" , " ▁ " ; echo "2" , " ▁ " ; echo $ n + $ d , " STRNEWLINE " ; }
function centeredHexagonalNumber ( $ n ) { return 3 * $ n * ( $ n - 1 ) + 1 ; }
function oddNumSum ( $ n ) { return ( $ n * ( 2 * $ n + 1 ) * ( 24 * $ n * $ n * $ n - 12 * $ n * $ n - 14 * $ n + 7 ) ) / 15 ; }
function isTrimorphic ( $ N ) { $ cube = $ N * $ N * $ N ; while ( $ N > 0 ) { if ( $ N % 10 != $ cube % 10 ) return -1 ; $ N /= 10 ; $ cube /= 10 ; } return 1 ; }
function reachTarget ( $ target ) { $ target = abs ( $ target ) ; $ sum = 0 ; $ step = 0 ; while ( $ sum < $ target or ( $ sum - $ target ) % 2 != 0 ) { $ step ++ ; $ sum += $ step ; } return $ step ; }
function averageEven ( $ n ) { if ( $ n % 2 != 0 ) { echo ( " Invalid ▁ Input " ) ; return -1 ; } return ( $ n + 2 ) / 2 ; }
function fifthPowerSum ( $ n ) { return ( ( 2 * $ n * $ n * $ n * $ n * $ n * $ n ) + ( 6 * $ n * $ n * $ n * $ n * $ n ) + ( 5 * $ n * $ n * $ n * $ n ) - ( $ n * $ n ) ) / 12 ; }
function maxFraction ( $ first , $ sec ) { $ a = $ first [ 0 ] ; $ b = $ first [ 1 ] ; $ c = $ sec [ 0 ] ; $ d = $ sec [ 1 ] ; $ Y = $ a * $ d - $ b * $ c ; return ( $ Y ) ? $ first : $ sec ; }
function find_distance ( $ n ) { return $ n * ( ( 3 * $ n ) + 7 ) ; }
function squareSum ( $ n ) { return $ n * ( 4 * $ n * $ n - 1 ) / 3 ; }
function squareSum ( $ n ) { return 2 * $ n * ( $ n + 1 ) * ( 2 * $ n + 1 ) / 3 ; }
function kthdigit ( $ a , $ b , $ k ) { $ p = pow ( $ a , $ b ) ; $ count = 0 ; while ( $ p > 0 and $ count < $ k ) { $ rem = $ p % 10 ; $ count ++ ; if ( $ count == $ k ) return $ rem ; $ p = $ p / 10 ; } return 0 ; }
function isPentagonal ( int $ N ) { $ i = 1 ; $ M ; do { $ M = ( 3 * $ i * $ i - $ i ) / 2 ; $ i += 1 ; } while ( $ M < $ N ) ; return ( $ M == $ N ) ; }
function fourthPowerSum ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ sum = $ sum + ( $ i * $ i * $ i * $ i ) ; return $ sum ; }
function fourthPowerSum ( $ n ) { return ( ( 6 * $ n * $ n * $ n * $ n * $ n ) + ( 15 * $ n * $ n * $ n * $ n ) + ( 10 * $ n * $ n * $ n ) - $ n ) / 30 ; }
function unitDigitXRaisedY ( $ x , $ y ) { $ res = 1 ; for ( $ i = 0 ; $ i < $ y ; $ i ++ ) $ res = ( $ res * $ x ) % 10 ; return $ res ; }
function unitnumber ( $ x , $ y ) { $ x = $ x % 10 ; if ( $ y != 0 ) $ y = $ y % 4 + 4 ; return ( ( ( int ) ( pow ( $ x , $ y ) ) ) % 10 ) ; }
function aliquotSum ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) if ( $ n % $ i == 0 ) $ sum += $ i ; return $ sum ; }
function findDivisor ( $ x , $ y ) { if ( $ x == $ y ) return $ y ; return 2 ; }
function AvgofSquareN ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ sum += ( $ i * $ i ) ; return $ sum / $ n ; }
function AvgofSquareN ( $ n ) { return ( ( $ n + 1 ) * ( 2 * $ n + 1 ) ) / 6 ; }
function sumofFactors ( $ n ) { if ( $ n % 2 != 0 ) return 0 ; $ res = 1 ; for ( $ i = 2 ; $ i <= sqrt ( $ n ) ; $ i ++ ) { $ count = 0 ; $ curr_sum = 1 ; $ curr_term = 1 ; while ( $ n % $ i == 0 ) { $ count ++ ; $ n = floor ( $ n / $ i ) ; if ( $ i == 2 && $ count == 1 ) $ curr_sum = 0 ; $ curr_term *= $ i ; $ curr_sum += $ curr_term ; } $ res *= $ curr_sum ; } if ( $ n >= 2 ) $ res *= ( 1 + $ n ) ; return $ res ; }
function maxArea ( $ A , $ len ) { $ l = 0 ; $ r = $ len - 1 ; $ area = 0 ; while ( $ l < $ r ) { $ area = max ( $ area , min ( $ A [ $ l ] , $ A [ $ r ] ) * ( $ r - $ l ) ) ; if ( $ A [ $ l ] < $ A [ $ r ] ) $ l += 1 ; else $ r -= 1 ; } return $ area ; }
function sumofoddFactors ( $ n ) { $ res = 1 ; while ( $ n % 2 == 0 ) $ n = $ n / 2 ; for ( $ i = 3 ; $ i <= sqrt ( $ n ) ; $ i ++ ) { $ count = 0 ; $ curr_sum = 1 ; $ curr_term = 1 ; while ( $ n % $ i == 0 ) { $ count ++ ; $ n = $ n / $ i ; $ curr_term *= $ i ; $ curr_sum += $ curr_term ; } $ res *= $ curr_sum ; } if ( $ n >= 2 ) $ res *= ( 1 + $ n ) ; return $ res ; }
function countSolutions ( $ n , $ val ) { $ total = 0 ; if ( $ n == 1 && $ val >= 0 ) return 1 ; for ( $ i = 0 ; $ i <= $ val ; $ i ++ ) { $ total += countSolutions ( $ n - 1 , $ val - $ i ) ; } return $ total ; }
function sumOfSeries ( $ n ) { return 0.0246 * ( pow ( 10 , $ n ) - 1 - ( 9 * $ n ) ) ; }
function sumofNterm ( $ a , $ d , $ b , $ r , $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ sum += ( ( $ a + ( $ i - 1 ) * $ d ) * ( $ b * pow ( $ r , $ i - 1 ) ) ) ; return $ sum ; }
function sumOfTheSeries ( $ n ) { $ sum = 0.0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ sum += 1.0 / ( $ i * ( $ i + 1 ) ) ; return $ sum ; }
function sum ( $ n ) { $ root = intval ( sqrt ( $ n ) ) ; $ ans = 0 ; for ( $ i = 1 ; $ i <= $ root ; $ i ++ ) $ ans += intval ( $ n / $ i ) ; $ ans = ( 2 * $ ans ) - ( $ root * $ root ) ; return $ ans ; }
function sumOfTheSeries ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ k = 2 ; for ( $ j = 1 ; $ j <= $ i ; $ j ++ ) { $ sum += $ k ; $ k += 2 ; } } return $ sum ; }
function sumOfTheSeries ( $ n ) { $ sum_n = ( $ n * ( $ n + 1 ) / 2 ) ; $ sum_sq_n = ( $ n * ( $ n + 1 ) / 2 ) * ( 2 * $ n + 1 ) / 3 ; return ( $ sum_n + $ sum_sq_n ) ; }
function sumofsquare ( $ n ) { $ i ; $ j ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 0 ; $ j <= min ( $ i , $ n ) ; $ j ++ ) { if ( $ j == 0 $ j == $ i ) $ C [ $ i ] [ $ j ] = 1 ; else $ C [ $ i ] [ $ j ] = $ C [ $ i - 1 ] [ $ j - 1 ] + $ C [ $ i - 1 ] [ $ j ] ; } } $ sum = 0 ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) $ sum += ( $ C [ $ n ] [ $ i ] * $ C [ $ n ] [ $ i ] ) ; return $ sum ; }
function sumOfSeries ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) for ( $ j = 1 ; $ j <= $ i ; $ j ++ ) $ sum = $ sum + $ i ; return $ sum ; }
function sumOfSeries ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ sum = $ sum + $ i * $ i ; return $ sum ; }
function sumOfSeries ( $ n ) { return ( $ n * ( $ n + 1 ) * ( 2 * $ n + 1 ) ) / 6 ; }
function evenSum ( $ n ) { $ C = array ( array ( ) ) ; $ i ; $ j ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) { for ( $ j = 0 ; $ j <= min ( $ i , $ n ) ; $ j ++ ) { if ( $ j == 0 or $ j == $ i ) $ C [ $ i ] [ $ j ] = 1 ; else $ C [ $ i ] [ $ j ] = $ C [ $ i - 1 ] [ $ j - 1 ] + $ C [ $ i - 1 ] [ $ j ] ; } } $ sum = 0 ; for ( $ i = 0 ; $ i <= $ n ; $ i += 2 ) $ sum += $ C [ $ n ] [ $ i ] ; return $ sum ; }
function evenbinomialCoeffSum ( $ n ) { return ( 1 << ( $ n - 1 ) ) ; }
function Series ( $ n ) { $ i ; $ sums = 0.0 ; $ ser ; for ( $ i = 1 ; $ i <= $ n ; ++ $ i ) { $ ser = 1 / pow ( $ i , $ i ) ; $ sums += $ ser ; } return $ sums ; }
function sumOfSeries ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ sum = $ sum + $ i * ( $ i + 1 ) * ( $ i + 2 ) ; return $ sum ; }
function Series ( $ n ) { $ i ; $ sums = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ sums += ( $ i * $ i ) ; return $ sums ; }
function Series ( $ x , $ n ) { $ sum = 1 ; $ term = 1 ; $ fct = 1 ; $ p = 1 ; $ multi = 1 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ fct = $ fct * $ multi * ( $ multi + 1 ) ; $ p = $ p * $ x * $ x ; $ term = ( -1 ) * $ term ; $ multi += 2 ; $ sum = $ sum + ( $ term * $ p ) / $ fct ; } return $ sum ; }
function fib ( $ n ) { global $ PHI ; $ f = array ( 0 , 1 , 1 , 2 , 3 , 5 ) ; if ( $ n < 6 ) return $ f [ $ n ] ; $ t = 5 ; $ fn = 5 ; while ( $ t < $ n ) { $ fn = round ( $ fn * $ PHI ) ; $ t ++ ; } return $ fn ; }
function first ( $ a , $ b , $ c ) { $ a %= $ b ; for ( $ i = 1 ; $ i <= $ b ; $ i ++ ) { $ a = $ a * 10 ; if ( $ a / $ b == $ c ) return $ i ; $ a %= $ b ; } return -1 ; }
function timeToMeet ( $ s , $ v ) { $ V = 3 * $ v / 2 ; $ time = $ s / $ V ; echo $ time ; }
function sumOfTheSeries ( $ n ) { return ( $ n * ( $ n + 1 ) / 2 ) * ( 2 * $ n + 1 ) / 3 ; }
function checksum ( $ n ) { if ( $ n % 3 == 0 ) echo $ n / 3 - 1 , " ▁ " , $ n / 3 , " ▁ " , $ n / 3 + 1 ; else echo " - 1" ; }
function solution ( $ a , $ b , $ n ) { for ( $ i = 0 ; $ i * $ a <= $ n ; $ i ++ ) { if ( ( $ n - ( $ i * $ a ) ) % $ b == 0 ) { echo " x = " ▁ , ▁ $ i ▁ , ▁ " , y = " ( $ n - ( $ i * $ a ) ) / $ b ; return ; } } echo " No ▁ solution " ; }
function divisorSum ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; ++ $ i ) { for ( $ j = 1 ; $ j * $ j <= $ i ; ++ $ j ) { if ( $ i % $ j == 0 ) { if ( $ i / $ j == $ j ) $ sum += $ j ; else $ sum += $ j + $ i / $ j ; } } } return $ sum ; }
function divisorSum ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; ++ $ i ) $ sum += floor ( $ n / $ i ) * $ i ; return $ sum ; }
function sumOfSeries ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) for ( $ j = 1 ; $ j <= $ i ; $ j ++ ) $ sum += $ j ; return $ sum ; }
function printbinomial ( $ max ) { for ( $ m = 0 ; $ m <= $ max ; $ m ++ ) { echo $ m ; $ binom = 1 ; for ( $ x = 0 ; $ x <= $ m ; $ x ++ ) { if ( $ m != 0 && $ x != 0 ) $ binom = $ binom * ( $ m - $ x + 1 ) / $ x ; echo " ▁ " , $ binom , " ▁ " ; } echo " STRNEWLINE " ; } }
function binomialCoeffSum ( $ n ) { return ( 1 << $ n ) ; }
function evenPowerSum ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ j = 2 * $ i ; $ sum = $ sum + ( $ j * $ j * $ j * $ j ) ; } return $ sum ; }
function evenPowerSum ( $ n ) { return ( 8 * $ n * ( $ n + 1 ) * ( 2 * $ n + 1 ) * ( 3 * $ n * $ n + 3 * $ n - 1 ) ) / 15 ; }
function quadrant ( $ x , $ y ) { if ( $ x > 0 and $ y > 0 ) echo ( " lies ▁ in ▁ First ▁ quadrant " ) ; else if ( $ x < 0 and $ y > 0 ) echo ( " lies ▁ in ▁ Second ▁ quadrant " ) ; else if ( $ x < 0 and $ y < 0 ) echo ( " lies ▁ in ▁ Third ▁ quadrant " ) ; else if ( $ x > 0 and $ y < 0 ) echo ( " lies ▁ in ▁ Fourth ▁ quadrant " ) ; else if ( $ x == 0 and $ y > 0 ) echo ( " lies ▁ at ▁ positive ▁ y ▁ axis " ) ; else if ( $ x == 0 and $ y < 0 ) echo ( " lies ▁ at ▁ negative ▁ y ▁ axis " ) ; else if ( $ y == 0 and $ x < 0 ) echo ( " lies ▁ at ▁ negative ▁ x ▁ axis " ) ; else if ( $ y == 0 and $ x > 0 ) echo ( " lies ▁ at ▁ positive ▁ x ▁ axis " ) ; else echo ( " lies ▁ at ▁ origin " ) ; }
function squaresum ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ sum += ( $ i * $ i ) ; return $ sum ; }
function squaresum ( $ n ) { return ( $ n * ( $ n + 1 ) / 2 ) * ( 2 * $ n + 1 ) / 3 ; }
function counLastDigitK ( $ low , $ high , $ k ) { $ count = 0 ; for ( $ i = $ low ; $ i <= $ high ; $ i ++ ) if ( $ i % 10 == $ k ) $ count ++ ; return $ count ; }
function polite ( $ n ) { $ n += 1 ; $ base = 2 ; return $ n + ( log ( ( $ n + ( log ( $ n ) / log ( $ base ) ) ) ) ) / log ( $ base ) ; }
function numberOfTriangles ( $ n ) { $ ans = 2 * ( pow ( 3 , $ n ) ) - 1 ; return $ ans ; }
function motzkin ( $ n ) { if ( $ n == 0 $ n == 1 ) return 1 ; return ( ( 2 * $ n + 1 ) * motzkin ( $ n - 1 ) + ( 3 * $ n - 3 ) * motzkin ( $ n - 2 ) ) / ( $ n + 2 ) ; }
function sumOfSeries ( $ n ) { return ( 0.666 ) * ( 1 - 1 / pow ( 10 , $ n ) ) ; }
function solve ( $ low , $ high , $ T ) { while ( $ low <= $ high ) { $ mid = ( $ low + $ high ) / 2 ; if ( ( $ mid * ( $ mid + 1 ) ) == $ T ) return $ mid ; if ( $ mid > 0 && ( $ mid * ( $ mid + 1 ) ) > $ T && ( $ mid * ( $ mid - 1 ) ) <= $ T ) return $ mid - 1 ; if ( ( $ mid * ( $ mid + 1 ) ) > $ T ) $ high = $ mid - 1 ; else $ low = $ mid + 1 ; } return -1 ; }
function nthSHN ( $ n , $ dp ) { if ( $ n == 1 $ n == 2 ) return $ dp [ $ n ] = 1 ; if ( $ dp [ $ n ] != -1 ) return $ dp [ $ n ] ; return $ dp [ $ n ] = ( ( 6 * $ n - 9 ) * nthSHN ( $ n - 1 , $ dp ) - ( $ n - 3 ) * nthSHN ( $ n - 2 , $ dp ) ) / $ n ; }
function summation ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ sum += ( $ i * $ i ) ; return $ sum ; }
function isOverflow ( $ a , $ b ) { if ( $ a == 0 $ b == 0 ) return false ; $ result = $ a * $ b ; if ( $ a == ( int ) $ result / $ b ) return false ; else return true ; }
function evenSum ( $ n ) { $ curr = 2 ; $ sum = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ sum += $ curr ; $ curr += 2 ; } return $ sum ; }
function evenSum ( $ n ) { return ( $ n * ( $ n + 1 ) ) ; }
function kthgroupsum ( $ k ) { $ cur = ( $ k * ( $ k - 1 ) ) + 1 ; $ sum = 0 ; while ( $ k -- ) { $ sum += $ cur ; $ cur += 2 ; } return $ sum ; }
function kthgroupsum ( $ k ) { return $ k * $ k * $ k ; }
function oddSum ( $ n ) { $ sum = 0 ; $ curr = 1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sum += $ curr ; $ curr += 2 ; } return $ sum ; }
function oddSum ( $ n ) { return ( $ n * $ n ) ; }
function Convert ( $ radian ) { $ pi = 3.14159 ; return ( $ radian * ( 180 / $ pi ) ) ; }
function nthTerm ( $ n ) { return ( $ n * $ n ) + ( $ n * $ n * $ n ) ; }
function printKPFNums ( $ A , $ B , $ K ) { $ prime = array_fill ( true , $ B + 1 , NULL ) ; $ p_factors = array_fill ( 0 , $ B + 1 , NULL ) ; for ( $ p = 2 ; $ p <= $ B ; $ p ++ ) if ( $ p_factors [ $ p ] == 0 ) for ( $ i = $ p ; $ i <= $ B ; $ i += $ p ) $ p_factors [ $ i ] ++ ; for ( $ i = $ A ; $ i <= $ B ; $ i ++ ) if ( $ p_factors [ $ i ] == $ K ) echo $ i . " " ; }
function distance ( $ x1 , $ y1 , $ x2 , $ y2 ) { return sqrt ( pow ( $ x2 - $ x1 , 2 ) + pow ( $ y2 - $ y1 , 2 ) * 1.0 ) ; }
function printXYZ ( $ n ) { if ( $ n == 1 ) echo - 1 ; else echo " x ▁ is ▁ " , $ n , " STRNEWLINE y ▁ is ▁ " , $ n + 1 , " STRNEWLINE z ▁ is ▁ " , $ n * ( $ n + 1 ) ; }
function seriesSum ( $ n ) { return ( $ n * ( $ n + 1 ) * ( $ n + 2 ) ) / 6 ; }
function term ( $ n ) { $ ans = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ ans += $ i ; return $ ans ; }
function term ( $ n ) { return $ n * ( $ n + 1 ) / 2 ; }
function avgOfFirstN ( $ n ) { return ( float ) ( 1 + $ n ) / 2 ; }
function summation ( $ n ) { $ sum ; $ sum = ( pow ( 10 , $ n + 1 ) - 10 - ( 9 * $ n ) ) / 81 ; return $ sum ; }
function sum ( $ x , $ n ) { $ i ; $ total = 1.0 ; $ multi = $ x ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ total = $ total + $ multi / $ i ; $ multi = $ multi * $ x ; } return $ total ; }
function term ( $ n ) { $ x = ( ( ( 1 ) + ( double ) sqrt ( 1 + ( 8 * $ n ) ) ) / 2 ) ; return $ x ; }
function isMember ( $ a , $ d , $ x ) { if ( $ d == 0 ) return ( $ x == $ a ) ; return ( ( $ x - $ a ) % $ d == 0 && ( $ x - $ a ) / $ d >= 0 ) ; }
function compute ( $ a , $ b ) { $ AM ; $ GM ; $ HM ; $ AM = ( $ a + $ b ) / 2 ; $ GM = sqrt ( $ a * $ b ) ; $ HM = ( $ GM * $ GM ) / $ AM ; return $ HM ; }
function minOp ( $ num ) { $ count = 0 ; while ( $ num ) { $ rem = intval ( $ num % 10 ) ; if ( ! ( $ rem == 3 $ rem == 8 ) ) $ count ++ ; $ num = intval ( $ num / 10 ) ; } return $ count ; }
function sumSquare ( int $ n ) { for ( $ i = 1 ; $ i * $ i <= $ n ; $ i ++ ) for ( $ j = 1 ; $ j * $ j <= $ n ; $ j ++ ) if ( $ i * $ i + $ j * $ j == $ n ) { echo $ i , " ^ 2 ▁ + ▁ " , $ j , " ^ 2" ; return true ; } return false ; }
function judgeSquareSum ( $ n ) { for ( $ i = 2 ; $ i * $ i <= $ n ; $ i ++ ) { $ count = 0 ; if ( $ n % $ i == 0 ) { while ( $ n % $ i == 0 ) { $ count ++ ; $ n = ( int ) $ n / $ i ; } if ( $ i % 4 == 3 && $ count % 2 != 0 ) return false ; } } return $ n % 4 != 3 ; }
function findK ( $ n , $ k ) { $ a ; $ index = 0 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) if ( $ i % 2 == 1 ) $ a [ $ index ++ ] = $ i ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) if ( $ i % 2 == 0 ) $ a [ $ index ++ ] = $ i ; return ( $ a [ $ k - 1 ] ) ; }
function sum ( $ L , $ R ) { $ p = intval ( $ R / 6 ) ; $ q = intval ( ( $ L - 1 ) / 6 ) ; $ sumR = intval ( 3 * ( $ p * ( $ p + 1 ) ) ) ; $ sumL = intval ( ( $ q * ( $ q + 1 ) ) * 3 ) ; return $ sumR - $ sumL ; }
function max_area ( $ n , $ m , $ k ) { if ( $ k > ( $ n + $ m - 2 ) ) echo " Not ▁ possible " , " STRNEWLINE " ; else { $ result ; if ( $ k < max ( $ m , $ n ) - 1 ) { $ result = max ( $ m * ( $ n / ( $ k + 1 ) ) , $ n * ( $ m / ( $ k + 1 ) ) ) ; } else { $ result = max ( $ m / ( $ k - $ n + 2 ) , $ n / ( $ k - $ m + 2 ) ) ; } echo $ result , " STRNEWLINE " ; } }
function countDigitOne ( $ n ) { $ countr = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ str = strval ( $ i ) ; $ countr += substr_count ( $ str , '1' ) ; } return $ countr ; }
function countDigitOne ( $ n ) { $ countr = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i *= 10 ) { $ divider = $ i * 10 ; $ countr += ( int ) ( $ n / $ divider ) * $ i + min ( max ( $ n % $ divider - $ i + 1 , 0 ) , $ i ) ; } return $ countr ; }
function asPowerSum ( $ w , $ m ) { while ( $ m ) { if ( ( $ m - 1 ) % $ w == 0 ) $ m = ( $ m - 1 ) / $ w ; else if ( ( $ m + 1 ) % $ w == 0 ) $ m = ( $ m + 1 ) / $ w ; else if ( $ m % $ w == 0 ) $ m = $ m / $ w ; else } return ( $ m == 0 ) ; }
function divisible ( $ num ) { $ n = strlen ( $ num ) ; $ sum = ( $ num ) ; ( $ num ) ; 0 - '0' ; if ( $ sum % 3 == 0 ) return 0 ; if ( $ n == 1 ) return -1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ sum % 3 == ( $ num [ $ i ] - '0' ) % 3 ) return 1 ; if ( $ n == 2 ) return -1 ; return 2 ; }
function calculate ( $ n , $ power ) { $ sum = 0 ; $ bp = ( int ) pow ( $ n , $ power ) ; while ( $ bp != 0 ) { $ d = $ bp % 10 ; $ sum += $ d ; $ bp /= 10 ; } return $ sum ; }
function coutSubSeq ( $ A , $ N , $ M ) { $ sum = 0 ; $ ans = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ N ; $ j ++ ) { for ( $ k = $ j + 1 ; $ k < $ N ; $ k ++ ) { $ sum = $ A [ $ i ] + $ A [ $ j ] + $ A [ $ k ] ; if ( $ sum % $ M == 0 ) $ ans ++ ; } } } return $ ans ; }
function findTerm ( $ n ) { if ( $ n == 1 ) return $ n ; else { $ term = 7 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) $ term = $ term * 2 + ( $ i - 1 ) ; return $ term ; } }
function findNumber ( $ n ) { $ n -- ; $ i = 1 ; while ( $ n >= 0 ) { $ n -= $ i ; ++ $ i ; } return ( $ n + $ i ) ; }
function findNumber ( $ n ) { $ x = floor ( ( -1 + sqrt ( 1 + 8 * $ n - 8 ) ) / 2 ) ; $ base = ( $ x * ( $ x + 1 ) ) / 2 + 1 ; return $ n - $ base + 1 ; }
function correlationCoefficient ( $ X , $ Y , $ n ) { $ sum_X = 0 ; $ sum_Y = 0 ; $ sum_XY = 0 ; $ squareSum_X = 0 ; $ squareSum_Y = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sum_X = $ sum_X + $ X [ $ i ] ; $ sum_Y = $ sum_Y + $ Y [ $ i ] ; $ sum_XY = $ sum_XY + $ X [ $ i ] * $ Y [ $ i ] ; $ squareSum_X = $ squareSum_X + $ X [ $ i ] * $ X [ $ i ] ; $ squareSum_Y = $ squareSum_Y + $ Y [ $ i ] * $ Y [ $ i ] ; } $ corr = ( float ) ( $ n * $ sum_XY - $ sum_X * $ sum_Y ) / sqrt ( ( $ n * $ squareSum_X - $ sum_X * $ sum_X ) * ( $ n * $ squareSum_Y - $ sum_Y * $ sum_Y ) ) ; return $ corr ; }
function result ( $ n , $ k , $ t ) { if ( $ t <= $ k ) echo t ; else if ( $ t <= $ n ) echo k ; else { $ temp = $ t - $ n ; $ temp = $ k - $ temp ; echo $ temp ; } }
function weightedMean ( $ X , $ W , $ n ) { $ sum = 0 ; $ numWeight = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ numWeight = $ numWeight + $ X [ $ i ] * $ W [ $ i ] ; $ sum = $ sum + $ W [ $ i ] ; } return ( float ) ( $ numWeight / $ sum ) ; }
function weightedMean ( $ n ) { return ( 2 * $ n + 1 ) / 3 ; }
function series ( $ n ) { return ( 8 * $ n * $ n ) + 1 ; }
function gcd ( $ a , $ b ) { if ( $ a < $ b ) return gcd ( $ b , $ a ) ; if ( abs ( $ b ) < 0.001 ) return $ a ; else return ( gcd ( $ b , $ a - floor ( $ a / $ b ) * $ b ) ) ; }
function harmonicMean ( $ arr , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum = $ sum + ( float ) ( 1 / $ arr [ $ i ] ) ; return ( float ) ( $ n / $ sum ) ; }
function harmonicMean ( $ arr , $ freq , $ n ) { $ sum = 0 ; $ frequency_sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sum = $ sum + ( float ) ( $ freq [ $ i ] / $ arr [ $ i ] ) ; $ frequency_sum = $ frequency_sum + $ freq [ $ i ] ; } return ( $ frequency_sum / $ sum ) ; }
function calculate ( $ a , $ b , $ n , $ m ) { $ mul = 1 ; for ( $ i = 0 ; $ i < $ m ; $ i ++ ) if ( $ b [ $ i ] != 0 ) $ mul = $ mul * $ b [ $ i ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ x = floor ( $ a [ $ i ] / $ mul ) ; echo $ x , " " ; } }
function calculate_sum ( $ a , $ N ) { $ m = $ N / $ a ; $ sum = $ m * ( $ m + 1 ) / 2 ; $ ans = $ a * $ sum ; return $ ans ; }
function p_rint ( $ n ) { echo floor ( $ n + $ n / 2 ) , " STRNEWLINE " ; for ( $ i = 2 ; $ i <= $ n ; $ i += 2 ) echo $ i , " ▁ " ; for ( $ i = 1 ; $ i <= $ n ; $ i += 2 ) echo $ i , " ▁ " ; for ( $ i = 2 ; $ i <= $ n ; $ i += 2 ) echo $ i , " ▁ " ; }
function gcdMax ( $ a , $ b , $ n , $ N ) { $ cnt = array_fill ( 0 , $ N , 0 ) ; $ first = array_fill ( 0 , $ N , 0 ) ; $ second = array_fill ( 0 , $ N , 0 ) ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) $ cnt [ $ a [ $ i ] ] = 1 ; for ( $ i = 1 ; $ i < $ N ; ++ $ i ) for ( $ j = $ i ; $ j < $ N ; $ j += $ i ) if ( $ cnt [ $ j ] ) $ first [ $ i ] = max ( $ first [ $ i ] , $ j ) ; $ cnt = array_fill ( 0 , $ N , 0 ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ cnt [ $ b [ $ i ] ] = 1 ; for ( $ i = 1 ; $ i < $ N ; $ i ++ ) for ( $ j = $ i ; $ j < $ N ; $ j += $ i ) if ( $ cnt [ $ j ] ) $ second [ $ i ] = max ( $ second [ $ i ] , $ j ) ; $ x = $ N - 1 ; for ( ; $ x >= 0 ; $ x -- ) if ( $ first [ $ x ] && $ second [ $ x ] ) break ; echo $ first [ $ x ] . " ▁ " . $ second [ $ x ] . " STRNEWLINE " ; }
function factorial ( $ n ) { return ( $ n == 1 $ n == 0 ) ? 1 : $ n * factorial ( $ n - 1 ) ; }
function ispowerof2 ( $ num ) { if ( ( $ num & ( $ num - 1 ) ) == 0 ) return 1 ; return 0 ; }
function isWoodall ( $ x ) { if ( $ x % 2 == 0 ) return false ; if ( $ x == 1 ) return true ; $ x ++ ; $ p = 0 ; while ( $ x % 2 == 0 ) { $ x = $ x / 2 ; $ p ++ ; if ( $ p == $ x ) return true ; } return false ; }
function print_result ( $ a , $ n , $ k , $ m ) { $ v = array_fill ( 0 , $ m + 1 , array ( ) ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ rem = $ a [ $ i ] % $ m ; array_push ( $ v [ $ rem ] , $ a [ $ i ] ) ; if ( count ( $ v [ $ rem ] ) == $ k ) { for ( $ j = 0 ; $ j < $ k ; $ j ++ ) echo $ v [ $ rem ] [ $ j ] . " ▁ " ; return ; } } echo " - 1" ; }
function complement ( $ number ) { for ( $ i = 0 ; $ i < strlen ( $ number ) ; $ i ++ ) if ( $ number [ $ i ] != ' . ' ) $ number [ $ i ] = '9' - $ number [ $ i ] + '0' ; echo "9 ' s ▁ complement ▁ is ▁ : ▁ " , $ number ; }
function countWays ( $ n ) { $ count = 0 ; for ( $ i = 1 ; $ i * $ i < $ n ; $ i ++ ) if ( $ n % $ i == 0 ) $ count ++ ; return $ count ; }
function isPowerOfK ( $ n , $ k ) { $ oneSeen = false ; while ( $ n > 0 ) { $ digit = $ n % $ k ; if ( $ digit > 1 ) return false ; if ( $ digit == 1 ) { if ( $ oneSeen ) return false ; $ oneSeen = true ; } $ n = ( int ) $ n / $ k ; } return true ; }
function printFactorialNums ( $ n ) { $ fact = 1 ; $ x = 2 ; while ( $ fact <= $ n ) { echo $ fact , " " ; $ fact = $ fact * $ x ; $ x ++ ; } }
function Cel_To_Fah ( $ n ) { return ( ( $ n * 9.0 / 5.0 ) + 32.0 ) ; }
function countCompositions ( $ n ) { return ( ( 1 ) << ( $ n - 1 ) ) ; }
function computeLastDigit ( $ A , $ B ) { $ variable = 1 ; if ( $ A == $ B ) return 1 ; else if ( ( $ B - $ A ) >= 5 ) return 0 ; else { for ( $ i = $ A + 1 ; $ i <= $ B ; $ i ++ ) $ variable = ( $ variable * ( $ i % 10 ) ) % 10 ; return $ variable % 10 ; } }
function findSumSubsets ( $ n ) { return ( $ n * ( $ n + 1 ) / 2 ) * ( 1 << ( $ n - 1 ) ) ; }
function findMin ( $ a , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum += log ( $ a [ $ i ] ) ; $ x = exp ( $ sum / $ n ) ; return ( int ) ( $ x + 1 ) ; }
function sumOfAP ( $ a , $ d , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sum = $ sum + $ a ; $ a = $ a + $ d ; } return $ sum ; }
function sumOfAP ( $ a , $ d , $ n ) { $ sum = ( $ n / 2 ) * ( 2 * $ a + ( $ n - 1 ) * $ d ) ; return $ sum ; }
function sumOfSeries ( $ n ) { $ x ; if ( $ n % 2 == 0 ) $ x = ( $ n / 2 ) * ( $ n + 1 ) ; else $ x = ( ( $ n + 1 ) / 2 ) * $ n ; return $ x * $ x ; }
function findValue ( $ arr , $ n ) { $ ans = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = 0 ; $ j < $ n ; $ j ++ ) $ ans = max ( $ ans , abs ( $ arr [ $ i ] - $ arr [ $ j ] ) + abs ( $ i - $ j ) ) ; return $ ans ; }
function countsubarray ( $ array , $ n , $ k ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ array [ $ i ] < $ k ) $ count ++ ; $ mul = $ array [ $ i ] ; for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) { $ mul = $ mul * $ array [ $ j ] ; if ( $ mul < $ k ) $ count ++ ; else break ; } } return $ count ; }
function multiplyFactors ( $ n ) { global $ M ; $ prod = 1 ; for ( $ i = 1 ; $ i * $ i <= $ n ; $ i ++ ) { if ( $ n % $ i == 0 ) { if ( $ n / $ i == $ i ) $ prod = ( $ prod * $ i ) % $ M ; else { $ prod = ( $ prod * $ i ) % $ M ; $ prod = ( $ prod * $ n / $ i ) % $ M ; } } } return $ prod ; }
function countDigit ( $ n ) { if ( $ n / 10 == 0 ) return 1 ; return 1 + countDigit ( ( int ) ( $ n / 10 ) ) ; }
function printTrib ( $ n ) { $ dp [ 0 ] = $ dp [ 1 ] = 0 ; $ dp [ 2 ] = 1 ; for ( $ i = 3 ; $ i < $ n ; $ i ++ ) $ dp [ $ i ] = $ dp [ $ i - 1 ] + $ dp [ $ i - 2 ] + $ dp [ $ i - 3 ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo $ dp [ $ i ] , " ▁ " ; }
function printTrib ( $ n ) { if ( $ n < 1 ) return ; $ first = 0 ; $ second = 0 ; $ third = 1 ; echo $ first , " " ; if ( $ n > 1 ) echo $ second , " ▁ " ; if ( $ n > 2 ) echo $ second , " ▁ " ; for ( $ i = 3 ; $ i < $ n ; $ i ++ ) { $ curr = $ first + $ second + $ third ; $ first = $ second ; $ second = $ third ; $ third = $ curr ; echo $ curr , " " ; } }
function digit_product_Sum ( $ N ) { $ a = array_fill ( 0 , $ N , 0 ) ; $ product = 1 ; $ a [ 0 ] = 1 ; for ( $ i = 1 ; $ i <= $ N ; $ i ++ ) { $ product = ( int ) ( $ a [ $ i - 1 ] / 10 ) ; if ( $ product == 0 ) $ product = 1 ; else $ product = $ a [ $ i - 1 ] % 10 ; $ val = ( int ) ( $ a [ $ i - 1 ] / 10 ) ; if ( $ val == 0 ) $ val = $ a [ $ i - 1 ] ; $ a [ $ i ] = $ a [ $ i - 1 ] + ( $ val * $ product ) ; } for ( $ i = 0 ; $ i < $ N ; $ i ++ ) echo $ a [ $ i ] . " ▁ " ; }
function geometricMean ( $ arr , $ n ) { $ product = 1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ product = $ product * $ arr [ $ i ] ; $ gm = pow ( $ product , ( float ) ( 1 / $ n ) ) ; return $ gm ; }
function geometricMean ( $ arr , $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum = $ sum + log ( $ arr [ $ i ] ) ; $ sum = $ sum / $ n ; return exp ( $ sum ) ; }
function printTaxicab2 ( $ N ) { $ i = 1 ; $ count = 0 ; while ( $ count < $ N ) { $ int_count = 0 ; for ( $ j = 1 ; $ j <= pow ( $ i , 1.0 / 3 ) ; $ j ++ ) for ( $ k = $ j + 1 ; $ k <= pow ( $ i , 1.0 / 3 ) ; $ k ++ ) if ( $ j * $ j * $ j + $ k * $ k * $ k == $ i ) $ int_count ++ ; if ( $ int_count == 2 ) { $ count ++ ; echo $ count , " " , ▁ $ i , ▁ " " } $ i ++ ; } }
function isMagic ( $ n ) { $ sum = 0 ; while ( $ n > 0 $ sum > 9 ) { if ( $ n == 0 ) { $ n = $ sum ; $ sum = 0 ; } $ sum += $ n % 10 ; $ n /= 10 ; } return ( $ sum == 1 ) ; }
function productOfSingelDgt ( $ n , $ SIZE ) { if ( $ n >= 0 && $ n <= 9 ) return true ; $ prime = array ( 2 , 3 , 5 , 7 ) ; for ( $ i = 0 ; $ i < $ SIZE && $ n > 1 ; $ i ++ ) while ( $ n % $ prime [ $ i ] == 0 ) $ n = $ n / $ prime [ $ i ] ; return ( $ n == 1 ) ; }
function isComposite ( $ n ) { if ( $ n <= 1 ) return false ; if ( $ n <= 3 ) return false ; if ( $ n % 2 == 0 $ n % 3 == 0 ) return true ; for ( $ i = 5 ; $ i * $ i <= $ n ; $ i = $ i + 6 ) if ( $ n % $ i == 0 || $ n % ( $ i + 2 ) == 0 ) return true ; return false ; }
function findSum ( $ n ) { $ sum = 0 ; for ( $ x = 1 ; $ x <= $ n ; $ x ++ ) $ sum = $ sum + $ x ; return $ sum ; }
function findSum ( $ n ) { if ( $ n % 2 == 0 ) return ( $ n / 2 ) * ( $ n + 1 ) ; else return ( ( $ n + 1 ) / 2 ) * $ n ; }
function sackRace ( $ p1 , $ s1 , $ p2 , $ s2 ) { return ( ( $ s1 > $ s2 && ( $ p2 - $ p1 ) % ( $ s1 - $ s2 ) == 0 ) || ( $ s2 > $ s1 && ( $ p1 - $ p2 ) % ( $ s2 - $ s1 ) == 0 ) ) ; }
function xorCalc ( $ k ) { if ( $ k == 1 ) return 2 ; if ( ( ( $ k + 1 ) & $ k ) == 0 ) return floor ( $ k / 2 ) ; return 1 ; }
function divCount ( $ n ) { $ hash = array_fill ( 0 , $ n + 1 , 1 ) ; for ( $ p = 2 ; ( $ p * $ p ) < $ n ; $ p ++ ) if ( $ hash [ $ p ] == 1 ) for ( $ i = ( $ p * 2 ) ; $ i < $ n ; $ i = ( $ i + $ p ) ) $ hash [ $ i ] = 0 ; $ total = 1 ; for ( $ p = 2 ; $ p <= $ n ; $ p ++ ) { if ( $ hash [ $ p ] == 1 ) { $ count = 0 ; if ( $ n % $ p == 0 ) { while ( $ n % $ p == 0 ) { $ n = ( $ n / $ p ) ; $ count ++ ; } $ total = $ total * ( $ count + 1 ) ; } } } return $ total ; }
function maxPrimefactorNum ( $ N ) { if ( $ N < 2 ) return 0 ; $ arr = array_fill ( 0 , ( $ N + 1 ) , true ) ; $ prod = 1 ; $ res = 0 ; for ( $ p = 2 ; $ p * $ p <= $ N ; $ p ++ ) { if ( $ arr [ $ p ] == true ) { for ( $ i = $ p * 2 ; $ i <= $ N ; $ i += $ p ) $ arr [ $ i ] = false ; $ prod *= $ p ; if ( $ prod > $ N ) return $ res ; $ res ++ ; } } return $ res ; }
function arraySum ( $ arr , $ n ) { $ x = ( $ n + 1 ) / 2 ; return ( $ arr [ 0 ] - 1 ) * $ n + $ x * $ x ; }
function countDigits ( $ a , $ b ) { $ count = 0 ; $ p = abs ( $ a * $ b ) ; if ( $ p == 0 ) return 1 ; while ( $ p > 0 ) { $ count ++ ; $ p = ( int ) ( $ p / 10 ) ; } return $ count ; }
function countDigits ( $ a , $ b ) { if ( $ a == 0 or $ b == 0 ) return 1 ; return floor ( log10 ( abs ( $ a ) ) + log10 ( abs ( $ b ) ) ) + 1 ; }
function multiple ( $ a , $ b , $ x ) { if ( $ b < 0 ) { if ( $ a == 1 && $ x == 1 ) echo "1" ; else echo "0" ; } $ mul = pow ( $ a , $ b ) ; $ ans = $ mul / $ x ; $ ans1 = $ x * $ ans ; $ ans2 = $ x * ( $ ans + 1 ) ; $ k = ( ( ( $ mul - $ ans1 ) <= ( $ ans2 - $ mul ) ) ? $ ans1 : $ ans2 ) ; echo ( $ k ) ; }
function area_fun ( $ side ) { $ area = $ side * $ side ; return $ area ; }
function isPalindrome ( $ n ) { $ divisor = 1 ; while ( $ n / $ divisor >= 10 ) $ divisor *= 10 ; while ( $ n != 0 ) { $ leading = floor ( $ n / $ divisor ) ; $ trailing = $ n % 10 ; if ( $ leading != $ trailing ) return false ; $ n = ( $ n % $ divisor ) / 10 ; $ divisor = $ divisor / 100 ; } return true ; }
function lastPosition ( $ n , $ m , $ k ) { if ( $ m <= $ n - $ k + 1 ) return $ m + $ k - 1 ; $ m = $ m - ( $ n - $ k + 1 ) ; return ( $ m % $ n == 0 ) ? $ n : ( $ m % $ n ) ; }
function maxSum ( $ n ) { if ( $ n == 1 ) return 1 ; else return ( $ n * ( $ n - 1 ) / 2 ) - 1 + $ n / 2 ; }
function primesInRange ( $ n ) { $ fact = 1 ; for ( $ k = 2 ; $ k < $ n ; $ k ++ ) { $ fact = $ fact * ( $ k - 1 ) ; if ( ( $ fact + 1 ) % $ k == 0 ) print ( $ k . " STRNEWLINE " ) ; } }
function check ( $ n ) { return 1162261467 % $ n == 0 ; }
function productPuzzle ( $ a , $ n ) { global $ EPS ; $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ sum += ( double ) log10 ( $ a [ $ i ] ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) echo ( int ) ( $ EPS + pow ( ( double ) 10.00 , $ sum - log10 ( $ a [ $ i ] ) ) ) . " ▁ " ; }
function changeEvenBits ( $ n ) { $ to_subtract = 0 ; $ m = 0 ; for ( $ x = $ n ; $ x ; $ x >>= 2 ) { if ( $ x & 1 ) $ to_subtract += ( 1 << $ m ) ; $ m += 2 ; } return $ n - $ to_subtract ; }
function closestNumber ( $ n , $ m ) { $ q = ( int ) ( $ n / $ m ) ; $ n1 = $ m * $ q ; $ n2 = ( $ n * $ m ) > 0 ? ( $ m * ( $ q + 1 ) ) : ( $ m * ( $ q - 1 ) ) ; if ( abs ( $ n - $ n1 ) < abs ( $ n - $ n2 ) ) return $ n1 ; return $ n2 ; }
function checkPronic ( $ x ) { for ( $ i = 0 ; $ i <= ( sqrt ( $ x ) ) ; $ i ++ ) if ( $ x == $ i * ( $ i + 1 ) ) return true ; return false ; }
function countConsecutive ( $ N ) { $ count = 0 ; for ( $ L = 1 ; $ L * ( $ L + 1 ) < 2 * $ N ; $ L ++ ) { $ a = ( int ) ( 1.0 * $ N - ( $ L * ( int ) ( $ L + 1 ) ) / 2 ) / ( $ L + 1 ) ; if ( $ a - ( int ) $ a == 0.0 ) $ count ++ ; } return $ count ; }
function findMinSum ( $ num ) { $ sum = 0 ; for ( $ i = 2 ; $ i * $ i <= $ num ; $ i ++ ) { while ( $ num % $ i == 0 ) { $ sum += $ i ; $ num /= $ i ; } } $ sum += $ num ; return $ sum ; }
function minNum ( $ arr , $ n ) { $ odd = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] % 2 ) $ odd += 1 ; return ( $ odd % 2 ) ? 1 : 2 ; }
function minNum ( $ arr , $ n ) { $ odd = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ arr [ $ i ] % 2 ) $ odd = ! $ odd ; if ( $ odd ) return 1 ; return 2 ; }
function checkJumbled ( $ num ) { if ( $ num / 10 == 0 ) return true ; while ( $ num != 0 ) { if ( $ num / 10 == 0 ) return true ; $ digit1 = $ num % 10 ; $ digit2 = ( $ num / 10 ) % 10 ; if ( abs ( $ digit2 - $ digit1 ) > 1 ) return false ; $ num = $ num / 10 ; } return true ; }
function pell ( $ n ) { if ( $ n <= 2 ) return $ n ; return 2 * pell ( $ n - 1 ) + pell ( $ n - 2 ) ; }
function pell ( $ n ) { if ( $ n <= 2 ) return $ n ; $ a = 1 ; $ b = 2 ; $ c ; $ i ; for ( $ i = 3 ; $ i <= $ n ; $ i ++ ) { $ c = 2 * $ b + $ a ; $ a = $ b ; $ b = $ c ; } return $ b ; }
function printDemlo ( $ str ) { $ len = strlen ( $ str ) ; $ res = " " ; for ( $ i = 1 ; $ i <= $ len ; $ i ++ ) $ res . = chr ( $ i + 48 ) ; for ( $ i = $ len - 1 ; $ i >= 1 ; $ i -- ) $ res . = chr ( $ i + 48 ) ; return $ res ; }
function NumberofTimes ( $ str ) { $ temporary_sum = 0 ; $ count = 0 ; while ( strlen ( $ str ) > 1 ) { $ temporary_sum = 0 ; for ( $ i = 0 ; $ i < strlen ( $ str ) ; $ i ++ ) $ temporary_sum += ( $ str [ $ i ] - '0' ) ; $ str = ( string ) ( $ temporary_sum ) ; $ count ++ ; } return $ count ; }
function calculateLeaps ( $ n ) { if ( $ n == 0 $ n == 1 ) { return 1 ; } else { $ leaps = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ leaps += calculateLeaps ( $ i ) ; return $ leaps ; } }
function CountPairs ( $ n ) { $ k = $ n ; $ imin = 1 ; $ ans = 0 ; while ( $ imin <= $ n ) { $ imax = $ n / $ k ; $ ans += $ k * ( $ imax - $ imin + 1 ) ; $ imin = $ imax + 1 ; $ k = ( int ) ( $ n / $ imin ) ; } return $ ans ; }
function PowerOFPINnfactorial ( $ n , $ p ) { $ ans = 0 ; $ temp = $ p ; while ( $ temp <= $ n ) { $ ans += $ n / $ temp ; $ temp = $ temp * $ p ; } return $ ans ; }
function totalDigits ( $ n ) { $ number_of_digits = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i *= 10 ) $ number_of_digits += ( $ n - $ i + 1 ) ; return $ number_of_digits ; }
function numbersWith3Divisors ( $ n ) { $ prime = array_fill ( 0 , $ n + 1 , true ) ; $ prime [ 0 ] = $ prime [ 1 ] = false ; for ( $ p = 2 ; $ p * $ p <= $ n ; $ p ++ ) { if ( $ prime [ $ p ] == true ) { for ( $ i = $ p * 2 ; $ i <= $ n ; $ i += $ p ) $ prime [ $ i ] = false ; } } echo " Numbers ▁ with ▁ 3 ▁ divisors ▁ : STRNEWLINE " ; for ( $ i = 0 ; $ i * $ i <= $ n ; $ i ++ ) if ( $ prime [ $ i ] ) echo $ i * $ i . " ▁ " ; }
function decToHexa ( $ n ) { $ hexaDeciNum ; $ i = 0 ; while ( $ n != 0 ) { $ temp = 0 ; $ temp = $ n % 16 ; if ( $ temp < 10 ) { $ hexaDeciNum [ $ i ] = chr ( $ temp + 48 ) ; $ i ++ ; } else { $ hexaDeciNum [ $ i ] = chr ( $ temp + 55 ) ; $ i ++ ; } $ n = ( int ) ( $ n / 16 ) ; } for ( $ j = $ i - 1 ; $ j >= 0 ; $ j -- ) echo $ hexaDeciNum [ $ j ] ; }
function decToBinary ( $ n ) { $ binaryNum ; $ i = 0 ; while ( $ n > 0 ) { $ binaryNum [ $ i ] = $ n % 2 ; $ n = ( int ) ( $ n / 2 ) ; $ i ++ ; } for ( $ j = $ i - 1 ; $ j >= 0 ; $ j -- ) echo $ binaryNum [ $ j ] ; }
function binaryToDecimal ( $ n ) { $ num = $ n ; $ dec_value = 0 ; $ base = 1 ; $ temp = $ num ; while ( $ temp ) { $ last_digit = $ temp % 10 ; $ temp = $ temp / 10 ; $ dec_value += $ last_digit * $ base ; $ base = $ base * 2 ; } return $ dec_value ; }
function stirlingFactorial ( $ n ) { if ( $ n == 1 ) return 1 ; $ z ; $ e = 2.71 ; $ z = sqrt ( 2 * 3.14 * $ n ) * pow ( ( $ n / $ e ) , $ n ) ; return floor ( $ z ) ; }
function countXorPair ( $ arr , $ n ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) if ( ( $ arr [ $ i ] ^ $ arr [ $ j ] ) % 2 == 1 ) $ count ++ ; } return $ count ; }
function countXorPair ( $ arr , $ n ) { $ odd = 0 ; $ even = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] % 2 == 0 ) $ even ++ ; else $ odd ++ ; } return $ odd * $ even ; }
function count_of_ways ( $ n ) { $ count ; $ count = ( $ n + 1 ) * ( $ n + 2 ) / 2 ; return $ count ; }
function numOfCombinations ( $ arr , $ N ) { $ C = array ( 0 , 0 , 0 ) ; for ( $ i = 0 ; $ i < $ N ; ++ $ i ) ++ $ C [ $ arr [ $ i ] % 3 ] ; return $ C [ 1 ] * $ C [ 2 ] + $ C [ 0 ] * ( $ C [ 0 ] - 1 ) / 2 + $ C [ 0 ] * ( $ C [ 0 ] - 1 ) * ( $ C [ 0 ] - 2 ) / 6 + $ C [ 1 ] * ( $ C [ 1 ] - 1 ) * ( $ C [ 1 ] - 2 ) / 6 + $ C [ 2 ] * ( $ C [ 2 ] - 1 ) * ( $ C [ 2 ] - 2 ) / 6 + $ C [ 0 ] * $ C [ 1 ] * $ C [ 2 ] ; }
function findRectNum ( $ n ) { return $ n * ( $ n + 1 ) ; }
function nthprimedigitsnumber ( $ number ) { $ num = " " ; while ( $ number > 0 ) { $ rem = $ number % 4 ; switch ( $ rem ) { case 1 : $ num . = '2' ; break ; case 2 : $ num . = '3' ; break ; case 3 : $ num . = '5' ; break ; case 0 : $ num . = '7' ; break ; } if ( $ number % 4 == 0 ) $ number -- ; $ number = ( int ) ( $ number / 4 ) ; } return strrev ( $ num ) ; }
function findNoIsDivisibleOrNot ( $ a , $ n , $ l ) { for ( $ i = 0 ; $ i < $ l ; $ i ++ ) { if ( $ a [ $ i ] % $ n != 0 ) return false ; } return true ; }
function countPairs ( $ N ) { $ count = 0 ; for ( $ i = 1 ; $ i <= ( int ) pow ( $ N , 1 / 3 ) ; $ i ++ ) { $ cb = $ i * $ i * $ i ; $ diff = ( $ N - $ cb ) ; $ cbrtDiff = ( int ) pow ( $ diff , 1 / 3 ) ; if ( $ cbrtDiff * $ cbrtDiff * $ cbrtDiff == $ diff ) $ count ++ ; } return $ count ; }
function sumOfTermsInNthRow ( $ n ) { $ sum = $ n * ( 2 * pow ( $ n , 2 ) + 1 ) ; return $ sum ; }
function firstDigit ( $ x ) { while ( $ x >= 10 ) $ x = $ x / 10 ; return floor ( $ x ) ; }
function FirstDigit ( $ arr , $ n ) { $ S = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ S = $ S + log10 ( $ arr [ $ i ] * 1.0 ) ; $ fract_S = $ S - floor ( $ S ) ; $ ans = pow ( 10 , $ fract_S ) ; return floor ( $ ans ) ; }
function countDigit ( $ n ) { $ temp = $ n ; $ count = 0 ; while ( $ temp != 0 ) { $ d = $ temp % 10 ; $ temp /= 10 ; if ( $ d > 0 && $ n % $ d == 0 ) $ count ++ ; } return $ count ; }
function getOccurence ( $ n , $ d ) { $ result = 0 ; $ itr = $ d ; while ( $ itr <= $ n ) { if ( $ itr % 10 == $ d ) $ result ++ ; if ( $ itr != 0 && floor ( $ itr / 10 ) == $ d ) { $ result ++ ; $ itr ++ ; } else if ( floor ( $ itr / 10 ) == $ d - 1 ) $ itr = $ itr + ( 10 - $ d ) ; else $ itr = $ itr + 10 ; } return $ result ; }
function cal_cos ( $ n ) { $ accuracy = 0.0001 ; $ n = $ n * ( 3.142 / 180.0 ) ; $ x1 = 1 ; $ cosx = $ x1 ; $ cosval = cos ( $ n ) ; $ i = 1 ; do { $ denominator = 2 * $ i * ( 2 * $ i - 1 ) ; $ x1 = - $ x1 * $ n * $ n / $ denominator ; $ cosx = $ cosx + $ x1 ; $ i = $ i + 1 ; } while ( $ accuracy <= abs ( $ cosval - $ cosx ) ) ; echo round ( $ cosx , 6 ) ; }
function findMinZero ( $ p ) { $ first = 1 ; $ second = 1 ; $ number = 2 ; $ next = 1 ; while ( $ next ) { $ next = ( $ first + $ second ) % $ p ; $ first = $ second ; $ second = $ next ; $ number ++ ; } return $ number ; }
function printOtherSides ( $ n ) { if ( $ n & 1 ) { if ( $ n == 1 ) echo - 1 ; else { $ b = ( $ n * $ n - 1 ) / 2 ; $ c = ( $ n * $ n + 1 ) / 2 ; echo " b ▁ = ▁ " , $ b , " , ▁ c ▁ = ▁ " , $ c ; } } else { if ( $ n == 2 ) echo - 1 ; else { $ b = $ n * $ n / 4 - 1 ; $ c = $ n * $ n / 4 + 1 ; echo " b ▁ = ▁ " , $ b , " , ▁ c ▁ = ▁ " , $ c ; } } }
function makeOdd ( $ n ) { if ( $ n % 2 != 0 ) return 1 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) if ( ( $ n % $ i == 0 ) && ( ( $ n / $ i ) % 2 == 1 ) ) return $ i ; }
function makeOdd ( $ n ) { if ( $ n % 2 != 0 ) return 1 ; $ resul = 1 ; while ( $ n % 2 == 0 ) { $ n /= 2 ; $ resul *= 2 ; } return $ resul ; }
function getTotalXorOfSubarrayXors ( $ arr , $ N ) { if ( $ N % 2 == 0 ) return 0 ; $ res = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i += 2 ) $ res ^= $ arr [ $ i ] ; return $ res ; }
function closestMultiple ( $ n , $ x ) { if ( $ x > $ n ) return $ x ; $ n = $ n + $ x / 2 ; $ n = $ n - ( $ n % $ x ) ; return $ n ; }
function isAutomorphic ( $ N ) { $ sq = $ N * $ N ; while ( $ N > 0 ) { if ( $ N % 10 != $ sq % 10 ) return -1 ; $ N /= 10 ; $ sq /= 10 ; } return 1 ; }
function printNthElement ( $ n ) { $ arr [ 1 ] = 4 ; $ arr [ 2 ] = 7 ; for ( $ i = 3 ; $ i <= $ n ; $ i ++ ) { if ( $ i % 2 != 0 ) $ arr [ $ i ] = $ arr [ $ i / 2 ] * 10 + 4 ; else $ arr [ $ i ] = $ arr [ ( $ i / 2 ) - 1 ] * 10 + 7 ; } return $ arr [ $ n ] ; }
function maxSumLCM ( $ n ) { $ max_sum = 0 ; for ( $ i = 1 ; $ i * $ i <= $ n ; $ i ++ ) { if ( $ n % $ i == 0 ) { $ max_sum += $ i ; if ( $ n / $ i != $ i ) $ max_sum += ( $ n / $ i ) ; } } return $ max_sum ; }
function printCubes ( $ a , $ b ) { for ( $ i = $ a ; $ i <= $ b ; $ i ++ ) { for ( $ j = 1 ; $ j * $ j * $ j <= $ i ; $ j ++ ) { if ( $ j * $ j * $ j == $ i ) { echo $ j * $ j * $ j , " " ; break ; } } } }
function func ( $ a , $ k , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ a [ $ i ] % $ k == 0 ) return true ; return false ; }
function tidyNum ( $ str , $ len ) { for ( $ i = $ len - 2 ; $ i >= 0 ; $ i -- ) { if ( $ str [ $ i ] > $ str [ $ i + 1 ] ) { $ x = ord ( $ str [ $ i ] ) ; $ x -- ; $ str [ $ i ] = chr ( $ x ) ; for ( $ j = $ i + 1 ; $ j < $ len ; $ j ++ ) $ str [ $ j ] = '9' ; } } return $ str ; }
function findCount ( $ m , $ n ) { $ num1 = 0 ; for ( $ i = 0 ; $ i < $ m ; $ i ++ ) $ num1 = ( $ num1 * 10 ) + 9 ; $ num2 = 0 ; for ( $ i = 0 ; $ i < ( $ m - 1 ) ; $ i ++ ) $ num2 = ( $ num2 * 10 ) + 9 ; return ( ( $ num1 / $ n ) - ( $ num2 / $ n ) ) ; }
function findNthEvenDigitNumber ( $ n ) { $ count = 0 ; for ( $ i = 0 ; ; $ i ++ ) { $ curr = $ i ; $ isCurrEvenDigit = true ; while ( $ curr != 0 ) { if ( $ curr % 10 == 1 $ curr % 10 == 3 $ curr % 10 == 5 $ curr % 10 == 7 $ curr % 10 == 9 ) $ isCurrEvenDigit = false ; $ curr = $ curr / 10 ; } if ( $ isCurrEvenDigit == true ) $ count ++ ; if ( $ count == $ n ) return $ i ; } }
function toBinary ( $ n ) { if ( $ n >= 1 $ n <= 0 ) return " ERROR " ; $ frac = 0.5 ; $ answer = " . " ; while ( $ n > 0 ) { if ( strlen ( $ answer ) >= 32 ) return " ERROR " ; if ( $ n >= $ frac ) { $ answer . = "1" ; $ n = $ n - $ frac ; } else { $ answer . = "0" ; } $ frac = ( $ frac / 2 ) ; } return $ answer ; }
function isMultipleOf10 ( $ n ) { return ( $ n % 15 == 0 ) ; }
function isDivisibleBy25 ( $ str ) { $ n = strlen ( $ str ) ; if ( $ n == 1 ) return false ; return ( ( $ str [ $ n - 1 ] - '0' == 0 && $ str [ $ n - 2 ] - '0' == 0 ) || ( ( $ str [ $ n - 2 ] - '0' ) * 10 + ( $ str [ $ n - 1 ] - '0' ) ) % 25 == 0 ) ; }
function check ( $ str ) { $ n = strlen ( $ str ) ; if ( $ n == 0 && $ n == 1 ) return false ; if ( $ n == 2 ) return ( ( ( $ str [ $ n - 2 ] - '0' ) * 10 + ( $ str [ $ n - 1 ] - '0' ) ) % 16 == 0 ) ; if ( $ n == 3 ) return ( ( ( $ str [ $ n - 3 ] - '0' ) * 100 + ( $ str [ $ n - 2 ] - '0' ) * 10 + ( $ str [ $ n - 1 ] - '0' ) ) % 16 == 0 ) ; $ last = $ str [ $ n - 1 ] - '0' ; $ second_last = $ str [ $ n - 2 ] - '0' ; $ third_last = $ str [ $ n - 3 ] - '0' ; $ fourth_last = $ str [ $ n - 4 ] - '0' ; return ( ( $ fourth_last * 1000 + $ third_last * 100 + $ second_last * 10 + $ last ) % 16 == 0 ) ; }
function findIndex ( $ n ) { if ( $ n <= 1 ) return $ n ; $ a = 0 ; $ b = 1 ; $ c = 1 ; $ res = 1 ; while ( $ c < $ n ) { $ c = $ a + $ b ; $ res ++ ; $ a = $ b ; $ b = $ c ; } return $ res ; }
function firstkdigits ( $ n , $ k ) { $ product = 1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ product *= $ n ; while ( ( int ) ( $ product / pow ( 10 , $ k ) ) != 0 ) $ product = ( int ) $ product / 10 ; return floor ( $ product ) ; }
function checkPandigital ( $ b , $ n ) { if ( strlen ( $ n ) < $ b ) return 0 ; $ hash = array ( ) ; for ( $ i = 0 ; $ i < $ b ; $ i ++ ) $ hash [ $ i ] = 0 ; for ( $ i = 0 ; $ i < strlen ( $ n ) ; $ i ++ ) { if ( $ n [ $ i ] >= '0' && $ n [ $ i ] <= '9' ) $ hash [ $ n [ $ i ] - '0' ] = 1 ; else if ( ord ( $ n [ $ i ] ) - ord ( ' A ' ) <= $ b - 11 ) $ hash [ ord ( $ n [ $ i ] ) - ord ( ' A ' ) + 10 ] = 1 ; } for ( $ i = 0 ; $ i < $ b ; $ i ++ ) if ( $ hash [ $ i ] == 0 ) return 0 ; return 1 ; }
function convert ( $ m , $ n ) { if ( $ m == $ n ) return 0 ; if ( $ m > $ n ) return $ m - $ n ; if ( $ m <= 0 && $ n > 0 ) return -1 ; if ( $ n % 2 == 1 ) return 1 + convert ( $ m , $ n + 1 ) ; else return 1 + convert ( $ m , $ n / 2 ) ; } { $ m = 3 ; $ n = 11 ; echo " Minimum ▁ number ▁ of ▁ " . " operations ▁ : ▁ " , convert ( $ m , $ n ) ; return 0 ; }
function moduloMultiplication ( $ a , $ b , $ mod ) { $ a %= $ mod ; while ( $ b ) { if ( $ b & 1 ) $ res = ( $ res + $ a ) % $ mod ; $ a = ( 2 * $ a ) % $ mod ; } return $ res ; }
function findStarNum ( $ n ) { return ( 6 * $ n * ( $ n - 1 ) + 1 ) ; }
function isDivisibleBy5 ( $ str ) { $ n = strlen ( $ str ) ; return ( ( ( $ str [ $ n - 1 ] - '0' ) == 0 ) || ( ( $ str [ $ n - 1 ] - '0' ) == 5 ) ) ; }
function isTidy ( $ num ) { $ prev = 10 ; while ( $ num ) { $ rem = $ num % 10 ; $ num = ( int ) $ num / 10 ; if ( $ rem > $ prev ) return false ; $ prev = $ rem ; } return true ; }
function minToggle ( $ arr , $ n ) { $ zero [ 0 ] = 0 ; $ zero [ $ n + 1 ] = 0 ; for ( $ i = 1 ; $ i <= $ n ; ++ $ i ) { if ( $ arr [ $ i - 1 ] == 0 ) $ zero [ $ i ] = $ zero [ $ i - 1 ] + 1 ; else $ zero [ $ i ] = $ zero [ $ i - 1 ] ; } $ ans = $ n ; for ( $ i = 1 ; $ i <= $ n ; ++ $ i ) $ ans = min ( $ ans , $ i - $ zero [ $ i ] + $ zero [ $ n ] - $ zero [ $ i ] ) ; return $ ans ; }
function nondecdigits ( $ n ) { $ x = 0 ; for ( $ x = $ n ; $ x >= 1 ; $ x -- ) { $ no = $ x ; $ prev_dig = 11 ; $ flag = true ; while ( $ no != 0 ) { if ( $ prev_dig < $ no % 10 ) { $ flag = false ; break ; } $ prev_dig = $ no % 10 ; $ no /= 10 ; } if ( $ flag == true ) break ; } return $ x ; }
function countDivisors ( $ n ) { $ cnt = 0 ; for ( $ i = 1 ; $ i <= sqrt ( $ n ) ; $ i ++ ) { if ( $ n % $ i == 0 ) { if ( $ n / $ i == $ i ) $ cnt ++ ; else $ cnt = $ cnt + 2 ; } } return $ cnt ; }
function validate ( $ n ) { for ( $ i = 0 ; $ i < 10 ; $ i ++ ) { $ temp = $ n ; $ count = 0 ; while ( $ temp ) { if ( $ temp % 10 == $ i ) $ count ++ ; if ( $ count > $ i ) return -1 ; $ temp /= 10 ; } } return 1 ; }
function divisibleBy36 ( $ num ) { $ l = strlen ( $ num ) ; if ( $ l == 0 ) return " No " ; if ( $ l == 1 && $ num [ 0 ] != '0' ) return " No " ; $ two_digit_num = ( $ num [ $ l - 2 ] - '0' ) * 10 + ( $ num [ $ l - 1 ] - '0' ) ; if ( $ two_digit_num % 4 != 0 ) return " No " ; $ sum = 0 ; for ( $ i = 0 ; $ i < $ l ; $ i ++ ) $ sum += ( $ num [ $ i ] - '0' ) ; if ( $ sum % 9 != 0 ) return " No " ; return " Yes " ; }
function check ( $ str ) { $ n = strlen ( $ str ) ; $ digitSum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ digitSum += ( $ str [ $ i ] - '0' ) ; return ( $ digitSum % 9 == 0 ) ; }
function getTotalXorOfSubarrayXors ( $ arr , $ N ) { $ res = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) for ( $ j = $ i ; $ j < $ N ; $ j ++ ) for ( $ k = $ i ; $ k <= $ j ; $ k ++ ) $ res = $ res ^ $ arr [ $ k ] ; return $ res ; }
function getTotalXorOfSubarrayXors ( $ arr , $ N ) { $ res = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { $ freq = ( $ i + 1 ) * ( $ N - $ i ) ; if ( $ freq % 2 == 1 ) $ res = $ res ^ $ arr [ $ i ] ; } return $ res ; }
function check ( $ str ) { $ n = strlen ( $ str ) ; if ( ( $ str [ $ n - 1 ] - '0' ) % 2 != 0 ) return false ; $ digitSum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ digitSum += ( $ str [ $ i ] - '0' ) ; return ( $ digitSum % 3 == 0 ) ; }
function check ( $ str ) { $ n = strlen ( $ str ) ; if ( $ n == 0 ) return false ; if ( $ n == 1 ) return ( ( $ str [ 0 ] - '0' ) % 8 == 0 ) ; if ( $ n == 2 ) return ( ( ( $ str [ $ n - 2 ] - '0' ) * 10 + ( $ str [ $ n - 1 ] - '0' ) ) % 8 == 0 ) ; $ last = $ str [ $ n - 1 ] - '0' ; $ second_last = $ str [ $ n - 2 ] - '0' ; $ third_last = $ str [ $ n - 3 ] - '0' ; return ( ( $ third_last * 100 + $ second_last * 10 + $ last ) % 8 == 0 ) ; }
function isRefactorableNumber ( $ n ) { $ divCount = 0 ; for ( $ i = 1 ; $ i <= sqrt ( $ n ) ; ++ $ i ) { if ( $ n % $ i == 0 ) { if ( $ n / $ i == $ i ) ++ $ divCount ; else $ divCount += 2 ; } } return $ n % $ divCount == 0 ; }
function check ( $ str ) { $ n = strlen ( $ str ) ; $ digitSum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ digitSum += ( $ str [ $ i ] - '0' ) ; return ( $ digitSum % 3 == 0 ) ; }
function nthPalindrome ( $ n , $ k ) { $ temp = ( $ k & 1 ) ? ( int ) ( $ k / 2 ) : ( int ) ( $ k / 2 - 1 ) ; $ palindrome = ( int ) pow ( 10 , $ temp ) ; $ palindrome += $ n - 1 ; print ( $ palindrome ) ; if ( $ k & 1 ) $ palindrome = ( int ) ( $ palindrome / 10 ) ; while ( $ palindrome > 0 ) { print ( $ palindrome % 10 ) ; $ palindrome = ( int ) ( $ palindrome / 10 ) ; } print ( " STRNEWLINE " ) ; }
function largestGCDSubsequence ( $ arr , $ n ) { $ ans = 0 ; $ maxele = max ( $ arr ) ; for ( $ i = 2 ; $ i <= $ maxele ; ++ $ i ) { $ count = 0 ; for ( $ j = 0 ; $ j < $ n ; ++ $ j ) { if ( $ arr [ $ j ] % $ i == 0 ) ++ $ count ; } $ ans = max ( $ ans , $ count ) ; } return $ ans ; }
function countOfBinaryNumberLessThanN ( $ N ) { $ q = array ( ) ; array_push ( $ q , 1 ) ; $ cnt = 0 ; $ t = 0 ; while ( ! empty ( $ q ) ) { $ t = array_pop ( $ q ) ; if ( $ t <= $ N ) { $ cnt ++ ; array_push ( $ q , $ t * 10 ) ; array_push ( $ q , ( $ t * 10 + 1 ) ) ; } } return $ cnt ; }
function SubArraySum ( $ arr , $ n ) { $ result = 0 ; $ temp = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ temp = 0 ; for ( $ j = $ i ; $ j < $ n ; $ j ++ ) { $ temp += $ arr [ $ j ] $ result += $ temp ; } } return $ result ; }
function SubArraySum ( $ arr , $ n ) { $ result = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ result += ( $ arr [ $ i ] * ( $ i + 1 ) * ( $ n - $ i ) ) ; return $ result ; }
function nthElement ( $ a , $ b , $ n ) { $ seq = array ( ) ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) array_push ( $ seq , $ a * $ i ) ; sort ( $ seq ) ; for ( $ i = 1 , $ k = $ n ; $ i <= $ n && $ k > 0 ; $ i ++ ) { if ( array_search ( $ b * $ i , $ seq ) == 0 ) { array_push ( $ seq , $ b * $ i ) ; sort ( $ seq ) ; $ k -- ; } } return $ seq [ $ n - 1 ] ; }
function sumofproduct ( $ n ) { $ ans = 0 ; for ( $ x = 1 ; $ x <= $ n ; $ x ++ ) { $ y = ( int ) ( $ n / $ x ) ; $ ans += ( $ y * $ x ) ; } return $ ans ; }
function lastNon0Digit ( $ n ) { global $ dig ; if ( $ n < 10 ) return $ dig [ $ n ] ; if ( ( ( $ n / 10 ) % 10 ) % 2 == 0 ) return ( 6 * lastNon0Digit ( $ n / 5 ) * $ dig [ $ n % 10 ] ) % 10 ; else return ( 4 * lastNon0Digit ( $ n / 5 ) * $ dig [ $ n % 10 ] ) % 10 ; }
function minPower ( $ n , $ x ) { if ( $ x == 1 ) return $ n ; $ ans = 0 ; while ( $ n > 0 ) { $ ans += ( $ n % $ x ) ; $ n /= $ x ; } return $ ans ; }
function calSum ( $ n ) { $ a = 3 ; $ b = 0 ; $ c = 2 ; return 3 ; return 3 ; return 5 ; $ sum = 5 ; while ( $ n > 2 ) { $ d = $ a + $ b ; $ sum += $ d ; $ a = $ b ; $ b = $ c ; $ c = $ d ; $ n -- ; } return $ sum ; }
function findKCF ( $ x , $ y , $ k ) { $ small = min ( $ x , $ y ) ; $ count = 1 ; for ( $ i = 2 ; $ i <= $ small ; $ i ++ ) { if ( $ x % $ i == 0 && $ y % $ i == 0 ) $ count ++ ; if ( $ count == $ k ) return $ i ; } return -1 ; }
function firstFactorialDivisibleNumber ( $ x ) { $ i = 1 ; $ fact = 1 ; for ( $ i = 1 ; $ i < $ x ; $ i ++ ) { $ fact = $ fact * $ i ; if ( $ fact % $ x == 0 ) break ; } return $ i ; }
function highestPowerof2 ( $ n ) { $ res = 0 ; for ( $ i = $ n ; $ i >= 1 ; $ i -- ) { if ( ( $ i & ( $ i - 1 ) ) == 0 ) { $ res = $ i ; break ; } } return $ res ; }
function highestPowerof2 ( $ n ) { $ p = ( int ) log ( $ n , 2 ) ; return ( int ) pow ( 2 , $ p ) ; }
function countMaxChoco ( $ money , $ price , $ wrap ) { if ( $ money < $ price ) return 0 ; $ choc = $ money / $ price ; $ choc = $ choc + ( $ choc - 1 ) / ( $ wrap - 1 ) ; return $ choc ; }
function findSum ( $ N , $ K ) { $ ans = 0 ; for ( $ i = 1 ; $ i <= $ N ; $ i ++ ) $ ans += ( $ i % $ K ) ; return $ ans ; }
function findSum ( $ N , $ K ) { $ ans = 0 ; $ y = $ N / $ K ; $ x = $ N % $ K ; $ ans = ( $ K * ( $ K - 1 ) / 2 ) * $ y + ( $ x * ( $ x + 1 ) ) / 2 ; return $ ans ; }
function maxHandshake ( $ n ) { return ( $ n * ( $ n - 1 ) ) / 2 ; }
function countNums ( $ n , $ x , $ y ) { $ arr = array_fill ( 0 , $ n + 1 , false ) ; if ( $ x <= $ n ) $ arr [ $ x ] = true ; if ( $ y <= $ n ) $ arr [ $ y ] = true ; $ result = 0 ; for ( $ i = min ( $ x , $ y ) ; $ i <= $ n ; $ i ++ ) { if ( $ arr [ $ i ] ) { if ( $ i + $ x <= $ n ) $ arr [ $ i + $ x ] = true ; if ( $ i + $ y <= $ n ) $ arr [ $ i + $ y ] = true ; $ result ++ ; } } return $ result ; }
function canBeSumofConsec ( $ n ) { return ( ( $ n & ( $ n - 1 ) ) && $ n ) ; }
function evenFibSum ( $ limit ) { if ( $ limit < 2 ) return 0 ; $ ef1 = 0 ; $ ef2 = 2 ; $ sum = $ ef1 + $ ef2 ; while ( $ ef2 <= $ limit ) { $ ef3 = 4 * $ ef2 + $ ef1 ; if ( $ ef3 > $ limit ) break ; $ ef1 = $ ef2 ; $ ef2 = $ ef3 ; $ sum += $ ef2 ; } return $ sum ; }
function evenFib ( $ n ) { if ( $ n < 1 ) return $ n ; if ( $ n == 1 ) return 2 ; return ( ( 4 * evenFib ( $ n - 1 ) ) + evenFib ( $ n - 2 ) ) ; }
function countSteps ( $ x , $ y ) { if ( $ x % $ y == 0 ) return floor ( ( ( int ) $ x / $ y ) ) ; return floor ( ( ( int ) $ x / $ y ) + countSteps ( $ y , $ x % $ y ) ) ; }
function findCountOfSolutions ( $ n , $ p ) { $ ans = 0 ; for ( $ x = 1 ; $ x < $ p ; $ x ++ ) { if ( ( $ x * $ x ) % $ p == 1 ) { $ last = $ x + $ p * ( $ n / $ p ) ; if ( $ last > $ n ) $ last -= $ p ; $ ans += ( ( $ last - $ x ) / $ p + 1 ) ; } } return $ ans ; }
function spellsCount ( $ num ) { $ n = strlen ( $ num ) ; $ result = 1 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ count = 1 ; while ( $ i < $ n - 1 && $ num [ $ i + 1 ] == $ num [ $ i ] ) { $ count ++ ; $ i ++ ; } $ result = $ result * pow ( 2 , $ count - 1 ) ; } return $ result ; }
function sqroot ( $ s ) { $ pSq = 0 ; $ N = 0 ; for ( $ i = intval ( $ s ) ; $ i > 0 ; $ i -- ) { for ( $ j = 1 ; $ j < $ i ; $ j ++ ) { if ( $ j * $ j == $ i ) { $ pSq = $ i ; $ N = $ j ; break ; } } if ( $ pSq > 0 ) break ; } $ d = $ s - $ pSq ; $ P = $ d / ( 2.0 * $ N ) ; $ A = $ N + $ P ; $ sqrt_of_s = $ A - ( ( $ P * $ P ) / ( 2.0 * $ A ) ) ; return $ sqrt_of_s ; }
function digSum ( $ n ) { $ sum = 0 ; while ( $ n > 0 $ sum > 9 ) { if ( $ n == 0 ) { $ n = $ sum ; $ sum = 0 ; } $ sum += $ n % 10 ; $ n = ( int ) $ n / 10 ; } return $ sum ; }
function digSum ( $ n ) { if ( $ n == 0 ) return 0 ; return ( $ n % 9 == 0 ) ? 9 : ( $ n % 9 ) ; }
function countMultiples ( $ n ) { return floor ( $ n / 3 + $ n / 7 - $ n / 21 ) ; }
function nonFibonacci ( $ n ) { $ prevPrev = 1 ; $ prev = 2 ; $ curr = 3 ; while ( $ n > 0 ) { $ prevPrev = $ prev ; $ prev = $ curr ; $ curr = $ prevPrev + $ prev ; $ n = $ n - ( $ curr - $ prev - 1 ) ; } $ n = $ n + ( $ curr - $ prev - 1 ) ; return $ prev + $ n ; }
function countOddSquares ( $ n , $ m ) { return pow ( $ m , 0.5 ) - pow ( $ n - 1 , 0.5 ) ; }
function gcd ( $ a , $ b ) { if ( $ a == $ b ) return $ a ; if ( $ a == 0 ) return $ b ; if ( $ b == 0 ) return $ a ; { return gcd ( $ a >> 1 , $ b ) ; return gcd ( $ a >> 1 , $ b >> 1 ) << 1 ; } return gcd ( $ a , $ b >> 1 ) ; if ( $ a > $ b ) return gcd ( ( $ a - $ b ) >> 1 , $ b ) ; return gcd ( ( $ b - $ a ) >> 1 , $ a ) ; }
function findPieces ( $ n ) { return ( $ n * ( $ n + 1 ) ) / 2 + 1 ; }
function findDigits ( $ n ) { if ( $ n < 0 ) return 0 ; if ( $ n <= 1 ) return 1 ; $ x = ( ( $ n * log10 ( $ n / M_E ) + log10 ( 2 * M_PI * $ n ) / 2.0 ) ) ; return floor ( $ x ) + 1 ; }
function findDigits ( $ n ) { if ( $ n < 0 ) return 0 ; if ( $ n <= 1 ) return 1 ; $ digits = 0 ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) $ digits += log10 ( $ i ) ; return floor ( $ digits ) + 1 ; }
function findPairs ( $ n ) { $ cubeRoot = pow ( $ n , 1.0 / 3.0 ) ; $ cube = array ( ) ; for ( $ i = 1 ; $ i <= $ cubeRoot ; $ i ++ ) $ cube [ $ i ] = $ i * $ i * $ i ; $ l = 1 ; $ r = $ cubeRoot ; while ( $ l < $ r ) { if ( $ cube [ $ l ] + $ cube [ $ r ] < $ n ) $ l ++ ; else if ( $ cube [ $ l ] + $ cube [ $ r ] > $ n ) $ r -- ; else { echo " ( " , $ l , " , ▁ " , floor ( $ r ) , " ) " ; echo " STRNEWLINE " ; $ l ++ ; $ r -- ; } } }
function countEvenSum ( $ arr , $ n ) { $ result = 0 ; for ( $ i = 0 ; $ i <= $ n - 1 ; $ i ++ ) { $ sum = 0 ; for ( $ j = $ i ; $ j <= $ n - 1 ; $ j ++ ) { $ sum = $ sum + $ arr [ $ j ] ; if ( $ sum % 2 == 0 ) $ result ++ ; } } return ( $ result ) ; }
function calculateSum ( $ n ) { if ( $ n <= 0 ) return 0 ; $ fibo [ 0 ] = 0 ; $ fibo [ 1 ] = 1 ; $ sum = $ fibo [ 0 ] + $ fibo [ 1 ] ; for ( $ i = 2 ; $ i <= $ n ; $ i ++ ) { $ fibo [ $ i ] = $ fibo [ $ i - 1 ] + $ fibo [ $ i - 2 ] ; $ sum += $ fibo [ $ i ] ; } return $ sum ; }
function isPower ( $ x , $ y ) { $ res1 = log ( $ y ) / log ( $ x ) ; $ res2 = log ( $ y ) / log ( $ x ) ; return ( $ res1 == $ res2 ) ; }
function isPerfectSquare ( $ n ) { for ( $ sum = 0 , $ i = 1 ; $ sum < $ n ; $ i += 2 ) { $ sum += $ i ; if ( $ sum == $ n ) return true ; } return false ; }
function findCount ( $ d ) { return 9 * ( pow ( 10 , $ d - 1 ) - pow ( 9 , $ d - 1 ) ) ; } { $ d = 1 ; echo findCount ( $ d ) , " STRNEWLINE " ; $ d = 2 ; echo findCount ( $ d ) , " STRNEWLINE " ; $ d = 4 ; echo findCount ( $ d ) , " STRNEWLINE " ; return 0 ; }
function countDyckPaths ( $ n ) { $ res = 1 ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) { $ res *= ( 2 * $ n - $ i ) ; $ res /= ( $ i + 1 ) ; } return $ res / ( $ n + 1 ) ; }
function countDivisors ( $ n ) { $ count = 0 ; for ( $ i = 1 ; $ i <= sqrt ( $ n ) + 1 ; $ i ++ ) { if ( $ n % $ i == 0 ) $ count += ( $ n / $ i == $ i ) ? 1 : 2 ; } if ( $ count % 2 == 0 ) echo " Even STRNEWLINE " ; else echo " Odd STRNEWLINE " ; }
function printDivisors ( $ n ) { $ v ; $ t = 0 ; for ( $ i = 1 ; $ i <= ( int ) sqrt ( $ n ) ; $ i ++ ) { if ( $ n % $ i == 0 ) { if ( ( int ) $ n / $ i == $ i ) echo $ i . " " ; else { echo $ i . " " ; $ v [ $ t ++ ] = ( int ) $ n / $ i ; } } } for ( $ i = count ( $ v ) - 1 ; $ i >= 0 ; $ i -- ) echo $ v [ $ i ] . " ▁ " ; }
function printDivisors ( $ n ) { for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) if ( $ n % $ i == 0 ) echo $ i , " ▁ " ; }
function printDivisors ( $ n ) { for ( $ i = 1 ; $ i <= sqrt ( $ n ) ; $ i ++ ) { if ( $ n % $ i == 0 ) { if ( $ n / $ i == $ i ) echo $ i , " ▁ " ; else echo $ i , " ▁ " , $ n / $ i , " ▁ " ; } } }
function isTriangular ( $ num ) { if ( $ num < 0 ) return false ; $ sum = 0 ; for ( $ n = 1 ; $ sum <= $ num ; $ n ++ ) { $ sum = $ sum + $ n ; if ( $ sum == $ num ) return true ; } return false ; }
function isTriangular ( $ num ) { if ( $ num < 0 ) return false ; $ c = ( -2 * $ num ) ; $ b = 1 ; $ a = 1 ; $ d = ( $ b * $ b ) - ( 4 * $ a * $ c ) ; if ( $ d < 0 ) return false ; $ root1 = ( - $ b + ( float ) sqrt ( $ d ) ) / ( 2 * $ a ) ; $ root2 = ( - $ b - ( float ) sqrt ( $ d ) ) / ( 2 * $ a ) ; if ( $ root1 > 0 && floor ( $ root1 ) == $ root1 ) return true ; if ( $ root2 > 0 && floor ( $ root2 ) == $ root2 ) return true ; return false ; }
function seriesSum ( $ calculated , $ current , $ N ) { $ i ; $ cur = 1 ; if ( $ current == $ N + 1 ) return 0 ; for ( $ i = $ calculated ; $ i < $ calculated + $ current ; $ i ++ ) $ cur *= $ i ; return $ cur + seriesSum ( $ i , $ current + 1 , $ N ) ; }
function SieveOfSundaram ( $ n ) { $ nNew = ( $ n - 1 ) / 2 ; $ marked = array_fill ( 0 , ( $ nNew + 1 ) , false ) ; for ( $ i = 1 ; $ i <= $ nNew ; $ i ++ ) for ( $ j = $ i ; ( $ i + $ j + 2 * $ i * $ j ) <= $ nNew ; $ j ++ ) $ marked [ $ i + $ j + 2 * $ i * $ j ] = true ; if ( $ n > 2 ) echo "2 ▁ " ; for ( $ i = 1 ; $ i <= $ nNew ; $ i ++ ) if ( $ marked [ $ i ] == false ) echo ( 2 * $ i + 1 ) . " ▁ " ; }
function squareRootExists ( $ n , $ p ) { $ n = $ n % $ p ; for ( $ x = 2 ; $ x < $ p ; $ x ++ ) if ( ( $ x * $ x ) % $ p == $ n ) return true ; return false ; }
function modFact ( $ n , $ p ) { if ( $ n >= $ p ) return 0 ; $ result = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ result = ( $ result * $ i ) % $ p ; return $ result ; }
function findMinX ( $ num , $ rem , $ k ) { while ( true ) { $ j ; for ( $ j = 0 ; $ j < $ k ; $ j ++ ) if ( $ x % $ num [ $ j ] != $ rem [ $ j ] ) break ; if ( $ j == $ k ) return $ x ; $ x ++ ; } return $ x ; }
function countSquares ( $ m , $ n ) { if ( $ n < $ m ) list ( $ m , $ n ) = array ( $ n , $ m ) ; return $ m * ( $ m + 1 ) * ( 2 * $ m + 1 ) / 6 + ( $ n - $ m ) * $ m * ( $ m + 1 ) / 2 ; }
function countWays ( $ n ) { $ counter = 0 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) for ( $ j = $ i ; $ j < $ n ; $ j ++ ) for ( $ k = $ j ; $ k < $ n ; $ k ++ ) for ( $ l = $ k ; $ l < $ n ; $ l ++ ) if ( $ i + $ j + $ k + $ l == $ n ) $ counter ++ ; return $ counter ; }
function pairAndSum ( $ arr , $ n ) { $ ans = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) $ ans += $ arr [ $ i ] & $ arr [ $ j ] ; return $ ans ; }
function isPrime ( $ n ) { if ( $ n <= 1 ) return false ; for ( $ i = 2 ; $ i < $ n ; $ i ++ ) if ( $ n % $ i == 0 ) return false ; return true ; }
function computeTotient ( $ n ) { for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ phi [ $ i ] = $ i ; for ( $ p = 2 ; $ p <= $ n ; $ p ++ ) { if ( $ phi [ $ p ] == $ p ) { $ phi [ $ p ] = $ p - 1 ; for ( $ i = 2 * $ p ; $ i <= $ n ; $ i += $ p ) { $ phi [ $ i ] = ( $ phi [ $ i ] / $ p ) * ( $ p - 1 ) ; } } } for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) echo " Totient ▁ of ▁ " , $ i , " ▁ is ▁ " , $ phi [ $ i ] , " STRNEWLINE " ; }
function isInside ( $ circle_x , $ circle_y , $ rad , $ x , $ y ) { if ( ( $ x - $ circle_x ) * ( $ x - $ circle_x ) + ( $ y - $ circle_y ) * ( $ y - $ circle_y ) <= $ rad * $ rad ) return true ; else return false ; }
function sumBitDifferences ( $ arr , $ n ) { $ ans = 0 ; for ( $ i = 0 ; $ i < 32 ; $ i ++ ) { $ count = 0 ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) if ( ( $ arr [ $ j ] & ( 1 << $ i ) ) ) $ count ++ ; $ ans += ( $ count * ( $ n - $ count ) * 2 ) ; } return $ ans ; }
function isPerfect ( $ n ) { $ sum = 1 ; for ( $ i = 2 ; $ i * $ i <= $ n ; $ i ++ ) { if ( $ n % $ i == 0 ) { if ( $ i * $ i != $ n ) $ sum = $ sum + $ i + ( int ) ( $ n / $ i ) ; else $ sum = $ sum + $ i ; } } if ( $ sum == $ n && $ n != 1 ) return true ; return false ; }
function isLucky ( $ n ) { $ arr = array ( ) ; for ( $ i = 0 ; $ i < 10 ; $ i ++ ) $ arr [ $ i ] = false ; while ( $ n > 0 ) { $ digit = $ n % 10 ; if ( $ arr [ $ digit ] ) return false ; $ arr [ $ digit ] = true ; $ n = ( int ) ( $ n / 10 ) ; } return true ; }
function mod ( $ num , $ a ) { $ res = 0 ; for ( $ i = 0 ; $ i < $ r = strlen ( $ num ) ; $ i ++ ) $ res = ( $ res * 10 + $ num [ $ i ] - '0' ) % $ a ; return $ res ; }
function nthMagicNo ( $ n ) { $ pow = 1 ; $ answer = 0 ; while ( $ n ) { $ pow = $ pow * 5 ; if ( $ n & 1 ) $ answer += $ pow ; } return $ answer ; }
function modInverse ( $ a , $ m ) { for ( $ x = 1 ; $ x < $ m ; $ x ++ ) if ( ( ( $ a % $ m ) * ( $ x % $ m ) ) % $ m == 1 ) return $ x ; }
function modInverse ( $ a , $ m ) { $ m0 = $ m ; $ y = 0 ; $ x = 1 ; if ( $ m == 1 ) return 0 ; while ( $ a > 1 ) { $ q = ( int ) ( $ a / $ m ) ; $ t = $ m ; $ m = $ a % $ m ; $ a = $ t ; $ t = $ y ; $ y = $ x - $ q * $ y ; $ x = $ t ; } if ( $ x < 0 ) $ x += $ m0 ; return $ x ; }
function phi ( $ n ) { $ result = $ n ; for ( $ p = 2 ; $ p * $ p <= $ n ; ++ $ p ) { if ( $ n % $ p == 0 ) { while ( $ n % $ p == 0 ) $ n /= $ p ; $ result *= ( 1.0 - ( 1.0 / $ p ) ) ; } } if ( $ n > 1 ) $ result *= ( 1.0 - ( 1.0 / $ n ) ) ; return intval ( $ result ) ; }
function largestPower ( $ n , $ p ) { $ x = 0 ; while ( $ n ) { $ n = ( int ) $ n / $ p ; $ x += $ n ; } return floor ( $ x ) ; }
function countOfMultiples ( $ n ) { return floor ( floor ( $ n / 3 ) + floor ( $ n / 5 ) - floor ( $ n / 15 ) ) ; }
function getPeriod ( $ n ) { $ rem = 1 ; for ( $ i = 1 ; $ i <= $ n + 1 ; $ i ++ ) $ rem = ( 10 * $ rem ) % $ n ; $ d = $ rem ; $ count = 0 ; do { $ rem = ( 10 * $ rem ) % $ n ; $ count ++ ; } while ( $ rem != $ d ) ; return $ count ; }
function getRemainder ( $ num , $ divisor ) { $ t = ( $ num - $ divisor * ( int ) ( $ num / $ divisor ) ) ; return $ t ; }
function sum ( $ n ) { $ sum = 0 ; $ fact = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ fact *= $ i ; $ sum += 1.0 / $ fact ; } return $ sum ; }
function println ( $ n , $ k ) { $ rem = 1 ; for ( $ i = 0 ; $ i < $ k ; $ i ++ ) { echo floor ( ( 10 * $ rem ) / $ n ) ; $ rem = ( 10 * $ rem ) % $ n ; } }
function printSquares ( $ n ) { $ square = 0 ; $ odd = 1 ; for ( $ x = 0 ; $ x < $ n ; $ x ++ ) { echo $ square , " " ; $ square = $ square + $ odd ; $ odd = $ odd + 2 ; } }
function printFibonacciNumbers ( $ n ) { $ f1 = 0 ; $ f2 = 1 ; $ i ; if ( $ n < 1 ) return ; echo ( $ f1 ) ; echo ( " ▁ " ) ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { echo ( $ f2 ) ; echo ( " ▁ " ) ; $ next = $ f1 + $ f2 ; $ f1 = $ f2 ; $ f2 = $ next ; } }
function factorial ( $ n ) { if ( $ n == 0 ) return 1 ; return $ n * factorial ( $ n - 1 ) ; }
function factorial ( $ n ) { return ( $ n == 1 $ n == 0 ) ? 1 : $ n * factorial ( $ n - 1 ) ; }
function gcd ( $ a , $ b ) { if ( $ a == 0 ) return $ b ; if ( $ b == 0 ) return $ a ; if ( $ a == $ b ) return $ a ; if ( $ a > $ b ) return gcd ( $ a - $ b , $ b ) ; return gcd ( $ a , $ b - $ a ) ; }
function gcd ( $ a , $ b ) { if ( $ b == 0 ) return $ a ; return gcd ( $ b , $ a % $ b ) ; }
function isMultipleof5 ( $ n ) { while ( $ n > 0 ) $ n = $ n - 5 ; if ( $ n == 0 ) return true ; return false ; }
function isMultipleof5 ( $ n ) { global $ MAX ; $ str = ( string ) $ n ; $ len = strlen ( $ str ) ; if ( $ str [ $ len - 1 ] == '5' $ str [ $ len - 1 ] == '0' ) return true ; return false ; }
function isPowerOfTwo ( $ x ) { return $ x && ( ! ( $ x & ( $ x - 1 ) ) ) ; }
function reversDigits ( $ num ) { global $ rev_num ; global $ base_pos ; if ( $ num > 0 ) { reversDigits ( ( int ) ( $ num / 10 ) ) ; $ rev_num += ( $ num % 10 ) * $ base_pos ; $ base_pos *= 10 ; } return $ rev_num ; }
function pairORSum ( $ arr , $ n ) { $ ans = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) $ ans += $ arr [ $ i ] | $ arr [ $ j ] ; return $ ans ; }
function multiplyByFifteen ( $ n ) { $ prod = ( $ n << 4 ) ; $ prod = $ prod - $ n ; return $ prod ; }
function CalculatePairs ( $ a , $ n ) { $ cnt_zero = 0 ; $ cnt_one = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ a [ $ i ] % 2 == 0 ) $ cnt_zero += 1 ; else $ cnt_one += 1 ; } $ total_XOR_pairs = $ cnt_zero * $ cnt_one ; $ total_AND_pairs = ( $ cnt_one ) * ( $ cnt_one - 1 ) / 2 ; $ total_OR_pairs = $ cnt_zero * $ cnt_one + ( $ cnt_one ) * ( $ cnt_one - 1 ) / 2 ; echo ( " cntXOR ▁ = ▁ $ total _ XOR _ pairs STRNEWLINE " ) ; echo ( " cntAND ▁ = ▁ $ total _ AND _ pairs STRNEWLINE " ) ; echo ( " cntOR ▁ = ▁ $ total _ OR _ pairs STRNEWLINE " ) ; }
function isDefeat ( $ s1 , $ s2 , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( ( $ s1 [ $ i ] == '0' && $ s2 [ $ i ] == '1' ) || ( $ s1 [ $ i ] == '1' && $ s2 [ $ i ] == '0' ) ) continue ; else if ( ( $ s1 [ $ i ] == '0' && $ s2 [ $ i ] == ' Z ' ) || ( $ s1 [ $ i ] == ' Z ' && $ s2 [ $ i ] == '0' ) ) continue ; else { return true ; } } return false ; }
function FindIndexKthBit ( $ n , $ k ) { $ cnt = 0 ; $ ind = 0 ; while ( $ n ) { if ( $ n & 1 ) $ cnt ++ ; if ( $ cnt == $ k ) return $ ind ; $ ind ++ ; $ n = $ n >> 1 ; } return -1 ; }
function minAND ( $ arr , $ n ) { $ s = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ s = $ s & $ arr [ $ i ] ; } print ( $ s . " " ) ; }
function check ( $ a , $ n ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) if ( $ a [ $ i ] ) return true ; return false ; }
function binToDecimal3 ( $ n ) { $ last_3 = ( ( $ n & 4 ) + ( $ n & 2 ) + ( $ n & 1 ) ) ; $ n = $ n >> 3 ; while ( $ n > 7 ) $ n = $ n >> 1 ; $ first_3 = ( ( $ n & 4 ) + ( $ n & 2 ) + ( $ n & 1 ) ) ; echo ( $ first_3 ) ; echo ( " ▁ " ) ; echo ( $ last_3 ) ; }
function minDistance ( $ n1 , $ n2 ) { $ bitCount1 = floor ( log ( $ n1 , 2 ) ) + 1 ; $ bitCount2 = floor ( log ( $ n2 , 2 ) ) + 1 ; $ bitDiff = abs ( $ bitCount1 - $ bitCount2 ) ; $ maxBitCount = max ( $ bitCount1 , $ bitCount2 ) ; if ( $ bitCount1 > $ bitCount2 ) { $ n2 = $ n2 * pow ( 2 , $ bitDiff ) ; } else { $ n1 = $ n1 * pow ( 2 , $ bitDiff ) ; } $ xorValue = $ n1 ^ $ n2 ; $ bitCountXorValue = floor ( log ( $ xorValue , 2 ) ) + 1 ; $ disSimilarBitPosition = $ maxBitCount - $ bitCountXorValue ; $ result = $ bitCount1 + $ bitCount2 - 2 * $ disSimilarBitPosition ; return $ result ; }
function printMaxAfterRemoval ( $ s ) { $ flag = false ; $ n = strlen ( $ s ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ s [ $ i ] == '0' && $ flag == false ) { $ flag = true ; continue ; } else echo $ s [ $ i ] ; } }
function bitPos ( $ n1 , $ n2 ) { if ( $ n1 == $ n2 ) return 0 ; $ bitCount1 = floor ( log ( $ n1 , 2 ) ) + 1 ; $ bitCount2 = floor ( log ( $ n2 , 2 ) ) + 1 ; $ bitDiff = abs ( $ bitCount1 - $ bitCount2 ) ; $ maxBitCount = max ( $ bitCount1 , $ bitCount2 ) ; if ( $ bitCount1 > $ bitCount2 ) { $ n2 = $ n2 * pow ( 2 , $ bitDiff ) ; } else { $ n1 = $ n1 * pow ( 2 , $ bitDiff ) ; } $ xorValue = $ n1 ^ $ n2 ; $ bitCountXorValue = floor ( log ( $ xorValue , 2 ) ) + 1 ; $ disSimilarBitPosition = $ maxBitCount - $ bitCountXorValue + 1 ; return $ disSimilarBitPosition ; }
function countOddPair ( $ A , $ N ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) if ( ! ( $ A [ $ i ] & 1 ) ) $ count ++ ; $ evenPairCount = $ count * ( $ count - 1 ) / 2 ; $ totPairs = $ N * ( $ N - 1 ) / 2 ; return ( $ totPairs - $ evenPairCount ) ; }
function findevenPair ( $ A , $ N ) { $ evenPair = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ N ; $ j ++ ) { if ( ( $ A [ $ i ] & $ A [ $ j ] ) % 2 == 0 ) $ evenPair ++ ; } } return $ evenPair ; }
function findevenPair ( $ A , $ N ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) if ( $ A [ $ i ] % 2 != 0 ) $ count ++ ; $ oddCount = $ count * ( $ count - 1 ) / 2 ; return ( $ N * ( $ N - 1 ) / 2 ) - $ oddCount ; }
function calculate ( $ X ) { $ number_of_bits = 8 ; return ( ( 1 << $ number_of_bits ) - 1 ) ^ $ X ; }
function ReplaceElements ( & $ arr , $ n ) { if ( $ n <= 1 ) return ; $ prev = $ arr [ 0 ] ; $ arr [ 0 ] = $ arr [ 0 ] ^ $ arr [ 1 ] ; for ( $ i = 1 ; $ i < $ n - 1 ; $ i ++ ) { $ curr = $ arr [ $ i ] ; $ arr [ $ i ] = $ prev ^ $ arr [ $ i + 1 ] ; $ prev = $ curr ; } $ arr [ $ n - 1 ] = $ prev ^ $ arr [ $ n - 1 ] ; }
function alternate ( & $ a , & $ b , & $ x ) { $ x = $ a ^ $ b ^ $ x ; }
function LeadingZeros ( $ x , $ y ) { if ( ( $ x ^ $ y ) <= ( $ x & $ y ) ) echo " Equal " else if ( ( $ x & ( ~ $ y ) ) > $ y ) echo $ y ; else echo $ x ; }
function highestPowerOf2 ( $ n ) { return ( $ n & ( ~ ( $ n - 1 ) ) ) ; }
function solve ( $ A , $ B ) { $ count = 0 ; for ( $ i = 0 ; $ i < 32 ; $ i ++ ) { if ( ( ( $ A >> $ i ) & 1 ) != ( ( $ B >> $ i ) & 1 ) ) { $ count ++ ; } } echo " Number ▁ of ▁ different ▁ bits ▁ : ▁ $ count " ; }
function isSubsetAndZero ( $ array , $ length , $ N ) { $ arrAnd = $ array [ 0 ] ; for ( $ i = 1 ; $ i < $ length ; $ i ++ ) { $ arrAnd = $ arrAnd & $ array [ $ i ] ; } if ( ( $ arrAnd & $ N ) == 0 ) echo ( " YES " ) ; else echo ( " NO " ) ; }
function setRightmostUnsetBit ( $ n ) { if ( ( $ n & ( $ n + 1 ) ) == 0 ) return $ n ; return $ n | ( $ n + 1 ) ; }
function O_R ( $ a , $ n ) { $ ans = $ a [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; ++ $ i ) $ ans |= $ a [ $ i ] ; return $ ans ; }
function ANDS ( & $ a , $ n ) { $ ans = $ a [ 0 ] ; for ( $ i = 0 ; $ i < $ n ; ++ $ i ) $ ans &= $ a [ $ i ] ; return $ ans ; }
function hammingDistance ( $ n1 , $ n2 ) { $ x = $ n1 ^ $ n2 ; $ setBits = 0 ; while ( $ x > 0 ) { $ setBits += $ x & 1 ; $ x >>= 1 ; } return $ setBits ; }
function findParity ( $ x ) { $ y = $ x ^ ( $ x >> 1 ) ; $ y = $ y ^ ( $ y >> 2 ) ; $ y = $ y ^ ( $ y >> 4 ) ; $ y = $ y ^ ( $ y >> 8 ) ; $ y = $ y ^ ( $ y >> 16 ) ; if ( $ y & 1 ) return 1 ; return 0 ; }
function increment ( $ i ) { $ i = - ( ~ $ i ) ; return $ i ; }
function increment ( $ i ) { $ i = - ( ~ ord ( $ i ) ) ; return chr ( $ i ) ; }
function findOddPair ( $ A , $ N ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) { if ( $ A [ $ i ] % 2 == 0 ) $ count ++ ; } return $ count * ( $ N - $ count ) ; }
function xor_pair_sum ( $ ar , $ n ) { $ total = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ total = $ total ^ $ ar [ $ i ] ; return ( 2 * $ total ) ; }
function findEvenPair ( & $ A , $ N ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ N ; $ i ++ ) if ( ! ( $ A [ $ i ] & 1 ) ) $ count ++ ; return $ count * ( $ count - 1 ) / 2 ; }
function allBitsSetInTheGivenRange ( $ n , $ l , $ r ) { $ num = ( ( 1 << $ r ) - 1 ) ^ ( ( 1 << ( $ l - 1 ) ) - 1 ) ; $ new_num = $ n & $ num ; if ( $ new_num == 0 ) return true ; return false ; }
function calculateSum ( $ n ) { $ sum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sum = $ sum + ( 1 << $ i ) ; } return $ sum ; }
function checkSame ( $ n ) { $ set = 0 ; $ unset = 0 ; while ( $ n ) { if ( $ n & 1 ) $ set ++ ; else $ unset ++ ; $ n = $ n >> 1 ; } if ( $ set == $ unset ) return true ; else return false ; }
function onlyFirstAndLastAreSet ( $ n ) { if ( $ n == 1 ) return true ; if ( $ n == 2 ) return false ; return ( ( ( $ n - 1 ) & ( $ n - 2 ) ) == 0 ) ; }
function getInteger ( $ L , $ R ) { $ number = 0 ; for ( $ i = $ L ; $ i <= $ R ; $ i ++ ) $ number += pow ( 2 , $ i ) ; return $ number ; }
function setbitsfromLtoR ( $ L , $ R ) { return ( 1 << ( $ R + 1 ) ) - ( 1 << $ L ) ; }
function maxOR ( $ arr , $ n , $ k , $ x ) { $ res ; $ pow = 1 ; for ( $ i = 0 ; $ i < $ k ; $ i ++ ) $ pow *= $ x ; $ preSum [ 0 ] = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ preSum [ $ i + 1 ] = $ preSum [ $ i ] | $ arr [ $ i ] ; $ suffSum [ $ n ] = 0 ; for ( $ i = $ n - 1 ; $ i >= 0 ; $ i -- ) $ suffSum [ $ i ] = $ suffSum [ $ i + 1 ] | $ arr [ $ i ] ; $ res = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ res = max ( $ res , $ preSum [ $ i ] | ( $ arr [ $ i ] * $ pow ) $ suffSum [ $ i + 1 ] ) ; return $ res ; }
function findXor ( $ arr , $ n ) { $ xoR = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ xoR = $ xoR ^ $ arr [ $ i ] ; } return $ xoR * 2 ; }
function turnOnK ( $ n , $ k ) { if ( $ k <= 0 ) return $ n ; return ( $ n | ( 1 << ( $ k - 1 ) ) ) ; }
function printOdds ( $ arr , $ n ) { $ res = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ res = $ res ^ $ arr [ $ i ] ; $ set_bit = $ res & ( ~ ( $ res - 1 ) ) ; $ x = 0 ; $ y = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] & $ set_bit ) $ x = $ x ^ $ arr [ $ i ] ; else $ y = $ y ^ $ arr [ $ i ] ; } echo ( $ x . " ▁ " . $ y ) ; }
function findEletobeInserted ( $ A , $ n , $ k ) { $ ans = $ k ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ ans ^= $ A [ $ i ] ; return $ ans ; }
function printKthBit ( $ n , $ k ) { echo ( $ n & ( 1 << ( $ k - 1 ) ) ) ; }
function andSum ( $ arr , $ n ) { global $ BITS ; $ ans = 0 ; for ( $ i = 0 ; $ i < $ BITS ; $ i ++ ) { $ countSetBits = 0 ; for ( $ j = 0 ; $ j < $ n ; $ j ++ ) { if ( $ arr [ $ j ] & ( 1 << $ i ) ) $ countSetBits ++ ; } $ subset = ( 1 << $ countSetBits ) - 1 ; $ subset = ( $ subset * ( 1 << $ i ) ) ; $ ans += $ subset ; } return $ ans ; }
function countSetBits ( $ n ) { $ count = 0 ; while ( $ n ) { $ count += $ n & 1 ; $ n >>= 1 ; } return $ count ; }
function multiplyWith4 ( $ n ) { return ( $ n << 2 ) ; }
function isEven ( $ n ) { $ isEven = true ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ isEven = ! $ isEven ; return $ isEven ; }
function isEven ( $ n ) { return ( ( int ) ( $ n / 2 ) * 2 == $ n ) ; }
function findWinner ( $ A , $ n ) { $ res = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ res ^= $ A [ $ i ] ; if ( $ res == 0 or $ n % 2 == 0 ) return " Alice " ; else return " Bob " ; }
function printSubsets ( $ n ) { for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) if ( ( $ n & $ i ) == $ i ) echo $ i . " " ; }
function printSubsets ( $ n ) { for ( $ i = $ n ; $ i > 0 ; $ i = ( $ i - 1 ) & $ n ) echo $ i . " " ; echo "0" ; }
function isFibbinaryNum ( $ n ) { if ( ( $ n & ( $ n >> 1 ) ) == 0 ) return true ; return false ; }
function maxXOR ( $ n , $ k ) { $ c = log ( $ n , 2 ) + 1 ; return ( ( 1 << $ c ) - 1 ) ; }
function divide ( $ dividend , $ divisor ) { $ sign = ( ( $ dividend < 0 ) ^ ( $ divisor < 0 ) ) ? -1 : 1 ; $ dividend = abs ( $ dividend ) ; $ divisor = abs ( $ divisor ) ; $ quotient = 0 ; $ temp = 0 ; for ( $ i = 31 ; $ i >= 0 ; -- $ i ) { if ( $ temp + ( $ divisor << $ i ) <= $ dividend ) { $ temp += $ divisor << $ i ; $ quotient |= ( double ) ( 1 ) << $ i ; } } if ( $ sign == -1 ) $ quotient = - $ quotient ; return $ quotient ; }
function swapBitsInPair ( $ x ) { return ( ( $ x & 0b10101010 ) >> 1 ) | ( ( $ x & 0b01010101 ) << 1 ) ; }
function evenbitsetnumber ( $ n ) { $ count = 0 ; $ res = 0 ; for ( $ temp = $ n ; $ temp > 0 ; $ temp >>= 1 ) { if ( $ count % 2 == 1 ) $ res |= ( 1 << $ count ) ; $ count ++ ; } return ( $ n $ res ) ; }
function oddbitsetnumber ( $ n ) { $ count = 0 ; $ res = 0 ; for ( $ temp = $ n ; $ temp > 0 ; $ temp >>= 1 ) { if ( $ count % 2 == 0 ) $ res |= ( 1 << $ count ) ; $ count ++ ; } return ( $ n $ res ) ; }
function toggleBits ( $ n1 , $ n2 ) { return $ n1 ^ $ n2 ; }
function evenbittogglenumber ( $ n ) { $ res = 0 ; $ count = 0 ; for ( $ temp = $ n ; $ temp > 0 ; $ temp >>= 1 ) { if ( $ count % 2 == 1 ) $ res |= ( 1 << $ count ) ; $ count ++ ; } return $ n ^ $ res ; }
function setleftmostunsetbit ( $ n ) { if ( ( $ n & ( $ n + 1 ) ) == 0 ) return $ n ; $ pos = 0 ; for ( $ temp = $ n , $ count = 0 ; $ temp > 0 ; $ temp >>= 1 , $ count ++ ) if ( ( $ temp & 1 ) == 0 ) $ pos = $ count ; return ( $ n | ( 1 << ( $ pos ) ) ) ; }
function maxXorSum ( $ n , $ k ) { if ( $ k == 1 ) return $ n ; $ res = 1 ; while ( $ res <= $ n ) $ res <<= 1 ; return $ res - 1 ; }
function printNumHavingAltBitPatrn ( $ n ) { $ curr_num = 1 ; echo $ curr_num . " " ; while ( 1 ) { $ curr_num <<= 1 ; if ( $ n < $ curr_num ) break ; echo $ curr_num . " " ; $ curr_num = ( ( $ curr_num ) << 1 ) ^ 1 ; if ( $ n < $ curr_num ) break ; echo $ curr_num . " " ; } }
function MaximumSum ( $ a , $ b , $ n ) { $ sum1 = 0 ; $ sum2 = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ sum1 |= $ a [ $ i ] ; $ sum2 |= $ b [ $ i ] ; } echo ( $ sum1 + $ sum2 ) . " STRNEWLINE " ; }
function multiply ( $ x , $ n ) { return $ x << $ n ; }
function isDivBy2PowerM ( $ n , $ m ) { if ( ( $ n & ( ( 1 << $ m ) - 1 ) ) == 0 ) return true ; return false ; }
function findWinner ( $ N ) { return $ N & 1 ; }
function countgroup ( $ a , $ n ) { $ xs = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ xs = $ xs ^ $ a [ $ i ] ; if ( $ xs == 0 ) return ( 1 << ( $ n - 1 ) ) - 1 ; return 0 ; }
function evenbittogglenumber ( $ n ) { $ res = 0 ; $ count = 0 ; for ( $ temp = $ n ; $ temp > 0 ; $ temp >>= 1 ) { if ( $ count % 2 == 0 ) $ res |= ( 1 << $ count ) ; $ count ++ ; } return $ n ^ $ res ; }
function divide ( $ n , $ m ) { echo " Remainder = " . ▁ ( ( $ n ) ▁ & ( $ m ▁ - ▁ 1 ) ) ; STRNEWLINE TABSYMBOL echo ▁ " Quotient = " }
function perfectPowerOf2 ( $ n ) { $ per_pow = 1 ; while ( $ n > 0 ) { $ per_pow = $ per_pow << 1 ; $ n = $ n >> 1 ; } return $ per_pow ; }
function solve ( $ p , $ n ) { $ G = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ p [ $ i ] & 1 ) $ G ^= ( $ p [ $ i ] + 1 ) ; $ G ^= ( $ p [ $ i ] - 1 ) ; } return $ G ; }
function isDivisibleby17 ( $ n ) { if ( $ n == 0 $ n == 17 ) return true ; if ( $ n < 17 ) return false ; return isDivisibleby17 ( ( int ) ( $ n >> 4 ) - ( int ) ( $ n & 15 ) ) ; }
function answer ( $ n ) { $ m = 2 ; $ ans = 1 ; $ r = 1 ; while ( $ r < $ n ) { $ r = ( pow ( 2 , $ m ) - 1 ) * ( pow ( 2 , $ m - 1 ) ) ; if ( $ r < $ n ) $ ans = $ r ; $ m ++ ; } return $ ans ; }
function maxAND ( $ arr , $ n ) { $ res = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) for ( $ j = $ i + 1 ; $ j < $ n ; $ j ++ ) $ res = max ( $ res , $ arr [ $ i ] & $ arr [ $ j ] ) ; return $ res ; }
function checking ( $ s ) { $ c = 0 ; $ n = strlen ( $ s ) ; for ( $ i = $ n - 1 ; $ i >= 0 ; $ i -- ) { if ( $ s [ $ i ] == '0' ) $ c ++ ; if ( $ c >= 6 and $ s [ $ i ] == '1' ) return true ; } return false ; }
function findUnique ( $ a , $ n , $ k ) { $ INT_SIZE = 8 * PHP_INT_SIZE ; $ count = array ( ) ; for ( $ i = 0 ; $ i < $ INT_SIZE ; $ i ++ ) $ count [ $ i ] = 0 ; for ( $ i = 0 ; $ i < $ INT_SIZE ; $ i ++ ) for ( $ j = 0 ; $ j < $ n ; $ j ++ ) if ( ( $ a [ $ j ] & ( 1 << $ i ) ) != 0 ) $ count [ $ i ] += 1 ; $ res = 0 ; for ( $ i = 0 ; $ i < $ INT_SIZE ; $ i ++ ) $ res += ( $ count [ $ i ] % $ k ) * ( 1 << $ i ) ; return $ res ; }
function findUniquePair ( $ arr , $ n ) { $ XOR = $ arr [ 0 ] ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ XOR = $ XOR ^ $ arr [ $ i ] ; $ set_bit_no = $ XOR & ~ ( $ XOR - 1 ) ; $ x = 0 ; $ y = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { if ( $ arr [ $ i ] & $ set_bit_no ) $ x = $ x ^ $ arr [ $ i ] ; else $ y = $ y ^ $ arr [ $ i ] ; } echo " The ▁ unique ▁ pair ▁ is ▁ " , " ( " , $ x , " ▁ " , $ y , " ) " ; }
function setallbitgivenrange ( $ n , $ l , $ r ) { $ range = ( ( ( 1 << ( $ l - 1 ) ) - 1 ) ^ ( ( 1 << ( $ r ) ) - 1 ) ) ; return ( $ n $ range ) ; }
function countBits ( $ number ) { return ( int ) ( log ( $ number ) / log ( 2 ) ) + 1 ; }
function setBitNumber ( $ n ) { if ( $ n == 0 ) return 0 ; $ msb = 0 ; $ n = $ n / 2 ; while ( $ n != 0 ) { $ n = $ n / 2 ; $ msb ++ ; } return ( 1 << $ msb ) ; }
function setBitNumber ( $ n ) { $ n |= $ n >> 1 ; $ n |= $ n >> 2 ; $ n |= $ n >> 4 ; $ n |= $ n >> 8 ; $ n |= $ n >> 16 ; $ n = $ n + 1 ; return ( $ n >> 1 ) ; }
function setBitNumber ( $ n ) { $ k = ( int ) ( log ( $ n , 2 ) ) ; return 1 << $ k ; }
function allBitsSetInTheGivenRange ( $ n , $ l , $ r ) { $ num = ( ( 1 << $ r ) - 1 ) ^ ( ( 1 << ( $ l - 1 ) ) - 1 ) ; $ new_num = $ n & $ num ; if ( $ new_num == 0 ) return " Yes " ; return " No " ; }
function toggle ( & $ n ) { $ temp = 1 ; while ( $ temp <= $ n ) { $ n = $ n ^ $ temp ; $ temp = $ temp << 1 ; } }
function checkPowerof8 ( $ n ) { $ i = log ( $ n ) / log ( 8 ) ; return ( $ i - floor ( $ i ) < 0.000001 ) ; }
function allBitsSetInTheGivenRange ( $ n , $ l , $ r ) { $ num = ( ( 1 << $ r ) - 1 ) ^ ( ( 1 << ( $ l - 1 ) ) - 1 ) ; $ new_num = $ n & $ num ; if ( $ num == $ new_num ) return " Yes " ; return " No " ; }
function printNonConsecutive ( $ n ) { $ p = ( 1 << $ n ) ; for ( $ i = 1 ; $ i < $ p ; $ i ++ ) if ( ( $ i & ( $ i << 1 ) ) == 0 ) echo $ i . " " ; }
function bitExtracted ( $ number , $ k , $ p ) { return ( ( ( 1 << $ k ) - 1 ) & ( $ number >> ( $ p - 1 ) ) ) ; }
function areSame ( $ a , $ b ) { if ( ! ( $ a - $ b ) ) echo " Same " ; else echo " Not ▁ Same " ; }
function findSum ( $ n ) { $ sum = 0 ; for ( $ i = 1 ; ( 1 << $ i ) < $ n ; $ i ++ ) { for ( $ j = 0 ; $ j < $ i ; $ j ++ ) { $ num = ( 1 << $ i ) + ( 1 << $ j ) ; if ( $ num <= $ n ) $ sum += $ num ; } } return $ sum ; }
function toggleLastMBits ( $ n , $ m ) { $ num = ( 1 << $ m ) - 1 ; return ( $ n ^ $ num ) ; } { $ n = 107 ; $ m = 4 ; echo toggleLastMBits ( $ n , $ m ) ; return 0 ; }
function isAMultipleOf4 ( $ n ) { if ( ( $ n & 3 ) == 0 ) return " Yes " ; return " No " ; }
function posOfRightMostDiffBit ( $ m , $ n ) { $ t = floor ( log ( $ m ^ $ n , 2 ) ) ; return $ t ; }
function areAllBitsSet ( $ n ) { if ( $ n == 0 ) return " No " ; while ( $ n > 0 ) { if ( ( $ n & 1 ) == 0 ) return " No " ; $ n = $ n >> 1 ; } return " Yes " ; }
function areAllBitsSet ( $ n ) { if ( $ n == 0 ) return " No " ; if ( ( ( $ n + 1 ) & $ n ) == 0 ) return " Yes " ; return " No " ; }
function setKthBit ( $ n , $ k ) { return ( ( 1 << $ k ) $ n ) ; }
function missingNumber ( $ arr1 , $ arr2 , $ n ) { $ mnum = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ mnum = $ mnum ^ $ arr1 [ $ i ] ; for ( $ i = 0 ; $ i < $ n - 1 ; $ i ++ ) $ mnum = $ mnum ^ $ arr2 [ $ i ] ; return $ mnum ; }
function toggleKthBit ( $ n , $ k ) { return ( $ n ^ ( 1 << ( $ k - 1 ) ) ) ; }
function countValues ( $ x ) { $ count = 0 ; $ n = 1 ; while ( $ x != 0 ) { if ( $ x % 2 == 0 ) $ count += $ n ; $ n *= 2 ; $ x /= 2 ; $ x = ( int ) $ x ; } return $ count ; }
function constructXOR ( & $ A , $ n ) { $ XOR = 0 ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ XOR ^= $ A [ $ i ] ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) $ A [ $ i ] = $ XOR ^ $ A [ $ i ] ; }
function countTrailingZero ( $ x ) { $ count = 0 ; while ( ( $ x & 1 ) == 0 ) { $ x = $ x >> 1 ; $ count ++ ; } return $ count ; }
function countTrailingZero ( $ x ) { $ lookup = array ( 32 , 0 , 1 , 26 , 2 , 23 , 27 , 0 , 3 , 16 , 24 , 30 , 28 , 11 , 0 , 13 , 4 , 7 , 17 , 0 , 25 , 22 , 31 , 15 , 29 , 10 , 12 , 6 , 0 , 21 , 14 , 9 , 5 , 20 , 8 , 19 , 18 ) ; return $ lookup [ ( - $ x & $ x ) % 37 ] ; }
function totalFlips ( $ A , $ B , $ C , $ N ) { $ count = 0 ; for ( $ i = 0 ; $ i < $ N ; ++ $ i ) { if ( $ A [ $ i ] == $ B [ $ i ] && $ C [ $ i ] == '1' ) ++ $ count ; else if ( $ A [ $ i ] != $ B [ $ i ] && $ C [ $ i ] == '0' ) ++ $ count ; } return $ count ; }
function countNumbers ( $ n ) { $ k = 0 ; $ count = 0 ; while ( $ n > 0 ) { if ( ( $ n & 1 ) == 0 ) $ count += pow ( 2 , $ k ) ; $ k += 1 ; $ n >>= 1 ; } return $ count ; }
function multiply ( $ n , $ m ) { $ ans = 0 ; $ count = 0 ; while ( $ m ) { if ( $ m % 2 == 1 ) $ ans += $ n << $ count ; $ count ++ ; $ m /= 2 ; } return $ ans ; }
function EqualNumber ( $ A , $ B ) { return ( $ A ^ $ B ) ; }
function areSetBitsIncreasing ( $ n ) { $ prev_count = PHP_INT_MAX ; while ( $ n > 0 ) { while ( $ n > 0 && $ n % 2 == 0 ) $ n = $ n / 2 ; $ curr_count = 1 ; while ( $ n > 0 and $ n % 2 == 1 ) { $ n = $ n / 2 ; $ curr_count ++ ; } if ( $ curr_count >= $ prev_count ) return false ; $ prev_count = $ curr_count ; } return true ; }
function findPattern ( $ n ) { $ prev = $ n % 2 ; $ n = $ n / 2 ; while ( $ n > 0 ) { $ curr = $ n % 2 ; if ( $ curr == $ prev ) return false ; $ prev = $ curr ; $ n = floor ( $ n / 2 ) ; } return true ; }
function countXOR ( $ n ) { $ count0 = 0 ; $ count1 = 0 ; while ( $ n ) { ( $ n % 2 == 0 ) ? $ count0 ++ : $ count1 ++ ; $ n = intval ( $ n / 2 ) ; } return ( $ count0 ^ $ count1 ) ; }
function isMultipleOf4 ( $ n ) { if ( $ n == 1 ) return false ; $ XOR = 0 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) $ XOR = $ XOR ^ $ i ; return ( $ XOR == $ n ) ; }
function multiplyTen ( $ n ) { return ( $ n << 1 ) + ( $ n << 3 ) ; }
function countValues ( $ n ) { $ countV = 0 ; for ( $ i = 0 ; $ i <= $ n ; $ i ++ ) if ( ( $ n + $ i ) == ( $ n ^ $ i ) ) $ countV ++ ; return $ countV ; }
function countValues ( $ n ) { $ unset_bits = 0 ; while ( $ n ) { if ( ( $ n & 1 ) == 0 ) $ unset_bits ++ ; $ n = $ n >> 1 ; } return 1 << $ unset_bits ; }
function maxConsecutiveOnes ( $ x ) { $ count = 0 ; while ( $ x != 0 ) { $ x = ( $ x & ( $ x << 1 ) ) ; $ count ++ ; } return $ count ; }
function swapThree ( & $ a , & $ b , & $ c ) { $ a = $ a ^ $ b ^ $ c ; $ b = $ a ^ $ b ^ $ c ; $ c = $ a ^ $ b ^ $ c ; $ a = $ a ^ $ b ^ $ c ; }
function findProffesion ( $ level , $ pos ) { if ( $ level == 1 ) return ' e ' ; if ( findProffesion ( $ level - 1 , ( $ pos + 1 ) / 2 ) == ' d ' ) return ( $ pos % 2 ) ? ' d ' : ' e ' ; return ( $ pos % 2 ) ? ' e ' : ' d ' ; }
function printTwoSetBitNums ( $ n ) { $ x = 1 ; while ( $ n > 0 ) { $ y = 0 ; while ( $ y < $ x ) { echo ( 1 << $ x ) + ( 1 << $ y ) , " ▁ " ; $ n -- ; if ( $ n == 0 ) return ; $ y ++ ; } $ x ++ ; } }
function countStrings ( $ n ) { $ a [ $ n ] = 0 ; $ b [ $ n ] = 0 ; $ a [ 0 ] = $ b [ 0 ] = 1 ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) { $ a [ $ i ] = $ a [ $ i - 1 ] + $ b [ $ i - 1 ] ; $ b [ $ i ] = $ a [ $ i - 1 ] ; } return ( 1 << $ n ) - $ a [ $ n - 1 ] - $ b [ $ n - 1 ] ; }
function findXOR ( $ Set , $ n ) { if ( $ n == 1 ) return $ Set [ 0 ] ; else return 0 ; }
function myXOR ( $ x , $ y ) { return ( $ x $ y ) & ( ~ $ x ~ $ y ) ; }
function multiplyBySevenByEight ( $ n ) { return ( $ n - ( $ n >> 3 ) ) ; }
function subtract ( $ x , $ y ) { while ( $ y != 0 ) { $ borrow = ( ~ $ x ) & $ y ; $ x = $ x ^ $ y ; $ y = $ borrow << 1 ; } return $ x ; }
function subtract ( $ x , $ y ) { if ( $ y == 0 ) return $ x ; return subtract ( $ x ^ $ y , ( ~ $ x & $ y ) << 1 ) ; }
function square ( $ n ) { if ( $ n < 0 ) $ n = - $ n ; $ res = $ n ; for ( $ i = 1 ; $ i < $ n ; $ i ++ ) $ res += $ n ; return $ res ; }
function nextPowerOf2 ( $ n ) { $ count = 0 ; if ( $ n && ! ( $ n & ( $ n - 1 ) ) ) return $ n ; while ( $ n != 0 ) { $ n >>= 1 ; $ count += 1 ; } return 1 << $ count ; }
